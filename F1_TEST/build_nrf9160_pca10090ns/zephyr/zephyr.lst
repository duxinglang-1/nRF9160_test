
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

0001c200 <_vector_table>:
   1c200:	200288a0 	.word	0x200288a0
   1c204:	000252e5 	.word	0x000252e5
   1c208:	00038017 	.word	0x00038017
   1c20c:	00024f41 	.word	0x00024f41
   1c210:	00024f41 	.word	0x00024f41
   1c214:	00024f41 	.word	0x00024f41
   1c218:	00024f41 	.word	0x00024f41
   1c21c:	00024f41 	.word	0x00024f41
   1c220:	00024f41 	.word	0x00024f41
   1c224:	00024f41 	.word	0x00024f41
   1c228:	00024f41 	.word	0x00024f41
   1c22c:	00024f09 	.word	0x00024f09
   1c230:	00024f41 	.word	0x00024f41
   1c234:	00024f41 	.word	0x00024f41
   1c238:	00024e45 	.word	0x00024e45
   1c23c:	00024975 	.word	0x00024975

0001c240 <_irq_vector_table>:
   1c240:	00024f5d 00024f5d 00024f5d 00024f5d     ]O..]O..]O..]O..
   1c250:	00024f5d 00024f5d 00024f5d 00024f5d     ]O..]O..]O..]O..
   1c260:	00024f5d 00024f5d 00024f5d 00024f5d     ]O..]O..]O..]O..
   1c270:	00024f5d 00024f5d 00024f5d 00024f5d     ]O..]O..]O..]O..
   1c280:	00024f5d 00024f5d 00024f5d 00024f5d     ]O..]O..]O..]O..
   1c290:	00024f5d 00024f5d 00024f5d 00024f5d     ]O..]O..]O..]O..
   1c2a0:	00024f5d 00024f5d 00024f5d 00024f5d     ]O..]O..]O..]O..
   1c2b0:	000278f1 00038ea9 00024f5d 00024f5d     .x......]O..]O..
   1c2c0:	00024f5d 00024f5d 00024f5d 00024f5d     ]O..]O..]O..]O..
   1c2d0:	00024f5d 00024f5d 00024f5d 00024f5d     ]O..]O..]O..]O..
   1c2e0:	00024f5d 00024f5d 00038ec7 00024f5d     ]O..]O......]O..
   1c2f0:	00024f5d 00024f5d 00024f5d 00024f5d     ]O..]O..]O..]O..
   1c300:	00024f5d 00024f5d 00024f5d 00024f5d     ]O..]O..]O..]O..
   1c310:	00024f5d 00024f5d 00024f5d 00024f5d     ]O..]O..]O..]O..
   1c320:	00024f5d 00024f5d 00024f5d 00024f5d     ]O..]O..]O..]O..
   1c330:	00024f5d 00024f5d 00024f5d 00024f5d     ]O..]O..]O..]O..
   1c340:	00024f5d                                ]O..

0001c344 <_vector_end>:
	...

0001c400 <m_firmware_info>:
   1c400:	281ee6de 8fcebb4c 00005b02 0000003c     ...(L....[..<...
   1c410:	0002532c 00000001 0001c200 0001c200     ,S..............
   1c420:	9102ffff 00000000 00000000 00000000     ................
	...

Disassembly of section text:

0001c440 <__aeabi_drsub>:
   1c440:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   1c444:	e002      	b.n	1c44c <__adddf3>
   1c446:	bf00      	nop

0001c448 <__aeabi_dsub>:
   1c448:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0001c44c <__adddf3>:
   1c44c:	b530      	push	{r4, r5, lr}
   1c44e:	ea4f 0441 	mov.w	r4, r1, lsl #1
   1c452:	ea4f 0543 	mov.w	r5, r3, lsl #1
   1c456:	ea94 0f05 	teq	r4, r5
   1c45a:	bf08      	it	eq
   1c45c:	ea90 0f02 	teqeq	r0, r2
   1c460:	bf1f      	itttt	ne
   1c462:	ea54 0c00 	orrsne.w	ip, r4, r0
   1c466:	ea55 0c02 	orrsne.w	ip, r5, r2
   1c46a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   1c46e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   1c472:	f000 80e2 	beq.w	1c63a <__adddf3+0x1ee>
   1c476:	ea4f 5454 	mov.w	r4, r4, lsr #21
   1c47a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   1c47e:	bfb8      	it	lt
   1c480:	426d      	neglt	r5, r5
   1c482:	dd0c      	ble.n	1c49e <__adddf3+0x52>
   1c484:	442c      	add	r4, r5
   1c486:	ea80 0202 	eor.w	r2, r0, r2
   1c48a:	ea81 0303 	eor.w	r3, r1, r3
   1c48e:	ea82 0000 	eor.w	r0, r2, r0
   1c492:	ea83 0101 	eor.w	r1, r3, r1
   1c496:	ea80 0202 	eor.w	r2, r0, r2
   1c49a:	ea81 0303 	eor.w	r3, r1, r3
   1c49e:	2d36      	cmp	r5, #54	; 0x36
   1c4a0:	bf88      	it	hi
   1c4a2:	bd30      	pophi	{r4, r5, pc}
   1c4a4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   1c4a8:	ea4f 3101 	mov.w	r1, r1, lsl #12
   1c4ac:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   1c4b0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   1c4b4:	d002      	beq.n	1c4bc <__adddf3+0x70>
   1c4b6:	4240      	negs	r0, r0
   1c4b8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1c4bc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   1c4c0:	ea4f 3303 	mov.w	r3, r3, lsl #12
   1c4c4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   1c4c8:	d002      	beq.n	1c4d0 <__adddf3+0x84>
   1c4ca:	4252      	negs	r2, r2
   1c4cc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   1c4d0:	ea94 0f05 	teq	r4, r5
   1c4d4:	f000 80a7 	beq.w	1c626 <__adddf3+0x1da>
   1c4d8:	f1a4 0401 	sub.w	r4, r4, #1
   1c4dc:	f1d5 0e20 	rsbs	lr, r5, #32
   1c4e0:	db0d      	blt.n	1c4fe <__adddf3+0xb2>
   1c4e2:	fa02 fc0e 	lsl.w	ip, r2, lr
   1c4e6:	fa22 f205 	lsr.w	r2, r2, r5
   1c4ea:	1880      	adds	r0, r0, r2
   1c4ec:	f141 0100 	adc.w	r1, r1, #0
   1c4f0:	fa03 f20e 	lsl.w	r2, r3, lr
   1c4f4:	1880      	adds	r0, r0, r2
   1c4f6:	fa43 f305 	asr.w	r3, r3, r5
   1c4fa:	4159      	adcs	r1, r3
   1c4fc:	e00e      	b.n	1c51c <__adddf3+0xd0>
   1c4fe:	f1a5 0520 	sub.w	r5, r5, #32
   1c502:	f10e 0e20 	add.w	lr, lr, #32
   1c506:	2a01      	cmp	r2, #1
   1c508:	fa03 fc0e 	lsl.w	ip, r3, lr
   1c50c:	bf28      	it	cs
   1c50e:	f04c 0c02 	orrcs.w	ip, ip, #2
   1c512:	fa43 f305 	asr.w	r3, r3, r5
   1c516:	18c0      	adds	r0, r0, r3
   1c518:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   1c51c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   1c520:	d507      	bpl.n	1c532 <__adddf3+0xe6>
   1c522:	f04f 0e00 	mov.w	lr, #0
   1c526:	f1dc 0c00 	rsbs	ip, ip, #0
   1c52a:	eb7e 0000 	sbcs.w	r0, lr, r0
   1c52e:	eb6e 0101 	sbc.w	r1, lr, r1
   1c532:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   1c536:	d31b      	bcc.n	1c570 <__adddf3+0x124>
   1c538:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   1c53c:	d30c      	bcc.n	1c558 <__adddf3+0x10c>
   1c53e:	0849      	lsrs	r1, r1, #1
   1c540:	ea5f 0030 	movs.w	r0, r0, rrx
   1c544:	ea4f 0c3c 	mov.w	ip, ip, rrx
   1c548:	f104 0401 	add.w	r4, r4, #1
   1c54c:	ea4f 5244 	mov.w	r2, r4, lsl #21
   1c550:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   1c554:	f080 809a 	bcs.w	1c68c <__adddf3+0x240>
   1c558:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   1c55c:	bf08      	it	eq
   1c55e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   1c562:	f150 0000 	adcs.w	r0, r0, #0
   1c566:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   1c56a:	ea41 0105 	orr.w	r1, r1, r5
   1c56e:	bd30      	pop	{r4, r5, pc}
   1c570:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   1c574:	4140      	adcs	r0, r0
   1c576:	eb41 0101 	adc.w	r1, r1, r1
   1c57a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   1c57e:	f1a4 0401 	sub.w	r4, r4, #1
   1c582:	d1e9      	bne.n	1c558 <__adddf3+0x10c>
   1c584:	f091 0f00 	teq	r1, #0
   1c588:	bf04      	itt	eq
   1c58a:	4601      	moveq	r1, r0
   1c58c:	2000      	moveq	r0, #0
   1c58e:	fab1 f381 	clz	r3, r1
   1c592:	bf08      	it	eq
   1c594:	3320      	addeq	r3, #32
   1c596:	f1a3 030b 	sub.w	r3, r3, #11
   1c59a:	f1b3 0220 	subs.w	r2, r3, #32
   1c59e:	da0c      	bge.n	1c5ba <__adddf3+0x16e>
   1c5a0:	320c      	adds	r2, #12
   1c5a2:	dd08      	ble.n	1c5b6 <__adddf3+0x16a>
   1c5a4:	f102 0c14 	add.w	ip, r2, #20
   1c5a8:	f1c2 020c 	rsb	r2, r2, #12
   1c5ac:	fa01 f00c 	lsl.w	r0, r1, ip
   1c5b0:	fa21 f102 	lsr.w	r1, r1, r2
   1c5b4:	e00c      	b.n	1c5d0 <__adddf3+0x184>
   1c5b6:	f102 0214 	add.w	r2, r2, #20
   1c5ba:	bfd8      	it	le
   1c5bc:	f1c2 0c20 	rsble	ip, r2, #32
   1c5c0:	fa01 f102 	lsl.w	r1, r1, r2
   1c5c4:	fa20 fc0c 	lsr.w	ip, r0, ip
   1c5c8:	bfdc      	itt	le
   1c5ca:	ea41 010c 	orrle.w	r1, r1, ip
   1c5ce:	4090      	lslle	r0, r2
   1c5d0:	1ae4      	subs	r4, r4, r3
   1c5d2:	bfa2      	ittt	ge
   1c5d4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   1c5d8:	4329      	orrge	r1, r5
   1c5da:	bd30      	popge	{r4, r5, pc}
   1c5dc:	ea6f 0404 	mvn.w	r4, r4
   1c5e0:	3c1f      	subs	r4, #31
   1c5e2:	da1c      	bge.n	1c61e <__adddf3+0x1d2>
   1c5e4:	340c      	adds	r4, #12
   1c5e6:	dc0e      	bgt.n	1c606 <__adddf3+0x1ba>
   1c5e8:	f104 0414 	add.w	r4, r4, #20
   1c5ec:	f1c4 0220 	rsb	r2, r4, #32
   1c5f0:	fa20 f004 	lsr.w	r0, r0, r4
   1c5f4:	fa01 f302 	lsl.w	r3, r1, r2
   1c5f8:	ea40 0003 	orr.w	r0, r0, r3
   1c5fc:	fa21 f304 	lsr.w	r3, r1, r4
   1c600:	ea45 0103 	orr.w	r1, r5, r3
   1c604:	bd30      	pop	{r4, r5, pc}
   1c606:	f1c4 040c 	rsb	r4, r4, #12
   1c60a:	f1c4 0220 	rsb	r2, r4, #32
   1c60e:	fa20 f002 	lsr.w	r0, r0, r2
   1c612:	fa01 f304 	lsl.w	r3, r1, r4
   1c616:	ea40 0003 	orr.w	r0, r0, r3
   1c61a:	4629      	mov	r1, r5
   1c61c:	bd30      	pop	{r4, r5, pc}
   1c61e:	fa21 f004 	lsr.w	r0, r1, r4
   1c622:	4629      	mov	r1, r5
   1c624:	bd30      	pop	{r4, r5, pc}
   1c626:	f094 0f00 	teq	r4, #0
   1c62a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   1c62e:	bf06      	itte	eq
   1c630:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   1c634:	3401      	addeq	r4, #1
   1c636:	3d01      	subne	r5, #1
   1c638:	e74e      	b.n	1c4d8 <__adddf3+0x8c>
   1c63a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   1c63e:	bf18      	it	ne
   1c640:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   1c644:	d029      	beq.n	1c69a <__adddf3+0x24e>
   1c646:	ea94 0f05 	teq	r4, r5
   1c64a:	bf08      	it	eq
   1c64c:	ea90 0f02 	teqeq	r0, r2
   1c650:	d005      	beq.n	1c65e <__adddf3+0x212>
   1c652:	ea54 0c00 	orrs.w	ip, r4, r0
   1c656:	bf04      	itt	eq
   1c658:	4619      	moveq	r1, r3
   1c65a:	4610      	moveq	r0, r2
   1c65c:	bd30      	pop	{r4, r5, pc}
   1c65e:	ea91 0f03 	teq	r1, r3
   1c662:	bf1e      	ittt	ne
   1c664:	2100      	movne	r1, #0
   1c666:	2000      	movne	r0, #0
   1c668:	bd30      	popne	{r4, r5, pc}
   1c66a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   1c66e:	d105      	bne.n	1c67c <__adddf3+0x230>
   1c670:	0040      	lsls	r0, r0, #1
   1c672:	4149      	adcs	r1, r1
   1c674:	bf28      	it	cs
   1c676:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   1c67a:	bd30      	pop	{r4, r5, pc}
   1c67c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   1c680:	bf3c      	itt	cc
   1c682:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   1c686:	bd30      	popcc	{r4, r5, pc}
   1c688:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   1c68c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   1c690:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   1c694:	f04f 0000 	mov.w	r0, #0
   1c698:	bd30      	pop	{r4, r5, pc}
   1c69a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   1c69e:	bf1a      	itte	ne
   1c6a0:	4619      	movne	r1, r3
   1c6a2:	4610      	movne	r0, r2
   1c6a4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   1c6a8:	bf1c      	itt	ne
   1c6aa:	460b      	movne	r3, r1
   1c6ac:	4602      	movne	r2, r0
   1c6ae:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   1c6b2:	bf06      	itte	eq
   1c6b4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   1c6b8:	ea91 0f03 	teqeq	r1, r3
   1c6bc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   1c6c0:	bd30      	pop	{r4, r5, pc}
   1c6c2:	bf00      	nop

0001c6c4 <__aeabi_ui2d>:
   1c6c4:	f090 0f00 	teq	r0, #0
   1c6c8:	bf04      	itt	eq
   1c6ca:	2100      	moveq	r1, #0
   1c6cc:	4770      	bxeq	lr
   1c6ce:	b530      	push	{r4, r5, lr}
   1c6d0:	f44f 6480 	mov.w	r4, #1024	; 0x400
   1c6d4:	f104 0432 	add.w	r4, r4, #50	; 0x32
   1c6d8:	f04f 0500 	mov.w	r5, #0
   1c6dc:	f04f 0100 	mov.w	r1, #0
   1c6e0:	e750      	b.n	1c584 <__adddf3+0x138>
   1c6e2:	bf00      	nop

0001c6e4 <__aeabi_i2d>:
   1c6e4:	f090 0f00 	teq	r0, #0
   1c6e8:	bf04      	itt	eq
   1c6ea:	2100      	moveq	r1, #0
   1c6ec:	4770      	bxeq	lr
   1c6ee:	b530      	push	{r4, r5, lr}
   1c6f0:	f44f 6480 	mov.w	r4, #1024	; 0x400
   1c6f4:	f104 0432 	add.w	r4, r4, #50	; 0x32
   1c6f8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   1c6fc:	bf48      	it	mi
   1c6fe:	4240      	negmi	r0, r0
   1c700:	f04f 0100 	mov.w	r1, #0
   1c704:	e73e      	b.n	1c584 <__adddf3+0x138>
   1c706:	bf00      	nop

0001c708 <__aeabi_f2d>:
   1c708:	0042      	lsls	r2, r0, #1
   1c70a:	ea4f 01e2 	mov.w	r1, r2, asr #3
   1c70e:	ea4f 0131 	mov.w	r1, r1, rrx
   1c712:	ea4f 7002 	mov.w	r0, r2, lsl #28
   1c716:	bf1f      	itttt	ne
   1c718:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   1c71c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   1c720:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   1c724:	4770      	bxne	lr
   1c726:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   1c72a:	bf08      	it	eq
   1c72c:	4770      	bxeq	lr
   1c72e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
   1c732:	bf04      	itt	eq
   1c734:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
   1c738:	4770      	bxeq	lr
   1c73a:	b530      	push	{r4, r5, lr}
   1c73c:	f44f 7460 	mov.w	r4, #896	; 0x380
   1c740:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   1c744:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   1c748:	e71c      	b.n	1c584 <__adddf3+0x138>
   1c74a:	bf00      	nop

0001c74c <__aeabi_ul2d>:
   1c74c:	ea50 0201 	orrs.w	r2, r0, r1
   1c750:	bf08      	it	eq
   1c752:	4770      	bxeq	lr
   1c754:	b530      	push	{r4, r5, lr}
   1c756:	f04f 0500 	mov.w	r5, #0
   1c75a:	e00a      	b.n	1c772 <__aeabi_l2d+0x16>

0001c75c <__aeabi_l2d>:
   1c75c:	ea50 0201 	orrs.w	r2, r0, r1
   1c760:	bf08      	it	eq
   1c762:	4770      	bxeq	lr
   1c764:	b530      	push	{r4, r5, lr}
   1c766:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   1c76a:	d502      	bpl.n	1c772 <__aeabi_l2d+0x16>
   1c76c:	4240      	negs	r0, r0
   1c76e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1c772:	f44f 6480 	mov.w	r4, #1024	; 0x400
   1c776:	f104 0432 	add.w	r4, r4, #50	; 0x32
   1c77a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   1c77e:	f43f aed8 	beq.w	1c532 <__adddf3+0xe6>
   1c782:	f04f 0203 	mov.w	r2, #3
   1c786:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   1c78a:	bf18      	it	ne
   1c78c:	3203      	addne	r2, #3
   1c78e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   1c792:	bf18      	it	ne
   1c794:	3203      	addne	r2, #3
   1c796:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   1c79a:	f1c2 0320 	rsb	r3, r2, #32
   1c79e:	fa00 fc03 	lsl.w	ip, r0, r3
   1c7a2:	fa20 f002 	lsr.w	r0, r0, r2
   1c7a6:	fa01 fe03 	lsl.w	lr, r1, r3
   1c7aa:	ea40 000e 	orr.w	r0, r0, lr
   1c7ae:	fa21 f102 	lsr.w	r1, r1, r2
   1c7b2:	4414      	add	r4, r2
   1c7b4:	e6bd      	b.n	1c532 <__adddf3+0xe6>
   1c7b6:	bf00      	nop

0001c7b8 <__aeabi_dmul>:
   1c7b8:	b570      	push	{r4, r5, r6, lr}
   1c7ba:	f04f 0cff 	mov.w	ip, #255	; 0xff
   1c7be:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   1c7c2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   1c7c6:	bf1d      	ittte	ne
   1c7c8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   1c7cc:	ea94 0f0c 	teqne	r4, ip
   1c7d0:	ea95 0f0c 	teqne	r5, ip
   1c7d4:	f000 f8de 	bleq	1c994 <__aeabi_dmul+0x1dc>
   1c7d8:	442c      	add	r4, r5
   1c7da:	ea81 0603 	eor.w	r6, r1, r3
   1c7de:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   1c7e2:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   1c7e6:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   1c7ea:	bf18      	it	ne
   1c7ec:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   1c7f0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1c7f4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   1c7f8:	d038      	beq.n	1c86c <__aeabi_dmul+0xb4>
   1c7fa:	fba0 ce02 	umull	ip, lr, r0, r2
   1c7fe:	f04f 0500 	mov.w	r5, #0
   1c802:	fbe1 e502 	umlal	lr, r5, r1, r2
   1c806:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   1c80a:	fbe0 e503 	umlal	lr, r5, r0, r3
   1c80e:	f04f 0600 	mov.w	r6, #0
   1c812:	fbe1 5603 	umlal	r5, r6, r1, r3
   1c816:	f09c 0f00 	teq	ip, #0
   1c81a:	bf18      	it	ne
   1c81c:	f04e 0e01 	orrne.w	lr, lr, #1
   1c820:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   1c824:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   1c828:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   1c82c:	d204      	bcs.n	1c838 <__aeabi_dmul+0x80>
   1c82e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   1c832:	416d      	adcs	r5, r5
   1c834:	eb46 0606 	adc.w	r6, r6, r6
   1c838:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   1c83c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   1c840:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   1c844:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   1c848:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   1c84c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   1c850:	bf88      	it	hi
   1c852:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   1c856:	d81e      	bhi.n	1c896 <__aeabi_dmul+0xde>
   1c858:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   1c85c:	bf08      	it	eq
   1c85e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   1c862:	f150 0000 	adcs.w	r0, r0, #0
   1c866:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   1c86a:	bd70      	pop	{r4, r5, r6, pc}
   1c86c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   1c870:	ea46 0101 	orr.w	r1, r6, r1
   1c874:	ea40 0002 	orr.w	r0, r0, r2
   1c878:	ea81 0103 	eor.w	r1, r1, r3
   1c87c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   1c880:	bfc2      	ittt	gt
   1c882:	ebd4 050c 	rsbsgt	r5, r4, ip
   1c886:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   1c88a:	bd70      	popgt	{r4, r5, r6, pc}
   1c88c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1c890:	f04f 0e00 	mov.w	lr, #0
   1c894:	3c01      	subs	r4, #1
   1c896:	f300 80ab 	bgt.w	1c9f0 <__aeabi_dmul+0x238>
   1c89a:	f114 0f36 	cmn.w	r4, #54	; 0x36
   1c89e:	bfde      	ittt	le
   1c8a0:	2000      	movle	r0, #0
   1c8a2:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   1c8a6:	bd70      	pople	{r4, r5, r6, pc}
   1c8a8:	f1c4 0400 	rsb	r4, r4, #0
   1c8ac:	3c20      	subs	r4, #32
   1c8ae:	da35      	bge.n	1c91c <__aeabi_dmul+0x164>
   1c8b0:	340c      	adds	r4, #12
   1c8b2:	dc1b      	bgt.n	1c8ec <__aeabi_dmul+0x134>
   1c8b4:	f104 0414 	add.w	r4, r4, #20
   1c8b8:	f1c4 0520 	rsb	r5, r4, #32
   1c8bc:	fa00 f305 	lsl.w	r3, r0, r5
   1c8c0:	fa20 f004 	lsr.w	r0, r0, r4
   1c8c4:	fa01 f205 	lsl.w	r2, r1, r5
   1c8c8:	ea40 0002 	orr.w	r0, r0, r2
   1c8cc:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   1c8d0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   1c8d4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   1c8d8:	fa21 f604 	lsr.w	r6, r1, r4
   1c8dc:	eb42 0106 	adc.w	r1, r2, r6
   1c8e0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   1c8e4:	bf08      	it	eq
   1c8e6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   1c8ea:	bd70      	pop	{r4, r5, r6, pc}
   1c8ec:	f1c4 040c 	rsb	r4, r4, #12
   1c8f0:	f1c4 0520 	rsb	r5, r4, #32
   1c8f4:	fa00 f304 	lsl.w	r3, r0, r4
   1c8f8:	fa20 f005 	lsr.w	r0, r0, r5
   1c8fc:	fa01 f204 	lsl.w	r2, r1, r4
   1c900:	ea40 0002 	orr.w	r0, r0, r2
   1c904:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   1c908:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   1c90c:	f141 0100 	adc.w	r1, r1, #0
   1c910:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   1c914:	bf08      	it	eq
   1c916:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   1c91a:	bd70      	pop	{r4, r5, r6, pc}
   1c91c:	f1c4 0520 	rsb	r5, r4, #32
   1c920:	fa00 f205 	lsl.w	r2, r0, r5
   1c924:	ea4e 0e02 	orr.w	lr, lr, r2
   1c928:	fa20 f304 	lsr.w	r3, r0, r4
   1c92c:	fa01 f205 	lsl.w	r2, r1, r5
   1c930:	ea43 0302 	orr.w	r3, r3, r2
   1c934:	fa21 f004 	lsr.w	r0, r1, r4
   1c938:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   1c93c:	fa21 f204 	lsr.w	r2, r1, r4
   1c940:	ea20 0002 	bic.w	r0, r0, r2
   1c944:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   1c948:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   1c94c:	bf08      	it	eq
   1c94e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   1c952:	bd70      	pop	{r4, r5, r6, pc}
   1c954:	f094 0f00 	teq	r4, #0
   1c958:	d10f      	bne.n	1c97a <__aeabi_dmul+0x1c2>
   1c95a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   1c95e:	0040      	lsls	r0, r0, #1
   1c960:	eb41 0101 	adc.w	r1, r1, r1
   1c964:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   1c968:	bf08      	it	eq
   1c96a:	3c01      	subeq	r4, #1
   1c96c:	d0f7      	beq.n	1c95e <__aeabi_dmul+0x1a6>
   1c96e:	ea41 0106 	orr.w	r1, r1, r6
   1c972:	f095 0f00 	teq	r5, #0
   1c976:	bf18      	it	ne
   1c978:	4770      	bxne	lr
   1c97a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   1c97e:	0052      	lsls	r2, r2, #1
   1c980:	eb43 0303 	adc.w	r3, r3, r3
   1c984:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   1c988:	bf08      	it	eq
   1c98a:	3d01      	subeq	r5, #1
   1c98c:	d0f7      	beq.n	1c97e <__aeabi_dmul+0x1c6>
   1c98e:	ea43 0306 	orr.w	r3, r3, r6
   1c992:	4770      	bx	lr
   1c994:	ea94 0f0c 	teq	r4, ip
   1c998:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   1c99c:	bf18      	it	ne
   1c99e:	ea95 0f0c 	teqne	r5, ip
   1c9a2:	d00c      	beq.n	1c9be <__aeabi_dmul+0x206>
   1c9a4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   1c9a8:	bf18      	it	ne
   1c9aa:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   1c9ae:	d1d1      	bne.n	1c954 <__aeabi_dmul+0x19c>
   1c9b0:	ea81 0103 	eor.w	r1, r1, r3
   1c9b4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   1c9b8:	f04f 0000 	mov.w	r0, #0
   1c9bc:	bd70      	pop	{r4, r5, r6, pc}
   1c9be:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   1c9c2:	bf06      	itte	eq
   1c9c4:	4610      	moveq	r0, r2
   1c9c6:	4619      	moveq	r1, r3
   1c9c8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   1c9cc:	d019      	beq.n	1ca02 <__aeabi_dmul+0x24a>
   1c9ce:	ea94 0f0c 	teq	r4, ip
   1c9d2:	d102      	bne.n	1c9da <__aeabi_dmul+0x222>
   1c9d4:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   1c9d8:	d113      	bne.n	1ca02 <__aeabi_dmul+0x24a>
   1c9da:	ea95 0f0c 	teq	r5, ip
   1c9de:	d105      	bne.n	1c9ec <__aeabi_dmul+0x234>
   1c9e0:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   1c9e4:	bf1c      	itt	ne
   1c9e6:	4610      	movne	r0, r2
   1c9e8:	4619      	movne	r1, r3
   1c9ea:	d10a      	bne.n	1ca02 <__aeabi_dmul+0x24a>
   1c9ec:	ea81 0103 	eor.w	r1, r1, r3
   1c9f0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   1c9f4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   1c9f8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   1c9fc:	f04f 0000 	mov.w	r0, #0
   1ca00:	bd70      	pop	{r4, r5, r6, pc}
   1ca02:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   1ca06:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   1ca0a:	bd70      	pop	{r4, r5, r6, pc}

0001ca0c <__aeabi_ddiv>:
   1ca0c:	b570      	push	{r4, r5, r6, lr}
   1ca0e:	f04f 0cff 	mov.w	ip, #255	; 0xff
   1ca12:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   1ca16:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   1ca1a:	bf1d      	ittte	ne
   1ca1c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   1ca20:	ea94 0f0c 	teqne	r4, ip
   1ca24:	ea95 0f0c 	teqne	r5, ip
   1ca28:	f000 f8a7 	bleq	1cb7a <__aeabi_ddiv+0x16e>
   1ca2c:	eba4 0405 	sub.w	r4, r4, r5
   1ca30:	ea81 0e03 	eor.w	lr, r1, r3
   1ca34:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   1ca38:	ea4f 3101 	mov.w	r1, r1, lsl #12
   1ca3c:	f000 8088 	beq.w	1cb50 <__aeabi_ddiv+0x144>
   1ca40:	ea4f 3303 	mov.w	r3, r3, lsl #12
   1ca44:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   1ca48:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   1ca4c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   1ca50:	ea4f 2202 	mov.w	r2, r2, lsl #8
   1ca54:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   1ca58:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   1ca5c:	ea4f 2600 	mov.w	r6, r0, lsl #8
   1ca60:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   1ca64:	429d      	cmp	r5, r3
   1ca66:	bf08      	it	eq
   1ca68:	4296      	cmpeq	r6, r2
   1ca6a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   1ca6e:	f504 7440 	add.w	r4, r4, #768	; 0x300
   1ca72:	d202      	bcs.n	1ca7a <__aeabi_ddiv+0x6e>
   1ca74:	085b      	lsrs	r3, r3, #1
   1ca76:	ea4f 0232 	mov.w	r2, r2, rrx
   1ca7a:	1ab6      	subs	r6, r6, r2
   1ca7c:	eb65 0503 	sbc.w	r5, r5, r3
   1ca80:	085b      	lsrs	r3, r3, #1
   1ca82:	ea4f 0232 	mov.w	r2, r2, rrx
   1ca86:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   1ca8a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   1ca8e:	ebb6 0e02 	subs.w	lr, r6, r2
   1ca92:	eb75 0e03 	sbcs.w	lr, r5, r3
   1ca96:	bf22      	ittt	cs
   1ca98:	1ab6      	subcs	r6, r6, r2
   1ca9a:	4675      	movcs	r5, lr
   1ca9c:	ea40 000c 	orrcs.w	r0, r0, ip
   1caa0:	085b      	lsrs	r3, r3, #1
   1caa2:	ea4f 0232 	mov.w	r2, r2, rrx
   1caa6:	ebb6 0e02 	subs.w	lr, r6, r2
   1caaa:	eb75 0e03 	sbcs.w	lr, r5, r3
   1caae:	bf22      	ittt	cs
   1cab0:	1ab6      	subcs	r6, r6, r2
   1cab2:	4675      	movcs	r5, lr
   1cab4:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   1cab8:	085b      	lsrs	r3, r3, #1
   1caba:	ea4f 0232 	mov.w	r2, r2, rrx
   1cabe:	ebb6 0e02 	subs.w	lr, r6, r2
   1cac2:	eb75 0e03 	sbcs.w	lr, r5, r3
   1cac6:	bf22      	ittt	cs
   1cac8:	1ab6      	subcs	r6, r6, r2
   1caca:	4675      	movcs	r5, lr
   1cacc:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   1cad0:	085b      	lsrs	r3, r3, #1
   1cad2:	ea4f 0232 	mov.w	r2, r2, rrx
   1cad6:	ebb6 0e02 	subs.w	lr, r6, r2
   1cada:	eb75 0e03 	sbcs.w	lr, r5, r3
   1cade:	bf22      	ittt	cs
   1cae0:	1ab6      	subcs	r6, r6, r2
   1cae2:	4675      	movcs	r5, lr
   1cae4:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   1cae8:	ea55 0e06 	orrs.w	lr, r5, r6
   1caec:	d018      	beq.n	1cb20 <__aeabi_ddiv+0x114>
   1caee:	ea4f 1505 	mov.w	r5, r5, lsl #4
   1caf2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   1caf6:	ea4f 1606 	mov.w	r6, r6, lsl #4
   1cafa:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   1cafe:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   1cb02:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   1cb06:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   1cb0a:	d1c0      	bne.n	1ca8e <__aeabi_ddiv+0x82>
   1cb0c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   1cb10:	d10b      	bne.n	1cb2a <__aeabi_ddiv+0x11e>
   1cb12:	ea41 0100 	orr.w	r1, r1, r0
   1cb16:	f04f 0000 	mov.w	r0, #0
   1cb1a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   1cb1e:	e7b6      	b.n	1ca8e <__aeabi_ddiv+0x82>
   1cb20:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   1cb24:	bf04      	itt	eq
   1cb26:	4301      	orreq	r1, r0
   1cb28:	2000      	moveq	r0, #0
   1cb2a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   1cb2e:	bf88      	it	hi
   1cb30:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   1cb34:	f63f aeaf 	bhi.w	1c896 <__aeabi_dmul+0xde>
   1cb38:	ebb5 0c03 	subs.w	ip, r5, r3
   1cb3c:	bf04      	itt	eq
   1cb3e:	ebb6 0c02 	subseq.w	ip, r6, r2
   1cb42:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   1cb46:	f150 0000 	adcs.w	r0, r0, #0
   1cb4a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   1cb4e:	bd70      	pop	{r4, r5, r6, pc}
   1cb50:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   1cb54:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   1cb58:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   1cb5c:	bfc2      	ittt	gt
   1cb5e:	ebd4 050c 	rsbsgt	r5, r4, ip
   1cb62:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   1cb66:	bd70      	popgt	{r4, r5, r6, pc}
   1cb68:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1cb6c:	f04f 0e00 	mov.w	lr, #0
   1cb70:	3c01      	subs	r4, #1
   1cb72:	e690      	b.n	1c896 <__aeabi_dmul+0xde>
   1cb74:	ea45 0e06 	orr.w	lr, r5, r6
   1cb78:	e68d      	b.n	1c896 <__aeabi_dmul+0xde>
   1cb7a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   1cb7e:	ea94 0f0c 	teq	r4, ip
   1cb82:	bf08      	it	eq
   1cb84:	ea95 0f0c 	teqeq	r5, ip
   1cb88:	f43f af3b 	beq.w	1ca02 <__aeabi_dmul+0x24a>
   1cb8c:	ea94 0f0c 	teq	r4, ip
   1cb90:	d10a      	bne.n	1cba8 <__aeabi_ddiv+0x19c>
   1cb92:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   1cb96:	f47f af34 	bne.w	1ca02 <__aeabi_dmul+0x24a>
   1cb9a:	ea95 0f0c 	teq	r5, ip
   1cb9e:	f47f af25 	bne.w	1c9ec <__aeabi_dmul+0x234>
   1cba2:	4610      	mov	r0, r2
   1cba4:	4619      	mov	r1, r3
   1cba6:	e72c      	b.n	1ca02 <__aeabi_dmul+0x24a>
   1cba8:	ea95 0f0c 	teq	r5, ip
   1cbac:	d106      	bne.n	1cbbc <__aeabi_ddiv+0x1b0>
   1cbae:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   1cbb2:	f43f aefd 	beq.w	1c9b0 <__aeabi_dmul+0x1f8>
   1cbb6:	4610      	mov	r0, r2
   1cbb8:	4619      	mov	r1, r3
   1cbba:	e722      	b.n	1ca02 <__aeabi_dmul+0x24a>
   1cbbc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   1cbc0:	bf18      	it	ne
   1cbc2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   1cbc6:	f47f aec5 	bne.w	1c954 <__aeabi_dmul+0x19c>
   1cbca:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   1cbce:	f47f af0d 	bne.w	1c9ec <__aeabi_dmul+0x234>
   1cbd2:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   1cbd6:	f47f aeeb 	bne.w	1c9b0 <__aeabi_dmul+0x1f8>
   1cbda:	e712      	b.n	1ca02 <__aeabi_dmul+0x24a>

0001cbdc <__gedf2>:
   1cbdc:	f04f 3cff 	mov.w	ip, #4294967295
   1cbe0:	e006      	b.n	1cbf0 <__cmpdf2+0x4>
   1cbe2:	bf00      	nop

0001cbe4 <__ledf2>:
   1cbe4:	f04f 0c01 	mov.w	ip, #1
   1cbe8:	e002      	b.n	1cbf0 <__cmpdf2+0x4>
   1cbea:	bf00      	nop

0001cbec <__cmpdf2>:
   1cbec:	f04f 0c01 	mov.w	ip, #1
   1cbf0:	f84d cd04 	str.w	ip, [sp, #-4]!
   1cbf4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   1cbf8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1cbfc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   1cc00:	bf18      	it	ne
   1cc02:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
   1cc06:	d01b      	beq.n	1cc40 <__cmpdf2+0x54>
   1cc08:	b001      	add	sp, #4
   1cc0a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
   1cc0e:	bf0c      	ite	eq
   1cc10:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
   1cc14:	ea91 0f03 	teqne	r1, r3
   1cc18:	bf02      	ittt	eq
   1cc1a:	ea90 0f02 	teqeq	r0, r2
   1cc1e:	2000      	moveq	r0, #0
   1cc20:	4770      	bxeq	lr
   1cc22:	f110 0f00 	cmn.w	r0, #0
   1cc26:	ea91 0f03 	teq	r1, r3
   1cc2a:	bf58      	it	pl
   1cc2c:	4299      	cmppl	r1, r3
   1cc2e:	bf08      	it	eq
   1cc30:	4290      	cmpeq	r0, r2
   1cc32:	bf2c      	ite	cs
   1cc34:	17d8      	asrcs	r0, r3, #31
   1cc36:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
   1cc3a:	f040 0001 	orr.w	r0, r0, #1
   1cc3e:	4770      	bx	lr
   1cc40:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   1cc44:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1cc48:	d102      	bne.n	1cc50 <__cmpdf2+0x64>
   1cc4a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   1cc4e:	d107      	bne.n	1cc60 <__cmpdf2+0x74>
   1cc50:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   1cc54:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1cc58:	d1d6      	bne.n	1cc08 <__cmpdf2+0x1c>
   1cc5a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   1cc5e:	d0d3      	beq.n	1cc08 <__cmpdf2+0x1c>
   1cc60:	f85d 0b04 	ldr.w	r0, [sp], #4
   1cc64:	4770      	bx	lr
   1cc66:	bf00      	nop

0001cc68 <__aeabi_cdrcmple>:
   1cc68:	4684      	mov	ip, r0
   1cc6a:	4610      	mov	r0, r2
   1cc6c:	4662      	mov	r2, ip
   1cc6e:	468c      	mov	ip, r1
   1cc70:	4619      	mov	r1, r3
   1cc72:	4663      	mov	r3, ip
   1cc74:	e000      	b.n	1cc78 <__aeabi_cdcmpeq>
   1cc76:	bf00      	nop

0001cc78 <__aeabi_cdcmpeq>:
   1cc78:	b501      	push	{r0, lr}
   1cc7a:	f7ff ffb7 	bl	1cbec <__cmpdf2>
   1cc7e:	2800      	cmp	r0, #0
   1cc80:	bf48      	it	mi
   1cc82:	f110 0f00 	cmnmi.w	r0, #0
   1cc86:	bd01      	pop	{r0, pc}

0001cc88 <__aeabi_dcmpeq>:
   1cc88:	f84d ed08 	str.w	lr, [sp, #-8]!
   1cc8c:	f7ff fff4 	bl	1cc78 <__aeabi_cdcmpeq>
   1cc90:	bf0c      	ite	eq
   1cc92:	2001      	moveq	r0, #1
   1cc94:	2000      	movne	r0, #0
   1cc96:	f85d fb08 	ldr.w	pc, [sp], #8
   1cc9a:	bf00      	nop

0001cc9c <__aeabi_dcmplt>:
   1cc9c:	f84d ed08 	str.w	lr, [sp, #-8]!
   1cca0:	f7ff ffea 	bl	1cc78 <__aeabi_cdcmpeq>
   1cca4:	bf34      	ite	cc
   1cca6:	2001      	movcc	r0, #1
   1cca8:	2000      	movcs	r0, #0
   1ccaa:	f85d fb08 	ldr.w	pc, [sp], #8
   1ccae:	bf00      	nop

0001ccb0 <__aeabi_dcmple>:
   1ccb0:	f84d ed08 	str.w	lr, [sp, #-8]!
   1ccb4:	f7ff ffe0 	bl	1cc78 <__aeabi_cdcmpeq>
   1ccb8:	bf94      	ite	ls
   1ccba:	2001      	movls	r0, #1
   1ccbc:	2000      	movhi	r0, #0
   1ccbe:	f85d fb08 	ldr.w	pc, [sp], #8
   1ccc2:	bf00      	nop

0001ccc4 <__aeabi_dcmpge>:
   1ccc4:	f84d ed08 	str.w	lr, [sp, #-8]!
   1ccc8:	f7ff ffce 	bl	1cc68 <__aeabi_cdrcmple>
   1cccc:	bf94      	ite	ls
   1ccce:	2001      	movls	r0, #1
   1ccd0:	2000      	movhi	r0, #0
   1ccd2:	f85d fb08 	ldr.w	pc, [sp], #8
   1ccd6:	bf00      	nop

0001ccd8 <__aeabi_dcmpgt>:
   1ccd8:	f84d ed08 	str.w	lr, [sp, #-8]!
   1ccdc:	f7ff ffc4 	bl	1cc68 <__aeabi_cdrcmple>
   1cce0:	bf34      	ite	cc
   1cce2:	2001      	movcc	r0, #1
   1cce4:	2000      	movcs	r0, #0
   1cce6:	f85d fb08 	ldr.w	pc, [sp], #8
   1ccea:	bf00      	nop

0001ccec <__aeabi_d2uiz>:
   1ccec:	004a      	lsls	r2, r1, #1
   1ccee:	d211      	bcs.n	1cd14 <__aeabi_d2uiz+0x28>
   1ccf0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   1ccf4:	d211      	bcs.n	1cd1a <__aeabi_d2uiz+0x2e>
   1ccf6:	d50d      	bpl.n	1cd14 <__aeabi_d2uiz+0x28>
   1ccf8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   1ccfc:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   1cd00:	d40e      	bmi.n	1cd20 <__aeabi_d2uiz+0x34>
   1cd02:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1cd06:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1cd0a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   1cd0e:	fa23 f002 	lsr.w	r0, r3, r2
   1cd12:	4770      	bx	lr
   1cd14:	f04f 0000 	mov.w	r0, #0
   1cd18:	4770      	bx	lr
   1cd1a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   1cd1e:	d102      	bne.n	1cd26 <__aeabi_d2uiz+0x3a>
   1cd20:	f04f 30ff 	mov.w	r0, #4294967295
   1cd24:	4770      	bx	lr
   1cd26:	f04f 0000 	mov.w	r0, #0
   1cd2a:	4770      	bx	lr

0001cd2c <__aeabi_d2f>:
   1cd2c:	ea4f 0241 	mov.w	r2, r1, lsl #1
   1cd30:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   1cd34:	bf24      	itt	cs
   1cd36:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   1cd3a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   1cd3e:	d90d      	bls.n	1cd5c <__aeabi_d2f+0x30>
   1cd40:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   1cd44:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   1cd48:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   1cd4c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   1cd50:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   1cd54:	bf08      	it	eq
   1cd56:	f020 0001 	biceq.w	r0, r0, #1
   1cd5a:	4770      	bx	lr
   1cd5c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   1cd60:	d121      	bne.n	1cda6 <__aeabi_d2f+0x7a>
   1cd62:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   1cd66:	bfbc      	itt	lt
   1cd68:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   1cd6c:	4770      	bxlt	lr
   1cd6e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1cd72:	ea4f 5252 	mov.w	r2, r2, lsr #21
   1cd76:	f1c2 0218 	rsb	r2, r2, #24
   1cd7a:	f1c2 0c20 	rsb	ip, r2, #32
   1cd7e:	fa10 f30c 	lsls.w	r3, r0, ip
   1cd82:	fa20 f002 	lsr.w	r0, r0, r2
   1cd86:	bf18      	it	ne
   1cd88:	f040 0001 	orrne.w	r0, r0, #1
   1cd8c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1cd90:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   1cd94:	fa03 fc0c 	lsl.w	ip, r3, ip
   1cd98:	ea40 000c 	orr.w	r0, r0, ip
   1cd9c:	fa23 f302 	lsr.w	r3, r3, r2
   1cda0:	ea4f 0343 	mov.w	r3, r3, lsl #1
   1cda4:	e7cc      	b.n	1cd40 <__aeabi_d2f+0x14>
   1cda6:	ea7f 5362 	mvns.w	r3, r2, asr #21
   1cdaa:	d107      	bne.n	1cdbc <__aeabi_d2f+0x90>
   1cdac:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   1cdb0:	bf1e      	ittt	ne
   1cdb2:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   1cdb6:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   1cdba:	4770      	bxne	lr
   1cdbc:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   1cdc0:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   1cdc4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   1cdc8:	4770      	bx	lr
   1cdca:	bf00      	nop

0001cdcc <__aeabi_uldivmod>:
   1cdcc:	b953      	cbnz	r3, 1cde4 <__aeabi_uldivmod+0x18>
   1cdce:	b94a      	cbnz	r2, 1cde4 <__aeabi_uldivmod+0x18>
   1cdd0:	2900      	cmp	r1, #0
   1cdd2:	bf08      	it	eq
   1cdd4:	2800      	cmpeq	r0, #0
   1cdd6:	bf1c      	itt	ne
   1cdd8:	f04f 31ff 	movne.w	r1, #4294967295
   1cddc:	f04f 30ff 	movne.w	r0, #4294967295
   1cde0:	f000 b970 	b.w	1d0c4 <__aeabi_idiv0>
   1cde4:	f1ad 0c08 	sub.w	ip, sp, #8
   1cde8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   1cdec:	f000 f806 	bl	1cdfc <__udivmoddi4>
   1cdf0:	f8dd e004 	ldr.w	lr, [sp, #4]
   1cdf4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1cdf8:	b004      	add	sp, #16
   1cdfa:	4770      	bx	lr

0001cdfc <__udivmoddi4>:
   1cdfc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ce00:	9e09      	ldr	r6, [sp, #36]	; 0x24
   1ce02:	4604      	mov	r4, r0
   1ce04:	4689      	mov	r9, r1
   1ce06:	2b00      	cmp	r3, #0
   1ce08:	f040 8083 	bne.w	1cf12 <__udivmoddi4+0x116>
   1ce0c:	428a      	cmp	r2, r1
   1ce0e:	4615      	mov	r5, r2
   1ce10:	d945      	bls.n	1ce9e <__udivmoddi4+0xa2>
   1ce12:	fab2 f282 	clz	r2, r2
   1ce16:	b14a      	cbz	r2, 1ce2c <__udivmoddi4+0x30>
   1ce18:	f1c2 0720 	rsb	r7, r2, #32
   1ce1c:	fa01 f302 	lsl.w	r3, r1, r2
   1ce20:	4095      	lsls	r5, r2
   1ce22:	4094      	lsls	r4, r2
   1ce24:	fa20 f707 	lsr.w	r7, r0, r7
   1ce28:	ea47 0903 	orr.w	r9, r7, r3
   1ce2c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1ce30:	0c23      	lsrs	r3, r4, #16
   1ce32:	fa1f f885 	uxth.w	r8, r5
   1ce36:	fbb9 fcfe 	udiv	ip, r9, lr
   1ce3a:	fb0e 991c 	mls	r9, lr, ip, r9
   1ce3e:	fb0c f108 	mul.w	r1, ip, r8
   1ce42:	ea43 4309 	orr.w	r3, r3, r9, lsl #16
   1ce46:	4299      	cmp	r1, r3
   1ce48:	d90a      	bls.n	1ce60 <__udivmoddi4+0x64>
   1ce4a:	18eb      	adds	r3, r5, r3
   1ce4c:	bf2c      	ite	cs
   1ce4e:	2001      	movcs	r0, #1
   1ce50:	2000      	movcc	r0, #0
   1ce52:	4299      	cmp	r1, r3
   1ce54:	d902      	bls.n	1ce5c <__udivmoddi4+0x60>
   1ce56:	2800      	cmp	r0, #0
   1ce58:	f000 811d 	beq.w	1d096 <__udivmoddi4+0x29a>
   1ce5c:	f10c 3cff 	add.w	ip, ip, #4294967295
   1ce60:	1a59      	subs	r1, r3, r1
   1ce62:	b2a3      	uxth	r3, r4
   1ce64:	fbb1 f0fe 	udiv	r0, r1, lr
   1ce68:	fb0e 1110 	mls	r1, lr, r0, r1
   1ce6c:	fb00 f808 	mul.w	r8, r0, r8
   1ce70:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
   1ce74:	45a0      	cmp	r8, r4
   1ce76:	d905      	bls.n	1ce84 <__udivmoddi4+0x88>
   1ce78:	192c      	adds	r4, r5, r4
   1ce7a:	d202      	bcs.n	1ce82 <__udivmoddi4+0x86>
   1ce7c:	45a0      	cmp	r8, r4
   1ce7e:	f200 810e 	bhi.w	1d09e <__udivmoddi4+0x2a2>
   1ce82:	3801      	subs	r0, #1
   1ce84:	eba4 0408 	sub.w	r4, r4, r8
   1ce88:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   1ce8c:	2700      	movs	r7, #0
   1ce8e:	b11e      	cbz	r6, 1ce98 <__udivmoddi4+0x9c>
   1ce90:	40d4      	lsrs	r4, r2
   1ce92:	2300      	movs	r3, #0
   1ce94:	e9c6 4300 	strd	r4, r3, [r6]
   1ce98:	4639      	mov	r1, r7
   1ce9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ce9e:	2a00      	cmp	r2, #0
   1cea0:	d051      	beq.n	1cf46 <__udivmoddi4+0x14a>
   1cea2:	fab2 f282 	clz	r2, r2
   1cea6:	2a00      	cmp	r2, #0
   1cea8:	f040 80af 	bne.w	1d00a <__udivmoddi4+0x20e>
   1ceac:	1b49      	subs	r1, r1, r5
   1ceae:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1ceb2:	fa1f f885 	uxth.w	r8, r5
   1ceb6:	2701      	movs	r7, #1
   1ceb8:	0c23      	lsrs	r3, r4, #16
   1ceba:	fbb1 fcfe 	udiv	ip, r1, lr
   1cebe:	fb0e 111c 	mls	r1, lr, ip, r1
   1cec2:	fb08 f00c 	mul.w	r0, r8, ip
   1cec6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   1ceca:	4298      	cmp	r0, r3
   1cecc:	d90a      	bls.n	1cee4 <__udivmoddi4+0xe8>
   1cece:	18eb      	adds	r3, r5, r3
   1ced0:	bf2c      	ite	cs
   1ced2:	2101      	movcs	r1, #1
   1ced4:	2100      	movcc	r1, #0
   1ced6:	4298      	cmp	r0, r3
   1ced8:	d902      	bls.n	1cee0 <__udivmoddi4+0xe4>
   1ceda:	2900      	cmp	r1, #0
   1cedc:	f000 80d7 	beq.w	1d08e <__udivmoddi4+0x292>
   1cee0:	f10c 3cff 	add.w	ip, ip, #4294967295
   1cee4:	1a19      	subs	r1, r3, r0
   1cee6:	b2a3      	uxth	r3, r4
   1cee8:	fbb1 f0fe 	udiv	r0, r1, lr
   1ceec:	fb0e 1110 	mls	r1, lr, r0, r1
   1cef0:	fb08 f800 	mul.w	r8, r8, r0
   1cef4:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
   1cef8:	45a0      	cmp	r8, r4
   1cefa:	d905      	bls.n	1cf08 <__udivmoddi4+0x10c>
   1cefc:	192c      	adds	r4, r5, r4
   1cefe:	d202      	bcs.n	1cf06 <__udivmoddi4+0x10a>
   1cf00:	45a0      	cmp	r8, r4
   1cf02:	f200 80c1 	bhi.w	1d088 <__udivmoddi4+0x28c>
   1cf06:	3801      	subs	r0, #1
   1cf08:	eba4 0408 	sub.w	r4, r4, r8
   1cf0c:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   1cf10:	e7bd      	b.n	1ce8e <__udivmoddi4+0x92>
   1cf12:	428b      	cmp	r3, r1
   1cf14:	d908      	bls.n	1cf28 <__udivmoddi4+0x12c>
   1cf16:	2e00      	cmp	r6, #0
   1cf18:	d074      	beq.n	1d004 <__udivmoddi4+0x208>
   1cf1a:	2700      	movs	r7, #0
   1cf1c:	e9c6 0100 	strd	r0, r1, [r6]
   1cf20:	4638      	mov	r0, r7
   1cf22:	4639      	mov	r1, r7
   1cf24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1cf28:	fab3 f783 	clz	r7, r3
   1cf2c:	b967      	cbnz	r7, 1cf48 <__udivmoddi4+0x14c>
   1cf2e:	428b      	cmp	r3, r1
   1cf30:	f0c0 80a4 	bcc.w	1d07c <__udivmoddi4+0x280>
   1cf34:	4282      	cmp	r2, r0
   1cf36:	f240 80a1 	bls.w	1d07c <__udivmoddi4+0x280>
   1cf3a:	4638      	mov	r0, r7
   1cf3c:	2e00      	cmp	r6, #0
   1cf3e:	d0ab      	beq.n	1ce98 <__udivmoddi4+0x9c>
   1cf40:	e9c6 4900 	strd	r4, r9, [r6]
   1cf44:	e7a8      	b.n	1ce98 <__udivmoddi4+0x9c>
   1cf46:	deff      	udf	#255	; 0xff
   1cf48:	f1c7 0520 	rsb	r5, r7, #32
   1cf4c:	40bb      	lsls	r3, r7
   1cf4e:	fa02 fc07 	lsl.w	ip, r2, r7
   1cf52:	fa01 f407 	lsl.w	r4, r1, r7
   1cf56:	40ea      	lsrs	r2, r5
   1cf58:	fa20 f805 	lsr.w	r8, r0, r5
   1cf5c:	40e9      	lsrs	r1, r5
   1cf5e:	fa00 fe07 	lsl.w	lr, r0, r7
   1cf62:	431a      	orrs	r2, r3
   1cf64:	ea48 0404 	orr.w	r4, r8, r4
   1cf68:	ea4f 4812 	mov.w	r8, r2, lsr #16
   1cf6c:	0c20      	lsrs	r0, r4, #16
   1cf6e:	fa1f f982 	uxth.w	r9, r2
   1cf72:	fbb1 faf8 	udiv	sl, r1, r8
   1cf76:	fb08 111a 	mls	r1, r8, sl, r1
   1cf7a:	fb0a fb09 	mul.w	fp, sl, r9
   1cf7e:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
   1cf82:	458b      	cmp	fp, r1
   1cf84:	d90a      	bls.n	1cf9c <__udivmoddi4+0x1a0>
   1cf86:	1851      	adds	r1, r2, r1
   1cf88:	bf2c      	ite	cs
   1cf8a:	2301      	movcs	r3, #1
   1cf8c:	2300      	movcc	r3, #0
   1cf8e:	458b      	cmp	fp, r1
   1cf90:	d902      	bls.n	1cf98 <__udivmoddi4+0x19c>
   1cf92:	2b00      	cmp	r3, #0
   1cf94:	f000 8088 	beq.w	1d0a8 <__udivmoddi4+0x2ac>
   1cf98:	f10a 3aff 	add.w	sl, sl, #4294967295
   1cf9c:	eba1 010b 	sub.w	r1, r1, fp
   1cfa0:	b2a4      	uxth	r4, r4
   1cfa2:	fbb1 f0f8 	udiv	r0, r1, r8
   1cfa6:	fb08 1110 	mls	r1, r8, r0, r1
   1cfaa:	fb00 f909 	mul.w	r9, r0, r9
   1cfae:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
   1cfb2:	4589      	cmp	r9, r1
   1cfb4:	d904      	bls.n	1cfc0 <__udivmoddi4+0x1c4>
   1cfb6:	1851      	adds	r1, r2, r1
   1cfb8:	d201      	bcs.n	1cfbe <__udivmoddi4+0x1c2>
   1cfba:	4589      	cmp	r9, r1
   1cfbc:	d87b      	bhi.n	1d0b6 <__udivmoddi4+0x2ba>
   1cfbe:	3801      	subs	r0, #1
   1cfc0:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
   1cfc4:	eba1 0109 	sub.w	r1, r1, r9
   1cfc8:	fba0 890c 	umull	r8, r9, r0, ip
   1cfcc:	4549      	cmp	r1, r9
   1cfce:	4644      	mov	r4, r8
   1cfd0:	464b      	mov	r3, r9
   1cfd2:	d302      	bcc.n	1cfda <__udivmoddi4+0x1de>
   1cfd4:	d106      	bne.n	1cfe4 <__udivmoddi4+0x1e8>
   1cfd6:	45c6      	cmp	lr, r8
   1cfd8:	d204      	bcs.n	1cfe4 <__udivmoddi4+0x1e8>
   1cfda:	3801      	subs	r0, #1
   1cfdc:	ebb8 040c 	subs.w	r4, r8, ip
   1cfe0:	eb69 0302 	sbc.w	r3, r9, r2
   1cfe4:	2e00      	cmp	r6, #0
   1cfe6:	d05d      	beq.n	1d0a4 <__udivmoddi4+0x2a8>
   1cfe8:	ebbe 0204 	subs.w	r2, lr, r4
   1cfec:	eb61 0103 	sbc.w	r1, r1, r3
   1cff0:	fa01 f505 	lsl.w	r5, r1, r5
   1cff4:	fa22 f307 	lsr.w	r3, r2, r7
   1cff8:	40f9      	lsrs	r1, r7
   1cffa:	2700      	movs	r7, #0
   1cffc:	431d      	orrs	r5, r3
   1cffe:	e9c6 5100 	strd	r5, r1, [r6]
   1d002:	e749      	b.n	1ce98 <__udivmoddi4+0x9c>
   1d004:	4637      	mov	r7, r6
   1d006:	4630      	mov	r0, r6
   1d008:	e746      	b.n	1ce98 <__udivmoddi4+0x9c>
   1d00a:	f1c2 0020 	rsb	r0, r2, #32
   1d00e:	4095      	lsls	r5, r2
   1d010:	fa01 f702 	lsl.w	r7, r1, r2
   1d014:	fa21 f300 	lsr.w	r3, r1, r0
   1d018:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1d01c:	fa24 f100 	lsr.w	r1, r4, r0
   1d020:	fa1f f885 	uxth.w	r8, r5
   1d024:	4094      	lsls	r4, r2
   1d026:	4339      	orrs	r1, r7
   1d028:	fbb3 f0fe 	udiv	r0, r3, lr
   1d02c:	0c0f      	lsrs	r7, r1, #16
   1d02e:	fb0e 3310 	mls	r3, lr, r0, r3
   1d032:	fb00 fc08 	mul.w	ip, r0, r8
   1d036:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
   1d03a:	459c      	cmp	ip, r3
   1d03c:	d907      	bls.n	1d04e <__udivmoddi4+0x252>
   1d03e:	18eb      	adds	r3, r5, r3
   1d040:	bf2c      	ite	cs
   1d042:	2701      	movcs	r7, #1
   1d044:	2700      	movcc	r7, #0
   1d046:	459c      	cmp	ip, r3
   1d048:	d900      	bls.n	1d04c <__udivmoddi4+0x250>
   1d04a:	b38f      	cbz	r7, 1d0b0 <__udivmoddi4+0x2b4>
   1d04c:	3801      	subs	r0, #1
   1d04e:	eba3 030c 	sub.w	r3, r3, ip
   1d052:	b289      	uxth	r1, r1
   1d054:	fbb3 f7fe 	udiv	r7, r3, lr
   1d058:	fb0e 3317 	mls	r3, lr, r7, r3
   1d05c:	fb07 fc08 	mul.w	ip, r7, r8
   1d060:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   1d064:	458c      	cmp	ip, r1
   1d066:	d904      	bls.n	1d072 <__udivmoddi4+0x276>
   1d068:	1869      	adds	r1, r5, r1
   1d06a:	d201      	bcs.n	1d070 <__udivmoddi4+0x274>
   1d06c:	458c      	cmp	ip, r1
   1d06e:	d825      	bhi.n	1d0bc <__udivmoddi4+0x2c0>
   1d070:	3f01      	subs	r7, #1
   1d072:	eba1 010c 	sub.w	r1, r1, ip
   1d076:	ea47 4700 	orr.w	r7, r7, r0, lsl #16
   1d07a:	e71d      	b.n	1ceb8 <__udivmoddi4+0xbc>
   1d07c:	1a84      	subs	r4, r0, r2
   1d07e:	eb61 0303 	sbc.w	r3, r1, r3
   1d082:	2001      	movs	r0, #1
   1d084:	4699      	mov	r9, r3
   1d086:	e759      	b.n	1cf3c <__udivmoddi4+0x140>
   1d088:	3802      	subs	r0, #2
   1d08a:	442c      	add	r4, r5
   1d08c:	e73c      	b.n	1cf08 <__udivmoddi4+0x10c>
   1d08e:	f1ac 0c02 	sub.w	ip, ip, #2
   1d092:	442b      	add	r3, r5
   1d094:	e726      	b.n	1cee4 <__udivmoddi4+0xe8>
   1d096:	f1ac 0c02 	sub.w	ip, ip, #2
   1d09a:	442b      	add	r3, r5
   1d09c:	e6e0      	b.n	1ce60 <__udivmoddi4+0x64>
   1d09e:	3802      	subs	r0, #2
   1d0a0:	442c      	add	r4, r5
   1d0a2:	e6ef      	b.n	1ce84 <__udivmoddi4+0x88>
   1d0a4:	4637      	mov	r7, r6
   1d0a6:	e6f7      	b.n	1ce98 <__udivmoddi4+0x9c>
   1d0a8:	f1aa 0a02 	sub.w	sl, sl, #2
   1d0ac:	4411      	add	r1, r2
   1d0ae:	e775      	b.n	1cf9c <__udivmoddi4+0x1a0>
   1d0b0:	3802      	subs	r0, #2
   1d0b2:	442b      	add	r3, r5
   1d0b4:	e7cb      	b.n	1d04e <__udivmoddi4+0x252>
   1d0b6:	3802      	subs	r0, #2
   1d0b8:	4411      	add	r1, r2
   1d0ba:	e781      	b.n	1cfc0 <__udivmoddi4+0x1c4>
   1d0bc:	3f02      	subs	r7, #2
   1d0be:	4429      	add	r1, r5
   1d0c0:	e7d7      	b.n	1d072 <__udivmoddi4+0x276>
   1d0c2:	bf00      	nop

0001d0c4 <__aeabi_idiv0>:
   1d0c4:	4770      	bx	lr
   1d0c6:	bf00      	nop

0001d0c8 <__aeabi_dcmpun>:
   1d0c8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   1d0cc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1d0d0:	d102      	bne.n	1d0d8 <__aeabi_dcmpun+0x10>
   1d0d2:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   1d0d6:	d10a      	bne.n	1d0ee <__aeabi_dcmpun+0x26>
   1d0d8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   1d0dc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1d0e0:	d102      	bne.n	1d0e8 <__aeabi_dcmpun+0x20>
   1d0e2:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   1d0e6:	d102      	bne.n	1d0ee <__aeabi_dcmpun+0x26>
   1d0e8:	f04f 0000 	mov.w	r0, #0
   1d0ec:	4770      	bx	lr
   1d0ee:	f04f 0001 	mov.w	r0, #1
   1d0f2:	4770      	bx	lr

0001d0f4 <__aeabi_d2iz>:
   1d0f4:	ea4f 0241 	mov.w	r2, r1, lsl #1
   1d0f8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   1d0fc:	d215      	bcs.n	1d12a <__aeabi_d2iz+0x36>
   1d0fe:	d511      	bpl.n	1d124 <__aeabi_d2iz+0x30>
   1d100:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   1d104:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   1d108:	d912      	bls.n	1d130 <__aeabi_d2iz+0x3c>
   1d10a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1d10e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1d112:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   1d116:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   1d11a:	fa23 f002 	lsr.w	r0, r3, r2
   1d11e:	bf18      	it	ne
   1d120:	4240      	negne	r0, r0
   1d122:	4770      	bx	lr
   1d124:	f04f 0000 	mov.w	r0, #0
   1d128:	4770      	bx	lr
   1d12a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   1d12e:	d105      	bne.n	1d13c <__aeabi_d2iz+0x48>
   1d130:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
   1d134:	bf08      	it	eq
   1d136:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   1d13a:	4770      	bx	lr
   1d13c:	f04f 0000 	mov.w	r0, #0
   1d140:	4770      	bx	lr
   1d142:	bf00      	nop

0001d144 <strcmp>:
   1d144:	f810 2b01 	ldrb.w	r2, [r0], #1
   1d148:	f811 3b01 	ldrb.w	r3, [r1], #1
   1d14c:	2a01      	cmp	r2, #1
   1d14e:	bf28      	it	cs
   1d150:	429a      	cmpcs	r2, r3
   1d152:	d0f7      	beq.n	1d144 <strcmp>
   1d154:	1ad0      	subs	r0, r2, r3
   1d156:	4770      	bx	lr

0001d158 <strlen>:
   1d158:	4603      	mov	r3, r0
   1d15a:	f813 2b01 	ldrb.w	r2, [r3], #1
   1d15e:	2a00      	cmp	r2, #0
   1d160:	d1fb      	bne.n	1d15a <strlen+0x2>
   1d162:	1a18      	subs	r0, r3, r0
   1d164:	3801      	subs	r0, #1
   1d166:	4770      	bx	lr

0001d168 <APP_Ask_GPS_Data_timerout>:
}
#endif

void APP_Ask_GPS_Data_timerout(struct k_timer *timer)
{
	u8_t str_gps[20] = {0};
   1d168:	2300      	movs	r3, #0
	u32_t tmp1;
	double tmp2;
	
	APP_wait_gps = false;
   1d16a:	4a4b      	ldr	r2, [pc, #300]	; (1d298 <APP_Ask_GPS_Data_timerout+0x130>)
{
   1d16c:	b5f0      	push	{r4, r5, r6, r7, lr}
	APP_wait_gps = false;
   1d16e:	7013      	strb	r3, [r2, #0]
	app_gps_off = true;
   1d170:	2201      	movs	r2, #1
{
   1d172:	b087      	sub	sp, #28

	//UTC date&time
	//year
	str_gps[0] = last_fix.pvt.datetime.year>>8;
   1d174:	4c49      	ldr	r4, [pc, #292]	; (1d29c <APP_Ask_GPS_Data_timerout+0x134>)
	u8_t str_gps[20] = {0};
   1d176:	9305      	str	r3, [sp, #20]
	app_gps_off = true;
   1d178:	4b49      	ldr	r3, [pc, #292]	; (1d2a0 <APP_Ask_GPS_Data_timerout+0x138>)
	//seconds
	str_gps[6] = last_fix.pvt.datetime.seconds;

	//longitude
	str_gps[7] = 'E';
	if(last_fix.pvt.longitude < 0)
   1d17a:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
	app_gps_off = true;
   1d17e:	701a      	strb	r2, [r3, #0]
	str_gps[0] = last_fix.pvt.datetime.year>>8;
   1d180:	8d23      	ldrh	r3, [r4, #40]	; 0x28
	str_gps[2] = last_fix.pvt.datetime.month;
   1d182:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
	str_gps[0] = last_fix.pvt.datetime.year>>8;
   1d184:	ba5b      	rev16	r3, r3
   1d186:	f8ad 3004 	strh.w	r3, [sp, #4]
	str_gps[6] = last_fix.pvt.datetime.seconds;
   1d18a:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
	str_gps[2] = last_fix.pvt.datetime.month;
   1d18e:	f8ad 2006 	strh.w	r2, [sp, #6]
	str_gps[6] = last_fix.pvt.datetime.seconds;
   1d192:	f88d 300a 	strb.w	r3, [sp, #10]
	str_gps[7] = 'E';
   1d196:	2345      	movs	r3, #69	; 0x45
	str_gps[4] = last_fix.pvt.datetime.hour;
   1d198:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
	str_gps[7] = 'E';
   1d19a:	f88d 300b 	strb.w	r3, [sp, #11]
	str_gps[4] = last_fix.pvt.datetime.hour;
   1d19e:	f8ad 2008 	strh.w	r2, [sp, #8]
	if(last_fix.pvt.longitude < 0)
   1d1a2:	2300      	movs	r3, #0
   1d1a4:	2200      	movs	r2, #0
   1d1a6:	4630      	mov	r0, r6
   1d1a8:	4639      	mov	r1, r7
   1d1aa:	f7ff fd77 	bl	1cc9c <__aeabi_dcmplt>
   1d1ae:	b130      	cbz	r0, 1d1be <APP_Ask_GPS_Data_timerout+0x56>
	{
		str_gps[7] = 'W';
   1d1b0:	2357      	movs	r3, #87	; 0x57
   1d1b2:	f88d 300b 	strb.w	r3, [sp, #11]
		last_fix.pvt.longitude = -last_fix.pvt.longitude;
   1d1b6:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
   1d1ba:	6126      	str	r6, [r4, #16]
   1d1bc:	6163      	str	r3, [r4, #20]
	}

	tmp1 = (u32_t)(last_fix.pvt.longitude);	//
   1d1be:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
   1d1c2:	4639      	mov	r1, r7
   1d1c4:	4630      	mov	r0, r6
   1d1c6:	f7ff fd91 	bl	1ccec <__aeabi_d2uiz>
	tmp2 = last_fix.pvt.longitude - tmp1;	//
	
	str_gps[8] = tmp1;//
   1d1ca:	f88d 000c 	strb.w	r0, [sp, #12]
	tmp2 = last_fix.pvt.longitude - tmp1;	//
   1d1ce:	f7ff fa79 	bl	1c6c4 <__aeabi_ui2d>
   1d1d2:	4602      	mov	r2, r0
   1d1d4:	460b      	mov	r3, r1
   1d1d6:	4630      	mov	r0, r6
   1d1d8:	4639      	mov	r1, r7
   1d1da:	f7ff f935 	bl	1c448 <__aeabi_dsub>
	tmp1 = (u32_t)(tmp2*1000000);
   1d1de:	a32c      	add	r3, pc, #176	; (adr r3, 1d290 <APP_Ask_GPS_Data_timerout+0x128>)
   1d1e0:	e9d3 2300 	ldrd	r2, r3, [r3]
   1d1e4:	f7ff fae8 	bl	1c7b8 <__aeabi_dmul>
   1d1e8:	f7ff fd80 	bl	1ccec <__aeabi_d2uiz>
	tmp1 = tmp1%100;
	str_gps[11] = (u8_t)(tmp1);
	
	//latitude
	str_gps[12] = 'N';
	if(last_fix.pvt.latitude < 0)
   1d1ec:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
	str_gps[9] = (u8_t)(tmp1/10000);
   1d1f0:	f242 7210 	movw	r2, #10000	; 0x2710
   1d1f4:	fbb0 f3f2 	udiv	r3, r0, r2
   1d1f8:	f88d 300d 	strb.w	r3, [sp, #13]
	tmp1 = tmp1%10000;
   1d1fc:	fb02 0313 	mls	r3, r2, r3, r0
	str_gps[10] = (u8_t)(tmp1/100);
   1d200:	2264      	movs	r2, #100	; 0x64
   1d202:	fbb3 f0f2 	udiv	r0, r3, r2
	tmp1 = tmp1%100;
   1d206:	fb02 3310 	mls	r3, r2, r0, r3
	str_gps[11] = (u8_t)(tmp1);
   1d20a:	f88d 300f 	strb.w	r3, [sp, #15]
	str_gps[12] = 'N';
   1d20e:	234e      	movs	r3, #78	; 0x4e
	str_gps[10] = (u8_t)(tmp1/100);
   1d210:	f88d 000e 	strb.w	r0, [sp, #14]
	str_gps[12] = 'N';
   1d214:	f88d 3010 	strb.w	r3, [sp, #16]
	if(last_fix.pvt.latitude < 0)
   1d218:	2200      	movs	r2, #0
   1d21a:	2300      	movs	r3, #0
   1d21c:	4630      	mov	r0, r6
   1d21e:	4639      	mov	r1, r7
   1d220:	f7ff fd3c 	bl	1cc9c <__aeabi_dcmplt>
   1d224:	b130      	cbz	r0, 1d234 <APP_Ask_GPS_Data_timerout+0xcc>
	{
		str_gps[12] = 'S';
   1d226:	2353      	movs	r3, #83	; 0x53
   1d228:	f88d 3010 	strb.w	r3, [sp, #16]
		last_fix.pvt.latitude = -last_fix.pvt.latitude;
   1d22c:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
   1d230:	60a6      	str	r6, [r4, #8]
   1d232:	60e3      	str	r3, [r4, #12]
	}

	tmp1 = (u32_t)(last_fix.pvt.latitude);	//
   1d234:	e9d4 4502 	ldrd	r4, r5, [r4, #8]
   1d238:	4629      	mov	r1, r5
   1d23a:	4620      	mov	r0, r4
   1d23c:	f7ff fd56 	bl	1ccec <__aeabi_d2uiz>
	tmp2 = last_fix.pvt.latitude - tmp1;	//
	
	str_gps[13] = tmp1;//
   1d240:	f88d 0011 	strb.w	r0, [sp, #17]
	tmp2 = last_fix.pvt.latitude - tmp1;	//
   1d244:	f7ff fa3e 	bl	1c6c4 <__aeabi_ui2d>
   1d248:	4602      	mov	r2, r0
   1d24a:	460b      	mov	r3, r1
   1d24c:	4620      	mov	r0, r4
   1d24e:	4629      	mov	r1, r5
   1d250:	f7ff f8fa 	bl	1c448 <__aeabi_dsub>
	tmp1 = (u32_t)(tmp2*1000000);
   1d254:	a30e      	add	r3, pc, #56	; (adr r3, 1d290 <APP_Ask_GPS_Data_timerout+0x128>)
   1d256:	e9d3 2300 	ldrd	r2, r3, [r3]
   1d25a:	f7ff faad 	bl	1c7b8 <__aeabi_dmul>
   1d25e:	f7ff fd45 	bl	1ccec <__aeabi_d2uiz>
	str_gps[14] = (u8_t)(tmp1/10000);
   1d262:	f242 7210 	movw	r2, #10000	; 0x2710
   1d266:	fbb0 f3f2 	udiv	r3, r0, r2
   1d26a:	f88d 3012 	strb.w	r3, [sp, #18]
	tmp1 = tmp1%10000;
   1d26e:	fb02 0313 	mls	r3, r2, r3, r0
	str_gps[15] = (u8_t)(tmp1/100);
   1d272:	2264      	movs	r2, #100	; 0x64
   1d274:	fbb3 f0f2 	udiv	r0, r3, r2
	tmp1 = tmp1%100;
   1d278:	fb02 3310 	mls	r3, r2, r0, r3
	str_gps[15] = (u8_t)(tmp1/100);
   1d27c:	f88d 0013 	strb.w	r0, [sp, #19]
	str_gps[16] = (u8_t)(tmp1);

	APP_get_location_data_reply(str_gps, 17);
   1d280:	2111      	movs	r1, #17
   1d282:	a801      	add	r0, sp, #4
	str_gps[16] = (u8_t)(tmp1);
   1d284:	f88d 3014 	strb.w	r3, [sp, #20]
	APP_get_location_data_reply(str_gps, 17);
   1d288:	f01a f8d7 	bl	3743a <APP_get_location_data_reply>
}
   1d28c:	b007      	add	sp, #28
   1d28e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d290:	00000000 	.word	0x00000000
   1d294:	412e8480 	.word	0x412e8480
   1d298:	200242b4 	.word	0x200242b4
   1d29c:	20020008 	.word	0x20020008
   1d2a0:	2002473c 	.word	0x2002473c
   1d2a4:	00000000 	.word	0x00000000

0001d2a8 <gps_data_receive>:
{
	app_gps_off = true;
}

void gps_data_receive(void)
{
   1d2a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1d2ac:	b0be      	sub	sp, #248	; 0xf8
	do
	{
		/* Loop until we don't have more
		 * data to read
		 */
	}while(process_gps_data(&gps_data) > 0);
   1d2ae:	a808      	add	r0, sp, #32
   1d2b0:	f003 fcea 	bl	20c88 <process_gps_data>
   1d2b4:	2800      	cmp	r0, #0
   1d2b6:	dcfa      	bgt.n	1d2ae <gps_data_receive+0x6>

	if(!got_first_fix)
   1d2b8:	4dd7      	ldr	r5, [pc, #860]	; (1d618 <gps_data_receive+0x370>)
   1d2ba:	782b      	ldrb	r3, [r5, #0]
   1d2bc:	bb93      	cbnz	r3, 1d324 <gps_data_receive+0x7c>
	{
		cnt++;
   1d2be:	f8df 83a8 	ldr.w	r8, [pc, #936]	; 1d668 <gps_data_receive+0x3c0>
		LOG_INF("\033[1;1H");
   1d2c2:	f04f 0000 	mov.w	r0, #0
		cnt++;
   1d2c6:	f898 3000 	ldrb.w	r3, [r8]
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
   1d2ca:	4cd4      	ldr	r4, [pc, #848]	; (1d61c <gps_data_receive+0x374>)
   1d2cc:	3301      	adds	r3, #1
   1d2ce:	f888 3000 	strb.w	r3, [r8]
		LOG_INF("\033[1;1H");
   1d2d2:	2303      	movs	r3, #3
   1d2d4:	f363 0007 	bfi	r0, r3, #0, #8
   1d2d8:	4bd1      	ldr	r3, [pc, #836]	; (1d620 <gps_data_receive+0x378>)
   1d2da:	49d2      	ldr	r1, [pc, #840]	; (1d624 <gps_data_receive+0x37c>)
   1d2dc:	1ae4      	subs	r4, r4, r3
   1d2de:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1d2e2:	f364 108f 	bfi	r0, r4, #6, #10
   1d2e6:	f01a fd42 	bl	37d6e <log_string_sync>
		LOG_INF("\033[2J");
   1d2ea:	2303      	movs	r3, #3
   1d2ec:	f04f 0000 	mov.w	r0, #0
   1d2f0:	f363 0007 	bfi	r0, r3, #0, #8
   1d2f4:	49cc      	ldr	r1, [pc, #816]	; (1d628 <gps_data_receive+0x380>)
   1d2f6:	f364 108f 	bfi	r0, r4, #6, #10
   1d2fa:	f01a fd38 	bl	37d6e <log_string_sync>
		print_satellite_stats(&gps_data);
   1d2fe:	a808      	add	r0, sp, #32
   1d300:	f003 fc54 	bl	20bac <print_satellite_stats>
		LOG_INF("\nScanning [%c] ",
   1d304:	2303      	movs	r3, #3
   1d306:	f04f 0000 	mov.w	r0, #0
   1d30a:	f363 0007 	bfi	r0, r3, #0, #8
   1d30e:	f898 3000 	ldrb.w	r3, [r8]
   1d312:	4ac6      	ldr	r2, [pc, #792]	; (1d62c <gps_data_receive+0x384>)
   1d314:	f003 0303 	and.w	r3, r3, #3
   1d318:	f364 108f 	bfi	r0, r4, #6, #10
   1d31c:	5cd2      	ldrb	r2, [r2, r3]
   1d31e:	49c4      	ldr	r1, [pc, #784]	; (1d630 <gps_data_receive+0x388>)
   1d320:	f01a fd25 	bl	37d6e <log_string_sync>
		(void)arch_syscall_invoke1((uintptr_t)&ret64, K_SYSCALL_K_UPTIME_GET);
		return (s64_t)ret64;
	}
#endif
	compiler_barrier();
	return z_impl_k_uptime_get();
   1d324:	f01c fc72 	bl	39c0c <z_impl_k_uptime_get>
		sprintf(tmpbuf, "Scanning [%c] ", update_indicator[cnt%4]);
		show_infor(tmpbuf);
	#endif	
	}

	if(((k_uptime_get() - fix_timestamp) >= 1) && (got_first_fix))
   1d328:	f8df 9340 	ldr.w	r9, [pc, #832]	; 1d66c <gps_data_receive+0x3c4>
   1d32c:	e9d9 2300 	ldrd	r2, r3, [r9]
   1d330:	428b      	cmp	r3, r1
   1d332:	bf08      	it	eq
   1d334:	4282      	cmpeq	r2, r0
   1d336:	f000 819b 	beq.w	1d670 <gps_data_receive+0x3c8>
   1d33a:	782b      	ldrb	r3, [r5, #0]
   1d33c:	2b00      	cmp	r3, #0
   1d33e:	f000 8197 	beq.w	1d670 <gps_data_receive+0x3c8>
	{
		LOG_INF("\033[1;1H");
   1d342:	2303      	movs	r3, #3
   1d344:	f04f 0000 	mov.w	r0, #0
   1d348:	4db4      	ldr	r5, [pc, #720]	; (1d61c <gps_data_receive+0x374>)
   1d34a:	f363 0007 	bfi	r0, r3, #0, #8
   1d34e:	4bb4      	ldr	r3, [pc, #720]	; (1d620 <gps_data_receive+0x378>)
   1d350:	49b4      	ldr	r1, [pc, #720]	; (1d624 <gps_data_receive+0x37c>)
   1d352:	1aed      	subs	r5, r5, r3
   1d354:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   1d358:	f365 108f 	bfi	r0, r5, #6, #10
   1d35c:	f01a fd07 	bl	37d6e <log_string_sync>
		LOG_INF("\033[2J");
   1d360:	2303      	movs	r3, #3
   1d362:	f04f 0000 	mov.w	r0, #0
   1d366:	f363 0007 	bfi	r0, r3, #0, #8
   1d36a:	f365 108f 	bfi	r0, r5, #6, #10
   1d36e:	49ae      	ldr	r1, [pc, #696]	; (1d628 <gps_data_receive+0x380>)
   1d370:	f01a fcfd 	bl	37d6e <log_string_sync>

		print_satellite_stats(&gps_data);
   1d374:	a808      	add	r0, sp, #32
   1d376:	f003 fc19 	bl	20bac <print_satellite_stats>

		LOG_INF("---------------------------------\n");
   1d37a:	2303      	movs	r3, #3
   1d37c:	f04f 0000 	mov.w	r0, #0
	LCD_Fill(0,20,240,200,BLACK);
   1d380:	f04f 0800 	mov.w	r8, #0
		LOG_INF("---------------------------------\n");
   1d384:	f363 0007 	bfi	r0, r3, #0, #8
   1d388:	f365 108f 	bfi	r0, r5, #6, #10
   1d38c:	49a9      	ldr	r1, [pc, #676]	; (1d634 <gps_data_receive+0x38c>)
   1d38e:	f01a fcee 	bl	37d6e <log_string_sync>
	LCD_Fill(0,20,240,200,BLACK);
   1d392:	4640      	mov	r0, r8
   1d394:	f8cd 8000 	str.w	r8, [sp]
   1d398:	23c8      	movs	r3, #200	; 0xc8
   1d39a:	22f0      	movs	r2, #240	; 0xf0
   1d39c:	2114      	movs	r1, #20
   1d39e:	f001 fb45 	bl	1ea2c <LCD_Fill>
	LOG_INF("Longitude:  %f\n", pvt_data->pvt.longitude);
   1d3a2:	2303      	movs	r3, #3
   1d3a4:	f04f 0000 	mov.w	r0, #0
   1d3a8:	4ca3      	ldr	r4, [pc, #652]	; (1d638 <gps_data_receive+0x390>)
   1d3aa:	f363 0007 	bfi	r0, r3, #0, #8
   1d3ae:	f365 108f 	bfi	r0, r5, #6, #10
   1d3b2:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
   1d3b6:	49a1      	ldr	r1, [pc, #644]	; (1d63c <gps_data_receive+0x394>)
   1d3b8:	f01a fcd9 	bl	37d6e <log_string_sync>
	LOG_INF("Latitude:   %f\n", pvt_data->pvt.latitude);
   1d3bc:	2303      	movs	r3, #3
   1d3be:	f04f 0000 	mov.w	r0, #0
   1d3c2:	f363 0007 	bfi	r0, r3, #0, #8
   1d3c6:	f365 108f 	bfi	r0, r5, #6, #10
   1d3ca:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
   1d3ce:	499c      	ldr	r1, [pc, #624]	; (1d640 <gps_data_receive+0x398>)
   1d3d0:	f01a fccd 	bl	37d6e <log_string_sync>
	LOG_INF("Altitude:   %f\n", pvt_data->pvt.altitude);
   1d3d4:	f04f 0a00 	mov.w	sl, #0
   1d3d8:	2303      	movs	r3, #3
   1d3da:	69a0      	ldr	r0, [r4, #24]
   1d3dc:	f363 0a07 	bfi	sl, r3, #0, #8
   1d3e0:	f7ff f992 	bl	1c708 <__aeabi_f2d>
   1d3e4:	f365 1a8f 	bfi	sl, r5, #6, #10
   1d3e8:	4602      	mov	r2, r0
   1d3ea:	460b      	mov	r3, r1
   1d3ec:	4650      	mov	r0, sl
   1d3ee:	4995      	ldr	r1, [pc, #596]	; (1d644 <gps_data_receive+0x39c>)
   1d3f0:	f01a fcbd 	bl	37d6e <log_string_sync>
	LOG_INF("Speed:      %f\n", pvt_data->pvt.speed);
   1d3f4:	f04f 0a00 	mov.w	sl, #0
   1d3f8:	2303      	movs	r3, #3
   1d3fa:	6a20      	ldr	r0, [r4, #32]
   1d3fc:	f363 0a07 	bfi	sl, r3, #0, #8
   1d400:	f7ff f982 	bl	1c708 <__aeabi_f2d>
   1d404:	f365 1a8f 	bfi	sl, r5, #6, #10
   1d408:	4602      	mov	r2, r0
   1d40a:	460b      	mov	r3, r1
   1d40c:	4650      	mov	r0, sl
   1d40e:	498e      	ldr	r1, [pc, #568]	; (1d648 <gps_data_receive+0x3a0>)
   1d410:	f01a fcad 	bl	37d6e <log_string_sync>
	LOG_INF("Heading:    %f\n", pvt_data->pvt.heading);
   1d414:	f04f 0a00 	mov.w	sl, #0
   1d418:	2303      	movs	r3, #3
   1d41a:	6a60      	ldr	r0, [r4, #36]	; 0x24
   1d41c:	f363 0a07 	bfi	sl, r3, #0, #8
   1d420:	f7ff f972 	bl	1c708 <__aeabi_f2d>
   1d424:	f365 1a8f 	bfi	sl, r5, #6, #10
   1d428:	4602      	mov	r2, r0
   1d42a:	460b      	mov	r3, r1
   1d42c:	4650      	mov	r0, sl
   1d42e:	4987      	ldr	r1, [pc, #540]	; (1d64c <gps_data_receive+0x3a4>)
   1d430:	f01a fc9d 	bl	37d6e <log_string_sync>
	LOG_INF("Date:       %02u-%02u-%02u", pvt_data->pvt.datetime.year,
   1d434:	2303      	movs	r3, #3
   1d436:	f04f 0000 	mov.w	r0, #0
   1d43a:	f363 0007 	bfi	r0, r3, #0, #8
   1d43e:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
   1d442:	f365 108f 	bfi	r0, r5, #6, #10
   1d446:	9300      	str	r3, [sp, #0]
   1d448:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
   1d44c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
   1d44e:	4980      	ldr	r1, [pc, #512]	; (1d650 <gps_data_receive+0x3a8>)
   1d450:	f01a fc8d 	bl	37d6e <log_string_sync>
	LOG_INF("Time (UTC): %02u:%02u:%02u", pvt_data->pvt.datetime.hour,
   1d454:	2303      	movs	r3, #3
   1d456:	f04f 0000 	mov.w	r0, #0
   1d45a:	f363 0007 	bfi	r0, r3, #0, #8
   1d45e:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   1d462:	f365 108f 	bfi	r0, r5, #6, #10
   1d466:	9300      	str	r3, [sp, #0]
   1d468:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
   1d46c:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
   1d470:	4978      	ldr	r1, [pc, #480]	; (1d654 <gps_data_receive+0x3ac>)
   1d472:	f01a fc7c 	bl	37d6e <log_string_sync>
		print_pvt_data(&last_fix);
		LOG_INF("\n");
   1d476:	2303      	movs	r3, #3
   1d478:	f04f 0000 	mov.w	r0, #0
   1d47c:	f363 0007 	bfi	r0, r3, #0, #8
   1d480:	f365 108f 	bfi	r0, r5, #6, #10
   1d484:	4974      	ldr	r1, [pc, #464]	; (1d658 <gps_data_receive+0x3b0>)
   1d486:	f01a fc72 	bl	37d6e <log_string_sync>
		print_nmea_data();
   1d48a:	f003 fb55 	bl	20b38 <print_nmea_data>
		LOG_INF("---------------------------------");
   1d48e:	2303      	movs	r3, #3
   1d490:	f04f 0000 	mov.w	r0, #0
   1d494:	f363 0007 	bfi	r0, r3, #0, #8
   1d498:	f365 108f 	bfi	r0, r5, #6, #10
   1d49c:	496f      	ldr	r1, [pc, #444]	; (1d65c <gps_data_receive+0x3b4>)
   1d49e:	f01a fc66 	bl	37d6e <log_string_sync>
   1d4a2:	f01c fbb3 	bl	39c0c <z_impl_k_uptime_get>

		update_terminal = false;

		if(((k_uptime_get() - fix_timestamp) >= 5) && (APP_wait_gps))
   1d4a6:	e9d9 3200 	ldrd	r3, r2, [r9]
   1d4aa:	1ac6      	subs	r6, r0, r3
   1d4ac:	eb61 0702 	sbc.w	r7, r1, r2
   1d4b0:	2f00      	cmp	r7, #0
   1d4b2:	bf08      	it	eq
   1d4b4:	2e05      	cmpeq	r6, #5
   1d4b6:	f0c0 80db 	bcc.w	1d670 <gps_data_receive+0x3c8>
   1d4ba:	4d69      	ldr	r5, [pc, #420]	; (1d660 <gps_data_receive+0x3b8>)
   1d4bc:	782a      	ldrb	r2, [r5, #0]
   1d4be:	2a00      	cmp	r2, #0
   1d4c0:	f000 80d6 	beq.w	1d670 <gps_data_receive+0x3c8>
		{
			u8_t str_gps[20] = {0};
   1d4c4:	2214      	movs	r2, #20
   1d4c6:	4641      	mov	r1, r8
   1d4c8:	a803      	add	r0, sp, #12
   1d4ca:	f01c fc78 	bl	39dbe <memset>
 */
__syscall u32_t k_timer_remaining_get(struct k_timer *timer);

static inline u32_t z_impl_k_timer_remaining_get(struct k_timer *timer)
{
	const s32_t ticks = z_timeout_remaining(&timer->timeout);
   1d4ce:	4865      	ldr	r0, [pc, #404]	; (1d664 <gps_data_receive+0x3bc>)
   1d4d0:	f017 fd48 	bl	34f64 <z_timeout_remaining>
	return (ticks > 0) ? (u32_t)k_ticks_to_ms_floor64(ticks) : 0U;
   1d4d4:	2800      	cmp	r0, #0
   1d4d6:	dd0a      	ble.n	1d4ee <gps_data_receive+0x246>
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
   1d4d8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1d4dc:	fb80 0103 	smull	r0, r1, r0, r3
   1d4e0:	0bc3      	lsrs	r3, r0, #15
			u32_t tmp1;
			double tmp2;

			if(k_timer_remaining_get(&app_wait_gps_timer) > 0)
   1d4e2:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
   1d4e6:	d002      	beq.n	1d4ee <gps_data_receive+0x246>
	z_impl_k_timer_stop(timer);
   1d4e8:	485e      	ldr	r0, [pc, #376]	; (1d664 <gps_data_receive+0x3bc>)
   1d4ea:	f01c fba9 	bl	39c40 <z_impl_k_timer_stop>
				k_timer_stop(&app_wait_gps_timer);

			APP_wait_gps = false;
   1d4ee:	2300      	movs	r3, #0
   1d4f0:	702b      	strb	r3, [r5, #0]
			gps_off();
   1d4f2:	f003 fd25 	bl	20f40 <gps_off>
			//seconds
			str_gps[6] = last_fix.pvt.datetime.seconds;

			//longitude
			str_gps[7] = 'E';
			if(last_fix.pvt.longitude < 0)
   1d4f6:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
			str_gps[0] = last_fix.pvt.datetime.year>>8;
   1d4fa:	8d23      	ldrh	r3, [r4, #40]	; 0x28
			str_gps[2] = last_fix.pvt.datetime.month;
   1d4fc:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
			str_gps[0] = last_fix.pvt.datetime.year>>8;
   1d4fe:	ba5b      	rev16	r3, r3
   1d500:	f8ad 300c 	strh.w	r3, [sp, #12]
			str_gps[6] = last_fix.pvt.datetime.seconds;
   1d504:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
			str_gps[2] = last_fix.pvt.datetime.month;
   1d508:	f8ad 200e 	strh.w	r2, [sp, #14]
			str_gps[6] = last_fix.pvt.datetime.seconds;
   1d50c:	f88d 3012 	strb.w	r3, [sp, #18]
			str_gps[7] = 'E';
   1d510:	2345      	movs	r3, #69	; 0x45
			str_gps[4] = last_fix.pvt.datetime.hour;
   1d512:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
			str_gps[7] = 'E';
   1d514:	f88d 3013 	strb.w	r3, [sp, #19]
			str_gps[4] = last_fix.pvt.datetime.hour;
   1d518:	f8ad 2010 	strh.w	r2, [sp, #16]
			if(last_fix.pvt.longitude < 0)
   1d51c:	2300      	movs	r3, #0
   1d51e:	2200      	movs	r2, #0
   1d520:	4630      	mov	r0, r6
   1d522:	4639      	mov	r1, r7
   1d524:	f7ff fbba 	bl	1cc9c <__aeabi_dcmplt>
   1d528:	b130      	cbz	r0, 1d538 <gps_data_receive+0x290>
			{
				str_gps[7] = 'W';
   1d52a:	2357      	movs	r3, #87	; 0x57
   1d52c:	f88d 3013 	strb.w	r3, [sp, #19]
				last_fix.pvt.longitude = -last_fix.pvt.longitude;
   1d530:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
   1d534:	6126      	str	r6, [r4, #16]
   1d536:	6163      	str	r3, [r4, #20]
			}

			tmp1 = (u32_t)(last_fix.pvt.longitude);	//
   1d538:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
   1d53c:	4639      	mov	r1, r7
   1d53e:	4630      	mov	r0, r6
   1d540:	f7ff fbd4 	bl	1ccec <__aeabi_d2uiz>
			tmp2 = last_fix.pvt.longitude - tmp1;	//
			
			str_gps[8] = tmp1;//
   1d544:	f88d 0014 	strb.w	r0, [sp, #20]
			tmp2 = last_fix.pvt.longitude - tmp1;	//
   1d548:	f7ff f8bc 	bl	1c6c4 <__aeabi_ui2d>
   1d54c:	4602      	mov	r2, r0
   1d54e:	460b      	mov	r3, r1
   1d550:	4630      	mov	r0, r6
   1d552:	4639      	mov	r1, r7
   1d554:	f7fe ff78 	bl	1c448 <__aeabi_dsub>
			tmp1 = (u32_t)(tmp2*1000000);
   1d558:	a32d      	add	r3, pc, #180	; (adr r3, 1d610 <gps_data_receive+0x368>)
   1d55a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1d55e:	f7ff f92b 	bl	1c7b8 <__aeabi_dmul>
   1d562:	f7ff fbc3 	bl	1ccec <__aeabi_d2uiz>
			tmp1 = tmp1%100;
			str_gps[11] = (u8_t)(tmp1);
			
			//latitude
			str_gps[12] = 'N';
			if(last_fix.pvt.latitude < 0)
   1d566:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
			str_gps[9] = (u8_t)(tmp1/10000);
   1d56a:	f242 7210 	movw	r2, #10000	; 0x2710
   1d56e:	fbb0 f3f2 	udiv	r3, r0, r2
   1d572:	f88d 3015 	strb.w	r3, [sp, #21]
			tmp1 = tmp1%10000;
   1d576:	fb02 0313 	mls	r3, r2, r3, r0
			str_gps[10] = (u8_t)(tmp1/100);
   1d57a:	2264      	movs	r2, #100	; 0x64
   1d57c:	fbb3 f0f2 	udiv	r0, r3, r2
			tmp1 = tmp1%100;
   1d580:	fb02 3310 	mls	r3, r2, r0, r3
			str_gps[11] = (u8_t)(tmp1);
   1d584:	f88d 3017 	strb.w	r3, [sp, #23]
			str_gps[12] = 'N';
   1d588:	234e      	movs	r3, #78	; 0x4e
			str_gps[10] = (u8_t)(tmp1/100);
   1d58a:	f88d 0016 	strb.w	r0, [sp, #22]
			str_gps[12] = 'N';
   1d58e:	f88d 3018 	strb.w	r3, [sp, #24]
			if(last_fix.pvt.latitude < 0)
   1d592:	2200      	movs	r2, #0
   1d594:	2300      	movs	r3, #0
   1d596:	4630      	mov	r0, r6
   1d598:	4639      	mov	r1, r7
   1d59a:	f7ff fb7f 	bl	1cc9c <__aeabi_dcmplt>
   1d59e:	b130      	cbz	r0, 1d5ae <gps_data_receive+0x306>
			{
				str_gps[12] = 'S';
   1d5a0:	2353      	movs	r3, #83	; 0x53
   1d5a2:	f88d 3018 	strb.w	r3, [sp, #24]
				last_fix.pvt.latitude = -last_fix.pvt.latitude;
   1d5a6:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
   1d5aa:	60a6      	str	r6, [r4, #8]
   1d5ac:	60e3      	str	r3, [r4, #12]
			}

			tmp1 = (u32_t)(last_fix.pvt.latitude);	//
   1d5ae:	e9d4 4502 	ldrd	r4, r5, [r4, #8]
   1d5b2:	4629      	mov	r1, r5
   1d5b4:	4620      	mov	r0, r4
   1d5b6:	f7ff fb99 	bl	1ccec <__aeabi_d2uiz>
			tmp2 = last_fix.pvt.latitude - tmp1;	//
			
			str_gps[13] = tmp1;//
   1d5ba:	f88d 0019 	strb.w	r0, [sp, #25]
			tmp2 = last_fix.pvt.latitude - tmp1;	//
   1d5be:	f7ff f881 	bl	1c6c4 <__aeabi_ui2d>
   1d5c2:	4602      	mov	r2, r0
   1d5c4:	460b      	mov	r3, r1
   1d5c6:	4620      	mov	r0, r4
   1d5c8:	4629      	mov	r1, r5
   1d5ca:	f7fe ff3d 	bl	1c448 <__aeabi_dsub>
			tmp1 = (u32_t)(tmp2*1000000);
   1d5ce:	a310      	add	r3, pc, #64	; (adr r3, 1d610 <gps_data_receive+0x368>)
   1d5d0:	e9d3 2300 	ldrd	r2, r3, [r3]
   1d5d4:	f7ff f8f0 	bl	1c7b8 <__aeabi_dmul>
   1d5d8:	f7ff fb88 	bl	1ccec <__aeabi_d2uiz>
			str_gps[14] = (u8_t)(tmp1/10000);
   1d5dc:	f242 7210 	movw	r2, #10000	; 0x2710
   1d5e0:	fbb0 f3f2 	udiv	r3, r0, r2
   1d5e4:	f88d 301a 	strb.w	r3, [sp, #26]
			tmp1 = tmp1%10000;
   1d5e8:	fb02 0313 	mls	r3, r2, r3, r0
			str_gps[15] = (u8_t)(tmp1/100);
   1d5ec:	2264      	movs	r2, #100	; 0x64
   1d5ee:	fbb3 f0f2 	udiv	r0, r3, r2
			tmp1 = tmp1%100;
   1d5f2:	fb02 3310 	mls	r3, r2, r0, r3
			str_gps[15] = (u8_t)(tmp1/100);
   1d5f6:	f88d 001b 	strb.w	r0, [sp, #27]
			str_gps[16] = (u8_t)(tmp1);

			APP_get_location_data_reply(str_gps, 17);
   1d5fa:	2111      	movs	r1, #17
   1d5fc:	a803      	add	r0, sp, #12
			str_gps[16] = (u8_t)(tmp1);
   1d5fe:	f88d 301c 	strb.w	r3, [sp, #28]
			APP_get_location_data_reply(str_gps, 17);
   1d602:	f019 ff1a 	bl	3743a <APP_get_location_data_reply>
	#endif
		return;
	}
	
	print_nmea_data();
}
   1d606:	b03e      	add	sp, #248	; 0xf8
   1d608:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1d60c:	f3af 8000 	nop.w
   1d610:	00000000 	.word	0x00000000
   1d614:	412e8480 	.word	0x412e8480
   1d618:	2002473f 	.word	0x2002473f
   1d61c:	0003ae48 	.word	0x0003ae48
   1d620:	0003ade0 	.word	0x0003ade0
   1d624:	0003bf08 	.word	0x0003bf08
   1d628:	0003bf0f 	.word	0x0003bf0f
   1d62c:	0003c167 	.word	0x0003c167
   1d630:	0003bf14 	.word	0x0003bf14
   1d634:	0003bf24 	.word	0x0003bf24
   1d638:	20020008 	.word	0x20020008
   1d63c:	0003bf47 	.word	0x0003bf47
   1d640:	0003bf57 	.word	0x0003bf57
   1d644:	0003bf67 	.word	0x0003bf67
   1d648:	0003bf77 	.word	0x0003bf77
   1d64c:	0003bf87 	.word	0x0003bf87
   1d650:	0003bf97 	.word	0x0003bf97
   1d654:	0003bfb2 	.word	0x0003bfb2
   1d658:	0003da1c 	.word	0x0003da1c
   1d65c:	0003bfcd 	.word	0x0003bfcd
   1d660:	200242b4 	.word	0x200242b4
   1d664:	200202dc 	.word	0x200202dc
   1d668:	2002473e 	.word	0x2002473e
   1d66c:	20020000 	.word	0x20020000
	if(!gps_is_on)
   1d670:	4b03      	ldr	r3, [pc, #12]	; (1d680 <gps_data_receive+0x3d8>)
   1d672:	781b      	ldrb	r3, [r3, #0]
   1d674:	2b00      	cmp	r3, #0
   1d676:	d0c6      	beq.n	1d606 <gps_data_receive+0x35e>
	print_nmea_data();
   1d678:	f003 fa5e 	bl	20b38 <print_nmea_data>
   1d67c:	e7c3      	b.n	1d606 <gps_data_receive+0x35e>
   1d67e:	bf00      	nop
   1d680:	20024742 	.word	0x20024742
   1d684:	00000000 	.word	0x00000000

0001d688 <MAX20353_UpdateTemper>:
	WriteWord(0x0C, RCOMP, 0x5C);
	return RCOMP;
}

void MAX20353_UpdateTemper(void)
{
   1d688:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1d68c:	ed2d 8b02 	vpush	{d8}
   1d690:	b0a5      	sub	sp, #148	; 0x94
	u8_t thm;
	s8_t begin,end,tmp;
	float resistance;
	s16_t temper=25;
	u8_t tmpbuf[128] = {0};
   1d692:	2100      	movs	r1, #0
   1d694:	2280      	movs	r2, #128	; 0x80
   1d696:	a804      	add	r0, sp, #16
   1d698:	f01c fb91 	bl	39dbe <memset>
	static u8_t pre_thm=0;
	static u16_t pre_temper=25;	//25
	
	thm = MAX20353_ReadTHM();
   1d69c:	f005 fe2c 	bl	232f8 <MAX20353_ReadTHM>
	if(thm == pre_thm)
   1d6a0:	4b95      	ldr	r3, [pc, #596]	; (1d8f8 <MAX20353_UpdateTemper+0x270>)
   1d6a2:	7819      	ldrb	r1, [r3, #0]
   1d6a4:	4281      	cmp	r1, r0
   1d6a6:	f000 80bd 	beq.w	1d824 <MAX20353_UpdateTemper+0x19c>
		return;

	pre_thm = thm;
   1d6aa:	7018      	strb	r0, [r3, #0]
	resistance = (float)10/(255.00/thm-1);
   1d6ac:	f7ff f81a 	bl	1c6e4 <__aeabi_i2d>
   1d6b0:	4602      	mov	r2, r0
   1d6b2:	460b      	mov	r3, r1
   1d6b4:	a18e      	add	r1, pc, #568	; (adr r1, 1d8f0 <MAX20353_UpdateTemper+0x268>)
   1d6b6:	e9d1 0100 	ldrd	r0, r1, [r1]
   1d6ba:	f7ff f9a7 	bl	1ca0c <__aeabi_ddiv>
   1d6be:	2200      	movs	r2, #0
   1d6c0:	4b8e      	ldr	r3, [pc, #568]	; (1d8fc <MAX20353_UpdateTemper+0x274>)
   1d6c2:	f7fe fec1 	bl	1c448 <__aeabi_dsub>
   1d6c6:	4602      	mov	r2, r0
   1d6c8:	460b      	mov	r3, r1
   1d6ca:	2000      	movs	r0, #0
   1d6cc:	498c      	ldr	r1, [pc, #560]	; (1d900 <MAX20353_UpdateTemper+0x278>)
   1d6ce:	f7ff f99d 	bl	1ca0c <__aeabi_ddiv>
   1d6d2:	f7ff fb2b 	bl	1cd2c <__aeabi_d2f>
   1d6d6:	ee08 0a10 	vmov	s16, r0

	sprintf(tmpbuf, "resistance:%.4f", resistance);
   1d6da:	f7ff f815 	bl	1c708 <__aeabi_f2d>
   1d6de:	4b89      	ldr	r3, [pc, #548]	; (1d904 <MAX20353_UpdateTemper+0x27c>)
   1d6e0:	e9cd 0100 	strd	r0, r1, [sp]
   1d6e4:	2280      	movs	r2, #128	; 0x80
   1d6e6:	2100      	movs	r1, #0
   1d6e8:	a804      	add	r0, sp, #16
   1d6ea:	f01c fcaa 	bl	3a042 <__sprintf_chk>
	LOG_INF("%s\n", tmpbuf);
   1d6ee:	2303      	movs	r3, #3
   1d6f0:	f04f 0000 	mov.w	r0, #0
   1d6f4:	4c84      	ldr	r4, [pc, #528]	; (1d908 <MAX20353_UpdateTemper+0x280>)
   1d6f6:	f363 0007 	bfi	r0, r3, #0, #8
   1d6fa:	4b84      	ldr	r3, [pc, #528]	; (1d90c <MAX20353_UpdateTemper+0x284>)
	end = TEMPER_NUM_MAX-1;
	while(begin <= end)
	{
		tmp = (begin+end)/2;
		
		if(ntc_table[tmp].impedance == resistance)
   1d6fc:	f8df 922c 	ldr.w	r9, [pc, #556]	; 1d92c <MAX20353_UpdateTemper+0x2a4>
	LOG_INF("%s\n", tmpbuf);
   1d700:	1ae4      	subs	r4, r4, r3
   1d702:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1d706:	f364 108f 	bfi	r0, r4, #6, #10
   1d70a:	aa04      	add	r2, sp, #16
   1d70c:	4980      	ldr	r1, [pc, #512]	; (1d910 <MAX20353_UpdateTemper+0x288>)
   1d70e:	f01a fb2e 	bl	37d6e <log_string_sync>
	end = TEMPER_NUM_MAX-1;
   1d712:	f04f 0821 	mov.w	r8, #33	; 0x21
	begin = 0;
   1d716:	2600      	movs	r6, #0
   1d718:	464f      	mov	r7, r9
		tmp = (begin+end)/2;
   1d71a:	eb06 0308 	add.w	r3, r6, r8
   1d71e:	105b      	asrs	r3, r3, #1
   1d720:	b25d      	sxtb	r5, r3
		if(ntc_table[tmp].impedance == resistance)
   1d722:	eb09 03c3 	add.w	r3, r9, r3, lsl #3
   1d726:	edd3 7a01 	vldr	s15, [r3, #4]
   1d72a:	eef4 7a48 	vcmp.f32	s15, s16
   1d72e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d732:	f000 80cf 	beq.w	1d8d4 <MAX20353_UpdateTemper+0x24c>
			break;

		if(ntc_table[tmp].impedance > resistance)
   1d736:	eef4 7ac8 	vcmpe.f32	s15, s16
   1d73a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		{
			begin = tmp+1;
   1d73e:	bfcb      	itete	gt
   1d740:	1c6e      	addgt	r6, r5, #1
		}
		else
		{
			end = tmp-1;
   1d742:	f105 38ff 	addle.w	r8, r5, #4294967295
			begin = tmp+1;
   1d746:	b276      	sxtbgt	r6, r6
			end = tmp-1;
   1d748:	fa4f f888 	sxtble.w	r8, r8
	while(begin <= end)
   1d74c:	4546      	cmp	r6, r8
   1d74e:	dde4      	ble.n	1d71a <MAX20353_UpdateTemper+0x92>
	}
	else			//select closeet
	{
		float com1,com2;

		LOG_INF("select closeet!\n");
   1d750:	2303      	movs	r3, #3
   1d752:	f04f 0000 	mov.w	r0, #0
   1d756:	f363 0007 	bfi	r0, r3, #0, #8
   1d75a:	f364 108f 	bfi	r0, r4, #6, #10
   1d75e:	496d      	ldr	r1, [pc, #436]	; (1d914 <MAX20353_UpdateTemper+0x28c>)
   1d760:	f01a fb05 	bl	37d6e <log_string_sync>
		
		if(begin == tmp+1)
   1d764:	1c6b      	adds	r3, r5, #1
   1d766:	429e      	cmp	r6, r3
   1d768:	d161      	bne.n	1d82e <MAX20353_UpdateTemper+0x1a6>
		{
			com1 = fabs(ntc_table[tmp].impedance-resistance);
   1d76a:	eb07 03c5 	add.w	r3, r7, r5, lsl #3
   1d76e:	edd3 7a01 	vldr	s15, [r3, #4]
   1d772:	ee77 7ac8 	vsub.f32	s15, s15, s16
   1d776:	ee17 0a90 	vmov	r0, s15
   1d77a:	f7fe ffc5 	bl	1c708 <__aeabi_f2d>
   1d77e:	ec41 0b10 	vmov	d0, r0, r1
   1d782:	f018 f99f 	bl	35ac4 <fabs>
   1d786:	ec51 0b10 	vmov	r0, r1, d0
   1d78a:	f7ff facf 	bl	1cd2c <__aeabi_d2f>
			com2 = fabs(ntc_table[tmp+1].impedance-resistance);
   1d78e:	eb07 03c6 	add.w	r3, r7, r6, lsl #3
   1d792:	edd3 7a01 	vldr	s15, [r3, #4]
   1d796:	ee77 7ac8 	vsub.f32	s15, s15, s16
			com1 = fabs(ntc_table[tmp].impedance-resistance);
   1d79a:	ee08 0a90 	vmov	s17, r0
			com2 = fabs(ntc_table[tmp+1].impedance-resistance);
   1d79e:	ee17 0a90 	vmov	r0, s15
   1d7a2:	f7fe ffb1 	bl	1c708 <__aeabi_f2d>
   1d7a6:	ec41 0b10 	vmov	d0, r0, r1
   1d7aa:	f018 f98b 	bl	35ac4 <fabs>
   1d7ae:	ec51 0b10 	vmov	r0, r1, d0
   1d7b2:	f7ff fabb 	bl	1cd2c <__aeabi_d2f>
   1d7b6:	ee08 0a10 	vmov	s16, r0
			sprintf(tmpbuf, "001 com1:%.4f, com2:%04f", com1, com2);
   1d7ba:	f7fe ffa5 	bl	1c708 <__aeabi_f2d>
   1d7be:	e9cd 0102 	strd	r0, r1, [sp, #8]
   1d7c2:	ee18 0a90 	vmov	r0, s17
   1d7c6:	f7fe ff9f 	bl	1c708 <__aeabi_f2d>
   1d7ca:	4b53      	ldr	r3, [pc, #332]	; (1d918 <MAX20353_UpdateTemper+0x290>)
   1d7cc:	e9cd 0100 	strd	r0, r1, [sp]
   1d7d0:	2280      	movs	r2, #128	; 0x80
   1d7d2:	2100      	movs	r1, #0
   1d7d4:	a804      	add	r0, sp, #16
   1d7d6:	f01c fc34 	bl	3a042 <__sprintf_chk>
			LOG_INF("%s\n", tmpbuf);
   1d7da:	2303      	movs	r3, #3
   1d7dc:	f04f 0000 	mov.w	r0, #0
   1d7e0:	f363 0007 	bfi	r0, r3, #0, #8
   1d7e4:	f364 108f 	bfi	r0, r4, #6, #10
   1d7e8:	aa04      	add	r2, sp, #16
   1d7ea:	4949      	ldr	r1, [pc, #292]	; (1d910 <MAX20353_UpdateTemper+0x288>)
   1d7ec:	f01a fabf 	bl	37d6e <log_string_sync>
			if(com1 > com2)
   1d7f0:	eef4 8ac8 	vcmpe.f32	s17, s16
   1d7f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d7f8:	dd67      	ble.n	1d8ca <MAX20353_UpdateTemper+0x242>
			{
				temper = ntc_table[tmp+1].temperature;
   1d7fa:	f937 5036 	ldrsh.w	r5, [r7, r6, lsl #3]
				temper = ntc_table[tmp].temperature;
			}			
		}
	}

	LOG_INF("temper:%d\n", temper);
   1d7fe:	2303      	movs	r3, #3
   1d800:	f04f 0000 	mov.w	r0, #0
   1d804:	f363 0007 	bfi	r0, r3, #0, #8
   1d808:	462a      	mov	r2, r5
   1d80a:	f364 108f 	bfi	r0, r4, #6, #10
   1d80e:	4943      	ldr	r1, [pc, #268]	; (1d91c <MAX20353_UpdateTemper+0x294>)
   1d810:	f01a faad 	bl	37d6e <log_string_sync>

	if(temper != pre_temper)
   1d814:	4b42      	ldr	r3, [pc, #264]	; (1d920 <MAX20353_UpdateTemper+0x298>)
   1d816:	881a      	ldrh	r2, [r3, #0]
   1d818:	4295      	cmp	r5, r2
   1d81a:	d003      	beq.n	1d824 <MAX20353_UpdateTemper+0x19c>
	{
		pre_temper = temper;
		MAX20353_UpdateRCOMP(temper);	
   1d81c:	4628      	mov	r0, r5
		pre_temper = temper;
   1d81e:	801d      	strh	r5, [r3, #0]
		MAX20353_UpdateRCOMP(temper);	
   1d820:	f005 fda0 	bl	23364 <MAX20353_UpdateRCOMP>
	}
}
   1d824:	b025      	add	sp, #148	; 0x94
   1d826:	ecbd 8b02 	vpop	{d8}
   1d82a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		else if(end == tmp-1)
   1d82e:	1e6b      	subs	r3, r5, #1
   1d830:	4598      	cmp	r8, r3
   1d832:	d14d      	bne.n	1d8d0 <MAX20353_UpdateTemper+0x248>
			com1 = fabs(ntc_table[tmp].impedance-resistance);
   1d834:	eb07 03c5 	add.w	r3, r7, r5, lsl #3
   1d838:	edd3 7a01 	vldr	s15, [r3, #4]
   1d83c:	ee77 7ac8 	vsub.f32	s15, s15, s16
   1d840:	ee17 0a90 	vmov	r0, s15
   1d844:	f7fe ff60 	bl	1c708 <__aeabi_f2d>
   1d848:	ec41 0b10 	vmov	d0, r0, r1
   1d84c:	f018 f93a 	bl	35ac4 <fabs>
   1d850:	ec51 0b10 	vmov	r0, r1, d0
   1d854:	f7ff fa6a 	bl	1cd2c <__aeabi_d2f>
			com2 = fabs(ntc_table[tmp-1].impedance-resistance);
   1d858:	eb07 03c8 	add.w	r3, r7, r8, lsl #3
   1d85c:	edd3 7a01 	vldr	s15, [r3, #4]
   1d860:	ee77 7ac8 	vsub.f32	s15, s15, s16
			com1 = fabs(ntc_table[tmp].impedance-resistance);
   1d864:	ee08 0a90 	vmov	s17, r0
			com2 = fabs(ntc_table[tmp-1].impedance-resistance);
   1d868:	ee17 0a90 	vmov	r0, s15
   1d86c:	f7fe ff4c 	bl	1c708 <__aeabi_f2d>
   1d870:	ec41 0b10 	vmov	d0, r0, r1
   1d874:	f018 f926 	bl	35ac4 <fabs>
   1d878:	ec51 0b10 	vmov	r0, r1, d0
   1d87c:	f7ff fa56 	bl	1cd2c <__aeabi_d2f>
   1d880:	ee08 0a10 	vmov	s16, r0
			sprintf(tmpbuf, "002 com1:%.4f, com2:%04f", com1, com2);
   1d884:	f7fe ff40 	bl	1c708 <__aeabi_f2d>
   1d888:	e9cd 0102 	strd	r0, r1, [sp, #8]
   1d88c:	ee18 0a90 	vmov	r0, s17
   1d890:	f7fe ff3a 	bl	1c708 <__aeabi_f2d>
   1d894:	4b23      	ldr	r3, [pc, #140]	; (1d924 <MAX20353_UpdateTemper+0x29c>)
   1d896:	e9cd 0100 	strd	r0, r1, [sp]
   1d89a:	2280      	movs	r2, #128	; 0x80
   1d89c:	2100      	movs	r1, #0
   1d89e:	a804      	add	r0, sp, #16
   1d8a0:	f01c fbcf 	bl	3a042 <__sprintf_chk>
			LOG_INF("%s\n", tmpbuf);
   1d8a4:	2303      	movs	r3, #3
   1d8a6:	f04f 0000 	mov.w	r0, #0
   1d8aa:	f363 0007 	bfi	r0, r3, #0, #8
   1d8ae:	f364 108f 	bfi	r0, r4, #6, #10
   1d8b2:	aa04      	add	r2, sp, #16
   1d8b4:	4916      	ldr	r1, [pc, #88]	; (1d910 <MAX20353_UpdateTemper+0x288>)
   1d8b6:	f01a fa5a 	bl	37d6e <log_string_sync>
			if(com1 > com2)
   1d8ba:	eef4 8ac8 	vcmpe.f32	s17, s16
   1d8be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d8c2:	dd02      	ble.n	1d8ca <MAX20353_UpdateTemper+0x242>
				temper = ntc_table[tmp-1].temperature;
   1d8c4:	f937 5038 	ldrsh.w	r5, [r7, r8, lsl #3]
   1d8c8:	e799      	b.n	1d7fe <MAX20353_UpdateTemper+0x176>
				temper = ntc_table[tmp].temperature;
   1d8ca:	f937 5035 	ldrsh.w	r5, [r7, r5, lsl #3]
   1d8ce:	e796      	b.n	1d7fe <MAX20353_UpdateTemper+0x176>
	s16_t temper=25;
   1d8d0:	2519      	movs	r5, #25
   1d8d2:	e794      	b.n	1d7fe <MAX20353_UpdateTemper+0x176>
		LOG_INF("find success!\n");
   1d8d4:	2303      	movs	r3, #3
   1d8d6:	f04f 0000 	mov.w	r0, #0
   1d8da:	f363 0007 	bfi	r0, r3, #0, #8
   1d8de:	f364 108f 	bfi	r0, r4, #6, #10
   1d8e2:	4911      	ldr	r1, [pc, #68]	; (1d928 <MAX20353_UpdateTemper+0x2a0>)
   1d8e4:	f01a fa43 	bl	37d6e <log_string_sync>
		temper = ntc_table[tmp].temperature;
   1d8e8:	f939 5035 	ldrsh.w	r5, [r9, r5, lsl #3]
   1d8ec:	e787      	b.n	1d7fe <MAX20353_UpdateTemper+0x176>
   1d8ee:	bf00      	nop
   1d8f0:	00000000 	.word	0x00000000
   1d8f4:	406fe000 	.word	0x406fe000
   1d8f8:	20024d05 	.word	0x20024d05
   1d8fc:	3ff00000 	.word	0x3ff00000
   1d900:	40240000 	.word	0x40240000
   1d904:	0003cb7e 	.word	0x0003cb7e
   1d908:	0003ae80 	.word	0x0003ae80
   1d90c:	0003ade0 	.word	0x0003ade0
   1d910:	0003e245 	.word	0x0003e245
   1d914:	0003cbda 	.word	0x0003cbda
   1d918:	0003cb8e 	.word	0x0003cb8e
   1d91c:	0003cbc0 	.word	0x0003cbc0
   1d920:	2002b236 	.word	0x2002b236
   1d924:	0003cba7 	.word	0x0003cba7
   1d928:	0003cbcb 	.word	0x0003cbcb
   1d92c:	0003b1e8 	.word	0x0003b1e8

0001d930 <_dtoa_r>:
   1d930:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1d934:	6a47      	ldr	r7, [r0, #36]	; 0x24
   1d936:	b099      	sub	sp, #100	; 0x64
   1d938:	4683      	mov	fp, r0
   1d93a:	9108      	str	r1, [sp, #32]
   1d93c:	920d      	str	r2, [sp, #52]	; 0x34
   1d93e:	9314      	str	r3, [sp, #80]	; 0x50
   1d940:	9e22      	ldr	r6, [sp, #136]	; 0x88
   1d942:	ec55 4b10 	vmov	r4, r5, d0
   1d946:	e9cd 4500 	strd	r4, r5, [sp]
   1d94a:	b947      	cbnz	r7, 1d95e <_dtoa_r+0x2e>
   1d94c:	2010      	movs	r0, #16
   1d94e:	f019 f983 	bl	36c58 <malloc>
   1d952:	f8cb 0024 	str.w	r0, [fp, #36]	; 0x24
   1d956:	6007      	str	r7, [r0, #0]
   1d958:	60c7      	str	r7, [r0, #12]
   1d95a:	e9c0 7701 	strd	r7, r7, [r0, #4]
   1d95e:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
   1d962:	6819      	ldr	r1, [r3, #0]
   1d964:	b159      	cbz	r1, 1d97e <_dtoa_r+0x4e>
   1d966:	685a      	ldr	r2, [r3, #4]
   1d968:	2301      	movs	r3, #1
   1d96a:	4658      	mov	r0, fp
   1d96c:	4093      	lsls	r3, r2
   1d96e:	604a      	str	r2, [r1, #4]
   1d970:	608b      	str	r3, [r1, #8]
   1d972:	f01c fd28 	bl	3a3c6 <_Bfree>
   1d976:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
   1d97a:	2200      	movs	r2, #0
   1d97c:	601a      	str	r2, [r3, #0]
   1d97e:	1e2b      	subs	r3, r5, #0
   1d980:	bfb7      	itett	lt
   1d982:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
   1d986:	2300      	movge	r3, #0
   1d988:	2201      	movlt	r2, #1
   1d98a:	9301      	strlt	r3, [sp, #4]
   1d98c:	bfa8      	it	ge
   1d98e:	6033      	strge	r3, [r6, #0]
   1d990:	9c01      	ldr	r4, [sp, #4]
   1d992:	4bb1      	ldr	r3, [pc, #708]	; (1dc58 <_dtoa_r+0x328>)
   1d994:	bfb8      	it	lt
   1d996:	6032      	strlt	r2, [r6, #0]
   1d998:	43a3      	bics	r3, r4
   1d99a:	d11a      	bne.n	1d9d2 <_dtoa_r+0xa2>
   1d99c:	f242 730f 	movw	r3, #9999	; 0x270f
   1d9a0:	9a14      	ldr	r2, [sp, #80]	; 0x50
   1d9a2:	6013      	str	r3, [r2, #0]
   1d9a4:	f3c4 0313 	ubfx	r3, r4, #0, #20
   1d9a8:	9a00      	ldr	r2, [sp, #0]
   1d9aa:	4313      	orrs	r3, r2
   1d9ac:	f000 8547 	beq.w	1e43e <_dtoa_r+0xb0e>
   1d9b0:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   1d9b2:	b953      	cbnz	r3, 1d9ca <_dtoa_r+0x9a>
   1d9b4:	4ba9      	ldr	r3, [pc, #676]	; (1dc5c <_dtoa_r+0x32c>)
   1d9b6:	e023      	b.n	1da00 <_dtoa_r+0xd0>
   1d9b8:	4ba9      	ldr	r3, [pc, #676]	; (1dc60 <_dtoa_r+0x330>)
   1d9ba:	9303      	str	r3, [sp, #12]
   1d9bc:	3308      	adds	r3, #8
   1d9be:	9a23      	ldr	r2, [sp, #140]	; 0x8c
   1d9c0:	6013      	str	r3, [r2, #0]
   1d9c2:	9803      	ldr	r0, [sp, #12]
   1d9c4:	b019      	add	sp, #100	; 0x64
   1d9c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1d9ca:	4ba4      	ldr	r3, [pc, #656]	; (1dc5c <_dtoa_r+0x32c>)
   1d9cc:	9303      	str	r3, [sp, #12]
   1d9ce:	3303      	adds	r3, #3
   1d9d0:	e7f5      	b.n	1d9be <_dtoa_r+0x8e>
   1d9d2:	ed9d 7b00 	vldr	d7, [sp]
   1d9d6:	2200      	movs	r2, #0
   1d9d8:	2300      	movs	r3, #0
   1d9da:	ec51 0b17 	vmov	r0, r1, d7
   1d9de:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
   1d9e2:	f7ff f951 	bl	1cc88 <__aeabi_dcmpeq>
   1d9e6:	4607      	mov	r7, r0
   1d9e8:	b160      	cbz	r0, 1da04 <_dtoa_r+0xd4>
   1d9ea:	2301      	movs	r3, #1
   1d9ec:	9a14      	ldr	r2, [sp, #80]	; 0x50
   1d9ee:	6013      	str	r3, [r2, #0]
   1d9f0:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   1d9f2:	2b00      	cmp	r3, #0
   1d9f4:	f000 8520 	beq.w	1e438 <_dtoa_r+0xb08>
   1d9f8:	4b9a      	ldr	r3, [pc, #616]	; (1dc64 <_dtoa_r+0x334>)
   1d9fa:	9a23      	ldr	r2, [sp, #140]	; 0x8c
   1d9fc:	6013      	str	r3, [r2, #0]
   1d9fe:	3b01      	subs	r3, #1
   1da00:	9303      	str	r3, [sp, #12]
   1da02:	e7de      	b.n	1d9c2 <_dtoa_r+0x92>
   1da04:	f3c4 560a 	ubfx	r6, r4, #20, #11
   1da08:	aa16      	add	r2, sp, #88	; 0x58
   1da0a:	a917      	add	r1, sp, #92	; 0x5c
   1da0c:	4658      	mov	r0, fp
   1da0e:	ed9d 0b0e 	vldr	d0, [sp, #56]	; 0x38
   1da12:	f01c fee1 	bl	3a7d8 <__d2b>
   1da16:	4680      	mov	r8, r0
   1da18:	2e00      	cmp	r6, #0
   1da1a:	d07d      	beq.n	1db18 <_dtoa_r+0x1e8>
   1da1c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1da1e:	f2a6 36ff 	subw	r6, r6, #1023	; 0x3ff
   1da22:	9715      	str	r7, [sp, #84]	; 0x54
   1da24:	f3c3 0313 	ubfx	r3, r3, #0, #20
   1da28:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
   1da2c:	f043 557f 	orr.w	r5, r3, #1069547520	; 0x3fc00000
   1da30:	f445 1540 	orr.w	r5, r5, #3145728	; 0x300000
   1da34:	2200      	movs	r2, #0
   1da36:	4b8c      	ldr	r3, [pc, #560]	; (1dc68 <_dtoa_r+0x338>)
   1da38:	4620      	mov	r0, r4
   1da3a:	4629      	mov	r1, r5
   1da3c:	f7fe fd04 	bl	1c448 <__aeabi_dsub>
   1da40:	a37f      	add	r3, pc, #508	; (adr r3, 1dc40 <_dtoa_r+0x310>)
   1da42:	e9d3 2300 	ldrd	r2, r3, [r3]
   1da46:	f7fe feb7 	bl	1c7b8 <__aeabi_dmul>
   1da4a:	a37f      	add	r3, pc, #508	; (adr r3, 1dc48 <_dtoa_r+0x318>)
   1da4c:	e9d3 2300 	ldrd	r2, r3, [r3]
   1da50:	f7fe fcfc 	bl	1c44c <__adddf3>
   1da54:	4604      	mov	r4, r0
   1da56:	460d      	mov	r5, r1
   1da58:	4630      	mov	r0, r6
   1da5a:	f7fe fe43 	bl	1c6e4 <__aeabi_i2d>
   1da5e:	a37c      	add	r3, pc, #496	; (adr r3, 1dc50 <_dtoa_r+0x320>)
   1da60:	e9d3 2300 	ldrd	r2, r3, [r3]
   1da64:	f7fe fea8 	bl	1c7b8 <__aeabi_dmul>
   1da68:	4602      	mov	r2, r0
   1da6a:	460b      	mov	r3, r1
   1da6c:	4620      	mov	r0, r4
   1da6e:	4629      	mov	r1, r5
   1da70:	f7fe fcec 	bl	1c44c <__adddf3>
   1da74:	4604      	mov	r4, r0
   1da76:	460d      	mov	r5, r1
   1da78:	f7ff fb3c 	bl	1d0f4 <__aeabi_d2iz>
   1da7c:	2200      	movs	r2, #0
   1da7e:	4682      	mov	sl, r0
   1da80:	2300      	movs	r3, #0
   1da82:	4620      	mov	r0, r4
   1da84:	4629      	mov	r1, r5
   1da86:	f7ff f909 	bl	1cc9c <__aeabi_dcmplt>
   1da8a:	b148      	cbz	r0, 1daa0 <_dtoa_r+0x170>
   1da8c:	4650      	mov	r0, sl
   1da8e:	f7fe fe29 	bl	1c6e4 <__aeabi_i2d>
   1da92:	4622      	mov	r2, r4
   1da94:	462b      	mov	r3, r5
   1da96:	f7ff f8f7 	bl	1cc88 <__aeabi_dcmpeq>
   1da9a:	b908      	cbnz	r0, 1daa0 <_dtoa_r+0x170>
   1da9c:	f10a 3aff 	add.w	sl, sl, #4294967295
   1daa0:	f1ba 0f16 	cmp.w	sl, #22
   1daa4:	d857      	bhi.n	1db56 <_dtoa_r+0x226>
   1daa6:	4b71      	ldr	r3, [pc, #452]	; (1dc6c <_dtoa_r+0x33c>)
   1daa8:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
   1daac:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   1dab0:	e9d3 2300 	ldrd	r2, r3, [r3]
   1dab4:	f7ff f8f2 	bl	1cc9c <__aeabi_dcmplt>
   1dab8:	2800      	cmp	r0, #0
   1daba:	d04e      	beq.n	1db5a <_dtoa_r+0x22a>
   1dabc:	f10a 3aff 	add.w	sl, sl, #4294967295
   1dac0:	2300      	movs	r3, #0
   1dac2:	9311      	str	r3, [sp, #68]	; 0x44
   1dac4:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1dac6:	1b9e      	subs	r6, r3, r6
   1dac8:	1e73      	subs	r3, r6, #1
   1daca:	9307      	str	r3, [sp, #28]
   1dacc:	bf49      	itett	mi
   1dace:	f1c6 0301 	rsbmi	r3, r6, #1
   1dad2:	2300      	movpl	r3, #0
   1dad4:	9306      	strmi	r3, [sp, #24]
   1dad6:	2300      	movmi	r3, #0
   1dad8:	bf54      	ite	pl
   1dada:	9306      	strpl	r3, [sp, #24]
   1dadc:	9307      	strmi	r3, [sp, #28]
   1dade:	f1ba 0f00 	cmp.w	sl, #0
   1dae2:	db3c      	blt.n	1db5e <_dtoa_r+0x22e>
   1dae4:	9b07      	ldr	r3, [sp, #28]
   1dae6:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
   1daea:	4453      	add	r3, sl
   1daec:	9307      	str	r3, [sp, #28]
   1daee:	2300      	movs	r3, #0
   1daf0:	9309      	str	r3, [sp, #36]	; 0x24
   1daf2:	9b08      	ldr	r3, [sp, #32]
   1daf4:	2b09      	cmp	r3, #9
   1daf6:	f200 808d 	bhi.w	1dc14 <_dtoa_r+0x2e4>
   1dafa:	2b05      	cmp	r3, #5
   1dafc:	bfc5      	ittet	gt
   1dafe:	3b04      	subgt	r3, #4
   1db00:	2400      	movgt	r4, #0
   1db02:	2401      	movle	r4, #1
   1db04:	9308      	strgt	r3, [sp, #32]
   1db06:	9b08      	ldr	r3, [sp, #32]
   1db08:	3b02      	subs	r3, #2
   1db0a:	2b03      	cmp	r3, #3
   1db0c:	f200 808d 	bhi.w	1dc2a <_dtoa_r+0x2fa>
   1db10:	e8df f003 	tbb	[pc, r3]
   1db14:	7e3a3c2f 	.word	0x7e3a3c2f
   1db18:	e9dd 6316 	ldrd	r6, r3, [sp, #88]	; 0x58
   1db1c:	441e      	add	r6, r3
   1db1e:	f206 4032 	addw	r0, r6, #1074	; 0x432
   1db22:	2820      	cmp	r0, #32
   1db24:	dd11      	ble.n	1db4a <_dtoa_r+0x21a>
   1db26:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
   1db2a:	9b00      	ldr	r3, [sp, #0]
   1db2c:	4084      	lsls	r4, r0
   1db2e:	f206 4012 	addw	r0, r6, #1042	; 0x412
   1db32:	fa23 f000 	lsr.w	r0, r3, r0
   1db36:	4320      	orrs	r0, r4
   1db38:	f7fe fdc4 	bl	1c6c4 <__aeabi_ui2d>
   1db3c:	2301      	movs	r3, #1
   1db3e:	4604      	mov	r4, r0
   1db40:	f1a1 75f8 	sub.w	r5, r1, #32505856	; 0x1f00000
   1db44:	3e01      	subs	r6, #1
   1db46:	9315      	str	r3, [sp, #84]	; 0x54
   1db48:	e774      	b.n	1da34 <_dtoa_r+0x104>
   1db4a:	f1c0 0020 	rsb	r0, r0, #32
   1db4e:	9b00      	ldr	r3, [sp, #0]
   1db50:	fa03 f000 	lsl.w	r0, r3, r0
   1db54:	e7f0      	b.n	1db38 <_dtoa_r+0x208>
   1db56:	2301      	movs	r3, #1
   1db58:	e7b3      	b.n	1dac2 <_dtoa_r+0x192>
   1db5a:	9011      	str	r0, [sp, #68]	; 0x44
   1db5c:	e7b2      	b.n	1dac4 <_dtoa_r+0x194>
   1db5e:	9b06      	ldr	r3, [sp, #24]
   1db60:	eba3 030a 	sub.w	r3, r3, sl
   1db64:	9306      	str	r3, [sp, #24]
   1db66:	f1ca 0300 	rsb	r3, sl, #0
   1db6a:	9309      	str	r3, [sp, #36]	; 0x24
   1db6c:	2300      	movs	r3, #0
   1db6e:	9310      	str	r3, [sp, #64]	; 0x40
   1db70:	e7bf      	b.n	1daf2 <_dtoa_r+0x1c2>
   1db72:	2300      	movs	r3, #0
   1db74:	930c      	str	r3, [sp, #48]	; 0x30
   1db76:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1db78:	2b00      	cmp	r3, #0
   1db7a:	dc59      	bgt.n	1dc30 <_dtoa_r+0x300>
   1db7c:	2301      	movs	r3, #1
   1db7e:	4699      	mov	r9, r3
   1db80:	461a      	mov	r2, r3
   1db82:	9304      	str	r3, [sp, #16]
   1db84:	920d      	str	r2, [sp, #52]	; 0x34
   1db86:	e00c      	b.n	1dba2 <_dtoa_r+0x272>
   1db88:	2301      	movs	r3, #1
   1db8a:	e7f3      	b.n	1db74 <_dtoa_r+0x244>
   1db8c:	2300      	movs	r3, #0
   1db8e:	930c      	str	r3, [sp, #48]	; 0x30
   1db90:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1db92:	4453      	add	r3, sl
   1db94:	f103 0901 	add.w	r9, r3, #1
   1db98:	9304      	str	r3, [sp, #16]
   1db9a:	464b      	mov	r3, r9
   1db9c:	2b01      	cmp	r3, #1
   1db9e:	bfb8      	it	lt
   1dba0:	2301      	movlt	r3, #1
   1dba2:	2200      	movs	r2, #0
   1dba4:	f8db 5024 	ldr.w	r5, [fp, #36]	; 0x24
   1dba8:	606a      	str	r2, [r5, #4]
   1dbaa:	2204      	movs	r2, #4
   1dbac:	f102 0014 	add.w	r0, r2, #20
   1dbb0:	6869      	ldr	r1, [r5, #4]
   1dbb2:	4298      	cmp	r0, r3
   1dbb4:	d940      	bls.n	1dc38 <_dtoa_r+0x308>
   1dbb6:	4658      	mov	r0, fp
   1dbb8:	f01c fbd1 	bl	3a35e <_Balloc>
   1dbbc:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
   1dbc0:	6028      	str	r0, [r5, #0]
   1dbc2:	f1b9 0f0e 	cmp.w	r9, #14
   1dbc6:	681b      	ldr	r3, [r3, #0]
   1dbc8:	9303      	str	r3, [sp, #12]
   1dbca:	f200 80d4 	bhi.w	1dd76 <_dtoa_r+0x446>
   1dbce:	2c00      	cmp	r4, #0
   1dbd0:	f000 80d1 	beq.w	1dd76 <_dtoa_r+0x446>
   1dbd4:	f1ba 0f00 	cmp.w	sl, #0
   1dbd8:	dd66      	ble.n	1dca8 <_dtoa_r+0x378>
   1dbda:	4a24      	ldr	r2, [pc, #144]	; (1dc6c <_dtoa_r+0x33c>)
   1dbdc:	f00a 030f 	and.w	r3, sl, #15
   1dbe0:	ea4f 142a 	mov.w	r4, sl, asr #4
   1dbe4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   1dbe8:	06e2      	lsls	r2, r4, #27
   1dbea:	ed93 7b00 	vldr	d7, [r3]
   1dbee:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
   1dbf2:	d557      	bpl.n	1dca4 <_dtoa_r+0x374>
   1dbf4:	4b1e      	ldr	r3, [pc, #120]	; (1dc70 <_dtoa_r+0x340>)
   1dbf6:	f004 040f 	and.w	r4, r4, #15
   1dbfa:	2603      	movs	r6, #3
   1dbfc:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
   1dc00:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   1dc04:	f7fe ff02 	bl	1ca0c <__aeabi_ddiv>
   1dc08:	e9cd 0100 	strd	r0, r1, [sp]
   1dc0c:	4d18      	ldr	r5, [pc, #96]	; (1dc70 <_dtoa_r+0x340>)
   1dc0e:	e03e      	b.n	1dc8e <_dtoa_r+0x35e>
   1dc10:	2301      	movs	r3, #1
   1dc12:	e7bc      	b.n	1db8e <_dtoa_r+0x25e>
   1dc14:	2401      	movs	r4, #1
   1dc16:	2300      	movs	r3, #0
   1dc18:	940c      	str	r4, [sp, #48]	; 0x30
   1dc1a:	9308      	str	r3, [sp, #32]
   1dc1c:	f04f 33ff 	mov.w	r3, #4294967295
   1dc20:	2200      	movs	r2, #0
   1dc22:	9304      	str	r3, [sp, #16]
   1dc24:	4699      	mov	r9, r3
   1dc26:	2312      	movs	r3, #18
   1dc28:	e7ac      	b.n	1db84 <_dtoa_r+0x254>
   1dc2a:	2301      	movs	r3, #1
   1dc2c:	930c      	str	r3, [sp, #48]	; 0x30
   1dc2e:	e7f5      	b.n	1dc1c <_dtoa_r+0x2ec>
   1dc30:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1dc32:	9304      	str	r3, [sp, #16]
   1dc34:	4699      	mov	r9, r3
   1dc36:	e7b4      	b.n	1dba2 <_dtoa_r+0x272>
   1dc38:	3101      	adds	r1, #1
   1dc3a:	0052      	lsls	r2, r2, #1
   1dc3c:	6069      	str	r1, [r5, #4]
   1dc3e:	e7b5      	b.n	1dbac <_dtoa_r+0x27c>
   1dc40:	636f4361 	.word	0x636f4361
   1dc44:	3fd287a7 	.word	0x3fd287a7
   1dc48:	8b60c8b3 	.word	0x8b60c8b3
   1dc4c:	3fc68a28 	.word	0x3fc68a28
   1dc50:	509f79fb 	.word	0x509f79fb
   1dc54:	3fd34413 	.word	0x3fd34413
   1dc58:	7ff00000 	.word	0x7ff00000
   1dc5c:	0003f740 	.word	0x0003f740
   1dc60:	0003f737 	.word	0x0003f737
   1dc64:	0003f10f 	.word	0x0003f10f
   1dc68:	3ff80000 	.word	0x3ff80000
   1dc6c:	0003b110 	.word	0x0003b110
   1dc70:	0003b0e8 	.word	0x0003b0e8
   1dc74:	07e3      	lsls	r3, r4, #31
   1dc76:	d508      	bpl.n	1dc8a <_dtoa_r+0x35a>
   1dc78:	3601      	adds	r6, #1
   1dc7a:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   1dc7e:	e9d5 2300 	ldrd	r2, r3, [r5]
   1dc82:	f7fe fd99 	bl	1c7b8 <__aeabi_dmul>
   1dc86:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   1dc8a:	1064      	asrs	r4, r4, #1
   1dc8c:	3508      	adds	r5, #8
   1dc8e:	2c00      	cmp	r4, #0
   1dc90:	d1f0      	bne.n	1dc74 <_dtoa_r+0x344>
   1dc92:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
   1dc96:	e9dd 0100 	ldrd	r0, r1, [sp]
   1dc9a:	f7fe feb7 	bl	1ca0c <__aeabi_ddiv>
   1dc9e:	e9cd 0100 	strd	r0, r1, [sp]
   1dca2:	e01a      	b.n	1dcda <_dtoa_r+0x3aa>
   1dca4:	2602      	movs	r6, #2
   1dca6:	e7b1      	b.n	1dc0c <_dtoa_r+0x2dc>
   1dca8:	f000 809f 	beq.w	1ddea <_dtoa_r+0x4ba>
   1dcac:	f1ca 0400 	rsb	r4, sl, #0
   1dcb0:	4b9e      	ldr	r3, [pc, #632]	; (1df2c <_dtoa_r+0x5fc>)
   1dcb2:	4d9f      	ldr	r5, [pc, #636]	; (1df30 <_dtoa_r+0x600>)
   1dcb4:	2602      	movs	r6, #2
   1dcb6:	f004 020f 	and.w	r2, r4, #15
   1dcba:	1124      	asrs	r4, r4, #4
   1dcbc:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   1dcc0:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   1dcc4:	e9d3 2300 	ldrd	r2, r3, [r3]
   1dcc8:	f7fe fd76 	bl	1c7b8 <__aeabi_dmul>
   1dccc:	2300      	movs	r3, #0
   1dcce:	e9cd 0100 	strd	r0, r1, [sp]
   1dcd2:	2c00      	cmp	r4, #0
   1dcd4:	d17e      	bne.n	1ddd4 <_dtoa_r+0x4a4>
   1dcd6:	2b00      	cmp	r3, #0
   1dcd8:	d1e1      	bne.n	1dc9e <_dtoa_r+0x36e>
   1dcda:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1dcdc:	2b00      	cmp	r3, #0
   1dcde:	f000 8086 	beq.w	1ddee <_dtoa_r+0x4be>
   1dce2:	2200      	movs	r2, #0
   1dce4:	4b93      	ldr	r3, [pc, #588]	; (1df34 <_dtoa_r+0x604>)
   1dce6:	e9dd 4500 	ldrd	r4, r5, [sp]
   1dcea:	4620      	mov	r0, r4
   1dcec:	4629      	mov	r1, r5
   1dcee:	f7fe ffd5 	bl	1cc9c <__aeabi_dcmplt>
   1dcf2:	2800      	cmp	r0, #0
   1dcf4:	d07b      	beq.n	1ddee <_dtoa_r+0x4be>
   1dcf6:	f1b9 0f00 	cmp.w	r9, #0
   1dcfa:	d078      	beq.n	1ddee <_dtoa_r+0x4be>
   1dcfc:	9b04      	ldr	r3, [sp, #16]
   1dcfe:	2b00      	cmp	r3, #0
   1dd00:	dd35      	ble.n	1dd6e <_dtoa_r+0x43e>
   1dd02:	f10a 33ff 	add.w	r3, sl, #4294967295
   1dd06:	4620      	mov	r0, r4
   1dd08:	2200      	movs	r2, #0
   1dd0a:	4629      	mov	r1, r5
   1dd0c:	930a      	str	r3, [sp, #40]	; 0x28
   1dd0e:	3601      	adds	r6, #1
   1dd10:	4b89      	ldr	r3, [pc, #548]	; (1df38 <_dtoa_r+0x608>)
   1dd12:	f7fe fd51 	bl	1c7b8 <__aeabi_dmul>
   1dd16:	9c04      	ldr	r4, [sp, #16]
   1dd18:	e9cd 0100 	strd	r0, r1, [sp]
   1dd1c:	4630      	mov	r0, r6
   1dd1e:	f7fe fce1 	bl	1c6e4 <__aeabi_i2d>
   1dd22:	e9dd 2300 	ldrd	r2, r3, [sp]
   1dd26:	f7fe fd47 	bl	1c7b8 <__aeabi_dmul>
   1dd2a:	2200      	movs	r2, #0
   1dd2c:	4b83      	ldr	r3, [pc, #524]	; (1df3c <_dtoa_r+0x60c>)
   1dd2e:	f7fe fb8d 	bl	1c44c <__adddf3>
   1dd32:	4606      	mov	r6, r0
   1dd34:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
   1dd38:	2c00      	cmp	r4, #0
   1dd3a:	d15c      	bne.n	1ddf6 <_dtoa_r+0x4c6>
   1dd3c:	2200      	movs	r2, #0
   1dd3e:	4b80      	ldr	r3, [pc, #512]	; (1df40 <_dtoa_r+0x610>)
   1dd40:	e9dd 0100 	ldrd	r0, r1, [sp]
   1dd44:	f7fe fb80 	bl	1c448 <__aeabi_dsub>
   1dd48:	4632      	mov	r2, r6
   1dd4a:	463b      	mov	r3, r7
   1dd4c:	e9cd 0100 	strd	r0, r1, [sp]
   1dd50:	f7fe ffc2 	bl	1ccd8 <__aeabi_dcmpgt>
   1dd54:	2800      	cmp	r0, #0
   1dd56:	f040 8289 	bne.w	1e26c <_dtoa_r+0x93c>
   1dd5a:	4632      	mov	r2, r6
   1dd5c:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
   1dd60:	e9dd 0100 	ldrd	r0, r1, [sp]
   1dd64:	f7fe ff9a 	bl	1cc9c <__aeabi_dcmplt>
   1dd68:	2800      	cmp	r0, #0
   1dd6a:	f040 827d 	bne.w	1e268 <_dtoa_r+0x938>
   1dd6e:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
   1dd72:	e9cd 3400 	strd	r3, r4, [sp]
   1dd76:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1dd78:	2b00      	cmp	r3, #0
   1dd7a:	f2c0 814c 	blt.w	1e016 <_dtoa_r+0x6e6>
   1dd7e:	f1ba 0f0e 	cmp.w	sl, #14
   1dd82:	f300 8148 	bgt.w	1e016 <_dtoa_r+0x6e6>
   1dd86:	4b69      	ldr	r3, [pc, #420]	; (1df2c <_dtoa_r+0x5fc>)
   1dd88:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
   1dd8c:	ed93 7b00 	vldr	d7, [r3]
   1dd90:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1dd92:	2b00      	cmp	r3, #0
   1dd94:	ed8d 7b04 	vstr	d7, [sp, #16]
   1dd98:	f280 80d6 	bge.w	1df48 <_dtoa_r+0x618>
   1dd9c:	f1b9 0f00 	cmp.w	r9, #0
   1dda0:	f300 80d2 	bgt.w	1df48 <_dtoa_r+0x618>
   1dda4:	f040 825f 	bne.w	1e266 <_dtoa_r+0x936>
   1dda8:	2200      	movs	r2, #0
   1ddaa:	4b65      	ldr	r3, [pc, #404]	; (1df40 <_dtoa_r+0x610>)
   1ddac:	464c      	mov	r4, r9
   1ddae:	464e      	mov	r6, r9
   1ddb0:	ec51 0b17 	vmov	r0, r1, d7
   1ddb4:	f7fe fd00 	bl	1c7b8 <__aeabi_dmul>
   1ddb8:	e9dd 2300 	ldrd	r2, r3, [sp]
   1ddbc:	f7fe ff82 	bl	1ccc4 <__aeabi_dcmpge>
   1ddc0:	2800      	cmp	r0, #0
   1ddc2:	f040 8238 	bne.w	1e236 <_dtoa_r+0x906>
   1ddc6:	9d03      	ldr	r5, [sp, #12]
   1ddc8:	2331      	movs	r3, #49	; 0x31
   1ddca:	f10a 0a01 	add.w	sl, sl, #1
   1ddce:	f805 3b01 	strb.w	r3, [r5], #1
   1ddd2:	e234      	b.n	1e23e <_dtoa_r+0x90e>
   1ddd4:	07e7      	lsls	r7, r4, #31
   1ddd6:	d505      	bpl.n	1dde4 <_dtoa_r+0x4b4>
   1ddd8:	3601      	adds	r6, #1
   1ddda:	e9d5 2300 	ldrd	r2, r3, [r5]
   1ddde:	f7fe fceb 	bl	1c7b8 <__aeabi_dmul>
   1dde2:	2301      	movs	r3, #1
   1dde4:	1064      	asrs	r4, r4, #1
   1dde6:	3508      	adds	r5, #8
   1dde8:	e773      	b.n	1dcd2 <_dtoa_r+0x3a2>
   1ddea:	2602      	movs	r6, #2
   1ddec:	e775      	b.n	1dcda <_dtoa_r+0x3aa>
   1ddee:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
   1ddf2:	464c      	mov	r4, r9
   1ddf4:	e792      	b.n	1dd1c <_dtoa_r+0x3ec>
   1ddf6:	4b4d      	ldr	r3, [pc, #308]	; (1df2c <_dtoa_r+0x5fc>)
   1ddf8:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
   1ddfc:	e953 0102 	ldrd	r0, r1, [r3, #-8]
   1de00:	9b03      	ldr	r3, [sp, #12]
   1de02:	441c      	add	r4, r3
   1de04:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1de06:	2b00      	cmp	r3, #0
   1de08:	d046      	beq.n	1de98 <_dtoa_r+0x568>
   1de0a:	4602      	mov	r2, r0
   1de0c:	460b      	mov	r3, r1
   1de0e:	2000      	movs	r0, #0
   1de10:	494c      	ldr	r1, [pc, #304]	; (1df44 <_dtoa_r+0x614>)
   1de12:	f7fe fdfb 	bl	1ca0c <__aeabi_ddiv>
   1de16:	4632      	mov	r2, r6
   1de18:	463b      	mov	r3, r7
   1de1a:	f7fe fb15 	bl	1c448 <__aeabi_dsub>
   1de1e:	9d03      	ldr	r5, [sp, #12]
   1de20:	4606      	mov	r6, r0
   1de22:	460f      	mov	r7, r1
   1de24:	e9dd 0100 	ldrd	r0, r1, [sp]
   1de28:	f7ff f964 	bl	1d0f4 <__aeabi_d2iz>
   1de2c:	9012      	str	r0, [sp, #72]	; 0x48
   1de2e:	f7fe fc59 	bl	1c6e4 <__aeabi_i2d>
   1de32:	4602      	mov	r2, r0
   1de34:	460b      	mov	r3, r1
   1de36:	e9dd 0100 	ldrd	r0, r1, [sp]
   1de3a:	f7fe fb05 	bl	1c448 <__aeabi_dsub>
   1de3e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1de40:	4632      	mov	r2, r6
   1de42:	3330      	adds	r3, #48	; 0x30
   1de44:	f805 3b01 	strb.w	r3, [r5], #1
   1de48:	463b      	mov	r3, r7
   1de4a:	e9cd 0100 	strd	r0, r1, [sp]
   1de4e:	f7fe ff25 	bl	1cc9c <__aeabi_dcmplt>
   1de52:	2800      	cmp	r0, #0
   1de54:	d15f      	bne.n	1df16 <_dtoa_r+0x5e6>
   1de56:	2000      	movs	r0, #0
   1de58:	4936      	ldr	r1, [pc, #216]	; (1df34 <_dtoa_r+0x604>)
   1de5a:	e9dd 2300 	ldrd	r2, r3, [sp]
   1de5e:	f7fe faf3 	bl	1c448 <__aeabi_dsub>
   1de62:	4632      	mov	r2, r6
   1de64:	463b      	mov	r3, r7
   1de66:	f7fe ff19 	bl	1cc9c <__aeabi_dcmplt>
   1de6a:	2800      	cmp	r0, #0
   1de6c:	f040 80b2 	bne.w	1dfd4 <_dtoa_r+0x6a4>
   1de70:	42a5      	cmp	r5, r4
   1de72:	f43f af7c 	beq.w	1dd6e <_dtoa_r+0x43e>
   1de76:	2200      	movs	r2, #0
   1de78:	4b2f      	ldr	r3, [pc, #188]	; (1df38 <_dtoa_r+0x608>)
   1de7a:	4630      	mov	r0, r6
   1de7c:	4639      	mov	r1, r7
   1de7e:	f7fe fc9b 	bl	1c7b8 <__aeabi_dmul>
   1de82:	2200      	movs	r2, #0
   1de84:	4606      	mov	r6, r0
   1de86:	460f      	mov	r7, r1
   1de88:	4b2b      	ldr	r3, [pc, #172]	; (1df38 <_dtoa_r+0x608>)
   1de8a:	e9dd 0100 	ldrd	r0, r1, [sp]
   1de8e:	f7fe fc93 	bl	1c7b8 <__aeabi_dmul>
   1de92:	e9cd 0100 	strd	r0, r1, [sp]
   1de96:	e7c5      	b.n	1de24 <_dtoa_r+0x4f4>
   1de98:	4632      	mov	r2, r6
   1de9a:	463b      	mov	r3, r7
   1de9c:	f7fe fc8c 	bl	1c7b8 <__aeabi_dmul>
   1dea0:	4625      	mov	r5, r4
   1dea2:	9e03      	ldr	r6, [sp, #12]
   1dea4:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
   1dea8:	e9dd 0100 	ldrd	r0, r1, [sp]
   1deac:	f7ff f922 	bl	1d0f4 <__aeabi_d2iz>
   1deb0:	4607      	mov	r7, r0
   1deb2:	f7fe fc17 	bl	1c6e4 <__aeabi_i2d>
   1deb6:	4602      	mov	r2, r0
   1deb8:	3730      	adds	r7, #48	; 0x30
   1deba:	460b      	mov	r3, r1
   1debc:	e9dd 0100 	ldrd	r0, r1, [sp]
   1dec0:	f7fe fac2 	bl	1c448 <__aeabi_dsub>
   1dec4:	f806 7b01 	strb.w	r7, [r6], #1
   1dec8:	42a6      	cmp	r6, r4
   1deca:	f04f 0200 	mov.w	r2, #0
   1dece:	e9cd 0100 	strd	r0, r1, [sp]
   1ded2:	d125      	bne.n	1df20 <_dtoa_r+0x5f0>
   1ded4:	4b1b      	ldr	r3, [pc, #108]	; (1df44 <_dtoa_r+0x614>)
   1ded6:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
   1deda:	f7fe fab7 	bl	1c44c <__adddf3>
   1dede:	4602      	mov	r2, r0
   1dee0:	460b      	mov	r3, r1
   1dee2:	e9dd 0100 	ldrd	r0, r1, [sp]
   1dee6:	f7fe fef7 	bl	1ccd8 <__aeabi_dcmpgt>
   1deea:	2800      	cmp	r0, #0
   1deec:	d172      	bne.n	1dfd4 <_dtoa_r+0x6a4>
   1deee:	2000      	movs	r0, #0
   1def0:	4914      	ldr	r1, [pc, #80]	; (1df44 <_dtoa_r+0x614>)
   1def2:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
   1def6:	f7fe faa7 	bl	1c448 <__aeabi_dsub>
   1defa:	4602      	mov	r2, r0
   1defc:	460b      	mov	r3, r1
   1defe:	e9dd 0100 	ldrd	r0, r1, [sp]
   1df02:	f7fe fecb 	bl	1cc9c <__aeabi_dcmplt>
   1df06:	2800      	cmp	r0, #0
   1df08:	f43f af31 	beq.w	1dd6e <_dtoa_r+0x43e>
   1df0c:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   1df10:	1e6a      	subs	r2, r5, #1
   1df12:	2b30      	cmp	r3, #48	; 0x30
   1df14:	d002      	beq.n	1df1c <_dtoa_r+0x5ec>
   1df16:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
   1df1a:	e049      	b.n	1dfb0 <_dtoa_r+0x680>
   1df1c:	4615      	mov	r5, r2
   1df1e:	e7f5      	b.n	1df0c <_dtoa_r+0x5dc>
   1df20:	4b05      	ldr	r3, [pc, #20]	; (1df38 <_dtoa_r+0x608>)
   1df22:	f7fe fc49 	bl	1c7b8 <__aeabi_dmul>
   1df26:	e9cd 0100 	strd	r0, r1, [sp]
   1df2a:	e7bd      	b.n	1dea8 <_dtoa_r+0x578>
   1df2c:	0003b110 	.word	0x0003b110
   1df30:	0003b0e8 	.word	0x0003b0e8
   1df34:	3ff00000 	.word	0x3ff00000
   1df38:	40240000 	.word	0x40240000
   1df3c:	401c0000 	.word	0x401c0000
   1df40:	40140000 	.word	0x40140000
   1df44:	3fe00000 	.word	0x3fe00000
   1df48:	e9dd 6700 	ldrd	r6, r7, [sp]
   1df4c:	9d03      	ldr	r5, [sp, #12]
   1df4e:	4630      	mov	r0, r6
   1df50:	4639      	mov	r1, r7
   1df52:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1df56:	f7fe fd59 	bl	1ca0c <__aeabi_ddiv>
   1df5a:	f7ff f8cb 	bl	1d0f4 <__aeabi_d2iz>
   1df5e:	4604      	mov	r4, r0
   1df60:	f7fe fbc0 	bl	1c6e4 <__aeabi_i2d>
   1df64:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1df68:	f7fe fc26 	bl	1c7b8 <__aeabi_dmul>
   1df6c:	4602      	mov	r2, r0
   1df6e:	4630      	mov	r0, r6
   1df70:	f104 0630 	add.w	r6, r4, #48	; 0x30
   1df74:	460b      	mov	r3, r1
   1df76:	4639      	mov	r1, r7
   1df78:	f7fe fa66 	bl	1c448 <__aeabi_dsub>
   1df7c:	f805 6b01 	strb.w	r6, [r5], #1
   1df80:	9e03      	ldr	r6, [sp, #12]
   1df82:	4602      	mov	r2, r0
   1df84:	460b      	mov	r3, r1
   1df86:	1bae      	subs	r6, r5, r6
   1df88:	45b1      	cmp	r9, r6
   1df8a:	d137      	bne.n	1dffc <_dtoa_r+0x6cc>
   1df8c:	f7fe fa5e 	bl	1c44c <__adddf3>
   1df90:	4606      	mov	r6, r0
   1df92:	460f      	mov	r7, r1
   1df94:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1df98:	f7fe fe9e 	bl	1ccd8 <__aeabi_dcmpgt>
   1df9c:	b9c0      	cbnz	r0, 1dfd0 <_dtoa_r+0x6a0>
   1df9e:	4630      	mov	r0, r6
   1dfa0:	4639      	mov	r1, r7
   1dfa2:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1dfa6:	f7fe fe6f 	bl	1cc88 <__aeabi_dcmpeq>
   1dfaa:	b108      	cbz	r0, 1dfb0 <_dtoa_r+0x680>
   1dfac:	07e1      	lsls	r1, r4, #31
   1dfae:	d40f      	bmi.n	1dfd0 <_dtoa_r+0x6a0>
   1dfb0:	4641      	mov	r1, r8
   1dfb2:	4658      	mov	r0, fp
   1dfb4:	f01c fa07 	bl	3a3c6 <_Bfree>
   1dfb8:	2300      	movs	r3, #0
   1dfba:	9a14      	ldr	r2, [sp, #80]	; 0x50
   1dfbc:	702b      	strb	r3, [r5, #0]
   1dfbe:	f10a 0301 	add.w	r3, sl, #1
   1dfc2:	6013      	str	r3, [r2, #0]
   1dfc4:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   1dfc6:	2b00      	cmp	r3, #0
   1dfc8:	f43f acfb 	beq.w	1d9c2 <_dtoa_r+0x92>
   1dfcc:	601d      	str	r5, [r3, #0]
   1dfce:	e4f8      	b.n	1d9c2 <_dtoa_r+0x92>
   1dfd0:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
   1dfd4:	f815 2c01 	ldrb.w	r2, [r5, #-1]
   1dfd8:	1e6b      	subs	r3, r5, #1
   1dfda:	2a39      	cmp	r2, #57	; 0x39
   1dfdc:	d108      	bne.n	1dff0 <_dtoa_r+0x6c0>
   1dfde:	9a03      	ldr	r2, [sp, #12]
   1dfe0:	429a      	cmp	r2, r3
   1dfe2:	d109      	bne.n	1dff8 <_dtoa_r+0x6c8>
   1dfe4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1dfe6:	9903      	ldr	r1, [sp, #12]
   1dfe8:	3201      	adds	r2, #1
   1dfea:	920a      	str	r2, [sp, #40]	; 0x28
   1dfec:	2230      	movs	r2, #48	; 0x30
   1dfee:	700a      	strb	r2, [r1, #0]
   1dff0:	781a      	ldrb	r2, [r3, #0]
   1dff2:	3201      	adds	r2, #1
   1dff4:	701a      	strb	r2, [r3, #0]
   1dff6:	e78e      	b.n	1df16 <_dtoa_r+0x5e6>
   1dff8:	461d      	mov	r5, r3
   1dffa:	e7eb      	b.n	1dfd4 <_dtoa_r+0x6a4>
   1dffc:	2200      	movs	r2, #0
   1dffe:	4b9d      	ldr	r3, [pc, #628]	; (1e274 <_dtoa_r+0x944>)
   1e000:	f7fe fbda 	bl	1c7b8 <__aeabi_dmul>
   1e004:	2200      	movs	r2, #0
   1e006:	2300      	movs	r3, #0
   1e008:	4606      	mov	r6, r0
   1e00a:	460f      	mov	r7, r1
   1e00c:	f7fe fe3c 	bl	1cc88 <__aeabi_dcmpeq>
   1e010:	2800      	cmp	r0, #0
   1e012:	d09c      	beq.n	1df4e <_dtoa_r+0x61e>
   1e014:	e7cc      	b.n	1dfb0 <_dtoa_r+0x680>
   1e016:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1e018:	2a00      	cmp	r2, #0
   1e01a:	f000 80cb 	beq.w	1e1b4 <_dtoa_r+0x884>
   1e01e:	9a08      	ldr	r2, [sp, #32]
   1e020:	2a01      	cmp	r2, #1
   1e022:	f300 80ae 	bgt.w	1e182 <_dtoa_r+0x852>
   1e026:	9a15      	ldr	r2, [sp, #84]	; 0x54
   1e028:	2a00      	cmp	r2, #0
   1e02a:	f000 80a6 	beq.w	1e17a <_dtoa_r+0x84a>
   1e02e:	f203 4333 	addw	r3, r3, #1075	; 0x433
   1e032:	9c09      	ldr	r4, [sp, #36]	; 0x24
   1e034:	9d06      	ldr	r5, [sp, #24]
   1e036:	9a06      	ldr	r2, [sp, #24]
   1e038:	2101      	movs	r1, #1
   1e03a:	4658      	mov	r0, fp
   1e03c:	441a      	add	r2, r3
   1e03e:	9206      	str	r2, [sp, #24]
   1e040:	9a07      	ldr	r2, [sp, #28]
   1e042:	441a      	add	r2, r3
   1e044:	9207      	str	r2, [sp, #28]
   1e046:	f01c fa62 	bl	3a50e <__i2b>
   1e04a:	4606      	mov	r6, r0
   1e04c:	2d00      	cmp	r5, #0
   1e04e:	dd0c      	ble.n	1e06a <_dtoa_r+0x73a>
   1e050:	9b07      	ldr	r3, [sp, #28]
   1e052:	2b00      	cmp	r3, #0
   1e054:	dd09      	ble.n	1e06a <_dtoa_r+0x73a>
   1e056:	42ab      	cmp	r3, r5
   1e058:	9a06      	ldr	r2, [sp, #24]
   1e05a:	bfa8      	it	ge
   1e05c:	462b      	movge	r3, r5
   1e05e:	1ad2      	subs	r2, r2, r3
   1e060:	1aed      	subs	r5, r5, r3
   1e062:	9206      	str	r2, [sp, #24]
   1e064:	9a07      	ldr	r2, [sp, #28]
   1e066:	1ad3      	subs	r3, r2, r3
   1e068:	9307      	str	r3, [sp, #28]
   1e06a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1e06c:	b1f3      	cbz	r3, 1e0ac <_dtoa_r+0x77c>
   1e06e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1e070:	2b00      	cmp	r3, #0
   1e072:	f000 80a3 	beq.w	1e1bc <_dtoa_r+0x88c>
   1e076:	2c00      	cmp	r4, #0
   1e078:	dd10      	ble.n	1e09c <_dtoa_r+0x76c>
   1e07a:	4631      	mov	r1, r6
   1e07c:	4622      	mov	r2, r4
   1e07e:	4658      	mov	r0, fp
   1e080:	f018 fdf2 	bl	36c68 <__pow5mult>
   1e084:	4642      	mov	r2, r8
   1e086:	4601      	mov	r1, r0
   1e088:	4606      	mov	r6, r0
   1e08a:	4658      	mov	r0, fp
   1e08c:	f01c fa48 	bl	3a520 <__multiply>
   1e090:	4607      	mov	r7, r0
   1e092:	4641      	mov	r1, r8
   1e094:	4658      	mov	r0, fp
   1e096:	46b8      	mov	r8, r7
   1e098:	f01c f995 	bl	3a3c6 <_Bfree>
   1e09c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1e09e:	1b1a      	subs	r2, r3, r4
   1e0a0:	d004      	beq.n	1e0ac <_dtoa_r+0x77c>
   1e0a2:	4641      	mov	r1, r8
   1e0a4:	4658      	mov	r0, fp
   1e0a6:	f018 fddf 	bl	36c68 <__pow5mult>
   1e0aa:	4680      	mov	r8, r0
   1e0ac:	2101      	movs	r1, #1
   1e0ae:	4658      	mov	r0, fp
   1e0b0:	f01c fa2d 	bl	3a50e <__i2b>
   1e0b4:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1e0b6:	4604      	mov	r4, r0
   1e0b8:	2b00      	cmp	r3, #0
   1e0ba:	f340 8081 	ble.w	1e1c0 <_dtoa_r+0x890>
   1e0be:	461a      	mov	r2, r3
   1e0c0:	4601      	mov	r1, r0
   1e0c2:	4658      	mov	r0, fp
   1e0c4:	f018 fdd0 	bl	36c68 <__pow5mult>
   1e0c8:	9b08      	ldr	r3, [sp, #32]
   1e0ca:	4604      	mov	r4, r0
   1e0cc:	2b01      	cmp	r3, #1
   1e0ce:	dd7a      	ble.n	1e1c6 <_dtoa_r+0x896>
   1e0d0:	2700      	movs	r7, #0
   1e0d2:	6923      	ldr	r3, [r4, #16]
   1e0d4:	eb04 0383 	add.w	r3, r4, r3, lsl #2
   1e0d8:	6918      	ldr	r0, [r3, #16]
   1e0da:	f01c f9c8 	bl	3a46e <__hi0bits>
   1e0de:	f1c0 0020 	rsb	r0, r0, #32
   1e0e2:	9b07      	ldr	r3, [sp, #28]
   1e0e4:	4418      	add	r0, r3
   1e0e6:	f010 001f 	ands.w	r0, r0, #31
   1e0ea:	f000 808b 	beq.w	1e204 <_dtoa_r+0x8d4>
   1e0ee:	f1c0 0320 	rsb	r3, r0, #32
   1e0f2:	2b04      	cmp	r3, #4
   1e0f4:	f340 8084 	ble.w	1e200 <_dtoa_r+0x8d0>
   1e0f8:	f1c0 001c 	rsb	r0, r0, #28
   1e0fc:	9b06      	ldr	r3, [sp, #24]
   1e0fe:	4405      	add	r5, r0
   1e100:	4403      	add	r3, r0
   1e102:	9306      	str	r3, [sp, #24]
   1e104:	9b07      	ldr	r3, [sp, #28]
   1e106:	4403      	add	r3, r0
   1e108:	9307      	str	r3, [sp, #28]
   1e10a:	9b06      	ldr	r3, [sp, #24]
   1e10c:	2b00      	cmp	r3, #0
   1e10e:	dd05      	ble.n	1e11c <_dtoa_r+0x7ec>
   1e110:	4641      	mov	r1, r8
   1e112:	461a      	mov	r2, r3
   1e114:	4658      	mov	r0, fp
   1e116:	f01c fa92 	bl	3a63e <__lshift>
   1e11a:	4680      	mov	r8, r0
   1e11c:	9b07      	ldr	r3, [sp, #28]
   1e11e:	2b00      	cmp	r3, #0
   1e120:	dd05      	ble.n	1e12e <_dtoa_r+0x7fe>
   1e122:	4621      	mov	r1, r4
   1e124:	461a      	mov	r2, r3
   1e126:	4658      	mov	r0, fp
   1e128:	f01c fa89 	bl	3a63e <__lshift>
   1e12c:	4604      	mov	r4, r0
   1e12e:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1e130:	2b00      	cmp	r3, #0
   1e132:	d069      	beq.n	1e208 <_dtoa_r+0x8d8>
   1e134:	4621      	mov	r1, r4
   1e136:	4640      	mov	r0, r8
   1e138:	f01c fad4 	bl	3a6e4 <__mcmp>
   1e13c:	2800      	cmp	r0, #0
   1e13e:	da63      	bge.n	1e208 <_dtoa_r+0x8d8>
   1e140:	2300      	movs	r3, #0
   1e142:	4641      	mov	r1, r8
   1e144:	220a      	movs	r2, #10
   1e146:	4658      	mov	r0, fp
   1e148:	f01c f954 	bl	3a3f4 <__multadd>
   1e14c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1e14e:	f10a 3aff 	add.w	sl, sl, #4294967295
   1e152:	4680      	mov	r8, r0
   1e154:	2b00      	cmp	r3, #0
   1e156:	f000 8179 	beq.w	1e44c <_dtoa_r+0xb1c>
   1e15a:	2300      	movs	r3, #0
   1e15c:	4631      	mov	r1, r6
   1e15e:	220a      	movs	r2, #10
   1e160:	4658      	mov	r0, fp
   1e162:	f01c f947 	bl	3a3f4 <__multadd>
   1e166:	9b04      	ldr	r3, [sp, #16]
   1e168:	4606      	mov	r6, r0
   1e16a:	2b00      	cmp	r3, #0
   1e16c:	f300 808a 	bgt.w	1e284 <_dtoa_r+0x954>
   1e170:	9b08      	ldr	r3, [sp, #32]
   1e172:	2b02      	cmp	r3, #2
   1e174:	f340 8086 	ble.w	1e284 <_dtoa_r+0x954>
   1e178:	e04e      	b.n	1e218 <_dtoa_r+0x8e8>
   1e17a:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1e17c:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
   1e180:	e757      	b.n	1e032 <_dtoa_r+0x702>
   1e182:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1e184:	f109 34ff 	add.w	r4, r9, #4294967295
   1e188:	42a3      	cmp	r3, r4
   1e18a:	bfb7      	itett	lt
   1e18c:	9b09      	ldrlt	r3, [sp, #36]	; 0x24
   1e18e:	1b1c      	subge	r4, r3, r4
   1e190:	9409      	strlt	r4, [sp, #36]	; 0x24
   1e192:	1ae2      	sublt	r2, r4, r3
   1e194:	bfbf      	itttt	lt
   1e196:	9b10      	ldrlt	r3, [sp, #64]	; 0x40
   1e198:	2400      	movlt	r4, #0
   1e19a:	189b      	addlt	r3, r3, r2
   1e19c:	9310      	strlt	r3, [sp, #64]	; 0x40
   1e19e:	f1b9 0f00 	cmp.w	r9, #0
   1e1a2:	bfb3      	iteet	lt
   1e1a4:	9b06      	ldrlt	r3, [sp, #24]
   1e1a6:	464b      	movge	r3, r9
   1e1a8:	9d06      	ldrge	r5, [sp, #24]
   1e1aa:	eba3 0509 	sublt.w	r5, r3, r9
   1e1ae:	bfb8      	it	lt
   1e1b0:	2300      	movlt	r3, #0
   1e1b2:	e740      	b.n	1e036 <_dtoa_r+0x706>
   1e1b4:	9c09      	ldr	r4, [sp, #36]	; 0x24
   1e1b6:	9d06      	ldr	r5, [sp, #24]
   1e1b8:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   1e1ba:	e747      	b.n	1e04c <_dtoa_r+0x71c>
   1e1bc:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1e1be:	e770      	b.n	1e0a2 <_dtoa_r+0x772>
   1e1c0:	9b08      	ldr	r3, [sp, #32]
   1e1c2:	2b01      	cmp	r3, #1
   1e1c4:	dc18      	bgt.n	1e1f8 <_dtoa_r+0x8c8>
   1e1c6:	9b00      	ldr	r3, [sp, #0]
   1e1c8:	b9b3      	cbnz	r3, 1e1f8 <_dtoa_r+0x8c8>
   1e1ca:	9b01      	ldr	r3, [sp, #4]
   1e1cc:	f3c3 0313 	ubfx	r3, r3, #0, #20
   1e1d0:	b9a3      	cbnz	r3, 1e1fc <_dtoa_r+0x8cc>
   1e1d2:	9b01      	ldr	r3, [sp, #4]
   1e1d4:	f023 4700 	bic.w	r7, r3, #2147483648	; 0x80000000
   1e1d8:	0d3f      	lsrs	r7, r7, #20
   1e1da:	053f      	lsls	r7, r7, #20
   1e1dc:	b137      	cbz	r7, 1e1ec <_dtoa_r+0x8bc>
   1e1de:	9b06      	ldr	r3, [sp, #24]
   1e1e0:	2701      	movs	r7, #1
   1e1e2:	3301      	adds	r3, #1
   1e1e4:	9306      	str	r3, [sp, #24]
   1e1e6:	9b07      	ldr	r3, [sp, #28]
   1e1e8:	3301      	adds	r3, #1
   1e1ea:	9307      	str	r3, [sp, #28]
   1e1ec:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1e1ee:	2b00      	cmp	r3, #0
   1e1f0:	f47f af6f 	bne.w	1e0d2 <_dtoa_r+0x7a2>
   1e1f4:	2001      	movs	r0, #1
   1e1f6:	e774      	b.n	1e0e2 <_dtoa_r+0x7b2>
   1e1f8:	2700      	movs	r7, #0
   1e1fa:	e7f7      	b.n	1e1ec <_dtoa_r+0x8bc>
   1e1fc:	9f00      	ldr	r7, [sp, #0]
   1e1fe:	e7f5      	b.n	1e1ec <_dtoa_r+0x8bc>
   1e200:	d083      	beq.n	1e10a <_dtoa_r+0x7da>
   1e202:	4618      	mov	r0, r3
   1e204:	301c      	adds	r0, #28
   1e206:	e779      	b.n	1e0fc <_dtoa_r+0x7cc>
   1e208:	f1b9 0f00 	cmp.w	r9, #0
   1e20c:	dc34      	bgt.n	1e278 <_dtoa_r+0x948>
   1e20e:	9b08      	ldr	r3, [sp, #32]
   1e210:	2b02      	cmp	r3, #2
   1e212:	dd31      	ble.n	1e278 <_dtoa_r+0x948>
   1e214:	f8cd 9010 	str.w	r9, [sp, #16]
   1e218:	9b04      	ldr	r3, [sp, #16]
   1e21a:	b963      	cbnz	r3, 1e236 <_dtoa_r+0x906>
   1e21c:	4621      	mov	r1, r4
   1e21e:	2205      	movs	r2, #5
   1e220:	4658      	mov	r0, fp
   1e222:	f01c f8e7 	bl	3a3f4 <__multadd>
   1e226:	4601      	mov	r1, r0
   1e228:	4604      	mov	r4, r0
   1e22a:	4640      	mov	r0, r8
   1e22c:	f01c fa5a 	bl	3a6e4 <__mcmp>
   1e230:	2800      	cmp	r0, #0
   1e232:	f73f adc8 	bgt.w	1ddc6 <_dtoa_r+0x496>
   1e236:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1e238:	9d03      	ldr	r5, [sp, #12]
   1e23a:	ea6f 0a03 	mvn.w	sl, r3
   1e23e:	2700      	movs	r7, #0
   1e240:	4621      	mov	r1, r4
   1e242:	4658      	mov	r0, fp
   1e244:	f01c f8bf 	bl	3a3c6 <_Bfree>
   1e248:	2e00      	cmp	r6, #0
   1e24a:	f43f aeb1 	beq.w	1dfb0 <_dtoa_r+0x680>
   1e24e:	b12f      	cbz	r7, 1e25c <_dtoa_r+0x92c>
   1e250:	42b7      	cmp	r7, r6
   1e252:	d003      	beq.n	1e25c <_dtoa_r+0x92c>
   1e254:	4639      	mov	r1, r7
   1e256:	4658      	mov	r0, fp
   1e258:	f01c f8b5 	bl	3a3c6 <_Bfree>
   1e25c:	4631      	mov	r1, r6
   1e25e:	4658      	mov	r0, fp
   1e260:	f01c f8b1 	bl	3a3c6 <_Bfree>
   1e264:	e6a4      	b.n	1dfb0 <_dtoa_r+0x680>
   1e266:	2400      	movs	r4, #0
   1e268:	4626      	mov	r6, r4
   1e26a:	e7e4      	b.n	1e236 <_dtoa_r+0x906>
   1e26c:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
   1e270:	4626      	mov	r6, r4
   1e272:	e5a8      	b.n	1ddc6 <_dtoa_r+0x496>
   1e274:	40240000 	.word	0x40240000
   1e278:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1e27a:	f8cd 9010 	str.w	r9, [sp, #16]
   1e27e:	2b00      	cmp	r3, #0
   1e280:	f000 80eb 	beq.w	1e45a <_dtoa_r+0xb2a>
   1e284:	2d00      	cmp	r5, #0
   1e286:	dd05      	ble.n	1e294 <_dtoa_r+0x964>
   1e288:	4631      	mov	r1, r6
   1e28a:	462a      	mov	r2, r5
   1e28c:	4658      	mov	r0, fp
   1e28e:	f01c f9d6 	bl	3a63e <__lshift>
   1e292:	4606      	mov	r6, r0
   1e294:	2f00      	cmp	r7, #0
   1e296:	d056      	beq.n	1e346 <_dtoa_r+0xa16>
   1e298:	6871      	ldr	r1, [r6, #4]
   1e29a:	4658      	mov	r0, fp
   1e29c:	f01c f85f 	bl	3a35e <_Balloc>
   1e2a0:	6932      	ldr	r2, [r6, #16]
   1e2a2:	4605      	mov	r5, r0
   1e2a4:	f106 010c 	add.w	r1, r6, #12
   1e2a8:	3202      	adds	r2, #2
   1e2aa:	300c      	adds	r0, #12
   1e2ac:	0092      	lsls	r2, r2, #2
   1e2ae:	f01b fd66 	bl	39d7e <memcpy>
   1e2b2:	2201      	movs	r2, #1
   1e2b4:	4629      	mov	r1, r5
   1e2b6:	4658      	mov	r0, fp
   1e2b8:	f01c f9c1 	bl	3a63e <__lshift>
   1e2bc:	9b03      	ldr	r3, [sp, #12]
   1e2be:	4637      	mov	r7, r6
   1e2c0:	4606      	mov	r6, r0
   1e2c2:	f103 0901 	add.w	r9, r3, #1
   1e2c6:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
   1e2ca:	4413      	add	r3, r2
   1e2cc:	9309      	str	r3, [sp, #36]	; 0x24
   1e2ce:	9b00      	ldr	r3, [sp, #0]
   1e2d0:	f003 0301 	and.w	r3, r3, #1
   1e2d4:	9307      	str	r3, [sp, #28]
   1e2d6:	f109 33ff 	add.w	r3, r9, #4294967295
   1e2da:	4621      	mov	r1, r4
   1e2dc:	4640      	mov	r0, r8
   1e2de:	9300      	str	r3, [sp, #0]
   1e2e0:	f01b ff3a 	bl	3a158 <quorem>
   1e2e4:	4603      	mov	r3, r0
   1e2e6:	9004      	str	r0, [sp, #16]
   1e2e8:	4639      	mov	r1, r7
   1e2ea:	4640      	mov	r0, r8
   1e2ec:	3330      	adds	r3, #48	; 0x30
   1e2ee:	930a      	str	r3, [sp, #40]	; 0x28
   1e2f0:	f01c f9f8 	bl	3a6e4 <__mcmp>
   1e2f4:	4632      	mov	r2, r6
   1e2f6:	9006      	str	r0, [sp, #24]
   1e2f8:	4621      	mov	r1, r4
   1e2fa:	4658      	mov	r0, fp
   1e2fc:	f01c fa0c 	bl	3a718 <__mdiff>
   1e300:	68c2      	ldr	r2, [r0, #12]
   1e302:	4605      	mov	r5, r0
   1e304:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1e306:	bb02      	cbnz	r2, 1e34a <_dtoa_r+0xa1a>
   1e308:	4601      	mov	r1, r0
   1e30a:	4640      	mov	r0, r8
   1e30c:	f01c f9ea 	bl	3a6e4 <__mcmp>
   1e310:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1e312:	4602      	mov	r2, r0
   1e314:	4629      	mov	r1, r5
   1e316:	4658      	mov	r0, fp
   1e318:	920c      	str	r2, [sp, #48]	; 0x30
   1e31a:	464d      	mov	r5, r9
   1e31c:	930a      	str	r3, [sp, #40]	; 0x28
   1e31e:	f01c f852 	bl	3a3c6 <_Bfree>
   1e322:	9b08      	ldr	r3, [sp, #32]
   1e324:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1e326:	ea43 0102 	orr.w	r1, r3, r2
   1e32a:	9b07      	ldr	r3, [sp, #28]
   1e32c:	430b      	orrs	r3, r1
   1e32e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1e330:	d10d      	bne.n	1e34e <_dtoa_r+0xa1e>
   1e332:	2b39      	cmp	r3, #57	; 0x39
   1e334:	d027      	beq.n	1e386 <_dtoa_r+0xa56>
   1e336:	9a06      	ldr	r2, [sp, #24]
   1e338:	2a00      	cmp	r2, #0
   1e33a:	dd01      	ble.n	1e340 <_dtoa_r+0xa10>
   1e33c:	9b04      	ldr	r3, [sp, #16]
   1e33e:	3331      	adds	r3, #49	; 0x31
   1e340:	9a00      	ldr	r2, [sp, #0]
   1e342:	7013      	strb	r3, [r2, #0]
   1e344:	e77c      	b.n	1e240 <_dtoa_r+0x910>
   1e346:	4630      	mov	r0, r6
   1e348:	e7b8      	b.n	1e2bc <_dtoa_r+0x98c>
   1e34a:	2201      	movs	r2, #1
   1e34c:	e7e2      	b.n	1e314 <_dtoa_r+0x9e4>
   1e34e:	9906      	ldr	r1, [sp, #24]
   1e350:	2900      	cmp	r1, #0
   1e352:	db04      	blt.n	1e35e <_dtoa_r+0xa2e>
   1e354:	9808      	ldr	r0, [sp, #32]
   1e356:	4301      	orrs	r1, r0
   1e358:	9807      	ldr	r0, [sp, #28]
   1e35a:	4301      	orrs	r1, r0
   1e35c:	d11d      	bne.n	1e39a <_dtoa_r+0xa6a>
   1e35e:	2a00      	cmp	r2, #0
   1e360:	ddee      	ble.n	1e340 <_dtoa_r+0xa10>
   1e362:	4641      	mov	r1, r8
   1e364:	2201      	movs	r2, #1
   1e366:	4658      	mov	r0, fp
   1e368:	9306      	str	r3, [sp, #24]
   1e36a:	f01c f968 	bl	3a63e <__lshift>
   1e36e:	4621      	mov	r1, r4
   1e370:	4680      	mov	r8, r0
   1e372:	f01c f9b7 	bl	3a6e4 <__mcmp>
   1e376:	2800      	cmp	r0, #0
   1e378:	9b06      	ldr	r3, [sp, #24]
   1e37a:	dc02      	bgt.n	1e382 <_dtoa_r+0xa52>
   1e37c:	d1e0      	bne.n	1e340 <_dtoa_r+0xa10>
   1e37e:	07da      	lsls	r2, r3, #31
   1e380:	d5de      	bpl.n	1e340 <_dtoa_r+0xa10>
   1e382:	2b39      	cmp	r3, #57	; 0x39
   1e384:	d1da      	bne.n	1e33c <_dtoa_r+0xa0c>
   1e386:	2339      	movs	r3, #57	; 0x39
   1e388:	9a00      	ldr	r2, [sp, #0]
   1e38a:	7013      	strb	r3, [r2, #0]
   1e38c:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   1e390:	1e6a      	subs	r2, r5, #1
   1e392:	2b39      	cmp	r3, #57	; 0x39
   1e394:	d046      	beq.n	1e424 <_dtoa_r+0xaf4>
   1e396:	3301      	adds	r3, #1
   1e398:	e7d3      	b.n	1e342 <_dtoa_r+0xa12>
   1e39a:	2a00      	cmp	r2, #0
   1e39c:	dd03      	ble.n	1e3a6 <_dtoa_r+0xa76>
   1e39e:	2b39      	cmp	r3, #57	; 0x39
   1e3a0:	d0f1      	beq.n	1e386 <_dtoa_r+0xa56>
   1e3a2:	3301      	adds	r3, #1
   1e3a4:	e7cc      	b.n	1e340 <_dtoa_r+0xa10>
   1e3a6:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1e3a8:	f809 3c01 	strb.w	r3, [r9, #-1]
   1e3ac:	4591      	cmp	r9, r2
   1e3ae:	d021      	beq.n	1e3f4 <_dtoa_r+0xac4>
   1e3b0:	4641      	mov	r1, r8
   1e3b2:	2300      	movs	r3, #0
   1e3b4:	220a      	movs	r2, #10
   1e3b6:	4658      	mov	r0, fp
   1e3b8:	f01c f81c 	bl	3a3f4 <__multadd>
   1e3bc:	42b7      	cmp	r7, r6
   1e3be:	4680      	mov	r8, r0
   1e3c0:	f04f 0300 	mov.w	r3, #0
   1e3c4:	f04f 020a 	mov.w	r2, #10
   1e3c8:	4639      	mov	r1, r7
   1e3ca:	4658      	mov	r0, fp
   1e3cc:	d106      	bne.n	1e3dc <_dtoa_r+0xaac>
   1e3ce:	f01c f811 	bl	3a3f4 <__multadd>
   1e3d2:	4607      	mov	r7, r0
   1e3d4:	4606      	mov	r6, r0
   1e3d6:	f109 0901 	add.w	r9, r9, #1
   1e3da:	e77c      	b.n	1e2d6 <_dtoa_r+0x9a6>
   1e3dc:	f01c f80a 	bl	3a3f4 <__multadd>
   1e3e0:	4631      	mov	r1, r6
   1e3e2:	4607      	mov	r7, r0
   1e3e4:	2300      	movs	r3, #0
   1e3e6:	220a      	movs	r2, #10
   1e3e8:	4658      	mov	r0, fp
   1e3ea:	f01c f803 	bl	3a3f4 <__multadd>
   1e3ee:	4606      	mov	r6, r0
   1e3f0:	e7f1      	b.n	1e3d6 <_dtoa_r+0xaa6>
   1e3f2:	2700      	movs	r7, #0
   1e3f4:	4641      	mov	r1, r8
   1e3f6:	2201      	movs	r2, #1
   1e3f8:	4658      	mov	r0, fp
   1e3fa:	9300      	str	r3, [sp, #0]
   1e3fc:	f01c f91f 	bl	3a63e <__lshift>
   1e400:	4621      	mov	r1, r4
   1e402:	4680      	mov	r8, r0
   1e404:	f01c f96e 	bl	3a6e4 <__mcmp>
   1e408:	2800      	cmp	r0, #0
   1e40a:	dcbf      	bgt.n	1e38c <_dtoa_r+0xa5c>
   1e40c:	d102      	bne.n	1e414 <_dtoa_r+0xae4>
   1e40e:	9b00      	ldr	r3, [sp, #0]
   1e410:	07db      	lsls	r3, r3, #31
   1e412:	d4bb      	bmi.n	1e38c <_dtoa_r+0xa5c>
   1e414:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   1e418:	1e6a      	subs	r2, r5, #1
   1e41a:	2b30      	cmp	r3, #48	; 0x30
   1e41c:	f47f af10 	bne.w	1e240 <_dtoa_r+0x910>
   1e420:	4615      	mov	r5, r2
   1e422:	e7f7      	b.n	1e414 <_dtoa_r+0xae4>
   1e424:	9b03      	ldr	r3, [sp, #12]
   1e426:	4293      	cmp	r3, r2
   1e428:	d104      	bne.n	1e434 <_dtoa_r+0xb04>
   1e42a:	f10a 0a01 	add.w	sl, sl, #1
   1e42e:	2331      	movs	r3, #49	; 0x31
   1e430:	9a03      	ldr	r2, [sp, #12]
   1e432:	e786      	b.n	1e342 <_dtoa_r+0xa12>
   1e434:	4615      	mov	r5, r2
   1e436:	e7a9      	b.n	1e38c <_dtoa_r+0xa5c>
   1e438:	4b13      	ldr	r3, [pc, #76]	; (1e488 <_dtoa_r+0xb58>)
   1e43a:	f7ff bae1 	b.w	1da00 <_dtoa_r+0xd0>
   1e43e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   1e440:	2b00      	cmp	r3, #0
   1e442:	f47f aab9 	bne.w	1d9b8 <_dtoa_r+0x88>
   1e446:	4b11      	ldr	r3, [pc, #68]	; (1e48c <_dtoa_r+0xb5c>)
   1e448:	f7ff bada 	b.w	1da00 <_dtoa_r+0xd0>
   1e44c:	9b04      	ldr	r3, [sp, #16]
   1e44e:	2b00      	cmp	r3, #0
   1e450:	dc03      	bgt.n	1e45a <_dtoa_r+0xb2a>
   1e452:	9b08      	ldr	r3, [sp, #32]
   1e454:	2b02      	cmp	r3, #2
   1e456:	f73f aedf 	bgt.w	1e218 <_dtoa_r+0x8e8>
   1e45a:	9d03      	ldr	r5, [sp, #12]
   1e45c:	4621      	mov	r1, r4
   1e45e:	4640      	mov	r0, r8
   1e460:	f01b fe7a 	bl	3a158 <quorem>
   1e464:	9a03      	ldr	r2, [sp, #12]
   1e466:	f100 0330 	add.w	r3, r0, #48	; 0x30
   1e46a:	9904      	ldr	r1, [sp, #16]
   1e46c:	f805 3b01 	strb.w	r3, [r5], #1
   1e470:	1aaa      	subs	r2, r5, r2
   1e472:	4291      	cmp	r1, r2
   1e474:	ddbd      	ble.n	1e3f2 <_dtoa_r+0xac2>
   1e476:	4641      	mov	r1, r8
   1e478:	2300      	movs	r3, #0
   1e47a:	220a      	movs	r2, #10
   1e47c:	4658      	mov	r0, fp
   1e47e:	f01b ffb9 	bl	3a3f4 <__multadd>
   1e482:	4680      	mov	r8, r0
   1e484:	e7ea      	b.n	1e45c <_dtoa_r+0xb2c>
   1e486:	bf00      	nop
   1e488:	0003f10e 	.word	0x0003f10e
   1e48c:	0003f737 	.word	0x0003f737

0001e490 <clock_timer_handler>:
	}
}

static void clock_timer_handler(struct k_timer *timer)
{
	sys_time_count = true;
   1e490:	2201      	movs	r2, #1
   1e492:	4b01      	ldr	r3, [pc, #4]	; (1e498 <clock_timer_handler+0x8>)
   1e494:	701a      	strb	r2, [r3, #0]
}
   1e496:	4770      	bx	lr
   1e498:	2002229f 	.word	0x2002229f

0001e49c <UpdateSystemTime>:
   	memcpy(&last_date_time, &date_time, sizeof(sys_date_timer_t));
   1e49c:	2208      	movs	r2, #8
{
   1e49e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   	memcpy(&last_date_time, &date_time, sizeof(sys_date_timer_t));
   1e4a0:	4951      	ldr	r1, [pc, #324]	; (1e5e8 <UpdateSystemTime+0x14c>)
   1e4a2:	4852      	ldr	r0, [pc, #328]	; (1e5ec <UpdateSystemTime+0x150>)
   1e4a4:	f01b fc6b 	bl	39d7e <memcpy>
	if(screen_id == SCREEN_ID_IDLE)
   1e4a8:	4b51      	ldr	r3, [pc, #324]	; (1e5f0 <UpdateSystemTime+0x154>)
   1e4aa:	4c52      	ldr	r4, [pc, #328]	; (1e5f4 <UpdateSystemTime+0x158>)
   1e4ac:	781d      	ldrb	r5, [r3, #0]
   1e4ae:	2d01      	cmp	r5, #1
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_TIME;
   1e4b0:	bf01      	itttt	eq
   1e4b2:	4a51      	ldreq	r2, [pc, #324]	; (1e5f8 <UpdateSystemTime+0x15c>)
   1e4b4:	68d3      	ldreq	r3, [r2, #12]
   1e4b6:	f043 0302 	orreq.w	r3, r3, #2
   1e4ba:	60d3      	streq	r3, [r2, #12]
	date_time.second++;
   1e4bc:	4b4a      	ldr	r3, [pc, #296]	; (1e5e8 <UpdateSystemTime+0x14c>)
   1e4be:	799a      	ldrb	r2, [r3, #6]
   1e4c0:	3201      	adds	r2, #1
   1e4c2:	b2d2      	uxtb	r2, r2
	if(date_time.second > 59)
   1e4c4:	2a3b      	cmp	r2, #59	; 0x3b
	date_time.second++;
   1e4c6:	719a      	strb	r2, [r3, #6]
	if(date_time.second > 59)
   1e4c8:	d948      	bls.n	1e55c <UpdateSystemTime+0xc0>
		date_time.second = 0;
   1e4ca:	2600      	movs	r6, #0
		date_time.minute++;
   1e4cc:	795a      	ldrb	r2, [r3, #5]
   1e4ce:	7821      	ldrb	r1, [r4, #0]
   1e4d0:	3201      	adds	r2, #1
   1e4d2:	b2d2      	uxtb	r2, r2
		date_time_changed = date_time_changed|0x02;
   1e4d4:	f041 0002 	orr.w	r0, r1, #2
		if(date_time.minute > 59)
   1e4d8:	2a3b      	cmp	r2, #59	; 0x3b
		date_time.second = 0;
   1e4da:	719e      	strb	r6, [r3, #6]
		date_time.minute++;
   1e4dc:	715a      	strb	r2, [r3, #5]
		date_time_changed = date_time_changed|0x02;
   1e4de:	7020      	strb	r0, [r4, #0]
		if(date_time.minute > 59)
   1e4e0:	d93c      	bls.n	1e55c <UpdateSystemTime+0xc0>
			date_time.hour++;
   1e4e2:	791a      	ldrb	r2, [r3, #4]
			date_time_changed = date_time_changed|0x04;
   1e4e4:	f041 0006 	orr.w	r0, r1, #6
			date_time.hour++;
   1e4e8:	3201      	adds	r2, #1
   1e4ea:	b2d2      	uxtb	r2, r2
			if(date_time.hour > 23)
   1e4ec:	2a17      	cmp	r2, #23
			date_time.minute = 0;
   1e4ee:	715e      	strb	r6, [r3, #5]
			date_time.hour++;
   1e4f0:	711a      	strb	r2, [r3, #4]
			date_time_changed = date_time_changed|0x04;
   1e4f2:	7020      	strb	r0, [r4, #0]
			if(date_time.hour > 23)
   1e4f4:	d932      	bls.n	1e55c <UpdateSystemTime+0xc0>
				date_time.week++;
   1e4f6:	79da      	ldrb	r2, [r3, #7]
				date_time.day++;
   1e4f8:	78d8      	ldrb	r0, [r3, #3]
				date_time.week++;
   1e4fa:	3201      	adds	r2, #1
   1e4fc:	b2d2      	uxtb	r2, r2
				if(date_time.week > 6)
   1e4fe:	2a06      	cmp	r2, #6
				date_time.week++;
   1e500:	bf98      	it	ls
   1e502:	71da      	strbls	r2, [r3, #7]
				date_time_changed = date_time_changed|0x08;
   1e504:	f041 020e 	orr.w	r2, r1, #14
   1e508:	7022      	strb	r2, [r4, #0]
				if(date_time.month == 1 \
   1e50a:	789a      	ldrb	r2, [r3, #2]
				date_time.day++;
   1e50c:	f100 0001 	add.w	r0, r0, #1
   1e510:	b2c0      	uxtb	r0, r0
					date_time.week = 0;
   1e512:	bf88      	it	hi
   1e514:	71de      	strbhi	r6, [r3, #7]
				if(date_time.month == 1 \
   1e516:	2a0c      	cmp	r2, #12
				date_time.hour = 0;
   1e518:	711e      	strb	r6, [r3, #4]
				date_time.day++;
   1e51a:	70d8      	strb	r0, [r3, #3]
				if(date_time.month == 1 \
   1e51c:	d804      	bhi.n	1e528 <UpdateSystemTime+0x8c>
   1e51e:	f241 56aa 	movw	r6, #5546	; 0x15aa
   1e522:	40d6      	lsrs	r6, r2
   1e524:	07f6      	lsls	r6, r6, #31
   1e526:	d429      	bmi.n	1e57c <UpdateSystemTime+0xe0>
				else if(date_time.month == 4 \
   1e528:	f002 06fd 	and.w	r6, r2, #253	; 0xfd
   1e52c:	2e04      	cmp	r6, #4
   1e52e:	d139      	bne.n	1e5a4 <UpdateSystemTime+0x108>
					if(date_time.day > 30)
   1e530:	281e      	cmp	r0, #30
   1e532:	d909      	bls.n	1e548 <UpdateSystemTime+0xac>
						date_time.day = 1;
   1e534:	2001      	movs	r0, #1
						date_time.month++;
   1e536:	4402      	add	r2, r0
   1e538:	b2d2      	uxtb	r2, r2
						date_time_changed = date_time_changed|0x10;
   1e53a:	f041 061e 	orr.w	r6, r1, #30
						if(date_time.month > 12)
   1e53e:	2a0c      	cmp	r2, #12
						date_time.day = 1;
   1e540:	70d8      	strb	r0, [r3, #3]
						date_time.month++;
   1e542:	709a      	strb	r2, [r3, #2]
						date_time_changed = date_time_changed|0x10;
   1e544:	7026      	strb	r6, [r4, #0]
						if(date_time.month > 12)
   1e546:	d825      	bhi.n	1e594 <UpdateSystemTime+0xf8>
				update_date_time = true;
   1e548:	2101      	movs	r1, #1
   1e54a:	4a2c      	ldr	r2, [pc, #176]	; (1e5fc <UpdateSystemTime+0x160>)
				if(screen_id == SCREEN_ID_IDLE)
   1e54c:	428d      	cmp	r5, r1
				update_date_time = true;
   1e54e:	7011      	strb	r1, [r2, #0]
					scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);
   1e550:	bf01      	itttt	eq
   1e552:	4929      	ldreq	r1, [pc, #164]	; (1e5f8 <UpdateSystemTime+0x15c>)
   1e554:	68ca      	ldreq	r2, [r1, #12]
   1e556:	f042 020c 	orreq.w	r2, r2, #12
   1e55a:	60ca      	streq	r2, [r1, #12]
	date_time_changed = date_time_changed|0x01;
   1e55c:	7822      	ldrb	r2, [r4, #0]
	if((date_time_changed&0x02) != 0)
   1e55e:	0791      	lsls	r1, r2, #30
   1e560:	d438      	bmi.n	1e5d4 <UpdateSystemTime+0x138>
	date_time_changed = date_time_changed|0x01;
   1e562:	f042 0201 	orr.w	r2, r2, #1
   1e566:	7022      	strb	r2, [r4, #0]
	if((date_time_changed&0x08) != 0)
   1e568:	7823      	ldrb	r3, [r4, #0]
   1e56a:	071a      	lsls	r2, r3, #28
   1e56c:	d505      	bpl.n	1e57a <UpdateSystemTime+0xde>
		reset_steps = true;
   1e56e:	2201      	movs	r2, #1
		date_time_changed = date_time_changed&0xF7;
   1e570:	f023 0308 	bic.w	r3, r3, #8
   1e574:	7023      	strb	r3, [r4, #0]
		reset_steps = true;
   1e576:	4b22      	ldr	r3, [pc, #136]	; (1e600 <UpdateSystemTime+0x164>)
   1e578:	701a      	strb	r2, [r3, #0]
}
   1e57a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					if(date_time.day > 31)
   1e57c:	281f      	cmp	r0, #31
   1e57e:	d9e3      	bls.n	1e548 <UpdateSystemTime+0xac>
						date_time.day = 1;
   1e580:	2001      	movs	r0, #1
						date_time.month++;
   1e582:	4402      	add	r2, r0
   1e584:	b2d2      	uxtb	r2, r2
						date_time_changed = date_time_changed|0x10;
   1e586:	f041 061e 	orr.w	r6, r1, #30
						if(date_time.month > 12)
   1e58a:	2a0d      	cmp	r2, #13
						date_time.day = 1;
   1e58c:	70d8      	strb	r0, [r3, #3]
						date_time.month++;
   1e58e:	709a      	strb	r2, [r3, #2]
						date_time_changed = date_time_changed|0x10;
   1e590:	7026      	strb	r6, [r4, #0]
						if(date_time.month > 12)
   1e592:	d1d9      	bne.n	1e548 <UpdateSystemTime+0xac>
							date_time.year++;
   1e594:	881a      	ldrh	r2, [r3, #0]
							date_time.month = 1;
   1e596:	7098      	strb	r0, [r3, #2]
							date_time.year++;
   1e598:	4402      	add	r2, r0
   1e59a:	801a      	strh	r2, [r3, #0]
							date_time_changed = date_time_changed|0x20;
   1e59c:	f041 013e 	orr.w	r1, r1, #62	; 0x3e
   1e5a0:	7021      	strb	r1, [r4, #0]
   1e5a2:	e7d1      	b.n	1e548 <UpdateSystemTime+0xac>
					|| date_time.month == 9 \
   1e5a4:	2e09      	cmp	r6, #9
   1e5a6:	d0c3      	beq.n	1e530 <UpdateSystemTime+0x94>
					if(date_time.year%4 == 0)
   1e5a8:	881e      	ldrh	r6, [r3, #0]
					if(date_time.day > (28+Leap))
   1e5aa:	f016 0f03 	tst.w	r6, #3
   1e5ae:	bf0c      	ite	eq
   1e5b0:	271d      	moveq	r7, #29
   1e5b2:	271c      	movne	r7, #28
   1e5b4:	42b8      	cmp	r0, r7
   1e5b6:	ddc7      	ble.n	1e548 <UpdateSystemTime+0xac>
						date_time.day = 1;
   1e5b8:	2001      	movs	r0, #1
						date_time.month++;
   1e5ba:	4402      	add	r2, r0
   1e5bc:	b2d2      	uxtb	r2, r2
						date_time_changed = date_time_changed|0x10;
   1e5be:	f041 071e 	orr.w	r7, r1, #30
						if(date_time.month > 12)
   1e5c2:	2a0c      	cmp	r2, #12
						date_time.day = 1;
   1e5c4:	70d8      	strb	r0, [r3, #3]
						date_time.month++;
   1e5c6:	709a      	strb	r2, [r3, #2]
						date_time_changed = date_time_changed|0x10;
   1e5c8:	7027      	strb	r7, [r4, #0]
						if(date_time.month > 12)
   1e5ca:	d9bd      	bls.n	1e548 <UpdateSystemTime+0xac>
							date_time.year++;
   1e5cc:	4406      	add	r6, r0
							date_time.month = 1;
   1e5ce:	7098      	strb	r0, [r3, #2]
							date_time.year++;
   1e5d0:	801e      	strh	r6, [r3, #0]
   1e5d2:	e7e3      	b.n	1e59c <UpdateSystemTime+0x100>
		date_time_changed = date_time_changed&0xFD;
   1e5d4:	f022 0202 	bic.w	r2, r2, #2
   1e5d8:	f042 0201 	orr.w	r2, r2, #1
		AlarmRemindCheck(date_time);
   1e5dc:	6818      	ldr	r0, [r3, #0]
   1e5de:	6859      	ldr	r1, [r3, #4]
		date_time_changed = date_time_changed&0xFD;
   1e5e0:	7022      	strb	r2, [r4, #0]
		AlarmRemindCheck(date_time);
   1e5e2:	f000 f96b 	bl	1e8bc <AlarmRemindCheck>
   1e5e6:	e7bf      	b.n	1e568 <UpdateSystemTime+0xcc>
   1e5e8:	20022230 	.word	0x20022230
   1e5ec:	20022238 	.word	0x20022238
   1e5f0:	20024cd9 	.word	0x20024cd9
   1e5f4:	2002229e 	.word	0x2002229e
   1e5f8:	200203c0 	.word	0x200203c0
   1e5fc:	200222a0 	.word	0x200222a0
   1e600:	20024c84 	.word	0x20024c84

0001e604 <StartSystemDateTime>:

void StartSystemDateTime(void)
{
   1e604:	b510      	push	{r4, lr}
	k_timer_init(&clock_timer, clock_timer_handler, NULL);
   1e606:	4c07      	ldr	r4, [pc, #28]	; (1e624 <StartSystemDateTime+0x20>)
   1e608:	2200      	movs	r2, #0
   1e60a:	4907      	ldr	r1, [pc, #28]	; (1e628 <StartSystemDateTime+0x24>)
   1e60c:	4620      	mov	r0, r4
   1e60e:	f01b fb0b 	bl	39c28 <k_timer_init>
	z_impl_k_timer_start(timer, duration, period);
   1e612:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1e616:	4620      	mov	r0, r4
	k_timer_start(&clock_timer, K_MSEC(1000), K_MSEC(1000));
}
   1e618:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1e61c:	4611      	mov	r1, r2
   1e61e:	f016 bec1 	b.w	353a4 <z_impl_k_timer_start>
   1e622:	bf00      	nop
   1e624:	200200e8 	.word	0x200200e8
   1e628:	0001e491 	.word	0x0001e491

0001e62c <GetSystemDateStrings>:

void GetSystemDateStrings(u8_t *str_date)
{
	u8_t tmpbuf[128] = {0};
	
	switch(global_settings.date_format)
   1e62c:	4b10      	ldr	r3, [pc, #64]	; (1e670 <GetSystemDateStrings+0x44>)
{
   1e62e:	b507      	push	{r0, r1, r2, lr}
	switch(global_settings.date_format)
   1e630:	7a9b      	ldrb	r3, [r3, #10]
   1e632:	2b01      	cmp	r3, #1
   1e634:	d00e      	beq.n	1e654 <GetSystemDateStrings+0x28>
   1e636:	b123      	cbz	r3, 1e642 <GetSystemDateStrings+0x16>
   1e638:	2b02      	cmp	r3, #2
   1e63a:	d012      	beq.n	1e662 <GetSystemDateStrings+0x36>

#ifdef FONTMAKER_UNICODE_FONT
	strcpy(tmpbuf, str_date);
	mmi_asc_to_ucs2(str_date, tmpbuf);
#endif
}
   1e63c:	b003      	add	sp, #12
   1e63e:	f85d fb04 	ldr.w	pc, [sp], #4
		sprintf((char*)str_date, "%04d/%02d/%02d", date_time.year, date_time.month, date_time.day);
   1e642:	4a0c      	ldr	r2, [pc, #48]	; (1e674 <GetSystemDateStrings+0x48>)
   1e644:	490c      	ldr	r1, [pc, #48]	; (1e678 <GetSystemDateStrings+0x4c>)
   1e646:	78d3      	ldrb	r3, [r2, #3]
   1e648:	9300      	str	r3, [sp, #0]
   1e64a:	7893      	ldrb	r3, [r2, #2]
   1e64c:	8812      	ldrh	r2, [r2, #0]
		sprintf((char*)str_date, "%02d/%02d/%04d", date_time.day, date_time.month, date_time.year);
   1e64e:	f017 ff0d 	bl	3646c <siprintf>
}
   1e652:	e7f3      	b.n	1e63c <GetSystemDateStrings+0x10>
		sprintf((char*)str_date, "%02d/%02d/%04d", date_time.month, date_time.day, date_time.year);
   1e654:	4a07      	ldr	r2, [pc, #28]	; (1e674 <GetSystemDateStrings+0x48>)
   1e656:	8813      	ldrh	r3, [r2, #0]
   1e658:	9300      	str	r3, [sp, #0]
   1e65a:	78d3      	ldrb	r3, [r2, #3]
   1e65c:	7892      	ldrb	r2, [r2, #2]
		sprintf((char*)str_date, "%02d/%02d/%04d", date_time.day, date_time.month, date_time.year);
   1e65e:	4907      	ldr	r1, [pc, #28]	; (1e67c <GetSystemDateStrings+0x50>)
   1e660:	e7f5      	b.n	1e64e <GetSystemDateStrings+0x22>
   1e662:	4a04      	ldr	r2, [pc, #16]	; (1e674 <GetSystemDateStrings+0x48>)
   1e664:	8813      	ldrh	r3, [r2, #0]
   1e666:	9300      	str	r3, [sp, #0]
   1e668:	7893      	ldrb	r3, [r2, #2]
   1e66a:	78d2      	ldrb	r2, [r2, #3]
   1e66c:	e7f7      	b.n	1e65e <GetSystemDateStrings+0x32>
   1e66e:	bf00      	nop
   1e670:	20022242 	.word	0x20022242
   1e674:	20022230 	.word	0x20022230
   1e678:	0003b911 	.word	0x0003b911
   1e67c:	0003b920 	.word	0x0003b920

0001e680 <GetSysteAmPmStrings>:

void GetSysteAmPmStrings(u8_t *str_ampm)
{
	u8_t flag = 0;
	u8_t *am_pm[2] = {"am", "pm"};
   1e680:	4b0d      	ldr	r3, [pc, #52]	; (1e6b8 <GetSysteAmPmStrings+0x38>)
{
   1e682:	b082      	sub	sp, #8
	u8_t *am_pm[2] = {"am", "pm"};
   1e684:	9300      	str	r3, [sp, #0]
   1e686:	4b0d      	ldr	r3, [pc, #52]	; (1e6bc <GetSysteAmPmStrings+0x3c>)
   1e688:	9301      	str	r3, [sp, #4]
	u8_t tmpbuf[128] = {0};

	if(date_time.hour > 12)
		flag = 1;
	
	switch(global_settings.time_format)
   1e68a:	4b0d      	ldr	r3, [pc, #52]	; (1e6c0 <GetSysteAmPmStrings+0x40>)
   1e68c:	7a1b      	ldrb	r3, [r3, #8]
   1e68e:	b11b      	cbz	r3, 1e698 <GetSysteAmPmStrings+0x18>
   1e690:	2b01      	cmp	r3, #1
   1e692:	d005      	beq.n	1e6a0 <GetSysteAmPmStrings+0x20>
#ifdef FONTMAKER_UNICODE_FONT
	strcpy(tmpbuf, str_ampm);
	mmi_asc_to_ucs2(str_ampm, tmpbuf);
#endif

}
   1e694:	b002      	add	sp, #8
   1e696:	4770      	bx	lr
		sprintf((char*)str_ampm, "  ");
   1e698:	490a      	ldr	r1, [pc, #40]	; (1e6c4 <GetSysteAmPmStrings+0x44>)
}
   1e69a:	b002      	add	sp, #8
		sprintf((char*)str_ampm, "%s", am_pm[flag]);
   1e69c:	f01b bcf8 	b.w	3a090 <strcpy>
	if(date_time.hour > 12)
   1e6a0:	4b09      	ldr	r3, [pc, #36]	; (1e6c8 <GetSysteAmPmStrings+0x48>)
		sprintf((char*)str_ampm, "%s", am_pm[flag]);
   1e6a2:	aa02      	add	r2, sp, #8
	if(date_time.hour > 12)
   1e6a4:	791b      	ldrb	r3, [r3, #4]
   1e6a6:	2b0c      	cmp	r3, #12
   1e6a8:	bf94      	ite	ls
   1e6aa:	2300      	movls	r3, #0
   1e6ac:	2301      	movhi	r3, #1
		sprintf((char*)str_ampm, "%s", am_pm[flag]);
   1e6ae:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   1e6b2:	f853 1c08 	ldr.w	r1, [r3, #-8]
   1e6b6:	e7f0      	b.n	1e69a <GetSysteAmPmStrings+0x1a>
   1e6b8:	0003b987 	.word	0x0003b987
   1e6bc:	0003b98a 	.word	0x0003b98a
   1e6c0:	20022242 	.word	0x20022242
   1e6c4:	0003bd2c 	.word	0x0003bd2c
   1e6c8:	20022230 	.word	0x20022230

0001e6cc <GetSystemTimeStrings>:

void GetSystemTimeStrings(u8_t *str_time)
{
	u8_t tmpbuf[128] = {0};
	
	switch(global_settings.time_format)
   1e6cc:	4b0d      	ldr	r3, [pc, #52]	; (1e704 <GetSystemTimeStrings+0x38>)
{
   1e6ce:	b513      	push	{r0, r1, r4, lr}
	switch(global_settings.time_format)
   1e6d0:	7a1b      	ldrb	r3, [r3, #8]
   1e6d2:	b11b      	cbz	r3, 1e6dc <GetSystemTimeStrings+0x10>
   1e6d4:	2b01      	cmp	r3, #1
   1e6d6:	d00a      	beq.n	1e6ee <GetSystemTimeStrings+0x22>

#ifdef FONTMAKER_UNICODE_FONT
	strcpy(tmpbuf, str_time);
	mmi_asc_to_ucs2(str_time, tmpbuf);
#endif
}
   1e6d8:	b002      	add	sp, #8
   1e6da:	bd10      	pop	{r4, pc}
		sprintf((char*)str_time, "%02d:%02d:%02d", date_time.hour, date_time.minute, date_time.second);
   1e6dc:	4a0a      	ldr	r2, [pc, #40]	; (1e708 <GetSystemTimeStrings+0x3c>)
   1e6de:	490b      	ldr	r1, [pc, #44]	; (1e70c <GetSystemTimeStrings+0x40>)
   1e6e0:	7993      	ldrb	r3, [r2, #6]
   1e6e2:	9300      	str	r3, [sp, #0]
   1e6e4:	7953      	ldrb	r3, [r2, #5]
   1e6e6:	7912      	ldrb	r2, [r2, #4]
		sprintf((char*)str_time, "%02d:%02d:%02d", (date_time.hour>12 ? (date_time.hour-12):date_time.hour), date_time.minute, date_time.second);
   1e6e8:	f017 fec0 	bl	3646c <siprintf>
}
   1e6ec:	e7f4      	b.n	1e6d8 <GetSystemTimeStrings+0xc>
		sprintf((char*)str_time, "%02d:%02d:%02d", (date_time.hour>12 ? (date_time.hour-12):date_time.hour), date_time.minute, date_time.second);
   1e6ee:	4b06      	ldr	r3, [pc, #24]	; (1e708 <GetSystemTimeStrings+0x3c>)
   1e6f0:	791a      	ldrb	r2, [r3, #4]
   1e6f2:	7999      	ldrb	r1, [r3, #6]
   1e6f4:	2a0c      	cmp	r2, #12
   1e6f6:	9100      	str	r1, [sp, #0]
   1e6f8:	bf88      	it	hi
   1e6fa:	3a0c      	subhi	r2, #12
   1e6fc:	795b      	ldrb	r3, [r3, #5]
   1e6fe:	4903      	ldr	r1, [pc, #12]	; (1e70c <GetSystemTimeStrings+0x40>)
   1e700:	e7f2      	b.n	1e6e8 <GetSystemTimeStrings+0x1c>
   1e702:	bf00      	nop
   1e704:	20022242 	.word	0x20022242
   1e708:	20022230 	.word	0x20022230
   1e70c:	0003b92f 	.word	0x0003b92f

0001e710 <GetSystemWeekStrings>:

void GetSystemWeekStrings(u8_t *str_week)
{
   1e710:	b570      	push	{r4, r5, r6, lr}
	u8_t *week_en[7] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
   1e712:	4c25      	ldr	r4, [pc, #148]	; (1e7a8 <GetSystemWeekStrings+0x98>)
{
   1e714:	b09e      	sub	sp, #120	; 0x78
	u8_t *week_en[7] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
   1e716:	ad01      	add	r5, sp, #4
{
   1e718:	4606      	mov	r6, r0
	u8_t *week_en[7] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
   1e71a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   1e71c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   1e71e:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
	u8_t *week_chn[7] = {"", "", "", "", "", "", ""};
   1e722:	340c      	adds	r4, #12
	u8_t *week_en[7] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
   1e724:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	u8_t *week_chn[7] = {"", "", "", "", "", "", ""};
   1e728:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   1e72a:	ad08      	add	r5, sp, #32
   1e72c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   1e72e:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
   1e732:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	u8_t *week_jpn[15] = {"", "", "", "", "", "", ""};
   1e736:	2220      	movs	r2, #32
   1e738:	2100      	movs	r1, #0
   1e73a:	a816      	add	r0, sp, #88	; 0x58
   1e73c:	f01b fb3f 	bl	39dbe <memset>
   1e740:	4b1a      	ldr	r3, [pc, #104]	; (1e7ac <GetSystemWeekStrings+0x9c>)
   1e742:	930f      	str	r3, [sp, #60]	; 0x3c
   1e744:	4b1a      	ldr	r3, [pc, #104]	; (1e7b0 <GetSystemWeekStrings+0xa0>)
   1e746:	9310      	str	r3, [sp, #64]	; 0x40
   1e748:	4b1a      	ldr	r3, [pc, #104]	; (1e7b4 <GetSystemWeekStrings+0xa4>)
   1e74a:	9311      	str	r3, [sp, #68]	; 0x44
   1e74c:	4b1a      	ldr	r3, [pc, #104]	; (1e7b8 <GetSystemWeekStrings+0xa8>)
   1e74e:	9312      	str	r3, [sp, #72]	; 0x48
   1e750:	4b1a      	ldr	r3, [pc, #104]	; (1e7bc <GetSystemWeekStrings+0xac>)
   1e752:	9313      	str	r3, [sp, #76]	; 0x4c
   1e754:	4b1a      	ldr	r3, [pc, #104]	; (1e7c0 <GetSystemWeekStrings+0xb0>)
   1e756:	9314      	str	r3, [sp, #80]	; 0x50
   1e758:	4b1a      	ldr	r3, [pc, #104]	; (1e7c4 <GetSystemWeekStrings+0xb4>)
   1e75a:	9315      	str	r3, [sp, #84]	; 0x54
								{0x304D,0x3093,0x3088,0x3046,0x3073,0x0000},
								{0x3069,0x3088,0x3046,0x3073,0x0000}
							};
#endif

	switch(global_settings.language)
   1e75c:	4b1a      	ldr	r3, [pc, #104]	; (1e7c8 <GetSystemWeekStrings+0xb8>)
   1e75e:	7a5b      	ldrb	r3, [r3, #9]
   1e760:	2b01      	cmp	r3, #1
   1e762:	d004      	beq.n	1e76e <GetSystemWeekStrings+0x5e>
   1e764:	b183      	cbz	r3, 1e788 <GetSystemWeekStrings+0x78>
   1e766:	2b02      	cmp	r3, #2
   1e768:	d016      	beq.n	1e798 <GetSystemWeekStrings+0x88>
	#else
		strcpy((char*)str_week, (const char*)week_jpn[date_time.week]);
	#endif
		break;
	}
}
   1e76a:	b01e      	add	sp, #120	; 0x78
   1e76c:	bd70      	pop	{r4, r5, r6, pc}
		strcpy((char*)str_week, (const char*)week_chn[date_time.week]);
   1e76e:	4b17      	ldr	r3, [pc, #92]	; (1e7cc <GetSystemWeekStrings+0xbc>)
   1e770:	aa1e      	add	r2, sp, #120	; 0x78
   1e772:	79db      	ldrb	r3, [r3, #7]
   1e774:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   1e778:	f853 1c58 	ldr.w	r1, [r3, #-88]
		strcpy((char*)str_week, (const char*)week_jpn[date_time.week]);
   1e77c:	4630      	mov	r0, r6
}
   1e77e:	b01e      	add	sp, #120	; 0x78
   1e780:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		strcpy((char*)str_week, (const char*)week_jpn[date_time.week]);
   1e784:	f01b bc84 	b.w	3a090 <strcpy>
		strcpy((char*)str_week, (const char*)week_en[date_time.week]);
   1e788:	4b10      	ldr	r3, [pc, #64]	; (1e7cc <GetSystemWeekStrings+0xbc>)
   1e78a:	aa1e      	add	r2, sp, #120	; 0x78
   1e78c:	79db      	ldrb	r3, [r3, #7]
   1e78e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   1e792:	f853 1c74 	ldr.w	r1, [r3, #-116]
   1e796:	e7f1      	b.n	1e77c <GetSystemWeekStrings+0x6c>
		strcpy((char*)str_week, (const char*)week_jpn[date_time.week]);
   1e798:	4b0c      	ldr	r3, [pc, #48]	; (1e7cc <GetSystemWeekStrings+0xbc>)
   1e79a:	aa1e      	add	r2, sp, #120	; 0x78
   1e79c:	79db      	ldrb	r3, [r3, #7]
   1e79e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   1e7a2:	f853 1c3c 	ldr.w	r1, [r3, #-60]
   1e7a6:	e7e9      	b.n	1e77c <GetSystemWeekStrings+0x6c>
   1e7a8:	0003af20 	.word	0x0003af20
   1e7ac:	0003b93e 	.word	0x0003b93e
   1e7b0:	0003b949 	.word	0x0003b949
   1e7b4:	0003b954 	.word	0x0003b954
   1e7b8:	0003b95d 	.word	0x0003b95d
   1e7bc:	0003b968 	.word	0x0003b968
   1e7c0:	0003b973 	.word	0x0003b973
   1e7c4:	0003b97e 	.word	0x0003b97e
   1e7c8:	20022242 	.word	0x20022242
   1e7cc:	20022230 	.word	0x20022230

0001e7d0 <TimeMsgProcess>:

void TimeMsgProcess(void)
{
   1e7d0:	b508      	push	{r3, lr}
	if(sys_time_count)
   1e7d2:	4b07      	ldr	r3, [pc, #28]	; (1e7f0 <TimeMsgProcess+0x20>)
   1e7d4:	781a      	ldrb	r2, [r3, #0]
   1e7d6:	b152      	cbz	r2, 1e7ee <TimeMsgProcess+0x1e>
	{
		sys_time_count = false;
   1e7d8:	2200      	movs	r2, #0
   1e7da:	701a      	strb	r2, [r3, #0]
		UpdateSystemTime();
   1e7dc:	f7ff fe5e 	bl	1e49c <UpdateSystemTime>

		if(screen_id == SCREEN_ID_IDLE)
   1e7e0:	4b04      	ldr	r3, [pc, #16]	; (1e7f4 <TimeMsgProcess+0x24>)
   1e7e2:	781b      	ldrb	r3, [r3, #0]
   1e7e4:	2b01      	cmp	r3, #1
			scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   1e7e6:	bf02      	ittt	eq
   1e7e8:	2202      	moveq	r2, #2
   1e7ea:	4b03      	ldreq	r3, [pc, #12]	; (1e7f8 <TimeMsgProcess+0x28>)
   1e7ec:	725a      	strbeq	r2, [r3, #9]
	}
}
   1e7ee:	bd08      	pop	{r3, pc}
   1e7f0:	2002229f 	.word	0x2002229f
   1e7f4:	20024cd9 	.word	0x20024cd9
   1e7f8:	200203c0 	.word	0x200203c0

0001e7fc <AlarmRemindStop>:
extern void VibrateStart(void);
extern void VibrateStop(void);

void AlarmRemindStop(void)
{
	vibrate_stop_flag = true;
   1e7fc:	2201      	movs	r2, #1
{
   1e7fe:	b508      	push	{r3, lr}
	vibrate_stop_flag = true;
   1e800:	4b07      	ldr	r3, [pc, #28]	; (1e820 <AlarmRemindStop+0x24>)
   1e802:	701a      	strb	r2, [r3, #0]

	alarm_is_running = false;
   1e804:	2300      	movs	r3, #0
   1e806:	4a07      	ldr	r2, [pc, #28]	; (1e824 <AlarmRemindStop+0x28>)
   1e808:	7013      	strb	r3, [r2, #0]
	vibrating = false;
   1e80a:	4a07      	ldr	r2, [pc, #28]	; (1e828 <AlarmRemindStop+0x2c>)
   1e80c:	7013      	strb	r3, [r2, #0]
	count = 0;
   1e80e:	4a07      	ldr	r2, [pc, #28]	; (1e82c <AlarmRemindStop+0x30>)
   1e810:	7013      	strb	r3, [r2, #0]
	z_impl_k_timer_stop(timer);
   1e812:	4807      	ldr	r0, [pc, #28]	; (1e830 <AlarmRemindStop+0x34>)
   1e814:	f01b fa14 	bl	39c40 <z_impl_k_timer_stop>

	k_timer_stop(&alarm_timer);

	GoBackHistoryScreen();
}
   1e818:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	GoBackHistoryScreen();
   1e81c:	f003 bebe 	b.w	2259c <GoBackHistoryScreen>
   1e820:	20024ce3 	.word	0x20024ce3
   1e824:	200222a1 	.word	0x200222a1
   1e828:	200222a5 	.word	0x200222a5
   1e82c:	200222a3 	.word	0x200222a3
   1e830:	20020114 	.word	0x20020114

0001e834 <AlarmRemindTimeout>:

void AlarmRemindTimeout(struct k_timer *timer)
{
	if(vibrating)
   1e834:	4b0d      	ldr	r3, [pc, #52]	; (1e86c <AlarmRemindTimeout+0x38>)
   1e836:	2101      	movs	r1, #1
   1e838:	781a      	ldrb	r2, [r3, #0]
   1e83a:	b182      	cbz	r2, 1e85e <AlarmRemindTimeout+0x2a>
	{
		vibrate_stop_flag = true;
   1e83c:	4a0c      	ldr	r2, [pc, #48]	; (1e870 <AlarmRemindTimeout+0x3c>)
   1e83e:	7011      	strb	r1, [r2, #0]
		vibrating = false;
   1e840:	2200      	movs	r2, #0

		count--;
   1e842:	490c      	ldr	r1, [pc, #48]	; (1e874 <AlarmRemindTimeout+0x40>)
		vibrating = false;
   1e844:	701a      	strb	r2, [r3, #0]
		count--;
   1e846:	780b      	ldrb	r3, [r1, #0]
   1e848:	3b01      	subs	r3, #1
   1e84a:	b2db      	uxtb	r3, r3
   1e84c:	700b      	strb	r3, [r1, #0]
		if(count>0)
   1e84e:	b123      	cbz	r3, 1e85a <AlarmRemindTimeout+0x26>
	z_impl_k_timer_start(timer, duration, period);
   1e850:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
   1e854:	4808      	ldr	r0, [pc, #32]	; (1e878 <AlarmRemindTimeout+0x44>)
   1e856:	f016 bda5 	b.w	353a4 <z_impl_k_timer_start>
		{
			k_timer_start(&alarm_timer, K_MSEC(ALARM_VIB_OFF_SEC), NULL);
		}
		else
		{
			AlarmRemindStop();
   1e85a:	f7ff bfcf 	b.w	1e7fc <AlarmRemindStop>
		}
	}
	else
	{
		vibrate_start_flag = true;
   1e85e:	4807      	ldr	r0, [pc, #28]	; (1e87c <AlarmRemindTimeout+0x48>)
		vibrating = true;
   1e860:	7019      	strb	r1, [r3, #0]
		vibrate_start_flag = true;
   1e862:	7001      	strb	r1, [r0, #0]
   1e864:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   1e868:	e7f4      	b.n	1e854 <AlarmRemindTimeout+0x20>
   1e86a:	bf00      	nop
   1e86c:	200222a5 	.word	0x200222a5
   1e870:	20024ce3 	.word	0x20024ce3
   1e874:	200222a3 	.word	0x200222a3
   1e878:	20020114 	.word	0x20020114
   1e87c:	20024ce2 	.word	0x20024ce2

0001e880 <AlarmRemindStart>:
	}
}

void AlarmRemindStart(void)
{
	lcd_sleep_out = true;
   1e880:	2301      	movs	r3, #1
	alarm_is_running = true;
	
	count = ALARM_VIB_REPEAT_MAX;
   1e882:	2105      	movs	r1, #5
	lcd_sleep_out = true;
   1e884:	4a07      	ldr	r2, [pc, #28]	; (1e8a4 <AlarmRemindStart+0x24>)
   1e886:	7013      	strb	r3, [r2, #0]
	alarm_is_running = true;
   1e888:	4a07      	ldr	r2, [pc, #28]	; (1e8a8 <AlarmRemindStart+0x28>)
   1e88a:	7013      	strb	r3, [r2, #0]
	count = ALARM_VIB_REPEAT_MAX;
   1e88c:	4a07      	ldr	r2, [pc, #28]	; (1e8ac <AlarmRemindStart+0x2c>)
   1e88e:	7011      	strb	r1, [r2, #0]
	vibrating = true;
   1e890:	4a07      	ldr	r2, [pc, #28]	; (1e8b0 <AlarmRemindStart+0x30>)
   1e892:	7013      	strb	r3, [r2, #0]

	vibrate_start_flag = true;
   1e894:	4a07      	ldr	r2, [pc, #28]	; (1e8b4 <AlarmRemindStart+0x34>)
   1e896:	7013      	strb	r3, [r2, #0]
   1e898:	2200      	movs	r2, #0
   1e89a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   1e89e:	4806      	ldr	r0, [pc, #24]	; (1e8b8 <AlarmRemindStart+0x38>)
   1e8a0:	f016 bd80 	b.w	353a4 <z_impl_k_timer_start>
   1e8a4:	200222a7 	.word	0x200222a7
   1e8a8:	200222a1 	.word	0x200222a1
   1e8ac:	200222a3 	.word	0x200222a3
   1e8b0:	200222a5 	.word	0x200222a5
   1e8b4:	20024ce2 	.word	0x20024ce2
   1e8b8:	20020114 	.word	0x20020114

0001e8bc <AlarmRemindCheck>:

	k_timer_start(&alarm_timer, K_MSEC(ALARM_VIB_ON_SEC), NULL);
}

void AlarmRemindCheck(sys_date_timer_t time)
{
   1e8bc:	b4f3      	push	{r0, r1, r4, r5, r6, r7}
   1e8be:	ab02      	add	r3, sp, #8
   1e8c0:	e903 0003 	stmdb	r3, {r0, r1}
   1e8c4:	4b17      	ldr	r3, [pc, #92]	; (1e924 <AlarmRemindCheck+0x68>)
	{
		if((global_settings.alarm[i].is_on)
			&&(global_settings.alarm[i].hour == time.hour)
			&&(global_settings.alarm[i].minute == time.minute))
		{
			switch(time.week)
   1e8c6:	2200      	movs	r2, #0
   1e8c8:	4618      	mov	r0, r3
			&&(global_settings.alarm[i].hour == time.hour)
   1e8ca:	f89d 4004 	ldrb.w	r4, [sp, #4]
			&&(global_settings.alarm[i].minute == time.minute))
   1e8ce:	f89d 5005 	ldrb.w	r5, [sp, #5]
			switch(time.week)
   1e8d2:	f89d 6007 	ldrb.w	r6, [sp, #7]
		if((global_settings.alarm[i].is_on)
   1e8d6:	7c19      	ldrb	r1, [r3, #16]
   1e8d8:	b1c1      	cbz	r1, 1e90c <AlarmRemindCheck+0x50>
			&&(global_settings.alarm[i].hour == time.hour)
   1e8da:	7c59      	ldrb	r1, [r3, #17]
   1e8dc:	42a1      	cmp	r1, r4
   1e8de:	d115      	bne.n	1e90c <AlarmRemindCheck+0x50>
			&&(global_settings.alarm[i].minute == time.minute))
   1e8e0:	7c99      	ldrb	r1, [r3, #18]
   1e8e2:	42a9      	cmp	r1, r5
   1e8e4:	d112      	bne.n	1e90c <AlarmRemindCheck+0x50>
			switch(time.week)
   1e8e6:	2e06      	cmp	r6, #6
   1e8e8:	7cd9      	ldrb	r1, [r3, #19]
   1e8ea:	d817      	bhi.n	1e91c <AlarmRemindCheck+0x60>
				{
					flag = true;
				}
				break;
			case 6://Saturday
				if(global_settings.alarm[i].repeat&0x02 != 0)
   1e8ec:	f001 0701 	and.w	r7, r1, #1
				break;
			default:
				break;
			}
			
			if(global_settings.alarm[i].repeat == 0)
   1e8f0:	b951      	cbnz	r1, 1e908 <AlarmRemindCheck+0x4c>
			{
				flag = true;
				global_settings.alarm[i].is_on = false;
   1e8f2:	2300      	movs	r3, #0
   1e8f4:	3204      	adds	r2, #4
   1e8f6:	f800 3022 	strb.w	r3, [r0, r2, lsl #2]
				need_save_settings = true;
   1e8fa:	2201      	movs	r2, #1
   1e8fc:	4b0a      	ldr	r3, [pc, #40]	; (1e928 <AlarmRemindCheck+0x6c>)
   1e8fe:	701a      	strb	r2, [r3, #0]
				AlarmRemindEntryScreen();
				break;
			}
		}
	}
}
   1e900:	b002      	add	sp, #8
   1e902:	bcf0      	pop	{r4, r5, r6, r7}
				AlarmRemindEntryScreen();
   1e904:	f018 bd03 	b.w	3730e <AlarmRemindEntryScreen>
			if(flag)
   1e908:	2f00      	cmp	r7, #0
   1e90a:	d1f9      	bne.n	1e900 <AlarmRemindCheck+0x44>
   1e90c:	3201      	adds	r2, #1
	for(i=0;i<ALARM_MAX;i++)
   1e90e:	2a08      	cmp	r2, #8
   1e910:	f103 0304 	add.w	r3, r3, #4
   1e914:	d1df      	bne.n	1e8d6 <AlarmRemindCheck+0x1a>
}
   1e916:	b002      	add	sp, #8
   1e918:	bcf0      	pop	{r4, r5, r6, r7}
   1e91a:	4770      	bx	lr
			if(global_settings.alarm[i].repeat == 0)
   1e91c:	2900      	cmp	r1, #0
   1e91e:	d1f5      	bne.n	1e90c <AlarmRemindCheck+0x50>
   1e920:	e7e7      	b.n	1e8f2 <AlarmRemindCheck+0x36>
   1e922:	bf00      	nop
   1e924:	20022242 	.word	0x20022242
   1e928:	200242ab 	.word	0x200242ab

0001e92c <FindDeviceStop>:
	AlarmRemindStart();
}

void FindDeviceStop(void)
{
	vibrate_stop_flag = true;
   1e92c:	2201      	movs	r2, #1
{
   1e92e:	b508      	push	{r3, lr}
	vibrate_stop_flag = true;
   1e930:	4b07      	ldr	r3, [pc, #28]	; (1e950 <FindDeviceStop+0x24>)
   1e932:	701a      	strb	r2, [r3, #0]

	find_is_running = false;
   1e934:	2300      	movs	r3, #0
   1e936:	4a07      	ldr	r2, [pc, #28]	; (1e954 <FindDeviceStop+0x28>)
   1e938:	7013      	strb	r3, [r2, #0]
	vibrating = false;
   1e93a:	4a07      	ldr	r2, [pc, #28]	; (1e958 <FindDeviceStop+0x2c>)
   1e93c:	7013      	strb	r3, [r2, #0]
	count = 0;
   1e93e:	4a07      	ldr	r2, [pc, #28]	; (1e95c <FindDeviceStop+0x30>)
   1e940:	7013      	strb	r3, [r2, #0]
	z_impl_k_timer_stop(timer);
   1e942:	4807      	ldr	r0, [pc, #28]	; (1e960 <FindDeviceStop+0x34>)
   1e944:	f01b f97c 	bl	39c40 <z_impl_k_timer_stop>

	k_timer_stop(&find_timer);

	GoBackHistoryScreen();
}
   1e948:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	GoBackHistoryScreen();
   1e94c:	f003 be26 	b.w	2259c <GoBackHistoryScreen>
   1e950:	20024ce3 	.word	0x20024ce3
   1e954:	200222a4 	.word	0x200222a4
   1e958:	200222a5 	.word	0x200222a5
   1e95c:	200222a3 	.word	0x200222a3
   1e960:	20020140 	.word	0x20020140

0001e964 <FindDeviceTimeout>:

void FindDeviceTimeout(struct k_timer *timer)
{
	if(vibrating)
   1e964:	4b0d      	ldr	r3, [pc, #52]	; (1e99c <FindDeviceTimeout+0x38>)
   1e966:	2101      	movs	r1, #1
   1e968:	781a      	ldrb	r2, [r3, #0]
   1e96a:	b182      	cbz	r2, 1e98e <FindDeviceTimeout+0x2a>
	{
		vibrate_stop_flag = true;
   1e96c:	4a0c      	ldr	r2, [pc, #48]	; (1e9a0 <FindDeviceTimeout+0x3c>)
   1e96e:	7011      	strb	r1, [r2, #0]
		vibrating = false;
   1e970:	2200      	movs	r2, #0

		count--;
   1e972:	490c      	ldr	r1, [pc, #48]	; (1e9a4 <FindDeviceTimeout+0x40>)
		vibrating = false;
   1e974:	701a      	strb	r2, [r3, #0]
		count--;
   1e976:	780b      	ldrb	r3, [r1, #0]
   1e978:	3b01      	subs	r3, #1
   1e97a:	b2db      	uxtb	r3, r3
   1e97c:	700b      	strb	r3, [r1, #0]
		if(count>0)
   1e97e:	b123      	cbz	r3, 1e98a <FindDeviceTimeout+0x26>
	z_impl_k_timer_start(timer, duration, period);
   1e980:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
   1e984:	4808      	ldr	r0, [pc, #32]	; (1e9a8 <FindDeviceTimeout+0x44>)
   1e986:	f016 bd0d 	b.w	353a4 <z_impl_k_timer_start>
		{
			k_timer_start(&find_timer, K_MSEC(FIND_VIB_OFF_SEC), NULL);
		}
		else
		{
			FindDeviceStop();
   1e98a:	f7ff bfcf 	b.w	1e92c <FindDeviceStop>
		}
	}
	else
	{
		vibrate_start_flag = true;
   1e98e:	4807      	ldr	r0, [pc, #28]	; (1e9ac <FindDeviceTimeout+0x48>)
		vibrating = true;
   1e990:	7019      	strb	r1, [r3, #0]
		vibrate_start_flag = true;
   1e992:	7001      	strb	r1, [r0, #0]
   1e994:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   1e998:	e7f4      	b.n	1e984 <FindDeviceTimeout+0x20>
   1e99a:	bf00      	nop
   1e99c:	200222a5 	.word	0x200222a5
   1e9a0:	20024ce3 	.word	0x20024ce3
   1e9a4:	200222a3 	.word	0x200222a3
   1e9a8:	20020140 	.word	0x20020140
   1e9ac:	20024ce2 	.word	0x20024ce2

0001e9b0 <FindDeviceStart>:
	}
}

void FindDeviceStart(void)
{
	lcd_sleep_out = true;
   1e9b0:	2301      	movs	r3, #1
	find_is_running = true;
	
	count = FIND_VIN_REPEAT_MAX;
   1e9b2:	210a      	movs	r1, #10
	lcd_sleep_out = true;
   1e9b4:	4a07      	ldr	r2, [pc, #28]	; (1e9d4 <FindDeviceStart+0x24>)
   1e9b6:	7013      	strb	r3, [r2, #0]
	find_is_running = true;
   1e9b8:	4a07      	ldr	r2, [pc, #28]	; (1e9d8 <FindDeviceStart+0x28>)
   1e9ba:	7013      	strb	r3, [r2, #0]
	count = FIND_VIN_REPEAT_MAX;
   1e9bc:	4a07      	ldr	r2, [pc, #28]	; (1e9dc <FindDeviceStart+0x2c>)
   1e9be:	7011      	strb	r1, [r2, #0]
	vibrating = true;
   1e9c0:	4a07      	ldr	r2, [pc, #28]	; (1e9e0 <FindDeviceStart+0x30>)
   1e9c2:	7013      	strb	r3, [r2, #0]

	vibrate_start_flag = true;
   1e9c4:	4a07      	ldr	r2, [pc, #28]	; (1e9e4 <FindDeviceStart+0x34>)
   1e9c6:	7013      	strb	r3, [r2, #0]
   1e9c8:	2200      	movs	r2, #0
   1e9ca:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   1e9ce:	4806      	ldr	r0, [pc, #24]	; (1e9e8 <FindDeviceStart+0x38>)
   1e9d0:	f016 bce8 	b.w	353a4 <z_impl_k_timer_start>
   1e9d4:	200222a7 	.word	0x200222a7
   1e9d8:	200222a4 	.word	0x200222a4
   1e9dc:	200222a3 	.word	0x200222a3
   1e9e0:	200222a5 	.word	0x200222a5
   1e9e4:	20024ce2 	.word	0x20024ce2
   1e9e8:	20020140 	.word	0x20020140

0001e9ec <AlarmRemindInit>:
	EnterFindDeviceScreen();
	FindDeviceStart();
}

void AlarmRemindInit(void)
{
   1e9ec:	b508      	push	{r3, lr}
	k_timer_init(&alarm_timer, AlarmRemindTimeout, NULL);
   1e9ee:	2200      	movs	r2, #0
   1e9f0:	4905      	ldr	r1, [pc, #20]	; (1ea08 <AlarmRemindInit+0x1c>)
   1e9f2:	4806      	ldr	r0, [pc, #24]	; (1ea0c <AlarmRemindInit+0x20>)
   1e9f4:	f01b f918 	bl	39c28 <k_timer_init>
	k_timer_init(&find_timer, FindDeviceTimeout, NULL);
}
   1e9f8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	k_timer_init(&find_timer, FindDeviceTimeout, NULL);
   1e9fc:	2200      	movs	r2, #0
   1e9fe:	4904      	ldr	r1, [pc, #16]	; (1ea10 <AlarmRemindInit+0x24>)
   1ea00:	4804      	ldr	r0, [pc, #16]	; (1ea14 <AlarmRemindInit+0x28>)
   1ea02:	f01b b911 	b.w	39c28 <k_timer_init>
   1ea06:	bf00      	nop
   1ea08:	0001e835 	.word	0x0001e835
   1ea0c:	20020114 	.word	0x20020114
   1ea10:	0001e965 	.word	0x0001e965
   1ea14:	20020140 	.word	0x20020140

0001ea18 <AlarmMsgProcess>:

void AlarmMsgProcess(void)
{
	if(app_find_device)
   1ea18:	4b03      	ldr	r3, [pc, #12]	; (1ea28 <AlarmMsgProcess+0x10>)
   1ea1a:	781a      	ldrb	r2, [r3, #0]
   1ea1c:	b11a      	cbz	r2, 1ea26 <AlarmMsgProcess+0xe>
	{
		app_find_device = false;
   1ea1e:	2200      	movs	r2, #0
   1ea20:	701a      	strb	r2, [r3, #0]
		FindDeviceEntryScreen();
   1ea22:	f018 bc7b 	b.w	3731c <FindDeviceEntryScreen>
	}
}
   1ea26:	4770      	bx	lr
   1ea28:	200222a2 	.word	0x200222a2

0001ea2c <LCD_Fill>:

//
//(x,y),(w,h):,:w*h   
//color:
void LCD_Fill(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color)
{          
   1ea2c:	b570      	push	{r4, r5, r6, lr}
   1ea2e:	461d      	mov	r5, r3
   1ea30:	4614      	mov	r4, r2
	u32_t i;

	if((x+w)>LCD_WIDTH)
   1ea32:	4b0e      	ldr	r3, [pc, #56]	; (1ea6c <LCD_Fill+0x40>)
   1ea34:	1882      	adds	r2, r0, r2
   1ea36:	881b      	ldrh	r3, [r3, #0]
{          
   1ea38:	f8bd 6010 	ldrh.w	r6, [sp, #16]
	if((x+w)>LCD_WIDTH)
   1ea3c:	429a      	cmp	r2, r3
		w = LCD_WIDTH - x;
   1ea3e:	bfc8      	it	gt
   1ea40:	1a1c      	subgt	r4, r3, r0
	if((y+h)>LCD_HEIGHT)
   1ea42:	4b0b      	ldr	r3, [pc, #44]	; (1ea70 <LCD_Fill+0x44>)
   1ea44:	eb01 0205 	add.w	r2, r1, r5
   1ea48:	881b      	ldrh	r3, [r3, #0]
		w = LCD_WIDTH - x;
   1ea4a:	bfc8      	it	gt
   1ea4c:	b2a4      	uxthgt	r4, r4
	if((y+h)>LCD_HEIGHT)
   1ea4e:	429a      	cmp	r2, r3
		h = LCD_HEIGHT - y;
   1ea50:	bfc4      	itt	gt
   1ea52:	1a5d      	subgt	r5, r3, r1
   1ea54:	b2ad      	uxthgt	r5, r5
	
	BlockWrite(x,y,w,h);
   1ea56:	462b      	mov	r3, r5
   1ea58:	4622      	mov	r2, r4
   1ea5a:	f018 fc97 	bl	3738c <BlockWrite>

#ifdef LCD_TYPE_SPI
	DispColor((w*h), color);
   1ea5e:	4631      	mov	r1, r6
   1ea60:	fb05 f004 	mul.w	r0, r5, r4
#else
	for(i=0;i<(w*h);i++)
		WriteOneDot(color); // 
#endif
}
   1ea64:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	DispColor((w*h), color);
   1ea68:	f000 ba68 	b.w	1ef3c <DispColor>
   1ea6c:	2002b232 	.word	0x2002b232
   1ea70:	2002b230 	.word	0x2002b230

0001ea74 <LCD_DrawRectangle>:
}    

//	  
//(x1,y1),(x2,y2):
void LCD_DrawRectangle(uint16_t x, uint16_t y, uint16_t w, uint16_t h)
{
   1ea74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1ea78:	4616      	mov	r6, r2
   1ea7a:	461c      	mov	r4, r3
   1ea7c:	4607      	mov	r7, r0
   1ea7e:	4688      	mov	r8, r1
#ifdef LCD_TYPE_SPI
	BlockWrite(x,y,w,1);
	DispColor(w, POINT_COLOR);
   1ea80:	4d14      	ldr	r5, [pc, #80]	; (1ead4 <LCD_DrawRectangle+0x60>)
	BlockWrite(x,y,w,1);
   1ea82:	2301      	movs	r3, #1
   1ea84:	f018 fc82 	bl	3738c <BlockWrite>
	DispColor(w, POINT_COLOR);
   1ea88:	8829      	ldrh	r1, [r5, #0]
   1ea8a:	4630      	mov	r0, r6
   1ea8c:	f000 fa56 	bl	1ef3c <DispColor>
	BlockWrite(x,y,1,h);
   1ea90:	4623      	mov	r3, r4
   1ea92:	2201      	movs	r2, #1
   1ea94:	4641      	mov	r1, r8
   1ea96:	4638      	mov	r0, r7
   1ea98:	f018 fc78 	bl	3738c <BlockWrite>
	DispColor(h, POINT_COLOR);
   1ea9c:	8829      	ldrh	r1, [r5, #0]
   1ea9e:	4620      	mov	r0, r4
   1eaa0:	f000 fa4c 	bl	1ef3c <DispColor>
	BlockWrite(x,y+h,w,1);
   1eaa4:	4632      	mov	r2, r6
   1eaa6:	2301      	movs	r3, #1
   1eaa8:	eb08 0104 	add.w	r1, r8, r4
   1eaac:	4638      	mov	r0, r7
   1eaae:	f018 fc6d 	bl	3738c <BlockWrite>
	DispColor(w, POINT_COLOR);
   1eab2:	8829      	ldrh	r1, [r5, #0]
   1eab4:	4630      	mov	r0, r6
   1eab6:	f000 fa41 	bl	1ef3c <DispColor>
	BlockWrite(x+w,y,1,h);
   1eaba:	4641      	mov	r1, r8
   1eabc:	19b8      	adds	r0, r7, r6
   1eabe:	4623      	mov	r3, r4
   1eac0:	2201      	movs	r2, #1
   1eac2:	f018 fc63 	bl	3738c <BlockWrite>
	DispColor(h, POINT_COLOR);	
   1eac6:	8829      	ldrh	r1, [r5, #0]
   1eac8:	4620      	mov	r0, r4
	LCD_DrawLine(x,y,x+w,y);
	LCD_DrawLine(x,y,x,y+h);
	LCD_DrawLine(x,y+h,x+w,y+h);
	LCD_DrawLine(x+w,y,x+w,y+h);
#endif
}
   1eaca:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	DispColor(h, POINT_COLOR);	
   1eace:	f000 ba35 	b.w	1ef3c <DispColor>
   1ead2:	bf00      	nop
   1ead4:	2002b234 	.word	0x2002b234

0001ead8 <LCD_dis_pic_from_flash>:
//flash
//pic_addr:flash
//x:X
//y:Y
void LCD_dis_pic_from_flash(uint16_t x, uint16_t y, u32_t pic_addr)
{
   1ead8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1eadc:	4617      	mov	r7, r2
   1eade:	4680      	mov	r8, r0
   1eae0:	f5ad 5d80 	sub.w	sp, sp, #4096	; 0x1000
   1eae4:	b081      	sub	sp, #4
   1eae6:	4689      	mov	r9, r1
	uint16_t h,w,show_w,show_h;
	uint16_t i;
	u8_t databuf[LCD_DATA_LEN]={0};
   1eae8:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   1eaec:	2100      	movs	r1, #0
   1eaee:	4668      	mov	r0, sp
   1eaf0:	f01b f965 	bl	39dbe <memset>
	u32_t datelen,showlen=0,readlen=LCD_DATA_LEN;
	
	SpiFlash_Read(databuf, pic_addr, 8);
   1eaf4:	4639      	mov	r1, r7
   1eaf6:	2208      	movs	r2, #8
   1eaf8:	4668      	mov	r0, sp
   1eafa:	f001 f853 	bl	1fba4 <SpiFlash_Read>

	w=256*databuf[2]+databuf[3]; 			//
   1eafe:	f89d 3002 	ldrb.w	r3, [sp, #2]
   1eb02:	f89d 6003 	ldrb.w	r6, [sp, #3]
	h=256*databuf[4]+databuf[5];			//
   1eb06:	f89d 4005 	ldrb.w	r4, [sp, #5]
	w=256*databuf[2]+databuf[3]; 			//
   1eb0a:	eb06 2603 	add.w	r6, r6, r3, lsl #8
	h=256*databuf[4]+databuf[5];			//
   1eb0e:	f89d 3004 	ldrb.w	r3, [sp, #4]
	w=256*databuf[2]+databuf[3]; 			//
   1eb12:	b2b6      	uxth	r6, r6
	h=256*databuf[4]+databuf[5];			//
   1eb14:	eb04 2403 	add.w	r4, r4, r3, lsl #8

	pic_addr += 8;

	if((x+w)>LCD_WIDTH)
   1eb18:	4b23      	ldr	r3, [pc, #140]	; (1eba8 <LCD_dis_pic_from_flash+0xd0>)
	h=256*databuf[4]+databuf[5];			//
   1eb1a:	b2a4      	uxth	r4, r4
	if((x+w)>LCD_WIDTH)
   1eb1c:	881d      	ldrh	r5, [r3, #0]
   1eb1e:	eb08 0306 	add.w	r3, r8, r6
   1eb22:	42ab      	cmp	r3, r5
	w=256*databuf[2]+databuf[3]; 			//
   1eb24:	bfd8      	it	le
   1eb26:	4635      	movle	r5, r6
		show_w = LCD_WIDTH-x;
	else
		show_w = w;
	
	if((y+h)>LCD_HEIGHT)
   1eb28:	4b20      	ldr	r3, [pc, #128]	; (1ebac <LCD_dis_pic_from_flash+0xd4>)
   1eb2a:	eb09 0204 	add.w	r2, r9, r4
   1eb2e:	881b      	ldrh	r3, [r3, #0]
		show_w = LCD_WIDTH-x;
   1eb30:	bfc4      	itt	gt
   1eb32:	eba5 0508 	subgt.w	r5, r5, r8
   1eb36:	b2ad      	uxthgt	r5, r5
	if((y+h)>LCD_HEIGHT)
   1eb38:	429a      	cmp	r2, r3
		show_h = LCD_HEIGHT-y;
   1eb3a:	bfc4      	itt	gt
   1eb3c:	eba3 0409 	subgt.w	r4, r3, r9
   1eb40:	b2a4      	uxthgt	r4, r4
	else
		show_h = h;
	
	BlockWrite(x,y,show_w,show_h);	//
   1eb42:	4623      	mov	r3, r4
   1eb44:	4649      	mov	r1, r9
   1eb46:	462a      	mov	r2, r5
   1eb48:	4640      	mov	r0, r8
   1eb4a:	f018 fc1f 	bl	3738c <BlockWrite>
   1eb4e:	006b      	lsls	r3, r5, #1

	datelen = 2*show_w*show_h;
   1eb50:	435c      	muls	r4, r3
	if(show_w < w)
   1eb52:	42b5      	cmp	r5, r6
   1eb54:	bf28      	it	cs
   1eb56:	f44f 5380 	movcs.w	r3, #4096	; 0x1000
	pic_addr += 8;
   1eb5a:	3708      	adds	r7, #8
		
		memset(databuf, 0, LCD_DATA_LEN);
		SpiFlash_Read(databuf, pic_addr, readlen);
		
		if(show_w < w)
			pic_addr += 2*w;
   1eb5c:	ea4f 0946 	mov.w	r9, r6, lsl #1
	while(datelen)
   1eb60:	b924      	cbnz	r4, 1eb6c <LCD_dis_pic_from_flash+0x94>
	#else
		for(i=0;i<(readlen/2);i++)
			WriteDispData(databuf[2*i],databuf[2*i+1]);	// 
	#endif
	}
}
   1eb62:	f50d 5d80 	add.w	sp, sp, #4096	; 0x1000
   1eb66:	b001      	add	sp, #4
   1eb68:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if(datelen < readlen)
   1eb6c:	429c      	cmp	r4, r3
			datelen -= readlen;
   1eb6e:	bf26      	itte	cs
   1eb70:	eba4 0803 	subcs.w	r8, r4, r3
   1eb74:	461c      	movcs	r4, r3
			datelen = 0;
   1eb76:	f04f 0800 	movcc.w	r8, #0
		memset(databuf, 0, LCD_DATA_LEN);
   1eb7a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   1eb7e:	2100      	movs	r1, #0
   1eb80:	4668      	mov	r0, sp
   1eb82:	f01b f91c 	bl	39dbe <memset>
		SpiFlash_Read(databuf, pic_addr, readlen);
   1eb86:	4639      	mov	r1, r7
   1eb88:	4622      	mov	r2, r4
   1eb8a:	4668      	mov	r0, sp
   1eb8c:	f001 f80a 	bl	1fba4 <SpiFlash_Read>
		if(show_w < w)
   1eb90:	42b5      	cmp	r5, r6
		DispDate(readlen, databuf);
   1eb92:	4620      	mov	r0, r4
   1eb94:	4669      	mov	r1, sp
			pic_addr += readlen;
   1eb96:	bf2c      	ite	cs
   1eb98:	193f      	addcs	r7, r7, r4
			pic_addr += 2*w;
   1eb9a:	444f      	addcc	r7, r9
		DispDate(readlen, databuf);
   1eb9c:	f000 f9f8 	bl	1ef90 <DispDate>
   1eba0:	4623      	mov	r3, r4
   1eba2:	4644      	mov	r4, r8
   1eba4:	e7dc      	b.n	1eb60 <LCD_dis_pic_from_flash+0x88>
   1eba6:	bf00      	nop
   1eba8:	2002b232 	.word	0x2002b232
   1ebac:	2002b230 	.word	0x2002b230

0001ebb0 <LCD_ShowChar>:
//
//x,y:
//num::" "--->"~"
//mode:(1)(0)
void LCD_ShowChar(uint16_t x,uint16_t y,uint8_t num,uint8_t mode)
{
   1ebb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ebb4:	4683      	mov	fp, r0
    u8_t temp,t1,t,i=0;
   1ebb6:	2400      	movs	r4, #0
{
   1ebb8:	f5ad 7d01 	sub.w	sp, sp, #516	; 0x204
   1ebbc:	9306      	str	r3, [sp, #24]
	u16_t y0=y,x0=x;
	u8_t cbyte=(system_font/2)/8+(((system_font/2)%8)?1:0);		//()
   1ebbe:	4b52      	ldr	r3, [pc, #328]	; (1ed08 <LCD_ShowChar+0x158>)
{
   1ebc0:	4690      	mov	r8, r2
	u8_t cbyte=(system_font/2)/8+(((system_font/2)%8)?1:0);		//()
   1ebc2:	781b      	ldrb	r3, [r3, #0]
	u8_t csize=cbyte*system_font;		//	
 	u8_t databuf[2*COL] = {0};
	
	num=num-' ';//ASCII-' '
	for(t=0;t<csize;t++)
   1ebc4:	46da      	mov	sl, fp
	u8_t cbyte=(system_font/2)/8+(((system_font/2)%8)?1:0);		//()
   1ebc6:	f013 070e 	ands.w	r7, r3, #14
   1ebca:	bf18      	it	ne
   1ebcc:	2701      	movne	r7, #1
	for(t=0;t<csize;t++)
   1ebce:	4625      	mov	r5, r4
	u8_t cbyte=(system_font/2)/8+(((system_font/2)%8)?1:0);		//()
   1ebd0:	eb07 1713 	add.w	r7, r7, r3, lsr #4
	u8_t csize=cbyte*system_font;		//	
   1ebd4:	fb13 f307 	smulbb	r3, r3, r7
{
   1ebd8:	460e      	mov	r6, r1
	u8_t csize=cbyte*system_font;		//	
   1ebda:	b2db      	uxtb	r3, r3
 	u8_t databuf[2*COL] = {0};
   1ebdc:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
   1ebe0:	2100      	movs	r1, #0
   1ebe2:	a808      	add	r0, sp, #32
	u8_t csize=cbyte*system_font;		//	
   1ebe4:	9305      	str	r3, [sp, #20]
	num=num-' ';//ASCII-' '
   1ebe6:	f1a8 0820 	sub.w	r8, r8, #32
 	u8_t databuf[2*COL] = {0};
   1ebea:	f01b f8e8 	bl	39dbe <memset>
	{
		switch(system_font)
		{
		#ifdef FONT_16
			case FONT_SIZE_16:
				temp=asc2_1608[num][t]; 	 	//1608
   1ebee:	4b47      	ldr	r3, [pc, #284]	; (1ed0c <LCD_ShowChar+0x15c>)
	num=num-' ';//ASCII-' '
   1ebf0:	fa5f f888 	uxtb.w	r8, r8
				temp=asc2_1608[num][t]; 	 	//1608
   1ebf4:	eb03 1308 	add.w	r3, r3, r8, lsl #4
   1ebf8:	9307      	str	r3, [sp, #28]
	for(t=0;t<csize;t++)
   1ebfa:	9b05      	ldr	r3, [sp, #20]
   1ebfc:	429d      	cmp	r5, r3
   1ebfe:	d205      	bcs.n	1ec0c <LCD_ShowChar+0x5c>
		switch(system_font)
   1ec00:	4b41      	ldr	r3, [pc, #260]	; (1ed08 <LCD_ShowChar+0x158>)
   1ec02:	781a      	ldrb	r2, [r3, #0]
   1ec04:	2a10      	cmp	r2, #16
   1ec06:	d005      	beq.n	1ec14 <LCD_ShowChar+0x64>
   1ec08:	2a18      	cmp	r2, #24
   1ec0a:	d056      	beq.n	1ecba <LCD_ShowChar+0x10a>
				break;
			}
		#endif
		}	
	}  	    	   	 	  
}
   1ec0c:	f50d 7d01 	add.w	sp, sp, #516	; 0x204
   1ec10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				temp=asc2_1608[num][t]; 	 	//1608
   1ec14:	9b07      	ldr	r3, [sp, #28]
				temp=asc2_2412[num][t];			//2412
   1ec16:	f813 9005 	ldrb.w	r9, [r3, r5]
		BlockWrite(x0,y,(system_font/2),1);	  	//
   1ec1a:	2301      	movs	r3, #1
   1ec1c:	4631      	mov	r1, r6
   1ec1e:	40da      	lsrs	r2, r3
   1ec20:	4658      	mov	r0, fp
   1ec22:	f018 fbb3 	bl	3738c <BlockWrite>
				databuf[2*i] = BACK_COLOR>>8;
   1ec26:	4b3a      	ldr	r3, [pc, #232]	; (1ed10 <LCD_ShowChar+0x160>)
   1ec28:	f10a 0a01 	add.w	sl, sl, #1
   1ec2c:	881b      	ldrh	r3, [r3, #0]
   1ec2e:	0a1a      	lsrs	r2, r3, #8
				databuf[2*i+1] = BACK_COLOR;
   1ec30:	b2db      	uxtb	r3, r3
   1ec32:	9304      	str	r3, [sp, #16]
				databuf[2*i] = POINT_COLOR>>8;
   1ec34:	4b37      	ldr	r3, [pc, #220]	; (1ed14 <LCD_ShowChar+0x164>)
				databuf[2*i] = BACK_COLOR>>8;
   1ec36:	9203      	str	r2, [sp, #12]
				databuf[2*i] = POINT_COLOR>>8;
   1ec38:	8819      	ldrh	r1, [r3, #0]
   1ec3a:	fa1f f28a 	uxth.w	r2, sl
   1ec3e:	0a0b      	lsrs	r3, r1, #8
   1ec40:	9301      	str	r3, [sp, #4]
				databuf[2*i+1] = POINT_COLOR;
   1ec42:	b2cb      	uxtb	r3, r1
   1ec44:	9302      	str	r3, [sp, #8]
			if(x>=LCD_WIDTH)				//
   1ec46:	4b34      	ldr	r3, [pc, #208]	; (1ed18 <LCD_ShowChar+0x168>)
   1ec48:	f8b3 e000 	ldrh.w	lr, [r3]
			if((x-x0)==(system_font/2))
   1ec4c:	4b2e      	ldr	r3, [pc, #184]	; (1ed08 <LCD_ShowChar+0x158>)
   1ec4e:	f893 c000 	ldrb.w	ip, [r3]
   1ec52:	f104 0308 	add.w	r3, r4, #8
   1ec56:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
   1ec5a:	b2db      	uxtb	r3, r3
			if(temp&0x80)
   1ec5c:	f019 0f80 	tst.w	r9, #128	; 0x80
   1ec60:	d030      	beq.n	1ecc4 <LCD_ShowChar+0x114>
				databuf[2*i] = POINT_COLOR>>8;
   1ec62:	9901      	ldr	r1, [sp, #4]
   1ec64:	b220      	sxth	r0, r4
   1ec66:	f10d 0a20 	add.w	sl, sp, #32
   1ec6a:	f80a 1010 	strb.w	r1, [sl, r0, lsl #1]
				databuf[2*i+1] = POINT_COLOR;
   1ec6e:	9902      	ldr	r1, [sp, #8]
   1ec70:	eb0a 0040 	add.w	r0, sl, r0, lsl #1
				databuf[2*i+1] = BACK_COLOR;
   1ec74:	7041      	strb	r1, [r0, #1]
			temp<<=1;
   1ec76:	fa1f fa82 	uxth.w	sl, r2
   1ec7a:	ea4f 0949 	mov.w	r9, r9, lsl #1
			i++;
   1ec7e:	3401      	adds	r4, #1
			if(x>=LCD_WIDTH)				//
   1ec80:	45d6      	cmp	lr, sl
			temp<<=1;
   1ec82:	fa5f f989 	uxtb.w	r9, r9
			i++;
   1ec86:	b2e4      	uxtb	r4, r4
			if(x>=LCD_WIDTH)				//
   1ec88:	d829      	bhi.n	1ecde <LCD_ShowChar+0x12e>
				DispDate(2*i, databuf);
   1ec8a:	a908      	add	r1, sp, #32
   1ec8c:	0060      	lsls	r0, r4, #1
   1ec8e:	f000 f97f 	bl	1ef90 <DispDate>
				if(y>=LCD_HEIGHT)return;	//
   1ec92:	4b22      	ldr	r3, [pc, #136]	; (1ed1c <LCD_ShowChar+0x16c>)
				y++;
   1ec94:	3601      	adds	r6, #1
				if(y>=LCD_HEIGHT)return;	//
   1ec96:	881b      	ldrh	r3, [r3, #0]
				y++;
   1ec98:	b2b6      	uxth	r6, r6
				if(y>=LCD_HEIGHT)return;	//
   1ec9a:	42b3      	cmp	r3, r6
   1ec9c:	d9b6      	bls.n	1ec0c <LCD_ShowChar+0x5c>
				t=t+(cbyte-(t%cbyte))-1;	//for11
   1ec9e:	fbb5 f3f7 	udiv	r3, r5, r7
   1eca2:	fb07 5313 	mls	r3, r7, r3, r5
   1eca6:	3d01      	subs	r5, #1
   1eca8:	1afb      	subs	r3, r7, r3
   1ecaa:	441d      	add	r5, r3
   1ecac:	b2ed      	uxtb	r5, r5
				x=x0;
   1ecae:	46da      	mov	sl, fp
				i=0;
   1ecb0:	2300      	movs	r3, #0
	for(t=0;t<csize;t++)
   1ecb2:	3501      	adds	r5, #1
   1ecb4:	b2ed      	uxtb	r5, r5
   1ecb6:	461c      	mov	r4, r3
   1ecb8:	e79f      	b.n	1ebfa <LCD_ShowChar+0x4a>
				temp=asc2_2412[num][t];			//2412
   1ecba:	2330      	movs	r3, #48	; 0x30
   1ecbc:	4918      	ldr	r1, [pc, #96]	; (1ed20 <LCD_ShowChar+0x170>)
   1ecbe:	fb03 1308 	mla	r3, r3, r8, r1
   1ecc2:	e7a8      	b.n	1ec16 <LCD_ShowChar+0x66>
			else if(mode==0)
   1ecc4:	9906      	ldr	r1, [sp, #24]
   1ecc6:	2900      	cmp	r1, #0
   1ecc8:	d1d5      	bne.n	1ec76 <LCD_ShowChar+0xc6>
				databuf[2*i] = BACK_COLOR>>8;
   1ecca:	9903      	ldr	r1, [sp, #12]
   1eccc:	b220      	sxth	r0, r4
   1ecce:	f10d 0a20 	add.w	sl, sp, #32
   1ecd2:	f80a 1010 	strb.w	r1, [sl, r0, lsl #1]
				databuf[2*i+1] = BACK_COLOR;
   1ecd6:	eb0a 0040 	add.w	r0, sl, r0, lsl #1
   1ecda:	9904      	ldr	r1, [sp, #16]
   1ecdc:	e7ca      	b.n	1ec74 <LCD_ShowChar+0xc4>
			if((x-x0)==(system_font/2))
   1ecde:	eba2 000b 	sub.w	r0, r2, fp
   1ece2:	4560      	cmp	r0, ip
   1ece4:	d10b      	bne.n	1ecfe <LCD_ShowChar+0x14e>
				DispDate(2*i, databuf);
   1ece6:	b220      	sxth	r0, r4
   1ece8:	a908      	add	r1, sp, #32
   1ecea:	0040      	lsls	r0, r0, #1
   1ecec:	f000 f950 	bl	1ef90 <DispDate>
				if(y>=LCD_HEIGHT)return;	//
   1ecf0:	4b0a      	ldr	r3, [pc, #40]	; (1ed1c <LCD_ShowChar+0x16c>)
				y++;
   1ecf2:	3601      	adds	r6, #1
				if(y>=LCD_HEIGHT)return;	//
   1ecf4:	881b      	ldrh	r3, [r3, #0]
				y++;
   1ecf6:	b2b6      	uxth	r6, r6
				if(y>=LCD_HEIGHT)return;	//
   1ecf8:	42b3      	cmp	r3, r6
   1ecfa:	d8d8      	bhi.n	1ecae <LCD_ShowChar+0xfe>
   1ecfc:	e786      	b.n	1ec0c <LCD_ShowChar+0x5c>
		for(t1=0;t1<8;t1++)
   1ecfe:	429c      	cmp	r4, r3
   1ed00:	f102 0201 	add.w	r2, r2, #1
   1ed04:	d1aa      	bne.n	1ec5c <LCD_ShowChar+0xac>
   1ed06:	e7d4      	b.n	1ecb2 <LCD_ShowChar+0x102>
   1ed08:	2002ca39 	.word	0x2002ca39
   1ed0c:	2002b238 	.word	0x2002b238
   1ed10:	20022240 	.word	0x20022240
   1ed14:	2002b234 	.word	0x2002b234
   1ed18:	2002b232 	.word	0x2002b232
   1ed1c:	2002b230 	.word	0x2002b230
   1ed20:	2002b838 	.word	0x2002b838

0001ed24 <LCD_ShowStringInRect>:
//
//x,y:
//width,height:  
//*p:	
void LCD_ShowStringInRect(uint16_t x,uint16_t y,uint16_t width,uint16_t height,uint8_t *p)
{
   1ed24:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1ed28:	460e      	mov	r6, r1
	uint8_t x0=x;
	uint16_t phz=0;

	width+=x;
	height+=y;
	while(*p)
   1ed2a:	4604      	mov	r4, r0
	width+=x;
   1ed2c:	4402      	add	r2, r0
	height+=y;
   1ed2e:	440b      	add	r3, r1
{
   1ed30:	9d08      	ldr	r5, [sp, #32]
	{       
		if(x>=width){x=x0;y+=system_font;}
   1ed32:	4f19      	ldr	r7, [pc, #100]	; (1ed98 <LCD_ShowStringInRect+0x74>)
	width+=x;
   1ed34:	fa1f f882 	uxth.w	r8, r2
	height+=y;
   1ed38:	fa1f f983 	uxth.w	r9, r3
	while(*p)
   1ed3c:	fa5f fa80 	uxtb.w	sl, r0
   1ed40:	782a      	ldrb	r2, [r5, #0]
   1ed42:	b90a      	cbnz	r2, 1ed48 <LCD_ShowStringInRect+0x24>
		#endif
			x+=system_font;
			p+=2;
		}        
	}
}
   1ed44:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if(x>=width){x=x0;y+=system_font;}
   1ed48:	4544      	cmp	r4, r8
   1ed4a:	bf21      	itttt	cs
   1ed4c:	783b      	ldrbcs	r3, [r7, #0]
   1ed4e:	4654      	movcs	r4, sl
   1ed50:	18f6      	addcs	r6, r6, r3
   1ed52:	b2b6      	uxthcs	r6, r6
		if(*p=='\n'){x=x0;y+=system_font;p++;}
   1ed54:	2a0a      	cmp	r2, #10
   1ed56:	d104      	bne.n	1ed62 <LCD_ShowStringInRect+0x3e>
   1ed58:	4654      	mov	r4, sl
   1ed5a:	783b      	ldrb	r3, [r7, #0]
   1ed5c:	3501      	adds	r5, #1
   1ed5e:	441e      	add	r6, r3
   1ed60:	b2b6      	uxth	r6, r6
		if(y>=height)break;//
   1ed62:	454e      	cmp	r6, r9
   1ed64:	d2ee      	bcs.n	1ed44 <LCD_ShowStringInRect+0x20>
		if(*p==0x00)break;//
   1ed66:	782a      	ldrb	r2, [r5, #0]
   1ed68:	2a00      	cmp	r2, #0
   1ed6a:	d0eb      	beq.n	1ed44 <LCD_ShowStringInRect+0x20>
		if(*p<0x80)
   1ed6c:	0613      	lsls	r3, r2, #24
   1ed6e:	d40a      	bmi.n	1ed86 <LCD_ShowStringInRect+0x62>
			LCD_ShowChar(x,y,*p,0);
   1ed70:	4620      	mov	r0, r4
   1ed72:	2300      	movs	r3, #0
   1ed74:	4631      	mov	r1, r6
   1ed76:	f7ff ff1b 	bl	1ebb0 <LCD_ShowChar>
			x+=system_font/2;
   1ed7a:	7838      	ldrb	r0, [r7, #0]
			p++;
   1ed7c:	3501      	adds	r5, #1
			x+=system_font/2;
   1ed7e:	eb04 0450 	add.w	r4, r4, r0, lsr #1
   1ed82:	b2a4      	uxth	r4, r4
			p++;
   1ed84:	e7dc      	b.n	1ed40 <LCD_ShowStringInRect+0x1c>
		else if(*(p+1))
   1ed86:	786b      	ldrb	r3, [r5, #1]
   1ed88:	2b00      	cmp	r3, #0
   1ed8a:	d0d9      	beq.n	1ed40 <LCD_ShowStringInRect+0x1c>
			x+=system_font;
   1ed8c:	7838      	ldrb	r0, [r7, #0]
			p+=2;
   1ed8e:	3502      	adds	r5, #2
			x+=system_font;
   1ed90:	4404      	add	r4, r0
   1ed92:	b2a4      	uxth	r4, r4
			p+=2;
   1ed94:	e7d4      	b.n	1ed40 <LCD_ShowStringInRect+0x1c>
   1ed96:	bf00      	nop
   1ed98:	2002ca39 	.word	0x2002ca39

0001ed9c <LCD_ShowString>:

//
//x,y:
//*p:	
void LCD_ShowString(uint16_t x,uint16_t y,uint8_t *p)
{
   1ed9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1eda0:	4605      	mov	r5, r0
   1eda2:	460e      	mov	r6, r1
   1eda4:	4614      	mov	r4, r2
	uint8_t width;
	uint16_t phz=0;

	while(*p)
	{       
		if(x>=LCD_WIDTH)break;//
   1eda6:	f8df 8050 	ldr.w	r8, [pc, #80]	; 1edf8 <LCD_ShowString+0x5c>
		if(y>=LCD_HEIGHT)break;//
   1edaa:	f8df 9050 	ldr.w	r9, [pc, #80]	; 1edfc <LCD_ShowString+0x60>
			LCD_ShowChineseChar_from_flash(x,y,phz,0);
		  #endif
		#else
			LCD_ShowChineseChar(x,y,phz,0);
		#endif
			x+=system_font;
   1edae:	4f11      	ldr	r7, [pc, #68]	; (1edf4 <LCD_ShowString+0x58>)
	while(*p)
   1edb0:	7822      	ldrb	r2, [r4, #0]
   1edb2:	b90a      	cbnz	r2, 1edb8 <LCD_ShowString+0x1c>
			p+=2;
		}        
	}
}
   1edb4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if(x>=LCD_WIDTH)break;//
   1edb8:	f8b8 3000 	ldrh.w	r3, [r8]
   1edbc:	42ab      	cmp	r3, r5
   1edbe:	d9f9      	bls.n	1edb4 <LCD_ShowString+0x18>
		if(y>=LCD_HEIGHT)break;//
   1edc0:	f8b9 3000 	ldrh.w	r3, [r9]
   1edc4:	42b3      	cmp	r3, r6
   1edc6:	d9f5      	bls.n	1edb4 <LCD_ShowString+0x18>
		if(*p<0x80)
   1edc8:	0613      	lsls	r3, r2, #24
   1edca:	d40a      	bmi.n	1ede2 <LCD_ShowString+0x46>
			LCD_ShowChar(x,y,*p,0);
   1edcc:	2300      	movs	r3, #0
   1edce:	4628      	mov	r0, r5
   1edd0:	4631      	mov	r1, r6
   1edd2:	f7ff feed 	bl	1ebb0 <LCD_ShowChar>
		  	x += system_font/2;
   1edd6:	783b      	ldrb	r3, [r7, #0]
			p++;
   1edd8:	3401      	adds	r4, #1
		  	x += system_font/2;
   1edda:	eb05 0553 	add.w	r5, r5, r3, lsr #1
   1edde:	b2ad      	uxth	r5, r5
			p++;
   1ede0:	e7e6      	b.n	1edb0 <LCD_ShowString+0x14>
		else if(*(p+1))
   1ede2:	7863      	ldrb	r3, [r4, #1]
   1ede4:	2b00      	cmp	r3, #0
   1ede6:	d0e3      	beq.n	1edb0 <LCD_ShowString+0x14>
			x+=system_font;
   1ede8:	783b      	ldrb	r3, [r7, #0]
			p+=2;
   1edea:	3402      	adds	r4, #2
			x+=system_font;
   1edec:	441d      	add	r5, r3
   1edee:	b2ad      	uxth	r5, r5
			p+=2;
   1edf0:	e7de      	b.n	1edb0 <LCD_ShowString+0x14>
   1edf2:	bf00      	nop
   1edf4:	2002ca39 	.word	0x2002ca39
   1edf8:	2002b232 	.word	0x2002b232
   1edfc:	2002b230 	.word	0x2002b230

0001ee00 <LCD_MeasureString>:
//width,height:
void LCD_MeasureString(uint8_t *p, uint16_t *width,uint16_t *height)
{
	uint8_t font_size;

	*width = 0;
   1ee00:	2300      	movs	r3, #0
{
   1ee02:	b570      	push	{r4, r5, r6, lr}
	*width = 0;
   1ee04:	800b      	strh	r3, [r1, #0]
{
   1ee06:	460d      	mov	r5, r1
   1ee08:	4616      	mov	r6, r2
	*height = 0;
   1ee0a:	8013      	strh	r3, [r2, #0]

	if(p == NULL || strlen((const char *)p) == 0)
   1ee0c:	4604      	mov	r4, r0
   1ee0e:	b148      	cbz	r0, 1ee24 <LCD_MeasureString+0x24>
   1ee10:	f7fe f9a2 	bl	1d158 <strlen>
   1ee14:	b130      	cbz	r0, 1ee24 <LCD_MeasureString+0x24>
		return;

	(*height) = system_font;
   1ee16:	4b0b      	ldr	r3, [pc, #44]	; (1ee44 <LCD_MeasureString+0x44>)
   1ee18:	781b      	ldrb	r3, [r3, #0]
   1ee1a:	b299      	uxth	r1, r3
   1ee1c:	8031      	strh	r1, [r6, #0]
		if(*p<0x80)
		{
		#ifdef FONTMAKER_MBCS_FONT
			(*width) += LCD_Measure_Mbcs_Byte(*p);
		#else
			(*width) += system_font/2;
   1ee1e:	085b      	lsrs	r3, r3, #1
	while(*p)
   1ee20:	7822      	ldrb	r2, [r4, #0]
   1ee22:	b902      	cbnz	r2, 1ee26 <LCD_MeasureString+0x26>
		{
			(*width) += system_font;
			p += 2;
		}        
	}  
}
   1ee24:	bd70      	pop	{r4, r5, r6, pc}
		if(*p<0x80)
   1ee26:	0612      	lsls	r2, r2, #24
   1ee28:	d404      	bmi.n	1ee34 <LCD_MeasureString+0x34>
			(*width) += system_font/2;
   1ee2a:	882a      	ldrh	r2, [r5, #0]
			p++;
   1ee2c:	3401      	adds	r4, #1
			(*width) += system_font/2;
   1ee2e:	441a      	add	r2, r3
   1ee30:	802a      	strh	r2, [r5, #0]
			p++;
   1ee32:	e7f5      	b.n	1ee20 <LCD_MeasureString+0x20>
		else if(*(p+1))
   1ee34:	7862      	ldrb	r2, [r4, #1]
   1ee36:	2a00      	cmp	r2, #0
   1ee38:	d0f2      	beq.n	1ee20 <LCD_MeasureString+0x20>
			(*width) += system_font;
   1ee3a:	882a      	ldrh	r2, [r5, #0]
			p += 2;
   1ee3c:	3402      	adds	r4, #2
			(*width) += system_font;
   1ee3e:	440a      	add	r2, r1
   1ee40:	802a      	strh	r2, [r5, #0]
			p += 2;
   1ee42:	e7ed      	b.n	1ee20 <LCD_MeasureString+0x20>
   1ee44:	2002ca39 	.word	0x2002ca39

0001ee48 <LCD_SetFontSize>:

//
//font_size:
void LCD_SetFontSize(uint8_t font_size)
{
	if(font_size > FONT_SIZE_MIN && font_size < FONT_SIZE_MAX)
   1ee48:	1e43      	subs	r3, r0, #1
   1ee4a:	2b17      	cmp	r3, #23
		system_font = font_size;
   1ee4c:	bf9c      	itt	ls
   1ee4e:	4b01      	ldrls	r3, [pc, #4]	; (1ee54 <LCD_SetFontSize+0xc>)
   1ee50:	7018      	strbls	r0, [r3, #0]
}
   1ee52:	4770      	bx	lr
   1ee54:	2002ca39 	.word	0x2002ca39

0001ee58 <LCDMsgProcess>:

void LCDMsgProcess(void)
{
   1ee58:	b508      	push	{r3, lr}
	if(lcd_sleep_in)
   1ee5a:	4b08      	ldr	r3, [pc, #32]	; (1ee7c <LCDMsgProcess+0x24>)
   1ee5c:	781a      	ldrb	r2, [r3, #0]
   1ee5e:	b11a      	cbz	r2, 1ee68 <LCDMsgProcess+0x10>
	{
		lcd_sleep_in = false;
   1ee60:	2200      	movs	r2, #0
   1ee62:	701a      	strb	r2, [r3, #0]
		LCD_SleepIn();
   1ee64:	f000 f8ba 	bl	1efdc <LCD_SleepIn>
	}

	if(lcd_sleep_out)
   1ee68:	4b05      	ldr	r3, [pc, #20]	; (1ee80 <LCDMsgProcess+0x28>)
   1ee6a:	781a      	ldrb	r2, [r3, #0]
   1ee6c:	b12a      	cbz	r2, 1ee7a <LCDMsgProcess+0x22>
	{
		lcd_sleep_out = false;
   1ee6e:	2200      	movs	r2, #0
   1ee70:	701a      	strb	r2, [r3, #0]
		LCD_SleepOut();
	}
}
   1ee72:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		LCD_SleepOut();
   1ee76:	f000 b8c5 	b.w	1f004 <LCD_SleepOut>
}
   1ee7a:	bd08      	pop	{r3, pc}
   1ee7c:	200222a6 	.word	0x200222a6
   1ee80:	200222a7 	.word	0x200222a7

0001ee84 <backlight_timer_handler>:
	k_sleep(K_MSEC(dly));
}

static void backlight_timer_handler(struct k_timer *timer)
{
	lcd_sleep_in = true;
   1ee84:	2201      	movs	r2, #1
   1ee86:	4b01      	ldr	r3, [pc, #4]	; (1ee8c <backlight_timer_handler+0x8>)
   1ee88:	701a      	strb	r2, [r3, #0]
}
   1ee8a:	4770      	bx	lr
   1ee8c:	200222a6 	.word	0x200222a6

0001ee90 <LCD_SPI_Transceive.constprop.0>:
	tx_buff.buf = txbuf;
   1ee90:	4b0e      	ldr	r3, [pc, #56]	; (1eecc <LCD_SPI_Transceive.constprop.0+0x3c>)
   1ee92:	4a0f      	ldr	r2, [pc, #60]	; (1eed0 <LCD_SPI_Transceive.constprop.0+0x40>)
static void LCD_SPI_Transceive(u8_t *txbuf, u32_t txbuflen, u8_t *rxbuf, u32_t rxbuflen)
   1ee94:	b510      	push	{r4, lr}
	tx_buff.len = txbuflen;
   1ee96:	e9c3 2000 	strd	r2, r0, [r3]
	tx_bufs.buffers = &tx_buff;
   1ee9a:	4a0e      	ldr	r2, [pc, #56]	; (1eed4 <LCD_SPI_Transceive.constprop.0+0x44>)
	tx_bufs.count = 1;
   1ee9c:	2001      	movs	r0, #1
	tx_bufs.buffers = &tx_buff;
   1ee9e:	6013      	str	r3, [r2, #0]
	rx_buff.buf = rxbuf;
   1eea0:	2300      	movs	r3, #0
   1eea2:	490d      	ldr	r1, [pc, #52]	; (1eed8 <LCD_SPI_Transceive.constprop.0+0x48>)
	tx_bufs.count = 1;
   1eea4:	6050      	str	r0, [r2, #4]
	rx_buff.len = rxbuflen;
   1eea6:	e9c1 3300 	strd	r3, r3, [r1]
	rx_bufs.buffers = &rx_buff;
   1eeaa:	4b0c      	ldr	r3, [pc, #48]	; (1eedc <LCD_SPI_Transceive.constprop.0+0x4c>)
	rx_bufs.count = 1;
   1eeac:	e9c3 1000 	strd	r1, r0, [r3]
	err = spi_transceive(spi_lcd, &spi_cfg, &tx_bufs, &rx_bufs);
   1eeb0:	490b      	ldr	r1, [pc, #44]	; (1eee0 <LCD_SPI_Transceive.constprop.0+0x50>)
   1eeb2:	6808      	ldr	r0, [r1, #0]
				       const struct spi_buf_set *rx_bufs)
{
	const struct spi_driver_api *api =
		(const struct spi_driver_api *)dev->driver_api;

	return api->transceive(dev, config, tx_bufs, rx_bufs);
   1eeb4:	6841      	ldr	r1, [r0, #4]
   1eeb6:	680c      	ldr	r4, [r1, #0]
   1eeb8:	490a      	ldr	r1, [pc, #40]	; (1eee4 <LCD_SPI_Transceive.constprop.0+0x54>)
   1eeba:	47a0      	blx	r4
	if(err)
   1eebc:	4601      	mov	r1, r0
   1eebe:	b120      	cbz	r0, 1eeca <LCD_SPI_Transceive.constprop.0+0x3a>
}
   1eec0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		printk("SPI error: %d\n", err);
   1eec4:	4808      	ldr	r0, [pc, #32]	; (1eee8 <LCD_SPI_Transceive.constprop.0+0x58>)
   1eec6:	f018 befb 	b.w	37cc0 <printk>
}
   1eeca:	bd10      	pop	{r4, pc}
   1eecc:	200201c8 	.word	0x200201c8
   1eed0:	200222a9 	.word	0x200222a9
   1eed4:	200201d0 	.word	0x200201d0
   1eed8:	2002019c 	.word	0x2002019c
   1eedc:	200201a4 	.word	0x200201a4
   1eee0:	200201c4 	.word	0x200201c4
   1eee4:	200201ac 	.word	0x200201ac
   1eee8:	0003ba62 	.word	0x0003ba62

0001eeec <Write_Data>:

//
//i:8
void Write_Data(uint8_t i) 
{	
	lcd_data_buffer[0] = i;
   1eeec:	4b02      	ldr	r3, [pc, #8]	; (1eef8 <Write_Data+0xc>)
   1eeee:	7018      	strb	r0, [r3, #0]
	
	LCD_SPI_Transceive(lcd_data_buffer, 1, NULL, 0);
   1eef0:	2001      	movs	r0, #1
   1eef2:	f7ff bfcd 	b.w	1ee90 <LCD_SPI_Transceive.constprop.0>
   1eef6:	bf00      	nop
   1eef8:	200222a9 	.word	0x200222a9

0001eefc <WriteComm>:

//----------------------------------------------------------------------
//
//i:
void WriteComm(u8_t i)
{
   1eefc:	b510      	push	{r4, lr}
   1eefe:	4604      	mov	r4, r0
	gpio_pin_write(gpio_lcd, RS, 0);
   1ef00:	4b05      	ldr	r3, [pc, #20]	; (1ef18 <WriteComm+0x1c>)
   1ef02:	2200      	movs	r2, #0
   1ef04:	2115      	movs	r1, #21
   1ef06:	6818      	ldr	r0, [r3, #0]
   1ef08:	f018 fa2c 	bl	37364 <gpio_pin_write>
	Write_Data(i);
   1ef0c:	4620      	mov	r0, r4
}
   1ef0e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	Write_Data(i);
   1ef12:	f7ff bfeb 	b.w	1eeec <Write_Data>
   1ef16:	bf00      	nop
   1ef18:	20020198 	.word	0x20020198

0001ef1c <WriteData>:

//LCD
//i:
void WriteData(u8_t i)
{
   1ef1c:	b510      	push	{r4, lr}
   1ef1e:	4604      	mov	r4, r0
	gpio_pin_write(gpio_lcd, RS, 1);
   1ef20:	4b05      	ldr	r3, [pc, #20]	; (1ef38 <WriteData+0x1c>)
   1ef22:	2201      	movs	r2, #1
   1ef24:	2115      	movs	r1, #21
   1ef26:	6818      	ldr	r0, [r3, #0]
   1ef28:	f018 fa1c 	bl	37364 <gpio_pin_write>
	Write_Data(i);  
   1ef2c:	4620      	mov	r0, r4
}
   1ef2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	Write_Data(i);  
   1ef32:	f7ff bfdb 	b.w	1eeec <Write_Data>
   1ef36:	bf00      	nop
   1ef38:	20020198 	.word	0x20020198

0001ef3c <DispColor>:

	WriteComm(0x2c);
}

void DispColor(u32_t total, u16_t color)
{
   1ef3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t i,remain;      

	gpio_pin_write(gpio_lcd, RS, 1);
   1ef3e:	4b12      	ldr	r3, [pc, #72]	; (1ef88 <DispColor+0x4c>)
{
   1ef40:	460e      	mov	r6, r1
   1ef42:	4605      	mov	r5, r0
	gpio_pin_write(gpio_lcd, RS, 1);
   1ef44:	2201      	movs	r2, #1
   1ef46:	2115      	movs	r1, #21
   1ef48:	6818      	ldr	r0, [r3, #0]
   1ef4a:	f018 fa0b 	bl	37364 <gpio_pin_write>
		else
			remain = LCD_DATA_LEN;
		
		for(i=0;i<remain;i++)
		{
			lcd_data_buffer[2*i] = color>>8;
   1ef4e:	0a37      	lsrs	r7, r6, #8
		if(total <= LCD_DATA_LEN)
   1ef50:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
   1ef54:	462a      	mov	r2, r5
		for(i=0;i<remain;i++)
   1ef56:	f04f 0400 	mov.w	r4, #0
   1ef5a:	bf28      	it	cs
   1ef5c:	f44f 5280 	movcs.w	r2, #4096	; 0x1000
   1ef60:	4b0a      	ldr	r3, [pc, #40]	; (1ef8c <DispColor+0x50>)
   1ef62:	4294      	cmp	r4, r2
   1ef64:	f103 0302 	add.w	r3, r3, #2
   1ef68:	d107      	bne.n	1ef7a <DispColor+0x3e>
			lcd_data_buffer[2*i+1] = color;
		}
		
		LCD_SPI_Transceive(lcd_data_buffer, 2*remain, NULL, 0);
   1ef6a:	0060      	lsls	r0, r4, #1
   1ef6c:	f7ff ff90 	bl	1ee90 <LCD_SPI_Transceive.constprop.0>

		if(remain == total)
   1ef70:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
   1ef74:	d907      	bls.n	1ef86 <DispColor+0x4a>
			break;

		total -= remain;
   1ef76:	1b2d      	subs	r5, r5, r4
		if(total <= LCD_DATA_LEN)
   1ef78:	e7ea      	b.n	1ef50 <DispColor+0x14>
			lcd_data_buffer[2*i] = color>>8;
   1ef7a:	f803 7c02 	strb.w	r7, [r3, #-2]
			lcd_data_buffer[2*i+1] = color;
   1ef7e:	f803 6c01 	strb.w	r6, [r3, #-1]
		for(i=0;i<remain;i++)
   1ef82:	3401      	adds	r4, #1
   1ef84:	e7ed      	b.n	1ef62 <DispColor+0x26>
	}
}
   1ef86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1ef88:	20020198 	.word	0x20020198
   1ef8c:	200222a9 	.word	0x200222a9

0001ef90 <DispDate>:

void DispDate(u32_t total, u8_t *data)
{
	u32_t i,remain;      

	gpio_pin_write(gpio_lcd, RS, 1);
   1ef90:	4b10      	ldr	r3, [pc, #64]	; (1efd4 <DispDate+0x44>)
{
   1ef92:	b570      	push	{r4, r5, r6, lr}
	gpio_pin_write(gpio_lcd, RS, 1);
   1ef94:	2201      	movs	r2, #1
{
   1ef96:	4604      	mov	r4, r0
   1ef98:	460e      	mov	r6, r1
	gpio_pin_write(gpio_lcd, RS, 1);
   1ef9a:	6818      	ldr	r0, [r3, #0]
   1ef9c:	2115      	movs	r1, #21
   1ef9e:	f018 f9e1 	bl	37364 <gpio_pin_write>
	
	while(1)
	{
		if(total <= 2*LCD_DATA_LEN)
   1efa2:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
   1efa6:	4625      	mov	r5, r4
   1efa8:	bf28      	it	cs
   1efaa:	f44f 5500 	movcs.w	r5, #8192	; 0x2000
			remain = total;
		else
			remain = 2*LCD_DATA_LEN;
		
		for(i=0;i<remain;i++)
   1efae:	4633      	mov	r3, r6
   1efb0:	4a09      	ldr	r2, [pc, #36]	; (1efd8 <DispDate+0x48>)
   1efb2:	1971      	adds	r1, r6, r5
   1efb4:	428b      	cmp	r3, r1
   1efb6:	d107      	bne.n	1efc8 <DispDate+0x38>
		{
			lcd_data_buffer[i] = data[i];
		}
		
		LCD_SPI_Transceive(lcd_data_buffer, remain, NULL, 0);
   1efb8:	4628      	mov	r0, r5
   1efba:	f7ff ff69 	bl	1ee90 <LCD_SPI_Transceive.constprop.0>

		if(remain == total)
   1efbe:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
   1efc2:	d906      	bls.n	1efd2 <DispDate+0x42>
			break;

		total -= remain;
   1efc4:	1b64      	subs	r4, r4, r5
		if(total <= 2*LCD_DATA_LEN)
   1efc6:	e7ec      	b.n	1efa2 <DispDate+0x12>
			lcd_data_buffer[i] = data[i];
   1efc8:	f813 0b01 	ldrb.w	r0, [r3], #1
   1efcc:	f802 0b01 	strb.w	r0, [r2], #1
   1efd0:	e7f0      	b.n	1efb4 <DispDate+0x24>
	}
}
   1efd2:	bd70      	pop	{r4, r5, r6, pc}
   1efd4:	20020198 	.word	0x20020198
   1efd8:	200222a9 	.word	0x200222a9

0001efdc <LCD_SleepIn>:
	DispColor(COL*ROW, color);
} 

//
void LCD_SleepIn(void)
{
   1efdc:	b510      	push	{r4, lr}
	if(lcd_is_sleeping)
   1efde:	4c08      	ldr	r4, [pc, #32]	; (1f000 <LCD_SleepIn+0x24>)
   1efe0:	7823      	ldrb	r3, [r4, #0]
   1efe2:	b963      	cbnz	r3, 1effe <LCD_SleepIn+0x22>
		return;

	//
#ifdef LCD_BACKLIGHT_CONTROLED_BY_PMU
	Set_Screen_Backlight_Off();
   1efe4:	f018 fb31 	bl	3764a <Set_Screen_Backlight_Off>
#else
	//gpio_pin_write(gpio_lcd, LEDK, 1);
	gpio_pin_write(gpio_lcd, LEDA, 0);
#endif

	WriteComm(0x28);	
   1efe8:	2028      	movs	r0, #40	; 0x28
   1efea:	f7ff ff87 	bl	1eefc <WriteComm>
	WriteComm(0x10);  		//Sleep in	
   1efee:	2010      	movs	r0, #16
   1eff0:	f7ff ff84 	bl	1eefc <WriteComm>
	k_sleep(K_MSEC(dly));
   1eff4:	2078      	movs	r0, #120	; 0x78
   1eff6:	f018 f9b3 	bl	37360 <k_sleep>
	Delay(120);             //120ms

	lcd_is_sleeping = true;
   1effa:	2301      	movs	r3, #1
   1effc:	7023      	strb	r3, [r4, #0]
}
   1effe:	bd10      	pop	{r4, pc}
   1f000:	2002ca38 	.word	0x2002ca38

0001f004 <LCD_SleepOut>:

//
void LCD_SleepOut(void)
{
   1f004:	b510      	push	{r4, lr}
	const s32_t ticks = z_timeout_remaining(&timer->timeout);
   1f006:	4818      	ldr	r0, [pc, #96]	; (1f068 <LCD_SleepOut+0x64>)
   1f008:	f015 ffac 	bl	34f64 <z_timeout_remaining>
	return (ticks > 0) ? (u32_t)k_ticks_to_ms_floor64(ticks) : 0U;
   1f00c:	2800      	cmp	r0, #0
   1f00e:	dd0a      	ble.n	1f026 <LCD_SleepOut+0x22>
   1f010:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1f014:	fb80 0103 	smull	r0, r1, r0, r3
   1f018:	0bc3      	lsrs	r3, r0, #15
	u16_t bk_time;
	
	if(k_timer_remaining_get(&backlight_timer) > 0)
   1f01a:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
   1f01e:	d002      	beq.n	1f026 <LCD_SleepOut+0x22>
	z_impl_k_timer_stop(timer);
   1f020:	4811      	ldr	r0, [pc, #68]	; (1f068 <LCD_SleepOut+0x64>)
   1f022:	f01a fe0d 	bl	39c40 <z_impl_k_timer_stop>
		k_timer_stop(&backlight_timer);

	if(global_settings.backlight_time != 0)
   1f026:	4b11      	ldr	r3, [pc, #68]	; (1f06c <LCD_SleepOut+0x68>)
   1f028:	899b      	ldrh	r3, [r3, #12]
   1f02a:	b163      	cbz	r3, 1f046 <LCD_SleepOut+0x42>
	{
		bk_time = global_settings.backlight_time;
		//xb add 2020-12-31 5
		if(sleep_out_by_wrist)
   1f02c:	4a10      	ldr	r2, [pc, #64]	; (1f070 <LCD_SleepOut+0x6c>)
   1f02e:	7811      	ldrb	r1, [r2, #0]
   1f030:	b111      	cbz	r1, 1f038 <LCD_SleepOut+0x34>
		{
			sleep_out_by_wrist = false;
   1f032:	2300      	movs	r3, #0
   1f034:	7013      	strb	r3, [r2, #0]
			bk_time = 5;
   1f036:	2305      	movs	r3, #5
	z_impl_k_timer_start(timer, duration, period);
   1f038:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   1f03c:	2200      	movs	r2, #0
   1f03e:	4359      	muls	r1, r3
   1f040:	4809      	ldr	r0, [pc, #36]	; (1f068 <LCD_SleepOut+0x64>)
   1f042:	f016 f9af 	bl	353a4 <z_impl_k_timer_start>
		}

		k_timer_start(&backlight_timer, K_SECONDS(bk_time), NULL);
	}

	if(!lcd_is_sleeping)
   1f046:	4c0b      	ldr	r4, [pc, #44]	; (1f074 <LCD_SleepOut+0x70>)
   1f048:	7823      	ldrb	r3, [r4, #0]
   1f04a:	b163      	cbz	r3, 1f066 <LCD_SleepOut+0x62>
		return;
	
	WriteComm(0x11);  		//Sleep out	
   1f04c:	2011      	movs	r0, #17
   1f04e:	f7ff ff55 	bl	1eefc <WriteComm>
	k_sleep(K_MSEC(dly));
   1f052:	2078      	movs	r0, #120	; 0x78
   1f054:	f018 f984 	bl	37360 <k_sleep>
	Delay(120);             //120ms
	WriteComm(0x29);
   1f058:	2029      	movs	r0, #41	; 0x29
   1f05a:	f7ff ff4f 	bl	1eefc <WriteComm>

	//
#ifdef LCD_BACKLIGHT_CONTROLED_BY_PMU
	Set_Screen_Backlight_On();
   1f05e:	f018 faef 	bl	37640 <Set_Screen_Backlight_On>
#else
	//gpio_pin_write(gpio_lcd, LEDK, 0);
	gpio_pin_write(gpio_lcd, LEDA, 1);                                                                                                         
#endif

	lcd_is_sleeping = false;
   1f062:	2300      	movs	r3, #0
   1f064:	7023      	strb	r3, [r4, #0]
}
   1f066:	bd10      	pop	{r4, pc}
   1f068:	2002016c 	.word	0x2002016c
   1f06c:	20022242 	.word	0x20022242
   1f070:	200222a8 	.word	0x200222a8
   1f074:	2002ca38 	.word	0x2002ca38

0001f078 <LCD_Init>:

//LCD
void LCD_Init(void)
{
   1f078:	b538      	push	{r3, r4, r5, lr}
	int err;
	
	printk("LCD_Init\n");
   1f07a:	48a6      	ldr	r0, [pc, #664]	; (1f314 <LCD_Init+0x29c>)
   1f07c:	f018 fe20 	bl	37cc0 <printk>
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
   1f080:	48a5      	ldr	r0, [pc, #660]	; (1f318 <LCD_Init+0x2a0>)
   1f082:	f013 f951 	bl	32328 <z_impl_device_get_binding>
	
  	//
  	gpio_lcd = device_get_binding(LCD_PORT);
   1f086:	4ca5      	ldr	r4, [pc, #660]	; (1f31c <LCD_Init+0x2a4>)
   1f088:	6020      	str	r0, [r4, #0]
	if(!gpio_lcd)
   1f08a:	b920      	cbnz	r0, 1f096 <LCD_Init+0x1e>

	k_timer_init(&backlight_timer, backlight_timer_handler, NULL);

	if(global_settings.backlight_time != 0)
		k_timer_start(&backlight_timer, K_SECONDS(global_settings.backlight_time), NULL);	
}
   1f08c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		printk("Cannot bind gpio device\n");
   1f090:	48a3      	ldr	r0, [pc, #652]	; (1f320 <LCD_Init+0x2a8>)
   1f092:	f018 be15 	b.w	37cc0 <printk>
	gpio_pin_configure(gpio_lcd, LEDA, GPIO_DIR_OUT);
   1f096:	210e      	movs	r1, #14
   1f098:	f018 f96e 	bl	37378 <gpio_pin_configure.constprop.2>
	gpio_pin_configure(gpio_lcd, CS, GPIO_DIR_OUT);
   1f09c:	2117      	movs	r1, #23
   1f09e:	6820      	ldr	r0, [r4, #0]
   1f0a0:	f018 f96a 	bl	37378 <gpio_pin_configure.constprop.2>
	gpio_pin_configure(gpio_lcd, RST, GPIO_DIR_OUT);
   1f0a4:	2118      	movs	r1, #24
   1f0a6:	6820      	ldr	r0, [r4, #0]
   1f0a8:	f018 f966 	bl	37378 <gpio_pin_configure.constprop.2>
	gpio_pin_configure(gpio_lcd, RS, GPIO_DIR_OUT);
   1f0ac:	2115      	movs	r1, #21
   1f0ae:	6820      	ldr	r0, [r4, #0]
   1f0b0:	f018 f962 	bl	37378 <gpio_pin_configure.constprop.2>
	gpio_pin_configure(gpio_lcd, VDD, GPIO_DIR_OUT);
   1f0b4:	2112      	movs	r1, #18
   1f0b6:	6820      	ldr	r0, [r4, #0]
   1f0b8:	f018 f95e 	bl	37378 <gpio_pin_configure.constprop.2>
	gpio_pin_write(gpio_lcd, VDD, 1);
   1f0bc:	2201      	movs	r2, #1
   1f0be:	2112      	movs	r1, #18
   1f0c0:	6820      	ldr	r0, [r4, #0]
   1f0c2:	f018 f94f 	bl	37364 <gpio_pin_write>
   1f0c6:	4897      	ldr	r0, [pc, #604]	; (1f324 <LCD_Init+0x2ac>)
   1f0c8:	f013 f92e 	bl	32328 <z_impl_device_get_binding>
	spi_lcd = device_get_binding(LCD_DEV);
   1f0cc:	4b96      	ldr	r3, [pc, #600]	; (1f328 <LCD_Init+0x2b0>)
   1f0ce:	6018      	str	r0, [r3, #0]
	if(!spi_lcd) 
   1f0d0:	2800      	cmp	r0, #0
   1f0d2:	f040 8107 	bne.w	1f2e4 <LCD_Init+0x26c>
		printk("Could not get %s device\n", LCD_DEV);
   1f0d6:	4993      	ldr	r1, [pc, #588]	; (1f324 <LCD_Init+0x2ac>)
   1f0d8:	4894      	ldr	r0, [pc, #592]	; (1f32c <LCD_Init+0x2b4>)
   1f0da:	f018 fdf1 	bl	37cc0 <printk>
	gpio_pin_write(gpio_lcd, RST, 1);
   1f0de:	2201      	movs	r2, #1
   1f0e0:	2118      	movs	r1, #24
   1f0e2:	6820      	ldr	r0, [r4, #0]
   1f0e4:	f018 f93e 	bl	37364 <gpio_pin_write>
	k_sleep(K_MSEC(dly));
   1f0e8:	200a      	movs	r0, #10
   1f0ea:	f018 f939 	bl	37360 <k_sleep>
	gpio_pin_write(gpio_lcd, RST, 0);
   1f0ee:	2200      	movs	r2, #0
   1f0f0:	2118      	movs	r1, #24
   1f0f2:	6820      	ldr	r0, [r4, #0]
   1f0f4:	f018 f936 	bl	37364 <gpio_pin_write>
	k_sleep(K_MSEC(dly));
   1f0f8:	200a      	movs	r0, #10
   1f0fa:	f018 f931 	bl	37360 <k_sleep>
	gpio_pin_write(gpio_lcd, RST, 1);
   1f0fe:	2201      	movs	r2, #1
   1f100:	2118      	movs	r1, #24
   1f102:	6820      	ldr	r0, [r4, #0]
   1f104:	f018 f92e 	bl	37364 <gpio_pin_write>
	k_sleep(K_MSEC(dly));
   1f108:	2078      	movs	r0, #120	; 0x78
   1f10a:	f018 f929 	bl	37360 <k_sleep>
	WriteComm(0x11);     //Sleep out
   1f10e:	2011      	movs	r0, #17
   1f110:	f7ff fef4 	bl	1eefc <WriteComm>
	k_sleep(K_MSEC(dly));
   1f114:	2078      	movs	r0, #120	; 0x78
   1f116:	f018 f923 	bl	37360 <k_sleep>
	WriteComm(0xfe);
   1f11a:	20fe      	movs	r0, #254	; 0xfe
   1f11c:	f7ff feee 	bl	1eefc <WriteComm>
	WriteComm(0xef);	
   1f120:	20ef      	movs	r0, #239	; 0xef
   1f122:	f7ff feeb 	bl	1eefc <WriteComm>
	WriteComm(0x36);	
   1f126:	2036      	movs	r0, #54	; 0x36
   1f128:	f7ff fee8 	bl	1eefc <WriteComm>
	WriteData(0x48);	
   1f12c:	2048      	movs	r0, #72	; 0x48
   1f12e:	f7ff fef5 	bl	1ef1c <WriteData>
	WriteComm(0x3a);	
   1f132:	203a      	movs	r0, #58	; 0x3a
   1f134:	f7ff fee2 	bl	1eefc <WriteComm>
	WriteData(0x05);	
   1f138:	2005      	movs	r0, #5
   1f13a:	f7ff feef 	bl	1ef1c <WriteData>
	WriteComm(0x86);	
   1f13e:	2086      	movs	r0, #134	; 0x86
   1f140:	f7ff fedc 	bl	1eefc <WriteComm>
	WriteData(0x98);	
   1f144:	2098      	movs	r0, #152	; 0x98
   1f146:	f7ff fee9 	bl	1ef1c <WriteData>
	WriteComm(0x89);	
   1f14a:	2089      	movs	r0, #137	; 0x89
   1f14c:	f7ff fed6 	bl	1eefc <WriteComm>
	WriteData(0x03);
   1f150:	2003      	movs	r0, #3
   1f152:	f7ff fee3 	bl	1ef1c <WriteData>
	WriteComm(0x8b);	
   1f156:	208b      	movs	r0, #139	; 0x8b
   1f158:	f7ff fed0 	bl	1eefc <WriteComm>
	WriteData(0x80);	
   1f15c:	2080      	movs	r0, #128	; 0x80
   1f15e:	f7ff fedd 	bl	1ef1c <WriteData>
	WriteComm(0x8d);	
   1f162:	208d      	movs	r0, #141	; 0x8d
   1f164:	f7ff feca 	bl	1eefc <WriteComm>
	WriteData(0x33);	
   1f168:	2033      	movs	r0, #51	; 0x33
   1f16a:	f7ff fed7 	bl	1ef1c <WriteData>
	WriteComm(0x8e);	
   1f16e:	208e      	movs	r0, #142	; 0x8e
   1f170:	f7ff fec4 	bl	1eefc <WriteComm>
	WriteData(0x8f);	
   1f174:	208f      	movs	r0, #143	; 0x8f
   1f176:	f7ff fed1 	bl	1ef1c <WriteData>
	WriteComm(0xe8);
   1f17a:	20e8      	movs	r0, #232	; 0xe8
   1f17c:	f7ff febe 	bl	1eefc <WriteComm>
	WriteData(0x12);
   1f180:	2012      	movs	r0, #18
   1f182:	f7ff fecb 	bl	1ef1c <WriteData>
	WriteData(0x00);	
   1f186:	2000      	movs	r0, #0
   1f188:	f7ff fec8 	bl	1ef1c <WriteData>
	WriteComm(0xc3);	
   1f18c:	20c3      	movs	r0, #195	; 0xc3
   1f18e:	f7ff feb5 	bl	1eefc <WriteComm>
	WriteData(0x20);
   1f192:	2020      	movs	r0, #32
   1f194:	f7ff fec2 	bl	1ef1c <WriteData>
	WriteComm(0xc4);	
   1f198:	20c4      	movs	r0, #196	; 0xc4
   1f19a:	f7ff feaf 	bl	1eefc <WriteComm>
	WriteData(0x30);
   1f19e:	2030      	movs	r0, #48	; 0x30
   1f1a0:	f7ff febc 	bl	1ef1c <WriteData>
	WriteComm(0xc9);	
   1f1a4:	20c9      	movs	r0, #201	; 0xc9
   1f1a6:	f7ff fea9 	bl	1eefc <WriteComm>
	WriteData(0x08);
   1f1aa:	2008      	movs	r0, #8
   1f1ac:	f7ff feb6 	bl	1ef1c <WriteData>
	WriteComm(0xff);
   1f1b0:	20ff      	movs	r0, #255	; 0xff
   1f1b2:	f7ff fea3 	bl	1eefc <WriteComm>
	WriteData(0x62);
   1f1b6:	2062      	movs	r0, #98	; 0x62
   1f1b8:	f7ff feb0 	bl	1ef1c <WriteData>
	WriteComm(0x99);	
   1f1bc:	2099      	movs	r0, #153	; 0x99
   1f1be:	f7ff fe9d 	bl	1eefc <WriteComm>
	WriteData(0x3e);
   1f1c2:	203e      	movs	r0, #62	; 0x3e
   1f1c4:	f7ff feaa 	bl	1ef1c <WriteData>
	WriteComm(0x9d);	
   1f1c8:	209d      	movs	r0, #157	; 0x9d
   1f1ca:	f7ff fe97 	bl	1eefc <WriteComm>
	WriteData(0x4b);
   1f1ce:	204b      	movs	r0, #75	; 0x4b
   1f1d0:	f7ff fea4 	bl	1ef1c <WriteData>
	WriteComm(0x98);	
   1f1d4:	2098      	movs	r0, #152	; 0x98
   1f1d6:	f7ff fe91 	bl	1eefc <WriteComm>
	WriteData(0x3e);
   1f1da:	203e      	movs	r0, #62	; 0x3e
   1f1dc:	f7ff fe9e 	bl	1ef1c <WriteData>
	WriteComm(0x9c);	
   1f1e0:	209c      	movs	r0, #156	; 0x9c
   1f1e2:	f7ff fe8b 	bl	1eefc <WriteComm>
	WriteData(0x4b);
   1f1e6:	204b      	movs	r0, #75	; 0x4b
   1f1e8:	f7ff fe98 	bl	1ef1c <WriteData>
	WriteComm(0xf0);
   1f1ec:	20f0      	movs	r0, #240	; 0xf0
   1f1ee:	f7ff fe85 	bl	1eefc <WriteComm>
	WriteData(0x13);
   1f1f2:	2013      	movs	r0, #19
   1f1f4:	f7ff fe92 	bl	1ef1c <WriteData>
	WriteData(0x14);
   1f1f8:	2014      	movs	r0, #20
   1f1fa:	f7ff fe8f 	bl	1ef1c <WriteData>
	lcd_is_sleeping = false;
   1f1fe:	2400      	movs	r4, #0
	WriteData(0x07);
   1f200:	2007      	movs	r0, #7
   1f202:	f7ff fe8b 	bl	1ef1c <WriteData>
	WriteData(0x05);
   1f206:	2005      	movs	r0, #5
   1f208:	f7ff fe88 	bl	1ef1c <WriteData>
	WriteData(0xf0);
   1f20c:	20f0      	movs	r0, #240	; 0xf0
   1f20e:	f7ff fe85 	bl	1ef1c <WriteData>
	WriteData(0x29);
   1f212:	2029      	movs	r0, #41	; 0x29
   1f214:	f7ff fe82 	bl	1ef1c <WriteData>
	WriteComm(0xf1);
   1f218:	20f1      	movs	r0, #241	; 0xf1
   1f21a:	f7ff fe6f 	bl	1eefc <WriteComm>
	WriteData(0x3e);
   1f21e:	203e      	movs	r0, #62	; 0x3e
   1f220:	f7ff fe7c 	bl	1ef1c <WriteData>
	WriteData(0x92);
   1f224:	2092      	movs	r0, #146	; 0x92
   1f226:	f7ff fe79 	bl	1ef1c <WriteData>
	WriteData(0x90);
   1f22a:	2090      	movs	r0, #144	; 0x90
   1f22c:	f7ff fe76 	bl	1ef1c <WriteData>
	WriteData(0x21);
   1f230:	2021      	movs	r0, #33	; 0x21
   1f232:	f7ff fe73 	bl	1ef1c <WriteData>
	WriteData(0x23);
   1f236:	2023      	movs	r0, #35	; 0x23
   1f238:	f7ff fe70 	bl	1ef1c <WriteData>
	WriteData(0x9f);
   1f23c:	209f      	movs	r0, #159	; 0x9f
   1f23e:	f7ff fe6d 	bl	1ef1c <WriteData>
	WriteComm(0xf2);
   1f242:	20f2      	movs	r0, #242	; 0xf2
   1f244:	f7ff fe5a 	bl	1eefc <WriteComm>
	WriteData(0x13);
   1f248:	2013      	movs	r0, #19
   1f24a:	f7ff fe67 	bl	1ef1c <WriteData>
	WriteData(0x14);
   1f24e:	2014      	movs	r0, #20
   1f250:	f7ff fe64 	bl	1ef1c <WriteData>
	WriteData(0x07);
   1f254:	2007      	movs	r0, #7
   1f256:	f7ff fe61 	bl	1ef1c <WriteData>
	WriteData(0x05);
   1f25a:	2005      	movs	r0, #5
   1f25c:	f7ff fe5e 	bl	1ef1c <WriteData>
	WriteData(0xf0);
   1f260:	20f0      	movs	r0, #240	; 0xf0
   1f262:	f7ff fe5b 	bl	1ef1c <WriteData>
	WriteData(0x29);
   1f266:	2029      	movs	r0, #41	; 0x29
   1f268:	f7ff fe58 	bl	1ef1c <WriteData>
	WriteComm(0xf3);
   1f26c:	20f3      	movs	r0, #243	; 0xf3
   1f26e:	f7ff fe45 	bl	1eefc <WriteComm>
	WriteData(0x3e);
   1f272:	203e      	movs	r0, #62	; 0x3e
   1f274:	f7ff fe52 	bl	1ef1c <WriteData>
	WriteData(0x92);
   1f278:	2092      	movs	r0, #146	; 0x92
   1f27a:	f7ff fe4f 	bl	1ef1c <WriteData>
	WriteData(0x90);
   1f27e:	2090      	movs	r0, #144	; 0x90
   1f280:	f7ff fe4c 	bl	1ef1c <WriteData>
	WriteData(0x21);
   1f284:	2021      	movs	r0, #33	; 0x21
   1f286:	f7ff fe49 	bl	1ef1c <WriteData>
	WriteData(0x23);
   1f28a:	2023      	movs	r0, #35	; 0x23
   1f28c:	f7ff fe46 	bl	1ef1c <WriteData>
	WriteData(0x9f);
   1f290:	209f      	movs	r0, #159	; 0x9f
   1f292:	f7ff fe43 	bl	1ef1c <WriteData>
	WriteComm(0x11);
   1f296:	2011      	movs	r0, #17
   1f298:	f7ff fe30 	bl	1eefc <WriteComm>
	k_sleep(K_MSEC(dly));
   1f29c:	2078      	movs	r0, #120	; 0x78
   1f29e:	f018 f85f 	bl	37360 <k_sleep>
	WriteComm(0x29);
   1f2a2:	2029      	movs	r0, #41	; 0x29
   1f2a4:	f7ff fe2a 	bl	1eefc <WriteComm>
	WriteComm(0x2c);
   1f2a8:	202c      	movs	r0, #44	; 0x2c
   1f2aa:	f7ff fe27 	bl	1eefc <WriteComm>
	LCD_Clear(BLACK);		//
   1f2ae:	2000      	movs	r0, #0
   1f2b0:	f018 f8a4 	bl	373fc <LCD_Clear>
	k_sleep(K_MSEC(dly));
   1f2b4:	2014      	movs	r0, #20
   1f2b6:	f018 f853 	bl	37360 <k_sleep>
	Set_Screen_Backlight_On();
   1f2ba:	f018 f9c1 	bl	37640 <Set_Screen_Backlight_On>
	lcd_is_sleeping = false;
   1f2be:	4b1c      	ldr	r3, [pc, #112]	; (1f330 <LCD_Init+0x2b8>)
	k_timer_init(&backlight_timer, backlight_timer_handler, NULL);
   1f2c0:	4622      	mov	r2, r4
   1f2c2:	491c      	ldr	r1, [pc, #112]	; (1f334 <LCD_Init+0x2bc>)
   1f2c4:	481c      	ldr	r0, [pc, #112]	; (1f338 <LCD_Init+0x2c0>)
	lcd_is_sleeping = false;
   1f2c6:	701c      	strb	r4, [r3, #0]
	k_timer_init(&backlight_timer, backlight_timer_handler, NULL);
   1f2c8:	f01a fcae 	bl	39c28 <k_timer_init>
	if(global_settings.backlight_time != 0)
   1f2cc:	4b1b      	ldr	r3, [pc, #108]	; (1f33c <LCD_Init+0x2c4>)
   1f2ce:	899b      	ldrh	r3, [r3, #12]
   1f2d0:	b1f3      	cbz	r3, 1f310 <LCD_Init+0x298>
   1f2d2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   1f2d6:	4622      	mov	r2, r4
   1f2d8:	4359      	muls	r1, r3
}
   1f2da:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1f2de:	4816      	ldr	r0, [pc, #88]	; (1f338 <LCD_Init+0x2c0>)
   1f2e0:	f016 b860 	b.w	353a4 <z_impl_k_timer_start>
	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
   1f2e4:	f44f 7380 	mov.w	r3, #256	; 0x100
	spi_cfg.frequency = 4000000;
   1f2e8:	4d15      	ldr	r5, [pc, #84]	; (1f340 <LCD_Init+0x2c8>)
	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
   1f2ea:	4816      	ldr	r0, [pc, #88]	; (1f344 <LCD_Init+0x2cc>)
   1f2ec:	e9c5 0300 	strd	r0, r3, [r5]
   1f2f0:	4809      	ldr	r0, [pc, #36]	; (1f318 <LCD_Init+0x2a0>)
   1f2f2:	f013 f819 	bl	32328 <z_impl_device_get_binding>
	spi_cs_ctr.gpio_dev = device_get_binding(LCD_PORT);
   1f2f6:	4b14      	ldr	r3, [pc, #80]	; (1f348 <LCD_Init+0x2d0>)
   1f2f8:	6018      	str	r0, [r3, #0]
	if (!spi_cs_ctr.gpio_dev)
   1f2fa:	b918      	cbnz	r0, 1f304 <LCD_Init+0x28c>
		printk("Unable to get GPIO SPI CS device\n");
   1f2fc:	4813      	ldr	r0, [pc, #76]	; (1f34c <LCD_Init+0x2d4>)
   1f2fe:	f018 fcdf 	bl	37cc0 <printk>
		return;
   1f302:	e6ec      	b.n	1f0de <LCD_Init+0x66>
	spi_cs_ctr.delay = 0U;
   1f304:	2117      	movs	r1, #23
   1f306:	2200      	movs	r2, #0
	spi_cfg.cs = &spi_cs_ctr;
   1f308:	60ab      	str	r3, [r5, #8]
	spi_cs_ctr.delay = 0U;
   1f30a:	e9c3 1201 	strd	r1, r2, [r3, #4]
	spi_cfg.cs = &spi_cs_ctr;
   1f30e:	e6e6      	b.n	1f0de <LCD_Init+0x66>
}
   1f310:	bd38      	pop	{r3, r4, r5, pc}
   1f312:	bf00      	nop
   1f314:	0003b9f7 	.word	0x0003b9f7
   1f318:	0003ba01 	.word	0x0003ba01
   1f31c:	20020198 	.word	0x20020198
   1f320:	0003ba08 	.word	0x0003ba08
   1f324:	0003ba21 	.word	0x0003ba21
   1f328:	200201c4 	.word	0x200201c4
   1f32c:	0003ba27 	.word	0x0003ba27
   1f330:	2002ca38 	.word	0x2002ca38
   1f334:	0001ee85 	.word	0x0001ee85
   1f338:	2002016c 	.word	0x2002016c
   1f33c:	20022242 	.word	0x20022242
   1f340:	200201ac 	.word	0x200201ac
   1f344:	003d0900 	.word	0x003d0900
   1f348:	200201b8 	.word	0x200201b8
   1f34c:	0003ba40 	.word	0x0003ba40

0001f350 <key_event_handler>:

static void key_event_handler(u8_t key_code, u8_t key_type)
{
	//LOG_INF("key_code:%d, key_type:%d, KEY_SOS:%d,KEY_PWR:%d\n", key_code, key_type,	KEY_SOS, KEY_PWR);

	switch(key_code)
   1f350:	2801      	cmp	r0, #1
{
   1f352:	b508      	push	{r3, lr}
	switch(key_code)
   1f354:	d003      	beq.n	1f35e <key_event_handler+0xe>
   1f356:	2802      	cmp	r0, #2
   1f358:	d014      	beq.n	1f384 <key_event_handler+0x34>
		}
		break;	
	}

	//power key will wakeup lcd
	if((key_type == KEY_UP))
   1f35a:	b161      	cbz	r1, 1f376 <key_event_handler+0x26>
   1f35c:	e002      	b.n	1f364 <key_event_handler+0x14>
		switch(key_type)
   1f35e:	b141      	cbz	r1, 1f372 <key_event_handler+0x22>
   1f360:	2902      	cmp	r1, #2
   1f362:	d00b      	beq.n	1f37c <key_event_handler+0x2c>
	if(alarm_is_running)
	{
		//AlarmRemindStop();
	}

	if(find_is_running)
   1f364:	4b0b      	ldr	r3, [pc, #44]	; (1f394 <key_event_handler+0x44>)
   1f366:	781b      	ldrb	r3, [r3, #0]
   1f368:	b193      	cbz	r3, 1f390 <key_event_handler+0x40>
	{
		FindDeviceStop();
	}

	//ExitNotifyScreen();
}
   1f36a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		FindDeviceStop();
   1f36e:	f7ff badd 	b.w	1e92c <FindDeviceStop>
			AlarmRemindStart();
   1f372:	f7ff fa85 	bl	1e880 <AlarmRemindStart>
		sleep_out_by_wrist = false;
   1f376:	4b08      	ldr	r3, [pc, #32]	; (1f398 <key_event_handler+0x48>)
   1f378:	2200      	movs	r2, #0
   1f37a:	e001      	b.n	1f380 <key_event_handler+0x30>
			sys_pwr_off = true;
   1f37c:	2201      	movs	r2, #1
   1f37e:	4b07      	ldr	r3, [pc, #28]	; (1f39c <key_event_handler+0x4c>)
		sleep_out_by_wrist = false;
   1f380:	701a      	strb	r2, [r3, #0]
   1f382:	e7ef      	b.n	1f364 <key_event_handler+0x14>
		switch(key_type)
   1f384:	2900      	cmp	r1, #0
   1f386:	d1eb      	bne.n	1f360 <key_event_handler+0x10>
			vibrate_stop_flag = true;
   1f388:	2201      	movs	r2, #1
   1f38a:	4b05      	ldr	r3, [pc, #20]	; (1f3a0 <key_event_handler+0x50>)
   1f38c:	701a      	strb	r2, [r3, #0]
			break;
   1f38e:	e7f2      	b.n	1f376 <key_event_handler+0x26>
}
   1f390:	bd08      	pop	{r3, pc}
   1f392:	bf00      	nop
   1f394:	200222a4 	.word	0x200222a4
   1f398:	200222a8 	.word	0x200222a8
   1f39c:	20024ce1 	.word	0x20024ce1
   1f3a0:	20024ce3 	.word	0x20024ce3

0001f3a4 <long_press_timer_handler>:
	key_event_handler(keycode, keytype);
}

static void long_press_timer_handler(struct k_timer *timer)
{
    key_event_handler(keycode, KEY_LONG_PRESS);
   1f3a4:	4b02      	ldr	r3, [pc, #8]	; (1f3b0 <long_press_timer_handler+0xc>)
   1f3a6:	2102      	movs	r1, #2
   1f3a8:	7818      	ldrb	r0, [r3, #0]
   1f3aa:	f7ff bfd1 	b.w	1f350 <key_event_handler>
   1f3ae:	bf00      	nop
   1f3b0:	20020250 	.word	0x20020250

0001f3b4 <button_handler>:
	keytype = button_state/has_changed;
   1f3b4:	fbb0 f0f1 	udiv	r0, r0, r1
{
   1f3b8:	b538      	push	{r3, r4, r5, lr}
	keycode = has_changed;
   1f3ba:	4c0b      	ldr	r4, [pc, #44]	; (1f3e8 <button_handler+0x34>)
	keytype = button_state/has_changed;
   1f3bc:	4d0b      	ldr	r5, [pc, #44]	; (1f3ec <button_handler+0x38>)
	keycode = has_changed;
   1f3be:	6021      	str	r1, [r4, #0]
	keytype = button_state/has_changed;
   1f3c0:	6028      	str	r0, [r5, #0]
	switch(keytype)
   1f3c2:	b168      	cbz	r0, 1f3e0 <button_handler+0x2c>
   1f3c4:	2801      	cmp	r0, #1
   1f3c6:	d105      	bne.n	1f3d4 <button_handler+0x20>
   1f3c8:	2200      	movs	r2, #0
   1f3ca:	f241 3188 	movw	r1, #5000	; 0x1388
   1f3ce:	4808      	ldr	r0, [pc, #32]	; (1f3f0 <button_handler+0x3c>)
   1f3d0:	f015 ffe8 	bl	353a4 <z_impl_k_timer_start>
	key_event_handler(keycode, keytype);
   1f3d4:	7829      	ldrb	r1, [r5, #0]
   1f3d6:	7820      	ldrb	r0, [r4, #0]
}
   1f3d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	key_event_handler(keycode, keytype);
   1f3dc:	f7ff bfb8 	b.w	1f350 <key_event_handler>
	z_impl_k_timer_stop(timer);
   1f3e0:	4803      	ldr	r0, [pc, #12]	; (1f3f0 <button_handler+0x3c>)
   1f3e2:	f01a fc2d 	bl	39c40 <z_impl_k_timer_stop>
   1f3e6:	e7f5      	b.n	1f3d4 <button_handler+0x20>
   1f3e8:	20020250 	.word	0x20020250
   1f3ec:	20020254 	.word	0x20020254
   1f3f0:	20020218 	.word	0x20020218

0001f3f4 <button_pressed>:

	last_state = current_state;
}

static void button_pressed(struct device *gpio_dev, struct gpio_callback *cb, u32_t pins)
{
   1f3f4:	b538      	push	{r3, r4, r5, lr}
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
   1f3f6:	f04f 0320 	mov.w	r3, #32
   1f3fa:	f3ef 8411 	mrs	r4, BASEPRI
   1f3fe:	f383 8811 	msr	BASEPRI, r3
   1f402:	f3bf 8f6f 	isb	sy
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   1f406:	4833      	ldr	r0, [pc, #204]	; (1f4d4 <button_pressed+0xe0>)
   1f408:	f015 fa1e 	bl	34848 <z_spin_lock_valid>
   1f40c:	b968      	cbnz	r0, 1f42a <button_pressed+0x36>
   1f40e:	234a      	movs	r3, #74	; 0x4a
   1f410:	4a31      	ldr	r2, [pc, #196]	; (1f4d8 <button_pressed+0xe4>)
   1f412:	4932      	ldr	r1, [pc, #200]	; (1f4dc <button_pressed+0xe8>)
   1f414:	4832      	ldr	r0, [pc, #200]	; (1f4e0 <button_pressed+0xec>)
   1f416:	f018 fc53 	bl	37cc0 <printk>
   1f41a:	492e      	ldr	r1, [pc, #184]	; (1f4d4 <button_pressed+0xe0>)
   1f41c:	4831      	ldr	r0, [pc, #196]	; (1f4e4 <button_pressed+0xf0>)
   1f41e:	f018 fc4f 	bl	37cc0 <printk>
   1f422:	214a      	movs	r1, #74	; 0x4a
   1f424:	482c      	ldr	r0, [pc, #176]	; (1f4d8 <button_pressed+0xe4>)
   1f426:	f018 fc91 	bl	37d4c <assert_post_action>
			err = gpio_pin_disable_callback(button_devs[i], button_pins[i].number);
   1f42a:	4d2f      	ldr	r5, [pc, #188]	; (1f4e8 <button_pressed+0xf4>)
	while (!atomic_cas(&l->locked, 0, 1)) {
	}
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
   1f42c:	4829      	ldr	r0, [pc, #164]	; (1f4d4 <button_pressed+0xe0>)
   1f42e:	f015 fa29 	bl	34884 <z_spin_lock_set_owner>
   1f432:	6828      	ldr	r0, [r5, #0]
					      int access_op, u32_t pin)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	if (api->disable_callback == NULL) {
   1f434:	6843      	ldr	r3, [r0, #4]
   1f436:	695b      	ldr	r3, [r3, #20]
   1f438:	2b00      	cmp	r3, #0
   1f43a:	d12e      	bne.n	1f49a <button_pressed+0xa6>
	/* Disable GPIO interrupt */
	int err = callback_ctrl(false);

	if(err)
	{
		LOG_INF("Cannot disable callbacks");
   1f43c:	2303      	movs	r3, #3
   1f43e:	f04f 0000 	mov.w	r0, #0
   1f442:	4a2a      	ldr	r2, [pc, #168]	; (1f4ec <button_pressed+0xf8>)
   1f444:	f363 0007 	bfi	r0, r3, #0, #8
   1f448:	4b29      	ldr	r3, [pc, #164]	; (1f4f0 <button_pressed+0xfc>)
   1f44a:	492a      	ldr	r1, [pc, #168]	; (1f4f4 <button_pressed+0x100>)
   1f44c:	1a9b      	subs	r3, r3, r2
   1f44e:	08db      	lsrs	r3, r3, #3
   1f450:	f363 108f 	bfi	r0, r3, #6, #10
   1f454:	f018 fc8b 	bl	37d6e <log_string_sync>
	}

	switch (state)
   1f458:	4b27      	ldr	r3, [pc, #156]	; (1f4f8 <button_pressed+0x104>)
   1f45a:	781a      	ldrb	r2, [r3, #0]
   1f45c:	2a00      	cmp	r2, #0
   1f45e:	d12c      	bne.n	1f4ba <button_pressed+0xc6>
	{
	case STATE_WAITING:
		state = STATE_SCANNING;
   1f460:	2201      	movs	r2, #1
 * @req K-DWORK-001
 */
static inline int k_delayed_work_submit(struct k_delayed_work *work,
					s32_t delay)
{
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   1f462:	4926      	ldr	r1, [pc, #152]	; (1f4fc <button_pressed+0x108>)
   1f464:	4826      	ldr	r0, [pc, #152]	; (1f500 <button_pressed+0x10c>)
   1f466:	701a      	strb	r2, [r3, #0]
   1f468:	f015 fbc2 	bl	34bf0 <k_delayed_work_submit_to_queue>
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   1f46c:	4819      	ldr	r0, [pc, #100]	; (1f4d4 <button_pressed+0xe0>)
   1f46e:	f015 f9f9 	bl	34864 <z_spin_unlock_valid>
   1f472:	b968      	cbnz	r0, 1f490 <button_pressed+0x9c>
   1f474:	235d      	movs	r3, #93	; 0x5d
   1f476:	4a18      	ldr	r2, [pc, #96]	; (1f4d8 <button_pressed+0xe4>)
   1f478:	4922      	ldr	r1, [pc, #136]	; (1f504 <button_pressed+0x110>)
   1f47a:	4819      	ldr	r0, [pc, #100]	; (1f4e0 <button_pressed+0xec>)
   1f47c:	f018 fc20 	bl	37cc0 <printk>
   1f480:	4914      	ldr	r1, [pc, #80]	; (1f4d4 <button_pressed+0xe0>)
   1f482:	4821      	ldr	r0, [pc, #132]	; (1f508 <button_pressed+0x114>)
   1f484:	f018 fc1c 	bl	37cc0 <printk>
   1f488:	215d      	movs	r1, #93	; 0x5d
   1f48a:	4813      	ldr	r0, [pc, #76]	; (1f4d8 <button_pressed+0xe4>)
   1f48c:	f018 fc5e 	bl	37d4c <assert_post_action>
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   1f490:	f384 8811 	msr	BASEPRI, r4
   1f494:	f3bf 8f6f 	isb	sy
		__ASSERT_NO_MSG(false);
		break;
	}

	k_spin_unlock(&lock, key);
}
   1f498:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOTSUP;
	}

	return api->disable_callback(port, access_op, pin);
   1f49a:	2100      	movs	r1, #0
   1f49c:	221a      	movs	r2, #26
   1f49e:	4798      	blx	r3
	for(size_t i = 0; (i < ARRAY_SIZE(button_pins)) && !err; i++)
   1f4a0:	4601      	mov	r1, r0
   1f4a2:	2800      	cmp	r0, #0
   1f4a4:	d1ca      	bne.n	1f43c <button_pressed+0x48>
			err = gpio_pin_disable_callback(button_devs[i], button_pins[i].number);
   1f4a6:	6868      	ldr	r0, [r5, #4]
	if (api->disable_callback == NULL) {
   1f4a8:	6843      	ldr	r3, [r0, #4]
   1f4aa:	695b      	ldr	r3, [r3, #20]
   1f4ac:	2b00      	cmp	r3, #0
   1f4ae:	d0c5      	beq.n	1f43c <button_pressed+0x48>
	return api->disable_callback(port, access_op, pin);
   1f4b0:	220f      	movs	r2, #15
   1f4b2:	4798      	blx	r3
	if(err)
   1f4b4:	2800      	cmp	r0, #0
   1f4b6:	d0cf      	beq.n	1f458 <button_pressed+0x64>
   1f4b8:	e7c0      	b.n	1f43c <button_pressed+0x48>
		__ASSERT_NO_MSG(false);
   1f4ba:	f240 1351 	movw	r3, #337	; 0x151
   1f4be:	4a13      	ldr	r2, [pc, #76]	; (1f50c <button_pressed+0x118>)
   1f4c0:	4913      	ldr	r1, [pc, #76]	; (1f510 <button_pressed+0x11c>)
   1f4c2:	4807      	ldr	r0, [pc, #28]	; (1f4e0 <button_pressed+0xec>)
   1f4c4:	f018 fbfc 	bl	37cc0 <printk>
   1f4c8:	f240 1151 	movw	r1, #337	; 0x151
   1f4cc:	480f      	ldr	r0, [pc, #60]	; (1f50c <button_pressed+0x118>)
   1f4ce:	f018 fc3d 	bl	37d4c <assert_post_action>
		break;
   1f4d2:	e7cb      	b.n	1f46c <button_pressed+0x78>
   1f4d4:	20020260 	.word	0x20020260
   1f4d8:	0003ba71 	.word	0x0003ba71
   1f4dc:	0003ba97 	.word	0x0003ba97
   1f4e0:	0003baac 	.word	0x0003baac
   1f4e4:	0003bac9 	.word	0x0003bac9
   1f4e8:	200201d8 	.word	0x200201d8
   1f4ec:	0003ade0 	.word	0x0003ade0
   1f4f0:	0003ae58 	.word	0x0003ae58
   1f4f4:	0003bae1 	.word	0x0003bae1
   1f4f8:	200242a9 	.word	0x200242a9
   1f4fc:	200201f8 	.word	0x200201f8
   1f500:	20022150 	.word	0x20022150
   1f504:	0003bb0b 	.word	0x0003bb0b
   1f508:	0003bb22 	.word	0x0003bb22
   1f50c:	0003bafa 	.word	0x0003bafa
   1f510:	0003f10e 	.word	0x0003f10e

0001f514 <buttons_scan_fn>:
{
   1f514:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1f518:	2500      	movs	r5, #0
   1f51a:	f8df 9214 	ldr.w	r9, [pc, #532]	; 1f730 <buttons_scan_fn+0x21c>
	u32_t ret = 0;
   1f51e:	462c      	mov	r4, r5
	for(size_t i = 0; i < ARRAY_SIZE(button_pins); i++)
   1f520:	46a8      	mov	r8, r5
   1f522:	464f      	mov	r7, r9
			ret |= 1U << i;
   1f524:	f04f 0a01 	mov.w	sl, #1
   1f528:	4e6a      	ldr	r6, [pc, #424]	; (1f6d4 <buttons_scan_fn+0x1c0>)
		if(gpio_pin_read(button_devs[i], button_pins[i].number, &val))
   1f52a:	f859 0b04 	ldr.w	r0, [r9], #4
   1f52e:	7932      	ldrb	r2, [r6, #4]
	return api->read(port, access_op, pin, value);
   1f530:	6843      	ldr	r3, [r0, #4]
   1f532:	2100      	movs	r1, #0
   1f534:	f8d3 b008 	ldr.w	fp, [r3, #8]
   1f538:	ab01      	add	r3, sp, #4
   1f53a:	47d8      	blx	fp
   1f53c:	2800      	cmp	r0, #0
   1f53e:	d044      	beq.n	1f5ca <buttons_scan_fn+0xb6>
			LOG_INF("Cannot read gpio pin");
   1f540:	2303      	movs	r3, #3
   1f542:	f04f 0000 	mov.w	r0, #0
   1f546:	4a64      	ldr	r2, [pc, #400]	; (1f6d8 <buttons_scan_fn+0x1c4>)
   1f548:	f363 0007 	bfi	r0, r3, #0, #8
   1f54c:	4b63      	ldr	r3, [pc, #396]	; (1f6dc <buttons_scan_fn+0x1c8>)
   1f54e:	4964      	ldr	r1, [pc, #400]	; (1f6e0 <buttons_scan_fn+0x1cc>)
   1f550:	1a9b      	subs	r3, r3, r2
   1f552:	08db      	lsrs	r3, r3, #3
   1f554:	f363 108f 	bfi	r0, r3, #6, #10
   1f558:	f018 fc09 	bl	37d6e <log_string_sync>
			return 0;
   1f55c:	2400      	movs	r4, #0
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1f55e:	4b61      	ldr	r3, [pc, #388]	; (1f6e4 <buttons_scan_fn+0x1d0>)
   1f560:	e8d3 2fef 	ldaex	r2, [r3]
   1f564:	e8c3 4fe1 	stlex	r1, r4, [r3]
   1f568:	2900      	cmp	r1, #0
   1f56a:	d1f9      	bne.n	1f560 <buttons_scan_fn+0x4c>
	if(!initial_run)
   1f56c:	4b5e      	ldr	r3, [pc, #376]	; (1f6e8 <buttons_scan_fn+0x1d4>)
   1f56e:	4d5f      	ldr	r5, [pc, #380]	; (1f6ec <buttons_scan_fn+0x1d8>)
   1f570:	781a      	ldrb	r2, [r3, #0]
   1f572:	2a00      	cmp	r2, #0
   1f574:	d140      	bne.n	1f5f8 <buttons_scan_fn+0xe4>
		if(button_scan != last_button_scan)
   1f576:	6829      	ldr	r1, [r5, #0]
   1f578:	42a1      	cmp	r1, r4
   1f57a:	d00d      	beq.n	1f598 <buttons_scan_fn+0x84>
	if(button_handler_cb != NULL)
   1f57c:	4b5c      	ldr	r3, [pc, #368]	; (1f6f0 <buttons_scan_fn+0x1dc>)
   1f57e:	681b      	ldr	r3, [r3, #0]
   1f580:	b113      	cbz	r3, 1f588 <buttons_scan_fn+0x74>
		button_handler_cb(button_state, has_changed);
   1f582:	4061      	eors	r1, r4
   1f584:	4620      	mov	r0, r4
   1f586:	4798      	blx	r3
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&mutex, *(uintptr_t *)&timeout, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
   1f588:	f04f 31ff 	mov.w	r1, #4294967295
   1f58c:	4859      	ldr	r0, [pc, #356]	; (1f6f4 <buttons_scan_fn+0x1e0>)
   1f58e:	f013 fbaf 	bl	32cf0 <z_impl_k_mutex_lock>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_unlock(mutex);
   1f592:	4858      	ldr	r0, [pc, #352]	; (1f6f4 <buttons_scan_fn+0x1e0>)
   1f594:	f013 fc8a 	bl	32eac <z_impl_k_mutex_unlock>
	last_button_scan = button_scan;
   1f598:	602c      	str	r4, [r5, #0]
	if (button_scan != 0)
   1f59a:	b384      	cbz	r4, 1f5fe <buttons_scan_fn+0xea>
   1f59c:	220a      	movs	r2, #10
   1f59e:	4956      	ldr	r1, [pc, #344]	; (1f6f8 <buttons_scan_fn+0x1e4>)
   1f5a0:	4856      	ldr	r0, [pc, #344]	; (1f6fc <buttons_scan_fn+0x1e8>)
   1f5a2:	f015 fb25 	bl	34bf0 <k_delayed_work_submit_to_queue>
		if(err)
   1f5a6:	b168      	cbz	r0, 1f5c4 <buttons_scan_fn+0xb0>
			LOG_INF("Cannot add work to workqueue");
   1f5a8:	2303      	movs	r3, #3
   1f5aa:	f04f 0000 	mov.w	r0, #0
   1f5ae:	4a4a      	ldr	r2, [pc, #296]	; (1f6d8 <buttons_scan_fn+0x1c4>)
   1f5b0:	f363 0007 	bfi	r0, r3, #0, #8
   1f5b4:	4b49      	ldr	r3, [pc, #292]	; (1f6dc <buttons_scan_fn+0x1c8>)
   1f5b6:	4952      	ldr	r1, [pc, #328]	; (1f700 <buttons_scan_fn+0x1ec>)
   1f5b8:	1a9b      	subs	r3, r3, r2
   1f5ba:	08db      	lsrs	r3, r3, #3
   1f5bc:	f363 108f 	bfi	r0, r3, #6, #10
			LOG_INF("Cannot enable callbacks");
   1f5c0:	f018 fbd5 	bl	37d6e <log_string_sync>
}
   1f5c4:	b003      	add	sp, #12
   1f5c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		switch(button_pins[i].active_flag)
   1f5ca:	7973      	ldrb	r3, [r6, #5]
   1f5cc:	b163      	cbz	r3, 1f5e8 <buttons_scan_fn+0xd4>
			actived_low = false;
   1f5ce:	2b01      	cmp	r3, #1
   1f5d0:	bf08      	it	eq
   1f5d2:	2500      	moveq	r5, #0
		if((!val && actived_low)||
   1f5d4:	9b01      	ldr	r3, [sp, #4]
   1f5d6:	b94b      	cbnz	r3, 1f5ec <buttons_scan_fn+0xd8>
   1f5d8:	b955      	cbnz	r5, 1f5f0 <buttons_scan_fn+0xdc>
   1f5da:	3608      	adds	r6, #8
	for(size_t i = 0; i < ARRAY_SIZE(button_pins); i++)
   1f5dc:	f1b8 0f00 	cmp.w	r8, #0
   1f5e0:	d1bd      	bne.n	1f55e <buttons_scan_fn+0x4a>
   1f5e2:	f04f 0801 	mov.w	r8, #1
   1f5e6:	e7a0      	b.n	1f52a <buttons_scan_fn+0x16>
			actived_low = true;
   1f5e8:	2501      	movs	r5, #1
   1f5ea:	e7f3      	b.n	1f5d4 <buttons_scan_fn+0xc0>
			(val && !actived_low))
   1f5ec:	2d00      	cmp	r5, #0
   1f5ee:	d1f4      	bne.n	1f5da <buttons_scan_fn+0xc6>
			ret |= 1U << i;
   1f5f0:	fa0a f308 	lsl.w	r3, sl, r8
   1f5f4:	431c      	orrs	r4, r3
   1f5f6:	e7f0      	b.n	1f5da <buttons_scan_fn+0xc6>
		initial_run = false;
   1f5f8:	2200      	movs	r2, #0
   1f5fa:	701a      	strb	r2, [r3, #0]
   1f5fc:	e7cc      	b.n	1f598 <buttons_scan_fn+0x84>
	__asm__ volatile(
   1f5fe:	f04f 0320 	mov.w	r3, #32
   1f602:	f3ef 8511 	mrs	r5, BASEPRI
   1f606:	f383 8811 	msr	BASEPRI, r3
   1f60a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   1f60e:	483d      	ldr	r0, [pc, #244]	; (1f704 <buttons_scan_fn+0x1f0>)
   1f610:	f015 f91a 	bl	34848 <z_spin_lock_valid>
   1f614:	b968      	cbnz	r0, 1f632 <buttons_scan_fn+0x11e>
   1f616:	234a      	movs	r3, #74	; 0x4a
   1f618:	4a3b      	ldr	r2, [pc, #236]	; (1f708 <buttons_scan_fn+0x1f4>)
   1f61a:	493c      	ldr	r1, [pc, #240]	; (1f70c <buttons_scan_fn+0x1f8>)
   1f61c:	483c      	ldr	r0, [pc, #240]	; (1f710 <buttons_scan_fn+0x1fc>)
   1f61e:	f018 fb4f 	bl	37cc0 <printk>
   1f622:	4938      	ldr	r1, [pc, #224]	; (1f704 <buttons_scan_fn+0x1f0>)
   1f624:	483b      	ldr	r0, [pc, #236]	; (1f714 <buttons_scan_fn+0x200>)
   1f626:	f018 fb4b 	bl	37cc0 <printk>
   1f62a:	214a      	movs	r1, #74	; 0x4a
   1f62c:	4836      	ldr	r0, [pc, #216]	; (1f708 <buttons_scan_fn+0x1f4>)
   1f62e:	f018 fb8d 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   1f632:	4834      	ldr	r0, [pc, #208]	; (1f704 <buttons_scan_fn+0x1f0>)
   1f634:	f015 f926 	bl	34884 <z_spin_lock_set_owner>
		switch (state)
   1f638:	4b37      	ldr	r3, [pc, #220]	; (1f718 <buttons_scan_fn+0x204>)
   1f63a:	781a      	ldrb	r2, [r3, #0]
   1f63c:	2a01      	cmp	r2, #1
   1f63e:	d13b      	bne.n	1f6b8 <buttons_scan_fn+0x1a4>
			state = STATE_WAITING;
   1f640:	2100      	movs	r1, #0
			err = gpio_pin_enable_callback(button_devs[i], button_pins[i].number);
   1f642:	6838      	ldr	r0, [r7, #0]
			state = STATE_WAITING;
   1f644:	7019      	strb	r1, [r3, #0]
	if (api->enable_callback == NULL) {
   1f646:	6843      	ldr	r3, [r0, #4]
   1f648:	691b      	ldr	r3, [r3, #16]
   1f64a:	bb33      	cbnz	r3, 1f69a <buttons_scan_fn+0x186>
		return -ENOTSUP;
   1f64c:	f06f 0485 	mvn.w	r4, #133	; 0x85
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   1f650:	482c      	ldr	r0, [pc, #176]	; (1f704 <buttons_scan_fn+0x1f0>)
   1f652:	f015 f907 	bl	34864 <z_spin_unlock_valid>
   1f656:	b968      	cbnz	r0, 1f674 <buttons_scan_fn+0x160>
   1f658:	235d      	movs	r3, #93	; 0x5d
   1f65a:	4a2b      	ldr	r2, [pc, #172]	; (1f708 <buttons_scan_fn+0x1f4>)
   1f65c:	492f      	ldr	r1, [pc, #188]	; (1f71c <buttons_scan_fn+0x208>)
   1f65e:	482c      	ldr	r0, [pc, #176]	; (1f710 <buttons_scan_fn+0x1fc>)
   1f660:	f018 fb2e 	bl	37cc0 <printk>
   1f664:	4927      	ldr	r1, [pc, #156]	; (1f704 <buttons_scan_fn+0x1f0>)
   1f666:	482e      	ldr	r0, [pc, #184]	; (1f720 <buttons_scan_fn+0x20c>)
   1f668:	f018 fb2a 	bl	37cc0 <printk>
   1f66c:	215d      	movs	r1, #93	; 0x5d
   1f66e:	4826      	ldr	r0, [pc, #152]	; (1f708 <buttons_scan_fn+0x1f4>)
   1f670:	f018 fb6c 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   1f674:	f385 8811 	msr	BASEPRI, r5
   1f678:	f3bf 8f6f 	isb	sy
		if(err)
   1f67c:	2c00      	cmp	r4, #0
   1f67e:	d0a1      	beq.n	1f5c4 <buttons_scan_fn+0xb0>
			LOG_INF("Cannot enable callbacks");
   1f680:	2303      	movs	r3, #3
   1f682:	f04f 0000 	mov.w	r0, #0
   1f686:	4a14      	ldr	r2, [pc, #80]	; (1f6d8 <buttons_scan_fn+0x1c4>)
   1f688:	f363 0007 	bfi	r0, r3, #0, #8
   1f68c:	4b13      	ldr	r3, [pc, #76]	; (1f6dc <buttons_scan_fn+0x1c8>)
   1f68e:	4925      	ldr	r1, [pc, #148]	; (1f724 <buttons_scan_fn+0x210>)
   1f690:	1a9b      	subs	r3, r3, r2
   1f692:	08db      	lsrs	r3, r3, #3
   1f694:	f363 108f 	bfi	r0, r3, #6, #10
   1f698:	e792      	b.n	1f5c0 <buttons_scan_fn+0xac>
	return api->enable_callback(port, access_op, pin);
   1f69a:	221a      	movs	r2, #26
   1f69c:	4798      	blx	r3
	for(size_t i = 0; (i < ARRAY_SIZE(button_pins)) && !err; i++)
   1f69e:	4604      	mov	r4, r0
   1f6a0:	2800      	cmp	r0, #0
   1f6a2:	d1d5      	bne.n	1f650 <buttons_scan_fn+0x13c>
			err = gpio_pin_enable_callback(button_devs[i], button_pins[i].number);
   1f6a4:	6878      	ldr	r0, [r7, #4]
	if (api->enable_callback == NULL) {
   1f6a6:	6843      	ldr	r3, [r0, #4]
   1f6a8:	691b      	ldr	r3, [r3, #16]
   1f6aa:	2b00      	cmp	r3, #0
   1f6ac:	d0ce      	beq.n	1f64c <buttons_scan_fn+0x138>
	return api->enable_callback(port, access_op, pin);
   1f6ae:	4621      	mov	r1, r4
   1f6b0:	220f      	movs	r2, #15
   1f6b2:	4798      	blx	r3
   1f6b4:	4604      	mov	r4, r0
   1f6b6:	e7cb      	b.n	1f650 <buttons_scan_fn+0x13c>
			__ASSERT_NO_MSG(false);
   1f6b8:	f44f 7386 	mov.w	r3, #268	; 0x10c
   1f6bc:	4a1a      	ldr	r2, [pc, #104]	; (1f728 <buttons_scan_fn+0x214>)
   1f6be:	491b      	ldr	r1, [pc, #108]	; (1f72c <buttons_scan_fn+0x218>)
   1f6c0:	4813      	ldr	r0, [pc, #76]	; (1f710 <buttons_scan_fn+0x1fc>)
   1f6c2:	f018 fafd 	bl	37cc0 <printk>
   1f6c6:	f44f 7186 	mov.w	r1, #268	; 0x10c
   1f6ca:	4817      	ldr	r0, [pc, #92]	; (1f728 <buttons_scan_fn+0x214>)
   1f6cc:	f018 fb3e 	bl	37d4c <assert_post_action>
		int err = 0;
   1f6d0:	2400      	movs	r4, #0
   1f6d2:	e7bd      	b.n	1f650 <buttons_scan_fn+0x13c>
   1f6d4:	0003b1d8 	.word	0x0003b1d8
   1f6d8:	0003ade0 	.word	0x0003ade0
   1f6dc:	0003ae58 	.word	0x0003ae58
   1f6e0:	0003bb37 	.word	0x0003bb37
   1f6e4:	20020264 	.word	0x20020264
   1f6e8:	2002ca3a 	.word	0x2002ca3a
   1f6ec:	20020258 	.word	0x20020258
   1f6f0:	200201e0 	.word	0x200201e0
   1f6f4:	200201e4 	.word	0x200201e4
   1f6f8:	200201f8 	.word	0x200201f8
   1f6fc:	20022150 	.word	0x20022150
   1f700:	0003bb4c 	.word	0x0003bb4c
   1f704:	20020260 	.word	0x20020260
   1f708:	0003ba71 	.word	0x0003ba71
   1f70c:	0003ba97 	.word	0x0003ba97
   1f710:	0003baac 	.word	0x0003baac
   1f714:	0003bac9 	.word	0x0003bac9
   1f718:	200242a9 	.word	0x200242a9
   1f71c:	0003bb0b 	.word	0x0003bb0b
   1f720:	0003bb22 	.word	0x0003bb22
   1f724:	0003bb69 	.word	0x0003bb69
   1f728:	0003bafa 	.word	0x0003bafa
   1f72c:	0003f10e 	.word	0x0003f10e
   1f730:	200201d8 	.word	0x200201d8

0001f734 <key_init>:

	return 0;
}

void key_init(void)
{
   1f734:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int err;

	LOG_INF("key_init\n");
   1f736:	f04f 0000 	mov.w	r0, #0
   1f73a:	2303      	movs	r3, #3
   1f73c:	4d6a      	ldr	r5, [pc, #424]	; (1f8e8 <key_init+0x1b4>)
   1f73e:	f363 0007 	bfi	r0, r3, #0, #8
   1f742:	4b6a      	ldr	r3, [pc, #424]	; (1f8ec <key_init+0x1b8>)
   1f744:	496a      	ldr	r1, [pc, #424]	; (1f8f0 <key_init+0x1bc>)
   1f746:	1aed      	subs	r5, r5, r3
   1f748:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   1f74c:	f365 108f 	bfi	r0, r5, #6, #10
   1f750:	f018 fb0d 	bl	37d6e <log_string_sync>
	button_handler_cb = button_handler;
   1f754:	4b67      	ldr	r3, [pc, #412]	; (1f8f4 <key_init+0x1c0>)
   1f756:	4a68      	ldr	r2, [pc, #416]	; (1f8f8 <key_init+0x1c4>)
   1f758:	601a      	str	r2, [r3, #0]
	return z_impl_k_mutex_init(mutex);
   1f75a:	4868      	ldr	r0, [pc, #416]	; (1f8fc <key_init+0x1c8>)
   1f75c:	f01a f95e 	bl	39a1c <z_impl_k_mutex_init>
   1f760:	4867      	ldr	r0, [pc, #412]	; (1f900 <key_init+0x1cc>)
   1f762:	f012 fde1 	bl	32328 <z_impl_device_get_binding>
		button_devs[i] = device_get_binding(button_pins[i].port);
   1f766:	4e67      	ldr	r6, [pc, #412]	; (1f904 <key_init+0x1d0>)
   1f768:	6030      	str	r0, [r6, #0]
		if (!button_devs[i])
   1f76a:	b350      	cbz	r0, 1f7c2 <key_init+0x8e>
	return api->config(port, access_op, pin, flags);
   1f76c:	6843      	ldr	r3, [r0, #4]
   1f76e:	221a      	movs	r2, #26
   1f770:	681c      	ldr	r4, [r3, #0]
   1f772:	2100      	movs	r1, #0
   1f774:	f44f 7380 	mov.w	r3, #256	; 0x100
   1f778:	47a0      	blx	r4
		if(err)
   1f77a:	4604      	mov	r4, r0
   1f77c:	2800      	cmp	r0, #0
   1f77e:	d139      	bne.n	1f7f4 <key_init+0xc0>
   1f780:	485f      	ldr	r0, [pc, #380]	; (1f900 <key_init+0x1cc>)
   1f782:	f012 fdd1 	bl	32328 <z_impl_device_get_binding>
		button_devs[i] = device_get_binding(button_pins[i].port);
   1f786:	6070      	str	r0, [r6, #4]
		if (!button_devs[i])
   1f788:	b1d8      	cbz	r0, 1f7c2 <key_init+0x8e>
   1f78a:	6843      	ldr	r3, [r0, #4]
   1f78c:	4621      	mov	r1, r4
   1f78e:	681f      	ldr	r7, [r3, #0]
   1f790:	220f      	movs	r2, #15
   1f792:	f44f 7380 	mov.w	r3, #256	; 0x100
   1f796:	47b8      	blx	r7
		if(err)
   1f798:	4604      	mov	r4, r0
   1f79a:	bb58      	cbnz	r0, 1f7f4 <key_init+0xc0>
		err = gpio_pin_configure(button_devs[i], button_pins[i].number, flags);
   1f79c:	6830      	ldr	r0, [r6, #0]
   1f79e:	6843      	ldr	r3, [r0, #4]
   1f7a0:	4621      	mov	r1, r4
   1f7a2:	681f      	ldr	r7, [r3, #0]
   1f7a4:	221a      	movs	r2, #26
   1f7a6:	f44f 7381 	mov.w	r3, #258	; 0x102
   1f7aa:	47b8      	blx	r7
	for(size_t i = 0; (i < ARRAY_SIZE(button_pins)) && !err; i++)
   1f7ac:	4604      	mov	r4, r0
   1f7ae:	b360      	cbz	r0, 1f80a <key_init+0xd6>
		LOG_INF("Cannot set interrupt mode");
   1f7b0:	f04f 0000 	mov.w	r0, #0
   1f7b4:	2303      	movs	r3, #3
   1f7b6:	f363 0007 	bfi	r0, r3, #0, #8
   1f7ba:	f365 108f 	bfi	r0, r5, #6, #10
   1f7be:	4952      	ldr	r1, [pc, #328]	; (1f908 <key_init+0x1d4>)
   1f7c0:	e020      	b.n	1f804 <key_init+0xd0>
			LOG_INF("Cannot bind gpio device");
   1f7c2:	2303      	movs	r3, #3
   1f7c4:	f04f 0000 	mov.w	r0, #0
   1f7c8:	f363 0007 	bfi	r0, r3, #0, #8
   1f7cc:	f365 108f 	bfi	r0, r5, #6, #10
   1f7d0:	494e      	ldr	r1, [pc, #312]	; (1f90c <key_init+0x1d8>)
   1f7d2:	f018 facc 	bl	37d6e <log_string_sync>
			return -ENODEV;
   1f7d6:	f06f 0412 	mvn.w	r4, #18
	
	err = buttons_init(button_handler);
	if (err)
	{
		LOG_INF("Could not initialize buttons, err code: %d\n", err);
   1f7da:	2303      	movs	r3, #3
   1f7dc:	f04f 0000 	mov.w	r0, #0
   1f7e0:	f363 0007 	bfi	r0, r3, #0, #8
   1f7e4:	f365 108f 	bfi	r0, r5, #6, #10
   1f7e8:	4622      	mov	r2, r4
		return;
	}

	k_timer_init(&g_long_press_timer_id, long_press_timer_handler, NULL);
}
   1f7ea:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		LOG_INF("Could not initialize buttons, err code: %d\n", err);
   1f7ee:	4948      	ldr	r1, [pc, #288]	; (1f910 <key_init+0x1dc>)
   1f7f0:	f018 babd 	b.w	37d6e <log_string_sync>
			LOG_INF("Cannot configure button gpio");
   1f7f4:	f04f 0000 	mov.w	r0, #0
   1f7f8:	2303      	movs	r3, #3
   1f7fa:	4946      	ldr	r1, [pc, #280]	; (1f914 <key_init+0x1e0>)
   1f7fc:	f363 0007 	bfi	r0, r3, #0, #8
   1f800:	f365 108f 	bfi	r0, r5, #6, #10
		LOG_INF("Cannot set interrupt mode");
   1f804:	f018 fab3 	bl	37d6e <log_string_sync>
		return err;
   1f808:	e7e7      	b.n	1f7da <key_init+0xa6>
		err = gpio_pin_configure(button_devs[i], button_pins[i].number, flags);
   1f80a:	6870      	ldr	r0, [r6, #4]
   1f80c:	6843      	ldr	r3, [r0, #4]
   1f80e:	4621      	mov	r1, r4
   1f810:	681f      	ldr	r7, [r3, #0]
   1f812:	220f      	movs	r2, #15
   1f814:	f44f 7381 	mov.w	r3, #258	; 0x102
   1f818:	47b8      	blx	r7
	if(err)
   1f81a:	4604      	mov	r4, r0
   1f81c:	2800      	cmp	r0, #0
   1f81e:	d1c7      	bne.n	1f7b0 <key_init+0x7c>
		err = gpio_pin_disable_callback(button_devs[i], button_pins[i].number);
   1f820:	6830      	ldr	r0, [r6, #0]
	if (api->disable_callback == NULL) {
   1f822:	6843      	ldr	r3, [r0, #4]
   1f824:	695b      	ldr	r3, [r3, #20]
   1f826:	b313      	cbz	r3, 1f86e <key_init+0x13a>
	return api->disable_callback(port, access_op, pin);
   1f828:	4621      	mov	r1, r4
   1f82a:	221a      	movs	r2, #26
   1f82c:	4798      	blx	r3
		if(err)
   1f82e:	4604      	mov	r4, r0
   1f830:	b9f8      	cbnz	r0, 1f872 <key_init+0x13e>
		err = gpio_pin_disable_callback(button_devs[i], button_pins[i].number);
   1f832:	6870      	ldr	r0, [r6, #4]
	if (api->disable_callback == NULL) {
   1f834:	6843      	ldr	r3, [r0, #4]
   1f836:	695b      	ldr	r3, [r3, #20]
   1f838:	b1cb      	cbz	r3, 1f86e <key_init+0x13a>
	return api->disable_callback(port, access_op, pin);
   1f83a:	4621      	mov	r1, r4
   1f83c:	220f      	movs	r2, #15
   1f83e:	4798      	blx	r3
		if(err)
   1f840:	4604      	mov	r4, r0
   1f842:	b9b0      	cbnz	r0, 1f872 <key_init+0x13e>
				      u32_t pin_mask)
{
	__ASSERT(callback, "Callback pointer should not be NULL");
	__ASSERT(handler, "Callback handler pointer should not be NULL");

	callback->handler = handler;
   1f844:	4f34      	ldr	r7, [pc, #208]	; (1f918 <key_init+0x1e4>)
   1f846:	4b35      	ldr	r3, [pc, #212]	; (1f91c <key_init+0x1e8>)
		err = gpio_add_callback(button_devs[i], &gpio_cb);
   1f848:	6830      	ldr	r0, [r6, #0]
   1f84a:	607b      	str	r3, [r7, #4]
	callback->pin_mask = pin_mask;
   1f84c:	4b34      	ldr	r3, [pc, #208]	; (1f920 <key_init+0x1ec>)
   1f84e:	60bb      	str	r3, [r7, #8]
				    struct gpio_callback *callback)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	if (api->manage_callback == NULL) {
   1f850:	6843      	ldr	r3, [r0, #4]
   1f852:	68db      	ldr	r3, [r3, #12]
   1f854:	b143      	cbz	r3, 1f868 <key_init+0x134>
		return -ENOTSUP;
	}

	return api->manage_callback(port, callback, true);
   1f856:	2201      	movs	r2, #1
   1f858:	4639      	mov	r1, r7
   1f85a:	4798      	blx	r3
		if(err)
   1f85c:	4604      	mov	r4, r0
   1f85e:	b9b0      	cbnz	r0, 1f88e <key_init+0x15a>
		err = gpio_add_callback(button_devs[i], &gpio_cb);
   1f860:	6870      	ldr	r0, [r6, #4]
	if (api->manage_callback == NULL) {
   1f862:	6843      	ldr	r3, [r0, #4]
   1f864:	68db      	ldr	r3, [r3, #12]
   1f866:	b96b      	cbnz	r3, 1f884 <key_init+0x150>
		return -ENOTSUP;
   1f868:	f06f 0485 	mvn.w	r4, #133	; 0x85
   1f86c:	e00f      	b.n	1f88e <key_init+0x15a>
		return -ENOTSUP;
   1f86e:	f06f 0485 	mvn.w	r4, #133	; 0x85
			LOG_INF("Cannot disable callbacks()");
   1f872:	f04f 0000 	mov.w	r0, #0
   1f876:	2303      	movs	r3, #3
   1f878:	f363 0007 	bfi	r0, r3, #0, #8
   1f87c:	f365 108f 	bfi	r0, r5, #6, #10
   1f880:	4928      	ldr	r1, [pc, #160]	; (1f924 <key_init+0x1f0>)
   1f882:	e7bf      	b.n	1f804 <key_init+0xd0>
	return api->manage_callback(port, callback, true);
   1f884:	2201      	movs	r2, #1
   1f886:	4639      	mov	r1, r7
   1f888:	4798      	blx	r3
		if(err)
   1f88a:	4604      	mov	r4, r0
   1f88c:	b140      	cbz	r0, 1f8a0 <key_init+0x16c>
			LOG_INF("Cannot add callback");
   1f88e:	f04f 0000 	mov.w	r0, #0
   1f892:	2303      	movs	r3, #3
   1f894:	f363 0007 	bfi	r0, r3, #0, #8
   1f898:	f365 108f 	bfi	r0, r5, #6, #10
   1f89c:	4922      	ldr	r1, [pc, #136]	; (1f928 <key_init+0x1f4>)
   1f89e:	e7b1      	b.n	1f804 <key_init+0xd0>
	k_delayed_work_init(&buttons_scan, buttons_scan_fn);
   1f8a0:	4922      	ldr	r1, [pc, #136]	; (1f92c <key_init+0x1f8>)
   1f8a2:	4823      	ldr	r0, [pc, #140]	; (1f930 <key_init+0x1fc>)
   1f8a4:	f01a f9a6 	bl	39bf4 <k_delayed_work_init>
	state = STATE_SCANNING;
   1f8a8:	2201      	movs	r2, #1
   1f8aa:	4b22      	ldr	r3, [pc, #136]	; (1f934 <key_init+0x200>)
   1f8ac:	4920      	ldr	r1, [pc, #128]	; (1f930 <key_init+0x1fc>)
   1f8ae:	701a      	strb	r2, [r3, #0]
   1f8b0:	4821      	ldr	r0, [pc, #132]	; (1f938 <key_init+0x204>)
   1f8b2:	4622      	mov	r2, r4
   1f8b4:	f015 f99c 	bl	34bf0 <k_delayed_work_submit_to_queue>
	if(err)
   1f8b8:	4604      	mov	r4, r0
   1f8ba:	b140      	cbz	r0, 1f8ce <key_init+0x19a>
		LOG_INF("Cannot add work to workqueue");
   1f8bc:	f04f 0000 	mov.w	r0, #0
   1f8c0:	2303      	movs	r3, #3
   1f8c2:	f363 0007 	bfi	r0, r3, #0, #8
   1f8c6:	f365 108f 	bfi	r0, r5, #6, #10
   1f8ca:	491c      	ldr	r1, [pc, #112]	; (1f93c <key_init+0x208>)
   1f8cc:	e79a      	b.n	1f804 <key_init+0xd0>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1f8ce:	4b1c      	ldr	r3, [pc, #112]	; (1f940 <key_init+0x20c>)
   1f8d0:	e8d3 2faf 	lda	r2, [r3]
	last_state = current_state;
   1f8d4:	4b1b      	ldr	r3, [pc, #108]	; (1f944 <key_init+0x210>)
	k_timer_init(&g_long_press_timer_id, long_press_timer_handler, NULL);
   1f8d6:	491c      	ldr	r1, [pc, #112]	; (1f948 <key_init+0x214>)
	last_state = current_state;
   1f8d8:	601a      	str	r2, [r3, #0]
	k_timer_init(&g_long_press_timer_id, long_press_timer_handler, NULL);
   1f8da:	4602      	mov	r2, r0
}
   1f8dc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	k_timer_init(&g_long_press_timer_id, long_press_timer_handler, NULL);
   1f8e0:	481a      	ldr	r0, [pc, #104]	; (1f94c <key_init+0x218>)
   1f8e2:	f01a b9a1 	b.w	39c28 <k_timer_init>
   1f8e6:	bf00      	nop
   1f8e8:	0003ae58 	.word	0x0003ae58
   1f8ec:	0003ade0 	.word	0x0003ade0
   1f8f0:	0003bb81 	.word	0x0003bb81
   1f8f4:	200201e0 	.word	0x200201e0
   1f8f8:	0001f3b5 	.word	0x0001f3b5
   1f8fc:	200201e4 	.word	0x200201e4
   1f900:	0003ba01 	.word	0x0003ba01
   1f904:	200201d8 	.word	0x200201d8
   1f908:	0003bbc0 	.word	0x0003bbc0
   1f90c:	0003bb8b 	.word	0x0003bb8b
   1f910:	0003bc09 	.word	0x0003bc09
   1f914:	0003bba3 	.word	0x0003bba3
   1f918:	20020244 	.word	0x20020244
   1f91c:	0001f3f5 	.word	0x0001f3f5
   1f920:	04008000 	.word	0x04008000
   1f924:	0003bbda 	.word	0x0003bbda
   1f928:	0003bbf5 	.word	0x0003bbf5
   1f92c:	0001f515 	.word	0x0001f515
   1f930:	200201f8 	.word	0x200201f8
   1f934:	200242a9 	.word	0x200242a9
   1f938:	20022150 	.word	0x20022150
   1f93c:	0003bb4c 	.word	0x0003bb4c
   1f940:	20020264 	.word	0x20020264
   1f944:	2002025c 	.word	0x2002025c
   1f948:	0001f3a5 	.word	0x0001f3a5
   1f94c:	20020218 	.word	0x20020218

0001f950 <SaveSystemDateTime>:
	return err;
}

void SaveSystemDateTime(void)
{
	nvs_write(&fs, DATETIME_ID, &date_time, sizeof(sys_date_timer_t));
   1f950:	2308      	movs	r3, #8
   1f952:	4a02      	ldr	r2, [pc, #8]	; (1f95c <SaveSystemDateTime+0xc>)
   1f954:	2101      	movs	r1, #1
   1f956:	4802      	ldr	r0, [pc, #8]	; (1f960 <SaveSystemDateTime+0x10>)
   1f958:	f004 bd32 	b.w	243c0 <nvs_write>
   1f95c:	20022230 	.word	0x20022230
   1f960:	20020268 	.word	0x20020268

0001f964 <ResetSystemTime>:
}

void ResetSystemTime(void)
{
	memcpy(&date_time, &FACTORY_DEFAULT_TIME, sizeof(sys_date_timer_t));
   1f964:	4903      	ldr	r1, [pc, #12]	; (1f974 <ResetSystemTime+0x10>)
   1f966:	4a04      	ldr	r2, [pc, #16]	; (1f978 <ResetSystemTime+0x14>)
   1f968:	680b      	ldr	r3, [r1, #0]
   1f96a:	6013      	str	r3, [r2, #0]
   1f96c:	684b      	ldr	r3, [r1, #4]
   1f96e:	6053      	str	r3, [r2, #4]
	SaveSystemDateTime();
   1f970:	f7ff bfee 	b.w	1f950 <SaveSystemDateTime>
   1f974:	0003b900 	.word	0x0003b900
   1f978:	20022230 	.word	0x20022230

0001f97c <InitSystemDateTime>:
}

void InitSystemDateTime(void)
{
   1f97c:	b513      	push	{r0, r1, r4, lr}
	int err = 0;
	sys_date_timer_t mytime = {0};
   1f97e:	2300      	movs	r3, #0
   1f980:	466c      	mov	r4, sp
   1f982:	9300      	str	r3, [sp, #0]
   1f984:	6063      	str	r3, [r4, #4]

	err = nvs_read(&fs, DATETIME_ID, &date_time, sizeof(sys_date_timer_t));
   1f986:	4a15      	ldr	r2, [pc, #84]	; (1f9dc <InitSystemDateTime+0x60>)
   1f988:	2308      	movs	r3, #8
   1f98a:	2101      	movs	r1, #1
   1f98c:	4814      	ldr	r0, [pc, #80]	; (1f9e0 <InitSystemDateTime+0x64>)
   1f98e:	f018 fb03 	bl	37f98 <nvs_read>
	if(err < 0)
   1f992:	1e02      	subs	r2, r0, #0
   1f994:	da0d      	bge.n	1f9b2 <InitSystemDateTime+0x36>
	{
		LOG_INF("get datetime err:%d\n", err);
   1f996:	2303      	movs	r3, #3
   1f998:	f04f 0000 	mov.w	r0, #0
   1f99c:	4911      	ldr	r1, [pc, #68]	; (1f9e4 <InitSystemDateTime+0x68>)
   1f99e:	f363 0007 	bfi	r0, r3, #0, #8
   1f9a2:	4b11      	ldr	r3, [pc, #68]	; (1f9e8 <InitSystemDateTime+0x6c>)
   1f9a4:	1a5b      	subs	r3, r3, r1
   1f9a6:	08db      	lsrs	r3, r3, #3
   1f9a8:	f363 108f 	bfi	r0, r3, #6, #10
   1f9ac:	490f      	ldr	r1, [pc, #60]	; (1f9ec <InitSystemDateTime+0x70>)
   1f9ae:	f018 f9de 	bl	37d6e <log_string_sync>
	}
	
	if(!CheckSystemDateTimeIsValid(mytime))
   1f9b2:	e894 0003 	ldmia.w	r4, {r0, r1}
   1f9b6:	f017 fc64 	bl	37282 <CheckSystemDateTimeIsValid>
   1f9ba:	b920      	cbnz	r0, 1f9c6 <InitSystemDateTime+0x4a>
	{
		memcpy(&mytime, &FACTORY_DEFAULT_TIME, sizeof(sys_date_timer_t));
   1f9bc:	4623      	mov	r3, r4
   1f9be:	4a0c      	ldr	r2, [pc, #48]	; (1f9f0 <InitSystemDateTime+0x74>)
   1f9c0:	6810      	ldr	r0, [r2, #0]
   1f9c2:	6851      	ldr	r1, [r2, #4]
   1f9c4:	c303      	stmia	r3!, {r0, r1}
	}
	memcpy(&date_time, &mytime, sizeof(sys_date_timer_t));
   1f9c6:	cc03      	ldmia	r4!, {r0, r1}
   1f9c8:	4b04      	ldr	r3, [pc, #16]	; (1f9dc <InitSystemDateTime+0x60>)
   1f9ca:	6018      	str	r0, [r3, #0]
   1f9cc:	6059      	str	r1, [r3, #4]

	SaveSystemDateTime();
   1f9ce:	f7ff ffbf 	bl	1f950 <SaveSystemDateTime>
	StartSystemDateTime();
}
   1f9d2:	b002      	add	sp, #8
   1f9d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	StartSystemDateTime();
   1f9d8:	f7fe be14 	b.w	1e604 <StartSystemDateTime>
   1f9dc:	20022230 	.word	0x20022230
   1f9e0:	20020268 	.word	0x20020268
   1f9e4:	0003ade0 	.word	0x0003ade0
   1f9e8:	0003aec8 	.word	0x0003aec8
   1f9ec:	0003bc39 	.word	0x0003bc39
   1f9f0:	0003b900 	.word	0x0003b900

0001f9f4 <SaveSystemSettings>:

void SaveSystemSettings(void)
{
	nvs_write(&fs, SETTINGS_ID, &global_settings, sizeof(global_settings_t));
   1f9f4:	2330      	movs	r3, #48	; 0x30
   1f9f6:	4a02      	ldr	r2, [pc, #8]	; (1fa00 <SaveSystemSettings+0xc>)
   1f9f8:	2102      	movs	r1, #2
   1f9fa:	4802      	ldr	r0, [pc, #8]	; (1fa04 <SaveSystemSettings+0x10>)
   1f9fc:	f004 bce0 	b.w	243c0 <nvs_write>
   1fa00:	20022242 	.word	0x20022242
   1fa04:	20020268 	.word	0x20020268

0001fa08 <ResetSystemSettings>:
}

void ResetSystemSettings(void)
{
	memcpy(&global_settings, &FACTORY_DEFAULT_SETTINGS, sizeof(global_settings_t));
   1fa08:	4b05      	ldr	r3, [pc, #20]	; (1fa20 <ResetSystemSettings+0x18>)
   1fa0a:	4a06      	ldr	r2, [pc, #24]	; (1fa24 <ResetSystemSettings+0x1c>)
   1fa0c:	f103 0130 	add.w	r1, r3, #48	; 0x30
   1fa10:	f853 0b04 	ldr.w	r0, [r3], #4
   1fa14:	428b      	cmp	r3, r1
   1fa16:	f842 0b04 	str.w	r0, [r2], #4
   1fa1a:	d1f9      	bne.n	1fa10 <ResetSystemSettings+0x8>
	SaveSystemSettings();
   1fa1c:	f7ff bfea 	b.w	1f9f4 <SaveSystemSettings>
   1fa20:	0003b8d0 	.word	0x0003b8d0
   1fa24:	20022242 	.word	0x20022242

0001fa28 <InitSystemSettings>:
}

void InitSystemSettings(void)
{
   1fa28:	b570      	push	{r4, r5, r6, lr}
	int err;

	if(!nvs_init_flag)
   1fa2a:	4d2c      	ldr	r5, [pc, #176]	; (1fadc <InitSystemSettings+0xb4>)
   1fa2c:	782b      	ldrb	r3, [r5, #0]
   1fa2e:	b9c3      	cbnz	r3, 1fa62 <InitSystemSettings+0x3a>
	fs.offset = DT_FLASH_AREA_STORAGE_OFFSET;	
   1fa30:	f44f 237a 	mov.w	r3, #1024000	; 0xfa000
   1fa34:	4c2a      	ldr	r4, [pc, #168]	; (1fae0 <InitSystemSettings+0xb8>)
   1fa36:	6023      	str	r3, [r4, #0]
   1fa38:	482a      	ldr	r0, [pc, #168]	; (1fae4 <InitSystemSettings+0xbc>)
   1fa3a:	f012 fc75 	bl	32328 <z_impl_device_get_binding>
	err = flash_get_page_info_by_offs(device_get_binding(DT_FLASH_DEV_NAME), fs.offset, &info);	
   1fa3e:	6821      	ldr	r1, [r4, #0]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&offset, *(uintptr_t *)&info, K_SYSCALL_FLASH_GET_PAGE_INFO_BY_OFFS);
	}
#endif
	compiler_barrier();
	return z_impl_flash_get_page_info_by_offs(dev, offset, info);
   1fa40:	4e29      	ldr	r6, [pc, #164]	; (1fae8 <InitSystemSettings+0xc0>)
   1fa42:	4632      	mov	r2, r6
   1fa44:	f019 f93a 	bl	38cbc <z_impl_flash_get_page_info_by_offs>
	if(err)
   1fa48:	2800      	cmp	r0, #0
   1fa4a:	d136      	bne.n	1faba <InitSystemSettings+0x92>
	fs.sector_size = info.size;
   1fa4c:	6873      	ldr	r3, [r6, #4]
	err = nvs_init(&fs, DT_FLASH_DEV_NAME);
   1fa4e:	4925      	ldr	r1, [pc, #148]	; (1fae4 <InitSystemSettings+0xbc>)
	fs.sector_size = info.size;
   1fa50:	81a3      	strh	r3, [r4, #12]
	fs.sector_count = 6U;
   1fa52:	2306      	movs	r3, #6
	err = nvs_init(&fs, DT_FLASH_DEV_NAME);
   1fa54:	4620      	mov	r0, r4
	fs.sector_count = 6U;
   1fa56:	81e3      	strh	r3, [r4, #14]
	err = nvs_init(&fs, DT_FLASH_DEV_NAME);
   1fa58:	f004 fb48 	bl	240ec <nvs_init>
	if(err)
   1fa5c:	bb68      	cbnz	r0, 1faba <InitSystemSettings+0x92>
	nvs_init_flag = true;
   1fa5e:	2301      	movs	r3, #1
   1fa60:	702b      	strb	r3, [r5, #0]
			LOG_INF("Flash Init failed, return!\n");
			return;
		}
	}
	
	err = nvs_read(&fs, SETTINGS_ID, &global_settings, sizeof(global_settings_t));
   1fa62:	4a22      	ldr	r2, [pc, #136]	; (1faec <InitSystemSettings+0xc4>)
   1fa64:	2330      	movs	r3, #48	; 0x30
   1fa66:	2102      	movs	r1, #2
   1fa68:	481d      	ldr	r0, [pc, #116]	; (1fae0 <InitSystemSettings+0xb8>)
   1fa6a:	f018 fa95 	bl	37f98 <nvs_read>
	if(err < 0)
   1fa6e:	1e02      	subs	r2, r0, #0
   1fa70:	da0d      	bge.n	1fa8e <InitSystemSettings+0x66>
	{
		LOG_INF("get settins err:%d\n", err);
   1fa72:	2303      	movs	r3, #3
   1fa74:	f04f 0000 	mov.w	r0, #0
   1fa78:	491d      	ldr	r1, [pc, #116]	; (1faf0 <InitSystemSettings+0xc8>)
   1fa7a:	f363 0007 	bfi	r0, r3, #0, #8
   1fa7e:	4b1d      	ldr	r3, [pc, #116]	; (1faf4 <InitSystemSettings+0xcc>)
   1fa80:	1a5b      	subs	r3, r3, r1
   1fa82:	08db      	lsrs	r3, r3, #3
   1fa84:	f363 108f 	bfi	r0, r3, #6, #10
   1fa88:	491b      	ldr	r1, [pc, #108]	; (1faf8 <InitSystemSettings+0xd0>)
   1fa8a:	f018 f970 	bl	37d6e <log_string_sync>
	}

	if(!global_settings.init)
   1fa8e:	4b17      	ldr	r3, [pc, #92]	; (1faec <InitSystemSettings+0xc4>)
   1fa90:	781a      	ldrb	r2, [r3, #0]
   1fa92:	b952      	cbnz	r2, 1faaa <InitSystemSettings+0x82>
	{
		memcpy(&global_settings, &FACTORY_DEFAULT_SETTINGS, sizeof(global_settings_t));
   1fa94:	4a19      	ldr	r2, [pc, #100]	; (1fafc <InitSystemSettings+0xd4>)
   1fa96:	f102 0130 	add.w	r1, r2, #48	; 0x30
   1fa9a:	f852 0b04 	ldr.w	r0, [r2], #4
   1fa9e:	428a      	cmp	r2, r1
   1faa0:	f843 0b04 	str.w	r0, [r3], #4
   1faa4:	d1f9      	bne.n	1fa9a <InitSystemSettings+0x72>
		SaveSystemSettings();
   1faa6:	f7ff ffa5 	bl	1f9f4 <SaveSystemSettings>
	}

	InitSystemDateTime();
   1faaa:	f7ff ff67 	bl	1f97c <InitSystemDateTime>
	AlarmRemindInit();
   1faae:	f7fe ff9d 	bl	1e9ec <AlarmRemindInit>

	mmi_chset_init();
}
   1fab2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	mmi_chset_init();
   1fab6:	f017 be63 	b.w	37780 <mmi_chset_init>
			LOG_INF("Flash Init failed, return!\n");
   1faba:	2303      	movs	r3, #3
}
   1fabc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			LOG_INF("Flash Init failed, return!\n");
   1fac0:	f04f 0000 	mov.w	r0, #0
   1fac4:	4a0a      	ldr	r2, [pc, #40]	; (1faf0 <InitSystemSettings+0xc8>)
   1fac6:	f363 0007 	bfi	r0, r3, #0, #8
   1faca:	4b0a      	ldr	r3, [pc, #40]	; (1faf4 <InitSystemSettings+0xcc>)
   1facc:	490c      	ldr	r1, [pc, #48]	; (1fb00 <InitSystemSettings+0xd8>)
   1face:	1a9b      	subs	r3, r3, r2
   1fad0:	08db      	lsrs	r3, r3, #3
   1fad2:	f363 108f 	bfi	r0, r3, #6, #10
   1fad6:	f018 b94a 	b.w	37d6e <log_string_sync>
   1fada:	bf00      	nop
   1fadc:	200242ad 	.word	0x200242ad
   1fae0:	20020268 	.word	0x20020268
   1fae4:	0003bc4e 	.word	0x0003bc4e
   1fae8:	20020294 	.word	0x20020294
   1faec:	20022242 	.word	0x20022242
   1faf0:	0003ade0 	.word	0x0003ade0
   1faf4:	0003aec8 	.word	0x0003aec8
   1faf8:	0003bc61 	.word	0x0003bc61
   1fafc:	0003b8d0 	.word	0x0003b8d0
   1fb00:	0003bc75 	.word	0x0003bc75

0001fb04 <SettingsMsgPorcess>:

void SettingsMsgPorcess(void)
{
   1fb04:	b510      	push	{r4, lr}
	if(need_save_time)
   1fb06:	4c0e      	ldr	r4, [pc, #56]	; (1fb40 <SettingsMsgPorcess+0x3c>)
   1fb08:	7823      	ldrb	r3, [r4, #0]
   1fb0a:	b11b      	cbz	r3, 1fb14 <SettingsMsgPorcess+0x10>
	{
		SaveSystemDateTime();
   1fb0c:	f7ff ff20 	bl	1f950 <SaveSystemDateTime>
		need_save_time = false;
   1fb10:	2300      	movs	r3, #0
   1fb12:	7023      	strb	r3, [r4, #0]
	}
	
	if(need_save_settings)
   1fb14:	4b0b      	ldr	r3, [pc, #44]	; (1fb44 <SettingsMsgPorcess+0x40>)
   1fb16:	781a      	ldrb	r2, [r3, #0]
   1fb18:	b11a      	cbz	r2, 1fb22 <SettingsMsgPorcess+0x1e>
	{
		need_save_settings = false;
   1fb1a:	2200      	movs	r2, #0
   1fb1c:	701a      	strb	r2, [r3, #0]
		SaveSystemSettings();
   1fb1e:	f7ff ff69 	bl	1f9f4 <SaveSystemSettings>
	}

	if(need_reset_settings)
   1fb22:	4b09      	ldr	r3, [pc, #36]	; (1fb48 <SettingsMsgPorcess+0x44>)
   1fb24:	781a      	ldrb	r2, [r3, #0]
   1fb26:	b152      	cbz	r2, 1fb3e <SettingsMsgPorcess+0x3a>
	{
		need_reset_settings = false;
   1fb28:	2200      	movs	r2, #0
   1fb2a:	701a      	strb	r2, [r3, #0]
		ResetSystemSettings();
   1fb2c:	f7ff ff6c 	bl	1fa08 <ResetSystemSettings>
		ResetSystemTime();
   1fb30:	f7ff ff18 	bl	1f964 <ResetSystemTime>

		lcd_sleep_out = true;
   1fb34:	2301      	movs	r3, #1
   1fb36:	4a05      	ldr	r2, [pc, #20]	; (1fb4c <SettingsMsgPorcess+0x48>)
   1fb38:	7013      	strb	r3, [r2, #0]
		update_date_time = true;
   1fb3a:	4a05      	ldr	r2, [pc, #20]	; (1fb50 <SettingsMsgPorcess+0x4c>)
   1fb3c:	7013      	strb	r3, [r2, #0]
	}
}
   1fb3e:	bd10      	pop	{r4, pc}
   1fb40:	200242ac 	.word	0x200242ac
   1fb44:	200242ab 	.word	0x200242ab
   1fb48:	200242aa 	.word	0x200242aa
   1fb4c:	200222a7 	.word	0x200222a7
   1fb50:	200222a0 	.word	0x200222a0

0001fb54 <z_impl_spi_transceive.constprop.7>:
   1fb54:	6843      	ldr	r3, [r0, #4]
static inline int z_impl_spi_transceive(struct device *dev,
   1fb56:	b410      	push	{r4}
	return api->transceive(dev, config, tx_bufs, rx_bufs);
   1fb58:	681c      	ldr	r4, [r3, #0]
   1fb5a:	4613      	mov	r3, r2
   1fb5c:	46a4      	mov	ip, r4
   1fb5e:	460a      	mov	r2, r1
}
   1fb60:	f85d 4b04 	ldr.w	r4, [sp], #4
	return api->transceive(dev, config, tx_bufs, rx_bufs);
   1fb64:	4900      	ldr	r1, [pc, #0]	; (1fb68 <z_impl_spi_transceive.constprop.7+0x14>)
   1fb66:	4760      	bx	ip
   1fb68:	200202b4 	.word	0x200202b4

0001fb6c <SpiFlash_CS_LOW>:
static struct spi_config spi_cfg;
static struct spi_cs_control spi_cs_ctr;

void SpiFlash_CS_LOW(void)
{
	gpio_pin_write(gpio_flash, CS, 0);
   1fb6c:	4b05      	ldr	r3, [pc, #20]	; (1fb84 <SpiFlash_CS_LOW+0x18>)
{
   1fb6e:	b410      	push	{r4}
	gpio_pin_write(gpio_flash, CS, 0);
   1fb70:	6818      	ldr	r0, [r3, #0]
	return api->write(port, access_op, pin, value);
   1fb72:	6843      	ldr	r3, [r0, #4]
   1fb74:	2202      	movs	r2, #2
   1fb76:	685c      	ldr	r4, [r3, #4]
   1fb78:	2300      	movs	r3, #0
   1fb7a:	46a4      	mov	ip, r4
   1fb7c:	4619      	mov	r1, r3
}
   1fb7e:	f85d 4b04 	ldr.w	r4, [sp], #4
   1fb82:	4760      	bx	ip
   1fb84:	200202a0 	.word	0x200202a0

0001fb88 <SpiFlash_CS_HIGH>:

void SpiFlash_CS_HIGH(void)
{
	gpio_pin_write(gpio_flash, CS, 1);
   1fb88:	4b05      	ldr	r3, [pc, #20]	; (1fba0 <SpiFlash_CS_HIGH+0x18>)
{
   1fb8a:	b410      	push	{r4}
	gpio_pin_write(gpio_flash, CS, 1);
   1fb8c:	6818      	ldr	r0, [r3, #0]
   1fb8e:	6843      	ldr	r3, [r0, #4]
   1fb90:	2202      	movs	r2, #2
   1fb92:	685c      	ldr	r4, [r3, #4]
   1fb94:	2100      	movs	r1, #0
   1fb96:	46a4      	mov	ip, r4
   1fb98:	2301      	movs	r3, #1
}
   1fb9a:	f85d 4b04 	ldr.w	r4, [sp], #4
   1fb9e:	4760      	bx	ip
   1fba0:	200202a0 	.word	0x200202a0

0001fba4 <SpiFlash_Read>:
**         ReadAddr
**         sizesizepBuffer
** 
******************************************************************************/
uint8_t SpiFlash_Read(uint8_t *pBuffer,uint32_t ReadAddr,uint32_t size)
{
   1fba4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1fba8:	4614      	mov	r4, r2
	int err;
	uint32_t read_size;
	
	spi_tx_buf[0] = SPIFlash_ReadData;
   1fbaa:	2203      	movs	r2, #3
   1fbac:	4b2f      	ldr	r3, [pc, #188]	; (1fc6c <SpiFlash_Read+0xc8>)
	spi_tx_buf[2] = (uint8_t)((ReadAddr&0x0000ff00)>>8);
	spi_tx_buf[3] = (uint8_t)ReadAddr;

	tx_buff.buf = spi_tx_buf;
	tx_buff.len = SPIFLASH_CMD_LENGTH;
	tx_bufs.buffers = &tx_buff;
   1fbae:	4d30      	ldr	r5, [pc, #192]	; (1fc70 <SpiFlash_Read+0xcc>)
	spi_tx_buf[0] = SPIFlash_ReadData;
   1fbb0:	701a      	strb	r2, [r3, #0]
	spi_tx_buf[1] = (uint8_t)((ReadAddr&0x00ff0000)>>16);
   1fbb2:	0c0a      	lsrs	r2, r1, #16
   1fbb4:	705a      	strb	r2, [r3, #1]
	spi_tx_buf[2] = (uint8_t)((ReadAddr&0x0000ff00)>>8);
   1fbb6:	0a0a      	lsrs	r2, r1, #8
   1fbb8:	709a      	strb	r2, [r3, #2]
	tx_buff.buf = spi_tx_buf;
   1fbba:	4a2e      	ldr	r2, [pc, #184]	; (1fc74 <SpiFlash_Read+0xd0>)
	spi_tx_buf[3] = (uint8_t)ReadAddr;
   1fbbc:	70d9      	strb	r1, [r3, #3]
	tx_buff.buf = spi_tx_buf;
   1fbbe:	6013      	str	r3, [r2, #0]
	tx_buff.len = SPIFLASH_CMD_LENGTH;
   1fbc0:	2304      	movs	r3, #4
   1fbc2:	6053      	str	r3, [r2, #4]
	tx_bufs.count = 1;
   1fbc4:	2301      	movs	r3, #1

	SpiFlash_CS_LOW();
	
	err = spi_transceive(spi_flash, &spi_cfg, &tx_bufs, NULL);
   1fbc6:	4e2c      	ldr	r6, [pc, #176]	; (1fc78 <SpiFlash_Read+0xd4>)
{
   1fbc8:	4680      	mov	r8, r0
	tx_bufs.buffers = &tx_buff;
   1fbca:	602a      	str	r2, [r5, #0]
	tx_bufs.count = 1;
   1fbcc:	606b      	str	r3, [r5, #4]
	SpiFlash_CS_LOW();
   1fbce:	f7ff ffcd 	bl	1fb6c <SpiFlash_CS_LOW>
	err = spi_transceive(spi_flash, &spi_cfg, &tx_bufs, NULL);
   1fbd2:	6830      	ldr	r0, [r6, #0]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke4(*(uintptr_t *)&dev, *(uintptr_t *)&config, *(uintptr_t *)&tx_bufs, *(uintptr_t *)&rx_bufs, K_SYSCALL_SPI_TRANSCEIVE);
	}
#endif
	compiler_barrier();
	return z_impl_spi_transceive(dev, config, tx_bufs, rx_bufs);
   1fbd4:	2200      	movs	r2, #0
   1fbd6:	4629      	mov	r1, r5
   1fbd8:	f7ff ffbc 	bl	1fb54 <z_impl_spi_transceive.constprop.7>
	if(err)
   1fbdc:	4d27      	ldr	r5, [pc, #156]	; (1fc7c <SpiFlash_Read+0xd8>)
   1fbde:	4b28      	ldr	r3, [pc, #160]	; (1fc80 <SpiFlash_Read+0xdc>)
   1fbe0:	4602      	mov	r2, r0
   1fbe2:	1aed      	subs	r5, r5, r3
   1fbe4:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   1fbe8:	9601      	str	r6, [sp, #4]
   1fbea:	b148      	cbz	r0, 1fc00 <SpiFlash_Read+0x5c>
	{
		LOG_INF("SPI error: %d\n", err);
   1fbec:	2103      	movs	r1, #3
   1fbee:	f04f 0000 	mov.w	r0, #0
   1fbf2:	f361 0007 	bfi	r0, r1, #0, #8
   1fbf6:	f365 108f 	bfi	r0, r5, #6, #10
   1fbfa:	4922      	ldr	r1, [pc, #136]	; (1fc84 <SpiFlash_Read+0xe0>)
   1fbfc:	f018 f8b7 	bl	37d6e <log_string_sync>
		{
			read_size = SPI_TXRX_MAX_LEN;
			size -= SPI_TXRX_MAX_LEN;
		}

		rx_buff.buf = pBuffer;
   1fc00:	4e21      	ldr	r6, [pc, #132]	; (1fc88 <SpiFlash_Read+0xe4>)
		rx_buff.len = read_size;
		rx_bufs.buffers = &rx_buff;
   1fc02:	f8df 9088 	ldr.w	r9, [pc, #136]	; 1fc8c <SpiFlash_Read+0xe8>
		rx_bufs.count = 1;

		err = spi_transceive(spi_flash, &spi_cfg, NULL, &rx_bufs);
		if(err)
		{
			LOG_INF("SPI error: %d\n", err);
   1fc06:	f8df b07c 	ldr.w	fp, [pc, #124]	; 1fc84 <SpiFlash_Read+0xe0>
	while(size!=0)
   1fc0a:	b92c      	cbnz	r4, 1fc18 <SpiFlash_Read+0x74>
		}
		
		pBuffer += read_size;
	}

	SpiFlash_CS_HIGH();
   1fc0c:	f7ff ffbc 	bl	1fb88 <SpiFlash_CS_HIGH>
	
    return true;
}
   1fc10:	2001      	movs	r0, #1
   1fc12:	b003      	add	sp, #12
   1fc14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if(size<=SPI_TXRX_MAX_LEN)
   1fc18:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
			size -= SPI_TXRX_MAX_LEN;
   1fc1c:	bf88      	it	hi
   1fc1e:	f5a4 5a80 	subhi.w	sl, r4, #4096	; 0x1000
		rx_bufs.count = 1;
   1fc22:	f04f 0201 	mov.w	r2, #1
			read_size = SPI_TXRX_MAX_LEN;
   1fc26:	bf88      	it	hi
   1fc28:	f44f 5480 	movhi.w	r4, #4096	; 0x1000
		err = spi_transceive(spi_flash, &spi_cfg, NULL, &rx_bufs);
   1fc2c:	9b01      	ldr	r3, [sp, #4]
			size = 0;
   1fc2e:	bf98      	it	ls
   1fc30:	f04f 0a00 	movls.w	sl, #0
		rx_buff.len = read_size;
   1fc34:	e9c6 8400 	strd	r8, r4, [r6]
		rx_bufs.buffers = &rx_buff;
   1fc38:	f8c9 6000 	str.w	r6, [r9]
		rx_bufs.count = 1;
   1fc3c:	f8c9 2004 	str.w	r2, [r9, #4]
		err = spi_transceive(spi_flash, &spi_cfg, NULL, &rx_bufs);
   1fc40:	6818      	ldr	r0, [r3, #0]
   1fc42:	4a12      	ldr	r2, [pc, #72]	; (1fc8c <SpiFlash_Read+0xe8>)
   1fc44:	2100      	movs	r1, #0
   1fc46:	f7ff ff85 	bl	1fb54 <z_impl_spi_transceive.constprop.7>
		if(err)
   1fc4a:	4602      	mov	r2, r0
   1fc4c:	b158      	cbz	r0, 1fc66 <SpiFlash_Read+0xc2>
			LOG_INF("SPI error: %d\n", err);
   1fc4e:	f027 013f 	bic.w	r1, r7, #63	; 0x3f
   1fc52:	f041 0103 	orr.w	r1, r1, #3
   1fc56:	f361 0707 	bfi	r7, r1, #0, #8
   1fc5a:	f365 178f 	bfi	r7, r5, #6, #10
   1fc5e:	4659      	mov	r1, fp
   1fc60:	4638      	mov	r0, r7
   1fc62:	f018 f884 	bl	37d6e <log_string_sync>
		pBuffer += read_size;
   1fc66:	44a0      	add	r8, r4
   1fc68:	4654      	mov	r4, sl
   1fc6a:	e7ce      	b.n	1fc0a <SpiFlash_Read+0x66>
   1fc6c:	200242ae 	.word	0x200242ae
   1fc70:	200202cc 	.word	0x200202cc
   1fc74:	200202c4 	.word	0x200202c4
   1fc78:	200202c0 	.word	0x200202c0
   1fc7c:	0003ae28 	.word	0x0003ae28
   1fc80:	0003ade0 	.word	0x0003ade0
   1fc84:	0003ba62 	.word	0x0003ba62
   1fc88:	200202a4 	.word	0x200202a4
   1fc8c:	200202ac 	.word	0x200202ac

0001fc90 <SPI_Flash_Init>:
**   W25Q64FW,CSSPI
**   
** 
******************************************************************************/
void SPI_Flash_Init(void)
{
   1fc90:	b508      	push	{r3, lr}
   1fc92:	480e      	ldr	r0, [pc, #56]	; (1fccc <SPI_Flash_Init+0x3c>)
   1fc94:	f012 fb48 	bl	32328 <z_impl_device_get_binding>
	spi_flash = device_get_binding(FLASH_DEVICE);
   1fc98:	4b0d      	ldr	r3, [pc, #52]	; (1fcd0 <SPI_Flash_Init+0x40>)
   1fc9a:	6018      	str	r0, [r3, #0]
	if (!spi_flash) 
   1fc9c:	b970      	cbnz	r0, 1fcbc <SPI_Flash_Init+0x2c>
	{
		LOG_INF("Could not get %s device\n", FLASH_DEVICE);
   1fc9e:	2303      	movs	r3, #3
   1fca0:	4a0c      	ldr	r2, [pc, #48]	; (1fcd4 <SPI_Flash_Init+0x44>)
   1fca2:	f363 0007 	bfi	r0, r3, #0, #8
   1fca6:	4b0c      	ldr	r3, [pc, #48]	; (1fcd8 <SPI_Flash_Init+0x48>)
   1fca8:	490c      	ldr	r1, [pc, #48]	; (1fcdc <SPI_Flash_Init+0x4c>)
   1fcaa:	1a9b      	subs	r3, r3, r2
   1fcac:	08db      	lsrs	r3, r3, #3
   1fcae:	f363 108f 	bfi	r0, r3, #6, #10
   1fcb2:	4a06      	ldr	r2, [pc, #24]	; (1fccc <SPI_Flash_Init+0x3c>)
	}

	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
	spi_cfg.frequency = 4000000;
	spi_cfg.slave = 0;
}
   1fcb4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		LOG_INF("Could not get %s device\n", FLASH_DEVICE);
   1fcb8:	f018 b859 	b.w	37d6e <log_string_sync>
	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
   1fcbc:	f44f 7280 	mov.w	r2, #256	; 0x100
	spi_cfg.frequency = 4000000;
   1fcc0:	4b07      	ldr	r3, [pc, #28]	; (1fce0 <SPI_Flash_Init+0x50>)
	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
   1fcc2:	4908      	ldr	r1, [pc, #32]	; (1fce4 <SPI_Flash_Init+0x54>)
   1fcc4:	e9c3 1200 	strd	r1, r2, [r3]
}
   1fcc8:	bd08      	pop	{r3, pc}
   1fcca:	bf00      	nop
   1fccc:	0003bc9a 	.word	0x0003bc9a
   1fcd0:	200202c0 	.word	0x200202c0
   1fcd4:	0003ade0 	.word	0x0003ade0
   1fcd8:	0003ae28 	.word	0x0003ae28
   1fcdc:	0003ba27 	.word	0x0003ba27
   1fce0:	200202b4 	.word	0x200202b4
   1fce4:	003d0900 	.word	0x003d0900

0001fce8 <flash_init>:

void flash_init(void)
{
   1fce8:	b538      	push	{r3, r4, r5, lr}
	LOG_INF("flash_init\n");
   1fcea:	f04f 0000 	mov.w	r0, #0
   1fcee:	2303      	movs	r3, #3
   1fcf0:	4c17      	ldr	r4, [pc, #92]	; (1fd50 <flash_init+0x68>)
   1fcf2:	f363 0007 	bfi	r0, r3, #0, #8
   1fcf6:	4b17      	ldr	r3, [pc, #92]	; (1fd54 <flash_init+0x6c>)
   1fcf8:	4917      	ldr	r1, [pc, #92]	; (1fd58 <flash_init+0x70>)
   1fcfa:	1ae4      	subs	r4, r4, r3
   1fcfc:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1fd00:	f364 108f 	bfi	r0, r4, #6, #10
   1fd04:	f018 f833 	bl	37d6e <log_string_sync>
   1fd08:	4814      	ldr	r0, [pc, #80]	; (1fd5c <flash_init+0x74>)
   1fd0a:	f012 fb0d 	bl	32328 <z_impl_device_get_binding>
		
	gpio_flash = device_get_binding(FLASH_PORT);
   1fd0e:	4d14      	ldr	r5, [pc, #80]	; (1fd60 <flash_init+0x78>)
   1fd10:	6028      	str	r0, [r5, #0]
	if(!gpio_flash)
   1fd12:	b958      	cbnz	r0, 1fd2c <flash_init+0x44>
	{
		LOG_INF("Cannot bind gpio device\n");
   1fd14:	2303      	movs	r3, #3
   1fd16:	f04f 0000 	mov.w	r0, #0
   1fd1a:	f363 0007 	bfi	r0, r3, #0, #8
   1fd1e:	f364 108f 	bfi	r0, r4, #6, #10
   1fd22:	4910      	ldr	r1, [pc, #64]	; (1fd64 <flash_init+0x7c>)

	gpio_pin_configure(gpio_flash, CS, GPIO_DIR_OUT);
	gpio_pin_write(gpio_flash, CS, 1);

	SPI_Flash_Init();
}
   1fd24:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		LOG_INF("Cannot bind gpio device\n");
   1fd28:	f018 b821 	b.w	37d6e <log_string_sync>
	return api->config(port, access_op, pin, flags);
   1fd2c:	6843      	ldr	r3, [r0, #4]
   1fd2e:	2202      	movs	r2, #2
   1fd30:	681c      	ldr	r4, [r3, #0]
   1fd32:	2100      	movs	r1, #0
   1fd34:	2301      	movs	r3, #1
   1fd36:	47a0      	blx	r4
	gpio_pin_write(gpio_flash, CS, 1);
   1fd38:	6828      	ldr	r0, [r5, #0]
	return api->write(port, access_op, pin, value);
   1fd3a:	6843      	ldr	r3, [r0, #4]
   1fd3c:	2202      	movs	r2, #2
   1fd3e:	685c      	ldr	r4, [r3, #4]
   1fd40:	2100      	movs	r1, #0
   1fd42:	2301      	movs	r3, #1
   1fd44:	47a0      	blx	r4
}
   1fd46:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	SPI_Flash_Init();
   1fd4a:	f7ff bfa1 	b.w	1fc90 <SPI_Flash_Init>
   1fd4e:	bf00      	nop
   1fd50:	0003ae28 	.word	0x0003ae28
   1fd54:	0003ade0 	.word	0x0003ade0
   1fd58:	0003bca4 	.word	0x0003bca4
   1fd5c:	0003ba01 	.word	0x0003ba01
   1fd60:	200202a0 	.word	0x200202a0
   1fd64:	0003ba08 	.word	0x0003ba08

0001fd68 <ble_connect_or_disconnect_handle>:
extern bool app_find_device;

static void MCU_send_heart_rate(void);

void ble_connect_or_disconnect_handle(u8_t *buf, u32_t len)
{
   1fd68:	b510      	push	{r4, lr}
	LOG_INF("BLE status:%x\n", buf[6]);
   1fd6a:	2303      	movs	r3, #3
{
   1fd6c:	4604      	mov	r4, r0
	LOG_INF("BLE status:%x\n", buf[6]);
   1fd6e:	f04f 0000 	mov.w	r0, #0
   1fd72:	4a09      	ldr	r2, [pc, #36]	; (1fd98 <ble_connect_or_disconnect_handle+0x30>)
   1fd74:	f363 0007 	bfi	r0, r3, #0, #8
   1fd78:	4b08      	ldr	r3, [pc, #32]	; (1fd9c <ble_connect_or_disconnect_handle+0x34>)
   1fd7a:	4909      	ldr	r1, [pc, #36]	; (1fda0 <ble_connect_or_disconnect_handle+0x38>)
   1fd7c:	1a9b      	subs	r3, r3, r2
   1fd7e:	08db      	lsrs	r3, r3, #3
   1fd80:	f363 108f 	bfi	r0, r3, #6, #10
   1fd84:	79a2      	ldrb	r2, [r4, #6]
   1fd86:	f017 fff2 	bl	37d6e <log_string_sync>
	
	if(buf[6] == 0x01)				//control
   1fd8a:	79a2      	ldrb	r2, [r4, #6]
   1fd8c:	4b05      	ldr	r3, [pc, #20]	; (1fda4 <ble_connect_or_disconnect_handle+0x3c>)
   1fd8e:	2a01      	cmp	r2, #1
		BLE_is_connected = true;
	else if(buf[6] == 0x00)
		BLE_is_connected = false;
   1fd90:	bf18      	it	ne
   1fd92:	2200      	movne	r2, #0
   1fd94:	701a      	strb	r2, [r3, #0]
	else
		BLE_is_connected = false;
}
   1fd96:	bd10      	pop	{r4, pc}
   1fd98:	0003ade0 	.word	0x0003ade0
   1fd9c:	0003aef0 	.word	0x0003aef0
   1fda0:	0003bd8a 	.word	0x0003bd8a
   1fda4:	200242b5 	.word	0x200242b5

0001fda8 <CTP_notify_handle>:

void CTP_notify_handle(u8_t *buf, u32_t len)
{
   1fda8:	b530      	push	{r4, r5, lr}
   1fdaa:	b0a5      	sub	sp, #148	; 0x94
   1fdac:	4604      	mov	r4, r0
	u8_t tmpbuf[128] = {0};
   1fdae:	2280      	movs	r2, #128	; 0x80
   1fdb0:	2100      	movs	r1, #0
   1fdb2:	a804      	add	r0, sp, #16
   1fdb4:	f01a f803 	bl	39dbe <memset>
	u8_t tp_type = TP_EVENT_MAX;
	u16_t tp_x,tp_y;
	
	LOG_INF("%x,%x,%x,%x,%x,%x\n",buf[5],buf[6],buf[7],buf[8],buf[9],buf[10]);
   1fdb8:	2303      	movs	r3, #3
   1fdba:	f04f 0000 	mov.w	r0, #0
   1fdbe:	4a2e      	ldr	r2, [pc, #184]	; (1fe78 <CTP_notify_handle+0xd0>)
   1fdc0:	f363 0007 	bfi	r0, r3, #0, #8
   1fdc4:	4b2d      	ldr	r3, [pc, #180]	; (1fe7c <CTP_notify_handle+0xd4>)
   1fdc6:	492e      	ldr	r1, [pc, #184]	; (1fe80 <CTP_notify_handle+0xd8>)
   1fdc8:	1a9b      	subs	r3, r3, r2
   1fdca:	08db      	lsrs	r3, r3, #3
   1fdcc:	f363 108f 	bfi	r0, r3, #6, #10
   1fdd0:	7aa3      	ldrb	r3, [r4, #10]
   1fdd2:	7962      	ldrb	r2, [r4, #5]
   1fdd4:	9303      	str	r3, [sp, #12]
   1fdd6:	7a63      	ldrb	r3, [r4, #9]
   1fdd8:	9302      	str	r3, [sp, #8]
   1fdda:	7a23      	ldrb	r3, [r4, #8]
   1fddc:	9301      	str	r3, [sp, #4]
   1fdde:	79e3      	ldrb	r3, [r4, #7]
   1fde0:	9300      	str	r3, [sp, #0]
   1fde2:	79a3      	ldrb	r3, [r4, #6]
   1fde4:	f017 ffc3 	bl	37d6e <log_string_sync>
	switch(buf[5])
   1fde8:	7965      	ldrb	r5, [r4, #5]
   1fdea:	2d0c      	cmp	r5, #12
   1fdec:	d80c      	bhi.n	1fe08 <CTP_notify_handle+0x60>
   1fdee:	e8df f005 	tbb	[pc, r5]
   1fdf2:	2007      	.short	0x2007
   1fdf4:	312b250d 	.word	0x312b250d
   1fdf8:	0b0b0b0b 	.word	0x0b0b0b0b
   1fdfc:	370b      	.short	0x370b
   1fdfe:	3d          	.byte	0x3d
   1fdff:	00          	.byte	0x00
	{
	case GESTURE_NONE:
		sprintf(tmpbuf, "GESTURE_NONE        ");
   1fe00:	4920      	ldr	r1, [pc, #128]	; (1fe84 <CTP_notify_handle+0xdc>)
   1fe02:	a804      	add	r0, sp, #16
   1fe04:	f01a f944 	bl	3a090 <strcpy>
	{
		tp_x = buf[7]*0x100+buf[8];
		tp_y = buf[9]*0x100+buf[10];
		touch_panel_event_handle(tp_type, tp_x, tp_y);
	}
}
   1fe08:	b025      	add	sp, #148	; 0x94
   1fe0a:	bd30      	pop	{r4, r5, pc}
		sprintf(tmpbuf, "MOVING_UP   ");
   1fe0c:	491e      	ldr	r1, [pc, #120]	; (1fe88 <CTP_notify_handle+0xe0>)
   1fe0e:	a804      	add	r0, sp, #16
   1fe10:	f01a f93e 	bl	3a090 <strcpy>
		tp_type = TP_EVENT_MOVING_UP;
   1fe14:	2500      	movs	r5, #0
		tp_y = buf[9]*0x100+buf[10];
   1fe16:	7a63      	ldrb	r3, [r4, #9]
   1fe18:	7aa2      	ldrb	r2, [r4, #10]
		tp_x = buf[7]*0x100+buf[8];
   1fe1a:	7a21      	ldrb	r1, [r4, #8]
		tp_y = buf[9]*0x100+buf[10];
   1fe1c:	eb02 2203 	add.w	r2, r2, r3, lsl #8
		tp_x = buf[7]*0x100+buf[8];
   1fe20:	79e3      	ldrb	r3, [r4, #7]
		touch_panel_event_handle(tp_type, tp_x, tp_y);
   1fe22:	b292      	uxth	r2, r2
		tp_x = buf[7]*0x100+buf[8];
   1fe24:	eb01 2103 	add.w	r1, r1, r3, lsl #8
		touch_panel_event_handle(tp_type, tp_x, tp_y);
   1fe28:	b289      	uxth	r1, r1
   1fe2a:	4628      	mov	r0, r5
   1fe2c:	f001 fe1c 	bl	21a68 <touch_panel_event_handle>
}
   1fe30:	e7ea      	b.n	1fe08 <CTP_notify_handle+0x60>
		sprintf(tmpbuf, "MOVING_DOWN ");
   1fe32:	4916      	ldr	r1, [pc, #88]	; (1fe8c <CTP_notify_handle+0xe4>)
   1fe34:	a804      	add	r0, sp, #16
   1fe36:	f01a f92b 	bl	3a090 <strcpy>
	if(tp_type != TP_EVENT_MAX)
   1fe3a:	e7ec      	b.n	1fe16 <CTP_notify_handle+0x6e>
		sprintf(tmpbuf, "MOVING_LEFT ");
   1fe3c:	4914      	ldr	r1, [pc, #80]	; (1fe90 <CTP_notify_handle+0xe8>)
   1fe3e:	a804      	add	r0, sp, #16
   1fe40:	f01a f926 	bl	3a090 <strcpy>
		tp_type = TP_EVENT_MOVING_LEFT;
   1fe44:	2502      	movs	r5, #2
   1fe46:	e7e6      	b.n	1fe16 <CTP_notify_handle+0x6e>
		sprintf(tmpbuf, "MOVING_RIGHT");
   1fe48:	4912      	ldr	r1, [pc, #72]	; (1fe94 <CTP_notify_handle+0xec>)
   1fe4a:	a804      	add	r0, sp, #16
   1fe4c:	f01a f920 	bl	3a090 <strcpy>
		tp_type = TP_EVENT_MOVING_RIGHT;
   1fe50:	2503      	movs	r5, #3
   1fe52:	e7e0      	b.n	1fe16 <CTP_notify_handle+0x6e>
		sprintf(tmpbuf, "SINGLE_CLICK");
   1fe54:	4910      	ldr	r1, [pc, #64]	; (1fe98 <CTP_notify_handle+0xf0>)
   1fe56:	a804      	add	r0, sp, #16
   1fe58:	f01a f91a 	bl	3a090 <strcpy>
		tp_type = TP_EVENT_SINGLE_CLICK;
   1fe5c:	2504      	movs	r5, #4
   1fe5e:	e7da      	b.n	1fe16 <CTP_notify_handle+0x6e>
		sprintf(tmpbuf, "DOUBLE_CLICK");
   1fe60:	490e      	ldr	r1, [pc, #56]	; (1fe9c <CTP_notify_handle+0xf4>)
   1fe62:	a804      	add	r0, sp, #16
   1fe64:	f01a f914 	bl	3a090 <strcpy>
		tp_type = TP_EVENT_DOUBLE_CLICK;
   1fe68:	2505      	movs	r5, #5
   1fe6a:	e7d4      	b.n	1fe16 <CTP_notify_handle+0x6e>
		sprintf(tmpbuf, "LONG_PRESS  ");
   1fe6c:	490c      	ldr	r1, [pc, #48]	; (1fea0 <CTP_notify_handle+0xf8>)
   1fe6e:	a804      	add	r0, sp, #16
   1fe70:	f01a f90e 	bl	3a090 <strcpy>
		tp_type = TP_EVENT_LONG_PRESS;
   1fe74:	2506      	movs	r5, #6
   1fe76:	e7ce      	b.n	1fe16 <CTP_notify_handle+0x6e>
   1fe78:	0003ade0 	.word	0x0003ade0
   1fe7c:	0003aef0 	.word	0x0003aef0
   1fe80:	0003bd07 	.word	0x0003bd07
   1fe84:	0003bd1a 	.word	0x0003bd1a
   1fe88:	0003bd2f 	.word	0x0003bd2f
   1fe8c:	0003bd3c 	.word	0x0003bd3c
   1fe90:	0003bd49 	.word	0x0003bd49
   1fe94:	0003bd56 	.word	0x0003bd56
   1fe98:	0003bd63 	.word	0x0003bd63
   1fe9c:	0003bd70 	.word	0x0003bd70
   1fea0:	0003bd7d 	.word	0x0003bd7d

0001fea4 <APP_reply_find_phone>:
	ble_send_date_handle(reply, reply_len);
}

//APP
void APP_reply_find_phone(u8_t *buf, u32_t len)
{
   1fea4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	u32_t i;

	LOG_INF("APP_reply_find_phone\n");
   1fea8:	2303      	movs	r3, #3
{
   1feaa:	4680      	mov	r8, r0
	LOG_INF("APP_reply_find_phone\n");
   1feac:	f04f 0000 	mov.w	r0, #0
   1feb0:	4c12      	ldr	r4, [pc, #72]	; (1fefc <APP_reply_find_phone+0x58>)
   1feb2:	f363 0007 	bfi	r0, r3, #0, #8
   1feb6:	4b12      	ldr	r3, [pc, #72]	; (1ff00 <APP_reply_find_phone+0x5c>)
{
   1feb8:	460f      	mov	r7, r1
	LOG_INF("APP_reply_find_phone\n");
   1feba:	1ae4      	subs	r4, r4, r3
   1febc:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1fec0:	f364 108f 	bfi	r0, r4, #6, #10
   1fec4:	490f      	ldr	r1, [pc, #60]	; (1ff04 <APP_reply_find_phone+0x60>)
   1fec6:	f017 ff52 	bl	37d6e <log_string_sync>
	
	for(i=0;i<len;i++)
   1feca:	2500      	movs	r5, #0
	{
		LOG_INF("i:%d, data:%02X\n", i, buf[i]);
   1fecc:	f8df 9038 	ldr.w	r9, [pc, #56]	; 1ff08 <APP_reply_find_phone+0x64>
	for(i=0;i<len;i++)
   1fed0:	42af      	cmp	r7, r5
   1fed2:	d101      	bne.n	1fed8 <APP_reply_find_phone+0x34>
	}
}
   1fed4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		LOG_INF("i:%d, data:%02X\n", i, buf[i]);
   1fed8:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   1fedc:	f043 0303 	orr.w	r3, r3, #3
   1fee0:	f363 0607 	bfi	r6, r3, #0, #8
   1fee4:	f364 168f 	bfi	r6, r4, #6, #10
   1fee8:	f818 3005 	ldrb.w	r3, [r8, r5]
   1feec:	462a      	mov	r2, r5
   1feee:	4649      	mov	r1, r9
   1fef0:	4630      	mov	r0, r6
   1fef2:	f017 ff3c 	bl	37d6e <log_string_sync>
	for(i=0;i<len;i++)
   1fef6:	3501      	adds	r5, #1
   1fef8:	e7ea      	b.n	1fed0 <APP_reply_find_phone+0x2c>
   1fefa:	bf00      	nop
   1fefc:	0003aef0 	.word	0x0003aef0
   1ff00:	0003ade0 	.word	0x0003ade0
   1ff04:	0003bcbf 	.word	0x0003bcbf
   1ff08:	0003bcd5 	.word	0x0003bcd5

0001ff0c <get_nrf52810_ver_response>:

void get_nrf52810_ver_response(u8_t *buf, u32_t len)
{
	u32_t i;

	for(i=0;i<len-9;i++)
   1ff0c:	4401      	add	r1, r0
   1ff0e:	4a0c      	ldr	r2, [pc, #48]	; (1ff40 <get_nrf52810_ver_response+0x34>)
   1ff10:	1d83      	adds	r3, r0, #6
   1ff12:	3903      	subs	r1, #3
   1ff14:	428b      	cmp	r3, r1
   1ff16:	d10e      	bne.n	1ff36 <get_nrf52810_ver_response+0x2a>
	{
		str_nrf52810_ver[i] = buf[7+i];
	}

	LOG_INF("str_nrf52810_ver:%s\n", str_nrf52810_ver);
   1ff18:	2303      	movs	r3, #3
   1ff1a:	f04f 0000 	mov.w	r0, #0
   1ff1e:	4a09      	ldr	r2, [pc, #36]	; (1ff44 <get_nrf52810_ver_response+0x38>)
   1ff20:	f363 0007 	bfi	r0, r3, #0, #8
   1ff24:	4b08      	ldr	r3, [pc, #32]	; (1ff48 <get_nrf52810_ver_response+0x3c>)
   1ff26:	4909      	ldr	r1, [pc, #36]	; (1ff4c <get_nrf52810_ver_response+0x40>)
   1ff28:	1a9b      	subs	r3, r3, r2
   1ff2a:	08db      	lsrs	r3, r3, #3
   1ff2c:	f363 108f 	bfi	r0, r3, #6, #10
   1ff30:	4a03      	ldr	r2, [pc, #12]	; (1ff40 <get_nrf52810_ver_response+0x34>)
   1ff32:	f017 bf1c 	b.w	37d6e <log_string_sync>
		str_nrf52810_ver[i] = buf[7+i];
   1ff36:	f813 0f01 	ldrb.w	r0, [r3, #1]!
   1ff3a:	f802 0b01 	strb.w	r0, [r2], #1
   1ff3e:	e7e9      	b.n	1ff14 <get_nrf52810_ver_response+0x8>
   1ff40:	200246bc 	.word	0x200246bc
   1ff44:	0003ade0 	.word	0x0003ade0
   1ff48:	0003aef0 	.word	0x0003aef0
   1ff4c:	0003be52 	.word	0x0003be52

0001ff50 <get_ble_mac_address_response>:
}

void get_ble_mac_address_response(u8_t *buf, u32_t len)
{
   1ff50:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   1ff52:	4912      	ldr	r1, [pc, #72]	; (1ff9c <get_ble_mac_address_response+0x4c>)
   1ff54:	1d83      	adds	r3, r0, #6
   1ff56:	460a      	mov	r2, r1
   1ff58:	300c      	adds	r0, #12
	u32_t i;

	for(i=0;i<6;i++)
	{
		ble_mac_addr[i] = buf[7+i];
   1ff5a:	f813 4f01 	ldrb.w	r4, [r3, #1]!
	for(i=0;i<6;i++)
   1ff5e:	4283      	cmp	r3, r0
		ble_mac_addr[i] = buf[7+i];
   1ff60:	f801 4b01 	strb.w	r4, [r1], #1
	for(i=0;i<6;i++)
   1ff64:	d1f9      	bne.n	1ff5a <get_ble_mac_address_response+0xa>
	}

	LOG_INF("ble_mac_addr %02X:%02X:%02X:%02X:%02X:%02X\n",
   1ff66:	2303      	movs	r3, #3
   1ff68:	f04f 0000 	mov.w	r0, #0
   1ff6c:	490c      	ldr	r1, [pc, #48]	; (1ffa0 <get_ble_mac_address_response+0x50>)
   1ff6e:	f363 0007 	bfi	r0, r3, #0, #8
   1ff72:	4b0c      	ldr	r3, [pc, #48]	; (1ffa4 <get_ble_mac_address_response+0x54>)
   1ff74:	1a5b      	subs	r3, r3, r1
   1ff76:	08db      	lsrs	r3, r3, #3
   1ff78:	f363 108f 	bfi	r0, r3, #6, #10
   1ff7c:	7953      	ldrb	r3, [r2, #5]
   1ff7e:	490a      	ldr	r1, [pc, #40]	; (1ffa8 <get_ble_mac_address_response+0x58>)
   1ff80:	9303      	str	r3, [sp, #12]
   1ff82:	7913      	ldrb	r3, [r2, #4]
   1ff84:	9302      	str	r3, [sp, #8]
   1ff86:	78d3      	ldrb	r3, [r2, #3]
   1ff88:	9301      	str	r3, [sp, #4]
   1ff8a:	7893      	ldrb	r3, [r2, #2]
   1ff8c:	9300      	str	r3, [sp, #0]
   1ff8e:	7853      	ldrb	r3, [r2, #1]
   1ff90:	7812      	ldrb	r2, [r2, #0]
   1ff92:	f017 feec 	bl	37d6e <log_string_sync>
							ble_mac_addr[2],
							ble_mac_addr[3],
							ble_mac_addr[4],
							ble_mac_addr[5]
							);
}
   1ff96:	b004      	add	sp, #16
   1ff98:	bd10      	pop	{r4, pc}
   1ff9a:	bf00      	nop
   1ff9c:	200242b6 	.word	0x200242b6
   1ffa0:	0003ade0 	.word	0x0003ade0
   1ffa4:	0003aef0 	.word	0x0003aef0
   1ffa8:	0003be17 	.word	0x0003be17

0001ffac <get_ble_status_response>:

void get_ble_status_response(u8_t *buf, u32_t len)
{
   1ffac:	b510      	push	{r4, lr}
	LOG_INF("BLE_status:%d\n", buf[6]);
   1ffae:	2303      	movs	r3, #3
{
   1ffb0:	4604      	mov	r4, r0
	LOG_INF("BLE_status:%d\n", buf[6]);
   1ffb2:	f04f 0000 	mov.w	r0, #0
   1ffb6:	4a08      	ldr	r2, [pc, #32]	; (1ffd8 <get_ble_status_response+0x2c>)
   1ffb8:	f363 0007 	bfi	r0, r3, #0, #8
   1ffbc:	4b07      	ldr	r3, [pc, #28]	; (1ffdc <get_ble_status_response+0x30>)
   1ffbe:	4908      	ldr	r1, [pc, #32]	; (1ffe0 <get_ble_status_response+0x34>)
   1ffc0:	1a9b      	subs	r3, r3, r2
   1ffc2:	08db      	lsrs	r3, r3, #3
   1ffc4:	f363 108f 	bfi	r0, r3, #6, #10
   1ffc8:	79a2      	ldrb	r2, [r4, #6]
   1ffca:	f017 fed0 	bl	37d6e <log_string_sync>

	g_ble_status = buf[6];
   1ffce:	79a2      	ldrb	r2, [r4, #6]
   1ffd0:	4b04      	ldr	r3, [pc, #16]	; (1ffe4 <get_ble_status_response+0x38>)
   1ffd2:	701a      	strb	r2, [r3, #0]
}
   1ffd4:	bd10      	pop	{r4, pc}
   1ffd6:	bf00      	nop
   1ffd8:	0003ade0 	.word	0x0003ade0
   1ffdc:	0003aef0 	.word	0x0003aef0
   1ffe0:	0003be43 	.word	0x0003be43
   1ffe4:	2002ca3b 	.word	0x2002ca3b

0001ffe8 <ble_send_date_handle>:
		break;
	}
}

void ble_send_date_handle(u8_t *buf, u32_t len)
{
   1ffe8:	b570      	push	{r4, r5, r6, lr}
	LOG_INF("ble_send_date_handle\n");
   1ffea:	2303      	movs	r3, #3
{
   1ffec:	4605      	mov	r5, r0
	LOG_INF("ble_send_date_handle\n");
   1ffee:	f04f 0000 	mov.w	r0, #0
{
   1fff2:	460e      	mov	r6, r1
   1fff4:	4a0a      	ldr	r2, [pc, #40]	; (20020 <__kernel_ram_size+0x20>)
	LOG_INF("ble_send_date_handle\n");
   1fff6:	f363 0007 	bfi	r0, r3, #0, #8
   1fffa:	4b0a      	ldr	r3, [pc, #40]	; (20024 <__kernel_ram_size+0x24>)

	uart_fifo_fill(uart_ble, buf, len);
   1fffc:	4c0a      	ldr	r4, [pc, #40]	; (20028 <__kernel_ram_size+0x28>)
   1fffe:	1a9b      	subs	r3, r3, r2
   20000:	08db      	lsrs	r3, r3, #3
	LOG_INF("ble_send_date_handle\n");
   20002:	f363 108f 	bfi	r0, r3, #6, #10
   20006:	4909      	ldr	r1, [pc, #36]	; (2002c <__kernel_ram_size+0x2c>)
   20008:	f017 feb1 	bl	37d6e <log_string_sync>
	uart_fifo_fill(uart_ble, buf, len);
   2000c:	4632      	mov	r2, r6
   2000e:	4629      	mov	r1, r5
   20010:	6820      	ldr	r0, [r4, #0]
   20012:	f017 fa02 	bl	3741a <uart_fifo_fill>
	uart_irq_tx_enable(uart_ble); 
   20016:	6820      	ldr	r0, [r4, #0]
}
   20018:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		arch_syscall_invoke1(*(uintptr_t *)&dev, K_SYSCALL_UART_IRQ_TX_ENABLE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_tx_enable(dev);
   2001c:	f017 ba03 	b.w	37426 <z_impl_uart_irq_tx_enable>
   20020:	0003ade0 	.word	0x0003ade0
   20024:	0003aef0 	.word	0x0003aef0
   20028:	200202d8 	.word	0x200202d8
   2002c:	0003be01 	.word	0x0003be01

00020030 <APP_set_find_device>:
{
   20030:	b500      	push	{lr}
   20032:	b0a1      	sub	sp, #132	; 0x84
	u8_t reply[128] = {0};
   20034:	2100      	movs	r1, #0
   20036:	2280      	movs	r2, #128	; 0x80
   20038:	4668      	mov	r0, sp
   2003a:	f019 fec0 	bl	39dbe <memset>
	reply[reply_len++] = PACKET_HEAD;
   2003e:	23ab      	movs	r3, #171	; 0xab
   20040:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   20044:	f64f 7306 	movw	r3, #65286	; 0xff06
   20048:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(FIND_DEVICE_ID&0x00ff);
   2004c:	f248 0337 	movw	r3, #32823	; 0x8037
   20050:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   20054:	2388      	movs	r3, #136	; 0x88
   20056:	4669      	mov	r1, sp
   20058:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   2005c:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   2005e:	f811 2b01 	ldrb.w	r2, [r1], #1
   20062:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   20066:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   20068:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   2006a:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   2006c:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   20070:	d1f5      	bne.n	2005e <APP_set_find_device+0x2e>
	ble_send_date_handle(reply, reply_len);
   20072:	2109      	movs	r1, #9
   20074:	4668      	mov	r0, sp
   20076:	f7ff ffb7 	bl	1ffe8 <ble_send_date_handle>
	app_find_device = true;	
   2007a:	2201      	movs	r2, #1
   2007c:	4b02      	ldr	r3, [pc, #8]	; (20088 <APP_set_find_device+0x58>)
   2007e:	701a      	strb	r2, [r3, #0]
}
   20080:	b021      	add	sp, #132	; 0x84
   20082:	f85d fb04 	ldr.w	pc, [sp], #4
   20086:	bf00      	nop
   20088:	200222a2 	.word	0x200222a2

0002008c <APP_set_language>:
{
   2008c:	b510      	push	{r4, lr}
   2008e:	4604      	mov	r4, r0
   20090:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   20092:	2280      	movs	r2, #128	; 0x80
   20094:	2100      	movs	r1, #0
   20096:	4668      	mov	r0, sp
   20098:	f019 fe91 	bl	39dbe <memset>
	if(buf[7] == 0x00)
   2009c:	79e2      	ldrb	r2, [r4, #7]
   2009e:	4b1b      	ldr	r3, [pc, #108]	; (2010c <APP_set_language+0x80>)
   200a0:	bb7a      	cbnz	r2, 20102 <APP_set_language+0x76>
		global_settings.language = LANGUAGE_CHN;
   200a2:	2201      	movs	r2, #1
		global_settings.language = LANGUAGE_JPN;
   200a4:	725a      	strb	r2, [r3, #9]
	reply[reply_len++] = PACKET_HEAD;
   200a6:	23ab      	movs	r3, #171	; 0xab
   200a8:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   200ac:	f64f 7306 	movw	r3, #65286	; 0xff06
   200b0:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(LANGUAGE_SETTING_ID&0x00ff);
   200b4:	f248 0345 	movw	r3, #32837	; 0x8045
   200b8:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   200bc:	2388      	movs	r3, #136	; 0x88
   200be:	4669      	mov	r1, sp
   200c0:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   200c4:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   200c6:	f811 2b01 	ldrb.w	r2, [r1], #1
   200ca:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   200ce:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   200d0:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   200d2:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   200d4:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   200d8:	d1f5      	bne.n	200c6 <APP_set_language+0x3a>
	ble_send_date_handle(reply, reply_len);
   200da:	2109      	movs	r1, #9
   200dc:	4668      	mov	r0, sp
   200de:	f7ff ff83 	bl	1ffe8 <ble_send_date_handle>
	if(screen_id == SCREEN_ID_IDLE)
   200e2:	4b0b      	ldr	r3, [pc, #44]	; (20110 <APP_set_language+0x84>)
   200e4:	781b      	ldrb	r3, [r3, #0]
   200e6:	2b01      	cmp	r3, #1
   200e8:	d106      	bne.n	200f8 <APP_set_language+0x6c>
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_WEEK;
   200ea:	4b0a      	ldr	r3, [pc, #40]	; (20114 <APP_set_language+0x88>)
   200ec:	68da      	ldr	r2, [r3, #12]
   200ee:	f042 0208 	orr.w	r2, r2, #8
   200f2:	60da      	str	r2, [r3, #12]
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   200f4:	2202      	movs	r2, #2
   200f6:	725a      	strb	r2, [r3, #9]
	need_save_settings = true;
   200f8:	2201      	movs	r2, #1
   200fa:	4b07      	ldr	r3, [pc, #28]	; (20118 <APP_set_language+0x8c>)
   200fc:	701a      	strb	r2, [r3, #0]
}
   200fe:	b020      	add	sp, #128	; 0x80
   20100:	bd10      	pop	{r4, pc}
	else if(buf[7] == 0x01)
   20102:	2a02      	cmp	r2, #2
		global_settings.language = LANGUAGE_EN;
   20104:	bf18      	it	ne
   20106:	2200      	movne	r2, #0
   20108:	e7cc      	b.n	200a4 <APP_set_language+0x18>
   2010a:	bf00      	nop
   2010c:	20022242 	.word	0x20022242
   20110:	20024cd9 	.word	0x20024cd9
   20114:	200203c0 	.word	0x200203c0
   20118:	200242ab 	.word	0x200242ab

0002011c <APP_set_time_24_format>:
{
   2011c:	b510      	push	{r4, lr}
   2011e:	4604      	mov	r4, r0
   20120:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   20122:	2280      	movs	r2, #128	; 0x80
   20124:	2100      	movs	r1, #0
   20126:	4668      	mov	r0, sp
   20128:	f019 fe49 	bl	39dbe <memset>
	if(buf[7] == 0x00)
   2012c:	79e2      	ldrb	r2, [r4, #7]
   2012e:	4b19      	ldr	r3, [pc, #100]	; (20194 <APP_set_time_24_format+0x78>)
   20130:	2a01      	cmp	r2, #1
		global_settings.time_format = TIME_FORMAT_24;//24 format
   20132:	bf18      	it	ne
   20134:	2200      	movne	r2, #0
		global_settings.time_format = TIME_FORMAT_12;//12 format
   20136:	721a      	strb	r2, [r3, #8]
	reply[reply_len++] = PACKET_HEAD;
   20138:	23ab      	movs	r3, #171	; 0xab
   2013a:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   2013e:	f64f 7306 	movw	r3, #65286	; 0xff06
   20142:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(TIME_24_SETTING_ID&0x00ff);
   20146:	f248 0346 	movw	r3, #32838	; 0x8046
   2014a:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   2014e:	2388      	movs	r3, #136	; 0x88
   20150:	4669      	mov	r1, sp
   20152:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   20156:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   20158:	f811 2b01 	ldrb.w	r2, [r1], #1
   2015c:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   20160:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   20162:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   20164:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   20166:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   2016a:	d1f5      	bne.n	20158 <APP_set_time_24_format+0x3c>
	ble_send_date_handle(reply, reply_len);
   2016c:	2109      	movs	r1, #9
   2016e:	4668      	mov	r0, sp
   20170:	f7ff ff3a 	bl	1ffe8 <ble_send_date_handle>
	if(screen_id == SCREEN_ID_IDLE)
   20174:	4b08      	ldr	r3, [pc, #32]	; (20198 <APP_set_time_24_format+0x7c>)
   20176:	781b      	ldrb	r3, [r3, #0]
   20178:	2b01      	cmp	r3, #1
   2017a:	d106      	bne.n	2018a <APP_set_time_24_format+0x6e>
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_TIME;
   2017c:	4b07      	ldr	r3, [pc, #28]	; (2019c <APP_set_time_24_format+0x80>)
   2017e:	68da      	ldr	r2, [r3, #12]
   20180:	f042 0202 	orr.w	r2, r2, #2
   20184:	60da      	str	r2, [r3, #12]
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   20186:	2202      	movs	r2, #2
   20188:	725a      	strb	r2, [r3, #9]
	need_save_settings = true;	
   2018a:	2201      	movs	r2, #1
   2018c:	4b04      	ldr	r3, [pc, #16]	; (201a0 <APP_set_time_24_format+0x84>)
   2018e:	701a      	strb	r2, [r3, #0]
}
   20190:	b020      	add	sp, #128	; 0x80
   20192:	bd10      	pop	{r4, pc}
   20194:	20022242 	.word	0x20022242
   20198:	20024cd9 	.word	0x20024cd9
   2019c:	200203c0 	.word	0x200203c0
   201a0:	200242ab 	.word	0x200242ab

000201a4 <APP_set_date_format>:
{
   201a4:	b510      	push	{r4, lr}
   201a6:	4604      	mov	r4, r0
   201a8:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   201aa:	2280      	movs	r2, #128	; 0x80
   201ac:	2100      	movs	r1, #0
   201ae:	4668      	mov	r0, sp
   201b0:	f019 fe05 	bl	39dbe <memset>
	if(buf[7] == 0x00)
   201b4:	79e3      	ldrb	r3, [r4, #7]
   201b6:	4a1b      	ldr	r2, [pc, #108]	; (20224 <APP_set_date_format+0x80>)
   201b8:	bb7b      	cbnz	r3, 2021a <APP_set_date_format+0x76>
		global_settings.date_format = DATE_FORMAT_YYYYMMDD;
   201ba:	2300      	movs	r3, #0
		global_settings.date_format = DATE_FORMAT_DDMMYYYY;
   201bc:	7293      	strb	r3, [r2, #10]
	reply[reply_len++] = PACKET_HEAD;
   201be:	23ab      	movs	r3, #171	; 0xab
   201c0:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   201c4:	f64f 7306 	movw	r3, #65286	; 0xff06
   201c8:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(DATE_FORMAT_ID&0x00ff);
   201cc:	f248 0356 	movw	r3, #32854	; 0x8056
   201d0:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   201d4:	2388      	movs	r3, #136	; 0x88
   201d6:	4669      	mov	r1, sp
   201d8:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   201dc:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   201de:	f811 2b01 	ldrb.w	r2, [r1], #1
   201e2:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   201e6:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   201e8:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   201ea:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   201ec:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   201f0:	d1f5      	bne.n	201de <APP_set_date_format+0x3a>
	ble_send_date_handle(reply, reply_len);
   201f2:	2109      	movs	r1, #9
   201f4:	4668      	mov	r0, sp
   201f6:	f7ff fef7 	bl	1ffe8 <ble_send_date_handle>
	if(screen_id == SCREEN_ID_IDLE)
   201fa:	4b0b      	ldr	r3, [pc, #44]	; (20228 <APP_set_date_format+0x84>)
   201fc:	781b      	ldrb	r3, [r3, #0]
   201fe:	2b01      	cmp	r3, #1
   20200:	d106      	bne.n	20210 <APP_set_date_format+0x6c>
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_DATE;
   20202:	4b0a      	ldr	r3, [pc, #40]	; (2022c <APP_set_date_format+0x88>)
   20204:	68da      	ldr	r2, [r3, #12]
   20206:	f042 0204 	orr.w	r2, r2, #4
   2020a:	60da      	str	r2, [r3, #12]
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   2020c:	2202      	movs	r2, #2
   2020e:	725a      	strb	r2, [r3, #9]
	need_save_settings = true;
   20210:	2201      	movs	r2, #1
   20212:	4b07      	ldr	r3, [pc, #28]	; (20230 <APP_set_date_format+0x8c>)
   20214:	701a      	strb	r2, [r3, #0]
}
   20216:	b020      	add	sp, #128	; 0x80
   20218:	bd10      	pop	{r4, pc}
	else if(buf[7] == 0x01)
   2021a:	2b01      	cmp	r3, #1
   2021c:	d0ce      	beq.n	201bc <APP_set_date_format+0x18>
	else if(buf[7] == 0x02)
   2021e:	2b02      	cmp	r3, #2
   20220:	d1cb      	bne.n	201ba <APP_set_date_format+0x16>
   20222:	e7cb      	b.n	201bc <APP_set_date_format+0x18>
   20224:	20022242 	.word	0x20022242
   20228:	20024cd9 	.word	0x20024cd9
   2022c:	200203c0 	.word	0x200203c0
   20230:	200242ab 	.word	0x200242ab

00020234 <APP_set_date_time>:
{
   20234:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   20238:	4604      	mov	r4, r0
   2023a:	b0a2      	sub	sp, #136	; 0x88
	u8_t reply[128] = {0};
   2023c:	2100      	movs	r1, #0
   2023e:	2280      	movs	r2, #128	; 0x80
   20240:	a802      	add	r0, sp, #8
   20242:	f019 fdbc 	bl	39dbe <memset>
	datetime.year = 256*buf[7]+buf[8];
   20246:	79e3      	ldrb	r3, [r4, #7]
   20248:	7a25      	ldrb	r5, [r4, #8]
	datetime.month = buf[9];
   2024a:	f894 9009 	ldrb.w	r9, [r4, #9]
	datetime.year = 256*buf[7]+buf[8];
   2024e:	eb05 2503 	add.w	r5, r5, r3, lsl #8
	if(CheckSystemDateTimeIsValid(datetime))
   20252:	2300      	movs	r3, #0
	datetime.day = buf[10];
   20254:	f894 800a 	ldrb.w	r8, [r4, #10]
	datetime.hour = buf[11];
   20258:	7ae7      	ldrb	r7, [r4, #11]
	datetime.minute = buf[12];
   2025a:	7b26      	ldrb	r6, [r4, #12]
	datetime.second = buf[13];
   2025c:	f894 a00d 	ldrb.w	sl, [r4, #13]
	if(CheckSystemDateTimeIsValid(datetime))
   20260:	466c      	mov	r4, sp
	datetime.year = 256*buf[7]+buf[8];
   20262:	b2ad      	uxth	r5, r5
	if(CheckSystemDateTimeIsValid(datetime))
   20264:	f8ad 5000 	strh.w	r5, [sp]
   20268:	f88d 9002 	strb.w	r9, [sp, #2]
   2026c:	f88d 8003 	strb.w	r8, [sp, #3]
   20270:	f88d 7004 	strb.w	r7, [sp, #4]
   20274:	f88d 6005 	strb.w	r6, [sp, #5]
   20278:	f88d a006 	strb.w	sl, [sp, #6]
   2027c:	f88d 3007 	strb.w	r3, [sp, #7]
   20280:	e894 0003 	ldmia.w	r4, {r0, r1}
   20284:	f016 fffd 	bl	37282 <CheckSystemDateTimeIsValid>
   20288:	b1e0      	cbz	r0, 202c4 <APP_set_date_time+0x90>
		datetime.week = GetWeekDayByDate(datetime);
   2028a:	e894 0003 	ldmia.w	r4, {r0, r1}
   2028e:	f016 ffa0 	bl	371d2 <GetWeekDayByDate>
		memcpy(&date_time, &datetime, sizeof(sys_date_timer_t));
   20292:	4b1a      	ldr	r3, [pc, #104]	; (202fc <APP_set_date_time+0xc8>)
   20294:	801d      	strh	r5, [r3, #0]
   20296:	f883 9002 	strb.w	r9, [r3, #2]
   2029a:	f883 8003 	strb.w	r8, [r3, #3]
   2029e:	711f      	strb	r7, [r3, #4]
   202a0:	715e      	strb	r6, [r3, #5]
   202a2:	f883 a006 	strb.w	sl, [r3, #6]
		datetime.week = GetWeekDayByDate(datetime);
   202a6:	71d8      	strb	r0, [r3, #7]
		if(screen_id == SCREEN_ID_IDLE)
   202a8:	4b15      	ldr	r3, [pc, #84]	; (20300 <APP_set_date_time+0xcc>)
   202aa:	781b      	ldrb	r3, [r3, #0]
   202ac:	2b01      	cmp	r3, #1
   202ae:	d106      	bne.n	202be <APP_set_date_time+0x8a>
			scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_TIME|SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);
   202b0:	4b14      	ldr	r3, [pc, #80]	; (20304 <APP_set_date_time+0xd0>)
   202b2:	68da      	ldr	r2, [r3, #12]
   202b4:	f042 020e 	orr.w	r2, r2, #14
   202b8:	60da      	str	r2, [r3, #12]
			scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   202ba:	2202      	movs	r2, #2
   202bc:	725a      	strb	r2, [r3, #9]
		need_save_time = true;
   202be:	2201      	movs	r2, #1
   202c0:	4b11      	ldr	r3, [pc, #68]	; (20308 <APP_set_date_time+0xd4>)
   202c2:	701a      	strb	r2, [r3, #0]
	reply[reply_len++] = (u8_t)(TIME_SYNC_ID&0x00ff);
   202c4:	f248 0349 	movw	r3, #32841	; 0x8049
   202c8:	4a10      	ldr	r2, [pc, #64]	; (2030c <APP_set_date_time+0xd8>)
   202ca:	a902      	add	r1, sp, #8
   202cc:	e9cd 2302 	strd	r2, r3, [sp, #8]
	reply[reply_len++] = PACKET_END;
   202d0:	2388      	movs	r3, #136	; 0x88
   202d2:	f88d 3010 	strb.w	r3, [sp, #16]
	for(i=0;i<(reply_len-2);i++)
   202d6:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   202d8:	f811 2b01 	ldrb.w	r2, [r1], #1
   202dc:	f89d 000f 	ldrb.w	r0, [sp, #15]
	for(i=0;i<(reply_len-2);i++)
   202e0:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   202e2:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   202e4:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   202e6:	f88d 200f 	strb.w	r2, [sp, #15]
	for(i=0;i<(reply_len-2);i++)
   202ea:	d1f5      	bne.n	202d8 <APP_set_date_time+0xa4>
	ble_send_date_handle(reply, reply_len);	
   202ec:	2109      	movs	r1, #9
   202ee:	a802      	add	r0, sp, #8
   202f0:	f7ff fe7a 	bl	1ffe8 <ble_send_date_handle>
}
   202f4:	b022      	add	sp, #136	; 0x88
   202f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   202fa:	bf00      	nop
   202fc:	20022230 	.word	0x20022230
   20300:	20024cd9 	.word	0x20024cd9
   20304:	200203c0 	.word	0x200203c0
   20308:	200242ac 	.word	0x200242ac
   2030c:	ff0600ab 	.word	0xff0600ab

00020310 <APP_set_alarm>:
{
   20310:	b510      	push	{r4, lr}
   20312:	b0a2      	sub	sp, #136	; 0x88
   20314:	4604      	mov	r4, r0
	u8_t result=0,reply[128] = {0};
   20316:	2280      	movs	r2, #128	; 0x80
   20318:	2100      	movs	r1, #0
   2031a:	a802      	add	r0, sp, #8
   2031c:	f019 fd4f 	bl	39dbe <memset>
	alarm_infor_t infor = {0};
   20320:	2300      	movs	r3, #0
   20322:	9301      	str	r3, [sp, #4]
	index = buf[7];
   20324:	79e3      	ldrb	r3, [r4, #7]
	if(index <= 7)
   20326:	2b07      	cmp	r3, #7
   20328:	d921      	bls.n	2036e <APP_set_alarm+0x5e>
	u8_t result=0,reply[128] = {0};
   2032a:	2300      	movs	r3, #0
	reply[reply_len++] = PACKET_HEAD;
   2032c:	22ab      	movs	r2, #171	; 0xab
   2032e:	f88d 2008 	strb.w	r2, [sp, #8]
	reply[reply_len++] = 0x06;
   20332:	f64f 7206 	movw	r2, #65286	; 0xff06
	reply[reply_len++] = result;
   20336:	f88d 300d 	strb.w	r3, [sp, #13]
	reply[reply_len++] = PACKET_END;
   2033a:	2388      	movs	r3, #136	; 0x88
	reply[reply_len++] = 0x06;
   2033c:	f8ad 200a 	strh.w	r2, [sp, #10]
	reply[reply_len++] = (u8_t)(ALARM_SETTING_ID&0x00ff);
   20340:	2239      	movs	r2, #57	; 0x39
	reply[reply_len++] = PACKET_END;
   20342:	f88d 3010 	strb.w	r3, [sp, #16]
	for(i=0;i<(reply_len-2);i++)
   20346:	2300      	movs	r3, #0
	reply[reply_len++] = (u8_t)(ALARM_SETTING_ID&0x00ff);
   20348:	f88d 200c 	strb.w	r2, [sp, #12]
	for(i=0;i<(reply_len-2);i++)
   2034c:	a902      	add	r1, sp, #8
		reply[reply_len-2] += reply[i];
   2034e:	f811 2b01 	ldrb.w	r2, [r1], #1
   20352:	f89d 000f 	ldrb.w	r0, [sp, #15]
	for(i=0;i<(reply_len-2);i++)
   20356:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   20358:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   2035a:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   2035c:	f88d 200f 	strb.w	r2, [sp, #15]
	for(i=0;i<(reply_len-2);i++)
   20360:	d1f5      	bne.n	2034e <APP_set_alarm+0x3e>
	ble_send_date_handle(reply, reply_len);	
   20362:	2109      	movs	r1, #9
   20364:	a802      	add	r0, sp, #8
   20366:	f7ff fe3f 	bl	1ffe8 <ble_send_date_handle>
}
   2036a:	b022      	add	sp, #136	; 0x88
   2036c:	bd10      	pop	{r4, pc}
		infor.is_on = buf[8];	//on\off
   2036e:	7a22      	ldrb	r2, [r4, #8]
		infor.hour = buf[9];	//hour
   20370:	7a60      	ldrb	r0, [r4, #9]
		infor.is_on = buf[8];	//on\off
   20372:	3200      	adds	r2, #0
   20374:	bf18      	it	ne
   20376:	2201      	movne	r2, #1
		infor.minute = buf[10];//minute
   20378:	7aa1      	ldrb	r1, [r4, #10]
		infor.is_on = buf[8];	//on\off
   2037a:	f88d 2004 	strb.w	r2, [sp, #4]
		infor.repeat = buf[11];//repeat from monday to sunday, for example:0x1111100 means repeat in workday
   2037e:	7ae2      	ldrb	r2, [r4, #11]
		if((buf[9]<=23)&&(buf[10]<=59)&&(buf[11]<=0x7f))
   20380:	2817      	cmp	r0, #23
		infor.hour = buf[9];	//hour
   20382:	f88d 0005 	strb.w	r0, [sp, #5]
		infor.minute = buf[10];//minute
   20386:	f88d 1006 	strb.w	r1, [sp, #6]
		infor.repeat = buf[11];//repeat from monday to sunday, for example:0x1111100 means repeat in workday
   2038a:	f88d 2007 	strb.w	r2, [sp, #7]
		if((buf[9]<=23)&&(buf[10]<=59)&&(buf[11]<=0x7f))
   2038e:	d8cc      	bhi.n	2032a <APP_set_alarm+0x1a>
   20390:	293b      	cmp	r1, #59	; 0x3b
   20392:	d8ca      	bhi.n	2032a <APP_set_alarm+0x1a>
   20394:	0612      	lsls	r2, r2, #24
   20396:	d4c8      	bmi.n	2032a <APP_set_alarm+0x1a>
__ ## fun ## _ichk(type1 __restrict dst, type2 __restrict src) { \
	return __builtin___ ## fun ## _chk(dst, src, __ssp_bos0(dst)); \
}

__BEGIN_DECLS
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   20398:	4a04      	ldr	r2, [pc, #16]	; (203ac <APP_set_alarm+0x9c>)
   2039a:	9901      	ldr	r1, [sp, #4]
			memcpy((alarm_infor_t*)&global_settings.alarm[index], (alarm_infor_t*)&infor, sizeof(alarm_infor_t));
   2039c:	3304      	adds	r3, #4
   2039e:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
			need_save_settings = true;
   203a2:	2201      	movs	r2, #1
   203a4:	4b02      	ldr	r3, [pc, #8]	; (203b0 <APP_set_alarm+0xa0>)
   203a6:	701a      	strb	r2, [r3, #0]
			result = 0x80;
   203a8:	2380      	movs	r3, #128	; 0x80
   203aa:	e7bf      	b.n	2032c <APP_set_alarm+0x1c>
   203ac:	20022242 	.word	0x20022242
   203b0:	200242ab 	.word	0x200242ab

000203b4 <APP_set_PHD_interval>:
{
   203b4:	b510      	push	{r4, lr}
   203b6:	4604      	mov	r4, r0
   203b8:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   203ba:	2280      	movs	r2, #128	; 0x80
   203bc:	2100      	movs	r1, #0
   203be:	4668      	mov	r0, sp
   203c0:	f019 fcfd 	bl	39dbe <memset>
	if(buf[6] == 1)
   203c4:	79a3      	ldrb	r3, [r4, #6]
   203c6:	4a16      	ldr	r2, [pc, #88]	; (20420 <APP_set_PHD_interval+0x6c>)
   203c8:	1e59      	subs	r1, r3, #1
   203ca:	424b      	negs	r3, r1
   203cc:	414b      	adcs	r3, r1
   203ce:	7393      	strb	r3, [r2, #14]
	global_settings.phd_infor.interval = buf[7];
   203d0:	79e3      	ldrb	r3, [r4, #7]
	need_save_settings = true;
   203d2:	4c14      	ldr	r4, [pc, #80]	; (20424 <APP_set_PHD_interval+0x70>)
	global_settings.phd_infor.interval = buf[7];
   203d4:	73d3      	strb	r3, [r2, #15]
	need_save_settings = true;
   203d6:	2201      	movs	r2, #1
   203d8:	7022      	strb	r2, [r4, #0]
	reply[reply_len++] = PACKET_HEAD;
   203da:	22ab      	movs	r2, #171	; 0xab
   203dc:	f88d 2000 	strb.w	r2, [sp]
	reply[reply_len++] = 0x06;
   203e0:	f64f 7206 	movw	r2, #65286	; 0xff06
   203e4:	f8ad 2002 	strh.w	r2, [sp, #2]
	reply[reply_len++] = (u8_t)(MEASURE_HOURLY_ID&0x00ff);
   203e8:	f248 0243 	movw	r2, #32835	; 0x8043
   203ec:	f8ad 2004 	strh.w	r2, [sp, #4]
	reply[reply_len++] = PACKET_END;
   203f0:	2288      	movs	r2, #136	; 0x88
   203f2:	4669      	mov	r1, sp
   203f4:	f88d 2008 	strb.w	r2, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   203f8:	2200      	movs	r2, #0
		reply[reply_len-2] += reply[i];
   203fa:	f811 3b01 	ldrb.w	r3, [r1], #1
   203fe:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   20402:	3201      	adds	r2, #1
		reply[reply_len-2] += reply[i];
   20404:	4403      	add	r3, r0
	for(i=0;i<(reply_len-2);i++)
   20406:	2a07      	cmp	r2, #7
		reply[reply_len-2] += reply[i];
   20408:	f88d 3007 	strb.w	r3, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   2040c:	d1f5      	bne.n	203fa <APP_set_PHD_interval+0x46>
	ble_send_date_handle(reply, reply_len);
   2040e:	2109      	movs	r1, #9
   20410:	4668      	mov	r0, sp
   20412:	f7ff fde9 	bl	1ffe8 <ble_send_date_handle>
	need_save_settings = true;	
   20416:	2301      	movs	r3, #1
   20418:	7023      	strb	r3, [r4, #0]
}
   2041a:	b020      	add	sp, #128	; 0x80
   2041c:	bd10      	pop	{r4, pc}
   2041e:	bf00      	nop
   20420:	20022242 	.word	0x20022242
   20424:	200242ab 	.word	0x200242ab

00020428 <APP_set_wake_screen_by_wrist>:
{
   20428:	b510      	push	{r4, lr}
   2042a:	4604      	mov	r4, r0
   2042c:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   2042e:	2280      	movs	r2, #128	; 0x80
   20430:	2100      	movs	r1, #0
   20432:	4668      	mov	r0, sp
   20434:	f019 fcc3 	bl	39dbe <memset>
	if(buf[6] == 1)
   20438:	79a3      	ldrb	r3, [r4, #6]
   2043a:	4669      	mov	r1, sp
   2043c:	1e5a      	subs	r2, r3, #1
   2043e:	4253      	negs	r3, r2
   20440:	4153      	adcs	r3, r2
   20442:	4a12      	ldr	r2, [pc, #72]	; (2048c <APP_set_wake_screen_by_wrist+0x64>)
   20444:	7113      	strb	r3, [r2, #4]
	reply[reply_len++] = PACKET_HEAD;
   20446:	23ab      	movs	r3, #171	; 0xab
   20448:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   2044c:	f64f 7306 	movw	r3, #65286	; 0xff06
   20450:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(SHAKE_SCREEN_ID&0x00ff);
   20454:	f248 0342 	movw	r3, #32834	; 0x8042
   20458:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   2045c:	2388      	movs	r3, #136	; 0x88
   2045e:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   20462:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   20464:	f811 2b01 	ldrb.w	r2, [r1], #1
   20468:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   2046c:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   2046e:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   20470:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   20472:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   20476:	d1f5      	bne.n	20464 <APP_set_wake_screen_by_wrist+0x3c>
	ble_send_date_handle(reply, reply_len);
   20478:	2109      	movs	r1, #9
   2047a:	4668      	mov	r0, sp
   2047c:	f7ff fdb4 	bl	1ffe8 <ble_send_date_handle>
	need_save_settings = true;
   20480:	2201      	movs	r2, #1
   20482:	4b03      	ldr	r3, [pc, #12]	; (20490 <APP_set_wake_screen_by_wrist+0x68>)
   20484:	701a      	strb	r2, [r3, #0]
}
   20486:	b020      	add	sp, #128	; 0x80
   20488:	bd10      	pop	{r4, pc}
   2048a:	bf00      	nop
   2048c:	20022242 	.word	0x20022242
   20490:	200242ab 	.word	0x200242ab

00020494 <APP_set_factory_reset>:
{
   20494:	b500      	push	{lr}
   20496:	b0a1      	sub	sp, #132	; 0x84
	u8_t reply[128] = {0};
   20498:	2100      	movs	r1, #0
   2049a:	2280      	movs	r2, #128	; 0x80
   2049c:	4668      	mov	r0, sp
   2049e:	f019 fc8e 	bl	39dbe <memset>
	reply[reply_len++] = PACKET_HEAD;
   204a2:	23ab      	movs	r3, #171	; 0xab
   204a4:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   204a8:	f64f 7306 	movw	r3, #65286	; 0xff06
   204ac:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(FACTORY_RESET_ID&0x00ff);
   204b0:	f248 0353 	movw	r3, #32851	; 0x8053
   204b4:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   204b8:	2388      	movs	r3, #136	; 0x88
   204ba:	4669      	mov	r1, sp
   204bc:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   204c0:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   204c2:	f811 2b01 	ldrb.w	r2, [r1], #1
   204c6:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   204ca:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   204cc:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   204ce:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   204d0:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   204d4:	d1f5      	bne.n	204c2 <APP_set_factory_reset+0x2e>
	ble_send_date_handle(reply, reply_len);
   204d6:	2109      	movs	r1, #9
   204d8:	4668      	mov	r0, sp
   204da:	f7ff fd85 	bl	1ffe8 <ble_send_date_handle>
	need_reset_settings = true;
   204de:	2201      	movs	r2, #1
   204e0:	4b02      	ldr	r3, [pc, #8]	; (204ec <APP_set_factory_reset+0x58>)
   204e2:	701a      	strb	r2, [r3, #0]
}
   204e4:	b021      	add	sp, #132	; 0x84
   204e6:	f85d fb04 	ldr.w	pc, [sp], #4
   204ea:	bf00      	nop
   204ec:	200242aa 	.word	0x200242aa

000204f0 <APP_set_target_steps>:
{
   204f0:	b510      	push	{r4, lr}
   204f2:	b0a0      	sub	sp, #128	; 0x80
   204f4:	4604      	mov	r4, r0
	u8_t reply[128] = {0};
   204f6:	2280      	movs	r2, #128	; 0x80
   204f8:	2100      	movs	r1, #0
   204fa:	4668      	mov	r0, sp
   204fc:	f019 fc5f 	bl	39dbe <memset>
	LOG_INF("APP_set_target_steps: %02X,%02X\n", buf[7], buf[8]);
   20500:	2303      	movs	r3, #3
   20502:	f04f 0000 	mov.w	r0, #0
   20506:	4a1a      	ldr	r2, [pc, #104]	; (20570 <APP_set_target_steps+0x80>)
   20508:	f363 0007 	bfi	r0, r3, #0, #8
   2050c:	4b19      	ldr	r3, [pc, #100]	; (20574 <APP_set_target_steps+0x84>)
   2050e:	491a      	ldr	r1, [pc, #104]	; (20578 <APP_set_target_steps+0x88>)
   20510:	1a9b      	subs	r3, r3, r2
   20512:	08db      	lsrs	r3, r3, #3
   20514:	f363 108f 	bfi	r0, r3, #6, #10
   20518:	79e2      	ldrb	r2, [r4, #7]
   2051a:	7a23      	ldrb	r3, [r4, #8]
   2051c:	f017 fc27 	bl	37d6e <log_string_sync>
	global_settings.target_steps = buf[7]*100+buf[8];
   20520:	79e3      	ldrb	r3, [r4, #7]
   20522:	7a22      	ldrb	r2, [r4, #8]
   20524:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   20528:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   2052c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   20530:	4a12      	ldr	r2, [pc, #72]	; (2057c <APP_set_target_steps+0x8c>)
   20532:	4669      	mov	r1, sp
   20534:	80d3      	strh	r3, [r2, #6]
	reply[reply_len++] = (u8_t)(TARGET_STEPS_ID&0x00ff);
   20536:	f248 0350 	movw	r3, #32848	; 0x8050
   2053a:	4a11      	ldr	r2, [pc, #68]	; (20580 <APP_set_target_steps+0x90>)
   2053c:	e9cd 2300 	strd	r2, r3, [sp]
	reply[reply_len++] = PACKET_END;
   20540:	2388      	movs	r3, #136	; 0x88
   20542:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   20546:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   20548:	f811 2b01 	ldrb.w	r2, [r1], #1
   2054c:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   20550:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   20552:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   20554:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   20556:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   2055a:	d1f5      	bne.n	20548 <APP_set_target_steps+0x58>
	ble_send_date_handle(reply, reply_len);
   2055c:	2109      	movs	r1, #9
   2055e:	4668      	mov	r0, sp
   20560:	f7ff fd42 	bl	1ffe8 <ble_send_date_handle>
	need_save_settings = true;
   20564:	2201      	movs	r2, #1
   20566:	4b07      	ldr	r3, [pc, #28]	; (20584 <APP_set_target_steps+0x94>)
   20568:	701a      	strb	r2, [r3, #0]
}
   2056a:	b020      	add	sp, #128	; 0x80
   2056c:	bd10      	pop	{r4, pc}
   2056e:	bf00      	nop
   20570:	0003ade0 	.word	0x0003ade0
   20574:	0003aef0 	.word	0x0003aef0
   20578:	0003bce6 	.word	0x0003bce6
   2057c:	20022242 	.word	0x20022242
   20580:	ff0600ab 	.word	0xff0600ab
   20584:	200242ab 	.word	0x200242ab

00020588 <APP_get_current_data>:
{
   20588:	b500      	push	{lr}
   2058a:	b0c5      	sub	sp, #276	; 0x114
	u8_t wake,reply[128] = {0};
   2058c:	2280      	movs	r2, #128	; 0x80
   2058e:	2100      	movs	r1, #0
   20590:	a804      	add	r0, sp, #16
   20592:	f019 fc14 	bl	39dbe <memset>
	GetSportData(&steps, &calorie, &distance);
   20596:	f10d 020a 	add.w	r2, sp, #10
   2059a:	a902      	add	r1, sp, #8
   2059c:	f10d 0006 	add.w	r0, sp, #6
   205a0:	f001 fa8a 	bl	21ab8 <GetSportData>
	GetSleepTimeData(&deep_sleep, &light_sleep);
   205a4:	a903      	add	r1, sp, #12
   205a6:	f10d 000e 	add.w	r0, sp, #14
   205aa:	f001 fa95 	bl	21ad8 <GetSleepTimeData>
	reply[reply_len++] = (steps>>8);
   205ae:	f8bd 2006 	ldrh.w	r2, [sp, #6]
	reply[reply_len++] = PACKET_HEAD;
   205b2:	4b3f      	ldr	r3, [pc, #252]	; (206b0 <APP_get_current_data+0x128>)
	reply[reply_len++] = (steps>>8);
   205b4:	0a11      	lsrs	r1, r2, #8
	reply[reply_len++] = (u8_t)(steps&0x00ff);
   205b6:	f88d 2018 	strb.w	r2, [sp, #24]
	reply[reply_len++] = (calorie>>8);
   205ba:	f8bd 2008 	ldrh.w	r2, [sp, #8]
	reply[reply_len++] = (steps>>8);
   205be:	f88d 1017 	strb.w	r1, [sp, #23]
	reply[reply_len++] = (u8_t)(calorie&0x00ff);
   205c2:	f88d 201a 	strb.w	r2, [sp, #26]
	reply[reply_len++] = (calorie>>8);
   205c6:	0a11      	lsrs	r1, r2, #8
	reply[reply_len++] = (distance>>8);
   205c8:	f8bd 200a 	ldrh.w	r2, [sp, #10]
	reply[reply_len++] = (calorie>>8);
   205cc:	f88d 1019 	strb.w	r1, [sp, #25]
	reply[reply_len++] = (u8_t)(distance&0x00ff);
   205d0:	f88d 201c 	strb.w	r2, [sp, #28]
	reply[reply_len++] = (distance>>8);
   205d4:	0a11      	lsrs	r1, r2, #8
	reply[reply_len++] = (light_sleep>>8);
   205d6:	f8bd 200c 	ldrh.w	r2, [sp, #12]
	reply[reply_len++] = (distance>>8);
   205da:	f88d 101b 	strb.w	r1, [sp, #27]
	reply[reply_len++] = (u8_t)(light_sleep&0x00ff);
   205de:	f88d 201e 	strb.w	r2, [sp, #30]
	reply[reply_len++] = (light_sleep>>8);
   205e2:	0a11      	lsrs	r1, r2, #8
	reply[reply_len++] = (deep_sleep>>8);
   205e4:	f8bd 200e 	ldrh.w	r2, [sp, #14]
	reply[reply_len++] = PACKET_HEAD;
   205e8:	9304      	str	r3, [sp, #16]
	reply[reply_len++] = (light_sleep>>8);
   205ea:	f88d 101d 	strb.w	r1, [sp, #29]
	reply[reply_len++] = (u8_t)(PULL_REFRESH_ID&0x00ff);
   205ee:	f248 0335 	movw	r3, #32821	; 0x8035
	reply[reply_len++] = (deep_sleep>>8);
   205f2:	0a11      	lsrs	r1, r2, #8
	reply[reply_len++] = (u8_t)(deep_sleep&0x00ff);
   205f4:	f88d 2020 	strb.w	r2, [sp, #32]
	reply[reply_len++] = wake;
   205f8:	2208      	movs	r2, #8
	reply[reply_len++] = (u8_t)(PULL_REFRESH_ID&0x00ff);
   205fa:	f8ad 3014 	strh.w	r3, [sp, #20]
	reply[reply_len++] = wake;
   205fe:	f88d 2021 	strb.w	r2, [sp, #33]	; 0x21
	reply[reply_len++] = 0x00;
   20602:	2300      	movs	r3, #0
	reply[reply_len++] = 0x00;
   20604:	f44f 4208 	mov.w	r2, #34816	; 0x8800
	reply[reply_len++] = (deep_sleep>>8);
   20608:	f88d 101f 	strb.w	r1, [sp, #31]
	reply[reply_len++] = 0x00;
   2060c:	f88d 3016 	strb.w	r3, [sp, #22]
	reply[reply_len++] = 0x00;
   20610:	f8ad 2022 	strh.w	r2, [sp, #34]	; 0x22
	for(i=0;i<(reply_len-2);i++)
   20614:	a904      	add	r1, sp, #16
		reply[reply_len-2] += reply[i];
   20616:	f811 2b01 	ldrb.w	r2, [r1], #1
   2061a:	f89d 0022 	ldrb.w	r0, [sp, #34]	; 0x22
	for(i=0;i<(reply_len-2);i++)
   2061e:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   20620:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   20622:	2b12      	cmp	r3, #18
		reply[reply_len-2] += reply[i];
   20624:	f88d 2022 	strb.w	r2, [sp, #34]	; 0x22
	for(i=0;i<(reply_len-2);i++)
   20628:	d1f5      	bne.n	20616 <APP_get_current_data+0x8e>
	ble_send_date_handle(reply, reply_len);
   2062a:	2114      	movs	r1, #20
   2062c:	a804      	add	r0, sp, #16
   2062e:	f7ff fcdb 	bl	1ffe8 <ble_send_date_handle>
	u8_t heart_rate,reply[128] = {0};
   20632:	2280      	movs	r2, #128	; 0x80
   20634:	2100      	movs	r1, #0
   20636:	a824      	add	r0, sp, #144	; 0x90
   20638:	f019 fbc1 	bl	39dbe <memset>
	GetHeartRate(&heart_rate);
   2063c:	f10d 0005 	add.w	r0, sp, #5
   20640:	f017 f88f 	bl	37762 <GetHeartRate>
	reply[reply_len++] = PACKET_HEAD;
   20644:	4b1b      	ldr	r3, [pc, #108]	; (206b4 <APP_get_current_data+0x12c>)
	reply[reply_len++] = (u8_t)(date_time.year>>8);
   20646:	4a1c      	ldr	r2, [pc, #112]	; (206b8 <APP_get_current_data+0x130>)
	reply[reply_len++] = PACKET_HEAD;
   20648:	9324      	str	r3, [sp, #144]	; 0x90
	reply[reply_len++] = (u8_t)(PULL_REFRESH_ID&0x00ff);
   2064a:	f248 1335 	movw	r3, #33077	; 0x8135
	reply[reply_len++] = (u8_t)(date_time.year>>8);
   2064e:	8811      	ldrh	r1, [r2, #0]
	reply[reply_len++] = (u8_t)(PULL_REFRESH_ID&0x00ff);
   20650:	f8ad 3094 	strh.w	r3, [sp, #148]	; 0x94
	reply[reply_len++] = (u8_t)(date_time.year>>8);
   20654:	0a08      	lsrs	r0, r1, #8
	reply[reply_len++] = (u8_t)(date_time.year&0x00ff);
   20656:	f88d 1098 	strb.w	r1, [sp, #152]	; 0x98
	reply[reply_len++] = date_time.month;
   2065a:	7891      	ldrb	r1, [r2, #2]
	reply[reply_len++] = 0x00;
   2065c:	2300      	movs	r3, #0
	reply[reply_len++] = date_time.month;
   2065e:	f88d 1099 	strb.w	r1, [sp, #153]	; 0x99
	reply[reply_len++] = date_time.day;
   20662:	78d1      	ldrb	r1, [r2, #3]
	reply[reply_len++] = 0x00;
   20664:	f88d 3096 	strb.w	r3, [sp, #150]	; 0x96
	reply[reply_len++] = date_time.day;
   20668:	f88d 109a 	strb.w	r1, [sp, #154]	; 0x9a
	reply[reply_len++] = date_time.hour;
   2066c:	7911      	ldrb	r1, [r2, #4]
	reply[reply_len++] = date_time.minute;
   2066e:	7952      	ldrb	r2, [r2, #5]
	reply[reply_len++] = date_time.hour;
   20670:	f88d 109b 	strb.w	r1, [sp, #155]	; 0x9b
	reply[reply_len++] = date_time.minute;
   20674:	f88d 209c 	strb.w	r2, [sp, #156]	; 0x9c
	reply[reply_len++] = heart_rate;
   20678:	f89d 2005 	ldrb.w	r2, [sp, #5]
	reply[reply_len++] = (u8_t)(date_time.year>>8);
   2067c:	f88d 0097 	strb.w	r0, [sp, #151]	; 0x97
	reply[reply_len++] = heart_rate;
   20680:	f88d 209d 	strb.w	r2, [sp, #157]	; 0x9d
	reply[reply_len++] = 0x00;
   20684:	f44f 4208 	mov.w	r2, #34816	; 0x8800
   20688:	a924      	add	r1, sp, #144	; 0x90
   2068a:	f8ad 209e 	strh.w	r2, [sp, #158]	; 0x9e
		reply[reply_len-2] += reply[i];
   2068e:	f811 2b01 	ldrb.w	r2, [r1], #1
   20692:	f89d 009e 	ldrb.w	r0, [sp, #158]	; 0x9e
	for(i=0;i<(reply_len-2);i++)
   20696:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   20698:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   2069a:	2b0e      	cmp	r3, #14
		reply[reply_len-2] += reply[i];
   2069c:	f88d 209e 	strb.w	r2, [sp, #158]	; 0x9e
	for(i=0;i<(reply_len-2);i++)
   206a0:	d1f5      	bne.n	2068e <APP_get_current_data+0x106>
	ble_send_date_handle(reply, reply_len);	
   206a2:	2110      	movs	r1, #16
   206a4:	a824      	add	r0, sp, #144	; 0x90
   206a6:	f7ff fc9f 	bl	1ffe8 <ble_send_date_handle>
}
   206aa:	b045      	add	sp, #276	; 0x114
   206ac:	f85d fb04 	ldr.w	pc, [sp], #4
   206b0:	ff1100ab 	.word	0xff1100ab
   206b4:	ff0d00ab 	.word	0xff0d00ab
   206b8:	20022230 	.word	0x20022230

000206bc <APP_get_battery_level>:
{
   206bc:	b570      	push	{r4, r5, r6, lr}
   206be:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   206c0:	2280      	movs	r2, #128	; 0x80
   206c2:	2100      	movs	r1, #0
   206c4:	4668      	mov	r0, sp
   206c6:	f019 fb7a 	bl	39dbe <memset>
	reply[reply_len++] = PACKET_HEAD;
   206ca:	23ab      	movs	r3, #171	; 0xab
   206cc:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x07;
   206d0:	f64f 7307 	movw	r3, #65287	; 0xff07
   206d4:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(BATTERY_LEVEL_ID&0x00ff);
   206d8:	2351      	movs	r3, #81	; 0x51
   206da:	f88d 3004 	strb.w	r3, [sp, #4]
	switch(g_chg_status)
   206de:	4b16      	ldr	r3, [pc, #88]	; (20738 <APP_get_battery_level+0x7c>)
   206e0:	781b      	ldrb	r3, [r3, #0]
   206e2:	b123      	cbz	r3, 206ee <APP_get_battery_level+0x32>
   206e4:	2b02      	cmp	r3, #2
   206e6:	d825      	bhi.n	20734 <APP_get_battery_level+0x78>
		reply[reply_len++] = 0x01;
   206e8:	2301      	movs	r3, #1
   206ea:	f88d 3005 	strb.w	r3, [sp, #5]
		reply[reply_len++] = 0x00;
   206ee:	2106      	movs	r1, #6
	reply[reply_len++] = 0x00;
   206f0:	ab20      	add	r3, sp, #128	; 0x80
   206f2:	1858      	adds	r0, r3, r1
	reply[reply_len++] = PACKET_END;
   206f4:	2588      	movs	r5, #136	; 0x88
	reply[reply_len++] = 0x00;
   206f6:	2300      	movs	r3, #0
	reply[reply_len++] = g_bat_soc;
   206f8:	4a10      	ldr	r2, [pc, #64]	; (2073c <APP_get_battery_level+0x80>)
   206fa:	1c8c      	adds	r4, r1, #2
   206fc:	7812      	ldrb	r2, [r2, #0]
	reply[reply_len++] = 0x00;
   206fe:	f800 3c80 	strb.w	r3, [r0, #-128]
	reply[reply_len++] = g_bat_soc;
   20702:	f800 2c7f 	strb.w	r2, [r0, #-127]
	reply[reply_len++] = 0x00;
   20706:	aa20      	add	r2, sp, #128	; 0x80
   20708:	4422      	add	r2, r4
   2070a:	f802 3c80 	strb.w	r3, [r2, #-128]
	reply[reply_len++] = PACKET_END;
   2070e:	f800 5c7d 	strb.w	r5, [r0, #-125]
   20712:	466d      	mov	r5, sp
   20714:	3104      	adds	r1, #4
		reply[reply_len-2] += reply[i];
   20716:	f815 0b01 	ldrb.w	r0, [r5], #1
   2071a:	f812 6c80 	ldrb.w	r6, [r2, #-128]
	for(i=0;i<(reply_len-2);i++)
   2071e:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   20720:	4430      	add	r0, r6
	for(i=0;i<(reply_len-2);i++)
   20722:	429c      	cmp	r4, r3
		reply[reply_len-2] += reply[i];
   20724:	f802 0c80 	strb.w	r0, [r2, #-128]
	for(i=0;i<(reply_len-2);i++)
   20728:	d8f5      	bhi.n	20716 <APP_get_battery_level+0x5a>
	ble_send_date_handle(reply, reply_len);
   2072a:	4668      	mov	r0, sp
   2072c:	f7ff fc5c 	bl	1ffe8 <ble_send_date_handle>
}
   20730:	b020      	add	sp, #128	; 0x80
   20732:	bd70      	pop	{r4, r5, r6, pc}
	reply[reply_len++] = (u8_t)(BATTERY_LEVEL_ID&0x00ff);
   20734:	2105      	movs	r1, #5
   20736:	e7db      	b.n	206f0 <APP_get_battery_level+0x34>
   20738:	20024cdc 	.word	0x20024cdc
   2073c:	20024cdb 	.word	0x20024cdb

00020740 <APP_get_heart_rate>:
{
   20740:	b500      	push	{lr}
   20742:	b0a3      	sub	sp, #140	; 0x8c
	u8_t heart_rate,reply[128] = {0};
   20744:	2100      	movs	r1, #0
   20746:	2280      	movs	r2, #128	; 0x80
   20748:	a802      	add	r0, sp, #8
   2074a:	f019 fb38 	bl	39dbe <memset>
	GetHeartRate(&heart_rate);
   2074e:	f10d 0007 	add.w	r0, sp, #7
   20752:	f017 f806 	bl	37762 <GetHeartRate>
	reply[reply_len++] = PACKET_HEAD;
   20756:	4b12      	ldr	r3, [pc, #72]	; (207a0 <APP_get_heart_rate+0x60>)
   20758:	a902      	add	r1, sp, #8
   2075a:	9302      	str	r3, [sp, #8]
	reply[reply_len++] = (u8_t)(HEART_RATE_ID&0x00ff);
   2075c:	f240 2331 	movw	r3, #561	; 0x231
   20760:	f8ad 300c 	strh.w	r3, [sp, #12]
	reply[reply_len++] = 0x01;
   20764:	2301      	movs	r3, #1
   20766:	f88d 300e 	strb.w	r3, [sp, #14]
	reply[reply_len++] = heart_rate;	//V2.0
   2076a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   2076e:	f88d 300f 	strb.w	r3, [sp, #15]
	reply[reply_len++] = 0x00;
   20772:	f44f 4308 	mov.w	r3, #34816	; 0x8800
   20776:	f8ad 3010 	strh.w	r3, [sp, #16]
	for(i=0;i<(reply_len-2);i++)
   2077a:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   2077c:	f811 2b01 	ldrb.w	r2, [r1], #1
   20780:	f89d 0010 	ldrb.w	r0, [sp, #16]
	for(i=0;i<(reply_len-2);i++)
   20784:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   20786:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   20788:	2b08      	cmp	r3, #8
		reply[reply_len-2] += reply[i];
   2078a:	f88d 2010 	strb.w	r2, [sp, #16]
	for(i=0;i<(reply_len-2);i++)
   2078e:	d1f5      	bne.n	2077c <APP_get_heart_rate+0x3c>
	ble_send_date_handle(reply, reply_len);
   20790:	210a      	movs	r1, #10
   20792:	a802      	add	r0, sp, #8
   20794:	f7ff fc28 	bl	1ffe8 <ble_send_date_handle>
}
   20798:	b023      	add	sp, #140	; 0x8c
   2079a:	f85d fb04 	ldr.w	pc, [sp], #4
   2079e:	bf00      	nop
   207a0:	ff0700ab 	.word	0xff0700ab

000207a4 <ble_receive_date_handle>:
{
   207a4:	b430      	push	{r4, r5}
	if((buf[0] != PACKET_HEAD) || (buf[len-1] != PACKET_END))	//format is error
   207a6:	7802      	ldrb	r2, [r0, #0]
   207a8:	1843      	adds	r3, r0, r1
   207aa:	2aab      	cmp	r2, #171	; 0xab
   207ac:	f813 3c01 	ldrb.w	r3, [r3, #-1]
   207b0:	d101      	bne.n	207b6 <ble_receive_date_handle+0x12>
   207b2:	2b88      	cmp	r3, #136	; 0x88
   207b4:	d024      	beq.n	20800 <ble_receive_date_handle+0x5c>
		LOG_INF("format is error! HEAD:%x, END:%x\n", buf[0], buf[len-1]);
   207b6:	2103      	movs	r1, #3
   207b8:	f04f 0000 	mov.w	r0, #0
   207bc:	4c6a      	ldr	r4, [pc, #424]	; (20968 <ble_receive_date_handle+0x1c4>)
   207be:	f361 0007 	bfi	r0, r1, #0, #8
   207c2:	496a      	ldr	r1, [pc, #424]	; (2096c <ble_receive_date_handle+0x1c8>)
   207c4:	1b09      	subs	r1, r1, r4
   207c6:	08c9      	lsrs	r1, r1, #3
   207c8:	f361 108f 	bfi	r0, r1, #6, #10
   207cc:	4968      	ldr	r1, [pc, #416]	; (20970 <ble_receive_date_handle+0x1cc>)
}
   207ce:	bc30      	pop	{r4, r5}
		LOG_INF("CRC is error! data:%x, CRC:%x\n", buf[len-2], CRC_data);
   207d0:	f017 bacd 	b.w	37d6e <log_string_sync>
		CRC_data = CRC_data+buf[i];
   207d4:	5c85      	ldrb	r5, [r0, r2]
	for(i=0;i<len-2;i++)
   207d6:	3201      	adds	r2, #1
		CRC_data = CRC_data+buf[i];
   207d8:	442b      	add	r3, r5
   207da:	b2db      	uxtb	r3, r3
	for(i=0;i<len-2;i++)
   207dc:	42a2      	cmp	r2, r4
   207de:	d3f9      	bcc.n	207d4 <ble_receive_date_handle+0x30>
	if(CRC_data != buf[len-2])									//crc is error
   207e0:	5d02      	ldrb	r2, [r0, r4]
   207e2:	4293      	cmp	r3, r2
   207e4:	d010      	beq.n	20808 <ble_receive_date_handle+0x64>
		LOG_INF("CRC is error! data:%x, CRC:%x\n", buf[len-2], CRC_data);
   207e6:	2103      	movs	r1, #3
   207e8:	f04f 0000 	mov.w	r0, #0
   207ec:	4c5e      	ldr	r4, [pc, #376]	; (20968 <ble_receive_date_handle+0x1c4>)
   207ee:	f361 0007 	bfi	r0, r1, #0, #8
   207f2:	495e      	ldr	r1, [pc, #376]	; (2096c <ble_receive_date_handle+0x1c8>)
   207f4:	1b09      	subs	r1, r1, r4
   207f6:	08c9      	lsrs	r1, r1, #3
   207f8:	f361 108f 	bfi	r0, r1, #6, #10
   207fc:	495d      	ldr	r1, [pc, #372]	; (20974 <ble_receive_date_handle+0x1d0>)
   207fe:	e7e6      	b.n	207ce <ble_receive_date_handle+0x2a>
	for(i=0;i<len-2;i++)
   20800:	2200      	movs	r2, #0
   20802:	1e8c      	subs	r4, r1, #2
	u8_t CRC_data=0,data_status;
   20804:	4613      	mov	r3, r2
   20806:	e7e9      	b.n	207dc <ble_receive_date_handle+0x38>
	data_ID = buf[3]*256+buf[4];
   20808:	78c2      	ldrb	r2, [r0, #3]
   2080a:	7903      	ldrb	r3, [r0, #4]
   2080c:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	switch(data_ID)
   20810:	f64f 7247 	movw	r2, #65351	; 0xff47
	data_ID = buf[3]*256+buf[4];
   20814:	b29b      	uxth	r3, r3
	switch(data_ID)
   20816:	4293      	cmp	r3, r2
   20818:	f000 8088 	beq.w	2092c <ble_receive_date_handle+0x188>
   2081c:	d83b      	bhi.n	20896 <ble_receive_date_handle+0xf2>
   2081e:	f64f 7239 	movw	r2, #65337	; 0xff39
   20822:	4293      	cmp	r3, r2
   20824:	d079      	beq.n	2091a <ble_receive_date_handle+0x176>
   20826:	d81e      	bhi.n	20866 <ble_receive_date_handle+0xc2>
   20828:	f64f 7235 	movw	r2, #65333	; 0xff35
   2082c:	4293      	cmp	r3, r2
   2082e:	d06e      	beq.n	2090e <ble_receive_date_handle+0x16a>
   20830:	d813      	bhi.n	2085a <ble_receive_date_handle+0xb6>
   20832:	f64f 7231 	movw	r2, #65329	; 0xff31
   20836:	4293      	cmp	r3, r2
   20838:	d066      	beq.n	20908 <ble_receive_date_handle+0x164>
   2083a:	d212      	bcs.n	20862 <ble_receive_date_handle+0xbe>
}
   2083c:	bc30      	pop	{r4, r5}
		LOG_INF("data_id is unknown! \n");
   2083e:	2303      	movs	r3, #3
   20840:	f04f 0000 	mov.w	r0, #0
   20844:	4a48      	ldr	r2, [pc, #288]	; (20968 <ble_receive_date_handle+0x1c4>)
   20846:	f363 0007 	bfi	r0, r3, #0, #8
   2084a:	4b48      	ldr	r3, [pc, #288]	; (2096c <ble_receive_date_handle+0x1c8>)
   2084c:	494a      	ldr	r1, [pc, #296]	; (20978 <ble_receive_date_handle+0x1d4>)
   2084e:	1a9b      	subs	r3, r3, r2
   20850:	08db      	lsrs	r3, r3, #3
   20852:	f363 108f 	bfi	r0, r3, #6, #10
   20856:	f017 ba8a 	b.w	37d6e <log_string_sync>
	switch(data_ID)
   2085a:	f64f 7237 	movw	r2, #65335	; 0xff37
   2085e:	4293      	cmp	r3, r2
   20860:	d058      	beq.n	20914 <ble_receive_date_handle+0x170>
}
   20862:	bc30      	pop	{r4, r5}
   20864:	4770      	bx	lr
	switch(data_ID)
   20866:	f64f 7243 	movw	r2, #65347	; 0xff43
   2086a:	4293      	cmp	r3, r2
   2086c:	d058      	beq.n	20920 <ble_receive_date_handle+0x17c>
   2086e:	d80a      	bhi.n	20886 <ble_receive_date_handle+0xe2>
   20870:	f64f 7240 	movw	r2, #65344	; 0xff40
   20874:	4293      	cmp	r3, r2
   20876:	d3e1      	bcc.n	2083c <ble_receive_date_handle+0x98>
   20878:	f64f 7241 	movw	r2, #65345	; 0xff41
   2087c:	4293      	cmp	r3, r2
   2087e:	d9f0      	bls.n	20862 <ble_receive_date_handle+0xbe>
}
   20880:	bc30      	pop	{r4, r5}
		APP_set_wake_screen_by_wrist(buf, len);
   20882:	f7ff bdd1 	b.w	20428 <APP_set_wake_screen_by_wrist>
	switch(data_ID)
   20886:	f64f 7245 	movw	r2, #65349	; 0xff45
   2088a:	4293      	cmp	r3, r2
   2088c:	d04b      	beq.n	20926 <ble_receive_date_handle+0x182>
   2088e:	d9e8      	bls.n	20862 <ble_receive_date_handle+0xbe>
}
   20890:	bc30      	pop	{r4, r5}
		APP_set_time_24_format(buf, len);
   20892:	f7ff bc43 	b.w	2011c <APP_set_time_24_format>
	switch(data_ID)
   20896:	f64f 7255 	movw	r2, #65365	; 0xff55
   2089a:	4293      	cmp	r3, r2
   2089c:	d052      	beq.n	20944 <ble_receive_date_handle+0x1a0>
   2089e:	d818      	bhi.n	208d2 <ble_receive_date_handle+0x12e>
   208a0:	f64f 7251 	movw	r2, #65361	; 0xff51
   208a4:	4293      	cmp	r3, r2
   208a6:	d047      	beq.n	20938 <ble_receive_date_handle+0x194>
   208a8:	d80b      	bhi.n	208c2 <ble_receive_date_handle+0x11e>
   208aa:	f64f 7249 	movw	r2, #65353	; 0xff49
   208ae:	4293      	cmp	r3, r2
   208b0:	d03f      	beq.n	20932 <ble_receive_date_handle+0x18e>
   208b2:	d3d6      	bcc.n	20862 <ble_receive_date_handle+0xbe>
   208b4:	f64f 7250 	movw	r2, #65360	; 0xff50
   208b8:	4293      	cmp	r3, r2
   208ba:	d1bf      	bne.n	2083c <ble_receive_date_handle+0x98>
}
   208bc:	bc30      	pop	{r4, r5}
		APP_set_target_steps(buf, len);
   208be:	f7ff be17 	b.w	204f0 <APP_set_target_steps>
	switch(data_ID)
   208c2:	f64f 7253 	movw	r2, #65363	; 0xff53
   208c6:	4293      	cmp	r3, r2
   208c8:	d039      	beq.n	2093e <ble_receive_date_handle+0x19a>
   208ca:	d8ca      	bhi.n	20862 <ble_receive_date_handle+0xbe>
}
   208cc:	bc30      	pop	{r4, r5}
		APP_get_firmware_version(buf, len);
   208ce:	f016 be0f 	b.w	374f0 <APP_get_firmware_version>
	switch(data_ID)
   208d2:	f64f 72b2 	movw	r2, #65458	; 0xffb2
   208d6:	4293      	cmp	r3, r2
   208d8:	d03d      	beq.n	20956 <ble_receive_date_handle+0x1b2>
   208da:	d80b      	bhi.n	208f4 <ble_receive_date_handle+0x150>
   208dc:	f64f 72b0 	movw	r2, #65456	; 0xffb0
   208e0:	4293      	cmp	r3, r2
   208e2:	d032      	beq.n	2094a <ble_receive_date_handle+0x1a6>
   208e4:	d834      	bhi.n	20950 <ble_receive_date_handle+0x1ac>
   208e6:	f64f 7256 	movw	r2, #65366	; 0xff56
   208ea:	4293      	cmp	r3, r2
   208ec:	d1a6      	bne.n	2083c <ble_receive_date_handle+0x98>
}
   208ee:	bc30      	pop	{r4, r5}
		APP_set_date_format(buf, len);
   208f0:	f7ff bc58 	b.w	201a4 <APP_set_date_format>
	switch(data_ID)
   208f4:	f64f 72b4 	movw	r2, #65460	; 0xffb4
   208f8:	4293      	cmp	r3, r2
   208fa:	d032      	beq.n	20962 <ble_receive_date_handle+0x1be>
   208fc:	d32e      	bcc.n	2095c <ble_receive_date_handle+0x1b8>
   208fe:	f64f 72b5 	movw	r2, #65461	; 0xffb5
   20902:	4293      	cmp	r3, r2
   20904:	d19a      	bne.n	2083c <ble_receive_date_handle+0x98>
   20906:	e7ac      	b.n	20862 <ble_receive_date_handle+0xbe>
}
   20908:	bc30      	pop	{r4, r5}
		APP_get_heart_rate(buf, len);
   2090a:	f7ff bf19 	b.w	20740 <APP_get_heart_rate>
}
   2090e:	bc30      	pop	{r4, r5}
		APP_get_current_data(buf, len);
   20910:	f7ff be3a 	b.w	20588 <APP_get_current_data>
}
   20914:	bc30      	pop	{r4, r5}
		APP_set_find_device(buf, len);
   20916:	f7ff bb8b 	b.w	20030 <APP_set_find_device>
}
   2091a:	bc30      	pop	{r4, r5}
		APP_set_alarm(buf, len);
   2091c:	f7ff bcf8 	b.w	20310 <APP_set_alarm>
}
   20920:	bc30      	pop	{r4, r5}
		APP_set_PHD_interval(buf, len);
   20922:	f7ff bd47 	b.w	203b4 <APP_set_PHD_interval>
}
   20926:	bc30      	pop	{r4, r5}
		APP_set_language(buf, len);
   20928:	f7ff bbb0 	b.w	2008c <APP_set_language>
}
   2092c:	bc30      	pop	{r4, r5}
		APP_reply_find_phone(buf, len);
   2092e:	f7ff bab9 	b.w	1fea4 <APP_reply_find_phone>
}
   20932:	bc30      	pop	{r4, r5}
		APP_set_date_time(buf, len);
   20934:	f7ff bc7e 	b.w	20234 <APP_set_date_time>
}
   20938:	bc30      	pop	{r4, r5}
		APP_get_battery_level(buf, len);
   2093a:	f7ff bebf 	b.w	206bc <APP_get_battery_level>
}
   2093e:	bc30      	pop	{r4, r5}
		APP_set_factory_reset(buf, len);
   20940:	f7ff bda8 	b.w	20494 <APP_set_factory_reset>
}
   20944:	bc30      	pop	{r4, r5}
	APP_Ask_GPS_Data();
   20946:	f000 b9ed 	b.w	20d24 <APP_Ask_GPS_Data>
}
   2094a:	bc30      	pop	{r4, r5}
		ble_connect_or_disconnect_handle(buf, len);
   2094c:	f7ff ba0c 	b.w	1fd68 <ble_connect_or_disconnect_handle>
}
   20950:	bc30      	pop	{r4, r5}
		CTP_notify_handle(buf, len);
   20952:	f7ff ba29 	b.w	1fda8 <CTP_notify_handle>
}
   20956:	bc30      	pop	{r4, r5}
		get_nrf52810_ver_response(buf, len);
   20958:	f7ff bad8 	b.w	1ff0c <get_nrf52810_ver_response>
}
   2095c:	bc30      	pop	{r4, r5}
		get_ble_mac_address_response(buf, len);
   2095e:	f7ff baf7 	b.w	1ff50 <get_ble_mac_address_response>
}
   20962:	bc30      	pop	{r4, r5}
		get_ble_status_response(buf, len);
   20964:	f7ff bb22 	b.w	1ffac <get_ble_status_response>
   20968:	0003ade0 	.word	0x0003ade0
   2096c:	0003aef0 	.word	0x0003aef0
   20970:	0003bdaa 	.word	0x0003bdaa
   20974:	0003bdcc 	.word	0x0003bdcc
   20978:	0003bdeb 	.word	0x0003bdeb

0002097c <uart_cb>:
	uart_irq_tx_enable(uart_ble); 
}

static void uart_cb(struct device *x)
{
	u8_t tmpbyte = 0;
   2097c:	2300      	movs	r3, #0
{
   2097e:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   20982:	4604      	mov	r4, r0
	u8_t tmpbyte = 0;
   20984:	f88d 3007 	strb.w	r3, [sp, #7]
static inline int z_impl_uart_irq_update(struct device *dev)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	if (api->irq_update) {
   20988:	6843      	ldr	r3, [r0, #4]
   2098a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   2098c:	b103      	cbz	r3, 20990 <uart_cb+0x14>
		return api->irq_update(dev);
   2098e:	4798      	blx	r3
	if (api->irq_rx_ready) {
   20990:	6863      	ldr	r3, [r4, #4]
   20992:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   20994:	b933      	cbnz	r3, 209a4 <uart_cb+0x28>
	if (api->irq_tx_ready) {
   20996:	6863      	ldr	r3, [r4, #4]
   20998:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   2099a:	2b00      	cmp	r3, #0
   2099c:	d14c      	bne.n	20a38 <uart_cb+0xbc>
			uart_irq_tx_disable(x);
		}

		k_free(buf);
	}
}
   2099e:	b002      	add	sp, #8
   209a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return api->irq_rx_ready(dev);
   209a4:	4620      	mov	r0, r4
   209a6:	4798      	blx	r3
	if(uart_irq_rx_ready(x)) 
   209a8:	2800      	cmp	r0, #0
   209aa:	d0f4      	beq.n	20996 <uart_cb+0x1a>
   209ac:	4d39      	ldr	r5, [pc, #228]	; (20a94 <uart_cb+0x118>)
	LOG_INF("uart_rece:%02X\n", data);
   209ae:	4b3a      	ldr	r3, [pc, #232]	; (20a98 <uart_cb+0x11c>)
   209b0:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 20aa8 <uart_cb+0x12c>
   209b4:	1aed      	subs	r5, r5, r3
   209b6:	4e39      	ldr	r6, [pc, #228]	; (20a9c <uart_cb+0x120>)
   209b8:	f3c5 05c9 	ubfx	r5, r5, #3, #10
		memset(rx_buf, 0, sizeof(rx_buf));
   209bc:	4f38      	ldr	r7, [pc, #224]	; (20aa0 <uart_cb+0x124>)
	if (api->fifo_read) {
   209be:	6863      	ldr	r3, [r4, #4]
   209c0:	699b      	ldr	r3, [r3, #24]
   209c2:	2b00      	cmp	r3, #0
   209c4:	d0e7      	beq.n	20996 <uart_cb+0x1a>
		return api->fifo_read(dev, rx_data, size);
   209c6:	2201      	movs	r2, #1
   209c8:	f10d 0107 	add.w	r1, sp, #7
   209cc:	4620      	mov	r0, r4
   209ce:	4798      	blx	r3
		while((len = uart_fifo_read(x, &tmpbyte, 1)) > 0)
   209d0:	2800      	cmp	r0, #0
   209d2:	d0e0      	beq.n	20996 <uart_cb+0x1a>
	LOG_INF("uart_rece:%02X\n", data);
   209d4:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   209d8:	f043 0303 	orr.w	r3, r3, #3
			uart_receive_data(tmpbyte, 1);
   209dc:	f89d a007 	ldrb.w	sl, [sp, #7]
	LOG_INF("uart_rece:%02X\n", data);
   209e0:	f363 0807 	bfi	r8, r3, #0, #8
   209e4:	f365 188f 	bfi	r8, r5, #6, #10
   209e8:	4652      	mov	r2, sl
   209ea:	4649      	mov	r1, r9
   209ec:	4640      	mov	r0, r8
   209ee:	f017 f9be 	bl	37d6e <log_string_sync>
	if(data == 0xAB)
   209f2:	f1ba 0fab 	cmp.w	sl, #171	; 0xab
   209f6:	d107      	bne.n	20a08 <uart_cb+0x8c>
		memset(rx_buf, 0, sizeof(rx_buf));
   209f8:	f44f 6280 	mov.w	r2, #1024	; 0x400
   209fc:	2100      	movs	r1, #0
   209fe:	4638      	mov	r0, r7
   20a00:	f019 f9dd 	bl	39dbe <memset>
		rece_len = 0;
   20a04:	2300      	movs	r3, #0
   20a06:	6033      	str	r3, [r6, #0]
	rx_buf[rece_len++] = data;
   20a08:	6833      	ldr	r3, [r6, #0]
   20a0a:	f807 a003 	strb.w	sl, [r7, r3]
   20a0e:	1c59      	adds	r1, r3, #1
	if(rece_len == (256*rx_buf[1]+rx_buf[2]+3))	//receivive complete
   20a10:	78bb      	ldrb	r3, [r7, #2]
   20a12:	787a      	ldrb	r2, [r7, #1]
   20a14:	3303      	adds	r3, #3
   20a16:	eb03 2302 	add.w	r3, r3, r2, lsl #8
   20a1a:	4299      	cmp	r1, r3
	rx_buf[rece_len++] = data;
   20a1c:	6031      	str	r1, [r6, #0]
	if(rece_len == (256*rx_buf[1]+rx_buf[2]+3))	//receivive complete
   20a1e:	d1ce      	bne.n	209be <uart_cb+0x42>
		ble_receive_date_handle(rx_buf, rece_len);
   20a20:	481f      	ldr	r0, [pc, #124]	; (20aa0 <uart_cb+0x124>)
   20a22:	f7ff febf 	bl	207a4 <ble_receive_date_handle>
		memset(rx_buf, 0, sizeof(rx_buf));
   20a26:	f44f 6280 	mov.w	r2, #1024	; 0x400
   20a2a:	2100      	movs	r1, #0
   20a2c:	481c      	ldr	r0, [pc, #112]	; (20aa0 <uart_cb+0x124>)
   20a2e:	f019 f9c6 	bl	39dbe <memset>
		rece_len = 0;
   20a32:	2300      	movs	r3, #0
   20a34:	6033      	str	r3, [r6, #0]
   20a36:	e7c1      	b.n	209bc <uart_cb+0x40>
		return api->irq_tx_ready(dev);
   20a38:	4620      	mov	r0, r4
   20a3a:	4798      	blx	r3
	if(uart_irq_tx_ready(x))
   20a3c:	2800      	cmp	r0, #0
   20a3e:	d0ae      	beq.n	2099e <uart_cb+0x22>
	return z_impl_k_queue_get(queue, timeout);
   20a40:	2100      	movs	r1, #0
   20a42:	4818      	ldr	r0, [pc, #96]	; (20aa4 <uart_cb+0x128>)
   20a44:	f012 fb78 	bl	33138 <z_impl_k_queue_get>
		if(!buf)
   20a48:	4606      	mov	r6, r0
   20a4a:	bb00      	cbnz	r0, 20a8e <uart_cb+0x112>
			uart_irq_tx_disable(x);
   20a4c:	4620      	mov	r0, r4
   20a4e:	f016 fcef 	bl	37430 <uart_irq_tx_disable>
			return;
   20a52:	e7a4      	b.n	2099e <uart_cb+0x22>
			written += uart_fifo_fill(x, &buf->data[written], buf->len - written);
   20a54:	1d29      	adds	r1, r5, #4
   20a56:	1b52      	subs	r2, r2, r5
   20a58:	4431      	add	r1, r6
   20a5a:	4620      	mov	r0, r4
   20a5c:	f016 fcdd 	bl	3741a <uart_fifo_fill>
   20a60:	4405      	add	r5, r0
   20a62:	b2ad      	uxth	r5, r5
		while(buf->len > written)
   20a64:	f8b6 2404 	ldrh.w	r2, [r6, #1028]	; 0x404
   20a68:	42aa      	cmp	r2, r5
   20a6a:	d8f3      	bhi.n	20a54 <uart_cb+0xd8>
	if (api->irq_tx_complete) {
   20a6c:	6863      	ldr	r3, [r4, #4]
   20a6e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   20a70:	b11b      	cbz	r3, 20a7a <uart_cb+0xfe>
		return api->irq_tx_complete(dev);
   20a72:	4620      	mov	r0, r4
   20a74:	4798      	blx	r3
		while (!uart_irq_tx_complete(x))
   20a76:	2800      	cmp	r0, #0
   20a78:	d0f8      	beq.n	20a6c <uart_cb+0xf0>
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_sflist_is_empty(sys_sflist_t *list);

Z_GENLIST_IS_EMPTY(sflist)
   20a7a:	4b0a      	ldr	r3, [pc, #40]	; (20aa4 <uart_cb+0x128>)
		if (k_fifo_is_empty(&fifo_uart_tx_data))
   20a7c:	681b      	ldr	r3, [r3, #0]
   20a7e:	b913      	cbnz	r3, 20a86 <uart_cb+0x10a>
			uart_irq_tx_disable(x);
   20a80:	4620      	mov	r0, r4
   20a82:	f016 fcd5 	bl	37430 <uart_irq_tx_disable>
		k_free(buf);
   20a86:	4630      	mov	r0, r6
   20a88:	f018 ffae 	bl	399e8 <k_free>
   20a8c:	e787      	b.n	2099e <uart_cb+0x22>
		u16_t written = 0;
   20a8e:	2500      	movs	r5, #0
   20a90:	e7e8      	b.n	20a64 <uart_cb+0xe8>
   20a92:	bf00      	nop
   20a94:	0003aef0 	.word	0x0003aef0
   20a98:	0003ade0 	.word	0x0003ade0
   20a9c:	200202d4 	.word	0x200202d4
   20aa0:	200242bc 	.word	0x200242bc
   20aa4:	2002cc68 	.word	0x2002cc68
   20aa8:	0003be72 	.word	0x0003be72

00020aac <ble_init>:

void ble_init(void)
{
	LOG_INF("ble_init\n");
   20aac:	2303      	movs	r3, #3
   20aae:	f04f 0000 	mov.w	r0, #0
{
   20ab2:	b570      	push	{r4, r5, r6, lr}
	LOG_INF("ble_init\n");
   20ab4:	f363 0007 	bfi	r0, r3, #0, #8
   20ab8:	4c15      	ldr	r4, [pc, #84]	; (20b10 <ble_init+0x64>)
   20aba:	4b16      	ldr	r3, [pc, #88]	; (20b14 <ble_init+0x68>)
   20abc:	4916      	ldr	r1, [pc, #88]	; (20b18 <ble_init+0x6c>)
   20abe:	1ae4      	subs	r4, r4, r3
   20ac0:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   20ac4:	f364 108f 	bfi	r0, r4, #6, #10
   20ac8:	f017 f951 	bl	37d6e <log_string_sync>
   20acc:	4813      	ldr	r0, [pc, #76]	; (20b1c <ble_init+0x70>)
   20ace:	f011 fc2b 	bl	32328 <z_impl_device_get_binding>
	
	uart_ble = device_get_binding(BLE_DEV);
   20ad2:	4d13      	ldr	r5, [pc, #76]	; (20b20 <ble_init+0x74>)
   20ad4:	4602      	mov	r2, r0
   20ad6:	6028      	str	r0, [r5, #0]
	if(!uart_ble)
   20ad8:	b960      	cbnz	r0, 20af4 <ble_init+0x48>
	{
		LOG_INF("Could not get %s device\n", BLE_DEV);
   20ada:	f04f 0000 	mov.w	r0, #0
   20ade:	2303      	movs	r3, #3
   20ae0:	f363 0007 	bfi	r0, r3, #0, #8
   20ae4:	f364 108f 	bfi	r0, r4, #6, #10
   20ae8:	4a0c      	ldr	r2, [pc, #48]	; (20b1c <ble_init+0x70>)
   20aea:	490e      	ldr	r1, [pc, #56]	; (20b24 <ble_init+0x78>)
		return;
	}

	uart_irq_callback_set(uart_ble, uart_cb);
	uart_irq_rx_enable(uart_ble);
}
   20aec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LOG_INF("Could not get %s device\n", BLE_DEV);
   20af0:	f017 b93d 	b.w	37d6e <log_string_sync>
static inline void uart_irq_callback_user_data_set(
					struct device *dev,
					uart_irq_callback_user_data_t cb,
					void *user_data)
{
	const struct uart_driver_api *api =
   20af4:	6843      	ldr	r3, [r0, #4]
		(const struct uart_driver_api *)dev->driver_api;

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
   20af6:	b11b      	cbz	r3, 20b00 <ble_init+0x54>
   20af8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   20afa:	b10b      	cbz	r3, 20b00 <ble_init+0x54>
		api->irq_callback_set(dev, cb, user_data);
   20afc:	490a      	ldr	r1, [pc, #40]	; (20b28 <ble_init+0x7c>)
   20afe:	4798      	blx	r3
	uart_irq_rx_enable(uart_ble);
   20b00:	6828      	ldr	r0, [r5, #0]
	if (api->irq_rx_enable) {
   20b02:	6843      	ldr	r3, [r0, #4]
   20b04:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   20b06:	b113      	cbz	r3, 20b0e <ble_init+0x62>
}
   20b08:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		api->irq_rx_enable(dev);
   20b0c:	4718      	bx	r3
   20b0e:	bd70      	pop	{r4, r5, r6, pc}
   20b10:	0003aef0 	.word	0x0003aef0
   20b14:	0003ade0 	.word	0x0003ade0
   20b18:	0003bd99 	.word	0x0003bd99
   20b1c:	0003bda3 	.word	0x0003bda3
   20b20:	200202d8 	.word	0x200202d8
   20b24:	0003ba27 	.word	0x0003ba27
   20b28:	0002097d 	.word	0x0002097d

00020b2c <gps_data_wait_timerout>:

void gps_data_wait_timerout(struct k_timer *timer)
{
	gps_data_incoming = true;
   20b2c:	2201      	movs	r2, #1
   20b2e:	4b01      	ldr	r3, [pc, #4]	; (20b34 <gps_data_wait_timerout+0x8>)
   20b30:	701a      	strb	r2, [r3, #0]
}
   20b32:	4770      	bx	lr
   20b34:	20024740 	.word	0x20024740

00020b38 <print_nmea_data>:
{
   20b38:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	LOG_INF("\n");
   20b3c:	f04f 0000 	mov.w	r0, #0
   20b40:	2303      	movs	r3, #3
   20b42:	4c14      	ldr	r4, [pc, #80]	; (20b94 <print_nmea_data+0x5c>)
   20b44:	f363 0007 	bfi	r0, r3, #0, #8
   20b48:	4b13      	ldr	r3, [pc, #76]	; (20b98 <print_nmea_data+0x60>)
   20b4a:	4914      	ldr	r1, [pc, #80]	; (20b9c <print_nmea_data+0x64>)
   20b4c:	1ae4      	subs	r4, r4, r3
   20b4e:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   20b52:	f364 108f 	bfi	r0, r4, #6, #10
   20b56:	f017 f90a 	bl	37d6e <log_string_sync>
	for(i = 0; i < nmea_string_cnt; ++i)
   20b5a:	2500      	movs	r5, #0
   20b5c:	4f10      	ldr	r7, [pc, #64]	; (20ba0 <print_nmea_data+0x68>)
		LOG_INF("%s", nmea_strings[i]);
   20b5e:	f8df 8044 	ldr.w	r8, [pc, #68]	; 20ba4 <print_nmea_data+0x6c>
   20b62:	f8df 9044 	ldr.w	r9, [pc, #68]	; 20ba8 <print_nmea_data+0x70>
	for(i = 0; i < nmea_string_cnt; ++i)
   20b66:	683b      	ldr	r3, [r7, #0]
   20b68:	429d      	cmp	r5, r3
   20b6a:	d301      	bcc.n	20b70 <print_nmea_data+0x38>
}
   20b6c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		LOG_INF("%s", nmea_strings[i]);
   20b70:	2253      	movs	r2, #83	; 0x53
   20b72:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   20b76:	f043 0303 	orr.w	r3, r3, #3
   20b7a:	f363 0607 	bfi	r6, r3, #0, #8
   20b7e:	f364 168f 	bfi	r6, r4, #6, #10
   20b82:	fb02 8205 	mla	r2, r2, r5, r8
   20b86:	4649      	mov	r1, r9
   20b88:	4630      	mov	r0, r6
   20b8a:	f017 f8f0 	bl	37d6e <log_string_sync>
	for(i = 0; i < nmea_string_cnt; ++i)
   20b8e:	3501      	adds	r5, #1
   20b90:	e7e9      	b.n	20b66 <print_nmea_data+0x2e>
   20b92:	bf00      	nop
   20b94:	0003ae48 	.word	0x0003ae48
   20b98:	0003ade0 	.word	0x0003ade0
   20b9c:	0003da1c 	.word	0x0003da1c
   20ba0:	20020338 	.word	0x20020338
   20ba4:	20024743 	.word	0x20024743
   20ba8:	0003dde1 	.word	0x0003dde1

00020bac <print_satellite_stats>:
{
   20bac:	b573      	push	{r0, r1, r4, r5, r6, lr}
	u8_t unhealthy = 0;
   20bae:	2100      	movs	r1, #0
	u8_t in_fix = 0;
   20bb0:	460b      	mov	r3, r1
	u8_t tracked = 0;
   20bb2:	460a      	mov	r2, r1
   20bb4:	f100 0590 	add.w	r5, r0, #144	; 0x90
		if ((pvt_data->pvt.sv[i].sv > 0) && (pvt_data->pvt.sv[i].sv < 33))
   20bb8:	f8b0 4046 	ldrh.w	r4, [r0, #70]	; 0x46
   20bbc:	3c01      	subs	r4, #1
   20bbe:	2c1f      	cmp	r4, #31
   20bc0:	d80c      	bhi.n	20bdc <print_satellite_stats+0x30>
			if (pvt_data->pvt.sv[i].flags & NRF_GNSS_SV_FLAG_USED_IN_FIX)
   20bc2:	f890 4050 	ldrb.w	r4, [r0, #80]	; 0x50
			tracked++;
   20bc6:	3201      	adds	r2, #1
			if (pvt_data->pvt.sv[i].flags & NRF_GNSS_SV_FLAG_USED_IN_FIX)
   20bc8:	07a6      	lsls	r6, r4, #30
				in_fix++;
   20bca:	bf44      	itt	mi
   20bcc:	3301      	addmi	r3, #1
   20bce:	b2db      	uxtbmi	r3, r3
			if (pvt_data->pvt.sv[i].flags & NRF_GNSS_SV_FLAG_UNHEALTHY)
   20bd0:	0724      	lsls	r4, r4, #28
				unhealthy++;
   20bd2:	bf48      	it	mi
   20bd4:	3101      	addmi	r1, #1
			tracked++;
   20bd6:	b2d2      	uxtb	r2, r2
				unhealthy++;
   20bd8:	bf48      	it	mi
   20bda:	b2c9      	uxtbmi	r1, r1
   20bdc:	300c      	adds	r0, #12
	for(i = 0; i < NRF_GNSS_MAX_SATELLITES; ++i)
   20bde:	42a8      	cmp	r0, r5
   20be0:	d1ea      	bne.n	20bb8 <print_satellite_stats+0xc>
	LOG_INF("Tracking: %d Using: %d Unhealthy: %d", tracked, in_fix, unhealthy);
   20be2:	2403      	movs	r4, #3
   20be4:	f04f 0000 	mov.w	r0, #0
   20be8:	4d15      	ldr	r5, [pc, #84]	; (20c40 <print_satellite_stats+0x94>)
   20bea:	f364 0007 	bfi	r0, r4, #0, #8
   20bee:	4c15      	ldr	r4, [pc, #84]	; (20c44 <print_satellite_stats+0x98>)
   20bf0:	9100      	str	r1, [sp, #0]
   20bf2:	1b64      	subs	r4, r4, r5
   20bf4:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   20bf8:	f364 108f 	bfi	r0, r4, #6, #10
   20bfc:	4912      	ldr	r1, [pc, #72]	; (20c48 <print_satellite_stats+0x9c>)
   20bfe:	f017 f8b6 	bl	37d6e <log_string_sync>
	LOG_INF("\nSeconds since last fix %lld\n", (k_uptime_get() - fix_timestamp) / 1000);
   20c02:	f04f 0500 	mov.w	r5, #0
   20c06:	2303      	movs	r3, #3
   20c08:	f363 0507 	bfi	r5, r3, #0, #8
   20c0c:	f364 158f 	bfi	r5, r4, #6, #10
	return z_impl_k_uptime_get();
   20c10:	f018 fffc 	bl	39c0c <z_impl_k_uptime_get>
   20c14:	4b0d      	ldr	r3, [pc, #52]	; (20c4c <print_satellite_stats+0xa0>)
   20c16:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   20c1a:	e9d3 4600 	ldrd	r4, r6, [r3]
   20c1e:	1b00      	subs	r0, r0, r4
   20c20:	f04f 0300 	mov.w	r3, #0
   20c24:	eb61 0106 	sbc.w	r1, r1, r6
   20c28:	f7fc f8d0 	bl	1cdcc <__aeabi_uldivmod>
   20c2c:	4602      	mov	r2, r0
   20c2e:	460b      	mov	r3, r1
   20c30:	4628      	mov	r0, r5
   20c32:	4907      	ldr	r1, [pc, #28]	; (20c50 <print_satellite_stats+0xa4>)
}
   20c34:	b002      	add	sp, #8
   20c36:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	LOG_INF("\nSeconds since last fix %lld\n", (k_uptime_get() - fix_timestamp) / 1000);
   20c3a:	f017 b898 	b.w	37d6e <log_string_sync>
   20c3e:	bf00      	nop
   20c40:	0003ade0 	.word	0x0003ade0
   20c44:	0003ae48 	.word	0x0003ae48
   20c48:	0003c120 	.word	0x0003c120
   20c4c:	20020000 	.word	0x20020000
   20c50:	0003c145 	.word	0x0003c145

00020c54 <bsd_recoverable_error_handler>:
{
   20c54:	b410      	push	{r4}
	LOG_INF("Err: %lu\n", (unsigned long)error);
   20c56:	2303      	movs	r3, #3
   20c58:	f04f 0400 	mov.w	r4, #0
   20c5c:	4a07      	ldr	r2, [pc, #28]	; (20c7c <bsd_recoverable_error_handler+0x28>)
   20c5e:	f363 0407 	bfi	r4, r3, #0, #8
   20c62:	4b07      	ldr	r3, [pc, #28]	; (20c80 <bsd_recoverable_error_handler+0x2c>)
   20c64:	4907      	ldr	r1, [pc, #28]	; (20c84 <bsd_recoverable_error_handler+0x30>)
   20c66:	1a9b      	subs	r3, r3, r2
   20c68:	08db      	lsrs	r3, r3, #3
   20c6a:	f363 148f 	bfi	r4, r3, #6, #10
   20c6e:	4602      	mov	r2, r0
   20c70:	4620      	mov	r0, r4
}
   20c72:	f85d 4b04 	ldr.w	r4, [sp], #4
	LOG_INF("Err: %lu\n", (unsigned long)error);
   20c76:	f017 b87a 	b.w	37d6e <log_string_sync>
   20c7a:	bf00      	nop
   20c7c:	0003ade0 	.word	0x0003ade0
   20c80:	0003ae48 	.word	0x0003ae48
   20c84:	0003befe 	.word	0x0003befe

00020c88 <process_gps_data>:
{
   20c88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	retval = nrf_recv(gnss_fd,
   20c8a:	4601      	mov	r1, r0
{
   20c8c:	4604      	mov	r4, r0
	retval = nrf_recv(gnss_fd,
   20c8e:	481f      	ldr	r0, [pc, #124]	; (20d0c <process_gps_data+0x84>)
   20c90:	2302      	movs	r3, #2
   20c92:	22d8      	movs	r2, #216	; 0xd8
   20c94:	6800      	ldr	r0, [r0, #0]
   20c96:	f00c ffe9 	bl	2dc6c <nrf_recv>
	if(retval > 0) 
   20c9a:	1e06      	subs	r6, r0, #0
   20c9c:	dd04      	ble.n	20ca8 <process_gps_data+0x20>
		switch (gps_data->data_id)
   20c9e:	7823      	ldrb	r3, [r4, #0]
   20ca0:	2b01      	cmp	r3, #1
   20ca2:	d003      	beq.n	20cac <process_gps_data+0x24>
   20ca4:	2b02      	cmp	r3, #2
   20ca6:	d01c      	beq.n	20ce2 <process_gps_data+0x5a>
}
   20ca8:	4630      	mov	r0, r6
   20caa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if((gps_data->pvt.flags & NRF_GNSS_PVT_FLAG_FIX_VALID_BIT)	== NRF_GNSS_PVT_FLAG_FIX_VALID_BIT)
   20cac:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
   20cb0:	4d17      	ldr	r5, [pc, #92]	; (20d10 <process_gps_data+0x88>)
   20cb2:	f012 0f01 	tst.w	r2, #1
   20cb6:	d00f      	beq.n	20cd8 <process_gps_data+0x50>
				if (!got_first_fix)
   20cb8:	4a16      	ldr	r2, [pc, #88]	; (20d14 <process_gps_data+0x8c>)
   20cba:	7811      	ldrb	r1, [r2, #0]
   20cbc:	b901      	cbnz	r1, 20cc0 <process_gps_data+0x38>
					got_first_fix = true;
   20cbe:	7013      	strb	r3, [r2, #0]
   20cc0:	f018 ffa4 	bl	39c0c <z_impl_k_uptime_get>
				fix_timestamp = k_uptime_get();
   20cc4:	4b14      	ldr	r3, [pc, #80]	; (20d18 <process_gps_data+0x90>)
				memcpy(&last_fix,
   20cc6:	22d8      	movs	r2, #216	; 0xd8
				fix_timestamp = k_uptime_get();
   20cc8:	e9c3 0100 	strd	r0, r1, [r3]
				memcpy(&last_fix,
   20ccc:	4621      	mov	r1, r4
   20cce:	4813      	ldr	r0, [pc, #76]	; (20d1c <process_gps_data+0x94>)
   20cd0:	f019 f855 	bl	39d7e <memcpy>
				nmea_string_cnt = 0;
   20cd4:	2300      	movs	r3, #0
   20cd6:	602b      	str	r3, [r5, #0]
			print_nmea_data();
   20cd8:	f7ff ff2e 	bl	20b38 <print_nmea_data>
			nmea_string_cnt = 0;
   20cdc:	2300      	movs	r3, #0
   20cde:	602b      	str	r3, [r5, #0]
			break;
   20ce0:	e7e2      	b.n	20ca8 <process_gps_data+0x20>
			if (nmea_string_cnt < 10) 
   20ce2:	4f0b      	ldr	r7, [pc, #44]	; (20d10 <process_gps_data+0x88>)
   20ce4:	683d      	ldr	r5, [r7, #0]
   20ce6:	2d09      	cmp	r5, #9
   20ce8:	d8de      	bhi.n	20ca8 <process_gps_data+0x20>
				memset(nmea_strings[nmea_string_cnt],
   20cea:	2253      	movs	r2, #83	; 0x53
   20cec:	4b0c      	ldr	r3, [pc, #48]	; (20d20 <process_gps_data+0x98>)
__ssp_bos_icheck3(memmove, void *, const void *)
__ssp_bos_icheck3_restrict(mempcpy, void *, const void *)
__ssp_bos_icheck3(memset, void *, int)
   20cee:	2100      	movs	r1, #0
   20cf0:	fb02 3305 	mla	r3, r2, r5, r3
   20cf4:	4618      	mov	r0, r3
   20cf6:	f019 f862 	bl	39dbe <memset>
				memcpy(nmea_strings[nmea_string_cnt++],
   20cfa:	3501      	adds	r5, #1
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   20cfc:	4632      	mov	r2, r6
   20cfe:	f104 0108 	add.w	r1, r4, #8
   20d02:	603d      	str	r5, [r7, #0]
   20d04:	f019 f83b 	bl	39d7e <memcpy>
	return retval;
   20d08:	e7ce      	b.n	20ca8 <process_gps_data+0x20>
   20d0a:	bf00      	nop
   20d0c:	20020308 	.word	0x20020308
   20d10:	20020338 	.word	0x20020338
   20d14:	2002473f 	.word	0x2002473f
   20d18:	20020000 	.word	0x20020000
   20d1c:	20020008 	.word	0x20020008
   20d20:	20024743 	.word	0x20024743

00020d24 <APP_Ask_GPS_Data>:
{
   20d24:	b508      	push	{r3, lr}
	app_gps_on = true;
   20d26:	2301      	movs	r3, #1
   20d28:	4a09      	ldr	r2, [pc, #36]	; (20d50 <APP_Ask_GPS_Data+0x2c>)
	if(time_init == false)
   20d2a:	490a      	ldr	r1, [pc, #40]	; (20d54 <APP_Ask_GPS_Data+0x30>)
	app_gps_on = true;
   20d2c:	7013      	strb	r3, [r2, #0]
	APP_wait_gps = true;
   20d2e:	4a0a      	ldr	r2, [pc, #40]	; (20d58 <APP_Ask_GPS_Data+0x34>)
   20d30:	7013      	strb	r3, [r2, #0]
	if(time_init == false)
   20d32:	780a      	ldrb	r2, [r1, #0]
   20d34:	b922      	cbnz	r2, 20d40 <APP_Ask_GPS_Data+0x1c>
		time_init = true;
   20d36:	700b      	strb	r3, [r1, #0]
		k_timer_init(&app_wait_gps_timer, APP_Ask_GPS_Data_timerout, NULL);
   20d38:	4808      	ldr	r0, [pc, #32]	; (20d5c <APP_Ask_GPS_Data+0x38>)
   20d3a:	4909      	ldr	r1, [pc, #36]	; (20d60 <APP_Ask_GPS_Data+0x3c>)
   20d3c:	f018 ff74 	bl	39c28 <k_timer_init>
}
   20d40:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_impl_k_timer_start(timer, duration, period);
   20d44:	2200      	movs	r2, #0
   20d46:	4907      	ldr	r1, [pc, #28]	; (20d64 <APP_Ask_GPS_Data+0x40>)
   20d48:	4804      	ldr	r0, [pc, #16]	; (20d5c <APP_Ask_GPS_Data+0x38>)
   20d4a:	f014 bb2b 	b.w	353a4 <z_impl_k_timer_start>
   20d4e:	bf00      	nop
   20d50:	2002473d 	.word	0x2002473d
   20d54:	20024a81 	.word	0x20024a81
   20d58:	200242b4 	.word	0x200242b4
   20d5c:	200202dc 	.word	0x200202dc
   20d60:	0001d169 	.word	0x0001d169
   20d64:	0002bf20 	.word	0x0002bf20

00020d68 <gps_init>:

void gps_init(void)
{
   20d68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	for(i = 0; i < ARRAY_SIZE(at_commands_activate_gps); i++)
   20d6c:	2700      	movs	r7, #0
   20d6e:	4c52      	ldr	r4, [pc, #328]	; (20eb8 <gps_init+0x150>)
{
   20d70:	b086      	sub	sp, #24
		if(at_cmd_write(at_commands_activate_gps[i], NULL, 0, NULL) != 0)
   20d72:	2300      	movs	r3, #0
   20d74:	4620      	mov	r0, r4
   20d76:	461a      	mov	r2, r3
   20d78:	4619      	mov	r1, r3
   20d7a:	f007 fab7 	bl	282ec <at_cmd_write>
   20d7e:	2800      	cmp	r0, #0
   20d80:	f040 808c 	bne.w	20e9c <gps_init+0x134>
	for(i = 0; i < ARRAY_SIZE(at_commands_activate_gps); i++)
   20d84:	3701      	adds	r7, #1
   20d86:	2f04      	cmp	r7, #4
   20d88:	f104 041f 	add.w	r4, r4, #31
   20d8c:	d1f1      	bne.n	20d72 <gps_init+0xa>
	nrf_gnss_fix_interval_t fix_interval = 1;
   20d8e:	f04f 0801 	mov.w	r8, #1
	nrf_gnss_nmea_mask_t nmea_mask = NRF_GNSS_NMEA_GSV_MASK |
   20d92:	231f      	movs	r3, #31
	nrf_gnss_fix_retry_t fix_retry    = 0;
   20d94:	f8ad 000e 	strh.w	r0, [sp, #14]
	nrf_gnss_delete_mask_t delete_mask  = 0;
   20d98:	9005      	str	r0, [sp, #20]
		gnss_fd = nrf_socket(NRF_AF_LOCAL,
   20d9a:	f44f 7201 	mov.w	r2, #516	; 0x204
   20d9e:	2102      	movs	r1, #2
   20da0:	4640      	mov	r0, r8
	nrf_gnss_nmea_mask_t nmea_mask = NRF_GNSS_NMEA_GSV_MASK |
   20da2:	f8ad 3012 	strh.w	r3, [sp, #18]
	nrf_gnss_fix_interval_t fix_interval = 1;
   20da6:	f8ad 8010 	strh.w	r8, [sp, #16]
		gnss_fd = nrf_socket(NRF_AF_LOCAL,
   20daa:	f00c feed 	bl	2db88 <nrf_socket>
   20dae:	4c43      	ldr	r4, [pc, #268]	; (20ebc <gps_init+0x154>)
   20db0:	4b43      	ldr	r3, [pc, #268]	; (20ec0 <gps_init+0x158>)
   20db2:	4d44      	ldr	r5, [pc, #272]	; (20ec4 <gps_init+0x15c>)
   20db4:	1ae4      	subs	r4, r4, r3
		if(gnss_fd >= 0)
   20db6:	2800      	cmp	r0, #0
		gnss_fd = nrf_socket(NRF_AF_LOCAL,
   20db8:	4602      	mov	r2, r0
   20dba:	6028      	str	r0, [r5, #0]
		if(gnss_fd >= 0)
   20dbc:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   20dc0:	da0c      	bge.n	20ddc <gps_init+0x74>
			LOG_INF("Could not init socket (err: %d)\n", gnss_fd);
   20dc2:	f04f 0000 	mov.w	r0, #0
   20dc6:	2303      	movs	r3, #3
   20dc8:	f363 0007 	bfi	r0, r3, #0, #8
   20dcc:	f364 108f 	bfi	r0, r4, #6, #10
   20dd0:	493d      	ldr	r1, [pc, #244]	; (20ec8 <gps_init+0x160>)
   20dd2:	f016 ffcc 	bl	37d6e <log_string_sync>
	}

	gps_is_inited = true;

	k_timer_init(&gps_data_timer, gps_data_wait_timerout, NULL);
}
   20dd6:	b006      	add	sp, #24
   20dd8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			LOG_INF("GPS Socket created\n");
   20ddc:	2303      	movs	r3, #3
   20dde:	f04f 0000 	mov.w	r0, #0
		retval = nrf_setsockopt(gnss_fd,
   20de2:	2602      	movs	r6, #2
			LOG_INF("GPS Socket created\n");
   20de4:	f363 0007 	bfi	r0, r3, #0, #8
   20de8:	f364 108f 	bfi	r0, r4, #6, #10
   20dec:	4937      	ldr	r1, [pc, #220]	; (20ecc <gps_init+0x164>)
   20dee:	f016 ffbe 	bl	37d6e <log_string_sync>
		retval = nrf_setsockopt(gnss_fd,
   20df2:	9600      	str	r6, [sp, #0]
   20df4:	f10d 030e 	add.w	r3, sp, #14
   20df8:	4632      	mov	r2, r6
   20dfa:	f44f 7101 	mov.w	r1, #516	; 0x204
   20dfe:	6828      	ldr	r0, [r5, #0]
   20e00:	f00c ff98 	bl	2dd34 <nrf_setsockopt>
		if(retval != 0)
   20e04:	b150      	cbz	r0, 20e1c <gps_init+0xb4>
			LOG_INF("Failed to set fix retry value\n");
   20e06:	f04f 0000 	mov.w	r0, #0
   20e0a:	2303      	movs	r3, #3
   20e0c:	4930      	ldr	r1, [pc, #192]	; (20ed0 <gps_init+0x168>)
   20e0e:	f363 0007 	bfi	r0, r3, #0, #8
   20e12:	f364 108f 	bfi	r0, r4, #6, #10
		LOG_INF("Failed to initialize modem\n");
   20e16:	f016 ffaa 	bl	37d6e <log_string_sync>
		return -1;
   20e1a:	e7dc      	b.n	20dd6 <gps_init+0x6e>
		retval = nrf_setsockopt(gnss_fd,
   20e1c:	9600      	str	r6, [sp, #0]
   20e1e:	ab04      	add	r3, sp, #16
   20e20:	4642      	mov	r2, r8
   20e22:	f44f 7101 	mov.w	r1, #516	; 0x204
   20e26:	6828      	ldr	r0, [r5, #0]
   20e28:	f00c ff84 	bl	2dd34 <nrf_setsockopt>
		if(retval != 0)
   20e2c:	b140      	cbz	r0, 20e40 <gps_init+0xd8>
			LOG_INF("Failed to set fix interval value\n");
   20e2e:	f04f 0000 	mov.w	r0, #0
   20e32:	2303      	movs	r3, #3
   20e34:	f363 0007 	bfi	r0, r3, #0, #8
   20e38:	f364 108f 	bfi	r0, r4, #6, #10
   20e3c:	4925      	ldr	r1, [pc, #148]	; (20ed4 <gps_init+0x16c>)
   20e3e:	e7ea      	b.n	20e16 <gps_init+0xae>
		retval = nrf_setsockopt(gnss_fd,
   20e40:	9600      	str	r6, [sp, #0]
   20e42:	f10d 0312 	add.w	r3, sp, #18
   20e46:	463a      	mov	r2, r7
   20e48:	f44f 7101 	mov.w	r1, #516	; 0x204
   20e4c:	6828      	ldr	r0, [r5, #0]
   20e4e:	f00c ff71 	bl	2dd34 <nrf_setsockopt>
		if(retval != 0)
   20e52:	b140      	cbz	r0, 20e66 <gps_init+0xfe>
			LOG_INF("Failed to set nmea mask\n");
   20e54:	f04f 0000 	mov.w	r0, #0
   20e58:	2303      	movs	r3, #3
   20e5a:	f363 0007 	bfi	r0, r3, #0, #8
   20e5e:	f364 108f 	bfi	r0, r4, #6, #10
   20e62:	491d      	ldr	r1, [pc, #116]	; (20ed8 <gps_init+0x170>)
   20e64:	e7d7      	b.n	20e16 <gps_init+0xae>
		retval = nrf_setsockopt(gnss_fd,
   20e66:	2207      	movs	r2, #7
   20e68:	9700      	str	r7, [sp, #0]
   20e6a:	ab05      	add	r3, sp, #20
   20e6c:	f44f 7101 	mov.w	r1, #516	; 0x204
   20e70:	6828      	ldr	r0, [r5, #0]
   20e72:	f00c ff5f 	bl	2dd34 <nrf_setsockopt>
		if(retval != 0)
   20e76:	4602      	mov	r2, r0
   20e78:	b938      	cbnz	r0, 20e8a <gps_init+0x122>
	gps_is_inited = true;
   20e7a:	4b18      	ldr	r3, [pc, #96]	; (20edc <gps_init+0x174>)
	k_timer_init(&gps_data_timer, gps_data_wait_timerout, NULL);
   20e7c:	4918      	ldr	r1, [pc, #96]	; (20ee0 <gps_init+0x178>)
   20e7e:	4819      	ldr	r0, [pc, #100]	; (20ee4 <gps_init+0x17c>)
	gps_is_inited = true;
   20e80:	f883 8000 	strb.w	r8, [r3]
	k_timer_init(&gps_data_timer, gps_data_wait_timerout, NULL);
   20e84:	f018 fed0 	bl	39c28 <k_timer_init>
   20e88:	e7a5      	b.n	20dd6 <gps_init+0x6e>
			LOG_INF("Failed to start GPS\n");
   20e8a:	f04f 0000 	mov.w	r0, #0
   20e8e:	2303      	movs	r3, #3
   20e90:	f363 0007 	bfi	r0, r3, #0, #8
   20e94:	f364 108f 	bfi	r0, r4, #6, #10
   20e98:	4913      	ldr	r1, [pc, #76]	; (20ee8 <gps_init+0x180>)
   20e9a:	e7bc      	b.n	20e16 <gps_init+0xae>
		LOG_INF("Failed to initialize modem\n");
   20e9c:	2303      	movs	r3, #3
   20e9e:	f04f 0000 	mov.w	r0, #0
   20ea2:	4a07      	ldr	r2, [pc, #28]	; (20ec0 <gps_init+0x158>)
   20ea4:	f363 0007 	bfi	r0, r3, #0, #8
   20ea8:	4b04      	ldr	r3, [pc, #16]	; (20ebc <gps_init+0x154>)
   20eaa:	4910      	ldr	r1, [pc, #64]	; (20eec <gps_init+0x184>)
   20eac:	1a9b      	subs	r3, r3, r2
   20eae:	08db      	lsrs	r3, r3, #3
   20eb0:	f363 108f 	bfi	r0, r3, #6, #10
   20eb4:	e7af      	b.n	20e16 <gps_init+0xae>
   20eb6:	bf00      	nop
   20eb8:	0003be82 	.word	0x0003be82
   20ebc:	0003ae48 	.word	0x0003ae48
   20ec0:	0003ade0 	.word	0x0003ade0
   20ec4:	20020308 	.word	0x20020308
   20ec8:	0003c003 	.word	0x0003c003
   20ecc:	0003bfef 	.word	0x0003bfef
   20ed0:	0003c024 	.word	0x0003c024
   20ed4:	0003c043 	.word	0x0003c043
   20ed8:	0003c065 	.word	0x0003c065
   20edc:	20024741 	.word	0x20024741
   20ee0:	00020b2d 	.word	0x00020b2d
   20ee4:	2002030c 	.word	0x2002030c
   20ee8:	0003c07e 	.word	0x0003c07e
   20eec:	0003c093 	.word	0x0003c093

00020ef0 <gps_restart>:

void gps_restart(void)
{
   20ef0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	nrf_gnss_delete_mask_t delete_mask  = 0;
   20ef2:	2300      	movs	r3, #0
   20ef4:	9303      	str	r3, [sp, #12]
		retval = nrf_setsockopt(gnss_fd,
   20ef6:	2304      	movs	r3, #4
   20ef8:	480d      	ldr	r0, [pc, #52]	; (20f30 <gps_restart+0x40>)
   20efa:	9300      	str	r3, [sp, #0]
   20efc:	2207      	movs	r2, #7
   20efe:	ab03      	add	r3, sp, #12
   20f00:	f44f 7101 	mov.w	r1, #516	; 0x204
   20f04:	6800      	ldr	r0, [r0, #0]
   20f06:	f00c ff15 	bl	2dd34 <nrf_setsockopt>
		if(retval != 0)
   20f0a:	b168      	cbz	r0, 20f28 <gps_restart+0x38>
			LOG_INF("Failed to start GPS\n");
   20f0c:	2303      	movs	r3, #3
   20f0e:	f04f 0000 	mov.w	r0, #0
   20f12:	4a08      	ldr	r2, [pc, #32]	; (20f34 <gps_restart+0x44>)
   20f14:	f363 0007 	bfi	r0, r3, #0, #8
   20f18:	4b07      	ldr	r3, [pc, #28]	; (20f38 <gps_restart+0x48>)
   20f1a:	4908      	ldr	r1, [pc, #32]	; (20f3c <gps_restart+0x4c>)
   20f1c:	1a9b      	subs	r3, r3, r2
   20f1e:	08db      	lsrs	r3, r3, #3
   20f20:	f363 108f 	bfi	r0, r3, #6, #10
   20f24:	f016 ff23 	bl	37d6e <log_string_sync>
	gnss_ctrl(GNSS_RESTART);
}
   20f28:	b005      	add	sp, #20
   20f2a:	f85d fb04 	ldr.w	pc, [sp], #4
   20f2e:	bf00      	nop
   20f30:	20020308 	.word	0x20020308
   20f34:	0003ade0 	.word	0x0003ade0
   20f38:	0003ae48 	.word	0x0003ae48
   20f3c:	0003c07e 	.word	0x0003c07e

00020f40 <gps_off>:

void gps_off(void)
{
   20f40:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	if(!gps_is_on)
   20f42:	4b1d      	ldr	r3, [pc, #116]	; (20fb8 <gps_off+0x78>)
   20f44:	781a      	ldrb	r2, [r3, #0]
   20f46:	b98a      	cbnz	r2, 20f6c <gps_off+0x2c>
	{
		LOG_INF("gps is been truned off\n");
   20f48:	2303      	movs	r3, #3
   20f4a:	f04f 0000 	mov.w	r0, #0
   20f4e:	4a1b      	ldr	r2, [pc, #108]	; (20fbc <gps_off+0x7c>)
   20f50:	f363 0007 	bfi	r0, r3, #0, #8
   20f54:	4b1a      	ldr	r3, [pc, #104]	; (20fc0 <gps_off+0x80>)
   20f56:	491b      	ldr	r1, [pc, #108]	; (20fc4 <gps_off+0x84>)
   20f58:	1a9b      	subs	r3, r3, r2
   20f5a:	08db      	lsrs	r3, r3, #3
   20f5c:	f363 108f 	bfi	r0, r3, #6, #10
			LOG_INF("Failed to stop GPS\n");
   20f60:	f016 ff05 	bl	37d6e <log_string_sync>
	//#ifdef SHOW_LOG_IN_SCREEN	
	//	show_infor("Failed to reset modem");
	//#endif	
	//}

	GoBackHistoryScreen();
   20f64:	f001 fb1a 	bl	2259c <GoBackHistoryScreen>
}
   20f68:	b004      	add	sp, #16
   20f6a:	bd10      	pop	{r4, pc}
	gps_is_on = false;
   20f6c:	2400      	movs	r4, #0
   20f6e:	701c      	strb	r4, [r3, #0]
	got_first_fix = false;
   20f70:	4b15      	ldr	r3, [pc, #84]	; (20fc8 <gps_off+0x88>)
   20f72:	701c      	strb	r4, [r3, #0]
	gps_data_incoming = false;
   20f74:	4b15      	ldr	r3, [pc, #84]	; (20fcc <gps_off+0x8c>)
   20f76:	701c      	strb	r4, [r3, #0]
	z_impl_k_timer_stop(timer);
   20f78:	4815      	ldr	r0, [pc, #84]	; (20fd0 <gps_off+0x90>)
   20f7a:	f018 fe61 	bl	39c40 <z_impl_k_timer_stop>
   20f7e:	4815      	ldr	r0, [pc, #84]	; (20fd4 <gps_off+0x94>)
   20f80:	f018 fe5e 	bl	39c40 <z_impl_k_timer_stop>
		retval = nrf_setsockopt(gnss_fd,
   20f84:	2304      	movs	r3, #4
   20f86:	4814      	ldr	r0, [pc, #80]	; (20fd8 <gps_off+0x98>)
   20f88:	9300      	str	r3, [sp, #0]
   20f8a:	2208      	movs	r2, #8
   20f8c:	ab03      	add	r3, sp, #12
   20f8e:	f44f 7101 	mov.w	r1, #516	; 0x204
   20f92:	6800      	ldr	r0, [r0, #0]
	nrf_gnss_delete_mask_t delete_mask  = 0;
   20f94:	9403      	str	r4, [sp, #12]
		retval = nrf_setsockopt(gnss_fd,
   20f96:	f00c fecd 	bl	2dd34 <nrf_setsockopt>
		if(retval != 0)
   20f9a:	2800      	cmp	r0, #0
   20f9c:	d0e2      	beq.n	20f64 <gps_off+0x24>
			LOG_INF("Failed to stop GPS\n");
   20f9e:	2303      	movs	r3, #3
   20fa0:	f04f 0000 	mov.w	r0, #0
   20fa4:	4a05      	ldr	r2, [pc, #20]	; (20fbc <gps_off+0x7c>)
   20fa6:	f363 0007 	bfi	r0, r3, #0, #8
   20faa:	4b05      	ldr	r3, [pc, #20]	; (20fc0 <gps_off+0x80>)
   20fac:	490b      	ldr	r1, [pc, #44]	; (20fdc <gps_off+0x9c>)
   20fae:	1a9b      	subs	r3, r3, r2
   20fb0:	08db      	lsrs	r3, r3, #3
   20fb2:	f363 108f 	bfi	r0, r3, #6, #10
   20fb6:	e7d3      	b.n	20f60 <gps_off+0x20>
   20fb8:	20024742 	.word	0x20024742
   20fbc:	0003ade0 	.word	0x0003ade0
   20fc0:	0003ae48 	.word	0x0003ae48
   20fc4:	0003c0af 	.word	0x0003c0af
   20fc8:	2002473f 	.word	0x2002473f
   20fcc:	20024740 	.word	0x20024740
   20fd0:	2002030c 	.word	0x2002030c
   20fd4:	200202dc 	.word	0x200202dc
   20fd8:	20020308 	.word	0x20020308
   20fdc:	0003c0c7 	.word	0x0003c0c7

00020fe0 <gps_on>:

void gps_on(void)
{
   20fe0:	b538      	push	{r3, r4, r5, lr}
		.logger     = supl_logger,
		.counter_ms = k_uptime_get
	};
#endif

	if(gps_is_on)
   20fe2:	4d20      	ldr	r5, [pc, #128]	; (21064 <gps_on+0x84>)
   20fe4:	4c20      	ldr	r4, [pc, #128]	; (21068 <gps_on+0x88>)
   20fe6:	4b21      	ldr	r3, [pc, #132]	; (2106c <gps_on+0x8c>)
   20fe8:	782a      	ldrb	r2, [r5, #0]
   20fea:	1ae4      	subs	r4, r4, r3
   20fec:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   20ff0:	b15a      	cbz	r2, 2100a <gps_on+0x2a>
	{
		LOG_INF("gps is been truned on\n");
   20ff2:	2303      	movs	r3, #3
   20ff4:	f04f 0000 	mov.w	r0, #0
   20ff8:	f363 0007 	bfi	r0, r3, #0, #8
   20ffc:	f364 108f 	bfi	r0, r4, #6, #10
   21000:	491b      	ldr	r1, [pc, #108]	; (21070 <gps_on+0x90>)
#ifdef SHOW_LOG_IN_SCREEN
	show_infor("Getting GPS data...");
#endif

	k_timer_start(&gps_data_timer, K_MSEC(500), K_MSEC(1000));
}
   21002:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		LOG_INF("gps is been truned on\n");
   21006:	f016 beb2 	b.w	37d6e <log_string_sync>
	EnterGPSTestScreen();
   2100a:	f001 faaf 	bl	2256c <EnterGPSTestScreen>
	LOG_INF("Staring GPS application\n");
   2100e:	2303      	movs	r3, #3
   21010:	f04f 0000 	mov.w	r0, #0
   21014:	f363 0007 	bfi	r0, r3, #0, #8
   21018:	f364 108f 	bfi	r0, r4, #6, #10
   2101c:	4915      	ldr	r1, [pc, #84]	; (21074 <gps_on+0x94>)
   2101e:	f016 fea6 	bl	37d6e <log_string_sync>
	if(gps_is_inited == false)
   21022:	4b15      	ldr	r3, [pc, #84]	; (21078 <gps_on+0x98>)
   21024:	781b      	ldrb	r3, [r3, #0]
   21026:	b9cb      	cbnz	r3, 2105c <gps_on+0x7c>
		gps_init();
   21028:	f7ff fe9e 	bl	20d68 <gps_init>
	cnt = 0;
   2102c:	2200      	movs	r2, #0
   2102e:	4b13      	ldr	r3, [pc, #76]	; (2107c <gps_on+0x9c>)
	LOG_INF("Getting GPS data...\n");
   21030:	f04f 0000 	mov.w	r0, #0
	cnt = 0;
   21034:	701a      	strb	r2, [r3, #0]
	gps_is_on = true;
   21036:	2301      	movs	r3, #1
   21038:	702b      	strb	r3, [r5, #0]
	LOG_INF("Getting GPS data...\n");
   2103a:	2303      	movs	r3, #3
   2103c:	f363 0007 	bfi	r0, r3, #0, #8
   21040:	f364 108f 	bfi	r0, r4, #6, #10
   21044:	490e      	ldr	r1, [pc, #56]	; (21080 <gps_on+0xa0>)
   21046:	f016 fe92 	bl	37d6e <log_string_sync>
}
   2104a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_timer_start(timer, duration, period);
   2104e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   21052:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
   21056:	480b      	ldr	r0, [pc, #44]	; (21084 <gps_on+0xa4>)
   21058:	f014 b9a4 	b.w	353a4 <z_impl_k_timer_start>
		gps_restart();
   2105c:	f7ff ff48 	bl	20ef0 <gps_restart>
   21060:	e7e4      	b.n	2102c <gps_on+0x4c>
   21062:	bf00      	nop
   21064:	20024742 	.word	0x20024742
   21068:	0003ae48 	.word	0x0003ae48
   2106c:	0003ade0 	.word	0x0003ade0
   21070:	0003c0db 	.word	0x0003c0db
   21074:	0003c0f2 	.word	0x0003c0f2
   21078:	20024741 	.word	0x20024741
   2107c:	2002473e 	.word	0x2002473e
   21080:	0003c10b 	.word	0x0003c10b
   21084:	2002030c 	.word	0x2002030c

00021088 <GPSMsgProcess>:

void GPSMsgProcess(void)
{
   21088:	b508      	push	{r3, lr}
	if(app_gps_on)
   2108a:	4b0c      	ldr	r3, [pc, #48]	; (210bc <GPSMsgProcess+0x34>)
   2108c:	781a      	ldrb	r2, [r3, #0]
   2108e:	b11a      	cbz	r2, 21098 <GPSMsgProcess+0x10>
	{
		app_gps_on = false;
   21090:	2200      	movs	r2, #0
   21092:	701a      	strb	r2, [r3, #0]
		gps_on();
   21094:	f7ff ffa4 	bl	20fe0 <gps_on>
	}
	if(app_gps_off)
   21098:	4b09      	ldr	r3, [pc, #36]	; (210c0 <GPSMsgProcess+0x38>)
   2109a:	781a      	ldrb	r2, [r3, #0]
   2109c:	b11a      	cbz	r2, 210a6 <GPSMsgProcess+0x1e>
	{
		app_gps_off = false;
   2109e:	2200      	movs	r2, #0
   210a0:	701a      	strb	r2, [r3, #0]
		gps_off();
   210a2:	f7ff ff4d 	bl	20f40 <gps_off>
	}
	if(gps_data_incoming)
   210a6:	4b07      	ldr	r3, [pc, #28]	; (210c4 <GPSMsgProcess+0x3c>)
   210a8:	781a      	ldrb	r2, [r3, #0]
   210aa:	b12a      	cbz	r2, 210b8 <GPSMsgProcess+0x30>
	{
		gps_data_incoming = false;
   210ac:	2200      	movs	r2, #0
   210ae:	701a      	strb	r2, [r3, #0]
		gps_data_receive();
	}	
}
   210b0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		gps_data_receive();
   210b4:	f7fc b8f8 	b.w	1d2a8 <gps_data_receive>
}
   210b8:	bd08      	pop	{r3, pc}
   210ba:	bf00      	nop
   210bc:	2002473d 	.word	0x2002473d
   210c0:	2002473c 	.word	0x2002473c
   210c4:	20024740 	.word	0x20024740

000210c8 <data_print.constprop.3>:
}
#endif /* defined(CONFIG_LWM2M_CARRIER) */

/**@brief Function to print strings without null-termination
 */
static void data_print(u8_t *prefix, u8_t *data, size_t len)
   210c8:	b5b0      	push	{r4, r5, r7, lr}
{
	char buf[len + 1];
   210ca:	f101 0308 	add.w	r3, r1, #8
   210ce:	f023 0307 	bic.w	r3, r3, #7
static void data_print(u8_t *prefix, u8_t *data, size_t len)
   210d2:	af00      	add	r7, sp, #0
	char buf[len + 1];
   210d4:	ebad 0d03 	sub.w	sp, sp, r3
static void data_print(u8_t *prefix, u8_t *data, size_t len)
   210d8:	4605      	mov	r5, r0
   210da:	460c      	mov	r4, r1
   210dc:	460a      	mov	r2, r1
   210de:	4668      	mov	r0, sp
   210e0:	490b      	ldr	r1, [pc, #44]	; (21110 <data_print.constprop.3+0x48>)
   210e2:	f018 fe4c 	bl	39d7e <memcpy>

	memcpy(buf, data, len);
	buf[len] = 0;
   210e6:	2300      	movs	r3, #0
	LOG_INF("%s%s\n", prefix, buf);
   210e8:	f04f 0000 	mov.w	r0, #0
	buf[len] = 0;
   210ec:	f80d 3004 	strb.w	r3, [sp, r4]
	LOG_INF("%s%s\n", prefix, buf);
   210f0:	2303      	movs	r3, #3
   210f2:	4a08      	ldr	r2, [pc, #32]	; (21114 <data_print.constprop.3+0x4c>)
   210f4:	f363 0007 	bfi	r0, r3, #0, #8
   210f8:	4b07      	ldr	r3, [pc, #28]	; (21118 <data_print.constprop.3+0x50>)
   210fa:	4908      	ldr	r1, [pc, #32]	; (2111c <data_print.constprop.3+0x54>)
   210fc:	1a9b      	subs	r3, r3, r2
   210fe:	08db      	lsrs	r3, r3, #3
   21100:	f363 108f 	bfi	r0, r3, #6, #10
   21104:	462a      	mov	r2, r5
   21106:	466b      	mov	r3, sp
   21108:	f016 fe31 	bl	37d6e <log_string_sync>
}
   2110c:	46bd      	mov	sp, r7
   2110e:	bdb0      	pop	{r4, r5, r7, pc}
   21110:	20024a84 	.word	0x20024a84
   21114:	0003ade0 	.word	0x0003ade0
   21118:	0003aea0 	.word	0x0003aea0
   2111c:	0003f5c3 	.word	0x0003f5c3

00021120 <poll.constprop.6>:
	__ASSERT_NO_MSG(socket_ops->connect);

	return socket_ops->connect(sock, addr, addrlen);
}

static inline int poll(struct pollfd *fds, int nfds, int timeout)
   21120:	b570      	push	{r4, r5, r6, lr}
{
	__ASSERT_NO_MSG(socket_ops);
   21122:	4c11      	ldr	r4, [pc, #68]	; (21168 <poll.constprop.6+0x48>)
static inline int poll(struct pollfd *fds, int nfds, int timeout)
   21124:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(socket_ops);
   21126:	6823      	ldr	r3, [r4, #0]
   21128:	b94b      	cbnz	r3, 2113e <poll.constprop.6+0x1e>
   2112a:	4910      	ldr	r1, [pc, #64]	; (2116c <poll.constprop.6+0x4c>)
   2112c:	4810      	ldr	r0, [pc, #64]	; (21170 <poll.constprop.6+0x50>)
   2112e:	234d      	movs	r3, #77	; 0x4d
   21130:	4a10      	ldr	r2, [pc, #64]	; (21174 <poll.constprop.6+0x54>)
   21132:	f016 fdc5 	bl	37cc0 <printk>
   21136:	214d      	movs	r1, #77	; 0x4d
   21138:	480e      	ldr	r0, [pc, #56]	; (21174 <poll.constprop.6+0x54>)
   2113a:	f016 fe07 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->poll);
   2113e:	6823      	ldr	r3, [r4, #0]
   21140:	699b      	ldr	r3, [r3, #24]
   21142:	b94b      	cbnz	r3, 21158 <poll.constprop.6+0x38>
   21144:	490c      	ldr	r1, [pc, #48]	; (21178 <poll.constprop.6+0x58>)
   21146:	480a      	ldr	r0, [pc, #40]	; (21170 <poll.constprop.6+0x50>)
   21148:	234e      	movs	r3, #78	; 0x4e
   2114a:	4a0a      	ldr	r2, [pc, #40]	; (21174 <poll.constprop.6+0x54>)
   2114c:	f016 fdb8 	bl	37cc0 <printk>
   21150:	214e      	movs	r1, #78	; 0x4e
   21152:	4808      	ldr	r0, [pc, #32]	; (21174 <poll.constprop.6+0x54>)
   21154:	f016 fdfa 	bl	37d4c <assert_post_action>

	return socket_ops->poll(fds, nfds, timeout);
   21158:	6823      	ldr	r3, [r4, #0]
   2115a:	462a      	mov	r2, r5
}
   2115c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return socket_ops->poll(fds, nfds, timeout);
   21160:	699b      	ldr	r3, [r3, #24]
   21162:	2101      	movs	r1, #1
   21164:	4805      	ldr	r0, [pc, #20]	; (2117c <poll.constprop.6+0x5c>)
   21166:	4718      	bx	r3
   21168:	200204c0 	.word	0x200204c0
   2116c:	0003c541 	.word	0x0003c541
   21170:	0003baac 	.word	0x0003baac
   21174:	0003c511 	.word	0x0003c511
   21178:	0003c54c 	.word	0x0003c54c
   2117c:	200203b8 	.word	0x200203b8

00021180 <mqtt_evt_handler>:

/**@brief MQTT client event handler
 */
void mqtt_evt_handler(struct mqtt_client *const c,
		      const struct mqtt_evt *evt)
{
   21180:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   21184:	4abb      	ldr	r2, [pc, #748]	; (21474 <mqtt_evt_handler+0x2f4>)
   21186:	4dbc      	ldr	r5, [pc, #752]	; (21478 <mqtt_evt_handler+0x2f8>)
	int err;

	switch(evt->type)
   21188:	780b      	ldrb	r3, [r1, #0]
   2118a:	1aad      	subs	r5, r5, r2
{
   2118c:	b08d      	sub	sp, #52	; 0x34
   2118e:	4681      	mov	r9, r0
   21190:	460c      	mov	r4, r1
   21192:	f3c5 05c9 	ubfx	r5, r5, #3, #10
	switch(evt->type)
   21196:	2b07      	cmp	r3, #7
   21198:	f200 81e3 	bhi.w	21562 <mqtt_evt_handler+0x3e2>
   2119c:	e8df f013 	tbh	[pc, r3, lsl #1]
   211a0:	00670008 	.word	0x00670008
   211a4:	01570084 	.word	0x01570084
   211a8:	01e101e1 	.word	0x01e101e1
   211ac:	01bf01e1 	.word	0x01bf01e1
	{
	case MQTT_EVT_CONNACK:
		if (evt->result != 0)
		{
			LOG_INF("MQTT connect failed %d\n", evt->result);
   211b0:	f04f 0000 	mov.w	r0, #0
   211b4:	2303      	movs	r3, #3
		if (evt->result != 0)
   211b6:	69ce      	ldr	r6, [r1, #28]
			LOG_INF("MQTT connect failed %d\n", evt->result);
   211b8:	f363 0007 	bfi	r0, r3, #0, #8
   211bc:	f365 108f 	bfi	r0, r5, #6, #10
		if (evt->result != 0)
   211c0:	b17e      	cbz	r6, 211e2 <mqtt_evt_handler+0x62>
			LOG_INF("MQTT connect failed %d\n", evt->result);
   211c2:	4632      	mov	r2, r6
   211c4:	49ad      	ldr	r1, [pc, #692]	; (2147c <mqtt_evt_handler+0x2fc>)
   211c6:	f016 fdd2 	bl	37d6e <log_string_sync>
		#ifdef SHOW_LOG_IN_SCREEN	
			sprintf(tmpbuf, "MQTT connect failed %d", evt->result);
   211ca:	69e3      	ldr	r3, [r4, #28]
   211cc:	9300      	str	r3, [sp, #0]
   211ce:	4bac      	ldr	r3, [pc, #688]	; (21480 <mqtt_evt_handler+0x300>)
	case MQTT_EVT_SUBACK:
		if(evt->result != 0)
		{
			LOG_INF("MQTT SUBACK error %d\n", evt->result);
		#ifdef SHOW_LOG_IN_SCREEN
			sprintf(tmpbuf, "MQTT SUBACK error %d", evt->result);
   211d0:	2280      	movs	r2, #128	; 0x80
   211d2:	2100      	movs	r1, #0
   211d4:	48ab      	ldr	r0, [pc, #684]	; (21484 <mqtt_evt_handler+0x304>)
   211d6:	f018 ff34 	bl	3a042 <__sprintf_chk>
		LOG_INF("[%s:%d] default: %d\n", __func__, __LINE__,
				evt->type);
	#ifdef SHOW_LOG_IN_SCREEN
		sprintf(tmpbuf, "[%s:%d] default: %d", __func__, __LINE__,
				evt->type);
		show_infor(tmpbuf);
   211da:	48aa      	ldr	r0, [pc, #680]	; (21484 <mqtt_evt_handler+0x304>)
   211dc:	f016 f9b3 	bl	37546 <show_infor>
	#endif
		break;
	}
}
   211e0:	e042      	b.n	21268 <mqtt_evt_handler+0xe8>
		LOG_INF("[%s:%d] MQTT client connected!\n", __func__, __LINE__);
   211e2:	4ca9      	ldr	r4, [pc, #676]	; (21488 <mqtt_evt_handler+0x308>)
   211e4:	f44f 7383 	mov.w	r3, #262	; 0x106
   211e8:	4622      	mov	r2, r4
   211ea:	49a8      	ldr	r1, [pc, #672]	; (2148c <mqtt_evt_handler+0x30c>)
   211ec:	f016 fdbf 	bl	37d6e <log_string_sync>
		sprintf(tmpbuf, "[%s:%d] MQTT client connected!", __func__, __LINE__);
   211f0:	f44f 7384 	mov.w	r3, #264	; 0x108
   211f4:	2280      	movs	r2, #128	; 0x80
   211f6:	4631      	mov	r1, r6
   211f8:	e9cd 4300 	strd	r4, r3, [sp]
   211fc:	48a1      	ldr	r0, [pc, #644]	; (21484 <mqtt_evt_handler+0x304>)
	struct mqtt_topic subscribe_topic = {
   211fe:	4ca4      	ldr	r4, [pc, #656]	; (21490 <mqtt_evt_handler+0x310>)
		sprintf(tmpbuf, "[%s:%d] MQTT client connected!", __func__, __LINE__);
   21200:	4ba4      	ldr	r3, [pc, #656]	; (21494 <mqtt_evt_handler+0x314>)
   21202:	f018 ff1e 	bl	3a042 <__sprintf_chk>
		show_infor(tmpbuf);
   21206:	489f      	ldr	r0, [pc, #636]	; (21484 <mqtt_evt_handler+0x304>)
   21208:	f016 f99d 	bl	37546 <show_infor>
			.size = strlen(CONFIG_MQTT_SUB_TOPIC)
   2120c:	4620      	mov	r0, r4
	struct mqtt_topic subscribe_topic = {
   2120e:	9406      	str	r4, [sp, #24]
			.size = strlen(CONFIG_MQTT_SUB_TOPIC)
   21210:	f7fb ffa2 	bl	1d158 <strlen>
	struct mqtt_topic subscribe_topic = {
   21214:	2301      	movs	r3, #1
   21216:	f88d 3020 	strb.w	r3, [sp, #32]
	const struct mqtt_subscription_list subscription_list = {
   2121a:	ab06      	add	r3, sp, #24
   2121c:	9304      	str	r3, [sp, #16]
   2121e:	4b9e      	ldr	r3, [pc, #632]	; (21498 <mqtt_evt_handler+0x318>)
	LOG_INF("Subscribing to: %s len %u\n", CONFIG_MQTT_SUB_TOPIC,
   21220:	f04f 0700 	mov.w	r7, #0
	const struct mqtt_subscription_list subscription_list = {
   21224:	9305      	str	r3, [sp, #20]
	LOG_INF("Subscribing to: %s len %u\n", CONFIG_MQTT_SUB_TOPIC,
   21226:	2303      	movs	r3, #3
	struct mqtt_topic subscribe_topic = {
   21228:	9007      	str	r0, [sp, #28]
	LOG_INF("Subscribing to: %s len %u\n", CONFIG_MQTT_SUB_TOPIC,
   2122a:	4620      	mov	r0, r4
   2122c:	f363 0707 	bfi	r7, r3, #0, #8
   21230:	f7fb ff92 	bl	1d158 <strlen>
   21234:	f365 178f 	bfi	r7, r5, #6, #10
   21238:	4603      	mov	r3, r0
   2123a:	4622      	mov	r2, r4
   2123c:	4997      	ldr	r1, [pc, #604]	; (2149c <mqtt_evt_handler+0x31c>)
   2123e:	4638      	mov	r0, r7
   21240:	f016 fd95 	bl	37d6e <log_string_sync>
	sprintf(tmpbuf, "Subscribing to: %s len %u", CONFIG_MQTT_SUB_TOPIC,
   21244:	4620      	mov	r0, r4
   21246:	f7fb ff87 	bl	1d158 <strlen>
   2124a:	4631      	mov	r1, r6
   2124c:	e9cd 4000 	strd	r4, r0, [sp]
   21250:	4b93      	ldr	r3, [pc, #588]	; (214a0 <mqtt_evt_handler+0x320>)
   21252:	2280      	movs	r2, #128	; 0x80
   21254:	488b      	ldr	r0, [pc, #556]	; (21484 <mqtt_evt_handler+0x304>)
   21256:	f018 fef4 	bl	3a042 <__sprintf_chk>
	show_infor(tmpbuf);
   2125a:	488a      	ldr	r0, [pc, #552]	; (21484 <mqtt_evt_handler+0x304>)
   2125c:	f016 f973 	bl	37546 <show_infor>
	return mqtt_subscribe(&client, &subscription_list);
   21260:	a904      	add	r1, sp, #16
   21262:	4890      	ldr	r0, [pc, #576]	; (214a4 <mqtt_evt_handler+0x324>)
   21264:	f017 fb16 	bl	38894 <mqtt_subscribe>
}
   21268:	b00d      	add	sp, #52	; 0x34
   2126a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		LOG_INF("[%s:%d] MQTT client disconnected %d\n", __func__,
   2126e:	2303      	movs	r3, #3
   21270:	f04f 0000 	mov.w	r0, #0
   21274:	f363 0007 	bfi	r0, r3, #0, #8
   21278:	f365 108f 	bfi	r0, r5, #6, #10
   2127c:	69cb      	ldr	r3, [r1, #28]
   2127e:	4d82      	ldr	r5, [pc, #520]	; (21488 <mqtt_evt_handler+0x308>)
   21280:	9300      	str	r3, [sp, #0]
   21282:	462a      	mov	r2, r5
   21284:	f44f 7388 	mov.w	r3, #272	; 0x110
   21288:	4987      	ldr	r1, [pc, #540]	; (214a8 <mqtt_evt_handler+0x328>)
   2128a:	f016 fd70 	bl	37d6e <log_string_sync>
		sprintf(tmpbuf, "[%s:%d] MQTT client disconnected %d", __func__,
   2128e:	69e3      	ldr	r3, [r4, #28]
   21290:	9302      	str	r3, [sp, #8]
   21292:	f240 1313 	movw	r3, #275	; 0x113
   21296:	e9cd 5300 	strd	r5, r3, [sp]
   2129a:	4b84      	ldr	r3, [pc, #528]	; (214ac <mqtt_evt_handler+0x32c>)
		sprintf(tmpbuf, "[%s:%d] default: %d", __func__, __LINE__,
   2129c:	2280      	movs	r2, #128	; 0x80
   2129e:	2100      	movs	r1, #0
   212a0:	4878      	ldr	r0, [pc, #480]	; (21484 <mqtt_evt_handler+0x304>)
   212a2:	f018 fece 	bl	3a042 <__sprintf_chk>
   212a6:	e798      	b.n	211da <mqtt_evt_handler+0x5a>
			LOG_INF("[%s:%d] MQTT PUBLISH result=%d len=%d\n", __func__,
   212a8:	2303      	movs	r3, #3
   212aa:	f04f 0000 	mov.w	r0, #0
   212ae:	f363 0007 	bfi	r0, r3, #0, #8
   212b2:	694b      	ldr	r3, [r1, #20]
   212b4:	4e74      	ldr	r6, [pc, #464]	; (21488 <mqtt_evt_handler+0x308>)
   212b6:	9301      	str	r3, [sp, #4]
   212b8:	69cb      	ldr	r3, [r1, #28]
   212ba:	f365 108f 	bfi	r0, r5, #6, #10
   212be:	9300      	str	r3, [sp, #0]
   212c0:	4632      	mov	r2, r6
   212c2:	f240 131f 	movw	r3, #287	; 0x11f
   212c6:	497a      	ldr	r1, [pc, #488]	; (214b0 <mqtt_evt_handler+0x330>)
   212c8:	f016 fd51 	bl	37d6e <log_string_sync>
			sprintf(tmpbuf, "[%s:%d] MQTT PUBLISH result=%d len=%d", __func__,
   212cc:	6963      	ldr	r3, [r4, #20]
   212ce:	2280      	movs	r2, #128	; 0x80
   212d0:	9303      	str	r3, [sp, #12]
   212d2:	69e3      	ldr	r3, [r4, #28]
   212d4:	2100      	movs	r1, #0
   212d6:	9302      	str	r3, [sp, #8]
   212d8:	f44f 7391 	mov.w	r3, #290	; 0x122
   212dc:	4869      	ldr	r0, [pc, #420]	; (21484 <mqtt_evt_handler+0x304>)
   212de:	e9cd 6300 	strd	r6, r3, [sp]
   212e2:	4b74      	ldr	r3, [pc, #464]	; (214b4 <mqtt_evt_handler+0x334>)
   212e4:	f018 fead 	bl	3a042 <__sprintf_chk>
			show_infor(tmpbuf);
   212e8:	4866      	ldr	r0, [pc, #408]	; (21484 <mqtt_evt_handler+0x304>)
   212ea:	f016 f92c 	bl	37546 <show_infor>
			err = publish_get_payload(c, p->message.payload.len);
   212ee:	6963      	ldr	r3, [r4, #20]
	u8_t *end = buf + length;
   212f0:	4f71      	ldr	r7, [pc, #452]	; (214b8 <mqtt_evt_handler+0x338>)
	if (length > sizeof(payload_buf)) {
   212f2:	2b80      	cmp	r3, #128	; 0x80
	u8_t *end = buf + length;
   212f4:	eb07 0a03 	add.w	sl, r7, r3
	if (length > sizeof(payload_buf)) {
   212f8:	f200 80a6 	bhi.w	21448 <mqtt_evt_handler+0x2c8>
	u8_t *buf = payload_buf;
   212fc:	46bb      	mov	fp, r7
	while (buf < end) {
   212fe:	45da      	cmp	sl, fp
   21300:	d840      	bhi.n	21384 <mqtt_evt_handler+0x204>
				data_print("Received: ", payload_buf,
   21302:	6961      	ldr	r1, [r4, #20]
   21304:	486d      	ldr	r0, [pc, #436]	; (214bc <mqtt_evt_handler+0x33c>)
   21306:	f7ff fedf 	bl	210c8 <data_print.constprop.3>
	param.message.topic.qos = qos;
   2130a:	2301      	movs	r3, #1
				data_publish(&client, MQTT_QOS_1_AT_LEAST_ONCE,
   2130c:	6966      	ldr	r6, [r4, #20]
	param.message.topic.topic.utf8 = CONFIG_MQTT_PUB_TOPIC;
   2130e:	4c6c      	ldr	r4, [pc, #432]	; (214c0 <mqtt_evt_handler+0x340>)
	param.message.topic.qos = qos;
   21310:	f88d 3020 	strb.w	r3, [sp, #32]
	param.message.topic.topic.size = strlen(CONFIG_MQTT_PUB_TOPIC);
   21314:	4620      	mov	r0, r4
	param.message.topic.topic.utf8 = CONFIG_MQTT_PUB_TOPIC;
   21316:	9406      	str	r4, [sp, #24]
	param.message.topic.topic.size = strlen(CONFIG_MQTT_PUB_TOPIC);
   21318:	f7fb ff1e 	bl	1d158 <strlen>
	param.message.payload.len = len;
   2131c:	e9cd 7609 	strd	r7, r6, [sp, #36]	; 0x24
	param.message.topic.topic.size = strlen(CONFIG_MQTT_PUB_TOPIC);
   21320:	9007      	str	r0, [sp, #28]
	param.message_id = sys_rand32_get();
   21322:	f005 fb59 	bl	269d8 <sys_rand32_get>
	param.dup_flag = 0;
   21326:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
	data_print("Publishing: ", data, len);
   2132a:	4631      	mov	r1, r6
	param.message_id = sys_rand32_get();
   2132c:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
	param.dup_flag = 0;
   21330:	f023 0303 	bic.w	r3, r3, #3
	data_print("Publishing: ", data, len);
   21334:	4863      	ldr	r0, [pc, #396]	; (214c4 <mqtt_evt_handler+0x344>)
	param.dup_flag = 0;
   21336:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
	LOG_INF("to topic: %s len: %u\n",
   2133a:	f04f 0600 	mov.w	r6, #0
	data_print("Publishing: ", data, len);
   2133e:	f7ff fec3 	bl	210c8 <data_print.constprop.3>
	LOG_INF("to topic: %s len: %u\n",
   21342:	2303      	movs	r3, #3
   21344:	4620      	mov	r0, r4
   21346:	f363 0607 	bfi	r6, r3, #0, #8
   2134a:	f7fb ff05 	bl	1d158 <strlen>
   2134e:	f365 168f 	bfi	r6, r5, #6, #10
   21352:	4603      	mov	r3, r0
   21354:	4622      	mov	r2, r4
   21356:	495c      	ldr	r1, [pc, #368]	; (214c8 <mqtt_evt_handler+0x348>)
   21358:	4630      	mov	r0, r6
   2135a:	f016 fd08 	bl	37d6e <log_string_sync>
	sprintf(tmpbuf, "to topic: %s len: %u",
   2135e:	4620      	mov	r0, r4
   21360:	f7fb fefa 	bl	1d158 <strlen>
   21364:	4b59      	ldr	r3, [pc, #356]	; (214cc <mqtt_evt_handler+0x34c>)
   21366:	e9cd 4000 	strd	r4, r0, [sp]
   2136a:	2280      	movs	r2, #128	; 0x80
   2136c:	2100      	movs	r1, #0
   2136e:	4845      	ldr	r0, [pc, #276]	; (21484 <mqtt_evt_handler+0x304>)
   21370:	f018 fe67 	bl	3a042 <__sprintf_chk>
	show_infor(tmpbuf);
   21374:	4843      	ldr	r0, [pc, #268]	; (21484 <mqtt_evt_handler+0x304>)
   21376:	f016 f8e6 	bl	37546 <show_infor>
	return mqtt_publish(c, &param);
   2137a:	a906      	add	r1, sp, #24
   2137c:	4849      	ldr	r0, [pc, #292]	; (214a4 <mqtt_evt_handler+0x324>)
   2137e:	f017 fa32 	bl	387e6 <mqtt_publish>
   21382:	e771      	b.n	21268 <mqtt_evt_handler+0xe8>
		int ret = mqtt_read_publish_payload(c, buf, end - buf);
   21384:	ebaa 020b 	sub.w	r2, sl, fp
   21388:	4659      	mov	r1, fp
   2138a:	4648      	mov	r0, r9
   2138c:	f017 fb33 	bl	389f6 <mqtt_read_publish_payload>
		if (ret < 0) {
   21390:	1e06      	subs	r6, r0, #0
   21392:	da56      	bge.n	21442 <mqtt_evt_handler+0x2c2>
			if (ret != -EAGAIN) {
   21394:	f116 0f0b 	cmn.w	r6, #11
   21398:	d116      	bne.n	213c8 <mqtt_evt_handler+0x248>
			LOG_INF("mqtt_read_publish_payload: EAGAIN\n");
   2139a:	f028 023f 	bic.w	r2, r8, #63	; 0x3f
   2139e:	f042 0203 	orr.w	r2, r2, #3
   213a2:	f362 0807 	bfi	r8, r2, #0, #8
   213a6:	f365 188f 	bfi	r8, r5, #6, #10
   213aa:	4949      	ldr	r1, [pc, #292]	; (214d0 <mqtt_evt_handler+0x350>)
   213ac:	4640      	mov	r0, r8
   213ae:	f016 fcde 	bl	37d6e <log_string_sync>
			show_infor("mqtt_read_publish_payload: EAGAIN");
   213b2:	4848      	ldr	r0, [pc, #288]	; (214d4 <mqtt_evt_handler+0x354>)
   213b4:	f016 f8c7 	bl	37546 <show_infor>
			err = poll(&fds, 1,
   213b8:	f64e 2060 	movw	r0, #60000	; 0xea60
   213bc:	f7ff feb0 	bl	21120 <poll.constprop.6>
			if (err > 0 && (fds.revents & POLLIN) == POLLIN) {
   213c0:	2800      	cmp	r0, #0
   213c2:	dc38      	bgt.n	21436 <mqtt_evt_handler+0x2b6>
				return -EIO;
   213c4:	f06f 0604 	mvn.w	r6, #4
				LOG_INF("mqtt_read_publish_payload: Failed! %d\n", err);
   213c8:	2303      	movs	r3, #3
   213ca:	f04f 0000 	mov.w	r0, #0
   213ce:	f363 0007 	bfi	r0, r3, #0, #8
   213d2:	4632      	mov	r2, r6
   213d4:	f365 108f 	bfi	r0, r5, #6, #10
   213d8:	493f      	ldr	r1, [pc, #252]	; (214d8 <mqtt_evt_handler+0x358>)
   213da:	f016 fcc8 	bl	37d6e <log_string_sync>
				LOG_INF("Disconnecting MQTT client...\n");
   213de:	2303      	movs	r3, #3
   213e0:	f04f 0000 	mov.w	r0, #0
   213e4:	f363 0007 	bfi	r0, r3, #0, #8
   213e8:	f365 108f 	bfi	r0, r5, #6, #10
   213ec:	493b      	ldr	r1, [pc, #236]	; (214dc <mqtt_evt_handler+0x35c>)
   213ee:	f016 fcbe 	bl	37d6e <log_string_sync>
				sprintf(tmpbuf, "mqtt_read_publish_payload: Failed! %d", err);
   213f2:	4b3b      	ldr	r3, [pc, #236]	; (214e0 <mqtt_evt_handler+0x360>)
   213f4:	2280      	movs	r2, #128	; 0x80
   213f6:	2100      	movs	r1, #0
   213f8:	9600      	str	r6, [sp, #0]
   213fa:	4822      	ldr	r0, [pc, #136]	; (21484 <mqtt_evt_handler+0x304>)
   213fc:	f018 fe21 	bl	3a042 <__sprintf_chk>
				show_infor(tmpbuf);
   21400:	4820      	ldr	r0, [pc, #128]	; (21484 <mqtt_evt_handler+0x304>)
   21402:	f016 f8a0 	bl	37546 <show_infor>
				show_infor("Disconnecting MQTT client...");
   21406:	4837      	ldr	r0, [pc, #220]	; (214e4 <mqtt_evt_handler+0x364>)
   21408:	f016 f89d 	bl	37546 <show_infor>
				err = mqtt_disconnect(c);
   2140c:	4648      	mov	r0, r9
   2140e:	f017 fa18 	bl	38842 <mqtt_disconnect>
				if(err)
   21412:	4604      	mov	r4, r0
   21414:	2800      	cmp	r0, #0
   21416:	f43f af27 	beq.w	21268 <mqtt_evt_handler+0xe8>
					LOG_INF("Could not disconnect: %d\n", err);
   2141a:	2303      	movs	r3, #3
   2141c:	f04f 0000 	mov.w	r0, #0
   21420:	f363 0007 	bfi	r0, r3, #0, #8
   21424:	f365 108f 	bfi	r0, r5, #6, #10
   21428:	4622      	mov	r2, r4
   2142a:	492f      	ldr	r1, [pc, #188]	; (214e8 <mqtt_evt_handler+0x368>)
   2142c:	f016 fc9f 	bl	37d6e <log_string_sync>
					sprintf(tmpbuf, "Could not disconnect: %d", err);
   21430:	9400      	str	r4, [sp, #0]
   21432:	4b2e      	ldr	r3, [pc, #184]	; (214ec <mqtt_evt_handler+0x36c>)
   21434:	e6cc      	b.n	211d0 <mqtt_evt_handler+0x50>
			if (err > 0 && (fds.revents & POLLIN) == POLLIN) {
   21436:	4b2e      	ldr	r3, [pc, #184]	; (214f0 <mqtt_evt_handler+0x370>)
   21438:	88da      	ldrh	r2, [r3, #6]
   2143a:	07d3      	lsls	r3, r2, #31
   2143c:	f53f af5f 	bmi.w	212fe <mqtt_evt_handler+0x17e>
   21440:	e7c0      	b.n	213c4 <mqtt_evt_handler+0x244>
		if (ret == 0) {
   21442:	d0bf      	beq.n	213c4 <mqtt_evt_handler+0x244>
		buf += ret;
   21444:	44b3      	add	fp, r6
   21446:	e75a      	b.n	212fe <mqtt_evt_handler+0x17e>
		return -EMSGSIZE;
   21448:	f06f 0679 	mvn.w	r6, #121	; 0x79
   2144c:	e7bc      	b.n	213c8 <mqtt_evt_handler+0x248>
			LOG_INF("MQTT PUBACK error %d\n", evt->result);
   2144e:	f04f 0000 	mov.w	r0, #0
   21452:	2303      	movs	r3, #3
		if(evt->result != 0)
   21454:	69ce      	ldr	r6, [r1, #28]
			LOG_INF("MQTT PUBACK error %d\n", evt->result);
   21456:	f363 0007 	bfi	r0, r3, #0, #8
   2145a:	f365 108f 	bfi	r0, r5, #6, #10
		if(evt->result != 0)
   2145e:	2e00      	cmp	r6, #0
   21460:	d04c      	beq.n	214fc <mqtt_evt_handler+0x37c>
			LOG_INF("MQTT PUBACK error %d\n", evt->result);
   21462:	4632      	mov	r2, r6
   21464:	4923      	ldr	r1, [pc, #140]	; (214f4 <mqtt_evt_handler+0x374>)
   21466:	f016 fc82 	bl	37d6e <log_string_sync>
			sprintf(tmpbuf, "MQTT PUBACK error %d", evt->result);
   2146a:	69e3      	ldr	r3, [r4, #28]
   2146c:	9300      	str	r3, [sp, #0]
   2146e:	4b22      	ldr	r3, [pc, #136]	; (214f8 <mqtt_evt_handler+0x378>)
   21470:	e6ae      	b.n	211d0 <mqtt_evt_handler+0x50>
   21472:	bf00      	nop
   21474:	0003ade0 	.word	0x0003ade0
   21478:	0003aea0 	.word	0x0003aea0
   2147c:	0003c17c 	.word	0x0003c17c
   21480:	0003c194 	.word	0x0003c194
   21484:	20024b84 	.word	0x20024b84
   21488:	0003c16b 	.word	0x0003c16b
   2148c:	0003c1ab 	.word	0x0003c1ab
   21490:	0003c1ea 	.word	0x0003c1ea
   21494:	0003c1cb 	.word	0x0003c1cb
   21498:	04d20001 	.word	0x04d20001
   2149c:	0003c1fd 	.word	0x0003c1fd
   214a0:	0003c218 	.word	0x0003c218
   214a4:	2002033c 	.word	0x2002033c
   214a8:	0003c232 	.word	0x0003c232
   214ac:	0003c257 	.word	0x0003c257
   214b0:	0003c27b 	.word	0x0003c27b
   214b4:	0003c2a2 	.word	0x0003c2a2
   214b8:	20024a84 	.word	0x20024a84
   214bc:	0003c4bd 	.word	0x0003c4bd
   214c0:	0003c4c8 	.word	0x0003c4c8
   214c4:	0003c4d9 	.word	0x0003c4d9
   214c8:	0003c4e6 	.word	0x0003c4e6
   214cc:	0003c4fc 	.word	0x0003c4fc
   214d0:	0003c2c8 	.word	0x0003c2c8
   214d4:	0003c2eb 	.word	0x0003c2eb
   214d8:	0003c30d 	.word	0x0003c30d
   214dc:	0003c334 	.word	0x0003c334
   214e0:	0003c352 	.word	0x0003c352
   214e4:	0003c378 	.word	0x0003c378
   214e8:	0003c395 	.word	0x0003c395
   214ec:	0003c3af 	.word	0x0003c3af
   214f0:	200203b8 	.word	0x200203b8
   214f4:	0003c3c8 	.word	0x0003c3c8
   214f8:	0003c3de 	.word	0x0003c3de
		LOG_INF("[%s:%d] PUBACK packet id: %u\n", __func__, __LINE__,
   214fc:	888b      	ldrh	r3, [r1, #4]
   214fe:	4d24      	ldr	r5, [pc, #144]	; (21590 <mqtt_evt_handler+0x410>)
   21500:	9300      	str	r3, [sp, #0]
   21502:	462a      	mov	r2, r5
   21504:	f44f 73a9 	mov.w	r3, #338	; 0x152
   21508:	4922      	ldr	r1, [pc, #136]	; (21594 <mqtt_evt_handler+0x414>)
   2150a:	f016 fc30 	bl	37d6e <log_string_sync>
		sprintf(tmpbuf, "[%s:%d] PUBACK packet id: %u", __func__, __LINE__,
   2150e:	88a3      	ldrh	r3, [r4, #4]
   21510:	9302      	str	r3, [sp, #8]
   21512:	f240 1355 	movw	r3, #341	; 0x155
   21516:	e9cd 5300 	strd	r5, r3, [sp]
   2151a:	4b1f      	ldr	r3, [pc, #124]	; (21598 <mqtt_evt_handler+0x418>)
   2151c:	e6be      	b.n	2129c <mqtt_evt_handler+0x11c>
			LOG_INF("MQTT SUBACK error %d\n", evt->result);
   2151e:	f04f 0000 	mov.w	r0, #0
   21522:	2303      	movs	r3, #3
		if(evt->result != 0)
   21524:	69ce      	ldr	r6, [r1, #28]
			LOG_INF("MQTT SUBACK error %d\n", evt->result);
   21526:	f363 0007 	bfi	r0, r3, #0, #8
   2152a:	f365 108f 	bfi	r0, r5, #6, #10
		if(evt->result != 0)
   2152e:	b13e      	cbz	r6, 21540 <mqtt_evt_handler+0x3c0>
			LOG_INF("MQTT SUBACK error %d\n", evt->result);
   21530:	4632      	mov	r2, r6
   21532:	491a      	ldr	r1, [pc, #104]	; (2159c <mqtt_evt_handler+0x41c>)
   21534:	f016 fc1b 	bl	37d6e <log_string_sync>
			sprintf(tmpbuf, "MQTT SUBACK error %d", evt->result);
   21538:	69e3      	ldr	r3, [r4, #28]
   2153a:	9300      	str	r3, [sp, #0]
   2153c:	4b18      	ldr	r3, [pc, #96]	; (215a0 <mqtt_evt_handler+0x420>)
   2153e:	e647      	b.n	211d0 <mqtt_evt_handler+0x50>
		LOG_INF("[%s:%d] SUBACK packet id: %u\n", __func__, __LINE__,
   21540:	888b      	ldrh	r3, [r1, #4]
   21542:	4d13      	ldr	r5, [pc, #76]	; (21590 <mqtt_evt_handler+0x410>)
   21544:	9300      	str	r3, [sp, #0]
   21546:	462a      	mov	r2, r5
   21548:	f44f 73b3 	mov.w	r3, #358	; 0x166
   2154c:	4915      	ldr	r1, [pc, #84]	; (215a4 <mqtt_evt_handler+0x424>)
   2154e:	f016 fc0e 	bl	37d6e <log_string_sync>
		sprintf(tmpbuf, "[%s:%d] SUBACK packet id: %u", __func__, __LINE__,
   21552:	88a3      	ldrh	r3, [r4, #4]
   21554:	9302      	str	r3, [sp, #8]
   21556:	f240 1369 	movw	r3, #361	; 0x169
   2155a:	e9cd 5300 	strd	r5, r3, [sp]
   2155e:	4b12      	ldr	r3, [pc, #72]	; (215a8 <mqtt_evt_handler+0x428>)
   21560:	e69c      	b.n	2129c <mqtt_evt_handler+0x11c>
		LOG_INF("[%s:%d] default: %d\n", __func__, __LINE__,
   21562:	2203      	movs	r2, #3
   21564:	f04f 0000 	mov.w	r0, #0
   21568:	f362 0007 	bfi	r0, r2, #0, #8
   2156c:	f365 108f 	bfi	r0, r5, #6, #10
   21570:	4d07      	ldr	r5, [pc, #28]	; (21590 <mqtt_evt_handler+0x410>)
	switch(evt->type)
   21572:	9300      	str	r3, [sp, #0]
		LOG_INF("[%s:%d] default: %d\n", __func__, __LINE__,
   21574:	462a      	mov	r2, r5
   21576:	f44f 73b8 	mov.w	r3, #368	; 0x170
   2157a:	490c      	ldr	r1, [pc, #48]	; (215ac <mqtt_evt_handler+0x42c>)
   2157c:	f016 fbf7 	bl	37d6e <log_string_sync>
		sprintf(tmpbuf, "[%s:%d] default: %d", __func__, __LINE__,
   21580:	7823      	ldrb	r3, [r4, #0]
   21582:	9302      	str	r3, [sp, #8]
   21584:	f240 1373 	movw	r3, #371	; 0x173
   21588:	e9cd 5300 	strd	r5, r3, [sp]
   2158c:	4b08      	ldr	r3, [pc, #32]	; (215b0 <mqtt_evt_handler+0x430>)
   2158e:	e685      	b.n	2129c <mqtt_evt_handler+0x11c>
   21590:	0003c16b 	.word	0x0003c16b
   21594:	0003c3f3 	.word	0x0003c3f3
   21598:	0003c411 	.word	0x0003c411
   2159c:	0003c42e 	.word	0x0003c42e
   215a0:	0003c444 	.word	0x0003c444
   215a4:	0003c459 	.word	0x0003c459
   215a8:	0003c477 	.word	0x0003c477
   215ac:	0003c494 	.word	0x0003c494
   215b0:	0003c4a9 	.word	0x0003c4a9

000215b4 <test_nb>:

void test_nb(void)
{
	int err;

	LOG_INF("Start NB-IoT test!\n");
   215b4:	2303      	movs	r3, #3
   215b6:	f04f 0000 	mov.w	r0, #0
{
   215ba:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	LOG_INF("Start NB-IoT test!\n");
   215be:	f363 0007 	bfi	r0, r3, #0, #8
   215c2:	4da2      	ldr	r5, [pc, #648]	; (2184c <test_nb+0x298>)
   215c4:	4ba2      	ldr	r3, [pc, #648]	; (21850 <test_nb+0x29c>)
{
   215c6:	b093      	sub	sp, #76	; 0x4c
	LOG_INF("Start NB-IoT test!\n");
   215c8:	1aed      	subs	r5, r5, r3
   215ca:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   215ce:	49a1      	ldr	r1, [pc, #644]	; (21854 <test_nb+0x2a0>)
   215d0:	f365 108f 	bfi	r0, r5, #6, #10
   215d4:	f016 fbcb 	bl	37d6e <log_string_sync>

#ifdef SHOW_LOG_IN_SCREEN
	show_infor("Start NB-IoT test!");
   215d8:	489f      	ldr	r0, [pc, #636]	; (21858 <test_nb+0x2a4>)
   215da:	f015 ffb4 	bl	37546 <show_infor>
	show_infor("modem_configure");
   215de:	489f      	ldr	r0, [pc, #636]	; (2185c <test_nb+0x2a8>)
   215e0:	f015 ffb1 	bl	37546 <show_infor>
	if(at_cmd_write("AT%CESQ=1", NULL, 0, NULL) != 0)
   215e4:	2300      	movs	r3, #0
   215e6:	489e      	ldr	r0, [pc, #632]	; (21860 <test_nb+0x2ac>)
   215e8:	461a      	mov	r2, r3
   215ea:	4619      	mov	r1, r3
   215ec:	f006 fe7e 	bl	282ec <at_cmd_write>
   215f0:	2800      	cmp	r0, #0
   215f2:	f000 8093 	beq.w	2171c <test_nb+0x168>
		LOG_INF("AT_CMD write fail!\n");
   215f6:	f04f 0000 	mov.w	r0, #0
   215fa:	2303      	movs	r3, #3
   215fc:	f363 0007 	bfi	r0, r3, #0, #8
   21600:	f365 108f 	bfi	r0, r5, #6, #10
   21604:	4997      	ldr	r1, [pc, #604]	; (21864 <test_nb+0x2b0>)
   21606:	f016 fbb2 	bl	37d6e <log_string_sync>
	mqtt_client_init(client);
   2160a:	4897      	ldr	r0, [pc, #604]	; (21868 <test_nb+0x2b4>)
   2160c:	f017 f88e 	bl	3872c <mqtt_client_init>
	struct addrinfo hints = {
   21610:	2220      	movs	r2, #32
   21612:	2100      	movs	r1, #0
   21614:	a80a      	add	r0, sp, #40	; 0x28
   21616:	f018 fbd2 	bl	39dbe <memset>
   2161a:	2301      	movs	r3, #1

static inline int getaddrinfo(const char *node, const char *service,
			      const struct addrinfo *hints,
			      struct addrinfo **res)
{
	__ASSERT_NO_MSG(socket_ops);
   2161c:	4c93      	ldr	r4, [pc, #588]	; (2186c <test_nb+0x2b8>)
   2161e:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
   21622:	6823      	ldr	r3, [r4, #0]
   21624:	b94b      	cbnz	r3, 2163a <test_nb+0x86>
   21626:	4992      	ldr	r1, [pc, #584]	; (21870 <test_nb+0x2bc>)
   21628:	4892      	ldr	r0, [pc, #584]	; (21874 <test_nb+0x2c0>)
   2162a:	2393      	movs	r3, #147	; 0x93
   2162c:	4a92      	ldr	r2, [pc, #584]	; (21878 <test_nb+0x2c4>)
   2162e:	f016 fb47 	bl	37cc0 <printk>
   21632:	2193      	movs	r1, #147	; 0x93
   21634:	4890      	ldr	r0, [pc, #576]	; (21878 <test_nb+0x2c4>)
   21636:	f016 fb89 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->getaddrinfo);
   2163a:	6823      	ldr	r3, [r4, #0]
   2163c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   2163e:	b94b      	cbnz	r3, 21654 <test_nb+0xa0>
   21640:	498e      	ldr	r1, [pc, #568]	; (2187c <test_nb+0x2c8>)
   21642:	488c      	ldr	r0, [pc, #560]	; (21874 <test_nb+0x2c0>)
   21644:	2394      	movs	r3, #148	; 0x94
   21646:	4a8c      	ldr	r2, [pc, #560]	; (21878 <test_nb+0x2c4>)
   21648:	f016 fb3a 	bl	37cc0 <printk>
   2164c:	2194      	movs	r1, #148	; 0x94
   2164e:	488a      	ldr	r0, [pc, #552]	; (21878 <test_nb+0x2c4>)
   21650:	f016 fb7c 	bl	37d4c <assert_post_action>

	return socket_ops->getaddrinfo(node, service, hints, res);
   21654:	6823      	ldr	r3, [r4, #0]
   21656:	aa0a      	add	r2, sp, #40	; 0x28
   21658:	6b5e      	ldr	r6, [r3, #52]	; 0x34
   2165a:	2100      	movs	r1, #0
   2165c:	ab05      	add	r3, sp, #20
   2165e:	4888      	ldr	r0, [pc, #544]	; (21880 <test_nb+0x2cc>)
   21660:	47b0      	blx	r6
	if(err)
   21662:	4e88      	ldr	r6, [pc, #544]	; (21884 <test_nb+0x2d0>)
   21664:	4607      	mov	r7, r0
   21666:	2800      	cmp	r0, #0
   21668:	f000 8085 	beq.w	21776 <test_nb+0x1c2>
		LOG_INF("ERROR: getaddrinfo failed %d\n", err);
   2166c:	2303      	movs	r3, #3
   2166e:	f04f 0000 	mov.w	r0, #0
   21672:	f363 0007 	bfi	r0, r3, #0, #8
   21676:	f365 108f 	bfi	r0, r5, #6, #10
   2167a:	463a      	mov	r2, r7
   2167c:	4982      	ldr	r1, [pc, #520]	; (21888 <test_nb+0x2d4>)
   2167e:	f016 fb76 	bl	37d6e <log_string_sync>
		sprintf(tmpbuf, "ERROR: getaddrinfo failed %d", err);
   21682:	9700      	str	r7, [sp, #0]
   21684:	4b81      	ldr	r3, [pc, #516]	; (2188c <test_nb+0x2d8>)
   21686:	2280      	movs	r2, #128	; 0x80
   21688:	2100      	movs	r1, #0
   2168a:	4881      	ldr	r0, [pc, #516]	; (21890 <test_nb+0x2dc>)
   2168c:	f018 fcd9 	bl	3a042 <__sprintf_chk>
		show_infor(tmpbuf);	
   21690:	487f      	ldr	r0, [pc, #508]	; (21890 <test_nb+0x2dc>)
   21692:	f015 ff58 	bl	37546 <show_infor>
	client->broker = &broker;
   21696:	4c74      	ldr	r4, [pc, #464]	; (21868 <test_nb+0x2b4>)
	client->evt_cb = mqtt_evt_handler;
   21698:	4b7e      	ldr	r3, [pc, #504]	; (21894 <test_nb+0x2e0>)
	client->client_id.utf8 = (u8_t *)CONFIG_MQTT_CLIENT_ID;
   2169a:	487f      	ldr	r0, [pc, #508]	; (21898 <test_nb+0x2e4>)
	client->broker = &broker;
   2169c:	64e6      	str	r6, [r4, #76]	; 0x4c
	client->evt_cb = mqtt_evt_handler;
   2169e:	6623      	str	r3, [r4, #96]	; 0x60
	client->client_id.utf8 = (u8_t *)CONFIG_MQTT_CLIENT_ID;
   216a0:	6460      	str	r0, [r4, #68]	; 0x44
	client->client_id.size = strlen(CONFIG_MQTT_CLIENT_ID);
   216a2:	f7fb fd59 	bl	1d158 <strlen>
	client->protocol_version = MQTT_VERSION_3_1_1;
   216a6:	2304      	movs	r3, #4
	client->rx_buf_size = sizeof(rx_buffer);
   216a8:	f04f 0880 	mov.w	r8, #128	; 0x80
	client->password = NULL;
   216ac:	2600      	movs	r6, #0
    client->transport.type = MQTT_TRANSPORT_SECURE;
   216ae:	2701      	movs	r7, #1
	client->protocol_version = MQTT_VERSION_3_1_1;
   216b0:	f884 3076 	strb.w	r3, [r4, #118]	; 0x76
	client->rx_buf = rx_buffer;
   216b4:	4b79      	ldr	r3, [pc, #484]	; (2189c <test_nb+0x2e8>)
	client->client_id.size = strlen(CONFIG_MQTT_CLIENT_ID);
   216b6:	64a0      	str	r0, [r4, #72]	; 0x48
	client->rx_buf = rx_buffer;
   216b8:	6663      	str	r3, [r4, #100]	; 0x64
	client->tx_buf = tx_buffer;
   216ba:	4b79      	ldr	r3, [pc, #484]	; (218a0 <test_nb+0x2ec>)
    tls_config->cipher_count = 0;
   216bc:	e9c4 760b 	strd	r7, r6, [r4, #44]	; 0x2c
	client->tx_buf_size = sizeof(tx_buffer);
   216c0:	e9c4 381b 	strd	r3, r8, [r4, #108]	; 0x6c
    tls_config->sec_tag_list = sec_tag_list;
   216c4:	4b77      	ldr	r3, [pc, #476]	; (218a4 <test_nb+0x2f0>)
    tls_config->sec_tag_count = ARRAY_SIZE(sec_tag_list);
   216c6:	e9c4 670d 	strd	r6, r7, [r4, #52]	; 0x34
    tls_config->sec_tag_list = sec_tag_list;
   216ca:	63e3      	str	r3, [r4, #60]	; 0x3c
    tls_config->hostname = CONFIG_MQTT_BROKER_HOSTNAME;
   216cc:	4b6c      	ldr	r3, [pc, #432]	; (21880 <test_nb+0x2cc>)

	modem_configure();

	client_init(&client);

	err = mqtt_connect(&client);
   216ce:	4620      	mov	r0, r4
    tls_config->hostname = CONFIG_MQTT_BROKER_HOSTNAME;
   216d0:	6423      	str	r3, [r4, #64]	; 0x40
	client->user_name = NULL;
   216d2:	e9c4 6614 	strd	r6, r6, [r4, #80]	; 0x50
	client->rx_buf_size = sizeof(rx_buffer);
   216d6:	f8c4 8068 	str.w	r8, [r4, #104]	; 0x68
    client->transport.type = MQTT_TRANSPORT_SECURE;
   216da:	f884 7024 	strb.w	r7, [r4, #36]	; 0x24
	err = mqtt_connect(&client);
   216de:	f017 f83e 	bl	3875e <mqtt_connect>
	if(err != 0)
   216e2:	4681      	mov	r9, r0
   216e4:	2800      	cmp	r0, #0
   216e6:	f000 80fb 	beq.w	218e0 <test_nb+0x32c>
	{
		LOG_INF("ERROR: mqtt_connect %d\n", err);
   216ea:	2303      	movs	r3, #3
   216ec:	f04f 0000 	mov.w	r0, #0
   216f0:	f363 0007 	bfi	r0, r3, #0, #8
   216f4:	f365 108f 	bfi	r0, r5, #6, #10
   216f8:	464a      	mov	r2, r9
   216fa:	496b      	ldr	r1, [pc, #428]	; (218a8 <test_nb+0x2f4>)
   216fc:	f016 fb37 	bl	37d6e <log_string_sync>
	#ifdef SHOW_LOG_IN_SCREEN
		sprintf(tmpbuf, "ERROR: mqtt_connect %d", err);
   21700:	4b6a      	ldr	r3, [pc, #424]	; (218ac <test_nb+0x2f8>)
   21702:	f8cd 9000 	str.w	r9, [sp]
	err = mqtt_disconnect(&client);
	if(err)
	{
		LOG_INF("Could not disconnect MQTT client. Error: %d\n", err);
	#ifdef SHOW_LOG_IN_SCREEN	
		sprintf(tmpbuf, "Could not disconnect MQTT client. Error: %d", err);
   21706:	2280      	movs	r2, #128	; 0x80
   21708:	2100      	movs	r1, #0
   2170a:	4861      	ldr	r0, [pc, #388]	; (21890 <test_nb+0x2dc>)
   2170c:	f018 fc99 	bl	3a042 <__sprintf_chk>
		show_infor(tmpbuf);
   21710:	485f      	ldr	r0, [pc, #380]	; (21890 <test_nb+0x2dc>)
   21712:	f015 ff18 	bl	37546 <show_infor>
	#endif
	}
}
   21716:	b013      	add	sp, #76	; 0x4c
   21718:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		LOG_INF("LTE Link Connecting ...\n");
   2171c:	2303      	movs	r3, #3
   2171e:	f04f 0000 	mov.w	r0, #0
   21722:	f363 0007 	bfi	r0, r3, #0, #8
   21726:	f365 108f 	bfi	r0, r5, #6, #10
   2172a:	4961      	ldr	r1, [pc, #388]	; (218b0 <test_nb+0x2fc>)
   2172c:	f016 fb1f 	bl	37d6e <log_string_sync>
		show_infor("LTE Link Connecting ...");
   21730:	4860      	ldr	r0, [pc, #384]	; (218b4 <test_nb+0x300>)
   21732:	f015 ff08 	bl	37546 <show_infor>
		err = lte_lc_init_and_connect();
   21736:	f018 f8e9 	bl	3990c <lte_lc_init_and_connect>
		__ASSERT(err == 0, "LTE link could not be established.");
   2173a:	b170      	cbz	r0, 2175a <test_nb+0x1a6>
   2173c:	495e      	ldr	r1, [pc, #376]	; (218b8 <test_nb+0x304>)
   2173e:	f44f 730d 	mov.w	r3, #564	; 0x234
   21742:	4a5e      	ldr	r2, [pc, #376]	; (218bc <test_nb+0x308>)
   21744:	484b      	ldr	r0, [pc, #300]	; (21874 <test_nb+0x2c0>)
   21746:	f016 fabb 	bl	37cc0 <printk>
   2174a:	485d      	ldr	r0, [pc, #372]	; (218c0 <test_nb+0x30c>)
   2174c:	f016 fab8 	bl	37cc0 <printk>
   21750:	f44f 710d 	mov.w	r1, #564	; 0x234
   21754:	4859      	ldr	r0, [pc, #356]	; (218bc <test_nb+0x308>)
   21756:	f016 faf9 	bl	37d4c <assert_post_action>
		LOG_INF("LTE Link Connected!\n");
   2175a:	2303      	movs	r3, #3
   2175c:	f04f 0000 	mov.w	r0, #0
   21760:	f363 0007 	bfi	r0, r3, #0, #8
   21764:	f365 108f 	bfi	r0, r5, #6, #10
   21768:	4956      	ldr	r1, [pc, #344]	; (218c4 <test_nb+0x310>)
   2176a:	f016 fb00 	bl	37d6e <log_string_sync>
		show_infor("LTE Link Connected!");
   2176e:	4856      	ldr	r0, [pc, #344]	; (218c8 <test_nb+0x314>)
   21770:	f015 fee9 	bl	37546 <show_infor>
   21774:	e749      	b.n	2160a <test_nb+0x56>
	addr = result;
   21776:	f8dd 8014 	ldr.w	r8, [sp, #20]
	while(addr != NULL)
   2177a:	f1b8 0f00 	cmp.w	r8, #0
   2177e:	d029      	beq.n	217d4 <test_nb+0x220>
		if (addr->ai_addrlen == sizeof(struct sockaddr_in))
   21780:	f8d8 2010 	ldr.w	r2, [r8, #16]
   21784:	2a08      	cmp	r2, #8
   21786:	d144      	bne.n	21812 <test_nb+0x25e>
				->sin_addr.s_addr;
   21788:	f8d8 3014 	ldr.w	r3, [r8, #20]
			broker4->sin_family = AF_INET;
   2178c:	2001      	movs	r0, #1
				->sin_addr.s_addr;
   2178e:	685b      	ldr	r3, [r3, #4]
			broker4->sin_family = AF_INET;
   21790:	8030      	strh	r0, [r6, #0]
			broker4->sin_addr.s_addr =
   21792:	6073      	str	r3, [r6, #4]
			broker4->sin_port = htons(CONFIG_MQTT_BROKER_PORT);
   21794:	f24b 4322 	movw	r3, #46114	; 0xb422
   21798:	8073      	strh	r3, [r6, #2]
	if (z_syscall_trap()) {
		return (char *) arch_syscall_invoke4(*(uintptr_t *)&family, *(uintptr_t *)&src, *(uintptr_t *)&dst, *(uintptr_t *)&size, K_SYSCALL_NET_ADDR_NTOP);
	}
#endif
	compiler_barrier();
	return z_impl_net_addr_ntop(family, src, dst, size);
   2179a:	f10d 0818 	add.w	r8, sp, #24
   2179e:	2310      	movs	r3, #16
   217a0:	4642      	mov	r2, r8
   217a2:	1d31      	adds	r1, r6, #4
   217a4:	f004 fc52 	bl	2604c <z_impl_net_addr_ntop>
			LOG_INF("IPv4 Address found %s\n", ipv4_addr);
   217a8:	2303      	movs	r3, #3
   217aa:	f04f 0000 	mov.w	r0, #0
   217ae:	f363 0007 	bfi	r0, r3, #0, #8
   217b2:	f365 108f 	bfi	r0, r5, #6, #10
   217b6:	4642      	mov	r2, r8
   217b8:	4944      	ldr	r1, [pc, #272]	; (218cc <test_nb+0x318>)
   217ba:	f016 fad8 	bl	37d6e <log_string_sync>
			sprintf(tmpbuf, "IPv4 Address found %s", ipv4_addr);
   217be:	f8cd 8000 	str.w	r8, [sp]
   217c2:	4b43      	ldr	r3, [pc, #268]	; (218d0 <test_nb+0x31c>)
   217c4:	2280      	movs	r2, #128	; 0x80
   217c6:	4639      	mov	r1, r7
   217c8:	4831      	ldr	r0, [pc, #196]	; (21890 <test_nb+0x2dc>)
   217ca:	f018 fc3a 	bl	3a042 <__sprintf_chk>
			show_infor(tmpbuf);
   217ce:	4830      	ldr	r0, [pc, #192]	; (21890 <test_nb+0x2dc>)
   217d0:	f015 feb9 	bl	37546 <show_infor>
}

static inline void freeaddrinfo(struct addrinfo *res)
{
	__ASSERT_NO_MSG(socket_ops);
   217d4:	6823      	ldr	r3, [r4, #0]
	freeaddrinfo(result);
   217d6:	9f05      	ldr	r7, [sp, #20]
   217d8:	b94b      	cbnz	r3, 217ee <test_nb+0x23a>
   217da:	4925      	ldr	r1, [pc, #148]	; (21870 <test_nb+0x2bc>)
   217dc:	4825      	ldr	r0, [pc, #148]	; (21874 <test_nb+0x2c0>)
   217de:	239b      	movs	r3, #155	; 0x9b
   217e0:	4a25      	ldr	r2, [pc, #148]	; (21878 <test_nb+0x2c4>)
   217e2:	f016 fa6d 	bl	37cc0 <printk>
   217e6:	219b      	movs	r1, #155	; 0x9b
   217e8:	4823      	ldr	r0, [pc, #140]	; (21878 <test_nb+0x2c4>)
   217ea:	f016 faaf 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->freeaddrinfo);
   217ee:	6823      	ldr	r3, [r4, #0]
   217f0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   217f2:	b94b      	cbnz	r3, 21808 <test_nb+0x254>
   217f4:	4937      	ldr	r1, [pc, #220]	; (218d4 <test_nb+0x320>)
   217f6:	481f      	ldr	r0, [pc, #124]	; (21874 <test_nb+0x2c0>)
   217f8:	239c      	movs	r3, #156	; 0x9c
   217fa:	4a1f      	ldr	r2, [pc, #124]	; (21878 <test_nb+0x2c4>)
   217fc:	f016 fa60 	bl	37cc0 <printk>
   21800:	219c      	movs	r1, #156	; 0x9c
   21802:	481d      	ldr	r0, [pc, #116]	; (21878 <test_nb+0x2c4>)
   21804:	f016 faa2 	bl	37d4c <assert_post_action>

	return socket_ops->freeaddrinfo(res);
   21808:	6823      	ldr	r3, [r4, #0]
   2180a:	4638      	mov	r0, r7
   2180c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   2180e:	4798      	blx	r3
   21810:	e741      	b.n	21696 <test_nb+0xe2>
			LOG_INF("ai_addrlen = %u should be %u or %u\n",
   21812:	2303      	movs	r3, #3
   21814:	f04f 0000 	mov.w	r0, #0
   21818:	f04f 0918 	mov.w	r9, #24
   2181c:	f363 0007 	bfi	r0, r3, #0, #8
   21820:	f365 108f 	bfi	r0, r5, #6, #10
   21824:	f8cd 9000 	str.w	r9, [sp]
   21828:	2308      	movs	r3, #8
   2182a:	492b      	ldr	r1, [pc, #172]	; (218d8 <test_nb+0x324>)
   2182c:	f016 fa9f 	bl	37d6e <log_string_sync>
			sprintf(tmpbuf, "ai_addrlen = %u should be %u or %u",
   21830:	2308      	movs	r3, #8
   21832:	f8cd 9008 	str.w	r9, [sp, #8]
   21836:	9301      	str	r3, [sp, #4]
   21838:	f8d8 3010 	ldr.w	r3, [r8, #16]
   2183c:	2280      	movs	r2, #128	; 0x80
   2183e:	9300      	str	r3, [sp, #0]
   21840:	4639      	mov	r1, r7
   21842:	4b26      	ldr	r3, [pc, #152]	; (218dc <test_nb+0x328>)
   21844:	4812      	ldr	r0, [pc, #72]	; (21890 <test_nb+0x2dc>)
   21846:	f018 fbfc 	bl	3a042 <__sprintf_chk>
   2184a:	e7c0      	b.n	217ce <test_nb+0x21a>
   2184c:	0003aea0 	.word	0x0003aea0
   21850:	0003ade0 	.word	0x0003ade0
   21854:	0003c560 	.word	0x0003c560
   21858:	0003c574 	.word	0x0003c574
   2185c:	0003c587 	.word	0x0003c587
   21860:	0003c597 	.word	0x0003c597
   21864:	0003c5a1 	.word	0x0003c5a1
   21868:	2002033c 	.word	0x2002033c
   2186c:	200204c0 	.word	0x200204c0
   21870:	0003c541 	.word	0x0003c541
   21874:	0003baac 	.word	0x0003baac
   21878:	0003c511 	.word	0x0003c511
   2187c:	0003c64c 	.word	0x0003c64c
   21880:	0003c664 	.word	0x0003c664
   21884:	20022272 	.word	0x20022272
   21888:	0003c677 	.word	0x0003c677
   2188c:	0003c695 	.word	0x0003c695
   21890:	20024b84 	.word	0x20024b84
   21894:	00021181 	.word	0x00021181
   21898:	0003c73f 	.word	0x0003c73f
   2189c:	20024b04 	.word	0x20024b04
   218a0:	20024c04 	.word	0x20024c04
   218a4:	2002af20 	.word	0x2002af20
   218a8:	0003c74e 	.word	0x0003c74e
   218ac:	0003c766 	.word	0x0003c766
   218b0:	0003c5b5 	.word	0x0003c5b5
   218b4:	0003c5ce 	.word	0x0003c5ce
   218b8:	0003c5f5 	.word	0x0003c5f5
   218bc:	0003c5e6 	.word	0x0003c5e6
   218c0:	0003c5fe 	.word	0x0003c5fe
   218c4:	0003c623 	.word	0x0003c623
   218c8:	0003c638 	.word	0x0003c638
   218cc:	0003c6b2 	.word	0x0003c6b2
   218d0:	0003c6c9 	.word	0x0003c6c9
   218d4:	0003c726 	.word	0x0003c726
   218d8:	0003c6df 	.word	0x0003c6df
   218dc:	0003c703 	.word	0x0003c703
	if(c->transport.type == MQTT_TRANSPORT_NON_SECURE)
   218e0:	4e48      	ldr	r6, [pc, #288]	; (21a04 <test_nb+0x450>)
   218e2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
	fds.events = POLLIN;
   218e4:	80b7      	strh	r7, [r6, #4]
   218e6:	6032      	str	r2, [r6, #0]
		err = poll(&fds, 1, mqtt_keepalive_time_left(&client));
   218e8:	4620      	mov	r0, r4
   218ea:	f017 f84c 	bl	38986 <mqtt_keepalive_time_left>
   218ee:	f7ff fc17 	bl	21120 <poll.constprop.6>
		if(err < 0)
   218f2:	2800      	cmp	r0, #0
   218f4:	da3c      	bge.n	21970 <test_nb+0x3bc>
			LOG_INF("ERROR: poll %d\n", errno);
   218f6:	2303      	movs	r3, #3
   218f8:	f04f 0400 	mov.w	r4, #0
   218fc:	f363 0407 	bfi	r4, r3, #0, #8
   21900:	f016 fbd9 	bl	380b6 <__errno>
   21904:	f365 148f 	bfi	r4, r5, #6, #10
   21908:	6802      	ldr	r2, [r0, #0]
   2190a:	493f      	ldr	r1, [pc, #252]	; (21a08 <test_nb+0x454>)
   2190c:	4620      	mov	r0, r4
   2190e:	f016 fa2e 	bl	37d6e <log_string_sync>
			sprintf(tmpbuf, "ERROR: poll %d", errno);
   21912:	f016 fbd0 	bl	380b6 <__errno>
   21916:	6803      	ldr	r3, [r0, #0]
   21918:	9300      	str	r3, [sp, #0]
   2191a:	4b3c      	ldr	r3, [pc, #240]	; (21a0c <test_nb+0x458>)
				sprintf(tmpbuf, "ERROR: mqtt_input %d", err);
   2191c:	2280      	movs	r2, #128	; 0x80
   2191e:	2100      	movs	r1, #0
   21920:	483b      	ldr	r0, [pc, #236]	; (21a10 <test_nb+0x45c>)
   21922:	f018 fb8e 	bl	3a042 <__sprintf_chk>
				show_infor(tmpbuf);
   21926:	483a      	ldr	r0, [pc, #232]	; (21a10 <test_nb+0x45c>)
			show_infor("POLLNVAL");
   21928:	f015 fe0d 	bl	37546 <show_infor>
	LOG_INF("Disconnecting MQTT client...\n");
   2192c:	2303      	movs	r3, #3
   2192e:	f04f 0000 	mov.w	r0, #0
   21932:	f363 0007 	bfi	r0, r3, #0, #8
   21936:	4937      	ldr	r1, [pc, #220]	; (21a14 <test_nb+0x460>)
   21938:	f365 108f 	bfi	r0, r5, #6, #10
   2193c:	f016 fa17 	bl	37d6e <log_string_sync>
	show_infor("Disconnecting MQTT client...");
   21940:	4835      	ldr	r0, [pc, #212]	; (21a18 <test_nb+0x464>)
   21942:	f015 fe00 	bl	37546 <show_infor>
	err = mqtt_disconnect(&client);
   21946:	4835      	ldr	r0, [pc, #212]	; (21a1c <test_nb+0x468>)
   21948:	f016 ff7b 	bl	38842 <mqtt_disconnect>
	if(err)
   2194c:	4604      	mov	r4, r0
   2194e:	2800      	cmp	r0, #0
   21950:	f43f aee1 	beq.w	21716 <test_nb+0x162>
		LOG_INF("Could not disconnect MQTT client. Error: %d\n", err);
   21954:	2303      	movs	r3, #3
   21956:	f04f 0000 	mov.w	r0, #0
   2195a:	f363 0007 	bfi	r0, r3, #0, #8
   2195e:	f365 108f 	bfi	r0, r5, #6, #10
   21962:	4622      	mov	r2, r4
   21964:	492e      	ldr	r1, [pc, #184]	; (21a20 <test_nb+0x46c>)
   21966:	f016 fa02 	bl	37d6e <log_string_sync>
		sprintf(tmpbuf, "Could not disconnect MQTT client. Error: %d", err);
   2196a:	9400      	str	r4, [sp, #0]
   2196c:	4b2d      	ldr	r3, [pc, #180]	; (21a24 <test_nb+0x470>)
   2196e:	e6ca      	b.n	21706 <test_nb+0x152>
		err = mqtt_live(&client);
   21970:	4620      	mov	r0, r4
   21972:	f016 ffe1 	bl	38938 <mqtt_live>
		if((err != 0) && (err != -EAGAIN))
   21976:	4607      	mov	r7, r0
   21978:	b180      	cbz	r0, 2199c <test_nb+0x3e8>
   2197a:	f110 0f0b 	cmn.w	r0, #11
   2197e:	d00d      	beq.n	2199c <test_nb+0x3e8>
			LOG_INF("ERROR: mqtt_live %d\n", err);
   21980:	2303      	movs	r3, #3
   21982:	f04f 0000 	mov.w	r0, #0
   21986:	f363 0007 	bfi	r0, r3, #0, #8
   2198a:	f365 108f 	bfi	r0, r5, #6, #10
   2198e:	463a      	mov	r2, r7
   21990:	4925      	ldr	r1, [pc, #148]	; (21a28 <test_nb+0x474>)
   21992:	f016 f9ec 	bl	37d6e <log_string_sync>
			sprintf(tmpbuf, "ERROR: mqtt_live %d", err);
   21996:	9700      	str	r7, [sp, #0]
   21998:	4b24      	ldr	r3, [pc, #144]	; (21a2c <test_nb+0x478>)
   2199a:	e7bf      	b.n	2191c <test_nb+0x368>
		if((fds.revents & POLLIN) == POLLIN)
   2199c:	88f3      	ldrh	r3, [r6, #6]
   2199e:	07d9      	lsls	r1, r3, #31
   219a0:	d512      	bpl.n	219c8 <test_nb+0x414>
			err = mqtt_input(&client);
   219a2:	4620      	mov	r0, r4
   219a4:	f017 f806 	bl	389b4 <mqtt_input>
			if(err != 0)
   219a8:	4607      	mov	r7, r0
   219aa:	b168      	cbz	r0, 219c8 <test_nb+0x414>
				LOG_INF("ERROR: mqtt_input %d\n", err);
   219ac:	2303      	movs	r3, #3
   219ae:	f04f 0000 	mov.w	r0, #0
   219b2:	f363 0007 	bfi	r0, r3, #0, #8
   219b6:	f365 108f 	bfi	r0, r5, #6, #10
   219ba:	463a      	mov	r2, r7
   219bc:	491c      	ldr	r1, [pc, #112]	; (21a30 <test_nb+0x47c>)
   219be:	f016 f9d6 	bl	37d6e <log_string_sync>
				sprintf(tmpbuf, "ERROR: mqtt_input %d", err);
   219c2:	9700      	str	r7, [sp, #0]
   219c4:	4b1b      	ldr	r3, [pc, #108]	; (21a34 <test_nb+0x480>)
   219c6:	e7a9      	b.n	2191c <test_nb+0x368>
		if((fds.revents & POLLERR) == POLLERR)
   219c8:	88f3      	ldrh	r3, [r6, #6]
   219ca:	071a      	lsls	r2, r3, #28
   219cc:	d50b      	bpl.n	219e6 <test_nb+0x432>
			LOG_INF("POLLERR\n");
   219ce:	2303      	movs	r3, #3
   219d0:	f04f 0000 	mov.w	r0, #0
   219d4:	f363 0007 	bfi	r0, r3, #0, #8
   219d8:	f365 108f 	bfi	r0, r5, #6, #10
   219dc:	4916      	ldr	r1, [pc, #88]	; (21a38 <test_nb+0x484>)
   219de:	f016 f9c6 	bl	37d6e <log_string_sync>
			show_infor("POLLERR");
   219e2:	4816      	ldr	r0, [pc, #88]	; (21a3c <test_nb+0x488>)
   219e4:	e7a0      	b.n	21928 <test_nb+0x374>
		if((fds.revents & POLLNVAL) == POLLNVAL)
   219e6:	069b      	lsls	r3, r3, #26
   219e8:	f57f af7e 	bpl.w	218e8 <test_nb+0x334>
			LOG_INF("POLLNVAL\n");
   219ec:	2303      	movs	r3, #3
   219ee:	f04f 0000 	mov.w	r0, #0
   219f2:	f363 0007 	bfi	r0, r3, #0, #8
   219f6:	f365 108f 	bfi	r0, r5, #6, #10
   219fa:	4911      	ldr	r1, [pc, #68]	; (21a40 <test_nb+0x48c>)
   219fc:	f016 f9b7 	bl	37d6e <log_string_sync>
			show_infor("POLLNVAL");
   21a00:	4810      	ldr	r0, [pc, #64]	; (21a44 <test_nb+0x490>)
   21a02:	e791      	b.n	21928 <test_nb+0x374>
   21a04:	200203b8 	.word	0x200203b8
   21a08:	0003c77d 	.word	0x0003c77d
   21a0c:	0003c78d 	.word	0x0003c78d
   21a10:	20024b84 	.word	0x20024b84
   21a14:	0003c334 	.word	0x0003c334
   21a18:	0003c378 	.word	0x0003c378
   21a1c:	2002033c 	.word	0x2002033c
   21a20:	0003c814 	.word	0x0003c814
   21a24:	0003c841 	.word	0x0003c841
   21a28:	0003c79c 	.word	0x0003c79c
   21a2c:	0003c7b1 	.word	0x0003c7b1
   21a30:	0003c7c5 	.word	0x0003c7c5
   21a34:	0003c7db 	.word	0x0003c7db
   21a38:	0003c7f0 	.word	0x0003c7f0
   21a3c:	0003c7f9 	.word	0x0003c7f9
   21a40:	0003c801 	.word	0x0003c801
   21a44:	0003c80b 	.word	0x0003c80b

00021a48 <NBMsgProcess>:
	app_nb_on = true;
}

void NBMsgProcess(void)
{
	if(app_nb_on)
   21a48:	4b05      	ldr	r3, [pc, #20]	; (21a60 <NBMsgProcess+0x18>)
   21a4a:	781a      	ldrb	r2, [r3, #0]
   21a4c:	b132      	cbz	r2, 21a5c <NBMsgProcess+0x14>
	{
		app_nb_on = false;
   21a4e:	2200      	movs	r2, #0
   21a50:	701a      	strb	r2, [r3, #0]
		if(nb_is_running)
   21a52:	4b04      	ldr	r3, [pc, #16]	; (21a64 <NBMsgProcess+0x1c>)
   21a54:	781b      	ldrb	r3, [r3, #0]
   21a56:	b90b      	cbnz	r3, 21a5c <NBMsgProcess+0x14>
			return;
		
		test_nb();
   21a58:	f7ff bdac 	b.w	215b4 <test_nb>
	}
}
   21a5c:	4770      	bx	lr
   21a5e:	bf00      	nop
   21a60:	20024a82 	.word	0x20024a82
   21a64:	20024a83 	.word	0x20024a83

00021a68 <touch_panel_event_handle>:
	return false;
}

void touch_panel_event_handle(tp_event tp_type, u16_t x_pos, u16_t y_pos)
{
	switch(tp_type)
   21a68:	2806      	cmp	r0, #6
   21a6a:	d815      	bhi.n	21a98 <touch_panel_event_handle+0x30>
   21a6c:	e8df f000 	tbb	[pc, r0]
   21a70:	0b090704 	.word	0x0b090704
   21a74:	100d      	.short	0x100d
   21a76:	12          	.byte	0x12
   21a77:	00          	.byte	0x00
	{
	case TP_EVENT_MOVING_UP:
		printk("tp moving up!\n");
   21a78:	4808      	ldr	r0, [pc, #32]	; (21a9c <touch_panel_event_handle+0x34>)
		break;
	case TP_EVENT_MOVING_DOWN:
		printk("tp moving down!\n");
   21a7a:	f016 b921 	b.w	37cc0 <printk>
   21a7e:	4808      	ldr	r0, [pc, #32]	; (21aa0 <touch_panel_event_handle+0x38>)
   21a80:	e7fb      	b.n	21a7a <touch_panel_event_handle+0x12>
		break;
	case TP_EVENT_MOVING_LEFT:
		printk("tp moving left!\n");
   21a82:	4808      	ldr	r0, [pc, #32]	; (21aa4 <touch_panel_event_handle+0x3c>)
   21a84:	e7f9      	b.n	21a7a <touch_panel_event_handle+0x12>
		break;
	case TP_EVENT_MOVING_RIGHT:
		printk("tp moving right!\n");
   21a86:	4808      	ldr	r0, [pc, #32]	; (21aa8 <touch_panel_event_handle+0x40>)
   21a88:	e7f7      	b.n	21a7a <touch_panel_event_handle+0x12>
		break;
	case TP_EVENT_SINGLE_CLICK:
		printk("tp single click! x:%d, y:%d\n", x_pos,y_pos);
   21a8a:	4808      	ldr	r0, [pc, #32]	; (21aac <touch_panel_event_handle+0x44>)
		break;
	case TP_EVENT_DOUBLE_CLICK:
		printk("tp double click! x:%d, y:%d\n", x_pos,y_pos);
		break;
	case TP_EVENT_LONG_PRESS:
		printk("tp long press! x:%d, y:%d\n", x_pos,y_pos);
   21a8c:	f016 b918 	b.w	37cc0 <printk>
		printk("tp double click! x:%d, y:%d\n", x_pos,y_pos);
   21a90:	4807      	ldr	r0, [pc, #28]	; (21ab0 <touch_panel_event_handle+0x48>)
   21a92:	e7fb      	b.n	21a8c <touch_panel_event_handle+0x24>
		printk("tp long press! x:%d, y:%d\n", x_pos,y_pos);
   21a94:	4807      	ldr	r0, [pc, #28]	; (21ab4 <touch_panel_event_handle+0x4c>)
   21a96:	e7f9      	b.n	21a8c <touch_panel_event_handle+0x24>
		break;
	case TP_EVENT_MAX:
		break;
	}
}
   21a98:	4770      	bx	lr
   21a9a:	bf00      	nop
   21a9c:	0003c86d 	.word	0x0003c86d
   21aa0:	0003c87c 	.word	0x0003c87c
   21aa4:	0003c88d 	.word	0x0003c88d
   21aa8:	0003c89e 	.word	0x0003c89e
   21aac:	0003c8b0 	.word	0x0003c8b0
   21ab0:	0003c8cd 	.word	0x0003c8cd
   21ab4:	0003c8ea 	.word	0x0003c8ea

00021ab8 <GetSportData>:
	LOG_INF("g_steps:%d,g_distance:%d,g_calorie:%d\n", g_steps, g_distance, g_calorie);
}

void GetSportData(u16_t *steps, u16_t *calorie, u16_t *distance)
{
	*steps = g_steps;
   21ab8:	4b04      	ldr	r3, [pc, #16]	; (21acc <GetSportData+0x14>)
   21aba:	881b      	ldrh	r3, [r3, #0]
   21abc:	8003      	strh	r3, [r0, #0]
	*calorie = g_calorie;
   21abe:	4b04      	ldr	r3, [pc, #16]	; (21ad0 <GetSportData+0x18>)
   21ac0:	881b      	ldrh	r3, [r3, #0]
   21ac2:	800b      	strh	r3, [r1, #0]
	*distance = g_distance;
   21ac4:	4b03      	ldr	r3, [pc, #12]	; (21ad4 <GetSportData+0x1c>)
   21ac6:	881b      	ldrh	r3, [r3, #0]
   21ac8:	8013      	strh	r3, [r2, #0]
}
   21aca:	4770      	bx	lr
   21acc:	2002228e 	.word	0x2002228e
   21ad0:	2002228a 	.word	0x2002228a
   21ad4:	2002228c 	.word	0x2002228c

00021ad8 <GetSleepTimeData>:
	k_timer_start(&sleep_timer, K_MSEC(1000), K_MSEC(1000));
}

void GetSleepTimeData(u16_t *deep_sleep, u16_t *light_sleep)
{
	*deep_sleep = g_deep_sleep;
   21ad8:	4b03      	ldr	r3, [pc, #12]	; (21ae8 <GetSleepTimeData+0x10>)
   21ada:	881b      	ldrh	r3, [r3, #0]
   21adc:	8003      	strh	r3, [r0, #0]
	*light_sleep = g_light_sleep;
   21ade:	4b03      	ldr	r3, [pc, #12]	; (21aec <GetSleepTimeData+0x14>)
   21ae0:	881b      	ldrh	r3, [r3, #0]
   21ae2:	800b      	strh	r3, [r1, #0]
}
   21ae4:	4770      	bx	lr
   21ae6:	bf00      	nop
   21ae8:	20022290 	.word	0x20022290
   21aec:	20022292 	.word	0x20022292

00021af0 <ShowBootUpLogo>:
SCREEN_ID_ENUM history_screen_id = SCREEN_ID_BOOTUP;
screen_msg scr_msg[SCREEN_ID_MAX] = {0};
notify_infor notify_msg = {0};

void ShowBootUpLogo(void)
{
   21af0:	b513      	push	{r0, r1, r4, lr}
	u16_t x,y,w,h;

	LCD_get_pic_size_from_flash(IMG_RM_LOGO_240X240_ADDR, &w, &h);
   21af2:	4c07      	ldr	r4, [pc, #28]	; (21b10 <ShowBootUpLogo+0x20>)
   21af4:	f10d 0206 	add.w	r2, sp, #6
   21af8:	a901      	add	r1, sp, #4
   21afa:	4620      	mov	r0, r4
   21afc:	f015 fc15 	bl	3732a <LCD_get_pic_size_from_flash>
	x = (w > LCD_WIDTH ? 0 : (LCD_WIDTH-w)/2);
	y = (h > LCD_HEIGHT ? 0 : (LCD_HEIGHT-h)/2);
	LCD_dis_pic_from_flash(0, 0, IMG_RM_LOGO_240X240_ADDR);
   21b00:	2100      	movs	r1, #0
   21b02:	4622      	mov	r2, r4
   21b04:	4608      	mov	r0, r1
   21b06:	f7fc ffe7 	bl	1ead8 <LCD_dis_pic_from_flash>
}
   21b0a:	b002      	add	sp, #8
   21b0c:	bd10      	pop	{r4, pc}
   21b0e:	bf00      	nop
   21b10:	00060e30 	.word	0x00060e30

00021b14 <EnterNotifyScreen>:
	ExitNotifyScreen();
}

void EnterNotifyScreen(void)
{
	if(screen_id == SCREEN_ID_NOTIFY)
   21b14:	4908      	ldr	r1, [pc, #32]	; (21b38 <EnterNotifyScreen+0x24>)
   21b16:	780b      	ldrb	r3, [r1, #0]
   21b18:	2b0a      	cmp	r3, #10
   21b1a:	d00b      	beq.n	21b34 <EnterNotifyScreen+0x20>
		return;

	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   21b1c:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   21b1e:	4a07      	ldr	r2, [pc, #28]	; (21b3c <EnterNotifyScreen+0x28>)
   21b20:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   21b22:	4a07      	ldr	r2, [pc, #28]	; (21b40 <EnterNotifyScreen+0x2c>)
   21b24:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_NOTIFY;	
   21b28:	230a      	movs	r3, #10
   21b2a:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_NOTIFY].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_NOTIFY].status = SCREEN_STATUS_CREATING;	
   21b2c:	f240 1301 	movw	r3, #257	; 0x101
   21b30:	f8a2 3050 	strh.w	r3, [r2, #80]	; 0x50
}
   21b34:	4770      	bx	lr
   21b36:	bf00      	nop
   21b38:	20024cd9 	.word	0x20024cd9
   21b3c:	20024c85 	.word	0x20024c85
   21b40:	200203c0 	.word	0x200203c0

00021b44 <DisplayPopUp>:

void DisplayPopUp(u8_t *message)
{
   21b44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t len;
	
	notify_msg.type = NOTIFY_TYPE_POPUP;
   21b46:	2500      	movs	r5, #0
   21b48:	4c10      	ldr	r4, [pc, #64]	; (21b8c <DisplayPopUp+0x48>)
{
   21b4a:	4606      	mov	r6, r0
	notify_msg.type = NOTIFY_TYPE_POPUP;
   21b4c:	7025      	strb	r5, [r4, #0]
	notify_msg.align = NOTIFY_ALIGN_CENTER;
   21b4e:	7065      	strb	r5, [r4, #1]
	
	len = strlen(message);
   21b50:	f7fb fb02 	bl	1d158 <strlen>
   21b54:	4607      	mov	r7, r0
	if(len > NOTIFY_TEXT_MAX_LEN)
		len = NOTIFY_TEXT_MAX_LEN;
	memset(notify_msg.text, 0x00, sizeof(notify_msg.text));
   21b56:	2251      	movs	r2, #81	; 0x51
   21b58:	4629      	mov	r1, r5
   21b5a:	1ca0      	adds	r0, r4, #2
   21b5c:	f018 f92f 	bl	39dbe <memset>
	memcpy(notify_msg.text, message, len);
   21b60:	2f50      	cmp	r7, #80	; 0x50
   21b62:	463a      	mov	r2, r7
   21b64:	f04f 0351 	mov.w	r3, #81	; 0x51
   21b68:	bf28      	it	cs
   21b6a:	2250      	movcs	r2, #80	; 0x50
   21b6c:	4631      	mov	r1, r6
   21b6e:	1ca0      	adds	r0, r4, #2
   21b70:	f018 f912 	bl	39d98 <__memcpy_chk>

	if(notify_msg.type == NOTIFY_TYPE_POPUP)
   21b74:	7822      	ldrb	r2, [r4, #0]
   21b76:	b922      	cbnz	r2, 21b82 <DisplayPopUp+0x3e>
   21b78:	f241 3188 	movw	r1, #5000	; 0x1388
   21b7c:	4804      	ldr	r0, [pc, #16]	; (21b90 <DisplayPopUp+0x4c>)
   21b7e:	f013 fc11 	bl	353a4 <z_impl_k_timer_start>
	{
		k_timer_start(&notify_timer, K_SECONDS(NOTIFY_TIMER_INTERVAL), NULL);
	}
	
	EnterNotifyScreen();
}
   21b82:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	EnterNotifyScreen();
   21b86:	f7ff bfc5 	b.w	21b14 <EnterNotifyScreen>
   21b8a:	bf00      	nop
   21b8c:	20024c86 	.word	0x20024c86
   21b90:	2002cb54 	.word	0x2002cb54

00021b94 <IdleShowSystemDate>:
void IdleShowSystemDate(void)
{
   21b94:	b530      	push	{r4, r5, lr}
   21b96:	b089      	sub	sp, #36	; 0x24
	u16_t x,y,w,h;
	u8_t str_date[20] = {0};
   21b98:	2100      	movs	r1, #0
   21b9a:	2214      	movs	r2, #20
   21b9c:	a803      	add	r0, sp, #12
   21b9e:	f018 f90e 	bl	39dbe <memset>

	POINT_COLOR=WHITE;
	BACK_COLOR=BLACK;
   21ba2:	2400      	movs	r4, #0
	POINT_COLOR=WHITE;
   21ba4:	f64f 72ff 	movw	r2, #65535	; 0xffff
   21ba8:	4b18      	ldr	r3, [pc, #96]	; (21c0c <IdleShowSystemDate+0x78>)
	BACK_COLOR=BLACK;
   21baa:	4d19      	ldr	r5, [pc, #100]	; (21c10 <IdleShowSystemDate+0x7c>)

#ifdef FONT_32
	LCD_SetFontSize(FONT_SIZE_32);
#elif defined(FONT_24)
	LCD_SetFontSize(FONT_SIZE_24);
   21bac:	2018      	movs	r0, #24
	POINT_COLOR=WHITE;
   21bae:	801a      	strh	r2, [r3, #0]
	BACK_COLOR=BLACK;
   21bb0:	802c      	strh	r4, [r5, #0]
	LCD_SetFontSize(FONT_SIZE_24);
   21bb2:	f7fd f949 	bl	1ee48 <LCD_SetFontSize>
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);	
	LCD_ShowUniString(x,y,str_date);
	
#else

	GetSystemDateStrings(str_date);
   21bb6:	a803      	add	r0, sp, #12
   21bb8:	f7fc fd38 	bl	1e62c <GetSystemDateStrings>
	LCD_MeasureString(str_date,&w,&h);
   21bbc:	a803      	add	r0, sp, #12
   21bbe:	f10d 020a 	add.w	r2, sp, #10
   21bc2:	a902      	add	r1, sp, #8
   21bc4:	f7fd f91c 	bl	1ee00 <LCD_MeasureString>
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   21bc8:	4629      	mov	r1, r5
   21bca:	4b12      	ldr	r3, [pc, #72]	; (21c14 <IdleShowSystemDate+0x80>)
   21bcc:	881a      	ldrh	r2, [r3, #0]
   21bce:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   21bd2:	429a      	cmp	r2, r3
   21bd4:	bf88      	it	hi
   21bd6:	1ad0      	subhi	r0, r2, r3
	y = IDLE_DATE_SHOW_Y;
   21bd8:	4b0f      	ldr	r3, [pc, #60]	; (21c18 <IdleShowSystemDate+0x84>)
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   21bda:	bf88      	it	hi
   21bdc:	eb00 70d0 	addhi.w	r0, r0, r0, lsr #31
	y = IDLE_DATE_SHOW_Y;
   21be0:	781d      	ldrb	r5, [r3, #0]
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);	
   21be2:	880b      	ldrh	r3, [r1, #0]
	y = IDLE_DATE_SHOW_Y;
   21be4:	f105 0540 	add.w	r5, r5, #64	; 0x40
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   21be8:	bf88      	it	hi
   21bea:	f3c0 044f 	ubfxhi	r4, r0, #1, #16
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);	
   21bee:	9300      	str	r3, [sp, #0]
   21bf0:	4629      	mov	r1, r5
   21bf2:	f8bd 300a 	ldrh.w	r3, [sp, #10]
   21bf6:	2000      	movs	r0, #0
   21bf8:	f7fc ff18 	bl	1ea2c <LCD_Fill>
	LCD_ShowString(x,y,str_date);
   21bfc:	aa03      	add	r2, sp, #12
   21bfe:	4629      	mov	r1, r5
   21c00:	4620      	mov	r0, r4
   21c02:	f7fd f8cb 	bl	1ed9c <LCD_ShowString>
#endif
}
   21c06:	b009      	add	sp, #36	; 0x24
   21c08:	bd30      	pop	{r4, r5, pc}
   21c0a:	bf00      	nop
   21c0c:	2002b234 	.word	0x2002b234
   21c10:	20022240 	.word	0x20022240
   21c14:	2002b232 	.word	0x2002b232
   21c18:	2002ca39 	.word	0x2002ca39

00021c1c <IdleShowSystemTime>:

void IdleShowSystemTime(void)
{
   21c1c:	b510      	push	{r4, lr}
   21c1e:	b088      	sub	sp, #32
	u16_t x,y,w,h,offset;
	u8_t str_time[20] = {0};
   21c20:	2100      	movs	r1, #0
   21c22:	2214      	movs	r2, #20
   21c24:	a803      	add	r0, sp, #12
   21c26:	f018 f8ca 	bl	39dbe <memset>
	u8_t str_ampm[5] = {0};

	POINT_COLOR=WHITE;
   21c2a:	f64f 72ff 	movw	r2, #65535	; 0xffff
	u8_t str_ampm[5] = {0};
   21c2e:	2400      	movs	r4, #0
	POINT_COLOR=WHITE;
   21c30:	4b19      	ldr	r3, [pc, #100]	; (21c98 <IdleShowSystemTime+0x7c>)
	
#ifdef FONT_32
	LCD_SetFontSize(FONT_SIZE_32);
	offset = 16;
#elif defined(FONT_24)
	LCD_SetFontSize(FONT_SIZE_24);
   21c32:	2018      	movs	r0, #24
	POINT_COLOR=WHITE;
   21c34:	801a      	strh	r2, [r3, #0]
	BACK_COLOR=BLACK;
   21c36:	4b19      	ldr	r3, [pc, #100]	; (21c9c <IdleShowSystemTime+0x80>)
	u8_t str_ampm[5] = {0};
   21c38:	9401      	str	r4, [sp, #4]
	BACK_COLOR=BLACK;
   21c3a:	801c      	strh	r4, [r3, #0]
	u8_t str_ampm[5] = {0};
   21c3c:	f88d 4008 	strb.w	r4, [sp, #8]
	LCD_SetFontSize(FONT_SIZE_24);
   21c40:	f7fd f902 	bl	1ee48 <LCD_SetFontSize>
	y = IDLE_TIME_SHOW_Y+offset;
	LCD_ShowUniString(x,y,str_ampm);

#else

	GetSystemTimeStrings(str_time);
   21c44:	a803      	add	r0, sp, #12
   21c46:	f7fc fd41 	bl	1e6cc <GetSystemTimeStrings>
	LCD_MeasureString(str_time,&w,&h);
   21c4a:	f10d 0202 	add.w	r2, sp, #2
   21c4e:	4669      	mov	r1, sp
   21c50:	a803      	add	r0, sp, #12
   21c52:	f7fd f8d5 	bl	1ee00 <LCD_MeasureString>
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   21c56:	4b12      	ldr	r3, [pc, #72]	; (21ca0 <IdleShowSystemTime+0x84>)
   21c58:	f8bd 2000 	ldrh.w	r2, [sp]
   21c5c:	881b      	ldrh	r3, [r3, #0]
	y = IDLE_TIME_SHOW_Y;
	LCD_ShowString(x,y,str_time);
   21c5e:	2140      	movs	r1, #64	; 0x40
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   21c60:	4293      	cmp	r3, r2
   21c62:	bf82      	ittt	hi
   21c64:	1a9c      	subhi	r4, r3, r2
   21c66:	eb04 74d4 	addhi.w	r4, r4, r4, lsr #31
   21c6a:	f3c4 044f 	ubfxhi	r4, r4, #1, #16
	LCD_ShowString(x,y,str_time);
   21c6e:	aa03      	add	r2, sp, #12
   21c70:	4620      	mov	r0, r4
   21c72:	f7fd f893 	bl	1ed9c <LCD_ShowString>

	LCD_SetFontSize(FONT_SIZE_16);
   21c76:	2010      	movs	r0, #16
   21c78:	f7fd f8e6 	bl	1ee48 <LCD_SetFontSize>
	GetSysteAmPmStrings(str_ampm);
   21c7c:	a801      	add	r0, sp, #4
   21c7e:	f7fc fcff 	bl	1e680 <GetSysteAmPmStrings>
	x = x+w+5;
   21c82:	f8bd 0000 	ldrh.w	r0, [sp]
	y = IDLE_TIME_SHOW_Y+offset;
	LCD_ShowString(x,y,str_ampm);
   21c86:	aa01      	add	r2, sp, #4
	x = x+w+5;
   21c88:	4404      	add	r4, r0
   21c8a:	1d60      	adds	r0, r4, #5
	LCD_ShowString(x,y,str_ampm);
   21c8c:	2148      	movs	r1, #72	; 0x48
   21c8e:	b280      	uxth	r0, r0
   21c90:	f7fd f884 	bl	1ed9c <LCD_ShowString>
#endif
}
   21c94:	b008      	add	sp, #32
   21c96:	bd10      	pop	{r4, pc}
   21c98:	2002b234 	.word	0x2002b234
   21c9c:	20022240 	.word	0x20022240
   21ca0:	2002b232 	.word	0x2002b232

00021ca4 <IdleShowSystemWeek>:

void IdleShowSystemWeek(void)
{
   21ca4:	b570      	push	{r4, r5, r6, lr}
   21ca6:	b0a4      	sub	sp, #144	; 0x90
	u16_t x,y,w,h;
	u8_t str_week[128] = {0};
   21ca8:	2100      	movs	r1, #0
   21caa:	2280      	movs	r2, #128	; 0x80
   21cac:	a804      	add	r0, sp, #16
   21cae:	f018 f886 	bl	39dbe <memset>

	POINT_COLOR=WHITE;
   21cb2:	f64f 72ff 	movw	r2, #65535	; 0xffff
   21cb6:	4b20      	ldr	r3, [pc, #128]	; (21d38 <IdleShowSystemWeek+0x94>)
	BACK_COLOR=BLACK;
   21cb8:	4e20      	ldr	r6, [pc, #128]	; (21d3c <IdleShowSystemWeek+0x98>)
	POINT_COLOR=WHITE;
   21cba:	801a      	strh	r2, [r3, #0]
	BACK_COLOR=BLACK;
   21cbc:	2300      	movs	r3, #0

#ifdef FONT_32
	LCD_SetFontSize(FONT_SIZE_32);
#elif defined(FONT_24)
	LCD_SetFontSize(FONT_SIZE_24);
   21cbe:	2018      	movs	r0, #24
	BACK_COLOR=BLACK;
   21cc0:	8033      	strh	r3, [r6, #0]
	LCD_SetFontSize(FONT_SIZE_24);
   21cc2:	f7fd f8c1 	bl	1ee48 <LCD_SetFontSize>
#else
	LCD_SetFontSize(FONT_SIZE_16);
#endif

	GetSystemWeekStrings(str_week);
   21cc6:	a804      	add	r0, sp, #16
   21cc8:	f7fc fd22 	bl	1e710 <GetSystemWeekStrings>
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);
	LCD_ShowUniString(x,y,str_week);

#else
	//xb add 2020-11-06
	if(global_settings.language == LANGUAGE_CHN)
   21ccc:	4b1c      	ldr	r3, [pc, #112]	; (21d40 <IdleShowSystemWeek+0x9c>)
   21cce:	7a5b      	ldrb	r3, [r3, #9]
   21cd0:	2b01      	cmp	r3, #1
   21cd2:	d12d      	bne.n	21d30 <IdleShowSystemWeek+0x8c>
		strcpy(str_week,"It has no chinese font!");
   21cd4:	491b      	ldr	r1, [pc, #108]	; (21d44 <IdleShowSystemWeek+0xa0>)
	else if(global_settings.language == LANGUAGE_JPN)
		strcpy(str_week,"It has no japanese font!");
   21cd6:	a804      	add	r0, sp, #16
   21cd8:	f018 f9da 	bl	3a090 <strcpy>
	//xb end

	LCD_MeasureString(str_week,&w,&h);
   21cdc:	f10d 020e 	add.w	r2, sp, #14
   21ce0:	a903      	add	r1, sp, #12
   21ce2:	a804      	add	r0, sp, #16
   21ce4:	f7fd f88c 	bl	1ee00 <LCD_MeasureString>
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   21ce8:	4b17      	ldr	r3, [pc, #92]	; (21d48 <IdleShowSystemWeek+0xa4>)
   21cea:	f8bd 400c 	ldrh.w	r4, [sp, #12]
   21cee:	881a      	ldrh	r2, [r3, #0]
	y = IDLE_WEEK_SHOW_Y;
   21cf0:	4b16      	ldr	r3, [pc, #88]	; (21d4c <IdleShowSystemWeek+0xa8>)
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   21cf2:	42a2      	cmp	r2, r4
   21cf4:	bf98      	it	ls
   21cf6:	2400      	movls	r4, #0
	y = IDLE_WEEK_SHOW_Y;
   21cf8:	781d      	ldrb	r5, [r3, #0]
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   21cfa:	bf88      	it	hi
   21cfc:	1b14      	subhi	r4, r2, r4
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);
   21cfe:	8833      	ldrh	r3, [r6, #0]
	y = IDLE_WEEK_SHOW_Y;
   21d00:	f105 0520 	add.w	r5, r5, #32
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   21d04:	bf88      	it	hi
   21d06:	eb04 74d4 	addhi.w	r4, r4, r4, lsr #31
	y = IDLE_WEEK_SHOW_Y;
   21d0a:	ea4f 0545 	mov.w	r5, r5, lsl #1
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   21d0e:	bf88      	it	hi
   21d10:	f3c4 044f 	ubfxhi	r4, r4, #1, #16
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);
   21d14:	9300      	str	r3, [sp, #0]
   21d16:	4629      	mov	r1, r5
   21d18:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   21d1c:	2000      	movs	r0, #0
   21d1e:	f7fc fe85 	bl	1ea2c <LCD_Fill>
	LCD_ShowString(x,y,str_week);
   21d22:	aa04      	add	r2, sp, #16
   21d24:	4629      	mov	r1, r5
   21d26:	4620      	mov	r0, r4
   21d28:	f7fd f838 	bl	1ed9c <LCD_ShowString>
#endif
}
   21d2c:	b024      	add	sp, #144	; 0x90
   21d2e:	bd70      	pop	{r4, r5, r6, pc}
	else if(global_settings.language == LANGUAGE_JPN)
   21d30:	2b02      	cmp	r3, #2
   21d32:	d1d3      	bne.n	21cdc <IdleShowSystemWeek+0x38>
		strcpy(str_week,"It has no japanese font!");
   21d34:	4906      	ldr	r1, [pc, #24]	; (21d50 <IdleShowSystemWeek+0xac>)
   21d36:	e7ce      	b.n	21cd6 <IdleShowSystemWeek+0x32>
   21d38:	2002b234 	.word	0x2002b234
   21d3c:	20022240 	.word	0x20022240
   21d40:	20022242 	.word	0x20022242
   21d44:	0003c928 	.word	0x0003c928
   21d48:	2002b232 	.word	0x2002b232
   21d4c:	2002ca39 	.word	0x2002ca39
   21d50:	0003c940 	.word	0x0003c940

00021d54 <IdleUpdateBatSoc>:
	IdleShowSystemDate();
	IdleShowSystemWeek();
}

void IdleUpdateBatSoc(void)
{
   21d54:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	u16_t x,y,w,h;
	u8_t strbuf[10] = {0};
   21d56:	2300      	movs	r3, #0
	u8_t tmpbuf[128] = {0};
	
	LCD_Fill(BAT_SUBJECT_X+1,BAT_SUBJECT_Y+1,BAT_SUBJECT_W-2,BAT_SUBJECT_H-2,BLACK);
   21d58:	223a      	movs	r2, #58	; 0x3a
	u8_t strbuf[10] = {0};
   21d5a:	e9cd 3303 	strd	r3, r3, [sp, #12]
   21d5e:	f8ad 3014 	strh.w	r3, [sp, #20]
	LCD_Fill(BAT_SUBJECT_X+1,BAT_SUBJECT_Y+1,BAT_SUBJECT_W-2,BAT_SUBJECT_H-2,BLACK);
   21d62:	9300      	str	r3, [sp, #0]
   21d64:	2110      	movs	r1, #16
   21d66:	2312      	movs	r3, #18
   21d68:	2060      	movs	r0, #96	; 0x60
   21d6a:	f7fc fe5f 	bl	1ea2c <LCD_Fill>
	
	switch(g_chg_status)
   21d6e:	4b1e      	ldr	r3, [pc, #120]	; (21de8 <IdleUpdateBatSoc+0x94>)
   21d70:	781b      	ldrb	r3, [r3, #0]
   21d72:	2b01      	cmp	r3, #1
   21d74:	d031      	beq.n	21dda <IdleUpdateBatSoc+0x86>
   21d76:	b259      	sxtb	r1, r3
   21d78:	b331      	cbz	r1, 21dc8 <IdleUpdateBatSoc+0x74>
   21d7a:	2b02      	cmp	r3, #2
   21d7c:	d032      	beq.n	21de4 <IdleUpdateBatSoc+0x90>
	case BAT_CHARGING_FINISHED:
		strcpy(strbuf, "OK");
		break;
	}

	LCD_SetFontSize(FONT_SIZE_16);
   21d7e:	2010      	movs	r0, #16
   21d80:	f7fd f862 	bl	1ee48 <LCD_SetFontSize>
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
	LCD_ShowUniString(BAT_SUBJECT_X+x, BAT_SUBJECT_Y+y, tmpbuf);
	
#else

	LCD_MeasureString(strbuf, &w, &h);
   21d84:	f10d 020a 	add.w	r2, sp, #10
   21d88:	a902      	add	r1, sp, #8
   21d8a:	a803      	add	r0, sp, #12
   21d8c:	f7fd f838 	bl	1ee00 <LCD_MeasureString>
	x = (w > BAT_SUBJECT_W ? BAT_SUBJECT_X : (BAT_SUBJECT_W-w)/2);
   21d90:	f8bd 0008 	ldrh.w	r0, [sp, #8]
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
   21d94:	f8bd 100a 	ldrh.w	r1, [sp, #10]
	x = (w > BAT_SUBJECT_W ? BAT_SUBJECT_X : (BAT_SUBJECT_W-w)/2);
   21d98:	283c      	cmp	r0, #60	; 0x3c
   21d9a:	bf9a      	itte	ls
   21d9c:	f1c0 003c 	rsbls	r0, r0, #60	; 0x3c
   21da0:	f3c0 004f 	ubfxls	r0, r0, #1, #16
   21da4:	205f      	movhi	r0, #95	; 0x5f
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
   21da6:	2914      	cmp	r1, #20
   21da8:	bf8e      	itee	hi
   21daa:	210f      	movhi	r1, #15
   21dac:	f1c1 0114 	rsbls	r1, r1, #20
   21db0:	f3c1 014f 	ubfxls	r1, r1, #1, #16
	LCD_ShowString(BAT_SUBJECT_X+x, BAT_SUBJECT_Y+y, strbuf);
   21db4:	310f      	adds	r1, #15
   21db6:	305f      	adds	r0, #95	; 0x5f
   21db8:	aa03      	add	r2, sp, #12
   21dba:	b289      	uxth	r1, r1
   21dbc:	b280      	uxth	r0, r0
   21dbe:	f7fc ffed 	bl	1ed9c <LCD_ShowString>
#endif
}
   21dc2:	b007      	add	sp, #28
   21dc4:	f85d fb04 	ldr.w	pc, [sp], #4
		sprintf(strbuf, "%02d", g_bat_soc);
   21dc8:	4b08      	ldr	r3, [pc, #32]	; (21dec <IdleUpdateBatSoc+0x98>)
   21dca:	220a      	movs	r2, #10
   21dcc:	781b      	ldrb	r3, [r3, #0]
   21dce:	a803      	add	r0, sp, #12
   21dd0:	9300      	str	r3, [sp, #0]
   21dd2:	4b07      	ldr	r3, [pc, #28]	; (21df0 <IdleUpdateBatSoc+0x9c>)
   21dd4:	f018 f935 	bl	3a042 <__sprintf_chk>
		break;
   21dd8:	e7d1      	b.n	21d7e <IdleUpdateBatSoc+0x2a>
		strcpy(strbuf, "CHG");
   21dda:	4906      	ldr	r1, [pc, #24]	; (21df4 <IdleUpdateBatSoc+0xa0>)
		strcpy(strbuf, "OK");
   21ddc:	a803      	add	r0, sp, #12
   21dde:	f018 f957 	bl	3a090 <strcpy>
		break;
   21de2:	e7cc      	b.n	21d7e <IdleUpdateBatSoc+0x2a>
		strcpy(strbuf, "OK");
   21de4:	4904      	ldr	r1, [pc, #16]	; (21df8 <IdleUpdateBatSoc+0xa4>)
   21de6:	e7f9      	b.n	21ddc <IdleUpdateBatSoc+0x88>
   21de8:	20024cdc 	.word	0x20024cdc
   21dec:	20024cdb 	.word	0x20024cdb
   21df0:	0003b91b 	.word	0x0003b91b
   21df4:	0003c959 	.word	0x0003c959
   21df8:	0003c95d 	.word	0x0003c95d

00021dfc <IdleShowBatSoc>:
{
	u16_t x,y,w,h;
	u8_t strbuf[10] = {0};
	u8_t tmpbuf[128] = {0};
	
	LCD_DrawRectangle(BAT_POSITIVE_X,BAT_POSITIVE_Y,BAT_POSITIVE_W,BAT_POSITIVE_H);
   21dfc:	230a      	movs	r3, #10
{
   21dfe:	b510      	push	{r4, lr}
	u8_t strbuf[10] = {0};
   21e00:	2400      	movs	r4, #0
{
   21e02:	b086      	sub	sp, #24
	LCD_DrawRectangle(BAT_POSITIVE_X,BAT_POSITIVE_Y,BAT_POSITIVE_W,BAT_POSITIVE_H);
   21e04:	461a      	mov	r2, r3
   21e06:	2114      	movs	r1, #20
   21e08:	2055      	movs	r0, #85	; 0x55
	u8_t strbuf[10] = {0};
   21e0a:	e9cd 4403 	strd	r4, r4, [sp, #12]
   21e0e:	f8ad 4014 	strh.w	r4, [sp, #20]
	LCD_DrawRectangle(BAT_POSITIVE_X,BAT_POSITIVE_Y,BAT_POSITIVE_W,BAT_POSITIVE_H);
   21e12:	f7fc fe2f 	bl	1ea74 <LCD_DrawRectangle>
	LCD_DrawRectangle(BAT_SUBJECT_X,BAT_SUBJECT_Y,BAT_SUBJECT_W,BAT_SUBJECT_H);
   21e16:	2314      	movs	r3, #20
   21e18:	223c      	movs	r2, #60	; 0x3c
   21e1a:	210f      	movs	r1, #15
   21e1c:	205f      	movs	r0, #95	; 0x5f
   21e1e:	f7fc fe29 	bl	1ea74 <LCD_DrawRectangle>
	LCD_Fill(BAT_SUBJECT_X+1,BAT_SUBJECT_Y+1,BAT_SUBJECT_W-2,BAT_SUBJECT_H-2,BLACK);
   21e22:	2312      	movs	r3, #18
   21e24:	9400      	str	r4, [sp, #0]
   21e26:	223a      	movs	r2, #58	; 0x3a
   21e28:	2110      	movs	r1, #16
   21e2a:	2060      	movs	r0, #96	; 0x60
   21e2c:	f7fc fdfe 	bl	1ea2c <LCD_Fill>
	
	switch(g_chg_status)
   21e30:	4b1d      	ldr	r3, [pc, #116]	; (21ea8 <IdleShowBatSoc+0xac>)
   21e32:	781b      	ldrb	r3, [r3, #0]
   21e34:	2b01      	cmp	r3, #1
   21e36:	d030      	beq.n	21e9a <IdleShowBatSoc+0x9e>
   21e38:	b259      	sxtb	r1, r3
   21e3a:	b329      	cbz	r1, 21e88 <IdleShowBatSoc+0x8c>
   21e3c:	2b02      	cmp	r3, #2
   21e3e:	d031      	beq.n	21ea4 <IdleShowBatSoc+0xa8>
	case BAT_CHARGING_FINISHED:
		strcpy(strbuf, "OK");
		break;
	}

	LCD_SetFontSize(FONT_SIZE_16);
   21e40:	2010      	movs	r0, #16
   21e42:	f7fd f801 	bl	1ee48 <LCD_SetFontSize>
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
	LCD_ShowUniString(BAT_SUBJECT_X+x, BAT_SUBJECT_Y+y, tmpbuf);
	
#else
	
	LCD_MeasureString(strbuf, &w, &h);
   21e46:	f10d 020a 	add.w	r2, sp, #10
   21e4a:	a902      	add	r1, sp, #8
   21e4c:	a803      	add	r0, sp, #12
   21e4e:	f7fc ffd7 	bl	1ee00 <LCD_MeasureString>
	x = (w > BAT_SUBJECT_W ? BAT_SUBJECT_X : (BAT_SUBJECT_W-w)/2);
   21e52:	f8bd 0008 	ldrh.w	r0, [sp, #8]
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
   21e56:	f8bd 100a 	ldrh.w	r1, [sp, #10]
	x = (w > BAT_SUBJECT_W ? BAT_SUBJECT_X : (BAT_SUBJECT_W-w)/2);
   21e5a:	283c      	cmp	r0, #60	; 0x3c
   21e5c:	bf9a      	itte	ls
   21e5e:	f1c0 003c 	rsbls	r0, r0, #60	; 0x3c
   21e62:	f3c0 004f 	ubfxls	r0, r0, #1, #16
   21e66:	205f      	movhi	r0, #95	; 0x5f
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
   21e68:	2914      	cmp	r1, #20
   21e6a:	bf8e      	itee	hi
   21e6c:	210f      	movhi	r1, #15
   21e6e:	f1c1 0114 	rsbls	r1, r1, #20
   21e72:	f3c1 014f 	ubfxls	r1, r1, #1, #16
	LCD_ShowString(BAT_SUBJECT_X+x, BAT_SUBJECT_Y+y, strbuf);
   21e76:	310f      	adds	r1, #15
   21e78:	305f      	adds	r0, #95	; 0x5f
   21e7a:	aa03      	add	r2, sp, #12
   21e7c:	b289      	uxth	r1, r1
   21e7e:	b280      	uxth	r0, r0
   21e80:	f7fc ff8c 	bl	1ed9c <LCD_ShowString>
#endif
}
   21e84:	b006      	add	sp, #24
   21e86:	bd10      	pop	{r4, pc}
		sprintf(strbuf, "%02d", g_bat_soc);
   21e88:	4b08      	ldr	r3, [pc, #32]	; (21eac <IdleShowBatSoc+0xb0>)
   21e8a:	220a      	movs	r2, #10
   21e8c:	781b      	ldrb	r3, [r3, #0]
   21e8e:	a803      	add	r0, sp, #12
   21e90:	9300      	str	r3, [sp, #0]
   21e92:	4b07      	ldr	r3, [pc, #28]	; (21eb0 <IdleShowBatSoc+0xb4>)
   21e94:	f018 f8d5 	bl	3a042 <__sprintf_chk>
		break;
   21e98:	e7d2      	b.n	21e40 <IdleShowBatSoc+0x44>
		strcpy(strbuf, "CHG");
   21e9a:	4906      	ldr	r1, [pc, #24]	; (21eb4 <IdleShowBatSoc+0xb8>)
		strcpy(strbuf, "OK");
   21e9c:	a803      	add	r0, sp, #12
   21e9e:	f018 f8f7 	bl	3a090 <strcpy>
		break;
   21ea2:	e7cd      	b.n	21e40 <IdleShowBatSoc+0x44>
		strcpy(strbuf, "OK");
   21ea4:	4904      	ldr	r1, [pc, #16]	; (21eb8 <IdleShowBatSoc+0xbc>)
   21ea6:	e7f9      	b.n	21e9c <IdleShowBatSoc+0xa0>
   21ea8:	20024cdc 	.word	0x20024cdc
   21eac:	20024cdb 	.word	0x20024cdb
   21eb0:	0003b91b 	.word	0x0003b91b
   21eb4:	0003c959 	.word	0x0003c959
   21eb8:	0003c95d 	.word	0x0003c95d

00021ebc <IdleUpdateSportData>:

void IdleUpdateSportData(void)
{
   21ebc:	b570      	push	{r4, r5, r6, lr}
	u16_t x,y,w,h;
	u8_t strbuf[128] = {0};
   21ebe:	2580      	movs	r5, #128	; 0x80
	LCD_ShowUniString(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3+w, IMU_STEPS_SHOW_Y, tmpbuf);

#else

	LCD_MeasureString("S:", &w, &h);		
	LCD_Fill(IMU_STEPS_SHOW_X+w, IMU_STEPS_SHOW_Y, 50, IMU_STEPS_SHOW_H, BLACK);
   21ec0:	2400      	movs	r4, #0
{
   21ec2:	b0a4      	sub	sp, #144	; 0x90
	u8_t strbuf[128] = {0};
   21ec4:	462a      	mov	r2, r5
   21ec6:	2100      	movs	r1, #0
   21ec8:	a804      	add	r0, sp, #16
   21eca:	f017 ff78 	bl	39dbe <memset>
	LCD_SetFontSize(FONT_SIZE_16);
   21ece:	2010      	movs	r0, #16
   21ed0:	f7fc ffba 	bl	1ee48 <LCD_SetFontSize>
	LCD_MeasureString("S:", &w, &h);		
   21ed4:	f10d 020e 	add.w	r2, sp, #14
   21ed8:	a903      	add	r1, sp, #12
   21eda:	4831      	ldr	r0, [pc, #196]	; (21fa0 <IdleUpdateSportData+0xe4>)
   21edc:	f7fc ff90 	bl	1ee00 <LCD_MeasureString>
	LCD_Fill(IMU_STEPS_SHOW_X+w, IMU_STEPS_SHOW_Y, 50, IMU_STEPS_SHOW_H, BLACK);
   21ee0:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   21ee4:	9400      	str	r4, [sp, #0]
   21ee6:	300f      	adds	r0, #15
   21ee8:	2314      	movs	r3, #20
   21eea:	2232      	movs	r2, #50	; 0x32
   21eec:	21a0      	movs	r1, #160	; 0xa0
   21eee:	b280      	uxth	r0, r0
   21ef0:	f7fc fd9c 	bl	1ea2c <LCD_Fill>
	sprintf(strbuf, "%d", g_steps);
   21ef4:	4b2b      	ldr	r3, [pc, #172]	; (21fa4 <IdleUpdateSportData+0xe8>)
   21ef6:	4e2c      	ldr	r6, [pc, #176]	; (21fa8 <IdleUpdateSportData+0xec>)
   21ef8:	881b      	ldrh	r3, [r3, #0]
   21efa:	462a      	mov	r2, r5
   21efc:	9300      	str	r3, [sp, #0]
   21efe:	4621      	mov	r1, r4
   21f00:	4633      	mov	r3, r6
   21f02:	a804      	add	r0, sp, #16
   21f04:	f018 f89d 	bl	3a042 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X+w, IMU_STEPS_SHOW_Y, strbuf);
   21f08:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   21f0c:	aa04      	add	r2, sp, #16
   21f0e:	300f      	adds	r0, #15
   21f10:	21a0      	movs	r1, #160	; 0xa0
   21f12:	b280      	uxth	r0, r0
   21f14:	f7fc ff42 	bl	1ed9c <LCD_ShowString>

	LCD_MeasureString("D:", &w, &h);
   21f18:	f10d 020e 	add.w	r2, sp, #14
   21f1c:	a903      	add	r1, sp, #12
   21f1e:	4823      	ldr	r0, [pc, #140]	; (21fac <IdleUpdateSportData+0xf0>)
   21f20:	f7fc ff6e 	bl	1ee00 <LCD_MeasureString>
	LCD_Fill(IMU_STEPS_SHOW_X+IMU_STEPS_SHOW_W/3+w, IMU_STEPS_SHOW_Y, 50, IMU_STEPS_SHOW_H, BLACK);
   21f24:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   21f28:	9400      	str	r4, [sp, #0]
   21f2a:	3055      	adds	r0, #85	; 0x55
   21f2c:	2314      	movs	r3, #20
   21f2e:	2232      	movs	r2, #50	; 0x32
   21f30:	21a0      	movs	r1, #160	; 0xa0
   21f32:	b280      	uxth	r0, r0
   21f34:	f7fc fd7a 	bl	1ea2c <LCD_Fill>
	sprintf(strbuf, "%d", g_distance);
   21f38:	4b1d      	ldr	r3, [pc, #116]	; (21fb0 <IdleUpdateSportData+0xf4>)
   21f3a:	462a      	mov	r2, r5
   21f3c:	881b      	ldrh	r3, [r3, #0]
   21f3e:	4621      	mov	r1, r4
   21f40:	9300      	str	r3, [sp, #0]
   21f42:	a804      	add	r0, sp, #16
   21f44:	4633      	mov	r3, r6
   21f46:	f018 f87c 	bl	3a042 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X+IMU_STEPS_SHOW_W/3+w, IMU_STEPS_SHOW_Y, strbuf);
   21f4a:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   21f4e:	aa04      	add	r2, sp, #16
   21f50:	3055      	adds	r0, #85	; 0x55
   21f52:	21a0      	movs	r1, #160	; 0xa0
   21f54:	b280      	uxth	r0, r0
   21f56:	f7fc ff21 	bl	1ed9c <LCD_ShowString>

	LCD_MeasureString("C:", &w, &h);
   21f5a:	f10d 020e 	add.w	r2, sp, #14
   21f5e:	a903      	add	r1, sp, #12
   21f60:	4814      	ldr	r0, [pc, #80]	; (21fb4 <IdleUpdateSportData+0xf8>)
   21f62:	f7fc ff4d 	bl	1ee00 <LCD_MeasureString>
	LCD_Fill(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3+w, IMU_STEPS_SHOW_Y, 50, IMU_STEPS_SHOW_H, BLACK);
   21f66:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   21f6a:	9400      	str	r4, [sp, #0]
   21f6c:	309b      	adds	r0, #155	; 0x9b
   21f6e:	2314      	movs	r3, #20
   21f70:	2232      	movs	r2, #50	; 0x32
   21f72:	21a0      	movs	r1, #160	; 0xa0
   21f74:	b280      	uxth	r0, r0
   21f76:	f7fc fd59 	bl	1ea2c <LCD_Fill>
	sprintf(strbuf, "%d", g_calorie);
   21f7a:	4b0f      	ldr	r3, [pc, #60]	; (21fb8 <IdleUpdateSportData+0xfc>)
   21f7c:	462a      	mov	r2, r5
   21f7e:	881b      	ldrh	r3, [r3, #0]
   21f80:	4621      	mov	r1, r4
   21f82:	9300      	str	r3, [sp, #0]
   21f84:	a804      	add	r0, sp, #16
   21f86:	4633      	mov	r3, r6
   21f88:	f018 f85b 	bl	3a042 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3+w, IMU_STEPS_SHOW_Y, strbuf);
   21f8c:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   21f90:	aa04      	add	r2, sp, #16
   21f92:	309b      	adds	r0, #155	; 0x9b
   21f94:	21a0      	movs	r1, #160	; 0xa0
   21f96:	b280      	uxth	r0, r0
   21f98:	f7fc ff00 	bl	1ed9c <LCD_ShowString>
#endif
}
   21f9c:	b024      	add	sp, #144	; 0x90
   21f9e:	bd70      	pop	{r4, r5, r6, pc}
   21fa0:	0003c960 	.word	0x0003c960
   21fa4:	2002228e 	.word	0x2002228e
   21fa8:	0003c375 	.word	0x0003c375
   21fac:	0003c963 	.word	0x0003c963
   21fb0:	2002228c 	.word	0x2002228c
   21fb4:	0003c966 	.word	0x0003c966
   21fb8:	2002228a 	.word	0x2002228a

00021fbc <IdleShowSportData>:

void IdleShowSportData(void)
{
   21fbc:	b530      	push	{r4, r5, lr}
	u16_t x,y,w,h;
	u8_t strbuf[128] = {0};
   21fbe:	2580      	movs	r5, #128	; 0x80
	sprintf(strbuf, "C:%d", g_calorie);
	mmi_asc_to_ucs2(tmpbuf,strbuf);
	LCD_ShowUniString(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3, IMU_STEPS_SHOW_Y, tmpbuf);

#else
	LCD_Fill(IMU_STEPS_SHOW_X,IMU_STEPS_SHOW_Y,IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_H,BLACK);
   21fc0:	2400      	movs	r4, #0
{
   21fc2:	b0a3      	sub	sp, #140	; 0x8c
	u8_t strbuf[128] = {0};
   21fc4:	462a      	mov	r2, r5
   21fc6:	2100      	movs	r1, #0
   21fc8:	a802      	add	r0, sp, #8
   21fca:	f017 fef8 	bl	39dbe <memset>
	LCD_SetFontSize(FONT_SIZE_16);
   21fce:	2010      	movs	r0, #16
   21fd0:	f7fc ff3a 	bl	1ee48 <LCD_SetFontSize>
	LCD_Fill(IMU_STEPS_SHOW_X,IMU_STEPS_SHOW_Y,IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_H,BLACK);
   21fd4:	9400      	str	r4, [sp, #0]
   21fd6:	2314      	movs	r3, #20
   21fd8:	2246      	movs	r2, #70	; 0x46
   21fda:	21a0      	movs	r1, #160	; 0xa0
   21fdc:	200f      	movs	r0, #15
   21fde:	f7fc fd25 	bl	1ea2c <LCD_Fill>
	sprintf(strbuf, "S:%d", g_steps);
   21fe2:	4b1d      	ldr	r3, [pc, #116]	; (22058 <IdleShowSportData+0x9c>)
   21fe4:	462a      	mov	r2, r5
   21fe6:	881b      	ldrh	r3, [r3, #0]
   21fe8:	4621      	mov	r1, r4
   21fea:	9300      	str	r3, [sp, #0]
   21fec:	a802      	add	r0, sp, #8
   21fee:	4b1b      	ldr	r3, [pc, #108]	; (2205c <IdleShowSportData+0xa0>)
   21ff0:	f018 f827 	bl	3a042 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X, IMU_STEPS_SHOW_Y, strbuf);
   21ff4:	aa02      	add	r2, sp, #8
   21ff6:	21a0      	movs	r1, #160	; 0xa0
   21ff8:	200f      	movs	r0, #15
   21ffa:	f7fc fecf 	bl	1ed9c <LCD_ShowString>

	LCD_Fill(IMU_STEPS_SHOW_X+IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_Y,IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_H,BLACK);
   21ffe:	9400      	str	r4, [sp, #0]
   22000:	2314      	movs	r3, #20
   22002:	2246      	movs	r2, #70	; 0x46
   22004:	21a0      	movs	r1, #160	; 0xa0
   22006:	2055      	movs	r0, #85	; 0x55
   22008:	f7fc fd10 	bl	1ea2c <LCD_Fill>
	sprintf(strbuf, "D:%d", g_distance);
   2200c:	4b14      	ldr	r3, [pc, #80]	; (22060 <IdleShowSportData+0xa4>)
   2200e:	462a      	mov	r2, r5
   22010:	881b      	ldrh	r3, [r3, #0]
   22012:	4621      	mov	r1, r4
   22014:	9300      	str	r3, [sp, #0]
   22016:	a802      	add	r0, sp, #8
   22018:	4b12      	ldr	r3, [pc, #72]	; (22064 <IdleShowSportData+0xa8>)
   2201a:	f018 f812 	bl	3a042 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X+IMU_STEPS_SHOW_W/3, IMU_STEPS_SHOW_Y, strbuf);
   2201e:	aa02      	add	r2, sp, #8
   22020:	21a0      	movs	r1, #160	; 0xa0
   22022:	2055      	movs	r0, #85	; 0x55
   22024:	f7fc feba 	bl	1ed9c <LCD_ShowString>

	LCD_Fill(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_Y,IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_H,BLACK);
   22028:	9400      	str	r4, [sp, #0]
   2202a:	2314      	movs	r3, #20
   2202c:	2246      	movs	r2, #70	; 0x46
   2202e:	21a0      	movs	r1, #160	; 0xa0
   22030:	209b      	movs	r0, #155	; 0x9b
   22032:	f7fc fcfb 	bl	1ea2c <LCD_Fill>
	sprintf(strbuf, "C:%d", g_calorie);
   22036:	4b0c      	ldr	r3, [pc, #48]	; (22068 <IdleShowSportData+0xac>)
   22038:	462a      	mov	r2, r5
   2203a:	881b      	ldrh	r3, [r3, #0]
   2203c:	4621      	mov	r1, r4
   2203e:	9300      	str	r3, [sp, #0]
   22040:	a802      	add	r0, sp, #8
   22042:	4b0a      	ldr	r3, [pc, #40]	; (2206c <IdleShowSportData+0xb0>)
   22044:	f017 fffd 	bl	3a042 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3, IMU_STEPS_SHOW_Y, strbuf);
   22048:	aa02      	add	r2, sp, #8
   2204a:	21a0      	movs	r1, #160	; 0xa0
   2204c:	209b      	movs	r0, #155	; 0x9b
   2204e:	f7fc fea5 	bl	1ed9c <LCD_ShowString>
#endif
}
   22052:	b023      	add	sp, #140	; 0x8c
   22054:	bd30      	pop	{r4, r5, pc}
   22056:	bf00      	nop
   22058:	2002228e 	.word	0x2002228e
   2205c:	0003c919 	.word	0x0003c919
   22060:	2002228c 	.word	0x2002228c
   22064:	0003c91e 	.word	0x0003c91e
   22068:	2002228a 	.word	0x2002228a
   2206c:	0003c923 	.word	0x0003c923

00022070 <IdleScreenProcess>:

void IdleScreenProcess(void)
{
	switch(scr_msg[SCREEN_ID_IDLE].act)
   22070:	4b24      	ldr	r3, [pc, #144]	; (22104 <IdleScreenProcess+0x94>)
{
   22072:	b510      	push	{r4, lr}
	switch(scr_msg[SCREEN_ID_IDLE].act)
   22074:	7a5a      	ldrb	r2, [r3, #9]
   22076:	461c      	mov	r4, r3
   22078:	2a01      	cmp	r2, #1
   2207a:	d002      	beq.n	22082 <IdleScreenProcess+0x12>
   2207c:	2a02      	cmp	r2, #2
   2207e:	d00d      	beq.n	2209c <IdleScreenProcess+0x2c>
		}

		if(scr_msg[SCREEN_ID_IDLE].para == SCREEN_EVENT_UPDATE_NO)
			scr_msg[SCREEN_ID_IDLE].act = SCREEN_ACTION_NO;
	}
}
   22080:	bd10      	pop	{r4, pc}
		scr_msg[SCREEN_ID_IDLE].status = SCREEN_STATUS_CREATED;
   22082:	2202      	movs	r2, #2
		LCD_Clear(BLACK);
   22084:	2000      	movs	r0, #0
		scr_msg[SCREEN_ID_IDLE].status = SCREEN_STATUS_CREATED;
   22086:	811a      	strh	r2, [r3, #8]
		LCD_Clear(BLACK);
   22088:	f015 f9b8 	bl	373fc <LCD_Clear>
		IdleShowBatSoc();
   2208c:	f7ff feb6 	bl	21dfc <IdleShowBatSoc>
		IdleShowDateTime();
   22090:	f015 fa67 	bl	37562 <IdleShowDateTime>
}
   22094:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		IdleShowSportData();
   22098:	f7ff bf90 	b.w	21fbc <IdleShowSportData>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_BAT)
   2209c:	68db      	ldr	r3, [r3, #12]
   2209e:	07d8      	lsls	r0, r3, #31
   220a0:	d504      	bpl.n	220ac <IdleScreenProcess+0x3c>
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_BAT);
   220a2:	f023 0301 	bic.w	r3, r3, #1
   220a6:	60e3      	str	r3, [r4, #12]
			IdleUpdateBatSoc();
   220a8:	f7ff fe54 	bl	21d54 <IdleUpdateBatSoc>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_TIME)
   220ac:	68e3      	ldr	r3, [r4, #12]
   220ae:	0799      	lsls	r1, r3, #30
   220b0:	d504      	bpl.n	220bc <IdleScreenProcess+0x4c>
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_TIME);
   220b2:	f023 0302 	bic.w	r3, r3, #2
   220b6:	60e3      	str	r3, [r4, #12]
			IdleShowSystemTime();
   220b8:	f7ff fdb0 	bl	21c1c <IdleShowSystemTime>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_DATE)
   220bc:	68e3      	ldr	r3, [r4, #12]
   220be:	075a      	lsls	r2, r3, #29
   220c0:	d504      	bpl.n	220cc <IdleScreenProcess+0x5c>
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_DATE);
   220c2:	f023 0304 	bic.w	r3, r3, #4
   220c6:	60e3      	str	r3, [r4, #12]
			IdleShowSystemDate();
   220c8:	f7ff fd64 	bl	21b94 <IdleShowSystemDate>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_WEEK)
   220cc:	68e3      	ldr	r3, [r4, #12]
   220ce:	0718      	lsls	r0, r3, #28
   220d0:	d504      	bpl.n	220dc <IdleScreenProcess+0x6c>
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_WEEK);
   220d2:	f023 0308 	bic.w	r3, r3, #8
   220d6:	60e3      	str	r3, [r4, #12]
			IdleShowSystemWeek();
   220d8:	f7ff fde4 	bl	21ca4 <IdleShowSystemWeek>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_SPORT)
   220dc:	68e3      	ldr	r3, [r4, #12]
   220de:	06d9      	lsls	r1, r3, #27
   220e0:	d504      	bpl.n	220ec <IdleScreenProcess+0x7c>
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_SPORT);
   220e2:	f023 0310 	bic.w	r3, r3, #16
   220e6:	60e3      	str	r3, [r4, #12]
			IdleUpdateSportData();
   220e8:	f7ff fee8 	bl	21ebc <IdleUpdateSportData>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_SLEEP)
   220ec:	68e3      	ldr	r3, [r4, #12]
   220ee:	069a      	lsls	r2, r3, #26
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_SLEEP);
   220f0:	bf44      	itt	mi
   220f2:	f023 0320 	bicmi.w	r3, r3, #32
   220f6:	60e3      	strmi	r3, [r4, #12]
		if(scr_msg[SCREEN_ID_IDLE].para == SCREEN_EVENT_UPDATE_NO)
   220f8:	68e3      	ldr	r3, [r4, #12]
   220fa:	2b00      	cmp	r3, #0
   220fc:	d1c0      	bne.n	22080 <IdleScreenProcess+0x10>
			scr_msg[SCREEN_ID_IDLE].act = SCREEN_ACTION_NO;
   220fe:	7263      	strb	r3, [r4, #9]
}
   22100:	e7be      	b.n	22080 <IdleScreenProcess+0x10>
   22102:	bf00      	nop
   22104:	200203c0 	.word	0x200203c0

00022108 <AlarmScreenProcess>:

void AlarmScreenProcess(void)
{
   22108:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2210c:	b0a5      	sub	sp, #148	; 0x94
	u16_t rect_x,rect_y,rect_w=180,rect_h=80;
	u16_t x,y,w,h;
	u8_t notify[128] = "Alarm Notify!";
   2210e:	aa04      	add	r2, sp, #16
   22110:	4617      	mov	r7, r2
   22112:	4b30      	ldr	r3, [pc, #192]	; (221d4 <AlarmScreenProcess+0xcc>)
   22114:	f103 0508 	add.w	r5, r3, #8
   22118:	4614      	mov	r4, r2
   2211a:	6818      	ldr	r0, [r3, #0]
   2211c:	6859      	ldr	r1, [r3, #4]
   2211e:	3308      	adds	r3, #8
   22120:	c403      	stmia	r4!, {r0, r1}
   22122:	42ab      	cmp	r3, r5
   22124:	4622      	mov	r2, r4
   22126:	d1f7      	bne.n	22118 <AlarmScreenProcess+0x10>
   22128:	6818      	ldr	r0, [r3, #0]
   2212a:	889b      	ldrh	r3, [r3, #4]

	switch(scr_msg[SCREEN_ID_ALARM].act)
   2212c:	4e2a      	ldr	r6, [pc, #168]	; (221d8 <AlarmScreenProcess+0xd0>)
	u8_t notify[128] = "Alarm Notify!";
   2212e:	6020      	str	r0, [r4, #0]
   22130:	80a3      	strh	r3, [r4, #4]
   22132:	2272      	movs	r2, #114	; 0x72
   22134:	2100      	movs	r1, #0
   22136:	f10d 001e 	add.w	r0, sp, #30
   2213a:	f017 fe40 	bl	39dbe <memset>
	switch(scr_msg[SCREEN_ID_ALARM].act)
   2213e:	7c73      	ldrb	r3, [r6, #17]
   22140:	2b01      	cmp	r3, #1
   22142:	d142      	bne.n	221ca <AlarmScreenProcess+0xc2>
	{
	case SCREEN_ACTION_ENTER:
		scr_msg[SCREEN_ID_ALARM].act = SCREEN_ACTION_NO;
		scr_msg[SCREEN_ID_ALARM].status = SCREEN_STATUS_CREATED;
   22144:	2302      	movs	r3, #2
   22146:	8233      	strh	r3, [r6, #16]
				
		rect_x = (LCD_WIDTH-rect_w)/2;
   22148:	4b24      	ldr	r3, [pc, #144]	; (221dc <AlarmScreenProcess+0xd4>)
		rect_y = (LCD_HEIGHT-rect_h)/2;
		
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   2214a:	22b4      	movs	r2, #180	; 0xb4
		rect_x = (LCD_WIDTH-rect_w)/2;
   2214c:	881c      	ldrh	r4, [r3, #0]
		rect_y = (LCD_HEIGHT-rect_h)/2;
   2214e:	4b24      	ldr	r3, [pc, #144]	; (221e0 <AlarmScreenProcess+0xd8>)
		rect_x = (LCD_WIDTH-rect_w)/2;
   22150:	3cb4      	subs	r4, #180	; 0xb4
		rect_y = (LCD_HEIGHT-rect_h)/2;
   22152:	881d      	ldrh	r5, [r3, #0]
		rect_x = (LCD_WIDTH-rect_w)/2;
   22154:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
		rect_y = (LCD_HEIGHT-rect_h)/2;
   22158:	3d50      	subs	r5, #80	; 0x50
   2215a:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   2215e:	106d      	asrs	r5, r5, #1
		rect_x = (LCD_WIDTH-rect_w)/2;
   22160:	1064      	asrs	r4, r4, #1
		rect_y = (LCD_HEIGHT-rect_h)/2;
   22162:	fa1f f985 	uxth.w	r9, r5
		rect_x = (LCD_WIDTH-rect_w)/2;
   22166:	fa1f f884 	uxth.w	r8, r4
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   2216a:	2350      	movs	r3, #80	; 0x50
   2216c:	4649      	mov	r1, r9
   2216e:	4640      	mov	r0, r8
   22170:	f7fc fc80 	bl	1ea74 <LCD_DrawRectangle>
		LCD_Fill(rect_x+1, rect_y+1, rect_w-2, rect_h-2, BLACK);
   22174:	1c69      	adds	r1, r5, #1
   22176:	2500      	movs	r5, #0
   22178:	1c60      	adds	r0, r4, #1
   2217a:	9500      	str	r5, [sp, #0]
   2217c:	234e      	movs	r3, #78	; 0x4e
   2217e:	22b2      	movs	r2, #178	; 0xb2
   22180:	b289      	uxth	r1, r1
   22182:	b280      	uxth	r0, r0
   22184:	f7fc fc52 	bl	1ea2c <LCD_Fill>

	#ifdef FONT_24
		LCD_SetFontSize(FONT_SIZE_24);
   22188:	2018      	movs	r0, #24
   2218a:	f7fc fe5d 	bl	1ee48 <LCD_SetFontSize>
	#else
		LCD_SetFontSize(FONT_SIZE_16);
	#endif
		LCD_MeasureString(notify,&w,&h);
   2218e:	f10d 020e 	add.w	r2, sp, #14
   22192:	a903      	add	r1, sp, #12
   22194:	4638      	mov	r0, r7
   22196:	f7fc fe33 	bl	1ee00 <LCD_MeasureString>
		x = (w > rect_w)? 0 : (rect_w-w)/2;
   2219a:	f8bd 000c 	ldrh.w	r0, [sp, #12]
		y = (h > rect_h)? 0 : (rect_h-h)/2;
   2219e:	f8bd 100e 	ldrh.w	r1, [sp, #14]
		x = (w > rect_w)? 0 : (rect_w-w)/2;
   221a2:	28b4      	cmp	r0, #180	; 0xb4
   221a4:	bf9c      	itt	ls
   221a6:	f1c0 05b4 	rsbls	r5, r0, #180	; 0xb4
   221aa:	f3c5 054f 	ubfxls	r5, r5, #1, #16
		y = (h > rect_h)? 0 : (rect_h-h)/2;
   221ae:	2950      	cmp	r1, #80	; 0x50
   221b0:	bf8e      	itee	hi
   221b2:	2100      	movhi	r1, #0
   221b4:	f1c1 0150 	rsbls	r1, r1, #80	; 0x50
   221b8:	f3c1 014f 	ubfxls	r1, r1, #1, #16
		x += rect_x;
		y += rect_y;
   221bc:	4449      	add	r1, r9
		x += rect_x;
   221be:	4445      	add	r5, r8
		LCD_ShowString(x,y,notify);
   221c0:	463a      	mov	r2, r7
   221c2:	b289      	uxth	r1, r1
   221c4:	b2a8      	uxth	r0, r5
   221c6:	f7fc fde9 	bl	1ed9c <LCD_ShowString>
		
	case SCREEN_ACTION_UPDATE:
		break;
	}
	
	scr_msg[SCREEN_ID_ALARM].act = SCREEN_ACTION_NO;
   221ca:	2300      	movs	r3, #0
   221cc:	7473      	strb	r3, [r6, #17]
}
   221ce:	b025      	add	sp, #148	; 0x94
   221d0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   221d4:	0003af70 	.word	0x0003af70
   221d8:	200203c0 	.word	0x200203c0
   221dc:	2002b232 	.word	0x2002b232
   221e0:	2002b230 	.word	0x2002b230

000221e4 <FindDeviceScreenProcess>:

void FindDeviceScreenProcess(void)
{
   221e4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   221e8:	b0a5      	sub	sp, #148	; 0x94
	u16_t rect_x,rect_y,rect_w=180,rect_h=80;
	u16_t x,y,w,h;
	u8_t notify[128] = "Find Device!";
   221ea:	aa04      	add	r2, sp, #16
   221ec:	4617      	mov	r7, r2
   221ee:	4b30      	ldr	r3, [pc, #192]	; (222b0 <FindDeviceScreenProcess+0xcc>)
   221f0:	f103 0508 	add.w	r5, r3, #8
   221f4:	4614      	mov	r4, r2
   221f6:	6818      	ldr	r0, [r3, #0]
   221f8:	6859      	ldr	r1, [r3, #4]
   221fa:	3308      	adds	r3, #8
   221fc:	c403      	stmia	r4!, {r0, r1}
   221fe:	42ab      	cmp	r3, r5
   22200:	4622      	mov	r2, r4
   22202:	d1f7      	bne.n	221f4 <FindDeviceScreenProcess+0x10>
   22204:	6818      	ldr	r0, [r3, #0]
   22206:	791b      	ldrb	r3, [r3, #4]

	switch(scr_msg[SCREEN_ID_FIND_DEVICE].act)
   22208:	4e2a      	ldr	r6, [pc, #168]	; (222b4 <FindDeviceScreenProcess+0xd0>)
	u8_t notify[128] = "Find Device!";
   2220a:	6020      	str	r0, [r4, #0]
   2220c:	7123      	strb	r3, [r4, #4]
   2220e:	2273      	movs	r2, #115	; 0x73
   22210:	2100      	movs	r1, #0
   22212:	f10d 001d 	add.w	r0, sp, #29
   22216:	f017 fdd2 	bl	39dbe <memset>
	switch(scr_msg[SCREEN_ID_FIND_DEVICE].act)
   2221a:	7e73      	ldrb	r3, [r6, #25]
   2221c:	2b01      	cmp	r3, #1
   2221e:	d142      	bne.n	222a6 <FindDeviceScreenProcess+0xc2>
	{
	case SCREEN_ACTION_ENTER:
		scr_msg[SCREEN_ID_FIND_DEVICE].act = SCREEN_ACTION_NO;
		scr_msg[SCREEN_ID_FIND_DEVICE].status = SCREEN_STATUS_CREATED;
   22220:	2302      	movs	r3, #2
   22222:	8333      	strh	r3, [r6, #24]
				
		rect_x = (LCD_WIDTH-rect_w)/2;
   22224:	4b24      	ldr	r3, [pc, #144]	; (222b8 <FindDeviceScreenProcess+0xd4>)
		rect_y = (LCD_HEIGHT-rect_h)/2;
		
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   22226:	22b4      	movs	r2, #180	; 0xb4
		rect_x = (LCD_WIDTH-rect_w)/2;
   22228:	881c      	ldrh	r4, [r3, #0]
		rect_y = (LCD_HEIGHT-rect_h)/2;
   2222a:	4b24      	ldr	r3, [pc, #144]	; (222bc <FindDeviceScreenProcess+0xd8>)
		rect_x = (LCD_WIDTH-rect_w)/2;
   2222c:	3cb4      	subs	r4, #180	; 0xb4
		rect_y = (LCD_HEIGHT-rect_h)/2;
   2222e:	881d      	ldrh	r5, [r3, #0]
		rect_x = (LCD_WIDTH-rect_w)/2;
   22230:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
		rect_y = (LCD_HEIGHT-rect_h)/2;
   22234:	3d50      	subs	r5, #80	; 0x50
   22236:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   2223a:	106d      	asrs	r5, r5, #1
		rect_x = (LCD_WIDTH-rect_w)/2;
   2223c:	1064      	asrs	r4, r4, #1
		rect_y = (LCD_HEIGHT-rect_h)/2;
   2223e:	fa1f f985 	uxth.w	r9, r5
		rect_x = (LCD_WIDTH-rect_w)/2;
   22242:	fa1f f884 	uxth.w	r8, r4
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   22246:	2350      	movs	r3, #80	; 0x50
   22248:	4649      	mov	r1, r9
   2224a:	4640      	mov	r0, r8
   2224c:	f7fc fc12 	bl	1ea74 <LCD_DrawRectangle>
		LCD_Fill(rect_x+1, rect_y+1, rect_w-2, rect_h-2, BLACK);
   22250:	1c69      	adds	r1, r5, #1
   22252:	2500      	movs	r5, #0
   22254:	1c60      	adds	r0, r4, #1
   22256:	9500      	str	r5, [sp, #0]
   22258:	234e      	movs	r3, #78	; 0x4e
   2225a:	22b2      	movs	r2, #178	; 0xb2
   2225c:	b289      	uxth	r1, r1
   2225e:	b280      	uxth	r0, r0
   22260:	f7fc fbe4 	bl	1ea2c <LCD_Fill>
		
	#ifdef FONT_24
		LCD_SetFontSize(FONT_SIZE_24);
   22264:	2018      	movs	r0, #24
   22266:	f7fc fdef 	bl	1ee48 <LCD_SetFontSize>
	#else
		LCD_SetFontSize(FONT_SIZE_16);
	#endif
		LCD_MeasureString(notify,&w,&h);
   2226a:	f10d 020e 	add.w	r2, sp, #14
   2226e:	a903      	add	r1, sp, #12
   22270:	4638      	mov	r0, r7
   22272:	f7fc fdc5 	bl	1ee00 <LCD_MeasureString>
		x = (w > rect_w)? 0 : (rect_w-w)/2;
   22276:	f8bd 000c 	ldrh.w	r0, [sp, #12]
		y = (h > rect_h)? 0 : (rect_h-h)/2;
   2227a:	f8bd 100e 	ldrh.w	r1, [sp, #14]
		x = (w > rect_w)? 0 : (rect_w-w)/2;
   2227e:	28b4      	cmp	r0, #180	; 0xb4
   22280:	bf9c      	itt	ls
   22282:	f1c0 05b4 	rsbls	r5, r0, #180	; 0xb4
   22286:	f3c5 054f 	ubfxls	r5, r5, #1, #16
		y = (h > rect_h)? 0 : (rect_h-h)/2;
   2228a:	2950      	cmp	r1, #80	; 0x50
   2228c:	bf8e      	itee	hi
   2228e:	2100      	movhi	r1, #0
   22290:	f1c1 0150 	rsbls	r1, r1, #80	; 0x50
   22294:	f3c1 014f 	ubfxls	r1, r1, #1, #16
		x += rect_x;
		y += rect_y;
   22298:	4449      	add	r1, r9
		x += rect_x;
   2229a:	4445      	add	r5, r8
		LCD_ShowString(x,y,notify);
   2229c:	463a      	mov	r2, r7
   2229e:	b289      	uxth	r1, r1
   222a0:	b2a8      	uxth	r0, r5
   222a2:	f7fc fd7b 	bl	1ed9c <LCD_ShowString>
		
	case SCREEN_ACTION_UPDATE:
		break;
	}
	
	scr_msg[SCREEN_ID_FIND_DEVICE].act = SCREEN_ACTION_NO;
   222a6:	2300      	movs	r3, #0
   222a8:	7673      	strb	r3, [r6, #25]
}
   222aa:	b025      	add	sp, #148	; 0x94
   222ac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   222b0:	0003aff0 	.word	0x0003aff0
   222b4:	200203c0 	.word	0x200203c0
   222b8:	2002b232 	.word	0x2002b232
   222bc:	2002b230 	.word	0x2002b230

000222c0 <NotifyScreenProcess>:

void NotifyScreenProcess(void)
{
   222c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u16_t rect_x,rect_y,rect_w=180,rect_h=120;
	u16_t x,y,w,h;
	u16_t offset_w=4,offset_h=4;

	switch(scr_msg[SCREEN_ID_NOTIFY].act)
   222c4:	4b83      	ldr	r3, [pc, #524]	; (224d4 <NotifyScreenProcess+0x214>)
{
   222c6:	b0a9      	sub	sp, #164	; 0xa4
	switch(scr_msg[SCREEN_ID_NOTIFY].act)
   222c8:	f893 2051 	ldrb.w	r2, [r3, #81]	; 0x51
   222cc:	9303      	str	r3, [sp, #12]
   222ce:	2a01      	cmp	r2, #1
   222d0:	d135      	bne.n	2233e <NotifyScreenProcess+0x7e>
	{
	case SCREEN_ACTION_ENTER:
		scr_msg[SCREEN_ID_NOTIFY].act = SCREEN_ACTION_NO;
		scr_msg[SCREEN_ID_NOTIFY].status = SCREEN_STATUS_CREATED;
   222d2:	2302      	movs	r3, #2
   222d4:	4a7f      	ldr	r2, [pc, #508]	; (224d4 <NotifyScreenProcess+0x214>)
		
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
		LCD_Fill(rect_x+1, rect_y+1, rect_w-2, rect_h-2, BLACK);
		
		LCD_SetFontSize(FONT_SIZE_16);
		LCD_MeasureString(notify_msg.text, &w, &h);
   222d6:	f8df 920c 	ldr.w	r9, [pc, #524]	; 224e4 <NotifyScreenProcess+0x224>
		scr_msg[SCREEN_ID_NOTIFY].status = SCREEN_STATUS_CREATED;
   222da:	f8a2 3050 	strh.w	r3, [r2, #80]	; 0x50
		rect_x = (LCD_WIDTH-rect_w)/2;
   222de:	4b7e      	ldr	r3, [pc, #504]	; (224d8 <NotifyScreenProcess+0x218>)
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   222e0:	22b4      	movs	r2, #180	; 0xb4
		rect_x = (LCD_WIDTH-rect_w)/2;
   222e2:	881e      	ldrh	r6, [r3, #0]
		rect_y = (LCD_HEIGHT-rect_h)/2;
   222e4:	4b7d      	ldr	r3, [pc, #500]	; (224dc <NotifyScreenProcess+0x21c>)
		rect_x = (LCD_WIDTH-rect_w)/2;
   222e6:	3eb4      	subs	r6, #180	; 0xb4
		rect_y = (LCD_HEIGHT-rect_h)/2;
   222e8:	881d      	ldrh	r5, [r3, #0]
		rect_x = (LCD_WIDTH-rect_w)/2;
   222ea:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
		rect_y = (LCD_HEIGHT-rect_h)/2;
   222ee:	3d78      	subs	r5, #120	; 0x78
   222f0:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
		rect_x = (LCD_WIDTH-rect_w)/2;
   222f4:	1076      	asrs	r6, r6, #1
		rect_y = (LCD_HEIGHT-rect_h)/2;
   222f6:	106d      	asrs	r5, r5, #1
		rect_x = (LCD_WIDTH-rect_w)/2;
   222f8:	b2b4      	uxth	r4, r6
		rect_y = (LCD_HEIGHT-rect_h)/2;
   222fa:	fa1f f885 	uxth.w	r8, r5
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   222fe:	2378      	movs	r3, #120	; 0x78
   22300:	4641      	mov	r1, r8
   22302:	4620      	mov	r0, r4
   22304:	f7fc fbb6 	bl	1ea74 <LCD_DrawRectangle>
		LCD_Fill(rect_x+1, rect_y+1, rect_w-2, rect_h-2, BLACK);
   22308:	2300      	movs	r3, #0
   2230a:	1c69      	adds	r1, r5, #1
   2230c:	1c70      	adds	r0, r6, #1
   2230e:	22b2      	movs	r2, #178	; 0xb2
   22310:	b289      	uxth	r1, r1
   22312:	9300      	str	r3, [sp, #0]
   22314:	b280      	uxth	r0, r0
   22316:	2376      	movs	r3, #118	; 0x76
   22318:	f7fc fb88 	bl	1ea2c <LCD_Fill>
		LCD_MeasureString(notify_msg.text, &w, &h);
   2231c:	f109 0502 	add.w	r5, r9, #2
		LCD_SetFontSize(FONT_SIZE_16);
   22320:	2010      	movs	r0, #16
   22322:	f7fc fd91 	bl	1ee48 <LCD_SetFontSize>
		LCD_MeasureString(notify_msg.text, &w, &h);
   22326:	f10d 021e 	add.w	r2, sp, #30
   2232a:	a907      	add	r1, sp, #28
   2232c:	4628      	mov	r0, r5
   2232e:	f7fc fd67 	bl	1ee00 <LCD_MeasureString>
		switch(notify_msg.align)
   22332:	f899 6001 	ldrb.w	r6, [r9, #1]
   22336:	b14e      	cbz	r6, 2234c <NotifyScreenProcess+0x8c>
   22338:	2e01      	cmp	r6, #1
   2233a:	f000 80be 	beq.w	224ba <NotifyScreenProcess+0x1fa>
		
	case SCREEN_ACTION_UPDATE:
		break;
	}
	
	scr_msg[SCREEN_ID_NOTIFY].act = SCREEN_ACTION_NO;
   2233e:	2300      	movs	r3, #0
   22340:	9a03      	ldr	r2, [sp, #12]
   22342:	f882 3051 	strb.w	r3, [r2, #81]	; 0x51

}
   22346:	b029      	add	sp, #164	; 0xa4
   22348:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if(w > (rect_w-2*offset_w))
   2234c:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   22350:	f108 0804 	add.w	r8, r8, #4
   22354:	2bac      	cmp	r3, #172	; 0xac
   22356:	f8bd 701e 	ldrh.w	r7, [sp, #30]
   2235a:	fa0f f888 	sxth.w	r8, r8
   2235e:	f240 8098 	bls.w	22492 <NotifyScreenProcess+0x1d2>
				line_count = w/(rect_w-2*offset_w) + ((w%(rect_w-offset_w) != 0)? 1 : 0);
   22362:	22b0      	movs	r2, #176	; 0xb0
   22364:	fbb3 f1f2 	udiv	r1, r3, r2
   22368:	fb02 3111 	mls	r1, r2, r1, r3
   2236c:	22ac      	movs	r2, #172	; 0xac
   2236e:	fbb3 f3f2 	udiv	r3, r3, r2
   22372:	2270      	movs	r2, #112	; 0x70
				u16_t line_h=(h+offset_h);
   22374:	3704      	adds	r7, #4
				line_count = w/(rect_w-2*offset_w) + ((w%(rect_w-offset_w) != 0)? 1 : 0);
   22376:	2900      	cmp	r1, #0
   22378:	bf18      	it	ne
   2237a:	3301      	addne	r3, #1
				u16_t line_h=(h+offset_h);
   2237c:	b2bf      	uxth	r7, r7
				line_count = w/(rect_w-2*offset_w) + ((w%(rect_w-offset_w) != 0)? 1 : 0);
   2237e:	fbb2 f2f7 	udiv	r2, r2, r7
   22382:	b2db      	uxtb	r3, r3
				if(line_count > line_max)
   22384:	429a      	cmp	r2, r3
   22386:	bf28      	it	cs
   22388:	461a      	movcs	r2, r3
				text_len = strlen(notify_msg.text);
   2238a:	4628      	mov	r0, r5
   2238c:	9202      	str	r2, [sp, #8]
   2238e:	f7fa fee3 	bl	1d158 <strlen>
				y = ((rect_h-2*offset_h)-line_count*line_h)/2;
   22392:	9b02      	ldr	r3, [sp, #8]
				text_len = strlen(notify_msg.text);
   22394:	fa1f fb80 	uxth.w	fp, r0
				y = ((rect_h-2*offset_h)-line_count*line_h)/2;
   22398:	fb07 f503 	mul.w	r5, r7, r3
   2239c:	f1c5 0570 	rsb	r5, r5, #112	; 0x70
   223a0:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   223a4:	1d23      	adds	r3, r4, #4
				y += (rect_y+offset_h);
   223a6:	eb08 0565 	add.w	r5, r8, r5, asr #1
   223aa:	b21b      	sxth	r3, r3
   223ac:	b2ad      	uxth	r5, r5
					tmpbuf[i++] = notify_msg.text[byte_no++];
   223ae:	f8cd 9010 	str.w	r9, [sp, #16]
   223b2:	9305      	str	r3, [sp, #20]
				while(line_no<line_count)
   223b4:	9b02      	ldr	r3, [sp, #8]
   223b6:	2b00      	cmp	r3, #0
   223b8:	d0c1      	beq.n	2233e <NotifyScreenProcess+0x7e>
					u8_t tmpbuf[128] = {0};
   223ba:	f10d 0a20 	add.w	sl, sp, #32
   223be:	2280      	movs	r2, #128	; 0x80
   223c0:	2100      	movs	r1, #0
   223c2:	4650      	mov	r0, sl
   223c4:	f017 fcfb 	bl	39dbe <memset>
					tmpbuf[i++] = notify_msg.text[byte_no++];
   223c8:	9b04      	ldr	r3, [sp, #16]
					LCD_MeasureString(tmpbuf, &w, &h);
   223ca:	f10d 021e 	add.w	r2, sp, #30
					tmpbuf[i++] = notify_msg.text[byte_no++];
   223ce:	4433      	add	r3, r6
   223d0:	789b      	ldrb	r3, [r3, #2]
					LCD_MeasureString(tmpbuf, &w, &h);
   223d2:	a907      	add	r1, sp, #28
   223d4:	4650      	mov	r0, sl
					tmpbuf[i++] = notify_msg.text[byte_no++];
   223d6:	f106 0901 	add.w	r9, r6, #1
   223da:	f88d 3020 	strb.w	r3, [sp, #32]
					LCD_MeasureString(tmpbuf, &w, &h);
   223de:	fa1f f989 	uxth.w	r9, r9
   223e2:	f7fc fd0d 	bl	1ee00 <LCD_MeasureString>
					while(w < (rect_w-2*offset_w))
   223e6:	9b04      	ldr	r3, [sp, #16]
   223e8:	f109 0902 	add.w	r9, r9, #2
   223ec:	4499      	add	r9, r3
   223ee:	f04f 0801 	mov.w	r8, #1
							tmpbuf[i++] = notify_msg.text[byte_no++];
   223f2:	4653      	mov	r3, sl
					while(w < (rect_w-2*offset_w))
   223f4:	f8bd 101c 	ldrh.w	r1, [sp, #28]
   223f8:	eb06 0208 	add.w	r2, r6, r8
   223fc:	29ab      	cmp	r1, #171	; 0xab
   223fe:	b292      	uxth	r2, r2
   22400:	d922      	bls.n	22448 <NotifyScreenProcess+0x188>
					if(byte_no < text_len)
   22402:	4593      	cmp	fp, r2
   22404:	d930      	bls.n	22468 <NotifyScreenProcess+0x1a8>
						tmpbuf[i] = 0x00;
   22406:	ab28      	add	r3, sp, #160	; 0xa0
						i -= 2;
   22408:	f1a8 0802 	sub.w	r8, r8, #2
						tmpbuf[i] = 0x00;
   2240c:	fa53 f888 	uxtab	r8, r3, r8
   22410:	2300      	movs	r3, #0
						byte_no -= 2;
   22412:	1e96      	subs	r6, r2, #2
						LCD_MeasureString(tmpbuf, &w, &h);
   22414:	a907      	add	r1, sp, #28
   22416:	f10d 021e 	add.w	r2, sp, #30
   2241a:	a808      	add	r0, sp, #32
						tmpbuf[i] = 0x00;
   2241c:	f808 3c80 	strb.w	r3, [r8, #-128]
						LCD_MeasureString(tmpbuf, &w, &h);
   22420:	f7fc fcee 	bl	1ee00 <LCD_MeasureString>
						x = ((rect_w-2*offset_w)-w)/2;
   22424:	f8bd 001c 	ldrh.w	r0, [sp, #28]
						x += (rect_x+offset_w);
   22428:	9b05      	ldr	r3, [sp, #20]
						x = ((rect_w-2*offset_w)-w)/2;
   2242a:	f1c0 00ac 	rsb	r0, r0, #172	; 0xac
   2242e:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
						x += (rect_x+offset_w);
   22432:	eb03 0060 	add.w	r0, r3, r0, asr #1
						LCD_ShowString(x,y,tmpbuf);
   22436:	4629      	mov	r1, r5
   22438:	aa08      	add	r2, sp, #32
   2243a:	b280      	uxth	r0, r0
						y += line_h;
   2243c:	443d      	add	r5, r7
						byte_no -= 2;
   2243e:	b2b6      	uxth	r6, r6
						LCD_ShowString(x,y,tmpbuf);
   22440:	f7fc fcac 	bl	1ed9c <LCD_ShowString>
						y += line_h;
   22444:	b2ad      	uxth	r5, r5
   22446:	e7b5      	b.n	223b4 <NotifyScreenProcess+0xf4>
						if(byte_no < text_len)
   22448:	4593      	cmp	fp, r2
   2244a:	d90d      	bls.n	22468 <NotifyScreenProcess+0x1a8>
							tmpbuf[i++] = notify_msg.text[byte_no++];
   2244c:	f819 2b01 	ldrb.w	r2, [r9], #1
							LCD_MeasureString(tmpbuf, &w, &h);
   22450:	4618      	mov	r0, r3
							tmpbuf[i++] = notify_msg.text[byte_no++];
   22452:	f808 2003 	strb.w	r2, [r8, r3]
							LCD_MeasureString(tmpbuf, &w, &h);
   22456:	a907      	add	r1, sp, #28
   22458:	f10d 021e 	add.w	r2, sp, #30
   2245c:	f7fc fcd0 	bl	1ee00 <LCD_MeasureString>
   22460:	f108 0801 	add.w	r8, r8, #1
   22464:	ab08      	add	r3, sp, #32
   22466:	e7c5      	b.n	223f4 <NotifyScreenProcess+0x134>
						LCD_MeasureString(tmpbuf, &w, &h);
   22468:	f10d 021e 	add.w	r2, sp, #30
   2246c:	a907      	add	r1, sp, #28
   2246e:	4650      	mov	r0, sl
   22470:	f7fc fcc6 	bl	1ee00 <LCD_MeasureString>
						LCD_ShowString(x,y,tmpbuf);
   22474:	4652      	mov	r2, sl
   22476:	4629      	mov	r1, r5
						x = ((rect_w-2*offset_w)-w)/2;
   22478:	f8bd 001c 	ldrh.w	r0, [sp, #28]
						x += (rect_x+offset_w);
   2247c:	3404      	adds	r4, #4
						x = ((rect_w-2*offset_w)-w)/2;
   2247e:	f1c0 00ac 	rsb	r0, r0, #172	; 0xac
   22482:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
						x += (rect_x+offset_w);
   22486:	eb04 0060 	add.w	r0, r4, r0, asr #1
						LCD_ShowString(x,y,tmpbuf);
   2248a:	b280      	uxth	r0, r0
				LCD_ShowString(x,y,notify_msg.text);				
   2248c:	f7fc fc86 	bl	1ed9c <LCD_ShowString>
   22490:	e755      	b.n	2233e <NotifyScreenProcess+0x7e>
				y = (h > (rect_h-2*offset_h))? 0 : ((rect_h-2*offset_h)-h)/2;
   22492:	2f70      	cmp	r7, #112	; 0x70
				x = (w > (rect_w-2*offset_w))? 0 : ((rect_w-2*offset_w)-w)/2;
   22494:	f1c3 03ac 	rsb	r3, r3, #172	; 0xac
				y = (h > (rect_h-2*offset_h))? 0 : ((rect_h-2*offset_h)-h)/2;
   22498:	bf98      	it	ls
   2249a:	f1c7 0670 	rsbls	r6, r7, #112	; 0x70
				x = (w > (rect_w-2*offset_w))? 0 : ((rect_w-2*offset_w)-w)/2;
   2249e:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
   224a2:	ea4f 0363 	mov.w	r3, r3, asr #1
				y = (h > (rect_h-2*offset_h))? 0 : ((rect_h-2*offset_h)-h)/2;
   224a6:	bf98      	it	ls
   224a8:	f3c6 064f 	ubfxls	r6, r6, #1, #16
				x += (rect_x+offset_w);
   224ac:	3404      	adds	r4, #4
				y += (rect_y+offset_h);
   224ae:	4446      	add	r6, r8
				x += (rect_x+offset_w);
   224b0:	4423      	add	r3, r4
				LCD_ShowString(x,y,notify_msg.text);				
   224b2:	4a0b      	ldr	r2, [pc, #44]	; (224e0 <NotifyScreenProcess+0x220>)
   224b4:	b2b1      	uxth	r1, r6
   224b6:	b298      	uxth	r0, r3
   224b8:	e7e8      	b.n	2248c <NotifyScreenProcess+0x1cc>
			y = (rect_y+offset_h);
   224ba:	f108 0804 	add.w	r8, r8, #4
			x = (rect_x+offset_w);
   224be:	1d20      	adds	r0, r4, #4
			LCD_ShowStringInRect(x, y, (rect_w-2*offset_w), (rect_h-2*offset_h), notify_msg.text);
   224c0:	9500      	str	r5, [sp, #0]
   224c2:	2370      	movs	r3, #112	; 0x70
   224c4:	22ac      	movs	r2, #172	; 0xac
   224c6:	fa1f f188 	uxth.w	r1, r8
   224ca:	b280      	uxth	r0, r0
   224cc:	f7fc fc2a 	bl	1ed24 <LCD_ShowStringInRect>
			break;
   224d0:	e735      	b.n	2233e <NotifyScreenProcess+0x7e>
   224d2:	bf00      	nop
   224d4:	200203c0 	.word	0x200203c0
   224d8:	2002b232 	.word	0x2002b232
   224dc:	2002b230 	.word	0x2002b230
   224e0:	20024c88 	.word	0x20024c88
   224e4:	20024c86 	.word	0x20024c86

000224e8 <EnterIdleScreen>:

void EnterIdleScreen(void)
{
	if(screen_id == SCREEN_ID_IDLE)
   224e8:	4907      	ldr	r1, [pc, #28]	; (22508 <EnterIdleScreen+0x20>)
   224ea:	780b      	ldrb	r3, [r1, #0]
   224ec:	2b01      	cmp	r3, #1
   224ee:	d00a      	beq.n	22506 <EnterIdleScreen+0x1e>
		return;
	
	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   224f0:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   224f2:	4a06      	ldr	r2, [pc, #24]	; (2250c <EnterIdleScreen+0x24>)
   224f4:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   224f6:	4a06      	ldr	r2, [pc, #24]	; (22510 <EnterIdleScreen+0x28>)
   224f8:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_IDLE;
   224fc:	2301      	movs	r3, #1
   224fe:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_IDLE].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_IDLE].status = SCREEN_STATUS_CREATING;
   22500:	f240 1301 	movw	r3, #257	; 0x101
   22504:	8113      	strh	r3, [r2, #8]
}
   22506:	4770      	bx	lr
   22508:	20024cd9 	.word	0x20024cd9
   2250c:	20024c85 	.word	0x20024c85
   22510:	200203c0 	.word	0x200203c0

00022514 <EnterAlarmScreen>:

void EnterAlarmScreen(void)
{
	if(screen_id == SCREEN_ID_ALARM)
   22514:	4907      	ldr	r1, [pc, #28]	; (22534 <EnterAlarmScreen+0x20>)
   22516:	780b      	ldrb	r3, [r1, #0]
   22518:	2b02      	cmp	r3, #2
   2251a:	d00a      	beq.n	22532 <EnterAlarmScreen+0x1e>
		return;

	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   2251c:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   2251e:	4a06      	ldr	r2, [pc, #24]	; (22538 <EnterAlarmScreen+0x24>)
   22520:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   22522:	4a06      	ldr	r2, [pc, #24]	; (2253c <EnterAlarmScreen+0x28>)
   22524:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_ALARM;	
   22528:	2302      	movs	r3, #2
   2252a:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_ALARM].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_ALARM].status = SCREEN_STATUS_CREATING;	
   2252c:	f240 1301 	movw	r3, #257	; 0x101
   22530:	8213      	strh	r3, [r2, #16]
}
   22532:	4770      	bx	lr
   22534:	20024cd9 	.word	0x20024cd9
   22538:	20024c85 	.word	0x20024c85
   2253c:	200203c0 	.word	0x200203c0

00022540 <EnterFindDeviceScreen>:

void EnterFindDeviceScreen(void)
{
	if(screen_id == SCREEN_ID_FIND_DEVICE)
   22540:	4907      	ldr	r1, [pc, #28]	; (22560 <EnterFindDeviceScreen+0x20>)
   22542:	780b      	ldrb	r3, [r1, #0]
   22544:	2b03      	cmp	r3, #3
   22546:	d00a      	beq.n	2255e <EnterFindDeviceScreen+0x1e>
		return;

	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   22548:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   2254a:	4a06      	ldr	r2, [pc, #24]	; (22564 <EnterFindDeviceScreen+0x24>)
   2254c:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   2254e:	4a06      	ldr	r2, [pc, #24]	; (22568 <EnterFindDeviceScreen+0x28>)
   22550:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_FIND_DEVICE;	
   22554:	2303      	movs	r3, #3
   22556:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_FIND_DEVICE].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_FIND_DEVICE].status = SCREEN_STATUS_CREATING;
   22558:	f240 1301 	movw	r3, #257	; 0x101
   2255c:	8313      	strh	r3, [r2, #24]
}
   2255e:	4770      	bx	lr
   22560:	20024cd9 	.word	0x20024cd9
   22564:	20024c85 	.word	0x20024c85
   22568:	200203c0 	.word	0x200203c0

0002256c <EnterGPSTestScreen>:

void EnterGPSTestScreen(void)
{
	if(screen_id == SCREEN_ID_GPS_TEST)
   2256c:	4908      	ldr	r1, [pc, #32]	; (22590 <EnterGPSTestScreen+0x24>)
   2256e:	780b      	ldrb	r3, [r1, #0]
   22570:	2b08      	cmp	r3, #8
   22572:	d00b      	beq.n	2258c <EnterGPSTestScreen+0x20>
		return;

	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   22574:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   22576:	4a07      	ldr	r2, [pc, #28]	; (22594 <EnterGPSTestScreen+0x28>)
   22578:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   2257a:	4a07      	ldr	r2, [pc, #28]	; (22598 <EnterGPSTestScreen+0x2c>)
   2257c:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_GPS_TEST;	
   22580:	2308      	movs	r3, #8
   22582:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_GPS_TEST].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_GPS_TEST].status = SCREEN_STATUS_CREATING;	
   22584:	f240 1301 	movw	r3, #257	; 0x101
   22588:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
}
   2258c:	4770      	bx	lr
   2258e:	bf00      	nop
   22590:	20024cd9 	.word	0x20024cd9
   22594:	20024c85 	.word	0x20024c85
   22598:	200203c0 	.word	0x200203c0

0002259c <GoBackHistoryScreen>:
{
	SCREEN_ID_ENUM scr_id;
	
	scr_id = screen_id;
	scr_msg[scr_id].act = SCREEN_ACTION_NO;
	scr_msg[scr_id].status = SCREEN_STATUS_NO;
   2259c:	2000      	movs	r0, #0
	scr_id = screen_id;
   2259e:	4906      	ldr	r1, [pc, #24]	; (225b8 <GoBackHistoryScreen+0x1c>)
	scr_msg[scr_id].status = SCREEN_STATUS_NO;
   225a0:	4b06      	ldr	r3, [pc, #24]	; (225bc <GoBackHistoryScreen+0x20>)
	scr_msg[scr_id].act = SCREEN_ACTION_NO;
   225a2:	780a      	ldrb	r2, [r1, #0]
	scr_msg[scr_id].status = SCREEN_STATUS_NO;
   225a4:	f823 0032 	strh.w	r0, [r3, r2, lsl #3]

	screen_id = history_screen_id;
   225a8:	4a05      	ldr	r2, [pc, #20]	; (225c0 <GoBackHistoryScreen+0x24>)
   225aa:	7812      	ldrb	r2, [r2, #0]
   225ac:	700a      	strb	r2, [r1, #0]
	scr_msg[history_screen_id].act = SCREEN_ACTION_ENTER;
	scr_msg[history_screen_id].status = SCREEN_STATUS_CREATING;	
   225ae:	f240 1101 	movw	r1, #257	; 0x101
   225b2:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
}
   225b6:	4770      	bx	lr
   225b8:	20024cd9 	.word	0x20024cd9
   225bc:	200203c0 	.word	0x200203c0
   225c0:	20024c85 	.word	0x20024c85

000225c4 <ExitNotifyScreen>:
{
   225c4:	b508      	push	{r3, lr}
	if(screen_id == SCREEN_ID_NOTIFY)
   225c6:	4b06      	ldr	r3, [pc, #24]	; (225e0 <ExitNotifyScreen+0x1c>)
   225c8:	781b      	ldrb	r3, [r3, #0]
   225ca:	2b0a      	cmp	r3, #10
   225cc:	d106      	bne.n	225dc <ExitNotifyScreen+0x18>
	z_impl_k_timer_stop(timer);
   225ce:	4805      	ldr	r0, [pc, #20]	; (225e4 <ExitNotifyScreen+0x20>)
   225d0:	f017 fb36 	bl	39c40 <z_impl_k_timer_stop>
}
   225d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		GoBackHistoryScreen();
   225d8:	f7ff bfe0 	b.w	2259c <GoBackHistoryScreen>
}
   225dc:	bd08      	pop	{r3, pc}
   225de:	bf00      	nop
   225e0:	20024cd9 	.word	0x20024cd9
   225e4:	2002cb54 	.word	0x2002cb54

000225e8 <ScreenMsgProcess>:

void ScreenMsgProcess(void)
{
	if(scr_msg[screen_id].act != SCREEN_ACTION_NO)
   225e8:	4b0f      	ldr	r3, [pc, #60]	; (22628 <ScreenMsgProcess+0x40>)
   225ea:	4910      	ldr	r1, [pc, #64]	; (2262c <ScreenMsgProcess+0x44>)
   225ec:	781b      	ldrb	r3, [r3, #0]
   225ee:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
   225f2:	7850      	ldrb	r0, [r2, #1]
   225f4:	b1b8      	cbz	r0, 22626 <ScreenMsgProcess+0x3e>
	{
		if(scr_msg[screen_id].status != SCREEN_STATUS_CREATED)
   225f6:	f811 1033 	ldrb.w	r1, [r1, r3, lsl #3]
			scr_msg[screen_id].act = SCREEN_ACTION_ENTER;

		switch(screen_id)
   225fa:	3b01      	subs	r3, #1
		if(scr_msg[screen_id].status != SCREEN_STATUS_CREATED)
   225fc:	2902      	cmp	r1, #2
			scr_msg[screen_id].act = SCREEN_ACTION_ENTER;
   225fe:	bf1c      	itt	ne
   22600:	2101      	movne	r1, #1
   22602:	7051      	strbne	r1, [r2, #1]
		switch(screen_id)
   22604:	2b09      	cmp	r3, #9
   22606:	d80e      	bhi.n	22626 <ScreenMsgProcess+0x3e>
   22608:	e8df f003 	tbb	[pc, r3]
   2260c:	0d090705 	.word	0x0d090705
   22610:	0d0d0d0d 	.word	0x0d0d0d0d
   22614:	0b0d      	.short	0x0b0d
		{
		case SCREEN_ID_IDLE:
			IdleScreenProcess();
   22616:	f7ff bd2b 	b.w	22070 <IdleScreenProcess>
			break;
		case SCREEN_ID_ALARM:
			AlarmScreenProcess();
   2261a:	f7ff bd75 	b.w	22108 <AlarmScreenProcess>
			break;
		case SCREEN_ID_FIND_DEVICE:
			FindDeviceScreenProcess();
   2261e:	f7ff bde1 	b.w	221e4 <FindDeviceScreenProcess>
		case SCREEN_ID_GPS_TEST:
			break;
		case SCREEN_ID_NB_TEST:
			break;
		case SCREEN_ID_NOTIFY:
			NotifyScreenProcess();
   22622:	f7ff be4d 	b.w	222c0 <NotifyScreenProcess>
			break;
		}
	}
}
   22626:	4770      	bx	lr
   22628:	20024cd9 	.word	0x20024cd9
   2262c:	200203c0 	.word	0x200203c0

00022630 <pmu_battery_low_shutdown_timerout>:
	MAX20353_PowerOffConfig();
}

void pmu_battery_low_shutdown_timerout(void)
{
	sys_pwr_off = true;
   22630:	2201      	movs	r2, #1
   22632:	4b01      	ldr	r3, [pc, #4]	; (22638 <pmu_battery_low_shutdown_timerout+0x8>)
   22634:	701a      	strb	r2, [r3, #0]
}
   22636:	4770      	bx	lr
   22638:	20024ce1 	.word	0x20024ce1

0002263c <PmuInterruptHandle>:
	}while(!val);
}

void PmuInterruptHandle(void)
{
	pmu_trige_flag = true;
   2263c:	2201      	movs	r2, #1
   2263e:	4b01      	ldr	r3, [pc, #4]	; (22644 <PmuInterruptHandle+0x8>)
   22640:	701a      	strb	r2, [r3, #0]
}
   22642:	4770      	bx	lr
   22644:	20024cdf 	.word	0x20024cdf

00022648 <PmuAlertHandle>:
	MAX20353_SOCWriteReg(0x0C, 0x12, 0x5C);
}

void PmuAlertHandle(void)
{
	pmu_alert_flag = true;
   22648:	2201      	movs	r2, #1
   2264a:	4b01      	ldr	r3, [pc, #4]	; (22650 <PmuAlertHandle+0x8>)
   2264c:	701a      	strb	r2, [r3, #0]
}
   2264e:	4770      	bx	lr
   22650:	20024cdd 	.word	0x20024cdd

00022654 <pmu_battery_low_shutdown>:
{
   22654:	b510      	push	{r4, lr}
	k_timer_init(&soc_pwroff, pmu_battery_low_shutdown_timerout, NULL);
   22656:	4c07      	ldr	r4, [pc, #28]	; (22674 <pmu_battery_low_shutdown+0x20>)
   22658:	2200      	movs	r2, #0
   2265a:	4907      	ldr	r1, [pc, #28]	; (22678 <pmu_battery_low_shutdown+0x24>)
   2265c:	4620      	mov	r0, r4
   2265e:	f017 fae3 	bl	39c28 <k_timer_init>
	z_impl_k_timer_start(timer, duration, period);
   22662:	2200      	movs	r2, #0
   22664:	4620      	mov	r0, r4
}
   22666:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2266a:	f242 7110 	movw	r1, #10000	; 0x2710
   2266e:	f012 be99 	b.w	353a4 <z_impl_k_timer_start>
   22672:	bf00      	nop
   22674:	20020444 	.word	0x20020444
   22678:	00022631 	.word	0x00022631

0002267c <pmu_interrupt_proc>:
{
   2267c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		LOG_INF("pmu_interrupt_proc REG_INT0:%02X\n", int0);
   22680:	4b58      	ldr	r3, [pc, #352]	; (227e4 <pmu_interrupt_proc+0x168>)
   22682:	4c59      	ldr	r4, [pc, #356]	; (227e8 <pmu_interrupt_proc+0x16c>)
   22684:	f8df 8180 	ldr.w	r8, [pc, #384]	; 22808 <pmu_interrupt_proc+0x18c>
   22688:	1ae4      	subs	r4, r4, r3
			LOG_INF("REG_STATUS0:%02X\n", status0);
   2268a:	f8df 9180 	ldr.w	r9, [pc, #384]	; 2280c <pmu_interrupt_proc+0x190>
			pmu_redraw_bat_flag = true;
   2268e:	4f57      	ldr	r7, [pc, #348]	; (227ec <pmu_interrupt_proc+0x170>)
		LOG_INF("pmu_interrupt_proc REG_INT0:%02X\n", int0);
   22690:	f3c4 04c9 	ubfx	r4, r4, #3, #10
		MAX20353_ReadReg(REG_INT0, &int0);
   22694:	a901      	add	r1, sp, #4
   22696:	2003      	movs	r0, #3
   22698:	f000 fc2a 	bl	22ef0 <MAX20353_ReadReg>
		LOG_INF("pmu_interrupt_proc REG_INT0:%02X\n", int0);
   2269c:	f025 033f 	bic.w	r3, r5, #63	; 0x3f
   226a0:	f043 0303 	orr.w	r3, r3, #3
   226a4:	f363 0507 	bfi	r5, r3, #0, #8
   226a8:	f364 158f 	bfi	r5, r4, #6, #10
   226ac:	4628      	mov	r0, r5
   226ae:	f89d 2004 	ldrb.w	r2, [sp, #4]
   226b2:	4641      	mov	r1, r8
   226b4:	f015 fb5b 	bl	37d6e <log_string_sync>
		if((int0&0x40) == 0x40) //Charger status change INT  
   226b8:	f89d 3004 	ldrb.w	r3, [sp, #4]
   226bc:	0658      	lsls	r0, r3, #25
   226be:	d523      	bpl.n	22708 <pmu_interrupt_proc+0x8c>
			MAX20353_ReadReg(REG_STATUS0, &status0);
   226c0:	f10d 0105 	add.w	r1, sp, #5
   226c4:	2006      	movs	r0, #6
   226c6:	f000 fc13 	bl	22ef0 <MAX20353_ReadReg>
			LOG_INF("REG_STATUS0:%02X\n", status0);
   226ca:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   226ce:	f043 0303 	orr.w	r3, r3, #3
   226d2:	f363 0607 	bfi	r6, r3, #0, #8
   226d6:	f364 168f 	bfi	r6, r4, #6, #10
   226da:	f89d 2005 	ldrb.w	r2, [sp, #5]
   226de:	4649      	mov	r1, r9
   226e0:	4630      	mov	r0, r6
   226e2:	f015 fb44 	bl	37d6e <log_string_sync>
			switch((status0&0x07))
   226e6:	2201      	movs	r2, #1
   226e8:	f89d 3005 	ldrb.w	r3, [sp, #5]
   226ec:	f003 0307 	and.w	r3, r3, #7
   226f0:	fa02 f303 	lsl.w	r3, r2, r3
   226f4:	f013 0f83 	tst.w	r3, #131	; 0x83
   226f8:	d141      	bne.n	2277e <pmu_interrupt_proc+0x102>
   226fa:	0659      	lsls	r1, r3, #25
   226fc:	d445      	bmi.n	2278a <pmu_interrupt_proc+0x10e>
   226fe:	f013 0f3c 	tst.w	r3, #60	; 0x3c
   22702:	d140      	bne.n	22786 <pmu_interrupt_proc+0x10a>
			pmu_redraw_bat_flag = true;
   22704:	2301      	movs	r3, #1
   22706:	703b      	strb	r3, [r7, #0]
		if((int0&0x08) == 0x08) //USB OK Int
   22708:	f89d 3004 	ldrb.w	r3, [sp, #4]
   2270c:	071b      	lsls	r3, r3, #28
   2270e:	d51d      	bpl.n	2274c <pmu_interrupt_proc+0xd0>
			MAX20353_ReadReg(REG_STATUS1, &status1);
   22710:	f10d 0106 	add.w	r1, sp, #6
   22714:	2007      	movs	r0, #7
   22716:	f000 fbeb 	bl	22ef0 <MAX20353_ReadReg>
			if((status1&0x08) == 0x08) //USB OK   
   2271a:	f89d 3006 	ldrb.w	r3, [sp, #6]
   2271e:	4a34      	ldr	r2, [pc, #208]	; (227f0 <pmu_interrupt_proc+0x174>)
   22720:	f013 0308 	ands.w	r3, r3, #8
   22724:	f8df b0d8 	ldr.w	fp, [pc, #216]	; 22800 <pmu_interrupt_proc+0x184>
   22728:	4932      	ldr	r1, [pc, #200]	; (227f4 <pmu_interrupt_proc+0x178>)
   2272a:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 22810 <pmu_interrupt_proc+0x194>
   2272e:	d031      	beq.n	22794 <pmu_interrupt_proc+0x118>
				InitCharger();
   22730:	f000 fd58 	bl	231e4 <InitCharger>
				charger_is_connected = true;
   22734:	2301      	movs	r3, #1
				g_chg_status = BAT_CHARGING_PROGRESS;
   22736:	4a2e      	ldr	r2, [pc, #184]	; (227f0 <pmu_interrupt_proc+0x174>)
				charger_is_connected = true;
   22738:	492e      	ldr	r1, [pc, #184]	; (227f4 <pmu_interrupt_proc+0x178>)
				g_chg_status = BAT_CHARGING_PROGRESS;
   2273a:	7013      	strb	r3, [r2, #0]
				g_bat_level = BAT_LEVEL_NORMAL;
   2273c:	2202      	movs	r2, #2
				charger_is_connected = true;
   2273e:	700b      	strb	r3, [r1, #0]
				g_bat_level = BAT_LEVEL_NORMAL;
   22740:	f88a 2000 	strb.w	r2, [sl]
				lcd_sleep_out = true;
   22744:	f88b 3000 	strb.w	r3, [fp]
			pmu_redraw_bat_flag = true;
   22748:	2301      	movs	r3, #1
   2274a:	703b      	strb	r3, [r7, #0]
		if(gpio_pin_read(gpio_pmu, PMU_EINT, &val))	//xb add 20201202 MCUPMU
   2274c:	4b2a      	ldr	r3, [pc, #168]	; (227f8 <pmu_interrupt_proc+0x17c>)
   2274e:	6818      	ldr	r0, [r3, #0]
	return api->read(port, access_op, pin, value);
   22750:	6843      	ldr	r3, [r0, #4]
   22752:	2208      	movs	r2, #8
   22754:	f8d3 a008 	ldr.w	sl, [r3, #8]
   22758:	2100      	movs	r1, #0
   2275a:	f10d 0307 	add.w	r3, sp, #7
   2275e:	47d0      	blx	sl
   22760:	2800      	cmp	r0, #0
   22762:	d038      	beq.n	227d6 <pmu_interrupt_proc+0x15a>
			LOG_INF("Cannot get pin");
   22764:	f04f 0000 	mov.w	r0, #0
   22768:	2303      	movs	r3, #3
   2276a:	f363 0007 	bfi	r0, r3, #0, #8
   2276e:	f364 108f 	bfi	r0, r4, #6, #10
   22772:	4922      	ldr	r1, [pc, #136]	; (227fc <pmu_interrupt_proc+0x180>)
   22774:	f015 fafb 	bl	37d6e <log_string_sync>
}
   22778:	b003      	add	sp, #12
   2277a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				g_chg_status = BAT_CHARGING_NO;
   2277e:	2200      	movs	r2, #0
   22780:	4b1b      	ldr	r3, [pc, #108]	; (227f0 <pmu_interrupt_proc+0x174>)
				lcd_sleep_out = true;
   22782:	701a      	strb	r2, [r3, #0]
				break;
   22784:	e7be      	b.n	22704 <pmu_interrupt_proc+0x88>
				g_chg_status = BAT_CHARGING_PROGRESS;
   22786:	4b1a      	ldr	r3, [pc, #104]	; (227f0 <pmu_interrupt_proc+0x174>)
   22788:	e7fb      	b.n	22782 <pmu_interrupt_proc+0x106>
				g_chg_status = BAT_CHARGING_FINISHED;
   2278a:	2102      	movs	r1, #2
   2278c:	4b18      	ldr	r3, [pc, #96]	; (227f0 <pmu_interrupt_proc+0x174>)
   2278e:	7019      	strb	r1, [r3, #0]
				lcd_sleep_out = true;
   22790:	4b1b      	ldr	r3, [pc, #108]	; (22800 <pmu_interrupt_proc+0x184>)
   22792:	e7f6      	b.n	22782 <pmu_interrupt_proc+0x106>
				g_chg_status = BAT_CHARGING_NO;
   22794:	7013      	strb	r3, [r2, #0]
				charger_is_connected = false;
   22796:	700b      	strb	r3, [r1, #0]
				g_bat_soc = MAX20353_CalculateSOC();
   22798:	f000 fe2a 	bl	233f0 <MAX20353_CalculateSOC>
   2279c:	b2c0      	uxtb	r0, r0
				if(g_bat_soc>100)
   2279e:	2864      	cmp	r0, #100	; 0x64
					g_bat_soc = 100;
   227a0:	bf88      	it	hi
   227a2:	2264      	movhi	r2, #100	; 0x64
   227a4:	4b17      	ldr	r3, [pc, #92]	; (22804 <pmu_interrupt_proc+0x188>)
				g_bat_soc = MAX20353_CalculateSOC();
   227a6:	bf94      	ite	ls
   227a8:	7018      	strbls	r0, [r3, #0]
					g_bat_soc = 100;
   227aa:	701a      	strbhi	r2, [r3, #0]
				if(g_bat_soc < 5)
   227ac:	781b      	ldrb	r3, [r3, #0]
   227ae:	2b04      	cmp	r3, #4
   227b0:	d806      	bhi.n	227c0 <pmu_interrupt_proc+0x144>
					g_bat_level = BAT_LEVEL_VERY_LOW;
   227b2:	2300      	movs	r3, #0
   227b4:	f88a 3000 	strb.w	r3, [sl]
					pmu_battery_low_shutdown();
   227b8:	f7ff ff4c 	bl	22654 <pmu_battery_low_shutdown>
				lcd_sleep_out = true;
   227bc:	2301      	movs	r3, #1
   227be:	e7c1      	b.n	22744 <pmu_interrupt_proc+0xc8>
				else if(g_bat_soc < 20)
   227c0:	2b13      	cmp	r3, #19
   227c2:	d803      	bhi.n	227cc <pmu_interrupt_proc+0x150>
					g_bat_level = BAT_LEVEL_LOW;
   227c4:	2301      	movs	r3, #1
					g_bat_level = BAT_LEVEL_GOOD;
   227c6:	f88a 3000 	strb.w	r3, [sl]
   227ca:	e7f7      	b.n	227bc <pmu_interrupt_proc+0x140>
				else if(g_bat_soc < 80)
   227cc:	2b4f      	cmp	r3, #79	; 0x4f
					g_bat_level = BAT_LEVEL_NORMAL;
   227ce:	bf94      	ite	ls
   227d0:	2302      	movls	r3, #2
					g_bat_level = BAT_LEVEL_GOOD;
   227d2:	2303      	movhi	r3, #3
   227d4:	e7f7      	b.n	227c6 <pmu_interrupt_proc+0x14a>
	}while(!val);
   227d6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   227da:	2b00      	cmp	r3, #0
   227dc:	f43f af5a 	beq.w	22694 <pmu_interrupt_proc+0x18>
   227e0:	e7ca      	b.n	22778 <pmu_interrupt_proc+0xfc>
   227e2:	bf00      	nop
   227e4:	0003ade0 	.word	0x0003ade0
   227e8:	0003ae78 	.word	0x0003ae78
   227ec:	2002ca3d 	.word	0x2002ca3d
   227f0:	20024cdc 	.word	0x20024cdc
   227f4:	20024cda 	.word	0x20024cda
   227f8:	20020430 	.word	0x20020430
   227fc:	0003cace 	.word	0x0003cace
   22800:	200222a7 	.word	0x200222a7
   22804:	20024cdb 	.word	0x20024cdb
   22808:	0003ca9a 	.word	0x0003ca9a
   2280c:	0003cabc 	.word	0x0003cabc
   22810:	2002ca3c 	.word	0x2002ca3c

00022814 <pmu_alert_proc>:
{
   22814:	b573      	push	{r0, r1, r4, r5, r6, lr}
	MAX20353_SOCReadReg(0x1A, &MSB, &LSB);
   22816:	201a      	movs	r0, #26
   22818:	f10d 0207 	add.w	r2, sp, #7
   2281c:	f10d 0106 	add.w	r1, sp, #6
   22820:	f014 ff74 	bl	3770c <MAX20353_SOCReadReg>
	LOG_INF("pmu_alert_proc status:%02X\n", MSB);
   22824:	2303      	movs	r3, #3
   22826:	f04f 0000 	mov.w	r0, #0
   2282a:	4c69      	ldr	r4, [pc, #420]	; (229d0 <pmu_alert_proc+0x1bc>)
   2282c:	f363 0007 	bfi	r0, r3, #0, #8
   22830:	4b68      	ldr	r3, [pc, #416]	; (229d4 <pmu_alert_proc+0x1c0>)
   22832:	4969      	ldr	r1, [pc, #420]	; (229d8 <pmu_alert_proc+0x1c4>)
   22834:	1ae4      	subs	r4, r4, r3
   22836:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   2283a:	f364 108f 	bfi	r0, r4, #6, #10
   2283e:	f89d 2006 	ldrb.w	r2, [sp, #6]
   22842:	f015 fa94 	bl	37d6e <log_string_sync>
	if(MSB&0x40)
   22846:	f89d 3006 	ldrb.w	r3, [sp, #6]
   2284a:	0659      	lsls	r1, r3, #25
   2284c:	d50d      	bpl.n	2286a <pmu_alert_proc+0x56>
		MSB = MSB&0xBF;
   2284e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   22852:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("voltage reset alert!\n");
   22856:	f04f 0000 	mov.w	r0, #0
   2285a:	2303      	movs	r3, #3
   2285c:	f363 0007 	bfi	r0, r3, #0, #8
   22860:	f364 108f 	bfi	r0, r4, #6, #10
   22864:	495d      	ldr	r1, [pc, #372]	; (229dc <pmu_alert_proc+0x1c8>)
   22866:	f015 fa82 	bl	37d6e <log_string_sync>
	if(MSB&0x20)
   2286a:	f89d 3006 	ldrb.w	r3, [sp, #6]
   2286e:	069a      	lsls	r2, r3, #26
   22870:	d531      	bpl.n	228d6 <pmu_alert_proc+0xc2>
		MSB = MSB&0xDF;
   22872:	f023 0320 	bic.w	r3, r3, #32
   22876:	f88d 3006 	strb.w	r3, [sp, #6]
		g_bat_soc = MAX20353_CalculateSOC();
   2287a:	f000 fdb9 	bl	233f0 <MAX20353_CalculateSOC>
   2287e:	b2c0      	uxtb	r0, r0
		if(g_bat_soc>100)
   22880:	2864      	cmp	r0, #100	; 0x64
			g_bat_soc = 100;
   22882:	bf88      	it	hi
   22884:	2364      	movhi	r3, #100	; 0x64
   22886:	4d56      	ldr	r5, [pc, #344]	; (229e0 <pmu_alert_proc+0x1cc>)
		LOG_INF("SOC:%d\n", g_bat_soc);
   22888:	4956      	ldr	r1, [pc, #344]	; (229e4 <pmu_alert_proc+0x1d0>)
		g_bat_soc = MAX20353_CalculateSOC();
   2288a:	bf94      	ite	ls
   2288c:	7028      	strbls	r0, [r5, #0]
			g_bat_soc = 100;
   2288e:	702b      	strbhi	r3, [r5, #0]
		LOG_INF("SOC:%d\n", g_bat_soc);
   22890:	f04f 0000 	mov.w	r0, #0
   22894:	2303      	movs	r3, #3
   22896:	f363 0007 	bfi	r0, r3, #0, #8
   2289a:	782a      	ldrb	r2, [r5, #0]
   2289c:	f364 108f 	bfi	r0, r4, #6, #10
   228a0:	f015 fa65 	bl	37d6e <log_string_sync>
		if(g_bat_soc < 5)
   228a4:	782b      	ldrb	r3, [r5, #0]
   228a6:	4e50      	ldr	r6, [pc, #320]	; (229e8 <pmu_alert_proc+0x1d4>)
   228a8:	2b04      	cmp	r3, #4
   228aa:	4d50      	ldr	r5, [pc, #320]	; (229ec <pmu_alert_proc+0x1d8>)
   228ac:	d87d      	bhi.n	229aa <pmu_alert_proc+0x196>
			g_bat_level = BAT_LEVEL_VERY_LOW;
   228ae:	2300      	movs	r3, #0
   228b0:	702b      	strb	r3, [r5, #0]
			if(!charger_is_connected)
   228b2:	7833      	ldrb	r3, [r6, #0]
   228b4:	2b00      	cmp	r3, #0
   228b6:	f040 8088 	bne.w	229ca <pmu_alert_proc+0x1b6>
				DisplayPopUp("Battery voltage is very low, the system will shut down in a few seconds!");
   228ba:	484d      	ldr	r0, [pc, #308]	; (229f0 <pmu_alert_proc+0x1dc>)
   228bc:	f7ff f942 	bl	21b44 <DisplayPopUp>
				pmu_battery_low_shutdown();
   228c0:	f7ff fec8 	bl	22654 <pmu_battery_low_shutdown>
		if(charger_is_connected)
   228c4:	7833      	ldrb	r3, [r6, #0]
   228c6:	2b00      	cmp	r3, #0
   228c8:	d17f      	bne.n	229ca <pmu_alert_proc+0x1b6>
		if(g_chg_status == BAT_CHARGING_NO)
   228ca:	4b4a      	ldr	r3, [pc, #296]	; (229f4 <pmu_alert_proc+0x1e0>)
   228cc:	781b      	ldrb	r3, [r3, #0]
   228ce:	b913      	cbnz	r3, 228d6 <pmu_alert_proc+0xc2>
			pmu_redraw_bat_flag = true;
   228d0:	2201      	movs	r2, #1
   228d2:	4b49      	ldr	r3, [pc, #292]	; (229f8 <pmu_alert_proc+0x1e4>)
   228d4:	701a      	strb	r2, [r3, #0]
	if(MSB&0x10)
   228d6:	f89d 3006 	ldrb.w	r3, [sp, #6]
   228da:	06de      	lsls	r6, r3, #27
   228dc:	d50d      	bpl.n	228fa <pmu_alert_proc+0xe6>
		MSB = MSB&0xEF;
   228de:	f023 0310 	bic.w	r3, r3, #16
   228e2:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("SOC low alert!\n");
   228e6:	f04f 0000 	mov.w	r0, #0
   228ea:	2303      	movs	r3, #3
   228ec:	f363 0007 	bfi	r0, r3, #0, #8
   228f0:	f364 108f 	bfi	r0, r4, #6, #10
   228f4:	4941      	ldr	r1, [pc, #260]	; (229fc <pmu_alert_proc+0x1e8>)
   228f6:	f015 fa3a 	bl	37d6e <log_string_sync>
	if(MSB&0x08)
   228fa:	f89d 3006 	ldrb.w	r3, [sp, #6]
   228fe:	071d      	lsls	r5, r3, #28
   22900:	d50d      	bpl.n	2291e <pmu_alert_proc+0x10a>
		MSB = MSB&0xF7;
   22902:	f023 0308 	bic.w	r3, r3, #8
   22906:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("voltage reset alert!\n");
   2290a:	f04f 0000 	mov.w	r0, #0
   2290e:	2303      	movs	r3, #3
   22910:	f363 0007 	bfi	r0, r3, #0, #8
   22914:	f364 108f 	bfi	r0, r4, #6, #10
   22918:	4930      	ldr	r1, [pc, #192]	; (229dc <pmu_alert_proc+0x1c8>)
   2291a:	f015 fa28 	bl	37d6e <log_string_sync>
	if(MSB&0x04)
   2291e:	f89d 3006 	ldrb.w	r3, [sp, #6]
   22922:	0758      	lsls	r0, r3, #29
   22924:	d50d      	bpl.n	22942 <pmu_alert_proc+0x12e>
		MSB = MSB&0xFB;
   22926:	f023 0304 	bic.w	r3, r3, #4
   2292a:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("voltage low alert!\n");
   2292e:	f04f 0000 	mov.w	r0, #0
   22932:	2303      	movs	r3, #3
   22934:	f363 0007 	bfi	r0, r3, #0, #8
   22938:	f364 108f 	bfi	r0, r4, #6, #10
   2293c:	4930      	ldr	r1, [pc, #192]	; (22a00 <pmu_alert_proc+0x1ec>)
   2293e:	f015 fa16 	bl	37d6e <log_string_sync>
	if(MSB&0x02)
   22942:	f89d 3006 	ldrb.w	r3, [sp, #6]
   22946:	0799      	lsls	r1, r3, #30
   22948:	d50d      	bpl.n	22966 <pmu_alert_proc+0x152>
		MSB = MSB&0xFD;
   2294a:	f023 0302 	bic.w	r3, r3, #2
   2294e:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("voltage high alert!\n");
   22952:	f04f 0000 	mov.w	r0, #0
   22956:	2303      	movs	r3, #3
   22958:	f363 0007 	bfi	r0, r3, #0, #8
   2295c:	f364 108f 	bfi	r0, r4, #6, #10
   22960:	4928      	ldr	r1, [pc, #160]	; (22a04 <pmu_alert_proc+0x1f0>)
   22962:	f015 fa04 	bl	37d6e <log_string_sync>
	if(MSB&0x01)
   22966:	f89d 3006 	ldrb.w	r3, [sp, #6]
   2296a:	07da      	lsls	r2, r3, #31
   2296c:	d50f      	bpl.n	2298e <pmu_alert_proc+0x17a>
		MSB = MSB&0xFE;
   2296e:	f023 0301 	bic.w	r3, r3, #1
   22972:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("reset indicator alert!\n");
   22976:	f04f 0000 	mov.w	r0, #0
   2297a:	2303      	movs	r3, #3
   2297c:	f363 0007 	bfi	r0, r3, #0, #8
   22980:	f364 108f 	bfi	r0, r4, #6, #10
   22984:	4920      	ldr	r1, [pc, #128]	; (22a08 <pmu_alert_proc+0x1f4>)
   22986:	f015 f9f2 	bl	37d6e <log_string_sync>
		MAX20353_QuickStart();
   2298a:	f014 fea5 	bl	376d8 <MAX20353_QuickStart>
	MAX20353_SOCWriteReg(0x1A, MSB, LSB);
   2298e:	f89d 2007 	ldrb.w	r2, [sp, #7]
   22992:	f89d 1006 	ldrb.w	r1, [sp, #6]
   22996:	201a      	movs	r0, #26
   22998:	f014 feba 	bl	37710 <MAX20353_SOCWriteReg>
	MAX20353_SOCWriteReg(0x0C, 0x12, 0x5C);
   2299c:	225c      	movs	r2, #92	; 0x5c
   2299e:	2112      	movs	r1, #18
   229a0:	200c      	movs	r0, #12
   229a2:	f014 feb5 	bl	37710 <MAX20353_SOCWriteReg>
}
   229a6:	b002      	add	sp, #8
   229a8:	bd70      	pop	{r4, r5, r6, pc}
		else if(g_bat_soc < 20)
   229aa:	2b13      	cmp	r3, #19
   229ac:	d807      	bhi.n	229be <pmu_alert_proc+0x1aa>
			g_bat_level = BAT_LEVEL_LOW;
   229ae:	2201      	movs	r2, #1
   229b0:	7833      	ldrb	r3, [r6, #0]
   229b2:	702a      	strb	r2, [r5, #0]
			if(!charger_is_connected)
   229b4:	b94b      	cbnz	r3, 229ca <pmu_alert_proc+0x1b6>
				DisplayPopUp("Battery voltage is low, please charge in time!");
   229b6:	4815      	ldr	r0, [pc, #84]	; (22a0c <pmu_alert_proc+0x1f8>)
   229b8:	f7ff f8c4 	bl	21b44 <DisplayPopUp>
   229bc:	e782      	b.n	228c4 <pmu_alert_proc+0xb0>
		else if(g_bat_soc < 80)
   229be:	2b4f      	cmp	r3, #79	; 0x4f
			g_bat_level = BAT_LEVEL_NORMAL;
   229c0:	bf94      	ite	ls
   229c2:	2302      	movls	r3, #2
			g_bat_level = BAT_LEVEL_GOOD;
   229c4:	2303      	movhi	r3, #3
   229c6:	702b      	strb	r3, [r5, #0]
   229c8:	e77c      	b.n	228c4 <pmu_alert_proc+0xb0>
			g_bat_level = BAT_LEVEL_NORMAL;
   229ca:	2302      	movs	r3, #2
   229cc:	702b      	strb	r3, [r5, #0]
   229ce:	e77c      	b.n	228ca <pmu_alert_proc+0xb6>
   229d0:	0003ae78 	.word	0x0003ae78
   229d4:	0003ade0 	.word	0x0003ade0
   229d8:	0003c970 	.word	0x0003c970
   229dc:	0003c98c 	.word	0x0003c98c
   229e0:	20024cdb 	.word	0x20024cdb
   229e4:	0003c9a2 	.word	0x0003c9a2
   229e8:	20024cda 	.word	0x20024cda
   229ec:	2002ca3c 	.word	0x2002ca3c
   229f0:	0003c9aa 	.word	0x0003c9aa
   229f4:	20024cdc 	.word	0x20024cdc
   229f8:	2002ca3d 	.word	0x2002ca3d
   229fc:	0003ca22 	.word	0x0003ca22
   22a00:	0003ca32 	.word	0x0003ca32
   22a04:	0003ca46 	.word	0x0003ca46
   22a08:	0003ca5b 	.word	0x0003ca5b
   22a0c:	0003c9f3 	.word	0x0003c9f3

00022a10 <MAX20353_InitData>:

void MAX20353_InitData(void)
{
   22a10:	b508      	push	{r3, lr}
	pmu_interrupt_proc();
   22a12:	f7ff fe33 	bl	2267c <pmu_interrupt_proc>
	
	g_bat_soc = MAX20353_CalculateSOC();
   22a16:	f000 fceb 	bl	233f0 <MAX20353_CalculateSOC>
   22a1a:	b2c0      	uxtb	r0, r0
	if(g_bat_soc>100)
   22a1c:	2864      	cmp	r0, #100	; 0x64
		g_bat_soc = 100;
   22a1e:	bf88      	it	hi
   22a20:	2264      	movhi	r2, #100	; 0x64
   22a22:	4b02      	ldr	r3, [pc, #8]	; (22a2c <MAX20353_InitData+0x1c>)
	g_bat_soc = MAX20353_CalculateSOC();
   22a24:	bf94      	ite	ls
   22a26:	7018      	strbls	r0, [r3, #0]
		g_bat_soc = 100;
   22a28:	701a      	strbhi	r2, [r3, #0]

	//test_soc();
}
   22a2a:	bd08      	pop	{r3, pc}
   22a2c:	20024cdb 	.word	0x20024cdb

00022a30 <pmu_init>:
void pmu_init(void)
{
	bool rst;
	int flag = GPIO_DIR_IN|GPIO_INT|GPIO_INT_EDGE|GPIO_PUD_PULL_UP|GPIO_INT_ACTIVE_LOW|GPIO_INT_DEBOUNCE;

	LOG_INF("pmu_init\n");
   22a30:	2303      	movs	r3, #3
   22a32:	f04f 0000 	mov.w	r0, #0
{
   22a36:	b570      	push	{r4, r5, r6, lr}
	LOG_INF("pmu_init\n");
   22a38:	f363 0007 	bfi	r0, r3, #0, #8
   22a3c:	4d35      	ldr	r5, [pc, #212]	; (22b14 <pmu_init+0xe4>)
   22a3e:	4b36      	ldr	r3, [pc, #216]	; (22b18 <pmu_init+0xe8>)
   22a40:	4936      	ldr	r1, [pc, #216]	; (22b1c <pmu_init+0xec>)
   22a42:	1aed      	subs	r5, r5, r3
   22a44:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   22a48:	f365 108f 	bfi	r0, r5, #6, #10
   22a4c:	f015 f98f 	bl	37d6e <log_string_sync>
   22a50:	4833      	ldr	r0, [pc, #204]	; (22b20 <pmu_init+0xf0>)
   22a52:	f00f fc69 	bl	32328 <z_impl_device_get_binding>

  	//
  	gpio_pmu = device_get_binding(PMU_PORT);
   22a56:	4c33      	ldr	r4, [pc, #204]	; (22b24 <pmu_init+0xf4>)
   22a58:	6020      	str	r0, [r4, #0]
	if(!gpio_pmu)
   22a5a:	b958      	cbnz	r0, 22a74 <pmu_init+0x44>
	{
		LOG_INF("Cannot bind gpio device\n");
   22a5c:	f04f 0000 	mov.w	r0, #0
   22a60:	2303      	movs	r3, #3
   22a62:	4931      	ldr	r1, [pc, #196]	; (22b28 <pmu_init+0xf8>)
   22a64:	f363 0007 	bfi	r0, r3, #0, #8
   22a68:	f365 108f 	bfi	r0, r5, #6, #10
	pmu_dev_ctx.read_reg  = platform_read;
	pmu_dev_ctx.handle    = i2c_pmu;

	MAX20353_Init();
	MAX20353_InitData();
}
   22a6c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LOG_INF("ERROR SETTING UP I2C\r\n");
   22a70:	f015 b97d 	b.w	37d6e <log_string_sync>
	return api->config(port, access_op, pin, flags);
   22a74:	6843      	ldr	r3, [r0, #4]
   22a76:	2208      	movs	r2, #8
   22a78:	681e      	ldr	r6, [r3, #0]
   22a7a:	2100      	movs	r1, #0
   22a7c:	f44f 7399 	mov.w	r3, #306	; 0x132
   22a80:	47b0      	blx	r6
	gpio_pin_disable_callback(gpio_pmu, PMU_EINT);
   22a82:	2108      	movs	r1, #8
   22a84:	6820      	ldr	r0, [r4, #0]
   22a86:	f014 fd7f 	bl	37588 <gpio_pin_disable_callback>
	callback->handler = handler;
   22a8a:	4928      	ldr	r1, [pc, #160]	; (22b2c <pmu_init+0xfc>)
   22a8c:	4b28      	ldr	r3, [pc, #160]	; (22b30 <pmu_init+0x100>)
	gpio_add_callback(gpio_pmu, &gpio_cb1);
   22a8e:	6820      	ldr	r0, [r4, #0]
   22a90:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
   22a92:	f44f 7380 	mov.w	r3, #256	; 0x100
   22a96:	608b      	str	r3, [r1, #8]
   22a98:	f014 fd6e 	bl	37578 <gpio_add_callback>
	gpio_pin_enable_callback(gpio_pmu, PMU_EINT);
   22a9c:	2108      	movs	r1, #8
   22a9e:	6820      	ldr	r0, [r4, #0]
   22aa0:	f014 fd7b 	bl	3759a <gpio_pin_enable_callback>
	gpio_pin_configure(gpio_pmu, PMU_ALRTB, flag);
   22aa4:	6820      	ldr	r0, [r4, #0]
	return api->config(port, access_op, pin, flags);
   22aa6:	6843      	ldr	r3, [r0, #4]
   22aa8:	2207      	movs	r2, #7
   22aaa:	681e      	ldr	r6, [r3, #0]
   22aac:	2100      	movs	r1, #0
   22aae:	f44f 7399 	mov.w	r3, #306	; 0x132
   22ab2:	47b0      	blx	r6
	gpio_pin_disable_callback(gpio_pmu, PMU_ALRTB);
   22ab4:	2107      	movs	r1, #7
   22ab6:	6820      	ldr	r0, [r4, #0]
   22ab8:	f014 fd66 	bl	37588 <gpio_pin_disable_callback>
	callback->handler = handler;
   22abc:	491d      	ldr	r1, [pc, #116]	; (22b34 <pmu_init+0x104>)
   22abe:	4b1e      	ldr	r3, [pc, #120]	; (22b38 <pmu_init+0x108>)
	gpio_add_callback(gpio_pmu, &gpio_cb2);
   22ac0:	6820      	ldr	r0, [r4, #0]
   22ac2:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
   22ac4:	2380      	movs	r3, #128	; 0x80
   22ac6:	608b      	str	r3, [r1, #8]
   22ac8:	f014 fd56 	bl	37578 <gpio_add_callback>
	gpio_pin_enable_callback(gpio_pmu, PMU_ALRTB);
   22acc:	2107      	movs	r1, #7
   22ace:	6820      	ldr	r0, [r4, #0]
   22ad0:	f014 fd63 	bl	3759a <gpio_pin_enable_callback>
   22ad4:	4819      	ldr	r0, [pc, #100]	; (22b3c <pmu_init+0x10c>)
   22ad6:	f00f fc27 	bl	32328 <z_impl_device_get_binding>
	i2c_pmu = device_get_binding(PMU_DEV);
   22ada:	4c19      	ldr	r4, [pc, #100]	; (22b40 <pmu_init+0x110>)
   22adc:	6020      	str	r0, [r4, #0]
	if(!i2c_pmu)
   22ade:	b940      	cbnz	r0, 22af2 <pmu_init+0xc2>
		LOG_INF("ERROR SETTING UP I2C\r\n");
   22ae0:	f04f 0000 	mov.w	r0, #0
   22ae4:	2303      	movs	r3, #3
   22ae6:	f363 0007 	bfi	r0, r3, #0, #8
   22aea:	f365 108f 	bfi	r0, r5, #6, #10
   22aee:	4915      	ldr	r1, [pc, #84]	; (22b44 <pmu_init+0x114>)
   22af0:	e7bc      	b.n	22a6c <pmu_init+0x3c>
static inline int z_impl_i2c_configure(struct device *dev, u32_t dev_config)
{
	const struct i2c_driver_api *api =
		(const struct i2c_driver_api *)dev->driver_api;

	return api->configure(dev, dev_config);
   22af2:	6843      	ldr	r3, [r0, #4]
   22af4:	2104      	movs	r1, #4
   22af6:	681b      	ldr	r3, [r3, #0]
   22af8:	4798      	blx	r3
	pmu_dev_ctx.write_reg = platform_write;
   22afa:	4b13      	ldr	r3, [pc, #76]	; (22b48 <pmu_init+0x118>)
   22afc:	4a13      	ldr	r2, [pc, #76]	; (22b4c <pmu_init+0x11c>)
   22afe:	601a      	str	r2, [r3, #0]
	pmu_dev_ctx.read_reg  = platform_read;
   22b00:	4a13      	ldr	r2, [pc, #76]	; (22b50 <pmu_init+0x120>)
   22b02:	605a      	str	r2, [r3, #4]
	pmu_dev_ctx.handle    = i2c_pmu;
   22b04:	6822      	ldr	r2, [r4, #0]
   22b06:	609a      	str	r2, [r3, #8]
	MAX20353_Init();
   22b08:	f000 fd08 	bl	2351c <MAX20353_Init>
}
   22b0c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	MAX20353_InitData();
   22b10:	f7ff bf7e 	b.w	22a10 <MAX20353_InitData>
   22b14:	0003ae78 	.word	0x0003ae78
   22b18:	0003ade0 	.word	0x0003ade0
   22b1c:	0003ca73 	.word	0x0003ca73
   22b20:	0003ba01 	.word	0x0003ba01
   22b24:	20020430 	.word	0x20020430
   22b28:	0003ba08 	.word	0x0003ba08
   22b2c:	20020418 	.word	0x20020418
   22b30:	0002263d 	.word	0x0002263d
   22b34:	20020424 	.word	0x20020424
   22b38:	00022649 	.word	0x00022649
   22b3c:	0003ca7d 	.word	0x0003ca7d
   22b40:	20020434 	.word	0x20020434
   22b44:	0003ca83 	.word	0x0003ca83
   22b48:	20020438 	.word	0x20020438
   22b4c:	000375ad 	.word	0x000375ad
   22b50:	000375f3 	.word	0x000375f3

00022b54 <test_soc_status>:
	ret |= MAX20353_ReadReg(REG_SYSTEM_ERROR, &buf_results[4]);
	return ret;
}

void test_soc_status(void)
{
   22b54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   22b58:	ed2d 8b02 	vpush	{d8}
	u8_t MSB,LSB;
	u8_t RCOMP,Status0,Status1,Status2,Status3;
	u16_t VCell,SOC,CRate,MODE,Version,HIBRT,Config,Status,VALRT,VReset,CMD,OCV;
	u8_t strbuf[512] = {0};
   22b5c:	f44f 7b00 	mov.w	fp, #512	; 0x200
{
   22b60:	f5ad 7d21 	sub.w	sp, sp, #644	; 0x284
	u8_t strbuf[512] = {0};
   22b64:	465a      	mov	r2, fp
   22b66:	2100      	movs	r1, #0
   22b68:	a820      	add	r0, sp, #128	; 0x80
   22b6a:	f017 f928 	bl	39dbe <memset>
	
	MAX20353_SOCReadReg(0x02, &MSB, &LSB);//vcell
   22b6e:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   22b72:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
   22b76:	2002      	movs	r0, #2
   22b78:	f014 fdc8 	bl	3770c <MAX20353_SOCReadReg>
	VCell = ((MSB<<8)+LSB);
   22b7c:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   22b80:	f89d 307e 	ldrb.w	r3, [sp, #126]	; 0x7e
	VCell = VCell*625/8/1000;
	
	MAX20353_SOCReadReg(0x04, &MSB, &LSB);//soc
   22b84:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	VCell = ((MSB<<8)+LSB);
   22b88:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	VCell = VCell*625/8/1000;
   22b8c:	f240 2271 	movw	r2, #625	; 0x271
   22b90:	b29b      	uxth	r3, r3
   22b92:	4353      	muls	r3, r2
   22b94:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
   22b98:	fbb3 f3f2 	udiv	r3, r3, r2
	MAX20353_SOCReadReg(0x04, &MSB, &LSB);//soc
   22b9c:	2004      	movs	r0, #4
   22b9e:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
	VCell = VCell*625/8/1000;
   22ba2:	9319      	str	r3, [sp, #100]	; 0x64
	MAX20353_SOCReadReg(0x04, &MSB, &LSB);//soc
   22ba4:	f014 fdb2 	bl	3770c <MAX20353_SOCReadReg>
	SOC = ((MSB<<8)+LSB);
   22ba8:	f89d 307d 	ldrb.w	r3, [sp, #125]	; 0x7d
   22bac:	f89d 007e 	ldrb.w	r0, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x0C, &MSB, &LSB);//Config RCOMP(MSB)
   22bb0:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
	SOC = ((MSB<<8)+LSB);
   22bb4:	eb00 2003 	add.w	r0, r0, r3, lsl #8
   22bb8:	b283      	uxth	r3, r0
	MAX20353_SOCReadReg(0x0C, &MSB, &LSB);//Config RCOMP(MSB)
   22bba:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
   22bbe:	200c      	movs	r0, #12
	SOC = ((MSB<<8)+LSB);
   22bc0:	ee08 3a10 	vmov	s16, r3
	MAX20353_SOCReadReg(0x0C, &MSB, &LSB);//Config RCOMP(MSB)
   22bc4:	f014 fda2 	bl	3770c <MAX20353_SOCReadReg>
	RCOMP = MSB;
	Config = ((MSB<<8)+LSB);
   22bc8:	f89d 307d 	ldrb.w	r3, [sp, #125]	; 0x7d
   22bcc:	f89d 607e 	ldrb.w	r6, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x16, &MSB, &LSB);//CRate
   22bd0:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   22bd4:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
   22bd8:	2016      	movs	r0, #22
	Config = ((MSB<<8)+LSB);
   22bda:	eb06 2603 	add.w	r6, r6, r3, lsl #8
   22bde:	931d      	str	r3, [sp, #116]	; 0x74
	MAX20353_SOCReadReg(0x16, &MSB, &LSB);//CRate
   22be0:	f014 fd94 	bl	3770c <MAX20353_SOCReadReg>
	CRate = ((MSB<<8)+LSB);
   22be4:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   22be8:	f89d 407e 	ldrb.w	r4, [sp, #126]	; 0x7e
	if(CRate&0x8000==0x8000)
		CRate |= 0xFFFF0000;
	CRate = CRate*208;
	
	MAX20353_SOCReadReg(0x06, &MSB, &LSB);//MODE
   22bec:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	CRate = ((MSB<<8)+LSB);
   22bf0:	eb04 2402 	add.w	r4, r4, r2, lsl #8
	MAX20353_SOCReadReg(0x06, &MSB, &LSB);//MODE
   22bf4:	2006      	movs	r0, #6
   22bf6:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   22bfa:	f014 fd87 	bl	3770c <MAX20353_SOCReadReg>
	MODE = ((MSB<<8)+LSB);
   22bfe:	f89d 107d 	ldrb.w	r1, [sp, #125]	; 0x7d
   22c02:	f89d 207e 	ldrb.w	r2, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x08, &MSB, &LSB);//Version
   22c06:	2008      	movs	r0, #8
	MODE = ((MSB<<8)+LSB);
   22c08:	eb02 2201 	add.w	r2, r2, r1, lsl #8
   22c0c:	b293      	uxth	r3, r2
	MAX20353_SOCReadReg(0x08, &MSB, &LSB);//Version
   22c0e:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
   22c12:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
	MODE = ((MSB<<8)+LSB);
   22c16:	931a      	str	r3, [sp, #104]	; 0x68
	MAX20353_SOCReadReg(0x08, &MSB, &LSB);//Version
   22c18:	f014 fd78 	bl	3770c <MAX20353_SOCReadReg>
	Version = ((MSB<<8)+LSB);
   22c1c:	f89d 107d 	ldrb.w	r1, [sp, #125]	; 0x7d
   22c20:	f89d 207e 	ldrb.w	r2, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x0A, &MSB, &LSB);//HIBRT
   22c24:	200a      	movs	r0, #10
	Version = ((MSB<<8)+LSB);
   22c26:	eb02 2201 	add.w	r2, r2, r1, lsl #8
   22c2a:	b293      	uxth	r3, r2
	MAX20353_SOCReadReg(0x0A, &MSB, &LSB);//HIBRT
   22c2c:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
   22c30:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
	Version = ((MSB<<8)+LSB);
   22c34:	931b      	str	r3, [sp, #108]	; 0x6c
	MAX20353_SOCReadReg(0x0A, &MSB, &LSB);//HIBRT
   22c36:	f014 fd69 	bl	3770c <MAX20353_SOCReadReg>
	HIBRT = ((MSB<<8)+LSB);
   22c3a:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   22c3e:	f89d 507e 	ldrb.w	r5, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x1A, &MSB, &LSB);//Status
   22c42:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	HIBRT = ((MSB<<8)+LSB);
   22c46:	eb05 2502 	add.w	r5, r5, r2, lsl #8
	MAX20353_SOCReadReg(0x1A, &MSB, &LSB);//Status
   22c4a:	201a      	movs	r0, #26
   22c4c:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   22c50:	f014 fd5c 	bl	3770c <MAX20353_SOCReadReg>
	Status = ((MSB<<8)+LSB);
   22c54:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   22c58:	f89d 707e 	ldrb.w	r7, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x14, &MSB, &LSB);//VALRT
   22c5c:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	Status = ((MSB<<8)+LSB);
   22c60:	eb07 2702 	add.w	r7, r7, r2, lsl #8
	MAX20353_SOCReadReg(0x14, &MSB, &LSB);//VALRT
   22c64:	2014      	movs	r0, #20
   22c66:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   22c6a:	f014 fd4f 	bl	3770c <MAX20353_SOCReadReg>
	VALRT = ((MSB<<8)+LSB);
   22c6e:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   22c72:	f89d 807e 	ldrb.w	r8, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x18, &MSB, &LSB);//VReset
   22c76:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	VALRT = ((MSB<<8)+LSB);
   22c7a:	eb08 2802 	add.w	r8, r8, r2, lsl #8
	MAX20353_SOCReadReg(0x18, &MSB, &LSB);//VReset
   22c7e:	2018      	movs	r0, #24
   22c80:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   22c84:	f014 fd42 	bl	3770c <MAX20353_SOCReadReg>
	VReset = ((MSB<<8)+LSB);
   22c88:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   22c8c:	f89d 907e 	ldrb.w	r9, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0xFE, &MSB, &LSB);//CMD
   22c90:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	VReset = ((MSB<<8)+LSB);
   22c94:	eb09 2902 	add.w	r9, r9, r2, lsl #8
	MAX20353_SOCReadReg(0xFE, &MSB, &LSB);//CMD
   22c98:	20fe      	movs	r0, #254	; 0xfe
   22c9a:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   22c9e:	f014 fd35 	bl	3770c <MAX20353_SOCReadReg>
	CMD = ((MSB<<8)+LSB);
   22ca2:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   22ca6:	f89d a07e 	ldrb.w	sl, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x0E, &MSB, &LSB);//OCV
   22caa:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	CMD = ((MSB<<8)+LSB);
   22cae:	eb0a 2a02 	add.w	sl, sl, r2, lsl #8
	MAX20353_SOCReadReg(0x0E, &MSB, &LSB);//OCV
   22cb2:	200e      	movs	r0, #14
   22cb4:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   22cb8:	f014 fd28 	bl	3770c <MAX20353_SOCReadReg>
	OCV = ((MSB<<8)+LSB);
   22cbc:	f89d 107d 	ldrb.w	r1, [sp, #125]	; 0x7d
   22cc0:	f89d 207e 	ldrb.w	r2, [sp, #126]	; 0x7e

	MAX20353_ReadReg(REG_STATUS0, &Status0);
   22cc4:	2006      	movs	r0, #6
	OCV = ((MSB<<8)+LSB);
   22cc6:	eb02 2201 	add.w	r2, r2, r1, lsl #8
   22cca:	b292      	uxth	r2, r2
	MAX20353_ReadReg(REG_STATUS0, &Status0);
   22ccc:	f10d 017f 	add.w	r1, sp, #127	; 0x7f
	OCV = ((MSB<<8)+LSB);
   22cd0:	921c      	str	r2, [sp, #112]	; 0x70
	MAX20353_ReadReg(REG_STATUS0, &Status0);
   22cd2:	f000 f90d 	bl	22ef0 <MAX20353_ReadReg>
	Status0 = Status0&0x07;
	
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   22cd6:	9a1c      	ldr	r2, [sp, #112]	; 0x70
	CRate = ((MSB<<8)+LSB);
   22cd8:	b2a4      	uxth	r4, r4
	CMD = ((MSB<<8)+LSB);
   22cda:	fa1f fa8a 	uxth.w	sl, sl
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   22cde:	e9cd a215 	strd	sl, r2, [sp, #84]	; 0x54
	CRate = CRate*208;
   22ce2:	eb04 0244 	add.w	r2, r4, r4, lsl #1
   22ce6:	eb04 0482 	add.w	r4, r4, r2, lsl #2
   22cea:	0124      	lsls	r4, r4, #4
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   22cec:	b2a4      	uxth	r4, r4
   22cee:	ee07 4a90 	vmov	s15, r4
   22cf2:	eddf 8a35 	vldr	s17, [pc, #212]	; 22dc8 <test_soc_status+0x274>
   22cf6:	eef8 7a67 	vcvt.f32.u32	s15, s15
   22cfa:	ee87 7aa8 	vdiv.f32	s14, s15, s17
   22cfe:	eddf 7a33 	vldr	s15, [pc, #204]	; 22dcc <test_soc_status+0x278>
   22d02:	eec7 7a27 	vdiv.f32	s15, s14, s15
   22d06:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
	Status0 = Status0&0x07;
   22d08:	f89d 107f 	ldrb.w	r1, [sp, #127]	; 0x7f
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   22d0c:	930f      	str	r3, [sp, #60]	; 0x3c
   22d0e:	9b1a      	ldr	r3, [sp, #104]	; 0x68
	Status0 = Status0&0x07;
   22d10:	f001 0107 	and.w	r1, r1, #7
	Config = ((MSB<<8)+LSB);
   22d14:	b2b6      	uxth	r6, r6
	HIBRT = ((MSB<<8)+LSB);
   22d16:	b2ad      	uxth	r5, r5
	Status = ((MSB<<8)+LSB);
   22d18:	b2bf      	uxth	r7, r7
	VALRT = ((MSB<<8)+LSB);
   22d1a:	fa1f f888 	uxth.w	r8, r8
	VReset = ((MSB<<8)+LSB);
   22d1e:	fa1f f989 	uxth.w	r9, r9
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   22d22:	ee17 0a90 	vmov	r0, s15
   22d26:	930e      	str	r3, [sp, #56]	; 0x38
	Status0 = Status0&0x07;
   22d28:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   22d2c:	9117      	str	r1, [sp, #92]	; 0x5c
   22d2e:	e9cd 8913 	strd	r8, r9, [sp, #76]	; 0x4c
   22d32:	e9cd 6711 	strd	r6, r7, [sp, #68]	; 0x44
   22d36:	9510      	str	r5, [sp, #64]	; 0x40
   22d38:	f7f9 fce6 	bl	1c708 <__aeabi_f2d>
   22d3c:	eef8 7a48 	vcvt.f32.u32	s15, s16
   22d40:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   22d42:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   22d46:	ee17 0a90 	vmov	r0, s15
   22d4a:	930a      	str	r3, [sp, #40]	; 0x28
   22d4c:	f7f9 fcdc 	bl	1c708 <__aeabi_f2d>
   22d50:	2200      	movs	r2, #0
   22d52:	4b1f      	ldr	r3, [pc, #124]	; (22dd0 <test_soc_status+0x27c>)
   22d54:	f7f9 fd30 	bl	1c7b8 <__aeabi_dmul>
   22d58:	f8bd 3064 	ldrh.w	r3, [sp, #100]	; 0x64
   22d5c:	e9cd 0108 	strd	r0, r1, [sp, #32]
   22d60:	ee07 3a90 	vmov	s15, r3
   22d64:	eef8 7a67 	vcvt.f32.u32	s15, s15
   22d68:	eec7 7aa8 	vdiv.f32	s15, s15, s17
   22d6c:	ee17 0a90 	vmov	r0, s15
   22d70:	f7f9 fcca 	bl	1c708 <__aeabi_f2d>
   22d74:	e9cd 0106 	strd	r0, r1, [sp, #24]
   22d78:	4b16      	ldr	r3, [pc, #88]	; (22dd4 <test_soc_status+0x280>)
   22d7a:	2100      	movs	r1, #0
   22d7c:	799a      	ldrb	r2, [r3, #6]
   22d7e:	a820      	add	r0, sp, #128	; 0x80
   22d80:	9205      	str	r2, [sp, #20]
   22d82:	795a      	ldrb	r2, [r3, #5]
   22d84:	9204      	str	r2, [sp, #16]
   22d86:	791a      	ldrb	r2, [r3, #4]
   22d88:	9203      	str	r2, [sp, #12]
   22d8a:	881a      	ldrh	r2, [r3, #0]
   22d8c:	9202      	str	r2, [sp, #8]
   22d8e:	789a      	ldrb	r2, [r3, #2]
   22d90:	9201      	str	r2, [sp, #4]
   22d92:	78db      	ldrb	r3, [r3, #3]
   22d94:	465a      	mov	r2, fp
   22d96:	9300      	str	r3, [sp, #0]
   22d98:	4b0f      	ldr	r3, [pc, #60]	; (22dd8 <test_soc_status+0x284>)
   22d9a:	f017 f952 	bl	3a042 <__sprintf_chk>
				(float)VCell/1000, (float)SOC/256.0,
				RCOMP,
				(float)CRate/1000/100,
				MODE, Version, HIBRT, Config, Status, VALRT, VReset, CMD, OCV, Status0);

	LOG_INF("%s", strbuf);
   22d9e:	2303      	movs	r3, #3
   22da0:	f04f 0000 	mov.w	r0, #0
   22da4:	4a0d      	ldr	r2, [pc, #52]	; (22ddc <test_soc_status+0x288>)
   22da6:	f363 0007 	bfi	r0, r3, #0, #8
   22daa:	4b0d      	ldr	r3, [pc, #52]	; (22de0 <test_soc_status+0x28c>)
   22dac:	490d      	ldr	r1, [pc, #52]	; (22de4 <test_soc_status+0x290>)
   22dae:	1a9b      	subs	r3, r3, r2
   22db0:	08db      	lsrs	r3, r3, #3
   22db2:	f363 108f 	bfi	r0, r3, #6, #10
   22db6:	aa20      	add	r2, sp, #128	; 0x80
   22db8:	f014 ffd9 	bl	37d6e <log_string_sync>
}
   22dbc:	f50d 7d21 	add.w	sp, sp, #644	; 0x284
   22dc0:	ecbd 8b02 	vpop	{d8}
   22dc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   22dc8:	447a0000 	.word	0x447a0000
   22dcc:	42c80000 	.word	0x42c80000
   22dd0:	3f700000 	.word	0x3f700000
   22dd4:	20022230 	.word	0x20022230
   22dd8:	0003cae6 	.word	0x0003cae6
   22ddc:	0003ade0 	.word	0x0003ade0
   22de0:	0003ae78 	.word	0x0003ae78
   22de4:	0003dde1 	.word	0x0003dde1

00022de8 <PMURedrawBatStatus>:
	k_timer_start(&soc_timer, K_MSEC(10*1000), K_MSEC(15*1000));
}

void PMURedrawBatStatus(void)
{
	if(screen_id == SCREEN_ID_IDLE)
   22de8:	4b05      	ldr	r3, [pc, #20]	; (22e00 <PMURedrawBatStatus+0x18>)
   22dea:	781b      	ldrb	r3, [r3, #0]
   22dec:	2b01      	cmp	r3, #1
   22dee:	d106      	bne.n	22dfe <PMURedrawBatStatus+0x16>
	{
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_BAT;
   22df0:	4b04      	ldr	r3, [pc, #16]	; (22e04 <PMURedrawBatStatus+0x1c>)
   22df2:	68da      	ldr	r2, [r3, #12]
   22df4:	f042 0201 	orr.w	r2, r2, #1
   22df8:	60da      	str	r2, [r3, #12]
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   22dfa:	2202      	movs	r2, #2
   22dfc:	725a      	strb	r2, [r3, #9]
	}
}
   22dfe:	4770      	bx	lr
   22e00:	20024cd9 	.word	0x20024cd9
   22e04:	200203c0 	.word	0x200203c0

00022e08 <PMUMsgProcess>:
	MAX20353_UpdateTemper();
}
#endif

void PMUMsgProcess(void)
{
   22e08:	b510      	push	{r4, lr}
	if(pmu_trige_flag)
   22e0a:	4c1c      	ldr	r4, [pc, #112]	; (22e7c <PMUMsgProcess+0x74>)
   22e0c:	7823      	ldrb	r3, [r4, #0]
   22e0e:	b11b      	cbz	r3, 22e18 <PMUMsgProcess+0x10>
	{
		pmu_interrupt_proc();
   22e10:	f7ff fc34 	bl	2267c <pmu_interrupt_proc>
		pmu_trige_flag = false;
   22e14:	2300      	movs	r3, #0
   22e16:	7023      	strb	r3, [r4, #0]
	}
	
	if(pmu_alert_flag)
   22e18:	4c19      	ldr	r4, [pc, #100]	; (22e80 <PMUMsgProcess+0x78>)
   22e1a:	7823      	ldrb	r3, [r4, #0]
   22e1c:	b11b      	cbz	r3, 22e26 <PMUMsgProcess+0x1e>
	{
		pmu_alert_proc();
   22e1e:	f7ff fcf9 	bl	22814 <pmu_alert_proc>
		pmu_alert_flag = false;
   22e22:	2300      	movs	r3, #0
   22e24:	7023      	strb	r3, [r4, #0]
	}
	
	if(sys_pwr_off)
   22e26:	4c17      	ldr	r4, [pc, #92]	; (22e84 <PMUMsgProcess+0x7c>)
   22e28:	7823      	ldrb	r3, [r4, #0]
   22e2a:	b11b      	cbz	r3, 22e34 <PMUMsgProcess+0x2c>
	{
		SystemShutDown();
   22e2c:	f014 fc12 	bl	37654 <SystemShutDown>
		sys_pwr_off = false;		
   22e30:	2300      	movs	r3, #0
   22e32:	7023      	strb	r3, [r4, #0]
	}
	
	if(vibrate_start_flag)
   22e34:	4c14      	ldr	r4, [pc, #80]	; (22e88 <PMUMsgProcess+0x80>)
   22e36:	7823      	ldrb	r3, [r4, #0]
   22e38:	b11b      	cbz	r3, 22e42 <PMUMsgProcess+0x3a>
	{
		VibrateStart();
   22e3a:	f014 fc14 	bl	37666 <VibrateStart>
		vibrate_start_flag = false;
   22e3e:	2300      	movs	r3, #0
   22e40:	7023      	strb	r3, [r4, #0]
	}
	
	if(vibrate_stop_flag)
   22e42:	4c12      	ldr	r4, [pc, #72]	; (22e8c <PMUMsgProcess+0x84>)
   22e44:	7823      	ldrb	r3, [r4, #0]
   22e46:	b11b      	cbz	r3, 22e50 <PMUMsgProcess+0x48>
	{
		VibrateStop();
   22e48:	f014 fc18 	bl	3767c <VibrateStop>
		vibrate_stop_flag = false;
   22e4c:	2300      	movs	r3, #0
   22e4e:	7023      	strb	r3, [r4, #0]
	}

	if(read_soc_status)
   22e50:	4c0f      	ldr	r4, [pc, #60]	; (22e90 <PMUMsgProcess+0x88>)
   22e52:	7823      	ldrb	r3, [r4, #0]
   22e54:	b11b      	cbz	r3, 22e5e <PMUMsgProcess+0x56>
	{
		test_soc_status();
   22e56:	f7ff fe7d 	bl	22b54 <test_soc_status>
		read_soc_status = false;
   22e5a:	2300      	movs	r3, #0
   22e5c:	7023      	strb	r3, [r4, #0]
	}

	if(pmu_redraw_bat_flag)
   22e5e:	490d      	ldr	r1, [pc, #52]	; (22e94 <PMUMsgProcess+0x8c>)
   22e60:	780b      	ldrb	r3, [r1, #0]
   22e62:	b11b      	cbz	r3, 22e6c <PMUMsgProcess+0x64>
	{
		PMURedrawBatStatus();
   22e64:	f7ff ffc0 	bl	22de8 <PMURedrawBatStatus>
		pmu_redraw_bat_flag = false;
   22e68:	2300      	movs	r3, #0
   22e6a:	700b      	strb	r3, [r1, #0]
	}

#ifdef BATTERT_NTC_CHECK
	if(pmu_check_temp_flag)
   22e6c:	4c0a      	ldr	r4, [pc, #40]	; (22e98 <PMUMsgProcess+0x90>)
   22e6e:	7823      	ldrb	r3, [r4, #0]
   22e70:	b11b      	cbz	r3, 22e7a <PMUMsgProcess+0x72>
	MAX20353_UpdateTemper();
   22e72:	f7fa fc09 	bl	1d688 <MAX20353_UpdateTemper>
	{
		PMUUpdateTempForSOC();
		pmu_check_temp_flag = false;
   22e76:	2300      	movs	r3, #0
   22e78:	7023      	strb	r3, [r4, #0]
	}
#endif
}
   22e7a:	bd10      	pop	{r4, pc}
   22e7c:	20024cdf 	.word	0x20024cdf
   22e80:	20024cdd 	.word	0x20024cdd
   22e84:	20024ce1 	.word	0x20024ce1
   22e88:	20024ce2 	.word	0x20024ce2
   22e8c:	20024ce3 	.word	0x20024ce3
   22e90:	20024ce0 	.word	0x20024ce0
   22e94:	2002ca3d 	.word	0x2002ca3d
   22e98:	20024cde 	.word	0x20024cde

00022e9c <MAX20353_CheckTemper>:

void MAX20353_CheckTemper(void)
{
	pmu_check_temp_flag = true;
   22e9c:	2201      	movs	r2, #1
   22e9e:	4b01      	ldr	r3, [pc, #4]	; (22ea4 <MAX20353_CheckTemper+0x8>)
   22ea0:	701a      	strb	r2, [r3, #0]
}
   22ea2:	4770      	bx	lr
   22ea4:	20024cde 	.word	0x20024cde

00022ea8 <MAX20353_WriteRegMulti>:
{
   22ea8:	b538      	push	{r3, r4, r5, lr}
	ret = pmu_dev_ctx.write_reg(pmu_dev_ctx.handle, reg, value, len);
   22eaa:	4c06      	ldr	r4, [pc, #24]	; (22ec4 <MAX20353_WriteRegMulti+0x1c>)
   22eac:	4613      	mov	r3, r2
   22eae:	6825      	ldr	r5, [r4, #0]
   22eb0:	460a      	mov	r2, r1
   22eb2:	4601      	mov	r1, r0
   22eb4:	68a0      	ldr	r0, [r4, #8]
   22eb6:	47a8      	blx	r5
	if(ret != 0)
   22eb8:	3000      	adds	r0, #0
   22eba:	bf18      	it	ne
   22ebc:	2001      	movne	r0, #1
}
   22ebe:	4240      	negs	r0, r0
   22ec0:	bd38      	pop	{r3, r4, r5, pc}
   22ec2:	bf00      	nop
   22ec4:	20020438 	.word	0x20020438

00022ec8 <MAX20353_WriteReg>:
{ 
   22ec8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	ret = pmu_dev_ctx.write_reg(pmu_dev_ctx.handle, reg, &value, 1);
   22eca:	4c08      	ldr	r4, [pc, #32]	; (22eec <MAX20353_WriteReg+0x24>)
{ 
   22ecc:	f88d 1007 	strb.w	r1, [sp, #7]
	ret = pmu_dev_ctx.write_reg(pmu_dev_ctx.handle, reg, &value, 1);
   22ed0:	6825      	ldr	r5, [r4, #0]
   22ed2:	4601      	mov	r1, r0
   22ed4:	2301      	movs	r3, #1
   22ed6:	f10d 0207 	add.w	r2, sp, #7
   22eda:	68a0      	ldr	r0, [r4, #8]
   22edc:	47a8      	blx	r5
	if(ret != 0)
   22ede:	3000      	adds	r0, #0
   22ee0:	bf18      	it	ne
   22ee2:	2001      	movne	r0, #1
}
   22ee4:	4240      	negs	r0, r0
   22ee6:	b003      	add	sp, #12
   22ee8:	bd30      	pop	{r4, r5, pc}
   22eea:	bf00      	nop
   22eec:	20020438 	.word	0x20020438

00022ef0 <MAX20353_ReadReg>:
{
   22ef0:	b538      	push	{r3, r4, r5, lr}
	ret = pmu_dev_ctx.read_reg(pmu_dev_ctx.handle, reg, value, 1);
   22ef2:	4c06      	ldr	r4, [pc, #24]	; (22f0c <MAX20353_ReadReg+0x1c>)
   22ef4:	460a      	mov	r2, r1
   22ef6:	6865      	ldr	r5, [r4, #4]
   22ef8:	4601      	mov	r1, r0
   22efa:	2301      	movs	r3, #1
   22efc:	68a0      	ldr	r0, [r4, #8]
   22efe:	47a8      	blx	r5
    if(ret != 0)
   22f00:	3000      	adds	r0, #0
   22f02:	bf18      	it	ne
   22f04:	2001      	movne	r0, #1
}
   22f06:	4240      	negs	r0, r0
   22f08:	bd38      	pop	{r3, r4, r5, pc}
   22f0a:	bf00      	nop
   22f0c:	20020438 	.word	0x20020438

00022f10 <MAX20353_AppWrite>:
{
   22f10:	b538      	push	{r3, r4, r5, lr}
	ret  = MAX20353_WriteRegMulti(REG_AP_DATOUT0, appdatainoutbuffer_, dataoutlen); ///0x0F
   22f12:	4602      	mov	r2, r0
   22f14:	490e      	ldr	r1, [pc, #56]	; (22f50 <MAX20353_AppWrite+0x40>)
   22f16:	200f      	movs	r0, #15
   22f18:	f7ff ffc6 	bl	22ea8 <MAX20353_WriteRegMulti>
   22f1c:	4c0d      	ldr	r4, [pc, #52]	; (22f54 <MAX20353_AppWrite+0x44>)
	ret |= MAX20353_WriteReg(REG_AP_CMDOUT, appcmdoutvalue_); //0x17	
   22f1e:	4d0e      	ldr	r5, [pc, #56]	; (22f58 <MAX20353_AppWrite+0x48>)
	ret  = MAX20353_WriteRegMulti(REG_AP_DATOUT0, appdatainoutbuffer_, dataoutlen); ///0x0F
   22f20:	6020      	str	r0, [r4, #0]
	ret |= MAX20353_WriteReg(REG_AP_CMDOUT, appcmdoutvalue_); //0x17	
   22f22:	7829      	ldrb	r1, [r5, #0]
   22f24:	2017      	movs	r0, #23
   22f26:	f7ff ffcf 	bl	22ec8 <MAX20353_WriteReg>
   22f2a:	6823      	ldr	r3, [r4, #0]
   22f2c:	4318      	orrs	r0, r3
   22f2e:	6020      	str	r0, [r4, #0]
	k_sleep(K_MSEC(10));
   22f30:	200a      	movs	r0, #10
   22f32:	f014 fb96 	bl	37662 <k_sleep>
	ret |= MAX20353_ReadReg(REG_AP_RESPONSE, &appcmdoutvalue_);//0x18
   22f36:	4629      	mov	r1, r5
   22f38:	2018      	movs	r0, #24
   22f3a:	f7ff ffd9 	bl	22ef0 <MAX20353_ReadReg>
   22f3e:	6823      	ldr	r3, [r4, #0]
	if(ret != 0)
   22f40:	4303      	orrs	r3, r0
   22f42:	bf14      	ite	ne
   22f44:	f04f 30ff 	movne.w	r0, #4294967295
   22f48:	2000      	moveq	r0, #0
   22f4a:	6020      	str	r0, [r4, #0]
}
   22f4c:	bd38      	pop	{r3, r4, r5, pc}
   22f4e:	bf00      	nop
   22f50:	20024ceb 	.word	0x20024ceb
   22f54:	2002049c 	.word	0x2002049c
   22f58:	20024cea 	.word	0x20024cea

00022f5c <MAX20303_HapticConfigDCMotor>:
{
   22f5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	appcmdoutvalue_ = 0xA0;
   22f5e:	23a0      	movs	r3, #160	; 0xa0
   22f60:	4e24      	ldr	r6, [pc, #144]	; (22ff4 <MAX20303_HapticConfigDCMotor+0x98>)
	appdatainoutbuffer_[0] = 0x0A; //0x0F; // EmfEn(resonance detection)/HptSel(ERM)/ALC/ZeroCrossHysteresis
   22f62:	4c25      	ldr	r4, [pc, #148]	; (22ff8 <MAX20303_HapticConfigDCMotor+0x9c>)
	appcmdoutvalue_ = 0xA0;
   22f64:	7033      	strb	r3, [r6, #0]
	appdatainoutbuffer_[0] = 0x0A; //0x0F; // EmfEn(resonance detection)/HptSel(ERM)/ALC/ZeroCrossHysteresis
   22f66:	230a      	movs	r3, #10
   22f68:	7023      	strb	r3, [r4, #0]
	appdatainoutbuffer_[1] = 0xDA; //0x9F; // Initial guess of Back EMF frequency = 25.6M/64/IniGss =235/205; IniGss = 0x6A6/0x79F
   22f6a:	23da      	movs	r3, #218	; 0xda
   22f6c:	7063      	strb	r3, [r4, #1]
	appdatainoutbuffer_[2] = 0x16; //0x87; // ZccSlowEn=0/FltrCntrEn=0
   22f6e:	2316      	movs	r3, #22
   22f70:	70a3      	strb	r3, [r4, #2]
	appdatainoutbuffer_[4] = 0x07; //0x05; // Wide Window for BEMF zero crossing
   22f72:	2307      	movs	r3, #7
	appdatainoutbuffer_[3] = 0x00; //0x00; // Skip periods before BEMF measuring
   22f74:	2700      	movs	r7, #0
	appdatainoutbuffer_[4] = 0x07; //0x05; // Wide Window for BEMF zero crossing
   22f76:	7123      	strb	r3, [r4, #4]
	appdatainoutbuffer_[5] = 0x02; //0x01; // Narrow Window for BEMF zero crossing
   22f78:	2302      	movs	r3, #2
	ret |= MAX20353_AppWrite(6);
   22f7a:	2006      	movs	r0, #6
	appdatainoutbuffer_[3] = 0x00; //0x00; // Skip periods before BEMF measuring
   22f7c:	70e7      	strb	r7, [r4, #3]
	appdatainoutbuffer_[5] = 0x02; //0x01; // Narrow Window for BEMF zero crossing
   22f7e:	7163      	strb	r3, [r4, #5]
	ret |= MAX20353_AppWrite(6);
   22f80:	f7ff ffc6 	bl	22f10 <MAX20353_AppWrite>
	appcmdoutvalue_ = 0xA2;
   22f84:	23a2      	movs	r3, #162	; 0xa2
   22f86:	7033      	strb	r3, [r6, #0]
	appdatainoutbuffer_[0] = 0xF0; //0x01; // EmfSkipCyc
   22f88:	23f0      	movs	r3, #240	; 0xf0
   22f8a:	7023      	strb	r3, [r4, #0]
	appdatainoutbuffer_[1] = 0x88; //0x00; // BlankWdw, zero corssing comparator blanking time after enable(1/25.6MHz)
   22f8c:	2388      	movs	r3, #136	; 0x88
   22f8e:	7063      	strb	r3, [r4, #1]
	appdatainoutbuffer_[4] = 0xE6; //0xE6; // ETRGOdAmp, Overdrive amplitude, LSB = 0.78%VFS, 98%
   22f90:	23e6      	movs	r3, #230	; 0xe6
	appdatainoutbuffer_[2] = 0x00; //0x02; // BlankWdw, zero corssing comparator blanking time after enable(1/25.6MHz)
   22f92:	70a7      	strb	r7, [r4, #2]
	appdatainoutbuffer_[4] = 0xE6; //0xE6; // ETRGOdAmp, Overdrive amplitude, LSB = 0.78%VFS, 98%
   22f94:	7123      	strb	r3, [r4, #4]
	appdatainoutbuffer_[3] = 0xFF; //0x5D; // Vpp_Sine_max = 5.65V, Vpp_Square_max = 4V, VFS= Vpp/2 = 2V, Max_VFS = 5.5V, set VFS = 2/5.5*255 = 92 = 0x5C(square), Sine: VFS=2.8/5.5*255=0x82
   22f96:	27ff      	movs	r7, #255	; 0xff
	appdatainoutbuffer_[5] = 0x10; //0x10; // ETRGOdDur, Overdrive period, LSB = 5ms, 80ms
   22f98:	2310      	movs	r3, #16
	ret |= MAX20353_AppWrite(6);
   22f9a:	4605      	mov	r5, r0
	ret |= MAX20353_AppWrite(6);
   22f9c:	2006      	movs	r0, #6
	appdatainoutbuffer_[5] = 0x10; //0x10; // ETRGOdDur, Overdrive period, LSB = 5ms, 80ms
   22f9e:	7163      	strb	r3, [r4, #5]
	appdatainoutbuffer_[3] = 0xFF; //0x5D; // Vpp_Sine_max = 5.65V, Vpp_Square_max = 4V, VFS= Vpp/2 = 2V, Max_VFS = 5.5V, set VFS = 2/5.5*255 = 92 = 0x5C(square), Sine: VFS=2.8/5.5*255=0x82
   22fa0:	70e7      	strb	r7, [r4, #3]
	ret |= MAX20353_AppWrite(6);
   22fa2:	f7ff ffb5 	bl	22f10 <MAX20353_AppWrite>
	appcmdoutvalue_ = 0xA4;
   22fa6:	23a4      	movs	r3, #164	; 0xa4
   22fa8:	7033      	strb	r3, [r6, #0]
	appdatainoutbuffer_[0] = 0xC0; //0xC0; // ETRGActAmp, normal amplitude, , LSB = 0.78%VFS, don't care
   22faa:	23c0      	movs	r3, #192	; 0xc0
   22fac:	7023      	strb	r3, [r4, #0]
	appdatainoutbuffer_[2] = 0xCD; //0xCD; // ETRGActAmp, braking amplitude, , LSB = 0.78%VFS, 80*VFS
   22fae:	23cd      	movs	r3, #205	; 0xcd
   22fb0:	70a3      	strb	r3, [r4, #2]
	appdatainoutbuffer_[3] = 0x14; //0x14; // ETRGActDur, breaking period, LSB = 5ms, 60ms
   22fb2:	2314      	movs	r3, #20
	ret |= MAX20353_AppWrite(6);
   22fb4:	4305      	orrs	r5, r0
	appdatainoutbuffer_[3] = 0x14; //0x14; // ETRGActDur, breaking period, LSB = 5ms, 60ms
   22fb6:	70e3      	strb	r3, [r4, #3]
	appdatainoutbuffer_[5] = 0x06; //0x00; // periods from wide to narrow
   22fb8:	2006      	movs	r0, #6
	appdatainoutbuffer_[4] = 0x23; //0x15; // narrow window gain, wide window gain = 1
   22fba:	2323      	movs	r3, #35	; 0x23
	appdatainoutbuffer_[1] = 0xFF; //0xFF; // ETRGActDur, normal period, LSB = 10ms, don't care
   22fbc:	7067      	strb	r7, [r4, #1]
	appdatainoutbuffer_[4] = 0x23; //0x15; // narrow window gain, wide window gain = 1
   22fbe:	7123      	strb	r3, [r4, #4]
	appdatainoutbuffer_[5] = 0x06; //0x00; // periods from wide to narrow
   22fc0:	7160      	strb	r0, [r4, #5]
	ret |= MAX20353_AppWrite(6);
   22fc2:	f7ff ffa5 	bl	22f10 <MAX20353_AppWrite>
	appcmdoutvalue_ = 0xA6;
   22fc6:	23a6      	movs	r3, #166	; 0xa6
   22fc8:	7033      	strb	r3, [r6, #0]
	appdatainoutbuffer_[0] = 0x4A; //Sys UVLO threshold = 1.6V
   22fca:	234a      	movs	r3, #74	; 0x4a
	ret |= MAX20353_AppWrite(6);
   22fcc:	4305      	orrs	r5, r0
	ret |= MAX20353_AppWrite(1);
   22fce:	2001      	movs	r0, #1
	appdatainoutbuffer_[0] = 0x4A; //Sys UVLO threshold = 1.6V
   22fd0:	7023      	strb	r3, [r4, #0]
	ret |= MAX20353_AppWrite(1);
   22fd2:	f7ff ff9d 	bl	22f10 <MAX20353_AppWrite>
	if(ret != 0)
   22fd6:	ea55 0100 	orrs.w	r1, r5, r0
   22fda:	d107      	bne.n	22fec <MAX20303_HapticConfigDCMotor+0x90>
	ret |= MAX20353_WriteReg( REG_HPT_DIRECT1,  0x00); //hptExtTrig=1, HptRamEn=1, HptDrvEn=1, HptDrvMode=0x12, disable HptDrvEn
   22fdc:	2031      	movs	r0, #49	; 0x31
   22fde:	f7ff ff73 	bl	22ec8 <MAX20353_WriteReg>
	if(ret != 0)
   22fe2:	3000      	adds	r0, #0
   22fe4:	bf18      	it	ne
   22fe6:	2001      	movne	r0, #1
   22fe8:	4240      	negs	r0, r0
}
   22fea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return MAX20353_ERROR;
   22fec:	f04f 30ff 	mov.w	r0, #4294967295
   22ff0:	e7fb      	b.n	22fea <MAX20303_HapticConfigDCMotor+0x8e>
   22ff2:	bf00      	nop
   22ff4:	20024cea 	.word	0x20024cea
   22ff8:	20024ceb 	.word	0x20024ceb

00022ffc <MAX20353_Buck1Config>:
    appcmdoutvalue_ = 0x35;
   22ffc:	2235      	movs	r2, #53	; 0x35
   22ffe:	4b07      	ldr	r3, [pc, #28]	; (2301c <MAX20353_Buck1Config+0x20>)
    ret = MAX20353_AppWrite(4);
   23000:	2004      	movs	r0, #4
    appcmdoutvalue_ = 0x35;
   23002:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x00;  	//
   23004:	2200      	movs	r2, #0
   23006:	4b06      	ldr	r3, [pc, #24]	; (23020 <MAX20353_Buck1Config+0x24>)
   23008:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[1] = 0x2C;  	//0x28    0.7+(0.025V * number)    0x48*0.025 =1.8v     //0.7V to 2.275V, Linear Scale, 25mV increments
   2300a:	222c      	movs	r2, #44	; 0x2c
   2300c:	705a      	strb	r2, [r3, #1]
    appdatainoutbuffer_[2] = 0x1F;  	//0x2F  	01 = 20mA, Use for 1V < Buck1VSet < 1.8V
   2300e:	221f      	movs	r2, #31
   23010:	709a      	strb	r2, [r3, #2]
    appdatainoutbuffer_[3] = 0x01;  	// Enable
   23012:	2201      	movs	r2, #1
   23014:	70da      	strb	r2, [r3, #3]
    ret = MAX20353_AppWrite(4);
   23016:	f7ff bf7b 	b.w	22f10 <MAX20353_AppWrite>
   2301a:	bf00      	nop
   2301c:	20024cea 	.word	0x20024cea
   23020:	20024ceb 	.word	0x20024ceb

00023024 <MAX20353_Buck2Config>:
    appcmdoutvalue_ = 0x3A;
   23024:	223a      	movs	r2, #58	; 0x3a
    appdatainoutbuffer_[1] = 0x32;     	//0x32    0.7V + (0.05V * number) = 3.3V;
   23026:	2132      	movs	r1, #50	; 0x32
    appcmdoutvalue_ = 0x3A;
   23028:	4b05      	ldr	r3, [pc, #20]	; (23040 <MAX20353_Buck2Config+0x1c>)
    ret = MAX20353_AppWrite(4);
   2302a:	2004      	movs	r0, #4
    appcmdoutvalue_ = 0x3A;
   2302c:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x01;      //
   2302e:	4b05      	ldr	r3, [pc, #20]	; (23044 <MAX20353_Buck2Config+0x20>)
   23030:	2201      	movs	r2, #1
    appdatainoutbuffer_[1] = 0x32;     	//0x32    0.7V + (0.05V * number) = 3.3V;
   23032:	7059      	strb	r1, [r3, #1]
    appdatainoutbuffer_[2] = 0x3F;		//  0x3F 375mA  01 = 20mA, Use for 1V < Buck2VSet < 1.8V
   23034:	213f      	movs	r1, #63	; 0x3f
    appdatainoutbuffer_[0] = 0x01;      //
   23036:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[2] = 0x3F;		//  0x3F 375mA  01 = 20mA, Use for 1V < Buck2VSet < 1.8V
   23038:	7099      	strb	r1, [r3, #2]
    appdatainoutbuffer_[3] = 0x01;		// Enable
   2303a:	70da      	strb	r2, [r3, #3]
    ret = MAX20353_AppWrite(4);
   2303c:	f7ff bf68 	b.w	22f10 <MAX20353_AppWrite>
   23040:	20024cea 	.word	0x20024cea
   23044:	20024ceb 	.word	0x20024ceb

00023048 <MAX20353_LDO1Config>:
    appcmdoutvalue_ = 0x40;
   23048:	2240      	movs	r2, #64	; 0x40
   2304a:	4b05      	ldr	r3, [pc, #20]	; (23060 <MAX20353_LDO1Config+0x18>)
    ret = MAX20353_AppWrite(2);
   2304c:	2002      	movs	r0, #2
    appcmdoutvalue_ = 0x40;
   2304e:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x01;     //0x01  0.5V to 1.95V, Linear Scale, 25mV increments,   LDO1  
   23050:	2201      	movs	r2, #1
   23052:	4b04      	ldr	r3, [pc, #16]	; (23064 <MAX20353_LDO1Config+0x1c>)
   23054:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[1] = 0x34;     //0x28  0.5V + (0.025V * number)   =  1.95V   1.8
   23056:	2234      	movs	r2, #52	; 0x34
   23058:	705a      	strb	r2, [r3, #1]
    ret = MAX20353_AppWrite(2);
   2305a:	f7ff bf59 	b.w	22f10 <MAX20353_AppWrite>
   2305e:	bf00      	nop
   23060:	20024cea 	.word	0x20024cea
   23064:	20024ceb 	.word	0x20024ceb

00023068 <MAX20353_LDO2Config>:
    appcmdoutvalue_ = 0x42;
   23068:	2242      	movs	r2, #66	; 0x42
   2306a:	4b05      	ldr	r3, [pc, #20]	; (23080 <MAX20353_LDO2Config+0x18>)
    ret = MAX20353_AppWrite(2);
   2306c:	2002      	movs	r0, #2
    appcmdoutvalue_ = 0x42;
   2306e:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x01;
   23070:	2201      	movs	r2, #1
   23072:	4b04      	ldr	r3, [pc, #16]	; (23084 <MAX20353_LDO2Config+0x1c>)
   23074:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[1] = 0x13;     // 0.9V + (0.1V * number)   =  2.8V 
   23076:	2213      	movs	r2, #19
   23078:	705a      	strb	r2, [r3, #1]
    ret = MAX20353_AppWrite(2);
   2307a:	f7ff bf49 	b.w	22f10 <MAX20353_AppWrite>
   2307e:	bf00      	nop
   23080:	20024cea 	.word	0x20024cea
   23084:	20024ceb 	.word	0x20024ceb

00023088 <MAX20353_BoostConfig>:
	appcmdoutvalue_ = 0x30;
   23088:	2230      	movs	r2, #48	; 0x30
   2308a:	4b06      	ldr	r3, [pc, #24]	; (230a4 <MAX20353_BoostConfig+0x1c>)
	ret = MAX20353_AppWrite(4);
   2308c:	2004      	movs	r0, #4
	appcmdoutvalue_ = 0x30;
   2308e:	701a      	strb	r2, [r3, #0]
	appdatainoutbuffer_[0] = 0x01;
   23090:	2201      	movs	r2, #1
   23092:	4b05      	ldr	r3, [pc, #20]	; (230a8 <MAX20353_BoostConfig+0x20>)
   23094:	701a      	strb	r2, [r3, #0]
	appdatainoutbuffer_[1] = 0x00;
   23096:	2200      	movs	r2, #0
   23098:	705a      	strb	r2, [r3, #1]
	appdatainoutbuffer_[2] = 0x00;
   2309a:	709a      	strb	r2, [r3, #2]
	appdatainoutbuffer_[3] = 0x00;     // 5V + (0.25V * number); 0x00:5V, 0x3B:20V; EVKIT's cap can only be upto 6.3V
   2309c:	70da      	strb	r2, [r3, #3]
	ret = MAX20353_AppWrite(4);
   2309e:	f7ff bf37 	b.w	22f10 <MAX20353_AppWrite>
   230a2:	bf00      	nop
   230a4:	20024cea 	.word	0x20024cea
   230a8:	20024ceb 	.word	0x20024ceb

000230ac <MAX20353_ChargePumpConfig>:
    appcmdoutvalue_ = 0x46;
   230ac:	2246      	movs	r2, #70	; 0x46
   230ae:	4b05      	ldr	r3, [pc, #20]	; (230c4 <MAX20353_ChargePumpConfig+0x18>)
    ret = MAX20353_AppWrite(2);
   230b0:	2002      	movs	r0, #2
    appcmdoutvalue_ = 0x46;
   230b2:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x01;	// Boost Enabled
   230b4:	2201      	movs	r2, #1
   230b6:	4b04      	ldr	r3, [pc, #16]	; (230c8 <MAX20353_ChargePumpConfig+0x1c>)
   230b8:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[1] = 0x03;	// 00 : 6.5V, 01: 5V
   230ba:	2203      	movs	r2, #3
   230bc:	705a      	strb	r2, [r3, #1]
    ret = MAX20353_AppWrite(2);
   230be:	f7ff bf27 	b.w	22f10 <MAX20353_AppWrite>
   230c2:	bf00      	nop
   230c4:	20024cea 	.word	0x20024cea
   230c8:	20024ceb 	.word	0x20024ceb

000230cc <MAX20353_BuckBoostConfig>:
    appcmdoutvalue_ = 0x70;
   230cc:	2270      	movs	r2, #112	; 0x70
   230ce:	4b06      	ldr	r3, [pc, #24]	; (230e8 <MAX20353_BuckBoostConfig+0x1c>)
    appdatainoutbuffer_[1] = 0x04;
   230d0:	2004      	movs	r0, #4
    appcmdoutvalue_ = 0x70;
   230d2:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x00;
   230d4:	2200      	movs	r2, #0
   230d6:	4b05      	ldr	r3, [pc, #20]	; (230ec <MAX20353_BuckBoostConfig+0x20>)
   230d8:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[2] = 0x19;		// 2.5V + (0.1V * number) = 5.0V
   230da:	2219      	movs	r2, #25
   230dc:	709a      	strb	r2, [r3, #2]
    appdatainoutbuffer_[3] = 0x41;     
   230de:	2241      	movs	r2, #65	; 0x41
    appdatainoutbuffer_[1] = 0x04;
   230e0:	7058      	strb	r0, [r3, #1]
    appdatainoutbuffer_[3] = 0x41;     
   230e2:	70da      	strb	r2, [r3, #3]
    ret = MAX20353_AppWrite(4);
   230e4:	f7ff bf14 	b.w	22f10 <MAX20353_AppWrite>
   230e8:	20024cea 	.word	0x20024cea
   230ec:	20024ceb 	.word	0x20024ceb

000230f0 <MAX20353_PowerOffConfig>:
    appcmdoutvalue_ = 0x80;
   230f0:	2280      	movs	r2, #128	; 0x80
   230f2:	4b04      	ldr	r3, [pc, #16]	; (23104 <MAX20353_PowerOffConfig+0x14>)
    ret = MAX20353_AppWrite(1);
   230f4:	2001      	movs	r0, #1
    appcmdoutvalue_ = 0x80;
   230f6:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0xB2;
   230f8:	22b2      	movs	r2, #178	; 0xb2
   230fa:	4b03      	ldr	r3, [pc, #12]	; (23108 <MAX20353_PowerOffConfig+0x18>)
   230fc:	701a      	strb	r2, [r3, #0]
    ret = MAX20353_AppWrite(1);
   230fe:	f7ff bf07 	b.w	22f10 <MAX20353_AppWrite>
   23102:	bf00      	nop
   23104:	20024cea 	.word	0x20024cea
   23108:	20024ceb 	.word	0x20024ceb

0002310c <MAX20353_ReadRegMulti>:
{
   2310c:	b538      	push	{r3, r4, r5, lr}
	ret = pmu_dev_ctx.read_reg(pmu_dev_ctx.handle, reg, value, len);
   2310e:	4c06      	ldr	r4, [pc, #24]	; (23128 <MAX20353_ReadRegMulti+0x1c>)
   23110:	4613      	mov	r3, r2
   23112:	6865      	ldr	r5, [r4, #4]
   23114:	460a      	mov	r2, r1
   23116:	4601      	mov	r1, r0
   23118:	68a0      	ldr	r0, [r4, #8]
   2311a:	47a8      	blx	r5
    if(ret != 0)
   2311c:	3000      	adds	r0, #0
   2311e:	bf18      	it	ne
   23120:	2001      	movne	r0, #1
}
   23122:	4240      	negs	r0, r0
   23124:	bd38      	pop	{r3, r4, r5, pc}
   23126:	bf00      	nop
   23128:	20020438 	.word	0x20020438

0002312c <MAX20353_AppRead>:
{
   2312c:	b538      	push	{r3, r4, r5, lr}
	ret = MAX20353_WriteReg(REG_AP_CMDOUT, appcmdoutvalue_);
   2312e:	4b0b      	ldr	r3, [pc, #44]	; (2315c <MAX20353_AppRead+0x30>)
{
   23130:	4605      	mov	r5, r0
	ret = MAX20353_WriteReg(REG_AP_CMDOUT, appcmdoutvalue_);
   23132:	7819      	ldrb	r1, [r3, #0]
   23134:	2017      	movs	r0, #23
   23136:	f7ff fec7 	bl	22ec8 <MAX20353_WriteReg>
   2313a:	4604      	mov	r4, r0
	k_sleep(K_MSEC(10));
   2313c:	200a      	movs	r0, #10
   2313e:	f014 fa90 	bl	37662 <k_sleep>
	ret |= MAX20353_ReadRegMulti(REG_AP_RESPONSE, i2cbuffer_, datainlen);
   23142:	462a      	mov	r2, r5
   23144:	4906      	ldr	r1, [pc, #24]	; (23160 <MAX20353_AppRead+0x34>)
   23146:	2018      	movs	r0, #24
   23148:	f7ff ffe0 	bl	2310c <MAX20353_ReadRegMulti>
	if(ret != 0)
   2314c:	ea54 0300 	orrs.w	r3, r4, r0
}
   23150:	bf14      	ite	ne
   23152:	f04f 30ff 	movne.w	r0, #4294967295
   23156:	2000      	moveq	r0, #0
   23158:	bd38      	pop	{r3, r4, r5, pc}
   2315a:	bf00      	nop
   2315c:	20024cea 	.word	0x20024cea
   23160:	20024cf3 	.word	0x20024cf3

00023164 <MAX20353_ChargerCfg>:
	appcmdoutvalue_ = 0x14; 
   23164:	2214      	movs	r2, #20
   23166:	4b06      	ldr	r3, [pc, #24]	; (23180 <MAX20353_ChargerCfg+0x1c>)
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   23168:	2004      	movs	r0, #4
	appcmdoutvalue_ = 0x14; 
   2316a:	701a      	strb	r2, [r3, #0]
	appdatainoutbuffer_[1] = 0x61; // Precharge to b110:3.0V, b00:0.05IFChg for dead battery, ChgDone b01: 0.1IFChg 
   2316c:	2261      	movs	r2, #97	; 0x61
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   2316e:	4b05      	ldr	r3, [pc, #20]	; (23184 <MAX20353_ChargerCfg+0x20>)
	appdatainoutbuffer_[1] = 0x61; // Precharge to b110:3.0V, b00:0.05IFChg for dead battery, ChgDone b01: 0.1IFChg 
   23170:	705a      	strb	r2, [r3, #1]
	appdatainoutbuffer_[2] = 0xD6; // Auto Stop, Auto ReStart, ReChg Threshold b01:120mV, Bat Volt b0011: 4.2V, b0110:4.35 
   23172:	22d6      	movs	r2, #214	; 0xd6
   23174:	709a      	strb	r2, [r3, #2]
	appdatainoutbuffer_[3] = 0x07; // System min volt = 4.3V 
   23176:	2207      	movs	r2, #7
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   23178:	7018      	strb	r0, [r3, #0]
	appdatainoutbuffer_[3] = 0x07; // System min volt = 4.3V 
   2317a:	70da      	strb	r2, [r3, #3]
	ret |= MAX20353_AppWrite(4);
   2317c:	f7ff bec8 	b.w	22f10 <MAX20353_AppWrite>
   23180:	20024cea 	.word	0x20024cea
   23184:	20024ceb 	.word	0x20024ceb

00023188 <MAX20353_ChargerCtrl>:
	appcmdoutvalue_ = 0x1A; 
   23188:	221a      	movs	r2, #26
	appdatainoutbuffer_[0] = 0x01; // Thermal EN, Charger EN 
   2318a:	2001      	movs	r0, #1
	appcmdoutvalue_ = 0x1A; 
   2318c:	4b02      	ldr	r3, [pc, #8]	; (23198 <MAX20353_ChargerCtrl+0x10>)
   2318e:	701a      	strb	r2, [r3, #0]
	appdatainoutbuffer_[0] = 0x01; // Thermal EN, Charger EN 
   23190:	4b02      	ldr	r3, [pc, #8]	; (2319c <MAX20353_ChargerCtrl+0x14>)
   23192:	7018      	strb	r0, [r3, #0]
	ret |= MAX20353_AppWrite(1); 
   23194:	f7ff bebc 	b.w	22f10 <MAX20353_AppWrite>
   23198:	20024cea 	.word	0x20024cea
   2319c:	20024ceb 	.word	0x20024ceb

000231a0 <MAX20353_InputCurCfg>:
	appcmdoutvalue_ = 0x10;
   231a0:	2210      	movs	r2, #16
   231a2:	4b04      	ldr	r3, [pc, #16]	; (231b4 <MAX20353_InputCurCfg+0x14>)
	ret = MAX20353_AppWrite(1);
   231a4:	2001      	movs	r0, #1
	appcmdoutvalue_ = 0x10;
   231a6:	701a      	strb	r2, [r3, #0]
	appdatainoutbuffer_[0] = 0x1E;  //500ma(+,F3160ma),10ms
   231a8:	221e      	movs	r2, #30
   231aa:	4b03      	ldr	r3, [pc, #12]	; (231b8 <MAX20353_InputCurCfg+0x18>)
   231ac:	701a      	strb	r2, [r3, #0]
	ret = MAX20353_AppWrite(1);
   231ae:	f7ff beaf 	b.w	22f10 <MAX20353_AppWrite>
   231b2:	bf00      	nop
   231b4:	20024cea 	.word	0x20024cea
   231b8:	20024ceb 	.word	0x20024ceb

000231bc <MAX20353_ChargerInit>:
{
   231bc:	b508      	push	{r3, lr}
	MAX20353_ChargerCfg();
   231be:	f7ff ffd1 	bl	23164 <MAX20353_ChargerCfg>
	MAX20353_ChargerCtrl();
   231c2:	f7ff ffe1 	bl	23188 <MAX20353_ChargerCtrl>
	MAX20353_InputCurCfg();
   231c6:	f7ff ffeb 	bl	231a0 <MAX20353_InputCurCfg>
	PMICIntMasks[0] = 0x48;
   231ca:	2348      	movs	r3, #72	; 0x48
   231cc:	4804      	ldr	r0, [pc, #16]	; (231e0 <MAX20353_ChargerInit+0x24>)
   231ce:	7003      	strb	r3, [r0, #0]
	PMICIntMasks[1] = 0x00;
   231d0:	2300      	movs	r3, #0
   231d2:	7043      	strb	r3, [r0, #1]
	PMICIntMasks[2] = 0x00;
   231d4:	7083      	strb	r3, [r0, #2]
}
   231d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	MAX20353_EnablePMICIntMaskRegisters(PMICIntMasks);
   231da:	f014 ba67 	b.w	376ac <MAX20353_EnablePMICIntMaskRegisters>
   231de:	bf00      	nop
   231e0:	20024ce5 	.word	0x20024ce5

000231e4 <InitCharger>:
	appcmdoutvalue_ = 0x14; 
   231e4:	2314      	movs	r3, #20
{ 
   231e6:	b570      	push	{r4, r5, r6, lr}
	appcmdoutvalue_ = 0x14; 
   231e8:	4d0a      	ldr	r5, [pc, #40]	; (23214 <InitCharger+0x30>)
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   231ea:	4c0b      	ldr	r4, [pc, #44]	; (23218 <InitCharger+0x34>)
	appcmdoutvalue_ = 0x14; 
   231ec:	702b      	strb	r3, [r5, #0]
	appdatainoutbuffer_[1] = 0x61; // Precharge to b110:3.0V, b00:0.05IFChg for dead battery, ChgDone b01: 0.1IFChg 
   231ee:	2361      	movs	r3, #97	; 0x61
   231f0:	7063      	strb	r3, [r4, #1]
	appdatainoutbuffer_[2] = 0xD6; // Auto Stop, Auto ReStart, ReChg Threshold b01:120mV, Bat Volt b0011: 4.2V, b0110:4.35 
   231f2:	23d6      	movs	r3, #214	; 0xd6
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   231f4:	2004      	movs	r0, #4
	appdatainoutbuffer_[2] = 0xD6; // Auto Stop, Auto ReStart, ReChg Threshold b01:120mV, Bat Volt b0011: 4.2V, b0110:4.35 
   231f6:	70a3      	strb	r3, [r4, #2]
	appdatainoutbuffer_[3] = 0x07; // System min volt = 4.3V 
   231f8:	2307      	movs	r3, #7
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   231fa:	7020      	strb	r0, [r4, #0]
	appdatainoutbuffer_[3] = 0x07; // System min volt = 4.3V 
   231fc:	70e3      	strb	r3, [r4, #3]
	ret |= MAX20353_AppWrite(4);
   231fe:	f7ff fe87 	bl	22f10 <MAX20353_AppWrite>
	appcmdoutvalue_ = 0x1A; 
   23202:	231a      	movs	r3, #26
	ret |= MAX20353_AppWrite(4);
   23204:	4606      	mov	r6, r0
	appdatainoutbuffer_[0] = 0x01; // Thermal EN, Charger EN 
   23206:	2001      	movs	r0, #1
	appcmdoutvalue_ = 0x1A; 
   23208:	702b      	strb	r3, [r5, #0]
	appdatainoutbuffer_[0] = 0x01; // Thermal EN, Charger EN 
   2320a:	7020      	strb	r0, [r4, #0]
	ret |= MAX20353_AppWrite(1); 
   2320c:	f7ff fe80 	bl	22f10 <MAX20353_AppWrite>
}
   23210:	4330      	orrs	r0, r6
   23212:	bd70      	pop	{r4, r5, r6, pc}
   23214:	20024cea 	.word	0x20024cea
   23218:	20024ceb 	.word	0x20024ceb

0002321c <ReadWord>:
{
   2321c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
			    u32_t num_bytes, u16_t addr)
{
	struct i2c_msg msg;

	msg.buf = (u8_t *)buf;
	msg.len = num_bytes;
   23220:	2401      	movs	r4, #1
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   23222:	2502      	movs	r5, #2
   23224:	b087      	sub	sp, #28
	ret = i2c_write(pmu_dev_ctx.handle, &data, sizeof(data), MAX20353_I2C_ADDR_FUEL_GAUGE);
   23226:	4e18      	ldr	r6, [pc, #96]	; (23288 <ReadWord+0x6c>)
	msg.buf = (u8_t *)buf;
   23228:	f10d 0307 	add.w	r3, sp, #7
	u8_t data = reg;
   2322c:	f88d 0007 	strb.w	r0, [sp, #7]
{
   23230:	4688      	mov	r8, r1
   23232:	4617      	mov	r7, r2
	ret = i2c_write(pmu_dev_ctx.handle, &data, sizeof(data), MAX20353_I2C_ADDR_FUEL_GAUGE);
   23234:	68b0      	ldr	r0, [r6, #8]
   23236:	9303      	str	r3, [sp, #12]
	msg.len = num_bytes;
   23238:	9404      	str	r4, [sp, #16]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   2323a:	f88d 5014 	strb.w	r5, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   2323e:	6843      	ldr	r3, [r0, #4]
   23240:	4622      	mov	r2, r4
   23242:	f8d3 9004 	ldr.w	r9, [r3, #4]
   23246:	a903      	add	r1, sp, #12
   23248:	2336      	movs	r3, #54	; 0x36
   2324a:	47c8      	blx	r9
	if(ret != 0)
   2324c:	b120      	cbz	r0, 23258 <ReadWord+0x3c>
		return MAX20353_ERROR;
   2324e:	f04f 30ff 	mov.w	r0, #4294967295
}
   23252:	b007      	add	sp, #28
   23254:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
static inline int i2c_read(struct device *dev, u8_t *buf,
			   u32_t num_bytes, u16_t addr)
{
	struct i2c_msg msg;

	msg.buf = buf;
   23258:	ab02      	add	r3, sp, #8
	msg.len = num_bytes;
   2325a:	e9cd 3503 	strd	r3, r5, [sp, #12]
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
   2325e:	2303      	movs	r3, #3
	ret = i2c_read(pmu_dev_ctx.handle, value, sizeof(value), MAX20353_I2C_ADDR_FUEL_GAUGE);
   23260:	68b0      	ldr	r0, [r6, #8]
   23262:	f88d 3014 	strb.w	r3, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   23266:	6843      	ldr	r3, [r0, #4]
   23268:	4622      	mov	r2, r4
   2326a:	685d      	ldr	r5, [r3, #4]
   2326c:	a903      	add	r1, sp, #12
   2326e:	2336      	movs	r3, #54	; 0x36
   23270:	47a8      	blx	r5
	if (ret != 0)
   23272:	2800      	cmp	r0, #0
   23274:	d1eb      	bne.n	2324e <ReadWord+0x32>
	*MSB = value[0];
   23276:	f89d 3008 	ldrb.w	r3, [sp, #8]
   2327a:	f888 3000 	strb.w	r3, [r8]
	*LSB = value[1];
   2327e:	f89d 3009 	ldrb.w	r3, [sp, #9]
   23282:	703b      	strb	r3, [r7, #0]
	return MAX20353_NO_ERROR;
   23284:	e7e5      	b.n	23252 <ReadWord+0x36>
   23286:	bf00      	nop
   23288:	20020438 	.word	0x20020438

0002328c <WriteWord>:
{
   2328c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	rslt = i2c_write(pmu_dev_ctx.handle, cmdData, sizeof(cmdData), MAX20353_I2C_ADDR_FUEL_GAUGE);
   2328e:	4b0d      	ldr	r3, [pc, #52]	; (232c4 <WriteWord+0x38>)
	u8_t cmdData[3] = {reg, MSB, LSB};
   23290:	f88d 0000 	strb.w	r0, [sp]
	rslt = i2c_write(pmu_dev_ctx.handle, cmdData, sizeof(cmdData), MAX20353_I2C_ADDR_FUEL_GAUGE);
   23294:	6898      	ldr	r0, [r3, #8]
	msg.len = num_bytes;
   23296:	2303      	movs	r3, #3
   23298:	9302      	str	r3, [sp, #8]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   2329a:	2302      	movs	r3, #2
	u8_t cmdData[3] = {reg, MSB, LSB};
   2329c:	f88d 1001 	strb.w	r1, [sp, #1]
   232a0:	f88d 2002 	strb.w	r2, [sp, #2]
	msg.buf = (u8_t *)buf;
   232a4:	f8cd d004 	str.w	sp, [sp, #4]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   232a8:	f88d 300c 	strb.w	r3, [sp, #12]
	return api->transfer(dev, msgs, num_msgs, addr);
   232ac:	6843      	ldr	r3, [r0, #4]
   232ae:	2201      	movs	r2, #1
   232b0:	685c      	ldr	r4, [r3, #4]
   232b2:	a901      	add	r1, sp, #4
   232b4:	2336      	movs	r3, #54	; 0x36
   232b6:	47a0      	blx	r4
	if (rslt != 0)
   232b8:	3000      	adds	r0, #0
   232ba:	bf18      	it	ne
   232bc:	2001      	movne	r0, #1
}
   232be:	4240      	negs	r0, r0
   232c0:	b004      	add	sp, #16
   232c2:	bd10      	pop	{r4, pc}
   232c4:	20020438 	.word	0x20020438

000232c8 <WriteMulti>:
	ret = i2c_write(pmu_dev_ctx.handle, data, len, MAX20353_I2C_ADDR_FUEL_GAUGE);
   232c8:	4b0a      	ldr	r3, [pc, #40]	; (232f4 <WriteMulti+0x2c>)
{
   232ca:	b530      	push	{r4, r5, lr}
	ret = i2c_write(pmu_dev_ctx.handle, data, len, MAX20353_I2C_ADDR_FUEL_GAUGE);
   232cc:	689c      	ldr	r4, [r3, #8]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   232ce:	2302      	movs	r3, #2
{
   232d0:	b085      	sub	sp, #20
	ret = i2c_write(pmu_dev_ctx.handle, data, len, MAX20353_I2C_ADDR_FUEL_GAUGE);
   232d2:	e9cd 0101 	strd	r0, r1, [sp, #4]
   232d6:	f88d 300c 	strb.w	r3, [sp, #12]
	return api->transfer(dev, msgs, num_msgs, addr);
   232da:	6863      	ldr	r3, [r4, #4]
   232dc:	2201      	movs	r2, #1
   232de:	685d      	ldr	r5, [r3, #4]
   232e0:	a901      	add	r1, sp, #4
   232e2:	2336      	movs	r3, #54	; 0x36
   232e4:	4620      	mov	r0, r4
   232e6:	47a8      	blx	r5
	if (ret != 0)
   232e8:	3000      	adds	r0, #0
   232ea:	bf18      	it	ne
   232ec:	2001      	movne	r0, #1
}
   232ee:	4240      	negs	r0, r0
   232f0:	b005      	add	sp, #20
   232f2:	bd30      	pop	{r4, r5, pc}
   232f4:	20020438 	.word	0x20020438

000232f8 <MAX20353_ReadTHM>:
{
   232f8:	b530      	push	{r4, r5, lr}
	appdatainoutbuffer_[0] = 0x22; ////4 average, THM
   232fa:	2222      	movs	r2, #34	; 0x22
	appcmdoutvalue_ = 0x53;
   232fc:	2553      	movs	r5, #83	; 0x53
	appdatainoutbuffer_[0] = 0x22; ////4 average, THM
   232fe:	4b13      	ldr	r3, [pc, #76]	; (2334c <MAX20353_ReadTHM+0x54>)
	appcmdoutvalue_ = 0x53;
   23300:	4c13      	ldr	r4, [pc, #76]	; (23350 <MAX20353_ReadTHM+0x58>)
{
   23302:	b085      	sub	sp, #20
	ret |= MAX20353_AppWrite(1);
   23304:	2001      	movs	r0, #1
	appdatainoutbuffer_[0] = 0x22; ////4 average, THM
   23306:	701a      	strb	r2, [r3, #0]
	appcmdoutvalue_ = 0x53;
   23308:	7025      	strb	r5, [r4, #0]
	ret |= MAX20353_AppWrite(1);
   2330a:	f7ff fe01 	bl	22f10 <MAX20353_AppWrite>
	ret |= MAX20353_AppRead(5);
   2330e:	2005      	movs	r0, #5
	appcmdoutvalue_ = 0x53;
   23310:	7025      	strb	r5, [r4, #0]
	ret |= MAX20353_AppRead(5);
   23312:	f7ff ff0b 	bl	2312c <MAX20353_AppRead>
	LOG_INF("%02X, %02X, %02X, %02X, %02X\n", i2cbuffer_[0], i2cbuffer_[1], i2cbuffer_[2], i2cbuffer_[3], i2cbuffer_[4]);
   23316:	2303      	movs	r3, #3
   23318:	f04f 0000 	mov.w	r0, #0
   2331c:	4a0d      	ldr	r2, [pc, #52]	; (23354 <MAX20353_ReadTHM+0x5c>)
   2331e:	f363 0007 	bfi	r0, r3, #0, #8
   23322:	4b0d      	ldr	r3, [pc, #52]	; (23358 <MAX20353_ReadTHM+0x60>)
   23324:	4c0d      	ldr	r4, [pc, #52]	; (2335c <MAX20353_ReadTHM+0x64>)
   23326:	1a9b      	subs	r3, r3, r2
   23328:	08db      	lsrs	r3, r3, #3
   2332a:	f363 108f 	bfi	r0, r3, #6, #10
   2332e:	7923      	ldrb	r3, [r4, #4]
   23330:	490b      	ldr	r1, [pc, #44]	; (23360 <MAX20353_ReadTHM+0x68>)
   23332:	9302      	str	r3, [sp, #8]
   23334:	78e3      	ldrb	r3, [r4, #3]
   23336:	9301      	str	r3, [sp, #4]
   23338:	78a3      	ldrb	r3, [r4, #2]
   2333a:	9300      	str	r3, [sp, #0]
   2333c:	7863      	ldrb	r3, [r4, #1]
   2333e:	7822      	ldrb	r2, [r4, #0]
   23340:	f014 fd15 	bl	37d6e <log_string_sync>
}
   23344:	7920      	ldrb	r0, [r4, #4]
   23346:	b005      	add	sp, #20
   23348:	bd30      	pop	{r4, r5, pc}
   2334a:	bf00      	nop
   2334c:	20024ceb 	.word	0x20024ceb
   23350:	20024cea 	.word	0x20024cea
   23354:	0003ade0 	.word	0x0003ade0
   23358:	0003ae80 	.word	0x0003ae80
   2335c:	20024cf3 	.word	0x20024cf3
   23360:	0003cb60 	.word	0x0003cb60

00023364 <MAX20353_UpdateRCOMP>:
	if(temp>20) // (20, ...) 
   23364:	2814      	cmp	r0, #20
{
   23366:	b510      	push	{r4, lr}
	if(temp>20) // (20, ...) 
   23368:	dd17      	ble.n	2339a <MAX20353_UpdateRCOMP+0x36>
		result = INI_RCOMP + (temp - 20) * used_tempco;
   2336a:	3814      	subs	r0, #20
   2336c:	ee07 0a90 	vmov	s15, r0
   23370:	eefe 6a07 	vmov.f32	s13, #231	; 0xbf380000 -0.7187500
   23374:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
		result = INI_RCOMP + (temp - 20) * used_tempco;
   23378:	eef3 7a06 	vmov.f32	s15, #54	; 0x41b00000  22.0
		result = result_0 + (temp - 0) * used_tempco;
   2337c:	ee47 7a26 	vmla.f32	s15, s14, s13
   23380:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	RCOMP = (result >= 0xff ? 0xff : (result <= 0 ?  0 : result));
   23384:	ee17 3a90 	vmov	r3, s15
   23388:	f383 0408 	usat	r4, #8, r3
	WriteWord(0x0C, RCOMP, 0x5C);
   2338c:	225c      	movs	r2, #92	; 0x5c
   2338e:	b2e1      	uxtb	r1, r4
   23390:	200c      	movs	r0, #12
   23392:	f7ff ff7b 	bl	2328c <WriteWord>
}
   23396:	4620      	mov	r0, r4
   23398:	bd10      	pop	{r4, pc}
	else if(temp>0) // {0, 20)
   2339a:	2800      	cmp	r0, #0
   2339c:	dd07      	ble.n	233ae <MAX20353_UpdateRCOMP+0x4a>
		result = INI_RCOMP + (temp - 20) * used_tempco;
   2339e:	3814      	subs	r0, #20
   233a0:	ee07 0a90 	vmov	s15, r0
   233a4:	eef8 6a0f 	vmov.f32	s13, #143	; 0xc0780000 -3.875
   233a8:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   233ac:	e7e4      	b.n	23378 <MAX20353_UpdateRCOMP+0x14>
		result = result_0 + (temp - 0) * used_tempco;
   233ae:	ee07 0a90 	vmov	s15, r0
   233b2:	eddf 6a03 	vldr	s13, [pc, #12]	; 233c0 <MAX20353_UpdateRCOMP+0x5c>
   233b6:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   233ba:	eddf 7a02 	vldr	s15, [pc, #8]	; 233c4 <MAX20353_UpdateRCOMP+0x60>
   233be:	e7dd      	b.n	2337c <MAX20353_UpdateRCOMP+0x18>
   233c0:	c07a0000 	.word	0xc07a0000
   233c4:	42c60000 	.word	0x42c60000

000233c8 <MAX20353_StartCheckTemper>:

void MAX20353_StartCheckTemper(void)
{
   233c8:	b510      	push	{r4, lr}
	k_timer_init(&ntc_check_timer, MAX20353_CheckTemper, NULL);
   233ca:	4c07      	ldr	r4, [pc, #28]	; (233e8 <MAX20353_StartCheckTemper+0x20>)
   233cc:	2200      	movs	r2, #0
   233ce:	4907      	ldr	r1, [pc, #28]	; (233ec <MAX20353_StartCheckTemper+0x24>)
   233d0:	4620      	mov	r0, r4
   233d2:	f016 fc29 	bl	39c28 <k_timer_init>
   233d6:	f64e 2260 	movw	r2, #60000	; 0xea60
   233da:	4620      	mov	r0, r4
	k_timer_start(&ntc_check_timer, K_MSEC(30*1000), K_MSEC(60*1000));
}
   233dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   233e0:	f247 5130 	movw	r1, #30000	; 0x7530
   233e4:	f011 bfde 	b.w	353a4 <z_impl_k_timer_start>
   233e8:	20020470 	.word	0x20020470
   233ec:	00022e9d 	.word	0x00022e9d

000233f0 <MAX20353_CalculateSOC>:

#endif/*BATTERT_NTC_CHECK*/

u8_t MAX20353_CalculateSOC(void)
{
   233f0:	b510      	push	{r4, lr}
	u16_t tmp;
	
	ReadWord(0x04, &SOC_1, &SOC_2);
   233f2:	4c04      	ldr	r4, [pc, #16]	; (23404 <MAX20353_CalculateSOC+0x14>)
   233f4:	4a04      	ldr	r2, [pc, #16]	; (23408 <MAX20353_CalculateSOC+0x18>)
   233f6:	4621      	mov	r1, r4
   233f8:	2004      	movs	r0, #4
   233fa:	f7ff ff0f 	bl	2321c <ReadWord>
		SOC_percent = SOC/512;

	//SOC_percent = 26.5;
	
	return SOC_percent;
}
   233fe:	7820      	ldrb	r0, [r4, #0]
   23400:	bd10      	pop	{r4, pc}
   23402:	bf00      	nop
   23404:	20024ce8 	.word	0x20024ce8
   23408:	20024ce9 	.word	0x20024ce9

0002340c <prepare_to_load_model>:
	*/
	delay_ms(250);
}

void prepare_to_load_model(void)
{
   2340c:	b538      	push	{r3, r4, r5, lr}
	Step 2. Read OCV
	The OCV Register will be modified during the process of loading the custom
	model. Read and store this value so that it can be written back to the
	device after the model has been loaded.
	*/
	ReadWord(0x0E, &original_OCV_1, &original_OCV_2);
   2340e:	4c09      	ldr	r4, [pc, #36]	; (23434 <prepare_to_load_model+0x28>)
   23410:	4d09      	ldr	r5, [pc, #36]	; (23438 <prepare_to_load_model+0x2c>)
	WriteWord(0x3E, 0x4A, 0x57);
   23412:	2257      	movs	r2, #87	; 0x57
   23414:	214a      	movs	r1, #74	; 0x4a
   23416:	203e      	movs	r0, #62	; 0x3e
   23418:	f7ff ff38 	bl	2328c <WriteWord>
	ReadWord(0x0E, &original_OCV_1, &original_OCV_2);
   2341c:	4a05      	ldr	r2, [pc, #20]	; (23434 <prepare_to_load_model+0x28>)
   2341e:	4906      	ldr	r1, [pc, #24]	; (23438 <prepare_to_load_model+0x2c>)
   23420:	200e      	movs	r0, #14
   23422:	f7ff fefb 	bl	2321c <ReadWord>
	If Model Access was correctly unlocked in Step 1, then the OCV bytes read
	in Step 2 will not be 0xFF. If the values of both bytes are 0xFF,
	that indicates that Model Access was not correctly unlocked and the
	sequence should be repeated from Step 1.
	*/
	if((original_OCV_1 == 0xFF) && (original_OCV_2 == 0xFF))
   23426:	782b      	ldrb	r3, [r5, #0]
   23428:	7822      	ldrb	r2, [r4, #0]
   2342a:	4013      	ands	r3, r2
   2342c:	2bff      	cmp	r3, #255	; 0xff
   2342e:	d0f0      	beq.n	23412 <prepare_to_load_model+0x6>
	Step 4. Write RCOMP to its Maximum Value (MAX17040/1/3/4 only)
	Make the fuel-gauge respond as slowly as possible (MSB = 0xFF), and disable
	alerts during model loading (LSB = 0x00)
	*/
	//WriteWord(0x0C, 0xFF, 0x00);
}
   23430:	bd38      	pop	{r3, r4, r5, pc}
   23432:	bf00      	nop
   23434:	20024d04 	.word	0x20024d04
   23438:	20024d03 	.word	0x20024d03

0002343c <load_model>:

void load_model(void)
{
   2343c:	b570      	push	{r4, r5, r6, lr}
   2343e:	b09a      	sub	sp, #104	; 0x68
	u8_t databuf[10] = {0};
	u8_t addr_mem;
	u32_t RCOMPSeg = RCOMPSEG;
	unsigned char RCOMPSeg_MSB = (RCOMPSeg >> 8) & 0xFF;
	unsigned char RCOMPSeg_LSB = RCOMPSeg & 0xFF;	
	u8_t model_data[65] = 
   23440:	2241      	movs	r2, #65	; 0x41
   23442:	490e      	ldr	r1, [pc, #56]	; (2347c <load_model+0x40>)
   23444:	a809      	add	r0, sp, #36	; 0x24
   23446:	f016 fc9a 	bl	39d7e <memcpy>
		0xD7,0x50,0x00,0x80,0x08,0xE0,0x12,0x80,0x0F,0xE0,
		0x15,0xC0,0x12,0xC0,0x19,0xE0,0x12,0xF0,0x0C,0xF0,
		0x09,0xE0,0x09,0x30,0x08,0x80,0x07,0xE0,0x09,0x00,
		0x06,0x10,0x06,0x10
	};
	u8_t RCOMP_data[33] = // 1+16*2, first byte is the memory address
   2344a:	466a      	mov	r2, sp
   2344c:	4615      	mov	r5, r2
   2344e:	4b0c      	ldr	r3, [pc, #48]	; (23480 <load_model+0x44>)
   23450:	f103 0620 	add.w	r6, r3, #32
   23454:	4614      	mov	r4, r2
   23456:	6818      	ldr	r0, [r3, #0]
   23458:	6859      	ldr	r1, [r3, #4]
   2345a:	3308      	adds	r3, #8
   2345c:	c403      	stmia	r4!, {r0, r1}
   2345e:	42b3      	cmp	r3, r6
   23460:	4622      	mov	r2, r4
   23462:	d1f7      	bne.n	23454 <load_model+0x18>
   23464:	781b      	ldrb	r3, [r3, #0]
	{
		pmu_dev_ctx.write_reg(pmu_dev_ctx.handle, addr_mem, &model_data[k], 1);
		addr_mem++;
	}
	*/
	WriteMulti(model_data, sizeof(model_data));
   23466:	2141      	movs	r1, #65	; 0x41
	u8_t RCOMP_data[33] = // 1+16*2, first byte is the memory address
   23468:	7023      	strb	r3, [r4, #0]
	WriteMulti(model_data, sizeof(model_data));
   2346a:	a809      	add	r0, sp, #36	; 0x24
   2346c:	f7ff ff2c 	bl	232c8 <WriteMulti>
		pmu_dev_ctx.write_reg(pmu_dev_ctx.handle, addr_mem, databuf, 2);
		addr_mem+2;
	}
	*/
	/* I2C STOP */
	WriteMulti(RCOMP_data, sizeof(RCOMP_data));
   23470:	2121      	movs	r1, #33	; 0x21
   23472:	4628      	mov	r0, r5
   23474:	f7ff ff28 	bl	232c8 <WriteMulti>
}
   23478:	b01a      	add	sp, #104	; 0x68
   2347a:	bd70      	pop	{r4, r5, r6, pc}
   2347c:	0003b070 	.word	0x0003b070
   23480:	0003b0b1 	.word	0x0003b0b1

00023484 <verify_model_is_correct>:

bool verify_model_is_correct(void)
{
   23484:	b510      	push	{r4, lr}
	
	/******************************************************************************
	Step 7. Write OCV
	This OCV should produce the SOC_Check values in Step 9
	*/
	WriteWord(0x0E, INI_OCVTEST_HIGH_BYTE, INI_OCVTEST_LOW_BYTE);
   23486:	2250      	movs	r2, #80	; 0x50
   23488:	21e1      	movs	r1, #225	; 0xe1
   2348a:	200e      	movs	r0, #14
   2348c:	f7ff fefe 	bl	2328c <WriteWord>
	/******************************************************************************
	Step 7.1 Disable Hibernate (MAX17048/49 only)
	The IC updates SOC less frequently in hibernate mode, so make sure it
	is not hibernating
	*/
	WriteWord(0x0A, 0, 0);
   23490:	2200      	movs	r2, #0
   23492:	200a      	movs	r0, #10
   23494:	4611      	mov	r1, r2
   23496:	f7ff fef9 	bl	2328c <WriteWord>
	Step 7.2. Lock Model Access (MAX17048/49/58/59 only)
	To allow the ModelGauge algorithm to run in MAX17048/49/58/59 only, the model
	must
	be locked. This is harmless but unnecessary for MAX17040/1/3/4
	*/
	WriteWord(0x3E, 0, 0);
   2349a:	2200      	movs	r2, #0
	register is verified to be within a specified range to verify that the
	model was loaded correctly. This value is not an indication of the state of
	the actual battery. Please note that INI_SOCCheckA and INI_SOCCheckB has a
	fixed LSB of 1/256% for both 18 and 19 bit models.
	*/
	ReadWord(0x04, &SOC_1, &SOC_2);
   2349c:	4c0a      	ldr	r4, [pc, #40]	; (234c8 <verify_model_is_correct+0x44>)
	WriteWord(0x3E, 0, 0);
   2349e:	4611      	mov	r1, r2
   234a0:	203e      	movs	r0, #62	; 0x3e
   234a2:	f7ff fef3 	bl	2328c <WriteWord>
    k_sleep(K_MSEC(period));
   234a6:	f44f 7096 	mov.w	r0, #300	; 0x12c
   234aa:	f014 f8da 	bl	37662 <k_sleep>
	ReadWord(0x04, &SOC_1, &SOC_2);
   234ae:	4a07      	ldr	r2, [pc, #28]	; (234cc <verify_model_is_correct+0x48>)
   234b0:	4621      	mov	r1, r4
   234b2:	2004      	movs	r0, #4
   234b4:	f7ff feb2 	bl	2321c <ReadWord>
	if(SOC_1 >= SOCCHECKA && SOC_1 <= SOCCHECKB)
   234b8:	7820      	ldrb	r0, [r4, #0]
   234ba:	3872      	subs	r0, #114	; 0x72
	else
	{
		// model was NOT loaded successfully
		return false;
	}
}
   234bc:	2802      	cmp	r0, #2
   234be:	bf8c      	ite	hi
   234c0:	2000      	movhi	r0, #0
   234c2:	2001      	movls	r0, #1
   234c4:	bd10      	pop	{r4, pc}
   234c6:	bf00      	nop
   234c8:	20024ce8 	.word	0x20024ce8
   234cc:	20024ce9 	.word	0x20024ce9

000234d0 <cleanup_model_load>:

void cleanup_model_load(void)
{
   234d0:	b508      	push	{r3, lr}
	/******************************************************************************
	Step 9.1. Unlock Model Access (MAX17048/49/58/59 only)
	To write OCV, MAX17048/49/58/59 requires model access to be unlocked.
	*/
	WriteWord(0x3E, 0x4A, 0x57);
   234d2:	2257      	movs	r2, #87	; 0x57
   234d4:	214a      	movs	r1, #74	; 0x4a
   234d6:	203e      	movs	r0, #62	; 0x3e
   234d8:	f7ff fed8 	bl	2328c <WriteWord>
	/******************************************************************************
	Step 10. Restore CONFIG and OCV
	It is up to the application how to configure the LSB of the CONFIG
	register; any byte value is valid.
	*/
	WriteWord(0x0C, RCOMP0, 0x5C);
   234dc:	225c      	movs	r2, #92	; 0x5c
   234de:	2116      	movs	r1, #22
   234e0:	200c      	movs	r0, #12
   234e2:	f7ff fed3 	bl	2328c <WriteWord>
	WriteWord(0x0E, original_OCV_1, original_OCV_2);
   234e6:	4b0b      	ldr	r3, [pc, #44]	; (23514 <cleanup_model_load+0x44>)
   234e8:	200e      	movs	r0, #14
   234ea:	781a      	ldrb	r2, [r3, #0]
   234ec:	4b0a      	ldr	r3, [pc, #40]	; (23518 <cleanup_model_load+0x48>)
   234ee:	7819      	ldrb	r1, [r3, #0]
   234f0:	f7ff fecc 	bl	2328c <WriteWord>
	Step 10.1 Restore Hibernate (MAX17048/49 only)
	Remember to restore your desired Hibernate configuration after the
	model was verified.
	*/
	// Restore your desired value of HIBRT
	WriteWord(0x0A, 0x80, 0x30);
   234f4:	2230      	movs	r2, #48	; 0x30
   234f6:	2180      	movs	r1, #128	; 0x80
   234f8:	200a      	movs	r0, #10
   234fa:	f7ff fec7 	bl	2328c <WriteWord>
	
	/******************************************************************************
	Step 11. Lock Model Access
	*/
	WriteWord(0x3E, 0x00, 0x00);
   234fe:	2200      	movs	r2, #0
   23500:	203e      	movs	r0, #62	; 0x3e
   23502:	4611      	mov	r1, r2
   23504:	f7ff fec2 	bl	2328c <WriteWord>
	*/
	//if(SOC < SOCCHECKA)
	//	model was loaded successfully
	//else
	//	goto step C1 and reload model
}
   23508:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    k_sleep(K_MSEC(period));
   2350c:	f44f 7096 	mov.w	r0, #300	; 0x12c
   23510:	f014 b8a7 	b.w	37662 <k_sleep>
   23514:	20024d04 	.word	0x20024d04
   23518:	20024d03 	.word	0x20024d03

0002351c <MAX20353_Init>:
{
   2351c:	b510      	push	{r4, lr}
	MAX20353_GetDeviceID(&HardwareID);
   2351e:	4c0f      	ldr	r4, [pc, #60]	; (2355c <MAX20353_Init+0x40>)
   23520:	4620      	mov	r0, r4
   23522:	f014 f8d5 	bl	376d0 <MAX20353_GetDeviceID>
	if(HardwareID != MAX20353_HARDWARE_ID)
   23526:	7823      	ldrb	r3, [r4, #0]
   23528:	2b03      	cmp	r3, #3
   2352a:	d115      	bne.n	23558 <MAX20353_Init+0x3c>
	MAX20353_Buck1Config();	//1.8v  350mA
   2352c:	f7ff fd66 	bl	22ffc <MAX20353_Buck1Config>
	MAX20353_Buck2Config(); //3.3V  350mA
   23530:	f7ff fd78 	bl	23024 <MAX20353_Buck2Config>
	MAX20353_LDO1Config();	//1.8v 50mA
   23534:	f7ff fd88 	bl	23048 <MAX20353_LDO1Config>
	MAX20353_LDO2Config();	//2.8V 100mA
   23538:	f7ff fd96 	bl	23068 <MAX20353_LDO2Config>
	MAX20353_BoostConfig(); //5V buck23.3VPPG
   2353c:	f7ff fda4 	bl	23088 <MAX20353_BoostConfig>
	MAX20353_ChargePumpConfig();
   23540:	f7ff fdb4 	bl	230ac <MAX20353_ChargePumpConfig>
	MAX20353_BuckBoostConfig();
   23544:	f7ff fdc2 	bl	230cc <MAX20353_BuckBoostConfig>
	MAX20303_HapticConfigDCMotor();
   23548:	f7ff fd08 	bl	22f5c <MAX20303_HapticConfigDCMotor>
	MAX20353_SOCInit();
   2354c:	f014 f8e2 	bl	37714 <MAX20353_SOCInit>
}
   23550:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	MAX20353_ChargerInit();
   23554:	f7ff be32 	b.w	231bc <MAX20353_ChargerInit>
}
   23558:	bd10      	pop	{r4, pc}
   2355a:	bf00      	nop
   2355c:	20024ce4 	.word	0x20024ce4

00023560 <crc8_ccitt>:
	0x00, 0x07, 0x0e, 0x09, 0x1c, 0x1b, 0x12, 0x15,
	0x38, 0x3f, 0x36, 0x31, 0x24, 0x23, 0x2a, 0x2d
};

u8_t crc8_ccitt(u8_t val, const void *buf, size_t cnt)
{
   23560:	b510      	push	{r4, lr}
	int i;
	const u8_t *p = buf;

	for (i = 0; i < cnt; i++) {
		val ^= p[i];
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
   23562:	4c09      	ldr	r4, [pc, #36]	; (23588 <crc8_ccitt+0x28>)
   23564:	440a      	add	r2, r1
	for (i = 0; i < cnt; i++) {
   23566:	4291      	cmp	r1, r2
   23568:	d100      	bne.n	2356c <crc8_ccitt+0xc>
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
	}
	return val;
}
   2356a:	bd10      	pop	{r4, pc}
		val ^= p[i];
   2356c:	f811 3b01 	ldrb.w	r3, [r1], #1
   23570:	4043      	eors	r3, r0
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
   23572:	0918      	lsrs	r0, r3, #4
   23574:	5c20      	ldrb	r0, [r4, r0]
   23576:	ea80 1003 	eor.w	r0, r0, r3, lsl #4
   2357a:	b2c3      	uxtb	r3, r0
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
   2357c:	0918      	lsrs	r0, r3, #4
   2357e:	5c20      	ldrb	r0, [r4, r0]
   23580:	ea80 1003 	eor.w	r0, r0, r3, lsl #4
   23584:	b2c0      	uxtb	r0, r0
   23586:	e7ee      	b.n	23566 <crc8_ccitt+0x6>
   23588:	0003cc1c 	.word	0x0003cc1c

0002358c <z_sys_mem_pool_block_free>:
	return 0;
}

void z_sys_mem_pool_block_free(struct sys_mem_pool_base *p, u32_t level,
			      u32_t block)
{
   2358c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   23590:	b085      	sub	sp, #20
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   23592:	7a83      	ldrb	r3, [r0, #10]
{
   23594:	af00      	add	r7, sp, #0
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   23596:	009b      	lsls	r3, r3, #2
   23598:	3307      	adds	r3, #7
   2359a:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
   2359e:	ebad 0d03 	sub.w	sp, sp, r3
   235a2:	46eb      	mov	fp, sp
	 * to avoid having to store it in precious RAM bytes.
	 * Overhead here is somewhat higher because block_free()
	 * doesn't inherently need to traverse all the larger
	 * sublevels.
	 */
	lsizes[0] = p->max_sz;
   235a4:	6843      	ldr	r3, [r0, #4]
{
   235a6:	4606      	mov	r6, r0
	lsizes[0] = p->max_sz;
   235a8:	465c      	mov	r4, fp
	for (i = 1; i <= level; i++) {
   235aa:	2001      	movs	r0, #1
	lsizes[0] = p->max_sz;
   235ac:	f8cb 3000 	str.w	r3, [fp]
	for (i = 1; i <= level; i++) {
   235b0:	4281      	cmp	r1, r0
   235b2:	d222      	bcs.n	235fa <z_sys_mem_pool_block_free+0x6e>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   235b4:	7c30      	ldrb	r0, [r6, #16]
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
	}

	block_free(p, level, lsizes, block);
   235b6:	4688      	mov	r8, r1
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   235b8:	f010 0001 	ands.w	r0, r0, #1
	block_free(p, level, lsizes, block);
   235bc:	4615      	mov	r5, r2
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   235be:	d001      	beq.n	235c4 <z_sys_mem_pool_block_free+0x38>
   235c0:	f014 f8f6 	bl	377b0 <pool_irq_lock.isra.2.part.3>
	unsigned int key = pool_irq_lock(p);
   235c4:	4604      	mov	r4, r0
	while (level >= 0) {
   235c6:	f1b8 0f00 	cmp.w	r8, #0
   235ca:	da1e      	bge.n	2360a <z_sys_mem_pool_block_free+0x7e>
	__ASSERT(0, "out of levels");
   235cc:	23bc      	movs	r3, #188	; 0xbc
   235ce:	4a50      	ldr	r2, [pc, #320]	; (23710 <z_sys_mem_pool_block_free+0x184>)
   235d0:	4950      	ldr	r1, [pc, #320]	; (23714 <z_sys_mem_pool_block_free+0x188>)
   235d2:	4851      	ldr	r0, [pc, #324]	; (23718 <z_sys_mem_pool_block_free+0x18c>)
   235d4:	f014 fb74 	bl	37cc0 <printk>
   235d8:	4850      	ldr	r0, [pc, #320]	; (2371c <z_sys_mem_pool_block_free+0x190>)
   235da:	f014 fb71 	bl	37cc0 <printk>
   235de:	21bc      	movs	r1, #188	; 0xbc
   235e0:	484b      	ldr	r0, [pc, #300]	; (23710 <z_sys_mem_pool_block_free+0x184>)
   235e2:	f014 fbb3 	bl	37d4c <assert_post_action>
	return -1;
   235e6:	f04f 34ff 	mov.w	r4, #4294967295
	pool_irq_unlock(p, key);
   235ea:	4621      	mov	r1, r4
   235ec:	7c30      	ldrb	r0, [r6, #16]
   235ee:	f014 f8e8 	bl	377c2 <pool_irq_unlock.isra.4>
}
   235f2:	3714      	adds	r7, #20
   235f4:	46bd      	mov	sp, r7
   235f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
   235fa:	6823      	ldr	r3, [r4, #0]
	for (i = 1; i <= level; i++) {
   235fc:	3001      	adds	r0, #1
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
   235fe:	089b      	lsrs	r3, r3, #2
   23600:	f023 0303 	bic.w	r3, r3, #3
   23604:	f844 3f04 	str.w	r3, [r4, #4]!
   23608:	e7d2      	b.n	235b0 <z_sys_mem_pool_block_free+0x24>
		int i, lsz = lsizes[level];
   2360a:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
	int bit = get_bit_ptr(p, level, bn, &word);
   2360e:	462a      	mov	r2, r5
	return (u8_t *)p->buf + lsz * block;
   23610:	fb03 fa05 	mul.w	sl, r3, r5
		int i, lsz = lsizes[level];
   23614:	607b      	str	r3, [r7, #4]
	return (u8_t *)p->buf + lsz * block;
   23616:	6833      	ldr	r3, [r6, #0]
	int bit = get_bit_ptr(p, level, bn, &word);
   23618:	4641      	mov	r1, r8
	return (u8_t *)p->buf + lsz * block;
   2361a:	603b      	str	r3, [r7, #0]
   2361c:	eb03 090a 	add.w	r9, r3, sl
	int bit = get_bit_ptr(p, level, bn, &word);
   23620:	4630      	mov	r0, r6
   23622:	f107 030c 	add.w	r3, r7, #12
   23626:	f014 f8ac 	bl	37782 <get_bit_ptr>
	return (*word >> bit) & 1;
   2362a:	68fb      	ldr	r3, [r7, #12]
   2362c:	681b      	ldr	r3, [r3, #0]
   2362e:	fa23 f000 	lsr.w	r0, r3, r0
		__ASSERT(alloc_bit_is_set(p, level, bn),
   23632:	07c3      	lsls	r3, r0, #31
   23634:	d40d      	bmi.n	23652 <z_sys_mem_pool_block_free+0xc6>
   23636:	23a3      	movs	r3, #163	; 0xa3
   23638:	4a35      	ldr	r2, [pc, #212]	; (23710 <z_sys_mem_pool_block_free+0x184>)
   2363a:	4939      	ldr	r1, [pc, #228]	; (23720 <z_sys_mem_pool_block_free+0x194>)
   2363c:	4836      	ldr	r0, [pc, #216]	; (23718 <z_sys_mem_pool_block_free+0x18c>)
   2363e:	f014 fb3f 	bl	37cc0 <printk>
   23642:	4649      	mov	r1, r9
   23644:	4837      	ldr	r0, [pc, #220]	; (23724 <z_sys_mem_pool_block_free+0x198>)
   23646:	f014 fb3b 	bl	37cc0 <printk>
   2364a:	21a3      	movs	r1, #163	; 0xa3
   2364c:	4830      	ldr	r0, [pc, #192]	; (23710 <z_sys_mem_pool_block_free+0x184>)
   2364e:	f014 fb7d 	bl	37d4c <assert_post_action>
	int bit = get_bit_ptr(p, level, bn, &word);
   23652:	f107 030c 	add.w	r3, r7, #12
   23656:	462a      	mov	r2, r5
   23658:	4641      	mov	r1, r8
   2365a:	4630      	mov	r0, r6
   2365c:	f014 f891 	bl	37782 <get_bit_ptr>
	*word &= ~(1<<bit);
   23660:	2301      	movs	r3, #1
   23662:	68fa      	ldr	r2, [r7, #12]
   23664:	fa03 f000 	lsl.w	r0, r3, r0
   23668:	6813      	ldr	r3, [r2, #0]
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
   2366a:	6839      	ldr	r1, [r7, #0]
   2366c:	ea23 0300 	bic.w	r3, r3, r0
   23670:	6013      	str	r3, [r2, #0]
		sys_dlist_append(&p->levels[level].free_list, block);
   23672:	230c      	movs	r3, #12
   23674:	68f2      	ldr	r2, [r6, #12]
   23676:	fb03 2308 	mla	r3, r3, r8, r2
   2367a:	1d1a      	adds	r2, r3, #4
   2367c:	f841 200a 	str.w	r2, [r1, sl]
	node->prev = list->tail;
   23680:	689a      	ldr	r2, [r3, #8]
		pool_irq_unlock(p, key);
   23682:	4621      	mov	r1, r4
   23684:	f8c9 2004 	str.w	r2, [r9, #4]

	list->tail->next = node;
   23688:	689a      	ldr	r2, [r3, #8]
   2368a:	f8c2 9000 	str.w	r9, [r2]
	list->tail = node;
   2368e:	f8c3 9008 	str.w	r9, [r3, #8]
   23692:	7c30      	ldrb	r0, [r6, #16]
   23694:	f014 f895 	bl	377c2 <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   23698:	7c30      	ldrb	r0, [r6, #16]
   2369a:	f010 0001 	ands.w	r0, r0, #1
   2369e:	d001      	beq.n	236a4 <z_sys_mem_pool_block_free+0x118>
   236a0:	f014 f886 	bl	377b0 <pool_irq_lock.isra.2.part.3>
		key = pool_irq_lock(p);
   236a4:	4604      	mov	r4, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
   236a6:	f1b8 0f00 	cmp.w	r8, #0
   236aa:	d09e      	beq.n	235ea <z_sys_mem_pool_block_free+0x5e>
	int bit = get_bit_ptr(p, level, bn, &word);
   236ac:	f107 030c 	add.w	r3, r7, #12
   236b0:	462a      	mov	r2, r5
   236b2:	4641      	mov	r1, r8
   236b4:	4630      	mov	r0, r6
   236b6:	f014 f864 	bl	37782 <get_bit_ptr>
	return (*word >> (4*(bit / 4))) & 0xf;
   236ba:	68fb      	ldr	r3, [r7, #12]
   236bc:	2800      	cmp	r0, #0
   236be:	bfb8      	it	lt
   236c0:	3003      	addlt	r0, #3
   236c2:	681b      	ldr	r3, [r3, #0]
   236c4:	f020 0003 	bic.w	r0, r0, #3
   236c8:	fa23 f000 	lsr.w	r0, r3, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
   236cc:	f010 000f 	ands.w	r0, r0, #15
   236d0:	d18b      	bne.n	235ea <z_sys_mem_pool_block_free+0x5e>
	node->next = NULL;
   236d2:	4684      	mov	ip, r0
			int b = (bn & ~3) + i;
   236d4:	f025 0a03 	bic.w	sl, r5, #3
	return (u8_t *)p->buf + lsz * block;
   236d8:	687a      	ldr	r2, [r7, #4]
			int b = (bn & ~3) + i;
   236da:	eb0a 0300 	add.w	r3, sl, r0
	return (u8_t *)p->buf + lsz * block;
   236de:	4353      	muls	r3, r2
   236e0:	6832      	ldr	r2, [r6, #0]
		for (i = 0; i < 4; i++) {
   236e2:	3001      	adds	r0, #1
	return (u8_t *)p->buf + lsz * block;
   236e4:	18d1      	adds	r1, r2, r3
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
   236e6:	f8d1 9004 	ldr.w	r9, [r1, #4]
   236ea:	f852 e003 	ldr.w	lr, [r2, r3]
		for (i = 0; i < 4; i++) {
   236ee:	2804      	cmp	r0, #4
   236f0:	f8c9 e000 	str.w	lr, [r9]
	node->next->prev = node->prev;
   236f4:	f8ce 9004 	str.w	r9, [lr, #4]
	node->next = NULL;
   236f8:	f842 c003 	str.w	ip, [r2, r3]
	node->prev = NULL;
   236fc:	f8c1 c004 	str.w	ip, [r1, #4]
   23700:	d1ea      	bne.n	236d8 <z_sys_mem_pool_block_free+0x14c>
		bn = bn / 4;
   23702:	2d00      	cmp	r5, #0
   23704:	bfb8      	it	lt
   23706:	3503      	addlt	r5, #3
		level = level - 1;
   23708:	f108 38ff 	add.w	r8, r8, #4294967295
		bn = bn / 4;
   2370c:	10ad      	asrs	r5, r5, #2
   2370e:	e75a      	b.n	235c6 <z_sys_mem_pool_block_free+0x3a>
   23710:	0003cc2c 	.word	0x0003cc2c
   23714:	0003f10e 	.word	0x0003f10e
   23718:	0003baac 	.word	0x0003baac
   2371c:	0003cc94 	.word	0x0003cc94
   23720:	0003cc50 	.word	0x0003cc50
   23724:	0003cc6f 	.word	0x0003cc6f

00023728 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
   23728:	680b      	ldr	r3, [r1, #0]
   2372a:	3301      	adds	r3, #1
   2372c:	600b      	str	r3, [r1, #0]
	return _char_out(c);
   2372e:	4b01      	ldr	r3, [pc, #4]	; (23734 <char_out+0xc>)
   23730:	681b      	ldr	r3, [r3, #0]
   23732:	4718      	bx	r3
   23734:	2002af24 	.word	0x2002af24

00023738 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
   23738:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2373c:	b085      	sub	sp, #20
   2373e:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   23740:	469b      	mov	fp, r3
   23742:	2c01      	cmp	r4, #1
   23744:	bfb8      	it	lt
   23746:	2401      	movlt	r4, #1
   23748:	2b01      	cmp	r3, #1
   2374a:	bf0c      	ite	eq
   2374c:	2330      	moveq	r3, #48	; 0x30
   2374e:	2320      	movne	r3, #32
   23750:	4616      	mov	r6, r2
   23752:	4682      	mov	sl, r0
   23754:	4688      	mov	r8, r1
   23756:	2501      	movs	r5, #1
   23758:	270a      	movs	r7, #10
   2375a:	2200      	movs	r2, #0
   2375c:	f8df 906c 	ldr.w	r9, [pc, #108]	; 237cc <_printk_dec_ulong+0x94>
   23760:	9302      	str	r3, [sp, #8]
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
   23762:	fbb6 f3f9 	udiv	r3, r6, r9
   23766:	9301      	str	r3, [sp, #4]
   23768:	b90a      	cbnz	r2, 2376e <_printk_dec_ulong+0x36>
   2376a:	45b1      	cmp	r9, r6
   2376c:	d81c      	bhi.n	237a8 <_printk_dec_ulong+0x70>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
   2376e:	9b01      	ldr	r3, [sp, #4]
   23770:	4641      	mov	r1, r8
   23772:	f103 0030 	add.w	r0, r3, #48	; 0x30
   23776:	47d0      	blx	sl
			found_largest_digit = 1;
   23778:	2201      	movs	r2, #1
			digits++;
   2377a:	3501      	adds	r5, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= pos;
   2377c:	9b01      	ldr	r3, [sp, #4]
		remaining--;
   2377e:	3f01      	subs	r7, #1
		remainder %= pos;
   23780:	fb09 6613 	mls	r6, r9, r3, r6
		pos /= 10;
   23784:	230a      	movs	r3, #10
	while (pos >= 10) {
   23786:	2f01      	cmp	r7, #1
		pos /= 10;
   23788:	fbb9 f9f3 	udiv	r9, r9, r3
	while (pos >= 10) {
   2378c:	d1e9      	bne.n	23762 <_printk_dec_ulong+0x2a>
	}
	out((int)(remainder + 48), ctx);
   2378e:	4641      	mov	r1, r8
   23790:	f106 0030 	add.w	r0, r6, #48	; 0x30
   23794:	47d0      	blx	sl

	if (padding == PAD_SPACE_AFTER) {
   23796:	f1bb 0f03 	cmp.w	fp, #3
   2379a:	d102      	bne.n	237a2 <_printk_dec_ulong+0x6a>
		remaining = min_width - digits;
   2379c:	1b64      	subs	r4, r4, r5
		while (remaining-- > 0) {
   2379e:	2c00      	cmp	r4, #0
   237a0:	dc0e      	bgt.n	237c0 <_printk_dec_ulong+0x88>
			out(' ', ctx);
		}
	}
}
   237a2:	b005      	add	sp, #20
   237a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
   237a8:	42bc      	cmp	r4, r7
   237aa:	dbe7      	blt.n	2377c <_printk_dec_ulong+0x44>
				&& padding < PAD_SPACE_AFTER) {
   237ac:	f1bb 0f02 	cmp.w	fp, #2
   237b0:	d8e4      	bhi.n	2377c <_printk_dec_ulong+0x44>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
   237b2:	4641      	mov	r1, r8
   237b4:	9802      	ldr	r0, [sp, #8]
   237b6:	9203      	str	r2, [sp, #12]
			digits++;
   237b8:	3501      	adds	r5, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
   237ba:	47d0      	blx	sl
			digits++;
   237bc:	9a03      	ldr	r2, [sp, #12]
   237be:	e7dd      	b.n	2377c <_printk_dec_ulong+0x44>
			out(' ', ctx);
   237c0:	4641      	mov	r1, r8
   237c2:	2020      	movs	r0, #32
   237c4:	47d0      	blx	sl
   237c6:	3c01      	subs	r4, #1
   237c8:	e7e9      	b.n	2379e <_printk_dec_ulong+0x66>
   237ca:	bf00      	nop
   237cc:	3b9aca00 	.word	0x3b9aca00

000237d0 <vprintk>:
	struct out_context ctx = { 0 };
   237d0:	2300      	movs	r3, #0
{
   237d2:	b507      	push	{r0, r1, r2, lr}
	z_vprintk(char_out, &ctx, fmt, ap);
   237d4:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
   237d6:	9301      	str	r3, [sp, #4]
	z_vprintk(char_out, &ctx, fmt, ap);
   237d8:	4803      	ldr	r0, [pc, #12]	; (237e8 <vprintk+0x18>)
   237da:	460b      	mov	r3, r1
   237dc:	a901      	add	r1, sp, #4
   237de:	f014 f8ff 	bl	379e0 <z_vprintk>
}
   237e2:	b003      	add	sp, #12
   237e4:	f85d fb04 	ldr.w	pc, [sp], #4
   237e8:	00023729 	.word	0x00023729

000237ec <nordicsemi_nrf91_init>:
	__asm__ volatile(
   237ec:	f04f 0220 	mov.w	r2, #32
   237f0:	f3ef 8311 	mrs	r3, BASEPRI
   237f4:	f382 8811 	msr	BASEPRI, r2
   237f8:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
   237fc:	2101      	movs	r1, #1
   237fe:	4a04      	ldr	r2, [pc, #16]	; (23810 <nordicsemi_nrf91_init+0x24>)
   23800:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
   23804:	f383 8811 	msr	BASEPRI, r3
   23808:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
   2380c:	2000      	movs	r0, #0
   2380e:	4770      	bx	lr
   23810:	40039000 	.word	0x40039000

00023814 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   23814:	b120      	cbz	r0, 23820 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   23816:	4b03      	ldr	r3, [pc, #12]	; (23824 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
   23818:	0180      	lsls	r0, r0, #6
   2381a:	f043 0301 	orr.w	r3, r3, #1
   2381e:	4718      	bx	r3

void arch_busy_wait(u32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
   23820:	4770      	bx	lr
   23822:	bf00      	nop
   23824:	0003b0e0 	.word	0x0003b0e0

00023828 <log_generic>:
	if (_is_user_context()) {
		log_generic_from_user(src_level, fmt, ap);
	} else  if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) &&
	    (!IS_ENABLED(CONFIG_LOG_FRONTEND))) {
		struct log_backend const *backend;
		u32_t timestamp = timestamp_func();
   23828:	4b13      	ldr	r3, [pc, #76]	; (23878 <log_generic+0x50>)
{
   2382a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		u32_t timestamp = timestamp_func();
   2382e:	681b      	ldr	r3, [r3, #0]
{
   23830:	4680      	mov	r8, r0
   23832:	4689      	mov	r9, r1
   23834:	4692      	mov	sl, r2
		u32_t timestamp = timestamp_func();
   23836:	4798      	blx	r3

		for (int i = 0; i < log_backend_count_get(); i++) {
   23838:	2600      	movs	r6, #0
		u32_t timestamp = timestamp_func();
   2383a:	4607      	mov	r7, r0
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
   2383c:	4c0f      	ldr	r4, [pc, #60]	; (2387c <log_generic+0x54>)
   2383e:	4d10      	ldr	r5, [pc, #64]	; (23880 <log_generic+0x58>)
   23840:	1b2d      	subs	r5, r5, r4
   23842:	112d      	asrs	r5, r5, #4
		for (int i = 0; i < log_backend_count_get(); i++) {
   23844:	42ae      	cmp	r6, r5
   23846:	db02      	blt.n	2384e <log_generic+0x26>
			args[i] = va_arg(ap, log_arg_t);
		}

		log_n(fmt, args, nargs, src_level);
	}
}
   23848:	b003      	add	sp, #12
   2384a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (log_backend_is_active(backend)) {
   2384e:	4620      	mov	r0, r4
   23850:	f014 fa86 	bl	37d60 <log_backend_is_active>
   23854:	b160      	cbz	r0, 23870 <log_generic+0x48>
	if (backend->api->put_sync_string) {
   23856:	6823      	ldr	r3, [r4, #0]
   23858:	f8d3 b004 	ldr.w	fp, [r3, #4]
   2385c:	f1bb 0f00 	cmp.w	fp, #0
   23860:	d006      	beq.n	23870 <log_generic+0x48>
		backend->api->put_sync_string(backend, src_level,
   23862:	f8cd a000 	str.w	sl, [sp]
   23866:	464b      	mov	r3, r9
   23868:	463a      	mov	r2, r7
   2386a:	4641      	mov	r1, r8
   2386c:	4620      	mov	r0, r4
   2386e:	47d8      	blx	fp
		for (int i = 0; i < log_backend_count_get(); i++) {
   23870:	3601      	adds	r6, #1
   23872:	3410      	adds	r4, #16
   23874:	e7e6      	b.n	23844 <log_generic+0x1c>
   23876:	bf00      	nop
   23878:	2002af28 	.word	0x2002af28
   2387c:	0003af10 	.word	0x0003af10
   23880:	0003af20 	.word	0x0003af20

00023884 <log_core_init>:
	/* Set default timestamp. */
	if (sys_clock_hw_cycles_per_sec() > 1000000) {
		timestamp_func = k_uptime_get_32;
		freq = 1000;
	} else {
		timestamp_func = k_cycle_get_32_wrapper;
   23884:	4b03      	ldr	r3, [pc, #12]	; (23894 <log_core_init+0x10>)
   23886:	4a04      	ldr	r2, [pc, #16]	; (23898 <log_core_init+0x14>)
		freq = sys_clock_hw_cycles_per_sec();
	}

	log_output_timestamp_freq_set(freq);
   23888:	f44f 4000 	mov.w	r0, #32768	; 0x8000
		timestamp_func = k_cycle_get_32_wrapper;
   2388c:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
   2388e:	f000 ba35 	b.w	23cfc <log_output_timestamp_freq_set>
   23892:	bf00      	nop
   23894:	2002af28 	.word	0x2002af28
   23898:	00037d67 	.word	0x00037d67

0002389c <log_source_name_get>:
   2389c:	4a04      	ldr	r2, [pc, #16]	; (238b0 <log_source_name_get+0x14>)
   2389e:	4b05      	ldr	r3, [pc, #20]	; (238b4 <log_source_name_get+0x18>)
   238a0:	1a9b      	subs	r3, r3, r2
	return log_sources_count();
}

const char *log_source_name_get(u32_t domain_id, u32_t src_id)
{
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
   238a2:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
   238a6:	bf34      	ite	cc
   238a8:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
   238ac:	2000      	movcs	r0, #0
}
   238ae:	4770      	bx	lr
   238b0:	0003ade0 	.word	0x0003ade0
   238b4:	0003af10 	.word	0x0003af10

000238b8 <log_backend_enable>:
}

void log_backend_enable(struct log_backend const *const backend,
			void *ctx,
			u32_t level)
{
   238b8:	b570      	push	{r4, r5, r6, lr}
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	u32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
   238ba:	4c10      	ldr	r4, [pc, #64]	; (238fc <log_backend_enable+0x44>)
{
   238bc:	4605      	mov	r5, r0
	id += backend - log_backend_get(0);
   238be:	1b04      	subs	r4, r0, r4
   238c0:	1124      	asrs	r4, r4, #4
   238c2:	3401      	adds	r4, #1
{
   238c4:	460e      	mov	r6, r1

	log_backend_id_set(backend, id);
   238c6:	b2e4      	uxtb	r4, r4
	__ASSERT_NO_MSG(backend != NULL);
   238c8:	b948      	cbnz	r0, 238de <log_backend_enable+0x26>
   238ca:	490d      	ldr	r1, [pc, #52]	; (23900 <log_backend_enable+0x48>)
   238cc:	480d      	ldr	r0, [pc, #52]	; (23904 <log_backend_enable+0x4c>)
   238ce:	23c0      	movs	r3, #192	; 0xc0
   238d0:	4a0d      	ldr	r2, [pc, #52]	; (23908 <log_backend_enable+0x50>)
   238d2:	f014 f9f5 	bl	37cc0 <printk>
   238d6:	21c0      	movs	r1, #192	; 0xc0
   238d8:	480b      	ldr	r0, [pc, #44]	; (23908 <log_backend_enable+0x50>)
   238da:	f014 fa37 	bl	37d4c <assert_post_action>
static inline void log_backend_activate(const struct log_backend *const backend,
					void *ctx)
{
	__ASSERT_NO_MSG(backend != NULL);
	backend->cb->ctx = ctx;
	backend->cb->active = true;
   238de:	2201      	movs	r2, #1
	backend->cb->id = id;
   238e0:	686b      	ldr	r3, [r5, #4]
   238e2:	711c      	strb	r4, [r3, #4]
	log_backend_activate(backend, ctx);

	/* Wakeup logger thread after attaching first backend. It might be
	 * blocked with log messages pending.
	 */
	if (!backend_attached) {
   238e4:	4c09      	ldr	r4, [pc, #36]	; (2390c <log_backend_enable+0x54>)
	backend->cb->active = true;
   238e6:	715a      	strb	r2, [r3, #5]
   238e8:	7822      	ldrb	r2, [r4, #0]
	backend->cb->ctx = ctx;
   238ea:	601e      	str	r6, [r3, #0]
   238ec:	b912      	cbnz	r2, 238f4 <log_backend_enable+0x3c>
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
   238ee:	4808      	ldr	r0, [pc, #32]	; (23910 <log_backend_enable+0x58>)
   238f0:	f010 feac 	bl	3464c <z_impl_k_sem_give>
		k_sem_give(&log_process_thread_sem);
	}

	backend_attached = true;
   238f4:	2301      	movs	r3, #1
   238f6:	7023      	strb	r3, [r4, #0]
}
   238f8:	bd70      	pop	{r4, r5, r6, pc}
   238fa:	bf00      	nop
   238fc:	0003af10 	.word	0x0003af10
   23900:	0003cce2 	.word	0x0003cce2
   23904:	0003baac 	.word	0x0003baac
   23908:	0003ccb1 	.word	0x0003ccb1
   2390c:	20024d06 	.word	0x20024d06
   23910:	2002cbd0 	.word	0x2002cbd0

00023914 <log_init>:
{
   23914:	b570      	push	{r4, r5, r6, lr}
	return __log_backends_end - __log_backends_start;
   23916:	4b13      	ldr	r3, [pc, #76]	; (23964 <log_init+0x50>)
   23918:	4c13      	ldr	r4, [pc, #76]	; (23968 <log_init+0x54>)
   2391a:	1b1b      	subs	r3, r3, r4
	assert(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
   2391c:	2b90      	cmp	r3, #144	; 0x90
   2391e:	dd06      	ble.n	2392e <log_init+0x1a>
   23920:	4b12      	ldr	r3, [pc, #72]	; (2396c <log_init+0x58>)
   23922:	4a13      	ldr	r2, [pc, #76]	; (23970 <log_init+0x5c>)
   23924:	f240 11ed 	movw	r1, #493	; 0x1ed
   23928:	4812      	ldr	r0, [pc, #72]	; (23974 <log_init+0x60>)
   2392a:	f012 f8d5 	bl	35ad8 <__assert_func>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   2392e:	4a12      	ldr	r2, [pc, #72]	; (23978 <log_init+0x64>)
   23930:	e8d2 6fef 	ldaex	r6, [r2]
   23934:	1c71      	adds	r1, r6, #1
   23936:	e8c2 1fe0 	stlex	r0, r1, [r2]
   2393a:	2800      	cmp	r0, #0
   2393c:	d1f8      	bne.n	23930 <log_init+0x1c>
	if (atomic_inc(&initialized) != 0) {
   2393e:	b916      	cbnz	r6, 23946 <log_init+0x32>
   23940:	111d      	asrs	r5, r3, #4
	for (i = 0; i < log_backend_count_get(); i++) {
   23942:	42ae      	cmp	r6, r5
   23944:	db00      	blt.n	23948 <log_init+0x34>
}
   23946:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
   23948:	7b23      	ldrb	r3, [r4, #12]
   2394a:	b143      	cbz	r3, 2395e <log_init+0x4a>
			if (backend->api->init != NULL) {
   2394c:	6823      	ldr	r3, [r4, #0]
   2394e:	695b      	ldr	r3, [r3, #20]
   23950:	b103      	cbz	r3, 23954 <log_init+0x40>
				backend->api->init();
   23952:	4798      	blx	r3
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
   23954:	2204      	movs	r2, #4
   23956:	2100      	movs	r1, #0
   23958:	4620      	mov	r0, r4
   2395a:	f7ff ffad 	bl	238b8 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
   2395e:	3601      	adds	r6, #1
   23960:	3410      	adds	r4, #16
   23962:	e7ee      	b.n	23942 <log_init+0x2e>
   23964:	0003af20 	.word	0x0003af20
   23968:	0003af10 	.word	0x0003af10
   2396c:	0003ccf9 	.word	0x0003ccf9
   23970:	0003cca8 	.word	0x0003cca8
   23974:	0003cd30 	.word	0x0003cd30
   23978:	200204a0 	.word	0x200204a0

0002397c <z_impl_log_panic>:
{
   2397c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
   2397e:	4f0c      	ldr	r7, [pc, #48]	; (239b0 <z_impl_log_panic+0x34>)
   23980:	783d      	ldrb	r5, [r7, #0]
   23982:	b94d      	cbnz	r5, 23998 <z_impl_log_panic+0x1c>
	log_init();
   23984:	f7ff ffc6 	bl	23914 <log_init>
   23988:	4c0a      	ldr	r4, [pc, #40]	; (239b4 <z_impl_log_panic+0x38>)
   2398a:	4e0b      	ldr	r6, [pc, #44]	; (239b8 <z_impl_log_panic+0x3c>)
   2398c:	1b36      	subs	r6, r6, r4
   2398e:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   23990:	42b5      	cmp	r5, r6
   23992:	db02      	blt.n	2399a <z_impl_log_panic+0x1e>
	panic_mode = true;
   23994:	2301      	movs	r3, #1
   23996:	703b      	strb	r3, [r7, #0]
}
   23998:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (log_backend_is_active(backend)) {
   2399a:	4620      	mov	r0, r4
   2399c:	f014 f9e0 	bl	37d60 <log_backend_is_active>
   239a0:	b118      	cbz	r0, 239aa <z_impl_log_panic+0x2e>
	backend->api->panic(backend);
   239a2:	6823      	ldr	r3, [r4, #0]
   239a4:	4620      	mov	r0, r4
   239a6:	691b      	ldr	r3, [r3, #16]
   239a8:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   239aa:	3501      	adds	r5, #1
   239ac:	3410      	adds	r4, #16
   239ae:	e7ef      	b.n	23990 <z_impl_log_panic+0x14>
   239b0:	20024d07 	.word	0x20024d07
   239b4:	0003af10 	.word	0x0003af10
   239b8:	0003af20 	.word	0x0003af20

000239bc <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *log_output,
			   const char *fmt, ...)
{
   239bc:	b40e      	push	{r1, r2, r3}
   239be:	b503      	push	{r0, r1, lr}
   239c0:	ab03      	add	r3, sp, #12
   239c2:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(args, fmt);
#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, args);
#else
	z_vprintk(out_func, (void *)log_output, fmt, args);
   239c6:	4601      	mov	r1, r0
   239c8:	4804      	ldr	r0, [pc, #16]	; (239dc <print_formatted+0x20>)
	va_start(args, fmt);
   239ca:	9301      	str	r3, [sp, #4]
	z_vprintk(out_func, (void *)log_output, fmt, args);
   239cc:	f014 f808 	bl	379e0 <z_vprintk>
#endif
	va_end(args);

	return length;
}
   239d0:	2000      	movs	r0, #0
   239d2:	b002      	add	sp, #8
   239d4:	f85d eb04 	ldr.w	lr, [sp], #4
   239d8:	b003      	add	sp, #12
   239da:	4770      	bx	lr
   239dc:	00037d95 	.word	0x00037d95

000239e0 <prefix_print>:
}

static u32_t prefix_print(const struct log_output *log_output,
			 u32_t flags, bool func_on, u32_t timestamp, u8_t level,
			 u8_t domain_id, u16_t source_id)
{
   239e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
   239e4:	f011 0402 	ands.w	r4, r1, #2
{
   239e8:	b085      	sub	sp, #20
   239ea:	4606      	mov	r6, r0
   239ec:	4690      	mov	r8, r2
   239ee:	f89d 7038 	ldrb.w	r7, [sp, #56]	; 0x38
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   239f2:	f001 0901 	and.w	r9, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
   239f6:	f001 0508 	and.w	r5, r1, #8
	if (stamp) {
   239fa:	d007      	beq.n	23a0c <prefix_print+0x2c>
	if (!format) {
   239fc:	f011 0f44 	tst.w	r1, #68	; 0x44
   23a00:	d137      	bne.n	23a72 <prefix_print+0x92>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
   23a02:	461a      	mov	r2, r3
   23a04:	4932      	ldr	r1, [pc, #200]	; (23ad0 <prefix_print+0xf0>)
   23a06:	f7ff ffd9 	bl	239bc <print_formatted>
		length += timestamp_print(log_output, flags, timestamp);
   23a0a:	4604      	mov	r4, r0
	if (color) {
   23a0c:	f1b9 0f00 	cmp.w	r9, #0
   23a10:	d00a      	beq.n	23a28 <prefix_print+0x48>
		const char *color = start && (colors[level] != NULL) ?
   23a12:	4b30      	ldr	r3, [pc, #192]	; (23ad4 <prefix_print+0xf4>)
		print_formatted(log_output, "%s", color);
   23a14:	4930      	ldr	r1, [pc, #192]	; (23ad8 <prefix_print+0xf8>)
		const char *color = start && (colors[level] != NULL) ?
   23a16:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
		print_formatted(log_output, "%s", color);
   23a1a:	4b30      	ldr	r3, [pc, #192]	; (23adc <prefix_print+0xfc>)
   23a1c:	4630      	mov	r0, r6
   23a1e:	2a00      	cmp	r2, #0
   23a20:	bf08      	it	eq
   23a22:	461a      	moveq	r2, r3
   23a24:	f7ff ffca 	bl	239bc <print_formatted>
	if (level_on) {
   23a28:	b13d      	cbz	r5, 23a3a <prefix_print+0x5a>
		total += print_formatted(log_output, "<%s> ", severity[level]);
   23a2a:	4b2d      	ldr	r3, [pc, #180]	; (23ae0 <prefix_print+0x100>)
   23a2c:	492d      	ldr	r1, [pc, #180]	; (23ae4 <prefix_print+0x104>)
   23a2e:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
   23a32:	4630      	mov	r0, r6
   23a34:	f7ff ffc2 	bl	239bc <print_formatted>
   23a38:	4605      	mov	r5, r0
	total += print_formatted(log_output,
   23a3a:	f1b8 0f00 	cmp.w	r8, #0
   23a3e:	d044      	beq.n	23aca <prefix_print+0xea>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
   23a40:	2301      	movs	r3, #1
   23a42:	fa03 f707 	lsl.w	r7, r3, r7
	total += print_formatted(log_output,
   23a46:	4b28      	ldr	r3, [pc, #160]	; (23ae8 <prefix_print+0x108>)
   23a48:	f017 0f10 	tst.w	r7, #16
   23a4c:	4f27      	ldr	r7, [pc, #156]	; (23aec <prefix_print+0x10c>)
   23a4e:	bf18      	it	ne
   23a50:	461f      	movne	r7, r3
   23a52:	f8bd 1040 	ldrh.w	r1, [sp, #64]	; 0x40
   23a56:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
   23a5a:	f7ff ff1f 	bl	2389c <log_source_name_get>
   23a5e:	4639      	mov	r1, r7
   23a60:	4602      	mov	r2, r0
   23a62:	4630      	mov	r0, r6
   23a64:	f7ff ffaa 	bl	239bc <print_formatted>
   23a68:	4428      	add	r0, r5
		length += ids_print(log_output, level_on, func_on,
				    domain_id, source_id, level);
	}

	return length;
}
   23a6a:	4420      	add	r0, r4
   23a6c:	b005      	add	sp, #20
   23a6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (freq != 0U) {
   23a72:	4a1f      	ldr	r2, [pc, #124]	; (23af0 <prefix_print+0x110>)
   23a74:	6811      	ldr	r1, [r2, #0]
   23a76:	b331      	cbz	r1, 23ac6 <prefix_print+0xe6>
		timestamp /= timestamp_div;
   23a78:	4a1e      	ldr	r2, [pc, #120]	; (23af4 <prefix_print+0x114>)
   23a7a:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
   23a7e:	6814      	ldr	r4, [r2, #0]
		ms = (remainder * 1000U) / freq;
   23a80:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
		timestamp /= timestamp_div;
   23a84:	fbb3 f3f4 	udiv	r3, r3, r4
		seconds = timestamp / freq;
   23a88:	fbb3 f4f1 	udiv	r4, r3, r1
		seconds -= hours * 3600U;
   23a8c:	fbb4 f2fe 	udiv	r2, r4, lr
   23a90:	fb0e 4e12 	mls	lr, lr, r2, r4
		remainder = timestamp % freq;
   23a94:	fb01 3414 	mls	r4, r1, r4, r3
		ms = (remainder * 1000U) / freq;
   23a98:	fb0c f404 	mul.w	r4, ip, r4
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   23a9c:	fbb4 fbf1 	udiv	fp, r4, r1
		mins = seconds / 60U;
   23aa0:	f04f 0a3c 	mov.w	sl, #60	; 0x3c
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   23aa4:	fb01 441b 	mls	r4, r1, fp, r4
   23aa8:	fb0c f404 	mul.w	r4, ip, r4
		mins = seconds / 60U;
   23aac:	fbbe f3fa 	udiv	r3, lr, sl
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   23ab0:	fbb4 f1f1 	udiv	r1, r4, r1
			length = print_formatted(log_output,
   23ab4:	e9cd b101 	strd	fp, r1, [sp, #4]
   23ab8:	fb0a e113 	mls	r1, sl, r3, lr
   23abc:	9100      	str	r1, [sp, #0]
   23abe:	490e      	ldr	r1, [pc, #56]	; (23af8 <prefix_print+0x118>)
   23ac0:	f7ff ff7c 	bl	239bc <print_formatted>
   23ac4:	e7a1      	b.n	23a0a <prefix_print+0x2a>
		length = 0;
   23ac6:	4608      	mov	r0, r1
   23ac8:	e79f      	b.n	23a0a <prefix_print+0x2a>
	total += print_formatted(log_output,
   23aca:	4f08      	ldr	r7, [pc, #32]	; (23aec <prefix_print+0x10c>)
   23acc:	e7c1      	b.n	23a52 <prefix_print+0x72>
   23ace:	bf00      	nop
   23ad0:	0003cdd0 	.word	0x0003cdd0
   23ad4:	0003b2f8 	.word	0x0003b2f8
   23ad8:	0003dde1 	.word	0x0003dde1
   23adc:	0003cdc2 	.word	0x0003cdc2
   23ae0:	0003b30c 	.word	0x0003b30c
   23ae4:	0003cdf5 	.word	0x0003cdf5
   23ae8:	0003cdcc 	.word	0x0003cdcc
   23aec:	0003cdc7 	.word	0x0003cdc7
   23af0:	200204a4 	.word	0x200204a4
   23af4:	200204a8 	.word	0x200204a8
   23af8:	0003cdd9 	.word	0x0003cdd9

00023afc <postfix_print>:

static void postfix_print(const struct log_output *log_output,
			  u32_t flags, u8_t level)
{
   23afc:	b538      	push	{r3, r4, r5, lr}
   23afe:	460c      	mov	r4, r1
	if (color) {
   23b00:	07e1      	lsls	r1, r4, #31
{
   23b02:	4605      	mov	r5, r0
	if (color) {
   23b04:	d503      	bpl.n	23b0e <postfix_print+0x12>
		print_formatted(log_output, "%s", color);
   23b06:	4a08      	ldr	r2, [pc, #32]	; (23b28 <postfix_print+0x2c>)
   23b08:	4908      	ldr	r1, [pc, #32]	; (23b2c <postfix_print+0x30>)
   23b0a:	f7ff ff57 	bl	239bc <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   23b0e:	06e2      	lsls	r2, r4, #27
   23b10:	d408      	bmi.n	23b24 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   23b12:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
   23b14:	4628      	mov	r0, r5
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(log_output, flags);
}
   23b16:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\n");
   23b1a:	bf4c      	ite	mi
   23b1c:	4904      	ldrmi	r1, [pc, #16]	; (23b30 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
   23b1e:	4905      	ldrpl	r1, [pc, #20]	; (23b34 <postfix_print+0x38>)
   23b20:	f7ff bf4c 	b.w	239bc <print_formatted>
}
   23b24:	bd38      	pop	{r3, r4, r5, pc}
   23b26:	bf00      	nop
   23b28:	0003cdc2 	.word	0x0003cdc2
   23b2c:	0003dde1 	.word	0x0003dde1
   23b30:	0003da1c 	.word	0x0003da1c
   23b34:	0003e824 	.word	0x0003e824

00023b38 <hexdump_line_print>:
{
   23b38:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   23b3c:	4698      	mov	r8, r3
   23b3e:	9b08      	ldr	r3, [sp, #32]
   23b40:	4604      	mov	r4, r0
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   23b42:	06dd      	lsls	r5, r3, #27
{
   23b44:	460e      	mov	r6, r1
   23b46:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   23b48:	d405      	bmi.n	23b56 <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   23b4a:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
   23b4c:	bf4c      	ite	mi
   23b4e:	492a      	ldrmi	r1, [pc, #168]	; (23bf8 <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
   23b50:	492a      	ldrpl	r1, [pc, #168]	; (23bfc <hexdump_line_print+0xc4>)
   23b52:	f7ff ff33 	bl	239bc <print_formatted>
{
   23b56:	2500      	movs	r5, #0
		print_formatted(log_output, " ");
   23b58:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 23c04 <hexdump_line_print+0xcc>
	for (int i = 0; i < prefix_offset; i++) {
   23b5c:	4545      	cmp	r5, r8
   23b5e:	db2d      	blt.n	23bbc <hexdump_line_print+0x84>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   23b60:	2500      	movs	r5, #0
			print_formatted(log_output, "   ");
   23b62:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 23c08 <hexdump_line_print+0xd0>
			print_formatted(log_output, "%02x ", data[i]);
   23b66:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 23c0c <hexdump_line_print+0xd4>
			print_formatted(log_output, " ");
   23b6a:	f8df a098 	ldr.w	sl, [pc, #152]	; 23c04 <hexdump_line_print+0xcc>
		if (i < length) {
   23b6e:	42bd      	cmp	r5, r7
   23b70:	d231      	bcs.n	23bd6 <hexdump_line_print+0x9e>
			print_formatted(log_output, "%02x ", data[i]);
   23b72:	5d72      	ldrb	r2, [r6, r5]
   23b74:	4649      	mov	r1, r9
   23b76:	4620      	mov	r0, r4
   23b78:	f7ff ff20 	bl	239bc <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   23b7c:	3501      	adds	r5, #1
   23b7e:	2d10      	cmp	r5, #16
   23b80:	d122      	bne.n	23bc8 <hexdump_line_print+0x90>
	print_formatted(log_output, "|");
   23b82:	491f      	ldr	r1, [pc, #124]	; (23c00 <hexdump_line_print+0xc8>)
   23b84:	4620      	mov	r0, r4
   23b86:	f7ff ff19 	bl	239bc <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   23b8a:	2500      	movs	r5, #0
			print_formatted(log_output, " ");
   23b8c:	f8df 8074 	ldr.w	r8, [pc, #116]	; 23c04 <hexdump_line_print+0xcc>
			      isprint((int)c) ? c : '.');
   23b90:	f8df 907c 	ldr.w	r9, [pc, #124]	; 23c10 <hexdump_line_print+0xd8>
			print_formatted(log_output, "%c",
   23b94:	f8df a07c 	ldr.w	sl, [pc, #124]	; 23c14 <hexdump_line_print+0xdc>
		if (i < length) {
   23b98:	42af      	cmp	r7, r5
   23b9a:	d928      	bls.n	23bee <hexdump_line_print+0xb6>
			char c = (char)data[i];
   23b9c:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(log_output, "%c",
   23b9e:	4651      	mov	r1, sl
   23ba0:	f812 3009 	ldrb.w	r3, [r2, r9]
   23ba4:	4620      	mov	r0, r4
   23ba6:	f013 0f97 	tst.w	r3, #151	; 0x97
   23baa:	bf08      	it	eq
   23bac:	222e      	moveq	r2, #46	; 0x2e
   23bae:	f7ff ff05 	bl	239bc <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   23bb2:	3501      	adds	r5, #1
   23bb4:	2d10      	cmp	r5, #16
   23bb6:	d113      	bne.n	23be0 <hexdump_line_print+0xa8>
}
   23bb8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, " ");
   23bbc:	4649      	mov	r1, r9
   23bbe:	4620      	mov	r0, r4
   23bc0:	f7ff fefc 	bl	239bc <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
   23bc4:	3501      	adds	r5, #1
   23bc6:	e7c9      	b.n	23b5c <hexdump_line_print+0x24>
		if (i > 0 && !(i % 8)) {
   23bc8:	076a      	lsls	r2, r5, #29
   23bca:	d1d0      	bne.n	23b6e <hexdump_line_print+0x36>
			print_formatted(log_output, " ");
   23bcc:	4651      	mov	r1, sl
   23bce:	4620      	mov	r0, r4
   23bd0:	f7ff fef4 	bl	239bc <print_formatted>
   23bd4:	e7cb      	b.n	23b6e <hexdump_line_print+0x36>
			print_formatted(log_output, "   ");
   23bd6:	4641      	mov	r1, r8
   23bd8:	4620      	mov	r0, r4
   23bda:	f7ff feef 	bl	239bc <print_formatted>
   23bde:	e7cd      	b.n	23b7c <hexdump_line_print+0x44>
		if (i > 0 && !(i % 8)) {
   23be0:	076b      	lsls	r3, r5, #29
   23be2:	d1d9      	bne.n	23b98 <hexdump_line_print+0x60>
			print_formatted(log_output, " ");
   23be4:	4641      	mov	r1, r8
   23be6:	4620      	mov	r0, r4
   23be8:	f7ff fee8 	bl	239bc <print_formatted>
   23bec:	e7d4      	b.n	23b98 <hexdump_line_print+0x60>
			print_formatted(log_output, " ");
   23bee:	4641      	mov	r1, r8
   23bf0:	4620      	mov	r0, r4
   23bf2:	f7ff fee3 	bl	239bc <print_formatted>
   23bf6:	e7dc      	b.n	23bb2 <hexdump_line_print+0x7a>
   23bf8:	0003da1c 	.word	0x0003da1c
   23bfc:	0003e824 	.word	0x0003e824
   23c00:	0003cd7b 	.word	0x0003cd7b
   23c04:	0003bd2d 	.word	0x0003bd2d
   23c08:	0003bd2b 	.word	0x0003bd2b
   23c0c:	0003cd75 	.word	0x0003cd75
   23c10:	0003f5ca 	.word	0x0003f5ca
   23c14:	0003cd7d 	.word	0x0003cd7d

00023c18 <log_output_string>:
}

void log_output_string(const struct log_output *log_output,
		       struct log_msg_ids src_level, u32_t timestamp,
		       const char *fmt, va_list ap, u32_t flags)
{
   23c18:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
		log_output_string_syst_process(log_output,
				src_level, fmt, ap, flags);
		return;
	}

	if (!raw_string) {
   23c1c:	f011 0407 	ands.w	r4, r1, #7
{
   23c20:	4606      	mov	r6, r0
   23c22:	e9dd 870a 	ldrd	r8, r7, [sp, #40]	; 0x28
   23c26:	461d      	mov	r5, r3
	if (!raw_string) {
   23c28:	d00b      	beq.n	23c42 <log_output_string+0x2a>
		prefix_print(log_output, flags, true, timestamp,
   23c2a:	f3c1 1389 	ubfx	r3, r1, #6, #10
   23c2e:	f3c1 01c2 	ubfx	r1, r1, #3, #3
   23c32:	9302      	str	r3, [sp, #8]
   23c34:	e9cd 4100 	strd	r4, r1, [sp]
   23c38:	4613      	mov	r3, r2
   23c3a:	4639      	mov	r1, r7
   23c3c:	2201      	movs	r2, #1
   23c3e:	f7ff fecf 	bl	239e0 <prefix_print>

#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, ap);
#else
	z_vprintk(out_func, (void *)log_output, fmt, ap);
   23c42:	4643      	mov	r3, r8
   23c44:	462a      	mov	r2, r5
   23c46:	4631      	mov	r1, r6
   23c48:	480d      	ldr	r0, [pc, #52]	; (23c80 <log_output_string+0x68>)
   23c4a:	f013 fec9 	bl	379e0 <z_vprintk>
#endif

	(void)length;

	if (raw_string) {
   23c4e:	b98c      	cbnz	r4, 23c74 <log_output_string+0x5c>
   23c50:	3d01      	subs	r5, #1
	while (*fmt != '\0') {
   23c52:	f815 3f01 	ldrb.w	r3, [r5, #1]!
   23c56:	b95b      	cbnz	r3, 23c70 <log_output_string+0x58>
		/* add \r if string ends with newline. */
		if (ends_with_newline(fmt)) {
   23c58:	2c0a      	cmp	r4, #10
   23c5a:	d103      	bne.n	23c64 <log_output_string+0x4c>
			print_formatted(log_output, "\r");
   23c5c:	4909      	ldr	r1, [pc, #36]	; (23c84 <log_output_string+0x6c>)
   23c5e:	4630      	mov	r0, r6
   23c60:	f7ff feac 	bl	239bc <print_formatted>
		}
	} else {
		postfix_print(log_output, flags, level);
	}

	log_output_flush(log_output);
   23c64:	4630      	mov	r0, r6
}
   23c66:	b004      	add	sp, #16
   23c68:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	log_output_flush(log_output);
   23c6c:	f014 b8ab 	b.w	37dc6 <log_output_flush>
	while (*fmt != '\0') {
   23c70:	461c      	mov	r4, r3
   23c72:	e7ee      	b.n	23c52 <log_output_string+0x3a>
		postfix_print(log_output, flags, level);
   23c74:	4622      	mov	r2, r4
   23c76:	4639      	mov	r1, r7
   23c78:	4630      	mov	r0, r6
   23c7a:	f7ff ff3f 	bl	23afc <postfix_print>
   23c7e:	e7f1      	b.n	23c64 <log_output_string+0x4c>
   23c80:	00037d95 	.word	0x00037d95
   23c84:	0003cdc0 	.word	0x0003cdc0

00023c88 <log_output_hexdump>:

void log_output_hexdump(const struct log_output *log_output,
			     struct log_msg_ids src_level, u32_t timestamp,
			     const char *metadata, const u8_t *data,
			     u32_t length, u32_t flags)
{
   23c88:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   23c8c:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   23c8e:	4698      	mov	r8, r3
   23c90:	e9dd 750c 	ldrd	r7, r5, [sp, #48]	; 0x30
		log_output_hexdump_syst_process(log_output,
				src_level, data, length, flags);
		return;
	}

	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   23c94:	f3c1 1389 	ubfx	r3, r1, #6, #10
	u8_t level = (u8_t)src_level.level;
   23c98:	f001 0907 	and.w	r9, r1, #7
	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   23c9c:	f3c1 01c2 	ubfx	r1, r1, #3, #3
   23ca0:	9302      	str	r3, [sp, #8]
   23ca2:	e9cd 9100 	strd	r9, r1, [sp]
   23ca6:	4613      	mov	r3, r2
   23ca8:	4631      	mov	r1, r6
   23caa:	2201      	movs	r2, #1
{
   23cac:	4604      	mov	r4, r0
	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   23cae:	f7ff fe97 	bl	239e0 <prefix_print>
				     level, domain_id, source_id);

	/* Print metadata */
	print_formatted(log_output, "%s", metadata);
   23cb2:	4642      	mov	r2, r8
	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   23cb4:	4682      	mov	sl, r0
	print_formatted(log_output, "%s", metadata);
   23cb6:	4910      	ldr	r1, [pc, #64]	; (23cf8 <log_output_hexdump+0x70>)
   23cb8:	4620      	mov	r0, r4
   23cba:	f7ff fe7f 	bl	239bc <print_formatted>

	while (length) {
   23cbe:	b955      	cbnz	r5, 23cd6 <log_output_hexdump+0x4e>

		data += part_len;
		length -= part_len;
	};

	postfix_print(log_output, flags, level);
   23cc0:	4620      	mov	r0, r4
   23cc2:	464a      	mov	r2, r9
   23cc4:	4631      	mov	r1, r6
   23cc6:	f7ff ff19 	bl	23afc <postfix_print>
	log_output_flush(log_output);
   23cca:	4620      	mov	r0, r4
}
   23ccc:	b004      	add	sp, #16
   23cce:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	log_output_flush(log_output);
   23cd2:	f014 b878 	b.w	37dc6 <log_output_flush>
		u32_t part_len = length > HEXDUMP_BYTES_IN_LINE ?
   23cd6:	2d10      	cmp	r5, #16
   23cd8:	46a8      	mov	r8, r5
   23cda:	bf28      	it	cs
   23cdc:	f04f 0810 	movcs.w	r8, #16
		hexdump_line_print(log_output, data, part_len,
   23ce0:	4639      	mov	r1, r7
   23ce2:	9600      	str	r6, [sp, #0]
   23ce4:	4653      	mov	r3, sl
   23ce6:	4642      	mov	r2, r8
   23ce8:	4620      	mov	r0, r4
   23cea:	f7ff ff25 	bl	23b38 <hexdump_line_print>
		data += part_len;
   23cee:	4447      	add	r7, r8
		length -= part_len;
   23cf0:	eba5 0508 	sub.w	r5, r5, r8
   23cf4:	e7e3      	b.n	23cbe <log_output_hexdump+0x36>
   23cf6:	bf00      	nop
   23cf8:	0003dde1 	.word	0x0003dde1

00023cfc <log_output_timestamp_freq_set>:
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
}

void log_output_timestamp_freq_set(u32_t frequency)
{
	timestamp_div = 1U;
   23cfc:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
   23cfe:	2100      	movs	r1, #0
	timestamp_div = 1U;
   23d00:	4a07      	ldr	r2, [pc, #28]	; (23d20 <log_output_timestamp_freq_set+0x24>)
{
   23d02:	b510      	push	{r4, lr}
	while (frequency > 1000000) {
   23d04:	4c07      	ldr	r4, [pc, #28]	; (23d24 <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
   23d06:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
   23d08:	42a0      	cmp	r0, r4
   23d0a:	d804      	bhi.n	23d16 <log_output_timestamp_freq_set+0x1a>
   23d0c:	b101      	cbz	r1, 23d10 <log_output_timestamp_freq_set+0x14>
   23d0e:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
   23d10:	4b05      	ldr	r3, [pc, #20]	; (23d28 <log_output_timestamp_freq_set+0x2c>)
   23d12:	6018      	str	r0, [r3, #0]
}
   23d14:	bd10      	pop	{r4, pc}
		frequency /= 2U;
   23d16:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
   23d18:	005b      	lsls	r3, r3, #1
   23d1a:	2101      	movs	r1, #1
   23d1c:	e7f4      	b.n	23d08 <log_output_timestamp_freq_set+0xc>
   23d1e:	bf00      	nop
   23d20:	200204a8 	.word	0x200204a8
   23d24:	000f4240 	.word	0x000f4240
   23d28:	200204a4 	.word	0x200204a4

00023d2c <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
   23d2c:	2201      	movs	r2, #1
   23d2e:	4b01      	ldr	r3, [pc, #4]	; (23d34 <log_backend_rtt_init+0x8>)
   23d30:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
   23d32:	4770      	bx	lr
   23d34:	20024d09 	.word	0x20024d09

00023d38 <panic>:

static void panic(struct log_backend const *const backend)
{
   23d38:	b508      	push	{r3, lr}
 * @param log_output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const log_output)
{
	log_output_flush(log_output);
   23d3a:	4803      	ldr	r0, [pc, #12]	; (23d48 <panic+0x10>)
   23d3c:	f014 f843 	bl	37dc6 <log_output_flush>
	log_backend_std_panic(&log_output);
	panic_mode = true;
   23d40:	2201      	movs	r2, #1
   23d42:	4b02      	ldr	r3, [pc, #8]	; (23d4c <panic+0x14>)
   23d44:	701a      	strb	r2, [r3, #0]
}
   23d46:	bd08      	pop	{r3, pc}
   23d48:	0003b338 	.word	0x0003b338
   23d4c:	20024d0a 	.word	0x20024d0a

00023d50 <sync_hexdump>:
}

static void sync_hexdump(const struct log_backend *const backend,
			 struct log_msg_ids src_level, u32_t timestamp,
			 const char *metadata, const u8_t *data, u32_t length)
{
   23d50:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		 * by another one, lock context for whole log processing.
		 */
		key = irq_lock();
	}

	log_output_hexdump(log_output, src_level, timestamp,
   23d52:	200a      	movs	r0, #10
   23d54:	9002      	str	r0, [sp, #8]
   23d56:	9807      	ldr	r0, [sp, #28]
   23d58:	9001      	str	r0, [sp, #4]
   23d5a:	9806      	ldr	r0, [sp, #24]
   23d5c:	9000      	str	r0, [sp, #0]
   23d5e:	4803      	ldr	r0, [pc, #12]	; (23d6c <sync_hexdump+0x1c>)
   23d60:	f7ff ff92 	bl	23c88 <log_output_hexdump>
	u32_t flag = IS_ENABLED(CONFIG_LOG_BACKEND_RTT_SYST_ENABLE) ?
		LOG_OUTPUT_FLAG_FORMAT_SYST : 0;

	log_backend_std_sync_hexdump(&log_output, flag, src_level,
				     timestamp, metadata, data, length);
}
   23d64:	b005      	add	sp, #20
   23d66:	f85d fb04 	ldr.w	pc, [sp], #4
   23d6a:	bf00      	nop
   23d6c:	0003b338 	.word	0x0003b338

00023d70 <sync_string>:
{
   23d70:	b507      	push	{r0, r1, r2, lr}
	log_output_string(log_output, src_level, timestamp, fmt, ap, flags);
   23d72:	200a      	movs	r0, #10
   23d74:	9001      	str	r0, [sp, #4]
   23d76:	9804      	ldr	r0, [sp, #16]
   23d78:	9000      	str	r0, [sp, #0]
   23d7a:	4803      	ldr	r0, [pc, #12]	; (23d88 <sync_string+0x18>)
   23d7c:	f7ff ff4c 	bl	23c18 <log_output_string>
}
   23d80:	b003      	add	sp, #12
   23d82:	f85d fb04 	ldr.w	pc, [sp], #4
   23d86:	bf00      	nop
   23d88:	0003b338 	.word	0x0003b338

00023d8c <data_out_drop_mode>:
{
   23d8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   23d8e:	4607      	mov	r7, r0
   23d90:	460e      	mov	r6, r1
	int retry_cnt = CONFIG_LOG_BACKEND_RTT_RETRY_CNT;
   23d92:	240a      	movs	r4, #10
   23d94:	4d17      	ldr	r5, [pc, #92]	; (23df4 <data_out_drop_mode+0x68>)
		ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
   23d96:	4632      	mov	r2, r6
   23d98:	4639      	mov	r1, r7
   23d9a:	2000      	movs	r0, #0
   23d9c:	f000 ffee 	bl	24d7c <SEGGER_RTT_WriteSkipNoLock>
		if (ret) {
   23da0:	b1c8      	cbz	r0, 23dd6 <data_out_drop_mode+0x4a>
	host_present = true;
   23da2:	2301      	movs	r3, #1
   23da4:	702b      	strb	r3, [r5, #0]
	return panic_mode;
   23da6:	4b14      	ldr	r3, [pc, #80]	; (23df8 <data_out_drop_mode+0x6c>)
	if (is_panic_mode()) {
   23da8:	781b      	ldrb	r3, [r3, #0]
   23daa:	b92b      	cbnz	r3, 23db8 <data_out_drop_mode+0x2c>
}
   23dac:	4630      	mov	r0, r6
   23dae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (retry_cnt == 0) {
   23db0:	b95c      	cbnz	r4, 23dca <data_out_drop_mode+0x3e>
		host_present = false;
   23db2:	702c      	strb	r4, [r5, #0]
   23db4:	f04f 34ff 	mov.w	r4, #4294967295
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
   23db8:	2000      	movs	r0, #0
   23dba:	f001 f82b 	bl	24e14 <SEGGER_RTT_HasDataUp>
   23dbe:	2800      	cmp	r0, #0
   23dc0:	d0f4      	beq.n	23dac <data_out_drop_mode+0x20>
   23dc2:	782b      	ldrb	r3, [r5, #0]
   23dc4:	2b00      	cmp	r3, #0
   23dc6:	d1f3      	bne.n	23db0 <data_out_drop_mode+0x24>
   23dc8:	e7f0      	b.n	23dac <data_out_drop_mode+0x20>
			on_failed_write(retry_cnt--);
   23dca:	3c01      	subs	r4, #1
	z_impl_k_busy_wait(usec_to_wait);
   23dcc:	f242 7010 	movw	r0, #10000	; 0x2710
   23dd0:	f015 fe9f 	bl	39b12 <z_impl_k_busy_wait>
   23dd4:	e7f0      	b.n	23db8 <data_out_drop_mode+0x2c>
		} else if (host_present) {
   23dd6:	782b      	ldrb	r3, [r5, #0]
   23dd8:	b113      	cbz	r3, 23de0 <data_out_drop_mode+0x54>
	if (retry_cnt == 0) {
   23dda:	3c01      	subs	r4, #1
   23ddc:	d104      	bne.n	23de8 <data_out_drop_mode+0x5c>
		host_present = false;
   23dde:	702c      	strb	r4, [r5, #0]
	} while ((ret == 0) && host_present);
   23de0:	782b      	ldrb	r3, [r5, #0]
   23de2:	2b00      	cmp	r3, #0
   23de4:	d1d7      	bne.n	23d96 <data_out_drop_mode+0xa>
   23de6:	e7e1      	b.n	23dac <data_out_drop_mode+0x20>
   23de8:	f242 7010 	movw	r0, #10000	; 0x2710
   23dec:	f015 fe91 	bl	39b12 <z_impl_k_busy_wait>
   23df0:	e7f6      	b.n	23de0 <data_out_drop_mode+0x54>
   23df2:	bf00      	nop
   23df4:	20024d09 	.word	0x20024d09
   23df8:	20024d0a 	.word	0x20024d0a

00023dfc <nvs_flash_erase_sector>:

/* erase a sector by first checking it is used and then erasing if required
 * return 0 if OK, errorcode on error.
 */
static int nvs_flash_erase_sector(struct nvs_fs *fs, u32_t addr)
{
   23dfc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	int rc;
	off_t offset;

	addr &= ADDR_SECT_MASK;
   23e00:	0c0c      	lsrs	r4, r1, #16
   23e02:	0424      	lsls	r4, r4, #16
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
   23e04:	8982      	ldrh	r2, [r0, #12]
   23e06:	4621      	mov	r1, r4
{
   23e08:	4605      	mov	r5, r0
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
   23e0a:	f014 f84a 	bl	37ea2 <nvs_flash_cmp_const.constprop.5>
	if (rc <= 0) {
   23e0e:	1e06      	subs	r6, r0, #0
   23e10:	dd29      	ble.n	23e66 <nvs_flash_erase_sector+0x6a>
	}

	offset = fs->offset;
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);

	rc = flash_write_protection_set(fs->flash_device, 0);
   23e12:	2100      	movs	r1, #0
   23e14:	6aa8      	ldr	r0, [r5, #40]	; 0x28
	offset = fs->offset;
   23e16:	682f      	ldr	r7, [r5, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   23e18:	f8b5 800c 	ldrh.w	r8, [r5, #12]
	rc = flash_write_protection_set(fs->flash_device, 0);
   23e1c:	f013 ffe0 	bl	37de0 <flash_write_protection_set>
	if (rc) {
   23e20:	4606      	mov	r6, r0
   23e22:	bb00      	cbnz	r0, 23e66 <nvs_flash_erase_sector+0x6a>
		/* flash protection set error */
		return rc;
	}
	LOG_DBG("Erasing flash at %lx, len %d", (long int) offset,
   23e24:	2304      	movs	r3, #4
   23e26:	f04f 0000 	mov.w	r0, #0
	return ((u8_t *)data - (u8_t *)__log_const_start)/
   23e2a:	4a11      	ldr	r2, [pc, #68]	; (23e70 <nvs_flash_erase_sector+0x74>)
   23e2c:	f363 0007 	bfi	r0, r3, #0, #8
   23e30:	4b10      	ldr	r3, [pc, #64]	; (23e74 <nvs_flash_erase_sector+0x78>)
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   23e32:	0c24      	lsrs	r4, r4, #16
   23e34:	fb08 7404 	mla	r4, r8, r4, r7
   23e38:	1a9b      	subs	r3, r3, r2
   23e3a:	08db      	lsrs	r3, r3, #3
	LOG_DBG("Erasing flash at %lx, len %d", (long int) offset,
   23e3c:	f363 108f 	bfi	r0, r3, #6, #10
   23e40:	89ab      	ldrh	r3, [r5, #12]
   23e42:	4a0d      	ldr	r2, [pc, #52]	; (23e78 <nvs_flash_erase_sector+0x7c>)
   23e44:	9300      	str	r3, [sp, #0]
   23e46:	490d      	ldr	r1, [pc, #52]	; (23e7c <nvs_flash_erase_sector+0x80>)
   23e48:	4623      	mov	r3, r4
   23e4a:	f013 ff90 	bl	37d6e <log_string_sync>
		fs->sector_size);
	rc = flash_erase(fs->flash_device, offset, fs->sector_size);
   23e4e:	6aa8      	ldr	r0, [r5, #40]	; 0x28
   23e50:	89aa      	ldrh	r2, [r5, #12]
				    size_t size)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->driver_api;

	return api->erase(dev, offset, size);
   23e52:	6843      	ldr	r3, [r0, #4]
   23e54:	4621      	mov	r1, r4
   23e56:	689b      	ldr	r3, [r3, #8]
   23e58:	4798      	blx	r3
	if (rc) {
   23e5a:	4606      	mov	r6, r0
   23e5c:	b918      	cbnz	r0, 23e66 <nvs_flash_erase_sector+0x6a>
		/* flash erase error */
		return rc;
	}
	(void) flash_write_protection_set(fs->flash_device, 1);
   23e5e:	2101      	movs	r1, #1
   23e60:	6aa8      	ldr	r0, [r5, #40]	; 0x28
   23e62:	f013 ffbd 	bl	37de0 <flash_write_protection_set>
	return 0;
}
   23e66:	4630      	mov	r0, r6
   23e68:	b002      	add	sp, #8
   23e6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   23e6e:	bf00      	nop
   23e70:	0003ade0 	.word	0x0003ade0
   23e74:	0003ae40 	.word	0x0003ae40
   23e78:	0003ce2b 	.word	0x0003ce2b
   23e7c:	0003ce5d 	.word	0x0003ce5d

00023e80 <nvs_prev_ate>:

/* walking through allocation entry list, from newest to oldest entries
 * read ate from addr, modify addr to the previous ate
 */
static int nvs_prev_ate(struct nvs_fs *fs, u32_t *addr, struct nvs_ate *ate)
{
   23e80:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   23e84:	2308      	movs	r3, #8
{
   23e86:	b085      	sub	sp, #20
   23e88:	460d      	mov	r5, r1
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   23e8a:	6809      	ldr	r1, [r1, #0]
{
   23e8c:	4607      	mov	r7, r0
	int rc;
	struct nvs_ate close_ate, end_ate;
	u32_t data_end_addr, ate_end_addr;
	size_t ate_size;

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   23e8e:	7c04      	ldrb	r4, [r0, #16]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   23e90:	f013 ffa9 	bl	37de6 <nvs_flash_rd>

	rc = nvs_flash_ate_rd(fs, *addr, ate);
	if (rc) {
   23e94:	b968      	cbnz	r0, 23eb2 <nvs_prev_ate+0x32>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   23e96:	2108      	movs	r1, #8
   23e98:	4620      	mov	r0, r4
   23e9a:	f013 ffef 	bl	37e7c <nvs_al_size.isra.1>
		return rc;
	}

	*addr += ate_size;
   23e9e:	6829      	ldr	r1, [r5, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
   23ea0:	89bb      	ldrh	r3, [r7, #12]
	*addr += ate_size;
   23ea2:	4401      	add	r1, r0
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
   23ea4:	b28a      	uxth	r2, r1
   23ea6:	1a1b      	subs	r3, r3, r0
   23ea8:	429a      	cmp	r2, r3
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   23eaa:	4606      	mov	r6, r0
	*addr += ate_size;
   23eac:	6029      	str	r1, [r5, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
   23eae:	d003      	beq.n	23eb8 <nvs_prev_ate+0x38>
		return 0;
   23eb0:	2000      	movs	r0, #0
	/* remark: if there was absolutely no valid data in the sector *addr
	 * is kept at sector_end - 2*ate_size, the next read will contain
	 * invalid data and continue with a sector jump
	 */
	return 0;
}
   23eb2:	b005      	add	sp, #20
   23eb4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (((*addr) >> ADDR_SECT_SHIFT) == 0U) {
   23eb8:	0c0b      	lsrs	r3, r1, #16
		*addr += ((fs->sector_count - 1) << ADDR_SECT_SHIFT);
   23eba:	bf09      	itett	eq
   23ebc:	89fb      	ldrheq	r3, [r7, #14]
		*addr -= (1 << ADDR_SECT_SHIFT);
   23ebe:	f5a1 3180 	subne.w	r1, r1, #65536	; 0x10000
		*addr += ((fs->sector_count - 1) << ADDR_SECT_SHIFT);
   23ec2:	f103 33ff 	addeq.w	r3, r3, #4294967295
   23ec6:	eb01 4103 	addeq.w	r1, r1, r3, lsl #16
		*addr -= (1 << ADDR_SECT_SHIFT);
   23eca:	6029      	str	r1, [r5, #0]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   23ecc:	2308      	movs	r3, #8
   23ece:	466a      	mov	r2, sp
   23ed0:	4638      	mov	r0, r7
   23ed2:	f013 ff88 	bl	37de6 <nvs_flash_rd>
	if (rc) {
   23ed6:	2800      	cmp	r0, #0
   23ed8:	d1eb      	bne.n	23eb2 <nvs_prev_ate+0x32>
   23eda:	466a      	mov	r2, sp
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   23edc:	4603      	mov	r3, r0
		if (data8[i] != value) {
   23ede:	f812 1b01 	ldrb.w	r1, [r2], #1
   23ee2:	29ff      	cmp	r1, #255	; 0xff
   23ee4:	d115      	bne.n	23f12 <nvs_prev_ate+0x92>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   23ee6:	3301      	adds	r3, #1
   23ee8:	2b08      	cmp	r3, #8
   23eea:	d1f8      	bne.n	23ede <nvs_prev_ate+0x5e>
		*addr = fs->ate_wra;
   23eec:	687b      	ldr	r3, [r7, #4]
   23eee:	602b      	str	r3, [r5, #0]
		return 0;
   23ef0:	e7df      	b.n	23eb2 <nvs_prev_ate+0x32>
		if (close_ate.offset < (fs->sector_size - ate_size) &&
   23ef2:	89ba      	ldrh	r2, [r7, #12]
   23ef4:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   23ef8:	1b92      	subs	r2, r2, r6
   23efa:	4293      	cmp	r3, r2
   23efc:	d20f      	bcs.n	23f1e <nvs_prev_ate+0x9e>
		    !(close_ate.offset % ate_size)) {
   23efe:	fbb3 f2f6 	udiv	r2, r3, r6
   23f02:	fb06 3212 	mls	r2, r6, r2, r3
		if (close_ate.offset < (fs->sector_size - ate_size) &&
   23f06:	b952      	cbnz	r2, 23f1e <nvs_prev_ate+0x9e>
			(*addr) &= ADDR_SECT_MASK;
   23f08:	0c24      	lsrs	r4, r4, #16
   23f0a:	0424      	lsls	r4, r4, #16
			(*addr) += close_ate.offset;
   23f0c:	441c      	add	r4, r3
   23f0e:	602c      	str	r4, [r5, #0]
			return 0;
   23f10:	e7cf      	b.n	23eb2 <nvs_prev_ate+0x32>
	if (!nvs_ate_crc8_check(&close_ate)) {
   23f12:	4668      	mov	r0, sp
   23f14:	f013 ff9d 	bl	37e52 <nvs_ate_crc8_check>
   23f18:	682c      	ldr	r4, [r5, #0]
   23f1a:	2800      	cmp	r0, #0
   23f1c:	d0e9      	beq.n	23ef2 <nvs_prev_ate+0x72>
	data_end_addr = *addr & ADDR_SECT_MASK;
   23f1e:	4b10      	ldr	r3, [pc, #64]	; (23f60 <nvs_prev_ate+0xe0>)
	*addr -= ate_size;
   23f20:	1ba4      	subs	r4, r4, r6
			data_end_addr &= ADDR_SECT_MASK;
   23f22:	4699      	mov	r9, r3
	*addr -= ate_size;
   23f24:	602c      	str	r4, [r5, #0]
	data_end_addr = *addr & ADDR_SECT_MASK;
   23f26:	ea04 0803 	and.w	r8, r4, r3
	while (ate_end_addr > data_end_addr) {
   23f2a:	45a0      	cmp	r8, r4
   23f2c:	d2c0      	bcs.n	23eb0 <nvs_prev_ate+0x30>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   23f2e:	2308      	movs	r3, #8
   23f30:	4621      	mov	r1, r4
   23f32:	eb0d 0203 	add.w	r2, sp, r3
   23f36:	4638      	mov	r0, r7
   23f38:	f013 ff55 	bl	37de6 <nvs_flash_rd>
		if (rc) {
   23f3c:	2800      	cmp	r0, #0
   23f3e:	d1b8      	bne.n	23eb2 <nvs_prev_ate+0x32>
		if (!nvs_ate_crc8_check(&end_ate)) {
   23f40:	a802      	add	r0, sp, #8
   23f42:	f013 ff86 	bl	37e52 <nvs_ate_crc8_check>
   23f46:	b940      	cbnz	r0, 23f5a <nvs_prev_ate+0xda>
			data_end_addr += end_ate.offset + end_ate.len;
   23f48:	f8bd 300a 	ldrh.w	r3, [sp, #10]
   23f4c:	f8bd 200c 	ldrh.w	r2, [sp, #12]
			data_end_addr &= ADDR_SECT_MASK;
   23f50:	ea08 0809 	and.w	r8, r8, r9
			data_end_addr += end_ate.offset + end_ate.len;
   23f54:	4413      	add	r3, r2
   23f56:	4498      	add	r8, r3
			*addr = ate_end_addr;
   23f58:	602c      	str	r4, [r5, #0]
		ate_end_addr -= ate_size;
   23f5a:	1ba4      	subs	r4, r4, r6
   23f5c:	e7e5      	b.n	23f2a <nvs_prev_ate+0xaa>
   23f5e:	bf00      	nop
   23f60:	ffff0000 	.word	0xffff0000

00023f64 <nvs_gc>:
/* garbage collection: the address ate_wra has been updated to the new sector
 * that has just been started. The data to gc is in the sector after this new
 * sector.
 */
static int nvs_gc(struct nvs_fs *fs)
{
   23f64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct nvs_ate close_ate, gc_ate, wlk_ate;
	u32_t sec_addr, gc_addr, gc_prev_addr, wlk_addr, wlk_prev_addr,
	      data_addr, stop_addr;
	size_t ate_size;

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   23f68:	2108      	movs	r1, #8
{
   23f6a:	b097      	sub	sp, #92	; 0x5c
   23f6c:	4604      	mov	r4, r0
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   23f6e:	7c00      	ldrb	r0, [r0, #16]
   23f70:	f013 ff84 	bl	37e7c <nvs_al_size.isra.1>
   23f74:	4680      	mov	r8, r0

	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
   23f76:	6863      	ldr	r3, [r4, #4]
	nvs_sector_advance(fs, &sec_addr);
   23f78:	a905      	add	r1, sp, #20
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
   23f7a:	0c1b      	lsrs	r3, r3, #16
   23f7c:	041b      	lsls	r3, r3, #16
	nvs_sector_advance(fs, &sec_addr);
   23f7e:	89e0      	ldrh	r0, [r4, #14]
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
   23f80:	9305      	str	r3, [sp, #20]
	nvs_sector_advance(fs, &sec_addr);
   23f82:	f013 ff84 	bl	37e8e <nvs_sector_advance.isra.2>
	gc_addr = sec_addr + fs->sector_size - ate_size;
   23f86:	9b05      	ldr	r3, [sp, #20]
   23f88:	89a1      	ldrh	r1, [r4, #12]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   23f8a:	ad08      	add	r5, sp, #32
	gc_addr = sec_addr + fs->sector_size - ate_size;
   23f8c:	4419      	add	r1, r3
   23f8e:	eba1 0108 	sub.w	r1, r1, r8
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   23f92:	462a      	mov	r2, r5
   23f94:	2308      	movs	r3, #8
   23f96:	4620      	mov	r0, r4
	gc_addr = sec_addr + fs->sector_size - ate_size;
   23f98:	9106      	str	r1, [sp, #24]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   23f9a:	f013 ff24 	bl	37de6 <nvs_flash_rd>

	/* if the sector is not closed don't do gc */
	rc = nvs_flash_ate_rd(fs, gc_addr, &close_ate);
	if (rc < 0) {
   23f9e:	1e02      	subs	r2, r0, #0
   23fa0:	f2c0 8085 	blt.w	240ae <nvs_gc+0x14a>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   23fa4:	2300      	movs	r3, #0
		if (data8[i] != value) {
   23fa6:	5cea      	ldrb	r2, [r5, r3]
   23fa8:	2aff      	cmp	r2, #255	; 0xff
   23faa:	f040 8084 	bne.w	240b6 <nvs_gc+0x152>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   23fae:	3301      	adds	r3, #1
   23fb0:	2b08      	cmp	r3, #8
   23fb2:	d1f8      	bne.n	23fa6 <nvs_gc+0x42>
		return rc;
	}

	rc = nvs_ate_cmp_const(&close_ate, 0xff);
	if (!rc) {
		rc = nvs_flash_erase_sector(fs, sec_addr);
   23fb4:	9905      	ldr	r1, [sp, #20]
   23fb6:	4620      	mov	r0, r4
   23fb8:	f7ff ff20 	bl	23dfc <nvs_flash_erase_sector>
   23fbc:	4602      	mov	r2, r0
		if (rc) {
   23fbe:	e076      	b.n	240ae <nvs_gc+0x14a>
		bytes_to_copy = MIN(block_size, len);
   23fc0:	454e      	cmp	r6, r9
   23fc2:	4635      	mov	r5, r6
   23fc4:	bf28      	it	cs
   23fc6:	464d      	movcs	r5, r9
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_copy);
   23fc8:	aa0e      	add	r2, sp, #56	; 0x38
   23fca:	462b      	mov	r3, r5
   23fcc:	4639      	mov	r1, r7
   23fce:	4620      	mov	r0, r4
   23fd0:	f013 ff09 	bl	37de6 <nvs_flash_rd>
		if (rc) {
   23fd4:	4602      	mov	r2, r0
   23fd6:	2800      	cmp	r0, #0
   23fd8:	d169      	bne.n	240ae <nvs_gc+0x14a>
	if (!len) {
   23fda:	b135      	cbz	r5, 23fea <nvs_gc+0x86>
   23fdc:	aa0e      	add	r2, sp, #56	; 0x38
   23fde:	462b      	mov	r3, r5
   23fe0:	68a1      	ldr	r1, [r4, #8]
   23fe2:	4620      	mov	r0, r4
   23fe4:	f013 ff81 	bl	37eea <nvs_flash_al_wrt.part.3>
   23fe8:	4602      	mov	r2, r0
	fs->data_wra += nvs_al_size(fs, len);
   23fea:	4629      	mov	r1, r5
   23fec:	7c20      	ldrb	r0, [r4, #16]
   23fee:	f013 ff45 	bl	37e7c <nvs_al_size.isra.1>
   23ff2:	68a3      	ldr	r3, [r4, #8]
   23ff4:	4418      	add	r0, r3
   23ff6:	60a0      	str	r0, [r4, #8]
		if (rc) {
   23ff8:	2a00      	cmp	r2, #0
   23ffa:	d158      	bne.n	240ae <nvs_gc+0x14a>
		len -= bytes_to_copy;
   23ffc:	eba9 0905 	sub.w	r9, r9, r5
		addr += bytes_to_copy;
   24000:	442f      	add	r7, r5
   24002:	e04a      	b.n	2409a <nvs_gc+0x136>
				return rc;
			}
		}

		/* stop gc at end of the sector */
		if (gc_prev_addr == stop_addr) {
   24004:	45d8      	cmp	r8, fp
   24006:	d0d5      	beq.n	23fb4 <nvs_gc+0x50>
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
   24008:	aa0a      	add	r2, sp, #40	; 0x28
   2400a:	a906      	add	r1, sp, #24
   2400c:	4620      	mov	r0, r4
		gc_prev_addr = gc_addr;
   2400e:	f8dd b018 	ldr.w	fp, [sp, #24]
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
   24012:	f7ff ff35 	bl	23e80 <nvs_prev_ate>
		if (rc) {
   24016:	4602      	mov	r2, r0
   24018:	2800      	cmp	r0, #0
   2401a:	d148      	bne.n	240ae <nvs_gc+0x14a>
		wlk_addr = fs->ate_wra;
   2401c:	6863      	ldr	r3, [r4, #4]
   2401e:	9307      	str	r3, [sp, #28]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   24020:	aa0c      	add	r2, sp, #48	; 0x30
   24022:	a907      	add	r1, sp, #28
   24024:	4620      	mov	r0, r4
			wlk_prev_addr = wlk_addr;
   24026:	9d07      	ldr	r5, [sp, #28]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   24028:	f7ff ff2a 	bl	23e80 <nvs_prev_ate>
			if (rc) {
   2402c:	4602      	mov	r2, r0
   2402e:	2800      	cmp	r0, #0
   24030:	d13d      	bne.n	240ae <nvs_gc+0x14a>
			if ((wlk_ate.id == gc_ate.id) &&
   24032:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
   24036:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   2403a:	429a      	cmp	r2, r3
   2403c:	d1f0      	bne.n	24020 <nvs_gc+0xbc>
			    (!nvs_ate_crc8_check(&wlk_ate))) {
   2403e:	a80c      	add	r0, sp, #48	; 0x30
   24040:	f013 ff07 	bl	37e52 <nvs_ate_crc8_check>
			if ((wlk_ate.id == gc_ate.id) &&
   24044:	2800      	cmp	r0, #0
   24046:	d1eb      	bne.n	24020 <nvs_gc+0xbc>
		if ((wlk_prev_addr == gc_prev_addr) && gc_ate.len) {
   24048:	45ab      	cmp	fp, r5
   2404a:	d1db      	bne.n	24004 <nvs_gc+0xa0>
   2404c:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
   24050:	2a00      	cmp	r2, #0
   24052:	d0d7      	beq.n	24004 <nvs_gc+0xa0>
			LOG_DBG("Moving %d, len %d", gc_ate.id, gc_ate.len);
   24054:	f02a 033f 	bic.w	r3, sl, #63	; 0x3f
   24058:	f043 0304 	orr.w	r3, r3, #4
   2405c:	f363 0a07 	bfi	sl, r3, #0, #8
   24060:	9b02      	ldr	r3, [sp, #8]
   24062:	9200      	str	r2, [sp, #0]
   24064:	f363 1a8f 	bfi	sl, r3, #6, #10
   24068:	4a1b      	ldr	r2, [pc, #108]	; (240d8 <nvs_gc+0x174>)
   2406a:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   2406e:	491b      	ldr	r1, [pc, #108]	; (240dc <nvs_gc+0x178>)
   24070:	4650      	mov	r0, sl
   24072:	f013 fe7c 	bl	37d6e <log_string_sync>
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
   24076:	9b03      	ldr	r3, [sp, #12]
			nvs_ate_crc8_update(&gc_ate);
   24078:	a80a      	add	r0, sp, #40	; 0x28
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
   2407a:	ea0b 0703 	and.w	r7, fp, r3
			data_addr += gc_ate.offset;
   2407e:	f8bd 302a 	ldrh.w	r3, [sp, #42]	; 0x2a
   24082:	441f      	add	r7, r3
			gc_ate.offset = (u16_t)(fs->data_wra & ADDR_OFFS_MASK);
   24084:	68a3      	ldr	r3, [r4, #8]
   24086:	f8ad 302a 	strh.w	r3, [sp, #42]	; 0x2a
			nvs_ate_crc8_update(&gc_ate);
   2408a:	f013 feee 	bl	37e6a <nvs_ate_crc8_update>
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   2408e:	7c26      	ldrb	r6, [r4, #16]
			rc = nvs_flash_block_move(fs, data_addr, gc_ate.len);
   24090:	f8bd 902c 	ldrh.w	r9, [sp, #44]	; 0x2c
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   24094:	4276      	negs	r6, r6
   24096:	f006 0620 	and.w	r6, r6, #32
	while (len) {
   2409a:	f1b9 0f00 	cmp.w	r9, #0
   2409e:	d18f      	bne.n	23fc0 <nvs_gc+0x5c>
			rc = nvs_flash_ate_wrt(fs, &gc_ate);
   240a0:	a90a      	add	r1, sp, #40	; 0x28
   240a2:	4620      	mov	r0, r4
   240a4:	f013 ff67 	bl	37f76 <nvs_flash_ate_wrt>
			if (rc) {
   240a8:	4602      	mov	r2, r0
   240aa:	2800      	cmp	r0, #0
   240ac:	d0aa      	beq.n	24004 <nvs_gc+0xa0>
	rc = nvs_flash_erase_sector(fs, sec_addr);
	if (rc) {
		return rc;
	}
	return 0;
}
   240ae:	4610      	mov	r0, r2
   240b0:	b017      	add	sp, #92	; 0x5c
   240b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	stop_addr = gc_addr - ate_size;
   240b6:	9b06      	ldr	r3, [sp, #24]
	gc_addr &= ADDR_SECT_MASK;
   240b8:	4a09      	ldr	r2, [pc, #36]	; (240e0 <nvs_gc+0x17c>)
	gc_addr += close_ate.offset;
   240ba:	f8bd 1022 	ldrh.w	r1, [sp, #34]	; 0x22
	stop_addr = gc_addr - ate_size;
   240be:	eba3 0808 	sub.w	r8, r3, r8
	gc_addr &= ADDR_SECT_MASK;
   240c2:	4013      	ands	r3, r2
	gc_addr += close_ate.offset;
   240c4:	440b      	add	r3, r1
   240c6:	9306      	str	r3, [sp, #24]
			LOG_DBG("Moving %d, len %d", gc_ate.id, gc_ate.len);
   240c8:	4906      	ldr	r1, [pc, #24]	; (240e4 <nvs_gc+0x180>)
   240ca:	4b07      	ldr	r3, [pc, #28]	; (240e8 <nvs_gc+0x184>)
   240cc:	1a5b      	subs	r3, r3, r1
   240ce:	f3c3 03c9 	ubfx	r3, r3, #3, #10
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
   240d2:	e9cd 3202 	strd	r3, r2, [sp, #8]
   240d6:	e797      	b.n	24008 <nvs_gc+0xa4>
   240d8:	0003ce42 	.word	0x0003ce42
   240dc:	0003ce7e 	.word	0x0003ce7e
   240e0:	ffff0000 	.word	0xffff0000
   240e4:	0003ade0 	.word	0x0003ade0
   240e8:	0003ae40 	.word	0x0003ae40

000240ec <nvs_init>:
	}
	return 0;
}

int nvs_init(struct nvs_fs *fs, const char *dev_name)
{
   240ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   240f0:	4604      	mov	r4, r0
   240f2:	b087      	sub	sp, #28
   240f4:	460d      	mov	r5, r1

	int rc;
	struct flash_pages_info info;

	k_mutex_init(&fs->nvs_lock);
   240f6:	f100 0614 	add.w	r6, r0, #20
	return z_impl_k_mutex_init(mutex);
   240fa:	4630      	mov	r0, r6
   240fc:	f015 fc8e 	bl	39a1c <z_impl_k_mutex_init>
   24100:	4628      	mov	r0, r5
   24102:	f00e f911 	bl	32328 <z_impl_device_get_binding>

	fs->flash_device = device_get_binding(dev_name);
   24106:	62a0      	str	r0, [r4, #40]	; 0x28
	if (!fs->flash_device) {
   24108:	b988      	cbnz	r0, 2412e <nvs_init+0x42>
		LOG_ERR("No valid flash device found");
   2410a:	2301      	movs	r3, #1
   2410c:	4aa1      	ldr	r2, [pc, #644]	; (24394 <nvs_init+0x2a8>)
   2410e:	f363 0007 	bfi	r0, r3, #0, #8
   24112:	4ba1      	ldr	r3, [pc, #644]	; (24398 <nvs_init+0x2ac>)
   24114:	49a1      	ldr	r1, [pc, #644]	; (2439c <nvs_init+0x2b0>)
   24116:	1a9b      	subs	r3, r3, r2
   24118:	08db      	lsrs	r3, r3, #3
   2411a:	f363 108f 	bfi	r0, r3, #6, #10
   2411e:	f013 fe26 	bl	37d6e <log_string_sync>
		return -ENXIO;
   24122:	f06f 0505 	mvn.w	r5, #5
	LOG_INF("data wra: %d, %x",
		(fs->data_wra >> ADDR_SECT_SHIFT),
		(fs->data_wra & ADDR_OFFS_MASK));

	return 0;
}
   24126:	4628      	mov	r0, r5
   24128:	b007      	add	sp, #28
   2412a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
static inline size_t z_impl_flash_get_write_block_size(struct device *dev)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->driver_api;

	return api->write_block_size;
   2412e:	6843      	ldr	r3, [r0, #4]
	fs->write_block_size = flash_get_write_block_size(fs->flash_device);
   24130:	7d1b      	ldrb	r3, [r3, #20]
	if (fs->write_block_size > NVS_BLOCK_SIZE) {
   24132:	2b20      	cmp	r3, #32
	fs->write_block_size = flash_get_write_block_size(fs->flash_device);
   24134:	7423      	strb	r3, [r4, #16]
	if (fs->write_block_size > NVS_BLOCK_SIZE) {
   24136:	d910      	bls.n	2415a <nvs_init+0x6e>
		LOG_ERR("Unsupported write block size");
   24138:	2301      	movs	r3, #1
   2413a:	f04f 0000 	mov.w	r0, #0
   2413e:	4a95      	ldr	r2, [pc, #596]	; (24394 <nvs_init+0x2a8>)
   24140:	f363 0007 	bfi	r0, r3, #0, #8
   24144:	4b94      	ldr	r3, [pc, #592]	; (24398 <nvs_init+0x2ac>)
   24146:	4996      	ldr	r1, [pc, #600]	; (243a0 <nvs_init+0x2b4>)
   24148:	1a9b      	subs	r3, r3, r2
   2414a:	08db      	lsrs	r3, r3, #3
   2414c:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Unable to get page info");
   24150:	f013 fe0d 	bl	37d6e <log_string_sync>
		return -EINVAL;
   24154:	f06f 0515 	mvn.w	r5, #21
   24158:	e7e5      	b.n	24126 <nvs_init+0x3a>
	rc = flash_get_page_info_by_offs(fs->flash_device, fs->offset, &info);
   2415a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   2415c:	6821      	ldr	r1, [r4, #0]
   2415e:	aa03      	add	r2, sp, #12
   24160:	f014 fdac 	bl	38cbc <z_impl_flash_get_page_info_by_offs>
	if (rc) {
   24164:	b160      	cbz	r0, 24180 <nvs_init+0x94>
		LOG_ERR("Unable to get page info");
   24166:	2301      	movs	r3, #1
   24168:	f04f 0000 	mov.w	r0, #0
   2416c:	4a89      	ldr	r2, [pc, #548]	; (24394 <nvs_init+0x2a8>)
   2416e:	f363 0007 	bfi	r0, r3, #0, #8
   24172:	4b89      	ldr	r3, [pc, #548]	; (24398 <nvs_init+0x2ac>)
   24174:	498b      	ldr	r1, [pc, #556]	; (243a4 <nvs_init+0x2b8>)
   24176:	1a9b      	subs	r3, r3, r2
   24178:	08db      	lsrs	r3, r3, #3
   2417a:	f363 108f 	bfi	r0, r3, #6, #10
   2417e:	e7e7      	b.n	24150 <nvs_init+0x64>
	if (!fs->sector_size || fs->sector_size % info.size) {
   24180:	89a3      	ldrh	r3, [r4, #12]
   24182:	b12b      	cbz	r3, 24190 <nvs_init+0xa4>
   24184:	9a04      	ldr	r2, [sp, #16]
   24186:	fbb3 f5f2 	udiv	r5, r3, r2
   2418a:	fb02 3515 	mls	r5, r2, r5, r3
   2418e:	b165      	cbz	r5, 241aa <nvs_init+0xbe>
		LOG_ERR("Invalid sector size");
   24190:	2301      	movs	r3, #1
   24192:	f04f 0000 	mov.w	r0, #0
   24196:	4a7f      	ldr	r2, [pc, #508]	; (24394 <nvs_init+0x2a8>)
   24198:	f363 0007 	bfi	r0, r3, #0, #8
   2419c:	4b7e      	ldr	r3, [pc, #504]	; (24398 <nvs_init+0x2ac>)
   2419e:	4982      	ldr	r1, [pc, #520]	; (243a8 <nvs_init+0x2bc>)
   241a0:	1a9b      	subs	r3, r3, r2
   241a2:	08db      	lsrs	r3, r3, #3
   241a4:	f363 108f 	bfi	r0, r3, #6, #10
   241a8:	e7d2      	b.n	24150 <nvs_init+0x64>
	if (fs->sector_count < 2) {
   241aa:	89e3      	ldrh	r3, [r4, #14]
   241ac:	2b01      	cmp	r3, #1
   241ae:	d80c      	bhi.n	241ca <nvs_init+0xde>
		LOG_ERR("Configuration error - sector count");
   241b0:	2301      	movs	r3, #1
   241b2:	f04f 0000 	mov.w	r0, #0
   241b6:	4a77      	ldr	r2, [pc, #476]	; (24394 <nvs_init+0x2a8>)
   241b8:	f363 0007 	bfi	r0, r3, #0, #8
   241bc:	4b76      	ldr	r3, [pc, #472]	; (24398 <nvs_init+0x2ac>)
   241be:	497b      	ldr	r1, [pc, #492]	; (243ac <nvs_init+0x2c0>)
   241c0:	1a9b      	subs	r3, r3, r2
   241c2:	08db      	lsrs	r3, r3, #3
   241c4:	f363 108f 	bfi	r0, r3, #6, #10
   241c8:	e7c2      	b.n	24150 <nvs_init+0x64>
	u32_t addr = 0U;
   241ca:	9500      	str	r5, [sp, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
   241cc:	f04f 31ff 	mov.w	r1, #4294967295
   241d0:	4630      	mov	r0, r6
   241d2:	f00e fd8d 	bl	32cf0 <z_impl_k_mutex_lock>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   241d6:	2108      	movs	r1, #8
   241d8:	7c20      	ldrb	r0, [r4, #16]
   241da:	f013 fe4f 	bl	37e7c <nvs_al_size.isra.1>
	u16_t i, closed_sectors = 0;
   241de:	46a9      	mov	r9, r5
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   241e0:	4607      	mov	r7, r0
	for (i = 0; i < fs->sector_count; i++) {
   241e2:	89e3      	ldrh	r3, [r4, #14]
   241e4:	fa1f f885 	uxth.w	r8, r5
   241e8:	4543      	cmp	r3, r8
   241ea:	d805      	bhi.n	241f8 <nvs_init+0x10c>
	if (closed_sectors == fs->sector_count) {
   241ec:	89e3      	ldrh	r3, [r4, #14]
   241ee:	454b      	cmp	r3, r9
   241f0:	d11e      	bne.n	24230 <nvs_init+0x144>
		return -EDEADLK;
   241f2:	f06f 052c 	mvn.w	r5, #44	; 0x2c
   241f6:	e796      	b.n	24126 <nvs_init+0x3a>
		       (u16_t)(fs->sector_size - ate_size);
   241f8:	89a1      	ldrh	r1, [r4, #12]
		addr = (i << ADDR_SECT_SHIFT) +
   241fa:	042b      	lsls	r3, r5, #16
		       (u16_t)(fs->sector_size - ate_size);
   241fc:	1bc9      	subs	r1, r1, r7
		addr = (i << ADDR_SECT_SHIFT) +
   241fe:	fa13 f181 	uxtah	r1, r3, r1
		rc = nvs_flash_cmp_const(fs, addr, 0xff,
   24202:	2208      	movs	r2, #8
   24204:	4620      	mov	r0, r4
		addr = (i << ADDR_SECT_SHIFT) +
   24206:	9100      	str	r1, [sp, #0]
		rc = nvs_flash_cmp_const(fs, addr, 0xff,
   24208:	f013 fe4b 	bl	37ea2 <nvs_flash_cmp_const.constprop.5>
		if (rc) {
   2420c:	b170      	cbz	r0, 2422c <nvs_init+0x140>
			nvs_sector_advance(fs, &addr);
   2420e:	4669      	mov	r1, sp
   24210:	89e0      	ldrh	r0, [r4, #14]
   24212:	f013 fe3c 	bl	37e8e <nvs_sector_advance.isra.2>
			closed_sectors++;
   24216:	f109 0901 	add.w	r9, r9, #1
			rc = nvs_flash_cmp_const(fs, addr, 0xff,
   2421a:	2208      	movs	r2, #8
   2421c:	9900      	ldr	r1, [sp, #0]
   2421e:	4620      	mov	r0, r4
			closed_sectors++;
   24220:	fa1f f989 	uxth.w	r9, r9
			rc = nvs_flash_cmp_const(fs, addr, 0xff,
   24224:	f013 fe3d 	bl	37ea2 <nvs_flash_cmp_const.constprop.5>
			if (!rc) {
   24228:	2800      	cmp	r0, #0
   2422a:	d0df      	beq.n	241ec <nvs_init+0x100>
   2422c:	3501      	adds	r5, #1
   2422e:	e7d8      	b.n	241e2 <nvs_init+0xf6>
	if (i == fs->sector_count) {
   24230:	4598      	cmp	r8, r3
   24232:	d10a      	bne.n	2424a <nvs_init+0x15e>
		rc = nvs_flash_cmp_const(fs, addr - ate_size, 0xff,
   24234:	9900      	ldr	r1, [sp, #0]
   24236:	2208      	movs	r2, #8
   24238:	1bc9      	subs	r1, r1, r7
   2423a:	4620      	mov	r0, r4
   2423c:	f013 fe31 	bl	37ea2 <nvs_flash_cmp_const.constprop.5>
		if (!rc) {
   24240:	b918      	cbnz	r0, 2424a <nvs_init+0x15e>
			nvs_sector_advance(fs, &addr);
   24242:	4669      	mov	r1, sp
   24244:	89e0      	ldrh	r0, [r4, #14]
   24246:	f013 fe22 	bl	37e8e <nvs_sector_advance.isra.2>
	fs->ate_wra = addr - ate_size;
   2424a:	9b00      	ldr	r3, [sp, #0]
   2424c:	1bda      	subs	r2, r3, r7
   2424e:	6062      	str	r2, [r4, #4]
	fs->data_wra = addr & ADDR_SECT_MASK;
   24250:	4a57      	ldr	r2, [pc, #348]	; (243b0 <nvs_init+0x2c4>)
			fs->data_wra = addr & ADDR_SECT_MASK;
   24252:	4690      	mov	r8, r2
	fs->data_wra = addr & ADDR_SECT_MASK;
   24254:	4013      	ands	r3, r2
   24256:	60a3      	str	r3, [r4, #8]
	while (fs->ate_wra >= fs->data_wra) {
   24258:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
   2425c:	4299      	cmp	r1, r3
   2425e:	d30e      	bcc.n	2427e <nvs_init+0x192>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   24260:	2308      	movs	r3, #8
   24262:	aa01      	add	r2, sp, #4
   24264:	4620      	mov	r0, r4
   24266:	f013 fdbe 	bl	37de6 <nvs_flash_rd>
		if (rc) {
   2426a:	4605      	mov	r5, r0
   2426c:	bb18      	cbnz	r0, 242b6 <nvs_init+0x1ca>
   2426e:	ab01      	add	r3, sp, #4
		if (data8[i] != value) {
   24270:	f813 2b01 	ldrb.w	r2, [r3], #1
   24274:	2aff      	cmp	r2, #255	; 0xff
   24276:	d175      	bne.n	24364 <nvs_init+0x278>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   24278:	3501      	adds	r5, #1
   2427a:	2d08      	cmp	r5, #8
   2427c:	d1f8      	bne.n	24270 <nvs_init+0x184>
	while (fs->ate_wra > fs->data_wra) {
   2427e:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
   24282:	428a      	cmp	r2, r1
   24284:	d906      	bls.n	24294 <nvs_init+0x1a8>
		rc = nvs_flash_cmp_const(fs, fs->data_wra, 0xff, empty_len);
   24286:	1a52      	subs	r2, r2, r1
   24288:	4620      	mov	r0, r4
   2428a:	f013 fe0a 	bl	37ea2 <nvs_flash_cmp_const.constprop.5>
		if (rc < 0) {
   2428e:	1e05      	subs	r5, r0, #0
   24290:	db11      	blt.n	242b6 <nvs_init+0x1ca>
		if (!rc) {
   24292:	d14a      	bne.n	2432a <nvs_init+0x23e>
	addr = fs->ate_wra & ADDR_SECT_MASK;
   24294:	6863      	ldr	r3, [r4, #4]
   24296:	f8df 8118 	ldr.w	r8, [pc, #280]	; 243b0 <nvs_init+0x2c4>
	nvs_sector_advance(fs, &addr);
   2429a:	4669      	mov	r1, sp
	addr = fs->ate_wra & ADDR_SECT_MASK;
   2429c:	ea03 0308 	and.w	r3, r3, r8
	nvs_sector_advance(fs, &addr);
   242a0:	89e0      	ldrh	r0, [r4, #14]
	addr = fs->ate_wra & ADDR_SECT_MASK;
   242a2:	9300      	str	r3, [sp, #0]
	nvs_sector_advance(fs, &addr);
   242a4:	f013 fdf3 	bl	37e8e <nvs_sector_advance.isra.2>
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
   242a8:	89a2      	ldrh	r2, [r4, #12]
   242aa:	9900      	ldr	r1, [sp, #0]
   242ac:	4620      	mov	r0, r4
   242ae:	f013 fdf8 	bl	37ea2 <nvs_flash_cmp_const.constprop.5>
	if (rc < 0) {
   242b2:	1e05      	subs	r5, r0, #0
   242b4:	da3e      	bge.n	24334 <nvs_init+0x248>
	return z_impl_k_mutex_unlock(mutex);
   242b6:	4630      	mov	r0, r6
   242b8:	f00e fdf8 	bl	32eac <z_impl_k_mutex_unlock>
	if (rc) {
   242bc:	2d00      	cmp	r5, #0
   242be:	f47f af32 	bne.w	24126 <nvs_init+0x3a>
	fs->ready = true;
   242c2:	2301      	movs	r3, #1
	LOG_INF("%d Sectors of %d bytes", fs->sector_count, fs->sector_size);
   242c4:	f04f 0000 	mov.w	r0, #0
	fs->ready = true;
   242c8:	7463      	strb	r3, [r4, #17]
	LOG_INF("%d Sectors of %d bytes", fs->sector_count, fs->sector_size);
   242ca:	2303      	movs	r3, #3
   242cc:	4e32      	ldr	r6, [pc, #200]	; (24398 <nvs_init+0x2ac>)
   242ce:	f363 0007 	bfi	r0, r3, #0, #8
   242d2:	4b30      	ldr	r3, [pc, #192]	; (24394 <nvs_init+0x2a8>)
   242d4:	89e2      	ldrh	r2, [r4, #14]
   242d6:	1af6      	subs	r6, r6, r3
   242d8:	f3c6 06c9 	ubfx	r6, r6, #3, #10
   242dc:	f366 108f 	bfi	r0, r6, #6, #10
   242e0:	89a3      	ldrh	r3, [r4, #12]
   242e2:	4934      	ldr	r1, [pc, #208]	; (243b4 <nvs_init+0x2c8>)
   242e4:	f013 fd43 	bl	37d6e <log_string_sync>
	LOG_INF("alloc wra: %d, %x",
   242e8:	2303      	movs	r3, #3
   242ea:	f04f 0000 	mov.w	r0, #0
   242ee:	6862      	ldr	r2, [r4, #4]
   242f0:	f363 0007 	bfi	r0, r3, #0, #8
   242f4:	f366 108f 	bfi	r0, r6, #6, #10
   242f8:	b293      	uxth	r3, r2
   242fa:	492f      	ldr	r1, [pc, #188]	; (243b8 <nvs_init+0x2cc>)
   242fc:	0c12      	lsrs	r2, r2, #16
   242fe:	f013 fd36 	bl	37d6e <log_string_sync>
	LOG_INF("data wra: %d, %x",
   24302:	2303      	movs	r3, #3
   24304:	f04f 0000 	mov.w	r0, #0
   24308:	68a2      	ldr	r2, [r4, #8]
   2430a:	f363 0007 	bfi	r0, r3, #0, #8
   2430e:	f366 108f 	bfi	r0, r6, #6, #10
   24312:	b293      	uxth	r3, r2
   24314:	4929      	ldr	r1, [pc, #164]	; (243bc <nvs_init+0x2d0>)
   24316:	0c12      	lsrs	r2, r2, #16
   24318:	f013 fd29 	bl	37d6e <log_string_sync>
	return 0;
   2431c:	e703      	b.n	24126 <nvs_init+0x3a>
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
   2431e:	f1b9 0f00 	cmp.w	r9, #0
   24322:	d034      	beq.n	2438e <nvs_init+0x2a2>
				return -ESPIPE;
   24324:	f06f 051c 	mvn.w	r5, #28
   24328:	e6fd      	b.n	24126 <nvs_init+0x3a>
		fs->data_wra += fs->write_block_size;
   2432a:	68a3      	ldr	r3, [r4, #8]
   2432c:	7c22      	ldrb	r2, [r4, #16]
   2432e:	4413      	add	r3, r2
   24330:	60a3      	str	r3, [r4, #8]
   24332:	e7a4      	b.n	2427e <nvs_init+0x192>
	if (rc) {
   24334:	d0bf      	beq.n	242b6 <nvs_init+0x1ca>
		rc = nvs_flash_erase_sector(fs, fs->ate_wra);
   24336:	6861      	ldr	r1, [r4, #4]
   24338:	4620      	mov	r0, r4
   2433a:	f7ff fd5f 	bl	23dfc <nvs_flash_erase_sector>
		if (rc) {
   2433e:	4605      	mov	r5, r0
   24340:	2800      	cmp	r0, #0
   24342:	d1b8      	bne.n	242b6 <nvs_init+0x1ca>
		fs->ate_wra &= ADDR_SECT_MASK;
   24344:	6860      	ldr	r0, [r4, #4]
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
   24346:	89a3      	ldrh	r3, [r4, #12]
		fs->ate_wra &= ADDR_SECT_MASK;
   24348:	ea00 0008 	and.w	r0, r0, r8
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
   2434c:	4418      	add	r0, r3
   2434e:	eba0 0047 	sub.w	r0, r0, r7, lsl #1
   24352:	6060      	str	r0, [r4, #4]
		fs->data_wra = (fs->ate_wra & ADDR_SECT_MASK);
   24354:	ea00 0008 	and.w	r0, r0, r8
   24358:	60a0      	str	r0, [r4, #8]
		rc = nvs_gc(fs);
   2435a:	4620      	mov	r0, r4
   2435c:	f7ff fe02 	bl	23f64 <nvs_gc>
   24360:	4605      	mov	r5, r0
		if (rc) {
   24362:	e7a8      	b.n	242b6 <nvs_init+0x1ca>
		if (!nvs_ate_crc8_check(&last_ate)) {
   24364:	a801      	add	r0, sp, #4
   24366:	f013 fd74 	bl	37e52 <nvs_ate_crc8_check>
   2436a:	6865      	ldr	r5, [r4, #4]
   2436c:	b978      	cbnz	r0, 2438e <nvs_init+0x2a2>
			fs->data_wra = addr & ADDR_SECT_MASK;
   2436e:	9800      	ldr	r0, [sp, #0]
			fs->data_wra += last_ate.offset;
   24370:	f8bd 2006 	ldrh.w	r2, [sp, #6]
			fs->data_wra += nvs_al_size(fs, last_ate.len);
   24374:	f8bd 9008 	ldrh.w	r9, [sp, #8]
			fs->data_wra = addr & ADDR_SECT_MASK;
   24378:	ea00 0008 	and.w	r0, r0, r8
			fs->data_wra += last_ate.offset;
   2437c:	4402      	add	r2, r0
			fs->data_wra += nvs_al_size(fs, last_ate.len);
   2437e:	4649      	mov	r1, r9
   24380:	7c20      	ldrb	r0, [r4, #16]
   24382:	f013 fd7b 	bl	37e7c <nvs_al_size.isra.1>
   24386:	4410      	add	r0, r2
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
   24388:	42a8      	cmp	r0, r5
			fs->data_wra += nvs_al_size(fs, last_ate.len);
   2438a:	60a0      	str	r0, [r4, #8]
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
   2438c:	d0c7      	beq.n	2431e <nvs_init+0x232>
		fs->ate_wra -= ate_size;
   2438e:	1bed      	subs	r5, r5, r7
   24390:	6065      	str	r5, [r4, #4]
   24392:	e761      	b.n	24258 <nvs_init+0x16c>
   24394:	0003ade0 	.word	0x0003ade0
   24398:	0003ae40 	.word	0x0003ae40
   2439c:	0003ce94 	.word	0x0003ce94
   243a0:	0003ceb0 	.word	0x0003ceb0
   243a4:	0003cecd 	.word	0x0003cecd
   243a8:	0003cee5 	.word	0x0003cee5
   243ac:	0003cef9 	.word	0x0003cef9
   243b0:	ffff0000 	.word	0xffff0000
   243b4:	0003cf1c 	.word	0x0003cf1c
   243b8:	0003cf33 	.word	0x0003cf33
   243bc:	0003cf45 	.word	0x0003cf45

000243c0 <nvs_write>:

ssize_t nvs_write(struct nvs_fs *fs, u16_t id, const void *data, size_t len)
{
   243c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   243c4:	461e      	mov	r6, r3
	struct nvs_ate wlk_ate;
	u32_t wlk_addr, rd_addr;
	u16_t required_space = 0U; /* no space, appropriate for delete ate */
	bool prev_found = false;

	if (!fs->ready) {
   243c6:	7c43      	ldrb	r3, [r0, #17]
{
   243c8:	b089      	sub	sp, #36	; 0x24
   243ca:	4604      	mov	r4, r0
   243cc:	4689      	mov	r9, r1
   243ce:	4690      	mov	r8, r2
	if (!fs->ready) {
   243d0:	b99b      	cbnz	r3, 243fa <nvs_write+0x3a>
		LOG_ERR("NVS not initialized");
   243d2:	2301      	movs	r3, #1
   243d4:	f04f 0000 	mov.w	r0, #0
   243d8:	4a68      	ldr	r2, [pc, #416]	; (2457c <nvs_write+0x1bc>)
   243da:	f363 0007 	bfi	r0, r3, #0, #8
   243de:	4b68      	ldr	r3, [pc, #416]	; (24580 <nvs_write+0x1c0>)
   243e0:	4968      	ldr	r1, [pc, #416]	; (24584 <nvs_write+0x1c4>)
   243e2:	1a9b      	subs	r3, r3, r2
   243e4:	08db      	lsrs	r3, r3, #3
   243e6:	f363 108f 	bfi	r0, r3, #6, #10
   243ea:	f013 fcc0 	bl	37d6e <log_string_sync>
		return -EACCES;
   243ee:	f06f 050c 	mvn.w	r5, #12
	}
	rc = len;
end:
	k_mutex_unlock(&fs->nvs_lock);
	return rc;
}
   243f2:	4628      	mov	r0, r5
   243f4:	b009      	add	sp, #36	; 0x24
   243f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   243fa:	f890 a010 	ldrb.w	sl, [r0, #16]
   243fe:	2108      	movs	r1, #8
   24400:	4650      	mov	r0, sl
   24402:	f013 fd3b 	bl	37e7c <nvs_al_size.isra.1>
	if ((len > (fs->sector_size - 3 * ate_size)) ||
   24406:	89a3      	ldrh	r3, [r4, #12]
   24408:	eb00 0240 	add.w	r2, r0, r0, lsl #1
   2440c:	1a9b      	subs	r3, r3, r2
   2440e:	42b3      	cmp	r3, r6
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   24410:	4607      	mov	r7, r0
	if ((len > (fs->sector_size - 3 * ate_size)) ||
   24412:	f0c0 80ae 	bcc.w	24572 <nvs_write+0x1b2>
   24416:	b11e      	cbz	r6, 24420 <nvs_write+0x60>
	    ((len > 0) && (data == NULL))) {
   24418:	f1b8 0f00 	cmp.w	r8, #0
   2441c:	f000 80a9 	beq.w	24572 <nvs_write+0x1b2>
	wlk_addr = fs->ate_wra;
   24420:	6863      	ldr	r3, [r4, #4]
   24422:	9303      	str	r3, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   24424:	aa04      	add	r2, sp, #16
   24426:	a903      	add	r1, sp, #12
   24428:	4620      	mov	r0, r4
		rd_addr = wlk_addr;
   2442a:	f8dd b00c 	ldr.w	fp, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   2442e:	f7ff fd27 	bl	23e80 <nvs_prev_ate>
		if (rc) {
   24432:	4605      	mov	r5, r0
   24434:	2800      	cmp	r0, #0
   24436:	d1dc      	bne.n	243f2 <nvs_write+0x32>
		if ((wlk_ate.id == id) && (!nvs_ate_crc8_check(&wlk_ate))) {
   24438:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   2443c:	454b      	cmp	r3, r9
   2443e:	d005      	beq.n	2444c <nvs_write+0x8c>
		if (wlk_addr == fs->ate_wra) {
   24440:	6862      	ldr	r2, [r4, #4]
   24442:	9b03      	ldr	r3, [sp, #12]
   24444:	429a      	cmp	r2, r3
   24446:	d1ed      	bne.n	24424 <nvs_write+0x64>
		if (len == 0) {
   24448:	b9de      	cbnz	r6, 24482 <nvs_write+0xc2>
   2444a:	e7d2      	b.n	243f2 <nvs_write+0x32>
		if ((wlk_ate.id == id) && (!nvs_ate_crc8_check(&wlk_ate))) {
   2444c:	a804      	add	r0, sp, #16
   2444e:	f013 fd00 	bl	37e52 <nvs_ate_crc8_check>
   24452:	2800      	cmp	r0, #0
   24454:	d1f4      	bne.n	24440 <nvs_write+0x80>
		if (len == 0) {
   24456:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   2445a:	b186      	cbz	r6, 2447e <nvs_write+0xbe>
		} else if (len == wlk_ate.len) {
   2445c:	42b3      	cmp	r3, r6
   2445e:	d110      	bne.n	24482 <nvs_write+0xc2>
		rd_addr += wlk_ate.offset;
   24460:	f8bd 0012 	ldrh.w	r0, [sp, #18]
		rd_addr &= ADDR_SECT_MASK;
   24464:	ea4f 411b 	mov.w	r1, fp, lsr #16
   24468:	0409      	lsls	r1, r1, #16
			rc = nvs_flash_block_cmp(fs, rd_addr, data, len);
   2446a:	4401      	add	r1, r0
   2446c:	4633      	mov	r3, r6
   2446e:	4642      	mov	r2, r8
   24470:	4620      	mov	r0, r4
   24472:	f013 fcc6 	bl	37e02 <nvs_flash_block_cmp>
			if (rc <= 0) {
   24476:	2800      	cmp	r0, #0
   24478:	dc03      	bgt.n	24482 <nvs_write+0xc2>
   2447a:	4605      	mov	r5, r0
   2447c:	e7b9      	b.n	243f2 <nvs_write+0x32>
			if (wlk_ate.len == 0U) {
   2447e:	2b00      	cmp	r3, #0
   24480:	d0b7      	beq.n	243f2 <nvs_write+0x32>
	data_size = nvs_al_size(fs, len);
   24482:	4631      	mov	r1, r6
   24484:	4650      	mov	r0, sl
   24486:	f013 fcf9 	bl	37e7c <nvs_al_size.isra.1>
	if (data_size) {
   2448a:	2800      	cmp	r0, #0
   2448c:	d13e      	bne.n	2450c <nvs_write+0x14c>
	u16_t required_space = 0U; /* no space, appropriate for delete ate */
   2448e:	4607      	mov	r7, r0
	k_mutex_lock(&fs->nvs_lock, K_FOREVER);
   24490:	f104 0a14 	add.w	sl, r4, #20
	return z_impl_k_mutex_lock(mutex, timeout);
   24494:	f04f 31ff 	mov.w	r1, #4294967295
   24498:	4650      	mov	r0, sl
   2449a:	f00e fc29 	bl	32cf0 <z_impl_k_mutex_lock>
	gc_count = 0;
   2449e:	2300      	movs	r3, #0
	fs->ate_wra &= ADDR_SECT_MASK;
   244a0:	f8df b0e4 	ldr.w	fp, [pc, #228]	; 24588 <nvs_write+0x1c8>
		if (gc_count == fs->sector_count) {
   244a4:	89e2      	ldrh	r2, [r4, #14]
   244a6:	4293      	cmp	r3, r2
   244a8:	d060      	beq.n	2456c <nvs_write+0x1ac>
		if (fs->ate_wra >= fs->data_wra + required_space) {
   244aa:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
   244ae:	1878      	adds	r0, r7, r1
   244b0:	4282      	cmp	r2, r0
   244b2:	d32e      	bcc.n	24512 <nvs_write+0x152>
	entry.part = 0xff;
   244b4:	23ff      	movs	r3, #255	; 0xff
	nvs_ate_crc8_update(&entry);
   244b6:	a806      	add	r0, sp, #24
	entry.id = id;
   244b8:	f8ad 9018 	strh.w	r9, [sp, #24]
	entry.offset = (u16_t)(fs->data_wra & ADDR_OFFS_MASK);
   244bc:	f8ad 101a 	strh.w	r1, [sp, #26]
	entry.len = (u16_t)len;
   244c0:	f8ad 601c 	strh.w	r6, [sp, #28]
	entry.part = 0xff;
   244c4:	f88d 301e 	strb.w	r3, [sp, #30]
	nvs_ate_crc8_update(&entry);
   244c8:	f013 fccf 	bl	37e6a <nvs_ate_crc8_update>
	if (!len) {
   244cc:	b136      	cbz	r6, 244dc <nvs_write+0x11c>
   244ce:	4633      	mov	r3, r6
   244d0:	4642      	mov	r2, r8
   244d2:	68a1      	ldr	r1, [r4, #8]
   244d4:	4620      	mov	r0, r4
   244d6:	f013 fd08 	bl	37eea <nvs_flash_al_wrt.part.3>
   244da:	4605      	mov	r5, r0
	fs->data_wra += nvs_al_size(fs, len);
   244dc:	4631      	mov	r1, r6
   244de:	7c20      	ldrb	r0, [r4, #16]
   244e0:	f013 fccc 	bl	37e7c <nvs_al_size.isra.1>
   244e4:	68a3      	ldr	r3, [r4, #8]
   244e6:	4418      	add	r0, r3
   244e8:	60a0      	str	r0, [r4, #8]
	if (rc) {
   244ea:	2d00      	cmp	r5, #0
   244ec:	d144      	bne.n	24578 <nvs_write+0x1b8>
	rc = nvs_flash_ate_wrt(fs, &entry);
   244ee:	a906      	add	r1, sp, #24
   244f0:	4620      	mov	r0, r4
   244f2:	f013 fd40 	bl	37f76 <nvs_flash_ate_wrt>
	if (rc) {
   244f6:	4605      	mov	r5, r0
   244f8:	2800      	cmp	r0, #0
   244fa:	d13d      	bne.n	24578 <nvs_write+0x1b8>
	rc = len;
   244fc:	4632      	mov	r2, r6
   244fe:	9201      	str	r2, [sp, #4]
	return z_impl_k_mutex_unlock(mutex);
   24500:	4650      	mov	r0, sl
   24502:	f00e fcd3 	bl	32eac <z_impl_k_mutex_unlock>
	return rc;
   24506:	9a01      	ldr	r2, [sp, #4]
   24508:	4615      	mov	r5, r2
   2450a:	e772      	b.n	243f2 <nvs_write+0x32>
		required_space = data_size + ate_size;
   2450c:	4407      	add	r7, r0
   2450e:	b2bf      	uxth	r7, r7
   24510:	e7be      	b.n	24490 <nvs_write+0xd0>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   24512:	2108      	movs	r1, #8
   24514:	7c20      	ldrb	r0, [r4, #16]
   24516:	9301      	str	r3, [sp, #4]
   24518:	f013 fcb0 	bl	37e7c <nvs_al_size.isra.1>
	close_ate.id = 0xFFFF;
   2451c:	f64f 71ff 	movw	r1, #65535	; 0xffff
   24520:	f8ad 1018 	strh.w	r1, [sp, #24]
	close_ate.len = 0U;
   24524:	2100      	movs	r1, #0
   24526:	f8ad 101c 	strh.w	r1, [sp, #28]
	close_ate.offset = (u16_t)((fs->ate_wra + ate_size) & ADDR_OFFS_MASK);
   2452a:	1811      	adds	r1, r2, r0
   2452c:	f8ad 101a 	strh.w	r1, [sp, #26]
	fs->ate_wra += (fs->sector_size - ate_size);
   24530:	89a1      	ldrh	r1, [r4, #12]
	fs->ate_wra &= ADDR_SECT_MASK;
   24532:	ea02 020b 	and.w	r2, r2, fp
	fs->ate_wra += (fs->sector_size - ate_size);
   24536:	440a      	add	r2, r1
   24538:	1a12      	subs	r2, r2, r0
   2453a:	6062      	str	r2, [r4, #4]
	nvs_ate_crc8_update(&close_ate);
   2453c:	a806      	add	r0, sp, #24
   2453e:	f013 fc94 	bl	37e6a <nvs_ate_crc8_update>
	rc = nvs_flash_ate_wrt(fs, &close_ate);
   24542:	a906      	add	r1, sp, #24
   24544:	4620      	mov	r0, r4
   24546:	f013 fd16 	bl	37f76 <nvs_flash_ate_wrt>
	nvs_sector_advance(fs, &fs->ate_wra);
   2454a:	1d21      	adds	r1, r4, #4
   2454c:	89e0      	ldrh	r0, [r4, #14]
   2454e:	f013 fc9e 	bl	37e8e <nvs_sector_advance.isra.2>
	fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
   24552:	6862      	ldr	r2, [r4, #4]
		rc = nvs_gc(fs);
   24554:	4620      	mov	r0, r4
	fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
   24556:	ea02 020b 	and.w	r2, r2, fp
   2455a:	60a2      	str	r2, [r4, #8]
		rc = nvs_gc(fs);
   2455c:	f7ff fd02 	bl	23f64 <nvs_gc>
		if (rc) {
   24560:	4602      	mov	r2, r0
   24562:	2800      	cmp	r0, #0
   24564:	d1cb      	bne.n	244fe <nvs_write+0x13e>
		gc_count++;
   24566:	9b01      	ldr	r3, [sp, #4]
   24568:	3301      	adds	r3, #1
		if (gc_count == fs->sector_count) {
   2456a:	e79b      	b.n	244a4 <nvs_write+0xe4>
			rc = -ENOSPC;
   2456c:	f06f 021b 	mvn.w	r2, #27
   24570:	e7c5      	b.n	244fe <nvs_write+0x13e>
		return -EINVAL;
   24572:	f06f 0515 	mvn.w	r5, #21
   24576:	e73c      	b.n	243f2 <nvs_write+0x32>
			if (rc) {
   24578:	462a      	mov	r2, r5
   2457a:	e7c0      	b.n	244fe <nvs_write+0x13e>
   2457c:	0003ade0 	.word	0x0003ade0
   24580:	0003ae40 	.word	0x0003ae40
   24584:	0003ce49 	.word	0x0003ce49
   24588:	ffff0000 	.word	0xffff0000

0002458c <nvs_read_hist>:
	return nvs_write(fs, id, NULL, 0);
}

ssize_t nvs_read_hist(struct nvs_fs *fs, u16_t id, void *data, size_t len,
		      u16_t cnt)
{
   2458c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   24590:	461f      	mov	r7, r3
	u32_t wlk_addr, rd_addr;
	u16_t cnt_his;
	struct nvs_ate wlk_ate;
	size_t ate_size;

	if (!fs->ready) {
   24592:	7c43      	ldrb	r3, [r0, #17]
{
   24594:	4604      	mov	r4, r0
   24596:	468a      	mov	sl, r1
   24598:	4691      	mov	r9, r2
   2459a:	f8bd 8030 	ldrh.w	r8, [sp, #48]	; 0x30
	if (!fs->ready) {
   2459e:	b993      	cbnz	r3, 245c6 <nvs_read_hist+0x3a>
		LOG_ERR("NVS not initialized");
   245a0:	2301      	movs	r3, #1
   245a2:	f04f 0000 	mov.w	r0, #0
   245a6:	4a2a      	ldr	r2, [pc, #168]	; (24650 <nvs_read_hist+0xc4>)
   245a8:	f363 0007 	bfi	r0, r3, #0, #8
   245ac:	4b29      	ldr	r3, [pc, #164]	; (24654 <nvs_read_hist+0xc8>)
   245ae:	492a      	ldr	r1, [pc, #168]	; (24658 <nvs_read_hist+0xcc>)
   245b0:	1a9b      	subs	r3, r3, r2
   245b2:	08db      	lsrs	r3, r3, #3
   245b4:	f363 108f 	bfi	r0, r3, #6, #10
   245b8:	f013 fbd9 	bl	37d6e <log_string_sync>
		return -EACCES;
   245bc:	f06f 000c 	mvn.w	r0, #12

	return wlk_ate.len;

err:
	return rc;
}
   245c0:	b004      	add	sp, #16
   245c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   245c6:	2108      	movs	r1, #8
   245c8:	7c00      	ldrb	r0, [r0, #16]
   245ca:	f013 fc57 	bl	37e7c <nvs_al_size.isra.1>
	if (len > (fs->sector_size - 2 * ate_size)) {
   245ce:	89a3      	ldrh	r3, [r4, #12]
   245d0:	eba3 0040 	sub.w	r0, r3, r0, lsl #1
   245d4:	42b8      	cmp	r0, r7
   245d6:	d338      	bcc.n	2464a <nvs_read_hist+0xbe>
	cnt_his = 0U;
   245d8:	2500      	movs	r5, #0
	wlk_addr = fs->ate_wra;
   245da:	6863      	ldr	r3, [r4, #4]
   245dc:	9301      	str	r3, [sp, #4]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   245de:	aa02      	add	r2, sp, #8
   245e0:	a901      	add	r1, sp, #4
   245e2:	4620      	mov	r0, r4
		rd_addr = wlk_addr;
   245e4:	9e01      	ldr	r6, [sp, #4]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   245e6:	f7ff fc4b 	bl	23e80 <nvs_prev_ate>
		if (rc) {
   245ea:	2800      	cmp	r0, #0
   245ec:	d1e8      	bne.n	245c0 <nvs_read_hist+0x34>
		if ((wlk_ate.id == id) &&  (!nvs_ate_crc8_check(&wlk_ate))) {
   245ee:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   245f2:	4553      	cmp	r3, sl
   245f4:	d105      	bne.n	24602 <nvs_read_hist+0x76>
   245f6:	a802      	add	r0, sp, #8
   245f8:	f013 fc2b 	bl	37e52 <nvs_ate_crc8_check>
   245fc:	b908      	cbnz	r0, 24602 <nvs_read_hist+0x76>
			cnt_his++;
   245fe:	3501      	adds	r5, #1
   24600:	b2ad      	uxth	r5, r5
		if (wlk_addr == fs->ate_wra) {
   24602:	6862      	ldr	r2, [r4, #4]
   24604:	9b01      	ldr	r3, [sp, #4]
   24606:	429a      	cmp	r2, r3
   24608:	d018      	beq.n	2463c <nvs_read_hist+0xb0>
	while (cnt_his <= cnt) {
   2460a:	4545      	cmp	r5, r8
   2460c:	d9e7      	bls.n	245de <nvs_read_hist+0x52>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
   2460e:	f8bd 300c 	ldrh.w	r3, [sp, #12]
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
   24612:	b1bb      	cbz	r3, 24644 <nvs_read_hist+0xb8>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
   24614:	4545      	cmp	r5, r8
   24616:	d315      	bcc.n	24644 <nvs_read_hist+0xb8>
	rd_addr += wlk_ate.offset;
   24618:	f8bd 000a 	ldrh.w	r0, [sp, #10]
	rd_addr &= ADDR_SECT_MASK;
   2461c:	0c31      	lsrs	r1, r6, #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
   2461e:	42bb      	cmp	r3, r7
	rd_addr &= ADDR_SECT_MASK;
   24620:	ea4f 4101 	mov.w	r1, r1, lsl #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
   24624:	bf28      	it	cs
   24626:	463b      	movcs	r3, r7
   24628:	4401      	add	r1, r0
   2462a:	464a      	mov	r2, r9
   2462c:	4620      	mov	r0, r4
   2462e:	f013 fbda 	bl	37de6 <nvs_flash_rd>
	if (rc) {
   24632:	2800      	cmp	r0, #0
   24634:	d1c4      	bne.n	245c0 <nvs_read_hist+0x34>
	return wlk_ate.len;
   24636:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   2463a:	e7c1      	b.n	245c0 <nvs_read_hist+0x34>
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
   2463c:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   24640:	4553      	cmp	r3, sl
   24642:	d0e4      	beq.n	2460e <nvs_read_hist+0x82>
		return -ENOENT;
   24644:	f06f 0001 	mvn.w	r0, #1
   24648:	e7ba      	b.n	245c0 <nvs_read_hist+0x34>
		return -EINVAL;
   2464a:	f06f 0015 	mvn.w	r0, #21
   2464e:	e7b7      	b.n	245c0 <nvs_read_hist+0x34>
   24650:	0003ade0 	.word	0x0003ade0
   24654:	0003ae40 	.word	0x0003ae40
   24658:	0003ce49 	.word	0x0003ce49

0002465c <socket_offload_register>:

/* Only one provider may register socket operations upon boot. */
const struct socket_offload *socket_ops;

void socket_offload_register(const struct socket_offload *ops)
{
   2465c:	b538      	push	{r3, r4, r5, lr}
	__ASSERT_NO_MSG(ops);
   2465e:	4605      	mov	r5, r0
   24660:	b948      	cbnz	r0, 24676 <socket_offload_register+0x1a>
   24662:	490c      	ldr	r1, [pc, #48]	; (24694 <socket_offload_register+0x38>)
   24664:	480c      	ldr	r0, [pc, #48]	; (24698 <socket_offload_register+0x3c>)
   24666:	2311      	movs	r3, #17
   24668:	4a0c      	ldr	r2, [pc, #48]	; (2469c <socket_offload_register+0x40>)
   2466a:	f013 fb29 	bl	37cc0 <printk>
   2466e:	2111      	movs	r1, #17
   24670:	480a      	ldr	r0, [pc, #40]	; (2469c <socket_offload_register+0x40>)
   24672:	f013 fb6b 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops == NULL);
   24676:	4c0a      	ldr	r4, [pc, #40]	; (246a0 <socket_offload_register+0x44>)
   24678:	6822      	ldr	r2, [r4, #0]
   2467a:	b14a      	cbz	r2, 24690 <socket_offload_register+0x34>
   2467c:	4909      	ldr	r1, [pc, #36]	; (246a4 <socket_offload_register+0x48>)
   2467e:	4806      	ldr	r0, [pc, #24]	; (24698 <socket_offload_register+0x3c>)
   24680:	2312      	movs	r3, #18
   24682:	4a06      	ldr	r2, [pc, #24]	; (2469c <socket_offload_register+0x40>)
   24684:	f013 fb1c 	bl	37cc0 <printk>
   24688:	2112      	movs	r1, #18
   2468a:	4804      	ldr	r0, [pc, #16]	; (2469c <socket_offload_register+0x40>)
   2468c:	f013 fb5e 	bl	37d4c <assert_post_action>

	socket_ops = ops;
   24690:	6025      	str	r5, [r4, #0]
}
   24692:	bd38      	pop	{r3, r4, r5, pc}
   24694:	0003c548 	.word	0x0003c548
   24698:	0003baac 	.word	0x0003baac
   2469c:	0003cf6e 	.word	0x0003cf6e
   246a0:	200204c0 	.word	0x200204c0
   246a4:	0003cfa9 	.word	0x0003cfa9

000246a8 <clk_init>:
 * symbol.
 */
void nrf_power_clock_isr(void *arg);

static int clk_init(struct device *dev)
{
   246a8:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   246aa:	2200      	movs	r2, #0
{
   246ac:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   246ae:	2101      	movs	r1, #1
   246b0:	2005      	movs	r0, #5
   246b2:	f000 fc9d 	bl	24ff0 <z_arm_irq_priority_set>
		    DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0_PRIORITY,
		    nrf_power_clock_isr, 0, 0);

	irq_enable(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0);
   246b6:	2005      	movs	r0, #5
   246b8:	f000 fc8a 	bl	24fd0 <arch_irq_enable>
    return false;
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
   246bc:	2202      	movs	r2, #2
   246be:	4b07      	ldr	r3, [pc, #28]	; (246dc <clk_init+0x34>)
 *
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
   246c0:	2000      	movs	r0, #0
   246c2:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    p_reg->INTENSET = mask;
   246c6:	2203      	movs	r2, #3
   246c8:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

	clock_irqs_enable();

	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		sys_slist_init(&(get_sub_data(dev, i)->list));
   246cc:	68a3      	ldr	r3, [r4, #8]
	list->tail = NULL;
   246ce:	e9c3 0000 	strd	r0, r0, [r3]
   246d2:	68a3      	ldr	r3, [r4, #8]
   246d4:	e9c3 0003 	strd	r0, r0, [r3, #12]
	}

	return 0;
}
   246d8:	bd10      	pop	{r4, pc}
   246da:	bf00      	nop
   246dc:	40005000 	.word	0x40005000

000246e0 <get_status>:
{
   246e0:	b538      	push	{r3, r4, r5, lr}
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   246e2:	b2cc      	uxtb	r4, r1
   246e4:	2c01      	cmp	r4, #1
{
   246e6:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   246e8:	d909      	bls.n	246fe <get_status+0x1e>
   246ea:	490b      	ldr	r1, [pc, #44]	; (24718 <get_status+0x38>)
   246ec:	480b      	ldr	r0, [pc, #44]	; (2471c <get_status+0x3c>)
   246ee:	2384      	movs	r3, #132	; 0x84
   246f0:	4a0b      	ldr	r2, [pc, #44]	; (24720 <get_status+0x40>)
   246f2:	f013 fae5 	bl	37cc0 <printk>
   246f6:	2184      	movs	r1, #132	; 0x84
   246f8:	4809      	ldr	r0, [pc, #36]	; (24720 <get_status+0x40>)
   246fa:	f013 fb27 	bl	37d4c <assert_post_action>
	if (data->started) {
   246fe:	210c      	movs	r1, #12
	data = get_sub_data(dev, type);
   24700:	68ab      	ldr	r3, [r5, #8]
	if (data->started) {
   24702:	fb04 3101 	mla	r1, r4, r1, r3
   24706:	7a4b      	ldrb	r3, [r1, #9]
   24708:	b923      	cbnz	r3, 24714 <get_status+0x34>
	if (data->ref > 0) {
   2470a:	7a08      	ldrb	r0, [r1, #8]
		return CLOCK_CONTROL_STATUS_ON;
   2470c:	fab0 f080 	clz	r0, r0
   24710:	0940      	lsrs	r0, r0, #5
}
   24712:	bd38      	pop	{r3, r4, r5, pc}
		return CLOCK_CONTROL_STATUS_ON;
   24714:	2002      	movs	r0, #2
   24716:	e7fc      	b.n	24712 <get_status+0x32>
   24718:	0003d064 	.word	0x0003d064
   2471c:	0003baac 	.word	0x0003baac
   24720:	0003d029 	.word	0x0003d029

00024724 <clock_async_start>:
{
   24724:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
   24728:	b2ce      	uxtb	r6, r1
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   2472a:	2e01      	cmp	r6, #1
{
   2472c:	4607      	mov	r7, r0
   2472e:	4614      	mov	r4, r2
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   24730:	d909      	bls.n	24746 <clock_async_start+0x22>
   24732:	4949      	ldr	r1, [pc, #292]	; (24858 <clock_async_start+0x134>)
   24734:	4849      	ldr	r0, [pc, #292]	; (2485c <clock_async_start+0x138>)
   24736:	23fd      	movs	r3, #253	; 0xfd
   24738:	4a49      	ldr	r2, [pc, #292]	; (24860 <clock_async_start+0x13c>)
   2473a:	f013 fac1 	bl	37cc0 <printk>
   2473e:	21fd      	movs	r1, #253	; 0xfd
   24740:	4847      	ldr	r0, [pc, #284]	; (24860 <clock_async_start+0x13c>)
   24742:	f013 fb03 	bl	37d4c <assert_post_action>
	const struct nrf_clock_control_config *config =
   24746:	683b      	ldr	r3, [r7, #0]
	clk_data = get_sub_data(dev, type);
   24748:	f8d7 8008 	ldr.w	r8, [r7, #8]
	const struct nrf_clock_control_config *config =
   2474c:	f8d3 9008 	ldr.w	r9, [r3, #8]
	__ASSERT_NO_MSG((data == NULL) ||
   24750:	2c00      	cmp	r4, #0
   24752:	d157      	bne.n	24804 <clock_async_start+0xe0>
	__asm__ volatile(
   24754:	f04f 0320 	mov.w	r3, #32
   24758:	f3ef 8a11 	mrs	sl, BASEPRI
   2475c:	f383 8811 	msr	BASEPRI, r3
   24760:	f3bf 8f6f 	isb	sy
	ref = ++clk_data->ref;
   24764:	230c      	movs	r3, #12
   24766:	fb03 8306 	mla	r3, r3, r6, r8
   2476a:	7a1d      	ldrb	r5, [r3, #8]
   2476c:	3501      	adds	r5, #1
   2476e:	b2ed      	uxtb	r5, r5
   24770:	721d      	strb	r5, [r3, #8]
	__ASSERT_NO_MSG(clk_data->ref > 0);
   24772:	b95d      	cbnz	r5, 2478c <clock_async_start+0x68>
   24774:	493b      	ldr	r1, [pc, #236]	; (24864 <clock_async_start+0x140>)
   24776:	4839      	ldr	r0, [pc, #228]	; (2485c <clock_async_start+0x138>)
   24778:	f44f 7387 	mov.w	r3, #270	; 0x10e
   2477c:	4a38      	ldr	r2, [pc, #224]	; (24860 <clock_async_start+0x13c>)
   2477e:	f013 fa9f 	bl	37cc0 <printk>
   24782:	f44f 7187 	mov.w	r1, #270	; 0x10e
   24786:	4836      	ldr	r0, [pc, #216]	; (24860 <clock_async_start+0x13c>)
   24788:	f013 fae0 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   2478c:	f38a 8811 	msr	BASEPRI, sl
   24790:	f3bf 8f6f 	isb	sy
	if (data) {
   24794:	b32c      	cbz	r4, 247e2 <clock_async_start+0xbe>
    p_reg->INTENCLR = mask;
   24796:	2203      	movs	r2, #3
   24798:	4b33      	ldr	r3, [pc, #204]	; (24868 <clock_async_start+0x144>)
   2479a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
		already_started = clk_data->started;
   2479e:	220c      	movs	r2, #12
   247a0:	4372      	muls	r2, r6
   247a2:	eb08 0302 	add.w	r3, r8, r2
   247a6:	7a59      	ldrb	r1, [r3, #9]
		if (!already_started) {
   247a8:	b991      	cbnz	r1, 247d0 <clock_async_start+0xac>
	__asm__ volatile(
   247aa:	f04f 0020 	mov.w	r0, #32
   247ae:	f3ef 8c11 	mrs	ip, BASEPRI
   247b2:	f380 8811 	msr	BASEPRI, r0
   247b6:	f3bf 8f6f 	isb	sy
	return node->next;
}

static inline void z_snode_next_set(sys_snode_t *parent, sys_snode_t *child)
{
	parent->next = child;
   247ba:	6021      	str	r1, [r4, #0]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
   247bc:	6858      	ldr	r0, [r3, #4]
   247be:	2800      	cmp	r0, #0
   247c0:	d13a      	bne.n	24838 <clock_async_start+0x114>
	list->tail = node;
   247c2:	605c      	str	r4, [r3, #4]
	list->head = node;
   247c4:	f848 4002 	str.w	r4, [r8, r2]
	__asm__ volatile(
   247c8:	f38c 8811 	msr	BASEPRI, ip
   247cc:	f3bf 8f6f 	isb	sy
    p_reg->INTENSET = mask;
   247d0:	2203      	movs	r2, #3
   247d2:	4b25      	ldr	r3, [pc, #148]	; (24868 <clock_async_start+0x144>)
   247d4:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		if (already_started) {
   247d8:	b119      	cbz	r1, 247e2 <clock_async_start+0xbe>
			data->cb(dev, data->user_data);
   247da:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
   247de:	4638      	mov	r0, r7
   247e0:	4798      	blx	r3
	if (ref == 1) {
   247e2:	2d01      	cmp	r5, #1
   247e4:	d10c      	bne.n	24800 <clock_async_start+0xdc>
		do_start =  (config->start_handler) ?
   247e6:	0135      	lsls	r5, r6, #4
   247e8:	f859 3005 	ldr.w	r3, [r9, r5]
				config->start_handler(dev) : true;
   247ec:	bb3b      	cbnz	r3, 2483e <clock_async_start+0x11a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   247ee:	2201      	movs	r2, #1
			nrf_clock_task_trigger(NRF_CLOCK,
   247f0:	44a9      	add	r9, r5
   247f2:	f899 300a 	ldrb.w	r3, [r9, #10]
   247f6:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   247fa:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
   247fe:	601a      	str	r2, [r3, #0]
	return 0;
   24800:	2000      	movs	r0, #0
   24802:	e027      	b.n	24854 <clock_async_start+0x130>
	__ASSERT_NO_MSG((data == NULL) ||
   24804:	6863      	ldr	r3, [r4, #4]
   24806:	b95b      	cbnz	r3, 24820 <clock_async_start+0xfc>
   24808:	4918      	ldr	r1, [pc, #96]	; (2486c <clock_async_start+0x148>)
   2480a:	4814      	ldr	r0, [pc, #80]	; (2485c <clock_async_start+0x138>)
   2480c:	f44f 7381 	mov.w	r3, #258	; 0x102
   24810:	4a13      	ldr	r2, [pc, #76]	; (24860 <clock_async_start+0x13c>)
   24812:	f013 fa55 	bl	37cc0 <printk>
   24816:	f44f 7181 	mov.w	r1, #258	; 0x102
   2481a:	4811      	ldr	r0, [pc, #68]	; (24860 <clock_async_start+0x13c>)
   2481c:	f013 fa96 	bl	37d4c <assert_post_action>
	sys_snode_t *item = sys_slist_peek_head(list);
   24820:	230c      	movs	r3, #12
   24822:	4373      	muls	r3, r6
   24824:	f858 3003 	ldr.w	r3, [r8, r3]
		if (item == node) {
   24828:	429c      	cmp	r4, r3
   2482a:	d011      	beq.n	24850 <clock_async_start+0x12c>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2482c:	2b00      	cmp	r3, #0
   2482e:	d091      	beq.n	24754 <clock_async_start+0x30>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   24830:	681b      	ldr	r3, [r3, #0]
	} while (item);
   24832:	2b00      	cmp	r3, #0
   24834:	d1f8      	bne.n	24828 <clock_async_start+0x104>
   24836:	e78d      	b.n	24754 <clock_async_start+0x30>
	parent->next = child;
   24838:	6004      	str	r4, [r0, #0]
	list->tail = node;
   2483a:	605c      	str	r4, [r3, #4]
   2483c:	e7c4      	b.n	247c8 <clock_async_start+0xa4>
				config->start_handler(dev) : true;
   2483e:	4638      	mov	r0, r7
   24840:	4798      	blx	r3
   24842:	2800      	cmp	r0, #0
   24844:	d1d3      	bne.n	247ee <clock_async_start+0xca>
			clkstarted_handle(dev, type);
   24846:	4631      	mov	r1, r6
   24848:	4638      	mov	r0, r7
   2484a:	f013 fbac 	bl	37fa6 <clkstarted_handle>
   2484e:	e7d7      	b.n	24800 <clock_async_start+0xdc>
		return -EBUSY;
   24850:	f06f 000f 	mvn.w	r0, #15
}
   24854:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   24858:	0003d064 	.word	0x0003d064
   2485c:	0003baac 	.word	0x0003baac
   24860:	0003d029 	.word	0x0003d029
   24864:	0003d017 	.word	0x0003d017
   24868:	40005000 	.word	0x40005000
   2486c:	0003cfc9 	.word	0x0003cfc9

00024870 <clock_stop>:
{
   24870:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   24874:	b2cd      	uxtb	r5, r1
   24876:	2d01      	cmp	r5, #1
{
   24878:	4680      	mov	r8, r0
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   2487a:	d909      	bls.n	24890 <clock_stop+0x20>
   2487c:	4925      	ldr	r1, [pc, #148]	; (24914 <clock_stop+0xa4>)
   2487e:	4826      	ldr	r0, [pc, #152]	; (24918 <clock_stop+0xa8>)
   24880:	2399      	movs	r3, #153	; 0x99
   24882:	4a26      	ldr	r2, [pc, #152]	; (2491c <clock_stop+0xac>)
   24884:	f013 fa1c 	bl	37cc0 <printk>
   24888:	2199      	movs	r1, #153	; 0x99
   2488a:	4824      	ldr	r0, [pc, #144]	; (2491c <clock_stop+0xac>)
   2488c:	f013 fa5e 	bl	37d4c <assert_post_action>
	const struct nrf_clock_control_config *config =
   24890:	f8d8 3000 	ldr.w	r3, [r8]
	data = get_sub_data(dev, type);
   24894:	f8d8 7008 	ldr.w	r7, [r8, #8]
	const struct nrf_clock_control_config *config =
   24898:	f8d3 9008 	ldr.w	r9, [r3, #8]
	__asm__ volatile(
   2489c:	f04f 0320 	mov.w	r3, #32
   248a0:	f3ef 8611 	mrs	r6, BASEPRI
   248a4:	f383 8811 	msr	BASEPRI, r3
   248a8:	f3bf 8f6f 	isb	sy
	if (data->ref == 0) {
   248ac:	220c      	movs	r2, #12
   248ae:	436a      	muls	r2, r5
   248b0:	18b9      	adds	r1, r7, r2
   248b2:	7a0b      	ldrb	r3, [r1, #8]
   248b4:	b34b      	cbz	r3, 2490a <clock_stop+0x9a>
	data->ref--;
   248b6:	3b01      	subs	r3, #1
   248b8:	b2db      	uxtb	r3, r3
   248ba:	720b      	strb	r3, [r1, #8]
	if (data->ref == 0) {
   248bc:	bb43      	cbnz	r3, 24910 <clock_stop+0xa0>
		do_stop =  (config->stop_handler) ?
   248be:	012c      	lsls	r4, r5, #4
	list->head = NULL;
   248c0:	50bb      	str	r3, [r7, r2]
	list->tail = NULL;
   248c2:	604b      	str	r3, [r1, #4]
   248c4:	eb09 0304 	add.w	r3, r9, r4
   248c8:	685b      	ldr	r3, [r3, #4]
				config->stop_handler(dev) : true;
   248ca:	b9cb      	cbnz	r3, 24900 <clock_stop+0x90>
   248cc:	2201      	movs	r2, #1
			nrf_clock_task_trigger(NRF_CLOCK, config->stop_tsk);
   248ce:	444c      	add	r4, r9
   248d0:	7ae3      	ldrb	r3, [r4, #11]
   248d2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   248d6:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
   248da:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   248dc:	2200      	movs	r2, #0
   248de:	8923      	ldrh	r3, [r4, #8]
   248e0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   248e4:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
   248e8:	601a      	str	r2, [r3, #0]
		data->started = false;
   248ea:	230c      	movs	r3, #12
   248ec:	2000      	movs	r0, #0
   248ee:	fb05 7503 	mla	r5, r5, r3, r7
   248f2:	7268      	strb	r0, [r5, #9]
	__asm__ volatile(
   248f4:	f386 8811 	msr	BASEPRI, r6
   248f8:	f3bf 8f6f 	isb	sy
}
   248fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				config->stop_handler(dev) : true;
   24900:	4640      	mov	r0, r8
   24902:	4798      	blx	r3
   24904:	2800      	cmp	r0, #0
   24906:	d1e1      	bne.n	248cc <clock_stop+0x5c>
   24908:	e7ef      	b.n	248ea <clock_stop+0x7a>
		err = -EALREADY;
   2490a:	f06f 0077 	mvn.w	r0, #119	; 0x77
   2490e:	e7f1      	b.n	248f4 <clock_stop+0x84>
	int err = 0;
   24910:	2000      	movs	r0, #0
   24912:	e7ef      	b.n	248f4 <clock_stop+0x84>
   24914:	0003d064 	.word	0x0003d064
   24918:	0003baac 	.word	0x0003baac
   2491c:	0003d029 	.word	0x0003d029

00024920 <nrf_power_clock_isr>:
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
   24920:	b508      	push	{r3, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   24922:	4b10      	ldr	r3, [pc, #64]	; (24964 <nrf_power_clock_isr+0x44>)
   24924:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
   24926:	b162      	cbz	r2, 24942 <nrf_power_clock_isr+0x22>
    return p_reg->INTENSET & mask;
   24928:	4a0f      	ldr	r2, [pc, #60]	; (24968 <nrf_power_clock_isr+0x48>)
   2492a:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
   2492e:	07d1      	lsls	r1, r2, #31
   24930:	d507      	bpl.n	24942 <nrf_power_clock_isr+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   24932:	2200      	movs	r2, #0
	struct device *dev = DEVICE_GET(clock_nrf);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
   24934:	480d      	ldr	r0, [pc, #52]	; (2496c <nrf_power_clock_isr+0x4c>)
   24936:	601a      	str	r2, [r3, #0]

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
   24938:	6883      	ldr	r3, [r0, #8]
   2493a:	7a59      	ldrb	r1, [r3, #9]
   2493c:	b909      	cbnz	r1, 24942 <nrf_power_clock_isr+0x22>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
   2493e:	f013 fb32 	bl	37fa6 <clkstarted_handle>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   24942:	4b0b      	ldr	r3, [pc, #44]	; (24970 <nrf_power_clock_isr+0x50>)
   24944:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
   24946:	b162      	cbz	r2, 24962 <nrf_power_clock_isr+0x42>
    return p_reg->INTENSET & mask;
   24948:	4a07      	ldr	r2, [pc, #28]	; (24968 <nrf_power_clock_isr+0x48>)
   2494a:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
   2494e:	0792      	lsls	r2, r2, #30
   24950:	d507      	bpl.n	24962 <nrf_power_clock_isr+0x42>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   24952:	2200      	movs	r2, #0
					NRF_CLOCK_INT_LF_STARTED_MASK)) {
		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started(dev);
		}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   24954:	2101      	movs	r1, #1
   24956:	601a      	str	r2, [r3, #0]
   24958:	4804      	ldr	r0, [pc, #16]	; (2496c <nrf_power_clock_isr+0x4c>)
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
   2495a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   2495e:	f013 bb22 	b.w	37fa6 <clkstarted_handle>
}
   24962:	bd08      	pop	{r3, pc}
   24964:	40005100 	.word	0x40005100
   24968:	40005000 	.word	0x40005000
   2496c:	2002ca7c 	.word	0x2002ca7c
   24970:	40005104 	.word	0x40005104

00024974 <z_clock_isr>:
#include <drivers/timer/system_timer.h>

/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
   24974:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(false);
   24976:	4c06      	ldr	r4, [pc, #24]	; (24990 <z_clock_isr+0x1c>)
   24978:	4906      	ldr	r1, [pc, #24]	; (24994 <z_clock_isr+0x20>)
   2497a:	4622      	mov	r2, r4
   2497c:	4806      	ldr	r0, [pc, #24]	; (24998 <z_clock_isr+0x24>)
   2497e:	2317      	movs	r3, #23
   24980:	f013 f99e 	bl	37cc0 <printk>
   24984:	4620      	mov	r0, r4
}
   24986:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__ASSERT_NO_MSG(false);
   2498a:	2117      	movs	r1, #23
   2498c:	f013 b9de 	b.w	37d4c <assert_post_action>
   24990:	0003d0b2 	.word	0x0003d0b2
   24994:	0003f10e 	.word	0x0003f10e
   24998:	0003baac 	.word	0x0003baac

0002499c <rtc1_nrf_isr>:
 * symbol.
 */
void rtc1_nrf_isr(void *arg)
{
	ARG_UNUSED(arg);
	RTC->EVENTS_COMPARE[0] = 0;
   2499c:	2200      	movs	r2, #0
{
   2499e:	b538      	push	{r3, r4, r5, lr}
	RTC->EVENTS_COMPARE[0] = 0;
   249a0:	4b22      	ldr	r3, [pc, #136]	; (24a2c <rtc1_nrf_isr+0x90>)
   249a2:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
	__asm__ volatile(
   249a6:	f04f 0320 	mov.w	r3, #32
   249aa:	f3ef 8511 	mrs	r5, BASEPRI
   249ae:	f383 8811 	msr	BASEPRI, r3
   249b2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   249b6:	481e      	ldr	r0, [pc, #120]	; (24a30 <rtc1_nrf_isr+0x94>)
   249b8:	f00f ff46 	bl	34848 <z_spin_lock_valid>
   249bc:	b968      	cbnz	r0, 249da <rtc1_nrf_isr+0x3e>
   249be:	234a      	movs	r3, #74	; 0x4a
   249c0:	4a1c      	ldr	r2, [pc, #112]	; (24a34 <rtc1_nrf_isr+0x98>)
   249c2:	491d      	ldr	r1, [pc, #116]	; (24a38 <rtc1_nrf_isr+0x9c>)
   249c4:	481d      	ldr	r0, [pc, #116]	; (24a3c <rtc1_nrf_isr+0xa0>)
   249c6:	f013 f97b 	bl	37cc0 <printk>
   249ca:	4919      	ldr	r1, [pc, #100]	; (24a30 <rtc1_nrf_isr+0x94>)
   249cc:	481c      	ldr	r0, [pc, #112]	; (24a40 <rtc1_nrf_isr+0xa4>)
   249ce:	f013 f977 	bl	37cc0 <printk>
   249d2:	214a      	movs	r1, #74	; 0x4a
   249d4:	4817      	ldr	r0, [pc, #92]	; (24a34 <rtc1_nrf_isr+0x98>)
   249d6:	f013 f9b9 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   249da:	4815      	ldr	r0, [pc, #84]	; (24a30 <rtc1_nrf_isr+0x94>)
   249dc:	f00f ff52 	bl	34884 <z_spin_lock_set_owner>
#endif
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
   249e0:	4b12      	ldr	r3, [pc, #72]	; (24a2c <rtc1_nrf_isr+0x90>)

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t t = counter();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
   249e2:	4a18      	ldr	r2, [pc, #96]	; (24a44 <rtc1_nrf_isr+0xa8>)
   249e4:	f8d3 4504 	ldr.w	r4, [r3, #1284]	; 0x504
   249e8:	6813      	ldr	r3, [r2, #0]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   249ea:	4811      	ldr	r0, [pc, #68]	; (24a30 <rtc1_nrf_isr+0x94>)
	return (a - b) & COUNTER_MAX;
   249ec:	1ae4      	subs	r4, r4, r3
   249ee:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
   249f2:	4423      	add	r3, r4
   249f4:	6013      	str	r3, [r2, #0]
   249f6:	f00f ff35 	bl	34864 <z_spin_unlock_valid>
   249fa:	b968      	cbnz	r0, 24a18 <rtc1_nrf_isr+0x7c>
   249fc:	235d      	movs	r3, #93	; 0x5d
   249fe:	4a0d      	ldr	r2, [pc, #52]	; (24a34 <rtc1_nrf_isr+0x98>)
   24a00:	4911      	ldr	r1, [pc, #68]	; (24a48 <rtc1_nrf_isr+0xac>)
   24a02:	480e      	ldr	r0, [pc, #56]	; (24a3c <rtc1_nrf_isr+0xa0>)
   24a04:	f013 f95c 	bl	37cc0 <printk>
   24a08:	4909      	ldr	r1, [pc, #36]	; (24a30 <rtc1_nrf_isr+0x94>)
   24a0a:	4810      	ldr	r0, [pc, #64]	; (24a4c <rtc1_nrf_isr+0xb0>)
   24a0c:	f013 f958 	bl	37cc0 <printk>
   24a10:	215d      	movs	r1, #93	; 0x5d
   24a12:	4808      	ldr	r0, [pc, #32]	; (24a34 <rtc1_nrf_isr+0x98>)
   24a14:	f013 f99a 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   24a18:	f385 8811 	msr	BASEPRI, r5
   24a1c:	f3bf 8f6f 	isb	sy
		}
		set_comparator(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
   24a20:	4620      	mov	r0, r4
}
   24a22:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
   24a26:	f010 bb95 	b.w	35154 <z_clock_announce>
   24a2a:	bf00      	nop
   24a2c:	40015000 	.word	0x40015000
   24a30:	200204e0 	.word	0x200204e0
   24a34:	0003ba71 	.word	0x0003ba71
   24a38:	0003ba97 	.word	0x0003ba97
   24a3c:	0003baac 	.word	0x0003baac
   24a40:	0003bac9 	.word	0x0003bac9
   24a44:	200204dc 	.word	0x200204dc
   24a48:	0003bb0b 	.word	0x0003bb0b
   24a4c:	0003bb22 	.word	0x0003bb22

00024a50 <z_clock_driver_init>:

int z_clock_driver_init(struct device *device)
{
   24a50:	b570      	push	{r4, r5, r6, lr}
   24a52:	4815      	ldr	r0, [pc, #84]	; (24aa8 <z_clock_driver_init+0x58>)
   24a54:	f00d fc68 	bl	32328 <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_INST_0_NORDIC_NRF_CLOCK_LABEL);
	if (!clock) {
   24a58:	b310      	cbz	r0, 24aa0 <z_clock_driver_init+0x50>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
   24a5a:	6843      	ldr	r3, [r0, #4]
   24a5c:	2101      	movs	r1, #1
   24a5e:	681b      	ldr	r3, [r3, #0]
   24a60:	4798      	blx	r3
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
   24a62:	2400      	movs	r4, #0
    p_reg->CC[ch] = cc_val;
   24a64:	2601      	movs	r6, #1
    p_reg->INTENSET = mask;
   24a66:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   24a6a:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    p_reg->PRESCALER = val;
   24a6e:	4d0f      	ldr	r5, [pc, #60]	; (24aac <z_clock_driver_init+0x5c>)

	/* Clear the event flag and possible pending interrupt */
	nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_COMPARE_0);
	NVIC_ClearPendingIRQ(RTC1_IRQn);

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
   24a70:	4631      	mov	r1, r6
   24a72:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
   24a76:	f8c5 6540 	str.w	r6, [r5, #1344]	; 0x540
    p_reg->INTENSET = mask;
   24a7a:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   24a7e:	4b0c      	ldr	r3, [pc, #48]	; (24ab0 <z_clock_driver_init+0x60>)
   24a80:	2015      	movs	r0, #21
   24a82:	601c      	str	r4, [r3, #0]
   24a84:	4b0b      	ldr	r3, [pc, #44]	; (24ab4 <z_clock_driver_init+0x64>)
   24a86:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   24a8a:	4622      	mov	r2, r4
   24a8c:	f000 fab0 	bl	24ff0 <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
   24a90:	2015      	movs	r0, #21
   24a92:	f000 fa9d 	bl	24fd0 <arch_irq_enable>

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
	}

	return 0;
   24a96:	4620      	mov	r0, r4
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   24a98:	4b07      	ldr	r3, [pc, #28]	; (24ab8 <z_clock_driver_init+0x68>)
   24a9a:	601e      	str	r6, [r3, #0]
   24a9c:	602e      	str	r6, [r5, #0]
}
   24a9e:	bd70      	pop	{r4, r5, r6, pc}
		return -1;
   24aa0:	f04f 30ff 	mov.w	r0, #4294967295
   24aa4:	e7fb      	b.n	24a9e <z_clock_driver_init+0x4e>
   24aa6:	bf00      	nop
   24aa8:	0003d088 	.word	0x0003d088
   24aac:	40015000 	.word	0x40015000
   24ab0:	40015140 	.word	0x40015140
   24ab4:	e000e100 	.word	0xe000e100
   24ab8:	40015008 	.word	0x40015008

00024abc <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
   24abc:	b570      	push	{r4, r5, r6, lr}
	ARG_UNUSED(idle);

#ifdef CONFIG_TICKLESS_KERNEL
	ticks = (ticks == K_FOREVER) ? MAX_TICKS : ticks;
   24abe:	4c3a      	ldr	r4, [pc, #232]	; (24ba8 <z_clock_set_timeout+0xec>)
   24ac0:	f1b0 3fff 	cmp.w	r0, #4294967295
   24ac4:	bf18      	it	ne
   24ac6:	4604      	movne	r4, r0
	__asm__ volatile(
   24ac8:	f04f 0320 	mov.w	r3, #32
   24acc:	f3ef 8511 	mrs	r5, BASEPRI
   24ad0:	f383 8811 	msr	BASEPRI, r3
   24ad4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   24ad8:	4834      	ldr	r0, [pc, #208]	; (24bac <z_clock_set_timeout+0xf0>)
   24ada:	f00f feb5 	bl	34848 <z_spin_lock_valid>
   24ade:	b968      	cbnz	r0, 24afc <z_clock_set_timeout+0x40>
   24ae0:	234a      	movs	r3, #74	; 0x4a
   24ae2:	4a33      	ldr	r2, [pc, #204]	; (24bb0 <z_clock_set_timeout+0xf4>)
   24ae4:	4933      	ldr	r1, [pc, #204]	; (24bb4 <z_clock_set_timeout+0xf8>)
   24ae6:	4834      	ldr	r0, [pc, #208]	; (24bb8 <z_clock_set_timeout+0xfc>)
   24ae8:	f013 f8ea 	bl	37cc0 <printk>
   24aec:	492f      	ldr	r1, [pc, #188]	; (24bac <z_clock_set_timeout+0xf0>)
   24aee:	4833      	ldr	r0, [pc, #204]	; (24bbc <z_clock_set_timeout+0x100>)
   24af0:	f013 f8e6 	bl	37cc0 <printk>
   24af4:	214a      	movs	r1, #74	; 0x4a
   24af6:	482e      	ldr	r0, [pc, #184]	; (24bb0 <z_clock_set_timeout+0xf4>)
   24af8:	f013 f928 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   24afc:	482b      	ldr	r0, [pc, #172]	; (24bac <z_clock_set_timeout+0xf0>)
   24afe:	f00f fec1 	bl	34884 <z_spin_lock_set_owner>
     return p_reg->COUNTER;
   24b02:	4b2f      	ldr	r3, [pc, #188]	; (24bc0 <z_clock_set_timeout+0x104>)
   24b04:	4e28      	ldr	r6, [pc, #160]	; (24ba8 <z_clock_set_timeout+0xec>)
   24b06:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t cyc, dt, t = counter();
	u32_t unannounced = counter_sub(t, last_count);
   24b0a:	4b2e      	ldr	r3, [pc, #184]	; (24bc4 <z_clock_set_timeout+0x108>)
   24b0c:	681b      	ldr	r3, [r3, #0]
	return (a - b) & COUNTER_MAX;
   24b0e:	1ad0      	subs	r0, r2, r3
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
   24b10:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
	return (a - b) & COUNTER_MAX;
   24b14:	f020 417f 	bic.w	r1, r0, #4278190080	; 0xff000000
	if (unannounced >= COUNTER_HALF_SPAN) {
   24b18:	d12c      	bne.n	24b74 <z_clock_set_timeout+0xb8>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
   24b1a:	1e60      	subs	r0, r4, #1
   24b1c:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   24b20:	42b0      	cmp	r0, r6
   24b22:	bfa8      	it	ge
   24b24:	4630      	movge	r0, r6
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
   24b26:	3101      	adds	r1, #1
   24b28:	4408      	add	r0, r1
	 */
	if (cyc > MAX_CYCLES) {
		cyc = MAX_CYCLES;
	}

	cyc += last_count;
   24b2a:	42b0      	cmp	r0, r6
   24b2c:	bf94      	ite	ls
   24b2e:	181b      	addls	r3, r3, r0
   24b30:	199b      	addhi	r3, r3, r6
	return (a - b) & COUNTER_MAX;
   24b32:	1a9a      	subs	r2, r3, r2
   24b34:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
   24b38:	4921      	ldr	r1, [pc, #132]	; (24bc0 <z_clock_set_timeout+0x104>)
   24b3a:	f023 407f 	bic.w	r0, r3, #4278190080	; 0xff000000
	 * least on nRF52.  Some experimentation on nrf52840 shows
	 * that you need to be early by about 400 processor cycles
	 * (about 1/5th of a RTC cycle) in order to reliably get the
	 * interrupt.  The docs say two cycles, they mean two cycles.
	 */
	if (counter_sub(cyc, t) > 2) {
   24b3e:	2a02      	cmp	r2, #2
    p_reg->CC[ch] = cc_val;
   24b40:	f8c1 0540 	str.w	r0, [r1, #1344]	; 0x540
   24b44:	d918      	bls.n	24b78 <z_clock_set_timeout+0xbc>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   24b46:	4819      	ldr	r0, [pc, #100]	; (24bac <z_clock_set_timeout+0xf0>)
   24b48:	f00f fe8c 	bl	34864 <z_spin_unlock_valid>
   24b4c:	b968      	cbnz	r0, 24b6a <z_clock_set_timeout+0xae>
   24b4e:	235d      	movs	r3, #93	; 0x5d
   24b50:	4a17      	ldr	r2, [pc, #92]	; (24bb0 <z_clock_set_timeout+0xf4>)
   24b52:	491d      	ldr	r1, [pc, #116]	; (24bc8 <z_clock_set_timeout+0x10c>)
   24b54:	4818      	ldr	r0, [pc, #96]	; (24bb8 <z_clock_set_timeout+0xfc>)
   24b56:	f013 f8b3 	bl	37cc0 <printk>
   24b5a:	4914      	ldr	r1, [pc, #80]	; (24bac <z_clock_set_timeout+0xf0>)
   24b5c:	481b      	ldr	r0, [pc, #108]	; (24bcc <z_clock_set_timeout+0x110>)
   24b5e:	f013 f8af 	bl	37cc0 <printk>
   24b62:	215d      	movs	r1, #93	; 0x5d
   24b64:	4812      	ldr	r0, [pc, #72]	; (24bb0 <z_clock_set_timeout+0xf4>)
   24b66:	f013 f8f1 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   24b6a:	f385 8811 	msr	BASEPRI, r5
   24b6e:	f3bf 8f6f 	isb	sy
	}
#endif

	k_spin_unlock(&lock, key);
#endif /* CONFIG_TICKLESS_KERNEL */
}
   24b72:	bd70      	pop	{r4, r5, r6, pc}
		ticks = 0;
   24b74:	2000      	movs	r0, #0
   24b76:	e7d6      	b.n	24b26 <z_clock_set_timeout+0x6a>
     return p_reg->COUNTER;
   24b78:	f8d1 2504 	ldr.w	r2, [r1, #1284]	; 0x504
		if (dt == 0 || dt > 0x7fffff) {
   24b7c:	4814      	ldr	r0, [pc, #80]	; (24bd0 <z_clock_set_timeout+0x114>)
	return (a - b) & COUNTER_MAX;
   24b7e:	1a9a      	subs	r2, r3, r2
   24b80:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
		if (dt == 0 || dt > 0x7fffff) {
   24b84:	1e54      	subs	r4, r2, #1
   24b86:	4284      	cmp	r4, r0
   24b88:	d905      	bls.n	24b96 <z_clock_set_timeout+0xda>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   24b8a:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   24b8e:	4b11      	ldr	r3, [pc, #68]	; (24bd4 <z_clock_set_timeout+0x118>)
   24b90:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   24b94:	e7d7      	b.n	24b46 <z_clock_set_timeout+0x8a>
		} else if (dt == 1) {
   24b96:	2a01      	cmp	r2, #1
			set_comparator(cyc + 2);
   24b98:	bf02      	ittt	eq
   24b9a:	3302      	addeq	r3, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
   24b9c:	f023 437f 	biceq.w	r3, r3, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
   24ba0:	f8c1 3540 	streq.w	r3, [r1, #1344]	; 0x540
   24ba4:	e7cf      	b.n	24b46 <z_clock_set_timeout+0x8a>
   24ba6:	bf00      	nop
   24ba8:	00fffffe 	.word	0x00fffffe
   24bac:	200204e0 	.word	0x200204e0
   24bb0:	0003ba71 	.word	0x0003ba71
   24bb4:	0003ba97 	.word	0x0003ba97
   24bb8:	0003baac 	.word	0x0003baac
   24bbc:	0003bac9 	.word	0x0003bac9
   24bc0:	40015000 	.word	0x40015000
   24bc4:	200204dc 	.word	0x200204dc
   24bc8:	0003bb0b 	.word	0x0003bb0b
   24bcc:	0003bb22 	.word	0x0003bb22
   24bd0:	007ffffe 	.word	0x007ffffe
   24bd4:	e000e100 	.word	0xe000e100

00024bd8 <z_clock_elapsed>:

u32_t z_clock_elapsed(void)
{
   24bd8:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   24bda:	f04f 0320 	mov.w	r3, #32
   24bde:	f3ef 8511 	mrs	r5, BASEPRI
   24be2:	f383 8811 	msr	BASEPRI, r3
   24be6:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   24bea:	481a      	ldr	r0, [pc, #104]	; (24c54 <z_clock_elapsed+0x7c>)
   24bec:	f00f fe2c 	bl	34848 <z_spin_lock_valid>
   24bf0:	b968      	cbnz	r0, 24c0e <z_clock_elapsed+0x36>
   24bf2:	234a      	movs	r3, #74	; 0x4a
   24bf4:	4a18      	ldr	r2, [pc, #96]	; (24c58 <z_clock_elapsed+0x80>)
   24bf6:	4919      	ldr	r1, [pc, #100]	; (24c5c <z_clock_elapsed+0x84>)
   24bf8:	4819      	ldr	r0, [pc, #100]	; (24c60 <z_clock_elapsed+0x88>)
   24bfa:	f013 f861 	bl	37cc0 <printk>
   24bfe:	4915      	ldr	r1, [pc, #84]	; (24c54 <z_clock_elapsed+0x7c>)
   24c00:	4818      	ldr	r0, [pc, #96]	; (24c64 <z_clock_elapsed+0x8c>)
   24c02:	f013 f85d 	bl	37cc0 <printk>
   24c06:	214a      	movs	r1, #74	; 0x4a
   24c08:	4813      	ldr	r0, [pc, #76]	; (24c58 <z_clock_elapsed+0x80>)
   24c0a:	f013 f89f 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   24c0e:	4811      	ldr	r0, [pc, #68]	; (24c54 <z_clock_elapsed+0x7c>)
   24c10:	f00f fe38 	bl	34884 <z_spin_lock_set_owner>
     return p_reg->COUNTER;
   24c14:	4b14      	ldr	r3, [pc, #80]	; (24c68 <z_clock_elapsed+0x90>)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   24c16:	480f      	ldr	r0, [pc, #60]	; (24c54 <z_clock_elapsed+0x7c>)
   24c18:	f8d3 4504 	ldr.w	r4, [r3, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
   24c1c:	4b13      	ldr	r3, [pc, #76]	; (24c6c <z_clock_elapsed+0x94>)
	return (a - b) & COUNTER_MAX;
   24c1e:	681b      	ldr	r3, [r3, #0]
   24c20:	1ae4      	subs	r4, r4, r3
   24c22:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
   24c26:	f00f fe1d 	bl	34864 <z_spin_unlock_valid>
   24c2a:	b968      	cbnz	r0, 24c48 <z_clock_elapsed+0x70>
   24c2c:	235d      	movs	r3, #93	; 0x5d
   24c2e:	4a0a      	ldr	r2, [pc, #40]	; (24c58 <z_clock_elapsed+0x80>)
   24c30:	490f      	ldr	r1, [pc, #60]	; (24c70 <z_clock_elapsed+0x98>)
   24c32:	480b      	ldr	r0, [pc, #44]	; (24c60 <z_clock_elapsed+0x88>)
   24c34:	f013 f844 	bl	37cc0 <printk>
   24c38:	4906      	ldr	r1, [pc, #24]	; (24c54 <z_clock_elapsed+0x7c>)
   24c3a:	480e      	ldr	r0, [pc, #56]	; (24c74 <z_clock_elapsed+0x9c>)
   24c3c:	f013 f840 	bl	37cc0 <printk>
   24c40:	215d      	movs	r1, #93	; 0x5d
   24c42:	4805      	ldr	r0, [pc, #20]	; (24c58 <z_clock_elapsed+0x80>)
   24c44:	f013 f882 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   24c48:	f385 8811 	msr	BASEPRI, r5
   24c4c:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
   24c50:	4620      	mov	r0, r4
   24c52:	bd38      	pop	{r3, r4, r5, pc}
   24c54:	200204e0 	.word	0x200204e0
   24c58:	0003ba71 	.word	0x0003ba71
   24c5c:	0003ba97 	.word	0x0003ba97
   24c60:	0003baac 	.word	0x0003baac
   24c64:	0003bac9 	.word	0x0003bac9
   24c68:	40015000 	.word	0x40015000
   24c6c:	200204dc 	.word	0x200204dc
   24c70:	0003bb0b 	.word	0x0003bb0b
   24c74:	0003bb22 	.word	0x0003bb22

00024c78 <z_timer_cycle_get_32>:

u32_t z_timer_cycle_get_32(void)
{
   24c78:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   24c7a:	f04f 0320 	mov.w	r3, #32
   24c7e:	f3ef 8511 	mrs	r5, BASEPRI
   24c82:	f383 8811 	msr	BASEPRI, r3
   24c86:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   24c8a:	481b      	ldr	r0, [pc, #108]	; (24cf8 <z_timer_cycle_get_32+0x80>)
   24c8c:	f00f fddc 	bl	34848 <z_spin_lock_valid>
   24c90:	b968      	cbnz	r0, 24cae <z_timer_cycle_get_32+0x36>
   24c92:	234a      	movs	r3, #74	; 0x4a
   24c94:	4a19      	ldr	r2, [pc, #100]	; (24cfc <z_timer_cycle_get_32+0x84>)
   24c96:	491a      	ldr	r1, [pc, #104]	; (24d00 <z_timer_cycle_get_32+0x88>)
   24c98:	481a      	ldr	r0, [pc, #104]	; (24d04 <z_timer_cycle_get_32+0x8c>)
   24c9a:	f013 f811 	bl	37cc0 <printk>
   24c9e:	4916      	ldr	r1, [pc, #88]	; (24cf8 <z_timer_cycle_get_32+0x80>)
   24ca0:	4819      	ldr	r0, [pc, #100]	; (24d08 <z_timer_cycle_get_32+0x90>)
   24ca2:	f013 f80d 	bl	37cc0 <printk>
   24ca6:	214a      	movs	r1, #74	; 0x4a
   24ca8:	4814      	ldr	r0, [pc, #80]	; (24cfc <z_timer_cycle_get_32+0x84>)
   24caa:	f013 f84f 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   24cae:	4812      	ldr	r0, [pc, #72]	; (24cf8 <z_timer_cycle_get_32+0x80>)
   24cb0:	f00f fde8 	bl	34884 <z_spin_lock_set_owner>
   24cb4:	4b15      	ldr	r3, [pc, #84]	; (24d0c <z_timer_cycle_get_32+0x94>)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   24cb6:	4810      	ldr	r0, [pc, #64]	; (24cf8 <z_timer_cycle_get_32+0x80>)
   24cb8:	f8d3 4504 	ldr.w	r4, [r3, #1284]	; 0x504
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
   24cbc:	4b14      	ldr	r3, [pc, #80]	; (24d10 <z_timer_cycle_get_32+0x98>)
   24cbe:	681b      	ldr	r3, [r3, #0]
	return (a - b) & COUNTER_MAX;
   24cc0:	1ae4      	subs	r4, r4, r3
   24cc2:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
	u32_t ret = counter_sub(counter(), last_count) + last_count;
   24cc6:	441c      	add	r4, r3
   24cc8:	f00f fdcc 	bl	34864 <z_spin_unlock_valid>
   24ccc:	b968      	cbnz	r0, 24cea <z_timer_cycle_get_32+0x72>
   24cce:	235d      	movs	r3, #93	; 0x5d
   24cd0:	4a0a      	ldr	r2, [pc, #40]	; (24cfc <z_timer_cycle_get_32+0x84>)
   24cd2:	4910      	ldr	r1, [pc, #64]	; (24d14 <z_timer_cycle_get_32+0x9c>)
   24cd4:	480b      	ldr	r0, [pc, #44]	; (24d04 <z_timer_cycle_get_32+0x8c>)
   24cd6:	f012 fff3 	bl	37cc0 <printk>
   24cda:	4907      	ldr	r1, [pc, #28]	; (24cf8 <z_timer_cycle_get_32+0x80>)
   24cdc:	480e      	ldr	r0, [pc, #56]	; (24d18 <z_timer_cycle_get_32+0xa0>)
   24cde:	f012 ffef 	bl	37cc0 <printk>
   24ce2:	215d      	movs	r1, #93	; 0x5d
   24ce4:	4805      	ldr	r0, [pc, #20]	; (24cfc <z_timer_cycle_get_32+0x84>)
   24ce6:	f013 f831 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   24cea:	f385 8811 	msr	BASEPRI, r5
   24cee:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
   24cf2:	4620      	mov	r0, r4
   24cf4:	bd38      	pop	{r3, r4, r5, pc}
   24cf6:	bf00      	nop
   24cf8:	200204e0 	.word	0x200204e0
   24cfc:	0003ba71 	.word	0x0003ba71
   24d00:	0003ba97 	.word	0x0003ba97
   24d04:	0003baac 	.word	0x0003baac
   24d08:	0003bac9 	.word	0x0003bac9
   24d0c:	40015000 	.word	0x40015000
   24d10:	200204dc 	.word	0x200204dc
   24d14:	0003bb0b 	.word	0x0003bb0b
   24d18:	0003bb22 	.word	0x0003bb22

00024d1c <_DoInit>:
  SEGGER_RTT_CB* p;
  //
  // Initialize control block
  //
  p = &_SEGGER_RTT;
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   24d1c:	2303      	movs	r3, #3
static void _DoInit(void) {
   24d1e:	b510      	push	{r4, lr}
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   24d20:	4c10      	ldr	r4, [pc, #64]	; (24d64 <_DoInit+0x48>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
   24d22:	4a11      	ldr	r2, [pc, #68]	; (24d68 <_DoInit+0x4c>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
   24d24:	e9c4 3304 	strd	r3, r3, [r4, #16]
  p->aUp[0].pBuffer       = _acUpBuffer;
   24d28:	4b10      	ldr	r3, [pc, #64]	; (24d6c <_DoInit+0x50>)
  p->aUp[0].sName         = "Terminal";
   24d2a:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
   24d2c:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
   24d2e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  p->aUp[0].WrOff         = 0u;
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
   24d32:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
   24d34:	4a0e      	ldr	r2, [pc, #56]	; (24d70 <_DoInit+0x54>)
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
   24d36:	6223      	str	r3, [r4, #32]
  p->aDown[0].pBuffer       = _acDownBuffer;
   24d38:	6662      	str	r2, [r4, #100]	; 0x64
  p->aUp[0].RdOff         = 0u;
   24d3a:	2300      	movs	r3, #0
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
   24d3c:	2210      	movs	r2, #16
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  strcpy(&p->acID[7], "RTT");
   24d3e:	490d      	ldr	r1, [pc, #52]	; (24d74 <_DoInit+0x58>)
   24d40:	1de0      	adds	r0, r4, #7
  p->aUp[0].RdOff         = 0u;
   24d42:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
   24d44:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   24d46:	62e3      	str	r3, [r4, #44]	; 0x2c
  p->aDown[0].RdOff         = 0u;
   24d48:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
   24d4a:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   24d4c:	6763      	str	r3, [r4, #116]	; 0x74
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
   24d4e:	66a2      	str	r2, [r4, #104]	; 0x68
  strcpy(&p->acID[7], "RTT");
   24d50:	f015 f99e 	bl	3a090 <strcpy>
  strcpy(&p->acID[0], "SEGGER");
   24d54:	4908      	ldr	r1, [pc, #32]	; (24d78 <_DoInit+0x5c>)
   24d56:	4620      	mov	r0, r4
   24d58:	f015 f99a 	bl	3a090 <strcpy>
  p->acID[6] = ' ';
   24d5c:	2320      	movs	r3, #32
   24d5e:	71a3      	strb	r3, [r4, #6]
}
   24d60:	bd10      	pop	{r4, pc}
   24d62:	bf00      	nop
   24d64:	200204e4 	.word	0x200204e4
   24d68:	0003d0e4 	.word	0x0003d0e4
   24d6c:	20024d1b 	.word	0x20024d1b
   24d70:	20024d0b 	.word	0x20024d0b
   24d74:	0003d0ed 	.word	0x0003d0ed
   24d78:	0003d0f1 	.word	0x0003d0f1

00024d7c <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   24d7c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  RdOff = pRing->RdOff;
   24d80:	f04f 0b18 	mov.w	fp, #24
   24d84:	4e22      	ldr	r6, [pc, #136]	; (24e10 <SEGGER_RTT_WriteSkipNoLock+0x94>)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   24d86:	4614      	mov	r4, r2
  RdOff = pRing->RdOff;
   24d88:	fb0b 6200 	mla	r2, fp, r0, r6
   24d8c:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
   24d8e:	6a55      	ldr	r5, [r2, #36]	; 0x24
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   24d90:	4607      	mov	r7, r0
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   24d92:	42ab      	cmp	r3, r5
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   24d94:	4688      	mov	r8, r1
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   24d96:	d834      	bhi.n	24e02 <SEGGER_RTT_WriteSkipNoLock+0x86>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
   24d98:	f8d2 a020 	ldr.w	sl, [r2, #32]
   24d9c:	ebaa 0905 	sub.w	r9, sl, r5
   24da0:	f109 32ff 	add.w	r2, r9, #4294967295
    if (Avail >= NumBytes) {                            // Case 1)?
   24da4:	42a2      	cmp	r2, r4
   24da6:	d311      	bcc.n	24dcc <SEGGER_RTT_WriteSkipNoLock+0x50>
CopyStraight:
      memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
   24da8:	f04f 0918 	mov.w	r9, #24
   24dac:	fb07 9309 	mla	r3, r7, r9, r9
   24db0:	4433      	add	r3, r6
   24db2:	6858      	ldr	r0, [r3, #4]
   24db4:	4622      	mov	r2, r4
   24db6:	4641      	mov	r1, r8
   24db8:	4428      	add	r0, r5
   24dba:	f014 ffe0 	bl	39d7e <memcpy>
      pRing->WrOff = WrOff + NumBytes;
   24dbe:	fb09 6607 	mla	r6, r9, r7, r6
   24dc2:	442c      	add	r4, r5
      //
      if (NumBytes) {
        memcpy(pRing->pBuffer, pData + Rem, NumBytes);
      }
      pRing->WrOff = NumBytes;
      return 1;
   24dc4:	2001      	movs	r0, #1
      pRing->WrOff = NumBytes;
   24dc6:	6274      	str	r4, [r6, #36]	; 0x24
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
}
   24dc8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Avail += RdOff;                                     // Space incl. wrap-around
   24dcc:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
   24dce:	429c      	cmp	r4, r3
   24dd0:	d81b      	bhi.n	24e0a <SEGGER_RTT_WriteSkipNoLock+0x8e>
      memcpy(pRing->pBuffer + WrOff, pData, Rem);       // Copy 1st chunk
   24dd2:	fb00 bb0b 	mla	fp, r0, fp, fp
   24dd6:	44b3      	add	fp, r6
   24dd8:	f8db 0004 	ldr.w	r0, [fp, #4]
   24ddc:	464a      	mov	r2, r9
   24dde:	4428      	add	r0, r5
   24de0:	442c      	add	r4, r5
   24de2:	f014 ffcc 	bl	39d7e <memcpy>
      if (NumBytes) {
   24de6:	ebb4 040a 	subs.w	r4, r4, sl
   24dea:	d006      	beq.n	24dfa <SEGGER_RTT_WriteSkipNoLock+0x7e>
   24dec:	4622      	mov	r2, r4
   24dee:	eb08 0109 	add.w	r1, r8, r9
   24df2:	f8db 0004 	ldr.w	r0, [fp, #4]
   24df6:	f014 ffc2 	bl	39d7e <memcpy>
      pRing->WrOff = NumBytes;
   24dfa:	2318      	movs	r3, #24
   24dfc:	fb03 6607 	mla	r6, r3, r7, r6
   24e00:	e7e0      	b.n	24dc4 <SEGGER_RTT_WriteSkipNoLock+0x48>
    Avail = RdOff - WrOff - 1u;
   24e02:	3b01      	subs	r3, #1
   24e04:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
   24e06:	429c      	cmp	r4, r3
   24e08:	d9ce      	bls.n	24da8 <SEGGER_RTT_WriteSkipNoLock+0x2c>
  return 0;     // No space in buffer
   24e0a:	2000      	movs	r0, #0
   24e0c:	e7dc      	b.n	24dc8 <SEGGER_RTT_WriteSkipNoLock+0x4c>
   24e0e:	bf00      	nop
   24e10:	200204e4 	.word	0x200204e4

00024e14 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  v = pRing->RdOff;
   24e14:	2318      	movs	r3, #24
   24e16:	4a03      	ldr	r2, [pc, #12]	; (24e24 <SEGGER_RTT_HasDataUp+0x10>)
   24e18:	fb03 2300 	mla	r3, r3, r0, r2
   24e1c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  return pRing->WrOff - v;
   24e1e:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
   24e20:	1a80      	subs	r0, r0, r2
   24e22:	4770      	bx	lr
   24e24:	200204e4 	.word	0x200204e4

00024e28 <z_arm_exc_exit>:
    /* r0 contains the caller mode */
    push {r0, lr}
#endif

#ifdef CONFIG_PREEMPT_ENABLED
    ldr r0, =_kernel
   24e28:	4804      	ldr	r0, [pc, #16]	; (24e3c <_EXIT_EXC+0x2>)

    ldr r1, [r0, #_kernel_offset_to_current]
   24e2a:	6881      	ldr	r1, [r0, #8]

    ldr r0, [r0, #_kernel_offset_to_ready_q_cache]
   24e2c:	6a40      	ldr	r0, [r0, #36]	; 0x24
    cmp r0, r1
   24e2e:	4288      	cmp	r0, r1
    beq _EXIT_EXC
   24e30:	d003      	beq.n	24e3a <_EXIT_EXC>

#if defined(CONFIG_CPU_CORTEX_M)
    /* context switch required, pend the PendSV exception */
    ldr r1, =_SCS_ICSR
   24e32:	4903      	ldr	r1, [pc, #12]	; (24e40 <_EXIT_EXC+0x6>)
    ldr r2, =_SCS_ICSR_PENDSV
   24e34:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    str r2, [r1]
   24e38:	600a      	str	r2, [r1, #0]

00024e3a <_EXIT_EXC>:
    bl z_check_stack_sentinel
#endif /* CONFIG_CPU_CORTEX_M */
#endif /* CONFIG_STACK_SENTINEL */

#if defined(CONFIG_CPU_CORTEX_M)
    bx lr
   24e3a:	4770      	bx	lr
    ldr r0, =_kernel
   24e3c:	20022108 	.word	0x20022108
    ldr r1, =_SCS_ICSR
   24e40:	e000ed04 	.word	0xe000ed04

00024e44 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   24e44:	492e      	ldr	r1, [pc, #184]	; (24f00 <in_fp_endif+0x40>)
    ldr r2, [r1, #_kernel_offset_to_current]
   24e46:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   24e48:	f04f 0028 	mov.w	r0, #40	; 0x28
    add r0, r2
   24e4c:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   24e4e:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   24e52:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#ifdef CONFIG_FP_SHARING
    /* Assess whether switched-out thread had been using the FP registers. */
    ldr r0, =0x10 /* EXC_RETURN.F_Type Mask */
   24e56:	f04f 0010 	mov.w	r0, #16
    tst lr, r0    /* EXC_RETURN & EXC_RETURN.F_Type_Msk */
   24e5a:	ea1e 0f00 	tst.w	lr, r0
    beq out_fp_active
   24e5e:	d004      	beq.n	24e6a <out_fp_active>
    /* FP context inactive: clear FP state */
    ldr r0, [r2, #_thread_offset_to_mode]
   24e60:	f8d2 00ac 	ldr.w	r0, [r2, #172]	; 0xac
    bic r0, #0x4 /* _current->arch.mode &= ~(CONTROL_FPCA_Msk) */
   24e64:	f020 0004 	bic.w	r0, r0, #4
    b out_fp_endif
   24e68:	e007      	b.n	24e7a <out_fp_endif>

00024e6a <out_fp_active>:

out_fp_active:
    /* FP context active: set FP state and store callee-saved registers */
    add r0, r2, #_thread_offset_to_preempt_float
   24e6a:	f102 006c 	add.w	r0, r2, #108	; 0x6c
    vstmia r0, {s16-s31}
   24e6e:	ec80 8a10 	vstmia	r0, {s16-s31}
    ldr r0, [r2, #_thread_offset_to_mode]
   24e72:	f8d2 00ac 	ldr.w	r0, [r2, #172]	; 0xac
    orrs r0, r0, #0x4 /* _current->arch.mode |= CONTROL_FPCA_Msk */
   24e76:	f050 0004 	orrs.w	r0, r0, #4

00024e7a <out_fp_endif>:

out_fp_endif:
    str r0, [r2, #_thread_offset_to_mode]
   24e7a:	f8c2 00ac 	str.w	r0, [r2, #172]	; 0xac

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   24e7e:	2020      	movs	r0, #32
    msr BASEPRI, r0
   24e80:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   24e84:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   24e88:	4f1e      	ldr	r7, [pc, #120]	; (24f04 <in_fp_endif+0x44>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   24e8a:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   24e8e:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
   24e90:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   24e92:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   24e94:	6e50      	ldr	r0, [r2, #100]	; 0x64
    movs r3, #0
   24e96:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   24e98:	6653      	str	r3, [r2, #100]	; 0x64
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   24e9a:	f380 8811 	msr	BASEPRI, r0

#ifdef CONFIG_FP_SHARING
    /* Assess whether switched-in thread had been using the FP registers. */
    ldr r0, [r2, #_thread_offset_to_mode]
   24e9e:	f8d2 00ac 	ldr.w	r0, [r2, #172]	; 0xac
    tst r0, #0x04 /* thread.arch.mode & CONTROL.FPCA Msk */
   24ea2:	f010 0f04 	tst.w	r0, #4
    bne in_fp_active
   24ea6:	d105      	bne.n	24eb4 <in_fp_active>
    /* FP context inactive for swapped-in thread:
     * - reset FPSCR to 0
     * - set EXC_RETURN.F_Type (prevents FP frame un-stacking when returning
     *   from pendSV)
     */
    movs.n r3, #0
   24ea8:	2300      	movs	r3, #0
    vmsr fpscr, r3
   24eaa:	eee1 3a10 	vmsr	fpscr, r3
    orrs lr, lr, #0x10 /* EXC_RETURN & EXC_RETURN.F_Type_Msk */
   24eae:	f05e 0e10 	orrs.w	lr, lr, #16
    b in_fp_endif
   24eb2:	e005      	b.n	24ec0 <in_fp_endif>

00024eb4 <in_fp_active>:
    /* FP context active:
     * - clear EXC_RETURN.F_Type
     * - FPSCR and caller-saved registers will be restored automatically
     * - restore callee-saved FP registers
     */
    bic lr, #0x10 /* EXC_RETURN | (~EXC_RETURN.F_Type_Msk) */
   24eb4:	f02e 0e10 	bic.w	lr, lr, #16
    add r0, r2, #_thread_offset_to_preempt_float
   24eb8:	f102 006c 	add.w	r0, r2, #108	; 0x6c
    vldmia r0, {s16-s31}
   24ebc:	ec90 8a10 	vldmia	r0, {s16-s31}

00024ec0 <in_fp_endif>:
in_fp_endif:
    /* Clear CONTROL.FPCA that may have been set by FP instructions */
    mrs r3, CONTROL
   24ec0:	f3ef 8314 	mrs	r3, CONTROL
    bic r3, #0x4 /* CONTROL.FPCA Msk */
   24ec4:	f023 0304 	bic.w	r3, r3, #4
    msr CONTROL, r3
   24ec8:	f383 8814 	msr	CONTROL, r3
    isb
   24ecc:	f3bf 8f6f 	isb	sy
#endif

#if defined (CONFIG_ARM_MPU)
    /* Re-program dynamic memory map */
    push {r2,lr}
   24ed0:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
   24ed2:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
   24ed4:	f013 f8a6 	bl	38024 <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
   24ed8:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   24edc:	f102 0028 	add.w	r0, r2, #40	; 0x28
    ldmia r0, {v1-v8, ip}
   24ee0:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* clear stack pointer limit before setting the PSP */
    mov r0, #0
   24ee4:	f04f 0000 	mov.w	r0, #0
    msr PSPLIM, r0
   24ee8:	f380 880b 	msr	PSPLIM, r0
#endif /* CONFIG_BUILTIN_STACK_GUARD */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   24eec:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
   24ef0:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
   24ef4:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
   24ef6:	f013 f886 	bl	38006 <configure_builtin_stack_guard>
    pop {r2, lr}
   24efa:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
   24efe:	4770      	bx	lr
    ldr r1, =_kernel
   24f00:	20022108 	.word	0x20022108
    ldr v4, =_SCS_ICSR
   24f04:	e000ed04 	.word	0xe000ed04

00024f08 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
   24f08:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   24f0c:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   24f0e:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   24f12:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   24f16:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   24f18:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   24f1c:	2902      	cmp	r1, #2
    beq _oops
   24f1e:	d0ff      	beq.n	24f20 <_oops>

00024f20 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   24f20:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
   24f22:	f013 f874 	bl	3800e <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
   24f26:	bd01      	pop	{r0, pc}

00024f28 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr r1, =_SCB_SCR
   24f28:	4901      	ldr	r1, [pc, #4]	; (24f30 <z_arm_cpu_idle_init+0x8>)
	movs.n r2, #_SCR_INIT_BITS
   24f2a:	2210      	movs	r2, #16
	str r2, [r1]
   24f2c:	600a      	str	r2, [r1, #0]
#endif
	bx lr
   24f2e:	4770      	bx	lr
	ldr r1, =_SCB_SCR
   24f30:	e000ed10 	.word	0xe000ed10

00024f34 <arch_cpu_idle>:
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	cpsie i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* clear BASEPRI so wfi is awakened by incoming interrupts */
	eors.n r0, r0
   24f34:	4040      	eors	r0, r0
	msr BASEPRI, r0
   24f36:	f380 8811 	msr	BASEPRI, r0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	wfi
   24f3a:	bf30      	wfi

	bx lr
   24f3c:	4770      	bx	lr
   24f3e:	bf00      	nop

00024f40 <z_arm_bus_fault>:
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_reserved)

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) || \
	defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	mrs r0, MSP
   24f40:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   24f44:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
   24f48:	4672      	mov	r2, lr

	push {r0, lr}
   24f4a:	b501      	push	{r0, lr}
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE || CONFIG_ARMv7_M_ARMV8_M_MAINLINE */

	bl z_arm_fault
   24f4c:	f000 fbae 	bl	256ac <z_arm_fault>

#if defined(CONFIG_CPU_CORTEX_M)
	pop {r0, pc}
   24f50:	bd01      	pop	{r0, pc}
   24f52:	bf00      	nop

00024f54 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   24f54:	bf30      	wfi
    b z_SysNmiOnReset
   24f56:	f7ff bffd 	b.w	24f54 <z_SysNmiOnReset>
   24f5a:	bf00      	nop

00024f5c <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   24f5c:	b501      	push	{r0, lr}
      * FIXME: Remove the Cortex-M conditional compilation checks for `cpsid i`
      *        and `cpsie i` after the Cortex-R port is updated to support
      *        interrupt nesting.  For more details, refer to the issue #21758.
      */
#if defined(CONFIG_CPU_CORTEX_M)
	cpsid i  /* PRIMASK = 1 */
   24f5e:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   24f60:	4a0b      	ldr	r2, [pc, #44]	; (24f90 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   24f62:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
   24f64:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   24f66:	bf1e      	ittt	ne
	movne	r1, #0
   24f68:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   24f6a:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
   24f6c:	f014 fd27 	blne	399be <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   24f70:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   24f72:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   24f76:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   24f7a:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 */
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldr r1, =_sw_isr_table
   24f7e:	4905      	ldr	r1, [pc, #20]	; (24f94 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   24f80:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   24f82:	c909      	ldmia	r1!, {r0, r3}
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldm sp!,{r0-r3} /* Restore r0 to r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
   24f84:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   24f86:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   24f8a:	4903      	ldr	r1, [pc, #12]	; (24f98 <_isr_wrapper+0x3c>)
	bx r1
   24f8c:	4708      	bx	r1
   24f8e:	0000      	.short	0x0000
	ldr r2, =_kernel
   24f90:	20022108 	.word	0x20022108
	ldr r1, =_sw_isr_table
   24f94:	0003aac4 	.word	0x0003aac4
	ldr r1, =z_arm_int_exit
   24f98:	00024e29 	.word	0x00024e29

00024f9c <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
   24f9c:	4a09      	ldr	r2, [pc, #36]	; (24fc4 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
   24f9e:	490a      	ldr	r1, [pc, #40]	; (24fc8 <arch_swap+0x2c>)
	_current->arch.basepri = key;
   24fa0:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   24fa2:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
   24fa4:	6658      	str	r0, [r3, #100]	; 0x64
	_current->arch.swap_return_value = _k_neg_eagain;
   24fa6:	6699      	str	r1, [r3, #104]	; 0x68

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   24fa8:	4908      	ldr	r1, [pc, #32]	; (24fcc <arch_swap+0x30>)
   24faa:	684b      	ldr	r3, [r1, #4]
   24fac:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   24fb0:	604b      	str	r3, [r1, #4]
   24fb2:	2300      	movs	r3, #0
   24fb4:	f383 8811 	msr	BASEPRI, r3
   24fb8:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   24fbc:	6893      	ldr	r3, [r2, #8]
}
   24fbe:	6e98      	ldr	r0, [r3, #104]	; 0x68
   24fc0:	4770      	bx	lr
   24fc2:	bf00      	nop
   24fc4:	20022108 	.word	0x20022108
   24fc8:	0003b848 	.word	0x0003b848
   24fcc:	e000ed00 	.word	0xe000ed00

00024fd0 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   24fd0:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
   24fd2:	2b00      	cmp	r3, #0
   24fd4:	db08      	blt.n	24fe8 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   24fd6:	2201      	movs	r2, #1
   24fd8:	f000 001f 	and.w	r0, r0, #31
   24fdc:	fa02 f000 	lsl.w	r0, r2, r0
   24fe0:	4a02      	ldr	r2, [pc, #8]	; (24fec <arch_irq_enable+0x1c>)
   24fe2:	095b      	lsrs	r3, r3, #5
   24fe4:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   24fe8:	4770      	bx	lr
   24fea:	bf00      	nop
   24fec:	e000e100 	.word	0xe000e100

00024ff0 <z_arm_irq_priority_set>:
 * priority levels which are reserved.
 *
 * @return N/A
 */
void z_arm_irq_priority_set(unsigned int irq, unsigned int prio, u32_t flags)
{
   24ff0:	b570      	push	{r4, r5, r6, lr}
	} else {
		prio += _IRQ_PRIO_OFFSET;
	}
#else
	ARG_UNUSED(flags);
	prio += _IRQ_PRIO_OFFSET;
   24ff2:	1c4c      	adds	r4, r1, #1
	/* The last priority level is also used by PendSV exception, but
	 * allow other interrupts to use the same level, even if it ends up
	 * affecting performance (can still be useful on systems with a
	 * reduced set of priorities, like Cortex-M0/M0+).
	 */
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
   24ff4:	2c07      	cmp	r4, #7
{
   24ff6:	4605      	mov	r5, r0
   24ff8:	460e      	mov	r6, r1
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
   24ffa:	d90e      	bls.n	2501a <z_arm_irq_priority_set+0x2a>
   24ffc:	235f      	movs	r3, #95	; 0x5f
   24ffe:	4a10      	ldr	r2, [pc, #64]	; (25040 <z_arm_irq_priority_set+0x50>)
   25000:	4910      	ldr	r1, [pc, #64]	; (25044 <z_arm_irq_priority_set+0x54>)
   25002:	4811      	ldr	r0, [pc, #68]	; (25048 <z_arm_irq_priority_set+0x58>)
   25004:	f012 fe5c 	bl	37cc0 <printk>
   25008:	4631      	mov	r1, r6
   2500a:	4810      	ldr	r0, [pc, #64]	; (2504c <z_arm_irq_priority_set+0x5c>)
   2500c:	2207      	movs	r2, #7
   2500e:	f012 fe57 	bl	37cc0 <printk>
   25012:	215f      	movs	r1, #95	; 0x5f
   25014:	480a      	ldr	r0, [pc, #40]	; (25040 <z_arm_irq_priority_set+0x50>)
   25016:	f012 fe99 	bl	37d4c <assert_post_action>
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(DT_NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   2501a:	b26b      	sxtb	r3, r5
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   2501c:	2b00      	cmp	r3, #0
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2501e:	bfa8      	it	ge
   25020:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
   25024:	ea4f 1444 	mov.w	r4, r4, lsl #5
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   25028:	bfb8      	it	lt
   2502a:	4b09      	ldrlt	r3, [pc, #36]	; (25050 <z_arm_irq_priority_set+0x60>)
   2502c:	b2e4      	uxtb	r4, r4
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2502e:	bfab      	itete	ge
   25030:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   25034:	f005 050f 	andlt.w	r5, r5, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   25038:	f883 4300 	strbge.w	r4, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2503c:	555c      	strblt	r4, [r3, r5]
}
   2503e:	bd70      	pop	{r4, r5, r6, pc}
   25040:	0003d0f8 	.word	0x0003d0f8
   25044:	0003d12e 	.word	0x0003d12e
   25048:	0003baac 	.word	0x0003baac
   2504c:	0003d149 	.word	0x0003d149
   25050:	e000ed14 	.word	0xe000ed14

00025054 <_arch_isr_direct_pm>:
	z_arm_reserved();
}

#ifdef CONFIG_SYS_POWER_MANAGEMENT
void _arch_isr_direct_pm(void)
{
   25054:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
   25056:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
   25058:	4b04      	ldr	r3, [pc, #16]	; (2506c <_arch_isr_direct_pm+0x18>)
   2505a:	6a18      	ldr	r0, [r3, #32]
   2505c:	b118      	cbz	r0, 25066 <_arch_isr_direct_pm+0x12>
		s32_t idle_val = _kernel.idle;

		_kernel.idle = 0;
   2505e:	2200      	movs	r2, #0
   25060:	621a      	str	r2, [r3, #32]
		z_sys_power_save_idle_exit(idle_val);
   25062:	f014 fcac 	bl	399be <z_sys_power_save_idle_exit>

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
   25066:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
   25068:	bd08      	pop	{r3, pc}
   2506a:	bf00      	nop
   2506c:	20022108 	.word	0x20022108

00025070 <arch_new_thread>:
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     size_t stackSize, k_thread_entry_t pEntry,
		     void *parameter1, void *parameter2, void *parameter3,
		     int priority, unsigned int options)
{
   25070:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   25074:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   25076:	4605      	mov	r5, r0
	char *pStackMem = Z_THREAD_STACK_BUFFER(stack);
	char *stackEnd;
	/* Offset between the top of stack and the high end of stack area. */
	u32_t top_of_stack_offset = 0U;

	Z_ASSERT_VALID_PRIO(priority, pEntry);
   25078:	2e0f      	cmp	r6, #15
{
   2507a:	4688      	mov	r8, r1
   2507c:	4691      	mov	r9, r2
   2507e:	461f      	mov	r7, r3
	Z_ASSERT_VALID_PRIO(priority, pEntry);
   25080:	d126      	bne.n	250d0 <arch_new_thread+0x60>
   25082:	4b1e      	ldr	r3, [pc, #120]	; (250fc <arch_new_thread+0x8c>)
   25084:	429f      	cmp	r7, r3
   25086:	d127      	bne.n	250d8 <arch_new_thread+0x68>
#endif
	stackEnd = pStackMem + stackSize;

	struct __esf *pInitCtx;

	z_new_thread_init(thread, pStackMem, stackSize, priority,
   25088:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   2508a:	464a      	mov	r2, r9
   2508c:	9300      	str	r3, [sp, #0]
   2508e:	4641      	mov	r1, r8
   25090:	4633      	mov	r3, r6
   25092:	4628      	mov	r0, r5
   25094:	f014 fd44 	bl	39b20 <z_new_thread_init>
	stackEnd = pStackMem + stackSize;
   25098:	eb08 0409 	add.w	r4, r8, r9
	pInitCtx->basic.pc = (u32_t)z_thread_entry;
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
   2509c:	4a18      	ldr	r2, [pc, #96]	; (25100 <arch_new_thread+0x90>)
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
   2509e:	f1a4 0320 	sub.w	r3, r4, #32
   250a2:	f023 0307 	bic.w	r3, r3, #7
	pInitCtx->basic.pc &= 0xfffffffe;
   250a6:	f022 0201 	bic.w	r2, r2, #1
   250aa:	619a      	str	r2, [r3, #24]
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
	pInitCtx->basic.a2 = (u32_t)parameter1;
   250ac:	9a0a      	ldr	r2, [sp, #40]	; 0x28
	pInitCtx->basic.a1 = (u32_t)pEntry;
   250ae:	601f      	str	r7, [r3, #0]
	pInitCtx->basic.a2 = (u32_t)parameter1;
   250b0:	605a      	str	r2, [r3, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
   250b2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   250b4:	609a      	str	r2, [r3, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
   250b6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   250b8:	60da      	str	r2, [r3, #12]
	pInitCtx->basic.xpsr =
   250ba:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   250be:	61da      	str	r2, [r3, #28]
		0x01000000UL; /* clear all, thumb bit is 1, even if RO */

	thread->callee_saved.psp = (u32_t)pInitCtx;
   250c0:	64ab      	str	r3, [r5, #72]	; 0x48
#if defined(CONFIG_CPU_CORTEX_R)
	pInitCtx->basic.lr = (u32_t)pInitCtx->basic.pc;
	thread->callee_saved.spsr = A_BIT | T_BIT | MODE_SYS;
	thread->callee_saved.lr = (u32_t)pInitCtx->basic.pc;
#endif
	thread->arch.basepri = 0;
   250c2:	2300      	movs	r3, #0
   250c4:	666b      	str	r3, [r5, #100]	; 0x64

#if defined(CONFIG_USERSPACE) || defined(CONFIG_FP_SHARING)
	thread->arch.mode = 0;
   250c6:	f8c5 30ac 	str.w	r3, [r5, #172]	; 0xac

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   250ca:	b003      	add	sp, #12
   250cc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	Z_ASSERT_VALID_PRIO(priority, pEntry);
   250d0:	f106 0310 	add.w	r3, r6, #16
   250d4:	2b1e      	cmp	r3, #30
   250d6:	d9d7      	bls.n	25088 <arch_new_thread+0x18>
   250d8:	232d      	movs	r3, #45	; 0x2d
   250da:	4a0a      	ldr	r2, [pc, #40]	; (25104 <arch_new_thread+0x94>)
   250dc:	490a      	ldr	r1, [pc, #40]	; (25108 <arch_new_thread+0x98>)
   250de:	480b      	ldr	r0, [pc, #44]	; (2510c <arch_new_thread+0x9c>)
   250e0:	f012 fdee 	bl	37cc0 <printk>
   250e4:	4631      	mov	r1, r6
   250e6:	f06f 030f 	mvn.w	r3, #15
   250ea:	220e      	movs	r2, #14
   250ec:	4808      	ldr	r0, [pc, #32]	; (25110 <arch_new_thread+0xa0>)
   250ee:	f012 fde7 	bl	37cc0 <printk>
   250f2:	212d      	movs	r1, #45	; 0x2d
   250f4:	4803      	ldr	r0, [pc, #12]	; (25104 <arch_new_thread+0x94>)
   250f6:	f012 fe29 	bl	37d4c <assert_post_action>
   250fa:	e7c5      	b.n	25088 <arch_new_thread+0x18>
   250fc:	00032479 	.word	0x00032479
   25100:	00037d03 	.word	0x00037d03
   25104:	0003d17e 	.word	0x0003d17e
   25108:	0003d1b0 	.word	0x0003d1b0
   2510c:	0003baac 	.word	0x0003baac
   25110:	0003d23d 	.word	0x0003d23d

00025114 <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
   25114:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25116:	461f      	mov	r7, r3
   25118:	4606      	mov	r6, r0
   2511a:	460d      	mov	r5, r1
   2511c:	4614      	mov	r4, r2
// Re-enable using built-in when GCC has been fixed
// || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
  __builtin_arm_set_fpscr(fpscr);
#else
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
   2511e:	2300      	movs	r3, #0
   25120:	eee1 3a10 	vmsr	fpscr, r3
  __ASM volatile ("MRS %0, control" : "=r" (result) );
   25124:	f3ef 8214 	mrs	r2, CONTROL
	 * initialized at thread creation for threads that make use of the FP).
	 */
	__set_FPSCR(0);
#if defined(CONFIG_FP_SHARING)
	/* In Sharing mode clearing FPSCR may set the CONTROL.FPCA flag. */
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
   25128:	f022 0204 	bic.w	r2, r2, #4
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
   2512c:	f382 8814 	msr	CONTROL, r2
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
   25130:	f3bf 8f6f 	isb	sy
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   25134:	f000 fc2a 	bl	2598c <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);

	_current = main_thread;
   25138:	4b0b      	ldr	r3, [pc, #44]	; (25168 <arch_switch_to_main_thread+0x54>)
	start_of_main_stack =
   2513a:	442c      	add	r4, r5
#ifdef CONFIG_ARM_MPU
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
   2513c:	4630      	mov	r0, r6
	_current = main_thread;
   2513e:	609e      	str	r6, [r3, #8]
	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);
   25140:	f024 0407 	bic.w	r4, r4, #7
	z_arm_configure_dynamic_mpu_regions(main_thread);
   25144:	f012 ff6e 	bl	38024 <z_arm_configure_dynamic_mpu_regions>
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   25148:	f385 880b 	msr	PSPLIM, r5

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   2514c:	4638      	mov	r0, r7
   2514e:	f384 8809 	msr	PSP, r4
   25152:	2100      	movs	r1, #0
   25154:	b663      	cpsie	if
   25156:	f381 8811 	msr	BASEPRI, r1
   2515a:	f3bf 8f6f 	isb	sy
   2515e:	2200      	movs	r2, #0
   25160:	2300      	movs	r3, #0
   25162:	f012 fdce 	bl	37d02 <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   25166:	bf00      	nop
   25168:	20022108 	.word	0x20022108

0002516c <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   2516c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   25170:	4681      	mov	r9, r0
   25172:	b086      	sub	sp, #24

	if (esf != NULL) {
   25174:	460c      	mov	r4, r1
   25176:	2900      	cmp	r1, #0
   25178:	d075      	beq.n	25266 <z_arm_fatal_error+0xfa>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
   2517a:	2301      	movs	r3, #1
   2517c:	f04f 0000 	mov.w	r0, #0
   25180:	4d3c      	ldr	r5, [pc, #240]	; (25274 <z_arm_fatal_error+0x108>)
   25182:	f363 0007 	bfi	r0, r3, #0, #8
   25186:	4b3c      	ldr	r3, [pc, #240]	; (25278 <z_arm_fatal_error+0x10c>)
   25188:	4627      	mov	r7, r4
   2518a:	1aed      	subs	r5, r5, r3
   2518c:	688b      	ldr	r3, [r1, #8]
   2518e:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   25192:	9300      	str	r3, [sp, #0]
   25194:	e9d1 2300 	ldrd	r2, r3, [r1]
   25198:	f365 108f 	bfi	r0, r5, #6, #10
   2519c:	4937      	ldr	r1, [pc, #220]	; (2527c <z_arm_fatal_error+0x110>)
   2519e:	f012 fde6 	bl	37d6e <log_string_sync>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
   251a2:	2301      	movs	r3, #1
   251a4:	f04f 0000 	mov.w	r0, #0
   251a8:	f363 0007 	bfi	r0, r3, #0, #8
   251ac:	6963      	ldr	r3, [r4, #20]
   251ae:	f365 108f 	bfi	r0, r5, #6, #10
   251b2:	9300      	str	r3, [sp, #0]
   251b4:	e9d4 2303 	ldrd	r2, r3, [r4, #12]
   251b8:	4931      	ldr	r1, [pc, #196]	; (25280 <z_arm_fatal_error+0x114>)
   251ba:	f012 fdd8 	bl	37d6e <log_string_sync>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
   251be:	2301      	movs	r3, #1
   251c0:	f04f 0000 	mov.w	r0, #0
   251c4:	f363 0007 	bfi	r0, r3, #0, #8
   251c8:	f365 108f 	bfi	r0, r5, #6, #10
   251cc:	69e2      	ldr	r2, [r4, #28]
   251ce:	492d      	ldr	r1, [pc, #180]	; (25284 <z_arm_fatal_error+0x118>)
   251d0:	f012 fdcd 	bl	37d6e <log_string_sync>
	for (int i = 0; i < 16; i += 4) {
   251d4:	2600      	movs	r6, #0
		LOG_ERR("s[%2d]:  0x%08x  s[%2d]:  0x%08x"
   251d6:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 25290 <z_arm_fatal_error+0x124>
   251da:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
   251de:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   251e2:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   251e6:	f043 0301 	orr.w	r3, r3, #1
   251ea:	f363 0807 	bfi	r8, r3, #0, #8
   251ee:	1cf3      	adds	r3, r6, #3
   251f0:	ed97 7a08 	vldr	s14, [r7, #32]
   251f4:	9304      	str	r3, [sp, #16]
   251f6:	edcd 7a05 	vstr	s15, [sp, #20]
   251fa:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
   251fe:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   25202:	1cb3      	adds	r3, r6, #2
   25204:	9302      	str	r3, [sp, #8]
   25206:	edcd 7a03 	vstr	s15, [sp, #12]
   2520a:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
   2520e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   25212:	edcd 7a01 	vstr	s15, [sp, #4]
   25216:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2521a:	1c73      	adds	r3, r6, #1
   2521c:	f365 188f 	bfi	r8, r5, #6, #10
   25220:	9300      	str	r3, [sp, #0]
   25222:	4632      	mov	r2, r6
   25224:	ee17 3a90 	vmov	r3, s15
   25228:	4651      	mov	r1, sl
   2522a:	4640      	mov	r0, r8
	for (int i = 0; i < 16; i += 4) {
   2522c:	3604      	adds	r6, #4
		LOG_ERR("s[%2d]:  0x%08x  s[%2d]:  0x%08x"
   2522e:	f012 fd9e 	bl	37d6e <log_string_sync>
	for (int i = 0; i < 16; i += 4) {
   25232:	2e10      	cmp	r6, #16
   25234:	f107 0710 	add.w	r7, r7, #16
   25238:	d1cf      	bne.n	251da <z_arm_fatal_error+0x6e>
	LOG_ERR("fpscr:  0x%08x", esf->fpscr);
   2523a:	2301      	movs	r3, #1
   2523c:	f04f 0000 	mov.w	r0, #0
   25240:	f363 0007 	bfi	r0, r3, #0, #8
   25244:	f365 108f 	bfi	r0, r5, #6, #10
   25248:	6e22      	ldr	r2, [r4, #96]	; 0x60
   2524a:	490f      	ldr	r1, [pc, #60]	; (25288 <z_arm_fatal_error+0x11c>)
   2524c:	f012 fd8f 	bl	37d6e <log_string_sync>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
   25250:	f04f 0000 	mov.w	r0, #0
   25254:	2301      	movs	r3, #1
   25256:	f363 0007 	bfi	r0, r3, #0, #8
   2525a:	f365 108f 	bfi	r0, r5, #6, #10
   2525e:	69a2      	ldr	r2, [r4, #24]
   25260:	490a      	ldr	r1, [pc, #40]	; (2528c <z_arm_fatal_error+0x120>)
   25262:	f012 fd84 	bl	37d6e <log_string_sync>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   25266:	4621      	mov	r1, r4
   25268:	4648      	mov	r0, r9
}
   2526a:	b006      	add	sp, #24
   2526c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_fatal_error(reason, esf);
   25270:	f00d b886 	b.w	32380 <z_fatal_error>
   25274:	0003aeb0 	.word	0x0003aeb0
   25278:	0003ade0 	.word	0x0003ade0
   2527c:	0003d26e 	.word	0x0003d26e
   25280:	0003d29d 	.word	0x0003d29d
   25284:	0003d2cc 	.word	0x0003d2cc
   25288:	0003d31e 	.word	0x0003d31e
   2528c:	0003d32d 	.word	0x0003d32d
   25290:	0003d2db 	.word	0x0003d2db

00025294 <z_arm_prep_c>:
#else
#define VECTOR_ADDRESS CONFIG_SRAM_BASE_ADDRESS
#endif
static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   25294:	4a11      	ldr	r2, [pc, #68]	; (252dc <z_arm_prep_c+0x48>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
   25296:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   25298:	4b11      	ldr	r3, [pc, #68]	; (252e0 <z_arm_prep_c+0x4c>)
   2529a:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   2529e:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   252a0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   252a4:	f3bf 8f6f 	isb	sy
	SCB->CPACR |= CPACR_CP10_PRIV_ACCESS | CPACR_CP11_PRIV_ACCESS;
   252a8:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   252ac:	f442 02a0 	orr.w	r2, r2, #5242880	; 0x500000
   252b0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	FPU->FPCCR = FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk;
   252b4:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
   252b8:	f8c3 2234 	str.w	r2, [r3, #564]	; 0x234
  __ASM volatile ("dsb 0xF":::"memory");
   252bc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   252c0:	f3bf 8f6f 	isb	sy
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
   252c4:	2300      	movs	r3, #0
   252c6:	eee1 3a10 	vmsr	fpscr, r3
	relocate_vector_table();
	enable_floating_point();
	z_bss_zero();
   252ca:	f00d f8ef 	bl	324ac <z_bss_zero>
	z_data_copy();
   252ce:	f00d f8f7 	bl	324c0 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_int_lib_init();
   252d2:	f000 fb11 	bl	258f8 <z_arm_int_lib_init>
	z_cstart();
   252d6:	f00d f925 	bl	32524 <z_cstart>
   252da:	bf00      	nop
   252dc:	0001c200 	.word	0x0001c200
   252e0:	e000ed00 	.word	0xe000ed00

000252e4 <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
   252e4:	f012 fd3a 	bl	37d5c <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   252e8:	2020      	movs	r0, #32
    msr BASEPRI, r0
   252ea:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to _interrupt_stack during initialization.
     */
    ldr r0, =_interrupt_stack
   252ee:	4808      	ldr	r0, [pc, #32]	; (25310 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
   252f0:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   252f4:	1840      	adds	r0, r0, r1
    msr PSP, r0
   252f6:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   252fa:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   252fe:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   25300:	4308      	orrs	r0, r1
    msr CONTROL, r0
   25302:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   25306:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   2530a:	f7ff ffc3 	bl	25294 <z_arm_prep_c>
   2530e:	0000      	.short	0x0000
    ldr r0, =_interrupt_stack
   25310:	200289e0 	.word	0x200289e0

00025314 <mem_manage_fault.isra.2>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   25314:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			      bool *recoverable)
{
	u32_t reason = K_ERR_CPU_EXCEPTION;
	u32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");
   25316:	2301      	movs	r3, #1
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   25318:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** MPU FAULT *****");
   2531a:	f04f 0000 	mov.w	r0, #0
   2531e:	4c40      	ldr	r4, [pc, #256]	; (25420 <_flash_used+0xf4>)
   25320:	f363 0007 	bfi	r0, r3, #0, #8
   25324:	4b3f      	ldr	r3, [pc, #252]	; (25424 <_flash_used+0xf8>)
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   25326:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
   25328:	1ae4      	subs	r4, r4, r3
   2532a:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   2532e:	493e      	ldr	r1, [pc, #248]	; (25428 <_flash_used+0xfc>)
   25330:	f364 108f 	bfi	r0, r4, #6, #10
   25334:	f012 fd1b 	bl	37d6e <log_string_sync>

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   25338:	4b3c      	ldr	r3, [pc, #240]	; (2542c <_flash_used+0x100>)
   2533a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   2533c:	06d9      	lsls	r1, r3, #27
   2533e:	d509      	bpl.n	25354 <_flash_used+0x28>
		PR_FAULT_INFO("  Stacking error (context area might be"
   25340:	f04f 0000 	mov.w	r0, #0
   25344:	2301      	movs	r3, #1
   25346:	f363 0007 	bfi	r0, r3, #0, #8
   2534a:	f364 108f 	bfi	r0, r4, #6, #10
   2534e:	4938      	ldr	r1, [pc, #224]	; (25430 <_flash_used+0x104>)
   25350:	f012 fd0d 	bl	37d6e <log_string_sync>
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   25354:	4b35      	ldr	r3, [pc, #212]	; (2542c <_flash_used+0x100>)
   25356:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   25358:	071a      	lsls	r2, r3, #28
   2535a:	d509      	bpl.n	25370 <_flash_used+0x44>
		PR_FAULT_INFO("  Unstacking error");
   2535c:	f04f 0000 	mov.w	r0, #0
   25360:	2301      	movs	r3, #1
   25362:	f363 0007 	bfi	r0, r3, #0, #8
   25366:	f364 108f 	bfi	r0, r4, #6, #10
   2536a:	4932      	ldr	r1, [pc, #200]	; (25434 <_flash_used+0x108>)
   2536c:	f012 fcff 	bl	37d6e <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   25370:	4d2e      	ldr	r5, [pc, #184]	; (2542c <_flash_used+0x100>)
   25372:	6aab      	ldr	r3, [r5, #40]	; 0x28
   25374:	079b      	lsls	r3, r3, #30
   25376:	d51c      	bpl.n	253b2 <_flash_used+0x86>
		PR_FAULT_INFO("  Data Access Violation");
   25378:	2301      	movs	r3, #1
   2537a:	f04f 0000 	mov.w	r0, #0
   2537e:	f363 0007 	bfi	r0, r3, #0, #8
   25382:	f364 108f 	bfi	r0, r4, #6, #10
   25386:	492c      	ldr	r1, [pc, #176]	; (25438 <_flash_used+0x10c>)
   25388:	f012 fcf1 	bl	37d6e <log_string_sync>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		mmfar = SCB->MMFAR;
   2538c:	6b6a      	ldr	r2, [r5, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   2538e:	6aab      	ldr	r3, [r5, #40]	; 0x28
   25390:	0618      	lsls	r0, r3, #24
   25392:	d50e      	bpl.n	253b2 <_flash_used+0x86>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
   25394:	f04f 0000 	mov.w	r0, #0
   25398:	2301      	movs	r3, #1
   2539a:	f363 0007 	bfi	r0, r3, #0, #8
   2539e:	f364 108f 	bfi	r0, r4, #6, #10
   253a2:	4926      	ldr	r1, [pc, #152]	; (2543c <_flash_used+0x110>)
   253a4:	f012 fce3 	bl	37d6e <log_string_sync>
			if (from_hard_fault) {
   253a8:	b11f      	cbz	r7, 253b2 <_flash_used+0x86>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   253aa:	6aab      	ldr	r3, [r5, #40]	; 0x28
   253ac:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   253b0:	62ab      	str	r3, [r5, #40]	; 0x28
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   253b2:	4b1e      	ldr	r3, [pc, #120]	; (2542c <_flash_used+0x100>)
   253b4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   253b6:	07d9      	lsls	r1, r3, #31
   253b8:	d509      	bpl.n	253ce <_flash_used+0xa2>
		PR_FAULT_INFO("  Instruction Access Violation");
   253ba:	f04f 0000 	mov.w	r0, #0
   253be:	2301      	movs	r3, #1
   253c0:	f363 0007 	bfi	r0, r3, #0, #8
   253c4:	f364 108f 	bfi	r0, r4, #6, #10
   253c8:	491d      	ldr	r1, [pc, #116]	; (25440 <_flash_used+0x114>)
   253ca:	f012 fcd0 	bl	37d6e <log_string_sync>
	}
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   253ce:	4b17      	ldr	r3, [pc, #92]	; (2542c <_flash_used+0x100>)
   253d0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   253d2:	069a      	lsls	r2, r3, #26
   253d4:	d509      	bpl.n	253ea <_flash_used+0xbe>
		PR_FAULT_INFO(
   253d6:	f04f 0000 	mov.w	r0, #0
   253da:	2301      	movs	r3, #1
   253dc:	f363 0007 	bfi	r0, r3, #0, #8
   253e0:	f364 108f 	bfi	r0, r4, #6, #10
   253e4:	4917      	ldr	r1, [pc, #92]	; (25444 <_flash_used+0x118>)
   253e6:	f012 fcc2 	bl	37d6e <log_string_sync>
	 * if the memory violation error is a stack corruption.
	 *
	 * By design, being a Stacking MemManage fault is a necessary
	 * and sufficient condition for a thread stack corruption.
	 */
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
   253ea:	4b10      	ldr	r3, [pc, #64]	; (2542c <_flash_used+0x100>)
   253ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   253ee:	06db      	lsls	r3, r3, #27
   253f0:	d50e      	bpl.n	25410 <_flash_used+0xe4>
					"Stacking error not a stack fail\n");
			}
		}
#else
	(void)mmfar;
	__ASSERT(0,
   253f2:	4915      	ldr	r1, [pc, #84]	; (25448 <_flash_used+0x11c>)
   253f4:	f44f 739b 	mov.w	r3, #310	; 0x136
   253f8:	4a14      	ldr	r2, [pc, #80]	; (2544c <_flash_used+0x120>)
   253fa:	4815      	ldr	r0, [pc, #84]	; (25450 <_flash_used+0x124>)
   253fc:	f012 fc60 	bl	37cc0 <printk>
   25400:	4814      	ldr	r0, [pc, #80]	; (25454 <_flash_used+0x128>)
   25402:	f012 fc5d 	bl	37cc0 <printk>
   25406:	f44f 719b 	mov.w	r1, #310	; 0x136
   2540a:	4810      	ldr	r0, [pc, #64]	; (2544c <_flash_used+0x120>)
   2540c:	f012 fc9e 	bl	37d4c <assert_post_action>

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf);
   25410:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   25412:	4a06      	ldr	r2, [pc, #24]	; (2542c <_flash_used+0x100>)
   25414:	6a93      	ldr	r3, [r2, #40]	; 0x28
   25416:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
   2541a:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
   2541c:	7030      	strb	r0, [r6, #0]

	return reason;
}
   2541e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   25420:	0003aeb0 	.word	0x0003aeb0
   25424:	0003ade0 	.word	0x0003ade0
   25428:	0003d3e3 	.word	0x0003d3e3
   2542c:	e000ed00 	.word	0xe000ed00
   25430:	0003d3f9 	.word	0x0003d3f9
   25434:	0003d42c 	.word	0x0003d42c
   25438:	0003d43f 	.word	0x0003d43f
   2543c:	0003d457 	.word	0x0003d457
   25440:	0003d46d 	.word	0x0003d46d
   25444:	0003d48c 	.word	0x0003d48c
   25448:	0003f10e 	.word	0x0003f10e
   2544c:	0003d4bb 	.word	0x0003d4bb
   25450:	0003baac 	.word	0x0003baac
   25454:	0003d4f5 	.word	0x0003d4f5

00025458 <bus_fault.isra.3>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return N/A
 */
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   25458:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");
   2545a:	2301      	movs	r3, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   2545c:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** BUS FAULT *****");
   2545e:	f04f 0000 	mov.w	r0, #0
   25462:	4c3d      	ldr	r4, [pc, #244]	; (25558 <bus_fault.isra.3+0x100>)
   25464:	f363 0007 	bfi	r0, r3, #0, #8
   25468:	4b3c      	ldr	r3, [pc, #240]	; (2555c <bus_fault.isra.3+0x104>)
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   2546a:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
   2546c:	1ae4      	subs	r4, r4, r3
   2546e:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   25472:	493b      	ldr	r1, [pc, #236]	; (25560 <bus_fault.isra.3+0x108>)
   25474:	f364 108f 	bfi	r0, r4, #6, #10
   25478:	f012 fc79 	bl	37d6e <log_string_sync>

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   2547c:	4b39      	ldr	r3, [pc, #228]	; (25564 <bus_fault.isra.3+0x10c>)
   2547e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   25480:	04d9      	lsls	r1, r3, #19
   25482:	d509      	bpl.n	25498 <bus_fault.isra.3+0x40>
		PR_FAULT_INFO("  Stacking error");
   25484:	f04f 0000 	mov.w	r0, #0
   25488:	2301      	movs	r3, #1
   2548a:	f363 0007 	bfi	r0, r3, #0, #8
   2548e:	f364 108f 	bfi	r0, r4, #6, #10
   25492:	4935      	ldr	r1, [pc, #212]	; (25568 <bus_fault.isra.3+0x110>)
   25494:	f012 fc6b 	bl	37d6e <log_string_sync>
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   25498:	4b32      	ldr	r3, [pc, #200]	; (25564 <bus_fault.isra.3+0x10c>)
   2549a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   2549c:	051a      	lsls	r2, r3, #20
   2549e:	d509      	bpl.n	254b4 <bus_fault.isra.3+0x5c>
		PR_FAULT_INFO("  Unstacking error");
   254a0:	f04f 0000 	mov.w	r0, #0
   254a4:	2301      	movs	r3, #1
   254a6:	f363 0007 	bfi	r0, r3, #0, #8
   254aa:	f364 108f 	bfi	r0, r4, #6, #10
   254ae:	492f      	ldr	r1, [pc, #188]	; (2556c <bus_fault.isra.3+0x114>)
   254b0:	f012 fc5d 	bl	37d6e <log_string_sync>
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   254b4:	4d2b      	ldr	r5, [pc, #172]	; (25564 <bus_fault.isra.3+0x10c>)
   254b6:	6aab      	ldr	r3, [r5, #40]	; 0x28
   254b8:	059b      	lsls	r3, r3, #22
   254ba:	d51c      	bpl.n	254f6 <bus_fault.isra.3+0x9e>
		PR_FAULT_INFO("  Precise data bus error");
   254bc:	2301      	movs	r3, #1
   254be:	f04f 0000 	mov.w	r0, #0
   254c2:	f363 0007 	bfi	r0, r3, #0, #8
   254c6:	f364 108f 	bfi	r0, r4, #6, #10
   254ca:	4929      	ldr	r1, [pc, #164]	; (25570 <bus_fault.isra.3+0x118>)
   254cc:	f012 fc4f 	bl	37d6e <log_string_sync>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
   254d0:	6baa      	ldr	r2, [r5, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   254d2:	6aab      	ldr	r3, [r5, #40]	; 0x28
   254d4:	0418      	lsls	r0, r3, #16
   254d6:	d50e      	bpl.n	254f6 <bus_fault.isra.3+0x9e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
   254d8:	f04f 0000 	mov.w	r0, #0
   254dc:	2301      	movs	r3, #1
   254de:	f363 0007 	bfi	r0, r3, #0, #8
   254e2:	f364 108f 	bfi	r0, r4, #6, #10
   254e6:	4923      	ldr	r1, [pc, #140]	; (25574 <bus_fault.isra.3+0x11c>)
   254e8:	f012 fc41 	bl	37d6e <log_string_sync>
			if (from_hard_fault) {
   254ec:	b11f      	cbz	r7, 254f6 <bus_fault.isra.3+0x9e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   254ee:	6aab      	ldr	r3, [r5, #40]	; 0x28
   254f0:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   254f4:	62ab      	str	r3, [r5, #40]	; 0x28
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   254f6:	4b1b      	ldr	r3, [pc, #108]	; (25564 <bus_fault.isra.3+0x10c>)
   254f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   254fa:	0559      	lsls	r1, r3, #21
   254fc:	d509      	bpl.n	25512 <bus_fault.isra.3+0xba>
		PR_FAULT_INFO("  Imprecise data bus error");
   254fe:	f04f 0000 	mov.w	r0, #0
   25502:	2301      	movs	r3, #1
   25504:	f363 0007 	bfi	r0, r3, #0, #8
   25508:	f364 108f 	bfi	r0, r4, #6, #10
   2550c:	491a      	ldr	r1, [pc, #104]	; (25578 <bus_fault.isra.3+0x120>)
   2550e:	f012 fc2e 	bl	37d6e <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   25512:	4b14      	ldr	r3, [pc, #80]	; (25564 <bus_fault.isra.3+0x10c>)
   25514:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   25516:	05d2      	lsls	r2, r2, #23
   25518:	d511      	bpl.n	2553e <bus_fault.isra.3+0xe6>
		PR_FAULT_INFO("  Instruction bus error");
   2551a:	f04f 0000 	mov.w	r0, #0
   2551e:	2301      	movs	r3, #1
   25520:	4916      	ldr	r1, [pc, #88]	; (2557c <bus_fault.isra.3+0x124>)
   25522:	f363 0007 	bfi	r0, r3, #0, #8
   25526:	f364 108f 	bfi	r0, r4, #6, #10
#if !defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	}
#else
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   2552a:	f012 fc20 	bl	37d6e <log_string_sync>
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;

	*recoverable = memory_fault_recoverable(esf);
   2552e:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   25530:	4a0c      	ldr	r2, [pc, #48]	; (25564 <bus_fault.isra.3+0x10c>)
   25532:	6a93      	ldr	r3, [r2, #40]	; 0x28
   25534:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
   25538:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
   2553a:	7030      	strb	r0, [r6, #0]

	return reason;
}
   2553c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   2553e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   25540:	049b      	lsls	r3, r3, #18
   25542:	d5f4      	bpl.n	2552e <bus_fault.isra.3+0xd6>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   25544:	f04f 0000 	mov.w	r0, #0
   25548:	2301      	movs	r3, #1
   2554a:	f363 0007 	bfi	r0, r3, #0, #8
   2554e:	f364 108f 	bfi	r0, r4, #6, #10
   25552:	490b      	ldr	r1, [pc, #44]	; (25580 <bus_fault.isra.3+0x128>)
   25554:	e7e9      	b.n	2552a <bus_fault.isra.3+0xd2>
   25556:	bf00      	nop
   25558:	0003aeb0 	.word	0x0003aeb0
   2555c:	0003ade0 	.word	0x0003ade0
   25560:	0003d35b 	.word	0x0003d35b
   25564:	e000ed00 	.word	0xe000ed00
   25568:	0003d371 	.word	0x0003d371
   2556c:	0003d42c 	.word	0x0003d42c
   25570:	0003d382 	.word	0x0003d382
   25574:	0003d39b 	.word	0x0003d39b
   25578:	0003d3b0 	.word	0x0003d3b0
   2557c:	0003d3cb 	.word	0x0003d3cb
   25580:	0003d48c 	.word	0x0003d48c

00025584 <usage_fault.isra.4>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t usage_fault(const z_arch_esf_t *esf)
   25584:	b538      	push	{r3, r4, r5, lr}
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
   25586:	f04f 0000 	mov.w	r0, #0
   2558a:	2301      	movs	r3, #1
   2558c:	4c3c      	ldr	r4, [pc, #240]	; (25680 <usage_fault.isra.4+0xfc>)
   2558e:	f363 0007 	bfi	r0, r3, #0, #8
   25592:	4b3c      	ldr	r3, [pc, #240]	; (25684 <usage_fault.isra.4+0x100>)
   25594:	493c      	ldr	r1, [pc, #240]	; (25688 <usage_fault.isra.4+0x104>)
   25596:	1ae4      	subs	r4, r4, r3
   25598:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   2559c:	f364 108f 	bfi	r0, r4, #6, #10
   255a0:	f012 fbe5 	bl	37d6e <log_string_sync>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   255a4:	4b39      	ldr	r3, [pc, #228]	; (2568c <usage_fault.isra.4+0x108>)
   255a6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   255a8:	019b      	lsls	r3, r3, #6
   255aa:	d509      	bpl.n	255c0 <usage_fault.isra.4+0x3c>
		PR_FAULT_INFO("  Division by zero");
   255ac:	f04f 0000 	mov.w	r0, #0
   255b0:	2301      	movs	r3, #1
   255b2:	f363 0007 	bfi	r0, r3, #0, #8
   255b6:	f364 108f 	bfi	r0, r4, #6, #10
   255ba:	4935      	ldr	r1, [pc, #212]	; (25690 <usage_fault.isra.4+0x10c>)
   255bc:	f012 fbd7 	bl	37d6e <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   255c0:	4b32      	ldr	r3, [pc, #200]	; (2568c <usage_fault.isra.4+0x108>)
   255c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   255c4:	01dd      	lsls	r5, r3, #7
   255c6:	d509      	bpl.n	255dc <usage_fault.isra.4+0x58>
		PR_FAULT_INFO("  Unaligned memory access");
   255c8:	f04f 0000 	mov.w	r0, #0
   255cc:	2301      	movs	r3, #1
   255ce:	f363 0007 	bfi	r0, r3, #0, #8
   255d2:	f364 108f 	bfi	r0, r4, #6, #10
   255d6:	492f      	ldr	r1, [pc, #188]	; (25694 <usage_fault.isra.4+0x110>)
   255d8:	f012 fbc9 	bl	37d6e <log_string_sync>
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
   255dc:	4b2b      	ldr	r3, [pc, #172]	; (2568c <usage_fault.isra.4+0x108>)
   255de:	6a9d      	ldr	r5, [r3, #40]	; 0x28
   255e0:	f415 1580 	ands.w	r5, r5, #1048576	; 0x100000
   255e4:	d00a      	beq.n	255fc <usage_fault.isra.4+0x78>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
   255e6:	2301      	movs	r3, #1
   255e8:	f04f 0000 	mov.w	r0, #0
   255ec:	f363 0007 	bfi	r0, r3, #0, #8
   255f0:	f364 108f 	bfi	r0, r4, #6, #10
   255f4:	4928      	ldr	r1, [pc, #160]	; (25698 <usage_fault.isra.4+0x114>)
   255f6:	f012 fbba 	bl	37d6e <log_string_sync>
		 * prevents the context area to be loaded on the stack upon
		 * UsageFault exception entry. As a result, we cannot rely
		 * on the reported faulty instruction address, to determine
		 * the instruction that triggered the stack overflow.
		 */
		reason = K_ERR_STACK_CHK_FAIL;
   255fa:	2502      	movs	r5, #2
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   255fc:	4b23      	ldr	r3, [pc, #140]	; (2568c <usage_fault.isra.4+0x108>)
   255fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   25600:	0318      	lsls	r0, r3, #12
   25602:	d509      	bpl.n	25618 <usage_fault.isra.4+0x94>
		PR_FAULT_INFO("  No coprocessor instructions");
   25604:	f04f 0000 	mov.w	r0, #0
   25608:	2301      	movs	r3, #1
   2560a:	f363 0007 	bfi	r0, r3, #0, #8
   2560e:	f364 108f 	bfi	r0, r4, #6, #10
   25612:	4922      	ldr	r1, [pc, #136]	; (2569c <usage_fault.isra.4+0x118>)
   25614:	f012 fbab 	bl	37d6e <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   25618:	4b1c      	ldr	r3, [pc, #112]	; (2568c <usage_fault.isra.4+0x108>)
   2561a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   2561c:	0359      	lsls	r1, r3, #13
   2561e:	d509      	bpl.n	25634 <usage_fault.isra.4+0xb0>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
   25620:	f04f 0000 	mov.w	r0, #0
   25624:	2301      	movs	r3, #1
   25626:	f363 0007 	bfi	r0, r3, #0, #8
   2562a:	f364 108f 	bfi	r0, r4, #6, #10
   2562e:	491c      	ldr	r1, [pc, #112]	; (256a0 <usage_fault.isra.4+0x11c>)
   25630:	f012 fb9d 	bl	37d6e <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   25634:	4b15      	ldr	r3, [pc, #84]	; (2568c <usage_fault.isra.4+0x108>)
   25636:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   25638:	039a      	lsls	r2, r3, #14
   2563a:	d509      	bpl.n	25650 <usage_fault.isra.4+0xcc>
		PR_FAULT_INFO("  Illegal use of the EPSR");
   2563c:	f04f 0000 	mov.w	r0, #0
   25640:	2301      	movs	r3, #1
   25642:	f363 0007 	bfi	r0, r3, #0, #8
   25646:	f364 108f 	bfi	r0, r4, #6, #10
   2564a:	4916      	ldr	r1, [pc, #88]	; (256a4 <usage_fault.isra.4+0x120>)
   2564c:	f012 fb8f 	bl	37d6e <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   25650:	4b0e      	ldr	r3, [pc, #56]	; (2568c <usage_fault.isra.4+0x108>)
   25652:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   25654:	03db      	lsls	r3, r3, #15
   25656:	d509      	bpl.n	2566c <usage_fault.isra.4+0xe8>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
   25658:	f04f 0000 	mov.w	r0, #0
   2565c:	2301      	movs	r3, #1
   2565e:	f363 0007 	bfi	r0, r3, #0, #8
   25662:	f364 108f 	bfi	r0, r4, #6, #10
   25666:	4910      	ldr	r1, [pc, #64]	; (256a8 <usage_fault.isra.4+0x124>)
   25668:	f012 fb81 	bl	37d6e <log_string_sync>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   2566c:	4a07      	ldr	r2, [pc, #28]	; (2568c <usage_fault.isra.4+0x108>)

	return reason;
}
   2566e:	4628      	mov	r0, r5
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   25670:	6a93      	ldr	r3, [r2, #40]	; 0x28
   25672:	ea6f 4303 	mvn.w	r3, r3, lsl #16
   25676:	ea6f 4313 	mvn.w	r3, r3, lsr #16
   2567a:	6293      	str	r3, [r2, #40]	; 0x28
}
   2567c:	bd38      	pop	{r3, r4, r5, pc}
   2567e:	bf00      	nop
   25680:	0003aeb0 	.word	0x0003aeb0
   25684:	0003ade0 	.word	0x0003ade0
   25688:	0003d52f 	.word	0x0003d52f
   2568c:	e000ed00 	.word	0xe000ed00
   25690:	0003d547 	.word	0x0003d547
   25694:	0003d55a 	.word	0x0003d55a
   25698:	0003d574 	.word	0x0003d574
   2569c:	0003d59e 	.word	0x0003d59e
   256a0:	0003d5bc 	.word	0x0003d5bc
   256a4:	0003d5e1 	.word	0x0003d5e1
   256a8:	0003d5fb 	.word	0x0003d5fb

000256ac <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
   256ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   256b0:	4b70      	ldr	r3, [pc, #448]	; (25874 <z_arm_fault+0x1c8>)
{
   256b2:	b09d      	sub	sp, #116	; 0x74
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   256b4:	f8d3 8004 	ldr.w	r8, [r3, #4]
{
   256b8:	4606      	mov	r6, r0
   256ba:	4689      	mov	r9, r1
   256bc:	4614      	mov	r4, r2
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   256be:	f3c8 0708 	ubfx	r7, r8, #0, #9
   256c2:	2500      	movs	r5, #0
   256c4:	f385 8811 	msr	BASEPRI, r5
   256c8:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   256cc:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
   256d0:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   256d4:	d11b      	bne.n	2570e <z_arm_fault+0x62>
	if (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {
   256d6:	07d0      	lsls	r0, r2, #31
   256d8:	d419      	bmi.n	2570e <z_arm_fault+0x62>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
   256da:	0651      	lsls	r1, r2, #25
   256dc:	d403      	bmi.n	256e6 <z_arm_fault+0x3a>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   256de:	0722      	lsls	r2, r4, #28
   256e0:	d412      	bmi.n	25708 <z_arm_fault+0x5c>
			*nested_exc = true;
   256e2:	2501      	movs	r5, #1
   256e4:	e012      	b.n	2570c <z_arm_fault+0x60>
		PR_FAULT_INFO("Exception occurred in Secure State");
   256e6:	2301      	movs	r3, #1
   256e8:	f04f 0000 	mov.w	r0, #0
   256ec:	4a62      	ldr	r2, [pc, #392]	; (25878 <z_arm_fault+0x1cc>)
   256ee:	f363 0007 	bfi	r0, r3, #0, #8
   256f2:	4b62      	ldr	r3, [pc, #392]	; (2587c <z_arm_fault+0x1d0>)
   256f4:	4962      	ldr	r1, [pc, #392]	; (25880 <z_arm_fault+0x1d4>)
   256f6:	1a9b      	subs	r3, r3, r2
   256f8:	08db      	lsrs	r3, r3, #3
   256fa:	f363 108f 	bfi	r0, r3, #6, #10
   256fe:	f012 fb36 	bl	37d6e <log_string_sync>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
   25702:	f014 0504 	ands.w	r5, r4, #4
   25706:	d001      	beq.n	2570c <z_arm_fault+0x60>
			ptr_esf = (z_arch_esf_t *)psp;
   25708:	464e      	mov	r6, r9
	*nested_exc = false;
   2570a:	2500      	movs	r5, #0

	/* Retrieve the Exception Stack Frame (ESF) to be supplied
	 * as argument to the remainder of the fault handling process.
	 */
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
   2570c:	b97e      	cbnz	r6, 2572e <z_arm_fault+0x82>
   2570e:	f240 33b1 	movw	r3, #945	; 0x3b1
   25712:	4a5c      	ldr	r2, [pc, #368]	; (25884 <z_arm_fault+0x1d8>)
   25714:	495c      	ldr	r1, [pc, #368]	; (25888 <z_arm_fault+0x1dc>)
   25716:	485d      	ldr	r0, [pc, #372]	; (2588c <z_arm_fault+0x1e0>)
   25718:	f012 fad2 	bl	37cc0 <printk>
   2571c:	485c      	ldr	r0, [pc, #368]	; (25890 <z_arm_fault+0x1e4>)
   2571e:	f012 facf 	bl	37cc0 <printk>
   25722:	f240 31b1 	movw	r1, #945	; 0x3b1
   25726:	4857      	ldr	r0, [pc, #348]	; (25884 <z_arm_fault+0x1d8>)
   25728:	f012 fb10 	bl	37d4c <assert_post_action>
   2572c:	2600      	movs	r6, #0
	*recoverable = false;
   2572e:	2300      	movs	r3, #0
   25730:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
   25734:	1efb      	subs	r3, r7, #3
   25736:	2b09      	cmp	r3, #9
   25738:	d87f      	bhi.n	2583a <z_arm_fault+0x18e>
   2573a:	e8df f003 	tbb	[pc, r3]
   2573e:	6905      	.short	0x6905
   25740:	7e7e4c6d 	.word	0x7e7e4c6d
   25744:	717e7e7e 	.word	0x717e7e7e
	PR_FAULT_INFO("***** HARD FAULT *****");
   25748:	2301      	movs	r3, #1
   2574a:	f04f 0000 	mov.w	r0, #0
	*recoverable = false;
   2574e:	f04f 0800 	mov.w	r8, #0
	PR_FAULT_INFO("***** HARD FAULT *****");
   25752:	f363 0007 	bfi	r0, r3, #0, #8
   25756:	4f49      	ldr	r7, [pc, #292]	; (2587c <z_arm_fault+0x1d0>)
   25758:	4b47      	ldr	r3, [pc, #284]	; (25878 <z_arm_fault+0x1cc>)
   2575a:	494e      	ldr	r1, [pc, #312]	; (25894 <z_arm_fault+0x1e8>)
   2575c:	1aff      	subs	r7, r7, r3
   2575e:	f3c7 07c9 	ubfx	r7, r7, #3, #10
   25762:	f367 108f 	bfi	r0, r7, #6, #10
   25766:	f012 fb02 	bl	37d6e <log_string_sync>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   2576a:	4b42      	ldr	r3, [pc, #264]	; (25874 <z_arm_fault+0x1c8>)
	*recoverable = false;
   2576c:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   25770:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   25772:	f014 0402 	ands.w	r4, r4, #2
   25776:	d00b      	beq.n	25790 <z_arm_fault+0xe4>
		PR_EXC("  Bus fault on vector table read");
   25778:	f04f 0000 	mov.w	r0, #0
   2577c:	2301      	movs	r3, #1
   2577e:	4946      	ldr	r1, [pc, #280]	; (25898 <z_arm_fault+0x1ec>)
   25780:	f363 0007 	bfi	r0, r3, #0, #8
   25784:	f367 108f 	bfi	r0, r7, #6, #10
	PR_FAULT_INFO(
   25788:	f012 faf1 	bl	37d6e <log_string_sync>
	u32_t reason = K_ERR_CPU_EXCEPTION;
   2578c:	2400      	movs	r4, #0
   2578e:	e025      	b.n	257dc <z_arm_fault+0x130>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   25790:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   25792:	005b      	lsls	r3, r3, #1
   25794:	d522      	bpl.n	257dc <z_arm_fault+0x130>
		PR_EXC("  Fault escalation (see below)");
   25796:	2301      	movs	r3, #1
   25798:	f04f 0000 	mov.w	r0, #0
   2579c:	f363 0007 	bfi	r0, r3, #0, #8
   257a0:	f367 108f 	bfi	r0, r7, #6, #10
   257a4:	493d      	ldr	r1, [pc, #244]	; (2589c <z_arm_fault+0x1f0>)
   257a6:	f012 fae2 	bl	37d6e <log_string_sync>
		if (SCB_MMFSR != 0) {
   257aa:	4b3d      	ldr	r3, [pc, #244]	; (258a0 <z_arm_fault+0x1f4>)
   257ac:	781b      	ldrb	r3, [r3, #0]
   257ae:	b12b      	cbz	r3, 257bc <z_arm_fault+0x110>
			reason = mem_manage_fault(esf, 1, recoverable);
   257b0:	2001      	movs	r0, #1
   257b2:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
   257b6:	f7ff fdad 	bl	25314 <mem_manage_fault.isra.2>
   257ba:	e00e      	b.n	257da <z_arm_fault+0x12e>
		} else if (SCB_BFSR != 0) {
   257bc:	4b39      	ldr	r3, [pc, #228]	; (258a4 <z_arm_fault+0x1f8>)
   257be:	781b      	ldrb	r3, [r3, #0]
   257c0:	b12b      	cbz	r3, 257ce <z_arm_fault+0x122>
			reason = bus_fault(esf, 1, recoverable);
   257c2:	2001      	movs	r0, #1
   257c4:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
   257c8:	f7ff fe46 	bl	25458 <bus_fault.isra.3>
   257cc:	e005      	b.n	257da <z_arm_fault+0x12e>
		} else if (SCB_UFSR != 0) {
   257ce:	4b36      	ldr	r3, [pc, #216]	; (258a8 <z_arm_fault+0x1fc>)
   257d0:	881b      	ldrh	r3, [r3, #0]
   257d2:	b29b      	uxth	r3, r3
   257d4:	b113      	cbz	r3, 257dc <z_arm_fault+0x130>
			reason = usage_fault(esf);
   257d6:	f7ff fed5 	bl	25584 <usage_fault.isra.4>
   257da:	4604      	mov	r4, r0
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
   257dc:	f89d 3007 	ldrb.w	r3, [sp, #7]
   257e0:	b99b      	cbnz	r3, 2580a <z_arm_fault+0x15e>
		return;
	}

	/* Copy ESF */
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   257e2:	2268      	movs	r2, #104	; 0x68
   257e4:	4631      	mov	r1, r6
   257e6:	a802      	add	r0, sp, #8
   257e8:	f014 fac9 	bl	39d7e <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
   257ec:	9b09      	ldr	r3, [sp, #36]	; 0x24
   257ee:	2d00      	cmp	r5, #0
   257f0:	d03a      	beq.n	25868 <z_arm_fault+0x1bc>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   257f2:	f3c3 0208 	ubfx	r2, r3, #0, #9
   257f6:	b922      	cbnz	r2, 25802 <z_arm_fault+0x156>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   257f8:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   257fc:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   25800:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
   25802:	a902      	add	r1, sp, #8
   25804:	4620      	mov	r0, r4
   25806:	f7ff fcb1 	bl	2516c <z_arm_fatal_error>
}
   2580a:	b01d      	add	sp, #116	; 0x74
   2580c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
   25810:	f10d 0107 	add.w	r1, sp, #7
   25814:	2000      	movs	r0, #0
   25816:	e7ce      	b.n	257b6 <z_arm_fault+0x10a>
		reason = bus_fault(esf, 0, recoverable);
   25818:	f10d 0107 	add.w	r1, sp, #7
   2581c:	2000      	movs	r0, #0
   2581e:	e7d3      	b.n	257c8 <z_arm_fault+0x11c>
	PR_FAULT_INFO(
   25820:	2301      	movs	r3, #1
   25822:	f04f 0000 	mov.w	r0, #0
   25826:	4a14      	ldr	r2, [pc, #80]	; (25878 <z_arm_fault+0x1cc>)
   25828:	f363 0007 	bfi	r0, r3, #0, #8
   2582c:	4b13      	ldr	r3, [pc, #76]	; (2587c <z_arm_fault+0x1d0>)
   2582e:	491f      	ldr	r1, [pc, #124]	; (258ac <z_arm_fault+0x200>)
   25830:	1a9b      	subs	r3, r3, r2
   25832:	08db      	lsrs	r3, r3, #3
   25834:	f363 108f 	bfi	r0, r3, #6, #10
   25838:	e7a6      	b.n	25788 <z_arm_fault+0xdc>
	PR_FAULT_INFO("***** %s %d) *****",
   2583a:	2301      	movs	r3, #1
   2583c:	f04f 0000 	mov.w	r0, #0
   25840:	4a0d      	ldr	r2, [pc, #52]	; (25878 <z_arm_fault+0x1cc>)
   25842:	f363 0007 	bfi	r0, r3, #0, #8
   25846:	4b0d      	ldr	r3, [pc, #52]	; (2587c <z_arm_fault+0x1d0>)
   25848:	4919      	ldr	r1, [pc, #100]	; (258b0 <z_arm_fault+0x204>)
   2584a:	1a9b      	subs	r3, r3, r2
   2584c:	08db      	lsrs	r3, r3, #3
   2584e:	f418 7ff8 	tst.w	r8, #496	; 0x1f0
   25852:	f363 108f 	bfi	r0, r3, #6, #10
   25856:	4a17      	ldr	r2, [pc, #92]	; (258b4 <z_arm_fault+0x208>)
   25858:	f1a7 0310 	sub.w	r3, r7, #16
   2585c:	bf08      	it	eq
   2585e:	460a      	moveq	r2, r1
   25860:	4915      	ldr	r1, [pc, #84]	; (258b8 <z_arm_fault+0x20c>)
   25862:	f012 fa84 	bl	37d6e <log_string_sync>
   25866:	e791      	b.n	2578c <z_arm_fault+0xe0>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   25868:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   2586c:	f023 0301 	bic.w	r3, r3, #1
   25870:	e7c6      	b.n	25800 <z_arm_fault+0x154>
   25872:	bf00      	nop
   25874:	e000ed00 	.word	0xe000ed00
   25878:	0003ade0 	.word	0x0003ade0
   2587c:	0003aeb0 	.word	0x0003aeb0
   25880:	0003d654 	.word	0x0003d654
   25884:	0003d4bb 	.word	0x0003d4bb
   25888:	0003d677 	.word	0x0003d677
   2588c:	0003baac 	.word	0x0003baac
   25890:	0003d68a 	.word	0x0003d68a
   25894:	0003d6c8 	.word	0x0003d6c8
   25898:	0003d6df 	.word	0x0003d6df
   2589c:	0003d700 	.word	0x0003d700
   258a0:	e000ed28 	.word	0xe000ed28
   258a4:	e000ed29 	.word	0xe000ed29
   258a8:	e000ed2a 	.word	0xe000ed2a
   258ac:	0003d71f 	.word	0x0003d71f
   258b0:	0003d626 	.word	0x0003d626
   258b4:	0003d63b 	.word	0x0003d63b
   258b8:	0003d755 	.word	0x0003d755

000258bc <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   258bc:	4b04      	ldr	r3, [pc, #16]	; (258d0 <z_arm_fault_init+0x14>)
   258be:	695a      	ldr	r2, [r3, #20]
   258c0:	f042 0210 	orr.w	r2, r2, #16
   258c4:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
   258c6:	695a      	ldr	r2, [r3, #20]
   258c8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   258cc:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
   258ce:	4770      	bx	lr
   258d0:	e000ed00 	.word	0xe000ed00

000258d4 <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
   258d4:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   258d8:	4905      	ldr	r1, [pc, #20]	; (258f0 <sys_arch_reboot+0x1c>)
   258da:	4b06      	ldr	r3, [pc, #24]	; (258f4 <sys_arch_reboot+0x20>)
   258dc:	68ca      	ldr	r2, [r1, #12]
   258de:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   258e2:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   258e4:	60cb      	str	r3, [r1, #12]
   258e6:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   258ea:	bf00      	nop
   258ec:	e7fd      	b.n	258ea <sys_arch_reboot+0x16>
   258ee:	bf00      	nop
   258f0:	e000ed00 	.word	0xe000ed00
   258f4:	05fa0004 	.word	0x05fa0004

000258f8 <z_arm_int_lib_init>:
 * @return N/A
 */

void z_arm_int_lib_init(void)
{
	int irq = 0;
   258f8:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   258fa:	2120      	movs	r1, #32
   258fc:	4803      	ldr	r0, [pc, #12]	; (2590c <z_arm_int_lib_init+0x14>)
   258fe:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   25900:	3301      	adds	r3, #1
   25902:	2b41      	cmp	r3, #65	; 0x41
   25904:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   25908:	d1f9      	bne.n	258fe <z_arm_int_lib_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   2590a:	4770      	bx	lr
   2590c:	e000e100 	.word	0xe000e100

00025910 <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
   25910:	b538      	push	{r3, r4, r5, lr}
   25912:	4604      	mov	r4, r0
	__asm__ volatile(
   25914:	f04f 0320 	mov.w	r3, #32
   25918:	f3ef 8511 	mrs	r5, BASEPRI
   2591c:	f383 8811 	msr	BASEPRI, r3
   25920:	f3bf 8f6f 	isb	sy
	unsigned int key;

	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
   25924:	7b03      	ldrb	r3, [r0, #12]
   25926:	07db      	lsls	r3, r3, #31
   25928:	d50c      	bpl.n	25944 <z_impl_k_thread_abort+0x34>
   2592a:	4912      	ldr	r1, [pc, #72]	; (25974 <z_impl_k_thread_abort+0x64>)
   2592c:	2324      	movs	r3, #36	; 0x24
   2592e:	4a12      	ldr	r2, [pc, #72]	; (25978 <z_impl_k_thread_abort+0x68>)
   25930:	4812      	ldr	r0, [pc, #72]	; (2597c <z_impl_k_thread_abort+0x6c>)
   25932:	f012 f9c5 	bl	37cc0 <printk>
   25936:	4812      	ldr	r0, [pc, #72]	; (25980 <z_impl_k_thread_abort+0x70>)
   25938:	f012 f9c2 	bl	37cc0 <printk>
   2593c:	2124      	movs	r1, #36	; 0x24
   2593e:	480e      	ldr	r0, [pc, #56]	; (25978 <z_impl_k_thread_abort+0x68>)
   25940:	f012 fa04 	bl	37d4c <assert_post_action>
		 "essential thread aborted");

	z_thread_single_abort(thread);
   25944:	4620      	mov	r0, r4
   25946:	f00e fa03 	bl	33d50 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
   2594a:	4b0e      	ldr	r3, [pc, #56]	; (25984 <z_impl_k_thread_abort+0x74>)
   2594c:	689b      	ldr	r3, [r3, #8]
   2594e:	42a3      	cmp	r3, r4
   25950:	d10b      	bne.n	2596a <z_impl_k_thread_abort+0x5a>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
   25952:	4b0d      	ldr	r3, [pc, #52]	; (25988 <z_impl_k_thread_abort+0x78>)
   25954:	685a      	ldr	r2, [r3, #4]
   25956:	f3c2 0208 	ubfx	r2, r2, #0, #9
   2595a:	b912      	cbnz	r2, 25962 <z_impl_k_thread_abort+0x52>
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
   2595c:	4628      	mov	r0, r5
   2595e:	f7ff fb1d 	bl	24f9c <arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   25962:	685a      	ldr	r2, [r3, #4]
   25964:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   25968:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
   2596a:	4628      	mov	r0, r5
}
   2596c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
   25970:	f014 b887 	b.w	39a82 <z_reschedule_irqlock>
   25974:	0003d7a9 	.word	0x0003d7a9
   25978:	0003d768 	.word	0x0003d768
   2597c:	0003baac 	.word	0x0003baac
   25980:	0003d7d7 	.word	0x0003d7d7
   25984:	20022108 	.word	0x20022108
   25988:	e000ed00 	.word	0xe000ed00

0002598c <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
   2598c:	b510      	push	{r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
   2598e:	4b0e      	ldr	r3, [pc, #56]	; (259c8 <z_arm_configure_static_mpu_regions+0x3c>)
{
   25990:	b088      	sub	sp, #32
		const struct k_mem_partition ramfunc_region =
   25992:	9302      	str	r3, [sp, #8]
   25994:	4b0d      	ldr	r3, [pc, #52]	; (259cc <z_arm_configure_static_mpu_regions+0x40>)
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   25996:	4c0e      	ldr	r4, [pc, #56]	; (259d0 <z_arm_configure_static_mpu_regions+0x44>)
		const struct k_mem_partition ramfunc_region =
   25998:	9303      	str	r3, [sp, #12]
   2599a:	4b0e      	ldr	r3, [pc, #56]	; (259d4 <z_arm_configure_static_mpu_regions+0x48>)
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   2599c:	4a0e      	ldr	r2, [pc, #56]	; (259d8 <z_arm_configure_static_mpu_regions+0x4c>)
		const struct k_mem_partition ramfunc_region =
   2599e:	9304      	str	r3, [sp, #16]
	const struct k_mem_partition *static_regions[] = {
   259a0:	ab02      	add	r3, sp, #8
   259a2:	9301      	str	r3, [sp, #4]
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   259a4:	a801      	add	r0, sp, #4
   259a6:	4623      	mov	r3, r4
   259a8:	2101      	movs	r1, #1
   259aa:	f000 f97d 	bl	25ca8 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of k_mem_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct k_mem_partition dyn_region_areas[] = {
   259ae:	2300      	movs	r3, #0
   259b0:	9307      	str	r3, [sp, #28]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
   259b2:	4b0a      	ldr	r3, [pc, #40]	; (259dc <z_arm_configure_static_mpu_regions+0x50>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   259b4:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
   259b6:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   259b8:	a805      	add	r0, sp, #20
	const struct k_mem_partition dyn_region_areas[] = {
   259ba:	9305      	str	r3, [sp, #20]
   259bc:	9406      	str	r4, [sp, #24]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   259be:	f000 f997 	bl	25cf0 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
   259c2:	b008      	add	sp, #32
   259c4:	bd10      	pop	{r4, pc}
   259c6:	bf00      	nop
   259c8:	20020000 	.word	0x20020000
   259cc:	00000000 	.word	0x00000000
   259d0:	20040000 	.word	0x20040000
   259d4:	00010006 	.word	0x00010006
   259d8:	20020000 	.word	0x20020000
   259dc:	20020000 	.word	0x20020000

000259e0 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
   259e0:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
   259e2:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
   259e4:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
   259e6:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
   259ea:	f004 031f 	and.w	r3, r4, #31
   259ee:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   259f0:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   259f2:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   259f4:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
   259f8:	4904      	ldr	r1, [pc, #16]	; (25a0c <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   259fa:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
   259fe:	f043 0301 	orr.w	r3, r3, #1
   25a02:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
   25a04:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
   25a06:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
   25a08:	bd10      	pop	{r4, pc}
   25a0a:	bf00      	nop
   25a0c:	e000ed90 	.word	0xe000ed90

00025a10 <region_allocate_and_init>:

static int region_allocate_and_init(const u8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1)) {
   25a10:	280f      	cmp	r0, #15
{
   25a12:	b510      	push	{r4, lr}
   25a14:	4604      	mov	r4, r0
	if (index > (get_num_regions() - 1)) {
   25a16:	d912      	bls.n	25a3e <region_allocate_and_init+0x2e>

		/* No available MPU region index. */
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
   25a18:	2301      	movs	r3, #1
   25a1a:	f04f 0000 	mov.w	r0, #0
   25a1e:	4a09      	ldr	r2, [pc, #36]	; (25a44 <region_allocate_and_init+0x34>)
   25a20:	f363 0007 	bfi	r0, r3, #0, #8
   25a24:	4b08      	ldr	r3, [pc, #32]	; (25a48 <region_allocate_and_init+0x38>)
   25a26:	4909      	ldr	r1, [pc, #36]	; (25a4c <region_allocate_and_init+0x3c>)
   25a28:	1a9b      	subs	r3, r3, r2
   25a2a:	08db      	lsrs	r3, r3, #3
   25a2c:	4622      	mov	r2, r4
   25a2e:	f363 108f 	bfi	r0, r3, #6, #10
   25a32:	f012 f99c 	bl	37d6e <log_string_sync>
		return -EINVAL;
   25a36:	f06f 0415 	mvn.w	r4, #21

	/* Program region */
	region_init(index, region_conf);

	return index;
}
   25a3a:	4620      	mov	r0, r4
   25a3c:	bd10      	pop	{r4, pc}
	region_init(index, region_conf);
   25a3e:	f7ff ffcf 	bl	259e0 <region_init>
	return index;
   25a42:	e7fa      	b.n	25a3a <region_allocate_and_init+0x2a>
   25a44:	0003ade0 	.word	0x0003ade0
   25a48:	0003ae98 	.word	0x0003ae98
   25a4c:	0003d9aa 	.word	0x0003d9aa

00025a50 <mpu_configure_regions_and_partition.constprop.2>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct k_mem_partition
   25a50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   25a54:	4607      	mov	r7, r0
   25a56:	4688      	mov	r8, r1
   25a58:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
   25a5a:	2600      	movs	r6, #0
	MPU->RNR = index;
   25a5c:	4d58      	ldr	r5, [pc, #352]	; (25bc0 <mpu_configure_regions_and_partition.constprop.2+0x170>)
static int mpu_configure_regions_and_partition(const struct k_mem_partition
   25a5e:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
   25a60:	4546      	cmp	r6, r8
   25a62:	da3d      	bge.n	25ae0 <mpu_configure_regions_and_partition.constprop.2+0x90>
		if (regions[i]->size == 0U) {
   25a64:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
   25a68:	f8d3 9004 	ldr.w	r9, [r3, #4]
   25a6c:	f1b9 0f00 	cmp.w	r9, #0
   25a70:	d059      	beq.n	25b26 <mpu_configure_regions_and_partition.constprop.2+0xd6>
		&&
   25a72:	f1b9 0f1f 	cmp.w	r9, #31
   25a76:	d922      	bls.n	25abe <mpu_configure_regions_and_partition.constprop.2+0x6e>
		&&
   25a78:	f019 0f1f 	tst.w	r9, #31
   25a7c:	d11f      	bne.n	25abe <mpu_configure_regions_and_partition.constprop.2+0x6e>
		((part->start &
   25a7e:	f8d3 a000 	ldr.w	sl, [r3]
		&&
   25a82:	f01a 0f1f 	tst.w	sl, #31
   25a86:	d11a      	bne.n	25abe <mpu_configure_regions_and_partition.constprop.2+0x6e>
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
   25a88:	4650      	mov	r0, sl
   25a8a:	f012 faee 	bl	3806a <arm_cmse_mpu_region_get>
   25a8e:	4683      	mov	fp, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   25a90:	eb09 000a 	add.w	r0, r9, sl
   25a94:	3801      	subs	r0, #1
   25a96:	f012 fae8 	bl	3806a <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   25a9a:	4583      	cmp	fp, r0
   25a9c:	d024      	beq.n	25ae8 <mpu_configure_regions_and_partition.constprop.2+0x98>
	return -EINVAL;
   25a9e:	f06f 0b15 	mvn.w	fp, #21
		int u_reg_index =
			get_region_index(regions[i]->start, regions[i]->size);

		if ((u_reg_index == -EINVAL) ||
			(u_reg_index > (reg_index - 1))) {
			LOG_ERR("Invalid underlying region index %u",
   25aa2:	2301      	movs	r3, #1
   25aa4:	f04f 0000 	mov.w	r0, #0
   25aa8:	4a46      	ldr	r2, [pc, #280]	; (25bc4 <mpu_configure_regions_and_partition.constprop.2+0x174>)
   25aaa:	f363 0007 	bfi	r0, r3, #0, #8
   25aae:	4b46      	ldr	r3, [pc, #280]	; (25bc8 <mpu_configure_regions_and_partition.constprop.2+0x178>)
   25ab0:	4946      	ldr	r1, [pc, #280]	; (25bcc <mpu_configure_regions_and_partition.constprop.2+0x17c>)
   25ab2:	1a9b      	subs	r3, r3, r2
   25ab4:	08db      	lsrs	r3, r3, #3
   25ab6:	f363 108f 	bfi	r0, r3, #6, #10
   25aba:	465a      	mov	r2, fp
   25abc:	e00c      	b.n	25ad8 <mpu_configure_regions_and_partition.constprop.2+0x88>
			LOG_ERR("Partition %u: sanity check failed.", i);
   25abe:	2301      	movs	r3, #1
   25ac0:	f04f 0000 	mov.w	r0, #0
   25ac4:	4a3f      	ldr	r2, [pc, #252]	; (25bc4 <mpu_configure_regions_and_partition.constprop.2+0x174>)
   25ac6:	f363 0007 	bfi	r0, r3, #0, #8
   25aca:	4b3f      	ldr	r3, [pc, #252]	; (25bc8 <mpu_configure_regions_and_partition.constprop.2+0x178>)
   25acc:	4940      	ldr	r1, [pc, #256]	; (25bd0 <mpu_configure_regions_and_partition.constprop.2+0x180>)
   25ace:	1a9b      	subs	r3, r3, r2
   25ad0:	4632      	mov	r2, r6
   25ad2:	08db      	lsrs	r3, r3, #3
   25ad4:	f363 108f 	bfi	r0, r3, #6, #10
			LOG_ERR("Invalid underlying region index %u",
   25ad8:	f012 f949 	bl	37d6e <log_string_sync>

			reg_index =
				mpu_configure_region(reg_index, regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
   25adc:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
   25ae0:	4620      	mov	r0, r4
   25ae2:	b005      	add	sp, #20
   25ae4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((u_reg_index == -EINVAL) ||
   25ae8:	f11b 0f16 	cmn.w	fp, #22
   25aec:	d0d9      	beq.n	25aa2 <mpu_configure_regions_and_partition.constprop.2+0x52>
			(u_reg_index > (reg_index - 1))) {
   25aee:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
   25af0:	455b      	cmp	r3, fp
   25af2:	dbd6      	blt.n	25aa2 <mpu_configure_regions_and_partition.constprop.2+0x52>
	MPU->RNR = index;
   25af4:	f8c5 b008 	str.w	fp, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   25af8:	68e8      	ldr	r0, [r5, #12]
	MPU->RNR = index;
   25afa:	f8c5 b008 	str.w	fp, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   25afe:	692b      	ldr	r3, [r5, #16]
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
   25b00:	f857 1026 	ldr.w	r1, [r7, r6, lsl #2]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   25b04:	f020 001f 	bic.w	r0, r0, #31
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   25b08:	f043 0a1f 	orr.w	sl, r3, #31
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
   25b0c:	e9d1 3200 	ldrd	r3, r2, [r1]
   25b10:	441a      	add	r2, r3
		if ((regions[i]->start == u_reg_base) &&
   25b12:	4298      	cmp	r0, r3
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
   25b14:	f102 39ff 	add.w	r9, r2, #4294967295
		if ((regions[i]->start == u_reg_base) &&
   25b18:	d118      	bne.n	25b4c <mpu_configure_regions_and_partition.constprop.2+0xfc>
   25b1a:	45ca      	cmp	sl, r9
   25b1c:	d105      	bne.n	25b2a <mpu_configure_regions_and_partition.constprop.2+0xda>
			mpu_configure_region(u_reg_index, regions[i]);
   25b1e:	fa5f f08b 	uxtb.w	r0, fp
   25b22:	f012 fa87 	bl	38034 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
   25b26:	3601      	adds	r6, #1
   25b28:	e79a      	b.n	25a60 <mpu_configure_regions_and_partition.constprop.2+0x10>
	MPU->RNR = index;
   25b2a:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   25b2e:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
   25b30:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   25b34:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
   25b38:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   25b3a:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, regions[i]);
   25b3c:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, regions[i]);
   25b3e:	f012 fa79 	bl	38034 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   25b42:	f110 0f16 	cmn.w	r0, #22
   25b46:	d0c9      	beq.n	25adc <mpu_configure_regions_and_partition.constprop.2+0x8c>
			reg_index++;
   25b48:	1c44      	adds	r4, r0, #1
   25b4a:	e7ec      	b.n	25b26 <mpu_configure_regions_and_partition.constprop.2+0xd6>
	MPU->RNR = index;
   25b4c:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   25b50:	692a      	ldr	r2, [r5, #16]
   25b52:	3b01      	subs	r3, #1
   25b54:	f023 031f 	bic.w	r3, r3, #31
   25b58:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   25b5c:	4313      	orrs	r3, r2
		} else if (reg_last == u_reg_last) {
   25b5e:	45ca      	cmp	sl, r9
   25b60:	b2e0      	uxtb	r0, r4
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   25b62:	612b      	str	r3, [r5, #16]
		} else if (reg_last == u_reg_last) {
   25b64:	d0eb      	beq.n	25b3e <mpu_configure_regions_and_partition.constprop.2+0xee>
				mpu_configure_region(reg_index, regions[i]);
   25b66:	f012 fa65 	bl	38034 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   25b6a:	f110 0f16 	cmn.w	r0, #22
   25b6e:	d0b5      	beq.n	25adc <mpu_configure_regions_and_partition.constprop.2+0x8c>
	MPU->RNR = index;
   25b70:	f8c5 b008 	str.w	fp, [r5, #8]
	attr->rbar = MPU->RBAR &
   25b74:	68ea      	ldr	r2, [r5, #12]
   25b76:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i]->start +
   25b7a:	f10a 3aff 	add.w	sl, sl, #4294967295
	attr->rbar = MPU->RBAR &
   25b7e:	f362 0304 	bfi	r3, r2, #0, #5
   25b82:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   25b86:	692b      	ldr	r3, [r5, #16]
   25b88:	f89d 2008 	ldrb.w	r2, [sp, #8]
   25b8c:	085b      	lsrs	r3, r3, #1
   25b8e:	f363 1247 	bfi	r2, r3, #5, #3
			fill_region.base = regions[i]->start +
   25b92:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   25b96:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i]->start +
   25b9a:	e9d3 2300 	ldrd	r2, r3, [r3]
   25b9e:	4413      	add	r3, r2
   25ba0:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i]->start +
   25ba2:	f023 031f 	bic.w	r3, r3, #31
   25ba6:	4453      	add	r3, sl
   25ba8:	eba3 0309 	sub.w	r3, r3, r9
			reg_index++;
   25bac:	3001      	adds	r0, #1
			REGION_LIMIT_ADDR((regions[i]->start +
   25bae:	f023 031f 	bic.w	r3, r3, #31
				region_allocate_and_init(reg_index,
   25bb2:	4669      	mov	r1, sp
   25bb4:	b2c0      	uxtb	r0, r0
			fill_region.attr.r_limit =
   25bb6:	9303      	str	r3, [sp, #12]
				region_allocate_and_init(reg_index,
   25bb8:	f7ff ff2a 	bl	25a10 <region_allocate_and_init>
   25bbc:	e7c1      	b.n	25b42 <mpu_configure_regions_and_partition.constprop.2+0xf2>
   25bbe:	bf00      	nop
   25bc0:	e000ed90 	.word	0xe000ed90
   25bc4:	0003ade0 	.word	0x0003ade0
   25bc8:	0003ae98 	.word	0x0003ae98
   25bcc:	0003d987 	.word	0x0003d987
   25bd0:	0003d964 	.word	0x0003d964

00025bd4 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   25bd4:	2205      	movs	r2, #5
   25bd6:	4b03      	ldr	r3, [pc, #12]	; (25be4 <arm_core_mpu_enable+0x10>)
   25bd8:	605a      	str	r2, [r3, #4]
   25bda:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   25bde:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   25be2:	4770      	bx	lr
   25be4:	e000ed90 	.word	0xe000ed90

00025be8 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
   25be8:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   25bec:	2200      	movs	r2, #0
   25bee:	4b01      	ldr	r3, [pc, #4]	; (25bf4 <arm_core_mpu_disable+0xc>)
   25bf0:	605a      	str	r2, [r3, #4]
}
   25bf2:	4770      	bx	lr
   25bf4:	e000ed90 	.word	0xe000ed90

00025bf8 <arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
static int arm_mpu_init(struct device *arg)
{
   25bf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   25bfa:	4f21      	ldr	r7, [pc, #132]	; (25c80 <arm_mpu_init+0x88>)
   25bfc:	683e      	ldr	r6, [r7, #0]
   25bfe:	2e10      	cmp	r6, #16
   25c00:	d913      	bls.n	25c2a <arm_mpu_init+0x32>
		 * what is supported by hardware. As this operation
		 * is executed during system (pre-kernel) initialization,
		 * we want to ensure we can detect an attempt to
		 * perform invalid configuration.
		 */
		__ASSERT(0,
   25c02:	f240 132d 	movw	r3, #301	; 0x12d
   25c06:	4a1f      	ldr	r2, [pc, #124]	; (25c84 <arm_mpu_init+0x8c>)
   25c08:	491f      	ldr	r1, [pc, #124]	; (25c88 <arm_mpu_init+0x90>)
   25c0a:	4820      	ldr	r0, [pc, #128]	; (25c8c <arm_mpu_init+0x94>)
   25c0c:	f012 f858 	bl	37cc0 <printk>
   25c10:	2210      	movs	r2, #16
   25c12:	4631      	mov	r1, r6
   25c14:	481e      	ldr	r0, [pc, #120]	; (25c90 <arm_mpu_init+0x98>)
   25c16:	f012 f853 	bl	37cc0 <printk>
   25c1a:	481a      	ldr	r0, [pc, #104]	; (25c84 <arm_mpu_init+0x8c>)
   25c1c:	f240 112d 	movw	r1, #301	; 0x12d
   25c20:	f012 f894 	bl	37d4c <assert_post_action>
			"Request to configure: %u regions (supported: %u)\n",
			mpu_config.num_regions,
			get_num_regions()
		);
		return -1;
   25c24:	f04f 30ff 	mov.w	r0, #4294967295
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		DT_NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
}
   25c28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   25c2a:	2400      	movs	r4, #0
	arm_core_mpu_disable();
   25c2c:	f7ff ffdc 	bl	25be8 <arm_core_mpu_disable>
	MPU->MAIR0 =
   25c30:	4d18      	ldr	r5, [pc, #96]	; (25c94 <arm_mpu_init+0x9c>)
   25c32:	4a19      	ldr	r2, [pc, #100]	; (25c98 <arm_mpu_init+0xa0>)
   25c34:	632a      	str	r2, [r5, #48]	; 0x30
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   25c36:	42a6      	cmp	r6, r4
   25c38:	d119      	bne.n	25c6e <arm_mpu_init+0x76>
	static_regions_num = mpu_config.num_regions;
   25c3a:	4b18      	ldr	r3, [pc, #96]	; (25c9c <arm_mpu_init+0xa4>)
   25c3c:	701e      	strb	r6, [r3, #0]
	arm_core_mpu_enable();
   25c3e:	f7ff ffc9 	bl	25bd4 <arm_core_mpu_enable>
	__ASSERT(
   25c42:	682b      	ldr	r3, [r5, #0]
   25c44:	f3c3 2307 	ubfx	r3, r3, #8, #8
   25c48:	2b10      	cmp	r3, #16
   25c4a:	d00e      	beq.n	25c6a <arm_mpu_init+0x72>
   25c4c:	4914      	ldr	r1, [pc, #80]	; (25ca0 <arm_mpu_init+0xa8>)
   25c4e:	f44f 73a7 	mov.w	r3, #334	; 0x14e
   25c52:	4a0c      	ldr	r2, [pc, #48]	; (25c84 <arm_mpu_init+0x8c>)
   25c54:	480d      	ldr	r0, [pc, #52]	; (25c8c <arm_mpu_init+0x94>)
   25c56:	f012 f833 	bl	37cc0 <printk>
   25c5a:	4812      	ldr	r0, [pc, #72]	; (25ca4 <arm_mpu_init+0xac>)
   25c5c:	f012 f830 	bl	37cc0 <printk>
   25c60:	f44f 71a7 	mov.w	r1, #334	; 0x14e
   25c64:	4807      	ldr	r0, [pc, #28]	; (25c84 <arm_mpu_init+0x8c>)
   25c66:	f012 f871 	bl	37d4c <assert_post_action>
	return 0;
   25c6a:	2000      	movs	r0, #0
   25c6c:	e7dc      	b.n	25c28 <arm_mpu_init+0x30>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
   25c6e:	6879      	ldr	r1, [r7, #4]
   25c70:	4620      	mov	r0, r4
   25c72:	eb01 1104 	add.w	r1, r1, r4, lsl #4
   25c76:	f7ff feb3 	bl	259e0 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   25c7a:	3401      	adds	r4, #1
   25c7c:	e7db      	b.n	25c36 <arm_mpu_init+0x3e>
   25c7e:	bf00      	nop
   25c80:	0003b37c 	.word	0x0003b37c
   25c84:	0003d87e 	.word	0x0003d87e
   25c88:	0003f10e 	.word	0x0003f10e
   25c8c:	0003baac 	.word	0x0003baac
   25c90:	0003d8be 	.word	0x0003d8be
   25c94:	e000ed90 	.word	0xe000ed90
   25c98:	0044ffaa 	.word	0x0044ffaa
   25c9c:	2002511b 	.word	0x2002511b
   25ca0:	0003d8f2 	.word	0x0003d8f2
   25ca4:	0003d943 	.word	0x0003d943

00025ca8 <arm_core_mpu_configure_static_mpu_regions>:
{
   25ca8:	b538      	push	{r3, r4, r5, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
   25caa:	4c0c      	ldr	r4, [pc, #48]	; (25cdc <arm_core_mpu_configure_static_mpu_regions+0x34>)
   25cac:	460d      	mov	r5, r1
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
   25cae:	7822      	ldrb	r2, [r4, #0]
   25cb0:	f7ff fece 	bl	25a50 <mpu_configure_regions_and_partition.constprop.2>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   25cb4:	7020      	strb	r0, [r4, #0]
	if (mpu_configure_static_mpu_regions(static_regions, regions_num,
   25cb6:	3016      	adds	r0, #22
   25cb8:	d10f      	bne.n	25cda <arm_core_mpu_configure_static_mpu_regions+0x32>
		__ASSERT(0, "Configuring %u static MPU regions failed\n",
   25cba:	23f3      	movs	r3, #243	; 0xf3
   25cbc:	4a08      	ldr	r2, [pc, #32]	; (25ce0 <arm_core_mpu_configure_static_mpu_regions+0x38>)
   25cbe:	4909      	ldr	r1, [pc, #36]	; (25ce4 <arm_core_mpu_configure_static_mpu_regions+0x3c>)
   25cc0:	4809      	ldr	r0, [pc, #36]	; (25ce8 <arm_core_mpu_configure_static_mpu_regions+0x40>)
   25cc2:	f011 fffd 	bl	37cc0 <printk>
   25cc6:	4629      	mov	r1, r5
   25cc8:	4808      	ldr	r0, [pc, #32]	; (25cec <arm_core_mpu_configure_static_mpu_regions+0x44>)
   25cca:	f011 fff9 	bl	37cc0 <printk>
}
   25cce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		__ASSERT(0, "Configuring %u static MPU regions failed\n",
   25cd2:	21f3      	movs	r1, #243	; 0xf3
   25cd4:	4802      	ldr	r0, [pc, #8]	; (25ce0 <arm_core_mpu_configure_static_mpu_regions+0x38>)
   25cd6:	f012 b839 	b.w	37d4c <assert_post_action>
}
   25cda:	bd38      	pop	{r3, r4, r5, pc}
   25cdc:	2002511b 	.word	0x2002511b
   25ce0:	0003d87e 	.word	0x0003d87e
   25ce4:	0003f10e 	.word	0x0003f10e
   25ce8:	0003baac 	.word	0x0003baac
   25cec:	0003d823 	.word	0x0003d823

00025cf0 <arm_core_mpu_mark_areas_for_dynamic_regions>:
{
   25cf0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   25cf4:	4c2e      	ldr	r4, [pc, #184]	; (25db0 <arm_core_mpu_mark_areas_for_dynamic_regions+0xc0>)
   25cf6:	4689      	mov	r9, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
   25cf8:	4680      	mov	r8, r0
   25cfa:	2700      	movs	r7, #0
   25cfc:	46a2      	mov	sl, r4
	attr->rbar = MPU->RBAR &
   25cfe:	f04f 0b14 	mov.w	fp, #20
	MPU->RNR = index;
   25d02:	4d2c      	ldr	r5, [pc, #176]	; (25db4 <arm_core_mpu_mark_areas_for_dynamic_regions+0xc4>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
   25d04:	454f      	cmp	r7, r9
   25d06:	db02      	blt.n	25d0e <arm_core_mpu_mark_areas_for_dynamic_regions+0x1e>
}
   25d08:	b003      	add	sp, #12
   25d0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (dyn_region_areas[i].size == 0U) {
   25d0e:	f8d8 3004 	ldr.w	r3, [r8, #4]
   25d12:	9301      	str	r3, [sp, #4]
   25d14:	2b00      	cmp	r3, #0
   25d16:	d046      	beq.n	25da6 <arm_core_mpu_mark_areas_for_dynamic_regions+0xb6>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
   25d18:	f8d8 1000 	ldr.w	r1, [r8]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
   25d1c:	4608      	mov	r0, r1
   25d1e:	9100      	str	r1, [sp, #0]
   25d20:	f012 f9a3 	bl	3806a <arm_cmse_mpu_region_get>
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   25d24:	e9dd 1300 	ldrd	r1, r3, [sp]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
   25d28:	4606      	mov	r6, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   25d2a:	1858      	adds	r0, r3, r1
   25d2c:	3801      	subs	r0, #1
   25d2e:	f012 f99c 	bl	3806a <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   25d32:	4286      	cmp	r6, r0
   25d34:	4a20      	ldr	r2, [pc, #128]	; (25db8 <arm_core_mpu_mark_areas_for_dynamic_regions+0xc8>)
   25d36:	d018      	beq.n	25d6a <arm_core_mpu_mark_areas_for_dynamic_regions+0x7a>
		dyn_reg_info[i].index =
   25d38:	2314      	movs	r3, #20
   25d3a:	435f      	muls	r7, r3
   25d3c:	f06f 0315 	mvn.w	r3, #21
   25d40:	f84a 3007 	str.w	r3, [sl, r7]
		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
   25d44:	f240 1303 	movw	r3, #259	; 0x103
   25d48:	4a1c      	ldr	r2, [pc, #112]	; (25dbc <arm_core_mpu_mark_areas_for_dynamic_regions+0xcc>)
   25d4a:	491d      	ldr	r1, [pc, #116]	; (25dc0 <arm_core_mpu_mark_areas_for_dynamic_regions+0xd0>)
   25d4c:	481d      	ldr	r0, [pc, #116]	; (25dc4 <arm_core_mpu_mark_areas_for_dynamic_regions+0xd4>)
   25d4e:	f011 ffb7 	bl	37cc0 <printk>
   25d52:	4649      	mov	r1, r9
   25d54:	481c      	ldr	r0, [pc, #112]	; (25dc8 <arm_core_mpu_mark_areas_for_dynamic_regions+0xd8>)
   25d56:	f011 ffb3 	bl	37cc0 <printk>
   25d5a:	f240 1103 	movw	r1, #259	; 0x103
   25d5e:	4817      	ldr	r0, [pc, #92]	; (25dbc <arm_core_mpu_mark_areas_for_dynamic_regions+0xcc>)
}
   25d60:	b003      	add	sp, #12
   25d62:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
   25d66:	f011 bff1 	b.w	37d4c <assert_post_action>
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
   25d6a:	f116 0f16 	cmn.w	r6, #22
		dyn_reg_info[i].index =
   25d6e:	6026      	str	r6, [r4, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
   25d70:	d0e8      	beq.n	25d44 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
   25d72:	7813      	ldrb	r3, [r2, #0]
   25d74:	42b3      	cmp	r3, r6
   25d76:	dde5      	ble.n	25d44 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
	attr->rbar = MPU->RBAR &
   25d78:	fb0b a307 	mla	r3, fp, r7, sl
	MPU->RNR = index;
   25d7c:	60ae      	str	r6, [r5, #8]
	MPU->RNR = index;
   25d7e:	60ae      	str	r6, [r5, #8]
	attr->rbar = MPU->RBAR &
   25d80:	68e8      	ldr	r0, [r5, #12]
   25d82:	7b19      	ldrb	r1, [r3, #12]
   25d84:	f360 0104 	bfi	r1, r0, #0, #5
   25d88:	7319      	strb	r1, [r3, #12]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   25d8a:	6929      	ldr	r1, [r5, #16]
   25d8c:	7b18      	ldrb	r0, [r3, #12]
   25d8e:	0849      	lsrs	r1, r1, #1
   25d90:	f361 1047 	bfi	r0, r1, #5, #3
   25d94:	7318      	strb	r0, [r3, #12]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
   25d96:	68eb      	ldr	r3, [r5, #12]
   25d98:	f023 031f 	bic.w	r3, r3, #31
   25d9c:	6063      	str	r3, [r4, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
   25d9e:	692b      	ldr	r3, [r5, #16]
   25da0:	f023 031f 	bic.w	r3, r3, #31
   25da4:	6123      	str	r3, [r4, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
   25da6:	3701      	adds	r7, #1
   25da8:	3414      	adds	r4, #20
   25daa:	f108 080c 	add.w	r8, r8, #12
   25dae:	e7a9      	b.n	25d04 <arm_core_mpu_mark_areas_for_dynamic_regions+0x14>
   25db0:	2002058c 	.word	0x2002058c
   25db4:	e000ed90 	.word	0xe000ed90
   25db8:	2002511b 	.word	0x2002511b
   25dbc:	0003d87e 	.word	0x0003d87e
   25dc0:	0003f10e 	.word	0x0003f10e
   25dc4:	0003baac 	.word	0x0003baac
   25dc8:	0003d84f 	.word	0x0003d84f

00025dcc <arm_core_mpu_configure_dynamic_mpu_regions>:
{
   25dcc:	b570      	push	{r4, r5, r6, lr}
 * performed, the error signal is propagated to the caller of the function.
 */
static int mpu_configure_dynamic_mpu_regions(const struct k_mem_partition
	*dynamic_regions[], u8_t regions_num)
{
	int mpu_reg_index = static_regions_num;
   25dce:	4b16      	ldr	r3, [pc, #88]	; (25e28 <arm_core_mpu_configure_dynamic_mpu_regions+0x5c>)
   25dd0:	460c      	mov	r4, r1
   25dd2:	781d      	ldrb	r5, [r3, #0]
   25dd4:	4606      	mov	r6, r0
   25dd6:	462b      	mov	r3, r5
  mpu->RLAR = 0U;
   25dd8:	2100      	movs	r1, #0
  mpu->RNR = rnr;
   25dda:	4a14      	ldr	r2, [pc, #80]	; (25e2c <arm_core_mpu_configure_dynamic_mpu_regions+0x60>)

	/* Disable all MPU regions except for the static ones. */
	for (int i = mpu_reg_index; i < get_num_regions(); i++) {
   25ddc:	2b0f      	cmp	r3, #15
   25dde:	dd1d      	ble.n	25e1c <arm_core_mpu_configure_dynamic_mpu_regions+0x50>
#if defined(CONFIG_MPU_GAP_FILLING)
	/* Reset MPU regions inside which dynamic memory regions may
	 * be programmed.
	 */
	for (int i = 0; i < MPU_DYNAMIC_REGION_AREAS_NUM; i++) {
		region_init(dyn_reg_info[i].index,
   25de0:	4913      	ldr	r1, [pc, #76]	; (25e30 <arm_core_mpu_configure_dynamic_mpu_regions+0x64>)
   25de2:	f851 0b04 	ldr.w	r0, [r1], #4
   25de6:	f7ff fdfb 	bl	259e0 <region_init>

	/* In ARMv8-M architecture the dynamic regions are programmed on SRAM,
	 * forming a full partition of the background area, specified by the
	 * given boundaries.
	 */
	mpu_reg_index = mpu_configure_regions_and_partition(dynamic_regions,
   25dea:	462a      	mov	r2, r5
   25dec:	4621      	mov	r1, r4
   25dee:	4630      	mov	r0, r6
   25df0:	f7ff fe2e 	bl	25a50 <mpu_configure_regions_and_partition.constprop.2>
	if (mpu_configure_dynamic_mpu_regions(dynamic_regions, regions_num)
   25df4:	3016      	adds	r0, #22
   25df6:	d115      	bne.n	25e24 <arm_core_mpu_configure_dynamic_mpu_regions+0x58>
		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
   25df8:	f44f 7389 	mov.w	r3, #274	; 0x112
   25dfc:	4a0d      	ldr	r2, [pc, #52]	; (25e34 <arm_core_mpu_configure_dynamic_mpu_regions+0x68>)
   25dfe:	490e      	ldr	r1, [pc, #56]	; (25e38 <arm_core_mpu_configure_dynamic_mpu_regions+0x6c>)
   25e00:	480e      	ldr	r0, [pc, #56]	; (25e3c <arm_core_mpu_configure_dynamic_mpu_regions+0x70>)
   25e02:	f011 ff5d 	bl	37cc0 <printk>
   25e06:	4621      	mov	r1, r4
   25e08:	480d      	ldr	r0, [pc, #52]	; (25e40 <arm_core_mpu_configure_dynamic_mpu_regions+0x74>)
   25e0a:	f011 ff59 	bl	37cc0 <printk>
}
   25e0e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
   25e12:	f44f 7189 	mov.w	r1, #274	; 0x112
   25e16:	4807      	ldr	r0, [pc, #28]	; (25e34 <arm_core_mpu_configure_dynamic_mpu_regions+0x68>)
   25e18:	f011 bf98 	b.w	37d4c <assert_post_action>
   25e1c:	6093      	str	r3, [r2, #8]
  mpu->RLAR = 0U;
   25e1e:	6111      	str	r1, [r2, #16]
	for (int i = mpu_reg_index; i < get_num_regions(); i++) {
   25e20:	3301      	adds	r3, #1
   25e22:	e7db      	b.n	25ddc <arm_core_mpu_configure_dynamic_mpu_regions+0x10>
}
   25e24:	bd70      	pop	{r4, r5, r6, pc}
   25e26:	bf00      	nop
   25e28:	2002511b 	.word	0x2002511b
   25e2c:	e000ed90 	.word	0xe000ed90
   25e30:	2002058c 	.word	0x2002058c
   25e34:	0003d87e 	.word	0x0003d87e
   25e38:	0003f10e 	.word	0x0003f10e
   25e3c:	0003baac 	.word	0x0003baac
   25e40:	0003d7f6 	.word	0x0003d7f6

00025e44 <z_impl_zephyr_read_stdin>:
{
	_stdin_hook = hook;
}

int z_impl_zephyr_read_stdin(char *buf, int nbytes)
{
   25e44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25e46:	4606      	mov	r6, r0
   25e48:	460d      	mov	r5, r1
	int i = 0;

	for (i = 0; i < nbytes; i++) {
   25e4a:	2400      	movs	r4, #0
		*(buf + i) = _stdin_hook();
   25e4c:	4f06      	ldr	r7, [pc, #24]	; (25e68 <z_impl_zephyr_read_stdin+0x24>)
	for (i = 0; i < nbytes; i++) {
   25e4e:	42ac      	cmp	r4, r5
   25e50:	da08      	bge.n	25e64 <z_impl_zephyr_read_stdin+0x20>
		*(buf + i) = _stdin_hook();
   25e52:	683b      	ldr	r3, [r7, #0]
   25e54:	4798      	blx	r3
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
   25e56:	280a      	cmp	r0, #10
		*(buf + i) = _stdin_hook();
   25e58:	5530      	strb	r0, [r6, r4]
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
   25e5a:	f104 0401 	add.w	r4, r4, #1
   25e5e:	d001      	beq.n	25e64 <z_impl_zephyr_read_stdin+0x20>
   25e60:	280d      	cmp	r0, #13
   25e62:	d1f4      	bne.n	25e4e <z_impl_zephyr_read_stdin+0xa>
			i++;
			break;
		}
	}
	return i;
}
   25e64:	4620      	mov	r0, r4
   25e66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   25e68:	2002af2c 	.word	0x2002af2c

00025e6c <z_impl_zephyr_write_stdout>:
}
#include <syscalls/z_zephyr_read_stdin_mrsh.c>
#endif

int z_impl_zephyr_write_stdout(const void *buffer, int nbytes)
{
   25e6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25e6e:	460e      	mov	r6, r1
   25e70:	4f09      	ldr	r7, [pc, #36]	; (25e98 <z_impl_zephyr_write_stdout+0x2c>)
   25e72:	1e44      	subs	r4, r0, #1
	const char *buf = buffer;
	int i;

	for (i = 0; i < nbytes; i++) {
   25e74:	f1c0 0501 	rsb	r5, r0, #1
   25e78:	192b      	adds	r3, r5, r4
   25e7a:	429e      	cmp	r6, r3
   25e7c:	dc01      	bgt.n	25e82 <z_impl_zephyr_write_stdout+0x16>
			_stdout_hook('\r');
		}
		_stdout_hook(*(buf + i));
	}
	return nbytes;
}
   25e7e:	4630      	mov	r0, r6
   25e80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (*(buf + i) == '\n') {
   25e82:	7863      	ldrb	r3, [r4, #1]
   25e84:	2b0a      	cmp	r3, #10
   25e86:	d102      	bne.n	25e8e <z_impl_zephyr_write_stdout+0x22>
			_stdout_hook('\r');
   25e88:	683b      	ldr	r3, [r7, #0]
   25e8a:	200d      	movs	r0, #13
   25e8c:	4798      	blx	r3
		_stdout_hook(*(buf + i));
   25e8e:	683b      	ldr	r3, [r7, #0]
   25e90:	f814 0f01 	ldrb.w	r0, [r4, #1]!
   25e94:	4798      	blx	r3
   25e96:	e7ef      	b.n	25e78 <z_impl_zephyr_write_stdout+0xc>
   25e98:	2002af30 	.word	0x2002af30

00025e9c <_exit>:
	return 0;
}
__weak FUNC_ALIAS(_fstat, fstat, int);

__weak void _exit(int status)
{
   25e9c:	b508      	push	{r3, lr}
	return z_impl_zephyr_write_stdout(buf, nbytes);
   25e9e:	2105      	movs	r1, #5
   25ea0:	4801      	ldr	r0, [pc, #4]	; (25ea8 <_exit+0xc>)
   25ea2:	f7ff ffe3 	bl	25e6c <z_impl_zephyr_write_stdout>
	_write(1, "exit\n", 5);
	while (1) {
		;
   25ea6:	e7fe      	b.n	25ea6 <_exit+0xa>
   25ea8:	0003d9d0 	.word	0x0003d9d0

00025eac <_sbrk>:
}

static LIBC_DATA SYS_SEM_DEFINE(heap_sem, 1, 1);

void *_sbrk(int count)
{
   25eac:	b538      	push	{r3, r4, r5, lr}
   25eae:	4605      	mov	r5, r0
	void *ret, *ptr;

	sys_sem_take(&heap_sem, K_FOREVER);
   25eb0:	f04f 31ff 	mov.w	r1, #4294967295
   25eb4:	480b      	ldr	r0, [pc, #44]	; (25ee4 <_sbrk+0x38>)
   25eb6:	f011 ff15 	bl	37ce4 <sys_sem_take>

#if CONFIG_NEWLIB_LIBC_ALIGNED_HEAP_SIZE
	ptr = heap_base + heap_sz;
#else
	ptr = ((char *)HEAP_BASE) + heap_sz;
   25eba:	4a0b      	ldr	r2, [pc, #44]	; (25ee8 <_sbrk+0x3c>)
#endif

	if ((heap_sz + count) < MAX_HEAP_SIZE) {
   25ebc:	490b      	ldr	r1, [pc, #44]	; (25eec <_sbrk+0x40>)
	ptr = ((char *)HEAP_BASE) + heap_sz;
   25ebe:	6814      	ldr	r4, [r2, #0]
	if ((heap_sz + count) < MAX_HEAP_SIZE) {
   25ec0:	f1c1 5300 	rsb	r3, r1, #536870912	; 0x20000000
   25ec4:	4425      	add	r5, r4
   25ec6:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   25eca:	429d      	cmp	r5, r3
		heap_sz += count;
		ret = ptr;
	} else {
		ret = (void *)-1;
   25ecc:	bf2c      	ite	cs
   25ece:	f04f 34ff 	movcs.w	r4, #4294967295
	ptr = ((char *)HEAP_BASE) + heap_sz;
   25ed2:	1864      	addcc	r4, r4, r1
	}

	sys_sem_give(&heap_sem);
   25ed4:	4803      	ldr	r0, [pc, #12]	; (25ee4 <_sbrk+0x38>)
		heap_sz += count;
   25ed6:	bf38      	it	cc
   25ed8:	6015      	strcc	r5, [r2, #0]
	sys_sem_give(&heap_sem);
   25eda:	f011 fefe 	bl	37cda <sys_sem_give>

	return ret;
}
   25ede:	4620      	mov	r0, r4
   25ee0:	bd38      	pop	{r3, r4, r5, pc}
   25ee2:	bf00      	nop
   25ee4:	2002cc00 	.word	0x2002cc00
   25ee8:	200205a0 	.word	0x200205a0
   25eec:	2002ccfc 	.word	0x2002ccfc

00025ef0 <net_if_flag_is_set>:
 *
 * @return True if the value is set, false otherwise
 */
static inline bool net_if_flag_is_set(struct net_if *iface,
				      enum net_if_flag value)
{
   25ef0:	b538      	push	{r3, r4, r5, lr}
   25ef2:	460d      	mov	r5, r1
	NET_ASSERT(iface);
   25ef4:	4604      	mov	r4, r0
   25ef6:	b970      	cbnz	r0, 25f16 <net_if_flag_is_set+0x26>
   25ef8:	490b      	ldr	r1, [pc, #44]	; (25f28 <net_if_flag_is_set+0x38>)
   25efa:	f240 2311 	movw	r3, #529	; 0x211
   25efe:	4a0b      	ldr	r2, [pc, #44]	; (25f2c <net_if_flag_is_set+0x3c>)
   25f00:	480b      	ldr	r0, [pc, #44]	; (25f30 <net_if_flag_is_set+0x40>)
   25f02:	f011 fedd 	bl	37cc0 <printk>
   25f06:	480b      	ldr	r0, [pc, #44]	; (25f34 <net_if_flag_is_set+0x44>)
   25f08:	f011 feda 	bl	37cc0 <printk>
   25f0c:	f240 2111 	movw	r1, #529	; 0x211
   25f10:	4806      	ldr	r0, [pc, #24]	; (25f2c <net_if_flag_is_set+0x3c>)
   25f12:	f011 ff1b 	bl	37d4c <assert_post_action>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   25f16:	6823      	ldr	r3, [r4, #0]
   25f18:	330c      	adds	r3, #12
   25f1a:	e8d3 0faf 	lda	r0, [r3]
 */
static inline bool atomic_test_bit(const atomic_t *target, int bit)
{
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));

	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   25f1e:	4128      	asrs	r0, r5

	return atomic_test_bit(iface->if_dev->flags, value);
}
   25f20:	f000 0001 	and.w	r0, r0, #1
   25f24:	bd38      	pop	{r3, r4, r5, pc}
   25f26:	bf00      	nop
   25f28:	0003da15 	.word	0x0003da15
   25f2c:	0003d9ed 	.word	0x0003d9ed
   25f30:	0003baac 	.word	0x0003baac
   25f34:	0003da1b 	.word	0x0003da1b

00025f38 <net_if_flag_set.constprop.24>:
static inline void net_if_flag_set(struct net_if *iface,
   25f38:	b510      	push	{r4, lr}
	NET_ASSERT(iface);
   25f3a:	4604      	mov	r4, r0
   25f3c:	b970      	cbnz	r0, 25f5c <net_if_flag_set.constprop.24+0x24>
   25f3e:	490d      	ldr	r1, [pc, #52]	; (25f74 <net_if_flag_set.constprop.24+0x3c>)
   25f40:	f240 13e3 	movw	r3, #483	; 0x1e3
   25f44:	4a0c      	ldr	r2, [pc, #48]	; (25f78 <net_if_flag_set.constprop.24+0x40>)
   25f46:	480d      	ldr	r0, [pc, #52]	; (25f7c <net_if_flag_set.constprop.24+0x44>)
   25f48:	f011 feba 	bl	37cc0 <printk>
   25f4c:	480c      	ldr	r0, [pc, #48]	; (25f80 <net_if_flag_set.constprop.24+0x48>)
   25f4e:	f011 feb7 	bl	37cc0 <printk>
   25f52:	f240 11e3 	movw	r1, #483	; 0x1e3
   25f56:	4808      	ldr	r0, [pc, #32]	; (25f78 <net_if_flag_set.constprop.24+0x40>)
   25f58:	f011 fef8 	bl	37d4c <assert_post_action>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   25f5c:	6823      	ldr	r3, [r4, #0]
   25f5e:	330c      	adds	r3, #12
   25f60:	e8d3 2fef 	ldaex	r2, [r3]
   25f64:	f042 0201 	orr.w	r2, r2, #1
   25f68:	e8c3 2fe1 	stlex	r1, r2, [r3]
   25f6c:	2900      	cmp	r1, #0
   25f6e:	d1f7      	bne.n	25f60 <net_if_flag_set.constprop.24+0x28>
}
   25f70:	bd10      	pop	{r4, pc}
   25f72:	bf00      	nop
   25f74:	0003da15 	.word	0x0003da15
   25f78:	0003d9ed 	.word	0x0003d9ed
   25f7c:	0003baac 	.word	0x0003baac
   25f80:	0003da1b 	.word	0x0003da1b

00025f84 <net_if_up>:
		cb(iface, user_data);
	}
}

int net_if_up(struct net_if *iface)
{
   25f84:	b538      	push	{r3, r4, r5, lr}
	int status;

	NET_DBG("iface %p", iface);

	if (net_if_flag_is_set(iface, NET_IF_UP)) {
   25f86:	2100      	movs	r1, #0
{
   25f88:	4605      	mov	r5, r0
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
   25f8a:	f7ff ffb1 	bl	25ef0 <net_if_flag_is_set>
   25f8e:	b928      	cbnz	r0, 25f9c <net_if_up+0x18>
 * @return True if socket offloading is active, false otherwise.
 */
static inline bool net_if_is_socket_offloaded(struct net_if *iface)
{
#if defined(CONFIG_NET_SOCKETS_OFFLOAD)
	return iface->if_dev->offloaded;
   25f90:	682b      	ldr	r3, [r5, #0]

	if ((IS_ENABLED(CONFIG_NET_OFFLOAD) &&
	     net_if_is_ip_offloaded(iface)) ||
	    (IS_ENABLED(CONFIG_NET_SOCKETS_OFFLOAD) &&
	     net_if_is_socket_offloaded(iface))) {
		net_if_flag_set(iface, NET_IF_UP);
   25f92:	4628      	mov	r0, r5
	if ((IS_ENABLED(CONFIG_NET_OFFLOAD) &&
   25f94:	7e9b      	ldrb	r3, [r3, #26]
   25f96:	b11b      	cbz	r3, 25fa0 <net_if_up+0x1c>
		net_if_flag_set(iface, NET_IF_UP);
   25f98:	f7ff ffce 	bl	25f38 <net_if_flag_set.constprop.24>
		return 0;
   25f9c:	2000      	movs	r0, #0
   25f9e:	e023      	b.n	25fe8 <net_if_up+0x64>
		goto exit;
	}

	/* If the L2 does not support enable just set the flag */
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
   25fa0:	f012 f892 	bl	380c8 <net_if_l2>
   25fa4:	b9c0      	cbnz	r0, 25fd8 <net_if_up+0x54>

done:
	/* In many places it's assumed that link address was set with
	 * net_if_set_link_addr(). Better check that now.
	 */
	NET_ASSERT(net_if_get_link_addr(iface)->addr != NULL);
   25fa6:	682b      	ldr	r3, [r5, #0]
   25fa8:	691b      	ldr	r3, [r3, #16]
   25faa:	b973      	cbnz	r3, 25fca <net_if_up+0x46>
   25fac:	490f      	ldr	r1, [pc, #60]	; (25fec <net_if_up+0x68>)
   25fae:	f640 538f 	movw	r3, #3471	; 0xd8f
   25fb2:	4a0f      	ldr	r2, [pc, #60]	; (25ff0 <net_if_up+0x6c>)
   25fb4:	480f      	ldr	r0, [pc, #60]	; (25ff4 <net_if_up+0x70>)
   25fb6:	f011 fe83 	bl	37cc0 <printk>
   25fba:	480f      	ldr	r0, [pc, #60]	; (25ff8 <net_if_up+0x74>)
   25fbc:	f011 fe80 	bl	37cc0 <printk>
   25fc0:	f640 518f 	movw	r1, #3471	; 0xd8f
   25fc4:	480a      	ldr	r0, [pc, #40]	; (25ff0 <net_if_up+0x6c>)
   25fc6:	f011 fec1 	bl	37d4c <assert_post_action>

	net_if_flag_set(iface, NET_IF_UP);
   25fca:	4628      	mov	r0, r5
   25fcc:	f7ff ffb4 	bl	25f38 <net_if_flag_set.constprop.24>

	/* If the interface is only having point-to-point traffic then we do
	 * not need to run DAD etc for it.
	 */
	if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
   25fd0:	4628      	mov	r0, r5
   25fd2:	f012 f87e 	bl	380d2 <l2_flags_get>
   25fd6:	e7e1      	b.n	25f9c <net_if_up+0x18>
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
   25fd8:	6883      	ldr	r3, [r0, #8]
   25fda:	2b00      	cmp	r3, #0
   25fdc:	d0e3      	beq.n	25fa6 <net_if_up+0x22>
	status = net_if_l2(iface)->enable(iface, true);
   25fde:	2101      	movs	r1, #1
   25fe0:	4628      	mov	r0, r5
   25fe2:	4798      	blx	r3
	if (status < 0) {
   25fe4:	2800      	cmp	r0, #0
   25fe6:	dade      	bge.n	25fa6 <net_if_up+0x22>

exit:
	net_mgmt_event_notify(NET_EVENT_IF_UP, iface);

	return 0;
}
   25fe8:	bd38      	pop	{r3, r4, r5, pc}
   25fea:	bf00      	nop
   25fec:	0003da1e 	.word	0x0003da1e
   25ff0:	0003da4f 	.word	0x0003da4f
   25ff4:	0003baac 	.word	0x0003baac
   25ff8:	0003da1b 	.word	0x0003da1b

00025ffc <net_if_init>:
	k_fifo_put(&tx_ts_queue, pkt);
}
#endif /* CONFIG_NET_PKT_TIMESTAMP_THREAD */

void net_if_init(void)
{
   25ffc:	b538      	push	{r3, r4, r5, lr}

	NET_DBG("");

	net_tc_tx_init();

	for (iface = __net_if_start, if_count = 0; iface != __net_if_end;
   25ffe:	4c07      	ldr	r4, [pc, #28]	; (2601c <net_if_init+0x20>)
   26000:	4d07      	ldr	r5, [pc, #28]	; (26020 <net_if_init+0x24>)
   26002:	42ac      	cmp	r4, r5
   26004:	d100      	bne.n	26008 <net_if_init+0xc>
		NET_WARN("You have configured only %d VLAN interfaces"
			 " but you have %d network interfaces.",
			 CONFIG_NET_VLAN_COUNT, if_count);
	}
#endif
}
   26006:	bd38      	pop	{r3, r4, r5, pc}
	return iface->if_dev->dev;
   26008:	6823      	ldr	r3, [r4, #0]
	const struct net_if_api *api = net_if_get_device(iface)->driver_api;
   2600a:	681b      	ldr	r3, [r3, #0]
   2600c:	685b      	ldr	r3, [r3, #4]
	if (!api || !api->init) {
   2600e:	b11b      	cbz	r3, 26018 <net_if_init+0x1c>
   26010:	681b      	ldr	r3, [r3, #0]
   26012:	b10b      	cbz	r3, 26018 <net_if_init+0x1c>
	api->init(iface);
   26014:	4620      	mov	r0, r4
   26016:	4798      	blx	r3
	     iface++, if_count++) {
   26018:	3420      	adds	r4, #32
   2601a:	e7f2      	b.n	26002 <net_if_init+0x6>
   2601c:	2002ccc0 	.word	0x2002ccc0
   26020:	2002cce0 	.word	0x2002cce0

00026024 <net_if_post_init>:

void net_if_post_init(void)
{
   26024:	b538      	push	{r3, r4, r5, lr}
	struct net_if *iface;

	NET_DBG("");

	/* After TX is running, attempt to bring the interface up */
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   26026:	4c07      	ldr	r4, [pc, #28]	; (26044 <net_if_post_init+0x20>)
   26028:	4d07      	ldr	r5, [pc, #28]	; (26048 <net_if_post_init+0x24>)
   2602a:	42ac      	cmp	r4, r5
   2602c:	d100      	bne.n	26030 <net_if_post_init+0xc>
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
			net_if_up(iface);
		}
	}
}
   2602e:	bd38      	pop	{r3, r4, r5, pc}
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
   26030:	2103      	movs	r1, #3
   26032:	4620      	mov	r0, r4
   26034:	f7ff ff5c 	bl	25ef0 <net_if_flag_is_set>
   26038:	b910      	cbnz	r0, 26040 <net_if_post_init+0x1c>
			net_if_up(iface);
   2603a:	4620      	mov	r0, r4
   2603c:	f7ff ffa2 	bl	25f84 <net_if_up>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   26040:	3420      	adds	r4, #32
   26042:	e7f2      	b.n	2602a <net_if_post_init+0x6>
   26044:	2002ccc0 	.word	0x2002ccc0
   26048:	2002cce0 	.word	0x2002cce0

0002604c <z_impl_net_addr_ntop>:
	struct in6_addr *addr6;
	u16_t *w;
	u8_t i, bl, bh, longest = 1U;
	s8_t pos = -1;
	char delim = ':';
	unsigned char zeros[8] = { 0 };
   2604c:	2300      	movs	r3, #0
{
   2604e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char *ptr = dst;
	int len = -1;
	u16_t value;
	bool needcolon = false;

	if (family == AF_INET6) {
   26052:	2802      	cmp	r0, #2
{
   26054:	b089      	sub	sp, #36	; 0x24
   26056:	4681      	mov	r9, r0
   26058:	468a      	mov	sl, r1
   2605a:	4690      	mov	r8, r2
	unsigned char zeros[8] = { 0 };
   2605c:	e9cd 3306 	strd	r3, r3, [sp, #24]
	if (family == AF_INET6) {
   26060:	d13c      	bne.n	260dc <z_impl_net_addr_ntop+0x90>
		addr6 = (struct in6_addr *)src;
		w = (u16_t *)addr6->s6_addr16;
   26062:	aa06      	add	r2, sp, #24
   26064:	4610      	mov	r0, r2
   26066:	9104      	str	r1, [sp, #16]
{
   26068:	4619      	mov	r1, r3
   2606a:	e006      	b.n	2607a <z_impl_net_addr_ntop+0x2e>
			for (j = i; j < 8; j++) {
				if (UNALIGNED_GET(&w[j]) != 0) {
					break;
				}

				zeros[i]++;
   2606c:	7804      	ldrb	r4, [r0, #0]
   2606e:	3101      	adds	r1, #1
   26070:	3401      	adds	r4, #1
   26072:	7004      	strb	r4, [r0, #0]
			for (j = i; j < 8; j++) {
   26074:	b2cc      	uxtb	r4, r1
   26076:	2c07      	cmp	r4, #7
   26078:	d803      	bhi.n	26082 <z_impl_net_addr_ntop+0x36>
				if (UNALIGNED_GET(&w[j]) != 0) {
   2607a:	f83a 4011 	ldrh.w	r4, [sl, r1, lsl #1]
   2607e:	2c00      	cmp	r4, #0
   26080:	d0f4      	beq.n	2606c <z_impl_net_addr_ntop+0x20>
   26082:	3301      	adds	r3, #1
		for (i = 0U; i < 8; i++) {
   26084:	2b08      	cmp	r3, #8
   26086:	f100 0001 	add.w	r0, r0, #1
   2608a:	d1ed      	bne.n	26068 <z_impl_net_addr_ntop+0x1c>
	s8_t pos = -1;
   2608c:	f04f 36ff 	mov.w	r6, #4294967295
	u8_t i, bl, bh, longest = 1U;
   26090:	2701      	movs	r7, #1
			}
		}

		for (i = 0U; i < 8; i++) {
   26092:	2300      	movs	r3, #0
			if (zeros[i] > longest) {
   26094:	f812 1b01 	ldrb.w	r1, [r2], #1
   26098:	42b9      	cmp	r1, r7
				longest = zeros[i];
				pos = i;
   2609a:	bf88      	it	hi
   2609c:	b25e      	sxtbhi	r6, r3
		for (i = 0U; i < 8; i++) {
   2609e:	f103 0301 	add.w	r3, r3, #1
   260a2:	b2db      	uxtb	r3, r3
				pos = i;
   260a4:	bf88      	it	hi
   260a6:	460f      	movhi	r7, r1
		for (i = 0U; i < 8; i++) {
   260a8:	2b08      	cmp	r3, #8
   260aa:	d1f3      	bne.n	26094 <z_impl_net_addr_ntop+0x48>
		len = 8;
   260ac:	9303      	str	r3, [sp, #12]
   260ae:	2f01      	cmp	r7, #1
   260b0:	f04f 033a 	mov.w	r3, #58	; 0x3a
   260b4:	bf08      	it	eq
   260b6:	f04f 36ff 	moveq.w	r6, #4294967295
   260ba:	9302      	str	r3, [sp, #8]
	bool needcolon = false;
   260bc:	2200      	movs	r2, #0
		delim = '.';
	} else {
		return NULL;
	}

	for (i = 0U; i < len; i++) {
   260be:	4644      	mov	r4, r8
   260c0:	4615      	mov	r5, r2
   260c2:	9b03      	ldr	r3, [sp, #12]
   260c4:	429d      	cmp	r5, r3
   260c6:	db19      	blt.n	260fc <z_impl_net_addr_ntop+0xb0>
		}

		needcolon = true;
	}

	if (!(ptr - dst)) {
   260c8:	4544      	cmp	r4, r8
   260ca:	d009      	beq.n	260e0 <z_impl_net_addr_ntop+0x94>
		return NULL;
	}

	if (family == AF_INET) {
   260cc:	2300      	movs	r3, #0
   260ce:	f1b9 0f01 	cmp.w	r9, #1
		*(ptr - 1) = '\0';
   260d2:	bf0c      	ite	eq
   260d4:	f804 3c01 	strbeq.w	r3, [r4, #-1]
	} else {
		*ptr = '\0';
   260d8:	7023      	strbne	r3, [r4, #0]
   260da:	e003      	b.n	260e4 <z_impl_net_addr_ntop+0x98>
	} else if (family == AF_INET) {
   260dc:	2801      	cmp	r0, #1
   260de:	d005      	beq.n	260ec <z_impl_net_addr_ntop+0xa0>
		return NULL;
   260e0:	f04f 0800 	mov.w	r8, #0
	}

	return dst;
}
   260e4:	4640      	mov	r0, r8
   260e6:	b009      	add	sp, #36	; 0x24
   260e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		delim = '.';
   260ec:	232e      	movs	r3, #46	; 0x2e
   260ee:	2204      	movs	r2, #4
	s8_t pos = -1;
   260f0:	f04f 36ff 	mov.w	r6, #4294967295
		delim = '.';
   260f4:	e9cd 3202 	strd	r3, r2, [sp, #8]
	u8_t i, bl, bh, longest = 1U;
   260f8:	4607      	mov	r7, r0
   260fa:	e7df      	b.n	260bc <z_impl_net_addr_ntop+0x70>
		if (len == 4) {
   260fc:	9b03      	ldr	r3, [sp, #12]
   260fe:	2b04      	cmp	r3, #4
   26100:	d134      	bne.n	2616c <z_impl_net_addr_ntop+0x120>
			value = (u32_t)addr->s4_addr[i];
   26102:	f81a 1005 	ldrb.w	r1, [sl, r5]
			if (value == 0U) {
   26106:	b949      	cbnz	r1, 2611c <z_impl_net_addr_ntop+0xd0>
				*ptr++ = '0';
   26108:	2330      	movs	r3, #48	; 0x30
   2610a:	4620      	mov	r0, r4
   2610c:	f800 3b02 	strb.w	r3, [r0], #2
				*ptr++ = delim;
   26110:	9b02      	ldr	r3, [sp, #8]
   26112:	7063      	strb	r3, [r4, #1]
	for (i = 0U; i < len; i++) {
   26114:	3501      	adds	r5, #1
   26116:	b2ed      	uxtb	r5, r5
   26118:	4604      	mov	r4, r0
   2611a:	e7d2      	b.n	260c2 <z_impl_net_addr_ntop+0x76>
			l = net_value_to_udec(ptr, value, 0);
   2611c:	2009      	movs	r0, #9
   2611e:	f04f 0b00 	mov.w	fp, #0
   26122:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 261fc <z_impl_net_addr_ntop+0x1b0>
   26126:	9401      	str	r4, [sp, #4]
		temp = value / divisor;
   26128:	fbb1 fefc 	udiv	lr, r1, ip
		value = value % divisor;
   2612c:	fb0c 131e 	mls	r3, ip, lr, r1
		if ((precision > i) || (temp != 0)) {
   26130:	4583      	cmp	fp, r0
		value = value % divisor;
   26132:	9305      	str	r3, [sp, #20]
		if ((precision > i) || (temp != 0)) {
   26134:	dc01      	bgt.n	2613a <z_impl_net_addr_ntop+0xee>
   26136:	4561      	cmp	r1, ip
   26138:	d306      	bcc.n	26148 <z_impl_net_addr_ntop+0xfc>
			*buf++ = (char) (temp + '0');
   2613a:	4683      	mov	fp, r0
   2613c:	9b01      	ldr	r3, [sp, #4]
   2613e:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
   26142:	f803 eb01 	strb.w	lr, [r3], #1
   26146:	9301      	str	r3, [sp, #4]
	for (i = 9; i >= 0; i--, divisor /= 10U) {
   26148:	230a      	movs	r3, #10
   2614a:	3801      	subs	r0, #1
   2614c:	fbbc fcf3 	udiv	ip, ip, r3
   26150:	1c43      	adds	r3, r0, #1
		value = value % divisor;
   26152:	9905      	ldr	r1, [sp, #20]
	for (i = 9; i >= 0; i--, divisor /= 10U) {
   26154:	d1e8      	bne.n	26128 <z_impl_net_addr_ntop+0xdc>
	*buf = 0;
   26156:	f04f 0300 	mov.w	r3, #0
   2615a:	9901      	ldr	r1, [sp, #4]
   2615c:	700b      	strb	r3, [r1, #0]
	return buf - start;
   2615e:	1b0b      	subs	r3, r1, r4
			ptr += l;
   26160:	b2db      	uxtb	r3, r3
			*ptr++ = delim;
   26162:	9902      	ldr	r1, [sp, #8]
			ptr += l;
   26164:	18e0      	adds	r0, r4, r3
			*ptr++ = delim;
   26166:	3001      	adds	r0, #1
   26168:	54e1      	strb	r1, [r4, r3]
			continue;
   2616a:	e7d3      	b.n	26114 <z_impl_net_addr_ntop+0xc8>
		if (i == pos) {
   2616c:	42ae      	cmp	r6, r5
   2616e:	d10d      	bne.n	2618c <z_impl_net_addr_ntop+0x140>
			if (needcolon || i == 0U) {
   26170:	b902      	cbnz	r2, 26174 <z_impl_net_addr_ntop+0x128>
   26172:	b916      	cbnz	r6, 2617a <z_impl_net_addr_ntop+0x12e>
				*ptr++ = ':';
   26174:	233a      	movs	r3, #58	; 0x3a
   26176:	f804 3b01 	strb.w	r3, [r4], #1
			*ptr++ = ':';
   2617a:	233a      	movs	r3, #58	; 0x3a
   2617c:	4620      	mov	r0, r4
   2617e:	f800 3b01 	strb.w	r3, [r0], #1
			i += longest - 1U;
   26182:	1e7b      	subs	r3, r7, #1
   26184:	441d      	add	r5, r3
   26186:	b2ed      	uxtb	r5, r5
			needcolon = false;
   26188:	2200      	movs	r2, #0
			continue;
   2618a:	e7c3      	b.n	26114 <z_impl_net_addr_ntop+0xc8>
		if (needcolon) {
   2618c:	b112      	cbz	r2, 26194 <z_impl_net_addr_ntop+0x148>
			*ptr++ = ':';
   2618e:	233a      	movs	r3, #58	; 0x3a
   26190:	f804 3b01 	strb.w	r3, [r4], #1
		value = (u32_t)sys_be16_to_cpu(UNALIGNED_GET(&w[i]));
   26194:	9b04      	ldr	r3, [sp, #16]
   26196:	f833 3015 	ldrh.w	r3, [r3, r5, lsl #1]
   2619a:	021a      	lsls	r2, r3, #8
   2619c:	ea42 2213 	orr.w	r2, r2, r3, lsr #8
   261a0:	b212      	sxth	r2, r2
		bh = value >> 8;
   261a2:	f3c2 2307 	ubfx	r3, r2, #8, #8
		bl = value & 0xff;
   261a6:	fa5f fb82 	uxtb.w	fp, r2
		if (bh) {
   261aa:	b1b3      	cbz	r3, 261da <z_impl_net_addr_ntop+0x18e>
			if (bh > 0x0f) {
   261ac:	2b0f      	cmp	r3, #15
		bh = value >> 8;
   261ae:	b2d9      	uxtb	r1, r3
			if (bh > 0x0f) {
   261b0:	d90b      	bls.n	261ca <z_impl_net_addr_ntop+0x17e>
				ptr = net_byte_to_hex(ptr, bh, 'a', false);
   261b2:	2300      	movs	r3, #0
   261b4:	2261      	movs	r2, #97	; 0x61
   261b6:	4620      	mov	r0, r4
   261b8:	f011 ff98 	bl	380ec <net_byte_to_hex>
			ptr = net_byte_to_hex(ptr, bl, 'a', true);
   261bc:	2301      	movs	r3, #1
   261be:	2261      	movs	r2, #97	; 0x61
   261c0:	4659      	mov	r1, fp
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
   261c2:	f011 ff93 	bl	380ec <net_byte_to_hex>
		needcolon = true;
   261c6:	2201      	movs	r2, #1
   261c8:	e7a4      	b.n	26114 <z_impl_net_addr_ntop+0xc8>
				if (bh < 10) {
   261ca:	b25b      	sxtb	r3, r3
   261cc:	2909      	cmp	r1, #9
					*ptr++ = (char)(bh + '0');
   261ce:	bf94      	ite	ls
   261d0:	3330      	addls	r3, #48	; 0x30
					*ptr++ = (char) (bh - 10 + 'a');
   261d2:	3357      	addhi	r3, #87	; 0x57
   261d4:	1c60      	adds	r0, r4, #1
   261d6:	7023      	strb	r3, [r4, #0]
   261d8:	e7f0      	b.n	261bc <z_impl_net_addr_ntop+0x170>
		} else if (bl > 0x0f) {
   261da:	f1bb 0f0f 	cmp.w	fp, #15
   261de:	d903      	bls.n	261e8 <z_impl_net_addr_ntop+0x19c>
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
   261e0:	2261      	movs	r2, #97	; 0x61
   261e2:	4659      	mov	r1, fp
   261e4:	4620      	mov	r0, r4
   261e6:	e7ec      	b.n	261c2 <z_impl_net_addr_ntop+0x176>
			if (bl < 10) {
   261e8:	b252      	sxtb	r2, r2
   261ea:	f1bb 0f09 	cmp.w	fp, #9
				*ptr++ = (char)(bl + '0');
   261ee:	bf94      	ite	ls
   261f0:	3230      	addls	r2, #48	; 0x30
				*ptr++ = (char) (bl - 10 + 'a');
   261f2:	3257      	addhi	r2, #87	; 0x57
   261f4:	1c60      	adds	r0, r4, #1
   261f6:	7022      	strb	r2, [r4, #0]
   261f8:	e7e5      	b.n	261c6 <z_impl_net_addr_ntop+0x17a>
   261fa:	bf00      	nop
   261fc:	3b9aca00 	.word	0x3b9aca00

00026200 <connect_request_encode>:
	return mqtt_encode_fixed_header(message_type, start, buf);
}

int connect_request_encode(const struct mqtt_client *client,
			   struct buf_ctx *buf)
{
   26200:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	} else {
		mqtt_proto_desc = &mqtt_3_1_0_proto_desc;
	}

	/* Reserve space for fixed header. */
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   26204:	680f      	ldr	r7, [r1, #0]
	u8_t connect_flags = client->clean_session << 1;
   26206:	f890 5078 	ldrb.w	r5, [r0, #120]	; 0x78
	start = buf->cur;

	MQTT_TRC("Encoding Protocol Description. Str:%s Size:%08x.",
		 mqtt_proto_desc->utf8, mqtt_proto_desc->size);

	err_code = pack_utf8_str(mqtt_proto_desc, buf);
   2620a:	4b3b      	ldr	r3, [pc, #236]	; (262f8 <connect_request_encode+0xf8>)
   2620c:	4a3b      	ldr	r2, [pc, #236]	; (262fc <connect_request_encode+0xfc>)
{
   2620e:	4606      	mov	r6, r0
	if (client->protocol_version == MQTT_VERSION_3_1_1) {
   26210:	f890 0076 	ldrb.w	r0, [r0, #118]	; 0x76
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   26214:	3705      	adds	r7, #5
	err_code = pack_utf8_str(mqtt_proto_desc, buf);
   26216:	2804      	cmp	r0, #4
   26218:	bf0c      	ite	eq
   2621a:	4610      	moveq	r0, r2
   2621c:	4618      	movne	r0, r3
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   2621e:	600f      	str	r7, [r1, #0]
{
   26220:	460c      	mov	r4, r1
	err_code = pack_utf8_str(mqtt_proto_desc, buf);
   26222:	f012 f84b 	bl	382bc <pack_utf8_str>
	u8_t connect_flags = client->clean_session << 1;
   26226:	f3c5 0540 	ubfx	r5, r5, #1, #1
	if (err_code != 0) {
   2622a:	4603      	mov	r3, r0
   2622c:	b938      	cbnz	r0, 2623e <connect_request_encode+0x3e>
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   2622e:	e9d4 2000 	ldrd	r2, r0, [r4]
   26232:	4290      	cmp	r0, r2
		return err_code;
	}

	MQTT_TRC("Encoding Protocol Version %02x.", client->protocol_version);
	err_code = pack_uint8(client->protocol_version, buf);
   26234:	f896 1076 	ldrb.w	r1, [r6, #118]	; 0x76
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   26238:	d104      	bne.n	26244 <connect_request_encode+0x44>
		return -ENOMEM;
   2623a:	f06f 030b 	mvn.w	r3, #11

	/* Write the flags the connect flags. */
	*connect_flags_pos = connect_flags;

	return mqtt_encode_fixed_header(message_type, start, buf);
}
   2623e:	4618      	mov	r0, r3
   26240:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	*(buf->cur++) = val;
   26244:	1c50      	adds	r0, r2, #1
   26246:	6020      	str	r0, [r4, #0]
   26248:	7011      	strb	r1, [r2, #0]
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   2624a:	e9d4 8200 	ldrd	r8, r2, [r4]
   2624e:	4590      	cmp	r8, r2
   26250:	d0f3      	beq.n	2623a <connect_request_encode+0x3a>
	*(buf->cur++) = val;
   26252:	f108 0201 	add.w	r2, r8, #1
   26256:	6022      	str	r2, [r4, #0]
   26258:	f888 3000 	strb.w	r3, [r8]
	err_code = pack_uint16(client->keepalive, buf);
   2625c:	4621      	mov	r1, r4
   2625e:	f8b6 0074 	ldrh.w	r0, [r6, #116]	; 0x74
   26262:	f012 f819 	bl	38298 <pack_uint16>
	if (err_code != 0) {
   26266:	4603      	mov	r3, r0
   26268:	2800      	cmp	r0, #0
   2626a:	d1e8      	bne.n	2623e <connect_request_encode+0x3e>
	err_code = pack_utf8_str(&client->client_id, buf);
   2626c:	f106 0044 	add.w	r0, r6, #68	; 0x44
   26270:	f012 f824 	bl	382bc <pack_utf8_str>
	if (err_code != 0) {
   26274:	4603      	mov	r3, r0
   26276:	2800      	cmp	r0, #0
   26278:	d1e1      	bne.n	2623e <connect_request_encode+0x3e>
	if (client->will_topic != NULL) {
   2627a:	6db0      	ldr	r0, [r6, #88]	; 0x58
	u8_t connect_flags = client->clean_session << 1;
   2627c:	006d      	lsls	r5, r5, #1
	if (client->will_topic != NULL) {
   2627e:	b1d8      	cbz	r0, 262b8 <connect_request_encode+0xb8>
		connect_flags |= client->will_retain << 5;
   26280:	f896 3078 	ldrb.w	r3, [r6, #120]	; 0x78
		connect_flags |= MQTT_CONNECT_FLAG_WILL_TOPIC;
   26284:	f045 0504 	orr.w	r5, r5, #4
		connect_flags |= client->will_retain << 5;
   26288:	f003 0301 	and.w	r3, r3, #1
   2628c:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
		connect_flags |= ((client->will_topic->qos & 0x03) << 3);
   26290:	7a03      	ldrb	r3, [r0, #8]
		err_code = pack_utf8_str(&client->will_topic->topic, buf);
   26292:	4621      	mov	r1, r4
		connect_flags |= ((client->will_topic->qos & 0x03) << 3);
   26294:	00db      	lsls	r3, r3, #3
   26296:	f003 0318 	and.w	r3, r3, #24
		connect_flags |= client->will_retain << 5;
   2629a:	431d      	orrs	r5, r3
		err_code = pack_utf8_str(&client->will_topic->topic, buf);
   2629c:	f012 f80e 	bl	382bc <pack_utf8_str>
		if (err_code != 0) {
   262a0:	4603      	mov	r3, r0
   262a2:	2800      	cmp	r0, #0
   262a4:	d1cb      	bne.n	2623e <connect_request_encode+0x3e>
		if (client->will_message != NULL) {
   262a6:	6df3      	ldr	r3, [r6, #92]	; 0x5c
			err_code = pack_utf8_str(client->will_message, buf);
   262a8:	4621      	mov	r1, r4
		if (client->will_message != NULL) {
   262aa:	b313      	cbz	r3, 262f2 <connect_request_encode+0xf2>
			err_code = pack_utf8_str(client->will_message, buf);
   262ac:	4618      	mov	r0, r3
   262ae:	f012 f805 	bl	382bc <pack_utf8_str>
			if (err_code != 0) {
   262b2:	4603      	mov	r3, r0
   262b4:	2800      	cmp	r0, #0
   262b6:	d1c2      	bne.n	2623e <connect_request_encode+0x3e>
	if (client->user_name != NULL) {
   262b8:	6d30      	ldr	r0, [r6, #80]	; 0x50
   262ba:	b138      	cbz	r0, 262cc <connect_request_encode+0xcc>
		err_code = pack_utf8_str(client->user_name, buf);
   262bc:	4621      	mov	r1, r4
   262be:	f011 fffd 	bl	382bc <pack_utf8_str>
		if (err_code != 0) {
   262c2:	4603      	mov	r3, r0
   262c4:	2800      	cmp	r0, #0
   262c6:	d1ba      	bne.n	2623e <connect_request_encode+0x3e>
		connect_flags |= MQTT_CONNECT_FLAG_USERNAME;
   262c8:	f045 0580 	orr.w	r5, r5, #128	; 0x80
	if (client->password != NULL) {
   262cc:	6d70      	ldr	r0, [r6, #84]	; 0x54
   262ce:	b138      	cbz	r0, 262e0 <connect_request_encode+0xe0>
		err_code = pack_utf8_str(client->password, buf);
   262d0:	4621      	mov	r1, r4
   262d2:	f011 fff3 	bl	382bc <pack_utf8_str>
		if (err_code != 0) {
   262d6:	4603      	mov	r3, r0
   262d8:	2800      	cmp	r0, #0
   262da:	d1b0      	bne.n	2623e <connect_request_encode+0x3e>
		connect_flags |= MQTT_CONNECT_FLAG_PASSWORD;
   262dc:	f045 0540 	orr.w	r5, r5, #64	; 0x40
	*connect_flags_pos = connect_flags;
   262e0:	f888 5000 	strb.w	r5, [r8]
	return mqtt_encode_fixed_header(message_type, start, buf);
   262e4:	4622      	mov	r2, r4
   262e6:	4639      	mov	r1, r7
}
   262e8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return mqtt_encode_fixed_header(message_type, start, buf);
   262ec:	2010      	movs	r0, #16
   262ee:	f012 b800 	b.w	382f2 <mqtt_encode_fixed_header>
	return pack_uint16(0x0000, buf);
   262f2:	f011 ffd1 	bl	38298 <pack_uint16>
   262f6:	e7dc      	b.n	262b2 <connect_request_encode+0xb2>
   262f8:	0003b3a4 	.word	0x0003b3a4
   262fc:	0003b3ac 	.word	0x0003b3ac

00026300 <disconnect_encode>:
	return mqtt_message_id_only_enc(message_type, param->message_id, buf);
}

int disconnect_encode(struct buf_ctx *buf)
{
	if (buf->end - buf->cur < sizeof(disc_packet)) {
   26300:	e9d0 2300 	ldrd	r2, r3, [r0]
   26304:	1a9b      	subs	r3, r3, r2
   26306:	2b01      	cmp	r3, #1
   26308:	bf81      	itttt	hi
   2630a:	4b05      	ldrhi	r3, [pc, #20]	; (26320 <disconnect_encode+0x20>)
   2630c:	881b      	ldrhhi	r3, [r3, #0]
   2630e:	8013      	strhhi	r3, [r2, #0]
		return -ENOMEM;
	}

	memcpy(buf->cur, disc_packet, sizeof(disc_packet));
	buf->end = buf->cur + sizeof(disc_packet);
   26310:	6803      	ldrhi	r3, [r0, #0]
   26312:	bf83      	ittte	hi
   26314:	3302      	addhi	r3, #2
   26316:	6043      	strhi	r3, [r0, #4]

	return 0;
   26318:	2000      	movhi	r0, #0
		return -ENOMEM;
   2631a:	f06f 000b 	mvnls.w	r0, #11
}
   2631e:	4770      	bx	lr
   26320:	0003da79 	.word	0x0003da79

00026324 <ping_request_encode>:
	return mqtt_encode_fixed_header(message_type, start, buf);
}

int ping_request_encode(struct buf_ctx *buf)
{
	if (buf->end - buf->cur < sizeof(ping_packet)) {
   26324:	e9d0 2300 	ldrd	r2, r3, [r0]
   26328:	1a9b      	subs	r3, r3, r2
   2632a:	2b01      	cmp	r3, #1
   2632c:	bf81      	itttt	hi
   2632e:	4b05      	ldrhi	r3, [pc, #20]	; (26344 <ping_request_encode+0x20>)
   26330:	881b      	ldrhhi	r3, [r3, #0]
   26332:	8013      	strhhi	r3, [r2, #0]
		return -ENOMEM;
	}

	memcpy(buf->cur, ping_packet, sizeof(ping_packet));
	buf->end = buf->cur + sizeof(ping_packet);
   26334:	6803      	ldrhi	r3, [r0, #0]
   26336:	bf83      	ittte	hi
   26338:	3302      	addhi	r3, #2
   2633a:	6043      	strhi	r3, [r0, #4]

	return 0;
   2633c:	2000      	movhi	r0, #0
		return -ENOMEM;
   2633e:	f06f 000b 	mvnls.w	r0, #11
}
   26342:	4770      	bx	lr
   26344:	0003da85 	.word	0x0003da85

00026348 <close>:
{
   26348:	b570      	push	{r4, r5, r6, lr}
	__ASSERT_NO_MSG(socket_ops);
   2634a:	4c10      	ldr	r4, [pc, #64]	; (2638c <close+0x44>)
{
   2634c:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(socket_ops);
   2634e:	6823      	ldr	r3, [r4, #0]
   26350:	b94b      	cbnz	r3, 26366 <close+0x1e>
   26352:	490f      	ldr	r1, [pc, #60]	; (26390 <close+0x48>)
   26354:	480f      	ldr	r0, [pc, #60]	; (26394 <close+0x4c>)
   26356:	2321      	movs	r3, #33	; 0x21
   26358:	4a0f      	ldr	r2, [pc, #60]	; (26398 <close+0x50>)
   2635a:	f011 fcb1 	bl	37cc0 <printk>
   2635e:	2121      	movs	r1, #33	; 0x21
   26360:	480d      	ldr	r0, [pc, #52]	; (26398 <close+0x50>)
   26362:	f011 fcf3 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->close);
   26366:	6823      	ldr	r3, [r4, #0]
   26368:	685b      	ldr	r3, [r3, #4]
   2636a:	b94b      	cbnz	r3, 26380 <close+0x38>
   2636c:	490b      	ldr	r1, [pc, #44]	; (2639c <close+0x54>)
   2636e:	4809      	ldr	r0, [pc, #36]	; (26394 <close+0x4c>)
   26370:	2322      	movs	r3, #34	; 0x22
   26372:	4a09      	ldr	r2, [pc, #36]	; (26398 <close+0x50>)
   26374:	f011 fca4 	bl	37cc0 <printk>
   26378:	2122      	movs	r1, #34	; 0x22
   2637a:	4807      	ldr	r0, [pc, #28]	; (26398 <close+0x50>)
   2637c:	f011 fce6 	bl	37d4c <assert_post_action>
	return socket_ops->close(sock);
   26380:	6823      	ldr	r3, [r4, #0]
   26382:	4628      	mov	r0, r5
}
   26384:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return socket_ops->close(sock);
   26388:	685b      	ldr	r3, [r3, #4]
   2638a:	4718      	bx	r3
   2638c:	200204c0 	.word	0x200204c0
   26390:	0003c541 	.word	0x0003c541
   26394:	0003baac 	.word	0x0003baac
   26398:	0003c511 	.word	0x0003c511
   2639c:	0003da87 	.word	0x0003da87

000263a0 <mqtt_client_tcp_connect>:
#include <net/mqtt.h>

#include "mqtt_os.h"

int mqtt_client_tcp_connect(struct mqtt_client *client)
{
   263a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(socket_ops);
   263a4:	4c2d      	ldr	r4, [pc, #180]	; (2645c <mqtt_client_tcp_connect+0xbc>)
	const struct sockaddr *broker = client->broker;
   263a6:	6cc5      	ldr	r5, [r0, #76]	; 0x4c
   263a8:	6823      	ldr	r3, [r4, #0]
{
   263aa:	4606      	mov	r6, r0
	int ret;

	client->transport.tcp.sock = socket(broker->sa_family, SOCK_STREAM,
   263ac:	882f      	ldrh	r7, [r5, #0]
   263ae:	b94b      	cbnz	r3, 263c4 <mqtt_client_tcp_connect+0x24>
   263b0:	492b      	ldr	r1, [pc, #172]	; (26460 <mqtt_client_tcp_connect+0xc0>)
   263b2:	482c      	ldr	r0, [pc, #176]	; (26464 <mqtt_client_tcp_connect+0xc4>)
   263b4:	2319      	movs	r3, #25
   263b6:	4a2c      	ldr	r2, [pc, #176]	; (26468 <mqtt_client_tcp_connect+0xc8>)
   263b8:	f011 fc82 	bl	37cc0 <printk>
   263bc:	2119      	movs	r1, #25
   263be:	482a      	ldr	r0, [pc, #168]	; (26468 <mqtt_client_tcp_connect+0xc8>)
   263c0:	f011 fcc4 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->socket);
   263c4:	6823      	ldr	r3, [r4, #0]
   263c6:	681b      	ldr	r3, [r3, #0]
   263c8:	b94b      	cbnz	r3, 263de <mqtt_client_tcp_connect+0x3e>
   263ca:	4928      	ldr	r1, [pc, #160]	; (2646c <mqtt_client_tcp_connect+0xcc>)
   263cc:	4825      	ldr	r0, [pc, #148]	; (26464 <mqtt_client_tcp_connect+0xc4>)
   263ce:	231a      	movs	r3, #26
   263d0:	4a25      	ldr	r2, [pc, #148]	; (26468 <mqtt_client_tcp_connect+0xc8>)
   263d2:	f011 fc75 	bl	37cc0 <printk>
   263d6:	211a      	movs	r1, #26
   263d8:	4823      	ldr	r0, [pc, #140]	; (26468 <mqtt_client_tcp_connect+0xc8>)
   263da:	f011 fcb7 	bl	37d4c <assert_post_action>
	return socket_ops->socket(family, type, proto);
   263de:	6823      	ldr	r3, [r4, #0]
   263e0:	4638      	mov	r0, r7
   263e2:	681b      	ldr	r3, [r3, #0]
   263e4:	2206      	movs	r2, #6
   263e6:	2101      	movs	r1, #1
   263e8:	4798      	blx	r3
					    IPPROTO_TCP);
	if (client->transport.tcp.sock < 0) {
   263ea:	2800      	cmp	r0, #0
   263ec:	4607      	mov	r7, r0
	client->transport.tcp.sock = socket(broker->sa_family, SOCK_STREAM,
   263ee:	62b0      	str	r0, [r6, #40]	; 0x28
	if (client->transport.tcp.sock < 0) {
   263f0:	da05      	bge.n	263fe <mqtt_client_tcp_connect+0x5e>

	ret = connect(client->transport.tcp.sock, client->broker,
		      peer_addr_size);
	if (ret < 0) {
		(void)close(client->transport.tcp.sock);
		return -errno;
   263f2:	f011 fe60 	bl	380b6 <__errno>
   263f6:	6800      	ldr	r0, [r0, #0]
   263f8:	4240      	negs	r0, r0
	}

	MQTT_TRC("Connect completed");
	return 0;
}
   263fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (broker->sa_family == AF_INET) {
   263fe:	882b      	ldrh	r3, [r5, #0]
	ret = connect(client->transport.tcp.sock, client->broker,
   26400:	6cf5      	ldr	r5, [r6, #76]	; 0x4c
		peer_addr_size = sizeof(struct sockaddr_in);
   26402:	2b01      	cmp	r3, #1
	__ASSERT_NO_MSG(socket_ops);
   26404:	6823      	ldr	r3, [r4, #0]
   26406:	bf14      	ite	ne
   26408:	f04f 0818 	movne.w	r8, #24
   2640c:	f04f 0808 	moveq.w	r8, #8
   26410:	b94b      	cbnz	r3, 26426 <mqtt_client_tcp_connect+0x86>
   26412:	4913      	ldr	r1, [pc, #76]	; (26460 <mqtt_client_tcp_connect+0xc0>)
   26414:	4813      	ldr	r0, [pc, #76]	; (26464 <mqtt_client_tcp_connect+0xc4>)
   26416:	2345      	movs	r3, #69	; 0x45
   26418:	4a13      	ldr	r2, [pc, #76]	; (26468 <mqtt_client_tcp_connect+0xc8>)
   2641a:	f011 fc51 	bl	37cc0 <printk>
   2641e:	2145      	movs	r1, #69	; 0x45
   26420:	4811      	ldr	r0, [pc, #68]	; (26468 <mqtt_client_tcp_connect+0xc8>)
   26422:	f011 fc93 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->connect);
   26426:	6823      	ldr	r3, [r4, #0]
   26428:	695b      	ldr	r3, [r3, #20]
   2642a:	b94b      	cbnz	r3, 26440 <mqtt_client_tcp_connect+0xa0>
   2642c:	4910      	ldr	r1, [pc, #64]	; (26470 <mqtt_client_tcp_connect+0xd0>)
   2642e:	480d      	ldr	r0, [pc, #52]	; (26464 <mqtt_client_tcp_connect+0xc4>)
   26430:	2346      	movs	r3, #70	; 0x46
   26432:	4a0d      	ldr	r2, [pc, #52]	; (26468 <mqtt_client_tcp_connect+0xc8>)
   26434:	f011 fc44 	bl	37cc0 <printk>
   26438:	2146      	movs	r1, #70	; 0x46
   2643a:	480b      	ldr	r0, [pc, #44]	; (26468 <mqtt_client_tcp_connect+0xc8>)
   2643c:	f011 fc86 	bl	37d4c <assert_post_action>
	return socket_ops->connect(sock, addr, addrlen);
   26440:	6823      	ldr	r3, [r4, #0]
   26442:	4642      	mov	r2, r8
   26444:	695b      	ldr	r3, [r3, #20]
   26446:	4629      	mov	r1, r5
   26448:	4638      	mov	r0, r7
   2644a:	4798      	blx	r3
	if (ret < 0) {
   2644c:	2800      	cmp	r0, #0
   2644e:	da03      	bge.n	26458 <mqtt_client_tcp_connect+0xb8>
		(void)close(client->transport.tcp.sock);
   26450:	6ab0      	ldr	r0, [r6, #40]	; 0x28
   26452:	f7ff ff79 	bl	26348 <close>
   26456:	e7cc      	b.n	263f2 <mqtt_client_tcp_connect+0x52>
	return 0;
   26458:	2000      	movs	r0, #0
   2645a:	e7ce      	b.n	263fa <mqtt_client_tcp_connect+0x5a>
   2645c:	200204c0 	.word	0x200204c0
   26460:	0003c541 	.word	0x0003c541
   26464:	0003baac 	.word	0x0003baac
   26468:	0003c511 	.word	0x0003c511
   2646c:	0003da99 	.word	0x0003da99
   26470:	0003daac 	.word	0x0003daac

00026474 <mqtt_client_tcp_write>:

int mqtt_client_tcp_write(struct mqtt_client *client, const u8_t *data,
			  u32_t datalen)
{
   26474:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   26478:	4680      	mov	r8, r0
   2647a:	4689      	mov	r9, r1
   2647c:	4617      	mov	r7, r2
	u32_t offset = 0U;
   2647e:	2400      	movs	r4, #0
	__ASSERT_NO_MSG(socket_ops);
   26480:	4d1d      	ldr	r5, [pc, #116]	; (264f8 <mqtt_client_tcp_write+0x84>)
	int ret;

	while (offset < datalen) {
   26482:	42bc      	cmp	r4, r7
   26484:	d301      	bcc.n	2648a <mqtt_client_tcp_write+0x16>
		}

		offset += ret;
	}

	return 0;
   26486:	2000      	movs	r0, #0
   26488:	e031      	b.n	264ee <mqtt_client_tcp_write+0x7a>
		ret = send(client->transport.tcp.sock, data + offset,
   2648a:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
   2648e:	eb09 0a04 	add.w	sl, r9, r4
   26492:	461e      	mov	r6, r3
   26494:	4b19      	ldr	r3, [pc, #100]	; (264fc <mqtt_client_tcp_write+0x88>)
   26496:	eba7 0b04 	sub.w	fp, r7, r4
   2649a:	681b      	ldr	r3, [r3, #0]
   2649c:	b94b      	cbnz	r3, 264b2 <mqtt_client_tcp_write+0x3e>
   2649e:	4918      	ldr	r1, [pc, #96]	; (26500 <mqtt_client_tcp_write+0x8c>)
   264a0:	4818      	ldr	r0, [pc, #96]	; (26504 <mqtt_client_tcp_write+0x90>)
   264a2:	237e      	movs	r3, #126	; 0x7e
   264a4:	462a      	mov	r2, r5
   264a6:	f011 fc0b 	bl	37cc0 <printk>
   264aa:	217e      	movs	r1, #126	; 0x7e
   264ac:	4628      	mov	r0, r5
   264ae:	f011 fc4d 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->send);
   264b2:	4b12      	ldr	r3, [pc, #72]	; (264fc <mqtt_client_tcp_write+0x88>)
   264b4:	681b      	ldr	r3, [r3, #0]
   264b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   264b8:	b94b      	cbnz	r3, 264ce <mqtt_client_tcp_write+0x5a>
   264ba:	4913      	ldr	r1, [pc, #76]	; (26508 <mqtt_client_tcp_write+0x94>)
   264bc:	4811      	ldr	r0, [pc, #68]	; (26504 <mqtt_client_tcp_write+0x90>)
   264be:	237f      	movs	r3, #127	; 0x7f
   264c0:	462a      	mov	r2, r5
   264c2:	f011 fbfd 	bl	37cc0 <printk>
   264c6:	217f      	movs	r1, #127	; 0x7f
   264c8:	4628      	mov	r0, r5
   264ca:	f011 fc3f 	bl	37d4c <assert_post_action>
	return socket_ops->send(sock, buf, len, flags);
   264ce:	4b0b      	ldr	r3, [pc, #44]	; (264fc <mqtt_client_tcp_write+0x88>)
   264d0:	4630      	mov	r0, r6
   264d2:	681b      	ldr	r3, [r3, #0]
   264d4:	465a      	mov	r2, fp
   264d6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   264d8:	4651      	mov	r1, sl
   264da:	469c      	mov	ip, r3
   264dc:	2300      	movs	r3, #0
   264de:	4666      	mov	r6, ip
   264e0:	47b0      	blx	r6
		if (ret < 0) {
   264e2:	2800      	cmp	r0, #0
   264e4:	da05      	bge.n	264f2 <mqtt_client_tcp_write+0x7e>
			return -errno;
   264e6:	f011 fde6 	bl	380b6 <__errno>
   264ea:	6800      	ldr	r0, [r0, #0]
   264ec:	4240      	negs	r0, r0
}
   264ee:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		offset += ret;
   264f2:	4404      	add	r4, r0
   264f4:	e7c5      	b.n	26482 <mqtt_client_tcp_write+0xe>
   264f6:	bf00      	nop
   264f8:	0003c511 	.word	0x0003c511
   264fc:	200204c0 	.word	0x200204c0
   26500:	0003c541 	.word	0x0003c541
   26504:	0003baac 	.word	0x0003baac
   26508:	0003dad1 	.word	0x0003dad1

0002650c <mqtt_client_tcp_read>:

int mqtt_client_tcp_read(struct mqtt_client *client, u8_t *data, u32_t buflen,
			 bool shall_block)
{
   2650c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(socket_ops);
   26510:	4c18      	ldr	r4, [pc, #96]	; (26574 <mqtt_client_tcp_read+0x68>)
	int flags = 0;
	int ret;

	if (!shall_block) {
		flags |= MSG_DONTWAIT;
   26512:	2b00      	cmp	r3, #0
   26514:	6823      	ldr	r3, [r4, #0]
{
   26516:	460e      	mov	r6, r1
   26518:	4617      	mov	r7, r2
		flags |= MSG_DONTWAIT;
   2651a:	bf14      	ite	ne
   2651c:	f04f 0800 	movne.w	r8, #0
   26520:	f04f 0840 	moveq.w	r8, #64	; 0x40
	}

	ret = recv(client->transport.tcp.sock, data, buflen, flags);
   26524:	6a85      	ldr	r5, [r0, #40]	; 0x28
   26526:	b94b      	cbnz	r3, 2653c <mqtt_client_tcp_read+0x30>
   26528:	4913      	ldr	r1, [pc, #76]	; (26578 <mqtt_client_tcp_read+0x6c>)
   2652a:	4814      	ldr	r0, [pc, #80]	; (2657c <mqtt_client_tcp_read+0x70>)
   2652c:	2369      	movs	r3, #105	; 0x69
   2652e:	4a14      	ldr	r2, [pc, #80]	; (26580 <mqtt_client_tcp_read+0x74>)
   26530:	f011 fbc6 	bl	37cc0 <printk>
   26534:	2169      	movs	r1, #105	; 0x69
   26536:	4812      	ldr	r0, [pc, #72]	; (26580 <mqtt_client_tcp_read+0x74>)
   26538:	f011 fc08 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->recv);
   2653c:	6823      	ldr	r3, [r4, #0]
   2653e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   26540:	b94b      	cbnz	r3, 26556 <mqtt_client_tcp_read+0x4a>
   26542:	4910      	ldr	r1, [pc, #64]	; (26584 <mqtt_client_tcp_read+0x78>)
   26544:	480d      	ldr	r0, [pc, #52]	; (2657c <mqtt_client_tcp_read+0x70>)
   26546:	236a      	movs	r3, #106	; 0x6a
   26548:	4a0d      	ldr	r2, [pc, #52]	; (26580 <mqtt_client_tcp_read+0x74>)
   2654a:	f011 fbb9 	bl	37cc0 <printk>
   2654e:	216a      	movs	r1, #106	; 0x6a
   26550:	480b      	ldr	r0, [pc, #44]	; (26580 <mqtt_client_tcp_read+0x74>)
   26552:	f011 fbfb 	bl	37d4c <assert_post_action>
	return socket_ops->recv(sock, buf, max_len, flags);
   26556:	6823      	ldr	r3, [r4, #0]
   26558:	463a      	mov	r2, r7
   2655a:	6a5c      	ldr	r4, [r3, #36]	; 0x24
   2655c:	4631      	mov	r1, r6
   2655e:	4643      	mov	r3, r8
   26560:	4628      	mov	r0, r5
   26562:	47a0      	blx	r4
	if (ret < 0) {
   26564:	2800      	cmp	r0, #0
   26566:	da03      	bge.n	26570 <mqtt_client_tcp_read+0x64>
		return -errno;
   26568:	f011 fda5 	bl	380b6 <__errno>
   2656c:	6800      	ldr	r0, [r0, #0]
   2656e:	4240      	negs	r0, r0
	}

	return ret;
}
   26570:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   26574:	200204c0 	.word	0x200204c0
   26578:	0003c541 	.word	0x0003c541
   2657c:	0003baac 	.word	0x0003baac
   26580:	0003c511 	.word	0x0003c511
   26584:	0003dac0 	.word	0x0003dac0

00026588 <mqtt_transport_connect>:
#endif /* CONFIG_MQTT_LIB_WEBSOCKET */
};

int mqtt_transport_connect(struct mqtt_client *client)
{
	return transport_fn[client->transport.type].connect(client);
   26588:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
   2658c:	4a01      	ldr	r2, [pc, #4]	; (26594 <mqtt_transport_connect+0xc>)
   2658e:	011b      	lsls	r3, r3, #4
   26590:	58d3      	ldr	r3, [r2, r3]
   26592:	4718      	bx	r3
   26594:	0003b3b4 	.word	0x0003b3b4

00026598 <mqtt_transport_write>:
}

int mqtt_transport_write(struct mqtt_client *client, const u8_t *data,
			 u32_t datalen)
{
   26598:	b410      	push	{r4}
	return transport_fn[client->transport.type].write(client, data,
   2659a:	4b04      	ldr	r3, [pc, #16]	; (265ac <mqtt_transport_write+0x14>)
   2659c:	f890 4024 	ldrb.w	r4, [r0, #36]	; 0x24
   265a0:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   265a4:	685b      	ldr	r3, [r3, #4]
							  datalen);
}
   265a6:	f85d 4b04 	ldr.w	r4, [sp], #4
	return transport_fn[client->transport.type].write(client, data,
   265aa:	4718      	bx	r3
   265ac:	0003b3b4 	.word	0x0003b3b4

000265b0 <mqtt_transport_read>:

int mqtt_transport_read(struct mqtt_client *client, u8_t *data, u32_t buflen,
			bool shall_block)
{
   265b0:	b430      	push	{r4, r5}
	return transport_fn[client->transport.type].read(client, data, buflen,
   265b2:	f890 5024 	ldrb.w	r5, [r0, #36]	; 0x24
   265b6:	4c03      	ldr	r4, [pc, #12]	; (265c4 <mqtt_transport_read+0x14>)
   265b8:	eb04 1405 	add.w	r4, r4, r5, lsl #4
   265bc:	68a4      	ldr	r4, [r4, #8]
   265be:	46a4      	mov	ip, r4
							 shall_block);
}
   265c0:	bc30      	pop	{r4, r5}
	return transport_fn[client->transport.type].read(client, data, buflen,
   265c2:	4760      	bx	ip
   265c4:	0003b3b4 	.word	0x0003b3b4

000265c8 <mqtt_transport_disconnect>:

int mqtt_transport_disconnect(struct mqtt_client *client)
{
	return transport_fn[client->transport.type].disconnect(client);
   265c8:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
   265cc:	4b02      	ldr	r3, [pc, #8]	; (265d8 <mqtt_transport_disconnect+0x10>)
   265ce:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   265d2:	68db      	ldr	r3, [r3, #12]
   265d4:	4718      	bx	r3
   265d6:	bf00      	nop
   265d8:	0003b3b4 	.word	0x0003b3b4

000265dc <mqtt_mutex_unlock>:
	return k_mutex_lock(&mutex->kernel_mutex, timeout);
}

static inline int sys_mutex_unlock(struct sys_mutex *mutex)
{
	if (mutex->kernel_mutex.lock_count == 0) {
   265dc:	68c2      	ldr	r2, [r0, #12]
}

/**@brief Release the lock on the module specific mutex, if any.
 */
static inline void mqtt_mutex_unlock(struct mqtt_client *client)
{
   265de:	b510      	push	{r4, lr}
   265e0:	b142      	cbz	r2, 265f4 <mqtt_mutex_unlock+0x18>
		return -EINVAL;
	}

	if (mutex->kernel_mutex.owner != _current) {
   265e2:	4b0f      	ldr	r3, [pc, #60]	; (26620 <mqtt_mutex_unlock+0x44>)
   265e4:	6882      	ldr	r2, [r0, #8]
   265e6:	689b      	ldr	r3, [r3, #8]
   265e8:	429a      	cmp	r2, r3
   265ea:	d115      	bne.n	26618 <mqtt_mutex_unlock+0x3c>
	int ret = sys_mutex_unlock(&client->internal.mutex);

	__ASSERT(ret == 0, "sys_mutex_unlock failed with %d", ret);
	(void)ret;
}
   265ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   265f0:	f00c bc5c 	b.w	32eac <z_impl_k_mutex_unlock>
		return -EINVAL;
   265f4:	f06f 0415 	mvn.w	r4, #21
	__ASSERT(ret == 0, "sys_mutex_unlock failed with %d", ret);
   265f8:	2343      	movs	r3, #67	; 0x43
   265fa:	4a0a      	ldr	r2, [pc, #40]	; (26624 <mqtt_mutex_unlock+0x48>)
   265fc:	490a      	ldr	r1, [pc, #40]	; (26628 <mqtt_mutex_unlock+0x4c>)
   265fe:	480b      	ldr	r0, [pc, #44]	; (2662c <mqtt_mutex_unlock+0x50>)
   26600:	f011 fb5e 	bl	37cc0 <printk>
   26604:	4621      	mov	r1, r4
   26606:	480a      	ldr	r0, [pc, #40]	; (26630 <mqtt_mutex_unlock+0x54>)
   26608:	f011 fb5a 	bl	37cc0 <printk>
}
   2660c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__ASSERT(ret == 0, "sys_mutex_unlock failed with %d", ret);
   26610:	2143      	movs	r1, #67	; 0x43
   26612:	4804      	ldr	r0, [pc, #16]	; (26624 <mqtt_mutex_unlock+0x48>)
   26614:	f011 bb9a 	b.w	37d4c <assert_post_action>
		return -EPERM;
   26618:	f04f 34ff 	mov.w	r4, #4294967295
   2661c:	e7ec      	b.n	265f8 <mqtt_mutex_unlock+0x1c>
   2661e:	bf00      	nop
   26620:	20022108 	.word	0x20022108
   26624:	0003db02 	.word	0x0003db02
   26628:	0003db33 	.word	0x0003db33
   2662c:	0003baac 	.word	0x0003baac
   26630:	0003db3c 	.word	0x0003db3c

00026634 <mqtt_mutex_lock>:
{
   26634:	b510      	push	{r4, lr}
	return z_impl_k_mutex_lock(mutex, timeout);
   26636:	f04f 31ff 	mov.w	r1, #4294967295
   2663a:	f00c fb59 	bl	32cf0 <z_impl_k_mutex_lock>
	__ASSERT(ret == 0, "sys_mutex_lock failed with %d", ret);
   2663e:	4604      	mov	r4, r0
   26640:	b178      	cbz	r0, 26662 <mqtt_mutex_lock+0x2e>
   26642:	2339      	movs	r3, #57	; 0x39
   26644:	4a07      	ldr	r2, [pc, #28]	; (26664 <mqtt_mutex_lock+0x30>)
   26646:	4908      	ldr	r1, [pc, #32]	; (26668 <mqtt_mutex_lock+0x34>)
   26648:	4808      	ldr	r0, [pc, #32]	; (2666c <mqtt_mutex_lock+0x38>)
   2664a:	f011 fb39 	bl	37cc0 <printk>
   2664e:	4621      	mov	r1, r4
   26650:	4807      	ldr	r0, [pc, #28]	; (26670 <mqtt_mutex_lock+0x3c>)
   26652:	f011 fb35 	bl	37cc0 <printk>
}
   26656:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__ASSERT(ret == 0, "sys_mutex_lock failed with %d", ret);
   2665a:	2139      	movs	r1, #57	; 0x39
   2665c:	4801      	ldr	r0, [pc, #4]	; (26664 <mqtt_mutex_lock+0x30>)
   2665e:	f011 bb75 	b.w	37d4c <assert_post_action>
}
   26662:	bd10      	pop	{r4, pc}
   26664:	0003db02 	.word	0x0003db02
   26668:	0003db33 	.word	0x0003db33
   2666c:	0003baac 	.word	0x0003baac
   26670:	0003dae2 	.word	0x0003dae2

00026674 <close>:
{
   26674:	b570      	push	{r4, r5, r6, lr}
	__ASSERT_NO_MSG(socket_ops);
   26676:	4c10      	ldr	r4, [pc, #64]	; (266b8 <close+0x44>)
{
   26678:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(socket_ops);
   2667a:	6823      	ldr	r3, [r4, #0]
   2667c:	b94b      	cbnz	r3, 26692 <close+0x1e>
   2667e:	490f      	ldr	r1, [pc, #60]	; (266bc <close+0x48>)
   26680:	480f      	ldr	r0, [pc, #60]	; (266c0 <close+0x4c>)
   26682:	2321      	movs	r3, #33	; 0x21
   26684:	4a0f      	ldr	r2, [pc, #60]	; (266c4 <close+0x50>)
   26686:	f011 fb1b 	bl	37cc0 <printk>
   2668a:	2121      	movs	r1, #33	; 0x21
   2668c:	480d      	ldr	r0, [pc, #52]	; (266c4 <close+0x50>)
   2668e:	f011 fb5d 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->close);
   26692:	6823      	ldr	r3, [r4, #0]
   26694:	685b      	ldr	r3, [r3, #4]
   26696:	b94b      	cbnz	r3, 266ac <close+0x38>
   26698:	490b      	ldr	r1, [pc, #44]	; (266c8 <close+0x54>)
   2669a:	4809      	ldr	r0, [pc, #36]	; (266c0 <close+0x4c>)
   2669c:	2322      	movs	r3, #34	; 0x22
   2669e:	4a09      	ldr	r2, [pc, #36]	; (266c4 <close+0x50>)
   266a0:	f011 fb0e 	bl	37cc0 <printk>
   266a4:	2122      	movs	r1, #34	; 0x22
   266a6:	4807      	ldr	r0, [pc, #28]	; (266c4 <close+0x50>)
   266a8:	f011 fb50 	bl	37d4c <assert_post_action>
	return socket_ops->close(sock);
   266ac:	6823      	ldr	r3, [r4, #0]
   266ae:	4628      	mov	r0, r5
}
   266b0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return socket_ops->close(sock);
   266b4:	685b      	ldr	r3, [r3, #4]
   266b6:	4718      	bx	r3
   266b8:	200204c0 	.word	0x200204c0
   266bc:	0003c541 	.word	0x0003c541
   266c0:	0003baac 	.word	0x0003baac
   266c4:	0003c511 	.word	0x0003c511
   266c8:	0003da87 	.word	0x0003da87

000266cc <setsockopt.constprop.1>:
static inline int setsockopt(int sock, int level, int optname,
   266cc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(socket_ops);
   266d0:	4c15      	ldr	r4, [pc, #84]	; (26728 <setsockopt.constprop.1+0x5c>)
static inline int setsockopt(int sock, int level, int optname,
   266d2:	4698      	mov	r8, r3
	__ASSERT_NO_MSG(socket_ops);
   266d4:	6823      	ldr	r3, [r4, #0]
static inline int setsockopt(int sock, int level, int optname,
   266d6:	4605      	mov	r5, r0
   266d8:	460e      	mov	r6, r1
   266da:	4617      	mov	r7, r2
	__ASSERT_NO_MSG(socket_ops);
   266dc:	b94b      	cbnz	r3, 266f2 <setsockopt.constprop.1+0x26>
   266de:	4913      	ldr	r1, [pc, #76]	; (2672c <setsockopt.constprop.1+0x60>)
   266e0:	4813      	ldr	r0, [pc, #76]	; (26730 <setsockopt.constprop.1+0x64>)
   266e2:	2357      	movs	r3, #87	; 0x57
   266e4:	4a13      	ldr	r2, [pc, #76]	; (26734 <setsockopt.constprop.1+0x68>)
   266e6:	f011 faeb 	bl	37cc0 <printk>
   266ea:	2157      	movs	r1, #87	; 0x57
   266ec:	4811      	ldr	r0, [pc, #68]	; (26734 <setsockopt.constprop.1+0x68>)
   266ee:	f011 fb2d 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->setsockopt);
   266f2:	6823      	ldr	r3, [r4, #0]
   266f4:	69db      	ldr	r3, [r3, #28]
   266f6:	b94b      	cbnz	r3, 2670c <setsockopt.constprop.1+0x40>
   266f8:	490f      	ldr	r1, [pc, #60]	; (26738 <setsockopt.constprop.1+0x6c>)
   266fa:	480d      	ldr	r0, [pc, #52]	; (26730 <setsockopt.constprop.1+0x64>)
   266fc:	2358      	movs	r3, #88	; 0x58
   266fe:	4a0d      	ldr	r2, [pc, #52]	; (26734 <setsockopt.constprop.1+0x68>)
   26700:	f011 fade 	bl	37cc0 <printk>
   26704:	2158      	movs	r1, #88	; 0x58
   26706:	480b      	ldr	r0, [pc, #44]	; (26734 <setsockopt.constprop.1+0x68>)
   26708:	f011 fb20 	bl	37d4c <assert_post_action>
	return socket_ops->setsockopt(sock, level, optname, optval, optlen);
   2670c:	6823      	ldr	r3, [r4, #0]
   2670e:	f8cd 8000 	str.w	r8, [sp]
   26712:	69dc      	ldr	r4, [r3, #28]
   26714:	4632      	mov	r2, r6
   26716:	463b      	mov	r3, r7
   26718:	f44f 718d 	mov.w	r1, #282	; 0x11a
   2671c:	4628      	mov	r0, r5
   2671e:	47a0      	blx	r4
}
   26720:	b002      	add	sp, #8
   26722:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   26726:	bf00      	nop
   26728:	200204c0 	.word	0x200204c0
   2672c:	0003c541 	.word	0x0003c541
   26730:	0003baac 	.word	0x0003baac
   26734:	0003c511 	.word	0x0003c511
   26738:	0003db5e 	.word	0x0003db5e

0002673c <mqtt_client_tls_connect>:
#include <net/mqtt.h>

#include "mqtt_os.h"

int mqtt_client_tls_connect(struct mqtt_client *client)
{
   2673c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(socket_ops);
   26740:	4d48      	ldr	r5, [pc, #288]	; (26864 <mqtt_client_tls_connect+0x128>)
	const struct sockaddr *broker = client->broker;
   26742:	6cc7      	ldr	r7, [r0, #76]	; 0x4c
   26744:	682b      	ldr	r3, [r5, #0]
{
   26746:	4604      	mov	r4, r0
	struct mqtt_sec_config *tls_config = &client->transport.tls.config;
	int ret;

	client->transport.tls.sock = socket(broker->sa_family,
   26748:	883e      	ldrh	r6, [r7, #0]
   2674a:	b94b      	cbnz	r3, 26760 <mqtt_client_tls_connect+0x24>
   2674c:	4946      	ldr	r1, [pc, #280]	; (26868 <mqtt_client_tls_connect+0x12c>)
   2674e:	4847      	ldr	r0, [pc, #284]	; (2686c <mqtt_client_tls_connect+0x130>)
   26750:	2319      	movs	r3, #25
   26752:	4a47      	ldr	r2, [pc, #284]	; (26870 <mqtt_client_tls_connect+0x134>)
   26754:	f011 fab4 	bl	37cc0 <printk>
   26758:	2119      	movs	r1, #25
   2675a:	4845      	ldr	r0, [pc, #276]	; (26870 <mqtt_client_tls_connect+0x134>)
   2675c:	f011 faf6 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->socket);
   26760:	682b      	ldr	r3, [r5, #0]
   26762:	681b      	ldr	r3, [r3, #0]
   26764:	b94b      	cbnz	r3, 2677a <mqtt_client_tls_connect+0x3e>
   26766:	4943      	ldr	r1, [pc, #268]	; (26874 <mqtt_client_tls_connect+0x138>)
   26768:	4840      	ldr	r0, [pc, #256]	; (2686c <mqtt_client_tls_connect+0x130>)
   2676a:	231a      	movs	r3, #26
   2676c:	4a40      	ldr	r2, [pc, #256]	; (26870 <mqtt_client_tls_connect+0x134>)
   2676e:	f011 faa7 	bl	37cc0 <printk>
   26772:	211a      	movs	r1, #26
   26774:	483e      	ldr	r0, [pc, #248]	; (26870 <mqtt_client_tls_connect+0x134>)
   26776:	f011 fae9 	bl	37d4c <assert_post_action>
	return socket_ops->socket(family, type, proto);
   2677a:	682b      	ldr	r3, [r5, #0]
   2677c:	f44f 7281 	mov.w	r2, #258	; 0x102
   26780:	681b      	ldr	r3, [r3, #0]
   26782:	2101      	movs	r1, #1
   26784:	4630      	mov	r0, r6
   26786:	4798      	blx	r3
					    SOCK_STREAM, IPPROTO_TLS_1_2);
	if (client->transport.tls.sock < 0) {
   26788:	2800      	cmp	r0, #0
	client->transport.tls.sock = socket(broker->sa_family,
   2678a:	62a0      	str	r0, [r4, #40]	; 0x28
	if (client->transport.tls.sock < 0) {
   2678c:	da05      	bge.n	2679a <mqtt_client_tls_connect+0x5e>
	MQTT_TRC("Connect completed");
	return 0;

error:
	(void)close(client->transport.tls.sock);
	return -errno;
   2678e:	f011 fc92 	bl	380b6 <__errno>
   26792:	6800      	ldr	r0, [r0, #0]
   26794:	4240      	negs	r0, r0
}
   26796:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ret = setsockopt(client->transport.tls.sock, SOL_TLS, TLS_PEER_VERIFY,
   2679a:	2304      	movs	r3, #4
   2679c:	f104 022c 	add.w	r2, r4, #44	; 0x2c
   267a0:	2105      	movs	r1, #5
   267a2:	f7ff ff93 	bl	266cc <setsockopt.constprop.1>
	if (ret < 0) {
   267a6:	2800      	cmp	r0, #0
   267a8:	da03      	bge.n	267b2 <mqtt_client_tls_connect+0x76>
	(void)close(client->transport.tls.sock);
   267aa:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   267ac:	f7ff ff62 	bl	26674 <close>
   267b0:	e7ed      	b.n	2678e <mqtt_client_tls_connect+0x52>
	if (tls_config->cipher_list != NULL && tls_config->cipher_count > 0) {
   267b2:	6b62      	ldr	r2, [r4, #52]	; 0x34
   267b4:	2a00      	cmp	r2, #0
   267b6:	d131      	bne.n	2681c <mqtt_client_tls_connect+0xe0>
	if (tls_config->sec_tag_list != NULL && tls_config->sec_tag_count > 0) {
   267b8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   267ba:	2a00      	cmp	r2, #0
   267bc:	d139      	bne.n	26832 <mqtt_client_tls_connect+0xf6>
	if (tls_config->hostname) {
   267be:	6c26      	ldr	r6, [r4, #64]	; 0x40
   267c0:	2e00      	cmp	r6, #0
   267c2:	d141      	bne.n	26848 <mqtt_client_tls_connect+0x10c>
	if (broker->sa_family == AF_INET) {
   267c4:	883b      	ldrh	r3, [r7, #0]
	ret = connect(client->transport.tls.sock, client->broker,
   267c6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
	size_t peer_addr_size = sizeof(struct sockaddr_in6);
   267c8:	2b01      	cmp	r3, #1
	__ASSERT_NO_MSG(socket_ops);
   267ca:	682b      	ldr	r3, [r5, #0]
   267cc:	bf0c      	ite	eq
   267ce:	f04f 0808 	moveq.w	r8, #8
   267d2:	f04f 0818 	movne.w	r8, #24
	ret = connect(client->transport.tls.sock, client->broker,
   267d6:	6ce7      	ldr	r7, [r4, #76]	; 0x4c
   267d8:	b94b      	cbnz	r3, 267ee <mqtt_client_tls_connect+0xb2>
   267da:	4923      	ldr	r1, [pc, #140]	; (26868 <mqtt_client_tls_connect+0x12c>)
   267dc:	4823      	ldr	r0, [pc, #140]	; (2686c <mqtt_client_tls_connect+0x130>)
   267de:	2345      	movs	r3, #69	; 0x45
   267e0:	4a23      	ldr	r2, [pc, #140]	; (26870 <mqtt_client_tls_connect+0x134>)
   267e2:	f011 fa6d 	bl	37cc0 <printk>
   267e6:	2145      	movs	r1, #69	; 0x45
   267e8:	4821      	ldr	r0, [pc, #132]	; (26870 <mqtt_client_tls_connect+0x134>)
   267ea:	f011 faaf 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->connect);
   267ee:	682b      	ldr	r3, [r5, #0]
   267f0:	695b      	ldr	r3, [r3, #20]
   267f2:	b94b      	cbnz	r3, 26808 <mqtt_client_tls_connect+0xcc>
   267f4:	4920      	ldr	r1, [pc, #128]	; (26878 <mqtt_client_tls_connect+0x13c>)
   267f6:	481d      	ldr	r0, [pc, #116]	; (2686c <mqtt_client_tls_connect+0x130>)
   267f8:	2346      	movs	r3, #70	; 0x46
   267fa:	4a1d      	ldr	r2, [pc, #116]	; (26870 <mqtt_client_tls_connect+0x134>)
   267fc:	f011 fa60 	bl	37cc0 <printk>
   26800:	2146      	movs	r1, #70	; 0x46
   26802:	481b      	ldr	r0, [pc, #108]	; (26870 <mqtt_client_tls_connect+0x134>)
   26804:	f011 faa2 	bl	37d4c <assert_post_action>
	return socket_ops->connect(sock, addr, addrlen);
   26808:	682b      	ldr	r3, [r5, #0]
   2680a:	4642      	mov	r2, r8
   2680c:	695b      	ldr	r3, [r3, #20]
   2680e:	4639      	mov	r1, r7
   26810:	4630      	mov	r0, r6
   26812:	4798      	blx	r3
	if (ret < 0) {
   26814:	2800      	cmp	r0, #0
   26816:	dbc8      	blt.n	267aa <mqtt_client_tls_connect+0x6e>
	return 0;
   26818:	2000      	movs	r0, #0
   2681a:	e7bc      	b.n	26796 <mqtt_client_tls_connect+0x5a>
	if (tls_config->cipher_list != NULL && tls_config->cipher_count > 0) {
   2681c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   2681e:	2b00      	cmp	r3, #0
   26820:	d0ca      	beq.n	267b8 <mqtt_client_tls_connect+0x7c>
		ret = setsockopt(client->transport.tls.sock, SOL_TLS,
   26822:	009b      	lsls	r3, r3, #2
   26824:	2103      	movs	r1, #3
   26826:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   26828:	f7ff ff50 	bl	266cc <setsockopt.constprop.1>
		if (ret < 0) {
   2682c:	2800      	cmp	r0, #0
   2682e:	dac3      	bge.n	267b8 <mqtt_client_tls_connect+0x7c>
   26830:	e7bb      	b.n	267aa <mqtt_client_tls_connect+0x6e>
	if (tls_config->sec_tag_list != NULL && tls_config->sec_tag_count > 0) {
   26832:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   26834:	2b00      	cmp	r3, #0
   26836:	d0c2      	beq.n	267be <mqtt_client_tls_connect+0x82>
		ret = setsockopt(client->transport.tls.sock, SOL_TLS,
   26838:	009b      	lsls	r3, r3, #2
   2683a:	2101      	movs	r1, #1
   2683c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   2683e:	f7ff ff45 	bl	266cc <setsockopt.constprop.1>
		if (ret < 0) {
   26842:	2800      	cmp	r0, #0
   26844:	dabb      	bge.n	267be <mqtt_client_tls_connect+0x82>
   26846:	e7b0      	b.n	267aa <mqtt_client_tls_connect+0x6e>
		ret = setsockopt(client->transport.tls.sock, SOL_TLS,
   26848:	4630      	mov	r0, r6
   2684a:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
   2684e:	f7f6 fc83 	bl	1d158 <strlen>
   26852:	4632      	mov	r2, r6
   26854:	4603      	mov	r3, r0
   26856:	2102      	movs	r1, #2
   26858:	4640      	mov	r0, r8
   2685a:	f7ff ff37 	bl	266cc <setsockopt.constprop.1>
		if (ret < 0) {
   2685e:	2800      	cmp	r0, #0
   26860:	dab0      	bge.n	267c4 <mqtt_client_tls_connect+0x88>
   26862:	e7a2      	b.n	267aa <mqtt_client_tls_connect+0x6e>
   26864:	200204c0 	.word	0x200204c0
   26868:	0003c541 	.word	0x0003c541
   2686c:	0003baac 	.word	0x0003baac
   26870:	0003c511 	.word	0x0003c511
   26874:	0003da99 	.word	0x0003da99
   26878:	0003daac 	.word	0x0003daac

0002687c <mqtt_client_tls_write>:

int mqtt_client_tls_write(struct mqtt_client *client, const u8_t *data,
			  u32_t datalen)
{
   2687c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   26880:	4680      	mov	r8, r0
   26882:	4689      	mov	r9, r1
   26884:	4617      	mov	r7, r2
	u32_t offset = 0U;
   26886:	2400      	movs	r4, #0
	__ASSERT_NO_MSG(socket_ops);
   26888:	4d1d      	ldr	r5, [pc, #116]	; (26900 <mqtt_client_tls_write+0x84>)
	int ret;

	while (offset < datalen) {
   2688a:	42bc      	cmp	r4, r7
   2688c:	d301      	bcc.n	26892 <mqtt_client_tls_write+0x16>
		}

		offset += ret;
	}

	return 0;
   2688e:	2000      	movs	r0, #0
   26890:	e031      	b.n	268f6 <mqtt_client_tls_write+0x7a>
		ret = send(client->transport.tls.sock, data + offset,
   26892:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
   26896:	eb09 0a04 	add.w	sl, r9, r4
   2689a:	461e      	mov	r6, r3
   2689c:	4b19      	ldr	r3, [pc, #100]	; (26904 <mqtt_client_tls_write+0x88>)
   2689e:	eba7 0b04 	sub.w	fp, r7, r4
   268a2:	681b      	ldr	r3, [r3, #0]
   268a4:	b94b      	cbnz	r3, 268ba <mqtt_client_tls_write+0x3e>
   268a6:	4918      	ldr	r1, [pc, #96]	; (26908 <mqtt_client_tls_write+0x8c>)
   268a8:	4818      	ldr	r0, [pc, #96]	; (2690c <mqtt_client_tls_write+0x90>)
   268aa:	237e      	movs	r3, #126	; 0x7e
   268ac:	462a      	mov	r2, r5
   268ae:	f011 fa07 	bl	37cc0 <printk>
   268b2:	217e      	movs	r1, #126	; 0x7e
   268b4:	4628      	mov	r0, r5
   268b6:	f011 fa49 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->send);
   268ba:	4b12      	ldr	r3, [pc, #72]	; (26904 <mqtt_client_tls_write+0x88>)
   268bc:	681b      	ldr	r3, [r3, #0]
   268be:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   268c0:	b94b      	cbnz	r3, 268d6 <mqtt_client_tls_write+0x5a>
   268c2:	4913      	ldr	r1, [pc, #76]	; (26910 <mqtt_client_tls_write+0x94>)
   268c4:	4811      	ldr	r0, [pc, #68]	; (2690c <mqtt_client_tls_write+0x90>)
   268c6:	237f      	movs	r3, #127	; 0x7f
   268c8:	462a      	mov	r2, r5
   268ca:	f011 f9f9 	bl	37cc0 <printk>
   268ce:	217f      	movs	r1, #127	; 0x7f
   268d0:	4628      	mov	r0, r5
   268d2:	f011 fa3b 	bl	37d4c <assert_post_action>
	return socket_ops->send(sock, buf, len, flags);
   268d6:	4b0b      	ldr	r3, [pc, #44]	; (26904 <mqtt_client_tls_write+0x88>)
   268d8:	4630      	mov	r0, r6
   268da:	681b      	ldr	r3, [r3, #0]
   268dc:	465a      	mov	r2, fp
   268de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   268e0:	4651      	mov	r1, sl
   268e2:	469c      	mov	ip, r3
   268e4:	2300      	movs	r3, #0
   268e6:	4666      	mov	r6, ip
   268e8:	47b0      	blx	r6
		if (ret < 0) {
   268ea:	2800      	cmp	r0, #0
   268ec:	da05      	bge.n	268fa <mqtt_client_tls_write+0x7e>
			return -errno;
   268ee:	f011 fbe2 	bl	380b6 <__errno>
   268f2:	6800      	ldr	r0, [r0, #0]
   268f4:	4240      	negs	r0, r0
}
   268f6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		offset += ret;
   268fa:	4404      	add	r4, r0
   268fc:	e7c5      	b.n	2688a <mqtt_client_tls_write+0xe>
   268fe:	bf00      	nop
   26900:	0003c511 	.word	0x0003c511
   26904:	200204c0 	.word	0x200204c0
   26908:	0003c541 	.word	0x0003c541
   2690c:	0003baac 	.word	0x0003baac
   26910:	0003dad1 	.word	0x0003dad1

00026914 <mqtt_client_tls_read>:

int mqtt_client_tls_read(struct mqtt_client *client, u8_t *data, u32_t buflen,
			 bool shall_block)
{
   26914:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(socket_ops);
   26918:	4c18      	ldr	r4, [pc, #96]	; (2697c <mqtt_client_tls_read+0x68>)
	int flags = 0;
	int ret;

	if (!shall_block) {
		flags |= MSG_DONTWAIT;
   2691a:	2b00      	cmp	r3, #0
   2691c:	6823      	ldr	r3, [r4, #0]
{
   2691e:	460e      	mov	r6, r1
   26920:	4617      	mov	r7, r2
		flags |= MSG_DONTWAIT;
   26922:	bf14      	ite	ne
   26924:	f04f 0800 	movne.w	r8, #0
   26928:	f04f 0840 	moveq.w	r8, #64	; 0x40
	}

	ret = recv(client->transport.tls.sock, data, buflen, flags);
   2692c:	6a85      	ldr	r5, [r0, #40]	; 0x28
   2692e:	b94b      	cbnz	r3, 26944 <mqtt_client_tls_read+0x30>
   26930:	4913      	ldr	r1, [pc, #76]	; (26980 <mqtt_client_tls_read+0x6c>)
   26932:	4814      	ldr	r0, [pc, #80]	; (26984 <mqtt_client_tls_read+0x70>)
   26934:	2369      	movs	r3, #105	; 0x69
   26936:	4a14      	ldr	r2, [pc, #80]	; (26988 <mqtt_client_tls_read+0x74>)
   26938:	f011 f9c2 	bl	37cc0 <printk>
   2693c:	2169      	movs	r1, #105	; 0x69
   2693e:	4812      	ldr	r0, [pc, #72]	; (26988 <mqtt_client_tls_read+0x74>)
   26940:	f011 fa04 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->recv);
   26944:	6823      	ldr	r3, [r4, #0]
   26946:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   26948:	b94b      	cbnz	r3, 2695e <mqtt_client_tls_read+0x4a>
   2694a:	4910      	ldr	r1, [pc, #64]	; (2698c <mqtt_client_tls_read+0x78>)
   2694c:	480d      	ldr	r0, [pc, #52]	; (26984 <mqtt_client_tls_read+0x70>)
   2694e:	236a      	movs	r3, #106	; 0x6a
   26950:	4a0d      	ldr	r2, [pc, #52]	; (26988 <mqtt_client_tls_read+0x74>)
   26952:	f011 f9b5 	bl	37cc0 <printk>
   26956:	216a      	movs	r1, #106	; 0x6a
   26958:	480b      	ldr	r0, [pc, #44]	; (26988 <mqtt_client_tls_read+0x74>)
   2695a:	f011 f9f7 	bl	37d4c <assert_post_action>
	return socket_ops->recv(sock, buf, max_len, flags);
   2695e:	6823      	ldr	r3, [r4, #0]
   26960:	463a      	mov	r2, r7
   26962:	6a5c      	ldr	r4, [r3, #36]	; 0x24
   26964:	4631      	mov	r1, r6
   26966:	4643      	mov	r3, r8
   26968:	4628      	mov	r0, r5
   2696a:	47a0      	blx	r4
	if (ret < 0) {
   2696c:	2800      	cmp	r0, #0
   2696e:	da03      	bge.n	26978 <mqtt_client_tls_read+0x64>
		return -errno;
   26970:	f011 fba1 	bl	380b6 <__errno>
   26974:	6800      	ldr	r0, [r0, #0]
   26976:	4240      	negs	r0, r0
	}

	return ret;
}
   26978:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2697c:	200204c0 	.word	0x200204c0
   26980:	0003c541 	.word	0x0003c541
   26984:	0003baac 	.word	0x0003baac
   26988:	0003c511 	.word	0x0003c511
   2698c:	0003dac0 	.word	0x0003dac0

00026990 <z_impl_entropy_get_entropy>:
				  u16_t length);

static inline int z_impl_entropy_get_entropy(struct device *dev,
					    u8_t *buffer,
					    u16_t length)
{
   26990:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct entropy_driver_api *api =
   26994:	6845      	ldr	r5, [r0, #4]
{
   26996:	4604      	mov	r4, r0
		(const struct entropy_driver_api *)dev->driver_api;

	__ASSERT(api->get_entropy != NULL,
   26998:	682b      	ldr	r3, [r5, #0]
{
   2699a:	460e      	mov	r6, r1
   2699c:	4617      	mov	r7, r2
	__ASSERT(api->get_entropy != NULL,
   2699e:	b963      	cbnz	r3, 269ba <z_impl_entropy_get_entropy+0x2a>
   269a0:	4909      	ldr	r1, [pc, #36]	; (269c8 <z_impl_entropy_get_entropy+0x38>)
   269a2:	234c      	movs	r3, #76	; 0x4c
   269a4:	4a09      	ldr	r2, [pc, #36]	; (269cc <z_impl_entropy_get_entropy+0x3c>)
   269a6:	480a      	ldr	r0, [pc, #40]	; (269d0 <z_impl_entropy_get_entropy+0x40>)
   269a8:	f011 f98a 	bl	37cc0 <printk>
   269ac:	4809      	ldr	r0, [pc, #36]	; (269d4 <z_impl_entropy_get_entropy+0x44>)
   269ae:	f011 f987 	bl	37cc0 <printk>
   269b2:	214c      	movs	r1, #76	; 0x4c
   269b4:	4805      	ldr	r0, [pc, #20]	; (269cc <z_impl_entropy_get_entropy+0x3c>)
   269b6:	f011 f9c9 	bl	37d4c <assert_post_action>
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
   269ba:	682b      	ldr	r3, [r5, #0]
   269bc:	463a      	mov	r2, r7
   269be:	4631      	mov	r1, r6
   269c0:	4620      	mov	r0, r4
}
   269c2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return api->get_entropy(dev, buffer, length);
   269c6:	4718      	bx	r3
   269c8:	0003dc52 	.word	0x0003dc52
   269cc:	0003dc25 	.word	0x0003dc25
   269d0:	0003baac 	.word	0x0003baac
   269d4:	0003dc72 	.word	0x0003dc72

000269d8 <sys_rand32_get>:

static struct device *entropy_driver;

#if defined(CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR)
u32_t sys_rand32_get(void)
{
   269d8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct device *dev = entropy_driver;
   269da:	4d12      	ldr	r5, [pc, #72]	; (26a24 <sys_rand32_get+0x4c>)
   269dc:	682c      	ldr	r4, [r5, #0]
	u32_t random_num;
	int ret;

	if (unlikely(!dev)) {
   269de:	b99c      	cbnz	r4, 26a08 <sys_rand32_get+0x30>
   269e0:	4811      	ldr	r0, [pc, #68]	; (26a28 <sys_rand32_get+0x50>)
   269e2:	f00b fca1 	bl	32328 <z_impl_device_get_binding>
		/* Only one entropy device exists, so this is safe even
		 * if the whole operation isn't atomic.
		 */
		dev = device_get_binding(CONFIG_ENTROPY_NAME);
		__ASSERT((dev != NULL),
   269e6:	4604      	mov	r4, r0
   269e8:	b968      	cbnz	r0, 26a06 <sys_rand32_get+0x2e>
   269ea:	231d      	movs	r3, #29
   269ec:	4a0f      	ldr	r2, [pc, #60]	; (26a2c <sys_rand32_get+0x54>)
   269ee:	4910      	ldr	r1, [pc, #64]	; (26a30 <sys_rand32_get+0x58>)
   269f0:	4810      	ldr	r0, [pc, #64]	; (26a34 <sys_rand32_get+0x5c>)
   269f2:	f011 f965 	bl	37cc0 <printk>
   269f6:	490c      	ldr	r1, [pc, #48]	; (26a28 <sys_rand32_get+0x50>)
   269f8:	480f      	ldr	r0, [pc, #60]	; (26a38 <sys_rand32_get+0x60>)
   269fa:	f011 f961 	bl	37cc0 <printk>
   269fe:	211d      	movs	r1, #29
   26a00:	480a      	ldr	r0, [pc, #40]	; (26a2c <sys_rand32_get+0x54>)
   26a02:	f011 f9a3 	bl	37d4c <assert_post_action>
			"Device driver for %s (CONFIG_ENTROPY_NAME) not found. "
			"Check your build configuration!",
			CONFIG_ENTROPY_NAME);
		entropy_driver = dev;
   26a06:	602c      	str	r4, [r5, #0]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&buffer, *(uintptr_t *)&length, K_SYSCALL_ENTROPY_GET_ENTROPY);
	}
#endif
	compiler_barrier();
	return z_impl_entropy_get_entropy(dev, buffer, length);
   26a08:	2204      	movs	r2, #4
   26a0a:	4620      	mov	r0, r4
   26a0c:	eb0d 0102 	add.w	r1, sp, r2
   26a10:	f7ff ffbe 	bl	26990 <z_impl_entropy_get_entropy>
	}

	ret = entropy_get_entropy(dev, (u8_t *)&random_num,
				  sizeof(random_num));
	if (unlikely(ret < 0)) {
   26a14:	2800      	cmp	r0, #0
   26a16:	da02      	bge.n	26a1e <sys_rand32_get+0x46>
#ifndef _ASMLANGUAGE
extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
   26a18:	f7fe f92e 	bl	24c78 <z_timer_cycle_get_32>
		 * 32-bit of data.  There's not much that can be done in this
		 * situation.  An __ASSERT() isn't used here as the HWRNG might
		 * still be gathering entropy during early boot situations.
		 */

		random_num = k_cycle_get_32();
   26a1c:	9001      	str	r0, [sp, #4]
	}

	return random_num;
}
   26a1e:	9801      	ldr	r0, [sp, #4]
   26a20:	b003      	add	sp, #12
   26a22:	bd30      	pop	{r4, r5, pc}
   26a24:	200205a4 	.word	0x200205a4
   26a28:	0003db75 	.word	0x0003db75
   26a2c:	0003db7f 	.word	0x0003db7f
   26a30:	0003dbb8 	.word	0x0003dbb8
   26a34:	0003baac 	.word	0x0003baac
   26a38:	0003dbcd 	.word	0x0003dbcd

00026a3c <gpio_nrfx_manage_callback>:
}

static int gpio_nrfx_manage_callback(struct device *port,
				     struct gpio_callback *callback,
				     bool set)
{
   26a3c:	b570      	push	{r4, r5, r6, lr}
   26a3e:	4616      	mov	r6, r2
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   26a40:	6884      	ldr	r4, [r0, #8]
 */
static inline int gpio_manage_callback(sys_slist_t *callbacks,
					struct gpio_callback *callback,
					bool set)
{
	__ASSERT(callback, "No callback!");
   26a42:	460d      	mov	r5, r1
   26a44:	b961      	cbnz	r1, 26a60 <gpio_nrfx_manage_callback+0x24>
   26a46:	4922      	ldr	r1, [pc, #136]	; (26ad0 <gpio_nrfx_manage_callback+0x94>)
   26a48:	231c      	movs	r3, #28
   26a4a:	4a22      	ldr	r2, [pc, #136]	; (26ad4 <gpio_nrfx_manage_callback+0x98>)
   26a4c:	4822      	ldr	r0, [pc, #136]	; (26ad8 <gpio_nrfx_manage_callback+0x9c>)
   26a4e:	f011 f937 	bl	37cc0 <printk>
   26a52:	4822      	ldr	r0, [pc, #136]	; (26adc <gpio_nrfx_manage_callback+0xa0>)
   26a54:	f011 f934 	bl	37cc0 <printk>
   26a58:	211c      	movs	r1, #28
   26a5a:	481e      	ldr	r0, [pc, #120]	; (26ad4 <gpio_nrfx_manage_callback+0x98>)
   26a5c:	f011 f976 	bl	37d4c <assert_post_action>
	__ASSERT(callback->handler, "No callback handler!");
   26a60:	686b      	ldr	r3, [r5, #4]
   26a62:	b963      	cbnz	r3, 26a7e <gpio_nrfx_manage_callback+0x42>
   26a64:	491e      	ldr	r1, [pc, #120]	; (26ae0 <gpio_nrfx_manage_callback+0xa4>)
   26a66:	231d      	movs	r3, #29
   26a68:	4a1a      	ldr	r2, [pc, #104]	; (26ad4 <gpio_nrfx_manage_callback+0x98>)
   26a6a:	481b      	ldr	r0, [pc, #108]	; (26ad8 <gpio_nrfx_manage_callback+0x9c>)
   26a6c:	f011 f928 	bl	37cc0 <printk>
   26a70:	481c      	ldr	r0, [pc, #112]	; (26ae4 <gpio_nrfx_manage_callback+0xa8>)
   26a72:	f011 f925 	bl	37cc0 <printk>
   26a76:	211d      	movs	r1, #29
   26a78:	4816      	ldr	r0, [pc, #88]	; (26ad4 <gpio_nrfx_manage_callback+0x98>)
   26a7a:	f011 f967 	bl	37d4c <assert_post_action>
Z_GENLIST_IS_EMPTY(slist)
   26a7e:	6823      	ldr	r3, [r4, #0]

	if (!sys_slist_is_empty(callbacks)) {
   26a80:	b15b      	cbz	r3, 26a9a <gpio_nrfx_manage_callback+0x5e>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   26a82:	2200      	movs	r2, #0
   26a84:	429d      	cmp	r5, r3
   26a86:	d113      	bne.n	26ab0 <gpio_nrfx_manage_callback+0x74>
Z_GENLIST_REMOVE(slist, snode)
   26a88:	682b      	ldr	r3, [r5, #0]
   26a8a:	b95a      	cbnz	r2, 26aa4 <gpio_nrfx_manage_callback+0x68>
   26a8c:	6862      	ldr	r2, [r4, #4]
	list->head = node;
   26a8e:	6023      	str	r3, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   26a90:	4295      	cmp	r5, r2
   26a92:	d100      	bne.n	26a96 <gpio_nrfx_manage_callback+0x5a>
	list->tail = node;
   26a94:	6063      	str	r3, [r4, #4]
	parent->next = child;
   26a96:	2300      	movs	r3, #0
   26a98:	602b      	str	r3, [r5, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
   26a9a:	b976      	cbnz	r6, 26aba <gpio_nrfx_manage_callback+0x7e>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
   26a9c:	2000      	movs	r0, #0
				     callback, set);
}
   26a9e:	bd70      	pop	{r4, r5, r6, pc}
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   26aa0:	460b      	mov	r3, r1
   26aa2:	e7ef      	b.n	26a84 <gpio_nrfx_manage_callback+0x48>
	parent->next = child;
   26aa4:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   26aa6:	6863      	ldr	r3, [r4, #4]
   26aa8:	429d      	cmp	r5, r3
	list->tail = node;
   26aaa:	bf08      	it	eq
   26aac:	6062      	streq	r2, [r4, #4]
   26aae:	e7f2      	b.n	26a96 <gpio_nrfx_manage_callback+0x5a>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   26ab0:	6819      	ldr	r1, [r3, #0]
	return node->next;
   26ab2:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   26ab4:	2900      	cmp	r1, #0
   26ab6:	d1f3      	bne.n	26aa0 <gpio_nrfx_manage_callback+0x64>
			if (!set) {
   26ab8:	b13e      	cbz	r6, 26aca <gpio_nrfx_manage_callback+0x8e>
Z_GENLIST_PREPEND(slist, snode)
   26aba:	6823      	ldr	r3, [r4, #0]
	parent->next = child;
   26abc:	602b      	str	r3, [r5, #0]
Z_GENLIST_PREPEND(slist, snode)
   26abe:	6860      	ldr	r0, [r4, #4]
	list->head = node;
   26ac0:	6025      	str	r5, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
   26ac2:	2800      	cmp	r0, #0
   26ac4:	d1ea      	bne.n	26a9c <gpio_nrfx_manage_callback+0x60>
	list->tail = node;
   26ac6:	6065      	str	r5, [r4, #4]
   26ac8:	e7e9      	b.n	26a9e <gpio_nrfx_manage_callback+0x62>
				return -EINVAL;
   26aca:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   26ace:	e7e6      	b.n	26a9e <gpio_nrfx_manage_callback+0x62>
   26ad0:	0003bc00 	.word	0x0003bc00
   26ad4:	0003dcb1 	.word	0x0003dcb1
   26ad8:	0003baac 	.word	0x0003baac
   26adc:	0003dcde 	.word	0x0003dcde
   26ae0:	0003dced 	.word	0x0003dced
   26ae4:	0003dcff 	.word	0x0003dcff

00026ae8 <nrf_gpio_pin_port_decode.isra.8.part.9>:
 *
 * @param[in,out] p_pin Pointer to the absolute pin number overriden by the pin number that is relative to the port.
 *
 * @return Pointer to port register set.
 */
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   26ae8:	b508      	push	{r3, lr}
{
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   26aea:	4a03      	ldr	r2, [pc, #12]	; (26af8 <nrf_gpio_pin_port_decode.isra.8.part.9+0x10>)
   26aec:	4b03      	ldr	r3, [pc, #12]	; (26afc <nrf_gpio_pin_port_decode.isra.8.part.9+0x14>)
   26aee:	f240 11ff 	movw	r1, #511	; 0x1ff
   26af2:	4803      	ldr	r0, [pc, #12]	; (26b00 <nrf_gpio_pin_port_decode.isra.8.part.9+0x18>)
   26af4:	f00e fff0 	bl	35ad8 <__assert_func>
   26af8:	0003dc98 	.word	0x0003dc98
   26afc:	0003dd42 	.word	0x0003dd42
   26b00:	0003dd50 	.word	0x0003dd50

00026b04 <nrf_gpio_cfg_sense_set>:
   26b04:	281f      	cmp	r0, #31
}


NRF_STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t             pin_number,
                                              nrf_gpio_pin_sense_t sense_config)
{
   26b06:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   26b08:	d901      	bls.n	26b0e <nrf_gpio_cfg_sense_set+0xa>
   26b0a:	f7ff ffed 	bl	26ae8 <nrf_gpio_pin_port_decode.isra.8.part.9>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
   26b0e:	4a06      	ldr	r2, [pc, #24]	; (26b28 <nrf_gpio_cfg_sense_set+0x24>)
   26b10:	eb02 0080 	add.w	r0, r2, r0, lsl #2
   26b14:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
   26b18:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000

    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   26b1c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   26b20:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
}
   26b24:	bd08      	pop	{r3, pc}
   26b26:	bf00      	nop
   26b28:	40842500 	.word	0x40842500

00026b2c <gpio_nrfx_init>:
#endif
	}
}

static int gpio_nrfx_init(struct device *port)
{
   26b2c:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
   26b2e:	4b09      	ldr	r3, [pc, #36]	; (26b54 <gpio_nrfx_init+0x28>)
   26b30:	781a      	ldrb	r2, [r3, #0]
   26b32:	b96a      	cbnz	r2, 26b50 <gpio_nrfx_init+0x24>
		gpio_initialized = true;
   26b34:	2101      	movs	r1, #1
		IRQ_CONNECT(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0,
   26b36:	2031      	movs	r0, #49	; 0x31
		gpio_initialized = true;
   26b38:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0,
   26b3a:	2105      	movs	r1, #5
   26b3c:	f7fe fa58 	bl	24ff0 <z_arm_irq_priority_set>
			    DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0_PRIORITY,
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0);
   26b40:	2031      	movs	r0, #49	; 0x31
   26b42:	f7fe fa45 	bl	24fd0 <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   26b46:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   26b4a:	4b03      	ldr	r3, [pc, #12]	; (26b58 <gpio_nrfx_init+0x2c>)
   26b4c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
   26b50:	2000      	movs	r0, #0
   26b52:	bd08      	pop	{r3, pc}
   26b54:	2002511c 	.word	0x2002511c
   26b58:	40031000 	.word	0x40031000

00026b5c <gpiote_pin_int_cfg>:
{
   26b5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return port->config->config_info;
   26b60:	6803      	ldr	r3, [r0, #0]
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   26b62:	f001 041f 	and.w	r4, r1, #31
   26b66:	689b      	ldr	r3, [r3, #8]
{
   26b68:	460d      	mov	r5, r1
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   26b6a:	791b      	ldrb	r3, [r3, #4]
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
   26b6c:	4e4b      	ldr	r6, [pc, #300]	; (26c9c <gpiote_pin_int_cfg+0x140>)
   26b6e:	ea44 1443 	orr.w	r4, r4, r3, lsl #5
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   26b72:	2300      	movs	r3, #0
   26b74:	f8d6 2304 	ldr.w	r2, [r6, #772]	; 0x304
	struct gpio_nrfx_data *data = get_port_data(port);
   26b78:	6887      	ldr	r7, [r0, #8]
   26b7a:	b2d2      	uxtb	r2, r2
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   26b7c:	f503 71a2 	add.w	r1, r3, #324	; 0x144
   26b80:	f856 1021 	ldr.w	r1, [r6, r1, lsl #2]
   26b84:	f3c1 2104 	ubfx	r1, r1, #8, #5
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
   26b88:	428c      	cmp	r4, r1
   26b8a:	d16c      	bne.n	26c66 <gpiote_pin_int_cfg+0x10a>
		    && (intenset & BIT(i))) {
   26b8c:	fa22 f103 	lsr.w	r1, r2, r3
   26b90:	07c9      	lsls	r1, r1, #31
   26b92:	d568      	bpl.n	26c66 <gpiote_pin_int_cfg+0x10a>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
   26b94:	009a      	lsls	r2, r3, #2
   26b96:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   26b9a:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   26b9e:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
   26ba2:	f021 0101 	bic.w	r1, r1, #1
   26ba6:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
   26baa:	2201      	movs	r2, #1
   26bac:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENCLR = mask;
   26bb0:	f8c6 3308 	str.w	r3, [r6, #776]	; 0x308
	nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   26bb4:	4620      	mov	r0, r4
   26bb6:	2100      	movs	r1, #0
   26bb8:	f7ff ffa4 	bl	26b04 <nrf_gpio_cfg_sense_set>
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
   26bbc:	68b8      	ldr	r0, [r7, #8]
   26bbe:	40e8      	lsrs	r0, r5
   26bc0:	f010 0001 	ands.w	r0, r0, #1
   26bc4:	d04d      	beq.n	26c62 <gpiote_pin_int_cfg+0x106>
   26bc6:	68f8      	ldr	r0, [r7, #12]
   26bc8:	40e8      	lsrs	r0, r5
   26bca:	f010 0001 	ands.w	r0, r0, #1
   26bce:	d048      	beq.n	26c62 <gpiote_pin_int_cfg+0x106>
		if (data->trig_edge & BIT(pin)) {
   26bd0:	6978      	ldr	r0, [r7, #20]
   26bd2:	40e8      	lsrs	r0, r5
   26bd4:	f010 0801 	ands.w	r8, r0, #1
   26bd8:	d051      	beq.n	26c7e <gpiote_pin_int_cfg+0x122>
			if (data->double_edge & BIT(pin)) {
   26bda:	69bb      	ldr	r3, [r7, #24]
   26bdc:	40eb      	lsrs	r3, r5
   26bde:	07db      	lsls	r3, r3, #31
   26be0:	d445      	bmi.n	26c6e <gpiote_pin_int_cfg+0x112>
			} else if (((data->active_level & BIT(pin)) != 0U)
   26be2:	693b      	ldr	r3, [r7, #16]
				   ^ ((BIT(pin) & data->inverted) != 0)) {
   26be4:	69fa      	ldr	r2, [r7, #28]
			} else if (((data->active_level & BIT(pin)) != 0U)
   26be6:	40eb      	lsrs	r3, r5
				   ^ ((BIT(pin) & data->inverted) != 0)) {
   26be8:	fa22 f505 	lsr.w	r5, r2, r5
			} else if (((data->active_level & BIT(pin)) != 0U)
   26bec:	f003 0301 	and.w	r3, r3, #1
   26bf0:	f005 0501 	and.w	r5, r5, #1
				pol = NRF_GPIOTE_POLARITY_HITOLO;
   26bf4:	42ab      	cmp	r3, r5
   26bf6:	bf14      	ite	ne
   26bf8:	2501      	movne	r5, #1
   26bfa:	2502      	moveq	r5, #2
   26bfc:	2100      	movs	r1, #0
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
   26bfe:	f501 73a2 	add.w	r3, r1, #324	; 0x144
   26c02:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
   26c06:	f010 0003 	ands.w	r0, r0, #3
   26c0a:	d132      	bne.n	26c72 <gpiote_pin_int_cfg+0x116>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   26c0c:	008b      	lsls	r3, r1, #2
   26c0e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   26c12:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   26c16:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   26c1a:	0224      	lsls	r4, r4, #8
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   26c1c:	f422 3247 	bic.w	r2, r2, #203776	; 0x31c00
   26c20:	f422 7240 	bic.w	r2, r2, #768	; 0x300
   26c24:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   26c28:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   26c2c:	f404 54f8 	and.w	r4, r4, #7936	; 0x1f00
   26c30:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
   26c34:	4315      	orrs	r5, r2
			nrf_gpiote_event_t evt =
   26c36:	f101 0240 	add.w	r2, r1, #64	; 0x40
   26c3a:	0092      	lsls	r2, r2, #2
    return ((uint32_t)p_reg + event);
   26c3c:	b292      	uxth	r2, r2
   26c3e:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   26c42:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   26c46:	f8c3 5510 	str.w	r5, [r3, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   26c4a:	6010      	str	r0, [r2, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   26c4c:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   26c50:	f042 0201 	orr.w	r2, r2, #1
   26c54:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
   26c58:	2301      	movs	r3, #1
   26c5a:	fa03 f101 	lsl.w	r1, r3, r1
    p_reg->INTENSET = mask;
   26c5e:	f8c6 1304 	str.w	r1, [r6, #772]	; 0x304
}
   26c62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   26c66:	3301      	adds	r3, #1
   26c68:	2b08      	cmp	r3, #8
   26c6a:	d187      	bne.n	26b7c <gpiote_pin_int_cfg+0x20>
   26c6c:	e7a2      	b.n	26bb4 <gpiote_pin_int_cfg+0x58>
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
   26c6e:	2503      	movs	r5, #3
   26c70:	e7c4      	b.n	26bfc <gpiote_pin_int_cfg+0xa0>
   26c72:	3101      	adds	r1, #1
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
   26c74:	2908      	cmp	r1, #8
   26c76:	d1c2      	bne.n	26bfe <gpiote_pin_int_cfg+0xa2>
	return -ENODEV;
   26c78:	f06f 0012 	mvn.w	r0, #18
   26c7c:	e7f1      	b.n	26c62 <gpiote_pin_int_cfg+0x106>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   26c7e:	693b      	ldr	r3, [r7, #16]
   26c80:	69fa      	ldr	r2, [r7, #28]
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   26c82:	4620      	mov	r0, r4
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   26c84:	4053      	eors	r3, r2
   26c86:	fa23 f505 	lsr.w	r5, r3, r5
		return NRF_GPIO_PIN_SENSE_HIGH;
   26c8a:	f015 0f01 	tst.w	r5, #1
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   26c8e:	bf0c      	ite	eq
   26c90:	2103      	moveq	r1, #3
   26c92:	2102      	movne	r1, #2
   26c94:	f7ff ff36 	bl	26b04 <nrf_gpio_cfg_sense_set>
	int res = 0;
   26c98:	4640      	mov	r0, r8
   26c9a:	e7e2      	b.n	26c62 <gpiote_pin_int_cfg+0x106>
   26c9c:	40031000 	.word	0x40031000

00026ca0 <gpio_nrfx_config>:
{
   26ca0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   26ca4:	4680      	mov	r8, r0
	struct gpio_nrfx_data *data = get_port_data(port);
   26ca6:	6885      	ldr	r5, [r0, #8]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   26ca8:	f403 4070 	and.w	r0, r3, #61440	; 0xf000
   26cac:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
{
   26cb0:	461e      	mov	r6, r3
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   26cb2:	d040      	beq.n	26d36 <gpio_nrfx_config+0x96>
   26cb4:	dc09      	bgt.n	26cca <gpio_nrfx_config+0x2a>
   26cb6:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   26cba:	d03e      	beq.n	26d3a <gpio_nrfx_config+0x9a>
   26cbc:	f5b0 5f40 	cmp.w	r0, #12288	; 0x3000
   26cc0:	d03d      	beq.n	26d3e <gpio_nrfx_config+0x9e>
   26cc2:	b190      	cbz	r0, 26cea <gpio_nrfx_config+0x4a>
		return -EINVAL;
   26cc4:	f06f 0015 	mvn.w	r0, #21
   26cc8:	e032      	b.n	26d30 <gpio_nrfx_config+0x90>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   26cca:	f5b0 4fe0 	cmp.w	r0, #28672	; 0x7000
   26cce:	d038      	beq.n	26d42 <gpio_nrfx_config+0xa2>
   26cd0:	dc04      	bgt.n	26cdc <gpio_nrfx_config+0x3c>
   26cd2:	f5b0 4fa0 	cmp.w	r0, #20480	; 0x5000
   26cd6:	d1f5      	bne.n	26cc4 <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0H1;
   26cd8:	2003      	movs	r0, #3
   26cda:	e006      	b.n	26cea <gpio_nrfx_config+0x4a>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   26cdc:	f5b0 4f40 	cmp.w	r0, #49152	; 0xc000
   26ce0:	d031      	beq.n	26d46 <gpio_nrfx_config+0xa6>
   26ce2:	f5b0 4f50 	cmp.w	r0, #53248	; 0xd000
   26ce6:	d1ed      	bne.n	26cc4 <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0D1;
   26ce8:	2007      	movs	r0, #7
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
   26cea:	f406 7740 	and.w	r7, r6, #768	; 0x300
   26cee:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
   26cf2:	d02a      	beq.n	26d4a <gpio_nrfx_config+0xaa>
		pull = NRF_GPIO_PIN_NOPULL;
   26cf4:	f5a7 7400 	sub.w	r4, r7, #512	; 0x200
   26cf8:	4263      	negs	r3, r4
   26cfa:	4163      	adcs	r3, r4
	if (access_op == GPIO_ACCESS_BY_PORT) {
   26cfc:	2901      	cmp	r1, #1
		from_pin = pin;
   26cfe:	bf19      	ittee	ne
   26d00:	b2d4      	uxtbne	r4, r2
		to_pin   = pin;
   26d02:	46a1      	movne	r9, r4
		to_pin   = 31U;
   26d04:	f04f 091f 	moveq.w	r9, #31
		from_pin = 0U;
   26d08:	2400      	moveq	r4, #0
   26d0a:	f04f 0b01 	mov.w	fp, #1
	dir = ((flags & GPIO_DIR_MASK) == GPIO_DIR_OUT)
   26d0e:	f006 0c01 	and.w	ip, r6, #1
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
   26d12:	ea4f 074c 	mov.w	r7, ip, lsl #1
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   26d16:	ea47 070c 	orr.w	r7, r7, ip
   26d1a:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   26d1e:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 26dc8 <gpio_nrfx_config+0x128>
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   26d22:	ea40 0783 	orr.w	r7, r0, r3, lsl #2
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   26d26:	f006 0302 	and.w	r3, r6, #2
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   26d2a:	45a1      	cmp	r9, r4
   26d2c:	d20f      	bcs.n	26d4e <gpio_nrfx_config+0xae>
	return 0;
   26d2e:	2000      	movs	r0, #0
}
   26d30:	b003      	add	sp, #12
   26d32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		drive = NRF_GPIO_PIN_S0H1;
   26d36:	2002      	movs	r0, #2
   26d38:	e7d7      	b.n	26cea <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_H0S1;
   26d3a:	2001      	movs	r0, #1
   26d3c:	e7d5      	b.n	26cea <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0S1;
   26d3e:	2004      	movs	r0, #4
   26d40:	e7d3      	b.n	26cea <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0H1;
   26d42:	2005      	movs	r0, #5
   26d44:	e7d1      	b.n	26cea <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_S0D1;
   26d46:	2006      	movs	r0, #6
   26d48:	e7cf      	b.n	26cea <gpio_nrfx_config+0x4a>
		pull = NRF_GPIO_PIN_PULLUP;
   26d4a:	2303      	movs	r3, #3
   26d4c:	e7d6      	b.n	26cfc <gpio_nrfx_config+0x5c>
	return port->config->config_info;
   26d4e:	f8d8 2000 	ldr.w	r2, [r8]
		nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num,
   26d52:	6892      	ldr	r2, [r2, #8]
   26d54:	7911      	ldrb	r1, [r2, #4]
   26d56:	f004 021f 	and.w	r2, r4, #31
   26d5a:	ea42 1241 	orr.w	r2, r2, r1, lsl #5
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   26d5e:	2a1f      	cmp	r2, #31
   26d60:	dd01      	ble.n	26d66 <gpio_nrfx_config+0xc6>
   26d62:	f7ff fec1 	bl	26ae8 <nrf_gpio_pin_port_decode.isra.8.part.9>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   26d66:	3280      	adds	r2, #128	; 0x80
   26d68:	f84a 7022 	str.w	r7, [sl, r2, lsl #2]
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   26d6c:	68a9      	ldr	r1, [r5, #8]
   26d6e:	fa0b f204 	lsl.w	r2, fp, r4
   26d72:	2b00      	cmp	r3, #0
   26d74:	d025      	beq.n	26dc2 <gpio_nrfx_config+0x122>
   26d76:	4311      	orrs	r1, r2
   26d78:	60a9      	str	r1, [r5, #8]
		WRITE_BIT(data->trig_edge, curr_pin, flags & GPIO_INT_EDGE);
   26d7a:	6969      	ldr	r1, [r5, #20]
   26d7c:	06b0      	lsls	r0, r6, #26
   26d7e:	bf4c      	ite	mi
   26d80:	4311      	orrmi	r1, r2
   26d82:	4391      	bicpl	r1, r2
   26d84:	6169      	str	r1, [r5, #20]
		WRITE_BIT(data->double_edge, curr_pin,
   26d86:	69a9      	ldr	r1, [r5, #24]
   26d88:	0670      	lsls	r0, r6, #25
   26d8a:	bf4c      	ite	mi
   26d8c:	4311      	orrmi	r1, r2
   26d8e:	4391      	bicpl	r1, r2
   26d90:	61a9      	str	r1, [r5, #24]
		WRITE_BIT(data->active_level, curr_pin,
   26d92:	6929      	ldr	r1, [r5, #16]
   26d94:	0770      	lsls	r0, r6, #29
   26d96:	bf4c      	ite	mi
   26d98:	4311      	orrmi	r1, r2
   26d9a:	4391      	bicpl	r1, r2
   26d9c:	6129      	str	r1, [r5, #16]
		WRITE_BIT(data->inverted, curr_pin, flags & GPIO_POL_INV);
   26d9e:	69e9      	ldr	r1, [r5, #28]
   26da0:	0630      	lsls	r0, r6, #24
   26da2:	bf4c      	ite	mi
   26da4:	430a      	orrmi	r2, r1
   26da6:	ea21 0202 	bicpl.w	r2, r1, r2
   26daa:	61ea      	str	r2, [r5, #28]
		res = gpiote_pin_int_cfg(port, curr_pin);
   26dac:	4621      	mov	r1, r4
   26dae:	4640      	mov	r0, r8
   26db0:	9301      	str	r3, [sp, #4]
   26db2:	f7ff fed3 	bl	26b5c <gpiote_pin_int_cfg>
		if (res != 0) {
   26db6:	2800      	cmp	r0, #0
   26db8:	d1ba      	bne.n	26d30 <gpio_nrfx_config+0x90>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   26dba:	3401      	adds	r4, #1
   26dbc:	b2e4      	uxtb	r4, r4
   26dbe:	9b01      	ldr	r3, [sp, #4]
   26dc0:	e7b3      	b.n	26d2a <gpio_nrfx_config+0x8a>
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   26dc2:	ea21 0102 	bic.w	r1, r1, r2
   26dc6:	e7d7      	b.n	26d78 <gpio_nrfx_config+0xd8>
   26dc8:	40842500 	.word	0x40842500

00026dcc <gpiote_event_handler>:
{
   26dcc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   26dd0:	4b56      	ldr	r3, [pc, #344]	; (26f2c <gpiote_event_handler+0x160>)
   26dd2:	681e      	ldr	r6, [r3, #0]
	if (port_event) {
   26dd4:	4698      	mov	r8, r3
   26dd6:	2e00      	cmp	r6, #0
   26dd8:	d05e      	beq.n	26e98 <gpiote_event_handler+0xcc>
	u32_t bit = 1U << pin;
   26dda:	2701      	movs	r7, #1
	u32_t pin = 0U;
   26ddc:	f04f 0a00 	mov.w	sl, #0
	struct gpio_nrfx_data *data = get_port_data(port);
   26de0:	4a53      	ldr	r2, [pc, #332]	; (26f30 <gpiote_event_handler+0x164>)
   26de2:	6893      	ldr	r3, [r2, #8]
	return port->config->config_info;
   26de4:	6812      	ldr	r2, [r2, #0]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
   26de6:	69dc      	ldr	r4, [r3, #28]
	return port->config->config_info;
   26de8:	f8d2 9008 	ldr.w	r9, [r2, #8]
	u32_t out = data->int_en & data->pin_int_en;
   26dec:	e9d3 2502 	ldrd	r2, r5, [r3, #8]
   26df0:	4015      	ands	r5, r2
	out &= ~data->trig_edge & ~data->double_edge;
   26df2:	e9d3 2105 	ldrd	r2, r1, [r3, #20]
   26df6:	430a      	orrs	r2, r1
   26df8:	ea25 0502 	bic.w	r5, r5, r2
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
   26dfc:	f8d9 2000 	ldr.w	r2, [r9]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
   26e00:	691b      	ldr	r3, [r3, #16]
}


NRF_STATIC_INLINE uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const * p_reg)
{
    return p_reg->IN;
   26e02:	6912      	ldr	r2, [r2, #16]
   26e04:	405c      	eors	r4, r3
   26e06:	4054      	eors	r4, r2
	u32_t out = pin_states & level_pins;
   26e08:	ea25 0404 	bic.w	r4, r5, r4
	while (level_pins) {
   26e0c:	bb9d      	cbnz	r5, 26e76 <gpiote_event_handler+0xaa>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   26e0e:	f8c8 5000 	str.w	r5, [r8]
	u32_t fired_triggers[GPIO_COUNT] = {0};
   26e12:	2300      	movs	r3, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
   26e14:	2001      	movs	r0, #1
   26e16:	461f      	mov	r7, r3
    return p_reg->INTENSET & mask;
   26e18:	4946      	ldr	r1, [pc, #280]	; (26f34 <gpiote_event_handler+0x168>)
   26e1a:	4d47      	ldr	r5, [pc, #284]	; (26f38 <gpiote_event_handler+0x16c>)
   26e1c:	f8d1 2304 	ldr.w	r2, [r1, #772]	; 0x304
   26e20:	fa00 fc03 	lsl.w	ip, r0, r3
   26e24:	ea1c 0f02 	tst.w	ip, r2
   26e28:	d00d      	beq.n	26e46 <gpiote_event_handler+0x7a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   26e2a:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
   26e2e:	b152      	cbz	r2, 26e46 <gpiote_event_handler+0x7a>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   26e30:	f503 72a2 	add.w	r2, r3, #324	; 0x144
   26e34:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   26e38:	f845 7023 	str.w	r7, [r5, r3, lsl #2]
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   26e3c:	f3c2 2204 	ubfx	r2, r2, #8, #5
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
   26e40:	fa00 f202 	lsl.w	r2, r0, r2
   26e44:	4314      	orrs	r4, r2
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   26e46:	3301      	adds	r3, #1
   26e48:	2b08      	cmp	r3, #8
   26e4a:	d1e7      	bne.n	26e1c <gpiote_event_handler+0x50>
	if (fired_triggers[0]) {
   26e4c:	bb34      	cbnz	r4, 26e9c <gpiote_event_handler+0xd0>
	if (port_event) {
   26e4e:	b186      	cbz	r6, 26e72 <gpiote_event_handler+0xa6>
	u32_t bit = 1U << pin;
   26e50:	2701      	movs	r7, #1
	u32_t pin = 0U;
   26e52:	f04f 0800 	mov.w	r8, #0
	const struct gpio_nrfx_data *data = get_port_data(port);
   26e56:	4b36      	ldr	r3, [pc, #216]	; (26f30 <gpiote_event_handler+0x164>)
   26e58:	689d      	ldr	r5, [r3, #8]
	return port->config->config_info;
   26e5a:	681b      	ldr	r3, [r3, #0]
   26e5c:	689e      	ldr	r6, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
   26e5e:	e9d5 3402 	ldrd	r3, r4, [r5, #8]
   26e62:	401c      	ands	r4, r3
	out &= ~data->trig_edge & ~data->double_edge;
   26e64:	e9d5 3205 	ldrd	r3, r2, [r5, #20]
   26e68:	4313      	orrs	r3, r2
   26e6a:	ea24 0403 	bic.w	r4, r4, r3
	while (level_pins) {
   26e6e:	2c00      	cmp	r4, #0
   26e70:	d142      	bne.n	26ef8 <gpiote_event_handler+0x12c>
}
   26e72:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (level_pins & bit) {
   26e76:	423d      	tst	r5, r7
   26e78:	d00a      	beq.n	26e90 <gpiote_event_handler+0xc4>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   26e7a:	f899 3004 	ldrb.w	r3, [r9, #4]
   26e7e:	f00a 001f 	and.w	r0, sl, #31
			nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   26e82:	2100      	movs	r1, #0
   26e84:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
   26e88:	f7ff fe3c 	bl	26b04 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   26e8c:	ea25 0507 	bic.w	r5, r5, r7
		++pin;
   26e90:	f10a 0a01 	add.w	sl, sl, #1
		bit <<= 1;
   26e94:	007f      	lsls	r7, r7, #1
   26e96:	e7b9      	b.n	26e0c <gpiote_event_handler+0x40>
	u32_t fired_triggers[GPIO_COUNT] = {0};
   26e98:	4634      	mov	r4, r6
   26e9a:	e7ba      	b.n	26e12 <gpiote_event_handler+0x46>
	struct gpio_nrfx_data *data = get_port_data(port);
   26e9c:	4b24      	ldr	r3, [pc, #144]	; (26f30 <gpiote_event_handler+0x164>)
   26e9e:	f8d3 9008 	ldr.w	r9, [r3, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   26ea2:	f8d9 5000 	ldr.w	r5, [r9]
   26ea6:	2d00      	cmp	r5, #0
   26ea8:	d0d1      	beq.n	26e4e <gpiote_event_handler+0x82>
			cb->handler(port, cb, pins);
   26eaa:	4698      	mov	r8, r3
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   26eac:	682f      	ldr	r7, [r5, #0]
			__ASSERT(cb->handler, "No callback handler!");
   26eae:	f8df a094 	ldr.w	sl, [pc, #148]	; 26f44 <gpiote_event_handler+0x178>
   26eb2:	f8df b094 	ldr.w	fp, [pc, #148]	; 26f48 <gpiote_event_handler+0x17c>
		if ((cb->pin_mask & pins) & data->int_en) {
   26eb6:	f8d9 300c 	ldr.w	r3, [r9, #12]
   26eba:	68aa      	ldr	r2, [r5, #8]
   26ebc:	4023      	ands	r3, r4
   26ebe:	4213      	tst	r3, r2
   26ec0:	d015      	beq.n	26eee <gpiote_event_handler+0x122>
			__ASSERT(cb->handler, "No callback handler!");
   26ec2:	686b      	ldr	r3, [r5, #4]
   26ec4:	b973      	cbnz	r3, 26ee4 <gpiote_event_handler+0x118>
   26ec6:	4659      	mov	r1, fp
   26ec8:	f44f 73d2 	mov.w	r3, #420	; 0x1a4
   26ecc:	4652      	mov	r2, sl
   26ece:	481b      	ldr	r0, [pc, #108]	; (26f3c <gpiote_event_handler+0x170>)
   26ed0:	f010 fef6 	bl	37cc0 <printk>
   26ed4:	481a      	ldr	r0, [pc, #104]	; (26f40 <gpiote_event_handler+0x174>)
   26ed6:	f010 fef3 	bl	37cc0 <printk>
   26eda:	f44f 71d2 	mov.w	r1, #420	; 0x1a4
   26ede:	4650      	mov	r0, sl
   26ee0:	f010 ff34 	bl	37d4c <assert_post_action>
			cb->handler(port, cb, pins);
   26ee4:	686b      	ldr	r3, [r5, #4]
   26ee6:	4622      	mov	r2, r4
   26ee8:	4629      	mov	r1, r5
   26eea:	4640      	mov	r0, r8
   26eec:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   26eee:	2f00      	cmp	r7, #0
   26ef0:	d0ad      	beq.n	26e4e <gpiote_event_handler+0x82>
   26ef2:	463d      	mov	r5, r7
   26ef4:	683f      	ldr	r7, [r7, #0]
   26ef6:	e7de      	b.n	26eb6 <gpiote_event_handler+0xea>
		if (level_pins & bit) {
   26ef8:	4227      	tst	r7, r4
   26efa:	d013      	beq.n	26f24 <gpiote_event_handler+0x158>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   26efc:	692b      	ldr	r3, [r5, #16]
   26efe:	69ea      	ldr	r2, [r5, #28]
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   26f00:	f896 c004 	ldrb.w	ip, [r6, #4]
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   26f04:	4053      	eors	r3, r2
   26f06:	fa23 f308 	lsr.w	r3, r3, r8
		return NRF_GPIO_PIN_SENSE_HIGH;
   26f0a:	f013 0f01 	tst.w	r3, #1
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   26f0e:	f008 001f 	and.w	r0, r8, #31
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   26f12:	bf0c      	ite	eq
   26f14:	2103      	moveq	r1, #3
   26f16:	2102      	movne	r1, #2
   26f18:	ea40 104c 	orr.w	r0, r0, ip, lsl #5
   26f1c:	f7ff fdf2 	bl	26b04 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   26f20:	ea24 0407 	bic.w	r4, r4, r7
		++pin;
   26f24:	f108 0801 	add.w	r8, r8, #1
		bit <<= 1;
   26f28:	007f      	lsls	r7, r7, #1
   26f2a:	e7a0      	b.n	26e6e <gpiote_event_handler+0xa2>
   26f2c:	4003117c 	.word	0x4003117c
   26f30:	2002cac4 	.word	0x2002cac4
   26f34:	40031000 	.word	0x40031000
   26f38:	40031100 	.word	0x40031100
   26f3c:	0003baac 	.word	0x0003baac
   26f40:	0003dcff 	.word	0x0003dcff
   26f44:	0003dd16 	.word	0x0003dd16
   26f48:	0003e93f 	.word	0x0003e93f

00026f4c <twim_1_init>:
#ifdef CONFIG_I2C_0_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(0);
#endif

#ifdef CONFIG_I2C_1_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(1);
   26f4c:	b510      	push	{r4, lr}
   26f4e:	4604      	mov	r4, r0
   26f50:	2200      	movs	r2, #0
   26f52:	2101      	movs	r1, #1
   26f54:	2009      	movs	r0, #9
   26f56:	f7fe f84b 	bl	24ff0 <z_arm_irq_priority_set>
	return dev->config->config_info;
   26f5a:	6823      	ldr	r3, [r4, #0]
	nrfx_err_t result = nrfx_twim_init(&get_dev_config(dev)->twim,
   26f5c:	4a0f      	ldr	r2, [pc, #60]	; (26f9c <twim_1_init+0x50>)
	return dev->config->config_info;
   26f5e:	6898      	ldr	r0, [r3, #8]
	nrfx_err_t result = nrfx_twim_init(&get_dev_config(dev)->twim,
   26f60:	4623      	mov	r3, r4
   26f62:	f100 0108 	add.w	r1, r0, #8
   26f66:	f00a fec7 	bl	31cf8 <nrfx_twim_init>
	if (result != NRFX_SUCCESS) {
   26f6a:	4b0d      	ldr	r3, [pc, #52]	; (26fa0 <twim_1_init+0x54>)
   26f6c:	4298      	cmp	r0, r3
   26f6e:	d012      	beq.n	26f96 <twim_1_init+0x4a>
		LOG_ERR("Failed to initialize device: %s",
   26f70:	2301      	movs	r3, #1
   26f72:	f04f 0000 	mov.w	r0, #0
   26f76:	4a0b      	ldr	r2, [pc, #44]	; (26fa4 <twim_1_init+0x58>)
   26f78:	f363 0007 	bfi	r0, r3, #0, #8
   26f7c:	4b0a      	ldr	r3, [pc, #40]	; (26fa8 <twim_1_init+0x5c>)
   26f7e:	490b      	ldr	r1, [pc, #44]	; (26fac <twim_1_init+0x60>)
   26f80:	1a9b      	subs	r3, r3, r2
   26f82:	08db      	lsrs	r3, r3, #3
   26f84:	f363 108f 	bfi	r0, r3, #6, #10
   26f88:	6823      	ldr	r3, [r4, #0]
   26f8a:	681a      	ldr	r2, [r3, #0]
   26f8c:	f010 feef 	bl	37d6e <log_string_sync>
		return -EBUSY;
   26f90:	f06f 000f 	mvn.w	r0, #15
I2C_NRFX_TWIM_DEVICE(1);
   26f94:	bd10      	pop	{r4, pc}
	return 0;
   26f96:	2000      	movs	r0, #0
I2C_NRFX_TWIM_DEVICE(1);
   26f98:	e7fc      	b.n	26f94 <twim_1_init+0x48>
   26f9a:	bf00      	nop
   26f9c:	000270fd 	.word	0x000270fd
   26fa0:	0bad0000 	.word	0x0bad0000
   26fa4:	0003ade0 	.word	0x0003ade0
   26fa8:	0003ae50 	.word	0x0003ae50
   26fac:	0003ddc4 	.word	0x0003ddc4

00026fb0 <i2c_nrfx_twim_configure>:
{
   26fb0:	b508      	push	{r3, lr}
	return dev->config->config_info;
   26fb2:	6803      	ldr	r3, [r0, #0]
	if (I2C_ADDR_10_BITS & dev_config) {
   26fb4:	07ca      	lsls	r2, r1, #31
	return dev->config->config_info;
   26fb6:	689b      	ldr	r3, [r3, #8]
	if (I2C_ADDR_10_BITS & dev_config) {
   26fb8:	d413      	bmi.n	26fe2 <i2c_nrfx_twim_configure+0x32>
	switch (I2C_SPEED_GET(dev_config)) {
   26fba:	f3c1 0242 	ubfx	r2, r1, #1, #3
   26fbe:	2a01      	cmp	r2, #1
   26fc0:	d012      	beq.n	26fe8 <i2c_nrfx_twim_configure+0x38>
   26fc2:	2a02      	cmp	r2, #2
   26fc4:	d019      	beq.n	26ffa <i2c_nrfx_twim_configure+0x4a>
		LOG_ERR("unsupported speed");
   26fc6:	2301      	movs	r3, #1
   26fc8:	f04f 0000 	mov.w	r0, #0
   26fcc:	4a0d      	ldr	r2, [pc, #52]	; (27004 <i2c_nrfx_twim_configure+0x54>)
   26fce:	f363 0007 	bfi	r0, r3, #0, #8
   26fd2:	4b0d      	ldr	r3, [pc, #52]	; (27008 <i2c_nrfx_twim_configure+0x58>)
   26fd4:	490d      	ldr	r1, [pc, #52]	; (2700c <i2c_nrfx_twim_configure+0x5c>)
   26fd6:	1a9b      	subs	r3, r3, r2
   26fd8:	08db      	lsrs	r3, r3, #3
   26fda:	f363 108f 	bfi	r0, r3, #6, #10
   26fde:	f010 fec6 	bl	37d6e <log_string_sync>
		return -EINVAL;
   26fe2:	f06f 0015 	mvn.w	r0, #21
   26fe6:	e007      	b.n	26ff8 <i2c_nrfx_twim_configure+0x48>
}

NRF_STATIC_INLINE void nrf_twim_frequency_set(NRF_TWIM_Type * p_reg,
                                              nrf_twim_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
   26fe8:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
		nrf_twim_frequency_set(inst->p_twim, NRF_TWIM_FREQ_100K);
   26fec:	681b      	ldr	r3, [r3, #0]
   26fee:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	get_dev_data(dev)->dev_config = dev_config;
   26ff2:	6883      	ldr	r3, [r0, #8]
	return 0;
   26ff4:	2000      	movs	r0, #0
	get_dev_data(dev)->dev_config = dev_config;
   26ff6:	6359      	str	r1, [r3, #52]	; 0x34
}
   26ff8:	bd08      	pop	{r3, pc}
		nrf_twim_frequency_set(inst->p_twim, NRF_TWIM_FREQ_400K);
   26ffa:	681b      	ldr	r3, [r3, #0]
   26ffc:	f04f 62c8 	mov.w	r2, #104857600	; 0x6400000
   27000:	e7f5      	b.n	26fee <i2c_nrfx_twim_configure+0x3e>
   27002:	bf00      	nop
   27004:	0003ade0 	.word	0x0003ade0
   27008:	0003ae50 	.word	0x0003ae50
   2700c:	0003dd83 	.word	0x0003dd83

00027010 <i2c_nrfx_twim_transfer>:
{
   27010:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27014:	4604      	mov	r4, r0
   27016:	b087      	sub	sp, #28
   27018:	460d      	mov	r5, r1
   2701a:	4691      	mov	r9, r2
   2701c:	469a      	mov	sl, r3
	k_sem_take(&(get_dev_data(dev)->transfer_sync), K_FOREVER);
   2701e:	6880      	ldr	r0, [r0, #8]
	return z_impl_k_sem_take(sem, timeout);
   27020:	f04f 31ff 	mov.w	r1, #4294967295
   27024:	f00d fb5c 	bl	346e0 <z_impl_k_sem_take>
	return dev->config->config_info;
   27028:	6823      	ldr	r3, [r4, #0]
	for (size_t i = 0; i < num_msgs; i++) {
   2702a:	2600      	movs	r6, #0
	nrfx_twim_enable(&get_dev_config(dev)->twim);
   2702c:	6898      	ldr	r0, [r3, #8]
   2702e:	f00a fec3 	bl	31db8 <nrfx_twim_enable>
		if (res != NRFX_SUCCESS) {
   27032:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 270f8 <i2c_nrfx_twim_transfer+0xe8>
   27036:	6823      	ldr	r3, [r4, #0]
	for (size_t i = 0; i < num_msgs; i++) {
   27038:	454e      	cmp	r6, r9
   2703a:	f8d3 b008 	ldr.w	fp, [r3, #8]
   2703e:	d301      	bcc.n	27044 <i2c_nrfx_twim_transfer+0x34>
	int ret = 0;
   27040:	2500      	movs	r5, #0
   27042:	e024      	b.n	2708e <i2c_nrfx_twim_transfer+0x7e>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
   27044:	7a2f      	ldrb	r7, [r5, #8]
   27046:	f017 0108 	ands.w	r1, r7, #8
   2704a:	d14a      	bne.n	270e2 <i2c_nrfx_twim_transfer+0xd2>
		nrfx_twim_xfer_desc_t cur_xfer = {
   2704c:	2212      	movs	r2, #18
   2704e:	f10d 0006 	add.w	r0, sp, #6
   27052:	f012 feb4 	bl	39dbe <memset>
					  NRFX_TWIM_XFER_RX : NRFX_TWIM_XFER_TX
   27056:	f007 0301 	and.w	r3, r7, #1
		nrfx_twim_xfer_desc_t cur_xfer = {
   2705a:	f88d 3004 	strb.w	r3, [sp, #4]
   2705e:	686b      	ldr	r3, [r5, #4]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
   27060:	f017 0f02 	tst.w	r7, #2
		nrfx_twim_xfer_desc_t cur_xfer = {
   27064:	9302      	str	r3, [sp, #8]
   27066:	682b      	ldr	r3, [r5, #0]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
   27068:	bf0c      	ite	eq
   2706a:	2220      	moveq	r2, #32
   2706c:	2200      	movne	r2, #0
   2706e:	a901      	add	r1, sp, #4
   27070:	4658      	mov	r0, fp
		nrfx_twim_xfer_desc_t cur_xfer = {
   27072:	f88d a005 	strb.w	sl, [sp, #5]
   27076:	9304      	str	r3, [sp, #16]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
   27078:	f00a feec 	bl	31e54 <nrfx_twim_xfer>
		if (res != NRFX_SUCCESS) {
   2707c:	4540      	cmp	r0, r8
   2707e:	d011      	beq.n	270a4 <i2c_nrfx_twim_transfer+0x94>
			if (res == NRFX_ERROR_BUSY) {
   27080:	4b19      	ldr	r3, [pc, #100]	; (270e8 <i2c_nrfx_twim_transfer+0xd8>)
				ret = -EIO;
   27082:	4298      	cmp	r0, r3
   27084:	bf0c      	ite	eq
   27086:	f06f 050f 	mvneq.w	r5, #15
   2708a:	f06f 0504 	mvnne.w	r5, #4
	return dev->config->config_info;
   2708e:	6823      	ldr	r3, [r4, #0]
	nrfx_twim_disable(&get_dev_config(dev)->twim);
   27090:	6898      	ldr	r0, [r3, #8]
   27092:	f00a feb3 	bl	31dfc <nrfx_twim_disable>
	k_sem_give(&(get_dev_data(dev)->transfer_sync));
   27096:	68a0      	ldr	r0, [r4, #8]
	z_impl_k_sem_give(sem);
   27098:	f00d fad8 	bl	3464c <z_impl_k_sem_give>
}
   2709c:	4628      	mov	r0, r5
   2709e:	b007      	add	sp, #28
   270a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		k_sem_take(&(get_dev_data(dev)->completion_sync), K_FOREVER);
   270a4:	68a0      	ldr	r0, [r4, #8]
   270a6:	3018      	adds	r0, #24
	return z_impl_k_sem_take(sem, timeout);
   270a8:	f04f 31ff 	mov.w	r1, #4294967295
   270ac:	f00d fb18 	bl	346e0 <z_impl_k_sem_take>
		res = get_dev_data(dev)->res;
   270b0:	68a3      	ldr	r3, [r4, #8]
	return dev->driver_data;
   270b2:	350c      	adds	r5, #12
		res = get_dev_data(dev)->res;
   270b4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
		if (res != NRFX_SUCCESS) {
   270b6:	4542      	cmp	r2, r8
   270b8:	d011      	beq.n	270de <i2c_nrfx_twim_transfer+0xce>
			LOG_ERR("Error %d occurred for message %d", res, i);
   270ba:	2301      	movs	r3, #1
   270bc:	f04f 0000 	mov.w	r0, #0
   270c0:	490a      	ldr	r1, [pc, #40]	; (270ec <i2c_nrfx_twim_transfer+0xdc>)
   270c2:	f363 0007 	bfi	r0, r3, #0, #8
   270c6:	4b0a      	ldr	r3, [pc, #40]	; (270f0 <i2c_nrfx_twim_transfer+0xe0>)
			ret = -EIO;
   270c8:	f06f 0504 	mvn.w	r5, #4
   270cc:	1ac9      	subs	r1, r1, r3
   270ce:	08c9      	lsrs	r1, r1, #3
			LOG_ERR("Error %d occurred for message %d", res, i);
   270d0:	f361 108f 	bfi	r0, r1, #6, #10
   270d4:	4633      	mov	r3, r6
   270d6:	4907      	ldr	r1, [pc, #28]	; (270f4 <i2c_nrfx_twim_transfer+0xe4>)
   270d8:	f010 fe49 	bl	37d6e <log_string_sync>
			break;
   270dc:	e7d7      	b.n	2708e <i2c_nrfx_twim_transfer+0x7e>
	for (size_t i = 0; i < num_msgs; i++) {
   270de:	3601      	adds	r6, #1
   270e0:	e7a9      	b.n	27036 <i2c_nrfx_twim_transfer+0x26>
			ret = -ENOTSUP;
   270e2:	f06f 0585 	mvn.w	r5, #133	; 0x85
   270e6:	e7d2      	b.n	2708e <i2c_nrfx_twim_transfer+0x7e>
   270e8:	0bad000b 	.word	0x0bad000b
   270ec:	0003ae50 	.word	0x0003ae50
   270f0:	0003ade0 	.word	0x0003ade0
   270f4:	0003dd95 	.word	0x0003dd95
   270f8:	0bad0000 	.word	0x0bad0000

000270fc <event_handler>:
	switch (p_event->type) {
   270fc:	7802      	ldrb	r2, [r0, #0]
	struct i2c_nrfx_twim_data *dev_data = get_dev_data(dev);
   270fe:	688b      	ldr	r3, [r1, #8]
	switch (p_event->type) {
   27100:	2a01      	cmp	r2, #1
   27102:	d00a      	beq.n	2711a <event_handler+0x1e>
   27104:	b11a      	cbz	r2, 2710e <event_handler+0x12>
   27106:	2a02      	cmp	r2, #2
   27108:	d009      	beq.n	2711e <event_handler+0x22>
		dev_data->res = NRFX_ERROR_INTERNAL;
   2710a:	4a06      	ldr	r2, [pc, #24]	; (27124 <event_handler+0x28>)
   2710c:	e000      	b.n	27110 <event_handler+0x14>
		dev_data->res = NRFX_SUCCESS;
   2710e:	4a06      	ldr	r2, [pc, #24]	; (27128 <event_handler+0x2c>)
		dev_data->res = NRFX_ERROR_INTERNAL;
   27110:	631a      	str	r2, [r3, #48]	; 0x30
	z_impl_k_sem_give(sem);
   27112:	f103 0018 	add.w	r0, r3, #24
   27116:	f00d ba99 	b.w	3464c <z_impl_k_sem_give>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   2711a:	4a04      	ldr	r2, [pc, #16]	; (2712c <event_handler+0x30>)
   2711c:	e7f8      	b.n	27110 <event_handler+0x14>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   2711e:	4a04      	ldr	r2, [pc, #16]	; (27130 <event_handler+0x34>)
   27120:	e7f6      	b.n	27110 <event_handler+0x14>
   27122:	bf00      	nop
   27124:	0bad0001 	.word	0x0bad0001
   27128:	0bad0000 	.word	0x0bad0000
   2712c:	0bae0001 	.word	0x0bae0001
   27130:	0bae0002 	.word	0x0bae0002

00027134 <init_spim>:
		transfer_next_chunk(dev);
	}
}

static int init_spim(struct device *dev)
{
   27134:	b510      	push	{r4, lr}
   27136:	4604      	mov	r4, r0
	return dev->config->config_info;
   27138:	6803      	ldr	r3, [r0, #0]
	/* This sets only default values of frequency, mode and bit order.
	 * The proper ones are set in configure() when a transfer is started.
	 */
	nrfx_err_t result = nrfx_spim_init(&get_dev_config(dev)->spim,
   2713a:	4a11      	ldr	r2, [pc, #68]	; (27180 <init_spim+0x4c>)
	return dev->config->config_info;
   2713c:	6898      	ldr	r0, [r3, #8]
	nrfx_err_t result = nrfx_spim_init(&get_dev_config(dev)->spim,
   2713e:	4623      	mov	r3, r4
   27140:	f100 010c 	add.w	r1, r0, #12
   27144:	f00a fc16 	bl	31974 <nrfx_spim_init>
					   &get_dev_config(dev)->config,
					   event_handler,
					   dev);
	if (result != NRFX_SUCCESS) {
   27148:	4b0e      	ldr	r3, [pc, #56]	; (27184 <init_spim+0x50>)
   2714a:	4298      	cmp	r0, r3
   2714c:	d012      	beq.n	27174 <init_spim+0x40>
		LOG_ERR("Failed to initialize device: %s",
   2714e:	2301      	movs	r3, #1
   27150:	f04f 0000 	mov.w	r0, #0
   27154:	4a0c      	ldr	r2, [pc, #48]	; (27188 <init_spim+0x54>)
   27156:	f363 0007 	bfi	r0, r3, #0, #8
   2715a:	4b0c      	ldr	r3, [pc, #48]	; (2718c <init_spim+0x58>)
   2715c:	490c      	ldr	r1, [pc, #48]	; (27190 <init_spim+0x5c>)
   2715e:	1a9b      	subs	r3, r3, r2
   27160:	08db      	lsrs	r3, r3, #3
   27162:	f363 108f 	bfi	r0, r3, #6, #10
   27166:	6823      	ldr	r3, [r4, #0]
   27168:	681a      	ldr	r2, [r3, #0]
   2716a:	f010 fe00 	bl	37d6e <log_string_sync>
			    dev->config->name);
		return -EBUSY;
   2716e:	f06f 000f 	mvn.w	r0, #15
	get_dev_data(dev)->pm_state = DEVICE_PM_ACTIVE_STATE;
#endif
	spi_context_unlock_unconditionally(&get_dev_data(dev)->ctx);

	return 0;
}
   27172:	bd10      	pop	{r4, pc}
	spi_context_unlock_unconditionally(&get_dev_data(dev)->ctx);
   27174:	68a0      	ldr	r0, [r4, #8]
   27176:	f011 fcf6 	bl	38b66 <spi_context_unlock_unconditionally>
	return 0;
   2717a:	2000      	movs	r0, #0
   2717c:	e7f9      	b.n	27172 <init_spim+0x3e>
   2717e:	bf00      	nop
   27180:	00027221 	.word	0x00027221
   27184:	0bad0000 	.word	0x0bad0000
   27188:	0003ade0 	.word	0x0003ade0
   2718c:	0003aee0 	.word	0x0003aee0
   27190:	0003ddc4 	.word	0x0003ddc4

00027194 <transfer_next_chunk>:
{
   27194:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   27196:	6885      	ldr	r5, [r0, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
}

static inline size_t spi_context_longest_current_buf(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
   27198:	6cea      	ldr	r2, [r5, #76]	; 0x4c
   2719a:	6d6b      	ldr	r3, [r5, #84]	; 0x54
   2719c:	b98a      	cbnz	r2, 271c2 <transfer_next_chunk+0x2e>
	if (chunk_len > 0) {
   2719e:	2b00      	cmp	r3, #0
   271a0:	d133      	bne.n	2720a <transfer_next_chunk+0x76>
	int error = 0;
   271a2:	461c      	mov	r4, r3
	_spi_context_cs_control(ctx, on, false);
   271a4:	2200      	movs	r2, #0
   271a6:	4628      	mov	r0, r5
   271a8:	4611      	mov	r1, r2
   271aa:	f011 fcb2 	bl	38b12 <_spi_context_cs_control.isra.7>
	ctx->sync_status = status;
   271ae:	636c      	str	r4, [r5, #52]	; 0x34
   271b0:	f105 001c 	add.w	r0, r5, #28
   271b4:	f00d fa4a 	bl	3464c <z_impl_k_sem_give>
	dev_data->busy = false;
   271b8:	2300      	movs	r3, #0
   271ba:	f885 305c 	strb.w	r3, [r5, #92]	; 0x5c
}
   271be:	b004      	add	sp, #16
   271c0:	bd70      	pop	{r4, r5, r6, pc}
		return ctx->rx_len;
	} else if (!ctx->rx_len) {
   271c2:	b323      	cbz	r3, 2720e <transfer_next_chunk+0x7a>
		return ctx->tx_len;
	} else if (ctx->tx_len < ctx->rx_len) {
   271c4:	4293      	cmp	r3, r2
   271c6:	4619      	mov	r1, r3
   271c8:	bf28      	it	cs
   271ca:	4611      	movcs	r1, r2
	return dev->config->config_info;
   271cc:	6800      	ldr	r0, [r0, #0]
		const u8_t *tx_buf = ctx->tx_buf;
   271ce:	6cac      	ldr	r4, [r5, #72]	; 0x48
	return dev->config->config_info;
   271d0:	6880      	ldr	r0, [r0, #8]
		xfer.p_tx_buffer = tx_buf;
   271d2:	9400      	str	r4, [sp, #0]
   271d4:	6886      	ldr	r6, [r0, #8]
   271d6:	42b1      	cmp	r1, r6
   271d8:	bf28      	it	cs
   271da:	4631      	movcs	r1, r6
		dev_data->chunk_len = chunk_len;
   271dc:	65a9      	str	r1, [r5, #88]	; 0x58
	return !!(ctx->tx_buf && ctx->tx_len);
   271de:	b1c4      	cbz	r4, 27212 <transfer_next_chunk+0x7e>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
   271e0:	2a00      	cmp	r2, #0
   271e2:	bf18      	it	ne
   271e4:	460a      	movne	r2, r1
   271e6:	9201      	str	r2, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
   271e8:	6d2a      	ldr	r2, [r5, #80]	; 0x50
   271ea:	9202      	str	r2, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
   271ec:	b19a      	cbz	r2, 27216 <transfer_next_chunk+0x82>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   271ee:	2b00      	cmp	r3, #0
   271f0:	bf18      	it	ne
   271f2:	460b      	movne	r3, r1
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
   271f4:	2200      	movs	r2, #0
   271f6:	4669      	mov	r1, sp
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   271f8:	9303      	str	r3, [sp, #12]
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
   271fa:	f00a fc73 	bl	31ae4 <nrfx_spim_xfer>
			if (result == NRFX_SUCCESS) {
   271fe:	4b07      	ldr	r3, [pc, #28]	; (2721c <transfer_next_chunk+0x88>)
   27200:	4298      	cmp	r0, r3
   27202:	d0dc      	beq.n	271be <transfer_next_chunk+0x2a>
			error = -EIO;
   27204:	f06f 0404 	mvn.w	r4, #4
   27208:	e7cc      	b.n	271a4 <transfer_next_chunk+0x10>
   2720a:	4619      	mov	r1, r3
   2720c:	e7de      	b.n	271cc <transfer_next_chunk+0x38>
	} else if (!ctx->rx_len) {
   2720e:	4611      	mov	r1, r2
   27210:	e7dc      	b.n	271cc <transfer_next_chunk+0x38>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
   27212:	4622      	mov	r2, r4
   27214:	e7e7      	b.n	271e6 <transfer_next_chunk+0x52>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   27216:	4613      	mov	r3, r2
   27218:	e7ec      	b.n	271f4 <transfer_next_chunk+0x60>
   2721a:	bf00      	nop
   2721c:	0bad0000 	.word	0x0bad0000

00027220 <event_handler>:
{
   27220:	b538      	push	{r3, r4, r5, lr}
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   27222:	7803      	ldrb	r3, [r0, #0]
{
   27224:	460d      	mov	r5, r1
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   27226:	2b00      	cmp	r3, #0
   27228:	d157      	bne.n	272da <event_handler+0xba>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   2722a:	688c      	ldr	r4, [r1, #8]
	if (!ctx->tx_len) {
   2722c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   2722e:	b183      	cbz	r3, 27252 <event_handler+0x32>
		spi_context_update_tx(&dev_data->ctx, 1, dev_data->chunk_len);
   27230:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (len > ctx->tx_len) {
   27232:	429a      	cmp	r2, r3
   27234:	d925      	bls.n	27282 <event_handler+0x62>
		LOG_ERR("Update exceeds current buffer");
   27236:	2301      	movs	r3, #1
   27238:	f04f 0000 	mov.w	r0, #0
   2723c:	4a27      	ldr	r2, [pc, #156]	; (272dc <event_handler+0xbc>)
   2723e:	f363 0007 	bfi	r0, r3, #0, #8
   27242:	4b27      	ldr	r3, [pc, #156]	; (272e0 <event_handler+0xc0>)
   27244:	4927      	ldr	r1, [pc, #156]	; (272e4 <event_handler+0xc4>)
   27246:	1a9b      	subs	r3, r3, r2
   27248:	08db      	lsrs	r3, r3, #3
   2724a:	f363 108f 	bfi	r0, r3, #6, #10
   2724e:	f010 fd8e 	bl	37d6e <log_string_sync>
	if (!ctx->rx_len) {
   27252:	6d63      	ldr	r3, [r4, #84]	; 0x54
   27254:	b183      	cbz	r3, 27278 <event_handler+0x58>
		spi_context_update_rx(&dev_data->ctx, 1, dev_data->chunk_len);
   27256:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (len > ctx->rx_len) {
   27258:	429a      	cmp	r2, r3
   2725a:	d928      	bls.n	272ae <event_handler+0x8e>
		LOG_ERR("Update exceeds current buffer");
   2725c:	2301      	movs	r3, #1
   2725e:	f04f 0000 	mov.w	r0, #0
   27262:	4a1e      	ldr	r2, [pc, #120]	; (272dc <event_handler+0xbc>)
   27264:	f363 0007 	bfi	r0, r3, #0, #8
   27268:	4b1d      	ldr	r3, [pc, #116]	; (272e0 <event_handler+0xc0>)
   2726a:	491e      	ldr	r1, [pc, #120]	; (272e4 <event_handler+0xc4>)
   2726c:	1a9b      	subs	r3, r3, r2
   2726e:	08db      	lsrs	r3, r3, #3
   27270:	f363 108f 	bfi	r0, r3, #6, #10
   27274:	f010 fd7b 	bl	37d6e <log_string_sync>
		transfer_next_chunk(dev);
   27278:	4628      	mov	r0, r5
}
   2727a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		transfer_next_chunk(dev);
   2727e:	f7ff bf89 	b.w	27194 <transfer_next_chunk>
	ctx->tx_len -= len;
   27282:	1a9b      	subs	r3, r3, r2
   27284:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (!ctx->tx_len) {
   27286:	b963      	cbnz	r3, 272a2 <event_handler+0x82>
		ctx->tx_count--;
   27288:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   2728a:	3b01      	subs	r3, #1
   2728c:	63e3      	str	r3, [r4, #60]	; 0x3c
		if (ctx->tx_count) {
   2728e:	b163      	cbz	r3, 272aa <event_handler+0x8a>
			ctx->current_tx++;
   27290:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   27292:	f103 0208 	add.w	r2, r3, #8
   27296:	63a2      	str	r2, [r4, #56]	; 0x38
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   27298:	689a      	ldr	r2, [r3, #8]
			ctx->tx_len = ctx->current_tx->len / dfs;
   2729a:	68db      	ldr	r3, [r3, #12]
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   2729c:	64a2      	str	r2, [r4, #72]	; 0x48
			ctx->tx_len = ctx->current_tx->len / dfs;
   2729e:	64e3      	str	r3, [r4, #76]	; 0x4c
   272a0:	e7d7      	b.n	27252 <event_handler+0x32>
	} else if (ctx->tx_buf) {
   272a2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   272a4:	2b00      	cmp	r3, #0
   272a6:	d0d4      	beq.n	27252 <event_handler+0x32>
		ctx->tx_buf += dfs * len;
   272a8:	4413      	add	r3, r2
   272aa:	64a3      	str	r3, [r4, #72]	; 0x48
   272ac:	e7d1      	b.n	27252 <event_handler+0x32>
	ctx->rx_len -= len;
   272ae:	1a9b      	subs	r3, r3, r2
   272b0:	6563      	str	r3, [r4, #84]	; 0x54
	if (!ctx->rx_len) {
   272b2:	b963      	cbnz	r3, 272ce <event_handler+0xae>
		ctx->rx_count--;
   272b4:	6c63      	ldr	r3, [r4, #68]	; 0x44
   272b6:	3b01      	subs	r3, #1
   272b8:	6463      	str	r3, [r4, #68]	; 0x44
		if (ctx->rx_count) {
   272ba:	b163      	cbz	r3, 272d6 <event_handler+0xb6>
			ctx->current_rx++;
   272bc:	6c23      	ldr	r3, [r4, #64]	; 0x40
   272be:	f103 0208 	add.w	r2, r3, #8
   272c2:	6422      	str	r2, [r4, #64]	; 0x40
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   272c4:	689a      	ldr	r2, [r3, #8]
			ctx->rx_len = ctx->current_rx->len / dfs;
   272c6:	68db      	ldr	r3, [r3, #12]
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   272c8:	6522      	str	r2, [r4, #80]	; 0x50
			ctx->rx_len = ctx->current_rx->len / dfs;
   272ca:	6563      	str	r3, [r4, #84]	; 0x54
   272cc:	e7d4      	b.n	27278 <event_handler+0x58>
	} else if (ctx->rx_buf) {
   272ce:	6d23      	ldr	r3, [r4, #80]	; 0x50
   272d0:	2b00      	cmp	r3, #0
   272d2:	d0d1      	beq.n	27278 <event_handler+0x58>
		ctx->rx_buf += dfs * len;
   272d4:	4413      	add	r3, r2
   272d6:	6523      	str	r3, [r4, #80]	; 0x50
   272d8:	e7ce      	b.n	27278 <event_handler+0x58>
}
   272da:	bd38      	pop	{r3, r4, r5, pc}
   272dc:	0003ade0 	.word	0x0003ade0
   272e0:	0003aee0 	.word	0x0003aee0
   272e4:	0003dde4 	.word	0x0003dde4

000272e8 <spi_nrfx_transceive>:
{
   272e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   272ec:	4607      	mov	r7, r0
	k_sem_take(&ctx->lock, K_FOREVER);
   272ee:	6880      	ldr	r0, [r0, #8]
   272f0:	4688      	mov	r8, r1
   272f2:	4616      	mov	r6, r2
   272f4:	461d      	mov	r5, r3
   272f6:	3004      	adds	r0, #4
	return z_impl_k_sem_take(sem, timeout);
   272f8:	f04f 31ff 	mov.w	r1, #4294967295
   272fc:	f00d f9f0 	bl	346e0 <z_impl_k_sem_take>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   27300:	68bc      	ldr	r4, [r7, #8]
	if (spi_context_configured(ctx, spi_cfg)) {
   27302:	6823      	ldr	r3, [r4, #0]
   27304:	4598      	cmp	r8, r3
   27306:	f000 80b0 	beq.w	2746a <spi_nrfx_transceive+0x182>
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
   2730a:	f8b8 3004 	ldrh.w	r3, [r8, #4]
	const nrfx_spim_t *spim = &get_dev_config(dev)->spim;
   2730e:	683a      	ldr	r2, [r7, #0]
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
   27310:	07d8      	lsls	r0, r3, #31
   27312:	d516      	bpl.n	27342 <spi_nrfx_transceive+0x5a>
		LOG_ERR("Slave mode is not supported on %s",
   27314:	2301      	movs	r3, #1
   27316:	f04f 0000 	mov.w	r0, #0
   2731a:	4981      	ldr	r1, [pc, #516]	; (27520 <spi_nrfx_transceive+0x238>)
   2731c:	f363 0007 	bfi	r0, r3, #0, #8
   27320:	4b80      	ldr	r3, [pc, #512]	; (27524 <spi_nrfx_transceive+0x23c>)
   27322:	6812      	ldr	r2, [r2, #0]
   27324:	1a5b      	subs	r3, r3, r1
   27326:	08db      	lsrs	r3, r3, #3
   27328:	f363 108f 	bfi	r0, r3, #6, #10
   2732c:	497e      	ldr	r1, [pc, #504]	; (27528 <spi_nrfx_transceive+0x240>)
   2732e:	f010 fd1e 	bl	37d6e <log_string_sync>
		return -EINVAL;
   27332:	f06f 0515 	mvn.w	r5, #21
	z_impl_k_sem_give(sem);
   27336:	1d20      	adds	r0, r4, #4
   27338:	f00d f988 	bl	3464c <z_impl_k_sem_give>
}
   2733c:	4628      	mov	r0, r5
   2733e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (spi_cfg->operation & SPI_MODE_LOOP) {
   27342:	0719      	lsls	r1, r3, #28
   27344:	d50e      	bpl.n	27364 <spi_nrfx_transceive+0x7c>
		LOG_ERR("Loopback mode is not supported");
   27346:	2301      	movs	r3, #1
   27348:	f04f 0000 	mov.w	r0, #0
   2734c:	4a74      	ldr	r2, [pc, #464]	; (27520 <spi_nrfx_transceive+0x238>)
   2734e:	f363 0007 	bfi	r0, r3, #0, #8
   27352:	4b74      	ldr	r3, [pc, #464]	; (27524 <spi_nrfx_transceive+0x23c>)
   27354:	4975      	ldr	r1, [pc, #468]	; (2752c <spi_nrfx_transceive+0x244>)
   27356:	1a9b      	subs	r3, r3, r2
   27358:	08db      	lsrs	r3, r3, #3
   2735a:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Word sizes other than 8 bits"
   2735e:	f010 fd06 	bl	37d6e <log_string_sync>
   27362:	e7e6      	b.n	27332 <spi_nrfx_transceive+0x4a>
	if ((spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
   27364:	f413 51c0 	ands.w	r1, r3, #6144	; 0x1800
   27368:	d00c      	beq.n	27384 <spi_nrfx_transceive+0x9c>
		LOG_ERR("Only single line mode is supported");
   2736a:	2301      	movs	r3, #1
   2736c:	f04f 0000 	mov.w	r0, #0
   27370:	4a6b      	ldr	r2, [pc, #428]	; (27520 <spi_nrfx_transceive+0x238>)
   27372:	f363 0007 	bfi	r0, r3, #0, #8
   27376:	4b6b      	ldr	r3, [pc, #428]	; (27524 <spi_nrfx_transceive+0x23c>)
   27378:	496d      	ldr	r1, [pc, #436]	; (27530 <spi_nrfx_transceive+0x248>)
   2737a:	1a9b      	subs	r3, r3, r2
   2737c:	08db      	lsrs	r3, r3, #3
   2737e:	f363 108f 	bfi	r0, r3, #6, #10
   27382:	e7ec      	b.n	2735e <spi_nrfx_transceive+0x76>
	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
   27384:	f3c3 1345 	ubfx	r3, r3, #5, #6
   27388:	2b08      	cmp	r3, #8
   2738a:	d00c      	beq.n	273a6 <spi_nrfx_transceive+0xbe>
		LOG_ERR("Word sizes other than 8 bits"
   2738c:	2301      	movs	r3, #1
   2738e:	f04f 0000 	mov.w	r0, #0
   27392:	4a63      	ldr	r2, [pc, #396]	; (27520 <spi_nrfx_transceive+0x238>)
   27394:	f363 0007 	bfi	r0, r3, #0, #8
   27398:	4b62      	ldr	r3, [pc, #392]	; (27524 <spi_nrfx_transceive+0x23c>)
   2739a:	4966      	ldr	r1, [pc, #408]	; (27534 <spi_nrfx_transceive+0x24c>)
   2739c:	1a9b      	subs	r3, r3, r2
   2739e:	08db      	lsrs	r3, r3, #3
   273a0:	f363 108f 	bfi	r0, r3, #6, #10
   273a4:	e7db      	b.n	2735e <spi_nrfx_transceive+0x76>
	if (spi_cfg->frequency < 125000) {
   273a6:	f8d8 0000 	ldr.w	r0, [r8]
   273aa:	4b63      	ldr	r3, [pc, #396]	; (27538 <spi_nrfx_transceive+0x250>)
   273ac:	4298      	cmp	r0, r3
   273ae:	d80c      	bhi.n	273ca <spi_nrfx_transceive+0xe2>
		LOG_ERR("Frequencies lower than 125 kHz are not supported");
   273b0:	2301      	movs	r3, #1
   273b2:	f04f 0000 	mov.w	r0, #0
   273b6:	4a5a      	ldr	r2, [pc, #360]	; (27520 <spi_nrfx_transceive+0x238>)
   273b8:	f363 0007 	bfi	r0, r3, #0, #8
   273bc:	4b59      	ldr	r3, [pc, #356]	; (27524 <spi_nrfx_transceive+0x23c>)
   273be:	495f      	ldr	r1, [pc, #380]	; (2753c <spi_nrfx_transceive+0x254>)
   273c0:	1a9b      	subs	r3, r3, r2
   273c2:	08db      	lsrs	r3, r3, #3
   273c4:	f363 108f 	bfi	r0, r3, #6, #10
   273c8:	e7c9      	b.n	2735e <spi_nrfx_transceive+0x76>
	if (ctx->config->cs && ctx->config->cs->gpio_dev) {
   273ca:	f8d8 3008 	ldr.w	r3, [r8, #8]
	return dev->config->config_info;
   273ce:	f8d2 9008 	ldr.w	r9, [r2, #8]
	ctx->config = spi_cfg;
   273d2:	f8c4 8000 	str.w	r8, [r4]
   273d6:	2b00      	cmp	r3, #0
   273d8:	d06f      	beq.n	274ba <spi_nrfx_transceive+0x1d2>
   273da:	6818      	ldr	r0, [r3, #0]
   273dc:	2800      	cmp	r0, #0
   273de:	d06c      	beq.n	274ba <spi_nrfx_transceive+0x1d2>
		gpio_pin_configure(ctx->config->cs->gpio_dev,
   273e0:	685a      	ldr	r2, [r3, #4]
	return api->config(port, access_op, pin, flags);
   273e2:	6843      	ldr	r3, [r0, #4]
   273e4:	f8d3 a000 	ldr.w	sl, [r3]
   273e8:	2301      	movs	r3, #1
   273ea:	47d0      	blx	sl
		gpio_pin_write(ctx->config->cs->gpio_dev,
   273ec:	6822      	ldr	r2, [r4, #0]
   273ee:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   273f0:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
		gpio_pin_write(ctx->config->cs->gpio_dev,
   273f4:	e9d3 0100 	ldrd	r0, r1, [r3]
   273f8:	43d2      	mvns	r2, r2
   273fa:	0fd2      	lsrs	r2, r2, #31
   273fc:	f011 fb7f 	bl	38afe <gpio_pin_write>
	nrf_spim_configure(spim->p_reg,
   27400:	f8b8 3004 	ldrh.w	r3, [r8, #4]
   27404:	f8d9 1000 	ldr.w	r1, [r9]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
   27408:	0798      	lsls	r0, r3, #30
   2740a:	f003 0204 	and.w	r2, r3, #4
   2740e:	d563      	bpl.n	274d8 <spi_nrfx_transceive+0x1f0>
			return NRF_SPIM_MODE_2;
   27410:	2a00      	cmp	r2, #0
   27412:	bf14      	ite	ne
   27414:	2203      	movne	r2, #3
   27416:	2202      	moveq	r2, #2
                                          nrf_spim_mode_t      spi_mode,
                                          nrf_spim_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPIM_BIT_ORDER_MSB_FIRST ?
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
    switch (spi_mode)
   27418:	2a02      	cmp	r2, #2
	if (operation & SPI_TRANSFER_LSB) {
   2741a:	f3c3 1300 	ubfx	r3, r3, #4, #1
   2741e:	d05f      	beq.n	274e0 <spi_nrfx_transceive+0x1f8>
   27420:	2a03      	cmp	r2, #3
   27422:	d060      	beq.n	274e6 <spi_nrfx_transceive+0x1fe>
   27424:	2a01      	cmp	r2, #1
   27426:	d101      	bne.n	2742c <spi_nrfx_transceive+0x144>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Leading    << SPIM_CONFIG_CPHA_Pos);
        break;

    case NRF_SPIM_MODE_1:
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
   27428:	f043 0302 	orr.w	r3, r3, #2
    case NRF_SPIM_MODE_3:
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Trailing   << SPIM_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
   2742c:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
	if (frequency < 250000) {
   27430:	4a43      	ldr	r2, [pc, #268]	; (27540 <spi_nrfx_transceive+0x258>)
	nrf_spim_frequency_set(spim->p_reg,
   27432:	f8d8 3000 	ldr.w	r3, [r8]
	if (frequency < 250000) {
   27436:	4293      	cmp	r3, r2
   27438:	d958      	bls.n	274ec <spi_nrfx_transceive+0x204>
	} else if (frequency < 500000) {
   2743a:	4a42      	ldr	r2, [pc, #264]	; (27544 <spi_nrfx_transceive+0x25c>)
   2743c:	4293      	cmp	r3, r2
   2743e:	d958      	bls.n	274f2 <spi_nrfx_transceive+0x20a>
	} else if (frequency < 1000000) {
   27440:	4a41      	ldr	r2, [pc, #260]	; (27548 <spi_nrfx_transceive+0x260>)
   27442:	4293      	cmp	r3, r2
   27444:	d958      	bls.n	274f8 <spi_nrfx_transceive+0x210>
	} else if (frequency < 2000000) {
   27446:	4a41      	ldr	r2, [pc, #260]	; (2754c <spi_nrfx_transceive+0x264>)
   27448:	4293      	cmp	r3, r2
   2744a:	d958      	bls.n	274fe <spi_nrfx_transceive+0x216>
	} else if (frequency < 4000000) {
   2744c:	4a40      	ldr	r2, [pc, #256]	; (27550 <spi_nrfx_transceive+0x268>)
   2744e:	4293      	cmp	r3, r2
   27450:	d958      	bls.n	27504 <spi_nrfx_transceive+0x21c>
		return NRF_SPIM_FREQ_8M;
   27452:	f502 1274 	add.w	r2, r2, #3997696	; 0x3d0000
   27456:	f502 6210 	add.w	r2, r2, #2304	; 0x900
   2745a:	4293      	cmp	r3, r2
   2745c:	bf94      	ite	ls
   2745e:	f04f 4380 	movls.w	r3, #1073741824	; 0x40000000
   27462:	f04f 4300 	movhi.w	r3, #2147483648	; 0x80000000
    p_reg->FREQUENCY = (uint32_t)frequency;
   27466:	f8c1 3524 	str.w	r3, [r1, #1316]	; 0x524
		dev_data->busy = true;
   2746a:	2301      	movs	r3, #1
   2746c:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
	if (tx_bufs) {
   27470:	2e00      	cmp	r6, #0
   27472:	d04a      	beq.n	2750a <spi_nrfx_transceive+0x222>
		ctx->current_tx = tx_bufs->buffers;
   27474:	6833      	ldr	r3, [r6, #0]
		ctx->tx_count = tx_bufs->count;
   27476:	6872      	ldr	r2, [r6, #4]
		ctx->current_tx = tx_bufs->buffers;
   27478:	63a3      	str	r3, [r4, #56]	; 0x38
		ctx->tx_count = tx_bufs->count;
   2747a:	63e2      	str	r2, [r4, #60]	; 0x3c
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   2747c:	681a      	ldr	r2, [r3, #0]
		ctx->tx_len = ctx->current_tx->len / dfs;
   2747e:	685b      	ldr	r3, [r3, #4]
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   27480:	64a2      	str	r2, [r4, #72]	; 0x48
		ctx->tx_len = ctx->current_tx->len / dfs;
   27482:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (rx_bufs) {
   27484:	2d00      	cmp	r5, #0
   27486:	d045      	beq.n	27514 <spi_nrfx_transceive+0x22c>
		ctx->current_rx = rx_bufs->buffers;
   27488:	682b      	ldr	r3, [r5, #0]
		ctx->rx_count = rx_bufs->count;
   2748a:	686a      	ldr	r2, [r5, #4]
		ctx->current_rx = rx_bufs->buffers;
   2748c:	6423      	str	r3, [r4, #64]	; 0x40
		ctx->rx_count = rx_bufs->count;
   2748e:	6462      	str	r2, [r4, #68]	; 0x44
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   27490:	681a      	ldr	r2, [r3, #0]
		ctx->rx_len = ctx->current_rx->len / dfs;
   27492:	685b      	ldr	r3, [r3, #4]
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   27494:	6522      	str	r2, [r4, #80]	; 0x50
		ctx->rx_len = ctx->current_rx->len / dfs;
   27496:	6563      	str	r3, [r4, #84]	; 0x54
	ctx->sync_status = 0;
   27498:	2200      	movs	r2, #0
	_spi_context_cs_control(ctx, on, false);
   2749a:	2101      	movs	r1, #1
	ctx->sync_status = 0;
   2749c:	6362      	str	r2, [r4, #52]	; 0x34
	_spi_context_cs_control(ctx, on, false);
   2749e:	4620      	mov	r0, r4
   274a0:	f011 fb37 	bl	38b12 <_spi_context_cs_control.isra.7>
		transfer_next_chunk(dev);
   274a4:	4638      	mov	r0, r7
   274a6:	f7ff fe75 	bl	27194 <transfer_next_chunk>
	return z_impl_k_sem_take(sem, timeout);
   274aa:	f04f 31ff 	mov.w	r1, #4294967295
   274ae:	f104 001c 	add.w	r0, r4, #28
   274b2:	f00d f915 	bl	346e0 <z_impl_k_sem_take>
	status = ctx->sync_status;
   274b6:	6b65      	ldr	r5, [r4, #52]	; 0x34
	return status;
   274b8:	e73d      	b.n	27336 <spi_nrfx_transceive+0x4e>
		LOG_INF("CS control inhibited (no GPIO device)");
   274ba:	2303      	movs	r3, #3
   274bc:	f04f 0000 	mov.w	r0, #0
   274c0:	4a17      	ldr	r2, [pc, #92]	; (27520 <spi_nrfx_transceive+0x238>)
   274c2:	f363 0007 	bfi	r0, r3, #0, #8
   274c6:	4b17      	ldr	r3, [pc, #92]	; (27524 <spi_nrfx_transceive+0x23c>)
   274c8:	4922      	ldr	r1, [pc, #136]	; (27554 <spi_nrfx_transceive+0x26c>)
   274ca:	1a9b      	subs	r3, r3, r2
   274cc:	08db      	lsrs	r3, r3, #3
   274ce:	f363 108f 	bfi	r0, r3, #6, #10
   274d2:	f010 fc4c 	bl	37d6e <log_string_sync>
   274d6:	e793      	b.n	27400 <spi_nrfx_transceive+0x118>
			return NRF_SPIM_MODE_0;
   274d8:	3200      	adds	r2, #0
   274da:	bf18      	it	ne
   274dc:	2201      	movne	r2, #1
   274de:	e79b      	b.n	27418 <spi_nrfx_transceive+0x130>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   274e0:	f043 0304 	orr.w	r3, r3, #4
        break;
   274e4:	e7a2      	b.n	2742c <spi_nrfx_transceive+0x144>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   274e6:	f043 0306 	orr.w	r3, r3, #6
        break;
   274ea:	e79f      	b.n	2742c <spi_nrfx_transceive+0x144>
		return NRF_SPIM_FREQ_125K;
   274ec:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   274f0:	e7b9      	b.n	27466 <spi_nrfx_transceive+0x17e>
		return NRF_SPIM_FREQ_250K;
   274f2:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   274f6:	e7b6      	b.n	27466 <spi_nrfx_transceive+0x17e>
		return NRF_SPIM_FREQ_500K;
   274f8:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
   274fc:	e7b3      	b.n	27466 <spi_nrfx_transceive+0x17e>
		return NRF_SPIM_FREQ_1M;
   274fe:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   27502:	e7b0      	b.n	27466 <spi_nrfx_transceive+0x17e>
		return NRF_SPIM_FREQ_2M;
   27504:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
   27508:	e7ad      	b.n	27466 <spi_nrfx_transceive+0x17e>
		ctx->tx_count = 0;
   2750a:	e9c4 660e 	strd	r6, r6, [r4, #56]	; 0x38
		ctx->tx_len = 0;
   2750e:	e9c4 6612 	strd	r6, r6, [r4, #72]	; 0x48
   27512:	e7b7      	b.n	27484 <spi_nrfx_transceive+0x19c>
		ctx->rx_count = 0;
   27514:	e9c4 5510 	strd	r5, r5, [r4, #64]	; 0x40
		ctx->rx_len = 0;
   27518:	e9c4 5514 	strd	r5, r5, [r4, #80]	; 0x50
   2751c:	e7bc      	b.n	27498 <spi_nrfx_transceive+0x1b0>
   2751e:	bf00      	nop
   27520:	0003ade0 	.word	0x0003ade0
   27524:	0003aee0 	.word	0x0003aee0
   27528:	0003de02 	.word	0x0003de02
   2752c:	0003de24 	.word	0x0003de24
   27530:	0003de43 	.word	0x0003de43
   27534:	0003de66 	.word	0x0003de66
   27538:	0001e847 	.word	0x0001e847
   2753c:	0003de95 	.word	0x0003de95
   27540:	0003d08f 	.word	0x0003d08f
   27544:	0007a11f 	.word	0x0007a11f
   27548:	000f423f 	.word	0x000f423f
   2754c:	001e847f 	.word	0x001e847f
   27550:	003d08ff 	.word	0x003d08ff
   27554:	0003dec6 	.word	0x0003dec6

00027558 <flash_nrf_pages_layout>:

static void flash_nrf_pages_layout(struct device *dev,
				     const struct flash_pages_layout **layout,
				     size_t *layout_size)
{
	*layout = &dev_layout;
   27558:	4b02      	ldr	r3, [pc, #8]	; (27564 <flash_nrf_pages_layout+0xc>)
   2755a:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
   2755c:	2301      	movs	r3, #1
   2755e:	6013      	str	r3, [r2, #0]
}
   27560:	4770      	bx	lr
   27562:	bf00      	nop
   27564:	200205c8 	.word	0x200205c8

00027568 <flash_nrf_erase>:
{
   27568:	b570      	push	{r4, r5, r6, lr}
   2756a:	460d      	mov	r5, r1
   2756c:	4614      	mov	r4, r2
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   2756e:	f012 f9da 	bl	39926 <nrfx_nvmc_flash_page_size_get>
	if (is_regular_addr_valid(addr, size)) {
   27572:	4621      	mov	r1, r4
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   27574:	4606      	mov	r6, r0
	if (is_regular_addr_valid(addr, size)) {
   27576:	4628      	mov	r0, r5
   27578:	f011 fb2f 	bl	38bda <is_regular_addr_valid>
   2757c:	b1f0      	cbz	r0, 275bc <flash_nrf_erase+0x54>
		if (((addr % pg_size) != 0) || ((size % pg_size) != 0)) {
   2757e:	fbb5 f3f6 	udiv	r3, r5, r6
   27582:	fb06 5313 	mls	r3, r6, r3, r5
   27586:	b9cb      	cbnz	r3, 275bc <flash_nrf_erase+0x54>
   27588:	fbb4 f0f6 	udiv	r0, r4, r6
   2758c:	fb06 4010 	mls	r0, r6, r0, r4
   27590:	b9a0      	cbnz	r0, 275bc <flash_nrf_erase+0x54>
		if (!n_pages) {
   27592:	42a6      	cmp	r6, r4
   27594:	d811      	bhi.n	275ba <flash_nrf_erase+0x52>
   27596:	f04f 31ff 	mov.w	r1, #4294967295
   2759a:	480a      	ldr	r0, [pc, #40]	; (275c4 <flash_nrf_erase+0x5c>)
   2759c:	f00d f8a0 	bl	346e0 <z_impl_k_sem_take>

#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

static int erase_op(void *context)
{
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   275a0:	f012 f9c1 	bl	39926 <nrfx_nvmc_flash_page_size_get>
   275a4:	4606      	mov	r6, r0
		return FLASH_OP_DONE;
	}
#endif

	do {
		(void)nrfx_nvmc_page_erase(e_ctx->flash_addr);
   275a6:	4628      	mov	r0, r5
   275a8:	f00a f95e 	bl	31868 <nrfx_nvmc_page_erase>
				break;
			}
		}
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

	} while (e_ctx->len > 0);
   275ac:	1ba4      	subs	r4, r4, r6
   275ae:	4435      	add	r5, r6
   275b0:	d1f9      	bne.n	275a6 <flash_nrf_erase+0x3e>
	z_impl_k_sem_give(sem);
   275b2:	4804      	ldr	r0, [pc, #16]	; (275c4 <flash_nrf_erase+0x5c>)
   275b4:	f00d f84a 	bl	3464c <z_impl_k_sem_give>
	return ret;
   275b8:	4620      	mov	r0, r4
}
   275ba:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   275bc:	f06f 0015 	mvn.w	r0, #21
   275c0:	e7fb      	b.n	275ba <flash_nrf_erase+0x52>
   275c2:	bf00      	nop
   275c4:	200205d0 	.word	0x200205d0

000275c8 <nrf_flash_init>:
{
   275c8:	b510      	push	{r4, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
   275ca:	2201      	movs	r2, #1
   275cc:	4806      	ldr	r0, [pc, #24]	; (275e8 <nrf_flash_init+0x20>)
   275ce:	4611      	mov	r1, r2
   275d0:	f012 fa89 	bl	39ae6 <z_impl_k_sem_init>
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
   275d4:	f012 f9aa 	bl	3992c <nrfx_nvmc_flash_page_count_get>
   275d8:	4c04      	ldr	r4, [pc, #16]	; (275ec <nrf_flash_init+0x24>)
   275da:	6020      	str	r0, [r4, #0]
	dev_layout.pages_size = nrfx_nvmc_flash_page_size_get();
   275dc:	f012 f9a3 	bl	39926 <nrfx_nvmc_flash_page_size_get>
   275e0:	6060      	str	r0, [r4, #4]
}
   275e2:	2000      	movs	r0, #0
   275e4:	bd10      	pop	{r4, pc}
   275e6:	bf00      	nop
   275e8:	200205d0 	.word	0x200205d0
   275ec:	200205c8 	.word	0x200205c8

000275f0 <flash_nrf_write>:
{
   275f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   275f2:	460e      	mov	r6, r1
	if (is_regular_addr_valid(addr, len)) {
   275f4:	4619      	mov	r1, r3
   275f6:	4630      	mov	r0, r6
{
   275f8:	4617      	mov	r7, r2
   275fa:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   275fc:	f011 faed 	bl	38bda <is_regular_addr_valid>
   27600:	b1f8      	cbz	r0, 27642 <flash_nrf_write+0x52>
	return (data & 0x3) ? false : true;
   27602:	ea46 0504 	orr.w	r5, r6, r4
	if (!is_aligned_32(addr) || (len % sizeof(u32_t))) {
   27606:	f015 0503 	ands.w	r5, r5, #3
   2760a:	d11a      	bne.n	27642 <flash_nrf_write+0x52>
	if (!len) {
   2760c:	b1e4      	cbz	r4, 27648 <flash_nrf_write+0x58>
	return z_impl_k_sem_take(sem, timeout);
   2760e:	f04f 31ff 	mov.w	r1, #4294967295
   27612:	480e      	ldr	r0, [pc, #56]	; (2764c <flash_nrf_write+0x5c>)
   27614:	f00d f864 	bl	346e0 <z_impl_k_sem_take>
	w_ctx->flash_addr += shift;
	w_ctx->data_addr += shift;
	w_ctx->len -= shift;
}

static int write_op(void *context)
   27618:	f024 0403 	bic.w	r4, r4, #3
		}
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */
	}
#endif /* CONFIG_SOC_FLASH_NRF_EMULATE_ONE_BYTE_WRITE_ACCESS */
	/* Write all the 4-byte aligned data */
	while (w_ctx->len >= sizeof(u32_t)) {
   2761c:	42a5      	cmp	r5, r4
   2761e:	eb06 0005 	add.w	r0, r6, r5
   27622:	d109      	bne.n	27638 <flash_nrf_write+0x48>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrf_nvmc_ready_check(NRF_NVMC_Type const * p_reg)
{
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   27624:	4a0a      	ldr	r2, [pc, #40]	; (27650 <flash_nrf_write+0x60>)
   27626:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
   2762a:	07db      	lsls	r3, r3, #31
   2762c:	d5fb      	bpl.n	27626 <flash_nrf_write+0x36>
	z_impl_k_sem_give(sem);
   2762e:	4807      	ldr	r0, [pc, #28]	; (2764c <flash_nrf_write+0x5c>)
   27630:	f00d f80c 	bl	3464c <z_impl_k_sem_give>
   27634:	2000      	movs	r0, #0
}
   27636:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		nrfx_nvmc_word_write(w_ctx->flash_addr,
   27638:	5979      	ldr	r1, [r7, r5]
   2763a:	f00a f941 	bl	318c0 <nrfx_nvmc_word_write>
	w_ctx->len -= shift;
   2763e:	3504      	adds	r5, #4
   27640:	e7ec      	b.n	2761c <flash_nrf_write+0x2c>
		return -EINVAL;
   27642:	f06f 0015 	mvn.w	r0, #21
   27646:	e7f6      	b.n	27636 <flash_nrf_write+0x46>
		return 0;
   27648:	4620      	mov	r0, r4
   2764a:	e7f4      	b.n	27636 <flash_nrf_write+0x46>
   2764c:	200205d0 	.word	0x200205d0
   27650:	40039000 	.word	0x40039000

00027654 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(struct device *dev,
				const struct uart_config *cfg)
{
   27654:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
   27656:	794b      	ldrb	r3, [r1, #5]
   27658:	2b01      	cmp	r3, #1
   2765a:	d029      	beq.n	276b0 <uarte_nrfx_configure+0x5c>
   2765c:	2b03      	cmp	r3, #3
   2765e:	d124      	bne.n	276aa <uarte_nrfx_configure+0x56>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
   27660:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   27662:	798b      	ldrb	r3, [r1, #6]
   27664:	2b03      	cmp	r3, #3
   27666:	d120      	bne.n	276aa <uarte_nrfx_configure+0x56>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
   27668:	79cc      	ldrb	r4, [r1, #7]
   2766a:	b12c      	cbz	r4, 27678 <uarte_nrfx_configure+0x24>
   2766c:	2c01      	cmp	r4, #1
   2766e:	d11c      	bne.n	276aa <uarte_nrfx_configure+0x56>
	return dev->config->config_info;
   27670:	6803      	ldr	r3, [r0, #0]
	case UART_CFG_FLOW_CTRL_NONE:
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
		break;
	case UART_CFG_FLOW_CTRL_RTS_CTS:
		if (get_dev_config(dev)->rts_cts_pins_set) {
   27672:	689b      	ldr	r3, [r3, #8]
   27674:	791b      	ldrb	r3, [r3, #4]
   27676:	b1c3      	cbz	r3, 276aa <uarte_nrfx_configure+0x56>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
   27678:	790a      	ldrb	r2, [r1, #4]
   2767a:	b112      	cbz	r2, 27682 <uarte_nrfx_configure+0x2e>
   2767c:	2a02      	cmp	r2, #2
   2767e:	d114      	bne.n	276aa <uarte_nrfx_configure+0x56>
	case UART_CFG_PARITY_NONE:
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
   27680:	220e      	movs	r2, #14
	switch (baudrate) {
   27682:	f647 2712 	movw	r7, #31250	; 0x7a12
	return dev->config->config_info;
   27686:	6805      	ldr	r5, [r0, #0]
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
   27688:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
   2768a:	68ad      	ldr	r5, [r5, #8]
	switch (baudrate) {
   2768c:	42bb      	cmp	r3, r7
	return config->uarte_regs;
   2768e:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
   27690:	d062      	beq.n	27758 <uarte_nrfx_configure+0x104>
   27692:	d829      	bhi.n	276e8 <uarte_nrfx_configure+0x94>
   27694:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
   27698:	d061      	beq.n	2775e <uarte_nrfx_configure+0x10a>
   2769a:	d814      	bhi.n	276c6 <uarte_nrfx_configure+0x72>
   2769c:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
   276a0:	d05f      	beq.n	27762 <uarte_nrfx_configure+0x10e>
   276a2:	d807      	bhi.n	276b4 <uarte_nrfx_configure+0x60>
   276a4:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   276a8:	d05e      	beq.n	27768 <uarte_nrfx_configure+0x114>
		return -ENOTSUP;
   276aa:	f06f 0085 	mvn.w	r0, #133	; 0x85
   276ae:	e052      	b.n	27756 <uarte_nrfx_configure+0x102>
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
   276b0:	2600      	movs	r6, #0
   276b2:	e7d6      	b.n	27662 <uarte_nrfx_configure+0xe>
	switch (baudrate) {
   276b4:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
   276b8:	d059      	beq.n	2776e <uarte_nrfx_configure+0x11a>
   276ba:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
   276be:	d1f4      	bne.n	276aa <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
   276c0:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
   276c4:	e03c      	b.n	27740 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   276c6:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
   276ca:	d053      	beq.n	27774 <uarte_nrfx_configure+0x120>
   276cc:	d804      	bhi.n	276d8 <uarte_nrfx_configure+0x84>
   276ce:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   276d2:	d1ea      	bne.n	276aa <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
   276d4:	4b32      	ldr	r3, [pc, #200]	; (277a0 <uarte_nrfx_configure+0x14c>)
   276d6:	e033      	b.n	27740 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   276d8:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
   276dc:	d04c      	beq.n	27778 <uarte_nrfx_configure+0x124>
   276de:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
   276e2:	d1e2      	bne.n	276aa <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
   276e4:	4b2f      	ldr	r3, [pc, #188]	; (277a4 <uarte_nrfx_configure+0x150>)
   276e6:	e02b      	b.n	27740 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   276e8:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
   276ec:	d046      	beq.n	2777c <uarte_nrfx_configure+0x128>
   276ee:	d812      	bhi.n	27716 <uarte_nrfx_configure+0xc2>
   276f0:	f64d 27c0 	movw	r7, #56000	; 0xdac0
   276f4:	42bb      	cmp	r3, r7
   276f6:	d044      	beq.n	27782 <uarte_nrfx_configure+0x12e>
   276f8:	d805      	bhi.n	27706 <uarte_nrfx_configure+0xb2>
   276fa:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
   276fe:	d1d4      	bne.n	276aa <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
   27700:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
   27704:	e01c      	b.n	27740 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   27706:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   2770a:	d03d      	beq.n	27788 <uarte_nrfx_configure+0x134>
   2770c:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
   27710:	d1cb      	bne.n	276aa <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
   27712:	4b25      	ldr	r3, [pc, #148]	; (277a8 <uarte_nrfx_configure+0x154>)
   27714:	e014      	b.n	27740 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   27716:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
   2771a:	d038      	beq.n	2778e <uarte_nrfx_configure+0x13a>
   2771c:	d808      	bhi.n	27730 <uarte_nrfx_configure+0xdc>
   2771e:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   27722:	d037      	beq.n	27794 <uarte_nrfx_configure+0x140>
   27724:	4f21      	ldr	r7, [pc, #132]	; (277ac <uarte_nrfx_configure+0x158>)
   27726:	42bb      	cmp	r3, r7
   27728:	d1bf      	bne.n	276aa <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
   2772a:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   2772e:	e007      	b.n	27740 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   27730:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
   27734:	d031      	beq.n	2779a <uarte_nrfx_configure+0x146>
   27736:	4f1e      	ldr	r7, [pc, #120]	; (277b0 <uarte_nrfx_configure+0x15c>)
   27738:	42bb      	cmp	r3, r7
   2773a:	d1b6      	bne.n	276aa <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
   2773c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
   27740:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
                    | (uint32_t)p_cfg->hwfc;
   27744:	4334      	orrs	r4, r6
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
   27746:	6883      	ldr	r3, [r0, #8]
   27748:	4322      	orrs	r2, r4
   2774a:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   2774c:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
   27750:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
   27754:	2000      	movs	r0, #0
}
   27756:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
   27758:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   2775c:	e7f0      	b.n	27740 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
   2775e:	4b15      	ldr	r3, [pc, #84]	; (277b4 <uarte_nrfx_configure+0x160>)
   27760:	e7ee      	b.n	27740 <uarte_nrfx_configure+0xec>
		nrf_baudrate = 0x00027000;
   27762:	f44f 331c 	mov.w	r3, #159744	; 0x27000
   27766:	e7eb      	b.n	27740 <uarte_nrfx_configure+0xec>
		nrf_baudrate = 0x00014000;
   27768:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
   2776c:	e7e8      	b.n	27740 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
   2776e:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
   27772:	e7e5      	b.n	27740 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
   27774:	4b10      	ldr	r3, [pc, #64]	; (277b8 <uarte_nrfx_configure+0x164>)
   27776:	e7e3      	b.n	27740 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
   27778:	4b10      	ldr	r3, [pc, #64]	; (277bc <uarte_nrfx_configure+0x168>)
   2777a:	e7e1      	b.n	27740 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
   2777c:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
   27780:	e7de      	b.n	27740 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
   27782:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
   27786:	e7db      	b.n	27740 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
   27788:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
   2778c:	e7d8      	b.n	27740 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
   2778e:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
   27792:	e7d5      	b.n	27740 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
   27794:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
   27798:	e7d2      	b.n	27740 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
   2779a:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   2779e:	e7cf      	b.n	27740 <uarte_nrfx_configure+0xec>
   277a0:	00275000 	.word	0x00275000
   277a4:	0075c000 	.word	0x0075c000
   277a8:	013a9000 	.word	0x013a9000
   277ac:	0003d090 	.word	0x0003d090
   277b0:	000f4240 	.word	0x000f4240
   277b4:	0013b000 	.word	0x0013b000
   277b8:	003af000 	.word	0x003af000
   277bc:	004ea000 	.word	0x004ea000

000277c0 <uarte_0_init>:
	#endif
	#if !defined(DT_NORDIC_NRF_UARTE_UART_0_RX_PIN)
	#define DT_NORDIC_NRF_UARTE_UART_0_RX_PIN NRF_UARTE_PSEL_DISCONNECTED
	#endif

	UART_NRF_UARTE_DEVICE(0);
   277c0:	b570      	push	{r4, r5, r6, lr}
   277c2:	4606      	mov	r6, r0
   277c4:	2200      	movs	r2, #0
   277c6:	2101      	movs	r1, #1
   277c8:	2008      	movs	r0, #8
   277ca:	f7fd fc11 	bl	24ff0 <z_arm_irq_priority_set>
   277ce:	2008      	movs	r0, #8
   277d0:	f7fd fbfe 	bl	24fd0 <arch_irq_enable>
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
   277d4:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
	return dev->config->config_info;
   277d8:	6833      	ldr	r3, [r6, #0]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   277da:	68b5      	ldr	r5, [r6, #8]
	return config->uarte_regs;
   277dc:	689b      	ldr	r3, [r3, #8]
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   277de:	4629      	mov	r1, r5
	return config->uarte_regs;
   277e0:	681c      	ldr	r4, [r3, #0]
   277e2:	4b14      	ldr	r3, [pc, #80]	; (27834 <uarte_0_init+0x74>)
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   277e4:	4630      	mov	r0, r6
   277e6:	609a      	str	r2, [r3, #8]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   277e8:	2203      	movs	r2, #3
   277ea:	f8c3 2274 	str.w	r2, [r3, #628]	; 0x274
   277ee:	2200      	movs	r2, #0
   277f0:	f8c3 2270 	str.w	r2, [r3, #624]	; 0x270
    p_reg->PSEL.TXD = pseltxd;
   277f4:	231d      	movs	r3, #29
   277f6:	f8c4 350c 	str.w	r3, [r4, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
   277fa:	231c      	movs	r3, #28
   277fc:	f8c4 3514 	str.w	r3, [r4, #1300]	; 0x514
   27800:	f7ff ff28 	bl	27654 <uarte_nrfx_configure>
	if (err) {
   27804:	b9a0      	cbnz	r0, 27830 <uarte_0_init+0x70>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   27806:	2308      	movs	r3, #8
   27808:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
		nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
   2780c:	f105 030c 	add.w	r3, r5, #12
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   27810:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   27814:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   27818:	2301      	movs	r3, #1
		nrf_uarte_tx_buffer_set(uarte, data->int_driven->tx_buffer, 0);
   2781a:	68aa      	ldr	r2, [r5, #8]
   2781c:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   27820:	6892      	ldr	r2, [r2, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   27822:	6023      	str	r3, [r4, #0]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   27824:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   27828:	f8c4 0548 	str.w	r0, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2782c:	60a3      	str	r3, [r4, #8]
   2782e:	60e3      	str	r3, [r4, #12]
	UART_NRF_UARTE_DEVICE(0);
   27830:	bd70      	pop	{r4, r5, r6, pc}
   27832:	bf00      	nop
   27834:	40842500 	.word	0x40842500

00027838 <entropy_cc310_rng_get_entropy>:
#include "nrf_cc310_platform_entropy.h"
#endif

static int entropy_cc310_rng_get_entropy(struct device *dev, u8_t *buffer,
					 u16_t length)
{
   27838:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2783a:	460d      	mov	r5, r1
   2783c:	4614      	mov	r4, r2
	int res = -EINVAL;
	size_t olen;

	__ASSERT_NO_MSG(dev != NULL);
   2783e:	b948      	cbnz	r0, 27854 <entropy_cc310_rng_get_entropy+0x1c>
   27840:	4910      	ldr	r1, [pc, #64]	; (27884 <entropy_cc310_rng_get_entropy+0x4c>)
   27842:	4811      	ldr	r0, [pc, #68]	; (27888 <entropy_cc310_rng_get_entropy+0x50>)
   27844:	231e      	movs	r3, #30
   27846:	4a11      	ldr	r2, [pc, #68]	; (2788c <entropy_cc310_rng_get_entropy+0x54>)
   27848:	f010 fa3a 	bl	37cc0 <printk>
   2784c:	211e      	movs	r1, #30
   2784e:	480f      	ldr	r0, [pc, #60]	; (2788c <entropy_cc310_rng_get_entropy+0x54>)
   27850:	f010 fa7c 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(buffer != NULL);
   27854:	b94d      	cbnz	r5, 2786a <entropy_cc310_rng_get_entropy+0x32>
   27856:	490e      	ldr	r1, [pc, #56]	; (27890 <entropy_cc310_rng_get_entropy+0x58>)
   27858:	480b      	ldr	r0, [pc, #44]	; (27888 <entropy_cc310_rng_get_entropy+0x50>)
   2785a:	231f      	movs	r3, #31
   2785c:	4a0b      	ldr	r2, [pc, #44]	; (2788c <entropy_cc310_rng_get_entropy+0x54>)
   2785e:	f010 fa2f 	bl	37cc0 <printk>
   27862:	211f      	movs	r1, #31
   27864:	4809      	ldr	r0, [pc, #36]	; (2788c <entropy_cc310_rng_get_entropy+0x54>)
   27866:	f010 fa71 	bl	37d4c <assert_post_action>

#if defined(CONFIG_SPM)
	/** This is a call from a non-secure app that enables secure services,
	 *  in which case entropy is gathered by calling through SPM
	 */
	res = spm_request_random_number(buffer, length, &olen);
   2786a:	aa01      	add	r2, sp, #4
   2786c:	4621      	mov	r1, r4
   2786e:	4628      	mov	r0, r5
   27870:	f7f0 fbbe 	bl	17ff0 <spm_request_random_number>
	if (olen != length) {
   27874:	9b01      	ldr	r3, [sp, #4]
		return -EINVAL;
   27876:	429c      	cmp	r4, r3
		return -EINVAL;
	}
#endif

	return res;
}
   27878:	bf18      	it	ne
   2787a:	f06f 0015 	mvnne.w	r0, #21
   2787e:	b003      	add	sp, #12
   27880:	bd30      	pop	{r4, r5, pc}
   27882:	bf00      	nop
   27884:	0003df3a 	.word	0x0003df3a
   27888:	0003baac 	.word	0x0003baac
   2788c:	0003df0a 	.word	0x0003df0a
   27890:	0003df4d 	.word	0x0003df4d

00027894 <_bsdlib_init>:
static int _bsdlib_init(struct device *unused)
{
	/* Setup the network IRQ used by the BSD library.
	 * Note: No call to irq_enable() here, that is done through bsd_init().
	 */
	IRQ_DIRECT_CONNECT(BSD_NETWORK_IRQ, BSD_NETWORK_IRQ_PRIORITY,
   27894:	2200      	movs	r2, #0
{
   27896:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(BSD_NETWORK_IRQ, BSD_NETWORK_IRQ_PRIORITY,
   27898:	4611      	mov	r1, r2
   2789a:	202a      	movs	r0, #42	; 0x2a
   2789c:	f7fd fba8 	bl	24ff0 <z_arm_irq_priority_set>
			   ipc_proxy_irq_handler, 0);

	init_ret = bsd_init();
   278a0:	f003 fea8 	bl	2b5f4 <bsd_init>
   278a4:	4b01      	ldr	r3, [pc, #4]	; (278ac <_bsdlib_init+0x18>)
   278a6:	6018      	str	r0, [r3, #0]
		 */
		return 0;
	}

	return init_ret;
}
   278a8:	2000      	movs	r0, #0
   278aa:	bd08      	pop	{r3, pc}
   278ac:	200205e8 	.word	0x200205e8

000278b0 <thread_monitor_entry_get>:

/* Get thread monitor structure assigned to a specific thread id, with a RPC
 * counter value at which bsdlib last checked the 'readiness' of a thread
 */
static struct thread_monitor_entry *thread_monitor_entry_get(k_tid_t id)
{
   278b0:	b570      	push	{r4, r5, r6, lr}
			new_entry = entry;
			break;
		}

		/* Identify oldest entry. */
		entry_age = rpc_event_cnt - entry->cnt;
   278b2:	4b0d      	ldr	r3, [pc, #52]	; (278e8 <thread_monitor_entry_get+0x38>)
	struct thread_monitor_entry *new_entry = thread_event_monitor;
   278b4:	4c0d      	ldr	r4, [pc, #52]	; (278ec <thread_monitor_entry_get+0x3c>)
		entry_age = rpc_event_cnt - entry->cnt;
   278b6:	681a      	ldr	r2, [r3, #0]
   278b8:	250a      	movs	r5, #10
	int entry_age, oldest_entry_age = 0;
   278ba:	2600      	movs	r6, #0
	struct thread_monitor_entry *entry = thread_event_monitor;
   278bc:	4623      	mov	r3, r4
		if (entry->id == id) {
   278be:	6819      	ldr	r1, [r3, #0]
   278c0:	4281      	cmp	r1, r0
   278c2:	d00e      	beq.n	278e2 <thread_monitor_entry_get+0x32>
		} else if (entry->id == 0) {
   278c4:	b151      	cbz	r1, 278dc <thread_monitor_entry_get+0x2c>
		entry_age = rpc_event_cnt - entry->cnt;
   278c6:	6859      	ldr	r1, [r3, #4]
   278c8:	1a51      	subs	r1, r2, r1
		if (entry_age > oldest_entry_age) {
   278ca:	42b1      	cmp	r1, r6
   278cc:	bfc4      	itt	gt
   278ce:	461c      	movgt	r4, r3
   278d0:	460e      	movgt	r6, r1
	for ( ; PART_OF_ARRAY(thread_event_monitor, entry); entry++) {
   278d2:	3d01      	subs	r5, #1
   278d4:	f103 0308 	add.w	r3, r3, #8
   278d8:	d1f1      	bne.n	278be <thread_monitor_entry_get+0xe>
   278da:	4623      	mov	r3, r4
			new_entry = entry;
		}
	}

	new_entry->id = id;
	new_entry->cnt = rpc_event_cnt - 1;
   278dc:	3a01      	subs	r2, #1
	new_entry->id = id;
   278de:	6018      	str	r0, [r3, #0]
	new_entry->cnt = rpc_event_cnt - 1;
   278e0:	605a      	str	r2, [r3, #4]

	return new_entry;
}
   278e2:	4618      	mov	r0, r3
   278e4:	bd70      	pop	{r4, r5, r6, pc}
   278e6:	bf00      	nop
   278e8:	200205ec 	.word	0x200205ec
   278ec:	200205f8 	.word	0x200205f8

000278f0 <rpc_proxy_irq_handler>:
			  */

	return 1; /* We should check if scheduling decision should be made */
}

ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   278f0:	4668      	mov	r0, sp
   278f2:	f020 0107 	bic.w	r1, r0, #7
   278f6:	468d      	mov	sp, r1
   278f8:	b519      	push	{r0, r3, r4, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   278fa:	4b0d      	ldr	r3, [pc, #52]	; (27930 <rpc_proxy_irq_handler+0x40>)
   278fc:	e8d3 2fef 	ldaex	r2, [r3]
   27900:	3201      	adds	r2, #1
   27902:	e8c3 2fe1 	stlex	r1, r2, [r3]
   27906:	2900      	cmp	r1, #0
   27908:	d1f8      	bne.n	278fc <rpc_proxy_irq_handler+0xc>
{
	atomic_inc(&rpc_event_cnt);

	bsd_os_application_irq_handler();
   2790a:	f008 f82b 	bl	2f964 <bsd_os_application_irq_handler>

	struct sleeping_thread *thread;

	/* Wake up all sleeping threads. */
	SYS_SLIST_FOR_EACH_CONTAINER(&sleeping_threads, thread, node) {
   2790e:	4b09      	ldr	r3, [pc, #36]	; (27934 <rpc_proxy_irq_handler+0x44>)
   27910:	681c      	ldr	r4, [r3, #0]
   27912:	b93c      	cbnz	r4, 27924 <rpc_proxy_irq_handler+0x34>
		k_sem_give(&thread->sem);
	}

	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   27914:	f7fd fb9e 	bl	25054 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING
	sys_trace_isr_exit();
#endif
	if (maybe_swap) {
		z_arm_int_exit();
   27918:	f7fd fa86 	bl	24e28 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   2791c:	e8bd 4019 	ldmia.w	sp!, {r0, r3, r4, lr}
   27920:	4685      	mov	sp, r0
   27922:	4770      	bx	lr
   27924:	1d20      	adds	r0, r4, #4
   27926:	f00c fe91 	bl	3464c <z_impl_k_sem_give>
   2792a:	6824      	ldr	r4, [r4, #0]
	return node->next;
   2792c:	e7f1      	b.n	27912 <rpc_proxy_irq_handler+0x22>
   2792e:	bf00      	nop
   27930:	200205ec 	.word	0x200205ec
   27934:	200205f0 	.word	0x200205f0

00027938 <bsd_os_timedwait>:
{
   27938:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2793c:	4688      	mov	r8, r1
   2793e:	b089      	sub	sp, #36	; 0x24
	return z_impl_k_uptime_get();
   27940:	f012 f964 	bl	39c0c <z_impl_k_uptime_get>
	if (*timeout == 0) {
   27944:	f8d8 3000 	ldr.w	r3, [r8]
   27948:	4606      	mov	r6, r0
   2794a:	2b00      	cmp	r3, #0
   2794c:	460f      	mov	r7, r1
   2794e:	d103      	bne.n	27958 <bsd_os_timedwait+0x20>
	z_impl_k_yield();
   27950:	f00c fcf8 	bl	34344 <z_impl_k_yield>
		return NRF_ETIMEDOUT;
   27954:	203c      	movs	r0, #60	; 0x3c
   27956:	e06e      	b.n	27a36 <bsd_os_timedwait+0xfe>
		*timeout = K_FOREVER;
   27958:	bfbc      	itt	lt
   2795a:	f04f 33ff 	movlt.w	r3, #4294967295
   2795e:	f8c8 3000 	strlt.w	r3, [r8]
	return z_impl_k_sem_init(sem, initial_count, limit);
   27962:	2201      	movs	r2, #1
   27964:	2100      	movs	r1, #0
   27966:	a802      	add	r0, sp, #8
   27968:	f012 f8bd 	bl	39ae6 <z_impl_k_sem_init>
   2796c:	f10d 0a04 	add.w	sl, sp, #4
   27970:	f04f 0320 	mov.w	r3, #32
   27974:	f3ef 8b11 	mrs	fp, BASEPRI
   27978:	f383 8811 	msr	BASEPRI, r3
   2797c:	f3bf 8f6f 	isb	sy
	return z_impl_k_current_get();
   27980:	f00c fe5e 	bl	34640 <z_impl_k_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   27984:	f7ff ff94 	bl	278b0 <thread_monitor_entry_get>
	if (rpc_event_cnt != entry->cnt) {
   27988:	4933      	ldr	r1, [pc, #204]	; (27a58 <bsd_os_timedwait+0x120>)
   2798a:	6843      	ldr	r3, [r0, #4]
   2798c:	680a      	ldr	r2, [r1, #0]
   2798e:	4689      	mov	r9, r1
   27990:	4293      	cmp	r3, r2
   27992:	f04f 0300 	mov.w	r3, #0
   27996:	d108      	bne.n	279aa <bsd_os_timedwait+0x72>
	parent->next = child;
   27998:	9301      	str	r3, [sp, #4]
Z_GENLIST_APPEND(slist, snode)
   2799a:	4b30      	ldr	r3, [pc, #192]	; (27a5c <bsd_os_timedwait+0x124>)
   2799c:	685a      	ldr	r2, [r3, #4]
   2799e:	2a00      	cmp	r2, #0
   279a0:	d14c      	bne.n	27a3c <bsd_os_timedwait+0x104>
	list->head = node;
   279a2:	e9c3 aa00 	strd	sl, sl, [r3]
		allow_to_sleep = true;
   279a6:	2301      	movs	r3, #1
   279a8:	e000      	b.n	279ac <bsd_os_timedwait+0x74>
	entry->cnt = rpc_event_cnt;
   279aa:	6042      	str	r2, [r0, #4]
	__asm__ volatile(
   279ac:	f38b 8811 	msr	BASEPRI, fp
   279b0:	f3bf 8f6f 	isb	sy
	if (!sleeping_thread_add(&thread)) {
   279b4:	2b00      	cmp	r3, #0
   279b6:	d03d      	beq.n	27a34 <bsd_os_timedwait+0xfc>
	(void)k_sem_take(&thread.sem, *timeout);
   279b8:	f8d8 1000 	ldr.w	r1, [r8]
	return z_impl_k_sem_take(sem, timeout);
   279bc:	a802      	add	r0, sp, #8
   279be:	f00c fe8f 	bl	346e0 <z_impl_k_sem_take>
	__asm__ volatile(
   279c2:	f04f 0320 	mov.w	r3, #32
   279c6:	f3ef 8b11 	mrs	fp, BASEPRI
   279ca:	f383 8811 	msr	BASEPRI, r3
   279ce:	f3bf 8f6f 	isb	sy
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   279d2:	2000      	movs	r0, #0
   279d4:	4b21      	ldr	r3, [pc, #132]	; (27a5c <bsd_os_timedwait+0x124>)
   279d6:	681a      	ldr	r2, [r3, #0]
   279d8:	b152      	cbz	r2, 279f0 <bsd_os_timedwait+0xb8>
   279da:	4552      	cmp	r2, sl
   279dc:	d139      	bne.n	27a52 <bsd_os_timedwait+0x11a>
Z_GENLIST_REMOVE(slist, snode)
   279de:	9901      	ldr	r1, [sp, #4]
   279e0:	bb88      	cbnz	r0, 27a46 <bsd_os_timedwait+0x10e>
   279e2:	6858      	ldr	r0, [r3, #4]
	list->head = node;
   279e4:	6019      	str	r1, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   279e6:	4290      	cmp	r0, r2
   279e8:	d100      	bne.n	279ec <bsd_os_timedwait+0xb4>
	list->tail = node;
   279ea:	6059      	str	r1, [r3, #4]
	parent->next = child;
   279ec:	2300      	movs	r3, #0
   279ee:	9301      	str	r3, [sp, #4]
	return z_impl_k_current_get();
   279f0:	f00c fe26 	bl	34640 <z_impl_k_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   279f4:	f7ff ff5c 	bl	278b0 <thread_monitor_entry_get>
	entry->cnt = rpc_event_cnt;
   279f8:	f8d9 3000 	ldr.w	r3, [r9]
   279fc:	6043      	str	r3, [r0, #4]
	__asm__ volatile(
   279fe:	f38b 8811 	msr	BASEPRI, fp
   27a02:	f3bf 8f6f 	isb	sy
	if (*timeout == K_FOREVER) {
   27a06:	f8d8 9000 	ldr.w	r9, [r8]
   27a0a:	f1b9 3fff 	cmp.w	r9, #4294967295
   27a0e:	d011      	beq.n	27a34 <bsd_os_timedwait+0xfc>
	return z_impl_k_uptime_get();
   27a10:	f012 f8fc 	bl	39c0c <z_impl_k_uptime_get>
	remaining = *timeout - (k_uptime_get() - start);
   27a14:	eb16 0209 	adds.w	r2, r6, r9
   27a18:	eb47 73e9 	adc.w	r3, r7, r9, asr #31
   27a1c:	1a14      	subs	r4, r2, r0
   27a1e:	eb63 0501 	sbc.w	r5, r3, r1
	*timeout = remaining > 0 ? remaining : 0;
   27a22:	2c00      	cmp	r4, #0
   27a24:	f175 0300 	sbcs.w	r3, r5, #0
   27a28:	bfb8      	it	lt
   27a2a:	2400      	movlt	r4, #0
   27a2c:	f8c8 4000 	str.w	r4, [r8]
	if (*timeout == 0) {
   27a30:	2c00      	cmp	r4, #0
   27a32:	d08f      	beq.n	27954 <bsd_os_timedwait+0x1c>
	return 0;
   27a34:	2000      	movs	r0, #0
}
   27a36:	b009      	add	sp, #36	; 0x24
   27a38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   27a3c:	f8c2 a000 	str.w	sl, [r2]
	list->tail = node;
   27a40:	f8c3 a004 	str.w	sl, [r3, #4]
   27a44:	e7af      	b.n	279a6 <bsd_os_timedwait+0x6e>
	parent->next = child;
   27a46:	6001      	str	r1, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   27a48:	6859      	ldr	r1, [r3, #4]
   27a4a:	4291      	cmp	r1, r2
	list->tail = node;
   27a4c:	bf08      	it	eq
   27a4e:	6058      	streq	r0, [r3, #4]
   27a50:	e7cc      	b.n	279ec <bsd_os_timedwait+0xb4>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   27a52:	4610      	mov	r0, r2
   27a54:	6812      	ldr	r2, [r2, #0]
   27a56:	e7bf      	b.n	279d8 <bsd_os_timedwait+0xa0>
   27a58:	200205ec 	.word	0x200205ec
   27a5c:	200205f0 	.word	0x200205f0

00027a60 <bsd_os_errno_set>:
	switch (err_code) {
   27a60:	282d      	cmp	r0, #45	; 0x2d
{
   27a62:	b510      	push	{r4, lr}
   27a64:	4604      	mov	r4, r0
	switch (err_code) {
   27a66:	f000 80a8 	beq.w	27bba <bsd_os_errno_set+0x15a>
   27a6a:	dc50      	bgt.n	27b0e <bsd_os_errno_set+0xae>
   27a6c:	2816      	cmp	r0, #22
   27a6e:	d009      	beq.n	27a84 <bsd_os_errno_set+0x24>
   27a70:	dc38      	bgt.n	27ae4 <bsd_os_errno_set+0x84>
   27a72:	2808      	cmp	r0, #8
   27a74:	d006      	beq.n	27a84 <bsd_os_errno_set+0x24>
   27a76:	dc09      	bgt.n	27a8c <bsd_os_errno_set+0x2c>
   27a78:	2802      	cmp	r0, #2
   27a7a:	d003      	beq.n	27a84 <bsd_os_errno_set+0x24>
   27a7c:	2805      	cmp	r0, #5
   27a7e:	d001      	beq.n	27a84 <bsd_os_errno_set+0x24>
   27a80:	2801      	cmp	r0, #1
   27a82:	d10c      	bne.n	27a9e <bsd_os_errno_set+0x3e>
		errno = ENOBUFS;
   27a84:	f010 fb17 	bl	380b6 <__errno>
   27a88:	6004      	str	r4, [r0, #0]
}
   27a8a:	bd10      	pop	{r4, pc}
	switch (err_code) {
   27a8c:	280c      	cmp	r0, #12
   27a8e:	d0f9      	beq.n	27a84 <bsd_os_errno_set+0x24>
   27a90:	dc01      	bgt.n	27a96 <bsd_os_errno_set+0x36>
   27a92:	2809      	cmp	r0, #9
   27a94:	e7f5      	b.n	27a82 <bsd_os_errno_set+0x22>
   27a96:	280d      	cmp	r0, #13
   27a98:	d0f4      	beq.n	27a84 <bsd_os_errno_set+0x24>
   27a9a:	280e      	cmp	r0, #14
   27a9c:	d074      	beq.n	27b88 <bsd_os_errno_set+0x128>
		__ASSERT(false, "Untranslated errno %d set by bsdlib!", err_code);
   27a9e:	f44f 73a5 	mov.w	r3, #330	; 0x14a
   27aa2:	4a63      	ldr	r2, [pc, #396]	; (27c30 <bsd_os_errno_set+0x1d0>)
   27aa4:	4963      	ldr	r1, [pc, #396]	; (27c34 <bsd_os_errno_set+0x1d4>)
   27aa6:	4864      	ldr	r0, [pc, #400]	; (27c38 <bsd_os_errno_set+0x1d8>)
   27aa8:	f010 f90a 	bl	37cc0 <printk>
   27aac:	4621      	mov	r1, r4
   27aae:	4863      	ldr	r0, [pc, #396]	; (27c3c <bsd_os_errno_set+0x1dc>)
   27ab0:	f010 f906 	bl	37cc0 <printk>
   27ab4:	f44f 71a5 	mov.w	r1, #330	; 0x14a
   27ab8:	485d      	ldr	r0, [pc, #372]	; (27c30 <bsd_os_errno_set+0x1d0>)
   27aba:	f010 f947 	bl	37d4c <assert_post_action>
		LOG_ERR("Untranslated errno %d set by bsdlib!", err_code);
   27abe:	2301      	movs	r3, #1
   27ac0:	f04f 0000 	mov.w	r0, #0
   27ac4:	4a5e      	ldr	r2, [pc, #376]	; (27c40 <bsd_os_errno_set+0x1e0>)
   27ac6:	f363 0007 	bfi	r0, r3, #0, #8
   27aca:	4b5e      	ldr	r3, [pc, #376]	; (27c44 <bsd_os_errno_set+0x1e4>)
   27acc:	495e      	ldr	r1, [pc, #376]	; (27c48 <bsd_os_errno_set+0x1e8>)
   27ace:	1a9b      	subs	r3, r3, r2
   27ad0:	08db      	lsrs	r3, r3, #3
   27ad2:	f363 108f 	bfi	r0, r3, #6, #10
   27ad6:	4622      	mov	r2, r4
   27ad8:	f010 f949 	bl	37d6e <log_string_sync>
		errno = 0xBAADBAAD;
   27adc:	f010 faeb 	bl	380b6 <__errno>
   27ae0:	4b5a      	ldr	r3, [pc, #360]	; (27c4c <bsd_os_errno_set+0x1ec>)
   27ae2:	e054      	b.n	27b8e <bsd_os_errno_set+0x12e>
	switch (err_code) {
   27ae4:	2828      	cmp	r0, #40	; 0x28
   27ae6:	f000 809f 	beq.w	27c28 <bsd_os_errno_set+0x1c8>
   27aea:	dc05      	bgt.n	27af8 <bsd_os_errno_set+0x98>
   27aec:	2823      	cmp	r0, #35	; 0x23
   27aee:	d050      	beq.n	27b92 <bsd_os_errno_set+0x132>
   27af0:	2825      	cmp	r0, #37	; 0x25
   27af2:	d052      	beq.n	27b9a <bsd_os_errno_set+0x13a>
   27af4:	2818      	cmp	r0, #24
   27af6:	e7c4      	b.n	27a82 <bsd_os_errno_set+0x22>
   27af8:	282a      	cmp	r0, #42	; 0x2a
   27afa:	d056      	beq.n	27baa <bsd_os_errno_set+0x14a>
   27afc:	db51      	blt.n	27ba2 <bsd_os_errno_set+0x142>
   27afe:	282b      	cmp	r0, #43	; 0x2b
   27b00:	d057      	beq.n	27bb2 <bsd_os_errno_set+0x152>
   27b02:	282c      	cmp	r0, #44	; 0x2c
   27b04:	d1cb      	bne.n	27a9e <bsd_os_errno_set+0x3e>
		errno = ESOCKTNOSUPPORT;
   27b06:	f010 fad6 	bl	380b6 <__errno>
   27b0a:	237c      	movs	r3, #124	; 0x7c
   27b0c:	e03f      	b.n	27b8e <bsd_os_errno_set+0x12e>
	switch (err_code) {
   27b0e:	283c      	cmp	r0, #60	; 0x3c
   27b10:	d06b      	beq.n	27bea <bsd_os_errno_set+0x18a>
   27b12:	dc1d      	bgt.n	27b50 <bsd_os_errno_set+0xf0>
   27b14:	2833      	cmp	r0, #51	; 0x33
   27b16:	d05c      	beq.n	27bd2 <bsd_os_errno_set+0x172>
   27b18:	dc09      	bgt.n	27b2e <bsd_os_errno_set+0xce>
   27b1a:	2830      	cmp	r0, #48	; 0x30
   27b1c:	d051      	beq.n	27bc2 <bsd_os_errno_set+0x162>
   27b1e:	2832      	cmp	r0, #50	; 0x32
   27b20:	d053      	beq.n	27bca <bsd_os_errno_set+0x16a>
   27b22:	282f      	cmp	r0, #47	; 0x2f
   27b24:	d1bb      	bne.n	27a9e <bsd_os_errno_set+0x3e>
		errno = EAFNOSUPPORT;
   27b26:	f010 fac6 	bl	380b6 <__errno>
   27b2a:	236a      	movs	r3, #106	; 0x6a
   27b2c:	e02f      	b.n	27b8e <bsd_os_errno_set+0x12e>
	switch (err_code) {
   27b2e:	2836      	cmp	r0, #54	; 0x36
   27b30:	d053      	beq.n	27bda <bsd_os_errno_set+0x17a>
   27b32:	dc05      	bgt.n	27b40 <bsd_os_errno_set+0xe0>
   27b34:	2834      	cmp	r0, #52	; 0x34
   27b36:	d1b2      	bne.n	27a9e <bsd_os_errno_set+0x3e>
		errno = ENETRESET;
   27b38:	f010 fabd 	bl	380b6 <__errno>
   27b3c:	237e      	movs	r3, #126	; 0x7e
   27b3e:	e026      	b.n	27b8e <bsd_os_errno_set+0x12e>
	switch (err_code) {
   27b40:	2838      	cmp	r0, #56	; 0x38
   27b42:	d04e      	beq.n	27be2 <bsd_os_errno_set+0x182>
   27b44:	2839      	cmp	r0, #57	; 0x39
   27b46:	d1aa      	bne.n	27a9e <bsd_os_errno_set+0x3e>
		errno = ENOTCONN;
   27b48:	f010 fab5 	bl	380b6 <__errno>
   27b4c:	2380      	movs	r3, #128	; 0x80
   27b4e:	e01e      	b.n	27b8e <bsd_os_errno_set+0x12e>
	switch (err_code) {
   27b50:	287d      	cmp	r0, #125	; 0x7d
   27b52:	d056      	beq.n	27c02 <bsd_os_errno_set+0x1a2>
   27b54:	dc0c      	bgt.n	27b70 <bsd_os_errno_set+0x110>
   27b56:	2870      	cmp	r0, #112	; 0x70
   27b58:	d04b      	beq.n	27bf2 <bsd_os_errno_set+0x192>
   27b5a:	dc01      	bgt.n	27b60 <bsd_os_errno_set+0x100>
   27b5c:	2869      	cmp	r0, #105	; 0x69
   27b5e:	e790      	b.n	27a82 <bsd_os_errno_set+0x22>
   27b60:	2872      	cmp	r0, #114	; 0x72
   27b62:	d04a      	beq.n	27bfa <bsd_os_errno_set+0x19a>
   27b64:	2873      	cmp	r0, #115	; 0x73
   27b66:	d19a      	bne.n	27a9e <bsd_os_errno_set+0x3e>
		errno = EINPROGRESS;
   27b68:	f010 faa5 	bl	380b6 <__errno>
   27b6c:	2377      	movs	r3, #119	; 0x77
   27b6e:	e00e      	b.n	27b8e <bsd_os_errno_set+0x12e>
	switch (err_code) {
   27b70:	287f      	cmp	r0, #127	; 0x7f
   27b72:	d04f      	beq.n	27c14 <bsd_os_errno_set+0x1b4>
   27b74:	db49      	blt.n	27c0a <bsd_os_errno_set+0x1aa>
   27b76:	2880      	cmp	r0, #128	; 0x80
   27b78:	d051      	beq.n	27c1e <bsd_os_errno_set+0x1be>
   27b7a:	2881      	cmp	r0, #129	; 0x81
   27b7c:	d18f      	bne.n	27a9e <bsd_os_errno_set+0x3e>
		errno = EKEYREJECTED;
   27b7e:	f010 fa9a 	bl	380b6 <__errno>
   27b82:	f240 73d4 	movw	r3, #2004	; 0x7d4
   27b86:	e002      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = EFAULT;
   27b88:	f010 fa95 	bl	380b6 <__errno>
   27b8c:	230e      	movs	r3, #14
		errno = 0xBAADBAAD;
   27b8e:	6003      	str	r3, [r0, #0]
}
   27b90:	e77b      	b.n	27a8a <bsd_os_errno_set+0x2a>
		errno = EAGAIN;
   27b92:	f010 fa90 	bl	380b6 <__errno>
   27b96:	230b      	movs	r3, #11
   27b98:	e7f9      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = EDOM;
   27b9a:	f010 fa8c 	bl	380b6 <__errno>
   27b9e:	2321      	movs	r3, #33	; 0x21
   27ba0:	e7f5      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = EPROTOTYPE;
   27ba2:	f010 fa88 	bl	380b6 <__errno>
   27ba6:	236b      	movs	r3, #107	; 0x6b
   27ba8:	e7f1      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = ENOPROTOOPT;
   27baa:	f010 fa84 	bl	380b6 <__errno>
   27bae:	236d      	movs	r3, #109	; 0x6d
   27bb0:	e7ed      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = EPROTONOSUPPORT;
   27bb2:	f010 fa80 	bl	380b6 <__errno>
   27bb6:	237b      	movs	r3, #123	; 0x7b
   27bb8:	e7e9      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = EOPNOTSUPP;
   27bba:	f010 fa7c 	bl	380b6 <__errno>
   27bbe:	235f      	movs	r3, #95	; 0x5f
   27bc0:	e7e5      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = EADDRINUSE;
   27bc2:	f010 fa78 	bl	380b6 <__errno>
   27bc6:	2370      	movs	r3, #112	; 0x70
   27bc8:	e7e1      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = ENETDOWN;
   27bca:	f010 fa74 	bl	380b6 <__errno>
   27bce:	2373      	movs	r3, #115	; 0x73
   27bd0:	e7dd      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = ENETUNREACH;
   27bd2:	f010 fa70 	bl	380b6 <__errno>
   27bd6:	2372      	movs	r3, #114	; 0x72
   27bd8:	e7d9      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = ECONNRESET;
   27bda:	f010 fa6c 	bl	380b6 <__errno>
   27bde:	2368      	movs	r3, #104	; 0x68
   27be0:	e7d5      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = EISCONN;
   27be2:	f010 fa68 	bl	380b6 <__errno>
   27be6:	237f      	movs	r3, #127	; 0x7f
   27be8:	e7d1      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = ETIMEDOUT;
   27bea:	f010 fa64 	bl	380b6 <__errno>
   27bee:	2374      	movs	r3, #116	; 0x74
   27bf0:	e7cd      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = EHOSTDOWN;
   27bf2:	f010 fa60 	bl	380b6 <__errno>
   27bf6:	2375      	movs	r3, #117	; 0x75
   27bf8:	e7c9      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = EALREADY;
   27bfa:	f010 fa5c 	bl	380b6 <__errno>
   27bfe:	2378      	movs	r3, #120	; 0x78
   27c00:	e7c5      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = ECANCELED;
   27c02:	f010 fa58 	bl	380b6 <__errno>
   27c06:	238c      	movs	r3, #140	; 0x8c
   27c08:	e7c1      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = ENOKEY;
   27c0a:	f010 fa54 	bl	380b6 <__errno>
   27c0e:	f240 73d1 	movw	r3, #2001	; 0x7d1
   27c12:	e7bc      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = EKEYEXPIRED;
   27c14:	f010 fa4f 	bl	380b6 <__errno>
   27c18:	f240 73d2 	movw	r3, #2002	; 0x7d2
   27c1c:	e7b7      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = EKEYREVOKED;
   27c1e:	f010 fa4a 	bl	380b6 <__errno>
   27c22:	f240 73d3 	movw	r3, #2003	; 0x7d3
   27c26:	e7b2      	b.n	27b8e <bsd_os_errno_set+0x12e>
		errno = EMSGSIZE;
   27c28:	f010 fa45 	bl	380b6 <__errno>
   27c2c:	237a      	movs	r3, #122	; 0x7a
   27c2e:	e7ae      	b.n	27b8e <bsd_os_errno_set+0x12e>
   27c30:	0003df63 	.word	0x0003df63
   27c34:	0003f10e 	.word	0x0003f10e
   27c38:	0003baac 	.word	0x0003baac
   27c3c:	0003df87 	.word	0x0003df87
   27c40:	0003ade0 	.word	0x0003ade0
   27c44:	0003ae00 	.word	0x0003ae00
   27c48:	0003dfae 	.word	0x0003dfae
   27c4c:	baadbaad 	.word	0xbaadbaad

00027c50 <bsd_os_application_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   27c50:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   27c54:	4b01      	ldr	r3, [pc, #4]	; (27c5c <bsd_os_application_irq_set+0xc>)
   27c56:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   27c5a:	4770      	bx	lr
   27c5c:	e000e100 	.word	0xe000e100

00027c60 <bsd_os_application_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   27c60:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   27c64:	4b01      	ldr	r3, [pc, #4]	; (27c6c <bsd_os_application_irq_clear+0xc>)
   27c66:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   27c6a:	4770      	bx	lr
   27c6c:	e000e100 	.word	0xe000e100

00027c70 <bsd_os_trace_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   27c70:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   27c74:	4b01      	ldr	r3, [pc, #4]	; (27c7c <bsd_os_trace_irq_set+0xc>)
   27c76:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   27c7a:	4770      	bx	lr
   27c7c:	e000e100 	.word	0xe000e100

00027c80 <bsd_os_trace_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   27c80:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   27c84:	4b01      	ldr	r3, [pc, #4]	; (27c8c <bsd_os_trace_irq_clear+0xc>)
   27c86:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   27c8a:	4770      	bx	lr
   27c8c:	e000e100 	.word	0xe000e100

00027c90 <bsd_os_init>:
#endif
}

/* This function is called by bsd_init and must not be called explicitly. */
void bsd_os_init(void)
{
   27c90:	b508      	push	{r3, lr}
	list->head = NULL;
   27c92:	2300      	movs	r3, #0
   27c94:	4a07      	ldr	r2, [pc, #28]	; (27cb4 <bsd_os_init+0x24>)
	list->tail = NULL;
   27c96:	e9c2 3300 	strd	r3, r3, [r2]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   27c9a:	4a07      	ldr	r2, [pc, #28]	; (27cb8 <bsd_os_init+0x28>)
   27c9c:	e8d2 1fef 	ldaex	r1, [r2]
   27ca0:	e8c2 3fe0 	stlex	r0, r3, [r2]
   27ca4:	2800      	cmp	r0, #0
   27ca6:	d1f9      	bne.n	27c9c <bsd_os_init+0xc>
	sys_slist_init(&sleeping_threads);
	atomic_clear(&rpc_event_cnt);

	read_task_create();
   27ca8:	f011 f927 	bl	38efa <read_task_create>

	/* Configure and enable modem tracing over UART. */
	trace_uart_init();
	trace_task_create();
}
   27cac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	trace_task_create();
   27cb0:	f011 b918 	b.w	38ee4 <trace_task_create>
   27cb4:	200205f0 	.word	0x200205f0
   27cb8:	200205ec 	.word	0x200205ec

00027cbc <z_to_nrf_optname>:
static int z_to_nrf_optname(int z_in_level, int z_in_optname,
			    int *nrf_out_optname)
{
	int retval = 0;

	switch (z_in_level) {
   27cbc:	f5b0 7f8d 	cmp.w	r0, #282	; 0x11a
   27cc0:	d03c      	beq.n	27d3c <z_to_nrf_optname+0x80>
   27cc2:	dc04      	bgt.n	27cce <z_to_nrf_optname+0x12>
   27cc4:	2801      	cmp	r0, #1
   27cc6:	d044      	beq.n	27d52 <z_to_nrf_optname+0x96>
			break;
		}
		break;

	default:
		retval = -1;
   27cc8:	f04f 30ff 	mov.w	r0, #4294967295
		break;
	}

	return retval;
}
   27ccc:	4770      	bx	lr
	switch (z_in_level) {
   27cce:	f240 2302 	movw	r3, #514	; 0x202
   27cd2:	4298      	cmp	r0, r3
   27cd4:	d052      	beq.n	27d7c <z_to_nrf_optname+0xc0>
   27cd6:	f240 2303 	movw	r3, #515	; 0x203
   27cda:	4298      	cmp	r0, r3
   27cdc:	d1f4      	bne.n	27cc8 <z_to_nrf_optname+0xc>
		switch (z_in_optname) {
   27cde:	3901      	subs	r1, #1
   27ce0:	2913      	cmp	r1, #19
   27ce2:	d8f1      	bhi.n	27cc8 <z_to_nrf_optname+0xc>
   27ce4:	a301      	add	r3, pc, #4	; (adr r3, 27cec <z_to_nrf_optname+0x30>)
   27ce6:	f853 f021 	ldr.w	pc, [r3, r1, lsl #2]
   27cea:	bf00      	nop
   27cec:	00027d89 	.word	0x00027d89
   27cf0:	00027d4d 	.word	0x00027d4d
   27cf4:	00027d6d 	.word	0x00027d6d
   27cf8:	00027d5f 	.word	0x00027d5f
   27cfc:	00027d71 	.word	0x00027d71
   27d00:	00027d75 	.word	0x00027d75
   27d04:	00027d79 	.word	0x00027d79
   27d08:	00027cc9 	.word	0x00027cc9
   27d0c:	00027cc9 	.word	0x00027cc9
   27d10:	00027cc9 	.word	0x00027cc9
   27d14:	00027cc9 	.word	0x00027cc9
   27d18:	00027cc9 	.word	0x00027cc9
   27d1c:	00027cc9 	.word	0x00027cc9
   27d20:	00027cc9 	.word	0x00027cc9
   27d24:	00027cc9 	.word	0x00027cc9
   27d28:	00027cc9 	.word	0x00027cc9
   27d2c:	00027cc9 	.word	0x00027cc9
   27d30:	00027cc9 	.word	0x00027cc9
   27d34:	00027cc9 	.word	0x00027cc9
   27d38:	00027d63 	.word	0x00027d63
		switch (z_in_optname) {
   27d3c:	3901      	subs	r1, #1
   27d3e:	2905      	cmp	r1, #5
   27d40:	d8c2      	bhi.n	27cc8 <z_to_nrf_optname+0xc>
   27d42:	e8df f001 	tbb	[pc, r1]
   27d46:	1503      	.short	0x1503
   27d48:	210c1917 	.word	0x210c1917
			*nrf_out_optname = NRF_SO_SEC_TAG_LIST;
   27d4c:	2302      	movs	r3, #2
			*nrf_out_optname = NRF_SO_DFU_OFFSET;
   27d4e:	6013      	str	r3, [r2, #0]
   27d50:	e00a      	b.n	27d68 <z_to_nrf_optname+0xac>
		switch (z_in_optname) {
   27d52:	2914      	cmp	r1, #20
   27d54:	d005      	beq.n	27d62 <z_to_nrf_optname+0xa6>
   27d56:	2919      	cmp	r1, #25
   27d58:	d005      	beq.n	27d66 <z_to_nrf_optname+0xaa>
   27d5a:	2904      	cmp	r1, #4
   27d5c:	d1b4      	bne.n	27cc8 <z_to_nrf_optname+0xc>
			*nrf_out_optname = NRF_SO_SEC_PEER_VERIFY;
   27d5e:	2304      	movs	r3, #4
   27d60:	e7f5      	b.n	27d4e <z_to_nrf_optname+0x92>
			*nrf_out_optname = NRF_SO_RCVTIMEO;
   27d62:	2314      	movs	r3, #20
   27d64:	e7f3      	b.n	27d4e <z_to_nrf_optname+0x92>
			*nrf_out_optname = NRF_SO_BINDTODEVICE;
   27d66:	6011      	str	r1, [r2, #0]
	int retval = 0;
   27d68:	2000      	movs	r0, #0
			break;
   27d6a:	4770      	bx	lr
			*nrf_out_optname = NRF_SO_DFU_TIMEO;
   27d6c:	2303      	movs	r3, #3
   27d6e:	e7ee      	b.n	27d4e <z_to_nrf_optname+0x92>
			*nrf_out_optname = NRF_SO_DFU_REVERT;
   27d70:	2305      	movs	r3, #5
   27d72:	e7ec      	b.n	27d4e <z_to_nrf_optname+0x92>
			*nrf_out_optname = NRF_SO_DFU_BACKUP_DELETE;
   27d74:	2306      	movs	r3, #6
   27d76:	e7ea      	b.n	27d4e <z_to_nrf_optname+0x92>
			*nrf_out_optname = NRF_SO_DFU_OFFSET;
   27d78:	2307      	movs	r3, #7
   27d7a:	e7e8      	b.n	27d4e <z_to_nrf_optname+0x92>
		switch (z_in_optname) {
   27d7c:	2902      	cmp	r1, #2
   27d7e:	d0e5      	beq.n	27d4c <z_to_nrf_optname+0x90>
   27d80:	2903      	cmp	r1, #3
   27d82:	d0f3      	beq.n	27d6c <z_to_nrf_optname+0xb0>
   27d84:	2901      	cmp	r1, #1
   27d86:	d19f      	bne.n	27cc8 <z_to_nrf_optname+0xc>
			*nrf_out_optname = NRF_SO_SEC_ROLE;
   27d88:	2301      	movs	r3, #1
   27d8a:	e7e0      	b.n	27d4e <z_to_nrf_optname+0x92>

00027d8c <nrf91_socket_iface_init>:

static void nrf91_socket_iface_init(struct net_if *iface)
{
	nrf91_socket_iface_data.iface = iface;

	iface->if_dev->offloaded = true;
   27d8c:	2201      	movs	r2, #1
	nrf91_socket_iface_data.iface = iface;
   27d8e:	4b03      	ldr	r3, [pc, #12]	; (27d9c <nrf91_socket_iface_init+0x10>)
   27d90:	6018      	str	r0, [r3, #0]
	iface->if_dev->offloaded = true;
   27d92:	6803      	ldr	r3, [r0, #0]

	socket_offload_register(&nrf91_socket_offload_ops);
   27d94:	4802      	ldr	r0, [pc, #8]	; (27da0 <nrf91_socket_iface_init+0x14>)
	iface->if_dev->offloaded = true;
   27d96:	769a      	strb	r2, [r3, #26]
	socket_offload_register(&nrf91_socket_offload_ops);
   27d98:	f7fc bc60 	b.w	2465c <socket_offload_register>
   27d9c:	20020648 	.word	0x20020648
   27da0:	0003b4d4 	.word	0x0003b4d4

00027da4 <close>:
{
   27da4:	b570      	push	{r4, r5, r6, lr}
	__ASSERT_NO_MSG(socket_ops);
   27da6:	4c10      	ldr	r4, [pc, #64]	; (27de8 <close+0x44>)
{
   27da8:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(socket_ops);
   27daa:	6823      	ldr	r3, [r4, #0]
   27dac:	b94b      	cbnz	r3, 27dc2 <close+0x1e>
   27dae:	490f      	ldr	r1, [pc, #60]	; (27dec <close+0x48>)
   27db0:	480f      	ldr	r0, [pc, #60]	; (27df0 <close+0x4c>)
   27db2:	2321      	movs	r3, #33	; 0x21
   27db4:	4a0f      	ldr	r2, [pc, #60]	; (27df4 <close+0x50>)
   27db6:	f00f ff83 	bl	37cc0 <printk>
   27dba:	2121      	movs	r1, #33	; 0x21
   27dbc:	480d      	ldr	r0, [pc, #52]	; (27df4 <close+0x50>)
   27dbe:	f00f ffc5 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->close);
   27dc2:	6823      	ldr	r3, [r4, #0]
   27dc4:	685b      	ldr	r3, [r3, #4]
   27dc6:	b94b      	cbnz	r3, 27ddc <close+0x38>
   27dc8:	490b      	ldr	r1, [pc, #44]	; (27df8 <close+0x54>)
   27dca:	4809      	ldr	r0, [pc, #36]	; (27df0 <close+0x4c>)
   27dcc:	2322      	movs	r3, #34	; 0x22
   27dce:	4a09      	ldr	r2, [pc, #36]	; (27df4 <close+0x50>)
   27dd0:	f00f ff76 	bl	37cc0 <printk>
   27dd4:	2122      	movs	r1, #34	; 0x22
   27dd6:	4807      	ldr	r0, [pc, #28]	; (27df4 <close+0x50>)
   27dd8:	f00f ffb8 	bl	37d4c <assert_post_action>
	return socket_ops->close(sock);
   27ddc:	6823      	ldr	r3, [r4, #0]
   27dde:	4628      	mov	r0, r5
}
   27de0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return socket_ops->close(sock);
   27de4:	685b      	ldr	r3, [r3, #4]
   27de6:	4718      	bx	r3
   27de8:	200204c0 	.word	0x200204c0
   27dec:	0003c541 	.word	0x0003c541
   27df0:	0003baac 	.word	0x0003baac
   27df4:	0003c511 	.word	0x0003c511
   27df8:	0003da87 	.word	0x0003da87

00027dfc <callback_worker>:

	return new_len;
}

static void callback_worker(struct k_work *item)
{
   27dfc:	b507      	push	{r0, r1, r2, lr}
	struct callback_work_item *data =
   27dfe:	9001      	str	r0, [sp, #4]
		CONTAINER_OF(item, struct callback_work_item, work);

	if (data != NULL) {
   27e00:	b118      	cbz	r0, 27e0a <callback_worker+0xe>
		data->callback(data->data);
   27e02:	f8d0 3a98 	ldr.w	r3, [r0, #2712]	; 0xa98
   27e06:	300c      	adds	r0, #12
   27e08:	4798      	blx	r3
	}

	k_mem_slab_free(&rsp_work_items, (void **)&data);
   27e0a:	a901      	add	r1, sp, #4
   27e0c:	4802      	ldr	r0, [pc, #8]	; (27e18 <callback_worker+0x1c>)
   27e0e:	f00a fcb1 	bl	32774 <k_mem_slab_free>
}
   27e12:	b003      	add	sp, #12
   27e14:	f85d fb04 	ldr.w	pc, [sp], #4
   27e18:	2002cb80 	.word	0x2002cb80

00027e1c <open_socket>:
{
   27e1c:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(socket_ops);
   27e1e:	4c16      	ldr	r4, [pc, #88]	; (27e78 <open_socket+0x5c>)
   27e20:	6823      	ldr	r3, [r4, #0]
   27e22:	b94b      	cbnz	r3, 27e38 <open_socket+0x1c>
   27e24:	4915      	ldr	r1, [pc, #84]	; (27e7c <open_socket+0x60>)
   27e26:	4816      	ldr	r0, [pc, #88]	; (27e80 <open_socket+0x64>)
   27e28:	2319      	movs	r3, #25
   27e2a:	4a16      	ldr	r2, [pc, #88]	; (27e84 <open_socket+0x68>)
   27e2c:	f00f ff48 	bl	37cc0 <printk>
   27e30:	2119      	movs	r1, #25
   27e32:	4814      	ldr	r0, [pc, #80]	; (27e84 <open_socket+0x68>)
   27e34:	f00f ff8a 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->socket);
   27e38:	6823      	ldr	r3, [r4, #0]
   27e3a:	681b      	ldr	r3, [r3, #0]
   27e3c:	b94b      	cbnz	r3, 27e52 <open_socket+0x36>
   27e3e:	4912      	ldr	r1, [pc, #72]	; (27e88 <open_socket+0x6c>)
   27e40:	480f      	ldr	r0, [pc, #60]	; (27e80 <open_socket+0x64>)
   27e42:	231a      	movs	r3, #26
   27e44:	4a0f      	ldr	r2, [pc, #60]	; (27e84 <open_socket+0x68>)
   27e46:	f00f ff3b 	bl	37cc0 <printk>
   27e4a:	211a      	movs	r1, #26
   27e4c:	480d      	ldr	r0, [pc, #52]	; (27e84 <open_socket+0x68>)
   27e4e:	f00f ff7d 	bl	37d4c <assert_post_action>
	return socket_ops->socket(family, type, proto);
   27e52:	6823      	ldr	r3, [r4, #0]
   27e54:	f240 2201 	movw	r2, #513	; 0x201
   27e58:	681b      	ldr	r3, [r3, #0]
   27e5a:	2102      	movs	r1, #2
   27e5c:	2066      	movs	r0, #102	; 0x66
   27e5e:	4798      	blx	r3
	common_socket_fd = socket(AF_LTE, SOCK_DGRAM, NPROTO_AT);
   27e60:	4b0a      	ldr	r3, [pc, #40]	; (27e8c <open_socket+0x70>)
   27e62:	6018      	str	r0, [r3, #0]
	if (common_socket_fd == -1) {
   27e64:	3001      	adds	r0, #1
   27e66:	d104      	bne.n	27e72 <open_socket+0x56>
		return -errno;
   27e68:	f010 f925 	bl	380b6 <__errno>
   27e6c:	6800      	ldr	r0, [r0, #0]
   27e6e:	4240      	negs	r0, r0
}
   27e70:	bd10      	pop	{r4, pc}
	return 0;
   27e72:	2000      	movs	r0, #0
   27e74:	e7fc      	b.n	27e70 <open_socket+0x54>
   27e76:	bf00      	nop
   27e78:	200204c0 	.word	0x200204c0
   27e7c:	0003c541 	.word	0x0003c541
   27e80:	0003baac 	.word	0x0003baac
   27e84:	0003c511 	.word	0x0003c511
   27e88:	0003da99 	.word	0x0003da99
   27e8c:	2002064c 	.word	0x2002064c

00027e90 <at_write>:
		}
	}
}

static inline int at_write(const char *const cmd, enum at_cmd_state *state)
{
   27e90:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   27e94:	4680      	mov	r8, r0
   27e96:	460d      	mov	r5, r1
	int bytes_sent;
	int bytes_to_send = strlen(cmd);
   27e98:	f7f5 f95e 	bl	1d158 <strlen>
	__ASSERT_NO_MSG(socket_ops);
   27e9c:	4c30      	ldr	r4, [pc, #192]	; (27f60 <at_write+0xd0>)
	struct return_state_object ret;

	LOG_DBG("Sending command %s", log_strdup(cmd));

	bytes_sent = send(common_socket_fd, cmd, bytes_to_send, 0);
   27e9e:	4b31      	ldr	r3, [pc, #196]	; (27f64 <at_write+0xd4>)
	int bytes_to_send = strlen(cmd);
   27ea0:	4606      	mov	r6, r0
	bytes_sent = send(common_socket_fd, cmd, bytes_to_send, 0);
   27ea2:	681f      	ldr	r7, [r3, #0]
   27ea4:	6823      	ldr	r3, [r4, #0]
   27ea6:	b94b      	cbnz	r3, 27ebc <at_write+0x2c>
   27ea8:	492f      	ldr	r1, [pc, #188]	; (27f68 <at_write+0xd8>)
   27eaa:	4830      	ldr	r0, [pc, #192]	; (27f6c <at_write+0xdc>)
   27eac:	237e      	movs	r3, #126	; 0x7e
   27eae:	4a30      	ldr	r2, [pc, #192]	; (27f70 <at_write+0xe0>)
   27eb0:	f00f ff06 	bl	37cc0 <printk>
   27eb4:	217e      	movs	r1, #126	; 0x7e
   27eb6:	482e      	ldr	r0, [pc, #184]	; (27f70 <at_write+0xe0>)
   27eb8:	f00f ff48 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->send);
   27ebc:	6823      	ldr	r3, [r4, #0]
   27ebe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   27ec0:	b94b      	cbnz	r3, 27ed6 <at_write+0x46>
   27ec2:	492c      	ldr	r1, [pc, #176]	; (27f74 <at_write+0xe4>)
   27ec4:	4829      	ldr	r0, [pc, #164]	; (27f6c <at_write+0xdc>)
   27ec6:	237f      	movs	r3, #127	; 0x7f
   27ec8:	4a29      	ldr	r2, [pc, #164]	; (27f70 <at_write+0xe0>)
   27eca:	f00f fef9 	bl	37cc0 <printk>
   27ece:	217f      	movs	r1, #127	; 0x7f
   27ed0:	4827      	ldr	r0, [pc, #156]	; (27f70 <at_write+0xe0>)
   27ed2:	f00f ff3b 	bl	37d4c <assert_post_action>
	return socket_ops->send(sock, buf, len, flags);
   27ed6:	6823      	ldr	r3, [r4, #0]
   27ed8:	4632      	mov	r2, r6
   27eda:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   27edc:	4641      	mov	r1, r8
   27ede:	2300      	movs	r3, #0
   27ee0:	4638      	mov	r0, r7
   27ee2:	47a0      	blx	r4

	if (bytes_sent == -1) {
   27ee4:	1c43      	adds	r3, r0, #1
   27ee6:	4604      	mov	r4, r0
   27ee8:	d121      	bne.n	27f2e <at_write+0x9e>
		LOG_ERR("Failed to send AT command (err:%d)", errno);
   27eea:	2301      	movs	r3, #1
   27eec:	f04f 0400 	mov.w	r4, #0
   27ef0:	4a21      	ldr	r2, [pc, #132]	; (27f78 <at_write+0xe8>)
   27ef2:	f363 0407 	bfi	r4, r3, #0, #8
   27ef6:	4b21      	ldr	r3, [pc, #132]	; (27f7c <at_write+0xec>)
   27ef8:	1a9b      	subs	r3, r3, r2
   27efa:	08db      	lsrs	r3, r3, #3
   27efc:	f363 148f 	bfi	r4, r3, #6, #10
   27f00:	f010 f8d9 	bl	380b6 <__errno>
   27f04:	491e      	ldr	r1, [pc, #120]	; (27f80 <at_write+0xf0>)
   27f06:	6802      	ldr	r2, [r0, #0]
   27f08:	4620      	mov	r0, r4
   27f0a:	f00f ff30 	bl	37d6e <log_string_sync>
		ret.code  = -errno;
   27f0e:	f010 f8d2 	bl	380b6 <__errno>
   27f12:	6803      	ldr	r3, [r0, #0]
   27f14:	425b      	negs	r3, r3
   27f16:	9300      	str	r3, [sp, #0]
		ret.state = AT_CMD_ERROR;
   27f18:	2301      	movs	r3, #1
   27f1a:	f88d 3004 	strb.w	r3, [sp, #4]
				"same as expected (%d)",
				bytes_sent, bytes_to_send);
		}
	}

	if (state) {
   27f1e:	b115      	cbz	r5, 27f26 <at_write+0x96>
		*state = ret.state;
   27f20:	f89d 3004 	ldrb.w	r3, [sp, #4]
   27f24:	702b      	strb	r3, [r5, #0]
	}

	return ret.code;
}
   27f26:	9800      	ldr	r0, [sp, #0]
   27f28:	b002      	add	sp, #8
   27f2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&msgq, *(uintptr_t *)&data, *(uintptr_t *)&timeout, K_SYSCALL_K_MSGQ_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_get(msgq, data, timeout);
   27f2e:	f04f 32ff 	mov.w	r2, #4294967295
   27f32:	4669      	mov	r1, sp
   27f34:	4813      	ldr	r0, [pc, #76]	; (27f84 <at_write+0xf4>)
   27f36:	f00a fe2f 	bl	32b98 <z_impl_k_msgq_get>
		if (bytes_sent != bytes_to_send) {
   27f3a:	42a6      	cmp	r6, r4
   27f3c:	d0ef      	beq.n	27f1e <at_write+0x8e>
			LOG_ERR("Bytes sent (%d) was not the "
   27f3e:	2301      	movs	r3, #1
   27f40:	f04f 0000 	mov.w	r0, #0
   27f44:	4a0c      	ldr	r2, [pc, #48]	; (27f78 <at_write+0xe8>)
   27f46:	f363 0007 	bfi	r0, r3, #0, #8
   27f4a:	4b0c      	ldr	r3, [pc, #48]	; (27f7c <at_write+0xec>)
   27f4c:	490e      	ldr	r1, [pc, #56]	; (27f88 <at_write+0xf8>)
   27f4e:	1a9b      	subs	r3, r3, r2
   27f50:	08db      	lsrs	r3, r3, #3
   27f52:	f363 108f 	bfi	r0, r3, #6, #10
   27f56:	4622      	mov	r2, r4
   27f58:	4633      	mov	r3, r6
   27f5a:	f00f ff08 	bl	37d6e <log_string_sync>
   27f5e:	e7de      	b.n	27f1e <at_write+0x8e>
   27f60:	200204c0 	.word	0x200204c0
   27f64:	2002064c 	.word	0x2002064c
   27f68:	0003c541 	.word	0x0003c541
   27f6c:	0003baac 	.word	0x0003baac
   27f70:	0003c511 	.word	0x0003c511
   27f74:	0003dad1 	.word	0x0003dad1
   27f78:	0003ade0 	.word	0x0003ade0
   27f7c:	0003ade8 	.word	0x0003ade8
   27f80:	0003e046 	.word	0x0003e046
   27f84:	2002cc7c 	.word	0x2002cc7c
   27f88:	0003e069 	.word	0x0003e069

00027f8c <socket_thread_fn>:
{
   27f8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
					LOG_ERR("Response buffer not large "
   27f90:	4b9e      	ldr	r3, [pc, #632]	; (2820c <socket_thread_fn+0x280>)
   27f92:	4c9f      	ldr	r4, [pc, #636]	; (28210 <socket_thread_fn+0x284>)
{
   27f94:	b087      	sub	sp, #28
					LOG_ERR("Response buffer not large "
   27f96:	1ae4      	subs	r4, r4, r3
   27f98:	f3c4 04c9 	ubfx	r4, r4, #3, #10
		k_mem_slab_alloc(&rsp_work_items, (void **)&item, K_FOREVER);
   27f9c:	f04f 32ff 	mov.w	r2, #4294967295
   27fa0:	a903      	add	r1, sp, #12
   27fa2:	489c      	ldr	r0, [pc, #624]	; (28214 <socket_thread_fn+0x288>)
   27fa4:	f00a fb82 	bl	326ac <k_mem_slab_alloc>
		ret.code  = 0;
   27fa8:	2300      	movs	r3, #0
		item->callback = NULL;
   27faa:	9d03      	ldr	r5, [sp, #12]
		ret.code  = 0;
   27fac:	9304      	str	r3, [sp, #16]
		item->callback = NULL;
   27fae:	f8c5 3a98 	str.w	r3, [r5, #2712]	; 0xa98
		ret.state = AT_CMD_OK;
   27fb2:	f88d 3014 	strb.w	r3, [sp, #20]
	__ASSERT_NO_MSG(socket_ops);
   27fb6:	f8df a2b4 	ldr.w	sl, [pc, #692]	; 2826c <socket_thread_fn+0x2e0>
		bytes_read = recv(common_socket_fd, item->data,
   27fba:	4b97      	ldr	r3, [pc, #604]	; (28218 <socket_thread_fn+0x28c>)
   27fbc:	350c      	adds	r5, #12
   27fbe:	f8d3 b000 	ldr.w	fp, [r3]
   27fc2:	f8da 3000 	ldr.w	r3, [sl]
   27fc6:	b94b      	cbnz	r3, 27fdc <socket_thread_fn+0x50>
   27fc8:	4994      	ldr	r1, [pc, #592]	; (2821c <socket_thread_fn+0x290>)
   27fca:	4895      	ldr	r0, [pc, #596]	; (28220 <socket_thread_fn+0x294>)
   27fcc:	2369      	movs	r3, #105	; 0x69
   27fce:	4a95      	ldr	r2, [pc, #596]	; (28224 <socket_thread_fn+0x298>)
   27fd0:	f00f fe76 	bl	37cc0 <printk>
   27fd4:	2169      	movs	r1, #105	; 0x69
   27fd6:	4893      	ldr	r0, [pc, #588]	; (28224 <socket_thread_fn+0x298>)
   27fd8:	f00f feb8 	bl	37d4c <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->recv);
   27fdc:	f8da 3000 	ldr.w	r3, [sl]
   27fe0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   27fe2:	b94b      	cbnz	r3, 27ff8 <socket_thread_fn+0x6c>
   27fe4:	4990      	ldr	r1, [pc, #576]	; (28228 <socket_thread_fn+0x29c>)
   27fe6:	488e      	ldr	r0, [pc, #568]	; (28220 <socket_thread_fn+0x294>)
   27fe8:	236a      	movs	r3, #106	; 0x6a
   27fea:	4a8e      	ldr	r2, [pc, #568]	; (28224 <socket_thread_fn+0x298>)
   27fec:	f00f fe68 	bl	37cc0 <printk>
   27ff0:	216a      	movs	r1, #106	; 0x6a
   27ff2:	488c      	ldr	r0, [pc, #560]	; (28224 <socket_thread_fn+0x298>)
   27ff4:	f00f feaa 	bl	37d4c <assert_post_action>
	return socket_ops->recv(sock, buf, max_len, flags);
   27ff8:	f8da 3000 	ldr.w	r3, [sl]
   27ffc:	f640 228c 	movw	r2, #2700	; 0xa8c
   28000:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
   28004:	4629      	mov	r1, r5
   28006:	2300      	movs	r3, #0
   28008:	4658      	mov	r0, fp
   2800a:	47d0      	blx	sl
		if (bytes_read < 0) {
   2800c:	1e02      	subs	r2, r0, #0
   2800e:	da58      	bge.n	280c2 <socket_thread_fn+0x136>
			LOG_ERR("AT socket recv failed with err %d",
   28010:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   28014:	f043 0301 	orr.w	r3, r3, #1
   28018:	f363 0607 	bfi	r6, r3, #0, #8
   2801c:	f364 168f 	bfi	r6, r4, #6, #10
   28020:	4630      	mov	r0, r6
   28022:	4982      	ldr	r1, [pc, #520]	; (2822c <socket_thread_fn+0x2a0>)
   28024:	f00f fea3 	bl	37d6e <log_string_sync>
			if ((close(common_socket_fd) == 0) &&
   28028:	4b7b      	ldr	r3, [pc, #492]	; (28218 <socket_thread_fn+0x28c>)
   2802a:	6818      	ldr	r0, [r3, #0]
   2802c:	f7ff feba 	bl	27da4 <close>
   28030:	2800      	cmp	r0, #0
   28032:	d131      	bne.n	28098 <socket_thread_fn+0x10c>
			    (open_socket() == 0)) {
   28034:	f7ff fef2 	bl	27e1c <open_socket>
			if ((close(common_socket_fd) == 0) &&
   28038:	bb70      	cbnz	r0, 28098 <socket_thread_fn+0x10c>
				LOG_INF("AT socket recovered");
   2803a:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
   2803e:	f043 0303 	orr.w	r3, r3, #3
   28042:	f363 0707 	bfi	r7, r3, #0, #8
   28046:	f364 178f 	bfi	r7, r4, #6, #10
   2804a:	4979      	ldr	r1, [pc, #484]	; (28230 <socket_thread_fn+0x2a4>)
   2804c:	4638      	mov	r0, r7
   2804e:	f00f fe8e 	bl	37d6e <log_string_sync>
				ret.state = AT_CMD_ERROR;
   28052:	2301      	movs	r3, #1
   28054:	f88d 3014 	strb.w	r3, [sp, #20]
				ret.code  = -errno;
   28058:	f010 f82d 	bl	380b6 <__errno>
   2805c:	6803      	ldr	r3, [r0, #0]
   2805e:	425b      	negs	r3, r3
			ret.code  = -ENOBUFS;
   28060:	9304      	str	r3, [sp, #16]
		if (item->callback == NULL) {
   28062:	9903      	ldr	r1, [sp, #12]
   28064:	f8d1 3a98 	ldr.w	r3, [r1, #2712]	; 0xa98
   28068:	2b00      	cmp	r3, #0
   2806a:	f040 80a5 	bne.w	281b8 <socket_thread_fn+0x22c>
			k_mem_slab_free(&rsp_work_items, (void **)&item);
   2806e:	a903      	add	r1, sp, #12
   28070:	4868      	ldr	r0, [pc, #416]	; (28214 <socket_thread_fn+0x288>)
   28072:	f00a fb7f 	bl	32774 <k_mem_slab_free>
	return z_impl_k_sem_count_get(sem);
   28076:	4b6f      	ldr	r3, [pc, #444]	; (28234 <socket_thread_fn+0x2a8>)
		if ((k_sem_count_get(&cmd_pending) == 0) &&
   28078:	689b      	ldr	r3, [r3, #8]
   2807a:	2b00      	cmp	r3, #0
   2807c:	d18e      	bne.n	27f9c <socket_thread_fn+0x10>
   2807e:	f89d 2014 	ldrb.w	r2, [sp, #20]
   28082:	2a04      	cmp	r2, #4
   28084:	d08a      	beq.n	27f9c <socket_thread_fn+0x10>
			current_cmd_handler = NULL;
   28086:	4a6c      	ldr	r2, [pc, #432]	; (28238 <socket_thread_fn+0x2ac>)
   28088:	6013      	str	r3, [r2, #0]
	return z_impl_k_msgq_put(msgq, data, timeout);
   2808a:	f04f 32ff 	mov.w	r2, #4294967295
   2808e:	a904      	add	r1, sp, #16
   28090:	486a      	ldr	r0, [pc, #424]	; (2823c <socket_thread_fn+0x2b0>)
   28092:	f00a fce1 	bl	32a58 <z_impl_k_msgq_put>
   28096:	e781      	b.n	27f9c <socket_thread_fn+0x10>
			LOG_ERR("Unrecoverable reception error (err: %d), "
   28098:	2301      	movs	r3, #1
   2809a:	f04f 0500 	mov.w	r5, #0
   2809e:	f363 0507 	bfi	r5, r3, #0, #8
   280a2:	f010 f808 	bl	380b6 <__errno>
   280a6:	f364 158f 	bfi	r5, r4, #6, #10
   280aa:	6802      	ldr	r2, [r0, #0]
   280ac:	4964      	ldr	r1, [pc, #400]	; (28240 <socket_thread_fn+0x2b4>)
   280ae:	4628      	mov	r0, r5
   280b0:	f00f fe5d 	bl	37d6e <log_string_sync>
			close(common_socket_fd);
   280b4:	4b58      	ldr	r3, [pc, #352]	; (28218 <socket_thread_fn+0x28c>)
   280b6:	6818      	ldr	r0, [r3, #0]
   280b8:	f7ff fe74 	bl	27da4 <close>
}
   280bc:	b007      	add	sp, #28
   280be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (bytes_read == sizeof(item->data) ||
   280c2:	f640 238c 	movw	r3, #2700	; 0xa8c
   280c6:	429a      	cmp	r2, r3
   280c8:	d004      	beq.n	280d4 <socket_thread_fn+0x148>
			   item->data[bytes_read - 1] != '\0') {
   280ca:	f8dd a00c 	ldr.w	sl, [sp, #12]
   280ce:	4452      	add	r2, sl
		} else if (bytes_read == sizeof(item->data) ||
   280d0:	7ad3      	ldrb	r3, [r2, #11]
   280d2:	b173      	cbz	r3, 280f2 <socket_thread_fn+0x166>
			LOG_ERR("AT message to large for reception buffer or "
   280d4:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   280d8:	f043 0301 	orr.w	r3, r3, #1
   280dc:	f363 0807 	bfi	r8, r3, #0, #8
   280e0:	f364 188f 	bfi	r8, r4, #6, #10
   280e4:	4957      	ldr	r1, [pc, #348]	; (28244 <socket_thread_fn+0x2b8>)
   280e6:	4640      	mov	r0, r8
   280e8:	f00f fe41 	bl	37d6e <log_string_sync>
			ret.code  = -ENOBUFS;
   280ec:	f06f 0368 	mvn.w	r3, #104	; 0x68
   280f0:	e7b6      	b.n	28060 <socket_thread_fn+0xd4>
	ret->state = AT_CMD_NOTIFICATION;
   280f2:	2204      	movs	r2, #4
		payload_len = get_return_code(item->data, &ret);
   280f4:	f10a 050c 	add.w	r5, sl, #12
		tmpstr = strstr(buf, AT_CMD_OK_STR);
   280f8:	4953      	ldr	r1, [pc, #332]	; (28248 <socket_thread_fn+0x2bc>)
   280fa:	4628      	mov	r0, r5
   280fc:	9301      	str	r3, [sp, #4]
	ret->state = AT_CMD_NOTIFICATION;
   280fe:	f88d 2014 	strb.w	r2, [sp, #20]
		tmpstr = strstr(buf, AT_CMD_OK_STR);
   28102:	f011 ffdf 	bl	3a0c4 <strstr>
		if (tmpstr) {
   28106:	4683      	mov	fp, r0
   28108:	b120      	cbz	r0, 28114 <socket_thread_fn+0x188>
			ret->state = AT_CMD_OK;
   2810a:	9b01      	ldr	r3, [sp, #4]
   2810c:	f88d 3014 	strb.w	r3, [sp, #20]
			ret->code  = -ENOEXEC;
   28110:	9304      	str	r3, [sp, #16]
			break;
   28112:	e00d      	b.n	28130 <socket_thread_fn+0x1a4>
		tmpstr = strstr(buf, AT_CMD_CMS_STR);
   28114:	494d      	ldr	r1, [pc, #308]	; (2824c <socket_thread_fn+0x2c0>)
   28116:	4628      	mov	r0, r5
   28118:	f011 ffd4 	bl	3a0c4 <strstr>
		if (tmpstr) {
   2811c:	4683      	mov	fp, r0
   2811e:	b330      	cbz	r0, 2816e <socket_thread_fn+0x1e2>
			ret->state = AT_CMD_ERROR_CMS;
   28120:	2302      	movs	r3, #2
			ret->code = atoi(&buf[ARRAY_SIZE(AT_CMD_CMS_STR) - 1]);
   28122:	f10a 0017 	add.w	r0, sl, #23
			ret->state = AT_CMD_ERROR_CME;
   28126:	f88d 3014 	strb.w	r3, [sp, #20]
			ret->code = atoi(&buf[ARRAY_SIZE(AT_CMD_CMS_STR) - 1]);
   2812a:	f011 fe08 	bl	39d3e <atoi>
   2812e:	9004      	str	r0, [sp, #16]
		buf[new_len++] = '\0';
   28130:	2300      	movs	r3, #0
		new_len = tmpstr - buf;
   28132:	ebab 0205 	sub.w	r2, fp, r5
		buf[new_len++] = '\0';
   28136:	3201      	adds	r2, #1
   28138:	f88b 3000 	strb.w	r3, [fp]
		if (ret.state != AT_CMD_NOTIFICATION) {
   2813c:	f89d 3014 	ldrb.w	r3, [sp, #20]
   28140:	2b04      	cmp	r3, #4
   28142:	d04f      	beq.n	281e4 <socket_thread_fn+0x258>
			if ((response_buf_len > 0) &&
   28144:	f8df a128 	ldr.w	sl, [pc, #296]	; 28270 <socket_thread_fn+0x2e4>
   28148:	f8da 3000 	ldr.w	r3, [sl]
   2814c:	2b00      	cmp	r3, #0
   2814e:	d052      	beq.n	281f6 <socket_thread_fn+0x26a>
			    (response_buf != NULL)) {
   28150:	4d3f      	ldr	r5, [pc, #252]	; (28250 <socket_thread_fn+0x2c4>)
   28152:	6828      	ldr	r0, [r5, #0]
			if ((response_buf_len > 0) &&
   28154:	2800      	cmp	r0, #0
   28156:	d04e      	beq.n	281f6 <socket_thread_fn+0x26a>
				if (response_buf_len > payload_len) {
   28158:	4293      	cmp	r3, r2
   2815a:	d91d      	bls.n	28198 <socket_thread_fn+0x20c>
   2815c:	9903      	ldr	r1, [sp, #12]
   2815e:	310c      	adds	r1, #12
   28160:	f011 fe0d 	bl	39d7e <memcpy>
				response_buf_len = 0;
   28164:	2300      	movs	r3, #0
   28166:	f8ca 3000 	str.w	r3, [sl]
				response_buf     = NULL;
   2816a:	602b      	str	r3, [r5, #0]
				goto next;
   2816c:	e779      	b.n	28062 <socket_thread_fn+0xd6>
		tmpstr = strstr(buf, AT_CMD_CME_STR);
   2816e:	4939      	ldr	r1, [pc, #228]	; (28254 <socket_thread_fn+0x2c8>)
   28170:	4628      	mov	r0, r5
   28172:	f011 ffa7 	bl	3a0c4 <strstr>
		if (tmpstr) {
   28176:	4683      	mov	fp, r0
   28178:	b108      	cbz	r0, 2817e <socket_thread_fn+0x1f2>
			ret->state = AT_CMD_ERROR_CME;
   2817a:	2303      	movs	r3, #3
   2817c:	e7d1      	b.n	28122 <socket_thread_fn+0x196>
		tmpstr = strstr(buf, AT_CMD_ERROR_STR);
   2817e:	4936      	ldr	r1, [pc, #216]	; (28258 <socket_thread_fn+0x2cc>)
   28180:	4628      	mov	r0, r5
   28182:	f011 ff9f 	bl	3a0c4 <strstr>
		if (tmpstr) {
   28186:	4683      	mov	fp, r0
   28188:	2800      	cmp	r0, #0
   2818a:	d039      	beq.n	28200 <socket_thread_fn+0x274>
			ret->state = AT_CMD_ERROR;
   2818c:	2301      	movs	r3, #1
   2818e:	f88d 3014 	strb.w	r3, [sp, #20]
			ret->code  = -ENOEXEC;
   28192:	f06f 0307 	mvn.w	r3, #7
   28196:	e7bb      	b.n	28110 <socket_thread_fn+0x184>
					LOG_ERR("Response buffer not large "
   28198:	f029 033f 	bic.w	r3, r9, #63	; 0x3f
   2819c:	f043 0301 	orr.w	r3, r3, #1
   281a0:	f363 0907 	bfi	r9, r3, #0, #8
   281a4:	f364 198f 	bfi	r9, r4, #6, #10
   281a8:	492c      	ldr	r1, [pc, #176]	; (2825c <socket_thread_fn+0x2d0>)
   281aa:	4648      	mov	r0, r9
   281ac:	f00f fddf 	bl	37d6e <log_string_sync>
					ret.code  = -EMSGSIZE;
   281b0:	f06f 0379 	mvn.w	r3, #121	; 0x79
   281b4:	9304      	str	r3, [sp, #16]
   281b6:	e7d5      	b.n	28164 <socket_thread_fn+0x1d8>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   281b8:	4b29      	ldr	r3, [pc, #164]	; (28260 <socket_thread_fn+0x2d4>)
   281ba:	2200      	movs	r2, #0
   281bc:	604b      	str	r3, [r1, #4]
   281be:	460b      	mov	r3, r1
   281c0:	600a      	str	r2, [r1, #0]
   281c2:	f843 2f08 	str.w	r2, [r3, #8]!
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   281c6:	e8d3 2fef 	ldaex	r2, [r3]
   281ca:	f042 0001 	orr.w	r0, r2, #1
   281ce:	e8c3 0fe5 	stlex	r5, r0, [r3]
   281d2:	2d00      	cmp	r5, #0
   281d4:	d1f7      	bne.n	281c6 <socket_thread_fn+0x23a>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   281d6:	07d3      	lsls	r3, r2, #31
   281d8:	f53f af4d 	bmi.w	28076 <socket_thread_fn+0xea>
		k_queue_append(&work_q->queue, work);
   281dc:	4821      	ldr	r0, [pc, #132]	; (28264 <socket_thread_fn+0x2d8>)
   281de:	f011 fc39 	bl	39a54 <k_queue_append>
   281e2:	e748      	b.n	28076 <socket_thread_fn+0xea>
		if (payload_len == 0) {
   281e4:	2a00      	cmp	r2, #0
   281e6:	f43f af3c 	beq.w	28062 <socket_thread_fn+0xd6>
			item->callback = notification_handler;
   281ea:	4b1f      	ldr	r3, [pc, #124]	; (28268 <socket_thread_fn+0x2dc>)
			item->callback = current_cmd_handler;
   281ec:	681a      	ldr	r2, [r3, #0]
   281ee:	9b03      	ldr	r3, [sp, #12]
   281f0:	f8c3 2a98 	str.w	r2, [r3, #2712]	; 0xa98
   281f4:	e735      	b.n	28062 <socket_thread_fn+0xd6>
		if (payload_len == 0) {
   281f6:	2a00      	cmp	r2, #0
   281f8:	f43f af33 	beq.w	28062 <socket_thread_fn+0xd6>
			item->callback = current_cmd_handler;
   281fc:	4b0e      	ldr	r3, [pc, #56]	; (28238 <socket_thread_fn+0x2ac>)
   281fe:	e7f5      	b.n	281ec <socket_thread_fn+0x260>
		new_len = strlen(buf) + 1;
   28200:	4628      	mov	r0, r5
   28202:	f7f4 ffa9 	bl	1d158 <strlen>
   28206:	1c42      	adds	r2, r0, #1
   28208:	e798      	b.n	2813c <socket_thread_fn+0x1b0>
   2820a:	bf00      	nop
   2820c:	0003ade0 	.word	0x0003ade0
   28210:	0003ade8 	.word	0x0003ade8
   28214:	2002cb80 	.word	0x2002cb80
   28218:	2002064c 	.word	0x2002064c
   2821c:	0003c541 	.word	0x0003c541
   28220:	0003baac 	.word	0x0003baac
   28224:	0003c511 	.word	0x0003c511
   28228:	0003dac0 	.word	0x0003dac0
   2822c:	0003e09b 	.word	0x0003e09b
   28230:	0003e0bd 	.word	0x0003e0bd
   28234:	2002cbe8 	.word	0x2002cbe8
   28238:	20020650 	.word	0x20020650
   2823c:	2002cc7c 	.word	0x2002cc7c
   28240:	0003e0d1 	.word	0x0003e0d1
   28244:	0003e108 	.word	0x0003e108
   28248:	0003c95d 	.word	0x0003c95d
   2824c:	0003e152 	.word	0x0003e152
   28250:	20020658 	.word	0x20020658
   28254:	0003e15e 	.word	0x0003e15e
   28258:	0003e16a 	.word	0x0003e16a
   2825c:	0003e170 	.word	0x0003e170
   28260:	00027dfd 	.word	0x00027dfd
   28264:	20022150 	.word	0x20022150
   28268:	20020654 	.word	0x20020654
   2826c:	200204c0 	.word	0x200204c0
   28270:	2002065c 	.word	0x2002065c

00028274 <at_cmd_driver_init>:

	k_sem_give(&cmd_pending);
}

static int at_cmd_driver_init(struct device *dev)
{
   28274:	b510      	push	{r4, lr}
	static bool initialized;

	if (initialized) {
   28276:	4b16      	ldr	r3, [pc, #88]	; (282d0 <at_cmd_driver_init+0x5c>)
{
   28278:	b086      	sub	sp, #24
	if (initialized) {
   2827a:	781a      	ldrb	r2, [r3, #0]
   2827c:	bb32      	cbnz	r2, 282cc <at_cmd_driver_init+0x58>
		return 0;
	}

	initialized = true;
   2827e:	2201      	movs	r2, #1
   28280:	701a      	strb	r2, [r3, #0]

	int err;

	ARG_UNUSED(dev);

	err = open_socket();
   28282:	f7ff fdcb 	bl	27e1c <open_socket>
	if (err) {
   28286:	4604      	mov	r4, r0
   28288:	b188      	cbz	r0, 282ae <at_cmd_driver_init+0x3a>
		LOG_ERR("Failed to open AT socket (err:%d)", err);
   2828a:	2301      	movs	r3, #1
   2828c:	f04f 0000 	mov.w	r0, #0
   28290:	4a10      	ldr	r2, [pc, #64]	; (282d4 <at_cmd_driver_init+0x60>)
   28292:	f363 0007 	bfi	r0, r3, #0, #8
   28296:	4b10      	ldr	r3, [pc, #64]	; (282d8 <at_cmd_driver_init+0x64>)
   28298:	4910      	ldr	r1, [pc, #64]	; (282dc <at_cmd_driver_init+0x68>)
   2829a:	1a9b      	subs	r3, r3, r2
   2829c:	08db      	lsrs	r3, r3, #3
   2829e:	f363 108f 	bfi	r0, r3, #6, #10
   282a2:	4622      	mov	r2, r4
   282a4:	f00f fd63 	bl	37d6e <log_string_sync>
			THREAD_PRIORITY, 0, K_NO_WAIT);

	LOG_DBG("Common AT socket processing thread created");

	return 0;
}
   282a8:	4620      	mov	r0, r4
   282aa:	b006      	add	sp, #24
   282ac:	bd10      	pop	{r4, pc}
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   282ae:	230a      	movs	r3, #10
   282b0:	e9cd 0004 	strd	r0, r0, [sp, #16]
   282b4:	e9cd 0302 	strd	r0, r3, [sp, #8]
   282b8:	e9cd 0000 	strd	r0, r0, [sp]
   282bc:	4b08      	ldr	r3, [pc, #32]	; (282e0 <at_cmd_driver_init+0x6c>)
   282be:	f44f 6280 	mov.w	r2, #1024	; 0x400
   282c2:	4908      	ldr	r1, [pc, #32]	; (282e4 <at_cmd_driver_init+0x70>)
   282c4:	4808      	ldr	r0, [pc, #32]	; (282e8 <at_cmd_driver_init+0x74>)
   282c6:	f00c fb3d 	bl	34944 <z_impl_k_thread_create>
	return 0;
   282ca:	e7ed      	b.n	282a8 <at_cmd_driver_init+0x34>
		return 0;
   282cc:	2400      	movs	r4, #0
   282ce:	e7eb      	b.n	282a8 <at_cmd_driver_init+0x34>
   282d0:	2002513d 	.word	0x2002513d
   282d4:	0003ade0 	.word	0x0003ade0
   282d8:	0003ade8 	.word	0x0003ade8
   282dc:	0003dffb 	.word	0x0003dffb
   282e0:	00027f8d 	.word	0x00027f8d
   282e4:	200262a0 	.word	0x200262a0
   282e8:	20020660 	.word	0x20020660

000282ec <at_cmd_write>:
{
   282ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   282f0:	4605      	mov	r5, r0
   282f2:	4688      	mov	r8, r1
   282f4:	4617      	mov	r7, r2
   282f6:	461e      	mov	r6, r3
	return z_impl_k_sem_take(sem, timeout);
   282f8:	4c0a      	ldr	r4, [pc, #40]	; (28324 <at_cmd_write+0x38>)
   282fa:	f04f 31ff 	mov.w	r1, #4294967295
   282fe:	4620      	mov	r0, r4
   28300:	f00c f9ee 	bl	346e0 <z_impl_k_sem_take>
	response_buf     = buf;
   28304:	4b08      	ldr	r3, [pc, #32]	; (28328 <at_cmd_write+0x3c>)
	int return_code = at_write(cmd, state);
   28306:	4631      	mov	r1, r6
	response_buf     = buf;
   28308:	f8c3 8000 	str.w	r8, [r3]
	response_buf_len = buf_len;
   2830c:	4b07      	ldr	r3, [pc, #28]	; (2832c <at_cmd_write+0x40>)
	int return_code = at_write(cmd, state);
   2830e:	4628      	mov	r0, r5
	response_buf_len = buf_len;
   28310:	601f      	str	r7, [r3, #0]
	int return_code = at_write(cmd, state);
   28312:	f7ff fdbd 	bl	27e90 <at_write>
   28316:	4605      	mov	r5, r0
	z_impl_k_sem_give(sem);
   28318:	4620      	mov	r0, r4
   2831a:	f00c f997 	bl	3464c <z_impl_k_sem_give>
}
   2831e:	4628      	mov	r0, r5
   28320:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   28324:	2002cbe8 	.word	0x2002cbe8
   28328:	20020658 	.word	0x20020658
   2832c:	2002065c 	.word	0x2002065c

00028330 <at_cmd_set_notification_handler>:
{
   28330:	b538      	push	{r3, r4, r5, lr}
	if (notification_handler != NULL && handler != notification_handler) {
   28332:	4c0f      	ldr	r4, [pc, #60]	; (28370 <at_cmd_set_notification_handler+0x40>)
{
   28334:	4605      	mov	r5, r0
	if (notification_handler != NULL && handler != notification_handler) {
   28336:	6822      	ldr	r2, [r4, #0]
   28338:	b17a      	cbz	r2, 2835a <at_cmd_set_notification_handler+0x2a>
   2833a:	4282      	cmp	r2, r0
   2833c:	d00d      	beq.n	2835a <at_cmd_set_notification_handler+0x2a>
		LOG_WRN("Forgetting prior notification handler %p",
   2833e:	2302      	movs	r3, #2
   28340:	f04f 0000 	mov.w	r0, #0
   28344:	490b      	ldr	r1, [pc, #44]	; (28374 <at_cmd_set_notification_handler+0x44>)
   28346:	f363 0007 	bfi	r0, r3, #0, #8
   2834a:	4b0b      	ldr	r3, [pc, #44]	; (28378 <at_cmd_set_notification_handler+0x48>)
   2834c:	1a5b      	subs	r3, r3, r1
   2834e:	08db      	lsrs	r3, r3, #3
   28350:	f363 108f 	bfi	r0, r3, #6, #10
   28354:	4909      	ldr	r1, [pc, #36]	; (2837c <at_cmd_set_notification_handler+0x4c>)
   28356:	f00f fd0a 	bl	37d6e <log_string_sync>
	return z_impl_k_sem_take(sem, timeout);
   2835a:	f04f 31ff 	mov.w	r1, #4294967295
   2835e:	4808      	ldr	r0, [pc, #32]	; (28380 <at_cmd_set_notification_handler+0x50>)
   28360:	f00c f9be 	bl	346e0 <z_impl_k_sem_take>
	notification_handler = handler;
   28364:	6025      	str	r5, [r4, #0]
	z_impl_k_sem_give(sem);
   28366:	4806      	ldr	r0, [pc, #24]	; (28380 <at_cmd_set_notification_handler+0x50>)
}
   28368:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2836c:	f00c b96e 	b.w	3464c <z_impl_k_sem_give>
   28370:	20020654 	.word	0x20020654
   28374:	0003ade0 	.word	0x0003ade0
   28378:	0003ade8 	.word	0x0003ade8
   2837c:	0003e01d 	.word	0x0003e01d
   28380:	2002cbe8 	.word	0x2002cbe8

00028384 <find_node>:
static struct notif_handler *find_node(struct notif_handler **prev_out,
	void *ctx, at_notif_handler_t handler)
{
	struct notif_handler *prev = NULL, *curr, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   28384:	4b0b      	ldr	r3, [pc, #44]	; (283b4 <find_node+0x30>)
{
   28386:	b570      	push	{r4, r5, r6, lr}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   28388:	681b      	ldr	r3, [r3, #0]
   2838a:	b153      	cbz	r3, 283a2 <find_node+0x1e>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   2838c:	2500      	movs	r5, #0
   2838e:	461c      	mov	r4, r3
   28390:	681b      	ldr	r3, [r3, #0]
		if (curr->ctx == ctx && curr->handler == handler) {
   28392:	6866      	ldr	r6, [r4, #4]
   28394:	428e      	cmp	r6, r1
   28396:	d106      	bne.n	283a6 <find_node+0x22>
   28398:	68a6      	ldr	r6, [r4, #8]
   2839a:	4296      	cmp	r6, r2
   2839c:	d103      	bne.n	283a6 <find_node+0x22>
			*prev_out = prev;
			return curr;
   2839e:	4623      	mov	r3, r4
			*prev_out = prev;
   283a0:	6005      	str	r5, [r0, #0]
		}
		prev = curr;
	}
	return NULL;
}
   283a2:	4618      	mov	r0, r3
   283a4:	bd70      	pop	{r4, r5, r6, pc}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   283a6:	2b00      	cmp	r3, #0
   283a8:	d0fb      	beq.n	283a2 <find_node+0x1e>
   283aa:	4625      	mov	r5, r4
   283ac:	461c      	mov	r4, r3
   283ae:	681b      	ldr	r3, [r3, #0]
   283b0:	e7ef      	b.n	28392 <find_node+0xe>
   283b2:	bf00      	nop
   283b4:	20020710 	.word	0x20020710

000283b8 <module_init>:
{
	ARG_UNUSED(dev);

	static bool initialized;

	if (initialized) {
   283b8:	4a0e      	ldr	r2, [pc, #56]	; (283f4 <module_init+0x3c>)
{
   283ba:	b508      	push	{r3, lr}
	if (initialized) {
   283bc:	7813      	ldrb	r3, [r2, #0]
   283be:	b17b      	cbz	r3, 283e0 <module_init+0x28>
		LOG_WRN("Already initialized. Nothing to do");
   283c0:	2302      	movs	r3, #2
   283c2:	f04f 0000 	mov.w	r0, #0
   283c6:	4a0c      	ldr	r2, [pc, #48]	; (283f8 <module_init+0x40>)
   283c8:	f363 0007 	bfi	r0, r3, #0, #8
   283cc:	4b0b      	ldr	r3, [pc, #44]	; (283fc <module_init+0x44>)
   283ce:	490c      	ldr	r1, [pc, #48]	; (28400 <module_init+0x48>)
   283d0:	1a9b      	subs	r3, r3, r2
   283d2:	08db      	lsrs	r3, r3, #3
   283d4:	f363 108f 	bfi	r0, r3, #6, #10
   283d8:	f00f fcc9 	bl	37d6e <log_string_sync>

	LOG_DBG("Initialization");
	sys_slist_init(&handler_list);
	at_cmd_set_notification_handler(notif_dispatch);
	return 0;
}
   283dc:	2000      	movs	r0, #0
   283de:	bd08      	pop	{r3, pc}
	initialized = true;
   283e0:	2101      	movs	r1, #1
   283e2:	7011      	strb	r1, [r2, #0]
	list->head = NULL;
   283e4:	4a07      	ldr	r2, [pc, #28]	; (28404 <module_init+0x4c>)
	at_cmd_set_notification_handler(notif_dispatch);
   283e6:	4808      	ldr	r0, [pc, #32]	; (28408 <module_init+0x50>)
	list->tail = NULL;
   283e8:	e9c2 3300 	strd	r3, r3, [r2]
   283ec:	f7ff ffa0 	bl	28330 <at_cmd_set_notification_handler>
	return 0;
   283f0:	e7f4      	b.n	283dc <module_init+0x24>
   283f2:	bf00      	nop
   283f4:	2002513e 	.word	0x2002513e
   283f8:	0003ade0 	.word	0x0003ade0
   283fc:	0003adf8 	.word	0x0003adf8
   28400:	0003e1ef 	.word	0x0003e1ef
   28404:	20020710 	.word	0x20020710
   28408:	00028419 	.word	0x00028419

0002840c <k_mutex_unlock.constprop.7>:
	return z_impl_k_mutex_unlock(mutex);
   2840c:	4801      	ldr	r0, [pc, #4]	; (28414 <k_mutex_unlock.constprop.7+0x8>)
   2840e:	f00a bd4d 	b.w	32eac <z_impl_k_mutex_unlock>
   28412:	bf00      	nop
   28414:	2002cc40 	.word	0x2002cc40

00028418 <notif_dispatch>:
{
   28418:	b538      	push	{r3, r4, r5, lr}
   2841a:	4605      	mov	r5, r0
	return z_impl_k_mutex_lock(mutex, timeout);
   2841c:	f04f 31ff 	mov.w	r1, #4294967295
   28420:	4809      	ldr	r0, [pc, #36]	; (28448 <notif_dispatch+0x30>)
   28422:	f00a fc65 	bl	32cf0 <z_impl_k_mutex_lock>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   28426:	4b09      	ldr	r3, [pc, #36]	; (2844c <notif_dispatch+0x34>)
   28428:	681b      	ldr	r3, [r3, #0]
   2842a:	b91b      	cbnz	r3, 28434 <notif_dispatch+0x1c>
}
   2842c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	k_mutex_unlock(&list_mtx);
   28430:	f7ff bfec 	b.w	2840c <k_mutex_unlock.constprop.7>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   28434:	681c      	ldr	r4, [r3, #0]
		curr->handler(curr->ctx, response);
   28436:	689a      	ldr	r2, [r3, #8]
   28438:	4629      	mov	r1, r5
   2843a:	6858      	ldr	r0, [r3, #4]
   2843c:	4790      	blx	r2
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   2843e:	2c00      	cmp	r4, #0
   28440:	d0f4      	beq.n	2842c <notif_dispatch+0x14>
   28442:	4623      	mov	r3, r4
   28444:	6824      	ldr	r4, [r4, #0]
   28446:	e7f6      	b.n	28436 <notif_dispatch+0x1e>
   28448:	2002cc40 	.word	0x2002cc40
   2844c:	20020710 	.word	0x20020710

00028450 <at_notif_register_handler>:
{
	return module_init(NULL);
}

int at_notif_register_handler(void *context, at_notif_handler_t handler)
{
   28450:	b573      	push	{r0, r1, r4, r5, r6, lr}
   28452:	4606      	mov	r6, r0
	if (handler == NULL) {
   28454:	460d      	mov	r5, r1
   28456:	b999      	cbnz	r1, 28480 <at_notif_register_handler+0x30>
		LOG_ERR("Invalid handler (context=0x%08X, handler=0x%08X)",
   28458:	2301      	movs	r3, #1
   2845a:	f04f 0000 	mov.w	r0, #0
   2845e:	4a1d      	ldr	r2, [pc, #116]	; (284d4 <at_notif_register_handler+0x84>)
   28460:	f363 0007 	bfi	r0, r3, #0, #8
   28464:	4b1c      	ldr	r3, [pc, #112]	; (284d8 <at_notif_register_handler+0x88>)
   28466:	1a9b      	subs	r3, r3, r2
   28468:	08db      	lsrs	r3, r3, #3
   2846a:	f363 108f 	bfi	r0, r3, #6, #10
   2846e:	4632      	mov	r2, r6
   28470:	460b      	mov	r3, r1
   28472:	491a      	ldr	r1, [pc, #104]	; (284dc <at_notif_register_handler+0x8c>)
   28474:	f00f fc7b 	bl	37d6e <log_string_sync>
			(u32_t)context, (u32_t)handler);
		return -EINVAL;
   28478:	f06f 0015 	mvn.w	r0, #21
	}
	return append_notif_handler(context, handler);
}
   2847c:	b002      	add	sp, #8
   2847e:	bd70      	pop	{r4, r5, r6, pc}
   28480:	f04f 31ff 	mov.w	r1, #4294967295
   28484:	4816      	ldr	r0, [pc, #88]	; (284e0 <at_notif_register_handler+0x90>)
   28486:	f00a fc33 	bl	32cf0 <z_impl_k_mutex_lock>
	if (find_node(&to_ins, ctx, handler) != NULL) {
   2848a:	462a      	mov	r2, r5
   2848c:	4631      	mov	r1, r6
   2848e:	a801      	add	r0, sp, #4
   28490:	f7ff ff78 	bl	28384 <find_node>
   28494:	4604      	mov	r4, r0
   28496:	b118      	cbz	r0, 284a0 <at_notif_register_handler+0x50>
		k_mutex_unlock(&list_mtx);
   28498:	f7ff ffb8 	bl	2840c <k_mutex_unlock.constprop.7>
		return 0;
   2849c:	2000      	movs	r0, #0
   2849e:	e7ed      	b.n	2847c <at_notif_register_handler+0x2c>
	to_ins = (struct notif_handler *)k_malloc(sizeof(struct notif_handler));
   284a0:	200c      	movs	r0, #12
   284a2:	f00a fabd 	bl	32a20 <k_malloc>
   284a6:	9001      	str	r0, [sp, #4]
	if (to_ins == NULL) {
   284a8:	b920      	cbnz	r0, 284b4 <at_notif_register_handler+0x64>
		k_mutex_unlock(&list_mtx);
   284aa:	f7ff ffaf 	bl	2840c <k_mutex_unlock.constprop.7>
		return -ENOBUFS;
   284ae:	f06f 0068 	mvn.w	r0, #104	; 0x68
   284b2:	e7e3      	b.n	2847c <at_notif_register_handler+0x2c>
__ssp_bos_icheck3(memset, void *, int)
   284b4:	6004      	str	r4, [r0, #0]
	to_ins->ctx     = ctx;
   284b6:	9b01      	ldr	r3, [sp, #4]
Z_GENLIST_APPEND(slist, snode)
   284b8:	4a0a      	ldr	r2, [pc, #40]	; (284e4 <at_notif_register_handler+0x94>)
   284ba:	6044      	str	r4, [r0, #4]
   284bc:	6084      	str	r4, [r0, #8]
	parent->next = child;
   284be:	601c      	str	r4, [r3, #0]
Z_GENLIST_APPEND(slist, snode)
   284c0:	6851      	ldr	r1, [r2, #4]
	to_ins->handler = handler;
   284c2:	e9c3 6501 	strd	r6, r5, [r3, #4]
   284c6:	b911      	cbnz	r1, 284ce <at_notif_register_handler+0x7e>
	list->head = node;
   284c8:	e9c2 3300 	strd	r3, r3, [r2]
   284cc:	e7e4      	b.n	28498 <at_notif_register_handler+0x48>
	parent->next = child;
   284ce:	600b      	str	r3, [r1, #0]
	list->tail = node;
   284d0:	6053      	str	r3, [r2, #4]
   284d2:	e7e1      	b.n	28498 <at_notif_register_handler+0x48>
   284d4:	0003ade0 	.word	0x0003ade0
   284d8:	0003adf8 	.word	0x0003adf8
   284dc:	0003e1be 	.word	0x0003e1be
   284e0:	2002cc40 	.word	0x2002cc40
   284e4:	20020710 	.word	0x20020710

000284e8 <at_notif_deregister_handler>:

int at_notif_deregister_handler(void *context, at_notif_handler_t handler)
{
   284e8:	b537      	push	{r0, r1, r2, r4, r5, lr}
   284ea:	4605      	mov	r5, r0
	if (handler == NULL) {
   284ec:	460c      	mov	r4, r1
   284ee:	b999      	cbnz	r1, 28518 <at_notif_deregister_handler+0x30>
		LOG_ERR("Invalid handler (context=0x%08X, handler=0x%08X)",
   284f0:	2301      	movs	r3, #1
   284f2:	f04f 0000 	mov.w	r0, #0
   284f6:	4921      	ldr	r1, [pc, #132]	; (2857c <at_notif_deregister_handler+0x94>)
   284f8:	f363 0007 	bfi	r0, r3, #0, #8
   284fc:	4b20      	ldr	r3, [pc, #128]	; (28580 <at_notif_deregister_handler+0x98>)
   284fe:	462a      	mov	r2, r5
   28500:	1ac9      	subs	r1, r1, r3
   28502:	08c9      	lsrs	r1, r1, #3
   28504:	f361 108f 	bfi	r0, r1, #6, #10
   28508:	4623      	mov	r3, r4
   2850a:	491e      	ldr	r1, [pc, #120]	; (28584 <at_notif_deregister_handler+0x9c>)
   2850c:	f00f fc2f 	bl	37d6e <log_string_sync>
			(u32_t)context, (u32_t)handler);
		return -EINVAL;
   28510:	f06f 0015 	mvn.w	r0, #21
	}
	return remove_notif_handler(context, handler);
}
   28514:	b003      	add	sp, #12
   28516:	bd30      	pop	{r4, r5, pc}
	struct notif_handler *curr, *prev = NULL;
   28518:	2300      	movs	r3, #0
   2851a:	9301      	str	r3, [sp, #4]
   2851c:	f04f 31ff 	mov.w	r1, #4294967295
   28520:	4819      	ldr	r0, [pc, #100]	; (28588 <at_notif_deregister_handler+0xa0>)
   28522:	f00a fbe5 	bl	32cf0 <z_impl_k_mutex_lock>
	curr = find_node(&prev, ctx, handler);
   28526:	4622      	mov	r2, r4
   28528:	4629      	mov	r1, r5
   2852a:	a801      	add	r0, sp, #4
   2852c:	f7ff ff2a 	bl	28384 <find_node>
	if (curr == NULL) {
   28530:	b978      	cbnz	r0, 28552 <at_notif_deregister_handler+0x6a>
		LOG_WRN("Handler not registered. Nothing to do");
   28532:	2302      	movs	r3, #2
   28534:	4a12      	ldr	r2, [pc, #72]	; (28580 <at_notif_deregister_handler+0x98>)
   28536:	f363 0007 	bfi	r0, r3, #0, #8
   2853a:	4b10      	ldr	r3, [pc, #64]	; (2857c <at_notif_deregister_handler+0x94>)
   2853c:	4913      	ldr	r1, [pc, #76]	; (2858c <at_notif_deregister_handler+0xa4>)
   2853e:	1a9b      	subs	r3, r3, r2
   28540:	08db      	lsrs	r3, r3, #3
   28542:	f363 108f 	bfi	r0, r3, #6, #10
   28546:	f00f fc12 	bl	37d6e <log_string_sync>
	k_mutex_unlock(&list_mtx);
   2854a:	f7ff ff5f 	bl	2840c <k_mutex_unlock.constprop.7>
	return remove_notif_handler(context, handler);
   2854e:	2000      	movs	r0, #0
   28550:	e7e0      	b.n	28514 <at_notif_deregister_handler+0x2c>
	sys_slist_remove(&handler_list, &prev->node, &curr->node);
   28552:	9a01      	ldr	r2, [sp, #4]
Z_GENLIST_REMOVE(slist, snode)
   28554:	6801      	ldr	r1, [r0, #0]
   28556:	4b0e      	ldr	r3, [pc, #56]	; (28590 <at_notif_deregister_handler+0xa8>)
   28558:	b94a      	cbnz	r2, 2856e <at_notif_deregister_handler+0x86>
   2855a:	685a      	ldr	r2, [r3, #4]
	list->head = node;
   2855c:	6019      	str	r1, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   2855e:	4290      	cmp	r0, r2
   28560:	d100      	bne.n	28564 <at_notif_deregister_handler+0x7c>
	list->tail = node;
   28562:	6059      	str	r1, [r3, #4]
	parent->next = child;
   28564:	2300      	movs	r3, #0
   28566:	6003      	str	r3, [r0, #0]
	k_free(curr);
   28568:	f011 fa3e 	bl	399e8 <k_free>
   2856c:	e7ed      	b.n	2854a <at_notif_deregister_handler+0x62>
   2856e:	6011      	str	r1, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   28570:	6859      	ldr	r1, [r3, #4]
   28572:	4288      	cmp	r0, r1
	list->tail = node;
   28574:	bf08      	it	eq
   28576:	605a      	streq	r2, [r3, #4]
   28578:	e7f4      	b.n	28564 <at_notif_deregister_handler+0x7c>
   2857a:	bf00      	nop
   2857c:	0003adf8 	.word	0x0003adf8
   28580:	0003ade0 	.word	0x0003ade0
   28584:	0003e1be 	.word	0x0003e1be
   28588:	2002cc40 	.word	0x2002cc40
   2858c:	0003e198 	.word	0x0003e198
   28590:	20020710 	.word	0x20020710

00028594 <write_uart_string>:
static struct k_work cmd_send_work;



static inline void write_uart_string(const char *str)
{
   28594:	b538      	push	{r3, r4, r5, lr}
	/* Send characters until, but not including, null */
	for (size_t i = 0; str[i]; i++) {
		uart_poll_out(uart_dev, str[i]);
   28596:	4d05      	ldr	r5, [pc, #20]	; (285ac <write_uart_string+0x18>)
   28598:	1e44      	subs	r4, r0, #1
	for (size_t i = 0; str[i]; i++) {
   2859a:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   2859e:	b901      	cbnz	r1, 285a2 <write_uart_string+0xe>
	}
}
   285a0:	bd38      	pop	{r3, r4, r5, pc}
		uart_poll_out(uart_dev, str[i]);
   285a2:	6828      	ldr	r0, [r5, #0]
	api->poll_out(dev, out_char);
   285a4:	6843      	ldr	r3, [r0, #4]
   285a6:	685b      	ldr	r3, [r3, #4]
   285a8:	4798      	blx	r3
   285aa:	e7f6      	b.n	2859a <write_uart_string+0x6>
   285ac:	200207ec 	.word	0x200207ec

000285b0 <cmd_send>:
	/* Forward the data over UART */
	write_uart_string(response);
}

static void cmd_send(struct k_work *work)
{
   285b0:	b500      	push	{lr}
	enum at_cmd_state state;
	int               err;

	ARG_UNUSED(work);

	err = at_cmd_write(at_buf, at_buf,
   285b2:	4923      	ldr	r1, [pc, #140]	; (28640 <cmd_send+0x90>)
{
   285b4:	b08b      	sub	sp, #44	; 0x2c
	err = at_cmd_write(at_buf, at_buf,
   285b6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   285ba:	f10d 030b 	add.w	r3, sp, #11
   285be:	4608      	mov	r0, r1
   285c0:	f7ff fe94 	bl	282ec <at_cmd_write>
			   sizeof(at_buf), &state);
	if (err < 0) {
   285c4:	1e02      	subs	r2, r0, #0
   285c6:	da12      	bge.n	285ee <cmd_send+0x3e>
		LOG_ERR("Error while processing AT command: %d", err);
   285c8:	2301      	movs	r3, #1
   285ca:	f04f 0000 	mov.w	r0, #0
   285ce:	491d      	ldr	r1, [pc, #116]	; (28644 <cmd_send+0x94>)
   285d0:	f363 0007 	bfi	r0, r3, #0, #8
   285d4:	4b1c      	ldr	r3, [pc, #112]	; (28648 <cmd_send+0x98>)
   285d6:	1a5b      	subs	r3, r3, r1
   285d8:	08db      	lsrs	r3, r3, #3
   285da:	f363 108f 	bfi	r0, r3, #6, #10
   285de:	491b      	ldr	r1, [pc, #108]	; (2864c <cmd_send+0x9c>)
   285e0:	f00f fbc5 	bl	37d6e <log_string_sync>
		state = AT_CMD_ERROR;
   285e4:	2301      	movs	r3, #1
   285e6:	f88d 300b 	strb.w	r3, [sp, #11]
	case AT_CMD_OK:
		write_uart_string(at_buf);
		write_uart_string(OK_STR);
		break;
	case AT_CMD_ERROR:
		write_uart_string(ERROR_STR);
   285ea:	4819      	ldr	r0, [pc, #100]	; (28650 <cmd_send+0xa0>)
   285ec:	e012      	b.n	28614 <cmd_send+0x64>
	switch (state) {
   285ee:	f89d 300b 	ldrb.w	r3, [sp, #11]
   285f2:	2b03      	cmp	r3, #3
   285f4:	d810      	bhi.n	28618 <cmd_send+0x68>
   285f6:	a101      	add	r1, pc, #4	; (adr r1, 285fc <cmd_send+0x4c>)
   285f8:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
   285fc:	0002860d 	.word	0x0002860d
   28600:	000285eb 	.word	0x000285eb
   28604:	00028627 	.word	0x00028627
   28608:	00028639 	.word	0x00028639
		write_uart_string(at_buf);
   2860c:	480c      	ldr	r0, [pc, #48]	; (28640 <cmd_send+0x90>)
   2860e:	f7ff ffc1 	bl	28594 <write_uart_string>
		write_uart_string(OK_STR);
   28612:	4810      	ldr	r0, [pc, #64]	; (28654 <cmd_send+0xa4>)
		sprintf(str, "+CMS ERROR: %d\r\n", err);
		write_uart_string(str);
		break;
	case AT_CMD_ERROR_CME:
		sprintf(str, "+CME ERROR: %d\r\n", err);
		write_uart_string(str);
   28614:	f7ff ffbe 	bl	28594 <write_uart_string>
		break;
	default:
		break;
	}

	uart_irq_rx_enable(uart_dev);
   28618:	4b0f      	ldr	r3, [pc, #60]	; (28658 <cmd_send+0xa8>)
   2861a:	6818      	ldr	r0, [r3, #0]
		arch_syscall_invoke1(*(uintptr_t *)&dev, K_SYSCALL_UART_IRQ_RX_ENABLE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_rx_enable(dev);
   2861c:	f011 f85a 	bl	396d4 <z_impl_uart_irq_rx_enable>
}
   28620:	b00b      	add	sp, #44	; 0x2c
   28622:	f85d fb04 	ldr.w	pc, [sp], #4
		sprintf(str, "+CMS ERROR: %d\r\n", err);
   28626:	4b0d      	ldr	r3, [pc, #52]	; (2865c <cmd_send+0xac>)
   28628:	9200      	str	r2, [sp, #0]
		sprintf(str, "+CME ERROR: %d\r\n", err);
   2862a:	2219      	movs	r2, #25
   2862c:	2100      	movs	r1, #0
   2862e:	a803      	add	r0, sp, #12
   28630:	f011 fd07 	bl	3a042 <__sprintf_chk>
		write_uart_string(str);
   28634:	a803      	add	r0, sp, #12
   28636:	e7ed      	b.n	28614 <cmd_send+0x64>
		sprintf(str, "+CME ERROR: %d\r\n", err);
   28638:	9200      	str	r2, [sp, #0]
   2863a:	4b09      	ldr	r3, [pc, #36]	; (28660 <cmd_send+0xb0>)
   2863c:	e7f5      	b.n	2862a <cmd_send+0x7a>
   2863e:	bf00      	nop
   28640:	2002513f 	.word	0x2002513f
   28644:	0003ade0 	.word	0x0003ade0
   28648:	0003adf0 	.word	0x0003adf0
   2864c:	0003e2d6 	.word	0x0003e2d6
   28650:	0003e301 	.word	0x0003e301
   28654:	0003e2fc 	.word	0x0003e2fc
   28658:	200207ec 	.word	0x200207ec
   2865c:	0003e309 	.word	0x0003e309
   28660:	0003e31a 	.word	0x0003e31a

00028664 <isr>:
		k_work_submit_to_queue(&at_host_work_q, &cmd_send_work);
	}
}

static void isr(struct device *dev)
{
   28664:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   28668:	4606      	mov	r6, r0
	if (api->irq_update) {
   2866a:	6843      	ldr	r3, [r0, #4]
   2866c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   2866e:	b103      	cbz	r3, 28672 <isr+0xe>
		return api->irq_update(dev);
   28670:	4798      	blx	r3
	if (api->irq_rx_ready) {
   28672:	6873      	ldr	r3, [r6, #4]
   28674:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   28676:	b1c3      	cbz	r3, 286aa <isr+0x46>
		return api->irq_rx_ready(dev);
   28678:	4630      	mov	r0, r6
   2867a:	4798      	blx	r3
	u8_t character;

	uart_irq_update(dev);

	if (!uart_irq_rx_ready(dev)) {
   2867c:	b1a8      	cbz	r0, 286aa <isr+0x46>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2867e:	f8df a14c 	ldr.w	sl, [pc, #332]	; 287cc <isr+0x168>
   28682:	4d47      	ldr	r5, [pc, #284]	; (287a0 <isr+0x13c>)
   28684:	46d1      	mov	r9, sl
			LOG_WRN("Ignored null; would terminate string early.");
   28686:	4b47      	ldr	r3, [pc, #284]	; (287a4 <isr+0x140>)
		if (at_cmd_len > 0) {
   28688:	4c47      	ldr	r4, [pc, #284]	; (287a8 <isr+0x144>)
			LOG_WRN("Ignored null; would terminate string early.");
   2868a:	1aed      	subs	r5, r5, r3
   2868c:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   28690:	e8da 3faf 	lda	r3, [sl]

	/*
	 * Check that we are not sending data (buffer must be preserved then),
	 * and that a new character is available before handling each character
	 */
	while ((!k_work_pending(&cmd_send_work)) &&
   28694:	07db      	lsls	r3, r3, #31
   28696:	d408      	bmi.n	286aa <isr+0x46>
	if (api->fifo_read) {
   28698:	6873      	ldr	r3, [r6, #4]
   2869a:	699b      	ldr	r3, [r3, #24]
   2869c:	b12b      	cbz	r3, 286aa <isr+0x46>
		return api->fifo_read(dev, rx_data, size);
   2869e:	2201      	movs	r2, #1
   286a0:	f10d 0107 	add.w	r1, sp, #7
   286a4:	4630      	mov	r0, r6
   286a6:	4798      	blx	r3
   286a8:	b910      	cbnz	r0, 286b0 <isr+0x4c>
	       (uart_fifo_read(dev, &character, 1))) {
		uart_rx_handler(character);
	}
}
   286aa:	b002      	add	sp, #8
   286ac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uart_rx_handler(character);
   286b0:	f89d 2007 	ldrb.w	r2, [sp, #7]
	switch (character) {
   286b4:	2a08      	cmp	r2, #8
   286b6:	d001      	beq.n	286bc <isr+0x58>
   286b8:	2a7f      	cmp	r2, #127	; 0x7f
   286ba:	d105      	bne.n	286c8 <isr+0x64>
		if (at_cmd_len > 0) {
   286bc:	6823      	ldr	r3, [r4, #0]
   286be:	2b00      	cmp	r3, #0
   286c0:	d0e6      	beq.n	28690 <isr+0x2c>
			at_cmd_len--;
   286c2:	3b01      	subs	r3, #1
   286c4:	6023      	str	r3, [r4, #0]
   286c6:	e7e3      	b.n	28690 <isr+0x2c>
	if (!inside_quotes) {
   286c8:	4938      	ldr	r1, [pc, #224]	; (287ac <isr+0x148>)
   286ca:	780b      	ldrb	r3, [r1, #0]
   286cc:	b9cb      	cbnz	r3, 28702 <isr+0x9e>
		switch (character) {
   286ce:	2a0a      	cmp	r2, #10
   286d0:	d02b      	beq.n	2872a <isr+0xc6>
   286d2:	2a0d      	cmp	r2, #13
   286d4:	d011      	beq.n	286fa <isr+0x96>
   286d6:	b9a2      	cbnz	r2, 28702 <isr+0x9e>
			if (term_mode == MODE_NULL_TERM) {
   286d8:	4b35      	ldr	r3, [pc, #212]	; (287b0 <isr+0x14c>)
   286da:	781b      	ldrb	r3, [r3, #0]
   286dc:	2b00      	cmp	r3, #0
   286de:	d040      	beq.n	28762 <isr+0xfe>
			LOG_WRN("Ignored null; would terminate string early.");
   286e0:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
   286e4:	f043 0302 	orr.w	r3, r3, #2
   286e8:	f363 0707 	bfi	r7, r3, #0, #8
   286ec:	f365 178f 	bfi	r7, r5, #6, #10
   286f0:	4930      	ldr	r1, [pc, #192]	; (287b4 <isr+0x150>)
   286f2:	4638      	mov	r0, r7
   286f4:	f00f fb3b 	bl	37d6e <log_string_sync>
			return;
   286f8:	e7ca      	b.n	28690 <isr+0x2c>
			if (term_mode == MODE_CR) {
   286fa:	482d      	ldr	r0, [pc, #180]	; (287b0 <isr+0x14c>)
   286fc:	7800      	ldrb	r0, [r0, #0]
   286fe:	2801      	cmp	r0, #1
			    at_cmd_len > 0 &&
   28700:	d02f      	beq.n	28762 <isr+0xfe>
	if (at_cmd_len + 1 > sizeof(at_buf) - 1) {
   28702:	f8d4 c000 	ldr.w	ip, [r4]
   28706:	f10c 0001 	add.w	r0, ip, #1
   2870a:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   2870e:	d31d      	bcc.n	2874c <isr+0xe8>
		LOG_ERR("Buffer overflow, dropping '%c'\n", character);
   28710:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   28714:	f043 0301 	orr.w	r3, r3, #1
   28718:	f363 0807 	bfi	r8, r3, #0, #8
   2871c:	f365 188f 	bfi	r8, r5, #6, #10
   28720:	4925      	ldr	r1, [pc, #148]	; (287b8 <isr+0x154>)
   28722:	4640      	mov	r0, r8
   28724:	f00f fb23 	bl	37d6e <log_string_sync>
		return;
   28728:	e7b2      	b.n	28690 <isr+0x2c>
			if (term_mode == MODE_LF) {
   2872a:	4821      	ldr	r0, [pc, #132]	; (287b0 <isr+0x14c>)
   2872c:	7800      	ldrb	r0, [r0, #0]
   2872e:	2802      	cmp	r0, #2
   28730:	d017      	beq.n	28762 <isr+0xfe>
			if (term_mode == MODE_CR_LF &&
   28732:	2803      	cmp	r0, #3
   28734:	d1e5      	bne.n	28702 <isr+0x9e>
   28736:	f8d4 c000 	ldr.w	ip, [r4]
   2873a:	f1bc 0f00 	cmp.w	ip, #0
   2873e:	d0e0      	beq.n	28702 <isr+0x9e>
			    at_buf[at_cmd_len - 1] == '\r') {
   28740:	481e      	ldr	r0, [pc, #120]	; (287bc <isr+0x158>)
   28742:	4460      	add	r0, ip
			    at_cmd_len > 0 &&
   28744:	f810 0c01 	ldrb.w	r0, [r0, #-1]
   28748:	280d      	cmp	r0, #13
   2874a:	e7d9      	b.n	28700 <isr+0x9c>
	at_buf[at_cmd_len] = character;
   2874c:	f8df e06c 	ldr.w	lr, [pc, #108]	; 287bc <isr+0x158>
	if (character == '"') {
   28750:	2a22      	cmp	r2, #34	; 0x22
	at_buf[at_cmd_len] = character;
   28752:	f80e 200c 	strb.w	r2, [lr, ip]
	at_cmd_len++;
   28756:	6020      	str	r0, [r4, #0]
	if (character == '"') {
   28758:	d19a      	bne.n	28690 <isr+0x2c>
	if (!inside_quotes) {
   2875a:	f083 0301 	eor.w	r3, r3, #1
		inside_quotes = !inside_quotes;
   2875e:	700b      	strb	r3, [r1, #0]
   28760:	e796      	b.n	28690 <isr+0x2c>
	at_buf[at_cmd_len] = '\0'; /* Terminate the command string */
   28762:	2300      	movs	r3, #0
   28764:	4a15      	ldr	r2, [pc, #84]	; (287bc <isr+0x158>)
   28766:	6820      	ldr	r0, [r4, #0]
	inside_quotes = false;
   28768:	700b      	strb	r3, [r1, #0]
	at_buf[at_cmd_len] = '\0'; /* Terminate the command string */
   2876a:	5413      	strb	r3, [r2, r0]
	at_cmd_len = 0;
   2876c:	6023      	str	r3, [r4, #0]
	if (at_buf[0]) {
   2876e:	7813      	ldrb	r3, [r2, #0]
   28770:	2b00      	cmp	r3, #0
   28772:	d08d      	beq.n	28690 <isr+0x2c>
		uart_irq_rx_disable(uart_dev); /* Stop UART to protect at_buf */
   28774:	4b12      	ldr	r3, [pc, #72]	; (287c0 <isr+0x15c>)
   28776:	6818      	ldr	r0, [r3, #0]
	if (api->irq_rx_disable) {
   28778:	6843      	ldr	r3, [r0, #4]
   2877a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2877c:	b103      	cbz	r3, 28780 <isr+0x11c>
		api->irq_rx_disable(dev);
   2877e:	4798      	blx	r3
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   28780:	e8d9 3fef 	ldaex	r3, [r9]
   28784:	f043 0201 	orr.w	r2, r3, #1
   28788:	e8c9 2fe1 	stlex	r1, r2, [r9]
   2878c:	2900      	cmp	r1, #0
   2878e:	d1f7      	bne.n	28780 <isr+0x11c>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   28790:	07da      	lsls	r2, r3, #31
   28792:	f53f af7d 	bmi.w	28690 <isr+0x2c>
		k_queue_append(&work_q->queue, work);
   28796:	490b      	ldr	r1, [pc, #44]	; (287c4 <isr+0x160>)
   28798:	480b      	ldr	r0, [pc, #44]	; (287c8 <isr+0x164>)
   2879a:	f011 f95b 	bl	39a54 <k_queue_append>
   2879e:	e777      	b.n	28690 <isr+0x2c>
   287a0:	0003adf0 	.word	0x0003adf0
   287a4:	0003ade0 	.word	0x0003ade0
   287a8:	20020718 	.word	0x20020718
   287ac:	2002613f 	.word	0x2002613f
   287b0:	20026140 	.word	0x20026140
   287b4:	0003e32b 	.word	0x0003e32b
   287b8:	0003e357 	.word	0x0003e357
   287bc:	2002513f 	.word	0x2002513f
   287c0:	200207ec 	.word	0x200207ec
   287c4:	200207e0 	.word	0x200207e0
   287c8:	2002071c 	.word	0x2002071c
   287cc:	200207e8 	.word	0x200207e8

000287d0 <at_host_init>:

	ARG_UNUSED(arg);

	/* Choosing the termination mode */
	if (mode < MODE_COUNT) {
		term_mode = mode;
   287d0:	2202      	movs	r2, #2
   287d2:	4b49      	ldr	r3, [pc, #292]	; (288f8 <at_host_init+0x128>)
{
   287d4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	default:
		LOG_ERR("Unknown UART instance %d", uart_id);
		return -EINVAL;
	}

	err = at_notif_register_handler(NULL, response_handler);
   287d8:	4948      	ldr	r1, [pc, #288]	; (288fc <at_host_init+0x12c>)
   287da:	2000      	movs	r0, #0
		term_mode = mode;
   287dc:	701a      	strb	r2, [r3, #0]
	err = at_notif_register_handler(NULL, response_handler);
   287de:	f7ff fe37 	bl	28450 <at_notif_register_handler>
	if (err != 0) {
   287e2:	4c47      	ldr	r4, [pc, #284]	; (28900 <at_host_init+0x130>)
   287e4:	4b47      	ldr	r3, [pc, #284]	; (28904 <at_host_init+0x134>)
   287e6:	4606      	mov	r6, r0
   287e8:	1ae4      	subs	r4, r4, r3
   287ea:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   287ee:	b170      	cbz	r0, 2880e <at_host_init+0x3e>
		LOG_ERR("Can't register handler err=%d", err);
   287f0:	f04f 0000 	mov.w	r0, #0
   287f4:	2301      	movs	r3, #1
   287f6:	f363 0007 	bfi	r0, r3, #0, #8
   287fa:	f364 108f 	bfi	r0, r4, #6, #10
   287fe:	4632      	mov	r2, r6
   28800:	4941      	ldr	r1, [pc, #260]	; (28908 <at_host_init+0x138>)
   28802:	f00f fab4 	bl	37d6e <log_string_sync>
		       K_THREAD_STACK_SIZEOF(at_host_stack_area),
		       CONFIG_AT_HOST_THREAD_PRIO);
	uart_irq_rx_enable(uart_dev);

	return err;
}
   28806:	4630      	mov	r0, r6
   28808:	b002      	add	sp, #8
   2880a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2880e:	483f      	ldr	r0, [pc, #252]	; (2890c <at_host_init+0x13c>)
   28810:	f009 fd8a 	bl	32328 <z_impl_device_get_binding>
	uart_dev = device_get_binding(uart_dev_name);
   28814:	4d3e      	ldr	r5, [pc, #248]	; (28910 <at_host_init+0x140>)
   28816:	6028      	str	r0, [r5, #0]
	if (uart_dev == NULL) {
   28818:	b9b8      	cbnz	r0, 2884a <at_host_init+0x7a>
		LOG_ERR("Cannot bind %s\n", uart_dev_name);
   2881a:	2301      	movs	r3, #1
   2881c:	f363 0007 	bfi	r0, r3, #0, #8
   28820:	4a3a      	ldr	r2, [pc, #232]	; (2890c <at_host_init+0x13c>)
   28822:	f364 108f 	bfi	r0, r4, #6, #10
   28826:	493b      	ldr	r1, [pc, #236]	; (28914 <at_host_init+0x144>)
   28828:	f00f faa1 	bl	37d6e <log_string_sync>
		return -EINVAL;
   2882c:	f06f 0215 	mvn.w	r2, #21
		LOG_ERR("UART could not be initialized: %d", err);
   28830:	2301      	movs	r3, #1
   28832:	f04f 0000 	mov.w	r0, #0
   28836:	f363 0007 	bfi	r0, r3, #0, #8
   2883a:	f364 108f 	bfi	r0, r4, #6, #10
   2883e:	4936      	ldr	r1, [pc, #216]	; (28918 <at_host_init+0x148>)
   28840:	f00f fa95 	bl	37d6e <log_string_sync>
		return -EFAULT;
   28844:	f06f 060d 	mvn.w	r6, #13
   28848:	e7dd      	b.n	28806 <at_host_init+0x36>
	return z_impl_k_uptime_get();
   2884a:	f011 f9df 	bl	39c0c <z_impl_k_uptime_get>
   2884e:	4681      	mov	r9, r0
			LOG_INF("UART check failed: %d. "
   28850:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 28934 <at_host_init+0x164>
		err = uart_err_check(uart_dev);
   28854:	6828      	ldr	r0, [r5, #0]
	if (api->err_check != NULL) {
   28856:	6843      	ldr	r3, [r0, #4]
   28858:	689b      	ldr	r3, [r3, #8]
   2885a:	b39b      	cbz	r3, 288c4 <at_host_init+0xf4>
		return api->err_check(dev);
   2885c:	4798      	blx	r3
		if (err) {
   2885e:	4680      	mov	r8, r0
   28860:	b380      	cbz	r0, 288c4 <at_host_init+0xf4>
   28862:	f011 f9d3 	bl	39c0c <z_impl_k_uptime_get>
			if (k_uptime_get_32() - start_time >
   28866:	eba0 0009 	sub.w	r0, r0, r9
   2886a:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
   2886e:	d90d      	bls.n	2888c <at_host_init+0xbc>
				LOG_ERR("UART check failed: %d. "
   28870:	2301      	movs	r3, #1
   28872:	f04f 0000 	mov.w	r0, #0
   28876:	f363 0007 	bfi	r0, r3, #0, #8
   2887a:	4642      	mov	r2, r8
   2887c:	f364 108f 	bfi	r0, r4, #6, #10
   28880:	4926      	ldr	r1, [pc, #152]	; (2891c <at_host_init+0x14c>)
   28882:	f00f fa74 	bl	37d6e <log_string_sync>
				return -EIO;
   28886:	f06f 0204 	mvn.w	r2, #4
   2888a:	e7d1      	b.n	28830 <at_host_init+0x60>
			LOG_INF("UART check failed: %d. "
   2888c:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
   28890:	f043 0303 	orr.w	r3, r3, #3
   28894:	f363 0707 	bfi	r7, r3, #0, #8
   28898:	f364 178f 	bfi	r7, r4, #6, #10
   2889c:	4642      	mov	r2, r8
   2889e:	4651      	mov	r1, sl
   288a0:	4638      	mov	r0, r7
   288a2:	f00f fa64 	bl	37d6e <log_string_sync>
			while (uart_fifo_read(uart_dev, &dummy, 1)) {
   288a6:	6828      	ldr	r0, [r5, #0]
	if (api->fifo_read) {
   288a8:	6843      	ldr	r3, [r0, #4]
   288aa:	699b      	ldr	r3, [r3, #24]
   288ac:	b91b      	cbnz	r3, 288b6 <at_host_init+0xe6>
	return z_impl_k_sleep(ms);
   288ae:	200a      	movs	r0, #10
   288b0:	f00b fe8a 	bl	345c8 <z_impl_k_sleep>
   288b4:	e7ce      	b.n	28854 <at_host_init+0x84>
		return api->fifo_read(dev, rx_data, size);
   288b6:	2201      	movs	r2, #1
   288b8:	f10d 0107 	add.w	r1, sp, #7
   288bc:	4798      	blx	r3
   288be:	2800      	cmp	r0, #0
   288c0:	d1f1      	bne.n	288a6 <at_host_init+0xd6>
   288c2:	e7f4      	b.n	288ae <at_host_init+0xde>
	uart_irq_callback_set(uart_dev, isr);
   288c4:	682a      	ldr	r2, [r5, #0]
	const struct uart_driver_api *api =
   288c6:	6853      	ldr	r3, [r2, #4]
	if ((api != NULL) && (api->irq_callback_set != NULL)) {
   288c8:	b123      	cbz	r3, 288d4 <at_host_init+0x104>
   288ca:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   288cc:	b113      	cbz	r3, 288d4 <at_host_init+0x104>
		api->irq_callback_set(dev, cb, user_data);
   288ce:	4914      	ldr	r1, [pc, #80]	; (28920 <at_host_init+0x150>)
   288d0:	4610      	mov	r0, r2
   288d2:	4798      	blx	r3
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   288d4:	2200      	movs	r2, #0
   288d6:	4b13      	ldr	r3, [pc, #76]	; (28924 <at_host_init+0x154>)
   288d8:	4913      	ldr	r1, [pc, #76]	; (28928 <at_host_init+0x158>)
   288da:	601a      	str	r2, [r3, #0]
   288dc:	e9c3 1201 	strd	r1, r2, [r3, #4]
	k_work_q_start(&at_host_work_q, at_host_stack_area,
   288e0:	4812      	ldr	r0, [pc, #72]	; (2892c <at_host_init+0x15c>)
   288e2:	230a      	movs	r3, #10
   288e4:	f44f 7200 	mov.w	r2, #512	; 0x200
   288e8:	4911      	ldr	r1, [pc, #68]	; (28930 <at_host_init+0x160>)
   288ea:	f00c f95d 	bl	34ba8 <k_work_q_start>
	uart_irq_rx_enable(uart_dev);
   288ee:	6828      	ldr	r0, [r5, #0]
   288f0:	f010 fef0 	bl	396d4 <z_impl_uart_irq_rx_enable>
	return err;
   288f4:	e787      	b.n	28806 <at_host_init+0x36>
   288f6:	bf00      	nop
   288f8:	20026140 	.word	0x20026140
   288fc:	000396df 	.word	0x000396df
   28900:	0003adf0 	.word	0x0003adf0
   28904:	0003ade0 	.word	0x0003ade0
   28908:	0003e21b 	.word	0x0003e21b
   2890c:	0003bda3 	.word	0x0003bda3
   28910:	200207ec 	.word	0x200207ec
   28914:	0003e239 	.word	0x0003e239
   28918:	0003e2b4 	.word	0x0003e2b4
   2891c:	0003e249 	.word	0x0003e249
   28920:	00028665 	.word	0x00028665
   28924:	200207e0 	.word	0x200207e0
   28928:	000285b1 	.word	0x000285b1
   2892c:	2002071c 	.word	0x2002071c
   28930:	200266a0 	.word	0x200266a0
   28934:	0003e27f 	.word	0x0003e27f

00028938 <is_valid_notification_char>:
 * @retval true  If character is valid
 * @retval false If character is not valid
 */
static inline bool is_valid_notification_char(char chr)
{
	chr = toupper(chr);
   28938:	4b06      	ldr	r3, [pc, #24]	; (28954 <is_valid_notification_char+0x1c>)
   2893a:	5cc3      	ldrb	r3, [r0, r3]
   2893c:	f003 0303 	and.w	r3, r3, #3
   28940:	2b02      	cmp	r3, #2
   28942:	bf08      	it	eq
   28944:	3820      	subeq	r0, #32

	if ((chr >= 'A') && (chr <= 'Z')) {
   28946:	3841      	subs	r0, #65	; 0x41
   28948:	b2c0      	uxtb	r0, r0
		return true;
	}

	return false;
}
   2894a:	2819      	cmp	r0, #25
   2894c:	bf8c      	ite	hi
   2894e:	2000      	movhi	r0, #0
   28950:	2001      	movls	r0, #1
   28952:	4770      	bx	lr
   28954:	0003f5ca 	.word	0x0003f5ca

00028958 <at_parse_process_element>:
	return 0;
}

static int at_parse_process_element(const char **str, int index,
				    struct at_param_list *const list)
{
   28958:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	const char *tmpstr = *str;
   2895c:	6805      	ldr	r5, [r0, #0]
{
   2895e:	b0a3      	sub	sp, #140	; 0x8c
	const char *tmpstr = *str;
   28960:	9500      	str	r5, [sp, #0]
 * @retval true  If character is 0
 * @retval false If character is not 0
 */
static inline bool is_terminated(char chr)
{
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   28962:	782b      	ldrb	r3, [r5, #0]
{
   28964:	4680      	mov	r8, r0
   28966:	460f      	mov	r7, r1
   28968:	4616      	mov	r6, r2
   2896a:	2b00      	cmp	r3, #0
   2896c:	f000 80bd 	beq.w	28aea <at_parse_process_element+0x192>

	if (is_terminated(*tmpstr)) {
		return -1;
	}

	if (state == NOTIFICATION) {
   28970:	4b5f      	ldr	r3, [pc, #380]	; (28af0 <at_parse_process_element+0x198>)
   28972:	781c      	ldrb	r4, [r3, #0]
   28974:	2c05      	cmp	r4, #5
   28976:	d110      	bne.n	2899a <at_parse_process_element+0x42>
		const char *start_ptr = tmpstr++;
   28978:	1c6b      	adds	r3, r5, #1
   2897a:	9300      	str	r3, [sp, #0]

		while (is_valid_notification_char(*tmpstr)) {
   2897c:	9a00      	ldr	r2, [sp, #0]
   2897e:	7810      	ldrb	r0, [r2, #0]
   28980:	f7ff ffda 	bl	28938 <is_valid_notification_char>
   28984:	b930      	cbnz	r0, 28994 <at_parse_process_element+0x3c>
			tmpstr++;
		}

		at_params_string_put(list, index, start_ptr,
   28986:	1b53      	subs	r3, r2, r5

		while (isxdigit((int)*tmpstr)) {
			tmpstr++;
		}

		at_params_string_put(list, index, start_ptr,
   28988:	462a      	mov	r2, r5
   2898a:	4639      	mov	r1, r7
   2898c:	4630      	mov	r0, r6
   2898e:	f010 ff1f 	bl	397d0 <at_params_string_put>
   28992:	e01b      	b.n	289cc <at_parse_process_element+0x74>
			tmpstr++;
   28994:	3201      	adds	r2, #1
   28996:	9200      	str	r2, [sp, #0]
   28998:	e7f0      	b.n	2897c <at_parse_process_element+0x24>
	} else if (state == COMMAND) {
   2899a:	2c06      	cmp	r4, #6
   2899c:	d124      	bne.n	289e8 <at_parse_process_element+0x90>
		skip_command_prefix(&tmpstr);
   2899e:	4668      	mov	r0, sp
   289a0:	f010 fea9 	bl	396f6 <skip_command_prefix>
		while (is_valid_notification_char(*tmpstr)) {
   289a4:	9a00      	ldr	r2, [sp, #0]
   289a6:	7810      	ldrb	r0, [r2, #0]
   289a8:	f7ff ffc6 	bl	28938 <is_valid_notification_char>
   289ac:	b9a8      	cbnz	r0, 289da <at_parse_process_element+0x82>
		at_params_string_put(list, index, start_ptr,
   289ae:	1b53      	subs	r3, r2, r5
   289b0:	4639      	mov	r1, r7
   289b2:	462a      	mov	r2, r5
   289b4:	4630      	mov	r0, r6
   289b6:	f010 ff0b 	bl	397d0 <at_params_string_put>
		if ((*tmpstr == AT_CMD_SEPARATOR) &&
   289ba:	9b00      	ldr	r3, [sp, #0]
   289bc:	781a      	ldrb	r2, [r3, #0]
   289be:	2a3d      	cmp	r2, #61	; 0x3d
   289c0:	d10e      	bne.n	289e0 <at_parse_process_element+0x88>
   289c2:	785a      	ldrb	r2, [r3, #1]
   289c4:	2a3f      	cmp	r2, #63	; 0x3f
   289c6:	d101      	bne.n	289cc <at_parse_process_element+0x74>
			tmpstr += 2;
   289c8:	3302      	adds	r3, #2
			tmpstr++;
   289ca:	9300      	str	r3, [sp, #0]
				     tmpstr - start_ptr);
	}

	*str = tmpstr;
	return 0;
   289cc:	2000      	movs	r0, #0
	*str = tmpstr;
   289ce:	9b00      	ldr	r3, [sp, #0]
   289d0:	f8c8 3000 	str.w	r3, [r8]
}
   289d4:	b023      	add	sp, #140	; 0x8c
   289d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			tmpstr++;
   289da:	3201      	adds	r2, #1
   289dc:	9200      	str	r2, [sp, #0]
   289de:	e7e1      	b.n	289a4 <at_parse_process_element+0x4c>
		} else if (*tmpstr == AT_CMD_READ_TEST_IDENTIFIER) {
   289e0:	2a3f      	cmp	r2, #63	; 0x3f
   289e2:	d1f3      	bne.n	289cc <at_parse_process_element+0x74>
			tmpstr++;
   289e4:	3301      	adds	r3, #1
   289e6:	e7f0      	b.n	289ca <at_parse_process_element+0x72>
	} else if (state == OPTIONAL) {
   289e8:	2c07      	cmp	r4, #7
   289ea:	d103      	bne.n	289f4 <at_parse_process_element+0x9c>
		at_params_empty_put(list, index);
   289ec:	4610      	mov	r0, r2
   289ee:	f010 fec6 	bl	3977e <at_params_empty_put>
   289f2:	e7eb      	b.n	289cc <at_parse_process_element+0x74>
	} else if (state == STRING) {
   289f4:	2c02      	cmp	r4, #2
   289f6:	d112      	bne.n	28a1e <at_parse_process_element+0xc6>
		while (!is_dblquote(*tmpstr) && !is_terminated(*tmpstr) &&
   289f8:	9a00      	ldr	r2, [sp, #0]
   289fa:	7810      	ldrb	r0, [r2, #0]
 * @retval true  If character is "
 * @retval false If character is something else
 */
static inline bool is_dblquote(char chr)
{
	if (chr == '"') {
   289fc:	2822      	cmp	r0, #34	; 0x22
   289fe:	d003      	beq.n	28a08 <at_parse_process_element+0xb0>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   28a00:	b110      	cbz	r0, 28a08 <at_parse_process_element+0xb0>
		       !is_lfcr(*tmpstr)) {
   28a02:	f010 fe6f 	bl	396e4 <is_lfcr>
		while (!is_dblquote(*tmpstr) && !is_terminated(*tmpstr) &&
   28a06:	b138      	cbz	r0, 28a18 <at_parse_process_element+0xc0>
		at_params_string_put(list, index, start_ptr,
   28a08:	1b53      	subs	r3, r2, r5
   28a0a:	4639      	mov	r1, r7
   28a0c:	462a      	mov	r2, r5
   28a0e:	4630      	mov	r0, r6
   28a10:	f010 fede 	bl	397d0 <at_params_string_put>
		tmpstr++;
   28a14:	9b00      	ldr	r3, [sp, #0]
   28a16:	e7e5      	b.n	289e4 <at_parse_process_element+0x8c>
			tmpstr++;
   28a18:	3201      	adds	r2, #1
   28a1a:	9200      	str	r2, [sp, #0]
   28a1c:	e7ec      	b.n	289f8 <at_parse_process_element+0xa0>
	} else if (state == ARRAY) {
   28a1e:	2c01      	cmp	r4, #1
   28a20:	d13c      	bne.n	28a9c <at_parse_process_element+0x144>
		tmparray[i++] = (u32_t)strtoul(tmpstr, &next, 10);
   28a22:	4628      	mov	r0, r5
   28a24:	220a      	movs	r2, #10
   28a26:	a901      	add	r1, sp, #4
   28a28:	f00d fe36 	bl	36698 <strtoul>
		tmpstr = next;
   28a2c:	9b01      	ldr	r3, [sp, #4]
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   28a2e:	4d31      	ldr	r5, [pc, #196]	; (28af4 <at_parse_process_element+0x19c>)
		tmparray[i++] = (u32_t)strtoul(tmpstr, &next, 10);
   28a30:	9002      	str	r0, [sp, #8]
		tmpstr = next;
   28a32:	9300      	str	r3, [sp, #0]
		while (!is_array_stop(*tmpstr) && !is_terminated(*tmpstr)) {
   28a34:	9800      	ldr	r0, [sp, #0]
   28a36:	7803      	ldrb	r3, [r0, #0]
 * @retval true  If character is )
 * @retval false If character is something else
 */
static inline bool is_array_stop(char chr)
{
	if (chr == ')') {
   28a38:	2b29      	cmp	r3, #41	; 0x29
   28a3a:	d028      	beq.n	28a8e <at_parse_process_element+0x136>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   28a3c:	b33b      	cbz	r3, 28a8e <at_parse_process_element+0x136>
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   28a3e:	3b2c      	subs	r3, #44	; 0x2c
   28a40:	b2db      	uxtb	r3, r3
   28a42:	3001      	adds	r0, #1
   28a44:	2b11      	cmp	r3, #17
				tmparray[i++] =
   28a46:	9000      	str	r0, [sp, #0]
   28a48:	d803      	bhi.n	28a52 <at_parse_process_element+0xfa>
   28a4a:	fa25 f303 	lsr.w	r3, r5, r3
   28a4e:	07db      	lsls	r3, r3, #31
   28a50:	d408      	bmi.n	28a64 <at_parse_process_element+0x10c>
				tmpstr++;
   28a52:	46a1      	mov	r9, r4
   28a54:	e004      	b.n	28a60 <at_parse_process_element+0x108>
					tmpstr = next;
   28a56:	9b01      	ldr	r3, [sp, #4]
			if (i == AT_CMD_MAX_ARRAY_SIZE) {
   28a58:	f1b9 0f20 	cmp.w	r9, #32
					tmpstr = next;
   28a5c:	9300      	str	r3, [sp, #0]
			if (i == AT_CMD_MAX_ARRAY_SIZE) {
   28a5e:	d015      	beq.n	28a8c <at_parse_process_element+0x134>
				tmpstr++;
   28a60:	464c      	mov	r4, r9
   28a62:	e7e7      	b.n	28a34 <at_parse_process_element+0xdc>
					(u32_t)strtoul(++tmpstr, &next, 10);
   28a64:	220a      	movs	r2, #10
   28a66:	a901      	add	r1, sp, #4
   28a68:	f00d fe16 	bl	36698 <strtoul>
				tmparray[i++] =
   28a6c:	ab22      	add	r3, sp, #136	; 0x88
   28a6e:	f104 0901 	add.w	r9, r4, #1
   28a72:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   28a76:	f844 0c80 	str.w	r0, [r4, #-128]
				if (strlen(tmpstr) == strlen(next)) {
   28a7a:	9800      	ldr	r0, [sp, #0]
   28a7c:	f7f4 fb6c 	bl	1d158 <strlen>
   28a80:	4604      	mov	r4, r0
   28a82:	9801      	ldr	r0, [sp, #4]
   28a84:	f7f4 fb68 	bl	1d158 <strlen>
   28a88:	4284      	cmp	r4, r0
   28a8a:	d1e4      	bne.n	28a56 <at_parse_process_element+0xfe>
   28a8c:	464c      	mov	r4, r9
		at_params_array_put(list, index, tmparray, i * sizeof(u32_t));
   28a8e:	00a3      	lsls	r3, r4, #2
   28a90:	aa02      	add	r2, sp, #8
   28a92:	4639      	mov	r1, r7
   28a94:	4630      	mov	r0, r6
   28a96:	f010 fec1 	bl	3981c <at_params_array_put>
   28a9a:	e7bb      	b.n	28a14 <at_parse_process_element+0xbc>
	} else if (state == NUMBER) {
   28a9c:	2c03      	cmp	r4, #3
   28a9e:	d115      	bne.n	28acc <at_parse_process_element+0x174>
		int value = (u32_t)strtoul(tmpstr, &next, 10);
   28aa0:	220a      	movs	r2, #10
   28aa2:	a902      	add	r1, sp, #8
   28aa4:	4628      	mov	r0, r5
   28aa6:	f00d fdf7 	bl	36698 <strtoul>
		tmpstr = next;
   28aaa:	9b02      	ldr	r3, [sp, #8]
		if (value <= USHRT_MAX) {
   28aac:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
		int value = (u32_t)strtoul(tmpstr, &next, 10);
   28ab0:	4602      	mov	r2, r0
		tmpstr = next;
   28ab2:	9300      	str	r3, [sp, #0]
		if (value <= USHRT_MAX) {
   28ab4:	da05      	bge.n	28ac2 <at_parse_process_element+0x16a>
			at_params_short_put(list, index, (u16_t)value);
   28ab6:	b282      	uxth	r2, r0
   28ab8:	4639      	mov	r1, r7
   28aba:	4630      	mov	r0, r6
   28abc:	f010 fe4a 	bl	39754 <at_params_short_put>
   28ac0:	e784      	b.n	289cc <at_parse_process_element+0x74>
			at_params_int_put(list, index, value);
   28ac2:	4639      	mov	r1, r7
   28ac4:	4630      	mov	r0, r6
   28ac6:	f010 fe6e 	bl	397a6 <at_params_int_put>
   28aca:	e77f      	b.n	289cc <at_parse_process_element+0x74>
	} else if (state == SMS_PDU) {
   28acc:	2c04      	cmp	r4, #4
   28ace:	f47f af7d 	bne.w	289cc <at_parse_process_element+0x74>
		while (isxdigit((int)*tmpstr)) {
   28ad2:	4909      	ldr	r1, [pc, #36]	; (28af8 <at_parse_process_element+0x1a0>)
   28ad4:	9b00      	ldr	r3, [sp, #0]
   28ad6:	781a      	ldrb	r2, [r3, #0]
   28ad8:	5c52      	ldrb	r2, [r2, r1]
   28ada:	f012 0f44 	tst.w	r2, #68	; 0x44
   28ade:	d101      	bne.n	28ae4 <at_parse_process_element+0x18c>
		at_params_string_put(list, index, start_ptr,
   28ae0:	1b5b      	subs	r3, r3, r5
   28ae2:	e751      	b.n	28988 <at_parse_process_element+0x30>
			tmpstr++;
   28ae4:	3301      	adds	r3, #1
   28ae6:	9300      	str	r3, [sp, #0]
   28ae8:	e7f4      	b.n	28ad4 <at_parse_process_element+0x17c>
		return -1;
   28aea:	f04f 30ff 	mov.w	r0, #4294967295
   28aee:	e771      	b.n	289d4 <at_parse_process_element+0x7c>
   28af0:	20026141 	.word	0x20026141
   28af4:	00024001 	.word	0x00024001
   28af8:	0003f5ca 	.word	0x0003f5ca

00028afc <is_command>:
 *
 * @retval true  If the string is an AT command
 * @retval false Otherwise
 */
static inline bool is_command(const char *str)
{
   28afc:	b510      	push	{r4, lr}
   28afe:	4604      	mov	r4, r0
	if (strlen(str) < 2) {
   28b00:	f7f4 fb2a 	bl	1d158 <strlen>
   28b04:	2801      	cmp	r0, #1
   28b06:	d922      	bls.n	28b4e <is_command+0x52>
		return false;
	}

	if ((toupper(str[0]) != 'A') || (toupper(str[1]) != 'T')) {
   28b08:	7821      	ldrb	r1, [r4, #0]
   28b0a:	4b13      	ldr	r3, [pc, #76]	; (28b58 <is_command+0x5c>)
   28b0c:	5cca      	ldrb	r2, [r1, r3]
   28b0e:	f002 0203 	and.w	r2, r2, #3
   28b12:	2a02      	cmp	r2, #2
   28b14:	bf08      	it	eq
   28b16:	3920      	subeq	r1, #32
   28b18:	2941      	cmp	r1, #65	; 0x41
   28b1a:	461a      	mov	r2, r3
   28b1c:	d117      	bne.n	28b4e <is_command+0x52>
   28b1e:	7863      	ldrb	r3, [r4, #1]
   28b20:	5cd2      	ldrb	r2, [r2, r3]
   28b22:	f002 0203 	and.w	r2, r2, #3
   28b26:	2a02      	cmp	r2, #2
   28b28:	bf08      	it	eq
   28b2a:	3b20      	subeq	r3, #32
   28b2c:	2b54      	cmp	r3, #84	; 0x54
   28b2e:	d10e      	bne.n	28b4e <is_command+0x52>
	}

	/* Third character has be one of the command special characters.
	 * The special case is a lone "AT" command.
	 */
	if ((str[2] == AT_STANDARD_NOTIFICATION_PREFIX) ||
   28b30:	78a2      	ldrb	r2, [r4, #2]
   28b32:	2a25      	cmp	r2, #37	; 0x25
   28b34:	d00d      	beq.n	28b52 <is_command+0x56>
	    (str[2] == AT_PROP_NOTIFICATION_PREFX) ||
   28b36:	f002 03f7 	and.w	r3, r2, #247	; 0xf7
   28b3a:	2b23      	cmp	r3, #35	; 0x23
   28b3c:	d009      	beq.n	28b52 <is_command+0x56>
	    (str[2] == AT_CUSTOM_COMMAND_PREFX) ||
	    is_lfcr(str[2]) || is_terminated(str[2])) {
   28b3e:	4610      	mov	r0, r2
   28b40:	f010 fdd0 	bl	396e4 <is_lfcr>
	    (str[2] == AT_CUSTOM_COMMAND_PREFX) ||
   28b44:	b910      	cbnz	r0, 28b4c <is_command+0x50>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   28b46:	fab2 f082 	clz	r0, r2
   28b4a:	0940      	lsrs	r0, r0, #5
		return true;
	}

	return false;
}
   28b4c:	bd10      	pop	{r4, pc}
	return false;
   28b4e:	2000      	movs	r0, #0
   28b50:	e7fc      	b.n	28b4c <is_command+0x50>
		return true;
   28b52:	2001      	movs	r0, #1
   28b54:	e7fa      	b.n	28b4c <is_command+0x50>
   28b56:	bf00      	nop
   28b58:	0003f5ca 	.word	0x0003f5ca

00028b5c <at_parse_detect_type>:
{
   28b5c:	b570      	push	{r4, r5, r6, lr}
	const char *tmpstr = *str;
   28b5e:	6804      	ldr	r4, [r0, #0]
	if ((index == 0) && is_notification(*tmpstr)) {
   28b60:	2900      	cmp	r1, #0
{
   28b62:	4606      	mov	r6, r0
   28b64:	7822      	ldrb	r2, [r4, #0]
	if ((index == 0) && is_notification(*tmpstr)) {
   28b66:	d141      	bne.n	28bec <at_parse_detect_type+0x90>
	if ((chr == AT_STANDARD_NOTIFICATION_PREFIX) ||
   28b68:	2a2b      	cmp	r2, #43	; 0x2b
   28b6a:	4d29      	ldr	r5, [pc, #164]	; (28c10 <at_parse_detect_type+0xb4>)
   28b6c:	d001      	beq.n	28b72 <at_parse_detect_type+0x16>
   28b6e:	2a25      	cmp	r2, #37	; 0x25
   28b70:	d104      	bne.n	28b7c <at_parse_detect_type+0x20>
	state = new_state;
   28b72:	2305      	movs	r3, #5
   28b74:	702b      	strb	r3, [r5, #0]
	return 0;
   28b76:	2000      	movs	r0, #0
	*str = tmpstr;
   28b78:	6034      	str	r4, [r6, #0]
}
   28b7a:	bd70      	pop	{r4, r5, r6, pc}
	} else if ((index == 0) && is_command(tmpstr)) {
   28b7c:	4620      	mov	r0, r4
   28b7e:	f7ff ffbd 	bl	28afc <is_command>
   28b82:	b388      	cbz	r0, 28be8 <at_parse_detect_type+0x8c>
	state = new_state;
   28b84:	2306      	movs	r3, #6
   28b86:	e7f5      	b.n	28b74 <at_parse_detect_type+0x18>
	if (chr == '"') {
   28b88:	2a22      	cmp	r2, #34	; 0x22
   28b8a:	d006      	beq.n	28b9a <at_parse_detect_type+0x3e>
	if (chr == '(') {
   28b8c:	2a28      	cmp	r2, #40	; 0x28
   28b8e:	d109      	bne.n	28ba4 <at_parse_detect_type+0x48>
   28b90:	2201      	movs	r2, #1
   28b92:	4b1f      	ldr	r3, [pc, #124]	; (28c10 <at_parse_detect_type+0xb4>)
		tmpstr++;
   28b94:	4414      	add	r4, r2
	state = new_state;
   28b96:	701a      	strb	r2, [r3, #0]
		tmpstr++;
   28b98:	e7ed      	b.n	28b76 <at_parse_detect_type+0x1a>
	state = new_state;
   28b9a:	2202      	movs	r2, #2
   28b9c:	4b1c      	ldr	r3, [pc, #112]	; (28c10 <at_parse_detect_type+0xb4>)
		tmpstr++;
   28b9e:	3401      	adds	r4, #1
	state = new_state;
   28ba0:	701a      	strb	r2, [r3, #0]
		tmpstr++;
   28ba2:	e7e8      	b.n	28b76 <at_parse_detect_type+0x1a>
	} else if (is_lfcr(*tmpstr) && (state == NUMBER)) {
   28ba4:	4610      	mov	r0, r2
   28ba6:	f010 fd9d 	bl	396e4 <is_lfcr>
   28baa:	b170      	cbz	r0, 28bca <at_parse_detect_type+0x6e>
   28bac:	4918      	ldr	r1, [pc, #96]	; (28c10 <at_parse_detect_type+0xb4>)
   28bae:	7808      	ldrb	r0, [r1, #0]
   28bb0:	2803      	cmp	r0, #3
   28bb2:	d108      	bne.n	28bc6 <at_parse_detect_type+0x6a>
		while (is_lfcr(*tmpstr)) {
   28bb4:	f814 0f01 	ldrb.w	r0, [r4, #1]!
   28bb8:	f010 fd94 	bl	396e4 <is_lfcr>
   28bbc:	2800      	cmp	r0, #0
   28bbe:	d1f9      	bne.n	28bb4 <at_parse_detect_type+0x58>
	state = new_state;
   28bc0:	2304      	movs	r3, #4
   28bc2:	700b      	strb	r3, [r1, #0]
   28bc4:	e7d7      	b.n	28b76 <at_parse_detect_type+0x1a>
	} else if (is_lfcr(*tmpstr) && (state == OPTIONAL)) {
   28bc6:	2807      	cmp	r0, #7
   28bc8:	d0d5      	beq.n	28b76 <at_parse_detect_type+0x1a>
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   28bca:	3a2c      	subs	r2, #44	; 0x2c
   28bcc:	b2d2      	uxtb	r2, r2
   28bce:	2a11      	cmp	r2, #17
   28bd0:	d807      	bhi.n	28be2 <at_parse_detect_type+0x86>
   28bd2:	4b10      	ldr	r3, [pc, #64]	; (28c14 <at_parse_detect_type+0xb8>)
   28bd4:	fa23 f202 	lsr.w	r2, r3, r2
   28bd8:	07d3      	lsls	r3, r2, #31
   28bda:	d502      	bpl.n	28be2 <at_parse_detect_type+0x86>
	state = new_state;
   28bdc:	4b0c      	ldr	r3, [pc, #48]	; (28c10 <at_parse_detect_type+0xb4>)
   28bde:	2207      	movs	r2, #7
   28be0:	e013      	b.n	28c0a <at_parse_detect_type+0xae>
		return -1;
   28be2:	f04f 30ff 	mov.w	r0, #4294967295
   28be6:	e7c8      	b.n	28b7a <at_parse_detect_type+0x1e>
	state = new_state;
   28be8:	2302      	movs	r3, #2
   28bea:	e7c3      	b.n	28b74 <at_parse_detect_type+0x18>
	} else if ((index > 0) && is_notification(*tmpstr)) {
   28bec:	dd03      	ble.n	28bf6 <at_parse_detect_type+0x9a>
	if ((chr == AT_STANDARD_NOTIFICATION_PREFIX) ||
   28bee:	2a2b      	cmp	r2, #43	; 0x2b
   28bf0:	d0f7      	beq.n	28be2 <at_parse_detect_type+0x86>
   28bf2:	2a25      	cmp	r2, #37	; 0x25
   28bf4:	d0f5      	beq.n	28be2 <at_parse_detect_type+0x86>
	if (isdigit(chr) || (chr == '-') || (chr == '+')) {
   28bf6:	4b08      	ldr	r3, [pc, #32]	; (28c18 <at_parse_detect_type+0xbc>)
   28bf8:	5cd3      	ldrb	r3, [r2, r3]
   28bfa:	0759      	lsls	r1, r3, #29
   28bfc:	d403      	bmi.n	28c06 <at_parse_detect_type+0xaa>
   28bfe:	2a2d      	cmp	r2, #45	; 0x2d
   28c00:	d001      	beq.n	28c06 <at_parse_detect_type+0xaa>
   28c02:	2a2b      	cmp	r2, #43	; 0x2b
   28c04:	d1c0      	bne.n	28b88 <at_parse_detect_type+0x2c>
	state = new_state;
   28c06:	2203      	movs	r2, #3
   28c08:	4b01      	ldr	r3, [pc, #4]	; (28c10 <at_parse_detect_type+0xb4>)
   28c0a:	701a      	strb	r2, [r3, #0]
   28c0c:	e7b3      	b.n	28b76 <at_parse_detect_type+0x1a>
   28c0e:	bf00      	nop
   28c10:	20026141 	.word	0x20026141
   28c14:	00024001 	.word	0x00024001
   28c18:	0003f5ca 	.word	0x0003f5ca

00028c1c <at_parser_max_params_from_str>:

int at_parser_max_params_from_str(const char *at_params_str,
				  char **next_param_str,
				  struct at_param_list *const list,
				  size_t max_params_count)
{
   28c1c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   28c20:	4688      	mov	r8, r1
   28c22:	4616      	mov	r6, r2
   28c24:	461f      	mov	r7, r3
	int err = 0;

	if (at_params_str == NULL || list == NULL || list->params == NULL) {
   28c26:	4604      	mov	r4, r0
   28c28:	2800      	cmp	r0, #0
   28c2a:	d07e      	beq.n	28d2a <at_parser_max_params_from_str+0x10e>
   28c2c:	2a00      	cmp	r2, #0
   28c2e:	d07c      	beq.n	28d2a <at_parser_max_params_from_str+0x10e>
   28c30:	6853      	ldr	r3, [r2, #4]
   28c32:	2b00      	cmp	r3, #0
   28c34:	d079      	beq.n	28d2a <at_parser_max_params_from_str+0x10e>
	state = IDLE;
   28c36:	2500      	movs	r5, #0
		return -EINVAL;
	}

	at_params_list_clear(list);
   28c38:	4610      	mov	r0, r2
   28c3a:	f000 f8eb 	bl	28e14 <at_params_list_clear>

	max_params_count = MIN(max_params_count, list->param_count);
   28c3e:	6832      	ldr	r2, [r6, #0]
	const char *str = *at_params_str;
   28c40:	9401      	str	r4, [sp, #4]
	max_params_count = MIN(max_params_count, list->param_count);
   28c42:	4297      	cmp	r7, r2
   28c44:	bf28      	it	cs
   28c46:	4617      	movcs	r7, r2
	int index = 0;
   28c48:	462c      	mov	r4, r5
	state = IDLE;
   28c4a:	4b39      	ldr	r3, [pc, #228]	; (28d30 <at_parser_max_params_from_str+0x114>)
		if (isspace((int)*str)) {
   28c4c:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 28d34 <at_parser_max_params_from_str+0x118>
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   28c50:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 28d38 <at_parser_max_params_from_str+0x11c>
	state = IDLE;
   28c54:	701d      	strb	r5, [r3, #0]
	while ((!is_terminated(*str)) && (index < max_params)) {
   28c56:	9b01      	ldr	r3, [sp, #4]
   28c58:	781a      	ldrb	r2, [r3, #0]
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   28c5a:	2a00      	cmp	r2, #0
   28c5c:	d04b      	beq.n	28cf6 <at_parser_max_params_from_str+0xda>
   28c5e:	42a7      	cmp	r7, r4
   28c60:	d949      	bls.n	28cf6 <at_parser_max_params_from_str+0xda>
		if (isspace((int)*str)) {
   28c62:	f812 2009 	ldrb.w	r2, [r2, r9]
		if (at_parse_detect_type(&str, index) == -1) {
   28c66:	a801      	add	r0, sp, #4
		if (isspace((int)*str)) {
   28c68:	0711      	lsls	r1, r2, #28
			str++;
   28c6a:	bf48      	it	mi
   28c6c:	3301      	addmi	r3, #1
		if (at_parse_detect_type(&str, index) == -1) {
   28c6e:	4621      	mov	r1, r4
			str++;
   28c70:	bf48      	it	mi
   28c72:	9301      	strmi	r3, [sp, #4]
		if (at_parse_detect_type(&str, index) == -1) {
   28c74:	f7ff ff72 	bl	28b5c <at_parse_detect_type>
   28c78:	1c42      	adds	r2, r0, #1
   28c7a:	d03c      	beq.n	28cf6 <at_parser_max_params_from_str+0xda>
		if (at_parse_process_element(&str, index, list) == -1) {
   28c7c:	4632      	mov	r2, r6
   28c7e:	4621      	mov	r1, r4
   28c80:	a801      	add	r0, sp, #4
   28c82:	f7ff fe69 	bl	28958 <at_parse_process_element>
   28c86:	1c43      	adds	r3, r0, #1
   28c88:	d035      	beq.n	28cf6 <at_parser_max_params_from_str+0xda>
		if (is_separator(*str)) {
   28c8a:	9b01      	ldr	r3, [sp, #4]
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   28c8c:	781a      	ldrb	r2, [r3, #0]
   28c8e:	3a2c      	subs	r2, #44	; 0x2c
   28c90:	b2d2      	uxtb	r2, r2
   28c92:	2a11      	cmp	r2, #17
   28c94:	d81a      	bhi.n	28ccc <at_parser_max_params_from_str+0xb0>
   28c96:	fa2a f202 	lsr.w	r2, sl, r2
   28c9a:	07d1      	lsls	r1, r2, #31
   28c9c:	d516      	bpl.n	28ccc <at_parser_max_params_from_str+0xb0>
			if (is_lfcr(*(str + 1))) {
   28c9e:	7858      	ldrb	r0, [r3, #1]
   28ca0:	f010 fd20 	bl	396e4 <is_lfcr>
   28ca4:	b178      	cbz	r0, 28cc6 <at_parser_max_params_from_str+0xaa>
				index++;
   28ca6:	3401      	adds	r4, #1
				if (index == max_params) {
   28ca8:	42bc      	cmp	r4, r7
   28caa:	d039      	beq.n	28d20 <at_parser_max_params_from_str+0x104>
				if (at_parse_detect_type(&str, index) == -1) {
   28cac:	4621      	mov	r1, r4
   28cae:	a801      	add	r0, sp, #4
   28cb0:	f7ff ff54 	bl	28b5c <at_parse_detect_type>
   28cb4:	1c42      	adds	r2, r0, #1
   28cb6:	d01e      	beq.n	28cf6 <at_parser_max_params_from_str+0xda>
				if (at_parse_process_element(&str, index,
   28cb8:	4632      	mov	r2, r6
   28cba:	4621      	mov	r1, r4
   28cbc:	a801      	add	r0, sp, #4
   28cbe:	f7ff fe4b 	bl	28958 <at_parse_process_element>
   28cc2:	1c43      	adds	r3, r0, #1
   28cc4:	d017      	beq.n	28cf6 <at_parser_max_params_from_str+0xda>
			str++;
   28cc6:	9b01      	ldr	r3, [sp, #4]
   28cc8:	3301      	adds	r3, #1
   28cca:	9301      	str	r3, [sp, #4]
		if (is_lfcr(*str)) {
   28ccc:	9a01      	ldr	r2, [sp, #4]
   28cce:	7810      	ldrb	r0, [r2, #0]
   28cd0:	f010 fd08 	bl	396e4 <is_lfcr>
   28cd4:	b1f8      	cbz	r0, 28d16 <at_parser_max_params_from_str+0xfa>
   28cd6:	3201      	adds	r2, #1
			while (is_lfcr(str[++i])) {
   28cd8:	7811      	ldrb	r1, [r2, #0]
   28cda:	4693      	mov	fp, r2
   28cdc:	4608      	mov	r0, r1
   28cde:	3201      	adds	r2, #1
   28ce0:	f010 fd00 	bl	396e4 <is_lfcr>
   28ce4:	2800      	cmp	r0, #0
   28ce6:	d1f7      	bne.n	28cd8 <at_parser_max_params_from_str+0xbc>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   28ce8:	b119      	cbz	r1, 28cf2 <at_parser_max_params_from_str+0xd6>
	if ((chr == AT_STANDARD_NOTIFICATION_PREFIX) ||
   28cea:	292b      	cmp	r1, #43	; 0x2b
   28cec:	d001      	beq.n	28cf2 <at_parser_max_params_from_str+0xd6>
   28cee:	2925      	cmp	r1, #37	; 0x25
   28cf0:	d111      	bne.n	28d16 <at_parser_max_params_from_str+0xfa>
				str += i;
   28cf2:	f8cd b004 	str.w	fp, [sp, #4]
	*at_params_str = str;
   28cf6:	9b01      	ldr	r3, [sp, #4]
	if (oversized) {
   28cf8:	b9a5      	cbnz	r5, 28d24 <at_parser_max_params_from_str+0x108>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   28cfa:	781a      	ldrb	r2, [r3, #0]
		return -EAGAIN;
   28cfc:	2a00      	cmp	r2, #0
   28cfe:	bf0c      	ite	eq
   28d00:	2000      	moveq	r0, #0
   28d02:	f06f 000a 	mvnne.w	r0, #10

	err = at_parse_param(&at_params_str, list, max_params_count);

	if (next_param_str) {
   28d06:	f1b8 0f00 	cmp.w	r8, #0
   28d0a:	d001      	beq.n	28d10 <at_parser_max_params_from_str+0xf4>
		*next_param_str = (char *)at_params_str;
   28d0c:	f8c8 3000 	str.w	r3, [r8]
	}

	return err;
}
   28d10:	b003      	add	sp, #12
   28d12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		index++;
   28d16:	3401      	adds	r4, #1
			oversized = true;
   28d18:	42bc      	cmp	r4, r7
   28d1a:	bf08      	it	eq
   28d1c:	2501      	moveq	r5, #1
   28d1e:	e79a      	b.n	28c56 <at_parser_max_params_from_str+0x3a>
					oversized = true;
   28d20:	4605      	mov	r5, r0
   28d22:	e7e8      	b.n	28cf6 <at_parser_max_params_from_str+0xda>
		return -E2BIG;
   28d24:	f06f 0006 	mvn.w	r0, #6
   28d28:	e7ed      	b.n	28d06 <at_parser_max_params_from_str+0xea>
		return -EINVAL;
   28d2a:	f06f 0015 	mvn.w	r0, #21
   28d2e:	e7ef      	b.n	28d10 <at_parser_max_params_from_str+0xf4>
   28d30:	20026141 	.word	0x20026141
   28d34:	0003f5ca 	.word	0x0003f5ca
   28d38:	00024001 	.word	0x00024001

00028d3c <at_params_get>:
}

/* Internal function. Parameter cannot be null. */
static struct at_param *at_params_get(const struct at_param_list *list,
				      size_t index)
{
   28d3c:	b538      	push	{r3, r4, r5, lr}
   28d3e:	460c      	mov	r4, r1
	__ASSERT(list != NULL, "Parameter list cannot be NULL.");
   28d40:	4605      	mov	r5, r0
   28d42:	b960      	cbnz	r0, 28d5e <at_params_get+0x22>
   28d44:	490a      	ldr	r1, [pc, #40]	; (28d70 <at_params_get+0x34>)
   28d46:	232b      	movs	r3, #43	; 0x2b
   28d48:	4a0a      	ldr	r2, [pc, #40]	; (28d74 <at_params_get+0x38>)
   28d4a:	480b      	ldr	r0, [pc, #44]	; (28d78 <at_params_get+0x3c>)
   28d4c:	f00e ffb8 	bl	37cc0 <printk>
   28d50:	480a      	ldr	r0, [pc, #40]	; (28d7c <at_params_get+0x40>)
   28d52:	f00e ffb5 	bl	37cc0 <printk>
   28d56:	212b      	movs	r1, #43	; 0x2b
   28d58:	4806      	ldr	r0, [pc, #24]	; (28d74 <at_params_get+0x38>)
   28d5a:	f00e fff7 	bl	37d4c <assert_post_action>

	if (index >= list->param_count) {
   28d5e:	682b      	ldr	r3, [r5, #0]
   28d60:	42a3      	cmp	r3, r4
		return NULL;
	}

	struct at_param *param = list->params;

	return &param[index];
   28d62:	bf85      	ittet	hi
   28d64:	230c      	movhi	r3, #12
   28d66:	6868      	ldrhi	r0, [r5, #4]
		return NULL;
   28d68:	2000      	movls	r0, #0
	return &param[index];
   28d6a:	fb03 0004 	mlahi	r0, r3, r4, r0
}
   28d6e:	bd38      	pop	{r3, r4, r5, pc}
   28d70:	0003e3de 	.word	0x0003e3de
   28d74:	0003e3b0 	.word	0x0003e3b0
   28d78:	0003baac 	.word	0x0003baac
   28d7c:	0003e3f2 	.word	0x0003e3f2

00028d80 <at_param_size>:

/* Internal function. Parameter cannot be null. */
static size_t at_param_size(const struct at_param *param)
{
   28d80:	b510      	push	{r4, lr}
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   28d82:	4604      	mov	r4, r0
   28d84:	b960      	cbnz	r0, 28da0 <at_param_size+0x20>
   28d86:	490e      	ldr	r1, [pc, #56]	; (28dc0 <at_param_size+0x40>)
   28d88:	2339      	movs	r3, #57	; 0x39
   28d8a:	4a0e      	ldr	r2, [pc, #56]	; (28dc4 <at_param_size+0x44>)
   28d8c:	480e      	ldr	r0, [pc, #56]	; (28dc8 <at_param_size+0x48>)
   28d8e:	f00e ff97 	bl	37cc0 <printk>
   28d92:	480e      	ldr	r0, [pc, #56]	; (28dcc <at_param_size+0x4c>)
   28d94:	f00e ff94 	bl	37cc0 <printk>
   28d98:	2139      	movs	r1, #57	; 0x39
   28d9a:	480a      	ldr	r0, [pc, #40]	; (28dc4 <at_param_size+0x44>)
   28d9c:	f00e ffd6 	bl	37d4c <assert_post_action>

	if (param->type == AT_PARAM_TYPE_NUM_SHORT) {
   28da0:	7823      	ldrb	r3, [r4, #0]
   28da2:	2b01      	cmp	r3, #1
   28da4:	d006      	beq.n	28db4 <at_param_size+0x34>
		return sizeof(u16_t);
	} else if (param->type == AT_PARAM_TYPE_NUM_INT) {
   28da6:	2b02      	cmp	r3, #2
   28da8:	d006      	beq.n	28db8 <at_param_size+0x38>
		return sizeof(u32_t);
	} else if ((param->type == AT_PARAM_TYPE_STRING) ||
   28daa:	3b03      	subs	r3, #3
   28dac:	2b01      	cmp	r3, #1
   28dae:	d805      	bhi.n	28dbc <at_param_size+0x3c>
		   (param->type == AT_PARAM_TYPE_ARRAY)) {
		return param->size;
   28db0:	6860      	ldr	r0, [r4, #4]
	}

	return 0;
}
   28db2:	bd10      	pop	{r4, pc}
		return sizeof(u16_t);
   28db4:	2002      	movs	r0, #2
   28db6:	e7fc      	b.n	28db2 <at_param_size+0x32>
		return sizeof(u32_t);
   28db8:	2004      	movs	r0, #4
   28dba:	e7fa      	b.n	28db2 <at_param_size+0x32>
	return 0;
   28dbc:	2000      	movs	r0, #0
   28dbe:	e7f8      	b.n	28db2 <at_param_size+0x32>
   28dc0:	0003e37f 	.word	0x0003e37f
   28dc4:	0003e3b0 	.word	0x0003e3b0
   28dc8:	0003baac 	.word	0x0003baac
   28dcc:	0003e394 	.word	0x0003e394

00028dd0 <at_param_clear>:
{
   28dd0:	b510      	push	{r4, lr}
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   28dd2:	4604      	mov	r4, r0
   28dd4:	b960      	cbnz	r0, 28df0 <at_param_clear+0x20>
   28dd6:	490b      	ldr	r1, [pc, #44]	; (28e04 <at_param_clear+0x34>)
   28dd8:	231d      	movs	r3, #29
   28dda:	4a0b      	ldr	r2, [pc, #44]	; (28e08 <at_param_clear+0x38>)
   28ddc:	480b      	ldr	r0, [pc, #44]	; (28e0c <at_param_clear+0x3c>)
   28dde:	f00e ff6f 	bl	37cc0 <printk>
   28de2:	480b      	ldr	r0, [pc, #44]	; (28e10 <at_param_clear+0x40>)
   28de4:	f00e ff6c 	bl	37cc0 <printk>
   28de8:	211d      	movs	r1, #29
   28dea:	4807      	ldr	r0, [pc, #28]	; (28e08 <at_param_clear+0x38>)
   28dec:	f00e ffae 	bl	37d4c <assert_post_action>
	if ((param->type == AT_PARAM_TYPE_STRING) ||
   28df0:	7823      	ldrb	r3, [r4, #0]
   28df2:	3b03      	subs	r3, #3
   28df4:	2b01      	cmp	r3, #1
   28df6:	d802      	bhi.n	28dfe <at_param_clear+0x2e>
		k_free(param->value.str_val);
   28df8:	68a0      	ldr	r0, [r4, #8]
   28dfa:	f010 fdf5 	bl	399e8 <k_free>
	param->value.int_val = 0;
   28dfe:	2300      	movs	r3, #0
   28e00:	60a3      	str	r3, [r4, #8]
}
   28e02:	bd10      	pop	{r4, pc}
   28e04:	0003e37f 	.word	0x0003e37f
   28e08:	0003e3b0 	.word	0x0003e3b0
   28e0c:	0003baac 	.word	0x0003baac
   28e10:	0003e394 	.word	0x0003e394

00028e14 <at_params_list_clear>:
	list->param_count = max_params_count;
	return 0;
}

void at_params_list_clear(struct at_param_list *list)
{
   28e14:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (list == NULL || list->params == NULL) {
   28e18:	4605      	mov	r5, r0
   28e1a:	b158      	cbz	r0, 28e34 <at_params_list_clear+0x20>
   28e1c:	6843      	ldr	r3, [r0, #4]
   28e1e:	b14b      	cbz	r3, 28e34 <at_params_list_clear+0x20>
		return;
	}

	for (size_t i = 0; i < list->param_count; ++i) {
   28e20:	2400      	movs	r4, #0
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   28e22:	f8df 8054 	ldr.w	r8, [pc, #84]	; 28e78 <at_params_list_clear+0x64>
   28e26:	f8df a054 	ldr.w	sl, [pc, #84]	; 28e7c <at_params_list_clear+0x68>
   28e2a:	f8df b054 	ldr.w	fp, [pc, #84]	; 28e80 <at_params_list_clear+0x6c>
	for (size_t i = 0; i < list->param_count; ++i) {
   28e2e:	682b      	ldr	r3, [r5, #0]
   28e30:	429c      	cmp	r4, r3
   28e32:	d301      	bcc.n	28e38 <at_params_list_clear+0x24>
		struct at_param *params = list->params;

		at_param_clear(&params[i]);
		at_param_init(&params[i]);
	}
}
   28e34:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		at_param_clear(&params[i]);
   28e38:	270c      	movs	r7, #12
   28e3a:	4367      	muls	r7, r4
   28e3c:	f8d5 9004 	ldr.w	r9, [r5, #4]
   28e40:	eb09 0607 	add.w	r6, r9, r7
   28e44:	4630      	mov	r0, r6
   28e46:	f7ff ffc3 	bl	28dd0 <at_param_clear>
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   28e4a:	b966      	cbnz	r6, 28e66 <at_params_list_clear+0x52>
   28e4c:	4651      	mov	r1, sl
   28e4e:	2314      	movs	r3, #20
   28e50:	4642      	mov	r2, r8
   28e52:	4658      	mov	r0, fp
   28e54:	f00e ff34 	bl	37cc0 <printk>
   28e58:	4806      	ldr	r0, [pc, #24]	; (28e74 <at_params_list_clear+0x60>)
   28e5a:	f00e ff31 	bl	37cc0 <printk>
   28e5e:	2114      	movs	r1, #20
   28e60:	4640      	mov	r0, r8
   28e62:	f00e ff73 	bl	37d4c <assert_post_action>
   28e66:	2300      	movs	r3, #0
	for (size_t i = 0; i < list->param_count; ++i) {
   28e68:	3401      	adds	r4, #1
   28e6a:	f849 3007 	str.w	r3, [r9, r7]
   28e6e:	6073      	str	r3, [r6, #4]
   28e70:	60b3      	str	r3, [r6, #8]
   28e72:	e7dc      	b.n	28e2e <at_params_list_clear+0x1a>
   28e74:	0003e394 	.word	0x0003e394
   28e78:	0003e3b0 	.word	0x0003e3b0
   28e7c:	0003e37f 	.word	0x0003e37f
   28e80:	0003baac 	.word	0x0003baac

00028e84 <w_lte_lc_init>:
	}
}

static int w_lte_lc_init(void)
{
	if (at_cmd_write(nw_mode_preferred, NULL, 0, NULL) != 0) {
   28e84:	2300      	movs	r3, #0
{
   28e86:	b510      	push	{r4, lr}
	if (at_cmd_write(nw_mode_preferred, NULL, 0, NULL) != 0) {
   28e88:	461a      	mov	r2, r3
   28e8a:	4619      	mov	r1, r3
   28e8c:	4813      	ldr	r0, [pc, #76]	; (28edc <w_lte_lc_init+0x58>)
   28e8e:	f7ff fa2d 	bl	282ec <at_cmd_write>
   28e92:	4603      	mov	r3, r0
   28e94:	b118      	cbz	r0, 28e9e <w_lte_lc_init+0x1a>
		return -EIO;
   28e96:	f06f 0404 	mvn.w	r4, #4
	}
	LOG_INF("PDN Auth: %s", log_strdup(cgauth));
#endif

	return 0;
}
   28e9a:	4620      	mov	r0, r4
   28e9c:	bd10      	pop	{r4, pc}
	if (at_cmd_write(cereg_5_subscribe, NULL, 0, NULL) != 0) {
   28e9e:	4602      	mov	r2, r0
   28ea0:	4601      	mov	r1, r0
   28ea2:	480f      	ldr	r0, [pc, #60]	; (28ee0 <w_lte_lc_init+0x5c>)
   28ea4:	f7ff fa22 	bl	282ec <at_cmd_write>
   28ea8:	4603      	mov	r3, r0
   28eaa:	2800      	cmp	r0, #0
   28eac:	d1f3      	bne.n	28e96 <w_lte_lc_init+0x12>
	if (at_cmd_write(legacy_pco, NULL, 0, NULL) != 0) {
   28eae:	4602      	mov	r2, r0
   28eb0:	4601      	mov	r1, r0
   28eb2:	480c      	ldr	r0, [pc, #48]	; (28ee4 <w_lte_lc_init+0x60>)
   28eb4:	f7ff fa1a 	bl	282ec <at_cmd_write>
   28eb8:	4604      	mov	r4, r0
   28eba:	2800      	cmp	r0, #0
   28ebc:	d1eb      	bne.n	28e96 <w_lte_lc_init+0x12>
	LOG_INF("Using legacy LTE PCO mode...");
   28ebe:	2303      	movs	r3, #3
   28ec0:	f04f 0000 	mov.w	r0, #0
   28ec4:	4a08      	ldr	r2, [pc, #32]	; (28ee8 <w_lte_lc_init+0x64>)
   28ec6:	f363 0007 	bfi	r0, r3, #0, #8
   28eca:	4b08      	ldr	r3, [pc, #32]	; (28eec <w_lte_lc_init+0x68>)
   28ecc:	4908      	ldr	r1, [pc, #32]	; (28ef0 <w_lte_lc_init+0x6c>)
   28ece:	1a9b      	subs	r3, r3, r2
   28ed0:	08db      	lsrs	r3, r3, #3
   28ed2:	f363 108f 	bfi	r0, r3, #6, #10
   28ed6:	f00e ff4a 	bl	37d6e <log_string_sync>
	return 0;
   28eda:	e7de      	b.n	28e9a <w_lte_lc_init+0x16>
   28edc:	0003e494 	.word	0x0003e494
   28ee0:	0003e45d 	.word	0x0003e45d
   28ee4:	0003e468 	.word	0x0003e468
   28ee8:	0003ade0 	.word	0x0003ade0
   28eec:	0003ae70 	.word	0x0003ae70
   28ef0:	0003e615 	.word	0x0003e615

00028ef4 <parse_nw_reg_status>:
static int parse_nw_reg_status(const char *at_response,
			       enum lte_lc_nw_reg_status *status,
			       size_t reg_status_index)
{
	int err, reg_status;
	struct at_param_list resp_list = {0};
   28ef4:	2300      	movs	r3, #0
{
   28ef6:	b5f0      	push	{r4, r5, r6, r7, lr}
   28ef8:	b087      	sub	sp, #28
	char  response_prefix[sizeof(AT_CEREG_RESPONSE_PREFIX)] = {0};
   28efa:	9302      	str	r3, [sp, #8]
	struct at_param_list resp_list = {0};
   28efc:	e9cd 3304 	strd	r3, r3, [sp, #16]
	char  response_prefix[sizeof(AT_CEREG_RESPONSE_PREFIX)] = {0};
   28f00:	f8cd 300b 	str.w	r3, [sp, #11]
	size_t response_prefix_len = sizeof(response_prefix);
   28f04:	2307      	movs	r3, #7
{
   28f06:	460d      	mov	r5, r1
   28f08:	4617      	mov	r7, r2
	size_t response_prefix_len = sizeof(response_prefix);
   28f0a:	9301      	str	r3, [sp, #4]

	if ((at_response == NULL) || (status == NULL)) {
   28f0c:	4606      	mov	r6, r0
   28f0e:	2800      	cmp	r0, #0
   28f10:	f000 8082 	beq.w	29018 <parse_nw_reg_status+0x124>
   28f14:	2900      	cmp	r1, #0
   28f16:	d07f      	beq.n	29018 <parse_nw_reg_status+0x124>
		return -EINVAL;
	}

	err = at_params_list_init(&resp_list, AT_CEREG_PARAMS_COUNT_MAX);
   28f18:	210a      	movs	r1, #10
   28f1a:	a804      	add	r0, sp, #16
   28f1c:	f010 fbf9 	bl	39712 <at_params_list_init>
	if (err) {
   28f20:	4604      	mov	r4, r0
   28f22:	b188      	cbz	r0, 28f48 <parse_nw_reg_status+0x54>
		LOG_ERR("Could not init AT params list, error: %d", err);
   28f24:	2301      	movs	r3, #1
   28f26:	f04f 0000 	mov.w	r0, #0
   28f2a:	4a3d      	ldr	r2, [pc, #244]	; (29020 <parse_nw_reg_status+0x12c>)
   28f2c:	f363 0007 	bfi	r0, r3, #0, #8
   28f30:	4b3c      	ldr	r3, [pc, #240]	; (29024 <parse_nw_reg_status+0x130>)
   28f32:	493d      	ldr	r1, [pc, #244]	; (29028 <parse_nw_reg_status+0x134>)
   28f34:	1a9b      	subs	r3, r3, r2
   28f36:	08db      	lsrs	r3, r3, #3
   28f38:	f363 108f 	bfi	r0, r3, #6, #10
   28f3c:	4622      	mov	r2, r4
   28f3e:	f00e ff16 	bl	37d6e <log_string_sync>

clean_exit:
	at_params_list_free(&resp_list);

	return err;
}
   28f42:	4620      	mov	r0, r4
   28f44:	b007      	add	sp, #28
   28f46:	bdf0      	pop	{r4, r5, r6, r7, pc}
	err = at_parser_max_params_from_str(at_response,
   28f48:	4601      	mov	r1, r0
   28f4a:	230a      	movs	r3, #10
   28f4c:	aa04      	add	r2, sp, #16
   28f4e:	4630      	mov	r0, r6
   28f50:	f7ff fe64 	bl	28c1c <at_parser_max_params_from_str>
	if (err) {
   28f54:	4604      	mov	r4, r0
   28f56:	b190      	cbz	r0, 28f7e <parse_nw_reg_status+0x8a>
		LOG_ERR("Could not parse AT+CEREG response, error: %d", err);
   28f58:	2301      	movs	r3, #1
   28f5a:	f04f 0000 	mov.w	r0, #0
   28f5e:	4a30      	ldr	r2, [pc, #192]	; (29020 <parse_nw_reg_status+0x12c>)
   28f60:	f363 0007 	bfi	r0, r3, #0, #8
   28f64:	4b2f      	ldr	r3, [pc, #188]	; (29024 <parse_nw_reg_status+0x130>)
   28f66:	4931      	ldr	r1, [pc, #196]	; (2902c <parse_nw_reg_status+0x138>)
   28f68:	1a9b      	subs	r3, r3, r2
   28f6a:	4622      	mov	r2, r4
   28f6c:	08db      	lsrs	r3, r3, #3
   28f6e:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Could not get response prefix, error: %d", err);
   28f72:	f00e fefc 	bl	37d6e <log_string_sync>
	at_params_list_free(&resp_list);
   28f76:	a804      	add	r0, sp, #16
   28f78:	f010 fbde 	bl	39738 <at_params_list_free>
	return err;
   28f7c:	e7e1      	b.n	28f42 <parse_nw_reg_status+0x4e>
	err = at_params_string_get(&resp_list,
   28f7e:	4601      	mov	r1, r0
   28f80:	ab01      	add	r3, sp, #4
   28f82:	aa02      	add	r2, sp, #8
   28f84:	a804      	add	r0, sp, #16
   28f86:	f010 fc86 	bl	39896 <at_params_string_get>
	if (err) {
   28f8a:	4604      	mov	r4, r0
   28f8c:	b168      	cbz	r0, 28faa <parse_nw_reg_status+0xb6>
		LOG_ERR("Could not get response prefix, error: %d", err);
   28f8e:	2301      	movs	r3, #1
   28f90:	f04f 0000 	mov.w	r0, #0
   28f94:	4a22      	ldr	r2, [pc, #136]	; (29020 <parse_nw_reg_status+0x12c>)
   28f96:	f363 0007 	bfi	r0, r3, #0, #8
   28f9a:	4b22      	ldr	r3, [pc, #136]	; (29024 <parse_nw_reg_status+0x130>)
   28f9c:	4924      	ldr	r1, [pc, #144]	; (29030 <parse_nw_reg_status+0x13c>)
   28f9e:	1a9b      	subs	r3, r3, r2
   28fa0:	08db      	lsrs	r3, r3, #3
   28fa2:	f363 108f 	bfi	r0, r3, #6, #10
   28fa6:	4622      	mov	r2, r4
   28fa8:	e7e3      	b.n	28f72 <parse_nw_reg_status+0x7e>
	if (!response_is_valid(response_prefix, response_prefix_len,
   28faa:	4a22      	ldr	r2, [pc, #136]	; (29034 <parse_nw_reg_status+0x140>)
   28fac:	9901      	ldr	r1, [sp, #4]
   28fae:	a802      	add	r0, sp, #8
   28fb0:	f010 fc98 	bl	398e4 <response_is_valid>
   28fb4:	2800      	cmp	r0, #0
   28fb6:	d0de      	beq.n	28f76 <parse_nw_reg_status+0x82>
	err = at_params_int_get(&resp_list, reg_status_index,
   28fb8:	466a      	mov	r2, sp
   28fba:	4639      	mov	r1, r7
   28fbc:	a804      	add	r0, sp, #16
   28fbe:	f010 fc53 	bl	39868 <at_params_int_get>
	if (err) {
   28fc2:	4604      	mov	r4, r0
   28fc4:	b168      	cbz	r0, 28fe2 <parse_nw_reg_status+0xee>
		LOG_ERR("Could not get registration status, error: %d", err);
   28fc6:	2301      	movs	r3, #1
   28fc8:	f04f 0000 	mov.w	r0, #0
   28fcc:	4a14      	ldr	r2, [pc, #80]	; (29020 <parse_nw_reg_status+0x12c>)
   28fce:	f363 0007 	bfi	r0, r3, #0, #8
   28fd2:	4b14      	ldr	r3, [pc, #80]	; (29024 <parse_nw_reg_status+0x130>)
   28fd4:	4918      	ldr	r1, [pc, #96]	; (29038 <parse_nw_reg_status+0x144>)
   28fd6:	1a9b      	subs	r3, r3, r2
   28fd8:	08db      	lsrs	r3, r3, #3
   28fda:	f363 108f 	bfi	r0, r3, #6, #10
   28fde:	4622      	mov	r2, r4
   28fe0:	e7c7      	b.n	28f72 <parse_nw_reg_status+0x7e>
	switch (reg_status) {
   28fe2:	9a00      	ldr	r2, [sp, #0]
   28fe4:	2a08      	cmp	r2, #8
   28fe6:	d015      	beq.n	29014 <parse_nw_reg_status+0x120>
   28fe8:	dc12      	bgt.n	29010 <parse_nw_reg_status+0x11c>
   28fea:	2a05      	cmp	r2, #5
   28fec:	d912      	bls.n	29014 <parse_nw_reg_status+0x120>
		LOG_ERR("Invalid network registration status: %d", reg_status);
   28fee:	2301      	movs	r3, #1
   28ff0:	f04f 0000 	mov.w	r0, #0
   28ff4:	490a      	ldr	r1, [pc, #40]	; (29020 <parse_nw_reg_status+0x12c>)
   28ff6:	f363 0007 	bfi	r0, r3, #0, #8
   28ffa:	4b0a      	ldr	r3, [pc, #40]	; (29024 <parse_nw_reg_status+0x130>)
		err = -EIO;
   28ffc:	f06f 0404 	mvn.w	r4, #4
   29000:	1a5b      	subs	r3, r3, r1
   29002:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Invalid network registration status: %d", reg_status);
   29004:	f363 108f 	bfi	r0, r3, #6, #10
   29008:	490c      	ldr	r1, [pc, #48]	; (2903c <parse_nw_reg_status+0x148>)
   2900a:	f00e feb0 	bl	37d6e <log_string_sync>
		err = -EIO;
   2900e:	e7b2      	b.n	28f76 <parse_nw_reg_status+0x82>
	switch (reg_status) {
   29010:	2a5a      	cmp	r2, #90	; 0x5a
   29012:	d1ec      	bne.n	28fee <parse_nw_reg_status+0xfa>
		*status = reg_status;
   29014:	702a      	strb	r2, [r5, #0]
		LOG_DBG("Network registration status: %d", reg_status);
   29016:	e7ae      	b.n	28f76 <parse_nw_reg_status+0x82>
		return -EINVAL;
   29018:	f06f 0415 	mvn.w	r4, #21
   2901c:	e791      	b.n	28f42 <parse_nw_reg_status+0x4e>
   2901e:	bf00      	nop
   29020:	0003ade0 	.word	0x0003ade0
   29024:	0003ae70 	.word	0x0003ae70
   29028:	0003e4b5 	.word	0x0003e4b5
   2902c:	0003e4de 	.word	0x0003e4de
   29030:	0003e50b 	.word	0x0003e50b
   29034:	0003e534 	.word	0x0003e534
   29038:	0003e53b 	.word	0x0003e53b
   2903c:	0003e568 	.word	0x0003e568

00029040 <at_handler>:
{
   29040:	b507      	push	{r0, r1, r2, lr}
	if (response == NULL) {
   29042:	4608      	mov	r0, r1
   29044:	b971      	cbnz	r1, 29064 <at_handler+0x24>
		LOG_ERR("Response buffer is NULL-pointer");
   29046:	2301      	movs	r3, #1
   29048:	4a15      	ldr	r2, [pc, #84]	; (290a0 <at_handler+0x60>)
   2904a:	f363 0007 	bfi	r0, r3, #0, #8
   2904e:	4b15      	ldr	r3, [pc, #84]	; (290a4 <at_handler+0x64>)
   29050:	4915      	ldr	r1, [pc, #84]	; (290a8 <at_handler+0x68>)
   29052:	1a9b      	subs	r3, r3, r2
   29054:	08db      	lsrs	r3, r3, #3
   29056:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Could not get network registration status");
   2905a:	f00e fe88 	bl	37d6e <log_string_sync>
}
   2905e:	b003      	add	sp, #12
   29060:	f85d fb04 	ldr.w	pc, [sp], #4
	err = parse_nw_reg_status(response, &status, AT_CEREG_REG_STATUS_INDEX);
   29064:	2201      	movs	r2, #1
   29066:	f10d 0107 	add.w	r1, sp, #7
   2906a:	f7ff ff43 	bl	28ef4 <parse_nw_reg_status>
	if (err) {
   2906e:	b160      	cbz	r0, 2908a <at_handler+0x4a>
		LOG_ERR("Could not get network registration status");
   29070:	2301      	movs	r3, #1
   29072:	f04f 0000 	mov.w	r0, #0
   29076:	4a0a      	ldr	r2, [pc, #40]	; (290a0 <at_handler+0x60>)
   29078:	f363 0007 	bfi	r0, r3, #0, #8
   2907c:	4b09      	ldr	r3, [pc, #36]	; (290a4 <at_handler+0x64>)
   2907e:	490b      	ldr	r1, [pc, #44]	; (290ac <at_handler+0x6c>)
   29080:	1a9b      	subs	r3, r3, r2
   29082:	08db      	lsrs	r3, r3, #3
   29084:	f363 108f 	bfi	r0, r3, #6, #10
   29088:	e7e7      	b.n	2905a <at_handler+0x1a>
	if ((status == LTE_LC_NW_REG_REGISTERED_HOME) ||
   2908a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   2908e:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
   29092:	2b01      	cmp	r3, #1
   29094:	d1e3      	bne.n	2905e <at_handler+0x1e>
	z_impl_k_sem_give(sem);
   29096:	4806      	ldr	r0, [pc, #24]	; (290b0 <at_handler+0x70>)
   29098:	f00b fad8 	bl	3464c <z_impl_k_sem_give>
   2909c:	e7df      	b.n	2905e <at_handler+0x1e>
   2909e:	bf00      	nop
   290a0:	0003ade0 	.word	0x0003ade0
   290a4:	0003ae70 	.word	0x0003ae70
   290a8:	0003e413 	.word	0x0003e413
   290ac:	0003e433 	.word	0x0003e433
   290b0:	200207f0 	.word	0x200207f0

000290b4 <w_lte_lc_connect>:
{
   290b4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
   290b8:	2201      	movs	r2, #1
   290ba:	2100      	movs	r1, #0
   290bc:	4838      	ldr	r0, [pc, #224]	; (291a0 <w_lte_lc_connect+0xec>)
   290be:	f010 fd12 	bl	39ae6 <z_impl_k_sem_init>
	rc = at_notif_register_handler(NULL, at_handler);
   290c2:	4938      	ldr	r1, [pc, #224]	; (291a4 <w_lte_lc_connect+0xf0>)
   290c4:	2000      	movs	r0, #0
   290c6:	f7ff f9c3 	bl	28450 <at_notif_register_handler>
	if (rc != 0) {
   290ca:	4c37      	ldr	r4, [pc, #220]	; (291a8 <w_lte_lc_connect+0xf4>)
   290cc:	4b37      	ldr	r3, [pc, #220]	; (291ac <w_lte_lc_connect+0xf8>)
   290ce:	4681      	mov	r9, r0
   290d0:	1ae4      	subs	r4, r4, r3
   290d2:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   290d6:	b168      	cbz	r0, 290f4 <w_lte_lc_connect+0x40>
		LOG_ERR("Can't register handler rc=%d", rc);
   290d8:	2201      	movs	r2, #1
   290da:	f04f 0000 	mov.w	r0, #0
   290de:	f362 0007 	bfi	r0, r2, #0, #8
   290e2:	464a      	mov	r2, r9
   290e4:	4932      	ldr	r1, [pc, #200]	; (291b0 <w_lte_lc_connect+0xfc>)
   290e6:	f364 108f 	bfi	r0, r4, #6, #10
		LOG_ERR("Can't de-register handler rc=%d", rc);
   290ea:	f00e fe40 	bl	37d6e <log_string_sync>
}
   290ee:	4648      	mov	r0, r9
   290f0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   290f4:	2702      	movs	r7, #2
	const char *current_network_mode = nw_mode_preferred;
   290f6:	482f      	ldr	r0, [pc, #188]	; (291b4 <w_lte_lc_connect+0x100>)
	return z_impl_k_sem_take(sem, timeout);
   290f8:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 291d0 <w_lte_lc_connect+0x11c>
   290fc:	f8df b0a0 	ldr.w	fp, [pc, #160]	; 291a0 <w_lte_lc_connect+0xec>
		if (at_cmd_write(current_network_mode, NULL, 0, NULL) != 0) {
   29100:	2300      	movs	r3, #0
   29102:	461a      	mov	r2, r3
   29104:	4619      	mov	r1, r3
   29106:	f7ff f8f1 	bl	282ec <at_cmd_write>
   2910a:	4603      	mov	r3, r0
   2910c:	bb90      	cbnz	r0, 29174 <w_lte_lc_connect+0xc0>
		if (at_cmd_write(normal, NULL, 0, NULL) != 0) {
   2910e:	4602      	mov	r2, r0
   29110:	4601      	mov	r1, r0
   29112:	4829      	ldr	r0, [pc, #164]	; (291b8 <w_lte_lc_connect+0x104>)
   29114:	f7ff f8ea 	bl	282ec <at_cmd_write>
   29118:	4680      	mov	r8, r0
   2911a:	bb58      	cbnz	r0, 29174 <w_lte_lc_connect+0xc0>
   2911c:	4651      	mov	r1, sl
   2911e:	4658      	mov	r0, fp
   29120:	f00b fade 	bl	346e0 <z_impl_k_sem_take>
		if (err == -EAGAIN) {
   29124:	f110 0f0b 	cmn.w	r0, #11
   29128:	4681      	mov	r9, r0
   2912a:	d125      	bne.n	29178 <w_lte_lc_connect+0xc4>
			LOG_INF("Network connection attempt timed out");
   2912c:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   29130:	f043 0303 	orr.w	r3, r3, #3
   29134:	f363 0607 	bfi	r6, r3, #0, #8
   29138:	f364 168f 	bfi	r6, r4, #6, #10
   2913c:	491f      	ldr	r1, [pc, #124]	; (291bc <w_lte_lc_connect+0x108>)
   2913e:	4630      	mov	r0, r6
   29140:	f00e fe15 	bl	37d6e <log_string_sync>
			if (IS_ENABLED(CONFIG_LTE_NETWORK_USE_FALLBACK) &&
   29144:	2f01      	cmp	r7, #1
   29146:	d027      	beq.n	29198 <w_lte_lc_connect+0xe4>
				if (at_cmd_write(offline, NULL, 0, NULL) != 0) {
   29148:	4643      	mov	r3, r8
   2914a:	4642      	mov	r2, r8
   2914c:	4641      	mov	r1, r8
   2914e:	481c      	ldr	r0, [pc, #112]	; (291c0 <w_lte_lc_connect+0x10c>)
   29150:	f7ff f8cc 	bl	282ec <at_cmd_write>
   29154:	b970      	cbnz	r0, 29174 <w_lte_lc_connect+0xc0>
				LOG_INF("Using fallback network mode");
   29156:	f025 033f 	bic.w	r3, r5, #63	; 0x3f
   2915a:	f043 0303 	orr.w	r3, r3, #3
   2915e:	f363 0507 	bfi	r5, r3, #0, #8
   29162:	f364 158f 	bfi	r5, r4, #6, #10
   29166:	4628      	mov	r0, r5
   29168:	4916      	ldr	r1, [pc, #88]	; (291c4 <w_lte_lc_connect+0x110>)
   2916a:	f00e fe00 	bl	37d6e <log_string_sync>
   2916e:	2701      	movs	r7, #1
				current_network_mode = nw_mode_fallback;
   29170:	4815      	ldr	r0, [pc, #84]	; (291c8 <w_lte_lc_connect+0x114>)
   29172:	e7c5      	b.n	29100 <w_lte_lc_connect+0x4c>
			err = -EIO;
   29174:	f06f 0904 	mvn.w	r9, #4
	rc = at_notif_deregister_handler(NULL, at_handler);
   29178:	490a      	ldr	r1, [pc, #40]	; (291a4 <w_lte_lc_connect+0xf0>)
   2917a:	2000      	movs	r0, #0
   2917c:	f7ff f9b4 	bl	284e8 <at_notif_deregister_handler>
	if (rc != 0) {
   29180:	4602      	mov	r2, r0
   29182:	2800      	cmp	r0, #0
   29184:	d0b3      	beq.n	290ee <w_lte_lc_connect+0x3a>
		LOG_ERR("Can't de-register handler rc=%d", rc);
   29186:	2101      	movs	r1, #1
   29188:	f04f 0000 	mov.w	r0, #0
   2918c:	f361 0007 	bfi	r0, r1, #0, #8
   29190:	f364 108f 	bfi	r0, r4, #6, #10
   29194:	490d      	ldr	r1, [pc, #52]	; (291cc <w_lte_lc_connect+0x118>)
   29196:	e7a8      	b.n	290ea <w_lte_lc_connect+0x36>
				err = -ETIMEDOUT;
   29198:	f06f 0973 	mvn.w	r9, #115	; 0x73
   2919c:	e7ec      	b.n	29178 <w_lte_lc_connect+0xc4>
   2919e:	bf00      	nop
   291a0:	200207f0 	.word	0x200207f0
   291a4:	00029041 	.word	0x00029041
   291a8:	0003ae70 	.word	0x0003ae70
   291ac:	0003ade0 	.word	0x0003ade0
   291b0:	0003e597 	.word	0x0003e597
   291b4:	0003e494 	.word	0x0003e494
   291b8:	0003e473 	.word	0x0003e473
   291bc:	0003e5b4 	.word	0x0003e5b4
   291c0:	0003e4ab 	.word	0x0003e4ab
   291c4:	0003e5d9 	.word	0x0003e5d9
   291c8:	0003e47d 	.word	0x0003e47d
   291cc:	0003e5f5 	.word	0x0003e5f5
   291d0:	000927c0 	.word	0x000927c0

000291d4 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
   291d4:	b508      	push	{r3, lr}
		arch_syscall_invoke0(K_SYSCALL_LOG_PANIC);
		return;
	}
#endif
	compiler_barrier();
	z_impl_log_panic();
   291d6:	f7fa fbd1 	bl	2397c <z_impl_log_panic>
	ARG_UNUSED(esf);
	ARG_UNUSED(reason);

	LOG_PANIC();

	LOG_ERR("Resetting system");
   291da:	2301      	movs	r3, #1
   291dc:	f04f 0000 	mov.w	r0, #0
   291e0:	4a06      	ldr	r2, [pc, #24]	; (291fc <k_sys_fatal_error_handler+0x28>)
   291e2:	f363 0007 	bfi	r0, r3, #0, #8
   291e6:	4b06      	ldr	r3, [pc, #24]	; (29200 <k_sys_fatal_error_handler+0x2c>)
   291e8:	4906      	ldr	r1, [pc, #24]	; (29204 <k_sys_fatal_error_handler+0x30>)
   291ea:	1a9b      	subs	r3, r3, r2
   291ec:	08db      	lsrs	r3, r3, #3
   291ee:	f363 108f 	bfi	r0, r3, #6, #10
   291f2:	f00e fdbc 	bl	37d6e <log_string_sync>
	sys_arch_reboot(0);
   291f6:	2000      	movs	r0, #0
   291f8:	f7fc fb6c 	bl	258d4 <sys_arch_reboot>

	CODE_UNREACHABLE;
   291fc:	0003ade0 	.word	0x0003ade0
   29200:	0003ae30 	.word	0x0003ae30
   29204:	0003e7ae 	.word	0x0003e7ae

00029208 <check_ext_api_requests>:
	}
};
#endif

static int check_ext_api_requests(struct device *dev)
{
   29208:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	(void)dev;

	const struct fw_info_ext_api_request *ext_api_req =
			skip_ext_apis(&m_firmware_info);

	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   2920c:	2500      	movs	r5, #0
			skip_ext_apis(&m_firmware_info);
   2920e:	4c21      	ldr	r4, [pc, #132]	; (29294 <check_ext_api_requests+0x8c>)
 */
static inline const struct fw_info_ext_api *fw_info_ext_api_check(
							u32_t ext_api_addr)
{
	const struct fw_info_ext_api *ext_api;
	const u32_t ext_api_magic[] = {EXT_API_MAGIC};
   29210:	4e21      	ldr	r6, [pc, #132]	; (29298 <check_ext_api_requests+0x90>)
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   29212:	f854 8c04 	ldr.w	r8, [r4, #-4]
			/* EXT_API hard requirement not met. */
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
			k_panic();
		} else {
			/* EXT_API soft requirement not met. */
			printk("WARNING: Optional EXT_API request not "
   29216:	f8df 9088 	ldr.w	r9, [pc, #136]	; 292a0 <check_ext_api_requests+0x98>
{
   2921a:	b085      	sub	sp, #20
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   2921c:	45a8      	cmp	r8, r5
   2921e:	d803      	bhi.n	29228 <check_ext_api_requests+0x20>
		}
		ADVANCE_EXT_API_REQ(ext_api_req);
	}

	return 0;
}
   29220:	2000      	movs	r0, #0
   29222:	b005      	add	sp, #20
   29224:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (fw_info_ext_api_check((u32_t)*(ext_api_req->ext_api))
   29228:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2922a:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
   2922e:	681f      	ldr	r7, [r3, #0]
   29230:	ab01      	add	r3, sp, #4
   29232:	e883 0007 	stmia.w	r3, {r0, r1, r2}

	ext_api = (const struct fw_info_ext_api *)(ext_api_addr);
	if (memcmp(ext_api->magic, ext_api_magic, CONFIG_FW_INFO_MAGIC_LEN)
   29236:	220c      	movs	r2, #12
   29238:	4619      	mov	r1, r3
   2923a:	4638      	mov	r0, r7
   2923c:	f010 fd91 	bl	39d62 <memcmp>
   29240:	b990      	cbnz	r0, 29268 <check_ext_api_requests+0x60>
   29242:	b18f      	cbz	r7, 29268 <check_ext_api_requests+0x60>
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
   29244:	6a63      	ldr	r3, [r4, #36]	; 0x24
	const u32_t req_id = ext_api_req->request.ext_api_id;
   29246:	6921      	ldr	r1, [r4, #16]
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
   29248:	681b      	ldr	r3, [r3, #0]
	return ((ext_api->ext_api_id == req_id)
   2924a:	691a      	ldr	r2, [r3, #16]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
   2924c:	4291      	cmp	r1, r2
   2924e:	d10b      	bne.n	29268 <check_ext_api_requests+0x60>
		&&  (ext_api->ext_api_version >= req_min_version)
   29250:	699a      	ldr	r2, [r3, #24]
	const u32_t req_min_version = ext_api_req->request.ext_api_version;
   29252:	69a1      	ldr	r1, [r4, #24]
		&&  (ext_api->ext_api_version >= req_min_version)
   29254:	4291      	cmp	r1, r2
   29256:	d807      	bhi.n	29268 <check_ext_api_requests+0x60>
	const u32_t req_max_version = ext_api_req->ext_api_max_version;
   29258:	69e1      	ldr	r1, [r4, #28]
		&&  (ext_api->ext_api_version <  req_max_version)
   2925a:	4291      	cmp	r1, r2
   2925c:	d904      	bls.n	29268 <check_ext_api_requests+0x60>
	const u32_t req_flags = ext_api_req->request.ext_api_flags;
   2925e:	6962      	ldr	r2, [r4, #20]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
   29260:	695b      	ldr	r3, [r3, #20]
   29262:	ea32 0303 	bics.w	r3, r2, r3
   29266:	d00a      	beq.n	2927e <check_ext_api_requests+0x76>
		} else if (ext_api_req->required) {
   29268:	6a27      	ldr	r7, [r4, #32]
   2926a:	b167      	cbz	r7, 29286 <check_ext_api_requests+0x7e>
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
   2926c:	480b      	ldr	r0, [pc, #44]	; (2929c <check_ext_api_requests+0x94>)
   2926e:	f00e fd27 	bl	37cc0 <printk>
			k_panic();
   29272:	4040      	eors	r0, r0
   29274:	f380 8811 	msr	BASEPRI, r0
   29278:	f04f 0004 	mov.w	r0, #4
   2927c:	df02      	svc	2
		ADVANCE_EXT_API_REQ(ext_api_req);
   2927e:	68e3      	ldr	r3, [r4, #12]
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   29280:	3501      	adds	r5, #1
		ADVANCE_EXT_API_REQ(ext_api_req);
   29282:	441c      	add	r4, r3
   29284:	e7ca      	b.n	2921c <check_ext_api_requests+0x14>
			printk("WARNING: Optional EXT_API request not "
   29286:	4648      	mov	r0, r9
   29288:	f00e fd1a 	bl	37cc0 <printk>
			*ext_api_req->ext_api = NULL;
   2928c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2928e:	601f      	str	r7, [r3, #0]
   29290:	e7f5      	b.n	2927e <check_ext_api_requests+0x76>
   29292:	bf00      	nop
   29294:	0001c43c 	.word	0x0001c43c
   29298:	0003af58 	.word	0x0003af58
   2929c:	0003e7cb 	.word	0x0003e7cb
   292a0:	0003e7f4 	.word	0x0003e7f4

000292a4 <rpc_logobj_client_evt_handler>:
   292a4:	b120      	cbz	r0, 292b0 <rpc_logobj_client_evt_handler+0xc>
   292a6:	f850 1b08 	ldr.w	r1, [r0], #8
   292aa:	0c09      	lsrs	r1, r1, #16
   292ac:	f000 b852 	b.w	29354 <logobj_event_handler>
   292b0:	4770      	bx	lr
   292b2:	bf00      	nop

000292b4 <rpc_logobj_client_init>:
   292b4:	4801      	ldr	r0, [pc, #4]	; (292bc <rpc_logobj_client_init+0x8>)
   292b6:	f006 bbcf 	b.w	2fa58 <rpc_client_register>
   292ba:	bf00      	nop
   292bc:	0003b514 	.word	0x0003b514

000292c0 <rpc_logobj_client_request_alloc>:
   292c0:	2300      	movs	r3, #0
   292c2:	b510      	push	{r4, lr}
   292c4:	b082      	sub	sp, #8
   292c6:	9301      	str	r3, [sp, #4]
   292c8:	b961      	cbnz	r1, 292e4 <rpc_logobj_client_request_alloc+0x24>
   292ca:	b170      	cbz	r0, 292ea <rpc_logobj_client_request_alloc+0x2a>
   292cc:	4604      	mov	r4, r0
   292ce:	aa01      	add	r2, sp, #4
   292d0:	2009      	movs	r0, #9
   292d2:	f006 fdf9 	bl	2fec8 <rpc_message_alloc>
   292d6:	b918      	cbnz	r0, 292e0 <rpc_logobj_client_request_alloc+0x20>
   292d8:	9b01      	ldr	r3, [sp, #4]
   292da:	b10b      	cbz	r3, 292e0 <rpc_logobj_client_request_alloc+0x20>
   292dc:	3308      	adds	r3, #8
   292de:	6023      	str	r3, [r4, #0]
   292e0:	b002      	add	sp, #8
   292e2:	bd10      	pop	{r4, pc}
   292e4:	200f      	movs	r0, #15
   292e6:	b002      	add	sp, #8
   292e8:	bd10      	pop	{r4, pc}
   292ea:	200e      	movs	r0, #14
   292ec:	b002      	add	sp, #8
   292ee:	bd10      	pop	{r4, pc}

000292f0 <rpc_logobj_client_request_send>:
   292f0:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   292f4:	f5b3 4fe0 	cmp.w	r3, #28672	; 0x7000
   292f8:	d10b      	bne.n	29312 <rpc_logobj_client_request_send+0x22>
   292fa:	b160      	cbz	r0, 29316 <rpc_logobj_client_request_send+0x26>
   292fc:	4603      	mov	r3, r0
   292fe:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   29302:	2009      	movs	r0, #9
   29304:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   29308:	f843 1d08 	str.w	r1, [r3, #-8]!
   2930c:	4619      	mov	r1, r3
   2930e:	f006 bdc3 	b.w	2fe98 <rpc_message_send>
   29312:	200f      	movs	r0, #15
   29314:	4770      	bx	lr
   29316:	200e      	movs	r0, #14
   29318:	4770      	bx	lr
   2931a:	bf00      	nop

0002931c <rpc_logobj_client_message_free>:
   2931c:	b120      	cbz	r0, 29328 <rpc_logobj_client_message_free+0xc>
   2931e:	f1a0 0108 	sub.w	r1, r0, #8
   29322:	2009      	movs	r0, #9
   29324:	f006 be02 	b.w	2ff2c <rpc_message_free>
   29328:	200e      	movs	r0, #14
   2932a:	4770      	bx	lr

0002932c <rpc_logobj_client_data_free>:
   2932c:	b118      	cbz	r0, 29336 <rpc_logobj_client_data_free+0xa>
   2932e:	4601      	mov	r1, r0
   29330:	2009      	movs	r0, #9
   29332:	f006 bf0d 	b.w	30150 <rpc_message_data_free>
   29336:	200e      	movs	r0, #14
   29338:	4770      	bx	lr
   2933a:	bf00      	nop

0002933c <packet_free_cb>:
   2933c:	b510      	push	{r4, lr}
   2933e:	4604      	mov	r4, r0
   29340:	6800      	ldr	r0, [r0, #0]
   29342:	f7ff fff3 	bl	2932c <rpc_logobj_client_data_free>
   29346:	68a0      	ldr	r0, [r4, #8]
   29348:	b118      	cbz	r0, 29352 <packet_free_cb+0x16>
   2934a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2934e:	f001 b935 	b.w	2a5bc <nrf_free>
   29352:	bd10      	pop	{r4, pc}

00029354 <logobj_event_handler>:
   29354:	b530      	push	{r4, r5, lr}
   29356:	4b3b      	ldr	r3, [pc, #236]	; (29444 <logobj_event_handler+0xf0>)
   29358:	b085      	sub	sp, #20
   2935a:	681d      	ldr	r5, [r3, #0]
   2935c:	2d00      	cmp	r5, #0
   2935e:	d04c      	beq.n	293fa <logobj_event_handler+0xa6>
   29360:	f248 0302 	movw	r3, #32770	; 0x8002
   29364:	4299      	cmp	r1, r3
   29366:	d053      	beq.n	29410 <logobj_event_handler+0xbc>
   29368:	d91c      	bls.n	293a4 <logobj_event_handler+0x50>
   2936a:	f248 0303 	movw	r3, #32771	; 0x8003
   2936e:	4299      	cmp	r1, r3
   29370:	d05a      	beq.n	29428 <logobj_event_handler+0xd4>
   29372:	f249 0301 	movw	r3, #36865	; 0x9001
   29376:	4299      	cmp	r1, r3
   29378:	d147      	bne.n	2940a <logobj_event_handler+0xb6>
   2937a:	2400      	movs	r4, #0
   2937c:	6843      	ldr	r3, [r0, #4]
   2937e:	6802      	ldr	r2, [r0, #0]
   29380:	e9cd 4402 	strd	r4, r4, [sp, #8]
   29384:	e9cd 2300 	strd	r2, r3, [sp]
   29388:	69e8      	ldr	r0, [r5, #28]
   2938a:	4669      	mov	r1, sp
   2938c:	6803      	ldr	r3, [r0, #0]
   2938e:	685b      	ldr	r3, [r3, #4]
   29390:	4798      	blx	r3
   29392:	3001      	adds	r0, #1
   29394:	d04e      	beq.n	29434 <logobj_event_handler+0xe0>
   29396:	4620      	mov	r0, r4
   29398:	682b      	ldr	r3, [r5, #0]
   2939a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   2939e:	602b      	str	r3, [r5, #0]
   293a0:	b005      	add	sp, #20
   293a2:	bd30      	pop	{r4, r5, pc}
   293a4:	f248 0301 	movw	r3, #32769	; 0x8001
   293a8:	4299      	cmp	r1, r3
   293aa:	d12e      	bne.n	2940a <logobj_event_handler+0xb6>
   293ac:	68c3      	ldr	r3, [r0, #12]
   293ae:	2b00      	cmp	r3, #0
   293b0:	d135      	bne.n	2941e <logobj_event_handler+0xca>
   293b2:	6828      	ldr	r0, [r5, #0]
   293b4:	f410 0080 	ands.w	r0, r0, #4194304	; 0x400000
   293b8:	d03e      	beq.n	29438 <logobj_event_handler+0xe4>
   293ba:	682b      	ldr	r3, [r5, #0]
   293bc:	b29b      	uxth	r3, r3
   293be:	2b01      	cmp	r3, #1
   293c0:	d105      	bne.n	293ce <logobj_event_handler+0x7a>
   293c2:	682b      	ldr	r3, [r5, #0]
   293c4:	0c1b      	lsrs	r3, r3, #16
   293c6:	041b      	lsls	r3, r3, #16
   293c8:	f043 0302 	orr.w	r3, r3, #2
   293cc:	602b      	str	r3, [r5, #0]
   293ce:	4b1e      	ldr	r3, [pc, #120]	; (29448 <logobj_event_handler+0xf4>)
   293d0:	781a      	ldrb	r2, [r3, #0]
   293d2:	f002 01ff 	and.w	r1, r2, #255	; 0xff
   293d6:	2a00      	cmp	r2, #0
   293d8:	d031      	beq.n	2943e <logobj_event_handler+0xea>
   293da:	4a1c      	ldr	r2, [pc, #112]	; (2944c <logobj_event_handler+0xf8>)
   293dc:	7811      	ldrb	r1, [r2, #0]
   293de:	b909      	cbnz	r1, 293e4 <logobj_event_handler+0x90>
   293e0:	2101      	movs	r1, #1
   293e2:	7011      	strb	r1, [r2, #0]
   293e4:	2000      	movs	r0, #0
   293e6:	7018      	strb	r0, [r3, #0]
   293e8:	682b      	ldr	r3, [r5, #0]
   293ea:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   293ee:	602b      	str	r3, [r5, #0]
   293f0:	682b      	ldr	r3, [r5, #0]
   293f2:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   293f6:	602b      	str	r3, [r5, #0]
   293f8:	e7d2      	b.n	293a0 <logobj_event_handler+0x4c>
   293fa:	6800      	ldr	r0, [r0, #0]
   293fc:	2800      	cmp	r0, #0
   293fe:	d0cf      	beq.n	293a0 <logobj_event_handler+0x4c>
   29400:	f7ff ff94 	bl	2932c <rpc_logobj_client_data_free>
   29404:	4628      	mov	r0, r5
   29406:	b005      	add	sp, #20
   29408:	bd30      	pop	{r4, r5, pc}
   2940a:	2000      	movs	r0, #0
   2940c:	b005      	add	sp, #20
   2940e:	bd30      	pop	{r4, r5, pc}
   29410:	682b      	ldr	r3, [r5, #0]
   29412:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
   29416:	d00b      	beq.n	29430 <logobj_event_handler+0xdc>
   29418:	68c0      	ldr	r0, [r0, #12]
   2941a:	2800      	cmp	r0, #0
   2941c:	d0e4      	beq.n	293e8 <logobj_event_handler+0x94>
   2941e:	230e      	movs	r3, #14
   29420:	2000      	movs	r0, #0
   29422:	606b      	str	r3, [r5, #4]
   29424:	b005      	add	sp, #20
   29426:	bd30      	pop	{r4, r5, pc}
   29428:	68c3      	ldr	r3, [r0, #12]
   2942a:	2b01      	cmp	r3, #1
   2942c:	d1a5      	bne.n	2937a <logobj_event_handler+0x26>
   2942e:	e7f6      	b.n	2941e <logobj_event_handler+0xca>
   29430:	4618      	mov	r0, r3
   29432:	e7b5      	b.n	293a0 <logobj_event_handler+0x4c>
   29434:	2002      	movs	r0, #2
   29436:	e7b3      	b.n	293a0 <logobj_event_handler+0x4c>
   29438:	230e      	movs	r3, #14
   2943a:	606b      	str	r3, [r5, #4]
   2943c:	e7b0      	b.n	293a0 <logobj_event_handler+0x4c>
   2943e:	4a03      	ldr	r2, [pc, #12]	; (2944c <logobj_event_handler+0xf8>)
   29440:	7011      	strb	r1, [r2, #0]
   29442:	e7cf      	b.n	293e4 <logobj_event_handler+0x90>
   29444:	2002080c 	.word	0x2002080c
   29448:	20026142 	.word	0x20026142
   2944c:	20026143 	.word	0x20026143

00029450 <logobj_interface_init>:
   29450:	2300      	movs	r3, #0
   29452:	b510      	push	{r4, lr}
   29454:	4907      	ldr	r1, [pc, #28]	; (29474 <logobj_interface_init+0x24>)
   29456:	4a08      	ldr	r2, [pc, #32]	; (29478 <logobj_interface_init+0x28>)
   29458:	4c08      	ldr	r4, [pc, #32]	; (2947c <logobj_interface_init+0x2c>)
   2945a:	4809      	ldr	r0, [pc, #36]	; (29480 <logobj_interface_init+0x30>)
   2945c:	7023      	strb	r3, [r4, #0]
   2945e:	6003      	str	r3, [r0, #0]
   29460:	700b      	strb	r3, [r1, #0]
   29462:	6013      	str	r3, [r2, #0]
   29464:	f7ff ff26 	bl	292b4 <rpc_logobj_client_init>
   29468:	3000      	adds	r0, #0
   2946a:	bf18      	it	ne
   2946c:	2001      	movne	r0, #1
   2946e:	4240      	negs	r0, r0
   29470:	bd10      	pop	{r4, pc}
   29472:	bf00      	nop
   29474:	20026142 	.word	0x20026142
   29478:	20020808 	.word	0x20020808
   2947c:	20026143 	.word	0x20026143
   29480:	2002080c 	.word	0x2002080c

00029484 <logobj_interface_open>:
   29484:	2300      	movs	r3, #0
   29486:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2948a:	2866      	cmp	r0, #102	; 0x66
   2948c:	b082      	sub	sp, #8
   2948e:	9300      	str	r3, [sp, #0]
   29490:	d172      	bne.n	29578 <logobj_interface_open+0xf4>
   29492:	2902      	cmp	r1, #2
   29494:	4689      	mov	r9, r1
   29496:	d16f      	bne.n	29578 <logobj_interface_open+0xf4>
   29498:	f240 2305 	movw	r3, #517	; 0x205
   2949c:	429a      	cmp	r2, r3
   2949e:	4692      	mov	sl, r2
   294a0:	d16a      	bne.n	29578 <logobj_interface_open+0xf4>
   294a2:	4f48      	ldr	r7, [pc, #288]	; (295c4 <logobj_interface_open+0x140>)
   294a4:	683d      	ldr	r5, [r7, #0]
   294a6:	2d00      	cmp	r5, #0
   294a8:	d17c      	bne.n	295a4 <logobj_interface_open+0x120>
   294aa:	4680      	mov	r8, r0
   294ac:	4a46      	ldr	r2, [pc, #280]	; (295c8 <logobj_interface_open+0x144>)
   294ae:	4668      	mov	r0, sp
   294b0:	f006 f870 	bl	2f594 <interface_socket_allocate>
   294b4:	9b00      	ldr	r3, [sp, #0]
   294b6:	4606      	mov	r6, r0
   294b8:	2b00      	cmp	r3, #0
   294ba:	d07d      	beq.n	295b8 <logobj_interface_open+0x134>
   294bc:	4629      	mov	r1, r5
   294be:	2204      	movs	r2, #4
   294c0:	4842      	ldr	r0, [pc, #264]	; (295cc <logobj_interface_open+0x148>)
   294c2:	603b      	str	r3, [r7, #0]
   294c4:	f010 fc7b 	bl	39dbe <memset>
   294c8:	9c00      	ldr	r4, [sp, #0]
   294ca:	4629      	mov	r1, r5
   294cc:	e9c4 8903 	strd	r8, r9, [r4, #12]
   294d0:	f8c4 a014 	str.w	sl, [r4, #20]
   294d4:	a801      	add	r0, sp, #4
   294d6:	f7ff fef3 	bl	292c0 <rpc_logobj_client_request_alloc>
   294da:	2800      	cmp	r0, #0
   294dc:	d13c      	bne.n	29558 <logobj_interface_open+0xd4>
   294de:	2201      	movs	r2, #1
   294e0:	2104      	movs	r1, #4
   294e2:	9b01      	ldr	r3, [sp, #4]
   294e4:	4d3a      	ldr	r5, [pc, #232]	; (295d0 <logobj_interface_open+0x14c>)
   294e6:	7358      	strb	r0, [r3, #13]
   294e8:	7398      	strb	r0, [r3, #14]
   294ea:	73d8      	strb	r0, [r3, #15]
   294ec:	7258      	strb	r0, [r3, #9]
   294ee:	7298      	strb	r0, [r3, #10]
   294f0:	72d8      	strb	r0, [r3, #11]
   294f2:	7219      	strb	r1, [r3, #8]
   294f4:	702a      	strb	r2, [r5, #0]
   294f6:	731a      	strb	r2, [r3, #12]
   294f8:	6822      	ldr	r2, [r4, #0]
   294fa:	4618      	mov	r0, r3
   294fc:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
   29500:	6022      	str	r2, [r4, #0]
   29502:	f247 0101 	movw	r1, #28673	; 0x7001
   29506:	f7ff fef3 	bl	292f0 <rpc_logobj_client_request_send>
   2950a:	bb38      	cbnz	r0, 2955c <logobj_interface_open+0xd8>
   2950c:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   29510:	f04f 33ff 	mov.w	r3, #4294967295
   29514:	4611      	mov	r1, r2
   29516:	4630      	mov	r0, r6
   29518:	f006 f8ee 	bl	2f6f8 <interface_socket_wait>
   2951c:	4604      	mov	r4, r0
   2951e:	b310      	cbz	r0, 29566 <logobj_interface_open+0xe2>
   29520:	9a00      	ldr	r2, [sp, #0]
   29522:	2e00      	cmp	r6, #0
   29524:	6813      	ldr	r3, [r2, #0]
   29526:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2952a:	6013      	str	r3, [r2, #0]
   2952c:	9a00      	ldr	r2, [sp, #0]
   2952e:	6813      	ldr	r3, [r2, #0]
   29530:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   29534:	6013      	str	r3, [r2, #0]
   29536:	9a00      	ldr	r2, [sp, #0]
   29538:	6813      	ldr	r3, [r2, #0]
   2953a:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   2953e:	6013      	str	r3, [r2, #0]
   29540:	da36      	bge.n	295b0 <logobj_interface_open+0x12c>
   29542:	2300      	movs	r3, #0
   29544:	4620      	mov	r0, r4
   29546:	603b      	str	r3, [r7, #0]
   29548:	f04f 36ff 	mov.w	r6, #4294967295
   2954c:	f7fe fa88 	bl	27a60 <bsd_os_errno_set>
   29550:	4630      	mov	r0, r6
   29552:	b002      	add	sp, #8
   29554:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   29558:	240c      	movs	r4, #12
   2955a:	e7e1      	b.n	29520 <logobj_interface_open+0x9c>
   2955c:	9801      	ldr	r0, [sp, #4]
   2955e:	f7ff fedd 	bl	2931c <rpc_logobj_client_message_free>
   29562:	2405      	movs	r4, #5
   29564:	e7dc      	b.n	29520 <logobj_interface_open+0x9c>
   29566:	4630      	mov	r0, r6
   29568:	f006 f93a 	bl	2f7e0 <interface_socket_from_handle_get>
   2956c:	b150      	cbz	r0, 29584 <logobj_interface_open+0x100>
   2956e:	6844      	ldr	r4, [r0, #4]
   29570:	b144      	cbz	r4, 29584 <logobj_interface_open+0x100>
   29572:	2300      	movs	r3, #0
   29574:	6043      	str	r3, [r0, #4]
   29576:	e7d3      	b.n	29520 <logobj_interface_open+0x9c>
   29578:	2016      	movs	r0, #22
   2957a:	f7fe fa71 	bl	27a60 <bsd_os_errno_set>
   2957e:	f04f 36ff 	mov.w	r6, #4294967295
   29582:	e7e5      	b.n	29550 <logobj_interface_open+0xcc>
   29584:	9a00      	ldr	r2, [sp, #0]
   29586:	6813      	ldr	r3, [r2, #0]
   29588:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2958c:	6013      	str	r3, [r2, #0]
   2958e:	9a00      	ldr	r2, [sp, #0]
   29590:	6813      	ldr	r3, [r2, #0]
   29592:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   29596:	6013      	str	r3, [r2, #0]
   29598:	9a00      	ldr	r2, [sp, #0]
   2959a:	6813      	ldr	r3, [r2, #0]
   2959c:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   295a0:	6013      	str	r3, [r2, #0]
   295a2:	e7d5      	b.n	29550 <logobj_interface_open+0xcc>
   295a4:	2001      	movs	r0, #1
   295a6:	f7fe fa5b 	bl	27a60 <bsd_os_errno_set>
   295aa:	f04f 36ff 	mov.w	r6, #4294967295
   295ae:	e7cf      	b.n	29550 <logobj_interface_open+0xcc>
   295b0:	4630      	mov	r0, r6
   295b2:	f006 f853 	bl	2f65c <interface_socket_free>
   295b6:	e7c4      	b.n	29542 <logobj_interface_open+0xbe>
   295b8:	2018      	movs	r0, #24
   295ba:	f7fe fa51 	bl	27a60 <bsd_os_errno_set>
   295be:	f04f 36ff 	mov.w	r6, #4294967295
   295c2:	e7c5      	b.n	29550 <logobj_interface_open+0xcc>
   295c4:	2002080c 	.word	0x2002080c
   295c8:	0002933d 	.word	0x0002933d
   295cc:	20020808 	.word	0x20020808
   295d0:	20026142 	.word	0x20026142

000295d4 <logobj_interface_read>:
   295d4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   295d8:	b085      	sub	sp, #20
   295da:	2900      	cmp	r1, #0
   295dc:	d068      	beq.n	296b0 <logobj_interface_read+0xdc>
   295de:	2a00      	cmp	r2, #0
   295e0:	4617      	mov	r7, r2
   295e2:	dd65      	ble.n	296b0 <logobj_interface_read+0xdc>
   295e4:	461d      	mov	r5, r3
   295e6:	4680      	mov	r8, r0
   295e8:	460e      	mov	r6, r1
   295ea:	f006 f8f9 	bl	2f7e0 <interface_socket_from_handle_get>
   295ee:	4604      	mov	r4, r0
   295f0:	2800      	cmp	r0, #0
   295f2:	d063      	beq.n	296bc <logobj_interface_read+0xe8>
   295f4:	bb4d      	cbnz	r5, 2964a <logobj_interface_read+0x76>
   295f6:	69e0      	ldr	r0, [r4, #28]
   295f8:	07aa      	lsls	r2, r5, #30
   295fa:	6803      	ldr	r3, [r0, #0]
   295fc:	68db      	ldr	r3, [r3, #12]
   295fe:	d52d      	bpl.n	2965c <logobj_interface_read+0x88>
   29600:	4798      	blx	r3
   29602:	3001      	adds	r0, #1
   29604:	d044      	beq.n	29690 <logobj_interface_read+0xbc>
   29606:	6823      	ldr	r3, [r4, #0]
   29608:	69e0      	ldr	r0, [r4, #28]
   2960a:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
   2960e:	d041      	beq.n	29694 <logobj_interface_read+0xc0>
   29610:	2100      	movs	r1, #0
   29612:	6823      	ldr	r3, [r4, #0]
   29614:	462a      	mov	r2, r5
   29616:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   2961a:	6023      	str	r3, [r4, #0]
   2961c:	e9cd 1102 	strd	r1, r1, [sp, #8]
   29620:	e9cd 6700 	strd	r6, r7, [sp]
   29624:	6803      	ldr	r3, [r0, #0]
   29626:	4669      	mov	r1, sp
   29628:	689b      	ldr	r3, [r3, #8]
   2962a:	4798      	blx	r3
   2962c:	4605      	mov	r5, r0
   2962e:	69e0      	ldr	r0, [r4, #28]
   29630:	6803      	ldr	r3, [r0, #0]
   29632:	68db      	ldr	r3, [r3, #12]
   29634:	4798      	blx	r3
   29636:	3001      	adds	r0, #1
   29638:	d003      	beq.n	29642 <logobj_interface_read+0x6e>
   2963a:	6823      	ldr	r3, [r4, #0]
   2963c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   29640:	6023      	str	r3, [r4, #0]
   29642:	4628      	mov	r0, r5
   29644:	b005      	add	sp, #20
   29646:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2964a:	f015 0f0a 	tst.w	r5, #10
   2964e:	d1d2      	bne.n	295f6 <logobj_interface_read+0x22>
   29650:	202d      	movs	r0, #45	; 0x2d
   29652:	f7fe fa05 	bl	27a60 <bsd_os_errno_set>
   29656:	f04f 35ff 	mov.w	r5, #4294967295
   2965a:	e7f2      	b.n	29642 <logobj_interface_read+0x6e>
   2965c:	6822      	ldr	r2, [r4, #0]
   2965e:	f012 5980 	ands.w	r9, r2, #268435456	; 0x10000000
   29662:	d1cd      	bne.n	29600 <logobj_interface_read+0x2c>
   29664:	4798      	blx	r3
   29666:	1c43      	adds	r3, r0, #1
   29668:	d1cd      	bne.n	29606 <logobj_interface_read+0x32>
   2966a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   2966e:	6a23      	ldr	r3, [r4, #32]
   29670:	4611      	mov	r1, r2
   29672:	2b00      	cmp	r3, #0
   29674:	bf08      	it	eq
   29676:	4603      	moveq	r3, r0
   29678:	4640      	mov	r0, r8
   2967a:	f006 f83d 	bl	2f6f8 <interface_socket_wait>
   2967e:	b158      	cbz	r0, 29698 <logobj_interface_read+0xc4>
   29680:	f04f 35ff 	mov.w	r5, #4294967295
   29684:	f7fe f9ec 	bl	27a60 <bsd_os_errno_set>
   29688:	4628      	mov	r0, r5
   2968a:	b005      	add	sp, #20
   2968c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   29690:	2023      	movs	r0, #35	; 0x23
   29692:	e7f5      	b.n	29680 <logobj_interface_read+0xac>
   29694:	461d      	mov	r5, r3
   29696:	e7cb      	b.n	29630 <logobj_interface_read+0x5c>
   29698:	4640      	mov	r0, r8
   2969a:	f006 f8a1 	bl	2f7e0 <interface_socket_from_handle_get>
   2969e:	4603      	mov	r3, r0
   296a0:	2800      	cmp	r0, #0
   296a2:	d0b0      	beq.n	29606 <logobj_interface_read+0x32>
   296a4:	6840      	ldr	r0, [r0, #4]
   296a6:	2800      	cmp	r0, #0
   296a8:	d0ad      	beq.n	29606 <logobj_interface_read+0x32>
   296aa:	f8c3 9004 	str.w	r9, [r3, #4]
   296ae:	e7e7      	b.n	29680 <logobj_interface_read+0xac>
   296b0:	2016      	movs	r0, #22
   296b2:	f7fe f9d5 	bl	27a60 <bsd_os_errno_set>
   296b6:	f04f 35ff 	mov.w	r5, #4294967295
   296ba:	e7c2      	b.n	29642 <logobj_interface_read+0x6e>
   296bc:	2009      	movs	r0, #9
   296be:	f7fe f9cf 	bl	27a60 <bsd_os_errno_set>
   296c2:	f04f 35ff 	mov.w	r5, #4294967295
   296c6:	e7bc      	b.n	29642 <logobj_interface_read+0x6e>

000296c8 <logobj_interface_write>:
   296c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   296cc:	b082      	sub	sp, #8
   296ce:	2900      	cmp	r1, #0
   296d0:	d05e      	beq.n	29790 <logobj_interface_write+0xc8>
   296d2:	2a04      	cmp	r2, #4
   296d4:	d15c      	bne.n	29790 <logobj_interface_write+0xc8>
   296d6:	461e      	mov	r6, r3
   296d8:	4607      	mov	r7, r0
   296da:	460d      	mov	r5, r1
   296dc:	f006 f880 	bl	2f7e0 <interface_socket_from_handle_get>
   296e0:	4604      	mov	r4, r0
   296e2:	2800      	cmp	r0, #0
   296e4:	d070      	beq.n	297c8 <logobj_interface_write+0x100>
   296e6:	b1e6      	cbz	r6, 29722 <logobj_interface_write+0x5a>
   296e8:	07b0      	lsls	r0, r6, #30
   296ea:	d567      	bpl.n	297bc <logobj_interface_write+0xf4>
   296ec:	6823      	ldr	r3, [r4, #0]
   296ee:	039b      	lsls	r3, r3, #14
   296f0:	d560      	bpl.n	297b4 <logobj_interface_write+0xec>
   296f2:	2600      	movs	r6, #0
   296f4:	6823      	ldr	r3, [r4, #0]
   296f6:	2100      	movs	r1, #0
   296f8:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   296fc:	6023      	str	r3, [r4, #0]
   296fe:	a801      	add	r0, sp, #4
   29700:	f8d5 8000 	ldr.w	r8, [r5]
   29704:	f7ff fddc 	bl	292c0 <rpc_logobj_client_request_alloc>
   29708:	b198      	cbz	r0, 29732 <logobj_interface_write+0x6a>
   2970a:	200c      	movs	r0, #12
   2970c:	6823      	ldr	r3, [r4, #0]
   2970e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   29712:	6023      	str	r3, [r4, #0]
   29714:	f7fe f9a4 	bl	27a60 <bsd_os_errno_set>
   29718:	f04f 30ff 	mov.w	r0, #4294967295
   2971c:	b002      	add	sp, #8
   2971e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   29722:	6803      	ldr	r3, [r0, #0]
   29724:	00d9      	lsls	r1, r3, #3
   29726:	d4e1      	bmi.n	296ec <logobj_interface_write+0x24>
   29728:	6803      	ldr	r3, [r0, #0]
   2972a:	039a      	lsls	r2, r3, #14
   2972c:	d544      	bpl.n	297b8 <logobj_interface_write+0xf0>
   2972e:	2601      	movs	r6, #1
   29730:	e7e0      	b.n	296f4 <logobj_interface_write+0x2c>
   29732:	2504      	movs	r5, #4
   29734:	9b01      	ldr	r3, [sp, #4]
   29736:	f247 0103 	movw	r1, #28675	; 0x7003
   2973a:	f8c3 800c 	str.w	r8, [r3, #12]
   2973e:	7258      	strb	r0, [r3, #9]
   29740:	7298      	strb	r0, [r3, #10]
   29742:	72d8      	strb	r0, [r3, #11]
   29744:	721d      	strb	r5, [r3, #8]
   29746:	4618      	mov	r0, r3
   29748:	f7ff fdd2 	bl	292f0 <rpc_logobj_client_request_send>
   2974c:	4680      	mov	r8, r0
   2974e:	b9b0      	cbnz	r0, 2977e <logobj_interface_write+0xb6>
   29750:	b93e      	cbnz	r6, 29762 <logobj_interface_write+0x9a>
   29752:	4628      	mov	r0, r5
   29754:	6823      	ldr	r3, [r4, #0]
   29756:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2975a:	6023      	str	r3, [r4, #0]
   2975c:	b002      	add	sp, #8
   2975e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   29762:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   29766:	f04f 33ff 	mov.w	r3, #4294967295
   2976a:	4611      	mov	r1, r2
   2976c:	4638      	mov	r0, r7
   2976e:	f005 ffc3 	bl	2f6f8 <interface_socket_wait>
   29772:	b198      	cbz	r0, 2979c <logobj_interface_write+0xd4>
   29774:	6823      	ldr	r3, [r4, #0]
   29776:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2977a:	6023      	str	r3, [r4, #0]
   2977c:	e7ca      	b.n	29714 <logobj_interface_write+0x4c>
   2977e:	9801      	ldr	r0, [sp, #4]
   29780:	f7ff fdcc 	bl	2931c <rpc_logobj_client_message_free>
   29784:	6823      	ldr	r3, [r4, #0]
   29786:	2005      	movs	r0, #5
   29788:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2978c:	6023      	str	r3, [r4, #0]
   2978e:	e7c1      	b.n	29714 <logobj_interface_write+0x4c>
   29790:	2016      	movs	r0, #22
   29792:	f7fe f965 	bl	27a60 <bsd_os_errno_set>
   29796:	f04f 30ff 	mov.w	r0, #4294967295
   2979a:	e7bf      	b.n	2971c <logobj_interface_write+0x54>
   2979c:	4638      	mov	r0, r7
   2979e:	f006 f81f 	bl	2f7e0 <interface_socket_from_handle_get>
   297a2:	4603      	mov	r3, r0
   297a4:	2800      	cmp	r0, #0
   297a6:	d0d4      	beq.n	29752 <logobj_interface_write+0x8a>
   297a8:	6840      	ldr	r0, [r0, #4]
   297aa:	2800      	cmp	r0, #0
   297ac:	d0d1      	beq.n	29752 <logobj_interface_write+0x8a>
   297ae:	f8c3 8004 	str.w	r8, [r3, #4]
   297b2:	e7df      	b.n	29774 <logobj_interface_write+0xac>
   297b4:	2073      	movs	r0, #115	; 0x73
   297b6:	e7ad      	b.n	29714 <logobj_interface_write+0x4c>
   297b8:	2009      	movs	r0, #9
   297ba:	e7ab      	b.n	29714 <logobj_interface_write+0x4c>
   297bc:	202d      	movs	r0, #45	; 0x2d
   297be:	f7fe f94f 	bl	27a60 <bsd_os_errno_set>
   297c2:	f04f 30ff 	mov.w	r0, #4294967295
   297c6:	e7a9      	b.n	2971c <logobj_interface_write+0x54>
   297c8:	2009      	movs	r0, #9
   297ca:	f7fe f949 	bl	27a60 <bsd_os_errno_set>
   297ce:	f04f 30ff 	mov.w	r0, #4294967295
   297d2:	e7a3      	b.n	2971c <logobj_interface_write+0x54>

000297d4 <logobj_interface_setopt>:
   297d4:	b5f0      	push	{r4, r5, r6, r7, lr}
   297d6:	2901      	cmp	r1, #1
   297d8:	b085      	sub	sp, #20
   297da:	d068      	beq.n	298ae <logobj_interface_setopt+0xda>
   297dc:	461e      	mov	r6, r3
   297de:	f240 2305 	movw	r3, #517	; 0x205
   297e2:	4299      	cmp	r1, r3
   297e4:	f040 8095 	bne.w	29912 <logobj_interface_setopt+0x13e>
   297e8:	4607      	mov	r7, r0
   297ea:	4615      	mov	r5, r2
   297ec:	f005 fff8 	bl	2f7e0 <interface_socket_from_handle_get>
   297f0:	4604      	mov	r4, r0
   297f2:	2800      	cmp	r0, #0
   297f4:	f000 80b2 	beq.w	2995c <logobj_interface_setopt+0x188>
   297f8:	2d01      	cmp	r5, #1
   297fa:	d019      	beq.n	29830 <logobj_interface_setopt+0x5c>
   297fc:	2d02      	cmp	r5, #2
   297fe:	d010      	beq.n	29822 <logobj_interface_setopt+0x4e>
   29800:	252a      	movs	r5, #42	; 0x2a
   29802:	6803      	ldr	r3, [r0, #0]
   29804:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   29808:	6023      	str	r3, [r4, #0]
   2980a:	6823      	ldr	r3, [r4, #0]
   2980c:	4628      	mov	r0, r5
   2980e:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   29812:	6023      	str	r3, [r4, #0]
   29814:	f7fe f924 	bl	27a60 <bsd_os_errno_set>
   29818:	f04f 35ff 	mov.w	r5, #4294967295
   2981c:	4628      	mov	r0, r5
   2981e:	b005      	add	sp, #20
   29820:	bdf0      	pop	{r4, r5, r6, r7, pc}
   29822:	b116      	cbz	r6, 2982a <logobj_interface_setopt+0x56>
   29824:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   29826:	2b01      	cmp	r3, #1
   29828:	d049      	beq.n	298be <logobj_interface_setopt+0xea>
   2982a:	6823      	ldr	r3, [r4, #0]
   2982c:	2516      	movs	r5, #22
   2982e:	e7e9      	b.n	29804 <logobj_interface_setopt+0x30>
   29830:	2e00      	cmp	r6, #0
   29832:	d0fa      	beq.n	2982a <logobj_interface_setopt+0x56>
   29834:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   29836:	2b04      	cmp	r3, #4
   29838:	d1f7      	bne.n	2982a <logobj_interface_setopt+0x56>
   2983a:	2100      	movs	r1, #0
   2983c:	a803      	add	r0, sp, #12
   2983e:	f7ff fd3f 	bl	292c0 <rpc_logobj_client_request_alloc>
   29842:	4605      	mov	r5, r0
   29844:	2800      	cmp	r0, #0
   29846:	d16a      	bne.n	2991e <logobj_interface_setopt+0x14a>
   29848:	9803      	ldr	r0, [sp, #12]
   2984a:	2208      	movs	r2, #8
   2984c:	4629      	mov	r1, r5
   2984e:	300c      	adds	r0, #12
   29850:	f010 fab5 	bl	39dbe <memset>
   29854:	9803      	ldr	r0, [sp, #12]
   29856:	4631      	mov	r1, r6
   29858:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   2985a:	300c      	adds	r0, #12
   2985c:	f010 fa8f 	bl	39d7e <memcpy>
   29860:	2308      	movs	r3, #8
   29862:	9803      	ldr	r0, [sp, #12]
   29864:	f247 0102 	movw	r1, #28674	; 0x7002
   29868:	7203      	strb	r3, [r0, #8]
   2986a:	7245      	strb	r5, [r0, #9]
   2986c:	7285      	strb	r5, [r0, #10]
   2986e:	72c5      	strb	r5, [r0, #11]
   29870:	6823      	ldr	r3, [r4, #0]
   29872:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   29876:	6023      	str	r3, [r4, #0]
   29878:	f7ff fd3a 	bl	292f0 <rpc_logobj_client_request_send>
   2987c:	2800      	cmp	r0, #0
   2987e:	d151      	bne.n	29924 <logobj_interface_setopt+0x150>
   29880:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   29884:	f04f 33ff 	mov.w	r3, #4294967295
   29888:	4611      	mov	r1, r2
   2988a:	4638      	mov	r0, r7
   2988c:	f005 ff34 	bl	2f6f8 <interface_socket_wait>
   29890:	4605      	mov	r5, r0
   29892:	2800      	cmp	r0, #0
   29894:	d13b      	bne.n	2990e <logobj_interface_setopt+0x13a>
   29896:	4638      	mov	r0, r7
   29898:	f005 ffa2 	bl	2f7e0 <interface_socket_from_handle_get>
   2989c:	2800      	cmp	r0, #0
   2989e:	d04f      	beq.n	29940 <logobj_interface_setopt+0x16c>
   298a0:	6843      	ldr	r3, [r0, #4]
   298a2:	2b00      	cmp	r3, #0
   298a4:	d04c      	beq.n	29940 <logobj_interface_setopt+0x16c>
   298a6:	2200      	movs	r2, #0
   298a8:	461d      	mov	r5, r3
   298aa:	6042      	str	r2, [r0, #4]
   298ac:	e02f      	b.n	2990e <logobj_interface_setopt+0x13a>
   298ae:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   298b0:	9400      	str	r4, [sp, #0]
   298b2:	f005 ffbd 	bl	2f830 <interface_socket_setopt>
   298b6:	4605      	mov	r5, r0
   298b8:	4628      	mov	r0, r5
   298ba:	b005      	add	sp, #20
   298bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   298be:	2100      	movs	r1, #0
   298c0:	a803      	add	r0, sp, #12
   298c2:	7835      	ldrb	r5, [r6, #0]
   298c4:	f7ff fcfc 	bl	292c0 <rpc_logobj_client_request_alloc>
   298c8:	bb48      	cbnz	r0, 2991e <logobj_interface_setopt+0x14a>
   298ca:	2d01      	cmp	r5, #1
   298cc:	bf08      	it	eq
   298ce:	4b26      	ldreq	r3, [pc, #152]	; (29968 <logobj_interface_setopt+0x194>)
   298d0:	f04f 0204 	mov.w	r2, #4
   298d4:	bf08      	it	eq
   298d6:	701d      	strbeq	r5, [r3, #0]
   298d8:	2300      	movs	r3, #0
   298da:	9803      	ldr	r0, [sp, #12]
   298dc:	f247 0101 	movw	r1, #28673	; 0x7001
   298e0:	7243      	strb	r3, [r0, #9]
   298e2:	60c5      	str	r5, [r0, #12]
   298e4:	7283      	strb	r3, [r0, #10]
   298e6:	72c3      	strb	r3, [r0, #11]
   298e8:	7202      	strb	r2, [r0, #8]
   298ea:	6823      	ldr	r3, [r4, #0]
   298ec:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   298f0:	6023      	str	r3, [r4, #0]
   298f2:	f7ff fcfd 	bl	292f0 <rpc_logobj_client_request_send>
   298f6:	4606      	mov	r6, r0
   298f8:	b9a0      	cbnz	r0, 29924 <logobj_interface_setopt+0x150>
   298fa:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   298fe:	f04f 33ff 	mov.w	r3, #4294967295
   29902:	4611      	mov	r1, r2
   29904:	4638      	mov	r0, r7
   29906:	f005 fef7 	bl	2f6f8 <interface_socket_wait>
   2990a:	4605      	mov	r5, r0
   2990c:	b180      	cbz	r0, 29930 <logobj_interface_setopt+0x15c>
   2990e:	6823      	ldr	r3, [r4, #0]
   29910:	e778      	b.n	29804 <logobj_interface_setopt+0x30>
   29912:	202a      	movs	r0, #42	; 0x2a
   29914:	f7fe f8a4 	bl	27a60 <bsd_os_errno_set>
   29918:	f04f 35ff 	mov.w	r5, #4294967295
   2991c:	e77e      	b.n	2981c <logobj_interface_setopt+0x48>
   2991e:	6823      	ldr	r3, [r4, #0]
   29920:	250c      	movs	r5, #12
   29922:	e76f      	b.n	29804 <logobj_interface_setopt+0x30>
   29924:	9803      	ldr	r0, [sp, #12]
   29926:	f7ff fcf9 	bl	2931c <rpc_logobj_client_message_free>
   2992a:	2505      	movs	r5, #5
   2992c:	6823      	ldr	r3, [r4, #0]
   2992e:	e769      	b.n	29804 <logobj_interface_setopt+0x30>
   29930:	4638      	mov	r0, r7
   29932:	f005 ff55 	bl	2f7e0 <interface_socket_from_handle_get>
   29936:	b140      	cbz	r0, 2994a <logobj_interface_setopt+0x176>
   29938:	6845      	ldr	r5, [r0, #4]
   2993a:	b135      	cbz	r5, 2994a <logobj_interface_setopt+0x176>
   2993c:	6046      	str	r6, [r0, #4]
   2993e:	e7e6      	b.n	2990e <logobj_interface_setopt+0x13a>
   29940:	4631      	mov	r1, r6
   29942:	2204      	movs	r2, #4
   29944:	4809      	ldr	r0, [pc, #36]	; (2996c <logobj_interface_setopt+0x198>)
   29946:	f010 fa1a 	bl	39d7e <memcpy>
   2994a:	6823      	ldr	r3, [r4, #0]
   2994c:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   29950:	6023      	str	r3, [r4, #0]
   29952:	6823      	ldr	r3, [r4, #0]
   29954:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   29958:	6023      	str	r3, [r4, #0]
   2995a:	e75f      	b.n	2981c <logobj_interface_setopt+0x48>
   2995c:	2009      	movs	r0, #9
   2995e:	f7fe f87f 	bl	27a60 <bsd_os_errno_set>
   29962:	f04f 35ff 	mov.w	r5, #4294967295
   29966:	e759      	b.n	2981c <logobj_interface_setopt+0x48>
   29968:	20026142 	.word	0x20026142
   2996c:	20020808 	.word	0x20020808

00029970 <logobj_interface_getopt>:
   29970:	b5f0      	push	{r4, r5, r6, r7, lr}
   29972:	2901      	cmp	r1, #1
   29974:	b083      	sub	sp, #12
   29976:	9e08      	ldr	r6, [sp, #32]
   29978:	d030      	beq.n	299dc <logobj_interface_getopt+0x6c>
   2997a:	461f      	mov	r7, r3
   2997c:	f240 2305 	movw	r3, #517	; 0x205
   29980:	4299      	cmp	r1, r3
   29982:	d134      	bne.n	299ee <logobj_interface_getopt+0x7e>
   29984:	4615      	mov	r5, r2
   29986:	f005 ff2b 	bl	2f7e0 <interface_socket_from_handle_get>
   2998a:	2800      	cmp	r0, #0
   2998c:	d037      	beq.n	299fe <logobj_interface_getopt+0x8e>
   2998e:	2d01      	cmp	r5, #1
   29990:	d015      	beq.n	299be <logobj_interface_getopt+0x4e>
   29992:	2d02      	cmp	r5, #2
   29994:	d10b      	bne.n	299ae <logobj_interface_getopt+0x3e>
   29996:	b387      	cbz	r7, 299fa <logobj_interface_getopt+0x8a>
   29998:	6833      	ldr	r3, [r6, #0]
   2999a:	b373      	cbz	r3, 299fa <logobj_interface_getopt+0x8a>
   2999c:	2300      	movs	r3, #0
   2999e:	2201      	movs	r2, #1
   299a0:	4618      	mov	r0, r3
   299a2:	491a      	ldr	r1, [pc, #104]	; (29a0c <logobj_interface_getopt+0x9c>)
   299a4:	7809      	ldrb	r1, [r1, #0]
   299a6:	7039      	strb	r1, [r7, #0]
   299a8:	6032      	str	r2, [r6, #0]
   299aa:	b003      	add	sp, #12
   299ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
   299ae:	2009      	movs	r0, #9
   299b0:	f7fe f856 	bl	27a60 <bsd_os_errno_set>
   299b4:	f04f 33ff 	mov.w	r3, #4294967295
   299b8:	4618      	mov	r0, r3
   299ba:	b003      	add	sp, #12
   299bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   299be:	b1e7      	cbz	r7, 299fa <logobj_interface_getopt+0x8a>
   299c0:	6833      	ldr	r3, [r6, #0]
   299c2:	2b03      	cmp	r3, #3
   299c4:	d919      	bls.n	299fa <logobj_interface_getopt+0x8a>
   299c6:	4638      	mov	r0, r7
   299c8:	2204      	movs	r2, #4
   299ca:	4911      	ldr	r1, [pc, #68]	; (29a10 <logobj_interface_getopt+0xa0>)
   299cc:	f010 f9d7 	bl	39d7e <memcpy>
   299d0:	2300      	movs	r3, #0
   299d2:	2204      	movs	r2, #4
   299d4:	4618      	mov	r0, r3
   299d6:	6032      	str	r2, [r6, #0]
   299d8:	b003      	add	sp, #12
   299da:	bdf0      	pop	{r4, r5, r6, r7, pc}
   299dc:	9600      	str	r6, [sp, #0]
   299de:	f005 ff69 	bl	2f8b4 <interface_socket_getopt>
   299e2:	4603      	mov	r3, r0
   299e4:	2800      	cmp	r0, #0
   299e6:	d1e3      	bne.n	299b0 <logobj_interface_getopt+0x40>
   299e8:	4618      	mov	r0, r3
   299ea:	b003      	add	sp, #12
   299ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
   299ee:	202a      	movs	r0, #42	; 0x2a
   299f0:	f7fe f836 	bl	27a60 <bsd_os_errno_set>
   299f4:	f04f 33ff 	mov.w	r3, #4294967295
   299f8:	e7de      	b.n	299b8 <logobj_interface_getopt+0x48>
   299fa:	2016      	movs	r0, #22
   299fc:	e7d8      	b.n	299b0 <logobj_interface_getopt+0x40>
   299fe:	2009      	movs	r0, #9
   29a00:	f7fe f82e 	bl	27a60 <bsd_os_errno_set>
   29a04:	f04f 33ff 	mov.w	r3, #4294967295
   29a08:	e7d6      	b.n	299b8 <logobj_interface_getopt+0x48>
   29a0a:	bf00      	nop
   29a0c:	20026143 	.word	0x20026143
   29a10:	20020808 	.word	0x20020808

00029a14 <logobj_interface_close>:
   29a14:	b510      	push	{r4, lr}
   29a16:	4604      	mov	r4, r0
   29a18:	f005 fee2 	bl	2f7e0 <interface_socket_from_handle_get>
   29a1c:	b138      	cbz	r0, 29a2e <logobj_interface_close+0x1a>
   29a1e:	4620      	mov	r0, r4
   29a20:	f005 fe1c 	bl	2f65c <interface_socket_free>
   29a24:	2300      	movs	r3, #0
   29a26:	4a05      	ldr	r2, [pc, #20]	; (29a3c <logobj_interface_close+0x28>)
   29a28:	4618      	mov	r0, r3
   29a2a:	6013      	str	r3, [r2, #0]
   29a2c:	bd10      	pop	{r4, pc}
   29a2e:	2009      	movs	r0, #9
   29a30:	f7fe f816 	bl	27a60 <bsd_os_errno_set>
   29a34:	f04f 30ff 	mov.w	r0, #4294967295
   29a38:	bd10      	pop	{r4, pc}
   29a3a:	bf00      	nop
   29a3c:	2002080c 	.word	0x2002080c

00029a40 <packet_free_cb>:
   29a40:	6800      	ldr	r0, [r0, #0]
   29a42:	f004 b9ef 	b.w	2de24 <rpc_at_client_data_free>
   29a46:	bf00      	nop

00029a48 <at_interface_write>:
   29a48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   29a4c:	b082      	sub	sp, #8
   29a4e:	9c08      	ldr	r4, [sp, #32]
   29a50:	2c00      	cmp	r4, #0
   29a52:	d15b      	bne.n	29b0c <at_interface_write+0xc4>
   29a54:	460f      	mov	r7, r1
   29a56:	4615      	mov	r5, r2
   29a58:	4698      	mov	r8, r3
   29a5a:	4606      	mov	r6, r0
   29a5c:	f005 fec0 	bl	2f7e0 <interface_socket_from_handle_get>
   29a60:	4604      	mov	r4, r0
   29a62:	f1b8 0f00 	cmp.w	r8, #0
   29a66:	d12b      	bne.n	29ac0 <at_interface_write+0x78>
   29a68:	2800      	cmp	r0, #0
   29a6a:	d055      	beq.n	29b18 <at_interface_write+0xd0>
   29a6c:	6803      	ldr	r3, [r0, #0]
   29a6e:	039b      	lsls	r3, r3, #14
   29a70:	d552      	bpl.n	29b18 <at_interface_write+0xd0>
   29a72:	6803      	ldr	r3, [r0, #0]
   29a74:	4629      	mov	r1, r5
   29a76:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   29a7a:	6003      	str	r3, [r0, #0]
   29a7c:	6803      	ldr	r3, [r0, #0]
   29a7e:	a801      	add	r0, sp, #4
   29a80:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
   29a84:	6023      	str	r3, [r4, #0]
   29a86:	f004 f9a3 	bl	2ddd0 <rpc_at_client_request_alloc>
   29a8a:	bb08      	cbnz	r0, 29ad0 <at_interface_write+0x88>
   29a8c:	2204      	movs	r2, #4
   29a8e:	9b01      	ldr	r3, [sp, #4]
   29a90:	721a      	strb	r2, [r3, #8]
   29a92:	7258      	strb	r0, [r3, #9]
   29a94:	7298      	strb	r0, [r3, #10]
   29a96:	72d8      	strb	r0, [r3, #11]
   29a98:	60de      	str	r6, [r3, #12]
   29a9a:	b9fd      	cbnz	r5, 29adc <at_interface_write+0x94>
   29a9c:	4618      	mov	r0, r3
   29a9e:	2101      	movs	r1, #1
   29aa0:	f004 f9aa 	bl	2ddf8 <rpc_at_client_request_send>
   29aa4:	bb48      	cbnz	r0, 29afa <at_interface_write+0xb2>
   29aa6:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   29aaa:	4630      	mov	r0, r6
   29aac:	4611      	mov	r1, r2
   29aae:	f04f 33ff 	mov.w	r3, #4294967295
   29ab2:	f005 fe21 	bl	2f6f8 <interface_socket_wait>
   29ab6:	b960      	cbnz	r0, 29ad2 <at_interface_write+0x8a>
   29ab8:	4628      	mov	r0, r5
   29aba:	b002      	add	sp, #8
   29abc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   29ac0:	b360      	cbz	r0, 29b1c <at_interface_write+0xd4>
   29ac2:	6803      	ldr	r3, [r0, #0]
   29ac4:	202d      	movs	r0, #45	; 0x2d
   29ac6:	f7fd ffcb 	bl	27a60 <bsd_os_errno_set>
   29aca:	f04f 30ff 	mov.w	r0, #4294967295
   29ace:	e7f4      	b.n	29aba <at_interface_write+0x72>
   29ad0:	200c      	movs	r0, #12
   29ad2:	6823      	ldr	r3, [r4, #0]
   29ad4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   29ad8:	6023      	str	r3, [r4, #0]
   29ada:	e7f4      	b.n	29ac6 <at_interface_write+0x7e>
   29adc:	4639      	mov	r1, r7
   29ade:	6818      	ldr	r0, [r3, #0]
   29ae0:	462a      	mov	r2, r5
   29ae2:	f010 f94c 	bl	39d7e <memcpy>
   29ae6:	2101      	movs	r1, #1
   29ae8:	9801      	ldr	r0, [sp, #4]
   29aea:	f004 f985 	bl	2ddf8 <rpc_at_client_request_send>
   29aee:	2800      	cmp	r0, #0
   29af0:	d0d9      	beq.n	29aa6 <at_interface_write+0x5e>
   29af2:	9b01      	ldr	r3, [sp, #4]
   29af4:	6818      	ldr	r0, [r3, #0]
   29af6:	f004 f995 	bl	2de24 <rpc_at_client_data_free>
   29afa:	9801      	ldr	r0, [sp, #4]
   29afc:	f004 f98a 	bl	2de14 <rpc_at_client_message_free>
   29b00:	6823      	ldr	r3, [r4, #0]
   29b02:	2023      	movs	r0, #35	; 0x23
   29b04:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   29b08:	6023      	str	r3, [r4, #0]
   29b0a:	e7dc      	b.n	29ac6 <at_interface_write+0x7e>
   29b0c:	2038      	movs	r0, #56	; 0x38
   29b0e:	f7fd ffa7 	bl	27a60 <bsd_os_errno_set>
   29b12:	f04f 30ff 	mov.w	r0, #4294967295
   29b16:	e7d0      	b.n	29aba <at_interface_write+0x72>
   29b18:	2016      	movs	r0, #22
   29b1a:	e7d4      	b.n	29ac6 <at_interface_write+0x7e>
   29b1c:	202d      	movs	r0, #45	; 0x2d
   29b1e:	e7d2      	b.n	29ac6 <at_interface_write+0x7e>

00029b20 <at_interface_init>:
   29b20:	f004 b950 	b.w	2ddc4 <rpc_at_client_init>

00029b24 <at_interface_open>:
   29b24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   29b28:	2600      	movs	r6, #0
   29b2a:	b082      	sub	sp, #8
   29b2c:	2902      	cmp	r1, #2
   29b2e:	9600      	str	r6, [sp, #0]
   29b30:	d13e      	bne.n	29bb0 <at_interface_open+0x8c>
   29b32:	4680      	mov	r8, r0
   29b34:	4617      	mov	r7, r2
   29b36:	4668      	mov	r0, sp
   29b38:	4a20      	ldr	r2, [pc, #128]	; (29bbc <at_interface_open+0x98>)
   29b3a:	460c      	mov	r4, r1
   29b3c:	f005 fd2a 	bl	2f594 <interface_socket_allocate>
   29b40:	9b00      	ldr	r3, [sp, #0]
   29b42:	4605      	mov	r5, r0
   29b44:	b30b      	cbz	r3, 29b8a <at_interface_open+0x66>
   29b46:	e9c3 8403 	strd	r8, r4, [r3, #12]
   29b4a:	615f      	str	r7, [r3, #20]
   29b4c:	4631      	mov	r1, r6
   29b4e:	a801      	add	r0, sp, #4
   29b50:	f004 f93e 	bl	2ddd0 <rpc_at_client_request_alloc>
   29b54:	bb50      	cbnz	r0, 29bac <at_interface_open+0x88>
   29b56:	2204      	movs	r2, #4
   29b58:	9b01      	ldr	r3, [sp, #4]
   29b5a:	2105      	movs	r1, #5
   29b5c:	7258      	strb	r0, [r3, #9]
   29b5e:	7298      	strb	r0, [r3, #10]
   29b60:	72d8      	strb	r0, [r3, #11]
   29b62:	721a      	strb	r2, [r3, #8]
   29b64:	60dd      	str	r5, [r3, #12]
   29b66:	4618      	mov	r0, r3
   29b68:	f004 f946 	bl	2ddf8 <rpc_at_client_request_send>
   29b6c:	b988      	cbnz	r0, 29b92 <at_interface_open+0x6e>
   29b6e:	4622      	mov	r2, r4
   29b70:	4621      	mov	r1, r4
   29b72:	f04f 33ff 	mov.w	r3, #4294967295
   29b76:	4628      	mov	r0, r5
   29b78:	f005 fdbe 	bl	2f6f8 <interface_socket_wait>
   29b7c:	4604      	mov	r4, r0
   29b7e:	b960      	cbnz	r0, 29b9a <at_interface_open+0x76>
   29b80:	9a00      	ldr	r2, [sp, #0]
   29b82:	6813      	ldr	r3, [r2, #0]
   29b84:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   29b88:	6013      	str	r3, [r2, #0]
   29b8a:	4628      	mov	r0, r5
   29b8c:	b002      	add	sp, #8
   29b8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   29b92:	9801      	ldr	r0, [sp, #4]
   29b94:	f004 f93e 	bl	2de14 <rpc_at_client_message_free>
   29b98:	2423      	movs	r4, #35	; 0x23
   29b9a:	4628      	mov	r0, r5
   29b9c:	f005 fd5e 	bl	2f65c <interface_socket_free>
   29ba0:	4620      	mov	r0, r4
   29ba2:	f7fd ff5d 	bl	27a60 <bsd_os_errno_set>
   29ba6:	f04f 35ff 	mov.w	r5, #4294967295
   29baa:	e7ee      	b.n	29b8a <at_interface_open+0x66>
   29bac:	240c      	movs	r4, #12
   29bae:	e7f4      	b.n	29b9a <at_interface_open+0x76>
   29bb0:	2029      	movs	r0, #41	; 0x29
   29bb2:	f7fd ff55 	bl	27a60 <bsd_os_errno_set>
   29bb6:	f04f 35ff 	mov.w	r5, #4294967295
   29bba:	e7e6      	b.n	29b8a <at_interface_open+0x66>
   29bbc:	00029a41 	.word	0x00029a41

00029bc0 <at_interface_close>:
   29bc0:	b5f0      	push	{r4, r5, r6, r7, lr}
   29bc2:	b083      	sub	sp, #12
   29bc4:	4606      	mov	r6, r0
   29bc6:	f005 fe0b 	bl	2f7e0 <interface_socket_from_handle_get>
   29bca:	2800      	cmp	r0, #0
   29bcc:	d03d      	beq.n	29c4a <at_interface_close+0x8a>
   29bce:	230d      	movs	r3, #13
   29bd0:	6807      	ldr	r7, [r0, #0]
   29bd2:	6003      	str	r3, [r0, #0]
   29bd4:	6803      	ldr	r3, [r0, #0]
   29bd6:	4604      	mov	r4, r0
   29bd8:	039b      	lsls	r3, r3, #14
   29bda:	d41f      	bmi.n	29c1c <at_interface_close+0x5c>
   29bdc:	2100      	movs	r1, #0
   29bde:	a801      	add	r0, sp, #4
   29be0:	f004 f8f6 	bl	2ddd0 <rpc_at_client_request_alloc>
   29be4:	bb20      	cbnz	r0, 29c30 <at_interface_close+0x70>
   29be6:	2204      	movs	r2, #4
   29be8:	9b01      	ldr	r3, [sp, #4]
   29bea:	2106      	movs	r1, #6
   29bec:	7258      	strb	r0, [r3, #9]
   29bee:	7298      	strb	r0, [r3, #10]
   29bf0:	72d8      	strb	r0, [r3, #11]
   29bf2:	721a      	strb	r2, [r3, #8]
   29bf4:	60de      	str	r6, [r3, #12]
   29bf6:	4618      	mov	r0, r3
   29bf8:	f004 f8fe 	bl	2ddf8 <rpc_at_client_request_send>
   29bfc:	b9d0      	cbnz	r0, 29c34 <at_interface_close+0x74>
   29bfe:	220e      	movs	r2, #14
   29c00:	f04f 33ff 	mov.w	r3, #4294967295
   29c04:	4611      	mov	r1, r2
   29c06:	4630      	mov	r0, r6
   29c08:	f005 fd76 	bl	2f6f8 <interface_socket_wait>
   29c0c:	4605      	mov	r5, r0
   29c0e:	b9a8      	cbnz	r0, 29c3c <at_interface_close+0x7c>
   29c10:	4630      	mov	r0, r6
   29c12:	f005 fd23 	bl	2f65c <interface_socket_free>
   29c16:	4628      	mov	r0, r5
   29c18:	b003      	add	sp, #12
   29c1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   29c1c:	6803      	ldr	r3, [r0, #0]
   29c1e:	2100      	movs	r1, #0
   29c20:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   29c24:	6003      	str	r3, [r0, #0]
   29c26:	a801      	add	r0, sp, #4
   29c28:	f004 f8d2 	bl	2ddd0 <rpc_at_client_request_alloc>
   29c2c:	2800      	cmp	r0, #0
   29c2e:	d0da      	beq.n	29be6 <at_interface_close+0x26>
   29c30:	250c      	movs	r5, #12
   29c32:	e003      	b.n	29c3c <at_interface_close+0x7c>
   29c34:	9801      	ldr	r0, [sp, #4]
   29c36:	f004 f8ed 	bl	2de14 <rpc_at_client_message_free>
   29c3a:	2523      	movs	r5, #35	; 0x23
   29c3c:	6027      	str	r7, [r4, #0]
   29c3e:	4628      	mov	r0, r5
   29c40:	f7fd ff0e 	bl	27a60 <bsd_os_errno_set>
   29c44:	f04f 35ff 	mov.w	r5, #4294967295
   29c48:	e7e5      	b.n	29c16 <at_interface_close+0x56>
   29c4a:	2516      	movs	r5, #22
   29c4c:	e7f7      	b.n	29c3e <at_interface_close+0x7e>
   29c4e:	bf00      	nop

00029c50 <at_interface_read>:
   29c50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   29c54:	b084      	sub	sp, #16
   29c56:	4688      	mov	r8, r1
   29c58:	4615      	mov	r5, r2
   29c5a:	461e      	mov	r6, r3
   29c5c:	4607      	mov	r7, r0
   29c5e:	f005 fdbf 	bl	2f7e0 <interface_socket_from_handle_get>
   29c62:	2800      	cmp	r0, #0
   29c64:	d043      	beq.n	29cee <at_interface_read+0x9e>
   29c66:	2300      	movs	r3, #0
   29c68:	4604      	mov	r4, r0
   29c6a:	e9cd 8500 	strd	r8, r5, [sp]
   29c6e:	e9cd 3302 	strd	r3, r3, [sp, #8]
   29c72:	bb2e      	cbnz	r6, 29cc0 <at_interface_read+0x70>
   29c74:	f016 0502 	ands.w	r5, r6, #2
   29c78:	d00d      	beq.n	29c96 <at_interface_read+0x46>
   29c7a:	e028      	b.n	29cce <at_interface_read+0x7e>
   29c7c:	b9cd      	cbnz	r5, 29cb2 <at_interface_read+0x62>
   29c7e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   29c82:	6a23      	ldr	r3, [r4, #32]
   29c84:	4611      	mov	r1, r2
   29c86:	2b00      	cmp	r3, #0
   29c88:	bf08      	it	eq
   29c8a:	f04f 33ff 	moveq.w	r3, #4294967295
   29c8e:	4638      	mov	r0, r7
   29c90:	f005 fd32 	bl	2f6f8 <interface_socket_wait>
   29c94:	4605      	mov	r5, r0
   29c96:	6823      	ldr	r3, [r4, #0]
   29c98:	69e0      	ldr	r0, [r4, #28]
   29c9a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   29c9e:	6023      	str	r3, [r4, #0]
   29ca0:	6803      	ldr	r3, [r0, #0]
   29ca2:	4632      	mov	r2, r6
   29ca4:	689b      	ldr	r3, [r3, #8]
   29ca6:	4669      	mov	r1, sp
   29ca8:	4798      	blx	r3
   29caa:	f1b0 0800 	subs.w	r8, r0, #0
   29cae:	dbe5      	blt.n	29c7c <at_interface_read+0x2c>
   29cb0:	b115      	cbz	r5, 29cb8 <at_interface_read+0x68>
   29cb2:	4628      	mov	r0, r5
   29cb4:	f7fd fed4 	bl	27a60 <bsd_os_errno_set>
   29cb8:	4640      	mov	r0, r8
   29cba:	b004      	add	sp, #16
   29cbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   29cc0:	f016 0f0a 	tst.w	r6, #10
   29cc4:	d1d6      	bne.n	29c74 <at_interface_read+0x24>
   29cc6:	252d      	movs	r5, #45	; 0x2d
   29cc8:	f04f 38ff 	mov.w	r8, #4294967295
   29ccc:	e7f1      	b.n	29cb2 <at_interface_read+0x62>
   29cce:	6823      	ldr	r3, [r4, #0]
   29cd0:	69e0      	ldr	r0, [r4, #28]
   29cd2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   29cd6:	6023      	str	r3, [r4, #0]
   29cd8:	6803      	ldr	r3, [r0, #0]
   29cda:	4632      	mov	r2, r6
   29cdc:	689b      	ldr	r3, [r3, #8]
   29cde:	4669      	mov	r1, sp
   29ce0:	4798      	blx	r3
   29ce2:	f1b0 3fff 	cmp.w	r0, #4294967295
   29ce6:	4680      	mov	r8, r0
   29ce8:	d1e6      	bne.n	29cb8 <at_interface_read+0x68>
   29cea:	2523      	movs	r5, #35	; 0x23
   29cec:	e7e1      	b.n	29cb2 <at_interface_read+0x62>
   29cee:	2516      	movs	r5, #22
   29cf0:	f04f 38ff 	mov.w	r8, #4294967295
   29cf4:	e7dd      	b.n	29cb2 <at_interface_read+0x62>
   29cf6:	bf00      	nop

00029cf8 <at_interface_getopt>:
   29cf8:	f005 bddc 	b.w	2f8b4 <interface_socket_getopt>

00029cfc <at_interface_setopt>:
   29cfc:	f005 bd98 	b.w	2f830 <interface_socket_setopt>

00029d00 <rpc_at_event_handler>:
   29d00:	b570      	push	{r4, r5, r6, lr}
   29d02:	4606      	mov	r6, r0
   29d04:	b084      	sub	sp, #16
   29d06:	68c0      	ldr	r0, [r0, #12]
   29d08:	460d      	mov	r5, r1
   29d0a:	f005 fd69 	bl	2f7e0 <interface_socket_from_handle_get>
   29d0e:	4604      	mov	r4, r0
   29d10:	b348      	cbz	r0, 29d66 <rpc_at_event_handler+0x66>
   29d12:	6803      	ldr	r3, [r0, #0]
   29d14:	b29b      	uxth	r3, r3
   29d16:	2b01      	cmp	r3, #1
   29d18:	d01f      	beq.n	29d5a <rpc_at_event_handler+0x5a>
   29d1a:	6803      	ldr	r3, [r0, #0]
   29d1c:	b29b      	uxth	r3, r3
   29d1e:	2b0d      	cmp	r3, #13
   29d20:	d029      	beq.n	29d76 <rpc_at_event_handler+0x76>
   29d22:	6803      	ldr	r3, [r0, #0]
   29d24:	b29b      	uxth	r3, r3
   29d26:	2b02      	cmp	r3, #2
   29d28:	d02d      	beq.n	29d86 <rpc_at_event_handler+0x86>
   29d2a:	3d03      	subs	r5, #3
   29d2c:	2d01      	cmp	r5, #1
   29d2e:	d817      	bhi.n	29d60 <rpc_at_event_handler+0x60>
   29d30:	2500      	movs	r5, #0
   29d32:	6873      	ldr	r3, [r6, #4]
   29d34:	6832      	ldr	r2, [r6, #0]
   29d36:	e9cd 5502 	strd	r5, r5, [sp, #8]
   29d3a:	e9cd 2300 	strd	r2, r3, [sp]
   29d3e:	69e0      	ldr	r0, [r4, #28]
   29d40:	4669      	mov	r1, sp
   29d42:	6803      	ldr	r3, [r0, #0]
   29d44:	685b      	ldr	r3, [r3, #4]
   29d46:	4798      	blx	r3
   29d48:	3001      	adds	r0, #1
   29d4a:	d019      	beq.n	29d80 <rpc_at_event_handler+0x80>
   29d4c:	4628      	mov	r0, r5
   29d4e:	6823      	ldr	r3, [r4, #0]
   29d50:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   29d54:	6023      	str	r3, [r4, #0]
   29d56:	b004      	add	sp, #16
   29d58:	bd70      	pop	{r4, r5, r6, pc}
   29d5a:	2d02      	cmp	r5, #2
   29d5c:	d1e5      	bne.n	29d2a <rpc_at_event_handler+0x2a>
   29d5e:	6005      	str	r5, [r0, #0]
   29d60:	2000      	movs	r0, #0
   29d62:	b004      	add	sp, #16
   29d64:	bd70      	pop	{r4, r5, r6, pc}
   29d66:	6830      	ldr	r0, [r6, #0]
   29d68:	2800      	cmp	r0, #0
   29d6a:	d0f9      	beq.n	29d60 <rpc_at_event_handler+0x60>
   29d6c:	f004 f85a 	bl	2de24 <rpc_at_client_data_free>
   29d70:	4620      	mov	r0, r4
   29d72:	b004      	add	sp, #16
   29d74:	bd70      	pop	{r4, r5, r6, pc}
   29d76:	2d02      	cmp	r5, #2
   29d78:	d1d7      	bne.n	29d2a <rpc_at_event_handler+0x2a>
   29d7a:	230e      	movs	r3, #14
   29d7c:	6003      	str	r3, [r0, #0]
   29d7e:	e7ef      	b.n	29d60 <rpc_at_event_handler+0x60>
   29d80:	2002      	movs	r0, #2
   29d82:	b004      	add	sp, #16
   29d84:	bd70      	pop	{r4, r5, r6, pc}
   29d86:	6803      	ldr	r3, [r0, #0]
   29d88:	029b      	lsls	r3, r3, #10
   29d8a:	d5ce      	bpl.n	29d2a <rpc_at_event_handler+0x2a>
   29d8c:	2d02      	cmp	r5, #2
   29d8e:	d1cc      	bne.n	29d2a <rpc_at_event_handler+0x2a>
   29d90:	6803      	ldr	r3, [r0, #0]
   29d92:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   29d96:	6003      	str	r3, [r0, #0]
   29d98:	6803      	ldr	r3, [r0, #0]
   29d9a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   29d9e:	6003      	str	r3, [r0, #0]
   29da0:	e7de      	b.n	29d60 <rpc_at_event_handler+0x60>
   29da2:	bf00      	nop

00029da4 <dfu_client_event_handler>:
   29da4:	f850 1b08 	ldr.w	r1, [r0], #8
   29da8:	0c09      	lsrs	r1, r1, #16
   29daa:	f001 b925 	b.w	2aff8 <rpc_dfu_event_handler>
   29dae:	bf00      	nop

00029db0 <rpc_dfu_client_init>:
   29db0:	4801      	ldr	r0, [pc, #4]	; (29db8 <rpc_dfu_client_init+0x8>)
   29db2:	f005 be51 	b.w	2fa58 <rpc_client_register>
   29db6:	bf00      	nop
   29db8:	0003b524 	.word	0x0003b524

00029dbc <rpc_dfu_client_request_alloc>:
   29dbc:	2300      	movs	r3, #0
   29dbe:	b510      	push	{r4, lr}
   29dc0:	b082      	sub	sp, #8
   29dc2:	9301      	str	r3, [sp, #4]
   29dc4:	b158      	cbz	r0, 29dde <rpc_dfu_client_request_alloc+0x22>
   29dc6:	4604      	mov	r4, r0
   29dc8:	aa01      	add	r2, sp, #4
   29dca:	2006      	movs	r0, #6
   29dcc:	f006 f87c 	bl	2fec8 <rpc_message_alloc>
   29dd0:	b918      	cbnz	r0, 29dda <rpc_dfu_client_request_alloc+0x1e>
   29dd2:	9b01      	ldr	r3, [sp, #4]
   29dd4:	b10b      	cbz	r3, 29dda <rpc_dfu_client_request_alloc+0x1e>
   29dd6:	3308      	adds	r3, #8
   29dd8:	6023      	str	r3, [r4, #0]
   29dda:	b002      	add	sp, #8
   29ddc:	bd10      	pop	{r4, pc}
   29dde:	2007      	movs	r0, #7
   29de0:	b002      	add	sp, #8
   29de2:	bd10      	pop	{r4, pc}

00029de4 <rpc_dfu_client_request_send>:
   29de4:	f411 4f70 	tst.w	r1, #61440	; 0xf000
   29de8:	d10b      	bne.n	29e02 <rpc_dfu_client_request_send+0x1e>
   29dea:	b160      	cbz	r0, 29e06 <rpc_dfu_client_request_send+0x22>
   29dec:	4603      	mov	r3, r0
   29dee:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   29df2:	2006      	movs	r0, #6
   29df4:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   29df8:	f843 1d08 	str.w	r1, [r3, #-8]!
   29dfc:	4619      	mov	r1, r3
   29dfe:	f006 b84b 	b.w	2fe98 <rpc_message_send>
   29e02:	200f      	movs	r0, #15
   29e04:	4770      	bx	lr
   29e06:	2007      	movs	r0, #7
   29e08:	4770      	bx	lr
   29e0a:	bf00      	nop

00029e0c <rpc_dfu_client_message_free>:
   29e0c:	b120      	cbz	r0, 29e18 <rpc_dfu_client_message_free+0xc>
   29e0e:	f1a0 0108 	sub.w	r1, r0, #8
   29e12:	2006      	movs	r0, #6
   29e14:	f006 b88a 	b.w	2ff2c <rpc_message_free>
   29e18:	2007      	movs	r0, #7
   29e1a:	4770      	bx	lr

00029e1c <rpc_dfu_client_data_free>:
   29e1c:	b118      	cbz	r0, 29e26 <rpc_dfu_client_data_free+0xa>
   29e1e:	4601      	mov	r1, r0
   29e20:	2006      	movs	r0, #6
   29e22:	f006 b995 	b.w	30150 <rpc_message_data_free>
   29e26:	2007      	movs	r0, #7
   29e28:	4770      	bx	lr
   29e2a:	bf00      	nop

00029e2c <mem_free>:
   29e2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   29e30:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 29f00 <mem_free+0xd4>
   29e34:	b083      	sub	sp, #12
   29e36:	9000      	str	r0, [sp, #0]
   29e38:	f10c 0b3c 	add.w	fp, ip, #60	; 0x3c
   29e3c:	f8dc 3008 	ldr.w	r3, [ip, #8]
   29e40:	b12b      	cbz	r3, 29e4e <mem_free+0x22>
   29e42:	f8dc 2000 	ldr.w	r2, [ip]
   29e46:	9c00      	ldr	r4, [sp, #0]
   29e48:	7810      	ldrb	r0, [r2, #0]
   29e4a:	42a0      	cmp	r0, r4
   29e4c:	d006      	beq.n	29e5c <mem_free+0x30>
   29e4e:	f10c 0c0c 	add.w	ip, ip, #12
   29e52:	45e3      	cmp	fp, ip
   29e54:	d1f2      	bne.n	29e3c <mem_free+0x10>
   29e56:	b003      	add	sp, #12
   29e58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   29e5c:	f8dc a004 	ldr.w	sl, [ip, #4]
   29e60:	eb03 080a 	add.w	r8, r3, sl
   29e64:	45c2      	cmp	sl, r8
   29e66:	d2f2      	bcs.n	29e4e <mem_free+0x22>
   29e68:	6853      	ldr	r3, [r2, #4]
   29e6a:	f8cd c004 	str.w	ip, [sp, #4]
   29e6e:	46d6      	mov	lr, sl
   29e70:	469c      	mov	ip, r3
   29e72:	f8d2 9010 	ldr.w	r9, [r2, #16]
   29e76:	8997      	ldrh	r7, [r2, #12]
   29e78:	ebae 000a 	sub.w	r0, lr, sl
   29e7c:	b3df      	cbz	r7, 29ef6 <mem_free+0xca>
   29e7e:	f8b9 2002 	ldrh.w	r2, [r9, #2]
   29e82:	4290      	cmp	r0, r2
   29e84:	d31c      	bcc.n	29ec0 <mem_free+0x94>
   29e86:	4665      	mov	r5, ip
   29e88:	2400      	movs	r4, #0
   29e8a:	f109 0304 	add.w	r3, r9, #4
   29e8e:	e003      	b.n	29e98 <mem_free+0x6c>
   29e90:	885a      	ldrh	r2, [r3, #2]
   29e92:	3304      	adds	r3, #4
   29e94:	4282      	cmp	r2, r0
   29e96:	d815      	bhi.n	29ec4 <mem_free+0x98>
   29e98:	f833 6c04 	ldrh.w	r6, [r3, #-4]
   29e9c:	3401      	adds	r4, #1
   29e9e:	42a7      	cmp	r7, r4
   29ea0:	fb02 5506 	mla	r5, r2, r6, r5
   29ea4:	eba0 0002 	sub.w	r0, r0, r2
   29ea8:	461e      	mov	r6, r3
   29eaa:	d1f1      	bne.n	29e90 <mem_free+0x64>
   29eac:	2000      	movs	r0, #0
   29eae:	4281      	cmp	r1, r0
   29eb0:	d00d      	beq.n	29ece <mem_free+0xa2>
   29eb2:	f10e 0e01 	add.w	lr, lr, #1
   29eb6:	45f0      	cmp	r8, lr
   29eb8:	d1de      	bne.n	29e78 <mem_free+0x4c>
   29eba:	f8dd c004 	ldr.w	ip, [sp, #4]
   29ebe:	e7c6      	b.n	29e4e <mem_free+0x22>
   29ec0:	4665      	mov	r5, ip
   29ec2:	464e      	mov	r6, r9
   29ec4:	8833      	ldrh	r3, [r6, #0]
   29ec6:	fb00 5003 	mla	r0, r0, r3, r5
   29eca:	4281      	cmp	r1, r0
   29ecc:	d1f1      	bne.n	29eb2 <mem_free+0x86>
   29ece:	f5be 7f00 	cmp.w	lr, #512	; 0x200
   29ed2:	f8dd c004 	ldr.w	ip, [sp, #4]
   29ed6:	d0ba      	beq.n	29e4e <mem_free+0x22>
   29ed8:	2301      	movs	r3, #1
   29eda:	4a08      	ldr	r2, [pc, #32]	; (29efc <mem_free+0xd0>)
   29edc:	ea4f 115e 	mov.w	r1, lr, lsr #5
   29ee0:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
   29ee4:	f00e 0e1f 	and.w	lr, lr, #31
   29ee8:	fa03 fe0e 	lsl.w	lr, r3, lr
   29eec:	ea4e 0000 	orr.w	r0, lr, r0
   29ef0:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
   29ef4:	e7af      	b.n	29e56 <mem_free+0x2a>
   29ef6:	4638      	mov	r0, r7
   29ef8:	e7d9      	b.n	29eae <mem_free+0x82>
   29efa:	bf00      	nop
   29efc:	20020810 	.word	0x20020810
   29f00:	20020854 	.word	0x20020854

00029f04 <mem_alloc.constprop.5>:
   29f04:	2800      	cmp	r0, #0
   29f06:	d050      	beq.n	29faa <mem_alloc.constprop.5+0xa6>
   29f08:	4b6d      	ldr	r3, [pc, #436]	; (2a0c0 <mem_alloc.constprop.5+0x1bc>)
   29f0a:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   29f0e:	4290      	cmp	r0, r2
   29f10:	d84b      	bhi.n	29faa <mem_alloc.constprop.5+0xa6>
   29f12:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   29f16:	f8d3 b08c 	ldr.w	fp, [r3, #140]	; 0x8c
   29f1a:	b083      	sub	sp, #12
   29f1c:	f1bb 0f00 	cmp.w	fp, #0
   29f20:	d054      	beq.n	29fcc <mem_alloc.constprop.5+0xc8>
   29f22:	f10b 32ff 	add.w	r2, fp, #4294967295
   29f26:	4691      	mov	r9, r2
   29f28:	2600      	movs	r6, #0
   29f2a:	f04f 0812 	mov.w	r8, #18
   29f2e:	4f65      	ldr	r7, [pc, #404]	; (2a0c4 <mem_alloc.constprop.5+0x1c0>)
   29f30:	9201      	str	r2, [sp, #4]
   29f32:	f10b 0e11 	add.w	lr, fp, #17
   29f36:	eb06 0209 	add.w	r2, r6, r9
   29f3a:	f853 4038 	ldr.w	r4, [r3, r8, lsl #3]
   29f3e:	3201      	adds	r2, #1
   29f40:	0852      	lsrs	r2, r2, #1
   29f42:	eb04 0c44 	add.w	ip, r4, r4, lsl #1
   29f46:	f102 0112 	add.w	r1, r2, #18
   29f4a:	f853 5031 	ldr.w	r5, [r3, r1, lsl #3]
   29f4e:	f857 a02c 	ldr.w	sl, [r7, ip, lsl #2]
   29f52:	f853 403e 	ldr.w	r4, [r3, lr, lsl #3]
   29f56:	eb03 0cc8 	add.w	ip, r3, r8, lsl #3
   29f5a:	f8dc c004 	ldr.w	ip, [ip, #4]
   29f5e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   29f62:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   29f66:	f8da a010 	ldr.w	sl, [sl, #16]
   29f6a:	f857 5025 	ldr.w	r5, [r7, r5, lsl #2]
   29f6e:	f857 4024 	ldr.w	r4, [r7, r4, lsl #2]
   29f72:	f83a a02c 	ldrh.w	sl, [sl, ip, lsl #2]
   29f76:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   29f7a:	eb03 0cce 	add.w	ip, r3, lr, lsl #3
   29f7e:	6849      	ldr	r1, [r1, #4]
   29f80:	692d      	ldr	r5, [r5, #16]
   29f82:	6924      	ldr	r4, [r4, #16]
   29f84:	f8dc c004 	ldr.w	ip, [ip, #4]
   29f88:	4550      	cmp	r0, sl
   29f8a:	f835 5021 	ldrh.w	r5, [r5, r1, lsl #2]
   29f8e:	f834 102c 	ldrh.w	r1, [r4, ip, lsl #2]
   29f92:	d915      	bls.n	29fc0 <mem_alloc.constprop.5+0xbc>
   29f94:	4288      	cmp	r0, r1
   29f96:	d211      	bcs.n	29fbc <mem_alloc.constprop.5+0xb8>
   29f98:	42a8      	cmp	r0, r5
   29f9a:	d908      	bls.n	29fae <mem_alloc.constprop.5+0xaa>
   29f9c:	1c56      	adds	r6, r2, #1
   29f9e:	45b1      	cmp	r9, r6
   29fa0:	f0c0 8087 	bcc.w	2a0b2 <mem_alloc.constprop.5+0x1ae>
   29fa4:	f102 0813 	add.w	r8, r2, #19
   29fa8:	e7c5      	b.n	29f36 <mem_alloc.constprop.5+0x32>
   29faa:	2000      	movs	r0, #0
   29fac:	4770      	bx	lr
   29fae:	f102 39ff 	add.w	r9, r2, #4294967295
   29fb2:	454e      	cmp	r6, r9
   29fb4:	d87d      	bhi.n	2a0b2 <mem_alloc.constprop.5+0x1ae>
   29fb6:	f102 0e11 	add.w	lr, r2, #17
   29fba:	e7bc      	b.n	29f36 <mem_alloc.constprop.5+0x32>
   29fbc:	f109 0601 	add.w	r6, r9, #1
   29fc0:	45b3      	cmp	fp, r6
   29fc2:	d007      	beq.n	29fd4 <mem_alloc.constprop.5+0xd0>
   29fc4:	2e10      	cmp	r6, #16
   29fc6:	d001      	beq.n	29fcc <mem_alloc.constprop.5+0xc8>
   29fc8:	45b3      	cmp	fp, r6
   29fca:	d808      	bhi.n	29fde <mem_alloc.constprop.5+0xda>
   29fcc:	2000      	movs	r0, #0
   29fce:	b003      	add	sp, #12
   29fd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   29fd4:	9a01      	ldr	r2, [sp, #4]
   29fd6:	2a10      	cmp	r2, #16
   29fd8:	bf18      	it	ne
   29fda:	4616      	movne	r6, r2
   29fdc:	d0f6      	beq.n	29fcc <mem_alloc.constprop.5+0xc8>
   29fde:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 2a0c8 <mem_alloc.constprop.5+0x1c4>
   29fe2:	eb03 08c6 	add.w	r8, r3, r6, lsl #3
   29fe6:	e9d8 2424 	ldrd	r2, r4, [r8, #144]	; 0x90
   29fea:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   29fee:	f857 3022 	ldr.w	r3, [r7, r2, lsl #2]
   29ff2:	eb07 0282 	add.w	r2, r7, r2, lsl #2
   29ff6:	f8d2 e004 	ldr.w	lr, [r2, #4]
   29ffa:	691d      	ldr	r5, [r3, #16]
   29ffc:	2c00      	cmp	r4, #0
   29ffe:	d056      	beq.n	2a0ae <mem_alloc.constprop.5+0x1aa>
   2a000:	462a      	mov	r2, r5
   2a002:	4670      	mov	r0, lr
   2a004:	00a4      	lsls	r4, r4, #2
   2a006:	eb05 0904 	add.w	r9, r5, r4
   2a00a:	8851      	ldrh	r1, [r2, #2]
   2a00c:	3204      	adds	r2, #4
   2a00e:	4591      	cmp	r9, r2
   2a010:	4408      	add	r0, r1
   2a012:	d1fa      	bne.n	2a00a <mem_alloc.constprop.5+0x106>
   2a014:	1929      	adds	r1, r5, r4
   2a016:	f8b1 a002 	ldrh.w	sl, [r1, #2]
   2a01a:	4482      	add	sl, r0
   2a01c:	4582      	cmp	sl, r0
   2a01e:	d918      	bls.n	2a052 <mem_alloc.constprop.5+0x14e>
   2a020:	0941      	lsrs	r1, r0, #5
   2a022:	f85c 2021 	ldr.w	r2, [ip, r1, lsl #2]
   2a026:	f000 041f 	and.w	r4, r0, #31
   2a02a:	fa22 f904 	lsr.w	r9, r2, r4
   2a02e:	f019 0f01 	tst.w	r9, #1
   2a032:	d007      	beq.n	2a044 <mem_alloc.constprop.5+0x140>
   2a034:	e013      	b.n	2a05e <mem_alloc.constprop.5+0x15a>
   2a036:	f85c 2021 	ldr.w	r2, [ip, r1, lsl #2]
   2a03a:	fa22 f904 	lsr.w	r9, r2, r4
   2a03e:	f019 0f01 	tst.w	r9, #1
   2a042:	d10c      	bne.n	2a05e <mem_alloc.constprop.5+0x15a>
   2a044:	3001      	adds	r0, #1
   2a046:	4582      	cmp	sl, r0
   2a048:	ea4f 1150 	mov.w	r1, r0, lsr #5
   2a04c:	f000 041f 	and.w	r4, r0, #31
   2a050:	d1f1      	bne.n	2a036 <mem_alloc.constprop.5+0x132>
   2a052:	3601      	adds	r6, #1
   2a054:	455e      	cmp	r6, fp
   2a056:	f108 0808 	add.w	r8, r8, #8
   2a05a:	d3c4      	bcc.n	29fe6 <mem_alloc.constprop.5+0xe2>
   2a05c:	e7b6      	b.n	29fcc <mem_alloc.constprop.5+0xc8>
   2a05e:	2601      	movs	r6, #1
   2a060:	fa06 f404 	lsl.w	r4, r6, r4
   2a064:	899e      	ldrh	r6, [r3, #12]
   2a066:	ea22 0204 	bic.w	r2, r2, r4
   2a06a:	eba0 000e 	sub.w	r0, r0, lr
   2a06e:	f84c 2021 	str.w	r2, [ip, r1, lsl #2]
   2a072:	685c      	ldr	r4, [r3, #4]
   2a074:	2e00      	cmp	r6, #0
   2a076:	d0a9      	beq.n	29fcc <mem_alloc.constprop.5+0xc8>
   2a078:	886a      	ldrh	r2, [r5, #2]
   2a07a:	4282      	cmp	r2, r0
   2a07c:	d811      	bhi.n	2a0a2 <mem_alloc.constprop.5+0x19e>
   2a07e:	2100      	movs	r1, #0
   2a080:	1d2b      	adds	r3, r5, #4
   2a082:	e003      	b.n	2a08c <mem_alloc.constprop.5+0x188>
   2a084:	885a      	ldrh	r2, [r3, #2]
   2a086:	3304      	adds	r3, #4
   2a088:	4282      	cmp	r2, r0
   2a08a:	d80a      	bhi.n	2a0a2 <mem_alloc.constprop.5+0x19e>
   2a08c:	f833 5c04 	ldrh.w	r5, [r3, #-4]
   2a090:	3101      	adds	r1, #1
   2a092:	428e      	cmp	r6, r1
   2a094:	fb02 4405 	mla	r4, r2, r5, r4
   2a098:	eba0 0002 	sub.w	r0, r0, r2
   2a09c:	461d      	mov	r5, r3
   2a09e:	d1f1      	bne.n	2a084 <mem_alloc.constprop.5+0x180>
   2a0a0:	e794      	b.n	29fcc <mem_alloc.constprop.5+0xc8>
   2a0a2:	882b      	ldrh	r3, [r5, #0]
   2a0a4:	fb00 4003 	mla	r0, r0, r3, r4
   2a0a8:	b003      	add	sp, #12
   2a0aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2a0ae:	4670      	mov	r0, lr
   2a0b0:	e7b0      	b.n	2a014 <mem_alloc.constprop.5+0x110>
   2a0b2:	f1bb 0f10 	cmp.w	fp, #16
   2a0b6:	bf08      	it	eq
   2a0b8:	260f      	moveq	r6, #15
   2a0ba:	d090      	beq.n	29fde <mem_alloc.constprop.5+0xda>
   2a0bc:	e786      	b.n	29fcc <mem_alloc.constprop.5+0xc8>
   2a0be:	bf00      	nop
   2a0c0:	20020890 	.word	0x20020890
   2a0c4:	20020854 	.word	0x20020854
   2a0c8:	20020810 	.word	0x20020810

0002a0cc <mem_alloc.constprop.4>:
   2a0cc:	2800      	cmp	r0, #0
   2a0ce:	d04c      	beq.n	2a16a <mem_alloc.constprop.4+0x9e>
   2a0d0:	4b6b      	ldr	r3, [pc, #428]	; (2a280 <mem_alloc.constprop.4+0x1b4>)
   2a0d2:	681a      	ldr	r2, [r3, #0]
   2a0d4:	4290      	cmp	r0, r2
   2a0d6:	d848      	bhi.n	2a16a <mem_alloc.constprop.4+0x9e>
   2a0d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2a0dc:	685f      	ldr	r7, [r3, #4]
   2a0de:	b083      	sub	sp, #12
   2a0e0:	9700      	str	r7, [sp, #0]
   2a0e2:	2f00      	cmp	r7, #0
   2a0e4:	d051      	beq.n	2a18a <mem_alloc.constprop.4+0xbe>
   2a0e6:	1e7a      	subs	r2, r7, #1
   2a0e8:	4696      	mov	lr, r2
   2a0ea:	2100      	movs	r1, #0
   2a0ec:	f04f 0c01 	mov.w	ip, #1
   2a0f0:	4c64      	ldr	r4, [pc, #400]	; (2a284 <mem_alloc.constprop.4+0x1b8>)
   2a0f2:	9201      	str	r2, [sp, #4]
   2a0f4:	eb01 020e 	add.w	r2, r1, lr
   2a0f8:	3201      	adds	r2, #1
   2a0fa:	f853 503c 	ldr.w	r5, [r3, ip, lsl #3]
   2a0fe:	0852      	lsrs	r2, r2, #1
   2a100:	f102 0801 	add.w	r8, r2, #1
   2a104:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   2a108:	f853 9037 	ldr.w	r9, [r3, r7, lsl #3]
   2a10c:	f854 a025 	ldr.w	sl, [r4, r5, lsl #2]
   2a110:	f853 6038 	ldr.w	r6, [r3, r8, lsl #3]
   2a114:	eb09 0549 	add.w	r5, r9, r9, lsl #1
   2a118:	eb03 09cc 	add.w	r9, r3, ip, lsl #3
   2a11c:	f8d9 9004 	ldr.w	r9, [r9, #4]
   2a120:	eb06 0646 	add.w	r6, r6, r6, lsl #1
   2a124:	f8da a010 	ldr.w	sl, [sl, #16]
   2a128:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
   2a12c:	f854 5025 	ldr.w	r5, [r4, r5, lsl #2]
   2a130:	f83a a029 	ldrh.w	sl, [sl, r9, lsl #2]
   2a134:	eb03 0bc8 	add.w	fp, r3, r8, lsl #3
   2a138:	eb03 09c7 	add.w	r9, r3, r7, lsl #3
   2a13c:	6936      	ldr	r6, [r6, #16]
   2a13e:	f8db b004 	ldr.w	fp, [fp, #4]
   2a142:	692d      	ldr	r5, [r5, #16]
   2a144:	f8d9 9004 	ldr.w	r9, [r9, #4]
   2a148:	4550      	cmp	r0, sl
   2a14a:	f836 602b 	ldrh.w	r6, [r6, fp, lsl #2]
   2a14e:	f835 5029 	ldrh.w	r5, [r5, r9, lsl #2]
   2a152:	d913      	bls.n	2a17c <mem_alloc.constprop.4+0xb0>
   2a154:	42a8      	cmp	r0, r5
   2a156:	d210      	bcs.n	2a17a <mem_alloc.constprop.4+0xae>
   2a158:	42b0      	cmp	r0, r6
   2a15a:	d908      	bls.n	2a16e <mem_alloc.constprop.4+0xa2>
   2a15c:	45c6      	cmp	lr, r8
   2a15e:	4641      	mov	r1, r8
   2a160:	f0c0 8087 	bcc.w	2a272 <mem_alloc.constprop.4+0x1a6>
   2a164:	f108 0c01 	add.w	ip, r8, #1
   2a168:	e7c4      	b.n	2a0f4 <mem_alloc.constprop.4+0x28>
   2a16a:	2000      	movs	r0, #0
   2a16c:	4770      	bx	lr
   2a16e:	f102 3eff 	add.w	lr, r2, #4294967295
   2a172:	4571      	cmp	r1, lr
   2a174:	d87d      	bhi.n	2a272 <mem_alloc.constprop.4+0x1a6>
   2a176:	4617      	mov	r7, r2
   2a178:	e7bc      	b.n	2a0f4 <mem_alloc.constprop.4+0x28>
   2a17a:	4639      	mov	r1, r7
   2a17c:	9a00      	ldr	r2, [sp, #0]
   2a17e:	428a      	cmp	r2, r1
   2a180:	d007      	beq.n	2a192 <mem_alloc.constprop.4+0xc6>
   2a182:	2910      	cmp	r1, #16
   2a184:	d001      	beq.n	2a18a <mem_alloc.constprop.4+0xbe>
   2a186:	428a      	cmp	r2, r1
   2a188:	d808      	bhi.n	2a19c <mem_alloc.constprop.4+0xd0>
   2a18a:	2000      	movs	r0, #0
   2a18c:	b003      	add	sp, #12
   2a18e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2a192:	9a01      	ldr	r2, [sp, #4]
   2a194:	2a10      	cmp	r2, #16
   2a196:	bf18      	it	ne
   2a198:	4611      	movne	r1, r2
   2a19a:	d0f6      	beq.n	2a18a <mem_alloc.constprop.4+0xbe>
   2a19c:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 2a288 <mem_alloc.constprop.4+0x1bc>
   2a1a0:	f8dd 9000 	ldr.w	r9, [sp]
   2a1a4:	eb03 08c1 	add.w	r8, r3, r1, lsl #3
   2a1a8:	e9d8 2602 	ldrd	r2, r6, [r8, #8]
   2a1ac:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   2a1b0:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
   2a1b4:	eb04 0282 	add.w	r2, r4, r2, lsl #2
   2a1b8:	f8d2 e004 	ldr.w	lr, [r2, #4]
   2a1bc:	691f      	ldr	r7, [r3, #16]
   2a1be:	2e00      	cmp	r6, #0
   2a1c0:	d055      	beq.n	2a26e <mem_alloc.constprop.4+0x1a2>
   2a1c2:	463a      	mov	r2, r7
   2a1c4:	4670      	mov	r0, lr
   2a1c6:	00b6      	lsls	r6, r6, #2
   2a1c8:	eb07 0a06 	add.w	sl, r7, r6
   2a1cc:	8855      	ldrh	r5, [r2, #2]
   2a1ce:	3204      	adds	r2, #4
   2a1d0:	4592      	cmp	sl, r2
   2a1d2:	4428      	add	r0, r5
   2a1d4:	d1fa      	bne.n	2a1cc <mem_alloc.constprop.4+0x100>
   2a1d6:	19bd      	adds	r5, r7, r6
   2a1d8:	f8b5 b002 	ldrh.w	fp, [r5, #2]
   2a1dc:	4483      	add	fp, r0
   2a1de:	4583      	cmp	fp, r0
   2a1e0:	d918      	bls.n	2a214 <mem_alloc.constprop.4+0x148>
   2a1e2:	0945      	lsrs	r5, r0, #5
   2a1e4:	f85c 2025 	ldr.w	r2, [ip, r5, lsl #2]
   2a1e8:	f000 061f 	and.w	r6, r0, #31
   2a1ec:	fa22 fa06 	lsr.w	sl, r2, r6
   2a1f0:	f01a 0f01 	tst.w	sl, #1
   2a1f4:	d007      	beq.n	2a206 <mem_alloc.constprop.4+0x13a>
   2a1f6:	e013      	b.n	2a220 <mem_alloc.constprop.4+0x154>
   2a1f8:	f85c 2025 	ldr.w	r2, [ip, r5, lsl #2]
   2a1fc:	fa22 fa06 	lsr.w	sl, r2, r6
   2a200:	f01a 0f01 	tst.w	sl, #1
   2a204:	d10c      	bne.n	2a220 <mem_alloc.constprop.4+0x154>
   2a206:	3001      	adds	r0, #1
   2a208:	4583      	cmp	fp, r0
   2a20a:	ea4f 1550 	mov.w	r5, r0, lsr #5
   2a20e:	f000 061f 	and.w	r6, r0, #31
   2a212:	d1f1      	bne.n	2a1f8 <mem_alloc.constprop.4+0x12c>
   2a214:	3101      	adds	r1, #1
   2a216:	4549      	cmp	r1, r9
   2a218:	f108 0808 	add.w	r8, r8, #8
   2a21c:	d3c4      	bcc.n	2a1a8 <mem_alloc.constprop.4+0xdc>
   2a21e:	e7b4      	b.n	2a18a <mem_alloc.constprop.4+0xbe>
   2a220:	2101      	movs	r1, #1
   2a222:	40b1      	lsls	r1, r6
   2a224:	899e      	ldrh	r6, [r3, #12]
   2a226:	ea22 0201 	bic.w	r2, r2, r1
   2a22a:	eba0 000e 	sub.w	r0, r0, lr
   2a22e:	f84c 2025 	str.w	r2, [ip, r5, lsl #2]
   2a232:	685c      	ldr	r4, [r3, #4]
   2a234:	2e00      	cmp	r6, #0
   2a236:	d0a8      	beq.n	2a18a <mem_alloc.constprop.4+0xbe>
   2a238:	887a      	ldrh	r2, [r7, #2]
   2a23a:	4282      	cmp	r2, r0
   2a23c:	d811      	bhi.n	2a262 <mem_alloc.constprop.4+0x196>
   2a23e:	2100      	movs	r1, #0
   2a240:	1d3b      	adds	r3, r7, #4
   2a242:	e003      	b.n	2a24c <mem_alloc.constprop.4+0x180>
   2a244:	885a      	ldrh	r2, [r3, #2]
   2a246:	3304      	adds	r3, #4
   2a248:	4282      	cmp	r2, r0
   2a24a:	d80a      	bhi.n	2a262 <mem_alloc.constprop.4+0x196>
   2a24c:	f833 5c04 	ldrh.w	r5, [r3, #-4]
   2a250:	3101      	adds	r1, #1
   2a252:	428e      	cmp	r6, r1
   2a254:	eba0 0002 	sub.w	r0, r0, r2
   2a258:	fb02 4405 	mla	r4, r2, r5, r4
   2a25c:	461f      	mov	r7, r3
   2a25e:	d1f1      	bne.n	2a244 <mem_alloc.constprop.4+0x178>
   2a260:	e793      	b.n	2a18a <mem_alloc.constprop.4+0xbe>
   2a262:	883b      	ldrh	r3, [r7, #0]
   2a264:	fb00 4003 	mla	r0, r0, r3, r4
   2a268:	b003      	add	sp, #12
   2a26a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2a26e:	4670      	mov	r0, lr
   2a270:	e7b1      	b.n	2a1d6 <mem_alloc.constprop.4+0x10a>
   2a272:	9a00      	ldr	r2, [sp, #0]
   2a274:	2a10      	cmp	r2, #16
   2a276:	bf08      	it	eq
   2a278:	210f      	moveq	r1, #15
   2a27a:	d08f      	beq.n	2a19c <mem_alloc.constprop.4+0xd0>
   2a27c:	e785      	b.n	2a18a <mem_alloc.constprop.4+0xbe>
   2a27e:	bf00      	nop
   2a280:	20020890 	.word	0x20020890
   2a284:	20020854 	.word	0x20020854
   2a288:	20020810 	.word	0x20020810

0002a28c <nrf_mem_init>:
   2a28c:	b570      	push	{r4, r5, r6, lr}
   2a28e:	2200      	movs	r2, #0
   2a290:	2501      	movs	r5, #1
   2a292:	4833      	ldr	r0, [pc, #204]	; (2a360 <nrf_mem_init+0xd4>)
   2a294:	0951      	lsrs	r1, r2, #5
   2a296:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
   2a29a:	f002 031f 	and.w	r3, r2, #31
   2a29e:	fa05 f303 	lsl.w	r3, r5, r3
   2a2a2:	3201      	adds	r2, #1
   2a2a4:	4323      	orrs	r3, r4
   2a2a6:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   2a2aa:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
   2a2ae:	d1f1      	bne.n	2a294 <nrf_mem_init+0x8>
   2a2b0:	2400      	movs	r4, #0
   2a2b2:	4b2c      	ldr	r3, [pc, #176]	; (2a364 <nrf_mem_init+0xd8>)
   2a2b4:	4621      	mov	r1, r4
   2a2b6:	223c      	movs	r2, #60	; 0x3c
   2a2b8:	482b      	ldr	r0, [pc, #172]	; (2a368 <nrf_mem_init+0xdc>)
   2a2ba:	601c      	str	r4, [r3, #0]
   2a2bc:	f00f fd7f 	bl	39dbe <memset>
   2a2c0:	2110      	movs	r1, #16
   2a2c2:	2205      	movs	r2, #5
   2a2c4:	4b29      	ldr	r3, [pc, #164]	; (2a36c <nrf_mem_init+0xe0>)
   2a2c6:	4e2a      	ldr	r6, [pc, #168]	; (2a370 <nrf_mem_init+0xe4>)
   2a2c8:	e9c3 4400 	strd	r4, r4, [r3]
   2a2cc:	60d9      	str	r1, [r3, #12]
   2a2ce:	6159      	str	r1, [r3, #20]
   2a2d0:	61d9      	str	r1, [r3, #28]
   2a2d2:	6259      	str	r1, [r3, #36]	; 0x24
   2a2d4:	62d9      	str	r1, [r3, #44]	; 0x2c
   2a2d6:	6359      	str	r1, [r3, #52]	; 0x34
   2a2d8:	63d9      	str	r1, [r3, #60]	; 0x3c
   2a2da:	6459      	str	r1, [r3, #68]	; 0x44
   2a2dc:	64d9      	str	r1, [r3, #76]	; 0x4c
   2a2de:	6559      	str	r1, [r3, #84]	; 0x54
   2a2e0:	65d9      	str	r1, [r3, #92]	; 0x5c
   2a2e2:	6659      	str	r1, [r3, #100]	; 0x64
   2a2e4:	66d9      	str	r1, [r3, #108]	; 0x6c
   2a2e6:	6759      	str	r1, [r3, #116]	; 0x74
   2a2e8:	67d9      	str	r1, [r3, #124]	; 0x7c
   2a2ea:	609a      	str	r2, [r3, #8]
   2a2ec:	611a      	str	r2, [r3, #16]
   2a2ee:	619a      	str	r2, [r3, #24]
   2a2f0:	621a      	str	r2, [r3, #32]
   2a2f2:	629a      	str	r2, [r3, #40]	; 0x28
   2a2f4:	631a      	str	r2, [r3, #48]	; 0x30
   2a2f6:	639a      	str	r2, [r3, #56]	; 0x38
   2a2f8:	641a      	str	r2, [r3, #64]	; 0x40
   2a2fa:	649a      	str	r2, [r3, #72]	; 0x48
   2a2fc:	651a      	str	r2, [r3, #80]	; 0x50
   2a2fe:	659a      	str	r2, [r3, #88]	; 0x58
   2a300:	661a      	str	r2, [r3, #96]	; 0x60
   2a302:	669a      	str	r2, [r3, #104]	; 0x68
   2a304:	671a      	str	r2, [r3, #112]	; 0x70
   2a306:	679a      	str	r2, [r3, #120]	; 0x78
   2a308:	e9c3 2120 	strd	r2, r1, [r3, #128]	; 0x80
   2a30c:	e9c3 4422 	strd	r4, r4, [r3, #136]	; 0x88
   2a310:	e9c3 2124 	strd	r2, r1, [r3, #144]	; 0x90
   2a314:	e9c3 2126 	strd	r2, r1, [r3, #152]	; 0x98
   2a318:	e9c3 2128 	strd	r2, r1, [r3, #160]	; 0xa0
   2a31c:	e9c3 212a 	strd	r2, r1, [r3, #168]	; 0xa8
   2a320:	e9c3 212c 	strd	r2, r1, [r3, #176]	; 0xb0
   2a324:	e9c3 212e 	strd	r2, r1, [r3, #184]	; 0xb8
   2a328:	e9c3 2130 	strd	r2, r1, [r3, #192]	; 0xc0
   2a32c:	e9c3 2132 	strd	r2, r1, [r3, #200]	; 0xc8
   2a330:	e9c3 2134 	strd	r2, r1, [r3, #208]	; 0xd0
   2a334:	e9c3 2136 	strd	r2, r1, [r3, #216]	; 0xd8
   2a338:	e9c3 2138 	strd	r2, r1, [r3, #224]	; 0xe0
   2a33c:	e9c3 213a 	strd	r2, r1, [r3, #232]	; 0xe8
   2a340:	e9c3 213c 	strd	r2, r1, [r3, #240]	; 0xf0
   2a344:	e9c3 213e 	strd	r2, r1, [r3, #248]	; 0xf8
   2a348:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
   2a34c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   2a350:	f8c3 110c 	str.w	r1, [r3, #268]	; 0x10c
   2a354:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   2a358:	4620      	mov	r0, r4
   2a35a:	7035      	strb	r5, [r6, #0]
   2a35c:	bd70      	pop	{r4, r5, r6, pc}
   2a35e:	bf00      	nop
   2a360:	20020810 	.word	0x20020810
   2a364:	20020850 	.word	0x20020850
   2a368:	20020854 	.word	0x20020854
   2a36c:	20020890 	.word	0x20020890
   2a370:	20026144 	.word	0x20026144

0002a374 <nrf_mem_register>:
   2a374:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2a378:	4b87      	ldr	r3, [pc, #540]	; (2a598 <nrf_mem_register+0x224>)
   2a37a:	b087      	sub	sp, #28
   2a37c:	781b      	ldrb	r3, [r3, #0]
   2a37e:	2b00      	cmp	r3, #0
   2a380:	f000 808c 	beq.w	2a49c <nrf_mem_register+0x128>
   2a384:	b328      	cbz	r0, 2a3d2 <nrf_mem_register+0x5e>
   2a386:	b321      	cbz	r1, 2a3d2 <nrf_mem_register+0x5e>
   2a388:	780b      	ldrb	r3, [r1, #0]
   2a38a:	f8df 8218 	ldr.w	r8, [pc, #536]	; 2a5a4 <nrf_mem_register+0x230>
   2a38e:	eb03 1303 	add.w	r3, r3, r3, lsl #4
   2a392:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
   2a396:	685b      	ldr	r3, [r3, #4]
   2a398:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
   2a39c:	4463      	add	r3, ip
   2a39e:	2b10      	cmp	r3, #16
   2a3a0:	d811      	bhi.n	2a3c6 <nrf_mem_register+0x52>
   2a3a2:	f04f 0a00 	mov.w	sl, #0
   2a3a6:	4689      	mov	r9, r1
   2a3a8:	4b7c      	ldr	r3, [pc, #496]	; (2a59c <nrf_mem_register+0x228>)
   2a3aa:	4f7d      	ldr	r7, [pc, #500]	; (2a5a0 <nrf_mem_register+0x22c>)
   2a3ac:	681b      	ldr	r3, [r3, #0]
   2a3ae:	ea4f 0e8c 	mov.w	lr, ip, lsl #2
   2a3b2:	9300      	str	r3, [sp, #0]
   2a3b4:	68b9      	ldr	r1, [r7, #8]
   2a3b6:	b191      	cbz	r1, 2a3de <nrf_mem_register+0x6a>
   2a3b8:	f10a 0a01 	add.w	sl, sl, #1
   2a3bc:	f1ba 0f05 	cmp.w	sl, #5
   2a3c0:	f107 070c 	add.w	r7, r7, #12
   2a3c4:	d1f6      	bne.n	2a3b4 <nrf_mem_register+0x40>
   2a3c6:	f248 1b07 	movw	fp, #33031	; 0x8107
   2a3ca:	4658      	mov	r0, fp
   2a3cc:	b007      	add	sp, #28
   2a3ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2a3d2:	f248 1b0e 	movw	fp, #33038	; 0x810e
   2a3d6:	4658      	mov	r0, fp
   2a3d8:	b007      	add	sp, #28
   2a3da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2a3de:	f1bc 0f00 	cmp.w	ip, #0
   2a3e2:	d061      	beq.n	2a4a8 <nrf_mem_register+0x134>
   2a3e4:	460d      	mov	r5, r1
   2a3e6:	460c      	mov	r4, r1
   2a3e8:	f8d9 3010 	ldr.w	r3, [r9, #16]
   2a3ec:	eb0e 0b03 	add.w	fp, lr, r3
   2a3f0:	885a      	ldrh	r2, [r3, #2]
   2a3f2:	f833 6b04 	ldrh.w	r6, [r3], #4
   2a3f6:	4415      	add	r5, r2
   2a3f8:	459b      	cmp	fp, r3
   2a3fa:	fb02 4406 	mla	r4, r2, r6, r4
   2a3fe:	d1f7      	bne.n	2a3f0 <nrf_mem_register+0x7c>
   2a400:	f8d9 3008 	ldr.w	r3, [r9, #8]
   2a404:	42a3      	cmp	r3, r4
   2a406:	d3d7      	bcc.n	2a3b8 <nrf_mem_register+0x44>
   2a408:	9b00      	ldr	r3, [sp, #0]
   2a40a:	442b      	add	r3, r5
   2a40c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   2a410:	d2d2      	bcs.n	2a3b8 <nrf_mem_register+0x44>
   2a412:	4c63      	ldr	r4, [pc, #396]	; (2a5a0 <nrf_mem_register+0x22c>)
   2a414:	eb0a 024a 	add.w	r2, sl, sl, lsl #1
   2a418:	0092      	lsls	r2, r2, #2
   2a41a:	f8c0 a000 	str.w	sl, [r0]
   2a41e:	18a0      	adds	r0, r4, r2
   2a420:	f844 9002 	str.w	r9, [r4, r2]
   2a424:	9a00      	ldr	r2, [sp, #0]
   2a426:	468b      	mov	fp, r1
   2a428:	e9c0 2501 	strd	r2, r5, [r0, #4]
   2a42c:	f899 2001 	ldrb.w	r2, [r9, #1]
   2a430:	485a      	ldr	r0, [pc, #360]	; (2a59c <nrf_mem_register+0x228>)
   2a432:	2a01      	cmp	r2, #1
   2a434:	6003      	str	r3, [r0, #0]
   2a436:	d0c8      	beq.n	2a3ca <nrf_mem_register+0x56>
   2a438:	f8b9 300c 	ldrh.w	r3, [r9, #12]
   2a43c:	2b00      	cmp	r3, #0
   2a43e:	d0c4      	beq.n	2a3ca <nrf_mem_register+0x56>
   2a440:	2500      	movs	r5, #0
   2a442:	f8cd 9004 	str.w	r9, [sp, #4]
   2a446:	f8cd a00c 	str.w	sl, [sp, #12]
   2a44a:	f8cd b014 	str.w	fp, [sp, #20]
   2a44e:	9b01      	ldr	r3, [sp, #4]
   2a450:	781f      	ldrb	r7, [r3, #0]
   2a452:	691a      	ldr	r2, [r3, #16]
   2a454:	013b      	lsls	r3, r7, #4
   2a456:	eb03 0907 	add.w	r9, r3, r7
   2a45a:	9300      	str	r3, [sp, #0]
   2a45c:	eb08 03c9 	add.w	r3, r8, r9, lsl #3
   2a460:	6859      	ldr	r1, [r3, #4]
   2a462:	f832 4025 	ldrh.w	r4, [r2, r5, lsl #2]
   2a466:	9102      	str	r1, [sp, #8]
   2a468:	bb39      	cbnz	r1, 2a4ba <nrf_mem_register+0x146>
   2a46a:	9a03      	ldr	r2, [sp, #12]
   2a46c:	60dd      	str	r5, [r3, #12]
   2a46e:	609a      	str	r2, [r3, #8]
   2a470:	9b00      	ldr	r3, [sp, #0]
   2a472:	443b      	add	r3, r7
   2a474:	461f      	mov	r7, r3
   2a476:	eb08 01c3 	add.w	r1, r8, r3, lsl #3
   2a47a:	684b      	ldr	r3, [r1, #4]
   2a47c:	f858 2037 	ldr.w	r2, [r8, r7, lsl #3]
   2a480:	3301      	adds	r3, #1
   2a482:	4294      	cmp	r4, r2
   2a484:	604b      	str	r3, [r1, #4]
   2a486:	d912      	bls.n	2a4ae <nrf_mem_register+0x13a>
   2a488:	9b01      	ldr	r3, [sp, #4]
   2a48a:	f848 4037 	str.w	r4, [r8, r7, lsl #3]
   2a48e:	899b      	ldrh	r3, [r3, #12]
   2a490:	3501      	adds	r5, #1
   2a492:	429d      	cmp	r5, r3
   2a494:	d3db      	bcc.n	2a44e <nrf_mem_register+0xda>
   2a496:	f8dd b014 	ldr.w	fp, [sp, #20]
   2a49a:	e796      	b.n	2a3ca <nrf_mem_register+0x56>
   2a49c:	f248 1b08 	movw	fp, #33032	; 0x8108
   2a4a0:	4658      	mov	r0, fp
   2a4a2:	b007      	add	sp, #28
   2a4a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2a4a8:	9b00      	ldr	r3, [sp, #0]
   2a4aa:	4665      	mov	r5, ip
   2a4ac:	e7ae      	b.n	2a40c <nrf_mem_register+0x98>
   2a4ae:	9b01      	ldr	r3, [sp, #4]
   2a4b0:	3501      	adds	r5, #1
   2a4b2:	899b      	ldrh	r3, [r3, #12]
   2a4b4:	42ab      	cmp	r3, r5
   2a4b6:	d8ca      	bhi.n	2a44e <nrf_mem_register+0xda>
   2a4b8:	e7ed      	b.n	2a496 <nrf_mem_register+0x122>
   2a4ba:	2600      	movs	r6, #0
   2a4bc:	f101 3aff 	add.w	sl, r1, #4294967295
   2a4c0:	9504      	str	r5, [sp, #16]
   2a4c2:	eb06 000a 	add.w	r0, r6, sl
   2a4c6:	eb09 0206 	add.w	r2, r9, r6
   2a4ca:	3201      	adds	r2, #1
   2a4cc:	3001      	adds	r0, #1
   2a4ce:	f858 c032 	ldr.w	ip, [r8, r2, lsl #3]
   2a4d2:	0840      	lsrs	r0, r0, #1
   2a4d4:	4d32      	ldr	r5, [pc, #200]	; (2a5a0 <nrf_mem_register+0x22c>)
   2a4d6:	eb09 0100 	add.w	r1, r9, r0
   2a4da:	eb09 030a 	add.w	r3, r9, sl
   2a4de:	3101      	adds	r1, #1
   2a4e0:	3301      	adds	r3, #1
   2a4e2:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
   2a4e6:	f858 e031 	ldr.w	lr, [r8, r1, lsl #3]
   2a4ea:	f855 b02c 	ldr.w	fp, [r5, ip, lsl #2]
   2a4ee:	f858 c033 	ldr.w	ip, [r8, r3, lsl #3]
   2a4f2:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
   2a4f6:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
   2a4fa:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
   2a4fe:	f8db b010 	ldr.w	fp, [fp, #16]
   2a502:	6852      	ldr	r2, [r2, #4]
   2a504:	f855 e02e 	ldr.w	lr, [r5, lr, lsl #2]
   2a508:	f855 c02c 	ldr.w	ip, [r5, ip, lsl #2]
   2a50c:	eb08 01c1 	add.w	r1, r8, r1, lsl #3
   2a510:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
   2a514:	f83b 2022 	ldrh.w	r2, [fp, r2, lsl #2]
   2a518:	f8de e010 	ldr.w	lr, [lr, #16]
   2a51c:	6849      	ldr	r1, [r1, #4]
   2a51e:	f8dc c010 	ldr.w	ip, [ip, #16]
   2a522:	685b      	ldr	r3, [r3, #4]
   2a524:	4294      	cmp	r4, r2
   2a526:	f83e 1021 	ldrh.w	r1, [lr, r1, lsl #2]
   2a52a:	f83c 3023 	ldrh.w	r3, [ip, r3, lsl #2]
   2a52e:	d92d      	bls.n	2a58c <nrf_mem_register+0x218>
   2a530:	429c      	cmp	r4, r3
   2a532:	d22d      	bcs.n	2a590 <nrf_mem_register+0x21c>
   2a534:	428c      	cmp	r4, r1
   2a536:	d924      	bls.n	2a582 <nrf_mem_register+0x20e>
   2a538:	1c46      	adds	r6, r0, #1
   2a53a:	45b2      	cmp	sl, r6
   2a53c:	d2c1      	bcs.n	2a4c2 <nrf_mem_register+0x14e>
   2a53e:	2610      	movs	r6, #16
   2a540:	9d04      	ldr	r5, [sp, #16]
   2a542:	9a02      	ldr	r2, [sp, #8]
   2a544:	42b2      	cmp	r2, r6
   2a546:	d911      	bls.n	2a56c <nrf_mem_register+0x1f8>
   2a548:	9b00      	ldr	r3, [sp, #0]
   2a54a:	443b      	add	r3, r7
   2a54c:	441a      	add	r2, r3
   2a54e:	4433      	add	r3, r6
   2a550:	eb08 0ac2 	add.w	sl, r8, r2, lsl #3
   2a554:	eb08 09c3 	add.w	r9, r8, r3, lsl #3
   2a558:	2208      	movs	r2, #8
   2a55a:	4651      	mov	r1, sl
   2a55c:	eb0a 0002 	add.w	r0, sl, r2
   2a560:	f1aa 0a08 	sub.w	sl, sl, #8
   2a564:	f00f fc0b 	bl	39d7e <memcpy>
   2a568:	45d1      	cmp	r9, sl
   2a56a:	d1f5      	bne.n	2a558 <nrf_mem_register+0x1e4>
   2a56c:	9b00      	ldr	r3, [sp, #0]
   2a56e:	9903      	ldr	r1, [sp, #12]
   2a570:	443b      	add	r3, r7
   2a572:	4433      	add	r3, r6
   2a574:	3301      	adds	r3, #1
   2a576:	eb08 02c3 	add.w	r2, r8, r3, lsl #3
   2a57a:	f848 1033 	str.w	r1, [r8, r3, lsl #3]
   2a57e:	6055      	str	r5, [r2, #4]
   2a580:	e776      	b.n	2a470 <nrf_mem_register+0xfc>
   2a582:	f100 3aff 	add.w	sl, r0, #4294967295
   2a586:	4556      	cmp	r6, sl
   2a588:	d99b      	bls.n	2a4c2 <nrf_mem_register+0x14e>
   2a58a:	e7d8      	b.n	2a53e <nrf_mem_register+0x1ca>
   2a58c:	9d04      	ldr	r5, [sp, #16]
   2a58e:	e7d8      	b.n	2a542 <nrf_mem_register+0x1ce>
   2a590:	9d04      	ldr	r5, [sp, #16]
   2a592:	f10a 0601 	add.w	r6, sl, #1
   2a596:	e7d4      	b.n	2a542 <nrf_mem_register+0x1ce>
   2a598:	20026144 	.word	0x20026144
   2a59c:	20020850 	.word	0x20020850
   2a5a0:	20020854 	.word	0x20020854
   2a5a4:	20020890 	.word	0x20020890

0002a5a8 <nrf_malloc>:
   2a5a8:	4b03      	ldr	r3, [pc, #12]	; (2a5b8 <nrf_malloc+0x10>)
   2a5aa:	781b      	ldrb	r3, [r3, #0]
   2a5ac:	b10b      	cbz	r3, 2a5b2 <nrf_malloc+0xa>
   2a5ae:	f7ff bd8d 	b.w	2a0cc <mem_alloc.constprop.4>
   2a5b2:	4618      	mov	r0, r3
   2a5b4:	4770      	bx	lr
   2a5b6:	bf00      	nop
   2a5b8:	20026144 	.word	0x20026144

0002a5bc <nrf_free>:
   2a5bc:	4b04      	ldr	r3, [pc, #16]	; (2a5d0 <nrf_free+0x14>)
   2a5be:	781b      	ldrb	r3, [r3, #0]
   2a5c0:	b123      	cbz	r3, 2a5cc <nrf_free+0x10>
   2a5c2:	b118      	cbz	r0, 2a5cc <nrf_free+0x10>
   2a5c4:	4601      	mov	r1, r0
   2a5c6:	2000      	movs	r0, #0
   2a5c8:	f7ff bc30 	b.w	29e2c <mem_free>
   2a5cc:	4770      	bx	lr
   2a5ce:	bf00      	nop
   2a5d0:	20026144 	.word	0x20026144

0002a5d4 <nrf_shared_malloc>:
   2a5d4:	4b03      	ldr	r3, [pc, #12]	; (2a5e4 <nrf_shared_malloc+0x10>)
   2a5d6:	781b      	ldrb	r3, [r3, #0]
   2a5d8:	b10b      	cbz	r3, 2a5de <nrf_shared_malloc+0xa>
   2a5da:	f7ff bc93 	b.w	29f04 <mem_alloc.constprop.5>
   2a5de:	4618      	mov	r0, r3
   2a5e0:	4770      	bx	lr
   2a5e2:	bf00      	nop
   2a5e4:	20026144 	.word	0x20026144

0002a5e8 <nrf_shared_free>:
   2a5e8:	4b04      	ldr	r3, [pc, #16]	; (2a5fc <nrf_shared_free+0x14>)
   2a5ea:	781b      	ldrb	r3, [r3, #0]
   2a5ec:	b123      	cbz	r3, 2a5f8 <nrf_shared_free+0x10>
   2a5ee:	b118      	cbz	r0, 2a5f8 <nrf_shared_free+0x10>
   2a5f0:	4601      	mov	r1, r0
   2a5f2:	2001      	movs	r0, #1
   2a5f4:	f7ff bc1a 	b.w	29e2c <mem_free>
   2a5f8:	4770      	bx	lr
   2a5fa:	bf00      	nop
   2a5fc:	20026144 	.word	0x20026144

0002a600 <ip_client_event_handler>:
   2a600:	f850 1b08 	ldr.w	r1, [r0], #8
   2a604:	0c09      	lsrs	r1, r1, #16
   2a606:	f004 bd33 	b.w	2f070 <rpc_ip_event_handler>
   2a60a:	bf00      	nop

0002a60c <rpc_ip_client_init>:
   2a60c:	4801      	ldr	r0, [pc, #4]	; (2a614 <rpc_ip_client_init+0x8>)
   2a60e:	f005 ba23 	b.w	2fa58 <rpc_client_register>
   2a612:	bf00      	nop
   2a614:	0003b534 	.word	0x0003b534

0002a618 <rpc_ip_client_request_alloc>:
   2a618:	2300      	movs	r3, #0
   2a61a:	b510      	push	{r4, lr}
   2a61c:	b082      	sub	sp, #8
   2a61e:	9301      	str	r3, [sp, #4]
   2a620:	b158      	cbz	r0, 2a63a <rpc_ip_client_request_alloc+0x22>
   2a622:	4604      	mov	r4, r0
   2a624:	aa01      	add	r2, sp, #4
   2a626:	2004      	movs	r0, #4
   2a628:	f005 fc4e 	bl	2fec8 <rpc_message_alloc>
   2a62c:	b918      	cbnz	r0, 2a636 <rpc_ip_client_request_alloc+0x1e>
   2a62e:	9b01      	ldr	r3, [sp, #4]
   2a630:	b10b      	cbz	r3, 2a636 <rpc_ip_client_request_alloc+0x1e>
   2a632:	3308      	adds	r3, #8
   2a634:	6023      	str	r3, [r4, #0]
   2a636:	b002      	add	sp, #8
   2a638:	bd10      	pop	{r4, pc}
   2a63a:	2007      	movs	r0, #7
   2a63c:	b002      	add	sp, #8
   2a63e:	bd10      	pop	{r4, pc}

0002a640 <rpc_ip_client_request_send>:
   2a640:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   2a644:	f5b3 4fe0 	cmp.w	r3, #28672	; 0x7000
   2a648:	d10b      	bne.n	2a662 <rpc_ip_client_request_send+0x22>
   2a64a:	b160      	cbz	r0, 2a666 <rpc_ip_client_request_send+0x26>
   2a64c:	4603      	mov	r3, r0
   2a64e:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   2a652:	2004      	movs	r0, #4
   2a654:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   2a658:	f843 1d08 	str.w	r1, [r3, #-8]!
   2a65c:	4619      	mov	r1, r3
   2a65e:	f005 bc1b 	b.w	2fe98 <rpc_message_send>
   2a662:	200f      	movs	r0, #15
   2a664:	4770      	bx	lr
   2a666:	2007      	movs	r0, #7
   2a668:	4770      	bx	lr
   2a66a:	bf00      	nop

0002a66c <rpc_ip_client_message_free>:
   2a66c:	b120      	cbz	r0, 2a678 <rpc_ip_client_message_free+0xc>
   2a66e:	f1a0 0108 	sub.w	r1, r0, #8
   2a672:	2004      	movs	r0, #4
   2a674:	f005 bc5a 	b.w	2ff2c <rpc_message_free>
   2a678:	2007      	movs	r0, #7
   2a67a:	4770      	bx	lr

0002a67c <rpc_ip_client_data_free>:
   2a67c:	b118      	cbz	r0, 2a686 <rpc_ip_client_data_free+0xa>
   2a67e:	4601      	mov	r1, r0
   2a680:	2004      	movs	r0, #4
   2a682:	f005 bd65 	b.w	30150 <rpc_message_data_free>
   2a686:	2007      	movs	r0, #7
   2a688:	4770      	bx	lr
   2a68a:	bf00      	nop

0002a68c <secure_client_socket>:
   2a68c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2a690:	460c      	mov	r4, r1
   2a692:	680b      	ldr	r3, [r1, #0]
   2a694:	4f46      	ldr	r7, [pc, #280]	; (2a7b0 <secure_client_socket+0x124>)
   2a696:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   2a69a:	600b      	str	r3, [r1, #0]
   2a69c:	680b      	ldr	r3, [r1, #0]
   2a69e:	00c6      	lsls	r6, r0, #3
   2a6a0:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   2a6a4:	600b      	str	r3, [r1, #0]
   2a6a6:	eb07 0a06 	add.w	sl, r7, r6
   2a6aa:	b082      	sub	sp, #8
   2a6ac:	f8da 3004 	ldr.w	r3, [sl, #4]
   2a6b0:	6989      	ldr	r1, [r1, #24]
   2a6b2:	f247 0281 	movw	r2, #28801	; 0x7081
   2a6b6:	4605      	mov	r5, r0
   2a6b8:	f8d4 8000 	ldr.w	r8, [r4]
   2a6bc:	f003 fbd0 	bl	2de60 <ip_interface_request_create>
   2a6c0:	2800      	cmp	r0, #0
   2a6c2:	d06f      	beq.n	2a7a4 <secure_client_socket+0x118>
   2a6c4:	f8da 2004 	ldr.w	r2, [sl, #4]
   2a6c8:	4681      	mov	r9, r0
   2a6ca:	2a00      	cmp	r2, #0
   2a6cc:	d15f      	bne.n	2a78e <secure_client_socket+0x102>
   2a6ce:	4b39      	ldr	r3, [pc, #228]	; (2a7b4 <secure_client_socket+0x128>)
   2a6d0:	1971      	adds	r1, r6, r5
   2a6d2:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   2a6d6:	2224      	movs	r2, #36	; 0x24
   2a6d8:	f109 0014 	add.w	r0, r9, #20
   2a6dc:	f00f fb4f 	bl	39d7e <memcpy>
   2a6e0:	f8d9 3008 	ldr.w	r3, [r9, #8]
   2a6e4:	4649      	mov	r1, r9
   2a6e6:	3324      	adds	r3, #36	; 0x24
   2a6e8:	f8c9 3008 	str.w	r3, [r9, #8]
   2a6ec:	6822      	ldr	r2, [r4, #0]
   2a6ee:	4643      	mov	r3, r8
   2a6f0:	0c12      	lsrs	r2, r2, #16
   2a6f2:	0412      	lsls	r2, r2, #16
   2a6f4:	f042 020a 	orr.w	r2, r2, #10
   2a6f8:	6022      	str	r2, [r4, #0]
   2a6fa:	4620      	mov	r0, r4
   2a6fc:	f247 0281 	movw	r2, #28801	; 0x7081
   2a700:	f003 fbce 	bl	2dea0 <ip_interface_request_send>
   2a704:	4603      	mov	r3, r0
   2a706:	b970      	cbnz	r0, 2a726 <secure_client_socket+0x9a>
   2a708:	6823      	ldr	r3, [r4, #0]
   2a70a:	00db      	lsls	r3, r3, #3
   2a70c:	d40f      	bmi.n	2a72e <secure_client_socket+0xa2>
   2a70e:	f04f 33ff 	mov.w	r3, #4294967295
   2a712:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2a716:	210b      	movs	r1, #11
   2a718:	4628      	mov	r0, r5
   2a71a:	f003 fbd5 	bl	2dec8 <ip_interface_wait>
   2a71e:	4603      	mov	r3, r0
   2a720:	b150      	cbz	r0, 2a738 <secure_client_socket+0xac>
   2a722:	f8c4 8000 	str.w	r8, [r4]
   2a726:	4618      	mov	r0, r3
   2a728:	b002      	add	sp, #8
   2a72a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2a72e:	2373      	movs	r3, #115	; 0x73
   2a730:	4618      	mov	r0, r3
   2a732:	b002      	add	sp, #8
   2a734:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2a738:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
   2a73c:	f04f 33ff 	mov.w	r3, #4294967295
   2a740:	4611      	mov	r1, r2
   2a742:	4628      	mov	r0, r5
   2a744:	f003 fbc0 	bl	2dec8 <ip_interface_wait>
   2a748:	4603      	mov	r3, r0
   2a74a:	bb30      	cbnz	r0, 2a79a <secure_client_socket+0x10e>
   2a74c:	f857 0035 	ldr.w	r0, [r7, r5, lsl #3]
   2a750:	b138      	cbz	r0, 2a762 <secure_client_socket+0xd6>
   2a752:	9301      	str	r3, [sp, #4]
   2a754:	f7ff ff32 	bl	2a5bc <nrf_free>
   2a758:	9b01      	ldr	r3, [sp, #4]
   2a75a:	443e      	add	r6, r7
   2a75c:	6073      	str	r3, [r6, #4]
   2a75e:	f847 3035 	str.w	r3, [r7, r5, lsl #3]
   2a762:	4618      	mov	r0, r3
   2a764:	6822      	ldr	r2, [r4, #0]
   2a766:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
   2a76a:	6022      	str	r2, [r4, #0]
   2a76c:	6822      	ldr	r2, [r4, #0]
   2a76e:	0c12      	lsrs	r2, r2, #16
   2a770:	0412      	lsls	r2, r2, #16
   2a772:	f042 020c 	orr.w	r2, r2, #12
   2a776:	6022      	str	r2, [r4, #0]
   2a778:	6822      	ldr	r2, [r4, #0]
   2a77a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   2a77e:	6022      	str	r2, [r4, #0]
   2a780:	6822      	ldr	r2, [r4, #0]
   2a782:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
   2a786:	6022      	str	r2, [r4, #0]
   2a788:	b002      	add	sp, #8
   2a78a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2a78e:	f857 1035 	ldr.w	r1, [r7, r5, lsl #3]
   2a792:	6800      	ldr	r0, [r0, #0]
   2a794:	f00f faf3 	bl	39d7e <memcpy>
   2a798:	e799      	b.n	2a6ce <secure_client_socket+0x42>
   2a79a:	2b73      	cmp	r3, #115	; 0x73
   2a79c:	d0c3      	beq.n	2a726 <secure_client_socket+0x9a>
   2a79e:	f8c4 8000 	str.w	r8, [r4]
   2a7a2:	e7c0      	b.n	2a726 <secure_client_socket+0x9a>
   2a7a4:	230c      	movs	r3, #12
   2a7a6:	4618      	mov	r0, r3
   2a7a8:	b002      	add	sp, #8
   2a7aa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2a7ae:	bf00      	nop
   2a7b0:	20020ae4 	.word	0x20020ae4
   2a7b4:	200209a0 	.word	0x200209a0

0002a7b8 <tls_interface_init>:
   2a7b8:	2000      	movs	r0, #0
   2a7ba:	4770      	bx	lr

0002a7bc <tls_interface_open>:
   2a7bc:	b538      	push	{r3, r4, r5, lr}
   2a7be:	1e4b      	subs	r3, r1, #1
   2a7c0:	2b01      	cmp	r3, #1
   2a7c2:	d808      	bhi.n	2a7d6 <tls_interface_open+0x1a>
   2a7c4:	4614      	mov	r4, r2
   2a7c6:	b162      	cbz	r2, 2a7e2 <tls_interface_open+0x26>
   2a7c8:	2901      	cmp	r1, #1
   2a7ca:	d02d      	beq.n	2a828 <tls_interface_open+0x6c>
   2a7cc:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   2a7d0:	bf08      	it	eq
   2a7d2:	2202      	moveq	r2, #2
   2a7d4:	d00d      	beq.n	2a7f2 <tls_interface_open+0x36>
   2a7d6:	2029      	movs	r0, #41	; 0x29
   2a7d8:	f7fd f942 	bl	27a60 <bsd_os_errno_set>
   2a7dc:	f04f 35ff 	mov.w	r5, #4294967295
   2a7e0:	e020      	b.n	2a824 <tls_interface_open+0x68>
   2a7e2:	2901      	cmp	r1, #1
   2a7e4:	bf0b      	itete	eq
   2a7e6:	2201      	moveq	r2, #1
   2a7e8:	2202      	movne	r2, #2
   2a7ea:	f44f 7482 	moveq.w	r4, #260	; 0x104
   2a7ee:	f44f 7487 	movne.w	r4, #270	; 0x10e
   2a7f2:	f003 fb95 	bl	2df20 <ip_interface_open>
   2a7f6:	1e05      	subs	r5, r0, #0
   2a7f8:	db1b      	blt.n	2a832 <tls_interface_open+0x76>
   2a7fa:	4b0f      	ldr	r3, [pc, #60]	; (2a838 <tls_interface_open+0x7c>)
   2a7fc:	eb05 00c5 	add.w	r0, r5, r5, lsl #3
   2a800:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   2a804:	2224      	movs	r2, #36	; 0x24
   2a806:	490d      	ldr	r1, [pc, #52]	; (2a83c <tls_interface_open+0x80>)
   2a808:	f00f fab9 	bl	39d7e <memcpy>
   2a80c:	4628      	mov	r0, r5
   2a80e:	f004 ffe7 	bl	2f7e0 <interface_socket_from_handle_get>
   2a812:	6803      	ldr	r3, [r0, #0]
   2a814:	6144      	str	r4, [r0, #20]
   2a816:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   2a81a:	6003      	str	r3, [r0, #0]
   2a81c:	6803      	ldr	r3, [r0, #0]
   2a81e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   2a822:	6003      	str	r3, [r0, #0]
   2a824:	4628      	mov	r0, r5
   2a826:	bd38      	pop	{r3, r4, r5, pc}
   2a828:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   2a82c:	d1d3      	bne.n	2a7d6 <tls_interface_open+0x1a>
   2a82e:	460a      	mov	r2, r1
   2a830:	e7df      	b.n	2a7f2 <tls_interface_open+0x36>
   2a832:	f04f 35ff 	mov.w	r5, #4294967295
   2a836:	e7f5      	b.n	2a824 <tls_interface_open+0x68>
   2a838:	200209a0 	.word	0x200209a0
   2a83c:	0003b544 	.word	0x0003b544

0002a840 <tls_interface_close>:
   2a840:	b538      	push	{r3, r4, r5, lr}
   2a842:	4604      	mov	r4, r0
   2a844:	f004 ffcc 	bl	2f7e0 <interface_socket_from_handle_get>
   2a848:	b180      	cbz	r0, 2a86c <tls_interface_close+0x2c>
   2a84a:	4d0b      	ldr	r5, [pc, #44]	; (2a878 <tls_interface_close+0x38>)
   2a84c:	f855 0034 	ldr.w	r0, [r5, r4, lsl #3]
   2a850:	b138      	cbz	r0, 2a862 <tls_interface_close+0x22>
   2a852:	f7ff feb3 	bl	2a5bc <nrf_free>
   2a856:	2300      	movs	r3, #0
   2a858:	eb05 02c4 	add.w	r2, r5, r4, lsl #3
   2a85c:	f845 3034 	str.w	r3, [r5, r4, lsl #3]
   2a860:	6053      	str	r3, [r2, #4]
   2a862:	4620      	mov	r0, r4
   2a864:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2a868:	f003 bc0c 	b.w	2e084 <ip_interface_close>
   2a86c:	2009      	movs	r0, #9
   2a86e:	f7fd f8f7 	bl	27a60 <bsd_os_errno_set>
   2a872:	f04f 30ff 	mov.w	r0, #4294967295
   2a876:	bd38      	pop	{r3, r4, r5, pc}
   2a878:	20020ae4 	.word	0x20020ae4

0002a87c <tls_interface_sendto>:
   2a87c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2a880:	460d      	mov	r5, r1
   2a882:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   2a886:	4616      	mov	r6, r2
   2a888:	461f      	mov	r7, r3
   2a88a:	4604      	mov	r4, r0
   2a88c:	f004 ffa8 	bl	2f7e0 <interface_socket_from_handle_get>
   2a890:	2800      	cmp	r0, #0
   2a892:	d03b      	beq.n	2a90c <tls_interface_sendto+0x90>
   2a894:	6803      	ldr	r3, [r0, #0]
   2a896:	b29b      	uxth	r3, r3
   2a898:	2b0c      	cmp	r3, #12
   2a89a:	d039      	beq.n	2a910 <tls_interface_sendto+0x94>
   2a89c:	6803      	ldr	r3, [r0, #0]
   2a89e:	b29b      	uxth	r3, r3
   2a8a0:	2b0b      	cmp	r3, #11
   2a8a2:	d111      	bne.n	2a8c8 <tls_interface_sendto+0x4c>
   2a8a4:	4b20      	ldr	r3, [pc, #128]	; (2a928 <tls_interface_sendto+0xac>)
   2a8a6:	eb04 04c4 	add.w	r4, r4, r4, lsl #3
   2a8aa:	f813 3024 	ldrb.w	r3, [r3, r4, lsl #2]
   2a8ae:	2b02      	cmp	r3, #2
   2a8b0:	d038      	beq.n	2a924 <tls_interface_sendto+0xa8>
   2a8b2:	6903      	ldr	r3, [r0, #16]
   2a8b4:	2b01      	cmp	r3, #1
   2a8b6:	bf14      	ite	ne
   2a8b8:	2039      	movne	r0, #57	; 0x39
   2a8ba:	202a      	moveq	r0, #42	; 0x2a
   2a8bc:	f7fd f8d0 	bl	27a60 <bsd_os_errno_set>
   2a8c0:	f04f 30ff 	mov.w	r0, #4294967295
   2a8c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2a8c8:	6903      	ldr	r3, [r0, #16]
   2a8ca:	2b01      	cmp	r3, #1
   2a8cc:	d00b      	beq.n	2a8e6 <tls_interface_sendto+0x6a>
   2a8ce:	2b02      	cmp	r3, #2
   2a8d0:	d001      	beq.n	2a8d6 <tls_interface_sendto+0x5a>
   2a8d2:	2039      	movs	r0, #57	; 0x39
   2a8d4:	e7f2      	b.n	2a8bc <tls_interface_sendto+0x40>
   2a8d6:	6803      	ldr	r3, [r0, #0]
   2a8d8:	b29b      	uxth	r3, r3
   2a8da:	2b02      	cmp	r3, #2
   2a8dc:	d007      	beq.n	2a8ee <tls_interface_sendto+0x72>
   2a8de:	6803      	ldr	r3, [r0, #0]
   2a8e0:	b29b      	uxth	r3, r3
   2a8e2:	2b04      	cmp	r3, #4
   2a8e4:	d003      	beq.n	2a8ee <tls_interface_sendto+0x72>
   2a8e6:	6803      	ldr	r3, [r0, #0]
   2a8e8:	b29b      	uxth	r3, r3
   2a8ea:	2b05      	cmp	r3, #5
   2a8ec:	d1f1      	bne.n	2a8d2 <tls_interface_sendto+0x56>
   2a8ee:	4b0e      	ldr	r3, [pc, #56]	; (2a928 <tls_interface_sendto+0xac>)
   2a8f0:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
   2a8f4:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   2a8f8:	2b02      	cmp	r3, #2
   2a8fa:	d1ea      	bne.n	2a8d2 <tls_interface_sendto+0x56>
   2a8fc:	4601      	mov	r1, r0
   2a8fe:	4620      	mov	r0, r4
   2a900:	f7ff fec4 	bl	2a68c <secure_client_socket>
   2a904:	2800      	cmp	r0, #0
   2a906:	d003      	beq.n	2a910 <tls_interface_sendto+0x94>
   2a908:	dcd8      	bgt.n	2a8bc <tls_interface_sendto+0x40>
   2a90a:	e7d9      	b.n	2a8c0 <tls_interface_sendto+0x44>
   2a90c:	2009      	movs	r0, #9
   2a90e:	e7d5      	b.n	2a8bc <tls_interface_sendto+0x40>
   2a910:	e9cd 8908 	strd	r8, r9, [sp, #32]
   2a914:	463b      	mov	r3, r7
   2a916:	4632      	mov	r2, r6
   2a918:	4629      	mov	r1, r5
   2a91a:	4620      	mov	r0, r4
   2a91c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2a920:	f003 bc20 	b.w	2e164 <ip_interface_sendto>
   2a924:	2023      	movs	r0, #35	; 0x23
   2a926:	e7c9      	b.n	2a8bc <tls_interface_sendto+0x40>
   2a928:	200209a0 	.word	0x200209a0

0002a92c <tls_interface_recvfrom>:
   2a92c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2a930:	460d      	mov	r5, r1
   2a932:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   2a936:	4616      	mov	r6, r2
   2a938:	461f      	mov	r7, r3
   2a93a:	4604      	mov	r4, r0
   2a93c:	f004 ff50 	bl	2f7e0 <interface_socket_from_handle_get>
   2a940:	2800      	cmp	r0, #0
   2a942:	d038      	beq.n	2a9b6 <tls_interface_recvfrom+0x8a>
   2a944:	6803      	ldr	r3, [r0, #0]
   2a946:	b29b      	uxth	r3, r3
   2a948:	2b0c      	cmp	r3, #12
   2a94a:	d00f      	beq.n	2a96c <tls_interface_recvfrom+0x40>
   2a94c:	6803      	ldr	r3, [r0, #0]
   2a94e:	b29b      	uxth	r3, r3
   2a950:	2b0d      	cmp	r3, #13
   2a952:	d00b      	beq.n	2a96c <tls_interface_recvfrom+0x40>
   2a954:	6903      	ldr	r3, [r0, #16]
   2a956:	2b01      	cmp	r3, #1
   2a958:	d01a      	beq.n	2a990 <tls_interface_recvfrom+0x64>
   2a95a:	2b02      	cmp	r3, #2
   2a95c:	d010      	beq.n	2a980 <tls_interface_recvfrom+0x54>
   2a95e:	2023      	movs	r0, #35	; 0x23
   2a960:	f7fd f87e 	bl	27a60 <bsd_os_errno_set>
   2a964:	f04f 30ff 	mov.w	r0, #4294967295
   2a968:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2a96c:	e9cd 8908 	strd	r8, r9, [sp, #32]
   2a970:	463b      	mov	r3, r7
   2a972:	4632      	mov	r2, r6
   2a974:	4629      	mov	r1, r5
   2a976:	4620      	mov	r0, r4
   2a978:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2a97c:	f003 bd6a 	b.w	2e454 <ip_interface_recvfrom>
   2a980:	6803      	ldr	r3, [r0, #0]
   2a982:	b29b      	uxth	r3, r3
   2a984:	2b02      	cmp	r3, #2
   2a986:	d007      	beq.n	2a998 <tls_interface_recvfrom+0x6c>
   2a988:	6803      	ldr	r3, [r0, #0]
   2a98a:	b29b      	uxth	r3, r3
   2a98c:	2b04      	cmp	r3, #4
   2a98e:	d003      	beq.n	2a998 <tls_interface_recvfrom+0x6c>
   2a990:	6803      	ldr	r3, [r0, #0]
   2a992:	b29b      	uxth	r3, r3
   2a994:	2b05      	cmp	r3, #5
   2a996:	d1e2      	bne.n	2a95e <tls_interface_recvfrom+0x32>
   2a998:	4b08      	ldr	r3, [pc, #32]	; (2a9bc <tls_interface_recvfrom+0x90>)
   2a99a:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
   2a99e:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   2a9a2:	2b02      	cmp	r3, #2
   2a9a4:	d1db      	bne.n	2a95e <tls_interface_recvfrom+0x32>
   2a9a6:	4601      	mov	r1, r0
   2a9a8:	4620      	mov	r0, r4
   2a9aa:	f7ff fe6f 	bl	2a68c <secure_client_socket>
   2a9ae:	2800      	cmp	r0, #0
   2a9b0:	d0dc      	beq.n	2a96c <tls_interface_recvfrom+0x40>
   2a9b2:	dcd5      	bgt.n	2a960 <tls_interface_recvfrom+0x34>
   2a9b4:	e7d6      	b.n	2a964 <tls_interface_recvfrom+0x38>
   2a9b6:	2009      	movs	r0, #9
   2a9b8:	e7d2      	b.n	2a960 <tls_interface_recvfrom+0x34>
   2a9ba:	bf00      	nop
   2a9bc:	200209a0 	.word	0x200209a0

0002a9c0 <tls_interface_bind>:
   2a9c0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2a9c4:	460c      	mov	r4, r1
   2a9c6:	4617      	mov	r7, r2
   2a9c8:	4606      	mov	r6, r0
   2a9ca:	f004 ff09 	bl	2f7e0 <interface_socket_from_handle_get>
   2a9ce:	2800      	cmp	r0, #0
   2a9d0:	d06d      	beq.n	2aaae <tls_interface_bind+0xee>
   2a9d2:	6803      	ldr	r3, [r0, #0]
   2a9d4:	4605      	mov	r5, r0
   2a9d6:	b29b      	uxth	r3, r3
   2a9d8:	2b02      	cmp	r3, #2
   2a9da:	d15a      	bne.n	2aa92 <tls_interface_bind+0xd2>
   2a9dc:	4621      	mov	r1, r4
   2a9de:	463a      	mov	r2, r7
   2a9e0:	4630      	mov	r0, r6
   2a9e2:	f003 ff25 	bl	2e830 <ip_interface_bind>
   2a9e6:	4604      	mov	r4, r0
   2a9e8:	2800      	cmp	r0, #0
   2a9ea:	d148      	bne.n	2aa7e <tls_interface_bind+0xbe>
   2a9ec:	00f7      	lsls	r7, r6, #3
   2a9ee:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 2aab4 <tls_interface_bind+0xf4>
   2a9f2:	19bb      	adds	r3, r7, r6
   2a9f4:	f818 3023 	ldrb.w	r3, [r8, r3, lsl #2]
   2a9f8:	2b01      	cmp	r3, #1
   2a9fa:	d002      	beq.n	2aa02 <tls_interface_bind+0x42>
   2a9fc:	4620      	mov	r0, r4
   2a9fe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2aa02:	f8df b0b4 	ldr.w	fp, [pc, #180]	; 2aab8 <tls_interface_bind+0xf8>
   2aa06:	f247 0281 	movw	r2, #28801	; 0x7081
   2aa0a:	eb0b 0a07 	add.w	sl, fp, r7
   2aa0e:	f8da 3004 	ldr.w	r3, [sl, #4]
   2aa12:	69a9      	ldr	r1, [r5, #24]
   2aa14:	4630      	mov	r0, r6
   2aa16:	f003 fa23 	bl	2de60 <ip_interface_request_create>
   2aa1a:	4681      	mov	r9, r0
   2aa1c:	2800      	cmp	r0, #0
   2aa1e:	d044      	beq.n	2aaaa <tls_interface_bind+0xea>
   2aa20:	f8da 2004 	ldr.w	r2, [sl, #4]
   2aa24:	2a00      	cmp	r2, #0
   2aa26:	d13a      	bne.n	2aa9e <tls_interface_bind+0xde>
   2aa28:	19b9      	adds	r1, r7, r6
   2aa2a:	eb08 0181 	add.w	r1, r8, r1, lsl #2
   2aa2e:	2224      	movs	r2, #36	; 0x24
   2aa30:	f109 0014 	add.w	r0, r9, #20
   2aa34:	f00f f9a3 	bl	39d7e <memcpy>
   2aa38:	f8d9 3008 	ldr.w	r3, [r9, #8]
   2aa3c:	4649      	mov	r1, r9
   2aa3e:	3324      	adds	r3, #36	; 0x24
   2aa40:	f8c9 3008 	str.w	r3, [r9, #8]
   2aa44:	682a      	ldr	r2, [r5, #0]
   2aa46:	2304      	movs	r3, #4
   2aa48:	0c12      	lsrs	r2, r2, #16
   2aa4a:	0412      	lsls	r2, r2, #16
   2aa4c:	f042 020a 	orr.w	r2, r2, #10
   2aa50:	602a      	str	r2, [r5, #0]
   2aa52:	4628      	mov	r0, r5
   2aa54:	f247 0281 	movw	r2, #28801	; 0x7081
   2aa58:	f003 fa22 	bl	2dea0 <ip_interface_request_send>
   2aa5c:	b9e8      	cbnz	r0, 2aa9a <tls_interface_bind+0xda>
   2aa5e:	682b      	ldr	r3, [r5, #0]
   2aa60:	00db      	lsls	r3, r3, #3
   2aa62:	d418      	bmi.n	2aa96 <tls_interface_bind+0xd6>
   2aa64:	4630      	mov	r0, r6
   2aa66:	f04f 33ff 	mov.w	r3, #4294967295
   2aa6a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2aa6e:	210b      	movs	r1, #11
   2aa70:	f003 fa2a 	bl	2dec8 <ip_interface_wait>
   2aa74:	2800      	cmp	r0, #0
   2aa76:	d0c1      	beq.n	2a9fc <tls_interface_bind+0x3c>
   2aa78:	2304      	movs	r3, #4
   2aa7a:	4604      	mov	r4, r0
   2aa7c:	602b      	str	r3, [r5, #0]
   2aa7e:	2c00      	cmp	r4, #0
   2aa80:	ddbc      	ble.n	2a9fc <tls_interface_bind+0x3c>
   2aa82:	4620      	mov	r0, r4
   2aa84:	f04f 34ff 	mov.w	r4, #4294967295
   2aa88:	f7fc ffea 	bl	27a60 <bsd_os_errno_set>
   2aa8c:	4620      	mov	r0, r4
   2aa8e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2aa92:	242d      	movs	r4, #45	; 0x2d
   2aa94:	e7f5      	b.n	2aa82 <tls_interface_bind+0xc2>
   2aa96:	2473      	movs	r4, #115	; 0x73
   2aa98:	e7f3      	b.n	2aa82 <tls_interface_bind+0xc2>
   2aa9a:	4604      	mov	r4, r0
   2aa9c:	e7ef      	b.n	2aa7e <tls_interface_bind+0xbe>
   2aa9e:	f85b 1036 	ldr.w	r1, [fp, r6, lsl #3]
   2aaa2:	6800      	ldr	r0, [r0, #0]
   2aaa4:	f00f f96b 	bl	39d7e <memcpy>
   2aaa8:	e7be      	b.n	2aa28 <tls_interface_bind+0x68>
   2aaaa:	240c      	movs	r4, #12
   2aaac:	e7e9      	b.n	2aa82 <tls_interface_bind+0xc2>
   2aaae:	2409      	movs	r4, #9
   2aab0:	e7e7      	b.n	2aa82 <tls_interface_bind+0xc2>
   2aab2:	bf00      	nop
   2aab4:	200209a0 	.word	0x200209a0
   2aab8:	20020ae4 	.word	0x20020ae4

0002aabc <tls_interface_connect>:
   2aabc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2aabe:	460e      	mov	r6, r1
   2aac0:	4617      	mov	r7, r2
   2aac2:	4604      	mov	r4, r0
   2aac4:	f004 fe8c 	bl	2f7e0 <interface_socket_from_handle_get>
   2aac8:	b1e8      	cbz	r0, 2ab06 <tls_interface_connect+0x4a>
   2aaca:	4b13      	ldr	r3, [pc, #76]	; (2ab18 <tls_interface_connect+0x5c>)
   2aacc:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
   2aad0:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   2aad4:	2b02      	cmp	r3, #2
   2aad6:	d11c      	bne.n	2ab12 <tls_interface_connect+0x56>
   2aad8:	6803      	ldr	r3, [r0, #0]
   2aada:	4605      	mov	r5, r0
   2aadc:	b29b      	uxth	r3, r3
   2aade:	2b02      	cmp	r3, #2
   2aae0:	d003      	beq.n	2aaea <tls_interface_connect+0x2e>
   2aae2:	6803      	ldr	r3, [r0, #0]
   2aae4:	b29b      	uxth	r3, r3
   2aae6:	2b04      	cmp	r3, #4
   2aae8:	d113      	bne.n	2ab12 <tls_interface_connect+0x56>
   2aaea:	463a      	mov	r2, r7
   2aaec:	4631      	mov	r1, r6
   2aaee:	4620      	mov	r0, r4
   2aaf0:	f003 fde4 	bl	2e6bc <ip_interface_connect>
   2aaf4:	b110      	cbz	r0, 2aafc <tls_interface_connect+0x40>
   2aaf6:	2800      	cmp	r0, #0
   2aaf8:	dc06      	bgt.n	2ab08 <tls_interface_connect+0x4c>
   2aafa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2aafc:	4629      	mov	r1, r5
   2aafe:	4620      	mov	r0, r4
   2ab00:	f7ff fdc4 	bl	2a68c <secure_client_socket>
   2ab04:	e7f7      	b.n	2aaf6 <tls_interface_connect+0x3a>
   2ab06:	2009      	movs	r0, #9
   2ab08:	f7fc ffaa 	bl	27a60 <bsd_os_errno_set>
   2ab0c:	f04f 30ff 	mov.w	r0, #4294967295
   2ab10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2ab12:	202d      	movs	r0, #45	; 0x2d
   2ab14:	e7f8      	b.n	2ab08 <tls_interface_connect+0x4c>
   2ab16:	bf00      	nop
   2ab18:	200209a0 	.word	0x200209a0

0002ab1c <tls_interface_listen>:
   2ab1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2ab20:	b083      	sub	sp, #12
   2ab22:	9101      	str	r1, [sp, #4]
   2ab24:	4605      	mov	r5, r0
   2ab26:	f004 fe5b 	bl	2f7e0 <interface_socket_from_handle_get>
   2ab2a:	2800      	cmp	r0, #0
   2ab2c:	d079      	beq.n	2ac22 <tls_interface_listen+0x106>
   2ab2e:	6903      	ldr	r3, [r0, #16]
   2ab30:	4604      	mov	r4, r0
   2ab32:	2b01      	cmp	r3, #1
   2ab34:	d173      	bne.n	2ac1e <tls_interface_listen+0x102>
   2ab36:	6803      	ldr	r3, [r0, #0]
   2ab38:	b29b      	uxth	r3, r3
   2ab3a:	2b04      	cmp	r3, #4
   2ab3c:	d05f      	beq.n	2abfe <tls_interface_listen+0xe2>
   2ab3e:	6823      	ldr	r3, [r4, #0]
   2ab40:	b29b      	uxth	r3, r3
   2ab42:	2b0b      	cmp	r3, #11
   2ab44:	d16b      	bne.n	2ac1e <tls_interface_listen+0x102>
   2ab46:	00ee      	lsls	r6, r5, #3
   2ab48:	4f37      	ldr	r7, [pc, #220]	; (2ac28 <tls_interface_listen+0x10c>)
   2ab4a:	1973      	adds	r3, r6, r5
   2ab4c:	f817 3023 	ldrb.w	r3, [r7, r3, lsl #2]
   2ab50:	2b01      	cmp	r3, #1
   2ab52:	d164      	bne.n	2ac1e <tls_interface_listen+0x102>
   2ab54:	2201      	movs	r2, #1
   2ab56:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 2ac2c <tls_interface_listen+0x110>
   2ab5a:	1973      	adds	r3, r6, r5
   2ab5c:	00ee      	lsls	r6, r5, #3
   2ab5e:	f807 2023 	strb.w	r2, [r7, r3, lsl #2]
   2ab62:	eb09 0806 	add.w	r8, r9, r6
   2ab66:	69a1      	ldr	r1, [r4, #24]
   2ab68:	f8d8 3004 	ldr.w	r3, [r8, #4]
   2ab6c:	f247 0281 	movw	r2, #28801	; 0x7081
   2ab70:	4628      	mov	r0, r5
   2ab72:	f8d4 a000 	ldr.w	sl, [r4]
   2ab76:	f003 f973 	bl	2de60 <ip_interface_request_create>
   2ab7a:	4683      	mov	fp, r0
   2ab7c:	2800      	cmp	r0, #0
   2ab7e:	d04c      	beq.n	2ac1a <tls_interface_listen+0xfe>
   2ab80:	f8d8 2004 	ldr.w	r2, [r8, #4]
   2ab84:	2a00      	cmp	r2, #0
   2ab86:	d142      	bne.n	2ac0e <tls_interface_listen+0xf2>
   2ab88:	1971      	adds	r1, r6, r5
   2ab8a:	eb07 0181 	add.w	r1, r7, r1, lsl #2
   2ab8e:	2224      	movs	r2, #36	; 0x24
   2ab90:	f10b 0014 	add.w	r0, fp, #20
   2ab94:	f00f f8f3 	bl	39d7e <memcpy>
   2ab98:	f8db 2008 	ldr.w	r2, [fp, #8]
   2ab9c:	4659      	mov	r1, fp
   2ab9e:	3224      	adds	r2, #36	; 0x24
   2aba0:	f8cb 2008 	str.w	r2, [fp, #8]
   2aba4:	6822      	ldr	r2, [r4, #0]
   2aba6:	4653      	mov	r3, sl
   2aba8:	0c12      	lsrs	r2, r2, #16
   2abaa:	0412      	lsls	r2, r2, #16
   2abac:	f042 020a 	orr.w	r2, r2, #10
   2abb0:	6022      	str	r2, [r4, #0]
   2abb2:	4620      	mov	r0, r4
   2abb4:	f247 0281 	movw	r2, #28801	; 0x7081
   2abb8:	f003 f972 	bl	2dea0 <ip_interface_request_send>
   2abbc:	b968      	cbnz	r0, 2abda <tls_interface_listen+0xbe>
   2abbe:	6823      	ldr	r3, [r4, #0]
   2abc0:	00db      	lsls	r3, r3, #3
   2abc2:	d40f      	bmi.n	2abe4 <tls_interface_listen+0xc8>
   2abc4:	f04f 33ff 	mov.w	r3, #4294967295
   2abc8:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2abcc:	210b      	movs	r1, #11
   2abce:	4628      	mov	r0, r5
   2abd0:	f003 f97a 	bl	2dec8 <ip_interface_wait>
   2abd4:	b170      	cbz	r0, 2abf4 <tls_interface_listen+0xd8>
   2abd6:	f8c4 a000 	str.w	sl, [r4]
   2abda:	2800      	cmp	r0, #0
   2abdc:	dc03      	bgt.n	2abe6 <tls_interface_listen+0xca>
   2abde:	b003      	add	sp, #12
   2abe0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2abe4:	2073      	movs	r0, #115	; 0x73
   2abe6:	f7fc ff3b 	bl	27a60 <bsd_os_errno_set>
   2abea:	f04f 30ff 	mov.w	r0, #4294967295
   2abee:	b003      	add	sp, #12
   2abf0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2abf4:	9901      	ldr	r1, [sp, #4]
   2abf6:	4628      	mov	r0, r5
   2abf8:	f003 feba 	bl	2e970 <ip_interface_listen>
   2abfc:	e7ed      	b.n	2abda <tls_interface_listen+0xbe>
   2abfe:	00ee      	lsls	r6, r5, #3
   2ac00:	4f09      	ldr	r7, [pc, #36]	; (2ac28 <tls_interface_listen+0x10c>)
   2ac02:	1973      	adds	r3, r6, r5
   2ac04:	f817 3023 	ldrb.w	r3, [r7, r3, lsl #2]
   2ac08:	2b02      	cmp	r3, #2
   2ac0a:	d198      	bne.n	2ab3e <tls_interface_listen+0x22>
   2ac0c:	e7a2      	b.n	2ab54 <tls_interface_listen+0x38>
   2ac0e:	f859 1035 	ldr.w	r1, [r9, r5, lsl #3]
   2ac12:	6800      	ldr	r0, [r0, #0]
   2ac14:	f00f f8b3 	bl	39d7e <memcpy>
   2ac18:	e7b6      	b.n	2ab88 <tls_interface_listen+0x6c>
   2ac1a:	200c      	movs	r0, #12
   2ac1c:	e7e3      	b.n	2abe6 <tls_interface_listen+0xca>
   2ac1e:	202d      	movs	r0, #45	; 0x2d
   2ac20:	e7e1      	b.n	2abe6 <tls_interface_listen+0xca>
   2ac22:	2009      	movs	r0, #9
   2ac24:	e7df      	b.n	2abe6 <tls_interface_listen+0xca>
   2ac26:	bf00      	nop
   2ac28:	200209a0 	.word	0x200209a0
   2ac2c:	20020ae4 	.word	0x20020ae4

0002ac30 <tls_interface_accept>:
   2ac30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2ac32:	460c      	mov	r4, r1
   2ac34:	4616      	mov	r6, r2
   2ac36:	461f      	mov	r7, r3
   2ac38:	4605      	mov	r5, r0
   2ac3a:	f004 fdd1 	bl	2f7e0 <interface_socket_from_handle_get>
   2ac3e:	2800      	cmp	r0, #0
   2ac40:	d03b      	beq.n	2acba <tls_interface_accept+0x8a>
   2ac42:	6800      	ldr	r0, [r0, #0]
   2ac44:	b280      	uxth	r0, r0
   2ac46:	2806      	cmp	r0, #6
   2ac48:	d137      	bne.n	2acba <tls_interface_accept+0x8a>
   2ac4a:	4621      	mov	r1, r4
   2ac4c:	463b      	mov	r3, r7
   2ac4e:	4632      	mov	r2, r6
   2ac50:	4628      	mov	r0, r5
   2ac52:	f003 ff03 	bl	2ea5c <ip_interface_accept>
   2ac56:	4604      	mov	r4, r0
   2ac58:	b118      	cbz	r0, 2ac62 <tls_interface_accept+0x32>
   2ac5a:	2c00      	cmp	r4, #0
   2ac5c:	dc2e      	bgt.n	2acbc <tls_interface_accept+0x8c>
   2ac5e:	4620      	mov	r0, r4
   2ac60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2ac62:	4628      	mov	r0, r5
   2ac64:	f004 fdbc 	bl	2f7e0 <interface_socket_from_handle_get>
   2ac68:	6803      	ldr	r3, [r0, #0]
   2ac6a:	4f18      	ldr	r7, [pc, #96]	; (2accc <tls_interface_accept+0x9c>)
   2ac6c:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   2ac70:	6003      	str	r3, [r0, #0]
   2ac72:	6803      	ldr	r3, [r0, #0]
   2ac74:	eb05 05c5 	add.w	r5, r5, r5, lsl #3
   2ac78:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   2ac7c:	4606      	mov	r6, r0
   2ac7e:	6003      	str	r3, [r0, #0]
   2ac80:	eb07 0185 	add.w	r1, r7, r5, lsl #2
   2ac84:	2224      	movs	r2, #36	; 0x24
   2ac86:	4638      	mov	r0, r7
   2ac88:	f00f f879 	bl	39d7e <memcpy>
   2ac8c:	2302      	movs	r3, #2
   2ac8e:	703b      	strb	r3, [r7, #0]
   2ac90:	6833      	ldr	r3, [r6, #0]
   2ac92:	4620      	mov	r0, r4
   2ac94:	0c1b      	lsrs	r3, r3, #16
   2ac96:	041b      	lsls	r3, r3, #16
   2ac98:	f043 030b 	orr.w	r3, r3, #11
   2ac9c:	6033      	str	r3, [r6, #0]
   2ac9e:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2aca2:	f04f 33ff 	mov.w	r3, #4294967295
   2aca6:	210c      	movs	r1, #12
   2aca8:	f003 f90e 	bl	2dec8 <ip_interface_wait>
   2acac:	4604      	mov	r4, r0
   2acae:	2800      	cmp	r0, #0
   2acb0:	d0d5      	beq.n	2ac5e <tls_interface_accept+0x2e>
   2acb2:	2000      	movs	r0, #0
   2acb4:	f003 f9e6 	bl	2e084 <ip_interface_close>
   2acb8:	e7cf      	b.n	2ac5a <tls_interface_accept+0x2a>
   2acba:	2409      	movs	r4, #9
   2acbc:	4620      	mov	r0, r4
   2acbe:	f04f 34ff 	mov.w	r4, #4294967295
   2acc2:	f7fc fecd 	bl	27a60 <bsd_os_errno_set>
   2acc6:	4620      	mov	r0, r4
   2acc8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2acca:	bf00      	nop
   2accc:	200209a0 	.word	0x200209a0

0002acd0 <tls_interface_setopt>:
   2acd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2acd4:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
   2acd8:	9e06      	ldr	r6, [sp, #24]
   2acda:	d11e      	bne.n	2ad1a <tls_interface_setopt+0x4a>
   2acdc:	461f      	mov	r7, r3
   2acde:	4605      	mov	r5, r0
   2ace0:	2b00      	cmp	r3, #0
   2ace2:	f000 808c 	beq.w	2adfe <tls_interface_setopt+0x12e>
   2ace6:	4690      	mov	r8, r2
   2ace8:	f004 fd7a 	bl	2f7e0 <interface_socket_from_handle_get>
   2acec:	2800      	cmp	r0, #0
   2acee:	d07b      	beq.n	2ade8 <tls_interface_setopt+0x118>
   2acf0:	6804      	ldr	r4, [r0, #0]
   2acf2:	b2a4      	uxth	r4, r4
   2acf4:	2c02      	cmp	r4, #2
   2acf6:	d007      	beq.n	2ad08 <tls_interface_setopt+0x38>
   2acf8:	6803      	ldr	r3, [r0, #0]
   2acfa:	b29b      	uxth	r3, r3
   2acfc:	2b04      	cmp	r3, #4
   2acfe:	d003      	beq.n	2ad08 <tls_interface_setopt+0x38>
   2ad00:	6803      	ldr	r3, [r0, #0]
   2ad02:	b29b      	uxth	r3, r3
   2ad04:	2b05      	cmp	r3, #5
   2ad06:	d16f      	bne.n	2ade8 <tls_interface_setopt+0x118>
   2ad08:	f108 32ff 	add.w	r2, r8, #4294967295
   2ad0c:	2a04      	cmp	r2, #4
   2ad0e:	d87c      	bhi.n	2ae0a <tls_interface_setopt+0x13a>
   2ad10:	e8df f002 	tbb	[pc, r2]
   2ad14:	41324e24 	.word	0x41324e24
   2ad18:	07          	.byte	0x07
   2ad19:	00          	.byte	0x00
   2ad1a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   2ad1e:	f003 bfd5 	b.w	2eccc <ip_interface_setopt>
   2ad22:	4c3b      	ldr	r4, [pc, #236]	; (2ae10 <tls_interface_setopt+0x140>)
   2ad24:	f854 0035 	ldr.w	r0, [r4, r5, lsl #3]
   2ad28:	b138      	cbz	r0, 2ad3a <tls_interface_setopt+0x6a>
   2ad2a:	f7ff fc47 	bl	2a5bc <nrf_free>
   2ad2e:	2200      	movs	r2, #0
   2ad30:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
   2ad34:	f844 2035 	str.w	r2, [r4, r5, lsl #3]
   2ad38:	605a      	str	r2, [r3, #4]
   2ad3a:	4630      	mov	r0, r6
   2ad3c:	b34e      	cbz	r6, 2ad92 <tls_interface_setopt+0xc2>
   2ad3e:	f7ff fc33 	bl	2a5a8 <nrf_malloc>
   2ad42:	f844 0035 	str.w	r0, [r4, r5, lsl #3]
   2ad46:	2800      	cmp	r0, #0
   2ad48:	d057      	beq.n	2adfa <tls_interface_setopt+0x12a>
   2ad4a:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   2ad4e:	4632      	mov	r2, r6
   2ad50:	4639      	mov	r1, r7
   2ad52:	6066      	str	r6, [r4, #4]
   2ad54:	f00f f813 	bl	39d7e <memcpy>
   2ad58:	2000      	movs	r0, #0
   2ad5a:	e01a      	b.n	2ad92 <tls_interface_setopt+0xc2>
   2ad5c:	2e04      	cmp	r6, #4
   2ad5e:	d14a      	bne.n	2adf6 <tls_interface_setopt+0x126>
   2ad60:	6838      	ldr	r0, [r7, #0]
   2ad62:	2800      	cmp	r0, #0
   2ad64:	d039      	beq.n	2adda <tls_interface_setopt+0x10a>
   2ad66:	2801      	cmp	r0, #1
   2ad68:	d145      	bne.n	2adf6 <tls_interface_setopt+0x126>
   2ad6a:	4a2a      	ldr	r2, [pc, #168]	; (2ae14 <tls_interface_setopt+0x144>)
   2ad6c:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   2ad70:	f802 0024 	strb.w	r0, [r2, r4, lsl #2]
   2ad74:	2000      	movs	r0, #0
   2ad76:	e00c      	b.n	2ad92 <tls_interface_setopt+0xc2>
   2ad78:	2e01      	cmp	r6, #1
   2ad7a:	d13c      	bne.n	2adf6 <tls_interface_setopt+0x126>
   2ad7c:	783a      	ldrb	r2, [r7, #0]
   2ad7e:	2000      	movs	r0, #0
   2ad80:	3200      	adds	r2, #0
   2ad82:	bf18      	it	ne
   2ad84:	2201      	movne	r2, #1
   2ad86:	4b23      	ldr	r3, [pc, #140]	; (2ae14 <tls_interface_setopt+0x144>)
   2ad88:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   2ad8c:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   2ad90:	7062      	strb	r2, [r4, #1]
   2ad92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2ad96:	2e04      	cmp	r6, #4
   2ad98:	d12d      	bne.n	2adf6 <tls_interface_setopt+0x126>
   2ad9a:	683a      	ldr	r2, [r7, #0]
   2ad9c:	2a02      	cmp	r2, #2
   2ad9e:	d82a      	bhi.n	2adf6 <tls_interface_setopt+0x126>
   2ada0:	4b1c      	ldr	r3, [pc, #112]	; (2ae14 <tls_interface_setopt+0x144>)
   2ada2:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   2ada6:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   2adaa:	70a2      	strb	r2, [r4, #2]
   2adac:	2000      	movs	r0, #0
   2adae:	e7f0      	b.n	2ad92 <tls_interface_setopt+0xc2>
   2adb0:	ea5f 0c96 	movs.w	ip, r6, lsr #2
   2adb4:	d01f      	beq.n	2adf6 <tls_interface_setopt+0x126>
   2adb6:	f016 0403 	ands.w	r4, r6, #3
   2adba:	d11c      	bne.n	2adf6 <tls_interface_setopt+0x126>
   2adbc:	eb05 05c5 	add.w	r5, r5, r5, lsl #3
   2adc0:	00ad      	lsls	r5, r5, #2
   2adc2:	4b14      	ldr	r3, [pc, #80]	; (2ae14 <tls_interface_setopt+0x144>)
   2adc4:	1d28      	adds	r0, r5, #4
   2adc6:	4418      	add	r0, r3
   2adc8:	442b      	add	r3, r5
   2adca:	4632      	mov	r2, r6
   2adcc:	4639      	mov	r1, r7
   2adce:	f883 c003 	strb.w	ip, [r3, #3]
   2add2:	f00e ffd4 	bl	39d7e <memcpy>
   2add6:	4620      	mov	r0, r4
   2add8:	e7db      	b.n	2ad92 <tls_interface_setopt+0xc2>
   2adda:	2102      	movs	r1, #2
   2addc:	4a0d      	ldr	r2, [pc, #52]	; (2ae14 <tls_interface_setopt+0x144>)
   2adde:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   2ade2:	f802 1024 	strb.w	r1, [r2, r4, lsl #2]
   2ade6:	e7d4      	b.n	2ad92 <tls_interface_setopt+0xc2>
   2ade8:	2009      	movs	r0, #9
   2adea:	f7fc fe39 	bl	27a60 <bsd_os_errno_set>
   2adee:	f04f 30ff 	mov.w	r0, #4294967295
   2adf2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2adf6:	2016      	movs	r0, #22
   2adf8:	e7f7      	b.n	2adea <tls_interface_setopt+0x11a>
   2adfa:	200c      	movs	r0, #12
   2adfc:	e7f5      	b.n	2adea <tls_interface_setopt+0x11a>
   2adfe:	200e      	movs	r0, #14
   2ae00:	f7fc fe2e 	bl	27a60 <bsd_os_errno_set>
   2ae04:	f04f 30ff 	mov.w	r0, #4294967295
   2ae08:	e7c3      	b.n	2ad92 <tls_interface_setopt+0xc2>
   2ae0a:	202a      	movs	r0, #42	; 0x2a
   2ae0c:	e7ed      	b.n	2adea <tls_interface_setopt+0x11a>
   2ae0e:	bf00      	nop
   2ae10:	20020ae4 	.word	0x20020ae4
   2ae14:	200209a0 	.word	0x200209a0

0002ae18 <tls_interface_getopt>:
   2ae18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2ae1c:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
   2ae20:	9f06      	ldr	r7, [sp, #24]
   2ae22:	d112      	bne.n	2ae4a <tls_interface_getopt+0x32>
   2ae24:	461d      	mov	r5, r3
   2ae26:	b16b      	cbz	r3, 2ae44 <tls_interface_getopt+0x2c>
   2ae28:	b167      	cbz	r7, 2ae44 <tls_interface_getopt+0x2c>
   2ae2a:	4606      	mov	r6, r0
   2ae2c:	4614      	mov	r4, r2
   2ae2e:	f004 fcd7 	bl	2f7e0 <interface_socket_from_handle_get>
   2ae32:	2800      	cmp	r0, #0
   2ae34:	d04f      	beq.n	2aed6 <tls_interface_getopt+0xbe>
   2ae36:	3c01      	subs	r4, #1
   2ae38:	2c03      	cmp	r4, #3
   2ae3a:	d852      	bhi.n	2aee2 <tls_interface_getopt+0xca>
   2ae3c:	e8df f004 	tbb	[pc, r4]
   2ae40:	09152139 	.word	0x09152139
   2ae44:	200e      	movs	r0, #14
   2ae46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2ae4a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   2ae4e:	f003 bff9 	b.w	2ee44 <ip_interface_getopt>
   2ae52:	683b      	ldr	r3, [r7, #0]
   2ae54:	2b04      	cmp	r3, #4
   2ae56:	d13c      	bne.n	2aed2 <tls_interface_getopt+0xba>
   2ae58:	4b23      	ldr	r3, [pc, #140]	; (2aee8 <tls_interface_getopt+0xd0>)
   2ae5a:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   2ae5e:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   2ae62:	78b3      	ldrb	r3, [r6, #2]
   2ae64:	2000      	movs	r0, #0
   2ae66:	602b      	str	r3, [r5, #0]
   2ae68:	e7ed      	b.n	2ae46 <tls_interface_getopt+0x2e>
   2ae6a:	683b      	ldr	r3, [r7, #0]
   2ae6c:	2b01      	cmp	r3, #1
   2ae6e:	d130      	bne.n	2aed2 <tls_interface_getopt+0xba>
   2ae70:	4b1d      	ldr	r3, [pc, #116]	; (2aee8 <tls_interface_getopt+0xd0>)
   2ae72:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   2ae76:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   2ae7a:	7873      	ldrb	r3, [r6, #1]
   2ae7c:	2000      	movs	r0, #0
   2ae7e:	702b      	strb	r3, [r5, #0]
   2ae80:	e7e1      	b.n	2ae46 <tls_interface_getopt+0x2e>
   2ae82:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   2ae86:	4918      	ldr	r1, [pc, #96]	; (2aee8 <tls_interface_getopt+0xd0>)
   2ae88:	683b      	ldr	r3, [r7, #0]
   2ae8a:	00b6      	lsls	r6, r6, #2
   2ae8c:	198a      	adds	r2, r1, r6
   2ae8e:	f013 0403 	ands.w	r4, r3, #3
   2ae92:	78d0      	ldrb	r0, [r2, #3]
   2ae94:	d121      	bne.n	2aeda <tls_interface_getopt+0xc2>
   2ae96:	089b      	lsrs	r3, r3, #2
   2ae98:	4283      	cmp	r3, r0
   2ae9a:	bf28      	it	cs
   2ae9c:	4603      	movcs	r3, r0
   2ae9e:	009a      	lsls	r2, r3, #2
   2aea0:	b1db      	cbz	r3, 2aeda <tls_interface_getopt+0xc2>
   2aea2:	3604      	adds	r6, #4
   2aea4:	4431      	add	r1, r6
   2aea6:	603a      	str	r2, [r7, #0]
   2aea8:	4628      	mov	r0, r5
   2aeaa:	f00e ff68 	bl	39d7e <memcpy>
   2aeae:	4620      	mov	r0, r4
   2aeb0:	e7c9      	b.n	2ae46 <tls_interface_getopt+0x2e>
   2aeb2:	683b      	ldr	r3, [r7, #0]
   2aeb4:	2b04      	cmp	r3, #4
   2aeb6:	d10c      	bne.n	2aed2 <tls_interface_getopt+0xba>
   2aeb8:	4b0b      	ldr	r3, [pc, #44]	; (2aee8 <tls_interface_getopt+0xd0>)
   2aeba:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   2aebe:	f813 3026 	ldrb.w	r3, [r3, r6, lsl #2]
   2aec2:	2000      	movs	r0, #0
   2aec4:	f1a3 0301 	sub.w	r3, r3, #1
   2aec8:	fab3 f383 	clz	r3, r3
   2aecc:	095b      	lsrs	r3, r3, #5
   2aece:	602b      	str	r3, [r5, #0]
   2aed0:	e7b9      	b.n	2ae46 <tls_interface_getopt+0x2e>
   2aed2:	2016      	movs	r0, #22
   2aed4:	e7b7      	b.n	2ae46 <tls_interface_getopt+0x2e>
   2aed6:	2009      	movs	r0, #9
   2aed8:	e7b5      	b.n	2ae46 <tls_interface_getopt+0x2e>
   2aeda:	2800      	cmp	r0, #0
   2aedc:	d1f9      	bne.n	2aed2 <tls_interface_getopt+0xba>
   2aede:	6038      	str	r0, [r7, #0]
   2aee0:	e7b1      	b.n	2ae46 <tls_interface_getopt+0x2e>
   2aee2:	202a      	movs	r0, #42	; 0x2a
   2aee4:	e7af      	b.n	2ae46 <tls_interface_getopt+0x2e>
   2aee6:	bf00      	nop
   2aee8:	200209a0 	.word	0x200209a0

0002aeec <tls_rpc_ip_event_handler>:
   2aeec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2aeee:	f248 0581 	movw	r5, #32897	; 0x8081
   2aef2:	42ab      	cmp	r3, r5
   2aef4:	460c      	mov	r4, r1
   2aef6:	d062      	beq.n	2afbe <tls_rpc_ip_event_handler+0xd2>
   2aef8:	f249 0182 	movw	r1, #36994	; 0x9082
   2aefc:	428b      	cmp	r3, r1
   2aefe:	4606      	mov	r6, r0
   2af00:	d02e      	beq.n	2af60 <tls_rpc_ip_event_handler+0x74>
   2af02:	f248 0102 	movw	r1, #32770	; 0x8002
   2af06:	428b      	cmp	r3, r1
   2af08:	d001      	beq.n	2af0e <tls_rpc_ip_event_handler+0x22>
   2af0a:	2001      	movs	r0, #1
   2af0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2af0e:	2c00      	cmp	r4, #0
   2af10:	d0fb      	beq.n	2af0a <tls_rpc_ip_event_handler+0x1e>
   2af12:	6963      	ldr	r3, [r4, #20]
   2af14:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
   2af18:	d002      	beq.n	2af20 <tls_rpc_ip_event_handler+0x34>
   2af1a:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   2af1e:	d1f4      	bne.n	2af0a <tls_rpc_ip_event_handler+0x1e>
   2af20:	6823      	ldr	r3, [r4, #0]
   2af22:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   2af26:	6023      	str	r3, [r4, #0]
   2af28:	6955      	ldr	r5, [r2, #20]
   2af2a:	2d00      	cmp	r5, #0
   2af2c:	d156      	bne.n	2afdc <tls_rpc_ip_event_handler+0xf0>
   2af2e:	6823      	ldr	r3, [r4, #0]
   2af30:	0c1b      	lsrs	r3, r3, #16
   2af32:	041b      	lsls	r3, r3, #16
   2af34:	f043 0305 	orr.w	r3, r3, #5
   2af38:	6023      	str	r3, [r4, #0]
   2af3a:	6823      	ldr	r3, [r4, #0]
   2af3c:	00da      	lsls	r2, r3, #3
   2af3e:	d50d      	bpl.n	2af5c <tls_rpc_ip_event_handler+0x70>
   2af40:	4b2b      	ldr	r3, [pc, #172]	; (2aff0 <tls_rpc_ip_event_handler+0x104>)
   2af42:	eb06 02c6 	add.w	r2, r6, r6, lsl #3
   2af46:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   2af4a:	2b02      	cmp	r3, #2
   2af4c:	d106      	bne.n	2af5c <tls_rpc_ip_event_handler+0x70>
   2af4e:	4630      	mov	r0, r6
   2af50:	4621      	mov	r1, r4
   2af52:	f7ff fb9b 	bl	2a68c <secure_client_socket>
   2af56:	b108      	cbz	r0, 2af5c <tls_rpc_ip_event_handler+0x70>
   2af58:	2873      	cmp	r0, #115	; 0x73
   2af5a:	d142      	bne.n	2afe2 <tls_rpc_ip_event_handler+0xf6>
   2af5c:	2000      	movs	r0, #0
   2af5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2af60:	2c00      	cmp	r4, #0
   2af62:	d0fb      	beq.n	2af5c <tls_rpc_ip_event_handler+0x70>
   2af64:	6823      	ldr	r3, [r4, #0]
   2af66:	b29b      	uxth	r3, r3
   2af68:	2b0b      	cmp	r3, #11
   2af6a:	d1f7      	bne.n	2af5c <tls_rpc_ip_event_handler+0x70>
   2af6c:	6915      	ldr	r5, [r2, #16]
   2af6e:	2d00      	cmp	r5, #0
   2af70:	d134      	bne.n	2afdc <tls_rpc_ip_event_handler+0xf0>
   2af72:	6823      	ldr	r3, [r4, #0]
   2af74:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   2af78:	6023      	str	r3, [r4, #0]
   2af7a:	6823      	ldr	r3, [r4, #0]
   2af7c:	00db      	lsls	r3, r3, #3
   2af7e:	d5ed      	bpl.n	2af5c <tls_rpc_ip_event_handler+0x70>
   2af80:	4f1c      	ldr	r7, [pc, #112]	; (2aff4 <tls_rpc_ip_event_handler+0x108>)
   2af82:	f857 0030 	ldr.w	r0, [r7, r0, lsl #3]
   2af86:	b130      	cbz	r0, 2af96 <tls_rpc_ip_event_handler+0xaa>
   2af88:	f7ff fb18 	bl	2a5bc <nrf_free>
   2af8c:	eb07 03c6 	add.w	r3, r7, r6, lsl #3
   2af90:	f847 5036 	str.w	r5, [r7, r6, lsl #3]
   2af94:	605d      	str	r5, [r3, #4]
   2af96:	6823      	ldr	r3, [r4, #0]
   2af98:	2000      	movs	r0, #0
   2af9a:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   2af9e:	6023      	str	r3, [r4, #0]
   2afa0:	6823      	ldr	r3, [r4, #0]
   2afa2:	0c1b      	lsrs	r3, r3, #16
   2afa4:	041b      	lsls	r3, r3, #16
   2afa6:	f043 030c 	orr.w	r3, r3, #12
   2afaa:	6023      	str	r3, [r4, #0]
   2afac:	6823      	ldr	r3, [r4, #0]
   2afae:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2afb2:	6023      	str	r3, [r4, #0]
   2afb4:	6823      	ldr	r3, [r4, #0]
   2afb6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   2afba:	6023      	str	r3, [r4, #0]
   2afbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2afbe:	2900      	cmp	r1, #0
   2afc0:	d0cc      	beq.n	2af5c <tls_rpc_ip_event_handler+0x70>
   2afc2:	680b      	ldr	r3, [r1, #0]
   2afc4:	b29b      	uxth	r3, r3
   2afc6:	2b0a      	cmp	r3, #10
   2afc8:	d1c8      	bne.n	2af5c <tls_rpc_ip_event_handler+0x70>
   2afca:	6950      	ldr	r0, [r2, #20]
   2afcc:	b938      	cbnz	r0, 2afde <tls_rpc_ip_event_handler+0xf2>
   2afce:	680b      	ldr	r3, [r1, #0]
   2afd0:	0c1b      	lsrs	r3, r3, #16
   2afd2:	041b      	lsls	r3, r3, #16
   2afd4:	f043 030b 	orr.w	r3, r3, #11
   2afd8:	600b      	str	r3, [r1, #0]
   2afda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2afdc:	4628      	mov	r0, r5
   2afde:	f002 ff35 	bl	2de4c <rpc_error_to_nrf_bsd_error>
   2afe2:	6060      	str	r0, [r4, #4]
   2afe4:	6823      	ldr	r3, [r4, #0]
   2afe6:	2000      	movs	r0, #0
   2afe8:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   2afec:	6023      	str	r3, [r4, #0]
   2afee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2aff0:	200209a0 	.word	0x200209a0
   2aff4:	20020ae4 	.word	0x20020ae4

0002aff8 <rpc_dfu_event_handler>:
   2aff8:	b508      	push	{r3, lr}
   2affa:	4a08      	ldr	r2, [pc, #32]	; (2b01c <rpc_dfu_event_handler+0x24>)
   2affc:	68c1      	ldr	r1, [r0, #12]
   2affe:	8812      	ldrh	r2, [r2, #0]
   2b000:	4603      	mov	r3, r0
   2b002:	ebb2 4f11 	cmp.w	r2, r1, lsr #16
   2b006:	d005      	beq.n	2b014 <rpc_dfu_event_handler+0x1c>
   2b008:	6800      	ldr	r0, [r0, #0]
   2b00a:	b110      	cbz	r0, 2b012 <rpc_dfu_event_handler+0x1a>
   2b00c:	f7fe ff06 	bl	29e1c <rpc_dfu_client_data_free>
   2b010:	2000      	movs	r0, #0
   2b012:	bd08      	pop	{r3, pc}
   2b014:	4a02      	ldr	r2, [pc, #8]	; (2b020 <rpc_dfu_event_handler+0x28>)
   2b016:	2001      	movs	r0, #1
   2b018:	6013      	str	r3, [r2, #0]
   2b01a:	bd08      	pop	{r3, pc}
   2b01c:	20022294 	.word	0x20022294
   2b020:	20020b30 	.word	0x20020b30

0002b024 <mfu_interface_init>:
   2b024:	2300      	movs	r3, #0
   2b026:	b510      	push	{r4, lr}
   2b028:	4808      	ldr	r0, [pc, #32]	; (2b04c <mfu_interface_init+0x28>)
   2b02a:	4909      	ldr	r1, [pc, #36]	; (2b050 <mfu_interface_init+0x2c>)
   2b02c:	4a09      	ldr	r2, [pc, #36]	; (2b054 <mfu_interface_init+0x30>)
   2b02e:	4c0a      	ldr	r4, [pc, #40]	; (2b058 <mfu_interface_init+0x34>)
   2b030:	8003      	strh	r3, [r0, #0]
   2b032:	600b      	str	r3, [r1, #0]
   2b034:	6013      	str	r3, [r2, #0]
   2b036:	6023      	str	r3, [r4, #0]
   2b038:	f7fe feba 	bl	29db0 <rpc_dfu_client_init>
   2b03c:	b910      	cbnz	r0, 2b044 <mfu_interface_init+0x20>
   2b03e:	2301      	movs	r3, #1
   2b040:	6023      	str	r3, [r4, #0]
   2b042:	bd10      	pop	{r4, pc}
   2b044:	f04f 30ff 	mov.w	r0, #4294967295
   2b048:	bd10      	pop	{r4, pc}
   2b04a:	bf00      	nop
   2b04c:	20022294 	.word	0x20022294
   2b050:	20020b30 	.word	0x20020b30
   2b054:	20020b2c 	.word	0x20020b2c
   2b058:	20020b24 	.word	0x20020b24

0002b05c <mfu_interface_open>:
   2b05c:	b508      	push	{r3, lr}
   2b05e:	4b07      	ldr	r3, [pc, #28]	; (2b07c <mfu_interface_open+0x20>)
   2b060:	681a      	ldr	r2, [r3, #0]
   2b062:	2a01      	cmp	r2, #1
   2b064:	d103      	bne.n	2b06e <mfu_interface_open+0x12>
   2b066:	2202      	movs	r2, #2
   2b068:	601a      	str	r2, [r3, #0]
   2b06a:	4805      	ldr	r0, [pc, #20]	; (2b080 <mfu_interface_open+0x24>)
   2b06c:	bd08      	pop	{r3, pc}
   2b06e:	2001      	movs	r0, #1
   2b070:	f7fc fcf6 	bl	27a60 <bsd_os_errno_set>
   2b074:	f04f 30ff 	mov.w	r0, #4294967295
   2b078:	bd08      	pop	{r3, pc}
   2b07a:	bf00      	nop
   2b07c:	20020b24 	.word	0x20020b24
   2b080:	49765432 	.word	0x49765432

0002b084 <mfu_interface_close>:
   2b084:	b5f0      	push	{r4, r5, r6, r7, lr}
   2b086:	4c32      	ldr	r4, [pc, #200]	; (2b150 <mfu_interface_close+0xcc>)
   2b088:	b083      	sub	sp, #12
   2b08a:	6823      	ldr	r3, [r4, #0]
   2b08c:	1e9a      	subs	r2, r3, #2
   2b08e:	2a01      	cmp	r2, #1
   2b090:	d857      	bhi.n	2b142 <mfu_interface_close+0xbe>
   2b092:	2b03      	cmp	r3, #3
   2b094:	d004      	beq.n	2b0a0 <mfu_interface_close+0x1c>
   2b096:	2301      	movs	r3, #1
   2b098:	2000      	movs	r0, #0
   2b09a:	6023      	str	r3, [r4, #0]
   2b09c:	b003      	add	sp, #12
   2b09e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2b0a0:	2100      	movs	r1, #0
   2b0a2:	4668      	mov	r0, sp
   2b0a4:	f7fe fe8a 	bl	29dbc <rpc_dfu_client_request_alloc>
   2b0a8:	4603      	mov	r3, r0
   2b0aa:	2800      	cmp	r0, #0
   2b0ac:	d13d      	bne.n	2b12a <mfu_interface_close+0xa6>
   2b0ae:	2104      	movs	r1, #4
   2b0b0:	4e28      	ldr	r6, [pc, #160]	; (2b154 <mfu_interface_close+0xd0>)
   2b0b2:	9800      	ldr	r0, [sp, #0]
   2b0b4:	8832      	ldrh	r2, [r6, #0]
   2b0b6:	7201      	strb	r1, [r0, #8]
   2b0b8:	3201      	adds	r2, #1
   2b0ba:	b292      	uxth	r2, r2
   2b0bc:	0411      	lsls	r1, r2, #16
   2b0be:	f041 0106 	orr.w	r1, r1, #6
   2b0c2:	4d25      	ldr	r5, [pc, #148]	; (2b158 <mfu_interface_close+0xd4>)
   2b0c4:	60c1      	str	r1, [r0, #12]
   2b0c6:	7103      	strb	r3, [r0, #4]
   2b0c8:	7143      	strb	r3, [r0, #5]
   2b0ca:	7183      	strb	r3, [r0, #6]
   2b0cc:	71c3      	strb	r3, [r0, #7]
   2b0ce:	7243      	strb	r3, [r0, #9]
   2b0d0:	7283      	strb	r3, [r0, #10]
   2b0d2:	72c3      	strb	r3, [r0, #11]
   2b0d4:	2106      	movs	r1, #6
   2b0d6:	8032      	strh	r2, [r6, #0]
   2b0d8:	602b      	str	r3, [r5, #0]
   2b0da:	f7fe fe83 	bl	29de4 <rpc_dfu_client_request_send>
   2b0de:	b9d8      	cbnz	r0, 2b118 <mfu_interface_close+0x94>
   2b0e0:	f04f 33ff 	mov.w	r3, #4294967295
   2b0e4:	ae02      	add	r6, sp, #8
   2b0e6:	4627      	mov	r7, r4
   2b0e8:	f846 3d04 	str.w	r3, [r6, #-4]!
   2b0ec:	e004      	b.n	2b0f8 <mfu_interface_close+0x74>
   2b0ee:	4631      	mov	r1, r6
   2b0f0:	4638      	mov	r0, r7
   2b0f2:	f7fc fc21 	bl	27938 <bsd_os_timedwait>
   2b0f6:	b9f0      	cbnz	r0, 2b136 <mfu_interface_close+0xb2>
   2b0f8:	6828      	ldr	r0, [r5, #0]
   2b0fa:	2800      	cmp	r0, #0
   2b0fc:	d0f7      	beq.n	2b0ee <mfu_interface_close+0x6a>
   2b0fe:	6905      	ldr	r5, [r0, #16]
   2b100:	f7fe fe84 	bl	29e0c <rpc_dfu_client_message_free>
   2b104:	2d00      	cmp	r5, #0
   2b106:	d0c6      	beq.n	2b096 <mfu_interface_close+0x12>
   2b108:	4b14      	ldr	r3, [pc, #80]	; (2b15c <mfu_interface_close+0xd8>)
   2b10a:	2008      	movs	r0, #8
   2b10c:	601d      	str	r5, [r3, #0]
   2b10e:	f7fc fca7 	bl	27a60 <bsd_os_errno_set>
   2b112:	f04f 30ff 	mov.w	r0, #4294967295
   2b116:	e7c1      	b.n	2b09c <mfu_interface_close+0x18>
   2b118:	9800      	ldr	r0, [sp, #0]
   2b11a:	6803      	ldr	r3, [r0, #0]
   2b11c:	b11b      	cbz	r3, 2b126 <mfu_interface_close+0xa2>
   2b11e:	4618      	mov	r0, r3
   2b120:	f7fe fe7c 	bl	29e1c <rpc_dfu_client_data_free>
   2b124:	9800      	ldr	r0, [sp, #0]
   2b126:	f7fe fe71 	bl	29e0c <rpc_dfu_client_message_free>
   2b12a:	200c      	movs	r0, #12
   2b12c:	f7fc fc98 	bl	27a60 <bsd_os_errno_set>
   2b130:	f04f 30ff 	mov.w	r0, #4294967295
   2b134:	e7b2      	b.n	2b09c <mfu_interface_close+0x18>
   2b136:	203c      	movs	r0, #60	; 0x3c
   2b138:	f7fc fc92 	bl	27a60 <bsd_os_errno_set>
   2b13c:	f04f 30ff 	mov.w	r0, #4294967295
   2b140:	e7ac      	b.n	2b09c <mfu_interface_close+0x18>
   2b142:	2001      	movs	r0, #1
   2b144:	f7fc fc8c 	bl	27a60 <bsd_os_errno_set>
   2b148:	f04f 30ff 	mov.w	r0, #4294967295
   2b14c:	e7a6      	b.n	2b09c <mfu_interface_close+0x18>
   2b14e:	bf00      	nop
   2b150:	20020b24 	.word	0x20020b24
   2b154:	20022294 	.word	0x20022294
   2b158:	20020b30 	.word	0x20020b30
   2b15c:	20020b28 	.word	0x20020b28

0002b160 <mfu_interface_sendto>:
   2b160:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2b164:	4e64      	ldr	r6, [pc, #400]	; (2b2f8 <mfu_interface_sendto+0x198>)
   2b166:	460f      	mov	r7, r1
   2b168:	6831      	ldr	r1, [r6, #0]
   2b16a:	4615      	mov	r5, r2
   2b16c:	1e8a      	subs	r2, r1, #2
   2b16e:	2a01      	cmp	r2, #1
   2b170:	b082      	sub	sp, #8
   2b172:	f200 80b4 	bhi.w	2b2de <mfu_interface_sendto+0x17e>
   2b176:	2f00      	cmp	r7, #0
   2b178:	f000 80a5 	beq.w	2b2c6 <mfu_interface_sendto+0x166>
   2b17c:	2d00      	cmp	r5, #0
   2b17e:	f000 80a2 	beq.w	2b2c6 <mfu_interface_sendto+0x166>
   2b182:	2b00      	cmp	r3, #0
   2b184:	f040 80b1 	bne.w	2b2ea <mfu_interface_sendto+0x18a>
   2b188:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2b18a:	2b00      	cmp	r3, #0
   2b18c:	f040 80a1 	bne.w	2b2d2 <mfu_interface_sendto+0x172>
   2b190:	2902      	cmp	r1, #2
   2b192:	d04f      	beq.n	2b234 <mfu_interface_sendto+0xd4>
   2b194:	46e8      	mov	r8, sp
   2b196:	4640      	mov	r0, r8
   2b198:	4629      	mov	r1, r5
   2b19a:	f7fe fe0f 	bl	29dbc <rpc_dfu_client_request_alloc>
   2b19e:	4606      	mov	r6, r0
   2b1a0:	b140      	cbz	r0, 2b1b4 <mfu_interface_sendto+0x54>
   2b1a2:	200c      	movs	r0, #12
   2b1a4:	f7fc fc5c 	bl	27a60 <bsd_os_errno_set>
   2b1a8:	f04f 35ff 	mov.w	r5, #4294967295
   2b1ac:	4628      	mov	r0, r5
   2b1ae:	b002      	add	sp, #8
   2b1b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2b1b4:	9b00      	ldr	r3, [sp, #0]
   2b1b6:	4639      	mov	r1, r7
   2b1b8:	6818      	ldr	r0, [r3, #0]
   2b1ba:	462a      	mov	r2, r5
   2b1bc:	f00e fddf 	bl	39d7e <memcpy>
   2b1c0:	2104      	movs	r1, #4
   2b1c2:	4c4e      	ldr	r4, [pc, #312]	; (2b2fc <mfu_interface_sendto+0x19c>)
   2b1c4:	9800      	ldr	r0, [sp, #0]
   2b1c6:	8823      	ldrh	r3, [r4, #0]
   2b1c8:	6045      	str	r5, [r0, #4]
   2b1ca:	3301      	adds	r3, #1
   2b1cc:	b29b      	uxth	r3, r3
   2b1ce:	041a      	lsls	r2, r3, #16
   2b1d0:	8023      	strh	r3, [r4, #0]
   2b1d2:	430a      	orrs	r2, r1
   2b1d4:	4c4a      	ldr	r4, [pc, #296]	; (2b300 <mfu_interface_sendto+0x1a0>)
   2b1d6:	60c2      	str	r2, [r0, #12]
   2b1d8:	7246      	strb	r6, [r0, #9]
   2b1da:	7286      	strb	r6, [r0, #10]
   2b1dc:	72c6      	strb	r6, [r0, #11]
   2b1de:	7201      	strb	r1, [r0, #8]
   2b1e0:	6026      	str	r6, [r4, #0]
   2b1e2:	f7fe fdff 	bl	29de4 <rpc_dfu_client_request_send>
   2b1e6:	2800      	cmp	r0, #0
   2b1e8:	d163      	bne.n	2b2b2 <mfu_interface_sendto+0x152>
   2b1ea:	f04f 33ff 	mov.w	r3, #4294967295
   2b1ee:	ae02      	add	r6, sp, #8
   2b1f0:	4f41      	ldr	r7, [pc, #260]	; (2b2f8 <mfu_interface_sendto+0x198>)
   2b1f2:	f846 3d04 	str.w	r3, [r6, #-4]!
   2b1f6:	e004      	b.n	2b202 <mfu_interface_sendto+0xa2>
   2b1f8:	4631      	mov	r1, r6
   2b1fa:	4638      	mov	r0, r7
   2b1fc:	f7fc fb9c 	bl	27938 <bsd_os_timedwait>
   2b200:	b978      	cbnz	r0, 2b222 <mfu_interface_sendto+0xc2>
   2b202:	6820      	ldr	r0, [r4, #0]
   2b204:	2800      	cmp	r0, #0
   2b206:	d0f7      	beq.n	2b1f8 <mfu_interface_sendto+0x98>
   2b208:	6904      	ldr	r4, [r0, #16]
   2b20a:	f7fe fdff 	bl	29e0c <rpc_dfu_client_message_free>
   2b20e:	2c00      	cmp	r4, #0
   2b210:	d0cc      	beq.n	2b1ac <mfu_interface_sendto+0x4c>
   2b212:	4b3c      	ldr	r3, [pc, #240]	; (2b304 <mfu_interface_sendto+0x1a4>)
   2b214:	2008      	movs	r0, #8
   2b216:	601c      	str	r4, [r3, #0]
   2b218:	f04f 35ff 	mov.w	r5, #4294967295
   2b21c:	f7fc fc20 	bl	27a60 <bsd_os_errno_set>
   2b220:	e7c4      	b.n	2b1ac <mfu_interface_sendto+0x4c>
   2b222:	f04f 35ff 	mov.w	r5, #4294967295
   2b226:	203c      	movs	r0, #60	; 0x3c
   2b228:	f7fc fc1a 	bl	27a60 <bsd_os_errno_set>
   2b22c:	4628      	mov	r0, r5
   2b22e:	b002      	add	sp, #8
   2b230:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2b234:	46e8      	mov	r8, sp
   2b236:	4619      	mov	r1, r3
   2b238:	4640      	mov	r0, r8
   2b23a:	f7fe fdbf 	bl	29dbc <rpc_dfu_client_request_alloc>
   2b23e:	4602      	mov	r2, r0
   2b240:	2800      	cmp	r0, #0
   2b242:	d1ae      	bne.n	2b1a2 <mfu_interface_sendto+0x42>
   2b244:	f04f 0c08 	mov.w	ip, #8
   2b248:	492c      	ldr	r1, [pc, #176]	; (2b2fc <mfu_interface_sendto+0x19c>)
   2b24a:	482f      	ldr	r0, [pc, #188]	; (2b308 <mfu_interface_sendto+0x1a8>)
   2b24c:	880b      	ldrh	r3, [r1, #0]
   2b24e:	6804      	ldr	r4, [r0, #0]
   2b250:	3301      	adds	r3, #1
   2b252:	9800      	ldr	r0, [sp, #0]
   2b254:	b29b      	uxth	r3, r3
   2b256:	800b      	strh	r3, [r1, #0]
   2b258:	041b      	lsls	r3, r3, #16
   2b25a:	f043 0303 	orr.w	r3, r3, #3
   2b25e:	6104      	str	r4, [r0, #16]
   2b260:	4c27      	ldr	r4, [pc, #156]	; (2b300 <mfu_interface_sendto+0x1a0>)
   2b262:	60c3      	str	r3, [r0, #12]
   2b264:	7102      	strb	r2, [r0, #4]
   2b266:	7142      	strb	r2, [r0, #5]
   2b268:	7182      	strb	r2, [r0, #6]
   2b26a:	71c2      	strb	r2, [r0, #7]
   2b26c:	7242      	strb	r2, [r0, #9]
   2b26e:	7282      	strb	r2, [r0, #10]
   2b270:	72c2      	strb	r2, [r0, #11]
   2b272:	f880 c008 	strb.w	ip, [r0, #8]
   2b276:	2103      	movs	r1, #3
   2b278:	6022      	str	r2, [r4, #0]
   2b27a:	f7fe fdb3 	bl	29de4 <rpc_dfu_client_request_send>
   2b27e:	b9c0      	cbnz	r0, 2b2b2 <mfu_interface_sendto+0x152>
   2b280:	f04f 33ff 	mov.w	r3, #4294967295
   2b284:	f10d 0908 	add.w	r9, sp, #8
   2b288:	f849 3d04 	str.w	r3, [r9, #-4]!
   2b28c:	46b2      	mov	sl, r6
   2b28e:	e005      	b.n	2b29c <mfu_interface_sendto+0x13c>
   2b290:	4649      	mov	r1, r9
   2b292:	4650      	mov	r0, sl
   2b294:	f7fc fb50 	bl	27938 <bsd_os_timedwait>
   2b298:	2800      	cmp	r0, #0
   2b29a:	d1c2      	bne.n	2b222 <mfu_interface_sendto+0xc2>
   2b29c:	6820      	ldr	r0, [r4, #0]
   2b29e:	2800      	cmp	r0, #0
   2b2a0:	d0f6      	beq.n	2b290 <mfu_interface_sendto+0x130>
   2b2a2:	6904      	ldr	r4, [r0, #16]
   2b2a4:	f7fe fdb2 	bl	29e0c <rpc_dfu_client_message_free>
   2b2a8:	2c00      	cmp	r4, #0
   2b2aa:	d1b2      	bne.n	2b212 <mfu_interface_sendto+0xb2>
   2b2ac:	2303      	movs	r3, #3
   2b2ae:	6033      	str	r3, [r6, #0]
   2b2b0:	e771      	b.n	2b196 <mfu_interface_sendto+0x36>
   2b2b2:	9800      	ldr	r0, [sp, #0]
   2b2b4:	6803      	ldr	r3, [r0, #0]
   2b2b6:	b11b      	cbz	r3, 2b2c0 <mfu_interface_sendto+0x160>
   2b2b8:	4618      	mov	r0, r3
   2b2ba:	f7fe fdaf 	bl	29e1c <rpc_dfu_client_data_free>
   2b2be:	9800      	ldr	r0, [sp, #0]
   2b2c0:	f7fe fda4 	bl	29e0c <rpc_dfu_client_message_free>
   2b2c4:	e76d      	b.n	2b1a2 <mfu_interface_sendto+0x42>
   2b2c6:	2016      	movs	r0, #22
   2b2c8:	f7fc fbca 	bl	27a60 <bsd_os_errno_set>
   2b2cc:	f04f 35ff 	mov.w	r5, #4294967295
   2b2d0:	e76c      	b.n	2b1ac <mfu_interface_sendto+0x4c>
   2b2d2:	2038      	movs	r0, #56	; 0x38
   2b2d4:	f7fc fbc4 	bl	27a60 <bsd_os_errno_set>
   2b2d8:	f04f 35ff 	mov.w	r5, #4294967295
   2b2dc:	e766      	b.n	2b1ac <mfu_interface_sendto+0x4c>
   2b2de:	2001      	movs	r0, #1
   2b2e0:	f7fc fbbe 	bl	27a60 <bsd_os_errno_set>
   2b2e4:	f04f 35ff 	mov.w	r5, #4294967295
   2b2e8:	e760      	b.n	2b1ac <mfu_interface_sendto+0x4c>
   2b2ea:	202d      	movs	r0, #45	; 0x2d
   2b2ec:	f7fc fbb8 	bl	27a60 <bsd_os_errno_set>
   2b2f0:	f04f 35ff 	mov.w	r5, #4294967295
   2b2f4:	e75a      	b.n	2b1ac <mfu_interface_sendto+0x4c>
   2b2f6:	bf00      	nop
   2b2f8:	20020b24 	.word	0x20020b24
   2b2fc:	20022294 	.word	0x20022294
   2b300:	20020b30 	.word	0x20020b30
   2b304:	20020b28 	.word	0x20020b28
   2b308:	20020b2c 	.word	0x20020b2c

0002b30c <mfu_interface_setopt>:
   2b30c:	b5f0      	push	{r4, r5, r6, r7, lr}
   2b30e:	4846      	ldr	r0, [pc, #280]	; (2b428 <mfu_interface_setopt+0x11c>)
   2b310:	b083      	sub	sp, #12
   2b312:	6800      	ldr	r0, [r0, #0]
   2b314:	3802      	subs	r0, #2
   2b316:	2801      	cmp	r0, #1
   2b318:	d877      	bhi.n	2b40a <mfu_interface_setopt+0xfe>
   2b31a:	f240 2003 	movw	r0, #515	; 0x203
   2b31e:	4281      	cmp	r1, r0
   2b320:	d16d      	bne.n	2b3fe <mfu_interface_setopt+0xf2>
   2b322:	3a04      	subs	r2, #4
   2b324:	2a03      	cmp	r2, #3
   2b326:	d85c      	bhi.n	2b3e2 <mfu_interface_setopt+0xd6>
   2b328:	e8df f002 	tbb	[pc, r2]
   2b32c:	514e024b 	.word	0x514e024b
   2b330:	2407      	movs	r4, #7
   2b332:	4625      	mov	r5, r4
   2b334:	2100      	movs	r1, #0
   2b336:	4668      	mov	r0, sp
   2b338:	f7fe fd40 	bl	29dbc <rpc_dfu_client_request_alloc>
   2b33c:	4603      	mov	r3, r0
   2b33e:	2800      	cmp	r0, #0
   2b340:	d138      	bne.n	2b3b4 <mfu_interface_setopt+0xa8>
   2b342:	2704      	movs	r7, #4
   2b344:	4e39      	ldr	r6, [pc, #228]	; (2b42c <mfu_interface_setopt+0x120>)
   2b346:	9800      	ldr	r0, [sp, #0]
   2b348:	8832      	ldrh	r2, [r6, #0]
   2b34a:	4629      	mov	r1, r5
   2b34c:	3201      	adds	r2, #1
   2b34e:	b292      	uxth	r2, r2
   2b350:	ea44 4502 	orr.w	r5, r4, r2, lsl #16
   2b354:	4c36      	ldr	r4, [pc, #216]	; (2b430 <mfu_interface_setopt+0x124>)
   2b356:	60c5      	str	r5, [r0, #12]
   2b358:	7103      	strb	r3, [r0, #4]
   2b35a:	7143      	strb	r3, [r0, #5]
   2b35c:	7183      	strb	r3, [r0, #6]
   2b35e:	71c3      	strb	r3, [r0, #7]
   2b360:	7243      	strb	r3, [r0, #9]
   2b362:	7283      	strb	r3, [r0, #10]
   2b364:	72c3      	strb	r3, [r0, #11]
   2b366:	7207      	strb	r7, [r0, #8]
   2b368:	8032      	strh	r2, [r6, #0]
   2b36a:	6023      	str	r3, [r4, #0]
   2b36c:	f7fe fd3a 	bl	29de4 <rpc_dfu_client_request_send>
   2b370:	b9b8      	cbnz	r0, 2b3a2 <mfu_interface_setopt+0x96>
   2b372:	f04f 33ff 	mov.w	r3, #4294967295
   2b376:	ad02      	add	r5, sp, #8
   2b378:	4e2b      	ldr	r6, [pc, #172]	; (2b428 <mfu_interface_setopt+0x11c>)
   2b37a:	f845 3d04 	str.w	r3, [r5, #-4]!
   2b37e:	e005      	b.n	2b38c <mfu_interface_setopt+0x80>
   2b380:	4629      	mov	r1, r5
   2b382:	4630      	mov	r0, r6
   2b384:	f7fc fad8 	bl	27938 <bsd_os_timedwait>
   2b388:	2800      	cmp	r0, #0
   2b38a:	d131      	bne.n	2b3f0 <mfu_interface_setopt+0xe4>
   2b38c:	6820      	ldr	r0, [r4, #0]
   2b38e:	2800      	cmp	r0, #0
   2b390:	d0f6      	beq.n	2b380 <mfu_interface_setopt+0x74>
   2b392:	6904      	ldr	r4, [r0, #16]
   2b394:	f7fe fd3a 	bl	29e0c <rpc_dfu_client_message_free>
   2b398:	2c00      	cmp	r4, #0
   2b39a:	d13c      	bne.n	2b416 <mfu_interface_setopt+0x10a>
   2b39c:	4620      	mov	r0, r4
   2b39e:	b003      	add	sp, #12
   2b3a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2b3a2:	9800      	ldr	r0, [sp, #0]
   2b3a4:	6803      	ldr	r3, [r0, #0]
   2b3a6:	b11b      	cbz	r3, 2b3b0 <mfu_interface_setopt+0xa4>
   2b3a8:	4618      	mov	r0, r3
   2b3aa:	f7fe fd37 	bl	29e1c <rpc_dfu_client_data_free>
   2b3ae:	9800      	ldr	r0, [sp, #0]
   2b3b0:	f7fe fd2c 	bl	29e0c <rpc_dfu_client_message_free>
   2b3b4:	200c      	movs	r0, #12
   2b3b6:	f7fc fb53 	bl	27a60 <bsd_os_errno_set>
   2b3ba:	f04f 30ff 	mov.w	r0, #4294967295
   2b3be:	b003      	add	sp, #12
   2b3c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2b3c2:	2405      	movs	r4, #5
   2b3c4:	4625      	mov	r5, r4
   2b3c6:	e7b5      	b.n	2b334 <mfu_interface_setopt+0x28>
   2b3c8:	2408      	movs	r4, #8
   2b3ca:	4625      	mov	r5, r4
   2b3cc:	e7b2      	b.n	2b334 <mfu_interface_setopt+0x28>
   2b3ce:	b1b3      	cbz	r3, 2b3fe <mfu_interface_setopt+0xf2>
   2b3d0:	9a08      	ldr	r2, [sp, #32]
   2b3d2:	2a04      	cmp	r2, #4
   2b3d4:	d113      	bne.n	2b3fe <mfu_interface_setopt+0xf2>
   2b3d6:	2000      	movs	r0, #0
   2b3d8:	681a      	ldr	r2, [r3, #0]
   2b3da:	4b16      	ldr	r3, [pc, #88]	; (2b434 <mfu_interface_setopt+0x128>)
   2b3dc:	601a      	str	r2, [r3, #0]
   2b3de:	b003      	add	sp, #12
   2b3e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2b3e2:	202a      	movs	r0, #42	; 0x2a
   2b3e4:	f7fc fb3c 	bl	27a60 <bsd_os_errno_set>
   2b3e8:	f04f 30ff 	mov.w	r0, #4294967295
   2b3ec:	b003      	add	sp, #12
   2b3ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2b3f0:	203c      	movs	r0, #60	; 0x3c
   2b3f2:	f7fc fb35 	bl	27a60 <bsd_os_errno_set>
   2b3f6:	f04f 30ff 	mov.w	r0, #4294967295
   2b3fa:	b003      	add	sp, #12
   2b3fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2b3fe:	2016      	movs	r0, #22
   2b400:	f7fc fb2e 	bl	27a60 <bsd_os_errno_set>
   2b404:	f04f 30ff 	mov.w	r0, #4294967295
   2b408:	e7c9      	b.n	2b39e <mfu_interface_setopt+0x92>
   2b40a:	2001      	movs	r0, #1
   2b40c:	f7fc fb28 	bl	27a60 <bsd_os_errno_set>
   2b410:	f04f 30ff 	mov.w	r0, #4294967295
   2b414:	e7c3      	b.n	2b39e <mfu_interface_setopt+0x92>
   2b416:	4b08      	ldr	r3, [pc, #32]	; (2b438 <mfu_interface_setopt+0x12c>)
   2b418:	2008      	movs	r0, #8
   2b41a:	601c      	str	r4, [r3, #0]
   2b41c:	f7fc fb20 	bl	27a60 <bsd_os_errno_set>
   2b420:	f04f 30ff 	mov.w	r0, #4294967295
   2b424:	e7bb      	b.n	2b39e <mfu_interface_setopt+0x92>
   2b426:	bf00      	nop
   2b428:	20020b24 	.word	0x20020b24
   2b42c:	20022294 	.word	0x20022294
   2b430:	20020b30 	.word	0x20020b30
   2b434:	20020b2c 	.word	0x20020b2c
   2b438:	20020b28 	.word	0x20020b28

0002b43c <mfu_interface_getopt>:
   2b43c:	f240 2003 	movw	r0, #515	; 0x203
   2b440:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2b444:	4281      	cmp	r1, r0
   2b446:	b082      	sub	sp, #8
   2b448:	9e08      	ldr	r6, [sp, #32]
   2b44a:	f040 80ae 	bne.w	2b5aa <mfu_interface_getopt+0x16e>
   2b44e:	461d      	mov	r5, r3
   2b450:	2b00      	cmp	r3, #0
   2b452:	f000 80aa 	beq.w	2b5aa <mfu_interface_getopt+0x16e>
   2b456:	2e00      	cmp	r6, #0
   2b458:	f000 80a7 	beq.w	2b5aa <mfu_interface_getopt+0x16e>
   2b45c:	4b5e      	ldr	r3, [pc, #376]	; (2b5d8 <mfu_interface_getopt+0x19c>)
   2b45e:	681b      	ldr	r3, [r3, #0]
   2b460:	3b02      	subs	r3, #2
   2b462:	2b01      	cmp	r3, #1
   2b464:	f200 80a7 	bhi.w	2b5b6 <mfu_interface_getopt+0x17a>
   2b468:	3a01      	subs	r2, #1
   2b46a:	2a13      	cmp	r2, #19
   2b46c:	d879      	bhi.n	2b562 <mfu_interface_getopt+0x126>
   2b46e:	e8df f002 	tbb	[pc, r2]
   2b472:	5f17      	.short	0x5f17
   2b474:	78787878 	.word	0x78787878
   2b478:	78787872 	.word	0x78787872
   2b47c:	78787878 	.word	0x78787878
   2b480:	78787878 	.word	0x78787878
   2b484:	0a78      	.short	0x0a78
   2b486:	6833      	ldr	r3, [r6, #0]
   2b488:	2b04      	cmp	r3, #4
   2b48a:	f040 808e 	bne.w	2b5aa <mfu_interface_getopt+0x16e>
   2b48e:	2200      	movs	r2, #0
   2b490:	4610      	mov	r0, r2
   2b492:	4b52      	ldr	r3, [pc, #328]	; (2b5dc <mfu_interface_getopt+0x1a0>)
   2b494:	6819      	ldr	r1, [r3, #0]
   2b496:	601a      	str	r2, [r3, #0]
   2b498:	6029      	str	r1, [r5, #0]
   2b49a:	b002      	add	sp, #8
   2b49c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2b4a0:	6833      	ldr	r3, [r6, #0]
   2b4a2:	2b24      	cmp	r3, #36	; 0x24
   2b4a4:	f040 8081 	bne.w	2b5aa <mfu_interface_getopt+0x16e>
   2b4a8:	2401      	movs	r4, #1
   2b4aa:	46a0      	mov	r8, r4
   2b4ac:	2100      	movs	r1, #0
   2b4ae:	4668      	mov	r0, sp
   2b4b0:	f7fe fc84 	bl	29dbc <rpc_dfu_client_request_alloc>
   2b4b4:	2800      	cmp	r0, #0
   2b4b6:	d146      	bne.n	2b546 <mfu_interface_getopt+0x10a>
   2b4b8:	4949      	ldr	r1, [pc, #292]	; (2b5e0 <mfu_interface_getopt+0x1a4>)
   2b4ba:	9b00      	ldr	r3, [sp, #0]
   2b4bc:	880a      	ldrh	r2, [r1, #0]
   2b4be:	f1b8 0f03 	cmp.w	r8, #3
   2b4c2:	f102 0201 	add.w	r2, r2, #1
   2b4c6:	b292      	uxth	r2, r2
   2b4c8:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
   2b4cc:	7118      	strb	r0, [r3, #4]
   2b4ce:	800a      	strh	r2, [r1, #0]
   2b4d0:	60dc      	str	r4, [r3, #12]
   2b4d2:	7158      	strb	r0, [r3, #5]
   2b4d4:	7198      	strb	r0, [r3, #6]
   2b4d6:	71d8      	strb	r0, [r3, #7]
   2b4d8:	d04b      	beq.n	2b572 <mfu_interface_getopt+0x136>
   2b4da:	2104      	movs	r1, #4
   2b4dc:	2200      	movs	r2, #0
   2b4de:	4f41      	ldr	r7, [pc, #260]	; (2b5e4 <mfu_interface_getopt+0x1a8>)
   2b4e0:	6099      	str	r1, [r3, #8]
   2b4e2:	4618      	mov	r0, r3
   2b4e4:	4641      	mov	r1, r8
   2b4e6:	603a      	str	r2, [r7, #0]
   2b4e8:	f7fe fc7c 	bl	29de4 <rpc_dfu_client_request_send>
   2b4ec:	2800      	cmp	r0, #0
   2b4ee:	d14d      	bne.n	2b58c <mfu_interface_getopt+0x150>
   2b4f0:	f04f 33ff 	mov.w	r3, #4294967295
   2b4f4:	ac02      	add	r4, sp, #8
   2b4f6:	f844 3d04 	str.w	r3, [r4, #-4]!
   2b4fa:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 2b5d8 <mfu_interface_getopt+0x19c>
   2b4fe:	e005      	b.n	2b50c <mfu_interface_getopt+0xd0>
   2b500:	4621      	mov	r1, r4
   2b502:	4640      	mov	r0, r8
   2b504:	f7fc fa18 	bl	27938 <bsd_os_timedwait>
   2b508:	2800      	cmp	r0, #0
   2b50a:	d137      	bne.n	2b57c <mfu_interface_getopt+0x140>
   2b50c:	6839      	ldr	r1, [r7, #0]
   2b50e:	2900      	cmp	r1, #0
   2b510:	d0f6      	beq.n	2b500 <mfu_interface_getopt+0xc4>
   2b512:	690c      	ldr	r4, [r1, #16]
   2b514:	2c00      	cmp	r4, #0
   2b516:	d154      	bne.n	2b5c2 <mfu_interface_getopt+0x186>
   2b518:	6832      	ldr	r2, [r6, #0]
   2b51a:	3114      	adds	r1, #20
   2b51c:	4628      	mov	r0, r5
   2b51e:	f00e fc2e 	bl	39d7e <memcpy>
   2b522:	6838      	ldr	r0, [r7, #0]
   2b524:	f7fe fc72 	bl	29e0c <rpc_dfu_client_message_free>
   2b528:	4620      	mov	r0, r4
   2b52a:	b002      	add	sp, #8
   2b52c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2b530:	6833      	ldr	r3, [r6, #0]
   2b532:	2b04      	cmp	r3, #4
   2b534:	d139      	bne.n	2b5aa <mfu_interface_getopt+0x16e>
   2b536:	2402      	movs	r4, #2
   2b538:	2100      	movs	r1, #0
   2b53a:	4668      	mov	r0, sp
   2b53c:	46a0      	mov	r8, r4
   2b53e:	f7fe fc3d 	bl	29dbc <rpc_dfu_client_request_alloc>
   2b542:	2800      	cmp	r0, #0
   2b544:	d0b8      	beq.n	2b4b8 <mfu_interface_getopt+0x7c>
   2b546:	200c      	movs	r0, #12
   2b548:	f7fc fa8a 	bl	27a60 <bsd_os_errno_set>
   2b54c:	f04f 30ff 	mov.w	r0, #4294967295
   2b550:	b002      	add	sp, #8
   2b552:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2b556:	6833      	ldr	r3, [r6, #0]
   2b558:	2b04      	cmp	r3, #4
   2b55a:	d126      	bne.n	2b5aa <mfu_interface_getopt+0x16e>
   2b55c:	2409      	movs	r4, #9
   2b55e:	46a0      	mov	r8, r4
   2b560:	e7a4      	b.n	2b4ac <mfu_interface_getopt+0x70>
   2b562:	202a      	movs	r0, #42	; 0x2a
   2b564:	f7fc fa7c 	bl	27a60 <bsd_os_errno_set>
   2b568:	f04f 30ff 	mov.w	r0, #4294967295
   2b56c:	b002      	add	sp, #8
   2b56e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2b572:	4a1d      	ldr	r2, [pc, #116]	; (2b5e8 <mfu_interface_getopt+0x1ac>)
   2b574:	2108      	movs	r1, #8
   2b576:	6812      	ldr	r2, [r2, #0]
   2b578:	611a      	str	r2, [r3, #16]
   2b57a:	e7af      	b.n	2b4dc <mfu_interface_getopt+0xa0>
   2b57c:	203c      	movs	r0, #60	; 0x3c
   2b57e:	f7fc fa6f 	bl	27a60 <bsd_os_errno_set>
   2b582:	f04f 30ff 	mov.w	r0, #4294967295
   2b586:	b002      	add	sp, #8
   2b588:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2b58c:	9800      	ldr	r0, [sp, #0]
   2b58e:	6803      	ldr	r3, [r0, #0]
   2b590:	b11b      	cbz	r3, 2b59a <mfu_interface_getopt+0x15e>
   2b592:	4618      	mov	r0, r3
   2b594:	f7fe fc42 	bl	29e1c <rpc_dfu_client_data_free>
   2b598:	9800      	ldr	r0, [sp, #0]
   2b59a:	f7fe fc37 	bl	29e0c <rpc_dfu_client_message_free>
   2b59e:	200c      	movs	r0, #12
   2b5a0:	f7fc fa5e 	bl	27a60 <bsd_os_errno_set>
   2b5a4:	f04f 30ff 	mov.w	r0, #4294967295
   2b5a8:	e7d2      	b.n	2b550 <mfu_interface_getopt+0x114>
   2b5aa:	2016      	movs	r0, #22
   2b5ac:	f7fc fa58 	bl	27a60 <bsd_os_errno_set>
   2b5b0:	f04f 30ff 	mov.w	r0, #4294967295
   2b5b4:	e771      	b.n	2b49a <mfu_interface_getopt+0x5e>
   2b5b6:	2001      	movs	r0, #1
   2b5b8:	f7fc fa52 	bl	27a60 <bsd_os_errno_set>
   2b5bc:	f04f 30ff 	mov.w	r0, #4294967295
   2b5c0:	e76b      	b.n	2b49a <mfu_interface_getopt+0x5e>
   2b5c2:	4b06      	ldr	r3, [pc, #24]	; (2b5dc <mfu_interface_getopt+0x1a0>)
   2b5c4:	2008      	movs	r0, #8
   2b5c6:	601c      	str	r4, [r3, #0]
   2b5c8:	f7fc fa4a 	bl	27a60 <bsd_os_errno_set>
   2b5cc:	6838      	ldr	r0, [r7, #0]
   2b5ce:	f7fe fc1d 	bl	29e0c <rpc_dfu_client_message_free>
   2b5d2:	f04f 30ff 	mov.w	r0, #4294967295
   2b5d6:	e760      	b.n	2b49a <mfu_interface_getopt+0x5e>
   2b5d8:	20020b24 	.word	0x20020b24
   2b5dc:	20020b28 	.word	0x20020b28
   2b5e0:	20022294 	.word	0x20022294
   2b5e4:	20020b30 	.word	0x20020b30
   2b5e8:	20020b2c 	.word	0x20020b2c

0002b5ec <bsd_platform_error_handler>:
   2b5ec:	b508      	push	{r3, lr}
   2b5ee:	f7f5 fb31 	bl	20c54 <bsd_recoverable_error_handler>
   2b5f2:	bd08      	pop	{r3, pc}

0002b5f4 <bsd_init>:
   2b5f4:	b510      	push	{r4, lr}
   2b5f6:	4c06      	ldr	r4, [pc, #24]	; (2b610 <bsd_init+0x1c>)
   2b5f8:	7823      	ldrb	r3, [r4, #0]
   2b5fa:	b92b      	cbnz	r3, 2b608 <bsd_init+0x14>
   2b5fc:	f000 f818 	bl	2b630 <bsd_platform_init>
   2b600:	b908      	cbnz	r0, 2b606 <bsd_init+0x12>
   2b602:	2301      	movs	r3, #1
   2b604:	7023      	strb	r3, [r4, #0]
   2b606:	bd10      	pop	{r4, pc}
   2b608:	f04f 30ff 	mov.w	r0, #4294967295
   2b60c:	bd10      	pop	{r4, pc}
   2b60e:	bf00      	nop
   2b610:	20026145 	.word	0x20026145

0002b614 <unimplemented_method>:
   2b614:	b40f      	push	{r0, r1, r2, r3}
   2b616:	b508      	push	{r3, lr}
   2b618:	202d      	movs	r0, #45	; 0x2d
   2b61a:	f7fc fa21 	bl	27a60 <bsd_os_errno_set>
   2b61e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   2b622:	f04f 30ff 	mov.w	r0, #4294967295
   2b626:	b004      	add	sp, #16
   2b628:	4770      	bx	lr
   2b62a:	bf00      	nop

0002b62c <rpc_transport_ipc_fault_handler>:
   2b62c:	f7ff bfde 	b.w	2b5ec <bsd_platform_error_handler>

0002b630 <bsd_platform_init>:
   2b630:	b5f0      	push	{r4, r5, r6, r7, lr}
   2b632:	b093      	sub	sp, #76	; 0x4c
   2b634:	f7fe fe2a 	bl	2a28c <nrf_mem_init>
   2b638:	2800      	cmp	r0, #0
   2b63a:	d14c      	bne.n	2b6d6 <bsd_platform_init+0xa6>
   2b63c:	4928      	ldr	r1, [pc, #160]	; (2b6e0 <bsd_platform_init+0xb0>)
   2b63e:	a801      	add	r0, sp, #4
   2b640:	f7fe fe98 	bl	2a374 <nrf_mem_register>
   2b644:	2800      	cmp	r0, #0
   2b646:	d146      	bne.n	2b6d6 <bsd_platform_init+0xa6>
   2b648:	f7fc fb22 	bl	27c90 <bsd_os_init>
   2b64c:	f004 f9fa 	bl	2fa44 <rpc_framework_init>
   2b650:	2800      	cmp	r0, #0
   2b652:	d140      	bne.n	2b6d6 <bsd_platform_init+0xa6>
   2b654:	2320      	movs	r3, #32
   2b656:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   2b65a:	2208      	movs	r2, #8
   2b65c:	f44f 5c40 	mov.w	ip, #12288	; 0x3000
   2b660:	4f20      	ldr	r7, [pc, #128]	; (2b6e4 <bsd_platform_init+0xb4>)
   2b662:	4e21      	ldr	r6, [pc, #132]	; (2b6e8 <bsd_platform_init+0xb8>)
   2b664:	9303      	str	r3, [sp, #12]
   2b666:	9305      	str	r3, [sp, #20]
   2b668:	9307      	str	r3, [sp, #28]
   2b66a:	4d20      	ldr	r5, [pc, #128]	; (2b6ec <bsd_platform_init+0xbc>)
   2b66c:	9109      	str	r1, [sp, #36]	; 0x24
   2b66e:	910d      	str	r1, [sp, #52]	; 0x34
   2b670:	4c1f      	ldr	r4, [pc, #124]	; (2b6f0 <bsd_platform_init+0xc0>)
   2b672:	4920      	ldr	r1, [pc, #128]	; (2b6f4 <bsd_platform_init+0xc4>)
   2b674:	4b20      	ldr	r3, [pc, #128]	; (2b6f8 <bsd_platform_init+0xc8>)
   2b676:	e9cd 0010 	strd	r0, r0, [sp, #64]	; 0x40
   2b67a:	eb0d 0002 	add.w	r0, sp, r2
   2b67e:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
   2b682:	e9cd 220e 	strd	r2, r2, [sp, #56]	; 0x38
   2b686:	9702      	str	r7, [sp, #8]
   2b688:	9604      	str	r6, [sp, #16]
   2b68a:	9506      	str	r5, [sp, #24]
   2b68c:	9408      	str	r4, [sp, #32]
   2b68e:	910a      	str	r1, [sp, #40]	; 0x28
   2b690:	930c      	str	r3, [sp, #48]	; 0x30
   2b692:	f000 fbe9 	bl	2be68 <rpc_transport_ipc_init>
   2b696:	b108      	cbz	r0, 2b69c <bsd_platform_init+0x6c>
   2b698:	b013      	add	sp, #76	; 0x4c
   2b69a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2b69c:	f003 ff6e 	bl	2f57c <interface_init>
   2b6a0:	b9c8      	cbnz	r0, 2b6d6 <bsd_platform_init+0xa6>
   2b6a2:	f7fe fa3d 	bl	29b20 <at_interface_init>
   2b6a6:	b9b0      	cbnz	r0, 2b6d6 <bsd_platform_init+0xa6>
   2b6a8:	f002 fc22 	bl	2def0 <ip_interface_init>
   2b6ac:	b998      	cbnz	r0, 2b6d6 <bsd_platform_init+0xa6>
   2b6ae:	f7ff f883 	bl	2a7b8 <tls_interface_init>
   2b6b2:	b980      	cbnz	r0, 2b6d6 <bsd_platform_init+0xa6>
   2b6b4:	f7ff fcb6 	bl	2b024 <mfu_interface_init>
   2b6b8:	b968      	cbnz	r0, 2b6d6 <bsd_platform_init+0xa6>
   2b6ba:	f001 f9e9 	bl	2ca90 <pdn_interface_init>
   2b6be:	b950      	cbnz	r0, 2b6d6 <bsd_platform_init+0xa6>
   2b6c0:	f005 fc94 	bl	30fec <gnss_interface_init>
   2b6c4:	b938      	cbnz	r0, 2b6d6 <bsd_platform_init+0xa6>
   2b6c6:	f7fd fec3 	bl	29450 <logobj_interface_init>
   2b6ca:	3000      	adds	r0, #0
   2b6cc:	bf18      	it	ne
   2b6ce:	2001      	movne	r0, #1
   2b6d0:	4240      	negs	r0, r0
   2b6d2:	b013      	add	sp, #76	; 0x4c
   2b6d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2b6d6:	f04f 30ff 	mov.w	r0, #4294967295
   2b6da:	b013      	add	sp, #76	; 0x4c
   2b6dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2b6de:	bf00      	nop
   2b6e0:	0003b6c0 	.word	0x0003b6c0
   2b6e4:	20010000 	.word	0x20010000
   2b6e8:	20010040 	.word	0x20010040
   2b6ec:	20010020 	.word	0x20010020
   2b6f0:	20017060 	.word	0x20017060
   2b6f4:	20010060 	.word	0x20010060
   2b6f8:	20013060 	.word	0x20013060

0002b6fc <bsd_platform_af_method_table_get>:
   2b6fc:	2805      	cmp	r0, #5
   2b6fe:	d02a      	beq.n	2b756 <bsd_platform_af_method_table_get+0x5a>
   2b700:	b508      	push	{r3, lr}
   2b702:	d914      	bls.n	2b72e <bsd_platform_af_method_table_get+0x32>
   2b704:	280a      	cmp	r0, #10
   2b706:	d016      	beq.n	2b736 <bsd_platform_af_method_table_get+0x3a>
   2b708:	2866      	cmp	r0, #102	; 0x66
   2b70a:	d11f      	bne.n	2b74c <bsd_platform_af_method_table_get+0x50>
   2b70c:	f240 2302 	movw	r3, #514	; 0x202
   2b710:	429a      	cmp	r2, r3
   2b712:	d035      	beq.n	2b780 <bsd_platform_af_method_table_get+0x84>
   2b714:	f240 2305 	movw	r3, #517	; 0x205
   2b718:	429a      	cmp	r2, r3
   2b71a:	d035      	beq.n	2b788 <bsd_platform_af_method_table_get+0x8c>
   2b71c:	f240 2301 	movw	r3, #513	; 0x201
   2b720:	429a      	cmp	r2, r3
   2b722:	d02f      	beq.n	2b784 <bsd_platform_af_method_table_get+0x88>
   2b724:	202b      	movs	r0, #43	; 0x2b
   2b726:	f7fc f99b 	bl	27a60 <bsd_os_errno_set>
   2b72a:	2000      	movs	r0, #0
   2b72c:	bd08      	pop	{r3, pc}
   2b72e:	2801      	cmp	r0, #1
   2b730:	d016      	beq.n	2b760 <bsd_platform_af_method_table_get+0x64>
   2b732:	2802      	cmp	r0, #2
   2b734:	d10a      	bne.n	2b74c <bsd_platform_af_method_table_get+0x50>
   2b736:	f5b2 7f83 	cmp.w	r2, #262	; 0x106
   2b73a:	d21a      	bcs.n	2b772 <bsd_platform_af_method_table_get+0x76>
   2b73c:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   2b740:	d21a      	bcs.n	2b778 <bsd_platform_af_method_table_get+0x7c>
   2b742:	3a01      	subs	r2, #1
   2b744:	2a01      	cmp	r2, #1
   2b746:	d8ed      	bhi.n	2b724 <bsd_platform_af_method_table_get+0x28>
   2b748:	4810      	ldr	r0, [pc, #64]	; (2b78c <bsd_platform_af_method_table_get+0x90>)
   2b74a:	bd08      	pop	{r3, pc}
   2b74c:	2016      	movs	r0, #22
   2b74e:	f7fc f987 	bl	27a60 <bsd_os_errno_set>
   2b752:	2000      	movs	r0, #0
   2b754:	bd08      	pop	{r3, pc}
   2b756:	2903      	cmp	r1, #3
   2b758:	480d      	ldr	r0, [pc, #52]	; (2b790 <bsd_platform_af_method_table_get+0x94>)
   2b75a:	bf18      	it	ne
   2b75c:	2000      	movne	r0, #0
   2b75e:	4770      	bx	lr
   2b760:	f240 2303 	movw	r3, #515	; 0x203
   2b764:	429a      	cmp	r2, r3
   2b766:	d009      	beq.n	2b77c <bsd_platform_af_method_table_get+0x80>
   2b768:	f5b2 7f01 	cmp.w	r2, #516	; 0x204
   2b76c:	d1da      	bne.n	2b724 <bsd_platform_af_method_table_get+0x28>
   2b76e:	4809      	ldr	r0, [pc, #36]	; (2b794 <bsd_platform_af_method_table_get+0x98>)
   2b770:	bd08      	pop	{r3, pc}
   2b772:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   2b776:	d1d5      	bne.n	2b724 <bsd_platform_af_method_table_get+0x28>
   2b778:	4807      	ldr	r0, [pc, #28]	; (2b798 <bsd_platform_af_method_table_get+0x9c>)
   2b77a:	bd08      	pop	{r3, pc}
   2b77c:	4807      	ldr	r0, [pc, #28]	; (2b79c <bsd_platform_af_method_table_get+0xa0>)
   2b77e:	bd08      	pop	{r3, pc}
   2b780:	4807      	ldr	r0, [pc, #28]	; (2b7a0 <bsd_platform_af_method_table_get+0xa4>)
   2b782:	bd08      	pop	{r3, pc}
   2b784:	4807      	ldr	r0, [pc, #28]	; (2b7a4 <bsd_platform_af_method_table_get+0xa8>)
   2b786:	bd08      	pop	{r3, pc}
   2b788:	4807      	ldr	r0, [pc, #28]	; (2b7a8 <bsd_platform_af_method_table_get+0xac>)
   2b78a:	bd08      	pop	{r3, pc}
   2b78c:	0003b590 	.word	0x0003b590
   2b790:	0003b680 	.word	0x0003b680
   2b794:	0003b630 	.word	0x0003b630
   2b798:	0003b5b8 	.word	0x0003b5b8
   2b79c:	0003b5e0 	.word	0x0003b5e0
   2b7a0:	0003b608 	.word	0x0003b608
   2b7a4:	0003b568 	.word	0x0003b568
   2b7a8:	0003b658 	.word	0x0003b658

0002b7ac <bsd_platform_fd_method_table_get>:
   2b7ac:	b538      	push	{r3, r4, r5, lr}
   2b7ae:	4605      	mov	r5, r0
   2b7b0:	f004 f816 	bl	2f7e0 <interface_socket_from_handle_get>
   2b7b4:	4604      	mov	r4, r0
   2b7b6:	b960      	cbnz	r0, 2b7d2 <bsd_platform_fd_method_table_get+0x26>
   2b7b8:	4b2c      	ldr	r3, [pc, #176]	; (2b86c <bsd_platform_fd_method_table_get+0xc0>)
   2b7ba:	429d      	cmp	r5, r3
   2b7bc:	d02f      	beq.n	2b81e <bsd_platform_fd_method_table_get+0x72>
   2b7be:	0c2b      	lsrs	r3, r5, #16
   2b7c0:	4a2b      	ldr	r2, [pc, #172]	; (2b870 <bsd_platform_fd_method_table_get+0xc4>)
   2b7c2:	041b      	lsls	r3, r3, #16
   2b7c4:	4293      	cmp	r3, r2
   2b7c6:	d03d      	beq.n	2b844 <bsd_platform_fd_method_table_get+0x98>
   2b7c8:	4b2a      	ldr	r3, [pc, #168]	; (2b874 <bsd_platform_fd_method_table_get+0xc8>)
   2b7ca:	429d      	cmp	r5, r3
   2b7cc:	d149      	bne.n	2b862 <bsd_platform_fd_method_table_get+0xb6>
   2b7ce:	482a      	ldr	r0, [pc, #168]	; (2b878 <bsd_platform_fd_method_table_get+0xcc>)
   2b7d0:	bd38      	pop	{r3, r4, r5, pc}
   2b7d2:	68c3      	ldr	r3, [r0, #12]
   2b7d4:	6942      	ldr	r2, [r0, #20]
   2b7d6:	2b05      	cmp	r3, #5
   2b7d8:	d036      	beq.n	2b848 <bsd_platform_fd_method_table_get+0x9c>
   2b7da:	d911      	bls.n	2b800 <bsd_platform_fd_method_table_get+0x54>
   2b7dc:	2b0a      	cmp	r3, #10
   2b7de:	d013      	beq.n	2b808 <bsd_platform_fd_method_table_get+0x5c>
   2b7e0:	2b66      	cmp	r3, #102	; 0x66
   2b7e2:	d11e      	bne.n	2b822 <bsd_platform_fd_method_table_get+0x76>
   2b7e4:	f240 2302 	movw	r3, #514	; 0x202
   2b7e8:	429a      	cmp	r2, r3
   2b7ea:	d02b      	beq.n	2b844 <bsd_platform_fd_method_table_get+0x98>
   2b7ec:	f240 2305 	movw	r3, #517	; 0x205
   2b7f0:	429a      	cmp	r2, r3
   2b7f2:	d02f      	beq.n	2b854 <bsd_platform_fd_method_table_get+0xa8>
   2b7f4:	f240 2301 	movw	r3, #513	; 0x201
   2b7f8:	429a      	cmp	r2, r3
   2b7fa:	d11e      	bne.n	2b83a <bsd_platform_fd_method_table_get+0x8e>
   2b7fc:	481f      	ldr	r0, [pc, #124]	; (2b87c <bsd_platform_fd_method_table_get+0xd0>)
   2b7fe:	bd38      	pop	{r3, r4, r5, pc}
   2b800:	2b01      	cmp	r3, #1
   2b802:	d013      	beq.n	2b82c <bsd_platform_fd_method_table_get+0x80>
   2b804:	2b02      	cmp	r3, #2
   2b806:	d10c      	bne.n	2b822 <bsd_platform_fd_method_table_get+0x76>
   2b808:	f5b2 7f83 	cmp.w	r2, #262	; 0x106
   2b80c:	d224      	bcs.n	2b858 <bsd_platform_fd_method_table_get+0xac>
   2b80e:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   2b812:	d224      	bcs.n	2b85e <bsd_platform_fd_method_table_get+0xb2>
   2b814:	3a01      	subs	r2, #1
   2b816:	2a01      	cmp	r2, #1
   2b818:	d80f      	bhi.n	2b83a <bsd_platform_fd_method_table_get+0x8e>
   2b81a:	4819      	ldr	r0, [pc, #100]	; (2b880 <bsd_platform_fd_method_table_get+0xd4>)
   2b81c:	bd38      	pop	{r3, r4, r5, pc}
   2b81e:	4819      	ldr	r0, [pc, #100]	; (2b884 <bsd_platform_fd_method_table_get+0xd8>)
   2b820:	bd38      	pop	{r3, r4, r5, pc}
   2b822:	2016      	movs	r0, #22
   2b824:	f7fc f91c 	bl	27a60 <bsd_os_errno_set>
   2b828:	2000      	movs	r0, #0
   2b82a:	bd38      	pop	{r3, r4, r5, pc}
   2b82c:	f240 2303 	movw	r3, #515	; 0x203
   2b830:	429a      	cmp	r2, r3
   2b832:	d0f4      	beq.n	2b81e <bsd_platform_fd_method_table_get+0x72>
   2b834:	f5b2 7f01 	cmp.w	r2, #516	; 0x204
   2b838:	d0c9      	beq.n	2b7ce <bsd_platform_fd_method_table_get+0x22>
   2b83a:	202b      	movs	r0, #43	; 0x2b
   2b83c:	f7fc f910 	bl	27a60 <bsd_os_errno_set>
   2b840:	2000      	movs	r0, #0
   2b842:	bd38      	pop	{r3, r4, r5, pc}
   2b844:	4810      	ldr	r0, [pc, #64]	; (2b888 <bsd_platform_fd_method_table_get+0xdc>)
   2b846:	bd38      	pop	{r3, r4, r5, pc}
   2b848:	6903      	ldr	r3, [r0, #16]
   2b84a:	4810      	ldr	r0, [pc, #64]	; (2b88c <bsd_platform_fd_method_table_get+0xe0>)
   2b84c:	2b03      	cmp	r3, #3
   2b84e:	bf18      	it	ne
   2b850:	2000      	movne	r0, #0
   2b852:	bd38      	pop	{r3, r4, r5, pc}
   2b854:	480e      	ldr	r0, [pc, #56]	; (2b890 <bsd_platform_fd_method_table_get+0xe4>)
   2b856:	bd38      	pop	{r3, r4, r5, pc}
   2b858:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   2b85c:	d1ed      	bne.n	2b83a <bsd_platform_fd_method_table_get+0x8e>
   2b85e:	480d      	ldr	r0, [pc, #52]	; (2b894 <bsd_platform_fd_method_table_get+0xe8>)
   2b860:	bd38      	pop	{r3, r4, r5, pc}
   2b862:	2009      	movs	r0, #9
   2b864:	f7fc f8fc 	bl	27a60 <bsd_os_errno_set>
   2b868:	4620      	mov	r0, r4
   2b86a:	bd38      	pop	{r3, r4, r5, pc}
   2b86c:	49765432 	.word	0x49765432
   2b870:	789a0000 	.word	0x789a0000
   2b874:	49765443 	.word	0x49765443
   2b878:	0003b630 	.word	0x0003b630
   2b87c:	0003b568 	.word	0x0003b568
   2b880:	0003b590 	.word	0x0003b590
   2b884:	0003b5e0 	.word	0x0003b5e0
   2b888:	0003b608 	.word	0x0003b608
   2b88c:	0003b680 	.word	0x0003b680
   2b890:	0003b658 	.word	0x0003b658
   2b894:	0003b5b8 	.word	0x0003b5b8

0002b898 <bsd_platform_getaddrinfo>:
   2b898:	f003 bad6 	b.w	2ee48 <ip_interface_getaddrinfo>

0002b89c <bsd_platform_freeaddrinfo>:
   2b89c:	f003 bbca 	b.w	2f034 <ip_interface_freeaddrinfo>

0002b8a0 <bsd_platform_poll>:
   2b8a0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2b8a4:	ea42 72e2 	orr.w	r2, r2, r2, asr #31
   2b8a8:	b083      	sub	sp, #12
   2b8aa:	9200      	str	r2, [sp, #0]
   2b8ac:	2800      	cmp	r0, #0
   2b8ae:	d048      	beq.n	2b942 <bsd_platform_poll+0xa2>
   2b8b0:	1e4b      	subs	r3, r1, #1
   2b8b2:	2b08      	cmp	r3, #8
   2b8b4:	d845      	bhi.n	2b942 <bsd_platform_poll+0xa2>
   2b8b6:	4680      	mov	r8, r0
   2b8b8:	4605      	mov	r5, r0
   2b8ba:	2400      	movs	r4, #0
   2b8bc:	eb00 07c1 	add.w	r7, r0, r1, lsl #3
   2b8c0:	88ab      	ldrh	r3, [r5, #4]
   2b8c2:	6828      	ldr	r0, [r5, #0]
   2b8c4:	f003 0303 	and.w	r3, r3, #3
   2b8c8:	a901      	add	r1, sp, #4
   2b8ca:	f043 061c 	orr.w	r6, r3, #28
   2b8ce:	f003 ff95 	bl	2f7fc <interface_socket_event_get>
   2b8d2:	9b01      	ldr	r3, [sp, #4]
   2b8d4:	3508      	adds	r5, #8
   2b8d6:	4033      	ands	r3, r6
   2b8d8:	f825 3c02 	strh.w	r3, [r5, #-2]
   2b8dc:	b103      	cbz	r3, 2b8e0 <bsd_platform_poll+0x40>
   2b8de:	3401      	adds	r4, #1
   2b8e0:	42af      	cmp	r7, r5
   2b8e2:	d1ed      	bne.n	2b8c0 <bsd_platform_poll+0x20>
   2b8e4:	bb9c      	cbnz	r4, 2b94e <bsd_platform_poll+0xae>
   2b8e6:	4669      	mov	r1, sp
   2b8e8:	4640      	mov	r0, r8
   2b8ea:	f7fc f825 	bl	27938 <bsd_os_timedwait>
   2b8ee:	4607      	mov	r7, r0
   2b8f0:	b108      	cbz	r0, 2b8f6 <bsd_platform_poll+0x56>
   2b8f2:	283c      	cmp	r0, #60	; 0x3c
   2b8f4:	d11d      	bne.n	2b932 <bsd_platform_poll+0x92>
   2b8f6:	46c1      	mov	r9, r8
   2b8f8:	2600      	movs	r6, #0
   2b8fa:	f8b9 3004 	ldrh.w	r3, [r9, #4]
   2b8fe:	f8d9 0000 	ldr.w	r0, [r9]
   2b902:	f003 0303 	and.w	r3, r3, #3
   2b906:	a901      	add	r1, sp, #4
   2b908:	f043 041c 	orr.w	r4, r3, #28
   2b90c:	f003 ff76 	bl	2f7fc <interface_socket_event_get>
   2b910:	9b01      	ldr	r3, [sp, #4]
   2b912:	f109 0908 	add.w	r9, r9, #8
   2b916:	4023      	ands	r3, r4
   2b918:	f829 3c02 	strh.w	r3, [r9, #-2]
   2b91c:	b103      	cbz	r3, 2b920 <bsd_platform_poll+0x80>
   2b91e:	3601      	adds	r6, #1
   2b920:	454d      	cmp	r5, r9
   2b922:	d1ea      	bne.n	2b8fa <bsd_platform_poll+0x5a>
   2b924:	b90e      	cbnz	r6, 2b92a <bsd_platform_poll+0x8a>
   2b926:	2f00      	cmp	r7, #0
   2b928:	d0dd      	beq.n	2b8e6 <bsd_platform_poll+0x46>
   2b92a:	4630      	mov	r0, r6
   2b92c:	b003      	add	sp, #12
   2b92e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2b932:	2023      	movs	r0, #35	; 0x23
   2b934:	f7fc f894 	bl	27a60 <bsd_os_errno_set>
   2b938:	f04f 30ff 	mov.w	r0, #4294967295
   2b93c:	b003      	add	sp, #12
   2b93e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2b942:	2016      	movs	r0, #22
   2b944:	f7fc f88c 	bl	27a60 <bsd_os_errno_set>
   2b948:	f04f 30ff 	mov.w	r0, #4294967295
   2b94c:	e7ee      	b.n	2b92c <bsd_platform_poll+0x8c>
   2b94e:	4620      	mov	r0, r4
   2b950:	e7ec      	b.n	2b92c <bsd_platform_poll+0x8c>
   2b952:	bf00      	nop

0002b954 <bsd_platform_fcntl>:
   2b954:	b508      	push	{r3, lr}
   2b956:	4b06      	ldr	r3, [pc, #24]	; (2b970 <bsd_platform_fcntl+0x1c>)
   2b958:	4298      	cmp	r0, r3
   2b95a:	d003      	beq.n	2b964 <bsd_platform_fcntl+0x10>
   2b95c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   2b960:	f003 bfd6 	b.w	2f910 <interface_socket_fcntl>
   2b964:	202d      	movs	r0, #45	; 0x2d
   2b966:	f7fc f87b 	bl	27a60 <bsd_os_errno_set>
   2b96a:	f04f 30ff 	mov.w	r0, #4294967295
   2b96e:	bd08      	pop	{r3, pc}
   2b970:	49765432 	.word	0x49765432

0002b974 <ipc_trace_init>:
   2b974:	4b01      	ldr	r3, [pc, #4]	; (2b97c <ipc_trace_init+0x8>)
   2b976:	6018      	str	r0, [r3, #0]
   2b978:	4770      	bx	lr
   2b97a:	bf00      	nop
   2b97c:	20020b40 	.word	0x20020b40

0002b980 <bsd_os_trace_irq_handler>:
   2b980:	b5f0      	push	{r4, r5, r6, r7, lr}
   2b982:	4b6c      	ldr	r3, [pc, #432]	; (2bb34 <bsd_os_trace_irq_handler+0x1b4>)
   2b984:	b083      	sub	sp, #12
   2b986:	781b      	ldrb	r3, [r3, #0]
   2b988:	2b00      	cmp	r3, #0
   2b98a:	f000 80ad 	beq.w	2bae8 <bsd_os_trace_irq_handler+0x168>
   2b98e:	4b6a      	ldr	r3, [pc, #424]	; (2bb38 <bsd_os_trace_irq_handler+0x1b8>)
   2b990:	681c      	ldr	r4, [r3, #0]
   2b992:	68a2      	ldr	r2, [r4, #8]
   2b994:	6863      	ldr	r3, [r4, #4]
   2b996:	429a      	cmp	r2, r3
   2b998:	d02d      	beq.n	2b9f6 <bsd_os_trace_irq_handler+0x76>
   2b99a:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   2b99e:	f8ad 3000 	strh.w	r3, [sp]
   2b9a2:	7823      	ldrb	r3, [r4, #0]
   2b9a4:	466e      	mov	r6, sp
   2b9a6:	f88d 3004 	strb.w	r3, [sp, #4]
   2b9aa:	6863      	ldr	r3, [r4, #4]
   2b9ac:	2105      	movs	r1, #5
   2b9ae:	429a      	cmp	r2, r3
   2b9b0:	bf2a      	itet	cs
   2b9b2:	6927      	ldrcs	r7, [r4, #16]
   2b9b4:	1a9f      	subcc	r7, r3, r2
   2b9b6:	1abf      	subcs	r7, r7, r2
   2b9b8:	429a      	cmp	r2, r3
   2b9ba:	bf94      	ite	ls
   2b9bc:	2500      	movls	r5, #0
   2b9be:	68e5      	ldrhi	r5, [r4, #12]
   2b9c0:	b2bf      	uxth	r7, r7
   2b9c2:	bf88      	it	hi
   2b9c4:	1b5b      	subhi	r3, r3, r5
   2b9c6:	4630      	mov	r0, r6
   2b9c8:	bf88      	it	hi
   2b9ca:	b29d      	uxthhi	r5, r3
   2b9cc:	f8ad 7002 	strh.w	r7, [sp, #2]
   2b9d0:	f00d fa9e 	bl	38f10 <bsd_os_trace_put>
   2b9d4:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2b9d8:	68a0      	ldr	r0, [r4, #8]
   2b9da:	f00d fa99 	bl	38f10 <bsd_os_trace_put>
   2b9de:	68a3      	ldr	r3, [r4, #8]
   2b9e0:	6922      	ldr	r2, [r4, #16]
   2b9e2:	441f      	add	r7, r3
   2b9e4:	4297      	cmp	r7, r2
   2b9e6:	bf08      	it	eq
   2b9e8:	68e3      	ldreq	r3, [r4, #12]
   2b9ea:	60a7      	str	r7, [r4, #8]
   2b9ec:	bf08      	it	eq
   2b9ee:	60a3      	streq	r3, [r4, #8]
   2b9f0:	2d00      	cmp	r5, #0
   2b9f2:	f040 808d 	bne.w	2bb10 <bsd_os_trace_irq_handler+0x190>
   2b9f6:	4b51      	ldr	r3, [pc, #324]	; (2bb3c <bsd_os_trace_irq_handler+0x1bc>)
   2b9f8:	681c      	ldr	r4, [r3, #0]
   2b9fa:	68a2      	ldr	r2, [r4, #8]
   2b9fc:	6863      	ldr	r3, [r4, #4]
   2b9fe:	429a      	cmp	r2, r3
   2ba00:	d02c      	beq.n	2ba5c <bsd_os_trace_irq_handler+0xdc>
   2ba02:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   2ba06:	f8ad 3000 	strh.w	r3, [sp]
   2ba0a:	7823      	ldrb	r3, [r4, #0]
   2ba0c:	466e      	mov	r6, sp
   2ba0e:	f88d 3004 	strb.w	r3, [sp, #4]
   2ba12:	6863      	ldr	r3, [r4, #4]
   2ba14:	2105      	movs	r1, #5
   2ba16:	429a      	cmp	r2, r3
   2ba18:	bf2a      	itet	cs
   2ba1a:	6927      	ldrcs	r7, [r4, #16]
   2ba1c:	1a9f      	subcc	r7, r3, r2
   2ba1e:	1abf      	subcs	r7, r7, r2
   2ba20:	429a      	cmp	r2, r3
   2ba22:	bf94      	ite	ls
   2ba24:	2500      	movls	r5, #0
   2ba26:	68e5      	ldrhi	r5, [r4, #12]
   2ba28:	b2bf      	uxth	r7, r7
   2ba2a:	bf88      	it	hi
   2ba2c:	1b5b      	subhi	r3, r3, r5
   2ba2e:	4630      	mov	r0, r6
   2ba30:	bf88      	it	hi
   2ba32:	b29d      	uxthhi	r5, r3
   2ba34:	f8ad 7002 	strh.w	r7, [sp, #2]
   2ba38:	f00d fa6a 	bl	38f10 <bsd_os_trace_put>
   2ba3c:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2ba40:	68a0      	ldr	r0, [r4, #8]
   2ba42:	f00d fa65 	bl	38f10 <bsd_os_trace_put>
   2ba46:	68a3      	ldr	r3, [r4, #8]
   2ba48:	6922      	ldr	r2, [r4, #16]
   2ba4a:	441f      	add	r7, r3
   2ba4c:	4297      	cmp	r7, r2
   2ba4e:	bf08      	it	eq
   2ba50:	68e3      	ldreq	r3, [r4, #12]
   2ba52:	60a7      	str	r7, [r4, #8]
   2ba54:	bf08      	it	eq
   2ba56:	60a3      	streq	r3, [r4, #8]
   2ba58:	2d00      	cmp	r5, #0
   2ba5a:	d148      	bne.n	2baee <bsd_os_trace_irq_handler+0x16e>
   2ba5c:	4b38      	ldr	r3, [pc, #224]	; (2bb40 <bsd_os_trace_irq_handler+0x1c0>)
   2ba5e:	681c      	ldr	r4, [r3, #0]
   2ba60:	68a2      	ldr	r2, [r4, #8]
   2ba62:	6863      	ldr	r3, [r4, #4]
   2ba64:	429a      	cmp	r2, r3
   2ba66:	d02b      	beq.n	2bac0 <bsd_os_trace_irq_handler+0x140>
   2ba68:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   2ba6c:	f8ad 3000 	strh.w	r3, [sp]
   2ba70:	7823      	ldrb	r3, [r4, #0]
   2ba72:	466e      	mov	r6, sp
   2ba74:	f88d 3004 	strb.w	r3, [sp, #4]
   2ba78:	6863      	ldr	r3, [r4, #4]
   2ba7a:	2105      	movs	r1, #5
   2ba7c:	429a      	cmp	r2, r3
   2ba7e:	bf2a      	itet	cs
   2ba80:	6927      	ldrcs	r7, [r4, #16]
   2ba82:	1a9f      	subcc	r7, r3, r2
   2ba84:	1abf      	subcs	r7, r7, r2
   2ba86:	429a      	cmp	r2, r3
   2ba88:	bf94      	ite	ls
   2ba8a:	2500      	movls	r5, #0
   2ba8c:	68e5      	ldrhi	r5, [r4, #12]
   2ba8e:	b2bf      	uxth	r7, r7
   2ba90:	bf88      	it	hi
   2ba92:	1b5b      	subhi	r3, r3, r5
   2ba94:	4630      	mov	r0, r6
   2ba96:	bf88      	it	hi
   2ba98:	b29d      	uxthhi	r5, r3
   2ba9a:	f8ad 7002 	strh.w	r7, [sp, #2]
   2ba9e:	f00d fa37 	bl	38f10 <bsd_os_trace_put>
   2baa2:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2baa6:	68a0      	ldr	r0, [r4, #8]
   2baa8:	f00d fa32 	bl	38f10 <bsd_os_trace_put>
   2baac:	68a3      	ldr	r3, [r4, #8]
   2baae:	6922      	ldr	r2, [r4, #16]
   2bab0:	441f      	add	r7, r3
   2bab2:	4297      	cmp	r7, r2
   2bab4:	bf08      	it	eq
   2bab6:	68e3      	ldreq	r3, [r4, #12]
   2bab8:	60a7      	str	r7, [r4, #8]
   2baba:	bf08      	it	eq
   2babc:	60a3      	streq	r3, [r4, #8]
   2babe:	b90d      	cbnz	r5, 2bac4 <bsd_os_trace_irq_handler+0x144>
   2bac0:	b003      	add	sp, #12
   2bac2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2bac4:	4630      	mov	r0, r6
   2bac6:	2105      	movs	r1, #5
   2bac8:	f8ad 5002 	strh.w	r5, [sp, #2]
   2bacc:	f00d fa20 	bl	38f10 <bsd_os_trace_put>
   2bad0:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2bad4:	68e0      	ldr	r0, [r4, #12]
   2bad6:	f00d fa1b 	bl	38f10 <bsd_os_trace_put>
   2bada:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   2bade:	68e3      	ldr	r3, [r4, #12]
   2bae0:	4413      	add	r3, r2
   2bae2:	60a3      	str	r3, [r4, #8]
   2bae4:	b003      	add	sp, #12
   2bae6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2bae8:	f7fc f8ca 	bl	27c80 <bsd_os_trace_irq_clear>
   2baec:	e74f      	b.n	2b98e <bsd_os_trace_irq_handler+0xe>
   2baee:	2105      	movs	r1, #5
   2baf0:	4630      	mov	r0, r6
   2baf2:	f8ad 5002 	strh.w	r5, [sp, #2]
   2baf6:	f00d fa0b 	bl	38f10 <bsd_os_trace_put>
   2bafa:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2bafe:	68e0      	ldr	r0, [r4, #12]
   2bb00:	f00d fa06 	bl	38f10 <bsd_os_trace_put>
   2bb04:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   2bb08:	68e3      	ldr	r3, [r4, #12]
   2bb0a:	4413      	add	r3, r2
   2bb0c:	60a3      	str	r3, [r4, #8]
   2bb0e:	e7a5      	b.n	2ba5c <bsd_os_trace_irq_handler+0xdc>
   2bb10:	2105      	movs	r1, #5
   2bb12:	4630      	mov	r0, r6
   2bb14:	f8ad 5002 	strh.w	r5, [sp, #2]
   2bb18:	f00d f9fa 	bl	38f10 <bsd_os_trace_put>
   2bb1c:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2bb20:	68e0      	ldr	r0, [r4, #12]
   2bb22:	f00d f9f5 	bl	38f10 <bsd_os_trace_put>
   2bb26:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   2bb2a:	68e3      	ldr	r3, [r4, #12]
   2bb2c:	4413      	add	r3, r2
   2bb2e:	60a3      	str	r3, [r4, #8]
   2bb30:	e761      	b.n	2b9f6 <bsd_os_trace_irq_handler+0x76>
   2bb32:	bf00      	nop
   2bb34:	20026146 	.word	0x20026146
   2bb38:	20020b3c 	.word	0x20020b3c
   2bb3c:	20020b34 	.word	0x20020b34
   2bb40:	20020b38 	.word	0x20020b38

0002bb44 <ipc_trace_handle>:
   2bb44:	2200      	movs	r2, #0
   2bb46:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2bb4a:	4bb0      	ldr	r3, [pc, #704]	; (2be0c <ipc_trace_handle+0x2c8>)
   2bb4c:	b083      	sub	sp, #12
   2bb4e:	681b      	ldr	r3, [r3, #0]
   2bb50:	6919      	ldr	r1, [r3, #16]
   2bb52:	695c      	ldr	r4, [r3, #20]
   2bb54:	7c18      	ldrb	r0, [r3, #16]
   2bb56:	741a      	strb	r2, [r3, #16]
   2bb58:	7c58      	ldrb	r0, [r3, #17]
   2bb5a:	745a      	strb	r2, [r3, #17]
   2bb5c:	7c98      	ldrb	r0, [r3, #18]
   2bb5e:	749a      	strb	r2, [r3, #18]
   2bb60:	7cd8      	ldrb	r0, [r3, #19]
   2bb62:	74da      	strb	r2, [r3, #19]
   2bb64:	7d18      	ldrb	r0, [r3, #20]
   2bb66:	751a      	strb	r2, [r3, #20]
   2bb68:	7d58      	ldrb	r0, [r3, #21]
   2bb6a:	755a      	strb	r2, [r3, #21]
   2bb6c:	7d98      	ldrb	r0, [r3, #22]
   2bb6e:	759a      	strb	r2, [r3, #22]
   2bb70:	7dd8      	ldrb	r0, [r3, #23]
   2bb72:	75da      	strb	r2, [r3, #23]
   2bb74:	b1b9      	cbz	r1, 2bba6 <ipc_trace_handle+0x62>
   2bb76:	3901      	subs	r1, #1
   2bb78:	2903      	cmp	r1, #3
   2bb7a:	d814      	bhi.n	2bba6 <ipc_trace_handle+0x62>
   2bb7c:	e8df f011 	tbh	[pc, r1, lsl #1]
   2bb80:	010300d6 	.word	0x010300d6
   2bb84:	00160004 	.word	0x00160004
   2bb88:	2501      	movs	r5, #1
   2bb8a:	2003      	movs	r0, #3
   2bb8c:	2200      	movs	r2, #0
   2bb8e:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   2bb92:	4c9f      	ldr	r4, [pc, #636]	; (2be10 <ipc_trace_handle+0x2cc>)
   2bb94:	7025      	strb	r5, [r4, #0]
   2bb96:	7a1c      	ldrb	r4, [r3, #8]
   2bb98:	7218      	strb	r0, [r3, #8]
   2bb9a:	7a58      	ldrb	r0, [r3, #9]
   2bb9c:	725a      	strb	r2, [r3, #9]
   2bb9e:	7a98      	ldrb	r0, [r3, #10]
   2bba0:	729a      	strb	r2, [r3, #10]
   2bba2:	7ada      	ldrb	r2, [r3, #11]
   2bba4:	72d9      	strb	r1, [r3, #11]
   2bba6:	b003      	add	sp, #12
   2bba8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2bbac:	2104      	movs	r1, #4
   2bbae:	2200      	movs	r2, #0
   2bbb0:	f06f 005f 	mvn.w	r0, #95	; 0x5f
   2bbb4:	7a1c      	ldrb	r4, [r3, #8]
   2bbb6:	7219      	strb	r1, [r3, #8]
   2bbb8:	7a59      	ldrb	r1, [r3, #9]
   2bbba:	725a      	strb	r2, [r3, #9]
   2bbbc:	4994      	ldr	r1, [pc, #592]	; (2be10 <ipc_trace_handle+0x2cc>)
   2bbbe:	7a9c      	ldrb	r4, [r3, #10]
   2bbc0:	729a      	strb	r2, [r3, #10]
   2bbc2:	7adc      	ldrb	r4, [r3, #11]
   2bbc4:	72d8      	strb	r0, [r3, #11]
   2bbc6:	700a      	strb	r2, [r1, #0]
   2bbc8:	780b      	ldrb	r3, [r1, #0]
   2bbca:	2b00      	cmp	r3, #0
   2bbcc:	f000 8117 	beq.w	2bdfe <ipc_trace_handle+0x2ba>
   2bbd0:	4b90      	ldr	r3, [pc, #576]	; (2be14 <ipc_trace_handle+0x2d0>)
   2bbd2:	681c      	ldr	r4, [r3, #0]
   2bbd4:	68a2      	ldr	r2, [r4, #8]
   2bbd6:	6863      	ldr	r3, [r4, #4]
   2bbd8:	429a      	cmp	r2, r3
   2bbda:	d02d      	beq.n	2bc38 <ipc_trace_handle+0xf4>
   2bbdc:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   2bbe0:	f8ad 3000 	strh.w	r3, [sp]
   2bbe4:	7823      	ldrb	r3, [r4, #0]
   2bbe6:	466e      	mov	r6, sp
   2bbe8:	f88d 3004 	strb.w	r3, [sp, #4]
   2bbec:	6863      	ldr	r3, [r4, #4]
   2bbee:	2105      	movs	r1, #5
   2bbf0:	429a      	cmp	r2, r3
   2bbf2:	bf2a      	itet	cs
   2bbf4:	6927      	ldrcs	r7, [r4, #16]
   2bbf6:	1a9f      	subcc	r7, r3, r2
   2bbf8:	1abf      	subcs	r7, r7, r2
   2bbfa:	429a      	cmp	r2, r3
   2bbfc:	bf94      	ite	ls
   2bbfe:	2500      	movls	r5, #0
   2bc00:	68e5      	ldrhi	r5, [r4, #12]
   2bc02:	b2bf      	uxth	r7, r7
   2bc04:	bf88      	it	hi
   2bc06:	1b5b      	subhi	r3, r3, r5
   2bc08:	4630      	mov	r0, r6
   2bc0a:	bf88      	it	hi
   2bc0c:	b29d      	uxthhi	r5, r3
   2bc0e:	f8ad 7002 	strh.w	r7, [sp, #2]
   2bc12:	f00d f97d 	bl	38f10 <bsd_os_trace_put>
   2bc16:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2bc1a:	68a0      	ldr	r0, [r4, #8]
   2bc1c:	f00d f978 	bl	38f10 <bsd_os_trace_put>
   2bc20:	68a3      	ldr	r3, [r4, #8]
   2bc22:	6922      	ldr	r2, [r4, #16]
   2bc24:	441f      	add	r7, r3
   2bc26:	4297      	cmp	r7, r2
   2bc28:	bf08      	it	eq
   2bc2a:	68e3      	ldreq	r3, [r4, #12]
   2bc2c:	60a7      	str	r7, [r4, #8]
   2bc2e:	bf08      	it	eq
   2bc30:	60a3      	streq	r3, [r4, #8]
   2bc32:	2d00      	cmp	r5, #0
   2bc34:	f040 80d2 	bne.w	2bddc <ipc_trace_handle+0x298>
   2bc38:	4b77      	ldr	r3, [pc, #476]	; (2be18 <ipc_trace_handle+0x2d4>)
   2bc3a:	681c      	ldr	r4, [r3, #0]
   2bc3c:	68a2      	ldr	r2, [r4, #8]
   2bc3e:	6863      	ldr	r3, [r4, #4]
   2bc40:	429a      	cmp	r2, r3
   2bc42:	d02d      	beq.n	2bca0 <ipc_trace_handle+0x15c>
   2bc44:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   2bc48:	f8ad 3000 	strh.w	r3, [sp]
   2bc4c:	7823      	ldrb	r3, [r4, #0]
   2bc4e:	466e      	mov	r6, sp
   2bc50:	f88d 3004 	strb.w	r3, [sp, #4]
   2bc54:	6863      	ldr	r3, [r4, #4]
   2bc56:	2105      	movs	r1, #5
   2bc58:	429a      	cmp	r2, r3
   2bc5a:	bf2a      	itet	cs
   2bc5c:	6927      	ldrcs	r7, [r4, #16]
   2bc5e:	1a9f      	subcc	r7, r3, r2
   2bc60:	1abf      	subcs	r7, r7, r2
   2bc62:	429a      	cmp	r2, r3
   2bc64:	bf94      	ite	ls
   2bc66:	2500      	movls	r5, #0
   2bc68:	68e5      	ldrhi	r5, [r4, #12]
   2bc6a:	b2bf      	uxth	r7, r7
   2bc6c:	bf88      	it	hi
   2bc6e:	1b5b      	subhi	r3, r3, r5
   2bc70:	4630      	mov	r0, r6
   2bc72:	bf88      	it	hi
   2bc74:	b29d      	uxthhi	r5, r3
   2bc76:	f8ad 7002 	strh.w	r7, [sp, #2]
   2bc7a:	f00d f949 	bl	38f10 <bsd_os_trace_put>
   2bc7e:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2bc82:	68a0      	ldr	r0, [r4, #8]
   2bc84:	f00d f944 	bl	38f10 <bsd_os_trace_put>
   2bc88:	68a3      	ldr	r3, [r4, #8]
   2bc8a:	6922      	ldr	r2, [r4, #16]
   2bc8c:	441f      	add	r7, r3
   2bc8e:	4297      	cmp	r7, r2
   2bc90:	bf08      	it	eq
   2bc92:	68e3      	ldreq	r3, [r4, #12]
   2bc94:	60a7      	str	r7, [r4, #8]
   2bc96:	bf08      	it	eq
   2bc98:	60a3      	streq	r3, [r4, #8]
   2bc9a:	2d00      	cmp	r5, #0
   2bc9c:	f040 808d 	bne.w	2bdba <ipc_trace_handle+0x276>
   2bca0:	4b5e      	ldr	r3, [pc, #376]	; (2be1c <ipc_trace_handle+0x2d8>)
   2bca2:	681c      	ldr	r4, [r3, #0]
   2bca4:	68a2      	ldr	r2, [r4, #8]
   2bca6:	6863      	ldr	r3, [r4, #4]
   2bca8:	429a      	cmp	r2, r3
   2bcaa:	f43f af7c 	beq.w	2bba6 <ipc_trace_handle+0x62>
   2bcae:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   2bcb2:	f8ad 3000 	strh.w	r3, [sp]
   2bcb6:	7823      	ldrb	r3, [r4, #0]
   2bcb8:	466e      	mov	r6, sp
   2bcba:	f88d 3004 	strb.w	r3, [sp, #4]
   2bcbe:	6863      	ldr	r3, [r4, #4]
   2bcc0:	2105      	movs	r1, #5
   2bcc2:	429a      	cmp	r2, r3
   2bcc4:	bf2a      	itet	cs
   2bcc6:	6927      	ldrcs	r7, [r4, #16]
   2bcc8:	1a9f      	subcc	r7, r3, r2
   2bcca:	1abf      	subcs	r7, r7, r2
   2bccc:	429a      	cmp	r2, r3
   2bcce:	bf94      	ite	ls
   2bcd0:	2500      	movls	r5, #0
   2bcd2:	68e5      	ldrhi	r5, [r4, #12]
   2bcd4:	b2bf      	uxth	r7, r7
   2bcd6:	bf88      	it	hi
   2bcd8:	1b5b      	subhi	r3, r3, r5
   2bcda:	4630      	mov	r0, r6
   2bcdc:	bf88      	it	hi
   2bcde:	b29d      	uxthhi	r5, r3
   2bce0:	f8ad 7002 	strh.w	r7, [sp, #2]
   2bce4:	f00d f914 	bl	38f10 <bsd_os_trace_put>
   2bce8:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2bcec:	68a0      	ldr	r0, [r4, #8]
   2bcee:	f00d f90f 	bl	38f10 <bsd_os_trace_put>
   2bcf2:	68a3      	ldr	r3, [r4, #8]
   2bcf4:	6922      	ldr	r2, [r4, #16]
   2bcf6:	441f      	add	r7, r3
   2bcf8:	4297      	cmp	r7, r2
   2bcfa:	bf08      	it	eq
   2bcfc:	68e3      	ldreq	r3, [r4, #12]
   2bcfe:	60a7      	str	r7, [r4, #8]
   2bd00:	bf08      	it	eq
   2bd02:	60a3      	streq	r3, [r4, #8]
   2bd04:	2d00      	cmp	r5, #0
   2bd06:	f43f af4e 	beq.w	2bba6 <ipc_trace_handle+0x62>
   2bd0a:	2105      	movs	r1, #5
   2bd0c:	4630      	mov	r0, r6
   2bd0e:	f8ad 5002 	strh.w	r5, [sp, #2]
   2bd12:	f00d f8fd 	bl	38f10 <bsd_os_trace_put>
   2bd16:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2bd1a:	68e0      	ldr	r0, [r4, #12]
   2bd1c:	f00d f8f8 	bl	38f10 <bsd_os_trace_put>
   2bd20:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   2bd24:	68e3      	ldr	r3, [r4, #12]
   2bd26:	4413      	add	r3, r2
   2bd28:	60a3      	str	r3, [r4, #8]
   2bd2a:	e73c      	b.n	2bba6 <ipc_trace_handle+0x62>
   2bd2c:	4a38      	ldr	r2, [pc, #224]	; (2be10 <ipc_trace_handle+0x2cc>)
   2bd2e:	7811      	ldrb	r1, [r2, #0]
   2bd30:	b109      	cbz	r1, 2bd36 <ipc_trace_handle+0x1f2>
   2bd32:	2100      	movs	r1, #0
   2bd34:	7011      	strb	r1, [r2, #0]
   2bd36:	68a5      	ldr	r5, [r4, #8]
   2bd38:	2d00      	cmp	r5, #0
   2bd3a:	d039      	beq.n	2bdb0 <ipc_trace_handle+0x26c>
   2bd3c:	f04f 0c00 	mov.w	ip, #0
   2bd40:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 2be18 <ipc_trace_handle+0x2d4>
   2bd44:	f8df b0cc 	ldr.w	fp, [pc, #204]	; 2be14 <ipc_trace_handle+0x2d0>
   2bd48:	4934      	ldr	r1, [pc, #208]	; (2be1c <ipc_trace_handle+0x2d8>)
   2bd4a:	46e1      	mov	r9, ip
   2bd4c:	4666      	mov	r6, ip
   2bd4e:	4662      	mov	r2, ip
   2bd50:	f8d1 e000 	ldr.w	lr, [r1]
   2bd54:	f8da 8000 	ldr.w	r8, [sl]
   2bd58:	f8db 7000 	ldr.w	r7, [fp]
   2bd5c:	e008      	b.n	2bd70 <ipc_trace_handle+0x22c>
   2bd5e:	2963      	cmp	r1, #99	; 0x63
   2bd60:	d016      	beq.n	2bd90 <ipc_trace_handle+0x24c>
   2bd62:	2961      	cmp	r1, #97	; 0x61
   2bd64:	bf04      	itt	eq
   2bd66:	4607      	moveq	r7, r0
   2bd68:	2601      	moveq	r6, #1
   2bd6a:	3201      	adds	r2, #1
   2bd6c:	42aa      	cmp	r2, r5
   2bd6e:	d013      	beq.n	2bd98 <ipc_trace_handle+0x254>
   2bd70:	1c91      	adds	r1, r2, #2
   2bd72:	eb04 0181 	add.w	r1, r4, r1, lsl #2
   2bd76:	6848      	ldr	r0, [r1, #4]
   2bd78:	7801      	ldrb	r1, [r0, #0]
   2bd7a:	2962      	cmp	r1, #98	; 0x62
   2bd7c:	d1ef      	bne.n	2bd5e <ipc_trace_handle+0x21a>
   2bd7e:	4680      	mov	r8, r0
   2bd80:	f04f 0901 	mov.w	r9, #1
   2bd84:	e7f1      	b.n	2bd6a <ipc_trace_handle+0x226>
   2bd86:	f7fb ff73 	bl	27c70 <bsd_os_trace_irq_set>
   2bd8a:	b003      	add	sp, #12
   2bd8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2bd90:	4686      	mov	lr, r0
   2bd92:	f04f 0c01 	mov.w	ip, #1
   2bd96:	e7e8      	b.n	2bd6a <ipc_trace_handle+0x226>
   2bd98:	bba6      	cbnz	r6, 2be04 <ipc_trace_handle+0x2c0>
   2bd9a:	f1b9 0f00 	cmp.w	r9, #0
   2bd9e:	d001      	beq.n	2bda4 <ipc_trace_handle+0x260>
   2bda0:	f8ca 8000 	str.w	r8, [sl]
   2bda4:	f1bc 0f00 	cmp.w	ip, #0
   2bda8:	d002      	beq.n	2bdb0 <ipc_trace_handle+0x26c>
   2bdaa:	4a1c      	ldr	r2, [pc, #112]	; (2be1c <ipc_trace_handle+0x2d8>)
   2bdac:	f8c2 e000 	str.w	lr, [r2]
   2bdb0:	2001      	movs	r0, #1
   2bdb2:	2200      	movs	r2, #0
   2bdb4:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   2bdb8:	e6ed      	b.n	2bb96 <ipc_trace_handle+0x52>
   2bdba:	2105      	movs	r1, #5
   2bdbc:	4630      	mov	r0, r6
   2bdbe:	f8ad 5002 	strh.w	r5, [sp, #2]
   2bdc2:	f00d f8a5 	bl	38f10 <bsd_os_trace_put>
   2bdc6:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2bdca:	68e0      	ldr	r0, [r4, #12]
   2bdcc:	f00d f8a0 	bl	38f10 <bsd_os_trace_put>
   2bdd0:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   2bdd4:	68e3      	ldr	r3, [r4, #12]
   2bdd6:	4413      	add	r3, r2
   2bdd8:	60a3      	str	r3, [r4, #8]
   2bdda:	e761      	b.n	2bca0 <ipc_trace_handle+0x15c>
   2bddc:	2105      	movs	r1, #5
   2bdde:	4630      	mov	r0, r6
   2bde0:	f8ad 5002 	strh.w	r5, [sp, #2]
   2bde4:	f00d f894 	bl	38f10 <bsd_os_trace_put>
   2bde8:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2bdec:	68e0      	ldr	r0, [r4, #12]
   2bdee:	f00d f88f 	bl	38f10 <bsd_os_trace_put>
   2bdf2:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   2bdf6:	68e3      	ldr	r3, [r4, #12]
   2bdf8:	4413      	add	r3, r2
   2bdfa:	60a3      	str	r3, [r4, #8]
   2bdfc:	e71c      	b.n	2bc38 <ipc_trace_handle+0xf4>
   2bdfe:	f7fb ff3f 	bl	27c80 <bsd_os_trace_irq_clear>
   2be02:	e6e5      	b.n	2bbd0 <ipc_trace_handle+0x8c>
   2be04:	f8cb 7000 	str.w	r7, [fp]
   2be08:	e7c7      	b.n	2bd9a <ipc_trace_handle+0x256>
   2be0a:	bf00      	nop
   2be0c:	20020b40 	.word	0x20020b40
   2be10:	20026146 	.word	0x20026146
   2be14:	20020b3c 	.word	0x20020b3c
   2be18:	20020b34 	.word	0x20020b34
   2be1c:	20020b38 	.word	0x20020b38

0002be20 <rpc_trace_coredump_in_progress>:
   2be20:	4b01      	ldr	r3, [pc, #4]	; (2be28 <rpc_trace_coredump_in_progress+0x8>)
   2be22:	7818      	ldrb	r0, [r3, #0]
   2be24:	4770      	bx	lr
   2be26:	bf00      	nop
   2be28:	20026146 	.word	0x20026146

0002be2c <transport_reset>:
   2be2c:	2000      	movs	r0, #0
   2be2e:	4770      	bx	lr

0002be30 <transport_data_free>:
   2be30:	4b0b      	ldr	r3, [pc, #44]	; (2be60 <transport_data_free+0x30>)
   2be32:	e9d3 2300 	ldrd	r2, r3, [r3]
   2be36:	4413      	add	r3, r2
   2be38:	4298      	cmp	r0, r3
   2be3a:	d20d      	bcs.n	2be58 <transport_data_free+0x28>
   2be3c:	4282      	cmp	r2, r0
   2be3e:	d80b      	bhi.n	2be58 <transport_data_free+0x28>
   2be40:	b510      	push	{r4, lr}
   2be42:	4604      	mov	r4, r0
   2be44:	f000 fd5a 	bl	2c8fc <rpc_transport_ipc_tx_rpc_ctrl_alloc>
   2be48:	b140      	cbz	r0, 2be5c <transport_data_free+0x2c>
   2be4a:	4a06      	ldr	r2, [pc, #24]	; (2be64 <transport_data_free+0x34>)
   2be4c:	6084      	str	r4, [r0, #8]
   2be4e:	6002      	str	r2, [r0, #0]
   2be50:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2be54:	f000 bc9a 	b.w	2c78c <rpc_transport_ipc_tx_send>
   2be58:	f7fe bbc6 	b.w	2a5e8 <nrf_shared_free>
   2be5c:	bd10      	pop	{r4, pc}
   2be5e:	bf00      	nop
   2be60:	20020b44 	.word	0x20020b44
   2be64:	00020001 	.word	0x00020001

0002be68 <rpc_transport_ipc_init>:
   2be68:	2800      	cmp	r0, #0
   2be6a:	d02b      	beq.n	2bec4 <rpc_transport_ipc_init+0x5c>
   2be6c:	b530      	push	{r4, r5, lr}
   2be6e:	b089      	sub	sp, #36	; 0x24
   2be70:	aa01      	add	r2, sp, #4
   2be72:	4669      	mov	r1, sp
   2be74:	4604      	mov	r4, r0
   2be76:	f000 fb9f 	bl	2c5b8 <rpc_transport_ipc_tx_init>
   2be7a:	4603      	mov	r3, r0
   2be7c:	b140      	cbz	r0, 2be90 <rpc_transport_ipc_init+0x28>
   2be7e:	4a13      	ldr	r2, [pc, #76]	; (2becc <rpc_transport_ipc_init+0x64>)
   2be80:	f104 0028 	add.w	r0, r4, #40	; 0x28
   2be84:	c803      	ldmia	r0, {r0, r1}
   2be86:	e882 0003 	stmia.w	r2, {r0, r1}
   2be8a:	4618      	mov	r0, r3
   2be8c:	b009      	add	sp, #36	; 0x24
   2be8e:	bd30      	pop	{r4, r5, pc}
   2be90:	e9dd 1200 	ldrd	r1, r2, [sp]
   2be94:	4620      	mov	r0, r4
   2be96:	f000 f84b 	bl	2bf30 <rpc_transport_ipc_rx_init>
   2be9a:	4603      	mov	r3, r0
   2be9c:	2800      	cmp	r0, #0
   2be9e:	d1ee      	bne.n	2be7e <rpc_transport_ipc_init+0x16>
   2bea0:	4b0b      	ldr	r3, [pc, #44]	; (2bed0 <rpc_transport_ipc_init+0x68>)
   2bea2:	490c      	ldr	r1, [pc, #48]	; (2bed4 <rpc_transport_ipc_init+0x6c>)
   2bea4:	480c      	ldr	r0, [pc, #48]	; (2bed8 <rpc_transport_ipc_init+0x70>)
   2bea6:	4a0d      	ldr	r2, [pc, #52]	; (2bedc <rpc_transport_ipc_init+0x74>)
   2bea8:	9303      	str	r3, [sp, #12]
   2beaa:	4d0d      	ldr	r5, [pc, #52]	; (2bee0 <rpc_transport_ipc_init+0x78>)
   2beac:	4b0d      	ldr	r3, [pc, #52]	; (2bee4 <rpc_transport_ipc_init+0x7c>)
   2beae:	9104      	str	r1, [sp, #16]
   2beb0:	9005      	str	r0, [sp, #20]
   2beb2:	490d      	ldr	r1, [pc, #52]	; (2bee8 <rpc_transport_ipc_init+0x80>)
   2beb4:	a802      	add	r0, sp, #8
   2beb6:	9307      	str	r3, [sp, #28]
   2beb8:	9506      	str	r5, [sp, #24]
   2beba:	9202      	str	r2, [sp, #8]
   2bebc:	f003 ff44 	bl	2fd48 <rpc_transport_register>
   2bec0:	4603      	mov	r3, r0
   2bec2:	e7dc      	b.n	2be7e <rpc_transport_ipc_init+0x16>
   2bec4:	230e      	movs	r3, #14
   2bec6:	4618      	mov	r0, r3
   2bec8:	4770      	bx	lr
   2beca:	bf00      	nop
   2becc:	20020b44 	.word	0x20020b44
   2bed0:	0002c88d 	.word	0x0002c88d
   2bed4:	0002c95d 	.word	0x0002c95d
   2bed8:	0002c54d 	.word	0x0002c54d
   2bedc:	0002c78d 	.word	0x0002c78d
   2bee0:	0002be31 	.word	0x0002be31
   2bee4:	0002be2d 	.word	0x0002be2d
   2bee8:	20020b4c 	.word	0x20020b4c

0002beec <rpc_transport_rx_handle>:
   2beec:	b160      	cbz	r0, 2bf08 <rpc_transport_rx_handle+0x1c>
   2beee:	b508      	push	{r3, lr}
   2bef0:	6843      	ldr	r3, [r0, #4]
   2bef2:	b2db      	uxtb	r3, r3
   2bef4:	2b02      	cmp	r3, #2
   2bef6:	d00e      	beq.n	2bf16 <rpc_transport_rx_handle+0x2a>
   2bef8:	6803      	ldr	r3, [r0, #0]
   2befa:	0c1b      	lsrs	r3, r3, #16
   2befc:	2b02      	cmp	r3, #2
   2befe:	d005      	beq.n	2bf0c <rpc_transport_rx_handle+0x20>
   2bf00:	2b04      	cmp	r3, #4
   2bf02:	d00e      	beq.n	2bf22 <rpc_transport_rx_handle+0x36>
   2bf04:	2000      	movs	r0, #0
   2bf06:	bd08      	pop	{r3, pc}
   2bf08:	2000      	movs	r0, #0
   2bf0a:	4770      	bx	lr
   2bf0c:	6880      	ldr	r0, [r0, #8]
   2bf0e:	f7fe fb6b 	bl	2a5e8 <nrf_shared_free>
   2bf12:	2000      	movs	r0, #0
   2bf14:	bd08      	pop	{r3, pc}
   2bf16:	4601      	mov	r1, r0
   2bf18:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   2bf1c:	4803      	ldr	r0, [pc, #12]	; (2bf2c <rpc_transport_rx_handle+0x40>)
   2bf1e:	f003 be05 	b.w	2fb2c <rpc_transport_input>
   2bf22:	4802      	ldr	r0, [pc, #8]	; (2bf2c <rpc_transport_rx_handle+0x40>)
   2bf24:	f003 ff70 	bl	2fe08 <rpc_transport_unregister>
   2bf28:	2000      	movs	r0, #0
   2bf2a:	bd08      	pop	{r3, pc}
   2bf2c:	20020b4c 	.word	0x20020b4c

0002bf30 <rpc_transport_ipc_rx_init>:
   2bf30:	2800      	cmp	r0, #0
   2bf32:	f000 80ff 	beq.w	2c134 <rpc_transport_ipc_rx_init+0x204>
   2bf36:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2bf3a:	6805      	ldr	r5, [r0, #0]
   2bf3c:	b095      	sub	sp, #84	; 0x54
   2bf3e:	2d00      	cmp	r5, #0
   2bf40:	f000 80ee 	beq.w	2c120 <rpc_transport_ipc_rx_init+0x1f0>
   2bf44:	6883      	ldr	r3, [r0, #8]
   2bf46:	2b00      	cmp	r3, #0
   2bf48:	f000 80ea 	beq.w	2c120 <rpc_transport_ipc_rx_init+0x1f0>
   2bf4c:	6907      	ldr	r7, [r0, #16]
   2bf4e:	2f00      	cmp	r7, #0
   2bf50:	f000 80e6 	beq.w	2c120 <rpc_transport_ipc_rx_init+0x1f0>
   2bf54:	6a84      	ldr	r4, [r0, #40]	; 0x28
   2bf56:	2c00      	cmp	r4, #0
   2bf58:	f000 80e2 	beq.w	2c120 <rpc_transport_ipc_rx_init+0x1f0>
   2bf5c:	6844      	ldr	r4, [r0, #4]
   2bf5e:	2c1b      	cmp	r4, #27
   2bf60:	f240 80e3 	bls.w	2c12a <rpc_transport_ipc_rx_init+0x1fa>
   2bf64:	68c4      	ldr	r4, [r0, #12]
   2bf66:	2c0b      	cmp	r4, #11
   2bf68:	f240 80df 	bls.w	2c12a <rpc_transport_ipc_rx_init+0x1fa>
   2bf6c:	f8d0 e014 	ldr.w	lr, [r0, #20]
   2bf70:	f1be 0f17 	cmp.w	lr, #23
   2bf74:	f240 80d9 	bls.w	2c12a <rpc_transport_ipc_rx_init+0x1fa>
   2bf78:	2600      	movs	r6, #0
   2bf7a:	4604      	mov	r4, r0
   2bf7c:	486f      	ldr	r0, [pc, #444]	; (2c13c <rpc_transport_ipc_rx_init+0x20c>)
   2bf7e:	e9cd 1200 	strd	r1, r2, [sp]
   2bf82:	f8df a1d8 	ldr.w	sl, [pc, #472]	; 2c15c <rpc_transport_ipc_rx_init+0x22c>
   2bf86:	496e      	ldr	r1, [pc, #440]	; (2c140 <rpc_transport_ipc_rx_init+0x210>)
   2bf88:	8006      	strh	r6, [r0, #0]
   2bf8a:	6ba0      	ldr	r0, [r4, #56]	; 0x38
   2bf8c:	f8df c1d0 	ldr.w	ip, [pc, #464]	; 2c160 <rpc_transport_ipc_rx_init+0x230>
   2bf90:	f8df 81d0 	ldr.w	r8, [pc, #464]	; 2c164 <rpc_transport_ipc_rx_init+0x234>
   2bf94:	f8df b1d0 	ldr.w	fp, [pc, #464]	; 2c168 <rpc_transport_ipc_rx_init+0x238>
   2bf98:	f8df 91d0 	ldr.w	r9, [pc, #464]	; 2c16c <rpc_transport_ipc_rx_init+0x23c>
   2bf9c:	4672      	mov	r2, lr
   2bf9e:	600e      	str	r6, [r1, #0]
   2bfa0:	f8ca 0000 	str.w	r0, [sl]
   2bfa4:	4631      	mov	r1, r6
   2bfa6:	4638      	mov	r0, r7
   2bfa8:	f8cc 6000 	str.w	r6, [ip]
   2bfac:	f8cb 3000 	str.w	r3, [fp]
   2bfb0:	f8c8 6000 	str.w	r6, [r8]
   2bfb4:	f8c9 6000 	str.w	r6, [r9]
   2bfb8:	f00d ff01 	bl	39dbe <memset>
   2bfbc:	69e3      	ldr	r3, [r4, #28]
   2bfbe:	4638      	mov	r0, r7
   2bfc0:	603b      	str	r3, [r7, #0]
   2bfc2:	69a3      	ldr	r3, [r4, #24]
   2bfc4:	607b      	str	r3, [r7, #4]
   2bfc6:	f7ff fcd5 	bl	2b974 <ipc_trace_init>
   2bfca:	2201      	movs	r2, #1
   2bfcc:	f04f 0c04 	mov.w	ip, #4
   2bfd0:	4b5c      	ldr	r3, [pc, #368]	; (2c144 <rpc_transport_ipc_rx_init+0x214>)
   2bfd2:	495d      	ldr	r1, [pc, #372]	; (2c148 <rpc_transport_ipc_rx_init+0x218>)
   2bfd4:	f8c3 5610 	str.w	r5, [r3, #1552]	; 0x610
   2bfd8:	6809      	ldr	r1, [r1, #0]
   2bfda:	2080      	movs	r0, #128	; 0x80
   2bfdc:	9104      	str	r1, [sp, #16]
   2bfde:	495b      	ldr	r1, [pc, #364]	; (2c14c <rpc_transport_ipc_rx_init+0x21c>)
   2bfe0:	f8dd e010 	ldr.w	lr, [sp, #16]
   2bfe4:	f8c3 6614 	str.w	r6, [r3, #1556]	; 0x614
   2bfe8:	6809      	ldr	r1, [r1, #0]
   2bfea:	702e      	strb	r6, [r5, #0]
   2bfec:	9103      	str	r1, [sp, #12]
   2bfee:	706e      	strb	r6, [r5, #1]
   2bff0:	70ee      	strb	r6, [r5, #3]
   2bff2:	70aa      	strb	r2, [r5, #2]
   2bff4:	9903      	ldr	r1, [sp, #12]
   2bff6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   2bff8:	f8db e000 	ldr.w	lr, [fp]
   2bffc:	6069      	str	r1, [r5, #4]
   2bffe:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   2c000:	9c01      	ldr	r4, [sp, #4]
   2c002:	60a9      	str	r1, [r5, #8]
   2c004:	60ec      	str	r4, [r5, #12]
   2c006:	9c00      	ldr	r4, [sp, #0]
   2c008:	4951      	ldr	r1, [pc, #324]	; (2c150 <rpc_transport_ipc_rx_init+0x220>)
   2c00a:	61af      	str	r7, [r5, #24]
   2c00c:	f8c5 e014 	str.w	lr, [r5, #20]
   2c010:	612c      	str	r4, [r5, #16]
   2c012:	f8c3 2590 	str.w	r2, [r3, #1424]	; 0x590
   2c016:	680c      	ldr	r4, [r1, #0]
   2c018:	f5a1 6192 	sub.w	r1, r1, #1168	; 0x490
   2c01c:	9405      	str	r4, [sp, #20]
   2c01e:	9c05      	ldr	r4, [sp, #20]
   2c020:	f8c3 c598 	str.w	ip, [r3, #1432]	; 0x598
   2c024:	f8d1 4498 	ldr.w	r4, [r1, #1176]	; 0x498
   2c028:	f44f 6780 	mov.w	r7, #1024	; 0x400
   2c02c:	9406      	str	r4, [sp, #24]
   2c02e:	9c06      	ldr	r4, [sp, #24]
   2c030:	2410      	movs	r4, #16
   2c032:	f8c3 45a0 	str.w	r4, [r3, #1440]	; 0x5a0
   2c036:	f8d1 44a0 	ldr.w	r4, [r1, #1184]	; 0x4a0
   2c03a:	4d46      	ldr	r5, [pc, #280]	; (2c154 <rpc_transport_ipc_rx_init+0x224>)
   2c03c:	9407      	str	r4, [sp, #28]
   2c03e:	9c07      	ldr	r4, [sp, #28]
   2c040:	2440      	movs	r4, #64	; 0x40
   2c042:	f8c3 45a8 	str.w	r4, [r3, #1448]	; 0x5a8
   2c046:	f8d1 44a8 	ldr.w	r4, [r1, #1192]	; 0x4a8
   2c04a:	9408      	str	r4, [sp, #32]
   2c04c:	9c08      	ldr	r4, [sp, #32]
   2c04e:	f8c3 05ac 	str.w	r0, [r3, #1452]	; 0x5ac
   2c052:	f8d1 04ac 	ldr.w	r0, [r1, #1196]	; 0x4ac
   2c056:	9009      	str	r0, [sp, #36]	; 0x24
   2c058:	9809      	ldr	r0, [sp, #36]	; 0x24
   2c05a:	f8c3 6100 	str.w	r6, [r3, #256]	; 0x100
   2c05e:	6808      	ldr	r0, [r1, #0]
   2c060:	900a      	str	r0, [sp, #40]	; 0x28
   2c062:	980a      	ldr	r0, [sp, #40]	; 0x28
   2c064:	f8c3 6108 	str.w	r6, [r3, #264]	; 0x108
   2c068:	6888      	ldr	r0, [r1, #8]
   2c06a:	900b      	str	r0, [sp, #44]	; 0x2c
   2c06c:	980b      	ldr	r0, [sp, #44]	; 0x2c
   2c06e:	f8c3 6110 	str.w	r6, [r3, #272]	; 0x110
   2c072:	6908      	ldr	r0, [r1, #16]
   2c074:	900c      	str	r0, [sp, #48]	; 0x30
   2c076:	980c      	ldr	r0, [sp, #48]	; 0x30
   2c078:	f8c3 6118 	str.w	r6, [r3, #280]	; 0x118
   2c07c:	6988      	ldr	r0, [r1, #24]
   2c07e:	900d      	str	r0, [sp, #52]	; 0x34
   2c080:	980d      	ldr	r0, [sp, #52]	; 0x34
   2c082:	f8c3 611c 	str.w	r6, [r3, #284]	; 0x11c
   2c086:	69c8      	ldr	r0, [r1, #28]
   2c088:	f501 7101 	add.w	r1, r1, #516	; 0x204
   2c08c:	900e      	str	r0, [sp, #56]	; 0x38
   2c08e:	980e      	ldr	r0, [sp, #56]	; 0x38
   2c090:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
   2c094:	4310      	orrs	r0, r2
   2c096:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
   2c09a:	680c      	ldr	r4, [r1, #0]
   2c09c:	482e      	ldr	r0, [pc, #184]	; (2c158 <rpc_transport_ipc_rx_init+0x228>)
   2c09e:	940f      	str	r4, [sp, #60]	; 0x3c
   2c0a0:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
   2c0a2:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   2c0a6:	ea44 040c 	orr.w	r4, r4, ip
   2c0aa:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   2c0ae:	680c      	ldr	r4, [r1, #0]
   2c0b0:	9410      	str	r4, [sp, #64]	; 0x40
   2c0b2:	9c10      	ldr	r4, [sp, #64]	; 0x40
   2c0b4:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   2c0b8:	f044 0410 	orr.w	r4, r4, #16
   2c0bc:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   2c0c0:	680c      	ldr	r4, [r1, #0]
   2c0c2:	9411      	str	r4, [sp, #68]	; 0x44
   2c0c4:	9c11      	ldr	r4, [sp, #68]	; 0x44
   2c0c6:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   2c0ca:	f044 0440 	orr.w	r4, r4, #64	; 0x40
   2c0ce:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   2c0d2:	680c      	ldr	r4, [r1, #0]
   2c0d4:	9412      	str	r4, [sp, #72]	; 0x48
   2c0d6:	9c12      	ldr	r4, [sp, #72]	; 0x48
   2c0d8:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   2c0dc:	f044 0480 	orr.w	r4, r4, #128	; 0x80
   2c0e0:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   2c0e4:	f8da 3000 	ldr.w	r3, [sl]
   2c0e8:	6809      	ldr	r1, [r1, #0]
   2c0ea:	015b      	lsls	r3, r3, #5
   2c0ec:	9113      	str	r1, [sp, #76]	; 0x4c
   2c0ee:	b2db      	uxtb	r3, r3
   2c0f0:	9913      	ldr	r1, [sp, #76]	; 0x4c
   2c0f2:	f8c8 2000 	str.w	r2, [r8]
   2c0f6:	f880 332a 	strb.w	r3, [r0, #810]	; 0x32a
   2c0fa:	f8c0 7184 	str.w	r7, [r0, #388]	; 0x184
   2c0fe:	6047      	str	r7, [r0, #4]
   2c100:	9602      	str	r6, [sp, #8]
   2c102:	f8c5 6610 	str.w	r6, [r5, #1552]	; 0x610
   2c106:	f8d5 3610 	ldr.w	r3, [r5, #1552]	; 0x610
   2c10a:	9302      	str	r3, [sp, #8]
   2c10c:	9b02      	ldr	r3, [sp, #8]
   2c10e:	f8d8 3000 	ldr.w	r3, [r8]
   2c112:	2b01      	cmp	r3, #1
   2c114:	d0fb      	beq.n	2c10e <rpc_transport_ipc_rx_init+0x1de>
   2c116:	f8d9 0000 	ldr.w	r0, [r9]
   2c11a:	b015      	add	sp, #84	; 0x54
   2c11c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2c120:	f24c 000e 	movw	r0, #49166	; 0xc00e
   2c124:	b015      	add	sp, #84	; 0x54
   2c126:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2c12a:	f24c 0009 	movw	r0, #49161	; 0xc009
   2c12e:	b015      	add	sp, #84	; 0x54
   2c130:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2c134:	f24c 000e 	movw	r0, #49166	; 0xc00e
   2c138:	4770      	bx	lr
   2c13a:	bf00      	nop
   2c13c:	20022296 	.word	0x20022296
   2c140:	20020b5c 	.word	0x20020b5c
   2c144:	4002a000 	.word	0x4002a000
   2c148:	4002a610 	.word	0x4002a610
   2c14c:	4002a614 	.word	0x4002a614
   2c150:	4002a590 	.word	0x4002a590
   2c154:	40005000 	.word	0x40005000
   2c158:	e000e100 	.word	0xe000e100
   2c15c:	20020b54 	.word	0x20020b54
   2c160:	20020b60 	.word	0x20020b60
   2c164:	20020b58 	.word	0x20020b58
   2c168:	20020b64 	.word	0x20020b64
   2c16c:	20020b50 	.word	0x20020b50

0002c170 <IPC_IRQHandler>:
   2c170:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2c174:	f44f 6580 	mov.w	r5, #1024	; 0x400
   2c178:	4ca7      	ldr	r4, [pc, #668]	; (2c418 <IPC_IRQHandler+0x2a8>)
   2c17a:	b087      	sub	sp, #28
   2c17c:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
   2c180:	f3bf 8f4f 	dsb	sy
   2c184:	f3bf 8f6f 	isb	sy
   2c188:	4ea4      	ldr	r6, [pc, #656]	; (2c41c <IPC_IRQHandler+0x2ac>)
   2c18a:	f8c4 5184 	str.w	r5, [r4, #388]	; 0x184
   2c18e:	f8d6 330c 	ldr.w	r3, [r6, #780]	; 0x30c
   2c192:	061f      	lsls	r7, r3, #24
   2c194:	f100 80c8 	bmi.w	2c328 <IPC_IRQHandler+0x1b8>
   2c198:	4ba0      	ldr	r3, [pc, #640]	; (2c41c <IPC_IRQHandler+0x2ac>)
   2c19a:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
   2c19e:	07d0      	lsls	r0, r2, #31
   2c1a0:	f100 80d4 	bmi.w	2c34c <IPC_IRQHandler+0x1dc>
   2c1a4:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
   2c1a8:	f012 0240 	ands.w	r2, r2, #64	; 0x40
   2c1ac:	f040 80b6 	bne.w	2c31c <IPC_IRQHandler+0x1ac>
   2c1b0:	f8d3 130c 	ldr.w	r1, [r3, #780]	; 0x30c
   2c1b4:	0749      	lsls	r1, r1, #29
   2c1b6:	f100 80e6 	bmi.w	2c386 <IPC_IRQHandler+0x216>
   2c1ba:	f8d3 330c 	ldr.w	r3, [r3, #780]	; 0x30c
   2c1be:	06da      	lsls	r2, r3, #27
   2c1c0:	f140 809d 	bpl.w	2c2fe <IPC_IRQHandler+0x18e>
   2c1c4:	2100      	movs	r1, #0
   2c1c6:	4a95      	ldr	r2, [pc, #596]	; (2c41c <IPC_IRQHandler+0x2ac>)
   2c1c8:	4b95      	ldr	r3, [pc, #596]	; (2c420 <IPC_IRQHandler+0x2b0>)
   2c1ca:	f8c2 1110 	str.w	r1, [r2, #272]	; 0x110
   2c1ce:	681b      	ldr	r3, [r3, #0]
   2c1d0:	9304      	str	r3, [sp, #16]
   2c1d2:	9b04      	ldr	r3, [sp, #16]
   2c1d4:	f8df 8270 	ldr.w	r8, [pc, #624]	; 2c448 <IPC_IRQHandler+0x2d8>
   2c1d8:	4f92      	ldr	r7, [pc, #584]	; (2c424 <IPC_IRQHandler+0x2b4>)
   2c1da:	f8df 9270 	ldr.w	r9, [pc, #624]	; 2c44c <IPC_IRQHandler+0x2dc>
   2c1de:	f8d8 a000 	ldr.w	sl, [r8]
   2c1e2:	f8da 1000 	ldr.w	r1, [sl]
   2c1e6:	2900      	cmp	r1, #0
   2c1e8:	d03f      	beq.n	2c26a <IPC_IRQHandler+0xfa>
   2c1ea:	2200      	movs	r2, #0
   2c1ec:	4614      	mov	r4, r2
   2c1ee:	e002      	b.n	2c1f6 <IPC_IRQHandler+0x86>
   2c1f0:	3401      	adds	r4, #1
   2c1f2:	428c      	cmp	r4, r1
   2c1f4:	d227      	bcs.n	2c246 <IPC_IRQHandler+0xd6>
   2c1f6:	eb0a 05c4 	add.w	r5, sl, r4, lsl #3
   2c1fa:	68ab      	ldr	r3, [r5, #8]
   2c1fc:	2b00      	cmp	r3, #0
   2c1fe:	d0f7      	beq.n	2c1f0 <IPC_IRQHandler+0x80>
   2c200:	686e      	ldr	r6, [r5, #4]
   2c202:	b2f6      	uxtb	r6, r6
   2c204:	2e01      	cmp	r6, #1
   2c206:	d1f3      	bne.n	2c1f0 <IPC_IRQHandler+0x80>
   2c208:	6868      	ldr	r0, [r5, #4]
   2c20a:	f8b9 3000 	ldrh.w	r3, [r9]
   2c20e:	ebb3 4f10 	cmp.w	r3, r0, lsr #16
   2c212:	d1ed      	bne.n	2c1f0 <IPC_IRQHandler+0x80>
   2c214:	686a      	ldr	r2, [r5, #4]
   2c216:	3301      	adds	r3, #1
   2c218:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   2c21c:	f042 0202 	orr.w	r2, r2, #2
   2c220:	606a      	str	r2, [r5, #4]
   2c222:	68a8      	ldr	r0, [r5, #8]
   2c224:	f8a9 3000 	strh.w	r3, [r9]
   2c228:	f7ff fe60 	bl	2beec <rpc_transport_rx_handle>
   2c22c:	4632      	mov	r2, r6
   2c22e:	b928      	cbnz	r0, 2c23c <IPC_IRQHandler+0xcc>
   2c230:	686b      	ldr	r3, [r5, #4]
   2c232:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   2c236:	f043 0303 	orr.w	r3, r3, #3
   2c23a:	606b      	str	r3, [r5, #4]
   2c23c:	f8da 1000 	ldr.w	r1, [sl]
   2c240:	3401      	adds	r4, #1
   2c242:	428c      	cmp	r4, r1
   2c244:	d3d7      	bcc.n	2c1f6 <IPC_IRQHandler+0x86>
   2c246:	2a00      	cmp	r2, #0
   2c248:	d1cd      	bne.n	2c1e6 <IPC_IRQHandler+0x76>
   2c24a:	b171      	cbz	r1, 2c26a <IPC_IRQHandler+0xfa>
   2c24c:	4613      	mov	r3, r2
   2c24e:	eb0a 02c3 	add.w	r2, sl, r3, lsl #3
   2c252:	6890      	ldr	r0, [r2, #8]
   2c254:	3301      	adds	r3, #1
   2c256:	b130      	cbz	r0, 2c266 <IPC_IRQHandler+0xf6>
   2c258:	f8d2 b004 	ldr.w	fp, [r2, #4]
   2c25c:	fa5f fb8b 	uxtb.w	fp, fp
   2c260:	f1bb 0f01 	cmp.w	fp, #1
   2c264:	d003      	beq.n	2c26e <IPC_IRQHandler+0xfe>
   2c266:	428b      	cmp	r3, r1
   2c268:	d1f1      	bne.n	2c24e <IPC_IRQHandler+0xde>
   2c26a:	f04f 0b00 	mov.w	fp, #0
   2c26e:	f8d7 a000 	ldr.w	sl, [r7]
   2c272:	f8da 2000 	ldr.w	r2, [sl]
   2c276:	2a00      	cmp	r2, #0
   2c278:	d03d      	beq.n	2c2f6 <IPC_IRQHandler+0x186>
   2c27a:	2100      	movs	r1, #0
   2c27c:	460c      	mov	r4, r1
   2c27e:	e002      	b.n	2c286 <IPC_IRQHandler+0x116>
   2c280:	3401      	adds	r4, #1
   2c282:	4294      	cmp	r4, r2
   2c284:	d227      	bcs.n	2c2d6 <IPC_IRQHandler+0x166>
   2c286:	eb0a 05c4 	add.w	r5, sl, r4, lsl #3
   2c28a:	68ab      	ldr	r3, [r5, #8]
   2c28c:	2b00      	cmp	r3, #0
   2c28e:	d0f7      	beq.n	2c280 <IPC_IRQHandler+0x110>
   2c290:	686e      	ldr	r6, [r5, #4]
   2c292:	b2f6      	uxtb	r6, r6
   2c294:	2e01      	cmp	r6, #1
   2c296:	d1f3      	bne.n	2c280 <IPC_IRQHandler+0x110>
   2c298:	6868      	ldr	r0, [r5, #4]
   2c29a:	f8b9 3000 	ldrh.w	r3, [r9]
   2c29e:	ebb3 4f10 	cmp.w	r3, r0, lsr #16
   2c2a2:	d1ed      	bne.n	2c280 <IPC_IRQHandler+0x110>
   2c2a4:	686a      	ldr	r2, [r5, #4]
   2c2a6:	3301      	adds	r3, #1
   2c2a8:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   2c2ac:	f042 0202 	orr.w	r2, r2, #2
   2c2b0:	606a      	str	r2, [r5, #4]
   2c2b2:	68a8      	ldr	r0, [r5, #8]
   2c2b4:	f8a9 3000 	strh.w	r3, [r9]
   2c2b8:	f7ff fe18 	bl	2beec <rpc_transport_rx_handle>
   2c2bc:	4631      	mov	r1, r6
   2c2be:	b928      	cbnz	r0, 2c2cc <IPC_IRQHandler+0x15c>
   2c2c0:	686a      	ldr	r2, [r5, #4]
   2c2c2:	f022 03ff 	bic.w	r3, r2, #255	; 0xff
   2c2c6:	f043 0303 	orr.w	r3, r3, #3
   2c2ca:	606b      	str	r3, [r5, #4]
   2c2cc:	f8da 2000 	ldr.w	r2, [sl]
   2c2d0:	3401      	adds	r4, #1
   2c2d2:	4294      	cmp	r4, r2
   2c2d4:	d3d7      	bcc.n	2c286 <IPC_IRQHandler+0x116>
   2c2d6:	2900      	cmp	r1, #0
   2c2d8:	d1cd      	bne.n	2c276 <IPC_IRQHandler+0x106>
   2c2da:	b162      	cbz	r2, 2c2f6 <IPC_IRQHandler+0x186>
   2c2dc:	460b      	mov	r3, r1
   2c2de:	eb0a 01c3 	add.w	r1, sl, r3, lsl #3
   2c2e2:	6888      	ldr	r0, [r1, #8]
   2c2e4:	3301      	adds	r3, #1
   2c2e6:	b120      	cbz	r0, 2c2f2 <IPC_IRQHandler+0x182>
   2c2e8:	6849      	ldr	r1, [r1, #4]
   2c2ea:	b2c9      	uxtb	r1, r1
   2c2ec:	2901      	cmp	r1, #1
   2c2ee:	f43f af76 	beq.w	2c1de <IPC_IRQHandler+0x6e>
   2c2f2:	4293      	cmp	r3, r2
   2c2f4:	d1f3      	bne.n	2c2de <IPC_IRQHandler+0x16e>
   2c2f6:	f1bb 0f00 	cmp.w	fp, #0
   2c2fa:	f47f af70 	bne.w	2c1de <IPC_IRQHandler+0x6e>
   2c2fe:	f44f 6180 	mov.w	r1, #1024	; 0x400
   2c302:	4b49      	ldr	r3, [pc, #292]	; (2c428 <IPC_IRQHandler+0x2b8>)
   2c304:	4a44      	ldr	r2, [pc, #272]	; (2c418 <IPC_IRQHandler+0x2a8>)
   2c306:	681b      	ldr	r3, [r3, #0]
   2c308:	015b      	lsls	r3, r3, #5
   2c30a:	b2db      	uxtb	r3, r3
   2c30c:	f882 332a 	strb.w	r3, [r2, #810]	; 0x32a
   2c310:	f8c2 1184 	str.w	r1, [r2, #388]	; 0x184
   2c314:	6051      	str	r1, [r2, #4]
   2c316:	b007      	add	sp, #28
   2c318:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2c31c:	2206      	movs	r2, #6
   2c31e:	4b43      	ldr	r3, [pc, #268]	; (2c42c <IPC_IRQHandler+0x2bc>)
   2c320:	601a      	str	r2, [r3, #0]
   2c322:	b007      	add	sp, #28
   2c324:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2c328:	f7ff fc0c 	bl	2bb44 <ipc_trace_handle>
   2c32c:	f7ff fd78 	bl	2be20 <rpc_trace_coredump_in_progress>
   2c330:	2800      	cmp	r0, #0
   2c332:	d149      	bne.n	2c3c8 <IPC_IRQHandler+0x258>
   2c334:	4b3e      	ldr	r3, [pc, #248]	; (2c430 <IPC_IRQHandler+0x2c0>)
   2c336:	f8c6 011c 	str.w	r0, [r6, #284]	; 0x11c
   2c33a:	681b      	ldr	r3, [r3, #0]
   2c33c:	9301      	str	r3, [sp, #4]
   2c33e:	9b01      	ldr	r3, [sp, #4]
   2c340:	4b36      	ldr	r3, [pc, #216]	; (2c41c <IPC_IRQHandler+0x2ac>)
   2c342:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
   2c346:	07d0      	lsls	r0, r2, #31
   2c348:	f57f af2c 	bpl.w	2c1a4 <IPC_IRQHandler+0x34>
   2c34c:	2000      	movs	r0, #0
   2c34e:	f248 0202 	movw	r2, #32770	; 0x8002
   2c352:	4938      	ldr	r1, [pc, #224]	; (2c434 <IPC_IRQHandler+0x2c4>)
   2c354:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
   2c358:	6809      	ldr	r1, [r1, #0]
   2c35a:	9102      	str	r1, [sp, #8]
   2c35c:	9902      	ldr	r1, [sp, #8]
   2c35e:	f8d3 3614 	ldr.w	r3, [r3, #1556]	; 0x614
   2c362:	4293      	cmp	r3, r2
   2c364:	d040      	beq.n	2c3e8 <IPC_IRQHandler+0x278>
   2c366:	d81e      	bhi.n	2c3a6 <IPC_IRQHandler+0x236>
   2c368:	2b00      	cmp	r3, #0
   2c36a:	d04f      	beq.n	2c40c <IPC_IRQHandler+0x29c>
   2c36c:	2b02      	cmp	r3, #2
   2c36e:	d942      	bls.n	2c3f6 <IPC_IRQHandler+0x286>
   2c370:	f248 0201 	movw	r2, #32769	; 0x8001
   2c374:	4293      	cmp	r3, r2
   2c376:	d149      	bne.n	2c40c <IPC_IRQHandler+0x29c>
   2c378:	2003      	movs	r0, #3
   2c37a:	2207      	movs	r2, #7
   2c37c:	492b      	ldr	r1, [pc, #172]	; (2c42c <IPC_IRQHandler+0x2bc>)
   2c37e:	4b2e      	ldr	r3, [pc, #184]	; (2c438 <IPC_IRQHandler+0x2c8>)
   2c380:	6008      	str	r0, [r1, #0]
   2c382:	601a      	str	r2, [r3, #0]
   2c384:	e7cd      	b.n	2c322 <IPC_IRQHandler+0x1b2>
   2c386:	4d29      	ldr	r5, [pc, #164]	; (2c42c <IPC_IRQHandler+0x2bc>)
   2c388:	6829      	ldr	r1, [r5, #0]
   2c38a:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   2c38e:	2901      	cmp	r1, #1
   2c390:	492a      	ldr	r1, [pc, #168]	; (2c43c <IPC_IRQHandler+0x2cc>)
   2c392:	d05d      	beq.n	2c450 <IPC_IRQHandler+0x2e0>
   2c394:	680a      	ldr	r2, [r1, #0]
   2c396:	9203      	str	r2, [sp, #12]
   2c398:	9a03      	ldr	r2, [sp, #12]
   2c39a:	f8d3 330c 	ldr.w	r3, [r3, #780]	; 0x30c
   2c39e:	06db      	lsls	r3, r3, #27
   2c3a0:	f53f af10 	bmi.w	2c1c4 <IPC_IRQHandler+0x54>
   2c3a4:	e716      	b.n	2c1d4 <IPC_IRQHandler+0x64>
   2c3a6:	4a26      	ldr	r2, [pc, #152]	; (2c440 <IPC_IRQHandler+0x2d0>)
   2c3a8:	4293      	cmp	r3, r2
   2c3aa:	d814      	bhi.n	2c3d6 <IPC_IRQHandler+0x266>
   2c3ac:	f1b3 6f88 	cmp.w	r3, #71303168	; 0x4400000
   2c3b0:	d814      	bhi.n	2c3dc <IPC_IRQHandler+0x26c>
   2c3b2:	f248 0203 	movw	r2, #32771	; 0x8003
   2c3b6:	4293      	cmp	r3, r2
   2c3b8:	d128      	bne.n	2c40c <IPC_IRQHandler+0x29c>
   2c3ba:	2003      	movs	r0, #3
   2c3bc:	2204      	movs	r2, #4
   2c3be:	491b      	ldr	r1, [pc, #108]	; (2c42c <IPC_IRQHandler+0x2bc>)
   2c3c0:	4b1d      	ldr	r3, [pc, #116]	; (2c438 <IPC_IRQHandler+0x2c8>)
   2c3c2:	6008      	str	r0, [r1, #0]
   2c3c4:	601a      	str	r2, [r3, #0]
   2c3c6:	e7ac      	b.n	2c322 <IPC_IRQHandler+0x1b2>
   2c3c8:	23e0      	movs	r3, #224	; 0xe0
   2c3ca:	f884 332a 	strb.w	r3, [r4, #810]	; 0x32a
   2c3ce:	6065      	str	r5, [r4, #4]
   2c3d0:	b007      	add	sp, #28
   2c3d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2c3d6:	4a1b      	ldr	r2, [pc, #108]	; (2c444 <IPC_IRQHandler+0x2d4>)
   2c3d8:	4293      	cmp	r3, r2
   2c3da:	d117      	bne.n	2c40c <IPC_IRQHandler+0x29c>
   2c3dc:	2003      	movs	r0, #3
   2c3de:	4913      	ldr	r1, [pc, #76]	; (2c42c <IPC_IRQHandler+0x2bc>)
   2c3e0:	4a15      	ldr	r2, [pc, #84]	; (2c438 <IPC_IRQHandler+0x2c8>)
   2c3e2:	6008      	str	r0, [r1, #0]
   2c3e4:	6013      	str	r3, [r2, #0]
   2c3e6:	e79c      	b.n	2c322 <IPC_IRQHandler+0x1b2>
   2c3e8:	2003      	movs	r0, #3
   2c3ea:	2206      	movs	r2, #6
   2c3ec:	490f      	ldr	r1, [pc, #60]	; (2c42c <IPC_IRQHandler+0x2bc>)
   2c3ee:	4b12      	ldr	r3, [pc, #72]	; (2c438 <IPC_IRQHandler+0x2c8>)
   2c3f0:	6008      	str	r0, [r1, #0]
   2c3f2:	601a      	str	r2, [r3, #0]
   2c3f4:	e795      	b.n	2c322 <IPC_IRQHandler+0x1b2>
   2c3f6:	2303      	movs	r3, #3
   2c3f8:	4618      	mov	r0, r3
   2c3fa:	490c      	ldr	r1, [pc, #48]	; (2c42c <IPC_IRQHandler+0x2bc>)
   2c3fc:	4a0e      	ldr	r2, [pc, #56]	; (2c438 <IPC_IRQHandler+0x2c8>)
   2c3fe:	600b      	str	r3, [r1, #0]
   2c400:	6013      	str	r3, [r2, #0]
   2c402:	b007      	add	sp, #28
   2c404:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2c408:	f7ff b910 	b.w	2b62c <rpc_transport_ipc_fault_handler>
   2c40c:	2303      	movs	r3, #3
   2c40e:	4907      	ldr	r1, [pc, #28]	; (2c42c <IPC_IRQHandler+0x2bc>)
   2c410:	4a09      	ldr	r2, [pc, #36]	; (2c438 <IPC_IRQHandler+0x2c8>)
   2c412:	600b      	str	r3, [r1, #0]
   2c414:	6013      	str	r3, [r2, #0]
   2c416:	e784      	b.n	2c322 <IPC_IRQHandler+0x1b2>
   2c418:	e000e100 	.word	0xe000e100
   2c41c:	4002a000 	.word	0x4002a000
   2c420:	4002a110 	.word	0x4002a110
   2c424:	20020b5c 	.word	0x20020b5c
   2c428:	20020b54 	.word	0x20020b54
   2c42c:	20020b58 	.word	0x20020b58
   2c430:	4002a11c 	.word	0x4002a11c
   2c434:	4002a100 	.word	0x4002a100
   2c438:	20020b50 	.word	0x20020b50
   2c43c:	4002a108 	.word	0x4002a108
   2c440:	04400004 	.word	0x04400004
   2c444:	05500001 	.word	0x05500001
   2c448:	20020b60 	.word	0x20020b60
   2c44c:	20022296 	.word	0x20022296
   2c450:	4a37      	ldr	r2, [pc, #220]	; (2c530 <IPC_IRQHandler+0x3c0>)
   2c452:	680b      	ldr	r3, [r1, #0]
   2c454:	6812      	ldr	r2, [r2, #0]
   2c456:	9305      	str	r3, [sp, #20]
   2c458:	6893      	ldr	r3, [r2, #8]
   2c45a:	4836      	ldr	r0, [pc, #216]	; (2c534 <IPC_IRQHandler+0x3c4>)
   2c45c:	4936      	ldr	r1, [pc, #216]	; (2c538 <IPC_IRQHandler+0x3c8>)
   2c45e:	6003      	str	r3, [r0, #0]
   2c460:	6854      	ldr	r4, [r2, #4]
   2c462:	9a05      	ldr	r2, [sp, #20]
   2c464:	600c      	str	r4, [r1, #0]
   2c466:	b16b      	cbz	r3, 2c484 <IPC_IRQHandler+0x314>
   2c468:	b164      	cbz	r4, 2c484 <IPC_IRQHandler+0x314>
   2c46a:	681b      	ldr	r3, [r3, #0]
   2c46c:	2b10      	cmp	r3, #16
   2c46e:	d802      	bhi.n	2c476 <IPC_IRQHandler+0x306>
   2c470:	6822      	ldr	r2, [r4, #0]
   2c472:	2a10      	cmp	r2, #16
   2c474:	d90c      	bls.n	2c490 <IPC_IRQHandler+0x320>
   2c476:	2103      	movs	r1, #3
   2c478:	f24c 0206 	movw	r2, #49158	; 0xc006
   2c47c:	4b2f      	ldr	r3, [pc, #188]	; (2c53c <IPC_IRQHandler+0x3cc>)
   2c47e:	6029      	str	r1, [r5, #0]
   2c480:	601a      	str	r2, [r3, #0]
   2c482:	e74e      	b.n	2c322 <IPC_IRQHandler+0x1b2>
   2c484:	2103      	movs	r1, #3
   2c486:	2210      	movs	r2, #16
   2c488:	4b2c      	ldr	r3, [pc, #176]	; (2c53c <IPC_IRQHandler+0x3cc>)
   2c48a:	6029      	str	r1, [r5, #0]
   2c48c:	601a      	str	r2, [r3, #0]
   2c48e:	e748      	b.n	2c322 <IPC_IRQHandler+0x1b2>
   2c490:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 2c548 <IPC_IRQHandler+0x3d8>
   2c494:	2a00      	cmp	r2, #0
   2c496:	d042      	beq.n	2c51e <IPC_IRQHandler+0x3ae>
   2c498:	2300      	movs	r3, #0
   2c49a:	f104 0904 	add.w	r9, r4, #4
   2c49e:	461e      	mov	r6, r3
   2c4a0:	e002      	b.n	2c4a8 <IPC_IRQHandler+0x338>
   2c4a2:	3601      	adds	r6, #1
   2c4a4:	4296      	cmp	r6, r2
   2c4a6:	d22a      	bcs.n	2c4fe <IPC_IRQHandler+0x38e>
   2c4a8:	00f7      	lsls	r7, r6, #3
   2c4aa:	19e1      	adds	r1, r4, r7
   2c4ac:	6888      	ldr	r0, [r1, #8]
   2c4ae:	2800      	cmp	r0, #0
   2c4b0:	d0f7      	beq.n	2c4a2 <IPC_IRQHandler+0x332>
   2c4b2:	f8d1 a004 	ldr.w	sl, [r1, #4]
   2c4b6:	fa5f fa8a 	uxtb.w	sl, sl
   2c4ba:	f1ba 0f01 	cmp.w	sl, #1
   2c4be:	d1f0      	bne.n	2c4a2 <IPC_IRQHandler+0x332>
   2c4c0:	f8d1 c004 	ldr.w	ip, [r1, #4]
   2c4c4:	f8b8 0000 	ldrh.w	r0, [r8]
   2c4c8:	ebb0 4f1c 	cmp.w	r0, ip, lsr #16
   2c4cc:	d1e9      	bne.n	2c4a2 <IPC_IRQHandler+0x332>
   2c4ce:	684b      	ldr	r3, [r1, #4]
   2c4d0:	1c42      	adds	r2, r0, #1
   2c4d2:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   2c4d6:	f043 0302 	orr.w	r3, r3, #2
   2c4da:	604b      	str	r3, [r1, #4]
   2c4dc:	6888      	ldr	r0, [r1, #8]
   2c4de:	f8a8 2000 	strh.w	r2, [r8]
   2c4e2:	f7ff fd03 	bl	2beec <rpc_transport_rx_handle>
   2c4e6:	4653      	mov	r3, sl
   2c4e8:	b938      	cbnz	r0, 2c4fa <IPC_IRQHandler+0x38a>
   2c4ea:	f859 2007 	ldr.w	r2, [r9, r7]
   2c4ee:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   2c4f2:	f042 0203 	orr.w	r2, r2, #3
   2c4f6:	f849 2007 	str.w	r2, [r9, r7]
   2c4fa:	6822      	ldr	r2, [r4, #0]
   2c4fc:	e7d1      	b.n	2c4a2 <IPC_IRQHandler+0x332>
   2c4fe:	2b00      	cmp	r3, #0
   2c500:	d1c8      	bne.n	2c494 <IPC_IRQHandler+0x324>
   2c502:	b912      	cbnz	r2, 2c50a <IPC_IRQHandler+0x39a>
   2c504:	e00b      	b.n	2c51e <IPC_IRQHandler+0x3ae>
   2c506:	4293      	cmp	r3, r2
   2c508:	d009      	beq.n	2c51e <IPC_IRQHandler+0x3ae>
   2c50a:	eb04 01c3 	add.w	r1, r4, r3, lsl #3
   2c50e:	6888      	ldr	r0, [r1, #8]
   2c510:	3301      	adds	r3, #1
   2c512:	2800      	cmp	r0, #0
   2c514:	d0f7      	beq.n	2c506 <IPC_IRQHandler+0x396>
   2c516:	6849      	ldr	r1, [r1, #4]
   2c518:	b2c9      	uxtb	r1, r1
   2c51a:	2901      	cmp	r1, #1
   2c51c:	d1f3      	bne.n	2c506 <IPC_IRQHandler+0x396>
   2c51e:	2002      	movs	r0, #2
   2c520:	4b07      	ldr	r3, [pc, #28]	; (2c540 <IPC_IRQHandler+0x3d0>)
   2c522:	f44f 6180 	mov.w	r1, #1024	; 0x400
   2c526:	4a07      	ldr	r2, [pc, #28]	; (2c544 <IPC_IRQHandler+0x3d4>)
   2c528:	681b      	ldr	r3, [r3, #0]
   2c52a:	6028      	str	r0, [r5, #0]
   2c52c:	e6ec      	b.n	2c308 <IPC_IRQHandler+0x198>
   2c52e:	bf00      	nop
   2c530:	20020b64 	.word	0x20020b64
   2c534:	20020b60 	.word	0x20020b60
   2c538:	20020b5c 	.word	0x20020b5c
   2c53c:	20020b50 	.word	0x20020b50
   2c540:	20020b54 	.word	0x20020b54
   2c544:	e000e100 	.word	0xe000e100
   2c548:	20022296 	.word	0x20022296

0002c54c <rpc_transport_msg_free>:
   2c54c:	b430      	push	{r4, r5}
   2c54e:	4b18      	ldr	r3, [pc, #96]	; (2c5b0 <rpc_transport_msg_free+0x64>)
   2c550:	681c      	ldr	r4, [r3, #0]
   2c552:	6825      	ldr	r5, [r4, #0]
   2c554:	b16d      	cbz	r5, 2c572 <rpc_transport_msg_free+0x26>
   2c556:	68a3      	ldr	r3, [r4, #8]
   2c558:	4283      	cmp	r3, r0
   2c55a:	d027      	beq.n	2c5ac <rpc_transport_msg_free+0x60>
   2c55c:	2300      	movs	r3, #0
   2c55e:	e002      	b.n	2c566 <rpc_transport_msg_free+0x1a>
   2c560:	6889      	ldr	r1, [r1, #8]
   2c562:	4281      	cmp	r1, r0
   2c564:	d019      	beq.n	2c59a <rpc_transport_msg_free+0x4e>
   2c566:	3301      	adds	r3, #1
   2c568:	00da      	lsls	r2, r3, #3
   2c56a:	42ab      	cmp	r3, r5
   2c56c:	eb04 0102 	add.w	r1, r4, r2
   2c570:	d1f6      	bne.n	2c560 <rpc_transport_msg_free+0x14>
   2c572:	4b10      	ldr	r3, [pc, #64]	; (2c5b4 <rpc_transport_msg_free+0x68>)
   2c574:	681c      	ldr	r4, [r3, #0]
   2c576:	6825      	ldr	r5, [r4, #0]
   2c578:	b16d      	cbz	r5, 2c596 <rpc_transport_msg_free+0x4a>
   2c57a:	68a3      	ldr	r3, [r4, #8]
   2c57c:	4283      	cmp	r3, r0
   2c57e:	d015      	beq.n	2c5ac <rpc_transport_msg_free+0x60>
   2c580:	2300      	movs	r3, #0
   2c582:	e002      	b.n	2c58a <rpc_transport_msg_free+0x3e>
   2c584:	6889      	ldr	r1, [r1, #8]
   2c586:	4281      	cmp	r1, r0
   2c588:	d007      	beq.n	2c59a <rpc_transport_msg_free+0x4e>
   2c58a:	3301      	adds	r3, #1
   2c58c:	00da      	lsls	r2, r3, #3
   2c58e:	429d      	cmp	r5, r3
   2c590:	eb04 0102 	add.w	r1, r4, r2
   2c594:	d1f6      	bne.n	2c584 <rpc_transport_msg_free+0x38>
   2c596:	bc30      	pop	{r4, r5}
   2c598:	4770      	bx	lr
   2c59a:	3204      	adds	r2, #4
   2c59c:	58a3      	ldr	r3, [r4, r2]
   2c59e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   2c5a2:	f043 0303 	orr.w	r3, r3, #3
   2c5a6:	50a3      	str	r3, [r4, r2]
   2c5a8:	bc30      	pop	{r4, r5}
   2c5aa:	4770      	bx	lr
   2c5ac:	2204      	movs	r2, #4
   2c5ae:	e7f5      	b.n	2c59c <rpc_transport_msg_free+0x50>
   2c5b0:	20020b60 	.word	0x20020b60
   2c5b4:	20020b5c 	.word	0x20020b5c

0002c5b8 <rpc_transport_ipc_tx_init>:
   2c5b8:	2800      	cmp	r0, #0
   2c5ba:	f000 80b8 	beq.w	2c72e <rpc_transport_ipc_tx_init+0x176>
   2c5be:	2900      	cmp	r1, #0
   2c5c0:	f000 80b5 	beq.w	2c72e <rpc_transport_ipc_tx_init+0x176>
   2c5c4:	2a00      	cmp	r2, #0
   2c5c6:	f000 80b2 	beq.w	2c72e <rpc_transport_ipc_tx_init+0x176>
   2c5ca:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2c5ce:	6a04      	ldr	r4, [r0, #32]
   2c5d0:	b085      	sub	sp, #20
   2c5d2:	2c00      	cmp	r4, #0
   2c5d4:	f000 80a6 	beq.w	2c724 <rpc_transport_ipc_tx_init+0x16c>
   2c5d8:	6a40      	ldr	r0, [r0, #36]	; 0x24
   2c5da:	2800      	cmp	r0, #0
   2c5dc:	f000 80a2 	beq.w	2c724 <rpc_transport_ipc_tx_init+0x16c>
   2c5e0:	f642 4587 	movw	r5, #11399	; 0x2c87
   2c5e4:	f04f 0a00 	mov.w	sl, #0
   2c5e8:	4e55      	ldr	r6, [pc, #340]	; (2c740 <rpc_transport_ipc_tx_init+0x188>)
   2c5ea:	42a8      	cmp	r0, r5
   2c5ec:	f886 a000 	strb.w	sl, [r6]
   2c5f0:	f240 80a0 	bls.w	2c734 <rpc_transport_ipc_tx_init+0x17c>
   2c5f4:	2708      	movs	r7, #8
   2c5f6:	f8df 9180 	ldr.w	r9, [pc, #384]	; 2c778 <rpc_transport_ipc_tx_init+0x1c0>
   2c5fa:	4620      	mov	r0, r4
   2c5fc:	4616      	mov	r6, r2
   2c5fe:	460d      	mov	r5, r1
   2c600:	2244      	movs	r2, #68	; 0x44
   2c602:	4651      	mov	r1, sl
   2c604:	f8c9 4000 	str.w	r4, [r9]
   2c608:	f00d fbd9 	bl	39dbe <memset>
   2c60c:	f8d9 2000 	ldr.w	r2, [r9]
   2c610:	f104 0344 	add.w	r3, r4, #68	; 0x44
   2c614:	f8df 8164 	ldr.w	r8, [pc, #356]	; 2c77c <rpc_transport_ipc_tx_init+0x1c4>
   2c618:	f882 a001 	strb.w	sl, [r2, #1]
   2c61c:	f882 a002 	strb.w	sl, [r2, #2]
   2c620:	f882 a003 	strb.w	sl, [r2, #3]
   2c624:	7017      	strb	r7, [r2, #0]
   2c626:	4618      	mov	r0, r3
   2c628:	2244      	movs	r2, #68	; 0x44
   2c62a:	4651      	mov	r1, sl
   2c62c:	f8c8 3000 	str.w	r3, [r8]
   2c630:	f00d fbc5 	bl	39dbe <memset>
   2c634:	f8d8 2000 	ldr.w	r2, [r8]
   2c638:	f104 0388 	add.w	r3, r4, #136	; 0x88
   2c63c:	f8df b140 	ldr.w	fp, [pc, #320]	; 2c780 <rpc_transport_ipc_tx_init+0x1c8>
   2c640:	7017      	strb	r7, [r2, #0]
   2c642:	f882 a001 	strb.w	sl, [r2, #1]
   2c646:	f882 a002 	strb.w	sl, [r2, #2]
   2c64a:	f882 a003 	strb.w	sl, [r2, #3]
   2c64e:	4618      	mov	r0, r3
   2c650:	f44f 7200 	mov.w	r2, #512	; 0x200
   2c654:	4651      	mov	r1, sl
   2c656:	f8cb 3000 	str.w	r3, [fp]
   2c65a:	f00d fbb0 	bl	39dbe <memset>
   2c65e:	4b39      	ldr	r3, [pc, #228]	; (2c744 <rpc_transport_ipc_tx_init+0x18c>)
   2c660:	f504 7c22 	add.w	ip, r4, #648	; 0x288
   2c664:	f8c3 c000 	str.w	ip, [r3]
   2c668:	4651      	mov	r1, sl
   2c66a:	4660      	mov	r0, ip
   2c66c:	f44f 7200 	mov.w	r2, #512	; 0x200
   2c670:	f00d fba5 	bl	39dbe <memset>
   2c674:	f44f 5c20 	mov.w	ip, #10240	; 0x2800
   2c678:	2106      	movs	r1, #6
   2c67a:	f04f 0e01 	mov.w	lr, #1
   2c67e:	f44f 3001 	mov.w	r0, #132096	; 0x20400
   2c682:	f44f 3288 	mov.w	r2, #69632	; 0x11000
   2c686:	4b30      	ldr	r3, [pc, #192]	; (2c748 <rpc_transport_ipc_tx_init+0x190>)
   2c688:	f504 6491 	add.w	r4, r4, #1160	; 0x488
   2c68c:	605c      	str	r4, [r3, #4]
   2c68e:	4c2f      	ldr	r4, [pc, #188]	; (2c74c <rpc_transport_ipc_tx_init+0x194>)
   2c690:	f8c3 c008 	str.w	ip, [r3, #8]
   2c694:	8199      	strh	r1, [r3, #12]
   2c696:	f8a3 e000 	strh.w	lr, [r3]
   2c69a:	4619      	mov	r1, r3
   2c69c:	611c      	str	r4, [r3, #16]
   2c69e:	4b2c      	ldr	r3, [pc, #176]	; (2c750 <rpc_transport_ipc_tx_init+0x198>)
   2c6a0:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 2c784 <rpc_transport_ipc_tx_init+0x1cc>
   2c6a4:	6120      	str	r0, [r4, #16]
   2c6a6:	482b      	ldr	r0, [pc, #172]	; (2c754 <rpc_transport_ipc_tx_init+0x19c>)
   2c6a8:	6063      	str	r3, [r4, #4]
   2c6aa:	f503 73c0 	add.w	r3, r3, #384	; 0x180
   2c6ae:	60a0      	str	r0, [r4, #8]
   2c6b0:	f8c4 c000 	str.w	ip, [r4]
   2c6b4:	4828      	ldr	r0, [pc, #160]	; (2c758 <rpc_transport_ipc_tx_init+0x1a0>)
   2c6b6:	60e3      	str	r3, [r4, #12]
   2c6b8:	6162      	str	r2, [r4, #20]
   2c6ba:	f7fd fe5b 	bl	2a374 <nrf_mem_register>
   2c6be:	2800      	cmp	r0, #0
   2c6c0:	d132      	bne.n	2c728 <rpc_transport_ipc_tx_init+0x170>
   2c6c2:	f04f 0c02 	mov.w	ip, #2
   2c6c6:	2420      	movs	r4, #32
   2c6c8:	f8d9 1000 	ldr.w	r1, [r9]
   2c6cc:	f8db 2000 	ldr.w	r2, [fp]
   2c6d0:	6029      	str	r1, [r5, #0]
   2c6d2:	4b1c      	ldr	r3, [pc, #112]	; (2c744 <rpc_transport_ipc_tx_init+0x18c>)
   2c6d4:	f8d8 1000 	ldr.w	r1, [r8]
   2c6d8:	f8df e0ac 	ldr.w	lr, [pc, #172]	; 2c788 <rpc_transport_ipc_tx_init+0x1d0>
   2c6dc:	4d1f      	ldr	r5, [pc, #124]	; (2c75c <rpc_transport_ipc_tx_init+0x1a4>)
   2c6de:	6031      	str	r1, [r6, #0]
   2c6e0:	f8ce 2000 	str.w	r2, [lr]
   2c6e4:	681b      	ldr	r3, [r3, #0]
   2c6e6:	491e      	ldr	r1, [pc, #120]	; (2c760 <rpc_transport_ipc_tx_init+0x1a8>)
   2c6e8:	f502 7200 	add.w	r2, r2, #512	; 0x200
   2c6ec:	602a      	str	r2, [r5, #0]
   2c6ee:	4e1d      	ldr	r6, [pc, #116]	; (2c764 <rpc_transport_ipc_tx_init+0x1ac>)
   2c6f0:	4a1d      	ldr	r2, [pc, #116]	; (2c768 <rpc_transport_ipc_tx_init+0x1b0>)
   2c6f2:	4d1e      	ldr	r5, [pc, #120]	; (2c76c <rpc_transport_ipc_tx_init+0x1b4>)
   2c6f4:	600b      	str	r3, [r1, #0]
   2c6f6:	f503 7300 	add.w	r3, r3, #512	; 0x200
   2c6fa:	491d      	ldr	r1, [pc, #116]	; (2c770 <rpc_transport_ipc_tx_init+0x1b8>)
   2c6fc:	6033      	str	r3, [r6, #0]
   2c6fe:	8028      	strh	r0, [r5, #0]
   2c700:	f8c2 c514 	str.w	ip, [r2, #1300]	; 0x514
   2c704:	6809      	ldr	r1, [r1, #0]
   2c706:	4b1b      	ldr	r3, [pc, #108]	; (2c774 <rpc_transport_ipc_tx_init+0x1bc>)
   2c708:	9103      	str	r1, [sp, #12]
   2c70a:	9903      	ldr	r1, [sp, #12]
   2c70c:	f8c2 751c 	str.w	r7, [r2, #1308]	; 0x51c
   2c710:	6819      	ldr	r1, [r3, #0]
   2c712:	443b      	add	r3, r7
   2c714:	9102      	str	r1, [sp, #8]
   2c716:	9902      	ldr	r1, [sp, #8]
   2c718:	f8c2 4524 	str.w	r4, [r2, #1316]	; 0x524
   2c71c:	681b      	ldr	r3, [r3, #0]
   2c71e:	9301      	str	r3, [sp, #4]
   2c720:	9b01      	ldr	r3, [sp, #4]
   2c722:	e001      	b.n	2c728 <rpc_transport_ipc_tx_init+0x170>
   2c724:	f24c 0007 	movw	r0, #49159	; 0xc007
   2c728:	b005      	add	sp, #20
   2c72a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2c72e:	f24c 000e 	movw	r0, #49166	; 0xc00e
   2c732:	4770      	bx	lr
   2c734:	f24c 0004 	movw	r0, #49156	; 0xc004
   2c738:	b005      	add	sp, #20
   2c73a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2c73e:	bf00      	nop
   2c740:	20026147 	.word	0x20026147
   2c744:	20020b90 	.word	0x20020b90
   2c748:	20020b7c 	.word	0x20020b7c
   2c74c:	20020ba0 	.word	0x20020ba0
   2c750:	00040080 	.word	0x00040080
   2c754:	00040100 	.word	0x00040100
   2c758:	20020b68 	.word	0x20020b68
   2c75c:	20020b74 	.word	0x20020b74
   2c760:	20020b70 	.word	0x20020b70
   2c764:	20020b6c 	.word	0x20020b6c
   2c768:	4002a000 	.word	0x4002a000
   2c76c:	20022298 	.word	0x20022298
   2c770:	4002a514 	.word	0x4002a514
   2c774:	4002a51c 	.word	0x4002a51c
   2c778:	20020b9c 	.word	0x20020b9c
   2c77c:	20020b94 	.word	0x20020b94
   2c780:	20020b98 	.word	0x20020b98
   2c784:	00080040 	.word	0x00080040
   2c788:	20020b78 	.word	0x20020b78

0002c78c <rpc_transport_ipc_tx_send>:
   2c78c:	2800      	cmp	r0, #0
   2c78e:	d05f      	beq.n	2c850 <rpc_transport_ipc_tx_send+0xc4>
   2c790:	b470      	push	{r4, r5, r6}
   2c792:	4b33      	ldr	r3, [pc, #204]	; (2c860 <rpc_transport_ipc_tx_send+0xd4>)
   2c794:	b083      	sub	sp, #12
   2c796:	681a      	ldr	r2, [r3, #0]
   2c798:	4b32      	ldr	r3, [pc, #200]	; (2c864 <rpc_transport_ipc_tx_send+0xd8>)
   2c79a:	4282      	cmp	r2, r0
   2c79c:	d81e      	bhi.n	2c7dc <rpc_transport_ipc_tx_send+0x50>
   2c79e:	681b      	ldr	r3, [r3, #0]
   2c7a0:	4931      	ldr	r1, [pc, #196]	; (2c868 <rpc_transport_ipc_tx_send+0xdc>)
   2c7a2:	4283      	cmp	r3, r0
   2c7a4:	6809      	ldr	r1, [r1, #0]
   2c7a6:	d803      	bhi.n	2c7b0 <rpc_transport_ipc_tx_send+0x24>
   2c7a8:	4c30      	ldr	r4, [pc, #192]	; (2c86c <rpc_transport_ipc_tx_send+0xe0>)
   2c7aa:	6824      	ldr	r4, [r4, #0]
   2c7ac:	4284      	cmp	r4, r0
   2c7ae:	d847      	bhi.n	2c840 <rpc_transport_ipc_tx_send+0xb4>
   2c7b0:	4281      	cmp	r1, r0
   2c7b2:	d90e      	bls.n	2c7d2 <rpc_transport_ipc_tx_send+0x46>
   2c7b4:	4b2e      	ldr	r3, [pc, #184]	; (2c870 <rpc_transport_ipc_tx_send+0xe4>)
   2c7b6:	781b      	ldrb	r3, [r3, #0]
   2c7b8:	2b00      	cmp	r3, #0
   2c7ba:	d14c      	bne.n	2c856 <rpc_transport_ipc_tx_send+0xca>
   2c7bc:	1a83      	subs	r3, r0, r2
   2c7be:	492d      	ldr	r1, [pc, #180]	; (2c874 <rpc_transport_ipc_tx_send+0xe8>)
   2c7c0:	099e      	lsrs	r6, r3, #6
   2c7c2:	069b      	lsls	r3, r3, #26
   2c7c4:	680a      	ldr	r2, [r1, #0]
   2c7c6:	4c2c      	ldr	r4, [pc, #176]	; (2c878 <rpc_transport_ipc_tx_send+0xec>)
   2c7c8:	f04f 0103 	mov.w	r1, #3
   2c7cc:	f04f 0502 	mov.w	r5, #2
   2c7d0:	d014      	beq.n	2c7fc <rpc_transport_ipc_tx_send+0x70>
   2c7d2:	f24c 0010 	movw	r0, #49168	; 0xc010
   2c7d6:	b003      	add	sp, #12
   2c7d8:	bc70      	pop	{r4, r5, r6}
   2c7da:	4770      	bx	lr
   2c7dc:	681b      	ldr	r3, [r3, #0]
   2c7de:	4298      	cmp	r0, r3
   2c7e0:	d3f7      	bcc.n	2c7d2 <rpc_transport_ipc_tx_send+0x46>
   2c7e2:	4a22      	ldr	r2, [pc, #136]	; (2c86c <rpc_transport_ipc_tx_send+0xe0>)
   2c7e4:	6812      	ldr	r2, [r2, #0]
   2c7e6:	4290      	cmp	r0, r2
   2c7e8:	d2f3      	bcs.n	2c7d2 <rpc_transport_ipc_tx_send+0x46>
   2c7ea:	2101      	movs	r1, #1
   2c7ec:	1ac3      	subs	r3, r0, r3
   2c7ee:	4a23      	ldr	r2, [pc, #140]	; (2c87c <rpc_transport_ipc_tx_send+0xf0>)
   2c7f0:	099e      	lsrs	r6, r3, #6
   2c7f2:	069b      	lsls	r3, r3, #26
   2c7f4:	460d      	mov	r5, r1
   2c7f6:	6812      	ldr	r2, [r2, #0]
   2c7f8:	4c21      	ldr	r4, [pc, #132]	; (2c880 <rpc_transport_ipc_tx_send+0xf4>)
   2c7fa:	d1ea      	bne.n	2c7d2 <rpc_transport_ipc_tx_send+0x46>
   2c7fc:	6843      	ldr	r3, [r0, #4]
   2c7fe:	b2db      	uxtb	r3, r3
   2c800:	429d      	cmp	r5, r3
   2c802:	d120      	bne.n	2c846 <rpc_transport_ipc_tx_send+0xba>
   2c804:	2020      	movs	r0, #32
   2c806:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
   2c80a:	4d1e      	ldr	r5, [pc, #120]	; (2c884 <rpc_transport_ipc_tx_send+0xf8>)
   2c80c:	6853      	ldr	r3, [r2, #4]
   2c80e:	882e      	ldrh	r6, [r5, #0]
   2c810:	b29b      	uxth	r3, r3
   2c812:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   2c816:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   2c81a:	f043 0301 	orr.w	r3, r3, #1
   2c81e:	6053      	str	r3, [r2, #4]
   2c820:	bf00      	nop
   2c822:	3801      	subs	r0, #1
   2c824:	d1fc      	bne.n	2c820 <rpc_transport_ipc_tx_send+0x94>
   2c826:	2201      	movs	r2, #1
   2c828:	4b17      	ldr	r3, [pc, #92]	; (2c888 <rpc_transport_ipc_tx_send+0xfc>)
   2c82a:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
   2c82e:	6822      	ldr	r2, [r4, #0]
   2c830:	882b      	ldrh	r3, [r5, #0]
   2c832:	9201      	str	r2, [sp, #4]
   2c834:	9a01      	ldr	r2, [sp, #4]
   2c836:	3301      	adds	r3, #1
   2c838:	802b      	strh	r3, [r5, #0]
   2c83a:	b003      	add	sp, #12
   2c83c:	bc70      	pop	{r4, r5, r6}
   2c83e:	4770      	bx	lr
   2c840:	4281      	cmp	r1, r0
   2c842:	d9d2      	bls.n	2c7ea <rpc_transport_ipc_tx_send+0x5e>
   2c844:	e7b6      	b.n	2c7b4 <rpc_transport_ipc_tx_send+0x28>
   2c846:	f24c 0007 	movw	r0, #49159	; 0xc007
   2c84a:	b003      	add	sp, #12
   2c84c:	bc70      	pop	{r4, r5, r6}
   2c84e:	4770      	bx	lr
   2c850:	f24c 000e 	movw	r0, #49166	; 0xc00e
   2c854:	4770      	bx	lr
   2c856:	f24c 000f 	movw	r0, #49167	; 0xc00f
   2c85a:	b003      	add	sp, #12
   2c85c:	bc70      	pop	{r4, r5, r6}
   2c85e:	4770      	bx	lr
   2c860:	20020b78 	.word	0x20020b78
   2c864:	20020b70 	.word	0x20020b70
   2c868:	20020b74 	.word	0x20020b74
   2c86c:	20020b6c 	.word	0x20020b6c
   2c870:	20026147 	.word	0x20026147
   2c874:	20020b9c 	.word	0x20020b9c
   2c878:	4002a00c 	.word	0x4002a00c
   2c87c:	20020b94 	.word	0x20020b94
   2c880:	4002a004 	.word	0x4002a004
   2c884:	20022298 	.word	0x20022298
   2c888:	4002a000 	.word	0x4002a000

0002c88c <rpc_transport_ipc_tx_rpc_data_alloc>:
   2c88c:	4b18      	ldr	r3, [pc, #96]	; (2c8f0 <rpc_transport_ipc_tx_rpc_data_alloc+0x64>)
   2c88e:	781b      	ldrb	r3, [r3, #0]
   2c890:	bb63      	cbnz	r3, 2c8ec <rpc_transport_ipc_tx_rpc_data_alloc+0x60>
   2c892:	b4f0      	push	{r4, r5, r6, r7}
   2c894:	4a17      	ldr	r2, [pc, #92]	; (2c8f4 <rpc_transport_ipc_tx_rpc_data_alloc+0x68>)
   2c896:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   2c89a:	6814      	ldr	r4, [r2, #0]
   2c89c:	4b16      	ldr	r3, [pc, #88]	; (2c8f8 <rpc_transport_ipc_tx_rpc_data_alloc+0x6c>)
   2c89e:	6825      	ldr	r5, [r4, #0]
   2c8a0:	681e      	ldr	r6, [r3, #0]
   2c8a2:	b1a5      	cbz	r5, 2c8ce <rpc_transport_ipc_tx_rpc_data_alloc+0x42>
   2c8a4:	4607      	mov	r7, r0
   2c8a6:	00c1      	lsls	r1, r0, #3
   2c8a8:	1863      	adds	r3, r4, r1
   2c8aa:	685a      	ldr	r2, [r3, #4]
   2c8ac:	b2d2      	uxtb	r2, r2
   2c8ae:	2a03      	cmp	r2, #3
   2c8b0:	d104      	bne.n	2c8bc <rpc_transport_ipc_tx_rpc_data_alloc+0x30>
   2c8b2:	609f      	str	r7, [r3, #8]
   2c8b4:	685a      	ldr	r2, [r3, #4]
   2c8b6:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   2c8ba:	605a      	str	r2, [r3, #4]
   2c8bc:	685a      	ldr	r2, [r3, #4]
   2c8be:	f012 0fff 	tst.w	r2, #255	; 0xff
   2c8c2:	d101      	bne.n	2c8c8 <rpc_transport_ipc_tx_rpc_data_alloc+0x3c>
   2c8c4:	689b      	ldr	r3, [r3, #8]
   2c8c6:	b12b      	cbz	r3, 2c8d4 <rpc_transport_ipc_tx_rpc_data_alloc+0x48>
   2c8c8:	3001      	adds	r0, #1
   2c8ca:	42a8      	cmp	r0, r5
   2c8cc:	d1eb      	bne.n	2c8a6 <rpc_transport_ipc_tx_rpc_data_alloc+0x1a>
   2c8ce:	2000      	movs	r0, #0
   2c8d0:	bcf0      	pop	{r4, r5, r6, r7}
   2c8d2:	4770      	bx	lr
   2c8d4:	eb06 1080 	add.w	r0, r6, r0, lsl #6
   2c8d8:	4421      	add	r1, r4
   2c8da:	6088      	str	r0, [r1, #8]
   2c8dc:	6843      	ldr	r3, [r0, #4]
   2c8de:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   2c8e2:	f043 0302 	orr.w	r3, r3, #2
   2c8e6:	6043      	str	r3, [r0, #4]
   2c8e8:	bcf0      	pop	{r4, r5, r6, r7}
   2c8ea:	4770      	bx	lr
   2c8ec:	2000      	movs	r0, #0
   2c8ee:	4770      	bx	lr
   2c8f0:	20026147 	.word	0x20026147
   2c8f4:	20020b9c 	.word	0x20020b9c
   2c8f8:	20020b98 	.word	0x20020b98

0002c8fc <rpc_transport_ipc_tx_rpc_ctrl_alloc>:
   2c8fc:	b4f0      	push	{r4, r5, r6, r7}
   2c8fe:	4a15      	ldr	r2, [pc, #84]	; (2c954 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x58>)
   2c900:	4b15      	ldr	r3, [pc, #84]	; (2c958 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x5c>)
   2c902:	6814      	ldr	r4, [r2, #0]
   2c904:	681e      	ldr	r6, [r3, #0]
   2c906:	6825      	ldr	r5, [r4, #0]
   2c908:	b1ad      	cbz	r5, 2c936 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x3a>
   2c90a:	2000      	movs	r0, #0
   2c90c:	4607      	mov	r7, r0
   2c90e:	00c1      	lsls	r1, r0, #3
   2c910:	1863      	adds	r3, r4, r1
   2c912:	685a      	ldr	r2, [r3, #4]
   2c914:	b2d2      	uxtb	r2, r2
   2c916:	2a03      	cmp	r2, #3
   2c918:	d104      	bne.n	2c924 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x28>
   2c91a:	609f      	str	r7, [r3, #8]
   2c91c:	685a      	ldr	r2, [r3, #4]
   2c91e:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   2c922:	605a      	str	r2, [r3, #4]
   2c924:	685a      	ldr	r2, [r3, #4]
   2c926:	f012 0fff 	tst.w	r2, #255	; 0xff
   2c92a:	d101      	bne.n	2c930 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x34>
   2c92c:	689b      	ldr	r3, [r3, #8]
   2c92e:	b12b      	cbz	r3, 2c93c <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x40>
   2c930:	3001      	adds	r0, #1
   2c932:	4285      	cmp	r5, r0
   2c934:	d1eb      	bne.n	2c90e <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x12>
   2c936:	2000      	movs	r0, #0
   2c938:	bcf0      	pop	{r4, r5, r6, r7}
   2c93a:	4770      	bx	lr
   2c93c:	eb06 1080 	add.w	r0, r6, r0, lsl #6
   2c940:	4421      	add	r1, r4
   2c942:	6088      	str	r0, [r1, #8]
   2c944:	6843      	ldr	r3, [r0, #4]
   2c946:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   2c94a:	f043 0301 	orr.w	r3, r3, #1
   2c94e:	6043      	str	r3, [r0, #4]
   2c950:	bcf0      	pop	{r4, r5, r6, r7}
   2c952:	4770      	bx	lr
   2c954:	20020b94 	.word	0x20020b94
   2c958:	20020b90 	.word	0x20020b90

0002c95c <rpc_transport_ipc_tx_data_alloc>:
   2c95c:	4b03      	ldr	r3, [pc, #12]	; (2c96c <rpc_transport_ipc_tx_data_alloc+0x10>)
   2c95e:	781b      	ldrb	r3, [r3, #0]
   2c960:	b90b      	cbnz	r3, 2c966 <rpc_transport_ipc_tx_data_alloc+0xa>
   2c962:	f7fd be37 	b.w	2a5d4 <nrf_shared_malloc>
   2c966:	2000      	movs	r0, #0
   2c968:	4770      	bx	lr
   2c96a:	bf00      	nop
   2c96c:	20026147 	.word	0x20026147

0002c970 <ok_rsp_parser>:
   2c970:	2000      	movs	r0, #0
   2c972:	4770      	bx	lr

0002c974 <pdn_state_get_parser>:
   2c974:	2200      	movs	r2, #0
   2c976:	b570      	push	{r4, r5, r6, lr}
   2c978:	780b      	ldrb	r3, [r1, #0]
   2c97a:	b084      	sub	sp, #16
   2c97c:	460e      	mov	r6, r1
   2c97e:	e9cd 2200 	strd	r2, r2, [sp]
   2c982:	e9cd 2202 	strd	r2, r2, [sp, #8]
   2c986:	b323      	cbz	r3, 2c9d2 <pdn_state_get_parser+0x5e>
   2c988:	460c      	mov	r4, r1
   2c98a:	2b20      	cmp	r3, #32
   2c98c:	460d      	mov	r5, r1
   2c98e:	d01b      	beq.n	2c9c8 <pdn_state_get_parser+0x54>
   2c990:	700b      	strb	r3, [r1, #0]
   2c992:	3201      	adds	r2, #1
   2c994:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   2c998:	18b1      	adds	r1, r6, r2
   2c99a:	460d      	mov	r5, r1
   2c99c:	2b00      	cmp	r3, #0
   2c99e:	d1f4      	bne.n	2c98a <pdn_state_get_parser+0x16>
   2c9a0:	2200      	movs	r2, #0
   2c9a2:	4b0d      	ldr	r3, [pc, #52]	; (2c9d8 <pdn_state_get_parser+0x64>)
   2c9a4:	702a      	strb	r2, [r5, #0]
   2c9a6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   2c9aa:	4a0c      	ldr	r2, [pc, #48]	; (2c9dc <pdn_state_get_parser+0x68>)
   2c9ac:	681b      	ldr	r3, [r3, #0]
   2c9ae:	2110      	movs	r1, #16
   2c9b0:	4668      	mov	r0, sp
   2c9b2:	f009 fd27 	bl	36404 <sniprintf>
   2c9b6:	4669      	mov	r1, sp
   2c9b8:	4630      	mov	r0, r6
   2c9ba:	f00d fb83 	bl	3a0c4 <strstr>
   2c9be:	3000      	adds	r0, #0
   2c9c0:	bf18      	it	ne
   2c9c2:	2001      	movne	r0, #1
   2c9c4:	b004      	add	sp, #16
   2c9c6:	bd70      	pop	{r4, r5, r6, pc}
   2c9c8:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   2c9cc:	2b00      	cmp	r3, #0
   2c9ce:	d1dc      	bne.n	2c98a <pdn_state_get_parser+0x16>
   2c9d0:	e7e6      	b.n	2c9a0 <pdn_state_get_parser+0x2c>
   2c9d2:	460d      	mov	r5, r1
   2c9d4:	e7e4      	b.n	2c9a0 <pdn_state_get_parser+0x2c>
   2c9d6:	bf00      	nop
   2c9d8:	20020cbc 	.word	0x20020cbc
   2c9dc:	0003b77c 	.word	0x0003b77c

0002c9e0 <pdn_id_get_parser>:
   2c9e0:	b570      	push	{r4, r5, r6, lr}
   2c9e2:	780b      	ldrb	r3, [r1, #0]
   2c9e4:	4606      	mov	r6, r0
   2c9e6:	b313      	cbz	r3, 2ca2e <pdn_id_get_parser+0x4e>
   2c9e8:	4608      	mov	r0, r1
   2c9ea:	2400      	movs	r4, #0
   2c9ec:	460a      	mov	r2, r1
   2c9ee:	2b20      	cmp	r3, #32
   2c9f0:	4615      	mov	r5, r2
   2c9f2:	d017      	beq.n	2ca24 <pdn_id_get_parser+0x44>
   2c9f4:	7013      	strb	r3, [r2, #0]
   2c9f6:	3401      	adds	r4, #1
   2c9f8:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   2c9fc:	190a      	adds	r2, r1, r4
   2c9fe:	4615      	mov	r5, r2
   2ca00:	2b00      	cmp	r3, #0
   2ca02:	d1f4      	bne.n	2c9ee <pdn_id_get_parser+0xe>
   2ca04:	2300      	movs	r3, #0
   2ca06:	4608      	mov	r0, r1
   2ca08:	702b      	strb	r3, [r5, #0]
   2ca0a:	213a      	movs	r1, #58	; 0x3a
   2ca0c:	f00d fb33 	bl	3a076 <strchr>
   2ca10:	b130      	cbz	r0, 2ca20 <pdn_id_get_parser+0x40>
   2ca12:	3001      	adds	r0, #1
   2ca14:	f00d f993 	bl	39d3e <atoi>
   2ca18:	4b06      	ldr	r3, [pc, #24]	; (2ca34 <pdn_id_get_parser+0x54>)
   2ca1a:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
   2ca1e:	6058      	str	r0, [r3, #4]
   2ca20:	2000      	movs	r0, #0
   2ca22:	bd70      	pop	{r4, r5, r6, pc}
   2ca24:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   2ca28:	2b00      	cmp	r3, #0
   2ca2a:	d1e0      	bne.n	2c9ee <pdn_id_get_parser+0xe>
   2ca2c:	e7ea      	b.n	2ca04 <pdn_id_get_parser+0x24>
   2ca2e:	460d      	mov	r5, r1
   2ca30:	e7e8      	b.n	2ca04 <pdn_id_get_parser+0x24>
   2ca32:	bf00      	nop
   2ca34:	20020cbc 	.word	0x20020cbc

0002ca38 <context_create_parser>:
   2ca38:	b570      	push	{r4, r5, r6, lr}
   2ca3a:	780b      	ldrb	r3, [r1, #0]
   2ca3c:	4606      	mov	r6, r0
   2ca3e:	b313      	cbz	r3, 2ca86 <context_create_parser+0x4e>
   2ca40:	4608      	mov	r0, r1
   2ca42:	2400      	movs	r4, #0
   2ca44:	460a      	mov	r2, r1
   2ca46:	2b20      	cmp	r3, #32
   2ca48:	4615      	mov	r5, r2
   2ca4a:	d017      	beq.n	2ca7c <context_create_parser+0x44>
   2ca4c:	7013      	strb	r3, [r2, #0]
   2ca4e:	3401      	adds	r4, #1
   2ca50:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   2ca54:	190a      	adds	r2, r1, r4
   2ca56:	4615      	mov	r5, r2
   2ca58:	2b00      	cmp	r3, #0
   2ca5a:	d1f4      	bne.n	2ca46 <context_create_parser+0xe>
   2ca5c:	2300      	movs	r3, #0
   2ca5e:	4608      	mov	r0, r1
   2ca60:	702b      	strb	r3, [r5, #0]
   2ca62:	213a      	movs	r1, #58	; 0x3a
   2ca64:	f00d fb07 	bl	3a076 <strchr>
   2ca68:	b130      	cbz	r0, 2ca78 <context_create_parser+0x40>
   2ca6a:	4b08      	ldr	r3, [pc, #32]	; (2ca8c <context_create_parser+0x54>)
   2ca6c:	3001      	adds	r0, #1
   2ca6e:	f853 4026 	ldr.w	r4, [r3, r6, lsl #2]
   2ca72:	f00d f964 	bl	39d3e <atoi>
   2ca76:	6020      	str	r0, [r4, #0]
   2ca78:	2000      	movs	r0, #0
   2ca7a:	bd70      	pop	{r4, r5, r6, pc}
   2ca7c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   2ca80:	2b00      	cmp	r3, #0
   2ca82:	d1e0      	bne.n	2ca46 <context_create_parser+0xe>
   2ca84:	e7ea      	b.n	2ca5c <context_create_parser+0x24>
   2ca86:	460d      	mov	r5, r1
   2ca88:	e7e8      	b.n	2ca5c <context_create_parser+0x24>
   2ca8a:	bf00      	nop
   2ca8c:	20020cbc 	.word	0x20020cbc

0002ca90 <pdn_interface_init>:
   2ca90:	f04f 33ff 	mov.w	r3, #4294967295
   2ca94:	b510      	push	{r4, lr}
   2ca96:	4c09      	ldr	r4, [pc, #36]	; (2cabc <pdn_interface_init+0x2c>)
   2ca98:	2228      	movs	r2, #40	; 0x28
   2ca9a:	2100      	movs	r1, #0
   2ca9c:	4808      	ldr	r0, [pc, #32]	; (2cac0 <pdn_interface_init+0x30>)
   2ca9e:	6023      	str	r3, [r4, #0]
   2caa0:	f00d f98d 	bl	39dbe <memset>
   2caa4:	f240 2201 	movw	r2, #513	; 0x201
   2caa8:	2102      	movs	r1, #2
   2caaa:	2066      	movs	r0, #102	; 0x66
   2caac:	f7fd f83a 	bl	29b24 <at_interface_open>
   2cab0:	2800      	cmp	r0, #0
   2cab2:	6020      	str	r0, [r4, #0]
   2cab4:	bfb4      	ite	lt
   2cab6:	2003      	movlt	r0, #3
   2cab8:	2000      	movge	r0, #0
   2caba:	bd10      	pop	{r4, pc}
   2cabc:	20020bb8 	.word	0x20020bb8
   2cac0:	20020cbc 	.word	0x20020cbc

0002cac4 <pdn_interface_open>:
   2cac4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2cac8:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   2cacc:	b083      	sub	sp, #12
   2cace:	f040 80ad 	bne.w	2cc2c <pdn_interface_open+0x168>
   2cad2:	4c5f      	ldr	r4, [pc, #380]	; (2cc50 <pdn_interface_open+0x18c>)
   2cad4:	6825      	ldr	r5, [r4, #0]
   2cad6:	b34d      	cbz	r5, 2cb2c <pdn_interface_open+0x68>
   2cad8:	6863      	ldr	r3, [r4, #4]
   2cada:	2b00      	cmp	r3, #0
   2cadc:	f000 8098 	beq.w	2cc10 <pdn_interface_open+0x14c>
   2cae0:	68a3      	ldr	r3, [r4, #8]
   2cae2:	2b00      	cmp	r3, #0
   2cae4:	f000 8096 	beq.w	2cc14 <pdn_interface_open+0x150>
   2cae8:	68e3      	ldr	r3, [r4, #12]
   2caea:	2b00      	cmp	r3, #0
   2caec:	f000 8094 	beq.w	2cc18 <pdn_interface_open+0x154>
   2caf0:	6923      	ldr	r3, [r4, #16]
   2caf2:	2b00      	cmp	r3, #0
   2caf4:	f000 8092 	beq.w	2cc1c <pdn_interface_open+0x158>
   2caf8:	6963      	ldr	r3, [r4, #20]
   2cafa:	2b00      	cmp	r3, #0
   2cafc:	f000 8090 	beq.w	2cc20 <pdn_interface_open+0x15c>
   2cb00:	69a3      	ldr	r3, [r4, #24]
   2cb02:	2b00      	cmp	r3, #0
   2cb04:	f000 808e 	beq.w	2cc24 <pdn_interface_open+0x160>
   2cb08:	69e3      	ldr	r3, [r4, #28]
   2cb0a:	2b00      	cmp	r3, #0
   2cb0c:	f000 808c 	beq.w	2cc28 <pdn_interface_open+0x164>
   2cb10:	6a23      	ldr	r3, [r4, #32]
   2cb12:	b153      	cbz	r3, 2cb2a <pdn_interface_open+0x66>
   2cb14:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2cb16:	2509      	movs	r5, #9
   2cb18:	b143      	cbz	r3, 2cb2c <pdn_interface_open+0x68>
   2cb1a:	200c      	movs	r0, #12
   2cb1c:	f7fa ffa0 	bl	27a60 <bsd_os_errno_set>
   2cb20:	f04f 30ff 	mov.w	r0, #4294967295
   2cb24:	b003      	add	sp, #12
   2cb26:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2cb2a:	2508      	movs	r5, #8
   2cb2c:	2074      	movs	r0, #116	; 0x74
   2cb2e:	f7fd fd3b 	bl	2a5a8 <nrf_malloc>
   2cb32:	f844 0025 	str.w	r0, [r4, r5, lsl #2]
   2cb36:	2800      	cmp	r0, #0
   2cb38:	d0ef      	beq.n	2cb1a <pdn_interface_open+0x56>
   2cb3a:	2274      	movs	r2, #116	; 0x74
   2cb3c:	2100      	movs	r1, #0
   2cb3e:	f00d f93e 	bl	39dbe <memset>
   2cb42:	2101      	movs	r1, #1
   2cb44:	2003      	movs	r0, #3
   2cb46:	f04f 37ff 	mov.w	r7, #4294967295
   2cb4a:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   2cb4e:	4a41      	ldr	r2, [pc, #260]	; (2cc54 <pdn_interface_open+0x190>)
   2cb50:	6099      	str	r1, [r3, #8]
   2cb52:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   2cb56:	f44f 7180 	mov.w	r1, #256	; 0x100
   2cb5a:	6718      	str	r0, [r3, #112]	; 0x70
   2cb5c:	605f      	str	r7, [r3, #4]
   2cb5e:	483e      	ldr	r0, [pc, #248]	; (2cc58 <pdn_interface_open+0x194>)
   2cb60:	f8df 8100 	ldr.w	r8, [pc, #256]	; 2cc64 <pdn_interface_open+0x1a0>
   2cb64:	f009 fc4e 	bl	36404 <sniprintf>
   2cb68:	483b      	ldr	r0, [pc, #236]	; (2cc58 <pdn_interface_open+0x194>)
   2cb6a:	f8d8 9000 	ldr.w	r9, [r8]
   2cb6e:	2600      	movs	r6, #0
   2cb70:	f7f0 faf2 	bl	1d158 <strlen>
   2cb74:	4633      	mov	r3, r6
   2cb76:	4602      	mov	r2, r0
   2cb78:	4937      	ldr	r1, [pc, #220]	; (2cc58 <pdn_interface_open+0x194>)
   2cb7a:	4648      	mov	r0, r9
   2cb7c:	9601      	str	r6, [sp, #4]
   2cb7e:	9600      	str	r6, [sp, #0]
   2cb80:	f7fc ff62 	bl	29a48 <at_interface_write>
   2cb84:	4681      	mov	r9, r0
   2cb86:	4834      	ldr	r0, [pc, #208]	; (2cc58 <pdn_interface_open+0x194>)
   2cb88:	f7f0 fae6 	bl	1d158 <strlen>
   2cb8c:	4548      	cmp	r0, r9
   2cb8e:	d153      	bne.n	2cc38 <pdn_interface_open+0x174>
   2cb90:	4633      	mov	r3, r6
   2cb92:	e9cd 6600 	strd	r6, r6, [sp]
   2cb96:	f44f 7280 	mov.w	r2, #256	; 0x100
   2cb9a:	492f      	ldr	r1, [pc, #188]	; (2cc58 <pdn_interface_open+0x194>)
   2cb9c:	f8d8 0000 	ldr.w	r0, [r8]
   2cba0:	f7fd f856 	bl	29c50 <at_interface_read>
   2cba4:	4606      	mov	r6, r0
   2cba6:	482d      	ldr	r0, [pc, #180]	; (2cc5c <pdn_interface_open+0x198>)
   2cba8:	f7f0 fad6 	bl	1d158 <strlen>
   2cbac:	4286      	cmp	r6, r0
   2cbae:	db15      	blt.n	2cbdc <pdn_interface_open+0x118>
   2cbb0:	4602      	mov	r2, r0
   2cbb2:	4929      	ldr	r1, [pc, #164]	; (2cc58 <pdn_interface_open+0x194>)
   2cbb4:	4829      	ldr	r0, [pc, #164]	; (2cc5c <pdn_interface_open+0x198>)
   2cbb6:	f00d fa73 	bl	3a0a0 <strncmp>
   2cbba:	b978      	cbnz	r0, 2cbdc <pdn_interface_open+0x118>
   2cbbc:	4926      	ldr	r1, [pc, #152]	; (2cc58 <pdn_interface_open+0x194>)
   2cbbe:	4628      	mov	r0, r5
   2cbc0:	f7ff ff3a 	bl	2ca38 <context_create_parser>
   2cbc4:	b9b0      	cbnz	r0, 2cbf4 <pdn_interface_open+0x130>
   2cbc6:	2202      	movs	r2, #2
   2cbc8:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   2cbcc:	f045 40f1 	orr.w	r0, r5, #2021654528	; 0x78800000
   2cbd0:	f440 10d0 	orr.w	r0, r0, #1703936	; 0x1a0000
   2cbd4:	609a      	str	r2, [r3, #8]
   2cbd6:	b003      	add	sp, #12
   2cbd8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2cbdc:	4820      	ldr	r0, [pc, #128]	; (2cc60 <pdn_interface_open+0x19c>)
   2cbde:	f7f0 fabb 	bl	1d158 <strlen>
   2cbe2:	491d      	ldr	r1, [pc, #116]	; (2cc58 <pdn_interface_open+0x194>)
   2cbe4:	4602      	mov	r2, r0
   2cbe6:	481e      	ldr	r0, [pc, #120]	; (2cc60 <pdn_interface_open+0x19c>)
   2cbe8:	f00d fa5a 	bl	3a0a0 <strncmp>
   2cbec:	b960      	cbnz	r0, 2cc08 <pdn_interface_open+0x144>
   2cbee:	2008      	movs	r0, #8
   2cbf0:	f7fa ff36 	bl	27a60 <bsd_os_errno_set>
   2cbf4:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
   2cbf8:	f7fd fce0 	bl	2a5bc <nrf_free>
   2cbfc:	2300      	movs	r3, #0
   2cbfe:	f04f 30ff 	mov.w	r0, #4294967295
   2cc02:	f844 3025 	str.w	r3, [r4, r5, lsl #2]
   2cc06:	e78d      	b.n	2cb24 <pdn_interface_open+0x60>
   2cc08:	2005      	movs	r0, #5
   2cc0a:	f7fa ff29 	bl	27a60 <bsd_os_errno_set>
   2cc0e:	e7f1      	b.n	2cbf4 <pdn_interface_open+0x130>
   2cc10:	2501      	movs	r5, #1
   2cc12:	e78b      	b.n	2cb2c <pdn_interface_open+0x68>
   2cc14:	2502      	movs	r5, #2
   2cc16:	e789      	b.n	2cb2c <pdn_interface_open+0x68>
   2cc18:	2503      	movs	r5, #3
   2cc1a:	e787      	b.n	2cb2c <pdn_interface_open+0x68>
   2cc1c:	2504      	movs	r5, #4
   2cc1e:	e785      	b.n	2cb2c <pdn_interface_open+0x68>
   2cc20:	2505      	movs	r5, #5
   2cc22:	e783      	b.n	2cb2c <pdn_interface_open+0x68>
   2cc24:	2506      	movs	r5, #6
   2cc26:	e781      	b.n	2cb2c <pdn_interface_open+0x68>
   2cc28:	2507      	movs	r5, #7
   2cc2a:	e77f      	b.n	2cb2c <pdn_interface_open+0x68>
   2cc2c:	2029      	movs	r0, #41	; 0x29
   2cc2e:	f7fa ff17 	bl	27a60 <bsd_os_errno_set>
   2cc32:	f04f 30ff 	mov.w	r0, #4294967295
   2cc36:	e775      	b.n	2cb24 <pdn_interface_open+0x60>
   2cc38:	2005      	movs	r0, #5
   2cc3a:	f7fa ff11 	bl	27a60 <bsd_os_errno_set>
   2cc3e:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
   2cc42:	f7fd fcbb 	bl	2a5bc <nrf_free>
   2cc46:	f844 6025 	str.w	r6, [r4, r5, lsl #2]
   2cc4a:	4638      	mov	r0, r7
   2cc4c:	e76a      	b.n	2cb24 <pdn_interface_open+0x60>
   2cc4e:	bf00      	nop
   2cc50:	20020cbc 	.word	0x20020cbc
   2cc54:	0003b758 	.word	0x0003b758
   2cc58:	20020bbc 	.word	0x20020bbc
   2cc5c:	0003b768 	.word	0x0003b768
   2cc60:	0003b774 	.word	0x0003b774
   2cc64:	20020bb8 	.word	0x20020bb8

0002cc68 <pdn_interface_connect>:
   2cc68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2cc6c:	b083      	sub	sp, #12
   2cc6e:	2900      	cmp	r1, #0
   2cc70:	f000 813d 	beq.w	2ceee <pdn_interface_connect+0x286>
   2cc74:	2a64      	cmp	r2, #100	; 0x64
   2cc76:	4691      	mov	r9, r2
   2cc78:	f200 8139 	bhi.w	2ceee <pdn_interface_connect+0x286>
   2cc7c:	4605      	mov	r5, r0
   2cc7e:	4608      	mov	r0, r1
   2cc80:	4688      	mov	r8, r1
   2cc82:	f7f0 fa69 	bl	1d158 <strlen>
   2cc86:	2864      	cmp	r0, #100	; 0x64
   2cc88:	f200 8131 	bhi.w	2ceee <pdn_interface_connect+0x286>
   2cc8c:	0c2b      	lsrs	r3, r5, #16
   2cc8e:	4aa5      	ldr	r2, [pc, #660]	; (2cf24 <pdn_interface_connect+0x2bc>)
   2cc90:	041b      	lsls	r3, r3, #16
   2cc92:	4293      	cmp	r3, r2
   2cc94:	f040 8122 	bne.w	2cedc <pdn_interface_connect+0x274>
   2cc98:	f025 45f1 	bic.w	r5, r5, #2021654528	; 0x78800000
   2cc9c:	f425 15d0 	bic.w	r5, r5, #1703936	; 0x1a0000
   2cca0:	2d09      	cmp	r5, #9
   2cca2:	f300 811b 	bgt.w	2cedc <pdn_interface_connect+0x274>
   2cca6:	4fa0      	ldr	r7, [pc, #640]	; (2cf28 <pdn_interface_connect+0x2c0>)
   2cca8:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   2ccac:	2b00      	cmp	r3, #0
   2ccae:	f000 8115 	beq.w	2cedc <pdn_interface_connect+0x274>
   2ccb2:	689a      	ldr	r2, [r3, #8]
   2ccb4:	2a00      	cmp	r2, #0
   2ccb6:	f000 8111 	beq.w	2cedc <pdn_interface_connect+0x274>
   2ccba:	689b      	ldr	r3, [r3, #8]
   2ccbc:	2b02      	cmp	r3, #2
   2ccbe:	f040 810d 	bne.w	2cedc <pdn_interface_connect+0x274>
   2ccc2:	4e9a      	ldr	r6, [pc, #616]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2ccc4:	4a9a      	ldr	r2, [pc, #616]	; (2cf30 <pdn_interface_connect+0x2c8>)
   2ccc6:	f44f 7180 	mov.w	r1, #256	; 0x100
   2ccca:	4630      	mov	r0, r6
   2cccc:	f009 fb9a 	bl	36404 <sniprintf>
   2ccd0:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   2ccd4:	4604      	mov	r4, r0
   2ccd6:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   2ccda:	681b      	ldr	r3, [r3, #0]
   2ccdc:	4a95      	ldr	r2, [pc, #596]	; (2cf34 <pdn_interface_connect+0x2cc>)
   2ccde:	1830      	adds	r0, r6, r0
   2cce0:	f009 fb90 	bl	36404 <sniprintf>
   2cce4:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   2cce8:	4404      	add	r4, r0
   2ccea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   2ccec:	f003 0203 	and.w	r2, r3, #3
   2ccf0:	2a03      	cmp	r2, #3
   2ccf2:	f000 80ea 	beq.w	2ceca <pdn_interface_connect+0x262>
   2ccf6:	079b      	lsls	r3, r3, #30
   2ccf8:	eb06 0004 	add.w	r0, r6, r4
   2ccfc:	f5c4 7180 	rsb	r1, r4, #256	; 0x100
   2cd00:	bf4c      	ite	mi
   2cd02:	4b8d      	ldrmi	r3, [pc, #564]	; (2cf38 <pdn_interface_connect+0x2d0>)
   2cd04:	4b8d      	ldrpl	r3, [pc, #564]	; (2cf3c <pdn_interface_connect+0x2d4>)
   2cd06:	4a8e      	ldr	r2, [pc, #568]	; (2cf40 <pdn_interface_connect+0x2d8>)
   2cd08:	f009 fb7c 	bl	36404 <sniprintf>
   2cd0c:	4404      	add	r4, r0
   2cd0e:	4643      	mov	r3, r8
   2cd10:	4a8c      	ldr	r2, [pc, #560]	; (2cf44 <pdn_interface_connect+0x2dc>)
   2cd12:	f5c4 7180 	rsb	r1, r4, #256	; 0x100
   2cd16:	1930      	adds	r0, r6, r4
   2cd18:	f009 fb74 	bl	36404 <sniprintf>
   2cd1c:	4420      	add	r0, r4
   2cd1e:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
   2cd22:	f300 80f7 	bgt.w	2cf14 <pdn_interface_connect+0x2ac>
   2cd26:	f8df a23c 	ldr.w	sl, [pc, #572]	; 2cf64 <pdn_interface_connect+0x2fc>
   2cd2a:	4880      	ldr	r0, [pc, #512]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2cd2c:	f8da b000 	ldr.w	fp, [sl]
   2cd30:	2400      	movs	r4, #0
   2cd32:	f7f0 fa11 	bl	1d158 <strlen>
   2cd36:	4623      	mov	r3, r4
   2cd38:	4602      	mov	r2, r0
   2cd3a:	497c      	ldr	r1, [pc, #496]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2cd3c:	4658      	mov	r0, fp
   2cd3e:	9401      	str	r4, [sp, #4]
   2cd40:	9400      	str	r4, [sp, #0]
   2cd42:	f7fc fe81 	bl	29a48 <at_interface_write>
   2cd46:	4683      	mov	fp, r0
   2cd48:	4878      	ldr	r0, [pc, #480]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2cd4a:	f7f0 fa05 	bl	1d158 <strlen>
   2cd4e:	4558      	cmp	r0, fp
   2cd50:	d008      	beq.n	2cd64 <pdn_interface_connect+0xfc>
   2cd52:	2005      	movs	r0, #5
   2cd54:	f7fa fe84 	bl	27a60 <bsd_os_errno_set>
   2cd58:	f04f 34ff 	mov.w	r4, #4294967295
   2cd5c:	4620      	mov	r0, r4
   2cd5e:	b003      	add	sp, #12
   2cd60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2cd64:	4623      	mov	r3, r4
   2cd66:	e9cd 4400 	strd	r4, r4, [sp]
   2cd6a:	f44f 7280 	mov.w	r2, #256	; 0x100
   2cd6e:	496f      	ldr	r1, [pc, #444]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2cd70:	f8da 0000 	ldr.w	r0, [sl]
   2cd74:	f7fc ff6c 	bl	29c50 <at_interface_read>
   2cd78:	4604      	mov	r4, r0
   2cd7a:	4873      	ldr	r0, [pc, #460]	; (2cf48 <pdn_interface_connect+0x2e0>)
   2cd7c:	f7f0 f9ec 	bl	1d158 <strlen>
   2cd80:	4284      	cmp	r4, r0
   2cd82:	f2c0 8091 	blt.w	2cea8 <pdn_interface_connect+0x240>
   2cd86:	4602      	mov	r2, r0
   2cd88:	4968      	ldr	r1, [pc, #416]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2cd8a:	486f      	ldr	r0, [pc, #444]	; (2cf48 <pdn_interface_connect+0x2e0>)
   2cd8c:	f00d f988 	bl	3a0a0 <strncmp>
   2cd90:	2800      	cmp	r0, #0
   2cd92:	f040 8089 	bne.w	2cea8 <pdn_interface_connect+0x240>
   2cd96:	4965      	ldr	r1, [pc, #404]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2cd98:	4628      	mov	r0, r5
   2cd9a:	f7ff fde9 	bl	2c970 <ok_rsp_parser>
   2cd9e:	4604      	mov	r4, r0
   2cda0:	2800      	cmp	r0, #0
   2cda2:	d1db      	bne.n	2cd5c <pdn_interface_connect+0xf4>
   2cda4:	4a69      	ldr	r2, [pc, #420]	; (2cf4c <pdn_interface_connect+0x2e4>)
   2cda6:	f44f 7180 	mov.w	r1, #256	; 0x100
   2cdaa:	4860      	ldr	r0, [pc, #384]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2cdac:	f009 fb2a 	bl	36404 <sniprintf>
   2cdb0:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   2cdb4:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   2cdb8:	681b      	ldr	r3, [r3, #0]
   2cdba:	4a65      	ldr	r2, [pc, #404]	; (2cf50 <pdn_interface_connect+0x2e8>)
   2cdbc:	4430      	add	r0, r6
   2cdbe:	f009 fb21 	bl	36404 <sniprintf>
   2cdc2:	485a      	ldr	r0, [pc, #360]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2cdc4:	f8da b000 	ldr.w	fp, [sl]
   2cdc8:	f7f0 f9c6 	bl	1d158 <strlen>
   2cdcc:	4623      	mov	r3, r4
   2cdce:	4602      	mov	r2, r0
   2cdd0:	4956      	ldr	r1, [pc, #344]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2cdd2:	4658      	mov	r0, fp
   2cdd4:	9401      	str	r4, [sp, #4]
   2cdd6:	9400      	str	r4, [sp, #0]
   2cdd8:	f7fc fe36 	bl	29a48 <at_interface_write>
   2cddc:	4683      	mov	fp, r0
   2cdde:	4853      	ldr	r0, [pc, #332]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2cde0:	f7f0 f9ba 	bl	1d158 <strlen>
   2cde4:	4558      	cmp	r0, fp
   2cde6:	d1b4      	bne.n	2cd52 <pdn_interface_connect+0xea>
   2cde8:	4623      	mov	r3, r4
   2cdea:	f44f 7280 	mov.w	r2, #256	; 0x100
   2cdee:	494f      	ldr	r1, [pc, #316]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2cdf0:	f8da 0000 	ldr.w	r0, [sl]
   2cdf4:	e9cd 4400 	strd	r4, r4, [sp]
   2cdf8:	f7fc ff2a 	bl	29c50 <at_interface_read>
   2cdfc:	4683      	mov	fp, r0
   2cdfe:	4852      	ldr	r0, [pc, #328]	; (2cf48 <pdn_interface_connect+0x2e0>)
   2ce00:	f7f0 f9aa 	bl	1d158 <strlen>
   2ce04:	4583      	cmp	fp, r0
   2ce06:	db4f      	blt.n	2cea8 <pdn_interface_connect+0x240>
   2ce08:	4602      	mov	r2, r0
   2ce0a:	4948      	ldr	r1, [pc, #288]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2ce0c:	484e      	ldr	r0, [pc, #312]	; (2cf48 <pdn_interface_connect+0x2e0>)
   2ce0e:	f00d f947 	bl	3a0a0 <strncmp>
   2ce12:	2800      	cmp	r0, #0
   2ce14:	d148      	bne.n	2cea8 <pdn_interface_connect+0x240>
   2ce16:	2103      	movs	r1, #3
   2ce18:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   2ce1c:	464a      	mov	r2, r9
   2ce1e:	6099      	str	r1, [r3, #8]
   2ce20:	f857 0025 	ldr.w	r0, [r7, r5, lsl #2]
   2ce24:	4641      	mov	r1, r8
   2ce26:	300c      	adds	r0, #12
   2ce28:	f00c ffa9 	bl	39d7e <memcpy>
   2ce2c:	4a49      	ldr	r2, [pc, #292]	; (2cf54 <pdn_interface_connect+0x2ec>)
   2ce2e:	f44f 7180 	mov.w	r1, #256	; 0x100
   2ce32:	483e      	ldr	r0, [pc, #248]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2ce34:	f009 fae6 	bl	36404 <sniprintf>
   2ce38:	4601      	mov	r1, r0
   2ce3a:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   2ce3e:	f5c1 7180 	rsb	r1, r1, #256	; 0x100
   2ce42:	681b      	ldr	r3, [r3, #0]
   2ce44:	4a42      	ldr	r2, [pc, #264]	; (2cf50 <pdn_interface_connect+0x2e8>)
   2ce46:	1830      	adds	r0, r6, r0
   2ce48:	f009 fadc 	bl	36404 <sniprintf>
   2ce4c:	4837      	ldr	r0, [pc, #220]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2ce4e:	f8da 6000 	ldr.w	r6, [sl]
   2ce52:	f7f0 f981 	bl	1d158 <strlen>
   2ce56:	4623      	mov	r3, r4
   2ce58:	4602      	mov	r2, r0
   2ce5a:	4934      	ldr	r1, [pc, #208]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2ce5c:	4630      	mov	r0, r6
   2ce5e:	9401      	str	r4, [sp, #4]
   2ce60:	9400      	str	r4, [sp, #0]
   2ce62:	f7fc fdf1 	bl	29a48 <at_interface_write>
   2ce66:	4606      	mov	r6, r0
   2ce68:	4830      	ldr	r0, [pc, #192]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2ce6a:	f7f0 f975 	bl	1d158 <strlen>
   2ce6e:	42b0      	cmp	r0, r6
   2ce70:	d153      	bne.n	2cf1a <pdn_interface_connect+0x2b2>
   2ce72:	4623      	mov	r3, r4
   2ce74:	f44f 7280 	mov.w	r2, #256	; 0x100
   2ce78:	492c      	ldr	r1, [pc, #176]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2ce7a:	f8da 0000 	ldr.w	r0, [sl]
   2ce7e:	e9cd 4400 	strd	r4, r4, [sp]
   2ce82:	f7fc fee5 	bl	29c50 <at_interface_read>
   2ce86:	4606      	mov	r6, r0
   2ce88:	4833      	ldr	r0, [pc, #204]	; (2cf58 <pdn_interface_connect+0x2f0>)
   2ce8a:	f7f0 f965 	bl	1d158 <strlen>
   2ce8e:	4286      	cmp	r6, r0
   2ce90:	db33      	blt.n	2cefa <pdn_interface_connect+0x292>
   2ce92:	4602      	mov	r2, r0
   2ce94:	4925      	ldr	r1, [pc, #148]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2ce96:	4830      	ldr	r0, [pc, #192]	; (2cf58 <pdn_interface_connect+0x2f0>)
   2ce98:	f00d f902 	bl	3a0a0 <strncmp>
   2ce9c:	bb68      	cbnz	r0, 2cefa <pdn_interface_connect+0x292>
   2ce9e:	4628      	mov	r0, r5
   2cea0:	4922      	ldr	r1, [pc, #136]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2cea2:	f7ff fd9d 	bl	2c9e0 <pdn_id_get_parser>
   2cea6:	e759      	b.n	2cd5c <pdn_interface_connect+0xf4>
   2cea8:	482c      	ldr	r0, [pc, #176]	; (2cf5c <pdn_interface_connect+0x2f4>)
   2ceaa:	f7f0 f955 	bl	1d158 <strlen>
   2ceae:	491f      	ldr	r1, [pc, #124]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2ceb0:	4602      	mov	r2, r0
   2ceb2:	482a      	ldr	r0, [pc, #168]	; (2cf5c <pdn_interface_connect+0x2f4>)
   2ceb4:	f00d f8f4 	bl	3a0a0 <strncmp>
   2ceb8:	2800      	cmp	r0, #0
   2ceba:	f47f af4a 	bne.w	2cd52 <pdn_interface_connect+0xea>
   2cebe:	2008      	movs	r0, #8
   2cec0:	f7fa fdce 	bl	27a60 <bsd_os_errno_set>
   2cec4:	f04f 34ff 	mov.w	r4, #4294967295
   2cec8:	e748      	b.n	2cd5c <pdn_interface_connect+0xf4>
   2ceca:	f5c4 7180 	rsb	r1, r4, #256	; 0x100
   2cece:	1930      	adds	r0, r6, r4
   2ced0:	4b23      	ldr	r3, [pc, #140]	; (2cf60 <pdn_interface_connect+0x2f8>)
   2ced2:	4a1b      	ldr	r2, [pc, #108]	; (2cf40 <pdn_interface_connect+0x2d8>)
   2ced4:	f009 fa96 	bl	36404 <sniprintf>
   2ced8:	4404      	add	r4, r0
   2ceda:	e718      	b.n	2cd0e <pdn_interface_connect+0xa6>
   2cedc:	f04f 34ff 	mov.w	r4, #4294967295
   2cee0:	2009      	movs	r0, #9
   2cee2:	f7fa fdbd 	bl	27a60 <bsd_os_errno_set>
   2cee6:	4620      	mov	r0, r4
   2cee8:	b003      	add	sp, #12
   2ceea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2ceee:	2016      	movs	r0, #22
   2cef0:	f7fa fdb6 	bl	27a60 <bsd_os_errno_set>
   2cef4:	f04f 34ff 	mov.w	r4, #4294967295
   2cef8:	e730      	b.n	2cd5c <pdn_interface_connect+0xf4>
   2cefa:	4818      	ldr	r0, [pc, #96]	; (2cf5c <pdn_interface_connect+0x2f4>)
   2cefc:	f7f0 f92c 	bl	1d158 <strlen>
   2cf00:	490a      	ldr	r1, [pc, #40]	; (2cf2c <pdn_interface_connect+0x2c4>)
   2cf02:	4602      	mov	r2, r0
   2cf04:	4815      	ldr	r0, [pc, #84]	; (2cf5c <pdn_interface_connect+0x2f4>)
   2cf06:	f00d f8cb 	bl	3a0a0 <strncmp>
   2cf0a:	b930      	cbnz	r0, 2cf1a <pdn_interface_connect+0x2b2>
   2cf0c:	2008      	movs	r0, #8
   2cf0e:	f7fa fda7 	bl	27a60 <bsd_os_errno_set>
   2cf12:	e723      	b.n	2cd5c <pdn_interface_connect+0xf4>
   2cf14:	f04f 34ff 	mov.w	r4, #4294967295
   2cf18:	e720      	b.n	2cd5c <pdn_interface_connect+0xf4>
   2cf1a:	2005      	movs	r0, #5
   2cf1c:	f7fa fda0 	bl	27a60 <bsd_os_errno_set>
   2cf20:	e71c      	b.n	2cd5c <pdn_interface_connect+0xf4>
   2cf22:	bf00      	nop
   2cf24:	789a0000 	.word	0x789a0000
   2cf28:	20020cbc 	.word	0x20020cbc
   2cf2c:	20020bbc 	.word	0x20020bbc
   2cf30:	0003b6e0 	.word	0x0003b6e0
   2cf34:	0003b6ec 	.word	0x0003b6ec
   2cf38:	0003b700 	.word	0x0003b700
   2cf3c:	0003b708 	.word	0x0003b708
   2cf40:	0003b6f8 	.word	0x0003b6f8
   2cf44:	0003b73c 	.word	0x0003b73c
   2cf48:	0003b70c 	.word	0x0003b70c
   2cf4c:	0003b710 	.word	0x0003b710
   2cf50:	0003b71c 	.word	0x0003b71c
   2cf54:	0003b720 	.word	0x0003b720
   2cf58:	0003b730 	.word	0x0003b730
   2cf5c:	0003b774 	.word	0x0003b774
   2cf60:	0003b6f0 	.word	0x0003b6f0
   2cf64:	20020bb8 	.word	0x20020bb8

0002cf68 <pdn_interface_close>:
   2cf68:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2cf6c:	4a64      	ldr	r2, [pc, #400]	; (2d100 <pdn_interface_close+0x198>)
   2cf6e:	0c03      	lsrs	r3, r0, #16
   2cf70:	041b      	lsls	r3, r3, #16
   2cf72:	4293      	cmp	r3, r2
   2cf74:	b083      	sub	sp, #12
   2cf76:	f040 809d 	bne.w	2d0b4 <pdn_interface_close+0x14c>
   2cf7a:	f020 44f1 	bic.w	r4, r0, #2021654528	; 0x78800000
   2cf7e:	f424 14d0 	bic.w	r4, r4, #1703936	; 0x1a0000
   2cf82:	2c09      	cmp	r4, #9
   2cf84:	f300 8096 	bgt.w	2d0b4 <pdn_interface_close+0x14c>
   2cf88:	4d5e      	ldr	r5, [pc, #376]	; (2d104 <pdn_interface_close+0x19c>)
   2cf8a:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   2cf8e:	2800      	cmp	r0, #0
   2cf90:	f000 8090 	beq.w	2d0b4 <pdn_interface_close+0x14c>
   2cf94:	6883      	ldr	r3, [r0, #8]
   2cf96:	2b00      	cmp	r3, #0
   2cf98:	f000 808c 	beq.w	2d0b4 <pdn_interface_close+0x14c>
   2cf9c:	6883      	ldr	r3, [r0, #8]
   2cf9e:	2b03      	cmp	r3, #3
   2cfa0:	d008      	beq.n	2cfb4 <pdn_interface_close+0x4c>
   2cfa2:	f7fd fb0b 	bl	2a5bc <nrf_free>
   2cfa6:	2300      	movs	r3, #0
   2cfa8:	4618      	mov	r0, r3
   2cfaa:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
   2cfae:	b003      	add	sp, #12
   2cfb0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2cfb4:	4e54      	ldr	r6, [pc, #336]	; (2d108 <pdn_interface_close+0x1a0>)
   2cfb6:	4a55      	ldr	r2, [pc, #340]	; (2d10c <pdn_interface_close+0x1a4>)
   2cfb8:	f44f 7180 	mov.w	r1, #256	; 0x100
   2cfbc:	4630      	mov	r0, r6
   2cfbe:	f009 fa21 	bl	36404 <sniprintf>
   2cfc2:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   2cfc6:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   2cfca:	681b      	ldr	r3, [r3, #0]
   2cfcc:	4a50      	ldr	r2, [pc, #320]	; (2d110 <pdn_interface_close+0x1a8>)
   2cfce:	4430      	add	r0, r6
   2cfd0:	f8df 814c 	ldr.w	r8, [pc, #332]	; 2d120 <pdn_interface_close+0x1b8>
   2cfd4:	f009 fa16 	bl	36404 <sniprintf>
   2cfd8:	4630      	mov	r0, r6
   2cfda:	f8d8 9000 	ldr.w	r9, [r8]
   2cfde:	2700      	movs	r7, #0
   2cfe0:	f7f0 f8ba 	bl	1d158 <strlen>
   2cfe4:	4631      	mov	r1, r6
   2cfe6:	4602      	mov	r2, r0
   2cfe8:	463b      	mov	r3, r7
   2cfea:	4648      	mov	r0, r9
   2cfec:	9701      	str	r7, [sp, #4]
   2cfee:	9700      	str	r7, [sp, #0]
   2cff0:	f7fc fd2a 	bl	29a48 <at_interface_write>
   2cff4:	4681      	mov	r9, r0
   2cff6:	4630      	mov	r0, r6
   2cff8:	f7f0 f8ae 	bl	1d158 <strlen>
   2cffc:	4548      	cmp	r0, r9
   2cffe:	d176      	bne.n	2d0ee <pdn_interface_close+0x186>
   2d000:	463b      	mov	r3, r7
   2d002:	e9cd 7700 	strd	r7, r7, [sp]
   2d006:	f44f 7280 	mov.w	r2, #256	; 0x100
   2d00a:	4631      	mov	r1, r6
   2d00c:	f8d8 0000 	ldr.w	r0, [r8]
   2d010:	f7fc fe1e 	bl	29c50 <at_interface_read>
   2d014:	4607      	mov	r7, r0
   2d016:	483f      	ldr	r0, [pc, #252]	; (2d114 <pdn_interface_close+0x1ac>)
   2d018:	f7f0 f89e 	bl	1d158 <strlen>
   2d01c:	4287      	cmp	r7, r0
   2d01e:	da4f      	bge.n	2d0c0 <pdn_interface_close+0x158>
   2d020:	483d      	ldr	r0, [pc, #244]	; (2d118 <pdn_interface_close+0x1b0>)
   2d022:	f7f0 f899 	bl	1d158 <strlen>
   2d026:	4938      	ldr	r1, [pc, #224]	; (2d108 <pdn_interface_close+0x1a0>)
   2d028:	4602      	mov	r2, r0
   2d02a:	483b      	ldr	r0, [pc, #236]	; (2d118 <pdn_interface_close+0x1b0>)
   2d02c:	f00d f838 	bl	3a0a0 <strncmp>
   2d030:	2800      	cmp	r0, #0
   2d032:	d15c      	bne.n	2d0ee <pdn_interface_close+0x186>
   2d034:	2008      	movs	r0, #8
   2d036:	f7fa fd13 	bl	27a60 <bsd_os_errno_set>
   2d03a:	4a38      	ldr	r2, [pc, #224]	; (2d11c <pdn_interface_close+0x1b4>)
   2d03c:	f44f 7180 	mov.w	r1, #256	; 0x100
   2d040:	4831      	ldr	r0, [pc, #196]	; (2d108 <pdn_interface_close+0x1a0>)
   2d042:	f009 f9df 	bl	36404 <sniprintf>
   2d046:	4601      	mov	r1, r0
   2d048:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   2d04c:	f5c1 7180 	rsb	r1, r1, #256	; 0x100
   2d050:	681b      	ldr	r3, [r3, #0]
   2d052:	4a2f      	ldr	r2, [pc, #188]	; (2d110 <pdn_interface_close+0x1a8>)
   2d054:	1830      	adds	r0, r6, r0
   2d056:	f009 f9d5 	bl	36404 <sniprintf>
   2d05a:	482b      	ldr	r0, [pc, #172]	; (2d108 <pdn_interface_close+0x1a0>)
   2d05c:	f8d8 7000 	ldr.w	r7, [r8]
   2d060:	2600      	movs	r6, #0
   2d062:	f7f0 f879 	bl	1d158 <strlen>
   2d066:	4633      	mov	r3, r6
   2d068:	4602      	mov	r2, r0
   2d06a:	4927      	ldr	r1, [pc, #156]	; (2d108 <pdn_interface_close+0x1a0>)
   2d06c:	4638      	mov	r0, r7
   2d06e:	9601      	str	r6, [sp, #4]
   2d070:	9600      	str	r6, [sp, #0]
   2d072:	f7fc fce9 	bl	29a48 <at_interface_write>
   2d076:	4607      	mov	r7, r0
   2d078:	4823      	ldr	r0, [pc, #140]	; (2d108 <pdn_interface_close+0x1a0>)
   2d07a:	f7f0 f86d 	bl	1d158 <strlen>
   2d07e:	42b8      	cmp	r0, r7
   2d080:	d139      	bne.n	2d0f6 <pdn_interface_close+0x18e>
   2d082:	4633      	mov	r3, r6
   2d084:	e9cd 6600 	strd	r6, r6, [sp]
   2d088:	f44f 7280 	mov.w	r2, #256	; 0x100
   2d08c:	491e      	ldr	r1, [pc, #120]	; (2d108 <pdn_interface_close+0x1a0>)
   2d08e:	f8d8 0000 	ldr.w	r0, [r8]
   2d092:	f7fc fddd 	bl	29c50 <at_interface_read>
   2d096:	4606      	mov	r6, r0
   2d098:	481e      	ldr	r0, [pc, #120]	; (2d114 <pdn_interface_close+0x1ac>)
   2d09a:	f7f0 f85d 	bl	1d158 <strlen>
   2d09e:	4286      	cmp	r6, r0
   2d0a0:	db16      	blt.n	2d0d0 <pdn_interface_close+0x168>
   2d0a2:	4602      	mov	r2, r0
   2d0a4:	4918      	ldr	r1, [pc, #96]	; (2d108 <pdn_interface_close+0x1a0>)
   2d0a6:	481b      	ldr	r0, [pc, #108]	; (2d114 <pdn_interface_close+0x1ac>)
   2d0a8:	f00c fffa 	bl	3a0a0 <strncmp>
   2d0ac:	b980      	cbnz	r0, 2d0d0 <pdn_interface_close+0x168>
   2d0ae:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   2d0b2:	e776      	b.n	2cfa2 <pdn_interface_close+0x3a>
   2d0b4:	2009      	movs	r0, #9
   2d0b6:	f7fa fcd3 	bl	27a60 <bsd_os_errno_set>
   2d0ba:	f04f 30ff 	mov.w	r0, #4294967295
   2d0be:	e776      	b.n	2cfae <pdn_interface_close+0x46>
   2d0c0:	4602      	mov	r2, r0
   2d0c2:	4631      	mov	r1, r6
   2d0c4:	4813      	ldr	r0, [pc, #76]	; (2d114 <pdn_interface_close+0x1ac>)
   2d0c6:	f00c ffeb 	bl	3a0a0 <strncmp>
   2d0ca:	2800      	cmp	r0, #0
   2d0cc:	d0b5      	beq.n	2d03a <pdn_interface_close+0xd2>
   2d0ce:	e7a7      	b.n	2d020 <pdn_interface_close+0xb8>
   2d0d0:	4811      	ldr	r0, [pc, #68]	; (2d118 <pdn_interface_close+0x1b0>)
   2d0d2:	f7f0 f841 	bl	1d158 <strlen>
   2d0d6:	490c      	ldr	r1, [pc, #48]	; (2d108 <pdn_interface_close+0x1a0>)
   2d0d8:	4602      	mov	r2, r0
   2d0da:	480f      	ldr	r0, [pc, #60]	; (2d118 <pdn_interface_close+0x1b0>)
   2d0dc:	f00c ffe0 	bl	3a0a0 <strncmp>
   2d0e0:	b948      	cbnz	r0, 2d0f6 <pdn_interface_close+0x18e>
   2d0e2:	2008      	movs	r0, #8
   2d0e4:	f7fa fcbc 	bl	27a60 <bsd_os_errno_set>
   2d0e8:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   2d0ec:	e759      	b.n	2cfa2 <pdn_interface_close+0x3a>
   2d0ee:	2005      	movs	r0, #5
   2d0f0:	f7fa fcb6 	bl	27a60 <bsd_os_errno_set>
   2d0f4:	e7a1      	b.n	2d03a <pdn_interface_close+0xd2>
   2d0f6:	2005      	movs	r0, #5
   2d0f8:	f7fa fcb2 	bl	27a60 <bsd_os_errno_set>
   2d0fc:	e7d7      	b.n	2d0ae <pdn_interface_close+0x146>
   2d0fe:	bf00      	nop
   2d100:	789a0000 	.word	0x789a0000
   2d104:	20020cbc 	.word	0x20020cbc
   2d108:	20020bbc 	.word	0x20020bbc
   2d10c:	0003b6d4 	.word	0x0003b6d4
   2d110:	0003b71c 	.word	0x0003b71c
   2d114:	0003b70c 	.word	0x0003b70c
   2d118:	0003b774 	.word	0x0003b774
   2d11c:	0003b6e0 	.word	0x0003b6e0
   2d120:	20020bb8 	.word	0x20020bb8

0002d124 <pdn_interface_setopt>:
   2d124:	b510      	push	{r4, lr}
   2d126:	f240 2402 	movw	r4, #514	; 0x202
   2d12a:	42a1      	cmp	r1, r4
   2d12c:	d10d      	bne.n	2d14a <pdn_interface_setopt+0x26>
   2d12e:	b163      	cbz	r3, 2d14a <pdn_interface_setopt+0x26>
   2d130:	9902      	ldr	r1, [sp, #8]
   2d132:	b151      	cbz	r1, 2d14a <pdn_interface_setopt+0x26>
   2d134:	0c01      	lsrs	r1, r0, #16
   2d136:	4c25      	ldr	r4, [pc, #148]	; (2d1cc <pdn_interface_setopt+0xa8>)
   2d138:	0409      	lsls	r1, r1, #16
   2d13a:	42a1      	cmp	r1, r4
   2d13c:	d00b      	beq.n	2d156 <pdn_interface_setopt+0x32>
   2d13e:	2009      	movs	r0, #9
   2d140:	f7fa fc8e 	bl	27a60 <bsd_os_errno_set>
   2d144:	f04f 30ff 	mov.w	r0, #4294967295
   2d148:	bd10      	pop	{r4, pc}
   2d14a:	2016      	movs	r0, #22
   2d14c:	f7fa fc88 	bl	27a60 <bsd_os_errno_set>
   2d150:	f04f 30ff 	mov.w	r0, #4294967295
   2d154:	bd10      	pop	{r4, pc}
   2d156:	f020 40f1 	bic.w	r0, r0, #2021654528	; 0x78800000
   2d15a:	f420 10d0 	bic.w	r0, r0, #1703936	; 0x1a0000
   2d15e:	2809      	cmp	r0, #9
   2d160:	dced      	bgt.n	2d13e <pdn_interface_setopt+0x1a>
   2d162:	491b      	ldr	r1, [pc, #108]	; (2d1d0 <pdn_interface_setopt+0xac>)
   2d164:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
   2d168:	2900      	cmp	r1, #0
   2d16a:	d0e8      	beq.n	2d13e <pdn_interface_setopt+0x1a>
   2d16c:	6888      	ldr	r0, [r1, #8]
   2d16e:	2800      	cmp	r0, #0
   2d170:	d0e5      	beq.n	2d13e <pdn_interface_setopt+0x1a>
   2d172:	2a01      	cmp	r2, #1
   2d174:	d001      	beq.n	2d17a <pdn_interface_setopt+0x56>
   2d176:	202d      	movs	r0, #45	; 0x2d
   2d178:	e7e8      	b.n	2d14c <pdn_interface_setopt+0x28>
   2d17a:	688a      	ldr	r2, [r1, #8]
   2d17c:	b1fa      	cbz	r2, 2d1be <pdn_interface_setopt+0x9a>
   2d17e:	688a      	ldr	r2, [r1, #8]
   2d180:	2a03      	cmp	r2, #3
   2d182:	d01c      	beq.n	2d1be <pdn_interface_setopt+0x9a>
   2d184:	688a      	ldr	r2, [r1, #8]
   2d186:	2a04      	cmp	r2, #4
   2d188:	d019      	beq.n	2d1be <pdn_interface_setopt+0x9a>
   2d18a:	9a02      	ldr	r2, [sp, #8]
   2d18c:	0890      	lsrs	r0, r2, #2
   2d18e:	1e42      	subs	r2, r0, #1
   2d190:	2a01      	cmp	r2, #1
   2d192:	d8da      	bhi.n	2d14a <pdn_interface_setopt+0x26>
   2d194:	9a02      	ldr	r2, [sp, #8]
   2d196:	0792      	lsls	r2, r2, #30
   2d198:	d1d7      	bne.n	2d14a <pdn_interface_setopt+0x26>
   2d19a:	681a      	ldr	r2, [r3, #0]
   2d19c:	2a02      	cmp	r2, #2
   2d19e:	d010      	beq.n	2d1c2 <pdn_interface_setopt+0x9e>
   2d1a0:	2a0a      	cmp	r2, #10
   2d1a2:	d1d2      	bne.n	2d14a <pdn_interface_setopt+0x26>
   2d1a4:	2202      	movs	r2, #2
   2d1a6:	2802      	cmp	r0, #2
   2d1a8:	d106      	bne.n	2d1b8 <pdn_interface_setopt+0x94>
   2d1aa:	685b      	ldr	r3, [r3, #4]
   2d1ac:	2b02      	cmp	r3, #2
   2d1ae:	d00a      	beq.n	2d1c6 <pdn_interface_setopt+0xa2>
   2d1b0:	2b0a      	cmp	r3, #10
   2d1b2:	d1ca      	bne.n	2d14a <pdn_interface_setopt+0x26>
   2d1b4:	f042 0202 	orr.w	r2, r2, #2
   2d1b8:	670a      	str	r2, [r1, #112]	; 0x70
   2d1ba:	2000      	movs	r0, #0
   2d1bc:	e7c6      	b.n	2d14c <pdn_interface_setopt+0x28>
   2d1be:	200e      	movs	r0, #14
   2d1c0:	e7c4      	b.n	2d14c <pdn_interface_setopt+0x28>
   2d1c2:	2201      	movs	r2, #1
   2d1c4:	e7ef      	b.n	2d1a6 <pdn_interface_setopt+0x82>
   2d1c6:	f042 0201 	orr.w	r2, r2, #1
   2d1ca:	e7f5      	b.n	2d1b8 <pdn_interface_setopt+0x94>
   2d1cc:	789a0000 	.word	0x789a0000
   2d1d0:	20020cbc 	.word	0x20020cbc

0002d1d4 <pdn_interface_getopt>:
   2d1d4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2d1d8:	f240 2402 	movw	r4, #514	; 0x202
   2d1dc:	b083      	sub	sp, #12
   2d1de:	42a1      	cmp	r1, r4
   2d1e0:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   2d1e2:	f040 80a9 	bne.w	2d338 <pdn_interface_getopt+0x164>
   2d1e6:	461e      	mov	r6, r3
   2d1e8:	2b00      	cmp	r3, #0
   2d1ea:	f000 80a5 	beq.w	2d338 <pdn_interface_getopt+0x164>
   2d1ee:	2d00      	cmp	r5, #0
   2d1f0:	f000 80a2 	beq.w	2d338 <pdn_interface_getopt+0x164>
   2d1f4:	0c03      	lsrs	r3, r0, #16
   2d1f6:	4956      	ldr	r1, [pc, #344]	; (2d350 <pdn_interface_getopt+0x17c>)
   2d1f8:	041b      	lsls	r3, r3, #16
   2d1fa:	428b      	cmp	r3, r1
   2d1fc:	f040 8082 	bne.w	2d304 <pdn_interface_getopt+0x130>
   2d200:	f020 44f1 	bic.w	r4, r0, #2021654528	; 0x78800000
   2d204:	f424 14d0 	bic.w	r4, r4, #1703936	; 0x1a0000
   2d208:	2c09      	cmp	r4, #9
   2d20a:	dc7b      	bgt.n	2d304 <pdn_interface_getopt+0x130>
   2d20c:	4b51      	ldr	r3, [pc, #324]	; (2d354 <pdn_interface_getopt+0x180>)
   2d20e:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   2d212:	2b00      	cmp	r3, #0
   2d214:	d076      	beq.n	2d304 <pdn_interface_getopt+0x130>
   2d216:	6899      	ldr	r1, [r3, #8]
   2d218:	2900      	cmp	r1, #0
   2d21a:	d073      	beq.n	2d304 <pdn_interface_getopt+0x130>
   2d21c:	2a02      	cmp	r2, #2
   2d21e:	d00e      	beq.n	2d23e <pdn_interface_getopt+0x6a>
   2d220:	2a03      	cmp	r2, #3
   2d222:	d008      	beq.n	2d236 <pdn_interface_getopt+0x62>
   2d224:	2a01      	cmp	r2, #1
   2d226:	d015      	beq.n	2d254 <pdn_interface_getopt+0x80>
   2d228:	202d      	movs	r0, #45	; 0x2d
   2d22a:	f7fa fc19 	bl	27a60 <bsd_os_errno_set>
   2d22e:	2000      	movs	r0, #0
   2d230:	b003      	add	sp, #12
   2d232:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2d236:	682b      	ldr	r3, [r5, #0]
   2d238:	bb23      	cbnz	r3, 2d284 <pdn_interface_getopt+0xb0>
   2d23a:	2016      	movs	r0, #22
   2d23c:	e7f5      	b.n	2d22a <pdn_interface_getopt+0x56>
   2d23e:	682a      	ldr	r2, [r5, #0]
   2d240:	2a00      	cmp	r2, #0
   2d242:	d0fa      	beq.n	2d23a <pdn_interface_getopt+0x66>
   2d244:	2201      	movs	r2, #1
   2d246:	2000      	movs	r0, #0
   2d248:	681b      	ldr	r3, [r3, #0]
   2d24a:	7033      	strb	r3, [r6, #0]
   2d24c:	602a      	str	r2, [r5, #0]
   2d24e:	b003      	add	sp, #12
   2d250:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2d254:	689a      	ldr	r2, [r3, #8]
   2d256:	2a00      	cmp	r2, #0
   2d258:	d052      	beq.n	2d300 <pdn_interface_getopt+0x12c>
   2d25a:	689a      	ldr	r2, [r3, #8]
   2d25c:	2a04      	cmp	r2, #4
   2d25e:	d04f      	beq.n	2d300 <pdn_interface_getopt+0x12c>
   2d260:	682a      	ldr	r2, [r5, #0]
   2d262:	2a07      	cmp	r2, #7
   2d264:	d9e9      	bls.n	2d23a <pdn_interface_getopt+0x66>
   2d266:	f012 0203 	ands.w	r2, r2, #3
   2d26a:	d1e6      	bne.n	2d23a <pdn_interface_getopt+0x66>
   2d26c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   2d26e:	0799      	lsls	r1, r3, #30
   2d270:	d45d      	bmi.n	2d32e <pdn_interface_getopt+0x15a>
   2d272:	2104      	movs	r1, #4
   2d274:	07db      	lsls	r3, r3, #31
   2d276:	d502      	bpl.n	2d27e <pdn_interface_getopt+0xaa>
   2d278:	2302      	movs	r3, #2
   2d27a:	50b3      	str	r3, [r6, r2]
   2d27c:	460a      	mov	r2, r1
   2d27e:	602a      	str	r2, [r5, #0]
   2d280:	2000      	movs	r0, #0
   2d282:	e7d5      	b.n	2d230 <pdn_interface_getopt+0x5c>
   2d284:	4a34      	ldr	r2, [pc, #208]	; (2d358 <pdn_interface_getopt+0x184>)
   2d286:	f44f 7180 	mov.w	r1, #256	; 0x100
   2d28a:	4834      	ldr	r0, [pc, #208]	; (2d35c <pdn_interface_getopt+0x188>)
   2d28c:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 2d368 <pdn_interface_getopt+0x194>
   2d290:	f009 f8b8 	bl	36404 <sniprintf>
   2d294:	4831      	ldr	r0, [pc, #196]	; (2d35c <pdn_interface_getopt+0x188>)
   2d296:	f8d8 9000 	ldr.w	r9, [r8]
   2d29a:	2700      	movs	r7, #0
   2d29c:	f7ef ff5c 	bl	1d158 <strlen>
   2d2a0:	463b      	mov	r3, r7
   2d2a2:	4602      	mov	r2, r0
   2d2a4:	492d      	ldr	r1, [pc, #180]	; (2d35c <pdn_interface_getopt+0x188>)
   2d2a6:	4648      	mov	r0, r9
   2d2a8:	9701      	str	r7, [sp, #4]
   2d2aa:	9700      	str	r7, [sp, #0]
   2d2ac:	f7fc fbcc 	bl	29a48 <at_interface_write>
   2d2b0:	4681      	mov	r9, r0
   2d2b2:	482a      	ldr	r0, [pc, #168]	; (2d35c <pdn_interface_getopt+0x188>)
   2d2b4:	f7ef ff50 	bl	1d158 <strlen>
   2d2b8:	4548      	cmp	r0, r9
   2d2ba:	d143      	bne.n	2d344 <pdn_interface_getopt+0x170>
   2d2bc:	463b      	mov	r3, r7
   2d2be:	e9cd 7700 	strd	r7, r7, [sp]
   2d2c2:	f44f 7280 	mov.w	r2, #256	; 0x100
   2d2c6:	4925      	ldr	r1, [pc, #148]	; (2d35c <pdn_interface_getopt+0x188>)
   2d2c8:	f8d8 0000 	ldr.w	r0, [r8]
   2d2cc:	f7fc fcc0 	bl	29c50 <at_interface_read>
   2d2d0:	4607      	mov	r7, r0
   2d2d2:	4823      	ldr	r0, [pc, #140]	; (2d360 <pdn_interface_getopt+0x18c>)
   2d2d4:	f7ef ff40 	bl	1d158 <strlen>
   2d2d8:	4287      	cmp	r7, r0
   2d2da:	db19      	blt.n	2d310 <pdn_interface_getopt+0x13c>
   2d2dc:	4602      	mov	r2, r0
   2d2de:	491f      	ldr	r1, [pc, #124]	; (2d35c <pdn_interface_getopt+0x188>)
   2d2e0:	481f      	ldr	r0, [pc, #124]	; (2d360 <pdn_interface_getopt+0x18c>)
   2d2e2:	f00c fedd 	bl	3a0a0 <strncmp>
   2d2e6:	4607      	mov	r7, r0
   2d2e8:	b990      	cbnz	r0, 2d310 <pdn_interface_getopt+0x13c>
   2d2ea:	4620      	mov	r0, r4
   2d2ec:	491b      	ldr	r1, [pc, #108]	; (2d35c <pdn_interface_getopt+0x188>)
   2d2ee:	f7ff fb41 	bl	2c974 <pdn_state_get_parser>
   2d2f2:	2800      	cmp	r0, #0
   2d2f4:	db99      	blt.n	2d22a <pdn_interface_getopt+0x56>
   2d2f6:	2301      	movs	r3, #1
   2d2f8:	7030      	strb	r0, [r6, #0]
   2d2fa:	4638      	mov	r0, r7
   2d2fc:	602b      	str	r3, [r5, #0]
   2d2fe:	e797      	b.n	2d230 <pdn_interface_getopt+0x5c>
   2d300:	200e      	movs	r0, #14
   2d302:	e792      	b.n	2d22a <pdn_interface_getopt+0x56>
   2d304:	2009      	movs	r0, #9
   2d306:	f7fa fbab 	bl	27a60 <bsd_os_errno_set>
   2d30a:	f04f 30ff 	mov.w	r0, #4294967295
   2d30e:	e78f      	b.n	2d230 <pdn_interface_getopt+0x5c>
   2d310:	4814      	ldr	r0, [pc, #80]	; (2d364 <pdn_interface_getopt+0x190>)
   2d312:	f7ef ff21 	bl	1d158 <strlen>
   2d316:	4911      	ldr	r1, [pc, #68]	; (2d35c <pdn_interface_getopt+0x188>)
   2d318:	4602      	mov	r2, r0
   2d31a:	4812      	ldr	r0, [pc, #72]	; (2d364 <pdn_interface_getopt+0x190>)
   2d31c:	f00c fec0 	bl	3a0a0 <strncmp>
   2d320:	b980      	cbnz	r0, 2d344 <pdn_interface_getopt+0x170>
   2d322:	2008      	movs	r0, #8
   2d324:	f7fa fb9c 	bl	27a60 <bsd_os_errno_set>
   2d328:	f04f 30ff 	mov.w	r0, #4294967295
   2d32c:	e77d      	b.n	2d22a <pdn_interface_getopt+0x56>
   2d32e:	220a      	movs	r2, #10
   2d330:	2108      	movs	r1, #8
   2d332:	6032      	str	r2, [r6, #0]
   2d334:	2204      	movs	r2, #4
   2d336:	e79d      	b.n	2d274 <pdn_interface_getopt+0xa0>
   2d338:	2016      	movs	r0, #22
   2d33a:	f7fa fb91 	bl	27a60 <bsd_os_errno_set>
   2d33e:	f04f 30ff 	mov.w	r0, #4294967295
   2d342:	e775      	b.n	2d230 <pdn_interface_getopt+0x5c>
   2d344:	2005      	movs	r0, #5
   2d346:	f7fa fb8b 	bl	27a60 <bsd_os_errno_set>
   2d34a:	f04f 30ff 	mov.w	r0, #4294967295
   2d34e:	e76c      	b.n	2d22a <pdn_interface_getopt+0x56>
   2d350:	789a0000 	.word	0x789a0000
   2d354:	20020cbc 	.word	0x20020cbc
   2d358:	0003b744 	.word	0x0003b744
   2d35c:	20020bbc 	.word	0x20020bbc
   2d360:	0003b750 	.word	0x0003b750
   2d364:	0003b774 	.word	0x0003b774
   2d368:	20020bb8 	.word	0x20020bb8

0002d36c <pdn_interface_pdn_id_get>:
   2d36c:	2900      	cmp	r1, #0
   2d36e:	f000 83b9 	beq.w	2dae4 <pdn_interface_pdn_id_get+0x778>
   2d372:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2d376:	4ca3      	ldr	r4, [pc, #652]	; (2d604 <pdn_interface_pdn_id_get+0x298>)
   2d378:	2802      	cmp	r0, #2
   2d37a:	b083      	sub	sp, #12
   2d37c:	460d      	mov	r5, r1
   2d37e:	6823      	ldr	r3, [r4, #0]
   2d380:	f000 8094 	beq.w	2d4ac <pdn_interface_pdn_id_get+0x140>
   2d384:	280a      	cmp	r0, #10
   2d386:	d03f      	beq.n	2d408 <pdn_interface_pdn_id_get+0x9c>
   2d388:	b11b      	cbz	r3, 2d392 <pdn_interface_pdn_id_get+0x26>
   2d38a:	689b      	ldr	r3, [r3, #8]
   2d38c:	2b03      	cmp	r3, #3
   2d38e:	f000 8127 	beq.w	2d5e0 <pdn_interface_pdn_id_get+0x274>
   2d392:	6863      	ldr	r3, [r4, #4]
   2d394:	b11b      	cbz	r3, 2d39e <pdn_interface_pdn_id_get+0x32>
   2d396:	689b      	ldr	r3, [r3, #8]
   2d398:	2b03      	cmp	r3, #3
   2d39a:	f000 8110 	beq.w	2d5be <pdn_interface_pdn_id_get+0x252>
   2d39e:	68a3      	ldr	r3, [r4, #8]
   2d3a0:	b11b      	cbz	r3, 2d3aa <pdn_interface_pdn_id_get+0x3e>
   2d3a2:	689b      	ldr	r3, [r3, #8]
   2d3a4:	2b03      	cmp	r3, #3
   2d3a6:	f000 80f9 	beq.w	2d59c <pdn_interface_pdn_id_get+0x230>
   2d3aa:	68e3      	ldr	r3, [r4, #12]
   2d3ac:	b11b      	cbz	r3, 2d3b6 <pdn_interface_pdn_id_get+0x4a>
   2d3ae:	689b      	ldr	r3, [r3, #8]
   2d3b0:	2b03      	cmp	r3, #3
   2d3b2:	f000 80e2 	beq.w	2d57a <pdn_interface_pdn_id_get+0x20e>
   2d3b6:	6923      	ldr	r3, [r4, #16]
   2d3b8:	b11b      	cbz	r3, 2d3c2 <pdn_interface_pdn_id_get+0x56>
   2d3ba:	689b      	ldr	r3, [r3, #8]
   2d3bc:	2b03      	cmp	r3, #3
   2d3be:	f000 8123 	beq.w	2d608 <pdn_interface_pdn_id_get+0x29c>
   2d3c2:	6963      	ldr	r3, [r4, #20]
   2d3c4:	b11b      	cbz	r3, 2d3ce <pdn_interface_pdn_id_get+0x62>
   2d3c6:	689b      	ldr	r3, [r3, #8]
   2d3c8:	2b03      	cmp	r3, #3
   2d3ca:	f000 8161 	beq.w	2d690 <pdn_interface_pdn_id_get+0x324>
   2d3ce:	69a3      	ldr	r3, [r4, #24]
   2d3d0:	b11b      	cbz	r3, 2d3da <pdn_interface_pdn_id_get+0x6e>
   2d3d2:	689b      	ldr	r3, [r3, #8]
   2d3d4:	2b03      	cmp	r3, #3
   2d3d6:	f000 814a 	beq.w	2d66e <pdn_interface_pdn_id_get+0x302>
   2d3da:	69e3      	ldr	r3, [r4, #28]
   2d3dc:	b11b      	cbz	r3, 2d3e6 <pdn_interface_pdn_id_get+0x7a>
   2d3de:	689b      	ldr	r3, [r3, #8]
   2d3e0:	2b03      	cmp	r3, #3
   2d3e2:	f000 8133 	beq.w	2d64c <pdn_interface_pdn_id_get+0x2e0>
   2d3e6:	6a23      	ldr	r3, [r4, #32]
   2d3e8:	b11b      	cbz	r3, 2d3f2 <pdn_interface_pdn_id_get+0x86>
   2d3ea:	689b      	ldr	r3, [r3, #8]
   2d3ec:	2b03      	cmp	r3, #3
   2d3ee:	f000 811c 	beq.w	2d62a <pdn_interface_pdn_id_get+0x2be>
   2d3f2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2d3f4:	b11b      	cbz	r3, 2d3fe <pdn_interface_pdn_id_get+0x92>
   2d3f6:	689b      	ldr	r3, [r3, #8]
   2d3f8:	2b03      	cmp	r3, #3
   2d3fa:	f000 80ad 	beq.w	2d558 <pdn_interface_pdn_id_get+0x1ec>
   2d3fe:	f04f 30ff 	mov.w	r0, #4294967295
   2d402:	b003      	add	sp, #12
   2d404:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2d408:	b11b      	cbz	r3, 2d412 <pdn_interface_pdn_id_get+0xa6>
   2d40a:	689b      	ldr	r3, [r3, #8]
   2d40c:	2b03      	cmp	r3, #3
   2d40e:	f000 8335 	beq.w	2da7c <pdn_interface_pdn_id_get+0x710>
   2d412:	6863      	ldr	r3, [r4, #4]
   2d414:	b11b      	cbz	r3, 2d41e <pdn_interface_pdn_id_get+0xb2>
   2d416:	689b      	ldr	r3, [r3, #8]
   2d418:	2b03      	cmp	r3, #3
   2d41a:	f000 82fd 	beq.w	2da18 <pdn_interface_pdn_id_get+0x6ac>
   2d41e:	68a3      	ldr	r3, [r4, #8]
   2d420:	b11b      	cbz	r3, 2d42a <pdn_interface_pdn_id_get+0xbe>
   2d422:	689b      	ldr	r3, [r3, #8]
   2d424:	2b03      	cmp	r3, #3
   2d426:	f000 82d5 	beq.w	2d9d4 <pdn_interface_pdn_id_get+0x668>
   2d42a:	68e3      	ldr	r3, [r4, #12]
   2d42c:	b11b      	cbz	r3, 2d436 <pdn_interface_pdn_id_get+0xca>
   2d42e:	689e      	ldr	r6, [r3, #8]
   2d430:	2e03      	cmp	r6, #3
   2d432:	f000 81f0 	beq.w	2d816 <pdn_interface_pdn_id_get+0x4aa>
   2d436:	6923      	ldr	r3, [r4, #16]
   2d438:	b11b      	cbz	r3, 2d442 <pdn_interface_pdn_id_get+0xd6>
   2d43a:	689b      	ldr	r3, [r3, #8]
   2d43c:	2b03      	cmp	r3, #3
   2d43e:	f000 8203 	beq.w	2d848 <pdn_interface_pdn_id_get+0x4dc>
   2d442:	6963      	ldr	r3, [r4, #20]
   2d444:	b11b      	cbz	r3, 2d44e <pdn_interface_pdn_id_get+0xe2>
   2d446:	689b      	ldr	r3, [r3, #8]
   2d448:	2b03      	cmp	r3, #3
   2d44a:	f000 8215 	beq.w	2d878 <pdn_interface_pdn_id_get+0x50c>
   2d44e:	69a3      	ldr	r3, [r4, #24]
   2d450:	b11b      	cbz	r3, 2d45a <pdn_interface_pdn_id_get+0xee>
   2d452:	689b      	ldr	r3, [r3, #8]
   2d454:	2b03      	cmp	r3, #3
   2d456:	f000 8227 	beq.w	2d8a8 <pdn_interface_pdn_id_get+0x53c>
   2d45a:	69e3      	ldr	r3, [r4, #28]
   2d45c:	b11b      	cbz	r3, 2d466 <pdn_interface_pdn_id_get+0xfa>
   2d45e:	689b      	ldr	r3, [r3, #8]
   2d460:	2b03      	cmp	r3, #3
   2d462:	f000 8239 	beq.w	2d8d8 <pdn_interface_pdn_id_get+0x56c>
   2d466:	6a23      	ldr	r3, [r4, #32]
   2d468:	b11b      	cbz	r3, 2d472 <pdn_interface_pdn_id_get+0x106>
   2d46a:	689b      	ldr	r3, [r3, #8]
   2d46c:	2b03      	cmp	r3, #3
   2d46e:	f000 824d 	beq.w	2d90c <pdn_interface_pdn_id_get+0x5a0>
   2d472:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2d474:	2b00      	cmp	r3, #0
   2d476:	d0c2      	beq.n	2d3fe <pdn_interface_pdn_id_get+0x92>
   2d478:	689b      	ldr	r3, [r3, #8]
   2d47a:	2b03      	cmp	r3, #3
   2d47c:	d1bf      	bne.n	2d3fe <pdn_interface_pdn_id_get+0x92>
   2d47e:	4628      	mov	r0, r5
   2d480:	f7ef fe6a 	bl	1d158 <strlen>
   2d484:	4606      	mov	r6, r0
   2d486:	6a60      	ldr	r0, [r4, #36]	; 0x24
   2d488:	300c      	adds	r0, #12
   2d48a:	f7ef fe65 	bl	1d158 <strlen>
   2d48e:	42b0      	cmp	r0, r6
   2d490:	d1b5      	bne.n	2d3fe <pdn_interface_pdn_id_get+0x92>
   2d492:	6a61      	ldr	r1, [r4, #36]	; 0x24
   2d494:	4628      	mov	r0, r5
   2d496:	310c      	adds	r1, #12
   2d498:	f7ef fe54 	bl	1d144 <strcmp>
   2d49c:	2800      	cmp	r0, #0
   2d49e:	d1ae      	bne.n	2d3fe <pdn_interface_pdn_id_get+0x92>
   2d4a0:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2d4a2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d4a4:	0792      	lsls	r2, r2, #30
   2d4a6:	d5aa      	bpl.n	2d3fe <pdn_interface_pdn_id_get+0x92>
   2d4a8:	2609      	movs	r6, #9
   2d4aa:	e11a      	b.n	2d6e2 <pdn_interface_pdn_id_get+0x376>
   2d4ac:	b11b      	cbz	r3, 2d4b6 <pdn_interface_pdn_id_get+0x14a>
   2d4ae:	689b      	ldr	r3, [r3, #8]
   2d4b0:	2b03      	cmp	r3, #3
   2d4b2:	f000 82fd 	beq.w	2dab0 <pdn_interface_pdn_id_get+0x744>
   2d4b6:	6863      	ldr	r3, [r4, #4]
   2d4b8:	b11b      	cbz	r3, 2d4c2 <pdn_interface_pdn_id_get+0x156>
   2d4ba:	689b      	ldr	r3, [r3, #8]
   2d4bc:	2b03      	cmp	r3, #3
   2d4be:	f000 82c5 	beq.w	2da4c <pdn_interface_pdn_id_get+0x6e0>
   2d4c2:	68a3      	ldr	r3, [r4, #8]
   2d4c4:	b11b      	cbz	r3, 2d4ce <pdn_interface_pdn_id_get+0x162>
   2d4c6:	689b      	ldr	r3, [r3, #8]
   2d4c8:	2b03      	cmp	r3, #3
   2d4ca:	f000 8269 	beq.w	2d9a0 <pdn_interface_pdn_id_get+0x634>
   2d4ce:	68e3      	ldr	r3, [r4, #12]
   2d4d0:	b11b      	cbz	r3, 2d4da <pdn_interface_pdn_id_get+0x16e>
   2d4d2:	689e      	ldr	r6, [r3, #8]
   2d4d4:	2e03      	cmp	r6, #3
   2d4d6:	f000 80ec 	beq.w	2d6b2 <pdn_interface_pdn_id_get+0x346>
   2d4da:	6923      	ldr	r3, [r4, #16]
   2d4dc:	b11b      	cbz	r3, 2d4e6 <pdn_interface_pdn_id_get+0x17a>
   2d4de:	689b      	ldr	r3, [r3, #8]
   2d4e0:	2b03      	cmp	r3, #3
   2d4e2:	f000 814a 	beq.w	2d77a <pdn_interface_pdn_id_get+0x40e>
   2d4e6:	6963      	ldr	r3, [r4, #20]
   2d4e8:	b11b      	cbz	r3, 2d4f2 <pdn_interface_pdn_id_get+0x186>
   2d4ea:	689b      	ldr	r3, [r3, #8]
   2d4ec:	2b03      	cmp	r3, #3
   2d4ee:	f000 815e 	beq.w	2d7ae <pdn_interface_pdn_id_get+0x442>
   2d4f2:	69a3      	ldr	r3, [r4, #24]
   2d4f4:	b11b      	cbz	r3, 2d4fe <pdn_interface_pdn_id_get+0x192>
   2d4f6:	689b      	ldr	r3, [r3, #8]
   2d4f8:	2b03      	cmp	r3, #3
   2d4fa:	f000 8172 	beq.w	2d7e2 <pdn_interface_pdn_id_get+0x476>
   2d4fe:	69e3      	ldr	r3, [r4, #28]
   2d500:	b11b      	cbz	r3, 2d50a <pdn_interface_pdn_id_get+0x19e>
   2d502:	689b      	ldr	r3, [r3, #8]
   2d504:	2b03      	cmp	r3, #3
   2d506:	f000 821b 	beq.w	2d940 <pdn_interface_pdn_id_get+0x5d4>
   2d50a:	6a23      	ldr	r3, [r4, #32]
   2d50c:	b11b      	cbz	r3, 2d516 <pdn_interface_pdn_id_get+0x1aa>
   2d50e:	689b      	ldr	r3, [r3, #8]
   2d510:	2b03      	cmp	r3, #3
   2d512:	f000 822d 	beq.w	2d970 <pdn_interface_pdn_id_get+0x604>
   2d516:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2d518:	2b00      	cmp	r3, #0
   2d51a:	f43f af70 	beq.w	2d3fe <pdn_interface_pdn_id_get+0x92>
   2d51e:	689b      	ldr	r3, [r3, #8]
   2d520:	2b03      	cmp	r3, #3
   2d522:	f47f af6c 	bne.w	2d3fe <pdn_interface_pdn_id_get+0x92>
   2d526:	4628      	mov	r0, r5
   2d528:	f7ef fe16 	bl	1d158 <strlen>
   2d52c:	4606      	mov	r6, r0
   2d52e:	6a60      	ldr	r0, [r4, #36]	; 0x24
   2d530:	300c      	adds	r0, #12
   2d532:	f7ef fe11 	bl	1d158 <strlen>
   2d536:	4286      	cmp	r6, r0
   2d538:	f47f af61 	bne.w	2d3fe <pdn_interface_pdn_id_get+0x92>
   2d53c:	6a61      	ldr	r1, [r4, #36]	; 0x24
   2d53e:	4628      	mov	r0, r5
   2d540:	310c      	adds	r1, #12
   2d542:	f7ef fdff 	bl	1d144 <strcmp>
   2d546:	2800      	cmp	r0, #0
   2d548:	f47f af59 	bne.w	2d3fe <pdn_interface_pdn_id_get+0x92>
   2d54c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2d54e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d550:	07d2      	lsls	r2, r2, #31
   2d552:	f57f af54 	bpl.w	2d3fe <pdn_interface_pdn_id_get+0x92>
   2d556:	e7a7      	b.n	2d4a8 <pdn_interface_pdn_id_get+0x13c>
   2d558:	4628      	mov	r0, r5
   2d55a:	f7ef fdfd 	bl	1d158 <strlen>
   2d55e:	4606      	mov	r6, r0
   2d560:	6a60      	ldr	r0, [r4, #36]	; 0x24
   2d562:	300c      	adds	r0, #12
   2d564:	f7ef fdf8 	bl	1d158 <strlen>
   2d568:	42b0      	cmp	r0, r6
   2d56a:	f47f af48 	bne.w	2d3fe <pdn_interface_pdn_id_get+0x92>
   2d56e:	6a61      	ldr	r1, [r4, #36]	; 0x24
   2d570:	4628      	mov	r0, r5
   2d572:	310c      	adds	r1, #12
   2d574:	f7ef fde6 	bl	1d144 <strcmp>
   2d578:	e741      	b.n	2d3fe <pdn_interface_pdn_id_get+0x92>
   2d57a:	4628      	mov	r0, r5
   2d57c:	f7ef fdec 	bl	1d158 <strlen>
   2d580:	4606      	mov	r6, r0
   2d582:	68e0      	ldr	r0, [r4, #12]
   2d584:	300c      	adds	r0, #12
   2d586:	f7ef fde7 	bl	1d158 <strlen>
   2d58a:	4286      	cmp	r6, r0
   2d58c:	f47f af13 	bne.w	2d3b6 <pdn_interface_pdn_id_get+0x4a>
   2d590:	68e1      	ldr	r1, [r4, #12]
   2d592:	4628      	mov	r0, r5
   2d594:	310c      	adds	r1, #12
   2d596:	f7ef fdd5 	bl	1d144 <strcmp>
   2d59a:	e70c      	b.n	2d3b6 <pdn_interface_pdn_id_get+0x4a>
   2d59c:	4628      	mov	r0, r5
   2d59e:	f7ef fddb 	bl	1d158 <strlen>
   2d5a2:	4606      	mov	r6, r0
   2d5a4:	68a0      	ldr	r0, [r4, #8]
   2d5a6:	300c      	adds	r0, #12
   2d5a8:	f7ef fdd6 	bl	1d158 <strlen>
   2d5ac:	4286      	cmp	r6, r0
   2d5ae:	f47f aefc 	bne.w	2d3aa <pdn_interface_pdn_id_get+0x3e>
   2d5b2:	68a1      	ldr	r1, [r4, #8]
   2d5b4:	4628      	mov	r0, r5
   2d5b6:	310c      	adds	r1, #12
   2d5b8:	f7ef fdc4 	bl	1d144 <strcmp>
   2d5bc:	e6f5      	b.n	2d3aa <pdn_interface_pdn_id_get+0x3e>
   2d5be:	4628      	mov	r0, r5
   2d5c0:	f7ef fdca 	bl	1d158 <strlen>
   2d5c4:	4606      	mov	r6, r0
   2d5c6:	6860      	ldr	r0, [r4, #4]
   2d5c8:	300c      	adds	r0, #12
   2d5ca:	f7ef fdc5 	bl	1d158 <strlen>
   2d5ce:	4286      	cmp	r6, r0
   2d5d0:	f47f aee5 	bne.w	2d39e <pdn_interface_pdn_id_get+0x32>
   2d5d4:	6861      	ldr	r1, [r4, #4]
   2d5d6:	4628      	mov	r0, r5
   2d5d8:	310c      	adds	r1, #12
   2d5da:	f7ef fdb3 	bl	1d144 <strcmp>
   2d5de:	e6de      	b.n	2d39e <pdn_interface_pdn_id_get+0x32>
   2d5e0:	4608      	mov	r0, r1
   2d5e2:	f7ef fdb9 	bl	1d158 <strlen>
   2d5e6:	4606      	mov	r6, r0
   2d5e8:	6820      	ldr	r0, [r4, #0]
   2d5ea:	300c      	adds	r0, #12
   2d5ec:	f7ef fdb4 	bl	1d158 <strlen>
   2d5f0:	4286      	cmp	r6, r0
   2d5f2:	f47f aece 	bne.w	2d392 <pdn_interface_pdn_id_get+0x26>
   2d5f6:	6821      	ldr	r1, [r4, #0]
   2d5f8:	4628      	mov	r0, r5
   2d5fa:	310c      	adds	r1, #12
   2d5fc:	f7ef fda2 	bl	1d144 <strcmp>
   2d600:	e6c7      	b.n	2d392 <pdn_interface_pdn_id_get+0x26>
   2d602:	bf00      	nop
   2d604:	20020cbc 	.word	0x20020cbc
   2d608:	4628      	mov	r0, r5
   2d60a:	f7ef fda5 	bl	1d158 <strlen>
   2d60e:	4606      	mov	r6, r0
   2d610:	6920      	ldr	r0, [r4, #16]
   2d612:	300c      	adds	r0, #12
   2d614:	f7ef fda0 	bl	1d158 <strlen>
   2d618:	4286      	cmp	r6, r0
   2d61a:	f47f aed2 	bne.w	2d3c2 <pdn_interface_pdn_id_get+0x56>
   2d61e:	6921      	ldr	r1, [r4, #16]
   2d620:	4628      	mov	r0, r5
   2d622:	310c      	adds	r1, #12
   2d624:	f7ef fd8e 	bl	1d144 <strcmp>
   2d628:	e6cb      	b.n	2d3c2 <pdn_interface_pdn_id_get+0x56>
   2d62a:	4628      	mov	r0, r5
   2d62c:	f7ef fd94 	bl	1d158 <strlen>
   2d630:	4606      	mov	r6, r0
   2d632:	6a20      	ldr	r0, [r4, #32]
   2d634:	300c      	adds	r0, #12
   2d636:	f7ef fd8f 	bl	1d158 <strlen>
   2d63a:	4286      	cmp	r6, r0
   2d63c:	f47f aed9 	bne.w	2d3f2 <pdn_interface_pdn_id_get+0x86>
   2d640:	6a21      	ldr	r1, [r4, #32]
   2d642:	4628      	mov	r0, r5
   2d644:	310c      	adds	r1, #12
   2d646:	f7ef fd7d 	bl	1d144 <strcmp>
   2d64a:	e6d2      	b.n	2d3f2 <pdn_interface_pdn_id_get+0x86>
   2d64c:	4628      	mov	r0, r5
   2d64e:	f7ef fd83 	bl	1d158 <strlen>
   2d652:	4606      	mov	r6, r0
   2d654:	69e0      	ldr	r0, [r4, #28]
   2d656:	300c      	adds	r0, #12
   2d658:	f7ef fd7e 	bl	1d158 <strlen>
   2d65c:	4286      	cmp	r6, r0
   2d65e:	f47f aec2 	bne.w	2d3e6 <pdn_interface_pdn_id_get+0x7a>
   2d662:	69e1      	ldr	r1, [r4, #28]
   2d664:	4628      	mov	r0, r5
   2d666:	310c      	adds	r1, #12
   2d668:	f7ef fd6c 	bl	1d144 <strcmp>
   2d66c:	e6bb      	b.n	2d3e6 <pdn_interface_pdn_id_get+0x7a>
   2d66e:	4628      	mov	r0, r5
   2d670:	f7ef fd72 	bl	1d158 <strlen>
   2d674:	4606      	mov	r6, r0
   2d676:	69a0      	ldr	r0, [r4, #24]
   2d678:	300c      	adds	r0, #12
   2d67a:	f7ef fd6d 	bl	1d158 <strlen>
   2d67e:	4286      	cmp	r6, r0
   2d680:	f47f aeab 	bne.w	2d3da <pdn_interface_pdn_id_get+0x6e>
   2d684:	69a1      	ldr	r1, [r4, #24]
   2d686:	4628      	mov	r0, r5
   2d688:	310c      	adds	r1, #12
   2d68a:	f7ef fd5b 	bl	1d144 <strcmp>
   2d68e:	e6a4      	b.n	2d3da <pdn_interface_pdn_id_get+0x6e>
   2d690:	4628      	mov	r0, r5
   2d692:	f7ef fd61 	bl	1d158 <strlen>
   2d696:	4606      	mov	r6, r0
   2d698:	6960      	ldr	r0, [r4, #20]
   2d69a:	300c      	adds	r0, #12
   2d69c:	f7ef fd5c 	bl	1d158 <strlen>
   2d6a0:	4286      	cmp	r6, r0
   2d6a2:	f47f ae94 	bne.w	2d3ce <pdn_interface_pdn_id_get+0x62>
   2d6a6:	6961      	ldr	r1, [r4, #20]
   2d6a8:	4628      	mov	r0, r5
   2d6aa:	310c      	adds	r1, #12
   2d6ac:	f7ef fd4a 	bl	1d144 <strcmp>
   2d6b0:	e68d      	b.n	2d3ce <pdn_interface_pdn_id_get+0x62>
   2d6b2:	4628      	mov	r0, r5
   2d6b4:	f7ef fd50 	bl	1d158 <strlen>
   2d6b8:	4607      	mov	r7, r0
   2d6ba:	68e0      	ldr	r0, [r4, #12]
   2d6bc:	300c      	adds	r0, #12
   2d6be:	f7ef fd4b 	bl	1d158 <strlen>
   2d6c2:	4287      	cmp	r7, r0
   2d6c4:	f47f af09 	bne.w	2d4da <pdn_interface_pdn_id_get+0x16e>
   2d6c8:	68e1      	ldr	r1, [r4, #12]
   2d6ca:	4628      	mov	r0, r5
   2d6cc:	310c      	adds	r1, #12
   2d6ce:	f7ef fd39 	bl	1d144 <strcmp>
   2d6d2:	2800      	cmp	r0, #0
   2d6d4:	f47f af01 	bne.w	2d4da <pdn_interface_pdn_id_get+0x16e>
   2d6d8:	68e3      	ldr	r3, [r4, #12]
   2d6da:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d6dc:	07d1      	lsls	r1, r2, #31
   2d6de:	f57f aefc 	bpl.w	2d4da <pdn_interface_pdn_id_get+0x16e>
   2d6e2:	6858      	ldr	r0, [r3, #4]
   2d6e4:	1c43      	adds	r3, r0, #1
   2d6e6:	f47f ae8c 	bne.w	2d402 <pdn_interface_pdn_id_get+0x96>
   2d6ea:	4dc6      	ldr	r5, [pc, #792]	; (2da04 <pdn_interface_pdn_id_get+0x698>)
   2d6ec:	4ac6      	ldr	r2, [pc, #792]	; (2da08 <pdn_interface_pdn_id_get+0x69c>)
   2d6ee:	f44f 7180 	mov.w	r1, #256	; 0x100
   2d6f2:	4628      	mov	r0, r5
   2d6f4:	f008 fe86 	bl	36404 <sniprintf>
   2d6f8:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   2d6fc:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   2d700:	681b      	ldr	r3, [r3, #0]
   2d702:	4ac2      	ldr	r2, [pc, #776]	; (2da0c <pdn_interface_pdn_id_get+0x6a0>)
   2d704:	4428      	add	r0, r5
   2d706:	f8df 830c 	ldr.w	r8, [pc, #780]	; 2da14 <pdn_interface_pdn_id_get+0x6a8>
   2d70a:	f008 fe7b 	bl	36404 <sniprintf>
   2d70e:	4628      	mov	r0, r5
   2d710:	f8d8 9000 	ldr.w	r9, [r8]
   2d714:	2700      	movs	r7, #0
   2d716:	f7ef fd1f 	bl	1d158 <strlen>
   2d71a:	4629      	mov	r1, r5
   2d71c:	4602      	mov	r2, r0
   2d71e:	463b      	mov	r3, r7
   2d720:	4648      	mov	r0, r9
   2d722:	9701      	str	r7, [sp, #4]
   2d724:	9700      	str	r7, [sp, #0]
   2d726:	f7fc f98f 	bl	29a48 <at_interface_write>
   2d72a:	4681      	mov	r9, r0
   2d72c:	4628      	mov	r0, r5
   2d72e:	f7ef fd13 	bl	1d158 <strlen>
   2d732:	4548      	cmp	r0, r9
   2d734:	f040 81e9 	bne.w	2db0a <pdn_interface_pdn_id_get+0x79e>
   2d738:	463b      	mov	r3, r7
   2d73a:	f44f 7280 	mov.w	r2, #256	; 0x100
   2d73e:	e9cd 7700 	strd	r7, r7, [sp]
   2d742:	4629      	mov	r1, r5
   2d744:	f8d8 0000 	ldr.w	r0, [r8]
   2d748:	f7fc fa82 	bl	29c50 <at_interface_read>
   2d74c:	4607      	mov	r7, r0
   2d74e:	48b0      	ldr	r0, [pc, #704]	; (2da10 <pdn_interface_pdn_id_get+0x6a4>)
   2d750:	f7ef fd02 	bl	1d158 <strlen>
   2d754:	4287      	cmp	r7, r0
   2d756:	4602      	mov	r2, r0
   2d758:	f2c0 81c7 	blt.w	2daea <pdn_interface_pdn_id_get+0x77e>
   2d75c:	4629      	mov	r1, r5
   2d75e:	48ac      	ldr	r0, [pc, #688]	; (2da10 <pdn_interface_pdn_id_get+0x6a4>)
   2d760:	f00c fc9e 	bl	3a0a0 <strncmp>
   2d764:	2800      	cmp	r0, #0
   2d766:	f040 81c0 	bne.w	2daea <pdn_interface_pdn_id_get+0x77e>
   2d76a:	4629      	mov	r1, r5
   2d76c:	4630      	mov	r0, r6
   2d76e:	f7ff f937 	bl	2c9e0 <pdn_id_get_parser>
   2d772:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   2d776:	6858      	ldr	r0, [r3, #4]
   2d778:	e643      	b.n	2d402 <pdn_interface_pdn_id_get+0x96>
   2d77a:	4628      	mov	r0, r5
   2d77c:	f7ef fcec 	bl	1d158 <strlen>
   2d780:	4606      	mov	r6, r0
   2d782:	6920      	ldr	r0, [r4, #16]
   2d784:	300c      	adds	r0, #12
   2d786:	f7ef fce7 	bl	1d158 <strlen>
   2d78a:	4286      	cmp	r6, r0
   2d78c:	f47f aeab 	bne.w	2d4e6 <pdn_interface_pdn_id_get+0x17a>
   2d790:	6921      	ldr	r1, [r4, #16]
   2d792:	4628      	mov	r0, r5
   2d794:	310c      	adds	r1, #12
   2d796:	f7ef fcd5 	bl	1d144 <strcmp>
   2d79a:	2800      	cmp	r0, #0
   2d79c:	f47f aea3 	bne.w	2d4e6 <pdn_interface_pdn_id_get+0x17a>
   2d7a0:	6923      	ldr	r3, [r4, #16]
   2d7a2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d7a4:	07d2      	lsls	r2, r2, #31
   2d7a6:	f57f ae9e 	bpl.w	2d4e6 <pdn_interface_pdn_id_get+0x17a>
   2d7aa:	2604      	movs	r6, #4
   2d7ac:	e799      	b.n	2d6e2 <pdn_interface_pdn_id_get+0x376>
   2d7ae:	4628      	mov	r0, r5
   2d7b0:	f7ef fcd2 	bl	1d158 <strlen>
   2d7b4:	4606      	mov	r6, r0
   2d7b6:	6960      	ldr	r0, [r4, #20]
   2d7b8:	300c      	adds	r0, #12
   2d7ba:	f7ef fccd 	bl	1d158 <strlen>
   2d7be:	4286      	cmp	r6, r0
   2d7c0:	f47f ae97 	bne.w	2d4f2 <pdn_interface_pdn_id_get+0x186>
   2d7c4:	6961      	ldr	r1, [r4, #20]
   2d7c6:	4628      	mov	r0, r5
   2d7c8:	310c      	adds	r1, #12
   2d7ca:	f7ef fcbb 	bl	1d144 <strcmp>
   2d7ce:	2800      	cmp	r0, #0
   2d7d0:	f47f ae8f 	bne.w	2d4f2 <pdn_interface_pdn_id_get+0x186>
   2d7d4:	6963      	ldr	r3, [r4, #20]
   2d7d6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d7d8:	07d7      	lsls	r7, r2, #31
   2d7da:	f57f ae8a 	bpl.w	2d4f2 <pdn_interface_pdn_id_get+0x186>
   2d7de:	2605      	movs	r6, #5
   2d7e0:	e77f      	b.n	2d6e2 <pdn_interface_pdn_id_get+0x376>
   2d7e2:	4628      	mov	r0, r5
   2d7e4:	f7ef fcb8 	bl	1d158 <strlen>
   2d7e8:	4606      	mov	r6, r0
   2d7ea:	69a0      	ldr	r0, [r4, #24]
   2d7ec:	300c      	adds	r0, #12
   2d7ee:	f7ef fcb3 	bl	1d158 <strlen>
   2d7f2:	4286      	cmp	r6, r0
   2d7f4:	f47f ae83 	bne.w	2d4fe <pdn_interface_pdn_id_get+0x192>
   2d7f8:	69a1      	ldr	r1, [r4, #24]
   2d7fa:	4628      	mov	r0, r5
   2d7fc:	310c      	adds	r1, #12
   2d7fe:	f7ef fca1 	bl	1d144 <strcmp>
   2d802:	2800      	cmp	r0, #0
   2d804:	f47f ae7b 	bne.w	2d4fe <pdn_interface_pdn_id_get+0x192>
   2d808:	69a3      	ldr	r3, [r4, #24]
   2d80a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d80c:	07d6      	lsls	r6, r2, #31
   2d80e:	f57f ae76 	bpl.w	2d4fe <pdn_interface_pdn_id_get+0x192>
   2d812:	2606      	movs	r6, #6
   2d814:	e765      	b.n	2d6e2 <pdn_interface_pdn_id_get+0x376>
   2d816:	4628      	mov	r0, r5
   2d818:	f7ef fc9e 	bl	1d158 <strlen>
   2d81c:	4607      	mov	r7, r0
   2d81e:	68e0      	ldr	r0, [r4, #12]
   2d820:	300c      	adds	r0, #12
   2d822:	f7ef fc99 	bl	1d158 <strlen>
   2d826:	4287      	cmp	r7, r0
   2d828:	f47f ae05 	bne.w	2d436 <pdn_interface_pdn_id_get+0xca>
   2d82c:	68e1      	ldr	r1, [r4, #12]
   2d82e:	4628      	mov	r0, r5
   2d830:	310c      	adds	r1, #12
   2d832:	f7ef fc87 	bl	1d144 <strcmp>
   2d836:	2800      	cmp	r0, #0
   2d838:	f47f adfd 	bne.w	2d436 <pdn_interface_pdn_id_get+0xca>
   2d83c:	68e3      	ldr	r3, [r4, #12]
   2d83e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d840:	0791      	lsls	r1, r2, #30
   2d842:	f53f af4e 	bmi.w	2d6e2 <pdn_interface_pdn_id_get+0x376>
   2d846:	e5f6      	b.n	2d436 <pdn_interface_pdn_id_get+0xca>
   2d848:	4628      	mov	r0, r5
   2d84a:	f7ef fc85 	bl	1d158 <strlen>
   2d84e:	4606      	mov	r6, r0
   2d850:	6920      	ldr	r0, [r4, #16]
   2d852:	300c      	adds	r0, #12
   2d854:	f7ef fc80 	bl	1d158 <strlen>
   2d858:	4286      	cmp	r6, r0
   2d85a:	f47f adf2 	bne.w	2d442 <pdn_interface_pdn_id_get+0xd6>
   2d85e:	6921      	ldr	r1, [r4, #16]
   2d860:	4628      	mov	r0, r5
   2d862:	310c      	adds	r1, #12
   2d864:	f7ef fc6e 	bl	1d144 <strcmp>
   2d868:	2800      	cmp	r0, #0
   2d86a:	f47f adea 	bne.w	2d442 <pdn_interface_pdn_id_get+0xd6>
   2d86e:	6923      	ldr	r3, [r4, #16]
   2d870:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d872:	0792      	lsls	r2, r2, #30
   2d874:	d499      	bmi.n	2d7aa <pdn_interface_pdn_id_get+0x43e>
   2d876:	e5e4      	b.n	2d442 <pdn_interface_pdn_id_get+0xd6>
   2d878:	4628      	mov	r0, r5
   2d87a:	f7ef fc6d 	bl	1d158 <strlen>
   2d87e:	4606      	mov	r6, r0
   2d880:	6960      	ldr	r0, [r4, #20]
   2d882:	300c      	adds	r0, #12
   2d884:	f7ef fc68 	bl	1d158 <strlen>
   2d888:	4286      	cmp	r6, r0
   2d88a:	f47f ade0 	bne.w	2d44e <pdn_interface_pdn_id_get+0xe2>
   2d88e:	6961      	ldr	r1, [r4, #20]
   2d890:	4628      	mov	r0, r5
   2d892:	310c      	adds	r1, #12
   2d894:	f7ef fc56 	bl	1d144 <strcmp>
   2d898:	2800      	cmp	r0, #0
   2d89a:	f47f add8 	bne.w	2d44e <pdn_interface_pdn_id_get+0xe2>
   2d89e:	6963      	ldr	r3, [r4, #20]
   2d8a0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d8a2:	0797      	lsls	r7, r2, #30
   2d8a4:	d49b      	bmi.n	2d7de <pdn_interface_pdn_id_get+0x472>
   2d8a6:	e5d2      	b.n	2d44e <pdn_interface_pdn_id_get+0xe2>
   2d8a8:	4628      	mov	r0, r5
   2d8aa:	f7ef fc55 	bl	1d158 <strlen>
   2d8ae:	4606      	mov	r6, r0
   2d8b0:	69a0      	ldr	r0, [r4, #24]
   2d8b2:	300c      	adds	r0, #12
   2d8b4:	f7ef fc50 	bl	1d158 <strlen>
   2d8b8:	4286      	cmp	r6, r0
   2d8ba:	f47f adce 	bne.w	2d45a <pdn_interface_pdn_id_get+0xee>
   2d8be:	69a1      	ldr	r1, [r4, #24]
   2d8c0:	4628      	mov	r0, r5
   2d8c2:	310c      	adds	r1, #12
   2d8c4:	f7ef fc3e 	bl	1d144 <strcmp>
   2d8c8:	2800      	cmp	r0, #0
   2d8ca:	f47f adc6 	bne.w	2d45a <pdn_interface_pdn_id_get+0xee>
   2d8ce:	69a3      	ldr	r3, [r4, #24]
   2d8d0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d8d2:	0796      	lsls	r6, r2, #30
   2d8d4:	d49d      	bmi.n	2d812 <pdn_interface_pdn_id_get+0x4a6>
   2d8d6:	e5c0      	b.n	2d45a <pdn_interface_pdn_id_get+0xee>
   2d8d8:	4628      	mov	r0, r5
   2d8da:	f7ef fc3d 	bl	1d158 <strlen>
   2d8de:	4606      	mov	r6, r0
   2d8e0:	69e0      	ldr	r0, [r4, #28]
   2d8e2:	300c      	adds	r0, #12
   2d8e4:	f7ef fc38 	bl	1d158 <strlen>
   2d8e8:	4286      	cmp	r6, r0
   2d8ea:	f47f adbc 	bne.w	2d466 <pdn_interface_pdn_id_get+0xfa>
   2d8ee:	69e1      	ldr	r1, [r4, #28]
   2d8f0:	4628      	mov	r0, r5
   2d8f2:	310c      	adds	r1, #12
   2d8f4:	f7ef fc26 	bl	1d144 <strcmp>
   2d8f8:	2800      	cmp	r0, #0
   2d8fa:	f47f adb4 	bne.w	2d466 <pdn_interface_pdn_id_get+0xfa>
   2d8fe:	69e3      	ldr	r3, [r4, #28]
   2d900:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d902:	0790      	lsls	r0, r2, #30
   2d904:	f57f adaf 	bpl.w	2d466 <pdn_interface_pdn_id_get+0xfa>
   2d908:	2607      	movs	r6, #7
   2d90a:	e6ea      	b.n	2d6e2 <pdn_interface_pdn_id_get+0x376>
   2d90c:	4628      	mov	r0, r5
   2d90e:	f7ef fc23 	bl	1d158 <strlen>
   2d912:	4606      	mov	r6, r0
   2d914:	6a20      	ldr	r0, [r4, #32]
   2d916:	300c      	adds	r0, #12
   2d918:	f7ef fc1e 	bl	1d158 <strlen>
   2d91c:	4286      	cmp	r6, r0
   2d91e:	f47f ada8 	bne.w	2d472 <pdn_interface_pdn_id_get+0x106>
   2d922:	6a21      	ldr	r1, [r4, #32]
   2d924:	4628      	mov	r0, r5
   2d926:	310c      	adds	r1, #12
   2d928:	f7ef fc0c 	bl	1d144 <strcmp>
   2d92c:	2800      	cmp	r0, #0
   2d92e:	f47f ada0 	bne.w	2d472 <pdn_interface_pdn_id_get+0x106>
   2d932:	6a23      	ldr	r3, [r4, #32]
   2d934:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d936:	0791      	lsls	r1, r2, #30
   2d938:	f57f ad9b 	bpl.w	2d472 <pdn_interface_pdn_id_get+0x106>
   2d93c:	2608      	movs	r6, #8
   2d93e:	e6d0      	b.n	2d6e2 <pdn_interface_pdn_id_get+0x376>
   2d940:	4628      	mov	r0, r5
   2d942:	f7ef fc09 	bl	1d158 <strlen>
   2d946:	4606      	mov	r6, r0
   2d948:	69e0      	ldr	r0, [r4, #28]
   2d94a:	300c      	adds	r0, #12
   2d94c:	f7ef fc04 	bl	1d158 <strlen>
   2d950:	4286      	cmp	r6, r0
   2d952:	f47f adda 	bne.w	2d50a <pdn_interface_pdn_id_get+0x19e>
   2d956:	69e1      	ldr	r1, [r4, #28]
   2d958:	4628      	mov	r0, r5
   2d95a:	310c      	adds	r1, #12
   2d95c:	f7ef fbf2 	bl	1d144 <strcmp>
   2d960:	2800      	cmp	r0, #0
   2d962:	f47f add2 	bne.w	2d50a <pdn_interface_pdn_id_get+0x19e>
   2d966:	69e3      	ldr	r3, [r4, #28]
   2d968:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d96a:	07d0      	lsls	r0, r2, #31
   2d96c:	d4cc      	bmi.n	2d908 <pdn_interface_pdn_id_get+0x59c>
   2d96e:	e5cc      	b.n	2d50a <pdn_interface_pdn_id_get+0x19e>
   2d970:	4628      	mov	r0, r5
   2d972:	f7ef fbf1 	bl	1d158 <strlen>
   2d976:	4606      	mov	r6, r0
   2d978:	6a20      	ldr	r0, [r4, #32]
   2d97a:	300c      	adds	r0, #12
   2d97c:	f7ef fbec 	bl	1d158 <strlen>
   2d980:	4286      	cmp	r6, r0
   2d982:	f47f adc8 	bne.w	2d516 <pdn_interface_pdn_id_get+0x1aa>
   2d986:	6a21      	ldr	r1, [r4, #32]
   2d988:	4628      	mov	r0, r5
   2d98a:	310c      	adds	r1, #12
   2d98c:	f7ef fbda 	bl	1d144 <strcmp>
   2d990:	2800      	cmp	r0, #0
   2d992:	f47f adc0 	bne.w	2d516 <pdn_interface_pdn_id_get+0x1aa>
   2d996:	6a23      	ldr	r3, [r4, #32]
   2d998:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d99a:	07d1      	lsls	r1, r2, #31
   2d99c:	d4ce      	bmi.n	2d93c <pdn_interface_pdn_id_get+0x5d0>
   2d99e:	e5ba      	b.n	2d516 <pdn_interface_pdn_id_get+0x1aa>
   2d9a0:	4628      	mov	r0, r5
   2d9a2:	f7ef fbd9 	bl	1d158 <strlen>
   2d9a6:	4606      	mov	r6, r0
   2d9a8:	68a0      	ldr	r0, [r4, #8]
   2d9aa:	300c      	adds	r0, #12
   2d9ac:	f7ef fbd4 	bl	1d158 <strlen>
   2d9b0:	4286      	cmp	r6, r0
   2d9b2:	f47f ad8c 	bne.w	2d4ce <pdn_interface_pdn_id_get+0x162>
   2d9b6:	68a1      	ldr	r1, [r4, #8]
   2d9b8:	4628      	mov	r0, r5
   2d9ba:	310c      	adds	r1, #12
   2d9bc:	f7ef fbc2 	bl	1d144 <strcmp>
   2d9c0:	2800      	cmp	r0, #0
   2d9c2:	f47f ad84 	bne.w	2d4ce <pdn_interface_pdn_id_get+0x162>
   2d9c6:	68a3      	ldr	r3, [r4, #8]
   2d9c8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d9ca:	07d0      	lsls	r0, r2, #31
   2d9cc:	f57f ad7f 	bpl.w	2d4ce <pdn_interface_pdn_id_get+0x162>
   2d9d0:	2602      	movs	r6, #2
   2d9d2:	e686      	b.n	2d6e2 <pdn_interface_pdn_id_get+0x376>
   2d9d4:	4628      	mov	r0, r5
   2d9d6:	f7ef fbbf 	bl	1d158 <strlen>
   2d9da:	4606      	mov	r6, r0
   2d9dc:	68a0      	ldr	r0, [r4, #8]
   2d9de:	300c      	adds	r0, #12
   2d9e0:	f7ef fbba 	bl	1d158 <strlen>
   2d9e4:	4286      	cmp	r6, r0
   2d9e6:	f47f ad20 	bne.w	2d42a <pdn_interface_pdn_id_get+0xbe>
   2d9ea:	68a1      	ldr	r1, [r4, #8]
   2d9ec:	4628      	mov	r0, r5
   2d9ee:	310c      	adds	r1, #12
   2d9f0:	f7ef fba8 	bl	1d144 <strcmp>
   2d9f4:	2800      	cmp	r0, #0
   2d9f6:	f47f ad18 	bne.w	2d42a <pdn_interface_pdn_id_get+0xbe>
   2d9fa:	68a3      	ldr	r3, [r4, #8]
   2d9fc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2d9fe:	0790      	lsls	r0, r2, #30
   2da00:	d4e6      	bmi.n	2d9d0 <pdn_interface_pdn_id_get+0x664>
   2da02:	e512      	b.n	2d42a <pdn_interface_pdn_id_get+0xbe>
   2da04:	20020bbc 	.word	0x20020bbc
   2da08:	0003b720 	.word	0x0003b720
   2da0c:	0003b71c 	.word	0x0003b71c
   2da10:	0003b730 	.word	0x0003b730
   2da14:	20020bb8 	.word	0x20020bb8
   2da18:	4628      	mov	r0, r5
   2da1a:	f7ef fb9d 	bl	1d158 <strlen>
   2da1e:	4606      	mov	r6, r0
   2da20:	6860      	ldr	r0, [r4, #4]
   2da22:	300c      	adds	r0, #12
   2da24:	f7ef fb98 	bl	1d158 <strlen>
   2da28:	4286      	cmp	r6, r0
   2da2a:	f47f acf8 	bne.w	2d41e <pdn_interface_pdn_id_get+0xb2>
   2da2e:	6861      	ldr	r1, [r4, #4]
   2da30:	4628      	mov	r0, r5
   2da32:	310c      	adds	r1, #12
   2da34:	f7ef fb86 	bl	1d144 <strcmp>
   2da38:	2800      	cmp	r0, #0
   2da3a:	f47f acf0 	bne.w	2d41e <pdn_interface_pdn_id_get+0xb2>
   2da3e:	6863      	ldr	r3, [r4, #4]
   2da40:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2da42:	0796      	lsls	r6, r2, #30
   2da44:	f57f aceb 	bpl.w	2d41e <pdn_interface_pdn_id_get+0xb2>
   2da48:	2601      	movs	r6, #1
   2da4a:	e64a      	b.n	2d6e2 <pdn_interface_pdn_id_get+0x376>
   2da4c:	4628      	mov	r0, r5
   2da4e:	f7ef fb83 	bl	1d158 <strlen>
   2da52:	4606      	mov	r6, r0
   2da54:	6860      	ldr	r0, [r4, #4]
   2da56:	300c      	adds	r0, #12
   2da58:	f7ef fb7e 	bl	1d158 <strlen>
   2da5c:	4286      	cmp	r6, r0
   2da5e:	f47f ad30 	bne.w	2d4c2 <pdn_interface_pdn_id_get+0x156>
   2da62:	6861      	ldr	r1, [r4, #4]
   2da64:	4628      	mov	r0, r5
   2da66:	310c      	adds	r1, #12
   2da68:	f7ef fb6c 	bl	1d144 <strcmp>
   2da6c:	2800      	cmp	r0, #0
   2da6e:	f47f ad28 	bne.w	2d4c2 <pdn_interface_pdn_id_get+0x156>
   2da72:	6863      	ldr	r3, [r4, #4]
   2da74:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2da76:	07d6      	lsls	r6, r2, #31
   2da78:	d4e6      	bmi.n	2da48 <pdn_interface_pdn_id_get+0x6dc>
   2da7a:	e522      	b.n	2d4c2 <pdn_interface_pdn_id_get+0x156>
   2da7c:	4608      	mov	r0, r1
   2da7e:	f7ef fb6b 	bl	1d158 <strlen>
   2da82:	4606      	mov	r6, r0
   2da84:	6820      	ldr	r0, [r4, #0]
   2da86:	300c      	adds	r0, #12
   2da88:	f7ef fb66 	bl	1d158 <strlen>
   2da8c:	4286      	cmp	r6, r0
   2da8e:	f47f acc0 	bne.w	2d412 <pdn_interface_pdn_id_get+0xa6>
   2da92:	6821      	ldr	r1, [r4, #0]
   2da94:	4628      	mov	r0, r5
   2da96:	310c      	adds	r1, #12
   2da98:	f7ef fb54 	bl	1d144 <strcmp>
   2da9c:	4606      	mov	r6, r0
   2da9e:	2800      	cmp	r0, #0
   2daa0:	f47f acb7 	bne.w	2d412 <pdn_interface_pdn_id_get+0xa6>
   2daa4:	6823      	ldr	r3, [r4, #0]
   2daa6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2daa8:	0797      	lsls	r7, r2, #30
   2daaa:	f53f ae1a 	bmi.w	2d6e2 <pdn_interface_pdn_id_get+0x376>
   2daae:	e4b0      	b.n	2d412 <pdn_interface_pdn_id_get+0xa6>
   2dab0:	4608      	mov	r0, r1
   2dab2:	f7ef fb51 	bl	1d158 <strlen>
   2dab6:	4606      	mov	r6, r0
   2dab8:	6820      	ldr	r0, [r4, #0]
   2daba:	300c      	adds	r0, #12
   2dabc:	f7ef fb4c 	bl	1d158 <strlen>
   2dac0:	4286      	cmp	r6, r0
   2dac2:	f47f acf8 	bne.w	2d4b6 <pdn_interface_pdn_id_get+0x14a>
   2dac6:	6821      	ldr	r1, [r4, #0]
   2dac8:	4628      	mov	r0, r5
   2daca:	310c      	adds	r1, #12
   2dacc:	f7ef fb3a 	bl	1d144 <strcmp>
   2dad0:	4606      	mov	r6, r0
   2dad2:	2800      	cmp	r0, #0
   2dad4:	f47f acef 	bne.w	2d4b6 <pdn_interface_pdn_id_get+0x14a>
   2dad8:	6823      	ldr	r3, [r4, #0]
   2dada:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2dadc:	07d7      	lsls	r7, r2, #31
   2dade:	f53f ae00 	bmi.w	2d6e2 <pdn_interface_pdn_id_get+0x376>
   2dae2:	e4e8      	b.n	2d4b6 <pdn_interface_pdn_id_get+0x14a>
   2dae4:	f04f 30ff 	mov.w	r0, #4294967295
   2dae8:	4770      	bx	lr
   2daea:	480b      	ldr	r0, [pc, #44]	; (2db18 <pdn_interface_pdn_id_get+0x7ac>)
   2daec:	f7ef fb34 	bl	1d158 <strlen>
   2daf0:	490a      	ldr	r1, [pc, #40]	; (2db1c <pdn_interface_pdn_id_get+0x7b0>)
   2daf2:	4602      	mov	r2, r0
   2daf4:	4808      	ldr	r0, [pc, #32]	; (2db18 <pdn_interface_pdn_id_get+0x7ac>)
   2daf6:	f00c fad3 	bl	3a0a0 <strncmp>
   2dafa:	b930      	cbnz	r0, 2db0a <pdn_interface_pdn_id_get+0x79e>
   2dafc:	2008      	movs	r0, #8
   2dafe:	f7f9 ffaf 	bl	27a60 <bsd_os_errno_set>
   2db02:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   2db06:	6858      	ldr	r0, [r3, #4]
   2db08:	e47b      	b.n	2d402 <pdn_interface_pdn_id_get+0x96>
   2db0a:	2005      	movs	r0, #5
   2db0c:	f7f9 ffa8 	bl	27a60 <bsd_os_errno_set>
   2db10:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   2db14:	6858      	ldr	r0, [r3, #4]
   2db16:	e474      	b.n	2d402 <pdn_interface_pdn_id_get+0x96>
   2db18:	0003b774 	.word	0x0003b774
   2db1c:	20020bbc 	.word	0x20020bbc

0002db20 <linked_list_init>:
   2db20:	b128      	cbz	r0, 2db2e <linked_list_init+0xe>
   2db22:	2300      	movs	r3, #0
   2db24:	6003      	str	r3, [r0, #0]
   2db26:	e9c0 3301 	strd	r3, r3, [r0, #4]
   2db2a:	4618      	mov	r0, r3
   2db2c:	4770      	bx	lr
   2db2e:	2007      	movs	r0, #7
   2db30:	4770      	bx	lr
   2db32:	bf00      	nop

0002db34 <linked_list_push>:
   2db34:	6802      	ldr	r2, [r0, #0]
   2db36:	4603      	mov	r3, r0
   2db38:	3201      	adds	r2, #1
   2db3a:	d00e      	beq.n	2db5a <linked_list_push+0x26>
   2db3c:	2200      	movs	r2, #0
   2db3e:	600a      	str	r2, [r1, #0]
   2db40:	6802      	ldr	r2, [r0, #0]
   2db42:	b13a      	cbz	r2, 2db54 <linked_list_push+0x20>
   2db44:	6882      	ldr	r2, [r0, #8]
   2db46:	6011      	str	r1, [r2, #0]
   2db48:	6081      	str	r1, [r0, #8]
   2db4a:	681a      	ldr	r2, [r3, #0]
   2db4c:	2000      	movs	r0, #0
   2db4e:	3201      	adds	r2, #1
   2db50:	601a      	str	r2, [r3, #0]
   2db52:	4770      	bx	lr
   2db54:	e9c0 1101 	strd	r1, r1, [r0, #4]
   2db58:	e7f7      	b.n	2db4a <linked_list_push+0x16>
   2db5a:	2004      	movs	r0, #4
   2db5c:	4770      	bx	lr
   2db5e:	bf00      	nop

0002db60 <linked_list_pop>:
   2db60:	4603      	mov	r3, r0
   2db62:	6800      	ldr	r0, [r0, #0]
   2db64:	b128      	cbz	r0, 2db72 <linked_list_pop+0x12>
   2db66:	6858      	ldr	r0, [r3, #4]
   2db68:	681a      	ldr	r2, [r3, #0]
   2db6a:	6801      	ldr	r1, [r0, #0]
   2db6c:	3a01      	subs	r2, #1
   2db6e:	6059      	str	r1, [r3, #4]
   2db70:	601a      	str	r2, [r3, #0]
   2db72:	4770      	bx	lr

0002db74 <linked_list_peek>:
   2db74:	6803      	ldr	r3, [r0, #0]
   2db76:	b10b      	cbz	r3, 2db7c <linked_list_peek+0x8>
   2db78:	6840      	ldr	r0, [r0, #4]
   2db7a:	4770      	bx	lr
   2db7c:	4618      	mov	r0, r3
   2db7e:	4770      	bx	lr

0002db80 <linked_list_size_get>:
   2db80:	6800      	ldr	r0, [r0, #0]
   2db82:	4770      	bx	lr

0002db84 <linked_list_get_next>:
   2db84:	6800      	ldr	r0, [r0, #0]
   2db86:	4770      	bx	lr

0002db88 <nrf_socket>:
   2db88:	b570      	push	{r4, r5, r6, lr}
   2db8a:	4604      	mov	r4, r0
   2db8c:	460d      	mov	r5, r1
   2db8e:	4616      	mov	r6, r2
   2db90:	f7fd fdb4 	bl	2b6fc <bsd_platform_af_method_table_get>
   2db94:	b130      	cbz	r0, 2dba4 <nrf_socket+0x1c>
   2db96:	6803      	ldr	r3, [r0, #0]
   2db98:	4632      	mov	r2, r6
   2db9a:	4629      	mov	r1, r5
   2db9c:	4620      	mov	r0, r4
   2db9e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   2dba2:	4718      	bx	r3
   2dba4:	f04f 30ff 	mov.w	r0, #4294967295
   2dba8:	bd70      	pop	{r4, r5, r6, pc}
   2dbaa:	bf00      	nop

0002dbac <nrf_close>:
   2dbac:	b510      	push	{r4, lr}
   2dbae:	4604      	mov	r4, r0
   2dbb0:	f7fd fdfc 	bl	2b7ac <bsd_platform_fd_method_table_get>
   2dbb4:	b120      	cbz	r0, 2dbc0 <nrf_close+0x14>
   2dbb6:	6843      	ldr	r3, [r0, #4]
   2dbb8:	4620      	mov	r0, r4
   2dbba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2dbbe:	4718      	bx	r3
   2dbc0:	f04f 30ff 	mov.w	r0, #4294967295
   2dbc4:	bd10      	pop	{r4, pc}
   2dbc6:	bf00      	nop

0002dbc8 <nrf_sendto>:
   2dbc8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2dbcc:	460d      	mov	r5, r1
   2dbce:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   2dbd2:	4616      	mov	r6, r2
   2dbd4:	461f      	mov	r7, r3
   2dbd6:	4604      	mov	r4, r0
   2dbd8:	f7fd fde8 	bl	2b7ac <bsd_platform_fd_method_table_get>
   2dbdc:	b158      	cbz	r0, 2dbf6 <nrf_sendto+0x2e>
   2dbde:	e9cd 8908 	strd	r8, r9, [sp, #32]
   2dbe2:	f8d0 e008 	ldr.w	lr, [r0, #8]
   2dbe6:	463b      	mov	r3, r7
   2dbe8:	4632      	mov	r2, r6
   2dbea:	4629      	mov	r1, r5
   2dbec:	4620      	mov	r0, r4
   2dbee:	46f4      	mov	ip, lr
   2dbf0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2dbf4:	4760      	bx	ip
   2dbf6:	f04f 30ff 	mov.w	r0, #4294967295
   2dbfa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2dbfe:	bf00      	nop

0002dc00 <nrf_send>:
   2dc00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2dc04:	b082      	sub	sp, #8
   2dc06:	460e      	mov	r6, r1
   2dc08:	4617      	mov	r7, r2
   2dc0a:	4698      	mov	r8, r3
   2dc0c:	4605      	mov	r5, r0
   2dc0e:	f7fd fdcd 	bl	2b7ac <bsd_platform_fd_method_table_get>
   2dc12:	b160      	cbz	r0, 2dc2e <nrf_send+0x2e>
   2dc14:	4604      	mov	r4, r0
   2dc16:	2000      	movs	r0, #0
   2dc18:	e9cd 0000 	strd	r0, r0, [sp]
   2dc1c:	4643      	mov	r3, r8
   2dc1e:	463a      	mov	r2, r7
   2dc20:	4631      	mov	r1, r6
   2dc22:	4628      	mov	r0, r5
   2dc24:	68a4      	ldr	r4, [r4, #8]
   2dc26:	47a0      	blx	r4
   2dc28:	b002      	add	sp, #8
   2dc2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2dc2e:	f04f 30ff 	mov.w	r0, #4294967295
   2dc32:	e7f9      	b.n	2dc28 <nrf_send+0x28>

0002dc34 <nrf_recvfrom>:
   2dc34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2dc38:	460d      	mov	r5, r1
   2dc3a:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   2dc3e:	4616      	mov	r6, r2
   2dc40:	461f      	mov	r7, r3
   2dc42:	4604      	mov	r4, r0
   2dc44:	f7fd fdb2 	bl	2b7ac <bsd_platform_fd_method_table_get>
   2dc48:	b158      	cbz	r0, 2dc62 <nrf_recvfrom+0x2e>
   2dc4a:	e9cd 8908 	strd	r8, r9, [sp, #32]
   2dc4e:	f8d0 e00c 	ldr.w	lr, [r0, #12]
   2dc52:	463b      	mov	r3, r7
   2dc54:	4632      	mov	r2, r6
   2dc56:	4629      	mov	r1, r5
   2dc58:	4620      	mov	r0, r4
   2dc5a:	46f4      	mov	ip, lr
   2dc5c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2dc60:	4760      	bx	ip
   2dc62:	f04f 30ff 	mov.w	r0, #4294967295
   2dc66:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2dc6a:	bf00      	nop

0002dc6c <nrf_recv>:
   2dc6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2dc70:	b082      	sub	sp, #8
   2dc72:	460e      	mov	r6, r1
   2dc74:	4617      	mov	r7, r2
   2dc76:	4698      	mov	r8, r3
   2dc78:	4605      	mov	r5, r0
   2dc7a:	f7fd fd97 	bl	2b7ac <bsd_platform_fd_method_table_get>
   2dc7e:	b160      	cbz	r0, 2dc9a <nrf_recv+0x2e>
   2dc80:	4604      	mov	r4, r0
   2dc82:	2000      	movs	r0, #0
   2dc84:	e9cd 0000 	strd	r0, r0, [sp]
   2dc88:	4643      	mov	r3, r8
   2dc8a:	463a      	mov	r2, r7
   2dc8c:	4631      	mov	r1, r6
   2dc8e:	4628      	mov	r0, r5
   2dc90:	68e4      	ldr	r4, [r4, #12]
   2dc92:	47a0      	blx	r4
   2dc94:	b002      	add	sp, #8
   2dc96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2dc9a:	f04f 30ff 	mov.w	r0, #4294967295
   2dc9e:	e7f9      	b.n	2dc94 <nrf_recv+0x28>

0002dca0 <nrf_connect>:
   2dca0:	b570      	push	{r4, r5, r6, lr}
   2dca2:	460d      	mov	r5, r1
   2dca4:	4616      	mov	r6, r2
   2dca6:	4604      	mov	r4, r0
   2dca8:	f7fd fd80 	bl	2b7ac <bsd_platform_fd_method_table_get>
   2dcac:	b130      	cbz	r0, 2dcbc <nrf_connect+0x1c>
   2dcae:	6943      	ldr	r3, [r0, #20]
   2dcb0:	4632      	mov	r2, r6
   2dcb2:	4629      	mov	r1, r5
   2dcb4:	4620      	mov	r0, r4
   2dcb6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   2dcba:	4718      	bx	r3
   2dcbc:	f04f 30ff 	mov.w	r0, #4294967295
   2dcc0:	bd70      	pop	{r4, r5, r6, pc}
   2dcc2:	bf00      	nop

0002dcc4 <nrf_listen>:
   2dcc4:	b570      	push	{r4, r5, r6, lr}
   2dcc6:	460d      	mov	r5, r1
   2dcc8:	4604      	mov	r4, r0
   2dcca:	f7fd fd6f 	bl	2b7ac <bsd_platform_fd_method_table_get>
   2dcce:	b128      	cbz	r0, 2dcdc <nrf_listen+0x18>
   2dcd0:	6983      	ldr	r3, [r0, #24]
   2dcd2:	4629      	mov	r1, r5
   2dcd4:	4620      	mov	r0, r4
   2dcd6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   2dcda:	4718      	bx	r3
   2dcdc:	f04f 30ff 	mov.w	r0, #4294967295
   2dce0:	bd70      	pop	{r4, r5, r6, pc}
   2dce2:	bf00      	nop

0002dce4 <nrf_accept>:
   2dce4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2dce8:	460d      	mov	r5, r1
   2dcea:	4616      	mov	r6, r2
   2dcec:	4604      	mov	r4, r0
   2dcee:	f7fd fd5d 	bl	2b7ac <bsd_platform_fd_method_table_get>
   2dcf2:	b140      	cbz	r0, 2dd06 <nrf_accept+0x22>
   2dcf4:	69c7      	ldr	r7, [r0, #28]
   2dcf6:	4632      	mov	r2, r6
   2dcf8:	4629      	mov	r1, r5
   2dcfa:	4620      	mov	r0, r4
   2dcfc:	46bc      	mov	ip, r7
   2dcfe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   2dd02:	2300      	movs	r3, #0
   2dd04:	4760      	bx	ip
   2dd06:	f04f 30ff 	mov.w	r0, #4294967295
   2dd0a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2dd0e:	bf00      	nop

0002dd10 <nrf_bind>:
   2dd10:	b570      	push	{r4, r5, r6, lr}
   2dd12:	460d      	mov	r5, r1
   2dd14:	4616      	mov	r6, r2
   2dd16:	4604      	mov	r4, r0
   2dd18:	f7fd fd48 	bl	2b7ac <bsd_platform_fd_method_table_get>
   2dd1c:	b130      	cbz	r0, 2dd2c <nrf_bind+0x1c>
   2dd1e:	6903      	ldr	r3, [r0, #16]
   2dd20:	4632      	mov	r2, r6
   2dd22:	4629      	mov	r1, r5
   2dd24:	4620      	mov	r0, r4
   2dd26:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   2dd2a:	4718      	bx	r3
   2dd2c:	f04f 30ff 	mov.w	r0, #4294967295
   2dd30:	bd70      	pop	{r4, r5, r6, pc}
   2dd32:	bf00      	nop

0002dd34 <nrf_setsockopt>:
   2dd34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2dd38:	f8dd 8018 	ldr.w	r8, [sp, #24]
   2dd3c:	460d      	mov	r5, r1
   2dd3e:	4616      	mov	r6, r2
   2dd40:	461f      	mov	r7, r3
   2dd42:	4604      	mov	r4, r0
   2dd44:	f7fd fd32 	bl	2b7ac <bsd_platform_fd_method_table_get>
   2dd48:	b158      	cbz	r0, 2dd62 <nrf_setsockopt+0x2e>
   2dd4a:	f8cd 8018 	str.w	r8, [sp, #24]
   2dd4e:	f8d0 e020 	ldr.w	lr, [r0, #32]
   2dd52:	463b      	mov	r3, r7
   2dd54:	4632      	mov	r2, r6
   2dd56:	4629      	mov	r1, r5
   2dd58:	4620      	mov	r0, r4
   2dd5a:	46f4      	mov	ip, lr
   2dd5c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   2dd60:	4760      	bx	ip
   2dd62:	f04f 30ff 	mov.w	r0, #4294967295
   2dd66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2dd6a:	bf00      	nop

0002dd6c <nrf_getsockopt>:
   2dd6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2dd70:	f8dd 8018 	ldr.w	r8, [sp, #24]
   2dd74:	460d      	mov	r5, r1
   2dd76:	4616      	mov	r6, r2
   2dd78:	461f      	mov	r7, r3
   2dd7a:	4604      	mov	r4, r0
   2dd7c:	f7fd fd16 	bl	2b7ac <bsd_platform_fd_method_table_get>
   2dd80:	b158      	cbz	r0, 2dd9a <nrf_getsockopt+0x2e>
   2dd82:	f8cd 8018 	str.w	r8, [sp, #24]
   2dd86:	f8d0 e024 	ldr.w	lr, [r0, #36]	; 0x24
   2dd8a:	463b      	mov	r3, r7
   2dd8c:	4632      	mov	r2, r6
   2dd8e:	4629      	mov	r1, r5
   2dd90:	4620      	mov	r0, r4
   2dd92:	46f4      	mov	ip, lr
   2dd94:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   2dd98:	4760      	bx	ip
   2dd9a:	f04f 30ff 	mov.w	r0, #4294967295
   2dd9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2dda2:	bf00      	nop

0002dda4 <nrf_getaddrinfo>:
   2dda4:	f7fd bd78 	b.w	2b898 <bsd_platform_getaddrinfo>

0002dda8 <nrf_freeaddrinfo>:
   2dda8:	f7fd bd78 	b.w	2b89c <bsd_platform_freeaddrinfo>

0002ddac <nrf_poll>:
   2ddac:	f7fd bd78 	b.w	2b8a0 <bsd_platform_poll>

0002ddb0 <nrf_fcntl>:
   2ddb0:	f7fd bdd0 	b.w	2b954 <bsd_platform_fcntl>

0002ddb4 <at_client_evt_handler>:
   2ddb4:	b120      	cbz	r0, 2ddc0 <at_client_evt_handler+0xc>
   2ddb6:	f850 1b08 	ldr.w	r1, [r0], #8
   2ddba:	0c09      	lsrs	r1, r1, #16
   2ddbc:	f7fb bfa0 	b.w	29d00 <rpc_at_event_handler>
   2ddc0:	4770      	bx	lr
   2ddc2:	bf00      	nop

0002ddc4 <rpc_at_client_init>:
   2ddc4:	4801      	ldr	r0, [pc, #4]	; (2ddcc <rpc_at_client_init+0x8>)
   2ddc6:	f001 be47 	b.w	2fa58 <rpc_client_register>
   2ddca:	bf00      	nop
   2ddcc:	0003b788 	.word	0x0003b788

0002ddd0 <rpc_at_client_request_alloc>:
   2ddd0:	b180      	cbz	r0, 2ddf4 <rpc_at_client_request_alloc+0x24>
   2ddd2:	2300      	movs	r3, #0
   2ddd4:	b510      	push	{r4, lr}
   2ddd6:	b082      	sub	sp, #8
   2ddd8:	aa02      	add	r2, sp, #8
   2ddda:	4604      	mov	r4, r0
   2dddc:	f842 3d04 	str.w	r3, [r2, #-4]!
   2dde0:	2003      	movs	r0, #3
   2dde2:	f002 f871 	bl	2fec8 <rpc_message_alloc>
   2dde6:	b918      	cbnz	r0, 2ddf0 <rpc_at_client_request_alloc+0x20>
   2dde8:	9b01      	ldr	r3, [sp, #4]
   2ddea:	b10b      	cbz	r3, 2ddf0 <rpc_at_client_request_alloc+0x20>
   2ddec:	3308      	adds	r3, #8
   2ddee:	6023      	str	r3, [r4, #0]
   2ddf0:	b002      	add	sp, #8
   2ddf2:	bd10      	pop	{r4, pc}
   2ddf4:	200e      	movs	r0, #14
   2ddf6:	4770      	bx	lr

0002ddf8 <rpc_at_client_request_send>:
   2ddf8:	b150      	cbz	r0, 2de10 <rpc_at_client_request_send+0x18>
   2ddfa:	4603      	mov	r3, r0
   2ddfc:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   2de00:	2003      	movs	r0, #3
   2de02:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   2de06:	f843 1d08 	str.w	r1, [r3, #-8]!
   2de0a:	4619      	mov	r1, r3
   2de0c:	f002 b844 	b.w	2fe98 <rpc_message_send>
   2de10:	200e      	movs	r0, #14
   2de12:	4770      	bx	lr

0002de14 <rpc_at_client_message_free>:
   2de14:	b120      	cbz	r0, 2de20 <rpc_at_client_message_free+0xc>
   2de16:	f1a0 0108 	sub.w	r1, r0, #8
   2de1a:	2003      	movs	r0, #3
   2de1c:	f002 b886 	b.w	2ff2c <rpc_message_free>
   2de20:	200e      	movs	r0, #14
   2de22:	4770      	bx	lr

0002de24 <rpc_at_client_data_free>:
   2de24:	b118      	cbz	r0, 2de2e <rpc_at_client_data_free+0xa>
   2de26:	4601      	mov	r1, r0
   2de28:	2003      	movs	r0, #3
   2de2a:	f002 b991 	b.w	30150 <rpc_message_data_free>
   2de2e:	200e      	movs	r0, #14
   2de30:	4770      	bx	lr
   2de32:	bf00      	nop

0002de34 <ip_recvd_packet_free_cb>:
   2de34:	b510      	push	{r4, lr}
   2de36:	4604      	mov	r4, r0
   2de38:	6800      	ldr	r0, [r0, #0]
   2de3a:	f7fc fc1f 	bl	2a67c <rpc_ip_client_data_free>
   2de3e:	68a0      	ldr	r0, [r4, #8]
   2de40:	b118      	cbz	r0, 2de4a <ip_recvd_packet_free_cb+0x16>
   2de42:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2de46:	f7fc bbb9 	b.w	2a5bc <nrf_free>
   2de4a:	bd10      	pop	{r4, pc}

0002de4c <rpc_error_to_nrf_bsd_error>:
   2de4c:	2810      	cmp	r0, #16
   2de4e:	bf9a      	itte	ls
   2de50:	4b02      	ldrls	r3, [pc, #8]	; (2de5c <rpc_error_to_nrf_bsd_error+0x10>)
   2de52:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
   2de56:	202d      	movhi	r0, #45	; 0x2d
   2de58:	4770      	bx	lr
   2de5a:	bf00      	nop
   2de5c:	0003b798 	.word	0x0003b798

0002de60 <ip_interface_request_create>:
   2de60:	b570      	push	{r4, r5, r6, lr}
   2de62:	2500      	movs	r5, #0
   2de64:	b082      	sub	sp, #8
   2de66:	ac02      	add	r4, sp, #8
   2de68:	f844 5d04 	str.w	r5, [r4, #-4]!
   2de6c:	4606      	mov	r6, r0
   2de6e:	460d      	mov	r5, r1
   2de70:	4620      	mov	r0, r4
   2de72:	4619      	mov	r1, r3
   2de74:	4614      	mov	r4, r2
   2de76:	f7fc fbcf 	bl	2a618 <rpc_ip_client_request_alloc>
   2de7a:	b960      	cbnz	r0, 2de96 <ip_interface_request_create+0x36>
   2de7c:	9b01      	ldr	r3, [sp, #4]
   2de7e:	2208      	movs	r2, #8
   2de80:	7258      	strb	r0, [r3, #9]
   2de82:	7298      	strb	r0, [r3, #10]
   2de84:	72d8      	strb	r0, [r3, #11]
   2de86:	4618      	mov	r0, r3
   2de88:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
   2de8c:	60dc      	str	r4, [r3, #12]
   2de8e:	611d      	str	r5, [r3, #16]
   2de90:	721a      	strb	r2, [r3, #8]
   2de92:	b002      	add	sp, #8
   2de94:	bd70      	pop	{r4, r5, r6, pc}
   2de96:	9b01      	ldr	r3, [sp, #4]
   2de98:	4618      	mov	r0, r3
   2de9a:	b002      	add	sp, #8
   2de9c:	bd70      	pop	{r4, r5, r6, pc}
   2de9e:	bf00      	nop

0002dea0 <ip_interface_request_send>:
   2dea0:	b570      	push	{r4, r5, r6, lr}
   2dea2:	460c      	mov	r4, r1
   2dea4:	4605      	mov	r5, r0
   2dea6:	4611      	mov	r1, r2
   2dea8:	4620      	mov	r0, r4
   2deaa:	461e      	mov	r6, r3
   2deac:	f7fc fbc8 	bl	2a640 <rpc_ip_client_request_send>
   2deb0:	b900      	cbnz	r0, 2deb4 <ip_interface_request_send+0x14>
   2deb2:	bd70      	pop	{r4, r5, r6, pc}
   2deb4:	6820      	ldr	r0, [r4, #0]
   2deb6:	b108      	cbz	r0, 2debc <ip_interface_request_send+0x1c>
   2deb8:	f7fc fbe0 	bl	2a67c <rpc_ip_client_data_free>
   2debc:	4620      	mov	r0, r4
   2debe:	f7fc fbd5 	bl	2a66c <rpc_ip_client_message_free>
   2dec2:	602e      	str	r6, [r5, #0]
   2dec4:	2023      	movs	r0, #35	; 0x23
   2dec6:	bd70      	pop	{r4, r5, r6, pc}

0002dec8 <ip_interface_wait>:
   2dec8:	b538      	push	{r3, r4, r5, lr}
   2deca:	4605      	mov	r5, r0
   2decc:	f001 fc14 	bl	2f6f8 <interface_socket_wait>
   2ded0:	4604      	mov	r4, r0
   2ded2:	b108      	cbz	r0, 2ded8 <ip_interface_wait+0x10>
   2ded4:	4620      	mov	r0, r4
   2ded6:	bd38      	pop	{r3, r4, r5, pc}
   2ded8:	4628      	mov	r0, r5
   2deda:	f001 fc81 	bl	2f7e0 <interface_socket_from_handle_get>
   2dede:	2800      	cmp	r0, #0
   2dee0:	d0f8      	beq.n	2ded4 <ip_interface_wait+0xc>
   2dee2:	6844      	ldr	r4, [r0, #4]
   2dee4:	2c00      	cmp	r4, #0
   2dee6:	d0f5      	beq.n	2ded4 <ip_interface_wait+0xc>
   2dee8:	2300      	movs	r3, #0
   2deea:	6043      	str	r3, [r0, #4]
   2deec:	4620      	mov	r0, r4
   2deee:	bd38      	pop	{r3, r4, r5, pc}

0002def0 <ip_interface_init>:
   2def0:	b538      	push	{r3, r4, r5, lr}
   2def2:	2300      	movs	r3, #0
   2def4:	4d07      	ldr	r5, [pc, #28]	; (2df14 <ip_interface_init+0x24>)
   2def6:	4c08      	ldr	r4, [pc, #32]	; (2df18 <ip_interface_init+0x28>)
   2def8:	4619      	mov	r1, r3
   2defa:	2224      	movs	r2, #36	; 0x24
   2defc:	4807      	ldr	r0, [pc, #28]	; (2df1c <ip_interface_init+0x2c>)
   2defe:	602b      	str	r3, [r5, #0]
   2df00:	6023      	str	r3, [r4, #0]
   2df02:	f00b ff5c 	bl	39dbe <memset>
   2df06:	f7fc fb81 	bl	2a60c <rpc_ip_client_init>
   2df0a:	3000      	adds	r0, #0
   2df0c:	bf18      	it	ne
   2df0e:	2001      	movne	r0, #1
   2df10:	4240      	negs	r0, r0
   2df12:	bd38      	pop	{r3, r4, r5, pc}
   2df14:	20020cf4 	.word	0x20020cf4
   2df18:	20020cf0 	.word	0x20020cf0
   2df1c:	20020cfc 	.word	0x20020cfc

0002df20 <ip_interface_open>:
   2df20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2df24:	4606      	mov	r6, r0
   2df26:	2000      	movs	r0, #0
   2df28:	f026 0308 	bic.w	r3, r6, #8
   2df2c:	b082      	sub	sp, #8
   2df2e:	2b02      	cmp	r3, #2
   2df30:	460c      	mov	r4, r1
   2df32:	4617      	mov	r7, r2
   2df34:	9000      	str	r0, [sp, #0]
   2df36:	d002      	beq.n	2df3e <ip_interface_open+0x1e>
   2df38:	2e05      	cmp	r6, #5
   2df3a:	f040 8085 	bne.w	2e048 <ip_interface_open+0x128>
   2df3e:	1e63      	subs	r3, r4, #1
   2df40:	2b02      	cmp	r3, #2
   2df42:	f200 8097 	bhi.w	2e074 <ip_interface_open+0x154>
   2df46:	2f00      	cmp	r7, #0
   2df48:	d154      	bne.n	2dff4 <ip_interface_open+0xd4>
   2df4a:	2c01      	cmp	r4, #1
   2df4c:	d067      	beq.n	2e01e <ip_interface_open+0xfe>
   2df4e:	2c03      	cmp	r4, #3
   2df50:	bf18      	it	ne
   2df52:	2702      	movne	r7, #2
   2df54:	4a4a      	ldr	r2, [pc, #296]	; (2e080 <ip_interface_open+0x160>)
   2df56:	4621      	mov	r1, r4
   2df58:	4668      	mov	r0, sp
   2df5a:	f001 fb1b 	bl	2f594 <interface_socket_allocate>
   2df5e:	9b00      	ldr	r3, [sp, #0]
   2df60:	4680      	mov	r8, r0
   2df62:	2b00      	cmp	r3, #0
   2df64:	d059      	beq.n	2e01a <ip_interface_open+0xfa>
   2df66:	2100      	movs	r1, #0
   2df68:	a802      	add	r0, sp, #8
   2df6a:	f840 1d04 	str.w	r1, [r0, #-4]!
   2df6e:	e9c3 6403 	strd	r6, r4, [r3, #12]
   2df72:	615f      	str	r7, [r3, #20]
   2df74:	f7fc fb50 	bl	2a618 <rpc_ip_client_request_alloc>
   2df78:	2800      	cmp	r0, #0
   2df7a:	d14b      	bne.n	2e014 <ip_interface_open+0xf4>
   2df7c:	f247 0201 	movw	r2, #28673	; 0x7001
   2df80:	f04f 33ff 	mov.w	r3, #4294967295
   2df84:	2108      	movs	r1, #8
   2df86:	9d01      	ldr	r5, [sp, #4]
   2df88:	ea42 4208 	orr.w	r2, r2, r8, lsl #16
   2df8c:	60ea      	str	r2, [r5, #12]
   2df8e:	7268      	strb	r0, [r5, #9]
   2df90:	72a8      	strb	r0, [r5, #10]
   2df92:	72e8      	strb	r0, [r5, #11]
   2df94:	7229      	strb	r1, [r5, #8]
   2df96:	742b      	strb	r3, [r5, #16]
   2df98:	746b      	strb	r3, [r5, #17]
   2df9a:	74ab      	strb	r3, [r5, #18]
   2df9c:	74eb      	strb	r3, [r5, #19]
   2df9e:	68ab      	ldr	r3, [r5, #8]
   2dfa0:	2e05      	cmp	r6, #5
   2dfa2:	f103 030c 	add.w	r3, r3, #12
   2dfa6:	60ab      	str	r3, [r5, #8]
   2dfa8:	d003      	beq.n	2dfb2 <ip_interface_open+0x92>
   2dfaa:	2e0a      	cmp	r6, #10
   2dfac:	bf14      	ite	ne
   2dfae:	2601      	movne	r6, #1
   2dfb0:	2602      	moveq	r6, #2
   2dfb2:	616e      	str	r6, [r5, #20]
   2dfb4:	61ef      	str	r7, [r5, #28]
   2dfb6:	61ac      	str	r4, [r5, #24]
   2dfb8:	f247 0101 	movw	r1, #28673	; 0x7001
   2dfbc:	4628      	mov	r0, r5
   2dfbe:	9f00      	ldr	r7, [sp, #0]
   2dfc0:	f7fc fb3e 	bl	2a640 <rpc_ip_client_request_send>
   2dfc4:	4606      	mov	r6, r0
   2dfc6:	b360      	cbz	r0, 2e022 <ip_interface_open+0x102>
   2dfc8:	6828      	ldr	r0, [r5, #0]
   2dfca:	b108      	cbz	r0, 2dfd0 <ip_interface_open+0xb0>
   2dfcc:	f7fc fb56 	bl	2a67c <rpc_ip_client_data_free>
   2dfd0:	4628      	mov	r0, r5
   2dfd2:	f7fc fb4b 	bl	2a66c <rpc_ip_client_message_free>
   2dfd6:	2301      	movs	r3, #1
   2dfd8:	2523      	movs	r5, #35	; 0x23
   2dfda:	603b      	str	r3, [r7, #0]
   2dfdc:	4640      	mov	r0, r8
   2dfde:	f001 fb3d 	bl	2f65c <interface_socket_free>
   2dfe2:	4628      	mov	r0, r5
   2dfe4:	f7f9 fd3c 	bl	27a60 <bsd_os_errno_set>
   2dfe8:	f04f 38ff 	mov.w	r8, #4294967295
   2dfec:	4640      	mov	r0, r8
   2dfee:	b002      	add	sp, #8
   2dff0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2dff4:	2c01      	cmp	r4, #1
   2dff6:	d009      	beq.n	2e00c <ip_interface_open+0xec>
   2dff8:	2c02      	cmp	r4, #2
   2dffa:	d109      	bne.n	2e010 <ip_interface_open+0xf0>
   2dffc:	2f02      	cmp	r7, #2
   2dffe:	d0a9      	beq.n	2df54 <ip_interface_open+0x34>
   2e000:	2029      	movs	r0, #41	; 0x29
   2e002:	f7f9 fd2d 	bl	27a60 <bsd_os_errno_set>
   2e006:	f04f 38ff 	mov.w	r8, #4294967295
   2e00a:	e7ef      	b.n	2dfec <ip_interface_open+0xcc>
   2e00c:	2f01      	cmp	r7, #1
   2e00e:	d1f7      	bne.n	2e000 <ip_interface_open+0xe0>
   2e010:	2702      	movs	r7, #2
   2e012:	e79f      	b.n	2df54 <ip_interface_open+0x34>
   2e014:	9d01      	ldr	r5, [sp, #4]
   2e016:	2d00      	cmp	r5, #0
   2e018:	d1c1      	bne.n	2df9e <ip_interface_open+0x7e>
   2e01a:	250c      	movs	r5, #12
   2e01c:	e7de      	b.n	2dfdc <ip_interface_open+0xbc>
   2e01e:	4627      	mov	r7, r4
   2e020:	e798      	b.n	2df54 <ip_interface_open+0x34>
   2e022:	f04f 33ff 	mov.w	r3, #4294967295
   2e026:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2e02a:	2102      	movs	r1, #2
   2e02c:	4640      	mov	r0, r8
   2e02e:	f001 fb63 	bl	2f6f8 <interface_socket_wait>
   2e032:	4605      	mov	r5, r0
   2e034:	2800      	cmp	r0, #0
   2e036:	d1d1      	bne.n	2dfdc <ip_interface_open+0xbc>
   2e038:	4640      	mov	r0, r8
   2e03a:	f001 fbd1 	bl	2f7e0 <interface_socket_from_handle_get>
   2e03e:	b148      	cbz	r0, 2e054 <ip_interface_open+0x134>
   2e040:	6845      	ldr	r5, [r0, #4]
   2e042:	b13d      	cbz	r5, 2e054 <ip_interface_open+0x134>
   2e044:	6046      	str	r6, [r0, #4]
   2e046:	e7c9      	b.n	2dfdc <ip_interface_open+0xbc>
   2e048:	202f      	movs	r0, #47	; 0x2f
   2e04a:	f7f9 fd09 	bl	27a60 <bsd_os_errno_set>
   2e04e:	f04f 38ff 	mov.w	r8, #4294967295
   2e052:	e7cb      	b.n	2dfec <ip_interface_open+0xcc>
   2e054:	3c02      	subs	r4, #2
   2e056:	2c01      	cmp	r4, #1
   2e058:	d8c8      	bhi.n	2dfec <ip_interface_open+0xcc>
   2e05a:	4640      	mov	r0, r8
   2e05c:	9b00      	ldr	r3, [sp, #0]
   2e05e:	681a      	ldr	r2, [r3, #0]
   2e060:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   2e064:	601a      	str	r2, [r3, #0]
   2e066:	681a      	ldr	r2, [r3, #0]
   2e068:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
   2e06c:	601a      	str	r2, [r3, #0]
   2e06e:	b002      	add	sp, #8
   2e070:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2e074:	2016      	movs	r0, #22
   2e076:	f7f9 fcf3 	bl	27a60 <bsd_os_errno_set>
   2e07a:	f04f 38ff 	mov.w	r8, #4294967295
   2e07e:	e7b5      	b.n	2dfec <ip_interface_open+0xcc>
   2e080:	0002de35 	.word	0x0002de35

0002e084 <ip_interface_close>:
   2e084:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2e088:	b082      	sub	sp, #8
   2e08a:	4606      	mov	r6, r0
   2e08c:	f001 fba8 	bl	2f7e0 <interface_socket_from_handle_get>
   2e090:	2800      	cmp	r0, #0
   2e092:	d063      	beq.n	2e15c <ip_interface_close+0xd8>
   2e094:	4604      	mov	r4, r0
   2e096:	2100      	movs	r1, #0
   2e098:	a802      	add	r0, sp, #8
   2e09a:	6827      	ldr	r7, [r4, #0]
   2e09c:	f840 1d04 	str.w	r1, [r0, #-4]!
   2e0a0:	f8d4 8018 	ldr.w	r8, [r4, #24]
   2e0a4:	f7fc fab8 	bl	2a618 <rpc_ip_client_request_alloc>
   2e0a8:	2800      	cmp	r0, #0
   2e0aa:	d13a      	bne.n	2e122 <ip_interface_close+0x9e>
   2e0ac:	f247 0309 	movw	r3, #28681	; 0x7009
   2e0b0:	2208      	movs	r2, #8
   2e0b2:	9d01      	ldr	r5, [sp, #4]
   2e0b4:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   2e0b8:	60eb      	str	r3, [r5, #12]
   2e0ba:	f8c5 8010 	str.w	r8, [r5, #16]
   2e0be:	7268      	strb	r0, [r5, #9]
   2e0c0:	72a8      	strb	r0, [r5, #10]
   2e0c2:	72e8      	strb	r0, [r5, #11]
   2e0c4:	722a      	strb	r2, [r5, #8]
   2e0c6:	6823      	ldr	r3, [r4, #0]
   2e0c8:	f247 0109 	movw	r1, #28681	; 0x7009
   2e0cc:	0c1b      	lsrs	r3, r3, #16
   2e0ce:	041b      	lsls	r3, r3, #16
   2e0d0:	f043 030d 	orr.w	r3, r3, #13
   2e0d4:	6023      	str	r3, [r4, #0]
   2e0d6:	6823      	ldr	r3, [r4, #0]
   2e0d8:	4628      	mov	r0, r5
   2e0da:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   2e0de:	6023      	str	r3, [r4, #0]
   2e0e0:	6823      	ldr	r3, [r4, #0]
   2e0e2:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   2e0e6:	6023      	str	r3, [r4, #0]
   2e0e8:	f7fc faaa 	bl	2a640 <rpc_ip_client_request_send>
   2e0ec:	bb40      	cbnz	r0, 2e140 <ip_interface_close+0xbc>
   2e0ee:	f04f 33ff 	mov.w	r3, #4294967295
   2e0f2:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2e0f6:	210e      	movs	r1, #14
   2e0f8:	4630      	mov	r0, r6
   2e0fa:	f001 fafd 	bl	2f6f8 <interface_socket_wait>
   2e0fe:	4604      	mov	r4, r0
   2e100:	b1a0      	cbz	r0, 2e12c <ip_interface_close+0xa8>
   2e102:	4c17      	ldr	r4, [pc, #92]	; (2e160 <ip_interface_close+0xdc>)
   2e104:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
   2e108:	b120      	cbz	r0, 2e114 <ip_interface_close+0x90>
   2e10a:	f7fc faaf 	bl	2a66c <rpc_ip_client_message_free>
   2e10e:	2300      	movs	r3, #0
   2e110:	f844 3026 	str.w	r3, [r4, r6, lsl #2]
   2e114:	4630      	mov	r0, r6
   2e116:	f001 faa1 	bl	2f65c <interface_socket_free>
   2e11a:	2000      	movs	r0, #0
   2e11c:	b002      	add	sp, #8
   2e11e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2e122:	9d01      	ldr	r5, [sp, #4]
   2e124:	200c      	movs	r0, #12
   2e126:	2d00      	cmp	r5, #0
   2e128:	d1cd      	bne.n	2e0c6 <ip_interface_close+0x42>
   2e12a:	e012      	b.n	2e152 <ip_interface_close+0xce>
   2e12c:	4630      	mov	r0, r6
   2e12e:	f001 fb57 	bl	2f7e0 <interface_socket_from_handle_get>
   2e132:	2800      	cmp	r0, #0
   2e134:	d0e5      	beq.n	2e102 <ip_interface_close+0x7e>
   2e136:	6843      	ldr	r3, [r0, #4]
   2e138:	2b00      	cmp	r3, #0
   2e13a:	d0e2      	beq.n	2e102 <ip_interface_close+0x7e>
   2e13c:	6044      	str	r4, [r0, #4]
   2e13e:	e7e0      	b.n	2e102 <ip_interface_close+0x7e>
   2e140:	6828      	ldr	r0, [r5, #0]
   2e142:	b108      	cbz	r0, 2e148 <ip_interface_close+0xc4>
   2e144:	f7fc fa9a 	bl	2a67c <rpc_ip_client_data_free>
   2e148:	4628      	mov	r0, r5
   2e14a:	f7fc fa8f 	bl	2a66c <rpc_ip_client_message_free>
   2e14e:	2023      	movs	r0, #35	; 0x23
   2e150:	6027      	str	r7, [r4, #0]
   2e152:	f7f9 fc85 	bl	27a60 <bsd_os_errno_set>
   2e156:	f04f 30ff 	mov.w	r0, #4294967295
   2e15a:	e7df      	b.n	2e11c <ip_interface_close+0x98>
   2e15c:	2009      	movs	r0, #9
   2e15e:	e7f8      	b.n	2e152 <ip_interface_close+0xce>
   2e160:	20020cfc 	.word	0x20020cfc

0002e164 <ip_interface_sendto>:
   2e164:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2e168:	2400      	movs	r4, #0
   2e16a:	b089      	sub	sp, #36	; 0x24
   2e16c:	9102      	str	r1, [sp, #8]
   2e16e:	4615      	mov	r5, r2
   2e170:	4699      	mov	r9, r3
   2e172:	9407      	str	r4, [sp, #28]
   2e174:	4607      	mov	r7, r0
   2e176:	9e12      	ldr	r6, [sp, #72]	; 0x48
   2e178:	f001 fb32 	bl	2f7e0 <interface_socket_from_handle_get>
   2e17c:	2800      	cmp	r0, #0
   2e17e:	f000 815f 	beq.w	2e440 <ip_interface_sendto+0x2dc>
   2e182:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
   2e186:	f300 814c 	bgt.w	2e422 <ip_interface_sendto+0x2be>
   2e18a:	6903      	ldr	r3, [r0, #16]
   2e18c:	4604      	mov	r4, r0
   2e18e:	2b01      	cmp	r3, #1
   2e190:	f000 80fb 	beq.w	2e38a <ip_interface_sendto+0x226>
   2e194:	6822      	ldr	r2, [r4, #0]
   2e196:	0390      	lsls	r0, r2, #14
   2e198:	d562      	bpl.n	2e260 <ip_interface_sendto+0xfc>
   2e19a:	f1b9 0f00 	cmp.w	r9, #0
   2e19e:	f000 80fc 	beq.w	2e39a <ip_interface_sendto+0x236>
   2e1a2:	f019 0f02 	tst.w	r9, #2
   2e1a6:	f000 8146 	beq.w	2e436 <ip_interface_sendto+0x2d2>
   2e1aa:	2300      	movs	r3, #0
   2e1ac:	9303      	str	r3, [sp, #12]
   2e1ae:	f247 0806 	movw	r8, #28678	; 0x7006
   2e1b2:	f04f 0b0c 	mov.w	fp, #12
   2e1b6:	4ba6      	ldr	r3, [pc, #664]	; (2e450 <ip_interface_sendto+0x2ec>)
   2e1b8:	9300      	str	r3, [sp, #0]
   2e1ba:	043b      	lsls	r3, r7, #16
   2e1bc:	9304      	str	r3, [sp, #16]
   2e1be:	4629      	mov	r1, r5
   2e1c0:	a807      	add	r0, sp, #28
   2e1c2:	f7fc fa29 	bl	2a618 <rpc_ip_client_request_alloc>
   2e1c6:	2804      	cmp	r0, #4
   2e1c8:	d063      	beq.n	2e292 <ip_interface_sendto+0x12e>
   2e1ca:	2800      	cmp	r0, #0
   2e1cc:	f040 813d 	bne.w	2e44a <ip_interface_sendto+0x2e6>
   2e1d0:	9b07      	ldr	r3, [sp, #28]
   2e1d2:	f883 b008 	strb.w	fp, [r3, #8]
   2e1d6:	7258      	strb	r0, [r3, #9]
   2e1d8:	7298      	strb	r0, [r3, #10]
   2e1da:	72d8      	strb	r0, [r3, #11]
   2e1dc:	2e00      	cmp	r6, #0
   2e1de:	d074      	beq.n	2e2ca <ip_interface_sendto+0x166>
   2e1e0:	68e2      	ldr	r2, [r4, #12]
   2e1e2:	6871      	ldr	r1, [r6, #4]
   2e1e4:	428a      	cmp	r2, r1
   2e1e6:	f040 80a2 	bne.w	2e32e <ip_interface_sendto+0x1ca>
   2e1ea:	7831      	ldrb	r1, [r6, #0]
   2e1ec:	9813      	ldr	r0, [sp, #76]	; 0x4c
   2e1ee:	4288      	cmp	r0, r1
   2e1f0:	d10a      	bne.n	2e208 <ip_interface_sendto+0xa4>
   2e1f2:	2a02      	cmp	r2, #2
   2e1f4:	f103 001c 	add.w	r0, r3, #28
   2e1f8:	f000 8101 	beq.w	2e3fe <ip_interface_sendto+0x29a>
   2e1fc:	2a0a      	cmp	r2, #10
   2e1fe:	d103      	bne.n	2e208 <ip_interface_sendto+0xa4>
   2e200:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   2e202:	2a24      	cmp	r2, #36	; 0x24
   2e204:	f000 80e8 	beq.w	2e3d8 <ip_interface_sendto+0x274>
   2e208:	f04f 0a16 	mov.w	sl, #22
   2e20c:	6818      	ldr	r0, [r3, #0]
   2e20e:	b110      	cbz	r0, 2e216 <ip_interface_sendto+0xb2>
   2e210:	f7fc fa34 	bl	2a67c <rpc_ip_client_data_free>
   2e214:	9b07      	ldr	r3, [sp, #28]
   2e216:	4618      	mov	r0, r3
   2e218:	f7fc fa28 	bl	2a66c <rpc_ip_client_message_free>
   2e21c:	6823      	ldr	r3, [r4, #0]
   2e21e:	031a      	lsls	r2, r3, #12
   2e220:	d43f      	bmi.n	2e2a2 <ip_interface_sendto+0x13e>
   2e222:	6823      	ldr	r3, [r4, #0]
   2e224:	b29b      	uxth	r3, r3
   2e226:	2b0d      	cmp	r3, #13
   2e228:	d007      	beq.n	2e23a <ip_interface_sendto+0xd6>
   2e22a:	6823      	ldr	r3, [r4, #0]
   2e22c:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   2e230:	6023      	str	r3, [r4, #0]
   2e232:	6823      	ldr	r3, [r4, #0]
   2e234:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2e238:	6023      	str	r3, [r4, #0]
   2e23a:	f1ba 0f00 	cmp.w	sl, #0
   2e23e:	d130      	bne.n	2e2a2 <ip_interface_sendto+0x13e>
   2e240:	6823      	ldr	r3, [r4, #0]
   2e242:	0118      	lsls	r0, r3, #4
   2e244:	d576      	bpl.n	2e334 <ip_interface_sendto+0x1d0>
   2e246:	6823      	ldr	r3, [r4, #0]
   2e248:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
   2e24c:	6023      	str	r3, [r4, #0]
   2e24e:	9b00      	ldr	r3, [sp, #0]
   2e250:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   2e254:	2800      	cmp	r0, #0
   2e256:	d12e      	bne.n	2e2b6 <ip_interface_sendto+0x152>
   2e258:	4628      	mov	r0, r5
   2e25a:	b009      	add	sp, #36	; 0x24
   2e25c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2e260:	6822      	ldr	r2, [r4, #0]
   2e262:	0091      	lsls	r1, r2, #2
   2e264:	d406      	bmi.n	2e274 <ip_interface_sendto+0x110>
   2e266:	2b01      	cmp	r3, #1
   2e268:	f000 80b0 	beq.w	2e3cc <ip_interface_sendto+0x268>
   2e26c:	6823      	ldr	r3, [r4, #0]
   2e26e:	031a      	lsls	r2, r3, #12
   2e270:	f140 80d2 	bpl.w	2e418 <ip_interface_sendto+0x2b4>
   2e274:	6823      	ldr	r3, [r4, #0]
   2e276:	031b      	lsls	r3, r3, #12
   2e278:	f140 80d8 	bpl.w	2e42c <ip_interface_sendto+0x2c8>
   2e27c:	4b74      	ldr	r3, [pc, #464]	; (2e450 <ip_interface_sendto+0x2ec>)
   2e27e:	f8d4 a008 	ldr.w	sl, [r4, #8]
   2e282:	9300      	str	r3, [sp, #0]
   2e284:	e7d9      	b.n	2e23a <ip_interface_sendto+0xd6>
   2e286:	9b00      	ldr	r3, [sp, #0]
   2e288:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   2e28c:	b108      	cbz	r0, 2e292 <ip_interface_sendto+0x12e>
   2e28e:	f7fc f9ed 	bl	2a66c <rpc_ip_client_message_free>
   2e292:	9b03      	ldr	r3, [sp, #12]
   2e294:	2b00      	cmp	r3, #0
   2e296:	d192      	bne.n	2e1be <ip_interface_sendto+0x5a>
   2e298:	6823      	ldr	r3, [r4, #0]
   2e29a:	f04f 0a23 	mov.w	sl, #35	; 0x23
   2e29e:	031a      	lsls	r2, r3, #12
   2e2a0:	d5bf      	bpl.n	2e222 <ip_interface_sendto+0xbe>
   2e2a2:	4650      	mov	r0, sl
   2e2a4:	f7f9 fbdc 	bl	27a60 <bsd_os_errno_set>
   2e2a8:	9b00      	ldr	r3, [sp, #0]
   2e2aa:	f04f 35ff 	mov.w	r5, #4294967295
   2e2ae:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   2e2b2:	2800      	cmp	r0, #0
   2e2b4:	d0d0      	beq.n	2e258 <ip_interface_sendto+0xf4>
   2e2b6:	f7fc f9d9 	bl	2a66c <rpc_ip_client_message_free>
   2e2ba:	2300      	movs	r3, #0
   2e2bc:	9a00      	ldr	r2, [sp, #0]
   2e2be:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
   2e2c2:	4628      	mov	r0, r5
   2e2c4:	b009      	add	sp, #36	; 0x24
   2e2c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2e2ca:	4642      	mov	r2, r8
   2e2cc:	f8c3 9014 	str.w	r9, [r3, #20]
   2e2d0:	69a1      	ldr	r1, [r4, #24]
   2e2d2:	9804      	ldr	r0, [sp, #16]
   2e2d4:	6119      	str	r1, [r3, #16]
   2e2d6:	9902      	ldr	r1, [sp, #8]
   2e2d8:	4302      	orrs	r2, r0
   2e2da:	60da      	str	r2, [r3, #12]
   2e2dc:	605d      	str	r5, [r3, #4]
   2e2de:	b119      	cbz	r1, 2e2e8 <ip_interface_sendto+0x184>
   2e2e0:	6818      	ldr	r0, [r3, #0]
   2e2e2:	462a      	mov	r2, r5
   2e2e4:	f00b fd4b 	bl	39d7e <memcpy>
   2e2e8:	6823      	ldr	r3, [r4, #0]
   2e2ea:	4641      	mov	r1, r8
   2e2ec:	9305      	str	r3, [sp, #20]
   2e2ee:	6823      	ldr	r3, [r4, #0]
   2e2f0:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   2e2f4:	6023      	str	r3, [r4, #0]
   2e2f6:	6823      	ldr	r3, [r4, #0]
   2e2f8:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
   2e2fc:	6023      	str	r3, [r4, #0]
   2e2fe:	9b07      	ldr	r3, [sp, #28]
   2e300:	4618      	mov	r0, r3
   2e302:	9301      	str	r3, [sp, #4]
   2e304:	f7fc f99c 	bl	2a640 <rpc_ip_client_request_send>
   2e308:	9b01      	ldr	r3, [sp, #4]
   2e30a:	4682      	mov	sl, r0
   2e30c:	b9e8      	cbnz	r0, 2e34a <ip_interface_sendto+0x1e6>
   2e30e:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   2e312:	f04f 33ff 	mov.w	r3, #4294967295
   2e316:	4611      	mov	r1, r2
   2e318:	4638      	mov	r0, r7
   2e31a:	f001 f9ed 	bl	2f6f8 <interface_socket_wait>
   2e31e:	b308      	cbz	r0, 2e364 <ip_interface_sendto+0x200>
   2e320:	6823      	ldr	r3, [r4, #0]
   2e322:	0319      	lsls	r1, r3, #12
   2e324:	d42a      	bmi.n	2e37c <ip_interface_sendto+0x218>
   2e326:	280c      	cmp	r0, #12
   2e328:	d0ad      	beq.n	2e286 <ip_interface_sendto+0x122>
   2e32a:	4682      	mov	sl, r0
   2e32c:	e776      	b.n	2e21c <ip_interface_sendto+0xb8>
   2e32e:	f04f 0a2f 	mov.w	sl, #47	; 0x2f
   2e332:	e76b      	b.n	2e20c <ip_interface_sendto+0xa8>
   2e334:	9b00      	ldr	r3, [sp, #0]
   2e336:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   2e33a:	6985      	ldr	r5, [r0, #24]
   2e33c:	f7fc f996 	bl	2a66c <rpc_ip_client_message_free>
   2e340:	2300      	movs	r3, #0
   2e342:	9a00      	ldr	r2, [sp, #0]
   2e344:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
   2e348:	e7bb      	b.n	2e2c2 <ip_interface_sendto+0x15e>
   2e34a:	6818      	ldr	r0, [r3, #0]
   2e34c:	469a      	mov	sl, r3
   2e34e:	b108      	cbz	r0, 2e354 <ip_interface_sendto+0x1f0>
   2e350:	f7fc f994 	bl	2a67c <rpc_ip_client_data_free>
   2e354:	4650      	mov	r0, sl
   2e356:	f7fc f989 	bl	2a66c <rpc_ip_client_message_free>
   2e35a:	9b05      	ldr	r3, [sp, #20]
   2e35c:	f04f 0a23 	mov.w	sl, #35	; 0x23
   2e360:	6023      	str	r3, [r4, #0]
   2e362:	e75b      	b.n	2e21c <ip_interface_sendto+0xb8>
   2e364:	4638      	mov	r0, r7
   2e366:	f001 fa3b 	bl	2f7e0 <interface_socket_from_handle_get>
   2e36a:	4603      	mov	r3, r0
   2e36c:	b1e0      	cbz	r0, 2e3a8 <ip_interface_sendto+0x244>
   2e36e:	6840      	ldr	r0, [r0, #4]
   2e370:	b1d0      	cbz	r0, 2e3a8 <ip_interface_sendto+0x244>
   2e372:	f8c3 a004 	str.w	sl, [r3, #4]
   2e376:	6823      	ldr	r3, [r4, #0]
   2e378:	0319      	lsls	r1, r3, #12
   2e37a:	d5d4      	bpl.n	2e326 <ip_interface_sendto+0x1c2>
   2e37c:	f8d4 a008 	ldr.w	sl, [r4, #8]
   2e380:	6823      	ldr	r3, [r4, #0]
   2e382:	031e      	lsls	r6, r3, #12
   2e384:	f57f af4d 	bpl.w	2e222 <ip_interface_sendto+0xbe>
   2e388:	e757      	b.n	2e23a <ip_interface_sendto+0xd6>
   2e38a:	2e00      	cmp	r6, #0
   2e38c:	f43f af02 	beq.w	2e194 <ip_interface_sendto+0x30>
   2e390:	4b2f      	ldr	r3, [pc, #188]	; (2e450 <ip_interface_sendto+0x2ec>)
   2e392:	f04f 0a38 	mov.w	sl, #56	; 0x38
   2e396:	9300      	str	r3, [sp, #0]
   2e398:	e783      	b.n	2e2a2 <ip_interface_sendto+0x13e>
   2e39a:	6823      	ldr	r3, [r4, #0]
   2e39c:	f083 5380 	eor.w	r3, r3, #268435456	; 0x10000000
   2e3a0:	f3c3 7300 	ubfx	r3, r3, #28, #1
   2e3a4:	9303      	str	r3, [sp, #12]
   2e3a6:	e702      	b.n	2e1ae <ip_interface_sendto+0x4a>
   2e3a8:	6823      	ldr	r3, [r4, #0]
   2e3aa:	031b      	lsls	r3, r3, #12
   2e3ac:	f53f af48 	bmi.w	2e240 <ip_interface_sendto+0xdc>
   2e3b0:	6823      	ldr	r3, [r4, #0]
   2e3b2:	b29b      	uxth	r3, r3
   2e3b4:	2b0d      	cmp	r3, #13
   2e3b6:	f43f af43 	beq.w	2e240 <ip_interface_sendto+0xdc>
   2e3ba:	6823      	ldr	r3, [r4, #0]
   2e3bc:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   2e3c0:	6023      	str	r3, [r4, #0]
   2e3c2:	6823      	ldr	r3, [r4, #0]
   2e3c4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2e3c8:	6023      	str	r3, [r4, #0]
   2e3ca:	e739      	b.n	2e240 <ip_interface_sendto+0xdc>
   2e3cc:	6823      	ldr	r3, [r4, #0]
   2e3ce:	b29b      	uxth	r3, r3
   2e3d0:	2b05      	cmp	r3, #5
   2e3d2:	f47f af4f 	bne.w	2e274 <ip_interface_sendto+0x110>
   2e3d6:	e749      	b.n	2e26c <ip_interface_sendto+0x108>
   2e3d8:	2210      	movs	r2, #16
   2e3da:	8931      	ldrh	r1, [r6, #8]
   2e3dc:	835a      	strh	r2, [r3, #26]
   2e3de:	8319      	strh	r1, [r3, #24]
   2e3e0:	18b1      	adds	r1, r6, r2
   2e3e2:	f00b fccc 	bl	39d7e <memcpy>
   2e3e6:	f247 0207 	movw	r2, #28679	; 0x7007
   2e3ea:	9b07      	ldr	r3, [sp, #28]
   2e3ec:	4690      	mov	r8, r2
   2e3ee:	6899      	ldr	r1, [r3, #8]
   2e3f0:	8b58      	ldrh	r0, [r3, #26]
   2e3f2:	3104      	adds	r1, #4
   2e3f4:	4401      	add	r1, r0
   2e3f6:	f8c3 9014 	str.w	r9, [r3, #20]
   2e3fa:	6099      	str	r1, [r3, #8]
   2e3fc:	e768      	b.n	2e2d0 <ip_interface_sendto+0x16c>
   2e3fe:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   2e400:	2a10      	cmp	r2, #16
   2e402:	f47f af01 	bne.w	2e208 <ip_interface_sendto+0xa4>
   2e406:	2204      	movs	r2, #4
   2e408:	8931      	ldrh	r1, [r6, #8]
   2e40a:	835a      	strh	r2, [r3, #26]
   2e40c:	8319      	strh	r1, [r3, #24]
   2e40e:	f106 010c 	add.w	r1, r6, #12
   2e412:	f00b fcb4 	bl	39d7e <memcpy>
   2e416:	e7e6      	b.n	2e3e6 <ip_interface_sendto+0x282>
   2e418:	4b0d      	ldr	r3, [pc, #52]	; (2e450 <ip_interface_sendto+0x2ec>)
   2e41a:	f04f 0a23 	mov.w	sl, #35	; 0x23
   2e41e:	9300      	str	r3, [sp, #0]
   2e420:	e73f      	b.n	2e2a2 <ip_interface_sendto+0x13e>
   2e422:	4b0b      	ldr	r3, [pc, #44]	; (2e450 <ip_interface_sendto+0x2ec>)
   2e424:	f04f 0a28 	mov.w	sl, #40	; 0x28
   2e428:	9300      	str	r3, [sp, #0]
   2e42a:	e73a      	b.n	2e2a2 <ip_interface_sendto+0x13e>
   2e42c:	4b08      	ldr	r3, [pc, #32]	; (2e450 <ip_interface_sendto+0x2ec>)
   2e42e:	f04f 0a39 	mov.w	sl, #57	; 0x39
   2e432:	9300      	str	r3, [sp, #0]
   2e434:	e735      	b.n	2e2a2 <ip_interface_sendto+0x13e>
   2e436:	4b06      	ldr	r3, [pc, #24]	; (2e450 <ip_interface_sendto+0x2ec>)
   2e438:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
   2e43c:	9300      	str	r3, [sp, #0]
   2e43e:	e730      	b.n	2e2a2 <ip_interface_sendto+0x13e>
   2e440:	4b03      	ldr	r3, [pc, #12]	; (2e450 <ip_interface_sendto+0x2ec>)
   2e442:	f04f 0a09 	mov.w	sl, #9
   2e446:	9300      	str	r3, [sp, #0]
   2e448:	e72b      	b.n	2e2a2 <ip_interface_sendto+0x13e>
   2e44a:	f04f 0a0c 	mov.w	sl, #12
   2e44e:	e6e5      	b.n	2e21c <ip_interface_sendto+0xb8>
   2e450:	20020cfc 	.word	0x20020cfc

0002e454 <ip_interface_recvfrom>:
   2e454:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2e458:	b085      	sub	sp, #20
   2e45a:	2a00      	cmp	r2, #0
   2e45c:	f000 811b 	beq.w	2e696 <ip_interface_recvfrom+0x242>
   2e460:	4605      	mov	r5, r0
   2e462:	468a      	mov	sl, r1
   2e464:	4698      	mov	r8, r3
   2e466:	4617      	mov	r7, r2
   2e468:	b11b      	cbz	r3, 2e472 <ip_interface_recvfrom+0x1e>
   2e46a:	f013 0f1a 	tst.w	r3, #26
   2e46e:	f000 810f 	beq.w	2e690 <ip_interface_recvfrom+0x23c>
   2e472:	4628      	mov	r0, r5
   2e474:	f001 f9b4 	bl	2f7e0 <interface_socket_from_handle_get>
   2e478:	4604      	mov	r4, r0
   2e47a:	2800      	cmp	r0, #0
   2e47c:	f000 810e 	beq.w	2e69c <ip_interface_recvfrom+0x248>
   2e480:	6803      	ldr	r3, [r0, #0]
   2e482:	02d9      	lsls	r1, r3, #11
   2e484:	d564      	bpl.n	2e550 <ip_interface_recvfrom+0xfc>
   2e486:	f018 0f02 	tst.w	r8, #2
   2e48a:	bf18      	it	ne
   2e48c:	f04f 0900 	movne.w	r9, #0
   2e490:	f04f 3bff 	mov.w	fp, #4294967295
   2e494:	bf08      	it	eq
   2e496:	6803      	ldreq	r3, [r0, #0]
   2e498:	f008 0610 	and.w	r6, r8, #16
   2e49c:	bf04      	itt	eq
   2e49e:	f083 5980 	eoreq.w	r9, r3, #268435456	; 0x10000000
   2e4a2:	f3c9 7900 	ubfxeq	r9, r9, #28, #1
   2e4a6:	6823      	ldr	r3, [r4, #0]
   2e4a8:	03da      	lsls	r2, r3, #15
   2e4aa:	d56c      	bpl.n	2e586 <ip_interface_recvfrom+0x132>
   2e4ac:	6823      	ldr	r3, [r4, #0]
   2e4ae:	69e0      	ldr	r0, [r4, #28]
   2e4b0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   2e4b4:	6023      	str	r3, [r4, #0]
   2e4b6:	6803      	ldr	r3, [r0, #0]
   2e4b8:	68db      	ldr	r3, [r3, #12]
   2e4ba:	4798      	blx	r3
   2e4bc:	f1b0 3fff 	cmp.w	r0, #4294967295
   2e4c0:	4683      	mov	fp, r0
   2e4c2:	d07f      	beq.n	2e5c4 <ip_interface_recvfrom+0x170>
   2e4c4:	4287      	cmp	r7, r0
   2e4c6:	dd03      	ble.n	2e4d0 <ip_interface_recvfrom+0x7c>
   2e4c8:	6923      	ldr	r3, [r4, #16]
   2e4ca:	2b01      	cmp	r3, #1
   2e4cc:	f000 80a6 	beq.w	2e61c <ip_interface_recvfrom+0x1c8>
   2e4d0:	2600      	movs	r6, #0
   2e4d2:	69e0      	ldr	r0, [r4, #28]
   2e4d4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   2e4d6:	b103      	cbz	r3, 2e4da <ip_interface_recvfrom+0x86>
   2e4d8:	681b      	ldr	r3, [r3, #0]
   2e4da:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   2e4dc:	e9cd a700 	strd	sl, r7, [sp]
   2e4e0:	e9cd 2302 	strd	r2, r3, [sp, #8]
   2e4e4:	6803      	ldr	r3, [r0, #0]
   2e4e6:	4642      	mov	r2, r8
   2e4e8:	689b      	ldr	r3, [r3, #8]
   2e4ea:	4669      	mov	r1, sp
   2e4ec:	4798      	blx	r3
   2e4ee:	4683      	mov	fp, r0
   2e4f0:	69e0      	ldr	r0, [r4, #28]
   2e4f2:	f1bb 3fff 	cmp.w	fp, #4294967295
   2e4f6:	6803      	ldr	r3, [r0, #0]
   2e4f8:	bf18      	it	ne
   2e4fa:	2501      	movne	r5, #1
   2e4fc:	68db      	ldr	r3, [r3, #12]
   2e4fe:	bf0a      	itet	eq
   2e500:	2500      	moveq	r5, #0
   2e502:	f04f 0900 	movne.w	r9, #0
   2e506:	f04f 0923 	moveq.w	r9, #35	; 0x23
   2e50a:	4798      	blx	r3
   2e50c:	3001      	adds	r0, #1
   2e50e:	d135      	bne.n	2e57c <ip_interface_recvfrom+0x128>
   2e510:	2e00      	cmp	r6, #0
   2e512:	f000 80b5 	beq.w	2e680 <ip_interface_recvfrom+0x22c>
   2e516:	2d00      	cmp	r5, #0
   2e518:	f000 80a5 	beq.w	2e666 <ip_interface_recvfrom+0x212>
   2e51c:	6823      	ldr	r3, [r4, #0]
   2e51e:	0319      	lsls	r1, r3, #12
   2e520:	d506      	bpl.n	2e530 <ip_interface_recvfrom+0xdc>
   2e522:	6823      	ldr	r3, [r4, #0]
   2e524:	b29b      	uxth	r3, r3
   2e526:	2b0d      	cmp	r3, #13
   2e528:	d002      	beq.n	2e530 <ip_interface_recvfrom+0xdc>
   2e52a:	6923      	ldr	r3, [r4, #16]
   2e52c:	2b01      	cmp	r3, #1
   2e52e:	d025      	beq.n	2e57c <ip_interface_recvfrom+0x128>
   2e530:	6823      	ldr	r3, [r4, #0]
   2e532:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
   2e536:	6823      	ldr	r3, [r4, #0]
   2e538:	f040 80b3 	bne.w	2e6a2 <ip_interface_recvfrom+0x24e>
   2e53c:	031a      	lsls	r2, r3, #12
   2e53e:	d474      	bmi.n	2e62a <ip_interface_recvfrom+0x1d6>
   2e540:	f1b9 0f00 	cmp.w	r9, #0
   2e544:	f040 8089 	bne.w	2e65a <ip_interface_recvfrom+0x206>
   2e548:	4658      	mov	r0, fp
   2e54a:	b005      	add	sp, #20
   2e54c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2e550:	6803      	ldr	r3, [r0, #0]
   2e552:	b29b      	uxth	r3, r3
   2e554:	2b06      	cmp	r3, #6
   2e556:	d072      	beq.n	2e63e <ip_interface_recvfrom+0x1ea>
   2e558:	6803      	ldr	r3, [r0, #0]
   2e55a:	b29b      	uxth	r3, r3
   2e55c:	2b07      	cmp	r3, #7
   2e55e:	bf0c      	ite	eq
   2e560:	f04f 0909 	moveq.w	r9, #9
   2e564:	f04f 0939 	movne.w	r9, #57	; 0x39
   2e568:	69e0      	ldr	r0, [r4, #28]
   2e56a:	6803      	ldr	r3, [r0, #0]
   2e56c:	68db      	ldr	r3, [r3, #12]
   2e56e:	4798      	blx	r3
   2e570:	f1b0 3fff 	cmp.w	r0, #4294967295
   2e574:	4683      	mov	fp, r0
   2e576:	d0db      	beq.n	2e530 <ip_interface_recvfrom+0xdc>
   2e578:	f04f 3bff 	mov.w	fp, #4294967295
   2e57c:	6823      	ldr	r3, [r4, #0]
   2e57e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   2e582:	6023      	str	r3, [r4, #0]
   2e584:	e7dc      	b.n	2e540 <ip_interface_recvfrom+0xec>
   2e586:	f1b9 0f00 	cmp.w	r9, #0
   2e58a:	d07d      	beq.n	2e688 <ip_interface_recvfrom+0x234>
   2e58c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   2e590:	6a23      	ldr	r3, [r4, #32]
   2e592:	4611      	mov	r1, r2
   2e594:	2b00      	cmp	r3, #0
   2e596:	bf08      	it	eq
   2e598:	f04f 33ff 	moveq.w	r3, #4294967295
   2e59c:	4628      	mov	r0, r5
   2e59e:	f001 f8ab 	bl	2f6f8 <interface_socket_wait>
   2e5a2:	4681      	mov	r9, r0
   2e5a4:	b358      	cbz	r0, 2e5fe <ip_interface_recvfrom+0x1aa>
   2e5a6:	6823      	ldr	r3, [r4, #0]
   2e5a8:	69e0      	ldr	r0, [r4, #28]
   2e5aa:	031b      	lsls	r3, r3, #12
   2e5ac:	d521      	bpl.n	2e5f2 <ip_interface_recvfrom+0x19e>
   2e5ae:	6823      	ldr	r3, [r4, #0]
   2e5b0:	b29b      	uxth	r3, r3
   2e5b2:	2b0d      	cmp	r3, #13
   2e5b4:	d01d      	beq.n	2e5f2 <ip_interface_recvfrom+0x19e>
   2e5b6:	6926      	ldr	r6, [r4, #16]
   2e5b8:	f1a6 0601 	sub.w	r6, r6, #1
   2e5bc:	fab6 f686 	clz	r6, r6
   2e5c0:	0976      	lsrs	r6, r6, #5
   2e5c2:	e787      	b.n	2e4d4 <ip_interface_recvfrom+0x80>
   2e5c4:	6823      	ldr	r3, [r4, #0]
   2e5c6:	0318      	lsls	r0, r3, #12
   2e5c8:	d5dd      	bpl.n	2e586 <ip_interface_recvfrom+0x132>
   2e5ca:	6823      	ldr	r3, [r4, #0]
   2e5cc:	b29b      	uxth	r3, r3
   2e5ce:	2b0d      	cmp	r3, #13
   2e5d0:	d0d9      	beq.n	2e586 <ip_interface_recvfrom+0x132>
   2e5d2:	6923      	ldr	r3, [r4, #16]
   2e5d4:	69e0      	ldr	r0, [r4, #28]
   2e5d6:	2b01      	cmp	r3, #1
   2e5d8:	d034      	beq.n	2e644 <ip_interface_recvfrom+0x1f0>
   2e5da:	f04f 0939 	mov.w	r9, #57	; 0x39
   2e5de:	6823      	ldr	r3, [r4, #0]
   2e5e0:	0c1b      	lsrs	r3, r3, #16
   2e5e2:	041b      	lsls	r3, r3, #16
   2e5e4:	f043 030d 	orr.w	r3, r3, #13
   2e5e8:	6023      	str	r3, [r4, #0]
   2e5ea:	6823      	ldr	r3, [r4, #0]
   2e5ec:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   2e5f0:	6023      	str	r3, [r4, #0]
   2e5f2:	6803      	ldr	r3, [r0, #0]
   2e5f4:	68db      	ldr	r3, [r3, #12]
   2e5f6:	4798      	blx	r3
   2e5f8:	3001      	adds	r0, #1
   2e5fa:	d1bf      	bne.n	2e57c <ip_interface_recvfrom+0x128>
   2e5fc:	e798      	b.n	2e530 <ip_interface_recvfrom+0xdc>
   2e5fe:	4628      	mov	r0, r5
   2e600:	f001 f8ee 	bl	2f7e0 <interface_socket_from_handle_get>
   2e604:	b138      	cbz	r0, 2e616 <ip_interface_recvfrom+0x1c2>
   2e606:	f8d0 9004 	ldr.w	r9, [r0, #4]
   2e60a:	f1b9 0f00 	cmp.w	r9, #0
   2e60e:	d002      	beq.n	2e616 <ip_interface_recvfrom+0x1c2>
   2e610:	2300      	movs	r3, #0
   2e612:	6043      	str	r3, [r0, #4]
   2e614:	e7c7      	b.n	2e5a6 <ip_interface_recvfrom+0x152>
   2e616:	f04f 0901 	mov.w	r9, #1
   2e61a:	e744      	b.n	2e4a6 <ip_interface_recvfrom+0x52>
   2e61c:	b11e      	cbz	r6, 2e626 <ip_interface_recvfrom+0x1d2>
   2e61e:	6823      	ldr	r3, [r4, #0]
   2e620:	00db      	lsls	r3, r3, #3
   2e622:	d5b3      	bpl.n	2e58c <ip_interface_recvfrom+0x138>
   2e624:	e754      	b.n	2e4d0 <ip_interface_recvfrom+0x7c>
   2e626:	69e0      	ldr	r0, [r4, #28]
   2e628:	e754      	b.n	2e4d4 <ip_interface_recvfrom+0x80>
   2e62a:	6823      	ldr	r3, [r4, #0]
   2e62c:	b29b      	uxth	r3, r3
   2e62e:	2b0d      	cmp	r3, #13
   2e630:	d186      	bne.n	2e540 <ip_interface_recvfrom+0xec>
   2e632:	68a3      	ldr	r3, [r4, #8]
   2e634:	2b00      	cmp	r3, #0
   2e636:	d083      	beq.n	2e540 <ip_interface_recvfrom+0xec>
   2e638:	f8d4 9008 	ldr.w	r9, [r4, #8]
   2e63c:	e780      	b.n	2e540 <ip_interface_recvfrom+0xec>
   2e63e:	f04f 0909 	mov.w	r9, #9
   2e642:	e791      	b.n	2e568 <ip_interface_recvfrom+0x114>
   2e644:	6803      	ldr	r3, [r0, #0]
   2e646:	68db      	ldr	r3, [r3, #12]
   2e648:	4798      	blx	r3
   2e64a:	3001      	adds	r0, #1
   2e64c:	d00b      	beq.n	2e666 <ip_interface_recvfrom+0x212>
   2e64e:	f04f 0923 	mov.w	r9, #35	; 0x23
   2e652:	6823      	ldr	r3, [r4, #0]
   2e654:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   2e658:	6023      	str	r3, [r4, #0]
   2e65a:	4648      	mov	r0, r9
   2e65c:	f7f9 fa00 	bl	27a60 <bsd_os_errno_set>
   2e660:	f04f 3bff 	mov.w	fp, #4294967295
   2e664:	e770      	b.n	2e548 <ip_interface_recvfrom+0xf4>
   2e666:	6823      	ldr	r3, [r4, #0]
   2e668:	f04f 0b00 	mov.w	fp, #0
   2e66c:	0c1b      	lsrs	r3, r3, #16
   2e66e:	041b      	lsls	r3, r3, #16
   2e670:	f043 030d 	orr.w	r3, r3, #13
   2e674:	6023      	str	r3, [r4, #0]
   2e676:	6823      	ldr	r3, [r4, #0]
   2e678:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   2e67c:	6023      	str	r3, [r4, #0]
   2e67e:	e763      	b.n	2e548 <ip_interface_recvfrom+0xf4>
   2e680:	2d00      	cmp	r5, #0
   2e682:	f47f af4b 	bne.w	2e51c <ip_interface_recvfrom+0xc8>
   2e686:	e753      	b.n	2e530 <ip_interface_recvfrom+0xdc>
   2e688:	f04f 0923 	mov.w	r9, #35	; 0x23
   2e68c:	69e0      	ldr	r0, [r4, #28]
   2e68e:	e7b0      	b.n	2e5f2 <ip_interface_recvfrom+0x19e>
   2e690:	f04f 092d 	mov.w	r9, #45	; 0x2d
   2e694:	e7e1      	b.n	2e65a <ip_interface_recvfrom+0x206>
   2e696:	f04f 0916 	mov.w	r9, #22
   2e69a:	e7de      	b.n	2e65a <ip_interface_recvfrom+0x206>
   2e69c:	f04f 0909 	mov.w	r9, #9
   2e6a0:	e7db      	b.n	2e65a <ip_interface_recvfrom+0x206>
   2e6a2:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
   2e6a6:	6023      	str	r3, [r4, #0]
   2e6a8:	6823      	ldr	r3, [r4, #0]
   2e6aa:	f04f 0969 	mov.w	r9, #105	; 0x69
   2e6ae:	0c1b      	lsrs	r3, r3, #16
   2e6b0:	041b      	lsls	r3, r3, #16
   2e6b2:	f043 030d 	orr.w	r3, r3, #13
   2e6b6:	6023      	str	r3, [r4, #0]
   2e6b8:	e7cf      	b.n	2e65a <ip_interface_recvfrom+0x206>
   2e6ba:	bf00      	nop

0002e6bc <ip_interface_connect>:
   2e6bc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2e6c0:	b083      	sub	sp, #12
   2e6c2:	2900      	cmp	r1, #0
   2e6c4:	d049      	beq.n	2e75a <ip_interface_connect+0x9e>
   2e6c6:	4616      	mov	r6, r2
   2e6c8:	2a00      	cmp	r2, #0
   2e6ca:	d046      	beq.n	2e75a <ip_interface_connect+0x9e>
   2e6cc:	4607      	mov	r7, r0
   2e6ce:	4688      	mov	r8, r1
   2e6d0:	f001 f886 	bl	2f7e0 <interface_socket_from_handle_get>
   2e6d4:	4605      	mov	r5, r0
   2e6d6:	2800      	cmp	r0, #0
   2e6d8:	f000 80a8 	beq.w	2e82c <ip_interface_connect+0x170>
   2e6dc:	6803      	ldr	r3, [r0, #0]
   2e6de:	b29b      	uxth	r3, r3
   2e6e0:	2b02      	cmp	r3, #2
   2e6e2:	d004      	beq.n	2e6ee <ip_interface_connect+0x32>
   2e6e4:	6803      	ldr	r3, [r0, #0]
   2e6e6:	b29b      	uxth	r3, r3
   2e6e8:	2b04      	cmp	r3, #4
   2e6ea:	f040 808b 	bne.w	2e804 <ip_interface_connect+0x148>
   2e6ee:	6829      	ldr	r1, [r5, #0]
   2e6f0:	f011 5100 	ands.w	r1, r1, #536870912	; 0x20000000
   2e6f4:	f040 8082 	bne.w	2e7fc <ip_interface_connect+0x140>
   2e6f8:	a802      	add	r0, sp, #8
   2e6fa:	f840 1d04 	str.w	r1, [r0, #-4]!
   2e6fe:	f8d5 9018 	ldr.w	r9, [r5, #24]
   2e702:	f7fb ff89 	bl	2a618 <rpc_ip_client_request_alloc>
   2e706:	bb90      	cbnz	r0, 2e76e <ip_interface_connect+0xb2>
   2e708:	2108      	movs	r1, #8
   2e70a:	043b      	lsls	r3, r7, #16
   2e70c:	9c01      	ldr	r4, [sp, #4]
   2e70e:	f443 42e0 	orr.w	r2, r3, #28672	; 0x7000
   2e712:	f042 0202 	orr.w	r2, r2, #2
   2e716:	60e2      	str	r2, [r4, #12]
   2e718:	f8c4 9010 	str.w	r9, [r4, #16]
   2e71c:	7260      	strb	r0, [r4, #9]
   2e71e:	72a0      	strb	r0, [r4, #10]
   2e720:	72e0      	strb	r0, [r4, #11]
   2e722:	7221      	strb	r1, [r4, #8]
   2e724:	f443 43e0 	orr.w	r3, r3, #28672	; 0x7000
   2e728:	f043 0302 	orr.w	r3, r3, #2
   2e72c:	60e3      	str	r3, [r4, #12]
   2e72e:	68a3      	ldr	r3, [r4, #8]
   2e730:	69aa      	ldr	r2, [r5, #24]
   2e732:	3304      	adds	r3, #4
   2e734:	6122      	str	r2, [r4, #16]
   2e736:	60a3      	str	r3, [r4, #8]
   2e738:	68eb      	ldr	r3, [r5, #12]
   2e73a:	f8d8 2004 	ldr.w	r2, [r8, #4]
   2e73e:	4293      	cmp	r3, r2
   2e740:	d11a      	bne.n	2e778 <ip_interface_connect+0xbc>
   2e742:	f898 2000 	ldrb.w	r2, [r8]
   2e746:	4296      	cmp	r6, r2
   2e748:	d107      	bne.n	2e75a <ip_interface_connect+0x9e>
   2e74a:	2b02      	cmp	r3, #2
   2e74c:	f104 0018 	add.w	r0, r4, #24
   2e750:	d014      	beq.n	2e77c <ip_interface_connect+0xc0>
   2e752:	2b0a      	cmp	r3, #10
   2e754:	d101      	bne.n	2e75a <ip_interface_connect+0x9e>
   2e756:	2e24      	cmp	r6, #36	; 0x24
   2e758:	d01c      	beq.n	2e794 <ip_interface_connect+0xd8>
   2e75a:	2416      	movs	r4, #22
   2e75c:	4620      	mov	r0, r4
   2e75e:	f7f9 f97f 	bl	27a60 <bsd_os_errno_set>
   2e762:	f04f 34ff 	mov.w	r4, #4294967295
   2e766:	4620      	mov	r0, r4
   2e768:	b003      	add	sp, #12
   2e76a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2e76e:	9c01      	ldr	r4, [sp, #4]
   2e770:	2c00      	cmp	r4, #0
   2e772:	d059      	beq.n	2e828 <ip_interface_connect+0x16c>
   2e774:	043b      	lsls	r3, r7, #16
   2e776:	e7d5      	b.n	2e724 <ip_interface_connect+0x68>
   2e778:	242f      	movs	r4, #47	; 0x2f
   2e77a:	e7ef      	b.n	2e75c <ip_interface_connect+0xa0>
   2e77c:	2e10      	cmp	r6, #16
   2e77e:	d1ec      	bne.n	2e75a <ip_interface_connect+0x9e>
   2e780:	2204      	movs	r2, #4
   2e782:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   2e786:	f108 010c 	add.w	r1, r8, #12
   2e78a:	82e2      	strh	r2, [r4, #22]
   2e78c:	82a3      	strh	r3, [r4, #20]
   2e78e:	f00b faf6 	bl	39d7e <memcpy>
   2e792:	e008      	b.n	2e7a6 <ip_interface_connect+0xea>
   2e794:	2210      	movs	r2, #16
   2e796:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   2e79a:	eb08 0102 	add.w	r1, r8, r2
   2e79e:	82e2      	strh	r2, [r4, #22]
   2e7a0:	82a3      	strh	r3, [r4, #20]
   2e7a2:	f00b faec 	bl	39d7e <memcpy>
   2e7a6:	68a3      	ldr	r3, [r4, #8]
   2e7a8:	8ae2      	ldrh	r2, [r4, #22]
   2e7aa:	f247 0102 	movw	r1, #28674	; 0x7002
   2e7ae:	4413      	add	r3, r2
   2e7b0:	60a3      	str	r3, [r4, #8]
   2e7b2:	682e      	ldr	r6, [r5, #0]
   2e7b4:	682b      	ldr	r3, [r5, #0]
   2e7b6:	4620      	mov	r0, r4
   2e7b8:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   2e7bc:	602b      	str	r3, [r5, #0]
   2e7be:	f7fb ff3f 	bl	2a640 <rpc_ip_client_request_send>
   2e7c2:	b988      	cbnz	r0, 2e7e8 <ip_interface_connect+0x12c>
   2e7c4:	682b      	ldr	r3, [r5, #0]
   2e7c6:	f013 5880 	ands.w	r8, r3, #268435456	; 0x10000000
   2e7ca:	d119      	bne.n	2e800 <ip_interface_connect+0x144>
   2e7cc:	f04f 33ff 	mov.w	r3, #4294967295
   2e7d0:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2e7d4:	2105      	movs	r1, #5
   2e7d6:	4638      	mov	r0, r7
   2e7d8:	f000 ff8e 	bl	2f6f8 <interface_socket_wait>
   2e7dc:	4604      	mov	r4, r0
   2e7de:	b1c0      	cbz	r0, 2e812 <ip_interface_connect+0x156>
   2e7e0:	2c73      	cmp	r4, #115	; 0x73
   2e7e2:	d0bb      	beq.n	2e75c <ip_interface_connect+0xa0>
   2e7e4:	602e      	str	r6, [r5, #0]
   2e7e6:	e7b9      	b.n	2e75c <ip_interface_connect+0xa0>
   2e7e8:	6820      	ldr	r0, [r4, #0]
   2e7ea:	b108      	cbz	r0, 2e7f0 <ip_interface_connect+0x134>
   2e7ec:	f7fb ff46 	bl	2a67c <rpc_ip_client_data_free>
   2e7f0:	4620      	mov	r0, r4
   2e7f2:	f7fb ff3b 	bl	2a66c <rpc_ip_client_message_free>
   2e7f6:	2423      	movs	r4, #35	; 0x23
   2e7f8:	602e      	str	r6, [r5, #0]
   2e7fa:	e7af      	b.n	2e75c <ip_interface_connect+0xa0>
   2e7fc:	2472      	movs	r4, #114	; 0x72
   2e7fe:	e7ad      	b.n	2e75c <ip_interface_connect+0xa0>
   2e800:	2473      	movs	r4, #115	; 0x73
   2e802:	e7ab      	b.n	2e75c <ip_interface_connect+0xa0>
   2e804:	6803      	ldr	r3, [r0, #0]
   2e806:	b29b      	uxth	r3, r3
   2e808:	2b05      	cmp	r3, #5
   2e80a:	bf14      	ite	ne
   2e80c:	2409      	movne	r4, #9
   2e80e:	2438      	moveq	r4, #56	; 0x38
   2e810:	e7a4      	b.n	2e75c <ip_interface_connect+0xa0>
   2e812:	4638      	mov	r0, r7
   2e814:	f000 ffe4 	bl	2f7e0 <interface_socket_from_handle_get>
   2e818:	2800      	cmp	r0, #0
   2e81a:	d0a4      	beq.n	2e766 <ip_interface_connect+0xaa>
   2e81c:	6844      	ldr	r4, [r0, #4]
   2e81e:	2c00      	cmp	r4, #0
   2e820:	d0a1      	beq.n	2e766 <ip_interface_connect+0xaa>
   2e822:	f8c0 8004 	str.w	r8, [r0, #4]
   2e826:	e7db      	b.n	2e7e0 <ip_interface_connect+0x124>
   2e828:	240c      	movs	r4, #12
   2e82a:	e797      	b.n	2e75c <ip_interface_connect+0xa0>
   2e82c:	2409      	movs	r4, #9
   2e82e:	e795      	b.n	2e75c <ip_interface_connect+0xa0>

0002e830 <ip_interface_bind>:
   2e830:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2e834:	b083      	sub	sp, #12
   2e836:	b3b1      	cbz	r1, 2e8a6 <ip_interface_bind+0x76>
   2e838:	4616      	mov	r6, r2
   2e83a:	b3a2      	cbz	r2, 2e8a6 <ip_interface_bind+0x76>
   2e83c:	4607      	mov	r7, r0
   2e83e:	4688      	mov	r8, r1
   2e840:	f000 ffce 	bl	2f7e0 <interface_socket_from_handle_get>
   2e844:	4605      	mov	r5, r0
   2e846:	2800      	cmp	r0, #0
   2e848:	d04a      	beq.n	2e8e0 <ip_interface_bind+0xb0>
   2e84a:	6803      	ldr	r3, [r0, #0]
   2e84c:	b29b      	uxth	r3, r3
   2e84e:	2b02      	cmp	r3, #2
   2e850:	d146      	bne.n	2e8e0 <ip_interface_bind+0xb0>
   2e852:	2100      	movs	r1, #0
   2e854:	a802      	add	r0, sp, #8
   2e856:	f840 1d04 	str.w	r1, [r0, #-4]!
   2e85a:	f8d5 9018 	ldr.w	r9, [r5, #24]
   2e85e:	f7fb fedb 	bl	2a618 <rpc_ip_client_request_alloc>
   2e862:	bb50      	cbnz	r0, 2e8ba <ip_interface_bind+0x8a>
   2e864:	f247 0305 	movw	r3, #28677	; 0x7005
   2e868:	2208      	movs	r2, #8
   2e86a:	9c01      	ldr	r4, [sp, #4]
   2e86c:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
   2e870:	60e3      	str	r3, [r4, #12]
   2e872:	f8c4 9010 	str.w	r9, [r4, #16]
   2e876:	7260      	strb	r0, [r4, #9]
   2e878:	72a0      	strb	r0, [r4, #10]
   2e87a:	72e0      	strb	r0, [r4, #11]
   2e87c:	7222      	strb	r2, [r4, #8]
   2e87e:	68a3      	ldr	r3, [r4, #8]
   2e880:	3304      	adds	r3, #4
   2e882:	60a3      	str	r3, [r4, #8]
   2e884:	68eb      	ldr	r3, [r5, #12]
   2e886:	f8d8 2004 	ldr.w	r2, [r8, #4]
   2e88a:	4293      	cmp	r3, r2
   2e88c:	d11a      	bne.n	2e8c4 <ip_interface_bind+0x94>
   2e88e:	f898 2000 	ldrb.w	r2, [r8]
   2e892:	4296      	cmp	r6, r2
   2e894:	d107      	bne.n	2e8a6 <ip_interface_bind+0x76>
   2e896:	2b02      	cmp	r3, #2
   2e898:	f104 0018 	add.w	r0, r4, #24
   2e89c:	d014      	beq.n	2e8c8 <ip_interface_bind+0x98>
   2e89e:	2b0a      	cmp	r3, #10
   2e8a0:	d101      	bne.n	2e8a6 <ip_interface_bind+0x76>
   2e8a2:	2e24      	cmp	r6, #36	; 0x24
   2e8a4:	d01e      	beq.n	2e8e4 <ip_interface_bind+0xb4>
   2e8a6:	2416      	movs	r4, #22
   2e8a8:	4620      	mov	r0, r4
   2e8aa:	f7f9 f8d9 	bl	27a60 <bsd_os_errno_set>
   2e8ae:	f04f 34ff 	mov.w	r4, #4294967295
   2e8b2:	4620      	mov	r0, r4
   2e8b4:	b003      	add	sp, #12
   2e8b6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2e8ba:	9c01      	ldr	r4, [sp, #4]
   2e8bc:	2c00      	cmp	r4, #0
   2e8be:	d1de      	bne.n	2e87e <ip_interface_bind+0x4e>
   2e8c0:	240c      	movs	r4, #12
   2e8c2:	e7f1      	b.n	2e8a8 <ip_interface_bind+0x78>
   2e8c4:	242f      	movs	r4, #47	; 0x2f
   2e8c6:	e7ef      	b.n	2e8a8 <ip_interface_bind+0x78>
   2e8c8:	2e10      	cmp	r6, #16
   2e8ca:	d1ec      	bne.n	2e8a6 <ip_interface_bind+0x76>
   2e8cc:	2204      	movs	r2, #4
   2e8ce:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   2e8d2:	f108 010c 	add.w	r1, r8, #12
   2e8d6:	82e2      	strh	r2, [r4, #22]
   2e8d8:	82a3      	strh	r3, [r4, #20]
   2e8da:	f00b fa50 	bl	39d7e <memcpy>
   2e8de:	e00a      	b.n	2e8f6 <ip_interface_bind+0xc6>
   2e8e0:	2409      	movs	r4, #9
   2e8e2:	e7e1      	b.n	2e8a8 <ip_interface_bind+0x78>
   2e8e4:	2210      	movs	r2, #16
   2e8e6:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   2e8ea:	eb08 0102 	add.w	r1, r8, r2
   2e8ee:	82e2      	strh	r2, [r4, #22]
   2e8f0:	82a3      	strh	r3, [r4, #20]
   2e8f2:	f00b fa44 	bl	39d7e <memcpy>
   2e8f6:	68a3      	ldr	r3, [r4, #8]
   2e8f8:	8ae2      	ldrh	r2, [r4, #22]
   2e8fa:	f247 0105 	movw	r1, #28677	; 0x7005
   2e8fe:	4413      	add	r3, r2
   2e900:	60a3      	str	r3, [r4, #8]
   2e902:	682b      	ldr	r3, [r5, #0]
   2e904:	4620      	mov	r0, r4
   2e906:	0c1b      	lsrs	r3, r3, #16
   2e908:	041b      	lsls	r3, r3, #16
   2e90a:	f043 0303 	orr.w	r3, r3, #3
   2e90e:	602b      	str	r3, [r5, #0]
   2e910:	682e      	ldr	r6, [r5, #0]
   2e912:	f7fb fe95 	bl	2a640 <rpc_ip_client_request_send>
   2e916:	4680      	mov	r8, r0
   2e918:	b980      	cbnz	r0, 2e93c <ip_interface_bind+0x10c>
   2e91a:	f04f 33ff 	mov.w	r3, #4294967295
   2e91e:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2e922:	2104      	movs	r1, #4
   2e924:	4638      	mov	r0, r7
   2e926:	f000 fee7 	bl	2f6f8 <interface_socket_wait>
   2e92a:	4604      	mov	r4, r0
   2e92c:	b1a0      	cbz	r0, 2e958 <ip_interface_bind+0x128>
   2e92e:	682b      	ldr	r3, [r5, #0]
   2e930:	0c1b      	lsrs	r3, r3, #16
   2e932:	041b      	lsls	r3, r3, #16
   2e934:	f043 0302 	orr.w	r3, r3, #2
   2e938:	602b      	str	r3, [r5, #0]
   2e93a:	e7b5      	b.n	2e8a8 <ip_interface_bind+0x78>
   2e93c:	6820      	ldr	r0, [r4, #0]
   2e93e:	b108      	cbz	r0, 2e944 <ip_interface_bind+0x114>
   2e940:	f7fb fe9c 	bl	2a67c <rpc_ip_client_data_free>
   2e944:	0c36      	lsrs	r6, r6, #16
   2e946:	0436      	lsls	r6, r6, #16
   2e948:	4620      	mov	r0, r4
   2e94a:	f046 0602 	orr.w	r6, r6, #2
   2e94e:	f7fb fe8d 	bl	2a66c <rpc_ip_client_message_free>
   2e952:	2423      	movs	r4, #35	; 0x23
   2e954:	602e      	str	r6, [r5, #0]
   2e956:	e7a7      	b.n	2e8a8 <ip_interface_bind+0x78>
   2e958:	4638      	mov	r0, r7
   2e95a:	f000 ff41 	bl	2f7e0 <interface_socket_from_handle_get>
   2e95e:	2800      	cmp	r0, #0
   2e960:	d0a7      	beq.n	2e8b2 <ip_interface_bind+0x82>
   2e962:	6844      	ldr	r4, [r0, #4]
   2e964:	2c00      	cmp	r4, #0
   2e966:	d0a4      	beq.n	2e8b2 <ip_interface_bind+0x82>
   2e968:	f8c0 8004 	str.w	r8, [r0, #4]
   2e96c:	e7df      	b.n	2e92e <ip_interface_bind+0xfe>
   2e96e:	bf00      	nop

0002e970 <ip_interface_listen>:
   2e970:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2e974:	b082      	sub	sp, #8
   2e976:	4606      	mov	r6, r0
   2e978:	f000 ff32 	bl	2f7e0 <interface_socket_from_handle_get>
   2e97c:	2800      	cmp	r0, #0
   2e97e:	d067      	beq.n	2ea50 <ip_interface_listen+0xe0>
   2e980:	6803      	ldr	r3, [r0, #0]
   2e982:	4605      	mov	r5, r0
   2e984:	b29b      	uxth	r3, r3
   2e986:	2b04      	cmp	r3, #4
   2e988:	d162      	bne.n	2ea50 <ip_interface_listen+0xe0>
   2e98a:	2100      	movs	r1, #0
   2e98c:	4a32      	ldr	r2, [pc, #200]	; (2ea58 <ip_interface_listen+0xe8>)
   2e98e:	4630      	mov	r0, r6
   2e990:	f000 fe7a 	bl	2f688 <interface_socket_packet_handler_update>
   2e994:	4601      	mov	r1, r0
   2e996:	2800      	cmp	r0, #0
   2e998:	d15c      	bne.n	2ea54 <ip_interface_listen+0xe4>
   2e99a:	a802      	add	r0, sp, #8
   2e99c:	f840 1d04 	str.w	r1, [r0, #-4]!
   2e9a0:	69af      	ldr	r7, [r5, #24]
   2e9a2:	f7fb fe39 	bl	2a618 <rpc_ip_client_request_alloc>
   2e9a6:	bba8      	cbnz	r0, 2ea14 <ip_interface_listen+0xa4>
   2e9a8:	f247 0308 	movw	r3, #28680	; 0x7008
   2e9ac:	2208      	movs	r2, #8
   2e9ae:	9c01      	ldr	r4, [sp, #4]
   2e9b0:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   2e9b4:	60e3      	str	r3, [r4, #12]
   2e9b6:	6127      	str	r7, [r4, #16]
   2e9b8:	7260      	strb	r0, [r4, #9]
   2e9ba:	72a0      	strb	r0, [r4, #10]
   2e9bc:	72e0      	strb	r0, [r4, #11]
   2e9be:	7222      	strb	r2, [r4, #8]
   2e9c0:	68a3      	ldr	r3, [r4, #8]
   2e9c2:	f247 0108 	movw	r1, #28680	; 0x7008
   2e9c6:	3304      	adds	r3, #4
   2e9c8:	60a3      	str	r3, [r4, #8]
   2e9ca:	682b      	ldr	r3, [r5, #0]
   2e9cc:	4620      	mov	r0, r4
   2e9ce:	0c1b      	lsrs	r3, r3, #16
   2e9d0:	041b      	lsls	r3, r3, #16
   2e9d2:	f043 0306 	orr.w	r3, r3, #6
   2e9d6:	602b      	str	r3, [r5, #0]
   2e9d8:	682f      	ldr	r7, [r5, #0]
   2e9da:	f7fb fe31 	bl	2a640 <rpc_ip_client_request_send>
   2e9de:	4680      	mov	r8, r0
   2e9e0:	b9e8      	cbnz	r0, 2ea1e <ip_interface_listen+0xae>
   2e9e2:	f04f 33ff 	mov.w	r3, #4294967295
   2e9e6:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2e9ea:	2107      	movs	r1, #7
   2e9ec:	4630      	mov	r0, r6
   2e9ee:	f000 fe83 	bl	2f6f8 <interface_socket_wait>
   2e9f2:	4604      	mov	r4, r0
   2e9f4:	b308      	cbz	r0, 2ea3a <ip_interface_listen+0xca>
   2e9f6:	682b      	ldr	r3, [r5, #0]
   2e9f8:	0c1b      	lsrs	r3, r3, #16
   2e9fa:	041b      	lsls	r3, r3, #16
   2e9fc:	f043 0304 	orr.w	r3, r3, #4
   2ea00:	602b      	str	r3, [r5, #0]
   2ea02:	4620      	mov	r0, r4
   2ea04:	f7f9 f82c 	bl	27a60 <bsd_os_errno_set>
   2ea08:	f04f 34ff 	mov.w	r4, #4294967295
   2ea0c:	4620      	mov	r0, r4
   2ea0e:	b002      	add	sp, #8
   2ea10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2ea14:	9c01      	ldr	r4, [sp, #4]
   2ea16:	2c00      	cmp	r4, #0
   2ea18:	d1d2      	bne.n	2e9c0 <ip_interface_listen+0x50>
   2ea1a:	240c      	movs	r4, #12
   2ea1c:	e7f1      	b.n	2ea02 <ip_interface_listen+0x92>
   2ea1e:	6820      	ldr	r0, [r4, #0]
   2ea20:	b108      	cbz	r0, 2ea26 <ip_interface_listen+0xb6>
   2ea22:	f7fb fe2b 	bl	2a67c <rpc_ip_client_data_free>
   2ea26:	0c3f      	lsrs	r7, r7, #16
   2ea28:	043f      	lsls	r7, r7, #16
   2ea2a:	4620      	mov	r0, r4
   2ea2c:	f047 0704 	orr.w	r7, r7, #4
   2ea30:	f7fb fe1c 	bl	2a66c <rpc_ip_client_message_free>
   2ea34:	2423      	movs	r4, #35	; 0x23
   2ea36:	602f      	str	r7, [r5, #0]
   2ea38:	e7e3      	b.n	2ea02 <ip_interface_listen+0x92>
   2ea3a:	4630      	mov	r0, r6
   2ea3c:	f000 fed0 	bl	2f7e0 <interface_socket_from_handle_get>
   2ea40:	2800      	cmp	r0, #0
   2ea42:	d0e3      	beq.n	2ea0c <ip_interface_listen+0x9c>
   2ea44:	6844      	ldr	r4, [r0, #4]
   2ea46:	2c00      	cmp	r4, #0
   2ea48:	d0e0      	beq.n	2ea0c <ip_interface_listen+0x9c>
   2ea4a:	f8c0 8004 	str.w	r8, [r0, #4]
   2ea4e:	e7d2      	b.n	2e9f6 <ip_interface_listen+0x86>
   2ea50:	2409      	movs	r4, #9
   2ea52:	e7d6      	b.n	2ea02 <ip_interface_listen+0x92>
   2ea54:	2423      	movs	r4, #35	; 0x23
   2ea56:	e7d4      	b.n	2ea02 <ip_interface_listen+0x92>
   2ea58:	0002de35 	.word	0x0002de35

0002ea5c <ip_interface_accept>:
   2ea5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2ea60:	2500      	movs	r5, #0
   2ea62:	b085      	sub	sp, #20
   2ea64:	460f      	mov	r7, r1
   2ea66:	4690      	mov	r8, r2
   2ea68:	9502      	str	r5, [sp, #8]
   2ea6a:	4606      	mov	r6, r0
   2ea6c:	f000 feb8 	bl	2f7e0 <interface_socket_from_handle_get>
   2ea70:	4604      	mov	r4, r0
   2ea72:	2800      	cmp	r0, #0
   2ea74:	f000 811c 	beq.w	2ecb0 <ip_interface_accept+0x254>
   2ea78:	6803      	ldr	r3, [r0, #0]
   2ea7a:	b29b      	uxth	r3, r3
   2ea7c:	2b07      	cmp	r3, #7
   2ea7e:	d10a      	bne.n	2ea96 <ip_interface_accept+0x3a>
   2ea80:	6803      	ldr	r3, [r0, #0]
   2ea82:	6805      	ldr	r5, [r0, #0]
   2ea84:	00db      	lsls	r3, r3, #3
   2ea86:	d416      	bmi.n	2eab6 <ip_interface_accept+0x5a>
   2ea88:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   2ea8c:	d019      	beq.n	2eac2 <ip_interface_accept+0x66>
   2ea8e:	6805      	ldr	r5, [r0, #0]
   2ea90:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   2ea94:	d124      	bne.n	2eae0 <ip_interface_accept+0x84>
   2ea96:	f04f 0909 	mov.w	r9, #9
   2ea9a:	9b02      	ldr	r3, [sp, #8]
   2ea9c:	b113      	cbz	r3, 2eaa4 <ip_interface_accept+0x48>
   2ea9e:	4628      	mov	r0, r5
   2eaa0:	f000 fddc 	bl	2f65c <interface_socket_free>
   2eaa4:	4648      	mov	r0, r9
   2eaa6:	f04f 39ff 	mov.w	r9, #4294967295
   2eaaa:	f7f8 ffd9 	bl	27a60 <bsd_os_errno_set>
   2eaae:	4648      	mov	r0, r9
   2eab0:	b005      	add	sp, #20
   2eab2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2eab6:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   2eaba:	d16d      	bne.n	2eb98 <ip_interface_accept+0x13c>
   2eabc:	f04f 0923 	mov.w	r9, #35	; 0x23
   2eac0:	e7eb      	b.n	2ea9a <ip_interface_accept+0x3e>
   2eac2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   2eac6:	f04f 33ff 	mov.w	r3, #4294967295
   2eaca:	4611      	mov	r1, r2
   2eacc:	4630      	mov	r0, r6
   2eace:	f000 fe13 	bl	2f6f8 <interface_socket_wait>
   2ead2:	4681      	mov	r9, r0
   2ead4:	2800      	cmp	r0, #0
   2ead6:	d07e      	beq.n	2ebd6 <ip_interface_accept+0x17a>
   2ead8:	6825      	ldr	r5, [r4, #0]
   2eada:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   2eade:	d0dc      	beq.n	2ea9a <ip_interface_accept+0x3e>
   2eae0:	f04f 30ff 	mov.w	r0, #4294967295
   2eae4:	2300      	movs	r3, #0
   2eae6:	e9cd 0300 	strd	r0, r3, [sp]
   2eaea:	4a75      	ldr	r2, [pc, #468]	; (2ecc0 <ip_interface_accept+0x264>)
   2eaec:	6921      	ldr	r1, [r4, #16]
   2eaee:	a802      	add	r0, sp, #8
   2eaf0:	f000 fd50 	bl	2f594 <interface_socket_allocate>
   2eaf4:	9b02      	ldr	r3, [sp, #8]
   2eaf6:	4605      	mov	r5, r0
   2eaf8:	2b00      	cmp	r3, #0
   2eafa:	f000 80dd 	beq.w	2ecb8 <ip_interface_accept+0x25c>
   2eafe:	2100      	movs	r1, #0
   2eb00:	6962      	ldr	r2, [r4, #20]
   2eb02:	a804      	add	r0, sp, #16
   2eb04:	615a      	str	r2, [r3, #20]
   2eb06:	68e2      	ldr	r2, [r4, #12]
   2eb08:	f840 1d04 	str.w	r1, [r0, #-4]!
   2eb0c:	60da      	str	r2, [r3, #12]
   2eb0e:	6922      	ldr	r2, [r4, #16]
   2eb10:	611a      	str	r2, [r3, #16]
   2eb12:	f8d4 9018 	ldr.w	r9, [r4, #24]
   2eb16:	f7fb fd7f 	bl	2a618 <rpc_ip_client_request_alloc>
   2eb1a:	2800      	cmp	r0, #0
   2eb1c:	d143      	bne.n	2eba6 <ip_interface_accept+0x14a>
   2eb1e:	f247 030c 	movw	r3, #28684	; 0x700c
   2eb22:	2108      	movs	r1, #8
   2eb24:	f8dd b00c 	ldr.w	fp, [sp, #12]
   2eb28:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   2eb2c:	f8cb 300c 	str.w	r3, [fp, #12]
   2eb30:	f8cb 9010 	str.w	r9, [fp, #16]
   2eb34:	f88b 0009 	strb.w	r0, [fp, #9]
   2eb38:	f88b 000a 	strb.w	r0, [fp, #10]
   2eb3c:	f88b 000b 	strb.w	r0, [fp, #11]
   2eb40:	f88b 1008 	strb.w	r1, [fp, #8]
   2eb44:	6823      	ldr	r3, [r4, #0]
   2eb46:	f247 010c 	movw	r1, #28684	; 0x700c
   2eb4a:	0c1b      	lsrs	r3, r3, #16
   2eb4c:	041b      	lsls	r3, r3, #16
   2eb4e:	f043 0308 	orr.w	r3, r3, #8
   2eb52:	6023      	str	r3, [r4, #0]
   2eb54:	4658      	mov	r0, fp
   2eb56:	f8d4 9000 	ldr.w	r9, [r4]
   2eb5a:	f7fb fd71 	bl	2a640 <rpc_ip_client_request_send>
   2eb5e:	4682      	mov	sl, r0
   2eb60:	bb48      	cbnz	r0, 2ebb6 <ip_interface_accept+0x15a>
   2eb62:	6822      	ldr	r2, [r4, #0]
   2eb64:	9900      	ldr	r1, [sp, #0]
   2eb66:	f04f 33ff 	mov.w	r3, #4294967295
   2eb6a:	400a      	ands	r2, r1
   2eb6c:	6022      	str	r2, [r4, #0]
   2eb6e:	2109      	movs	r1, #9
   2eb70:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2eb74:	4630      	mov	r0, r6
   2eb76:	f000 fdbf 	bl	2f6f8 <interface_socket_wait>
   2eb7a:	4681      	mov	r9, r0
   2eb7c:	2800      	cmp	r0, #0
   2eb7e:	f000 8085 	beq.w	2ec8c <ip_interface_accept+0x230>
   2eb82:	6823      	ldr	r3, [r4, #0]
   2eb84:	9a01      	ldr	r2, [sp, #4]
   2eb86:	431a      	orrs	r2, r3
   2eb88:	6022      	str	r2, [r4, #0]
   2eb8a:	6823      	ldr	r3, [r4, #0]
   2eb8c:	0c1b      	lsrs	r3, r3, #16
   2eb8e:	041b      	lsls	r3, r3, #16
   2eb90:	f043 0307 	orr.w	r3, r3, #7
   2eb94:	6023      	str	r3, [r4, #0]
   2eb96:	e780      	b.n	2ea9a <ip_interface_accept+0x3e>
   2eb98:	f06f 5280 	mvn.w	r2, #268435456	; 0x10000000
   2eb9c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   2eba0:	e9cd 2300 	strd	r2, r3, [sp]
   2eba4:	e7a1      	b.n	2eaea <ip_interface_accept+0x8e>
   2eba6:	f8dd b00c 	ldr.w	fp, [sp, #12]
   2ebaa:	f04f 090c 	mov.w	r9, #12
   2ebae:	f1bb 0f00 	cmp.w	fp, #0
   2ebb2:	d1c7      	bne.n	2eb44 <ip_interface_accept+0xe8>
   2ebb4:	e771      	b.n	2ea9a <ip_interface_accept+0x3e>
   2ebb6:	f8db 0000 	ldr.w	r0, [fp]
   2ebba:	b108      	cbz	r0, 2ebc0 <ip_interface_accept+0x164>
   2ebbc:	f7fb fd5e 	bl	2a67c <rpc_ip_client_data_free>
   2ebc0:	ea4f 4919 	mov.w	r9, r9, lsr #16
   2ebc4:	4658      	mov	r0, fp
   2ebc6:	ea4f 4909 	mov.w	r9, r9, lsl #16
   2ebca:	f7fb fd4f 	bl	2a66c <rpc_ip_client_message_free>
   2ebce:	f049 0307 	orr.w	r3, r9, #7
   2ebd2:	6023      	str	r3, [r4, #0]
   2ebd4:	e772      	b.n	2eabc <ip_interface_accept+0x60>
   2ebd6:	4630      	mov	r0, r6
   2ebd8:	f000 fe02 	bl	2f7e0 <interface_socket_from_handle_get>
   2ebdc:	b130      	cbz	r0, 2ebec <ip_interface_accept+0x190>
   2ebde:	f8d0 9004 	ldr.w	r9, [r0, #4]
   2ebe2:	f1b9 0f00 	cmp.w	r9, #0
   2ebe6:	d001      	beq.n	2ebec <ip_interface_accept+0x190>
   2ebe8:	6045      	str	r5, [r0, #4]
   2ebea:	e775      	b.n	2ead8 <ip_interface_accept+0x7c>
   2ebec:	6823      	ldr	r3, [r4, #0]
   2ebee:	03d9      	lsls	r1, r3, #15
   2ebf0:	f53f af76 	bmi.w	2eae0 <ip_interface_accept+0x84>
   2ebf4:	4d33      	ldr	r5, [pc, #204]	; (2ecc4 <ip_interface_accept+0x268>)
   2ebf6:	9902      	ldr	r1, [sp, #8]
   2ebf8:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
   2ebfc:	699b      	ldr	r3, [r3, #24]
   2ebfe:	618b      	str	r3, [r1, #24]
   2ec00:	b147      	cbz	r7, 2ec14 <ip_interface_accept+0x1b8>
   2ec02:	68cb      	ldr	r3, [r1, #12]
   2ec04:	2b0a      	cmp	r3, #10
   2ec06:	d024      	beq.n	2ec52 <ip_interface_accept+0x1f6>
   2ec08:	2b02      	cmp	r3, #2
   2ec0a:	d103      	bne.n	2ec14 <ip_interface_accept+0x1b8>
   2ec0c:	f8d8 2000 	ldr.w	r2, [r8]
   2ec10:	2a10      	cmp	r2, #16
   2ec12:	d032      	beq.n	2ec7a <ip_interface_accept+0x21e>
   2ec14:	680a      	ldr	r2, [r1, #0]
   2ec16:	482c      	ldr	r0, [pc, #176]	; (2ecc8 <ip_interface_accept+0x26c>)
   2ec18:	4002      	ands	r2, r0
   2ec1a:	f042 0205 	orr.w	r2, r2, #5
   2ec1e:	600a      	str	r2, [r1, #0]
   2ec20:	9a02      	ldr	r2, [sp, #8]
   2ec22:	6811      	ldr	r1, [r2, #0]
   2ec24:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
   2ec28:	6011      	str	r1, [r2, #0]
   2ec2a:	6811      	ldr	r1, [r2, #0]
   2ec2c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   2ec30:	6011      	str	r1, [r2, #0]
   2ec32:	6823      	ldr	r3, [r4, #0]
   2ec34:	4003      	ands	r3, r0
   2ec36:	f043 0307 	orr.w	r3, r3, #7
   2ec3a:	6023      	str	r3, [r4, #0]
   2ec3c:	f855 0026 	ldr.w	r0, [r5, r6, lsl #2]
   2ec40:	f7fb fd14 	bl	2a66c <rpc_ip_client_message_free>
   2ec44:	2300      	movs	r3, #0
   2ec46:	4648      	mov	r0, r9
   2ec48:	f845 3026 	str.w	r3, [r5, r6, lsl #2]
   2ec4c:	b005      	add	sp, #20
   2ec4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2ec52:	f8d8 2000 	ldr.w	r2, [r8]
   2ec56:	2a24      	cmp	r2, #36	; 0x24
   2ec58:	d1dc      	bne.n	2ec14 <ip_interface_accept+0x1b8>
   2ec5a:	703a      	strb	r2, [r7, #0]
   2ec5c:	2210      	movs	r2, #16
   2ec5e:	607b      	str	r3, [r7, #4]
   2ec60:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
   2ec64:	f107 0010 	add.w	r0, r7, #16
   2ec68:	8b9b      	ldrh	r3, [r3, #28]
   2ec6a:	813b      	strh	r3, [r7, #8]
   2ec6c:	f855 1026 	ldr.w	r1, [r5, r6, lsl #2]
   2ec70:	3120      	adds	r1, #32
   2ec72:	f00b f884 	bl	39d7e <memcpy>
   2ec76:	9902      	ldr	r1, [sp, #8]
   2ec78:	e7cc      	b.n	2ec14 <ip_interface_accept+0x1b8>
   2ec7a:	703a      	strb	r2, [r7, #0]
   2ec7c:	607b      	str	r3, [r7, #4]
   2ec7e:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
   2ec82:	f107 000c 	add.w	r0, r7, #12
   2ec86:	8b9b      	ldrh	r3, [r3, #28]
   2ec88:	2204      	movs	r2, #4
   2ec8a:	e7ee      	b.n	2ec6a <ip_interface_accept+0x20e>
   2ec8c:	4630      	mov	r0, r6
   2ec8e:	f000 fda7 	bl	2f7e0 <interface_socket_from_handle_get>
   2ec92:	b138      	cbz	r0, 2eca4 <ip_interface_accept+0x248>
   2ec94:	f8d0 9004 	ldr.w	r9, [r0, #4]
   2ec98:	f1b9 0f00 	cmp.w	r9, #0
   2ec9c:	d002      	beq.n	2eca4 <ip_interface_accept+0x248>
   2ec9e:	f8c0 a004 	str.w	sl, [r0, #4]
   2eca2:	e76e      	b.n	2eb82 <ip_interface_accept+0x126>
   2eca4:	6823      	ldr	r3, [r4, #0]
   2eca6:	9a01      	ldr	r2, [sp, #4]
   2eca8:	46a9      	mov	r9, r5
   2ecaa:	4313      	orrs	r3, r2
   2ecac:	6023      	str	r3, [r4, #0]
   2ecae:	e7a1      	b.n	2ebf4 <ip_interface_accept+0x198>
   2ecb0:	4605      	mov	r5, r0
   2ecb2:	f04f 0909 	mov.w	r9, #9
   2ecb6:	e6f0      	b.n	2ea9a <ip_interface_accept+0x3e>
   2ecb8:	f04f 090c 	mov.w	r9, #12
   2ecbc:	e6f2      	b.n	2eaa4 <ip_interface_accept+0x48>
   2ecbe:	bf00      	nop
   2ecc0:	0002de35 	.word	0x0002de35
   2ecc4:	20020cfc 	.word	0x20020cfc
   2ecc8:	ffff0000 	.word	0xffff0000

0002eccc <ip_interface_setopt>:
   2eccc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2ecd0:	2901      	cmp	r1, #1
   2ecd2:	b084      	sub	sp, #16
   2ecd4:	f040 809c 	bne.w	2ee10 <ip_interface_setopt+0x144>
   2ecd8:	460e      	mov	r6, r1
   2ecda:	4690      	mov	r8, r2
   2ecdc:	461d      	mov	r5, r3
   2ecde:	4607      	mov	r7, r0
   2ece0:	f000 fd7e 	bl	2f7e0 <interface_socket_from_handle_get>
   2ece4:	4604      	mov	r4, r0
   2ece6:	2800      	cmp	r0, #0
   2ece8:	f000 80a5 	beq.w	2ee36 <ip_interface_setopt+0x16a>
   2ecec:	f1b8 0f19 	cmp.w	r8, #25
   2ecf0:	d16e      	bne.n	2edd0 <ip_interface_setopt+0x104>
   2ecf2:	2d00      	cmp	r5, #0
   2ecf4:	f000 8092 	beq.w	2ee1c <ip_interface_setopt+0x150>
   2ecf8:	4628      	mov	r0, r5
   2ecfa:	f7ee fa2d 	bl	1d158 <strlen>
   2ecfe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2ed00:	4298      	cmp	r0, r3
   2ed02:	f040 808b 	bne.w	2ee1c <ip_interface_setopt+0x150>
   2ed06:	6823      	ldr	r3, [r4, #0]
   2ed08:	b29b      	uxth	r3, r3
   2ed0a:	2b02      	cmp	r3, #2
   2ed0c:	d173      	bne.n	2edf6 <ip_interface_setopt+0x12a>
   2ed0e:	4629      	mov	r1, r5
   2ed10:	68e0      	ldr	r0, [r4, #12]
   2ed12:	f7fe fb2b 	bl	2d36c <pdn_interface_pdn_id_get>
   2ed16:	9002      	str	r0, [sp, #8]
   2ed18:	3001      	adds	r0, #1
   2ed1a:	bf08      	it	eq
   2ed1c:	2516      	moveq	r5, #22
   2ed1e:	d04e      	beq.n	2edbe <ip_interface_setopt+0xf2>
   2ed20:	6823      	ldr	r3, [r4, #0]
   2ed22:	025b      	lsls	r3, r3, #9
   2ed24:	d44a      	bmi.n	2edbc <ip_interface_setopt+0xf0>
   2ed26:	6823      	ldr	r3, [r4, #0]
   2ed28:	f413 0300 	ands.w	r3, r3, #8388608	; 0x800000
   2ed2c:	d146      	bne.n	2edbc <ip_interface_setopt+0xf0>
   2ed2e:	6826      	ldr	r6, [r4, #0]
   2ed30:	6822      	ldr	r2, [r4, #0]
   2ed32:	a804      	add	r0, sp, #16
   2ed34:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
   2ed38:	6022      	str	r2, [r4, #0]
   2ed3a:	2104      	movs	r1, #4
   2ed3c:	f840 3d04 	str.w	r3, [r0, #-4]!
   2ed40:	f8d4 8018 	ldr.w	r8, [r4, #24]
   2ed44:	f7fb fc68 	bl	2a618 <rpc_ip_client_request_alloc>
   2ed48:	2800      	cmp	r0, #0
   2ed4a:	d14e      	bne.n	2edea <ip_interface_setopt+0x11e>
   2ed4c:	f247 0203 	movw	r2, #28675	; 0x7003
   2ed50:	2300      	movs	r3, #0
   2ed52:	2108      	movs	r1, #8
   2ed54:	9d03      	ldr	r5, [sp, #12]
   2ed56:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
   2ed5a:	60ea      	str	r2, [r5, #12]
   2ed5c:	f8c5 8010 	str.w	r8, [r5, #16]
   2ed60:	7229      	strb	r1, [r5, #8]
   2ed62:	726b      	strb	r3, [r5, #9]
   2ed64:	72ab      	strb	r3, [r5, #10]
   2ed66:	72eb      	strb	r3, [r5, #11]
   2ed68:	f04f 0c08 	mov.w	ip, #8
   2ed6c:	2300      	movs	r3, #0
   2ed6e:	2010      	movs	r0, #16
   2ed70:	2130      	movs	r1, #48	; 0x30
   2ed72:	68aa      	ldr	r2, [r5, #8]
   2ed74:	756b      	strb	r3, [r5, #21]
   2ed76:	4462      	add	r2, ip
   2ed78:	60aa      	str	r2, [r5, #8]
   2ed7a:	75ab      	strb	r3, [r5, #22]
   2ed7c:	75eb      	strb	r3, [r5, #23]
   2ed7e:	76ab      	strb	r3, [r5, #26]
   2ed80:	76eb      	strb	r3, [r5, #27]
   2ed82:	f885 c014 	strb.w	ip, [r5, #20]
   2ed86:	7628      	strb	r0, [r5, #24]
   2ed88:	7669      	strb	r1, [r5, #25]
   2ed8a:	2204      	movs	r2, #4
   2ed8c:	eb0d 010c 	add.w	r1, sp, ip
   2ed90:	6828      	ldr	r0, [r5, #0]
   2ed92:	f00a fff4 	bl	39d7e <memcpy>
   2ed96:	f247 0103 	movw	r1, #28675	; 0x7003
   2ed9a:	4628      	mov	r0, r5
   2ed9c:	f7fb fc50 	bl	2a640 <rpc_ip_client_request_send>
   2eda0:	4680      	mov	r8, r0
   2eda2:	bb50      	cbnz	r0, 2edfa <ip_interface_setopt+0x12e>
   2eda4:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   2eda8:	f04f 33ff 	mov.w	r3, #4294967295
   2edac:	4611      	mov	r1, r2
   2edae:	4638      	mov	r0, r7
   2edb0:	f000 fca2 	bl	2f6f8 <interface_socket_wait>
   2edb4:	4605      	mov	r5, r0
   2edb6:	b398      	cbz	r0, 2ee20 <ip_interface_setopt+0x154>
   2edb8:	6026      	str	r6, [r4, #0]
   2edba:	e000      	b.n	2edbe <ip_interface_setopt+0xf2>
   2edbc:	2523      	movs	r5, #35	; 0x23
   2edbe:	4628      	mov	r0, r5
   2edc0:	f7f8 fe4e 	bl	27a60 <bsd_os_errno_set>
   2edc4:	f04f 35ff 	mov.w	r5, #4294967295
   2edc8:	4628      	mov	r0, r5
   2edca:	b004      	add	sp, #16
   2edcc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2edd0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2edd2:	4642      	mov	r2, r8
   2edd4:	9300      	str	r3, [sp, #0]
   2edd6:	4631      	mov	r1, r6
   2edd8:	462b      	mov	r3, r5
   2edda:	4638      	mov	r0, r7
   2eddc:	f000 fd28 	bl	2f830 <interface_socket_setopt>
   2ede0:	4605      	mov	r5, r0
   2ede2:	4628      	mov	r0, r5
   2ede4:	b004      	add	sp, #16
   2ede6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2edea:	9d03      	ldr	r5, [sp, #12]
   2edec:	2d00      	cmp	r5, #0
   2edee:	d1bb      	bne.n	2ed68 <ip_interface_setopt+0x9c>
   2edf0:	6026      	str	r6, [r4, #0]
   2edf2:	250c      	movs	r5, #12
   2edf4:	e7e3      	b.n	2edbe <ip_interface_setopt+0xf2>
   2edf6:	2509      	movs	r5, #9
   2edf8:	e7e1      	b.n	2edbe <ip_interface_setopt+0xf2>
   2edfa:	6828      	ldr	r0, [r5, #0]
   2edfc:	b108      	cbz	r0, 2ee02 <ip_interface_setopt+0x136>
   2edfe:	f7fb fc3d 	bl	2a67c <rpc_ip_client_data_free>
   2ee02:	4628      	mov	r0, r5
   2ee04:	f7fb fc32 	bl	2a66c <rpc_ip_client_message_free>
   2ee08:	2523      	movs	r5, #35	; 0x23
   2ee0a:	6026      	str	r6, [r4, #0]
   2ee0c:	6026      	str	r6, [r4, #0]
   2ee0e:	e7d6      	b.n	2edbe <ip_interface_setopt+0xf2>
   2ee10:	202a      	movs	r0, #42	; 0x2a
   2ee12:	f7f8 fe25 	bl	27a60 <bsd_os_errno_set>
   2ee16:	f04f 35ff 	mov.w	r5, #4294967295
   2ee1a:	e7d5      	b.n	2edc8 <ip_interface_setopt+0xfc>
   2ee1c:	250e      	movs	r5, #14
   2ee1e:	e7ce      	b.n	2edbe <ip_interface_setopt+0xf2>
   2ee20:	4638      	mov	r0, r7
   2ee22:	f000 fcdd 	bl	2f7e0 <interface_socket_from_handle_get>
   2ee26:	b120      	cbz	r0, 2ee32 <ip_interface_setopt+0x166>
   2ee28:	6845      	ldr	r5, [r0, #4]
   2ee2a:	b115      	cbz	r5, 2ee32 <ip_interface_setopt+0x166>
   2ee2c:	f8c0 8004 	str.w	r8, [r0, #4]
   2ee30:	e7c2      	b.n	2edb8 <ip_interface_setopt+0xec>
   2ee32:	6026      	str	r6, [r4, #0]
   2ee34:	e7c8      	b.n	2edc8 <ip_interface_setopt+0xfc>
   2ee36:	2009      	movs	r0, #9
   2ee38:	f7f8 fe12 	bl	27a60 <bsd_os_errno_set>
   2ee3c:	f04f 35ff 	mov.w	r5, #4294967295
   2ee40:	e7c2      	b.n	2edc8 <ip_interface_setopt+0xfc>
   2ee42:	bf00      	nop

0002ee44 <ip_interface_getopt>:
   2ee44:	f000 bd36 	b.w	2f8b4 <interface_socket_getopt>

0002ee48 <ip_interface_getaddrinfo>:
   2ee48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2ee4c:	f04f 0c00 	mov.w	ip, #0
   2ee50:	2401      	movs	r4, #1
   2ee52:	4e72      	ldr	r6, [pc, #456]	; (2f01c <ip_interface_getaddrinfo+0x1d4>)
   2ee54:	f8df a1d0 	ldr.w	sl, [pc, #464]	; 2f028 <ip_interface_getaddrinfo+0x1e0>
   2ee58:	f8df 91d0 	ldr.w	r9, [pc, #464]	; 2f02c <ip_interface_getaddrinfo+0x1e4>
   2ee5c:	b085      	sub	sp, #20
   2ee5e:	4607      	mov	r7, r0
   2ee60:	4615      	mov	r5, r2
   2ee62:	9301      	str	r3, [sp, #4]
   2ee64:	f8a6 c000 	strh.w	ip, [r6]
   2ee68:	f8ca 4000 	str.w	r4, [sl]
   2ee6c:	f8c9 4000 	str.w	r4, [r9]
   2ee70:	b171      	cbz	r1, 2ee90 <ip_interface_getaddrinfo+0x48>
   2ee72:	4608      	mov	r0, r1
   2ee74:	220a      	movs	r2, #10
   2ee76:	4661      	mov	r1, ip
   2ee78:	f007 fb90 	bl	3659c <strtol>
   2ee7c:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   2ee80:	1e42      	subs	r2, r0, #1
   2ee82:	429a      	cmp	r2, r3
   2ee84:	f200 8083 	bhi.w	2ef8e <ip_interface_getaddrinfo+0x146>
   2ee88:	0203      	lsls	r3, r0, #8
   2ee8a:	ea43 2020 	orr.w	r0, r3, r0, asr #8
   2ee8e:	8030      	strh	r0, [r6, #0]
   2ee90:	f8df 819c 	ldr.w	r8, [pc, #412]	; 2f030 <ip_interface_getaddrinfo+0x1e8>
   2ee94:	f8d8 3000 	ldr.w	r3, [r8]
   2ee98:	2b00      	cmp	r3, #0
   2ee9a:	d174      	bne.n	2ef86 <ip_interface_getaddrinfo+0x13e>
   2ee9c:	4a60      	ldr	r2, [pc, #384]	; (2f020 <ip_interface_getaddrinfo+0x1d8>)
   2ee9e:	6013      	str	r3, [r2, #0]
   2eea0:	4a60      	ldr	r2, [pc, #384]	; (2f024 <ip_interface_getaddrinfo+0x1dc>)
   2eea2:	6013      	str	r3, [r2, #0]
   2eea4:	2f00      	cmp	r7, #0
   2eea6:	d062      	beq.n	2ef6e <ip_interface_getaddrinfo+0x126>
   2eea8:	4638      	mov	r0, r7
   2eeaa:	f7ee f955 	bl	1d158 <strlen>
   2eeae:	4683      	mov	fp, r0
   2eeb0:	b125      	cbz	r5, 2eebc <ip_interface_getaddrinfo+0x74>
   2eeb2:	69ea      	ldr	r2, [r5, #28]
   2eeb4:	b112      	cbz	r2, 2eebc <ip_interface_getaddrinfo+0x74>
   2eeb6:	6851      	ldr	r1, [r2, #4]
   2eeb8:	2966      	cmp	r1, #102	; 0x66
   2eeba:	d06c      	beq.n	2ef96 <ip_interface_getaddrinfo+0x14e>
   2eebc:	f04f 32ff 	mov.w	r2, #4294967295
   2eec0:	2100      	movs	r1, #0
   2eec2:	ae04      	add	r6, sp, #16
   2eec4:	f846 1d04 	str.w	r1, [r6, #-4]!
   2eec8:	4630      	mov	r0, r6
   2eeca:	4659      	mov	r1, fp
   2eecc:	9200      	str	r2, [sp, #0]
   2eece:	f7fb fba3 	bl	2a618 <rpc_ip_client_request_alloc>
   2eed2:	9a00      	ldr	r2, [sp, #0]
   2eed4:	2800      	cmp	r0, #0
   2eed6:	d14c      	bne.n	2ef72 <ip_interface_getaddrinfo+0x12a>
   2eed8:	f247 010d 	movw	r1, #28685	; 0x700d
   2eedc:	f04f 0c08 	mov.w	ip, #8
   2eee0:	9c03      	ldr	r4, [sp, #12]
   2eee2:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   2eee6:	60e1      	str	r1, [r4, #12]
   2eee8:	6122      	str	r2, [r4, #16]
   2eeea:	7260      	strb	r0, [r4, #9]
   2eeec:	72a0      	strb	r0, [r4, #10]
   2eeee:	72e0      	strb	r0, [r4, #11]
   2eef0:	f884 c008 	strb.w	ip, [r4, #8]
   2eef4:	2d00      	cmp	r5, #0
   2eef6:	d076      	beq.n	2efe6 <ip_interface_getaddrinfo+0x19e>
   2eef8:	686a      	ldr	r2, [r5, #4]
   2eefa:	f022 0108 	bic.w	r1, r2, #8
   2eefe:	2902      	cmp	r1, #2
   2ef00:	d05c      	beq.n	2efbc <ip_interface_getaddrinfo+0x174>
   2ef02:	2a05      	cmp	r2, #5
   2ef04:	d178      	bne.n	2eff8 <ip_interface_getaddrinfo+0x1b0>
   2ef06:	68a9      	ldr	r1, [r5, #8]
   2ef08:	2902      	cmp	r1, #2
   2ef0a:	f8c9 1000 	str.w	r1, [r9]
   2ef0e:	d061      	beq.n	2efd4 <ip_interface_getaddrinfo+0x18c>
   2ef10:	61a2      	str	r2, [r4, #24]
   2ef12:	68ea      	ldr	r2, [r5, #12]
   2ef14:	6222      	str	r2, [r4, #32]
   2ef16:	68aa      	ldr	r2, [r5, #8]
   2ef18:	61e2      	str	r2, [r4, #28]
   2ef1a:	682a      	ldr	r2, [r5, #0]
   2ef1c:	6162      	str	r2, [r4, #20]
   2ef1e:	68a2      	ldr	r2, [r4, #8]
   2ef20:	3210      	adds	r2, #16
   2ef22:	60a2      	str	r2, [r4, #8]
   2ef24:	b12f      	cbz	r7, 2ef32 <ip_interface_getaddrinfo+0xea>
   2ef26:	6820      	ldr	r0, [r4, #0]
   2ef28:	b118      	cbz	r0, 2ef32 <ip_interface_getaddrinfo+0xea>
   2ef2a:	465a      	mov	r2, fp
   2ef2c:	4639      	mov	r1, r7
   2ef2e:	f00a ff26 	bl	39d7e <memcpy>
   2ef32:	2301      	movs	r3, #1
   2ef34:	f247 010d 	movw	r1, #28685	; 0x700d
   2ef38:	4620      	mov	r0, r4
   2ef3a:	f8c8 3000 	str.w	r3, [r8]
   2ef3e:	f7fb fb7f 	bl	2a640 <rpc_ip_client_request_send>
   2ef42:	2800      	cmp	r0, #0
   2ef44:	d156      	bne.n	2eff4 <ip_interface_getaddrinfo+0x1ac>
   2ef46:	f04f 33ff 	mov.w	r3, #4294967295
   2ef4a:	9303      	str	r3, [sp, #12]
   2ef4c:	4631      	mov	r1, r6
   2ef4e:	4620      	mov	r0, r4
   2ef50:	f7f8 fcf2 	bl	27938 <bsd_os_timedwait>
   2ef54:	f8d8 3000 	ldr.w	r3, [r8]
   2ef58:	2b01      	cmp	r3, #1
   2ef5a:	d0f7      	beq.n	2ef4c <ip_interface_getaddrinfo+0x104>
   2ef5c:	4b31      	ldr	r3, [pc, #196]	; (2f024 <ip_interface_getaddrinfo+0x1dc>)
   2ef5e:	6818      	ldr	r0, [r3, #0]
   2ef60:	2800      	cmp	r0, #0
   2ef62:	d13b      	bne.n	2efdc <ip_interface_getaddrinfo+0x194>
   2ef64:	4b2e      	ldr	r3, [pc, #184]	; (2f020 <ip_interface_getaddrinfo+0x1d8>)
   2ef66:	9a01      	ldr	r2, [sp, #4]
   2ef68:	681b      	ldr	r3, [r3, #0]
   2ef6a:	6013      	str	r3, [r2, #0]
   2ef6c:	e00c      	b.n	2ef88 <ip_interface_getaddrinfo+0x140>
   2ef6e:	46bb      	mov	fp, r7
   2ef70:	e79e      	b.n	2eeb0 <ip_interface_getaddrinfo+0x68>
   2ef72:	9c03      	ldr	r4, [sp, #12]
   2ef74:	2c00      	cmp	r4, #0
   2ef76:	d1bd      	bne.n	2eef4 <ip_interface_getaddrinfo+0xac>
   2ef78:	200c      	movs	r0, #12
   2ef7a:	2300      	movs	r3, #0
   2ef7c:	f8c8 3000 	str.w	r3, [r8]
   2ef80:	b005      	add	sp, #20
   2ef82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2ef86:	2073      	movs	r0, #115	; 0x73
   2ef88:	b005      	add	sp, #20
   2ef8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2ef8e:	2016      	movs	r0, #22
   2ef90:	b005      	add	sp, #20
   2ef92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2ef96:	6891      	ldr	r1, [r2, #8]
   2ef98:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   2ef9c:	d18e      	bne.n	2eebc <ip_interface_getaddrinfo+0x74>
   2ef9e:	f240 2102 	movw	r1, #514	; 0x202
   2efa2:	68d0      	ldr	r0, [r2, #12]
   2efa4:	4288      	cmp	r0, r1
   2efa6:	d189      	bne.n	2eebc <ip_interface_getaddrinfo+0x74>
   2efa8:	6991      	ldr	r1, [r2, #24]
   2efaa:	2900      	cmp	r1, #0
   2efac:	d086      	beq.n	2eebc <ip_interface_getaddrinfo+0x74>
   2efae:	6868      	ldr	r0, [r5, #4]
   2efb0:	f7fe f9dc 	bl	2d36c <pdn_interface_pdn_id_get>
   2efb4:	1c43      	adds	r3, r0, #1
   2efb6:	d081      	beq.n	2eebc <ip_interface_getaddrinfo+0x74>
   2efb8:	4602      	mov	r2, r0
   2efba:	e781      	b.n	2eec0 <ip_interface_getaddrinfo+0x78>
   2efbc:	68a9      	ldr	r1, [r5, #8]
   2efbe:	2902      	cmp	r1, #2
   2efc0:	f8c9 1000 	str.w	r1, [r9]
   2efc4:	d006      	beq.n	2efd4 <ip_interface_getaddrinfo+0x18c>
   2efc6:	2a05      	cmp	r2, #5
   2efc8:	d0a2      	beq.n	2ef10 <ip_interface_getaddrinfo+0xc8>
   2efca:	2a0a      	cmp	r2, #10
   2efcc:	bf14      	ite	ne
   2efce:	2201      	movne	r2, #1
   2efd0:	2202      	moveq	r2, #2
   2efd2:	e79d      	b.n	2ef10 <ip_interface_getaddrinfo+0xc8>
   2efd4:	2102      	movs	r1, #2
   2efd6:	f8ca 1000 	str.w	r1, [sl]
   2efda:	e7f4      	b.n	2efc6 <ip_interface_getaddrinfo+0x17e>
   2efdc:	4b11      	ldr	r3, [pc, #68]	; (2f024 <ip_interface_getaddrinfo+0x1dc>)
   2efde:	6818      	ldr	r0, [r3, #0]
   2efe0:	2800      	cmp	r0, #0
   2efe2:	d0d1      	beq.n	2ef88 <ip_interface_getaddrinfo+0x140>
   2efe4:	e7c9      	b.n	2ef7a <ip_interface_getaddrinfo+0x132>
   2efe6:	4629      	mov	r1, r5
   2efe8:	2210      	movs	r2, #16
   2efea:	f104 0014 	add.w	r0, r4, #20
   2efee:	f00a fee6 	bl	39dbe <memset>
   2eff2:	e794      	b.n	2ef1e <ip_interface_getaddrinfo+0xd6>
   2eff4:	2023      	movs	r0, #35	; 0x23
   2eff6:	e7c0      	b.n	2ef7a <ip_interface_getaddrinfo+0x132>
   2eff8:	202f      	movs	r0, #47	; 0x2f
   2effa:	f7f8 fd31 	bl	27a60 <bsd_os_errno_set>
   2effe:	68a2      	ldr	r2, [r4, #8]
   2f000:	3210      	adds	r2, #16
   2f002:	60a2      	str	r2, [r4, #8]
   2f004:	b917      	cbnz	r7, 2f00c <ip_interface_getaddrinfo+0x1c4>
   2f006:	f04f 30ff 	mov.w	r0, #4294967295
   2f00a:	e7b6      	b.n	2ef7a <ip_interface_getaddrinfo+0x132>
   2f00c:	6820      	ldr	r0, [r4, #0]
   2f00e:	2800      	cmp	r0, #0
   2f010:	d0f9      	beq.n	2f006 <ip_interface_getaddrinfo+0x1be>
   2f012:	465a      	mov	r2, fp
   2f014:	4639      	mov	r1, r7
   2f016:	f00a feb2 	bl	39d7e <memcpy>
   2f01a:	e7f4      	b.n	2f006 <ip_interface_getaddrinfo+0x1be>
   2f01c:	2002229a 	.word	0x2002229a
   2f020:	20020cf4 	.word	0x20020cf4
   2f024:	20020cec 	.word	0x20020cec
   2f028:	20020ce4 	.word	0x20020ce4
   2f02c:	20020ce8 	.word	0x20020ce8
   2f030:	20020cf0 	.word	0x20020cf0

0002f034 <ip_interface_freeaddrinfo>:
   2f034:	b538      	push	{r3, r4, r5, lr}
   2f036:	4c0b      	ldr	r4, [pc, #44]	; (2f064 <ip_interface_freeaddrinfo+0x30>)
   2f038:	6823      	ldr	r3, [r4, #0]
   2f03a:	2b02      	cmp	r3, #2
   2f03c:	d000      	beq.n	2f040 <ip_interface_freeaddrinfo+0xc>
   2f03e:	bd38      	pop	{r3, r4, r5, pc}
   2f040:	b130      	cbz	r0, 2f050 <ip_interface_freeaddrinfo+0x1c>
   2f042:	4605      	mov	r5, r0
   2f044:	6940      	ldr	r0, [r0, #20]
   2f046:	f7fb fab9 	bl	2a5bc <nrf_free>
   2f04a:	4628      	mov	r0, r5
   2f04c:	f7fb fab6 	bl	2a5bc <nrf_free>
   2f050:	2300      	movs	r3, #0
   2f052:	4a05      	ldr	r2, [pc, #20]	; (2f068 <ip_interface_freeaddrinfo+0x34>)
   2f054:	4905      	ldr	r1, [pc, #20]	; (2f06c <ip_interface_freeaddrinfo+0x38>)
   2f056:	6023      	str	r3, [r4, #0]
   2f058:	6013      	str	r3, [r2, #0]
   2f05a:	6808      	ldr	r0, [r1, #0]
   2f05c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2f060:	f7fb bb0c 	b.w	2a67c <rpc_ip_client_data_free>
   2f064:	20020cf0 	.word	0x20020cf0
   2f068:	20020cec 	.word	0x20020cec
   2f06c:	20020cf8 	.word	0x20020cf8

0002f070 <rpc_ip_event_handler>:
   2f070:	f248 030d 	movw	r3, #32781	; 0x800d
   2f074:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2f078:	4299      	cmp	r1, r3
   2f07a:	b089      	sub	sp, #36	; 0x24
   2f07c:	4605      	mov	r5, r0
   2f07e:	d062      	beq.n	2f146 <rpc_ip_event_handler+0xd6>
   2f080:	f248 030f 	movw	r3, #32783	; 0x800f
   2f084:	4299      	cmp	r1, r3
   2f086:	460c      	mov	r4, r1
   2f088:	d04b      	beq.n	2f122 <rpc_ip_event_handler+0xb2>
   2f08a:	f401 4310 	and.w	r3, r1, #36864	; 0x9000
   2f08e:	f5b3 4f10 	cmp.w	r3, #36864	; 0x9000
   2f092:	68c0      	ldr	r0, [r0, #12]
   2f094:	d07b      	beq.n	2f18e <rpc_ip_event_handler+0x11e>
   2f096:	0c07      	lsrs	r7, r0, #16
   2f098:	4638      	mov	r0, r7
   2f09a:	f000 fba1 	bl	2f7e0 <interface_socket_from_handle_get>
   2f09e:	4606      	mov	r6, r0
   2f0a0:	2800      	cmp	r0, #0
   2f0a2:	d05f      	beq.n	2f164 <rpc_ip_event_handler+0xf4>
   2f0a4:	4601      	mov	r1, r0
   2f0a6:	4623      	mov	r3, r4
   2f0a8:	462a      	mov	r2, r5
   2f0aa:	4638      	mov	r0, r7
   2f0ac:	f7fb ff1e 	bl	2aeec <tls_rpc_ip_event_handler>
   2f0b0:	2800      	cmp	r0, #0
   2f0b2:	d053      	beq.n	2f15c <rpc_ip_event_handler+0xec>
   2f0b4:	f248 0307 	movw	r3, #32775	; 0x8007
   2f0b8:	429c      	cmp	r4, r3
   2f0ba:	d97d      	bls.n	2f1b8 <rpc_ip_event_handler+0x148>
   2f0bc:	f248 030c 	movw	r3, #32780	; 0x800c
   2f0c0:	429c      	cmp	r4, r3
   2f0c2:	d068      	beq.n	2f196 <rpc_ip_event_handler+0x126>
   2f0c4:	f240 8119 	bls.w	2f2fa <rpc_ip_event_handler+0x28a>
   2f0c8:	f249 0302 	movw	r3, #36866	; 0x9002
   2f0cc:	429c      	cmp	r4, r3
   2f0ce:	f000 8195 	beq.w	2f3fc <rpc_ip_event_handler+0x38c>
   2f0d2:	f249 0303 	movw	r3, #36867	; 0x9003
   2f0d6:	429c      	cmp	r4, r3
   2f0d8:	f000 81aa 	beq.w	2f430 <rpc_ip_event_handler+0x3c0>
   2f0dc:	f249 0301 	movw	r3, #36865	; 0x9001
   2f0e0:	429c      	cmp	r4, r3
   2f0e2:	d13f      	bne.n	2f164 <rpc_ip_event_handler+0xf4>
   2f0e4:	6834      	ldr	r4, [r6, #0]
   2f0e6:	f414 1480 	ands.w	r4, r4, #1048576	; 0x100000
   2f0ea:	f000 81c2 	beq.w	2f472 <rpc_ip_event_handler+0x402>
   2f0ee:	68ab      	ldr	r3, [r5, #8]
   2f0f0:	2b04      	cmp	r3, #4
   2f0f2:	f200 81ff 	bhi.w	2f4f4 <rpc_ip_event_handler+0x484>
   2f0f6:	2400      	movs	r4, #0
   2f0f8:	4627      	mov	r7, r4
   2f0fa:	6829      	ldr	r1, [r5, #0]
   2f0fc:	686a      	ldr	r2, [r5, #4]
   2f0fe:	e9cd 7406 	strd	r7, r4, [sp, #24]
   2f102:	e9cd 1204 	strd	r1, r2, [sp, #16]
   2f106:	69f0      	ldr	r0, [r6, #28]
   2f108:	a904      	add	r1, sp, #16
   2f10a:	6803      	ldr	r3, [r0, #0]
   2f10c:	685b      	ldr	r3, [r3, #4]
   2f10e:	4798      	blx	r3
   2f110:	3001      	adds	r0, #1
   2f112:	f000 81db 	beq.w	2f4cc <rpc_ip_event_handler+0x45c>
   2f116:	6833      	ldr	r3, [r6, #0]
   2f118:	2000      	movs	r0, #0
   2f11a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   2f11e:	6033      	str	r3, [r6, #0]
   2f120:	e00e      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f122:	6943      	ldr	r3, [r0, #20]
   2f124:	2001      	movs	r0, #1
   2f126:	2b10      	cmp	r3, #16
   2f128:	49b7      	ldr	r1, [pc, #732]	; (2f408 <rpc_ip_event_handler+0x398>)
   2f12a:	bf88      	it	hi
   2f12c:	222d      	movhi	r2, #45	; 0x2d
   2f12e:	7008      	strb	r0, [r1, #0]
   2f130:	f04f 0000 	mov.w	r0, #0
   2f134:	bf9c      	itt	ls
   2f136:	4ab5      	ldrls	r2, [pc, #724]	; (2f40c <rpc_ip_event_handler+0x39c>)
   2f138:	f852 2023 	ldrls.w	r2, [r2, r3, lsl #2]
   2f13c:	4bb4      	ldr	r3, [pc, #720]	; (2f410 <rpc_ip_event_handler+0x3a0>)
   2f13e:	601a      	str	r2, [r3, #0]
   2f140:	b009      	add	sp, #36	; 0x24
   2f142:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2f146:	f8df 92dc 	ldr.w	r9, [pc, #732]	; 2f424 <rpc_ip_event_handler+0x3b4>
   2f14a:	6807      	ldr	r7, [r0, #0]
   2f14c:	f8d9 3000 	ldr.w	r3, [r9]
   2f150:	2b01      	cmp	r3, #1
   2f152:	d00b      	beq.n	2f16c <rpc_ip_event_handler+0xfc>
   2f154:	b117      	cbz	r7, 2f15c <rpc_ip_event_handler+0xec>
   2f156:	4638      	mov	r0, r7
   2f158:	f7fb fa90 	bl	2a67c <rpc_ip_client_data_free>
   2f15c:	2000      	movs	r0, #0
   2f15e:	b009      	add	sp, #36	; 0x24
   2f160:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2f164:	6828      	ldr	r0, [r5, #0]
   2f166:	2800      	cmp	r0, #0
   2f168:	d1f6      	bne.n	2f158 <rpc_ip_event_handler+0xe8>
   2f16a:	e7f7      	b.n	2f15c <rpc_ip_event_handler+0xec>
   2f16c:	6943      	ldr	r3, [r0, #20]
   2f16e:	2b00      	cmp	r3, #0
   2f170:	d046      	beq.n	2f200 <rpc_ip_event_handler+0x190>
   2f172:	2b10      	cmp	r3, #16
   2f174:	bf96      	itet	ls
   2f176:	4aa5      	ldrls	r2, [pc, #660]	; (2f40c <rpc_ip_event_handler+0x39c>)
   2f178:	232d      	movhi	r3, #45	; 0x2d
   2f17a:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
   2f17e:	2202      	movs	r2, #2
   2f180:	49a4      	ldr	r1, [pc, #656]	; (2f414 <rpc_ip_event_handler+0x3a4>)
   2f182:	600b      	str	r3, [r1, #0]
   2f184:	f8c9 2000 	str.w	r2, [r9]
   2f188:	2f00      	cmp	r7, #0
   2f18a:	d1e4      	bne.n	2f156 <rpc_ip_event_handler+0xe6>
   2f18c:	e7e6      	b.n	2f15c <rpc_ip_event_handler+0xec>
   2f18e:	f000 fad5 	bl	2f73c <interface_from_internal_id_search>
   2f192:	4607      	mov	r7, r0
   2f194:	e780      	b.n	2f098 <rpc_ip_event_handler+0x28>
   2f196:	6833      	ldr	r3, [r6, #0]
   2f198:	b29b      	uxth	r3, r3
   2f19a:	2b08      	cmp	r3, #8
   2f19c:	d1de      	bne.n	2f15c <rpc_ip_event_handler+0xec>
   2f19e:	696b      	ldr	r3, [r5, #20]
   2f1a0:	2b00      	cmp	r3, #0
   2f1a2:	f000 819c 	beq.w	2f4de <rpc_ip_event_handler+0x46e>
   2f1a6:	2b10      	cmp	r3, #16
   2f1a8:	f200 8161 	bhi.w	2f46e <rpc_ip_event_handler+0x3fe>
   2f1ac:	4a97      	ldr	r2, [pc, #604]	; (2f40c <rpc_ip_event_handler+0x39c>)
   2f1ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   2f1b2:	6073      	str	r3, [r6, #4]
   2f1b4:	2000      	movs	r0, #0
   2f1b6:	e7c3      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f1b8:	f248 0306 	movw	r3, #32774	; 0x8006
   2f1bc:	429c      	cmp	r4, r3
   2f1be:	f080 810d 	bcs.w	2f3dc <rpc_ip_event_handler+0x36c>
   2f1c2:	f248 0302 	movw	r3, #32770	; 0x8002
   2f1c6:	429c      	cmp	r4, r3
   2f1c8:	f000 80f0 	beq.w	2f3ac <rpc_ip_event_handler+0x33c>
   2f1cc:	f240 80be 	bls.w	2f34c <rpc_ip_event_handler+0x2dc>
   2f1d0:	f248 0303 	movw	r3, #32771	; 0x8003
   2f1d4:	429c      	cmp	r4, r3
   2f1d6:	f000 80ca 	beq.w	2f36e <rpc_ip_event_handler+0x2fe>
   2f1da:	f248 0305 	movw	r3, #32773	; 0x8005
   2f1de:	429c      	cmp	r4, r3
   2f1e0:	d1c0      	bne.n	2f164 <rpc_ip_event_handler+0xf4>
   2f1e2:	6833      	ldr	r3, [r6, #0]
   2f1e4:	b29b      	uxth	r3, r3
   2f1e6:	2b03      	cmp	r3, #3
   2f1e8:	d1b8      	bne.n	2f15c <rpc_ip_event_handler+0xec>
   2f1ea:	696b      	ldr	r3, [r5, #20]
   2f1ec:	2b00      	cmp	r3, #0
   2f1ee:	d1da      	bne.n	2f1a6 <rpc_ip_event_handler+0x136>
   2f1f0:	6833      	ldr	r3, [r6, #0]
   2f1f2:	2000      	movs	r0, #0
   2f1f4:	0c1b      	lsrs	r3, r3, #16
   2f1f6:	041b      	lsls	r3, r3, #16
   2f1f8:	f043 0304 	orr.w	r3, r3, #4
   2f1fc:	6033      	str	r3, [r6, #0]
   2f1fe:	e79f      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f200:	4b85      	ldr	r3, [pc, #532]	; (2f418 <rpc_ip_event_handler+0x3a8>)
   2f202:	601f      	str	r7, [r3, #0]
   2f204:	6984      	ldr	r4, [r0, #24]
   2f206:	0163      	lsls	r3, r4, #5
   2f208:	4618      	mov	r0, r3
   2f20a:	9303      	str	r3, [sp, #12]
   2f20c:	f7fb f9cc 	bl	2a5a8 <nrf_malloc>
   2f210:	9002      	str	r0, [sp, #8]
   2f212:	2800      	cmp	r0, #0
   2f214:	f000 808a 	beq.w	2f32c <rpc_ip_event_handler+0x2bc>
   2f218:	00e5      	lsls	r5, r4, #3
   2f21a:	1928      	adds	r0, r5, r4
   2f21c:	0080      	lsls	r0, r0, #2
   2f21e:	f7fb f9c3 	bl	2a5a8 <nrf_malloc>
   2f222:	2800      	cmp	r0, #0
   2f224:	f000 811f 	beq.w	2f466 <rpc_ip_event_handler+0x3f6>
   2f228:	2c00      	cmp	r4, #0
   2f22a:	d05e      	beq.n	2f2ea <rpc_ip_event_handler+0x27a>
   2f22c:	3510      	adds	r5, #16
   2f22e:	1943      	adds	r3, r0, r5
   2f230:	9301      	str	r3, [sp, #4]
   2f232:	9b02      	ldr	r3, [sp, #8]
   2f234:	2404      	movs	r4, #4
   2f236:	f8df a1f0 	ldr.w	sl, [pc, #496]	; 2f428 <rpc_ip_event_handler+0x3b8>
   2f23a:	f8df b1f0 	ldr.w	fp, [pc, #496]	; 2f42c <rpc_ip_event_handler+0x3bc>
   2f23e:	f100 0810 	add.w	r8, r0, #16
   2f242:	f103 0620 	add.w	r6, r3, #32
   2f246:	e01d      	b.n	2f284 <rpc_ip_event_handler+0x214>
   2f248:	220a      	movs	r2, #10
   2f24a:	f848 2c0c 	str.w	r2, [r8, #-12]
   2f24e:	f04f 0224 	mov.w	r2, #36	; 0x24
   2f252:	4640      	mov	r0, r8
   2f254:	f808 2c10 	strb.w	r2, [r8, #-16]
   2f258:	f828 3c08 	strh.w	r3, [r8, #-8]
   2f25c:	f856 2c10 	ldr.w	r2, [r6, #-16]
   2f260:	f00a fd8d 	bl	39d7e <memcpy>
   2f264:	f856 3c10 	ldr.w	r3, [r6, #-16]
   2f268:	f108 0808 	add.w	r8, r8, #8
   2f26c:	441c      	add	r4, r3
   2f26e:	193b      	adds	r3, r7, r4
   2f270:	f846 3c08 	str.w	r3, [r6, #-8]
   2f274:	9b01      	ldr	r3, [sp, #4]
   2f276:	f846 6c04 	str.w	r6, [r6, #-4]
   2f27a:	4598      	cmp	r8, r3
   2f27c:	442c      	add	r4, r5
   2f27e:	f106 0620 	add.w	r6, r6, #32
   2f282:	d02c      	beq.n	2f2de <rpc_ip_event_handler+0x26e>
   2f284:	593b      	ldr	r3, [r7, r4]
   2f286:	193a      	adds	r2, r7, r4
   2f288:	f846 3c20 	str.w	r3, [r6, #-32]
   2f28c:	6853      	ldr	r3, [r2, #4]
   2f28e:	f8da 1000 	ldr.w	r1, [sl]
   2f292:	2b02      	cmp	r3, #2
   2f294:	bf14      	ite	ne
   2f296:	2002      	movne	r0, #2
   2f298:	200a      	moveq	r0, #10
   2f29a:	f8db 3000 	ldr.w	r3, [fp]
   2f29e:	e946 0107 	strd	r0, r1, [r6, #-28]
   2f2a2:	f846 3c14 	str.w	r3, [r6, #-20]
   2f2a6:	8a10      	ldrh	r0, [r2, #16]
   2f2a8:	f1a8 0310 	sub.w	r3, r8, #16
   2f2ac:	f846 0c10 	str.w	r0, [r6, #-16]
   2f2b0:	8a55      	ldrh	r5, [r2, #18]
   2f2b2:	f846 3c0c 	str.w	r3, [r6, #-12]
   2f2b6:	4b59      	ldr	r3, [pc, #356]	; (2f41c <rpc_ip_event_handler+0x3ac>)
   2f2b8:	3414      	adds	r4, #20
   2f2ba:	2804      	cmp	r0, #4
   2f2bc:	eb07 0104 	add.w	r1, r7, r4
   2f2c0:	881b      	ldrh	r3, [r3, #0]
   2f2c2:	d1c1      	bne.n	2f248 <rpc_ip_event_handler+0x1d8>
   2f2c4:	2210      	movs	r2, #16
   2f2c6:	2002      	movs	r0, #2
   2f2c8:	f828 3c08 	strh.w	r3, [r8, #-8]
   2f2cc:	f848 0c0c 	str.w	r0, [r8, #-12]
   2f2d0:	f808 2c10 	strb.w	r2, [r8, #-16]
   2f2d4:	f856 2c10 	ldr.w	r2, [r6, #-16]
   2f2d8:	f1a8 0004 	sub.w	r0, r8, #4
   2f2dc:	e7c0      	b.n	2f260 <rpc_ip_event_handler+0x1f0>
   2f2de:	2200      	movs	r2, #0
   2f2e0:	e9dd 1302 	ldrd	r1, r3, [sp, #8]
   2f2e4:	440b      	add	r3, r1
   2f2e6:	f843 2c04 	str.w	r2, [r3, #-4]
   2f2ea:	2202      	movs	r2, #2
   2f2ec:	4b4c      	ldr	r3, [pc, #304]	; (2f420 <rpc_ip_event_handler+0x3b0>)
   2f2ee:	f8c9 2000 	str.w	r2, [r9]
   2f2f2:	9a02      	ldr	r2, [sp, #8]
   2f2f4:	2000      	movs	r0, #0
   2f2f6:	601a      	str	r2, [r3, #0]
   2f2f8:	e722      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f2fa:	f248 0308 	movw	r3, #32776	; 0x8008
   2f2fe:	429c      	cmp	r4, r3
   2f300:	d045      	beq.n	2f38e <rpc_ip_event_handler+0x31e>
   2f302:	f248 0309 	movw	r3, #32777	; 0x8009
   2f306:	429c      	cmp	r4, r3
   2f308:	f47f af2c 	bne.w	2f164 <rpc_ip_event_handler+0xf4>
   2f30c:	6833      	ldr	r3, [r6, #0]
   2f30e:	b29b      	uxth	r3, r3
   2f310:	2b0d      	cmp	r3, #13
   2f312:	f47f af23 	bne.w	2f15c <rpc_ip_event_handler+0xec>
   2f316:	6968      	ldr	r0, [r5, #20]
   2f318:	2800      	cmp	r0, #0
   2f31a:	f000 80d9 	beq.w	2f4d0 <rpc_ip_event_handler+0x460>
   2f31e:	2810      	cmp	r0, #16
   2f320:	f200 80a5 	bhi.w	2f46e <rpc_ip_event_handler+0x3fe>
   2f324:	4b39      	ldr	r3, [pc, #228]	; (2f40c <rpc_ip_event_handler+0x39c>)
   2f326:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   2f32a:	e742      	b.n	2f1b2 <rpc_ip_event_handler+0x142>
   2f32c:	f7fb f946 	bl	2a5bc <nrf_free>
   2f330:	200c      	movs	r0, #12
   2f332:	2302      	movs	r3, #2
   2f334:	4937      	ldr	r1, [pc, #220]	; (2f414 <rpc_ip_event_handler+0x3a4>)
   2f336:	4a3a      	ldr	r2, [pc, #232]	; (2f420 <rpc_ip_event_handler+0x3b0>)
   2f338:	6008      	str	r0, [r1, #0]
   2f33a:	682f      	ldr	r7, [r5, #0]
   2f33c:	9902      	ldr	r1, [sp, #8]
   2f33e:	f8c9 3000 	str.w	r3, [r9]
   2f342:	6011      	str	r1, [r2, #0]
   2f344:	2f00      	cmp	r7, #0
   2f346:	f47f af06 	bne.w	2f156 <rpc_ip_event_handler+0xe6>
   2f34a:	e707      	b.n	2f15c <rpc_ip_event_handler+0xec>
   2f34c:	f248 0301 	movw	r3, #32769	; 0x8001
   2f350:	429c      	cmp	r4, r3
   2f352:	f47f af07 	bne.w	2f164 <rpc_ip_event_handler+0xf4>
   2f356:	6833      	ldr	r3, [r6, #0]
   2f358:	2b01      	cmp	r3, #1
   2f35a:	f47f aeff 	bne.w	2f15c <rpc_ip_event_handler+0xec>
   2f35e:	6968      	ldr	r0, [r5, #20]
   2f360:	2800      	cmp	r0, #0
   2f362:	d1dc      	bne.n	2f31e <rpc_ip_event_handler+0x2ae>
   2f364:	2302      	movs	r3, #2
   2f366:	6033      	str	r3, [r6, #0]
   2f368:	69ab      	ldr	r3, [r5, #24]
   2f36a:	61b3      	str	r3, [r6, #24]
   2f36c:	e6e8      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f36e:	6833      	ldr	r3, [r6, #0]
   2f370:	025b      	lsls	r3, r3, #9
   2f372:	f57f aef3 	bpl.w	2f15c <rpc_ip_event_handler+0xec>
   2f376:	6968      	ldr	r0, [r5, #20]
   2f378:	2800      	cmp	r0, #0
   2f37a:	f000 80a0 	beq.w	2f4be <rpc_ip_event_handler+0x44e>
   2f37e:	2810      	cmp	r0, #16
   2f380:	bf8e      	itee	hi
   2f382:	232d      	movhi	r3, #45	; 0x2d
   2f384:	4b21      	ldrls	r3, [pc, #132]	; (2f40c <rpc_ip_event_handler+0x39c>)
   2f386:	f853 3020 	ldrls.w	r3, [r3, r0, lsl #2]
   2f38a:	6073      	str	r3, [r6, #4]
   2f38c:	e6e6      	b.n	2f15c <rpc_ip_event_handler+0xec>
   2f38e:	6833      	ldr	r3, [r6, #0]
   2f390:	b29b      	uxth	r3, r3
   2f392:	2b06      	cmp	r3, #6
   2f394:	f47f aee2 	bne.w	2f15c <rpc_ip_event_handler+0xec>
   2f398:	6968      	ldr	r0, [r5, #20]
   2f39a:	2800      	cmp	r0, #0
   2f39c:	d1bf      	bne.n	2f31e <rpc_ip_event_handler+0x2ae>
   2f39e:	6833      	ldr	r3, [r6, #0]
   2f3a0:	0c1b      	lsrs	r3, r3, #16
   2f3a2:	041b      	lsls	r3, r3, #16
   2f3a4:	f043 0307 	orr.w	r3, r3, #7
   2f3a8:	6033      	str	r3, [r6, #0]
   2f3aa:	e6c9      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f3ac:	6833      	ldr	r3, [r6, #0]
   2f3ae:	0099      	lsls	r1, r3, #2
   2f3b0:	f57f aed4 	bpl.w	2f15c <rpc_ip_event_handler+0xec>
   2f3b4:	6833      	ldr	r3, [r6, #0]
   2f3b6:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   2f3ba:	6033      	str	r3, [r6, #0]
   2f3bc:	6968      	ldr	r0, [r5, #20]
   2f3be:	2800      	cmp	r0, #0
   2f3c0:	d06e      	beq.n	2f4a0 <rpc_ip_event_handler+0x430>
   2f3c2:	2810      	cmp	r0, #16
   2f3c4:	f200 8080 	bhi.w	2f4c8 <rpc_ip_event_handler+0x458>
   2f3c8:	4b10      	ldr	r3, [pc, #64]	; (2f40c <rpc_ip_event_handler+0x39c>)
   2f3ca:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   2f3ce:	6073      	str	r3, [r6, #4]
   2f3d0:	6833      	ldr	r3, [r6, #0]
   2f3d2:	2000      	movs	r0, #0
   2f3d4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   2f3d8:	6033      	str	r3, [r6, #0]
   2f3da:	e6b1      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f3dc:	6833      	ldr	r3, [r6, #0]
   2f3de:	029a      	lsls	r2, r3, #10
   2f3e0:	f57f aebc 	bpl.w	2f15c <rpc_ip_event_handler+0xec>
   2f3e4:	696b      	ldr	r3, [r5, #20]
   2f3e6:	2b00      	cmp	r3, #0
   2f3e8:	d051      	beq.n	2f48e <rpc_ip_event_handler+0x41e>
   2f3ea:	2b6b      	cmp	r3, #107	; 0x6b
   2f3ec:	f000 8086 	beq.w	2f4fc <rpc_ip_event_handler+0x48c>
   2f3f0:	2b10      	cmp	r3, #16
   2f3f2:	d869      	bhi.n	2f4c8 <rpc_ip_event_handler+0x458>
   2f3f4:	4a05      	ldr	r2, [pc, #20]	; (2f40c <rpc_ip_event_handler+0x39c>)
   2f3f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   2f3fa:	e7e8      	b.n	2f3ce <rpc_ip_event_handler+0x35e>
   2f3fc:	6833      	ldr	r3, [r6, #0]
   2f3fe:	b29b      	uxth	r3, r3
   2f400:	2b07      	cmp	r3, #7
   2f402:	f47f aeab 	bne.w	2f15c <rpc_ip_event_handler+0xec>
   2f406:	e686      	b.n	2f116 <rpc_ip_event_handler+0xa6>
   2f408:	20026148 	.word	0x20026148
   2f40c:	0003b798 	.word	0x0003b798
   2f410:	20020d20 	.word	0x20020d20
   2f414:	20020cec 	.word	0x20020cec
   2f418:	20020cf8 	.word	0x20020cf8
   2f41c:	2002229a 	.word	0x2002229a
   2f420:	20020cf4 	.word	0x20020cf4
   2f424:	20020cf0 	.word	0x20020cf0
   2f428:	20020ce8 	.word	0x20020ce8
   2f42c:	20020ce4 	.word	0x20020ce4
   2f430:	6833      	ldr	r3, [r6, #0]
   2f432:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
   2f436:	6033      	str	r3, [r6, #0]
   2f438:	6833      	ldr	r3, [r6, #0]
   2f43a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   2f43e:	6033      	str	r3, [r6, #0]
   2f440:	6833      	ldr	r3, [r6, #0]
   2f442:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   2f446:	6033      	str	r3, [r6, #0]
   2f448:	692b      	ldr	r3, [r5, #16]
   2f44a:	2b6c      	cmp	r3, #108	; 0x6c
   2f44c:	d016      	beq.n	2f47c <rpc_ip_event_handler+0x40c>
   2f44e:	2b10      	cmp	r3, #16
   2f450:	bf8c      	ite	hi
   2f452:	232d      	movhi	r3, #45	; 0x2d
   2f454:	4a46      	ldrls	r2, [pc, #280]	; (2f570 <rpc_ip_event_handler+0x500>)
   2f456:	f04f 0000 	mov.w	r0, #0
   2f45a:	bf98      	it	ls
   2f45c:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
   2f460:	6073      	str	r3, [r6, #4]
   2f462:	60b3      	str	r3, [r6, #8]
   2f464:	e66c      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f466:	220c      	movs	r2, #12
   2f468:	4b42      	ldr	r3, [pc, #264]	; (2f574 <rpc_ip_event_handler+0x504>)
   2f46a:	601a      	str	r2, [r3, #0]
   2f46c:	e73d      	b.n	2f2ea <rpc_ip_event_handler+0x27a>
   2f46e:	232d      	movs	r3, #45	; 0x2d
   2f470:	e69f      	b.n	2f1b2 <rpc_ip_event_handler+0x142>
   2f472:	6828      	ldr	r0, [r5, #0]
   2f474:	f7fb f902 	bl	2a67c <rpc_ip_client_data_free>
   2f478:	4620      	mov	r0, r4
   2f47a:	e661      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f47c:	2239      	movs	r2, #57	; 0x39
   2f47e:	6833      	ldr	r3, [r6, #0]
   2f480:	2000      	movs	r0, #0
   2f482:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   2f486:	6033      	str	r3, [r6, #0]
   2f488:	6072      	str	r2, [r6, #4]
   2f48a:	60b2      	str	r2, [r6, #8]
   2f48c:	e658      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f48e:	6833      	ldr	r3, [r6, #0]
   2f490:	4a39      	ldr	r2, [pc, #228]	; (2f578 <rpc_ip_event_handler+0x508>)
   2f492:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2f496:	6033      	str	r3, [r6, #0]
   2f498:	2001      	movs	r0, #1
   2f49a:	f842 5027 	str.w	r5, [r2, r7, lsl #2]
   2f49e:	e64f      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f4a0:	6833      	ldr	r3, [r6, #0]
   2f4a2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2f4a6:	6033      	str	r3, [r6, #0]
   2f4a8:	6833      	ldr	r3, [r6, #0]
   2f4aa:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   2f4ae:	6033      	str	r3, [r6, #0]
   2f4b0:	6833      	ldr	r3, [r6, #0]
   2f4b2:	0c1b      	lsrs	r3, r3, #16
   2f4b4:	041b      	lsls	r3, r3, #16
   2f4b6:	f043 0305 	orr.w	r3, r3, #5
   2f4ba:	6033      	str	r3, [r6, #0]
   2f4bc:	e640      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f4be:	6833      	ldr	r3, [r6, #0]
   2f4c0:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   2f4c4:	6033      	str	r3, [r6, #0]
   2f4c6:	e63b      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f4c8:	232d      	movs	r3, #45	; 0x2d
   2f4ca:	e780      	b.n	2f3ce <rpc_ip_event_handler+0x35e>
   2f4cc:	2002      	movs	r0, #2
   2f4ce:	e637      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f4d0:	6833      	ldr	r3, [r6, #0]
   2f4d2:	0c1b      	lsrs	r3, r3, #16
   2f4d4:	041b      	lsls	r3, r3, #16
   2f4d6:	f043 030e 	orr.w	r3, r3, #14
   2f4da:	6033      	str	r3, [r6, #0]
   2f4dc:	e630      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f4de:	4b26      	ldr	r3, [pc, #152]	; (2f578 <rpc_ip_event_handler+0x508>)
   2f4e0:	2001      	movs	r0, #1
   2f4e2:	f843 5027 	str.w	r5, [r3, r7, lsl #2]
   2f4e6:	6833      	ldr	r3, [r6, #0]
   2f4e8:	0c1b      	lsrs	r3, r3, #16
   2f4ea:	041b      	lsls	r3, r3, #16
   2f4ec:	f043 0309 	orr.w	r3, r3, #9
   2f4f0:	6033      	str	r3, [r6, #0]
   2f4f2:	e625      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f4f4:	8a6c      	ldrh	r4, [r5, #18]
   2f4f6:	b934      	cbnz	r4, 2f506 <rpc_ip_event_handler+0x496>
   2f4f8:	4627      	mov	r7, r4
   2f4fa:	e5fe      	b.n	2f0fa <rpc_ip_event_handler+0x8a>
   2f4fc:	6933      	ldr	r3, [r6, #16]
   2f4fe:	2b01      	cmp	r3, #1
   2f500:	d012      	beq.n	2f528 <rpc_ip_event_handler+0x4b8>
   2f502:	230c      	movs	r3, #12
   2f504:	e763      	b.n	2f3ce <rpc_ip_event_handler+0x35e>
   2f506:	2024      	movs	r0, #36	; 0x24
   2f508:	f7fb f84e 	bl	2a5a8 <nrf_malloc>
   2f50c:	4607      	mov	r7, r0
   2f50e:	b358      	cbz	r0, 2f568 <rpc_ip_event_handler+0x4f8>
   2f510:	8a6a      	ldrh	r2, [r5, #18]
   2f512:	2a10      	cmp	r2, #16
   2f514:	d01c      	beq.n	2f550 <rpc_ip_event_handler+0x4e0>
   2f516:	2a04      	cmp	r2, #4
   2f518:	d00e      	beq.n	2f538 <rpc_ip_event_handler+0x4c8>
   2f51a:	6828      	ldr	r0, [r5, #0]
   2f51c:	f7fb f8ae 	bl	2a67c <rpc_ip_client_data_free>
   2f520:	4638      	mov	r0, r7
   2f522:	f7fb f84b 	bl	2a5bc <nrf_free>
   2f526:	e619      	b.n	2f15c <rpc_ip_event_handler+0xec>
   2f528:	220c      	movs	r2, #12
   2f52a:	6833      	ldr	r3, [r6, #0]
   2f52c:	2000      	movs	r0, #0
   2f52e:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   2f532:	6033      	str	r3, [r6, #0]
   2f534:	6072      	str	r2, [r6, #4]
   2f536:	e603      	b.n	2f140 <rpc_ip_event_handler+0xd0>
   2f538:	2302      	movs	r3, #2
   2f53a:	2410      	movs	r4, #16
   2f53c:	6043      	str	r3, [r0, #4]
   2f53e:	7004      	strb	r4, [r0, #0]
   2f540:	8a2b      	ldrh	r3, [r5, #16]
   2f542:	f105 0114 	add.w	r1, r5, #20
   2f546:	8103      	strh	r3, [r0, #8]
   2f548:	300c      	adds	r0, #12
   2f54a:	f00a fc18 	bl	39d7e <memcpy>
   2f54e:	e5d4      	b.n	2f0fa <rpc_ip_event_handler+0x8a>
   2f550:	230a      	movs	r3, #10
   2f552:	2424      	movs	r4, #36	; 0x24
   2f554:	6043      	str	r3, [r0, #4]
   2f556:	7004      	strb	r4, [r0, #0]
   2f558:	8a2b      	ldrh	r3, [r5, #16]
   2f55a:	f105 0114 	add.w	r1, r5, #20
   2f55e:	8103      	strh	r3, [r0, #8]
   2f560:	3010      	adds	r0, #16
   2f562:	f00a fc0c 	bl	39d7e <memcpy>
   2f566:	e5c8      	b.n	2f0fa <rpc_ip_event_handler+0x8a>
   2f568:	6828      	ldr	r0, [r5, #0]
   2f56a:	f7fb f887 	bl	2a67c <rpc_ip_client_data_free>
   2f56e:	e5f5      	b.n	2f15c <rpc_ip_event_handler+0xec>
   2f570:	0003b798 	.word	0x0003b798
   2f574:	20020cec 	.word	0x20020cec
   2f578:	20020cfc 	.word	0x20020cfc

0002f57c <interface_init>:
   2f57c:	b508      	push	{r3, lr}
   2f57e:	f44f 72a2 	mov.w	r2, #324	; 0x144
   2f582:	2100      	movs	r1, #0
   2f584:	4802      	ldr	r0, [pc, #8]	; (2f590 <interface_init+0x14>)
   2f586:	f00a fc1a 	bl	39dbe <memset>
   2f58a:	2000      	movs	r0, #0
   2f58c:	bd08      	pop	{r3, pc}
   2f58e:	bf00      	nop
   2f590:	2002614c 	.word	0x2002614c

0002f594 <interface_socket_allocate>:
   2f594:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2f596:	4b30      	ldr	r3, [pc, #192]	; (2f658 <interface_socket_allocate+0xc4>)
   2f598:	4606      	mov	r6, r0
   2f59a:	681d      	ldr	r5, [r3, #0]
   2f59c:	4608      	mov	r0, r1
   2f59e:	b31d      	cbz	r5, 2f5e8 <interface_socket_allocate+0x54>
   2f5a0:	6a5c      	ldr	r4, [r3, #36]	; 0x24
   2f5a2:	2c00      	cmp	r4, #0
   2f5a4:	d04a      	beq.n	2f63c <interface_socket_allocate+0xa8>
   2f5a6:	6c9c      	ldr	r4, [r3, #72]	; 0x48
   2f5a8:	2c00      	cmp	r4, #0
   2f5aa:	d049      	beq.n	2f640 <interface_socket_allocate+0xac>
   2f5ac:	6edc      	ldr	r4, [r3, #108]	; 0x6c
   2f5ae:	2c00      	cmp	r4, #0
   2f5b0:	d048      	beq.n	2f644 <interface_socket_allocate+0xb0>
   2f5b2:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
   2f5b6:	2900      	cmp	r1, #0
   2f5b8:	d046      	beq.n	2f648 <interface_socket_allocate+0xb4>
   2f5ba:	f8d3 10b4 	ldr.w	r1, [r3, #180]	; 0xb4
   2f5be:	b191      	cbz	r1, 2f5e6 <interface_socket_allocate+0x52>
   2f5c0:	f8d3 10d8 	ldr.w	r1, [r3, #216]	; 0xd8
   2f5c4:	2900      	cmp	r1, #0
   2f5c6:	d043      	beq.n	2f650 <interface_socket_allocate+0xbc>
   2f5c8:	f8d3 10fc 	ldr.w	r1, [r3, #252]	; 0xfc
   2f5cc:	2900      	cmp	r1, #0
   2f5ce:	d041      	beq.n	2f654 <interface_socket_allocate+0xc0>
   2f5d0:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
   2f5d4:	2900      	cmp	r1, #0
   2f5d6:	d039      	beq.n	2f64c <interface_socket_allocate+0xb8>
   2f5d8:	f04f 35ff 	mov.w	r5, #4294967295
   2f5dc:	2069      	movs	r0, #105	; 0x69
   2f5de:	f7f8 fa3f 	bl	27a60 <bsd_os_errno_set>
   2f5e2:	4628      	mov	r0, r5
   2f5e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2f5e6:	2505      	movs	r5, #5
   2f5e8:	f04f 0c01 	mov.w	ip, #1
   2f5ec:	f04f 37ff 	mov.w	r7, #4294967295
   2f5f0:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   2f5f4:	00a4      	lsls	r4, r4, #2
   2f5f6:	f843 c004 	str.w	ip, [r3, r4]
   2f5fa:	441c      	add	r4, r3
   2f5fc:	4611      	mov	r1, r2
   2f5fe:	61a7      	str	r7, [r4, #24]
   2f600:	4622      	mov	r2, r4
   2f602:	f001 ffd1 	bl	315a8 <packet_handler_create>
   2f606:	4603      	mov	r3, r0
   2f608:	61e0      	str	r0, [r4, #28]
   2f60a:	b158      	cbz	r0, 2f624 <interface_socket_allocate+0x90>
   2f60c:	681b      	ldr	r3, [r3, #0]
   2f60e:	681b      	ldr	r3, [r3, #0]
   2f610:	4798      	blx	r3
   2f612:	b910      	cbnz	r0, 2f61a <interface_socket_allocate+0x86>
   2f614:	6034      	str	r4, [r6, #0]
   2f616:	4628      	mov	r0, r5
   2f618:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2f61a:	69e0      	ldr	r0, [r4, #28]
   2f61c:	f001 ffe4 	bl	315e8 <packet_handler_delete>
   2f620:	2300      	movs	r3, #0
   2f622:	61e3      	str	r3, [r4, #28]
   2f624:	f04f 35ff 	mov.w	r5, #4294967295
   2f628:	2224      	movs	r2, #36	; 0x24
   2f62a:	2100      	movs	r1, #0
   2f62c:	4620      	mov	r0, r4
   2f62e:	f00a fbc6 	bl	39dbe <memset>
   2f632:	200c      	movs	r0, #12
   2f634:	f7f8 fa14 	bl	27a60 <bsd_os_errno_set>
   2f638:	4628      	mov	r0, r5
   2f63a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2f63c:	2501      	movs	r5, #1
   2f63e:	e7d3      	b.n	2f5e8 <interface_socket_allocate+0x54>
   2f640:	2502      	movs	r5, #2
   2f642:	e7d1      	b.n	2f5e8 <interface_socket_allocate+0x54>
   2f644:	2503      	movs	r5, #3
   2f646:	e7cf      	b.n	2f5e8 <interface_socket_allocate+0x54>
   2f648:	2504      	movs	r5, #4
   2f64a:	e7cd      	b.n	2f5e8 <interface_socket_allocate+0x54>
   2f64c:	2508      	movs	r5, #8
   2f64e:	e7cb      	b.n	2f5e8 <interface_socket_allocate+0x54>
   2f650:	2506      	movs	r5, #6
   2f652:	e7c9      	b.n	2f5e8 <interface_socket_allocate+0x54>
   2f654:	2507      	movs	r5, #7
   2f656:	e7c7      	b.n	2f5e8 <interface_socket_allocate+0x54>
   2f658:	2002614c 	.word	0x2002614c

0002f65c <interface_socket_free>:
   2f65c:	2808      	cmp	r0, #8
   2f65e:	d900      	bls.n	2f662 <interface_socket_free+0x6>
   2f660:	4770      	bx	lr
   2f662:	b510      	push	{r4, lr}
   2f664:	4c07      	ldr	r4, [pc, #28]	; (2f684 <interface_socket_free+0x28>)
   2f666:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   2f66a:	eb04 0480 	add.w	r4, r4, r0, lsl #2
   2f66e:	69e0      	ldr	r0, [r4, #28]
   2f670:	b108      	cbz	r0, 2f676 <interface_socket_free+0x1a>
   2f672:	f001 ffb9 	bl	315e8 <packet_handler_delete>
   2f676:	4620      	mov	r0, r4
   2f678:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2f67c:	2224      	movs	r2, #36	; 0x24
   2f67e:	2100      	movs	r1, #0
   2f680:	f00a bb9d 	b.w	39dbe <memset>
   2f684:	2002614c 	.word	0x2002614c

0002f688 <interface_socket_packet_handler_update>:
   2f688:	2808      	cmp	r0, #8
   2f68a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2f68e:	d81e      	bhi.n	2f6ce <interface_socket_packet_handler_update+0x46>
   2f690:	ea4f 08c0 	mov.w	r8, r0, lsl #3
   2f694:	4e17      	ldr	r6, [pc, #92]	; (2f6f4 <interface_socket_packet_handler_update+0x6c>)
   2f696:	eb08 0300 	add.w	r3, r8, r0
   2f69a:	009b      	lsls	r3, r3, #2
   2f69c:	58f4      	ldr	r4, [r6, r3]
   2f69e:	18f5      	adds	r5, r6, r3
   2f6a0:	b1ac      	cbz	r4, 2f6ce <interface_socket_packet_handler_update+0x46>
   2f6a2:	460b      	mov	r3, r1
   2f6a4:	4604      	mov	r4, r0
   2f6a6:	4611      	mov	r1, r2
   2f6a8:	4618      	mov	r0, r3
   2f6aa:	462a      	mov	r2, r5
   2f6ac:	f8d5 901c 	ldr.w	r9, [r5, #28]
   2f6b0:	f001 ff7a 	bl	315a8 <packet_handler_create>
   2f6b4:	61e8      	str	r0, [r5, #28]
   2f6b6:	b1d0      	cbz	r0, 2f6ee <interface_socket_packet_handler_update+0x66>
   2f6b8:	6803      	ldr	r3, [r0, #0]
   2f6ba:	681b      	ldr	r3, [r3, #0]
   2f6bc:	4798      	blx	r3
   2f6be:	4607      	mov	r7, r0
   2f6c0:	b948      	cbnz	r0, 2f6d6 <interface_socket_packet_handler_update+0x4e>
   2f6c2:	4648      	mov	r0, r9
   2f6c4:	f001 ff90 	bl	315e8 <packet_handler_delete>
   2f6c8:	4638      	mov	r0, r7
   2f6ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2f6ce:	2705      	movs	r7, #5
   2f6d0:	4638      	mov	r0, r7
   2f6d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2f6d6:	69e8      	ldr	r0, [r5, #28]
   2f6d8:	f001 ff86 	bl	315e8 <packet_handler_delete>
   2f6dc:	eb08 0004 	add.w	r0, r8, r4
   2f6e0:	eb06 0680 	add.w	r6, r6, r0, lsl #2
   2f6e4:	f8c6 901c 	str.w	r9, [r6, #28]
   2f6e8:	4638      	mov	r0, r7
   2f6ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2f6ee:	2704      	movs	r7, #4
   2f6f0:	e7f4      	b.n	2f6dc <interface_socket_packet_handler_update+0x54>
   2f6f2:	bf00      	nop
   2f6f4:	2002614c 	.word	0x2002614c

0002f6f8 <interface_socket_wait>:
   2f6f8:	b5f0      	push	{r4, r5, r6, r7, lr}
   2f6fa:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   2f6fe:	4c0e      	ldr	r4, [pc, #56]	; (2f738 <interface_socket_wait+0x40>)
   2f700:	0080      	lsls	r0, r0, #2
   2f702:	5825      	ldr	r5, [r4, r0]
   2f704:	b083      	sub	sp, #12
   2f706:	4015      	ands	r5, r2
   2f708:	428d      	cmp	r5, r1
   2f70a:	9301      	str	r3, [sp, #4]
   2f70c:	4404      	add	r4, r0
   2f70e:	d010      	beq.n	2f732 <interface_socket_wait+0x3a>
   2f710:	6863      	ldr	r3, [r4, #4]
   2f712:	b973      	cbnz	r3, 2f732 <interface_socket_wait+0x3a>
   2f714:	460f      	mov	r7, r1
   2f716:	4616      	mov	r6, r2
   2f718:	4625      	mov	r5, r4
   2f71a:	e006      	b.n	2f72a <interface_socket_wait+0x32>
   2f71c:	686b      	ldr	r3, [r5, #4]
   2f71e:	b943      	cbnz	r3, 2f732 <interface_socket_wait+0x3a>
   2f720:	a901      	add	r1, sp, #4
   2f722:	4620      	mov	r0, r4
   2f724:	f7f8 f908 	bl	27938 <bsd_os_timedwait>
   2f728:	b920      	cbnz	r0, 2f734 <interface_socket_wait+0x3c>
   2f72a:	682b      	ldr	r3, [r5, #0]
   2f72c:	4033      	ands	r3, r6
   2f72e:	42bb      	cmp	r3, r7
   2f730:	d1f4      	bne.n	2f71c <interface_socket_wait+0x24>
   2f732:	2000      	movs	r0, #0
   2f734:	b003      	add	sp, #12
   2f736:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2f738:	2002614c 	.word	0x2002614c

0002f73c <interface_from_internal_id_search>:
   2f73c:	4b27      	ldr	r3, [pc, #156]	; (2f7dc <interface_from_internal_id_search+0xa0>)
   2f73e:	681a      	ldr	r2, [r3, #0]
   2f740:	b112      	cbz	r2, 2f748 <interface_from_internal_id_search+0xc>
   2f742:	699a      	ldr	r2, [r3, #24]
   2f744:	4282      	cmp	r2, r0
   2f746:	d039      	beq.n	2f7bc <interface_from_internal_id_search+0x80>
   2f748:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   2f74a:	b112      	cbz	r2, 2f752 <interface_from_internal_id_search+0x16>
   2f74c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   2f74e:	4282      	cmp	r2, r0
   2f750:	d036      	beq.n	2f7c0 <interface_from_internal_id_search+0x84>
   2f752:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   2f754:	b112      	cbz	r2, 2f75c <interface_from_internal_id_search+0x20>
   2f756:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   2f758:	4282      	cmp	r2, r0
   2f75a:	d033      	beq.n	2f7c4 <interface_from_internal_id_search+0x88>
   2f75c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   2f75e:	b11a      	cbz	r2, 2f768 <interface_from_internal_id_search+0x2c>
   2f760:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   2f764:	4282      	cmp	r2, r0
   2f766:	d02f      	beq.n	2f7c8 <interface_from_internal_id_search+0x8c>
   2f768:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   2f76c:	b11a      	cbz	r2, 2f776 <interface_from_internal_id_search+0x3a>
   2f76e:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
   2f772:	4282      	cmp	r2, r0
   2f774:	d02a      	beq.n	2f7cc <interface_from_internal_id_search+0x90>
   2f776:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
   2f77a:	b11a      	cbz	r2, 2f784 <interface_from_internal_id_search+0x48>
   2f77c:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
   2f780:	4282      	cmp	r2, r0
   2f782:	d025      	beq.n	2f7d0 <interface_from_internal_id_search+0x94>
   2f784:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
   2f788:	b11a      	cbz	r2, 2f792 <interface_from_internal_id_search+0x56>
   2f78a:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
   2f78e:	4282      	cmp	r2, r0
   2f790:	d020      	beq.n	2f7d4 <interface_from_internal_id_search+0x98>
   2f792:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
   2f796:	b11a      	cbz	r2, 2f7a0 <interface_from_internal_id_search+0x64>
   2f798:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
   2f79c:	4282      	cmp	r2, r0
   2f79e:	d01b      	beq.n	2f7d8 <interface_from_internal_id_search+0x9c>
   2f7a0:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   2f7a4:	b13a      	cbz	r2, 2f7b6 <interface_from_internal_id_search+0x7a>
   2f7a6:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
   2f7aa:	4283      	cmp	r3, r0
   2f7ac:	bf14      	ite	ne
   2f7ae:	f04f 30ff 	movne.w	r0, #4294967295
   2f7b2:	2008      	moveq	r0, #8
   2f7b4:	4770      	bx	lr
   2f7b6:	f04f 30ff 	mov.w	r0, #4294967295
   2f7ba:	4770      	bx	lr
   2f7bc:	2000      	movs	r0, #0
   2f7be:	4770      	bx	lr
   2f7c0:	2001      	movs	r0, #1
   2f7c2:	4770      	bx	lr
   2f7c4:	2002      	movs	r0, #2
   2f7c6:	4770      	bx	lr
   2f7c8:	2003      	movs	r0, #3
   2f7ca:	4770      	bx	lr
   2f7cc:	2004      	movs	r0, #4
   2f7ce:	4770      	bx	lr
   2f7d0:	2005      	movs	r0, #5
   2f7d2:	4770      	bx	lr
   2f7d4:	2006      	movs	r0, #6
   2f7d6:	4770      	bx	lr
   2f7d8:	2007      	movs	r0, #7
   2f7da:	4770      	bx	lr
   2f7dc:	2002614c 	.word	0x2002614c

0002f7e0 <interface_socket_from_handle_get>:
   2f7e0:	2808      	cmp	r0, #8
   2f7e2:	d807      	bhi.n	2f7f4 <interface_socket_from_handle_get+0x14>
   2f7e4:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   2f7e8:	4b03      	ldr	r3, [pc, #12]	; (2f7f8 <interface_socket_from_handle_get+0x18>)
   2f7ea:	0080      	lsls	r0, r0, #2
   2f7ec:	581a      	ldr	r2, [r3, r0]
   2f7ee:	b10a      	cbz	r2, 2f7f4 <interface_socket_from_handle_get+0x14>
   2f7f0:	4418      	add	r0, r3
   2f7f2:	4770      	bx	lr
   2f7f4:	2000      	movs	r0, #0
   2f7f6:	4770      	bx	lr
   2f7f8:	2002614c 	.word	0x2002614c

0002f7fc <interface_socket_event_get>:
   2f7fc:	b119      	cbz	r1, 2f806 <interface_socket_event_get+0xa>
   2f7fe:	2808      	cmp	r0, #8
   2f800:	d902      	bls.n	2f808 <interface_socket_event_get+0xc>
   2f802:	2310      	movs	r3, #16
   2f804:	600b      	str	r3, [r1, #0]
   2f806:	4770      	bx	lr
   2f808:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   2f80c:	4b07      	ldr	r3, [pc, #28]	; (2f82c <interface_socket_event_get+0x30>)
   2f80e:	0080      	lsls	r0, r0, #2
   2f810:	581a      	ldr	r2, [r3, r0]
   2f812:	2a00      	cmp	r2, #0
   2f814:	d0f5      	beq.n	2f802 <interface_socket_event_get+0x6>
   2f816:	581b      	ldr	r3, [r3, r0]
   2f818:	0c1b      	lsrs	r3, r3, #16
   2f81a:	f003 020a 	and.w	r2, r3, #10
   2f81e:	2a0a      	cmp	r2, #10
   2f820:	bf14      	ite	ne
   2f822:	f003 030f 	andne.w	r3, r3, #15
   2f826:	f003 030d 	andeq.w	r3, r3, #13
   2f82a:	e7eb      	b.n	2f804 <interface_socket_event_get+0x8>
   2f82c:	2002614c 	.word	0x2002614c

0002f830 <interface_socket_setopt>:
   2f830:	2808      	cmp	r0, #8
   2f832:	b538      	push	{r3, r4, r5, lr}
   2f834:	d82d      	bhi.n	2f892 <interface_socket_setopt+0x62>
   2f836:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   2f83a:	4c1c      	ldr	r4, [pc, #112]	; (2f8ac <interface_socket_setopt+0x7c>)
   2f83c:	0080      	lsls	r0, r0, #2
   2f83e:	461d      	mov	r5, r3
   2f840:	5823      	ldr	r3, [r4, r0]
   2f842:	b333      	cbz	r3, 2f892 <interface_socket_setopt+0x62>
   2f844:	2901      	cmp	r1, #1
   2f846:	d11e      	bne.n	2f886 <interface_socket_setopt+0x56>
   2f848:	2a14      	cmp	r2, #20
   2f84a:	d11c      	bne.n	2f886 <interface_socket_setopt+0x56>
   2f84c:	b1ad      	cbz	r5, 2f87a <interface_socket_setopt+0x4a>
   2f84e:	9b04      	ldr	r3, [sp, #16]
   2f850:	2b08      	cmp	r3, #8
   2f852:	d112      	bne.n	2f87a <interface_socket_setopt+0x4a>
   2f854:	686a      	ldr	r2, [r5, #4]
   2f856:	4b16      	ldr	r3, [pc, #88]	; (2f8b0 <interface_socket_setopt+0x80>)
   2f858:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   2f85c:	fba3 3202 	umull	r3, r2, r3, r2
   2f860:	2300      	movs	r3, #0
   2f862:	682d      	ldr	r5, [r5, #0]
   2f864:	0992      	lsrs	r2, r2, #6
   2f866:	fbe1 2305 	umlal	r2, r3, r1, r5
   2f86a:	2b01      	cmp	r3, #1
   2f86c:	bf08      	it	eq
   2f86e:	2a00      	cmpeq	r2, #0
   2f870:	d215      	bcs.n	2f89e <interface_socket_setopt+0x6e>
   2f872:	4420      	add	r0, r4
   2f874:	6202      	str	r2, [r0, #32]
   2f876:	2000      	movs	r0, #0
   2f878:	bd38      	pop	{r3, r4, r5, pc}
   2f87a:	2016      	movs	r0, #22
   2f87c:	f7f8 f8f0 	bl	27a60 <bsd_os_errno_set>
   2f880:	f04f 30ff 	mov.w	r0, #4294967295
   2f884:	bd38      	pop	{r3, r4, r5, pc}
   2f886:	202a      	movs	r0, #42	; 0x2a
   2f888:	f7f8 f8ea 	bl	27a60 <bsd_os_errno_set>
   2f88c:	f04f 30ff 	mov.w	r0, #4294967295
   2f890:	bd38      	pop	{r3, r4, r5, pc}
   2f892:	2009      	movs	r0, #9
   2f894:	f7f8 f8e4 	bl	27a60 <bsd_os_errno_set>
   2f898:	f04f 30ff 	mov.w	r0, #4294967295
   2f89c:	bd38      	pop	{r3, r4, r5, pc}
   2f89e:	2025      	movs	r0, #37	; 0x25
   2f8a0:	f7f8 f8de 	bl	27a60 <bsd_os_errno_set>
   2f8a4:	f04f 30ff 	mov.w	r0, #4294967295
   2f8a8:	bd38      	pop	{r3, r4, r5, pc}
   2f8aa:	bf00      	nop
   2f8ac:	2002614c 	.word	0x2002614c
   2f8b0:	10624dd3 	.word	0x10624dd3

0002f8b4 <interface_socket_getopt>:
   2f8b4:	b570      	push	{r4, r5, r6, lr}
   2f8b6:	2808      	cmp	r0, #8
   2f8b8:	9d04      	ldr	r5, [sp, #16]
   2f8ba:	d821      	bhi.n	2f900 <interface_socket_getopt+0x4c>
   2f8bc:	4c13      	ldr	r4, [pc, #76]	; (2f90c <interface_socket_getopt+0x58>)
   2f8be:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   2f8c2:	0080      	lsls	r0, r0, #2
   2f8c4:	5826      	ldr	r6, [r4, r0]
   2f8c6:	4404      	add	r4, r0
   2f8c8:	b1d6      	cbz	r6, 2f900 <interface_socket_getopt+0x4c>
   2f8ca:	2901      	cmp	r1, #1
   2f8cc:	d112      	bne.n	2f8f4 <interface_socket_getopt+0x40>
   2f8ce:	2a04      	cmp	r2, #4
   2f8d0:	d110      	bne.n	2f8f4 <interface_socket_getopt+0x40>
   2f8d2:	b14b      	cbz	r3, 2f8e8 <interface_socket_getopt+0x34>
   2f8d4:	b145      	cbz	r5, 2f8e8 <interface_socket_getopt+0x34>
   2f8d6:	682a      	ldr	r2, [r5, #0]
   2f8d8:	2a04      	cmp	r2, #4
   2f8da:	d105      	bne.n	2f8e8 <interface_socket_getopt+0x34>
   2f8dc:	2200      	movs	r2, #0
   2f8de:	6861      	ldr	r1, [r4, #4]
   2f8e0:	4610      	mov	r0, r2
   2f8e2:	6019      	str	r1, [r3, #0]
   2f8e4:	6062      	str	r2, [r4, #4]
   2f8e6:	bd70      	pop	{r4, r5, r6, pc}
   2f8e8:	2016      	movs	r0, #22
   2f8ea:	f7f8 f8b9 	bl	27a60 <bsd_os_errno_set>
   2f8ee:	f04f 30ff 	mov.w	r0, #4294967295
   2f8f2:	bd70      	pop	{r4, r5, r6, pc}
   2f8f4:	202a      	movs	r0, #42	; 0x2a
   2f8f6:	f7f8 f8b3 	bl	27a60 <bsd_os_errno_set>
   2f8fa:	f04f 30ff 	mov.w	r0, #4294967295
   2f8fe:	bd70      	pop	{r4, r5, r6, pc}
   2f900:	2009      	movs	r0, #9
   2f902:	f7f8 f8ad 	bl	27a60 <bsd_os_errno_set>
   2f906:	f04f 30ff 	mov.w	r0, #4294967295
   2f90a:	bd70      	pop	{r4, r5, r6, pc}
   2f90c:	2002614c 	.word	0x2002614c

0002f910 <interface_socket_fcntl>:
   2f910:	2808      	cmp	r0, #8
   2f912:	b510      	push	{r4, lr}
   2f914:	d818      	bhi.n	2f948 <interface_socket_fcntl+0x38>
   2f916:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   2f91a:	4c11      	ldr	r4, [pc, #68]	; (2f960 <interface_socket_fcntl+0x50>)
   2f91c:	0083      	lsls	r3, r0, #2
   2f91e:	58e0      	ldr	r0, [r4, r3]
   2f920:	b190      	cbz	r0, 2f948 <interface_socket_fcntl+0x38>
   2f922:	2901      	cmp	r1, #1
   2f924:	d005      	beq.n	2f932 <interface_socket_fcntl+0x22>
   2f926:	2902      	cmp	r1, #2
   2f928:	d114      	bne.n	2f954 <interface_socket_fcntl+0x44>
   2f92a:	58e0      	ldr	r0, [r4, r3]
   2f92c:	f3c0 7000 	ubfx	r0, r0, #28, #1
   2f930:	bd10      	pop	{r4, pc}
   2f932:	f012 0001 	ands.w	r0, r2, #1
   2f936:	58e2      	ldr	r2, [r4, r3]
   2f938:	bf1a      	itte	ne
   2f93a:	2000      	movne	r0, #0
   2f93c:	f042 5280 	orrne.w	r2, r2, #268435456	; 0x10000000
   2f940:	f022 5280 	biceq.w	r2, r2, #268435456	; 0x10000000
   2f944:	50e2      	str	r2, [r4, r3]
   2f946:	bd10      	pop	{r4, pc}
   2f948:	2009      	movs	r0, #9
   2f94a:	f7f8 f889 	bl	27a60 <bsd_os_errno_set>
   2f94e:	f04f 30ff 	mov.w	r0, #4294967295
   2f952:	bd10      	pop	{r4, pc}
   2f954:	2016      	movs	r0, #22
   2f956:	f7f8 f883 	bl	27a60 <bsd_os_errno_set>
   2f95a:	f04f 30ff 	mov.w	r0, #4294967295
   2f95e:	bd10      	pop	{r4, pc}
   2f960:	2002614c 	.word	0x2002614c

0002f964 <bsd_os_application_irq_handler>:
   2f964:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2f968:	4c33      	ldr	r4, [pc, #204]	; (2fa38 <bsd_os_application_irq_handler+0xd4>)
   2f96a:	f7f8 f979 	bl	27c60 <bsd_os_application_irq_clear>
   2f96e:	f04f 0803 	mov.w	r8, #3
   2f972:	4d32      	ldr	r5, [pc, #200]	; (2fa3c <bsd_os_application_irq_handler+0xd8>)
   2f974:	4f32      	ldr	r7, [pc, #200]	; (2fa40 <bsd_os_application_irq_handler+0xdc>)
   2f976:	f104 0680 	add.w	r6, r4, #128	; 0x80
   2f97a:	e004      	b.n	2f986 <bsd_os_application_irq_handler+0x22>
   2f97c:	2b04      	cmp	r3, #4
   2f97e:	d006      	beq.n	2f98e <bsd_os_application_irq_handler+0x2a>
   2f980:	3408      	adds	r4, #8
   2f982:	42b4      	cmp	r4, r6
   2f984:	d03b      	beq.n	2f9fe <bsd_os_application_irq_handler+0x9a>
   2f986:	f814 3c04 	ldrb.w	r3, [r4, #-4]
   2f98a:	2b02      	cmp	r3, #2
   2f98c:	d1f6      	bne.n	2f97c <bsd_os_application_irq_handler+0x18>
   2f98e:	6820      	ldr	r0, [r4, #0]
   2f990:	882a      	ldrh	r2, [r5, #0]
   2f992:	6803      	ldr	r3, [r0, #0]
   2f994:	b29b      	uxth	r3, r3
   2f996:	429a      	cmp	r2, r3
   2f998:	d033      	beq.n	2fa02 <bsd_os_application_irq_handler+0x9e>
   2f99a:	8a2a      	ldrh	r2, [r5, #16]
   2f99c:	429a      	cmp	r2, r3
   2f99e:	d032      	beq.n	2fa06 <bsd_os_application_irq_handler+0xa2>
   2f9a0:	8c2a      	ldrh	r2, [r5, #32]
   2f9a2:	429a      	cmp	r2, r3
   2f9a4:	d031      	beq.n	2fa0a <bsd_os_application_irq_handler+0xa6>
   2f9a6:	8e2a      	ldrh	r2, [r5, #48]	; 0x30
   2f9a8:	429a      	cmp	r2, r3
   2f9aa:	d030      	beq.n	2fa0e <bsd_os_application_irq_handler+0xaa>
   2f9ac:	f8b5 2040 	ldrh.w	r2, [r5, #64]	; 0x40
   2f9b0:	429a      	cmp	r2, r3
   2f9b2:	d036      	beq.n	2fa22 <bsd_os_application_irq_handler+0xbe>
   2f9b4:	f8b5 2050 	ldrh.w	r2, [r5, #80]	; 0x50
   2f9b8:	429a      	cmp	r2, r3
   2f9ba:	d034      	beq.n	2fa26 <bsd_os_application_irq_handler+0xc2>
   2f9bc:	f8b5 2060 	ldrh.w	r2, [r5, #96]	; 0x60
   2f9c0:	429a      	cmp	r2, r3
   2f9c2:	d032      	beq.n	2fa2a <bsd_os_application_irq_handler+0xc6>
   2f9c4:	f8b5 2070 	ldrh.w	r2, [r5, #112]	; 0x70
   2f9c8:	429a      	cmp	r2, r3
   2f9ca:	d030      	beq.n	2fa2e <bsd_os_application_irq_handler+0xca>
   2f9cc:	f8b5 2080 	ldrh.w	r2, [r5, #128]	; 0x80
   2f9d0:	429a      	cmp	r2, r3
   2f9d2:	d02e      	beq.n	2fa32 <bsd_os_application_irq_handler+0xce>
   2f9d4:	f8b5 2090 	ldrh.w	r2, [r5, #144]	; 0x90
   2f9d8:	429a      	cmp	r2, r3
   2f9da:	bf08      	it	eq
   2f9dc:	2309      	moveq	r3, #9
   2f9de:	d1cf      	bne.n	2f980 <bsd_os_application_irq_handler+0x1c>
   2f9e0:	eb05 1303 	add.w	r3, r5, r3, lsl #4
   2f9e4:	685a      	ldr	r2, [r3, #4]
   2f9e6:	68d9      	ldr	r1, [r3, #12]
   2f9e8:	4790      	blx	r2
   2f9ea:	b990      	cbnz	r0, 2fa12 <bsd_os_application_irq_handler+0xae>
   2f9ec:	2201      	movs	r2, #1
   2f9ee:	6820      	ldr	r0, [r4, #0]
   2f9f0:	f804 2c04 	strb.w	r2, [r4, #-4]
   2f9f4:	68fb      	ldr	r3, [r7, #12]
   2f9f6:	3408      	adds	r4, #8
   2f9f8:	4798      	blx	r3
   2f9fa:	42b4      	cmp	r4, r6
   2f9fc:	d1c3      	bne.n	2f986 <bsd_os_application_irq_handler+0x22>
   2f9fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2fa02:	2300      	movs	r3, #0
   2fa04:	e7ec      	b.n	2f9e0 <bsd_os_application_irq_handler+0x7c>
   2fa06:	2301      	movs	r3, #1
   2fa08:	e7ea      	b.n	2f9e0 <bsd_os_application_irq_handler+0x7c>
   2fa0a:	2302      	movs	r3, #2
   2fa0c:	e7e8      	b.n	2f9e0 <bsd_os_application_irq_handler+0x7c>
   2fa0e:	2303      	movs	r3, #3
   2fa10:	e7e6      	b.n	2f9e0 <bsd_os_application_irq_handler+0x7c>
   2fa12:	2802      	cmp	r0, #2
   2fa14:	bf0a      	itet	eq
   2fa16:	2304      	moveq	r3, #4
   2fa18:	f804 8c04 	strbne.w	r8, [r4, #-4]
   2fa1c:	f804 3c04 	strbeq.w	r3, [r4, #-4]
   2fa20:	e7ae      	b.n	2f980 <bsd_os_application_irq_handler+0x1c>
   2fa22:	2304      	movs	r3, #4
   2fa24:	e7dc      	b.n	2f9e0 <bsd_os_application_irq_handler+0x7c>
   2fa26:	2305      	movs	r3, #5
   2fa28:	e7da      	b.n	2f9e0 <bsd_os_application_irq_handler+0x7c>
   2fa2a:	2306      	movs	r3, #6
   2fa2c:	e7d8      	b.n	2f9e0 <bsd_os_application_irq_handler+0x7c>
   2fa2e:	2307      	movs	r3, #7
   2fa30:	e7d6      	b.n	2f9e0 <bsd_os_application_irq_handler+0x7c>
   2fa32:	2308      	movs	r3, #8
   2fa34:	e7d4      	b.n	2f9e0 <bsd_os_application_irq_handler+0x7c>
   2fa36:	bf00      	nop
   2fa38:	20020e60 	.word	0x20020e60
   2fa3c:	20020d24 	.word	0x20020d24
   2fa40:	20020dc4 	.word	0x20020dc4

0002fa44 <rpc_framework_init>:
   2fa44:	b508      	push	{r3, lr}
   2fa46:	22a0      	movs	r2, #160	; 0xa0
   2fa48:	2100      	movs	r1, #0
   2fa4a:	4802      	ldr	r0, [pc, #8]	; (2fa54 <rpc_framework_init+0x10>)
   2fa4c:	f00a f9b7 	bl	39dbe <memset>
   2fa50:	2000      	movs	r0, #0
   2fa52:	bd08      	pop	{r3, pc}
   2fa54:	20020d24 	.word	0x20020d24

0002fa58 <rpc_client_register>:
   2fa58:	8803      	ldrh	r3, [r0, #0]
   2fa5a:	2b00      	cmp	r3, #0
   2fa5c:	d045      	beq.n	2faea <rpc_client_register+0x92>
   2fa5e:	6842      	ldr	r2, [r0, #4]
   2fa60:	4601      	mov	r1, r0
   2fa62:	2a00      	cmp	r2, #0
   2fa64:	d050      	beq.n	2fb08 <rpc_client_register+0xb0>
   2fa66:	4a30      	ldr	r2, [pc, #192]	; (2fb28 <rpc_client_register+0xd0>)
   2fa68:	8810      	ldrh	r0, [r2, #0]
   2fa6a:	4283      	cmp	r3, r0
   2fa6c:	d03d      	beq.n	2faea <rpc_client_register+0x92>
   2fa6e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2fa72:	8a14      	ldrh	r4, [r2, #16]
   2fa74:	42a3      	cmp	r3, r4
   2fa76:	d035      	beq.n	2fae4 <rpc_client_register+0x8c>
   2fa78:	8c15      	ldrh	r5, [r2, #32]
   2fa7a:	42ab      	cmp	r3, r5
   2fa7c:	d032      	beq.n	2fae4 <rpc_client_register+0x8c>
   2fa7e:	8e16      	ldrh	r6, [r2, #48]	; 0x30
   2fa80:	42b3      	cmp	r3, r6
   2fa82:	d02f      	beq.n	2fae4 <rpc_client_register+0x8c>
   2fa84:	f8b2 7040 	ldrh.w	r7, [r2, #64]	; 0x40
   2fa88:	42bb      	cmp	r3, r7
   2fa8a:	d02b      	beq.n	2fae4 <rpc_client_register+0x8c>
   2fa8c:	f8b2 c050 	ldrh.w	ip, [r2, #80]	; 0x50
   2fa90:	4563      	cmp	r3, ip
   2fa92:	d027      	beq.n	2fae4 <rpc_client_register+0x8c>
   2fa94:	f8b2 e060 	ldrh.w	lr, [r2, #96]	; 0x60
   2fa98:	4573      	cmp	r3, lr
   2fa9a:	d023      	beq.n	2fae4 <rpc_client_register+0x8c>
   2fa9c:	f8b2 8070 	ldrh.w	r8, [r2, #112]	; 0x70
   2faa0:	4543      	cmp	r3, r8
   2faa2:	d01f      	beq.n	2fae4 <rpc_client_register+0x8c>
   2faa4:	f8b2 9080 	ldrh.w	r9, [r2, #128]	; 0x80
   2faa8:	454b      	cmp	r3, r9
   2faaa:	d01b      	beq.n	2fae4 <rpc_client_register+0x8c>
   2faac:	f8b2 a090 	ldrh.w	sl, [r2, #144]	; 0x90
   2fab0:	4553      	cmp	r3, sl
   2fab2:	d017      	beq.n	2fae4 <rpc_client_register+0x8c>
   2fab4:	b1e0      	cbz	r0, 2faf0 <rpc_client_register+0x98>
   2fab6:	b35c      	cbz	r4, 2fb10 <rpc_client_register+0xb8>
   2fab8:	b365      	cbz	r5, 2fb14 <rpc_client_register+0xbc>
   2faba:	b36e      	cbz	r6, 2fb18 <rpc_client_register+0xc0>
   2fabc:	b377      	cbz	r7, 2fb1c <rpc_client_register+0xc4>
   2fabe:	f1bc 0f00 	cmp.w	ip, #0
   2fac2:	d02d      	beq.n	2fb20 <rpc_client_register+0xc8>
   2fac4:	f1be 0f00 	cmp.w	lr, #0
   2fac8:	d020      	beq.n	2fb0c <rpc_client_register+0xb4>
   2faca:	f1b8 0f00 	cmp.w	r8, #0
   2face:	d029      	beq.n	2fb24 <rpc_client_register+0xcc>
   2fad0:	f1b9 0f00 	cmp.w	r9, #0
   2fad4:	d00b      	beq.n	2faee <rpc_client_register+0x96>
   2fad6:	2009      	movs	r0, #9
   2fad8:	f1ba 0f00 	cmp.w	sl, #0
   2fadc:	d008      	beq.n	2faf0 <rpc_client_register+0x98>
   2fade:	2004      	movs	r0, #4
   2fae0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2fae4:	2007      	movs	r0, #7
   2fae6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2faea:	2007      	movs	r0, #7
   2faec:	4770      	bx	lr
   2faee:	2008      	movs	r0, #8
   2faf0:	0100      	lsls	r0, r0, #4
   2faf2:	5213      	strh	r3, [r2, r0]
   2faf4:	684b      	ldr	r3, [r1, #4]
   2faf6:	4402      	add	r2, r0
   2faf8:	6053      	str	r3, [r2, #4]
   2fafa:	688b      	ldr	r3, [r1, #8]
   2fafc:	2000      	movs	r0, #0
   2fafe:	6093      	str	r3, [r2, #8]
   2fb00:	68cb      	ldr	r3, [r1, #12]
   2fb02:	60d3      	str	r3, [r2, #12]
   2fb04:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2fb08:	200e      	movs	r0, #14
   2fb0a:	4770      	bx	lr
   2fb0c:	2006      	movs	r0, #6
   2fb0e:	e7ef      	b.n	2faf0 <rpc_client_register+0x98>
   2fb10:	2001      	movs	r0, #1
   2fb12:	e7ed      	b.n	2faf0 <rpc_client_register+0x98>
   2fb14:	2002      	movs	r0, #2
   2fb16:	e7eb      	b.n	2faf0 <rpc_client_register+0x98>
   2fb18:	2003      	movs	r0, #3
   2fb1a:	e7e9      	b.n	2faf0 <rpc_client_register+0x98>
   2fb1c:	2004      	movs	r0, #4
   2fb1e:	e7e7      	b.n	2faf0 <rpc_client_register+0x98>
   2fb20:	2005      	movs	r0, #5
   2fb22:	e7e5      	b.n	2faf0 <rpc_client_register+0x98>
   2fb24:	2007      	movs	r0, #7
   2fb26:	e7e3      	b.n	2faf0 <rpc_client_register+0x98>
   2fb28:	20020d24 	.word	0x20020d24

0002fb2c <rpc_transport_input>:
   2fb2c:	b538      	push	{r3, r4, r5, lr}
   2fb2e:	4a82      	ldr	r2, [pc, #520]	; (2fd38 <rpc_transport_input+0x20c>)
   2fb30:	680b      	ldr	r3, [r1, #0]
   2fb32:	8810      	ldrh	r0, [r2, #0]
   2fb34:	b29b      	uxth	r3, r3
   2fb36:	4298      	cmp	r0, r3
   2fb38:	d027      	beq.n	2fb8a <rpc_transport_input+0x5e>
   2fb3a:	8a10      	ldrh	r0, [r2, #16]
   2fb3c:	4298      	cmp	r0, r3
   2fb3e:	d024      	beq.n	2fb8a <rpc_transport_input+0x5e>
   2fb40:	8c10      	ldrh	r0, [r2, #32]
   2fb42:	4298      	cmp	r0, r3
   2fb44:	d021      	beq.n	2fb8a <rpc_transport_input+0x5e>
   2fb46:	8e10      	ldrh	r0, [r2, #48]	; 0x30
   2fb48:	4298      	cmp	r0, r3
   2fb4a:	d01e      	beq.n	2fb8a <rpc_transport_input+0x5e>
   2fb4c:	f8b2 0040 	ldrh.w	r0, [r2, #64]	; 0x40
   2fb50:	4298      	cmp	r0, r3
   2fb52:	d01a      	beq.n	2fb8a <rpc_transport_input+0x5e>
   2fb54:	f8b2 0050 	ldrh.w	r0, [r2, #80]	; 0x50
   2fb58:	4298      	cmp	r0, r3
   2fb5a:	d016      	beq.n	2fb8a <rpc_transport_input+0x5e>
   2fb5c:	f8b2 0060 	ldrh.w	r0, [r2, #96]	; 0x60
   2fb60:	4298      	cmp	r0, r3
   2fb62:	d012      	beq.n	2fb8a <rpc_transport_input+0x5e>
   2fb64:	f8b2 0070 	ldrh.w	r0, [r2, #112]	; 0x70
   2fb68:	4298      	cmp	r0, r3
   2fb6a:	d00e      	beq.n	2fb8a <rpc_transport_input+0x5e>
   2fb6c:	f8b2 0080 	ldrh.w	r0, [r2, #128]	; 0x80
   2fb70:	4298      	cmp	r0, r3
   2fb72:	d00a      	beq.n	2fb8a <rpc_transport_input+0x5e>
   2fb74:	f8b2 2090 	ldrh.w	r2, [r2, #144]	; 0x90
   2fb78:	429a      	cmp	r2, r3
   2fb7a:	d006      	beq.n	2fb8a <rpc_transport_input+0x5e>
   2fb7c:	6888      	ldr	r0, [r1, #8]
   2fb7e:	b118      	cbz	r0, 2fb88 <rpc_transport_input+0x5c>
   2fb80:	4b6e      	ldr	r3, [pc, #440]	; (2fd3c <rpc_transport_input+0x210>)
   2fb82:	691b      	ldr	r3, [r3, #16]
   2fb84:	4798      	blx	r3
   2fb86:	2000      	movs	r0, #0
   2fb88:	bd38      	pop	{r3, r4, r5, pc}
   2fb8a:	6888      	ldr	r0, [r1, #8]
   2fb8c:	2800      	cmp	r0, #0
   2fb8e:	f000 8098 	beq.w	2fcc2 <rpc_transport_input+0x196>
   2fb92:	4a6b      	ldr	r2, [pc, #428]	; (2fd40 <rpc_transport_input+0x214>)
   2fb94:	6814      	ldr	r4, [r2, #0]
   2fb96:	2c00      	cmp	r4, #0
   2fb98:	d03c      	beq.n	2fc14 <rpc_transport_input+0xe8>
   2fb9a:	6894      	ldr	r4, [r2, #8]
   2fb9c:	2c00      	cmp	r4, #0
   2fb9e:	f000 809a 	beq.w	2fcd6 <rpc_transport_input+0x1aa>
   2fba2:	6914      	ldr	r4, [r2, #16]
   2fba4:	2c00      	cmp	r4, #0
   2fba6:	f000 809a 	beq.w	2fcde <rpc_transport_input+0x1b2>
   2fbaa:	6994      	ldr	r4, [r2, #24]
   2fbac:	2c00      	cmp	r4, #0
   2fbae:	f000 809a 	beq.w	2fce6 <rpc_transport_input+0x1ba>
   2fbb2:	6a14      	ldr	r4, [r2, #32]
   2fbb4:	2c00      	cmp	r4, #0
   2fbb6:	f000 809a 	beq.w	2fcee <rpc_transport_input+0x1c2>
   2fbba:	6a94      	ldr	r4, [r2, #40]	; 0x28
   2fbbc:	2c00      	cmp	r4, #0
   2fbbe:	f000 8084 	beq.w	2fcca <rpc_transport_input+0x19e>
   2fbc2:	6b14      	ldr	r4, [r2, #48]	; 0x30
   2fbc4:	2c00      	cmp	r4, #0
   2fbc6:	f000 8098 	beq.w	2fcfa <rpc_transport_input+0x1ce>
   2fbca:	6b94      	ldr	r4, [r2, #56]	; 0x38
   2fbcc:	2c00      	cmp	r4, #0
   2fbce:	f000 8096 	beq.w	2fcfe <rpc_transport_input+0x1d2>
   2fbd2:	6c14      	ldr	r4, [r2, #64]	; 0x40
   2fbd4:	2c00      	cmp	r4, #0
   2fbd6:	f000 8096 	beq.w	2fd06 <rpc_transport_input+0x1da>
   2fbda:	6c94      	ldr	r4, [r2, #72]	; 0x48
   2fbdc:	2c00      	cmp	r4, #0
   2fbde:	f000 8096 	beq.w	2fd0e <rpc_transport_input+0x1e2>
   2fbe2:	6d14      	ldr	r4, [r2, #80]	; 0x50
   2fbe4:	2c00      	cmp	r4, #0
   2fbe6:	f000 8096 	beq.w	2fd16 <rpc_transport_input+0x1ea>
   2fbea:	6d94      	ldr	r4, [r2, #88]	; 0x58
   2fbec:	2c00      	cmp	r4, #0
   2fbee:	f000 8098 	beq.w	2fd22 <rpc_transport_input+0x1f6>
   2fbf2:	6e14      	ldr	r4, [r2, #96]	; 0x60
   2fbf4:	2c00      	cmp	r4, #0
   2fbf6:	f000 8098 	beq.w	2fd2a <rpc_transport_input+0x1fe>
   2fbfa:	6e94      	ldr	r4, [r2, #104]	; 0x68
   2fbfc:	2c00      	cmp	r4, #0
   2fbfe:	f000 8096 	beq.w	2fd2e <rpc_transport_input+0x202>
   2fc02:	6f14      	ldr	r4, [r2, #112]	; 0x70
   2fc04:	2c00      	cmp	r4, #0
   2fc06:	f000 8094 	beq.w	2fd32 <rpc_transport_input+0x206>
   2fc0a:	6f94      	ldr	r4, [r2, #120]	; 0x78
   2fc0c:	b10c      	cbz	r4, 2fc12 <rpc_transport_input+0xe6>
   2fc0e:	2001      	movs	r0, #1
   2fc10:	bd38      	pop	{r3, r4, r5, pc}
   2fc12:	240f      	movs	r4, #15
   2fc14:	eb02 05c4 	add.w	r5, r2, r4, lsl #3
   2fc18:	f842 0034 	str.w	r0, [r2, r4, lsl #3]
   2fc1c:	80ab      	strh	r3, [r5, #4]
   2fc1e:	4b49      	ldr	r3, [pc, #292]	; (2fd44 <rpc_transport_input+0x218>)
   2fc20:	781a      	ldrb	r2, [r3, #0]
   2fc22:	2a01      	cmp	r2, #1
   2fc24:	d053      	beq.n	2fcce <rpc_transport_input+0x1a2>
   2fc26:	7a1a      	ldrb	r2, [r3, #8]
   2fc28:	2a01      	cmp	r2, #1
   2fc2a:	d041      	beq.n	2fcb0 <rpc_transport_input+0x184>
   2fc2c:	7c1a      	ldrb	r2, [r3, #16]
   2fc2e:	2a01      	cmp	r2, #1
   2fc30:	d04f      	beq.n	2fcd2 <rpc_transport_input+0x1a6>
   2fc32:	7e1a      	ldrb	r2, [r3, #24]
   2fc34:	2a01      	cmp	r2, #1
   2fc36:	d050      	beq.n	2fcda <rpc_transport_input+0x1ae>
   2fc38:	f893 2020 	ldrb.w	r2, [r3, #32]
   2fc3c:	2a01      	cmp	r2, #1
   2fc3e:	d050      	beq.n	2fce2 <rpc_transport_input+0x1b6>
   2fc40:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
   2fc44:	2a01      	cmp	r2, #1
   2fc46:	d050      	beq.n	2fcea <rpc_transport_input+0x1be>
   2fc48:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
   2fc4c:	2a01      	cmp	r2, #1
   2fc4e:	d03a      	beq.n	2fcc6 <rpc_transport_input+0x19a>
   2fc50:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
   2fc54:	2a01      	cmp	r2, #1
   2fc56:	d04c      	beq.n	2fcf2 <rpc_transport_input+0x1c6>
   2fc58:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
   2fc5c:	2a01      	cmp	r2, #1
   2fc5e:	d04a      	beq.n	2fcf6 <rpc_transport_input+0x1ca>
   2fc60:	f893 2048 	ldrb.w	r2, [r3, #72]	; 0x48
   2fc64:	2a01      	cmp	r2, #1
   2fc66:	d04c      	beq.n	2fd02 <rpc_transport_input+0x1d6>
   2fc68:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
   2fc6c:	2a01      	cmp	r2, #1
   2fc6e:	d04c      	beq.n	2fd0a <rpc_transport_input+0x1de>
   2fc70:	f893 2058 	ldrb.w	r2, [r3, #88]	; 0x58
   2fc74:	2a01      	cmp	r2, #1
   2fc76:	d04c      	beq.n	2fd12 <rpc_transport_input+0x1e6>
   2fc78:	f893 2060 	ldrb.w	r2, [r3, #96]	; 0x60
   2fc7c:	2a01      	cmp	r2, #1
   2fc7e:	d04c      	beq.n	2fd1a <rpc_transport_input+0x1ee>
   2fc80:	f893 2068 	ldrb.w	r2, [r3, #104]	; 0x68
   2fc84:	2a01      	cmp	r2, #1
   2fc86:	d04a      	beq.n	2fd1e <rpc_transport_input+0x1f2>
   2fc88:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
   2fc8c:	2a01      	cmp	r2, #1
   2fc8e:	d04a      	beq.n	2fd26 <rpc_transport_input+0x1fa>
   2fc90:	f893 2078 	ldrb.w	r2, [r3, #120]	; 0x78
   2fc94:	2a01      	cmp	r2, #1
   2fc96:	d00a      	beq.n	2fcae <rpc_transport_input+0x182>
   2fc98:	2c10      	cmp	r4, #16
   2fc9a:	d0b8      	beq.n	2fc0e <rpc_transport_input+0xe2>
   2fc9c:	2200      	movs	r2, #0
   2fc9e:	4b28      	ldr	r3, [pc, #160]	; (2fd40 <rpc_transport_input+0x214>)
   2fca0:	2001      	movs	r0, #1
   2fca2:	eb03 01c4 	add.w	r1, r3, r4, lsl #3
   2fca6:	808a      	strh	r2, [r1, #4]
   2fca8:	f843 2034 	str.w	r2, [r3, r4, lsl #3]
   2fcac:	bd38      	pop	{r3, r4, r5, pc}
   2fcae:	220f      	movs	r2, #15
   2fcb0:	2402      	movs	r4, #2
   2fcb2:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
   2fcb6:	f803 4032 	strb.w	r4, [r3, r2, lsl #3]
   2fcba:	6041      	str	r1, [r0, #4]
   2fcbc:	f7f7 ffc8 	bl	27c50 <bsd_os_application_irq_set>
   2fcc0:	e7a5      	b.n	2fc0e <rpc_transport_input+0xe2>
   2fcc2:	2410      	movs	r4, #16
   2fcc4:	e7ab      	b.n	2fc1e <rpc_transport_input+0xf2>
   2fcc6:	2206      	movs	r2, #6
   2fcc8:	e7f2      	b.n	2fcb0 <rpc_transport_input+0x184>
   2fcca:	2405      	movs	r4, #5
   2fccc:	e7a2      	b.n	2fc14 <rpc_transport_input+0xe8>
   2fcce:	2200      	movs	r2, #0
   2fcd0:	e7ee      	b.n	2fcb0 <rpc_transport_input+0x184>
   2fcd2:	2202      	movs	r2, #2
   2fcd4:	e7ec      	b.n	2fcb0 <rpc_transport_input+0x184>
   2fcd6:	2401      	movs	r4, #1
   2fcd8:	e79c      	b.n	2fc14 <rpc_transport_input+0xe8>
   2fcda:	2203      	movs	r2, #3
   2fcdc:	e7e8      	b.n	2fcb0 <rpc_transport_input+0x184>
   2fcde:	2402      	movs	r4, #2
   2fce0:	e798      	b.n	2fc14 <rpc_transport_input+0xe8>
   2fce2:	2204      	movs	r2, #4
   2fce4:	e7e4      	b.n	2fcb0 <rpc_transport_input+0x184>
   2fce6:	2403      	movs	r4, #3
   2fce8:	e794      	b.n	2fc14 <rpc_transport_input+0xe8>
   2fcea:	2205      	movs	r2, #5
   2fcec:	e7e0      	b.n	2fcb0 <rpc_transport_input+0x184>
   2fcee:	2404      	movs	r4, #4
   2fcf0:	e790      	b.n	2fc14 <rpc_transport_input+0xe8>
   2fcf2:	2207      	movs	r2, #7
   2fcf4:	e7dc      	b.n	2fcb0 <rpc_transport_input+0x184>
   2fcf6:	2208      	movs	r2, #8
   2fcf8:	e7da      	b.n	2fcb0 <rpc_transport_input+0x184>
   2fcfa:	2406      	movs	r4, #6
   2fcfc:	e78a      	b.n	2fc14 <rpc_transport_input+0xe8>
   2fcfe:	2407      	movs	r4, #7
   2fd00:	e788      	b.n	2fc14 <rpc_transport_input+0xe8>
   2fd02:	2209      	movs	r2, #9
   2fd04:	e7d4      	b.n	2fcb0 <rpc_transport_input+0x184>
   2fd06:	2408      	movs	r4, #8
   2fd08:	e784      	b.n	2fc14 <rpc_transport_input+0xe8>
   2fd0a:	220a      	movs	r2, #10
   2fd0c:	e7d0      	b.n	2fcb0 <rpc_transport_input+0x184>
   2fd0e:	2409      	movs	r4, #9
   2fd10:	e780      	b.n	2fc14 <rpc_transport_input+0xe8>
   2fd12:	220b      	movs	r2, #11
   2fd14:	e7cc      	b.n	2fcb0 <rpc_transport_input+0x184>
   2fd16:	240a      	movs	r4, #10
   2fd18:	e77c      	b.n	2fc14 <rpc_transport_input+0xe8>
   2fd1a:	220c      	movs	r2, #12
   2fd1c:	e7c8      	b.n	2fcb0 <rpc_transport_input+0x184>
   2fd1e:	220d      	movs	r2, #13
   2fd20:	e7c6      	b.n	2fcb0 <rpc_transport_input+0x184>
   2fd22:	240b      	movs	r4, #11
   2fd24:	e776      	b.n	2fc14 <rpc_transport_input+0xe8>
   2fd26:	220e      	movs	r2, #14
   2fd28:	e7c2      	b.n	2fcb0 <rpc_transport_input+0x184>
   2fd2a:	240c      	movs	r4, #12
   2fd2c:	e772      	b.n	2fc14 <rpc_transport_input+0xe8>
   2fd2e:	240d      	movs	r4, #13
   2fd30:	e770      	b.n	2fc14 <rpc_transport_input+0xe8>
   2fd32:	240e      	movs	r4, #14
   2fd34:	e76e      	b.n	2fc14 <rpc_transport_input+0xe8>
   2fd36:	bf00      	nop
   2fd38:	20020d24 	.word	0x20020d24
   2fd3c:	20020dc4 	.word	0x20020dc4
   2fd40:	20020ddc 	.word	0x20020ddc
   2fd44:	20020e5c 	.word	0x20020e5c

0002fd48 <rpc_transport_register>:
   2fd48:	b4f0      	push	{r4, r5, r6, r7}
   2fd4a:	2900      	cmp	r1, #0
   2fd4c:	d052      	beq.n	2fdf4 <rpc_transport_register+0xac>
   2fd4e:	2800      	cmp	r0, #0
   2fd50:	d050      	beq.n	2fdf4 <rpc_transport_register+0xac>
   2fd52:	6883      	ldr	r3, [r0, #8]
   2fd54:	2b00      	cmp	r3, #0
   2fd56:	d04d      	beq.n	2fdf4 <rpc_transport_register+0xac>
   2fd58:	6903      	ldr	r3, [r0, #16]
   2fd5a:	2b00      	cmp	r3, #0
   2fd5c:	d04a      	beq.n	2fdf4 <rpc_transport_register+0xac>
   2fd5e:	6843      	ldr	r3, [r0, #4]
   2fd60:	2b00      	cmp	r3, #0
   2fd62:	d047      	beq.n	2fdf4 <rpc_transport_register+0xac>
   2fd64:	68c3      	ldr	r3, [r0, #12]
   2fd66:	2b00      	cmp	r3, #0
   2fd68:	d044      	beq.n	2fdf4 <rpc_transport_register+0xac>
   2fd6a:	6803      	ldr	r3, [r0, #0]
   2fd6c:	2b00      	cmp	r3, #0
   2fd6e:	d041      	beq.n	2fdf4 <rpc_transport_register+0xac>
   2fd70:	6943      	ldr	r3, [r0, #20]
   2fd72:	2b00      	cmp	r3, #0
   2fd74:	d03e      	beq.n	2fdf4 <rpc_transport_register+0xac>
   2fd76:	2601      	movs	r6, #1
   2fd78:	2500      	movs	r5, #0
   2fd7a:	4604      	mov	r4, r0
   2fd7c:	460f      	mov	r7, r1
   2fd7e:	4a1f      	ldr	r2, [pc, #124]	; (2fdfc <rpc_transport_register+0xb4>)
   2fd80:	4b1f      	ldr	r3, [pc, #124]	; (2fe00 <rpc_transport_register+0xb8>)
   2fd82:	f8df c080 	ldr.w	ip, [pc, #128]	; 2fe04 <rpc_transport_register+0xbc>
   2fd86:	7416      	strb	r6, [r2, #16]
   2fd88:	7616      	strb	r6, [r2, #24]
   2fd8a:	f882 6020 	strb.w	r6, [r2, #32]
   2fd8e:	f882 6028 	strb.w	r6, [r2, #40]	; 0x28
   2fd92:	f882 6030 	strb.w	r6, [r2, #48]	; 0x30
   2fd96:	f882 6038 	strb.w	r6, [r2, #56]	; 0x38
   2fd9a:	f882 6040 	strb.w	r6, [r2, #64]	; 0x40
   2fd9e:	f882 6048 	strb.w	r6, [r2, #72]	; 0x48
   2fda2:	f882 6050 	strb.w	r6, [r2, #80]	; 0x50
   2fda6:	f882 6058 	strb.w	r6, [r2, #88]	; 0x58
   2fdaa:	f882 6060 	strb.w	r6, [r2, #96]	; 0x60
   2fdae:	f882 6068 	strb.w	r6, [r2, #104]	; 0x68
   2fdb2:	f882 6070 	strb.w	r6, [r2, #112]	; 0x70
   2fdb6:	f882 6078 	strb.w	r6, [r2, #120]	; 0x78
   2fdba:	611d      	str	r5, [r3, #16]
   2fdbc:	619d      	str	r5, [r3, #24]
   2fdbe:	621d      	str	r5, [r3, #32]
   2fdc0:	629d      	str	r5, [r3, #40]	; 0x28
   2fdc2:	631d      	str	r5, [r3, #48]	; 0x30
   2fdc4:	639d      	str	r5, [r3, #56]	; 0x38
   2fdc6:	641d      	str	r5, [r3, #64]	; 0x40
   2fdc8:	649d      	str	r5, [r3, #72]	; 0x48
   2fdca:	651d      	str	r5, [r3, #80]	; 0x50
   2fdcc:	659d      	str	r5, [r3, #88]	; 0x58
   2fdce:	661d      	str	r5, [r3, #96]	; 0x60
   2fdd0:	669d      	str	r5, [r3, #104]	; 0x68
   2fdd2:	671d      	str	r5, [r3, #112]	; 0x70
   2fdd4:	679d      	str	r5, [r3, #120]	; 0x78
   2fdd6:	7016      	strb	r6, [r2, #0]
   2fdd8:	7216      	strb	r6, [r2, #8]
   2fdda:	601d      	str	r5, [r3, #0]
   2fddc:	609d      	str	r5, [r3, #8]
   2fdde:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   2fde0:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   2fde4:	e894 0003 	ldmia.w	r4, {r0, r1}
   2fde8:	e88c 0003 	stmia.w	ip, {r0, r1}
   2fdec:	603e      	str	r6, [r7, #0]
   2fdee:	4628      	mov	r0, r5
   2fdf0:	bcf0      	pop	{r4, r5, r6, r7}
   2fdf2:	4770      	bx	lr
   2fdf4:	250e      	movs	r5, #14
   2fdf6:	4628      	mov	r0, r5
   2fdf8:	bcf0      	pop	{r4, r5, r6, r7}
   2fdfa:	4770      	bx	lr
   2fdfc:	20020e5c 	.word	0x20020e5c
   2fe00:	20020ddc 	.word	0x20020ddc
   2fe04:	20020dc4 	.word	0x20020dc4

0002fe08 <rpc_transport_unregister>:
   2fe08:	2800      	cmp	r0, #0
   2fe0a:	d03a      	beq.n	2fe82 <rpc_transport_unregister+0x7a>
   2fe0c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2fe10:	4680      	mov	r8, r0
   2fe12:	4c1d      	ldr	r4, [pc, #116]	; (2fe88 <rpc_transport_unregister+0x80>)
   2fe14:	f104 05a0 	add.w	r5, r4, #160	; 0xa0
   2fe18:	68a3      	ldr	r3, [r4, #8]
   2fe1a:	3410      	adds	r4, #16
   2fe1c:	b103      	cbz	r3, 2fe20 <rpc_transport_unregister+0x18>
   2fe1e:	4798      	blx	r3
   2fe20:	42ac      	cmp	r4, r5
   2fe22:	d1f9      	bne.n	2fe18 <rpc_transport_unregister+0x10>
   2fe24:	f04f 0901 	mov.w	r9, #1
   2fe28:	2600      	movs	r6, #0
   2fe2a:	4c18      	ldr	r4, [pc, #96]	; (2fe8c <rpc_transport_unregister+0x84>)
   2fe2c:	4d18      	ldr	r5, [pc, #96]	; (2fe90 <rpc_transport_unregister+0x88>)
   2fe2e:	f8df a064 	ldr.w	sl, [pc, #100]	; 2fe94 <rpc_transport_unregister+0x8c>
   2fe32:	f104 0780 	add.w	r7, r4, #128	; 0x80
   2fe36:	f814 3c04 	ldrb.w	r3, [r4, #-4]
   2fe3a:	2b01      	cmp	r3, #1
   2fe3c:	d005      	beq.n	2fe4a <rpc_transport_unregister+0x42>
   2fe3e:	f8da 300c 	ldr.w	r3, [sl, #12]
   2fe42:	6820      	ldr	r0, [r4, #0]
   2fe44:	4798      	blx	r3
   2fe46:	f804 9c04 	strb.w	r9, [r4, #-4]
   2fe4a:	f855 0c04 	ldr.w	r0, [r5, #-4]
   2fe4e:	3408      	adds	r4, #8
   2fe50:	b128      	cbz	r0, 2fe5e <rpc_transport_unregister+0x56>
   2fe52:	f8da 3010 	ldr.w	r3, [sl, #16]
   2fe56:	4798      	blx	r3
   2fe58:	802e      	strh	r6, [r5, #0]
   2fe5a:	f845 6c04 	str.w	r6, [r5, #-4]
   2fe5e:	42bc      	cmp	r4, r7
   2fe60:	f105 0508 	add.w	r5, r5, #8
   2fe64:	d1e7      	bne.n	2fe36 <rpc_transport_unregister+0x2e>
   2fe66:	f8d8 0000 	ldr.w	r0, [r8]
   2fe6a:	2218      	movs	r2, #24
   2fe6c:	3801      	subs	r0, #1
   2fe6e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   2fe72:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
   2fe76:	2100      	movs	r1, #0
   2fe78:	f009 ffa1 	bl	39dbe <memset>
   2fe7c:	2000      	movs	r0, #0
   2fe7e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2fe82:	200e      	movs	r0, #14
   2fe84:	4770      	bx	lr
   2fe86:	bf00      	nop
   2fe88:	20020d24 	.word	0x20020d24
   2fe8c:	20020e60 	.word	0x20020e60
   2fe90:	20020de0 	.word	0x20020de0
   2fe94:	20020dc4 	.word	0x20020dc4

0002fe98 <rpc_message_send>:
   2fe98:	b168      	cbz	r0, 2feb6 <rpc_message_send+0x1e>
   2fe9a:	b171      	cbz	r1, 2feba <rpc_message_send+0x22>
   2fe9c:	4a09      	ldr	r2, [pc, #36]	; (2fec4 <rpc_message_send+0x2c>)
   2fe9e:	6853      	ldr	r3, [r2, #4]
   2fea0:	b16b      	cbz	r3, 2febe <rpc_message_send+0x26>
   2fea2:	684b      	ldr	r3, [r1, #4]
   2fea4:	8008      	strh	r0, [r1, #0]
   2fea6:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   2feaa:	f043 0302 	orr.w	r3, r3, #2
   2feae:	6812      	ldr	r2, [r2, #0]
   2feb0:	604b      	str	r3, [r1, #4]
   2feb2:	4608      	mov	r0, r1
   2feb4:	4710      	bx	r2
   2feb6:	2007      	movs	r0, #7
   2feb8:	4770      	bx	lr
   2feba:	200e      	movs	r0, #14
   2febc:	4770      	bx	lr
   2febe:	2008      	movs	r0, #8
   2fec0:	4770      	bx	lr
   2fec2:	bf00      	nop
   2fec4:	20020dc4 	.word	0x20020dc4

0002fec8 <rpc_message_alloc>:
   2fec8:	b35a      	cbz	r2, 2ff22 <rpc_message_alloc+0x5a>
   2feca:	b330      	cbz	r0, 2ff1a <rpc_message_alloc+0x52>
   2fecc:	2300      	movs	r3, #0
   2fece:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2fed2:	4f15      	ldr	r7, [pc, #84]	; (2ff28 <rpc_message_alloc+0x60>)
   2fed4:	6013      	str	r3, [r2, #0]
   2fed6:	687b      	ldr	r3, [r7, #4]
   2fed8:	b30b      	cbz	r3, 2ff1e <rpc_message_alloc+0x56>
   2feda:	4615      	mov	r5, r2
   2fedc:	460c      	mov	r4, r1
   2fede:	4606      	mov	r6, r0
   2fee0:	b959      	cbnz	r1, 2fefa <rpc_message_alloc+0x32>
   2fee2:	4798      	blx	r3
   2fee4:	4603      	mov	r3, r0
   2fee6:	b1a8      	cbz	r0, 2ff14 <rpc_message_alloc+0x4c>
   2fee8:	46a0      	mov	r8, r4
   2feea:	60dc      	str	r4, [r3, #12]
   2feec:	f8c3 8008 	str.w	r8, [r3, #8]
   2fef0:	801e      	strh	r6, [r3, #0]
   2fef2:	602b      	str	r3, [r5, #0]
   2fef4:	2000      	movs	r0, #0
   2fef6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2fefa:	68bb      	ldr	r3, [r7, #8]
   2fefc:	4608      	mov	r0, r1
   2fefe:	4798      	blx	r3
   2ff00:	4680      	mov	r8, r0
   2ff02:	b138      	cbz	r0, 2ff14 <rpc_message_alloc+0x4c>
   2ff04:	687b      	ldr	r3, [r7, #4]
   2ff06:	4798      	blx	r3
   2ff08:	4603      	mov	r3, r0
   2ff0a:	2800      	cmp	r0, #0
   2ff0c:	d1ed      	bne.n	2feea <rpc_message_alloc+0x22>
   2ff0e:	693b      	ldr	r3, [r7, #16]
   2ff10:	4640      	mov	r0, r8
   2ff12:	4798      	blx	r3
   2ff14:	2004      	movs	r0, #4
   2ff16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2ff1a:	2007      	movs	r0, #7
   2ff1c:	4770      	bx	lr
   2ff1e:	2008      	movs	r0, #8
   2ff20:	e7f9      	b.n	2ff16 <rpc_message_alloc+0x4e>
   2ff22:	200e      	movs	r0, #14
   2ff24:	4770      	bx	lr
   2ff26:	bf00      	nop
   2ff28:	20020dc4 	.word	0x20020dc4

0002ff2c <rpc_message_free>:
   2ff2c:	2800      	cmp	r0, #0
   2ff2e:	f000 808c 	beq.w	3004a <rpc_message_free+0x11e>
   2ff32:	2900      	cmp	r1, #0
   2ff34:	f000 80e9 	beq.w	3010a <rpc_message_free+0x1de>
   2ff38:	b538      	push	{r3, r4, r5, lr}
   2ff3a:	4a83      	ldr	r2, [pc, #524]	; (30148 <rpc_message_free+0x21c>)
   2ff3c:	6853      	ldr	r3, [r2, #4]
   2ff3e:	2b00      	cmp	r3, #0
   2ff40:	f000 8085 	beq.w	3004e <rpc_message_free+0x122>
   2ff44:	4c81      	ldr	r4, [pc, #516]	; (3014c <rpc_message_free+0x220>)
   2ff46:	4608      	mov	r0, r1
   2ff48:	6863      	ldr	r3, [r4, #4]
   2ff4a:	4299      	cmp	r1, r3
   2ff4c:	f000 8085 	beq.w	3005a <rpc_message_free+0x12e>
   2ff50:	68e3      	ldr	r3, [r4, #12]
   2ff52:	4298      	cmp	r0, r3
   2ff54:	f000 808e 	beq.w	30074 <rpc_message_free+0x148>
   2ff58:	6963      	ldr	r3, [r4, #20]
   2ff5a:	4298      	cmp	r0, r3
   2ff5c:	f000 8090 	beq.w	30080 <rpc_message_free+0x154>
   2ff60:	69e3      	ldr	r3, [r4, #28]
   2ff62:	4298      	cmp	r0, r3
   2ff64:	f000 8092 	beq.w	3008c <rpc_message_free+0x160>
   2ff68:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2ff6a:	4298      	cmp	r0, r3
   2ff6c:	f000 8095 	beq.w	3009a <rpc_message_free+0x16e>
   2ff70:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   2ff72:	4298      	cmp	r0, r3
   2ff74:	f000 8098 	beq.w	300a8 <rpc_message_free+0x17c>
   2ff78:	6b63      	ldr	r3, [r4, #52]	; 0x34
   2ff7a:	4298      	cmp	r0, r3
   2ff7c:	f000 809b 	beq.w	300b6 <rpc_message_free+0x18a>
   2ff80:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   2ff82:	4298      	cmp	r0, r3
   2ff84:	f000 809e 	beq.w	300c4 <rpc_message_free+0x198>
   2ff88:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2ff8a:	4298      	cmp	r0, r3
   2ff8c:	f000 80a1 	beq.w	300d2 <rpc_message_free+0x1a6>
   2ff90:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   2ff92:	4298      	cmp	r0, r3
   2ff94:	f000 80a4 	beq.w	300e0 <rpc_message_free+0x1b4>
   2ff98:	6d63      	ldr	r3, [r4, #84]	; 0x54
   2ff9a:	4298      	cmp	r0, r3
   2ff9c:	f000 80a7 	beq.w	300ee <rpc_message_free+0x1c2>
   2ffa0:	6de3      	ldr	r3, [r4, #92]	; 0x5c
   2ffa2:	4298      	cmp	r0, r3
   2ffa4:	f000 80aa 	beq.w	300fc <rpc_message_free+0x1d0>
   2ffa8:	6e63      	ldr	r3, [r4, #100]	; 0x64
   2ffaa:	4298      	cmp	r0, r3
   2ffac:	f000 80af 	beq.w	3010e <rpc_message_free+0x1e2>
   2ffb0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   2ffb2:	4298      	cmp	r0, r3
   2ffb4:	f000 80b2 	beq.w	3011c <rpc_message_free+0x1f0>
   2ffb8:	6f63      	ldr	r3, [r4, #116]	; 0x74
   2ffba:	4298      	cmp	r0, r3
   2ffbc:	f000 80b5 	beq.w	3012a <rpc_message_free+0x1fe>
   2ffc0:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
   2ffc2:	4283      	cmp	r3, r0
   2ffc4:	f000 80b8 	beq.w	30138 <rpc_message_free+0x20c>
   2ffc8:	68d3      	ldr	r3, [r2, #12]
   2ffca:	4798      	blx	r3
   2ffcc:	7823      	ldrb	r3, [r4, #0]
   2ffce:	2b04      	cmp	r3, #4
   2ffd0:	d03f      	beq.n	30052 <rpc_message_free+0x126>
   2ffd2:	7a23      	ldrb	r3, [r4, #8]
   2ffd4:	2b04      	cmp	r3, #4
   2ffd6:	d03c      	beq.n	30052 <rpc_message_free+0x126>
   2ffd8:	7c23      	ldrb	r3, [r4, #16]
   2ffda:	2b04      	cmp	r3, #4
   2ffdc:	d039      	beq.n	30052 <rpc_message_free+0x126>
   2ffde:	7e23      	ldrb	r3, [r4, #24]
   2ffe0:	2b04      	cmp	r3, #4
   2ffe2:	d036      	beq.n	30052 <rpc_message_free+0x126>
   2ffe4:	f894 3020 	ldrb.w	r3, [r4, #32]
   2ffe8:	2b04      	cmp	r3, #4
   2ffea:	d032      	beq.n	30052 <rpc_message_free+0x126>
   2ffec:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
   2fff0:	2b04      	cmp	r3, #4
   2fff2:	d02e      	beq.n	30052 <rpc_message_free+0x126>
   2fff4:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   2fff8:	2b04      	cmp	r3, #4
   2fffa:	d02a      	beq.n	30052 <rpc_message_free+0x126>
   2fffc:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
   30000:	2b04      	cmp	r3, #4
   30002:	d026      	beq.n	30052 <rpc_message_free+0x126>
   30004:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   30008:	2b04      	cmp	r3, #4
   3000a:	d022      	beq.n	30052 <rpc_message_free+0x126>
   3000c:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
   30010:	2b04      	cmp	r3, #4
   30012:	d01e      	beq.n	30052 <rpc_message_free+0x126>
   30014:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
   30018:	2b04      	cmp	r3, #4
   3001a:	d01a      	beq.n	30052 <rpc_message_free+0x126>
   3001c:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
   30020:	2b04      	cmp	r3, #4
   30022:	d016      	beq.n	30052 <rpc_message_free+0x126>
   30024:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
   30028:	2b04      	cmp	r3, #4
   3002a:	d012      	beq.n	30052 <rpc_message_free+0x126>
   3002c:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
   30030:	2b04      	cmp	r3, #4
   30032:	d00e      	beq.n	30052 <rpc_message_free+0x126>
   30034:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
   30038:	2b04      	cmp	r3, #4
   3003a:	d00a      	beq.n	30052 <rpc_message_free+0x126>
   3003c:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
   30040:	2b04      	cmp	r3, #4
   30042:	bf18      	it	ne
   30044:	2000      	movne	r0, #0
   30046:	d004      	beq.n	30052 <rpc_message_free+0x126>
   30048:	bd38      	pop	{r3, r4, r5, pc}
   3004a:	2007      	movs	r0, #7
   3004c:	4770      	bx	lr
   3004e:	2008      	movs	r0, #8
   30050:	bd38      	pop	{r3, r4, r5, pc}
   30052:	f7f7 fdfd 	bl	27c50 <bsd_os_application_irq_set>
   30056:	2000      	movs	r0, #0
   30058:	bd38      	pop	{r3, r4, r5, pc}
   3005a:	7821      	ldrb	r1, [r4, #0]
   3005c:	2903      	cmp	r1, #3
   3005e:	f47f af77 	bne.w	2ff50 <rpc_message_free+0x24>
   30062:	2100      	movs	r1, #0
   30064:	2501      	movs	r5, #1
   30066:	4618      	mov	r0, r3
   30068:	68d2      	ldr	r2, [r2, #12]
   3006a:	f804 5031 	strb.w	r5, [r4, r1, lsl #3]
   3006e:	4790      	blx	r2
   30070:	2000      	movs	r0, #0
   30072:	bd38      	pop	{r3, r4, r5, pc}
   30074:	7a21      	ldrb	r1, [r4, #8]
   30076:	2903      	cmp	r1, #3
   30078:	f47f af6e 	bne.w	2ff58 <rpc_message_free+0x2c>
   3007c:	2101      	movs	r1, #1
   3007e:	e7f1      	b.n	30064 <rpc_message_free+0x138>
   30080:	7c21      	ldrb	r1, [r4, #16]
   30082:	2903      	cmp	r1, #3
   30084:	f47f af6c 	bne.w	2ff60 <rpc_message_free+0x34>
   30088:	2102      	movs	r1, #2
   3008a:	e7eb      	b.n	30064 <rpc_message_free+0x138>
   3008c:	7e21      	ldrb	r1, [r4, #24]
   3008e:	2903      	cmp	r1, #3
   30090:	d0e8      	beq.n	30064 <rpc_message_free+0x138>
   30092:	6a63      	ldr	r3, [r4, #36]	; 0x24
   30094:	4298      	cmp	r0, r3
   30096:	f47f af6b 	bne.w	2ff70 <rpc_message_free+0x44>
   3009a:	f894 1020 	ldrb.w	r1, [r4, #32]
   3009e:	2903      	cmp	r1, #3
   300a0:	f47f af66 	bne.w	2ff70 <rpc_message_free+0x44>
   300a4:	2104      	movs	r1, #4
   300a6:	e7dd      	b.n	30064 <rpc_message_free+0x138>
   300a8:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
   300ac:	2903      	cmp	r1, #3
   300ae:	f47f af63 	bne.w	2ff78 <rpc_message_free+0x4c>
   300b2:	2105      	movs	r1, #5
   300b4:	e7d6      	b.n	30064 <rpc_message_free+0x138>
   300b6:	f894 1030 	ldrb.w	r1, [r4, #48]	; 0x30
   300ba:	2903      	cmp	r1, #3
   300bc:	f47f af60 	bne.w	2ff80 <rpc_message_free+0x54>
   300c0:	2106      	movs	r1, #6
   300c2:	e7cf      	b.n	30064 <rpc_message_free+0x138>
   300c4:	f894 1038 	ldrb.w	r1, [r4, #56]	; 0x38
   300c8:	2903      	cmp	r1, #3
   300ca:	f47f af5d 	bne.w	2ff88 <rpc_message_free+0x5c>
   300ce:	2107      	movs	r1, #7
   300d0:	e7c8      	b.n	30064 <rpc_message_free+0x138>
   300d2:	f894 1040 	ldrb.w	r1, [r4, #64]	; 0x40
   300d6:	2903      	cmp	r1, #3
   300d8:	f47f af5a 	bne.w	2ff90 <rpc_message_free+0x64>
   300dc:	2108      	movs	r1, #8
   300de:	e7c1      	b.n	30064 <rpc_message_free+0x138>
   300e0:	f894 1048 	ldrb.w	r1, [r4, #72]	; 0x48
   300e4:	2903      	cmp	r1, #3
   300e6:	f47f af57 	bne.w	2ff98 <rpc_message_free+0x6c>
   300ea:	2109      	movs	r1, #9
   300ec:	e7ba      	b.n	30064 <rpc_message_free+0x138>
   300ee:	f894 1050 	ldrb.w	r1, [r4, #80]	; 0x50
   300f2:	2903      	cmp	r1, #3
   300f4:	f47f af54 	bne.w	2ffa0 <rpc_message_free+0x74>
   300f8:	210a      	movs	r1, #10
   300fa:	e7b3      	b.n	30064 <rpc_message_free+0x138>
   300fc:	f894 1058 	ldrb.w	r1, [r4, #88]	; 0x58
   30100:	2903      	cmp	r1, #3
   30102:	f47f af51 	bne.w	2ffa8 <rpc_message_free+0x7c>
   30106:	210b      	movs	r1, #11
   30108:	e7ac      	b.n	30064 <rpc_message_free+0x138>
   3010a:	200e      	movs	r0, #14
   3010c:	4770      	bx	lr
   3010e:	f894 1060 	ldrb.w	r1, [r4, #96]	; 0x60
   30112:	2903      	cmp	r1, #3
   30114:	f47f af4c 	bne.w	2ffb0 <rpc_message_free+0x84>
   30118:	210c      	movs	r1, #12
   3011a:	e7a3      	b.n	30064 <rpc_message_free+0x138>
   3011c:	f894 1068 	ldrb.w	r1, [r4, #104]	; 0x68
   30120:	2903      	cmp	r1, #3
   30122:	f47f af49 	bne.w	2ffb8 <rpc_message_free+0x8c>
   30126:	210d      	movs	r1, #13
   30128:	e79c      	b.n	30064 <rpc_message_free+0x138>
   3012a:	f894 1070 	ldrb.w	r1, [r4, #112]	; 0x70
   3012e:	2903      	cmp	r1, #3
   30130:	f47f af46 	bne.w	2ffc0 <rpc_message_free+0x94>
   30134:	210e      	movs	r1, #14
   30136:	e795      	b.n	30064 <rpc_message_free+0x138>
   30138:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
   3013c:	2b03      	cmp	r3, #3
   3013e:	f47f af43 	bne.w	2ffc8 <rpc_message_free+0x9c>
   30142:	4603      	mov	r3, r0
   30144:	210f      	movs	r1, #15
   30146:	e78d      	b.n	30064 <rpc_message_free+0x138>
   30148:	20020dc4 	.word	0x20020dc4
   3014c:	20020e5c 	.word	0x20020e5c

00030150 <rpc_message_data_free>:
   30150:	2800      	cmp	r0, #0
   30152:	f000 8091 	beq.w	30278 <rpc_message_data_free+0x128>
   30156:	2900      	cmp	r1, #0
   30158:	f000 80e4 	beq.w	30324 <rpc_message_data_free+0x1d4>
   3015c:	b538      	push	{r3, r4, r5, lr}
   3015e:	4a81      	ldr	r2, [pc, #516]	; (30364 <rpc_message_data_free+0x214>)
   30160:	6853      	ldr	r3, [r2, #4]
   30162:	2b00      	cmp	r3, #0
   30164:	f000 808a 	beq.w	3027c <rpc_message_data_free+0x12c>
   30168:	4b7f      	ldr	r3, [pc, #508]	; (30368 <rpc_message_data_free+0x218>)
   3016a:	681c      	ldr	r4, [r3, #0]
   3016c:	42a1      	cmp	r1, r4
   3016e:	f000 8087 	beq.w	30280 <rpc_message_data_free+0x130>
   30172:	689c      	ldr	r4, [r3, #8]
   30174:	42a1      	cmp	r1, r4
   30176:	f000 808f 	beq.w	30298 <rpc_message_data_free+0x148>
   3017a:	691c      	ldr	r4, [r3, #16]
   3017c:	42a1      	cmp	r1, r4
   3017e:	f000 8091 	beq.w	302a4 <rpc_message_data_free+0x154>
   30182:	699c      	ldr	r4, [r3, #24]
   30184:	42a1      	cmp	r1, r4
   30186:	f000 8093 	beq.w	302b0 <rpc_message_data_free+0x160>
   3018a:	6a1c      	ldr	r4, [r3, #32]
   3018c:	42a1      	cmp	r1, r4
   3018e:	f000 8095 	beq.w	302bc <rpc_message_data_free+0x16c>
   30192:	6a9c      	ldr	r4, [r3, #40]	; 0x28
   30194:	42a1      	cmp	r1, r4
   30196:	f000 8097 	beq.w	302c8 <rpc_message_data_free+0x178>
   3019a:	6b1c      	ldr	r4, [r3, #48]	; 0x30
   3019c:	42a1      	cmp	r1, r4
   3019e:	f000 8099 	beq.w	302d4 <rpc_message_data_free+0x184>
   301a2:	6b9c      	ldr	r4, [r3, #56]	; 0x38
   301a4:	42a1      	cmp	r1, r4
   301a6:	f000 809b 	beq.w	302e0 <rpc_message_data_free+0x190>
   301aa:	6c1c      	ldr	r4, [r3, #64]	; 0x40
   301ac:	42a1      	cmp	r1, r4
   301ae:	f000 809d 	beq.w	302ec <rpc_message_data_free+0x19c>
   301b2:	6c9c      	ldr	r4, [r3, #72]	; 0x48
   301b4:	42a1      	cmp	r1, r4
   301b6:	f000 80a0 	beq.w	302fa <rpc_message_data_free+0x1aa>
   301ba:	6d1c      	ldr	r4, [r3, #80]	; 0x50
   301bc:	42a1      	cmp	r1, r4
   301be:	f000 80a3 	beq.w	30308 <rpc_message_data_free+0x1b8>
   301c2:	6d9c      	ldr	r4, [r3, #88]	; 0x58
   301c4:	42a1      	cmp	r1, r4
   301c6:	f000 80a6 	beq.w	30316 <rpc_message_data_free+0x1c6>
   301ca:	6e1c      	ldr	r4, [r3, #96]	; 0x60
   301cc:	42a1      	cmp	r1, r4
   301ce:	f000 80ab 	beq.w	30328 <rpc_message_data_free+0x1d8>
   301d2:	6e9c      	ldr	r4, [r3, #104]	; 0x68
   301d4:	42a1      	cmp	r1, r4
   301d6:	f000 80ae 	beq.w	30336 <rpc_message_data_free+0x1e6>
   301da:	6f1c      	ldr	r4, [r3, #112]	; 0x70
   301dc:	42a1      	cmp	r1, r4
   301de:	f000 80b1 	beq.w	30344 <rpc_message_data_free+0x1f4>
   301e2:	6f9c      	ldr	r4, [r3, #120]	; 0x78
   301e4:	428c      	cmp	r4, r1
   301e6:	f000 80b4 	beq.w	30352 <rpc_message_data_free+0x202>
   301ea:	6913      	ldr	r3, [r2, #16]
   301ec:	4608      	mov	r0, r1
   301ee:	4798      	blx	r3
   301f0:	4b5e      	ldr	r3, [pc, #376]	; (3036c <rpc_message_data_free+0x21c>)
   301f2:	781a      	ldrb	r2, [r3, #0]
   301f4:	2a04      	cmp	r2, #4
   301f6:	d03b      	beq.n	30270 <rpc_message_data_free+0x120>
   301f8:	7a1a      	ldrb	r2, [r3, #8]
   301fa:	2a04      	cmp	r2, #4
   301fc:	d038      	beq.n	30270 <rpc_message_data_free+0x120>
   301fe:	7c1a      	ldrb	r2, [r3, #16]
   30200:	2a04      	cmp	r2, #4
   30202:	d035      	beq.n	30270 <rpc_message_data_free+0x120>
   30204:	7e1a      	ldrb	r2, [r3, #24]
   30206:	2a04      	cmp	r2, #4
   30208:	d032      	beq.n	30270 <rpc_message_data_free+0x120>
   3020a:	f893 2020 	ldrb.w	r2, [r3, #32]
   3020e:	2a04      	cmp	r2, #4
   30210:	d02e      	beq.n	30270 <rpc_message_data_free+0x120>
   30212:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
   30216:	2a04      	cmp	r2, #4
   30218:	d02a      	beq.n	30270 <rpc_message_data_free+0x120>
   3021a:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
   3021e:	2a04      	cmp	r2, #4
   30220:	d026      	beq.n	30270 <rpc_message_data_free+0x120>
   30222:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
   30226:	2a04      	cmp	r2, #4
   30228:	d022      	beq.n	30270 <rpc_message_data_free+0x120>
   3022a:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
   3022e:	2a04      	cmp	r2, #4
   30230:	d01e      	beq.n	30270 <rpc_message_data_free+0x120>
   30232:	f893 2048 	ldrb.w	r2, [r3, #72]	; 0x48
   30236:	2a04      	cmp	r2, #4
   30238:	d01a      	beq.n	30270 <rpc_message_data_free+0x120>
   3023a:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
   3023e:	2a04      	cmp	r2, #4
   30240:	d016      	beq.n	30270 <rpc_message_data_free+0x120>
   30242:	f893 2058 	ldrb.w	r2, [r3, #88]	; 0x58
   30246:	2a04      	cmp	r2, #4
   30248:	d012      	beq.n	30270 <rpc_message_data_free+0x120>
   3024a:	f893 2060 	ldrb.w	r2, [r3, #96]	; 0x60
   3024e:	2a04      	cmp	r2, #4
   30250:	d00e      	beq.n	30270 <rpc_message_data_free+0x120>
   30252:	f893 2068 	ldrb.w	r2, [r3, #104]	; 0x68
   30256:	2a04      	cmp	r2, #4
   30258:	d00a      	beq.n	30270 <rpc_message_data_free+0x120>
   3025a:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
   3025e:	2a04      	cmp	r2, #4
   30260:	d006      	beq.n	30270 <rpc_message_data_free+0x120>
   30262:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
   30266:	2b04      	cmp	r3, #4
   30268:	bf18      	it	ne
   3026a:	2000      	movne	r0, #0
   3026c:	d000      	beq.n	30270 <rpc_message_data_free+0x120>
   3026e:	bd38      	pop	{r3, r4, r5, pc}
   30270:	f7f7 fcee 	bl	27c50 <bsd_os_application_irq_set>
   30274:	2000      	movs	r0, #0
   30276:	bd38      	pop	{r3, r4, r5, pc}
   30278:	2007      	movs	r0, #7
   3027a:	4770      	bx	lr
   3027c:	2008      	movs	r0, #8
   3027e:	bd38      	pop	{r3, r4, r5, pc}
   30280:	889c      	ldrh	r4, [r3, #4]
   30282:	4284      	cmp	r4, r0
   30284:	f47f af75 	bne.w	30172 <rpc_message_data_free+0x22>
   30288:	2400      	movs	r4, #0
   3028a:	2000      	movs	r0, #0
   3028c:	eb03 05c4 	add.w	r5, r3, r4, lsl #3
   30290:	f843 0034 	str.w	r0, [r3, r4, lsl #3]
   30294:	80a8      	strh	r0, [r5, #4]
   30296:	e7a8      	b.n	301ea <rpc_message_data_free+0x9a>
   30298:	899c      	ldrh	r4, [r3, #12]
   3029a:	4284      	cmp	r4, r0
   3029c:	f47f af6d 	bne.w	3017a <rpc_message_data_free+0x2a>
   302a0:	2401      	movs	r4, #1
   302a2:	e7f2      	b.n	3028a <rpc_message_data_free+0x13a>
   302a4:	8a9c      	ldrh	r4, [r3, #20]
   302a6:	4284      	cmp	r4, r0
   302a8:	f47f af6b 	bne.w	30182 <rpc_message_data_free+0x32>
   302ac:	2402      	movs	r4, #2
   302ae:	e7ec      	b.n	3028a <rpc_message_data_free+0x13a>
   302b0:	8b9c      	ldrh	r4, [r3, #28]
   302b2:	4284      	cmp	r4, r0
   302b4:	f47f af69 	bne.w	3018a <rpc_message_data_free+0x3a>
   302b8:	2403      	movs	r4, #3
   302ba:	e7e6      	b.n	3028a <rpc_message_data_free+0x13a>
   302bc:	8c9c      	ldrh	r4, [r3, #36]	; 0x24
   302be:	4284      	cmp	r4, r0
   302c0:	f47f af67 	bne.w	30192 <rpc_message_data_free+0x42>
   302c4:	2404      	movs	r4, #4
   302c6:	e7e0      	b.n	3028a <rpc_message_data_free+0x13a>
   302c8:	8d9c      	ldrh	r4, [r3, #44]	; 0x2c
   302ca:	4284      	cmp	r4, r0
   302cc:	f47f af65 	bne.w	3019a <rpc_message_data_free+0x4a>
   302d0:	2405      	movs	r4, #5
   302d2:	e7da      	b.n	3028a <rpc_message_data_free+0x13a>
   302d4:	8e9c      	ldrh	r4, [r3, #52]	; 0x34
   302d6:	4284      	cmp	r4, r0
   302d8:	f47f af63 	bne.w	301a2 <rpc_message_data_free+0x52>
   302dc:	2406      	movs	r4, #6
   302de:	e7d4      	b.n	3028a <rpc_message_data_free+0x13a>
   302e0:	8f9c      	ldrh	r4, [r3, #60]	; 0x3c
   302e2:	4284      	cmp	r4, r0
   302e4:	f47f af61 	bne.w	301aa <rpc_message_data_free+0x5a>
   302e8:	2407      	movs	r4, #7
   302ea:	e7ce      	b.n	3028a <rpc_message_data_free+0x13a>
   302ec:	f8b3 4044 	ldrh.w	r4, [r3, #68]	; 0x44
   302f0:	4284      	cmp	r4, r0
   302f2:	f47f af5e 	bne.w	301b2 <rpc_message_data_free+0x62>
   302f6:	2408      	movs	r4, #8
   302f8:	e7c7      	b.n	3028a <rpc_message_data_free+0x13a>
   302fa:	f8b3 404c 	ldrh.w	r4, [r3, #76]	; 0x4c
   302fe:	4284      	cmp	r4, r0
   30300:	f47f af5b 	bne.w	301ba <rpc_message_data_free+0x6a>
   30304:	2409      	movs	r4, #9
   30306:	e7c0      	b.n	3028a <rpc_message_data_free+0x13a>
   30308:	f8b3 4054 	ldrh.w	r4, [r3, #84]	; 0x54
   3030c:	4284      	cmp	r4, r0
   3030e:	f47f af58 	bne.w	301c2 <rpc_message_data_free+0x72>
   30312:	240a      	movs	r4, #10
   30314:	e7b9      	b.n	3028a <rpc_message_data_free+0x13a>
   30316:	f8b3 405c 	ldrh.w	r4, [r3, #92]	; 0x5c
   3031a:	4284      	cmp	r4, r0
   3031c:	f47f af55 	bne.w	301ca <rpc_message_data_free+0x7a>
   30320:	240b      	movs	r4, #11
   30322:	e7b2      	b.n	3028a <rpc_message_data_free+0x13a>
   30324:	200e      	movs	r0, #14
   30326:	4770      	bx	lr
   30328:	f8b3 4064 	ldrh.w	r4, [r3, #100]	; 0x64
   3032c:	4284      	cmp	r4, r0
   3032e:	f47f af50 	bne.w	301d2 <rpc_message_data_free+0x82>
   30332:	240c      	movs	r4, #12
   30334:	e7a9      	b.n	3028a <rpc_message_data_free+0x13a>
   30336:	f8b3 406c 	ldrh.w	r4, [r3, #108]	; 0x6c
   3033a:	4284      	cmp	r4, r0
   3033c:	f47f af4d 	bne.w	301da <rpc_message_data_free+0x8a>
   30340:	240d      	movs	r4, #13
   30342:	e7a2      	b.n	3028a <rpc_message_data_free+0x13a>
   30344:	f8b3 4074 	ldrh.w	r4, [r3, #116]	; 0x74
   30348:	4284      	cmp	r4, r0
   3034a:	f47f af4a 	bne.w	301e2 <rpc_message_data_free+0x92>
   3034e:	240e      	movs	r4, #14
   30350:	e79b      	b.n	3028a <rpc_message_data_free+0x13a>
   30352:	f8b3 407c 	ldrh.w	r4, [r3, #124]	; 0x7c
   30356:	4284      	cmp	r4, r0
   30358:	bf08      	it	eq
   3035a:	240f      	moveq	r4, #15
   3035c:	f47f af45 	bne.w	301ea <rpc_message_data_free+0x9a>
   30360:	e793      	b.n	3028a <rpc_message_data_free+0x13a>
   30362:	bf00      	nop
   30364:	20020dc4 	.word	0x20020dc4
   30368:	20020ddc 	.word	0x20020ddc
   3036c:	20020e5c 	.word	0x20020e5c

00030370 <packet_free_cb>:
   30370:	b510      	push	{r4, lr}
   30372:	4604      	mov	r4, r0
   30374:	b118      	cbz	r0, 3037e <packet_free_cb+0xe>
   30376:	6800      	ldr	r0, [r0, #0]
   30378:	b108      	cbz	r0, 3037e <packet_free_cb+0xe>
   3037a:	f001 f82f 	bl	313dc <rpc_gnss_client_data_free>
   3037e:	68a0      	ldr	r0, [r4, #8]
   30380:	b118      	cbz	r0, 3038a <packet_free_cb+0x1a>
   30382:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   30386:	f7fa b919 	b.w	2a5bc <nrf_free>
   3038a:	bd10      	pop	{r4, pc}

0003038c <rpc_gnss_event_handler>:
   3038c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   30390:	4b64      	ldr	r3, [pc, #400]	; (30524 <rpc_gnss_event_handler+0x198>)
   30392:	4606      	mov	r6, r0
   30394:	6800      	ldr	r0, [r0, #0]
   30396:	881b      	ldrh	r3, [r3, #0]
   30398:	6802      	ldr	r2, [r0, #0]
   3039a:	4f63      	ldr	r7, [pc, #396]	; (30528 <rpc_gnss_event_handler+0x19c>)
   3039c:	ebb3 4f12 	cmp.w	r3, r2, lsr #16
   303a0:	b084      	sub	sp, #16
   303a2:	460d      	mov	r5, r1
   303a4:	6038      	str	r0, [r7, #0]
   303a6:	d038      	beq.n	3041a <rpc_gnss_event_handler+0x8e>
   303a8:	f505 433f 	add.w	r3, r5, #48896	; 0xbf00
   303ac:	33ff      	adds	r3, #255	; 0xff
   303ae:	b29b      	uxth	r3, r3
   303b0:	2b02      	cmp	r3, #2
   303b2:	d810      	bhi.n	303d6 <rpc_gnss_event_handler+0x4a>
   303b4:	4c5d      	ldr	r4, [pc, #372]	; (3052c <rpc_gnss_event_handler+0x1a0>)
   303b6:	6823      	ldr	r3, [r4, #0]
   303b8:	075a      	lsls	r2, r3, #29
   303ba:	d410      	bmi.n	303de <rpc_gnss_event_handler+0x52>
   303bc:	6823      	ldr	r3, [r4, #0]
   303be:	079b      	lsls	r3, r3, #30
   303c0:	d503      	bpl.n	303ca <rpc_gnss_event_handler+0x3e>
   303c2:	f244 0303 	movw	r3, #16387	; 0x4003
   303c6:	429d      	cmp	r5, r3
   303c8:	d009      	beq.n	303de <rpc_gnss_event_handler+0x52>
   303ca:	6830      	ldr	r0, [r6, #0]
   303cc:	b118      	cbz	r0, 303d6 <rpc_gnss_event_handler+0x4a>
   303ce:	f001 f805 	bl	313dc <rpc_gnss_client_data_free>
   303d2:	2300      	movs	r3, #0
   303d4:	603b      	str	r3, [r7, #0]
   303d6:	2000      	movs	r0, #0
   303d8:	b004      	add	sp, #16
   303da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   303de:	2002      	movs	r0, #2
   303e0:	f7fa f8e2 	bl	2a5a8 <nrf_malloc>
   303e4:	4680      	mov	r8, r0
   303e6:	2800      	cmp	r0, #0
   303e8:	f000 8093 	beq.w	30512 <rpc_gnss_event_handler+0x186>
   303ec:	2302      	movs	r3, #2
   303ee:	8005      	strh	r5, [r0, #0]
   303f0:	6831      	ldr	r1, [r6, #0]
   303f2:	6872      	ldr	r2, [r6, #4]
   303f4:	484e      	ldr	r0, [pc, #312]	; (30530 <rpc_gnss_event_handler+0x1a4>)
   303f6:	e88d 0106 	stmia.w	sp, {r1, r2, r8}
   303fa:	6800      	ldr	r0, [r0, #0]
   303fc:	9303      	str	r3, [sp, #12]
   303fe:	6803      	ldr	r3, [r0, #0]
   30400:	4669      	mov	r1, sp
   30402:	685b      	ldr	r3, [r3, #4]
   30404:	4798      	blx	r3
   30406:	3001      	adds	r0, #1
   30408:	d070      	beq.n	304ec <rpc_gnss_event_handler+0x160>
   3040a:	2000      	movs	r0, #0
   3040c:	6823      	ldr	r3, [r4, #0]
   3040e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   30412:	6023      	str	r3, [r4, #0]
   30414:	b004      	add	sp, #16
   30416:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   3041a:	4c44      	ldr	r4, [pc, #272]	; (3052c <rpc_gnss_event_handler+0x1a0>)
   3041c:	6823      	ldr	r3, [r4, #0]
   3041e:	01d9      	lsls	r1, r3, #7
   30420:	d523      	bpl.n	3046a <rpc_gnss_event_handler+0xde>
   30422:	f242 1302 	movw	r3, #8450	; 0x2102
   30426:	429d      	cmp	r5, r3
   30428:	d11f      	bne.n	3046a <rpc_gnss_event_handler+0xde>
   3042a:	6843      	ldr	r3, [r0, #4]
   3042c:	b91b      	cbnz	r3, 30436 <rpc_gnss_event_handler+0xaa>
   3042e:	6823      	ldr	r3, [r4, #0]
   30430:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   30434:	6023      	str	r3, [r4, #0]
   30436:	6823      	ldr	r3, [r4, #0]
   30438:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   3043c:	6023      	str	r3, [r4, #0]
   3043e:	6823      	ldr	r3, [r4, #0]
   30440:	025a      	lsls	r2, r3, #9
   30442:	d430      	bmi.n	304a6 <rpc_gnss_event_handler+0x11a>
   30444:	f242 0305 	movw	r3, #8197	; 0x2005
   30448:	429d      	cmp	r5, r3
   3044a:	d12c      	bne.n	304a6 <rpc_gnss_event_handler+0x11a>
   3044c:	6823      	ldr	r3, [r4, #0]
   3044e:	0299      	lsls	r1, r3, #10
   30450:	d529      	bpl.n	304a6 <rpc_gnss_event_handler+0x11a>
   30452:	6843      	ldr	r3, [r0, #4]
   30454:	2b00      	cmp	r3, #0
   30456:	d157      	bne.n	30508 <rpc_gnss_event_handler+0x17c>
   30458:	6823      	ldr	r3, [r4, #0]
   3045a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   3045e:	6023      	str	r3, [r4, #0]
   30460:	6823      	ldr	r3, [r4, #0]
   30462:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   30466:	6023      	str	r3, [r4, #0]
   30468:	e01d      	b.n	304a6 <rpc_gnss_event_handler+0x11a>
   3046a:	6823      	ldr	r3, [r4, #0]
   3046c:	025b      	lsls	r3, r3, #9
   3046e:	d50e      	bpl.n	3048e <rpc_gnss_event_handler+0x102>
   30470:	f242 1303 	movw	r3, #8451	; 0x2103
   30474:	429d      	cmp	r5, r3
   30476:	d10a      	bne.n	3048e <rpc_gnss_event_handler+0x102>
   30478:	6843      	ldr	r3, [r0, #4]
   3047a:	b91b      	cbnz	r3, 30484 <rpc_gnss_event_handler+0xf8>
   3047c:	6823      	ldr	r3, [r4, #0]
   3047e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   30482:	6023      	str	r3, [r4, #0]
   30484:	6823      	ldr	r3, [r4, #0]
   30486:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   3048a:	6023      	str	r3, [r4, #0]
   3048c:	e00b      	b.n	304a6 <rpc_gnss_event_handler+0x11a>
   3048e:	f242 0301 	movw	r3, #8193	; 0x2001
   30492:	429d      	cmp	r5, r3
   30494:	d10c      	bne.n	304b0 <rpc_gnss_event_handler+0x124>
   30496:	6843      	ldr	r3, [r0, #4]
   30498:	b92b      	cbnz	r3, 304a6 <rpc_gnss_event_handler+0x11a>
   3049a:	6823      	ldr	r3, [r4, #0]
   3049c:	0c1b      	lsrs	r3, r3, #16
   3049e:	041b      	lsls	r3, r3, #16
   304a0:	f043 0302 	orr.w	r3, r3, #2
   304a4:	6023      	str	r3, [r4, #0]
   304a6:	f000 ff99 	bl	313dc <rpc_gnss_client_data_free>
   304aa:	2300      	movs	r3, #0
   304ac:	603b      	str	r3, [r7, #0]
   304ae:	e77b      	b.n	303a8 <rpc_gnss_event_handler+0x1c>
   304b0:	f242 0304 	movw	r3, #8196	; 0x2004
   304b4:	429d      	cmp	r5, r3
   304b6:	d1c5      	bne.n	30444 <rpc_gnss_event_handler+0xb8>
   304b8:	6843      	ldr	r3, [r0, #4]
   304ba:	b993      	cbnz	r3, 304e2 <rpc_gnss_event_handler+0x156>
   304bc:	6823      	ldr	r3, [r4, #0]
   304be:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   304c2:	6023      	str	r3, [r4, #0]
   304c4:	6823      	ldr	r3, [r4, #0]
   304c6:	b29b      	uxth	r3, r3
   304c8:	2b03      	cmp	r3, #3
   304ca:	6823      	ldr	r3, [r4, #0]
   304cc:	d016      	beq.n	304fc <rpc_gnss_event_handler+0x170>
   304ce:	b29b      	uxth	r3, r3
   304d0:	2b04      	cmp	r3, #4
   304d2:	d1d7      	bne.n	30484 <rpc_gnss_event_handler+0xf8>
   304d4:	6823      	ldr	r3, [r4, #0]
   304d6:	0c1b      	lsrs	r3, r3, #16
   304d8:	041b      	lsls	r3, r3, #16
   304da:	f043 0302 	orr.w	r3, r3, #2
   304de:	6023      	str	r3, [r4, #0]
   304e0:	e7d0      	b.n	30484 <rpc_gnss_event_handler+0xf8>
   304e2:	6823      	ldr	r3, [r4, #0]
   304e4:	b29b      	uxth	r3, r3
   304e6:	2b03      	cmp	r3, #3
   304e8:	d1cc      	bne.n	30484 <rpc_gnss_event_handler+0xf8>
   304ea:	e7f3      	b.n	304d4 <rpc_gnss_event_handler+0x148>
   304ec:	4640      	mov	r0, r8
   304ee:	f7fa f865 	bl	2a5bc <nrf_free>
   304f2:	6830      	ldr	r0, [r6, #0]
   304f4:	2800      	cmp	r0, #0
   304f6:	f47f af6a 	bne.w	303ce <rpc_gnss_event_handler+0x42>
   304fa:	e76c      	b.n	303d6 <rpc_gnss_event_handler+0x4a>
   304fc:	0c1b      	lsrs	r3, r3, #16
   304fe:	041b      	lsls	r3, r3, #16
   30500:	f043 0304 	orr.w	r3, r3, #4
   30504:	6023      	str	r3, [r4, #0]
   30506:	e7bd      	b.n	30484 <rpc_gnss_event_handler+0xf8>
   30508:	6823      	ldr	r3, [r4, #0]
   3050a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   3050e:	6023      	str	r3, [r4, #0]
   30510:	e7c9      	b.n	304a6 <rpc_gnss_event_handler+0x11a>
   30512:	6830      	ldr	r0, [r6, #0]
   30514:	2800      	cmp	r0, #0
   30516:	f43f af5e 	beq.w	303d6 <rpc_gnss_event_handler+0x4a>
   3051a:	f000 ff5f 	bl	313dc <rpc_gnss_client_data_free>
   3051e:	f8c7 8000 	str.w	r8, [r7]
   30522:	e758      	b.n	303d6 <rpc_gnss_event_handler+0x4a>
   30524:	2002229c 	.word	0x2002229c
   30528:	20020ee0 	.word	0x20020ee0
   3052c:	20020edc 	.word	0x20020edc
   30530:	20020ee4 	.word	0x20020ee4

00030534 <gnss_interface_write>:
   30534:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   30538:	4a74      	ldr	r2, [pc, #464]	; (3070c <gnss_interface_write+0x1d8>)
   3053a:	b09f      	sub	sp, #124	; 0x7c
   3053c:	4290      	cmp	r0, r2
   3053e:	9d26      	ldr	r5, [sp, #152]	; 0x98
   30540:	f040 80d7 	bne.w	306f2 <gnss_interface_write+0x1be>
   30544:	2900      	cmp	r1, #0
   30546:	f000 80c6 	beq.w	306d6 <gnss_interface_write+0x1a2>
   3054a:	2d00      	cmp	r5, #0
   3054c:	f000 80c3 	beq.w	306d6 <gnss_interface_write+0x1a2>
   30550:	9a27      	ldr	r2, [sp, #156]	; 0x9c
   30552:	2a02      	cmp	r2, #2
   30554:	f040 80bf 	bne.w	306d6 <gnss_interface_write+0x1a2>
   30558:	4c6d      	ldr	r4, [pc, #436]	; (30710 <gnss_interface_write+0x1dc>)
   3055a:	6822      	ldr	r2, [r4, #0]
   3055c:	b292      	uxth	r2, r2
   3055e:	2a02      	cmp	r2, #2
   30560:	d004      	beq.n	3056c <gnss_interface_write+0x38>
   30562:	6822      	ldr	r2, [r4, #0]
   30564:	b292      	uxth	r2, r2
   30566:	2a04      	cmp	r2, #4
   30568:	f040 80bd 	bne.w	306e6 <gnss_interface_write+0x1b2>
   3056c:	2b00      	cmp	r3, #0
   3056e:	f040 80c6 	bne.w	306fe <gnss_interface_write+0x1ca>
   30572:	6822      	ldr	r2, [r4, #0]
   30574:	0390      	lsls	r0, r2, #14
   30576:	d512      	bpl.n	3059e <gnss_interface_write+0x6a>
   30578:	6822      	ldr	r2, [r4, #0]
   3057a:	882b      	ldrh	r3, [r5, #0]
   3057c:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
   30580:	6022      	str	r2, [r4, #0]
   30582:	6822      	ldr	r2, [r4, #0]
   30584:	3b01      	subs	r3, #1
   30586:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
   3058a:	6022      	str	r2, [r4, #0]
   3058c:	2b07      	cmp	r3, #7
   3058e:	f200 80a2 	bhi.w	306d6 <gnss_interface_write+0x1a2>
   30592:	e8df f003 	tbb	[pc, r3]
   30596:	7d82      	.short	0x7d82
   30598:	646e7378 	.word	0x646e7378
   3059c:	0869      	.short	0x0869
   3059e:	2000      	movs	r0, #0
   305a0:	b01f      	add	sp, #124	; 0x7c
   305a2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   305a6:	4608      	mov	r0, r1
   305a8:	a902      	add	r1, sp, #8
   305aa:	f000 fecb 	bl	31344 <rpc_gnss_serialize_integrity>
   305ae:	2172      	movs	r1, #114	; 0x72
   305b0:	4668      	mov	r0, sp
   305b2:	f000 fee1 	bl	31378 <rpc_gnss_client_request_alloc>
   305b6:	4605      	mov	r5, r0
   305b8:	9800      	ldr	r0, [sp, #0]
   305ba:	2d00      	cmp	r5, #0
   305bc:	d172      	bne.n	306a4 <gnss_interface_write+0x170>
   305be:	2800      	cmp	r0, #0
   305c0:	d077      	beq.n	306b2 <gnss_interface_write+0x17e>
   305c2:	f241 0605 	movw	r6, #4101	; 0x1005
   305c6:	f04f 0c49 	mov.w	ip, #73	; 0x49
   305ca:	2272      	movs	r2, #114	; 0x72
   305cc:	f04f 0e76 	mov.w	lr, #118	; 0x76
   305d0:	f04f 0943 	mov.w	r9, #67	; 0x43
   305d4:	f04f 0854 	mov.w	r8, #84	; 0x54
   305d8:	4f4e      	ldr	r7, [pc, #312]	; (30714 <gnss_interface_write+0x1e0>)
   305da:	a91e      	add	r1, sp, #120	; 0x78
   305dc:	883b      	ldrh	r3, [r7, #0]
   305de:	f880 c00f 	strb.w	ip, [r0, #15]
   305e2:	3301      	adds	r3, #1
   305e4:	b29b      	uxth	r3, r3
   305e6:	ea46 4c03 	orr.w	ip, r6, r3, lsl #16
   305ea:	f841 cd74 	str.w	ip, [r1, #-116]!
   305ee:	7145      	strb	r5, [r0, #5]
   305f0:	7185      	strb	r5, [r0, #6]
   305f2:	71c5      	strb	r5, [r0, #7]
   305f4:	7205      	strb	r5, [r0, #8]
   305f6:	7245      	strb	r5, [r0, #9]
   305f8:	7285      	strb	r5, [r0, #10]
   305fa:	72c5      	strb	r5, [r0, #11]
   305fc:	7102      	strb	r2, [r0, #4]
   305fe:	f880 900c 	strb.w	r9, [r0, #12]
   30602:	f880 800d 	strb.w	r8, [r0, #13]
   30606:	f880 e00e 	strb.w	lr, [r0, #14]
   3060a:	6800      	ldr	r0, [r0, #0]
   3060c:	803b      	strh	r3, [r7, #0]
   3060e:	f009 fbb6 	bl	39d7e <memcpy>
   30612:	4b41      	ldr	r3, [pc, #260]	; (30718 <gnss_interface_write+0x1e4>)
   30614:	4631      	mov	r1, r6
   30616:	9800      	ldr	r0, [sp, #0]
   30618:	601d      	str	r5, [r3, #0]
   3061a:	f000 fec1 	bl	313a0 <rpc_gnss_client_request_send>
   3061e:	2800      	cmp	r0, #0
   30620:	d14e      	bne.n	306c0 <gnss_interface_write+0x18c>
   30622:	6823      	ldr	r3, [r4, #0]
   30624:	0299      	lsls	r1, r3, #10
   30626:	d50b      	bpl.n	30640 <gnss_interface_write+0x10c>
   30628:	4e3c      	ldr	r6, [pc, #240]	; (3071c <gnss_interface_write+0x1e8>)
   3062a:	4d38      	ldr	r5, [pc, #224]	; (3070c <gnss_interface_write+0x1d8>)
   3062c:	e000      	b.n	30630 <gnss_interface_write+0xfc>
   3062e:	b978      	cbnz	r0, 30650 <gnss_interface_write+0x11c>
   30630:	4631      	mov	r1, r6
   30632:	4628      	mov	r0, r5
   30634:	f7f7 f980 	bl	27938 <bsd_os_timedwait>
   30638:	6823      	ldr	r3, [r4, #0]
   3063a:	029a      	lsls	r2, r3, #10
   3063c:	d4f7      	bmi.n	3062e <gnss_interface_write+0xfa>
   3063e:	b938      	cbnz	r0, 30650 <gnss_interface_write+0x11c>
   30640:	6823      	ldr	r3, [r4, #0]
   30642:	039b      	lsls	r3, r3, #14
   30644:	d4ab      	bmi.n	3059e <gnss_interface_write+0x6a>
   30646:	2005      	movs	r0, #5
   30648:	6823      	ldr	r3, [r4, #0]
   3064a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   3064e:	6023      	str	r3, [r4, #0]
   30650:	f7f7 fa06 	bl	27a60 <bsd_os_errno_set>
   30654:	f04f 30ff 	mov.w	r0, #4294967295
   30658:	b01f      	add	sp, #124	; 0x7c
   3065a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   3065e:	4608      	mov	r0, r1
   30660:	a902      	add	r1, sp, #8
   30662:	f000 fe27 	bl	312b4 <rpc_gnss_serialize_time_and_sv_tow>
   30666:	e7a2      	b.n	305ae <gnss_interface_write+0x7a>
   30668:	4608      	mov	r0, r1
   3066a:	a902      	add	r1, sp, #8
   3066c:	f000 fe4a 	bl	31304 <rpc_gnss_serialize_location>
   30670:	e79d      	b.n	305ae <gnss_interface_write+0x7a>
   30672:	4608      	mov	r0, r1
   30674:	a902      	add	r1, sp, #8
   30676:	f000 fe03 	bl	31280 <rpc_gnss_serialize_nequick>
   3067a:	e798      	b.n	305ae <gnss_interface_write+0x7a>
   3067c:	4608      	mov	r0, r1
   3067e:	a902      	add	r1, sp, #8
   30680:	f000 fdda 	bl	31238 <rpc_gnss_serialize_klob>
   30684:	e793      	b.n	305ae <gnss_interface_write+0x7a>
   30686:	4608      	mov	r0, r1
   30688:	a902      	add	r1, sp, #8
   3068a:	f000 fda3 	bl	311d4 <rpc_gnss_serialize_alm>
   3068e:	e78e      	b.n	305ae <gnss_interface_write+0x7a>
   30690:	4608      	mov	r0, r1
   30692:	a902      	add	r1, sp, #8
   30694:	f000 fd4c 	bl	31130 <rpc_gnss_serialize_ephe>
   30698:	e789      	b.n	305ae <gnss_interface_write+0x7a>
   3069a:	4608      	mov	r0, r1
   3069c:	a902      	add	r1, sp, #8
   3069e:	f000 fd25 	bl	310ec <rpc_gnss_serialize_utc>
   306a2:	e784      	b.n	305ae <gnss_interface_write+0x7a>
   306a4:	b128      	cbz	r0, 306b2 <gnss_interface_write+0x17e>
   306a6:	6803      	ldr	r3, [r0, #0]
   306a8:	b11b      	cbz	r3, 306b2 <gnss_interface_write+0x17e>
   306aa:	4618      	mov	r0, r3
   306ac:	f000 fe96 	bl	313dc <rpc_gnss_client_data_free>
   306b0:	9800      	ldr	r0, [sp, #0]
   306b2:	f000 fe8b 	bl	313cc <rpc_gnss_client_message_free>
   306b6:	2023      	movs	r0, #35	; 0x23
   306b8:	f7f7 f9d2 	bl	27a60 <bsd_os_errno_set>
   306bc:	f04f 30ff 	mov.w	r0, #4294967295
   306c0:	6823      	ldr	r3, [r4, #0]
   306c2:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   306c6:	6023      	str	r3, [r4, #0]
   306c8:	6823      	ldr	r3, [r4, #0]
   306ca:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   306ce:	6023      	str	r3, [r4, #0]
   306d0:	b01f      	add	sp, #124	; 0x7c
   306d2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   306d6:	2016      	movs	r0, #22
   306d8:	f7f7 f9c2 	bl	27a60 <bsd_os_errno_set>
   306dc:	f04f 30ff 	mov.w	r0, #4294967295
   306e0:	b01f      	add	sp, #124	; 0x7c
   306e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   306e6:	2039      	movs	r0, #57	; 0x39
   306e8:	f7f7 f9ba 	bl	27a60 <bsd_os_errno_set>
   306ec:	f04f 30ff 	mov.w	r0, #4294967295
   306f0:	e756      	b.n	305a0 <gnss_interface_write+0x6c>
   306f2:	2009      	movs	r0, #9
   306f4:	f7f7 f9b4 	bl	27a60 <bsd_os_errno_set>
   306f8:	f04f 30ff 	mov.w	r0, #4294967295
   306fc:	e750      	b.n	305a0 <gnss_interface_write+0x6c>
   306fe:	202d      	movs	r0, #45	; 0x2d
   30700:	f7f7 f9ae 	bl	27a60 <bsd_os_errno_set>
   30704:	f04f 30ff 	mov.w	r0, #4294967295
   30708:	e74a      	b.n	305a0 <gnss_interface_write+0x6c>
   3070a:	bf00      	nop
   3070c:	49765443 	.word	0x49765443
   30710:	20020edc 	.word	0x20020edc
   30714:	2002229c 	.word	0x2002229c
   30718:	20020ee0 	.word	0x20020ee0
   3071c:	2002b050 	.word	0x2002b050

00030720 <gnss_interface_read>:
   30720:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   30724:	4c50      	ldr	r4, [pc, #320]	; (30868 <gnss_interface_read+0x148>)
   30726:	b0b7      	sub	sp, #220	; 0xdc
   30728:	42a0      	cmp	r0, r4
   3072a:	f040 81fe 	bne.w	30b2a <gnss_interface_read+0x40a>
   3072e:	4688      	mov	r8, r1
   30730:	2900      	cmp	r1, #0
   30732:	f000 81f4 	beq.w	30b1e <gnss_interface_read+0x3fe>
   30736:	2ad7      	cmp	r2, #215	; 0xd7
   30738:	f240 81f1 	bls.w	30b1e <gnss_interface_read+0x3fe>
   3073c:	4d4b      	ldr	r5, [pc, #300]	; (3086c <gnss_interface_read+0x14c>)
   3073e:	4699      	mov	r9, r3
   30740:	682b      	ldr	r3, [r5, #0]
   30742:	b29b      	uxth	r3, r3
   30744:	2b04      	cmp	r3, #4
   30746:	d004      	beq.n	30752 <gnss_interface_read+0x32>
   30748:	682b      	ldr	r3, [r5, #0]
   3074a:	b29b      	uxth	r3, r3
   3074c:	2b02      	cmp	r3, #2
   3074e:	f040 81e0 	bne.w	30b12 <gnss_interface_read+0x3f2>
   30752:	f1b9 0f00 	cmp.w	r9, #0
   30756:	d158      	bne.n	3080a <gnss_interface_read+0xea>
   30758:	2102      	movs	r1, #2
   3075a:	20b6      	movs	r0, #182	; 0xb6
   3075c:	2400      	movs	r4, #0
   3075e:	682b      	ldr	r3, [r5, #0]
   30760:	f10d 020e 	add.w	r2, sp, #14
   30764:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   30768:	602b      	str	r3, [r5, #0]
   3076a:	f8df a108 	ldr.w	sl, [pc, #264]	; 30874 <gnss_interface_read+0x154>
   3076e:	ab08      	add	r3, sp, #32
   30770:	4f3f      	ldr	r7, [pc, #252]	; (30870 <gnss_interface_read+0x150>)
   30772:	4e3d      	ldr	r6, [pc, #244]	; (30868 <gnss_interface_read+0x148>)
   30774:	9005      	str	r0, [sp, #20]
   30776:	9107      	str	r1, [sp, #28]
   30778:	9304      	str	r3, [sp, #16]
   3077a:	9206      	str	r2, [sp, #24]
   3077c:	ea09 0b01 	and.w	fp, r9, r1
   30780:	f8da 0000 	ldr.w	r0, [sl]
   30784:	464a      	mov	r2, r9
   30786:	6803      	ldr	r3, [r0, #0]
   30788:	a904      	add	r1, sp, #16
   3078a:	689b      	ldr	r3, [r3, #8]
   3078c:	4798      	blx	r3
   3078e:	2800      	cmp	r0, #0
   30790:	da11      	bge.n	307b6 <gnss_interface_read+0x96>
   30792:	f1bb 0f00 	cmp.w	fp, #0
   30796:	d141      	bne.n	3081c <gnss_interface_read+0xfc>
   30798:	682b      	ldr	r3, [r5, #0]
   3079a:	03d8      	lsls	r0, r3, #15
   3079c:	d4f0      	bmi.n	30780 <gnss_interface_read+0x60>
   3079e:	b10c      	cbz	r4, 307a4 <gnss_interface_read+0x84>
   307a0:	e7ee      	b.n	30780 <gnss_interface_read+0x60>
   307a2:	b930      	cbnz	r0, 307b2 <gnss_interface_read+0x92>
   307a4:	4639      	mov	r1, r7
   307a6:	4630      	mov	r0, r6
   307a8:	f7f7 f8c6 	bl	27938 <bsd_os_timedwait>
   307ac:	682b      	ldr	r3, [r5, #0]
   307ae:	03d9      	lsls	r1, r3, #15
   307b0:	d5f7      	bpl.n	307a2 <gnss_interface_read+0x82>
   307b2:	4604      	mov	r4, r0
   307b4:	e7e4      	b.n	30780 <gnss_interface_read+0x60>
   307b6:	f244 0202 	movw	r2, #16386	; 0x4002
   307ba:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   307be:	4293      	cmp	r3, r2
   307c0:	d042      	beq.n	30848 <gnss_interface_read+0x128>
   307c2:	f244 0201 	movw	r2, #16385	; 0x4001
   307c6:	4293      	cmp	r3, r2
   307c8:	d056      	beq.n	30878 <gnss_interface_read+0x158>
   307ca:	f244 0203 	movw	r2, #16387	; 0x4003
   307ce:	4293      	cmp	r3, r2
   307d0:	f040 81a5 	bne.w	30b1e <gnss_interface_read+0x3fe>
   307d4:	2203      	movs	r2, #3
   307d6:	2414      	movs	r4, #20
   307d8:	9b08      	ldr	r3, [sp, #32]
   307da:	f888 2000 	strb.w	r2, [r8]
   307de:	9a09      	ldr	r2, [sp, #36]	; 0x24
   307e0:	f8c8 3008 	str.w	r3, [r8, #8]
   307e4:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   307e8:	e9c8 2303 	strd	r2, r3, [r8, #12]
   307ec:	f8da 0000 	ldr.w	r0, [sl]
   307f0:	6803      	ldr	r3, [r0, #0]
   307f2:	68db      	ldr	r3, [r3, #12]
   307f4:	4798      	blx	r3
   307f6:	2800      	cmp	r0, #0
   307f8:	dd03      	ble.n	30802 <gnss_interface_read+0xe2>
   307fa:	682b      	ldr	r3, [r5, #0]
   307fc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   30800:	602b      	str	r3, [r5, #0]
   30802:	4620      	mov	r0, r4
   30804:	b037      	add	sp, #220	; 0xdc
   30806:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3080a:	f019 0f0a 	tst.w	r9, #10
   3080e:	d1a3      	bne.n	30758 <gnss_interface_read+0x38>
   30810:	202d      	movs	r0, #45	; 0x2d
   30812:	f7f7 f925 	bl	27a60 <bsd_os_errno_set>
   30816:	f04f 34ff 	mov.w	r4, #4294967295
   3081a:	e7f2      	b.n	30802 <gnss_interface_read+0xe2>
   3081c:	1c42      	adds	r2, r0, #1
   3081e:	4603      	mov	r3, r0
   30820:	d1c9      	bne.n	307b6 <gnss_interface_read+0x96>
   30822:	b93c      	cbnz	r4, 30834 <gnss_interface_read+0x114>
   30824:	461c      	mov	r4, r3
   30826:	2023      	movs	r0, #35	; 0x23
   30828:	f7f7 f91a 	bl	27a60 <bsd_os_errno_set>
   3082c:	4620      	mov	r0, r4
   3082e:	b037      	add	sp, #220	; 0xdc
   30830:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   30834:	9001      	str	r0, [sp, #4]
   30836:	4620      	mov	r0, r4
   30838:	f7f7 f912 	bl	27a60 <bsd_os_errno_set>
   3083c:	9b01      	ldr	r3, [sp, #4]
   3083e:	461c      	mov	r4, r3
   30840:	4620      	mov	r0, r4
   30842:	b037      	add	sp, #220	; 0xdc
   30844:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   30848:	a808      	add	r0, sp, #32
   3084a:	f7ec fc85 	bl	1d158 <strlen>
   3084e:	2302      	movs	r3, #2
   30850:	1c44      	adds	r4, r0, #1
   30852:	b2a4      	uxth	r4, r4
   30854:	f808 3b08 	strb.w	r3, [r8], #8
   30858:	4622      	mov	r2, r4
   3085a:	a908      	add	r1, sp, #32
   3085c:	4640      	mov	r0, r8
   3085e:	f009 fa8e 	bl	39d7e <memcpy>
   30862:	3408      	adds	r4, #8
   30864:	e7c2      	b.n	307ec <gnss_interface_read+0xcc>
   30866:	bf00      	nop
   30868:	49765443 	.word	0x49765443
   3086c:	20020edc 	.word	0x20020edc
   30870:	2002b050 	.word	0x2002b050
   30874:	20020ee4 	.word	0x20020ee4
   30878:	2401      	movs	r4, #1
   3087a:	a809      	add	r0, sp, #36	; 0x24
   3087c:	c80f      	ldmia	r0, {r0, r1, r2, r3}
   3087e:	e9c8 0102 	strd	r0, r1, [r8, #8]
   30882:	e9c8 2304 	strd	r2, r3, [r8, #16]
   30886:	990d      	ldr	r1, [sp, #52]	; 0x34
   30888:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   3088a:	f888 4000 	strb.w	r4, [r8]
   3088e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   30890:	f8c8 1018 	str.w	r1, [r8, #24]
   30894:	9910      	ldr	r1, [sp, #64]	; 0x40
   30896:	f8c8 201c 	str.w	r2, [r8, #28]
   3089a:	f8c8 3020 	str.w	r3, [r8, #32]
   3089e:	f89d 205d 	ldrb.w	r2, [sp, #93]	; 0x5d
   308a2:	f8dd 304d 	ldr.w	r3, [sp, #77]	; 0x4d
   308a6:	f8c8 1024 	str.w	r1, [r8, #36]	; 0x24
   308aa:	f8dd 1051 	ldr.w	r1, [sp, #81]	; 0x51
   308ae:	f888 2044 	strb.w	r2, [r8, #68]	; 0x44
   308b2:	f8dd 2055 	ldr.w	r2, [sp, #85]	; 0x55
   308b6:	f8c8 3034 	str.w	r3, [r8, #52]	; 0x34
   308ba:	f8dd 3059 	ldr.w	r3, [sp, #89]	; 0x59
   308be:	f8c8 1038 	str.w	r1, [r8, #56]	; 0x38
   308c2:	f8bd 1044 	ldrh.w	r1, [sp, #68]	; 0x44
   308c6:	f8c8 203c 	str.w	r2, [r8, #60]	; 0x3c
   308ca:	f8c8 3040 	str.w	r3, [r8, #64]	; 0x40
   308ce:	f8dd 2046 	ldr.w	r2, [sp, #70]	; 0x46
   308d2:	f89d 304a 	ldrb.w	r3, [sp, #74]	; 0x4a
   308d6:	f8a8 1028 	strh.w	r1, [r8, #40]	; 0x28
   308da:	f888 302e 	strb.w	r3, [r8, #46]	; 0x2e
   308de:	f8c8 202a 	str.w	r2, [r8, #42]	; 0x2a
   308e2:	f89d 004b 	ldrb.w	r0, [sp, #75]	; 0x4b
   308e6:	f89d 204c 	ldrb.w	r2, [sp, #76]	; 0x4c
   308ea:	9b18      	ldr	r3, [sp, #96]	; 0x60
   308ec:	f89d 406c 	ldrb.w	r4, [sp, #108]	; 0x6c
   308f0:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
   308f4:	f89d 206b 	ldrb.w	r2, [sp, #107]	; 0x6b
   308f8:	f3c3 210f 	ubfx	r1, r3, #8, #16
   308fc:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   308fe:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
   30902:	f8a8 0030 	strh.w	r0, [r8, #48]	; 0x30
   30906:	f8a8 104a 	strh.w	r1, [r8, #74]	; 0x4a
   3090a:	f8bd 105e 	ldrh.w	r1, [sp, #94]	; 0x5e
   3090e:	f3c3 230f 	ubfx	r3, r3, #8, #16
   30912:	f8a8 2056 	strh.w	r2, [r8, #86]	; 0x56
   30916:	f89d 2060 	ldrb.w	r2, [sp, #96]	; 0x60
   3091a:	f8a8 3062 	strh.w	r3, [r8, #98]	; 0x62
   3091e:	f8dd 3063 	ldr.w	r3, [sp, #99]	; 0x63
   30922:	f8a8 1046 	strh.w	r1, [r8, #70]	; 0x46
   30926:	f888 2048 	strb.w	r2, [r8, #72]	; 0x48
   3092a:	f8bd 2068 	ldrh.w	r2, [sp, #104]	; 0x68
   3092e:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
   30932:	f8c8 304c 	str.w	r3, [r8, #76]	; 0x4c
   30936:	f89d 306a 	ldrb.w	r3, [sp, #106]	; 0x6a
   3093a:	f888 1050 	strb.w	r1, [r8, #80]	; 0x50
   3093e:	f8a8 2052 	strh.w	r2, [r8, #82]	; 0x52
   30942:	f888 3054 	strb.w	r3, [r8, #84]	; 0x54
   30946:	f8bd 3072 	ldrh.w	r3, [sp, #114]	; 0x72
   3094a:	f8dd 106d 	ldr.w	r1, [sp, #109]	; 0x6d
   3094e:	f89d 2071 	ldrb.w	r2, [sp, #113]	; 0x71
   30952:	f8c8 1058 	str.w	r1, [r8, #88]	; 0x58
   30956:	f888 205c 	strb.w	r2, [r8, #92]	; 0x5c
   3095a:	f89d 1074 	ldrb.w	r1, [sp, #116]	; 0x74
   3095e:	f8dd 2077 	ldr.w	r2, [sp, #119]	; 0x77
   30962:	f8a8 305e 	strh.w	r3, [r8, #94]	; 0x5e
   30966:	f89d 307b 	ldrb.w	r3, [sp, #123]	; 0x7b
   3096a:	f888 1060 	strb.w	r1, [r8, #96]	; 0x60
   3096e:	f8c8 2064 	str.w	r2, [r8, #100]	; 0x64
   30972:	f888 3068 	strb.w	r3, [r8, #104]	; 0x68
   30976:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
   3097a:	f89d 107f 	ldrb.w	r1, [sp, #127]	; 0x7f
   3097e:	9a22      	ldr	r2, [sp, #136]	; 0x88
   30980:	f89d 0094 	ldrb.w	r0, [sp, #148]	; 0x94
   30984:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
   30988:	f89d 3093 	ldrb.w	r3, [sp, #147]	; 0x93
   3098c:	f3c2 220f 	ubfx	r2, r2, #8, #16
   30990:	f8a8 106e 	strh.w	r1, [r8, #110]	; 0x6e
   30994:	f8bd 107c 	ldrh.w	r1, [sp, #124]	; 0x7c
   30998:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   3099c:	f8a8 207a 	strh.w	r2, [r8, #122]	; 0x7a
   309a0:	f89d 207e 	ldrb.w	r2, [sp, #126]	; 0x7e
   309a4:	f8a8 3086 	strh.w	r3, [r8, #134]	; 0x86
   309a8:	f8dd 3081 	ldr.w	r3, [sp, #129]	; 0x81
   309ac:	f8a8 106a 	strh.w	r1, [r8, #106]	; 0x6a
   309b0:	f888 206c 	strb.w	r2, [r8, #108]	; 0x6c
   309b4:	f8bd 2086 	ldrh.w	r2, [sp, #134]	; 0x86
   309b8:	f89d 1085 	ldrb.w	r1, [sp, #133]	; 0x85
   309bc:	f8c8 3070 	str.w	r3, [r8, #112]	; 0x70
   309c0:	f89d 3088 	ldrb.w	r3, [sp, #136]	; 0x88
   309c4:	f888 1074 	strb.w	r1, [r8, #116]	; 0x74
   309c8:	f8a8 2076 	strh.w	r2, [r8, #118]	; 0x76
   309cc:	f888 3078 	strb.w	r3, [r8, #120]	; 0x78
   309d0:	f8bd 3090 	ldrh.w	r3, [sp, #144]	; 0x90
   309d4:	f8dd 108b 	ldr.w	r1, [sp, #139]	; 0x8b
   309d8:	f89d 208f 	ldrb.w	r2, [sp, #143]	; 0x8f
   309dc:	f8c8 107c 	str.w	r1, [r8, #124]	; 0x7c
   309e0:	f888 2080 	strb.w	r2, [r8, #128]	; 0x80
   309e4:	f89d 1092 	ldrb.w	r1, [sp, #146]	; 0x92
   309e8:	f8dd 2095 	ldr.w	r2, [sp, #149]	; 0x95
   309ec:	f8a8 3082 	strh.w	r3, [r8, #130]	; 0x82
   309f0:	f89d 3099 	ldrb.w	r3, [sp, #153]	; 0x99
   309f4:	f888 1084 	strb.w	r1, [r8, #132]	; 0x84
   309f8:	f8c8 2088 	str.w	r2, [r8, #136]	; 0x88
   309fc:	f888 308c 	strb.w	r3, [r8, #140]	; 0x8c
   30a00:	f8bd 009a 	ldrh.w	r0, [sp, #154]	; 0x9a
   30a04:	9b27      	ldr	r3, [sp, #156]	; 0x9c
   30a06:	f89d 40a8 	ldrb.w	r4, [sp, #168]	; 0xa8
   30a0a:	f89d 20a7 	ldrb.w	r2, [sp, #167]	; 0xa7
   30a0e:	f3c3 210f 	ubfx	r1, r3, #8, #16
   30a12:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   30a14:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
   30a18:	f8a8 1092 	strh.w	r1, [r8, #146]	; 0x92
   30a1c:	f89d 109c 	ldrb.w	r1, [sp, #156]	; 0x9c
   30a20:	f8a8 209e 	strh.w	r2, [r8, #158]	; 0x9e
   30a24:	f3c3 230f 	ubfx	r3, r3, #8, #16
   30a28:	f8dd 209f 	ldr.w	r2, [sp, #159]	; 0x9f
   30a2c:	f8a8 008e 	strh.w	r0, [r8, #142]	; 0x8e
   30a30:	f8a8 30aa 	strh.w	r3, [r8, #170]	; 0xaa
   30a34:	f888 1090 	strb.w	r1, [r8, #144]	; 0x90
   30a38:	f89d 30a3 	ldrb.w	r3, [sp, #163]	; 0xa3
   30a3c:	f8bd 10a4 	ldrh.w	r1, [sp, #164]	; 0xa4
   30a40:	f8c8 2094 	str.w	r2, [r8, #148]	; 0x94
   30a44:	f89d 20a6 	ldrb.w	r2, [sp, #166]	; 0xa6
   30a48:	f888 3098 	strb.w	r3, [r8, #152]	; 0x98
   30a4c:	f8dd 30a9 	ldr.w	r3, [sp, #169]	; 0xa9
   30a50:	f8a8 109a 	strh.w	r1, [r8, #154]	; 0x9a
   30a54:	f888 209c 	strb.w	r2, [r8, #156]	; 0x9c
   30a58:	f8bd 20ae 	ldrh.w	r2, [sp, #174]	; 0xae
   30a5c:	f89d 10ad 	ldrb.w	r1, [sp, #173]	; 0xad
   30a60:	f8c8 30a0 	str.w	r3, [r8, #160]	; 0xa0
   30a64:	f89d 30b0 	ldrb.w	r3, [sp, #176]	; 0xb0
   30a68:	f888 10a4 	strb.w	r1, [r8, #164]	; 0xa4
   30a6c:	f8a8 20a6 	strh.w	r2, [r8, #166]	; 0xa6
   30a70:	f888 30a8 	strb.w	r3, [r8, #168]	; 0xa8
   30a74:	f8bd 30b8 	ldrh.w	r3, [sp, #184]	; 0xb8
   30a78:	f8dd 10b3 	ldr.w	r1, [sp, #179]	; 0xb3
   30a7c:	f89d 20b7 	ldrb.w	r2, [sp, #183]	; 0xb7
   30a80:	f8c8 10ac 	str.w	r1, [r8, #172]	; 0xac
   30a84:	f888 20b0 	strb.w	r2, [r8, #176]	; 0xb0
   30a88:	f8a8 30b2 	strh.w	r3, [r8, #178]	; 0xb2
   30a8c:	f89d 30bc 	ldrb.w	r3, [sp, #188]	; 0xbc
   30a90:	f89d 10bb 	ldrb.w	r1, [sp, #187]	; 0xbb
   30a94:	f89d 00d0 	ldrb.w	r0, [sp, #208]	; 0xd0
   30a98:	9a31      	ldr	r2, [sp, #196]	; 0xc4
   30a9a:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
   30a9e:	f89d 30cf 	ldrb.w	r3, [sp, #207]	; 0xcf
   30aa2:	f89d 40ba 	ldrb.w	r4, [sp, #186]	; 0xba
   30aa6:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   30aaa:	f3c2 220f 	ubfx	r2, r2, #8, #16
   30aae:	f8a8 10b6 	strh.w	r1, [r8, #182]	; 0xb6
   30ab2:	f8a8 30ce 	strh.w	r3, [r8, #206]	; 0xce
   30ab6:	f888 40b4 	strb.w	r4, [r8, #180]	; 0xb4
   30aba:	f8a8 20c2 	strh.w	r2, [r8, #194]	; 0xc2
   30abe:	f8bd 20c2 	ldrh.w	r2, [sp, #194]	; 0xc2
   30ac2:	f89d 10c1 	ldrb.w	r1, [sp, #193]	; 0xc1
   30ac6:	f89d 30c4 	ldrb.w	r3, [sp, #196]	; 0xc4
   30aca:	f8dd 00bd 	ldr.w	r0, [sp, #189]	; 0xbd
   30ace:	f888 10bc 	strb.w	r1, [r8, #188]	; 0xbc
   30ad2:	f8a8 20be 	strh.w	r2, [r8, #190]	; 0xbe
   30ad6:	f8c8 00b8 	str.w	r0, [r8, #184]	; 0xb8
   30ada:	f888 30c0 	strb.w	r3, [r8, #192]	; 0xc0
   30ade:	f8bd 30cc 	ldrh.w	r3, [sp, #204]	; 0xcc
   30ae2:	f8dd 10c7 	ldr.w	r1, [sp, #199]	; 0xc7
   30ae6:	f89d 20cb 	ldrb.w	r2, [sp, #203]	; 0xcb
   30aea:	f8c8 10c4 	str.w	r1, [r8, #196]	; 0xc4
   30aee:	f888 20c8 	strb.w	r2, [r8, #200]	; 0xc8
   30af2:	f89d 10ce 	ldrb.w	r1, [sp, #206]	; 0xce
   30af6:	f8dd 20d1 	ldr.w	r2, [sp, #209]	; 0xd1
   30afa:	f8a8 30ca 	strh.w	r3, [r8, #202]	; 0xca
   30afe:	f89d 30d5 	ldrb.w	r3, [sp, #213]	; 0xd5
   30b02:	f888 10cc 	strb.w	r1, [r8, #204]	; 0xcc
   30b06:	f8c8 20d0 	str.w	r2, [r8, #208]	; 0xd0
   30b0a:	f888 30d4 	strb.w	r3, [r8, #212]	; 0xd4
   30b0e:	24d8      	movs	r4, #216	; 0xd8
   30b10:	e66c      	b.n	307ec <gnss_interface_read+0xcc>
   30b12:	2039      	movs	r0, #57	; 0x39
   30b14:	f7f6 ffa4 	bl	27a60 <bsd_os_errno_set>
   30b18:	f04f 34ff 	mov.w	r4, #4294967295
   30b1c:	e671      	b.n	30802 <gnss_interface_read+0xe2>
   30b1e:	2016      	movs	r0, #22
   30b20:	f7f6 ff9e 	bl	27a60 <bsd_os_errno_set>
   30b24:	f04f 34ff 	mov.w	r4, #4294967295
   30b28:	e66b      	b.n	30802 <gnss_interface_read+0xe2>
   30b2a:	2009      	movs	r0, #9
   30b2c:	f7f6 ff98 	bl	27a60 <bsd_os_errno_set>
   30b30:	f04f 34ff 	mov.w	r4, #4294967295
   30b34:	e665      	b.n	30802 <gnss_interface_read+0xe2>
   30b36:	bf00      	nop

00030b38 <gnss_interface_setopt>:
   30b38:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   30b3c:	f241 1402 	movw	r4, #4354	; 0x1102
   30b40:	4222      	tst	r2, r4
   30b42:	b086      	sub	sp, #24
   30b44:	4d9c      	ldr	r5, [pc, #624]	; (30db8 <gnss_interface_setopt+0x280>)
   30b46:	d004      	beq.n	30b52 <gnss_interface_setopt+0x1a>
   30b48:	682c      	ldr	r4, [r5, #0]
   30b4a:	b2a4      	uxth	r4, r4
   30b4c:	2c02      	cmp	r4, #2
   30b4e:	f040 8104 	bne.w	30d5a <gnss_interface_setopt+0x222>
   30b52:	682c      	ldr	r4, [r5, #0]
   30b54:	0264      	lsls	r4, r4, #9
   30b56:	f100 8128 	bmi.w	30daa <gnss_interface_setopt+0x272>
   30b5a:	f5b1 7f01 	cmp.w	r1, #516	; 0x204
   30b5e:	f040 811e 	bne.w	30d9e <gnss_interface_setopt+0x266>
   30b62:	4996      	ldr	r1, [pc, #600]	; (30dbc <gnss_interface_setopt+0x284>)
   30b64:	4288      	cmp	r0, r1
   30b66:	f040 8114 	bne.w	30d92 <gnss_interface_setopt+0x25a>
   30b6a:	3a01      	subs	r2, #1
   30b6c:	2a08      	cmp	r2, #8
   30b6e:	f200 80ec 	bhi.w	30d4a <gnss_interface_setopt+0x212>
   30b72:	e8df f012 	tbh	[pc, r2, lsl #1]
   30b76:	0075      	.short	0x0075
   30b78:	00c200d8 	.word	0x00c200d8
   30b7c:	008100cc 	.word	0x008100cc
   30b80:	0098008c 	.word	0x0098008c
   30b84:	000900af 	.word	0x000900af
   30b88:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   30b8a:	2a01      	cmp	r2, #1
   30b8c:	f040 80dd 	bne.w	30d4a <gnss_interface_setopt+0x212>
   30b90:	f241 1603 	movw	r6, #4355	; 0x1103
   30b94:	2240      	movs	r2, #64	; 0x40
   30b96:	4637      	mov	r7, r6
   30b98:	781b      	ldrb	r3, [r3, #0]
   30b9a:	9202      	str	r2, [sp, #8]
   30b9c:	f88d 3015 	strb.w	r3, [sp, #21]
   30ba0:	682b      	ldr	r3, [r5, #0]
   30ba2:	2112      	movs	r1, #18
   30ba4:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   30ba8:	4668      	mov	r0, sp
   30baa:	602b      	str	r3, [r5, #0]
   30bac:	f000 fbe4 	bl	31378 <rpc_gnss_client_request_alloc>
   30bb0:	4604      	mov	r4, r0
   30bb2:	9800      	ldr	r0, [sp, #0]
   30bb4:	2c00      	cmp	r4, #0
   30bb6:	f040 80d6 	bne.w	30d66 <gnss_interface_setopt+0x22e>
   30bba:	2800      	cmp	r0, #0
   30bbc:	f000 80da 	beq.w	30d74 <gnss_interface_setopt+0x23c>
   30bc0:	2212      	movs	r2, #18
   30bc2:	f04f 0876 	mov.w	r8, #118	; 0x76
   30bc6:	f04f 0e49 	mov.w	lr, #73	; 0x49
   30bca:	f04f 0a43 	mov.w	sl, #67	; 0x43
   30bce:	f04f 0954 	mov.w	r9, #84	; 0x54
   30bd2:	f8df c1f0 	ldr.w	ip, [pc, #496]	; 30dc4 <gnss_interface_setopt+0x28c>
   30bd6:	a906      	add	r1, sp, #24
   30bd8:	f8bc 3000 	ldrh.w	r3, [ip]
   30bdc:	f880 800e 	strb.w	r8, [r0, #14]
   30be0:	3301      	adds	r3, #1
   30be2:	b29b      	uxth	r3, r3
   30be4:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
   30be8:	f841 6d14 	str.w	r6, [r1, #-20]!
   30bec:	7144      	strb	r4, [r0, #5]
   30bee:	7184      	strb	r4, [r0, #6]
   30bf0:	71c4      	strb	r4, [r0, #7]
   30bf2:	7204      	strb	r4, [r0, #8]
   30bf4:	7244      	strb	r4, [r0, #9]
   30bf6:	7284      	strb	r4, [r0, #10]
   30bf8:	72c4      	strb	r4, [r0, #11]
   30bfa:	7102      	strb	r2, [r0, #4]
   30bfc:	f880 a00c 	strb.w	sl, [r0, #12]
   30c00:	f880 900d 	strb.w	r9, [r0, #13]
   30c04:	f880 e00f 	strb.w	lr, [r0, #15]
   30c08:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 30dc8 <gnss_interface_setopt+0x290>
   30c0c:	6800      	ldr	r0, [r0, #0]
   30c0e:	f8ac 3000 	strh.w	r3, [ip]
   30c12:	f009 f8b4 	bl	39d7e <memcpy>
   30c16:	4639      	mov	r1, r7
   30c18:	9800      	ldr	r0, [sp, #0]
   30c1a:	f8c8 4000 	str.w	r4, [r8]
   30c1e:	f000 fbbf 	bl	313a0 <rpc_gnss_client_request_send>
   30c22:	2800      	cmp	r0, #0
   30c24:	f040 80ab 	bne.w	30d7e <gnss_interface_setopt+0x246>
   30c28:	4f65      	ldr	r7, [pc, #404]	; (30dc0 <gnss_interface_setopt+0x288>)
   30c2a:	4e64      	ldr	r6, [pc, #400]	; (30dbc <gnss_interface_setopt+0x284>)
   30c2c:	4639      	mov	r1, r7
   30c2e:	4630      	mov	r0, r6
   30c30:	f7f6 fe82 	bl	27938 <bsd_os_timedwait>
   30c34:	682c      	ldr	r4, [r5, #0]
   30c36:	f414 0480 	ands.w	r4, r4, #4194304	; 0x400000
   30c3a:	d1f7      	bne.n	30c2c <gnss_interface_setopt+0xf4>
   30c3c:	f8d8 0000 	ldr.w	r0, [r8]
   30c40:	b118      	cbz	r0, 30c4a <gnss_interface_setopt+0x112>
   30c42:	f000 fbcb 	bl	313dc <rpc_gnss_client_data_free>
   30c46:	f8c8 4000 	str.w	r4, [r8]
   30c4a:	682b      	ldr	r3, [r5, #0]
   30c4c:	021b      	lsls	r3, r3, #8
   30c4e:	d576      	bpl.n	30d3e <gnss_interface_setopt+0x206>
   30c50:	2000      	movs	r0, #0
   30c52:	682b      	ldr	r3, [r5, #0]
   30c54:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   30c58:	602b      	str	r3, [r5, #0]
   30c5a:	b006      	add	sp, #24
   30c5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   30c60:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   30c62:	2a02      	cmp	r2, #2
   30c64:	d171      	bne.n	30d4a <gnss_interface_setopt+0x212>
   30c66:	2208      	movs	r2, #8
   30c68:	f241 1603 	movw	r6, #4355	; 0x1103
   30c6c:	881b      	ldrh	r3, [r3, #0]
   30c6e:	9202      	str	r2, [sp, #8]
   30c70:	f8ad 300f 	strh.w	r3, [sp, #15]
   30c74:	4637      	mov	r7, r6
   30c76:	e793      	b.n	30ba0 <gnss_interface_setopt+0x68>
   30c78:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   30c7a:	2a01      	cmp	r2, #1
   30c7c:	d165      	bne.n	30d4a <gnss_interface_setopt+0x212>
   30c7e:	f241 1603 	movw	r6, #4355	; 0x1103
   30c82:	781b      	ldrb	r3, [r3, #0]
   30c84:	9202      	str	r2, [sp, #8]
   30c86:	f88d 300c 	strb.w	r3, [sp, #12]
   30c8a:	4637      	mov	r7, r6
   30c8c:	e788      	b.n	30ba0 <gnss_interface_setopt+0x68>
   30c8e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   30c90:	2a01      	cmp	r2, #1
   30c92:	d15a      	bne.n	30d4a <gnss_interface_setopt+0x212>
   30c94:	2202      	movs	r2, #2
   30c96:	f241 1603 	movw	r6, #4355	; 0x1103
   30c9a:	781b      	ldrb	r3, [r3, #0]
   30c9c:	9202      	str	r2, [sp, #8]
   30c9e:	f88d 300d 	strb.w	r3, [sp, #13]
   30ca2:	4637      	mov	r7, r6
   30ca4:	e77c      	b.n	30ba0 <gnss_interface_setopt+0x68>
   30ca6:	682a      	ldr	r2, [r5, #0]
   30ca8:	b292      	uxth	r2, r2
   30caa:	2a02      	cmp	r2, #2
   30cac:	d155      	bne.n	30d5a <gnss_interface_setopt+0x222>
   30cae:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   30cb0:	2a04      	cmp	r2, #4
   30cb2:	d14a      	bne.n	30d4a <gnss_interface_setopt+0x212>
   30cb4:	2101      	movs	r1, #1
   30cb6:	f241 0604 	movw	r6, #4100	; 0x1004
   30cba:	682a      	ldr	r2, [r5, #0]
   30cbc:	6818      	ldr	r0, [r3, #0]
   30cbe:	0c13      	lsrs	r3, r2, #16
   30cc0:	041b      	lsls	r3, r3, #16
   30cc2:	f043 0303 	orr.w	r3, r3, #3
   30cc6:	f8cd 0009 	str.w	r0, [sp, #9]
   30cca:	602b      	str	r3, [r5, #0]
   30ccc:	f88d 1008 	strb.w	r1, [sp, #8]
   30cd0:	4637      	mov	r7, r6
   30cd2:	e765      	b.n	30ba0 <gnss_interface_setopt+0x68>
   30cd4:	682b      	ldr	r3, [r5, #0]
   30cd6:	b29b      	uxth	r3, r3
   30cd8:	2b04      	cmp	r3, #4
   30cda:	d13e      	bne.n	30d5a <gnss_interface_setopt+0x222>
   30cdc:	2300      	movs	r3, #0
   30cde:	f241 0604 	movw	r6, #4100	; 0x1004
   30ce2:	f88d 3008 	strb.w	r3, [sp, #8]
   30ce6:	f88d 3009 	strb.w	r3, [sp, #9]
   30cea:	f88d 300a 	strb.w	r3, [sp, #10]
   30cee:	f88d 300b 	strb.w	r3, [sp, #11]
   30cf2:	f88d 300c 	strb.w	r3, [sp, #12]
   30cf6:	4637      	mov	r7, r6
   30cf8:	e752      	b.n	30ba0 <gnss_interface_setopt+0x68>
   30cfa:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   30cfc:	2a01      	cmp	r2, #1
   30cfe:	d124      	bne.n	30d4a <gnss_interface_setopt+0x212>
   30d00:	781b      	ldrb	r3, [r3, #0]
   30d02:	2b01      	cmp	r3, #1
   30d04:	d121      	bne.n	30d4a <gnss_interface_setopt+0x212>
   30d06:	f241 1603 	movw	r6, #4355	; 0x1103
   30d0a:	4637      	mov	r7, r6
   30d0c:	e748      	b.n	30ba0 <gnss_interface_setopt+0x68>
   30d0e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   30d10:	2a02      	cmp	r2, #2
   30d12:	d11a      	bne.n	30d4a <gnss_interface_setopt+0x212>
   30d14:	2220      	movs	r2, #32
   30d16:	f241 1603 	movw	r6, #4355	; 0x1103
   30d1a:	881b      	ldrh	r3, [r3, #0]
   30d1c:	9202      	str	r2, [sp, #8]
   30d1e:	f8ad 3013 	strh.w	r3, [sp, #19]
   30d22:	4637      	mov	r7, r6
   30d24:	e73c      	b.n	30ba0 <gnss_interface_setopt+0x68>
   30d26:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   30d28:	2a02      	cmp	r2, #2
   30d2a:	d10e      	bne.n	30d4a <gnss_interface_setopt+0x212>
   30d2c:	2210      	movs	r2, #16
   30d2e:	f241 1603 	movw	r6, #4355	; 0x1103
   30d32:	881b      	ldrh	r3, [r3, #0]
   30d34:	9202      	str	r2, [sp, #8]
   30d36:	f8ad 3011 	strh.w	r3, [sp, #17]
   30d3a:	4637      	mov	r7, r6
   30d3c:	e730      	b.n	30ba0 <gnss_interface_setopt+0x68>
   30d3e:	200e      	movs	r0, #14
   30d40:	f7f6 fe8e 	bl	27a60 <bsd_os_errno_set>
   30d44:	f04f 30ff 	mov.w	r0, #4294967295
   30d48:	e783      	b.n	30c52 <gnss_interface_setopt+0x11a>
   30d4a:	2016      	movs	r0, #22
   30d4c:	f7f6 fe88 	bl	27a60 <bsd_os_errno_set>
   30d50:	f04f 30ff 	mov.w	r0, #4294967295
   30d54:	b006      	add	sp, #24
   30d56:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   30d5a:	200e      	movs	r0, #14
   30d5c:	f7f6 fe80 	bl	27a60 <bsd_os_errno_set>
   30d60:	f04f 30ff 	mov.w	r0, #4294967295
   30d64:	e779      	b.n	30c5a <gnss_interface_setopt+0x122>
   30d66:	b128      	cbz	r0, 30d74 <gnss_interface_setopt+0x23c>
   30d68:	6803      	ldr	r3, [r0, #0]
   30d6a:	b11b      	cbz	r3, 30d74 <gnss_interface_setopt+0x23c>
   30d6c:	4618      	mov	r0, r3
   30d6e:	f000 fb35 	bl	313dc <rpc_gnss_client_data_free>
   30d72:	9800      	ldr	r0, [sp, #0]
   30d74:	f000 fb2a 	bl	313cc <rpc_gnss_client_message_free>
   30d78:	2023      	movs	r0, #35	; 0x23
   30d7a:	f7f6 fe71 	bl	27a60 <bsd_os_errno_set>
   30d7e:	682b      	ldr	r3, [r5, #0]
   30d80:	200e      	movs	r0, #14
   30d82:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   30d86:	602b      	str	r3, [r5, #0]
   30d88:	f7f6 fe6a 	bl	27a60 <bsd_os_errno_set>
   30d8c:	f04f 30ff 	mov.w	r0, #4294967295
   30d90:	e763      	b.n	30c5a <gnss_interface_setopt+0x122>
   30d92:	2009      	movs	r0, #9
   30d94:	f7f6 fe64 	bl	27a60 <bsd_os_errno_set>
   30d98:	f04f 30ff 	mov.w	r0, #4294967295
   30d9c:	e75d      	b.n	30c5a <gnss_interface_setopt+0x122>
   30d9e:	202a      	movs	r0, #42	; 0x2a
   30da0:	f7f6 fe5e 	bl	27a60 <bsd_os_errno_set>
   30da4:	f04f 30ff 	mov.w	r0, #4294967295
   30da8:	e757      	b.n	30c5a <gnss_interface_setopt+0x122>
   30daa:	2073      	movs	r0, #115	; 0x73
   30dac:	f7f6 fe58 	bl	27a60 <bsd_os_errno_set>
   30db0:	f04f 30ff 	mov.w	r0, #4294967295
   30db4:	e751      	b.n	30c5a <gnss_interface_setopt+0x122>
   30db6:	bf00      	nop
   30db8:	20020edc 	.word	0x20020edc
   30dbc:	49765443 	.word	0x49765443
   30dc0:	2002b050 	.word	0x2002b050
   30dc4:	2002229c 	.word	0x2002229c
   30dc8:	20020ee0 	.word	0x20020ee0

00030dcc <gnss_interface_getopt>:
   30dcc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   30dd0:	4c81      	ldr	r4, [pc, #516]	; (30fd8 <gnss_interface_getopt+0x20c>)
   30dd2:	b087      	sub	sp, #28
   30dd4:	6825      	ldr	r5, [r4, #0]
   30dd6:	4698      	mov	r8, r3
   30dd8:	b2ad      	uxth	r5, r5
   30dda:	2d02      	cmp	r5, #2
   30ddc:	9b10      	ldr	r3, [sp, #64]	; 0x40
   30dde:	f040 80dd 	bne.w	30f9c <gnss_interface_getopt+0x1d0>
   30de2:	6825      	ldr	r5, [r4, #0]
   30de4:	03ee      	lsls	r6, r5, #15
   30de6:	f100 80eb 	bmi.w	30fc0 <gnss_interface_getopt+0x1f4>
   30dea:	6825      	ldr	r5, [r4, #0]
   30dec:	01ed      	lsls	r5, r5, #7
   30dee:	f100 80ed 	bmi.w	30fcc <gnss_interface_getopt+0x200>
   30df2:	f5b1 7f01 	cmp.w	r1, #516	; 0x204
   30df6:	f040 80d7 	bne.w	30fa8 <gnss_interface_getopt+0x1dc>
   30dfa:	4978      	ldr	r1, [pc, #480]	; (30fdc <gnss_interface_getopt+0x210>)
   30dfc:	4288      	cmp	r0, r1
   30dfe:	f040 80d9 	bne.w	30fb4 <gnss_interface_getopt+0x1e8>
   30e02:	f1b8 0f00 	cmp.w	r8, #0
   30e06:	d00b      	beq.n	30e20 <gnss_interface_getopt+0x54>
   30e08:	b153      	cbz	r3, 30e20 <gnss_interface_getopt+0x54>
   30e0a:	1e57      	subs	r7, r2, #1
   30e0c:	2f05      	cmp	r7, #5
   30e0e:	d807      	bhi.n	30e20 <gnss_interface_getopt+0x54>
   30e10:	e8df f007 	tbb	[pc, r7]
   30e14:	0f030f0f 	.word	0x0f030f0f
   30e18:	0303      	.short	0x0303
   30e1a:	681b      	ldr	r3, [r3, #0]
   30e1c:	2b01      	cmp	r3, #1
   30e1e:	d00b      	beq.n	30e38 <gnss_interface_getopt+0x6c>
   30e20:	2016      	movs	r0, #22
   30e22:	f7f6 fe1d 	bl	27a60 <bsd_os_errno_set>
   30e26:	f04f 35ff 	mov.w	r5, #4294967295
   30e2a:	4628      	mov	r0, r5
   30e2c:	b007      	add	sp, #28
   30e2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   30e32:	681b      	ldr	r3, [r3, #0]
   30e34:	2b02      	cmp	r3, #2
   30e36:	d1f3      	bne.n	30e20 <gnss_interface_getopt+0x54>
   30e38:	6823      	ldr	r3, [r4, #0]
   30e3a:	2212      	movs	r2, #18
   30e3c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   30e40:	2100      	movs	r1, #0
   30e42:	a801      	add	r0, sp, #4
   30e44:	6023      	str	r3, [r4, #0]
   30e46:	f008 ffba 	bl	39dbe <memset>
   30e4a:	2112      	movs	r1, #18
   30e4c:	4668      	mov	r0, sp
   30e4e:	f000 fa93 	bl	31378 <rpc_gnss_client_request_alloc>
   30e52:	4605      	mov	r5, r0
   30e54:	9800      	ldr	r0, [sp, #0]
   30e56:	2d00      	cmp	r5, #0
   30e58:	f040 808a 	bne.w	30f70 <gnss_interface_getopt+0x1a4>
   30e5c:	2800      	cmp	r0, #0
   30e5e:	f000 808e 	beq.w	30f7e <gnss_interface_getopt+0x1b2>
   30e62:	f241 1602 	movw	r6, #4354	; 0x1102
   30e66:	f04f 0e49 	mov.w	lr, #73	; 0x49
   30e6a:	2212      	movs	r2, #18
   30e6c:	f04f 0976 	mov.w	r9, #118	; 0x76
   30e70:	f04f 0b43 	mov.w	fp, #67	; 0x43
   30e74:	f04f 0a54 	mov.w	sl, #84	; 0x54
   30e78:	f8df c168 	ldr.w	ip, [pc, #360]	; 30fe4 <gnss_interface_getopt+0x218>
   30e7c:	f880 e00f 	strb.w	lr, [r0, #15]
   30e80:	f8bc 3000 	ldrh.w	r3, [ip]
   30e84:	f880 900e 	strb.w	r9, [r0, #14]
   30e88:	3301      	adds	r3, #1
   30e8a:	b29b      	uxth	r3, r3
   30e8c:	ea46 4e03 	orr.w	lr, r6, r3, lsl #16
   30e90:	f8cd e004 	str.w	lr, [sp, #4]
   30e94:	7145      	strb	r5, [r0, #5]
   30e96:	7185      	strb	r5, [r0, #6]
   30e98:	71c5      	strb	r5, [r0, #7]
   30e9a:	7205      	strb	r5, [r0, #8]
   30e9c:	7245      	strb	r5, [r0, #9]
   30e9e:	7285      	strb	r5, [r0, #10]
   30ea0:	72c5      	strb	r5, [r0, #11]
   30ea2:	a901      	add	r1, sp, #4
   30ea4:	7102      	strb	r2, [r0, #4]
   30ea6:	f880 b00c 	strb.w	fp, [r0, #12]
   30eaa:	f880 a00d 	strb.w	sl, [r0, #13]
   30eae:	f8df 9138 	ldr.w	r9, [pc, #312]	; 30fe8 <gnss_interface_getopt+0x21c>
   30eb2:	6800      	ldr	r0, [r0, #0]
   30eb4:	f8ac 3000 	strh.w	r3, [ip]
   30eb8:	f008 ff61 	bl	39d7e <memcpy>
   30ebc:	4631      	mov	r1, r6
   30ebe:	9800      	ldr	r0, [sp, #0]
   30ec0:	f8c9 5000 	str.w	r5, [r9]
   30ec4:	f000 fa6c 	bl	313a0 <rpc_gnss_client_request_send>
   30ec8:	2800      	cmp	r0, #0
   30eca:	d15d      	bne.n	30f88 <gnss_interface_getopt+0x1bc>
   30ecc:	4e44      	ldr	r6, [pc, #272]	; (30fe0 <gnss_interface_getopt+0x214>)
   30ece:	4d43      	ldr	r5, [pc, #268]	; (30fdc <gnss_interface_getopt+0x210>)
   30ed0:	4631      	mov	r1, r6
   30ed2:	4628      	mov	r0, r5
   30ed4:	f7f6 fd30 	bl	27938 <bsd_os_timedwait>
   30ed8:	6823      	ldr	r3, [r4, #0]
   30eda:	01db      	lsls	r3, r3, #7
   30edc:	d4f8      	bmi.n	30ed0 <gnss_interface_getopt+0x104>
   30ede:	f8d9 0000 	ldr.w	r0, [r9]
   30ee2:	b1d8      	cbz	r0, 30f1c <gnss_interface_getopt+0x150>
   30ee4:	6825      	ldr	r5, [r4, #0]
   30ee6:	f015 7500 	ands.w	r5, r5, #33554432	; 0x2000000
   30eea:	d00f      	beq.n	30f0c <gnss_interface_getopt+0x140>
   30eec:	2f05      	cmp	r7, #5
   30eee:	d837      	bhi.n	30f60 <gnss_interface_getopt+0x194>
   30ef0:	e8df f007 	tbb	[pc, r7]
   30ef4:	2b26201a 	.word	0x2b26201a
   30ef8:	0331      	.short	0x0331
   30efa:	2500      	movs	r5, #0
   30efc:	7b43      	ldrb	r3, [r0, #13]
   30efe:	f888 3000 	strb.w	r3, [r8]
   30f02:	f000 fa6b 	bl	313dc <rpc_gnss_client_data_free>
   30f06:	2300      	movs	r3, #0
   30f08:	f8c9 3000 	str.w	r3, [r9]
   30f0c:	6823      	ldr	r3, [r4, #0]
   30f0e:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
   30f12:	6023      	str	r3, [r4, #0]
   30f14:	4628      	mov	r0, r5
   30f16:	b007      	add	sp, #28
   30f18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   30f1c:	6823      	ldr	r3, [r4, #0]
   30f1e:	4605      	mov	r5, r0
   30f20:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
   30f24:	6023      	str	r3, [r4, #0]
   30f26:	e7f5      	b.n	30f14 <gnss_interface_getopt+0x148>
   30f28:	f8b0 300f 	ldrh.w	r3, [r0, #15]
   30f2c:	2500      	movs	r5, #0
   30f2e:	f8a8 3000 	strh.w	r3, [r8]
   30f32:	e7e6      	b.n	30f02 <gnss_interface_getopt+0x136>
   30f34:	f8b0 3011 	ldrh.w	r3, [r0, #17]
   30f38:	2500      	movs	r5, #0
   30f3a:	f8a8 3000 	strh.w	r3, [r8]
   30f3e:	e7e0      	b.n	30f02 <gnss_interface_getopt+0x136>
   30f40:	7b83      	ldrb	r3, [r0, #14]
   30f42:	2500      	movs	r5, #0
   30f44:	f888 3000 	strb.w	r3, [r8]
   30f48:	e7db      	b.n	30f02 <gnss_interface_getopt+0x136>
   30f4a:	f8b0 3013 	ldrh.w	r3, [r0, #19]
   30f4e:	2500      	movs	r5, #0
   30f50:	f8a8 3000 	strh.w	r3, [r8]
   30f54:	e7d5      	b.n	30f02 <gnss_interface_getopt+0x136>
   30f56:	7b03      	ldrb	r3, [r0, #12]
   30f58:	2500      	movs	r5, #0
   30f5a:	f888 3000 	strb.w	r3, [r8]
   30f5e:	e7d0      	b.n	30f02 <gnss_interface_getopt+0x136>
   30f60:	2016      	movs	r0, #22
   30f62:	f7f6 fd7d 	bl	27a60 <bsd_os_errno_set>
   30f66:	f04f 35ff 	mov.w	r5, #4294967295
   30f6a:	f8d9 0000 	ldr.w	r0, [r9]
   30f6e:	e7c8      	b.n	30f02 <gnss_interface_getopt+0x136>
   30f70:	b128      	cbz	r0, 30f7e <gnss_interface_getopt+0x1b2>
   30f72:	6803      	ldr	r3, [r0, #0]
   30f74:	b11b      	cbz	r3, 30f7e <gnss_interface_getopt+0x1b2>
   30f76:	4618      	mov	r0, r3
   30f78:	f000 fa30 	bl	313dc <rpc_gnss_client_data_free>
   30f7c:	9800      	ldr	r0, [sp, #0]
   30f7e:	f000 fa25 	bl	313cc <rpc_gnss_client_message_free>
   30f82:	2023      	movs	r0, #35	; 0x23
   30f84:	f7f6 fd6c 	bl	27a60 <bsd_os_errno_set>
   30f88:	6823      	ldr	r3, [r4, #0]
   30f8a:	200e      	movs	r0, #14
   30f8c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   30f90:	6023      	str	r3, [r4, #0]
   30f92:	f04f 35ff 	mov.w	r5, #4294967295
   30f96:	f7f6 fd63 	bl	27a60 <bsd_os_errno_set>
   30f9a:	e746      	b.n	30e2a <gnss_interface_getopt+0x5e>
   30f9c:	200e      	movs	r0, #14
   30f9e:	f7f6 fd5f 	bl	27a60 <bsd_os_errno_set>
   30fa2:	f04f 35ff 	mov.w	r5, #4294967295
   30fa6:	e740      	b.n	30e2a <gnss_interface_getopt+0x5e>
   30fa8:	202a      	movs	r0, #42	; 0x2a
   30faa:	f7f6 fd59 	bl	27a60 <bsd_os_errno_set>
   30fae:	f04f 35ff 	mov.w	r5, #4294967295
   30fb2:	e73a      	b.n	30e2a <gnss_interface_getopt+0x5e>
   30fb4:	2009      	movs	r0, #9
   30fb6:	f7f6 fd53 	bl	27a60 <bsd_os_errno_set>
   30fba:	f04f 35ff 	mov.w	r5, #4294967295
   30fbe:	e734      	b.n	30e2a <gnss_interface_getopt+0x5e>
   30fc0:	2005      	movs	r0, #5
   30fc2:	f7f6 fd4d 	bl	27a60 <bsd_os_errno_set>
   30fc6:	f04f 35ff 	mov.w	r5, #4294967295
   30fca:	e72e      	b.n	30e2a <gnss_interface_getopt+0x5e>
   30fcc:	2073      	movs	r0, #115	; 0x73
   30fce:	f7f6 fd47 	bl	27a60 <bsd_os_errno_set>
   30fd2:	f04f 35ff 	mov.w	r5, #4294967295
   30fd6:	e728      	b.n	30e2a <gnss_interface_getopt+0x5e>
   30fd8:	20020edc 	.word	0x20020edc
   30fdc:	49765443 	.word	0x49765443
   30fe0:	2002b050 	.word	0x2002b050
   30fe4:	2002229c 	.word	0x2002229c
   30fe8:	20020ee0 	.word	0x20020ee0

00030fec <gnss_interface_init>:
   30fec:	2100      	movs	r1, #0
   30fee:	b538      	push	{r3, r4, r5, lr}
   30ff0:	4c09      	ldr	r4, [pc, #36]	; (31018 <gnss_interface_init+0x2c>)
   30ff2:	4d0a      	ldr	r5, [pc, #40]	; (3101c <gnss_interface_init+0x30>)
   30ff4:	6822      	ldr	r2, [r4, #0]
   30ff6:	480a      	ldr	r0, [pc, #40]	; (31020 <gnss_interface_init+0x34>)
   30ff8:	4b0a      	ldr	r3, [pc, #40]	; (31024 <gnss_interface_init+0x38>)
   30ffa:	402a      	ands	r2, r5
   30ffc:	6022      	str	r2, [r4, #0]
   30ffe:	8001      	strh	r1, [r0, #0]
   31000:	6019      	str	r1, [r3, #0]
   31002:	f000 f9b3 	bl	3136c <rpc_gnss_client_init>
   31006:	b928      	cbnz	r0, 31014 <gnss_interface_init+0x28>
   31008:	6823      	ldr	r3, [r4, #0]
   3100a:	402b      	ands	r3, r5
   3100c:	f043 0301 	orr.w	r3, r3, #1
   31010:	6023      	str	r3, [r4, #0]
   31012:	bd38      	pop	{r3, r4, r5, pc}
   31014:	2003      	movs	r0, #3
   31016:	bd38      	pop	{r3, r4, r5, pc}
   31018:	20020edc 	.word	0x20020edc
   3101c:	ffff0000 	.word	0xffff0000
   31020:	2002229c 	.word	0x2002229c
   31024:	20020ee0 	.word	0x20020ee0

00031028 <gnss_interface_open>:
   31028:	2902      	cmp	r1, #2
   3102a:	b510      	push	{r4, lr}
   3102c:	d121      	bne.n	31072 <gnss_interface_open+0x4a>
   3102e:	4c14      	ldr	r4, [pc, #80]	; (31080 <gnss_interface_open+0x58>)
   31030:	6823      	ldr	r3, [r4, #0]
   31032:	b29b      	uxth	r3, r3
   31034:	2b01      	cmp	r3, #1
   31036:	d116      	bne.n	31066 <gnss_interface_open+0x3e>
   31038:	6823      	ldr	r3, [r4, #0]
   3103a:	4608      	mov	r0, r1
   3103c:	0c1b      	lsrs	r3, r3, #16
   3103e:	041b      	lsls	r3, r3, #16
   31040:	f043 0302 	orr.w	r3, r3, #2
   31044:	2200      	movs	r2, #0
   31046:	490f      	ldr	r1, [pc, #60]	; (31084 <gnss_interface_open+0x5c>)
   31048:	6023      	str	r3, [r4, #0]
   3104a:	f000 faad 	bl	315a8 <packet_handler_create>
   3104e:	4a0e      	ldr	r2, [pc, #56]	; (31088 <gnss_interface_open+0x60>)
   31050:	6010      	str	r0, [r2, #0]
   31052:	b140      	cbz	r0, 31066 <gnss_interface_open+0x3e>
   31054:	6823      	ldr	r3, [r4, #0]
   31056:	6802      	ldr	r2, [r0, #0]
   31058:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   3105c:	6812      	ldr	r2, [r2, #0]
   3105e:	6023      	str	r3, [r4, #0]
   31060:	4790      	blx	r2
   31062:	480a      	ldr	r0, [pc, #40]	; (3108c <gnss_interface_open+0x64>)
   31064:	bd10      	pop	{r4, pc}
   31066:	200e      	movs	r0, #14
   31068:	f7f6 fcfa 	bl	27a60 <bsd_os_errno_set>
   3106c:	f04f 30ff 	mov.w	r0, #4294967295
   31070:	bd10      	pop	{r4, pc}
   31072:	2029      	movs	r0, #41	; 0x29
   31074:	f7f6 fcf4 	bl	27a60 <bsd_os_errno_set>
   31078:	f04f 30ff 	mov.w	r0, #4294967295
   3107c:	bd10      	pop	{r4, pc}
   3107e:	bf00      	nop
   31080:	20020edc 	.word	0x20020edc
   31084:	00030371 	.word	0x00030371
   31088:	20020ee4 	.word	0x20020ee4
   3108c:	49765443 	.word	0x49765443

00031090 <gnss_interface_close>:
   31090:	b530      	push	{r4, r5, lr}
   31092:	4b13      	ldr	r3, [pc, #76]	; (310e0 <gnss_interface_close+0x50>)
   31094:	b083      	sub	sp, #12
   31096:	4298      	cmp	r0, r3
   31098:	d11c      	bne.n	310d4 <gnss_interface_close+0x44>
   3109a:	4c12      	ldr	r4, [pc, #72]	; (310e4 <gnss_interface_close+0x54>)
   3109c:	6823      	ldr	r3, [r4, #0]
   3109e:	b29b      	uxth	r3, r3
   310a0:	2b04      	cmp	r3, #4
   310a2:	d00f      	beq.n	310c4 <gnss_interface_close+0x34>
   310a4:	4d10      	ldr	r5, [pc, #64]	; (310e8 <gnss_interface_close+0x58>)
   310a6:	6828      	ldr	r0, [r5, #0]
   310a8:	b118      	cbz	r0, 310b2 <gnss_interface_close+0x22>
   310aa:	f000 fa9d 	bl	315e8 <packet_handler_delete>
   310ae:	2300      	movs	r3, #0
   310b0:	602b      	str	r3, [r5, #0]
   310b2:	2000      	movs	r0, #0
   310b4:	6823      	ldr	r3, [r4, #0]
   310b6:	0c1b      	lsrs	r3, r3, #16
   310b8:	041b      	lsls	r3, r3, #16
   310ba:	f043 0301 	orr.w	r3, r3, #1
   310be:	6023      	str	r3, [r4, #0]
   310c0:	b003      	add	sp, #12
   310c2:	bd30      	pop	{r4, r5, pc}
   310c4:	2300      	movs	r3, #0
   310c6:	2208      	movs	r2, #8
   310c8:	9300      	str	r3, [sp, #0]
   310ca:	f44f 7101 	mov.w	r1, #516	; 0x204
   310ce:	f7fc fe31 	bl	2dd34 <nrf_setsockopt>
   310d2:	e7e7      	b.n	310a4 <gnss_interface_close+0x14>
   310d4:	2009      	movs	r0, #9
   310d6:	f7f6 fcc3 	bl	27a60 <bsd_os_errno_set>
   310da:	f04f 30ff 	mov.w	r0, #4294967295
   310de:	e7ef      	b.n	310c0 <gnss_interface_close+0x30>
   310e0:	49765443 	.word	0x49765443
   310e4:	20020edc 	.word	0x20020edc
   310e8:	20020ee4 	.word	0x20020ee4

000310ec <rpc_gnss_serialize_utc>:
   310ec:	4603      	mov	r3, r0
   310ee:	b1d8      	cbz	r0, 31128 <rpc_gnss_serialize_utc+0x3c>
   310f0:	b1d1      	cbz	r1, 31128 <rpc_gnss_serialize_utc+0x3c>
   310f2:	2000      	movs	r0, #0
   310f4:	2201      	movs	r2, #1
   310f6:	7048      	strb	r0, [r1, #1]
   310f8:	700a      	strb	r2, [r1, #0]
   310fa:	685a      	ldr	r2, [r3, #4]
   310fc:	2010      	movs	r0, #16
   310fe:	f8c1 2006 	str.w	r2, [r1, #6]
   31102:	681a      	ldr	r2, [r3, #0]
   31104:	f8c1 2002 	str.w	r2, [r1, #2]
   31108:	f993 200a 	ldrsb.w	r2, [r3, #10]
   3110c:	730a      	strb	r2, [r1, #12]
   3110e:	f993 200d 	ldrsb.w	r2, [r3, #13]
   31112:	73ca      	strb	r2, [r1, #15]
   31114:	f993 200c 	ldrsb.w	r2, [r3, #12]
   31118:	738a      	strb	r2, [r1, #14]
   3111a:	7a1a      	ldrb	r2, [r3, #8]
   3111c:	728a      	strb	r2, [r1, #10]
   3111e:	7ada      	ldrb	r2, [r3, #11]
   31120:	734a      	strb	r2, [r1, #13]
   31122:	7a5b      	ldrb	r3, [r3, #9]
   31124:	72cb      	strb	r3, [r1, #11]
   31126:	4770      	bx	lr
   31128:	f04f 30ff 	mov.w	r0, #4294967295
   3112c:	4770      	bx	lr
   3112e:	bf00      	nop

00031130 <rpc_gnss_serialize_ephe>:
   31130:	4603      	mov	r3, r0
   31132:	2800      	cmp	r0, #0
   31134:	d04b      	beq.n	311ce <rpc_gnss_serialize_ephe+0x9e>
   31136:	2900      	cmp	r1, #0
   31138:	d049      	beq.n	311ce <rpc_gnss_serialize_ephe+0x9e>
   3113a:	2000      	movs	r0, #0
   3113c:	2202      	movs	r2, #2
   3113e:	7048      	strb	r0, [r1, #1]
   31140:	700a      	strb	r2, [r1, #0]
   31142:	68da      	ldr	r2, [r3, #12]
   31144:	2040      	movs	r0, #64	; 0x40
   31146:	f8c1 200b 	str.w	r2, [r1, #11]
   3114a:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   3114e:	f8a1 2009 	strh.w	r2, [r1, #9]
   31152:	f993 2006 	ldrsb.w	r2, [r3, #6]
   31156:	720a      	strb	r2, [r1, #8]
   31158:	f9b3 2044 	ldrsh.w	r2, [r3, #68]	; 0x44
   3115c:	878a      	strh	r2, [r1, #60]	; 0x3c
   3115e:	f9b3 203e 	ldrsh.w	r2, [r3, #62]	; 0x3e
   31162:	86ca      	strh	r2, [r1, #54]	; 0x36
   31164:	f9b3 2042 	ldrsh.w	r2, [r3, #66]	; 0x42
   31168:	874a      	strh	r2, [r1, #58]	; 0x3a
   3116a:	f9b3 203c 	ldrsh.w	r2, [r3, #60]	; 0x3c
   3116e:	868a      	strh	r2, [r1, #52]	; 0x34
   31170:	f9b3 2046 	ldrsh.w	r2, [r3, #70]	; 0x46
   31174:	87ca      	strh	r2, [r1, #62]	; 0x3e
   31176:	f9b3 2040 	ldrsh.w	r2, [r3, #64]	; 0x40
   3117a:	870a      	strh	r2, [r1, #56]	; 0x38
   3117c:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
   31180:	830a      	strh	r2, [r1, #24]
   31182:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   31184:	f8c1 2022 	str.w	r2, [r1, #34]	; 0x22
   31188:	7c9a      	ldrb	r2, [r3, #18]
   3118a:	744a      	strb	r2, [r1, #17]
   3118c:	785a      	ldrb	r2, [r3, #1]
   3118e:	70ca      	strb	r2, [r1, #3]
   31190:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   31192:	62ca      	str	r2, [r1, #44]	; 0x2c
   31194:	f9b3 202c 	ldrsh.w	r2, [r3, #44]	; 0x2c
   31198:	84ca      	strh	r2, [r1, #38]	; 0x26
   3119a:	885a      	ldrh	r2, [r3, #2]
   3119c:	808a      	strh	r2, [r1, #4]
   3119e:	6a1a      	ldr	r2, [r3, #32]
   311a0:	f8c1 201a 	str.w	r2, [r1, #26]
   311a4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   311a6:	630a      	str	r2, [r1, #48]	; 0x30
   311a8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   311aa:	f8c1 201e 	str.w	r2, [r1, #30]
   311ae:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   311b0:	628a      	str	r2, [r1, #40]	; 0x28
   311b2:	781a      	ldrb	r2, [r3, #0]
   311b4:	708a      	strb	r2, [r1, #2]
   311b6:	f993 2010 	ldrsb.w	r2, [r3, #16]
   311ba:	73ca      	strb	r2, [r1, #15]
   311bc:	889a      	ldrh	r2, [r3, #4]
   311be:	80ca      	strh	r2, [r1, #6]
   311c0:	8a9a      	ldrh	r2, [r3, #20]
   311c2:	824a      	strh	r2, [r1, #18]
   311c4:	7c5a      	ldrb	r2, [r3, #17]
   311c6:	740a      	strb	r2, [r1, #16]
   311c8:	699b      	ldr	r3, [r3, #24]
   311ca:	614b      	str	r3, [r1, #20]
   311cc:	4770      	bx	lr
   311ce:	f04f 30ff 	mov.w	r0, #4294967295
   311d2:	4770      	bx	lr

000311d4 <rpc_gnss_serialize_alm>:
   311d4:	4603      	mov	r3, r0
   311d6:	b360      	cbz	r0, 31232 <rpc_gnss_serialize_alm+0x5e>
   311d8:	b359      	cbz	r1, 31232 <rpc_gnss_serialize_alm+0x5e>
   311da:	2000      	movs	r0, #0
   311dc:	2203      	movs	r2, #3
   311de:	7048      	strb	r0, [r1, #1]
   311e0:	700a      	strb	r2, [r1, #0]
   311e2:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
   311e6:	2021      	movs	r0, #33	; 0x21
   311e8:	f8a1 201d 	strh.w	r2, [r1, #29]
   311ec:	f9b3 201e 	ldrsh.w	r2, [r3, #30]
   311f0:	f8a1 201f 	strh.w	r2, [r1, #31]
   311f4:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
   311f8:	810a      	strh	r2, [r1, #8]
   311fa:	889a      	ldrh	r2, [r3, #4]
   311fc:	80ca      	strh	r2, [r1, #6]
   311fe:	78da      	ldrb	r2, [r3, #3]
   31200:	714a      	strb	r2, [r1, #5]
   31202:	699a      	ldr	r2, [r3, #24]
   31204:	f8c1 2019 	str.w	r2, [r1, #25]
   31208:	691a      	ldr	r2, [r3, #16]
   3120a:	f8c1 2011 	str.w	r2, [r1, #17]
   3120e:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   31212:	814a      	strh	r2, [r1, #10]
   31214:	68da      	ldr	r2, [r3, #12]
   31216:	f8c1 200d 	str.w	r2, [r1, #13]
   3121a:	7a9a      	ldrb	r2, [r3, #10]
   3121c:	730a      	strb	r2, [r1, #12]
   3121e:	781a      	ldrb	r2, [r3, #0]
   31220:	708a      	strb	r2, [r1, #2]
   31222:	789a      	ldrb	r2, [r3, #2]
   31224:	710a      	strb	r2, [r1, #4]
   31226:	695a      	ldr	r2, [r3, #20]
   31228:	f8c1 2015 	str.w	r2, [r1, #21]
   3122c:	785b      	ldrb	r3, [r3, #1]
   3122e:	70cb      	strb	r3, [r1, #3]
   31230:	4770      	bx	lr
   31232:	f04f 30ff 	mov.w	r0, #4294967295
   31236:	4770      	bx	lr

00031238 <rpc_gnss_serialize_klob>:
   31238:	4603      	mov	r3, r0
   3123a:	b1f0      	cbz	r0, 3127a <rpc_gnss_serialize_klob+0x42>
   3123c:	b1e9      	cbz	r1, 3127a <rpc_gnss_serialize_klob+0x42>
   3123e:	2000      	movs	r0, #0
   31240:	2204      	movs	r2, #4
   31242:	7048      	strb	r0, [r1, #1]
   31244:	700a      	strb	r2, [r1, #0]
   31246:	f993 2000 	ldrsb.w	r2, [r3]
   3124a:	200a      	movs	r0, #10
   3124c:	708a      	strb	r2, [r1, #2]
   3124e:	f993 2001 	ldrsb.w	r2, [r3, #1]
   31252:	70ca      	strb	r2, [r1, #3]
   31254:	f993 2002 	ldrsb.w	r2, [r3, #2]
   31258:	710a      	strb	r2, [r1, #4]
   3125a:	f993 2003 	ldrsb.w	r2, [r3, #3]
   3125e:	714a      	strb	r2, [r1, #5]
   31260:	f993 2004 	ldrsb.w	r2, [r3, #4]
   31264:	718a      	strb	r2, [r1, #6]
   31266:	f993 2005 	ldrsb.w	r2, [r3, #5]
   3126a:	71ca      	strb	r2, [r1, #7]
   3126c:	f993 2006 	ldrsb.w	r2, [r3, #6]
   31270:	720a      	strb	r2, [r1, #8]
   31272:	f993 3007 	ldrsb.w	r3, [r3, #7]
   31276:	724b      	strb	r3, [r1, #9]
   31278:	4770      	bx	lr
   3127a:	f04f 30ff 	mov.w	r0, #4294967295
   3127e:	4770      	bx	lr

00031280 <rpc_gnss_serialize_nequick>:
   31280:	4603      	mov	r3, r0
   31282:	b198      	cbz	r0, 312ac <rpc_gnss_serialize_nequick+0x2c>
   31284:	b191      	cbz	r1, 312ac <rpc_gnss_serialize_nequick+0x2c>
   31286:	2000      	movs	r0, #0
   31288:	2205      	movs	r2, #5
   3128a:	7048      	strb	r0, [r1, #1]
   3128c:	700a      	strb	r2, [r1, #0]
   3128e:	f9b3 2000 	ldrsh.w	r2, [r3]
   31292:	200a      	movs	r0, #10
   31294:	804a      	strh	r2, [r1, #2]
   31296:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
   3129a:	808a      	strh	r2, [r1, #4]
   3129c:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
   312a0:	80ca      	strh	r2, [r1, #6]
   312a2:	799a      	ldrb	r2, [r3, #6]
   312a4:	720a      	strb	r2, [r1, #8]
   312a6:	79db      	ldrb	r3, [r3, #7]
   312a8:	724b      	strb	r3, [r1, #9]
   312aa:	4770      	bx	lr
   312ac:	f04f 30ff 	mov.w	r0, #4294967295
   312b0:	4770      	bx	lr
   312b2:	bf00      	nop

000312b4 <rpc_gnss_serialize_time_and_sv_tow>:
   312b4:	b310      	cbz	r0, 312fc <rpc_gnss_serialize_time_and_sv_tow+0x48>
   312b6:	b309      	cbz	r1, 312fc <rpc_gnss_serialize_time_and_sv_tow+0x48>
   312b8:	b470      	push	{r4, r5, r6}
   312ba:	2500      	movs	r5, #0
   312bc:	2606      	movs	r6, #6
   312be:	460c      	mov	r4, r1
   312c0:	704d      	strb	r5, [r1, #1]
   312c2:	700e      	strb	r6, [r1, #0]
   312c4:	462b      	mov	r3, r5
   312c6:	8805      	ldrh	r5, [r0, #0]
   312c8:	4602      	mov	r2, r0
   312ca:	804d      	strh	r5, [r1, #2]
   312cc:	68c5      	ldr	r5, [r0, #12]
   312ce:	f8c1 500a 	str.w	r5, [r1, #10]
   312d2:	8905      	ldrh	r5, [r0, #8]
   312d4:	810d      	strh	r5, [r1, #8]
   312d6:	6840      	ldr	r0, [r0, #4]
   312d8:	6048      	str	r0, [r1, #4]
   312da:	8a15      	ldrh	r5, [r2, #16]
   312dc:	eb03 0043 	add.w	r0, r3, r3, lsl #1
   312e0:	4408      	add	r0, r1
   312e2:	81c5      	strh	r5, [r0, #14]
   312e4:	7c90      	ldrb	r0, [r2, #18]
   312e6:	3301      	adds	r3, #1
   312e8:	2b20      	cmp	r3, #32
   312ea:	7420      	strb	r0, [r4, #16]
   312ec:	f102 0204 	add.w	r2, r2, #4
   312f0:	f104 0403 	add.w	r4, r4, #3
   312f4:	d1f1      	bne.n	312da <rpc_gnss_serialize_time_and_sv_tow+0x26>
   312f6:	206e      	movs	r0, #110	; 0x6e
   312f8:	bc70      	pop	{r4, r5, r6}
   312fa:	4770      	bx	lr
   312fc:	f04f 30ff 	mov.w	r0, #4294967295
   31300:	4770      	bx	lr
   31302:	bf00      	nop

00031304 <rpc_gnss_serialize_location>:
   31304:	4603      	mov	r3, r0
   31306:	b1c8      	cbz	r0, 3133c <rpc_gnss_serialize_location+0x38>
   31308:	b1c1      	cbz	r1, 3133c <rpc_gnss_serialize_location+0x38>
   3130a:	2000      	movs	r0, #0
   3130c:	2207      	movs	r2, #7
   3130e:	7048      	strb	r0, [r1, #1]
   31310:	700a      	strb	r2, [r1, #0]
   31312:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   31316:	2011      	movs	r0, #17
   31318:	814a      	strh	r2, [r1, #10]
   3131a:	7b9a      	ldrb	r2, [r3, #14]
   3131c:	740a      	strb	r2, [r1, #16]
   3131e:	681a      	ldr	r2, [r3, #0]
   31320:	f8c1 2002 	str.w	r2, [r1, #2]
   31324:	685a      	ldr	r2, [r3, #4]
   31326:	f8c1 2006 	str.w	r2, [r1, #6]
   3132a:	7b1a      	ldrb	r2, [r3, #12]
   3132c:	738a      	strb	r2, [r1, #14]
   3132e:	7b5a      	ldrb	r2, [r3, #13]
   31330:	73ca      	strb	r2, [r1, #15]
   31332:	7a9a      	ldrb	r2, [r3, #10]
   31334:	730a      	strb	r2, [r1, #12]
   31336:	7adb      	ldrb	r3, [r3, #11]
   31338:	734b      	strb	r3, [r1, #13]
   3133a:	4770      	bx	lr
   3133c:	f04f 30ff 	mov.w	r0, #4294967295
   31340:	4770      	bx	lr
   31342:	bf00      	nop

00031344 <rpc_gnss_serialize_integrity>:
   31344:	b148      	cbz	r0, 3135a <rpc_gnss_serialize_integrity+0x16>
   31346:	b141      	cbz	r1, 3135a <rpc_gnss_serialize_integrity+0x16>
   31348:	2200      	movs	r2, #0
   3134a:	2308      	movs	r3, #8
   3134c:	704a      	strb	r2, [r1, #1]
   3134e:	700b      	strb	r3, [r1, #0]
   31350:	6803      	ldr	r3, [r0, #0]
   31352:	2006      	movs	r0, #6
   31354:	f8c1 3002 	str.w	r3, [r1, #2]
   31358:	4770      	bx	lr
   3135a:	f04f 30ff 	mov.w	r0, #4294967295
   3135e:	4770      	bx	lr

00031360 <gnss_client_event_handler>:
   31360:	f850 1b08 	ldr.w	r1, [r0], #8
   31364:	0c09      	lsrs	r1, r1, #16
   31366:	f7ff b811 	b.w	3038c <rpc_gnss_event_handler>
   3136a:	bf00      	nop

0003136c <rpc_gnss_client_init>:
   3136c:	4801      	ldr	r0, [pc, #4]	; (31374 <rpc_gnss_client_init+0x8>)
   3136e:	f7fe bb73 	b.w	2fa58 <rpc_client_register>
   31372:	bf00      	nop
   31374:	0003b7dc 	.word	0x0003b7dc

00031378 <rpc_gnss_client_request_alloc>:
   31378:	2300      	movs	r3, #0
   3137a:	b510      	push	{r4, lr}
   3137c:	b082      	sub	sp, #8
   3137e:	9301      	str	r3, [sp, #4]
   31380:	b158      	cbz	r0, 3139a <rpc_gnss_client_request_alloc+0x22>
   31382:	4604      	mov	r4, r0
   31384:	aa01      	add	r2, sp, #4
   31386:	2007      	movs	r0, #7
   31388:	f7fe fd9e 	bl	2fec8 <rpc_message_alloc>
   3138c:	b918      	cbnz	r0, 31396 <rpc_gnss_client_request_alloc+0x1e>
   3138e:	9b01      	ldr	r3, [sp, #4]
   31390:	b10b      	cbz	r3, 31396 <rpc_gnss_client_request_alloc+0x1e>
   31392:	3308      	adds	r3, #8
   31394:	6023      	str	r3, [r4, #0]
   31396:	b002      	add	sp, #8
   31398:	bd10      	pop	{r4, pc}
   3139a:	2007      	movs	r0, #7
   3139c:	b002      	add	sp, #8
   3139e:	bd10      	pop	{r4, pc}

000313a0 <rpc_gnss_client_request_send>:
   313a0:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   313a4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   313a8:	d10b      	bne.n	313c2 <rpc_gnss_client_request_send+0x22>
   313aa:	b160      	cbz	r0, 313c6 <rpc_gnss_client_request_send+0x26>
   313ac:	4603      	mov	r3, r0
   313ae:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   313b2:	2007      	movs	r0, #7
   313b4:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   313b8:	f843 1d08 	str.w	r1, [r3, #-8]!
   313bc:	4619      	mov	r1, r3
   313be:	f7fe bd6b 	b.w	2fe98 <rpc_message_send>
   313c2:	200f      	movs	r0, #15
   313c4:	4770      	bx	lr
   313c6:	2007      	movs	r0, #7
   313c8:	4770      	bx	lr
   313ca:	bf00      	nop

000313cc <rpc_gnss_client_message_free>:
   313cc:	b120      	cbz	r0, 313d8 <rpc_gnss_client_message_free+0xc>
   313ce:	f1a0 0108 	sub.w	r1, r0, #8
   313d2:	2007      	movs	r0, #7
   313d4:	f7fe bdaa 	b.w	2ff2c <rpc_message_free>
   313d8:	2007      	movs	r0, #7
   313da:	4770      	bx	lr

000313dc <rpc_gnss_client_data_free>:
   313dc:	b118      	cbz	r0, 313e6 <rpc_gnss_client_data_free+0xa>
   313de:	4601      	mov	r1, r0
   313e0:	2007      	movs	r0, #7
   313e2:	f7fe beb5 	b.w	30150 <rpc_message_data_free>
   313e6:	2007      	movs	r0, #7
   313e8:	4770      	bx	lr
   313ea:	bf00      	nop

000313ec <datagram_handler_init>:
   313ec:	b510      	push	{r4, lr}
   313ee:	4604      	mov	r4, r0
   313f0:	200c      	movs	r0, #12
   313f2:	f7f9 f8d9 	bl	2a5a8 <nrf_malloc>
   313f6:	60e0      	str	r0, [r4, #12]
   313f8:	b118      	cbz	r0, 31402 <datagram_handler_init+0x16>
   313fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   313fe:	f7fc bb8f 	b.w	2db20 <linked_list_init>
   31402:	2004      	movs	r0, #4
   31404:	bd10      	pop	{r4, pc}
   31406:	bf00      	nop

00031408 <datagram_handler_put>:
   31408:	b570      	push	{r4, r5, r6, lr}
   3140a:	4606      	mov	r6, r0
   3140c:	2014      	movs	r0, #20
   3140e:	460d      	mov	r5, r1
   31410:	f7f9 f8ca 	bl	2a5a8 <nrf_malloc>
   31414:	b178      	cbz	r0, 31436 <datagram_handler_put+0x2e>
   31416:	682b      	ldr	r3, [r5, #0]
   31418:	4604      	mov	r4, r0
   3141a:	6043      	str	r3, [r0, #4]
   3141c:	686b      	ldr	r3, [r5, #4]
   3141e:	4601      	mov	r1, r0
   31420:	6083      	str	r3, [r0, #8]
   31422:	68eb      	ldr	r3, [r5, #12]
   31424:	60c3      	str	r3, [r0, #12]
   31426:	68ab      	ldr	r3, [r5, #8]
   31428:	6103      	str	r3, [r0, #16]
   3142a:	68f0      	ldr	r0, [r6, #12]
   3142c:	f7fc fb82 	bl	2db34 <linked_list_push>
   31430:	b920      	cbnz	r0, 3143c <datagram_handler_put+0x34>
   31432:	6868      	ldr	r0, [r5, #4]
   31434:	bd70      	pop	{r4, r5, r6, pc}
   31436:	f04f 30ff 	mov.w	r0, #4294967295
   3143a:	bd70      	pop	{r4, r5, r6, pc}
   3143c:	4620      	mov	r0, r4
   3143e:	f7f9 f8bd 	bl	2a5bc <nrf_free>
   31442:	f04f 30ff 	mov.w	r0, #4294967295
   31446:	bd70      	pop	{r4, r5, r6, pc}

00031448 <datagram_handler_get>:
   31448:	b5f0      	push	{r4, r5, r6, r7, lr}
   3144a:	4606      	mov	r6, r0
   3144c:	b085      	sub	sp, #20
   3144e:	68c0      	ldr	r0, [r0, #12]
   31450:	460c      	mov	r4, r1
   31452:	4617      	mov	r7, r2
   31454:	f7fc fb8e 	bl	2db74 <linked_list_peek>
   31458:	2800      	cmp	r0, #0
   3145a:	d037      	beq.n	314cc <datagram_handler_get+0x84>
   3145c:	6882      	ldr	r2, [r0, #8]
   3145e:	4605      	mov	r5, r0
   31460:	e9d4 0300 	ldrd	r0, r3, [r4]
   31464:	429a      	cmp	r2, r3
   31466:	bf28      	it	cs
   31468:	461a      	movcs	r2, r3
   3146a:	6062      	str	r2, [r4, #4]
   3146c:	b110      	cbz	r0, 31474 <datagram_handler_get+0x2c>
   3146e:	6869      	ldr	r1, [r5, #4]
   31470:	f008 fc85 	bl	39d7e <memcpy>
   31474:	68a0      	ldr	r0, [r4, #8]
   31476:	b118      	cbz	r0, 31480 <datagram_handler_get+0x38>
   31478:	692b      	ldr	r3, [r5, #16]
   3147a:	b10b      	cbz	r3, 31480 <datagram_handler_get+0x38>
   3147c:	68ea      	ldr	r2, [r5, #12]
   3147e:	b9e2      	cbnz	r2, 314ba <datagram_handler_get+0x72>
   31480:	2300      	movs	r3, #0
   31482:	60e3      	str	r3, [r4, #12]
   31484:	073b      	lsls	r3, r7, #28
   31486:	d502      	bpl.n	3148e <datagram_handler_get+0x46>
   31488:	6860      	ldr	r0, [r4, #4]
   3148a:	b005      	add	sp, #20
   3148c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   3148e:	68f0      	ldr	r0, [r6, #12]
   31490:	f7fc fb66 	bl	2db60 <linked_list_pop>
   31494:	4605      	mov	r5, r0
   31496:	2800      	cmp	r0, #0
   31498:	d0f6      	beq.n	31488 <datagram_handler_get+0x40>
   3149a:	e9d0 3101 	ldrd	r3, r1, [r0, #4]
   3149e:	6902      	ldr	r2, [r0, #16]
   314a0:	9300      	str	r3, [sp, #0]
   314a2:	68c3      	ldr	r3, [r0, #12]
   314a4:	e9cd 1201 	strd	r1, r2, [sp, #4]
   314a8:	9303      	str	r3, [sp, #12]
   314aa:	4668      	mov	r0, sp
   314ac:	e9d6 3101 	ldrd	r3, r1, [r6, #4]
   314b0:	4798      	blx	r3
   314b2:	4628      	mov	r0, r5
   314b4:	f7f9 f882 	bl	2a5bc <nrf_free>
   314b8:	e7e6      	b.n	31488 <datagram_handler_get+0x40>
   314ba:	68e3      	ldr	r3, [r4, #12]
   314bc:	429a      	cmp	r2, r3
   314be:	bf28      	it	cs
   314c0:	461a      	movcs	r2, r3
   314c2:	60e2      	str	r2, [r4, #12]
   314c4:	6929      	ldr	r1, [r5, #16]
   314c6:	f008 fc5a 	bl	39d7e <memcpy>
   314ca:	e7db      	b.n	31484 <datagram_handler_get+0x3c>
   314cc:	f04f 30ff 	mov.w	r0, #4294967295
   314d0:	e7db      	b.n	3148a <datagram_handler_get+0x42>
   314d2:	bf00      	nop

000314d4 <datagram_handler_available>:
   314d4:	b508      	push	{r3, lr}
   314d6:	68c0      	ldr	r0, [r0, #12]
   314d8:	f7fc fb4c 	bl	2db74 <linked_list_peek>
   314dc:	b108      	cbz	r0, 314e2 <datagram_handler_available+0xe>
   314de:	6880      	ldr	r0, [r0, #8]
   314e0:	bd08      	pop	{r3, pc}
   314e2:	f04f 30ff 	mov.w	r0, #4294967295
   314e6:	bd08      	pop	{r3, pc}

000314e8 <datagram_handler_flush>:
   314e8:	b530      	push	{r4, r5, lr}
   314ea:	4605      	mov	r5, r0
   314ec:	68c0      	ldr	r0, [r0, #12]
   314ee:	b085      	sub	sp, #20
   314f0:	b9a8      	cbnz	r0, 3151e <datagram_handler_flush+0x36>
   314f2:	e01a      	b.n	3152a <datagram_handler_flush+0x42>
   314f4:	68e8      	ldr	r0, [r5, #12]
   314f6:	f7fc fb33 	bl	2db60 <linked_list_pop>
   314fa:	4604      	mov	r4, r0
   314fc:	b170      	cbz	r0, 3151c <datagram_handler_flush+0x34>
   314fe:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   31502:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   31506:	e9cd 0100 	strd	r0, r1, [sp]
   3150a:	e9cd 2302 	strd	r2, r3, [sp, #8]
   3150e:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   31512:	4668      	mov	r0, sp
   31514:	4798      	blx	r3
   31516:	4620      	mov	r0, r4
   31518:	f7f9 f850 	bl	2a5bc <nrf_free>
   3151c:	68e8      	ldr	r0, [r5, #12]
   3151e:	f7fc fb2f 	bl	2db80 <linked_list_size_get>
   31522:	2800      	cmp	r0, #0
   31524:	d1e6      	bne.n	314f4 <datagram_handler_flush+0xc>
   31526:	b005      	add	sp, #20
   31528:	bd30      	pop	{r4, r5, pc}
   3152a:	2008      	movs	r0, #8
   3152c:	b005      	add	sp, #20
   3152e:	bd30      	pop	{r4, r5, pc}

00031530 <datagram_handler_free>:
   31530:	b530      	push	{r4, r5, lr}
   31532:	4605      	mov	r5, r0
   31534:	68c0      	ldr	r0, [r0, #12]
   31536:	b085      	sub	sp, #20
   31538:	b9a0      	cbnz	r0, 31564 <datagram_handler_free+0x34>
   3153a:	e01c      	b.n	31576 <datagram_handler_free+0x46>
   3153c:	f7fc fb10 	bl	2db60 <linked_list_pop>
   31540:	4604      	mov	r4, r0
   31542:	b170      	cbz	r0, 31562 <datagram_handler_free+0x32>
   31544:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   31548:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   3154c:	e9cd 0100 	strd	r0, r1, [sp]
   31550:	e9cd 2302 	strd	r2, r3, [sp, #8]
   31554:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   31558:	4668      	mov	r0, sp
   3155a:	4798      	blx	r3
   3155c:	4620      	mov	r0, r4
   3155e:	f7f9 f82d 	bl	2a5bc <nrf_free>
   31562:	68e8      	ldr	r0, [r5, #12]
   31564:	f7fc fb0c 	bl	2db80 <linked_list_size_get>
   31568:	4604      	mov	r4, r0
   3156a:	68e8      	ldr	r0, [r5, #12]
   3156c:	2c00      	cmp	r4, #0
   3156e:	d1e5      	bne.n	3153c <datagram_handler_free+0xc>
   31570:	f7f9 f824 	bl	2a5bc <nrf_free>
   31574:	60ec      	str	r4, [r5, #12]
   31576:	b005      	add	sp, #20
   31578:	bd30      	pop	{r4, r5, pc}
   3157a:	bf00      	nop

0003157c <null_handler_init>:
   3157c:	2000      	movs	r0, #0
   3157e:	4770      	bx	lr

00031580 <null_handler_put>:
   31580:	b510      	push	{r4, lr}
   31582:	460c      	mov	r4, r1
   31584:	e9d0 3101 	ldrd	r3, r1, [r0, #4]
   31588:	4620      	mov	r0, r4
   3158a:	4798      	blx	r3
   3158c:	6860      	ldr	r0, [r4, #4]
   3158e:	bd10      	pop	{r4, pc}

00031590 <null_handler_get>:
   31590:	f04f 30ff 	mov.w	r0, #4294967295
   31594:	4770      	bx	lr
   31596:	bf00      	nop

00031598 <null_handler_available>:
   31598:	f04f 30ff 	mov.w	r0, #4294967295
   3159c:	4770      	bx	lr
   3159e:	bf00      	nop

000315a0 <null_handler_flush>:
   315a0:	2000      	movs	r0, #0
   315a2:	4770      	bx	lr

000315a4 <null_handler_free>:
   315a4:	4770      	bx	lr
   315a6:	bf00      	nop

000315a8 <packet_handler_create>:
   315a8:	2801      	cmp	r0, #1
   315aa:	b538      	push	{r3, r4, r5, lr}
   315ac:	460d      	mov	r5, r1
   315ae:	4614      	mov	r4, r2
   315b0:	d00d      	beq.n	315ce <packet_handler_create+0x26>
   315b2:	db11      	blt.n	315d8 <packet_handler_create+0x30>
   315b4:	2803      	cmp	r0, #3
   315b6:	dc0f      	bgt.n	315d8 <packet_handler_create+0x30>
   315b8:	2010      	movs	r0, #16
   315ba:	f7f8 fff5 	bl	2a5a8 <nrf_malloc>
   315be:	2218      	movs	r2, #24
   315c0:	b120      	cbz	r0, 315cc <packet_handler_create+0x24>
   315c2:	4b08      	ldr	r3, [pc, #32]	; (315e4 <packet_handler_create+0x3c>)
   315c4:	6045      	str	r5, [r0, #4]
   315c6:	4413      	add	r3, r2
   315c8:	6084      	str	r4, [r0, #8]
   315ca:	6003      	str	r3, [r0, #0]
   315cc:	bd38      	pop	{r3, r4, r5, pc}
   315ce:	2014      	movs	r0, #20
   315d0:	f7f8 ffea 	bl	2a5a8 <nrf_malloc>
   315d4:	2230      	movs	r2, #48	; 0x30
   315d6:	e7f3      	b.n	315c0 <packet_handler_create+0x18>
   315d8:	200c      	movs	r0, #12
   315da:	f7f8 ffe5 	bl	2a5a8 <nrf_malloc>
   315de:	2200      	movs	r2, #0
   315e0:	e7ee      	b.n	315c0 <packet_handler_create+0x18>
   315e2:	bf00      	nop
   315e4:	0003b7ec 	.word	0x0003b7ec

000315e8 <packet_handler_delete>:
   315e8:	b510      	push	{r4, lr}
   315ea:	4604      	mov	r4, r0
   315ec:	6803      	ldr	r3, [r0, #0]
   315ee:	691b      	ldr	r3, [r3, #16]
   315f0:	4798      	blx	r3
   315f2:	6823      	ldr	r3, [r4, #0]
   315f4:	4620      	mov	r0, r4
   315f6:	695b      	ldr	r3, [r3, #20]
   315f8:	4798      	blx	r3
   315fa:	4620      	mov	r0, r4
   315fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   31600:	f7f8 bfdc 	b.w	2a5bc <nrf_free>

00031604 <stream_handler_init>:
   31604:	b510      	push	{r4, lr}
   31606:	4604      	mov	r4, r0
   31608:	200c      	movs	r0, #12
   3160a:	f7f8 ffcd 	bl	2a5a8 <nrf_malloc>
   3160e:	60e0      	str	r0, [r4, #12]
   31610:	b128      	cbz	r0, 3161e <stream_handler_init+0x1a>
   31612:	2300      	movs	r3, #0
   31614:	6123      	str	r3, [r4, #16]
   31616:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   3161a:	f7fc ba81 	b.w	2db20 <linked_list_init>
   3161e:	2004      	movs	r0, #4
   31620:	bd10      	pop	{r4, pc}
   31622:	bf00      	nop

00031624 <stream_handler_put>:
   31624:	b570      	push	{r4, r5, r6, lr}
   31626:	4606      	mov	r6, r0
   31628:	2014      	movs	r0, #20
   3162a:	460d      	mov	r5, r1
   3162c:	f7f8 ffbc 	bl	2a5a8 <nrf_malloc>
   31630:	b178      	cbz	r0, 31652 <stream_handler_put+0x2e>
   31632:	682b      	ldr	r3, [r5, #0]
   31634:	4604      	mov	r4, r0
   31636:	6043      	str	r3, [r0, #4]
   31638:	686b      	ldr	r3, [r5, #4]
   3163a:	4601      	mov	r1, r0
   3163c:	6083      	str	r3, [r0, #8]
   3163e:	68eb      	ldr	r3, [r5, #12]
   31640:	60c3      	str	r3, [r0, #12]
   31642:	68ab      	ldr	r3, [r5, #8]
   31644:	6103      	str	r3, [r0, #16]
   31646:	68f0      	ldr	r0, [r6, #12]
   31648:	f7fc fa74 	bl	2db34 <linked_list_push>
   3164c:	b920      	cbnz	r0, 31658 <stream_handler_put+0x34>
   3164e:	6868      	ldr	r0, [r5, #4]
   31650:	bd70      	pop	{r4, r5, r6, pc}
   31652:	f04f 30ff 	mov.w	r0, #4294967295
   31656:	bd70      	pop	{r4, r5, r6, pc}
   31658:	4620      	mov	r0, r4
   3165a:	f7f8 ffaf 	bl	2a5bc <nrf_free>
   3165e:	f04f 30ff 	mov.w	r0, #4294967295
   31662:	bd70      	pop	{r4, r5, r6, pc}

00031664 <stream_handler_get>:
   31664:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   31668:	4682      	mov	sl, r0
   3166a:	b087      	sub	sp, #28
   3166c:	68c0      	ldr	r0, [r0, #12]
   3166e:	4689      	mov	r9, r1
   31670:	4693      	mov	fp, r2
   31672:	f7fc fa7f 	bl	2db74 <linked_list_peek>
   31676:	2800      	cmp	r0, #0
   31678:	d072      	beq.n	31760 <stream_handler_get+0xfc>
   3167a:	4605      	mov	r5, r0
   3167c:	f8d9 0008 	ldr.w	r0, [r9, #8]
   31680:	b120      	cbz	r0, 3168c <stream_handler_get+0x28>
   31682:	692b      	ldr	r3, [r5, #16]
   31684:	b113      	cbz	r3, 3168c <stream_handler_get+0x28>
   31686:	68ea      	ldr	r2, [r5, #12]
   31688:	2a00      	cmp	r2, #0
   3168a:	d15c      	bne.n	31746 <stream_handler_get+0xe2>
   3168c:	2300      	movs	r3, #0
   3168e:	f8c9 300c 	str.w	r3, [r9, #12]
   31692:	f8d9 2000 	ldr.w	r2, [r9]
   31696:	f8d9 8004 	ldr.w	r8, [r9, #4]
   3169a:	f8da 1010 	ldr.w	r1, [sl, #16]
   3169e:	9201      	str	r2, [sp, #4]
   316a0:	f1b8 0f00 	cmp.w	r8, #0
   316a4:	d05a      	beq.n	3175c <stream_handler_get+0xf8>
   316a6:	f00b 0308 	and.w	r3, fp, #8
   316aa:	2400      	movs	r4, #0
   316ac:	9300      	str	r3, [sp, #0]
   316ae:	e010      	b.n	316d2 <stream_handler_get+0x6e>
   316b0:	f8da 3010 	ldr.w	r3, [sl, #16]
   316b4:	443b      	add	r3, r7
   316b6:	f8ca 3010 	str.w	r3, [sl, #16]
   316ba:	4628      	mov	r0, r5
   316bc:	f7fc fa62 	bl	2db84 <linked_list_get_next>
   316c0:	443c      	add	r4, r7
   316c2:	4605      	mov	r5, r0
   316c4:	2800      	cmp	r0, #0
   316c6:	d038      	beq.n	3173a <stream_handler_get+0xd6>
   316c8:	45a0      	cmp	r8, r4
   316ca:	d936      	bls.n	3173a <stream_handler_get+0xd6>
   316cc:	2100      	movs	r1, #0
   316ce:	f8d9 2000 	ldr.w	r2, [r9]
   316d2:	68ae      	ldr	r6, [r5, #8]
   316d4:	eba8 0b04 	sub.w	fp, r8, r4
   316d8:	1a76      	subs	r6, r6, r1
   316da:	455e      	cmp	r6, fp
   316dc:	4637      	mov	r7, r6
   316de:	bf28      	it	cs
   316e0:	465f      	movcs	r7, fp
   316e2:	b132      	cbz	r2, 316f2 <stream_handler_get+0x8e>
   316e4:	6868      	ldr	r0, [r5, #4]
   316e6:	9b01      	ldr	r3, [sp, #4]
   316e8:	4401      	add	r1, r0
   316ea:	463a      	mov	r2, r7
   316ec:	1918      	adds	r0, r3, r4
   316ee:	f008 fb46 	bl	39d7e <memcpy>
   316f2:	9b00      	ldr	r3, [sp, #0]
   316f4:	2b00      	cmp	r3, #0
   316f6:	d1e0      	bne.n	316ba <stream_handler_get+0x56>
   316f8:	455e      	cmp	r6, fp
   316fa:	d8d9      	bhi.n	316b0 <stream_handler_get+0x4c>
   316fc:	f8da 000c 	ldr.w	r0, [sl, #12]
   31700:	f7fc fa2e 	bl	2db60 <linked_list_pop>
   31704:	4606      	mov	r6, r0
   31706:	b170      	cbz	r0, 31726 <stream_handler_get+0xc2>
   31708:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
   3170c:	e9d0 0103 	ldrd	r0, r1, [r0, #12]
   31710:	e9cd 2302 	strd	r2, r3, [sp, #8]
   31714:	e9cd 1004 	strd	r1, r0, [sp, #16]
   31718:	e9da 3101 	ldrd	r3, r1, [sl, #4]
   3171c:	a802      	add	r0, sp, #8
   3171e:	4798      	blx	r3
   31720:	4630      	mov	r0, r6
   31722:	f7f8 ff4b 	bl	2a5bc <nrf_free>
   31726:	2300      	movs	r3, #0
   31728:	4628      	mov	r0, r5
   3172a:	f8ca 3010 	str.w	r3, [sl, #16]
   3172e:	f7fc fa29 	bl	2db84 <linked_list_get_next>
   31732:	443c      	add	r4, r7
   31734:	4605      	mov	r5, r0
   31736:	2800      	cmp	r0, #0
   31738:	d1c6      	bne.n	316c8 <stream_handler_get+0x64>
   3173a:	4620      	mov	r0, r4
   3173c:	f8c9 4004 	str.w	r4, [r9, #4]
   31740:	b007      	add	sp, #28
   31742:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   31746:	f8d9 300c 	ldr.w	r3, [r9, #12]
   3174a:	429a      	cmp	r2, r3
   3174c:	bf28      	it	cs
   3174e:	461a      	movcs	r2, r3
   31750:	f8c9 200c 	str.w	r2, [r9, #12]
   31754:	6929      	ldr	r1, [r5, #16]
   31756:	f008 fb12 	bl	39d7e <memcpy>
   3175a:	e79a      	b.n	31692 <stream_handler_get+0x2e>
   3175c:	4644      	mov	r4, r8
   3175e:	e7ec      	b.n	3173a <stream_handler_get+0xd6>
   31760:	f04f 30ff 	mov.w	r0, #4294967295
   31764:	e7ec      	b.n	31740 <stream_handler_get+0xdc>
   31766:	bf00      	nop

00031768 <stream_handler_available>:
   31768:	b510      	push	{r4, lr}
   3176a:	4604      	mov	r4, r0
   3176c:	68c0      	ldr	r0, [r0, #12]
   3176e:	f7fc fa01 	bl	2db74 <linked_list_peek>
   31772:	b150      	cbz	r0, 3178a <stream_handler_available+0x22>
   31774:	6924      	ldr	r4, [r4, #16]
   31776:	4264      	negs	r4, r4
   31778:	6883      	ldr	r3, [r0, #8]
   3177a:	441c      	add	r4, r3
   3177c:	f7fc fa02 	bl	2db84 <linked_list_get_next>
   31780:	2800      	cmp	r0, #0
   31782:	d1f9      	bne.n	31778 <stream_handler_available+0x10>
   31784:	ea24 70e4 	bic.w	r0, r4, r4, asr #31
   31788:	bd10      	pop	{r4, pc}
   3178a:	f04f 30ff 	mov.w	r0, #4294967295
   3178e:	bd10      	pop	{r4, pc}

00031790 <stream_handler_flush>:
   31790:	b530      	push	{r4, r5, lr}
   31792:	4605      	mov	r5, r0
   31794:	68c0      	ldr	r0, [r0, #12]
   31796:	b085      	sub	sp, #20
   31798:	b9a8      	cbnz	r0, 317c6 <stream_handler_flush+0x36>
   3179a:	e01a      	b.n	317d2 <stream_handler_flush+0x42>
   3179c:	68e8      	ldr	r0, [r5, #12]
   3179e:	f7fc f9df 	bl	2db60 <linked_list_pop>
   317a2:	4604      	mov	r4, r0
   317a4:	b170      	cbz	r0, 317c4 <stream_handler_flush+0x34>
   317a6:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   317aa:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   317ae:	e9cd 0100 	strd	r0, r1, [sp]
   317b2:	e9cd 2302 	strd	r2, r3, [sp, #8]
   317b6:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   317ba:	4668      	mov	r0, sp
   317bc:	4798      	blx	r3
   317be:	4620      	mov	r0, r4
   317c0:	f7f8 fefc 	bl	2a5bc <nrf_free>
   317c4:	68e8      	ldr	r0, [r5, #12]
   317c6:	f7fc f9db 	bl	2db80 <linked_list_size_get>
   317ca:	2800      	cmp	r0, #0
   317cc:	d1e6      	bne.n	3179c <stream_handler_flush+0xc>
   317ce:	b005      	add	sp, #20
   317d0:	bd30      	pop	{r4, r5, pc}
   317d2:	2008      	movs	r0, #8
   317d4:	b005      	add	sp, #20
   317d6:	bd30      	pop	{r4, r5, pc}

000317d8 <stream_handler_free>:
   317d8:	b530      	push	{r4, r5, lr}
   317da:	4605      	mov	r5, r0
   317dc:	68c0      	ldr	r0, [r0, #12]
   317de:	b085      	sub	sp, #20
   317e0:	b9a0      	cbnz	r0, 3180c <stream_handler_free+0x34>
   317e2:	e01c      	b.n	3181e <stream_handler_free+0x46>
   317e4:	f7fc f9bc 	bl	2db60 <linked_list_pop>
   317e8:	4604      	mov	r4, r0
   317ea:	b170      	cbz	r0, 3180a <stream_handler_free+0x32>
   317ec:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   317f0:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   317f4:	e9cd 0100 	strd	r0, r1, [sp]
   317f8:	e9cd 2302 	strd	r2, r3, [sp, #8]
   317fc:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   31800:	4668      	mov	r0, sp
   31802:	4798      	blx	r3
   31804:	4620      	mov	r0, r4
   31806:	f7f8 fed9 	bl	2a5bc <nrf_free>
   3180a:	68e8      	ldr	r0, [r5, #12]
   3180c:	f7fc f9b8 	bl	2db80 <linked_list_size_get>
   31810:	4604      	mov	r4, r0
   31812:	68e8      	ldr	r0, [r5, #12]
   31814:	2c00      	cmp	r4, #0
   31816:	d1e5      	bne.n	317e4 <stream_handler_free+0xc>
   31818:	f7f8 fed0 	bl	2a5bc <nrf_free>
   3181c:	60ec      	str	r4, [r5, #12]
   3181e:	b005      	add	sp, #20
   31820:	bd30      	pop	{r4, r5, pc}
   31822:	bf00      	nop

00031824 <SystemInit>:
    
    /* Enable the FPU if the compiler used floating point unit instructions. __FPU_USED is a MACRO defined by the
    * compiler. Since the FPU consumes energy, remember to disable FPU use in the compiler if floating point unit
    * operations are not used in your code. */
    #if (__FPU_USED == 1)
      SCB->CPACR |= (3UL << 20) | (3UL << 22);
   31824:	4a07      	ldr	r2, [pc, #28]	; (31844 <SystemInit+0x20>)
   31826:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
   3182a:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
   3182e:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
   31832:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   31836:	f3bf 8f6f 	isb	sy
    SystemCoreClock = __SYSTEM_CLOCK;
   3183a:	4b03      	ldr	r3, [pc, #12]	; (31848 <SystemInit+0x24>)
   3183c:	4a03      	ldr	r2, [pc, #12]	; (3184c <SystemInit+0x28>)
   3183e:	601a      	str	r2, [r3, #0]
      __DSB();
      __ISB();
    #endif
    
    SystemCoreClockUpdate();
}
   31840:	4770      	bx	lr
   31842:	bf00      	nop
   31844:	e000ed00 	.word	0xe000ed00
   31848:	2002b054 	.word	0x2002b054
   3184c:	03d09000 	.word	0x03d09000

00031850 <nvmc_word_write>:
}

#if defined(NVMC_READYNEXT_READYNEXT_Msk)
NRF_STATIC_INLINE bool nrf_nvmc_write_ready_check(NRF_NVMC_Type const * p_reg)
{
    return (bool)(p_reg->READYNEXT & NVMC_READYNEXT_READYNEXT_Msk);
   31850:	4a04      	ldr	r2, [pc, #16]	; (31864 <nvmc_word_write+0x14>)
   31852:	f8d2 3408 	ldr.w	r3, [r2, #1032]	; 0x408
}

static void nvmc_word_write(uint32_t addr, uint32_t value)
{
#if defined(NRF9160_XXAA)
    while (!nrf_nvmc_write_ready_check(NRF_NVMC))
   31856:	07db      	lsls	r3, r3, #31
   31858:	d5fb      	bpl.n	31852 <nvmc_word_write+0x2>
#else
    while (!nrf_nvmc_ready_check(NRF_NVMC))
    {}
#endif

    *(volatile uint32_t *)addr = value;
   3185a:	6001      	str	r1, [r0, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   3185c:	f3bf 8f5f 	dmb	sy
    __DMB();
}
   31860:	4770      	bx	lr
   31862:	bf00      	nop
   31864:	40039000 	.word	0x40039000

00031868 <nrfx_nvmc_page_erase>:
    }
}

nrfx_err_t nrfx_nvmc_page_erase(uint32_t addr)
{
    NRFX_ASSERT((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get());
   31868:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
{
   3186c:	b508      	push	{r3, lr}
    NRFX_ASSERT((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get());
   3186e:	d305      	bcc.n	3187c <nrfx_nvmc_page_erase+0x14>
   31870:	4b0d      	ldr	r3, [pc, #52]	; (318a8 <nrfx_nvmc_page_erase+0x40>)
   31872:	4a0e      	ldr	r2, [pc, #56]	; (318ac <nrfx_nvmc_page_erase+0x44>)
   31874:	21dd      	movs	r1, #221	; 0xdd
   31876:	480e      	ldr	r0, [pc, #56]	; (318b0 <nrfx_nvmc_page_erase+0x48>)
   31878:	f004 f92e 	bl	35ad8 <__assert_func>
    return !(addr % flash_page_size_get());
   3187c:	f3c0 030b 	ubfx	r3, r0, #0, #12

    if (!is_page_aligned_check(addr))
   31880:	b97b      	cbnz	r3, 318a2 <nrfx_nvmc_page_erase+0x3a>

#if defined(NVMC_CONFIGNS_WEN_Msk)
NRF_STATIC_INLINE void nrf_nvmc_nonsecure_mode_set(NRF_NVMC_Type *    p_reg,
                                                   nrf_nvmc_ns_mode_t mode)
{
    p_reg->CONFIGNS = (uint32_t)mode;
   31882:	2202      	movs	r2, #2
   31884:	4b0b      	ldr	r3, [pc, #44]	; (318b4 <nrfx_nvmc_page_erase+0x4c>)
   31886:	f8c3 2584 	str.w	r2, [r3, #1412]	; 0x584
        p_reg->ERASEPCR1 = page_addr;
    }
#elif defined(NRF52_SERIES)
    p_reg->ERASEPAGE = page_addr;
#elif defined(NRF9160_XXAA) || defined(NRF5340_XXAA_APPLICATION) || defined(NRF5340_XXAA_NETWORK)
    *(volatile uint32_t *)page_addr = 0xFFFFFFFF;
   3188a:	f04f 32ff 	mov.w	r2, #4294967295
   3188e:	6002      	str	r2, [r0, #0]
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   31890:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
        return NRFX_ERROR_INVALID_ADDR;
    }

    nvmc_erase_mode_set();
    nrf_nvmc_page_erase_start(NRF_NVMC, addr);
    while (!nrf_nvmc_ready_check(NRF_NVMC))
   31894:	07d2      	lsls	r2, r2, #31
   31896:	d5fb      	bpl.n	31890 <nrfx_nvmc_page_erase+0x28>
    p_reg->CONFIGNS = (uint32_t)mode;
   31898:	2200      	movs	r2, #0
    {}
    nvmc_readonly_mode_set();

    return NRFX_SUCCESS;
   3189a:	4807      	ldr	r0, [pc, #28]	; (318b8 <nrfx_nvmc_page_erase+0x50>)
   3189c:	f8c3 2584 	str.w	r2, [r3, #1412]	; 0x584
}
   318a0:	bd08      	pop	{r3, pc}
        return NRFX_ERROR_INVALID_ADDR;
   318a2:	4806      	ldr	r0, [pc, #24]	; (318bc <nrfx_nvmc_page_erase+0x54>)
   318a4:	e7fc      	b.n	318a0 <nrfx_nvmc_page_erase+0x38>
   318a6:	bf00      	nop
   318a8:	0003e851 	.word	0x0003e851
   318ac:	0003e827 	.word	0x0003e827
   318b0:	0003e8be 	.word	0x0003e8be
   318b4:	40039000 	.word	0x40039000
   318b8:	0bad0000 	.word	0x0bad0000
   318bc:	0bad000a 	.word	0x0bad000a

000318c0 <nrfx_nvmc_word_write>:
    nrfx_nvmc_word_write(aligned_addr, partial_word_create(addr, &value, 1));
}

void nrfx_nvmc_word_write(uint32_t addr, uint32_t value)
{
    NRFX_ASSERT((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get());
   318c0:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
{
   318c4:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get());
   318c6:	d306      	bcc.n	318d6 <nrfx_nvmc_word_write+0x16>
   318c8:	f240 114d 	movw	r1, #333	; 0x14d
   318cc:	4b0a      	ldr	r3, [pc, #40]	; (318f8 <nrfx_nvmc_word_write+0x38>)
   318ce:	4a0b      	ldr	r2, [pc, #44]	; (318fc <nrfx_nvmc_word_write+0x3c>)
    NRFX_ASSERT(nrfx_is_word_aligned((void const *)addr));
   318d0:	480b      	ldr	r0, [pc, #44]	; (31900 <nrfx_nvmc_word_write+0x40>)
   318d2:	f004 f901 	bl	35ad8 <__assert_func>
   318d6:	f010 0403 	ands.w	r4, r0, #3
   318da:	d004      	beq.n	318e6 <nrfx_nvmc_word_write+0x26>
   318dc:	4b09      	ldr	r3, [pc, #36]	; (31904 <nrfx_nvmc_word_write+0x44>)
   318de:	4a07      	ldr	r2, [pc, #28]	; (318fc <nrfx_nvmc_word_write+0x3c>)
   318e0:	f44f 71a7 	mov.w	r1, #334	; 0x14e
   318e4:	e7f4      	b.n	318d0 <nrfx_nvmc_word_write+0x10>
   318e6:	2301      	movs	r3, #1
   318e8:	4d07      	ldr	r5, [pc, #28]	; (31908 <nrfx_nvmc_word_write+0x48>)
   318ea:	f8c5 3584 	str.w	r3, [r5, #1412]	; 0x584

    nvmc_write_mode_set();

    nvmc_word_write(addr, value);
   318ee:	f7ff ffaf 	bl	31850 <nvmc_word_write>
   318f2:	f8c5 4584 	str.w	r4, [r5, #1412]	; 0x584

    nvmc_readonly_mode_set();
}
   318f6:	bd38      	pop	{r3, r4, r5, pc}
   318f8:	0003e851 	.word	0x0003e851
   318fc:	0003e83c 	.word	0x0003e83c
   31900:	0003e8be 	.word	0x0003e8be
   31904:	0003e875 	.word	0x0003e875
   31908:	40039000 	.word	0x40039000

0003190c <nrf_gpio_pin_port_decode.isra.0.part.1>:
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   3190c:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   3190e:	4a03      	ldr	r2, [pc, #12]	; (3191c <nrf_gpio_pin_port_decode.isra.0.part.1+0x10>)
   31910:	4b03      	ldr	r3, [pc, #12]	; (31920 <nrf_gpio_pin_port_decode.isra.0.part.1+0x14>)
   31912:	f240 11ff 	movw	r1, #511	; 0x1ff
   31916:	4803      	ldr	r0, [pc, #12]	; (31924 <nrf_gpio_pin_port_decode.isra.0.part.1+0x18>)
   31918:	f004 f8de 	bl	35ad8 <__assert_func>
   3191c:	0003e8fa 	.word	0x0003e8fa
   31920:	0003dd42 	.word	0x0003dd42
   31924:	0003dd50 	.word	0x0003dd50

00031928 <nrf_gpio_pin_clear>:
   31928:	281f      	cmp	r0, #31
{
   3192a:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   3192c:	d901      	bls.n	31932 <nrf_gpio_pin_clear+0xa>
   3192e:	f7ff ffed 	bl	3190c <nrf_gpio_pin_port_decode.isra.0.part.1>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   31932:	2301      	movs	r3, #1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
   31934:	4a01      	ldr	r2, [pc, #4]	; (3193c <nrf_gpio_pin_clear+0x14>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   31936:	4083      	lsls	r3, r0
    p_reg->OUTCLR = clr_mask;
   31938:	60d3      	str	r3, [r2, #12]
}
   3193a:	bd08      	pop	{r3, pc}
   3193c:	40842500 	.word	0x40842500

00031940 <nrf_gpio_pin_set>:
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   31940:	281f      	cmp	r0, #31
{
   31942:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   31944:	d901      	bls.n	3194a <nrf_gpio_pin_set+0xa>
   31946:	f7ff ffe1 	bl	3190c <nrf_gpio_pin_port_decode.isra.0.part.1>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   3194a:	2301      	movs	r3, #1
    p_reg->OUTSET = set_mask;
   3194c:	4a01      	ldr	r2, [pc, #4]	; (31954 <nrf_gpio_pin_set+0x14>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   3194e:	4083      	lsls	r3, r0
    p_reg->OUTSET = set_mask;
   31950:	6093      	str	r3, [r2, #8]
}
   31952:	bd08      	pop	{r3, pc}
   31954:	40842500 	.word	0x40842500

00031958 <irq_handler.part.2>:
{
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
    return nrf_spim_event_address_get(p_spim, NRF_SPIM_EVENT_END);
}

static void irq_handler(NRF_SPIM_Type * p_spim, spim_control_block_t * p_cb)
   31958:	b508      	push	{r3, lr}
        {
            anomaly_198_disable();
        }
#endif
        nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_END);
        NRFX_ASSERT(p_cb->handler);
   3195a:	4a03      	ldr	r2, [pc, #12]	; (31968 <irq_handler.part.2+0x10>)
   3195c:	4b03      	ldr	r3, [pc, #12]	; (3196c <irq_handler.part.2+0x14>)
   3195e:	f240 21e7 	movw	r1, #743	; 0x2e7
   31962:	4803      	ldr	r0, [pc, #12]	; (31970 <irq_handler.part.2+0x18>)
   31964:	f004 f8b8 	bl	35ad8 <__assert_func>
   31968:	0003e931 	.word	0x0003e931
   3196c:	0003e93d 	.word	0x0003e93d
   31970:	0003e94b 	.word	0x0003e94b

00031974 <nrfx_spim_init>:
{
   31974:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   31978:	4681      	mov	r9, r0
    NRFX_ASSERT(p_config);
   3197a:	460c      	mov	r4, r1
   3197c:	b929      	cbnz	r1, 3198a <nrfx_spim_init+0x16>
   3197e:	4b52      	ldr	r3, [pc, #328]	; (31ac8 <nrfx_spim_init+0x154>)
   31980:	4a52      	ldr	r2, [pc, #328]	; (31acc <nrfx_spim_init+0x158>)
   31982:	21f4      	movs	r1, #244	; 0xf4
   31984:	4852      	ldr	r0, [pc, #328]	; (31ad0 <nrfx_spim_init+0x15c>)
   31986:	f004 f8a7 	bl	35ad8 <__assert_func>
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   3198a:	2124      	movs	r1, #36	; 0x24
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   3198c:	7905      	ldrb	r5, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   3198e:	4e51      	ldr	r6, [pc, #324]	; (31ad4 <nrfx_spim_init+0x160>)
   31990:	4369      	muls	r1, r5
   31992:	1870      	adds	r0, r6, r1
   31994:	7f07      	ldrb	r7, [r0, #28]
   31996:	2f00      	cmp	r7, #0
   31998:	f040 8094 	bne.w	31ac4 <nrfx_spim_init+0x150>
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
   3199c:	f8d9 7000 	ldr.w	r7, [r9]
    p_cb->p_context = p_context;
   319a0:	6043      	str	r3, [r0, #4]
    if (p_config->mode <= NRF_SPIM_MODE_1)
   319a2:	7b23      	ldrb	r3, [r4, #12]
    p_cb->handler = handler;
   319a4:	5072      	str	r2, [r6, r1]
    if (p_config->mode <= NRF_SPIM_MODE_1)
   319a6:	2b01      	cmp	r3, #1
   319a8:	7820      	ldrb	r0, [r4, #0]
   319aa:	d806      	bhi.n	319ba <nrfx_spim_init+0x46>
        nrf_gpio_pin_clear(p_config->sck_pin);
   319ac:	f7ff ffbc 	bl	31928 <nrf_gpio_pin_clear>
    nrf_gpio_cfg(p_config->sck_pin,
   319b0:	7823      	ldrb	r3, [r4, #0]
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   319b2:	2b1f      	cmp	r3, #31
   319b4:	d904      	bls.n	319c0 <nrfx_spim_init+0x4c>
   319b6:	f7ff ffa9 	bl	3190c <nrf_gpio_pin_port_decode.isra.0.part.1>
        nrf_gpio_pin_set(p_config->sck_pin);
   319ba:	f7ff ffc1 	bl	31940 <nrf_gpio_pin_set>
   319be:	e7f7      	b.n	319b0 <nrfx_spim_init+0x3c>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   319c0:	2101      	movs	r1, #1
   319c2:	4a45      	ldr	r2, [pc, #276]	; (31ad8 <nrfx_spim_init+0x164>)
   319c4:	3380      	adds	r3, #128	; 0x80
   319c6:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    if (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
   319ca:	f894 8001 	ldrb.w	r8, [r4, #1]
   319ce:	4692      	mov	sl, r2
   319d0:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
   319d4:	d067      	beq.n	31aa6 <nrfx_spim_init+0x132>
        nrf_gpio_pin_clear(mosi_pin);
   319d6:	4640      	mov	r0, r8
   319d8:	f7ff ffa6 	bl	31928 <nrf_gpio_pin_clear>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   319dc:	f1b8 0f1f 	cmp.w	r8, #31
   319e0:	d8e9      	bhi.n	319b6 <nrfx_spim_init+0x42>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   319e2:	2203      	movs	r2, #3
   319e4:	f108 0380 	add.w	r3, r8, #128	; 0x80
   319e8:	f84a 2023 	str.w	r2, [sl, r3, lsl #2]
    if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
   319ec:	78a3      	ldrb	r3, [r4, #2]
   319ee:	2bff      	cmp	r3, #255	; 0xff
   319f0:	d05c      	beq.n	31aac <nrfx_spim_init+0x138>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   319f2:	2b1f      	cmp	r3, #31
        miso_pin = p_config->miso_pin;
   319f4:	469b      	mov	fp, r3
        nrf_gpio_cfg_input(miso_pin, p_config->miso_pull);
   319f6:	7ba2      	ldrb	r2, [r4, #14]
   319f8:	d8dd      	bhi.n	319b6 <nrfx_spim_init+0x42>
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
   319fa:	0092      	lsls	r2, r2, #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   319fc:	f103 0180 	add.w	r1, r3, #128	; 0x80
   31a00:	f84a 2021 	str.w	r2, [sl, r1, lsl #2]
    p_cb->miso_pin = p_config->miso_pin;
   31a04:	2224      	movs	r2, #36	; 0x24
   31a06:	fb02 6205 	mla	r2, r2, r5, r6
   31a0a:	f882 3020 	strb.w	r3, [r2, #32]
    p_cb->ss_pin = p_config->ss_pin;
   31a0e:	78e0      	ldrb	r0, [r4, #3]
    if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   31a10:	28ff      	cmp	r0, #255	; 0xff
    p_cb->ss_pin = p_config->ss_pin;
   31a12:	77d0      	strb	r0, [r2, #31]
    if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   31a14:	d010      	beq.n	31a38 <nrfx_spim_init+0xc4>
        if (p_config->ss_active_high)
   31a16:	7923      	ldrb	r3, [r4, #4]
   31a18:	2b00      	cmp	r3, #0
   31a1a:	d04a      	beq.n	31ab2 <nrfx_spim_init+0x13e>
            nrf_gpio_pin_clear(p_config->ss_pin);
   31a1c:	f7ff ff84 	bl	31928 <nrf_gpio_pin_clear>
        nrf_gpio_cfg_output(p_config->ss_pin);
   31a20:	78e3      	ldrb	r3, [r4, #3]
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   31a22:	2b1f      	cmp	r3, #31
   31a24:	d8c7      	bhi.n	319b6 <nrfx_spim_init+0x42>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   31a26:	2203      	movs	r2, #3
   31a28:	3380      	adds	r3, #128	; 0x80
   31a2a:	f84a 2023 	str.w	r2, [sl, r3, lsl #2]
        p_cb->ss_active_high = p_config->ss_active_high;
   31a2e:	2324      	movs	r3, #36	; 0x24
   31a30:	fb03 6305 	mla	r3, r3, r5, r6
   31a34:	7922      	ldrb	r2, [r4, #4]
   31a36:	779a      	strb	r2, [r3, #30]
    nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
   31a38:	7823      	ldrb	r3, [r4, #0]
    nrf_spim_configure(p_spim, p_config->mode, p_config->bit_order);
   31a3a:	7b22      	ldrb	r2, [r4, #12]
    p_reg->PSEL.SCK  = sck_pin;
   31a3c:	f8c7 3508 	str.w	r3, [r7, #1288]	; 0x508
    p_reg->FREQUENCY = (uint32_t)frequency;
   31a40:	68a3      	ldr	r3, [r4, #8]
    p_reg->PSEL.MOSI = mosi_pin;
   31a42:	f8c7 850c 	str.w	r8, [r7, #1292]	; 0x50c
    p_reg->PSEL.MISO = miso_pin;
   31a46:	f8c7 b510 	str.w	fp, [r7, #1296]	; 0x510
    p_reg->FREQUENCY = (uint32_t)frequency;
   31a4a:	f8c7 3524 	str.w	r3, [r7, #1316]	; 0x524
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
   31a4e:	7b63      	ldrb	r3, [r4, #13]
   31a50:	3300      	adds	r3, #0
   31a52:	bf18      	it	ne
   31a54:	2301      	movne	r3, #1
    switch (spi_mode)
   31a56:	2a02      	cmp	r2, #2
   31a58:	d02e      	beq.n	31ab8 <nrfx_spim_init+0x144>
   31a5a:	2a03      	cmp	r2, #3
   31a5c:	d02f      	beq.n	31abe <nrfx_spim_init+0x14a>
   31a5e:	2a01      	cmp	r2, #1
   31a60:	d101      	bne.n	31a66 <nrfx_spim_init+0xf2>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
   31a62:	f043 0302 	orr.w	r3, r3, #2
    p_reg->CONFIG = config;
   31a66:	f8c7 3554 	str.w	r3, [r7, #1364]	; 0x554
}

NRF_STATIC_INLINE void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
                                        uint8_t         orc)
{
    p_reg->ORC = orc;
   31a6a:	79a3      	ldrb	r3, [r4, #6]
   31a6c:	f8c7 35c0 	str.w	r3, [r7, #1472]	; 0x5c0
    if (p_cb->handler)
   31a70:	2324      	movs	r3, #36	; 0x24
   31a72:	436b      	muls	r3, r5
   31a74:	58f3      	ldr	r3, [r6, r3]
   31a76:	b113      	cbz	r3, 31a7e <nrfx_spim_init+0x10a>
    p_reg->INTENSET = mask;
   31a78:	2240      	movs	r2, #64	; 0x40
   31a7a:	f8c7 2304 	str.w	r2, [r7, #772]	; 0x304
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Enabled << SPIM_ENABLE_ENABLE_Pos);
   31a7e:	2207      	movs	r2, #7
   31a80:	f8c7 2500 	str.w	r2, [r7, #1280]	; 0x500
    if (p_cb->handler)
   31a84:	b12b      	cbz	r3, 31a92 <nrfx_spim_init+0x11e>
    return ((((uint32_t)p_object) & 0x3u) == 0u);
}

NRF_STATIC_INLINE IRQn_Type nrfx_get_irq_number(void const * p_reg)
{
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
   31a86:	f8d9 0000 	ldr.w	r0, [r9]
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
   31a8a:	f340 3007 	sbfx	r0, r0, #12, #8
   31a8e:	f7f3 fa9f 	bl	24fd0 <arch_irq_enable>
    p_cb->transfer_in_progress = false;
   31a92:	2324      	movs	r3, #36	; 0x24
   31a94:	fb03 6505 	mla	r5, r3, r5, r6
   31a98:	2300      	movs	r3, #0
   31a9a:	776b      	strb	r3, [r5, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   31a9c:	2301      	movs	r3, #1
    return err_code;
   31a9e:	480f      	ldr	r0, [pc, #60]	; (31adc <nrfx_spim_init+0x168>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   31aa0:	772b      	strb	r3, [r5, #28]
}
   31aa2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        mosi_pin = NRF_SPIM_PIN_NOT_CONNECTED;
   31aa6:	f04f 38ff 	mov.w	r8, #4294967295
   31aaa:	e79f      	b.n	319ec <nrfx_spim_init+0x78>
        miso_pin = NRF_SPIM_PIN_NOT_CONNECTED;
   31aac:	f04f 3bff 	mov.w	fp, #4294967295
   31ab0:	e7a8      	b.n	31a04 <nrfx_spim_init+0x90>
            nrf_gpio_pin_set(p_config->ss_pin);
   31ab2:	f7ff ff45 	bl	31940 <nrf_gpio_pin_set>
   31ab6:	e7b3      	b.n	31a20 <nrfx_spim_init+0xac>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   31ab8:	f043 0304 	orr.w	r3, r3, #4
        break;
   31abc:	e7d3      	b.n	31a66 <nrfx_spim_init+0xf2>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   31abe:	f043 0306 	orr.w	r3, r3, #6
        break;
   31ac2:	e7d0      	b.n	31a66 <nrfx_spim_init+0xf2>
        return err_code;
   31ac4:	4806      	ldr	r0, [pc, #24]	; (31ae0 <nrfx_spim_init+0x16c>)
   31ac6:	e7ec      	b.n	31aa2 <nrfx_spim_init+0x12e>
   31ac8:	0003e987 	.word	0x0003e987
   31acc:	0003e913 	.word	0x0003e913
   31ad0:	0003e94b 	.word	0x0003e94b
   31ad4:	20020ee8 	.word	0x20020ee8
   31ad8:	40842500 	.word	0x40842500
   31adc:	0bad0000 	.word	0x0bad0000
   31ae0:	0bad0005 	.word	0x0bad0005

00031ae4 <nrfx_spim_xfer>:
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   31ae4:	2324      	movs	r3, #36	; 0x24
{
   31ae6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   31aea:	4d58      	ldr	r5, [pc, #352]	; (31c4c <nrfx_spim_xfer+0x168>)
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   31aec:	7906      	ldrb	r6, [r0, #4]
{
   31aee:	4680      	mov	r8, r0
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   31af0:	fb03 5306 	mla	r3, r3, r6, r5
   31af4:	7f1b      	ldrb	r3, [r3, #28]
{
   31af6:	460c      	mov	r4, r1
   31af8:	4617      	mov	r7, r2
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   31afa:	b933      	cbnz	r3, 31b0a <nrfx_spim_xfer+0x26>
   31afc:	f240 217d 	movw	r1, #637	; 0x27d
   31b00:	4b53      	ldr	r3, [pc, #332]	; (31c50 <nrfx_spim_xfer+0x16c>)
   31b02:	4a54      	ldr	r2, [pc, #336]	; (31c54 <nrfx_spim_xfer+0x170>)
    NRFX_ASSERT(p_xfer_desc->p_tx_buffer != NULL || p_xfer_desc->tx_length == 0);
   31b04:	4854      	ldr	r0, [pc, #336]	; (31c58 <nrfx_spim_xfer+0x174>)
   31b06:	f003 ffe7 	bl	35ad8 <__assert_func>
   31b0a:	680b      	ldr	r3, [r1, #0]
   31b0c:	b933      	cbnz	r3, 31b1c <nrfx_spim_xfer+0x38>
   31b0e:	684b      	ldr	r3, [r1, #4]
   31b10:	b123      	cbz	r3, 31b1c <nrfx_spim_xfer+0x38>
   31b12:	4b52      	ldr	r3, [pc, #328]	; (31c5c <nrfx_spim_xfer+0x178>)
   31b14:	4a4f      	ldr	r2, [pc, #316]	; (31c54 <nrfx_spim_xfer+0x170>)
   31b16:	f240 217e 	movw	r1, #638	; 0x27e
   31b1a:	e7f3      	b.n	31b04 <nrfx_spim_xfer+0x20>
    NRFX_ASSERT(p_xfer_desc->p_rx_buffer != NULL || p_xfer_desc->rx_length == 0);
   31b1c:	68a3      	ldr	r3, [r4, #8]
   31b1e:	b943      	cbnz	r3, 31b32 <nrfx_spim_xfer+0x4e>
   31b20:	68e3      	ldr	r3, [r4, #12]
   31b22:	2b00      	cmp	r3, #0
   31b24:	f000 808e 	beq.w	31c44 <nrfx_spim_xfer+0x160>
   31b28:	4b4d      	ldr	r3, [pc, #308]	; (31c60 <nrfx_spim_xfer+0x17c>)
   31b2a:	4a4a      	ldr	r2, [pc, #296]	; (31c54 <nrfx_spim_xfer+0x170>)
   31b2c:	f240 217f 	movw	r1, #639	; 0x27f
   31b30:	e7e8      	b.n	31b04 <nrfx_spim_xfer+0x20>
    NRFX_ASSERT(SPIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   31b32:	2e01      	cmp	r6, #1
   31b34:	d807      	bhi.n	31b46 <nrfx_spim_xfer+0x62>
   31b36:	68e3      	ldr	r3, [r4, #12]
   31b38:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   31b3c:	d203      	bcs.n	31b46 <nrfx_spim_xfer+0x62>
   31b3e:	6863      	ldr	r3, [r4, #4]
   31b40:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   31b44:	d304      	bcc.n	31b50 <nrfx_spim_xfer+0x6c>
   31b46:	4b47      	ldr	r3, [pc, #284]	; (31c64 <nrfx_spim_xfer+0x180>)
   31b48:	4a42      	ldr	r2, [pc, #264]	; (31c54 <nrfx_spim_xfer+0x170>)
   31b4a:	f240 2182 	movw	r1, #642	; 0x282
   31b4e:	e7d9      	b.n	31b04 <nrfx_spim_xfer+0x20>
    if (p_cb->transfer_in_progress)
   31b50:	2324      	movs	r3, #36	; 0x24
   31b52:	4373      	muls	r3, r6
   31b54:	18ea      	adds	r2, r5, r3
   31b56:	7f51      	ldrb	r1, [r2, #29]
   31b58:	2900      	cmp	r1, #0
   31b5a:	d171      	bne.n	31c40 <nrfx_spim_xfer+0x15c>
        if (p_cb->handler && !(flags & (NRFX_SPIM_FLAG_REPEATED_XFER |
   31b5c:	58eb      	ldr	r3, [r5, r3]
   31b5e:	b123      	cbz	r3, 31b6a <nrfx_spim_xfer+0x86>
   31b60:	f017 0f14 	tst.w	r7, #20
            p_cb->transfer_in_progress = true;
   31b64:	bf04      	itt	eq
   31b66:	2301      	moveq	r3, #1
   31b68:	7753      	strbeq	r3, [r2, #29]
    p_cb->evt.xfer_desc = *p_xfer_desc;
   31b6a:	f04f 0c24 	mov.w	ip, #36	; 0x24
   31b6e:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   31b72:	fb0c 5c06 	mla	ip, ip, r6, r5
   31b76:	f10c 0e0c 	add.w	lr, ip, #12
   31b7a:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   31b7e:	f89c 001f 	ldrb.w	r0, [ip, #31]
   31b82:	28ff      	cmp	r0, #255	; 0xff
   31b84:	d004      	beq.n	31b90 <nrfx_spim_xfer+0xac>
            if (p_cb->ss_active_high)
   31b86:	f89c 301e 	ldrb.w	r3, [ip, #30]
   31b8a:	b1bb      	cbz	r3, 31bbc <nrfx_spim_xfer+0xd8>
                nrf_gpio_pin_set(p_cb->ss_pin);
   31b8c:	f7ff fed8 	bl	31940 <nrf_gpio_pin_set>
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   31b90:	6821      	ldr	r1, [r4, #0]
   31b92:	b121      	cbz	r1, 31b9e <nrfx_spim_xfer+0xba>
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   31b94:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
   31b98:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   31b9c:	d106      	bne.n	31bac <nrfx_spim_xfer+0xc8>
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   31b9e:	68a2      	ldr	r2, [r4, #8]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   31ba0:	b17a      	cbz	r2, 31bc2 <nrfx_spim_xfer+0xde>
   31ba2:	f002 4360 	and.w	r3, r2, #3758096384	; 0xe0000000
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   31ba6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   31baa:	d00a      	beq.n	31bc2 <nrfx_spim_xfer+0xde>
        p_cb->transfer_in_progress = false;
   31bac:	2324      	movs	r3, #36	; 0x24
   31bae:	fb03 5506 	mla	r5, r3, r6, r5
   31bb2:	2300      	movs	r3, #0
        return err_code;
   31bb4:	482c      	ldr	r0, [pc, #176]	; (31c68 <nrfx_spim_xfer+0x184>)
        p_cb->transfer_in_progress = false;
   31bb6:	776b      	strb	r3, [r5, #29]
}
   31bb8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                nrf_gpio_pin_clear(p_cb->ss_pin);
   31bbc:	f7ff feb4 	bl	31928 <nrf_gpio_pin_clear>
   31bc0:	e7e6      	b.n	31b90 <nrfx_spim_xfer+0xac>
    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
   31bc2:	f8d8 3000 	ldr.w	r3, [r8]
    nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
   31bc6:	6860      	ldr	r0, [r4, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   31bc8:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   31bcc:	f8c3 0548 	str.w	r0, [r3, #1352]	; 0x548
    nrf_spim_rx_buffer_set(p_spim, p_xfer_desc->p_rx_buffer, p_xfer_desc->rx_length);
   31bd0:	68e1      	ldr	r1, [r4, #12]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   31bd2:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   31bd6:	2200      	movs	r2, #0
    p_reg->RXD.MAXCNT = length;
   31bd8:	f8c3 1538 	str.w	r1, [r3, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   31bdc:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    if (NRFX_SPIM_FLAG_TX_POSTINC & flags)
   31be0:	f017 0201 	ands.w	r2, r7, #1
}


NRF_STATIC_INLINE void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_ArrayList << SPIM_TXD_LIST_LIST_Pos;
   31be4:	bf18      	it	ne
   31be6:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_tx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_Disabled << SPIM_TXD_LIST_LIST_Pos;
   31be8:	f8c3 2550 	str.w	r2, [r3, #1360]	; 0x550
    if (NRFX_SPIM_FLAG_RX_POSTINC & flags)
   31bec:	f017 0202 	ands.w	r2, r7, #2
}

NRF_STATIC_INLINE void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_ArrayList << SPIM_RXD_LIST_LIST_Pos;
   31bf0:	bf18      	it	ne
   31bf2:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_Disabled << SPIM_RXD_LIST_LIST_Pos;
   31bf4:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
   31bf8:	073a      	lsls	r2, r7, #28
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   31bfa:	bf5c      	itt	pl
   31bfc:	2201      	movpl	r2, #1
   31bfe:	611a      	strpl	r2, [r3, #16]
    if (!p_cb->handler)
   31c00:	2224      	movs	r2, #36	; 0x24
   31c02:	4372      	muls	r2, r6
   31c04:	58aa      	ldr	r2, [r5, r2]
   31c06:	b992      	cbnz	r2, 31c2e <nrfx_spim_xfer+0x14a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   31c08:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
        while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END)){}
   31c0c:	2a00      	cmp	r2, #0
   31c0e:	d0fb      	beq.n	31c08 <nrfx_spim_xfer+0x124>
        if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   31c10:	2324      	movs	r3, #36	; 0x24
   31c12:	fb03 5506 	mla	r5, r3, r6, r5
   31c16:	7fe8      	ldrb	r0, [r5, #31]
   31c18:	28ff      	cmp	r0, #255	; 0xff
   31c1a:	d003      	beq.n	31c24 <nrfx_spim_xfer+0x140>
                if (p_cb->ss_active_high)
   31c1c:	7fab      	ldrb	r3, [r5, #30]
   31c1e:	b11b      	cbz	r3, 31c28 <nrfx_spim_xfer+0x144>
                    nrf_gpio_pin_clear(p_cb->ss_pin);
   31c20:	f7ff fe82 	bl	31928 <nrf_gpio_pin_clear>
    return err_code;
   31c24:	4811      	ldr	r0, [pc, #68]	; (31c6c <nrfx_spim_xfer+0x188>)
   31c26:	e7c7      	b.n	31bb8 <nrfx_spim_xfer+0xd4>
                    nrf_gpio_pin_set(p_cb->ss_pin);
   31c28:	f7ff fe8a 	bl	31940 <nrf_gpio_pin_set>
   31c2c:	e7fa      	b.n	31c24 <nrfx_spim_xfer+0x140>
    if (!enable)
   31c2e:	2240      	movs	r2, #64	; 0x40
   31c30:	f017 0f04 	tst.w	r7, #4
    p_reg->INTENCLR = mask;
   31c34:	bf14      	ite	ne
   31c36:	f8c3 2308 	strne.w	r2, [r3, #776]	; 0x308
    p_reg->INTENSET = mask;
   31c3a:	f8c3 2304 	streq.w	r2, [r3, #772]	; 0x304
   31c3e:	e7f1      	b.n	31c24 <nrfx_spim_xfer+0x140>
        return err_code;
   31c40:	480b      	ldr	r0, [pc, #44]	; (31c70 <nrfx_spim_xfer+0x18c>)
   31c42:	e7b9      	b.n	31bb8 <nrfx_spim_xfer+0xd4>
    NRFX_ASSERT(SPIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   31c44:	2e01      	cmp	r6, #1
   31c46:	f67f af7a 	bls.w	31b3e <nrfx_spim_xfer+0x5a>
   31c4a:	e77c      	b.n	31b46 <nrfx_spim_xfer+0x62>
   31c4c:	20020ee8 	.word	0x20020ee8
   31c50:	0003e990 	.word	0x0003e990
   31c54:	0003e922 	.word	0x0003e922
   31c58:	0003e94b 	.word	0x0003e94b
   31c5c:	0003e9bc 	.word	0x0003e9bc
   31c60:	0003ea03 	.word	0x0003ea03
   31c64:	0003ea4a 	.word	0x0003ea4a
   31c68:	0bad000a 	.word	0x0bad000a
   31c6c:	0bad0000 	.word	0x0bad0000
   31c70:	0bad000b 	.word	0x0bad000b

00031c74 <nrfx_spim_2_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_SPIM2_ENABLED)
void nrfx_spim_2_irq_handler(void)
{
   31c74:	b508      	push	{r3, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   31c76:	4b08      	ldr	r3, [pc, #32]	; (31c98 <nrfx_spim_2_irq_handler+0x24>)
   31c78:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   31c7c:	b15a      	cbz	r2, 31c96 <nrfx_spim_2_irq_handler+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   31c7e:	2200      	movs	r2, #0
        NRFX_ASSERT(p_cb->handler);
   31c80:	4806      	ldr	r0, [pc, #24]	; (31c9c <nrfx_spim_2_irq_handler+0x28>)
   31c82:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   31c86:	6803      	ldr	r3, [r0, #0]
   31c88:	b90b      	cbnz	r3, 31c8e <nrfx_spim_2_irq_handler+0x1a>
   31c8a:	f7ff fe65 	bl	31958 <irq_handler.part.2>
    irq_handler(NRF_SPIM2, &m_cb[NRFX_SPIM2_INST_IDX]);
}
   31c8e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        finish_transfer(p_cb);
   31c92:	f007 be4e 	b.w	39932 <finish_transfer>
}
   31c96:	bd08      	pop	{r3, pc}
   31c98:	4000a000 	.word	0x4000a000
   31c9c:	20020ee8 	.word	0x20020ee8

00031ca0 <nrfx_spim_3_irq_handler>:
#endif

#if NRFX_CHECK(NRFX_SPIM3_ENABLED)
void nrfx_spim_3_irq_handler(void)
{
   31ca0:	b508      	push	{r3, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   31ca2:	4b09      	ldr	r3, [pc, #36]	; (31cc8 <nrfx_spim_3_irq_handler+0x28>)
   31ca4:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   31ca8:	b162      	cbz	r2, 31cc4 <nrfx_spim_3_irq_handler+0x24>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   31caa:	2200      	movs	r2, #0
        NRFX_ASSERT(p_cb->handler);
   31cac:	4807      	ldr	r0, [pc, #28]	; (31ccc <nrfx_spim_3_irq_handler+0x2c>)
   31cae:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   31cb2:	6a43      	ldr	r3, [r0, #36]	; 0x24
   31cb4:	b90b      	cbnz	r3, 31cba <nrfx_spim_3_irq_handler+0x1a>
   31cb6:	f7ff fe4f 	bl	31958 <irq_handler.part.2>
        finish_transfer(p_cb);
   31cba:	3024      	adds	r0, #36	; 0x24
    irq_handler(NRF_SPIM3, &m_cb[NRFX_SPIM3_INST_IDX]);
}
   31cbc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        finish_transfer(p_cb);
   31cc0:	f007 be37 	b.w	39932 <finish_transfer>
}
   31cc4:	bd08      	pop	{r3, pc}
   31cc6:	bf00      	nop
   31cc8:	4000b000 	.word	0x4000b000
   31ccc:	20020ee8 	.word	0x20020ee8

00031cd0 <nrf_gpio_pin_port_decode.isra.1>:
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   31cd0:	281f      	cmp	r0, #31
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   31cd2:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   31cd4:	d906      	bls.n	31ce4 <nrf_gpio_pin_port_decode.isra.1+0x14>
   31cd6:	4b04      	ldr	r3, [pc, #16]	; (31ce8 <nrf_gpio_pin_port_decode.isra.1+0x18>)
   31cd8:	4a04      	ldr	r2, [pc, #16]	; (31cec <nrf_gpio_pin_port_decode.isra.1+0x1c>)
   31cda:	f240 11ff 	movw	r1, #511	; 0x1ff
   31cde:	4804      	ldr	r0, [pc, #16]	; (31cf0 <nrf_gpio_pin_port_decode.isra.1+0x20>)
   31ce0:	f003 fefa 	bl	35ad8 <__assert_func>
}
   31ce4:	4803      	ldr	r0, [pc, #12]	; (31cf4 <nrf_gpio_pin_port_decode.isra.1+0x24>)
   31ce6:	bd08      	pop	{r3, pc}
   31ce8:	0003dd42 	.word	0x0003dd42
   31cec:	0003eb7a 	.word	0x0003eb7a
   31cf0:	0003dd50 	.word	0x0003dd50
   31cf4:	40842500 	.word	0x40842500

00031cf8 <nrfx_twim_init>:

nrfx_err_t nrfx_twim_init(nrfx_twim_t const *        p_instance,
                          nrfx_twim_config_t const * p_config,
                          nrfx_twim_evt_handler_t    event_handler,
                          void *                     p_context)
{
   31cf8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   31cfc:	4682      	mov	sl, r0
   31cfe:	4691      	mov	r9, r2
    NRFX_ASSERT(p_config);
   31d00:	460d      	mov	r5, r1
   31d02:	b929      	cbnz	r1, 31d10 <nrfx_twim_init+0x18>
   31d04:	21de      	movs	r1, #222	; 0xde
   31d06:	4b25      	ldr	r3, [pc, #148]	; (31d9c <nrfx_twim_init+0xa4>)
   31d08:	4a25      	ldr	r2, [pc, #148]	; (31da0 <nrfx_twim_init+0xa8>)
    NRFX_ASSERT(p_config->scl != p_config->sda);
   31d0a:	4826      	ldr	r0, [pc, #152]	; (31da4 <nrfx_twim_init+0xac>)
   31d0c:	f003 fee4 	bl	35ad8 <__assert_func>
   31d10:	e9d1 8700 	ldrd	r8, r7, [r1]
   31d14:	45b8      	cmp	r8, r7
   31d16:	d103      	bne.n	31d20 <nrfx_twim_init+0x28>
   31d18:	4b23      	ldr	r3, [pc, #140]	; (31da8 <nrfx_twim_init+0xb0>)
   31d1a:	4a21      	ldr	r2, [pc, #132]	; (31da0 <nrfx_twim_init+0xa8>)
   31d1c:	21df      	movs	r1, #223	; 0xdf
   31d1e:	e7f4      	b.n	31d0a <nrfx_twim_init+0x12>
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   31d20:	2134      	movs	r1, #52	; 0x34
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   31d22:	7906      	ldrb	r6, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   31d24:	4c21      	ldr	r4, [pc, #132]	; (31dac <nrfx_twim_init+0xb4>)
   31d26:	4371      	muls	r1, r6
   31d28:	1860      	adds	r0, r4, r1
   31d2a:	f890 202d 	ldrb.w	r2, [r0, #45]	; 0x2d
   31d2e:	bb9a      	cbnz	r2, 31d98 <nrfx_twim_init+0xa0>
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler         = event_handler;
    p_cb->p_context       = p_context;
   31d30:	6043      	str	r3, [r0, #4]
    p_cb->int_mask        = 0;
    p_cb->repeated        = false;
    p_cb->busy            = false;
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   31d32:	7b6b      	ldrb	r3, [r5, #13]
    p_cb->int_mask        = 0;
   31d34:	6082      	str	r2, [r0, #8]
    p_cb->repeated        = false;
   31d36:	f880 2030 	strb.w	r2, [r0, #48]	; 0x30
    p_cb->busy            = false;
   31d3a:	f880 202f 	strb.w	r2, [r0, #47]	; 0x2f
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   31d3e:	f880 3032 	strb.w	r3, [r0, #50]	; 0x32
    p_cb->handler         = event_handler;
   31d42:	f844 9001 	str.w	r9, [r4, r1]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   31d46:	4640      	mov	r0, r8
   31d48:	f7ff ffc2 	bl	31cd0 <nrf_gpio_pin_port_decode.isra.1>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   31d4c:	f240 6b0c 	movw	fp, #1548	; 0x60c
   31d50:	f108 0380 	add.w	r3, r8, #128	; 0x80
   31d54:	f840 b023 	str.w	fp, [r0, r3, lsl #2]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   31d58:	4638      	mov	r0, r7
   31d5a:	f7ff ffb9 	bl	31cd0 <nrf_gpio_pin_port_decode.isra.1>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   31d5e:	f107 0380 	add.w	r3, r7, #128	; 0x80
   31d62:	f840 b023 	str.w	fp, [r0, r3, lsl #2]
       disabled, these pins must be configured in the GPIO peripheral.
    */
    TWIM_PIN_INIT(p_config->scl);
    TWIM_PIN_INIT(p_config->sda);

    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   31d66:	f8da 0000 	ldr.w	r0, [sl]
    nrf_twim_pins_set(p_twim, p_config->scl, p_config->sda);
    nrf_twim_frequency_set(p_twim,
        (nrf_twim_frequency_t)p_config->frequency);
   31d6a:	68ab      	ldr	r3, [r5, #8]
    p_reg->PSEL.SCL = scl_pin;
   31d6c:	f8c0 8508 	str.w	r8, [r0, #1288]	; 0x508
    p_reg->PSEL.SDA = sda_pin;
   31d70:	f8c0 750c 	str.w	r7, [r0, #1292]	; 0x50c
    p_reg->FREQUENCY = frequency;
   31d74:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524

    if (p_cb->handler)
   31d78:	f1b9 0f00 	cmp.w	r9, #0
   31d7c:	d003      	beq.n	31d86 <nrfx_twim_init+0x8e>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_twim),
            p_config->interrupt_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twim));
   31d7e:	f340 3007 	sbfx	r0, r0, #12, #8
   31d82:	f7f3 f925 	bl	24fd0 <arch_irq_enable>
    }

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   31d86:	2334      	movs	r3, #52	; 0x34
   31d88:	fb03 4406 	mla	r4, r3, r6, r4
   31d8c:	2301      	movs	r3, #1

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   31d8e:	4808      	ldr	r0, [pc, #32]	; (31db0 <nrfx_twim_init+0xb8>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   31d90:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
   31d94:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return err_code;
   31d98:	4806      	ldr	r0, [pc, #24]	; (31db4 <nrfx_twim_init+0xbc>)
   31d9a:	e7fb      	b.n	31d94 <nrfx_twim_init+0x9c>
   31d9c:	0003e987 	.word	0x0003e987
   31da0:	0003eb93 	.word	0x0003eb93
   31da4:	0003ec19 	.word	0x0003ec19
   31da8:	0003ec55 	.word	0x0003ec55
   31dac:	20020f30 	.word	0x20020f30
   31db0:	0bad0000 	.word	0x0bad0000
   31db4:	0bad0005 	.word	0x0bad0005

00031db8 <nrfx_twim_enable>:
}

void nrfx_twim_enable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   31db8:	2134      	movs	r1, #52	; 0x34
{
   31dba:	b508      	push	{r3, lr}
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   31dbc:	4a0b      	ldr	r2, [pc, #44]	; (31dec <nrfx_twim_enable+0x34>)
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   31dbe:	7903      	ldrb	r3, [r0, #4]
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   31dc0:	fb01 2303 	mla	r3, r1, r3, r2
   31dc4:	f893 202d 	ldrb.w	r2, [r3, #45]	; 0x2d
   31dc8:	2a01      	cmp	r2, #1
   31dca:	d006      	beq.n	31dda <nrfx_twim_enable+0x22>
   31dcc:	4b08      	ldr	r3, [pc, #32]	; (31df0 <nrfx_twim_enable+0x38>)
   31dce:	4a09      	ldr	r2, [pc, #36]	; (31df4 <nrfx_twim_enable+0x3c>)
   31dd0:	f44f 71a3 	mov.w	r1, #326	; 0x146
   31dd4:	4808      	ldr	r0, [pc, #32]	; (31df8 <nrfx_twim_enable+0x40>)
   31dd6:	f003 fe7f 	bl	35ad8 <__assert_func>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   31dda:	2106      	movs	r1, #6

    nrf_twim_enable(p_instance->p_twim);
   31ddc:	6802      	ldr	r2, [r0, #0]
   31dde:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500

    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
   31de2:	2202      	movs	r2, #2
   31de4:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance enabled: %d.", p_instance->drv_inst_idx);
}
   31de8:	bd08      	pop	{r3, pc}
   31dea:	bf00      	nop
   31dec:	20020f30 	.word	0x20020f30
   31df0:	0003ebef 	.word	0x0003ebef
   31df4:	0003eba2 	.word	0x0003eba2
   31df8:	0003ec19 	.word	0x0003ec19

00031dfc <nrfx_twim_disable>:

void nrfx_twim_disable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   31dfc:	2134      	movs	r1, #52	; 0x34
{
   31dfe:	b508      	push	{r3, lr}
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   31e00:	4a0f      	ldr	r2, [pc, #60]	; (31e40 <nrfx_twim_disable+0x44>)
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   31e02:	7903      	ldrb	r3, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   31e04:	fb01 2303 	mla	r3, r1, r3, r2
   31e08:	f893 202d 	ldrb.w	r2, [r3, #45]	; 0x2d
   31e0c:	b932      	cbnz	r2, 31e1c <nrfx_twim_disable+0x20>
   31e0e:	4b0d      	ldr	r3, [pc, #52]	; (31e44 <nrfx_twim_disable+0x48>)
   31e10:	4a0d      	ldr	r2, [pc, #52]	; (31e48 <nrfx_twim_disable+0x4c>)
   31e12:	f240 1151 	movw	r1, #337	; 0x151
   31e16:	480d      	ldr	r0, [pc, #52]	; (31e4c <nrfx_twim_disable+0x50>)
   31e18:	f003 fe5e 	bl	35ad8 <__assert_func>

    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   31e1c:	6802      	ldr	r2, [r0, #0]
    p_cb->int_mask = 0;
   31e1e:	2000      	movs	r0, #0
    p_reg->INTENCLR = mask;
   31e20:	490b      	ldr	r1, [pc, #44]	; (31e50 <nrfx_twim_disable+0x54>)
   31e22:	6098      	str	r0, [r3, #8]
   31e24:	f8c2 1308 	str.w	r1, [r2, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
   31e28:	f8d2 1200 	ldr.w	r1, [r2, #512]	; 0x200
   31e2c:	f421 51bc 	bic.w	r1, r1, #6016	; 0x1780
   31e30:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   31e34:	f8c2 0500 	str.w	r0, [r2, #1280]	; 0x500
    nrf_twim_int_disable(p_twim, NRF_TWIM_ALL_INTS_MASK);
    nrf_twim_shorts_disable(p_twim, NRF_TWIM_ALL_SHORTS_MASK);
    nrf_twim_disable(p_twim);

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   31e38:	2201      	movs	r2, #1
   31e3a:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance disabled: %d.", p_instance->drv_inst_idx);
}
   31e3e:	bd08      	pop	{r3, pc}
   31e40:	20020f30 	.word	0x20020f30
   31e44:	0003e990 	.word	0x0003e990
   31e48:	0003ebb3 	.word	0x0003ebb3
   31e4c:	0003ec19 	.word	0x0003ec19
   31e50:	019c0202 	.word	0x019c0202

00031e54 <nrfx_twim_xfer>:


nrfx_err_t nrfx_twim_xfer(nrfx_twim_t           const * p_instance,
                          nrfx_twim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
   31e54:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    NRFX_ASSERT(TWIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   31e58:	f890 8004 	ldrb.w	r8, [r0, #4]
{
   31e5c:	460e      	mov	r6, r1
   31e5e:	4617      	mov	r7, r2
    NRFX_ASSERT(TWIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   31e60:	f1b8 0f00 	cmp.w	r8, #0
   31e64:	d107      	bne.n	31e76 <nrfx_twim_xfer+0x22>
   31e66:	684b      	ldr	r3, [r1, #4]
   31e68:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   31e6c:	d203      	bcs.n	31e76 <nrfx_twim_xfer+0x22>
   31e6e:	688b      	ldr	r3, [r1, #8]
   31e70:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   31e74:	d306      	bcc.n	31e84 <nrfx_twim_xfer+0x30>
   31e76:	f240 2163 	movw	r1, #611	; 0x263
   31e7a:	4ba9      	ldr	r3, [pc, #676]	; (32120 <nrfx_twim_xfer+0x2cc>)
   31e7c:	4aa9      	ldr	r2, [pc, #676]	; (32124 <nrfx_twim_xfer+0x2d0>)

    nrfx_err_t err_code = NRFX_SUCCESS;
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];

    // TXRX and TXTX transfers are supported only in non-blocking mode.
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWIM_XFER_TXRX)));
   31e7e:	48aa      	ldr	r0, [pc, #680]	; (32128 <nrfx_twim_xfer+0x2d4>)
   31e80:	f003 fe2a 	bl	35ad8 <__assert_func>
   31e84:	4da9      	ldr	r5, [pc, #676]	; (3212c <nrfx_twim_xfer+0x2d8>)
   31e86:	682b      	ldr	r3, [r5, #0]
   31e88:	b973      	cbnz	r3, 31ea8 <nrfx_twim_xfer+0x54>
   31e8a:	780b      	ldrb	r3, [r1, #0]
   31e8c:	2b02      	cmp	r3, #2
   31e8e:	d104      	bne.n	31e9a <nrfx_twim_xfer+0x46>
   31e90:	4ba7      	ldr	r3, [pc, #668]	; (32130 <nrfx_twim_xfer+0x2dc>)
   31e92:	4aa4      	ldr	r2, [pc, #656]	; (32124 <nrfx_twim_xfer+0x2d0>)
   31e94:	f240 2169 	movw	r1, #617	; 0x269
   31e98:	e7f1      	b.n	31e7e <nrfx_twim_xfer+0x2a>
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWIM_XFER_TXTX)));
   31e9a:	2b03      	cmp	r3, #3
   31e9c:	d104      	bne.n	31ea8 <nrfx_twim_xfer+0x54>
   31e9e:	4ba5      	ldr	r3, [pc, #660]	; (32134 <nrfx_twim_xfer+0x2e0>)
   31ea0:	4aa0      	ldr	r2, [pc, #640]	; (32124 <nrfx_twim_xfer+0x2d0>)
   31ea2:	f240 216a 	movw	r1, #618	; 0x26a
   31ea6:	e7ea      	b.n	31e7e <nrfx_twim_xfer+0x2a>
    p_cb->error = false;
   31ea8:	2300      	movs	r3, #0
                           p_xfer_desc->primary_length * sizeof(p_xfer_desc->p_primary_buf[0]));
    NRFX_LOG_DEBUG("Secondary buffer data:");
    NRFX_LOG_HEXDUMP_DEBUG(p_xfer_desc->p_secondary_buf,
                           p_xfer_desc->secondary_length * sizeof(p_xfer_desc->p_secondary_buf[0]));

    err_code = twim_xfer(p_cb, (NRF_TWIM_Type *)p_instance->p_twim, p_xfer_desc, flags);
   31eaa:	6804      	ldr	r4, [r0, #0]
    p_cb->error = false;
   31eac:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e
   31eb0:	68f3      	ldr	r3, [r6, #12]
   31eb2:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
    if (!nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   31eb6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   31eba:	d003      	beq.n	31ec4 <nrfx_twim_xfer+0x70>
        return err_code;
   31ebc:	4e9e      	ldr	r6, [pc, #632]	; (32138 <nrfx_twim_xfer+0x2e4>)
    NRFX_LOG_WARNING("Function: %s, error code: %s.",
                     __func__,
                     NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   31ebe:	4630      	mov	r0, r6
   31ec0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    p_reg->INTENCLR = mask;
   31ec4:	4b9d      	ldr	r3, [pc, #628]	; (3213c <nrfx_twim_xfer+0x2e8>)
   31ec6:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    if (p_cb->busy)
   31eca:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
   31ece:	f003 09ff 	and.w	r9, r3, #255	; 0xff
   31ed2:	b123      	cbz	r3, 31ede <nrfx_twim_xfer+0x8a>
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   31ed4:	68ab      	ldr	r3, [r5, #8]
        return err_code;
   31ed6:	4e9a      	ldr	r6, [pc, #616]	; (32140 <nrfx_twim_xfer+0x2ec>)
    p_reg->INTENSET = mask;
   31ed8:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   31edc:	e7ef      	b.n	31ebe <nrfx_twim_xfer+0x6a>
                      (NRFX_TWIM_FLAG_REPEATED_XFER & flags)) ? false: true;
   31ede:	f017 0f14 	tst.w	r7, #20
   31ee2:	bf0c      	ite	eq
   31ee4:	2301      	moveq	r3, #1
   31ee6:	2300      	movne	r3, #0
    p_cb->xfer_desc = *p_xfer_desc;
   31ee8:	46b6      	mov	lr, r6
   31eea:	f8df c27c 	ldr.w	ip, [pc, #636]	; 32168 <nrfx_twim_xfer+0x314>
        p_cb->busy = ((NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER & flags) ||
   31eee:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    p_cb->xfer_desc = *p_xfer_desc;
   31ef2:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   31ef6:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   31efa:	f8de 3000 	ldr.w	r3, [lr]
    p_cb->flags = flags;
   31efe:	622f      	str	r7, [r5, #32]
    p_cb->xfer_desc = *p_xfer_desc;
   31f00:	f8cc 3000 	str.w	r3, [ip]
    p_cb->repeated = (flags & NRFX_TWIM_FLAG_REPEATED_XFER) ? true : false;
   31f04:	f3c7 1300 	ubfx	r3, r7, #4, #1
   31f08:	f885 3030 	strb.w	r3, [r5, #48]	; 0x30
}

NRF_STATIC_INLINE void nrf_twim_address_set(NRF_TWIM_Type * p_reg,
                                            uint8_t address)
{
    p_reg->ADDRESS = address;
   31f0c:	7873      	ldrb	r3, [r6, #1]
   31f0e:	f8c4 3588 	str.w	r3, [r4, #1416]	; 0x588
    if (NRFX_TWIM_FLAG_TX_POSTINC & flags)
   31f12:	f017 0301 	ands.w	r3, r7, #1
    return p_reg->RXD.AMOUNT;
}

NRF_STATIC_INLINE void nrf_twim_tx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_ArrayList << TWIM_TXD_LIST_LIST_Pos;
   31f16:	bf18      	it	ne
   31f18:	2301      	movne	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   31f1a:	f8c4 9104 	str.w	r9, [r4, #260]	; 0x104
   31f1e:	f8c4 9124 	str.w	r9, [r4, #292]	; 0x124
   31f22:	f8c4 9160 	str.w	r9, [r4, #352]	; 0x160
   31f26:	f8c4 9148 	str.w	r9, [r4, #328]	; 0x148
}

NRF_STATIC_INLINE void nrf_twim_tx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_Disabled << TWIM_TXD_LIST_LIST_Pos;
   31f2a:	f8c4 3550 	str.w	r3, [r4, #1360]	; 0x550
    if (NRFX_TWIM_FLAG_RX_POSTINC & flags)
   31f2e:	f017 0302 	ands.w	r3, r7, #2
}

NRF_STATIC_INLINE void nrf_twim_rx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_ArrayList << TWIM_RXD_LIST_LIST_Pos;
   31f32:	bf18      	it	ne
   31f34:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_rx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_Disabled << TWIM_RXD_LIST_LIST_Pos;
   31f36:	f8c4 3540 	str.w	r3, [r4, #1344]	; 0x540
    switch (p_xfer_desc->type)
   31f3a:	7833      	ldrb	r3, [r6, #0]
   31f3c:	2b03      	cmp	r3, #3
   31f3e:	f200 80ac 	bhi.w	3209a <nrfx_twim_xfer+0x246>
   31f42:	e8df f003 	tbb	[pc, r3]
   31f46:	9b86      	.short	0x9b86
   31f48:	026e      	.short	0x026e
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_REPEATED_XFER));
   31f4a:	06f9      	lsls	r1, r7, #27
   31f4c:	d504      	bpl.n	31f58 <nrfx_twim_xfer+0x104>
   31f4e:	4b7d      	ldr	r3, [pc, #500]	; (32144 <nrfx_twim_xfer+0x2f0>)
   31f50:	4a7d      	ldr	r2, [pc, #500]	; (32148 <nrfx_twim_xfer+0x2f4>)
   31f52:	f240 11a9 	movw	r1, #425	; 0x1a9
   31f56:	e792      	b.n	31e7e <nrfx_twim_xfer+0x2a>
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_HOLD_XFER));
   31f58:	073a      	lsls	r2, r7, #28
   31f5a:	d504      	bpl.n	31f66 <nrfx_twim_xfer+0x112>
   31f5c:	4b7b      	ldr	r3, [pc, #492]	; (3214c <nrfx_twim_xfer+0x2f8>)
   31f5e:	4a7a      	ldr	r2, [pc, #488]	; (32148 <nrfx_twim_xfer+0x2f4>)
   31f60:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
   31f64:	e78b      	b.n	31e7e <nrfx_twim_xfer+0x2a>
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER));
   31f66:	f017 0c04 	ands.w	ip, r7, #4
   31f6a:	d004      	beq.n	31f76 <nrfx_twim_xfer+0x122>
   31f6c:	4b78      	ldr	r3, [pc, #480]	; (32150 <nrfx_twim_xfer+0x2fc>)
   31f6e:	4a76      	ldr	r2, [pc, #472]	; (32148 <nrfx_twim_xfer+0x2f4>)
   31f70:	f240 11ab 	movw	r1, #427	; 0x1ab
   31f74:	e783      	b.n	31e7e <nrfx_twim_xfer+0x2a>
   31f76:	6932      	ldr	r2, [r6, #16]
   31f78:	f002 4060 	and.w	r0, r2, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   31f7c:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
   31f80:	d19c      	bne.n	31ebc <nrfx_twim_xfer+0x68>
    p_reg->SHORTS = mask;
   31f82:	f44f 7080 	mov.w	r0, #256	; 0x100
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   31f86:	68f1      	ldr	r1, [r6, #12]
    p_reg->SHORTS = mask;
   31f88:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   31f8c:	6870      	ldr	r0, [r6, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   31f8e:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   31f92:	2101      	movs	r1, #1
    p_reg->TXD.MAXCNT = length;
   31f94:	f8c4 0548 	str.w	r0, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   31f98:	f8c4 c150 	str.w	ip, [r4, #336]	; 0x150
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   31f9c:	6221      	str	r1, [r4, #32]
   31f9e:	60a1      	str	r1, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   31fa0:	f8d4 1150 	ldr.w	r1, [r4, #336]	; 0x150
        while (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_TXSTARTED))
   31fa4:	2900      	cmp	r1, #0
   31fa6:	d0fb      	beq.n	31fa0 <nrfx_twim_xfer+0x14c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   31fa8:	2100      	movs	r1, #0
   31faa:	f8c4 1150 	str.w	r1, [r4, #336]	; 0x150
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   31fae:	68b1      	ldr	r1, [r6, #8]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   31fb0:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
        p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   31fb4:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    p_reg->TXD.MAXCNT = length;
   31fb8:	f8c4 1548 	str.w	r1, [r4, #1352]	; 0x548
   31fbc:	60aa      	str	r2, [r5, #8]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   31fbe:	f04f 0808 	mov.w	r8, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
   31fc2:	4e64      	ldr	r6, [pc, #400]	; (32154 <nrfx_twim_xfer+0x300>)
    if (!(flags & NRFX_TWIM_FLAG_HOLD_XFER) && (p_xfer_desc->type != NRFX_TWIM_XFER_TXTX))
   31fc4:	0739      	lsls	r1, r7, #28
   31fc6:	d404      	bmi.n	31fd2 <nrfx_twim_xfer+0x17e>
   31fc8:	2b03      	cmp	r3, #3
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   31fca:	bf1c      	itt	ne
   31fcc:	2301      	movne	r3, #1
   31fce:	f844 3008 	strne.w	r3, [r4, r8]
    if (p_cb->handler)
   31fd2:	682b      	ldr	r3, [r5, #0]
   31fd4:	2b00      	cmp	r3, #0
   31fd6:	d164      	bne.n	320a2 <nrfx_twim_xfer+0x24e>
                transmission_finished = true;
   31fd8:	2101      	movs	r1, #1
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   31fda:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
   31fde:	f8d4 0104 	ldr.w	r0, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   31fe2:	2800      	cmp	r0, #0
   31fe4:	d16f      	bne.n	320c6 <nrfx_twim_xfer+0x272>
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_SUSPENDED))
   31fe6:	3200      	adds	r2, #0
   31fe8:	bf18      	it	ne
   31fea:	2201      	movne	r2, #1
   31fec:	f8d4 0124 	ldr.w	r0, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   31ff0:	2800      	cmp	r0, #0
   31ff2:	d06c      	beq.n	320ce <nrfx_twim_xfer+0x27a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   31ff4:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   31ff8:	f8d4 c160 	ldr.w	ip, [r4, #352]	; 0x160
    return p_reg->SHORTS;
   31ffc:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
                if (!(lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_STOP_MASK)))
   32000:	f1bc 0f00 	cmp.w	ip, #0
   32004:	d002      	beq.n	3200c <nrfx_twim_xfer+0x1b8>
   32006:	f410 7f00 	tst.w	r0, #512	; 0x200
   3200a:	d105      	bne.n	32018 <nrfx_twim_xfer+0x1c4>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   3200c:	6221      	str	r1, [r4, #32]
   3200e:	6161      	str	r1, [r4, #20]
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   32010:	f1bc 0f00 	cmp.w	ip, #0
   32014:	d0e1      	beq.n	31fda <nrfx_twim_xfer+0x186>
                    transmission_finished = false;
   32016:	2200      	movs	r2, #0
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   32018:	05c0      	lsls	r0, r0, #23
   3201a:	d558      	bpl.n	320ce <nrfx_twim_xfer+0x27a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   3201c:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
                    transmission_finished = false;
   32020:	e7db      	b.n	31fda <nrfx_twim_xfer+0x186>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   32022:	6872      	ldr	r2, [r6, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   32024:	68f1      	ldr	r1, [r6, #12]
   32026:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   3202a:	f8c4 2548 	str.w	r2, [r4, #1352]	; 0x548
   3202e:	6932      	ldr	r2, [r6, #16]
   32030:	f002 4160 	and.w	r1, r2, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   32034:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
   32038:	f47f af40 	bne.w	31ebc <nrfx_twim_xfer+0x68>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   3203c:	68b1      	ldr	r1, [r6, #8]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   3203e:	f8c4 2534 	str.w	r2, [r4, #1332]	; 0x534
    p_reg->SHORTS = mask;
   32042:	f44f 5284 	mov.w	r2, #4224	; 0x1080
    p_reg->RXD.MAXCNT = length;
   32046:	f8c4 1538 	str.w	r1, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   3204a:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   3204e:	2202      	movs	r2, #2
   32050:	e00d      	b.n	3206e <nrfx_twim_xfer+0x21a>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   32052:	6872      	ldr	r2, [r6, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   32054:	68f1      	ldr	r1, [r6, #12]
        if (NRFX_TWIM_FLAG_TX_NO_STOP & flags)
   32056:	06b8      	lsls	r0, r7, #26
   32058:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   3205c:	f8c4 2548 	str.w	r2, [r4, #1352]	; 0x548
   32060:	d509      	bpl.n	32076 <nrfx_twim_xfer+0x222>
    p_reg->SHORTS = mask;
   32062:	f44f 7280 	mov.w	r2, #256	; 0x100
   32066:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   3206a:	f44f 2280 	mov.w	r2, #262144	; 0x40000
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   3206e:	60aa      	str	r2, [r5, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   32070:	2201      	movs	r2, #1
   32072:	6222      	str	r2, [r4, #32]
   32074:	e7a3      	b.n	31fbe <nrfx_twim_xfer+0x16a>
    p_reg->SHORTS = mask;
   32076:	f44f 7200 	mov.w	r2, #512	; 0x200
   3207a:	e7e6      	b.n	3204a <nrfx_twim_xfer+0x1f6>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   3207c:	6872      	ldr	r2, [r6, #4]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   3207e:	68f1      	ldr	r1, [r6, #12]
   32080:	f8c4 1534 	str.w	r1, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   32084:	f8c4 2538 	str.w	r2, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   32088:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   3208c:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   32090:	2202      	movs	r2, #2
   32092:	60aa      	str	r2, [r5, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   32094:	2201      	movs	r2, #1
   32096:	6222      	str	r2, [r4, #32]
   32098:	e793      	b.n	31fc2 <nrfx_twim_xfer+0x16e>
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   3209a:	f04f 0808 	mov.w	r8, #8
        err_code = NRFX_ERROR_INVALID_PARAM;
   3209e:	4e2e      	ldr	r6, [pc, #184]	; (32158 <nrfx_twim_xfer+0x304>)
   320a0:	e790      	b.n	31fc4 <nrfx_twim_xfer+0x170>
        if (flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER)
   320a2:	077a      	lsls	r2, r7, #29
            p_cb->int_mask = 0;
   320a4:	bf44      	itt	mi
   320a6:	2300      	movmi	r3, #0
   320a8:	60ab      	strmi	r3, [r5, #8]
        if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK))
   320aa:	067b      	lsls	r3, r7, #25
            p_cb->int_mask |= NRF_TWIM_INT_STOPPED_MASK;
   320ac:	bf5e      	ittt	pl
   320ae:	68ab      	ldrpl	r3, [r5, #8]
   320b0:	f043 0302 	orrpl.w	r3, r3, #2
   320b4:	60ab      	strpl	r3, [r5, #8]
        p_cb->int_mask |= NRF_TWIM_INT_ERROR_MASK;
   320b6:	68ab      	ldr	r3, [r5, #8]
   320b8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   320bc:	60ab      	str	r3, [r5, #8]
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   320be:	68ab      	ldr	r3, [r5, #8]
    p_reg->INTENSET = mask;
   320c0:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   320c4:	e6fb      	b.n	31ebe <nrfx_twim_xfer+0x6a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   320c6:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
                transmission_finished = true;
   320ca:	2201      	movs	r2, #1
   320cc:	e78e      	b.n	31fec <nrfx_twim_xfer+0x198>
        } while (!transmission_finished);
   320ce:	2a00      	cmp	r2, #0
   320d0:	d083      	beq.n	31fda <nrfx_twim_xfer+0x186>
        p_cb->busy = false;
   320d2:	2200      	movs	r2, #0
    uint32_t error_source = p_reg->ERRORSRC;
   320d4:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   320d8:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
   320dc:	f885 202f 	strb.w	r2, [r5, #47]	; 0x2f
        if (errorsrc)
   320e0:	b18b      	cbz	r3, 32106 <nrfx_twim_xfer+0x2b2>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
   320e2:	4a1e      	ldr	r2, [pc, #120]	; (3215c <nrfx_twim_xfer+0x308>)
   320e4:	f013 0f01 	tst.w	r3, #1
   320e8:	4e1d      	ldr	r6, [pc, #116]	; (32160 <nrfx_twim_xfer+0x30c>)
   320ea:	bf18      	it	ne
   320ec:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   320ee:	f013 0f02 	tst.w	r3, #2
   320f2:	f102 0201 	add.w	r2, r2, #1
   320f6:	bf18      	it	ne
   320f8:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   320fa:	f013 0f04 	tst.w	r3, #4
   320fe:	4b19      	ldr	r3, [pc, #100]	; (32164 <nrfx_twim_xfer+0x310>)
   32100:	bf18      	it	ne
   32102:	461e      	movne	r6, r3
   32104:	e6db      	b.n	31ebe <nrfx_twim_xfer+0x6a>
            if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) &&
   32106:	067b      	lsls	r3, r7, #25
   32108:	f53f aed9 	bmi.w	31ebe <nrfx_twim_xfer+0x6a>
                !xfer_completeness_check(p_twim, p_cb))
   3210c:	4907      	ldr	r1, [pc, #28]	; (3212c <nrfx_twim_xfer+0x2d8>)
   3210e:	4620      	mov	r0, r4
   32110:	f007 fc25 	bl	3995e <xfer_completeness_check>
                err_code = NRFX_ERROR_INTERNAL;
   32114:	4b12      	ldr	r3, [pc, #72]	; (32160 <nrfx_twim_xfer+0x30c>)
   32116:	2800      	cmp	r0, #0
   32118:	bf08      	it	eq
   3211a:	461e      	moveq	r6, r3
   3211c:	e6cf      	b.n	31ebe <nrfx_twim_xfer+0x6a>
   3211e:	bf00      	nop
   32120:	0003ec74 	.word	0x0003ec74
   32124:	0003ebcf 	.word	0x0003ebcf
   32128:	0003ec19 	.word	0x0003ec19
   3212c:	20020f30 	.word	0x20020f30
   32130:	0003ed1f 	.word	0x0003ed1f
   32134:	0003ed6f 	.word	0x0003ed6f
   32138:	0bad000a 	.word	0x0bad000a
   3213c:	019c0202 	.word	0x019c0202
   32140:	0bad000b 	.word	0x0bad000b
   32144:	0003edbf 	.word	0x0003edbf
   32148:	0003ebc5 	.word	0x0003ebc5
   3214c:	0003edd5 	.word	0x0003edd5
   32150:	0003edeb 	.word	0x0003edeb
   32154:	0bad0000 	.word	0x0bad0000
   32158:	0bad0004 	.word	0x0bad0004
   3215c:	0bae0000 	.word	0x0bae0000
   32160:	0bad0001 	.word	0x0bad0001
   32164:	0bae0002 	.word	0x0bae0002
   32168:	20020f3c 	.word	0x20020f3c

0003216c <nrfx_twim_1_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_TWIM1_ENABLED)
void nrfx_twim_1_irq_handler(void)
{
   3216c:	b5f0      	push	{r4, r5, r6, r7, lr}
    NRFX_ASSERT(p_cb->handler);
   3216e:	4c5b      	ldr	r4, [pc, #364]	; (322dc <nrfx_twim_1_irq_handler+0x170>)
{
   32170:	b087      	sub	sp, #28
    NRFX_ASSERT(p_cb->handler);
   32172:	6823      	ldr	r3, [r4, #0]
   32174:	b933      	cbnz	r3, 32184 <nrfx_twim_1_irq_handler+0x18>
   32176:	4b5a      	ldr	r3, [pc, #360]	; (322e0 <nrfx_twim_1_irq_handler+0x174>)
   32178:	4a5a      	ldr	r2, [pc, #360]	; (322e4 <nrfx_twim_1_irq_handler+0x178>)
   3217a:	f44f 7129 	mov.w	r1, #676	; 0x2a4
   3217e:	485a      	ldr	r0, [pc, #360]	; (322e8 <nrfx_twim_1_irq_handler+0x17c>)
   32180:	f003 fcaa 	bl	35ad8 <__assert_func>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   32184:	4b59      	ldr	r3, [pc, #356]	; (322ec <nrfx_twim_1_irq_handler+0x180>)
   32186:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
   3218a:	461d      	mov	r5, r3
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   3218c:	b1ea      	cbz	r2, 321ca <nrfx_twim_1_irq_handler+0x5e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   3218e:	2200      	movs	r2, #0
   32190:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   32194:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
        if (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   32198:	b9ba      	cbnz	r2, 321ca <nrfx_twim_1_irq_handler+0x5e>
            nrf_twim_int_disable(p_twim, p_cb->int_mask);
   3219a:	68a2      	ldr	r2, [r4, #8]
    p_reg->INTENCLR = mask;
   3219c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   321a0:	2202      	movs	r2, #2
   321a2:	60a2      	str	r2, [r4, #8]
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   321a4:	68a2      	ldr	r2, [r4, #8]
    p_reg->INTENSET = mask;
   321a6:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   321aa:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
            if (!(nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_LASTTX) &&
   321ae:	b11a      	cbz	r2, 321b8 <nrfx_twim_1_irq_handler+0x4c>
    return p_reg->SHORTS;
   321b0:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
   321b4:	059e      	lsls	r6, r3, #22
   321b6:	d403      	bmi.n	321c0 <nrfx_twim_1_irq_handler+0x54>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   321b8:	2201      	movs	r2, #1
   321ba:	4b4c      	ldr	r3, [pc, #304]	; (322ec <nrfx_twim_1_irq_handler+0x180>)
   321bc:	621a      	str	r2, [r3, #32]
   321be:	615a      	str	r2, [r3, #20]
            p_cb->error = true;
   321c0:	2301      	movs	r3, #1
   321c2:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
    twim_irq_handler(NRF_TWIM1, &m_cb[NRFX_TWIM1_INST_IDX]);
}
   321c6:	b007      	add	sp, #28
   321c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   321ca:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   321ce:	2b00      	cmp	r3, #0
   321d0:	d04e      	beq.n	32270 <nrfx_twim_1_irq_handler+0x104>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   321d2:	2300      	movs	r3, #0
   321d4:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) && !p_cb->error)
   321d8:	6a23      	ldr	r3, [r4, #32]
   321da:	065d      	lsls	r5, r3, #25
   321dc:	d40a      	bmi.n	321f4 <nrfx_twim_1_irq_handler+0x88>
   321de:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   321e2:	b93b      	cbnz	r3, 321f4 <nrfx_twim_1_irq_handler+0x88>
            p_cb->error = !xfer_completeness_check(p_twim, p_cb);
   321e4:	493d      	ldr	r1, [pc, #244]	; (322dc <nrfx_twim_1_irq_handler+0x170>)
   321e6:	4841      	ldr	r0, [pc, #260]	; (322ec <nrfx_twim_1_irq_handler+0x180>)
   321e8:	f007 fbb9 	bl	3995e <xfer_completeness_check>
   321ec:	f080 0001 	eor.w	r0, r0, #1
   321f0:	f884 002e 	strb.w	r0, [r4, #46]	; 0x2e
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
   321f4:	6a23      	ldr	r3, [r4, #32]
   321f6:	f013 0704 	ands.w	r7, r3, #4
   321fa:	d11e      	bne.n	3223a <nrfx_twim_1_irq_handler+0xce>
            event.xfer_desc = p_cb->xfer_desc;
   321fc:	4e3c      	ldr	r6, [pc, #240]	; (322f0 <nrfx_twim_1_irq_handler+0x184>)
   321fe:	ad01      	add	r5, sp, #4
   32200:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   32202:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   32204:	6833      	ldr	r3, [r6, #0]
   32206:	f894 c030 	ldrb.w	ip, [r4, #48]	; 0x30
   3220a:	602b      	str	r3, [r5, #0]
   3220c:	4b37      	ldr	r3, [pc, #220]	; (322ec <nrfx_twim_1_irq_handler+0x180>)
   3220e:	f8c3 7160 	str.w	r7, [r3, #352]	; 0x160
   32212:	f8c3 715c 	str.w	r7, [r3, #348]	; 0x15c
            if (!p_cb->repeated || p_cb->error)
   32216:	f1bc 0f00 	cmp.w	ip, #0
   3221a:	d002      	beq.n	32222 <nrfx_twim_1_irq_handler+0xb6>
   3221c:	f894 202e 	ldrb.w	r2, [r4, #46]	; 0x2e
   32220:	b15a      	cbz	r2, 3223a <nrfx_twim_1_irq_handler+0xce>
    p_reg->SHORTS = mask;
   32222:	2200      	movs	r2, #0
   32224:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
                p_cb->int_mask = 0;
   32228:	60a2      	str	r2, [r4, #8]
    p_reg->INTENCLR = mask;
   3222a:	4a32      	ldr	r2, [pc, #200]	; (322f4 <nrfx_twim_1_irq_handler+0x188>)
   3222c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   32230:	f44f 7200 	mov.w	r2, #512	; 0x200
   32234:	4b30      	ldr	r3, [pc, #192]	; (322f8 <nrfx_twim_1_irq_handler+0x18c>)
   32236:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    uint32_t error_source = p_reg->ERRORSRC;
   3223a:	4a2c      	ldr	r2, [pc, #176]	; (322ec <nrfx_twim_1_irq_handler+0x180>)
   3223c:	f8d2 34c4 	ldr.w	r3, [r2, #1220]	; 0x4c4
    if (errorsrc & NRF_TWIM_ERROR_ADDRESS_NACK)
   32240:	0798      	lsls	r0, r3, #30
    p_reg->ERRORSRC = error_source;
   32242:	f8c2 34c4 	str.w	r3, [r2, #1220]	; 0x4c4
   32246:	d53a      	bpl.n	322be <nrfx_twim_1_irq_handler+0x152>
        event.type = NRFX_TWIM_EVT_ADDRESS_NACK;
   32248:	2301      	movs	r3, #1
        event.type = NRFX_TWIM_EVT_DONE;
   3224a:	f88d 3000 	strb.w	r3, [sp]
    if (!p_cb->repeated)
   3224e:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   32252:	b90b      	cbnz	r3, 32258 <nrfx_twim_1_irq_handler+0xec>
        p_cb->busy = false;
   32254:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
    if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER) || p_cb->error)
   32258:	6a23      	ldr	r3, [r4, #32]
   3225a:	075b      	lsls	r3, r3, #29
   3225c:	d503      	bpl.n	32266 <nrfx_twim_1_irq_handler+0xfa>
   3225e:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   32262:	2b00      	cmp	r3, #0
   32264:	d0af      	beq.n	321c6 <nrfx_twim_1_irq_handler+0x5a>
        p_cb->handler(&event, p_cb->p_context);
   32266:	e9d4 3100 	ldrd	r3, r1, [r4]
   3226a:	4668      	mov	r0, sp
   3226c:	4798      	blx	r3
}
   3226e:	e7aa      	b.n	321c6 <nrfx_twim_1_irq_handler+0x5a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   32270:	f8c5 3148 	str.w	r3, [r5, #328]	; 0x148
        if (p_cb->xfer_desc.type == NRFX_TWIM_XFER_TX)
   32274:	7b23      	ldrb	r3, [r4, #12]
   32276:	b983      	cbnz	r3, 3229a <nrfx_twim_1_irq_handler+0x12e>
            event.xfer_desc = p_cb->xfer_desc;
   32278:	4f1d      	ldr	r7, [pc, #116]	; (322f0 <nrfx_twim_1_irq_handler+0x184>)
   3227a:	ae01      	add	r6, sp, #4
   3227c:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
   3227e:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   32280:	683b      	ldr	r3, [r7, #0]
   32282:	6033      	str	r3, [r6, #0]
            if (!p_cb->repeated)
   32284:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   32288:	2b00      	cmp	r3, #0
   3228a:	d1d6      	bne.n	3223a <nrfx_twim_1_irq_handler+0xce>
    p_reg->SHORTS = mask;
   3228c:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
                p_cb->int_mask = 0;
   32290:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   32292:	4b18      	ldr	r3, [pc, #96]	; (322f4 <nrfx_twim_1_irq_handler+0x188>)
   32294:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
   32298:	e7ca      	b.n	32230 <nrfx_twim_1_irq_handler+0xc4>
    p_reg->SHORTS = mask;
   3229a:	f44f 7300 	mov.w	r3, #512	; 0x200
   3229e:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK | NRF_TWIM_INT_ERROR_MASK;
   322a2:	f240 2302 	movw	r3, #514	; 0x202
   322a6:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   322a8:	f103 73ce 	add.w	r3, r3, #27000832	; 0x19c0000
   322ac:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   322b0:	68a3      	ldr	r3, [r4, #8]
    p_reg->INTENSET = mask;
   322b2:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   322b6:	2301      	movs	r3, #1
   322b8:	60ab      	str	r3, [r5, #8]
   322ba:	622b      	str	r3, [r5, #32]
            return;
   322bc:	e783      	b.n	321c6 <nrfx_twim_1_irq_handler+0x5a>
    else if (errorsrc & NRF_TWIM_ERROR_DATA_NACK)
   322be:	0759      	lsls	r1, r3, #29
   322c0:	d501      	bpl.n	322c6 <nrfx_twim_1_irq_handler+0x15a>
        event.type = NRFX_TWIM_EVT_DATA_NACK;
   322c2:	2302      	movs	r3, #2
   322c4:	e7c1      	b.n	3224a <nrfx_twim_1_irq_handler+0xde>
    else if (errorsrc & NRF_TWIM_ERROR_OVERRUN)
   322c6:	07da      	lsls	r2, r3, #31
   322c8:	d501      	bpl.n	322ce <nrfx_twim_1_irq_handler+0x162>
        event.type = NRFX_TWIM_EVT_OVERRUN;
   322ca:	2303      	movs	r3, #3
   322cc:	e7bd      	b.n	3224a <nrfx_twim_1_irq_handler+0xde>
    else if (p_cb->error)
   322ce:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   322d2:	2b00      	cmp	r3, #0
   322d4:	d0b9      	beq.n	3224a <nrfx_twim_1_irq_handler+0xde>
        event.type = NRFX_TWIM_EVT_BUS_ERROR;
   322d6:	2304      	movs	r3, #4
   322d8:	e7b7      	b.n	3224a <nrfx_twim_1_irq_handler+0xde>
   322da:	bf00      	nop
   322dc:	20020f30 	.word	0x20020f30
   322e0:	0003e93d 	.word	0x0003e93d
   322e4:	0003ebde 	.word	0x0003ebde
   322e8:	0003ec19 	.word	0x0003ec19
   322ec:	40009000 	.word	0x40009000
   322f0:	20020f3c 	.word	0x20020f3c
   322f4:	019c0202 	.word	0x019c0202
   322f8:	e000e100 	.word	0xe000e100

000322fc <z_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_device_do_config_level(s32_t level)
{
   322fc:	b570      	push	{r4, r5, r6, lr}
		retval = device_conf->init(info);
		if (retval != 0) {
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
   322fe:	2600      	movs	r6, #0
	for (info = config_levels[level]; info < config_levels[level+1];
   32300:	4b08      	ldr	r3, [pc, #32]	; (32324 <z_sys_device_do_config_level+0x28>)
   32302:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   32306:	3001      	adds	r0, #1
   32308:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
   3230c:	42a5      	cmp	r5, r4
   3230e:	d800      	bhi.n	32312 <z_sys_device_do_config_level+0x16>
		} else {
			z_object_init(info);
		}
	}
}
   32310:	bd70      	pop	{r4, r5, r6, pc}
		retval = device_conf->init(info);
   32312:	6823      	ldr	r3, [r4, #0]
   32314:	4620      	mov	r0, r4
   32316:	685b      	ldr	r3, [r3, #4]
   32318:	4798      	blx	r3
		if (retval != 0) {
   3231a:	b100      	cbz	r0, 3231e <z_sys_device_do_config_level+0x22>
			info->driver_api = NULL;
   3231c:	6066      	str	r6, [r4, #4]
								info++) {
   3231e:	340c      	adds	r4, #12
   32320:	e7f4      	b.n	3230c <z_sys_device_do_config_level+0x10>
   32322:	bf00      	nop
   32324:	0003b834 	.word	0x0003b834

00032328 <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
   32328:	4b10      	ldr	r3, [pc, #64]	; (3236c <z_impl_device_get_binding+0x44>)
{
   3232a:	b570      	push	{r4, r5, r6, lr}
   3232c:	4605      	mov	r5, r0
   3232e:	461e      	mov	r6, r3
	for (info = __device_init_start; info != __device_init_end; info++) {
   32330:	4c0f      	ldr	r4, [pc, #60]	; (32370 <z_impl_device_get_binding+0x48>)
   32332:	429c      	cmp	r4, r3
   32334:	d104      	bne.n	32340 <z_impl_device_get_binding+0x18>
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
   32336:	4c0e      	ldr	r4, [pc, #56]	; (32370 <z_impl_device_get_binding+0x48>)
   32338:	42b4      	cmp	r4, r6
   3233a:	d109      	bne.n	32350 <z_impl_device_get_binding+0x28>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
   3233c:	2400      	movs	r4, #0
   3233e:	e012      	b.n	32366 <z_impl_device_get_binding+0x3e>
		if ((info->driver_api != NULL) &&
   32340:	6862      	ldr	r2, [r4, #4]
   32342:	b11a      	cbz	r2, 3234c <z_impl_device_get_binding+0x24>
		    (info->config->name == name)) {
   32344:	6822      	ldr	r2, [r4, #0]
		if ((info->driver_api != NULL) &&
   32346:	6812      	ldr	r2, [r2, #0]
   32348:	42aa      	cmp	r2, r5
   3234a:	d00c      	beq.n	32366 <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
   3234c:	340c      	adds	r4, #12
   3234e:	e7f0      	b.n	32332 <z_impl_device_get_binding+0xa>
		if (info->driver_api == NULL) {
   32350:	6863      	ldr	r3, [r4, #4]
   32352:	b90b      	cbnz	r3, 32358 <z_impl_device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
   32354:	340c      	adds	r4, #12
   32356:	e7ef      	b.n	32338 <z_impl_device_get_binding+0x10>
		if (strcmp(name, info->config->name) == 0) {
   32358:	6823      	ldr	r3, [r4, #0]
   3235a:	4628      	mov	r0, r5
   3235c:	6819      	ldr	r1, [r3, #0]
   3235e:	f7ea fef1 	bl	1d144 <strcmp>
   32362:	2800      	cmp	r0, #0
   32364:	d1f6      	bne.n	32354 <z_impl_device_get_binding+0x2c>
}
   32366:	4620      	mov	r0, r4
   32368:	bd70      	pop	{r4, r5, r6, pc}
   3236a:	bf00      	nop
   3236c:	2002cb54 	.word	0x2002cb54
   32370:	2002ca40 	.word	0x2002ca40

00032374 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   32374:	4b01      	ldr	r3, [pc, #4]	; (3237c <z_impl_z_errno+0x8>)
   32376:	6898      	ldr	r0, [r3, #8]
}
   32378:	3054      	adds	r0, #84	; 0x54
   3237a:	4770      	bx	lr
   3237c:	20022108 	.word	0x20022108

00032380 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   32380:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   32384:	4605      	mov	r5, r0
   32386:	4688      	mov	r8, r1
	return z_impl_k_current_get();
   32388:	f002 f95a 	bl	34640 <z_impl_k_current_get>
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   3238c:	2301      	movs	r3, #1
   3238e:	4606      	mov	r6, r0
   32390:	f04f 0000 	mov.w	r0, #0
   32394:	2200      	movs	r2, #0
   32396:	f363 0007 	bfi	r0, r3, #0, #8
   3239a:	4c2b      	ldr	r4, [pc, #172]	; (32448 <z_fatal_error+0xc8>)
   3239c:	4b2b      	ldr	r3, [pc, #172]	; (3244c <z_fatal_error+0xcc>)
   3239e:	2d04      	cmp	r5, #4
   323a0:	eba4 0403 	sub.w	r4, r4, r3
   323a4:	bf98      	it	ls
   323a6:	4b2a      	ldrls	r3, [pc, #168]	; (32450 <z_fatal_error+0xd0>)
   323a8:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   323ac:	bf94      	ite	ls
   323ae:	f853 3025 	ldrls.w	r3, [r3, r5, lsl #2]
   323b2:	4b28      	ldrhi	r3, [pc, #160]	; (32454 <z_fatal_error+0xd4>)
   323b4:	9200      	str	r2, [sp, #0]
   323b6:	f364 108f 	bfi	r0, r4, #6, #10
   323ba:	462a      	mov	r2, r5
   323bc:	4926      	ldr	r1, [pc, #152]	; (32458 <z_fatal_error+0xd8>)
   323be:	f005 fcd6 	bl	37d6e <log_string_sync>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   323c2:	f8d8 301c 	ldr.w	r3, [r8, #28]
   323c6:	f3c3 0308 	ubfx	r3, r3, #0, #9
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if (arch_is_in_nested_exception(esf)) {
   323ca:	b14b      	cbz	r3, 323e0 <z_fatal_error+0x60>
		LOG_ERR("Fault during interrupt handling\n");
   323cc:	f04f 0000 	mov.w	r0, #0
   323d0:	2301      	movs	r3, #1
   323d2:	f363 0007 	bfi	r0, r3, #0, #8
   323d6:	f364 108f 	bfi	r0, r4, #6, #10
   323da:	4920      	ldr	r1, [pc, #128]	; (3245c <z_fatal_error+0xdc>)
   323dc:	f005 fcc7 	bl	37d6e <log_string_sync>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   323e0:	f04f 0700 	mov.w	r7, #0
   323e4:	2301      	movs	r3, #1
	const char *thread_name = k_thread_name_get(thread);
   323e6:	4630      	mov	r0, r6
	LOG_ERR("Current thread: %p (%s)", thread,
   323e8:	f363 0707 	bfi	r7, r3, #0, #8
   323ec:	f364 178f 	bfi	r7, r4, #6, #10
	const char *thread_name = k_thread_name_get(thread);
   323f0:	f007 fb94 	bl	39b1c <k_thread_name_get>
	if (thread_name == NULL || thread_name[0] == '\0') {
   323f4:	b328      	cbz	r0, 32442 <z_fatal_error+0xc2>
   323f6:	7802      	ldrb	r2, [r0, #0]
		thread_name = "unknown";
   323f8:	4b19      	ldr	r3, [pc, #100]	; (32460 <z_fatal_error+0xe0>)
   323fa:	2a00      	cmp	r2, #0
   323fc:	bf08      	it	eq
   323fe:	4618      	moveq	r0, r3
	LOG_ERR("Current thread: %p (%s)", thread,
   32400:	f005 fcc7 	bl	37d92 <log_strdup>
   32404:	4632      	mov	r2, r6
   32406:	4603      	mov	r3, r0
   32408:	4916      	ldr	r1, [pc, #88]	; (32464 <z_fatal_error+0xe4>)
   3240a:	4638      	mov	r0, r7
   3240c:	f005 fcaf 	bl	37d6e <log_string_sync>
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
   32410:	4641      	mov	r1, r8
   32412:	4628      	mov	r0, r5
   32414:	f7f6 fede 	bl	291d4 <k_sys_fatal_error_handler>
	 *
	 * Note that k_thread_abort() returns on some architectures but
	 * not others; e.g. on ARC, x86_64, Xtensa with ASM2, ARM
	 */
	if (!IS_ENABLED(CONFIG_TEST)) {
		__ASSERT(reason != K_ERR_KERNEL_PANIC,
   32418:	2d04      	cmp	r5, #4
   3241a:	d10c      	bne.n	32436 <z_fatal_error+0xb6>
   3241c:	4912      	ldr	r1, [pc, #72]	; (32468 <z_fatal_error+0xe8>)
   3241e:	2387      	movs	r3, #135	; 0x87
   32420:	4a12      	ldr	r2, [pc, #72]	; (3246c <z_fatal_error+0xec>)
   32422:	4813      	ldr	r0, [pc, #76]	; (32470 <z_fatal_error+0xf0>)
   32424:	f005 fc4c 	bl	37cc0 <printk>
   32428:	4812      	ldr	r0, [pc, #72]	; (32474 <z_fatal_error+0xf4>)
   3242a:	f005 fc49 	bl	37cc0 <printk>
   3242e:	2187      	movs	r1, #135	; 0x87
   32430:	480e      	ldr	r0, [pc, #56]	; (3246c <z_fatal_error+0xec>)
   32432:	f005 fc8b 	bl	37d4c <assert_post_action>
	z_impl_k_thread_abort(thread);
   32436:	4630      	mov	r0, r6
			}
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	k_thread_abort(thread);
}
   32438:	b002      	add	sp, #8
   3243a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   3243e:	f7f3 ba67 	b.w	25910 <z_impl_k_thread_abort>
		thread_name = "unknown";
   32442:	4807      	ldr	r0, [pc, #28]	; (32460 <z_fatal_error+0xe0>)
   32444:	e7dc      	b.n	32400 <z_fatal_error+0x80>
   32446:	bf00      	nop
   32448:	0003aeb0 	.word	0x0003aeb0
   3244c:	0003ade0 	.word	0x0003ade0
   32450:	0003b84c 	.word	0x0003b84c
   32454:	0003ee4b 	.word	0x0003ee4b
   32458:	0003ee61 	.word	0x0003ee61
   3245c:	0003ee89 	.word	0x0003ee89
   32460:	0003ee59 	.word	0x0003ee59
   32464:	0003eeaa 	.word	0x0003eeaa
   32468:	0003eee4 	.word	0x0003eee4
   3246c:	0003eec2 	.word	0x0003eec2
   32470:	0003baac 	.word	0x0003baac
   32474:	0003ef01 	.word	0x0003ef01

00032478 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
   32478:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
   3247a:	4d0b      	ldr	r5, [pc, #44]	; (324a8 <idle+0x30>)
	__asm__ volatile(
   3247c:	f04f 0220 	mov.w	r2, #32
   32480:	f3ef 8311 	mrs	r3, BASEPRI
   32484:	f382 8811 	msr	BASEPRI, r2
   32488:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
   3248c:	f002 fdca 	bl	35024 <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   32490:	2101      	movs	r1, #1
	s32_t ticks = z_get_next_timeout_expiry();
   32492:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   32494:	2802      	cmp	r0, #2
   32496:	bfd8      	it	le
   32498:	4608      	movle	r0, r1
   3249a:	f002 fe0b 	bl	350b4 <z_set_timeout_expiry>
	_kernel.idle = ticks;
   3249e:	622c      	str	r4, [r5, #32]
 * @return N/A
 * @req K-CPU-IDLE-001
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
   324a0:	f7f2 fd48 	bl	24f34 <arch_cpu_idle>
   324a4:	e7ea      	b.n	3247c <idle+0x4>
   324a6:	bf00      	nop
   324a8:	20022108 	.word	0x20022108

000324ac <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   324ac:	4802      	ldr	r0, [pc, #8]	; (324b8 <z_bss_zero+0xc>)
   324ae:	4a03      	ldr	r2, [pc, #12]	; (324bc <z_bss_zero+0x10>)
   324b0:	2100      	movs	r1, #0
   324b2:	1a12      	subs	r2, r2, r0
   324b4:	f007 bc83 	b.w	39dbe <memset>
   324b8:	20020000 	.word	0x20020000
   324bc:	200262a0 	.word	0x200262a0

000324c0 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   324c0:	b508      	push	{r3, lr}
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   324c2:	4806      	ldr	r0, [pc, #24]	; (324dc <z_data_copy+0x1c>)
   324c4:	4a06      	ldr	r2, [pc, #24]	; (324e0 <z_data_copy+0x20>)
   324c6:	4907      	ldr	r1, [pc, #28]	; (324e4 <z_data_copy+0x24>)
   324c8:	1a12      	subs	r2, r2, r0
   324ca:	f007 fc58 	bl	39d7e <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   324ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   324d2:	4a05      	ldr	r2, [pc, #20]	; (324e8 <z_data_copy+0x28>)
   324d4:	4905      	ldr	r1, [pc, #20]	; (324ec <z_data_copy+0x2c>)
   324d6:	4806      	ldr	r0, [pc, #24]	; (324f0 <z_data_copy+0x30>)
   324d8:	f007 bc51 	b.w	39d7e <memcpy>
   324dc:	2002af20 	.word	0x2002af20
   324e0:	2002ccfc 	.word	0x2002ccfc
   324e4:	0003f750 	.word	0x0003f750
   324e8:	00000000 	.word	0x00000000
   324ec:	0003f750 	.word	0x0003f750
   324f0:	20020000 	.word	0x20020000

000324f4 <bg_thread_main>:
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
   324f4:	2201      	movs	r2, #1
{
   324f6:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   324f8:	4b08      	ldr	r3, [pc, #32]	; (3251c <bg_thread_main+0x28>)

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   324fa:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   324fc:	701a      	strb	r2, [r3, #0]
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   324fe:	f7ff fefd 	bl	322fc <z_sys_device_do_config_level>
			KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
   32502:	2003      	movs	r0, #3
   32504:	f7ff fefa 	bl	322fc <z_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
   32508:	f002 fa70 	bl	349ec <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
   3250c:	f004 fe4b 	bl	371a6 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   32510:	4a03      	ldr	r2, [pc, #12]	; (32520 <bg_thread_main+0x2c>)
   32512:	7b13      	ldrb	r3, [r2, #12]
   32514:	f023 0301 	bic.w	r3, r3, #1
   32518:	7313      	strb	r3, [r2, #12]

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   3251a:	bd08      	pop	{r3, pc}
   3251c:	20026149 	.word	0x20026149
   32520:	20021014 	.word	0x20021014

00032524 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
   32524:	b580      	push	{r7, lr}
   32526:	b0b2      	sub	sp, #200	; 0xc8
#endif	/* CONFIG_STACK_CANARIES */

	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
   32528:	f7f1 f9ac 	bl	23884 <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(_interrupt_stack)) +
   3252c:	4b35      	ldr	r3, [pc, #212]	; (32604 <z_cstart+0xe0>)
   3252e:	f503 6200 	add.w	r2, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   32532:	f382 8808 	msr	MSP, r2
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
   32536:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   3253a:	2400      	movs	r4, #0
   3253c:	23e0      	movs	r3, #224	; 0xe0
   3253e:	4d32      	ldr	r5, [pc, #200]	; (32608 <z_cstart+0xe4>)

	/* perform any architecture-specific initialization */
	arch_kernel_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
   32540:	2701      	movs	r7, #1
   32542:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   32546:	77ec      	strb	r4, [r5, #31]
   32548:	762c      	strb	r4, [r5, #24]
   3254a:	766c      	strb	r4, [r5, #25]
   3254c:	76ac      	strb	r4, [r5, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   3254e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
   32550:	4e2e      	ldr	r6, [pc, #184]	; (3260c <z_cstart+0xe8>)
   32552:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   32556:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   32558:	f7f3 f9b0 	bl	258bc <z_arm_fault_init>
	z_arm_cpu_idle_init();
   3255c:	f7f2 fce4 	bl	24f28 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   32560:	f04f 33ff 	mov.w	r3, #4294967295
   32564:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   32566:	62eb      	str	r3, [r5, #44]	; 0x2c
	struct k_thread dummy_thread = {
   32568:	ab06      	add	r3, sp, #24
   3256a:	22b0      	movs	r2, #176	; 0xb0
   3256c:	4621      	mov	r1, r4
   3256e:	4618      	mov	r0, r3
   32570:	f007 fc25 	bl	39dbe <memset>
	_current = &dummy_thread;
   32574:	60b0      	str	r0, [r6, #8]
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   32576:	4620      	mov	r0, r4
	struct k_thread dummy_thread = {
   32578:	f88d 7025 	strb.w	r7, [sp, #37]	; 0x25
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   3257c:	f7ff febe 	bl	322fc <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   32580:	4638      	mov	r0, r7
   32582:	f7ff febb 	bl	322fc <z_sys_device_do_config_level>
	_kernel.ready_q.cache = &z_main_thread;
   32586:	4d22      	ldr	r5, [pc, #136]	; (32610 <z_cstart+0xec>)
	z_sched_init();
   32588:	f001 fed0 	bl	3432c <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
   3258c:	4b21      	ldr	r3, [pc, #132]	; (32614 <z_cstart+0xf0>)
   3258e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   32592:	e9cd 7304 	strd	r7, r3, [sp, #16]
   32596:	e9cd 4402 	strd	r4, r4, [sp, #8]
   3259a:	4b1f      	ldr	r3, [pc, #124]	; (32618 <z_cstart+0xf4>)
   3259c:	e9cd 4400 	strd	r4, r4, [sp]
   325a0:	491e      	ldr	r1, [pc, #120]	; (3261c <z_cstart+0xf8>)
   325a2:	4628      	mov	r0, r5
	_kernel.ready_q.cache = &z_main_thread;
   325a4:	6275      	str	r5, [r6, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
   325a6:	f002 f937 	bl	34818 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   325aa:	7b6b      	ldrb	r3, [r5, #13]
   325ac:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   325b0:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
   325b4:	736a      	strb	r2, [r5, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   325b6:	d104      	bne.n	325c2 <z_cstart+0x9e>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
   325b8:	69ab      	ldr	r3, [r5, #24]
   325ba:	b913      	cbnz	r3, 325c2 <z_cstart+0x9e>
		z_add_thread_to_ready_q(thread);
   325bc:	4628      	mov	r0, r5
   325be:	f001 f9af 	bl	33920 <z_add_thread_to_ready_q>
	z_setup_new_thread(thread, stack,
   325c2:	4b17      	ldr	r3, [pc, #92]	; (32620 <z_cstart+0xfc>)
   325c4:	2201      	movs	r2, #1
   325c6:	9305      	str	r3, [sp, #20]
   325c8:	230f      	movs	r3, #15
   325ca:	e9cd 3203 	strd	r3, r2, [sp, #12]
   325ce:	2300      	movs	r3, #0
   325d0:	4d14      	ldr	r5, [pc, #80]	; (32624 <z_cstart+0x100>)
   325d2:	e9cd 3301 	strd	r3, r3, [sp, #4]
   325d6:	9300      	str	r3, [sp, #0]
   325d8:	f44f 72a0 	mov.w	r2, #320	; 0x140
   325dc:	4b12      	ldr	r3, [pc, #72]	; (32628 <z_cstart+0x104>)
   325de:	4913      	ldr	r1, [pc, #76]	; (3262c <z_cstart+0x108>)
   325e0:	4628      	mov	r0, r5
   325e2:	f002 f919 	bl	34818 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   325e6:	7b6b      	ldrb	r3, [r5, #13]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
   325e8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   325ec:	f023 0304 	bic.w	r3, r3, #4
   325f0:	736b      	strb	r3, [r5, #13]
	list->head = (sys_dnode_t *)list;
   325f2:	4b0f      	ldr	r3, [pc, #60]	; (32630 <z_cstart+0x10c>)
   325f4:	4909      	ldr	r1, [pc, #36]	; (3261c <z_cstart+0xf8>)
	list->tail = (sys_dnode_t *)list;
   325f6:	e9c6 3306 	strd	r3, r3, [r6, #24]
   325fa:	4805      	ldr	r0, [pc, #20]	; (32610 <z_cstart+0xec>)
   325fc:	4b06      	ldr	r3, [pc, #24]	; (32618 <z_cstart+0xf4>)
	_kernel.cpus[0].idle_thread = &z_idle_thread;
   325fe:	60f5      	str	r5, [r6, #12]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
   32600:	f7f2 fd88 	bl	25114 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   32604:	200289e0 	.word	0x200289e0
   32608:	e000ed00 	.word	0xe000ed00
   3260c:	20022108 	.word	0x20022108
   32610:	20021014 	.word	0x20021014
   32614:	0003ef39 	.word	0x0003ef39
   32618:	000324f5 	.word	0x000324f5
   3261c:	200268a0 	.word	0x200268a0
   32620:	0003ef3e 	.word	0x0003ef3e
   32624:	20020f64 	.word	0x20020f64
   32628:	00032479 	.word	0x00032479
   3262c:	200288a0 	.word	0x200288a0
   32630:	20022120 	.word	0x20022120

00032634 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(struct device *dev)
{
   32634:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   32638:	4d16      	ldr	r5, [pc, #88]	; (32694 <init_mem_slab_module+0x60>)
   3263a:	4c17      	ldr	r4, [pc, #92]	; (32698 <init_mem_slab_module+0x64>)
   3263c:	46a8      	mov	r8, r5
   3263e:	4e17      	ldr	r6, [pc, #92]	; (3269c <init_mem_slab_module+0x68>)
   32640:	42ac      	cmp	r4, r5
   32642:	d90c      	bls.n	3265e <init_mem_slab_module+0x2a>
   32644:	4916      	ldr	r1, [pc, #88]	; (326a0 <init_mem_slab_module+0x6c>)
   32646:	2342      	movs	r3, #66	; 0x42
   32648:	4632      	mov	r2, r6
   3264a:	4816      	ldr	r0, [pc, #88]	; (326a4 <init_mem_slab_module+0x70>)
   3264c:	f005 fb38 	bl	37cc0 <printk>
   32650:	4815      	ldr	r0, [pc, #84]	; (326a8 <init_mem_slab_module+0x74>)
   32652:	f005 fb35 	bl	37cc0 <printk>
   32656:	2142      	movs	r1, #66	; 0x42
   32658:	4630      	mov	r0, r6
   3265a:	f005 fb77 	bl	37d4c <assert_post_action>
   3265e:	4544      	cmp	r4, r8
   32660:	d302      	bcc.n	32668 <init_mem_slab_module+0x34>
		}
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}

out:
   32662:	2000      	movs	r0, #0
	return rc;
}
   32664:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   32668:	e9d4 1203 	ldrd	r1, r2, [r4, #12]
   3266c:	ea42 0301 	orr.w	r3, r2, r1
   32670:	f013 0303 	ands.w	r3, r3, #3
   32674:	d10b      	bne.n	3268e <init_mem_slab_module+0x5a>
	for (j = 0U; j < slab->num_blocks; j++) {
   32676:	68a0      	ldr	r0, [r4, #8]
	slab->free_list = NULL;
   32678:	6163      	str	r3, [r4, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   3267a:	4283      	cmp	r3, r0
   3267c:	d101      	bne.n	32682 <init_mem_slab_module+0x4e>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   3267e:	341c      	adds	r4, #28
   32680:	e7de      	b.n	32640 <init_mem_slab_module+0xc>
		*(char **)p = slab->free_list;
   32682:	6967      	ldr	r7, [r4, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   32684:	3301      	adds	r3, #1
		*(char **)p = slab->free_list;
   32686:	6017      	str	r7, [r2, #0]
		slab->free_list = p;
   32688:	6162      	str	r2, [r4, #20]
		p += slab->block_size;
   3268a:	440a      	add	r2, r1
   3268c:	e7f5      	b.n	3267a <init_mem_slab_module+0x46>
		return -EINVAL;
   3268e:	f06f 0015 	mvn.w	r0, #21
	return rc;
   32692:	e7e7      	b.n	32664 <init_mem_slab_module+0x30>
   32694:	2002cb9c 	.word	0x2002cb9c
   32698:	2002cb80 	.word	0x2002cb80
   3269c:	0003ef43 	.word	0x0003ef43
   326a0:	0003ef68 	.word	0x0003ef68
   326a4:	0003baac 	.word	0x0003baac
   326a8:	0003ef85 	.word	0x0003ef85

000326ac <k_mem_slab_alloc>:
out:
	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)
{
   326ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   326ae:	4604      	mov	r4, r0
   326b0:	460d      	mov	r5, r1
   326b2:	4616      	mov	r6, r2
   326b4:	f04f 0320 	mov.w	r3, #32
   326b8:	f3ef 8711 	mrs	r7, BASEPRI
   326bc:	f383 8811 	msr	BASEPRI, r3
   326c0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   326c4:	4823      	ldr	r0, [pc, #140]	; (32754 <k_mem_slab_alloc+0xa8>)
   326c6:	f002 f8bf 	bl	34848 <z_spin_lock_valid>
   326ca:	b968      	cbnz	r0, 326e8 <k_mem_slab_alloc+0x3c>
   326cc:	234a      	movs	r3, #74	; 0x4a
   326ce:	4a22      	ldr	r2, [pc, #136]	; (32758 <k_mem_slab_alloc+0xac>)
   326d0:	4922      	ldr	r1, [pc, #136]	; (3275c <k_mem_slab_alloc+0xb0>)
   326d2:	4823      	ldr	r0, [pc, #140]	; (32760 <k_mem_slab_alloc+0xb4>)
   326d4:	f005 faf4 	bl	37cc0 <printk>
   326d8:	491e      	ldr	r1, [pc, #120]	; (32754 <k_mem_slab_alloc+0xa8>)
   326da:	4822      	ldr	r0, [pc, #136]	; (32764 <k_mem_slab_alloc+0xb8>)
   326dc:	f005 faf0 	bl	37cc0 <printk>
   326e0:	214a      	movs	r1, #74	; 0x4a
   326e2:	481d      	ldr	r0, [pc, #116]	; (32758 <k_mem_slab_alloc+0xac>)
   326e4:	f005 fb32 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   326e8:	481a      	ldr	r0, [pc, #104]	; (32754 <k_mem_slab_alloc+0xa8>)
   326ea:	f002 f8cb 	bl	34884 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
   326ee:	6963      	ldr	r3, [r4, #20]
   326f0:	b1eb      	cbz	r3, 3272e <k_mem_slab_alloc+0x82>
		/* take a free block */
		*mem = slab->free_list;
   326f2:	602b      	str	r3, [r5, #0]
		slab->free_list = *(char **)(slab->free_list);
   326f4:	681b      	ldr	r3, [r3, #0]
   326f6:	6163      	str	r3, [r4, #20]
		slab->num_used++;
   326f8:	69a3      	ldr	r3, [r4, #24]
   326fa:	3301      	adds	r3, #1
   326fc:	61a3      	str	r3, [r4, #24]
		result = 0;
   326fe:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   32700:	4814      	ldr	r0, [pc, #80]	; (32754 <k_mem_slab_alloc+0xa8>)
   32702:	f002 f8af 	bl	34864 <z_spin_unlock_valid>
   32706:	b968      	cbnz	r0, 32724 <k_mem_slab_alloc+0x78>
   32708:	235d      	movs	r3, #93	; 0x5d
   3270a:	4a13      	ldr	r2, [pc, #76]	; (32758 <k_mem_slab_alloc+0xac>)
   3270c:	4916      	ldr	r1, [pc, #88]	; (32768 <k_mem_slab_alloc+0xbc>)
   3270e:	4814      	ldr	r0, [pc, #80]	; (32760 <k_mem_slab_alloc+0xb4>)
   32710:	f005 fad6 	bl	37cc0 <printk>
   32714:	490f      	ldr	r1, [pc, #60]	; (32754 <k_mem_slab_alloc+0xa8>)
   32716:	4815      	ldr	r0, [pc, #84]	; (3276c <k_mem_slab_alloc+0xc0>)
   32718:	f005 fad2 	bl	37cc0 <printk>
   3271c:	215d      	movs	r1, #93	; 0x5d
   3271e:	480e      	ldr	r0, [pc, #56]	; (32758 <k_mem_slab_alloc+0xac>)
   32720:	f005 fb14 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   32724:	f387 8811 	msr	BASEPRI, r7
   32728:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
   3272c:	e010      	b.n	32750 <k_mem_slab_alloc+0xa4>
	} else if (timeout == K_NO_WAIT) {
   3272e:	b91e      	cbnz	r6, 32738 <k_mem_slab_alloc+0x8c>
		*mem = NULL;
   32730:	602e      	str	r6, [r5, #0]
		result = -ENOMEM;
   32732:	f06f 040b 	mvn.w	r4, #11
   32736:	e7e3      	b.n	32700 <k_mem_slab_alloc+0x54>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
   32738:	4622      	mov	r2, r4
   3273a:	4633      	mov	r3, r6
   3273c:	4639      	mov	r1, r7
   3273e:	4805      	ldr	r0, [pc, #20]	; (32754 <k_mem_slab_alloc+0xa8>)
   32740:	f001 fca8 	bl	34094 <z_pend_curr>
		if (result == 0) {
   32744:	4604      	mov	r4, r0
   32746:	b918      	cbnz	r0, 32750 <k_mem_slab_alloc+0xa4>
			*mem = _current->base.swap_data;
   32748:	4b09      	ldr	r3, [pc, #36]	; (32770 <k_mem_slab_alloc+0xc4>)
   3274a:	689b      	ldr	r3, [r3, #8]
   3274c:	695b      	ldr	r3, [r3, #20]
   3274e:	602b      	str	r3, [r5, #0]
}
   32750:	4620      	mov	r0, r4
   32752:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   32754:	200210c4 	.word	0x200210c4
   32758:	0003ba71 	.word	0x0003ba71
   3275c:	0003ba97 	.word	0x0003ba97
   32760:	0003baac 	.word	0x0003baac
   32764:	0003bac9 	.word	0x0003bac9
   32768:	0003bb0b 	.word	0x0003bb0b
   3276c:	0003bb22 	.word	0x0003bb22
   32770:	20022108 	.word	0x20022108

00032774 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   32774:	b570      	push	{r4, r5, r6, lr}
   32776:	4604      	mov	r4, r0
   32778:	460d      	mov	r5, r1
	__asm__ volatile(
   3277a:	f04f 0320 	mov.w	r3, #32
   3277e:	f3ef 8611 	mrs	r6, BASEPRI
   32782:	f383 8811 	msr	BASEPRI, r3
   32786:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   3278a:	4824      	ldr	r0, [pc, #144]	; (3281c <k_mem_slab_free+0xa8>)
   3278c:	f002 f85c 	bl	34848 <z_spin_lock_valid>
   32790:	b968      	cbnz	r0, 327ae <k_mem_slab_free+0x3a>
   32792:	234a      	movs	r3, #74	; 0x4a
   32794:	4a22      	ldr	r2, [pc, #136]	; (32820 <k_mem_slab_free+0xac>)
   32796:	4923      	ldr	r1, [pc, #140]	; (32824 <k_mem_slab_free+0xb0>)
   32798:	4823      	ldr	r0, [pc, #140]	; (32828 <k_mem_slab_free+0xb4>)
   3279a:	f005 fa91 	bl	37cc0 <printk>
   3279e:	491f      	ldr	r1, [pc, #124]	; (3281c <k_mem_slab_free+0xa8>)
   327a0:	4822      	ldr	r0, [pc, #136]	; (3282c <k_mem_slab_free+0xb8>)
   327a2:	f005 fa8d 	bl	37cc0 <printk>
   327a6:	214a      	movs	r1, #74	; 0x4a
   327a8:	481d      	ldr	r0, [pc, #116]	; (32820 <k_mem_slab_free+0xac>)
   327aa:	f005 facf 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   327ae:	481b      	ldr	r0, [pc, #108]	; (3281c <k_mem_slab_free+0xa8>)
   327b0:	f002 f868 	bl	34884 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   327b4:	4620      	mov	r0, r4
   327b6:	f001 fd29 	bl	3420c <z_unpend_first_thread>

	if (pending_thread != NULL) {
   327ba:	b180      	cbz	r0, 327de <k_mem_slab_free+0x6a>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   327bc:	2100      	movs	r1, #0
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   327be:	682a      	ldr	r2, [r5, #0]
   327c0:	6681      	str	r1, [r0, #104]	; 0x68
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   327c2:	6142      	str	r2, [r0, #20]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   327c4:	7b42      	ldrb	r2, [r0, #13]
   327c6:	06d2      	lsls	r2, r2, #27
   327c8:	d103      	bne.n	327d2 <k_mem_slab_free+0x5e>
	if (z_is_thread_ready(thread)) {
   327ca:	6983      	ldr	r3, [r0, #24]
   327cc:	b90b      	cbnz	r3, 327d2 <k_mem_slab_free+0x5e>
		z_add_thread_to_ready_q(thread);
   327ce:	f001 f8a7 	bl	33920 <z_add_thread_to_ready_q>
		z_ready_thread(pending_thread);
		z_reschedule(&lock, key);
   327d2:	4631      	mov	r1, r6
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
   327d4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   327d8:	4810      	ldr	r0, [pc, #64]	; (3281c <k_mem_slab_free+0xa8>)
   327da:	f000 beb7 	b.w	3354c <z_reschedule>
		**(char ***)mem = slab->free_list;
   327de:	682b      	ldr	r3, [r5, #0]
   327e0:	6962      	ldr	r2, [r4, #20]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   327e2:	480e      	ldr	r0, [pc, #56]	; (3281c <k_mem_slab_free+0xa8>)
   327e4:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
   327e6:	682b      	ldr	r3, [r5, #0]
   327e8:	6163      	str	r3, [r4, #20]
		slab->num_used--;
   327ea:	69a3      	ldr	r3, [r4, #24]
   327ec:	3b01      	subs	r3, #1
   327ee:	61a3      	str	r3, [r4, #24]
   327f0:	f002 f838 	bl	34864 <z_spin_unlock_valid>
   327f4:	b968      	cbnz	r0, 32812 <k_mem_slab_free+0x9e>
   327f6:	235d      	movs	r3, #93	; 0x5d
   327f8:	4a09      	ldr	r2, [pc, #36]	; (32820 <k_mem_slab_free+0xac>)
   327fa:	490d      	ldr	r1, [pc, #52]	; (32830 <k_mem_slab_free+0xbc>)
   327fc:	480a      	ldr	r0, [pc, #40]	; (32828 <k_mem_slab_free+0xb4>)
   327fe:	f005 fa5f 	bl	37cc0 <printk>
   32802:	4906      	ldr	r1, [pc, #24]	; (3281c <k_mem_slab_free+0xa8>)
   32804:	480b      	ldr	r0, [pc, #44]	; (32834 <k_mem_slab_free+0xc0>)
   32806:	f005 fa5b 	bl	37cc0 <printk>
   3280a:	215d      	movs	r1, #93	; 0x5d
   3280c:	4804      	ldr	r0, [pc, #16]	; (32820 <k_mem_slab_free+0xac>)
   3280e:	f005 fa9d 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   32812:	f386 8811 	msr	BASEPRI, r6
   32816:	f3bf 8f6f 	isb	sy
}
   3281a:	bd70      	pop	{r4, r5, r6, pc}
   3281c:	200210c4 	.word	0x200210c4
   32820:	0003ba71 	.word	0x0003ba71
   32824:	0003ba97 	.word	0x0003ba97
   32828:	0003baac 	.word	0x0003baac
   3282c:	0003bac9 	.word	0x0003bac9
   32830:	0003bb0b 	.word	0x0003bb0b
   32834:	0003bb22 	.word	0x0003bb22

00032838 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
   32838:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ARG_UNUSED(unused);

	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
   3283a:	4d10      	ldr	r5, [pc, #64]	; (3287c <init_static_pools+0x44>)
   3283c:	4c10      	ldr	r4, [pc, #64]	; (32880 <init_static_pools+0x48>)
   3283e:	462f      	mov	r7, r5
   32840:	4e10      	ldr	r6, [pc, #64]	; (32884 <init_static_pools+0x4c>)
   32842:	42ac      	cmp	r4, r5
   32844:	d90c      	bls.n	32860 <init_static_pools+0x28>
   32846:	4910      	ldr	r1, [pc, #64]	; (32888 <init_static_pools+0x50>)
   32848:	2328      	movs	r3, #40	; 0x28
   3284a:	4632      	mov	r2, r6
   3284c:	480f      	ldr	r0, [pc, #60]	; (3288c <init_static_pools+0x54>)
   3284e:	f005 fa37 	bl	37cc0 <printk>
   32852:	480f      	ldr	r0, [pc, #60]	; (32890 <init_static_pools+0x58>)
   32854:	f005 fa34 	bl	37cc0 <printk>
   32858:	2128      	movs	r1, #40	; 0x28
   3285a:	4630      	mov	r0, r6
   3285c:	f005 fa76 	bl	37d4c <assert_post_action>
   32860:	42bc      	cmp	r4, r7
   32862:	d301      	bcc.n	32868 <init_static_pools+0x30>
		k_mem_pool_init(p);
	}

	return 0;
}
   32864:	2000      	movs	r0, #0
   32866:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   32868:	f104 0314 	add.w	r3, r4, #20
	z_sys_mem_pool_base_init(&p->base);
   3286c:	4620      	mov	r0, r4
   3286e:	e9c4 3305 	strd	r3, r3, [r4, #20]
   32872:	f004 ffad 	bl	377d0 <z_sys_mem_pool_base_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
   32876:	341c      	adds	r4, #28
   32878:	e7e3      	b.n	32842 <init_static_pools+0xa>
   3287a:	bf00      	nop
   3287c:	2002cbb8 	.word	0x2002cbb8
   32880:	2002cb9c 	.word	0x2002cb9c
   32884:	0003efa4 	.word	0x0003efa4
   32888:	0003efc8 	.word	0x0003efc8
   3288c:	0003baac 	.word	0x0003baac
   32890:	0003ef85 	.word	0x0003ef85

00032894 <k_mem_pool_alloc>:

SYS_INIT(init_static_pools, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, s32_t timeout)
{
   32894:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   32898:	4607      	mov	r7, r0
   3289a:	b085      	sub	sp, #20
   3289c:	460d      	mov	r5, r1
   3289e:	4692      	mov	sl, r2
   328a0:	461c      	mov	r4, r3
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   328a2:	f3ef 8305 	mrs	r3, IPSR
	int ret;
	s64_t end = 0;

	__ASSERT(!(arch_is_in_isr() && timeout != K_NO_WAIT), "");
   328a6:	2b00      	cmp	r3, #0
   328a8:	d048      	beq.n	3293c <k_mem_pool_alloc+0xa8>
   328aa:	2c00      	cmp	r4, #0
   328ac:	d139      	bne.n	32922 <k_mem_pool_alloc+0x8e>
	s64_t end = 0;
   328ae:	f04f 0800 	mov.w	r8, #0
	return pool - &_k_mem_pool_list_start[0];
   328b2:	4b26      	ldr	r3, [pc, #152]	; (3294c <k_mem_pool_alloc+0xb8>)
   328b4:	4e26      	ldr	r6, [pc, #152]	; (32950 <k_mem_pool_alloc+0xbc>)
   328b6:	1afb      	subs	r3, r7, r3
   328b8:	109b      	asrs	r3, r3, #2
   328ba:	435e      	muls	r6, r3
		if (ret == 0 || timeout == K_NO_WAIT ||
		    ret != -ENOMEM) {
			return ret;
		}

		z_pend_curr_unlocked(&p->wait_q, timeout);
   328bc:	f107 0b14 	add.w	fp, r7, #20
		block->id.pool = pool_id(p);
   328c0:	b2f6      	uxtb	r6, r6
		ret = z_sys_mem_pool_block_alloc(&p->base, size,
   328c2:	ab03      	add	r3, sp, #12
   328c4:	aa02      	add	r2, sp, #8
   328c6:	9500      	str	r5, [sp, #0]
   328c8:	4651      	mov	r1, sl
   328ca:	4638      	mov	r0, r7
   328cc:	f004 ffc6 	bl	3785c <z_sys_mem_pool_block_alloc>
		block->id.level = level_num;
   328d0:	796b      	ldrb	r3, [r5, #5]
   328d2:	9a02      	ldr	r2, [sp, #8]
		block->id.pool = pool_id(p);
   328d4:	712e      	strb	r6, [r5, #4]
		block->id.level = level_num;
   328d6:	f362 0303 	bfi	r3, r2, #0, #4
   328da:	716b      	strb	r3, [r5, #5]
		block->id.block = block_num;
   328dc:	686b      	ldr	r3, [r5, #4]
   328de:	9a03      	ldr	r2, [sp, #12]
   328e0:	f362 331f 	bfi	r3, r2, #12, #20
   328e4:	606b      	str	r3, [r5, #4]
		if (ret == 0 || timeout == K_NO_WAIT ||
   328e6:	b1c8      	cbz	r0, 3291c <k_mem_pool_alloc+0x88>
   328e8:	b1c4      	cbz	r4, 3291c <k_mem_pool_alloc+0x88>
   328ea:	f110 0f0c 	cmn.w	r0, #12
   328ee:	d115      	bne.n	3291c <k_mem_pool_alloc+0x88>
	__asm__ volatile(
   328f0:	f04f 0320 	mov.w	r3, #32
   328f4:	f3ef 8011 	mrs	r0, BASEPRI
   328f8:	f383 8811 	msr	BASEPRI, r3
   328fc:	f3bf 8f6f 	isb	sy
	(void) z_pend_curr_irqlock(arch_irq_lock(), wait_q, timeout);
   32900:	4622      	mov	r2, r4
   32902:	4659      	mov	r1, fp
   32904:	f001 fb6c 	bl	33fe0 <z_pend_curr_irqlock>

		if (timeout != K_FOREVER) {
   32908:	1c63      	adds	r3, r4, #1
   3290a:	d0da      	beq.n	328c2 <k_mem_pool_alloc+0x2e>
	return z_impl_k_uptime_get();
   3290c:	f007 f97e 	bl	39c0c <z_impl_k_uptime_get>
			timeout = end - k_uptime_get();
   32910:	eba8 0400 	sub.w	r4, r8, r0
			if (timeout <= 0) {
   32914:	2c00      	cmp	r4, #0
   32916:	dcd4      	bgt.n	328c2 <k_mem_pool_alloc+0x2e>
				break;
			}
		}
	}

	return -EAGAIN;
   32918:	f06f 000a 	mvn.w	r0, #10
}
   3291c:	b005      	add	sp, #20
   3291e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	__ASSERT(!(arch_is_in_isr() && timeout != K_NO_WAIT), "");
   32922:	490c      	ldr	r1, [pc, #48]	; (32954 <k_mem_pool_alloc+0xc0>)
   32924:	2337      	movs	r3, #55	; 0x37
   32926:	4a0c      	ldr	r2, [pc, #48]	; (32958 <k_mem_pool_alloc+0xc4>)
   32928:	480c      	ldr	r0, [pc, #48]	; (3295c <k_mem_pool_alloc+0xc8>)
   3292a:	f005 f9c9 	bl	37cc0 <printk>
   3292e:	480c      	ldr	r0, [pc, #48]	; (32960 <k_mem_pool_alloc+0xcc>)
   32930:	f005 f9c6 	bl	37cc0 <printk>
   32934:	2137      	movs	r1, #55	; 0x37
   32936:	4808      	ldr	r0, [pc, #32]	; (32958 <k_mem_pool_alloc+0xc4>)
   32938:	f005 fa08 	bl	37d4c <assert_post_action>
	if (timeout > 0) {
   3293c:	2c00      	cmp	r4, #0
   3293e:	ddb6      	ble.n	328ae <k_mem_pool_alloc+0x1a>
   32940:	f007 f964 	bl	39c0c <z_impl_k_uptime_get>
		end = k_uptime_get() + timeout;
   32944:	eb10 0804 	adds.w	r8, r0, r4
   32948:	e7b3      	b.n	328b2 <k_mem_pool_alloc+0x1e>
   3294a:	bf00      	nop
   3294c:	2002cb9c 	.word	0x2002cb9c
   32950:	b6db6db7 	.word	0xb6db6db7
   32954:	0003efe2 	.word	0x0003efe2
   32958:	0003efa4 	.word	0x0003efa4
   3295c:	0003baac 	.word	0x0003baac
   32960:	0003da1b 	.word	0x0003da1b

00032964 <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
   32964:	b570      	push	{r4, r5, r6, lr}
   32966:	7804      	ldrb	r4, [r0, #0]
	int need_sched = 0;
	struct k_mem_pool *p = get_pool(id->pool);

	z_sys_mem_pool_block_free(&p->base, id->level, id->block);
   32968:	6802      	ldr	r2, [r0, #0]
   3296a:	7841      	ldrb	r1, [r0, #1]
   3296c:	4d24      	ldr	r5, [pc, #144]	; (32a00 <k_mem_pool_free_id+0x9c>)
   3296e:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   32972:	00a4      	lsls	r4, r4, #2
   32974:	0b12      	lsrs	r2, r2, #12
   32976:	f001 010f 	and.w	r1, r1, #15
   3297a:	1928      	adds	r0, r5, r4
   3297c:	f7f0 fe06 	bl	2358c <z_sys_mem_pool_block_free>
   32980:	f04f 0320 	mov.w	r3, #32
   32984:	f3ef 8611 	mrs	r6, BASEPRI
   32988:	f383 8811 	msr	BASEPRI, r3
   3298c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   32990:	481c      	ldr	r0, [pc, #112]	; (32a04 <k_mem_pool_free_id+0xa0>)
   32992:	f001 ff59 	bl	34848 <z_spin_lock_valid>
   32996:	b968      	cbnz	r0, 329b4 <k_mem_pool_free_id+0x50>
   32998:	234a      	movs	r3, #74	; 0x4a
   3299a:	4a1b      	ldr	r2, [pc, #108]	; (32a08 <k_mem_pool_free_id+0xa4>)
   3299c:	491b      	ldr	r1, [pc, #108]	; (32a0c <k_mem_pool_free_id+0xa8>)
   3299e:	481c      	ldr	r0, [pc, #112]	; (32a10 <k_mem_pool_free_id+0xac>)
   329a0:	f005 f98e 	bl	37cc0 <printk>
   329a4:	4917      	ldr	r1, [pc, #92]	; (32a04 <k_mem_pool_free_id+0xa0>)
   329a6:	481b      	ldr	r0, [pc, #108]	; (32a14 <k_mem_pool_free_id+0xb0>)
   329a8:	f005 f98a 	bl	37cc0 <printk>
   329ac:	214a      	movs	r1, #74	; 0x4a
   329ae:	4816      	ldr	r0, [pc, #88]	; (32a08 <k_mem_pool_free_id+0xa4>)
   329b0:	f005 f9cc 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   329b4:	4813      	ldr	r0, [pc, #76]	; (32a04 <k_mem_pool_free_id+0xa0>)
   329b6:	f001 ff65 	bl	34884 <z_spin_lock_set_owner>
	 * is unsynchronized.  Maybe we want to put the lock into the
	 * wait_q instead and make the API safe?)
	 */
	k_spinlock_key_t key = k_spin_lock(&lock);

	need_sched = z_unpend_all(&p->wait_q);
   329ba:	f104 0014 	add.w	r0, r4, #20
   329be:	4428      	add	r0, r5
   329c0:	f007 f87b 	bl	39aba <z_unpend_all>

	if (need_sched != 0) {
   329c4:	b128      	cbz	r0, 329d2 <k_mem_pool_free_id+0x6e>
		z_reschedule(&lock, key);
   329c6:	4631      	mov	r1, r6
	} else {
		k_spin_unlock(&lock, key);
	}
}
   329c8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   329cc:	480d      	ldr	r0, [pc, #52]	; (32a04 <k_mem_pool_free_id+0xa0>)
   329ce:	f000 bdbd 	b.w	3354c <z_reschedule>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   329d2:	480c      	ldr	r0, [pc, #48]	; (32a04 <k_mem_pool_free_id+0xa0>)
   329d4:	f001 ff46 	bl	34864 <z_spin_unlock_valid>
   329d8:	b968      	cbnz	r0, 329f6 <k_mem_pool_free_id+0x92>
   329da:	235d      	movs	r3, #93	; 0x5d
   329dc:	4a0a      	ldr	r2, [pc, #40]	; (32a08 <k_mem_pool_free_id+0xa4>)
   329de:	490e      	ldr	r1, [pc, #56]	; (32a18 <k_mem_pool_free_id+0xb4>)
   329e0:	480b      	ldr	r0, [pc, #44]	; (32a10 <k_mem_pool_free_id+0xac>)
   329e2:	f005 f96d 	bl	37cc0 <printk>
   329e6:	4907      	ldr	r1, [pc, #28]	; (32a04 <k_mem_pool_free_id+0xa0>)
   329e8:	480c      	ldr	r0, [pc, #48]	; (32a1c <k_mem_pool_free_id+0xb8>)
   329ea:	f005 f969 	bl	37cc0 <printk>
   329ee:	215d      	movs	r1, #93	; 0x5d
   329f0:	4805      	ldr	r0, [pc, #20]	; (32a08 <k_mem_pool_free_id+0xa4>)
   329f2:	f005 f9ab 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   329f6:	f386 8811 	msr	BASEPRI, r6
   329fa:	f3bf 8f6f 	isb	sy
}
   329fe:	bd70      	pop	{r4, r5, r6, pc}
   32a00:	2002cb9c 	.word	0x2002cb9c
   32a04:	20022100 	.word	0x20022100
   32a08:	0003ba71 	.word	0x0003ba71
   32a0c:	0003ba97 	.word	0x0003ba97
   32a10:	0003baac 	.word	0x0003baac
   32a14:	0003bac9 	.word	0x0003bac9
   32a18:	0003bb0b 	.word	0x0003bb0b
   32a1c:	0003bb22 	.word	0x0003bb22

00032a20 <k_malloc>:
		  CONFIG_HEAP_MEM_POOL_SIZE, 1, 4);
#define _HEAP_MEM_POOL (&_heap_mem_pool)

void *k_malloc(size_t size)
{
	return k_mem_pool_malloc(_HEAP_MEM_POOL, size);
   32a20:	4601      	mov	r1, r0
   32a22:	4801      	ldr	r0, [pc, #4]	; (32a28 <k_malloc+0x8>)
   32a24:	f006 bfcd 	b.w	399c2 <k_mem_pool_malloc>
   32a28:	2002cb9c 	.word	0x2002cb9c

00032a2c <z_thread_malloc>:
#else
#define _HEAP_MEM_POOL	NULL
#endif

void *z_thread_malloc(size_t size)
{
   32a2c:	b510      	push	{r4, lr}
   32a2e:	4604      	mov	r4, r0
	void *ret;
	struct k_mem_pool *pool;

	if (k_is_in_isr()) {
   32a30:	f007 f869 	bl	39b06 <k_is_in_isr>
   32a34:	b948      	cbnz	r0, 32a4a <z_thread_malloc+0x1e>
		pool = _HEAP_MEM_POOL;
	} else {
		pool = _current->resource_pool;
   32a36:	4b06      	ldr	r3, [pc, #24]	; (32a50 <z_thread_malloc+0x24>)
   32a38:	689b      	ldr	r3, [r3, #8]
   32a3a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
	}

	if (pool) {
   32a3c:	b13b      	cbz	r3, 32a4e <z_thread_malloc+0x22>
		ret = k_mem_pool_malloc(pool, size);
   32a3e:	4621      	mov	r1, r4
	} else {
		ret = NULL;
	}

	return ret;
}
   32a40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ret = k_mem_pool_malloc(pool, size);
   32a44:	4618      	mov	r0, r3
   32a46:	f006 bfbc 	b.w	399c2 <k_mem_pool_malloc>
		pool = _HEAP_MEM_POOL;
   32a4a:	4b02      	ldr	r3, [pc, #8]	; (32a54 <z_thread_malloc+0x28>)
   32a4c:	e7f7      	b.n	32a3e <z_thread_malloc+0x12>
}
   32a4e:	bd10      	pop	{r4, pc}
   32a50:	20022108 	.word	0x20022108
   32a54:	2002cb9c 	.word	0x2002cb9c

00032a58 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, void *data, s32_t timeout)
{
   32a58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   32a5c:	4604      	mov	r4, r0
   32a5e:	4688      	mov	r8, r1
   32a60:	4616      	mov	r6, r2
   32a62:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr() || timeout == K_NO_WAIT, "");
   32a66:	b16b      	cbz	r3, 32a84 <z_impl_k_msgq_put+0x2c>
   32a68:	b162      	cbz	r2, 32a84 <z_impl_k_msgq_put+0x2c>
   32a6a:	4941      	ldr	r1, [pc, #260]	; (32b70 <z_impl_k_msgq_put+0x118>)
   32a6c:	2376      	movs	r3, #118	; 0x76
   32a6e:	4a41      	ldr	r2, [pc, #260]	; (32b74 <z_impl_k_msgq_put+0x11c>)
   32a70:	4841      	ldr	r0, [pc, #260]	; (32b78 <z_impl_k_msgq_put+0x120>)
   32a72:	f005 f925 	bl	37cc0 <printk>
   32a76:	4841      	ldr	r0, [pc, #260]	; (32b7c <z_impl_k_msgq_put+0x124>)
   32a78:	f005 f922 	bl	37cc0 <printk>
   32a7c:	2176      	movs	r1, #118	; 0x76
   32a7e:	483d      	ldr	r0, [pc, #244]	; (32b74 <z_impl_k_msgq_put+0x11c>)
   32a80:	f005 f964 	bl	37d4c <assert_post_action>

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
   32a84:	f104 0508 	add.w	r5, r4, #8
	__asm__ volatile(
   32a88:	f04f 0320 	mov.w	r3, #32
   32a8c:	f3ef 8711 	mrs	r7, BASEPRI
   32a90:	f383 8811 	msr	BASEPRI, r3
   32a94:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   32a98:	4628      	mov	r0, r5
   32a9a:	f001 fed5 	bl	34848 <z_spin_lock_valid>
   32a9e:	b968      	cbnz	r0, 32abc <z_impl_k_msgq_put+0x64>
   32aa0:	234a      	movs	r3, #74	; 0x4a
   32aa2:	4a37      	ldr	r2, [pc, #220]	; (32b80 <z_impl_k_msgq_put+0x128>)
   32aa4:	4937      	ldr	r1, [pc, #220]	; (32b84 <z_impl_k_msgq_put+0x12c>)
   32aa6:	4834      	ldr	r0, [pc, #208]	; (32b78 <z_impl_k_msgq_put+0x120>)
   32aa8:	f005 f90a 	bl	37cc0 <printk>
   32aac:	4629      	mov	r1, r5
   32aae:	4836      	ldr	r0, [pc, #216]	; (32b88 <z_impl_k_msgq_put+0x130>)
   32ab0:	f005 f906 	bl	37cc0 <printk>
   32ab4:	214a      	movs	r1, #74	; 0x4a
   32ab6:	4832      	ldr	r0, [pc, #200]	; (32b80 <z_impl_k_msgq_put+0x128>)
   32ab8:	f005 f948 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   32abc:	4628      	mov	r0, r5
   32abe:	f001 fee1 	bl	34884 <z_spin_lock_set_owner>

	if (msgq->used_msgs < msgq->max_msgs) {
   32ac2:	6a62      	ldr	r2, [r4, #36]	; 0x24
   32ac4:	6923      	ldr	r3, [r4, #16]
   32ac6:	429a      	cmp	r2, r3
   32ac8:	d242      	bcs.n	32b50 <z_impl_k_msgq_put+0xf8>
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   32aca:	4620      	mov	r0, r4
   32acc:	f001 fb9e 	bl	3420c <z_unpend_first_thread>
		if (pending_thread != NULL) {
   32ad0:	68e2      	ldr	r2, [r4, #12]
   32ad2:	4606      	mov	r6, r0
   32ad4:	4641      	mov	r1, r8
   32ad6:	b1a0      	cbz	r0, 32b02 <z_impl_k_msgq_put+0xaa>
   32ad8:	6940      	ldr	r0, [r0, #20]
   32ada:	f007 f950 	bl	39d7e <memcpy>
   32ade:	2300      	movs	r3, #0
   32ae0:	66b3      	str	r3, [r6, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   32ae2:	7b73      	ldrb	r3, [r6, #13]
   32ae4:	06db      	lsls	r3, r3, #27
   32ae6:	d104      	bne.n	32af2 <z_impl_k_msgq_put+0x9a>
	if (z_is_thread_ready(thread)) {
   32ae8:	69b3      	ldr	r3, [r6, #24]
   32aea:	b913      	cbnz	r3, 32af2 <z_impl_k_msgq_put+0x9a>
		z_add_thread_to_ready_q(thread);
   32aec:	4630      	mov	r0, r6
   32aee:	f000 ff17 	bl	33920 <z_add_thread_to_ready_q>
			(void)memcpy(pending_thread->base.swap_data, data,
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
   32af2:	4639      	mov	r1, r7
   32af4:	4628      	mov	r0, r5
   32af6:	f000 fd29 	bl	3354c <z_reschedule>
			return 0;
   32afa:	2400      	movs	r4, #0
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   32afc:	4620      	mov	r0, r4
   32afe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   32b02:	6a20      	ldr	r0, [r4, #32]
   32b04:	f007 f93b 	bl	39d7e <memcpy>
			msgq->write_ptr += msgq->msg_size;
   32b08:	6a23      	ldr	r3, [r4, #32]
   32b0a:	68e2      	ldr	r2, [r4, #12]
   32b0c:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   32b0e:	69a2      	ldr	r2, [r4, #24]
			msgq->write_ptr += msgq->msg_size;
   32b10:	6223      	str	r3, [r4, #32]
			if (msgq->write_ptr == msgq->buffer_end) {
   32b12:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   32b14:	bf04      	itt	eq
   32b16:	6963      	ldreq	r3, [r4, #20]
   32b18:	6223      	streq	r3, [r4, #32]
			msgq->used_msgs++;
   32b1a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   32b1c:	3301      	adds	r3, #1
   32b1e:	6263      	str	r3, [r4, #36]	; 0x24
		result = 0;
   32b20:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   32b22:	4628      	mov	r0, r5
   32b24:	f001 fe9e 	bl	34864 <z_spin_unlock_valid>
   32b28:	b968      	cbnz	r0, 32b46 <z_impl_k_msgq_put+0xee>
   32b2a:	235d      	movs	r3, #93	; 0x5d
   32b2c:	4a14      	ldr	r2, [pc, #80]	; (32b80 <z_impl_k_msgq_put+0x128>)
   32b2e:	4917      	ldr	r1, [pc, #92]	; (32b8c <z_impl_k_msgq_put+0x134>)
   32b30:	4811      	ldr	r0, [pc, #68]	; (32b78 <z_impl_k_msgq_put+0x120>)
   32b32:	f005 f8c5 	bl	37cc0 <printk>
   32b36:	4629      	mov	r1, r5
   32b38:	4815      	ldr	r0, [pc, #84]	; (32b90 <z_impl_k_msgq_put+0x138>)
   32b3a:	f005 f8c1 	bl	37cc0 <printk>
   32b3e:	215d      	movs	r1, #93	; 0x5d
   32b40:	480f      	ldr	r0, [pc, #60]	; (32b80 <z_impl_k_msgq_put+0x128>)
   32b42:	f005 f903 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   32b46:	f387 8811 	msr	BASEPRI, r7
   32b4a:	f3bf 8f6f 	isb	sy
	return result;
   32b4e:	e7d5      	b.n	32afc <z_impl_k_msgq_put+0xa4>
	} else if (timeout == K_NO_WAIT) {
   32b50:	b15e      	cbz	r6, 32b6a <z_impl_k_msgq_put+0x112>
		_current->base.swap_data = data;
   32b52:	4b10      	ldr	r3, [pc, #64]	; (32b94 <z_impl_k_msgq_put+0x13c>)
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   32b54:	4622      	mov	r2, r4
		_current->base.swap_data = data;
   32b56:	689b      	ldr	r3, [r3, #8]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   32b58:	4639      	mov	r1, r7
		_current->base.swap_data = data;
   32b5a:	f8c3 8014 	str.w	r8, [r3, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   32b5e:	4628      	mov	r0, r5
   32b60:	4633      	mov	r3, r6
}
   32b62:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   32b66:	f001 ba95 	b.w	34094 <z_pend_curr>
		result = -ENOMSG;
   32b6a:	f06f 0422 	mvn.w	r4, #34	; 0x22
   32b6e:	e7d8      	b.n	32b22 <z_impl_k_msgq_put+0xca>
   32b70:	0003f028 	.word	0x0003f028
   32b74:	0003f006 	.word	0x0003f006
   32b78:	0003baac 	.word	0x0003baac
   32b7c:	0003da1b 	.word	0x0003da1b
   32b80:	0003ba71 	.word	0x0003ba71
   32b84:	0003ba97 	.word	0x0003ba97
   32b88:	0003bac9 	.word	0x0003bac9
   32b8c:	0003bb0b 	.word	0x0003bb0b
   32b90:	0003bb22 	.word	0x0003bb22
   32b94:	20022108 	.word	0x20022108

00032b98 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, s32_t timeout)
{
   32b98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   32b9c:	4604      	mov	r4, r0
   32b9e:	4688      	mov	r8, r1
   32ba0:	4615      	mov	r5, r2
   32ba2:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr() || timeout == K_NO_WAIT, "");
   32ba6:	b16b      	cbz	r3, 32bc4 <z_impl_k_msgq_get+0x2c>
   32ba8:	b162      	cbz	r2, 32bc4 <z_impl_k_msgq_get+0x2c>
   32baa:	4947      	ldr	r1, [pc, #284]	; (32cc8 <z_impl_k_msgq_get+0x130>)
   32bac:	23c1      	movs	r3, #193	; 0xc1
   32bae:	4a47      	ldr	r2, [pc, #284]	; (32ccc <z_impl_k_msgq_get+0x134>)
   32bb0:	4847      	ldr	r0, [pc, #284]	; (32cd0 <z_impl_k_msgq_get+0x138>)
   32bb2:	f005 f885 	bl	37cc0 <printk>
   32bb6:	4847      	ldr	r0, [pc, #284]	; (32cd4 <z_impl_k_msgq_get+0x13c>)
   32bb8:	f005 f882 	bl	37cc0 <printk>
   32bbc:	21c1      	movs	r1, #193	; 0xc1
   32bbe:	4843      	ldr	r0, [pc, #268]	; (32ccc <z_impl_k_msgq_get+0x134>)
   32bc0:	f005 f8c4 	bl	37d4c <assert_post_action>

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
   32bc4:	f104 0608 	add.w	r6, r4, #8
	__asm__ volatile(
   32bc8:	f04f 0320 	mov.w	r3, #32
   32bcc:	f3ef 8711 	mrs	r7, BASEPRI
   32bd0:	f383 8811 	msr	BASEPRI, r3
   32bd4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   32bd8:	4630      	mov	r0, r6
   32bda:	f001 fe35 	bl	34848 <z_spin_lock_valid>
   32bde:	b968      	cbnz	r0, 32bfc <z_impl_k_msgq_get+0x64>
   32be0:	234a      	movs	r3, #74	; 0x4a
   32be2:	4a3d      	ldr	r2, [pc, #244]	; (32cd8 <z_impl_k_msgq_get+0x140>)
   32be4:	493d      	ldr	r1, [pc, #244]	; (32cdc <z_impl_k_msgq_get+0x144>)
   32be6:	483a      	ldr	r0, [pc, #232]	; (32cd0 <z_impl_k_msgq_get+0x138>)
   32be8:	f005 f86a 	bl	37cc0 <printk>
   32bec:	4631      	mov	r1, r6
   32bee:	483c      	ldr	r0, [pc, #240]	; (32ce0 <z_impl_k_msgq_get+0x148>)
   32bf0:	f005 f866 	bl	37cc0 <printk>
   32bf4:	214a      	movs	r1, #74	; 0x4a
   32bf6:	4838      	ldr	r0, [pc, #224]	; (32cd8 <z_impl_k_msgq_get+0x140>)
   32bf8:	f005 f8a8 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   32bfc:	4630      	mov	r0, r6
   32bfe:	f001 fe41 	bl	34884 <z_spin_lock_set_owner>

	if (msgq->used_msgs > 0) {
   32c02:	6a63      	ldr	r3, [r4, #36]	; 0x24
   32c04:	2b00      	cmp	r3, #0
   32c06:	d039      	beq.n	32c7c <z_impl_k_msgq_get+0xe4>
   32c08:	68e2      	ldr	r2, [r4, #12]
   32c0a:	69e1      	ldr	r1, [r4, #28]
   32c0c:	4640      	mov	r0, r8
   32c0e:	f007 f8b6 	bl	39d7e <memcpy>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
   32c12:	69e3      	ldr	r3, [r4, #28]
   32c14:	68e2      	ldr	r2, [r4, #12]
			msgq->read_ptr = msgq->buffer_start;
		}
		msgq->used_msgs--;

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   32c16:	4620      	mov	r0, r4
		msgq->read_ptr += msgq->msg_size;
   32c18:	4413      	add	r3, r2
		if (msgq->read_ptr == msgq->buffer_end) {
   32c1a:	69a2      	ldr	r2, [r4, #24]
		msgq->read_ptr += msgq->msg_size;
   32c1c:	61e3      	str	r3, [r4, #28]
		if (msgq->read_ptr == msgq->buffer_end) {
   32c1e:	4293      	cmp	r3, r2
			msgq->read_ptr = msgq->buffer_start;
   32c20:	bf04      	itt	eq
   32c22:	6963      	ldreq	r3, [r4, #20]
   32c24:	61e3      	streq	r3, [r4, #28]
		msgq->used_msgs--;
   32c26:	6a63      	ldr	r3, [r4, #36]	; 0x24
   32c28:	3b01      	subs	r3, #1
   32c2a:	6263      	str	r3, [r4, #36]	; 0x24
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   32c2c:	f001 faee 	bl	3420c <z_unpend_first_thread>
		if (pending_thread != NULL) {
   32c30:	4605      	mov	r5, r0
   32c32:	2800      	cmp	r0, #0
   32c34:	d031      	beq.n	32c9a <z_impl_k_msgq_get+0x102>
   32c36:	68e2      	ldr	r2, [r4, #12]
   32c38:	6941      	ldr	r1, [r0, #20]
   32c3a:	6a20      	ldr	r0, [r4, #32]
   32c3c:	f007 f89f 	bl	39d7e <memcpy>
			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
   32c40:	6a23      	ldr	r3, [r4, #32]
   32c42:	68e2      	ldr	r2, [r4, #12]
   32c44:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   32c46:	69a2      	ldr	r2, [r4, #24]
			msgq->write_ptr += msgq->msg_size;
   32c48:	6223      	str	r3, [r4, #32]
			if (msgq->write_ptr == msgq->buffer_end) {
   32c4a:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   32c4c:	bf04      	itt	eq
   32c4e:	6963      	ldreq	r3, [r4, #20]
   32c50:	6223      	streq	r3, [r4, #32]
			}
			msgq->used_msgs++;
   32c52:	6a63      	ldr	r3, [r4, #36]	; 0x24
   32c54:	3301      	adds	r3, #1
   32c56:	6263      	str	r3, [r4, #36]	; 0x24
   32c58:	2300      	movs	r3, #0
   32c5a:	66ab      	str	r3, [r5, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   32c5c:	7b6b      	ldrb	r3, [r5, #13]
   32c5e:	06db      	lsls	r3, r3, #27
   32c60:	d104      	bne.n	32c6c <z_impl_k_msgq_get+0xd4>
	if (z_is_thread_ready(thread)) {
   32c62:	69ab      	ldr	r3, [r5, #24]
   32c64:	b913      	cbnz	r3, 32c6c <z_impl_k_msgq_get+0xd4>
		z_add_thread_to_ready_q(thread);
   32c66:	4628      	mov	r0, r5
   32c68:	f000 fe5a 	bl	33920 <z_add_thread_to_ready_q>

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
   32c6c:	4639      	mov	r1, r7
   32c6e:	4630      	mov	r0, r6
   32c70:	f000 fc6c 	bl	3354c <z_reschedule>
			return 0;
   32c74:	2500      	movs	r5, #0
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   32c76:	4628      	mov	r0, r5
   32c78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (timeout == K_NO_WAIT) {
   32c7c:	b15d      	cbz	r5, 32c96 <z_impl_k_msgq_get+0xfe>
		_current->base.swap_data = data;
   32c7e:	4b19      	ldr	r3, [pc, #100]	; (32ce4 <z_impl_k_msgq_get+0x14c>)
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   32c80:	4622      	mov	r2, r4
		_current->base.swap_data = data;
   32c82:	689b      	ldr	r3, [r3, #8]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   32c84:	4639      	mov	r1, r7
		_current->base.swap_data = data;
   32c86:	f8c3 8014 	str.w	r8, [r3, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   32c8a:	4630      	mov	r0, r6
   32c8c:	462b      	mov	r3, r5
}
   32c8e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   32c92:	f001 b9ff 	b.w	34094 <z_pend_curr>
		result = -ENOMSG;
   32c96:	f06f 0522 	mvn.w	r5, #34	; 0x22
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   32c9a:	4630      	mov	r0, r6
   32c9c:	f001 fde2 	bl	34864 <z_spin_unlock_valid>
   32ca0:	b968      	cbnz	r0, 32cbe <z_impl_k_msgq_get+0x126>
   32ca2:	235d      	movs	r3, #93	; 0x5d
   32ca4:	4a0c      	ldr	r2, [pc, #48]	; (32cd8 <z_impl_k_msgq_get+0x140>)
   32ca6:	4910      	ldr	r1, [pc, #64]	; (32ce8 <z_impl_k_msgq_get+0x150>)
   32ca8:	4809      	ldr	r0, [pc, #36]	; (32cd0 <z_impl_k_msgq_get+0x138>)
   32caa:	f005 f809 	bl	37cc0 <printk>
   32cae:	4631      	mov	r1, r6
   32cb0:	480e      	ldr	r0, [pc, #56]	; (32cec <z_impl_k_msgq_get+0x154>)
   32cb2:	f005 f805 	bl	37cc0 <printk>
   32cb6:	215d      	movs	r1, #93	; 0x5d
   32cb8:	4807      	ldr	r0, [pc, #28]	; (32cd8 <z_impl_k_msgq_get+0x140>)
   32cba:	f005 f847 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   32cbe:	f387 8811 	msr	BASEPRI, r7
   32cc2:	f3bf 8f6f 	isb	sy
	return result;
   32cc6:	e7d6      	b.n	32c76 <z_impl_k_msgq_get+0xde>
   32cc8:	0003f028 	.word	0x0003f028
   32ccc:	0003f006 	.word	0x0003f006
   32cd0:	0003baac 	.word	0x0003baac
   32cd4:	0003da1b 	.word	0x0003da1b
   32cd8:	0003ba71 	.word	0x0003ba71
   32cdc:	0003ba97 	.word	0x0003ba97
   32ce0:	0003bac9 	.word	0x0003bac9
   32ce4:	20022108 	.word	0x20022108
   32ce8:	0003bb0b 	.word	0x0003bb0b
   32cec:	0003bb22 	.word	0x0003bb22

00032cf0 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, s32_t timeout)
{
   32cf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   32cf2:	4604      	mov	r4, r0
   32cf4:	460e      	mov	r6, r1
	__asm__ volatile(
   32cf6:	f04f 0320 	mov.w	r3, #32
   32cfa:	f3ef 8511 	mrs	r5, BASEPRI
   32cfe:	f383 8811 	msr	BASEPRI, r3
   32d02:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   32d06:	4861      	ldr	r0, [pc, #388]	; (32e8c <z_impl_k_mutex_lock+0x19c>)
   32d08:	f001 fd9e 	bl	34848 <z_spin_lock_valid>
   32d0c:	b968      	cbnz	r0, 32d2a <z_impl_k_mutex_lock+0x3a>
   32d0e:	234a      	movs	r3, #74	; 0x4a
   32d10:	4a5f      	ldr	r2, [pc, #380]	; (32e90 <z_impl_k_mutex_lock+0x1a0>)
   32d12:	4960      	ldr	r1, [pc, #384]	; (32e94 <z_impl_k_mutex_lock+0x1a4>)
   32d14:	4860      	ldr	r0, [pc, #384]	; (32e98 <z_impl_k_mutex_lock+0x1a8>)
   32d16:	f004 ffd3 	bl	37cc0 <printk>
   32d1a:	495c      	ldr	r1, [pc, #368]	; (32e8c <z_impl_k_mutex_lock+0x19c>)
   32d1c:	485f      	ldr	r0, [pc, #380]	; (32e9c <z_impl_k_mutex_lock+0x1ac>)
   32d1e:	f004 ffcf 	bl	37cc0 <printk>
   32d22:	214a      	movs	r1, #74	; 0x4a
   32d24:	485a      	ldr	r0, [pc, #360]	; (32e90 <z_impl_k_mutex_lock+0x1a0>)
   32d26:	f005 f811 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   32d2a:	4858      	ldr	r0, [pc, #352]	; (32e8c <z_impl_k_mutex_lock+0x19c>)
   32d2c:	f001 fdaa 	bl	34884 <z_spin_lock_set_owner>
	bool resched = false;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   32d30:	68e3      	ldr	r3, [r4, #12]
   32d32:	4a5b      	ldr	r2, [pc, #364]	; (32ea0 <z_impl_k_mutex_lock+0x1b0>)
   32d34:	b1f3      	cbz	r3, 32d74 <z_impl_k_mutex_lock+0x84>
   32d36:	68a0      	ldr	r0, [r4, #8]
   32d38:	6891      	ldr	r1, [r2, #8]
   32d3a:	4288      	cmp	r0, r1
   32d3c:	d03a      	beq.n	32db4 <z_impl_k_mutex_lock+0xc4>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(timeout == (s32_t)K_NO_WAIT)) {
   32d3e:	2e00      	cmp	r6, #0
   32d40:	d13a      	bne.n	32db8 <z_impl_k_mutex_lock+0xc8>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   32d42:	4852      	ldr	r0, [pc, #328]	; (32e8c <z_impl_k_mutex_lock+0x19c>)
   32d44:	f001 fd8e 	bl	34864 <z_spin_unlock_valid>
   32d48:	b968      	cbnz	r0, 32d66 <z_impl_k_mutex_lock+0x76>
   32d4a:	235d      	movs	r3, #93	; 0x5d
   32d4c:	4a50      	ldr	r2, [pc, #320]	; (32e90 <z_impl_k_mutex_lock+0x1a0>)
   32d4e:	4955      	ldr	r1, [pc, #340]	; (32ea4 <z_impl_k_mutex_lock+0x1b4>)
   32d50:	4851      	ldr	r0, [pc, #324]	; (32e98 <z_impl_k_mutex_lock+0x1a8>)
   32d52:	f004 ffb5 	bl	37cc0 <printk>
   32d56:	494d      	ldr	r1, [pc, #308]	; (32e8c <z_impl_k_mutex_lock+0x19c>)
   32d58:	4853      	ldr	r0, [pc, #332]	; (32ea8 <z_impl_k_mutex_lock+0x1b8>)
   32d5a:	f004 ffb1 	bl	37cc0 <printk>
   32d5e:	215d      	movs	r1, #93	; 0x5d
   32d60:	484b      	ldr	r0, [pc, #300]	; (32e90 <z_impl_k_mutex_lock+0x1a0>)
   32d62:	f004 fff3 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   32d66:	f385 8811 	msr	BASEPRI, r5
   32d6a:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
   32d6e:	f06f 000f 	mvn.w	r0, #15
   32d72:	e01e      	b.n	32db2 <z_impl_k_mutex_lock+0xc2>
					_current->base.prio :
   32d74:	6891      	ldr	r1, [r2, #8]
   32d76:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
   32d7a:	3301      	adds	r3, #1
   32d7c:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   32d7e:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   32d80:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
   32d82:	60a3      	str	r3, [r4, #8]
   32d84:	4841      	ldr	r0, [pc, #260]	; (32e8c <z_impl_k_mutex_lock+0x19c>)
   32d86:	f001 fd6d 	bl	34864 <z_spin_unlock_valid>
   32d8a:	b968      	cbnz	r0, 32da8 <z_impl_k_mutex_lock+0xb8>
   32d8c:	235d      	movs	r3, #93	; 0x5d
   32d8e:	4a40      	ldr	r2, [pc, #256]	; (32e90 <z_impl_k_mutex_lock+0x1a0>)
   32d90:	4944      	ldr	r1, [pc, #272]	; (32ea4 <z_impl_k_mutex_lock+0x1b4>)
   32d92:	4841      	ldr	r0, [pc, #260]	; (32e98 <z_impl_k_mutex_lock+0x1a8>)
   32d94:	f004 ff94 	bl	37cc0 <printk>
   32d98:	493c      	ldr	r1, [pc, #240]	; (32e8c <z_impl_k_mutex_lock+0x19c>)
   32d9a:	4843      	ldr	r0, [pc, #268]	; (32ea8 <z_impl_k_mutex_lock+0x1b8>)
   32d9c:	f004 ff90 	bl	37cc0 <printk>
   32da0:	215d      	movs	r1, #93	; 0x5d
   32da2:	483b      	ldr	r0, [pc, #236]	; (32e90 <z_impl_k_mutex_lock+0x1a0>)
   32da4:	f004 ffd2 	bl	37d4c <assert_post_action>
   32da8:	f385 8811 	msr	BASEPRI, r5
   32dac:	f3bf 8f6f 	isb	sy
		return 0;
   32db0:	2000      	movs	r0, #0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
   32db2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					_current->base.prio :
   32db4:	6921      	ldr	r1, [r4, #16]
   32db6:	e7e0      	b.n	32d7a <z_impl_k_mutex_lock+0x8a>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   32db8:	f990 300e 	ldrsb.w	r3, [r0, #14]
   32dbc:	f991 100e 	ldrsb.w	r1, [r1, #14]
   32dc0:	4299      	cmp	r1, r3
   32dc2:	bfa8      	it	ge
   32dc4:	4619      	movge	r1, r3
   32dc6:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   32dca:	4299      	cmp	r1, r3
   32dcc:	da40      	bge.n	32e50 <z_impl_k_mutex_lock+0x160>
		return z_set_prio(mutex->owner, new_prio);
   32dce:	f001 f98f 	bl	340f0 <z_set_prio>
   32dd2:	4607      	mov	r7, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   32dd4:	4633      	mov	r3, r6
   32dd6:	4622      	mov	r2, r4
   32dd8:	4629      	mov	r1, r5
   32dda:	482c      	ldr	r0, [pc, #176]	; (32e8c <z_impl_k_mutex_lock+0x19c>)
   32ddc:	f001 f95a 	bl	34094 <z_pend_curr>
	if (got_mutex == 0) {
   32de0:	2800      	cmp	r0, #0
   32de2:	d0e6      	beq.n	32db2 <z_impl_k_mutex_lock+0xc2>
	__asm__ volatile(
   32de4:	f04f 0320 	mov.w	r3, #32
   32de8:	f3ef 8511 	mrs	r5, BASEPRI
   32dec:	f383 8811 	msr	BASEPRI, r3
   32df0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   32df4:	4825      	ldr	r0, [pc, #148]	; (32e8c <z_impl_k_mutex_lock+0x19c>)
   32df6:	f001 fd27 	bl	34848 <z_spin_lock_valid>
   32dfa:	b968      	cbnz	r0, 32e18 <z_impl_k_mutex_lock+0x128>
   32dfc:	234a      	movs	r3, #74	; 0x4a
   32dfe:	4a24      	ldr	r2, [pc, #144]	; (32e90 <z_impl_k_mutex_lock+0x1a0>)
   32e00:	4924      	ldr	r1, [pc, #144]	; (32e94 <z_impl_k_mutex_lock+0x1a4>)
   32e02:	4825      	ldr	r0, [pc, #148]	; (32e98 <z_impl_k_mutex_lock+0x1a8>)
   32e04:	f004 ff5c 	bl	37cc0 <printk>
   32e08:	4920      	ldr	r1, [pc, #128]	; (32e8c <z_impl_k_mutex_lock+0x19c>)
   32e0a:	4824      	ldr	r0, [pc, #144]	; (32e9c <z_impl_k_mutex_lock+0x1ac>)
   32e0c:	f004 ff58 	bl	37cc0 <printk>
   32e10:	214a      	movs	r1, #74	; 0x4a
   32e12:	481f      	ldr	r0, [pc, #124]	; (32e90 <z_impl_k_mutex_lock+0x1a0>)
   32e14:	f004 ff9a 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   32e18:	481c      	ldr	r0, [pc, #112]	; (32e8c <z_impl_k_mutex_lock+0x19c>)
   32e1a:	f001 fd33 	bl	34884 <z_spin_lock_set_owner>
	return list->head == list;
   32e1e:	6823      	ldr	r3, [r4, #0]
   32e20:	6921      	ldr	r1, [r4, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   32e22:	429c      	cmp	r4, r3
   32e24:	d007      	beq.n	32e36 <z_impl_k_mutex_lock+0x146>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   32e26:	b133      	cbz	r3, 32e36 <z_impl_k_mutex_lock+0x146>
   32e28:	f993 300e 	ldrsb.w	r3, [r3, #14]
   32e2c:	4299      	cmp	r1, r3
   32e2e:	bfa8      	it	ge
   32e30:	4619      	movge	r1, r3
   32e32:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   32e36:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   32e38:	f990 300e 	ldrsb.w	r3, [r0, #14]
   32e3c:	4299      	cmp	r1, r3
   32e3e:	d109      	bne.n	32e54 <z_impl_k_mutex_lock+0x164>
	if (resched) {
   32e40:	b16f      	cbz	r7, 32e5e <z_impl_k_mutex_lock+0x16e>
		z_reschedule(&lock, key);
   32e42:	4629      	mov	r1, r5
   32e44:	4811      	ldr	r0, [pc, #68]	; (32e8c <z_impl_k_mutex_lock+0x19c>)
   32e46:	f000 fb81 	bl	3354c <z_reschedule>
	return -EAGAIN;
   32e4a:	f06f 000a 	mvn.w	r0, #10
   32e4e:	e7b0      	b.n	32db2 <z_impl_k_mutex_lock+0xc2>
	bool resched = false;
   32e50:	2700      	movs	r7, #0
   32e52:	e7bf      	b.n	32dd4 <z_impl_k_mutex_lock+0xe4>
		return z_set_prio(mutex->owner, new_prio);
   32e54:	f001 f94c 	bl	340f0 <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   32e58:	2800      	cmp	r0, #0
   32e5a:	d1f2      	bne.n	32e42 <z_impl_k_mutex_lock+0x152>
   32e5c:	e7f0      	b.n	32e40 <z_impl_k_mutex_lock+0x150>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   32e5e:	480b      	ldr	r0, [pc, #44]	; (32e8c <z_impl_k_mutex_lock+0x19c>)
   32e60:	f001 fd00 	bl	34864 <z_spin_unlock_valid>
   32e64:	b968      	cbnz	r0, 32e82 <z_impl_k_mutex_lock+0x192>
   32e66:	235d      	movs	r3, #93	; 0x5d
   32e68:	4a09      	ldr	r2, [pc, #36]	; (32e90 <z_impl_k_mutex_lock+0x1a0>)
   32e6a:	490e      	ldr	r1, [pc, #56]	; (32ea4 <z_impl_k_mutex_lock+0x1b4>)
   32e6c:	480a      	ldr	r0, [pc, #40]	; (32e98 <z_impl_k_mutex_lock+0x1a8>)
   32e6e:	f004 ff27 	bl	37cc0 <printk>
   32e72:	4906      	ldr	r1, [pc, #24]	; (32e8c <z_impl_k_mutex_lock+0x19c>)
   32e74:	480c      	ldr	r0, [pc, #48]	; (32ea8 <z_impl_k_mutex_lock+0x1b8>)
   32e76:	f004 ff23 	bl	37cc0 <printk>
   32e7a:	215d      	movs	r1, #93	; 0x5d
   32e7c:	4804      	ldr	r0, [pc, #16]	; (32e90 <z_impl_k_mutex_lock+0x1a0>)
   32e7e:	f004 ff65 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   32e82:	f385 8811 	msr	BASEPRI, r5
   32e86:	f3bf 8f6f 	isb	sy
   32e8a:	e7de      	b.n	32e4a <z_impl_k_mutex_lock+0x15a>
   32e8c:	20022104 	.word	0x20022104
   32e90:	0003ba71 	.word	0x0003ba71
   32e94:	0003ba97 	.word	0x0003ba97
   32e98:	0003baac 	.word	0x0003baac
   32e9c:	0003bac9 	.word	0x0003bac9
   32ea0:	20022108 	.word	0x20022108
   32ea4:	0003bb0b 	.word	0x0003bb0b
   32ea8:	0003bb22 	.word	0x0003bb22

00032eac <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   32eac:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *new_owner;

	CHECKIF(mutex->owner == NULL) {
   32eae:	6883      	ldr	r3, [r0, #8]
{
   32eb0:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   32eb2:	2b00      	cmp	r3, #0
   32eb4:	f000 8096 	beq.w	32fe4 <z_impl_k_mutex_unlock+0x138>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   32eb8:	4d4d      	ldr	r5, [pc, #308]	; (32ff0 <z_impl_k_mutex_unlock+0x144>)
   32eba:	68aa      	ldr	r2, [r5, #8]
   32ebc:	4293      	cmp	r3, r2
   32ebe:	f040 8094 	bne.w	32fea <z_impl_k_mutex_unlock+0x13e>
	 * Attempt to unlock a mutex which is unlocked. mutex->lock_count
	 * cannot be zero if the current thread is equal to mutex->owner,
	 * therefore no underflow check is required. Use assert to catch
	 * undefined behavior.
	 */
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
   32ec2:	68c3      	ldr	r3, [r0, #12]
   32ec4:	b94b      	cbnz	r3, 32eda <z_impl_k_mutex_unlock+0x2e>
   32ec6:	494b      	ldr	r1, [pc, #300]	; (32ff4 <z_impl_k_mutex_unlock+0x148>)
   32ec8:	484b      	ldr	r0, [pc, #300]	; (32ff8 <z_impl_k_mutex_unlock+0x14c>)
   32eca:	23e5      	movs	r3, #229	; 0xe5
   32ecc:	4a4b      	ldr	r2, [pc, #300]	; (32ffc <z_impl_k_mutex_unlock+0x150>)
   32ece:	f004 fef7 	bl	37cc0 <printk>
   32ed2:	21e5      	movs	r1, #229	; 0xe5
   32ed4:	4849      	ldr	r0, [pc, #292]	; (32ffc <z_impl_k_mutex_unlock+0x150>)
   32ed6:	f004 ff39 	bl	37d4c <assert_post_action>
   32eda:	f3ef 8305 	mrs	r3, IPSR
}

static inline void z_sched_lock(void)
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
   32ede:	b173      	cbz	r3, 32efe <z_impl_k_mutex_unlock+0x52>
   32ee0:	4947      	ldr	r1, [pc, #284]	; (33000 <z_impl_k_mutex_unlock+0x154>)
   32ee2:	f240 130d 	movw	r3, #269	; 0x10d
   32ee6:	4a47      	ldr	r2, [pc, #284]	; (33004 <z_impl_k_mutex_unlock+0x158>)
   32ee8:	4843      	ldr	r0, [pc, #268]	; (32ff8 <z_impl_k_mutex_unlock+0x14c>)
   32eea:	f004 fee9 	bl	37cc0 <printk>
   32eee:	4846      	ldr	r0, [pc, #280]	; (33008 <z_impl_k_mutex_unlock+0x15c>)
   32ef0:	f004 fee6 	bl	37cc0 <printk>
   32ef4:	f240 110d 	movw	r1, #269	; 0x10d
   32ef8:	4842      	ldr	r0, [pc, #264]	; (33004 <z_impl_k_mutex_unlock+0x158>)
   32efa:	f004 ff27 	bl	37d4c <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1, "");
   32efe:	68ab      	ldr	r3, [r5, #8]
   32f00:	7bdb      	ldrb	r3, [r3, #15]
   32f02:	2b01      	cmp	r3, #1
   32f04:	d10e      	bne.n	32f24 <z_impl_k_mutex_unlock+0x78>
   32f06:	4941      	ldr	r1, [pc, #260]	; (3300c <z_impl_k_mutex_unlock+0x160>)
   32f08:	f44f 7387 	mov.w	r3, #270	; 0x10e
   32f0c:	4a3d      	ldr	r2, [pc, #244]	; (33004 <z_impl_k_mutex_unlock+0x158>)
   32f0e:	483a      	ldr	r0, [pc, #232]	; (32ff8 <z_impl_k_mutex_unlock+0x14c>)
   32f10:	f004 fed6 	bl	37cc0 <printk>
   32f14:	483c      	ldr	r0, [pc, #240]	; (33008 <z_impl_k_mutex_unlock+0x15c>)
   32f16:	f004 fed3 	bl	37cc0 <printk>
   32f1a:	f44f 7187 	mov.w	r1, #270	; 0x10e
   32f1e:	4839      	ldr	r0, [pc, #228]	; (33004 <z_impl_k_mutex_unlock+0x158>)
   32f20:	f004 ff14 	bl	37d4c <assert_post_action>

	--_current->base.sched_locked;
   32f24:	68aa      	ldr	r2, [r5, #8]
   32f26:	7bd3      	ldrb	r3, [r2, #15]
   32f28:	3b01      	subs	r3, #1
   32f2a:	73d3      	strb	r3, [r2, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count - 1U != 0U) {
   32f2c:	68e3      	ldr	r3, [r4, #12]
   32f2e:	2b01      	cmp	r3, #1
   32f30:	d005      	beq.n	32f3e <z_impl_k_mutex_unlock+0x92>
		mutex->lock_count--;
   32f32:	3b01      	subs	r3, #1
   32f34:	60e3      	str	r3, [r4, #12]
		k_spin_unlock(&lock, key);
	}


k_mutex_unlock_return:
	k_sched_unlock();
   32f36:	f000 fc77 	bl	33828 <k_sched_unlock>
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);

	return 0;
   32f3a:	2000      	movs	r0, #0
}
   32f3c:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   32f3e:	f04f 0320 	mov.w	r3, #32
   32f42:	f3ef 8511 	mrs	r5, BASEPRI
   32f46:	f383 8811 	msr	BASEPRI, r3
   32f4a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   32f4e:	4830      	ldr	r0, [pc, #192]	; (33010 <z_impl_k_mutex_unlock+0x164>)
   32f50:	f001 fc7a 	bl	34848 <z_spin_lock_valid>
   32f54:	b968      	cbnz	r0, 32f72 <z_impl_k_mutex_unlock+0xc6>
   32f56:	234a      	movs	r3, #74	; 0x4a
   32f58:	4a2e      	ldr	r2, [pc, #184]	; (33014 <z_impl_k_mutex_unlock+0x168>)
   32f5a:	492f      	ldr	r1, [pc, #188]	; (33018 <z_impl_k_mutex_unlock+0x16c>)
   32f5c:	4826      	ldr	r0, [pc, #152]	; (32ff8 <z_impl_k_mutex_unlock+0x14c>)
   32f5e:	f004 feaf 	bl	37cc0 <printk>
   32f62:	492b      	ldr	r1, [pc, #172]	; (33010 <z_impl_k_mutex_unlock+0x164>)
   32f64:	482d      	ldr	r0, [pc, #180]	; (3301c <z_impl_k_mutex_unlock+0x170>)
   32f66:	f004 feab 	bl	37cc0 <printk>
   32f6a:	214a      	movs	r1, #74	; 0x4a
   32f6c:	4829      	ldr	r0, [pc, #164]	; (33014 <z_impl_k_mutex_unlock+0x168>)
   32f6e:	f004 feed 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   32f72:	4827      	ldr	r0, [pc, #156]	; (33010 <z_impl_k_mutex_unlock+0x164>)
   32f74:	f001 fc86 	bl	34884 <z_spin_lock_set_owner>
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   32f78:	68a0      	ldr	r0, [r4, #8]
   32f7a:	6921      	ldr	r1, [r4, #16]
	if (mutex->owner->base.prio != new_prio) {
   32f7c:	f990 300e 	ldrsb.w	r3, [r0, #14]
   32f80:	4299      	cmp	r1, r3
   32f82:	d001      	beq.n	32f88 <z_impl_k_mutex_unlock+0xdc>
		return z_set_prio(mutex->owner, new_prio);
   32f84:	f001 f8b4 	bl	340f0 <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   32f88:	4620      	mov	r0, r4
   32f8a:	f001 f93f 	bl	3420c <z_unpend_first_thread>
	mutex->owner = new_owner;
   32f8e:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   32f90:	b180      	cbz	r0, 32fb4 <z_impl_k_mutex_unlock+0x108>
		mutex->owner_orig_prio = new_owner->base.prio;
   32f92:	f990 200e 	ldrsb.w	r2, [r0, #14]
   32f96:	6122      	str	r2, [r4, #16]
   32f98:	2200      	movs	r2, #0
   32f9a:	6682      	str	r2, [r0, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   32f9c:	7b42      	ldrb	r2, [r0, #13]
   32f9e:	06d2      	lsls	r2, r2, #27
   32fa0:	d103      	bne.n	32faa <z_impl_k_mutex_unlock+0xfe>
	if (z_is_thread_ready(thread)) {
   32fa2:	6983      	ldr	r3, [r0, #24]
   32fa4:	b90b      	cbnz	r3, 32faa <z_impl_k_mutex_unlock+0xfe>
		z_add_thread_to_ready_q(thread);
   32fa6:	f000 fcbb 	bl	33920 <z_add_thread_to_ready_q>
		z_reschedule(&lock, key);
   32faa:	4629      	mov	r1, r5
   32fac:	4818      	ldr	r0, [pc, #96]	; (33010 <z_impl_k_mutex_unlock+0x164>)
   32fae:	f000 facd 	bl	3354c <z_reschedule>
   32fb2:	e7c0      	b.n	32f36 <z_impl_k_mutex_unlock+0x8a>
		mutex->lock_count = 0U;
   32fb4:	60e0      	str	r0, [r4, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   32fb6:	4816      	ldr	r0, [pc, #88]	; (33010 <z_impl_k_mutex_unlock+0x164>)
   32fb8:	f001 fc54 	bl	34864 <z_spin_unlock_valid>
   32fbc:	b968      	cbnz	r0, 32fda <z_impl_k_mutex_unlock+0x12e>
   32fbe:	235d      	movs	r3, #93	; 0x5d
   32fc0:	4a14      	ldr	r2, [pc, #80]	; (33014 <z_impl_k_mutex_unlock+0x168>)
   32fc2:	4917      	ldr	r1, [pc, #92]	; (33020 <z_impl_k_mutex_unlock+0x174>)
   32fc4:	480c      	ldr	r0, [pc, #48]	; (32ff8 <z_impl_k_mutex_unlock+0x14c>)
   32fc6:	f004 fe7b 	bl	37cc0 <printk>
   32fca:	4911      	ldr	r1, [pc, #68]	; (33010 <z_impl_k_mutex_unlock+0x164>)
   32fcc:	4815      	ldr	r0, [pc, #84]	; (33024 <z_impl_k_mutex_unlock+0x178>)
   32fce:	f004 fe77 	bl	37cc0 <printk>
   32fd2:	215d      	movs	r1, #93	; 0x5d
   32fd4:	480f      	ldr	r0, [pc, #60]	; (33014 <z_impl_k_mutex_unlock+0x168>)
   32fd6:	f004 feb9 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   32fda:	f385 8811 	msr	BASEPRI, r5
   32fde:	f3bf 8f6f 	isb	sy
   32fe2:	e7a8      	b.n	32f36 <z_impl_k_mutex_unlock+0x8a>
		return -EINVAL;
   32fe4:	f06f 0015 	mvn.w	r0, #21
   32fe8:	e7a8      	b.n	32f3c <z_impl_k_mutex_unlock+0x90>
		return -EPERM;
   32fea:	f04f 30ff 	mov.w	r0, #4294967295
   32fee:	e7a5      	b.n	32f3c <z_impl_k_mutex_unlock+0x90>
   32ff0:	20022108 	.word	0x20022108
   32ff4:	0003f06c 	.word	0x0003f06c
   32ff8:	0003baac 	.word	0x0003baac
   32ffc:	0003f04a 	.word	0x0003f04a
   33000:	0003f0ae 	.word	0x0003f0ae
   33004:	0003f083 	.word	0x0003f083
   33008:	0003da1b 	.word	0x0003da1b
   3300c:	0003f0c0 	.word	0x0003f0c0
   33010:	20022104 	.word	0x20022104
   33014:	0003ba71 	.word	0x0003ba71
   33018:	0003ba97 	.word	0x0003ba97
   3301c:	0003bac9 	.word	0x0003bac9
   33020:	0003bb0b 	.word	0x0003bb0b
   33024:	0003bb22 	.word	0x0003bb22

00033028 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static s32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			  bool alloc)
{
   33028:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   3302c:	4604      	mov	r4, r0
   3302e:	460e      	mov	r6, r1
   33030:	4690      	mov	r8, r2
   33032:	4699      	mov	r9, r3
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   33034:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   33038:	f04f 0320 	mov.w	r3, #32
   3303c:	f3ef 8711 	mrs	r7, BASEPRI
   33040:	f383 8811 	msr	BASEPRI, r3
   33044:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   33048:	4628      	mov	r0, r5
   3304a:	f001 fbfd 	bl	34848 <z_spin_lock_valid>
   3304e:	b968      	cbnz	r0, 3306c <queue_insert+0x44>
   33050:	234a      	movs	r3, #74	; 0x4a
   33052:	4a33      	ldr	r2, [pc, #204]	; (33120 <queue_insert+0xf8>)
   33054:	4933      	ldr	r1, [pc, #204]	; (33124 <queue_insert+0xfc>)
   33056:	4834      	ldr	r0, [pc, #208]	; (33128 <queue_insert+0x100>)
   33058:	f004 fe32 	bl	37cc0 <printk>
   3305c:	4629      	mov	r1, r5
   3305e:	4833      	ldr	r0, [pc, #204]	; (3312c <queue_insert+0x104>)
   33060:	f004 fe2e 	bl	37cc0 <printk>
   33064:	214a      	movs	r1, #74	; 0x4a
   33066:	482e      	ldr	r0, [pc, #184]	; (33120 <queue_insert+0xf8>)
   33068:	f004 fe70 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   3306c:	4628      	mov	r0, r5
   3306e:	f001 fc09 	bl	34884 <z_spin_lock_set_owner>
		return 0;
	}
#endif /* !CONFIG_POLL */

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
   33072:	f1b9 0f00 	cmp.w	r9, #0
   33076:	d02d      	beq.n	330d4 <queue_insert+0xac>
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
   33078:	2008      	movs	r0, #8
   3307a:	f7ff fcd7 	bl	32a2c <z_thread_malloc>
		if (anode == NULL) {
   3307e:	b9c8      	cbnz	r0, 330b4 <queue_insert+0x8c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   33080:	4628      	mov	r0, r5
   33082:	f001 fbef 	bl	34864 <z_spin_unlock_valid>
   33086:	b968      	cbnz	r0, 330a4 <queue_insert+0x7c>
   33088:	235d      	movs	r3, #93	; 0x5d
   3308a:	4a25      	ldr	r2, [pc, #148]	; (33120 <queue_insert+0xf8>)
   3308c:	4928      	ldr	r1, [pc, #160]	; (33130 <queue_insert+0x108>)
   3308e:	4826      	ldr	r0, [pc, #152]	; (33128 <queue_insert+0x100>)
   33090:	f004 fe16 	bl	37cc0 <printk>
   33094:	4629      	mov	r1, r5
   33096:	4827      	ldr	r0, [pc, #156]	; (33134 <queue_insert+0x10c>)
   33098:	f004 fe12 	bl	37cc0 <printk>
   3309c:	215d      	movs	r1, #93	; 0x5d
   3309e:	4820      	ldr	r0, [pc, #128]	; (33120 <queue_insert+0xf8>)
   330a0:	f004 fe54 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   330a4:	f387 8811 	msr	BASEPRI, r7
   330a8:	f3bf 8f6f 	isb	sy
			k_spin_unlock(&queue->lock, key);
			return -ENOMEM;
   330ac:	f06f 000b 	mvn.w	r0, #11
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* CONFIG_POLL */

	z_reschedule(&queue->lock, key);
	return 0;
}
   330b0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	node->next_and_flags = flags;
   330b4:	2301      	movs	r3, #1
		anode->data = data;
   330b6:	f8c0 8004 	str.w	r8, [r0, #4]
   330ba:	6003      	str	r3, [r0, #0]
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
   330bc:	6803      	ldr	r3, [r0, #0]
   330be:	f003 0203 	and.w	r2, r3, #3
   330c2:	b95e      	cbnz	r6, 330dc <queue_insert+0xb4>
	parent->next_and_flags = cur_flags | (unative_t)child;
   330c4:	6823      	ldr	r3, [r4, #0]
   330c6:	4313      	orrs	r3, r2
   330c8:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   330ca:	6863      	ldr	r3, [r4, #4]
	list->head = node;
   330cc:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   330ce:	b973      	cbnz	r3, 330ee <queue_insert+0xc6>
	list->tail = node;
   330d0:	6060      	str	r0, [r4, #4]
   330d2:	e00c      	b.n	330ee <queue_insert+0xc6>
	node->next_and_flags = flags;
   330d4:	f8c8 9000 	str.w	r9, [r8]
   330d8:	4640      	mov	r0, r8
   330da:	e7ef      	b.n	330bc <queue_insert+0x94>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   330dc:	6833      	ldr	r3, [r6, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   330de:	f033 0303 	bics.w	r3, r3, #3
   330e2:	d115      	bne.n	33110 <queue_insert+0xe8>
	parent->next_and_flags = cur_flags | (unative_t)child;
   330e4:	6002      	str	r2, [r0, #0]
Z_GENLIST_APPEND(sflist, sfnode)
   330e6:	6862      	ldr	r2, [r4, #4]
   330e8:	b962      	cbnz	r2, 33104 <queue_insert+0xdc>
	list->head = node;
   330ea:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   330ee:	2104      	movs	r1, #4
   330f0:	f104 000c 	add.w	r0, r4, #12
   330f4:	f006 fe14 	bl	39d20 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   330f8:	4628      	mov	r0, r5
   330fa:	4639      	mov	r1, r7
   330fc:	f000 fa26 	bl	3354c <z_reschedule>
	return 0;
   33100:	2000      	movs	r0, #0
   33102:	e7d5      	b.n	330b0 <queue_insert+0x88>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   33104:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   33106:	f003 0303 	and.w	r3, r3, #3
   3310a:	4303      	orrs	r3, r0
   3310c:	6013      	str	r3, [r2, #0]
   3310e:	e7df      	b.n	330d0 <queue_insert+0xa8>
   33110:	4313      	orrs	r3, r2
   33112:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   33114:	6833      	ldr	r3, [r6, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   33116:	f003 0303 	and.w	r3, r3, #3
   3311a:	4318      	orrs	r0, r3
   3311c:	6030      	str	r0, [r6, #0]
   3311e:	e7e6      	b.n	330ee <queue_insert+0xc6>
   33120:	0003ba71 	.word	0x0003ba71
   33124:	0003ba97 	.word	0x0003ba97
   33128:	0003baac 	.word	0x0003baac
   3312c:	0003bac9 	.word	0x0003bac9
   33130:	0003bb0b 	.word	0x0003bb0b
   33134:	0003bb22 	.word	0x0003bb22

00033138 <z_impl_k_queue_get>:
	return val;
}
#endif /* CONFIG_POLL */

void *z_impl_k_queue_get(struct k_queue *queue, s32_t timeout)
{
   33138:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3313c:	4606      	mov	r6, r0
   3313e:	b089      	sub	sp, #36	; 0x24
   33140:	460f      	mov	r7, r1
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   33142:	f100 0408 	add.w	r4, r0, #8
	__asm__ volatile(
   33146:	f04f 0320 	mov.w	r3, #32
   3314a:	f3ef 8811 	mrs	r8, BASEPRI
   3314e:	f383 8811 	msr	BASEPRI, r3
   33152:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   33156:	4620      	mov	r0, r4
   33158:	f001 fb76 	bl	34848 <z_spin_lock_valid>
   3315c:	b968      	cbnz	r0, 3317a <z_impl_k_queue_get+0x42>
   3315e:	234a      	movs	r3, #74	; 0x4a
   33160:	4a5f      	ldr	r2, [pc, #380]	; (332e0 <z_impl_k_queue_get+0x1a8>)
   33162:	4960      	ldr	r1, [pc, #384]	; (332e4 <z_impl_k_queue_get+0x1ac>)
   33164:	4860      	ldr	r0, [pc, #384]	; (332e8 <z_impl_k_queue_get+0x1b0>)
   33166:	f004 fdab 	bl	37cc0 <printk>
   3316a:	4621      	mov	r1, r4
   3316c:	485f      	ldr	r0, [pc, #380]	; (332ec <z_impl_k_queue_get+0x1b4>)
   3316e:	f004 fda7 	bl	37cc0 <printk>
   33172:	214a      	movs	r1, #74	; 0x4a
   33174:	485a      	ldr	r0, [pc, #360]	; (332e0 <z_impl_k_queue_get+0x1a8>)
   33176:	f004 fde9 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   3317a:	4620      	mov	r0, r4
   3317c:	f001 fb82 	bl	34884 <z_spin_lock_set_owner>
Z_GENLIST_IS_EMPTY(sflist)
   33180:	6835      	ldr	r5, [r6, #0]
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   33182:	b335      	cbz	r5, 331d2 <z_impl_k_queue_get+0x9a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   33184:	682b      	ldr	r3, [r5, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   33186:	6872      	ldr	r2, [r6, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   33188:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   3318c:	4295      	cmp	r5, r2
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   3318e:	4628      	mov	r0, r5
	list->head = node;
   33190:	6033      	str	r3, [r6, #0]
	list->tail = node;
   33192:	bf08      	it	eq
   33194:	6073      	streq	r3, [r6, #4]
   33196:	2101      	movs	r1, #1
   33198:	f006 fc47 	bl	39a2a <z_queue_node_peek>
   3319c:	4605      	mov	r5, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   3319e:	4620      	mov	r0, r4
   331a0:	f001 fb60 	bl	34864 <z_spin_unlock_valid>
   331a4:	b968      	cbnz	r0, 331c2 <z_impl_k_queue_get+0x8a>
   331a6:	235d      	movs	r3, #93	; 0x5d
   331a8:	4a4d      	ldr	r2, [pc, #308]	; (332e0 <z_impl_k_queue_get+0x1a8>)
   331aa:	4951      	ldr	r1, [pc, #324]	; (332f0 <z_impl_k_queue_get+0x1b8>)
   331ac:	484e      	ldr	r0, [pc, #312]	; (332e8 <z_impl_k_queue_get+0x1b0>)
   331ae:	f004 fd87 	bl	37cc0 <printk>
   331b2:	4621      	mov	r1, r4
   331b4:	484f      	ldr	r0, [pc, #316]	; (332f4 <z_impl_k_queue_get+0x1bc>)
   331b6:	f004 fd83 	bl	37cc0 <printk>
   331ba:	215d      	movs	r1, #93	; 0x5d
   331bc:	4848      	ldr	r0, [pc, #288]	; (332e0 <z_impl_k_queue_get+0x1a8>)
   331be:	f004 fdc5 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   331c2:	f388 8811 	msr	BASEPRI, r8
   331c6:	f3bf 8f6f 	isb	sy
#else
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
#endif /* CONFIG_POLL */
}
   331ca:	4628      	mov	r0, r5
   331cc:	b009      	add	sp, #36	; 0x24
   331ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   331d2:	4620      	mov	r0, r4
	if (timeout == K_NO_WAIT) {
   331d4:	2f00      	cmp	r7, #0
   331d6:	d0e3      	beq.n	331a0 <z_impl_k_queue_get+0x68>
   331d8:	f001 fb44 	bl	34864 <z_spin_unlock_valid>
   331dc:	b968      	cbnz	r0, 331fa <z_impl_k_queue_get+0xc2>
   331de:	235d      	movs	r3, #93	; 0x5d
   331e0:	4a3f      	ldr	r2, [pc, #252]	; (332e0 <z_impl_k_queue_get+0x1a8>)
   331e2:	4943      	ldr	r1, [pc, #268]	; (332f0 <z_impl_k_queue_get+0x1b8>)
   331e4:	4840      	ldr	r0, [pc, #256]	; (332e8 <z_impl_k_queue_get+0x1b0>)
   331e6:	f004 fd6b 	bl	37cc0 <printk>
   331ea:	4621      	mov	r1, r4
   331ec:	4841      	ldr	r0, [pc, #260]	; (332f4 <z_impl_k_queue_get+0x1bc>)
   331ee:	f004 fd67 	bl	37cc0 <printk>
   331f2:	215d      	movs	r1, #93	; 0x5d
   331f4:	483a      	ldr	r0, [pc, #232]	; (332e0 <z_impl_k_queue_get+0x1a8>)
   331f6:	f004 fda9 	bl	37d4c <assert_post_action>
   331fa:	f388 8811 	msr	BASEPRI, r8
   331fe:	f3bf 8f6f 	isb	sy
	k_poll_event_init(&event, K_POLL_TYPE_FIFO_DATA_AVAILABLE,
   33202:	2200      	movs	r2, #0
   33204:	4633      	mov	r3, r6
   33206:	2104      	movs	r1, #4
   33208:	a803      	add	r0, sp, #12
   3320a:	f002 fb03 	bl	35814 <k_poll_event_init>
	if (timeout != K_FOREVER) {
   3320e:	1c7a      	adds	r2, r7, #1
   33210:	d002      	beq.n	33218 <z_impl_k_queue_get+0xe0>
   33212:	f006 fcfb 	bl	39c0c <z_impl_k_uptime_get>
   33216:	4683      	mov	fp, r0
{
   33218:	f04f 0900 	mov.w	r9, #0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   3321c:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 332e0 <z_impl_k_queue_get+0x1a8>
   33220:	f8df a0c4 	ldr.w	sl, [pc, #196]	; 332e8 <z_impl_k_queue_get+0x1b0>
		event.state = K_POLL_STATE_NOT_READY;
   33224:	9b06      	ldr	r3, [sp, #24]
   33226:	f36f 3310 	bfc	r3, #12, #5
   3322a:	9306      	str	r3, [sp, #24]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&events, *(uintptr_t *)&num_events, *(uintptr_t *)&timeout, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
   3322c:	2101      	movs	r1, #1
   3322e:	eba7 0209 	sub.w	r2, r7, r9
   33232:	a803      	add	r0, sp, #12
   33234:	f002 fb40 	bl	358b8 <z_impl_k_poll>
		if (err && err != -EAGAIN) {
   33238:	b118      	cbz	r0, 33242 <z_impl_k_queue_get+0x10a>
   3323a:	300b      	adds	r0, #11
   3323c:	d001      	beq.n	33242 <z_impl_k_queue_get+0x10a>
			return NULL;
   3323e:	2500      	movs	r5, #0
   33240:	e7c3      	b.n	331ca <z_impl_k_queue_get+0x92>
	__asm__ volatile(
   33242:	f04f 0320 	mov.w	r3, #32
   33246:	f3ef 8211 	mrs	r2, BASEPRI
   3324a:	f383 8811 	msr	BASEPRI, r3
   3324e:	f3bf 8f6f 	isb	sy
   33252:	4620      	mov	r0, r4
   33254:	9201      	str	r2, [sp, #4]
   33256:	f001 faf7 	bl	34848 <z_spin_lock_valid>
   3325a:	b968      	cbnz	r0, 33278 <z_impl_k_queue_get+0x140>
   3325c:	234a      	movs	r3, #74	; 0x4a
   3325e:	4642      	mov	r2, r8
   33260:	4920      	ldr	r1, [pc, #128]	; (332e4 <z_impl_k_queue_get+0x1ac>)
   33262:	4650      	mov	r0, sl
   33264:	f004 fd2c 	bl	37cc0 <printk>
   33268:	4621      	mov	r1, r4
   3326a:	4820      	ldr	r0, [pc, #128]	; (332ec <z_impl_k_queue_get+0x1b4>)
   3326c:	f004 fd28 	bl	37cc0 <printk>
   33270:	214a      	movs	r1, #74	; 0x4a
   33272:	4640      	mov	r0, r8
   33274:	f004 fd6a 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   33278:	4620      	mov	r0, r4
   3327a:	f001 fb03 	bl	34884 <z_spin_lock_set_owner>
Z_GENLIST_IS_EMPTY(sflist)
   3327e:	6830      	ldr	r0, [r6, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_sfnode_t *sys_sflist_get(sys_sflist_t *list);

Z_GENLIST_GET(sflist, sfnode)
   33280:	b138      	cbz	r0, 33292 <z_impl_k_queue_get+0x15a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   33282:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   33284:	6872      	ldr	r2, [r6, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   33286:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   3328a:	4290      	cmp	r0, r2
	list->head = node;
   3328c:	6033      	str	r3, [r6, #0]
	list->tail = node;
   3328e:	bf08      	it	eq
   33290:	6073      	streq	r3, [r6, #4]
		val = z_queue_node_peek(sys_sflist_get(&queue->data_q), true);
   33292:	2101      	movs	r1, #1
   33294:	f006 fbc9 	bl	39a2a <z_queue_node_peek>
   33298:	4605      	mov	r5, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   3329a:	4620      	mov	r0, r4
   3329c:	f001 fae2 	bl	34864 <z_spin_unlock_valid>
   332a0:	b968      	cbnz	r0, 332be <z_impl_k_queue_get+0x186>
   332a2:	235d      	movs	r3, #93	; 0x5d
   332a4:	4642      	mov	r2, r8
   332a6:	4912      	ldr	r1, [pc, #72]	; (332f0 <z_impl_k_queue_get+0x1b8>)
   332a8:	4650      	mov	r0, sl
   332aa:	f004 fd09 	bl	37cc0 <printk>
   332ae:	4621      	mov	r1, r4
   332b0:	4810      	ldr	r0, [pc, #64]	; (332f4 <z_impl_k_queue_get+0x1bc>)
   332b2:	f004 fd05 	bl	37cc0 <printk>
   332b6:	215d      	movs	r1, #93	; 0x5d
   332b8:	4640      	mov	r0, r8
   332ba:	f004 fd47 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   332be:	9b01      	ldr	r3, [sp, #4]
   332c0:	f383 8811 	msr	BASEPRI, r3
   332c4:	f3bf 8f6f 	isb	sy
		if ((val == NULL) && (timeout != K_FOREVER)) {
   332c8:	2d00      	cmp	r5, #0
   332ca:	f47f af7e 	bne.w	331ca <z_impl_k_queue_get+0x92>
   332ce:	1c7b      	adds	r3, r7, #1
   332d0:	d0a8      	beq.n	33224 <z_impl_k_queue_get+0xec>
	return z_impl_k_uptime_get();
   332d2:	f006 fc9b 	bl	39c0c <z_impl_k_uptime_get>
			elapsed = k_uptime_get_32() - start;
   332d6:	eba0 090b 	sub.w	r9, r0, fp
	} while (!val && !done);
   332da:	454f      	cmp	r7, r9
   332dc:	daa2      	bge.n	33224 <z_impl_k_queue_get+0xec>
   332de:	e7ae      	b.n	3323e <z_impl_k_queue_get+0x106>
   332e0:	0003ba71 	.word	0x0003ba71
   332e4:	0003ba97 	.word	0x0003ba97
   332e8:	0003baac 	.word	0x0003baac
   332ec:	0003bac9 	.word	0x0003bac9
   332f0:	0003bb0b 	.word	0x0003bb0b
   332f4:	0003bb22 	.word	0x0003bb22

000332f8 <pended_on.isra.17>:
	}
}

static _wait_q_t *pended_on(struct k_thread *thread)
{
	__ASSERT_NO_MSG(thread->base.pended_on);
   332f8:	6803      	ldr	r3, [r0, #0]
static _wait_q_t *pended_on(struct k_thread *thread)
   332fa:	b510      	push	{r4, lr}
   332fc:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(thread->base.pended_on);
   332fe:	b95b      	cbnz	r3, 33318 <pended_on.isra.17+0x20>
   33300:	4906      	ldr	r1, [pc, #24]	; (3331c <pended_on.isra.17+0x24>)
   33302:	4807      	ldr	r0, [pc, #28]	; (33320 <pended_on.isra.17+0x28>)
   33304:	f240 139d 	movw	r3, #413	; 0x19d
   33308:	4a06      	ldr	r2, [pc, #24]	; (33324 <pended_on.isra.17+0x2c>)
   3330a:	f004 fcd9 	bl	37cc0 <printk>
   3330e:	f240 119d 	movw	r1, #413	; 0x19d
   33312:	4804      	ldr	r0, [pc, #16]	; (33324 <pended_on.isra.17+0x2c>)
   33314:	f004 fd1a 	bl	37d4c <assert_post_action>

	return thread->base.pended_on;
}
   33318:	6820      	ldr	r0, [r4, #0]
   3331a:	bd10      	pop	{r4, pc}
   3331c:	0003f168 	.word	0x0003f168
   33320:	0003baac 	.word	0x0003baac
   33324:	0003f146 	.word	0x0003f146

00033328 <z_reset_time_slice>:
{
   33328:	b510      	push	{r4, lr}
	if (slice_time != 0) {
   3332a:	4c08      	ldr	r4, [pc, #32]	; (3334c <z_reset_time_slice+0x24>)
   3332c:	6823      	ldr	r3, [r4, #0]
   3332e:	b15b      	cbz	r3, 33348 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   33330:	f7f1 fc52 	bl	24bd8 <z_clock_elapsed>
   33334:	6823      	ldr	r3, [r4, #0]
   33336:	4a06      	ldr	r2, [pc, #24]	; (33350 <z_reset_time_slice+0x28>)
   33338:	4418      	add	r0, r3
   3333a:	6110      	str	r0, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   3333c:	2100      	movs	r1, #0
}
   3333e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_set_timeout_expiry(slice_time, false);
   33342:	4618      	mov	r0, r3
   33344:	f001 beb6 	b.w	350b4 <z_set_timeout_expiry>
}
   33348:	bd10      	pop	{r4, pc}
   3334a:	bf00      	nop
   3334c:	20022148 	.word	0x20022148
   33350:	20022108 	.word	0x20022108

00033354 <k_sched_time_slice_set>:
{
   33354:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   33356:	4607      	mov	r7, r0
   33358:	460d      	mov	r5, r1
	__asm__ volatile(
   3335a:	f04f 0320 	mov.w	r3, #32
   3335e:	f3ef 8411 	mrs	r4, BASEPRI
   33362:	f383 8811 	msr	BASEPRI, r3
   33366:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   3336a:	4820      	ldr	r0, [pc, #128]	; (333ec <k_sched_time_slice_set+0x98>)
   3336c:	f001 fa6c 	bl	34848 <z_spin_lock_valid>
   33370:	b968      	cbnz	r0, 3338e <k_sched_time_slice_set+0x3a>
   33372:	234a      	movs	r3, #74	; 0x4a
   33374:	4a1e      	ldr	r2, [pc, #120]	; (333f0 <k_sched_time_slice_set+0x9c>)
   33376:	491f      	ldr	r1, [pc, #124]	; (333f4 <k_sched_time_slice_set+0xa0>)
   33378:	481f      	ldr	r0, [pc, #124]	; (333f8 <k_sched_time_slice_set+0xa4>)
   3337a:	f004 fca1 	bl	37cc0 <printk>
   3337e:	491b      	ldr	r1, [pc, #108]	; (333ec <k_sched_time_slice_set+0x98>)
   33380:	481e      	ldr	r0, [pc, #120]	; (333fc <k_sched_time_slice_set+0xa8>)
   33382:	f004 fc9d 	bl	37cc0 <printk>
   33386:	214a      	movs	r1, #74	; 0x4a
   33388:	4819      	ldr	r0, [pc, #100]	; (333f0 <k_sched_time_slice_set+0x9c>)
   3338a:	f004 fcdf 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   3338e:	4817      	ldr	r0, [pc, #92]	; (333ec <k_sched_time_slice_set+0x98>)
   33390:	f001 fa78 	bl	34884 <z_spin_lock_set_owner>
			return (u32_t)((t * to_hz + off) / from_hz);
   33394:	f44f 4600 	mov.w	r6, #32768	; 0x8000
		_current_cpu->slice_ticks = 0;
   33398:	2200      	movs	r2, #0
   3339a:	f240 30e7 	movw	r0, #999	; 0x3e7
   3339e:	2100      	movs	r1, #0
   333a0:	4b17      	ldr	r3, [pc, #92]	; (33400 <k_sched_time_slice_set+0xac>)
   333a2:	fbe6 0107 	umlal	r0, r1, r6, r7
   333a6:	611a      	str	r2, [r3, #16]
   333a8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   333ac:	2300      	movs	r3, #0
   333ae:	f7e9 fd0d 	bl	1cdcc <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
   333b2:	4b14      	ldr	r3, [pc, #80]	; (33404 <k_sched_time_slice_set+0xb0>)
   333b4:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
   333b6:	4b14      	ldr	r3, [pc, #80]	; (33408 <k_sched_time_slice_set+0xb4>)
   333b8:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
   333ba:	f7ff ffb5 	bl	33328 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   333be:	480b      	ldr	r0, [pc, #44]	; (333ec <k_sched_time_slice_set+0x98>)
   333c0:	f001 fa50 	bl	34864 <z_spin_unlock_valid>
   333c4:	b968      	cbnz	r0, 333e2 <k_sched_time_slice_set+0x8e>
   333c6:	235d      	movs	r3, #93	; 0x5d
   333c8:	4a09      	ldr	r2, [pc, #36]	; (333f0 <k_sched_time_slice_set+0x9c>)
   333ca:	4910      	ldr	r1, [pc, #64]	; (3340c <k_sched_time_slice_set+0xb8>)
   333cc:	480a      	ldr	r0, [pc, #40]	; (333f8 <k_sched_time_slice_set+0xa4>)
   333ce:	f004 fc77 	bl	37cc0 <printk>
   333d2:	4906      	ldr	r1, [pc, #24]	; (333ec <k_sched_time_slice_set+0x98>)
   333d4:	480e      	ldr	r0, [pc, #56]	; (33410 <k_sched_time_slice_set+0xbc>)
   333d6:	f004 fc73 	bl	37cc0 <printk>
   333da:	215d      	movs	r1, #93	; 0x5d
   333dc:	4804      	ldr	r0, [pc, #16]	; (333f0 <k_sched_time_slice_set+0x9c>)
   333de:	f004 fcb5 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   333e2:	f384 8811 	msr	BASEPRI, r4
   333e6:	f3bf 8f6f 	isb	sy
}
   333ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   333ec:	20022140 	.word	0x20022140
   333f0:	0003ba71 	.word	0x0003ba71
   333f4:	0003ba97 	.word	0x0003ba97
   333f8:	0003baac 	.word	0x0003baac
   333fc:	0003bac9 	.word	0x0003bac9
   33400:	20022108 	.word	0x20022108
   33404:	20022148 	.word	0x20022148
   33408:	20022144 	.word	0x20022144
   3340c:	0003bb0b 	.word	0x0003bb0b
   33410:	0003bb22 	.word	0x0003bb22

00033414 <z_find_first_thread_to_unpend>:
	pend(thread, wait_q, timeout);
}

ALWAYS_INLINE struct k_thread *z_find_first_thread_to_unpend(_wait_q_t *wait_q,
						     struct k_thread *from)
{
   33414:	b538      	push	{r3, r4, r5, lr}
   33416:	4604      	mov	r4, r0
	__asm__ volatile(
   33418:	f04f 0320 	mov.w	r3, #32
   3341c:	f3ef 8511 	mrs	r5, BASEPRI
   33420:	f383 8811 	msr	BASEPRI, r3
   33424:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   33428:	4818      	ldr	r0, [pc, #96]	; (3348c <z_find_first_thread_to_unpend+0x78>)
   3342a:	f001 fa0d 	bl	34848 <z_spin_lock_valid>
   3342e:	b968      	cbnz	r0, 3344c <z_find_first_thread_to_unpend+0x38>
   33430:	234a      	movs	r3, #74	; 0x4a
   33432:	4a17      	ldr	r2, [pc, #92]	; (33490 <z_find_first_thread_to_unpend+0x7c>)
   33434:	4917      	ldr	r1, [pc, #92]	; (33494 <z_find_first_thread_to_unpend+0x80>)
   33436:	4818      	ldr	r0, [pc, #96]	; (33498 <z_find_first_thread_to_unpend+0x84>)
   33438:	f004 fc42 	bl	37cc0 <printk>
   3343c:	4913      	ldr	r1, [pc, #76]	; (3348c <z_find_first_thread_to_unpend+0x78>)
   3343e:	4817      	ldr	r0, [pc, #92]	; (3349c <z_find_first_thread_to_unpend+0x88>)
   33440:	f004 fc3e 	bl	37cc0 <printk>
   33444:	214a      	movs	r1, #74	; 0x4a
   33446:	4812      	ldr	r0, [pc, #72]	; (33490 <z_find_first_thread_to_unpend+0x7c>)
   33448:	f004 fc80 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   3344c:	480f      	ldr	r0, [pc, #60]	; (3348c <z_find_first_thread_to_unpend+0x78>)
   3344e:	f001 fa19 	bl	34884 <z_spin_lock_set_owner>
	ARG_UNUSED(from);

	struct k_thread *ret = NULL;

	LOCKED(&sched_spinlock) {
		ret = _priq_wait_best(&wait_q->waitq);
   33452:	4620      	mov	r0, r4
   33454:	f006 fb2b 	bl	39aae <z_priq_dumb_best>
   33458:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   3345a:	480c      	ldr	r0, [pc, #48]	; (3348c <z_find_first_thread_to_unpend+0x78>)
   3345c:	f001 fa02 	bl	34864 <z_spin_unlock_valid>
   33460:	b968      	cbnz	r0, 3347e <z_find_first_thread_to_unpend+0x6a>
   33462:	235d      	movs	r3, #93	; 0x5d
   33464:	4a0a      	ldr	r2, [pc, #40]	; (33490 <z_find_first_thread_to_unpend+0x7c>)
   33466:	490e      	ldr	r1, [pc, #56]	; (334a0 <z_find_first_thread_to_unpend+0x8c>)
   33468:	480b      	ldr	r0, [pc, #44]	; (33498 <z_find_first_thread_to_unpend+0x84>)
   3346a:	f004 fc29 	bl	37cc0 <printk>
   3346e:	4907      	ldr	r1, [pc, #28]	; (3348c <z_find_first_thread_to_unpend+0x78>)
   33470:	480c      	ldr	r0, [pc, #48]	; (334a4 <z_find_first_thread_to_unpend+0x90>)
   33472:	f004 fc25 	bl	37cc0 <printk>
   33476:	215d      	movs	r1, #93	; 0x5d
   33478:	4805      	ldr	r0, [pc, #20]	; (33490 <z_find_first_thread_to_unpend+0x7c>)
   3347a:	f004 fc67 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   3347e:	f385 8811 	msr	BASEPRI, r5
   33482:	f3bf 8f6f 	isb	sy
	}

	return ret;
}
   33486:	4620      	mov	r0, r4
   33488:	bd38      	pop	{r3, r4, r5, pc}
   3348a:	bf00      	nop
   3348c:	20022140 	.word	0x20022140
   33490:	0003ba71 	.word	0x0003ba71
   33494:	0003ba97 	.word	0x0003ba97
   33498:	0003baac 	.word	0x0003baac
   3349c:	0003bac9 	.word	0x0003bac9
   334a0:	0003bb0b 	.word	0x0003bb0b
   334a4:	0003bb22 	.word	0x0003bb22

000334a8 <z_unpend_thread_no_timeout>:

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
   334a8:	b538      	push	{r3, r4, r5, lr}
   334aa:	4604      	mov	r4, r0
	__asm__ volatile(
   334ac:	f04f 0320 	mov.w	r3, #32
   334b0:	f3ef 8511 	mrs	r5, BASEPRI
   334b4:	f383 8811 	msr	BASEPRI, r3
   334b8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   334bc:	481c      	ldr	r0, [pc, #112]	; (33530 <z_unpend_thread_no_timeout+0x88>)
   334be:	f001 f9c3 	bl	34848 <z_spin_lock_valid>
   334c2:	b968      	cbnz	r0, 334e0 <z_unpend_thread_no_timeout+0x38>
   334c4:	234a      	movs	r3, #74	; 0x4a
   334c6:	4a1b      	ldr	r2, [pc, #108]	; (33534 <z_unpend_thread_no_timeout+0x8c>)
   334c8:	491b      	ldr	r1, [pc, #108]	; (33538 <z_unpend_thread_no_timeout+0x90>)
   334ca:	481c      	ldr	r0, [pc, #112]	; (3353c <z_unpend_thread_no_timeout+0x94>)
   334cc:	f004 fbf8 	bl	37cc0 <printk>
   334d0:	4917      	ldr	r1, [pc, #92]	; (33530 <z_unpend_thread_no_timeout+0x88>)
   334d2:	481b      	ldr	r0, [pc, #108]	; (33540 <z_unpend_thread_no_timeout+0x98>)
   334d4:	f004 fbf4 	bl	37cc0 <printk>
   334d8:	214a      	movs	r1, #74	; 0x4a
   334da:	4816      	ldr	r0, [pc, #88]	; (33534 <z_unpend_thread_no_timeout+0x8c>)
   334dc:	f004 fc36 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   334e0:	4813      	ldr	r0, [pc, #76]	; (33530 <z_unpend_thread_no_timeout+0x88>)
   334e2:	f001 f9cf 	bl	34884 <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   334e6:	f104 0008 	add.w	r0, r4, #8
   334ea:	f7ff ff05 	bl	332f8 <pended_on.isra.17>
   334ee:	4621      	mov	r1, r4
   334f0:	f000 f8e0 	bl	336b4 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   334f4:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   334f6:	480e      	ldr	r0, [pc, #56]	; (33530 <z_unpend_thread_no_timeout+0x88>)
   334f8:	f023 0302 	bic.w	r3, r3, #2
   334fc:	7363      	strb	r3, [r4, #13]
   334fe:	f001 f9b1 	bl	34864 <z_spin_unlock_valid>
   33502:	b968      	cbnz	r0, 33520 <z_unpend_thread_no_timeout+0x78>
   33504:	235d      	movs	r3, #93	; 0x5d
   33506:	4a0b      	ldr	r2, [pc, #44]	; (33534 <z_unpend_thread_no_timeout+0x8c>)
   33508:	490e      	ldr	r1, [pc, #56]	; (33544 <z_unpend_thread_no_timeout+0x9c>)
   3350a:	480c      	ldr	r0, [pc, #48]	; (3353c <z_unpend_thread_no_timeout+0x94>)
   3350c:	f004 fbd8 	bl	37cc0 <printk>
   33510:	4907      	ldr	r1, [pc, #28]	; (33530 <z_unpend_thread_no_timeout+0x88>)
   33512:	480d      	ldr	r0, [pc, #52]	; (33548 <z_unpend_thread_no_timeout+0xa0>)
   33514:	f004 fbd4 	bl	37cc0 <printk>
   33518:	215d      	movs	r1, #93	; 0x5d
   3351a:	4806      	ldr	r0, [pc, #24]	; (33534 <z_unpend_thread_no_timeout+0x8c>)
   3351c:	f004 fc16 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   33520:	f385 8811 	msr	BASEPRI, r5
   33524:	f3bf 8f6f 	isb	sy
		z_mark_thread_as_not_pending(thread);
	}

	thread->base.pended_on = NULL;
   33528:	2300      	movs	r3, #0
   3352a:	60a3      	str	r3, [r4, #8]
}
   3352c:	bd38      	pop	{r3, r4, r5, pc}
   3352e:	bf00      	nop
   33530:	20022140 	.word	0x20022140
   33534:	0003ba71 	.word	0x0003ba71
   33538:	0003ba97 	.word	0x0003ba97
   3353c:	0003baac 	.word	0x0003baac
   33540:	0003bac9 	.word	0x0003bac9
   33544:	0003bb0b 	.word	0x0003bb0b
   33548:	0003bb22 	.word	0x0003bb22

0003354c <z_reschedule>:

	return arch_irq_unlocked(key) && !arch_is_in_isr();
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
   3354c:	b538      	push	{r3, r4, r5, lr}
   3354e:	4604      	mov	r4, r0
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   33550:	460d      	mov	r5, r1
   33552:	b9c1      	cbnz	r1, 33586 <z_reschedule+0x3a>
   33554:	f3ef 8305 	mrs	r3, IPSR
   33558:	b9ab      	cbnz	r3, 33586 <z_reschedule+0x3a>
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   3355a:	f001 f983 	bl	34864 <z_spin_unlock_valid>
   3355e:	b968      	cbnz	r0, 3357c <z_reschedule+0x30>
   33560:	2374      	movs	r3, #116	; 0x74
   33562:	4a14      	ldr	r2, [pc, #80]	; (335b4 <z_reschedule+0x68>)
   33564:	4914      	ldr	r1, [pc, #80]	; (335b8 <z_reschedule+0x6c>)
   33566:	4815      	ldr	r0, [pc, #84]	; (335bc <z_reschedule+0x70>)
   33568:	f004 fbaa 	bl	37cc0 <printk>
   3356c:	4621      	mov	r1, r4
   3356e:	4814      	ldr	r0, [pc, #80]	; (335c0 <z_reschedule+0x74>)
   33570:	f004 fba6 	bl	37cc0 <printk>
   33574:	2174      	movs	r1, #116	; 0x74
   33576:	480f      	ldr	r0, [pc, #60]	; (335b4 <z_reschedule+0x68>)
   33578:	f004 fbe8 	bl	37d4c <assert_post_action>
	if (resched(key.key)) {
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
   3357c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   33580:	2000      	movs	r0, #0
   33582:	f7f1 bd0b 	b.w	24f9c <arch_swap>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   33586:	4620      	mov	r0, r4
   33588:	f001 f96c 	bl	34864 <z_spin_unlock_valid>
   3358c:	b968      	cbnz	r0, 335aa <z_reschedule+0x5e>
   3358e:	235d      	movs	r3, #93	; 0x5d
   33590:	4a08      	ldr	r2, [pc, #32]	; (335b4 <z_reschedule+0x68>)
   33592:	4909      	ldr	r1, [pc, #36]	; (335b8 <z_reschedule+0x6c>)
   33594:	4809      	ldr	r0, [pc, #36]	; (335bc <z_reschedule+0x70>)
   33596:	f004 fb93 	bl	37cc0 <printk>
   3359a:	4621      	mov	r1, r4
   3359c:	4808      	ldr	r0, [pc, #32]	; (335c0 <z_reschedule+0x74>)
   3359e:	f004 fb8f 	bl	37cc0 <printk>
   335a2:	215d      	movs	r1, #93	; 0x5d
   335a4:	4803      	ldr	r0, [pc, #12]	; (335b4 <z_reschedule+0x68>)
   335a6:	f004 fbd1 	bl	37d4c <assert_post_action>
   335aa:	f385 8811 	msr	BASEPRI, r5
   335ae:	f3bf 8f6f 	isb	sy
   335b2:	bd38      	pop	{r3, r4, r5, pc}
   335b4:	0003ba71 	.word	0x0003ba71
   335b8:	0003bb0b 	.word	0x0003bb0b
   335bc:	0003baac 	.word	0x0003baac
   335c0:	0003bb22 	.word	0x0003bb22

000335c4 <k_sched_lock>:
		irq_unlock(key);
	}
}

void k_sched_lock(void)
{
   335c4:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   335c6:	f04f 0320 	mov.w	r3, #32
   335ca:	f3ef 8511 	mrs	r5, BASEPRI
   335ce:	f383 8811 	msr	BASEPRI, r3
   335d2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   335d6:	482b      	ldr	r0, [pc, #172]	; (33684 <k_sched_lock+0xc0>)
   335d8:	f001 f936 	bl	34848 <z_spin_lock_valid>
   335dc:	b968      	cbnz	r0, 335fa <k_sched_lock+0x36>
   335de:	234a      	movs	r3, #74	; 0x4a
   335e0:	4a29      	ldr	r2, [pc, #164]	; (33688 <k_sched_lock+0xc4>)
   335e2:	492a      	ldr	r1, [pc, #168]	; (3368c <k_sched_lock+0xc8>)
   335e4:	482a      	ldr	r0, [pc, #168]	; (33690 <k_sched_lock+0xcc>)
   335e6:	f004 fb6b 	bl	37cc0 <printk>
   335ea:	4926      	ldr	r1, [pc, #152]	; (33684 <k_sched_lock+0xc0>)
   335ec:	4829      	ldr	r0, [pc, #164]	; (33694 <k_sched_lock+0xd0>)
   335ee:	f004 fb67 	bl	37cc0 <printk>
   335f2:	214a      	movs	r1, #74	; 0x4a
   335f4:	4824      	ldr	r0, [pc, #144]	; (33688 <k_sched_lock+0xc4>)
   335f6:	f004 fba9 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   335fa:	4822      	ldr	r0, [pc, #136]	; (33684 <k_sched_lock+0xc0>)
   335fc:	f001 f942 	bl	34884 <z_spin_lock_set_owner>
   33600:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   33604:	b173      	cbz	r3, 33624 <k_sched_lock+0x60>
   33606:	4924      	ldr	r1, [pc, #144]	; (33698 <k_sched_lock+0xd4>)
   33608:	f240 130d 	movw	r3, #269	; 0x10d
   3360c:	4a23      	ldr	r2, [pc, #140]	; (3369c <k_sched_lock+0xd8>)
   3360e:	4820      	ldr	r0, [pc, #128]	; (33690 <k_sched_lock+0xcc>)
   33610:	f004 fb56 	bl	37cc0 <printk>
   33614:	4822      	ldr	r0, [pc, #136]	; (336a0 <k_sched_lock+0xdc>)
   33616:	f004 fb53 	bl	37cc0 <printk>
   3361a:	f240 110d 	movw	r1, #269	; 0x10d
   3361e:	481f      	ldr	r0, [pc, #124]	; (3369c <k_sched_lock+0xd8>)
   33620:	f004 fb94 	bl	37d4c <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1, "");
   33624:	4c1f      	ldr	r4, [pc, #124]	; (336a4 <k_sched_lock+0xe0>)
   33626:	68a2      	ldr	r2, [r4, #8]
   33628:	7bd2      	ldrb	r2, [r2, #15]
   3362a:	2a01      	cmp	r2, #1
   3362c:	d10e      	bne.n	3364c <k_sched_lock+0x88>
   3362e:	491e      	ldr	r1, [pc, #120]	; (336a8 <k_sched_lock+0xe4>)
   33630:	f44f 7387 	mov.w	r3, #270	; 0x10e
   33634:	4a19      	ldr	r2, [pc, #100]	; (3369c <k_sched_lock+0xd8>)
   33636:	4816      	ldr	r0, [pc, #88]	; (33690 <k_sched_lock+0xcc>)
   33638:	f004 fb42 	bl	37cc0 <printk>
   3363c:	4818      	ldr	r0, [pc, #96]	; (336a0 <k_sched_lock+0xdc>)
   3363e:	f004 fb3f 	bl	37cc0 <printk>
   33642:	f44f 7187 	mov.w	r1, #270	; 0x10e
   33646:	4815      	ldr	r0, [pc, #84]	; (3369c <k_sched_lock+0xd8>)
   33648:	f004 fb80 	bl	37d4c <assert_post_action>
	--_current->base.sched_locked;
   3364c:	68a2      	ldr	r2, [r4, #8]
   3364e:	7bd3      	ldrb	r3, [r2, #15]
   33650:	3b01      	subs	r3, #1
   33652:	73d3      	strb	r3, [r2, #15]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   33654:	480b      	ldr	r0, [pc, #44]	; (33684 <k_sched_lock+0xc0>)
   33656:	f001 f905 	bl	34864 <z_spin_unlock_valid>
   3365a:	b968      	cbnz	r0, 33678 <k_sched_lock+0xb4>
   3365c:	235d      	movs	r3, #93	; 0x5d
   3365e:	4a0a      	ldr	r2, [pc, #40]	; (33688 <k_sched_lock+0xc4>)
   33660:	4912      	ldr	r1, [pc, #72]	; (336ac <k_sched_lock+0xe8>)
   33662:	480b      	ldr	r0, [pc, #44]	; (33690 <k_sched_lock+0xcc>)
   33664:	f004 fb2c 	bl	37cc0 <printk>
   33668:	4906      	ldr	r1, [pc, #24]	; (33684 <k_sched_lock+0xc0>)
   3366a:	4811      	ldr	r0, [pc, #68]	; (336b0 <k_sched_lock+0xec>)
   3366c:	f004 fb28 	bl	37cc0 <printk>
   33670:	215d      	movs	r1, #93	; 0x5d
   33672:	4805      	ldr	r0, [pc, #20]	; (33688 <k_sched_lock+0xc4>)
   33674:	f004 fb6a 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   33678:	f385 8811 	msr	BASEPRI, r5
   3367c:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
   33680:	bd38      	pop	{r3, r4, r5, pc}
   33682:	bf00      	nop
   33684:	20022140 	.word	0x20022140
   33688:	0003ba71 	.word	0x0003ba71
   3368c:	0003ba97 	.word	0x0003ba97
   33690:	0003baac 	.word	0x0003baac
   33694:	0003bac9 	.word	0x0003bac9
   33698:	0003f0ae 	.word	0x0003f0ae
   3369c:	0003f083 	.word	0x0003f083
   336a0:	0003da1b 	.word	0x0003da1b
   336a4:	20022108 	.word	0x20022108
   336a8:	0003f0c0 	.word	0x0003f0c0
   336ac:	0003bb0b 	.word	0x0003bb0b
   336b0:	0003bb22 	.word	0x0003bb22

000336b4 <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   336b4:	4b11      	ldr	r3, [pc, #68]	; (336fc <z_priq_dumb_remove+0x48>)
{
   336b6:	b510      	push	{r4, lr}
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   336b8:	f103 0228 	add.w	r2, r3, #40	; 0x28
   336bc:	4282      	cmp	r2, r0
{
   336be:	460c      	mov	r4, r1
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   336c0:	d105      	bne.n	336ce <z_priq_dumb_remove+0x1a>
   336c2:	689b      	ldr	r3, [r3, #8]
   336c4:	428b      	cmp	r3, r1
   336c6:	d102      	bne.n	336ce <z_priq_dumb_remove+0x1a>
   336c8:	7b4b      	ldrb	r3, [r1, #13]
   336ca:	06db      	lsls	r3, r3, #27
   336cc:	d115      	bne.n	336fa <z_priq_dumb_remove+0x46>
	    z_is_thread_prevented_from_running(thread)) {
		return;
	}
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   336ce:	4b0c      	ldr	r3, [pc, #48]	; (33700 <z_priq_dumb_remove+0x4c>)
   336d0:	429c      	cmp	r4, r3
   336d2:	d10b      	bne.n	336ec <z_priq_dumb_remove+0x38>
   336d4:	490b      	ldr	r1, [pc, #44]	; (33704 <z_priq_dumb_remove+0x50>)
   336d6:	480c      	ldr	r0, [pc, #48]	; (33708 <z_priq_dumb_remove+0x54>)
   336d8:	f44f 7346 	mov.w	r3, #792	; 0x318
   336dc:	4a0b      	ldr	r2, [pc, #44]	; (3370c <z_priq_dumb_remove+0x58>)
   336de:	f004 faef 	bl	37cc0 <printk>
   336e2:	f44f 7146 	mov.w	r1, #792	; 0x318
   336e6:	4809      	ldr	r0, [pc, #36]	; (3370c <z_priq_dumb_remove+0x58>)
   336e8:	f004 fb30 	bl	37d4c <assert_post_action>
	node->prev->next = node->next;
   336ec:	e9d4 3200 	ldrd	r3, r2, [r4]
   336f0:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   336f2:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   336f4:	2300      	movs	r3, #0
	node->prev = NULL;
   336f6:	e9c4 3300 	strd	r3, r3, [r4]

	sys_dlist_remove(&thread->base.qnode_dlist);
}
   336fa:	bd10      	pop	{r4, pc}
   336fc:	20022108 	.word	0x20022108
   33700:	20020f64 	.word	0x20020f64
   33704:	0003f19e 	.word	0x0003f19e
   33708:	0003baac 	.word	0x0003baac
   3370c:	0003f146 	.word	0x0003f146

00033710 <z_unpend_thread>:
{
   33710:	b538      	push	{r3, r4, r5, lr}
   33712:	4604      	mov	r4, r0
	__asm__ volatile(
   33714:	f04f 0320 	mov.w	r3, #32
   33718:	f3ef 8511 	mrs	r5, BASEPRI
   3371c:	f383 8811 	msr	BASEPRI, r3
   33720:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   33724:	481e      	ldr	r0, [pc, #120]	; (337a0 <z_unpend_thread+0x90>)
   33726:	f001 f88f 	bl	34848 <z_spin_lock_valid>
   3372a:	b968      	cbnz	r0, 33748 <z_unpend_thread+0x38>
   3372c:	234a      	movs	r3, #74	; 0x4a
   3372e:	4a1d      	ldr	r2, [pc, #116]	; (337a4 <z_unpend_thread+0x94>)
   33730:	491d      	ldr	r1, [pc, #116]	; (337a8 <z_unpend_thread+0x98>)
   33732:	481e      	ldr	r0, [pc, #120]	; (337ac <z_unpend_thread+0x9c>)
   33734:	f004 fac4 	bl	37cc0 <printk>
   33738:	4919      	ldr	r1, [pc, #100]	; (337a0 <z_unpend_thread+0x90>)
   3373a:	481d      	ldr	r0, [pc, #116]	; (337b0 <z_unpend_thread+0xa0>)
   3373c:	f004 fac0 	bl	37cc0 <printk>
   33740:	214a      	movs	r1, #74	; 0x4a
   33742:	4818      	ldr	r0, [pc, #96]	; (337a4 <z_unpend_thread+0x94>)
   33744:	f004 fb02 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   33748:	4815      	ldr	r0, [pc, #84]	; (337a0 <z_unpend_thread+0x90>)
   3374a:	f001 f89b 	bl	34884 <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   3374e:	f104 0008 	add.w	r0, r4, #8
   33752:	f7ff fdd1 	bl	332f8 <pended_on.isra.17>
   33756:	4621      	mov	r1, r4
   33758:	f7ff ffac 	bl	336b4 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   3375c:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   3375e:	4810      	ldr	r0, [pc, #64]	; (337a0 <z_unpend_thread+0x90>)
   33760:	f023 0302 	bic.w	r3, r3, #2
   33764:	7363      	strb	r3, [r4, #13]
   33766:	f001 f87d 	bl	34864 <z_spin_unlock_valid>
   3376a:	b968      	cbnz	r0, 33788 <z_unpend_thread+0x78>
   3376c:	235d      	movs	r3, #93	; 0x5d
   3376e:	4a0d      	ldr	r2, [pc, #52]	; (337a4 <z_unpend_thread+0x94>)
   33770:	4910      	ldr	r1, [pc, #64]	; (337b4 <z_unpend_thread+0xa4>)
   33772:	480e      	ldr	r0, [pc, #56]	; (337ac <z_unpend_thread+0x9c>)
   33774:	f004 faa4 	bl	37cc0 <printk>
   33778:	4909      	ldr	r1, [pc, #36]	; (337a0 <z_unpend_thread+0x90>)
   3377a:	480f      	ldr	r0, [pc, #60]	; (337b8 <z_unpend_thread+0xa8>)
   3377c:	f004 faa0 	bl	37cc0 <printk>
   33780:	215d      	movs	r1, #93	; 0x5d
   33782:	4808      	ldr	r0, [pc, #32]	; (337a4 <z_unpend_thread+0x94>)
   33784:	f004 fae2 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   33788:	f385 8811 	msr	BASEPRI, r5
   3378c:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   33790:	2300      	movs	r3, #0
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   33792:	f104 0018 	add.w	r0, r4, #24
   33796:	60a3      	str	r3, [r4, #8]
}
   33798:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   3379c:	f001 bb94 	b.w	34ec8 <z_abort_timeout>
   337a0:	20022140 	.word	0x20022140
   337a4:	0003ba71 	.word	0x0003ba71
   337a8:	0003ba97 	.word	0x0003ba97
   337ac:	0003baac 	.word	0x0003baac
   337b0:	0003bac9 	.word	0x0003bac9
   337b4:	0003bb0b 	.word	0x0003bb0b
   337b8:	0003bb22 	.word	0x0003bb22

000337bc <update_cache>:
{
   337bc:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   337be:	4c15      	ldr	r4, [pc, #84]	; (33814 <update_cache+0x58>)
{
   337c0:	4602      	mov	r2, r0
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   337c2:	f104 0028 	add.w	r0, r4, #40	; 0x28
   337c6:	f006 f972 	bl	39aae <z_priq_dumb_best>
	return thread ? thread : _current_cpu->idle_thread;
   337ca:	4605      	mov	r5, r0
   337cc:	b900      	cbnz	r0, 337d0 <update_cache+0x14>
   337ce:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
   337d0:	b9ca      	cbnz	r2, 33806 <update_cache+0x4a>
	__ASSERT(_current != NULL, "");
   337d2:	68a3      	ldr	r3, [r4, #8]
   337d4:	b963      	cbnz	r3, 337f0 <update_cache+0x34>
   337d6:	4910      	ldr	r1, [pc, #64]	; (33818 <update_cache+0x5c>)
   337d8:	237e      	movs	r3, #126	; 0x7e
   337da:	4a10      	ldr	r2, [pc, #64]	; (3381c <update_cache+0x60>)
   337dc:	4810      	ldr	r0, [pc, #64]	; (33820 <update_cache+0x64>)
   337de:	f004 fa6f 	bl	37cc0 <printk>
   337e2:	4810      	ldr	r0, [pc, #64]	; (33824 <update_cache+0x68>)
   337e4:	f004 fa6c 	bl	37cc0 <printk>
   337e8:	217e      	movs	r1, #126	; 0x7e
   337ea:	480c      	ldr	r0, [pc, #48]	; (3381c <update_cache+0x60>)
   337ec:	f004 faae 	bl	37d4c <assert_post_action>
	if (z_is_thread_prevented_from_running(_current)) {
   337f0:	68a3      	ldr	r3, [r4, #8]
   337f2:	7b5a      	ldrb	r2, [r3, #13]
   337f4:	06d2      	lsls	r2, r2, #27
   337f6:	d106      	bne.n	33806 <update_cache+0x4a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   337f8:	69aa      	ldr	r2, [r5, #24]
   337fa:	b922      	cbnz	r2, 33806 <update_cache+0x4a>
	if (is_preempt(_current) || is_metairq(thread)) {
   337fc:	89da      	ldrh	r2, [r3, #14]
   337fe:	2a7f      	cmp	r2, #127	; 0x7f
   33800:	d901      	bls.n	33806 <update_cache+0x4a>
		_kernel.ready_q.cache = _current;
   33802:	6263      	str	r3, [r4, #36]	; 0x24
}
   33804:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
   33806:	68a3      	ldr	r3, [r4, #8]
   33808:	42ab      	cmp	r3, r5
   3380a:	d001      	beq.n	33810 <update_cache+0x54>
			z_reset_time_slice();
   3380c:	f7ff fd8c 	bl	33328 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   33810:	6265      	str	r5, [r4, #36]	; 0x24
}
   33812:	e7f7      	b.n	33804 <update_cache+0x48>
   33814:	20022108 	.word	0x20022108
   33818:	0003f17f 	.word	0x0003f17f
   3381c:	0003f146 	.word	0x0003f146
   33820:	0003baac 	.word	0x0003baac
   33824:	0003da1b 	.word	0x0003da1b

00033828 <k_sched_unlock>:
{
   33828:	b538      	push	{r3, r4, r5, lr}
	__ASSERT(_current->base.sched_locked != 0, "");
   3382a:	4c31      	ldr	r4, [pc, #196]	; (338f0 <k_sched_unlock+0xc8>)
   3382c:	68a2      	ldr	r2, [r4, #8]
   3382e:	7bd2      	ldrb	r2, [r2, #15]
   33830:	b972      	cbnz	r2, 33850 <k_sched_unlock+0x28>
   33832:	4930      	ldr	r1, [pc, #192]	; (338f4 <k_sched_unlock+0xcc>)
   33834:	f240 23ad 	movw	r3, #685	; 0x2ad
   33838:	4a2f      	ldr	r2, [pc, #188]	; (338f8 <k_sched_unlock+0xd0>)
   3383a:	4830      	ldr	r0, [pc, #192]	; (338fc <k_sched_unlock+0xd4>)
   3383c:	f004 fa40 	bl	37cc0 <printk>
   33840:	482f      	ldr	r0, [pc, #188]	; (33900 <k_sched_unlock+0xd8>)
   33842:	f004 fa3d 	bl	37cc0 <printk>
   33846:	f240 21ad 	movw	r1, #685	; 0x2ad
   3384a:	482b      	ldr	r0, [pc, #172]	; (338f8 <k_sched_unlock+0xd0>)
   3384c:	f004 fa7e 	bl	37d4c <assert_post_action>
   33850:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   33854:	b173      	cbz	r3, 33874 <k_sched_unlock+0x4c>
   33856:	492b      	ldr	r1, [pc, #172]	; (33904 <k_sched_unlock+0xdc>)
   33858:	f240 23ae 	movw	r3, #686	; 0x2ae
   3385c:	4a26      	ldr	r2, [pc, #152]	; (338f8 <k_sched_unlock+0xd0>)
   3385e:	4827      	ldr	r0, [pc, #156]	; (338fc <k_sched_unlock+0xd4>)
   33860:	f004 fa2e 	bl	37cc0 <printk>
   33864:	4826      	ldr	r0, [pc, #152]	; (33900 <k_sched_unlock+0xd8>)
   33866:	f004 fa2b 	bl	37cc0 <printk>
   3386a:	f240 21ae 	movw	r1, #686	; 0x2ae
   3386e:	4822      	ldr	r0, [pc, #136]	; (338f8 <k_sched_unlock+0xd0>)
   33870:	f004 fa6c 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   33874:	f04f 0320 	mov.w	r3, #32
   33878:	f3ef 8511 	mrs	r5, BASEPRI
   3387c:	f383 8811 	msr	BASEPRI, r3
   33880:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   33884:	4820      	ldr	r0, [pc, #128]	; (33908 <k_sched_unlock+0xe0>)
   33886:	f000 ffdf 	bl	34848 <z_spin_lock_valid>
   3388a:	b968      	cbnz	r0, 338a8 <k_sched_unlock+0x80>
   3388c:	234a      	movs	r3, #74	; 0x4a
   3388e:	4a1f      	ldr	r2, [pc, #124]	; (3390c <k_sched_unlock+0xe4>)
   33890:	491f      	ldr	r1, [pc, #124]	; (33910 <k_sched_unlock+0xe8>)
   33892:	481a      	ldr	r0, [pc, #104]	; (338fc <k_sched_unlock+0xd4>)
   33894:	f004 fa14 	bl	37cc0 <printk>
   33898:	491b      	ldr	r1, [pc, #108]	; (33908 <k_sched_unlock+0xe0>)
   3389a:	481e      	ldr	r0, [pc, #120]	; (33914 <k_sched_unlock+0xec>)
   3389c:	f004 fa10 	bl	37cc0 <printk>
   338a0:	214a      	movs	r1, #74	; 0x4a
   338a2:	481a      	ldr	r0, [pc, #104]	; (3390c <k_sched_unlock+0xe4>)
   338a4:	f004 fa52 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   338a8:	4817      	ldr	r0, [pc, #92]	; (33908 <k_sched_unlock+0xe0>)
   338aa:	f000 ffeb 	bl	34884 <z_spin_lock_set_owner>
		++_current->base.sched_locked;
   338ae:	68a2      	ldr	r2, [r4, #8]
		update_cache(0);
   338b0:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   338b2:	7bd3      	ldrb	r3, [r2, #15]
   338b4:	3301      	adds	r3, #1
   338b6:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   338b8:	f7ff ff80 	bl	337bc <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   338bc:	4812      	ldr	r0, [pc, #72]	; (33908 <k_sched_unlock+0xe0>)
   338be:	f000 ffd1 	bl	34864 <z_spin_unlock_valid>
   338c2:	b968      	cbnz	r0, 338e0 <k_sched_unlock+0xb8>
   338c4:	235d      	movs	r3, #93	; 0x5d
   338c6:	4a11      	ldr	r2, [pc, #68]	; (3390c <k_sched_unlock+0xe4>)
   338c8:	4913      	ldr	r1, [pc, #76]	; (33918 <k_sched_unlock+0xf0>)
   338ca:	480c      	ldr	r0, [pc, #48]	; (338fc <k_sched_unlock+0xd4>)
   338cc:	f004 f9f8 	bl	37cc0 <printk>
   338d0:	490d      	ldr	r1, [pc, #52]	; (33908 <k_sched_unlock+0xe0>)
   338d2:	4812      	ldr	r0, [pc, #72]	; (3391c <k_sched_unlock+0xf4>)
   338d4:	f004 f9f4 	bl	37cc0 <printk>
   338d8:	215d      	movs	r1, #93	; 0x5d
   338da:	480c      	ldr	r0, [pc, #48]	; (3390c <k_sched_unlock+0xe4>)
   338dc:	f004 fa36 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   338e0:	f385 8811 	msr	BASEPRI, r5
   338e4:	f3bf 8f6f 	isb	sy
}
   338e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_unlocked();
   338ec:	f006 b8d5 	b.w	39a9a <z_reschedule_unlocked>
   338f0:	20022108 	.word	0x20022108
   338f4:	0003f0e8 	.word	0x0003f0e8
   338f8:	0003f146 	.word	0x0003f146
   338fc:	0003baac 	.word	0x0003baac
   33900:	0003da1b 	.word	0x0003da1b
   33904:	0003f0ae 	.word	0x0003f0ae
   33908:	20022140 	.word	0x20022140
   3390c:	0003ba71 	.word	0x0003ba71
   33910:	0003ba97 	.word	0x0003ba97
   33914:	0003bac9 	.word	0x0003bac9
   33918:	0003bb0b 	.word	0x0003bb0b
   3391c:	0003bb22 	.word	0x0003bb22

00033920 <z_add_thread_to_ready_q>:
{
   33920:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   33922:	4604      	mov	r4, r0
	__asm__ volatile(
   33924:	f04f 0320 	mov.w	r3, #32
   33928:	f3ef 8511 	mrs	r5, BASEPRI
   3392c:	f383 8811 	msr	BASEPRI, r3
   33930:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   33934:	482f      	ldr	r0, [pc, #188]	; (339f4 <z_add_thread_to_ready_q+0xd4>)
   33936:	f000 ff87 	bl	34848 <z_spin_lock_valid>
   3393a:	b968      	cbnz	r0, 33958 <z_add_thread_to_ready_q+0x38>
   3393c:	234a      	movs	r3, #74	; 0x4a
   3393e:	4a2e      	ldr	r2, [pc, #184]	; (339f8 <z_add_thread_to_ready_q+0xd8>)
   33940:	492e      	ldr	r1, [pc, #184]	; (339fc <z_add_thread_to_ready_q+0xdc>)
   33942:	482f      	ldr	r0, [pc, #188]	; (33a00 <z_add_thread_to_ready_q+0xe0>)
   33944:	f004 f9bc 	bl	37cc0 <printk>
   33948:	492a      	ldr	r1, [pc, #168]	; (339f4 <z_add_thread_to_ready_q+0xd4>)
   3394a:	482e      	ldr	r0, [pc, #184]	; (33a04 <z_add_thread_to_ready_q+0xe4>)
   3394c:	f004 f9b8 	bl	37cc0 <printk>
   33950:	214a      	movs	r1, #74	; 0x4a
   33952:	4829      	ldr	r0, [pc, #164]	; (339f8 <z_add_thread_to_ready_q+0xd8>)
   33954:	f004 f9fa 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   33958:	4826      	ldr	r0, [pc, #152]	; (339f4 <z_add_thread_to_ready_q+0xd4>)
   3395a:	f000 ff93 	bl	34884 <z_spin_lock_set_owner>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   3395e:	4b2a      	ldr	r3, [pc, #168]	; (33a08 <z_add_thread_to_ready_q+0xe8>)
   33960:	429c      	cmp	r4, r3
   33962:	d10b      	bne.n	3397c <z_add_thread_to_ready_q+0x5c>
   33964:	4929      	ldr	r1, [pc, #164]	; (33a0c <z_add_thread_to_ready_q+0xec>)
   33966:	4826      	ldr	r0, [pc, #152]	; (33a00 <z_add_thread_to_ready_q+0xe0>)
   33968:	f240 3302 	movw	r3, #770	; 0x302
   3396c:	4a28      	ldr	r2, [pc, #160]	; (33a10 <z_add_thread_to_ready_q+0xf0>)
   3396e:	f004 f9a7 	bl	37cc0 <printk>
   33972:	f240 3102 	movw	r1, #770	; 0x302
   33976:	4826      	ldr	r0, [pc, #152]	; (33a10 <z_add_thread_to_ready_q+0xf0>)
   33978:	f004 f9e8 	bl	37d4c <assert_post_action>
	return list->head == list;
   3397c:	4a25      	ldr	r2, [pc, #148]	; (33a14 <z_add_thread_to_ready_q+0xf4>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
   3397e:	f102 0128 	add.w	r1, r2, #40	; 0x28
   33982:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
   33986:	428b      	cmp	r3, r1
   33988:	d02e      	beq.n	339e8 <z_add_thread_to_ready_q+0xc8>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   3398a:	b36b      	cbz	r3, 339e8 <z_add_thread_to_ready_q+0xc8>
	if (thread_1->base.prio < thread_2->base.prio) {
   3398c:	f994 600e 	ldrsb.w	r6, [r4, #14]
   33990:	f993 700e 	ldrsb.w	r7, [r3, #14]
   33994:	42b7      	cmp	r7, r6
   33996:	dd22      	ble.n	339de <z_add_thread_to_ready_q+0xbe>
	node->prev = successor->prev;
   33998:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   3399a:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   3399e:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   339a0:	605c      	str	r4, [r3, #4]
	thread->base.thread_state |= states;
   339a2:	7b63      	ldrb	r3, [r4, #13]
		update_cache(0);
   339a4:	2000      	movs	r0, #0
   339a6:	f063 037f 	orn	r3, r3, #127	; 0x7f
   339aa:	7363      	strb	r3, [r4, #13]
   339ac:	f7ff ff06 	bl	337bc <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   339b0:	4810      	ldr	r0, [pc, #64]	; (339f4 <z_add_thread_to_ready_q+0xd4>)
   339b2:	f000 ff57 	bl	34864 <z_spin_unlock_valid>
   339b6:	b968      	cbnz	r0, 339d4 <z_add_thread_to_ready_q+0xb4>
   339b8:	235d      	movs	r3, #93	; 0x5d
   339ba:	4a0f      	ldr	r2, [pc, #60]	; (339f8 <z_add_thread_to_ready_q+0xd8>)
   339bc:	4916      	ldr	r1, [pc, #88]	; (33a18 <z_add_thread_to_ready_q+0xf8>)
   339be:	4810      	ldr	r0, [pc, #64]	; (33a00 <z_add_thread_to_ready_q+0xe0>)
   339c0:	f004 f97e 	bl	37cc0 <printk>
   339c4:	490b      	ldr	r1, [pc, #44]	; (339f4 <z_add_thread_to_ready_q+0xd4>)
   339c6:	4815      	ldr	r0, [pc, #84]	; (33a1c <z_add_thread_to_ready_q+0xfc>)
   339c8:	f004 f97a 	bl	37cc0 <printk>
   339cc:	215d      	movs	r1, #93	; 0x5d
   339ce:	480a      	ldr	r0, [pc, #40]	; (339f8 <z_add_thread_to_ready_q+0xd8>)
   339d0:	f004 f9bc 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   339d4:	f385 8811 	msr	BASEPRI, r5
   339d8:	f3bf 8f6f 	isb	sy
}
   339dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   339de:	4298      	cmp	r0, r3
   339e0:	d002      	beq.n	339e8 <z_add_thread_to_ready_q+0xc8>
   339e2:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   339e4:	2b00      	cmp	r3, #0
   339e6:	d1d3      	bne.n	33990 <z_add_thread_to_ready_q+0x70>
	node->prev = list->tail;
   339e8:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   339ec:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   339ee:	601c      	str	r4, [r3, #0]
	list->tail = node;
   339f0:	62d4      	str	r4, [r2, #44]	; 0x2c
   339f2:	e7d6      	b.n	339a2 <z_add_thread_to_ready_q+0x82>
   339f4:	20022140 	.word	0x20022140
   339f8:	0003ba71 	.word	0x0003ba71
   339fc:	0003ba97 	.word	0x0003ba97
   33a00:	0003baac 	.word	0x0003baac
   33a04:	0003bac9 	.word	0x0003bac9
   33a08:	20020f64 	.word	0x20020f64
   33a0c:	0003f19e 	.word	0x0003f19e
   33a10:	0003f146 	.word	0x0003f146
   33a14:	20022108 	.word	0x20022108
   33a18:	0003bb0b 	.word	0x0003bb0b
   33a1c:	0003bb22 	.word	0x0003bb22

00033a20 <z_thread_timeout>:
	if (thread->base.pended_on != NULL) {
   33a20:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
   33a24:	b570      	push	{r4, r5, r6, lr}
   33a26:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
   33a28:	f1a0 0518 	sub.w	r5, r0, #24
	if (thread->base.pended_on != NULL) {
   33a2c:	2b00      	cmp	r3, #0
   33a2e:	d042      	beq.n	33ab6 <z_thread_timeout+0x96>
	__asm__ volatile(
   33a30:	f04f 0320 	mov.w	r3, #32
   33a34:	f3ef 8611 	mrs	r6, BASEPRI
   33a38:	f383 8811 	msr	BASEPRI, r3
   33a3c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   33a40:	4825      	ldr	r0, [pc, #148]	; (33ad8 <z_thread_timeout+0xb8>)
   33a42:	f000 ff01 	bl	34848 <z_spin_lock_valid>
   33a46:	b968      	cbnz	r0, 33a64 <z_thread_timeout+0x44>
   33a48:	234a      	movs	r3, #74	; 0x4a
   33a4a:	4a24      	ldr	r2, [pc, #144]	; (33adc <z_thread_timeout+0xbc>)
   33a4c:	4924      	ldr	r1, [pc, #144]	; (33ae0 <z_thread_timeout+0xc0>)
   33a4e:	4825      	ldr	r0, [pc, #148]	; (33ae4 <z_thread_timeout+0xc4>)
   33a50:	f004 f936 	bl	37cc0 <printk>
   33a54:	4920      	ldr	r1, [pc, #128]	; (33ad8 <z_thread_timeout+0xb8>)
   33a56:	4824      	ldr	r0, [pc, #144]	; (33ae8 <z_thread_timeout+0xc8>)
   33a58:	f004 f932 	bl	37cc0 <printk>
   33a5c:	214a      	movs	r1, #74	; 0x4a
   33a5e:	481f      	ldr	r0, [pc, #124]	; (33adc <z_thread_timeout+0xbc>)
   33a60:	f004 f974 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   33a64:	481c      	ldr	r0, [pc, #112]	; (33ad8 <z_thread_timeout+0xb8>)
   33a66:	f000 ff0d 	bl	34884 <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   33a6a:	f1a4 0010 	sub.w	r0, r4, #16
   33a6e:	f7ff fc43 	bl	332f8 <pended_on.isra.17>
   33a72:	4629      	mov	r1, r5
   33a74:	f7ff fe1e 	bl	336b4 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   33a78:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   33a7c:	4816      	ldr	r0, [pc, #88]	; (33ad8 <z_thread_timeout+0xb8>)
   33a7e:	f023 0302 	bic.w	r3, r3, #2
   33a82:	f804 3c0b 	strb.w	r3, [r4, #-11]
   33a86:	f000 feed 	bl	34864 <z_spin_unlock_valid>
   33a8a:	b968      	cbnz	r0, 33aa8 <z_thread_timeout+0x88>
   33a8c:	235d      	movs	r3, #93	; 0x5d
   33a8e:	4a13      	ldr	r2, [pc, #76]	; (33adc <z_thread_timeout+0xbc>)
   33a90:	4916      	ldr	r1, [pc, #88]	; (33aec <z_thread_timeout+0xcc>)
   33a92:	4814      	ldr	r0, [pc, #80]	; (33ae4 <z_thread_timeout+0xc4>)
   33a94:	f004 f914 	bl	37cc0 <printk>
   33a98:	490f      	ldr	r1, [pc, #60]	; (33ad8 <z_thread_timeout+0xb8>)
   33a9a:	4815      	ldr	r0, [pc, #84]	; (33af0 <z_thread_timeout+0xd0>)
   33a9c:	f004 f910 	bl	37cc0 <printk>
   33aa0:	215d      	movs	r1, #93	; 0x5d
   33aa2:	480e      	ldr	r0, [pc, #56]	; (33adc <z_thread_timeout+0xbc>)
   33aa4:	f004 f952 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   33aa8:	f386 8811 	msr	BASEPRI, r6
   33aac:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   33ab0:	2300      	movs	r3, #0
   33ab2:	f844 3c10 	str.w	r3, [r4, #-16]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   33ab6:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
   33aba:	4628      	mov	r0, r5
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   33abc:	f023 0314 	bic.w	r3, r3, #20
   33ac0:	f804 3c0b 	strb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
   33ac4:	f005 ffcb 	bl	39a5e <z_is_thread_ready>
   33ac8:	b120      	cbz	r0, 33ad4 <z_thread_timeout+0xb4>
		z_add_thread_to_ready_q(thread);
   33aca:	4628      	mov	r0, r5
}
   33acc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   33ad0:	f7ff bf26 	b.w	33920 <z_add_thread_to_ready_q>
   33ad4:	bd70      	pop	{r4, r5, r6, pc}
   33ad6:	bf00      	nop
   33ad8:	20022140 	.word	0x20022140
   33adc:	0003ba71 	.word	0x0003ba71
   33ae0:	0003ba97 	.word	0x0003ba97
   33ae4:	0003baac 	.word	0x0003baac
   33ae8:	0003bac9 	.word	0x0003bac9
   33aec:	0003bb0b 	.word	0x0003bb0b
   33af0:	0003bb22 	.word	0x0003bb22

00033af4 <z_move_thread_to_end_of_prio_q>:
{
   33af4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   33af6:	4604      	mov	r4, r0
	__asm__ volatile(
   33af8:	f04f 0320 	mov.w	r3, #32
   33afc:	f3ef 8511 	mrs	r5, BASEPRI
   33b00:	f383 8811 	msr	BASEPRI, r3
   33b04:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   33b08:	4835      	ldr	r0, [pc, #212]	; (33be0 <z_move_thread_to_end_of_prio_q+0xec>)
   33b0a:	f000 fe9d 	bl	34848 <z_spin_lock_valid>
   33b0e:	b968      	cbnz	r0, 33b2c <z_move_thread_to_end_of_prio_q+0x38>
   33b10:	234a      	movs	r3, #74	; 0x4a
   33b12:	4a34      	ldr	r2, [pc, #208]	; (33be4 <z_move_thread_to_end_of_prio_q+0xf0>)
   33b14:	4934      	ldr	r1, [pc, #208]	; (33be8 <z_move_thread_to_end_of_prio_q+0xf4>)
   33b16:	4835      	ldr	r0, [pc, #212]	; (33bec <z_move_thread_to_end_of_prio_q+0xf8>)
   33b18:	f004 f8d2 	bl	37cc0 <printk>
   33b1c:	4930      	ldr	r1, [pc, #192]	; (33be0 <z_move_thread_to_end_of_prio_q+0xec>)
   33b1e:	4834      	ldr	r0, [pc, #208]	; (33bf0 <z_move_thread_to_end_of_prio_q+0xfc>)
   33b20:	f004 f8ce 	bl	37cc0 <printk>
   33b24:	214a      	movs	r1, #74	; 0x4a
   33b26:	482f      	ldr	r0, [pc, #188]	; (33be4 <z_move_thread_to_end_of_prio_q+0xf0>)
   33b28:	f004 f910 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   33b2c:	482c      	ldr	r0, [pc, #176]	; (33be0 <z_move_thread_to_end_of_prio_q+0xec>)
   33b2e:	f000 fea9 	bl	34884 <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
   33b32:	f994 300d 	ldrsb.w	r3, [r4, #13]
   33b36:	2b00      	cmp	r3, #0
   33b38:	da03      	bge.n	33b42 <z_move_thread_to_end_of_prio_q+0x4e>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   33b3a:	4621      	mov	r1, r4
   33b3c:	482d      	ldr	r0, [pc, #180]	; (33bf4 <z_move_thread_to_end_of_prio_q+0x100>)
   33b3e:	f7ff fdb9 	bl	336b4 <z_priq_dumb_remove>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   33b42:	4b2d      	ldr	r3, [pc, #180]	; (33bf8 <z_move_thread_to_end_of_prio_q+0x104>)
   33b44:	429c      	cmp	r4, r3
   33b46:	d10b      	bne.n	33b60 <z_move_thread_to_end_of_prio_q+0x6c>
   33b48:	492c      	ldr	r1, [pc, #176]	; (33bfc <z_move_thread_to_end_of_prio_q+0x108>)
   33b4a:	4828      	ldr	r0, [pc, #160]	; (33bec <z_move_thread_to_end_of_prio_q+0xf8>)
   33b4c:	f240 3302 	movw	r3, #770	; 0x302
   33b50:	4a2b      	ldr	r2, [pc, #172]	; (33c00 <z_move_thread_to_end_of_prio_q+0x10c>)
   33b52:	f004 f8b5 	bl	37cc0 <printk>
   33b56:	f240 3102 	movw	r1, #770	; 0x302
   33b5a:	4829      	ldr	r0, [pc, #164]	; (33c00 <z_move_thread_to_end_of_prio_q+0x10c>)
   33b5c:	f004 f8f6 	bl	37d4c <assert_post_action>
	return list->head == list;
   33b60:	4a28      	ldr	r2, [pc, #160]	; (33c04 <z_move_thread_to_end_of_prio_q+0x110>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
   33b62:	f102 0128 	add.w	r1, r2, #40	; 0x28
   33b66:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
   33b6a:	428b      	cmp	r3, r1
   33b6c:	d032      	beq.n	33bd4 <z_move_thread_to_end_of_prio_q+0xe0>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   33b6e:	2b00      	cmp	r3, #0
   33b70:	d030      	beq.n	33bd4 <z_move_thread_to_end_of_prio_q+0xe0>
	if (thread_1->base.prio < thread_2->base.prio) {
   33b72:	f994 600e 	ldrsb.w	r6, [r4, #14]
   33b76:	f993 700e 	ldrsb.w	r7, [r3, #14]
   33b7a:	42b7      	cmp	r7, r6
   33b7c:	dd25      	ble.n	33bca <z_move_thread_to_end_of_prio_q+0xd6>
	node->prev = successor->prev;
   33b7e:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   33b80:	e9c4 3100 	strd	r3, r1, [r4]
	successor->prev->next = node;
   33b84:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   33b86:	605c      	str	r4, [r3, #4]
	thread->base.thread_state |= states;
   33b88:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
   33b8a:	6890      	ldr	r0, [r2, #8]
   33b8c:	f063 037f 	orn	r3, r3, #127	; 0x7f
   33b90:	7363      	strb	r3, [r4, #13]
   33b92:	1b03      	subs	r3, r0, r4
   33b94:	4258      	negs	r0, r3
   33b96:	4158      	adcs	r0, r3
   33b98:	f7ff fe10 	bl	337bc <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   33b9c:	4810      	ldr	r0, [pc, #64]	; (33be0 <z_move_thread_to_end_of_prio_q+0xec>)
   33b9e:	f000 fe61 	bl	34864 <z_spin_unlock_valid>
   33ba2:	b968      	cbnz	r0, 33bc0 <z_move_thread_to_end_of_prio_q+0xcc>
   33ba4:	235d      	movs	r3, #93	; 0x5d
   33ba6:	4a0f      	ldr	r2, [pc, #60]	; (33be4 <z_move_thread_to_end_of_prio_q+0xf0>)
   33ba8:	4917      	ldr	r1, [pc, #92]	; (33c08 <z_move_thread_to_end_of_prio_q+0x114>)
   33baa:	4810      	ldr	r0, [pc, #64]	; (33bec <z_move_thread_to_end_of_prio_q+0xf8>)
   33bac:	f004 f888 	bl	37cc0 <printk>
   33bb0:	490b      	ldr	r1, [pc, #44]	; (33be0 <z_move_thread_to_end_of_prio_q+0xec>)
   33bb2:	4816      	ldr	r0, [pc, #88]	; (33c0c <z_move_thread_to_end_of_prio_q+0x118>)
   33bb4:	f004 f884 	bl	37cc0 <printk>
   33bb8:	215d      	movs	r1, #93	; 0x5d
   33bba:	480a      	ldr	r0, [pc, #40]	; (33be4 <z_move_thread_to_end_of_prio_q+0xf0>)
   33bbc:	f004 f8c6 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   33bc0:	f385 8811 	msr	BASEPRI, r5
   33bc4:	f3bf 8f6f 	isb	sy
}
   33bc8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   33bca:	4298      	cmp	r0, r3
   33bcc:	d002      	beq.n	33bd4 <z_move_thread_to_end_of_prio_q+0xe0>
   33bce:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   33bd0:	2b00      	cmp	r3, #0
   33bd2:	d1d0      	bne.n	33b76 <z_move_thread_to_end_of_prio_q+0x82>
	node->prev = list->tail;
   33bd4:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   33bd8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   33bda:	601c      	str	r4, [r3, #0]
	list->tail = node;
   33bdc:	62d4      	str	r4, [r2, #44]	; 0x2c
   33bde:	e7d3      	b.n	33b88 <z_move_thread_to_end_of_prio_q+0x94>
   33be0:	20022140 	.word	0x20022140
   33be4:	0003ba71 	.word	0x0003ba71
   33be8:	0003ba97 	.word	0x0003ba97
   33bec:	0003baac 	.word	0x0003baac
   33bf0:	0003bac9 	.word	0x0003bac9
   33bf4:	20022130 	.word	0x20022130
   33bf8:	20020f64 	.word	0x20020f64
   33bfc:	0003f19e 	.word	0x0003f19e
   33c00:	0003f146 	.word	0x0003f146
   33c04:	20022108 	.word	0x20022108
   33c08:	0003bb0b 	.word	0x0003bb0b
   33c0c:	0003bb22 	.word	0x0003bb22

00033c10 <z_time_slice>:
	if (pending_current == _current) {
   33c10:	4a15      	ldr	r2, [pc, #84]	; (33c68 <z_time_slice+0x58>)
   33c12:	4916      	ldr	r1, [pc, #88]	; (33c6c <z_time_slice+0x5c>)
{
   33c14:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
   33c16:	680c      	ldr	r4, [r1, #0]
   33c18:	6893      	ldr	r3, [r2, #8]
   33c1a:	42a3      	cmp	r3, r4
   33c1c:	4614      	mov	r4, r2
   33c1e:	d103      	bne.n	33c28 <z_time_slice+0x18>
}
   33c20:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
   33c24:	f7ff bb80 	b.w	33328 <z_reset_time_slice>
	pending_current = NULL;
   33c28:	2500      	movs	r5, #0
   33c2a:	600d      	str	r5, [r1, #0]
	if (slice_time && sliceable(_current)) {
   33c2c:	4910      	ldr	r1, [pc, #64]	; (33c70 <z_time_slice+0x60>)
   33c2e:	6809      	ldr	r1, [r1, #0]
   33c30:	b1b9      	cbz	r1, 33c62 <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   33c32:	89d9      	ldrh	r1, [r3, #14]
   33c34:	297f      	cmp	r1, #127	; 0x7f
   33c36:	d814      	bhi.n	33c62 <z_time_slice+0x52>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   33c38:	490e      	ldr	r1, [pc, #56]	; (33c74 <z_time_slice+0x64>)
   33c3a:	f993 500e 	ldrsb.w	r5, [r3, #14]
   33c3e:	6809      	ldr	r1, [r1, #0]
   33c40:	428d      	cmp	r5, r1
   33c42:	db0e      	blt.n	33c62 <z_time_slice+0x52>
		&& !z_is_idle_thread_object(thread)
   33c44:	490c      	ldr	r1, [pc, #48]	; (33c78 <z_time_slice+0x68>)
   33c46:	428b      	cmp	r3, r1
   33c48:	d00b      	beq.n	33c62 <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   33c4a:	6999      	ldr	r1, [r3, #24]
   33c4c:	b949      	cbnz	r1, 33c62 <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
   33c4e:	6911      	ldr	r1, [r2, #16]
   33c50:	4281      	cmp	r1, r0
   33c52:	dc03      	bgt.n	33c5c <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
   33c54:	4618      	mov	r0, r3
   33c56:	f7ff ff4d 	bl	33af4 <z_move_thread_to_end_of_prio_q>
   33c5a:	e7e1      	b.n	33c20 <z_time_slice+0x10>
			_current_cpu->slice_ticks -= ticks;
   33c5c:	1a09      	subs	r1, r1, r0
   33c5e:	6111      	str	r1, [r2, #16]
}
   33c60:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
   33c62:	2300      	movs	r3, #0
   33c64:	6123      	str	r3, [r4, #16]
   33c66:	e7fb      	b.n	33c60 <z_time_slice+0x50>
   33c68:	20022108 	.word	0x20022108
   33c6c:	2002213c 	.word	0x2002213c
   33c70:	20022148 	.word	0x20022148
   33c74:	20022144 	.word	0x20022144
   33c78:	20020f64 	.word	0x20020f64

00033c7c <z_thread_single_suspend>:
{
   33c7c:	b570      	push	{r4, r5, r6, lr}
   33c7e:	4604      	mov	r4, r0
   33c80:	3018      	adds	r0, #24
   33c82:	f001 f921 	bl	34ec8 <z_abort_timeout>
	__asm__ volatile(
   33c86:	f04f 0320 	mov.w	r3, #32
   33c8a:	f3ef 8611 	mrs	r6, BASEPRI
   33c8e:	f383 8811 	msr	BASEPRI, r3
   33c92:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   33c96:	4825      	ldr	r0, [pc, #148]	; (33d2c <z_thread_single_suspend+0xb0>)
   33c98:	f000 fdd6 	bl	34848 <z_spin_lock_valid>
   33c9c:	b968      	cbnz	r0, 33cba <z_thread_single_suspend+0x3e>
   33c9e:	234a      	movs	r3, #74	; 0x4a
   33ca0:	4a23      	ldr	r2, [pc, #140]	; (33d30 <z_thread_single_suspend+0xb4>)
   33ca2:	4924      	ldr	r1, [pc, #144]	; (33d34 <z_thread_single_suspend+0xb8>)
   33ca4:	4824      	ldr	r0, [pc, #144]	; (33d38 <z_thread_single_suspend+0xbc>)
   33ca6:	f004 f80b 	bl	37cc0 <printk>
   33caa:	4920      	ldr	r1, [pc, #128]	; (33d2c <z_thread_single_suspend+0xb0>)
   33cac:	4823      	ldr	r0, [pc, #140]	; (33d3c <z_thread_single_suspend+0xc0>)
   33cae:	f004 f807 	bl	37cc0 <printk>
   33cb2:	214a      	movs	r1, #74	; 0x4a
   33cb4:	481e      	ldr	r0, [pc, #120]	; (33d30 <z_thread_single_suspend+0xb4>)
   33cb6:	f004 f849 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   33cba:	481c      	ldr	r0, [pc, #112]	; (33d2c <z_thread_single_suspend+0xb0>)
   33cbc:	f000 fde2 	bl	34884 <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
   33cc0:	f994 300d 	ldrsb.w	r3, [r4, #13]
   33cc4:	2b00      	cmp	r3, #0
   33cc6:	da07      	bge.n	33cd8 <z_thread_single_suspend+0x5c>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   33cc8:	4621      	mov	r1, r4
   33cca:	481d      	ldr	r0, [pc, #116]	; (33d40 <z_thread_single_suspend+0xc4>)
   33ccc:	f7ff fcf2 	bl	336b4 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   33cd0:	7b63      	ldrb	r3, [r4, #13]
   33cd2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   33cd6:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   33cd8:	4d1a      	ldr	r5, [pc, #104]	; (33d44 <z_thread_single_suspend+0xc8>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   33cda:	7b63      	ldrb	r3, [r4, #13]
   33cdc:	68a8      	ldr	r0, [r5, #8]
   33cde:	f043 0310 	orr.w	r3, r3, #16
   33ce2:	7363      	strb	r3, [r4, #13]
   33ce4:	1b03      	subs	r3, r0, r4
   33ce6:	4258      	negs	r0, r3
   33ce8:	4158      	adcs	r0, r3
   33cea:	f7ff fd67 	bl	337bc <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   33cee:	480f      	ldr	r0, [pc, #60]	; (33d2c <z_thread_single_suspend+0xb0>)
   33cf0:	f000 fdb8 	bl	34864 <z_spin_unlock_valid>
   33cf4:	b968      	cbnz	r0, 33d12 <z_thread_single_suspend+0x96>
   33cf6:	235d      	movs	r3, #93	; 0x5d
   33cf8:	4a0d      	ldr	r2, [pc, #52]	; (33d30 <z_thread_single_suspend+0xb4>)
   33cfa:	4913      	ldr	r1, [pc, #76]	; (33d48 <z_thread_single_suspend+0xcc>)
   33cfc:	480e      	ldr	r0, [pc, #56]	; (33d38 <z_thread_single_suspend+0xbc>)
   33cfe:	f003 ffdf 	bl	37cc0 <printk>
   33d02:	490a      	ldr	r1, [pc, #40]	; (33d2c <z_thread_single_suspend+0xb0>)
   33d04:	4811      	ldr	r0, [pc, #68]	; (33d4c <z_thread_single_suspend+0xd0>)
   33d06:	f003 ffdb 	bl	37cc0 <printk>
   33d0a:	215d      	movs	r1, #93	; 0x5d
   33d0c:	4808      	ldr	r0, [pc, #32]	; (33d30 <z_thread_single_suspend+0xb4>)
   33d0e:	f004 f81d 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   33d12:	f386 8811 	msr	BASEPRI, r6
   33d16:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   33d1a:	68ab      	ldr	r3, [r5, #8]
   33d1c:	42a3      	cmp	r3, r4
   33d1e:	d103      	bne.n	33d28 <z_thread_single_suspend+0xac>
}
   33d20:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   33d24:	f005 beb9 	b.w	39a9a <z_reschedule_unlocked>
}
   33d28:	bd70      	pop	{r4, r5, r6, pc}
   33d2a:	bf00      	nop
   33d2c:	20022140 	.word	0x20022140
   33d30:	0003ba71 	.word	0x0003ba71
   33d34:	0003ba97 	.word	0x0003ba97
   33d38:	0003baac 	.word	0x0003baac
   33d3c:	0003bac9 	.word	0x0003bac9
   33d40:	20022130 	.word	0x20022130
   33d44:	20022108 	.word	0x20022108
   33d48:	0003bb0b 	.word	0x0003bb0b
   33d4c:	0003bb22 	.word	0x0003bb22

00033d50 <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
   33d50:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
   33d52:	b570      	push	{r4, r5, r6, lr}
   33d54:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
   33d56:	b103      	cbz	r3, 33d5a <z_thread_single_abort+0xa>
		thread->fn_abort();
   33d58:	4798      	blx	r3
   33d5a:	f104 0018 	add.w	r0, r4, #24
   33d5e:	f001 f8b3 	bl	34ec8 <z_abort_timeout>
	__asm__ volatile(
   33d62:	f04f 0320 	mov.w	r3, #32
   33d66:	f3ef 8511 	mrs	r5, BASEPRI
   33d6a:	f383 8811 	msr	BASEPRI, r3
   33d6e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   33d72:	482c      	ldr	r0, [pc, #176]	; (33e24 <z_thread_single_abort+0xd4>)
   33d74:	f000 fd68 	bl	34848 <z_spin_lock_valid>
   33d78:	b968      	cbnz	r0, 33d96 <z_thread_single_abort+0x46>
   33d7a:	234a      	movs	r3, #74	; 0x4a
   33d7c:	4a2a      	ldr	r2, [pc, #168]	; (33e28 <z_thread_single_abort+0xd8>)
   33d7e:	492b      	ldr	r1, [pc, #172]	; (33e2c <z_thread_single_abort+0xdc>)
   33d80:	482b      	ldr	r0, [pc, #172]	; (33e30 <z_thread_single_abort+0xe0>)
   33d82:	f003 ff9d 	bl	37cc0 <printk>
   33d86:	4927      	ldr	r1, [pc, #156]	; (33e24 <z_thread_single_abort+0xd4>)
   33d88:	482a      	ldr	r0, [pc, #168]	; (33e34 <z_thread_single_abort+0xe4>)
   33d8a:	f003 ff99 	bl	37cc0 <printk>
   33d8e:	214a      	movs	r1, #74	; 0x4a
   33d90:	4825      	ldr	r0, [pc, #148]	; (33e28 <z_thread_single_abort+0xd8>)
   33d92:	f003 ffdb 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   33d96:	4823      	ldr	r0, [pc, #140]	; (33e24 <z_thread_single_abort+0xd4>)
   33d98:	f000 fd74 	bl	34884 <z_spin_lock_set_owner>
		if (z_is_thread_ready(thread)) {
   33d9c:	4620      	mov	r0, r4
   33d9e:	f005 fe5e 	bl	39a5e <z_is_thread_ready>
   33da2:	4606      	mov	r6, r0
   33da4:	b368      	cbz	r0, 33e02 <z_thread_single_abort+0xb2>
			if (z_is_thread_queued(thread)) {
   33da6:	f994 300d 	ldrsb.w	r3, [r4, #13]
   33daa:	2b00      	cmp	r3, #0
   33dac:	da07      	bge.n	33dbe <z_thread_single_abort+0x6e>
				_priq_run_remove(&_kernel.ready_q.runq,
   33dae:	4621      	mov	r1, r4
   33db0:	4821      	ldr	r0, [pc, #132]	; (33e38 <z_thread_single_abort+0xe8>)
   33db2:	f7ff fc7f 	bl	336b4 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   33db6:	7b63      	ldrb	r3, [r4, #13]
   33db8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   33dbc:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
   33dbe:	4b1f      	ldr	r3, [pc, #124]	; (33e3c <z_thread_single_abort+0xec>)
   33dc0:	6898      	ldr	r0, [r3, #8]
   33dc2:	1b02      	subs	r2, r0, r4
   33dc4:	4250      	negs	r0, r2
   33dc6:	4150      	adcs	r0, r2
   33dc8:	f7ff fcf8 	bl	337bc <update_cache>
		thread->base.thread_state |= mask;
   33dcc:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   33dce:	4815      	ldr	r0, [pc, #84]	; (33e24 <z_thread_single_abort+0xd4>)
   33dd0:	f043 0308 	orr.w	r3, r3, #8
   33dd4:	7363      	strb	r3, [r4, #13]
   33dd6:	f000 fd45 	bl	34864 <z_spin_unlock_valid>
   33dda:	b968      	cbnz	r0, 33df8 <z_thread_single_abort+0xa8>
   33ddc:	235d      	movs	r3, #93	; 0x5d
   33dde:	4a12      	ldr	r2, [pc, #72]	; (33e28 <z_thread_single_abort+0xd8>)
   33de0:	4917      	ldr	r1, [pc, #92]	; (33e40 <z_thread_single_abort+0xf0>)
   33de2:	4813      	ldr	r0, [pc, #76]	; (33e30 <z_thread_single_abort+0xe0>)
   33de4:	f003 ff6c 	bl	37cc0 <printk>
   33de8:	490e      	ldr	r1, [pc, #56]	; (33e24 <z_thread_single_abort+0xd4>)
   33dea:	4816      	ldr	r0, [pc, #88]	; (33e44 <z_thread_single_abort+0xf4>)
   33dec:	f003 ff68 	bl	37cc0 <printk>
   33df0:	215d      	movs	r1, #93	; 0x5d
   33df2:	480d      	ldr	r0, [pc, #52]	; (33e28 <z_thread_single_abort+0xd8>)
   33df4:	f003 ffaa 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   33df8:	f385 8811 	msr	BASEPRI, r5
   33dfc:	f3bf 8f6f 	isb	sy
}
   33e00:	bd70      	pop	{r4, r5, r6, pc}
			if (z_is_thread_pending(thread)) {
   33e02:	7b63      	ldrb	r3, [r4, #13]
   33e04:	079b      	lsls	r3, r3, #30
   33e06:	d5e1      	bpl.n	33dcc <z_thread_single_abort+0x7c>
				_priq_wait_remove(&pended_on(thread)->waitq,
   33e08:	f104 0008 	add.w	r0, r4, #8
   33e0c:	f7ff fa74 	bl	332f8 <pended_on.isra.17>
   33e10:	4621      	mov	r1, r4
   33e12:	f7ff fc4f 	bl	336b4 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   33e16:	7b63      	ldrb	r3, [r4, #13]
				thread->base.pended_on = NULL;
   33e18:	60a6      	str	r6, [r4, #8]
   33e1a:	f023 0302 	bic.w	r3, r3, #2
   33e1e:	7363      	strb	r3, [r4, #13]
   33e20:	e7d4      	b.n	33dcc <z_thread_single_abort+0x7c>
   33e22:	bf00      	nop
   33e24:	20022140 	.word	0x20022140
   33e28:	0003ba71 	.word	0x0003ba71
   33e2c:	0003ba97 	.word	0x0003ba97
   33e30:	0003baac 	.word	0x0003baac
   33e34:	0003bac9 	.word	0x0003bac9
   33e38:	20022130 	.word	0x20022130
   33e3c:	20022108 	.word	0x20022108
   33e40:	0003bb0b 	.word	0x0003bb0b
   33e44:	0003bb22 	.word	0x0003bb22

00033e48 <z_remove_thread_from_ready_q>:
{
   33e48:	b538      	push	{r3, r4, r5, lr}
   33e4a:	4604      	mov	r4, r0
	__asm__ volatile(
   33e4c:	f04f 0320 	mov.w	r3, #32
   33e50:	f3ef 8511 	mrs	r5, BASEPRI
   33e54:	f383 8811 	msr	BASEPRI, r3
   33e58:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   33e5c:	481f      	ldr	r0, [pc, #124]	; (33edc <z_remove_thread_from_ready_q+0x94>)
   33e5e:	f000 fcf3 	bl	34848 <z_spin_lock_valid>
   33e62:	b968      	cbnz	r0, 33e80 <z_remove_thread_from_ready_q+0x38>
   33e64:	234a      	movs	r3, #74	; 0x4a
   33e66:	4a1e      	ldr	r2, [pc, #120]	; (33ee0 <z_remove_thread_from_ready_q+0x98>)
   33e68:	491e      	ldr	r1, [pc, #120]	; (33ee4 <z_remove_thread_from_ready_q+0x9c>)
   33e6a:	481f      	ldr	r0, [pc, #124]	; (33ee8 <z_remove_thread_from_ready_q+0xa0>)
   33e6c:	f003 ff28 	bl	37cc0 <printk>
   33e70:	491a      	ldr	r1, [pc, #104]	; (33edc <z_remove_thread_from_ready_q+0x94>)
   33e72:	481e      	ldr	r0, [pc, #120]	; (33eec <z_remove_thread_from_ready_q+0xa4>)
   33e74:	f003 ff24 	bl	37cc0 <printk>
   33e78:	214a      	movs	r1, #74	; 0x4a
   33e7a:	4819      	ldr	r0, [pc, #100]	; (33ee0 <z_remove_thread_from_ready_q+0x98>)
   33e7c:	f003 ff66 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   33e80:	4816      	ldr	r0, [pc, #88]	; (33edc <z_remove_thread_from_ready_q+0x94>)
   33e82:	f000 fcff 	bl	34884 <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
   33e86:	f994 300d 	ldrsb.w	r3, [r4, #13]
   33e8a:	2b00      	cmp	r3, #0
   33e8c:	da07      	bge.n	33e9e <z_remove_thread_from_ready_q+0x56>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   33e8e:	4621      	mov	r1, r4
   33e90:	4817      	ldr	r0, [pc, #92]	; (33ef0 <z_remove_thread_from_ready_q+0xa8>)
   33e92:	f7ff fc0f 	bl	336b4 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   33e96:	7b63      	ldrb	r3, [r4, #13]
   33e98:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   33e9c:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   33e9e:	4b15      	ldr	r3, [pc, #84]	; (33ef4 <z_remove_thread_from_ready_q+0xac>)
   33ea0:	6898      	ldr	r0, [r3, #8]
   33ea2:	1b03      	subs	r3, r0, r4
   33ea4:	4258      	negs	r0, r3
   33ea6:	4158      	adcs	r0, r3
   33ea8:	f7ff fc88 	bl	337bc <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   33eac:	480b      	ldr	r0, [pc, #44]	; (33edc <z_remove_thread_from_ready_q+0x94>)
   33eae:	f000 fcd9 	bl	34864 <z_spin_unlock_valid>
   33eb2:	b968      	cbnz	r0, 33ed0 <z_remove_thread_from_ready_q+0x88>
   33eb4:	235d      	movs	r3, #93	; 0x5d
   33eb6:	4a0a      	ldr	r2, [pc, #40]	; (33ee0 <z_remove_thread_from_ready_q+0x98>)
   33eb8:	490f      	ldr	r1, [pc, #60]	; (33ef8 <z_remove_thread_from_ready_q+0xb0>)
   33eba:	480b      	ldr	r0, [pc, #44]	; (33ee8 <z_remove_thread_from_ready_q+0xa0>)
   33ebc:	f003 ff00 	bl	37cc0 <printk>
   33ec0:	4906      	ldr	r1, [pc, #24]	; (33edc <z_remove_thread_from_ready_q+0x94>)
   33ec2:	480e      	ldr	r0, [pc, #56]	; (33efc <z_remove_thread_from_ready_q+0xb4>)
   33ec4:	f003 fefc 	bl	37cc0 <printk>
   33ec8:	215d      	movs	r1, #93	; 0x5d
   33eca:	4805      	ldr	r0, [pc, #20]	; (33ee0 <z_remove_thread_from_ready_q+0x98>)
   33ecc:	f003 ff3e 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   33ed0:	f385 8811 	msr	BASEPRI, r5
   33ed4:	f3bf 8f6f 	isb	sy
}
   33ed8:	bd38      	pop	{r3, r4, r5, pc}
   33eda:	bf00      	nop
   33edc:	20022140 	.word	0x20022140
   33ee0:	0003ba71 	.word	0x0003ba71
   33ee4:	0003ba97 	.word	0x0003ba97
   33ee8:	0003baac 	.word	0x0003baac
   33eec:	0003bac9 	.word	0x0003bac9
   33ef0:	20022130 	.word	0x20022130
   33ef4:	20022108 	.word	0x20022108
   33ef8:	0003bb0b 	.word	0x0003bb0b
   33efc:	0003bb22 	.word	0x0003bb22

00033f00 <pend>:
{
   33f00:	b570      	push	{r4, r5, r6, lr}
   33f02:	4604      	mov	r4, r0
   33f04:	460d      	mov	r5, r1
   33f06:	4616      	mov	r6, r2
	z_remove_thread_from_ready_q(thread);
   33f08:	f7ff ff9e 	bl	33e48 <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_PENDING;
   33f0c:	7b63      	ldrb	r3, [r4, #13]
   33f0e:	f043 0302 	orr.w	r3, r3, #2
   33f12:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   33f14:	b1fd      	cbz	r5, 33f56 <pend+0x56>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   33f16:	4b2b      	ldr	r3, [pc, #172]	; (33fc4 <pend+0xc4>)
		thread->base.pended_on = wait_q;
   33f18:	60a5      	str	r5, [r4, #8]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   33f1a:	429c      	cmp	r4, r3
   33f1c:	d10b      	bne.n	33f36 <pend+0x36>
   33f1e:	492a      	ldr	r1, [pc, #168]	; (33fc8 <pend+0xc8>)
   33f20:	482a      	ldr	r0, [pc, #168]	; (33fcc <pend+0xcc>)
   33f22:	f240 3302 	movw	r3, #770	; 0x302
   33f26:	4a2a      	ldr	r2, [pc, #168]	; (33fd0 <pend+0xd0>)
   33f28:	f003 feca 	bl	37cc0 <printk>
   33f2c:	f240 3102 	movw	r1, #770	; 0x302
   33f30:	4827      	ldr	r0, [pc, #156]	; (33fd0 <pend+0xd0>)
   33f32:	f003 ff0b 	bl	37d4c <assert_post_action>
	return list->head == list;
   33f36:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   33f38:	429d      	cmp	r5, r3
   33f3a:	d03b      	beq.n	33fb4 <pend+0xb4>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   33f3c:	2b00      	cmp	r3, #0
   33f3e:	d039      	beq.n	33fb4 <pend+0xb4>
	if (thread_1->base.prio < thread_2->base.prio) {
   33f40:	f994 200e 	ldrsb.w	r2, [r4, #14]
   33f44:	f993 100e 	ldrsb.w	r1, [r3, #14]
   33f48:	4291      	cmp	r1, r2
   33f4a:	dd2d      	ble.n	33fa8 <pend+0xa8>
	node->prev = successor->prev;
   33f4c:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   33f4e:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   33f52:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   33f54:	605c      	str	r4, [r3, #4]
	if (timeout != K_FOREVER) {
   33f56:	1c73      	adds	r3, r6, #1
   33f58:	d033      	beq.n	33fc2 <pend+0xc2>
		__ASSERT(timeout >= 0,
   33f5a:	2e00      	cmp	r6, #0
   33f5c:	da0e      	bge.n	33f7c <pend+0x7c>
   33f5e:	491d      	ldr	r1, [pc, #116]	; (33fd4 <pend+0xd4>)
   33f60:	f44f 73fb 	mov.w	r3, #502	; 0x1f6
   33f64:	4a1a      	ldr	r2, [pc, #104]	; (33fd0 <pend+0xd0>)
   33f66:	4819      	ldr	r0, [pc, #100]	; (33fcc <pend+0xcc>)
   33f68:	f003 feaa 	bl	37cc0 <printk>
   33f6c:	481a      	ldr	r0, [pc, #104]	; (33fd8 <pend+0xd8>)
   33f6e:	f003 fea7 	bl	37cc0 <printk>
   33f72:	f44f 71fb 	mov.w	r1, #502	; 0x1f6
   33f76:	4816      	ldr	r0, [pc, #88]	; (33fd0 <pend+0xd0>)
   33f78:	f003 fee8 	bl	37d4c <assert_post_action>
   33f7c:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   33f80:	f240 30e7 	movw	r0, #999	; 0x3e7
   33f84:	2100      	movs	r1, #0
   33f86:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
   33f8a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   33f8e:	fbc5 0106 	smlal	r0, r1, r5, r6
   33f92:	2300      	movs	r3, #0
   33f94:	f7e8 ff1a 	bl	1cdcc <__aeabi_uldivmod>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   33f98:	4910      	ldr	r1, [pc, #64]	; (33fdc <pend+0xdc>)
   33f9a:	1c42      	adds	r2, r0, #1
   33f9c:	f104 0018 	add.w	r0, r4, #24
}
   33fa0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   33fa4:	f000 beea 	b.w	34d7c <z_add_timeout>
	return (node == list->tail) ? NULL : node->next;
   33fa8:	6869      	ldr	r1, [r5, #4]
   33faa:	428b      	cmp	r3, r1
   33fac:	d002      	beq.n	33fb4 <pend+0xb4>
   33fae:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   33fb0:	2b00      	cmp	r3, #0
   33fb2:	d1c7      	bne.n	33f44 <pend+0x44>
	node->prev = list->tail;
   33fb4:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   33fb6:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
   33fb8:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   33fba:	686b      	ldr	r3, [r5, #4]
   33fbc:	601c      	str	r4, [r3, #0]
	list->tail = node;
   33fbe:	606c      	str	r4, [r5, #4]
   33fc0:	e7c9      	b.n	33f56 <pend+0x56>
}
   33fc2:	bd70      	pop	{r4, r5, r6, pc}
   33fc4:	20020f64 	.word	0x20020f64
   33fc8:	0003f19e 	.word	0x0003f19e
   33fcc:	0003baac 	.word	0x0003baac
   33fd0:	0003f146 	.word	0x0003f146
   33fd4:	0003f110 	.word	0x0003f110
   33fd8:	0003f11d 	.word	0x0003f11d
   33fdc:	00033a21 	.word	0x00033a21

00033fe0 <z_pend_curr_irqlock>:
{
   33fe0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   33fe2:	4606      	mov	r6, r0
	pend(_current, wait_q, timeout);
   33fe4:	4d22      	ldr	r5, [pc, #136]	; (34070 <z_pend_curr_irqlock+0x90>)
	pending_current = _current;
   33fe6:	4c23      	ldr	r4, [pc, #140]	; (34074 <z_pend_curr_irqlock+0x94>)
	pend(_current, wait_q, timeout);
   33fe8:	68a8      	ldr	r0, [r5, #8]
   33fea:	f7ff ff89 	bl	33f00 <pend>
	pending_current = _current;
   33fee:	68ab      	ldr	r3, [r5, #8]
   33ff0:	4630      	mov	r0, r6
   33ff2:	6023      	str	r3, [r4, #0]
   33ff4:	f7f0 ffd2 	bl	24f9c <arch_swap>
   33ff8:	4606      	mov	r6, r0
	__asm__ volatile(
   33ffa:	f04f 0320 	mov.w	r3, #32
   33ffe:	f3ef 8711 	mrs	r7, BASEPRI
   34002:	f383 8811 	msr	BASEPRI, r3
   34006:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   3400a:	481b      	ldr	r0, [pc, #108]	; (34078 <z_pend_curr_irqlock+0x98>)
   3400c:	f000 fc1c 	bl	34848 <z_spin_lock_valid>
   34010:	b968      	cbnz	r0, 3402e <z_pend_curr_irqlock+0x4e>
   34012:	234a      	movs	r3, #74	; 0x4a
   34014:	4a19      	ldr	r2, [pc, #100]	; (3407c <z_pend_curr_irqlock+0x9c>)
   34016:	491a      	ldr	r1, [pc, #104]	; (34080 <z_pend_curr_irqlock+0xa0>)
   34018:	481a      	ldr	r0, [pc, #104]	; (34084 <z_pend_curr_irqlock+0xa4>)
   3401a:	f003 fe51 	bl	37cc0 <printk>
   3401e:	4916      	ldr	r1, [pc, #88]	; (34078 <z_pend_curr_irqlock+0x98>)
   34020:	4819      	ldr	r0, [pc, #100]	; (34088 <z_pend_curr_irqlock+0xa8>)
   34022:	f003 fe4d 	bl	37cc0 <printk>
   34026:	214a      	movs	r1, #74	; 0x4a
   34028:	4814      	ldr	r0, [pc, #80]	; (3407c <z_pend_curr_irqlock+0x9c>)
   3402a:	f003 fe8f 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   3402e:	4812      	ldr	r0, [pc, #72]	; (34078 <z_pend_curr_irqlock+0x98>)
   34030:	f000 fc28 	bl	34884 <z_spin_lock_set_owner>
		if (pending_current == _current) {
   34034:	6823      	ldr	r3, [r4, #0]
   34036:	68aa      	ldr	r2, [r5, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   34038:	480f      	ldr	r0, [pc, #60]	; (34078 <z_pend_curr_irqlock+0x98>)
   3403a:	429a      	cmp	r2, r3
			pending_current = NULL;
   3403c:	bf04      	itt	eq
   3403e:	2300      	moveq	r3, #0
   34040:	6023      	streq	r3, [r4, #0]
   34042:	f000 fc0f 	bl	34864 <z_spin_unlock_valid>
   34046:	b968      	cbnz	r0, 34064 <z_pend_curr_irqlock+0x84>
   34048:	235d      	movs	r3, #93	; 0x5d
   3404a:	4a0c      	ldr	r2, [pc, #48]	; (3407c <z_pend_curr_irqlock+0x9c>)
   3404c:	490f      	ldr	r1, [pc, #60]	; (3408c <z_pend_curr_irqlock+0xac>)
   3404e:	480d      	ldr	r0, [pc, #52]	; (34084 <z_pend_curr_irqlock+0xa4>)
   34050:	f003 fe36 	bl	37cc0 <printk>
   34054:	4908      	ldr	r1, [pc, #32]	; (34078 <z_pend_curr_irqlock+0x98>)
   34056:	480e      	ldr	r0, [pc, #56]	; (34090 <z_pend_curr_irqlock+0xb0>)
   34058:	f003 fe32 	bl	37cc0 <printk>
   3405c:	215d      	movs	r1, #93	; 0x5d
   3405e:	4807      	ldr	r0, [pc, #28]	; (3407c <z_pend_curr_irqlock+0x9c>)
   34060:	f003 fe74 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   34064:	f387 8811 	msr	BASEPRI, r7
   34068:	f3bf 8f6f 	isb	sy
}
   3406c:	4630      	mov	r0, r6
   3406e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   34070:	20022108 	.word	0x20022108
   34074:	2002213c 	.word	0x2002213c
   34078:	20022140 	.word	0x20022140
   3407c:	0003ba71 	.word	0x0003ba71
   34080:	0003ba97 	.word	0x0003ba97
   34084:	0003baac 	.word	0x0003baac
   34088:	0003bac9 	.word	0x0003bac9
   3408c:	0003bb0b 	.word	0x0003bb0b
   34090:	0003bb22 	.word	0x0003bb22

00034094 <z_pend_curr>:
{
   34094:	b538      	push	{r3, r4, r5, lr}
   34096:	4604      	mov	r4, r0
   34098:	460d      	mov	r5, r1
   3409a:	4611      	mov	r1, r2
	pending_current = _current;
   3409c:	4a0e      	ldr	r2, [pc, #56]	; (340d8 <z_pend_curr+0x44>)
   3409e:	6890      	ldr	r0, [r2, #8]
   340a0:	4a0e      	ldr	r2, [pc, #56]	; (340dc <z_pend_curr+0x48>)
   340a2:	6010      	str	r0, [r2, #0]
	pend(_current, wait_q, timeout);
   340a4:	461a      	mov	r2, r3
   340a6:	f7ff ff2b 	bl	33f00 <pend>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   340aa:	4620      	mov	r0, r4
   340ac:	f000 fbda 	bl	34864 <z_spin_unlock_valid>
   340b0:	b968      	cbnz	r0, 340ce <z_pend_curr+0x3a>
   340b2:	2374      	movs	r3, #116	; 0x74
   340b4:	4a0a      	ldr	r2, [pc, #40]	; (340e0 <z_pend_curr+0x4c>)
   340b6:	490b      	ldr	r1, [pc, #44]	; (340e4 <z_pend_curr+0x50>)
   340b8:	480b      	ldr	r0, [pc, #44]	; (340e8 <z_pend_curr+0x54>)
   340ba:	f003 fe01 	bl	37cc0 <printk>
   340be:	4621      	mov	r1, r4
   340c0:	480a      	ldr	r0, [pc, #40]	; (340ec <z_pend_curr+0x58>)
   340c2:	f003 fdfd 	bl	37cc0 <printk>
   340c6:	2174      	movs	r1, #116	; 0x74
   340c8:	4805      	ldr	r0, [pc, #20]	; (340e0 <z_pend_curr+0x4c>)
   340ca:	f003 fe3f 	bl	37d4c <assert_post_action>
   340ce:	4628      	mov	r0, r5
}
   340d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   340d4:	f7f0 bf62 	b.w	24f9c <arch_swap>
   340d8:	20022108 	.word	0x20022108
   340dc:	2002213c 	.word	0x2002213c
   340e0:	0003ba71 	.word	0x0003ba71
   340e4:	0003bb0b 	.word	0x0003bb0b
   340e8:	0003baac 	.word	0x0003baac
   340ec:	0003bb22 	.word	0x0003bb22

000340f0 <z_set_prio>:
{
   340f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   340f2:	4604      	mov	r4, r0
   340f4:	460d      	mov	r5, r1
	__asm__ volatile(
   340f6:	f04f 0320 	mov.w	r3, #32
   340fa:	f3ef 8611 	mrs	r6, BASEPRI
   340fe:	f383 8811 	msr	BASEPRI, r3
   34102:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   34106:	4835      	ldr	r0, [pc, #212]	; (341dc <z_set_prio+0xec>)
   34108:	f000 fb9e 	bl	34848 <z_spin_lock_valid>
   3410c:	b968      	cbnz	r0, 3412a <z_set_prio+0x3a>
   3410e:	234a      	movs	r3, #74	; 0x4a
   34110:	4a33      	ldr	r2, [pc, #204]	; (341e0 <z_set_prio+0xf0>)
   34112:	4934      	ldr	r1, [pc, #208]	; (341e4 <z_set_prio+0xf4>)
   34114:	4834      	ldr	r0, [pc, #208]	; (341e8 <z_set_prio+0xf8>)
   34116:	f003 fdd3 	bl	37cc0 <printk>
   3411a:	4930      	ldr	r1, [pc, #192]	; (341dc <z_set_prio+0xec>)
   3411c:	4833      	ldr	r0, [pc, #204]	; (341ec <z_set_prio+0xfc>)
   3411e:	f003 fdcf 	bl	37cc0 <printk>
   34122:	214a      	movs	r1, #74	; 0x4a
   34124:	482e      	ldr	r0, [pc, #184]	; (341e0 <z_set_prio+0xf0>)
   34126:	f003 fe11 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   3412a:	482c      	ldr	r0, [pc, #176]	; (341dc <z_set_prio+0xec>)
   3412c:	f000 fbaa 	bl	34884 <z_spin_lock_set_owner>
		need_sched = z_is_thread_ready(thread);
   34130:	4620      	mov	r0, r4
   34132:	f005 fc94 	bl	39a5e <z_is_thread_ready>
		if (need_sched) {
   34136:	b26d      	sxtb	r5, r5
   34138:	4607      	mov	r7, r0
   3413a:	2800      	cmp	r0, #0
   3413c:	d04c      	beq.n	341d8 <z_set_prio+0xe8>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
   3413e:	4621      	mov	r1, r4
   34140:	482b      	ldr	r0, [pc, #172]	; (341f0 <z_set_prio+0x100>)
   34142:	f7ff fab7 	bl	336b4 <z_priq_dumb_remove>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   34146:	4b2b      	ldr	r3, [pc, #172]	; (341f4 <z_set_prio+0x104>)
				thread->base.prio = prio;
   34148:	73a5      	strb	r5, [r4, #14]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   3414a:	429c      	cmp	r4, r3
   3414c:	d10b      	bne.n	34166 <z_set_prio+0x76>
   3414e:	492a      	ldr	r1, [pc, #168]	; (341f8 <z_set_prio+0x108>)
   34150:	4825      	ldr	r0, [pc, #148]	; (341e8 <z_set_prio+0xf8>)
   34152:	f240 3302 	movw	r3, #770	; 0x302
   34156:	4a29      	ldr	r2, [pc, #164]	; (341fc <z_set_prio+0x10c>)
   34158:	f003 fdb2 	bl	37cc0 <printk>
   3415c:	f240 3102 	movw	r1, #770	; 0x302
   34160:	4826      	ldr	r0, [pc, #152]	; (341fc <z_set_prio+0x10c>)
   34162:	f003 fdf3 	bl	37d4c <assert_post_action>
	return list->head == list;
   34166:	4a26      	ldr	r2, [pc, #152]	; (34200 <z_set_prio+0x110>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
   34168:	f102 0128 	add.w	r1, r2, #40	; 0x28
   3416c:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
   34170:	428b      	cmp	r3, r1
   34172:	d02b      	beq.n	341cc <z_set_prio+0xdc>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   34174:	b353      	cbz	r3, 341cc <z_set_prio+0xdc>
	if (thread_1->base.prio < thread_2->base.prio) {
   34176:	f994 500e 	ldrsb.w	r5, [r4, #14]
   3417a:	f993 c00e 	ldrsb.w	ip, [r3, #14]
   3417e:	45ac      	cmp	ip, r5
   34180:	dd1f      	ble.n	341c2 <z_set_prio+0xd2>
	node->prev = successor->prev;
   34182:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   34184:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   34188:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   3418a:	605c      	str	r4, [r3, #4]
			update_cache(1);
   3418c:	2001      	movs	r0, #1
   3418e:	f7ff fb15 	bl	337bc <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   34192:	4812      	ldr	r0, [pc, #72]	; (341dc <z_set_prio+0xec>)
   34194:	f000 fb66 	bl	34864 <z_spin_unlock_valid>
   34198:	b968      	cbnz	r0, 341b6 <z_set_prio+0xc6>
   3419a:	235d      	movs	r3, #93	; 0x5d
   3419c:	4a10      	ldr	r2, [pc, #64]	; (341e0 <z_set_prio+0xf0>)
   3419e:	4919      	ldr	r1, [pc, #100]	; (34204 <z_set_prio+0x114>)
   341a0:	4811      	ldr	r0, [pc, #68]	; (341e8 <z_set_prio+0xf8>)
   341a2:	f003 fd8d 	bl	37cc0 <printk>
   341a6:	490d      	ldr	r1, [pc, #52]	; (341dc <z_set_prio+0xec>)
   341a8:	4817      	ldr	r0, [pc, #92]	; (34208 <z_set_prio+0x118>)
   341aa:	f003 fd89 	bl	37cc0 <printk>
   341ae:	215d      	movs	r1, #93	; 0x5d
   341b0:	480b      	ldr	r0, [pc, #44]	; (341e0 <z_set_prio+0xf0>)
   341b2:	f003 fdcb 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   341b6:	f386 8811 	msr	BASEPRI, r6
   341ba:	f3bf 8f6f 	isb	sy
}
   341be:	4638      	mov	r0, r7
   341c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   341c2:	4298      	cmp	r0, r3
   341c4:	d002      	beq.n	341cc <z_set_prio+0xdc>
   341c6:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   341c8:	2b00      	cmp	r3, #0
   341ca:	d1d6      	bne.n	3417a <z_set_prio+0x8a>
	node->prev = list->tail;
   341cc:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   341d0:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   341d2:	601c      	str	r4, [r3, #0]
	list->tail = node;
   341d4:	62d4      	str	r4, [r2, #44]	; 0x2c
   341d6:	e7d9      	b.n	3418c <z_set_prio+0x9c>
			thread->base.prio = prio;
   341d8:	73a5      	strb	r5, [r4, #14]
   341da:	e7da      	b.n	34192 <z_set_prio+0xa2>
   341dc:	20022140 	.word	0x20022140
   341e0:	0003ba71 	.word	0x0003ba71
   341e4:	0003ba97 	.word	0x0003ba97
   341e8:	0003baac 	.word	0x0003baac
   341ec:	0003bac9 	.word	0x0003bac9
   341f0:	20022130 	.word	0x20022130
   341f4:	20020f64 	.word	0x20020f64
   341f8:	0003f19e 	.word	0x0003f19e
   341fc:	0003f146 	.word	0x0003f146
   34200:	20022108 	.word	0x20022108
   34204:	0003bb0b 	.word	0x0003bb0b
   34208:	0003bb22 	.word	0x0003bb22

0003420c <z_unpend_first_thread>:
{
   3420c:	b538      	push	{r3, r4, r5, lr}
   3420e:	4604      	mov	r4, r0
	__asm__ volatile(
   34210:	f04f 0320 	mov.w	r3, #32
   34214:	f3ef 8511 	mrs	r5, BASEPRI
   34218:	f383 8811 	msr	BASEPRI, r3
   3421c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   34220:	483b      	ldr	r0, [pc, #236]	; (34310 <z_unpend_first_thread+0x104>)
   34222:	f000 fb11 	bl	34848 <z_spin_lock_valid>
   34226:	b968      	cbnz	r0, 34244 <z_unpend_first_thread+0x38>
   34228:	234a      	movs	r3, #74	; 0x4a
   3422a:	4a3a      	ldr	r2, [pc, #232]	; (34314 <z_unpend_first_thread+0x108>)
   3422c:	493a      	ldr	r1, [pc, #232]	; (34318 <z_unpend_first_thread+0x10c>)
   3422e:	483b      	ldr	r0, [pc, #236]	; (3431c <z_unpend_first_thread+0x110>)
   34230:	f003 fd46 	bl	37cc0 <printk>
   34234:	4936      	ldr	r1, [pc, #216]	; (34310 <z_unpend_first_thread+0x104>)
   34236:	483a      	ldr	r0, [pc, #232]	; (34320 <z_unpend_first_thread+0x114>)
   34238:	f003 fd42 	bl	37cc0 <printk>
   3423c:	214a      	movs	r1, #74	; 0x4a
   3423e:	4835      	ldr	r0, [pc, #212]	; (34314 <z_unpend_first_thread+0x108>)
   34240:	f003 fd84 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   34244:	4832      	ldr	r0, [pc, #200]	; (34310 <z_unpend_first_thread+0x104>)
   34246:	f000 fb1d 	bl	34884 <z_spin_lock_set_owner>
		ret = _priq_wait_best(&wait_q->waitq);
   3424a:	4620      	mov	r0, r4
   3424c:	f005 fc2f 	bl	39aae <z_priq_dumb_best>
   34250:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   34252:	482f      	ldr	r0, [pc, #188]	; (34310 <z_unpend_first_thread+0x104>)
   34254:	f000 fb06 	bl	34864 <z_spin_unlock_valid>
   34258:	b968      	cbnz	r0, 34276 <z_unpend_first_thread+0x6a>
   3425a:	235d      	movs	r3, #93	; 0x5d
   3425c:	4a2d      	ldr	r2, [pc, #180]	; (34314 <z_unpend_first_thread+0x108>)
   3425e:	4931      	ldr	r1, [pc, #196]	; (34324 <z_unpend_first_thread+0x118>)
   34260:	482e      	ldr	r0, [pc, #184]	; (3431c <z_unpend_first_thread+0x110>)
   34262:	f003 fd2d 	bl	37cc0 <printk>
   34266:	492a      	ldr	r1, [pc, #168]	; (34310 <z_unpend_first_thread+0x104>)
   34268:	482f      	ldr	r0, [pc, #188]	; (34328 <z_unpend_first_thread+0x11c>)
   3426a:	f003 fd29 	bl	37cc0 <printk>
   3426e:	215d      	movs	r1, #93	; 0x5d
   34270:	4828      	ldr	r0, [pc, #160]	; (34314 <z_unpend_first_thread+0x108>)
   34272:	f003 fd6b 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   34276:	f385 8811 	msr	BASEPRI, r5
   3427a:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   3427e:	2c00      	cmp	r4, #0
   34280:	d043      	beq.n	3430a <z_unpend_first_thread+0xfe>
	__asm__ volatile(
   34282:	f04f 0320 	mov.w	r3, #32
   34286:	f3ef 8511 	mrs	r5, BASEPRI
   3428a:	f383 8811 	msr	BASEPRI, r3
   3428e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   34292:	481f      	ldr	r0, [pc, #124]	; (34310 <z_unpend_first_thread+0x104>)
   34294:	f000 fad8 	bl	34848 <z_spin_lock_valid>
   34298:	b968      	cbnz	r0, 342b6 <z_unpend_first_thread+0xaa>
   3429a:	234a      	movs	r3, #74	; 0x4a
   3429c:	4a1d      	ldr	r2, [pc, #116]	; (34314 <z_unpend_first_thread+0x108>)
   3429e:	491e      	ldr	r1, [pc, #120]	; (34318 <z_unpend_first_thread+0x10c>)
   342a0:	481e      	ldr	r0, [pc, #120]	; (3431c <z_unpend_first_thread+0x110>)
   342a2:	f003 fd0d 	bl	37cc0 <printk>
   342a6:	491a      	ldr	r1, [pc, #104]	; (34310 <z_unpend_first_thread+0x104>)
   342a8:	481d      	ldr	r0, [pc, #116]	; (34320 <z_unpend_first_thread+0x114>)
   342aa:	f003 fd09 	bl	37cc0 <printk>
   342ae:	214a      	movs	r1, #74	; 0x4a
   342b0:	4818      	ldr	r0, [pc, #96]	; (34314 <z_unpend_first_thread+0x108>)
   342b2:	f003 fd4b 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   342b6:	4816      	ldr	r0, [pc, #88]	; (34310 <z_unpend_first_thread+0x104>)
   342b8:	f000 fae4 	bl	34884 <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   342bc:	f104 0008 	add.w	r0, r4, #8
   342c0:	f7ff f81a 	bl	332f8 <pended_on.isra.17>
   342c4:	4621      	mov	r1, r4
   342c6:	f7ff f9f5 	bl	336b4 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   342ca:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   342cc:	4810      	ldr	r0, [pc, #64]	; (34310 <z_unpend_first_thread+0x104>)
   342ce:	f023 0302 	bic.w	r3, r3, #2
   342d2:	7363      	strb	r3, [r4, #13]
   342d4:	f000 fac6 	bl	34864 <z_spin_unlock_valid>
   342d8:	b968      	cbnz	r0, 342f6 <z_unpend_first_thread+0xea>
   342da:	235d      	movs	r3, #93	; 0x5d
   342dc:	4a0d      	ldr	r2, [pc, #52]	; (34314 <z_unpend_first_thread+0x108>)
   342de:	4911      	ldr	r1, [pc, #68]	; (34324 <z_unpend_first_thread+0x118>)
   342e0:	480e      	ldr	r0, [pc, #56]	; (3431c <z_unpend_first_thread+0x110>)
   342e2:	f003 fced 	bl	37cc0 <printk>
   342e6:	490a      	ldr	r1, [pc, #40]	; (34310 <z_unpend_first_thread+0x104>)
   342e8:	480f      	ldr	r0, [pc, #60]	; (34328 <z_unpend_first_thread+0x11c>)
   342ea:	f003 fce9 	bl	37cc0 <printk>
   342ee:	215d      	movs	r1, #93	; 0x5d
   342f0:	4808      	ldr	r0, [pc, #32]	; (34314 <z_unpend_first_thread+0x108>)
   342f2:	f003 fd2b 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   342f6:	f385 8811 	msr	BASEPRI, r5
   342fa:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   342fe:	2300      	movs	r3, #0
	return z_abort_timeout(&thread->base.timeout);
   34300:	f104 0018 	add.w	r0, r4, #24
   34304:	60a3      	str	r3, [r4, #8]
   34306:	f000 fddf 	bl	34ec8 <z_abort_timeout>
}
   3430a:	4620      	mov	r0, r4
   3430c:	bd38      	pop	{r3, r4, r5, pc}
   3430e:	bf00      	nop
   34310:	20022140 	.word	0x20022140
   34314:	0003ba71 	.word	0x0003ba71
   34318:	0003ba97 	.word	0x0003ba97
   3431c:	0003baac 	.word	0x0003baac
   34320:	0003bac9 	.word	0x0003bac9
   34324:	0003bb0b 	.word	0x0003bb0b
   34328:	0003bb22 	.word	0x0003bb22

0003432c <z_sched_init>:
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   3432c:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
   3432e:	4b04      	ldr	r3, [pc, #16]	; (34340 <z_sched_init+0x14>)
   34330:	4608      	mov	r0, r1
   34332:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
   34336:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
   3433a:	f7ff b80b 	b.w	33354 <k_sched_time_slice_set>
   3433e:	bf00      	nop
   34340:	20022108 	.word	0x20022108

00034344 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
   34344:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   34346:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   3434a:	b173      	cbz	r3, 3436a <z_impl_k_yield+0x26>
   3434c:	4945      	ldr	r1, [pc, #276]	; (34464 <z_impl_k_yield+0x120>)
   3434e:	f240 430d 	movw	r3, #1037	; 0x40d
   34352:	4a45      	ldr	r2, [pc, #276]	; (34468 <z_impl_k_yield+0x124>)
   34354:	4845      	ldr	r0, [pc, #276]	; (3446c <z_impl_k_yield+0x128>)
   34356:	f003 fcb3 	bl	37cc0 <printk>
   3435a:	4845      	ldr	r0, [pc, #276]	; (34470 <z_impl_k_yield+0x12c>)
   3435c:	f003 fcb0 	bl	37cc0 <printk>
   34360:	f240 410d 	movw	r1, #1037	; 0x40d
   34364:	4840      	ldr	r0, [pc, #256]	; (34468 <z_impl_k_yield+0x124>)
   34366:	f003 fcf1 	bl	37d4c <assert_post_action>

	if (!z_is_idle_thread_object(_current)) {
   3436a:	4c42      	ldr	r4, [pc, #264]	; (34474 <z_impl_k_yield+0x130>)
   3436c:	4e42      	ldr	r6, [pc, #264]	; (34478 <z_impl_k_yield+0x134>)
   3436e:	68a2      	ldr	r2, [r4, #8]
   34370:	42b2      	cmp	r2, r6
   34372:	d05f      	beq.n	34434 <z_impl_k_yield+0xf0>
	__asm__ volatile(
   34374:	f04f 0320 	mov.w	r3, #32
   34378:	f3ef 8711 	mrs	r7, BASEPRI
   3437c:	f383 8811 	msr	BASEPRI, r3
   34380:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   34384:	483d      	ldr	r0, [pc, #244]	; (3447c <z_impl_k_yield+0x138>)
   34386:	f000 fa5f 	bl	34848 <z_spin_lock_valid>
   3438a:	b968      	cbnz	r0, 343a8 <z_impl_k_yield+0x64>
   3438c:	234a      	movs	r3, #74	; 0x4a
   3438e:	4a3c      	ldr	r2, [pc, #240]	; (34480 <z_impl_k_yield+0x13c>)
   34390:	493c      	ldr	r1, [pc, #240]	; (34484 <z_impl_k_yield+0x140>)
   34392:	4836      	ldr	r0, [pc, #216]	; (3446c <z_impl_k_yield+0x128>)
   34394:	f003 fc94 	bl	37cc0 <printk>
   34398:	4938      	ldr	r1, [pc, #224]	; (3447c <z_impl_k_yield+0x138>)
   3439a:	483b      	ldr	r0, [pc, #236]	; (34488 <z_impl_k_yield+0x144>)
   3439c:	f003 fc90 	bl	37cc0 <printk>
   343a0:	214a      	movs	r1, #74	; 0x4a
   343a2:	4837      	ldr	r0, [pc, #220]	; (34480 <z_impl_k_yield+0x13c>)
   343a4:	f003 fcd2 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   343a8:	4834      	ldr	r0, [pc, #208]	; (3447c <z_impl_k_yield+0x138>)
   343aa:	f000 fa6b 	bl	34884 <z_spin_lock_set_owner>
		LOCKED(&sched_spinlock) {
			if (!IS_ENABLED(CONFIG_SMP) ||
			    z_is_thread_queued(_current)) {
				_priq_run_remove(&_kernel.ready_q.runq,
   343ae:	68a1      	ldr	r1, [r4, #8]
   343b0:	4836      	ldr	r0, [pc, #216]	; (3448c <z_impl_k_yield+0x148>)
   343b2:	f7ff f97f 	bl	336b4 <z_priq_dumb_remove>
						 _current);
			}
			_priq_run_add(&_kernel.ready_q.runq, _current);
   343b6:	68a5      	ldr	r5, [r4, #8]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   343b8:	42b5      	cmp	r5, r6
   343ba:	d10b      	bne.n	343d4 <z_impl_k_yield+0x90>
   343bc:	4934      	ldr	r1, [pc, #208]	; (34490 <z_impl_k_yield+0x14c>)
   343be:	482b      	ldr	r0, [pc, #172]	; (3446c <z_impl_k_yield+0x128>)
   343c0:	f240 3302 	movw	r3, #770	; 0x302
   343c4:	4a28      	ldr	r2, [pc, #160]	; (34468 <z_impl_k_yield+0x124>)
   343c6:	f003 fc7b 	bl	37cc0 <printk>
   343ca:	f240 3102 	movw	r1, #770	; 0x302
   343ce:	4826      	ldr	r0, [pc, #152]	; (34468 <z_impl_k_yield+0x124>)
   343d0:	f003 fcbc 	bl	37d4c <assert_post_action>
	return list->head == list;
   343d4:	e9d4 310a 	ldrd	r3, r1, [r4, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
   343d8:	4a2c      	ldr	r2, [pc, #176]	; (3448c <z_impl_k_yield+0x148>)
   343da:	4293      	cmp	r3, r2
   343dc:	d03b      	beq.n	34456 <z_impl_k_yield+0x112>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   343de:	2b00      	cmp	r3, #0
   343e0:	d039      	beq.n	34456 <z_impl_k_yield+0x112>
	if (thread_1->base.prio < thread_2->base.prio) {
   343e2:	f995 000e 	ldrsb.w	r0, [r5, #14]
   343e6:	f993 600e 	ldrsb.w	r6, [r3, #14]
   343ea:	4286      	cmp	r6, r0
   343ec:	dd2e      	ble.n	3444c <z_impl_k_yield+0x108>
	node->prev = successor->prev;
   343ee:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   343f0:	e9c5 3200 	strd	r3, r2, [r5]
	successor->prev->next = node;
   343f4:	6015      	str	r5, [r2, #0]
	successor->prev = node;
   343f6:	605d      	str	r5, [r3, #4]
			z_mark_thread_as_queued(_current);
   343f8:	68a2      	ldr	r2, [r4, #8]
			update_cache(1);
   343fa:	2001      	movs	r0, #1
	thread->base.thread_state |= states;
   343fc:	7b53      	ldrb	r3, [r2, #13]
   343fe:	f063 037f 	orn	r3, r3, #127	; 0x7f
   34402:	7353      	strb	r3, [r2, #13]
   34404:	f7ff f9da 	bl	337bc <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   34408:	481c      	ldr	r0, [pc, #112]	; (3447c <z_impl_k_yield+0x138>)
   3440a:	f000 fa2b 	bl	34864 <z_spin_unlock_valid>
   3440e:	b968      	cbnz	r0, 3442c <z_impl_k_yield+0xe8>
   34410:	235d      	movs	r3, #93	; 0x5d
   34412:	4a1b      	ldr	r2, [pc, #108]	; (34480 <z_impl_k_yield+0x13c>)
   34414:	491f      	ldr	r1, [pc, #124]	; (34494 <z_impl_k_yield+0x150>)
   34416:	4815      	ldr	r0, [pc, #84]	; (3446c <z_impl_k_yield+0x128>)
   34418:	f003 fc52 	bl	37cc0 <printk>
   3441c:	4917      	ldr	r1, [pc, #92]	; (3447c <z_impl_k_yield+0x138>)
   3441e:	481e      	ldr	r0, [pc, #120]	; (34498 <z_impl_k_yield+0x154>)
   34420:	f003 fc4e 	bl	37cc0 <printk>
   34424:	215d      	movs	r1, #93	; 0x5d
   34426:	4816      	ldr	r0, [pc, #88]	; (34480 <z_impl_k_yield+0x13c>)
   34428:	f003 fc90 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   3442c:	f387 8811 	msr	BASEPRI, r7
   34430:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   34434:	f04f 0320 	mov.w	r3, #32
   34438:	f3ef 8011 	mrs	r0, BASEPRI
   3443c:	f383 8811 	msr	BASEPRI, r3
   34440:	f3bf 8f6f 	isb	sy
		}
	}
	z_swap_unlocked();
}
   34444:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   34448:	f7f0 bda8 	b.w	24f9c <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   3444c:	4299      	cmp	r1, r3
   3444e:	d002      	beq.n	34456 <z_impl_k_yield+0x112>
   34450:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   34452:	2b00      	cmp	r3, #0
   34454:	d1c7      	bne.n	343e6 <z_impl_k_yield+0xa2>
	node->prev = list->tail;
   34456:	e9c5 2100 	strd	r2, r1, [r5]
	list->tail->next = node;
   3445a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   3445c:	601d      	str	r5, [r3, #0]
	list->tail = node;
   3445e:	62e5      	str	r5, [r4, #44]	; 0x2c
   34460:	e7ca      	b.n	343f8 <z_impl_k_yield+0xb4>
   34462:	bf00      	nop
   34464:	0003f0ae 	.word	0x0003f0ae
   34468:	0003f146 	.word	0x0003f146
   3446c:	0003baac 	.word	0x0003baac
   34470:	0003da1b 	.word	0x0003da1b
   34474:	20022108 	.word	0x20022108
   34478:	20020f64 	.word	0x20020f64
   3447c:	20022140 	.word	0x20022140
   34480:	0003ba71 	.word	0x0003ba71
   34484:	0003ba97 	.word	0x0003ba97
   34488:	0003bac9 	.word	0x0003bac9
   3448c:	20022130 	.word	0x20022130
   34490:	0003f19e 	.word	0x0003f19e
   34494:	0003bb0b 	.word	0x0003bb0b
   34498:	0003bb22 	.word	0x0003bb22

0003449c <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static s32_t z_tick_sleep(s32_t ticks)
{
   3449c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   3449e:	4604      	mov	r4, r0
   344a0:	f3ef 8305 	mrs	r3, IPSR
#ifdef CONFIG_MULTITHREADING
	u32_t expected_wakeup_time;

	__ASSERT(!arch_is_in_isr(), "");
   344a4:	b173      	cbz	r3, 344c4 <z_tick_sleep+0x28>
   344a6:	493b      	ldr	r1, [pc, #236]	; (34594 <z_tick_sleep+0xf8>)
   344a8:	f240 432b 	movw	r3, #1067	; 0x42b
   344ac:	4a3a      	ldr	r2, [pc, #232]	; (34598 <z_tick_sleep+0xfc>)
   344ae:	483b      	ldr	r0, [pc, #236]	; (3459c <z_tick_sleep+0x100>)
   344b0:	f003 fc06 	bl	37cc0 <printk>
   344b4:	483a      	ldr	r0, [pc, #232]	; (345a0 <z_tick_sleep+0x104>)
   344b6:	f003 fc03 	bl	37cc0 <printk>
   344ba:	f240 412b 	movw	r1, #1067	; 0x42b
   344be:	4836      	ldr	r0, [pc, #216]	; (34598 <z_tick_sleep+0xfc>)
   344c0:	f003 fc44 	bl	37d4c <assert_post_action>

	K_DEBUG("thread %p for %d ticks\n", _current, ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   344c4:	b924      	cbnz	r4, 344d0 <z_tick_sleep+0x34>
	z_impl_k_yield();
   344c6:	f7ff ff3d 	bl	34344 <z_impl_k_yield>
		return ticks;
	}
#endif

	return 0;
}
   344ca:	4620      	mov	r0, r4
   344cc:	b003      	add	sp, #12
   344ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
	expected_wakeup_time = ticks + z_tick_get_32();
   344d0:	f005 fb98 	bl	39c04 <z_tick_get_32>
	struct k_spinlock local_lock = {};
   344d4:	2300      	movs	r3, #0
	ticks += _TICK_ALIGN;
   344d6:	1c66      	adds	r6, r4, #1
	expected_wakeup_time = ticks + z_tick_get_32();
   344d8:	1834      	adds	r4, r6, r0
	struct k_spinlock local_lock = {};
   344da:	9301      	str	r3, [sp, #4]
   344dc:	f04f 0320 	mov.w	r3, #32
   344e0:	f3ef 8711 	mrs	r7, BASEPRI
   344e4:	f383 8811 	msr	BASEPRI, r3
   344e8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   344ec:	a801      	add	r0, sp, #4
   344ee:	f000 f9ab 	bl	34848 <z_spin_lock_valid>
   344f2:	b968      	cbnz	r0, 34510 <z_tick_sleep+0x74>
   344f4:	234a      	movs	r3, #74	; 0x4a
   344f6:	4a2b      	ldr	r2, [pc, #172]	; (345a4 <z_tick_sleep+0x108>)
   344f8:	492b      	ldr	r1, [pc, #172]	; (345a8 <z_tick_sleep+0x10c>)
   344fa:	4828      	ldr	r0, [pc, #160]	; (3459c <z_tick_sleep+0x100>)
   344fc:	f003 fbe0 	bl	37cc0 <printk>
   34500:	a901      	add	r1, sp, #4
   34502:	482a      	ldr	r0, [pc, #168]	; (345ac <z_tick_sleep+0x110>)
   34504:	f003 fbdc 	bl	37cc0 <printk>
   34508:	214a      	movs	r1, #74	; 0x4a
   3450a:	4826      	ldr	r0, [pc, #152]	; (345a4 <z_tick_sleep+0x108>)
   3450c:	f003 fc1e 	bl	37d4c <assert_post_action>
	pending_current = _current;
   34510:	4d27      	ldr	r5, [pc, #156]	; (345b0 <z_tick_sleep+0x114>)
	z_spin_lock_set_owner(l);
   34512:	a801      	add	r0, sp, #4
   34514:	f000 f9b6 	bl	34884 <z_spin_lock_set_owner>
   34518:	4b26      	ldr	r3, [pc, #152]	; (345b4 <z_tick_sleep+0x118>)
   3451a:	68a8      	ldr	r0, [r5, #8]
   3451c:	6018      	str	r0, [r3, #0]
	z_remove_thread_from_ready_q(_current);
   3451e:	f7ff fc93 	bl	33e48 <z_remove_thread_from_ready_q>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   34522:	68a8      	ldr	r0, [r5, #8]
   34524:	4632      	mov	r2, r6
   34526:	3018      	adds	r0, #24
   34528:	4923      	ldr	r1, [pc, #140]	; (345b8 <z_tick_sleep+0x11c>)
   3452a:	f000 fc27 	bl	34d7c <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   3452e:	68aa      	ldr	r2, [r5, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   34530:	a801      	add	r0, sp, #4
	thread->base.thread_state |= _THREAD_SUSPENDED;
   34532:	7b53      	ldrb	r3, [r2, #13]
   34534:	f043 0310 	orr.w	r3, r3, #16
   34538:	7353      	strb	r3, [r2, #13]
   3453a:	f000 f993 	bl	34864 <z_spin_unlock_valid>
   3453e:	b968      	cbnz	r0, 3455c <z_tick_sleep+0xc0>
   34540:	2374      	movs	r3, #116	; 0x74
   34542:	4a18      	ldr	r2, [pc, #96]	; (345a4 <z_tick_sleep+0x108>)
   34544:	491d      	ldr	r1, [pc, #116]	; (345bc <z_tick_sleep+0x120>)
   34546:	4815      	ldr	r0, [pc, #84]	; (3459c <z_tick_sleep+0x100>)
   34548:	f003 fbba 	bl	37cc0 <printk>
   3454c:	a901      	add	r1, sp, #4
   3454e:	481c      	ldr	r0, [pc, #112]	; (345c0 <z_tick_sleep+0x124>)
   34550:	f003 fbb6 	bl	37cc0 <printk>
   34554:	2174      	movs	r1, #116	; 0x74
   34556:	4813      	ldr	r0, [pc, #76]	; (345a4 <z_tick_sleep+0x108>)
   34558:	f003 fbf8 	bl	37d4c <assert_post_action>
   3455c:	4638      	mov	r0, r7
   3455e:	f7f0 fd1d 	bl	24f9c <arch_swap>
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
   34562:	68ab      	ldr	r3, [r5, #8]
   34564:	7b5b      	ldrb	r3, [r3, #13]
   34566:	06db      	lsls	r3, r3, #27
   34568:	d50e      	bpl.n	34588 <z_tick_sleep+0xec>
   3456a:	4916      	ldr	r1, [pc, #88]	; (345c4 <z_tick_sleep+0x128>)
   3456c:	f44f 6389 	mov.w	r3, #1096	; 0x448
   34570:	4a09      	ldr	r2, [pc, #36]	; (34598 <z_tick_sleep+0xfc>)
   34572:	480a      	ldr	r0, [pc, #40]	; (3459c <z_tick_sleep+0x100>)
   34574:	f003 fba4 	bl	37cc0 <printk>
   34578:	4809      	ldr	r0, [pc, #36]	; (345a0 <z_tick_sleep+0x104>)
   3457a:	f003 fba1 	bl	37cc0 <printk>
   3457e:	f44f 6189 	mov.w	r1, #1096	; 0x448
   34582:	4805      	ldr	r0, [pc, #20]	; (34598 <z_tick_sleep+0xfc>)
   34584:	f003 fbe2 	bl	37d4c <assert_post_action>
	ticks = expected_wakeup_time - z_tick_get_32();
   34588:	f005 fb3c 	bl	39c04 <z_tick_get_32>
   3458c:	1a24      	subs	r4, r4, r0
   3458e:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
   34592:	e79a      	b.n	344ca <z_tick_sleep+0x2e>
   34594:	0003f0ae 	.word	0x0003f0ae
   34598:	0003f146 	.word	0x0003f146
   3459c:	0003baac 	.word	0x0003baac
   345a0:	0003da1b 	.word	0x0003da1b
   345a4:	0003ba71 	.word	0x0003ba71
   345a8:	0003ba97 	.word	0x0003ba97
   345ac:	0003bac9 	.word	0x0003bac9
   345b0:	20022108 	.word	0x20022108
   345b4:	2002213c 	.word	0x2002213c
   345b8:	00033a21 	.word	0x00033a21
   345bc:	0003bb0b 	.word	0x0003bb0b
   345c0:	0003bb22 	.word	0x0003bb22
   345c4:	0003f1bf 	.word	0x0003f1bf

000345c8 <z_impl_k_sleep>:

s32_t z_impl_k_sleep(int ms)
{
   345c8:	b538      	push	{r3, r4, r5, lr}
   345ca:	4604      	mov	r4, r0
   345cc:	f3ef 8305 	mrs	r3, IPSR
	s32_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
   345d0:	b173      	cbz	r3, 345f0 <z_impl_k_sleep+0x28>
   345d2:	4916      	ldr	r1, [pc, #88]	; (3462c <z_impl_k_sleep+0x64>)
   345d4:	f240 4357 	movw	r3, #1111	; 0x457
   345d8:	4a15      	ldr	r2, [pc, #84]	; (34630 <z_impl_k_sleep+0x68>)
   345da:	4816      	ldr	r0, [pc, #88]	; (34634 <z_impl_k_sleep+0x6c>)
   345dc:	f003 fb70 	bl	37cc0 <printk>
   345e0:	4815      	ldr	r0, [pc, #84]	; (34638 <z_impl_k_sleep+0x70>)
   345e2:	f003 fb6d 	bl	37cc0 <printk>
   345e6:	f240 4157 	movw	r1, #1111	; 0x457
   345ea:	4811      	ldr	r0, [pc, #68]	; (34630 <z_impl_k_sleep+0x68>)
   345ec:	f003 fbae 	bl	37d4c <assert_post_action>

	if (ms == K_FOREVER) {
   345f0:	1c63      	adds	r3, r4, #1
   345f2:	d105      	bne.n	34600 <z_impl_k_sleep+0x38>
		k_thread_suspend(_current);
   345f4:	4b11      	ldr	r3, [pc, #68]	; (3463c <z_impl_k_sleep+0x74>)
   345f6:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   345f8:	f000 fa82 	bl	34b00 <z_impl_k_thread_suspend>
	}

	ticks = k_ms_to_ticks_ceil32(ms);
	ticks = z_tick_sleep(ticks);
	return k_ticks_to_ms_floor64(ticks);
}
   345fc:	4620      	mov	r0, r4
   345fe:	bd38      	pop	{r3, r4, r5, pc}
   34600:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   34604:	f240 30e7 	movw	r0, #999	; 0x3e7
   34608:	2100      	movs	r1, #0
   3460a:	2300      	movs	r3, #0
   3460c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   34610:	fbe5 0104 	umlal	r0, r1, r5, r4
   34614:	f7e8 fbda 	bl	1cdcc <__aeabi_uldivmod>
	ticks = z_tick_sleep(ticks);
   34618:	f7ff ff40 	bl	3449c <z_tick_sleep>
			return (t * to_hz + off) / from_hz;
   3461c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   34620:	fb80 0103 	smull	r0, r1, r0, r3
   34624:	0bc4      	lsrs	r4, r0, #15
   34626:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
	return k_ticks_to_ms_floor64(ticks);
   3462a:	e7e7      	b.n	345fc <z_impl_k_sleep+0x34>
   3462c:	0003f0ae 	.word	0x0003f0ae
   34630:	0003f146 	.word	0x0003f146
   34634:	0003baac 	.word	0x0003baac
   34638:	0003da1b 	.word	0x0003da1b
   3463c:	20022108 	.word	0x20022108

00034640 <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
   34640:	4b01      	ldr	r3, [pc, #4]	; (34648 <z_impl_k_current_get+0x8>)
   34642:	6898      	ldr	r0, [r3, #8]
   34644:	4770      	bx	lr
   34646:	bf00      	nop
   34648:	20022108 	.word	0x20022108

0003464c <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   3464c:	b570      	push	{r4, r5, r6, lr}
   3464e:	4604      	mov	r4, r0
   34650:	f04f 0320 	mov.w	r3, #32
   34654:	f3ef 8611 	mrs	r6, BASEPRI
   34658:	f383 8811 	msr	BASEPRI, r3
   3465c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   34660:	481a      	ldr	r0, [pc, #104]	; (346cc <z_impl_k_sem_give+0x80>)
   34662:	f000 f8f1 	bl	34848 <z_spin_lock_valid>
   34666:	b968      	cbnz	r0, 34684 <z_impl_k_sem_give+0x38>
   34668:	234a      	movs	r3, #74	; 0x4a
   3466a:	4a19      	ldr	r2, [pc, #100]	; (346d0 <z_impl_k_sem_give+0x84>)
   3466c:	4919      	ldr	r1, [pc, #100]	; (346d4 <z_impl_k_sem_give+0x88>)
   3466e:	481a      	ldr	r0, [pc, #104]	; (346d8 <z_impl_k_sem_give+0x8c>)
   34670:	f003 fb26 	bl	37cc0 <printk>
   34674:	4915      	ldr	r1, [pc, #84]	; (346cc <z_impl_k_sem_give+0x80>)
   34676:	4819      	ldr	r0, [pc, #100]	; (346dc <z_impl_k_sem_give+0x90>)
   34678:	f003 fb22 	bl	37cc0 <printk>
   3467c:	214a      	movs	r1, #74	; 0x4a
   3467e:	4814      	ldr	r0, [pc, #80]	; (346d0 <z_impl_k_sem_give+0x84>)
   34680:	f003 fb64 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   34684:	4811      	ldr	r0, [pc, #68]	; (346cc <z_impl_k_sem_give+0x80>)
   34686:	f000 f8fd 	bl	34884 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
   3468a:	4620      	mov	r0, r4
   3468c:	f7ff fdbe 	bl	3420c <z_unpend_first_thread>

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);

	if (thread != NULL) {
   34690:	4605      	mov	r5, r0
   34692:	b170      	cbz	r0, 346b2 <z_impl_k_sem_give+0x66>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   34694:	7b43      	ldrb	r3, [r0, #13]
   34696:	06db      	lsls	r3, r3, #27
   34698:	d103      	bne.n	346a2 <z_impl_k_sem_give+0x56>
	if (z_is_thread_ready(thread)) {
   3469a:	6983      	ldr	r3, [r0, #24]
   3469c:	b90b      	cbnz	r3, 346a2 <z_impl_k_sem_give+0x56>
		z_add_thread_to_ready_q(thread);
   3469e:	f7ff f93f 	bl	33920 <z_add_thread_to_ready_q>
   346a2:	2300      	movs	r3, #0
   346a4:	66ab      	str	r3, [r5, #104]	; 0x68
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
   346a6:	4631      	mov	r1, r6
}
   346a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&lock, key);
   346ac:	4807      	ldr	r0, [pc, #28]	; (346cc <z_impl_k_sem_give+0x80>)
   346ae:	f7fe bf4d 	b.w	3354c <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   346b2:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   346b6:	429a      	cmp	r2, r3
   346b8:	bf18      	it	ne
   346ba:	3301      	addne	r3, #1
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   346bc:	2102      	movs	r1, #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   346be:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   346c0:	f104 0010 	add.w	r0, r4, #16
   346c4:	f005 fb2c 	bl	39d20 <z_handle_obj_poll_events>
   346c8:	e7ed      	b.n	346a6 <z_impl_k_sem_give+0x5a>
   346ca:	bf00      	nop
   346cc:	2002214c 	.word	0x2002214c
   346d0:	0003ba71 	.word	0x0003ba71
   346d4:	0003ba97 	.word	0x0003ba97
   346d8:	0003baac 	.word	0x0003baac
   346dc:	0003bac9 	.word	0x0003bac9

000346e0 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, s32_t timeout)
{
   346e0:	b570      	push	{r4, r5, r6, lr}
   346e2:	4605      	mov	r5, r0
   346e4:	460e      	mov	r6, r1
   346e6:	f3ef 8305 	mrs	r3, IPSR
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");
   346ea:	b16b      	cbz	r3, 34708 <z_impl_k_sem_take+0x28>
   346ec:	b161      	cbz	r1, 34708 <z_impl_k_sem_take+0x28>
   346ee:	4934      	ldr	r1, [pc, #208]	; (347c0 <z_impl_k_sem_take+0xe0>)
   346f0:	238c      	movs	r3, #140	; 0x8c
   346f2:	4a34      	ldr	r2, [pc, #208]	; (347c4 <z_impl_k_sem_take+0xe4>)
   346f4:	4834      	ldr	r0, [pc, #208]	; (347c8 <z_impl_k_sem_take+0xe8>)
   346f6:	f003 fae3 	bl	37cc0 <printk>
   346fa:	4834      	ldr	r0, [pc, #208]	; (347cc <z_impl_k_sem_take+0xec>)
   346fc:	f003 fae0 	bl	37cc0 <printk>
   34700:	218c      	movs	r1, #140	; 0x8c
   34702:	4830      	ldr	r0, [pc, #192]	; (347c4 <z_impl_k_sem_take+0xe4>)
   34704:	f003 fb22 	bl	37d4c <assert_post_action>
   34708:	f04f 0320 	mov.w	r3, #32
   3470c:	f3ef 8411 	mrs	r4, BASEPRI
   34710:	f383 8811 	msr	BASEPRI, r3
   34714:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   34718:	482d      	ldr	r0, [pc, #180]	; (347d0 <z_impl_k_sem_take+0xf0>)
   3471a:	f000 f895 	bl	34848 <z_spin_lock_valid>
   3471e:	b968      	cbnz	r0, 3473c <z_impl_k_sem_take+0x5c>
   34720:	234a      	movs	r3, #74	; 0x4a
   34722:	4a2c      	ldr	r2, [pc, #176]	; (347d4 <z_impl_k_sem_take+0xf4>)
   34724:	492c      	ldr	r1, [pc, #176]	; (347d8 <z_impl_k_sem_take+0xf8>)
   34726:	4828      	ldr	r0, [pc, #160]	; (347c8 <z_impl_k_sem_take+0xe8>)
   34728:	f003 faca 	bl	37cc0 <printk>
   3472c:	4928      	ldr	r1, [pc, #160]	; (347d0 <z_impl_k_sem_take+0xf0>)
   3472e:	482b      	ldr	r0, [pc, #172]	; (347dc <z_impl_k_sem_take+0xfc>)
   34730:	f003 fac6 	bl	37cc0 <printk>
   34734:	214a      	movs	r1, #74	; 0x4a
   34736:	4827      	ldr	r0, [pc, #156]	; (347d4 <z_impl_k_sem_take+0xf4>)
   34738:	f003 fb08 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   3473c:	4824      	ldr	r0, [pc, #144]	; (347d0 <z_impl_k_sem_take+0xf0>)
   3473e:	f000 f8a1 	bl	34884 <z_spin_lock_set_owner>

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
   34742:	68ab      	ldr	r3, [r5, #8]
   34744:	b1cb      	cbz	r3, 3477a <z_impl_k_sem_take+0x9a>
		sem->count--;
   34746:	3b01      	subs	r3, #1
   34748:	60ab      	str	r3, [r5, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   3474a:	4821      	ldr	r0, [pc, #132]	; (347d0 <z_impl_k_sem_take+0xf0>)
   3474c:	f000 f88a 	bl	34864 <z_spin_unlock_valid>
   34750:	b968      	cbnz	r0, 3476e <z_impl_k_sem_take+0x8e>
   34752:	235d      	movs	r3, #93	; 0x5d
   34754:	4a1f      	ldr	r2, [pc, #124]	; (347d4 <z_impl_k_sem_take+0xf4>)
   34756:	4922      	ldr	r1, [pc, #136]	; (347e0 <z_impl_k_sem_take+0x100>)
   34758:	481b      	ldr	r0, [pc, #108]	; (347c8 <z_impl_k_sem_take+0xe8>)
   3475a:	f003 fab1 	bl	37cc0 <printk>
   3475e:	491c      	ldr	r1, [pc, #112]	; (347d0 <z_impl_k_sem_take+0xf0>)
   34760:	4820      	ldr	r0, [pc, #128]	; (347e4 <z_impl_k_sem_take+0x104>)
   34762:	f003 faad 	bl	37cc0 <printk>
   34766:	215d      	movs	r1, #93	; 0x5d
   34768:	481a      	ldr	r0, [pc, #104]	; (347d4 <z_impl_k_sem_take+0xf4>)
   3476a:	f003 faef 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   3476e:	f384 8811 	msr	BASEPRI, r4
   34772:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   34776:	2000      	movs	r0, #0
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
   34778:	bd70      	pop	{r4, r5, r6, pc}
	if (timeout == K_NO_WAIT) {
   3477a:	b9c6      	cbnz	r6, 347ae <z_impl_k_sem_take+0xce>
   3477c:	4814      	ldr	r0, [pc, #80]	; (347d0 <z_impl_k_sem_take+0xf0>)
   3477e:	f000 f871 	bl	34864 <z_spin_unlock_valid>
   34782:	b968      	cbnz	r0, 347a0 <z_impl_k_sem_take+0xc0>
   34784:	235d      	movs	r3, #93	; 0x5d
   34786:	4a13      	ldr	r2, [pc, #76]	; (347d4 <z_impl_k_sem_take+0xf4>)
   34788:	4915      	ldr	r1, [pc, #84]	; (347e0 <z_impl_k_sem_take+0x100>)
   3478a:	480f      	ldr	r0, [pc, #60]	; (347c8 <z_impl_k_sem_take+0xe8>)
   3478c:	f003 fa98 	bl	37cc0 <printk>
   34790:	490f      	ldr	r1, [pc, #60]	; (347d0 <z_impl_k_sem_take+0xf0>)
   34792:	4814      	ldr	r0, [pc, #80]	; (347e4 <z_impl_k_sem_take+0x104>)
   34794:	f003 fa94 	bl	37cc0 <printk>
   34798:	215d      	movs	r1, #93	; 0x5d
   3479a:	480e      	ldr	r0, [pc, #56]	; (347d4 <z_impl_k_sem_take+0xf4>)
   3479c:	f003 fad6 	bl	37d4c <assert_post_action>
   347a0:	f384 8811 	msr	BASEPRI, r4
   347a4:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   347a8:	f06f 000f 	mvn.w	r0, #15
		goto out;
   347ac:	e7e4      	b.n	34778 <z_impl_k_sem_take+0x98>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   347ae:	4633      	mov	r3, r6
   347b0:	462a      	mov	r2, r5
   347b2:	4621      	mov	r1, r4
}
   347b4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   347b8:	4805      	ldr	r0, [pc, #20]	; (347d0 <z_impl_k_sem_take+0xf0>)
   347ba:	f7ff bc6b 	b.w	34094 <z_pend_curr>
   347be:	bf00      	nop
   347c0:	0003f217 	.word	0x0003f217
   347c4:	0003f1f7 	.word	0x0003f1f7
   347c8:	0003baac 	.word	0x0003baac
   347cc:	0003da1b 	.word	0x0003da1b
   347d0:	2002214c 	.word	0x2002214c
   347d4:	0003ba71 	.word	0x0003ba71
   347d8:	0003ba97 	.word	0x0003ba97
   347dc:	0003bac9 	.word	0x0003bac9
   347e0:	0003bb0b 	.word	0x0003bb0b
   347e4:	0003bb22 	.word	0x0003bb22

000347e8 <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
   347e8:	b510      	push	{r4, lr}
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
   347ea:	4c08      	ldr	r4, [pc, #32]	; (3480c <k_sys_work_q_init+0x24>)
   347ec:	f04f 33ff 	mov.w	r3, #4294967295
   347f0:	f44f 6200 	mov.w	r2, #2048	; 0x800
   347f4:	4906      	ldr	r1, [pc, #24]	; (34810 <k_sys_work_q_init+0x28>)
   347f6:	4620      	mov	r0, r4
   347f8:	f000 f9d6 	bl	34ba8 <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
   347fc:	4905      	ldr	r1, [pc, #20]	; (34814 <k_sys_work_q_init+0x2c>)
   347fe:	f104 0014 	add.w	r0, r4, #20
   34802:	f005 f988 	bl	39b16 <z_impl_k_thread_name_set>
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
   34806:	2000      	movs	r0, #0
   34808:	bd10      	pop	{r4, pc}
   3480a:	bf00      	nop
   3480c:	20022150 	.word	0x20022150
   34810:	200291e0 	.word	0x200291e0
   34814:	0003f243 	.word	0x0003f243

00034818 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
   34818:	b530      	push	{r4, r5, lr}
   3481a:	b087      	sub	sp, #28
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   3481c:	9d0e      	ldr	r5, [sp, #56]	; 0x38
{
   3481e:	4604      	mov	r4, r0
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   34820:	9504      	str	r5, [sp, #16]
   34822:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   34824:	9503      	str	r5, [sp, #12]
   34826:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   34828:	9502      	str	r5, [sp, #8]
   3482a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   3482c:	9501      	str	r5, [sp, #4]
   3482e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   34830:	9500      	str	r5, [sp, #0]
   34832:	f7f0 fc1d 	bl	25070 <arch_new_thread>
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
   34836:	4b03      	ldr	r3, [pc, #12]	; (34844 <z_setup_new_thread+0x2c>)
   34838:	689b      	ldr	r3, [r3, #8]
   3483a:	b103      	cbz	r3, 3483e <z_setup_new_thread+0x26>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
   3483c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
   3483e:	6623      	str	r3, [r4, #96]	; 0x60
	sys_trace_thread_create(new_thread);
}
   34840:	b007      	add	sp, #28
   34842:	bd30      	pop	{r4, r5, pc}
   34844:	20022108 	.word	0x20022108

00034848 <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
   34848:	6800      	ldr	r0, [r0, #0]

	if (thread_cpu) {
   3484a:	b138      	cbz	r0, 3485c <z_spin_lock_valid+0x14>
		if ((thread_cpu & 3) == _current_cpu->id) {
   3484c:	4b04      	ldr	r3, [pc, #16]	; (34860 <z_spin_lock_valid+0x18>)
   3484e:	f000 0003 	and.w	r0, r0, #3
   34852:	7d1b      	ldrb	r3, [r3, #20]
   34854:	1ac0      	subs	r0, r0, r3
   34856:	bf18      	it	ne
   34858:	2001      	movne	r0, #1
   3485a:	4770      	bx	lr
			return false;
		}
	}
	return true;
   3485c:	2001      	movs	r0, #1
}
   3485e:	4770      	bx	lr
   34860:	20022108 	.word	0x20022108

00034864 <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
   34864:	4a06      	ldr	r2, [pc, #24]	; (34880 <z_spin_unlock_valid+0x1c>)
   34866:	7d11      	ldrb	r1, [r2, #20]
   34868:	6893      	ldr	r3, [r2, #8]
   3486a:	6802      	ldr	r2, [r0, #0]
   3486c:	430b      	orrs	r3, r1
   3486e:	429a      	cmp	r2, r3
   34870:	f04f 0300 	mov.w	r3, #0
		return false;
	}
	l->thread_cpu = 0;
   34874:	bf06      	itte	eq
   34876:	6003      	streq	r3, [r0, #0]
	return true;
   34878:	2001      	moveq	r0, #1
		return false;
   3487a:	4618      	movne	r0, r3
}
   3487c:	4770      	bx	lr
   3487e:	bf00      	nop
   34880:	20022108 	.word	0x20022108

00034884 <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
   34884:	4a02      	ldr	r2, [pc, #8]	; (34890 <z_spin_lock_set_owner+0xc>)
   34886:	7d11      	ldrb	r1, [r2, #20]
   34888:	6893      	ldr	r3, [r2, #8]
   3488a:	430b      	orrs	r3, r1
   3488c:	6003      	str	r3, [r0, #0]
}
   3488e:	4770      	bx	lr
   34890:	20022108 	.word	0x20022108

00034894 <z_impl_k_thread_start>:
{
   34894:	b538      	push	{r3, r4, r5, lr}
   34896:	4604      	mov	r4, r0
	__asm__ volatile(
   34898:	f04f 0320 	mov.w	r3, #32
   3489c:	f3ef 8511 	mrs	r5, BASEPRI
   348a0:	f383 8811 	msr	BASEPRI, r3
   348a4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   348a8:	481f      	ldr	r0, [pc, #124]	; (34928 <z_impl_k_thread_start+0x94>)
   348aa:	f7ff ffcd 	bl	34848 <z_spin_lock_valid>
   348ae:	b968      	cbnz	r0, 348cc <z_impl_k_thread_start+0x38>
   348b0:	234a      	movs	r3, #74	; 0x4a
   348b2:	4a1e      	ldr	r2, [pc, #120]	; (3492c <z_impl_k_thread_start+0x98>)
   348b4:	491e      	ldr	r1, [pc, #120]	; (34930 <z_impl_k_thread_start+0x9c>)
   348b6:	481f      	ldr	r0, [pc, #124]	; (34934 <z_impl_k_thread_start+0xa0>)
   348b8:	f003 fa02 	bl	37cc0 <printk>
   348bc:	491a      	ldr	r1, [pc, #104]	; (34928 <z_impl_k_thread_start+0x94>)
   348be:	481e      	ldr	r0, [pc, #120]	; (34938 <z_impl_k_thread_start+0xa4>)
   348c0:	f003 f9fe 	bl	37cc0 <printk>
   348c4:	214a      	movs	r1, #74	; 0x4a
   348c6:	4819      	ldr	r0, [pc, #100]	; (3492c <z_impl_k_thread_start+0x98>)
   348c8:	f003 fa40 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   348cc:	4816      	ldr	r0, [pc, #88]	; (34928 <z_impl_k_thread_start+0x94>)
   348ce:	f7ff ffd9 	bl	34884 <z_spin_lock_set_owner>
	if (z_has_thread_started(thread)) {
   348d2:	7b63      	ldrb	r3, [r4, #13]
   348d4:	075a      	lsls	r2, r3, #29
   348d6:	d416      	bmi.n	34906 <z_impl_k_thread_start+0x72>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   348d8:	4813      	ldr	r0, [pc, #76]	; (34928 <z_impl_k_thread_start+0x94>)
   348da:	f7ff ffc3 	bl	34864 <z_spin_unlock_valid>
   348de:	b968      	cbnz	r0, 348fc <z_impl_k_thread_start+0x68>
   348e0:	235d      	movs	r3, #93	; 0x5d
   348e2:	4a12      	ldr	r2, [pc, #72]	; (3492c <z_impl_k_thread_start+0x98>)
   348e4:	4915      	ldr	r1, [pc, #84]	; (3493c <z_impl_k_thread_start+0xa8>)
   348e6:	4813      	ldr	r0, [pc, #76]	; (34934 <z_impl_k_thread_start+0xa0>)
   348e8:	f003 f9ea 	bl	37cc0 <printk>
   348ec:	490e      	ldr	r1, [pc, #56]	; (34928 <z_impl_k_thread_start+0x94>)
   348ee:	4814      	ldr	r0, [pc, #80]	; (34940 <z_impl_k_thread_start+0xac>)
   348f0:	f003 f9e6 	bl	37cc0 <printk>
   348f4:	215d      	movs	r1, #93	; 0x5d
   348f6:	480d      	ldr	r0, [pc, #52]	; (3492c <z_impl_k_thread_start+0x98>)
   348f8:	f003 fa28 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   348fc:	f385 8811 	msr	BASEPRI, r5
   34900:	f3bf 8f6f 	isb	sy
}
   34904:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   34906:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   3490a:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
   3490e:	7362      	strb	r2, [r4, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   34910:	d104      	bne.n	3491c <z_impl_k_thread_start+0x88>
	if (z_is_thread_ready(thread)) {
   34912:	69a3      	ldr	r3, [r4, #24]
   34914:	b913      	cbnz	r3, 3491c <z_impl_k_thread_start+0x88>
		z_add_thread_to_ready_q(thread);
   34916:	4620      	mov	r0, r4
   34918:	f7ff f802 	bl	33920 <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
   3491c:	4629      	mov	r1, r5
}
   3491e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   34922:	4801      	ldr	r0, [pc, #4]	; (34928 <z_impl_k_thread_start+0x94>)
   34924:	f7fe be12 	b.w	3354c <z_reschedule>
   34928:	20022214 	.word	0x20022214
   3492c:	0003ba71 	.word	0x0003ba71
   34930:	0003ba97 	.word	0x0003ba97
   34934:	0003baac 	.word	0x0003baac
   34938:	0003bac9 	.word	0x0003bac9
   3493c:	0003bb0b 	.word	0x0003bb0b
   34940:	0003bb22 	.word	0x0003bb22

00034944 <z_impl_k_thread_create>:
{
   34944:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   34948:	b086      	sub	sp, #24
   3494a:	4604      	mov	r4, r0
   3494c:	460e      	mov	r6, r1
   3494e:	4617      	mov	r7, r2
   34950:	4698      	mov	r8, r3
   34952:	9d11      	ldr	r5, [sp, #68]	; 0x44
   34954:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
   34958:	b173      	cbz	r3, 34978 <z_impl_k_thread_create+0x34>
   3495a:	491f      	ldr	r1, [pc, #124]	; (349d8 <z_impl_k_thread_create+0x94>)
   3495c:	f240 2357 	movw	r3, #599	; 0x257
   34960:	4a1e      	ldr	r2, [pc, #120]	; (349dc <z_impl_k_thread_create+0x98>)
   34962:	481f      	ldr	r0, [pc, #124]	; (349e0 <z_impl_k_thread_create+0x9c>)
   34964:	f003 f9ac 	bl	37cc0 <printk>
   34968:	481e      	ldr	r0, [pc, #120]	; (349e4 <z_impl_k_thread_create+0xa0>)
   3496a:	f003 f9a9 	bl	37cc0 <printk>
   3496e:	f240 2157 	movw	r1, #599	; 0x257
   34972:	481a      	ldr	r0, [pc, #104]	; (349dc <z_impl_k_thread_create+0x98>)
   34974:	f003 f9ea 	bl	37d4c <assert_post_action>
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   34978:	2300      	movs	r3, #0
   3497a:	9305      	str	r3, [sp, #20]
   3497c:	9b10      	ldr	r3, [sp, #64]	; 0x40
   3497e:	463a      	mov	r2, r7
   34980:	9304      	str	r3, [sp, #16]
   34982:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   34984:	4631      	mov	r1, r6
   34986:	9303      	str	r3, [sp, #12]
   34988:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   3498a:	4620      	mov	r0, r4
   3498c:	9302      	str	r3, [sp, #8]
   3498e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   34990:	9301      	str	r3, [sp, #4]
   34992:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   34994:	9300      	str	r3, [sp, #0]
   34996:	4643      	mov	r3, r8
   34998:	f7ff ff3e 	bl	34818 <z_setup_new_thread>
	if (delay != K_FOREVER) {
   3499c:	1c6b      	adds	r3, r5, #1
   3499e:	d003      	beq.n	349a8 <z_impl_k_thread_create+0x64>
	if (delay == 0) {
   349a0:	b935      	cbnz	r5, 349b0 <z_impl_k_thread_create+0x6c>
	z_impl_k_thread_start(thread);
   349a2:	4620      	mov	r0, r4
   349a4:	f7ff ff76 	bl	34894 <z_impl_k_thread_start>
}
   349a8:	4620      	mov	r0, r4
   349aa:	b006      	add	sp, #24
   349ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			return (u32_t)((t * to_hz + off) / from_hz);
   349b0:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   349b4:	f240 30e7 	movw	r0, #999	; 0x3e7
   349b8:	2100      	movs	r1, #0
   349ba:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   349be:	2300      	movs	r3, #0
   349c0:	fbe6 0105 	umlal	r0, r1, r6, r5
   349c4:	f7e8 fa02 	bl	1cdcc <__aeabi_uldivmod>
   349c8:	4907      	ldr	r1, [pc, #28]	; (349e8 <z_impl_k_thread_create+0xa4>)
   349ca:	1c42      	adds	r2, r0, #1
   349cc:	f104 0018 	add.w	r0, r4, #24
   349d0:	f000 f9d4 	bl	34d7c <z_add_timeout>
   349d4:	e7e8      	b.n	349a8 <z_impl_k_thread_create+0x64>
   349d6:	bf00      	nop
   349d8:	0003f0ae 	.word	0x0003f0ae
   349dc:	0003f24c 	.word	0x0003f24c
   349e0:	0003baac 	.word	0x0003baac
   349e4:	0003f26f 	.word	0x0003f26f
   349e8:	00033a21 	.word	0x00033a21

000349ec <z_init_static_threads>:
{
   349ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   349f0:	4f3c      	ldr	r7, [pc, #240]	; (34ae4 <z_init_static_threads+0xf8>)
   349f2:	4d3d      	ldr	r5, [pc, #244]	; (34ae8 <z_init_static_threads+0xfc>)
   349f4:	463e      	mov	r6, r7
   349f6:	f8df 8100 	ldr.w	r8, [pc, #256]	; 34af8 <z_init_static_threads+0x10c>
{
   349fa:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
   349fc:	42bd      	cmp	r5, r7
   349fe:	d90e      	bls.n	34a1e <z_init_static_threads+0x32>
   34a00:	493a      	ldr	r1, [pc, #232]	; (34aec <z_init_static_threads+0x100>)
   34a02:	f240 23e7 	movw	r3, #743	; 0x2e7
   34a06:	4642      	mov	r2, r8
   34a08:	4839      	ldr	r0, [pc, #228]	; (34af0 <z_init_static_threads+0x104>)
   34a0a:	f003 f959 	bl	37cc0 <printk>
   34a0e:	4839      	ldr	r0, [pc, #228]	; (34af4 <z_init_static_threads+0x108>)
   34a10:	f003 f956 	bl	37cc0 <printk>
   34a14:	f240 21e7 	movw	r1, #743	; 0x2e7
   34a18:	4640      	mov	r0, r8
   34a1a:	f003 f997 	bl	37d4c <assert_post_action>
   34a1e:	42b5      	cmp	r5, r6
   34a20:	f105 0430 	add.w	r4, r5, #48	; 0x30
   34a24:	d31f      	bcc.n	34a66 <z_init_static_threads+0x7a>
	k_sched_lock();
   34a26:	f7fe fdcd 	bl	335c4 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   34a2a:	4c2f      	ldr	r4, [pc, #188]	; (34ae8 <z_init_static_threads+0xfc>)
   34a2c:	4d32      	ldr	r5, [pc, #200]	; (34af8 <z_init_static_threads+0x10c>)
   34a2e:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 34aec <z_init_static_threads+0x100>
   34a32:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 34af0 <z_init_static_threads+0x104>
   34a36:	42b4      	cmp	r4, r6
   34a38:	d90e      	bls.n	34a58 <z_init_static_threads+0x6c>
   34a3a:	4641      	mov	r1, r8
   34a3c:	f240 3306 	movw	r3, #774	; 0x306
   34a40:	462a      	mov	r2, r5
   34a42:	4648      	mov	r0, r9
   34a44:	f003 f93c 	bl	37cc0 <printk>
   34a48:	482a      	ldr	r0, [pc, #168]	; (34af4 <z_init_static_threads+0x108>)
   34a4a:	f003 f939 	bl	37cc0 <printk>
   34a4e:	f240 3106 	movw	r1, #774	; 0x306
   34a52:	4628      	mov	r0, r5
   34a54:	f003 f97a 	bl	37d4c <assert_post_action>
   34a58:	42b4      	cmp	r4, r6
   34a5a:	d321      	bcc.n	34aa0 <z_init_static_threads+0xb4>
}
   34a5c:	b007      	add	sp, #28
   34a5e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_sched_unlock();
   34a62:	f7fe bee1 	b.w	33828 <k_sched_unlock>
		z_setup_new_thread(
   34a66:	f854 3c04 	ldr.w	r3, [r4, #-4]
   34a6a:	9305      	str	r3, [sp, #20]
   34a6c:	f854 3c10 	ldr.w	r3, [r4, #-16]
   34a70:	9304      	str	r3, [sp, #16]
   34a72:	f854 3c14 	ldr.w	r3, [r4, #-20]
   34a76:	9303      	str	r3, [sp, #12]
   34a78:	f854 3c18 	ldr.w	r3, [r4, #-24]
   34a7c:	9302      	str	r3, [sp, #8]
   34a7e:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   34a82:	9301      	str	r3, [sp, #4]
   34a84:	f854 3c20 	ldr.w	r3, [r4, #-32]
   34a88:	9300      	str	r3, [sp, #0]
   34a8a:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   34a8e:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   34a92:	f7ff fec1 	bl	34818 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   34a96:	f854 3c30 	ldr.w	r3, [r4, #-48]
   34a9a:	64dd      	str	r5, [r3, #76]	; 0x4c
   34a9c:	4625      	mov	r5, r4
   34a9e:	e7ad      	b.n	349fc <z_init_static_threads+0x10>
		if (thread_data->init_delay != K_FOREVER) {
   34aa0:	f8d4 c024 	ldr.w	ip, [r4, #36]	; 0x24
   34aa4:	f1bc 3fff 	cmp.w	ip, #4294967295
   34aa8:	d006      	beq.n	34ab8 <z_init_static_threads+0xcc>
			schedule_new_thread(thread_data->init_thread,
   34aaa:	6827      	ldr	r7, [r4, #0]
	if (delay == 0) {
   34aac:	f1bc 0f00 	cmp.w	ip, #0
   34ab0:	d104      	bne.n	34abc <z_init_static_threads+0xd0>
   34ab2:	4638      	mov	r0, r7
   34ab4:	f7ff feee 	bl	34894 <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   34ab8:	3430      	adds	r4, #48	; 0x30
   34aba:	e7bc      	b.n	34a36 <z_init_static_threads+0x4a>
   34abc:	f44f 4e00 	mov.w	lr, #32768	; 0x8000
   34ac0:	f240 30e7 	movw	r0, #999	; 0x3e7
   34ac4:	2100      	movs	r1, #0
   34ac6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   34aca:	2300      	movs	r3, #0
   34acc:	fbee 010c 	umlal	r0, r1, lr, ip
   34ad0:	f7e8 f97c 	bl	1cdcc <__aeabi_uldivmod>
   34ad4:	4909      	ldr	r1, [pc, #36]	; (34afc <z_init_static_threads+0x110>)
   34ad6:	1c42      	adds	r2, r0, #1
   34ad8:	f107 0018 	add.w	r0, r7, #24
   34adc:	f000 f94e 	bl	34d7c <z_add_timeout>
   34ae0:	e7ea      	b.n	34ab8 <z_init_static_threads+0xcc>
   34ae2:	bf00      	nop
   34ae4:	2002cb54 	.word	0x2002cb54
   34ae8:	2002cb54 	.word	0x2002cb54
   34aec:	0003f294 	.word	0x0003f294
   34af0:	0003baac 	.word	0x0003baac
   34af4:	0003ef85 	.word	0x0003ef85
   34af8:	0003f24c 	.word	0x0003f24c
   34afc:	00033a21 	.word	0x00033a21

00034b00 <z_impl_k_thread_suspend>:
{
   34b00:	b538      	push	{r3, r4, r5, lr}
   34b02:	4605      	mov	r5, r0
	__asm__ volatile(
   34b04:	f04f 0320 	mov.w	r3, #32
   34b08:	f3ef 8411 	mrs	r4, BASEPRI
   34b0c:	f383 8811 	msr	BASEPRI, r3
   34b10:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   34b14:	481c      	ldr	r0, [pc, #112]	; (34b88 <z_impl_k_thread_suspend+0x88>)
   34b16:	f7ff fe97 	bl	34848 <z_spin_lock_valid>
   34b1a:	b968      	cbnz	r0, 34b38 <z_impl_k_thread_suspend+0x38>
   34b1c:	234a      	movs	r3, #74	; 0x4a
   34b1e:	4a1b      	ldr	r2, [pc, #108]	; (34b8c <z_impl_k_thread_suspend+0x8c>)
   34b20:	491b      	ldr	r1, [pc, #108]	; (34b90 <z_impl_k_thread_suspend+0x90>)
   34b22:	481c      	ldr	r0, [pc, #112]	; (34b94 <z_impl_k_thread_suspend+0x94>)
   34b24:	f003 f8cc 	bl	37cc0 <printk>
   34b28:	4917      	ldr	r1, [pc, #92]	; (34b88 <z_impl_k_thread_suspend+0x88>)
   34b2a:	481b      	ldr	r0, [pc, #108]	; (34b98 <z_impl_k_thread_suspend+0x98>)
   34b2c:	f003 f8c8 	bl	37cc0 <printk>
   34b30:	214a      	movs	r1, #74	; 0x4a
   34b32:	4816      	ldr	r0, [pc, #88]	; (34b8c <z_impl_k_thread_suspend+0x8c>)
   34b34:	f003 f90a 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   34b38:	4813      	ldr	r0, [pc, #76]	; (34b88 <z_impl_k_thread_suspend+0x88>)
   34b3a:	f7ff fea3 	bl	34884 <z_spin_lock_set_owner>
	z_thread_single_suspend(thread);
   34b3e:	4628      	mov	r0, r5
   34b40:	f7ff f89c 	bl	33c7c <z_thread_single_suspend>
	if (thread == _current) {
   34b44:	4b15      	ldr	r3, [pc, #84]	; (34b9c <z_impl_k_thread_suspend+0x9c>)
   34b46:	689b      	ldr	r3, [r3, #8]
   34b48:	42ab      	cmp	r3, r5
   34b4a:	d105      	bne.n	34b58 <z_impl_k_thread_suspend+0x58>
		z_reschedule(&lock, key);
   34b4c:	4621      	mov	r1, r4
}
   34b4e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&lock, key);
   34b52:	480d      	ldr	r0, [pc, #52]	; (34b88 <z_impl_k_thread_suspend+0x88>)
   34b54:	f7fe bcfa 	b.w	3354c <z_reschedule>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   34b58:	480b      	ldr	r0, [pc, #44]	; (34b88 <z_impl_k_thread_suspend+0x88>)
   34b5a:	f7ff fe83 	bl	34864 <z_spin_unlock_valid>
   34b5e:	b968      	cbnz	r0, 34b7c <z_impl_k_thread_suspend+0x7c>
   34b60:	235d      	movs	r3, #93	; 0x5d
   34b62:	4a0a      	ldr	r2, [pc, #40]	; (34b8c <z_impl_k_thread_suspend+0x8c>)
   34b64:	490e      	ldr	r1, [pc, #56]	; (34ba0 <z_impl_k_thread_suspend+0xa0>)
   34b66:	480b      	ldr	r0, [pc, #44]	; (34b94 <z_impl_k_thread_suspend+0x94>)
   34b68:	f003 f8aa 	bl	37cc0 <printk>
   34b6c:	4906      	ldr	r1, [pc, #24]	; (34b88 <z_impl_k_thread_suspend+0x88>)
   34b6e:	480d      	ldr	r0, [pc, #52]	; (34ba4 <z_impl_k_thread_suspend+0xa4>)
   34b70:	f003 f8a6 	bl	37cc0 <printk>
   34b74:	215d      	movs	r1, #93	; 0x5d
   34b76:	4805      	ldr	r0, [pc, #20]	; (34b8c <z_impl_k_thread_suspend+0x8c>)
   34b78:	f003 f8e8 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   34b7c:	f384 8811 	msr	BASEPRI, r4
   34b80:	f3bf 8f6f 	isb	sy
}
   34b84:	bd38      	pop	{r3, r4, r5, pc}
   34b86:	bf00      	nop
   34b88:	20022214 	.word	0x20022214
   34b8c:	0003ba71 	.word	0x0003ba71
   34b90:	0003ba97 	.word	0x0003ba97
   34b94:	0003baac 	.word	0x0003baac
   34b98:	0003bac9 	.word	0x0003bac9
   34b9c:	20022108 	.word	0x20022108
   34ba0:	0003bb0b 	.word	0x0003bb0b
   34ba4:	0003bb22 	.word	0x0003bb22

00034ba8 <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
   34ba8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   34bac:	4605      	mov	r5, r0
   34bae:	b086      	sub	sp, #24
   34bb0:	460e      	mov	r6, r1
   34bb2:	4617      	mov	r7, r2
   34bb4:	4698      	mov	r8, r3
	z_impl_k_queue_init(queue);
   34bb6:	f004 ff44 	bl	39a42 <z_impl_k_queue_init>
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
   34bba:	f105 0414 	add.w	r4, r5, #20
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   34bbe:	2000      	movs	r0, #0
   34bc0:	4b09      	ldr	r3, [pc, #36]	; (34be8 <k_work_q_start+0x40>)
   34bc2:	e9cd 0004 	strd	r0, r0, [sp, #16]
   34bc6:	e9cd 0802 	strd	r0, r8, [sp, #8]
   34bca:	e9cd 5000 	strd	r5, r0, [sp]
   34bce:	463a      	mov	r2, r7
   34bd0:	4631      	mov	r1, r6
   34bd2:	4620      	mov	r0, r4
   34bd4:	f7ff feb6 	bl	34944 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   34bd8:	4620      	mov	r0, r4
   34bda:	4904      	ldr	r1, [pc, #16]	; (34bec <k_work_q_start+0x44>)
			work_q, NULL, NULL, prio, 0, K_NO_WAIT);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
   34bdc:	b006      	add	sp, #24
   34bde:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   34be2:	f004 bf98 	b.w	39b16 <z_impl_k_thread_name_set>
   34be6:	bf00      	nop
   34be8:	00037d17 	.word	0x00037d17
   34bec:	0003bb5f 	.word	0x0003bb5f

00034bf0 <k_delayed_work_submit_to_queue>:
}

int k_delayed_work_submit_to_queue(struct k_work_q *work_q,
				   struct k_delayed_work *work,
				   s32_t delay)
{
   34bf0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   34bf4:	4606      	mov	r6, r0
   34bf6:	460d      	mov	r5, r1
   34bf8:	4690      	mov	r8, r2
	__asm__ volatile(
   34bfa:	f04f 0320 	mov.w	r3, #32
   34bfe:	f3ef 8711 	mrs	r7, BASEPRI
   34c02:	f383 8811 	msr	BASEPRI, r3
   34c06:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   34c0a:	4837      	ldr	r0, [pc, #220]	; (34ce8 <k_delayed_work_submit_to_queue+0xf8>)
   34c0c:	f7ff fe1c 	bl	34848 <z_spin_lock_valid>
   34c10:	b968      	cbnz	r0, 34c2e <k_delayed_work_submit_to_queue+0x3e>
   34c12:	234a      	movs	r3, #74	; 0x4a
   34c14:	4a35      	ldr	r2, [pc, #212]	; (34cec <k_delayed_work_submit_to_queue+0xfc>)
   34c16:	4936      	ldr	r1, [pc, #216]	; (34cf0 <k_delayed_work_submit_to_queue+0x100>)
   34c18:	4836      	ldr	r0, [pc, #216]	; (34cf4 <k_delayed_work_submit_to_queue+0x104>)
   34c1a:	f003 f851 	bl	37cc0 <printk>
   34c1e:	4932      	ldr	r1, [pc, #200]	; (34ce8 <k_delayed_work_submit_to_queue+0xf8>)
   34c20:	4835      	ldr	r0, [pc, #212]	; (34cf8 <k_delayed_work_submit_to_queue+0x108>)
   34c22:	f003 f84d 	bl	37cc0 <printk>
   34c26:	214a      	movs	r1, #74	; 0x4a
   34c28:	4830      	ldr	r0, [pc, #192]	; (34cec <k_delayed_work_submit_to_queue+0xfc>)
   34c2a:	f003 f88f 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   34c2e:	482e      	ldr	r0, [pc, #184]	; (34ce8 <k_delayed_work_submit_to_queue+0xf8>)
   34c30:	f7ff fe28 	bl	34884 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	int err = 0;

	/* Work cannot be active in multiple queues */
	if (work->work_q != NULL && work->work_q != work_q) {
   34c34:	69ec      	ldr	r4, [r5, #28]
   34c36:	b1ec      	cbz	r4, 34c74 <k_delayed_work_submit_to_queue+0x84>
   34c38:	42b4      	cmp	r4, r6
   34c3a:	d152      	bne.n	34ce2 <k_delayed_work_submit_to_queue+0xf2>
		goto done;
	}

	/* Cancel if work has been submitted */
	if (work->work_q == work_q) {
		err = work_cancel(work);
   34c3c:	4628      	mov	r0, r5
   34c3e:	f004 ff97 	bl	39b70 <work_cancel>
		if (err < 0) {
   34c42:	1e04      	subs	r4, r0, #0
   34c44:	da18      	bge.n	34c78 <k_delayed_work_submit_to_queue+0x88>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   34c46:	4828      	ldr	r0, [pc, #160]	; (34ce8 <k_delayed_work_submit_to_queue+0xf8>)
   34c48:	f7ff fe0c 	bl	34864 <z_spin_unlock_valid>
   34c4c:	b968      	cbnz	r0, 34c6a <k_delayed_work_submit_to_queue+0x7a>
   34c4e:	235d      	movs	r3, #93	; 0x5d
   34c50:	4a26      	ldr	r2, [pc, #152]	; (34cec <k_delayed_work_submit_to_queue+0xfc>)
   34c52:	492a      	ldr	r1, [pc, #168]	; (34cfc <k_delayed_work_submit_to_queue+0x10c>)
   34c54:	4827      	ldr	r0, [pc, #156]	; (34cf4 <k_delayed_work_submit_to_queue+0x104>)
   34c56:	f003 f833 	bl	37cc0 <printk>
   34c5a:	4923      	ldr	r1, [pc, #140]	; (34ce8 <k_delayed_work_submit_to_queue+0xf8>)
   34c5c:	4828      	ldr	r0, [pc, #160]	; (34d00 <k_delayed_work_submit_to_queue+0x110>)
   34c5e:	f003 f82f 	bl	37cc0 <printk>
   34c62:	215d      	movs	r1, #93	; 0x5d
   34c64:	4821      	ldr	r0, [pc, #132]	; (34cec <k_delayed_work_submit_to_queue+0xfc>)
   34c66:	f003 f871 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   34c6a:	f387 8811 	msr	BASEPRI, r7
   34c6e:	f3bf 8f6f 	isb	sy
	z_add_timeout(&work->timeout, work_timeout,
		     _TICK_ALIGN + k_ms_to_ticks_ceil32(delay));

done:
	k_spin_unlock(&lock, key);
	return err;
   34c72:	e020      	b.n	34cb6 <k_delayed_work_submit_to_queue+0xc6>
	if (work->work_q == work_q) {
   34c74:	2e00      	cmp	r6, #0
   34c76:	d0e1      	beq.n	34c3c <k_delayed_work_submit_to_queue+0x4c>
	work->work_q = work_q;
   34c78:	61ee      	str	r6, [r5, #28]
	if (delay == 0) {
   34c7a:	f1b8 0f00 	cmp.w	r8, #0
   34c7e:	d11d      	bne.n	34cbc <k_delayed_work_submit_to_queue+0xcc>
   34c80:	4819      	ldr	r0, [pc, #100]	; (34ce8 <k_delayed_work_submit_to_queue+0xf8>)
   34c82:	f7ff fdef 	bl	34864 <z_spin_unlock_valid>
   34c86:	b968      	cbnz	r0, 34ca4 <k_delayed_work_submit_to_queue+0xb4>
   34c88:	235d      	movs	r3, #93	; 0x5d
   34c8a:	4a18      	ldr	r2, [pc, #96]	; (34cec <k_delayed_work_submit_to_queue+0xfc>)
   34c8c:	491b      	ldr	r1, [pc, #108]	; (34cfc <k_delayed_work_submit_to_queue+0x10c>)
   34c8e:	4819      	ldr	r0, [pc, #100]	; (34cf4 <k_delayed_work_submit_to_queue+0x104>)
   34c90:	f003 f816 	bl	37cc0 <printk>
   34c94:	4914      	ldr	r1, [pc, #80]	; (34ce8 <k_delayed_work_submit_to_queue+0xf8>)
   34c96:	481a      	ldr	r0, [pc, #104]	; (34d00 <k_delayed_work_submit_to_queue+0x110>)
   34c98:	f003 f812 	bl	37cc0 <printk>
   34c9c:	215d      	movs	r1, #93	; 0x5d
   34c9e:	4813      	ldr	r0, [pc, #76]	; (34cec <k_delayed_work_submit_to_queue+0xfc>)
   34ca0:	f003 f854 	bl	37d4c <assert_post_action>
   34ca4:	f387 8811 	msr	BASEPRI, r7
   34ca8:	f3bf 8f6f 	isb	sy
		k_work_submit_to_queue(work_q, &work->work);
   34cac:	4629      	mov	r1, r5
   34cae:	4630      	mov	r0, r6
   34cb0:	f004 ff45 	bl	39b3e <k_work_submit_to_queue>
		return 0;
   34cb4:	2400      	movs	r4, #0
}
   34cb6:	4620      	mov	r0, r4
   34cb8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   34cbc:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   34cc0:	f240 30e7 	movw	r0, #999	; 0x3e7
   34cc4:	2100      	movs	r1, #0
   34cc6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   34cca:	2300      	movs	r3, #0
   34ccc:	fbe6 0108 	umlal	r0, r1, r6, r8
   34cd0:	f7e8 f87c 	bl	1cdcc <__aeabi_uldivmod>
	z_add_timeout(&work->timeout, work_timeout,
   34cd4:	490b      	ldr	r1, [pc, #44]	; (34d04 <k_delayed_work_submit_to_queue+0x114>)
   34cd6:	1c42      	adds	r2, r0, #1
   34cd8:	f105 000c 	add.w	r0, r5, #12
   34cdc:	f000 f84e 	bl	34d7c <z_add_timeout>
   34ce0:	e7b1      	b.n	34c46 <k_delayed_work_submit_to_queue+0x56>
		err = -EADDRINUSE;
   34ce2:	f06f 046f 	mvn.w	r4, #111	; 0x6f
   34ce6:	e7ae      	b.n	34c46 <k_delayed_work_submit_to_queue+0x56>
   34ce8:	20022218 	.word	0x20022218
   34cec:	0003ba71 	.word	0x0003ba71
   34cf0:	0003ba97 	.word	0x0003ba97
   34cf4:	0003baac 	.word	0x0003baac
   34cf8:	0003bac9 	.word	0x0003bac9
   34cfc:	0003bb0b 	.word	0x0003bb0b
   34d00:	0003bb22 	.word	0x0003bb22
   34d04:	00039b67 	.word	0x00039b67

00034d08 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
   34d08:	4b03      	ldr	r3, [pc, #12]	; (34d18 <elapsed+0x10>)
   34d0a:	681b      	ldr	r3, [r3, #0]
   34d0c:	b90b      	cbnz	r3, 34d12 <elapsed+0xa>
   34d0e:	f7ef bf63 	b.w	24bd8 <z_clock_elapsed>
}
   34d12:	2000      	movs	r0, #0
   34d14:	4770      	bx	lr
   34d16:	bf00      	nop
   34d18:	2002221c 	.word	0x2002221c

00034d1c <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   34d1c:	6803      	ldr	r3, [r0, #0]
   34d1e:	b140      	cbz	r0, 34d32 <remove_timeout+0x16>
   34d20:	4a07      	ldr	r2, [pc, #28]	; (34d40 <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
   34d22:	6852      	ldr	r2, [r2, #4]
   34d24:	4290      	cmp	r0, r2
   34d26:	d004      	beq.n	34d32 <remove_timeout+0x16>
	if (next(t) != NULL) {
   34d28:	b11b      	cbz	r3, 34d32 <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
   34d2a:	689a      	ldr	r2, [r3, #8]
   34d2c:	6881      	ldr	r1, [r0, #8]
   34d2e:	440a      	add	r2, r1
   34d30:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
   34d32:	6842      	ldr	r2, [r0, #4]
   34d34:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   34d36:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   34d38:	2300      	movs	r3, #0
	node->prev = NULL;
   34d3a:	e9c0 3300 	strd	r3, r3, [r0]
}
   34d3e:	4770      	bx	lr
   34d40:	2002b058 	.word	0x2002b058

00034d44 <next_timeout>:
	return list->head == list;
   34d44:	4b0b      	ldr	r3, [pc, #44]	; (34d74 <next_timeout+0x30>)

static s32_t next_timeout(void)
{
   34d46:	b510      	push	{r4, lr}
   34d48:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   34d4a:	429c      	cmp	r4, r3
   34d4c:	bf08      	it	eq
   34d4e:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
   34d50:	f7ff ffda 	bl	34d08 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   34d54:	b154      	cbz	r4, 34d6c <next_timeout+0x28>
   34d56:	68a3      	ldr	r3, [r4, #8]
   34d58:	1a18      	subs	r0, r3, r0
   34d5a:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   34d5e:	4b06      	ldr	r3, [pc, #24]	; (34d78 <next_timeout+0x34>)
   34d60:	691b      	ldr	r3, [r3, #16]
   34d62:	b113      	cbz	r3, 34d6a <next_timeout+0x26>
   34d64:	4298      	cmp	r0, r3
   34d66:	bfa8      	it	ge
   34d68:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   34d6a:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   34d6c:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   34d70:	e7f5      	b.n	34d5e <next_timeout+0x1a>
   34d72:	bf00      	nop
   34d74:	2002b058 	.word	0x2002b058
   34d78:	20022108 	.word	0x20022108

00034d7c <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
   34d7c:	6803      	ldr	r3, [r0, #0]
{
   34d7e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   34d82:	4604      	mov	r4, r0
   34d84:	460e      	mov	r6, r1
   34d86:	4615      	mov	r5, r2
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
   34d88:	b163      	cbz	r3, 34da4 <z_add_timeout+0x28>
   34d8a:	4943      	ldr	r1, [pc, #268]	; (34e98 <z_add_timeout+0x11c>)
   34d8c:	2358      	movs	r3, #88	; 0x58
   34d8e:	4a43      	ldr	r2, [pc, #268]	; (34e9c <z_add_timeout+0x120>)
   34d90:	4843      	ldr	r0, [pc, #268]	; (34ea0 <z_add_timeout+0x124>)
   34d92:	f002 ff95 	bl	37cc0 <printk>
   34d96:	4843      	ldr	r0, [pc, #268]	; (34ea4 <z_add_timeout+0x128>)
   34d98:	f002 ff92 	bl	37cc0 <printk>
   34d9c:	2158      	movs	r1, #88	; 0x58
   34d9e:	483f      	ldr	r0, [pc, #252]	; (34e9c <z_add_timeout+0x120>)
   34da0:	f002 ffd4 	bl	37d4c <assert_post_action>
	to->fn = fn;
	ticks = MAX(1, ticks);
   34da4:	2d01      	cmp	r5, #1
   34da6:	bfb8      	it	lt
   34da8:	2501      	movlt	r5, #1
	to->fn = fn;
   34daa:	60e6      	str	r6, [r4, #12]
	__asm__ volatile(
   34dac:	f04f 0320 	mov.w	r3, #32
   34db0:	f3ef 8811 	mrs	r8, BASEPRI
   34db4:	f383 8811 	msr	BASEPRI, r3
   34db8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   34dbc:	483a      	ldr	r0, [pc, #232]	; (34ea8 <z_add_timeout+0x12c>)
   34dbe:	f7ff fd43 	bl	34848 <z_spin_lock_valid>
   34dc2:	b968      	cbnz	r0, 34de0 <z_add_timeout+0x64>
   34dc4:	234a      	movs	r3, #74	; 0x4a
   34dc6:	4a39      	ldr	r2, [pc, #228]	; (34eac <z_add_timeout+0x130>)
   34dc8:	4939      	ldr	r1, [pc, #228]	; (34eb0 <z_add_timeout+0x134>)
   34dca:	4835      	ldr	r0, [pc, #212]	; (34ea0 <z_add_timeout+0x124>)
   34dcc:	f002 ff78 	bl	37cc0 <printk>
   34dd0:	4935      	ldr	r1, [pc, #212]	; (34ea8 <z_add_timeout+0x12c>)
   34dd2:	4838      	ldr	r0, [pc, #224]	; (34eb4 <z_add_timeout+0x138>)
   34dd4:	f002 ff74 	bl	37cc0 <printk>
   34dd8:	214a      	movs	r1, #74	; 0x4a
   34dda:	4834      	ldr	r0, [pc, #208]	; (34eac <z_add_timeout+0x130>)
   34ddc:	f002 ffb6 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   34de0:	4831      	ldr	r0, [pc, #196]	; (34ea8 <z_add_timeout+0x12c>)
   34de2:	f7ff fd4f 	bl	34884 <z_spin_lock_set_owner>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
   34de6:	f7ff ff8f 	bl	34d08 <elapsed>
   34dea:	4428      	add	r0, r5
	return list->head == list;
   34dec:	4d32      	ldr	r5, [pc, #200]	; (34eb8 <z_add_timeout+0x13c>)
   34dee:	60a0      	str	r0, [r4, #8]
   34df0:	682e      	ldr	r6, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   34df2:	42ae      	cmp	r6, r5
   34df4:	d005      	beq.n	34e02 <z_add_timeout+0x86>
		for (t = first(); t != NULL; t = next(t)) {
			__ASSERT(t->dticks >= 0, "");
   34df6:	4f29      	ldr	r7, [pc, #164]	; (34e9c <z_add_timeout+0x120>)
   34df8:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 34ec4 <z_add_timeout+0x148>
   34dfc:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 34ea0 <z_add_timeout+0x124>
		for (t = first(); t != NULL; t = next(t)) {
   34e00:	b936      	cbnz	r6, 34e10 <z_add_timeout+0x94>
	node->prev = list->tail;
   34e02:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   34e04:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
   34e06:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   34e08:	686b      	ldr	r3, [r5, #4]
   34e0a:	601c      	str	r4, [r3, #0]
	list->tail = node;
   34e0c:	606c      	str	r4, [r5, #4]
   34e0e:	e01a      	b.n	34e46 <z_add_timeout+0xca>
			__ASSERT(t->dticks >= 0, "");
   34e10:	68b3      	ldr	r3, [r6, #8]
   34e12:	2b00      	cmp	r3, #0
   34e14:	da0c      	bge.n	34e30 <z_add_timeout+0xb4>
   34e16:	4649      	mov	r1, r9
   34e18:	2361      	movs	r3, #97	; 0x61
   34e1a:	463a      	mov	r2, r7
   34e1c:	4650      	mov	r0, sl
   34e1e:	f002 ff4f 	bl	37cc0 <printk>
   34e22:	4820      	ldr	r0, [pc, #128]	; (34ea4 <z_add_timeout+0x128>)
   34e24:	f002 ff4c 	bl	37cc0 <printk>
   34e28:	2161      	movs	r1, #97	; 0x61
   34e2a:	4638      	mov	r0, r7
   34e2c:	f002 ff8e 	bl	37d4c <assert_post_action>

			if (t->dticks > to->dticks) {
   34e30:	68b2      	ldr	r2, [r6, #8]
   34e32:	68a3      	ldr	r3, [r4, #8]
   34e34:	429a      	cmp	r2, r3
   34e36:	dd28      	ble.n	34e8a <z_add_timeout+0x10e>
				t->dticks -= to->dticks;
   34e38:	1ad3      	subs	r3, r2, r3
   34e3a:	60b3      	str	r3, [r6, #8]
	node->prev = successor->prev;
   34e3c:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   34e3e:	e9c4 6300 	strd	r6, r3, [r4]
	successor->prev->next = node;
   34e42:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   34e44:	6074      	str	r4, [r6, #4]
	return list->head == list;
   34e46:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   34e48:	42ab      	cmp	r3, r5
   34e4a:	d006      	beq.n	34e5a <z_add_timeout+0xde>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   34e4c:	429c      	cmp	r4, r3
   34e4e:	d104      	bne.n	34e5a <z_add_timeout+0xde>
			z_clock_set_timeout(next_timeout(), false);
   34e50:	f7ff ff78 	bl	34d44 <next_timeout>
   34e54:	2100      	movs	r1, #0
   34e56:	f7ef fe31 	bl	24abc <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   34e5a:	4813      	ldr	r0, [pc, #76]	; (34ea8 <z_add_timeout+0x12c>)
   34e5c:	f7ff fd02 	bl	34864 <z_spin_unlock_valid>
   34e60:	b968      	cbnz	r0, 34e7e <z_add_timeout+0x102>
   34e62:	235d      	movs	r3, #93	; 0x5d
   34e64:	4a11      	ldr	r2, [pc, #68]	; (34eac <z_add_timeout+0x130>)
   34e66:	4915      	ldr	r1, [pc, #84]	; (34ebc <z_add_timeout+0x140>)
   34e68:	480d      	ldr	r0, [pc, #52]	; (34ea0 <z_add_timeout+0x124>)
   34e6a:	f002 ff29 	bl	37cc0 <printk>
   34e6e:	490e      	ldr	r1, [pc, #56]	; (34ea8 <z_add_timeout+0x12c>)
   34e70:	4813      	ldr	r0, [pc, #76]	; (34ec0 <z_add_timeout+0x144>)
   34e72:	f002 ff25 	bl	37cc0 <printk>
   34e76:	215d      	movs	r1, #93	; 0x5d
   34e78:	480c      	ldr	r0, [pc, #48]	; (34eac <z_add_timeout+0x130>)
   34e7a:	f002 ff67 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   34e7e:	f388 8811 	msr	BASEPRI, r8
   34e82:	f3bf 8f6f 	isb	sy
		}
	}
}
   34e86:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			to->dticks -= t->dticks;
   34e8a:	1a9b      	subs	r3, r3, r2
   34e8c:	60a3      	str	r3, [r4, #8]
	return (node == list->tail) ? NULL : node->next;
   34e8e:	686b      	ldr	r3, [r5, #4]
   34e90:	429e      	cmp	r6, r3
   34e92:	d0b6      	beq.n	34e02 <z_add_timeout+0x86>
   34e94:	6836      	ldr	r6, [r6, #0]
   34e96:	e7b3      	b.n	34e00 <z_add_timeout+0x84>
   34e98:	0003f2e5 	.word	0x0003f2e5
   34e9c:	0003f2c1 	.word	0x0003f2c1
   34ea0:	0003baac 	.word	0x0003baac
   34ea4:	0003da1b 	.word	0x0003da1b
   34ea8:	20022220 	.word	0x20022220
   34eac:	0003ba71 	.word	0x0003ba71
   34eb0:	0003ba97 	.word	0x0003ba97
   34eb4:	0003bac9 	.word	0x0003bac9
   34eb8:	2002b058 	.word	0x2002b058
   34ebc:	0003bb0b 	.word	0x0003bb0b
   34ec0:	0003bb22 	.word	0x0003bb22
   34ec4:	0003f305 	.word	0x0003f305

00034ec8 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
   34ec8:	b538      	push	{r3, r4, r5, lr}
   34eca:	4604      	mov	r4, r0
	__asm__ volatile(
   34ecc:	f04f 0320 	mov.w	r3, #32
   34ed0:	f3ef 8511 	mrs	r5, BASEPRI
   34ed4:	f383 8811 	msr	BASEPRI, r3
   34ed8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   34edc:	481a      	ldr	r0, [pc, #104]	; (34f48 <z_abort_timeout+0x80>)
   34ede:	f7ff fcb3 	bl	34848 <z_spin_lock_valid>
   34ee2:	b968      	cbnz	r0, 34f00 <z_abort_timeout+0x38>
   34ee4:	234a      	movs	r3, #74	; 0x4a
   34ee6:	4a19      	ldr	r2, [pc, #100]	; (34f4c <z_abort_timeout+0x84>)
   34ee8:	4919      	ldr	r1, [pc, #100]	; (34f50 <z_abort_timeout+0x88>)
   34eea:	481a      	ldr	r0, [pc, #104]	; (34f54 <z_abort_timeout+0x8c>)
   34eec:	f002 fee8 	bl	37cc0 <printk>
   34ef0:	4915      	ldr	r1, [pc, #84]	; (34f48 <z_abort_timeout+0x80>)
   34ef2:	4819      	ldr	r0, [pc, #100]	; (34f58 <z_abort_timeout+0x90>)
   34ef4:	f002 fee4 	bl	37cc0 <printk>
   34ef8:	214a      	movs	r1, #74	; 0x4a
   34efa:	4814      	ldr	r0, [pc, #80]	; (34f4c <z_abort_timeout+0x84>)
   34efc:	f002 ff26 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   34f00:	4811      	ldr	r0, [pc, #68]	; (34f48 <z_abort_timeout+0x80>)
   34f02:	f7ff fcbf 	bl	34884 <z_spin_lock_set_owner>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
   34f06:	6823      	ldr	r3, [r4, #0]
   34f08:	b1db      	cbz	r3, 34f42 <z_abort_timeout+0x7a>
			remove_timeout(to);
   34f0a:	4620      	mov	r0, r4
   34f0c:	f7ff ff06 	bl	34d1c <remove_timeout>
			ret = 0;
   34f10:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   34f12:	480d      	ldr	r0, [pc, #52]	; (34f48 <z_abort_timeout+0x80>)
   34f14:	f7ff fca6 	bl	34864 <z_spin_unlock_valid>
   34f18:	b968      	cbnz	r0, 34f36 <z_abort_timeout+0x6e>
   34f1a:	235d      	movs	r3, #93	; 0x5d
   34f1c:	4a0b      	ldr	r2, [pc, #44]	; (34f4c <z_abort_timeout+0x84>)
   34f1e:	490f      	ldr	r1, [pc, #60]	; (34f5c <z_abort_timeout+0x94>)
   34f20:	480c      	ldr	r0, [pc, #48]	; (34f54 <z_abort_timeout+0x8c>)
   34f22:	f002 fecd 	bl	37cc0 <printk>
   34f26:	4908      	ldr	r1, [pc, #32]	; (34f48 <z_abort_timeout+0x80>)
   34f28:	480d      	ldr	r0, [pc, #52]	; (34f60 <z_abort_timeout+0x98>)
   34f2a:	f002 fec9 	bl	37cc0 <printk>
   34f2e:	215d      	movs	r1, #93	; 0x5d
   34f30:	4806      	ldr	r0, [pc, #24]	; (34f4c <z_abort_timeout+0x84>)
   34f32:	f002 ff0b 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   34f36:	f385 8811 	msr	BASEPRI, r5
   34f3a:	f3bf 8f6f 	isb	sy
		}
	}

	return ret;
}
   34f3e:	4620      	mov	r0, r4
   34f40:	bd38      	pop	{r3, r4, r5, pc}
	int ret = -EINVAL;
   34f42:	f06f 0415 	mvn.w	r4, #21
   34f46:	e7e4      	b.n	34f12 <z_abort_timeout+0x4a>
   34f48:	20022220 	.word	0x20022220
   34f4c:	0003ba71 	.word	0x0003ba71
   34f50:	0003ba97 	.word	0x0003ba97
   34f54:	0003baac 	.word	0x0003baac
   34f58:	0003bac9 	.word	0x0003bac9
   34f5c:	0003bb0b 	.word	0x0003bb0b
   34f60:	0003bb22 	.word	0x0003bb22

00034f64 <z_timeout_remaining>:

s32_t z_timeout_remaining(struct _timeout *timeout)
{
   34f64:	b570      	push	{r4, r5, r6, lr}
   34f66:	4605      	mov	r5, r0
	s32_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
   34f68:	6800      	ldr	r0, [r0, #0]
   34f6a:	2800      	cmp	r0, #0
   34f6c:	d03c      	beq.n	34fe8 <z_timeout_remaining+0x84>
	__asm__ volatile(
   34f6e:	f04f 0320 	mov.w	r3, #32
   34f72:	f3ef 8611 	mrs	r6, BASEPRI
   34f76:	f383 8811 	msr	BASEPRI, r3
   34f7a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   34f7e:	4821      	ldr	r0, [pc, #132]	; (35004 <z_timeout_remaining+0xa0>)
   34f80:	f7ff fc62 	bl	34848 <z_spin_lock_valid>
   34f84:	b968      	cbnz	r0, 34fa2 <z_timeout_remaining+0x3e>
   34f86:	234a      	movs	r3, #74	; 0x4a
   34f88:	4a1f      	ldr	r2, [pc, #124]	; (35008 <z_timeout_remaining+0xa4>)
   34f8a:	4920      	ldr	r1, [pc, #128]	; (3500c <z_timeout_remaining+0xa8>)
   34f8c:	4820      	ldr	r0, [pc, #128]	; (35010 <z_timeout_remaining+0xac>)
   34f8e:	f002 fe97 	bl	37cc0 <printk>
   34f92:	491c      	ldr	r1, [pc, #112]	; (35004 <z_timeout_remaining+0xa0>)
   34f94:	481f      	ldr	r0, [pc, #124]	; (35014 <z_timeout_remaining+0xb0>)
   34f96:	f002 fe93 	bl	37cc0 <printk>
   34f9a:	214a      	movs	r1, #74	; 0x4a
   34f9c:	481a      	ldr	r0, [pc, #104]	; (35008 <z_timeout_remaining+0xa4>)
   34f9e:	f002 fed5 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   34fa2:	4818      	ldr	r0, [pc, #96]	; (35004 <z_timeout_remaining+0xa0>)
   34fa4:	f7ff fc6e 	bl	34884 <z_spin_lock_set_owner>
	return list->head == list;
   34fa8:	4a1b      	ldr	r2, [pc, #108]	; (35018 <z_timeout_remaining+0xb4>)
   34faa:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   34fac:	4293      	cmp	r3, r2
   34fae:	d026      	beq.n	34ffe <z_timeout_remaining+0x9a>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   34fb0:	2400      	movs	r4, #0
   34fb2:	6852      	ldr	r2, [r2, #4]
		return 0;
	}

	LOCKED(&timeout_lock) {
		for (struct _timeout *t = first(); t != NULL; t = next(t)) {
   34fb4:	b9cb      	cbnz	r3, 34fea <z_timeout_remaining+0x86>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   34fb6:	4813      	ldr	r0, [pc, #76]	; (35004 <z_timeout_remaining+0xa0>)
   34fb8:	f7ff fc54 	bl	34864 <z_spin_unlock_valid>
   34fbc:	b968      	cbnz	r0, 34fda <z_timeout_remaining+0x76>
   34fbe:	235d      	movs	r3, #93	; 0x5d
   34fc0:	4a11      	ldr	r2, [pc, #68]	; (35008 <z_timeout_remaining+0xa4>)
   34fc2:	4916      	ldr	r1, [pc, #88]	; (3501c <z_timeout_remaining+0xb8>)
   34fc4:	4812      	ldr	r0, [pc, #72]	; (35010 <z_timeout_remaining+0xac>)
   34fc6:	f002 fe7b 	bl	37cc0 <printk>
   34fca:	490e      	ldr	r1, [pc, #56]	; (35004 <z_timeout_remaining+0xa0>)
   34fcc:	4814      	ldr	r0, [pc, #80]	; (35020 <z_timeout_remaining+0xbc>)
   34fce:	f002 fe77 	bl	37cc0 <printk>
   34fd2:	215d      	movs	r1, #93	; 0x5d
   34fd4:	480c      	ldr	r0, [pc, #48]	; (35008 <z_timeout_remaining+0xa4>)
   34fd6:	f002 feb9 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   34fda:	f386 8811 	msr	BASEPRI, r6
   34fde:	f3bf 8f6f 	isb	sy
				break;
			}
		}
	}

	return ticks - elapsed();
   34fe2:	f7ff fe91 	bl	34d08 <elapsed>
   34fe6:	1a20      	subs	r0, r4, r0
}
   34fe8:	bd70      	pop	{r4, r5, r6, pc}
			ticks += t->dticks;
   34fea:	6899      	ldr	r1, [r3, #8]
			if (timeout == t) {
   34fec:	42ab      	cmp	r3, r5
			ticks += t->dticks;
   34fee:	440c      	add	r4, r1
			if (timeout == t) {
   34ff0:	d0e1      	beq.n	34fb6 <z_timeout_remaining+0x52>
   34ff2:	2b00      	cmp	r3, #0
   34ff4:	d0df      	beq.n	34fb6 <z_timeout_remaining+0x52>
	return (node == list->tail) ? NULL : node->next;
   34ff6:	4293      	cmp	r3, r2
   34ff8:	d0dd      	beq.n	34fb6 <z_timeout_remaining+0x52>
   34ffa:	681b      	ldr	r3, [r3, #0]
   34ffc:	e7da      	b.n	34fb4 <z_timeout_remaining+0x50>
	return sys_dlist_is_empty(list) ? NULL : list->head;
   34ffe:	2400      	movs	r4, #0
   35000:	e7d9      	b.n	34fb6 <z_timeout_remaining+0x52>
   35002:	bf00      	nop
   35004:	20022220 	.word	0x20022220
   35008:	0003ba71 	.word	0x0003ba71
   3500c:	0003ba97 	.word	0x0003ba97
   35010:	0003baac 	.word	0x0003baac
   35014:	0003bac9 	.word	0x0003bac9
   35018:	2002b058 	.word	0x2002b058
   3501c:	0003bb0b 	.word	0x0003bb0b
   35020:	0003bb22 	.word	0x0003bb22

00035024 <z_get_next_timeout_expiry>:

s32_t z_get_next_timeout_expiry(void)
{
   35024:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   35026:	f04f 0320 	mov.w	r3, #32
   3502a:	f3ef 8511 	mrs	r5, BASEPRI
   3502e:	f383 8811 	msr	BASEPRI, r3
   35032:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   35036:	4818      	ldr	r0, [pc, #96]	; (35098 <z_get_next_timeout_expiry+0x74>)
   35038:	f7ff fc06 	bl	34848 <z_spin_lock_valid>
   3503c:	b968      	cbnz	r0, 3505a <z_get_next_timeout_expiry+0x36>
   3503e:	234a      	movs	r3, #74	; 0x4a
   35040:	4a16      	ldr	r2, [pc, #88]	; (3509c <z_get_next_timeout_expiry+0x78>)
   35042:	4917      	ldr	r1, [pc, #92]	; (350a0 <z_get_next_timeout_expiry+0x7c>)
   35044:	4817      	ldr	r0, [pc, #92]	; (350a4 <z_get_next_timeout_expiry+0x80>)
   35046:	f002 fe3b 	bl	37cc0 <printk>
   3504a:	4913      	ldr	r1, [pc, #76]	; (35098 <z_get_next_timeout_expiry+0x74>)
   3504c:	4816      	ldr	r0, [pc, #88]	; (350a8 <z_get_next_timeout_expiry+0x84>)
   3504e:	f002 fe37 	bl	37cc0 <printk>
   35052:	214a      	movs	r1, #74	; 0x4a
   35054:	4811      	ldr	r0, [pc, #68]	; (3509c <z_get_next_timeout_expiry+0x78>)
   35056:	f002 fe79 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   3505a:	480f      	ldr	r0, [pc, #60]	; (35098 <z_get_next_timeout_expiry+0x74>)
   3505c:	f7ff fc12 	bl	34884 <z_spin_lock_set_owner>
	s32_t ret = K_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
   35060:	f7ff fe70 	bl	34d44 <next_timeout>
   35064:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   35066:	480c      	ldr	r0, [pc, #48]	; (35098 <z_get_next_timeout_expiry+0x74>)
   35068:	f7ff fbfc 	bl	34864 <z_spin_unlock_valid>
   3506c:	b968      	cbnz	r0, 3508a <z_get_next_timeout_expiry+0x66>
   3506e:	235d      	movs	r3, #93	; 0x5d
   35070:	4a0a      	ldr	r2, [pc, #40]	; (3509c <z_get_next_timeout_expiry+0x78>)
   35072:	490e      	ldr	r1, [pc, #56]	; (350ac <z_get_next_timeout_expiry+0x88>)
   35074:	480b      	ldr	r0, [pc, #44]	; (350a4 <z_get_next_timeout_expiry+0x80>)
   35076:	f002 fe23 	bl	37cc0 <printk>
   3507a:	4907      	ldr	r1, [pc, #28]	; (35098 <z_get_next_timeout_expiry+0x74>)
   3507c:	480c      	ldr	r0, [pc, #48]	; (350b0 <z_get_next_timeout_expiry+0x8c>)
   3507e:	f002 fe1f 	bl	37cc0 <printk>
   35082:	215d      	movs	r1, #93	; 0x5d
   35084:	4805      	ldr	r0, [pc, #20]	; (3509c <z_get_next_timeout_expiry+0x78>)
   35086:	f002 fe61 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   3508a:	f385 8811 	msr	BASEPRI, r5
   3508e:	f3bf 8f6f 	isb	sy
	}
	return ret;
}
   35092:	4620      	mov	r0, r4
   35094:	bd38      	pop	{r3, r4, r5, pc}
   35096:	bf00      	nop
   35098:	20022220 	.word	0x20022220
   3509c:	0003ba71 	.word	0x0003ba71
   350a0:	0003ba97 	.word	0x0003ba97
   350a4:	0003baac 	.word	0x0003baac
   350a8:	0003bac9 	.word	0x0003bac9
   350ac:	0003bb0b 	.word	0x0003bb0b
   350b0:	0003bb22 	.word	0x0003bb22

000350b4 <z_set_timeout_expiry>:

void z_set_timeout_expiry(s32_t ticks, bool idle)
{
   350b4:	b570      	push	{r4, r5, r6, lr}
   350b6:	4604      	mov	r4, r0
   350b8:	460e      	mov	r6, r1
	__asm__ volatile(
   350ba:	f04f 0320 	mov.w	r3, #32
   350be:	f3ef 8511 	mrs	r5, BASEPRI
   350c2:	f383 8811 	msr	BASEPRI, r3
   350c6:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   350ca:	481b      	ldr	r0, [pc, #108]	; (35138 <z_set_timeout_expiry+0x84>)
   350cc:	f7ff fbbc 	bl	34848 <z_spin_lock_valid>
   350d0:	b968      	cbnz	r0, 350ee <z_set_timeout_expiry+0x3a>
   350d2:	234a      	movs	r3, #74	; 0x4a
   350d4:	4a19      	ldr	r2, [pc, #100]	; (3513c <z_set_timeout_expiry+0x88>)
   350d6:	491a      	ldr	r1, [pc, #104]	; (35140 <z_set_timeout_expiry+0x8c>)
   350d8:	481a      	ldr	r0, [pc, #104]	; (35144 <z_set_timeout_expiry+0x90>)
   350da:	f002 fdf1 	bl	37cc0 <printk>
   350de:	4916      	ldr	r1, [pc, #88]	; (35138 <z_set_timeout_expiry+0x84>)
   350e0:	4819      	ldr	r0, [pc, #100]	; (35148 <z_set_timeout_expiry+0x94>)
   350e2:	f002 fded 	bl	37cc0 <printk>
   350e6:	214a      	movs	r1, #74	; 0x4a
   350e8:	4814      	ldr	r0, [pc, #80]	; (3513c <z_set_timeout_expiry+0x88>)
   350ea:	f002 fe2f 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   350ee:	4812      	ldr	r0, [pc, #72]	; (35138 <z_set_timeout_expiry+0x84>)
   350f0:	f7ff fbc8 	bl	34884 <z_spin_lock_set_owner>
	LOCKED(&timeout_lock) {
		int next = next_timeout();
   350f4:	f7ff fe26 	bl	34d44 <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   350f8:	2801      	cmp	r0, #1
   350fa:	dd05      	ble.n	35108 <z_set_timeout_expiry+0x54>
   350fc:	42a0      	cmp	r0, r4
   350fe:	dd03      	ble.n	35108 <z_set_timeout_expiry+0x54>
			z_clock_set_timeout(ticks, idle);
   35100:	4631      	mov	r1, r6
   35102:	4620      	mov	r0, r4
   35104:	f7ef fcda 	bl	24abc <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   35108:	480b      	ldr	r0, [pc, #44]	; (35138 <z_set_timeout_expiry+0x84>)
   3510a:	f7ff fbab 	bl	34864 <z_spin_unlock_valid>
   3510e:	b968      	cbnz	r0, 3512c <z_set_timeout_expiry+0x78>
   35110:	235d      	movs	r3, #93	; 0x5d
   35112:	4a0a      	ldr	r2, [pc, #40]	; (3513c <z_set_timeout_expiry+0x88>)
   35114:	490d      	ldr	r1, [pc, #52]	; (3514c <z_set_timeout_expiry+0x98>)
   35116:	480b      	ldr	r0, [pc, #44]	; (35144 <z_set_timeout_expiry+0x90>)
   35118:	f002 fdd2 	bl	37cc0 <printk>
   3511c:	4906      	ldr	r1, [pc, #24]	; (35138 <z_set_timeout_expiry+0x84>)
   3511e:	480c      	ldr	r0, [pc, #48]	; (35150 <z_set_timeout_expiry+0x9c>)
   35120:	f002 fdce 	bl	37cc0 <printk>
   35124:	215d      	movs	r1, #93	; 0x5d
   35126:	4805      	ldr	r0, [pc, #20]	; (3513c <z_set_timeout_expiry+0x88>)
   35128:	f002 fe10 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   3512c:	f385 8811 	msr	BASEPRI, r5
   35130:	f3bf 8f6f 	isb	sy
		}
	}
}
   35134:	bd70      	pop	{r4, r5, r6, pc}
   35136:	bf00      	nop
   35138:	20022220 	.word	0x20022220
   3513c:	0003ba71 	.word	0x0003ba71
   35140:	0003ba97 	.word	0x0003ba97
   35144:	0003baac 	.word	0x0003baac
   35148:	0003bac9 	.word	0x0003bac9
   3514c:	0003bb0b 	.word	0x0003bb0b
   35150:	0003bb22 	.word	0x0003bb22

00035154 <z_clock_announce>:

void z_clock_announce(s32_t ticks)
{
   35154:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
   35158:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   3515a:	f7fe fd59 	bl	33c10 <z_time_slice>
	__asm__ volatile(
   3515e:	f04f 0320 	mov.w	r3, #32
   35162:	f3ef 8511 	mrs	r5, BASEPRI
   35166:	f383 8811 	msr	BASEPRI, r3
   3516a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   3516e:	4848      	ldr	r0, [pc, #288]	; (35290 <z_clock_announce+0x13c>)
   35170:	f7ff fb6a 	bl	34848 <z_spin_lock_valid>
   35174:	b968      	cbnz	r0, 35192 <z_clock_announce+0x3e>
   35176:	234a      	movs	r3, #74	; 0x4a
   35178:	4a46      	ldr	r2, [pc, #280]	; (35294 <z_clock_announce+0x140>)
   3517a:	4947      	ldr	r1, [pc, #284]	; (35298 <z_clock_announce+0x144>)
   3517c:	4847      	ldr	r0, [pc, #284]	; (3529c <z_clock_announce+0x148>)
   3517e:	f002 fd9f 	bl	37cc0 <printk>
   35182:	4943      	ldr	r1, [pc, #268]	; (35290 <z_clock_announce+0x13c>)
   35184:	4846      	ldr	r0, [pc, #280]	; (352a0 <z_clock_announce+0x14c>)
   35186:	f002 fd9b 	bl	37cc0 <printk>
   3518a:	214a      	movs	r1, #74	; 0x4a
   3518c:	4841      	ldr	r0, [pc, #260]	; (35294 <z_clock_announce+0x140>)
   3518e:	f002 fddd 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   35192:	4f44      	ldr	r7, [pc, #272]	; (352a4 <z_clock_announce+0x150>)
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   35194:	4e44      	ldr	r6, [pc, #272]	; (352a8 <z_clock_announce+0x154>)
   35196:	46b9      	mov	r9, r7
   35198:	483d      	ldr	r0, [pc, #244]	; (35290 <z_clock_announce+0x13c>)
	return list->head == list;
   3519a:	f8df 8118 	ldr.w	r8, [pc, #280]	; 352b4 <z_clock_announce+0x160>
   3519e:	f7ff fb71 	bl	34884 <z_spin_lock_set_owner>
   351a2:	6034      	str	r4, [r6, #0]
   351a4:	f8d8 4000 	ldr.w	r4, [r8]
   351a8:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   351aa:	4544      	cmp	r4, r8
   351ac:	e9d7 bc00 	ldrd	fp, ip, [r7]
   351b0:	d005      	beq.n	351be <z_clock_announce+0x6a>

	while (first() != NULL && first()->dticks <= announce_remaining) {
   351b2:	b124      	cbz	r4, 351be <z_clock_announce+0x6a>
   351b4:	68a3      	ldr	r3, [r4, #8]
   351b6:	4293      	cmp	r3, r2
   351b8:	dd26      	ble.n	35208 <z_clock_announce+0xb4>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   351ba:	1a9b      	subs	r3, r3, r2
   351bc:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
   351be:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
   351c0:	eb1b 0002 	adds.w	r0, fp, r2
   351c4:	eb4c 71e2 	adc.w	r1, ip, r2, asr #31
   351c8:	e9c9 0100 	strd	r0, r1, [r9]
	announce_remaining = 0;
   351cc:	6034      	str	r4, [r6, #0]

	z_clock_set_timeout(next_timeout(), false);
   351ce:	f7ff fdb9 	bl	34d44 <next_timeout>
   351d2:	4621      	mov	r1, r4
   351d4:	f7ef fc72 	bl	24abc <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   351d8:	482d      	ldr	r0, [pc, #180]	; (35290 <z_clock_announce+0x13c>)
   351da:	f7ff fb43 	bl	34864 <z_spin_unlock_valid>
   351de:	b968      	cbnz	r0, 351fc <z_clock_announce+0xa8>
   351e0:	235d      	movs	r3, #93	; 0x5d
   351e2:	4a2c      	ldr	r2, [pc, #176]	; (35294 <z_clock_announce+0x140>)
   351e4:	4931      	ldr	r1, [pc, #196]	; (352ac <z_clock_announce+0x158>)
   351e6:	482d      	ldr	r0, [pc, #180]	; (3529c <z_clock_announce+0x148>)
   351e8:	f002 fd6a 	bl	37cc0 <printk>
   351ec:	4928      	ldr	r1, [pc, #160]	; (35290 <z_clock_announce+0x13c>)
   351ee:	4830      	ldr	r0, [pc, #192]	; (352b0 <z_clock_announce+0x15c>)
   351f0:	f002 fd66 	bl	37cc0 <printk>
   351f4:	215d      	movs	r1, #93	; 0x5d
   351f6:	4827      	ldr	r0, [pc, #156]	; (35294 <z_clock_announce+0x140>)
   351f8:	f002 fda8 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   351fc:	f385 8811 	msr	BASEPRI, r5
   35200:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   35204:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		curr_tick += dt;
   35208:	eb1b 0003 	adds.w	r0, fp, r3
   3520c:	eb4c 71e3 	adc.w	r1, ip, r3, asr #31
		announce_remaining -= dt;
   35210:	1ad3      	subs	r3, r2, r3
   35212:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
   35214:	2300      	movs	r3, #0
		curr_tick += dt;
   35216:	e9c7 0100 	strd	r0, r1, [r7]
		t->dticks = 0;
   3521a:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
   3521c:	4620      	mov	r0, r4
   3521e:	f7ff fd7d 	bl	34d1c <remove_timeout>
   35222:	481b      	ldr	r0, [pc, #108]	; (35290 <z_clock_announce+0x13c>)
   35224:	f7ff fb1e 	bl	34864 <z_spin_unlock_valid>
   35228:	b968      	cbnz	r0, 35246 <z_clock_announce+0xf2>
   3522a:	235d      	movs	r3, #93	; 0x5d
   3522c:	4a19      	ldr	r2, [pc, #100]	; (35294 <z_clock_announce+0x140>)
   3522e:	491f      	ldr	r1, [pc, #124]	; (352ac <z_clock_announce+0x158>)
   35230:	481a      	ldr	r0, [pc, #104]	; (3529c <z_clock_announce+0x148>)
   35232:	f002 fd45 	bl	37cc0 <printk>
   35236:	4916      	ldr	r1, [pc, #88]	; (35290 <z_clock_announce+0x13c>)
   35238:	481d      	ldr	r0, [pc, #116]	; (352b0 <z_clock_announce+0x15c>)
   3523a:	f002 fd41 	bl	37cc0 <printk>
   3523e:	215d      	movs	r1, #93	; 0x5d
   35240:	4814      	ldr	r0, [pc, #80]	; (35294 <z_clock_announce+0x140>)
   35242:	f002 fd83 	bl	37d4c <assert_post_action>
   35246:	f385 8811 	msr	BASEPRI, r5
   3524a:	f3bf 8f6f 	isb	sy
		t->fn(t);
   3524e:	68e3      	ldr	r3, [r4, #12]
   35250:	4620      	mov	r0, r4
   35252:	4798      	blx	r3
	__asm__ volatile(
   35254:	f04f 0320 	mov.w	r3, #32
   35258:	f3ef 8511 	mrs	r5, BASEPRI
   3525c:	f383 8811 	msr	BASEPRI, r3
   35260:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   35264:	480a      	ldr	r0, [pc, #40]	; (35290 <z_clock_announce+0x13c>)
   35266:	f7ff faef 	bl	34848 <z_spin_lock_valid>
   3526a:	b968      	cbnz	r0, 35288 <z_clock_announce+0x134>
   3526c:	234a      	movs	r3, #74	; 0x4a
   3526e:	4a09      	ldr	r2, [pc, #36]	; (35294 <z_clock_announce+0x140>)
   35270:	4909      	ldr	r1, [pc, #36]	; (35298 <z_clock_announce+0x144>)
   35272:	480a      	ldr	r0, [pc, #40]	; (3529c <z_clock_announce+0x148>)
   35274:	f002 fd24 	bl	37cc0 <printk>
   35278:	4905      	ldr	r1, [pc, #20]	; (35290 <z_clock_announce+0x13c>)
   3527a:	4809      	ldr	r0, [pc, #36]	; (352a0 <z_clock_announce+0x14c>)
   3527c:	f002 fd20 	bl	37cc0 <printk>
   35280:	214a      	movs	r1, #74	; 0x4a
   35282:	4804      	ldr	r0, [pc, #16]	; (35294 <z_clock_announce+0x140>)
   35284:	f002 fd62 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   35288:	4801      	ldr	r0, [pc, #4]	; (35290 <z_clock_announce+0x13c>)
   3528a:	f7ff fafb 	bl	34884 <z_spin_lock_set_owner>
	return k;
   3528e:	e789      	b.n	351a4 <z_clock_announce+0x50>
   35290:	20022220 	.word	0x20022220
   35294:	0003ba71 	.word	0x0003ba71
   35298:	0003ba97 	.word	0x0003ba97
   3529c:	0003baac 	.word	0x0003baac
   352a0:	0003bac9 	.word	0x0003bac9
   352a4:	200200e0 	.word	0x200200e0
   352a8:	2002221c 	.word	0x2002221c
   352ac:	0003bb0b 	.word	0x0003bb0b
   352b0:	0003bb22 	.word	0x0003bb22
   352b4:	2002b058 	.word	0x2002b058

000352b8 <z_tick_get>:

s64_t z_tick_get(void)
{
   352b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   352bc:	f04f 0320 	mov.w	r3, #32
   352c0:	f3ef 8611 	mrs	r6, BASEPRI
   352c4:	f383 8811 	msr	BASEPRI, r3
   352c8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   352cc:	481b      	ldr	r0, [pc, #108]	; (3533c <z_tick_get+0x84>)
   352ce:	f7ff fabb 	bl	34848 <z_spin_lock_valid>
   352d2:	b968      	cbnz	r0, 352f0 <z_tick_get+0x38>
   352d4:	234a      	movs	r3, #74	; 0x4a
   352d6:	4a1a      	ldr	r2, [pc, #104]	; (35340 <z_tick_get+0x88>)
   352d8:	491a      	ldr	r1, [pc, #104]	; (35344 <z_tick_get+0x8c>)
   352da:	481b      	ldr	r0, [pc, #108]	; (35348 <z_tick_get+0x90>)
   352dc:	f002 fcf0 	bl	37cc0 <printk>
   352e0:	4916      	ldr	r1, [pc, #88]	; (3533c <z_tick_get+0x84>)
   352e2:	481a      	ldr	r0, [pc, #104]	; (3534c <z_tick_get+0x94>)
   352e4:	f002 fcec 	bl	37cc0 <printk>
   352e8:	214a      	movs	r1, #74	; 0x4a
   352ea:	4815      	ldr	r0, [pc, #84]	; (35340 <z_tick_get+0x88>)
   352ec:	f002 fd2e 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   352f0:	4812      	ldr	r0, [pc, #72]	; (3533c <z_tick_get+0x84>)
   352f2:	f7ff fac7 	bl	34884 <z_spin_lock_set_owner>
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
   352f6:	f7ef fc6f 	bl	24bd8 <z_clock_elapsed>
   352fa:	4b15      	ldr	r3, [pc, #84]	; (35350 <z_tick_get+0x98>)
   352fc:	e9d3 4500 	ldrd	r4, r5, [r3]
   35300:	1827      	adds	r7, r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   35302:	480e      	ldr	r0, [pc, #56]	; (3533c <z_tick_get+0x84>)
   35304:	f145 0800 	adc.w	r8, r5, #0
   35308:	f7ff faac 	bl	34864 <z_spin_unlock_valid>
   3530c:	b968      	cbnz	r0, 3532a <z_tick_get+0x72>
   3530e:	235d      	movs	r3, #93	; 0x5d
   35310:	4a0b      	ldr	r2, [pc, #44]	; (35340 <z_tick_get+0x88>)
   35312:	4910      	ldr	r1, [pc, #64]	; (35354 <z_tick_get+0x9c>)
   35314:	480c      	ldr	r0, [pc, #48]	; (35348 <z_tick_get+0x90>)
   35316:	f002 fcd3 	bl	37cc0 <printk>
   3531a:	4908      	ldr	r1, [pc, #32]	; (3533c <z_tick_get+0x84>)
   3531c:	480e      	ldr	r0, [pc, #56]	; (35358 <z_tick_get+0xa0>)
   3531e:	f002 fccf 	bl	37cc0 <printk>
   35322:	215d      	movs	r1, #93	; 0x5d
   35324:	4806      	ldr	r0, [pc, #24]	; (35340 <z_tick_get+0x88>)
   35326:	f002 fd11 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   3532a:	f386 8811 	msr	BASEPRI, r6
   3532e:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   35332:	4638      	mov	r0, r7
   35334:	4641      	mov	r1, r8
   35336:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   3533a:	bf00      	nop
   3533c:	20022220 	.word	0x20022220
   35340:	0003ba71 	.word	0x0003ba71
   35344:	0003ba97 	.word	0x0003ba97
   35348:	0003baac 	.word	0x0003baac
   3534c:	0003bac9 	.word	0x0003bac9
   35350:	200200e0 	.word	0x200200e0
   35354:	0003bb0b 	.word	0x0003bb0b
   35358:	0003bb22 	.word	0x0003bb22

0003535c <z_timer_expiration_handler>:

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
   3535c:	6a02      	ldr	r2, [r0, #32]
{
   3535e:	b538      	push	{r3, r4, r5, lr}
	if (timer->period > 0) {
   35360:	2a00      	cmp	r2, #0
{
   35362:	4604      	mov	r4, r0
	if (timer->period > 0) {
   35364:	dd02      	ble.n	3536c <z_timer_expiration_handler+0x10>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   35366:	490e      	ldr	r1, [pc, #56]	; (353a0 <z_timer_expiration_handler+0x44>)
   35368:	f7ff fd08 	bl	34d7c <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   3536c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   3536e:	3301      	adds	r3, #1
   35370:	6263      	str	r3, [r4, #36]	; 0x24

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   35372:	69a3      	ldr	r3, [r4, #24]
   35374:	b10b      	cbz	r3, 3537a <z_timer_expiration_handler+0x1e>
		timer->expiry_fn(timer);
   35376:	4620      	mov	r0, r4
   35378:	4798      	blx	r3
	return list->head == list;
   3537a:	f854 5f10 	ldr.w	r5, [r4, #16]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   3537e:	42a5      	cmp	r5, r4
   35380:	d00d      	beq.n	3539e <z_timer_expiration_handler+0x42>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   35382:	b165      	cbz	r5, 3539e <z_timer_expiration_handler+0x42>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
   35384:	4628      	mov	r0, r5
   35386:	f7fe f88f 	bl	334a8 <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   3538a:	7b6b      	ldrb	r3, [r5, #13]
   3538c:	06db      	lsls	r3, r3, #27
   3538e:	d104      	bne.n	3539a <z_timer_expiration_handler+0x3e>
	if (z_is_thread_ready(thread)) {
   35390:	69ab      	ldr	r3, [r5, #24]
   35392:	b913      	cbnz	r3, 3539a <z_timer_expiration_handler+0x3e>
		z_add_thread_to_ready_q(thread);
   35394:	4628      	mov	r0, r5
   35396:	f7fe fac3 	bl	33920 <z_add_thread_to_ready_q>
   3539a:	2300      	movs	r3, #0
   3539c:	66ab      	str	r3, [r5, #104]	; 0x68

	z_ready_thread(thread);

	arch_thread_return_value_set(thread, 0);
}
   3539e:	bd38      	pop	{r3, r4, r5, pc}
   353a0:	0003535d 	.word	0x0003535d

000353a4 <z_impl_k_timer_start>:
	z_object_init(timer);
}


void z_impl_k_timer_start(struct k_timer *timer, s32_t duration, s32_t period)
{
   353a4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	__ASSERT(duration >= 0 && period >= 0 &&
   353a8:	f1b1 0900 	subs.w	r9, r1, #0
{
   353ac:	4604      	mov	r4, r0
   353ae:	4615      	mov	r5, r2
	__ASSERT(duration >= 0 && period >= 0 &&
   353b0:	db04      	blt.n	353bc <z_impl_k_timer_start+0x18>
   353b2:	2a00      	cmp	r2, #0
   353b4:	db02      	blt.n	353bc <z_impl_k_timer_start+0x18>
   353b6:	ea59 0302 	orrs.w	r3, r9, r2
   353ba:	d10c      	bne.n	353d6 <z_impl_k_timer_start+0x32>
   353bc:	491a      	ldr	r1, [pc, #104]	; (35428 <z_impl_k_timer_start+0x84>)
   353be:	236f      	movs	r3, #111	; 0x6f
   353c0:	4a1a      	ldr	r2, [pc, #104]	; (3542c <z_impl_k_timer_start+0x88>)
   353c2:	481b      	ldr	r0, [pc, #108]	; (35430 <z_impl_k_timer_start+0x8c>)
   353c4:	f002 fc7c 	bl	37cc0 <printk>
   353c8:	481a      	ldr	r0, [pc, #104]	; (35434 <z_impl_k_timer_start+0x90>)
   353ca:	f002 fc79 	bl	37cc0 <printk>
   353ce:	216f      	movs	r1, #111	; 0x6f
   353d0:	4816      	ldr	r0, [pc, #88]	; (3542c <z_impl_k_timer_start+0x88>)
   353d2:	f002 fcbb 	bl	37d4c <assert_post_action>
   353d6:	f240 36e7 	movw	r6, #999	; 0x3e7
   353da:	2700      	movs	r7, #0
   353dc:	f44f 4800 	mov.w	r8, #32768	; 0x8000
   353e0:	4630      	mov	r0, r6
   353e2:	4639      	mov	r1, r7
   353e4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   353e8:	2300      	movs	r3, #0
   353ea:	fbe8 0105 	umlal	r0, r1, r8, r5
   353ee:	f7e7 fced 	bl	1cdcc <__aeabi_uldivmod>
   353f2:	4639      	mov	r1, r7
		 (duration != 0 || period != 0), "invalid parameters\n");

	volatile s32_t period_in_ticks, duration_in_ticks;

	period_in_ticks = k_ms_to_ticks_ceil32(period);
   353f4:	9000      	str	r0, [sp, #0]
   353f6:	4630      	mov	r0, r6
   353f8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   353fc:	2300      	movs	r3, #0
   353fe:	fbe8 0109 	umlal	r0, r1, r8, r9
   35402:	f7e7 fce3 	bl	1cdcc <__aeabi_uldivmod>
	duration_in_ticks = k_ms_to_ticks_ceil32(duration);
   35406:	9001      	str	r0, [sp, #4]

	(void)z_abort_timeout(&timer->timeout);
   35408:	4620      	mov	r0, r4
   3540a:	f7ff fd5d 	bl	34ec8 <z_abort_timeout>
	timer->period = period_in_ticks;
   3540e:	9b00      	ldr	r3, [sp, #0]
	timer->status = 0U;
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   35410:	4620      	mov	r0, r4
	timer->period = period_in_ticks;
   35412:	6223      	str	r3, [r4, #32]
	timer->status = 0U;
   35414:	2300      	movs	r3, #0
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   35416:	9a01      	ldr	r2, [sp, #4]
   35418:	4907      	ldr	r1, [pc, #28]	; (35438 <z_impl_k_timer_start+0x94>)
	timer->status = 0U;
   3541a:	6263      	str	r3, [r4, #36]	; 0x24
		     duration_in_ticks);
}
   3541c:	b003      	add	sp, #12
   3541e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   35422:	f7ff bcab 	b.w	34d7c <z_add_timeout>
   35426:	bf00      	nop
   35428:	0003f336 	.word	0x0003f336
   3542c:	0003f314 	.word	0x0003f314
   35430:	0003baac 	.word	0x0003baac
   35434:	0003f375 	.word	0x0003f375
   35438:	0003535d 	.word	0x0003535d

0003543c <k_poll_poller_cb>:

	return events_registered;
}

static int k_poll_poller_cb(struct k_poll_event *event, u32_t state)
{
   3543c:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = event->poller->thread;
   3543e:	6883      	ldr	r3, [r0, #8]
{
   35440:	460d      	mov	r5, r1
	struct k_thread *thread = event->poller->thread;
   35442:	685c      	ldr	r4, [r3, #4]

	__ASSERT(thread != NULL, "poller should have a thread\n");
   35444:	b964      	cbnz	r4, 35460 <k_poll_poller_cb+0x24>
   35446:	4915      	ldr	r1, [pc, #84]	; (3549c <k_poll_poller_cb+0x60>)
   35448:	23e0      	movs	r3, #224	; 0xe0
   3544a:	4a15      	ldr	r2, [pc, #84]	; (354a0 <k_poll_poller_cb+0x64>)
   3544c:	4815      	ldr	r0, [pc, #84]	; (354a4 <k_poll_poller_cb+0x68>)
   3544e:	f002 fc37 	bl	37cc0 <printk>
   35452:	4815      	ldr	r0, [pc, #84]	; (354a8 <k_poll_poller_cb+0x6c>)
   35454:	f002 fc34 	bl	37cc0 <printk>
   35458:	21e0      	movs	r1, #224	; 0xe0
   3545a:	4811      	ldr	r0, [pc, #68]	; (354a0 <k_poll_poller_cb+0x64>)
   3545c:	f002 fc76 	bl	37d4c <assert_post_action>

	if (!z_is_thread_pending(thread)) {
   35460:	7b63      	ldrb	r3, [r4, #13]
   35462:	079a      	lsls	r2, r3, #30
   35464:	d401      	bmi.n	3546a <k_poll_poller_cb+0x2e>
		return 0;
   35466:	2000      	movs	r0, #0
	}

	z_ready_thread(thread);

	return 0;
}
   35468:	bd38      	pop	{r3, r4, r5, pc}
	if (z_is_thread_timeout_expired(thread)) {
   3546a:	6a23      	ldr	r3, [r4, #32]
   3546c:	3302      	adds	r3, #2
   3546e:	d012      	beq.n	35496 <k_poll_poller_cb+0x5a>
	z_unpend_thread(thread);
   35470:	4620      	mov	r0, r4
   35472:	f7fe f94d 	bl	33710 <z_unpend_thread>
	arch_thread_return_value_set(thread,
   35476:	2d08      	cmp	r5, #8
   35478:	bf0c      	ite	eq
   3547a:	f06f 0303 	mvneq.w	r3, #3
   3547e:	2300      	movne	r3, #0
   35480:	66a3      	str	r3, [r4, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   35482:	7b63      	ldrb	r3, [r4, #13]
   35484:	06db      	lsls	r3, r3, #27
   35486:	d1ee      	bne.n	35466 <k_poll_poller_cb+0x2a>
	if (!z_is_thread_ready(thread)) {
   35488:	69a5      	ldr	r5, [r4, #24]
   3548a:	2d00      	cmp	r5, #0
   3548c:	d1eb      	bne.n	35466 <k_poll_poller_cb+0x2a>
		z_add_thread_to_ready_q(thread);
   3548e:	4620      	mov	r0, r4
   35490:	f7fe fa46 	bl	33920 <z_add_thread_to_ready_q>
	return 0;
   35494:	e7e7      	b.n	35466 <k_poll_poller_cb+0x2a>
		return -EAGAIN;
   35496:	f06f 000a 	mvn.w	r0, #10
   3549a:	e7e5      	b.n	35468 <k_poll_poller_cb+0x2c>
   3549c:	0003f4f9 	.word	0x0003f4f9
   354a0:	0003f4d8 	.word	0x0003f4d8
   354a4:	0003baac 	.word	0x0003baac
   354a8:	0003f50f 	.word	0x0003f50f

000354ac <clear_event_registrations>:
{
   354ac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   354b0:	2414      	movs	r4, #20
   354b2:	4680      	mov	r8, r0
   354b4:	4617      	mov	r7, r2
	while (num_events--) {
   354b6:	fb04 0401 	mla	r4, r4, r1, r0
		__ASSERT(false, "invalid event type\n");
   354ba:	4d48      	ldr	r5, [pc, #288]	; (355dc <clear_event_registrations+0x130>)
   354bc:	f8df 9158 	ldr.w	r9, [pc, #344]	; 35618 <clear_event_registrations+0x16c>
   354c0:	4e47      	ldr	r6, [pc, #284]	; (355e0 <clear_event_registrations+0x134>)
	while (num_events--) {
   354c2:	4544      	cmp	r4, r8
   354c4:	d101      	bne.n	354ca <clear_event_registrations+0x1e>
}
   354c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	event->poller = NULL;
   354ca:	2300      	movs	r3, #0
   354cc:	f844 3c0c 	str.w	r3, [r4, #-12]
	switch (event->type) {
   354d0:	f814 3c07 	ldrb.w	r3, [r4, #-7]
   354d4:	f003 030f 	and.w	r3, r3, #15
   354d8:	2b04      	cmp	r3, #4
   354da:	d83d      	bhi.n	35558 <clear_event_registrations+0xac>
   354dc:	e8df f003 	tbb	[pc, r3]
   354e0:	3c032d49 	.word	0x3c032d49
   354e4:	1e          	.byte	0x1e
   354e5:	00          	.byte	0x00
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
   354e6:	f854 3c04 	ldr.w	r3, [r4, #-4]
   354ea:	b963      	cbnz	r3, 35506 <clear_event_registrations+0x5a>
   354ec:	493d      	ldr	r1, [pc, #244]	; (355e4 <clear_event_registrations+0x138>)
   354ee:	2396      	movs	r3, #150	; 0x96
   354f0:	462a      	mov	r2, r5
   354f2:	4630      	mov	r0, r6
   354f4:	f002 fbe4 	bl	37cc0 <printk>
   354f8:	483b      	ldr	r0, [pc, #236]	; (355e8 <clear_event_registrations+0x13c>)
   354fa:	f002 fbe1 	bl	37cc0 <printk>
   354fe:	2196      	movs	r1, #150	; 0x96
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   35500:	4628      	mov	r0, r5
   35502:	f002 fc23 	bl	37d4c <assert_post_action>
	if (remove && sys_dnode_is_linked(&event->_node)) {
   35506:	f854 3c14 	ldr.w	r3, [r4, #-20]
   3550a:	b393      	cbz	r3, 35572 <clear_event_registrations+0xc6>
	node->prev->next = node->next;
   3550c:	f854 2c10 	ldr.w	r2, [r4, #-16]
   35510:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   35512:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   35514:	2300      	movs	r3, #0
	node->prev = NULL;
   35516:	e944 3305 	strd	r3, r3, [r4, #-20]
   3551a:	e02a      	b.n	35572 <clear_event_registrations+0xc6>
		__ASSERT(event->queue != NULL, "invalid queue\n");
   3551c:	f854 3c04 	ldr.w	r3, [r4, #-4]
   35520:	2b00      	cmp	r3, #0
   35522:	d1f0      	bne.n	35506 <clear_event_registrations+0x5a>
   35524:	4931      	ldr	r1, [pc, #196]	; (355ec <clear_event_registrations+0x140>)
   35526:	239a      	movs	r3, #154	; 0x9a
   35528:	462a      	mov	r2, r5
   3552a:	4630      	mov	r0, r6
   3552c:	f002 fbc8 	bl	37cc0 <printk>
   35530:	482f      	ldr	r0, [pc, #188]	; (355f0 <clear_event_registrations+0x144>)
   35532:	f002 fbc5 	bl	37cc0 <printk>
   35536:	219a      	movs	r1, #154	; 0x9a
   35538:	e7e2      	b.n	35500 <clear_event_registrations+0x54>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   3553a:	f854 3c04 	ldr.w	r3, [r4, #-4]
   3553e:	2b00      	cmp	r3, #0
   35540:	d1e1      	bne.n	35506 <clear_event_registrations+0x5a>
   35542:	492c      	ldr	r1, [pc, #176]	; (355f4 <clear_event_registrations+0x148>)
   35544:	239e      	movs	r3, #158	; 0x9e
   35546:	462a      	mov	r2, r5
   35548:	4630      	mov	r0, r6
   3554a:	f002 fbb9 	bl	37cc0 <printk>
   3554e:	482a      	ldr	r0, [pc, #168]	; (355f8 <clear_event_registrations+0x14c>)
   35550:	f002 fbb6 	bl	37cc0 <printk>
   35554:	219e      	movs	r1, #158	; 0x9e
   35556:	e7d3      	b.n	35500 <clear_event_registrations+0x54>
		__ASSERT(false, "invalid event type\n");
   35558:	4649      	mov	r1, r9
   3555a:	23a5      	movs	r3, #165	; 0xa5
   3555c:	462a      	mov	r2, r5
   3555e:	4630      	mov	r0, r6
   35560:	f002 fbae 	bl	37cc0 <printk>
   35564:	4825      	ldr	r0, [pc, #148]	; (355fc <clear_event_registrations+0x150>)
   35566:	f002 fbab 	bl	37cc0 <printk>
   3556a:	21a5      	movs	r1, #165	; 0xa5
   3556c:	4628      	mov	r0, r5
   3556e:	f002 fbed 	bl	37d4c <assert_post_action>
   35572:	4823      	ldr	r0, [pc, #140]	; (35600 <clear_event_registrations+0x154>)
   35574:	f7ff f976 	bl	34864 <z_spin_unlock_valid>
   35578:	b968      	cbnz	r0, 35596 <clear_event_registrations+0xea>
   3557a:	235d      	movs	r3, #93	; 0x5d
   3557c:	4a21      	ldr	r2, [pc, #132]	; (35604 <clear_event_registrations+0x158>)
   3557e:	4922      	ldr	r1, [pc, #136]	; (35608 <clear_event_registrations+0x15c>)
   35580:	4630      	mov	r0, r6
   35582:	f002 fb9d 	bl	37cc0 <printk>
   35586:	491e      	ldr	r1, [pc, #120]	; (35600 <clear_event_registrations+0x154>)
   35588:	4820      	ldr	r0, [pc, #128]	; (3560c <clear_event_registrations+0x160>)
   3558a:	f002 fb99 	bl	37cc0 <printk>
   3558e:	215d      	movs	r1, #93	; 0x5d
   35590:	481c      	ldr	r0, [pc, #112]	; (35604 <clear_event_registrations+0x158>)
   35592:	f002 fbdb 	bl	37d4c <assert_post_action>
   35596:	f387 8811 	msr	BASEPRI, r7
   3559a:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   3559e:	f04f 0320 	mov.w	r3, #32
   355a2:	f3ef 8711 	mrs	r7, BASEPRI
   355a6:	f383 8811 	msr	BASEPRI, r3
   355aa:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   355ae:	4814      	ldr	r0, [pc, #80]	; (35600 <clear_event_registrations+0x154>)
   355b0:	f7ff f94a 	bl	34848 <z_spin_lock_valid>
   355b4:	b968      	cbnz	r0, 355d2 <clear_event_registrations+0x126>
   355b6:	234a      	movs	r3, #74	; 0x4a
   355b8:	4a12      	ldr	r2, [pc, #72]	; (35604 <clear_event_registrations+0x158>)
   355ba:	4915      	ldr	r1, [pc, #84]	; (35610 <clear_event_registrations+0x164>)
   355bc:	4630      	mov	r0, r6
   355be:	f002 fb7f 	bl	37cc0 <printk>
   355c2:	490f      	ldr	r1, [pc, #60]	; (35600 <clear_event_registrations+0x154>)
   355c4:	4813      	ldr	r0, [pc, #76]	; (35614 <clear_event_registrations+0x168>)
   355c6:	f002 fb7b 	bl	37cc0 <printk>
   355ca:	214a      	movs	r1, #74	; 0x4a
   355cc:	480d      	ldr	r0, [pc, #52]	; (35604 <clear_event_registrations+0x158>)
   355ce:	f002 fbbd 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   355d2:	480b      	ldr	r0, [pc, #44]	; (35600 <clear_event_registrations+0x154>)
   355d4:	f7ff f956 	bl	34884 <z_spin_lock_set_owner>
	return k;
   355d8:	3c14      	subs	r4, #20
   355da:	e772      	b.n	354c2 <clear_event_registrations+0x16>
   355dc:	0003f4d8 	.word	0x0003f4d8
   355e0:	0003baac 	.word	0x0003baac
   355e4:	0003f38b 	.word	0x0003f38b
   355e8:	0003f3a5 	.word	0x0003f3a5
   355ec:	0003f3ba 	.word	0x0003f3ba
   355f0:	0003f3d6 	.word	0x0003f3d6
   355f4:	0003f3e7 	.word	0x0003f3e7
   355f8:	0003f404 	.word	0x0003f404
   355fc:	0003f41b 	.word	0x0003f41b
   35600:	20022224 	.word	0x20022224
   35604:	0003ba71 	.word	0x0003ba71
   35608:	0003bb0b 	.word	0x0003bb0b
   3560c:	0003bb22 	.word	0x0003bb22
   35610:	0003ba97 	.word	0x0003ba97
   35614:	0003bac9 	.word	0x0003bac9
   35618:	0003f10e 	.word	0x0003f10e

0003561c <register_events>:
{
   3561c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
   35620:	2700      	movs	r7, #0
{
   35622:	468a      	mov	sl, r1
   35624:	4615      	mov	r5, r2
   35626:	4604      	mov	r4, r0
	int events_registered = 0;
   35628:	46b9      	mov	r9, r7
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   3562a:	4e69      	ldr	r6, [pc, #420]	; (357d0 <register_events+0x1b4>)
   3562c:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 35810 <register_events+0x1f4>
{
   35630:	9301      	str	r3, [sp, #4]
	for (int ii = 0; ii < num_events; ii++) {
   35632:	4557      	cmp	r7, sl
   35634:	db03      	blt.n	3563e <register_events+0x22>
}
   35636:	4648      	mov	r0, r9
   35638:	b003      	add	sp, #12
   3563a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3563e:	f04f 0320 	mov.w	r3, #32
   35642:	f3ef 8b11 	mrs	fp, BASEPRI
   35646:	f383 8811 	msr	BASEPRI, r3
   3564a:	f3bf 8f6f 	isb	sy
   3564e:	4630      	mov	r0, r6
   35650:	f7ff f8fa 	bl	34848 <z_spin_lock_valid>
   35654:	b968      	cbnz	r0, 35672 <register_events+0x56>
   35656:	234a      	movs	r3, #74	; 0x4a
   35658:	4642      	mov	r2, r8
   3565a:	495e      	ldr	r1, [pc, #376]	; (357d4 <register_events+0x1b8>)
   3565c:	485e      	ldr	r0, [pc, #376]	; (357d8 <register_events+0x1bc>)
   3565e:	f002 fb2f 	bl	37cc0 <printk>
   35662:	4631      	mov	r1, r6
   35664:	485d      	ldr	r0, [pc, #372]	; (357dc <register_events+0x1c0>)
   35666:	f002 fb2b 	bl	37cc0 <printk>
   3566a:	214a      	movs	r1, #74	; 0x4a
   3566c:	4640      	mov	r0, r8
   3566e:	f002 fb6d 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   35672:	4630      	mov	r0, r6
   35674:	f7ff f906 	bl	34884 <z_spin_lock_set_owner>
	switch (event->type) {
   35678:	7b63      	ldrb	r3, [r4, #13]
   3567a:	f003 030f 	and.w	r3, r3, #15
   3567e:	2b04      	cmp	r3, #4
   35680:	d844      	bhi.n	3570c <register_events+0xf0>
   35682:	e8df f003 	tbb	[pc, r3]
   35686:	3d2d      	.short	0x3d2d
   35688:	4303      	.short	0x4303
   3568a:	2a          	.byte	0x2a
   3568b:	00          	.byte	0x00
		if (k_sem_count_get(event->sem) > 0) {
   3568c:	6923      	ldr	r3, [r4, #16]
   3568e:	689b      	ldr	r3, [r3, #8]
   35690:	b333      	cbz	r3, 356e0 <register_events+0xc4>
			*state = K_POLL_STATE_SEM_AVAILABLE;
   35692:	2202      	movs	r2, #2
	event->poller = NULL;
   35694:	2100      	movs	r1, #0
	event->state |= state;
   35696:	68e3      	ldr	r3, [r4, #12]
	event->poller = NULL;
   35698:	60a1      	str	r1, [r4, #8]
	event->state |= state;
   3569a:	f3c3 3004 	ubfx	r0, r3, #12, #5
   3569e:	4302      	orrs	r2, r0
   356a0:	f362 3310 	bfi	r3, r2, #12, #5
   356a4:	60e3      	str	r3, [r4, #12]
			poller->is_polling = false;
   356a6:	7029      	strb	r1, [r5, #0]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   356a8:	4630      	mov	r0, r6
   356aa:	f7ff f8db 	bl	34864 <z_spin_unlock_valid>
   356ae:	b968      	cbnz	r0, 356cc <register_events+0xb0>
   356b0:	235d      	movs	r3, #93	; 0x5d
   356b2:	4642      	mov	r2, r8
   356b4:	494a      	ldr	r1, [pc, #296]	; (357e0 <register_events+0x1c4>)
   356b6:	4848      	ldr	r0, [pc, #288]	; (357d8 <register_events+0x1bc>)
   356b8:	f002 fb02 	bl	37cc0 <printk>
   356bc:	4631      	mov	r1, r6
   356be:	4849      	ldr	r0, [pc, #292]	; (357e4 <register_events+0x1c8>)
   356c0:	f002 fafe 	bl	37cc0 <printk>
   356c4:	215d      	movs	r1, #93	; 0x5d
   356c6:	4640      	mov	r0, r8
   356c8:	f002 fb40 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   356cc:	f38b 8811 	msr	BASEPRI, fp
   356d0:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   356d4:	3701      	adds	r7, #1
   356d6:	3414      	adds	r4, #20
   356d8:	e7ab      	b.n	35632 <register_events+0x16>
		if (!k_queue_is_empty(event->queue)) {
   356da:	6923      	ldr	r3, [r4, #16]
   356dc:	681b      	ldr	r3, [r3, #0]
   356de:	bb33      	cbnz	r3, 3572e <register_events+0x112>
		} else if (!just_check && poller->is_polling) {
   356e0:	9b01      	ldr	r3, [sp, #4]
   356e2:	2b00      	cmp	r3, #0
   356e4:	d1e0      	bne.n	356a8 <register_events+0x8c>
   356e6:	782b      	ldrb	r3, [r5, #0]
   356e8:	2b00      	cmp	r3, #0
   356ea:	d0dd      	beq.n	356a8 <register_events+0x8c>
	switch (event->type) {
   356ec:	7b63      	ldrb	r3, [r4, #13]
   356ee:	f003 030f 	and.w	r3, r3, #15
   356f2:	2b04      	cmp	r3, #4
   356f4:	d85d      	bhi.n	357b2 <register_events+0x196>
   356f6:	e8df f003 	tbb	[pc, r3]
   356fa:	4931      	.short	0x4931
   356fc:	5c1c      	.short	0x5c1c
   356fe:	35          	.byte	0x35
   356ff:	00          	.byte	0x00
		if (event->signal->signaled != 0U) {
   35700:	6923      	ldr	r3, [r4, #16]
   35702:	689b      	ldr	r3, [r3, #8]
   35704:	2b00      	cmp	r3, #0
   35706:	d0eb      	beq.n	356e0 <register_events+0xc4>
			*state = K_POLL_STATE_SIGNALED;
   35708:	2201      	movs	r2, #1
   3570a:	e7c3      	b.n	35694 <register_events+0x78>
		__ASSERT(false, "invalid event type (0x%x)\n", event->type);
   3570c:	2350      	movs	r3, #80	; 0x50
   3570e:	4a36      	ldr	r2, [pc, #216]	; (357e8 <register_events+0x1cc>)
   35710:	4936      	ldr	r1, [pc, #216]	; (357ec <register_events+0x1d0>)
   35712:	4831      	ldr	r0, [pc, #196]	; (357d8 <register_events+0x1bc>)
   35714:	f002 fad4 	bl	37cc0 <printk>
   35718:	7b61      	ldrb	r1, [r4, #13]
   3571a:	4835      	ldr	r0, [pc, #212]	; (357f0 <register_events+0x1d4>)
   3571c:	f001 010f 	and.w	r1, r1, #15
   35720:	f002 face 	bl	37cc0 <printk>
   35724:	2150      	movs	r1, #80	; 0x50
   35726:	4830      	ldr	r0, [pc, #192]	; (357e8 <register_events+0x1cc>)
   35728:	f002 fb10 	bl	37d4c <assert_post_action>
		break;
   3572c:	e7d8      	b.n	356e0 <register_events+0xc4>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
   3572e:	2204      	movs	r2, #4
   35730:	e7b0      	b.n	35694 <register_events+0x78>
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
   35732:	6923      	ldr	r3, [r4, #16]
   35734:	b963      	cbnz	r3, 35750 <register_events+0x134>
   35736:	492f      	ldr	r1, [pc, #188]	; (357f4 <register_events+0x1d8>)
   35738:	2375      	movs	r3, #117	; 0x75
   3573a:	4a2b      	ldr	r2, [pc, #172]	; (357e8 <register_events+0x1cc>)
   3573c:	4826      	ldr	r0, [pc, #152]	; (357d8 <register_events+0x1bc>)
   3573e:	f002 fabf 	bl	37cc0 <printk>
   35742:	482d      	ldr	r0, [pc, #180]	; (357f8 <register_events+0x1dc>)
   35744:	f002 fabc 	bl	37cc0 <printk>
   35748:	2175      	movs	r1, #117	; 0x75
   3574a:	4827      	ldr	r0, [pc, #156]	; (357e8 <register_events+0x1cc>)
   3574c:	f002 fafe 	bl	37d4c <assert_post_action>
		add_event(&event->sem->poll_events, event, poller);
   35750:	462a      	mov	r2, r5
   35752:	4621      	mov	r1, r4
   35754:	6920      	ldr	r0, [r4, #16]
   35756:	3010      	adds	r0, #16
		add_event(&event->queue->poll_events, event, poller);
   35758:	f004 fab4 	bl	39cc4 <add_event>
	event->poller = poller;
   3575c:	60a5      	str	r5, [r4, #8]
				events_registered += 1;
   3575e:	f109 0901 	add.w	r9, r9, #1
   35762:	e7a1      	b.n	356a8 <register_events+0x8c>
		__ASSERT(event->queue != NULL, "invalid queue\n");
   35764:	6923      	ldr	r3, [r4, #16]
   35766:	b963      	cbnz	r3, 35782 <register_events+0x166>
   35768:	4924      	ldr	r1, [pc, #144]	; (357fc <register_events+0x1e0>)
   3576a:	2379      	movs	r3, #121	; 0x79
   3576c:	4a1e      	ldr	r2, [pc, #120]	; (357e8 <register_events+0x1cc>)
   3576e:	481a      	ldr	r0, [pc, #104]	; (357d8 <register_events+0x1bc>)
   35770:	f002 faa6 	bl	37cc0 <printk>
   35774:	4822      	ldr	r0, [pc, #136]	; (35800 <register_events+0x1e4>)
   35776:	f002 faa3 	bl	37cc0 <printk>
   3577a:	2179      	movs	r1, #121	; 0x79
   3577c:	481a      	ldr	r0, [pc, #104]	; (357e8 <register_events+0x1cc>)
   3577e:	f002 fae5 	bl	37d4c <assert_post_action>
		add_event(&event->queue->poll_events, event, poller);
   35782:	6920      	ldr	r0, [r4, #16]
   35784:	462a      	mov	r2, r5
   35786:	4621      	mov	r1, r4
   35788:	300c      	adds	r0, #12
   3578a:	e7e5      	b.n	35758 <register_events+0x13c>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   3578c:	6923      	ldr	r3, [r4, #16]
   3578e:	b963      	cbnz	r3, 357aa <register_events+0x18e>
   35790:	491c      	ldr	r1, [pc, #112]	; (35804 <register_events+0x1e8>)
   35792:	237d      	movs	r3, #125	; 0x7d
   35794:	4a14      	ldr	r2, [pc, #80]	; (357e8 <register_events+0x1cc>)
   35796:	4810      	ldr	r0, [pc, #64]	; (357d8 <register_events+0x1bc>)
   35798:	f002 fa92 	bl	37cc0 <printk>
   3579c:	481a      	ldr	r0, [pc, #104]	; (35808 <register_events+0x1ec>)
   3579e:	f002 fa8f 	bl	37cc0 <printk>
   357a2:	217d      	movs	r1, #125	; 0x7d
   357a4:	4810      	ldr	r0, [pc, #64]	; (357e8 <register_events+0x1cc>)
   357a6:	f002 fad1 	bl	37d4c <assert_post_action>
		add_event(&event->signal->poll_events, event, poller);
   357aa:	462a      	mov	r2, r5
   357ac:	4621      	mov	r1, r4
   357ae:	6920      	ldr	r0, [r4, #16]
   357b0:	e7d2      	b.n	35758 <register_events+0x13c>
		__ASSERT(false, "invalid event type\n");
   357b2:	2384      	movs	r3, #132	; 0x84
   357b4:	4a0c      	ldr	r2, [pc, #48]	; (357e8 <register_events+0x1cc>)
   357b6:	490d      	ldr	r1, [pc, #52]	; (357ec <register_events+0x1d0>)
   357b8:	4807      	ldr	r0, [pc, #28]	; (357d8 <register_events+0x1bc>)
   357ba:	f002 fa81 	bl	37cc0 <printk>
   357be:	4813      	ldr	r0, [pc, #76]	; (3580c <register_events+0x1f0>)
   357c0:	f002 fa7e 	bl	37cc0 <printk>
   357c4:	2184      	movs	r1, #132	; 0x84
   357c6:	4808      	ldr	r0, [pc, #32]	; (357e8 <register_events+0x1cc>)
   357c8:	f002 fac0 	bl	37d4c <assert_post_action>
		break;
   357cc:	e7c6      	b.n	3575c <register_events+0x140>
   357ce:	bf00      	nop
   357d0:	20022224 	.word	0x20022224
   357d4:	0003ba97 	.word	0x0003ba97
   357d8:	0003baac 	.word	0x0003baac
   357dc:	0003bac9 	.word	0x0003bac9
   357e0:	0003bb0b 	.word	0x0003bb0b
   357e4:	0003bb22 	.word	0x0003bb22
   357e8:	0003f4d8 	.word	0x0003f4d8
   357ec:	0003f10e 	.word	0x0003f10e
   357f0:	0003f52e 	.word	0x0003f52e
   357f4:	0003f38b 	.word	0x0003f38b
   357f8:	0003f3a5 	.word	0x0003f3a5
   357fc:	0003f3ba 	.word	0x0003f3ba
   35800:	0003f3d6 	.word	0x0003f3d6
   35804:	0003f3e7 	.word	0x0003f3e7
   35808:	0003f404 	.word	0x0003f404
   3580c:	0003f41b 	.word	0x0003f41b
   35810:	0003ba71 	.word	0x0003ba71

00035814 <k_poll_event_init>:
{
   35814:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   35816:	4604      	mov	r4, r0
   35818:	460f      	mov	r7, r1
   3581a:	461d      	mov	r5, r3
	__ASSERT(mode == K_POLL_MODE_NOTIFY_ONLY,
   3581c:	4616      	mov	r6, r2
   3581e:	b162      	cbz	r2, 3583a <k_poll_event_init+0x26>
   35820:	491c      	ldr	r1, [pc, #112]	; (35894 <k_poll_event_init+0x80>)
   35822:	232a      	movs	r3, #42	; 0x2a
   35824:	4a1c      	ldr	r2, [pc, #112]	; (35898 <k_poll_event_init+0x84>)
   35826:	481d      	ldr	r0, [pc, #116]	; (3589c <k_poll_event_init+0x88>)
   35828:	f002 fa4a 	bl	37cc0 <printk>
   3582c:	481c      	ldr	r0, [pc, #112]	; (358a0 <k_poll_event_init+0x8c>)
   3582e:	f002 fa47 	bl	37cc0 <printk>
   35832:	212a      	movs	r1, #42	; 0x2a
   35834:	4818      	ldr	r0, [pc, #96]	; (35898 <k_poll_event_init+0x84>)
   35836:	f002 fa89 	bl	37d4c <assert_post_action>
	__ASSERT(type < (BIT(_POLL_NUM_TYPES)), "invalid type\n");
   3583a:	2f0f      	cmp	r7, #15
   3583c:	d90c      	bls.n	35858 <k_poll_event_init+0x44>
   3583e:	4919      	ldr	r1, [pc, #100]	; (358a4 <k_poll_event_init+0x90>)
   35840:	232b      	movs	r3, #43	; 0x2b
   35842:	4a15      	ldr	r2, [pc, #84]	; (35898 <k_poll_event_init+0x84>)
   35844:	4815      	ldr	r0, [pc, #84]	; (3589c <k_poll_event_init+0x88>)
   35846:	f002 fa3b 	bl	37cc0 <printk>
   3584a:	4817      	ldr	r0, [pc, #92]	; (358a8 <k_poll_event_init+0x94>)
   3584c:	f002 fa38 	bl	37cc0 <printk>
   35850:	212b      	movs	r1, #43	; 0x2b
   35852:	4811      	ldr	r0, [pc, #68]	; (35898 <k_poll_event_init+0x84>)
   35854:	f002 fa7a 	bl	37d4c <assert_post_action>
	__ASSERT(obj != NULL, "must provide an object\n");
   35858:	b965      	cbnz	r5, 35874 <k_poll_event_init+0x60>
   3585a:	4914      	ldr	r1, [pc, #80]	; (358ac <k_poll_event_init+0x98>)
   3585c:	232c      	movs	r3, #44	; 0x2c
   3585e:	4a0e      	ldr	r2, [pc, #56]	; (35898 <k_poll_event_init+0x84>)
   35860:	480e      	ldr	r0, [pc, #56]	; (3589c <k_poll_event_init+0x88>)
   35862:	f002 fa2d 	bl	37cc0 <printk>
   35866:	4812      	ldr	r0, [pc, #72]	; (358b0 <k_poll_event_init+0x9c>)
   35868:	f002 fa2a 	bl	37cc0 <printk>
   3586c:	212c      	movs	r1, #44	; 0x2c
   3586e:	480a      	ldr	r0, [pc, #40]	; (35898 <k_poll_event_init+0x84>)
   35870:	f002 fa6c 	bl	37d4c <assert_post_action>
	event->type = type;
   35874:	7b63      	ldrb	r3, [r4, #13]
   35876:	f367 0303 	bfi	r3, r7, #0, #4
   3587a:	7363      	strb	r3, [r4, #13]
	event->mode = mode;
   3587c:	7ba3      	ldrb	r3, [r4, #14]
   3587e:	f366 0341 	bfi	r3, r6, #1, #1
   35882:	73a3      	strb	r3, [r4, #14]
	event->poller = NULL;
   35884:	2300      	movs	r3, #0
	event->state = K_POLL_STATE_NOT_READY;
   35886:	68e2      	ldr	r2, [r4, #12]
	event->poller = NULL;
   35888:	60a3      	str	r3, [r4, #8]
	event->state = K_POLL_STATE_NOT_READY;
   3588a:	4b0a      	ldr	r3, [pc, #40]	; (358b4 <k_poll_event_init+0xa0>)
   3588c:	4013      	ands	r3, r2
	event->obj = obj;
   3588e:	e9c4 3503 	strd	r3, r5, [r4, #12]
}
   35892:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   35894:	0003f431 	.word	0x0003f431
   35898:	0003f4d8 	.word	0x0003f4d8
   3589c:	0003baac 	.word	0x0003baac
   358a0:	0003f451 	.word	0x0003f451
   358a4:	0003f477 	.word	0x0003f477
   358a8:	0003f49b 	.word	0x0003f49b
   358ac:	0003f4ab 	.word	0x0003f4ab
   358b0:	0003f4be 	.word	0x0003f4be
   358b4:	00020fff 	.word	0x00020fff

000358b8 <z_impl_k_poll>:

int z_impl_k_poll(struct k_poll_event *events, int num_events, s32_t timeout)
{
	int events_registered;
	k_spinlock_key_t key;
	struct _poller poller = { .is_polling = true,
   358b8:	2301      	movs	r3, #1
{
   358ba:	b5f0      	push	{r4, r5, r6, r7, lr}
   358bc:	b087      	sub	sp, #28
	struct _poller poller = { .is_polling = true,
   358be:	f88d 300c 	strb.w	r3, [sp, #12]
				  .thread     = _current,
   358c2:	4b70      	ldr	r3, [pc, #448]	; (35a84 <z_impl_k_poll+0x1cc>)
{
   358c4:	4604      	mov	r4, r0
	struct _poller poller = { .is_polling = true,
   358c6:	689b      	ldr	r3, [r3, #8]
{
   358c8:	460d      	mov	r5, r1
	struct _poller poller = { .is_polling = true,
   358ca:	9304      	str	r3, [sp, #16]
   358cc:	4b6e      	ldr	r3, [pc, #440]	; (35a88 <z_impl_k_poll+0x1d0>)
{
   358ce:	4616      	mov	r6, r2
	struct _poller poller = { .is_polling = true,
   358d0:	9305      	str	r3, [sp, #20]
   358d2:	f3ef 8305 	mrs	r3, IPSR
				  .cb         = k_poll_poller_cb };

	__ASSERT(!arch_is_in_isr(), "");
   358d6:	b163      	cbz	r3, 358f2 <z_impl_k_poll+0x3a>
   358d8:	496c      	ldr	r1, [pc, #432]	; (35a8c <z_impl_k_poll+0x1d4>)
   358da:	23ff      	movs	r3, #255	; 0xff
   358dc:	4a6c      	ldr	r2, [pc, #432]	; (35a90 <z_impl_k_poll+0x1d8>)
   358de:	486d      	ldr	r0, [pc, #436]	; (35a94 <z_impl_k_poll+0x1dc>)
   358e0:	f002 f9ee 	bl	37cc0 <printk>
   358e4:	486c      	ldr	r0, [pc, #432]	; (35a98 <z_impl_k_poll+0x1e0>)
   358e6:	f002 f9eb 	bl	37cc0 <printk>
   358ea:	21ff      	movs	r1, #255	; 0xff
   358ec:	4868      	ldr	r0, [pc, #416]	; (35a90 <z_impl_k_poll+0x1d8>)
   358ee:	f002 fa2d 	bl	37d4c <assert_post_action>
	__ASSERT(events != NULL, "NULL events\n");
   358f2:	b974      	cbnz	r4, 35912 <z_impl_k_poll+0x5a>
   358f4:	4969      	ldr	r1, [pc, #420]	; (35a9c <z_impl_k_poll+0x1e4>)
   358f6:	f44f 7380 	mov.w	r3, #256	; 0x100
   358fa:	4a65      	ldr	r2, [pc, #404]	; (35a90 <z_impl_k_poll+0x1d8>)
   358fc:	4865      	ldr	r0, [pc, #404]	; (35a94 <z_impl_k_poll+0x1dc>)
   358fe:	f002 f9df 	bl	37cc0 <printk>
   35902:	4867      	ldr	r0, [pc, #412]	; (35aa0 <z_impl_k_poll+0x1e8>)
   35904:	f002 f9dc 	bl	37cc0 <printk>
   35908:	f44f 7180 	mov.w	r1, #256	; 0x100
   3590c:	4860      	ldr	r0, [pc, #384]	; (35a90 <z_impl_k_poll+0x1d8>)
   3590e:	f002 fa1d 	bl	37d4c <assert_post_action>
	__ASSERT(num_events >= 0, "<0 events\n");
   35912:	2d00      	cmp	r5, #0
   35914:	da0e      	bge.n	35934 <z_impl_k_poll+0x7c>
   35916:	4963      	ldr	r1, [pc, #396]	; (35aa4 <z_impl_k_poll+0x1ec>)
   35918:	f240 1301 	movw	r3, #257	; 0x101
   3591c:	4a5c      	ldr	r2, [pc, #368]	; (35a90 <z_impl_k_poll+0x1d8>)
   3591e:	485d      	ldr	r0, [pc, #372]	; (35a94 <z_impl_k_poll+0x1dc>)
   35920:	f002 f9ce 	bl	37cc0 <printk>
   35924:	4860      	ldr	r0, [pc, #384]	; (35aa8 <z_impl_k_poll+0x1f0>)
   35926:	f002 f9cb 	bl	37cc0 <printk>
   3592a:	f240 1101 	movw	r1, #257	; 0x101
   3592e:	4858      	ldr	r0, [pc, #352]	; (35a90 <z_impl_k_poll+0x1d8>)
   35930:	f002 fa0c 	bl	37d4c <assert_post_action>

	events_registered = register_events(events, num_events, &poller,
   35934:	fab6 f386 	clz	r3, r6
   35938:	aa03      	add	r2, sp, #12
   3593a:	095b      	lsrs	r3, r3, #5
   3593c:	4629      	mov	r1, r5
   3593e:	4620      	mov	r0, r4
   35940:	f7ff fe6c 	bl	3561c <register_events>
   35944:	4607      	mov	r7, r0
	__asm__ volatile(
   35946:	f04f 0320 	mov.w	r3, #32
   3594a:	f3ef 8511 	mrs	r5, BASEPRI
   3594e:	f383 8811 	msr	BASEPRI, r3
   35952:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   35956:	4855      	ldr	r0, [pc, #340]	; (35aac <z_impl_k_poll+0x1f4>)
   35958:	f7fe ff76 	bl	34848 <z_spin_lock_valid>
   3595c:	b968      	cbnz	r0, 3597a <z_impl_k_poll+0xc2>
   3595e:	234a      	movs	r3, #74	; 0x4a
   35960:	4a53      	ldr	r2, [pc, #332]	; (35ab0 <z_impl_k_poll+0x1f8>)
   35962:	4954      	ldr	r1, [pc, #336]	; (35ab4 <z_impl_k_poll+0x1fc>)
   35964:	484b      	ldr	r0, [pc, #300]	; (35a94 <z_impl_k_poll+0x1dc>)
   35966:	f002 f9ab 	bl	37cc0 <printk>
   3596a:	4950      	ldr	r1, [pc, #320]	; (35aac <z_impl_k_poll+0x1f4>)
   3596c:	4852      	ldr	r0, [pc, #328]	; (35ab8 <z_impl_k_poll+0x200>)
   3596e:	f002 f9a7 	bl	37cc0 <printk>
   35972:	214a      	movs	r1, #74	; 0x4a
   35974:	484e      	ldr	r0, [pc, #312]	; (35ab0 <z_impl_k_poll+0x1f8>)
   35976:	f002 f9e9 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   3597a:	484c      	ldr	r0, [pc, #304]	; (35aac <z_impl_k_poll+0x1f4>)
   3597c:	f7fe ff82 	bl	34884 <z_spin_lock_set_owner>
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller.is_polling) {
   35980:	f89d 300c 	ldrb.w	r3, [sp, #12]
   35984:	b9f3      	cbnz	r3, 359c4 <z_impl_k_poll+0x10c>
		clear_event_registrations(events, events_registered, key);
   35986:	4620      	mov	r0, r4
   35988:	462a      	mov	r2, r5
   3598a:	4639      	mov	r1, r7
   3598c:	f7ff fd8e 	bl	354ac <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   35990:	4846      	ldr	r0, [pc, #280]	; (35aac <z_impl_k_poll+0x1f4>)
   35992:	f7fe ff67 	bl	34864 <z_spin_unlock_valid>
   35996:	b968      	cbnz	r0, 359b4 <z_impl_k_poll+0xfc>
   35998:	235d      	movs	r3, #93	; 0x5d
   3599a:	4a45      	ldr	r2, [pc, #276]	; (35ab0 <z_impl_k_poll+0x1f8>)
   3599c:	4947      	ldr	r1, [pc, #284]	; (35abc <z_impl_k_poll+0x204>)
   3599e:	483d      	ldr	r0, [pc, #244]	; (35a94 <z_impl_k_poll+0x1dc>)
   359a0:	f002 f98e 	bl	37cc0 <printk>
   359a4:	4941      	ldr	r1, [pc, #260]	; (35aac <z_impl_k_poll+0x1f4>)
   359a6:	4846      	ldr	r0, [pc, #280]	; (35ac0 <z_impl_k_poll+0x208>)
   359a8:	f002 f98a 	bl	37cc0 <printk>
   359ac:	215d      	movs	r1, #93	; 0x5d
   359ae:	4840      	ldr	r0, [pc, #256]	; (35ab0 <z_impl_k_poll+0x1f8>)
   359b0:	f002 f9cc 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   359b4:	f385 8811 	msr	BASEPRI, r5
   359b8:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		return 0;
   359bc:	2500      	movs	r5, #0
	key = k_spin_lock(&lock);
	clear_event_registrations(events, events_registered, key);
	k_spin_unlock(&lock, key);

	return swap_rc;
}
   359be:	4628      	mov	r0, r5
   359c0:	b007      	add	sp, #28
   359c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	poller.is_polling = false;
   359c4:	2300      	movs	r3, #0
   359c6:	f88d 300c 	strb.w	r3, [sp, #12]
	if (timeout == K_NO_WAIT) {
   359ca:	b9c6      	cbnz	r6, 359fe <z_impl_k_poll+0x146>
   359cc:	4837      	ldr	r0, [pc, #220]	; (35aac <z_impl_k_poll+0x1f4>)
   359ce:	f7fe ff49 	bl	34864 <z_spin_unlock_valid>
   359d2:	b968      	cbnz	r0, 359f0 <z_impl_k_poll+0x138>
   359d4:	235d      	movs	r3, #93	; 0x5d
   359d6:	4a36      	ldr	r2, [pc, #216]	; (35ab0 <z_impl_k_poll+0x1f8>)
   359d8:	4938      	ldr	r1, [pc, #224]	; (35abc <z_impl_k_poll+0x204>)
   359da:	482e      	ldr	r0, [pc, #184]	; (35a94 <z_impl_k_poll+0x1dc>)
   359dc:	f002 f970 	bl	37cc0 <printk>
   359e0:	4932      	ldr	r1, [pc, #200]	; (35aac <z_impl_k_poll+0x1f4>)
   359e2:	4837      	ldr	r0, [pc, #220]	; (35ac0 <z_impl_k_poll+0x208>)
   359e4:	f002 f96c 	bl	37cc0 <printk>
   359e8:	215d      	movs	r1, #93	; 0x5d
   359ea:	4831      	ldr	r0, [pc, #196]	; (35ab0 <z_impl_k_poll+0x1f8>)
   359ec:	f002 f9ae 	bl	37d4c <assert_post_action>
   359f0:	f385 8811 	msr	BASEPRI, r5
   359f4:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
   359f8:	f06f 050a 	mvn.w	r5, #10
   359fc:	e7df      	b.n	359be <z_impl_k_poll+0x106>
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   359fe:	aa01      	add	r2, sp, #4
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   35a00:	4629      	mov	r1, r5
   35a02:	4633      	mov	r3, r6
   35a04:	4829      	ldr	r0, [pc, #164]	; (35aac <z_impl_k_poll+0x1f4>)
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   35a06:	e9cd 2201 	strd	r2, r2, [sp, #4]
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   35a0a:	f7fe fb43 	bl	34094 <z_pend_curr>
   35a0e:	4605      	mov	r5, r0
	__asm__ volatile(
   35a10:	f04f 0320 	mov.w	r3, #32
   35a14:	f3ef 8611 	mrs	r6, BASEPRI
   35a18:	f383 8811 	msr	BASEPRI, r3
   35a1c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   35a20:	4822      	ldr	r0, [pc, #136]	; (35aac <z_impl_k_poll+0x1f4>)
   35a22:	f7fe ff11 	bl	34848 <z_spin_lock_valid>
   35a26:	b968      	cbnz	r0, 35a44 <z_impl_k_poll+0x18c>
   35a28:	234a      	movs	r3, #74	; 0x4a
   35a2a:	4a21      	ldr	r2, [pc, #132]	; (35ab0 <z_impl_k_poll+0x1f8>)
   35a2c:	4921      	ldr	r1, [pc, #132]	; (35ab4 <z_impl_k_poll+0x1fc>)
   35a2e:	4819      	ldr	r0, [pc, #100]	; (35a94 <z_impl_k_poll+0x1dc>)
   35a30:	f002 f946 	bl	37cc0 <printk>
   35a34:	491d      	ldr	r1, [pc, #116]	; (35aac <z_impl_k_poll+0x1f4>)
   35a36:	4820      	ldr	r0, [pc, #128]	; (35ab8 <z_impl_k_poll+0x200>)
   35a38:	f002 f942 	bl	37cc0 <printk>
   35a3c:	214a      	movs	r1, #74	; 0x4a
   35a3e:	481c      	ldr	r0, [pc, #112]	; (35ab0 <z_impl_k_poll+0x1f8>)
   35a40:	f002 f984 	bl	37d4c <assert_post_action>
	z_spin_lock_set_owner(l);
   35a44:	4819      	ldr	r0, [pc, #100]	; (35aac <z_impl_k_poll+0x1f4>)
   35a46:	f7fe ff1d 	bl	34884 <z_spin_lock_set_owner>
	clear_event_registrations(events, events_registered, key);
   35a4a:	4620      	mov	r0, r4
   35a4c:	4632      	mov	r2, r6
   35a4e:	4639      	mov	r1, r7
   35a50:	f7ff fd2c 	bl	354ac <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   35a54:	4815      	ldr	r0, [pc, #84]	; (35aac <z_impl_k_poll+0x1f4>)
   35a56:	f7fe ff05 	bl	34864 <z_spin_unlock_valid>
   35a5a:	b968      	cbnz	r0, 35a78 <z_impl_k_poll+0x1c0>
   35a5c:	235d      	movs	r3, #93	; 0x5d
   35a5e:	4a14      	ldr	r2, [pc, #80]	; (35ab0 <z_impl_k_poll+0x1f8>)
   35a60:	4916      	ldr	r1, [pc, #88]	; (35abc <z_impl_k_poll+0x204>)
   35a62:	480c      	ldr	r0, [pc, #48]	; (35a94 <z_impl_k_poll+0x1dc>)
   35a64:	f002 f92c 	bl	37cc0 <printk>
   35a68:	4910      	ldr	r1, [pc, #64]	; (35aac <z_impl_k_poll+0x1f4>)
   35a6a:	4815      	ldr	r0, [pc, #84]	; (35ac0 <z_impl_k_poll+0x208>)
   35a6c:	f002 f928 	bl	37cc0 <printk>
   35a70:	215d      	movs	r1, #93	; 0x5d
   35a72:	480f      	ldr	r0, [pc, #60]	; (35ab0 <z_impl_k_poll+0x1f8>)
   35a74:	f002 f96a 	bl	37d4c <assert_post_action>
	__asm__ volatile(
   35a78:	f386 8811 	msr	BASEPRI, r6
   35a7c:	f3bf 8f6f 	isb	sy
	return swap_rc;
   35a80:	e79d      	b.n	359be <z_impl_k_poll+0x106>
   35a82:	bf00      	nop
   35a84:	20022108 	.word	0x20022108
   35a88:	0003543d 	.word	0x0003543d
   35a8c:	0003f0ae 	.word	0x0003f0ae
   35a90:	0003f4d8 	.word	0x0003f4d8
   35a94:	0003baac 	.word	0x0003baac
   35a98:	0003da1b 	.word	0x0003da1b
   35a9c:	0003f54b 	.word	0x0003f54b
   35aa0:	0003f561 	.word	0x0003f561
   35aa4:	0003f570 	.word	0x0003f570
   35aa8:	0003f580 	.word	0x0003f580
   35aac:	20022224 	.word	0x20022224
   35ab0:	0003ba71 	.word	0x0003ba71
   35ab4:	0003ba97 	.word	0x0003ba97
   35ab8:	0003bac9 	.word	0x0003bac9
   35abc:	0003bb0b 	.word	0x0003bb0b
   35ac0:	0003bb22 	.word	0x0003bb22

00035ac4 <fabs>:
   35ac4:	ec51 0b10 	vmov	r0, r1, d0
   35ac8:	ee10 2a10 	vmov	r2, s0
   35acc:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   35ad0:	ec43 2b10 	vmov	d0, r2, r3
   35ad4:	4770      	bx	lr
   35ad6:	bf00      	nop

00035ad8 <__assert_func>:
   35ad8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   35ada:	461c      	mov	r4, r3
   35adc:	4b09      	ldr	r3, [pc, #36]	; (35b04 <__assert_func+0x2c>)
   35ade:	4605      	mov	r5, r0
   35ae0:	681b      	ldr	r3, [r3, #0]
   35ae2:	68d8      	ldr	r0, [r3, #12]
   35ae4:	b152      	cbz	r2, 35afc <__assert_func+0x24>
   35ae6:	4b08      	ldr	r3, [pc, #32]	; (35b08 <__assert_func+0x30>)
   35ae8:	9100      	str	r1, [sp, #0]
   35aea:	4908      	ldr	r1, [pc, #32]	; (35b0c <__assert_func+0x34>)
   35aec:	e9cd 3201 	strd	r3, r2, [sp, #4]
   35af0:	462b      	mov	r3, r5
   35af2:	4622      	mov	r2, r4
   35af4:	f000 f80e 	bl	35b14 <fiprintf>
   35af8:	f004 fb27 	bl	3a14a <abort>
   35afc:	4b04      	ldr	r3, [pc, #16]	; (35b10 <__assert_func+0x38>)
   35afe:	461a      	mov	r2, r3
   35b00:	e7f2      	b.n	35ae8 <__assert_func+0x10>
   35b02:	bf00      	nop
   35b04:	2002b060 	.word	0x2002b060
   35b08:	0003f58d 	.word	0x0003f58d
   35b0c:	0003f59a 	.word	0x0003f59a
   35b10:	0003da1d 	.word	0x0003da1d

00035b14 <fiprintf>:
   35b14:	b40e      	push	{r1, r2, r3}
   35b16:	b503      	push	{r0, r1, lr}
   35b18:	ab03      	add	r3, sp, #12
   35b1a:	4601      	mov	r1, r0
   35b1c:	4805      	ldr	r0, [pc, #20]	; (35b34 <fiprintf+0x20>)
   35b1e:	f853 2b04 	ldr.w	r2, [r3], #4
   35b22:	6800      	ldr	r0, [r0, #0]
   35b24:	9301      	str	r3, [sp, #4]
   35b26:	f000 f807 	bl	35b38 <_vfiprintf_r>
   35b2a:	b002      	add	sp, #8
   35b2c:	f85d eb04 	ldr.w	lr, [sp], #4
   35b30:	b003      	add	sp, #12
   35b32:	4770      	bx	lr
   35b34:	2002b060 	.word	0x2002b060

00035b38 <_vfiprintf_r>:
   35b38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   35b3c:	460d      	mov	r5, r1
   35b3e:	b09d      	sub	sp, #116	; 0x74
   35b40:	4614      	mov	r4, r2
   35b42:	461e      	mov	r6, r3
   35b44:	4607      	mov	r7, r0
   35b46:	b118      	cbz	r0, 35b50 <_vfiprintf_r+0x18>
   35b48:	6983      	ldr	r3, [r0, #24]
   35b4a:	b90b      	cbnz	r3, 35b50 <_vfiprintf_r+0x18>
   35b4c:	f000 ffc2 	bl	36ad4 <__sinit>
   35b50:	4b85      	ldr	r3, [pc, #532]	; (35d68 <_vfiprintf_r+0x230>)
   35b52:	429d      	cmp	r5, r3
   35b54:	d11b      	bne.n	35b8e <_vfiprintf_r+0x56>
   35b56:	687d      	ldr	r5, [r7, #4]
   35b58:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   35b5a:	07d9      	lsls	r1, r3, #31
   35b5c:	d405      	bmi.n	35b6a <_vfiprintf_r+0x32>
   35b5e:	89ab      	ldrh	r3, [r5, #12]
   35b60:	059a      	lsls	r2, r3, #22
   35b62:	d402      	bmi.n	35b6a <_vfiprintf_r+0x32>
   35b64:	6da8      	ldr	r0, [r5, #88]	; 0x58
   35b66:	f004 fbba 	bl	3a2de <__retarget_lock_acquire_recursive>
   35b6a:	89ab      	ldrh	r3, [r5, #12]
   35b6c:	071b      	lsls	r3, r3, #28
   35b6e:	d501      	bpl.n	35b74 <_vfiprintf_r+0x3c>
   35b70:	692b      	ldr	r3, [r5, #16]
   35b72:	b9eb      	cbnz	r3, 35bb0 <_vfiprintf_r+0x78>
   35b74:	4629      	mov	r1, r5
   35b76:	4638      	mov	r0, r7
   35b78:	f000 fe18 	bl	367ac <__swsetup_r>
   35b7c:	b1c0      	cbz	r0, 35bb0 <_vfiprintf_r+0x78>
   35b7e:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   35b80:	07d8      	lsls	r0, r3, #31
   35b82:	d50e      	bpl.n	35ba2 <_vfiprintf_r+0x6a>
   35b84:	f04f 30ff 	mov.w	r0, #4294967295
   35b88:	b01d      	add	sp, #116	; 0x74
   35b8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   35b8e:	4b77      	ldr	r3, [pc, #476]	; (35d6c <_vfiprintf_r+0x234>)
   35b90:	429d      	cmp	r5, r3
   35b92:	d101      	bne.n	35b98 <_vfiprintf_r+0x60>
   35b94:	68bd      	ldr	r5, [r7, #8]
   35b96:	e7df      	b.n	35b58 <_vfiprintf_r+0x20>
   35b98:	4b75      	ldr	r3, [pc, #468]	; (35d70 <_vfiprintf_r+0x238>)
   35b9a:	429d      	cmp	r5, r3
   35b9c:	bf08      	it	eq
   35b9e:	68fd      	ldreq	r5, [r7, #12]
   35ba0:	e7da      	b.n	35b58 <_vfiprintf_r+0x20>
   35ba2:	89ab      	ldrh	r3, [r5, #12]
   35ba4:	0599      	lsls	r1, r3, #22
   35ba6:	d4ed      	bmi.n	35b84 <_vfiprintf_r+0x4c>
   35ba8:	6da8      	ldr	r0, [r5, #88]	; 0x58
   35baa:	f004 fb99 	bl	3a2e0 <__retarget_lock_release_recursive>
   35bae:	e7e9      	b.n	35b84 <_vfiprintf_r+0x4c>
   35bb0:	2300      	movs	r3, #0
   35bb2:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 35d74 <_vfiprintf_r+0x23c>
   35bb6:	f04f 0a01 	mov.w	sl, #1
   35bba:	9603      	str	r6, [sp, #12]
   35bbc:	9309      	str	r3, [sp, #36]	; 0x24
   35bbe:	2320      	movs	r3, #32
   35bc0:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   35bc4:	2330      	movs	r3, #48	; 0x30
   35bc6:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   35bca:	4623      	mov	r3, r4
   35bcc:	461e      	mov	r6, r3
   35bce:	f813 2b01 	ldrb.w	r2, [r3], #1
   35bd2:	b10a      	cbz	r2, 35bd8 <_vfiprintf_r+0xa0>
   35bd4:	2a25      	cmp	r2, #37	; 0x25
   35bd6:	d1f9      	bne.n	35bcc <_vfiprintf_r+0x94>
   35bd8:	ebb6 0b04 	subs.w	fp, r6, r4
   35bdc:	d00b      	beq.n	35bf6 <_vfiprintf_r+0xbe>
   35bde:	465b      	mov	r3, fp
   35be0:	4622      	mov	r2, r4
   35be2:	4629      	mov	r1, r5
   35be4:	4638      	mov	r0, r7
   35be6:	f004 f912 	bl	39e0e <__sfputs_r>
   35bea:	3001      	adds	r0, #1
   35bec:	f000 80a3 	beq.w	35d36 <_vfiprintf_r+0x1fe>
   35bf0:	9b09      	ldr	r3, [sp, #36]	; 0x24
   35bf2:	445b      	add	r3, fp
   35bf4:	9309      	str	r3, [sp, #36]	; 0x24
   35bf6:	7833      	ldrb	r3, [r6, #0]
   35bf8:	2b00      	cmp	r3, #0
   35bfa:	f000 809c 	beq.w	35d36 <_vfiprintf_r+0x1fe>
   35bfe:	2300      	movs	r3, #0
   35c00:	f04f 32ff 	mov.w	r2, #4294967295
   35c04:	3601      	adds	r6, #1
   35c06:	9304      	str	r3, [sp, #16]
   35c08:	9307      	str	r3, [sp, #28]
   35c0a:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   35c0e:	931a      	str	r3, [sp, #104]	; 0x68
   35c10:	e9cd 2305 	strd	r2, r3, [sp, #20]
   35c14:	4634      	mov	r4, r6
   35c16:	2205      	movs	r2, #5
   35c18:	4856      	ldr	r0, [pc, #344]	; (35d74 <_vfiprintf_r+0x23c>)
   35c1a:	f814 1b01 	ldrb.w	r1, [r4], #1
   35c1e:	f004 f892 	bl	39d46 <memchr>
   35c22:	9b04      	ldr	r3, [sp, #16]
   35c24:	b9c0      	cbnz	r0, 35c58 <_vfiprintf_r+0x120>
   35c26:	06da      	lsls	r2, r3, #27
   35c28:	bf44      	itt	mi
   35c2a:	2220      	movmi	r2, #32
   35c2c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   35c30:	0718      	lsls	r0, r3, #28
   35c32:	bf44      	itt	mi
   35c34:	222b      	movmi	r2, #43	; 0x2b
   35c36:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   35c3a:	7832      	ldrb	r2, [r6, #0]
   35c3c:	2a2a      	cmp	r2, #42	; 0x2a
   35c3e:	d013      	beq.n	35c68 <_vfiprintf_r+0x130>
   35c40:	4634      	mov	r4, r6
   35c42:	9a07      	ldr	r2, [sp, #28]
   35c44:	2000      	movs	r0, #0
   35c46:	260a      	movs	r6, #10
   35c48:	4621      	mov	r1, r4
   35c4a:	f811 3b01 	ldrb.w	r3, [r1], #1
   35c4e:	3b30      	subs	r3, #48	; 0x30
   35c50:	2b09      	cmp	r3, #9
   35c52:	d94b      	bls.n	35cec <_vfiprintf_r+0x1b4>
   35c54:	b970      	cbnz	r0, 35c74 <_vfiprintf_r+0x13c>
   35c56:	e014      	b.n	35c82 <_vfiprintf_r+0x14a>
   35c58:	eba0 0009 	sub.w	r0, r0, r9
   35c5c:	4626      	mov	r6, r4
   35c5e:	fa0a f000 	lsl.w	r0, sl, r0
   35c62:	4318      	orrs	r0, r3
   35c64:	9004      	str	r0, [sp, #16]
   35c66:	e7d5      	b.n	35c14 <_vfiprintf_r+0xdc>
   35c68:	9a03      	ldr	r2, [sp, #12]
   35c6a:	1d11      	adds	r1, r2, #4
   35c6c:	6812      	ldr	r2, [r2, #0]
   35c6e:	2a00      	cmp	r2, #0
   35c70:	9103      	str	r1, [sp, #12]
   35c72:	db01      	blt.n	35c78 <_vfiprintf_r+0x140>
   35c74:	9207      	str	r2, [sp, #28]
   35c76:	e004      	b.n	35c82 <_vfiprintf_r+0x14a>
   35c78:	4252      	negs	r2, r2
   35c7a:	f043 0302 	orr.w	r3, r3, #2
   35c7e:	9207      	str	r2, [sp, #28]
   35c80:	9304      	str	r3, [sp, #16]
   35c82:	7823      	ldrb	r3, [r4, #0]
   35c84:	2b2e      	cmp	r3, #46	; 0x2e
   35c86:	d10c      	bne.n	35ca2 <_vfiprintf_r+0x16a>
   35c88:	7863      	ldrb	r3, [r4, #1]
   35c8a:	2b2a      	cmp	r3, #42	; 0x2a
   35c8c:	d133      	bne.n	35cf6 <_vfiprintf_r+0x1be>
   35c8e:	9b03      	ldr	r3, [sp, #12]
   35c90:	3402      	adds	r4, #2
   35c92:	1d1a      	adds	r2, r3, #4
   35c94:	681b      	ldr	r3, [r3, #0]
   35c96:	2b00      	cmp	r3, #0
   35c98:	9203      	str	r2, [sp, #12]
   35c9a:	bfb8      	it	lt
   35c9c:	f04f 33ff 	movlt.w	r3, #4294967295
   35ca0:	9305      	str	r3, [sp, #20]
   35ca2:	4e35      	ldr	r6, [pc, #212]	; (35d78 <_vfiprintf_r+0x240>)
   35ca4:	2203      	movs	r2, #3
   35ca6:	7821      	ldrb	r1, [r4, #0]
   35ca8:	4630      	mov	r0, r6
   35caa:	f004 f84c 	bl	39d46 <memchr>
   35cae:	b138      	cbz	r0, 35cc0 <_vfiprintf_r+0x188>
   35cb0:	2340      	movs	r3, #64	; 0x40
   35cb2:	1b80      	subs	r0, r0, r6
   35cb4:	3401      	adds	r4, #1
   35cb6:	fa03 f000 	lsl.w	r0, r3, r0
   35cba:	9b04      	ldr	r3, [sp, #16]
   35cbc:	4303      	orrs	r3, r0
   35cbe:	9304      	str	r3, [sp, #16]
   35cc0:	f814 1b01 	ldrb.w	r1, [r4], #1
   35cc4:	2206      	movs	r2, #6
   35cc6:	482d      	ldr	r0, [pc, #180]	; (35d7c <_vfiprintf_r+0x244>)
   35cc8:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   35ccc:	f004 f83b 	bl	39d46 <memchr>
   35cd0:	2800      	cmp	r0, #0
   35cd2:	d03f      	beq.n	35d54 <_vfiprintf_r+0x21c>
   35cd4:	4b2a      	ldr	r3, [pc, #168]	; (35d80 <_vfiprintf_r+0x248>)
   35cd6:	bb13      	cbnz	r3, 35d1e <_vfiprintf_r+0x1e6>
   35cd8:	9b03      	ldr	r3, [sp, #12]
   35cda:	3307      	adds	r3, #7
   35cdc:	f023 0307 	bic.w	r3, r3, #7
   35ce0:	3308      	adds	r3, #8
   35ce2:	9303      	str	r3, [sp, #12]
   35ce4:	9b09      	ldr	r3, [sp, #36]	; 0x24
   35ce6:	4443      	add	r3, r8
   35ce8:	9309      	str	r3, [sp, #36]	; 0x24
   35cea:	e76e      	b.n	35bca <_vfiprintf_r+0x92>
   35cec:	fb06 3202 	mla	r2, r6, r2, r3
   35cf0:	2001      	movs	r0, #1
   35cf2:	460c      	mov	r4, r1
   35cf4:	e7a8      	b.n	35c48 <_vfiprintf_r+0x110>
   35cf6:	2300      	movs	r3, #0
   35cf8:	3401      	adds	r4, #1
   35cfa:	260a      	movs	r6, #10
   35cfc:	4619      	mov	r1, r3
   35cfe:	9305      	str	r3, [sp, #20]
   35d00:	4620      	mov	r0, r4
   35d02:	f810 2b01 	ldrb.w	r2, [r0], #1
   35d06:	3a30      	subs	r2, #48	; 0x30
   35d08:	2a09      	cmp	r2, #9
   35d0a:	d903      	bls.n	35d14 <_vfiprintf_r+0x1dc>
   35d0c:	2b00      	cmp	r3, #0
   35d0e:	d0c8      	beq.n	35ca2 <_vfiprintf_r+0x16a>
   35d10:	9105      	str	r1, [sp, #20]
   35d12:	e7c6      	b.n	35ca2 <_vfiprintf_r+0x16a>
   35d14:	fb06 2101 	mla	r1, r6, r1, r2
   35d18:	2301      	movs	r3, #1
   35d1a:	4604      	mov	r4, r0
   35d1c:	e7f0      	b.n	35d00 <_vfiprintf_r+0x1c8>
   35d1e:	ab03      	add	r3, sp, #12
   35d20:	462a      	mov	r2, r5
   35d22:	a904      	add	r1, sp, #16
   35d24:	4638      	mov	r0, r7
   35d26:	9300      	str	r3, [sp, #0]
   35d28:	4b16      	ldr	r3, [pc, #88]	; (35d84 <_vfiprintf_r+0x24c>)
   35d2a:	f000 f82d 	bl	35d88 <_printf_float>
   35d2e:	f1b0 3fff 	cmp.w	r0, #4294967295
   35d32:	4680      	mov	r8, r0
   35d34:	d1d6      	bne.n	35ce4 <_vfiprintf_r+0x1ac>
   35d36:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   35d38:	07d9      	lsls	r1, r3, #31
   35d3a:	d405      	bmi.n	35d48 <_vfiprintf_r+0x210>
   35d3c:	89ab      	ldrh	r3, [r5, #12]
   35d3e:	059a      	lsls	r2, r3, #22
   35d40:	d402      	bmi.n	35d48 <_vfiprintf_r+0x210>
   35d42:	6da8      	ldr	r0, [r5, #88]	; 0x58
   35d44:	f004 facc 	bl	3a2e0 <__retarget_lock_release_recursive>
   35d48:	89ab      	ldrh	r3, [r5, #12]
   35d4a:	065b      	lsls	r3, r3, #25
   35d4c:	f53f af1a 	bmi.w	35b84 <_vfiprintf_r+0x4c>
   35d50:	9809      	ldr	r0, [sp, #36]	; 0x24
   35d52:	e719      	b.n	35b88 <_vfiprintf_r+0x50>
   35d54:	ab03      	add	r3, sp, #12
   35d56:	462a      	mov	r2, r5
   35d58:	a904      	add	r1, sp, #16
   35d5a:	4638      	mov	r0, r7
   35d5c:	9300      	str	r3, [sp, #0]
   35d5e:	4b09      	ldr	r3, [pc, #36]	; (35d84 <_vfiprintf_r+0x24c>)
   35d60:	f000 fa3c 	bl	361dc <_printf_i>
   35d64:	e7e3      	b.n	35d2e <_vfiprintf_r+0x1f6>
   35d66:	bf00      	nop
   35d68:	0003b884 	.word	0x0003b884
   35d6c:	0003b8a4 	.word	0x0003b8a4
   35d70:	0003b864 	.word	0x0003b864
   35d74:	0003f6ca 	.word	0x0003f6ca
   35d78:	0003f6d0 	.word	0x0003f6d0
   35d7c:	0003f6d4 	.word	0x0003f6d4
   35d80:	00035d89 	.word	0x00035d89
   35d84:	00039e0f 	.word	0x00039e0f

00035d88 <_printf_float>:
   35d88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   35d8c:	b08d      	sub	sp, #52	; 0x34
   35d8e:	460c      	mov	r4, r1
   35d90:	4616      	mov	r6, r2
   35d92:	461f      	mov	r7, r3
   35d94:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
   35d98:	4605      	mov	r5, r0
   35d9a:	f000 ff19 	bl	36bd0 <_localeconv_r>
   35d9e:	6803      	ldr	r3, [r0, #0]
   35da0:	4618      	mov	r0, r3
   35da2:	9306      	str	r3, [sp, #24]
   35da4:	f7e7 f9d8 	bl	1d158 <strlen>
   35da8:	2300      	movs	r3, #0
   35daa:	9007      	str	r0, [sp, #28]
   35dac:	930a      	str	r3, [sp, #40]	; 0x28
   35dae:	f8d8 3000 	ldr.w	r3, [r8]
   35db2:	f894 a018 	ldrb.w	sl, [r4, #24]
   35db6:	3307      	adds	r3, #7
   35db8:	f8d4 b000 	ldr.w	fp, [r4]
   35dbc:	f023 0307 	bic.w	r3, r3, #7
   35dc0:	f103 0208 	add.w	r2, r3, #8
   35dc4:	f8c8 2000 	str.w	r2, [r8]
   35dc8:	e9d3 2300 	ldrd	r2, r3, [r3]
   35dcc:	e9c4 2312 	strd	r2, r3, [r4, #72]	; 0x48
   35dd0:	ed94 7b12 	vldr	d7, [r4, #72]	; 0x48
   35dd4:	f04f 32ff 	mov.w	r2, #4294967295
   35dd8:	ed8d 7b04 	vstr	d7, [sp, #16]
   35ddc:	e9dd 8304 	ldrd	r8, r3, [sp, #16]
   35de0:	f023 4900 	bic.w	r9, r3, #2147483648	; 0x80000000
   35de4:	4640      	mov	r0, r8
   35de6:	4ba6      	ldr	r3, [pc, #664]	; (36080 <_printf_float+0x2f8>)
   35de8:	4649      	mov	r1, r9
   35dea:	f7e7 f96d 	bl	1d0c8 <__aeabi_dcmpun>
   35dee:	bb70      	cbnz	r0, 35e4e <_printf_float+0xc6>
   35df0:	f04f 32ff 	mov.w	r2, #4294967295
   35df4:	4ba2      	ldr	r3, [pc, #648]	; (36080 <_printf_float+0x2f8>)
   35df6:	4640      	mov	r0, r8
   35df8:	4649      	mov	r1, r9
   35dfa:	f7e6 ff59 	bl	1ccb0 <__aeabi_dcmple>
   35dfe:	bb30      	cbnz	r0, 35e4e <_printf_float+0xc6>
   35e00:	2200      	movs	r2, #0
   35e02:	2300      	movs	r3, #0
   35e04:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   35e08:	f7e6 ff48 	bl	1cc9c <__aeabi_dcmplt>
   35e0c:	b110      	cbz	r0, 35e14 <_printf_float+0x8c>
   35e0e:	232d      	movs	r3, #45	; 0x2d
   35e10:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   35e14:	4a9b      	ldr	r2, [pc, #620]	; (36084 <_printf_float+0x2fc>)
   35e16:	4b9c      	ldr	r3, [pc, #624]	; (36088 <_printf_float+0x300>)
   35e18:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
   35e1c:	bf94      	ite	ls
   35e1e:	4690      	movls	r8, r2
   35e20:	4698      	movhi	r8, r3
   35e22:	f04f 0900 	mov.w	r9, #0
   35e26:	2303      	movs	r3, #3
   35e28:	f02b 0204 	bic.w	r2, fp, #4
   35e2c:	6123      	str	r3, [r4, #16]
   35e2e:	6022      	str	r2, [r4, #0]
   35e30:	9700      	str	r7, [sp, #0]
   35e32:	4633      	mov	r3, r6
   35e34:	aa0b      	add	r2, sp, #44	; 0x2c
   35e36:	4621      	mov	r1, r4
   35e38:	4628      	mov	r0, r5
   35e3a:	f004 f88a 	bl	39f52 <_printf_common>
   35e3e:	3001      	adds	r0, #1
   35e40:	f040 808c 	bne.w	35f5c <_printf_float+0x1d4>
   35e44:	f04f 30ff 	mov.w	r0, #4294967295
   35e48:	b00d      	add	sp, #52	; 0x34
   35e4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   35e4e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   35e52:	4610      	mov	r0, r2
   35e54:	4619      	mov	r1, r3
   35e56:	f7e7 f937 	bl	1d0c8 <__aeabi_dcmpun>
   35e5a:	b140      	cbz	r0, 35e6e <_printf_float+0xe6>
   35e5c:	9b05      	ldr	r3, [sp, #20]
   35e5e:	4a8b      	ldr	r2, [pc, #556]	; (3608c <_printf_float+0x304>)
   35e60:	2b00      	cmp	r3, #0
   35e62:	bfbc      	itt	lt
   35e64:	232d      	movlt	r3, #45	; 0x2d
   35e66:	f884 3043 	strblt.w	r3, [r4, #67]	; 0x43
   35e6a:	4b89      	ldr	r3, [pc, #548]	; (36090 <_printf_float+0x308>)
   35e6c:	e7d4      	b.n	35e18 <_printf_float+0x90>
   35e6e:	6863      	ldr	r3, [r4, #4]
   35e70:	f00a 09df 	and.w	r9, sl, #223	; 0xdf
   35e74:	1c5a      	adds	r2, r3, #1
   35e76:	d13e      	bne.n	35ef6 <_printf_float+0x16e>
   35e78:	2306      	movs	r3, #6
   35e7a:	6063      	str	r3, [r4, #4]
   35e7c:	2300      	movs	r3, #0
   35e7e:	f44b 6280 	orr.w	r2, fp, #1024	; 0x400
   35e82:	6861      	ldr	r1, [r4, #4]
   35e84:	4628      	mov	r0, r5
   35e86:	9303      	str	r3, [sp, #12]
   35e88:	ab0a      	add	r3, sp, #40	; 0x28
   35e8a:	6022      	str	r2, [r4, #0]
   35e8c:	e9cd a301 	strd	sl, r3, [sp, #4]
   35e90:	ab09      	add	r3, sp, #36	; 0x24
   35e92:	ed9d 0b04 	vldr	d0, [sp, #16]
   35e96:	9300      	str	r3, [sp, #0]
   35e98:	f10d 0323 	add.w	r3, sp, #35	; 0x23
   35e9c:	f003 ffc9 	bl	39e32 <__cvt>
   35ea0:	f1b9 0f47 	cmp.w	r9, #71	; 0x47
   35ea4:	4680      	mov	r8, r0
   35ea6:	9909      	ldr	r1, [sp, #36]	; 0x24
   35ea8:	d108      	bne.n	35ebc <_printf_float+0x134>
   35eaa:	1cc8      	adds	r0, r1, #3
   35eac:	db02      	blt.n	35eb4 <_printf_float+0x12c>
   35eae:	6863      	ldr	r3, [r4, #4]
   35eb0:	4299      	cmp	r1, r3
   35eb2:	dd41      	ble.n	35f38 <_printf_float+0x1b0>
   35eb4:	f1aa 0a02 	sub.w	sl, sl, #2
   35eb8:	fa5f fa8a 	uxtb.w	sl, sl
   35ebc:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
   35ec0:	d820      	bhi.n	35f04 <_printf_float+0x17c>
   35ec2:	3901      	subs	r1, #1
   35ec4:	4652      	mov	r2, sl
   35ec6:	f104 0050 	add.w	r0, r4, #80	; 0x50
   35eca:	9109      	str	r1, [sp, #36]	; 0x24
   35ecc:	f004 f80e 	bl	39eec <__exponent>
   35ed0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   35ed2:	4681      	mov	r9, r0
   35ed4:	1813      	adds	r3, r2, r0
   35ed6:	2a01      	cmp	r2, #1
   35ed8:	6123      	str	r3, [r4, #16]
   35eda:	dc02      	bgt.n	35ee2 <_printf_float+0x15a>
   35edc:	6822      	ldr	r2, [r4, #0]
   35ede:	07d2      	lsls	r2, r2, #31
   35ee0:	d501      	bpl.n	35ee6 <_printf_float+0x15e>
   35ee2:	3301      	adds	r3, #1
   35ee4:	6123      	str	r3, [r4, #16]
   35ee6:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
   35eea:	2b00      	cmp	r3, #0
   35eec:	d0a0      	beq.n	35e30 <_printf_float+0xa8>
   35eee:	232d      	movs	r3, #45	; 0x2d
   35ef0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   35ef4:	e79c      	b.n	35e30 <_printf_float+0xa8>
   35ef6:	f1b9 0f47 	cmp.w	r9, #71	; 0x47
   35efa:	d1bf      	bne.n	35e7c <_printf_float+0xf4>
   35efc:	2b00      	cmp	r3, #0
   35efe:	d1bd      	bne.n	35e7c <_printf_float+0xf4>
   35f00:	2301      	movs	r3, #1
   35f02:	e7ba      	b.n	35e7a <_printf_float+0xf2>
   35f04:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
   35f08:	d118      	bne.n	35f3c <_printf_float+0x1b4>
   35f0a:	2900      	cmp	r1, #0
   35f0c:	6863      	ldr	r3, [r4, #4]
   35f0e:	dd0b      	ble.n	35f28 <_printf_float+0x1a0>
   35f10:	6121      	str	r1, [r4, #16]
   35f12:	b913      	cbnz	r3, 35f1a <_printf_float+0x192>
   35f14:	6822      	ldr	r2, [r4, #0]
   35f16:	07d0      	lsls	r0, r2, #31
   35f18:	d502      	bpl.n	35f20 <_printf_float+0x198>
   35f1a:	3301      	adds	r3, #1
   35f1c:	440b      	add	r3, r1
   35f1e:	6123      	str	r3, [r4, #16]
   35f20:	65a1      	str	r1, [r4, #88]	; 0x58
   35f22:	f04f 0900 	mov.w	r9, #0
   35f26:	e7de      	b.n	35ee6 <_printf_float+0x15e>
   35f28:	b913      	cbnz	r3, 35f30 <_printf_float+0x1a8>
   35f2a:	6822      	ldr	r2, [r4, #0]
   35f2c:	07d2      	lsls	r2, r2, #31
   35f2e:	d501      	bpl.n	35f34 <_printf_float+0x1ac>
   35f30:	3302      	adds	r3, #2
   35f32:	e7f4      	b.n	35f1e <_printf_float+0x196>
   35f34:	2301      	movs	r3, #1
   35f36:	e7f2      	b.n	35f1e <_printf_float+0x196>
   35f38:	f04f 0a67 	mov.w	sl, #103	; 0x67
   35f3c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   35f3e:	4299      	cmp	r1, r3
   35f40:	db05      	blt.n	35f4e <_printf_float+0x1c6>
   35f42:	6823      	ldr	r3, [r4, #0]
   35f44:	6121      	str	r1, [r4, #16]
   35f46:	07d8      	lsls	r0, r3, #31
   35f48:	d5ea      	bpl.n	35f20 <_printf_float+0x198>
   35f4a:	1c4b      	adds	r3, r1, #1
   35f4c:	e7e7      	b.n	35f1e <_printf_float+0x196>
   35f4e:	2900      	cmp	r1, #0
   35f50:	bfd4      	ite	le
   35f52:	f1c1 0202 	rsble	r2, r1, #2
   35f56:	2201      	movgt	r2, #1
   35f58:	4413      	add	r3, r2
   35f5a:	e7e0      	b.n	35f1e <_printf_float+0x196>
   35f5c:	6823      	ldr	r3, [r4, #0]
   35f5e:	055a      	lsls	r2, r3, #21
   35f60:	d407      	bmi.n	35f72 <_printf_float+0x1ea>
   35f62:	6923      	ldr	r3, [r4, #16]
   35f64:	4642      	mov	r2, r8
   35f66:	4631      	mov	r1, r6
   35f68:	4628      	mov	r0, r5
   35f6a:	47b8      	blx	r7
   35f6c:	3001      	adds	r0, #1
   35f6e:	d12b      	bne.n	35fc8 <_printf_float+0x240>
   35f70:	e768      	b.n	35e44 <_printf_float+0xbc>
   35f72:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
   35f76:	f240 80dc 	bls.w	36132 <_printf_float+0x3aa>
   35f7a:	2200      	movs	r2, #0
   35f7c:	2300      	movs	r3, #0
   35f7e:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
   35f82:	f7e6 fe81 	bl	1cc88 <__aeabi_dcmpeq>
   35f86:	2800      	cmp	r0, #0
   35f88:	d033      	beq.n	35ff2 <_printf_float+0x26a>
   35f8a:	2301      	movs	r3, #1
   35f8c:	4a41      	ldr	r2, [pc, #260]	; (36094 <_printf_float+0x30c>)
   35f8e:	4631      	mov	r1, r6
   35f90:	4628      	mov	r0, r5
   35f92:	47b8      	blx	r7
   35f94:	3001      	adds	r0, #1
   35f96:	f43f af55 	beq.w	35e44 <_printf_float+0xbc>
   35f9a:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   35f9e:	429a      	cmp	r2, r3
   35fa0:	db02      	blt.n	35fa8 <_printf_float+0x220>
   35fa2:	6823      	ldr	r3, [r4, #0]
   35fa4:	07d8      	lsls	r0, r3, #31
   35fa6:	d50f      	bpl.n	35fc8 <_printf_float+0x240>
   35fa8:	4631      	mov	r1, r6
   35faa:	4628      	mov	r0, r5
   35fac:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   35fb0:	47b8      	blx	r7
   35fb2:	3001      	adds	r0, #1
   35fb4:	f43f af46 	beq.w	35e44 <_printf_float+0xbc>
   35fb8:	f04f 0800 	mov.w	r8, #0
   35fbc:	f104 091a 	add.w	r9, r4, #26
   35fc0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   35fc2:	3b01      	subs	r3, #1
   35fc4:	4543      	cmp	r3, r8
   35fc6:	dc09      	bgt.n	35fdc <_printf_float+0x254>
   35fc8:	6823      	ldr	r3, [r4, #0]
   35fca:	079b      	lsls	r3, r3, #30
   35fcc:	f100 8101 	bmi.w	361d2 <_printf_float+0x44a>
   35fd0:	68e0      	ldr	r0, [r4, #12]
   35fd2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   35fd4:	4298      	cmp	r0, r3
   35fd6:	bfb8      	it	lt
   35fd8:	4618      	movlt	r0, r3
   35fda:	e735      	b.n	35e48 <_printf_float+0xc0>
   35fdc:	2301      	movs	r3, #1
   35fde:	464a      	mov	r2, r9
   35fe0:	4631      	mov	r1, r6
   35fe2:	4628      	mov	r0, r5
   35fe4:	47b8      	blx	r7
   35fe6:	3001      	adds	r0, #1
   35fe8:	f43f af2c 	beq.w	35e44 <_printf_float+0xbc>
   35fec:	f108 0801 	add.w	r8, r8, #1
   35ff0:	e7e6      	b.n	35fc0 <_printf_float+0x238>
   35ff2:	9b09      	ldr	r3, [sp, #36]	; 0x24
   35ff4:	2b00      	cmp	r3, #0
   35ff6:	dc2b      	bgt.n	36050 <_printf_float+0x2c8>
   35ff8:	2301      	movs	r3, #1
   35ffa:	4a26      	ldr	r2, [pc, #152]	; (36094 <_printf_float+0x30c>)
   35ffc:	4631      	mov	r1, r6
   35ffe:	4628      	mov	r0, r5
   36000:	47b8      	blx	r7
   36002:	3001      	adds	r0, #1
   36004:	f43f af1e 	beq.w	35e44 <_printf_float+0xbc>
   36008:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   3600c:	4313      	orrs	r3, r2
   3600e:	d102      	bne.n	36016 <_printf_float+0x28e>
   36010:	6823      	ldr	r3, [r4, #0]
   36012:	07d9      	lsls	r1, r3, #31
   36014:	d5d8      	bpl.n	35fc8 <_printf_float+0x240>
   36016:	4631      	mov	r1, r6
   36018:	4628      	mov	r0, r5
   3601a:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   3601e:	47b8      	blx	r7
   36020:	3001      	adds	r0, #1
   36022:	f43f af0f 	beq.w	35e44 <_printf_float+0xbc>
   36026:	f04f 0900 	mov.w	r9, #0
   3602a:	f104 0a1a 	add.w	sl, r4, #26
   3602e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   36030:	425b      	negs	r3, r3
   36032:	454b      	cmp	r3, r9
   36034:	dc01      	bgt.n	3603a <_printf_float+0x2b2>
   36036:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   36038:	e794      	b.n	35f64 <_printf_float+0x1dc>
   3603a:	2301      	movs	r3, #1
   3603c:	4652      	mov	r2, sl
   3603e:	4631      	mov	r1, r6
   36040:	4628      	mov	r0, r5
   36042:	47b8      	blx	r7
   36044:	3001      	adds	r0, #1
   36046:	f43f aefd 	beq.w	35e44 <_printf_float+0xbc>
   3604a:	f109 0901 	add.w	r9, r9, #1
   3604e:	e7ee      	b.n	3602e <_printf_float+0x2a6>
   36050:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   36052:	6da3      	ldr	r3, [r4, #88]	; 0x58
   36054:	429a      	cmp	r2, r3
   36056:	bfa8      	it	ge
   36058:	461a      	movge	r2, r3
   3605a:	2a00      	cmp	r2, #0
   3605c:	4691      	mov	r9, r2
   3605e:	dd07      	ble.n	36070 <_printf_float+0x2e8>
   36060:	4613      	mov	r3, r2
   36062:	4631      	mov	r1, r6
   36064:	4642      	mov	r2, r8
   36066:	4628      	mov	r0, r5
   36068:	47b8      	blx	r7
   3606a:	3001      	adds	r0, #1
   3606c:	f43f aeea 	beq.w	35e44 <_printf_float+0xbc>
   36070:	f104 031a 	add.w	r3, r4, #26
   36074:	f04f 0b00 	mov.w	fp, #0
   36078:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
   3607c:	9304      	str	r3, [sp, #16]
   3607e:	e015      	b.n	360ac <_printf_float+0x324>
   36080:	7fefffff 	.word	0x7fefffff
   36084:	0003f6db 	.word	0x0003f6db
   36088:	0003ce13 	.word	0x0003ce13
   3608c:	0003f6df 	.word	0x0003f6df
   36090:	0003f6e3 	.word	0x0003f6e3
   36094:	0003f10e 	.word	0x0003f10e
   36098:	2301      	movs	r3, #1
   3609a:	9a04      	ldr	r2, [sp, #16]
   3609c:	4631      	mov	r1, r6
   3609e:	4628      	mov	r0, r5
   360a0:	47b8      	blx	r7
   360a2:	3001      	adds	r0, #1
   360a4:	f43f aece 	beq.w	35e44 <_printf_float+0xbc>
   360a8:	f10b 0b01 	add.w	fp, fp, #1
   360ac:	f8d4 a058 	ldr.w	sl, [r4, #88]	; 0x58
   360b0:	ebaa 0309 	sub.w	r3, sl, r9
   360b4:	455b      	cmp	r3, fp
   360b6:	dcef      	bgt.n	36098 <_printf_float+0x310>
   360b8:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   360bc:	429a      	cmp	r2, r3
   360be:	db1b      	blt.n	360f8 <_printf_float+0x370>
   360c0:	6823      	ldr	r3, [r4, #0]
   360c2:	07da      	lsls	r2, r3, #31
   360c4:	d418      	bmi.n	360f8 <_printf_float+0x370>
   360c6:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   360ca:	4592      	cmp	sl, r2
   360cc:	db1c      	blt.n	36108 <_printf_float+0x380>
   360ce:	eba3 090a 	sub.w	r9, r3, sl
   360d2:	f1b9 0f00 	cmp.w	r9, #0
   360d6:	dd08      	ble.n	360ea <_printf_float+0x362>
   360d8:	464b      	mov	r3, r9
   360da:	eb08 020a 	add.w	r2, r8, sl
   360de:	4631      	mov	r1, r6
   360e0:	4628      	mov	r0, r5
   360e2:	47b8      	blx	r7
   360e4:	3001      	adds	r0, #1
   360e6:	f43f aead 	beq.w	35e44 <_printf_float+0xbc>
   360ea:	f04f 0800 	mov.w	r8, #0
   360ee:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
   360f2:	f104 0a1a 	add.w	sl, r4, #26
   360f6:	e014      	b.n	36122 <_printf_float+0x39a>
   360f8:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   360fc:	4631      	mov	r1, r6
   360fe:	4628      	mov	r0, r5
   36100:	47b8      	blx	r7
   36102:	3001      	adds	r0, #1
   36104:	d1df      	bne.n	360c6 <_printf_float+0x33e>
   36106:	e69d      	b.n	35e44 <_printf_float+0xbc>
   36108:	eba3 0902 	sub.w	r9, r3, r2
   3610c:	e7e1      	b.n	360d2 <_printf_float+0x34a>
   3610e:	2301      	movs	r3, #1
   36110:	4652      	mov	r2, sl
   36112:	4631      	mov	r1, r6
   36114:	4628      	mov	r0, r5
   36116:	47b8      	blx	r7
   36118:	3001      	adds	r0, #1
   3611a:	f43f ae93 	beq.w	35e44 <_printf_float+0xbc>
   3611e:	f108 0801 	add.w	r8, r8, #1
   36122:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   36126:	1a9b      	subs	r3, r3, r2
   36128:	eba3 0309 	sub.w	r3, r3, r9
   3612c:	4543      	cmp	r3, r8
   3612e:	dcee      	bgt.n	3610e <_printf_float+0x386>
   36130:	e74a      	b.n	35fc8 <_printf_float+0x240>
   36132:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   36134:	2a01      	cmp	r2, #1
   36136:	dc01      	bgt.n	3613c <_printf_float+0x3b4>
   36138:	07db      	lsls	r3, r3, #31
   3613a:	d537      	bpl.n	361ac <_printf_float+0x424>
   3613c:	2301      	movs	r3, #1
   3613e:	4642      	mov	r2, r8
   36140:	4631      	mov	r1, r6
   36142:	4628      	mov	r0, r5
   36144:	47b8      	blx	r7
   36146:	3001      	adds	r0, #1
   36148:	f43f ae7c 	beq.w	35e44 <_printf_float+0xbc>
   3614c:	4631      	mov	r1, r6
   3614e:	4628      	mov	r0, r5
   36150:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   36154:	47b8      	blx	r7
   36156:	3001      	adds	r0, #1
   36158:	f43f ae74 	beq.w	35e44 <_printf_float+0xbc>
   3615c:	2200      	movs	r2, #0
   3615e:	2300      	movs	r3, #0
   36160:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
   36164:	f7e6 fd90 	bl	1cc88 <__aeabi_dcmpeq>
   36168:	b9d8      	cbnz	r0, 361a2 <_printf_float+0x41a>
   3616a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   3616c:	f108 0201 	add.w	r2, r8, #1
   36170:	3b01      	subs	r3, #1
   36172:	4631      	mov	r1, r6
   36174:	4628      	mov	r0, r5
   36176:	47b8      	blx	r7
   36178:	3001      	adds	r0, #1
   3617a:	d10e      	bne.n	3619a <_printf_float+0x412>
   3617c:	e662      	b.n	35e44 <_printf_float+0xbc>
   3617e:	2301      	movs	r3, #1
   36180:	4652      	mov	r2, sl
   36182:	4631      	mov	r1, r6
   36184:	4628      	mov	r0, r5
   36186:	47b8      	blx	r7
   36188:	3001      	adds	r0, #1
   3618a:	f43f ae5b 	beq.w	35e44 <_printf_float+0xbc>
   3618e:	f108 0801 	add.w	r8, r8, #1
   36192:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   36194:	3b01      	subs	r3, #1
   36196:	4543      	cmp	r3, r8
   36198:	dcf1      	bgt.n	3617e <_printf_float+0x3f6>
   3619a:	464b      	mov	r3, r9
   3619c:	f104 0250 	add.w	r2, r4, #80	; 0x50
   361a0:	e6e1      	b.n	35f66 <_printf_float+0x1de>
   361a2:	f04f 0800 	mov.w	r8, #0
   361a6:	f104 0a1a 	add.w	sl, r4, #26
   361aa:	e7f2      	b.n	36192 <_printf_float+0x40a>
   361ac:	2301      	movs	r3, #1
   361ae:	4642      	mov	r2, r8
   361b0:	e7df      	b.n	36172 <_printf_float+0x3ea>
   361b2:	2301      	movs	r3, #1
   361b4:	464a      	mov	r2, r9
   361b6:	4631      	mov	r1, r6
   361b8:	4628      	mov	r0, r5
   361ba:	47b8      	blx	r7
   361bc:	3001      	adds	r0, #1
   361be:	f43f ae41 	beq.w	35e44 <_printf_float+0xbc>
   361c2:	f108 0801 	add.w	r8, r8, #1
   361c6:	68e3      	ldr	r3, [r4, #12]
   361c8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   361ca:	1a9b      	subs	r3, r3, r2
   361cc:	4543      	cmp	r3, r8
   361ce:	dcf0      	bgt.n	361b2 <_printf_float+0x42a>
   361d0:	e6fe      	b.n	35fd0 <_printf_float+0x248>
   361d2:	f04f 0800 	mov.w	r8, #0
   361d6:	f104 0919 	add.w	r9, r4, #25
   361da:	e7f4      	b.n	361c6 <_printf_float+0x43e>

000361dc <_printf_i>:
   361dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   361e0:	4606      	mov	r6, r0
   361e2:	460c      	mov	r4, r1
   361e4:	f101 0043 	add.w	r0, r1, #67	; 0x43
   361e8:	7e09      	ldrb	r1, [r1, #24]
   361ea:	b085      	sub	sp, #20
   361ec:	4698      	mov	r8, r3
   361ee:	296e      	cmp	r1, #110	; 0x6e
   361f0:	4617      	mov	r7, r2
   361f2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   361f4:	f000 80ba 	beq.w	3636c <_printf_i+0x190>
   361f8:	d824      	bhi.n	36244 <_printf_i+0x68>
   361fa:	2963      	cmp	r1, #99	; 0x63
   361fc:	d039      	beq.n	36272 <_printf_i+0x96>
   361fe:	d80a      	bhi.n	36216 <_printf_i+0x3a>
   36200:	2900      	cmp	r1, #0
   36202:	f000 80c3 	beq.w	3638c <_printf_i+0x1b0>
   36206:	2958      	cmp	r1, #88	; 0x58
   36208:	f000 8091 	beq.w	3632e <_printf_i+0x152>
   3620c:	f104 0542 	add.w	r5, r4, #66	; 0x42
   36210:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
   36214:	e035      	b.n	36282 <_printf_i+0xa6>
   36216:	2964      	cmp	r1, #100	; 0x64
   36218:	d001      	beq.n	3621e <_printf_i+0x42>
   3621a:	2969      	cmp	r1, #105	; 0x69
   3621c:	d1f6      	bne.n	3620c <_printf_i+0x30>
   3621e:	6825      	ldr	r5, [r4, #0]
   36220:	681a      	ldr	r2, [r3, #0]
   36222:	f015 0f80 	tst.w	r5, #128	; 0x80
   36226:	f102 0104 	add.w	r1, r2, #4
   3622a:	d02c      	beq.n	36286 <_printf_i+0xaa>
   3622c:	6812      	ldr	r2, [r2, #0]
   3622e:	6019      	str	r1, [r3, #0]
   36230:	2a00      	cmp	r2, #0
   36232:	da03      	bge.n	3623c <_printf_i+0x60>
   36234:	232d      	movs	r3, #45	; 0x2d
   36236:	4252      	negs	r2, r2
   36238:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   3623c:	f8df c1bc 	ldr.w	ip, [pc, #444]	; 363fc <_printf_i+0x220>
   36240:	230a      	movs	r3, #10
   36242:	e03f      	b.n	362c4 <_printf_i+0xe8>
   36244:	2973      	cmp	r1, #115	; 0x73
   36246:	f000 80a5 	beq.w	36394 <_printf_i+0x1b8>
   3624a:	d808      	bhi.n	3625e <_printf_i+0x82>
   3624c:	296f      	cmp	r1, #111	; 0x6f
   3624e:	d021      	beq.n	36294 <_printf_i+0xb8>
   36250:	2970      	cmp	r1, #112	; 0x70
   36252:	d1db      	bne.n	3620c <_printf_i+0x30>
   36254:	6822      	ldr	r2, [r4, #0]
   36256:	f042 0220 	orr.w	r2, r2, #32
   3625a:	6022      	str	r2, [r4, #0]
   3625c:	e003      	b.n	36266 <_printf_i+0x8a>
   3625e:	2975      	cmp	r1, #117	; 0x75
   36260:	d018      	beq.n	36294 <_printf_i+0xb8>
   36262:	2978      	cmp	r1, #120	; 0x78
   36264:	d1d2      	bne.n	3620c <_printf_i+0x30>
   36266:	2278      	movs	r2, #120	; 0x78
   36268:	f8df c194 	ldr.w	ip, [pc, #404]	; 36400 <_printf_i+0x224>
   3626c:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
   36270:	e061      	b.n	36336 <_printf_i+0x15a>
   36272:	681a      	ldr	r2, [r3, #0]
   36274:	f104 0542 	add.w	r5, r4, #66	; 0x42
   36278:	1d11      	adds	r1, r2, #4
   3627a:	6019      	str	r1, [r3, #0]
   3627c:	6813      	ldr	r3, [r2, #0]
   3627e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
   36282:	2301      	movs	r3, #1
   36284:	e093      	b.n	363ae <_printf_i+0x1d2>
   36286:	6812      	ldr	r2, [r2, #0]
   36288:	f015 0f40 	tst.w	r5, #64	; 0x40
   3628c:	6019      	str	r1, [r3, #0]
   3628e:	bf18      	it	ne
   36290:	b212      	sxthne	r2, r2
   36292:	e7cd      	b.n	36230 <_printf_i+0x54>
   36294:	f8d4 c000 	ldr.w	ip, [r4]
   36298:	681a      	ldr	r2, [r3, #0]
   3629a:	f01c 0f80 	tst.w	ip, #128	; 0x80
   3629e:	f102 0504 	add.w	r5, r2, #4
   362a2:	601d      	str	r5, [r3, #0]
   362a4:	d001      	beq.n	362aa <_printf_i+0xce>
   362a6:	6812      	ldr	r2, [r2, #0]
   362a8:	e003      	b.n	362b2 <_printf_i+0xd6>
   362aa:	f01c 0f40 	tst.w	ip, #64	; 0x40
   362ae:	d0fa      	beq.n	362a6 <_printf_i+0xca>
   362b0:	8812      	ldrh	r2, [r2, #0]
   362b2:	296f      	cmp	r1, #111	; 0x6f
   362b4:	f8df c144 	ldr.w	ip, [pc, #324]	; 363fc <_printf_i+0x220>
   362b8:	bf0c      	ite	eq
   362ba:	2308      	moveq	r3, #8
   362bc:	230a      	movne	r3, #10
   362be:	2100      	movs	r1, #0
   362c0:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
   362c4:	6865      	ldr	r5, [r4, #4]
   362c6:	2d00      	cmp	r5, #0
   362c8:	60a5      	str	r5, [r4, #8]
   362ca:	bfa2      	ittt	ge
   362cc:	6821      	ldrge	r1, [r4, #0]
   362ce:	f021 0104 	bicge.w	r1, r1, #4
   362d2:	6021      	strge	r1, [r4, #0]
   362d4:	b90a      	cbnz	r2, 362da <_printf_i+0xfe>
   362d6:	2d00      	cmp	r5, #0
   362d8:	d046      	beq.n	36368 <_printf_i+0x18c>
   362da:	4605      	mov	r5, r0
   362dc:	4293      	cmp	r3, r2
   362de:	fbb2 f1f3 	udiv	r1, r2, r3
   362e2:	fb03 2e11 	mls	lr, r3, r1, r2
   362e6:	f81c e00e 	ldrb.w	lr, [ip, lr]
   362ea:	f805 ed01 	strb.w	lr, [r5, #-1]!
   362ee:	d939      	bls.n	36364 <_printf_i+0x188>
   362f0:	2b08      	cmp	r3, #8
   362f2:	d10b      	bne.n	3630c <_printf_i+0x130>
   362f4:	6823      	ldr	r3, [r4, #0]
   362f6:	07da      	lsls	r2, r3, #31
   362f8:	d508      	bpl.n	3630c <_printf_i+0x130>
   362fa:	6923      	ldr	r3, [r4, #16]
   362fc:	6862      	ldr	r2, [r4, #4]
   362fe:	429a      	cmp	r2, r3
   36300:	bfde      	ittt	le
   36302:	2330      	movle	r3, #48	; 0x30
   36304:	f805 3c01 	strble.w	r3, [r5, #-1]
   36308:	f105 35ff 	addle.w	r5, r5, #4294967295
   3630c:	1b40      	subs	r0, r0, r5
   3630e:	6120      	str	r0, [r4, #16]
   36310:	f8cd 8000 	str.w	r8, [sp]
   36314:	463b      	mov	r3, r7
   36316:	aa03      	add	r2, sp, #12
   36318:	4621      	mov	r1, r4
   3631a:	4630      	mov	r0, r6
   3631c:	f003 fe19 	bl	39f52 <_printf_common>
   36320:	3001      	adds	r0, #1
   36322:	d149      	bne.n	363b8 <_printf_i+0x1dc>
   36324:	f04f 30ff 	mov.w	r0, #4294967295
   36328:	b005      	add	sp, #20
   3632a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   3632e:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 363fc <_printf_i+0x220>
   36332:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
   36336:	681d      	ldr	r5, [r3, #0]
   36338:	6821      	ldr	r1, [r4, #0]
   3633a:	f855 2b04 	ldr.w	r2, [r5], #4
   3633e:	601d      	str	r5, [r3, #0]
   36340:	060d      	lsls	r5, r1, #24
   36342:	d50b      	bpl.n	3635c <_printf_i+0x180>
   36344:	07cd      	lsls	r5, r1, #31
   36346:	bf44      	itt	mi
   36348:	f041 0120 	orrmi.w	r1, r1, #32
   3634c:	6021      	strmi	r1, [r4, #0]
   3634e:	b91a      	cbnz	r2, 36358 <_printf_i+0x17c>
   36350:	6823      	ldr	r3, [r4, #0]
   36352:	f023 0320 	bic.w	r3, r3, #32
   36356:	6023      	str	r3, [r4, #0]
   36358:	2310      	movs	r3, #16
   3635a:	e7b0      	b.n	362be <_printf_i+0xe2>
   3635c:	064b      	lsls	r3, r1, #25
   3635e:	bf48      	it	mi
   36360:	b292      	uxthmi	r2, r2
   36362:	e7ef      	b.n	36344 <_printf_i+0x168>
   36364:	460a      	mov	r2, r1
   36366:	e7b9      	b.n	362dc <_printf_i+0x100>
   36368:	4605      	mov	r5, r0
   3636a:	e7c1      	b.n	362f0 <_printf_i+0x114>
   3636c:	681a      	ldr	r2, [r3, #0]
   3636e:	f8d4 c000 	ldr.w	ip, [r4]
   36372:	1d15      	adds	r5, r2, #4
   36374:	6961      	ldr	r1, [r4, #20]
   36376:	f01c 0f80 	tst.w	ip, #128	; 0x80
   3637a:	601d      	str	r5, [r3, #0]
   3637c:	6813      	ldr	r3, [r2, #0]
   3637e:	d001      	beq.n	36384 <_printf_i+0x1a8>
   36380:	6019      	str	r1, [r3, #0]
   36382:	e003      	b.n	3638c <_printf_i+0x1b0>
   36384:	f01c 0f40 	tst.w	ip, #64	; 0x40
   36388:	d0fa      	beq.n	36380 <_printf_i+0x1a4>
   3638a:	8019      	strh	r1, [r3, #0]
   3638c:	2300      	movs	r3, #0
   3638e:	4605      	mov	r5, r0
   36390:	6123      	str	r3, [r4, #16]
   36392:	e7bd      	b.n	36310 <_printf_i+0x134>
   36394:	681a      	ldr	r2, [r3, #0]
   36396:	1d11      	adds	r1, r2, #4
   36398:	6019      	str	r1, [r3, #0]
   3639a:	2100      	movs	r1, #0
   3639c:	6815      	ldr	r5, [r2, #0]
   3639e:	6862      	ldr	r2, [r4, #4]
   363a0:	4628      	mov	r0, r5
   363a2:	f003 fcd0 	bl	39d46 <memchr>
   363a6:	b108      	cbz	r0, 363ac <_printf_i+0x1d0>
   363a8:	1b40      	subs	r0, r0, r5
   363aa:	6060      	str	r0, [r4, #4]
   363ac:	6863      	ldr	r3, [r4, #4]
   363ae:	6123      	str	r3, [r4, #16]
   363b0:	2300      	movs	r3, #0
   363b2:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   363b6:	e7ab      	b.n	36310 <_printf_i+0x134>
   363b8:	6923      	ldr	r3, [r4, #16]
   363ba:	462a      	mov	r2, r5
   363bc:	4639      	mov	r1, r7
   363be:	4630      	mov	r0, r6
   363c0:	47c0      	blx	r8
   363c2:	3001      	adds	r0, #1
   363c4:	d0ae      	beq.n	36324 <_printf_i+0x148>
   363c6:	6823      	ldr	r3, [r4, #0]
   363c8:	079b      	lsls	r3, r3, #30
   363ca:	d413      	bmi.n	363f4 <_printf_i+0x218>
   363cc:	68e0      	ldr	r0, [r4, #12]
   363ce:	9b03      	ldr	r3, [sp, #12]
   363d0:	4298      	cmp	r0, r3
   363d2:	bfb8      	it	lt
   363d4:	4618      	movlt	r0, r3
   363d6:	e7a7      	b.n	36328 <_printf_i+0x14c>
   363d8:	2301      	movs	r3, #1
   363da:	464a      	mov	r2, r9
   363dc:	4639      	mov	r1, r7
   363de:	4630      	mov	r0, r6
   363e0:	47c0      	blx	r8
   363e2:	3001      	adds	r0, #1
   363e4:	d09e      	beq.n	36324 <_printf_i+0x148>
   363e6:	3501      	adds	r5, #1
   363e8:	68e3      	ldr	r3, [r4, #12]
   363ea:	9a03      	ldr	r2, [sp, #12]
   363ec:	1a9b      	subs	r3, r3, r2
   363ee:	42ab      	cmp	r3, r5
   363f0:	dcf2      	bgt.n	363d8 <_printf_i+0x1fc>
   363f2:	e7eb      	b.n	363cc <_printf_i+0x1f0>
   363f4:	2500      	movs	r5, #0
   363f6:	f104 0919 	add.w	r9, r4, #25
   363fa:	e7f5      	b.n	363e8 <_printf_i+0x20c>
   363fc:	0003f6e7 	.word	0x0003f6e7
   36400:	0003f6f8 	.word	0x0003f6f8

00036404 <sniprintf>:
   36404:	b40c      	push	{r2, r3}
   36406:	4b18      	ldr	r3, [pc, #96]	; (36468 <sniprintf+0x64>)
   36408:	b530      	push	{r4, r5, lr}
   3640a:	1e0c      	subs	r4, r1, #0
   3640c:	b09d      	sub	sp, #116	; 0x74
   3640e:	681d      	ldr	r5, [r3, #0]
   36410:	da08      	bge.n	36424 <sniprintf+0x20>
   36412:	238b      	movs	r3, #139	; 0x8b
   36414:	f04f 30ff 	mov.w	r0, #4294967295
   36418:	602b      	str	r3, [r5, #0]
   3641a:	b01d      	add	sp, #116	; 0x74
   3641c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   36420:	b002      	add	sp, #8
   36422:	4770      	bx	lr
   36424:	f44f 7302 	mov.w	r3, #520	; 0x208
   36428:	9002      	str	r0, [sp, #8]
   3642a:	9006      	str	r0, [sp, #24]
   3642c:	a902      	add	r1, sp, #8
   3642e:	f8ad 3014 	strh.w	r3, [sp, #20]
   36432:	bf14      	ite	ne
   36434:	f104 33ff 	addne.w	r3, r4, #4294967295
   36438:	4623      	moveq	r3, r4
   3643a:	9a20      	ldr	r2, [sp, #128]	; 0x80
   3643c:	4628      	mov	r0, r5
   3643e:	9304      	str	r3, [sp, #16]
   36440:	9307      	str	r3, [sp, #28]
   36442:	f64f 73ff 	movw	r3, #65535	; 0xffff
   36446:	f8ad 3016 	strh.w	r3, [sp, #22]
   3644a:	ab21      	add	r3, sp, #132	; 0x84
   3644c:	9301      	str	r3, [sp, #4]
   3644e:	f000 fd01 	bl	36e54 <_svfiprintf_r>
   36452:	1c43      	adds	r3, r0, #1
   36454:	bfbc      	itt	lt
   36456:	238b      	movlt	r3, #139	; 0x8b
   36458:	602b      	strlt	r3, [r5, #0]
   3645a:	2c00      	cmp	r4, #0
   3645c:	d0dd      	beq.n	3641a <sniprintf+0x16>
   3645e:	9b02      	ldr	r3, [sp, #8]
   36460:	2200      	movs	r2, #0
   36462:	701a      	strb	r2, [r3, #0]
   36464:	e7d9      	b.n	3641a <sniprintf+0x16>
   36466:	bf00      	nop
   36468:	2002b060 	.word	0x2002b060

0003646c <siprintf>:
   3646c:	b40e      	push	{r1, r2, r3}
   3646e:	b500      	push	{lr}
   36470:	b09c      	sub	sp, #112	; 0x70
   36472:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   36476:	ab1d      	add	r3, sp, #116	; 0x74
   36478:	9002      	str	r0, [sp, #8]
   3647a:	9006      	str	r0, [sp, #24]
   3647c:	9107      	str	r1, [sp, #28]
   3647e:	9104      	str	r1, [sp, #16]
   36480:	4808      	ldr	r0, [pc, #32]	; (364a4 <siprintf+0x38>)
   36482:	4909      	ldr	r1, [pc, #36]	; (364a8 <siprintf+0x3c>)
   36484:	f853 2b04 	ldr.w	r2, [r3], #4
   36488:	9105      	str	r1, [sp, #20]
   3648a:	a902      	add	r1, sp, #8
   3648c:	6800      	ldr	r0, [r0, #0]
   3648e:	9301      	str	r3, [sp, #4]
   36490:	f000 fce0 	bl	36e54 <_svfiprintf_r>
   36494:	9b02      	ldr	r3, [sp, #8]
   36496:	2200      	movs	r2, #0
   36498:	701a      	strb	r2, [r3, #0]
   3649a:	b01c      	add	sp, #112	; 0x70
   3649c:	f85d eb04 	ldr.w	lr, [sp], #4
   364a0:	b003      	add	sp, #12
   364a2:	4770      	bx	lr
   364a4:	2002b060 	.word	0x2002b060
   364a8:	ffff0208 	.word	0xffff0208

000364ac <_strtol_l.isra.0>:
   364ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   364b0:	4686      	mov	lr, r0
   364b2:	4f39      	ldr	r7, [pc, #228]	; (36598 <_strtol_l.isra.0+0xec>)
   364b4:	4608      	mov	r0, r1
   364b6:	4605      	mov	r5, r0
   364b8:	f815 4b01 	ldrb.w	r4, [r5], #1
   364bc:	5de6      	ldrb	r6, [r4, r7]
   364be:	f016 0608 	ands.w	r6, r6, #8
   364c2:	d135      	bne.n	36530 <_strtol_l.isra.0+0x84>
   364c4:	2c2d      	cmp	r4, #45	; 0x2d
   364c6:	d135      	bne.n	36534 <_strtol_l.isra.0+0x88>
   364c8:	782c      	ldrb	r4, [r5, #0]
   364ca:	f04f 0801 	mov.w	r8, #1
   364ce:	1c85      	adds	r5, r0, #2
   364d0:	2b00      	cmp	r3, #0
   364d2:	d05c      	beq.n	3658e <_strtol_l.isra.0+0xe2>
   364d4:	2b10      	cmp	r3, #16
   364d6:	d109      	bne.n	364ec <_strtol_l.isra.0+0x40>
   364d8:	2c30      	cmp	r4, #48	; 0x30
   364da:	d107      	bne.n	364ec <_strtol_l.isra.0+0x40>
   364dc:	7828      	ldrb	r0, [r5, #0]
   364de:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   364e2:	2858      	cmp	r0, #88	; 0x58
   364e4:	d14e      	bne.n	36584 <_strtol_l.isra.0+0xd8>
   364e6:	786c      	ldrb	r4, [r5, #1]
   364e8:	2310      	movs	r3, #16
   364ea:	3502      	adds	r5, #2
   364ec:	f1b8 0f00 	cmp.w	r8, #0
   364f0:	f04f 0700 	mov.w	r7, #0
   364f4:	bf14      	ite	ne
   364f6:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
   364fa:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
   364fe:	4638      	mov	r0, r7
   36500:	fbbc f9f3 	udiv	r9, ip, r3
   36504:	fb03 ca19 	mls	sl, r3, r9, ip
   36508:	f1a4 0630 	sub.w	r6, r4, #48	; 0x30
   3650c:	2e09      	cmp	r6, #9
   3650e:	d817      	bhi.n	36540 <_strtol_l.isra.0+0x94>
   36510:	4634      	mov	r4, r6
   36512:	42a3      	cmp	r3, r4
   36514:	dd23      	ble.n	3655e <_strtol_l.isra.0+0xb2>
   36516:	1c7e      	adds	r6, r7, #1
   36518:	d007      	beq.n	3652a <_strtol_l.isra.0+0x7e>
   3651a:	4581      	cmp	r9, r0
   3651c:	d31c      	bcc.n	36558 <_strtol_l.isra.0+0xac>
   3651e:	d101      	bne.n	36524 <_strtol_l.isra.0+0x78>
   36520:	45a2      	cmp	sl, r4
   36522:	db19      	blt.n	36558 <_strtol_l.isra.0+0xac>
   36524:	fb00 4003 	mla	r0, r0, r3, r4
   36528:	2701      	movs	r7, #1
   3652a:	f815 4b01 	ldrb.w	r4, [r5], #1
   3652e:	e7eb      	b.n	36508 <_strtol_l.isra.0+0x5c>
   36530:	4628      	mov	r0, r5
   36532:	e7c0      	b.n	364b6 <_strtol_l.isra.0+0xa>
   36534:	2c2b      	cmp	r4, #43	; 0x2b
   36536:	46b0      	mov	r8, r6
   36538:	bf04      	itt	eq
   3653a:	782c      	ldrbeq	r4, [r5, #0]
   3653c:	1c85      	addeq	r5, r0, #2
   3653e:	e7c7      	b.n	364d0 <_strtol_l.isra.0+0x24>
   36540:	f1a4 0641 	sub.w	r6, r4, #65	; 0x41
   36544:	2e19      	cmp	r6, #25
   36546:	d801      	bhi.n	3654c <_strtol_l.isra.0+0xa0>
   36548:	3c37      	subs	r4, #55	; 0x37
   3654a:	e7e2      	b.n	36512 <_strtol_l.isra.0+0x66>
   3654c:	f1a4 0661 	sub.w	r6, r4, #97	; 0x61
   36550:	2e19      	cmp	r6, #25
   36552:	d804      	bhi.n	3655e <_strtol_l.isra.0+0xb2>
   36554:	3c57      	subs	r4, #87	; 0x57
   36556:	e7dc      	b.n	36512 <_strtol_l.isra.0+0x66>
   36558:	f04f 37ff 	mov.w	r7, #4294967295
   3655c:	e7e5      	b.n	3652a <_strtol_l.isra.0+0x7e>
   3655e:	1c7b      	adds	r3, r7, #1
   36560:	d106      	bne.n	36570 <_strtol_l.isra.0+0xc4>
   36562:	2322      	movs	r3, #34	; 0x22
   36564:	4660      	mov	r0, ip
   36566:	f8ce 3000 	str.w	r3, [lr]
   3656a:	b942      	cbnz	r2, 3657e <_strtol_l.isra.0+0xd2>
   3656c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   36570:	f1b8 0f00 	cmp.w	r8, #0
   36574:	d000      	beq.n	36578 <_strtol_l.isra.0+0xcc>
   36576:	4240      	negs	r0, r0
   36578:	2a00      	cmp	r2, #0
   3657a:	d0f7      	beq.n	3656c <_strtol_l.isra.0+0xc0>
   3657c:	b107      	cbz	r7, 36580 <_strtol_l.isra.0+0xd4>
   3657e:	1e69      	subs	r1, r5, #1
   36580:	6011      	str	r1, [r2, #0]
   36582:	e7f3      	b.n	3656c <_strtol_l.isra.0+0xc0>
   36584:	2430      	movs	r4, #48	; 0x30
   36586:	2b00      	cmp	r3, #0
   36588:	d1b0      	bne.n	364ec <_strtol_l.isra.0+0x40>
   3658a:	2308      	movs	r3, #8
   3658c:	e7ae      	b.n	364ec <_strtol_l.isra.0+0x40>
   3658e:	2c30      	cmp	r4, #48	; 0x30
   36590:	d0a4      	beq.n	364dc <_strtol_l.isra.0+0x30>
   36592:	230a      	movs	r3, #10
   36594:	e7aa      	b.n	364ec <_strtol_l.isra.0+0x40>
   36596:	bf00      	nop
   36598:	0003f5ca 	.word	0x0003f5ca

0003659c <strtol>:
   3659c:	4613      	mov	r3, r2
   3659e:	460a      	mov	r2, r1
   365a0:	4601      	mov	r1, r0
   365a2:	4802      	ldr	r0, [pc, #8]	; (365ac <strtol+0x10>)
   365a4:	6800      	ldr	r0, [r0, #0]
   365a6:	f7ff bf81 	b.w	364ac <_strtol_l.isra.0>
   365aa:	bf00      	nop
   365ac:	2002b060 	.word	0x2002b060

000365b0 <_strtoul_l.isra.0>:
   365b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   365b4:	4686      	mov	lr, r0
   365b6:	4f37      	ldr	r7, [pc, #220]	; (36694 <_strtoul_l.isra.0+0xe4>)
   365b8:	4608      	mov	r0, r1
   365ba:	4605      	mov	r5, r0
   365bc:	f815 4b01 	ldrb.w	r4, [r5], #1
   365c0:	5de6      	ldrb	r6, [r4, r7]
   365c2:	f016 0608 	ands.w	r6, r6, #8
   365c6:	d131      	bne.n	3662c <_strtoul_l.isra.0+0x7c>
   365c8:	2c2d      	cmp	r4, #45	; 0x2d
   365ca:	d131      	bne.n	36630 <_strtoul_l.isra.0+0x80>
   365cc:	782c      	ldrb	r4, [r5, #0]
   365ce:	f04f 0801 	mov.w	r8, #1
   365d2:	1c85      	adds	r5, r0, #2
   365d4:	2b00      	cmp	r3, #0
   365d6:	d059      	beq.n	3668c <_strtoul_l.isra.0+0xdc>
   365d8:	2b10      	cmp	r3, #16
   365da:	d109      	bne.n	365f0 <_strtoul_l.isra.0+0x40>
   365dc:	2c30      	cmp	r4, #48	; 0x30
   365de:	d107      	bne.n	365f0 <_strtoul_l.isra.0+0x40>
   365e0:	7828      	ldrb	r0, [r5, #0]
   365e2:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   365e6:	2858      	cmp	r0, #88	; 0x58
   365e8:	d14b      	bne.n	36682 <_strtoul_l.isra.0+0xd2>
   365ea:	786c      	ldrb	r4, [r5, #1]
   365ec:	2310      	movs	r3, #16
   365ee:	3502      	adds	r5, #2
   365f0:	f04f 3cff 	mov.w	ip, #4294967295
   365f4:	2600      	movs	r6, #0
   365f6:	fbbc fcf3 	udiv	ip, ip, r3
   365fa:	fb03 f90c 	mul.w	r9, r3, ip
   365fe:	4630      	mov	r0, r6
   36600:	ea6f 0909 	mvn.w	r9, r9
   36604:	f1a4 0730 	sub.w	r7, r4, #48	; 0x30
   36608:	2f09      	cmp	r7, #9
   3660a:	d817      	bhi.n	3663c <_strtoul_l.isra.0+0x8c>
   3660c:	463c      	mov	r4, r7
   3660e:	42a3      	cmp	r3, r4
   36610:	dd23      	ble.n	3665a <_strtoul_l.isra.0+0xaa>
   36612:	2e00      	cmp	r6, #0
   36614:	db1e      	blt.n	36654 <_strtoul_l.isra.0+0xa4>
   36616:	4584      	cmp	ip, r0
   36618:	d31c      	bcc.n	36654 <_strtoul_l.isra.0+0xa4>
   3661a:	d101      	bne.n	36620 <_strtoul_l.isra.0+0x70>
   3661c:	45a1      	cmp	r9, r4
   3661e:	db19      	blt.n	36654 <_strtoul_l.isra.0+0xa4>
   36620:	fb00 4003 	mla	r0, r0, r3, r4
   36624:	2601      	movs	r6, #1
   36626:	f815 4b01 	ldrb.w	r4, [r5], #1
   3662a:	e7eb      	b.n	36604 <_strtoul_l.isra.0+0x54>
   3662c:	4628      	mov	r0, r5
   3662e:	e7c4      	b.n	365ba <_strtoul_l.isra.0+0xa>
   36630:	2c2b      	cmp	r4, #43	; 0x2b
   36632:	46b0      	mov	r8, r6
   36634:	bf04      	itt	eq
   36636:	782c      	ldrbeq	r4, [r5, #0]
   36638:	1c85      	addeq	r5, r0, #2
   3663a:	e7cb      	b.n	365d4 <_strtoul_l.isra.0+0x24>
   3663c:	f1a4 0741 	sub.w	r7, r4, #65	; 0x41
   36640:	2f19      	cmp	r7, #25
   36642:	d801      	bhi.n	36648 <_strtoul_l.isra.0+0x98>
   36644:	3c37      	subs	r4, #55	; 0x37
   36646:	e7e2      	b.n	3660e <_strtoul_l.isra.0+0x5e>
   36648:	f1a4 0761 	sub.w	r7, r4, #97	; 0x61
   3664c:	2f19      	cmp	r7, #25
   3664e:	d804      	bhi.n	3665a <_strtoul_l.isra.0+0xaa>
   36650:	3c57      	subs	r4, #87	; 0x57
   36652:	e7dc      	b.n	3660e <_strtoul_l.isra.0+0x5e>
   36654:	f04f 36ff 	mov.w	r6, #4294967295
   36658:	e7e5      	b.n	36626 <_strtoul_l.isra.0+0x76>
   3665a:	2e00      	cmp	r6, #0
   3665c:	da07      	bge.n	3666e <_strtoul_l.isra.0+0xbe>
   3665e:	2322      	movs	r3, #34	; 0x22
   36660:	f04f 30ff 	mov.w	r0, #4294967295
   36664:	f8ce 3000 	str.w	r3, [lr]
   36668:	b942      	cbnz	r2, 3667c <_strtoul_l.isra.0+0xcc>
   3666a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   3666e:	f1b8 0f00 	cmp.w	r8, #0
   36672:	d000      	beq.n	36676 <_strtoul_l.isra.0+0xc6>
   36674:	4240      	negs	r0, r0
   36676:	2a00      	cmp	r2, #0
   36678:	d0f7      	beq.n	3666a <_strtoul_l.isra.0+0xba>
   3667a:	b106      	cbz	r6, 3667e <_strtoul_l.isra.0+0xce>
   3667c:	1e69      	subs	r1, r5, #1
   3667e:	6011      	str	r1, [r2, #0]
   36680:	e7f3      	b.n	3666a <_strtoul_l.isra.0+0xba>
   36682:	2430      	movs	r4, #48	; 0x30
   36684:	2b00      	cmp	r3, #0
   36686:	d1b3      	bne.n	365f0 <_strtoul_l.isra.0+0x40>
   36688:	2308      	movs	r3, #8
   3668a:	e7b1      	b.n	365f0 <_strtoul_l.isra.0+0x40>
   3668c:	2c30      	cmp	r4, #48	; 0x30
   3668e:	d0a7      	beq.n	365e0 <_strtoul_l.isra.0+0x30>
   36690:	230a      	movs	r3, #10
   36692:	e7ad      	b.n	365f0 <_strtoul_l.isra.0+0x40>
   36694:	0003f5ca 	.word	0x0003f5ca

00036698 <strtoul>:
   36698:	4613      	mov	r3, r2
   3669a:	460a      	mov	r2, r1
   3669c:	4601      	mov	r1, r0
   3669e:	4802      	ldr	r0, [pc, #8]	; (366a8 <strtoul+0x10>)
   366a0:	6800      	ldr	r0, [r0, #0]
   366a2:	f7ff bf85 	b.w	365b0 <_strtoul_l.isra.0>
   366a6:	bf00      	nop
   366a8:	2002b060 	.word	0x2002b060

000366ac <vsniprintf>:
   366ac:	b507      	push	{r0, r1, r2, lr}
   366ae:	9300      	str	r3, [sp, #0]
   366b0:	4613      	mov	r3, r2
   366b2:	460a      	mov	r2, r1
   366b4:	4601      	mov	r1, r0
   366b6:	4803      	ldr	r0, [pc, #12]	; (366c4 <vsniprintf+0x18>)
   366b8:	6800      	ldr	r0, [r0, #0]
   366ba:	f003 fd1a 	bl	3a0f2 <_vsniprintf_r>
   366be:	b003      	add	sp, #12
   366c0:	f85d fb04 	ldr.w	pc, [sp], #4
   366c4:	2002b060 	.word	0x2002b060

000366c8 <_vsiprintf_r>:
   366c8:	b500      	push	{lr}
   366ca:	b09b      	sub	sp, #108	; 0x6c
   366cc:	9100      	str	r1, [sp, #0]
   366ce:	9104      	str	r1, [sp, #16]
   366d0:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   366d4:	9105      	str	r1, [sp, #20]
   366d6:	9102      	str	r1, [sp, #8]
   366d8:	4905      	ldr	r1, [pc, #20]	; (366f0 <_vsiprintf_r+0x28>)
   366da:	9103      	str	r1, [sp, #12]
   366dc:	4669      	mov	r1, sp
   366de:	f000 fbb9 	bl	36e54 <_svfiprintf_r>
   366e2:	9b00      	ldr	r3, [sp, #0]
   366e4:	2200      	movs	r2, #0
   366e6:	701a      	strb	r2, [r3, #0]
   366e8:	b01b      	add	sp, #108	; 0x6c
   366ea:	f85d fb04 	ldr.w	pc, [sp], #4
   366ee:	bf00      	nop
   366f0:	ffff0208 	.word	0xffff0208

000366f4 <vsiprintf>:
   366f4:	4613      	mov	r3, r2
   366f6:	460a      	mov	r2, r1
   366f8:	4601      	mov	r1, r0
   366fa:	4802      	ldr	r0, [pc, #8]	; (36704 <vsiprintf+0x10>)
   366fc:	6800      	ldr	r0, [r0, #0]
   366fe:	f7ff bfe3 	b.w	366c8 <_vsiprintf_r>
   36702:	bf00      	nop
   36704:	2002b060 	.word	0x2002b060

00036708 <__swbuf_r>:
   36708:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3670a:	460e      	mov	r6, r1
   3670c:	4614      	mov	r4, r2
   3670e:	4605      	mov	r5, r0
   36710:	b118      	cbz	r0, 3671a <__swbuf_r+0x12>
   36712:	6983      	ldr	r3, [r0, #24]
   36714:	b90b      	cbnz	r3, 3671a <__swbuf_r+0x12>
   36716:	f000 f9dd 	bl	36ad4 <__sinit>
   3671a:	4b21      	ldr	r3, [pc, #132]	; (367a0 <__swbuf_r+0x98>)
   3671c:	429c      	cmp	r4, r3
   3671e:	d12b      	bne.n	36778 <__swbuf_r+0x70>
   36720:	686c      	ldr	r4, [r5, #4]
   36722:	69a3      	ldr	r3, [r4, #24]
   36724:	60a3      	str	r3, [r4, #8]
   36726:	89a3      	ldrh	r3, [r4, #12]
   36728:	071a      	lsls	r2, r3, #28
   3672a:	d52f      	bpl.n	3678c <__swbuf_r+0x84>
   3672c:	6923      	ldr	r3, [r4, #16]
   3672e:	b36b      	cbz	r3, 3678c <__swbuf_r+0x84>
   36730:	6923      	ldr	r3, [r4, #16]
   36732:	b2f6      	uxtb	r6, r6
   36734:	6820      	ldr	r0, [r4, #0]
   36736:	4637      	mov	r7, r6
   36738:	1ac0      	subs	r0, r0, r3
   3673a:	6963      	ldr	r3, [r4, #20]
   3673c:	4283      	cmp	r3, r0
   3673e:	dc04      	bgt.n	3674a <__swbuf_r+0x42>
   36740:	4621      	mov	r1, r4
   36742:	4628      	mov	r0, r5
   36744:	f000 f948 	bl	369d8 <_fflush_r>
   36748:	bb30      	cbnz	r0, 36798 <__swbuf_r+0x90>
   3674a:	68a3      	ldr	r3, [r4, #8]
   3674c:	3001      	adds	r0, #1
   3674e:	3b01      	subs	r3, #1
   36750:	60a3      	str	r3, [r4, #8]
   36752:	6823      	ldr	r3, [r4, #0]
   36754:	1c5a      	adds	r2, r3, #1
   36756:	6022      	str	r2, [r4, #0]
   36758:	701e      	strb	r6, [r3, #0]
   3675a:	6963      	ldr	r3, [r4, #20]
   3675c:	4283      	cmp	r3, r0
   3675e:	d004      	beq.n	3676a <__swbuf_r+0x62>
   36760:	89a3      	ldrh	r3, [r4, #12]
   36762:	07db      	lsls	r3, r3, #31
   36764:	d506      	bpl.n	36774 <__swbuf_r+0x6c>
   36766:	2e0a      	cmp	r6, #10
   36768:	d104      	bne.n	36774 <__swbuf_r+0x6c>
   3676a:	4621      	mov	r1, r4
   3676c:	4628      	mov	r0, r5
   3676e:	f000 f933 	bl	369d8 <_fflush_r>
   36772:	b988      	cbnz	r0, 36798 <__swbuf_r+0x90>
   36774:	4638      	mov	r0, r7
   36776:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   36778:	4b0a      	ldr	r3, [pc, #40]	; (367a4 <__swbuf_r+0x9c>)
   3677a:	429c      	cmp	r4, r3
   3677c:	d101      	bne.n	36782 <__swbuf_r+0x7a>
   3677e:	68ac      	ldr	r4, [r5, #8]
   36780:	e7cf      	b.n	36722 <__swbuf_r+0x1a>
   36782:	4b09      	ldr	r3, [pc, #36]	; (367a8 <__swbuf_r+0xa0>)
   36784:	429c      	cmp	r4, r3
   36786:	bf08      	it	eq
   36788:	68ec      	ldreq	r4, [r5, #12]
   3678a:	e7ca      	b.n	36722 <__swbuf_r+0x1a>
   3678c:	4621      	mov	r1, r4
   3678e:	4628      	mov	r0, r5
   36790:	f000 f80c 	bl	367ac <__swsetup_r>
   36794:	2800      	cmp	r0, #0
   36796:	d0cb      	beq.n	36730 <__swbuf_r+0x28>
   36798:	f04f 37ff 	mov.w	r7, #4294967295
   3679c:	e7ea      	b.n	36774 <__swbuf_r+0x6c>
   3679e:	bf00      	nop
   367a0:	0003b884 	.word	0x0003b884
   367a4:	0003b8a4 	.word	0x0003b8a4
   367a8:	0003b864 	.word	0x0003b864

000367ac <__swsetup_r>:
   367ac:	4b32      	ldr	r3, [pc, #200]	; (36878 <__swsetup_r+0xcc>)
   367ae:	b570      	push	{r4, r5, r6, lr}
   367b0:	681d      	ldr	r5, [r3, #0]
   367b2:	4606      	mov	r6, r0
   367b4:	460c      	mov	r4, r1
   367b6:	b125      	cbz	r5, 367c2 <__swsetup_r+0x16>
   367b8:	69ab      	ldr	r3, [r5, #24]
   367ba:	b913      	cbnz	r3, 367c2 <__swsetup_r+0x16>
   367bc:	4628      	mov	r0, r5
   367be:	f000 f989 	bl	36ad4 <__sinit>
   367c2:	4b2e      	ldr	r3, [pc, #184]	; (3687c <__swsetup_r+0xd0>)
   367c4:	429c      	cmp	r4, r3
   367c6:	d10f      	bne.n	367e8 <__swsetup_r+0x3c>
   367c8:	686c      	ldr	r4, [r5, #4]
   367ca:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   367ce:	b29a      	uxth	r2, r3
   367d0:	0715      	lsls	r5, r2, #28
   367d2:	d42c      	bmi.n	3682e <__swsetup_r+0x82>
   367d4:	06d0      	lsls	r0, r2, #27
   367d6:	d411      	bmi.n	367fc <__swsetup_r+0x50>
   367d8:	2209      	movs	r2, #9
   367da:	6032      	str	r2, [r6, #0]
   367dc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   367e0:	f04f 30ff 	mov.w	r0, #4294967295
   367e4:	81a3      	strh	r3, [r4, #12]
   367e6:	e03e      	b.n	36866 <__swsetup_r+0xba>
   367e8:	4b25      	ldr	r3, [pc, #148]	; (36880 <__swsetup_r+0xd4>)
   367ea:	429c      	cmp	r4, r3
   367ec:	d101      	bne.n	367f2 <__swsetup_r+0x46>
   367ee:	68ac      	ldr	r4, [r5, #8]
   367f0:	e7eb      	b.n	367ca <__swsetup_r+0x1e>
   367f2:	4b24      	ldr	r3, [pc, #144]	; (36884 <__swsetup_r+0xd8>)
   367f4:	429c      	cmp	r4, r3
   367f6:	bf08      	it	eq
   367f8:	68ec      	ldreq	r4, [r5, #12]
   367fa:	e7e6      	b.n	367ca <__swsetup_r+0x1e>
   367fc:	0751      	lsls	r1, r2, #29
   367fe:	d512      	bpl.n	36826 <__swsetup_r+0x7a>
   36800:	6b61      	ldr	r1, [r4, #52]	; 0x34
   36802:	b141      	cbz	r1, 36816 <__swsetup_r+0x6a>
   36804:	f104 0344 	add.w	r3, r4, #68	; 0x44
   36808:	4299      	cmp	r1, r3
   3680a:	d002      	beq.n	36812 <__swsetup_r+0x66>
   3680c:	4630      	mov	r0, r6
   3680e:	f000 fa79 	bl	36d04 <_free_r>
   36812:	2300      	movs	r3, #0
   36814:	6363      	str	r3, [r4, #52]	; 0x34
   36816:	89a3      	ldrh	r3, [r4, #12]
   36818:	f023 0324 	bic.w	r3, r3, #36	; 0x24
   3681c:	81a3      	strh	r3, [r4, #12]
   3681e:	2300      	movs	r3, #0
   36820:	6063      	str	r3, [r4, #4]
   36822:	6923      	ldr	r3, [r4, #16]
   36824:	6023      	str	r3, [r4, #0]
   36826:	89a3      	ldrh	r3, [r4, #12]
   36828:	f043 0308 	orr.w	r3, r3, #8
   3682c:	81a3      	strh	r3, [r4, #12]
   3682e:	6923      	ldr	r3, [r4, #16]
   36830:	b94b      	cbnz	r3, 36846 <__swsetup_r+0x9a>
   36832:	89a3      	ldrh	r3, [r4, #12]
   36834:	f403 7320 	and.w	r3, r3, #640	; 0x280
   36838:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   3683c:	d003      	beq.n	36846 <__swsetup_r+0x9a>
   3683e:	4621      	mov	r1, r4
   36840:	4630      	mov	r0, r6
   36842:	f000 f9c9 	bl	36bd8 <__smakebuf_r>
   36846:	89a2      	ldrh	r2, [r4, #12]
   36848:	f012 0301 	ands.w	r3, r2, #1
   3684c:	d00c      	beq.n	36868 <__swsetup_r+0xbc>
   3684e:	2300      	movs	r3, #0
   36850:	60a3      	str	r3, [r4, #8]
   36852:	6963      	ldr	r3, [r4, #20]
   36854:	425b      	negs	r3, r3
   36856:	61a3      	str	r3, [r4, #24]
   36858:	6923      	ldr	r3, [r4, #16]
   3685a:	b953      	cbnz	r3, 36872 <__swsetup_r+0xc6>
   3685c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   36860:	f013 0080 	ands.w	r0, r3, #128	; 0x80
   36864:	d1ba      	bne.n	367dc <__swsetup_r+0x30>
   36866:	bd70      	pop	{r4, r5, r6, pc}
   36868:	0792      	lsls	r2, r2, #30
   3686a:	bf58      	it	pl
   3686c:	6963      	ldrpl	r3, [r4, #20]
   3686e:	60a3      	str	r3, [r4, #8]
   36870:	e7f2      	b.n	36858 <__swsetup_r+0xac>
   36872:	2000      	movs	r0, #0
   36874:	e7f7      	b.n	36866 <__swsetup_r+0xba>
   36876:	bf00      	nop
   36878:	2002b060 	.word	0x2002b060
   3687c:	0003b884 	.word	0x0003b884
   36880:	0003b8a4 	.word	0x0003b8a4
   36884:	0003b864 	.word	0x0003b864

00036888 <__chk_fail>:
   36888:	b500      	push	{lr}
   3688a:	b08d      	sub	sp, #52	; 0x34
   3688c:	4b0f      	ldr	r3, [pc, #60]	; (368cc <__chk_fail+0x44>)
   3688e:	466a      	mov	r2, sp
   36890:	f103 0628 	add.w	r6, r3, #40	; 0x28
   36894:	4615      	mov	r5, r2
   36896:	6818      	ldr	r0, [r3, #0]
   36898:	3308      	adds	r3, #8
   3689a:	f853 1c04 	ldr.w	r1, [r3, #-4]
   3689e:	4614      	mov	r4, r2
   368a0:	42b3      	cmp	r3, r6
   368a2:	c403      	stmia	r4!, {r0, r1}
   368a4:	4622      	mov	r2, r4
   368a6:	d1f6      	bne.n	36896 <__chk_fail+0xe>
   368a8:	6818      	ldr	r0, [r3, #0]
   368aa:	889b      	ldrh	r3, [r3, #4]
   368ac:	6020      	str	r0, [r4, #0]
   368ae:	4628      	mov	r0, r5
   368b0:	80a3      	strh	r3, [r4, #4]
   368b2:	f7e6 fc51 	bl	1d158 <strlen>
   368b6:	4629      	mov	r1, r5
   368b8:	4602      	mov	r2, r0
   368ba:	2002      	movs	r0, #2
   368bc:	f001 fbe7 	bl	3808e <_write>
   368c0:	2006      	movs	r0, #6
   368c2:	f000 fbcf 	bl	37064 <raise>
   368c6:	207f      	movs	r0, #127	; 0x7f
   368c8:	f7ef fae8 	bl	25e9c <_exit>
   368cc:	0003f709 	.word	0x0003f709

000368d0 <__sflush_r>:
   368d0:	898a      	ldrh	r2, [r1, #12]
   368d2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   368d6:	4605      	mov	r5, r0
   368d8:	0710      	lsls	r0, r2, #28
   368da:	460c      	mov	r4, r1
   368dc:	d458      	bmi.n	36990 <__sflush_r+0xc0>
   368de:	684b      	ldr	r3, [r1, #4]
   368e0:	2b00      	cmp	r3, #0
   368e2:	dc05      	bgt.n	368f0 <__sflush_r+0x20>
   368e4:	6c0b      	ldr	r3, [r1, #64]	; 0x40
   368e6:	2b00      	cmp	r3, #0
   368e8:	dc02      	bgt.n	368f0 <__sflush_r+0x20>
   368ea:	2000      	movs	r0, #0
   368ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   368f0:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   368f2:	2e00      	cmp	r6, #0
   368f4:	d0f9      	beq.n	368ea <__sflush_r+0x1a>
   368f6:	2300      	movs	r3, #0
   368f8:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
   368fc:	682f      	ldr	r7, [r5, #0]
   368fe:	602b      	str	r3, [r5, #0]
   36900:	d032      	beq.n	36968 <__sflush_r+0x98>
   36902:	6d60      	ldr	r0, [r4, #84]	; 0x54
   36904:	89a3      	ldrh	r3, [r4, #12]
   36906:	075a      	lsls	r2, r3, #29
   36908:	d505      	bpl.n	36916 <__sflush_r+0x46>
   3690a:	6863      	ldr	r3, [r4, #4]
   3690c:	1ac0      	subs	r0, r0, r3
   3690e:	6b63      	ldr	r3, [r4, #52]	; 0x34
   36910:	b10b      	cbz	r3, 36916 <__sflush_r+0x46>
   36912:	6c23      	ldr	r3, [r4, #64]	; 0x40
   36914:	1ac0      	subs	r0, r0, r3
   36916:	2300      	movs	r3, #0
   36918:	4602      	mov	r2, r0
   3691a:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   3691c:	4628      	mov	r0, r5
   3691e:	6a21      	ldr	r1, [r4, #32]
   36920:	47b0      	blx	r6
   36922:	1c43      	adds	r3, r0, #1
   36924:	89a3      	ldrh	r3, [r4, #12]
   36926:	d106      	bne.n	36936 <__sflush_r+0x66>
   36928:	6829      	ldr	r1, [r5, #0]
   3692a:	291d      	cmp	r1, #29
   3692c:	d82c      	bhi.n	36988 <__sflush_r+0xb8>
   3692e:	4a29      	ldr	r2, [pc, #164]	; (369d4 <__sflush_r+0x104>)
   36930:	40ca      	lsrs	r2, r1
   36932:	07d6      	lsls	r6, r2, #31
   36934:	d528      	bpl.n	36988 <__sflush_r+0xb8>
   36936:	2200      	movs	r2, #0
   36938:	04d9      	lsls	r1, r3, #19
   3693a:	6062      	str	r2, [r4, #4]
   3693c:	6922      	ldr	r2, [r4, #16]
   3693e:	6022      	str	r2, [r4, #0]
   36940:	d504      	bpl.n	3694c <__sflush_r+0x7c>
   36942:	1c42      	adds	r2, r0, #1
   36944:	d101      	bne.n	3694a <__sflush_r+0x7a>
   36946:	682b      	ldr	r3, [r5, #0]
   36948:	b903      	cbnz	r3, 3694c <__sflush_r+0x7c>
   3694a:	6560      	str	r0, [r4, #84]	; 0x54
   3694c:	6b61      	ldr	r1, [r4, #52]	; 0x34
   3694e:	602f      	str	r7, [r5, #0]
   36950:	2900      	cmp	r1, #0
   36952:	d0ca      	beq.n	368ea <__sflush_r+0x1a>
   36954:	f104 0344 	add.w	r3, r4, #68	; 0x44
   36958:	4299      	cmp	r1, r3
   3695a:	d002      	beq.n	36962 <__sflush_r+0x92>
   3695c:	4628      	mov	r0, r5
   3695e:	f000 f9d1 	bl	36d04 <_free_r>
   36962:	2000      	movs	r0, #0
   36964:	6360      	str	r0, [r4, #52]	; 0x34
   36966:	e7c1      	b.n	368ec <__sflush_r+0x1c>
   36968:	6a21      	ldr	r1, [r4, #32]
   3696a:	2301      	movs	r3, #1
   3696c:	4628      	mov	r0, r5
   3696e:	47b0      	blx	r6
   36970:	1c41      	adds	r1, r0, #1
   36972:	d1c7      	bne.n	36904 <__sflush_r+0x34>
   36974:	682b      	ldr	r3, [r5, #0]
   36976:	2b00      	cmp	r3, #0
   36978:	d0c4      	beq.n	36904 <__sflush_r+0x34>
   3697a:	2b1d      	cmp	r3, #29
   3697c:	d001      	beq.n	36982 <__sflush_r+0xb2>
   3697e:	2b16      	cmp	r3, #22
   36980:	d101      	bne.n	36986 <__sflush_r+0xb6>
   36982:	602f      	str	r7, [r5, #0]
   36984:	e7b1      	b.n	368ea <__sflush_r+0x1a>
   36986:	89a3      	ldrh	r3, [r4, #12]
   36988:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   3698c:	81a3      	strh	r3, [r4, #12]
   3698e:	e7ad      	b.n	368ec <__sflush_r+0x1c>
   36990:	690f      	ldr	r7, [r1, #16]
   36992:	2f00      	cmp	r7, #0
   36994:	d0a9      	beq.n	368ea <__sflush_r+0x1a>
   36996:	0793      	lsls	r3, r2, #30
   36998:	680e      	ldr	r6, [r1, #0]
   3699a:	600f      	str	r7, [r1, #0]
   3699c:	bf0c      	ite	eq
   3699e:	694b      	ldreq	r3, [r1, #20]
   369a0:	2300      	movne	r3, #0
   369a2:	eba6 0807 	sub.w	r8, r6, r7
   369a6:	608b      	str	r3, [r1, #8]
   369a8:	f1b8 0f00 	cmp.w	r8, #0
   369ac:	dd9d      	ble.n	368ea <__sflush_r+0x1a>
   369ae:	4643      	mov	r3, r8
   369b0:	463a      	mov	r2, r7
   369b2:	6a21      	ldr	r1, [r4, #32]
   369b4:	4628      	mov	r0, r5
   369b6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   369b8:	47b0      	blx	r6
   369ba:	2800      	cmp	r0, #0
   369bc:	dc06      	bgt.n	369cc <__sflush_r+0xfc>
   369be:	89a3      	ldrh	r3, [r4, #12]
   369c0:	f04f 30ff 	mov.w	r0, #4294967295
   369c4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   369c8:	81a3      	strh	r3, [r4, #12]
   369ca:	e78f      	b.n	368ec <__sflush_r+0x1c>
   369cc:	4407      	add	r7, r0
   369ce:	eba8 0800 	sub.w	r8, r8, r0
   369d2:	e7e9      	b.n	369a8 <__sflush_r+0xd8>
   369d4:	20400001 	.word	0x20400001

000369d8 <_fflush_r>:
   369d8:	b538      	push	{r3, r4, r5, lr}
   369da:	690b      	ldr	r3, [r1, #16]
   369dc:	4605      	mov	r5, r0
   369de:	460c      	mov	r4, r1
   369e0:	b913      	cbnz	r3, 369e8 <_fflush_r+0x10>
   369e2:	2500      	movs	r5, #0
   369e4:	4628      	mov	r0, r5
   369e6:	bd38      	pop	{r3, r4, r5, pc}
   369e8:	b118      	cbz	r0, 369f2 <_fflush_r+0x1a>
   369ea:	6983      	ldr	r3, [r0, #24]
   369ec:	b90b      	cbnz	r3, 369f2 <_fflush_r+0x1a>
   369ee:	f000 f871 	bl	36ad4 <__sinit>
   369f2:	4b14      	ldr	r3, [pc, #80]	; (36a44 <_fflush_r+0x6c>)
   369f4:	429c      	cmp	r4, r3
   369f6:	d11b      	bne.n	36a30 <_fflush_r+0x58>
   369f8:	686c      	ldr	r4, [r5, #4]
   369fa:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   369fe:	2b00      	cmp	r3, #0
   36a00:	d0ef      	beq.n	369e2 <_fflush_r+0xa>
   36a02:	6e62      	ldr	r2, [r4, #100]	; 0x64
   36a04:	07d0      	lsls	r0, r2, #31
   36a06:	d404      	bmi.n	36a12 <_fflush_r+0x3a>
   36a08:	0599      	lsls	r1, r3, #22
   36a0a:	d402      	bmi.n	36a12 <_fflush_r+0x3a>
   36a0c:	6da0      	ldr	r0, [r4, #88]	; 0x58
   36a0e:	f003 fc66 	bl	3a2de <__retarget_lock_acquire_recursive>
   36a12:	4628      	mov	r0, r5
   36a14:	4621      	mov	r1, r4
   36a16:	f7ff ff5b 	bl	368d0 <__sflush_r>
   36a1a:	6e63      	ldr	r3, [r4, #100]	; 0x64
   36a1c:	4605      	mov	r5, r0
   36a1e:	07da      	lsls	r2, r3, #31
   36a20:	d4e0      	bmi.n	369e4 <_fflush_r+0xc>
   36a22:	89a3      	ldrh	r3, [r4, #12]
   36a24:	059b      	lsls	r3, r3, #22
   36a26:	d4dd      	bmi.n	369e4 <_fflush_r+0xc>
   36a28:	6da0      	ldr	r0, [r4, #88]	; 0x58
   36a2a:	f003 fc59 	bl	3a2e0 <__retarget_lock_release_recursive>
   36a2e:	e7d9      	b.n	369e4 <_fflush_r+0xc>
   36a30:	4b05      	ldr	r3, [pc, #20]	; (36a48 <_fflush_r+0x70>)
   36a32:	429c      	cmp	r4, r3
   36a34:	d101      	bne.n	36a3a <_fflush_r+0x62>
   36a36:	68ac      	ldr	r4, [r5, #8]
   36a38:	e7df      	b.n	369fa <_fflush_r+0x22>
   36a3a:	4b04      	ldr	r3, [pc, #16]	; (36a4c <_fflush_r+0x74>)
   36a3c:	429c      	cmp	r4, r3
   36a3e:	bf08      	it	eq
   36a40:	68ec      	ldreq	r4, [r5, #12]
   36a42:	e7da      	b.n	369fa <_fflush_r+0x22>
   36a44:	0003b884 	.word	0x0003b884
   36a48:	0003b8a4 	.word	0x0003b8a4
   36a4c:	0003b864 	.word	0x0003b864

00036a50 <std>:
   36a50:	2300      	movs	r3, #0
   36a52:	b510      	push	{r4, lr}
   36a54:	4604      	mov	r4, r0
   36a56:	6083      	str	r3, [r0, #8]
   36a58:	8181      	strh	r1, [r0, #12]
   36a5a:	4619      	mov	r1, r3
   36a5c:	6643      	str	r3, [r0, #100]	; 0x64
   36a5e:	81c2      	strh	r2, [r0, #14]
   36a60:	2208      	movs	r2, #8
   36a62:	6183      	str	r3, [r0, #24]
   36a64:	e9c0 3300 	strd	r3, r3, [r0]
   36a68:	e9c0 3304 	strd	r3, r3, [r0, #16]
   36a6c:	305c      	adds	r0, #92	; 0x5c
   36a6e:	f003 f9a6 	bl	39dbe <memset>
   36a72:	4b05      	ldr	r3, [pc, #20]	; (36a88 <std+0x38>)
   36a74:	6224      	str	r4, [r4, #32]
   36a76:	6263      	str	r3, [r4, #36]	; 0x24
   36a78:	4b04      	ldr	r3, [pc, #16]	; (36a8c <std+0x3c>)
   36a7a:	62a3      	str	r3, [r4, #40]	; 0x28
   36a7c:	4b04      	ldr	r3, [pc, #16]	; (36a90 <std+0x40>)
   36a7e:	62e3      	str	r3, [r4, #44]	; 0x2c
   36a80:	4b04      	ldr	r3, [pc, #16]	; (36a94 <std+0x44>)
   36a82:	6323      	str	r3, [r4, #48]	; 0x30
   36a84:	bd10      	pop	{r4, pc}
   36a86:	bf00      	nop
   36a88:	0003a9e7 	.word	0x0003a9e7
   36a8c:	0003aa09 	.word	0x0003aa09
   36a90:	0003aa41 	.word	0x0003aa41
   36a94:	0003aa65 	.word	0x0003aa65

00036a98 <_cleanup_r>:
   36a98:	4901      	ldr	r1, [pc, #4]	; (36aa0 <_cleanup_r+0x8>)
   36a9a:	f003 bc01 	b.w	3a2a0 <_fwalk_reent>
   36a9e:	bf00      	nop
   36aa0:	000369d9 	.word	0x000369d9

00036aa4 <__sfp_lock_acquire>:
   36aa4:	4801      	ldr	r0, [pc, #4]	; (36aac <__sfp_lock_acquire+0x8>)
   36aa6:	f003 bc1a 	b.w	3a2de <__retarget_lock_acquire_recursive>
   36aaa:	bf00      	nop
   36aac:	2002629c 	.word	0x2002629c

00036ab0 <__sfp_lock_release>:
   36ab0:	4801      	ldr	r0, [pc, #4]	; (36ab8 <__sfp_lock_release+0x8>)
   36ab2:	f003 bc15 	b.w	3a2e0 <__retarget_lock_release_recursive>
   36ab6:	bf00      	nop
   36ab8:	2002629c 	.word	0x2002629c

00036abc <__sinit_lock_acquire>:
   36abc:	4801      	ldr	r0, [pc, #4]	; (36ac4 <__sinit_lock_acquire+0x8>)
   36abe:	f003 bc0e 	b.w	3a2de <__retarget_lock_acquire_recursive>
   36ac2:	bf00      	nop
   36ac4:	20026297 	.word	0x20026297

00036ac8 <__sinit_lock_release>:
   36ac8:	4801      	ldr	r0, [pc, #4]	; (36ad0 <__sinit_lock_release+0x8>)
   36aca:	f003 bc09 	b.w	3a2e0 <__retarget_lock_release_recursive>
   36ace:	bf00      	nop
   36ad0:	20026297 	.word	0x20026297

00036ad4 <__sinit>:
   36ad4:	b510      	push	{r4, lr}
   36ad6:	4604      	mov	r4, r0
   36ad8:	f7ff fff0 	bl	36abc <__sinit_lock_acquire>
   36adc:	69a3      	ldr	r3, [r4, #24]
   36ade:	b11b      	cbz	r3, 36ae8 <__sinit+0x14>
   36ae0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   36ae4:	f7ff bff0 	b.w	36ac8 <__sinit_lock_release>
   36ae8:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
   36aec:	6523      	str	r3, [r4, #80]	; 0x50
   36aee:	4620      	mov	r0, r4
   36af0:	4b12      	ldr	r3, [pc, #72]	; (36b3c <__sinit+0x68>)
   36af2:	4a13      	ldr	r2, [pc, #76]	; (36b40 <__sinit+0x6c>)
   36af4:	681b      	ldr	r3, [r3, #0]
   36af6:	62a2      	str	r2, [r4, #40]	; 0x28
   36af8:	42a3      	cmp	r3, r4
   36afa:	bf04      	itt	eq
   36afc:	2301      	moveq	r3, #1
   36afe:	61a3      	streq	r3, [r4, #24]
   36b00:	f000 f820 	bl	36b44 <__sfp>
   36b04:	6060      	str	r0, [r4, #4]
   36b06:	4620      	mov	r0, r4
   36b08:	f000 f81c 	bl	36b44 <__sfp>
   36b0c:	60a0      	str	r0, [r4, #8]
   36b0e:	4620      	mov	r0, r4
   36b10:	f000 f818 	bl	36b44 <__sfp>
   36b14:	2200      	movs	r2, #0
   36b16:	60e0      	str	r0, [r4, #12]
   36b18:	2104      	movs	r1, #4
   36b1a:	6860      	ldr	r0, [r4, #4]
   36b1c:	f7ff ff98 	bl	36a50 <std>
   36b20:	2201      	movs	r2, #1
   36b22:	2109      	movs	r1, #9
   36b24:	68a0      	ldr	r0, [r4, #8]
   36b26:	f7ff ff93 	bl	36a50 <std>
   36b2a:	2202      	movs	r2, #2
   36b2c:	2112      	movs	r1, #18
   36b2e:	68e0      	ldr	r0, [r4, #12]
   36b30:	f7ff ff8e 	bl	36a50 <std>
   36b34:	2301      	movs	r3, #1
   36b36:	61a3      	str	r3, [r4, #24]
   36b38:	e7d2      	b.n	36ae0 <__sinit+0xc>
   36b3a:	bf00      	nop
   36b3c:	0003b860 	.word	0x0003b860
   36b40:	00036a99 	.word	0x00036a99

00036b44 <__sfp>:
   36b44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   36b46:	4607      	mov	r7, r0
   36b48:	f7ff ffac 	bl	36aa4 <__sfp_lock_acquire>
   36b4c:	4b1e      	ldr	r3, [pc, #120]	; (36bc8 <__sfp+0x84>)
   36b4e:	681e      	ldr	r6, [r3, #0]
   36b50:	69b3      	ldr	r3, [r6, #24]
   36b52:	b913      	cbnz	r3, 36b5a <__sfp+0x16>
   36b54:	4630      	mov	r0, r6
   36b56:	f7ff ffbd 	bl	36ad4 <__sinit>
   36b5a:	3648      	adds	r6, #72	; 0x48
   36b5c:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
   36b60:	3b01      	subs	r3, #1
   36b62:	d503      	bpl.n	36b6c <__sfp+0x28>
   36b64:	6833      	ldr	r3, [r6, #0]
   36b66:	b30b      	cbz	r3, 36bac <__sfp+0x68>
   36b68:	6836      	ldr	r6, [r6, #0]
   36b6a:	e7f7      	b.n	36b5c <__sfp+0x18>
   36b6c:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
   36b70:	b9d5      	cbnz	r5, 36ba8 <__sfp+0x64>
   36b72:	4b16      	ldr	r3, [pc, #88]	; (36bcc <__sfp+0x88>)
   36b74:	f104 0058 	add.w	r0, r4, #88	; 0x58
   36b78:	6665      	str	r5, [r4, #100]	; 0x64
   36b7a:	60e3      	str	r3, [r4, #12]
   36b7c:	f003 fbae 	bl	3a2dc <__retarget_lock_init_recursive>
   36b80:	f7ff ff96 	bl	36ab0 <__sfp_lock_release>
   36b84:	6025      	str	r5, [r4, #0]
   36b86:	61a5      	str	r5, [r4, #24]
   36b88:	2208      	movs	r2, #8
   36b8a:	4629      	mov	r1, r5
   36b8c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   36b90:	e9c4 5501 	strd	r5, r5, [r4, #4]
   36b94:	e9c4 5504 	strd	r5, r5, [r4, #16]
   36b98:	f003 f911 	bl	39dbe <memset>
   36b9c:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
   36ba0:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
   36ba4:	4620      	mov	r0, r4
   36ba6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   36ba8:	3468      	adds	r4, #104	; 0x68
   36baa:	e7d9      	b.n	36b60 <__sfp+0x1c>
   36bac:	2104      	movs	r1, #4
   36bae:	4638      	mov	r0, r7
   36bb0:	f003 fb60 	bl	3a274 <__sfmoreglue>
   36bb4:	4604      	mov	r4, r0
   36bb6:	6030      	str	r0, [r6, #0]
   36bb8:	2800      	cmp	r0, #0
   36bba:	d1d5      	bne.n	36b68 <__sfp+0x24>
   36bbc:	f7ff ff78 	bl	36ab0 <__sfp_lock_release>
   36bc0:	230c      	movs	r3, #12
   36bc2:	603b      	str	r3, [r7, #0]
   36bc4:	e7ee      	b.n	36ba4 <__sfp+0x60>
   36bc6:	bf00      	nop
   36bc8:	0003b860 	.word	0x0003b860
   36bcc:	ffff0001 	.word	0xffff0001

00036bd0 <_localeconv_r>:
   36bd0:	4800      	ldr	r0, [pc, #0]	; (36bd4 <_localeconv_r+0x4>)
   36bd2:	4770      	bx	lr
   36bd4:	2002b1b4 	.word	0x2002b1b4

00036bd8 <__smakebuf_r>:
   36bd8:	898b      	ldrh	r3, [r1, #12]
   36bda:	b573      	push	{r0, r1, r4, r5, r6, lr}
   36bdc:	079d      	lsls	r5, r3, #30
   36bde:	4606      	mov	r6, r0
   36be0:	460c      	mov	r4, r1
   36be2:	d507      	bpl.n	36bf4 <__smakebuf_r+0x1c>
   36be4:	f104 0347 	add.w	r3, r4, #71	; 0x47
   36be8:	6023      	str	r3, [r4, #0]
   36bea:	6123      	str	r3, [r4, #16]
   36bec:	2301      	movs	r3, #1
   36bee:	6163      	str	r3, [r4, #20]
   36bf0:	b002      	add	sp, #8
   36bf2:	bd70      	pop	{r4, r5, r6, pc}
   36bf4:	ab01      	add	r3, sp, #4
   36bf6:	466a      	mov	r2, sp
   36bf8:	f003 fb73 	bl	3a2e2 <__swhatbuf_r>
   36bfc:	9900      	ldr	r1, [sp, #0]
   36bfe:	4605      	mov	r5, r0
   36c00:	4630      	mov	r0, r6
   36c02:	f000 f8cd 	bl	36da0 <_malloc_r>
   36c06:	b948      	cbnz	r0, 36c1c <__smakebuf_r+0x44>
   36c08:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   36c0c:	059a      	lsls	r2, r3, #22
   36c0e:	d4ef      	bmi.n	36bf0 <__smakebuf_r+0x18>
   36c10:	f023 0303 	bic.w	r3, r3, #3
   36c14:	f043 0302 	orr.w	r3, r3, #2
   36c18:	81a3      	strh	r3, [r4, #12]
   36c1a:	e7e3      	b.n	36be4 <__smakebuf_r+0xc>
   36c1c:	4b0d      	ldr	r3, [pc, #52]	; (36c54 <__smakebuf_r+0x7c>)
   36c1e:	62b3      	str	r3, [r6, #40]	; 0x28
   36c20:	89a3      	ldrh	r3, [r4, #12]
   36c22:	6020      	str	r0, [r4, #0]
   36c24:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   36c28:	6120      	str	r0, [r4, #16]
   36c2a:	81a3      	strh	r3, [r4, #12]
   36c2c:	9b00      	ldr	r3, [sp, #0]
   36c2e:	6163      	str	r3, [r4, #20]
   36c30:	9b01      	ldr	r3, [sp, #4]
   36c32:	b15b      	cbz	r3, 36c4c <__smakebuf_r+0x74>
   36c34:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   36c38:	4630      	mov	r0, r6
   36c3a:	f000 fa61 	bl	37100 <_isatty_r>
   36c3e:	b128      	cbz	r0, 36c4c <__smakebuf_r+0x74>
   36c40:	89a3      	ldrh	r3, [r4, #12]
   36c42:	f023 0303 	bic.w	r3, r3, #3
   36c46:	f043 0301 	orr.w	r3, r3, #1
   36c4a:	81a3      	strh	r3, [r4, #12]
   36c4c:	89a3      	ldrh	r3, [r4, #12]
   36c4e:	431d      	orrs	r5, r3
   36c50:	81a5      	strh	r5, [r4, #12]
   36c52:	e7cd      	b.n	36bf0 <__smakebuf_r+0x18>
   36c54:	00036a99 	.word	0x00036a99

00036c58 <malloc>:
   36c58:	4b02      	ldr	r3, [pc, #8]	; (36c64 <malloc+0xc>)
   36c5a:	4601      	mov	r1, r0
   36c5c:	6818      	ldr	r0, [r3, #0]
   36c5e:	f000 b89f 	b.w	36da0 <_malloc_r>
   36c62:	bf00      	nop
   36c64:	2002b060 	.word	0x2002b060

00036c68 <__pow5mult>:
   36c68:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   36c6c:	4615      	mov	r5, r2
   36c6e:	f012 0203 	ands.w	r2, r2, #3
   36c72:	4606      	mov	r6, r0
   36c74:	460f      	mov	r7, r1
   36c76:	d007      	beq.n	36c88 <__pow5mult+0x20>
   36c78:	3a01      	subs	r2, #1
   36c7a:	4c21      	ldr	r4, [pc, #132]	; (36d00 <__pow5mult+0x98>)
   36c7c:	2300      	movs	r3, #0
   36c7e:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
   36c82:	f003 fbb7 	bl	3a3f4 <__multadd>
   36c86:	4607      	mov	r7, r0
   36c88:	10ad      	asrs	r5, r5, #2
   36c8a:	d035      	beq.n	36cf8 <__pow5mult+0x90>
   36c8c:	6a74      	ldr	r4, [r6, #36]	; 0x24
   36c8e:	b93c      	cbnz	r4, 36ca0 <__pow5mult+0x38>
   36c90:	2010      	movs	r0, #16
   36c92:	f7ff ffe1 	bl	36c58 <malloc>
   36c96:	6270      	str	r0, [r6, #36]	; 0x24
   36c98:	6004      	str	r4, [r0, #0]
   36c9a:	60c4      	str	r4, [r0, #12]
   36c9c:	e9c0 4401 	strd	r4, r4, [r0, #4]
   36ca0:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
   36ca4:	f8d8 4008 	ldr.w	r4, [r8, #8]
   36ca8:	b94c      	cbnz	r4, 36cbe <__pow5mult+0x56>
   36caa:	f240 2171 	movw	r1, #625	; 0x271
   36cae:	4630      	mov	r0, r6
   36cb0:	f003 fc2d 	bl	3a50e <__i2b>
   36cb4:	2300      	movs	r3, #0
   36cb6:	4604      	mov	r4, r0
   36cb8:	f8c8 0008 	str.w	r0, [r8, #8]
   36cbc:	6003      	str	r3, [r0, #0]
   36cbe:	f04f 0800 	mov.w	r8, #0
   36cc2:	07eb      	lsls	r3, r5, #31
   36cc4:	d50a      	bpl.n	36cdc <__pow5mult+0x74>
   36cc6:	4639      	mov	r1, r7
   36cc8:	4622      	mov	r2, r4
   36cca:	4630      	mov	r0, r6
   36ccc:	f003 fc28 	bl	3a520 <__multiply>
   36cd0:	4681      	mov	r9, r0
   36cd2:	4639      	mov	r1, r7
   36cd4:	4630      	mov	r0, r6
   36cd6:	464f      	mov	r7, r9
   36cd8:	f003 fb75 	bl	3a3c6 <_Bfree>
   36cdc:	106d      	asrs	r5, r5, #1
   36cde:	d00b      	beq.n	36cf8 <__pow5mult+0x90>
   36ce0:	6820      	ldr	r0, [r4, #0]
   36ce2:	b938      	cbnz	r0, 36cf4 <__pow5mult+0x8c>
   36ce4:	4622      	mov	r2, r4
   36ce6:	4621      	mov	r1, r4
   36ce8:	4630      	mov	r0, r6
   36cea:	f003 fc19 	bl	3a520 <__multiply>
   36cee:	6020      	str	r0, [r4, #0]
   36cf0:	f8c0 8000 	str.w	r8, [r0]
   36cf4:	4604      	mov	r4, r0
   36cf6:	e7e4      	b.n	36cc2 <__pow5mult+0x5a>
   36cf8:	4638      	mov	r0, r7
   36cfa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   36cfe:	bf00      	nop
   36d00:	0003b8c4 	.word	0x0003b8c4

00036d04 <_free_r>:
   36d04:	b538      	push	{r3, r4, r5, lr}
   36d06:	4605      	mov	r5, r0
   36d08:	2900      	cmp	r1, #0
   36d0a:	d045      	beq.n	36d98 <_free_r+0x94>
   36d0c:	f851 3c04 	ldr.w	r3, [r1, #-4]
   36d10:	1f0c      	subs	r4, r1, #4
   36d12:	2b00      	cmp	r3, #0
   36d14:	bfb8      	it	lt
   36d16:	18e4      	addlt	r4, r4, r3
   36d18:	f000 fa14 	bl	37144 <__malloc_lock>
   36d1c:	4a1f      	ldr	r2, [pc, #124]	; (36d9c <_free_r+0x98>)
   36d1e:	6813      	ldr	r3, [r2, #0]
   36d20:	4610      	mov	r0, r2
   36d22:	b933      	cbnz	r3, 36d32 <_free_r+0x2e>
   36d24:	6063      	str	r3, [r4, #4]
   36d26:	6014      	str	r4, [r2, #0]
   36d28:	4628      	mov	r0, r5
   36d2a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   36d2e:	f000 ba0f 	b.w	37150 <__malloc_unlock>
   36d32:	42a3      	cmp	r3, r4
   36d34:	d90c      	bls.n	36d50 <_free_r+0x4c>
   36d36:	6821      	ldr	r1, [r4, #0]
   36d38:	1862      	adds	r2, r4, r1
   36d3a:	4293      	cmp	r3, r2
   36d3c:	bf02      	ittt	eq
   36d3e:	681a      	ldreq	r2, [r3, #0]
   36d40:	685b      	ldreq	r3, [r3, #4]
   36d42:	1852      	addeq	r2, r2, r1
   36d44:	6063      	str	r3, [r4, #4]
   36d46:	bf08      	it	eq
   36d48:	6022      	streq	r2, [r4, #0]
   36d4a:	6004      	str	r4, [r0, #0]
   36d4c:	e7ec      	b.n	36d28 <_free_r+0x24>
   36d4e:	4613      	mov	r3, r2
   36d50:	685a      	ldr	r2, [r3, #4]
   36d52:	b10a      	cbz	r2, 36d58 <_free_r+0x54>
   36d54:	42a2      	cmp	r2, r4
   36d56:	d9fa      	bls.n	36d4e <_free_r+0x4a>
   36d58:	6819      	ldr	r1, [r3, #0]
   36d5a:	1858      	adds	r0, r3, r1
   36d5c:	42a0      	cmp	r0, r4
   36d5e:	d10b      	bne.n	36d78 <_free_r+0x74>
   36d60:	6820      	ldr	r0, [r4, #0]
   36d62:	4401      	add	r1, r0
   36d64:	1858      	adds	r0, r3, r1
   36d66:	6019      	str	r1, [r3, #0]
   36d68:	4282      	cmp	r2, r0
   36d6a:	d1dd      	bne.n	36d28 <_free_r+0x24>
   36d6c:	6810      	ldr	r0, [r2, #0]
   36d6e:	6852      	ldr	r2, [r2, #4]
   36d70:	4401      	add	r1, r0
   36d72:	605a      	str	r2, [r3, #4]
   36d74:	6019      	str	r1, [r3, #0]
   36d76:	e7d7      	b.n	36d28 <_free_r+0x24>
   36d78:	d902      	bls.n	36d80 <_free_r+0x7c>
   36d7a:	230c      	movs	r3, #12
   36d7c:	602b      	str	r3, [r5, #0]
   36d7e:	e7d3      	b.n	36d28 <_free_r+0x24>
   36d80:	6820      	ldr	r0, [r4, #0]
   36d82:	1821      	adds	r1, r4, r0
   36d84:	428a      	cmp	r2, r1
   36d86:	bf02      	ittt	eq
   36d88:	6811      	ldreq	r1, [r2, #0]
   36d8a:	6852      	ldreq	r2, [r2, #4]
   36d8c:	1809      	addeq	r1, r1, r0
   36d8e:	6062      	str	r2, [r4, #4]
   36d90:	bf08      	it	eq
   36d92:	6021      	streq	r1, [r4, #0]
   36d94:	605c      	str	r4, [r3, #4]
   36d96:	e7c7      	b.n	36d28 <_free_r+0x24>
   36d98:	bd38      	pop	{r3, r4, r5, pc}
   36d9a:	bf00      	nop
   36d9c:	20022228 	.word	0x20022228

00036da0 <_malloc_r>:
   36da0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   36da2:	1ccd      	adds	r5, r1, #3
   36da4:	4606      	mov	r6, r0
   36da6:	f025 0503 	bic.w	r5, r5, #3
   36daa:	3508      	adds	r5, #8
   36dac:	2d0c      	cmp	r5, #12
   36dae:	bf38      	it	cc
   36db0:	250c      	movcc	r5, #12
   36db2:	2d00      	cmp	r5, #0
   36db4:	db01      	blt.n	36dba <_malloc_r+0x1a>
   36db6:	42a9      	cmp	r1, r5
   36db8:	d903      	bls.n	36dc2 <_malloc_r+0x22>
   36dba:	230c      	movs	r3, #12
   36dbc:	6033      	str	r3, [r6, #0]
   36dbe:	2000      	movs	r0, #0
   36dc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   36dc2:	f000 f9bf 	bl	37144 <__malloc_lock>
   36dc6:	4921      	ldr	r1, [pc, #132]	; (36e4c <_malloc_r+0xac>)
   36dc8:	680a      	ldr	r2, [r1, #0]
   36dca:	4614      	mov	r4, r2
   36dcc:	b99c      	cbnz	r4, 36df6 <_malloc_r+0x56>
   36dce:	4f20      	ldr	r7, [pc, #128]	; (36e50 <_malloc_r+0xb0>)
   36dd0:	683b      	ldr	r3, [r7, #0]
   36dd2:	b923      	cbnz	r3, 36dde <_malloc_r+0x3e>
   36dd4:	4621      	mov	r1, r4
   36dd6:	4630      	mov	r0, r6
   36dd8:	f000 f934 	bl	37044 <_sbrk_r>
   36ddc:	6038      	str	r0, [r7, #0]
   36dde:	4629      	mov	r1, r5
   36de0:	4630      	mov	r0, r6
   36de2:	f000 f92f 	bl	37044 <_sbrk_r>
   36de6:	1c43      	adds	r3, r0, #1
   36de8:	d123      	bne.n	36e32 <_malloc_r+0x92>
   36dea:	230c      	movs	r3, #12
   36dec:	4630      	mov	r0, r6
   36dee:	6033      	str	r3, [r6, #0]
   36df0:	f000 f9ae 	bl	37150 <__malloc_unlock>
   36df4:	e7e3      	b.n	36dbe <_malloc_r+0x1e>
   36df6:	6823      	ldr	r3, [r4, #0]
   36df8:	1b5b      	subs	r3, r3, r5
   36dfa:	d417      	bmi.n	36e2c <_malloc_r+0x8c>
   36dfc:	2b0b      	cmp	r3, #11
   36dfe:	d903      	bls.n	36e08 <_malloc_r+0x68>
   36e00:	6023      	str	r3, [r4, #0]
   36e02:	441c      	add	r4, r3
   36e04:	6025      	str	r5, [r4, #0]
   36e06:	e004      	b.n	36e12 <_malloc_r+0x72>
   36e08:	6863      	ldr	r3, [r4, #4]
   36e0a:	42a2      	cmp	r2, r4
   36e0c:	bf0c      	ite	eq
   36e0e:	600b      	streq	r3, [r1, #0]
   36e10:	6053      	strne	r3, [r2, #4]
   36e12:	4630      	mov	r0, r6
   36e14:	f000 f99c 	bl	37150 <__malloc_unlock>
   36e18:	f104 000b 	add.w	r0, r4, #11
   36e1c:	1d23      	adds	r3, r4, #4
   36e1e:	f020 0007 	bic.w	r0, r0, #7
   36e22:	1ac2      	subs	r2, r0, r3
   36e24:	d0cc      	beq.n	36dc0 <_malloc_r+0x20>
   36e26:	1a1b      	subs	r3, r3, r0
   36e28:	50a3      	str	r3, [r4, r2]
   36e2a:	e7c9      	b.n	36dc0 <_malloc_r+0x20>
   36e2c:	4622      	mov	r2, r4
   36e2e:	6864      	ldr	r4, [r4, #4]
   36e30:	e7cc      	b.n	36dcc <_malloc_r+0x2c>
   36e32:	1cc4      	adds	r4, r0, #3
   36e34:	f024 0403 	bic.w	r4, r4, #3
   36e38:	42a0      	cmp	r0, r4
   36e3a:	d0e3      	beq.n	36e04 <_malloc_r+0x64>
   36e3c:	1a21      	subs	r1, r4, r0
   36e3e:	4630      	mov	r0, r6
   36e40:	f000 f900 	bl	37044 <_sbrk_r>
   36e44:	3001      	adds	r0, #1
   36e46:	d1dd      	bne.n	36e04 <_malloc_r+0x64>
   36e48:	e7cf      	b.n	36dea <_malloc_r+0x4a>
   36e4a:	bf00      	nop
   36e4c:	20022228 	.word	0x20022228
   36e50:	2002222c 	.word	0x2002222c

00036e54 <_svfiprintf_r>:
   36e54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   36e58:	461e      	mov	r6, r3
   36e5a:	898b      	ldrh	r3, [r1, #12]
   36e5c:	b09d      	sub	sp, #116	; 0x74
   36e5e:	4607      	mov	r7, r0
   36e60:	061b      	lsls	r3, r3, #24
   36e62:	460d      	mov	r5, r1
   36e64:	4614      	mov	r4, r2
   36e66:	d50e      	bpl.n	36e86 <_svfiprintf_r+0x32>
   36e68:	690b      	ldr	r3, [r1, #16]
   36e6a:	b963      	cbnz	r3, 36e86 <_svfiprintf_r+0x32>
   36e6c:	2140      	movs	r1, #64	; 0x40
   36e6e:	f7ff ff97 	bl	36da0 <_malloc_r>
   36e72:	6028      	str	r0, [r5, #0]
   36e74:	6128      	str	r0, [r5, #16]
   36e76:	b920      	cbnz	r0, 36e82 <_svfiprintf_r+0x2e>
   36e78:	230c      	movs	r3, #12
   36e7a:	603b      	str	r3, [r7, #0]
   36e7c:	f04f 30ff 	mov.w	r0, #4294967295
   36e80:	e0c9      	b.n	37016 <_svfiprintf_r+0x1c2>
   36e82:	2340      	movs	r3, #64	; 0x40
   36e84:	616b      	str	r3, [r5, #20]
   36e86:	2300      	movs	r3, #0
   36e88:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 37030 <_svfiprintf_r+0x1dc>
   36e8c:	f04f 0a01 	mov.w	sl, #1
   36e90:	9603      	str	r6, [sp, #12]
   36e92:	9309      	str	r3, [sp, #36]	; 0x24
   36e94:	2320      	movs	r3, #32
   36e96:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   36e9a:	2330      	movs	r3, #48	; 0x30
   36e9c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   36ea0:	4623      	mov	r3, r4
   36ea2:	461e      	mov	r6, r3
   36ea4:	f813 2b01 	ldrb.w	r2, [r3], #1
   36ea8:	b10a      	cbz	r2, 36eae <_svfiprintf_r+0x5a>
   36eaa:	2a25      	cmp	r2, #37	; 0x25
   36eac:	d1f9      	bne.n	36ea2 <_svfiprintf_r+0x4e>
   36eae:	ebb6 0b04 	subs.w	fp, r6, r4
   36eb2:	d00b      	beq.n	36ecc <_svfiprintf_r+0x78>
   36eb4:	465b      	mov	r3, fp
   36eb6:	4622      	mov	r2, r4
   36eb8:	4629      	mov	r1, r5
   36eba:	4638      	mov	r0, r7
   36ebc:	f003 fd0e 	bl	3a8dc <__ssputs_r>
   36ec0:	3001      	adds	r0, #1
   36ec2:	f000 80a3 	beq.w	3700c <_svfiprintf_r+0x1b8>
   36ec6:	9b09      	ldr	r3, [sp, #36]	; 0x24
   36ec8:	445b      	add	r3, fp
   36eca:	9309      	str	r3, [sp, #36]	; 0x24
   36ecc:	7833      	ldrb	r3, [r6, #0]
   36ece:	2b00      	cmp	r3, #0
   36ed0:	f000 809c 	beq.w	3700c <_svfiprintf_r+0x1b8>
   36ed4:	2300      	movs	r3, #0
   36ed6:	f04f 32ff 	mov.w	r2, #4294967295
   36eda:	3601      	adds	r6, #1
   36edc:	9304      	str	r3, [sp, #16]
   36ede:	9307      	str	r3, [sp, #28]
   36ee0:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   36ee4:	931a      	str	r3, [sp, #104]	; 0x68
   36ee6:	e9cd 2305 	strd	r2, r3, [sp, #20]
   36eea:	4634      	mov	r4, r6
   36eec:	2205      	movs	r2, #5
   36eee:	4850      	ldr	r0, [pc, #320]	; (37030 <_svfiprintf_r+0x1dc>)
   36ef0:	f814 1b01 	ldrb.w	r1, [r4], #1
   36ef4:	f002 ff27 	bl	39d46 <memchr>
   36ef8:	9b04      	ldr	r3, [sp, #16]
   36efa:	b9c0      	cbnz	r0, 36f2e <_svfiprintf_r+0xda>
   36efc:	06d9      	lsls	r1, r3, #27
   36efe:	bf44      	itt	mi
   36f00:	2220      	movmi	r2, #32
   36f02:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   36f06:	071a      	lsls	r2, r3, #28
   36f08:	bf44      	itt	mi
   36f0a:	222b      	movmi	r2, #43	; 0x2b
   36f0c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   36f10:	7832      	ldrb	r2, [r6, #0]
   36f12:	2a2a      	cmp	r2, #42	; 0x2a
   36f14:	d013      	beq.n	36f3e <_svfiprintf_r+0xea>
   36f16:	4634      	mov	r4, r6
   36f18:	9a07      	ldr	r2, [sp, #28]
   36f1a:	2000      	movs	r0, #0
   36f1c:	260a      	movs	r6, #10
   36f1e:	4621      	mov	r1, r4
   36f20:	f811 3b01 	ldrb.w	r3, [r1], #1
   36f24:	3b30      	subs	r3, #48	; 0x30
   36f26:	2b09      	cmp	r3, #9
   36f28:	d94b      	bls.n	36fc2 <_svfiprintf_r+0x16e>
   36f2a:	b970      	cbnz	r0, 36f4a <_svfiprintf_r+0xf6>
   36f2c:	e014      	b.n	36f58 <_svfiprintf_r+0x104>
   36f2e:	eba0 0009 	sub.w	r0, r0, r9
   36f32:	4626      	mov	r6, r4
   36f34:	fa0a f000 	lsl.w	r0, sl, r0
   36f38:	4318      	orrs	r0, r3
   36f3a:	9004      	str	r0, [sp, #16]
   36f3c:	e7d5      	b.n	36eea <_svfiprintf_r+0x96>
   36f3e:	9a03      	ldr	r2, [sp, #12]
   36f40:	1d11      	adds	r1, r2, #4
   36f42:	6812      	ldr	r2, [r2, #0]
   36f44:	2a00      	cmp	r2, #0
   36f46:	9103      	str	r1, [sp, #12]
   36f48:	db01      	blt.n	36f4e <_svfiprintf_r+0xfa>
   36f4a:	9207      	str	r2, [sp, #28]
   36f4c:	e004      	b.n	36f58 <_svfiprintf_r+0x104>
   36f4e:	4252      	negs	r2, r2
   36f50:	f043 0302 	orr.w	r3, r3, #2
   36f54:	9207      	str	r2, [sp, #28]
   36f56:	9304      	str	r3, [sp, #16]
   36f58:	7823      	ldrb	r3, [r4, #0]
   36f5a:	2b2e      	cmp	r3, #46	; 0x2e
   36f5c:	d10c      	bne.n	36f78 <_svfiprintf_r+0x124>
   36f5e:	7863      	ldrb	r3, [r4, #1]
   36f60:	2b2a      	cmp	r3, #42	; 0x2a
   36f62:	d133      	bne.n	36fcc <_svfiprintf_r+0x178>
   36f64:	9b03      	ldr	r3, [sp, #12]
   36f66:	3402      	adds	r4, #2
   36f68:	1d1a      	adds	r2, r3, #4
   36f6a:	681b      	ldr	r3, [r3, #0]
   36f6c:	2b00      	cmp	r3, #0
   36f6e:	9203      	str	r2, [sp, #12]
   36f70:	bfb8      	it	lt
   36f72:	f04f 33ff 	movlt.w	r3, #4294967295
   36f76:	9305      	str	r3, [sp, #20]
   36f78:	4e2e      	ldr	r6, [pc, #184]	; (37034 <_svfiprintf_r+0x1e0>)
   36f7a:	2203      	movs	r2, #3
   36f7c:	7821      	ldrb	r1, [r4, #0]
   36f7e:	4630      	mov	r0, r6
   36f80:	f002 fee1 	bl	39d46 <memchr>
   36f84:	b138      	cbz	r0, 36f96 <_svfiprintf_r+0x142>
   36f86:	2340      	movs	r3, #64	; 0x40
   36f88:	1b80      	subs	r0, r0, r6
   36f8a:	3401      	adds	r4, #1
   36f8c:	fa03 f000 	lsl.w	r0, r3, r0
   36f90:	9b04      	ldr	r3, [sp, #16]
   36f92:	4303      	orrs	r3, r0
   36f94:	9304      	str	r3, [sp, #16]
   36f96:	f814 1b01 	ldrb.w	r1, [r4], #1
   36f9a:	2206      	movs	r2, #6
   36f9c:	4826      	ldr	r0, [pc, #152]	; (37038 <_svfiprintf_r+0x1e4>)
   36f9e:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   36fa2:	f002 fed0 	bl	39d46 <memchr>
   36fa6:	2800      	cmp	r0, #0
   36fa8:	d038      	beq.n	3701c <_svfiprintf_r+0x1c8>
   36faa:	4b24      	ldr	r3, [pc, #144]	; (3703c <_svfiprintf_r+0x1e8>)
   36fac:	bb13      	cbnz	r3, 36ff4 <_svfiprintf_r+0x1a0>
   36fae:	9b03      	ldr	r3, [sp, #12]
   36fb0:	3307      	adds	r3, #7
   36fb2:	f023 0307 	bic.w	r3, r3, #7
   36fb6:	3308      	adds	r3, #8
   36fb8:	9303      	str	r3, [sp, #12]
   36fba:	9b09      	ldr	r3, [sp, #36]	; 0x24
   36fbc:	4443      	add	r3, r8
   36fbe:	9309      	str	r3, [sp, #36]	; 0x24
   36fc0:	e76e      	b.n	36ea0 <_svfiprintf_r+0x4c>
   36fc2:	fb06 3202 	mla	r2, r6, r2, r3
   36fc6:	2001      	movs	r0, #1
   36fc8:	460c      	mov	r4, r1
   36fca:	e7a8      	b.n	36f1e <_svfiprintf_r+0xca>
   36fcc:	2300      	movs	r3, #0
   36fce:	3401      	adds	r4, #1
   36fd0:	260a      	movs	r6, #10
   36fd2:	4619      	mov	r1, r3
   36fd4:	9305      	str	r3, [sp, #20]
   36fd6:	4620      	mov	r0, r4
   36fd8:	f810 2b01 	ldrb.w	r2, [r0], #1
   36fdc:	3a30      	subs	r2, #48	; 0x30
   36fde:	2a09      	cmp	r2, #9
   36fe0:	d903      	bls.n	36fea <_svfiprintf_r+0x196>
   36fe2:	2b00      	cmp	r3, #0
   36fe4:	d0c8      	beq.n	36f78 <_svfiprintf_r+0x124>
   36fe6:	9105      	str	r1, [sp, #20]
   36fe8:	e7c6      	b.n	36f78 <_svfiprintf_r+0x124>
   36fea:	fb06 2101 	mla	r1, r6, r1, r2
   36fee:	2301      	movs	r3, #1
   36ff0:	4604      	mov	r4, r0
   36ff2:	e7f0      	b.n	36fd6 <_svfiprintf_r+0x182>
   36ff4:	ab03      	add	r3, sp, #12
   36ff6:	462a      	mov	r2, r5
   36ff8:	a904      	add	r1, sp, #16
   36ffa:	4638      	mov	r0, r7
   36ffc:	9300      	str	r3, [sp, #0]
   36ffe:	4b10      	ldr	r3, [pc, #64]	; (37040 <_svfiprintf_r+0x1ec>)
   37000:	f7fe fec2 	bl	35d88 <_printf_float>
   37004:	f1b0 3fff 	cmp.w	r0, #4294967295
   37008:	4680      	mov	r8, r0
   3700a:	d1d6      	bne.n	36fba <_svfiprintf_r+0x166>
   3700c:	89ab      	ldrh	r3, [r5, #12]
   3700e:	065b      	lsls	r3, r3, #25
   37010:	f53f af34 	bmi.w	36e7c <_svfiprintf_r+0x28>
   37014:	9809      	ldr	r0, [sp, #36]	; 0x24
   37016:	b01d      	add	sp, #116	; 0x74
   37018:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3701c:	ab03      	add	r3, sp, #12
   3701e:	462a      	mov	r2, r5
   37020:	a904      	add	r1, sp, #16
   37022:	4638      	mov	r0, r7
   37024:	9300      	str	r3, [sp, #0]
   37026:	4b06      	ldr	r3, [pc, #24]	; (37040 <_svfiprintf_r+0x1ec>)
   37028:	f7ff f8d8 	bl	361dc <_printf_i>
   3702c:	e7ea      	b.n	37004 <_svfiprintf_r+0x1b0>
   3702e:	bf00      	nop
   37030:	0003f6ca 	.word	0x0003f6ca
   37034:	0003f6d0 	.word	0x0003f6d0
   37038:	0003f6d4 	.word	0x0003f6d4
   3703c:	00035d89 	.word	0x00035d89
   37040:	0003a8dd 	.word	0x0003a8dd

00037044 <_sbrk_r>:
   37044:	b538      	push	{r3, r4, r5, lr}
   37046:	2300      	movs	r3, #0
   37048:	4c05      	ldr	r4, [pc, #20]	; (37060 <_sbrk_r+0x1c>)
   3704a:	4605      	mov	r5, r0
   3704c:	4608      	mov	r0, r1
   3704e:	6023      	str	r3, [r4, #0]
   37050:	f7ee ff2c 	bl	25eac <_sbrk>
   37054:	1c43      	adds	r3, r0, #1
   37056:	d102      	bne.n	3705e <_sbrk_r+0x1a>
   37058:	6823      	ldr	r3, [r4, #0]
   3705a:	b103      	cbz	r3, 3705e <_sbrk_r+0x1a>
   3705c:	602b      	str	r3, [r5, #0]
   3705e:	bd38      	pop	{r3, r4, r5, pc}
   37060:	20026290 	.word	0x20026290

00037064 <raise>:
   37064:	4b02      	ldr	r3, [pc, #8]	; (37070 <raise+0xc>)
   37066:	4601      	mov	r1, r0
   37068:	6818      	ldr	r0, [r3, #0]
   3706a:	f003 bc92 	b.w	3a992 <_raise_r>
   3706e:	bf00      	nop
   37070:	2002b060 	.word	0x2002b060

00037074 <_kill_r>:
   37074:	b538      	push	{r3, r4, r5, lr}
   37076:	2300      	movs	r3, #0
   37078:	4c06      	ldr	r4, [pc, #24]	; (37094 <_kill_r+0x20>)
   3707a:	4605      	mov	r5, r0
   3707c:	4608      	mov	r0, r1
   3707e:	4611      	mov	r1, r2
   37080:	6023      	str	r3, [r4, #0]
   37082:	f001 f80f 	bl	380a4 <_kill>
   37086:	1c43      	adds	r3, r0, #1
   37088:	d102      	bne.n	37090 <_kill_r+0x1c>
   3708a:	6823      	ldr	r3, [r4, #0]
   3708c:	b103      	cbz	r3, 37090 <_kill_r+0x1c>
   3708e:	602b      	str	r3, [r5, #0]
   37090:	bd38      	pop	{r3, r4, r5, pc}
   37092:	bf00      	nop
   37094:	20026290 	.word	0x20026290

00037098 <_write_r>:
   37098:	b538      	push	{r3, r4, r5, lr}
   3709a:	4605      	mov	r5, r0
   3709c:	4c06      	ldr	r4, [pc, #24]	; (370b8 <_write_r+0x20>)
   3709e:	4608      	mov	r0, r1
   370a0:	4611      	mov	r1, r2
   370a2:	2200      	movs	r2, #0
   370a4:	6022      	str	r2, [r4, #0]
   370a6:	461a      	mov	r2, r3
   370a8:	f000 fff1 	bl	3808e <_write>
   370ac:	1c43      	adds	r3, r0, #1
   370ae:	d102      	bne.n	370b6 <_write_r+0x1e>
   370b0:	6823      	ldr	r3, [r4, #0]
   370b2:	b103      	cbz	r3, 370b6 <_write_r+0x1e>
   370b4:	602b      	str	r3, [r5, #0]
   370b6:	bd38      	pop	{r3, r4, r5, pc}
   370b8:	20026290 	.word	0x20026290

000370bc <_close_r>:
   370bc:	b538      	push	{r3, r4, r5, lr}
   370be:	2300      	movs	r3, #0
   370c0:	4c05      	ldr	r4, [pc, #20]	; (370d8 <_close_r+0x1c>)
   370c2:	4605      	mov	r5, r0
   370c4:	4608      	mov	r0, r1
   370c6:	6023      	str	r3, [r4, #0]
   370c8:	f000 ffe5 	bl	38096 <_close>
   370cc:	1c43      	adds	r3, r0, #1
   370ce:	d102      	bne.n	370d6 <_close_r+0x1a>
   370d0:	6823      	ldr	r3, [r4, #0]
   370d2:	b103      	cbz	r3, 370d6 <_close_r+0x1a>
   370d4:	602b      	str	r3, [r5, #0]
   370d6:	bd38      	pop	{r3, r4, r5, pc}
   370d8:	20026290 	.word	0x20026290

000370dc <_fstat_r>:
   370dc:	b538      	push	{r3, r4, r5, lr}
   370de:	2300      	movs	r3, #0
   370e0:	4c06      	ldr	r4, [pc, #24]	; (370fc <_fstat_r+0x20>)
   370e2:	4605      	mov	r5, r0
   370e4:	4608      	mov	r0, r1
   370e6:	4611      	mov	r1, r2
   370e8:	6023      	str	r3, [r4, #0]
   370ea:	f000 ffdf 	bl	380ac <_fstat>
   370ee:	1c43      	adds	r3, r0, #1
   370f0:	d102      	bne.n	370f8 <_fstat_r+0x1c>
   370f2:	6823      	ldr	r3, [r4, #0]
   370f4:	b103      	cbz	r3, 370f8 <_fstat_r+0x1c>
   370f6:	602b      	str	r3, [r5, #0]
   370f8:	bd38      	pop	{r3, r4, r5, pc}
   370fa:	bf00      	nop
   370fc:	20026290 	.word	0x20026290

00037100 <_isatty_r>:
   37100:	b538      	push	{r3, r4, r5, lr}
   37102:	2300      	movs	r3, #0
   37104:	4c05      	ldr	r4, [pc, #20]	; (3711c <_isatty_r+0x1c>)
   37106:	4605      	mov	r5, r0
   37108:	4608      	mov	r0, r1
   3710a:	6023      	str	r3, [r4, #0]
   3710c:	f000 ffc8 	bl	380a0 <_isatty>
   37110:	1c43      	adds	r3, r0, #1
   37112:	d102      	bne.n	3711a <_isatty_r+0x1a>
   37114:	6823      	ldr	r3, [r4, #0]
   37116:	b103      	cbz	r3, 3711a <_isatty_r+0x1a>
   37118:	602b      	str	r3, [r5, #0]
   3711a:	bd38      	pop	{r3, r4, r5, pc}
   3711c:	20026290 	.word	0x20026290

00037120 <_lseek_r>:
   37120:	b538      	push	{r3, r4, r5, lr}
   37122:	4605      	mov	r5, r0
   37124:	4c06      	ldr	r4, [pc, #24]	; (37140 <_lseek_r+0x20>)
   37126:	4608      	mov	r0, r1
   37128:	4611      	mov	r1, r2
   3712a:	2200      	movs	r2, #0
   3712c:	6022      	str	r2, [r4, #0]
   3712e:	461a      	mov	r2, r3
   37130:	f000 ffb4 	bl	3809c <_lseek>
   37134:	1c43      	adds	r3, r0, #1
   37136:	d102      	bne.n	3713e <_lseek_r+0x1e>
   37138:	6823      	ldr	r3, [r4, #0]
   3713a:	b103      	cbz	r3, 3713e <_lseek_r+0x1e>
   3713c:	602b      	str	r3, [r5, #0]
   3713e:	bd38      	pop	{r3, r4, r5, pc}
   37140:	20026290 	.word	0x20026290

00037144 <__malloc_lock>:
   37144:	4801      	ldr	r0, [pc, #4]	; (3714c <__malloc_lock+0x8>)
   37146:	f003 b8ca 	b.w	3a2de <__retarget_lock_acquire_recursive>
   3714a:	bf00      	nop
   3714c:	20026298 	.word	0x20026298

00037150 <__malloc_unlock>:
   37150:	4801      	ldr	r0, [pc, #4]	; (37158 <__malloc_unlock+0x8>)
   37152:	f003 b8c5 	b.w	3a2e0 <__retarget_lock_release_recursive>
   37156:	bf00      	nop
   37158:	20026298 	.word	0x20026298

0003715c <_read_r>:
   3715c:	b538      	push	{r3, r4, r5, lr}
   3715e:	4605      	mov	r5, r0
   37160:	4c06      	ldr	r4, [pc, #24]	; (3717c <_read_r+0x20>)
   37162:	4608      	mov	r0, r1
   37164:	4611      	mov	r1, r2
   37166:	2200      	movs	r2, #0
   37168:	6022      	str	r2, [r4, #0]
   3716a:	461a      	mov	r2, r3
   3716c:	f000 ff8b 	bl	38086 <_read>
   37170:	1c43      	adds	r3, r0, #1
   37172:	d102      	bne.n	3717a <_read_r+0x1e>
   37174:	6823      	ldr	r3, [r4, #0]
   37176:	b103      	cbz	r3, 3717a <_read_r+0x1e>
   37178:	602b      	str	r3, [r5, #0]
   3717a:	bd38      	pop	{r3, r4, r5, pc}
   3717c:	20026290 	.word	0x20026290

00037180 <system_init>:
		LOG_INF("Could not set leds state, err code: %d\n", err);
	}
}

void system_init(void)
{
   37180:	b508      	push	{r3, lr}
	InitSystemSettings();
   37182:	f7e8 fc51 	bl	1fa28 <InitSystemSettings>
	
	pmu_init();
   37186:	f7eb fc53 	bl	22a30 <pmu_init>
	flash_init();
   3718a:	f7e8 fdad 	bl	1fce8 <flash_init>
	LCD_Init();
   3718e:	f7e7 ff73 	bl	1f078 <LCD_Init>
	
	ShowBootUpLogo();
   37192:	f7ea fcad 	bl	21af0 <ShowBootUpLogo>

	key_init();
   37196:	f7e8 facd 	bl	1f734 <key_init>
	//IMU_init();
	ble_init();//UART_0ATAT
   3719a:	f7e9 fc87 	bl	20aac <ble_init>

	EnterIdleScreen();
}
   3719e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	EnterIdleScreen();
   371a2:	f7eb b9a1 	b.w	224e8 <EnterIdleScreen>

000371a6 <main>:
*    : main 
*    :  
*  : int 
**************************************************************************/
int main(void)
{
   371a6:	b508      	push	{r3, lr}
	system_init();
   371a8:	f7ff ffea 	bl	37180 <system_init>
//	test_i2c();
//	test_bat_soc();

	while(1)
	{
		TimeMsgProcess();
   371ac:	f7e7 fb10 	bl	1e7d0 <TimeMsgProcess>
		NBMsgProcess();
   371b0:	f7ea fc4a 	bl	21a48 <NBMsgProcess>
		GPSMsgProcess();
   371b4:	f7e9 ff68 	bl	21088 <GPSMsgProcess>
		PMUMsgProcess();
   371b8:	f7eb fe26 	bl	22e08 <PMUMsgProcess>
		//IMUMsgProcess();
		LCDMsgProcess();
   371bc:	f7e7 fe4c 	bl	1ee58 <LCDMsgProcess>
		//TPMsgProcess();
		AlarmMsgProcess();
   371c0:	f7e7 fc2a 	bl	1ea18 <AlarmMsgProcess>
		SettingsMsgPorcess();
   371c4:	f7e8 fc9e 	bl	1fb04 <SettingsMsgPorcess>

		ScreenMsgProcess();
   371c8:	f7eb fa0e 	bl	225e8 <ScreenMsgProcess>
   371cc:	f7ed feb2 	bl	24f34 <arch_cpu_idle>
   371d0:	e7ec      	b.n	371ac <main+0x6>

000371d2 <GetWeekDayByDate>:
{
   371d2:	b082      	sub	sp, #8
   371d4:	ab02      	add	r3, sp, #8
   371d6:	e903 0003 	stmdb	r3, {r0, r1}
   371da:	f8bd 1000 	ldrh.w	r1, [sp]
	if(date.year < SYSTEM_STARTING_YEAR)
   371de:	f5b1 6ff0 	cmp.w	r1, #1920	; 0x780
   371e2:	d34c      	bcc.n	3727e <GetWeekDayByDate+0xac>
	uint32_t i,count=0;
   371e4:	2200      	movs	r2, #0
	for(i=SYSTEM_STARTING_YEAR;i<date.year;i++)
   371e6:	f44f 63f0 	mov.w	r3, #1920	; 0x780
   371ea:	4299      	cmp	r1, r3
   371ec:	d813      	bhi.n	37216 <GetWeekDayByDate+0x44>
	if(date.year%4 == 0)
   371ee:	f011 0f03 	tst.w	r1, #3
	switch(date.month)
   371f2:	f89d 1002 	ldrb.w	r1, [sp, #2]
	if(date.year%4 == 0)
   371f6:	bf08      	it	eq
   371f8:	2301      	moveq	r3, #1
	switch(date.month)
   371fa:	f1a1 0102 	sub.w	r1, r1, #2
	if(date.year%4 == 0)
   371fe:	bf18      	it	ne
   37200:	2300      	movne	r3, #0
	switch(date.month)
   37202:	290a      	cmp	r1, #10
   37204:	d810      	bhi.n	37228 <GetWeekDayByDate+0x56>
   37206:	e8df f001 	tbb	[pc, r1]
   3720a:	220e      	.short	0x220e
   3720c:	2b292725 	.word	0x2b292725
   37210:	34312f2d 	.word	0x34312f2d
   37214:	37          	.byte	0x37
   37215:	00          	.byte	0x00
		if(i%4 == 0)	//366
   37216:	0798      	lsls	r0, r3, #30
			count += 366;
   37218:	bf0c      	ite	eq
   3721a:	f502 72b7 	addeq.w	r2, r2, #366	; 0x16e
			count += 365;
   3721e:	f202 126d 	addwne	r2, r2, #365	; 0x16d
	for(i=SYSTEM_STARTING_YEAR;i<date.year;i++)
   37222:	3301      	adds	r3, #1
   37224:	e7e1      	b.n	371ea <GetWeekDayByDate+0x18>
		count += 31;
   37226:	321f      	adds	r2, #31
	count = count%7;
   37228:	2307      	movs	r3, #7
	count += (date.day-1);
   3722a:	f89d 0003 	ldrb.w	r0, [sp, #3]
   3722e:	3801      	subs	r0, #1
   37230:	4402      	add	r2, r0
	count = count%7;
   37232:	fbb2 f0f3 	udiv	r0, r2, r3
   37236:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
   3723a:	1a12      	subs	r2, r2, r0
	index = (index+count)%7;
   3723c:	1d10      	adds	r0, r2, #4
   3723e:	fbb0 f3f3 	udiv	r3, r0, r3
   37242:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   37246:	1ac0      	subs	r0, r0, r3
   37248:	b2c0      	uxtb	r0, r0
}
   3724a:	b002      	add	sp, #8
   3724c:	4770      	bx	lr
		count += (31+(28+flag));
   3724e:	333b      	adds	r3, #59	; 0x3b
		count += (6*31+4*30+(28+flag));
   37250:	441a      	add	r2, r3
		break;			
   37252:	e7e9      	b.n	37228 <GetWeekDayByDate+0x56>
		count += (2*31+(28+flag));
   37254:	335a      	adds	r3, #90	; 0x5a
   37256:	e7fb      	b.n	37250 <GetWeekDayByDate+0x7e>
		count += (2*31+30+(28+flag));
   37258:	3378      	adds	r3, #120	; 0x78
   3725a:	e7f9      	b.n	37250 <GetWeekDayByDate+0x7e>
		count += (3*31+30+(28+flag));
   3725c:	3397      	adds	r3, #151	; 0x97
   3725e:	e7f7      	b.n	37250 <GetWeekDayByDate+0x7e>
		count += (3*31+2*30+(28+flag));
   37260:	33b5      	adds	r3, #181	; 0xb5
   37262:	e7f5      	b.n	37250 <GetWeekDayByDate+0x7e>
		count += (4*31+2*30+(28+flag));
   37264:	33d4      	adds	r3, #212	; 0xd4
   37266:	e7f3      	b.n	37250 <GetWeekDayByDate+0x7e>
		count += (5*31+2*30+(28+flag));
   37268:	33f3      	adds	r3, #243	; 0xf3
   3726a:	e7f1      	b.n	37250 <GetWeekDayByDate+0x7e>
		count += (5*31+3*30+(28+flag));
   3726c:	f203 1311 	addw	r3, r3, #273	; 0x111
   37270:	e7ee      	b.n	37250 <GetWeekDayByDate+0x7e>
		count += (6*31+3*30+(28+flag));
   37272:	f503 7398 	add.w	r3, r3, #304	; 0x130
   37276:	e7eb      	b.n	37250 <GetWeekDayByDate+0x7e>
		count += (6*31+4*30+(28+flag));
   37278:	f503 73a7 	add.w	r3, r3, #334	; 0x14e
   3727c:	e7e8      	b.n	37250 <GetWeekDayByDate+0x7e>
		return 0xff;
   3727e:	20ff      	movs	r0, #255	; 0xff
   37280:	e7e3      	b.n	3724a <GetWeekDayByDate+0x78>

00037282 <CheckSystemDateTimeIsValid>:
{
   37282:	b082      	sub	sp, #8
   37284:	ab02      	add	r3, sp, #8
   37286:	e903 0003 	stmdb	r3, {r0, r1}
	if((systime.year<SYSTEM_STARTING_YEAR || systime.year>9999)
   3728a:	f641 718f 	movw	r1, #8079	; 0x1f8f
   3728e:	f8bd 2000 	ldrh.w	r2, [sp]
   37292:	f5a2 63f0 	sub.w	r3, r2, #1920	; 0x780
   37296:	b29b      	uxth	r3, r3
   37298:	428b      	cmp	r3, r1
   3729a:	d816      	bhi.n	372ca <CheckSystemDateTimeIsValid+0x48>
   3729c:	f89d 3002 	ldrb.w	r3, [sp, #2]
		|| ((systime.month==0)||(systime.month>12)) 
   372a0:	1e59      	subs	r1, r3, #1
   372a2:	290b      	cmp	r1, #11
   372a4:	d811      	bhi.n	372ca <CheckSystemDateTimeIsValid+0x48>
   372a6:	f89d 0003 	ldrb.w	r0, [sp, #3]
		|| (systime.day==0) 
   372aa:	b338      	cbz	r0, 372fc <CheckSystemDateTimeIsValid+0x7a>
		|| ((systime.day>31)&&((systime.month==1)||(systime.month==3)||(systime.month==5)||(systime.month==7)||(systime.month==8)||(systime.month==10)||(systime.month==12)))
   372ac:	281f      	cmp	r0, #31
   372ae:	d90e      	bls.n	372ce <CheckSystemDateTimeIsValid+0x4c>
   372b0:	f241 50aa 	movw	r0, #5546	; 0x15aa
   372b4:	40d8      	lsrs	r0, r3
   372b6:	43c0      	mvns	r0, r0
   372b8:	f010 0001 	ands.w	r0, r0, #1
   372bc:	d01e      	beq.n	372fc <CheckSystemDateTimeIsValid+0x7a>
		|| ((systime.day>30)&&((systime.month==4)||(systime.month==6)||(systime.month==9)||(systime.month==11)))
   372be:	f003 02fd 	and.w	r2, r3, #253	; 0xfd
   372c2:	2a04      	cmp	r2, #4
   372c4:	d001      	beq.n	372ca <CheckSystemDateTimeIsValid+0x48>
   372c6:	2a09      	cmp	r2, #9
   372c8:	d104      	bne.n	372d4 <CheckSystemDateTimeIsValid+0x52>
		ret = false;
   372ca:	2000      	movs	r0, #0
   372cc:	e016      	b.n	372fc <CheckSystemDateTimeIsValid+0x7a>
		|| ((systime.day>30)&&((systime.month==4)||(systime.month==6)||(systime.month==9)||(systime.month==11)))
   372ce:	d0f6      	beq.n	372be <CheckSystemDateTimeIsValid+0x3c>
		|| ((systime.day>29)&&((systime.month==2)&&(systime.year%4==0)))
   372d0:	281e      	cmp	r0, #30
   372d2:	d115      	bne.n	37300 <CheckSystemDateTimeIsValid+0x7e>
   372d4:	2b02      	cmp	r3, #2
   372d6:	d0f8      	beq.n	372ca <CheckSystemDateTimeIsValid+0x48>
		|| ((systime.hour>23)||(systime.minute>59)||(systime.second>59))
   372d8:	f89d 3004 	ldrb.w	r3, [sp, #4]
   372dc:	2b17      	cmp	r3, #23
   372de:	d8f4      	bhi.n	372ca <CheckSystemDateTimeIsValid+0x48>
   372e0:	f89d 3005 	ldrb.w	r3, [sp, #5]
   372e4:	2b3b      	cmp	r3, #59	; 0x3b
   372e6:	d8f0      	bhi.n	372ca <CheckSystemDateTimeIsValid+0x48>
   372e8:	f89d 3006 	ldrb.w	r3, [sp, #6]
   372ec:	2b3b      	cmp	r3, #59	; 0x3b
   372ee:	d8ec      	bhi.n	372ca <CheckSystemDateTimeIsValid+0x48>
		|| (systime.week>6))
   372f0:	f89d 0007 	ldrb.w	r0, [sp, #7]
   372f4:	2806      	cmp	r0, #6
   372f6:	bf8c      	ite	hi
   372f8:	2000      	movhi	r0, #0
   372fa:	2001      	movls	r0, #1
}
   372fc:	b002      	add	sp, #8
   372fe:	4770      	bx	lr
		|| ((systime.day>28)&&((systime.month==2)&&(systime.year%4!=0)))
   37300:	281d      	cmp	r0, #29
   37302:	d1e9      	bne.n	372d8 <CheckSystemDateTimeIsValid+0x56>
   37304:	2b02      	cmp	r3, #2
   37306:	d1e7      	bne.n	372d8 <CheckSystemDateTimeIsValid+0x56>
   37308:	0793      	lsls	r3, r2, #30
   3730a:	d1de      	bne.n	372ca <CheckSystemDateTimeIsValid+0x48>
   3730c:	e7e4      	b.n	372d8 <CheckSystemDateTimeIsValid+0x56>

0003730e <AlarmRemindEntryScreen>:
{
   3730e:	b508      	push	{r3, lr}
	EnterAlarmScreen();
   37310:	f7eb f900 	bl	22514 <EnterAlarmScreen>
}
   37314:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	AlarmRemindStart();
   37318:	f7e7 bab2 	b.w	1e880 <AlarmRemindStart>

0003731c <FindDeviceEntryScreen>:
{
   3731c:	b508      	push	{r3, lr}
	EnterFindDeviceScreen();
   3731e:	f7eb f90f 	bl	22540 <EnterFindDeviceScreen>
}
   37322:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	FindDeviceStart();
   37326:	f7e7 bb43 	b.w	1e9b0 <FindDeviceStart>

0003732a <LCD_get_pic_size_from_flash>:
	u8_t databuf[8] = {0};
   3732a:	2300      	movs	r3, #0
{
   3732c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   3732e:	460d      	mov	r5, r1
   37330:	4614      	mov	r4, r2
	SpiFlash_Read(databuf, pic_addr, 8);
   37332:	4601      	mov	r1, r0
   37334:	2208      	movs	r2, #8
   37336:	4668      	mov	r0, sp
	u8_t databuf[8] = {0};
   37338:	e9cd 3300 	strd	r3, r3, [sp]
	SpiFlash_Read(databuf, pic_addr, 8);
   3733c:	f7e8 fc32 	bl	1fba4 <SpiFlash_Read>
	*width = 256*databuf[2]+databuf[3]; 			//
   37340:	f89d 2002 	ldrb.w	r2, [sp, #2]
   37344:	f89d 3003 	ldrb.w	r3, [sp, #3]
   37348:	eb03 2302 	add.w	r3, r3, r2, lsl #8
   3734c:	802b      	strh	r3, [r5, #0]
	*height = 256*databuf[4]+databuf[5];			//
   3734e:	f89d 2004 	ldrb.w	r2, [sp, #4]
   37352:	f89d 3005 	ldrb.w	r3, [sp, #5]
   37356:	eb03 2302 	add.w	r3, r3, r2, lsl #8
   3735a:	8023      	strh	r3, [r4, #0]
}
   3735c:	b003      	add	sp, #12
   3735e:	bd30      	pop	{r4, r5, pc}

00037360 <k_sleep>:
	return z_impl_k_sleep(ms);
   37360:	f7fd b932 	b.w	345c8 <z_impl_k_sleep>

00037364 <gpio_pin_write>:
{
   37364:	b410      	push	{r4}
   37366:	4613      	mov	r3, r2
	return api->write(port, access_op, pin, value);
   37368:	6842      	ldr	r2, [r0, #4]
   3736a:	6854      	ldr	r4, [r2, #4]
   3736c:	460a      	mov	r2, r1
   3736e:	46a4      	mov	ip, r4
   37370:	2100      	movs	r1, #0
}
   37372:	f85d 4b04 	ldr.w	r4, [sp], #4
	return api->write(port, access_op, pin, value);
   37376:	4760      	bx	ip

00037378 <gpio_pin_configure.constprop.2>:
static inline int gpio_pin_configure(struct device *port, u32_t pin,
   37378:	b410      	push	{r4}
   3737a:	460a      	mov	r2, r1
	return api->config(port, access_op, pin, flags);
   3737c:	6843      	ldr	r3, [r0, #4]
   3737e:	2100      	movs	r1, #0
   37380:	681c      	ldr	r4, [r3, #0]
   37382:	2301      	movs	r3, #1
   37384:	46a4      	mov	ip, r4
}
   37386:	f85d 4b04 	ldr.w	r4, [sp], #4
	return api->config(port, access_op, pin, flags);
   3738a:	4760      	bx	ip

0003738c <BlockWrite>:
{
   3738c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   37390:	4605      	mov	r5, r0
   37392:	4690      	mov	r8, r2
   37394:	460c      	mov	r4, r1
   37396:	461e      	mov	r6, r3
	WriteComm(0x2A);             
   37398:	202a      	movs	r0, #42	; 0x2a
	WriteData(x);             
   3739a:	b2ef      	uxtb	r7, r5
	WriteComm(0x2A);             
   3739c:	f7e7 fdae 	bl	1eefc <WriteComm>
	WriteData(x>>8);             
   373a0:	f3c5 2007 	ubfx	r0, r5, #8, #8
   373a4:	f7e7 fdba 	bl	1ef1c <WriteData>
	WriteData((x+w-1)>>8);             
   373a8:	f108 38ff 	add.w	r8, r8, #4294967295
	WriteData(x);             
   373ac:	4638      	mov	r0, r7
   373ae:	f7e7 fdb5 	bl	1ef1c <WriteData>
	WriteData((x+w-1)>>8);             
   373b2:	eb08 0005 	add.w	r0, r8, r5
   373b6:	f3c0 2007 	ubfx	r0, r0, #8, #8
   373ba:	f7e7 fdaf 	bl	1ef1c <WriteData>
	WriteData((x+w-1));             
   373be:	eb07 0008 	add.w	r0, r7, r8
   373c2:	b2c0      	uxtb	r0, r0
   373c4:	f7e7 fdaa 	bl	1ef1c <WriteData>
	WriteComm(0x2B);             
   373c8:	202b      	movs	r0, #43	; 0x2b
   373ca:	f7e7 fd97 	bl	1eefc <WriteComm>
	WriteData(y);             
   373ce:	b2e5      	uxtb	r5, r4
	WriteData(y>>8);             
   373d0:	f3c4 2007 	ubfx	r0, r4, #8, #8
   373d4:	f7e7 fda2 	bl	1ef1c <WriteData>
	WriteData((y+h-1)>>8);//	WriteData((Yend+1)>>8);             
   373d8:	3e01      	subs	r6, #1
	WriteData(y);             
   373da:	4628      	mov	r0, r5
   373dc:	f7e7 fd9e 	bl	1ef1c <WriteData>
	WriteData((y+h-1)>>8);//	WriteData((Yend+1)>>8);             
   373e0:	1930      	adds	r0, r6, r4
   373e2:	f3c0 2007 	ubfx	r0, r0, #8, #8
   373e6:	f7e7 fd99 	bl	1ef1c <WriteData>
	WriteData((y+h-1));//	WriteData(Yend+1);   	
   373ea:	19a8      	adds	r0, r5, r6
   373ec:	b2c0      	uxtb	r0, r0
   373ee:	f7e7 fd95 	bl	1ef1c <WriteData>
}
   373f2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	WriteComm(0x2c);
   373f6:	202c      	movs	r0, #44	; 0x2c
   373f8:	f7e7 bd80 	b.w	1eefc <WriteComm>

000373fc <LCD_Clear>:
	BlockWrite(0,0,COL,ROW);//
   373fc:	2100      	movs	r1, #0
{
   373fe:	b510      	push	{r4, lr}
   37400:	4604      	mov	r4, r0
	BlockWrite(0,0,COL,ROW);//
   37402:	23d2      	movs	r3, #210	; 0xd2
   37404:	4608      	mov	r0, r1
   37406:	22f0      	movs	r2, #240	; 0xf0
   37408:	f7ff ffc0 	bl	3738c <BlockWrite>
	DispColor(COL*ROW, color);
   3740c:	4621      	mov	r1, r4
} 
   3740e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	DispColor(COL*ROW, color);
   37412:	f24c 40e0 	movw	r0, #50400	; 0xc4e0
   37416:	f7e7 bd91 	b.w	1ef3c <DispColor>

0003741a <uart_fifo_fill>:
	if (api->fifo_fill) {
   3741a:	6843      	ldr	r3, [r0, #4]
   3741c:	695b      	ldr	r3, [r3, #20]
   3741e:	b103      	cbz	r3, 37422 <uart_fifo_fill+0x8>
		return api->fifo_fill(dev, tx_data, size);
   37420:	4718      	bx	r3
}
   37422:	4618      	mov	r0, r3
   37424:	4770      	bx	lr

00037426 <z_impl_uart_irq_tx_enable>:
	if (api->irq_tx_enable) {
   37426:	6843      	ldr	r3, [r0, #4]
   37428:	69db      	ldr	r3, [r3, #28]
   3742a:	b103      	cbz	r3, 3742e <z_impl_uart_irq_tx_enable+0x8>
		api->irq_tx_enable(dev);
   3742c:	4718      	bx	r3
}
   3742e:	4770      	bx	lr

00037430 <uart_irq_tx_disable>:
	if (api->irq_tx_disable) {
   37430:	6843      	ldr	r3, [r0, #4]
   37432:	6a1b      	ldr	r3, [r3, #32]
   37434:	b103      	cbz	r3, 37438 <uart_irq_tx_disable+0x8>
		api->irq_tx_disable(dev);
   37436:	4718      	bx	r3
}
   37438:	4770      	bx	lr

0003743a <APP_get_location_data_reply>:
{
   3743a:	b510      	push	{r4, lr}
   3743c:	b0a0      	sub	sp, #128	; 0x80
   3743e:	4604      	mov	r4, r0
	u8_t reply[128] = {0};
   37440:	2100      	movs	r1, #0
   37442:	2280      	movs	r2, #128	; 0x80
   37444:	4668      	mov	r0, sp
   37446:	f002 fcba 	bl	39dbe <memset>
	reply[reply_len++] = PACKET_HEAD;
   3744a:	23ab      	movs	r3, #171	; 0xab
   3744c:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x17;
   37450:	f64f 7317 	movw	r3, #65303	; 0xff17
   37454:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(LOCATION_ID&0x00ff);
   37458:	f248 0355 	movw	r3, #32853	; 0x8055
   3745c:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = buf[0];//h-byte year
   37460:	7823      	ldrb	r3, [r4, #0]
   37462:	4669      	mov	r1, sp
   37464:	f88d 3007 	strb.w	r3, [sp, #7]
	reply[reply_len++] = buf[1];//l-byte year
   37468:	7863      	ldrb	r3, [r4, #1]
   3746a:	f88d 3008 	strb.w	r3, [sp, #8]
	reply[reply_len++] = buf[2];//month
   3746e:	78a3      	ldrb	r3, [r4, #2]
   37470:	f88d 3009 	strb.w	r3, [sp, #9]
	reply[reply_len++] = buf[3];//day
   37474:	78e3      	ldrb	r3, [r4, #3]
   37476:	f88d 300a 	strb.w	r3, [sp, #10]
	reply[reply_len++] = buf[4];//hour
   3747a:	7923      	ldrb	r3, [r4, #4]
   3747c:	f88d 300b 	strb.w	r3, [sp, #11]
	reply[reply_len++] = buf[5];//minute
   37480:	7963      	ldrb	r3, [r4, #5]
   37482:	f88d 300c 	strb.w	r3, [sp, #12]
	reply[reply_len++] = buf[6];//seconds
   37486:	79a3      	ldrb	r3, [r4, #6]
   37488:	f88d 300d 	strb.w	r3, [sp, #13]
	reply[reply_len++] = buf[7];//direction	E\W
   3748c:	79e3      	ldrb	r3, [r4, #7]
   3748e:	f88d 300e 	strb.w	r3, [sp, #14]
	reply[reply_len++] = buf[8];//degree int
   37492:	7a23      	ldrb	r3, [r4, #8]
   37494:	f88d 300f 	strb.w	r3, [sp, #15]
	reply[reply_len++] = buf[9];//degree dot1~2
   37498:	7a63      	ldrb	r3, [r4, #9]
   3749a:	f88d 3010 	strb.w	r3, [sp, #16]
	reply[reply_len++] = buf[10];//degree dot3~4
   3749e:	7aa3      	ldrb	r3, [r4, #10]
   374a0:	f88d 3011 	strb.w	r3, [sp, #17]
	reply[reply_len++] = buf[11];//degree dot5~6
   374a4:	7ae3      	ldrb	r3, [r4, #11]
   374a6:	f88d 3012 	strb.w	r3, [sp, #18]
	reply[reply_len++] = buf[12];//direction	N\S
   374aa:	7b23      	ldrb	r3, [r4, #12]
   374ac:	f88d 3013 	strb.w	r3, [sp, #19]
	reply[reply_len++] = buf[13];//degree int
   374b0:	7b63      	ldrb	r3, [r4, #13]
   374b2:	f88d 3014 	strb.w	r3, [sp, #20]
	reply[reply_len++] = buf[14];//degree dot1~2
   374b6:	7ba3      	ldrb	r3, [r4, #14]
   374b8:	f88d 3015 	strb.w	r3, [sp, #21]
	reply[reply_len++] = buf[15];//degree dot3~4
   374bc:	7be3      	ldrb	r3, [r4, #15]
   374be:	f88d 3016 	strb.w	r3, [sp, #22]
	reply[reply_len++] = buf[16];//degree dot5~6
   374c2:	7c23      	ldrb	r3, [r4, #16]
   374c4:	f88d 3017 	strb.w	r3, [sp, #23]
	reply[reply_len++] = PACKET_END;
   374c8:	2388      	movs	r3, #136	; 0x88
   374ca:	f88d 3019 	strb.w	r3, [sp, #25]
	for(i=0;i<(reply_len-2);i++)
   374ce:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   374d0:	f811 2b01 	ldrb.w	r2, [r1], #1
   374d4:	f89d 0018 	ldrb.w	r0, [sp, #24]
	for(i=0;i<(reply_len-2);i++)
   374d8:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   374da:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   374dc:	2b18      	cmp	r3, #24
		reply[reply_len-2] += reply[i];
   374de:	f88d 2018 	strb.w	r2, [sp, #24]
	for(i=0;i<(reply_len-2);i++)
   374e2:	d1f5      	bne.n	374d0 <APP_get_location_data_reply+0x96>
	ble_send_date_handle(reply, reply_len);
   374e4:	211a      	movs	r1, #26
   374e6:	4668      	mov	r0, sp
   374e8:	f7e8 fd7e 	bl	1ffe8 <ble_send_date_handle>
}
   374ec:	b020      	add	sp, #128	; 0x80
   374ee:	bd10      	pop	{r4, pc}

000374f0 <APP_get_firmware_version>:
{
   374f0:	b500      	push	{lr}
   374f2:	b0a1      	sub	sp, #132	; 0x84
	u8_t reply[128] = {0};
   374f4:	2100      	movs	r1, #0
   374f6:	2280      	movs	r2, #128	; 0x80
   374f8:	4668      	mov	r0, sp
   374fa:	f002 fc60 	bl	39dbe <memset>
	reply[reply_len++] = PACKET_HEAD;
   374fe:	23ab      	movs	r3, #171	; 0xab
   37500:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x07;
   37504:	f64f 7307 	movw	r3, #65287	; 0xff07
   37508:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(FIRMWARE_INFOR_ID&0x00ff);
   3750c:	f248 0352 	movw	r3, #32850	; 0x8052
   37510:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = (0x02<<4)+0x00;	//V2.0
   37514:	2320      	movs	r3, #32
   37516:	f88d 3007 	strb.w	r3, [sp, #7]
	reply[reply_len++] = PACKET_END;
   3751a:	2388      	movs	r3, #136	; 0x88
   3751c:	4669      	mov	r1, sp
   3751e:	f88d 3009 	strb.w	r3, [sp, #9]
	for(i=0;i<(reply_len-2);i++)
   37522:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   37524:	f811 2b01 	ldrb.w	r2, [r1], #1
   37528:	f89d 0008 	ldrb.w	r0, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   3752c:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   3752e:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   37530:	2b08      	cmp	r3, #8
		reply[reply_len-2] += reply[i];
   37532:	f88d 2008 	strb.w	r2, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   37536:	d1f5      	bne.n	37524 <APP_get_firmware_version+0x34>
	ble_send_date_handle(reply, reply_len);
   37538:	210a      	movs	r1, #10
   3753a:	4668      	mov	r0, sp
   3753c:	f7e8 fd54 	bl	1ffe8 <ble_send_date_handle>
}
   37540:	b021      	add	sp, #132	; 0x84
   37542:	f85d fb04 	ldr.w	pc, [sp], #4

00037546 <show_infor>:
{
   37546:	b513      	push	{r0, r1, r4, lr}
   37548:	4604      	mov	r4, r0
	LCD_Clear(BLACK);
   3754a:	2000      	movs	r0, #0
   3754c:	f7ff ff56 	bl	373fc <LCD_Clear>
	LCD_ShowStringInRect(20,90,200,50,strbuf);
   37550:	9400      	str	r4, [sp, #0]
   37552:	2332      	movs	r3, #50	; 0x32
   37554:	22c8      	movs	r2, #200	; 0xc8
   37556:	215a      	movs	r1, #90	; 0x5a
   37558:	2014      	movs	r0, #20
   3755a:	f7e7 fbe3 	bl	1ed24 <LCD_ShowStringInRect>
}
   3755e:	b002      	add	sp, #8
   37560:	bd10      	pop	{r4, pc}

00037562 <IdleShowDateTime>:
{
   37562:	b508      	push	{r3, lr}
	IdleShowSystemTime();
   37564:	f7ea fb5a 	bl	21c1c <IdleShowSystemTime>
	IdleShowSystemDate();
   37568:	f7ea fb14 	bl	21b94 <IdleShowSystemDate>
}
   3756c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	IdleShowSystemWeek();
   37570:	f7ea bb98 	b.w	21ca4 <IdleShowSystemWeek>

00037574 <NotifyTimerOutCallBack>:
	ExitNotifyScreen();
   37574:	f7eb b826 	b.w	225c4 <ExitNotifyScreen>

00037578 <gpio_add_callback>:
	if (api->manage_callback == NULL) {
   37578:	6843      	ldr	r3, [r0, #4]
   3757a:	68db      	ldr	r3, [r3, #12]
   3757c:	b10b      	cbz	r3, 37582 <gpio_add_callback+0xa>
	return api->manage_callback(port, callback, true);
   3757e:	2201      	movs	r2, #1
   37580:	4718      	bx	r3
}
   37582:	f06f 0085 	mvn.w	r0, #133	; 0x85
   37586:	4770      	bx	lr

00037588 <gpio_pin_disable_callback>:
 * @param port Pointer to the device structure for the driver instance.
 * @param pin Pin number where the callback function is disabled.
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_disable_callback(struct device *port, u32_t pin)
{
   37588:	460a      	mov	r2, r1
	if (api->disable_callback == NULL) {
   3758a:	6843      	ldr	r3, [r0, #4]
   3758c:	695b      	ldr	r3, [r3, #20]
   3758e:	b10b      	cbz	r3, 37594 <gpio_pin_disable_callback+0xc>
	return api->disable_callback(port, access_op, pin);
   37590:	2100      	movs	r1, #0
   37592:	4718      	bx	r3
	return gpio_disable_callback(port, GPIO_ACCESS_BY_PIN, pin);
}
   37594:	f06f 0085 	mvn.w	r0, #133	; 0x85
   37598:	4770      	bx	lr

0003759a <gpio_pin_enable_callback>:
{
   3759a:	460a      	mov	r2, r1
	if (api->enable_callback == NULL) {
   3759c:	6843      	ldr	r3, [r0, #4]
   3759e:	691b      	ldr	r3, [r3, #16]
   375a0:	b10b      	cbz	r3, 375a6 <gpio_pin_enable_callback+0xc>
	return api->enable_callback(port, access_op, pin);
   375a2:	2100      	movs	r1, #0
   375a4:	4718      	bx	r3
}
   375a6:	f06f 0085 	mvn.w	r0, #133	; 0x85
   375aa:	4770      	bx	lr

000375ac <platform_write>:
{
   375ac:	b5f0      	push	{r4, r5, r6, r7, lr}
   375ae:	b085      	sub	sp, #20
   375b0:	4604      	mov	r4, r0
	u8_t data[len+1];
   375b2:	4668      	mov	r0, sp
{
   375b4:	4616      	mov	r6, r2
	u8_t data[len+1];
   375b6:	f103 0208 	add.w	r2, r3, #8
   375ba:	08d2      	lsrs	r2, r2, #3
   375bc:	eba0 02c2 	sub.w	r2, r0, r2, lsl #3
{
   375c0:	af00      	add	r7, sp, #0
	u8_t data[len+1];
   375c2:	4695      	mov	sp, r2
	data[0] = reg;
   375c4:	4668      	mov	r0, sp
   375c6:	461a      	mov	r2, r3
   375c8:	f800 1b01 	strb.w	r1, [r0], #1
   375cc:	4631      	mov	r1, r6
	u8_t data[len+1];
   375ce:	1c5d      	adds	r5, r3, #1
   375d0:	f002 fbd5 	bl	39d7e <memcpy>
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   375d4:	2302      	movs	r3, #2
	msg.buf = (u8_t *)buf;
   375d6:	f8c7 d004 	str.w	sp, [r7, #4]
	msg.len = num_bytes;
   375da:	60bd      	str	r5, [r7, #8]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   375dc:	733b      	strb	r3, [r7, #12]
	return api->transfer(dev, msgs, num_msgs, addr);
   375de:	6863      	ldr	r3, [r4, #4]
   375e0:	1d39      	adds	r1, r7, #4
   375e2:	685d      	ldr	r5, [r3, #4]
   375e4:	2201      	movs	r2, #1
   375e6:	2328      	movs	r3, #40	; 0x28
   375e8:	4620      	mov	r0, r4
   375ea:	47a8      	blx	r5
}
   375ec:	3714      	adds	r7, #20
   375ee:	46bd      	mov	sp, r7
   375f0:	bdf0      	pop	{r4, r5, r6, r7, pc}

000375f2 <platform_read>:
{
   375f2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   375f6:	b086      	sub	sp, #24
   375f8:	461e      	mov	r6, r3
	msg.buf = (u8_t *)buf;
   375fa:	f10d 0307 	add.w	r3, sp, #7
   375fe:	9303      	str	r3, [sp, #12]
	msg.len = num_bytes;
   37600:	2501      	movs	r5, #1
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   37602:	2302      	movs	r3, #2
   37604:	4604      	mov	r4, r0
   37606:	4617      	mov	r7, r2
   37608:	f88d 1007 	strb.w	r1, [sp, #7]
	msg.len = num_bytes;
   3760c:	9504      	str	r5, [sp, #16]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   3760e:	f88d 3014 	strb.w	r3, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   37612:	6843      	ldr	r3, [r0, #4]
   37614:	462a      	mov	r2, r5
   37616:	f8d3 8004 	ldr.w	r8, [r3, #4]
   3761a:	a903      	add	r1, sp, #12
   3761c:	2328      	movs	r3, #40	; 0x28
   3761e:	47c0      	blx	r8
	if(rslt == 0)
   37620:	b958      	cbnz	r0, 3763a <platform_read+0x48>
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
   37622:	2303      	movs	r3, #3
		rslt = i2c_read(handle, bufp, len, MAX20353_I2C_ADDR);
   37624:	e9cd 7603 	strd	r7, r6, [sp, #12]
   37628:	f88d 3014 	strb.w	r3, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   3762c:	6863      	ldr	r3, [r4, #4]
   3762e:	462a      	mov	r2, r5
   37630:	685e      	ldr	r6, [r3, #4]
   37632:	a903      	add	r1, sp, #12
   37634:	2328      	movs	r3, #40	; 0x28
   37636:	4620      	mov	r0, r4
   37638:	47b0      	blx	r6
}
   3763a:	b006      	add	sp, #24
   3763c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00037640 <Set_Screen_Backlight_On>:
	ret = MAX20353_LED1(2, 31, true);
   37640:	2201      	movs	r2, #1
   37642:	211f      	movs	r1, #31
   37644:	2002      	movs	r0, #2
   37646:	f000 b81d 	b.w	37684 <MAX20353_LED1>

0003764a <Set_Screen_Backlight_Off>:
	ret = MAX20353_LED1(2, 0, false);
   3764a:	2200      	movs	r2, #0
   3764c:	2002      	movs	r0, #2
   3764e:	4611      	mov	r1, r2
   37650:	f000 b818 	b.w	37684 <MAX20353_LED1>

00037654 <SystemShutDown>:
{
   37654:	b508      	push	{r3, lr}
	SaveSystemDateTime();
   37656:	f7e8 f97b 	bl	1f950 <SaveSystemDateTime>
}
   3765a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	MAX20353_PowerOffConfig();
   3765e:	f7eb bd47 	b.w	230f0 <MAX20353_PowerOffConfig>

00037662 <k_sleep>:
   37662:	f7fc bfb1 	b.w	345c8 <z_impl_k_sleep>

00037666 <VibrateStart>:
{
   37666:	b508      	push	{r3, lr}
	MAX20353_WriteReg( REG_HPT_RTI2CAMP,  0x3f);	//0x000x7f
   37668:	213f      	movs	r1, #63	; 0x3f
   3766a:	2032      	movs	r0, #50	; 0x32
   3766c:	f7eb fc2c 	bl	22ec8 <MAX20353_WriteReg>
}
   37670:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	MAX20353_WriteReg( REG_HPT_DIRECT1,  0x26); //hptExtTrig=1, HptRamEn=1, HptDrvEn=1, HptDrvMode=0x06
   37674:	2126      	movs	r1, #38	; 0x26
   37676:	2031      	movs	r0, #49	; 0x31
   37678:	f7eb bc26 	b.w	22ec8 <MAX20353_WriteReg>

0003767c <VibrateStop>:
	MAX20353_WriteReg( REG_HPT_DIRECT1,  0x00); //hptExtTrig=1, HptRamEn=1, HptDrvEn=1, HptDrvMode=0x12
   3767c:	2100      	movs	r1, #0
   3767e:	2031      	movs	r0, #49	; 0x31
   37680:	f7eb bc22 	b.w	22ec8 <MAX20353_WriteReg>

00037684 <MAX20353_LED1>:
{ 
   37684:	b538      	push	{r3, r4, r5, lr}
   37686:	4615      	mov	r5, r2
   37688:	460c      	mov	r4, r1
	ret |= MAX20353_WriteReg(REG_LED_STEP_DIRECT,  IStep&0x03);
   3768a:	f000 0103 	and.w	r1, r0, #3
   3768e:	202c      	movs	r0, #44	; 0x2c
   37690:	f7eb fc1a 	bl	22ec8 <MAX20353_WriteReg>
	if(flag)
   37694:	b145      	cbz	r5, 376a8 <MAX20353_LED1+0x24>
		ret |= MAX20353_WriteReg(REG_LED1_DIRECT,  0x20|(Amplitude&0x1F)); 
   37696:	f004 011f 	and.w	r1, r4, #31
   3769a:	f041 0120 	orr.w	r1, r1, #32
		ret |= MAX20353_WriteReg(REG_LED1_DIRECT,  0x00); 
   3769e:	202e      	movs	r0, #46	; 0x2e
}
   376a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		ret |= MAX20353_WriteReg(REG_LED1_DIRECT,  0x00); 
   376a4:	f7eb bc10 	b.w	22ec8 <MAX20353_WriteReg>
   376a8:	4629      	mov	r1, r5
   376aa:	e7f8      	b.n	3769e <MAX20353_LED1+0x1a>

000376ac <MAX20353_EnablePMICIntMaskRegisters>:
{
   376ac:	b538      	push	{r3, r4, r5, lr}
   376ae:	4605      	mov	r5, r0
	ret  = MAX20353_WriteReg(REG_INT_MASK0, buf_results[0]);
   376b0:	7801      	ldrb	r1, [r0, #0]
   376b2:	200c      	movs	r0, #12
   376b4:	f7eb fc08 	bl	22ec8 <MAX20353_WriteReg>
	ret |= MAX20353_WriteReg(REG_INT_MASK1, buf_results[1]);
   376b8:	7869      	ldrb	r1, [r5, #1]
	ret  = MAX20353_WriteReg(REG_INT_MASK0, buf_results[0]);
   376ba:	4604      	mov	r4, r0
	ret |= MAX20353_WriteReg(REG_INT_MASK1, buf_results[1]);
   376bc:	200d      	movs	r0, #13
   376be:	f7eb fc03 	bl	22ec8 <MAX20353_WriteReg>
	ret |= MAX20353_WriteReg(REG_INT_MASK2, buf_results[2]);
   376c2:	78a9      	ldrb	r1, [r5, #2]
	ret |= MAX20353_WriteReg(REG_INT_MASK1, buf_results[1]);
   376c4:	4304      	orrs	r4, r0
	ret |= MAX20353_WriteReg(REG_INT_MASK2, buf_results[2]);
   376c6:	200e      	movs	r0, #14
   376c8:	f7eb fbfe 	bl	22ec8 <MAX20353_WriteReg>
}
   376cc:	4320      	orrs	r0, r4
   376ce:	bd38      	pop	{r3, r4, r5, pc}

000376d0 <MAX20353_GetDeviceID>:
	MAX20353_ReadReg(REG_HARDWARE_ID, Device_ID);
   376d0:	4601      	mov	r1, r0
   376d2:	2000      	movs	r0, #0
   376d4:	f7eb bc0c 	b.w	22ef0 <MAX20353_ReadReg>

000376d8 <MAX20353_QuickStart>:
	WriteWord(0x06, 0x40, 0x00);
   376d8:	2200      	movs	r2, #0
   376da:	2140      	movs	r1, #64	; 0x40
   376dc:	2006      	movs	r0, #6
   376de:	f7eb bdd5 	b.w	2328c <WriteWord>

000376e2 <handle_model>:
handle_model(LOAD_MODEL);
If you want to verify the model, and correct errors, call:
handle_model(VERIFY_AND_FIX);
*/
void handle_model(int load_or_verify)
{
   376e2:	b538      	push	{r3, r4, r5, lr}
   376e4:	4605      	mov	r5, r0
   376e6:	2403      	movs	r4, #3
	u8_t retry = 3;
	
	do
	{
		// Steps 1-4
		prepare_to_load_model();
   376e8:	f7eb fe90 	bl	2340c <prepare_to_load_model>
		if(load_or_verify == LOAD_MODEL)
   376ec:	b90d      	cbnz	r5, 376f2 <handle_model+0x10>
		{
			//Step 5
			load_model();
   376ee:	f7eb fea5 	bl	2343c <load_model>
		}
		
		//Steps 6-9
		model_load_ok = verify_model_is_correct();
   376f2:	f7eb fec7 	bl	23484 <verify_model_is_correct>
		if(!model_load_ok)
   376f6:	b118      	cbz	r0, 37700 <handle_model+0x1e>
		retry--;
	}while((!model_load_ok)&&(retry>0));
	
	// Steps 10-11
	cleanup_model_load();
}
   376f8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	cleanup_model_load();
   376fc:	f7eb bee8 	b.w	234d0 <cleanup_model_load>
		retry--;
   37700:	3c01      	subs	r4, #1
	}while((!model_load_ok)&&(retry>0));
   37702:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
			load_or_verify = LOAD_MODEL;
   37706:	4605      	mov	r5, r0
	}while((!model_load_ok)&&(retry>0));
   37708:	d1ee      	bne.n	376e8 <handle_model+0x6>
   3770a:	e7f5      	b.n	376f8 <handle_model+0x16>

0003770c <MAX20353_SOCReadReg>:
   3770c:	f7eb bd86 	b.w	2321c <ReadWord>

00037710 <MAX20353_SOCWriteReg>:
   37710:	f7eb bdbc 	b.w	2328c <WriteWord>

00037714 <MAX20353_SOCInit>:
		return MAX20353_ERROR;
	return MAX20353_NO_ERROR;
}

void MAX20353_SOCInit(void)
{
   37714:	b507      	push	{r0, r1, r2, lr}
	u8_t MSB,LSB;

	MAX20353_SOCReadReg(0x1A, &MSB, &LSB);
   37716:	201a      	movs	r0, #26
   37718:	f10d 0106 	add.w	r1, sp, #6
   3771c:	f10d 0207 	add.w	r2, sp, #7
   37720:	f7eb fd7c 	bl	2321c <ReadWord>
	if(MSB&0x01)
   37724:	f89d 1006 	ldrb.w	r1, [sp, #6]
   37728:	07cb      	lsls	r3, r1, #31
   3772a:	d510      	bpl.n	3774e <MAX20353_SOCInit+0x3a>
	{
		//RI (reset indicator) is set when the device powers up.
		//Any time this bit is set, the IC is not configured, so the
		//model should be loaded and the bit should be cleared
		MSB = MSB&0xFE;
   3772c:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
		MAX20353_SOCWriteReg(0x1A, MSB, LSB);
   37730:	f89d 2007 	ldrb.w	r2, [sp, #7]
   37734:	201a      	movs	r0, #26
		MSB = MSB&0xFE;
   37736:	f88d 1006 	strb.w	r1, [sp, #6]
		MAX20353_SOCWriteReg(0x1A, MSB, LSB);
   3773a:	f7eb fda7 	bl	2328c <WriteWord>
		MAX20353_QuickStart();
   3773e:	f7ff ffcb 	bl	376d8 <MAX20353_QuickStart>
    k_sleep(K_MSEC(period));
   37742:	2096      	movs	r0, #150	; 0x96
   37744:	f7ff ff8d 	bl	37662 <k_sleep>
		delay_ms(150);
		
		handle_model(LOAD_MODEL);
   37748:	2000      	movs	r0, #0
   3774a:	f7ff ffca 	bl	376e2 <handle_model>
	}
	
	//25SOC1%4%
	WriteWord(0x0C, 0x12, 0x5C);
   3774e:	225c      	movs	r2, #92	; 0x5c
   37750:	2112      	movs	r1, #18
   37752:	200c      	movs	r0, #12
   37754:	f7eb fd9a 	bl	2328c <WriteWord>

#ifdef BATTERT_NTC_CHECK
	MAX20353_StartCheckTemper();
   37758:	f7eb fe36 	bl	233c8 <MAX20353_StartCheckTemper>
#endif
}
   3775c:	b003      	add	sp, #12
   3775e:	f85d fb04 	ldr.w	pc, [sp], #4

00037762 <GetHeartRate>:
	gpio_pin_write(gpio_ppg, 17, 0);
	return 0;
}

void GetHeartRate(u8_t *HR)
{
   37762:	b538      	push	{r3, r4, r5, lr}
   37764:	4605      	mov	r5, r0
	u32_t heart;

	while(1)
	{
		heart = sys_rand32_get();
		if(((heart%200)>=60) && ((heart%200)<=160))
   37766:	24c8      	movs	r4, #200	; 0xc8
		heart = sys_rand32_get();
   37768:	f7ef f936 	bl	269d8 <sys_rand32_get>
		if(((heart%200)>=60) && ((heart%200)<=160))
   3776c:	fbb0 f3f4 	udiv	r3, r0, r4
   37770:	fb03 0014 	mls	r0, r3, r4, r0
   37774:	f1a0 033c 	sub.w	r3, r0, #60	; 0x3c
   37778:	2b64      	cmp	r3, #100	; 0x64
   3777a:	d8f5      	bhi.n	37768 <GetHeartRate+0x6>
		{
			*HR = (heart%200);
   3777c:	7028      	strb	r0, [r5, #0]
			break;
		}
	}
}
   3777e:	bd38      	pop	{r3, r4, r5, pc}

00037780 <mmi_chset_init>:
	}
#endif /* __MMI_CHSET_WESTERN_WIN__ */ 


    g_chset_tbl_is_init = true;
}
   37780:	4770      	bx	lr

00037782 <get_bit_ptr>:
{
   37782:	b570      	push	{r4, r5, r6, lr}
   37784:	250c      	movs	r5, #12
   37786:	68c6      	ldr	r6, [r0, #12]
	u32_t *bitarray = level <= p->max_inline_level ?
   37788:	f990 000b 	ldrsb.w	r0, [r0, #11]
   3778c:	434d      	muls	r5, r1
		p->levels[level].bits : p->levels[level].bits_p;
   3778e:	4288      	cmp	r0, r1
	*word = &bitarray[bn / 32];
   37790:	4610      	mov	r0, r2
   37792:	eb06 0405 	add.w	r4, r6, r5
		p->levels[level].bits : p->levels[level].bits_p;
   37796:	bfb8      	it	lt
   37798:	5974      	ldrlt	r4, [r6, r5]
	*word = &bitarray[bn / 32];
   3779a:	2a00      	cmp	r2, #0
   3779c:	bfb8      	it	lt
   3779e:	f102 001f 	addlt.w	r0, r2, #31
   377a2:	1140      	asrs	r0, r0, #5
   377a4:	eb04 0180 	add.w	r1, r4, r0, lsl #2
   377a8:	6019      	str	r1, [r3, #0]
}
   377aa:	f002 001f 	and.w	r0, r2, #31
   377ae:	bd70      	pop	{r4, r5, r6, pc}

000377b0 <pool_irq_lock.isra.2.part.3>:
	__asm__ volatile(
   377b0:	f04f 0320 	mov.w	r3, #32
   377b4:	f3ef 8011 	mrs	r0, BASEPRI
   377b8:	f383 8811 	msr	BASEPRI, r3
   377bc:	f3bf 8f6f 	isb	sy
}
   377c0:	4770      	bx	lr

000377c2 <pool_irq_unlock.isra.4>:
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   377c2:	07c3      	lsls	r3, r0, #31
   377c4:	d503      	bpl.n	377ce <pool_irq_unlock.isra.4+0xc>
	__asm__ volatile(
   377c6:	f381 8811 	msr	BASEPRI, r1
   377ca:	f3bf 8f6f 	isb	sy
}
   377ce:	4770      	bx	lr

000377d0 <z_sys_mem_pool_base_init>:
	p->max_inline_level = -1;
   377d0:	23ff      	movs	r3, #255	; 0xff
{
   377d2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   377d6:	6846      	ldr	r6, [r0, #4]
	p->max_inline_level = -1;
   377d8:	72c3      	strb	r3, [r0, #11]
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   377da:	4632      	mov	r2, r6
	for (i = 0; i < p->n_levels; i++) {
   377dc:	2300      	movs	r3, #0
		sys_dlist_init(&p->levels[i].free_list);
   377de:	f04f 090c 	mov.w	r9, #12
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   377e2:	8907      	ldrh	r7, [r0, #8]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   377e4:	6801      	ldr	r1, [r0, #0]
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   377e6:	fb06 fc07 	mul.w	ip, r6, r7
	for (i = 0; i < p->n_levels; i++) {
   377ea:	f890 800a 	ldrb.w	r8, [r0, #10]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   377ee:	4461      	add	r1, ip
	for (i = 0; i < p->n_levels; i++) {
   377f0:	4598      	cmp	r8, r3
   377f2:	dc05      	bgt.n	37800 <z_sys_mem_pool_base_init+0x30>
   377f4:	2300      	movs	r3, #0
	for (i = 0; i < p->n_max; i++) {
   377f6:	4619      	mov	r1, r3
   377f8:	428f      	cmp	r7, r1
   377fa:	dc20      	bgt.n	3783e <z_sys_mem_pool_base_init+0x6e>
}
   377fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		int nblocks = buflen / sz;
   37800:	fbbc f5f2 	udiv	r5, ip, r2
		sys_dlist_init(&p->levels[i].free_list);
   37804:	fb09 fe03 	mul.w	lr, r9, r3
   37808:	f8d0 a00c 	ldr.w	sl, [r0, #12]
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
   3780c:	2d20      	cmp	r5, #32
		sys_dlist_init(&p->levels[i].free_list);
   3780e:	eb0a 040e 	add.w	r4, sl, lr
   37812:	f104 0b04 	add.w	fp, r4, #4
	list->tail = (sys_dnode_t *)list;
   37816:	e9c4 bb01 	strd	fp, fp, [r4, #4]
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
   3781a:	d805      	bhi.n	37828 <z_sys_mem_pool_base_init+0x58>
			p->max_inline_level = i;
   3781c:	72c3      	strb	r3, [r0, #11]
		sz = WB_DN(sz / 4);
   3781e:	0892      	lsrs	r2, r2, #2
   37820:	f022 0203 	bic.w	r2, r2, #3
	for (i = 0; i < p->n_levels; i++) {
   37824:	3301      	adds	r3, #1
   37826:	e7e3      	b.n	377f0 <z_sys_mem_pool_base_init+0x20>
			bits += (nblocks + 31)/32;
   37828:	f115 041f 	adds.w	r4, r5, #31
   3782c:	bf48      	it	mi
   3782e:	f105 043e 	addmi.w	r4, r5, #62	; 0x3e
   37832:	1164      	asrs	r4, r4, #5
			p->levels[i].bits_p = bits;
   37834:	f84a 100e 	str.w	r1, [sl, lr]
			bits += (nblocks + 31)/32;
   37838:	eb01 0184 	add.w	r1, r1, r4, lsl #2
   3783c:	e7ef      	b.n	3781e <z_sys_mem_pool_base_init+0x4e>
		sys_dlist_append(&p->levels[0].free_list, block);
   3783e:	68c2      	ldr	r2, [r0, #12]
	return (u8_t *)p->buf + lsz * block;
   37840:	6805      	ldr	r5, [r0, #0]
		sys_dlist_append(&p->levels[0].free_list, block);
   37842:	f102 0c04 	add.w	ip, r2, #4
	return (u8_t *)p->buf + lsz * block;
   37846:	18ec      	adds	r4, r5, r3
	node->next = list;
   37848:	f845 c003 	str.w	ip, [r5, r3]
	node->prev = list->tail;
   3784c:	6895      	ldr	r5, [r2, #8]
	for (i = 0; i < p->n_max; i++) {
   3784e:	3101      	adds	r1, #1
   37850:	6065      	str	r5, [r4, #4]
	list->tail->next = node;
   37852:	6895      	ldr	r5, [r2, #8]
   37854:	4433      	add	r3, r6
   37856:	602c      	str	r4, [r5, #0]
	list->tail = node;
   37858:	6094      	str	r4, [r2, #8]
   3785a:	e7cd      	b.n	377f8 <z_sys_mem_pool_base_init+0x28>

0003785c <z_sys_mem_pool_block_alloc>:
{
   3785c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   37860:	b087      	sub	sp, #28
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   37862:	7a84      	ldrb	r4, [r0, #10]
{
   37864:	af00      	add	r7, sp, #0
   37866:	e9c7 3201 	strd	r3, r2, [r7, #4]
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   3786a:	00a3      	lsls	r3, r4, #2
   3786c:	3307      	adds	r3, #7
   3786e:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
   37872:	ebad 0d03 	sub.w	sp, sp, r3
   37876:	46ea      	mov	sl, sp
	lsizes[0] = p->max_sz;
   37878:	4653      	mov	r3, sl
   3787a:	6842      	ldr	r2, [r0, #4]
{
   3787c:	4605      	mov	r5, r0
	lsizes[0] = p->max_sz;
   3787e:	f843 2904 	str.w	r2, [r3], #-4
	for (i = 0; i < p->n_levels; i++) {
   37882:	2200      	movs	r2, #0
   37884:	4294      	cmp	r4, r2
   37886:	f102 39ff 	add.w	r9, r2, #4294967295
   3788a:	dd09      	ble.n	378a0 <z_sys_mem_pool_block_alloc+0x44>
		if (i > 0) {
   3788c:	b122      	cbz	r2, 37898 <z_sys_mem_pool_block_alloc+0x3c>
			lsizes[i] = WB_DN(lsizes[i-1] / 4);
   3788e:	6818      	ldr	r0, [r3, #0]
   37890:	0880      	lsrs	r0, r0, #2
   37892:	f020 0003 	bic.w	r0, r0, #3
   37896:	6058      	str	r0, [r3, #4]
		if (lsizes[i] < size) {
   37898:	f853 0f04 	ldr.w	r0, [r3, #4]!
   3789c:	4288      	cmp	r0, r1
   3789e:	d208      	bcs.n	378b2 <z_sys_mem_pool_block_alloc+0x56>
	if (alloc_l < 0) {
   378a0:	f1b9 3fff 	cmp.w	r9, #4294967295
   378a4:	d107      	bne.n	378b6 <z_sys_mem_pool_block_alloc+0x5a>
		*data_p = NULL;
   378a6:	2300      	movs	r3, #0
   378a8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   378aa:	6013      	str	r3, [r2, #0]
		return -ENOMEM;
   378ac:	f06f 000b 	mvn.w	r0, #11
   378b0:	e02c      	b.n	3790c <z_sys_mem_pool_block_alloc+0xb0>
	for (i = 0; i < p->n_levels; i++) {
   378b2:	3201      	adds	r2, #1
   378b4:	e7e6      	b.n	37884 <z_sys_mem_pool_block_alloc+0x28>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   378b6:	7c28      	ldrb	r0, [r5, #16]
   378b8:	f010 0001 	ands.w	r0, r0, #1
   378bc:	d001      	beq.n	378c2 <z_sys_mem_pool_block_alloc+0x66>
   378be:	f7ff ff77 	bl	377b0 <pool_irq_lock.isra.2.part.3>
   378c2:	230c      	movs	r3, #12
	key = pool_irq_lock(p);
   378c4:	4680      	mov	r8, r0
	block = sys_dlist_get(&p->levels[l].free_list);
   378c6:	464e      	mov	r6, r9
   378c8:	68ea      	ldr	r2, [r5, #12]
   378ca:	fb03 2309 	mla	r3, r3, r9, r2
	return list->head == list;
   378ce:	461a      	mov	r2, r3
   378d0:	f852 4f04 	ldr.w	r4, [r2, #4]!

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   378d4:	4294      	cmp	r4, r2
   378d6:	d11d      	bne.n	37914 <z_sys_mem_pool_block_alloc+0xb8>
	for (i = alloc_l; i >= 0; i--) {
   378d8:	3e01      	subs	r6, #1
   378da:	1c72      	adds	r2, r6, #1
   378dc:	f1a3 030c 	sub.w	r3, r3, #12
   378e0:	d1f5      	bne.n	378ce <z_sys_mem_pool_block_alloc+0x72>
   378e2:	2400      	movs	r4, #0
	pool_irq_unlock(p, key);
   378e4:	4641      	mov	r1, r8
   378e6:	7c28      	ldrb	r0, [r5, #16]
   378e8:	f7ff ff6b 	bl	377c2 <pool_irq_unlock.isra.4>
	*data_p = data;
   378ec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   378ee:	601c      	str	r4, [r3, #0]
	if (data == NULL) {
   378f0:	2c00      	cmp	r4, #0
   378f2:	d0db      	beq.n	378ac <z_sys_mem_pool_block_alloc+0x50>
	*level_p = alloc_l;
   378f4:	68bb      	ldr	r3, [r7, #8]
	return 0;
   378f6:	2000      	movs	r0, #0
	*level_p = alloc_l;
   378f8:	f8c3 9000 	str.w	r9, [r3]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   378fc:	682b      	ldr	r3, [r5, #0]
   378fe:	1ae4      	subs	r4, r4, r3
   37900:	f85a 3029 	ldr.w	r3, [sl, r9, lsl #2]
   37904:	fb94 f4f3 	sdiv	r4, r4, r3
	*block_p = block_num(p, data, lsizes[alloc_l]);
   37908:	687b      	ldr	r3, [r7, #4]
   3790a:	601c      	str	r4, [r3, #0]
}
   3790c:	371c      	adds	r7, #28
   3790e:	46bd      	mov	sp, r7
   37910:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	node->prev->next = node->next;
   37914:	e9d4 3200 	ldrd	r3, r2, [r4]
   37918:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   3791a:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   3791c:	2300      	movs	r3, #0
	node->prev = NULL;
   3791e:	e9c4 3300 	strd	r3, r3, [r4]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   37922:	682b      	ldr	r3, [r5, #0]
		data = block_alloc(p, i, lsizes[i]);
   37924:	f85a 1026 	ldr.w	r1, [sl, r6, lsl #2]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   37928:	1ae2      	subs	r2, r4, r3
	int bit = get_bit_ptr(p, level, bn, &word);
   3792a:	f107 0b14 	add.w	fp, r7, #20
   3792e:	fb92 f2f1 	sdiv	r2, r2, r1
   37932:	465b      	mov	r3, fp
   37934:	4631      	mov	r1, r6
   37936:	4628      	mov	r0, r5
   37938:	f7ff ff23 	bl	37782 <get_bit_ptr>
	*word |= (1<<bit);
   3793c:	2201      	movs	r2, #1
   3793e:	6979      	ldr	r1, [r7, #20]
   37940:	fa02 f000 	lsl.w	r0, r2, r0
   37944:	680b      	ldr	r3, [r1, #0]
   37946:	603a      	str	r2, [r7, #0]
   37948:	4303      	orrs	r3, r0
   3794a:	600b      	str	r3, [r1, #0]
			for (from_l = i; from_l < alloc_l; from_l++) {
   3794c:	454e      	cmp	r6, r9
   3794e:	dac9      	bge.n	378e4 <z_sys_mem_pool_block_alloc+0x88>
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   37950:	682a      	ldr	r2, [r5, #0]
   37952:	f85a 3026 	ldr.w	r3, [sl, r6, lsl #2]
   37956:	1aa2      	subs	r2, r4, r2
   37958:	fb92 f2f3 	sdiv	r2, r2, r3
	set_alloc_bit(p, l + 1, 4*bn);
   3795c:	3601      	adds	r6, #1
	int bit = get_bit_ptr(p, level, bn, &word);
   3795e:	465b      	mov	r3, fp
   37960:	0092      	lsls	r2, r2, #2
   37962:	4631      	mov	r1, r6
   37964:	4628      	mov	r0, r5
   37966:	f7ff ff0c 	bl	37782 <get_bit_ptr>
	*word |= (1<<bit);
   3796a:	697a      	ldr	r2, [r7, #20]
   3796c:	683b      	ldr	r3, [r7, #0]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   3796e:	68e9      	ldr	r1, [r5, #12]
	*word |= (1<<bit);
   37970:	fa03 f000 	lsl.w	r0, r3, r0
   37974:	6813      	ldr	r3, [r2, #0]
   37976:	4303      	orrs	r3, r0
   37978:	6013      	str	r3, [r2, #0]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   3797a:	230c      	movs	r3, #12
   3797c:	2203      	movs	r2, #3
   3797e:	fb03 1106 	mla	r1, r3, r6, r1
		int lsz = lsizes[l + 1];
   37982:	f85a 0026 	ldr.w	r0, [sl, r6, lsl #2]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   37986:	f101 0e04 	add.w	lr, r1, #4
   3798a:	1823      	adds	r3, r4, r0
   3798c:	60fa      	str	r2, [r7, #12]
	node->prev = list->tail;
   3798e:	688a      	ldr	r2, [r1, #8]
	node->next = list;
   37990:	f8c3 e000 	str.w	lr, [r3]
	node->prev = list->tail;
   37994:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
   37996:	688a      	ldr	r2, [r1, #8]
   37998:	6013      	str	r3, [r2, #0]
	for (i = 1; i < 4; i++) {
   3799a:	68fa      	ldr	r2, [r7, #12]
	list->tail = node;
   3799c:	608b      	str	r3, [r1, #8]
   3799e:	3a01      	subs	r2, #1
   379a0:	4403      	add	r3, r0
   379a2:	60fa      	str	r2, [r7, #12]
   379a4:	d1f3      	bne.n	3798e <z_sys_mem_pool_block_alloc+0x132>
				pool_irq_unlock(p, key);
   379a6:	4641      	mov	r1, r8
   379a8:	7c28      	ldrb	r0, [r5, #16]
   379aa:	f7ff ff0a 	bl	377c2 <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   379ae:	7c2b      	ldrb	r3, [r5, #16]
   379b0:	07db      	lsls	r3, r3, #31
   379b2:	d503      	bpl.n	379bc <z_sys_mem_pool_block_alloc+0x160>
   379b4:	f7ff fefc 	bl	377b0 <pool_irq_lock.isra.2.part.3>
				key = pool_irq_lock(p);
   379b8:	4680      	mov	r8, r0
   379ba:	e7c7      	b.n	3794c <z_sys_mem_pool_block_alloc+0xf0>
		return 0;
   379bc:	68f8      	ldr	r0, [r7, #12]
   379be:	e7fb      	b.n	379b8 <z_sys_mem_pool_block_alloc+0x15c>

000379c0 <arch_printk_char_out>:
}
   379c0:	2000      	movs	r0, #0
   379c2:	4770      	bx	lr

000379c4 <print_err>:
{
   379c4:	b570      	push	{r4, r5, r6, lr}
   379c6:	460d      	mov	r5, r1
   379c8:	4604      	mov	r4, r0
	out('E', ctx);
   379ca:	2045      	movs	r0, #69	; 0x45
   379cc:	47a0      	blx	r4
	out('R', ctx);
   379ce:	4629      	mov	r1, r5
   379d0:	2052      	movs	r0, #82	; 0x52
   379d2:	47a0      	blx	r4
	out('R', ctx);
   379d4:	4629      	mov	r1, r5
   379d6:	4623      	mov	r3, r4
}
   379d8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
   379dc:	2052      	movs	r0, #82	; 0x52
   379de:	4718      	bx	r3

000379e0 <z_vprintk>:
{
   379e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char length_mod = 0;
   379e4:	f04f 0800 	mov.w	r8, #0
{
   379e8:	4606      	mov	r6, r0
   379ea:	460f      	mov	r7, r1
   379ec:	461c      	mov	r4, r3
	int min_width = -1;
   379ee:	f04f 3aff 	mov.w	sl, #4294967295
	enum pad_type padding = PAD_NONE;
   379f2:	46c1      	mov	r9, r8
	int might_format = 0; /* 1 if encountered a '%' */
   379f4:	4645      	mov	r5, r8
{
   379f6:	b08b      	sub	sp, #44	; 0x2c
   379f8:	9202      	str	r2, [sp, #8]
	while (*fmt) {
   379fa:	9b02      	ldr	r3, [sp, #8]
   379fc:	7818      	ldrb	r0, [r3, #0]
   379fe:	b910      	cbnz	r0, 37a06 <z_vprintk+0x26>
}
   37a00:	b00b      	add	sp, #44	; 0x2c
   37a02:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!might_format) {
   37a06:	b945      	cbnz	r5, 37a1a <z_vprintk+0x3a>
			if (*fmt != '%') {
   37a08:	2825      	cmp	r0, #37	; 0x25
   37a0a:	f000 814b 	beq.w	37ca4 <z_vprintk+0x2c4>
				out((int)*fmt, ctx);
   37a0e:	4639      	mov	r1, r7
   37a10:	47b0      	blx	r6
		++fmt;
   37a12:	9b02      	ldr	r3, [sp, #8]
   37a14:	3301      	adds	r3, #1
   37a16:	9302      	str	r3, [sp, #8]
   37a18:	e7ef      	b.n	379fa <z_vprintk+0x1a>
			switch (*fmt) {
   37a1a:	2864      	cmp	r0, #100	; 0x64
   37a1c:	d06d      	beq.n	37afa <z_vprintk+0x11a>
   37a1e:	d819      	bhi.n	37a54 <z_vprintk+0x74>
   37a20:	2839      	cmp	r0, #57	; 0x39
   37a22:	d80a      	bhi.n	37a3a <z_vprintk+0x5a>
   37a24:	2831      	cmp	r0, #49	; 0x31
   37a26:	d25f      	bcs.n	37ae8 <z_vprintk+0x108>
   37a28:	282d      	cmp	r0, #45	; 0x2d
   37a2a:	f000 8141 	beq.w	37cb0 <z_vprintk+0x2d0>
   37a2e:	2830      	cmp	r0, #48	; 0x30
   37a30:	d04b      	beq.n	37aca <z_vprintk+0xea>
   37a32:	2825      	cmp	r0, #37	; 0x25
   37a34:	d107      	bne.n	37a46 <z_vprintk+0x66>
				out((int)'%', ctx);
   37a36:	4639      	mov	r1, r7
   37a38:	e132      	b.n	37ca0 <z_vprintk+0x2c0>
			switch (*fmt) {
   37a3a:	2858      	cmp	r0, #88	; 0x58
   37a3c:	f000 80bb 	beq.w	37bb6 <z_vprintk+0x1d6>
   37a40:	2863      	cmp	r0, #99	; 0x63
   37a42:	f000 812a 	beq.w	37c9a <z_vprintk+0x2ba>
				out((int)'%', ctx);
   37a46:	4639      	mov	r1, r7
   37a48:	2025      	movs	r0, #37	; 0x25
   37a4a:	47b0      	blx	r6
				out((int)*fmt, ctx);
   37a4c:	9b02      	ldr	r3, [sp, #8]
   37a4e:	4639      	mov	r1, r7
   37a50:	7818      	ldrb	r0, [r3, #0]
   37a52:	e125      	b.n	37ca0 <z_vprintk+0x2c0>
			switch (*fmt) {
   37a54:	2870      	cmp	r0, #112	; 0x70
   37a56:	f000 80a4 	beq.w	37ba2 <z_vprintk+0x1c2>
   37a5a:	d811      	bhi.n	37a80 <z_vprintk+0xa0>
   37a5c:	2869      	cmp	r0, #105	; 0x69
   37a5e:	d04c      	beq.n	37afa <z_vprintk+0x11a>
   37a60:	286c      	cmp	r0, #108	; 0x6c
   37a62:	d105      	bne.n	37a70 <z_vprintk+0x90>
				} else if (*fmt == 'l' && length_mod == 'l') {
   37a64:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   37a68:	d12a      	bne.n	37ac0 <z_vprintk+0xe0>
					length_mod = 'L';
   37a6a:	f04f 084c 	mov.w	r8, #76	; 0x4c
   37a6e:	e7d0      	b.n	37a12 <z_vprintk+0x32>
			switch (*fmt) {
   37a70:	2868      	cmp	r0, #104	; 0x68
   37a72:	d1e8      	bne.n	37a46 <z_vprintk+0x66>
				if (*fmt == 'h' && length_mod == 'h') {
   37a74:	f1b8 0f68 	cmp.w	r8, #104	; 0x68
   37a78:	d122      	bne.n	37ac0 <z_vprintk+0xe0>
					length_mod = 'H';
   37a7a:	f04f 0848 	mov.w	r8, #72	; 0x48
   37a7e:	e7c8      	b.n	37a12 <z_vprintk+0x32>
			switch (*fmt) {
   37a80:	2875      	cmp	r0, #117	; 0x75
   37a82:	d072      	beq.n	37b6a <z_vprintk+0x18a>
   37a84:	d818      	bhi.n	37ab8 <z_vprintk+0xd8>
   37a86:	2873      	cmp	r0, #115	; 0x73
   37a88:	d1dd      	bne.n	37a46 <z_vprintk+0x66>
				char *s = va_arg(ap, char *);
   37a8a:	f854 5b04 	ldr.w	r5, [r4], #4
				while (*s) {
   37a8e:	46ab      	mov	fp, r5
   37a90:	465b      	mov	r3, fp
   37a92:	f81b 0b01 	ldrb.w	r0, [fp], #1
   37a96:	2800      	cmp	r0, #0
   37a98:	f040 80fc 	bne.w	37c94 <z_vprintk+0x2b4>
				if (padding == PAD_SPACE_AFTER) {
   37a9c:	f1b9 0f03 	cmp.w	r9, #3
   37aa0:	f040 810c 	bne.w	37cbc <z_vprintk+0x2dc>
					int remaining = min_width - (s - start);
   37aa4:	1b5d      	subs	r5, r3, r5
   37aa6:	ebaa 0505 	sub.w	r5, sl, r5
					while (remaining-- > 0) {
   37aaa:	2d00      	cmp	r5, #0
   37aac:	dd49      	ble.n	37b42 <z_vprintk+0x162>
						out(' ', ctx);
   37aae:	4639      	mov	r1, r7
   37ab0:	2020      	movs	r0, #32
   37ab2:	47b0      	blx	r6
   37ab4:	3d01      	subs	r5, #1
   37ab6:	e7f8      	b.n	37aaa <z_vprintk+0xca>
			switch (*fmt) {
   37ab8:	2878      	cmp	r0, #120	; 0x78
   37aba:	d07c      	beq.n	37bb6 <z_vprintk+0x1d6>
   37abc:	287a      	cmp	r0, #122	; 0x7a
   37abe:	d1c2      	bne.n	37a46 <z_vprintk+0x66>
				} else if (length_mod == 0) {
   37ac0:	f1b8 0f00 	cmp.w	r8, #0
   37ac4:	d1bf      	bne.n	37a46 <z_vprintk+0x66>
   37ac6:	4680      	mov	r8, r0
   37ac8:	e7a3      	b.n	37a12 <z_vprintk+0x32>
				if (min_width < 0 && padding == PAD_NONE) {
   37aca:	f1ba 0f00 	cmp.w	sl, #0
   37ace:	da0e      	bge.n	37aee <z_vprintk+0x10e>
   37ad0:	f1b9 0f00 	cmp.w	r9, #0
   37ad4:	f000 80ef 	beq.w	37cb6 <z_vprintk+0x2d6>
					min_width = *fmt - '0';
   37ad8:	f1a0 0a30 	sub.w	sl, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
   37adc:	f1b9 0f00 	cmp.w	r9, #0
   37ae0:	bf08      	it	eq
   37ae2:	f04f 0902 	moveq.w	r9, #2
   37ae6:	e794      	b.n	37a12 <z_vprintk+0x32>
				if (min_width < 0) {
   37ae8:	f1ba 0f00 	cmp.w	sl, #0
   37aec:	dbf4      	blt.n	37ad8 <z_vprintk+0xf8>
					min_width = 10 * min_width + *fmt - '0';
   37aee:	230a      	movs	r3, #10
   37af0:	fb03 0a0a 	mla	sl, r3, sl, r0
   37af4:	f1aa 0a30 	sub.w	sl, sl, #48	; 0x30
   37af8:	e7f0      	b.n	37adc <z_vprintk+0xfc>
				if (length_mod == 'z') {
   37afa:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
   37afe:	d102      	bne.n	37b06 <z_vprintk+0x126>
					d = va_arg(ap, int);
   37b00:	f854 5b04 	ldr.w	r5, [r4], #4
   37b04:	e020      	b.n	37b48 <z_vprintk+0x168>
				} else if (length_mod == 'l') {
   37b06:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   37b0a:	d0f9      	beq.n	37b00 <z_vprintk+0x120>
				} else if (length_mod == 'L') {
   37b0c:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   37b10:	d1f6      	bne.n	37b00 <z_vprintk+0x120>
					long long lld = va_arg(ap, long long);
   37b12:	3407      	adds	r4, #7
   37b14:	f024 0407 	bic.w	r4, r4, #7
   37b18:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (lld > __LONG_MAX__ ||
   37b1c:	f112 4100 	adds.w	r1, r2, #2147483648	; 0x80000000
   37b20:	9106      	str	r1, [sp, #24]
   37b22:	f143 0100 	adc.w	r1, r3, #0
   37b26:	9107      	str	r1, [sp, #28]
   37b28:	2100      	movs	r1, #0
   37b2a:	e9dd bc06 	ldrd	fp, ip, [sp, #24]
   37b2e:	f04f 30ff 	mov.w	r0, #4294967295
   37b32:	4561      	cmp	r1, ip
   37b34:	bf08      	it	eq
   37b36:	4558      	cmpeq	r0, fp
   37b38:	d205      	bcs.n	37b46 <z_vprintk+0x166>
						print_err(out, ctx);
   37b3a:	4639      	mov	r1, r7
   37b3c:	4630      	mov	r0, r6
   37b3e:	f7ff ff41 	bl	379c4 <print_err>
			might_format = 0;
   37b42:	2500      	movs	r5, #0
				break;
   37b44:	e765      	b.n	37a12 <z_vprintk+0x32>
					d = lld;
   37b46:	4615      	mov	r5, r2
				if (d < 0) {
   37b48:	2d00      	cmp	r5, #0
   37b4a:	da05      	bge.n	37b58 <z_vprintk+0x178>
					out((int)'-', ctx);
   37b4c:	4639      	mov	r1, r7
   37b4e:	202d      	movs	r0, #45	; 0x2d
   37b50:	47b0      	blx	r6
					d = -d;
   37b52:	426d      	negs	r5, r5
					min_width--;
   37b54:	f10a 3aff 	add.w	sl, sl, #4294967295
				_printk_dec_ulong(out, ctx, d, padding,
   37b58:	464b      	mov	r3, r9
   37b5a:	462a      	mov	r2, r5
   37b5c:	f8cd a000 	str.w	sl, [sp]
				_printk_dec_ulong(out, ctx, u, padding,
   37b60:	4639      	mov	r1, r7
   37b62:	4630      	mov	r0, r6
   37b64:	f7eb fde8 	bl	23738 <_printk_dec_ulong>
				break;
   37b68:	e7eb      	b.n	37b42 <z_vprintk+0x162>
				if (length_mod == 'z') {
   37b6a:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
   37b6e:	d102      	bne.n	37b76 <z_vprintk+0x196>
					u = va_arg(ap, unsigned int);
   37b70:	f854 2b04 	ldr.w	r2, [r4], #4
   37b74:	e011      	b.n	37b9a <z_vprintk+0x1ba>
				} else if (length_mod == 'l') {
   37b76:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   37b7a:	d0f9      	beq.n	37b70 <z_vprintk+0x190>
				} else if (length_mod == 'L') {
   37b7c:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   37b80:	d1f6      	bne.n	37b70 <z_vprintk+0x190>
					if (llu > ~0UL) {
   37b82:	2100      	movs	r1, #0
   37b84:	f04f 30ff 	mov.w	r0, #4294967295
					unsigned long long llu =
   37b88:	3407      	adds	r4, #7
   37b8a:	f024 0407 	bic.w	r4, r4, #7
   37b8e:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > ~0UL) {
   37b92:	4299      	cmp	r1, r3
   37b94:	bf08      	it	eq
   37b96:	4290      	cmpeq	r0, r2
   37b98:	d3cf      	bcc.n	37b3a <z_vprintk+0x15a>
				_printk_dec_ulong(out, ctx, u, padding,
   37b9a:	f8cd a000 	str.w	sl, [sp]
   37b9e:	464b      	mov	r3, r9
   37ba0:	e7de      	b.n	37b60 <z_vprintk+0x180>
				out('0', ctx);
   37ba2:	4639      	mov	r1, r7
   37ba4:	2030      	movs	r0, #48	; 0x30
   37ba6:	47b0      	blx	r6
				out('x', ctx);
   37ba8:	4639      	mov	r1, r7
   37baa:	2078      	movs	r0, #120	; 0x78
   37bac:	47b0      	blx	r6
					min_width = 8;
   37bae:	f04f 0a08 	mov.w	sl, #8
				padding = PAD_ZERO_BEFORE;
   37bb2:	f04f 0901 	mov.w	r9, #1
				if (*fmt == 'p') {
   37bb6:	9b02      	ldr	r3, [sp, #8]
   37bb8:	781b      	ldrb	r3, [r3, #0]
   37bba:	2b70      	cmp	r3, #112	; 0x70
   37bbc:	d104      	bne.n	37bc8 <z_vprintk+0x1e8>
					x = va_arg(ap, unsigned int);
   37bbe:	f854 3b04 	ldr.w	r3, [r4], #4
   37bc2:	9304      	str	r3, [sp, #16]
   37bc4:	2300      	movs	r3, #0
   37bc6:	e00d      	b.n	37be4 <z_vprintk+0x204>
				} else if (length_mod == 'l') {
   37bc8:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   37bcc:	d0f7      	beq.n	37bbe <z_vprintk+0x1de>
				} else if (length_mod == 'L') {
   37bce:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   37bd2:	d1f4      	bne.n	37bbe <z_vprintk+0x1de>
					x = va_arg(ap, unsigned long long);
   37bd4:	3407      	adds	r4, #7
   37bd6:	f024 0307 	bic.w	r3, r4, #7
   37bda:	461c      	mov	r4, r3
   37bdc:	f854 2b08 	ldr.w	r2, [r4], #8
   37be0:	685b      	ldr	r3, [r3, #4]
   37be2:	9204      	str	r2, [sp, #16]
	int digits = 0;
   37be4:	2100      	movs	r1, #0
	int remaining = 16; /* 16 digits max */
   37be6:	2210      	movs	r2, #16
	int shift = sizeof(num) * 8;
   37be8:	f04f 0b40 	mov.w	fp, #64	; 0x40
	int digits = 0;
   37bec:	9103      	str	r1, [sp, #12]
	int found_largest_digit = 0;
   37bee:	9105      	str	r1, [sp, #20]
		shift -= 4;
   37bf0:	f1ab 0b04 	sub.w	fp, fp, #4
		nibble = (num >> shift) & 0xf;
   37bf4:	9804      	ldr	r0, [sp, #16]
   37bf6:	f1cb 0c20 	rsb	ip, fp, #32
   37bfa:	f1ab 0120 	sub.w	r1, fp, #32
   37bfe:	fa20 f00b 	lsr.w	r0, r0, fp
   37c02:	fa03 fc0c 	lsl.w	ip, r3, ip
   37c06:	ea40 000c 	orr.w	r0, r0, ip
   37c0a:	fa23 f101 	lsr.w	r1, r3, r1
   37c0e:	4308      	orrs	r0, r1
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
   37c10:	f010 000f 	ands.w	r0, r0, #15
   37c14:	d106      	bne.n	37c24 <z_vprintk+0x244>
   37c16:	9905      	ldr	r1, [sp, #20]
   37c18:	b911      	cbnz	r1, 37c20 <z_vprintk+0x240>
   37c1a:	f1bb 0f00 	cmp.w	fp, #0
   37c1e:	d122      	bne.n	37c66 <z_vprintk+0x286>
			nibble += nibble > 9 ? 87 : 48;
   37c20:	2130      	movs	r1, #48	; 0x30
   37c22:	e003      	b.n	37c2c <z_vprintk+0x24c>
   37c24:	2809      	cmp	r0, #9
   37c26:	bf8c      	ite	hi
   37c28:	2157      	movhi	r1, #87	; 0x57
   37c2a:	2130      	movls	r1, #48	; 0x30
   37c2c:	4408      	add	r0, r1
			out((int)nibble, ctx);
   37c2e:	b240      	sxtb	r0, r0
   37c30:	4639      	mov	r1, r7
   37c32:	9308      	str	r3, [sp, #32]
   37c34:	9205      	str	r2, [sp, #20]
   37c36:	47b0      	blx	r6
			digits++;
   37c38:	9b03      	ldr	r3, [sp, #12]
	while (shift >= 4) {
   37c3a:	9a05      	ldr	r2, [sp, #20]
			digits++;
   37c3c:	3301      	adds	r3, #1
   37c3e:	9303      	str	r3, [sp, #12]
	while (shift >= 4) {
   37c40:	9b08      	ldr	r3, [sp, #32]
   37c42:	f1bb 0f00 	cmp.w	fp, #0
   37c46:	d123      	bne.n	37c90 <z_vprintk+0x2b0>
	if (padding == PAD_SPACE_AFTER) {
   37c48:	f1b9 0f03 	cmp.w	r9, #3
   37c4c:	f47f af79 	bne.w	37b42 <z_vprintk+0x162>
		remaining = min_width * 2 - digits;
   37c50:	9b03      	ldr	r3, [sp, #12]
   37c52:	ebc3 054a 	rsb	r5, r3, sl, lsl #1
		while (remaining-- > 0) {
   37c56:	2d00      	cmp	r5, #0
   37c58:	f77f af73 	ble.w	37b42 <z_vprintk+0x162>
			out(' ', ctx);
   37c5c:	4639      	mov	r1, r7
   37c5e:	2020      	movs	r0, #32
   37c60:	47b0      	blx	r6
   37c62:	3d01      	subs	r5, #1
   37c64:	e7f7      	b.n	37c56 <z_vprintk+0x276>
		if (remaining-- <= min_width) {
   37c66:	1e51      	subs	r1, r2, #1
   37c68:	4592      	cmp	sl, r2
   37c6a:	9108      	str	r1, [sp, #32]
   37c6c:	db07      	blt.n	37c7e <z_vprintk+0x29e>
			if (padding == PAD_ZERO_BEFORE) {
   37c6e:	f1b9 0f01 	cmp.w	r9, #1
   37c72:	d106      	bne.n	37c82 <z_vprintk+0x2a2>
				out('0', ctx);
   37c74:	4639      	mov	r1, r7
   37c76:	2030      	movs	r0, #48	; 0x30
   37c78:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
   37c7a:	47b0      	blx	r6
   37c7c:	9b09      	ldr	r3, [sp, #36]	; 0x24
			nibble += nibble > 9 ? 87 : 48;
   37c7e:	9a08      	ldr	r2, [sp, #32]
   37c80:	e7b6      	b.n	37bf0 <z_vprintk+0x210>
			} else if (padding == PAD_SPACE_BEFORE) {
   37c82:	f1b9 0f02 	cmp.w	r9, #2
   37c86:	d1fa      	bne.n	37c7e <z_vprintk+0x29e>
   37c88:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
   37c8a:	4639      	mov	r1, r7
   37c8c:	2020      	movs	r0, #32
   37c8e:	e7f4      	b.n	37c7a <z_vprintk+0x29a>
			found_largest_digit = 1;
   37c90:	9505      	str	r5, [sp, #20]
   37c92:	e7ad      	b.n	37bf0 <z_vprintk+0x210>
					out((int)(*s++), ctx);
   37c94:	4639      	mov	r1, r7
   37c96:	47b0      	blx	r6
   37c98:	e6fa      	b.n	37a90 <z_vprintk+0xb0>
				out(c, ctx);
   37c9a:	4639      	mov	r1, r7
   37c9c:	f854 0b04 	ldr.w	r0, [r4], #4
				out((int)'%', ctx);
   37ca0:	47b0      	blx	r6
   37ca2:	e74e      	b.n	37b42 <z_vprintk+0x162>
				length_mod = 0;
   37ca4:	46a8      	mov	r8, r5
				padding = PAD_NONE;
   37ca6:	46a9      	mov	r9, r5
				min_width = -1;
   37ca8:	f04f 3aff 	mov.w	sl, #4294967295
				might_format = 1;
   37cac:	2501      	movs	r5, #1
   37cae:	e6b0      	b.n	37a12 <z_vprintk+0x32>
				padding = PAD_SPACE_AFTER;
   37cb0:	f04f 0903 	mov.w	r9, #3
   37cb4:	e6ad      	b.n	37a12 <z_vprintk+0x32>
					padding = PAD_ZERO_BEFORE;
   37cb6:	f04f 0901 	mov.w	r9, #1
   37cba:	e6aa      	b.n	37a12 <z_vprintk+0x32>
			might_format = 0;
   37cbc:	4605      	mov	r5, r0
   37cbe:	e6a8      	b.n	37a12 <z_vprintk+0x32>

00037cc0 <printk>:
{
   37cc0:	b40f      	push	{r0, r1, r2, r3}
   37cc2:	b507      	push	{r0, r1, r2, lr}
   37cc4:	a904      	add	r1, sp, #16
   37cc6:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   37cca:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
   37ccc:	f7eb fd80 	bl	237d0 <vprintk>
}
   37cd0:	b003      	add	sp, #12
   37cd2:	f85d eb04 	ldr.w	lr, [sp], #4
   37cd6:	b004      	add	sp, #16
   37cd8:	4770      	bx	lr

00037cda <sys_sem_give>:

	return 0;
}

int sys_sem_give(struct sys_sem *sem)
{
   37cda:	b508      	push	{r3, lr}
	z_impl_k_sem_give(sem);
   37cdc:	f7fc fcb6 	bl	3464c <z_impl_k_sem_give>
	k_sem_give(&sem->kernel_sem);

	return 0;
}
   37ce0:	2000      	movs	r0, #0
   37ce2:	bd08      	pop	{r3, pc}

00037ce4 <sys_sem_take>:

int sys_sem_take(struct sys_sem *sem, s32_t timeout)
{
   37ce4:	b508      	push	{r3, lr}
	return z_impl_k_sem_take(sem, timeout);
   37ce6:	f7fc fcfb 	bl	346e0 <z_impl_k_sem_take>
	int ret_value = 0;

	ret_value = k_sem_take(&sem->kernel_sem, timeout);
	if (ret_value == -EAGAIN || ret_value == -EBUSY) {
   37cea:	f110 0f0b 	cmn.w	r0, #11
   37cee:	d005      	beq.n	37cfc <sys_sem_take+0x18>
   37cf0:	f110 0f10 	cmn.w	r0, #16
		ret_value = -ETIMEDOUT;
   37cf4:	bf08      	it	eq
   37cf6:	f06f 0073 	mvneq.w	r0, #115	; 0x73
	}

	return ret_value;
}
   37cfa:	bd08      	pop	{r3, pc}
		ret_value = -ETIMEDOUT;
   37cfc:	f06f 0073 	mvn.w	r0, #115	; 0x73
	return ret_value;
   37d00:	e7fb      	b.n	37cfa <sys_sem_take+0x16>

00037d02 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   37d02:	4604      	mov	r4, r0
   37d04:	b508      	push	{r3, lr}
   37d06:	4608      	mov	r0, r1
   37d08:	4611      	mov	r1, r2
	entry(p1, p2, p3);
   37d0a:	461a      	mov	r2, r3
   37d0c:	47a0      	blx	r4
	return z_impl_k_current_get();
   37d0e:	f7fc fc97 	bl	34640 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
   37d12:	f7ed fdfd 	bl	25910 <z_impl_k_thread_abort>

00037d16 <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
   37d16:	b510      	push	{r4, lr}
   37d18:	4604      	mov	r4, r0
	return z_impl_k_queue_get(queue, timeout);
   37d1a:	f04f 31ff 	mov.w	r1, #4294967295
   37d1e:	4620      	mov	r0, r4
   37d20:	f7fb fa0a 	bl	33138 <z_impl_k_queue_get>
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
   37d24:	4603      	mov	r3, r0
   37d26:	2800      	cmp	r0, #0
   37d28:	d0f7      	beq.n	37d1a <z_work_q_main+0x4>
			continue;
		}

		handler = work->handler;
   37d2a:	6842      	ldr	r2, [r0, #4]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   37d2c:	3308      	adds	r3, #8
   37d2e:	e8d3 1fef 	ldaex	r1, [r3]
   37d32:	f021 0c01 	bic.w	ip, r1, #1
   37d36:	e8c3 cfee 	stlex	lr, ip, [r3]
   37d3a:	f1be 0f00 	cmp.w	lr, #0
   37d3e:	d1f6      	bne.n	37d2e <z_work_q_main+0x18>

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
   37d40:	07cb      	lsls	r3, r1, #31
   37d42:	d500      	bpl.n	37d46 <z_work_q_main+0x30>
					      K_WORK_STATE_PENDING)) {
			handler(work);
   37d44:	4790      	blx	r2
	z_impl_k_yield();
   37d46:	f7fc fafd 	bl	34344 <z_impl_k_yield>
   37d4a:	e7e6      	b.n	37d1a <z_work_q_main+0x4>

00037d4c <assert_post_action>:
	if (_is_user_context()) {
		k_oops();
	}
#endif

	k_panic();
   37d4c:	4040      	eors	r0, r0
   37d4e:	f380 8811 	msr	BASEPRI, r0
   37d52:	f04f 0004 	mov.w	r0, #4
   37d56:	df02      	svc	2
}
   37d58:	4770      	bx	lr

00037d5a <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_BOOTLOADER_MCUBOOT, 1);
GEN_ABSOLUTE_SYM(CONFIG_REBOOT, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   37d5a:	4770      	bx	lr

00037d5c <z_platform_init>:

void z_platform_init(void)
{
	SystemInit();
   37d5c:	f7f9 bd62 	b.w	31824 <SystemInit>

00037d60 <log_backend_is_active>:
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
   37d60:	6843      	ldr	r3, [r0, #4]
}
   37d62:	7958      	ldrb	r0, [r3, #5]
   37d64:	4770      	bx	lr

00037d66 <k_cycle_get_32_wrapper>:
   37d66:	f7ec bf87 	b.w	24c78 <z_timer_cycle_get_32>

00037d6a <dummy_timestamp>:
   37d6a:	2000      	movs	r0, #0
   37d6c:	4770      	bx	lr

00037d6e <log_string_sync>:
{
   37d6e:	b40e      	push	{r1, r2, r3}
   37d70:	b503      	push	{r0, r1, lr}
   37d72:	aa03      	add	r2, sp, #12
   37d74:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(ap, fmt);
   37d78:	9201      	str	r2, [sp, #4]
	log_generic(src_level, fmt, ap);
   37d7a:	f7eb fd55 	bl	23828 <log_generic>
}
   37d7e:	b002      	add	sp, #8
   37d80:	f85d eb04 	ldr.w	lr, [sp], #4
   37d84:	b003      	add	sp, #12
   37d86:	4770      	bx	lr

00037d88 <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
   37d88:	b508      	push	{r3, lr}
				K_THREAD_STACK_SIZEOF(logging_stack),
				log_process_thread_func, NULL, NULL, NULL,
				K_LOWEST_APPLICATION_THREAD_PRIO, 0, K_NO_WAIT);
		k_thread_name_set(&logging_thread, "logging");
	} else {
		log_init();
   37d8a:	f7eb fdc3 	bl	23914 <log_init>
	}

	return 0;
}
   37d8e:	2000      	movs	r0, #0
   37d90:	bd08      	pop	{r3, pc}

00037d92 <log_strdup>:
}
   37d92:	4770      	bx	lr

00037d94 <out_func>:
{
   37d94:	b507      	push	{r0, r1, r2, lr}
		out_ctx->func((u8_t *)&c, 1, out_ctx->control_block->ctx);
   37d96:	e9d1 3200 	ldrd	r3, r2, [r1]
{
   37d9a:	9001      	str	r0, [sp, #4]
		out_ctx->func((u8_t *)&c, 1, out_ctx->control_block->ctx);
   37d9c:	6852      	ldr	r2, [r2, #4]
   37d9e:	2101      	movs	r1, #1
   37da0:	a801      	add	r0, sp, #4
   37da2:	4798      	blx	r3
}
   37da4:	2000      	movs	r0, #0
   37da6:	b003      	add	sp, #12
   37da8:	f85d fb04 	ldr.w	pc, [sp], #4

00037dac <buffer_write>:
{
   37dac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   37dae:	4606      	mov	r6, r0
   37db0:	460d      	mov	r5, r1
   37db2:	4614      	mov	r4, r2
   37db4:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
   37db6:	4621      	mov	r1, r4
   37db8:	4628      	mov	r0, r5
   37dba:	463a      	mov	r2, r7
   37dbc:	47b0      	blx	r6
	} while (len != 0);
   37dbe:	1a24      	subs	r4, r4, r0
		buf += processed;
   37dc0:	4405      	add	r5, r0
	} while (len != 0);
   37dc2:	d1f8      	bne.n	37db6 <buffer_write+0xa>
}
   37dc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00037dc6 <log_output_flush>:
		     log_output->control_block->offset,
   37dc6:	6842      	ldr	r2, [r0, #4]
{
   37dc8:	b510      	push	{r4, lr}
	buffer_write(log_output->func, log_output->buf,
   37dca:	e9d2 2300 	ldrd	r2, r3, [r2]
{
   37dce:	4604      	mov	r4, r0
	buffer_write(log_output->func, log_output->buf,
   37dd0:	6881      	ldr	r1, [r0, #8]
   37dd2:	6800      	ldr	r0, [r0, #0]
   37dd4:	f7ff ffea 	bl	37dac <buffer_write>
	log_output->control_block->offset = 0;
   37dd8:	2200      	movs	r2, #0
   37dda:	6863      	ldr	r3, [r4, #4]
   37ddc:	601a      	str	r2, [r3, #0]
}
   37dde:	bd10      	pop	{r4, pc}

00037de0 <flash_write_protection_set>:
	return api->write_protection(dev, enable);
   37de0:	6843      	ldr	r3, [r0, #4]
   37de2:	68db      	ldr	r3, [r3, #12]
   37de4:	4718      	bx	r3

00037de6 <nvs_flash_rd>:
{
   37de6:	b470      	push	{r4, r5, r6}
	offset += addr & ADDR_OFFS_MASK;
   37de8:	6806      	ldr	r6, [r0, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   37dea:	8984      	ldrh	r4, [r0, #12]
   37dec:	0c0d      	lsrs	r5, r1, #16
	offset += addr & ADDR_OFFS_MASK;
   37dee:	fa16 f181 	uxtah	r1, r6, r1
   37df2:	fb05 1104 	mla	r1, r5, r4, r1
	rc = flash_read(fs->flash_device, offset, data, len);
   37df6:	6a80      	ldr	r0, [r0, #40]	; 0x28
	return api->read(dev, offset, data, len);
   37df8:	6844      	ldr	r4, [r0, #4]
   37dfa:	6824      	ldr	r4, [r4, #0]
   37dfc:	46a4      	mov	ip, r4
}
   37dfe:	bc70      	pop	{r4, r5, r6}
   37e00:	4760      	bx	ip

00037e02 <nvs_flash_block_cmp>:
{
   37e02:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   37e06:	4681      	mov	r9, r0
   37e08:	460f      	mov	r7, r1
   37e0a:	4690      	mov	r8, r2
   37e0c:	461c      	mov	r4, r3
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   37e0e:	7c05      	ldrb	r5, [r0, #16]
{
   37e10:	b089      	sub	sp, #36	; 0x24
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   37e12:	426d      	negs	r5, r5
   37e14:	f005 0520 	and.w	r5, r5, #32
	while (len) {
   37e18:	b91c      	cbnz	r4, 37e22 <nvs_flash_block_cmp+0x20>
	return 0;
   37e1a:	4620      	mov	r0, r4
}
   37e1c:	b009      	add	sp, #36	; 0x24
   37e1e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		bytes_to_cmp = MIN(block_size, len);
   37e22:	42ac      	cmp	r4, r5
   37e24:	4626      	mov	r6, r4
   37e26:	bf28      	it	cs
   37e28:	462e      	movcs	r6, r5
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_cmp);
   37e2a:	466a      	mov	r2, sp
   37e2c:	4633      	mov	r3, r6
   37e2e:	4639      	mov	r1, r7
   37e30:	4648      	mov	r0, r9
   37e32:	f7ff ffd8 	bl	37de6 <nvs_flash_rd>
		if (rc) {
   37e36:	2800      	cmp	r0, #0
   37e38:	d1f0      	bne.n	37e1c <nvs_flash_block_cmp+0x1a>
		rc = memcmp(data8, buf, bytes_to_cmp);
   37e3a:	4632      	mov	r2, r6
   37e3c:	4669      	mov	r1, sp
   37e3e:	4640      	mov	r0, r8
   37e40:	f001 ff8f 	bl	39d62 <memcmp>
		if (rc) {
   37e44:	b918      	cbnz	r0, 37e4e <nvs_flash_block_cmp+0x4c>
		len -= bytes_to_cmp;
   37e46:	1ba4      	subs	r4, r4, r6
		addr += bytes_to_cmp;
   37e48:	4437      	add	r7, r6
		data8 += bytes_to_cmp;
   37e4a:	44b0      	add	r8, r6
   37e4c:	e7e4      	b.n	37e18 <nvs_flash_block_cmp+0x16>
			return 1;
   37e4e:	2001      	movs	r0, #1
   37e50:	e7e4      	b.n	37e1c <nvs_flash_block_cmp+0x1a>

00037e52 <nvs_ate_crc8_check>:
{
   37e52:	b510      	push	{r4, lr}
   37e54:	4604      	mov	r4, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   37e56:	4601      	mov	r1, r0
   37e58:	2207      	movs	r2, #7
   37e5a:	20ff      	movs	r0, #255	; 0xff
   37e5c:	f7eb fb80 	bl	23560 <crc8_ccitt>
	if (crc8 == entry->crc8) {
   37e60:	79e3      	ldrb	r3, [r4, #7]
}
   37e62:	1a18      	subs	r0, r3, r0
   37e64:	bf18      	it	ne
   37e66:	2001      	movne	r0, #1
   37e68:	bd10      	pop	{r4, pc}

00037e6a <nvs_ate_crc8_update>:
{
   37e6a:	b510      	push	{r4, lr}
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   37e6c:	4601      	mov	r1, r0
{
   37e6e:	4604      	mov	r4, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   37e70:	2207      	movs	r2, #7
   37e72:	20ff      	movs	r0, #255	; 0xff
   37e74:	f7eb fb74 	bl	23560 <crc8_ccitt>
	entry->crc8 = crc8;
   37e78:	71e0      	strb	r0, [r4, #7]
}
   37e7a:	bd10      	pop	{r4, pc}

00037e7c <nvs_al_size.isra.1>:
	if (fs->write_block_size <= 1U) {
   37e7c:	2801      	cmp	r0, #1
	return (len + (fs->write_block_size - 1U)) & ~(fs->write_block_size - 1U);
   37e7e:	bf81      	itttt	hi
   37e80:	f100 33ff 	addhi.w	r3, r0, #4294967295
   37e84:	18c9      	addhi	r1, r1, r3
   37e86:	4240      	neghi	r0, r0
   37e88:	4001      	andhi	r1, r0
}
   37e8a:	4608      	mov	r0, r1
   37e8c:	4770      	bx	lr

00037e8e <nvs_sector_advance.isra.2>:
	*addr += (1 << ADDR_SECT_SHIFT);
   37e8e:	680b      	ldr	r3, [r1, #0]
   37e90:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
	if ((*addr >> ADDR_SECT_SHIFT) == fs->sector_count) {
   37e94:	0c1a      	lsrs	r2, r3, #16
   37e96:	4282      	cmp	r2, r0
		*addr -= (fs->sector_count << ADDR_SECT_SHIFT);
   37e98:	bf08      	it	eq
   37e9a:	eba3 4302 	subeq.w	r3, r3, r2, lsl #16
   37e9e:	600b      	str	r3, [r1, #0]
}
   37ea0:	4770      	bx	lr

00037ea2 <nvs_flash_cmp_const.constprop.5>:
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   37ea2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   37ea6:	7c04      	ldrb	r4, [r0, #16]
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   37ea8:	b088      	sub	sp, #32
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   37eaa:	4264      	negs	r4, r4
   37eac:	f004 0420 	and.w	r4, r4, #32
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   37eb0:	4680      	mov	r8, r0
   37eb2:	460e      	mov	r6, r1
   37eb4:	4615      	mov	r5, r2
	(void)memset(cmp, value, block_size);
   37eb6:	2320      	movs	r3, #32
   37eb8:	4622      	mov	r2, r4
   37eba:	21ff      	movs	r1, #255	; 0xff
   37ebc:	4668      	mov	r0, sp
   37ebe:	f001 ff86 	bl	39dce <__memset_chk>
	while (len) {
   37ec2:	b91d      	cbnz	r5, 37ecc <nvs_flash_cmp_const.constprop.5+0x2a>
	return 0;
   37ec4:	4628      	mov	r0, r5
}
   37ec6:	b008      	add	sp, #32
   37ec8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		bytes_to_cmp = MIN(block_size, len);
   37ecc:	42ac      	cmp	r4, r5
   37ece:	4627      	mov	r7, r4
   37ed0:	bf28      	it	cs
   37ed2:	462f      	movcs	r7, r5
		rc = nvs_flash_block_cmp(fs, addr, cmp, bytes_to_cmp);
   37ed4:	466a      	mov	r2, sp
   37ed6:	463b      	mov	r3, r7
   37ed8:	4631      	mov	r1, r6
   37eda:	4640      	mov	r0, r8
   37edc:	f7ff ff91 	bl	37e02 <nvs_flash_block_cmp>
		if (rc) {
   37ee0:	2800      	cmp	r0, #0
   37ee2:	d1f0      	bne.n	37ec6 <nvs_flash_cmp_const.constprop.5+0x24>
		len -= bytes_to_cmp;
   37ee4:	1bed      	subs	r5, r5, r7
		addr += bytes_to_cmp;
   37ee6:	443e      	add	r6, r7
   37ee8:	e7eb      	b.n	37ec2 <nvs_flash_cmp_const.constprop.5+0x20>

00037eea <nvs_flash_al_wrt.part.3>:
static int nvs_flash_al_wrt(struct nvs_fs *fs, u32_t addr, const void *data,
   37eea:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   37eee:	4607      	mov	r7, r0
   37ef0:	b088      	sub	sp, #32
   37ef2:	460d      	mov	r5, r1
	offset = fs->offset;
   37ef4:	f8d0 a000 	ldr.w	sl, [r0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   37ef8:	8986      	ldrh	r6, [r0, #12]
	rc = flash_write_protection_set(fs->flash_device, 0);
   37efa:	2100      	movs	r1, #0
   37efc:	6a80      	ldr	r0, [r0, #40]	; 0x28
static int nvs_flash_al_wrt(struct nvs_fs *fs, u32_t addr, const void *data,
   37efe:	4690      	mov	r8, r2
   37f00:	461c      	mov	r4, r3
	rc = flash_write_protection_set(fs->flash_device, 0);
   37f02:	f7ff ff6d 	bl	37de0 <flash_write_protection_set>
	if (rc) {
   37f06:	bb88      	cbnz	r0, 37f6c <nvs_flash_al_wrt.part.3+0x82>
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   37f08:	ea4f 4915 	mov.w	r9, r5, lsr #16
	offset += addr & ADDR_OFFS_MASK;
   37f0c:	fa1a f585 	uxtah	r5, sl, r5
   37f10:	fb06 5909 	mla	r9, r6, r9, r5
	blen = len & ~(fs->write_block_size - 1U);
   37f14:	7c3d      	ldrb	r5, [r7, #16]
   37f16:	426d      	negs	r5, r5
	if (blen > 0) {
   37f18:	4025      	ands	r5, r4
   37f1a:	d00b      	beq.n	37f34 <nvs_flash_al_wrt.part.3+0x4a>
   37f1c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
	return api->write(dev, offset, data, len);
   37f1e:	6843      	ldr	r3, [r0, #4]
   37f20:	4642      	mov	r2, r8
   37f22:	685e      	ldr	r6, [r3, #4]
   37f24:	4649      	mov	r1, r9
   37f26:	462b      	mov	r3, r5
   37f28:	47b0      	blx	r6
		if (rc) {
   37f2a:	4606      	mov	r6, r0
   37f2c:	b9c8      	cbnz	r0, 37f62 <nvs_flash_al_wrt.part.3+0x78>
		len -= blen;
   37f2e:	1b64      	subs	r4, r4, r5
		offset += blen;
   37f30:	44a9      	add	r9, r5
		data8 += blen;
   37f32:	44a8      	add	r8, r5
	if (len) {
   37f34:	b1ec      	cbz	r4, 37f72 <nvs_flash_al_wrt.part.3+0x88>
		memcpy(buf, data8, len);
   37f36:	2320      	movs	r3, #32
   37f38:	4622      	mov	r2, r4
   37f3a:	4641      	mov	r1, r8
   37f3c:	4668      	mov	r0, sp
   37f3e:	6abd      	ldr	r5, [r7, #40]	; 0x28
   37f40:	f001 ff2a 	bl	39d98 <__memcpy_chk>
		(void)memset(buf + len, 0xff, fs->write_block_size - len);
   37f44:	7c3e      	ldrb	r6, [r7, #16]
__ssp_bos_icheck3(memset, void *, int)
   37f46:	21ff      	movs	r1, #255	; 0xff
   37f48:	1b32      	subs	r2, r6, r4
   37f4a:	eb0d 0004 	add.w	r0, sp, r4
   37f4e:	f001 ff36 	bl	39dbe <memset>
   37f52:	686b      	ldr	r3, [r5, #4]
   37f54:	466a      	mov	r2, sp
   37f56:	685c      	ldr	r4, [r3, #4]
   37f58:	4649      	mov	r1, r9
   37f5a:	4633      	mov	r3, r6
   37f5c:	4628      	mov	r0, r5
   37f5e:	47a0      	blx	r4
   37f60:	4606      	mov	r6, r0
	(void) flash_write_protection_set(fs->flash_device, 1);
   37f62:	2101      	movs	r1, #1
   37f64:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   37f66:	f7ff ff3b 	bl	37de0 <flash_write_protection_set>
	return rc;
   37f6a:	4630      	mov	r0, r6
}
   37f6c:	b008      	add	sp, #32
   37f6e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
   37f72:	4626      	mov	r6, r4
   37f74:	e7f5      	b.n	37f62 <nvs_flash_al_wrt.part.3+0x78>

00037f76 <nvs_flash_ate_wrt>:
{
   37f76:	b510      	push	{r4, lr}
   37f78:	2308      	movs	r3, #8
   37f7a:	460a      	mov	r2, r1
   37f7c:	6841      	ldr	r1, [r0, #4]
   37f7e:	4604      	mov	r4, r0
   37f80:	f7ff ffb3 	bl	37eea <nvs_flash_al_wrt.part.3>
	fs->ate_wra -= nvs_al_size(fs, sizeof(struct nvs_ate));
   37f84:	2108      	movs	r1, #8
   37f86:	4602      	mov	r2, r0
   37f88:	7c20      	ldrb	r0, [r4, #16]
   37f8a:	f7ff ff77 	bl	37e7c <nvs_al_size.isra.1>
   37f8e:	6863      	ldr	r3, [r4, #4]
   37f90:	1a18      	subs	r0, r3, r0
   37f92:	6060      	str	r0, [r4, #4]
}
   37f94:	4610      	mov	r0, r2
   37f96:	bd10      	pop	{r4, pc}

00037f98 <nvs_read>:

ssize_t nvs_read(struct nvs_fs *fs, u16_t id, void *data, size_t len)
{
   37f98:	b513      	push	{r0, r1, r4, lr}
	int rc;

	rc = nvs_read_hist(fs, id, data, len, 0);
   37f9a:	2400      	movs	r4, #0
   37f9c:	9400      	str	r4, [sp, #0]
   37f9e:	f7ec faf5 	bl	2458c <nvs_read_hist>
	return rc;
}
   37fa2:	b002      	add	sp, #8
   37fa4:	bd10      	pop	{r4, pc}

00037fa6 <clkstarted_handle>:
{
   37fa6:	b538      	push	{r3, r4, r5, lr}
	sub_data->started = true;
   37fa8:	240c      	movs	r4, #12
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
   37faa:	6883      	ldr	r3, [r0, #8]
{
   37fac:	4605      	mov	r5, r0
	sub_data->started = true;
   37fae:	fb04 3401 	mla	r4, r4, r1, r3
   37fb2:	2301      	movs	r3, #1
   37fb4:	7263      	strb	r3, [r4, #9]
	__asm__ volatile(
   37fb6:	f04f 0320 	mov.w	r3, #32
   37fba:	f3ef 8111 	mrs	r1, BASEPRI
   37fbe:	f383 8811 	msr	BASEPRI, r3
   37fc2:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
   37fc6:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_GET(slist, snode)
   37fc8:	b12b      	cbz	r3, 37fd6 <clkstarted_handle+0x30>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   37fca:	6860      	ldr	r0, [r4, #4]
   37fcc:	681a      	ldr	r2, [r3, #0]
   37fce:	4283      	cmp	r3, r0
	list->head = node;
   37fd0:	6022      	str	r2, [r4, #0]
	list->tail = node;
   37fd2:	bf08      	it	eq
   37fd4:	6062      	streq	r2, [r4, #4]
	__asm__ volatile(
   37fd6:	f381 8811 	msr	BASEPRI, r1
   37fda:	f3bf 8f6f 	isb	sy
	while ((async_data = list_get(&sub_data->list)) != NULL) {
   37fde:	b903      	cbnz	r3, 37fe2 <clkstarted_handle+0x3c>
}
   37fe0:	bd38      	pop	{r3, r4, r5, pc}
		async_data->cb(dev, async_data->user_data);
   37fe2:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
   37fe6:	4628      	mov	r0, r5
   37fe8:	4790      	blx	r2
   37fea:	e7e4      	b.n	37fb6 <clkstarted_handle+0x10>

00037fec <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
   37fec:	2200      	movs	r2, #0
   37fee:	f7ec bb99 	b.w	24724 <clock_async_start>

00037ff2 <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
   37ff2:	4770      	bx	lr

00037ff4 <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
   37ff4:	f7ec be92 	b.w	24d1c <_DoInit>

00037ff8 <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(struct device *unused)
{
   37ff8:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
   37ffa:	f7ff fffb 	bl	37ff4 <SEGGER_RTT_Init>

	return 0;
}
   37ffe:	2000      	movs	r0, #0
   38000:	bd08      	pop	{r3, pc}

00038002 <z_irq_spurious>:
	z_arm_reserved();
   38002:	f7ec bf9d 	b.w	24f40 <z_arm_bus_fault>

00038006 <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   38006:	6d83      	ldr	r3, [r0, #88]	; 0x58
   38008:	f383 880b 	msr	PSPLIM, r3
}
   3800c:	4770      	bx	lr

0003800e <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   3800e:	4601      	mov	r1, r0
			reason = K_ERR_KERNEL_OOPS;
		}
	}

#endif /* CONFIG_USERSPACE */
	z_arm_fatal_error(reason, esf);
   38010:	6800      	ldr	r0, [r0, #0]
   38012:	f7ed b8ab 	b.w	2516c <z_arm_fatal_error>

00038016 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   38016:	b508      	push	{r3, lr}
	handler();
   38018:	f7ec ff9c 	bl	24f54 <z_SysNmiOnReset>
	z_arm_exc_exit();
}
   3801c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_exc_exit();
   38020:	f7ec bf02 	b.w	24e28 <z_arm_exc_exit>

00038024 <z_arm_configure_dynamic_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_dynamic_mpu_regions(struct k_thread *thread)
{
   38024:	b507      	push	{r0, r1, r2, lr}

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(
   38026:	2100      	movs	r1, #0
   38028:	a801      	add	r0, sp, #4
   3802a:	f7ed fecf 	bl	25dcc <arm_core_mpu_configure_dynamic_mpu_regions>
		(const struct k_mem_partition **)dynamic_regions,
		region_num);
}
   3802e:	b003      	add	sp, #12
   38030:	f85d fb04 	ldr.w	pc, [sp], #4

00038034 <mpu_configure_region>:
{
   38034:	b530      	push	{r4, r5, lr}
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
   38036:	684b      	ldr	r3, [r1, #4]
{
   38038:	b085      	sub	sp, #20
	region_conf.base = new_region->start;
   3803a:	680c      	ldr	r4, [r1, #0]
	p_attr->rbar = attr->rbar &
   3803c:	f89d 2008 	ldrb.w	r2, [sp, #8]
   38040:	890d      	ldrh	r5, [r1, #8]
   38042:	9400      	str	r4, [sp, #0]
	p_attr->mair_idx = attr->mair_idx;
   38044:	8949      	ldrh	r1, [r1, #10]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   38046:	f024 041f 	bic.w	r4, r4, #31
   3804a:	3b01      	subs	r3, #1
	p_attr->rbar = attr->rbar &
   3804c:	f365 0204 	bfi	r2, r5, #0, #5
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   38050:	4423      	add	r3, r4
	p_attr->mair_idx = attr->mair_idx;
   38052:	f361 1247 	bfi	r2, r1, #5, #3
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   38056:	f023 031f 	bic.w	r3, r3, #31
	return region_allocate_and_init(index,
   3805a:	4669      	mov	r1, sp
	p_attr->mair_idx = attr->mair_idx;
   3805c:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   38060:	9303      	str	r3, [sp, #12]
   38062:	f7ed fcd5 	bl	25a10 <region_allocate_and_init>
}
   38066:	b005      	add	sp, #20
   38068:	bd30      	pop	{r4, r5, pc}

0003806a <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   3806a:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(u32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
   3806e:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   38072:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
   38074:	bf08      	it	eq
   38076:	f06f 0015 	mvneq.w	r0, #21
   3807a:	4770      	bx	lr

0003807c <_stdout_hook_default>:
}
   3807c:	f04f 30ff 	mov.w	r0, #4294967295
   38080:	4770      	bx	lr

00038082 <_stdin_hook_default>:
}
   38082:	2000      	movs	r0, #0
   38084:	4770      	bx	lr

00038086 <_read>:
{
   38086:	4608      	mov	r0, r1
	return z_impl_zephyr_read_stdin(buf, nbytes);
   38088:	4611      	mov	r1, r2
   3808a:	f7ed bedb 	b.w	25e44 <z_impl_zephyr_read_stdin>

0003808e <_write>:
{
   3808e:	4608      	mov	r0, r1
	return z_impl_zephyr_write_stdout(buf, nbytes);
   38090:	4611      	mov	r1, r2
   38092:	f7ed beeb 	b.w	25e6c <z_impl_zephyr_write_stdout>

00038096 <_close>:
   38096:	f04f 30ff 	mov.w	r0, #4294967295
   3809a:	4770      	bx	lr

0003809c <_lseek>:
}
   3809c:	2000      	movs	r0, #0
   3809e:	4770      	bx	lr

000380a0 <_isatty>:
}
   380a0:	2001      	movs	r0, #1
   380a2:	4770      	bx	lr

000380a4 <_kill>:
}
   380a4:	2000      	movs	r0, #0
   380a6:	4770      	bx	lr

000380a8 <_getpid>:
}
   380a8:	2000      	movs	r0, #0
   380aa:	4770      	bx	lr

000380ac <_fstat>:
	st->st_mode = S_IFCHR;
   380ac:	f44f 5300 	mov.w	r3, #8192	; 0x2000
}
   380b0:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
   380b2:	604b      	str	r3, [r1, #4]
}
   380b4:	4770      	bx	lr

000380b6 <__errno>:
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
   380b6:	f7fa b95d 	b.w	32374 <z_impl_z_errno>

000380ba <net_init>:

	return status;
}

static int net_init(struct device *unused)
{
   380ba:	b508      	push	{r3, lr}
	net_if_init();
   380bc:	f7ed ff9e 	bl	25ffc <net_if_init>
	net_if_post_init();
   380c0:	f7ed ffb0 	bl	26024 <net_if_post_init>
	net_mgmt_event_init();

	init_rx_queues();

	return services_init();
}
   380c4:	2000      	movs	r0, #0
   380c6:	bd08      	pop	{r3, pc}

000380c8 <net_if_l2>:
	if (!iface || !iface->if_dev) {
   380c8:	b110      	cbz	r0, 380d0 <net_if_l2+0x8>
   380ca:	6800      	ldr	r0, [r0, #0]
   380cc:	b100      	cbz	r0, 380d0 <net_if_l2+0x8>
	return iface->if_dev->l2;
   380ce:	6840      	ldr	r0, [r0, #4]
}
   380d0:	4770      	bx	lr

000380d2 <l2_flags_get>:
{
   380d2:	b510      	push	{r4, lr}
   380d4:	4602      	mov	r2, r0
	if (net_if_l2(iface) && net_if_l2(iface)->get_flags) {
   380d6:	f7ff fff7 	bl	380c8 <net_if_l2>
   380da:	b128      	cbz	r0, 380e8 <l2_flags_get+0x16>
   380dc:	68c3      	ldr	r3, [r0, #12]
   380de:	b11b      	cbz	r3, 380e8 <l2_flags_get+0x16>
}
   380e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		flags = net_if_l2(iface)->get_flags(iface);
   380e4:	4610      	mov	r0, r2
   380e6:	4718      	bx	r3
}
   380e8:	2000      	movs	r0, #0
   380ea:	bd10      	pop	{r4, pc}

000380ec <net_byte_to_hex>:
{
   380ec:	b570      	push	{r4, r5, r6, lr}
	for (i = 0, val = (byte & 0xf0) >> 4; i < 2; i++, val = byte & 0x0f) {
   380ee:	090e      	lsrs	r6, r1, #4
		if (i == 0 && !pad && !val) {
   380f0:	b1b3      	cbz	r3, 38120 <net_byte_to_hex+0x34>
		if (val < 10) {
   380f2:	2e09      	cmp	r6, #9
			*ptr++ = (char) (val - 10 + base);
   380f4:	b274      	sxtb	r4, r6
   380f6:	bf86      	itte	hi
   380f8:	f1a2 030a 	subhi.w	r3, r2, #10
   380fc:	18e4      	addhi	r4, r4, r3
			*ptr++ = (char) (val + '0');
   380fe:	3430      	addls	r4, #48	; 0x30
   38100:	1c45      	adds	r5, r0, #1
   38102:	7004      	strb	r4, [r0, #0]
   38104:	f001 010f 	and.w	r1, r1, #15
		if (val < 10) {
   38108:	2909      	cmp	r1, #9
			*ptr++ = (char) (val - 10 + base);
   3810a:	b24b      	sxtb	r3, r1
   3810c:	bf83      	ittte	hi
   3810e:	3a0a      	subhi	r2, #10
   38110:	189b      	addhi	r3, r3, r2
   38112:	b2db      	uxtbhi	r3, r3
			*ptr++ = (char) (val + '0');
   38114:	3330      	addls	r3, #48	; 0x30
   38116:	702b      	strb	r3, [r5, #0]
	*ptr = '\0';
   38118:	2300      	movs	r3, #0
   3811a:	706b      	strb	r3, [r5, #1]
   3811c:	1c68      	adds	r0, r5, #1
}
   3811e:	bd70      	pop	{r4, r5, r6, pc}
		if (i == 0 && !pad && !val) {
   38120:	2e00      	cmp	r6, #0
   38122:	d1e6      	bne.n	380f2 <net_byte_to_hex+0x6>
   38124:	4605      	mov	r5, r0
   38126:	e7ed      	b.n	38104 <net_byte_to_hex+0x18>

00038128 <unpack_uint16>:
 */
static int unpack_uint16(struct buf_ctx *buf, u16_t *val)
{
	MQTT_TRC(">> cur:%p, end:%p", buf->cur, buf->end);

	if ((buf->end - buf->cur) < sizeof(u16_t)) {
   38128:	e9d0 2300 	ldrd	r2, r3, [r0]
   3812c:	1a9b      	subs	r3, r3, r2
   3812e:	2b01      	cmp	r3, #1
{
   38130:	b510      	push	{r4, lr}
	if ((buf->end - buf->cur) < sizeof(u16_t)) {
   38132:	d90c      	bls.n	3814e <unpack_uint16+0x26>
		return -EINVAL;
	}

	*val = *(buf->cur++) << 8; /* MSB */
   38134:	4614      	mov	r4, r2
   38136:	1c53      	adds	r3, r2, #1
   38138:	6003      	str	r3, [r0, #0]
   3813a:	f814 3b02 	ldrb.w	r3, [r4], #2
   3813e:	021b      	lsls	r3, r3, #8
   38140:	800b      	strh	r3, [r1, #0]
	*val |= *(buf->cur++); /* LSB */
   38142:	6004      	str	r4, [r0, #0]

	MQTT_TRC("<< val:%04x", *val);

	return 0;
   38144:	2000      	movs	r0, #0
	*val |= *(buf->cur++); /* LSB */
   38146:	7852      	ldrb	r2, [r2, #1]
   38148:	4313      	orrs	r3, r2
   3814a:	800b      	strh	r3, [r1, #0]
}
   3814c:	bd10      	pop	{r4, pc}
		return -EINVAL;
   3814e:	f06f 0015 	mvn.w	r0, #21
   38152:	e7fb      	b.n	3814c <unpack_uint16+0x24>

00038154 <packet_length_decode>:
int packet_length_decode(struct buf_ctx *buf, u32_t *length)
{
	u8_t shift = 0U;
	u8_t bytes = 0U;

	*length = 0U;
   38154:	2300      	movs	r3, #0
{
   38156:	b5f0      	push	{r4, r5, r6, r7, lr}
	do {
		if (bytes > MQTT_MAX_LENGTH_BYTES) {
			return -EINVAL;
		}

		if (buf->cur >= buf->end) {
   38158:	6847      	ldr	r7, [r0, #4]
	*length = 0U;
   3815a:	600b      	str	r3, [r1, #0]
		if (buf->cur >= buf->end) {
   3815c:	6804      	ldr	r4, [r0, #0]
   3815e:	42bc      	cmp	r4, r7
   38160:	d215      	bcs.n	3818e <packet_length_decode+0x3a>
			return -EAGAIN;
		}

		*length += ((u32_t)*(buf->cur) & MQTT_LENGTH_VALUE_MASK)
   38162:	4625      	mov	r5, r4
   38164:	f815 2b01 	ldrb.w	r2, [r5], #1
   38168:	680e      	ldr	r6, [r1, #0]
   3816a:	f002 027f 	and.w	r2, r2, #127	; 0x7f
								<< shift;
   3816e:	409a      	lsls	r2, r3
		*length += ((u32_t)*(buf->cur) & MQTT_LENGTH_VALUE_MASK)
   38170:	4432      	add	r2, r6
   38172:	600a      	str	r2, [r1, #0]
		shift += MQTT_LENGTH_SHIFT;
		bytes++;
	} while ((*(buf->cur++) & MQTT_LENGTH_CONTINUATION_BIT) != 0U);
   38174:	6005      	str	r5, [r0, #0]
   38176:	f994 2000 	ldrsb.w	r2, [r4]
   3817a:	2a00      	cmp	r2, #0
   3817c:	db01      	blt.n	38182 <packet_length_decode+0x2e>

	MQTT_TRC("length:0x%08x", *length);

	return 0;
   3817e:	2000      	movs	r0, #0
}
   38180:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (bytes > MQTT_MAX_LENGTH_BYTES) {
   38182:	3307      	adds	r3, #7
   38184:	2b23      	cmp	r3, #35	; 0x23
   38186:	d1e9      	bne.n	3815c <packet_length_decode+0x8>
			return -EINVAL;
   38188:	f06f 0015 	mvn.w	r0, #21
   3818c:	e7f8      	b.n	38180 <packet_length_decode+0x2c>
			return -EAGAIN;
   3818e:	f06f 000a 	mvn.w	r0, #10
   38192:	e7f5      	b.n	38180 <packet_length_decode+0x2c>

00038194 <fixed_header_decode>:

int fixed_header_decode(struct buf_ctx *buf, u8_t *type_and_flags,
			u32_t *length)
{
   38194:	b430      	push	{r4, r5}
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   38196:	e9d0 3500 	ldrd	r3, r5, [r0]
   3819a:	429d      	cmp	r5, r3
   3819c:	d007      	beq.n	381ae <fixed_header_decode+0x1a>
	*val = *(buf->cur++);
   3819e:	1c5d      	adds	r5, r3, #1
   381a0:	6005      	str	r5, [r0, #0]
   381a2:	781b      	ldrb	r3, [r3, #0]
   381a4:	700b      	strb	r3, [r1, #0]
	if (err_code != 0) {
		return err_code;
	}

	return packet_length_decode(buf, length);
}
   381a6:	bc30      	pop	{r4, r5}
	return packet_length_decode(buf, length);
   381a8:	4611      	mov	r1, r2
   381aa:	f7ff bfd3 	b.w	38154 <packet_length_decode>
}
   381ae:	f06f 0015 	mvn.w	r0, #21
   381b2:	bc30      	pop	{r4, r5}
   381b4:	4770      	bx	lr

000381b6 <connect_ack_decode>:

int connect_ack_decode(const struct mqtt_client *client, struct buf_ctx *buf,
		       struct mqtt_connack_param *param)
{
   381b6:	b530      	push	{r4, r5, lr}
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   381b8:	e9d1 3500 	ldrd	r3, r5, [r1]
   381bc:	429d      	cmp	r5, r3
   381be:	d102      	bne.n	381c6 <connect_ack_decode+0x10>
		return -EINVAL;
   381c0:	f06f 0015 	mvn.w	r0, #21
	}

	param->return_code = (enum mqtt_conn_return_code)ret_code;

	return 0;
}
   381c4:	bd30      	pop	{r4, r5, pc}
	*val = *(buf->cur++);
   381c6:	1c5c      	adds	r4, r3, #1
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   381c8:	42a5      	cmp	r5, r4
	*val = *(buf->cur++);
   381ca:	600c      	str	r4, [r1, #0]
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   381cc:	d0f8      	beq.n	381c0 <connect_ack_decode+0xa>
	*val = *(buf->cur++);
   381ce:	461d      	mov	r5, r3
   381d0:	f815 4b02 	ldrb.w	r4, [r5], #2
   381d4:	600d      	str	r5, [r1, #0]
	if (client->protocol_version == MQTT_VERSION_3_1_1) {
   381d6:	f890 1076 	ldrb.w	r1, [r0, #118]	; 0x76
	*val = *(buf->cur++);
   381da:	785b      	ldrb	r3, [r3, #1]
	if (client->protocol_version == MQTT_VERSION_3_1_1) {
   381dc:	2904      	cmp	r1, #4
			flags & MQTT_CONNACK_FLAG_SESSION_PRESENT;
   381de:	bf04      	itt	eq
   381e0:	f004 0401 	andeq.w	r4, r4, #1
		param->session_present_flag =
   381e4:	7014      	strbeq	r4, [r2, #0]
	param->return_code = (enum mqtt_conn_return_code)ret_code;
   381e6:	7053      	strb	r3, [r2, #1]
	return 0;
   381e8:	2000      	movs	r0, #0
   381ea:	e7eb      	b.n	381c4 <connect_ack_decode+0xe>

000381ec <publish_decode>:

int publish_decode(u8_t flags, u32_t var_length, struct buf_ctx *buf,
		   struct mqtt_publish_param *param)
{
   381ec:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   381f0:	461c      	mov	r4, r3
	int err_code;
	u32_t var_header_length;

	param->dup_flag = flags & MQTT_HEADER_DUP_MASK;
   381f2:	7d9b      	ldrb	r3, [r3, #22]
{
   381f4:	4688      	mov	r8, r1
	param->retain_flag = flags & MQTT_HEADER_RETAIN_MASK;
   381f6:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
   381fa:	f360 0341 	bfi	r3, r0, #1, #1
	param->message.topic.qos = ((flags & MQTT_HEADER_QOS_MASK) >> 1);
   381fe:	f3c0 0041 	ubfx	r0, r0, #1, #2
   38202:	7220      	strb	r0, [r4, #8]
	param->retain_flag = flags & MQTT_HEADER_RETAIN_MASK;
   38204:	75a3      	strb	r3, [r4, #22]
	err_code = unpack_uint16(buf, &utf8_strlen);
   38206:	f10d 0106 	add.w	r1, sp, #6
   3820a:	4610      	mov	r0, r2
{
   3820c:	4616      	mov	r6, r2
	err_code = unpack_uint16(buf, &utf8_strlen);
   3820e:	f7ff ff8b 	bl	38128 <unpack_uint16>
	if (err_code != 0) {
   38212:	4607      	mov	r7, r0
   38214:	b940      	cbnz	r0, 38228 <publish_decode+0x3c>
	if ((buf->end - buf->cur) < utf8_strlen) {
   38216:	6833      	ldr	r3, [r6, #0]
   38218:	6872      	ldr	r2, [r6, #4]
   3821a:	f8bd 5006 	ldrh.w	r5, [sp, #6]
   3821e:	1ad2      	subs	r2, r2, r3
   38220:	42aa      	cmp	r2, r5
   38222:	da05      	bge.n	38230 <publish_decode+0x44>
		return -EINVAL;
   38224:	f06f 0715 	mvn.w	r7, #21

	param->message.payload.data = NULL;
	param->message.payload.len = var_length - var_header_length;

	return 0;
}
   38228:	4638      	mov	r0, r7
   3822a:	b002      	add	sp, #8
   3822c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	str->size = utf8_strlen;
   38230:	6065      	str	r5, [r4, #4]
	if (utf8_strlen) {
   38232:	b15d      	cbz	r5, 3824c <publish_decode+0x60>
		str->utf8 = buf->cur;
   38234:	6023      	str	r3, [r4, #0]
		buf->cur += utf8_strlen;
   38236:	442b      	add	r3, r5
   38238:	6033      	str	r3, [r6, #0]
	if (param->message.topic.qos > MQTT_QOS_0_AT_MOST_ONCE) {
   3823a:	7a23      	ldrb	r3, [r4, #8]
   3823c:	b943      	cbnz	r3, 38250 <publish_decode+0x64>
	var_header_length = param->message.topic.topic.size + sizeof(u16_t);
   3823e:	3502      	adds	r5, #2
	param->message.payload.data = NULL;
   38240:	2300      	movs	r3, #0
	param->message.payload.len = var_length - var_header_length;
   38242:	eba8 0505 	sub.w	r5, r8, r5
	param->message.payload.data = NULL;
   38246:	60e3      	str	r3, [r4, #12]
	param->message.payload.len = var_length - var_header_length;
   38248:	6125      	str	r5, [r4, #16]
	return 0;
   3824a:	e7ed      	b.n	38228 <publish_decode+0x3c>
		str->utf8 = NULL;
   3824c:	6025      	str	r5, [r4, #0]
	if (err_code != 0) {
   3824e:	e7f4      	b.n	3823a <publish_decode+0x4e>
		err_code = unpack_uint16(buf, &param->message_id);
   38250:	f104 0114 	add.w	r1, r4, #20
   38254:	4630      	mov	r0, r6
   38256:	f7ff ff67 	bl	38128 <unpack_uint16>
		if (err_code != 0) {
   3825a:	b908      	cbnz	r0, 38260 <publish_decode+0x74>
		var_header_length += sizeof(u16_t);
   3825c:	3504      	adds	r5, #4
   3825e:	e7ef      	b.n	38240 <publish_decode+0x54>
   38260:	4607      	mov	r7, r0
   38262:	e7e1      	b.n	38228 <publish_decode+0x3c>

00038264 <publish_ack_decode>:

int publish_ack_decode(struct buf_ctx *buf, struct mqtt_puback_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   38264:	f7ff bf60 	b.w	38128 <unpack_uint16>

00038268 <publish_receive_decode>:
}

int publish_receive_decode(struct buf_ctx *buf, struct mqtt_pubrec_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   38268:	f7ff bf5e 	b.w	38128 <unpack_uint16>

0003826c <publish_release_decode>:
}

int publish_release_decode(struct buf_ctx *buf, struct mqtt_pubrel_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   3826c:	f7ff bf5c 	b.w	38128 <unpack_uint16>

00038270 <publish_complete_decode>:
}

int publish_complete_decode(struct buf_ctx *buf,
			    struct mqtt_pubcomp_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   38270:	f7ff bf5a 	b.w	38128 <unpack_uint16>

00038274 <subscribe_ack_decode>:
}

int subscribe_ack_decode(struct buf_ctx *buf, struct mqtt_suback_param *param)
{
   38274:	b538      	push	{r3, r4, r5, lr}
   38276:	4605      	mov	r5, r0
   38278:	460c      	mov	r4, r1
	int err_code;

	err_code = unpack_uint16(buf, &param->message_id);
   3827a:	f7ff ff55 	bl	38128 <unpack_uint16>
	if (err_code != 0) {
   3827e:	b930      	cbnz	r0, 3828e <subscribe_ack_decode+0x1a>
		return err_code;
	}

	return unpack_data(buf->end - buf->cur, buf, &param->return_codes);
   38280:	e9d5 2300 	ldrd	r2, r3, [r5]
   38284:	1a99      	subs	r1, r3, r2
	str->len = length;
   38286:	60a1      	str	r1, [r4, #8]
	if (length > 0) {
   38288:	b111      	cbz	r1, 38290 <subscribe_ack_decode+0x1c>
		str->data = buf->cur;
   3828a:	6062      	str	r2, [r4, #4]
		buf->cur += length;
   3828c:	602b      	str	r3, [r5, #0]
}
   3828e:	bd38      	pop	{r3, r4, r5, pc}
		str->data = NULL;
   38290:	6060      	str	r0, [r4, #4]
   38292:	e7fc      	b.n	3828e <subscribe_ack_decode+0x1a>

00038294 <unsubscribe_ack_decode>:

int unsubscribe_ack_decode(struct buf_ctx *buf,
			   struct mqtt_unsuback_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   38294:	f7ff bf48 	b.w	38128 <unpack_uint16>

00038298 <pack_uint16>:
	if ((buf->end - buf->cur) < sizeof(u16_t)) {
   38298:	e9d1 3200 	ldrd	r3, r2, [r1]
   3829c:	1ad2      	subs	r2, r2, r3
   3829e:	2a01      	cmp	r2, #1
   382a0:	d909      	bls.n	382b6 <pack_uint16+0x1e>
	*(buf->cur++) = (val >> 8) & 0xFF;
   382a2:	1c5a      	adds	r2, r3, #1
   382a4:	600a      	str	r2, [r1, #0]
   382a6:	0a02      	lsrs	r2, r0, #8
   382a8:	701a      	strb	r2, [r3, #0]
	*(buf->cur++) = val & 0xFF;
   382aa:	680b      	ldr	r3, [r1, #0]
   382ac:	1c5a      	adds	r2, r3, #1
   382ae:	600a      	str	r2, [r1, #0]
   382b0:	7018      	strb	r0, [r3, #0]
	return 0;
   382b2:	2000      	movs	r0, #0
   382b4:	4770      	bx	lr
		return -ENOMEM;
   382b6:	f06f 000b 	mvn.w	r0, #11
}
   382ba:	4770      	bx	lr

000382bc <pack_utf8_str>:
{
   382bc:	b538      	push	{r3, r4, r5, lr}
	if ((buf->end - buf->cur) < GET_UT8STR_BUFFER_SIZE(str)) {
   382be:	e9d1 2300 	ldrd	r2, r3, [r1]
{
   382c2:	4605      	mov	r5, r0
	if ((buf->end - buf->cur) < GET_UT8STR_BUFFER_SIZE(str)) {
   382c4:	6840      	ldr	r0, [r0, #4]
   382c6:	1a9b      	subs	r3, r3, r2
   382c8:	1c82      	adds	r2, r0, #2
   382ca:	4293      	cmp	r3, r2
{
   382cc:	460c      	mov	r4, r1
	if ((buf->end - buf->cur) < GET_UT8STR_BUFFER_SIZE(str)) {
   382ce:	d30d      	bcc.n	382ec <pack_utf8_str+0x30>
	(void)pack_uint16(str->size, buf);
   382d0:	b280      	uxth	r0, r0
   382d2:	f7ff ffe1 	bl	38298 <pack_uint16>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   382d6:	e9d5 1200 	ldrd	r1, r2, [r5]
   382da:	6820      	ldr	r0, [r4, #0]
   382dc:	f001 fd4f 	bl	39d7e <memcpy>
	return 0;
   382e0:	2000      	movs	r0, #0
	buf->cur += str->size;
   382e2:	6823      	ldr	r3, [r4, #0]
   382e4:	686a      	ldr	r2, [r5, #4]
   382e6:	4413      	add	r3, r2
   382e8:	6023      	str	r3, [r4, #0]
}
   382ea:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOMEM;
   382ec:	f06f 000b 	mvn.w	r0, #11
   382f0:	e7fb      	b.n	382ea <pack_utf8_str+0x2e>

000382f2 <mqtt_encode_fixed_header>:
{
   382f2:	b570      	push	{r4, r5, r6, lr}
	u32_t length = buf->cur - start;
   382f4:	6815      	ldr	r5, [r2, #0]
   382f6:	1a6d      	subs	r5, r5, r1
	if (length > MQTT_MAX_PAYLOAD_SIZE) {
   382f8:	f1b5 5f80 	cmp.w	r5, #268435456	; 0x10000000
   382fc:	d227      	bcs.n	3834e <mqtt_encode_fixed_header+0x5c>
   382fe:	462c      	mov	r4, r5
   38300:	2600      	movs	r6, #0
	} while (length > 0);
   38302:	09e4      	lsrs	r4, r4, #7
   38304:	b2f3      	uxtb	r3, r6
		if (buf != NULL) {
   38306:	f106 0601 	add.w	r6, r6, #1
	} while (length > 0);
   3830a:	d1fa      	bne.n	38302 <mqtt_encode_fixed_header+0x10>
	fixed_header_length += sizeof(u8_t);
   3830c:	3302      	adds	r3, #2
	buf->cur = start - fixed_header_length;
   3830e:	b2db      	uxtb	r3, r3
   38310:	425b      	negs	r3, r3
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   38312:	6856      	ldr	r6, [r2, #4]
	buf->cur = start - fixed_header_length;
   38314:	18cc      	adds	r4, r1, r3
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   38316:	42b4      	cmp	r4, r6
	buf->cur = start - fixed_header_length;
   38318:	6014      	str	r4, [r2, #0]
	*(buf->cur++) = val;
   3831a:	bf1e      	ittt	ne
   3831c:	3401      	addne	r4, #1
   3831e:	6014      	strne	r4, [r2, #0]
   38320:	54c8      	strbne	r0, [r1, r3]
	return 0;
   38322:	4628      	mov	r0, r5
			*(buf->cur) = length & MQTT_LENGTH_VALUE_MASK;
   38324:	6811      	ldr	r1, [r2, #0]
   38326:	f000 047f 	and.w	r4, r0, #127	; 0x7f
   3832a:	700c      	strb	r4, [r1, #0]
			if (length > 0) {
   3832c:	09c0      	lsrs	r0, r0, #7
				*(buf->cur) |= MQTT_LENGTH_CONTINUATION_BIT;
   3832e:	bf1f      	itttt	ne
   38330:	6814      	ldrne	r4, [r2, #0]
   38332:	7821      	ldrbne	r1, [r4, #0]
   38334:	f061 017f 	ornne	r1, r1, #127	; 0x7f
   38338:	7021      	strbne	r1, [r4, #0]
			buf->cur++;
   3833a:	6811      	ldr	r1, [r2, #0]
   3833c:	3101      	adds	r1, #1
   3833e:	6011      	str	r1, [r2, #0]
	} while (length > 0);
   38340:	2800      	cmp	r0, #0
   38342:	d1ef      	bne.n	38324 <mqtt_encode_fixed_header+0x32>
	buf->cur = buf->cur - fixed_header_length;
   38344:	440b      	add	r3, r1
	buf->end = buf->cur + length + fixed_header_length;
   38346:	4429      	add	r1, r5
	buf->cur = buf->cur - fixed_header_length;
   38348:	6013      	str	r3, [r2, #0]
	buf->end = buf->cur + length + fixed_header_length;
   3834a:	6051      	str	r1, [r2, #4]
}
   3834c:	bd70      	pop	{r4, r5, r6, pc}
		return -EMSGSIZE;
   3834e:	f06f 0079 	mvn.w	r0, #121	; 0x79
   38352:	e7fb      	b.n	3834c <mqtt_encode_fixed_header+0x5a>

00038354 <publish_encode>:
{
   38354:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   38358:	4607      	mov	r7, r0
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   3835a:	7d80      	ldrb	r0, [r0, #22]
   3835c:	7a3c      	ldrb	r4, [r7, #8]
{
   3835e:	460d      	mov	r5, r1
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   38360:	f000 0801 	and.w	r8, r0, #1
   38364:	f3c0 0940 	ubfx	r9, r0, #1, #1
	if ((param->message.topic.qos) && (param->message_id == 0U)) {
   38368:	b10c      	cbz	r4, 3836e <publish_encode+0x1a>
   3836a:	8abb      	ldrh	r3, [r7, #20]
   3836c:	b35b      	cbz	r3, 383c6 <publish_encode+0x72>
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   3836e:	682e      	ldr	r6, [r5, #0]
	err_code = pack_utf8_str(&param->message.topic.topic, buf);
   38370:	4629      	mov	r1, r5
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   38372:	3605      	adds	r6, #5
   38374:	602e      	str	r6, [r5, #0]
	err_code = pack_utf8_str(&param->message.topic.topic, buf);
   38376:	4638      	mov	r0, r7
   38378:	f7ff ffa0 	bl	382bc <pack_utf8_str>
	if (err_code != 0) {
   3837c:	b9a8      	cbnz	r0, 383aa <publish_encode+0x56>
	if (param->message.topic.qos) {
   3837e:	7a3b      	ldrb	r3, [r7, #8]
   38380:	b9ab      	cbnz	r3, 383ae <publish_encode+0x5a>
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   38382:	0060      	lsls	r0, r4, #1
   38384:	f000 0006 	and.w	r0, r0, #6
	buf->cur += param->message.payload.len;
   38388:	693a      	ldr	r2, [r7, #16]
   3838a:	682b      	ldr	r3, [r5, #0]
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   3838c:	ea40 0009 	orr.w	r0, r0, r9
   38390:	ea40 00c8 	orr.w	r0, r0, r8, lsl #3
	buf->cur += param->message.payload.len;
   38394:	4413      	add	r3, r2
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   38396:	f040 0030 	orr.w	r0, r0, #48	; 0x30
	buf->cur += param->message.payload.len;
   3839a:	602b      	str	r3, [r5, #0]
	err_code = mqtt_encode_fixed_header(message_type, start, buf);
   3839c:	462a      	mov	r2, r5
   3839e:	4631      	mov	r1, r6
   383a0:	f000 003f 	and.w	r0, r0, #63	; 0x3f
   383a4:	f7ff ffa5 	bl	382f2 <mqtt_encode_fixed_header>
	if (err_code != 0) {
   383a8:	b140      	cbz	r0, 383bc <publish_encode+0x68>
}
   383aa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		err_code = pack_uint16(param->message_id, buf);
   383ae:	4629      	mov	r1, r5
   383b0:	8ab8      	ldrh	r0, [r7, #20]
   383b2:	f7ff ff71 	bl	38298 <pack_uint16>
		if (err_code != 0) {
   383b6:	2800      	cmp	r0, #0
   383b8:	d0e3      	beq.n	38382 <publish_encode+0x2e>
   383ba:	e7f6      	b.n	383aa <publish_encode+0x56>
	buf->end -= param->message.payload.len;
   383bc:	686b      	ldr	r3, [r5, #4]
   383be:	693a      	ldr	r2, [r7, #16]
   383c0:	1a9b      	subs	r3, r3, r2
   383c2:	606b      	str	r3, [r5, #4]
	return 0;
   383c4:	e7f1      	b.n	383aa <publish_encode+0x56>
		return -EINVAL;
   383c6:	f06f 0015 	mvn.w	r0, #21
   383ca:	e7ee      	b.n	383aa <publish_encode+0x56>

000383cc <subscribe_encode>:
{
   383cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   383d0:	4607      	mov	r7, r0
	if (param->message_id == 0U) {
   383d2:	88c0      	ldrh	r0, [r0, #6]
{
   383d4:	460d      	mov	r5, r1
	if (param->message_id == 0U) {
   383d6:	b330      	cbz	r0, 38426 <subscribe_encode+0x5a>
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   383d8:	680e      	ldr	r6, [r1, #0]
   383da:	3605      	adds	r6, #5
   383dc:	600e      	str	r6, [r1, #0]
	err_code = pack_uint16(param->message_id, buf);
   383de:	f7ff ff5b 	bl	38298 <pack_uint16>
	if (err_code != 0) {
   383e2:	4604      	mov	r4, r0
   383e4:	bb08      	cbnz	r0, 3842a <subscribe_encode+0x5e>
   383e6:	f04f 090c 	mov.w	r9, #12
	for (i = 0; i < param->list_count; i++) {
   383ea:	88bb      	ldrh	r3, [r7, #4]
   383ec:	42a3      	cmp	r3, r4
   383ee:	dc06      	bgt.n	383fe <subscribe_encode+0x32>
	return mqtt_encode_fixed_header(message_type, start, buf);
   383f0:	462a      	mov	r2, r5
   383f2:	4631      	mov	r1, r6
}
   383f4:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return mqtt_encode_fixed_header(message_type, start, buf);
   383f8:	2082      	movs	r0, #130	; 0x82
   383fa:	f7ff bf7a 	b.w	382f2 <mqtt_encode_fixed_header>
		err_code = pack_utf8_str(&param->list[i].topic, buf);
   383fe:	fb09 f804 	mul.w	r8, r9, r4
   38402:	6838      	ldr	r0, [r7, #0]
   38404:	4629      	mov	r1, r5
   38406:	4440      	add	r0, r8
   38408:	f7ff ff58 	bl	382bc <pack_utf8_str>
		if (err_code != 0) {
   3840c:	b980      	cbnz	r0, 38430 <subscribe_encode+0x64>
		err_code = pack_uint8(param->list[i].qos, buf);
   3840e:	683b      	ldr	r3, [r7, #0]
   38410:	4443      	add	r3, r8
   38412:	7a1a      	ldrb	r2, [r3, #8]
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   38414:	e9d5 3100 	ldrd	r3, r1, [r5]
   38418:	4299      	cmp	r1, r3
   3841a:	d00b      	beq.n	38434 <subscribe_encode+0x68>
	*(buf->cur++) = val;
   3841c:	1c59      	adds	r1, r3, #1
   3841e:	6029      	str	r1, [r5, #0]
	for (i = 0; i < param->list_count; i++) {
   38420:	3401      	adds	r4, #1
	*(buf->cur++) = val;
   38422:	701a      	strb	r2, [r3, #0]
		if (err_code != 0) {
   38424:	e7e1      	b.n	383ea <subscribe_encode+0x1e>
		return -EINVAL;
   38426:	f06f 0415 	mvn.w	r4, #21
}
   3842a:	4620      	mov	r0, r4
   3842c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		err_code = pack_utf8_str(&param->list[i].topic, buf);
   38430:	4604      	mov	r4, r0
   38432:	e7fa      	b.n	3842a <subscribe_encode+0x5e>
		return -ENOMEM;
   38434:	f06f 040b 	mvn.w	r4, #11
   38438:	e7f7      	b.n	3842a <subscribe_encode+0x5e>

0003843a <mqtt_read_message_chunk>:
	return err_code;
}

static int mqtt_read_message_chunk(struct mqtt_client *client,
				   struct buf_ctx *buf, u32_t length)
{
   3843a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3843c:	460d      	mov	r5, r1
	int len;

	/* Calculate how much data we need to read from the transport,
	 * given the already buffered data.
	 */
	remaining = length - (buf->end - buf->cur);
   3843e:	e9d1 4100 	ldrd	r4, r1, [r1]
   38442:	1b0c      	subs	r4, r1, r4
   38444:	1b14      	subs	r4, r2, r4
	if (remaining <= 0) {
   38446:	2c00      	cmp	r4, #0
{
   38448:	4606      	mov	r6, r0
	if (remaining <= 0) {
   3844a:	dd14      	ble.n	38476 <mqtt_read_message_chunk+0x3c>
		return 0;
	}

	/* Check if read does not exceed the buffer. */
	if (buf->end + remaining > client->rx_buf + client->rx_buf_size) {
   3844c:	e9d0 3719 	ldrd	r3, r7, [r0, #100]	; 0x64
   38450:	190a      	adds	r2, r1, r4
   38452:	443b      	add	r3, r7
   38454:	429a      	cmp	r2, r3
   38456:	d810      	bhi.n	3847a <mqtt_read_message_chunk+0x40>
		MQTT_ERR("[CID %p]: Buffer too small to receive the message",
			 client);
		return -ENOMEM;
	}

	len = mqtt_transport_read(client, buf->end, remaining, false);
   38458:	2300      	movs	r3, #0
   3845a:	4622      	mov	r2, r4
   3845c:	f7ee f8a8 	bl	265b0 <mqtt_transport_read>
	if (len < 0) {
   38460:	2800      	cmp	r0, #0
   38462:	db09      	blt.n	38478 <mqtt_read_message_chunk+0x3e>
		MQTT_TRC("[CID %p]: Transport read error: %d", client, len);
		return len;
	}

	if (len == 0) {
   38464:	d00c      	beq.n	38480 <mqtt_read_message_chunk+0x46>
		MQTT_TRC("[CID %p]: Connection closed.", client);
		return -ENOTCONN;
	}

	client->internal.rx_buf_datalen += len;
   38466:	69f3      	ldr	r3, [r6, #28]
	buf->end += len;

	if (len < remaining) {
   38468:	4284      	cmp	r4, r0
	client->internal.rx_buf_datalen += len;
   3846a:	4403      	add	r3, r0
   3846c:	61f3      	str	r3, [r6, #28]
	buf->end += len;
   3846e:	686b      	ldr	r3, [r5, #4]
   38470:	4403      	add	r3, r0
   38472:	606b      	str	r3, [r5, #4]
	if (len < remaining) {
   38474:	dc07      	bgt.n	38486 <mqtt_read_message_chunk+0x4c>
		MQTT_TRC("[CID %p]: Message partially received.", client);
		return -EAGAIN;
	}

	return 0;
   38476:	2000      	movs	r0, #0
}
   38478:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ENOMEM;
   3847a:	f06f 000b 	mvn.w	r0, #11
   3847e:	e7fb      	b.n	38478 <mqtt_read_message_chunk+0x3e>
		return -ENOTCONN;
   38480:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   38484:	e7f8      	b.n	38478 <mqtt_read_message_chunk+0x3e>
		return -EAGAIN;
   38486:	f06f 000a 	mvn.w	r0, #10
   3848a:	e7f5      	b.n	38478 <mqtt_read_message_chunk+0x3e>

0003848c <mqtt_handle_rx>:

	return err_code;
}

int mqtt_handle_rx(struct mqtt_client *client)
{
   3848c:	b570      	push	{r4, r5, r6, lr}
	int err_code;
	u8_t type_and_flags;
	u32_t var_length;
	struct buf_ctx buf;

	buf.cur = client->rx_buf;
   3848e:	6e43      	ldr	r3, [r0, #100]	; 0x64
	buf.end = client->rx_buf + client->internal.rx_buf_datalen;
   38490:	69c2      	ldr	r2, [r0, #28]
{
   38492:	b08c      	sub	sp, #48	; 0x30
	buf.cur = client->rx_buf;
   38494:	9302      	str	r3, [sp, #8]
{
   38496:	4605      	mov	r5, r0
	buf.end = client->rx_buf + client->internal.rx_buf_datalen;
   38498:	4413      	add	r3, r2
	u8_t chunk_size = MQTT_FIXED_HEADER_MIN_SIZE;
   3849a:	2202      	movs	r2, #2
	buf.end = client->rx_buf + client->internal.rx_buf_datalen;
   3849c:	9303      	str	r3, [sp, #12]
		err_code = mqtt_read_message_chunk(client, buf, chunk_size);
   3849e:	a902      	add	r1, sp, #8
   384a0:	4628      	mov	r0, r5
   384a2:	f7ff ffca 	bl	3843a <mqtt_read_message_chunk>
		if (err_code < 0) {
   384a6:	1e04      	subs	r4, r0, #0
   384a8:	db2b      	blt.n	38502 <mqtt_handle_rx+0x76>
		buf->cur = client->rx_buf;
   384aa:	6e6b      	ldr	r3, [r5, #100]	; 0x64
		err_code = fixed_header_decode(buf, type_and_flags, var_length);
   384ac:	aa01      	add	r2, sp, #4
   384ae:	f10d 0103 	add.w	r1, sp, #3
   384b2:	a802      	add	r0, sp, #8
		buf->cur = client->rx_buf;
   384b4:	9302      	str	r3, [sp, #8]
		err_code = fixed_header_decode(buf, type_and_flags, var_length);
   384b6:	f7ff fe6d 	bl	38194 <fixed_header_decode>
	} while (err_code == -EAGAIN);
   384ba:	f110 0f0b 	cmn.w	r0, #11
		err_code = fixed_header_decode(buf, type_and_flags, var_length);
   384be:	4604      	mov	r4, r0
		chunk_size = 1U;
   384c0:	f04f 0201 	mov.w	r2, #1
	} while (err_code == -EAGAIN);
   384c4:	d0eb      	beq.n	3849e <mqtt_handle_rx+0x12>

	err_code = mqtt_read_and_parse_fixed_header(client, &type_and_flags,
						    &var_length, &buf);
	if (err_code < 0) {
   384c6:	2800      	cmp	r0, #0
   384c8:	db1f      	blt.n	3850a <mqtt_handle_rx+0x7e>
		return (err_code == -EAGAIN) ? 0 : err_code;
	}

	if ((type_and_flags & 0xF0) == MQTT_PKT_TYPE_PUBLISH) {
   384ca:	f89d 6003 	ldrb.w	r6, [sp, #3]
   384ce:	f006 03f0 	and.w	r3, r6, #240	; 0xf0
   384d2:	2b30      	cmp	r3, #48	; 0x30
   384d4:	d11c      	bne.n	38510 <mqtt_handle_rx+0x84>
	err_code = mqtt_read_message_chunk(client, buf, sizeof(u16_t));
   384d6:	2202      	movs	r2, #2
   384d8:	a902      	add	r1, sp, #8
   384da:	4628      	mov	r0, r5
   384dc:	f7ff ffad 	bl	3843a <mqtt_read_message_chunk>
	if (err_code < 0) {
   384e0:	1e04      	subs	r4, r0, #0
   384e2:	db0e      	blt.n	38502 <mqtt_handle_rx+0x76>
	variable_header_length = *buf->cur << 8; /* MSB */
   384e4:	9b02      	ldr	r3, [sp, #8]
	if (qos > MQTT_QOS_0_AT_MOST_ONCE) {
   384e6:	f016 0f06 	tst.w	r6, #6
   384ea:	881a      	ldrh	r2, [r3, #0]
   384ec:	ba52      	rev16	r2, r2
   384ee:	b292      	uxth	r2, r2
	variable_header_length += sizeof(u16_t);
   384f0:	bf0c      	ite	eq
   384f2:	3202      	addeq	r2, #2
		variable_header_length += sizeof(u16_t);
   384f4:	3204      	addne	r2, #4
		err_code = mqtt_read_publish_var_header(client, type_and_flags,
							&buf);
	} else {
		err_code = mqtt_read_message_chunk(client, &buf, var_length);
   384f6:	a902      	add	r1, sp, #8
   384f8:	4628      	mov	r0, r5
   384fa:	f7ff ff9e 	bl	3843a <mqtt_read_message_chunk>
	}

	if (err_code < 0) {
   384fe:	1e04      	subs	r4, r0, #0
   38500:	da08      	bge.n	38514 <mqtt_handle_rx+0x88>
		return (err_code == -EAGAIN) ? 0 : err_code;
   38502:	f114 0f0b 	cmn.w	r4, #11
   38506:	d100      	bne.n	3850a <mqtt_handle_rx+0x7e>
   38508:	2400      	movs	r4, #0
	}

	client->internal.rx_buf_datalen = 0U;

	return 0;
}
   3850a:	4620      	mov	r0, r4
   3850c:	b00c      	add	sp, #48	; 0x30
   3850e:	bd70      	pop	{r4, r5, r6, pc}
		err_code = mqtt_read_message_chunk(client, &buf, var_length);
   38510:	9a01      	ldr	r2, [sp, #4]
   38512:	e7f0      	b.n	384f6 <mqtt_handle_rx+0x6a>
	evt.result = 0;
   38514:	2200      	movs	r2, #0
	err_code = mqtt_handle_packet(client, type_and_flags, var_length, &buf);
   38516:	f89d 0003 	ldrb.w	r0, [sp, #3]
   3851a:	9901      	ldr	r1, [sp, #4]
	evt.result = 0;
   3851c:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
	switch (type_and_flags & 0xF0) {
   38520:	2b60      	cmp	r3, #96	; 0x60
	evt.result = 0;
   38522:	920b      	str	r2, [sp, #44]	; 0x2c
	switch (type_and_flags & 0xF0) {
   38524:	d05e      	beq.n	385e4 <mqtt_handle_rx+0x158>
   38526:	d813      	bhi.n	38550 <mqtt_handle_rx+0xc4>
   38528:	2b30      	cmp	r3, #48	; 0x30
   3852a:	d045      	beq.n	385b8 <mqtt_handle_rx+0x12c>
   3852c:	d804      	bhi.n	38538 <mqtt_handle_rx+0xac>
   3852e:	2b20      	cmp	r3, #32
   38530:	d02a      	beq.n	38588 <mqtt_handle_rx+0xfc>
	client->internal.rx_buf_datalen = 0U;
   38532:	2400      	movs	r4, #0
   38534:	61ec      	str	r4, [r5, #28]
	return 0;
   38536:	e7e8      	b.n	3850a <mqtt_handle_rx+0x7e>
	switch (type_and_flags & 0xF0) {
   38538:	2b40      	cmp	r3, #64	; 0x40
   3853a:	d049      	beq.n	385d0 <mqtt_handle_rx+0x144>
   3853c:	2b50      	cmp	r3, #80	; 0x50
   3853e:	d1f8      	bne.n	38532 <mqtt_handle_rx+0xa6>
		evt.type = MQTT_EVT_PUBREC;
   38540:	2304      	movs	r3, #4
		err_code = publish_receive_decode(buf, &evt.param.pubrec);
   38542:	a905      	add	r1, sp, #20
   38544:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBREC;
   38546:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_receive_decode(buf, &evt.param.pubrec);
   3854a:	f7ff fe8d 	bl	38268 <publish_receive_decode>
   3854e:	e046      	b.n	385de <mqtt_handle_rx+0x152>
	switch (type_and_flags & 0xF0) {
   38550:	2b90      	cmp	r3, #144	; 0x90
   38552:	d04f      	beq.n	385f4 <mqtt_handle_rx+0x168>
   38554:	d809      	bhi.n	3856a <mqtt_handle_rx+0xde>
   38556:	2b70      	cmp	r3, #112	; 0x70
   38558:	d1eb      	bne.n	38532 <mqtt_handle_rx+0xa6>
		evt.type = MQTT_EVT_PUBCOMP;
   3855a:	2306      	movs	r3, #6
		err_code = publish_complete_decode(buf, &evt.param.pubcomp);
   3855c:	a905      	add	r1, sp, #20
   3855e:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBCOMP;
   38560:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_complete_decode(buf, &evt.param.pubcomp);
   38564:	f7ff fe84 	bl	38270 <publish_complete_decode>
   38568:	e039      	b.n	385de <mqtt_handle_rx+0x152>
	switch (type_and_flags & 0xF0) {
   3856a:	2bb0      	cmp	r3, #176	; 0xb0
   3856c:	d04a      	beq.n	38604 <mqtt_handle_rx+0x178>
   3856e:	2bd0      	cmp	r3, #208	; 0xd0
   38570:	d1df      	bne.n	38532 <mqtt_handle_rx+0xa6>
		if (client->unacked_ping <= 0) {
   38572:	f995 3077 	ldrsb.w	r3, [r5, #119]	; 0x77
   38576:	2b00      	cmp	r3, #0
			client->unacked_ping--;
   38578:	bfca      	itet	gt
   3857a:	f103 33ff 	addgt.w	r3, r3, #4294967295
			client->unacked_ping = 0;
   3857e:	f885 2077 	strble.w	r2, [r5, #119]	; 0x77
			client->unacked_ping--;
   38582:	f885 3077 	strbgt.w	r3, [r5, #119]	; 0x77
	if (err_code < 0) {
   38586:	e7d4      	b.n	38532 <mqtt_handle_rx+0xa6>
		evt.type = MQTT_EVT_CONNACK;
   38588:	f88d 2010 	strb.w	r2, [sp, #16]
		err_code = connect_ack_decode(client, buf, &evt.param.connack);
   3858c:	a902      	add	r1, sp, #8
   3858e:	aa05      	add	r2, sp, #20
   38590:	4628      	mov	r0, r5
   38592:	f7ff fe10 	bl	381b6 <connect_ack_decode>
		if (err_code == 0) {
   38596:	4604      	mov	r4, r0
   38598:	bb10      	cbnz	r0, 385e0 <mqtt_handle_rx+0x154>
			if (evt.param.connack.return_code ==
   3859a:	f89d 2015 	ldrb.w	r2, [sp, #21]
   3859e:	b91a      	cbnz	r2, 385a8 <mqtt_handle_rx+0x11c>
				MQTT_SET_STATE(client, MQTT_STATE_CONNECTED);
   385a0:	69ab      	ldr	r3, [r5, #24]
   385a2:	f043 0304 	orr.w	r3, r3, #4
   385a6:	61ab      	str	r3, [r5, #24]
			evt.result = evt.param.connack.return_code;
   385a8:	920b      	str	r2, [sp, #44]	; 0x2c
		event_notify(client, &evt);
   385aa:	a904      	add	r1, sp, #16
   385ac:	4628      	mov	r0, r5
   385ae:	f000 f84d 	bl	3864c <event_notify>
	if (err_code < 0) {
   385b2:	2c00      	cmp	r4, #0
   385b4:	dabd      	bge.n	38532 <mqtt_handle_rx+0xa6>
   385b6:	e7a8      	b.n	3850a <mqtt_handle_rx+0x7e>
		evt.type = MQTT_EVT_PUBLISH;
   385b8:	2302      	movs	r3, #2
		err_code = publish_decode(type_and_flags, var_length, buf,
   385ba:	aa02      	add	r2, sp, #8
		evt.type = MQTT_EVT_PUBLISH;
   385bc:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_decode(type_and_flags, var_length, buf,
   385c0:	ab05      	add	r3, sp, #20
   385c2:	f7ff fe13 	bl	381ec <publish_decode>
		client->internal.remaining_payload =
   385c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
		err_code = publish_decode(type_and_flags, var_length, buf,
   385c8:	4604      	mov	r4, r0
		evt.result = err_code;
   385ca:	900b      	str	r0, [sp, #44]	; 0x2c
		client->internal.remaining_payload =
   385cc:	622b      	str	r3, [r5, #32]
	if (notify_event == true) {
   385ce:	e7ec      	b.n	385aa <mqtt_handle_rx+0x11e>
		evt.type = MQTT_EVT_PUBACK;
   385d0:	2303      	movs	r3, #3
		err_code = publish_ack_decode(buf, &evt.param.puback);
   385d2:	a905      	add	r1, sp, #20
   385d4:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBACK;
   385d6:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_ack_decode(buf, &evt.param.puback);
   385da:	f7ff fe43 	bl	38264 <publish_ack_decode>
		err_code = unsubscribe_ack_decode(buf, &evt.param.unsuback);
   385de:	4604      	mov	r4, r0
		evt.result = err_code;
   385e0:	940b      	str	r4, [sp, #44]	; 0x2c
	if (notify_event == true) {
   385e2:	e7e2      	b.n	385aa <mqtt_handle_rx+0x11e>
		evt.type = MQTT_EVT_PUBREL;
   385e4:	2305      	movs	r3, #5
		err_code = publish_release_decode(buf, &evt.param.pubrel);
   385e6:	a905      	add	r1, sp, #20
   385e8:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBREL;
   385ea:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_release_decode(buf, &evt.param.pubrel);
   385ee:	f7ff fe3d 	bl	3826c <publish_release_decode>
   385f2:	e7f4      	b.n	385de <mqtt_handle_rx+0x152>
		evt.type = MQTT_EVT_SUBACK;
   385f4:	2307      	movs	r3, #7
		err_code = subscribe_ack_decode(buf, &evt.param.suback);
   385f6:	a905      	add	r1, sp, #20
   385f8:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_SUBACK;
   385fa:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = subscribe_ack_decode(buf, &evt.param.suback);
   385fe:	f7ff fe39 	bl	38274 <subscribe_ack_decode>
   38602:	e7ec      	b.n	385de <mqtt_handle_rx+0x152>
		evt.type = MQTT_EVT_UNSUBACK;
   38604:	2308      	movs	r3, #8
		err_code = unsubscribe_ack_decode(buf, &evt.param.unsuback);
   38606:	a905      	add	r1, sp, #20
   38608:	eb0d 0003 	add.w	r0, sp, r3
		evt.type = MQTT_EVT_UNSUBACK;
   3860c:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = unsubscribe_ack_decode(buf, &evt.param.unsuback);
   38610:	f7ff fe40 	bl	38294 <unsubscribe_ack_decode>
   38614:	e7e3      	b.n	385de <mqtt_handle_rx+0x152>

00038616 <mqtt_client_tcp_disconnect>:

int mqtt_client_tcp_disconnect(struct mqtt_client *client)
{
   38616:	b508      	push	{r3, lr}
	int ret;

	MQTT_TRC("Closing socket %d", client->transport.tcp.sock);

	ret = close(client->transport.tcp.sock);
   38618:	6a80      	ldr	r0, [r0, #40]	; 0x28
   3861a:	f7ed fe95 	bl	26348 <close>
	if (ret < 0) {
   3861e:	2800      	cmp	r0, #0
   38620:	da04      	bge.n	3862c <mqtt_client_tcp_disconnect+0x16>
		return -errno;
   38622:	f7ff fd48 	bl	380b6 <__errno>
   38626:	6800      	ldr	r0, [r0, #0]
   38628:	4240      	negs	r0, r0
	}

	return 0;
}
   3862a:	bd08      	pop	{r3, pc}
	return 0;
   3862c:	2000      	movs	r0, #0
   3862e:	e7fc      	b.n	3862a <mqtt_client_tcp_disconnect+0x14>

00038630 <tx_buf_init>:
	client->internal.remaining_payload = 0U;
}

/** @brief Initialize tx buffer. */
static void tx_buf_init(struct mqtt_client *client, struct buf_ctx *buf)
{
   38630:	b538      	push	{r3, r4, r5, lr}
   38632:	4604      	mov	r4, r0
   38634:	460d      	mov	r5, r1
__ssp_bos_icheck3(memset, void *, int)
   38636:	6f02      	ldr	r2, [r0, #112]	; 0x70
   38638:	2100      	movs	r1, #0
   3863a:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
   3863c:	f001 fbbf 	bl	39dbe <memset>
	memset(client->tx_buf, 0, client->tx_buf_size);
	buf->cur = client->tx_buf;
   38640:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
	buf->end = client->tx_buf + client->tx_buf_size;
   38642:	6f22      	ldr	r2, [r4, #112]	; 0x70
	buf->cur = client->tx_buf;
   38644:	602b      	str	r3, [r5, #0]
	buf->end = client->tx_buf + client->tx_buf_size;
   38646:	4413      	add	r3, r2
   38648:	606b      	str	r3, [r5, #4]
}
   3864a:	bd38      	pop	{r3, r4, r5, pc}

0003864c <event_notify>:
	/* Reset internal state. */
	client_reset(client);
}

void event_notify(struct mqtt_client *client, const struct mqtt_evt *evt)
{
   3864c:	b538      	push	{r3, r4, r5, lr}
	if (client->evt_cb != NULL) {
   3864e:	6e03      	ldr	r3, [r0, #96]	; 0x60
{
   38650:	4604      	mov	r4, r0
   38652:	460d      	mov	r5, r1
	if (client->evt_cb != NULL) {
   38654:	b153      	cbz	r3, 3866c <event_notify+0x20>
		mqtt_mutex_unlock(client);
   38656:	f7ed ffc1 	bl	265dc <mqtt_mutex_unlock>

		client->evt_cb(client, evt);
   3865a:	4620      	mov	r0, r4
   3865c:	6e23      	ldr	r3, [r4, #96]	; 0x60
   3865e:	4629      	mov	r1, r5
   38660:	4798      	blx	r3

		mqtt_mutex_lock(client);
   38662:	4620      	mov	r0, r4
	}
}
   38664:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		mqtt_mutex_lock(client);
   38668:	f7ed bfe4 	b.w	26634 <mqtt_mutex_lock>
}
   3866c:	bd38      	pop	{r3, r4, r5, pc}

0003866e <client_disconnect>:

static void client_disconnect(struct mqtt_client *client, int result)
{
   3866e:	b530      	push	{r4, r5, lr}
   38670:	4604      	mov	r4, r0
   38672:	b089      	sub	sp, #36	; 0x24
   38674:	460d      	mov	r5, r1
	int err_code;

	err_code = mqtt_transport_disconnect(client);
   38676:	f7ed ffa7 	bl	265c8 <mqtt_transport_disconnect>
	if (MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   3867a:	69a3      	ldr	r3, [r4, #24]
	event_notify(client, &evt);
   3867c:	4669      	mov	r1, sp
	if (MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   3867e:	f013 0304 	ands.w	r3, r3, #4
		evt.type = MQTT_EVT_DISCONNECT;
   38682:	bf12      	itee	ne
   38684:	2301      	movne	r3, #1
		evt.type = MQTT_EVT_CONNACK;
   38686:	f88d 3000 	strbeq.w	r3, [sp]
		evt.result = -ECONNREFUSED;
   3868a:	f06f 036e 	mvneq.w	r3, #110	; 0x6e
	event_notify(client, &evt);
   3868e:	4620      	mov	r0, r4
		evt.type = MQTT_EVT_DISCONNECT;
   38690:	bf16      	itet	ne
   38692:	f88d 3000 	strbne.w	r3, [sp]
		evt.result = -ECONNREFUSED;
   38696:	9307      	streq	r3, [sp, #28]
		evt.result = result;
   38698:	9507      	strne	r5, [sp, #28]
	event_notify(client, &evt);
   3869a:	f7ff ffd7 	bl	3864c <event_notify>
	MQTT_STATE_INIT(client);
   3869e:	2300      	movs	r3, #0
	client->internal.last_activity = 0U;
   386a0:	e9c4 3305 	strd	r3, r3, [r4, #20]
	client->internal.remaining_payload = 0U;
   386a4:	e9c4 3307 	strd	r3, r3, [r4, #28]
	if (err_code < 0) {
		MQTT_ERR("Failed to disconnect transport!");
	}

	disconnect_event_notify(client, result);
}
   386a8:	b009      	add	sp, #36	; 0x24
   386aa:	bd30      	pop	{r4, r5, pc}

000386ac <client_write>:
	return err_code;
}

static int client_write(struct mqtt_client *client, const u8_t *data,
			u32_t datalen)
{
   386ac:	b538      	push	{r3, r4, r5, lr}
   386ae:	4605      	mov	r5, r0
	int err_code;

	MQTT_TRC("[%p]: Transport writing %d bytes.", client, datalen);

	err_code = mqtt_transport_write(client, data, datalen);
   386b0:	f7ed ff72 	bl	26598 <mqtt_transport_write>
	if (err_code < 0) {
   386b4:	1e04      	subs	r4, r0, #0
   386b6:	da05      	bge.n	386c4 <client_write+0x18>
		MQTT_TRC("TCP write failed, errno = %d, "
			 "closing connection", errno);
		client_disconnect(client, err_code);
   386b8:	4621      	mov	r1, r4
   386ba:	4628      	mov	r0, r5
   386bc:	f7ff ffd7 	bl	3866e <client_disconnect>

	MQTT_TRC("[%p]: Transport write complete.", client);
	client->internal.last_activity = mqtt_sys_tick_in_ms_get();

	return 0;
}
   386c0:	4620      	mov	r0, r4
   386c2:	bd38      	pop	{r3, r4, r5, pc}
	return z_impl_k_uptime_get();
   386c4:	f001 faa2 	bl	39c0c <z_impl_k_uptime_get>
	return 0;
   386c8:	2400      	movs	r4, #0
	return (u32_t)k_uptime_get();
   386ca:	6168      	str	r0, [r5, #20]
   386cc:	e7f8      	b.n	386c0 <client_write+0x14>

000386ce <read_publish_payload>:
	return err_code;
}

static int read_publish_payload(struct mqtt_client *client, void *buffer,
				size_t length, bool shall_block)
{
   386ce:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   386d2:	460f      	mov	r7, r1
   386d4:	4690      	mov	r8, r2
   386d6:	461e      	mov	r6, r3
	int ret;

	NULL_PARAM_CHECK(client);
   386d8:	4605      	mov	r5, r0
   386da:	b320      	cbz	r0, 38726 <read_publish_payload+0x58>

	mqtt_mutex_lock(client);
   386dc:	f7ed ffaa 	bl	26634 <mqtt_mutex_lock>

	if (client->internal.remaining_payload == 0U) {
   386e0:	6a2c      	ldr	r4, [r5, #32]
   386e2:	b1b4      	cbz	r4, 38712 <read_publish_payload+0x44>

	if (client->internal.remaining_payload < length) {
		length = client->internal.remaining_payload;
	}

	ret = mqtt_transport_read(client, buffer, length, shall_block);
   386e4:	4544      	cmp	r4, r8
   386e6:	4622      	mov	r2, r4
   386e8:	4633      	mov	r3, r6
   386ea:	bf28      	it	cs
   386ec:	4642      	movcs	r2, r8
   386ee:	4639      	mov	r1, r7
   386f0:	4628      	mov	r0, r5
   386f2:	f7ed ff5d 	bl	265b0 <mqtt_transport_read>
   386f6:	4604      	mov	r4, r0
	if (!shall_block && ret == -EAGAIN) {
   386f8:	b916      	cbnz	r6, 38700 <read_publish_payload+0x32>
   386fa:	f110 0f0b 	cmn.w	r0, #11
   386fe:	d008      	beq.n	38712 <read_publish_payload+0x44>
		goto exit;
	}

	if (ret <= 0) {
   38700:	2c00      	cmp	r4, #0
   38702:	dc0c      	bgt.n	3871e <read_publish_payload+0x50>
		if (ret == 0) {
			ret = -ENOTCONN;
   38704:	bf08      	it	eq
   38706:	f06f 047f 	mvneq.w	r4, #127	; 0x7f
		}

		client_disconnect(client, ret);
   3870a:	4628      	mov	r0, r5
   3870c:	4621      	mov	r1, r4
   3870e:	f7ff ffae 	bl	3866e <client_disconnect>
	}

	client->internal.remaining_payload -= ret;

exit:
	mqtt_mutex_unlock(client);
   38712:	4628      	mov	r0, r5
   38714:	f7ed ff62 	bl	265dc <mqtt_mutex_unlock>

	return ret;
}
   38718:	4620      	mov	r0, r4
   3871a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	client->internal.remaining_payload -= ret;
   3871e:	6a2b      	ldr	r3, [r5, #32]
   38720:	1b1b      	subs	r3, r3, r4
   38722:	622b      	str	r3, [r5, #32]
   38724:	e7f5      	b.n	38712 <read_publish_payload+0x44>
	NULL_PARAM_CHECK(client);
   38726:	f06f 0415 	mvn.w	r4, #21
   3872a:	e7f5      	b.n	38718 <read_publish_payload+0x4a>

0003872c <mqtt_client_init>:
{
   3872c:	b510      	push	{r4, lr}
	NULL_PARAM_CHECK_VOID(client);
   3872e:	4604      	mov	r4, r0
   38730:	b1a0      	cbz	r0, 3875c <mqtt_client_init+0x30>
   38732:	227c      	movs	r2, #124	; 0x7c
   38734:	2100      	movs	r1, #0
   38736:	f001 fb42 	bl	39dbe <memset>
	MQTT_STATE_INIT(client);
   3873a:	2300      	movs	r3, #0
   3873c:	61a3      	str	r3, [r4, #24]
	return z_impl_k_mutex_init(mutex);
   3873e:	4620      	mov	r0, r4
   38740:	f001 f96c 	bl	39a1c <z_impl_k_mutex_init>
	client->protocol_version = MQTT_VERSION_3_1_1;
   38744:	2304      	movs	r3, #4
   38746:	f884 3076 	strb.w	r3, [r4, #118]	; 0x76
	client->clean_session = 1U;
   3874a:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
   3874e:	f043 0302 	orr.w	r3, r3, #2
   38752:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
	client->keepalive = MQTT_KEEPALIVE;
   38756:	233c      	movs	r3, #60	; 0x3c
   38758:	f8a4 3074 	strh.w	r3, [r4, #116]	; 0x74
}
   3875c:	bd10      	pop	{r4, pc}

0003875e <mqtt_connect>:
{
   3875e:	b537      	push	{r0, r1, r2, r4, r5, lr}
	NULL_PARAM_CHECK(client);
   38760:	4604      	mov	r4, r0
   38762:	2800      	cmp	r0, #0
   38764:	d03c      	beq.n	387e0 <mqtt_connect+0x82>
	NULL_PARAM_CHECK(client->client_id.utf8);
   38766:	6c43      	ldr	r3, [r0, #68]	; 0x44
   38768:	2b00      	cmp	r3, #0
   3876a:	d039      	beq.n	387e0 <mqtt_connect+0x82>
	mqtt_mutex_lock(client);
   3876c:	f7ed ff62 	bl	26634 <mqtt_mutex_lock>
	if ((client->tx_buf == NULL) || (client->rx_buf == NULL)) {
   38770:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   38772:	b393      	cbz	r3, 387da <mqtt_connect+0x7c>
   38774:	6e63      	ldr	r3, [r4, #100]	; 0x64
   38776:	b383      	cbz	r3, 387da <mqtt_connect+0x7c>
	err_code = mqtt_transport_connect(client);
   38778:	4620      	mov	r0, r4
   3877a:	f7ed ff05 	bl	26588 <mqtt_transport_connect>
	if (err_code < 0) {
   3877e:	1e05      	subs	r5, r0, #0
   38780:	db25      	blt.n	387ce <mqtt_connect+0x70>
	tx_buf_init(client, &packet);
   38782:	4669      	mov	r1, sp
   38784:	4620      	mov	r0, r4
   38786:	f7ff ff53 	bl	38630 <tx_buf_init>
	MQTT_SET_STATE(client, MQTT_STATE_TCP_CONNECTED);
   3878a:	69a3      	ldr	r3, [r4, #24]
	err_code = connect_request_encode(client, &packet);
   3878c:	4669      	mov	r1, sp
	MQTT_SET_STATE(client, MQTT_STATE_TCP_CONNECTED);
   3878e:	f043 0302 	orr.w	r3, r3, #2
   38792:	61a3      	str	r3, [r4, #24]
	err_code = connect_request_encode(client, &packet);
   38794:	4620      	mov	r0, r4
   38796:	f7ed fd33 	bl	26200 <connect_request_encode>
	if (err_code < 0) {
   3879a:	1e05      	subs	r5, r0, #0
   3879c:	db13      	blt.n	387c6 <mqtt_connect+0x68>
	err_code = mqtt_transport_write(client, packet.cur,
   3879e:	e9dd 1200 	ldrd	r1, r2, [sp]
   387a2:	4620      	mov	r0, r4
   387a4:	1a52      	subs	r2, r2, r1
   387a6:	f7ed fef7 	bl	26598 <mqtt_transport_write>
	if (err_code < 0) {
   387aa:	1e05      	subs	r5, r0, #0
   387ac:	db0b      	blt.n	387c6 <mqtt_connect+0x68>
	return z_impl_k_uptime_get();
   387ae:	f001 fa2d 	bl	39c0c <z_impl_k_uptime_get>
	client->unacked_ping = 0;
   387b2:	2500      	movs	r5, #0
   387b4:	6160      	str	r0, [r4, #20]
   387b6:	f884 5077 	strb.w	r5, [r4, #119]	; 0x77
	mqtt_mutex_unlock(client);
   387ba:	4620      	mov	r0, r4
   387bc:	f7ed ff0e 	bl	265dc <mqtt_mutex_unlock>
}
   387c0:	4628      	mov	r0, r5
   387c2:	b003      	add	sp, #12
   387c4:	bd30      	pop	{r4, r5, pc}
	client_disconnect(client, err_code);
   387c6:	4629      	mov	r1, r5
   387c8:	4620      	mov	r0, r4
   387ca:	f7ff ff50 	bl	3866e <client_disconnect>
	MQTT_STATE_INIT(client);
   387ce:	2300      	movs	r3, #0
	client->internal.last_activity = 0U;
   387d0:	e9c4 3305 	strd	r3, r3, [r4, #20]
	client->internal.remaining_payload = 0U;
   387d4:	e9c4 3307 	strd	r3, r3, [r4, #28]
   387d8:	e7ef      	b.n	387ba <mqtt_connect+0x5c>
		err_code = -ENOMEM;
   387da:	f06f 050b 	mvn.w	r5, #11
   387de:	e7f6      	b.n	387ce <mqtt_connect+0x70>
	NULL_PARAM_CHECK(client);
   387e0:	f06f 0515 	mvn.w	r5, #21
   387e4:	e7ec      	b.n	387c0 <mqtt_connect+0x62>

000387e6 <mqtt_publish>:
{
   387e6:	b573      	push	{r0, r1, r4, r5, r6, lr}
   387e8:	460e      	mov	r6, r1
	NULL_PARAM_CHECK(client);
   387ea:	4605      	mov	r5, r0
   387ec:	b330      	cbz	r0, 3883c <mqtt_publish+0x56>
	NULL_PARAM_CHECK(param);
   387ee:	b329      	cbz	r1, 3883c <mqtt_publish+0x56>
	mqtt_mutex_lock(client);
   387f0:	f7ed ff20 	bl	26634 <mqtt_mutex_lock>
	tx_buf_init(client, &packet);
   387f4:	4669      	mov	r1, sp
   387f6:	4628      	mov	r0, r5
   387f8:	f7ff ff1a 	bl	38630 <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   387fc:	69ab      	ldr	r3, [r5, #24]
   387fe:	075b      	lsls	r3, r3, #29
   38800:	d519      	bpl.n	38836 <mqtt_publish+0x50>
	err_code = publish_encode(param, &packet);
   38802:	4669      	mov	r1, sp
   38804:	4630      	mov	r0, r6
   38806:	f7ff fda5 	bl	38354 <publish_encode>
	if (err_code < 0) {
   3880a:	1e04      	subs	r4, r0, #0
   3880c:	db0d      	blt.n	3882a <mqtt_publish+0x44>
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   3880e:	e9dd 1200 	ldrd	r1, r2, [sp]
   38812:	4628      	mov	r0, r5
   38814:	1a52      	subs	r2, r2, r1
   38816:	f7ff ff49 	bl	386ac <client_write>
	if (err_code < 0) {
   3881a:	1e04      	subs	r4, r0, #0
   3881c:	db05      	blt.n	3882a <mqtt_publish+0x44>
	err_code = client_write(client, param->message.payload.data,
   3881e:	e9d6 1203 	ldrd	r1, r2, [r6, #12]
   38822:	4628      	mov	r0, r5
   38824:	f7ff ff42 	bl	386ac <client_write>
   38828:	4604      	mov	r4, r0
	mqtt_mutex_unlock(client);
   3882a:	4628      	mov	r0, r5
   3882c:	f7ed fed6 	bl	265dc <mqtt_mutex_unlock>
}
   38830:	4620      	mov	r0, r4
   38832:	b002      	add	sp, #8
   38834:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOTCONN;
   38836:	f06f 047f 	mvn.w	r4, #127	; 0x7f
   3883a:	e7f6      	b.n	3882a <mqtt_publish+0x44>
	NULL_PARAM_CHECK(client);
   3883c:	f06f 0415 	mvn.w	r4, #21
   38840:	e7f6      	b.n	38830 <mqtt_publish+0x4a>

00038842 <mqtt_disconnect>:
{
   38842:	b537      	push	{r0, r1, r2, r4, r5, lr}
	NULL_PARAM_CHECK(client);
   38844:	4604      	mov	r4, r0
   38846:	b310      	cbz	r0, 3888e <mqtt_disconnect+0x4c>
	mqtt_mutex_lock(client);
   38848:	f7ed fef4 	bl	26634 <mqtt_mutex_lock>
	tx_buf_init(client, &packet);
   3884c:	4669      	mov	r1, sp
   3884e:	4620      	mov	r0, r4
   38850:	f7ff feee 	bl	38630 <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   38854:	69a3      	ldr	r3, [r4, #24]
   38856:	075b      	lsls	r3, r3, #29
   38858:	d516      	bpl.n	38888 <mqtt_disconnect+0x46>
	err_code = disconnect_encode(&packet);
   3885a:	4668      	mov	r0, sp
   3885c:	f7ed fd50 	bl	26300 <disconnect_encode>
	if (err_code < 0) {
   38860:	1e05      	subs	r5, r0, #0
   38862:	db0b      	blt.n	3887c <mqtt_disconnect+0x3a>
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   38864:	e9dd 1200 	ldrd	r1, r2, [sp]
   38868:	4620      	mov	r0, r4
   3886a:	1a52      	subs	r2, r2, r1
   3886c:	f7ff ff1e 	bl	386ac <client_write>
	if (err_code < 0) {
   38870:	1e05      	subs	r5, r0, #0
   38872:	db03      	blt.n	3887c <mqtt_disconnect+0x3a>
	client_disconnect(client, 0);
   38874:	2100      	movs	r1, #0
   38876:	4620      	mov	r0, r4
   38878:	f7ff fef9 	bl	3866e <client_disconnect>
	mqtt_mutex_unlock(client);
   3887c:	4620      	mov	r0, r4
   3887e:	f7ed fead 	bl	265dc <mqtt_mutex_unlock>
}
   38882:	4628      	mov	r0, r5
   38884:	b003      	add	sp, #12
   38886:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   38888:	f06f 057f 	mvn.w	r5, #127	; 0x7f
   3888c:	e7f6      	b.n	3887c <mqtt_disconnect+0x3a>
	NULL_PARAM_CHECK(client);
   3888e:	f06f 0515 	mvn.w	r5, #21
   38892:	e7f6      	b.n	38882 <mqtt_disconnect+0x40>

00038894 <mqtt_subscribe>:
{
   38894:	b537      	push	{r0, r1, r2, r4, r5, lr}
   38896:	460c      	mov	r4, r1
	NULL_PARAM_CHECK(client);
   38898:	4605      	mov	r5, r0
   3889a:	b1f8      	cbz	r0, 388dc <mqtt_subscribe+0x48>
	NULL_PARAM_CHECK(param);
   3889c:	b1f1      	cbz	r1, 388dc <mqtt_subscribe+0x48>
	mqtt_mutex_lock(client);
   3889e:	f7ed fec9 	bl	26634 <mqtt_mutex_lock>
	tx_buf_init(client, &packet);
   388a2:	4669      	mov	r1, sp
   388a4:	4628      	mov	r0, r5
   388a6:	f7ff fec3 	bl	38630 <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   388aa:	69ab      	ldr	r3, [r5, #24]
   388ac:	075b      	lsls	r3, r3, #29
   388ae:	d512      	bpl.n	388d6 <mqtt_subscribe+0x42>
	err_code = subscribe_encode(param, &packet);
   388b0:	4620      	mov	r0, r4
   388b2:	4669      	mov	r1, sp
   388b4:	f7ff fd8a 	bl	383cc <subscribe_encode>
	if (err_code < 0) {
   388b8:	1e04      	subs	r4, r0, #0
   388ba:	db06      	blt.n	388ca <mqtt_subscribe+0x36>
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   388bc:	e9dd 1200 	ldrd	r1, r2, [sp]
   388c0:	4628      	mov	r0, r5
   388c2:	1a52      	subs	r2, r2, r1
   388c4:	f7ff fef2 	bl	386ac <client_write>
   388c8:	4604      	mov	r4, r0
	mqtt_mutex_unlock(client);
   388ca:	4628      	mov	r0, r5
   388cc:	f7ed fe86 	bl	265dc <mqtt_mutex_unlock>
}
   388d0:	4620      	mov	r0, r4
   388d2:	b003      	add	sp, #12
   388d4:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   388d6:	f06f 047f 	mvn.w	r4, #127	; 0x7f
   388da:	e7f6      	b.n	388ca <mqtt_subscribe+0x36>
	NULL_PARAM_CHECK(client);
   388dc:	f06f 0415 	mvn.w	r4, #21
   388e0:	e7f6      	b.n	388d0 <mqtt_subscribe+0x3c>

000388e2 <mqtt_ping>:
{
   388e2:	b537      	push	{r0, r1, r2, r4, r5, lr}
	NULL_PARAM_CHECK(client);
   388e4:	4604      	mov	r4, r0
   388e6:	b320      	cbz	r0, 38932 <mqtt_ping+0x50>
	mqtt_mutex_lock(client);
   388e8:	f7ed fea4 	bl	26634 <mqtt_mutex_lock>
	tx_buf_init(client, &packet);
   388ec:	4669      	mov	r1, sp
   388ee:	4620      	mov	r0, r4
   388f0:	f7ff fe9e 	bl	38630 <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   388f4:	69a3      	ldr	r3, [r4, #24]
   388f6:	075b      	lsls	r3, r3, #29
   388f8:	d518      	bpl.n	3892c <mqtt_ping+0x4a>
	err_code = ping_request_encode(&packet);
   388fa:	4668      	mov	r0, sp
   388fc:	f7ed fd12 	bl	26324 <ping_request_encode>
	if (err_code < 0) {
   38900:	1e05      	subs	r5, r0, #0
   38902:	db0d      	blt.n	38920 <mqtt_ping+0x3e>
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   38904:	e9dd 1200 	ldrd	r1, r2, [sp]
   38908:	4620      	mov	r0, r4
   3890a:	1a52      	subs	r2, r2, r1
   3890c:	f7ff fece 	bl	386ac <client_write>
	if (client->unacked_ping >= INT8_MAX) {
   38910:	f994 3077 	ldrsb.w	r3, [r4, #119]	; 0x77
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   38914:	4605      	mov	r5, r0
	if (client->unacked_ping >= INT8_MAX) {
   38916:	2b7f      	cmp	r3, #127	; 0x7f
   38918:	d002      	beq.n	38920 <mqtt_ping+0x3e>
		client->unacked_ping++;
   3891a:	3301      	adds	r3, #1
   3891c:	f884 3077 	strb.w	r3, [r4, #119]	; 0x77
	mqtt_mutex_unlock(client);
   38920:	4620      	mov	r0, r4
   38922:	f7ed fe5b 	bl	265dc <mqtt_mutex_unlock>
}
   38926:	4628      	mov	r0, r5
   38928:	b003      	add	sp, #12
   3892a:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   3892c:	f06f 057f 	mvn.w	r5, #127	; 0x7f
   38930:	e7f6      	b.n	38920 <mqtt_ping+0x3e>
	NULL_PARAM_CHECK(client);
   38932:	f06f 0515 	mvn.w	r5, #21
   38936:	e7f6      	b.n	38926 <mqtt_ping+0x44>

00038938 <mqtt_live>:
{
   38938:	b570      	push	{r4, r5, r6, lr}
	NULL_PARAM_CHECK(client);
   3893a:	4606      	mov	r6, r0
   3893c:	b300      	cbz	r0, 38980 <mqtt_live+0x48>
	mqtt_mutex_lock(client);
   3893e:	f7ed fe79 	bl	26634 <mqtt_mutex_lock>
	elapsed_time = mqtt_elapsed_time_in_ms_get(
   38942:	6974      	ldr	r4, [r6, #20]
   38944:	f001 f962 	bl	39c0c <z_impl_k_uptime_get>
 *
 * @retval Time elapsed since last_activity time.
 */
static inline u32_t mqtt_elapsed_time_in_ms_get(u32_t last_activity)
{
	s32_t diff = k_uptime_get_32() - last_activity;
   38948:	1b00      	subs	r0, r0, r4
	if ((client->keepalive > 0) &&
   3894a:	f8b6 4074 	ldrh.w	r4, [r6, #116]	; 0x74

	if (diff < 0) {
		return 0;
   3894e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   38952:	b19c      	cbz	r4, 3897c <mqtt_live+0x44>
	    (elapsed_time >= (client->keepalive * 1000))) {
   38954:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   38958:	435c      	muls	r4, r3
	if ((client->keepalive > 0) &&
   3895a:	4284      	cmp	r4, r0
   3895c:	d80d      	bhi.n	3897a <mqtt_live+0x42>
		err_code = mqtt_ping(client);
   3895e:	4630      	mov	r0, r6
   38960:	f7ff ffbf 	bl	388e2 <mqtt_ping>
		ping_sent = true;
   38964:	2401      	movs	r4, #1
		err_code = mqtt_ping(client);
   38966:	4605      	mov	r5, r0
	mqtt_mutex_unlock(client);
   38968:	4630      	mov	r0, r6
   3896a:	f7ed fe37 	bl	265dc <mqtt_mutex_unlock>
		return -EAGAIN;
   3896e:	2c00      	cmp	r4, #0
   38970:	bf08      	it	eq
   38972:	f06f 050a 	mvneq.w	r5, #10
}
   38976:	4628      	mov	r0, r5
   38978:	bd70      	pop	{r4, r5, r6, pc}
	bool ping_sent = false;
   3897a:	2400      	movs	r4, #0
	int err_code = 0;
   3897c:	4625      	mov	r5, r4
   3897e:	e7f3      	b.n	38968 <mqtt_live+0x30>
	NULL_PARAM_CHECK(client);
   38980:	f06f 0515 	mvn.w	r5, #21
   38984:	e7f7      	b.n	38976 <mqtt_live+0x3e>

00038986 <mqtt_keepalive_time_left>:
{
   38986:	b538      	push	{r3, r4, r5, lr}
   38988:	4605      	mov	r5, r0
	u32_t elapsed_time = mqtt_elapsed_time_in_ms_get(
   3898a:	6944      	ldr	r4, [r0, #20]
   3898c:	f001 f93e 	bl	39c0c <z_impl_k_uptime_get>
	s32_t diff = k_uptime_get_32() - last_activity;
   38990:	1b04      	subs	r4, r0, r4
	u32_t keepalive_ms = 1000U * client->keepalive;
   38992:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   38996:	f8b5 2074 	ldrh.w	r2, [r5, #116]	; 0x74
		return 0;
   3899a:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
   3899e:	4350      	muls	r0, r2
	if (client->keepalive == 0) {
   389a0:	b11a      	cbz	r2, 389aa <mqtt_keepalive_time_left+0x24>
	if (keepalive_ms <= elapsed_time) {
   389a2:	42a0      	cmp	r0, r4
   389a4:	d904      	bls.n	389b0 <mqtt_keepalive_time_left+0x2a>
	return keepalive_ms - elapsed_time;
   389a6:	1b00      	subs	r0, r0, r4
}
   389a8:	bd38      	pop	{r3, r4, r5, pc}
		return UINT32_MAX;
   389aa:	f04f 30ff 	mov.w	r0, #4294967295
   389ae:	e7fb      	b.n	389a8 <mqtt_keepalive_time_left+0x22>
		return 0;
   389b0:	2000      	movs	r0, #0
   389b2:	e7f9      	b.n	389a8 <mqtt_keepalive_time_left+0x22>

000389b4 <mqtt_input>:
{
   389b4:	b538      	push	{r3, r4, r5, lr}
	NULL_PARAM_CHECK(client);
   389b6:	4605      	mov	r5, r0
   389b8:	b1d0      	cbz	r0, 389f0 <mqtt_input+0x3c>
	mqtt_mutex_lock(client);
   389ba:	f7ed fe3b 	bl	26634 <mqtt_mutex_lock>
	if (MQTT_HAS_STATE(client, MQTT_STATE_TCP_CONNECTED)) {
   389be:	69ab      	ldr	r3, [r5, #24]
   389c0:	079b      	lsls	r3, r3, #30
   389c2:	d50f      	bpl.n	389e4 <mqtt_input+0x30>
	if (client->internal.remaining_payload > 0) {
   389c4:	6a2b      	ldr	r3, [r5, #32]
   389c6:	b983      	cbnz	r3, 389ea <mqtt_input+0x36>
	err_code = mqtt_handle_rx(client);
   389c8:	4628      	mov	r0, r5
   389ca:	f7ff fd5f 	bl	3848c <mqtt_handle_rx>
	if (err_code < 0) {
   389ce:	1e04      	subs	r4, r0, #0
   389d0:	da03      	bge.n	389da <mqtt_input+0x26>
		client_disconnect(client, err_code);
   389d2:	4621      	mov	r1, r4
   389d4:	4628      	mov	r0, r5
   389d6:	f7ff fe4a 	bl	3866e <client_disconnect>
	mqtt_mutex_unlock(client);
   389da:	4628      	mov	r0, r5
   389dc:	f7ed fdfe 	bl	265dc <mqtt_mutex_unlock>
}
   389e0:	4620      	mov	r0, r4
   389e2:	bd38      	pop	{r3, r4, r5, pc}
		err_code = -EACCES;
   389e4:	f06f 040c 	mvn.w	r4, #12
   389e8:	e7f7      	b.n	389da <mqtt_input+0x26>
		return -EBUSY;
   389ea:	f06f 040f 	mvn.w	r4, #15
   389ee:	e7f4      	b.n	389da <mqtt_input+0x26>
	NULL_PARAM_CHECK(client);
   389f0:	f06f 0415 	mvn.w	r4, #21
   389f4:	e7f4      	b.n	389e0 <mqtt_input+0x2c>

000389f6 <mqtt_read_publish_payload>:

int mqtt_read_publish_payload(struct mqtt_client *client, void *buffer,
			      size_t length)
{
	return read_publish_payload(client, buffer, length, false);
   389f6:	2300      	movs	r3, #0
   389f8:	f7ff be69 	b.w	386ce <read_publish_payload>

000389fc <mqtt_client_tls_disconnect>:

int mqtt_client_tls_disconnect(struct mqtt_client *client)
{
   389fc:	b508      	push	{r3, lr}
	int ret;

	MQTT_TRC("Closing socket %d", client->transport.tls.sock);
	ret = close(client->transport.tls.sock);
   389fe:	6a80      	ldr	r0, [r0, #40]	; 0x28
   38a00:	f7ed fe38 	bl	26674 <close>
	if (ret < 0) {
   38a04:	2800      	cmp	r0, #0
   38a06:	da04      	bge.n	38a12 <mqtt_client_tls_disconnect+0x16>
		return -errno;
   38a08:	f7ff fb55 	bl	380b6 <__errno>
   38a0c:	6800      	ldr	r0, [r0, #0]
   38a0e:	4240      	negs	r0, r0
	}

	return 0;
}
   38a10:	bd08      	pop	{r3, pc}
	return 0;
   38a12:	2000      	movs	r0, #0
   38a14:	e7fc      	b.n	38a10 <mqtt_client_tls_disconnect+0x14>

00038a16 <gpio_nrfx_write>:
{
   38a16:	b510      	push	{r4, lr}
	return port->config->config_info;
   38a18:	6804      	ldr	r4, [r0, #0]
   38a1a:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   38a1c:	68a4      	ldr	r4, [r4, #8]
	if (access_op == GPIO_ACCESS_BY_PORT) {
   38a1e:	2901      	cmp	r1, #1
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   38a20:	6824      	ldr	r4, [r4, #0]
	if (access_op == GPIO_ACCESS_BY_PORT) {
   38a22:	69c0      	ldr	r0, [r0, #28]
   38a24:	d103      	bne.n	38a2e <gpio_nrfx_write+0x18>
		nrf_gpio_port_out_write(reg, value ^ data->inverted);
   38a26:	4058      	eors	r0, r3
    p_reg->OUT = value;
   38a28:	6060      	str	r0, [r4, #4]
}
   38a2a:	2000      	movs	r0, #0
   38a2c:	bd10      	pop	{r4, pc}
		if ((value > 0) ^ ((BIT(pin) & data->inverted) != 0)) {
   38a2e:	3300      	adds	r3, #0
   38a30:	f04f 0101 	mov.w	r1, #1
   38a34:	bf18      	it	ne
   38a36:	2301      	movne	r3, #1
   38a38:	40d0      	lsrs	r0, r2
   38a3a:	f000 0001 	and.w	r0, r0, #1
   38a3e:	4091      	lsls	r1, r2
   38a40:	4283      	cmp	r3, r0
    p_reg->OUTSET = set_mask;
   38a42:	bf14      	ite	ne
   38a44:	60a1      	strne	r1, [r4, #8]
    p_reg->OUTCLR = clr_mask;
   38a46:	60e1      	streq	r1, [r4, #12]
   38a48:	e7ef      	b.n	38a2a <gpio_nrfx_write+0x14>

00038a4a <gpio_nrfx_read>:
{
   38a4a:	b570      	push	{r4, r5, r6, lr}
	return port->config->config_info;
   38a4c:	6804      	ldr	r4, [r0, #0]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   38a4e:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   38a50:	68a4      	ldr	r4, [r4, #8]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   38a52:	69c0      	ldr	r0, [r0, #28]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   38a54:	6825      	ldr	r5, [r4, #0]
	if (access_op == GPIO_ACCESS_BY_PORT) {
   38a56:	2901      	cmp	r1, #1
    return p_reg->DIR;
   38a58:	696e      	ldr	r6, [r5, #20]
    return p_reg->IN;
   38a5a:	692c      	ldr	r4, [r5, #16]
    return p_reg->OUT;
   38a5c:	686d      	ldr	r5, [r5, #4]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   38a5e:	ea80 0004 	eor.w	r0, r0, r4
   38a62:	ea84 0405 	eor.w	r4, r4, r5
   38a66:	ea04 0406 	and.w	r4, r4, r6
   38a6a:	ea80 0004 	eor.w	r0, r0, r4
		*value = (port_val & BIT(pin)) ? 1 : 0;
   38a6e:	bf1c      	itt	ne
   38a70:	40d0      	lsrne	r0, r2
   38a72:	f000 0001 	andne.w	r0, r0, #1
   38a76:	6018      	str	r0, [r3, #0]
}
   38a78:	2000      	movs	r0, #0
   38a7a:	bd70      	pop	{r4, r5, r6, pc}

00038a7c <gpio_nrfx_pin_disable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
   38a7c:	2901      	cmp	r1, #1
{
   38a7e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
   38a82:	bf18      	it	ne
   38a84:	b2d4      	uxtbne	r4, r2
{
   38a86:	4606      	mov	r6, r0
		to_pin   = pin;
   38a88:	bf12      	itee	ne
   38a8a:	4625      	movne	r5, r4
		to_pin   = 31U;
   38a8c:	251f      	moveq	r5, #31
		from_pin = 0U;
   38a8e:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
   38a90:	f04f 0801 	mov.w	r8, #1
	struct gpio_nrfx_data *data = get_port_data(port);
   38a94:	6887      	ldr	r7, [r0, #8]
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   38a96:	42ac      	cmp	r4, r5
   38a98:	d902      	bls.n	38aa0 <gpio_nrfx_pin_disable_callback+0x24>
	return res;
   38a9a:	2000      	movs	r0, #0
}
   38a9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
   38aa0:	68fb      	ldr	r3, [r7, #12]
   38aa2:	fa08 f204 	lsl.w	r2, r8, r4
   38aa6:	ea23 0302 	bic.w	r3, r3, r2
   38aaa:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
   38aac:	4621      	mov	r1, r4
   38aae:	4630      	mov	r0, r6
   38ab0:	f7ee f854 	bl	26b5c <gpiote_pin_int_cfg>
		if (res != 0) {
   38ab4:	2800      	cmp	r0, #0
   38ab6:	d1f1      	bne.n	38a9c <gpio_nrfx_pin_disable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   38ab8:	3401      	adds	r4, #1
   38aba:	b2e4      	uxtb	r4, r4
   38abc:	e7eb      	b.n	38a96 <gpio_nrfx_pin_disable_callback+0x1a>

00038abe <gpio_nrfx_pin_enable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
   38abe:	2901      	cmp	r1, #1
{
   38ac0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
   38ac4:	bf18      	it	ne
   38ac6:	b2d4      	uxtbne	r4, r2
{
   38ac8:	4606      	mov	r6, r0
		to_pin   = pin;
   38aca:	bf12      	itee	ne
   38acc:	4625      	movne	r5, r4
		to_pin   = 31U;
   38ace:	251f      	moveq	r5, #31
		from_pin = 0U;
   38ad0:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
   38ad2:	f04f 0801 	mov.w	r8, #1
	struct gpio_nrfx_data *data = get_port_data(port);
   38ad6:	6887      	ldr	r7, [r0, #8]
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   38ad8:	42ac      	cmp	r4, r5
   38ada:	d902      	bls.n	38ae2 <gpio_nrfx_pin_enable_callback+0x24>
	return res;
   38adc:	2000      	movs	r0, #0
}
   38ade:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
   38ae2:	68fb      	ldr	r3, [r7, #12]
   38ae4:	fa08 f204 	lsl.w	r2, r8, r4
   38ae8:	4313      	orrs	r3, r2
   38aea:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
   38aec:	4621      	mov	r1, r4
   38aee:	4630      	mov	r0, r6
   38af0:	f7ee f834 	bl	26b5c <gpiote_pin_int_cfg>
		if (res != 0) {
   38af4:	2800      	cmp	r0, #0
   38af6:	d1f2      	bne.n	38ade <gpio_nrfx_pin_enable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   38af8:	3401      	adds	r4, #1
   38afa:	b2e4      	uxtb	r4, r4
   38afc:	e7ec      	b.n	38ad8 <gpio_nrfx_pin_enable_callback+0x1a>

00038afe <gpio_pin_write>:
{
   38afe:	b410      	push	{r4}
   38b00:	4613      	mov	r3, r2
	return api->write(port, access_op, pin, value);
   38b02:	6842      	ldr	r2, [r0, #4]
   38b04:	6854      	ldr	r4, [r2, #4]
   38b06:	460a      	mov	r2, r1
   38b08:	46a4      	mov	ip, r4
   38b0a:	2100      	movs	r1, #0
}
   38b0c:	f85d 4b04 	ldr.w	r4, [sp], #4
	return api->write(port, access_op, pin, value);
   38b10:	4760      	bx	ip

00038b12 <_spi_context_cs_control.isra.7>:
static inline void _spi_context_cs_control(struct spi_context *ctx,
   38b12:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   38b14:	6804      	ldr	r4, [r0, #0]
static inline void _spi_context_cs_control(struct spi_context *ctx,
   38b16:	4605      	mov	r5, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   38b18:	b324      	cbz	r4, 38b64 <_spi_context_cs_control.isra.7+0x52>
   38b1a:	68a3      	ldr	r3, [r4, #8]
   38b1c:	b313      	cbz	r3, 38b64 <_spi_context_cs_control.isra.7+0x52>
   38b1e:	6818      	ldr	r0, [r3, #0]
   38b20:	b300      	cbz	r0, 38b64 <_spi_context_cs_control.isra.7+0x52>
		if (on) {
   38b22:	b161      	cbz	r1, 38b3e <_spi_context_cs_control.isra.7+0x2c>
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   38b24:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
			gpio_pin_write(ctx->config->cs->gpio_dev,
   38b28:	6859      	ldr	r1, [r3, #4]
   38b2a:	0fd2      	lsrs	r2, r2, #31
   38b2c:	f7ff ffe7 	bl	38afe <gpio_pin_write>
			k_busy_wait(ctx->config->cs->delay);
   38b30:	682b      	ldr	r3, [r5, #0]
   38b32:	689b      	ldr	r3, [r3, #8]
   38b34:	6898      	ldr	r0, [r3, #8]
}
   38b36:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_busy_wait(usec_to_wait);
   38b3a:	f000 bfea 	b.w	39b12 <z_impl_k_busy_wait>
			if (!force_off &&
   38b3e:	b912      	cbnz	r2, 38b46 <_spi_context_cs_control.isra.7+0x34>
   38b40:	88a2      	ldrh	r2, [r4, #4]
   38b42:	0492      	lsls	r2, r2, #18
   38b44:	d40e      	bmi.n	38b64 <_spi_context_cs_control.isra.7+0x52>
			k_busy_wait(ctx->config->cs->delay);
   38b46:	6898      	ldr	r0, [r3, #8]
   38b48:	f000 ffe3 	bl	39b12 <z_impl_k_busy_wait>
			gpio_pin_write(ctx->config->cs->gpio_dev,
   38b4c:	682a      	ldr	r2, [r5, #0]
   38b4e:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   38b50:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
			gpio_pin_write(ctx->config->cs->gpio_dev,
   38b54:	e9d3 0100 	ldrd	r0, r1, [r3]
   38b58:	43d2      	mvns	r2, r2
}
   38b5a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_write(ctx->config->cs->gpio_dev,
   38b5e:	0fd2      	lsrs	r2, r2, #31
   38b60:	f7ff bfcd 	b.w	38afe <gpio_pin_write>
}
   38b64:	bd38      	pop	{r3, r4, r5, pc}

00038b66 <spi_context_unlock_unconditionally>:
{
   38b66:	b510      	push	{r4, lr}
	_spi_context_cs_control(ctx, false, true);
   38b68:	2201      	movs	r2, #1
   38b6a:	2100      	movs	r1, #0
{
   38b6c:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
   38b6e:	f7ff ffd0 	bl	38b12 <_spi_context_cs_control.isra.7>
	if (!k_sem_count_get(&ctx->lock)) {
   38b72:	68e3      	ldr	r3, [r4, #12]
   38b74:	b923      	cbnz	r3, 38b80 <spi_context_unlock_unconditionally+0x1a>
	z_impl_k_sem_give(sem);
   38b76:	1d20      	adds	r0, r4, #4
}
   38b78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   38b7c:	f7fb bd66 	b.w	3464c <z_impl_k_sem_give>
   38b80:	bd10      	pop	{r4, pc}

00038b82 <spi_2_init>:
#ifdef CONFIG_SPI_1_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(1);
#endif

#ifdef CONFIG_SPI_2_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(2);
   38b82:	b510      	push	{r4, lr}
   38b84:	4604      	mov	r4, r0
   38b86:	2200      	movs	r2, #0
   38b88:	200a      	movs	r0, #10
   38b8a:	2101      	movs	r1, #1
   38b8c:	f7ec fa30 	bl	24ff0 <z_arm_irq_priority_set>
   38b90:	4620      	mov	r0, r4
   38b92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   38b96:	f7ee bacd 	b.w	27134 <init_spim>

00038b9a <spi_3_init>:
#endif

#ifdef CONFIG_SPI_3_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(3);
   38b9a:	b510      	push	{r4, lr}
   38b9c:	4604      	mov	r4, r0
   38b9e:	2200      	movs	r2, #0
   38ba0:	200b      	movs	r0, #11
   38ba2:	2101      	movs	r1, #1
   38ba4:	f7ec fa24 	bl	24ff0 <z_arm_irq_priority_set>
   38ba8:	4620      	mov	r0, r4
   38baa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   38bae:	f7ee bac1 	b.w	27134 <init_spim>

00038bb2 <spi_nrfx_release>:
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   38bb2:	6880      	ldr	r0, [r0, #8]
{
   38bb4:	b510      	push	{r4, lr}
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   38bb6:	6803      	ldr	r3, [r0, #0]
   38bb8:	428b      	cmp	r3, r1
   38bba:	d106      	bne.n	38bca <spi_nrfx_release+0x18>
	if (dev_data->busy) {
   38bbc:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
   38bc0:	b934      	cbnz	r4, 38bd0 <spi_nrfx_release+0x1e>
	spi_context_unlock_unconditionally(&dev_data->ctx);
   38bc2:	f7ff ffd0 	bl	38b66 <spi_context_unlock_unconditionally>
	return 0;
   38bc6:	4620      	mov	r0, r4
}
   38bc8:	bd10      	pop	{r4, pc}
		return -EINVAL;
   38bca:	f06f 0015 	mvn.w	r0, #21
   38bce:	e7fb      	b.n	38bc8 <spi_nrfx_release+0x16>
		return -EBUSY;
   38bd0:	f06f 000f 	mvn.w	r0, #15
   38bd4:	e7f8      	b.n	38bc8 <spi_nrfx_release+0x16>

00038bd6 <flash_nrf_write_protection>:
}
   38bd6:	2000      	movs	r0, #0
   38bd8:	4770      	bx	lr

00038bda <is_regular_addr_valid>:
{
   38bda:	b538      	push	{r3, r4, r5, lr}
   38bdc:	4604      	mov	r4, r0
   38bde:	460d      	mov	r5, r1
	size_t flash_size = nrfx_nvmc_flash_size_get();
   38be0:	f000 fe9e 	bl	39920 <nrfx_nvmc_flash_size_get>
	if (addr >= flash_size ||
   38be4:	4284      	cmp	r4, r0
   38be6:	d209      	bcs.n	38bfc <is_regular_addr_valid+0x22>
   38be8:	2c00      	cmp	r4, #0
   38bea:	db07      	blt.n	38bfc <is_regular_addr_valid+0x22>
	    addr < 0 ||
   38bec:	42a8      	cmp	r0, r5
   38bee:	d305      	bcc.n	38bfc <is_regular_addr_valid+0x22>
	    (addr) + len > flash_size) {
   38bf0:	442c      	add	r4, r5
	    len > flash_size ||
   38bf2:	4284      	cmp	r4, r0
   38bf4:	bf8c      	ite	hi
   38bf6:	2000      	movhi	r0, #0
   38bf8:	2001      	movls	r0, #1
}
   38bfa:	bd38      	pop	{r3, r4, r5, pc}
		return false;
   38bfc:	2000      	movs	r0, #0
   38bfe:	e7fc      	b.n	38bfa <is_regular_addr_valid+0x20>

00038c00 <flash_nrf_read>:
{
   38c00:	b570      	push	{r4, r5, r6, lr}
   38c02:	460d      	mov	r5, r1
	if (is_regular_addr_valid(addr, len)) {
   38c04:	4619      	mov	r1, r3
   38c06:	4628      	mov	r0, r5
{
   38c08:	4616      	mov	r6, r2
   38c0a:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   38c0c:	f7ff ffe5 	bl	38bda <is_regular_addr_valid>
   38c10:	b170      	cbz	r0, 38c30 <flash_nrf_read+0x30>
	if (!len) {
   38c12:	b184      	cbz	r4, 38c36 <flash_nrf_read+0x36>
	if (addr < PM_APP_ADDRESS) {
   38c14:	f5b5 3fe1 	cmp.w	r5, #115200	; 0x1c200
		return spm_request_read(data, addr, len);
   38c18:	4622      	mov	r2, r4
   38c1a:	4629      	mov	r1, r5
   38c1c:	4630      	mov	r0, r6
	if (addr < PM_APP_ADDRESS) {
   38c1e:	da03      	bge.n	38c28 <flash_nrf_read+0x28>
}
   38c20:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return spm_request_read(data, addr, len);
   38c24:	f7df b9dc 	b.w	17fe0 <spm_request_read>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   38c28:	f001 f8a9 	bl	39d7e <memcpy>
   38c2c:	2000      	movs	r0, #0
}
   38c2e:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   38c30:	f06f 0015 	mvn.w	r0, #21
   38c34:	e7fb      	b.n	38c2e <flash_nrf_read+0x2e>
		return 0;
   38c36:	4620      	mov	r0, r4
   38c38:	e7f9      	b.n	38c2e <flash_nrf_read+0x2e>

00038c3a <flash_get_page_info>:

#include <drivers/flash.h>

static int flash_get_page_info(struct device *dev, off_t offs,
				   bool use_addr, struct flash_pages_info *info)
{
   38c3a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   38c3e:	461d      	mov	r5, r3
	off_t group_offs = 0;
	u32_t num_in_group;
	off_t end = 0;
	size_t layout_size;

	api->page_layout(dev, &layout, &layout_size);
   38c40:	6843      	ldr	r3, [r0, #4]
{
   38c42:	460c      	mov	r4, r1
	api->page_layout(dev, &layout, &layout_size);
   38c44:	691b      	ldr	r3, [r3, #16]
   38c46:	4669      	mov	r1, sp
{
   38c48:	4616      	mov	r6, r2
	api->page_layout(dev, &layout, &layout_size);
   38c4a:	aa01      	add	r2, sp, #4
   38c4c:	4798      	blx	r3

	while (layout_size--) {
   38c4e:	e9dd 1200 	ldrd	r1, r2, [sp]
   38c52:	2300      	movs	r3, #0
	off_t end = 0;
   38c54:	4618      	mov	r0, r3
	off_t group_offs = 0;
   38c56:	469e      	mov	lr, r3
	size_t page_count = 0;
   38c58:	469c      	mov	ip, r3
   38c5a:	3a01      	subs	r2, #1
	while (layout_size--) {
   38c5c:	1c57      	adds	r7, r2, #1
   38c5e:	d102      	bne.n	38c66 <flash_get_page_info+0x2c>
		page_count += layout->pages_count;

		layout++;
	}

	return -EINVAL; /* page of the index doesn't exist */
   38c60:	f06f 0015 	mvn.w	r0, #21
   38c64:	e01a      	b.n	38c9c <flash_get_page_info+0x62>
		if (use_addr) {
   38c66:	f8d1 8000 	ldr.w	r8, [r1]
   38c6a:	b1d6      	cbz	r6, 38ca2 <flash_get_page_info+0x68>
			end += layout->pages_count * layout->pages_size;
   38c6c:	684f      	ldr	r7, [r1, #4]
   38c6e:	fb07 0008 	mla	r0, r7, r8, r0
		if (offs < end) {
   38c72:	42a0      	cmp	r0, r4
   38c74:	f102 37ff 	add.w	r7, r2, #4294967295
   38c78:	dd18      	ble.n	38cac <flash_get_page_info+0x72>
   38c7a:	9201      	str	r2, [sp, #4]
   38c7c:	b103      	cbz	r3, 38c80 <flash_get_page_info+0x46>
   38c7e:	9100      	str	r1, [sp, #0]
			info->size = layout->pages_size;
   38c80:	9b00      	ldr	r3, [sp, #0]
   38c82:	685b      	ldr	r3, [r3, #4]
   38c84:	606b      	str	r3, [r5, #4]
			if (use_addr) {
   38c86:	b176      	cbz	r6, 38ca6 <flash_get_page_info+0x6c>
				num_in_group = (offs - group_offs) /
   38c88:	eba4 040e 	sub.w	r4, r4, lr
   38c8c:	fbb4 f4f3 	udiv	r4, r4, r3
			return 0;
   38c90:	2000      	movs	r0, #0
			info->start_offset = group_offs +
   38c92:	fb04 e303 	mla	r3, r4, r3, lr
			info->index = page_count + num_in_group;
   38c96:	4464      	add	r4, ip
			info->start_offset = group_offs +
   38c98:	602b      	str	r3, [r5, #0]
			info->index = page_count + num_in_group;
   38c9a:	60ac      	str	r4, [r5, #8]
}
   38c9c:	b002      	add	sp, #8
   38c9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			end += layout->pages_count;
   38ca2:	4440      	add	r0, r8
   38ca4:	e7e5      	b.n	38c72 <flash_get_page_info+0x38>
				num_in_group = offs - page_count;
   38ca6:	eba4 040c 	sub.w	r4, r4, ip
   38caa:	e7f1      	b.n	38c90 <flash_get_page_info+0x56>
		group_offs += layout->pages_count * layout->pages_size;
   38cac:	684b      	ldr	r3, [r1, #4]
		page_count += layout->pages_count;
   38cae:	44c4      	add	ip, r8
		group_offs += layout->pages_count * layout->pages_size;
   38cb0:	fb03 ee08 	mla	lr, r3, r8, lr
		layout++;
   38cb4:	3108      	adds	r1, #8
   38cb6:	2301      	movs	r3, #1
   38cb8:	463a      	mov	r2, r7
   38cba:	e7cf      	b.n	38c5c <flash_get_page_info+0x22>

00038cbc <z_impl_flash_get_page_info_by_offs>:

int z_impl_flash_get_page_info_by_offs(struct device *dev, off_t offs,
				      struct flash_pages_info *info)
{
	return flash_get_page_info(dev, offs, true, info);
   38cbc:	4613      	mov	r3, r2
   38cbe:	2201      	movs	r2, #1
   38cc0:	f7ff bfbb 	b.w	38c3a <flash_get_page_info>

00038cc4 <uarte_nrfx_isr_int>:
	if (data->int_driven->disable_tx_irq &&
   38cc4:	6882      	ldr	r2, [r0, #8]
	return dev->config->config_info;
   38cc6:	6803      	ldr	r3, [r0, #0]
	if (data->int_driven->disable_tx_irq &&
   38cc8:	6892      	ldr	r2, [r2, #8]
	return config->uarte_regs;
   38cca:	689b      	ldr	r3, [r3, #8]
	if (data->int_driven->disable_tx_irq &&
   38ccc:	7b91      	ldrb	r1, [r2, #14]
	return config->uarte_regs;
   38cce:	681b      	ldr	r3, [r3, #0]
	if (data->int_driven->disable_tx_irq &&
   38cd0:	b159      	cbz	r1, 38cea <uarte_nrfx_isr_int+0x26>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   38cd2:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
   38cd6:	b141      	cbz	r1, 38cea <uarte_nrfx_isr_int+0x26>
    p_reg->INTENCLR = mask;
   38cd8:	f44f 7180 	mov.w	r1, #256	; 0x100
   38cdc:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   38ce0:	2101      	movs	r1, #1
   38ce2:	60d9      	str	r1, [r3, #12]
		data->int_driven->disable_tx_irq = false;
   38ce4:	2300      	movs	r3, #0
   38ce6:	7393      	strb	r3, [r2, #14]
		return;
   38ce8:	4770      	bx	lr
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   38cea:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ERROR)) {
   38cee:	b111      	cbz	r1, 38cf6 <uarte_nrfx_isr_int+0x32>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   38cf0:	2100      	movs	r1, #0
   38cf2:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
	if (data->int_driven->cb) {
   38cf6:	6813      	ldr	r3, [r2, #0]
   38cf8:	b10b      	cbz	r3, 38cfe <uarte_nrfx_isr_int+0x3a>
		data->int_driven->cb(data->int_driven->cb_data);
   38cfa:	6850      	ldr	r0, [r2, #4]
   38cfc:	4718      	bx	r3
}
   38cfe:	4770      	bx	lr

00038d00 <uarte_nrfx_config_get>:
{
   38d00:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   38d02:	6882      	ldr	r2, [r0, #8]
   38d04:	e892 0003 	ldmia.w	r2, {r0, r1}
   38d08:	e883 0003 	stmia.w	r3, {r0, r1}
}
   38d0c:	2000      	movs	r0, #0
   38d0e:	4770      	bx	lr

00038d10 <uarte_nrfx_err_check>:
	return dev->config->config_info;
   38d10:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   38d12:	689b      	ldr	r3, [r3, #8]
   38d14:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   38d16:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   38d1a:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   38d1e:	4770      	bx	lr

00038d20 <uarte_nrfx_poll_in>:
	return dev->config->config_info;
   38d20:	6803      	ldr	r3, [r0, #0]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   38d22:	6882      	ldr	r2, [r0, #8]
	return config->uarte_regs;
   38d24:	689b      	ldr	r3, [r3, #8]
   38d26:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   38d28:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   38d2c:	b138      	cbz	r0, 38d3e <uarte_nrfx_poll_in+0x1e>
	*c = data->rx_data;
   38d2e:	7b12      	ldrb	r2, [r2, #12]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   38d30:	2000      	movs	r0, #0
   38d32:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   38d34:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   38d36:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   38d3a:	601a      	str	r2, [r3, #0]
	return 0;
   38d3c:	4770      	bx	lr
		return -1;
   38d3e:	f04f 30ff 	mov.w	r0, #4294967295
}
   38d42:	4770      	bx	lr

00038d44 <uarte_nrfx_poll_out>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   38d44:	2200      	movs	r2, #0
	return dev->config->config_info;
   38d46:	6803      	ldr	r3, [r0, #0]
{
   38d48:	b082      	sub	sp, #8
	return config->uarte_regs;
   38d4a:	689b      	ldr	r3, [r3, #8]
{
   38d4c:	f88d 1007 	strb.w	r1, [sp, #7]
	return config->uarte_regs;
   38d50:	681b      	ldr	r3, [r3, #0]
   38d52:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   38d56:	f10d 0207 	add.w	r2, sp, #7
   38d5a:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   38d5e:	2201      	movs	r2, #1
   38d60:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   38d64:	609a      	str	r2, [r3, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   38d66:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	while (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   38d6a:	2900      	cmp	r1, #0
   38d6c:	d0fb      	beq.n	38d66 <uarte_nrfx_poll_out+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   38d6e:	60da      	str	r2, [r3, #12]
}
   38d70:	b002      	add	sp, #8
   38d72:	4770      	bx	lr

00038d74 <uarte_nrfx_fifo_fill>:
	return dev->config->config_info;
   38d74:	6803      	ldr	r3, [r0, #0]
{
   38d76:	b570      	push	{r4, r5, r6, lr}
	return config->uarte_regs;
   38d78:	689b      	ldr	r3, [r3, #8]
   38d7a:	681c      	ldr	r4, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   38d7c:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   38d80:	b1bb      	cbz	r3, 38db2 <uarte_nrfx_fifo_fill+0x3e>
	struct uarte_nrfx_data *data = get_dev_data(dev);
   38d82:	6885      	ldr	r5, [r0, #8]
	if (len > data->int_driven->tx_buff_size) {
   38d84:	68ab      	ldr	r3, [r5, #8]
   38d86:	8998      	ldrh	r0, [r3, #12]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   38d88:	2300      	movs	r3, #0
   38d8a:	4290      	cmp	r0, r2
   38d8c:	bfa8      	it	ge
   38d8e:	4610      	movge	r0, r2
   38d90:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
	for (int i = 0; i < len; i++) {
   38d94:	68aa      	ldr	r2, [r5, #8]
   38d96:	4283      	cmp	r3, r0
   38d98:	6892      	ldr	r2, [r2, #8]
   38d9a:	db06      	blt.n	38daa <uarte_nrfx_fifo_fill+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   38d9c:	2301      	movs	r3, #1
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   38d9e:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   38da2:	f8c4 0548 	str.w	r0, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   38da6:	60a3      	str	r3, [r4, #8]
}
   38da8:	bd70      	pop	{r4, r5, r6, pc}
		data->int_driven->tx_buffer[i] = tx_data[i];
   38daa:	5cce      	ldrb	r6, [r1, r3]
   38dac:	54d6      	strb	r6, [r2, r3]
	for (int i = 0; i < len; i++) {
   38dae:	3301      	adds	r3, #1
   38db0:	e7f0      	b.n	38d94 <uarte_nrfx_fifo_fill+0x20>
		return 0;
   38db2:	4618      	mov	r0, r3
   38db4:	e7f8      	b.n	38da8 <uarte_nrfx_fifo_fill+0x34>

00038db6 <uarte_nrfx_fifo_read>:
	return dev->config->config_info;
   38db6:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   38db8:	689b      	ldr	r3, [r3, #8]
   38dba:	681a      	ldr	r2, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   38dbc:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   38dc0:	b143      	cbz	r3, 38dd4 <uarte_nrfx_fifo_read+0x1e>
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   38dc2:	6883      	ldr	r3, [r0, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   38dc4:	2000      	movs	r0, #0
   38dc6:	f8c2 0110 	str.w	r0, [r2, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   38dca:	2001      	movs	r0, #1
		rx_data[num_rx++] = (u8_t)data->rx_data;
   38dcc:	7b1b      	ldrb	r3, [r3, #12]
   38dce:	700b      	strb	r3, [r1, #0]
   38dd0:	6010      	str	r0, [r2, #0]
   38dd2:	4770      	bx	lr
	int num_rx = 0;
   38dd4:	4618      	mov	r0, r3
}
   38dd6:	4770      	bx	lr

00038dd8 <uarte_nrfx_irq_tx_enable>:
	data->int_driven->disable_tx_irq = false;
   38dd8:	2100      	movs	r1, #0
	return dev->config->config_info;
   38dda:	6803      	ldr	r3, [r0, #0]
	data->int_driven->disable_tx_irq = false;
   38ddc:	6882      	ldr	r2, [r0, #8]
	return config->uarte_regs;
   38dde:	689b      	ldr	r3, [r3, #8]
	data->int_driven->disable_tx_irq = false;
   38de0:	6892      	ldr	r2, [r2, #8]
	return config->uarte_regs;
   38de2:	681b      	ldr	r3, [r3, #0]
	data->int_driven->disable_tx_irq = false;
   38de4:	7391      	strb	r1, [r2, #14]
    p_reg->INTENSET = mask;
   38de6:	f44f 7280 	mov.w	r2, #256	; 0x100
   38dea:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   38dee:	4770      	bx	lr

00038df0 <uarte_nrfx_irq_tx_disable>:
	data->int_driven->disable_tx_irq = true;
   38df0:	2201      	movs	r2, #1
   38df2:	6883      	ldr	r3, [r0, #8]
   38df4:	689b      	ldr	r3, [r3, #8]
   38df6:	739a      	strb	r2, [r3, #14]
}
   38df8:	4770      	bx	lr

00038dfa <uarte_nrfx_irq_tx_ready_complete>:
	return dev->config->config_info;
   38dfa:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   38dfc:	689b      	ldr	r3, [r3, #8]
   38dfe:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   38e00:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX) &&
   38e04:	b118      	cbz	r0, 38e0e <uarte_nrfx_irq_tx_ready_complete+0x14>
    return p_reg->INTENSET & mask;
   38e06:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
   38e0a:	f3c0 2000 	ubfx	r0, r0, #8, #1
}
   38e0e:	4770      	bx	lr

00038e10 <uarte_nrfx_irq_rx_ready>:
	return dev->config->config_info;
   38e10:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   38e12:	689b      	ldr	r3, [r3, #8]
   38e14:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   38e16:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
}
   38e1a:	3000      	adds	r0, #0
   38e1c:	bf18      	it	ne
   38e1e:	2001      	movne	r0, #1
   38e20:	4770      	bx	lr

00038e22 <uarte_nrfx_irq_rx_enable>:
    p_reg->INTENSET = mask;
   38e22:	2210      	movs	r2, #16
	return dev->config->config_info;
   38e24:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   38e26:	689b      	ldr	r3, [r3, #8]
   38e28:	681b      	ldr	r3, [r3, #0]
   38e2a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   38e2e:	4770      	bx	lr

00038e30 <uarte_nrfx_irq_rx_disable>:
    p_reg->INTENCLR = mask;
   38e30:	2210      	movs	r2, #16
	return dev->config->config_info;
   38e32:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   38e34:	689b      	ldr	r3, [r3, #8]
   38e36:	681b      	ldr	r3, [r3, #0]
   38e38:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   38e3c:	4770      	bx	lr

00038e3e <uarte_nrfx_irq_err_enable>:
    p_reg->INTENSET = mask;
   38e3e:	f44f 7200 	mov.w	r2, #512	; 0x200
	return dev->config->config_info;
   38e42:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   38e44:	689b      	ldr	r3, [r3, #8]
   38e46:	681b      	ldr	r3, [r3, #0]
   38e48:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   38e4c:	4770      	bx	lr

00038e4e <uarte_nrfx_irq_err_disable>:
    p_reg->INTENCLR = mask;
   38e4e:	f44f 7200 	mov.w	r2, #512	; 0x200
	return dev->config->config_info;
   38e52:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   38e54:	689b      	ldr	r3, [r3, #8]
   38e56:	681b      	ldr	r3, [r3, #0]
   38e58:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   38e5c:	4770      	bx	lr

00038e5e <uarte_nrfx_irq_update>:
}
   38e5e:	2001      	movs	r0, #1
   38e60:	4770      	bx	lr

00038e62 <uarte_nrfx_irq_callback_set>:
	data->int_driven->cb = cb;
   38e62:	6883      	ldr	r3, [r0, #8]
   38e64:	689b      	ldr	r3, [r3, #8]
	data->int_driven->cb_data = cb_data;
   38e66:	e9c3 1200 	strd	r1, r2, [r3]
}
   38e6a:	4770      	bx	lr

00038e6c <uarte_nrfx_irq_is_pending>:
{
   38e6c:	b508      	push	{r3, lr}
	return dev->config->config_info;
   38e6e:	6803      	ldr	r3, [r0, #0]
{
   38e70:	4602      	mov	r2, r0
	return config->uarte_regs;
   38e72:	689b      	ldr	r3, [r3, #8]
   38e74:	6819      	ldr	r1, [r3, #0]
    return p_reg->INTENSET & mask;
   38e76:	f8d1 3304 	ldr.w	r3, [r1, #772]	; 0x304
		||
   38e7a:	05db      	lsls	r3, r3, #23
   38e7c:	d405      	bmi.n	38e8a <uarte_nrfx_irq_is_pending+0x1e>
   38e7e:	f8d1 0304 	ldr.w	r0, [r1, #772]	; 0x304
   38e82:	f010 0010 	ands.w	r0, r0, #16
   38e86:	d106      	bne.n	38e96 <uarte_nrfx_irq_is_pending+0x2a>
}
   38e88:	bd08      	pop	{r3, pc}
		 uarte_nrfx_irq_tx_ready_complete(dev))
   38e8a:	f7ff ffb6 	bl	38dfa <uarte_nrfx_irq_tx_ready_complete>
					    NRF_UARTE_INT_ENDTX_MASK) &&
   38e8e:	2800      	cmp	r0, #0
   38e90:	d0f5      	beq.n	38e7e <uarte_nrfx_irq_is_pending+0x12>
		||
   38e92:	2001      	movs	r0, #1
   38e94:	e7f8      	b.n	38e88 <uarte_nrfx_irq_is_pending+0x1c>
		 uarte_nrfx_irq_rx_ready(dev)));
   38e96:	4610      	mov	r0, r2
   38e98:	f7ff ffba 	bl	38e10 <uarte_nrfx_irq_rx_ready>
					    NRF_UARTE_INT_ENDRX_MASK) &&
   38e9c:	3000      	adds	r0, #0
   38e9e:	bf18      	it	ne
   38ea0:	2001      	movne	r0, #1
   38ea2:	e7f1      	b.n	38e88 <uarte_nrfx_irq_is_pending+0x1c>

00038ea4 <entropy_cc310_rng_init>:
{
	/* No initialization is required */
	(void)dev;

	return 0;
}
   38ea4:	2000      	movs	r0, #0
   38ea6:	4770      	bx	lr

00038ea8 <trace_proxy_irq_handler>:
ISR_DIRECT_DECLARE(trace_proxy_irq_handler)
   38ea8:	4668      	mov	r0, sp
   38eaa:	f020 0107 	bic.w	r1, r0, #7
   38eae:	468d      	mov	sp, r1
   38eb0:	b501      	push	{r0, lr}
	bsd_os_trace_irq_handler();
   38eb2:	f7f2 fd65 	bl	2b980 <bsd_os_trace_irq_handler>
	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   38eb6:	f7ec f8cd 	bl	25054 <_arch_isr_direct_pm>
   38eba:	f7eb ffb5 	bl	24e28 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(trace_proxy_irq_handler)
   38ebe:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   38ec2:	4685      	mov	sp, r0
   38ec4:	4770      	bx	lr

00038ec6 <ipc_proxy_irq_handler>:
ISR_DIRECT_DECLARE(ipc_proxy_irq_handler)
   38ec6:	4668      	mov	r0, sp
   38ec8:	f020 0107 	bic.w	r1, r0, #7
   38ecc:	468d      	mov	sp, r1
   38ece:	b501      	push	{r0, lr}
	IPC_IRQHandler();
   38ed0:	f7f3 f94e 	bl	2c170 <IPC_IRQHandler>
	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   38ed4:	f7ec f8be 	bl	25054 <_arch_isr_direct_pm>
   38ed8:	f7eb ffa6 	bl	24e28 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(ipc_proxy_irq_handler)
   38edc:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   38ee0:	4685      	mov	sp, r0
   38ee2:	4770      	bx	lr

00038ee4 <trace_task_create>:
{
   38ee4:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(TRACE_IRQ, TRACE_IRQ_PRIORITY,
   38ee6:	201d      	movs	r0, #29
   38ee8:	2200      	movs	r2, #0
   38eea:	2106      	movs	r1, #6
   38eec:	f7ec f880 	bl	24ff0 <z_arm_irq_priority_set>
}
   38ef0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(TRACE_IRQ);
   38ef4:	201d      	movs	r0, #29
   38ef6:	f7ec b86b 	b.w	24fd0 <arch_irq_enable>

00038efa <read_task_create>:
{
   38efa:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(BSD_APPLICATION_IRQ, BSD_APPLICATION_IRQ_PRIORITY,
   38efc:	201c      	movs	r0, #28
   38efe:	2200      	movs	r2, #0
   38f00:	2106      	movs	r1, #6
   38f02:	f7ec f875 	bl	24ff0 <z_arm_irq_priority_set>
}
   38f06:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(BSD_APPLICATION_IRQ);
   38f0a:	201c      	movs	r0, #28
   38f0c:	f7ec b860 	b.w	24fd0 <arch_irq_enable>

00038f10 <bsd_os_trace_put>:
		remaining_bytes -= transfer_len;
	}
#endif

	return 0;
}
   38f10:	2000      	movs	r0, #0
   38f12:	4770      	bx	lr

00038f14 <z_to_nrf_flags>:
		nrf_flags |= NRF_MSG_DONTWAIT;
   38f14:	f010 0340 	ands.w	r3, r0, #64	; 0x40
   38f18:	bf18      	it	ne
   38f1a:	2302      	movne	r3, #2
	if (z_flags & MSG_PEEK) {
   38f1c:	0782      	lsls	r2, r0, #30
		nrf_flags |= NRF_MSG_PEEK;
   38f1e:	bf48      	it	mi
   38f20:	f043 0308 	orrmi.w	r3, r3, #8
}
   38f24:	4618      	mov	r0, r3
   38f26:	4770      	bx	lr

00038f28 <z_to_nrf_family>:
	switch (z_family) {
   38f28:	2803      	cmp	r0, #3
   38f2a:	d00f      	beq.n	38f4c <z_to_nrf_family+0x24>
   38f2c:	d808      	bhi.n	38f40 <z_to_nrf_family+0x18>
   38f2e:	2801      	cmp	r0, #1
   38f30:	d00e      	beq.n	38f50 <z_to_nrf_family+0x28>
   38f32:	2802      	cmp	r0, #2
		return -EAFNOSUPPORT;
   38f34:	bf08      	it	eq
   38f36:	200a      	moveq	r0, #10
   38f38:	bf18      	it	ne
   38f3a:	f06f 0069 	mvnne.w	r0, #105	; 0x69
   38f3e:	4770      	bx	lr
	switch (z_family) {
   38f40:	2866      	cmp	r0, #102	; 0x66
   38f42:	d006      	beq.n	38f52 <z_to_nrf_family+0x2a>
   38f44:	2867      	cmp	r0, #103	; 0x67
		return -EAFNOSUPPORT;
   38f46:	bf08      	it	eq
   38f48:	2001      	moveq	r0, #1
   38f4a:	e7f5      	b.n	38f38 <z_to_nrf_family+0x10>
		return NRF_AF_PACKET;
   38f4c:	2005      	movs	r0, #5
   38f4e:	4770      	bx	lr
		return NRF_AF_INET;
   38f50:	2002      	movs	r0, #2
}
   38f52:	4770      	bx	lr

00038f54 <z_to_nrf_protocol>:
	switch (proto) {
   38f54:	f5b0 7f81 	cmp.w	r0, #258	; 0x102
   38f58:	d01d      	beq.n	38f96 <z_to_nrf_protocol+0x42>
   38f5a:	dc08      	bgt.n	38f6e <z_to_nrf_protocol+0x1a>
   38f5c:	2806      	cmp	r0, #6
   38f5e:	d01d      	beq.n	38f9c <z_to_nrf_protocol+0x48>
   38f60:	2811      	cmp	r0, #17
   38f62:	d01d      	beq.n	38fa0 <z_to_nrf_protocol+0x4c>
   38f64:	2800      	cmp	r0, #0
		return -EPROTONOSUPPORT;
   38f66:	bf18      	it	ne
   38f68:	f06f 007a 	mvnne.w	r0, #122	; 0x7a
   38f6c:	4770      	bx	lr
	switch (proto) {
   38f6e:	f240 2301 	movw	r3, #513	; 0x201
   38f72:	4298      	cmp	r0, r3
   38f74:	d015      	beq.n	38fa2 <z_to_nrf_protocol+0x4e>
   38f76:	dc06      	bgt.n	38f86 <z_to_nrf_protocol+0x32>
   38f78:	f240 1311 	movw	r3, #273	; 0x111
   38f7c:	4298      	cmp	r0, r3
		return -EPROTONOSUPPORT;
   38f7e:	bf08      	it	eq
   38f80:	f44f 7087 	moveq.w	r0, #270	; 0x10e
   38f84:	e7ef      	b.n	38f66 <z_to_nrf_protocol+0x12>
	switch (proto) {
   38f86:	f240 2302 	movw	r3, #514	; 0x202
   38f8a:	4298      	cmp	r0, r3
   38f8c:	d009      	beq.n	38fa2 <z_to_nrf_protocol+0x4e>
   38f8e:	f240 2303 	movw	r3, #515	; 0x203
   38f92:	4298      	cmp	r0, r3
   38f94:	e7e7      	b.n	38f66 <z_to_nrf_protocol+0x12>
		return NRF_SPROTO_TLS1v2;
   38f96:	f44f 7082 	mov.w	r0, #260	; 0x104
   38f9a:	4770      	bx	lr
		return NRF_IPPROTO_TCP;
   38f9c:	2001      	movs	r0, #1
   38f9e:	4770      	bx	lr
		return NRF_IPPROTO_UDP;
   38fa0:	2002      	movs	r0, #2
}
   38fa2:	4770      	bx	lr

00038fa4 <nrf91_bsdlib_socket_offload_init>:
}
   38fa4:	2000      	movs	r0, #0
   38fa6:	4770      	bx	lr

00038fa8 <nrf91_socket_offload_freeaddrinfo>:
{
   38fa8:	b538      	push	{r3, r4, r5, lr}
   38faa:	4604      	mov	r4, r0
	while (next != NULL) {
   38fac:	b904      	cbnz	r4, 38fb0 <nrf91_socket_offload_freeaddrinfo+0x8>
}
   38fae:	bd38      	pop	{r3, r4, r5, pc}
		k_free(this->ai_addr);
   38fb0:	6960      	ldr	r0, [r4, #20]
		next = next->ai_next;
   38fb2:	69e5      	ldr	r5, [r4, #28]
		k_free(this->ai_addr);
   38fb4:	f000 fd18 	bl	399e8 <k_free>
		k_free(this);
   38fb8:	4620      	mov	r0, r4
   38fba:	f000 fd15 	bl	399e8 <k_free>
		next = next->ai_next;
   38fbe:	462c      	mov	r4, r5
   38fc0:	e7f4      	b.n	38fac <nrf91_socket_offload_freeaddrinfo+0x4>

00038fc2 <z_to_nrf_addrinfo_hints>:
{
   38fc2:	b538      	push	{r3, r4, r5, lr}
   38fc4:	460c      	mov	r4, r1
   38fc6:	4605      	mov	r5, r0
__ssp_bos_icheck3(memset, void *, int)
   38fc8:	221c      	movs	r2, #28
   38fca:	2100      	movs	r1, #0
   38fcc:	1d20      	adds	r0, r4, #4
   38fce:	f000 fef6 	bl	39dbe <memset>
	nrf_out->ai_flags = z_to_nrf_addrinfo_flags(z_in->ai_flags);
   38fd2:	2300      	movs	r3, #0
   38fd4:	6023      	str	r3, [r4, #0]
	nrf_out->ai_socktype = z_to_nrf_socktype(z_in->ai_socktype);
   38fd6:	68ab      	ldr	r3, [r5, #8]
	switch (socktype) {
   38fd8:	2b03      	cmp	r3, #3
   38fda:	d003      	beq.n	38fe4 <z_to_nrf_addrinfo_hints+0x22>
		return NRF_SOCK_MGMT;
   38fdc:	2b04      	cmp	r3, #4
   38fde:	bf08      	it	eq
   38fe0:	f44f 7300 	moveq.w	r3, #512	; 0x200
	nrf_out->ai_socktype = z_to_nrf_socktype(z_in->ai_socktype);
   38fe4:	60a3      	str	r3, [r4, #8]
	family = z_to_nrf_family(z_in->ai_family);
   38fe6:	88a8      	ldrh	r0, [r5, #4]
   38fe8:	f7ff ff9e 	bl	38f28 <z_to_nrf_family>
	if (family == -EAFNOSUPPORT) {
   38fec:	f110 0f6a 	cmn.w	r0, #106	; 0x6a
   38ff0:	d00b      	beq.n	3900a <z_to_nrf_addrinfo_hints+0x48>
	nrf_out->ai_family = family;
   38ff2:	6060      	str	r0, [r4, #4]
	nrf_out->ai_protocol = z_to_nrf_protocol(z_in->ai_protocol);
   38ff4:	68e8      	ldr	r0, [r5, #12]
   38ff6:	f7ff ffad 	bl	38f54 <z_to_nrf_protocol>
	if (nrf_out->ai_protocol == -EPROTONOSUPPORT) {
   38ffa:	f110 0f7b 	cmn.w	r0, #123	; 0x7b
	nrf_out->ai_protocol = z_to_nrf_protocol(z_in->ai_protocol);
   38ffe:	60e0      	str	r0, [r4, #12]
	if (nrf_out->ai_protocol == -EPROTONOSUPPORT) {
   39000:	d003      	beq.n	3900a <z_to_nrf_addrinfo_hints+0x48>
	if (z_in->ai_canonname != NULL) {
   39002:	69a8      	ldr	r0, [r5, #24]
   39004:	b108      	cbz	r0, 3900a <z_to_nrf_addrinfo_hints+0x48>
		nrf_out->ai_canonname = z_in->ai_canonname;
   39006:	61a0      	str	r0, [r4, #24]
	return 0;
   39008:	2000      	movs	r0, #0
}
   3900a:	bd38      	pop	{r3, r4, r5, pc}

0003900c <nrf91_socket_offload_send>:
{
   3900c:	b570      	push	{r4, r5, r6, lr}
   3900e:	4604      	mov	r4, r0
	return nrf_send(sd, buf, len, z_to_nrf_flags(flags));
   39010:	4618      	mov	r0, r3
{
   39012:	4615      	mov	r5, r2
	return nrf_send(sd, buf, len, z_to_nrf_flags(flags));
   39014:	f7ff ff7e 	bl	38f14 <z_to_nrf_flags>
   39018:	462a      	mov	r2, r5
   3901a:	4603      	mov	r3, r0
   3901c:	4620      	mov	r0, r4
}
   3901e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return nrf_send(sd, buf, len, z_to_nrf_flags(flags));
   39022:	f7f4 bded 	b.w	2dc00 <nrf_send>

00039026 <nrf91_socket_offload_recv>:
{
   39026:	b570      	push	{r4, r5, r6, lr}
   39028:	4604      	mov	r4, r0
	return nrf_recv(sd, buf, max_len, z_to_nrf_flags(flags));
   3902a:	4618      	mov	r0, r3
{
   3902c:	4615      	mov	r5, r2
	return nrf_recv(sd, buf, max_len, z_to_nrf_flags(flags));
   3902e:	f7ff ff71 	bl	38f14 <z_to_nrf_flags>
   39032:	462a      	mov	r2, r5
   39034:	4603      	mov	r3, r0
   39036:	4620      	mov	r0, r4
}
   39038:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return nrf_recv(sd, buf, max_len, z_to_nrf_flags(flags));
   3903c:	f7f4 be16 	b.w	2dc6c <nrf_recv>

00039040 <nrf91_socket_offload_getsockopt>:
{
   39040:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   39044:	461d      	mov	r5, r3
	struct nrf_timeval nrf_rcvtimeo = {0, 0};
   39046:	2300      	movs	r3, #0
{
   39048:	b086      	sub	sp, #24
   3904a:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
	struct nrf_timeval nrf_rcvtimeo = {0, 0};
   3904e:	e9cd 3304 	strd	r3, r3, [sp, #16]
	nrf_socklen_t nrf_optlen = (nrf_socklen_t)*optlen;
   39052:	f8d8 3000 	ldr.w	r3, [r8]
	switch (z_in_level) {
   39056:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
{
   3905a:	4607      	mov	r7, r0
   3905c:	460c      	mov	r4, r1
   3905e:	4616      	mov	r6, r2
	nrf_socklen_t nrf_optlen = (nrf_socklen_t)*optlen;
   39060:	9303      	str	r3, [sp, #12]
	switch (z_in_level) {
   39062:	d002      	beq.n	3906a <nrf91_socket_offload_getsockopt+0x2a>
   39064:	dc2b      	bgt.n	390be <nrf91_socket_offload_getsockopt+0x7e>
   39066:	2901      	cmp	r1, #1
   39068:	d13d      	bne.n	390e6 <nrf91_socket_offload_getsockopt+0xa6>
	if (z_to_nrf_optname(level, optname, &nrf_optname) < 0)
   3906a:	aa02      	add	r2, sp, #8
   3906c:	4631      	mov	r1, r6
   3906e:	4620      	mov	r0, r4
   39070:	f7ee fe24 	bl	27cbc <z_to_nrf_optname>
   39074:	2800      	cmp	r0, #0
   39076:	db36      	blt.n	390e6 <nrf91_socket_offload_getsockopt+0xa6>
	if ((level == SOL_SOCKET) && (optname == SO_RCVTIMEO)) {
   39078:	2c01      	cmp	r4, #1
   3907a:	d128      	bne.n	390ce <nrf91_socket_offload_getsockopt+0x8e>
   3907c:	2e14      	cmp	r6, #20
   3907e:	d126      	bne.n	390ce <nrf91_socket_offload_getsockopt+0x8e>
		nrf_optlen = sizeof(struct nrf_timeval);
   39080:	2308      	movs	r3, #8
   39082:	9303      	str	r3, [sp, #12]
		nrf_optval = &nrf_rcvtimeo;
   39084:	ab04      	add	r3, sp, #16
	retval = nrf_getsockopt(sd, nrf_level, nrf_optname, nrf_optval,
   39086:	aa03      	add	r2, sp, #12
   39088:	9200      	str	r2, [sp, #0]
   3908a:	4638      	mov	r0, r7
   3908c:	9a02      	ldr	r2, [sp, #8]
   3908e:	4621      	mov	r1, r4
   39090:	f7f4 fe6c 	bl	2dd6c <nrf_getsockopt>
	if ((retval == 0) && (optval != NULL)) {
   39094:	4607      	mov	r7, r0
   39096:	b970      	cbnz	r0, 390b6 <nrf91_socket_offload_getsockopt+0x76>
   39098:	b16d      	cbz	r5, 390b6 <nrf91_socket_offload_getsockopt+0x76>
		*optlen = nrf_optlen;
   3909a:	9b03      	ldr	r3, [sp, #12]
		if (level == SOL_SOCKET) {
   3909c:	2c01      	cmp	r4, #1
		*optlen = nrf_optlen;
   3909e:	f8c8 3000 	str.w	r3, [r8]
		if (level == SOL_SOCKET) {
   390a2:	d108      	bne.n	390b6 <nrf91_socket_offload_getsockopt+0x76>
			if (optname == SO_ERROR) {
   390a4:	2e04      	cmp	r6, #4
   390a6:	d114      	bne.n	390d2 <nrf91_socket_offload_getsockopt+0x92>
				bsd_os_errno_set(*(int *)optval);
   390a8:	6828      	ldr	r0, [r5, #0]
   390aa:	f7ee fcd9 	bl	27a60 <bsd_os_errno_set>
				*(int *)optval = errno;
   390ae:	f7ff f802 	bl	380b6 <__errno>
   390b2:	6803      	ldr	r3, [r0, #0]
   390b4:	602b      	str	r3, [r5, #0]
}
   390b6:	4638      	mov	r0, r7
   390b8:	b006      	add	sp, #24
   390ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (z_in_level) {
   390be:	f240 2302 	movw	r3, #514	; 0x202
   390c2:	4299      	cmp	r1, r3
   390c4:	d0d1      	beq.n	3906a <nrf91_socket_offload_getsockopt+0x2a>
   390c6:	f240 2303 	movw	r3, #515	; 0x203
   390ca:	4299      	cmp	r1, r3
   390cc:	e7cc      	b.n	39068 <nrf91_socket_offload_getsockopt+0x28>
   390ce:	462b      	mov	r3, r5
   390d0:	e7d9      	b.n	39086 <nrf91_socket_offload_getsockopt+0x46>
			} else if (optname == SO_RCVTIMEO) {
   390d2:	2e14      	cmp	r6, #20
   390d4:	d1ef      	bne.n	390b6 <nrf91_socket_offload_getsockopt+0x76>
				((struct timeval *)optval)->tv_sec =
   390d6:	9b04      	ldr	r3, [sp, #16]
   390d8:	602b      	str	r3, [r5, #0]
				((struct timeval *)optval)->tv_usec =
   390da:	9b05      	ldr	r3, [sp, #20]
   390dc:	606b      	str	r3, [r5, #4]
				*optlen = sizeof(struct timeval);
   390de:	2308      	movs	r3, #8
   390e0:	f8c8 3000 	str.w	r3, [r8]
   390e4:	e7e7      	b.n	390b6 <nrf91_socket_offload_getsockopt+0x76>
	errno = ENOPROTOOPT;
   390e6:	f7fe ffe6 	bl	380b6 <__errno>
   390ea:	236d      	movs	r3, #109	; 0x6d
	return retval;
   390ec:	f04f 37ff 	mov.w	r7, #4294967295
	errno = ENOPROTOOPT;
   390f0:	6003      	str	r3, [r0, #0]
	return retval;
   390f2:	e7e0      	b.n	390b6 <nrf91_socket_offload_getsockopt+0x76>

000390f4 <nrf91_socket_offload_poll>:
{
   390f4:	b5f0      	push	{r4, r5, r6, r7, lr}
   390f6:	b091      	sub	sp, #68	; 0x44
   390f8:	4605      	mov	r5, r0
   390fa:	460c      	mov	r4, r1
   390fc:	4616      	mov	r6, r2
	struct nrf_pollfd tmp[BSD_MAX_SOCKET_COUNT] = {0};
   390fe:	2100      	movs	r1, #0
   39100:	2240      	movs	r2, #64	; 0x40
   39102:	4668      	mov	r0, sp
   39104:	f000 fe5b 	bl	39dbe <memset>
	for (int i = 0; i < nfds; i++) {
   39108:	466a      	mov	r2, sp
   3910a:	2100      	movs	r1, #0
		if (fds[i].events & POLLIN) {
   3910c:	1d2f      	adds	r7, r5, #4
	for (int i = 0; i < nfds; i++) {
   3910e:	42a1      	cmp	r1, r4
   39110:	db0c      	blt.n	3912c <nrf91_socket_offload_poll+0x38>
	retval = nrf_poll((struct nrf_pollfd *)&tmp, nfds, timeout);
   39112:	4632      	mov	r2, r6
   39114:	4621      	mov	r1, r4
   39116:	4668      	mov	r0, sp
   39118:	f7f4 fe48 	bl	2ddac <nrf_poll>
	for (int i = 0; i < nfds; i++) {
   3911c:	2200      	movs	r2, #0
   3911e:	462b      	mov	r3, r5
		fds[i].revents = 0;
   39120:	4616      	mov	r6, r2
			fds[i].revents |= POLLIN;
   39122:	2701      	movs	r7, #1
	for (int i = 0; i < nfds; i++) {
   39124:	42a2      	cmp	r2, r4
   39126:	db1a      	blt.n	3915e <nrf91_socket_offload_poll+0x6a>
}
   39128:	b011      	add	sp, #68	; 0x44
   3912a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		tmp[i].handle = fds[i].fd;
   3912c:	f855 3031 	ldr.w	r3, [r5, r1, lsl #3]
		if (fds[i].events & POLLIN) {
   39130:	f837 0031 	ldrh.w	r0, [r7, r1, lsl #3]
		tmp[i].handle = fds[i].fd;
   39134:	6013      	str	r3, [r2, #0]
		if (fds[i].events & POLLIN) {
   39136:	07c3      	lsls	r3, r0, #31
			tmp[i].requested |= NRF_POLLIN;
   39138:	bf48      	it	mi
   3913a:	8893      	ldrhmi	r3, [r2, #4]
	for (int i = 0; i < nfds; i++) {
   3913c:	f101 0101 	add.w	r1, r1, #1
			tmp[i].requested |= NRF_POLLIN;
   39140:	bf44      	itt	mi
   39142:	f043 0301 	orrmi.w	r3, r3, #1
   39146:	8093      	strhmi	r3, [r2, #4]
		if (fds[i].events & POLLOUT) {
   39148:	0743      	lsls	r3, r0, #29
			tmp[i].requested |= NRF_POLLOUT;
   3914a:	bf48      	it	mi
   3914c:	8893      	ldrhmi	r3, [r2, #4]
   3914e:	f102 0208 	add.w	r2, r2, #8
   39152:	bf44      	itt	mi
   39154:	f043 0302 	orrmi.w	r3, r3, #2
   39158:	f822 3c04 	strhmi.w	r3, [r2, #-4]
   3915c:	e7d7      	b.n	3910e <nrf91_socket_offload_poll+0x1a>
		if (tmp[i].returned & NRF_POLLIN) {
   3915e:	eb0d 01c2 	add.w	r1, sp, r2, lsl #3
   39162:	88c9      	ldrh	r1, [r1, #6]
		fds[i].revents = 0;
   39164:	80de      	strh	r6, [r3, #6]
		if (tmp[i].returned & NRF_POLLIN) {
   39166:	07cd      	lsls	r5, r1, #31
			fds[i].revents |= POLLIN;
   39168:	bf48      	it	mi
   3916a:	80df      	strhmi	r7, [r3, #6]
		if (tmp[i].returned & NRF_POLLOUT) {
   3916c:	078d      	lsls	r5, r1, #30
			fds[i].revents |= POLLOUT;
   3916e:	bf48      	it	mi
   39170:	88dd      	ldrhmi	r5, [r3, #6]
	for (int i = 0; i < nfds; i++) {
   39172:	f102 0201 	add.w	r2, r2, #1
			fds[i].revents |= POLLOUT;
   39176:	bf44      	itt	mi
   39178:	f045 0504 	orrmi.w	r5, r5, #4
   3917c:	80dd      	strhmi	r5, [r3, #6]
		if (tmp[i].returned & NRF_POLLERR) {
   3917e:	074d      	lsls	r5, r1, #29
			fds[i].revents |= POLLERR;
   39180:	bf48      	it	mi
   39182:	88dd      	ldrhmi	r5, [r3, #6]
   39184:	f103 0308 	add.w	r3, r3, #8
   39188:	bf44      	itt	mi
   3918a:	f045 0508 	orrmi.w	r5, r5, #8
   3918e:	f823 5c02 	strhmi.w	r5, [r3, #-2]
		if (tmp[i].returned & NRF_POLLNVAL) {
   39192:	06cd      	lsls	r5, r1, #27
			fds[i].revents |= POLLNVAL;
   39194:	bf42      	ittt	mi
   39196:	f833 5c02 	ldrhmi.w	r5, [r3, #-2]
   3919a:	f045 0520 	orrmi.w	r5, r5, #32
   3919e:	f823 5c02 	strhmi.w	r5, [r3, #-2]
		if (tmp[i].returned & NRF_POLLHUP) {
   391a2:	0709      	lsls	r1, r1, #28
			fds[i].revents |= POLLHUP;
   391a4:	bf42      	ittt	mi
   391a6:	f833 1c02 	ldrhmi.w	r1, [r3, #-2]
   391aa:	f041 0110 	orrmi.w	r1, r1, #16
   391ae:	f823 1c02 	strhmi.w	r1, [r3, #-2]
   391b2:	e7b7      	b.n	39124 <nrf91_socket_offload_poll+0x30>

000391b4 <nrf91_socket_offload_listen>:
	return nrf_listen(sd, backlog);
   391b4:	f7f4 bd86 	b.w	2dcc4 <nrf_listen>

000391b8 <nrf91_socket_offload_close>:
	return nrf_close(sd);
   391b8:	f7f4 bcf8 	b.w	2dbac <nrf_close>

000391bc <nrf91_socket_offload_fcntl>:
	switch (cmd) {
   391bc:	2903      	cmp	r1, #3
{
   391be:	b508      	push	{r3, lr}
	switch (cmd) {
   391c0:	d00b      	beq.n	391da <nrf91_socket_offload_fcntl+0x1e>
   391c2:	2904      	cmp	r1, #4
   391c4:	d111      	bne.n	391ea <nrf91_socket_offload_fcntl+0x2e>
		flags = va_arg(args, int);
   391c6:	6812      	ldr	r2, [r2, #0]
		if (flags != 0 && flags != O_NONBLOCK)
   391c8:	f432 4380 	bics.w	r3, r2, #16384	; 0x4000
   391cc:	d10d      	bne.n	391ea <nrf91_socket_offload_fcntl+0x2e>
}
   391ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		retval = nrf_fcntl(fd, NRF_F_SETFL, flags);
   391d2:	1392      	asrs	r2, r2, #14
   391d4:	2101      	movs	r1, #1
   391d6:	f7f4 bdeb 	b.w	2ddb0 <nrf_fcntl>
		flags = nrf_fcntl(fd, NRF_F_GETFL, 0);
   391da:	2200      	movs	r2, #0
   391dc:	2102      	movs	r1, #2
   391de:	f7f4 fde7 	bl	2ddb0 <nrf_fcntl>
		retval = (flags & NRF_O_NONBLOCK) ? O_NONBLOCK : 0;
   391e2:	0380      	lsls	r0, r0, #14
   391e4:	f400 4080 	and.w	r0, r0, #16384	; 0x4000
}
   391e8:	bd08      	pop	{r3, pc}
	errno = EINVAL;
   391ea:	f7fe ff64 	bl	380b6 <__errno>
   391ee:	2316      	movs	r3, #22
   391f0:	6003      	str	r3, [r0, #0]
	return retval;
   391f2:	f04f 30ff 	mov.w	r0, #4294967295
   391f6:	e7f7      	b.n	391e8 <nrf91_socket_offload_fcntl+0x2c>

000391f8 <nrf_to_z_ipv6>:
	ptr->sin6_port = nrf_in->sin6_port;
   391f8:	890b      	ldrh	r3, [r1, #8]
	ptr->sin6_family = AF_INET6;
   391fa:	2202      	movs	r2, #2
	ptr->sin6_port = nrf_in->sin6_port;
   391fc:	8043      	strh	r3, [r0, #2]
	ptr->sin6_family = AF_INET6;
   391fe:	4603      	mov	r3, r0
{
   39200:	b530      	push	{r4, r5, lr}
	ptr->sin6_family = AF_INET6;
   39202:	f823 2b04 	strh.w	r2, [r3], #4
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   39206:	f101 0210 	add.w	r2, r1, #16
   3920a:	f102 0410 	add.w	r4, r2, #16
   3920e:	f852 5b04 	ldr.w	r5, [r2], #4
   39212:	42a2      	cmp	r2, r4
   39214:	f843 5b04 	str.w	r5, [r3], #4
   39218:	d1f9      	bne.n	3920e <nrf_to_z_ipv6+0x16>
	ptr->sin6_scope_id = (u8_t)nrf_in->sin6_scope_id;
   3921a:	6a0b      	ldr	r3, [r1, #32]
   3921c:	7503      	strb	r3, [r0, #20]
}
   3921e:	bd30      	pop	{r4, r5, pc}

00039220 <nrf91_socket_offload_getaddrinfo>:
{
   39220:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   39224:	4614      	mov	r4, r2
   39226:	460e      	mov	r6, r1
	struct nrf_addrinfo *nrf_res = NULL;
   39228:	2100      	movs	r1, #0
{
   3922a:	b093      	sub	sp, #76	; 0x4c
   3922c:	4605      	mov	r5, r0
	memset(&nrf_hints, 0, sizeof(struct nrf_addrinfo));
   3922e:	2220      	movs	r2, #32
   39230:	a802      	add	r0, sp, #8
{
   39232:	461f      	mov	r7, r3
	struct nrf_addrinfo *nrf_res = NULL;
   39234:	9101      	str	r1, [sp, #4]
	memset(&nrf_hints, 0, sizeof(struct nrf_addrinfo));
   39236:	f000 fdc2 	bl	39dbe <memset>
	if (hints != NULL) {
   3923a:	b194      	cbz	r4, 39262 <nrf91_socket_offload_getaddrinfo+0x42>
		error = z_to_nrf_addrinfo_hints(hints, &nrf_hints);
   3923c:	a902      	add	r1, sp, #8
   3923e:	4620      	mov	r0, r4
   39240:	f7ff febf 	bl	38fc2 <z_to_nrf_addrinfo_hints>
		if (error == -EPROTONOSUPPORT) {
   39244:	f110 0f7b 	cmn.w	r0, #123	; 0x7b
   39248:	f000 80bf 	beq.w	393ca <nrf91_socket_offload_getaddrinfo+0x1aa>
		} else if (error == -EAFNOSUPPORT) {
   3924c:	306a      	adds	r0, #106	; 0x6a
   3924e:	f000 80bf 	beq.w	393d0 <nrf91_socket_offload_getaddrinfo+0x1b0>
		if (hints->ai_next != NULL) {
   39252:	69e0      	ldr	r0, [r4, #28]
   39254:	b120      	cbz	r0, 39260 <nrf91_socket_offload_getaddrinfo+0x40>
			z_to_nrf_addrinfo_hints(hints->ai_next, &nrf_hints_pdn);
   39256:	ac0a      	add	r4, sp, #40	; 0x28
   39258:	4621      	mov	r1, r4
   3925a:	f7ff feb2 	bl	38fc2 <z_to_nrf_addrinfo_hints>
			nrf_hints.ai_next = &nrf_hints_pdn;
   3925e:	9409      	str	r4, [sp, #36]	; 0x24
		nrf_hints_ptr = &nrf_hints;
   39260:	ac02      	add	r4, sp, #8
	int retval = nrf_getaddrinfo(node, service, nrf_hints_ptr, &nrf_res);
   39262:	4628      	mov	r0, r5
   39264:	ab01      	add	r3, sp, #4
   39266:	4622      	mov	r2, r4
   39268:	4631      	mov	r1, r6
   3926a:	f7f4 fd9b 	bl	2dda4 <nrf_getaddrinfo>
	if (retval != 0) {
   3926e:	4605      	mov	r5, r0
   39270:	b1b0      	cbz	r0, 392a0 <nrf91_socket_offload_getaddrinfo+0x80>
	switch (nrf_error) {
   39272:	2823      	cmp	r0, #35	; 0x23
   39274:	f000 80af 	beq.w	393d6 <nrf91_socket_offload_getaddrinfo+0x1b6>
   39278:	dc0a      	bgt.n	39290 <nrf91_socket_offload_getaddrinfo+0x70>
		return DNS_EAI_SYSTEM;
   3927a:	280c      	cmp	r0, #12
   3927c:	bf08      	it	eq
   3927e:	f06f 0509 	mvneq.w	r5, #9
   39282:	bf18      	it	ne
   39284:	f06f 050a 	mvnne.w	r5, #10
}
   39288:	4628      	mov	r0, r5
   3928a:	b013      	add	sp, #76	; 0x4c
   3928c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	switch (nrf_error) {
   39290:	282f      	cmp	r0, #47	; 0x2f
   39292:	f000 80a3 	beq.w	393dc <nrf91_socket_offload_getaddrinfo+0x1bc>
		return DNS_EAI_SYSTEM;
   39296:	2873      	cmp	r0, #115	; 0x73
   39298:	bf08      	it	eq
   3929a:	f06f 0563 	mvneq.w	r5, #99	; 0x63
   3929e:	e7f0      	b.n	39282 <nrf91_socket_offload_getaddrinfo+0x62>
	struct addrinfo *latest_z_res = NULL;
   392a0:	4680      	mov	r8, r0
	z_out->ai_next = NULL;
   392a2:	4681      	mov	r9, r0
	struct nrf_addrinfo *next_nrf_res = nrf_res;
   392a4:	9e01      	ldr	r6, [sp, #4]
	*res = NULL;
   392a6:	6038      	str	r0, [r7, #0]
	while ((retval == 0) && (next_nrf_res != NULL)) {
   392a8:	b91e      	cbnz	r6, 392b2 <nrf91_socket_offload_getaddrinfo+0x92>
	nrf_freeaddrinfo(nrf_res);
   392aa:	9801      	ldr	r0, [sp, #4]
   392ac:	f7f4 fd7c 	bl	2dda8 <nrf_freeaddrinfo>
	return retval;
   392b0:	e7ea      	b.n	39288 <nrf91_socket_offload_getaddrinfo+0x68>
		struct addrinfo *next_z_res = k_malloc(sizeof(struct addrinfo));
   392b2:	2020      	movs	r0, #32
   392b4:	f7f9 fbb4 	bl	32a20 <k_malloc>
		if (next_z_res == NULL) {
   392b8:	4604      	mov	r4, r0
   392ba:	2800      	cmp	r0, #0
   392bc:	d07a      	beq.n	393b4 <nrf91_socket_offload_getaddrinfo+0x194>
	family = nrf_to_z_family(nrf_in->ai_family);
   392be:	6872      	ldr	r2, [r6, #4]
	z_out->ai_socktype = nrf_in->ai_socktype;
   392c0:	68b3      	ldr	r3, [r6, #8]
	switch (nrf_family) {
   392c2:	2a05      	cmp	r2, #5
	z_out->ai_canonname = NULL; /* TODO Do proper content copy. */
   392c4:	e9c0 9906 	strd	r9, r9, [r0, #24]
	z_out->ai_flags = nrf_to_z_addrinfo_flags(nrf_in->ai_flags);
   392c8:	f8c0 9000 	str.w	r9, [r0]
	z_out->ai_socktype = nrf_in->ai_socktype;
   392cc:	6083      	str	r3, [r0, #8]
	switch (nrf_family) {
   392ce:	d033      	beq.n	39338 <nrf91_socket_offload_getaddrinfo+0x118>
   392d0:	dc09      	bgt.n	392e6 <nrf91_socket_offload_getaddrinfo+0xc6>
   392d2:	2a01      	cmp	r2, #1
   392d4:	d032      	beq.n	3933c <nrf91_socket_offload_getaddrinfo+0x11c>
   392d6:	2a02      	cmp	r2, #2
   392d8:	d032      	beq.n	39340 <nrf91_socket_offload_getaddrinfo+0x120>
			k_free(next_z_res);
   392da:	4620      	mov	r0, r4
   392dc:	f000 fb84 	bl	399e8 <k_free>
			retval = DNS_EAI_ADDRFAMILY;
   392e0:	f06f 0508 	mvn.w	r5, #8
   392e4:	e068      	b.n	393b8 <nrf91_socket_offload_getaddrinfo+0x198>
	switch (nrf_family) {
   392e6:	2a0a      	cmp	r2, #10
   392e8:	d02c      	beq.n	39344 <nrf91_socket_offload_getaddrinfo+0x124>
   392ea:	2a66      	cmp	r2, #102	; 0x66
   392ec:	d1f5      	bne.n	392da <nrf91_socket_offload_getaddrinfo+0xba>
		return AF_LTE;
   392ee:	4613      	mov	r3, r2
	z_out->ai_family = family;
   392f0:	6063      	str	r3, [r4, #4]
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   392f2:	68f3      	ldr	r3, [r6, #12]
	switch (proto) {
   392f4:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
   392f8:	d045      	beq.n	39386 <nrf91_socket_offload_getaddrinfo+0x166>
   392fa:	dc25      	bgt.n	39348 <nrf91_socket_offload_getaddrinfo+0x128>
   392fc:	2b01      	cmp	r3, #1
   392fe:	d047      	beq.n	39390 <nrf91_socket_offload_getaddrinfo+0x170>
   39300:	2b02      	cmp	r3, #2
   39302:	d043      	beq.n	3938c <nrf91_socket_offload_getaddrinfo+0x16c>
   39304:	bb43      	cbnz	r3, 39358 <nrf91_socket_offload_getaddrinfo+0x138>
	if (nrf_in->ai_family == NRF_AF_INET) {
   39306:	2a02      	cmp	r2, #2
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   39308:	60e3      	str	r3, [r4, #12]
	if (nrf_in->ai_family == NRF_AF_INET) {
   3930a:	d143      	bne.n	39394 <nrf91_socket_offload_getaddrinfo+0x174>
		z_out->ai_addr = k_malloc(sizeof(struct sockaddr_in));
   3930c:	2008      	movs	r0, #8
   3930e:	f7f9 fb87 	bl	32a20 <k_malloc>
   39312:	6160      	str	r0, [r4, #20]
		if (z_out->ai_addr == NULL) {
   39314:	2800      	cmp	r0, #0
   39316:	d04a      	beq.n	393ae <nrf91_socket_offload_getaddrinfo+0x18e>
		z_out->ai_addrlen  = sizeof(struct sockaddr_in);
   39318:	2308      	movs	r3, #8
   3931a:	6123      	str	r3, [r4, #16]
			(const struct nrf_sockaddr_in *)nrf_in->ai_addr);
   3931c:	6973      	ldr	r3, [r6, #20]
	ptr->sin_port = nrf_in->sin_port;
   3931e:	891a      	ldrh	r2, [r3, #8]
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   39320:	68db      	ldr	r3, [r3, #12]
	ptr->sin_port = nrf_in->sin_port;
   39322:	8042      	strh	r2, [r0, #2]
	ptr->sin_family = AF_INET;
   39324:	2201      	movs	r2, #1
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   39326:	6043      	str	r3, [r0, #4]
	ptr->sin_family = AF_INET;
   39328:	8002      	strh	r2, [r0, #0]
		if (latest_z_res == NULL) {
   3932a:	f1b8 0f00 	cmp.w	r8, #0
   3932e:	d149      	bne.n	393c4 <nrf91_socket_offload_getaddrinfo+0x1a4>
			*res = next_z_res;
   39330:	603c      	str	r4, [r7, #0]
		next_nrf_res = next_nrf_res->ai_next;
   39332:	69f6      	ldr	r6, [r6, #28]
   39334:	46a0      	mov	r8, r4
   39336:	e7b7      	b.n	392a8 <nrf91_socket_offload_getaddrinfo+0x88>
		return AF_PACKET;
   39338:	2303      	movs	r3, #3
   3933a:	e7d9      	b.n	392f0 <nrf91_socket_offload_getaddrinfo+0xd0>
		return AF_LOCAL;
   3933c:	2367      	movs	r3, #103	; 0x67
   3933e:	e7d7      	b.n	392f0 <nrf91_socket_offload_getaddrinfo+0xd0>
		return AF_INET;
   39340:	2301      	movs	r3, #1
   39342:	e7d5      	b.n	392f0 <nrf91_socket_offload_getaddrinfo+0xd0>
		return AF_INET6;
   39344:	2302      	movs	r3, #2
   39346:	e7d3      	b.n	392f0 <nrf91_socket_offload_getaddrinfo+0xd0>
	switch (proto) {
   39348:	f240 2101 	movw	r1, #513	; 0x201
   3934c:	428b      	cmp	r3, r1
   3934e:	d0da      	beq.n	39306 <nrf91_socket_offload_getaddrinfo+0xe6>
   39350:	dc0d      	bgt.n	3936e <nrf91_socket_offload_getaddrinfo+0x14e>
   39352:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   39356:	d013      	beq.n	39380 <nrf91_socket_offload_getaddrinfo+0x160>
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   39358:	f06f 037a 	mvn.w	r3, #122	; 0x7a
   3935c:	60e3      	str	r3, [r4, #12]
		z_out->ai_addr = NULL;
   3935e:	2300      	movs	r3, #0
   39360:	6163      	str	r3, [r4, #20]
			k_free(next_z_res);
   39362:	4620      	mov	r0, r4
   39364:	f000 fb40 	bl	399e8 <k_free>
			retval = DNS_EAI_SOCKTYPE;
   39368:	f06f 0506 	mvn.w	r5, #6
   3936c:	e024      	b.n	393b8 <nrf91_socket_offload_getaddrinfo+0x198>
	switch (proto) {
   3936e:	f240 2102 	movw	r1, #514	; 0x202
   39372:	428b      	cmp	r3, r1
   39374:	d0c7      	beq.n	39306 <nrf91_socket_offload_getaddrinfo+0xe6>
   39376:	f240 2103 	movw	r1, #515	; 0x203
   3937a:	428b      	cmp	r3, r1
   3937c:	d0c3      	beq.n	39306 <nrf91_socket_offload_getaddrinfo+0xe6>
   3937e:	e7eb      	b.n	39358 <nrf91_socket_offload_getaddrinfo+0x138>
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   39380:	f240 1311 	movw	r3, #273	; 0x111
   39384:	e7bf      	b.n	39306 <nrf91_socket_offload_getaddrinfo+0xe6>
   39386:	f44f 7381 	mov.w	r3, #258	; 0x102
   3938a:	e7bc      	b.n	39306 <nrf91_socket_offload_getaddrinfo+0xe6>
   3938c:	2311      	movs	r3, #17
   3938e:	e7ba      	b.n	39306 <nrf91_socket_offload_getaddrinfo+0xe6>
   39390:	2306      	movs	r3, #6
   39392:	e7b8      	b.n	39306 <nrf91_socket_offload_getaddrinfo+0xe6>
	} else if (nrf_in->ai_family == NRF_AF_INET6) {
   39394:	2a0a      	cmp	r2, #10
   39396:	d1e4      	bne.n	39362 <nrf91_socket_offload_getaddrinfo+0x142>
		z_out->ai_addr = k_malloc(sizeof(struct sockaddr_in6));
   39398:	2018      	movs	r0, #24
   3939a:	f7f9 fb41 	bl	32a20 <k_malloc>
   3939e:	6160      	str	r0, [r4, #20]
		if (z_out->ai_addr == NULL) {
   393a0:	b128      	cbz	r0, 393ae <nrf91_socket_offload_getaddrinfo+0x18e>
		z_out->ai_addrlen  = sizeof(struct sockaddr_in6);
   393a2:	2318      	movs	r3, #24
		nrf_to_z_ipv6(z_out->ai_addr,
   393a4:	6971      	ldr	r1, [r6, #20]
		z_out->ai_addrlen  = sizeof(struct sockaddr_in6);
   393a6:	6123      	str	r3, [r4, #16]
		nrf_to_z_ipv6(z_out->ai_addr,
   393a8:	f7ff ff26 	bl	391f8 <nrf_to_z_ipv6>
		} else if (error == -EAFNOSUPPORT) {
   393ac:	e7bd      	b.n	3932a <nrf91_socket_offload_getaddrinfo+0x10a>
			k_free(next_z_res);
   393ae:	4620      	mov	r0, r4
   393b0:	f000 fb1a 	bl	399e8 <k_free>
			retval = DNS_EAI_MEMORY;
   393b4:	f06f 0509 	mvn.w	r5, #9
		nrf91_socket_offload_freeaddrinfo(*res);
   393b8:	6838      	ldr	r0, [r7, #0]
   393ba:	f7ff fdf5 	bl	38fa8 <nrf91_socket_offload_freeaddrinfo>
		*res = NULL;
   393be:	2300      	movs	r3, #0
   393c0:	603b      	str	r3, [r7, #0]
   393c2:	e772      	b.n	392aa <nrf91_socket_offload_getaddrinfo+0x8a>
			latest_z_res->ai_next = next_z_res;
   393c4:	f8c8 401c 	str.w	r4, [r8, #28]
   393c8:	e7b3      	b.n	39332 <nrf91_socket_offload_getaddrinfo+0x112>
			return DNS_EAI_SOCKTYPE;
   393ca:	f06f 0506 	mvn.w	r5, #6
   393ce:	e75b      	b.n	39288 <nrf91_socket_offload_getaddrinfo+0x68>
			return DNS_EAI_ADDRFAMILY;
   393d0:	f06f 0508 	mvn.w	r5, #8
   393d4:	e758      	b.n	39288 <nrf91_socket_offload_getaddrinfo+0x68>
		return DNS_EAI_AGAIN;
   393d6:	f06f 0502 	mvn.w	r5, #2
   393da:	e755      	b.n	39288 <nrf91_socket_offload_getaddrinfo+0x68>
		return DNS_EAI_NONAME;
   393dc:	f06f 0501 	mvn.w	r5, #1
   393e0:	e752      	b.n	39288 <nrf91_socket_offload_getaddrinfo+0x68>

000393e2 <z_to_nrf_ipv6>:
	nrf_out->sin6_len = sizeof(struct nrf_sockaddr_in6);
   393e2:	2224      	movs	r2, #36	; 0x24
{
   393e4:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_out->sin6_len = sizeof(struct nrf_sockaddr_in6);
   393e6:	700a      	strb	r2, [r1, #0]
	nrf_out->sin6_port = ptr->sin6_port;
   393e8:	8842      	ldrh	r2, [r0, #2]
{
   393ea:	4604      	mov	r4, r0
	nrf_out->sin6_port = ptr->sin6_port;
   393ec:	810a      	strh	r2, [r1, #8]
	nrf_out->sin6_family = NRF_AF_INET6;
   393ee:	220a      	movs	r2, #10
{
   393f0:	460b      	mov	r3, r1
	nrf_out->sin6_family = NRF_AF_INET6;
   393f2:	604a      	str	r2, [r1, #4]
   393f4:	f101 0610 	add.w	r6, r1, #16
   393f8:	1d02      	adds	r2, r0, #4
   393fa:	f100 0714 	add.w	r7, r0, #20
   393fe:	4635      	mov	r5, r6
   39400:	6810      	ldr	r0, [r2, #0]
   39402:	6851      	ldr	r1, [r2, #4]
   39404:	3208      	adds	r2, #8
   39406:	c503      	stmia	r5!, {r0, r1}
   39408:	42ba      	cmp	r2, r7
   3940a:	462e      	mov	r6, r5
   3940c:	d1f7      	bne.n	393fe <z_to_nrf_ipv6+0x1c>
	nrf_out->sin6_scope_id = (u32_t)ptr->sin6_scope_id;
   3940e:	7d22      	ldrb	r2, [r4, #20]
   39410:	621a      	str	r2, [r3, #32]
}
   39412:	bdf0      	pop	{r4, r5, r6, r7, pc}

00039414 <nrf91_socket_offload_sendto>:
{
   39414:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   39418:	b08d      	sub	sp, #52	; 0x34
   3941a:	9c14      	ldr	r4, [sp, #80]	; 0x50
   3941c:	4605      	mov	r5, r0
   3941e:	460e      	mov	r6, r1
   39420:	4617      	mov	r7, r2
   39422:	4698      	mov	r8, r3
	if (to == NULL) {
   39424:	b96c      	cbnz	r4, 39442 <nrf91_socket_offload_sendto+0x2e>
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), NULL,
   39426:	4618      	mov	r0, r3
   39428:	f7ff fd74 	bl	38f14 <z_to_nrf_flags>
   3942c:	e9cd 4400 	strd	r4, r4, [sp]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv6,
   39430:	4603      	mov	r3, r0
   39432:	463a      	mov	r2, r7
   39434:	4631      	mov	r1, r6
   39436:	4628      	mov	r0, r5
   39438:	f7f4 fbc6 	bl	2dbc8 <nrf_sendto>
}
   3943c:	b00d      	add	sp, #52	; 0x34
   3943e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if (to->sa_family == AF_INET) {
   39442:	8823      	ldrh	r3, [r4, #0]
   39444:	2b01      	cmp	r3, #1
   39446:	d110      	bne.n	3946a <nrf91_socket_offload_sendto+0x56>
	nrf_out->sin_port = ptr->sin_port;
   39448:	8863      	ldrh	r3, [r4, #2]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   3944a:	2110      	movs	r1, #16
	nrf_out->sin_port = ptr->sin_port;
   3944c:	f8ad 3014 	strh.w	r3, [sp, #20]
	nrf_out->sin_family = NRF_AF_INET;
   39450:	2302      	movs	r3, #2
   39452:	9304      	str	r3, [sp, #16]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   39454:	6863      	ldr	r3, [r4, #4]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv4,
   39456:	4640      	mov	r0, r8
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   39458:	9306      	str	r3, [sp, #24]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   3945a:	f88d 100c 	strb.w	r1, [sp, #12]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv4,
   3945e:	f7ff fd59 	bl	38f14 <z_to_nrf_flags>
   39462:	ab03      	add	r3, sp, #12
   39464:	9101      	str	r1, [sp, #4]
   39466:	9300      	str	r3, [sp, #0]
   39468:	e7e2      	b.n	39430 <nrf91_socket_offload_sendto+0x1c>
	} else if (to->sa_family == AF_INET6) {
   3946a:	2b02      	cmp	r3, #2
   3946c:	d10c      	bne.n	39488 <nrf91_socket_offload_sendto+0x74>
		z_to_nrf_ipv6(to, &ipv6);
   3946e:	f10d 090c 	add.w	r9, sp, #12
   39472:	4649      	mov	r1, r9
   39474:	4620      	mov	r0, r4
   39476:	f7ff ffb4 	bl	393e2 <z_to_nrf_ipv6>
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv6,
   3947a:	4640      	mov	r0, r8
   3947c:	f7ff fd4a 	bl	38f14 <z_to_nrf_flags>
   39480:	2324      	movs	r3, #36	; 0x24
   39482:	e9cd 9300 	strd	r9, r3, [sp]
   39486:	e7d3      	b.n	39430 <nrf91_socket_offload_sendto+0x1c>
	errno = ENOTSUP;
   39488:	f7fe fe15 	bl	380b6 <__errno>
   3948c:	2386      	movs	r3, #134	; 0x86
   3948e:	6003      	str	r3, [r0, #0]
	return retval;
   39490:	f04f 30ff 	mov.w	r0, #4294967295
   39494:	e7d2      	b.n	3943c <nrf91_socket_offload_sendto+0x28>

00039496 <nrf91_socket_offload_recvfrom>:
{
   39496:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3949a:	4605      	mov	r5, r0
   3949c:	b08c      	sub	sp, #48	; 0x30
   3949e:	4618      	mov	r0, r3
   394a0:	e9dd 4612 	ldrd	r4, r6, [sp, #72]	; 0x48
   394a4:	4690      	mov	r8, r2
	if (from == NULL) {
   394a6:	f7ff fd35 	bl	38f14 <z_to_nrf_flags>
   394aa:	4603      	mov	r3, r0
   394ac:	b954      	cbnz	r4, 394c4 <nrf91_socket_offload_recvfrom+0x2e>
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags), NULL,
   394ae:	4628      	mov	r0, r5
   394b0:	e9cd 4400 	strd	r4, r4, [sp]
   394b4:	4642      	mov	r2, r8
   394b6:	f7f4 fbbd 	bl	2dc34 <nrf_recvfrom>
   394ba:	4605      	mov	r5, r0
}
   394bc:	4628      	mov	r0, r5
   394be:	b00c      	add	sp, #48	; 0x30
   394c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		nrf_socklen_t sock_len = sizeof(struct nrf_sockaddr_in6);
   394c4:	2224      	movs	r2, #36	; 0x24
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags),
   394c6:	af03      	add	r7, sp, #12
		nrf_socklen_t sock_len = sizeof(struct nrf_sockaddr_in6);
   394c8:	9202      	str	r2, [sp, #8]
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags),
   394ca:	aa02      	add	r2, sp, #8
   394cc:	9201      	str	r2, [sp, #4]
   394ce:	4628      	mov	r0, r5
   394d0:	9700      	str	r7, [sp, #0]
   394d2:	4642      	mov	r2, r8
   394d4:	f7f4 fbae 	bl	2dc34 <nrf_recvfrom>
		if (cliaddr->sa_family == NRF_AF_INET) {
   394d8:	9b04      	ldr	r3, [sp, #16]
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags),
   394da:	4605      	mov	r5, r0
		if (cliaddr->sa_family == NRF_AF_INET) {
   394dc:	2b02      	cmp	r3, #2
   394de:	d109      	bne.n	394f4 <nrf91_socket_offload_recvfrom+0x5e>
	ptr->sin_port = nrf_in->sin_port;
   394e0:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   394e4:	8063      	strh	r3, [r4, #2]
	ptr->sin_family = AF_INET;
   394e6:	2301      	movs	r3, #1
   394e8:	8023      	strh	r3, [r4, #0]
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   394ea:	9b06      	ldr	r3, [sp, #24]
   394ec:	6063      	str	r3, [r4, #4]
			*fromlen = sizeof(struct sockaddr_in);
   394ee:	2308      	movs	r3, #8
			*fromlen = sizeof(struct sockaddr_in6);
   394f0:	6033      	str	r3, [r6, #0]
	return retval;
   394f2:	e7e3      	b.n	394bc <nrf91_socket_offload_recvfrom+0x26>
		} else if (cliaddr->sa_family == NRF_AF_INET6) {
   394f4:	2b0a      	cmp	r3, #10
   394f6:	d1e1      	bne.n	394bc <nrf91_socket_offload_recvfrom+0x26>
			nrf_to_z_ipv6(from, (struct nrf_sockaddr_in6 *)
   394f8:	4639      	mov	r1, r7
   394fa:	4620      	mov	r0, r4
   394fc:	f7ff fe7c 	bl	391f8 <nrf_to_z_ipv6>
			*fromlen = sizeof(struct sockaddr_in6);
   39500:	2318      	movs	r3, #24
   39502:	e7f5      	b.n	394f0 <nrf91_socket_offload_recvfrom+0x5a>

00039504 <nrf91_socket_offload_connect>:
{
   39504:	b530      	push	{r4, r5, lr}
	if (addr->sa_family == AF_INET) {
   39506:	880c      	ldrh	r4, [r1, #0]
{
   39508:	b08b      	sub	sp, #44	; 0x2c
	if (addr->sa_family == AF_INET) {
   3950a:	2c01      	cmp	r4, #1
{
   3950c:	4605      	mov	r5, r0
   3950e:	460b      	mov	r3, r1
	if (addr->sa_family == AF_INET) {
   39510:	d10e      	bne.n	39530 <nrf91_socket_offload_connect+0x2c>
	nrf_out->sin_port = ptr->sin_port;
   39512:	8849      	ldrh	r1, [r1, #2]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   39514:	2210      	movs	r2, #16
	nrf_out->sin_port = ptr->sin_port;
   39516:	f8ad 100c 	strh.w	r1, [sp, #12]
	nrf_out->sin_family = NRF_AF_INET;
   3951a:	2102      	movs	r1, #2
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   3951c:	685b      	ldr	r3, [r3, #4]
	nrf_out->sin_family = NRF_AF_INET;
   3951e:	9102      	str	r1, [sp, #8]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   39520:	f88d 2004 	strb.w	r2, [sp, #4]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   39524:	9304      	str	r3, [sp, #16]
		retval = nrf_connect(sd, (const struct nrf_sockaddr_in *)&ipv4,
   39526:	a901      	add	r1, sp, #4
		retval = nrf_connect(sd, (const struct nrf_sockaddr *)&ipv6,
   39528:	f7f4 fbba 	bl	2dca0 <nrf_connect>
}
   3952c:	b00b      	add	sp, #44	; 0x2c
   3952e:	bd30      	pop	{r4, r5, pc}
	} else if (addr->sa_family == AF_INET6) {
   39530:	2c02      	cmp	r4, #2
   39532:	d107      	bne.n	39544 <nrf91_socket_offload_connect+0x40>
		z_to_nrf_ipv6(addr, &ipv6);
   39534:	a901      	add	r1, sp, #4
   39536:	4618      	mov	r0, r3
   39538:	f7ff ff53 	bl	393e2 <z_to_nrf_ipv6>
		retval = nrf_connect(sd, (const struct nrf_sockaddr *)&ipv6,
   3953c:	2224      	movs	r2, #36	; 0x24
   3953e:	a901      	add	r1, sp, #4
   39540:	4628      	mov	r0, r5
   39542:	e7f1      	b.n	39528 <nrf91_socket_offload_connect+0x24>
		retval = nrf_connect(sd, (void *)addr, addrlen);
   39544:	f7f4 fbac 	bl	2dca0 <nrf_connect>
		if (retval < 0) {
   39548:	2800      	cmp	r0, #0
   3954a:	daef      	bge.n	3952c <nrf91_socket_offload_connect+0x28>
	errno = ENOTSUP;
   3954c:	f7fe fdb3 	bl	380b6 <__errno>
   39550:	2386      	movs	r3, #134	; 0x86
   39552:	6003      	str	r3, [r0, #0]
   39554:	f04f 30ff 	mov.w	r0, #4294967295
   39558:	e7e8      	b.n	3952c <nrf91_socket_offload_connect+0x28>

0003955a <nrf91_socket_offload_accept>:
{
   3955a:	b5f0      	push	{r4, r5, r6, r7, lr}
   3955c:	4616      	mov	r6, r2
   3955e:	b08b      	sub	sp, #44	; 0x2c
	if ((addr != NULL) && (addrlen != NULL)) {
   39560:	460c      	mov	r4, r1
   39562:	b1f1      	cbz	r1, 395a2 <nrf91_socket_offload_accept+0x48>
   39564:	b302      	cbz	r2, 395a8 <nrf91_socket_offload_accept+0x4e>
		if (*addrlen == sizeof(struct sockaddr_in)) {
   39566:	6813      	ldr	r3, [r2, #0]
		nrf_addrlen_ptr = &nrf_addrlen;
   39568:	466a      	mov	r2, sp
		if (*addrlen == sizeof(struct sockaddr_in)) {
   3956a:	2b08      	cmp	r3, #8
			nrf_addrlen = sizeof(struct nrf_sockaddr_in);
   3956c:	bf0c      	ite	eq
   3956e:	2310      	moveq	r3, #16
			nrf_addrlen = sizeof(struct nrf_sockaddr_in6);
   39570:	2324      	movne	r3, #36	; 0x24
		nrf_addr_ptr = (struct nrf_sockaddr *)&nrf_addr;
   39572:	ad01      	add	r5, sp, #4
			nrf_addrlen = sizeof(struct nrf_sockaddr_in6);
   39574:	9300      	str	r3, [sp, #0]
	retval = nrf_accept(sd, nrf_addr_ptr, nrf_addrlen_ptr);
   39576:	4629      	mov	r1, r5
   39578:	f7f4 fbb4 	bl	2dce4 <nrf_accept>
	if (retval < 0) {
   3957c:	1e07      	subs	r7, r0, #0
   3957e:	db22      	blt.n	395c6 <nrf91_socket_offload_accept+0x6c>
	if ((addr != NULL) && (addrlen != NULL)) {
   39580:	b164      	cbz	r4, 3959c <nrf91_socket_offload_accept+0x42>
   39582:	b15e      	cbz	r6, 3959c <nrf91_socket_offload_accept+0x42>
		if (nrf_addr_ptr->sa_family == NRF_AF_INET) {
   39584:	686b      	ldr	r3, [r5, #4]
   39586:	2b02      	cmp	r3, #2
   39588:	d110      	bne.n	395ac <nrf91_socket_offload_accept+0x52>
			*addrlen = sizeof(struct sockaddr_in);
   3958a:	2308      	movs	r3, #8
   3958c:	6033      	str	r3, [r6, #0]
	ptr->sin_port = nrf_in->sin_port;
   3958e:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   39592:	8063      	strh	r3, [r4, #2]
	ptr->sin_family = AF_INET;
   39594:	2301      	movs	r3, #1
   39596:	8023      	strh	r3, [r4, #0]
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   39598:	9b04      	ldr	r3, [sp, #16]
   3959a:	6063      	str	r3, [r4, #4]
}
   3959c:	4638      	mov	r0, r7
   3959e:	b00b      	add	sp, #44	; 0x2c
   395a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	nrf_socklen_t *nrf_addrlen_ptr = NULL;
   395a2:	460a      	mov	r2, r1
	struct nrf_sockaddr *nrf_addr_ptr = NULL;
   395a4:	460d      	mov	r5, r1
   395a6:	e7e6      	b.n	39576 <nrf91_socket_offload_accept+0x1c>
   395a8:	4615      	mov	r5, r2
   395aa:	e7e4      	b.n	39576 <nrf91_socket_offload_accept+0x1c>
		} else if (nrf_addr_ptr->sa_family == NRF_AF_INET6) {
   395ac:	2b0a      	cmp	r3, #10
   395ae:	d106      	bne.n	395be <nrf91_socket_offload_accept+0x64>
			*addrlen = sizeof(struct sockaddr_in6);
   395b0:	2318      	movs	r3, #24
			nrf_to_z_ipv6(
   395b2:	a901      	add	r1, sp, #4
			*addrlen = sizeof(struct sockaddr_in6);
   395b4:	6033      	str	r3, [r6, #0]
			nrf_to_z_ipv6(
   395b6:	4620      	mov	r0, r4
   395b8:	f7ff fe1e 	bl	391f8 <nrf_to_z_ipv6>
   395bc:	e7ee      	b.n	3959c <nrf91_socket_offload_accept+0x42>
	errno = ENOTSUP;
   395be:	f7fe fd7a 	bl	380b6 <__errno>
   395c2:	2386      	movs	r3, #134	; 0x86
   395c4:	6003      	str	r3, [r0, #0]
		return -1;
   395c6:	f04f 37ff 	mov.w	r7, #4294967295
   395ca:	e7e7      	b.n	3959c <nrf91_socket_offload_accept+0x42>

000395cc <nrf91_socket_offload_socket>:
{
   395cc:	b510      	push	{r4, lr}
	family = z_to_nrf_family(family);
   395ce:	b280      	uxth	r0, r0
   395d0:	f7ff fcaa 	bl	38f28 <z_to_nrf_family>
	if (family == -EAFNOSUPPORT) {
   395d4:	f110 0f6a 	cmn.w	r0, #106	; 0x6a
	family = z_to_nrf_family(family);
   395d8:	4604      	mov	r4, r0
	if (family == -EAFNOSUPPORT) {
   395da:	d106      	bne.n	395ea <nrf91_socket_offload_socket+0x1e>
		errno = EAFNOSUPPORT;
   395dc:	f7fe fd6b 	bl	380b6 <__errno>
   395e0:	236a      	movs	r3, #106	; 0x6a
		errno = EPROTONOSUPPORT;
   395e2:	6003      	str	r3, [r0, #0]
}
   395e4:	f04f 30ff 	mov.w	r0, #4294967295
   395e8:	bd10      	pop	{r4, pc}
	switch (socktype) {
   395ea:	2903      	cmp	r1, #3
   395ec:	d003      	beq.n	395f6 <nrf91_socket_offload_socket+0x2a>
		return NRF_SOCK_MGMT;
   395ee:	2904      	cmp	r1, #4
   395f0:	bf08      	it	eq
   395f2:	f44f 7100 	moveq.w	r1, #512	; 0x200
	proto = z_to_nrf_protocol(proto);
   395f6:	4610      	mov	r0, r2
   395f8:	f7ff fcac 	bl	38f54 <z_to_nrf_protocol>
	if (proto == -EPROTONOSUPPORT) {
   395fc:	f110 0f7b 	cmn.w	r0, #123	; 0x7b
	proto = z_to_nrf_protocol(proto);
   39600:	4602      	mov	r2, r0
	if (proto == -EPROTONOSUPPORT) {
   39602:	d103      	bne.n	3960c <nrf91_socket_offload_socket+0x40>
		errno = EPROTONOSUPPORT;
   39604:	f7fe fd57 	bl	380b6 <__errno>
   39608:	237b      	movs	r3, #123	; 0x7b
   3960a:	e7ea      	b.n	395e2 <nrf91_socket_offload_socket+0x16>
	retval = nrf_socket(family, type, proto);
   3960c:	4620      	mov	r0, r4
}
   3960e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	retval = nrf_socket(family, type, proto);
   39612:	f7f4 bab9 	b.w	2db88 <nrf_socket>

00039616 <nrf91_socket_offload_setsockopt>:
{
   39616:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	switch (z_in_level) {
   3961a:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
{
   3961e:	b086      	sub	sp, #24
   39620:	4680      	mov	r8, r0
   39622:	460c      	mov	r4, r1
   39624:	4617      	mov	r7, r2
   39626:	461d      	mov	r5, r3
   39628:	9e0c      	ldr	r6, [sp, #48]	; 0x30
	switch (z_in_level) {
   3962a:	d002      	beq.n	39632 <nrf91_socket_offload_setsockopt+0x1c>
   3962c:	dc1c      	bgt.n	39668 <nrf91_socket_offload_setsockopt+0x52>
   3962e:	2901      	cmp	r1, #1
   39630:	d122      	bne.n	39678 <nrf91_socket_offload_setsockopt+0x62>
	if (z_to_nrf_optname(level, optname, &nrf_optname) < 0)
   39632:	aa03      	add	r2, sp, #12
   39634:	4639      	mov	r1, r7
   39636:	4620      	mov	r0, r4
   39638:	f7ee fb40 	bl	27cbc <z_to_nrf_optname>
   3963c:	2800      	cmp	r0, #0
   3963e:	db1b      	blt.n	39678 <nrf91_socket_offload_setsockopt+0x62>
	if ((level == SOL_SOCKET) && (optname == SO_RCVTIMEO)) {
   39640:	2c01      	cmp	r4, #1
   39642:	d107      	bne.n	39654 <nrf91_socket_offload_setsockopt+0x3e>
   39644:	2f14      	cmp	r7, #20
   39646:	d105      	bne.n	39654 <nrf91_socket_offload_setsockopt+0x3e>
		nrf_optlen = sizeof(struct nrf_timeval);
   39648:	2608      	movs	r6, #8
		nrf_rcvtimeo.tv_sec = ((struct timeval *)optval)->tv_sec;
   3964a:	682b      	ldr	r3, [r5, #0]
   3964c:	9304      	str	r3, [sp, #16]
		nrf_rcvtimeo.tv_usec = ((struct timeval *)optval)->tv_usec;
   3964e:	686b      	ldr	r3, [r5, #4]
		nrf_optval = &nrf_rcvtimeo;
   39650:	ad04      	add	r5, sp, #16
		nrf_rcvtimeo.tv_usec = ((struct timeval *)optval)->tv_usec;
   39652:	9305      	str	r3, [sp, #20]
	retval = nrf_setsockopt(sd, nrf_level, nrf_optname, nrf_optval,
   39654:	9600      	str	r6, [sp, #0]
   39656:	462b      	mov	r3, r5
   39658:	9a03      	ldr	r2, [sp, #12]
   3965a:	4621      	mov	r1, r4
   3965c:	4640      	mov	r0, r8
   3965e:	f7f4 fb69 	bl	2dd34 <nrf_setsockopt>
}
   39662:	b006      	add	sp, #24
   39664:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (z_in_level) {
   39668:	f240 2302 	movw	r3, #514	; 0x202
   3966c:	4299      	cmp	r1, r3
   3966e:	d0e0      	beq.n	39632 <nrf91_socket_offload_setsockopt+0x1c>
   39670:	f240 2303 	movw	r3, #515	; 0x203
   39674:	4299      	cmp	r1, r3
   39676:	e7db      	b.n	39630 <nrf91_socket_offload_setsockopt+0x1a>
	errno = ENOPROTOOPT;
   39678:	f7fe fd1d 	bl	380b6 <__errno>
   3967c:	236d      	movs	r3, #109	; 0x6d
   3967e:	6003      	str	r3, [r0, #0]
   39680:	f04f 30ff 	mov.w	r0, #4294967295
   39684:	e7ed      	b.n	39662 <nrf91_socket_offload_setsockopt+0x4c>

00039686 <nrf91_socket_offload_bind>:
{
   39686:	b510      	push	{r4, lr}
	if (addr->sa_family == AF_INET) {
   39688:	880a      	ldrh	r2, [r1, #0]
{
   3968a:	b08a      	sub	sp, #40	; 0x28
	if (addr->sa_family == AF_INET) {
   3968c:	2a01      	cmp	r2, #1
{
   3968e:	4604      	mov	r4, r0
   39690:	460b      	mov	r3, r1
	if (addr->sa_family == AF_INET) {
   39692:	d10e      	bne.n	396b2 <nrf91_socket_offload_bind+0x2c>
	nrf_out->sin_port = ptr->sin_port;
   39694:	8849      	ldrh	r1, [r1, #2]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   39696:	2210      	movs	r2, #16
	nrf_out->sin_port = ptr->sin_port;
   39698:	f8ad 100c 	strh.w	r1, [sp, #12]
	nrf_out->sin_family = NRF_AF_INET;
   3969c:	2102      	movs	r1, #2
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   3969e:	685b      	ldr	r3, [r3, #4]
	nrf_out->sin_family = NRF_AF_INET;
   396a0:	9102      	str	r1, [sp, #8]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   396a2:	f88d 2004 	strb.w	r2, [sp, #4]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   396a6:	9304      	str	r3, [sp, #16]
		retval = nrf_bind(sd, (const struct nrf_sockaddr *)&ipv4,
   396a8:	a901      	add	r1, sp, #4
		retval = nrf_bind(sd, (const struct nrf_sockaddr *)&ipv6,
   396aa:	f7f4 fb31 	bl	2dd10 <nrf_bind>
}
   396ae:	b00a      	add	sp, #40	; 0x28
   396b0:	bd10      	pop	{r4, pc}
	} else if (addr->sa_family == AF_INET6) {
   396b2:	2a02      	cmp	r2, #2
   396b4:	d107      	bne.n	396c6 <nrf91_socket_offload_bind+0x40>
		z_to_nrf_ipv6(addr, &ipv6);
   396b6:	a901      	add	r1, sp, #4
   396b8:	4618      	mov	r0, r3
   396ba:	f7ff fe92 	bl	393e2 <z_to_nrf_ipv6>
		retval = nrf_bind(sd, (const struct nrf_sockaddr *)&ipv6,
   396be:	2224      	movs	r2, #36	; 0x24
   396c0:	a901      	add	r1, sp, #4
   396c2:	4620      	mov	r0, r4
   396c4:	e7f1      	b.n	396aa <nrf91_socket_offload_bind+0x24>
	errno = ENOTSUP;
   396c6:	f7fe fcf6 	bl	380b6 <__errno>
   396ca:	2386      	movs	r3, #134	; 0x86
   396cc:	6003      	str	r3, [r0, #0]
   396ce:	f04f 30ff 	mov.w	r0, #4294967295
   396d2:	e7ec      	b.n	396ae <nrf91_socket_offload_bind+0x28>

000396d4 <z_impl_uart_irq_rx_enable>:
	if (api->irq_rx_enable) {
   396d4:	6843      	ldr	r3, [r0, #4]
   396d6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   396d8:	b103      	cbz	r3, 396dc <z_impl_uart_irq_rx_enable+0x8>
		api->irq_rx_enable(dev);
   396da:	4718      	bx	r3
}
   396dc:	4770      	bx	lr

000396de <response_handler>:
	write_uart_string(response);
   396de:	4608      	mov	r0, r1
   396e0:	f7ee bf58 	b.w	28594 <write_uart_string>

000396e4 <is_lfcr>:
	if ((chr == '\r') || (chr == '\n')) {
   396e4:	280d      	cmp	r0, #13
   396e6:	d004      	beq.n	396f2 <is_lfcr+0xe>
   396e8:	f1a0 030a 	sub.w	r3, r0, #10
   396ec:	4258      	negs	r0, r3
   396ee:	4158      	adcs	r0, r3
   396f0:	4770      	bx	lr
		return true;
   396f2:	2001      	movs	r0, #1
}
   396f4:	4770      	bx	lr

000396f6 <skip_command_prefix>:
{
   396f6:	b510      	push	{r4, lr}
	*cmd += sizeof("AT") - 1;
   396f8:	6802      	ldr	r2, [r0, #0]
{
   396fa:	4601      	mov	r1, r0
	*cmd += sizeof("AT") - 1;
   396fc:	1c93      	adds	r3, r2, #2
   396fe:	6003      	str	r3, [r0, #0]
	if (is_lfcr(**cmd) || is_terminated(**cmd)) {
   39700:	7894      	ldrb	r4, [r2, #2]
   39702:	4620      	mov	r0, r4
   39704:	f7ff ffee 	bl	396e4 <is_lfcr>
   39708:	b910      	cbnz	r0, 39710 <skip_command_prefix+0x1a>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   3970a:	b10c      	cbz	r4, 39710 <skip_command_prefix+0x1a>
	(*cmd)++;
   3970c:	3203      	adds	r2, #3
   3970e:	600a      	str	r2, [r1, #0]
}
   39710:	bd10      	pop	{r4, pc}

00039712 <at_params_list_init>:
{
   39712:	b538      	push	{r3, r4, r5, lr}
   39714:	460d      	mov	r5, r1
	if (list == NULL) {
   39716:	4604      	mov	r4, r0
   39718:	b140      	cbz	r0, 3972c <at_params_list_init+0x1a>
	list->params = k_calloc(max_params_count, sizeof(struct at_param));
   3971a:	210c      	movs	r1, #12
   3971c:	4628      	mov	r0, r5
   3971e:	f000 f968 	bl	399f2 <k_calloc>
   39722:	6060      	str	r0, [r4, #4]
	if (list->params == NULL) {
   39724:	b128      	cbz	r0, 39732 <at_params_list_init+0x20>
	return 0;
   39726:	2000      	movs	r0, #0
	list->param_count = max_params_count;
   39728:	6025      	str	r5, [r4, #0]
}
   3972a:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   3972c:	f06f 0015 	mvn.w	r0, #21
   39730:	e7fb      	b.n	3972a <at_params_list_init+0x18>
		return -ENOMEM;
   39732:	f06f 000b 	mvn.w	r0, #11
   39736:	e7f8      	b.n	3972a <at_params_list_init+0x18>

00039738 <at_params_list_free>:

void at_params_list_free(struct at_param_list *list)
{
   39738:	b538      	push	{r3, r4, r5, lr}
	if (list == NULL || list->params == NULL) {
   3973a:	4604      	mov	r4, r0
   3973c:	b148      	cbz	r0, 39752 <at_params_list_free+0x1a>
   3973e:	6843      	ldr	r3, [r0, #4]
   39740:	b13b      	cbz	r3, 39752 <at_params_list_free+0x1a>
		return;
	}

	at_params_list_clear(list);

	list->param_count = 0;
   39742:	2500      	movs	r5, #0
	at_params_list_clear(list);
   39744:	f7ef fb66 	bl	28e14 <at_params_list_clear>
	list->param_count = 0;
   39748:	6025      	str	r5, [r4, #0]
	k_free(list->params);
   3974a:	6860      	ldr	r0, [r4, #4]
   3974c:	f000 f94c 	bl	399e8 <k_free>
	list->params = NULL;
   39750:	6065      	str	r5, [r4, #4]
}
   39752:	bd38      	pop	{r3, r4, r5, pc}

00039754 <at_params_short_put>:

int at_params_short_put(const struct at_param_list *list, size_t index,
			u16_t value)
{
   39754:	b538      	push	{r3, r4, r5, lr}
   39756:	4615      	mov	r5, r2
	if (list == NULL || list->params == NULL) {
   39758:	b910      	cbnz	r0, 39760 <at_params_short_put+0xc>
		return -EINVAL;
   3975a:	f06f 0015 	mvn.w	r0, #21
	at_param_clear(param);

	param->type = AT_PARAM_TYPE_NUM_SHORT;
	param->value.int_val = (u32_t)(value & USHRT_MAX);
	return 0;
}
   3975e:	bd38      	pop	{r3, r4, r5, pc}
	if (list == NULL || list->params == NULL) {
   39760:	6843      	ldr	r3, [r0, #4]
   39762:	2b00      	cmp	r3, #0
   39764:	d0f9      	beq.n	3975a <at_params_short_put+0x6>
	struct at_param *param = at_params_get(list, index);
   39766:	f7ef fae9 	bl	28d3c <at_params_get>
	if (param == NULL) {
   3976a:	4604      	mov	r4, r0
   3976c:	2800      	cmp	r0, #0
   3976e:	d0f4      	beq.n	3975a <at_params_short_put+0x6>
	at_param_clear(param);
   39770:	f7ef fb2e 	bl	28dd0 <at_param_clear>
	param->type = AT_PARAM_TYPE_NUM_SHORT;
   39774:	2301      	movs	r3, #1
	param->value.int_val = (u32_t)(value & USHRT_MAX);
   39776:	60a5      	str	r5, [r4, #8]
	param->type = AT_PARAM_TYPE_NUM_SHORT;
   39778:	7023      	strb	r3, [r4, #0]
	return 0;
   3977a:	2000      	movs	r0, #0
   3977c:	e7ef      	b.n	3975e <at_params_short_put+0xa>

0003977e <at_params_empty_put>:

int at_params_empty_put(const struct at_param_list *list, size_t index)
{
   3977e:	b510      	push	{r4, lr}
	if (list == NULL || list->params == NULL) {
   39780:	b910      	cbnz	r0, 39788 <at_params_empty_put+0xa>
		return -EINVAL;
   39782:	f06f 0015 	mvn.w	r0, #21

	param->type = AT_PARAM_TYPE_EMPTY;
	param->value.int_val = 0;

	return 0;
}
   39786:	bd10      	pop	{r4, pc}
	if (list == NULL || list->params == NULL) {
   39788:	6843      	ldr	r3, [r0, #4]
   3978a:	2b00      	cmp	r3, #0
   3978c:	d0f9      	beq.n	39782 <at_params_empty_put+0x4>
	struct at_param *param = at_params_get(list, index);
   3978e:	f7ef fad5 	bl	28d3c <at_params_get>
	if (param == NULL) {
   39792:	4604      	mov	r4, r0
   39794:	2800      	cmp	r0, #0
   39796:	d0f4      	beq.n	39782 <at_params_empty_put+0x4>
	at_param_clear(param);
   39798:	f7ef fb1a 	bl	28dd0 <at_param_clear>
	param->type = AT_PARAM_TYPE_EMPTY;
   3979c:	2305      	movs	r3, #5
	param->value.int_val = 0;
   3979e:	2000      	movs	r0, #0
	param->type = AT_PARAM_TYPE_EMPTY;
   397a0:	7023      	strb	r3, [r4, #0]
	param->value.int_val = 0;
   397a2:	60a0      	str	r0, [r4, #8]
	return 0;
   397a4:	e7ef      	b.n	39786 <at_params_empty_put+0x8>

000397a6 <at_params_int_put>:

int at_params_int_put(const struct at_param_list *list, size_t index,
		      u32_t value)
{
   397a6:	b538      	push	{r3, r4, r5, lr}
   397a8:	4615      	mov	r5, r2
	if (list == NULL || list->params == NULL) {
   397aa:	b910      	cbnz	r0, 397b2 <at_params_int_put+0xc>
		return -EINVAL;
   397ac:	f06f 0015 	mvn.w	r0, #21
	at_param_clear(param);

	param->type = AT_PARAM_TYPE_NUM_INT;
	param->value.int_val = value;
	return 0;
}
   397b0:	bd38      	pop	{r3, r4, r5, pc}
	if (list == NULL || list->params == NULL) {
   397b2:	6843      	ldr	r3, [r0, #4]
   397b4:	2b00      	cmp	r3, #0
   397b6:	d0f9      	beq.n	397ac <at_params_int_put+0x6>
	struct at_param *param = at_params_get(list, index);
   397b8:	f7ef fac0 	bl	28d3c <at_params_get>
	if (param == NULL) {
   397bc:	4604      	mov	r4, r0
   397be:	2800      	cmp	r0, #0
   397c0:	d0f4      	beq.n	397ac <at_params_int_put+0x6>
	at_param_clear(param);
   397c2:	f7ef fb05 	bl	28dd0 <at_param_clear>
	param->type = AT_PARAM_TYPE_NUM_INT;
   397c6:	2302      	movs	r3, #2
	param->value.int_val = value;
   397c8:	60a5      	str	r5, [r4, #8]
	param->type = AT_PARAM_TYPE_NUM_INT;
   397ca:	7023      	strb	r3, [r4, #0]
	return 0;
   397cc:	2000      	movs	r0, #0
   397ce:	e7ef      	b.n	397b0 <at_params_int_put+0xa>

000397d0 <at_params_string_put>:

int at_params_string_put(const struct at_param_list *list, size_t index,
			 const char *str, size_t str_len)
{
   397d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   397d2:	4616      	mov	r6, r2
   397d4:	461d      	mov	r5, r3
	if (list == NULL || list->params == NULL || str == NULL) {
   397d6:	b910      	cbnz	r0, 397de <at_params_string_put+0xe>
		return -EINVAL;
   397d8:	f06f 0015 	mvn.w	r0, #21
	param->size = str_len;
	param->type = AT_PARAM_TYPE_STRING;
	param->value.str_val = param_value;

	return 0;
}
   397dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (list == NULL || list->params == NULL || str == NULL) {
   397de:	6843      	ldr	r3, [r0, #4]
   397e0:	2b00      	cmp	r3, #0
   397e2:	d0f9      	beq.n	397d8 <at_params_string_put+0x8>
   397e4:	2a00      	cmp	r2, #0
   397e6:	d0f7      	beq.n	397d8 <at_params_string_put+0x8>
	struct at_param *param = at_params_get(list, index);
   397e8:	f7ef faa8 	bl	28d3c <at_params_get>
	if (param == NULL) {
   397ec:	4604      	mov	r4, r0
   397ee:	2800      	cmp	r0, #0
   397f0:	d0f2      	beq.n	397d8 <at_params_string_put+0x8>
	char *param_value = (char *)k_malloc(str_len + 1);
   397f2:	1c68      	adds	r0, r5, #1
   397f4:	f7f9 f914 	bl	32a20 <k_malloc>
	if (param_value == NULL) {
   397f8:	4607      	mov	r7, r0
   397fa:	b160      	cbz	r0, 39816 <at_params_string_put+0x46>
   397fc:	462a      	mov	r2, r5
   397fe:	4631      	mov	r1, r6
   39800:	f000 fabd 	bl	39d7e <memcpy>
	at_param_clear(param);
   39804:	4620      	mov	r0, r4
   39806:	f7ef fae3 	bl	28dd0 <at_param_clear>
	param->type = AT_PARAM_TYPE_STRING;
   3980a:	2303      	movs	r3, #3
	param->size = str_len;
   3980c:	6065      	str	r5, [r4, #4]
	param->type = AT_PARAM_TYPE_STRING;
   3980e:	7023      	strb	r3, [r4, #0]
	param->value.str_val = param_value;
   39810:	60a7      	str	r7, [r4, #8]
	return 0;
   39812:	2000      	movs	r0, #0
   39814:	e7e2      	b.n	397dc <at_params_string_put+0xc>
		return -ENOMEM;
   39816:	f06f 000b 	mvn.w	r0, #11
   3981a:	e7df      	b.n	397dc <at_params_string_put+0xc>

0003981c <at_params_array_put>:

int at_params_array_put(const struct at_param_list *list, size_t index,
			const u32_t *array, size_t array_len)
{
   3981c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3981e:	4616      	mov	r6, r2
   39820:	461d      	mov	r5, r3
	if (list == NULL || list->params == NULL || array == NULL) {
   39822:	b910      	cbnz	r0, 3982a <at_params_array_put+0xe>
		return -EINVAL;
   39824:	f06f 0015 	mvn.w	r0, #21
	param->size = array_len;
	param->type = AT_PARAM_TYPE_ARRAY;
	param->value.array_val = param_value;

	return 0;
}
   39828:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (list == NULL || list->params == NULL || array == NULL) {
   3982a:	6843      	ldr	r3, [r0, #4]
   3982c:	2b00      	cmp	r3, #0
   3982e:	d0f9      	beq.n	39824 <at_params_array_put+0x8>
   39830:	2a00      	cmp	r2, #0
   39832:	d0f7      	beq.n	39824 <at_params_array_put+0x8>
	struct at_param *param = at_params_get(list, index);
   39834:	f7ef fa82 	bl	28d3c <at_params_get>
	if (param == NULL) {
   39838:	4604      	mov	r4, r0
   3983a:	2800      	cmp	r0, #0
   3983c:	d0f2      	beq.n	39824 <at_params_array_put+0x8>
	u32_t *param_value = (u32_t *)k_malloc(array_len);
   3983e:	4628      	mov	r0, r5
   39840:	f7f9 f8ee 	bl	32a20 <k_malloc>
	if (param_value == NULL) {
   39844:	4607      	mov	r7, r0
   39846:	b160      	cbz	r0, 39862 <at_params_array_put+0x46>
   39848:	462a      	mov	r2, r5
   3984a:	4631      	mov	r1, r6
   3984c:	f000 fa97 	bl	39d7e <memcpy>
	at_param_clear(param);
   39850:	4620      	mov	r0, r4
   39852:	f7ef fabd 	bl	28dd0 <at_param_clear>
	param->type = AT_PARAM_TYPE_ARRAY;
   39856:	2304      	movs	r3, #4
	param->size = array_len;
   39858:	6065      	str	r5, [r4, #4]
	param->type = AT_PARAM_TYPE_ARRAY;
   3985a:	7023      	strb	r3, [r4, #0]
	param->value.array_val = param_value;
   3985c:	60a7      	str	r7, [r4, #8]
	return 0;
   3985e:	2000      	movs	r0, #0
   39860:	e7e2      	b.n	39828 <at_params_array_put+0xc>
		return -ENOMEM;
   39862:	f06f 000b 	mvn.w	r0, #11
   39866:	e7df      	b.n	39828 <at_params_array_put+0xc>

00039868 <at_params_int_get>:
	return 0;
}

int at_params_int_get(const struct at_param_list *list, size_t index,
		      u32_t *value)
{
   39868:	b510      	push	{r4, lr}
   3986a:	4614      	mov	r4, r2
	if (list == NULL || list->params == NULL || value == NULL) {
   3986c:	b910      	cbnz	r0, 39874 <at_params_int_get+0xc>
		return -EINVAL;
   3986e:	f06f 0015 	mvn.w	r0, #21
		return -EINVAL;
	}

	*value = param->value.int_val;
	return 0;
}
   39872:	bd10      	pop	{r4, pc}
	if (list == NULL || list->params == NULL || value == NULL) {
   39874:	6843      	ldr	r3, [r0, #4]
   39876:	2b00      	cmp	r3, #0
   39878:	d0f9      	beq.n	3986e <at_params_int_get+0x6>
   3987a:	2a00      	cmp	r2, #0
   3987c:	d0f7      	beq.n	3986e <at_params_int_get+0x6>
	struct at_param *param = at_params_get(list, index);
   3987e:	f7ef fa5d 	bl	28d3c <at_params_get>
	if (param == NULL) {
   39882:	2800      	cmp	r0, #0
   39884:	d0f3      	beq.n	3986e <at_params_int_get+0x6>
	if ((param->type != AT_PARAM_TYPE_NUM_INT) &&
   39886:	7803      	ldrb	r3, [r0, #0]
   39888:	3b01      	subs	r3, #1
   3988a:	2b01      	cmp	r3, #1
   3988c:	d8ef      	bhi.n	3986e <at_params_int_get+0x6>
	*value = param->value.int_val;
   3988e:	6883      	ldr	r3, [r0, #8]
	return 0;
   39890:	2000      	movs	r0, #0
	*value = param->value.int_val;
   39892:	6023      	str	r3, [r4, #0]
	return 0;
   39894:	e7ed      	b.n	39872 <at_params_int_get+0xa>

00039896 <at_params_string_get>:

int at_params_string_get(const struct at_param_list *list, size_t index,
			 char *value, size_t *len)
{
   39896:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   39898:	4616      	mov	r6, r2
   3989a:	461c      	mov	r4, r3
	if (list == NULL || list->params == NULL || value == NULL ||
   3989c:	b910      	cbnz	r0, 398a4 <at_params_string_get+0xe>
	    value == NULL || len == NULL) {
		return -EINVAL;
   3989e:	f06f 0015 	mvn.w	r0, #21

	memcpy(value, param->value.str_val, param_len);
	*len = param_len;

	return 0;
}
   398a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (list == NULL || list->params == NULL || value == NULL ||
   398a4:	6843      	ldr	r3, [r0, #4]
   398a6:	2b00      	cmp	r3, #0
   398a8:	d0f9      	beq.n	3989e <at_params_string_get+0x8>
   398aa:	2a00      	cmp	r2, #0
   398ac:	d0f7      	beq.n	3989e <at_params_string_get+0x8>
	    value == NULL || len == NULL) {
   398ae:	2c00      	cmp	r4, #0
   398b0:	d0f5      	beq.n	3989e <at_params_string_get+0x8>
	struct at_param *param = at_params_get(list, index);
   398b2:	f7ef fa43 	bl	28d3c <at_params_get>
	if (param == NULL) {
   398b6:	4607      	mov	r7, r0
   398b8:	2800      	cmp	r0, #0
   398ba:	d0f0      	beq.n	3989e <at_params_string_get+0x8>
	if (param->type != AT_PARAM_TYPE_STRING) {
   398bc:	7803      	ldrb	r3, [r0, #0]
   398be:	2b03      	cmp	r3, #3
   398c0:	d1ed      	bne.n	3989e <at_params_string_get+0x8>
	size_t param_len = at_param_size(param);
   398c2:	f7ef fa5d 	bl	28d80 <at_param_size>
	if (*len < param_len) {
   398c6:	6823      	ldr	r3, [r4, #0]
	size_t param_len = at_param_size(param);
   398c8:	4605      	mov	r5, r0
	if (*len < param_len) {
   398ca:	4283      	cmp	r3, r0
   398cc:	d307      	bcc.n	398de <at_params_string_get+0x48>
   398ce:	4602      	mov	r2, r0
   398d0:	68b9      	ldr	r1, [r7, #8]
   398d2:	4630      	mov	r0, r6
   398d4:	f000 fa53 	bl	39d7e <memcpy>
	*len = param_len;
   398d8:	6025      	str	r5, [r4, #0]
	return 0;
   398da:	2000      	movs	r0, #0
   398dc:	e7e1      	b.n	398a2 <at_params_string_get+0xc>
		return -ENOMEM;
   398de:	f06f 000b 	mvn.w	r0, #11
   398e2:	e7de      	b.n	398a2 <at_params_string_get+0xc>

000398e4 <response_is_valid>:
{
   398e4:	b570      	push	{r4, r5, r6, lr}
   398e6:	4606      	mov	r6, r0
	if ((response_len < strlen(check)) ||
   398e8:	4610      	mov	r0, r2
{
   398ea:	460d      	mov	r5, r1
   398ec:	4614      	mov	r4, r2
	if ((response_len < strlen(check)) ||
   398ee:	f7e3 fc33 	bl	1d158 <strlen>
   398f2:	42a8      	cmp	r0, r5
   398f4:	d808      	bhi.n	39908 <response_is_valid+0x24>
	    (memcmp(response, check, response_len) != 0)) {
   398f6:	462a      	mov	r2, r5
   398f8:	4621      	mov	r1, r4
   398fa:	4630      	mov	r0, r6
   398fc:	f000 fa31 	bl	39d62 <memcmp>
	if ((response_len < strlen(check)) ||
   39900:	fab0 f080 	clz	r0, r0
   39904:	0940      	lsrs	r0, r0, #5
}
   39906:	bd70      	pop	{r4, r5, r6, pc}
		return false;
   39908:	2000      	movs	r0, #0
   3990a:	e7fc      	b.n	39906 <response_is_valid+0x22>

0003990c <lte_lc_init_and_connect>:
{
   3990c:	b508      	push	{r3, lr}
	ret = w_lte_lc_init();
   3990e:	f7ef fab9 	bl	28e84 <w_lte_lc_init>
	if (ret) {
   39912:	b918      	cbnz	r0, 3991c <lte_lc_init_and_connect+0x10>
}
   39914:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return w_lte_lc_connect();
   39918:	f7ef bbcc 	b.w	290b4 <w_lte_lc_connect>
}
   3991c:	bd08      	pop	{r3, pc}

0003991e <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   3991e:	4700      	bx	r0

00039920 <nrfx_nvmc_flash_size_get>:
}

uint32_t nrfx_nvmc_flash_size_get(void)
{
    return flash_total_size_get();
}
   39920:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   39924:	4770      	bx	lr

00039926 <nrfx_nvmc_flash_page_size_get>:

uint32_t nrfx_nvmc_flash_page_size_get(void)
{
    return flash_page_size_get();
}
   39926:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   3992a:	4770      	bx	lr

0003992c <nrfx_nvmc_flash_page_count_get>:

uint32_t nrfx_nvmc_flash_page_count_get(void)
{
    return flash_page_count_get();
}
   3992c:	f44f 7080 	mov.w	r0, #256	; 0x100
   39930:	4770      	bx	lr

00039932 <finish_transfer>:
{
   39932:	b510      	push	{r4, lr}
   39934:	4604      	mov	r4, r0
    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   39936:	7fc0      	ldrb	r0, [r0, #31]
   39938:	28ff      	cmp	r0, #255	; 0xff
   3993a:	d003      	beq.n	39944 <finish_transfer+0x12>
            if (p_cb->ss_active_high)
   3993c:	7fa3      	ldrb	r3, [r4, #30]
   3993e:	b15b      	cbz	r3, 39958 <finish_transfer+0x26>
                nrf_gpio_pin_clear(p_cb->ss_pin);
   39940:	f7f7 fff2 	bl	31928 <nrf_gpio_pin_clear>
    p_cb->transfer_in_progress = false;
   39944:	2300      	movs	r3, #0
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   39946:	4620      	mov	r0, r4
    p_cb->transfer_in_progress = false;
   39948:	7763      	strb	r3, [r4, #29]
    p_cb->evt.type = NRFX_SPIM_EVENT_DONE;
   3994a:	7223      	strb	r3, [r4, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   3994c:	6861      	ldr	r1, [r4, #4]
   3994e:	f850 3b08 	ldr.w	r3, [r0], #8
}
   39952:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   39956:	4718      	bx	r3
                nrf_gpio_pin_set(p_cb->ss_pin);
   39958:	f7f7 fff2 	bl	31940 <nrf_gpio_pin_set>
   3995c:	e7f2      	b.n	39944 <finish_transfer+0x12>

0003995e <xfer_completeness_check>:
    switch (p_cb->xfer_desc.type)
   3995e:	7b0b      	ldrb	r3, [r1, #12]
   39960:	2b03      	cmp	r3, #3
   39962:	d82a      	bhi.n	399ba <xfer_completeness_check+0x5c>
   39964:	e8df f003 	tbb	[pc, r3]
   39968:	021a2622 	.word	0x021a2622
            if (((p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   3996c:	688b      	ldr	r3, [r1, #8]
   3996e:	035a      	lsls	r2, r3, #13
   39970:	d504      	bpl.n	3997c <xfer_completeness_check+0x1e>
    return p_reg->TXD.AMOUNT;
   39972:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
   39976:	690a      	ldr	r2, [r1, #16]
   39978:	429a      	cmp	r2, r3
   3997a:	d107      	bne.n	3998c <xfer_completeness_check+0x2e>
                (!(p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   3997c:	688b      	ldr	r3, [r1, #8]
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)) ||
   3997e:	035b      	lsls	r3, r3, #13
   39980:	d41b      	bmi.n	399ba <xfer_completeness_check+0x5c>
   39982:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   39986:	694a      	ldr	r2, [r1, #20]
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   39988:	429a      	cmp	r2, r3
   3998a:	d016      	beq.n	399ba <xfer_completeness_check+0x5c>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   3998c:	2300      	movs	r3, #0
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   3998e:	2206      	movs	r2, #6
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   39990:	f8c0 3500 	str.w	r3, [r0, #1280]	; 0x500
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   39994:	f8c0 2500 	str.w	r2, [r0, #1280]	; 0x500
   39998:	4618      	mov	r0, r3
   3999a:	4770      	bx	lr
    return p_reg->TXD.AMOUNT;
   3999c:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   399a0:	690a      	ldr	r2, [r1, #16]
   399a2:	429a      	cmp	r2, r3
   399a4:	d1f2      	bne.n	3998c <xfer_completeness_check+0x2e>
    return p_reg->RXD.AMOUNT;
   399a6:	f8d0 353c 	ldr.w	r3, [r0, #1340]	; 0x53c
   399aa:	e7ec      	b.n	39986 <xfer_completeness_check+0x28>
    return p_reg->TXD.AMOUNT;
   399ac:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   399b0:	690a      	ldr	r2, [r1, #16]
   399b2:	e7e9      	b.n	39988 <xfer_completeness_check+0x2a>
    return p_reg->RXD.AMOUNT;
   399b4:	f8d0 353c 	ldr.w	r3, [r0, #1340]	; 0x53c
   399b8:	e7fa      	b.n	399b0 <xfer_completeness_check+0x52>
    bool transfer_complete = true;
   399ba:	2001      	movs	r0, #1
}
   399bc:	4770      	bx	lr

000399be <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
   399be:	f7fe bb18 	b.w	37ff2 <z_clock_idle_exit>

000399c2 <k_mem_pool_malloc>:
{
   399c2:	b507      	push	{r0, r1, r2, lr}
   399c4:	2204      	movs	r2, #4
   399c6:	188a      	adds	r2, r1, r2
   399c8:	d204      	bcs.n	399d4 <k_mem_pool_malloc+0x12>
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
   399ca:	2300      	movs	r3, #0
   399cc:	4669      	mov	r1, sp
   399ce:	f7f8 ff61 	bl	32894 <k_mem_pool_alloc>
   399d2:	b118      	cbz	r0, 399dc <k_mem_pool_malloc+0x1a>
		return NULL;
   399d4:	2000      	movs	r0, #0
}
   399d6:	b003      	add	sp, #12
   399d8:	f85d fb04 	ldr.w	pc, [sp], #4
   399dc:	e9dd 3200 	ldrd	r3, r2, [sp]
   399e0:	601a      	str	r2, [r3, #0]
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
   399e2:	9800      	ldr	r0, [sp, #0]
   399e4:	3004      	adds	r0, #4
   399e6:	e7f6      	b.n	399d6 <k_mem_pool_malloc+0x14>

000399e8 <k_free>:
	if (ptr != NULL) {
   399e8:	b110      	cbz	r0, 399f0 <k_free+0x8>
		k_mem_pool_free_id(ptr);
   399ea:	3804      	subs	r0, #4
   399ec:	f7f8 bfba 	b.w	32964 <k_mem_pool_free_id>
}
   399f0:	4770      	bx	lr

000399f2 <k_calloc>:
{
   399f2:	b538      	push	{r3, r4, r5, lr}
	return a != 0 && (c / a) != b;
}

static inline bool size_mul_overflow(size_t a, size_t b, size_t *result)
{
	size_t c = a * b;
   399f4:	fb01 f400 	mul.w	r4, r1, r0

	*result = c;

	return a != 0 && (c / a) != b;
   399f8:	b118      	cbz	r0, 39a02 <k_calloc+0x10>
   399fa:	fbb4 f0f0 	udiv	r0, r4, r0
   399fe:	4281      	cmp	r1, r0
   39a00:	d10a      	bne.n	39a18 <k_calloc+0x26>
	ret = k_malloc(bounds);
   39a02:	4620      	mov	r0, r4
   39a04:	f7f9 f80c 	bl	32a20 <k_malloc>
	if (ret != NULL) {
   39a08:	4605      	mov	r5, r0
   39a0a:	b118      	cbz	r0, 39a14 <k_calloc+0x22>
__ssp_bos_icheck3(memset, void *, int)
   39a0c:	4622      	mov	r2, r4
   39a0e:	2100      	movs	r1, #0
   39a10:	f000 f9d5 	bl	39dbe <memset>
}
   39a14:	4628      	mov	r0, r5
   39a16:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
   39a18:	2500      	movs	r5, #0
   39a1a:	e7fb      	b.n	39a14 <k_calloc+0x22>

00039a1c <z_impl_k_mutex_init>:
{
   39a1c:	4603      	mov	r3, r0
	mutex->owner = NULL;
   39a1e:	2000      	movs	r0, #0
	list->tail = (sys_dnode_t *)list;
   39a20:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
   39a24:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
   39a28:	4770      	bx	lr

00039a2a <z_queue_node_peek>:
{
   39a2a:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
   39a2c:	4604      	mov	r4, r0
   39a2e:	b130      	cbz	r0, 39a3e <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   39a30:	6802      	ldr	r2, [r0, #0]
   39a32:	0793      	lsls	r3, r2, #30
   39a34:	d003      	beq.n	39a3e <z_queue_node_peek+0x14>
		ret = anode->data;
   39a36:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   39a38:	b109      	cbz	r1, 39a3e <z_queue_node_peek+0x14>
			k_free(anode);
   39a3a:	f7ff ffd5 	bl	399e8 <k_free>
}
   39a3e:	4620      	mov	r0, r4
   39a40:	bd10      	pop	{r4, pc}

00039a42 <z_impl_k_queue_init>:
	list->head = NULL;
   39a42:	2300      	movs	r3, #0
	list->tail = NULL;
   39a44:	e9c0 3300 	strd	r3, r3, [r0]
	queue->lock = (struct k_spinlock) {};
   39a48:	6083      	str	r3, [r0, #8]
	sys_dlist_init(&queue->poll_events);
   39a4a:	f100 030c 	add.w	r3, r0, #12
   39a4e:	e9c0 3303 	strd	r3, r3, [r0, #12]
}
   39a52:	4770      	bx	lr

00039a54 <k_queue_append>:
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
   39a54:	460a      	mov	r2, r1
   39a56:	2300      	movs	r3, #0
   39a58:	6841      	ldr	r1, [r0, #4]
   39a5a:	f7f9 bae5 	b.w	33028 <queue_insert>

00039a5e <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   39a5e:	7b43      	ldrb	r3, [r0, #13]
   39a60:	06db      	lsls	r3, r3, #27
   39a62:	bf03      	ittte	eq
   39a64:	6980      	ldreq	r0, [r0, #24]
   39a66:	fab0 f080 	clzeq	r0, r0
   39a6a:	0940      	lsreq	r0, r0, #5
   39a6c:	2000      	movne	r0, #0
}
   39a6e:	4770      	bx	lr

00039a70 <z_is_t1_higher_prio_than_t2>:
	if (thread_1->base.prio < thread_2->base.prio) {
   39a70:	f990 000e 	ldrsb.w	r0, [r0, #14]
   39a74:	f991 300e 	ldrsb.w	r3, [r1, #14]
}
   39a78:	4298      	cmp	r0, r3
   39a7a:	bfac      	ite	ge
   39a7c:	2000      	movge	r0, #0
   39a7e:	2001      	movlt	r0, #1
   39a80:	4770      	bx	lr

00039a82 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   39a82:	4603      	mov	r3, r0
   39a84:	b920      	cbnz	r0, 39a90 <z_reschedule_irqlock+0xe>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   39a86:	f3ef 8205 	mrs	r2, IPSR
   39a8a:	b90a      	cbnz	r2, 39a90 <z_reschedule_irqlock+0xe>
   39a8c:	f7eb ba86 	b.w	24f9c <arch_swap>
   39a90:	f383 8811 	msr	BASEPRI, r3
   39a94:	f3bf 8f6f 	isb	sy
}
   39a98:	4770      	bx	lr

00039a9a <z_reschedule_unlocked>:
	__asm__ volatile(
   39a9a:	f04f 0320 	mov.w	r3, #32
   39a9e:	f3ef 8011 	mrs	r0, BASEPRI
   39aa2:	f383 8811 	msr	BASEPRI, r3
   39aa6:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   39aaa:	f7ff bfea 	b.w	39a82 <z_reschedule_irqlock>

00039aae <z_priq_dumb_best>:
	return list->head == list;
   39aae:	6803      	ldr	r3, [r0, #0]
}
   39ab0:	4298      	cmp	r0, r3
   39ab2:	bf14      	ite	ne
   39ab4:	4618      	movne	r0, r3
   39ab6:	2000      	moveq	r0, #0
   39ab8:	4770      	bx	lr

00039aba <z_unpend_all>:
{
   39aba:	b570      	push	{r4, r5, r6, lr}
   39abc:	4606      	mov	r6, r0
	int need_sched = 0;
   39abe:	2500      	movs	r5, #0
   39ac0:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   39ac2:	42a6      	cmp	r6, r4
   39ac4:	d000      	beq.n	39ac8 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   39ac6:	b90c      	cbnz	r4, 39acc <z_unpend_all+0x12>
}
   39ac8:	4628      	mov	r0, r5
   39aca:	bd70      	pop	{r4, r5, r6, pc}
		z_unpend_thread(thread);
   39acc:	4620      	mov	r0, r4
   39ace:	f7f9 fe1f 	bl	33710 <z_unpend_thread>
	if (z_is_thread_ready(thread)) {
   39ad2:	4620      	mov	r0, r4
   39ad4:	f7ff ffc3 	bl	39a5e <z_is_thread_ready>
		need_sched = 1;
   39ad8:	2501      	movs	r5, #1
   39ada:	2800      	cmp	r0, #0
   39adc:	d0f0      	beq.n	39ac0 <z_unpend_all+0x6>
		z_add_thread_to_ready_q(thread);
   39ade:	4620      	mov	r0, r4
   39ae0:	f7f9 ff1e 	bl	33920 <z_add_thread_to_ready_q>
   39ae4:	e7ec      	b.n	39ac0 <z_unpend_all+0x6>

00039ae6 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || initial_count > limit) {
   39ae6:	b15a      	cbz	r2, 39b00 <z_impl_k_sem_init+0x1a>
   39ae8:	428a      	cmp	r2, r1
   39aea:	d309      	bcc.n	39b00 <z_impl_k_sem_init+0x1a>
	sys_dlist_init(&sem->poll_events);
   39aec:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
   39af0:	e9c0 1202 	strd	r1, r2, [r0, #8]
	list->tail = (sys_dnode_t *)list;
   39af4:	e9c0 0000 	strd	r0, r0, [r0]
   39af8:	e9c0 3304 	strd	r3, r3, [r0, #16]
	return 0;
   39afc:	2000      	movs	r0, #0
   39afe:	4770      	bx	lr
		return -EINVAL;
   39b00:	f06f 0015 	mvn.w	r0, #21
}
   39b04:	4770      	bx	lr

00039b06 <k_is_in_isr>:
   39b06:	f3ef 8005 	mrs	r0, IPSR
}
   39b0a:	3000      	adds	r0, #0
   39b0c:	bf18      	it	ne
   39b0e:	2001      	movne	r0, #1
   39b10:	4770      	bx	lr

00039b12 <z_impl_k_busy_wait>:
	arch_busy_wait(usec_to_wait);
   39b12:	f7e9 be7f 	b.w	23814 <arch_busy_wait>

00039b16 <z_impl_k_thread_name_set>:
}
   39b16:	f06f 0057 	mvn.w	r0, #87	; 0x57
   39b1a:	4770      	bx	lr

00039b1c <k_thread_name_get>:
}
   39b1c:	2000      	movs	r0, #0
   39b1e:	4770      	bx	lr

00039b20 <z_new_thread_init>:
{
   39b20:	b510      	push	{r4, lr}
	thread_base->user_options = (u8_t)options;
   39b22:	9c02      	ldr	r4, [sp, #8]
	thread_base->prio = priority;
   39b24:	7383      	strb	r3, [r0, #14]
	thread_base->user_options = (u8_t)options;
   39b26:	7304      	strb	r4, [r0, #12]
	thread_base->sched_locked = 0U;
   39b28:	2300      	movs	r3, #0
	thread_base->thread_state = (u8_t)initial_state;
   39b2a:	2404      	movs	r4, #4
	thread_base->sched_locked = 0U;
   39b2c:	73c3      	strb	r3, [r0, #15]
	thread_base->thread_state = (u8_t)initial_state;
   39b2e:	7344      	strb	r4, [r0, #13]
	node->prev = NULL;
   39b30:	e9c0 3306 	strd	r3, r3, [r0, #24]
	thread->fn_abort = NULL;
   39b34:	e9c0 3313 	strd	r3, r3, [r0, #76]	; 0x4c
	thread->stack_info.size = (u32_t)stackSize;
   39b38:	e9c0 1216 	strd	r1, r2, [r0, #88]	; 0x58
}
   39b3c:	bd10      	pop	{r4, pc}

00039b3e <k_work_submit_to_queue>:
{
   39b3e:	b500      	push	{lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   39b40:	f101 0308 	add.w	r3, r1, #8
   39b44:	e8d3 2fef 	ldaex	r2, [r3]
   39b48:	f042 0c01 	orr.w	ip, r2, #1
   39b4c:	e8c3 cfee 	stlex	lr, ip, [r3]
   39b50:	f1be 0f00 	cmp.w	lr, #0
   39b54:	d1f6      	bne.n	39b44 <k_work_submit_to_queue+0x6>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   39b56:	07d3      	lsls	r3, r2, #31
   39b58:	d403      	bmi.n	39b62 <k_work_submit_to_queue+0x24>
}
   39b5a:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
   39b5e:	f7ff bf79 	b.w	39a54 <k_queue_append>
}
   39b62:	f85d fb04 	ldr.w	pc, [sp], #4

00039b66 <work_timeout>:
	k_work_submit_to_queue(w->work_q, &w->work);
   39b66:	f1a0 010c 	sub.w	r1, r0, #12
   39b6a:	6900      	ldr	r0, [r0, #16]
   39b6c:	f7ff bfe7 	b.w	39b3e <k_work_submit_to_queue>

00039b70 <work_cancel>:
	CHECKIF(work->work_q == NULL) {
   39b70:	69c3      	ldr	r3, [r0, #28]
{
   39b72:	b570      	push	{r4, r5, r6, lr}
   39b74:	4604      	mov	r4, r0
	CHECKIF(work->work_q == NULL) {
   39b76:	2b00      	cmp	r3, #0
   39b78:	d039      	beq.n	39bee <work_cancel+0x7e>
	return atomic_test_bit(work->flags, K_WORK_STATE_PENDING);
   39b7a:	f100 0508 	add.w	r5, r0, #8
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   39b7e:	e8d5 3faf 	lda	r3, [r5]
	if (k_work_pending(&work->work)) {
   39b82:	07db      	lsls	r3, r3, #31
   39b84:	d52f      	bpl.n	39be6 <work_cancel+0x76>
 * @return true if node was removed
 */
static inline bool sys_sflist_find_and_remove(sys_sflist_t *list,
					      sys_sfnode_t *node);

Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   39b86:	2100      	movs	r1, #0
		if (!k_queue_remove(&work->work_q->queue, &work->work)) {
   39b88:	69c2      	ldr	r2, [r0, #28]
   39b8a:	6813      	ldr	r3, [r2, #0]
   39b8c:	b913      	cbnz	r3, 39b94 <work_cancel+0x24>
			return -EINVAL;
   39b8e:	f06f 0015 	mvn.w	r0, #21
}
   39b92:	bd70      	pop	{r4, r5, r6, pc}
   39b94:	429c      	cmp	r4, r3
   39b96:	d121      	bne.n	39bdc <work_cancel+0x6c>
Z_GENLIST_REMOVE(sflist, sfnode)
   39b98:	6823      	ldr	r3, [r4, #0]
   39b9a:	6856      	ldr	r6, [r2, #4]
   39b9c:	f023 0003 	bic.w	r0, r3, #3
   39ba0:	b991      	cbnz	r1, 39bc8 <work_cancel+0x58>
   39ba2:	42b4      	cmp	r4, r6
	list->head = node;
   39ba4:	6010      	str	r0, [r2, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
   39ba6:	d100      	bne.n	39baa <work_cancel+0x3a>
	list->tail = node;
   39ba8:	6050      	str	r0, [r2, #4]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   39baa:	6823      	ldr	r3, [r4, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   39bac:	f003 0303 	and.w	r3, r3, #3
   39bb0:	6023      	str	r3, [r4, #0]
	work->work_q = NULL;
   39bb2:	2000      	movs	r0, #0
   39bb4:	61e0      	str	r0, [r4, #28]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   39bb6:	e8d5 3fef 	ldaex	r3, [r5]
   39bba:	f023 0301 	bic.w	r3, r3, #1
   39bbe:	e8c5 3fe2 	stlex	r2, r3, [r5]
   39bc2:	2a00      	cmp	r2, #0
   39bc4:	d0e5      	beq.n	39b92 <work_cancel+0x22>
   39bc6:	e7f6      	b.n	39bb6 <work_cancel+0x46>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   39bc8:	680b      	ldr	r3, [r1, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
   39bca:	42b4      	cmp	r4, r6
	parent->next_and_flags = cur_flags | (unative_t)child;
   39bcc:	f003 0303 	and.w	r3, r3, #3
   39bd0:	ea43 0300 	orr.w	r3, r3, r0
   39bd4:	600b      	str	r3, [r1, #0]
	list->tail = node;
   39bd6:	bf08      	it	eq
   39bd8:	6051      	streq	r1, [r2, #4]
   39bda:	e7e6      	b.n	39baa <work_cancel+0x3a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   39bdc:	6818      	ldr	r0, [r3, #0]
Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   39bde:	4619      	mov	r1, r3
   39be0:	f020 0303 	bic.w	r3, r0, #3
   39be4:	e7d2      	b.n	39b8c <work_cancel+0x1c>
		(void)z_abort_timeout(&work->timeout);
   39be6:	300c      	adds	r0, #12
   39be8:	f7fb f96e 	bl	34ec8 <z_abort_timeout>
   39bec:	e7e1      	b.n	39bb2 <work_cancel+0x42>
		return -EAGAIN;
   39bee:	f06f 000a 	mvn.w	r0, #10
   39bf2:	e7ce      	b.n	39b92 <work_cancel+0x22>

00039bf4 <k_delayed_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   39bf4:	2300      	movs	r3, #0
   39bf6:	e9c0 3100 	strd	r3, r1, [r0]
	node->next = NULL;
   39bfa:	e9c0 3302 	strd	r3, r3, [r0, #8]
	node->prev = NULL;
   39bfe:	6103      	str	r3, [r0, #16]
	work->work_q = NULL;
   39c00:	61c3      	str	r3, [r0, #28]
}
   39c02:	4770      	bx	lr

00039c04 <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
   39c04:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
   39c06:	f7fb fb57 	bl	352b8 <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
   39c0a:	bd08      	pop	{r3, pc}

00039c0c <z_impl_k_uptime_get>:

s64_t z_impl_k_uptime_get(void)
{
   39c0c:	b510      	push	{r4, lr}
	return k_ticks_to_ms_floor64(z_tick_get());
   39c0e:	f7fb fb53 	bl	352b8 <z_tick_get>
			return (t * to_hz + off) / from_hz;
   39c12:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   39c16:	fba0 2304 	umull	r2, r3, r0, r4
   39c1a:	fb04 3301 	mla	r3, r4, r1, r3
   39c1e:	0bd0      	lsrs	r0, r2, #15
}
   39c20:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   39c24:	0bd9      	lsrs	r1, r3, #15
   39c26:	bd10      	pop	{r4, pc}

00039c28 <k_timer_init>:
	timer->status = 0U;
   39c28:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   39c2a:	e9c0 1206 	strd	r1, r2, [r0, #24]
   39c2e:	f100 0210 	add.w	r2, r0, #16
	timer->status = 0U;
   39c32:	6243      	str	r3, [r0, #36]	; 0x24
	list->tail = (sys_dnode_t *)list;
   39c34:	e9c0 2204 	strd	r2, r2, [r0, #16]
	node->prev = NULL;
   39c38:	e9c0 3300 	strd	r3, r3, [r0]
	timer->user_data = NULL;
   39c3c:	6283      	str	r3, [r0, #40]	; 0x28
}
   39c3e:	4770      	bx	lr

00039c40 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   39c40:	b510      	push	{r4, lr}
   39c42:	4604      	mov	r4, r0
	int inactive = z_abort_timeout(&timer->timeout) != 0;
   39c44:	f7fb f940 	bl	34ec8 <z_abort_timeout>

	if (inactive) {
   39c48:	bb00      	cbnz	r0, 39c8c <z_impl_k_timer_stop+0x4c>
		return;
	}

	if (timer->stop_fn != NULL) {
   39c4a:	69e3      	ldr	r3, [r4, #28]
   39c4c:	b10b      	cbz	r3, 39c52 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   39c4e:	4620      	mov	r0, r4
   39c50:	4798      	blx	r3
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
   39c52:	f104 0010 	add.w	r0, r4, #16
   39c56:	2100      	movs	r1, #0
   39c58:	f7f9 fbdc 	bl	33414 <z_find_first_thread_to_unpend>
	if (thread != NULL) {
   39c5c:	4604      	mov	r4, r0
   39c5e:	b1a8      	cbz	r0, 39c8c <z_impl_k_timer_stop+0x4c>
		z_unpend_thread_no_timeout(thread);
   39c60:	f7f9 fc22 	bl	334a8 <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   39c64:	7b63      	ldrb	r3, [r4, #13]
   39c66:	06db      	lsls	r3, r3, #27
   39c68:	d104      	bne.n	39c74 <z_impl_k_timer_stop+0x34>
	if (z_is_thread_ready(thread)) {
   39c6a:	69a3      	ldr	r3, [r4, #24]
   39c6c:	b913      	cbnz	r3, 39c74 <z_impl_k_timer_stop+0x34>
		z_add_thread_to_ready_q(thread);
   39c6e:	4620      	mov	r0, r4
   39c70:	f7f9 fe56 	bl	33920 <z_add_thread_to_ready_q>
   39c74:	f04f 0320 	mov.w	r3, #32
   39c78:	f3ef 8011 	mrs	r0, BASEPRI
   39c7c:	f383 8811 	msr	BASEPRI, r3
   39c80:	f3bf 8f6f 	isb	sy

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
		z_reschedule_unlocked();
	}
}
   39c84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   39c88:	f7ff befb 	b.w	39a82 <z_reschedule_irqlock>
   39c8c:	bd10      	pop	{r4, pc}

00039c8e <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, u32_t state)
{
   39c8e:	b570      	push	{r4, r5, r6, lr}
	struct _poller *poller = event->poller;
   39c90:	6884      	ldr	r4, [r0, #8]
{
   39c92:	4605      	mov	r5, r0
   39c94:	460e      	mov	r6, r1
	int retcode = 0;

	if (poller) {
   39c96:	b19c      	cbz	r4, 39cc0 <signal_poll_event+0x32>
		if (poller->cb != NULL) {
   39c98:	68a3      	ldr	r3, [r4, #8]
   39c9a:	b95b      	cbnz	r3, 39cb4 <signal_poll_event+0x26>
	int retcode = 0;
   39c9c:	4618      	mov	r0, r3
			retcode = poller->cb(event, state);
		}

		poller->is_polling = false;
   39c9e:	7023      	strb	r3, [r4, #0]
	event->poller = NULL;
   39ca0:	2300      	movs	r3, #0
   39ca2:	60ab      	str	r3, [r5, #8]
	event->state |= state;
   39ca4:	68eb      	ldr	r3, [r5, #12]
   39ca6:	f3c3 3204 	ubfx	r2, r3, #12, #5
   39caa:	4316      	orrs	r6, r2
   39cac:	f366 3310 	bfi	r3, r6, #12, #5
   39cb0:	60eb      	str	r3, [r5, #12]
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
   39cb2:	e004      	b.n	39cbe <signal_poll_event+0x30>
			retcode = poller->cb(event, state);
   39cb4:	4798      	blx	r3
		poller->is_polling = false;
   39cb6:	2300      	movs	r3, #0
		if (retcode < 0) {
   39cb8:	2800      	cmp	r0, #0
		poller->is_polling = false;
   39cba:	7023      	strb	r3, [r4, #0]
		if (retcode < 0) {
   39cbc:	daf0      	bge.n	39ca0 <signal_poll_event+0x12>
}
   39cbe:	bd70      	pop	{r4, r5, r6, pc}
	int retcode = 0;
   39cc0:	4620      	mov	r0, r4
   39cc2:	e7ed      	b.n	39ca0 <signal_poll_event+0x12>

00039cc4 <add_event>:
{
   39cc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   39cc6:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   39cc8:	e9d0 2300 	ldrd	r2, r3, [r0]
   39ccc:	4290      	cmp	r0, r2
   39cce:	4604      	mov	r4, r0
   39cd0:	460d      	mov	r5, r1
   39cd2:	d106      	bne.n	39ce2 <add_event+0x1e>
	node->prev = list->tail;
   39cd4:	6863      	ldr	r3, [r4, #4]
	node->next = list;
   39cd6:	602c      	str	r4, [r5, #0]
	node->prev = list->tail;
   39cd8:	606b      	str	r3, [r5, #4]
	list->tail->next = node;
   39cda:	6863      	ldr	r3, [r4, #4]
   39cdc:	601d      	str	r5, [r3, #0]
	list->tail = node;
   39cde:	6065      	str	r5, [r4, #4]
}
   39ce0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
   39ce2:	2b00      	cmp	r3, #0
   39ce4:	d0f6      	beq.n	39cd4 <add_event+0x10>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
   39ce6:	689b      	ldr	r3, [r3, #8]
   39ce8:	6879      	ldr	r1, [r7, #4]
   39cea:	6858      	ldr	r0, [r3, #4]
   39cec:	f7ff fec0 	bl	39a70 <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
   39cf0:	2800      	cmp	r0, #0
   39cf2:	d1ef      	bne.n	39cd4 <add_event+0x10>
	return list->head == list;
   39cf4:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   39cf6:	42b4      	cmp	r4, r6
   39cf8:	d0ec      	beq.n	39cd4 <add_event+0x10>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   39cfa:	2e00      	cmp	r6, #0
   39cfc:	d0ea      	beq.n	39cd4 <add_event+0x10>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
   39cfe:	68b3      	ldr	r3, [r6, #8]
   39d00:	6878      	ldr	r0, [r7, #4]
   39d02:	6859      	ldr	r1, [r3, #4]
   39d04:	f7ff feb4 	bl	39a70 <z_is_t1_higher_prio_than_t2>
   39d08:	b128      	cbz	r0, 39d16 <add_event+0x52>
	node->prev = successor->prev;
   39d0a:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   39d0c:	e9c5 6300 	strd	r6, r3, [r5]
	successor->prev->next = node;
   39d10:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   39d12:	6075      	str	r5, [r6, #4]
			return;
   39d14:	e7e4      	b.n	39ce0 <add_event+0x1c>
	return (node == list->tail) ? NULL : node->next;
   39d16:	6863      	ldr	r3, [r4, #4]
   39d18:	429e      	cmp	r6, r3
   39d1a:	d0db      	beq.n	39cd4 <add_event+0x10>
   39d1c:	6836      	ldr	r6, [r6, #0]
   39d1e:	e7ec      	b.n	39cfa <add_event+0x36>

00039d20 <z_handle_obj_poll_events>:
	return list->head == list;
   39d20:	6803      	ldr	r3, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
   39d22:	4298      	cmp	r0, r3
   39d24:	d009      	beq.n	39d3a <z_handle_obj_poll_events+0x1a>
	node->prev->next = node->next;
   39d26:	e9d3 2000 	ldrd	r2, r0, [r3]
   39d2a:	6002      	str	r2, [r0, #0]
	node->next->prev = node->prev;
   39d2c:	6050      	str	r0, [r2, #4]
	node->next = NULL;
   39d2e:	2200      	movs	r2, #0
{
	struct k_poll_event *poll_event;

	poll_event = (struct k_poll_event *)sys_dlist_get(events);
	if (poll_event != NULL) {
		(void) signal_poll_event(poll_event, state);
   39d30:	4618      	mov	r0, r3
	node->prev = NULL;
   39d32:	e9c3 2200 	strd	r2, r2, [r3]
   39d36:	f7ff bfaa 	b.w	39c8e <signal_poll_event>
	}
}
   39d3a:	4770      	bx	lr

00039d3c <_OffsetAbsSyms>:
					    sizeof(struct _preempt_float));
#else
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF, sizeof(struct k_thread));
#endif

GEN_ABS_SYM_END
   39d3c:	4770      	bx	lr

00039d3e <atoi>:
   39d3e:	220a      	movs	r2, #10
   39d40:	2100      	movs	r1, #0
   39d42:	f7fc bc2b 	b.w	3659c <strtol>

00039d46 <memchr>:
   39d46:	b2c9      	uxtb	r1, r1
   39d48:	4402      	add	r2, r0
   39d4a:	b510      	push	{r4, lr}
   39d4c:	4290      	cmp	r0, r2
   39d4e:	4603      	mov	r3, r0
   39d50:	d101      	bne.n	39d56 <memchr+0x10>
   39d52:	2300      	movs	r3, #0
   39d54:	e003      	b.n	39d5e <memchr+0x18>
   39d56:	781c      	ldrb	r4, [r3, #0]
   39d58:	3001      	adds	r0, #1
   39d5a:	428c      	cmp	r4, r1
   39d5c:	d1f6      	bne.n	39d4c <memchr+0x6>
   39d5e:	4618      	mov	r0, r3
   39d60:	bd10      	pop	{r4, pc}

00039d62 <memcmp>:
   39d62:	b530      	push	{r4, r5, lr}
   39d64:	3901      	subs	r1, #1
   39d66:	2400      	movs	r4, #0
   39d68:	42a2      	cmp	r2, r4
   39d6a:	d101      	bne.n	39d70 <memcmp+0xe>
   39d6c:	2000      	movs	r0, #0
   39d6e:	e005      	b.n	39d7c <memcmp+0x1a>
   39d70:	5d03      	ldrb	r3, [r0, r4]
   39d72:	3401      	adds	r4, #1
   39d74:	5d0d      	ldrb	r5, [r1, r4]
   39d76:	42ab      	cmp	r3, r5
   39d78:	d0f6      	beq.n	39d68 <memcmp+0x6>
   39d7a:	1b58      	subs	r0, r3, r5
   39d7c:	bd30      	pop	{r4, r5, pc}

00039d7e <memcpy>:
   39d7e:	440a      	add	r2, r1
   39d80:	1e43      	subs	r3, r0, #1
   39d82:	4291      	cmp	r1, r2
   39d84:	d100      	bne.n	39d88 <memcpy+0xa>
   39d86:	4770      	bx	lr
   39d88:	b510      	push	{r4, lr}
   39d8a:	f811 4b01 	ldrb.w	r4, [r1], #1
   39d8e:	4291      	cmp	r1, r2
   39d90:	f803 4f01 	strb.w	r4, [r3, #1]!
   39d94:	d1f9      	bne.n	39d8a <memcpy+0xc>
   39d96:	bd10      	pop	{r4, pc}

00039d98 <__memcpy_chk>:
   39d98:	429a      	cmp	r2, r3
   39d9a:	b508      	push	{r3, lr}
   39d9c:	d901      	bls.n	39da2 <__memcpy_chk+0xa>
   39d9e:	f7fc fd73 	bl	36888 <__chk_fail>
   39da2:	4281      	cmp	r1, r0
   39da4:	d804      	bhi.n	39db0 <__memcpy_chk+0x18>
   39da6:	188b      	adds	r3, r1, r2
   39da8:	4298      	cmp	r0, r3
   39daa:	d3f8      	bcc.n	39d9e <__memcpy_chk+0x6>
   39dac:	4281      	cmp	r1, r0
   39dae:	d102      	bne.n	39db6 <__memcpy_chk+0x1e>
   39db0:	1883      	adds	r3, r0, r2
   39db2:	4299      	cmp	r1, r3
   39db4:	d3f3      	bcc.n	39d9e <__memcpy_chk+0x6>
   39db6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   39dba:	f7ff bfe0 	b.w	39d7e <memcpy>

00039dbe <memset>:
   39dbe:	4402      	add	r2, r0
   39dc0:	4603      	mov	r3, r0
   39dc2:	4293      	cmp	r3, r2
   39dc4:	d100      	bne.n	39dc8 <memset+0xa>
   39dc6:	4770      	bx	lr
   39dc8:	f803 1b01 	strb.w	r1, [r3], #1
   39dcc:	e7f9      	b.n	39dc2 <memset+0x4>

00039dce <__memset_chk>:
   39dce:	429a      	cmp	r2, r3
   39dd0:	b508      	push	{r3, lr}
   39dd2:	d901      	bls.n	39dd8 <__memset_chk+0xa>
   39dd4:	f7fc fd58 	bl	36888 <__chk_fail>
   39dd8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   39ddc:	f7ff bfef 	b.w	39dbe <memset>

00039de0 <__sfputc_r>:
   39de0:	6893      	ldr	r3, [r2, #8]
   39de2:	3b01      	subs	r3, #1
   39de4:	2b00      	cmp	r3, #0
   39de6:	6093      	str	r3, [r2, #8]
   39de8:	b410      	push	{r4}
   39dea:	da08      	bge.n	39dfe <__sfputc_r+0x1e>
   39dec:	6994      	ldr	r4, [r2, #24]
   39dee:	42a3      	cmp	r3, r4
   39df0:	db01      	blt.n	39df6 <__sfputc_r+0x16>
   39df2:	290a      	cmp	r1, #10
   39df4:	d103      	bne.n	39dfe <__sfputc_r+0x1e>
   39df6:	f85d 4b04 	ldr.w	r4, [sp], #4
   39dfa:	f7fc bc85 	b.w	36708 <__swbuf_r>
   39dfe:	6813      	ldr	r3, [r2, #0]
   39e00:	1c58      	adds	r0, r3, #1
   39e02:	6010      	str	r0, [r2, #0]
   39e04:	4608      	mov	r0, r1
   39e06:	7019      	strb	r1, [r3, #0]
   39e08:	f85d 4b04 	ldr.w	r4, [sp], #4
   39e0c:	4770      	bx	lr

00039e0e <__sfputs_r>:
   39e0e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   39e10:	4606      	mov	r6, r0
   39e12:	460f      	mov	r7, r1
   39e14:	4614      	mov	r4, r2
   39e16:	18d5      	adds	r5, r2, r3
   39e18:	42ac      	cmp	r4, r5
   39e1a:	d101      	bne.n	39e20 <__sfputs_r+0x12>
   39e1c:	2000      	movs	r0, #0
   39e1e:	e007      	b.n	39e30 <__sfputs_r+0x22>
   39e20:	463a      	mov	r2, r7
   39e22:	f814 1b01 	ldrb.w	r1, [r4], #1
   39e26:	4630      	mov	r0, r6
   39e28:	f7ff ffda 	bl	39de0 <__sfputc_r>
   39e2c:	1c43      	adds	r3, r0, #1
   39e2e:	d1f3      	bne.n	39e18 <__sfputs_r+0xa>
   39e30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00039e32 <__cvt>:
   39e32:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   39e36:	ec55 4b10 	vmov	r4, r5, d0
   39e3a:	2d00      	cmp	r5, #0
   39e3c:	460e      	mov	r6, r1
   39e3e:	4691      	mov	r9, r2
   39e40:	4619      	mov	r1, r3
   39e42:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   39e46:	f04f 0200 	mov.w	r2, #0
   39e4a:	da03      	bge.n	39e54 <__cvt+0x22>
   39e4c:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
   39e50:	222d      	movs	r2, #45	; 0x2d
   39e52:	461d      	mov	r5, r3
   39e54:	9f0d      	ldr	r7, [sp, #52]	; 0x34
   39e56:	700a      	strb	r2, [r1, #0]
   39e58:	f027 0720 	bic.w	r7, r7, #32
   39e5c:	2f46      	cmp	r7, #70	; 0x46
   39e5e:	d004      	beq.n	39e6a <__cvt+0x38>
   39e60:	2f45      	cmp	r7, #69	; 0x45
   39e62:	d100      	bne.n	39e66 <__cvt+0x34>
   39e64:	3601      	adds	r6, #1
   39e66:	2102      	movs	r1, #2
   39e68:	e000      	b.n	39e6c <__cvt+0x3a>
   39e6a:	2103      	movs	r1, #3
   39e6c:	ab03      	add	r3, sp, #12
   39e6e:	4632      	mov	r2, r6
   39e70:	9301      	str	r3, [sp, #4]
   39e72:	ab02      	add	r3, sp, #8
   39e74:	ec45 4b10 	vmov	d0, r4, r5
   39e78:	9300      	str	r3, [sp, #0]
   39e7a:	4653      	mov	r3, sl
   39e7c:	f7e3 fd58 	bl	1d930 <_dtoa_r>
   39e80:	2f47      	cmp	r7, #71	; 0x47
   39e82:	4680      	mov	r8, r0
   39e84:	d102      	bne.n	39e8c <__cvt+0x5a>
   39e86:	f019 0f01 	tst.w	r9, #1
   39e8a:	d022      	beq.n	39ed2 <__cvt+0xa0>
   39e8c:	2f46      	cmp	r7, #70	; 0x46
   39e8e:	eb08 0906 	add.w	r9, r8, r6
   39e92:	d111      	bne.n	39eb8 <__cvt+0x86>
   39e94:	f898 3000 	ldrb.w	r3, [r8]
   39e98:	2b30      	cmp	r3, #48	; 0x30
   39e9a:	d10a      	bne.n	39eb2 <__cvt+0x80>
   39e9c:	2200      	movs	r2, #0
   39e9e:	2300      	movs	r3, #0
   39ea0:	4620      	mov	r0, r4
   39ea2:	4629      	mov	r1, r5
   39ea4:	f7e2 fef0 	bl	1cc88 <__aeabi_dcmpeq>
   39ea8:	b918      	cbnz	r0, 39eb2 <__cvt+0x80>
   39eaa:	f1c6 0601 	rsb	r6, r6, #1
   39eae:	f8ca 6000 	str.w	r6, [sl]
   39eb2:	f8da 3000 	ldr.w	r3, [sl]
   39eb6:	4499      	add	r9, r3
   39eb8:	2200      	movs	r2, #0
   39eba:	2300      	movs	r3, #0
   39ebc:	4620      	mov	r0, r4
   39ebe:	4629      	mov	r1, r5
   39ec0:	f7e2 fee2 	bl	1cc88 <__aeabi_dcmpeq>
   39ec4:	b108      	cbz	r0, 39eca <__cvt+0x98>
   39ec6:	f8cd 900c 	str.w	r9, [sp, #12]
   39eca:	2230      	movs	r2, #48	; 0x30
   39ecc:	9b03      	ldr	r3, [sp, #12]
   39ece:	454b      	cmp	r3, r9
   39ed0:	d308      	bcc.n	39ee4 <__cvt+0xb2>
   39ed2:	9b03      	ldr	r3, [sp, #12]
   39ed4:	4640      	mov	r0, r8
   39ed6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   39ed8:	eba3 0308 	sub.w	r3, r3, r8
   39edc:	6013      	str	r3, [r2, #0]
   39ede:	b004      	add	sp, #16
   39ee0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   39ee4:	1c59      	adds	r1, r3, #1
   39ee6:	9103      	str	r1, [sp, #12]
   39ee8:	701a      	strb	r2, [r3, #0]
   39eea:	e7ef      	b.n	39ecc <__cvt+0x9a>

00039eec <__exponent>:
   39eec:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   39eee:	2900      	cmp	r1, #0
   39ef0:	7002      	strb	r2, [r0, #0]
   39ef2:	bfba      	itte	lt
   39ef4:	4249      	neglt	r1, r1
   39ef6:	232d      	movlt	r3, #45	; 0x2d
   39ef8:	232b      	movge	r3, #43	; 0x2b
   39efa:	2909      	cmp	r1, #9
   39efc:	7043      	strb	r3, [r0, #1]
   39efe:	dd22      	ble.n	39f46 <__exponent+0x5a>
   39f00:	f10d 0307 	add.w	r3, sp, #7
   39f04:	260a      	movs	r6, #10
   39f06:	461f      	mov	r7, r3
   39f08:	2963      	cmp	r1, #99	; 0x63
   39f0a:	f103 35ff 	add.w	r5, r3, #4294967295
   39f0e:	fb91 f2f6 	sdiv	r2, r1, r6
   39f12:	fb06 1412 	mls	r4, r6, r2, r1
   39f16:	f104 0430 	add.w	r4, r4, #48	; 0x30
   39f1a:	f803 4c01 	strb.w	r4, [r3, #-1]
   39f1e:	dc0a      	bgt.n	39f36 <__exponent+0x4a>
   39f20:	3230      	adds	r2, #48	; 0x30
   39f22:	3b02      	subs	r3, #2
   39f24:	f805 2c01 	strb.w	r2, [r5, #-1]
   39f28:	1c82      	adds	r2, r0, #2
   39f2a:	42bb      	cmp	r3, r7
   39f2c:	4614      	mov	r4, r2
   39f2e:	d305      	bcc.n	39f3c <__exponent+0x50>
   39f30:	1a20      	subs	r0, r4, r0
   39f32:	b003      	add	sp, #12
   39f34:	bdf0      	pop	{r4, r5, r6, r7, pc}
   39f36:	462b      	mov	r3, r5
   39f38:	4611      	mov	r1, r2
   39f3a:	e7e5      	b.n	39f08 <__exponent+0x1c>
   39f3c:	f813 1b01 	ldrb.w	r1, [r3], #1
   39f40:	f802 1b01 	strb.w	r1, [r2], #1
   39f44:	e7f1      	b.n	39f2a <__exponent+0x3e>
   39f46:	2330      	movs	r3, #48	; 0x30
   39f48:	1d04      	adds	r4, r0, #4
   39f4a:	4419      	add	r1, r3
   39f4c:	7083      	strb	r3, [r0, #2]
   39f4e:	70c1      	strb	r1, [r0, #3]
   39f50:	e7ee      	b.n	39f30 <__exponent+0x44>

00039f52 <_printf_common>:
   39f52:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   39f56:	4691      	mov	r9, r2
   39f58:	461f      	mov	r7, r3
   39f5a:	688a      	ldr	r2, [r1, #8]
   39f5c:	4606      	mov	r6, r0
   39f5e:	690b      	ldr	r3, [r1, #16]
   39f60:	460c      	mov	r4, r1
   39f62:	f8dd 8020 	ldr.w	r8, [sp, #32]
   39f66:	4293      	cmp	r3, r2
   39f68:	bfb8      	it	lt
   39f6a:	4613      	movlt	r3, r2
   39f6c:	f8c9 3000 	str.w	r3, [r9]
   39f70:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
   39f74:	b112      	cbz	r2, 39f7c <_printf_common+0x2a>
   39f76:	3301      	adds	r3, #1
   39f78:	f8c9 3000 	str.w	r3, [r9]
   39f7c:	6823      	ldr	r3, [r4, #0]
   39f7e:	0699      	lsls	r1, r3, #26
   39f80:	bf42      	ittt	mi
   39f82:	f8d9 3000 	ldrmi.w	r3, [r9]
   39f86:	3302      	addmi	r3, #2
   39f88:	f8c9 3000 	strmi.w	r3, [r9]
   39f8c:	6825      	ldr	r5, [r4, #0]
   39f8e:	f015 0506 	ands.w	r5, r5, #6
   39f92:	d107      	bne.n	39fa4 <_printf_common+0x52>
   39f94:	f104 0a19 	add.w	sl, r4, #25
   39f98:	68e3      	ldr	r3, [r4, #12]
   39f9a:	f8d9 2000 	ldr.w	r2, [r9]
   39f9e:	1a9b      	subs	r3, r3, r2
   39fa0:	42ab      	cmp	r3, r5
   39fa2:	dc2b      	bgt.n	39ffc <_printf_common+0xaa>
   39fa4:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   39fa8:	6822      	ldr	r2, [r4, #0]
   39faa:	3300      	adds	r3, #0
   39fac:	bf18      	it	ne
   39fae:	2301      	movne	r3, #1
   39fb0:	0692      	lsls	r2, r2, #26
   39fb2:	d430      	bmi.n	3a016 <_printf_common+0xc4>
   39fb4:	f104 0243 	add.w	r2, r4, #67	; 0x43
   39fb8:	4639      	mov	r1, r7
   39fba:	4630      	mov	r0, r6
   39fbc:	47c0      	blx	r8
   39fbe:	3001      	adds	r0, #1
   39fc0:	d023      	beq.n	3a00a <_printf_common+0xb8>
   39fc2:	6823      	ldr	r3, [r4, #0]
   39fc4:	341a      	adds	r4, #26
   39fc6:	f854 5c0e 	ldr.w	r5, [r4, #-14]
   39fca:	f003 0306 	and.w	r3, r3, #6
   39fce:	f8d9 2000 	ldr.w	r2, [r9]
   39fd2:	f04f 0900 	mov.w	r9, #0
   39fd6:	2b04      	cmp	r3, #4
   39fd8:	f854 3c12 	ldr.w	r3, [r4, #-18]
   39fdc:	bf08      	it	eq
   39fde:	1aad      	subeq	r5, r5, r2
   39fe0:	f854 2c0a 	ldr.w	r2, [r4, #-10]
   39fe4:	bf14      	ite	ne
   39fe6:	2500      	movne	r5, #0
   39fe8:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
   39fec:	4293      	cmp	r3, r2
   39fee:	bfc4      	itt	gt
   39ff0:	1a9b      	subgt	r3, r3, r2
   39ff2:	18ed      	addgt	r5, r5, r3
   39ff4:	454d      	cmp	r5, r9
   39ff6:	d11a      	bne.n	3a02e <_printf_common+0xdc>
   39ff8:	2000      	movs	r0, #0
   39ffa:	e008      	b.n	3a00e <_printf_common+0xbc>
   39ffc:	2301      	movs	r3, #1
   39ffe:	4652      	mov	r2, sl
   3a000:	4639      	mov	r1, r7
   3a002:	4630      	mov	r0, r6
   3a004:	47c0      	blx	r8
   3a006:	3001      	adds	r0, #1
   3a008:	d103      	bne.n	3a012 <_printf_common+0xc0>
   3a00a:	f04f 30ff 	mov.w	r0, #4294967295
   3a00e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3a012:	3501      	adds	r5, #1
   3a014:	e7c0      	b.n	39f98 <_printf_common+0x46>
   3a016:	18e1      	adds	r1, r4, r3
   3a018:	1c5a      	adds	r2, r3, #1
   3a01a:	2030      	movs	r0, #48	; 0x30
   3a01c:	3302      	adds	r3, #2
   3a01e:	4422      	add	r2, r4
   3a020:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
   3a024:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
   3a028:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
   3a02c:	e7c2      	b.n	39fb4 <_printf_common+0x62>
   3a02e:	2301      	movs	r3, #1
   3a030:	4622      	mov	r2, r4
   3a032:	4639      	mov	r1, r7
   3a034:	4630      	mov	r0, r6
   3a036:	47c0      	blx	r8
   3a038:	3001      	adds	r0, #1
   3a03a:	d0e6      	beq.n	3a00a <_printf_common+0xb8>
   3a03c:	f109 0901 	add.w	r9, r9, #1
   3a040:	e7d8      	b.n	39ff4 <_printf_common+0xa2>

0003a042 <__sprintf_chk>:
   3a042:	b408      	push	{r3}
   3a044:	b517      	push	{r0, r1, r2, r4, lr}
   3a046:	ab05      	add	r3, sp, #20
   3a048:	1e14      	subs	r4, r2, #0
   3a04a:	f853 1b04 	ldr.w	r1, [r3], #4
   3a04e:	9301      	str	r3, [sp, #4]
   3a050:	da07      	bge.n	3a062 <__sprintf_chk+0x20>
   3a052:	461a      	mov	r2, r3
   3a054:	f7fc fb4e 	bl	366f4 <vsiprintf>
   3a058:	b003      	add	sp, #12
   3a05a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   3a05e:	b001      	add	sp, #4
   3a060:	4770      	bx	lr
   3a062:	460a      	mov	r2, r1
   3a064:	4621      	mov	r1, r4
   3a066:	f7fc fb21 	bl	366ac <vsniprintf>
   3a06a:	2800      	cmp	r0, #0
   3a06c:	dbf4      	blt.n	3a058 <__sprintf_chk+0x16>
   3a06e:	42a0      	cmp	r0, r4
   3a070:	d3f2      	bcc.n	3a058 <__sprintf_chk+0x16>
   3a072:	f7fc fc09 	bl	36888 <__chk_fail>

0003a076 <strchr>:
   3a076:	b2c9      	uxtb	r1, r1
   3a078:	4603      	mov	r3, r0
   3a07a:	f810 2b01 	ldrb.w	r2, [r0], #1
   3a07e:	b11a      	cbz	r2, 3a088 <strchr+0x12>
   3a080:	428a      	cmp	r2, r1
   3a082:	d1f9      	bne.n	3a078 <strchr+0x2>
   3a084:	4618      	mov	r0, r3
   3a086:	4770      	bx	lr
   3a088:	2900      	cmp	r1, #0
   3a08a:	bf18      	it	ne
   3a08c:	2300      	movne	r3, #0
   3a08e:	e7f9      	b.n	3a084 <strchr+0xe>

0003a090 <strcpy>:
   3a090:	4603      	mov	r3, r0
   3a092:	f811 2b01 	ldrb.w	r2, [r1], #1
   3a096:	f803 2b01 	strb.w	r2, [r3], #1
   3a09a:	2a00      	cmp	r2, #0
   3a09c:	d1f9      	bne.n	3a092 <strcpy+0x2>
   3a09e:	4770      	bx	lr

0003a0a0 <strncmp>:
   3a0a0:	b510      	push	{r4, lr}
   3a0a2:	b16a      	cbz	r2, 3a0c0 <strncmp+0x20>
   3a0a4:	3901      	subs	r1, #1
   3a0a6:	1884      	adds	r4, r0, r2
   3a0a8:	f810 3b01 	ldrb.w	r3, [r0], #1
   3a0ac:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   3a0b0:	4293      	cmp	r3, r2
   3a0b2:	d103      	bne.n	3a0bc <strncmp+0x1c>
   3a0b4:	42a0      	cmp	r0, r4
   3a0b6:	d001      	beq.n	3a0bc <strncmp+0x1c>
   3a0b8:	2b00      	cmp	r3, #0
   3a0ba:	d1f5      	bne.n	3a0a8 <strncmp+0x8>
   3a0bc:	1a98      	subs	r0, r3, r2
   3a0be:	bd10      	pop	{r4, pc}
   3a0c0:	4610      	mov	r0, r2
   3a0c2:	e7fc      	b.n	3a0be <strncmp+0x1e>

0003a0c4 <strstr>:
   3a0c4:	b5f0      	push	{r4, r5, r6, r7, lr}
   3a0c6:	780c      	ldrb	r4, [r1, #0]
   3a0c8:	b164      	cbz	r4, 3a0e4 <strstr+0x20>
   3a0ca:	4603      	mov	r3, r0
   3a0cc:	781a      	ldrb	r2, [r3, #0]
   3a0ce:	4618      	mov	r0, r3
   3a0d0:	1c5e      	adds	r6, r3, #1
   3a0d2:	b90a      	cbnz	r2, 3a0d8 <strstr+0x14>
   3a0d4:	4610      	mov	r0, r2
   3a0d6:	e005      	b.n	3a0e4 <strstr+0x20>
   3a0d8:	4294      	cmp	r4, r2
   3a0da:	d108      	bne.n	3a0ee <strstr+0x2a>
   3a0dc:	460d      	mov	r5, r1
   3a0de:	f815 2f01 	ldrb.w	r2, [r5, #1]!
   3a0e2:	b902      	cbnz	r2, 3a0e6 <strstr+0x22>
   3a0e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   3a0e6:	f813 7f01 	ldrb.w	r7, [r3, #1]!
   3a0ea:	4297      	cmp	r7, r2
   3a0ec:	d0f7      	beq.n	3a0de <strstr+0x1a>
   3a0ee:	4633      	mov	r3, r6
   3a0f0:	e7ec      	b.n	3a0cc <strstr+0x8>

0003a0f2 <_vsniprintf_r>:
   3a0f2:	b530      	push	{r4, r5, lr}
   3a0f4:	1e14      	subs	r4, r2, #0
   3a0f6:	4605      	mov	r5, r0
   3a0f8:	b09b      	sub	sp, #108	; 0x6c
   3a0fa:	4618      	mov	r0, r3
   3a0fc:	da05      	bge.n	3a10a <_vsniprintf_r+0x18>
   3a0fe:	238b      	movs	r3, #139	; 0x8b
   3a100:	f04f 30ff 	mov.w	r0, #4294967295
   3a104:	602b      	str	r3, [r5, #0]
   3a106:	b01b      	add	sp, #108	; 0x6c
   3a108:	bd30      	pop	{r4, r5, pc}
   3a10a:	f44f 7302 	mov.w	r3, #520	; 0x208
   3a10e:	9100      	str	r1, [sp, #0]
   3a110:	9104      	str	r1, [sp, #16]
   3a112:	4602      	mov	r2, r0
   3a114:	f8ad 300c 	strh.w	r3, [sp, #12]
   3a118:	bf14      	ite	ne
   3a11a:	f104 33ff 	addne.w	r3, r4, #4294967295
   3a11e:	4623      	moveq	r3, r4
   3a120:	4669      	mov	r1, sp
   3a122:	4628      	mov	r0, r5
   3a124:	9302      	str	r3, [sp, #8]
   3a126:	9305      	str	r3, [sp, #20]
   3a128:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3a12c:	f8ad 300e 	strh.w	r3, [sp, #14]
   3a130:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   3a132:	f7fc fe8f 	bl	36e54 <_svfiprintf_r>
   3a136:	1c43      	adds	r3, r0, #1
   3a138:	bfbc      	itt	lt
   3a13a:	238b      	movlt	r3, #139	; 0x8b
   3a13c:	602b      	strlt	r3, [r5, #0]
   3a13e:	2c00      	cmp	r4, #0
   3a140:	d0e1      	beq.n	3a106 <_vsniprintf_r+0x14>
   3a142:	9b00      	ldr	r3, [sp, #0]
   3a144:	2200      	movs	r2, #0
   3a146:	701a      	strb	r2, [r3, #0]
   3a148:	e7dd      	b.n	3a106 <_vsniprintf_r+0x14>

0003a14a <abort>:
   3a14a:	b508      	push	{r3, lr}
   3a14c:	2006      	movs	r0, #6
   3a14e:	f7fc ff89 	bl	37064 <raise>
   3a152:	2001      	movs	r0, #1
   3a154:	f7eb fea2 	bl	25e9c <_exit>

0003a158 <quorem>:
   3a158:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3a15c:	6903      	ldr	r3, [r0, #16]
   3a15e:	4680      	mov	r8, r0
   3a160:	690c      	ldr	r4, [r1, #16]
   3a162:	42a3      	cmp	r3, r4
   3a164:	f2c0 8084 	blt.w	3a270 <quorem+0x118>
   3a168:	3c01      	subs	r4, #1
   3a16a:	f108 0514 	add.w	r5, r8, #20
   3a16e:	f101 0714 	add.w	r7, r1, #20
   3a172:	00a0      	lsls	r0, r4, #2
   3a174:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   3a178:	182b      	adds	r3, r5, r0
   3a17a:	eb07 0900 	add.w	r9, r7, r0
   3a17e:	9301      	str	r3, [sp, #4]
   3a180:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
   3a184:	3301      	adds	r3, #1
   3a186:	429a      	cmp	r2, r3
   3a188:	fbb2 f6f3 	udiv	r6, r2, r3
   3a18c:	d333      	bcc.n	3a1f6 <quorem+0x9e>
   3a18e:	f04f 0a00 	mov.w	sl, #0
   3a192:	46bc      	mov	ip, r7
   3a194:	46ae      	mov	lr, r5
   3a196:	46d3      	mov	fp, sl
   3a198:	f85c 2b04 	ldr.w	r2, [ip], #4
   3a19c:	b293      	uxth	r3, r2
   3a19e:	45e1      	cmp	r9, ip
   3a1a0:	ea4f 4212 	mov.w	r2, r2, lsr #16
   3a1a4:	fb06 a303 	mla	r3, r6, r3, sl
   3a1a8:	ea4f 4a13 	mov.w	sl, r3, lsr #16
   3a1ac:	b29b      	uxth	r3, r3
   3a1ae:	fb06 a202 	mla	r2, r6, r2, sl
   3a1b2:	ebab 0303 	sub.w	r3, fp, r3
   3a1b6:	f8de b000 	ldr.w	fp, [lr]
   3a1ba:	ea4f 4a12 	mov.w	sl, r2, lsr #16
   3a1be:	fa1f fb8b 	uxth.w	fp, fp
   3a1c2:	445b      	add	r3, fp
   3a1c4:	fa1f fb82 	uxth.w	fp, r2
   3a1c8:	f8de 2000 	ldr.w	r2, [lr]
   3a1cc:	ebcb 4212 	rsb	r2, fp, r2, lsr #16
   3a1d0:	eb02 4223 	add.w	r2, r2, r3, asr #16
   3a1d4:	b29b      	uxth	r3, r3
   3a1d6:	ea4f 4b22 	mov.w	fp, r2, asr #16
   3a1da:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   3a1de:	f84e 3b04 	str.w	r3, [lr], #4
   3a1e2:	d2d9      	bcs.n	3a198 <quorem+0x40>
   3a1e4:	582b      	ldr	r3, [r5, r0]
   3a1e6:	b933      	cbnz	r3, 3a1f6 <quorem+0x9e>
   3a1e8:	9b01      	ldr	r3, [sp, #4]
   3a1ea:	3b04      	subs	r3, #4
   3a1ec:	429d      	cmp	r5, r3
   3a1ee:	461a      	mov	r2, r3
   3a1f0:	d332      	bcc.n	3a258 <quorem+0x100>
   3a1f2:	f8c8 4010 	str.w	r4, [r8, #16]
   3a1f6:	4640      	mov	r0, r8
   3a1f8:	f000 fa74 	bl	3a6e4 <__mcmp>
   3a1fc:	2800      	cmp	r0, #0
   3a1fe:	db27      	blt.n	3a250 <quorem+0xf8>
   3a200:	3601      	adds	r6, #1
   3a202:	4628      	mov	r0, r5
   3a204:	f04f 0c00 	mov.w	ip, #0
   3a208:	f857 1b04 	ldr.w	r1, [r7], #4
   3a20c:	f8d0 e000 	ldr.w	lr, [r0]
   3a210:	b28b      	uxth	r3, r1
   3a212:	45b9      	cmp	r9, r7
   3a214:	fa1f f28e 	uxth.w	r2, lr
   3a218:	ebac 0303 	sub.w	r3, ip, r3
   3a21c:	4413      	add	r3, r2
   3a21e:	ea4f 4211 	mov.w	r2, r1, lsr #16
   3a222:	ebc2 421e 	rsb	r2, r2, lr, lsr #16
   3a226:	eb02 4223 	add.w	r2, r2, r3, asr #16
   3a22a:	b29b      	uxth	r3, r3
   3a22c:	ea4f 4c22 	mov.w	ip, r2, asr #16
   3a230:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   3a234:	f840 3b04 	str.w	r3, [r0], #4
   3a238:	d2e6      	bcs.n	3a208 <quorem+0xb0>
   3a23a:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   3a23e:	eb05 0384 	add.w	r3, r5, r4, lsl #2
   3a242:	b92a      	cbnz	r2, 3a250 <quorem+0xf8>
   3a244:	3b04      	subs	r3, #4
   3a246:	429d      	cmp	r5, r3
   3a248:	461a      	mov	r2, r3
   3a24a:	d30b      	bcc.n	3a264 <quorem+0x10c>
   3a24c:	f8c8 4010 	str.w	r4, [r8, #16]
   3a250:	4630      	mov	r0, r6
   3a252:	b003      	add	sp, #12
   3a254:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3a258:	6812      	ldr	r2, [r2, #0]
   3a25a:	3b04      	subs	r3, #4
   3a25c:	2a00      	cmp	r2, #0
   3a25e:	d1c8      	bne.n	3a1f2 <quorem+0x9a>
   3a260:	3c01      	subs	r4, #1
   3a262:	e7c3      	b.n	3a1ec <quorem+0x94>
   3a264:	6812      	ldr	r2, [r2, #0]
   3a266:	3b04      	subs	r3, #4
   3a268:	2a00      	cmp	r2, #0
   3a26a:	d1ef      	bne.n	3a24c <quorem+0xf4>
   3a26c:	3c01      	subs	r4, #1
   3a26e:	e7ea      	b.n	3a246 <quorem+0xee>
   3a270:	2000      	movs	r0, #0
   3a272:	e7ee      	b.n	3a252 <quorem+0xfa>

0003a274 <__sfmoreglue>:
   3a274:	b570      	push	{r4, r5, r6, lr}
   3a276:	1e4a      	subs	r2, r1, #1
   3a278:	2568      	movs	r5, #104	; 0x68
   3a27a:	460e      	mov	r6, r1
   3a27c:	4355      	muls	r5, r2
   3a27e:	f105 0174 	add.w	r1, r5, #116	; 0x74
   3a282:	f7fc fd8d 	bl	36da0 <_malloc_r>
   3a286:	4604      	mov	r4, r0
   3a288:	b140      	cbz	r0, 3a29c <__sfmoreglue+0x28>
   3a28a:	2100      	movs	r1, #0
   3a28c:	f105 0268 	add.w	r2, r5, #104	; 0x68
   3a290:	e9c0 1600 	strd	r1, r6, [r0]
   3a294:	300c      	adds	r0, #12
   3a296:	60a0      	str	r0, [r4, #8]
   3a298:	f7ff fd91 	bl	39dbe <memset>
   3a29c:	4620      	mov	r0, r4
   3a29e:	bd70      	pop	{r4, r5, r6, pc}

0003a2a0 <_fwalk_reent>:
   3a2a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   3a2a4:	4680      	mov	r8, r0
   3a2a6:	4689      	mov	r9, r1
   3a2a8:	f100 0448 	add.w	r4, r0, #72	; 0x48
   3a2ac:	2600      	movs	r6, #0
   3a2ae:	b914      	cbnz	r4, 3a2b6 <_fwalk_reent+0x16>
   3a2b0:	4630      	mov	r0, r6
   3a2b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   3a2b6:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
   3a2ba:	3f01      	subs	r7, #1
   3a2bc:	d501      	bpl.n	3a2c2 <_fwalk_reent+0x22>
   3a2be:	6824      	ldr	r4, [r4, #0]
   3a2c0:	e7f5      	b.n	3a2ae <_fwalk_reent+0xe>
   3a2c2:	89ab      	ldrh	r3, [r5, #12]
   3a2c4:	2b01      	cmp	r3, #1
   3a2c6:	d907      	bls.n	3a2d8 <_fwalk_reent+0x38>
   3a2c8:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
   3a2cc:	3301      	adds	r3, #1
   3a2ce:	d003      	beq.n	3a2d8 <_fwalk_reent+0x38>
   3a2d0:	4629      	mov	r1, r5
   3a2d2:	4640      	mov	r0, r8
   3a2d4:	47c8      	blx	r9
   3a2d6:	4306      	orrs	r6, r0
   3a2d8:	3568      	adds	r5, #104	; 0x68
   3a2da:	e7ee      	b.n	3a2ba <_fwalk_reent+0x1a>

0003a2dc <__retarget_lock_init_recursive>:
   3a2dc:	4770      	bx	lr

0003a2de <__retarget_lock_acquire_recursive>:
   3a2de:	4770      	bx	lr

0003a2e0 <__retarget_lock_release_recursive>:
   3a2e0:	4770      	bx	lr

0003a2e2 <__swhatbuf_r>:
   3a2e2:	b570      	push	{r4, r5, r6, lr}
   3a2e4:	460e      	mov	r6, r1
   3a2e6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   3a2ea:	b096      	sub	sp, #88	; 0x58
   3a2ec:	4614      	mov	r4, r2
   3a2ee:	2900      	cmp	r1, #0
   3a2f0:	461d      	mov	r5, r3
   3a2f2:	da07      	bge.n	3a304 <__swhatbuf_r+0x22>
   3a2f4:	2300      	movs	r3, #0
   3a2f6:	602b      	str	r3, [r5, #0]
   3a2f8:	89b3      	ldrh	r3, [r6, #12]
   3a2fa:	061a      	lsls	r2, r3, #24
   3a2fc:	d410      	bmi.n	3a320 <__swhatbuf_r+0x3e>
   3a2fe:	f44f 6380 	mov.w	r3, #1024	; 0x400
   3a302:	e00e      	b.n	3a322 <__swhatbuf_r+0x40>
   3a304:	466a      	mov	r2, sp
   3a306:	f7fc fee9 	bl	370dc <_fstat_r>
   3a30a:	2800      	cmp	r0, #0
   3a30c:	dbf2      	blt.n	3a2f4 <__swhatbuf_r+0x12>
   3a30e:	9a01      	ldr	r2, [sp, #4]
   3a310:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
   3a314:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
   3a318:	425a      	negs	r2, r3
   3a31a:	415a      	adcs	r2, r3
   3a31c:	602a      	str	r2, [r5, #0]
   3a31e:	e7ee      	b.n	3a2fe <__swhatbuf_r+0x1c>
   3a320:	2340      	movs	r3, #64	; 0x40
   3a322:	2000      	movs	r0, #0
   3a324:	6023      	str	r3, [r4, #0]
   3a326:	b016      	add	sp, #88	; 0x58
   3a328:	bd70      	pop	{r4, r5, r6, pc}

0003a32a <memmove>:
   3a32a:	4288      	cmp	r0, r1
   3a32c:	eb01 0302 	add.w	r3, r1, r2
   3a330:	b510      	push	{r4, lr}
   3a332:	d902      	bls.n	3a33a <memmove+0x10>
   3a334:	4283      	cmp	r3, r0
   3a336:	461c      	mov	r4, r3
   3a338:	d807      	bhi.n	3a34a <memmove+0x20>
   3a33a:	1e42      	subs	r2, r0, #1
   3a33c:	4299      	cmp	r1, r3
   3a33e:	d008      	beq.n	3a352 <memmove+0x28>
   3a340:	f811 4b01 	ldrb.w	r4, [r1], #1
   3a344:	f802 4f01 	strb.w	r4, [r2, #1]!
   3a348:	e7f8      	b.n	3a33c <memmove+0x12>
   3a34a:	1883      	adds	r3, r0, r2
   3a34c:	1a9a      	subs	r2, r3, r2
   3a34e:	429a      	cmp	r2, r3
   3a350:	d100      	bne.n	3a354 <memmove+0x2a>
   3a352:	bd10      	pop	{r4, pc}
   3a354:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
   3a358:	f803 1d01 	strb.w	r1, [r3, #-1]!
   3a35c:	e7f7      	b.n	3a34e <memmove+0x24>

0003a35e <_Balloc>:
   3a35e:	b570      	push	{r4, r5, r6, lr}
   3a360:	6a45      	ldr	r5, [r0, #36]	; 0x24
   3a362:	4604      	mov	r4, r0
   3a364:	460e      	mov	r6, r1
   3a366:	b93d      	cbnz	r5, 3a378 <_Balloc+0x1a>
   3a368:	2010      	movs	r0, #16
   3a36a:	f7fc fc75 	bl	36c58 <malloc>
   3a36e:	6260      	str	r0, [r4, #36]	; 0x24
   3a370:	6005      	str	r5, [r0, #0]
   3a372:	60c5      	str	r5, [r0, #12]
   3a374:	e9c0 5501 	strd	r5, r5, [r0, #4]
   3a378:	6a65      	ldr	r5, [r4, #36]	; 0x24
   3a37a:	68eb      	ldr	r3, [r5, #12]
   3a37c:	b183      	cbz	r3, 3a3a0 <_Balloc+0x42>
   3a37e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   3a380:	68db      	ldr	r3, [r3, #12]
   3a382:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
   3a386:	b9b8      	cbnz	r0, 3a3b8 <_Balloc+0x5a>
   3a388:	2101      	movs	r1, #1
   3a38a:	4620      	mov	r0, r4
   3a38c:	fa01 f506 	lsl.w	r5, r1, r6
   3a390:	1d6a      	adds	r2, r5, #5
   3a392:	0092      	lsls	r2, r2, #2
   3a394:	f000 fa6e 	bl	3a874 <_calloc_r>
   3a398:	b160      	cbz	r0, 3a3b4 <_Balloc+0x56>
   3a39a:	e9c0 6501 	strd	r6, r5, [r0, #4]
   3a39e:	e00e      	b.n	3a3be <_Balloc+0x60>
   3a3a0:	2221      	movs	r2, #33	; 0x21
   3a3a2:	2104      	movs	r1, #4
   3a3a4:	4620      	mov	r0, r4
   3a3a6:	f000 fa65 	bl	3a874 <_calloc_r>
   3a3aa:	6a63      	ldr	r3, [r4, #36]	; 0x24
   3a3ac:	60e8      	str	r0, [r5, #12]
   3a3ae:	68db      	ldr	r3, [r3, #12]
   3a3b0:	2b00      	cmp	r3, #0
   3a3b2:	d1e4      	bne.n	3a37e <_Balloc+0x20>
   3a3b4:	2000      	movs	r0, #0
   3a3b6:	bd70      	pop	{r4, r5, r6, pc}
   3a3b8:	6802      	ldr	r2, [r0, #0]
   3a3ba:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
   3a3be:	2300      	movs	r3, #0
   3a3c0:	e9c0 3303 	strd	r3, r3, [r0, #12]
   3a3c4:	e7f7      	b.n	3a3b6 <_Balloc+0x58>

0003a3c6 <_Bfree>:
   3a3c6:	b570      	push	{r4, r5, r6, lr}
   3a3c8:	6a44      	ldr	r4, [r0, #36]	; 0x24
   3a3ca:	4606      	mov	r6, r0
   3a3cc:	460d      	mov	r5, r1
   3a3ce:	b93c      	cbnz	r4, 3a3e0 <_Bfree+0x1a>
   3a3d0:	2010      	movs	r0, #16
   3a3d2:	f7fc fc41 	bl	36c58 <malloc>
   3a3d6:	6270      	str	r0, [r6, #36]	; 0x24
   3a3d8:	6004      	str	r4, [r0, #0]
   3a3da:	60c4      	str	r4, [r0, #12]
   3a3dc:	e9c0 4401 	strd	r4, r4, [r0, #4]
   3a3e0:	b13d      	cbz	r5, 3a3f2 <_Bfree+0x2c>
   3a3e2:	6a73      	ldr	r3, [r6, #36]	; 0x24
   3a3e4:	686a      	ldr	r2, [r5, #4]
   3a3e6:	68db      	ldr	r3, [r3, #12]
   3a3e8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   3a3ec:	6029      	str	r1, [r5, #0]
   3a3ee:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
   3a3f2:	bd70      	pop	{r4, r5, r6, pc}

0003a3f4 <__multadd>:
   3a3f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3a3f8:	f101 0c14 	add.w	ip, r1, #20
   3a3fc:	461f      	mov	r7, r3
   3a3fe:	4606      	mov	r6, r0
   3a400:	460c      	mov	r4, r1
   3a402:	690d      	ldr	r5, [r1, #16]
   3a404:	2300      	movs	r3, #0
   3a406:	f8dc 0000 	ldr.w	r0, [ip]
   3a40a:	3301      	adds	r3, #1
   3a40c:	b281      	uxth	r1, r0
   3a40e:	429d      	cmp	r5, r3
   3a410:	ea4f 4010 	mov.w	r0, r0, lsr #16
   3a414:	fb02 7101 	mla	r1, r2, r1, r7
   3a418:	ea4f 4711 	mov.w	r7, r1, lsr #16
   3a41c:	b289      	uxth	r1, r1
   3a41e:	fb02 7000 	mla	r0, r2, r0, r7
   3a422:	eb01 4100 	add.w	r1, r1, r0, lsl #16
   3a426:	ea4f 4710 	mov.w	r7, r0, lsr #16
   3a42a:	f84c 1b04 	str.w	r1, [ip], #4
   3a42e:	dcea      	bgt.n	3a406 <__multadd+0x12>
   3a430:	b1d7      	cbz	r7, 3a468 <__multadd+0x74>
   3a432:	68a3      	ldr	r3, [r4, #8]
   3a434:	42ab      	cmp	r3, r5
   3a436:	dc12      	bgt.n	3a45e <__multadd+0x6a>
   3a438:	6861      	ldr	r1, [r4, #4]
   3a43a:	4630      	mov	r0, r6
   3a43c:	3101      	adds	r1, #1
   3a43e:	f7ff ff8e 	bl	3a35e <_Balloc>
   3a442:	6922      	ldr	r2, [r4, #16]
   3a444:	4680      	mov	r8, r0
   3a446:	f104 010c 	add.w	r1, r4, #12
   3a44a:	3202      	adds	r2, #2
   3a44c:	300c      	adds	r0, #12
   3a44e:	0092      	lsls	r2, r2, #2
   3a450:	f7ff fc95 	bl	39d7e <memcpy>
   3a454:	4621      	mov	r1, r4
   3a456:	4644      	mov	r4, r8
   3a458:	4630      	mov	r0, r6
   3a45a:	f7ff ffb4 	bl	3a3c6 <_Bfree>
   3a45e:	eb04 0385 	add.w	r3, r4, r5, lsl #2
   3a462:	3501      	adds	r5, #1
   3a464:	615f      	str	r7, [r3, #20]
   3a466:	6125      	str	r5, [r4, #16]
   3a468:	4620      	mov	r0, r4
   3a46a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0003a46e <__hi0bits>:
   3a46e:	0c02      	lsrs	r2, r0, #16
   3a470:	4603      	mov	r3, r0
   3a472:	0412      	lsls	r2, r2, #16
   3a474:	b9ca      	cbnz	r2, 3a4aa <__hi0bits+0x3c>
   3a476:	0403      	lsls	r3, r0, #16
   3a478:	2010      	movs	r0, #16
   3a47a:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
   3a47e:	bf04      	itt	eq
   3a480:	021b      	lsleq	r3, r3, #8
   3a482:	3008      	addeq	r0, #8
   3a484:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
   3a488:	bf04      	itt	eq
   3a48a:	011b      	lsleq	r3, r3, #4
   3a48c:	3004      	addeq	r0, #4
   3a48e:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
   3a492:	bf04      	itt	eq
   3a494:	009b      	lsleq	r3, r3, #2
   3a496:	3002      	addeq	r0, #2
   3a498:	2b00      	cmp	r3, #0
   3a49a:	db05      	blt.n	3a4a8 <__hi0bits+0x3a>
   3a49c:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
   3a4a0:	f100 0001 	add.w	r0, r0, #1
   3a4a4:	bf08      	it	eq
   3a4a6:	2020      	moveq	r0, #32
   3a4a8:	4770      	bx	lr
   3a4aa:	2000      	movs	r0, #0
   3a4ac:	e7e5      	b.n	3a47a <__hi0bits+0xc>

0003a4ae <__lo0bits>:
   3a4ae:	6803      	ldr	r3, [r0, #0]
   3a4b0:	4601      	mov	r1, r0
   3a4b2:	f013 0207 	ands.w	r2, r3, #7
   3a4b6:	d00b      	beq.n	3a4d0 <__lo0bits+0x22>
   3a4b8:	07da      	lsls	r2, r3, #31
   3a4ba:	d424      	bmi.n	3a506 <__lo0bits+0x58>
   3a4bc:	0798      	lsls	r0, r3, #30
   3a4be:	bf47      	ittee	mi
   3a4c0:	085b      	lsrmi	r3, r3, #1
   3a4c2:	2001      	movmi	r0, #1
   3a4c4:	089b      	lsrpl	r3, r3, #2
   3a4c6:	2002      	movpl	r0, #2
   3a4c8:	bf4c      	ite	mi
   3a4ca:	600b      	strmi	r3, [r1, #0]
   3a4cc:	600b      	strpl	r3, [r1, #0]
   3a4ce:	4770      	bx	lr
   3a4d0:	b298      	uxth	r0, r3
   3a4d2:	b9b0      	cbnz	r0, 3a502 <__lo0bits+0x54>
   3a4d4:	0c1b      	lsrs	r3, r3, #16
   3a4d6:	2010      	movs	r0, #16
   3a4d8:	f013 0fff 	tst.w	r3, #255	; 0xff
   3a4dc:	bf04      	itt	eq
   3a4de:	0a1b      	lsreq	r3, r3, #8
   3a4e0:	3008      	addeq	r0, #8
   3a4e2:	071a      	lsls	r2, r3, #28
   3a4e4:	bf04      	itt	eq
   3a4e6:	091b      	lsreq	r3, r3, #4
   3a4e8:	3004      	addeq	r0, #4
   3a4ea:	079a      	lsls	r2, r3, #30
   3a4ec:	bf04      	itt	eq
   3a4ee:	089b      	lsreq	r3, r3, #2
   3a4f0:	3002      	addeq	r0, #2
   3a4f2:	07da      	lsls	r2, r3, #31
   3a4f4:	d403      	bmi.n	3a4fe <__lo0bits+0x50>
   3a4f6:	085b      	lsrs	r3, r3, #1
   3a4f8:	f100 0001 	add.w	r0, r0, #1
   3a4fc:	d005      	beq.n	3a50a <__lo0bits+0x5c>
   3a4fe:	600b      	str	r3, [r1, #0]
   3a500:	4770      	bx	lr
   3a502:	4610      	mov	r0, r2
   3a504:	e7e8      	b.n	3a4d8 <__lo0bits+0x2a>
   3a506:	2000      	movs	r0, #0
   3a508:	4770      	bx	lr
   3a50a:	2020      	movs	r0, #32
   3a50c:	4770      	bx	lr

0003a50e <__i2b>:
   3a50e:	b510      	push	{r4, lr}
   3a510:	460c      	mov	r4, r1
   3a512:	2101      	movs	r1, #1
   3a514:	f7ff ff23 	bl	3a35e <_Balloc>
   3a518:	2201      	movs	r2, #1
   3a51a:	6144      	str	r4, [r0, #20]
   3a51c:	6102      	str	r2, [r0, #16]
   3a51e:	bd10      	pop	{r4, pc}

0003a520 <__multiply>:
   3a520:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3a524:	4690      	mov	r8, r2
   3a526:	690a      	ldr	r2, [r1, #16]
   3a528:	460c      	mov	r4, r1
   3a52a:	f8d8 3010 	ldr.w	r3, [r8, #16]
   3a52e:	429a      	cmp	r2, r3
   3a530:	bfbe      	ittt	lt
   3a532:	460b      	movlt	r3, r1
   3a534:	4644      	movlt	r4, r8
   3a536:	4698      	movlt	r8, r3
   3a538:	6927      	ldr	r7, [r4, #16]
   3a53a:	68a3      	ldr	r3, [r4, #8]
   3a53c:	f8d8 9010 	ldr.w	r9, [r8, #16]
   3a540:	6861      	ldr	r1, [r4, #4]
   3a542:	eb07 0609 	add.w	r6, r7, r9
   3a546:	42b3      	cmp	r3, r6
   3a548:	bfb8      	it	lt
   3a54a:	3101      	addlt	r1, #1
   3a54c:	f7ff ff07 	bl	3a35e <_Balloc>
   3a550:	f100 0514 	add.w	r5, r0, #20
   3a554:	2200      	movs	r2, #0
   3a556:	eb05 0e86 	add.w	lr, r5, r6, lsl #2
   3a55a:	462b      	mov	r3, r5
   3a55c:	4573      	cmp	r3, lr
   3a55e:	d316      	bcc.n	3a58e <__multiply+0x6e>
   3a560:	f104 0314 	add.w	r3, r4, #20
   3a564:	f108 0214 	add.w	r2, r8, #20
   3a568:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   3a56c:	eb02 0389 	add.w	r3, r2, r9, lsl #2
   3a570:	9300      	str	r3, [sp, #0]
   3a572:	9b00      	ldr	r3, [sp, #0]
   3a574:	9201      	str	r2, [sp, #4]
   3a576:	4293      	cmp	r3, r2
   3a578:	d80c      	bhi.n	3a594 <__multiply+0x74>
   3a57a:	2e00      	cmp	r6, #0
   3a57c:	dd03      	ble.n	3a586 <__multiply+0x66>
   3a57e:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
   3a582:	2b00      	cmp	r3, #0
   3a584:	d059      	beq.n	3a63a <__multiply+0x11a>
   3a586:	6106      	str	r6, [r0, #16]
   3a588:	b003      	add	sp, #12
   3a58a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3a58e:	f843 2b04 	str.w	r2, [r3], #4
   3a592:	e7e3      	b.n	3a55c <__multiply+0x3c>
   3a594:	f8b2 a000 	ldrh.w	sl, [r2]
   3a598:	f1ba 0f00 	cmp.w	sl, #0
   3a59c:	d023      	beq.n	3a5e6 <__multiply+0xc6>
   3a59e:	f104 0914 	add.w	r9, r4, #20
   3a5a2:	46ac      	mov	ip, r5
   3a5a4:	f04f 0800 	mov.w	r8, #0
   3a5a8:	f859 1b04 	ldr.w	r1, [r9], #4
   3a5ac:	f8dc b000 	ldr.w	fp, [ip]
   3a5b0:	b28b      	uxth	r3, r1
   3a5b2:	454f      	cmp	r7, r9
   3a5b4:	fa1f fb8b 	uxth.w	fp, fp
   3a5b8:	fb0a b303 	mla	r3, sl, r3, fp
   3a5bc:	ea4f 4b11 	mov.w	fp, r1, lsr #16
   3a5c0:	f8dc 1000 	ldr.w	r1, [ip]
   3a5c4:	4443      	add	r3, r8
   3a5c6:	ea4f 4811 	mov.w	r8, r1, lsr #16
   3a5ca:	fb0a 810b 	mla	r1, sl, fp, r8
   3a5ce:	eb01 4113 	add.w	r1, r1, r3, lsr #16
   3a5d2:	b29b      	uxth	r3, r3
   3a5d4:	ea4f 4811 	mov.w	r8, r1, lsr #16
   3a5d8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   3a5dc:	f84c 3b04 	str.w	r3, [ip], #4
   3a5e0:	d8e2      	bhi.n	3a5a8 <__multiply+0x88>
   3a5e2:	f8cc 8000 	str.w	r8, [ip]
   3a5e6:	9b01      	ldr	r3, [sp, #4]
   3a5e8:	3204      	adds	r2, #4
   3a5ea:	f8b3 9002 	ldrh.w	r9, [r3, #2]
   3a5ee:	f1b9 0f00 	cmp.w	r9, #0
   3a5f2:	d020      	beq.n	3a636 <__multiply+0x116>
   3a5f4:	682b      	ldr	r3, [r5, #0]
   3a5f6:	f104 0814 	add.w	r8, r4, #20
   3a5fa:	46ac      	mov	ip, r5
   3a5fc:	f04f 0a00 	mov.w	sl, #0
   3a600:	f8b8 1000 	ldrh.w	r1, [r8]
   3a604:	b29b      	uxth	r3, r3
   3a606:	f8bc b002 	ldrh.w	fp, [ip, #2]
   3a60a:	fb09 b101 	mla	r1, r9, r1, fp
   3a60e:	448a      	add	sl, r1
   3a610:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
   3a614:	f84c 3b04 	str.w	r3, [ip], #4
   3a618:	f858 3b04 	ldr.w	r3, [r8], #4
   3a61c:	f8bc 1000 	ldrh.w	r1, [ip]
   3a620:	0c1b      	lsrs	r3, r3, #16
   3a622:	4547      	cmp	r7, r8
   3a624:	fb09 1303 	mla	r3, r9, r3, r1
   3a628:	eb03 431a 	add.w	r3, r3, sl, lsr #16
   3a62c:	ea4f 4a13 	mov.w	sl, r3, lsr #16
   3a630:	d8e6      	bhi.n	3a600 <__multiply+0xe0>
   3a632:	f8cc 3000 	str.w	r3, [ip]
   3a636:	3504      	adds	r5, #4
   3a638:	e79b      	b.n	3a572 <__multiply+0x52>
   3a63a:	3e01      	subs	r6, #1
   3a63c:	e79d      	b.n	3a57a <__multiply+0x5a>

0003a63e <__lshift>:
   3a63e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   3a642:	460c      	mov	r4, r1
   3a644:	ea4f 1a62 	mov.w	sl, r2, asr #5
   3a648:	4607      	mov	r7, r0
   3a64a:	4616      	mov	r6, r2
   3a64c:	6923      	ldr	r3, [r4, #16]
   3a64e:	6849      	ldr	r1, [r1, #4]
   3a650:	eb0a 0903 	add.w	r9, sl, r3
   3a654:	68a3      	ldr	r3, [r4, #8]
   3a656:	f109 0501 	add.w	r5, r9, #1
   3a65a:	42ab      	cmp	r3, r5
   3a65c:	db33      	blt.n	3a6c6 <__lshift+0x88>
   3a65e:	4638      	mov	r0, r7
   3a660:	f7ff fe7d 	bl	3a35e <_Balloc>
   3a664:	2300      	movs	r3, #0
   3a666:	4680      	mov	r8, r0
   3a668:	f100 0114 	add.w	r1, r0, #20
   3a66c:	f100 0210 	add.w	r2, r0, #16
   3a670:	4618      	mov	r0, r3
   3a672:	4553      	cmp	r3, sl
   3a674:	db2a      	blt.n	3a6cc <__lshift+0x8e>
   3a676:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
   3a67a:	f104 0314 	add.w	r3, r4, #20
   3a67e:	6920      	ldr	r0, [r4, #16]
   3a680:	f016 021f 	ands.w	r2, r6, #31
   3a684:	eb01 018a 	add.w	r1, r1, sl, lsl #2
   3a688:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   3a68c:	d022      	beq.n	3a6d4 <__lshift+0x96>
   3a68e:	f1c2 0e20 	rsb	lr, r2, #32
   3a692:	2000      	movs	r0, #0
   3a694:	681e      	ldr	r6, [r3, #0]
   3a696:	4096      	lsls	r6, r2
   3a698:	4330      	orrs	r0, r6
   3a69a:	f841 0b04 	str.w	r0, [r1], #4
   3a69e:	f853 0b04 	ldr.w	r0, [r3], #4
   3a6a2:	459c      	cmp	ip, r3
   3a6a4:	fa20 f00e 	lsr.w	r0, r0, lr
   3a6a8:	d8f4      	bhi.n	3a694 <__lshift+0x56>
   3a6aa:	6008      	str	r0, [r1, #0]
   3a6ac:	b108      	cbz	r0, 3a6b2 <__lshift+0x74>
   3a6ae:	f109 0502 	add.w	r5, r9, #2
   3a6b2:	3d01      	subs	r5, #1
   3a6b4:	4638      	mov	r0, r7
   3a6b6:	4621      	mov	r1, r4
   3a6b8:	f8c8 5010 	str.w	r5, [r8, #16]
   3a6bc:	f7ff fe83 	bl	3a3c6 <_Bfree>
   3a6c0:	4640      	mov	r0, r8
   3a6c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3a6c6:	3101      	adds	r1, #1
   3a6c8:	005b      	lsls	r3, r3, #1
   3a6ca:	e7c6      	b.n	3a65a <__lshift+0x1c>
   3a6cc:	f842 0f04 	str.w	r0, [r2, #4]!
   3a6d0:	3301      	adds	r3, #1
   3a6d2:	e7ce      	b.n	3a672 <__lshift+0x34>
   3a6d4:	3904      	subs	r1, #4
   3a6d6:	f853 2b04 	ldr.w	r2, [r3], #4
   3a6da:	459c      	cmp	ip, r3
   3a6dc:	f841 2f04 	str.w	r2, [r1, #4]!
   3a6e0:	d8f9      	bhi.n	3a6d6 <__lshift+0x98>
   3a6e2:	e7e6      	b.n	3a6b2 <__lshift+0x74>

0003a6e4 <__mcmp>:
   3a6e4:	6903      	ldr	r3, [r0, #16]
   3a6e6:	690a      	ldr	r2, [r1, #16]
   3a6e8:	1a9b      	subs	r3, r3, r2
   3a6ea:	b530      	push	{r4, r5, lr}
   3a6ec:	d10c      	bne.n	3a708 <__mcmp+0x24>
   3a6ee:	0092      	lsls	r2, r2, #2
   3a6f0:	3014      	adds	r0, #20
   3a6f2:	3114      	adds	r1, #20
   3a6f4:	1884      	adds	r4, r0, r2
   3a6f6:	4411      	add	r1, r2
   3a6f8:	f854 5d04 	ldr.w	r5, [r4, #-4]!
   3a6fc:	f851 2d04 	ldr.w	r2, [r1, #-4]!
   3a700:	4295      	cmp	r5, r2
   3a702:	d003      	beq.n	3a70c <__mcmp+0x28>
   3a704:	d305      	bcc.n	3a712 <__mcmp+0x2e>
   3a706:	2301      	movs	r3, #1
   3a708:	4618      	mov	r0, r3
   3a70a:	bd30      	pop	{r4, r5, pc}
   3a70c:	42a0      	cmp	r0, r4
   3a70e:	d3f3      	bcc.n	3a6f8 <__mcmp+0x14>
   3a710:	e7fa      	b.n	3a708 <__mcmp+0x24>
   3a712:	f04f 33ff 	mov.w	r3, #4294967295
   3a716:	e7f7      	b.n	3a708 <__mcmp+0x24>

0003a718 <__mdiff>:
   3a718:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   3a71c:	460d      	mov	r5, r1
   3a71e:	4607      	mov	r7, r0
   3a720:	4611      	mov	r1, r2
   3a722:	4614      	mov	r4, r2
   3a724:	4628      	mov	r0, r5
   3a726:	f7ff ffdd 	bl	3a6e4 <__mcmp>
   3a72a:	1e06      	subs	r6, r0, #0
   3a72c:	d108      	bne.n	3a740 <__mdiff+0x28>
   3a72e:	4631      	mov	r1, r6
   3a730:	4638      	mov	r0, r7
   3a732:	f7ff fe14 	bl	3a35e <_Balloc>
   3a736:	2301      	movs	r3, #1
   3a738:	e9c0 3604 	strd	r3, r6, [r0, #16]
   3a73c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3a740:	bfa3      	ittte	ge
   3a742:	4623      	movge	r3, r4
   3a744:	462c      	movge	r4, r5
   3a746:	2600      	movge	r6, #0
   3a748:	2601      	movlt	r6, #1
   3a74a:	bfa8      	it	ge
   3a74c:	461d      	movge	r5, r3
   3a74e:	6861      	ldr	r1, [r4, #4]
   3a750:	4638      	mov	r0, r7
   3a752:	f7ff fe04 	bl	3a35e <_Balloc>
   3a756:	f105 0914 	add.w	r9, r5, #20
   3a75a:	60c6      	str	r6, [r0, #12]
   3a75c:	f104 0214 	add.w	r2, r4, #20
   3a760:	6926      	ldr	r6, [r4, #16]
   3a762:	f100 0114 	add.w	r1, r0, #20
   3a766:	692b      	ldr	r3, [r5, #16]
   3a768:	f04f 0e00 	mov.w	lr, #0
   3a76c:	eb02 0786 	add.w	r7, r2, r6, lsl #2
   3a770:	eb09 0883 	add.w	r8, r9, r3, lsl #2
   3a774:	f852 ab04 	ldr.w	sl, [r2], #4
   3a778:	f859 5b04 	ldr.w	r5, [r9], #4
   3a77c:	fa1f f38a 	uxth.w	r3, sl
   3a780:	4694      	mov	ip, r2
   3a782:	b2ac      	uxth	r4, r5
   3a784:	45c8      	cmp	r8, r9
   3a786:	4473      	add	r3, lr
   3a788:	eba3 0304 	sub.w	r3, r3, r4
   3a78c:	ea4f 4415 	mov.w	r4, r5, lsr #16
   3a790:	ebc4 441a 	rsb	r4, r4, sl, lsr #16
   3a794:	eb04 4423 	add.w	r4, r4, r3, asr #16
   3a798:	b29b      	uxth	r3, r3
   3a79a:	ea4f 4e24 	mov.w	lr, r4, asr #16
   3a79e:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
   3a7a2:	f841 4b04 	str.w	r4, [r1], #4
   3a7a6:	d8e5      	bhi.n	3a774 <__mdiff+0x5c>
   3a7a8:	45bc      	cmp	ip, r7
   3a7aa:	d304      	bcc.n	3a7b6 <__mdiff+0x9e>
   3a7ac:	f851 3d04 	ldr.w	r3, [r1, #-4]!
   3a7b0:	b183      	cbz	r3, 3a7d4 <__mdiff+0xbc>
   3a7b2:	6106      	str	r6, [r0, #16]
   3a7b4:	e7c2      	b.n	3a73c <__mdiff+0x24>
   3a7b6:	f85c 4b04 	ldr.w	r4, [ip], #4
   3a7ba:	b2a2      	uxth	r2, r4
   3a7bc:	4472      	add	r2, lr
   3a7be:	1413      	asrs	r3, r2, #16
   3a7c0:	b292      	uxth	r2, r2
   3a7c2:	eb03 4314 	add.w	r3, r3, r4, lsr #16
   3a7c6:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
   3a7ca:	ea4f 4e23 	mov.w	lr, r3, asr #16
   3a7ce:	f841 2b04 	str.w	r2, [r1], #4
   3a7d2:	e7e9      	b.n	3a7a8 <__mdiff+0x90>
   3a7d4:	3e01      	subs	r6, #1
   3a7d6:	e7e9      	b.n	3a7ac <__mdiff+0x94>

0003a7d8 <__d2b>:
   3a7d8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   3a7dc:	ec59 8b10 	vmov	r8, r9, d0
   3a7e0:	f3c9 540a 	ubfx	r4, r9, #20, #11
   3a7e4:	460e      	mov	r6, r1
   3a7e6:	2101      	movs	r1, #1
   3a7e8:	4615      	mov	r5, r2
   3a7ea:	f7ff fdb8 	bl	3a35e <_Balloc>
   3a7ee:	f3c9 0313 	ubfx	r3, r9, #0, #20
   3a7f2:	4607      	mov	r7, r0
   3a7f4:	bb2c      	cbnz	r4, 3a842 <__d2b+0x6a>
   3a7f6:	9301      	str	r3, [sp, #4]
   3a7f8:	f1b8 0300 	subs.w	r3, r8, #0
   3a7fc:	d026      	beq.n	3a84c <__d2b+0x74>
   3a7fe:	4668      	mov	r0, sp
   3a800:	9300      	str	r3, [sp, #0]
   3a802:	f7ff fe54 	bl	3a4ae <__lo0bits>
   3a806:	9900      	ldr	r1, [sp, #0]
   3a808:	b1f0      	cbz	r0, 3a848 <__d2b+0x70>
   3a80a:	9a01      	ldr	r2, [sp, #4]
   3a80c:	f1c0 0320 	rsb	r3, r0, #32
   3a810:	fa02 f303 	lsl.w	r3, r2, r3
   3a814:	40c2      	lsrs	r2, r0
   3a816:	430b      	orrs	r3, r1
   3a818:	9201      	str	r2, [sp, #4]
   3a81a:	617b      	str	r3, [r7, #20]
   3a81c:	9b01      	ldr	r3, [sp, #4]
   3a81e:	2b00      	cmp	r3, #0
   3a820:	61bb      	str	r3, [r7, #24]
   3a822:	bf14      	ite	ne
   3a824:	2102      	movne	r1, #2
   3a826:	2101      	moveq	r1, #1
   3a828:	6139      	str	r1, [r7, #16]
   3a82a:	b1c4      	cbz	r4, 3a85e <__d2b+0x86>
   3a82c:	f2a4 4433 	subw	r4, r4, #1075	; 0x433
   3a830:	4404      	add	r4, r0
   3a832:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
   3a836:	6034      	str	r4, [r6, #0]
   3a838:	6028      	str	r0, [r5, #0]
   3a83a:	4638      	mov	r0, r7
   3a83c:	b003      	add	sp, #12
   3a83e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   3a842:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   3a846:	e7d6      	b.n	3a7f6 <__d2b+0x1e>
   3a848:	6179      	str	r1, [r7, #20]
   3a84a:	e7e7      	b.n	3a81c <__d2b+0x44>
   3a84c:	a801      	add	r0, sp, #4
   3a84e:	f7ff fe2e 	bl	3a4ae <__lo0bits>
   3a852:	9b01      	ldr	r3, [sp, #4]
   3a854:	2101      	movs	r1, #1
   3a856:	3020      	adds	r0, #32
   3a858:	617b      	str	r3, [r7, #20]
   3a85a:	6139      	str	r1, [r7, #16]
   3a85c:	e7e5      	b.n	3a82a <__d2b+0x52>
   3a85e:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
   3a862:	eb07 0381 	add.w	r3, r7, r1, lsl #2
   3a866:	6030      	str	r0, [r6, #0]
   3a868:	6918      	ldr	r0, [r3, #16]
   3a86a:	f7ff fe00 	bl	3a46e <__hi0bits>
   3a86e:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
   3a872:	e7e1      	b.n	3a838 <__d2b+0x60>

0003a874 <_calloc_r>:
   3a874:	b538      	push	{r3, r4, r5, lr}
   3a876:	fb02 f401 	mul.w	r4, r2, r1
   3a87a:	4621      	mov	r1, r4
   3a87c:	f7fc fa90 	bl	36da0 <_malloc_r>
   3a880:	4605      	mov	r5, r0
   3a882:	b118      	cbz	r0, 3a88c <_calloc_r+0x18>
   3a884:	4622      	mov	r2, r4
   3a886:	2100      	movs	r1, #0
   3a888:	f7ff fa99 	bl	39dbe <memset>
   3a88c:	4628      	mov	r0, r5
   3a88e:	bd38      	pop	{r3, r4, r5, pc}

0003a890 <_realloc_r>:
   3a890:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3a892:	4607      	mov	r7, r0
   3a894:	4614      	mov	r4, r2
   3a896:	460e      	mov	r6, r1
   3a898:	b921      	cbnz	r1, 3a8a4 <_realloc_r+0x14>
   3a89a:	4611      	mov	r1, r2
   3a89c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   3a8a0:	f7fc ba7e 	b.w	36da0 <_malloc_r>
   3a8a4:	b922      	cbnz	r2, 3a8b0 <_realloc_r+0x20>
   3a8a6:	4625      	mov	r5, r4
   3a8a8:	f7fc fa2c 	bl	36d04 <_free_r>
   3a8ac:	4628      	mov	r0, r5
   3a8ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   3a8b0:	f000 f8ee 	bl	3aa90 <_malloc_usable_size_r>
   3a8b4:	42a0      	cmp	r0, r4
   3a8b6:	d20f      	bcs.n	3a8d8 <_realloc_r+0x48>
   3a8b8:	4621      	mov	r1, r4
   3a8ba:	4638      	mov	r0, r7
   3a8bc:	f7fc fa70 	bl	36da0 <_malloc_r>
   3a8c0:	4605      	mov	r5, r0
   3a8c2:	2800      	cmp	r0, #0
   3a8c4:	d0f2      	beq.n	3a8ac <_realloc_r+0x1c>
   3a8c6:	4631      	mov	r1, r6
   3a8c8:	4622      	mov	r2, r4
   3a8ca:	f7ff fa58 	bl	39d7e <memcpy>
   3a8ce:	4631      	mov	r1, r6
   3a8d0:	4638      	mov	r0, r7
   3a8d2:	f7fc fa17 	bl	36d04 <_free_r>
   3a8d6:	e7e9      	b.n	3a8ac <_realloc_r+0x1c>
   3a8d8:	4635      	mov	r5, r6
   3a8da:	e7e7      	b.n	3a8ac <_realloc_r+0x1c>

0003a8dc <__ssputs_r>:
   3a8dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   3a8e0:	688e      	ldr	r6, [r1, #8]
   3a8e2:	4682      	mov	sl, r0
   3a8e4:	460c      	mov	r4, r1
   3a8e6:	4691      	mov	r9, r2
   3a8e8:	429e      	cmp	r6, r3
   3a8ea:	4698      	mov	r8, r3
   3a8ec:	d838      	bhi.n	3a960 <__ssputs_r+0x84>
   3a8ee:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
   3a8f2:	f41c 6f90 	tst.w	ip, #1152	; 0x480
   3a8f6:	d031      	beq.n	3a95c <__ssputs_r+0x80>
   3a8f8:	6962      	ldr	r2, [r4, #20]
   3a8fa:	3301      	adds	r3, #1
   3a8fc:	6825      	ldr	r5, [r4, #0]
   3a8fe:	6909      	ldr	r1, [r1, #16]
   3a900:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   3a904:	1a6f      	subs	r7, r5, r1
   3a906:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   3a90a:	443b      	add	r3, r7
   3a90c:	1055      	asrs	r5, r2, #1
   3a90e:	429d      	cmp	r5, r3
   3a910:	bf38      	it	cc
   3a912:	461d      	movcc	r5, r3
   3a914:	f41c 6f80 	tst.w	ip, #1024	; 0x400
   3a918:	d030      	beq.n	3a97c <__ssputs_r+0xa0>
   3a91a:	4629      	mov	r1, r5
   3a91c:	f7fc fa40 	bl	36da0 <_malloc_r>
   3a920:	4606      	mov	r6, r0
   3a922:	b950      	cbnz	r0, 3a93a <__ssputs_r+0x5e>
   3a924:	230c      	movs	r3, #12
   3a926:	f04f 30ff 	mov.w	r0, #4294967295
   3a92a:	f8ca 3000 	str.w	r3, [sl]
   3a92e:	89a3      	ldrh	r3, [r4, #12]
   3a930:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   3a934:	81a3      	strh	r3, [r4, #12]
   3a936:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3a93a:	463a      	mov	r2, r7
   3a93c:	6921      	ldr	r1, [r4, #16]
   3a93e:	f7ff fa1e 	bl	39d7e <memcpy>
   3a942:	89a3      	ldrh	r3, [r4, #12]
   3a944:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   3a948:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   3a94c:	81a3      	strh	r3, [r4, #12]
   3a94e:	6126      	str	r6, [r4, #16]
   3a950:	443e      	add	r6, r7
   3a952:	6165      	str	r5, [r4, #20]
   3a954:	1bed      	subs	r5, r5, r7
   3a956:	6026      	str	r6, [r4, #0]
   3a958:	4646      	mov	r6, r8
   3a95a:	60a5      	str	r5, [r4, #8]
   3a95c:	4546      	cmp	r6, r8
   3a95e:	d900      	bls.n	3a962 <__ssputs_r+0x86>
   3a960:	4646      	mov	r6, r8
   3a962:	4632      	mov	r2, r6
   3a964:	4649      	mov	r1, r9
   3a966:	6820      	ldr	r0, [r4, #0]
   3a968:	f7ff fcdf 	bl	3a32a <memmove>
   3a96c:	68a3      	ldr	r3, [r4, #8]
   3a96e:	2000      	movs	r0, #0
   3a970:	1b9b      	subs	r3, r3, r6
   3a972:	60a3      	str	r3, [r4, #8]
   3a974:	6823      	ldr	r3, [r4, #0]
   3a976:	441e      	add	r6, r3
   3a978:	6026      	str	r6, [r4, #0]
   3a97a:	e7dc      	b.n	3a936 <__ssputs_r+0x5a>
   3a97c:	462a      	mov	r2, r5
   3a97e:	f7ff ff87 	bl	3a890 <_realloc_r>
   3a982:	4606      	mov	r6, r0
   3a984:	2800      	cmp	r0, #0
   3a986:	d1e2      	bne.n	3a94e <__ssputs_r+0x72>
   3a988:	6921      	ldr	r1, [r4, #16]
   3a98a:	4650      	mov	r0, sl
   3a98c:	f7fc f9ba 	bl	36d04 <_free_r>
   3a990:	e7c8      	b.n	3a924 <__ssputs_r+0x48>

0003a992 <_raise_r>:
   3a992:	291f      	cmp	r1, #31
   3a994:	b538      	push	{r3, r4, r5, lr}
   3a996:	4604      	mov	r4, r0
   3a998:	460d      	mov	r5, r1
   3a99a:	d904      	bls.n	3a9a6 <_raise_r+0x14>
   3a99c:	2316      	movs	r3, #22
   3a99e:	6003      	str	r3, [r0, #0]
   3a9a0:	f04f 30ff 	mov.w	r0, #4294967295
   3a9a4:	bd38      	pop	{r3, r4, r5, pc}
   3a9a6:	6c42      	ldr	r2, [r0, #68]	; 0x44
   3a9a8:	b112      	cbz	r2, 3a9b0 <_raise_r+0x1e>
   3a9aa:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   3a9ae:	b94b      	cbnz	r3, 3a9c4 <_raise_r+0x32>
   3a9b0:	4620      	mov	r0, r4
   3a9b2:	f000 f816 	bl	3a9e2 <_getpid_r>
   3a9b6:	462a      	mov	r2, r5
   3a9b8:	4601      	mov	r1, r0
   3a9ba:	4620      	mov	r0, r4
   3a9bc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   3a9c0:	f7fc bb58 	b.w	37074 <_kill_r>
   3a9c4:	2b01      	cmp	r3, #1
   3a9c6:	d00a      	beq.n	3a9de <_raise_r+0x4c>
   3a9c8:	1c59      	adds	r1, r3, #1
   3a9ca:	d103      	bne.n	3a9d4 <_raise_r+0x42>
   3a9cc:	2316      	movs	r3, #22
   3a9ce:	6003      	str	r3, [r0, #0]
   3a9d0:	2001      	movs	r0, #1
   3a9d2:	e7e7      	b.n	3a9a4 <_raise_r+0x12>
   3a9d4:	2400      	movs	r4, #0
   3a9d6:	4628      	mov	r0, r5
   3a9d8:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
   3a9dc:	4798      	blx	r3
   3a9de:	2000      	movs	r0, #0
   3a9e0:	e7e0      	b.n	3a9a4 <_raise_r+0x12>

0003a9e2 <_getpid_r>:
   3a9e2:	f7fd bb61 	b.w	380a8 <_getpid>

0003a9e6 <__sread>:
   3a9e6:	b510      	push	{r4, lr}
   3a9e8:	460c      	mov	r4, r1
   3a9ea:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   3a9ee:	f7fc fbb5 	bl	3715c <_read_r>
   3a9f2:	2800      	cmp	r0, #0
   3a9f4:	bfab      	itete	ge
   3a9f6:	6d63      	ldrge	r3, [r4, #84]	; 0x54
   3a9f8:	89a3      	ldrhlt	r3, [r4, #12]
   3a9fa:	181b      	addge	r3, r3, r0
   3a9fc:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
   3aa00:	bfac      	ite	ge
   3aa02:	6563      	strge	r3, [r4, #84]	; 0x54
   3aa04:	81a3      	strhlt	r3, [r4, #12]
   3aa06:	bd10      	pop	{r4, pc}

0003aa08 <__swrite>:
   3aa08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3aa0c:	461f      	mov	r7, r3
   3aa0e:	898b      	ldrh	r3, [r1, #12]
   3aa10:	4605      	mov	r5, r0
   3aa12:	460c      	mov	r4, r1
   3aa14:	05db      	lsls	r3, r3, #23
   3aa16:	4616      	mov	r6, r2
   3aa18:	d505      	bpl.n	3aa26 <__swrite+0x1e>
   3aa1a:	2302      	movs	r3, #2
   3aa1c:	2200      	movs	r2, #0
   3aa1e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   3aa22:	f7fc fb7d 	bl	37120 <_lseek_r>
   3aa26:	89a3      	ldrh	r3, [r4, #12]
   3aa28:	4632      	mov	r2, r6
   3aa2a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   3aa2e:	4628      	mov	r0, r5
   3aa30:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   3aa34:	81a3      	strh	r3, [r4, #12]
   3aa36:	463b      	mov	r3, r7
   3aa38:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   3aa3c:	f7fc bb2c 	b.w	37098 <_write_r>

0003aa40 <__sseek>:
   3aa40:	b510      	push	{r4, lr}
   3aa42:	460c      	mov	r4, r1
   3aa44:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   3aa48:	f7fc fb6a 	bl	37120 <_lseek_r>
   3aa4c:	1c43      	adds	r3, r0, #1
   3aa4e:	89a3      	ldrh	r3, [r4, #12]
   3aa50:	bf15      	itete	ne
   3aa52:	6560      	strne	r0, [r4, #84]	; 0x54
   3aa54:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   3aa58:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
   3aa5c:	81a3      	strheq	r3, [r4, #12]
   3aa5e:	bf18      	it	ne
   3aa60:	81a3      	strhne	r3, [r4, #12]
   3aa62:	bd10      	pop	{r4, pc}

0003aa64 <__sclose>:
   3aa64:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   3aa68:	f7fc bb28 	b.w	370bc <_close_r>

0003aa6c <__ascii_mbtowc>:
   3aa6c:	b082      	sub	sp, #8
   3aa6e:	b901      	cbnz	r1, 3aa72 <__ascii_mbtowc+0x6>
   3aa70:	a901      	add	r1, sp, #4
   3aa72:	b142      	cbz	r2, 3aa86 <__ascii_mbtowc+0x1a>
   3aa74:	b14b      	cbz	r3, 3aa8a <__ascii_mbtowc+0x1e>
   3aa76:	7813      	ldrb	r3, [r2, #0]
   3aa78:	600b      	str	r3, [r1, #0]
   3aa7a:	7812      	ldrb	r2, [r2, #0]
   3aa7c:	1c10      	adds	r0, r2, #0
   3aa7e:	bf18      	it	ne
   3aa80:	2001      	movne	r0, #1
   3aa82:	b002      	add	sp, #8
   3aa84:	4770      	bx	lr
   3aa86:	4610      	mov	r0, r2
   3aa88:	e7fb      	b.n	3aa82 <__ascii_mbtowc+0x16>
   3aa8a:	f06f 0001 	mvn.w	r0, #1
   3aa8e:	e7f8      	b.n	3aa82 <__ascii_mbtowc+0x16>

0003aa90 <_malloc_usable_size_r>:
   3aa90:	f851 3c04 	ldr.w	r3, [r1, #-4]
   3aa94:	1f18      	subs	r0, r3, #4
   3aa96:	2b00      	cmp	r3, #0
   3aa98:	bfbc      	itt	lt
   3aa9a:	580b      	ldrlt	r3, [r1, r0]
   3aa9c:	18c0      	addlt	r0, r0, r3
   3aa9e:	4770      	bx	lr

0003aaa0 <__ascii_wctomb>:
   3aaa0:	b149      	cbz	r1, 3aab6 <__ascii_wctomb+0x16>
   3aaa2:	2aff      	cmp	r2, #255	; 0xff
   3aaa4:	bf8d      	iteet	hi
   3aaa6:	238a      	movhi	r3, #138	; 0x8a
   3aaa8:	700a      	strbls	r2, [r1, #0]
   3aaaa:	2001      	movls	r0, #1
   3aaac:	6003      	strhi	r3, [r0, #0]
   3aaae:	bf88      	it	hi
   3aab0:	f04f 30ff 	movhi.w	r0, #4294967295
   3aab4:	4770      	bx	lr
   3aab6:	4608      	mov	r0, r1
   3aab8:	4770      	bx	lr
