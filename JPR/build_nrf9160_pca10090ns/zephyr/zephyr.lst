
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

0001c200 <_vector_table>:
   1c200:	20031f48 	.word	0x20031f48
   1c204:	00028449 	.word	0x00028449
   1c208:	0003ca83 	.word	0x0003ca83
   1c20c:	000280a5 	.word	0x000280a5
   1c210:	000280a5 	.word	0x000280a5
   1c214:	000280a5 	.word	0x000280a5
   1c218:	000280a5 	.word	0x000280a5
   1c21c:	000280a5 	.word	0x000280a5
   1c220:	000280a5 	.word	0x000280a5
   1c224:	000280a5 	.word	0x000280a5
   1c228:	000280a5 	.word	0x000280a5
   1c22c:	0002806d 	.word	0x0002806d
   1c230:	000280a5 	.word	0x000280a5
   1c234:	000280a5 	.word	0x000280a5
   1c238:	00027fa9 	.word	0x00027fa9
   1c23c:	00027ad9 	.word	0x00027ad9

0001c240 <_irq_vector_table>:
   1c240:	000280c1 000280c1 000280c1 000280c1     ................
   1c250:	000280c1 000280c1 000280c1 000280c1     ................
   1c260:	000280c1 000280c1 000280c1 000280c1     ................
   1c270:	000280c1 000280c1 000280c1 000280c1     ................
   1c280:	000280c1 000280c1 000280c1 000280c1     ................
   1c290:	000280c1 000280c1 000280c1 000280c1     ................
   1c2a0:	000280c1 000280c1 000280c1 000280c1     ................
   1c2b0:	0002aa55 0003d915 000280c1 000280c1     U...............
   1c2c0:	000280c1 000280c1 000280c1 000280c1     ................
   1c2d0:	000280c1 000280c1 000280c1 000280c1     ................
   1c2e0:	000280c1 000280c1 0003d933 000280c1     ........3.......
   1c2f0:	000280c1 000280c1 000280c1 000280c1     ................
   1c300:	000280c1 000280c1 000280c1 000280c1     ................
   1c310:	000280c1 000280c1 000280c1 000280c1     ................
   1c320:	000280c1 000280c1 000280c1 000280c1     ................
   1c330:	000280c1 000280c1 000280c1 000280c1     ................
   1c340:	000280c1                                ....

0001c344 <_vector_end>:
	...

0001c400 <m_firmware_info>:
   1c400:	281ee6de 8fcebb4c 00005b02 0000003c     ...(L....[..<...
   1c410:	0002b8a0 00000001 0001c200 0001c200     ................
   1c420:	9102ffff 00000000 00000000 00000000     ................
	...

Disassembly of section text:

0001c440 <__aeabi_drsub>:
   1c440:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   1c444:	e002      	b.n	1c44c <__adddf3>
   1c446:	bf00      	nop

0001c448 <__aeabi_dsub>:
   1c448:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0001c44c <__adddf3>:
   1c44c:	b530      	push	{r4, r5, lr}
   1c44e:	ea4f 0441 	mov.w	r4, r1, lsl #1
   1c452:	ea4f 0543 	mov.w	r5, r3, lsl #1
   1c456:	ea94 0f05 	teq	r4, r5
   1c45a:	bf08      	it	eq
   1c45c:	ea90 0f02 	teqeq	r0, r2
   1c460:	bf1f      	itttt	ne
   1c462:	ea54 0c00 	orrsne.w	ip, r4, r0
   1c466:	ea55 0c02 	orrsne.w	ip, r5, r2
   1c46a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   1c46e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   1c472:	f000 80e2 	beq.w	1c63a <__adddf3+0x1ee>
   1c476:	ea4f 5454 	mov.w	r4, r4, lsr #21
   1c47a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   1c47e:	bfb8      	it	lt
   1c480:	426d      	neglt	r5, r5
   1c482:	dd0c      	ble.n	1c49e <__adddf3+0x52>
   1c484:	442c      	add	r4, r5
   1c486:	ea80 0202 	eor.w	r2, r0, r2
   1c48a:	ea81 0303 	eor.w	r3, r1, r3
   1c48e:	ea82 0000 	eor.w	r0, r2, r0
   1c492:	ea83 0101 	eor.w	r1, r3, r1
   1c496:	ea80 0202 	eor.w	r2, r0, r2
   1c49a:	ea81 0303 	eor.w	r3, r1, r3
   1c49e:	2d36      	cmp	r5, #54	; 0x36
   1c4a0:	bf88      	it	hi
   1c4a2:	bd30      	pophi	{r4, r5, pc}
   1c4a4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   1c4a8:	ea4f 3101 	mov.w	r1, r1, lsl #12
   1c4ac:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   1c4b0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   1c4b4:	d002      	beq.n	1c4bc <__adddf3+0x70>
   1c4b6:	4240      	negs	r0, r0
   1c4b8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1c4bc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   1c4c0:	ea4f 3303 	mov.w	r3, r3, lsl #12
   1c4c4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   1c4c8:	d002      	beq.n	1c4d0 <__adddf3+0x84>
   1c4ca:	4252      	negs	r2, r2
   1c4cc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   1c4d0:	ea94 0f05 	teq	r4, r5
   1c4d4:	f000 80a7 	beq.w	1c626 <__adddf3+0x1da>
   1c4d8:	f1a4 0401 	sub.w	r4, r4, #1
   1c4dc:	f1d5 0e20 	rsbs	lr, r5, #32
   1c4e0:	db0d      	blt.n	1c4fe <__adddf3+0xb2>
   1c4e2:	fa02 fc0e 	lsl.w	ip, r2, lr
   1c4e6:	fa22 f205 	lsr.w	r2, r2, r5
   1c4ea:	1880      	adds	r0, r0, r2
   1c4ec:	f141 0100 	adc.w	r1, r1, #0
   1c4f0:	fa03 f20e 	lsl.w	r2, r3, lr
   1c4f4:	1880      	adds	r0, r0, r2
   1c4f6:	fa43 f305 	asr.w	r3, r3, r5
   1c4fa:	4159      	adcs	r1, r3
   1c4fc:	e00e      	b.n	1c51c <__adddf3+0xd0>
   1c4fe:	f1a5 0520 	sub.w	r5, r5, #32
   1c502:	f10e 0e20 	add.w	lr, lr, #32
   1c506:	2a01      	cmp	r2, #1
   1c508:	fa03 fc0e 	lsl.w	ip, r3, lr
   1c50c:	bf28      	it	cs
   1c50e:	f04c 0c02 	orrcs.w	ip, ip, #2
   1c512:	fa43 f305 	asr.w	r3, r3, r5
   1c516:	18c0      	adds	r0, r0, r3
   1c518:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   1c51c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   1c520:	d507      	bpl.n	1c532 <__adddf3+0xe6>
   1c522:	f04f 0e00 	mov.w	lr, #0
   1c526:	f1dc 0c00 	rsbs	ip, ip, #0
   1c52a:	eb7e 0000 	sbcs.w	r0, lr, r0
   1c52e:	eb6e 0101 	sbc.w	r1, lr, r1
   1c532:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   1c536:	d31b      	bcc.n	1c570 <__adddf3+0x124>
   1c538:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   1c53c:	d30c      	bcc.n	1c558 <__adddf3+0x10c>
   1c53e:	0849      	lsrs	r1, r1, #1
   1c540:	ea5f 0030 	movs.w	r0, r0, rrx
   1c544:	ea4f 0c3c 	mov.w	ip, ip, rrx
   1c548:	f104 0401 	add.w	r4, r4, #1
   1c54c:	ea4f 5244 	mov.w	r2, r4, lsl #21
   1c550:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   1c554:	f080 809a 	bcs.w	1c68c <__adddf3+0x240>
   1c558:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   1c55c:	bf08      	it	eq
   1c55e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   1c562:	f150 0000 	adcs.w	r0, r0, #0
   1c566:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   1c56a:	ea41 0105 	orr.w	r1, r1, r5
   1c56e:	bd30      	pop	{r4, r5, pc}
   1c570:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   1c574:	4140      	adcs	r0, r0
   1c576:	eb41 0101 	adc.w	r1, r1, r1
   1c57a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   1c57e:	f1a4 0401 	sub.w	r4, r4, #1
   1c582:	d1e9      	bne.n	1c558 <__adddf3+0x10c>
   1c584:	f091 0f00 	teq	r1, #0
   1c588:	bf04      	itt	eq
   1c58a:	4601      	moveq	r1, r0
   1c58c:	2000      	moveq	r0, #0
   1c58e:	fab1 f381 	clz	r3, r1
   1c592:	bf08      	it	eq
   1c594:	3320      	addeq	r3, #32
   1c596:	f1a3 030b 	sub.w	r3, r3, #11
   1c59a:	f1b3 0220 	subs.w	r2, r3, #32
   1c59e:	da0c      	bge.n	1c5ba <__adddf3+0x16e>
   1c5a0:	320c      	adds	r2, #12
   1c5a2:	dd08      	ble.n	1c5b6 <__adddf3+0x16a>
   1c5a4:	f102 0c14 	add.w	ip, r2, #20
   1c5a8:	f1c2 020c 	rsb	r2, r2, #12
   1c5ac:	fa01 f00c 	lsl.w	r0, r1, ip
   1c5b0:	fa21 f102 	lsr.w	r1, r1, r2
   1c5b4:	e00c      	b.n	1c5d0 <__adddf3+0x184>
   1c5b6:	f102 0214 	add.w	r2, r2, #20
   1c5ba:	bfd8      	it	le
   1c5bc:	f1c2 0c20 	rsble	ip, r2, #32
   1c5c0:	fa01 f102 	lsl.w	r1, r1, r2
   1c5c4:	fa20 fc0c 	lsr.w	ip, r0, ip
   1c5c8:	bfdc      	itt	le
   1c5ca:	ea41 010c 	orrle.w	r1, r1, ip
   1c5ce:	4090      	lslle	r0, r2
   1c5d0:	1ae4      	subs	r4, r4, r3
   1c5d2:	bfa2      	ittt	ge
   1c5d4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   1c5d8:	4329      	orrge	r1, r5
   1c5da:	bd30      	popge	{r4, r5, pc}
   1c5dc:	ea6f 0404 	mvn.w	r4, r4
   1c5e0:	3c1f      	subs	r4, #31
   1c5e2:	da1c      	bge.n	1c61e <__adddf3+0x1d2>
   1c5e4:	340c      	adds	r4, #12
   1c5e6:	dc0e      	bgt.n	1c606 <__adddf3+0x1ba>
   1c5e8:	f104 0414 	add.w	r4, r4, #20
   1c5ec:	f1c4 0220 	rsb	r2, r4, #32
   1c5f0:	fa20 f004 	lsr.w	r0, r0, r4
   1c5f4:	fa01 f302 	lsl.w	r3, r1, r2
   1c5f8:	ea40 0003 	orr.w	r0, r0, r3
   1c5fc:	fa21 f304 	lsr.w	r3, r1, r4
   1c600:	ea45 0103 	orr.w	r1, r5, r3
   1c604:	bd30      	pop	{r4, r5, pc}
   1c606:	f1c4 040c 	rsb	r4, r4, #12
   1c60a:	f1c4 0220 	rsb	r2, r4, #32
   1c60e:	fa20 f002 	lsr.w	r0, r0, r2
   1c612:	fa01 f304 	lsl.w	r3, r1, r4
   1c616:	ea40 0003 	orr.w	r0, r0, r3
   1c61a:	4629      	mov	r1, r5
   1c61c:	bd30      	pop	{r4, r5, pc}
   1c61e:	fa21 f004 	lsr.w	r0, r1, r4
   1c622:	4629      	mov	r1, r5
   1c624:	bd30      	pop	{r4, r5, pc}
   1c626:	f094 0f00 	teq	r4, #0
   1c62a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   1c62e:	bf06      	itte	eq
   1c630:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   1c634:	3401      	addeq	r4, #1
   1c636:	3d01      	subne	r5, #1
   1c638:	e74e      	b.n	1c4d8 <__adddf3+0x8c>
   1c63a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   1c63e:	bf18      	it	ne
   1c640:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   1c644:	d029      	beq.n	1c69a <__adddf3+0x24e>
   1c646:	ea94 0f05 	teq	r4, r5
   1c64a:	bf08      	it	eq
   1c64c:	ea90 0f02 	teqeq	r0, r2
   1c650:	d005      	beq.n	1c65e <__adddf3+0x212>
   1c652:	ea54 0c00 	orrs.w	ip, r4, r0
   1c656:	bf04      	itt	eq
   1c658:	4619      	moveq	r1, r3
   1c65a:	4610      	moveq	r0, r2
   1c65c:	bd30      	pop	{r4, r5, pc}
   1c65e:	ea91 0f03 	teq	r1, r3
   1c662:	bf1e      	ittt	ne
   1c664:	2100      	movne	r1, #0
   1c666:	2000      	movne	r0, #0
   1c668:	bd30      	popne	{r4, r5, pc}
   1c66a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   1c66e:	d105      	bne.n	1c67c <__adddf3+0x230>
   1c670:	0040      	lsls	r0, r0, #1
   1c672:	4149      	adcs	r1, r1
   1c674:	bf28      	it	cs
   1c676:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   1c67a:	bd30      	pop	{r4, r5, pc}
   1c67c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   1c680:	bf3c      	itt	cc
   1c682:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   1c686:	bd30      	popcc	{r4, r5, pc}
   1c688:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   1c68c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   1c690:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   1c694:	f04f 0000 	mov.w	r0, #0
   1c698:	bd30      	pop	{r4, r5, pc}
   1c69a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   1c69e:	bf1a      	itte	ne
   1c6a0:	4619      	movne	r1, r3
   1c6a2:	4610      	movne	r0, r2
   1c6a4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   1c6a8:	bf1c      	itt	ne
   1c6aa:	460b      	movne	r3, r1
   1c6ac:	4602      	movne	r2, r0
   1c6ae:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   1c6b2:	bf06      	itte	eq
   1c6b4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   1c6b8:	ea91 0f03 	teqeq	r1, r3
   1c6bc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   1c6c0:	bd30      	pop	{r4, r5, pc}
   1c6c2:	bf00      	nop

0001c6c4 <__aeabi_ui2d>:
   1c6c4:	f090 0f00 	teq	r0, #0
   1c6c8:	bf04      	itt	eq
   1c6ca:	2100      	moveq	r1, #0
   1c6cc:	4770      	bxeq	lr
   1c6ce:	b530      	push	{r4, r5, lr}
   1c6d0:	f44f 6480 	mov.w	r4, #1024	; 0x400
   1c6d4:	f104 0432 	add.w	r4, r4, #50	; 0x32
   1c6d8:	f04f 0500 	mov.w	r5, #0
   1c6dc:	f04f 0100 	mov.w	r1, #0
   1c6e0:	e750      	b.n	1c584 <__adddf3+0x138>
   1c6e2:	bf00      	nop

0001c6e4 <__aeabi_i2d>:
   1c6e4:	f090 0f00 	teq	r0, #0
   1c6e8:	bf04      	itt	eq
   1c6ea:	2100      	moveq	r1, #0
   1c6ec:	4770      	bxeq	lr
   1c6ee:	b530      	push	{r4, r5, lr}
   1c6f0:	f44f 6480 	mov.w	r4, #1024	; 0x400
   1c6f4:	f104 0432 	add.w	r4, r4, #50	; 0x32
   1c6f8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   1c6fc:	bf48      	it	mi
   1c6fe:	4240      	negmi	r0, r0
   1c700:	f04f 0100 	mov.w	r1, #0
   1c704:	e73e      	b.n	1c584 <__adddf3+0x138>
   1c706:	bf00      	nop

0001c708 <__aeabi_f2d>:
   1c708:	0042      	lsls	r2, r0, #1
   1c70a:	ea4f 01e2 	mov.w	r1, r2, asr #3
   1c70e:	ea4f 0131 	mov.w	r1, r1, rrx
   1c712:	ea4f 7002 	mov.w	r0, r2, lsl #28
   1c716:	bf1f      	itttt	ne
   1c718:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   1c71c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   1c720:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   1c724:	4770      	bxne	lr
   1c726:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   1c72a:	bf08      	it	eq
   1c72c:	4770      	bxeq	lr
   1c72e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
   1c732:	bf04      	itt	eq
   1c734:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
   1c738:	4770      	bxeq	lr
   1c73a:	b530      	push	{r4, r5, lr}
   1c73c:	f44f 7460 	mov.w	r4, #896	; 0x380
   1c740:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   1c744:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   1c748:	e71c      	b.n	1c584 <__adddf3+0x138>
   1c74a:	bf00      	nop

0001c74c <__aeabi_ul2d>:
   1c74c:	ea50 0201 	orrs.w	r2, r0, r1
   1c750:	bf08      	it	eq
   1c752:	4770      	bxeq	lr
   1c754:	b530      	push	{r4, r5, lr}
   1c756:	f04f 0500 	mov.w	r5, #0
   1c75a:	e00a      	b.n	1c772 <__aeabi_l2d+0x16>

0001c75c <__aeabi_l2d>:
   1c75c:	ea50 0201 	orrs.w	r2, r0, r1
   1c760:	bf08      	it	eq
   1c762:	4770      	bxeq	lr
   1c764:	b530      	push	{r4, r5, lr}
   1c766:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   1c76a:	d502      	bpl.n	1c772 <__aeabi_l2d+0x16>
   1c76c:	4240      	negs	r0, r0
   1c76e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1c772:	f44f 6480 	mov.w	r4, #1024	; 0x400
   1c776:	f104 0432 	add.w	r4, r4, #50	; 0x32
   1c77a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   1c77e:	f43f aed8 	beq.w	1c532 <__adddf3+0xe6>
   1c782:	f04f 0203 	mov.w	r2, #3
   1c786:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   1c78a:	bf18      	it	ne
   1c78c:	3203      	addne	r2, #3
   1c78e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   1c792:	bf18      	it	ne
   1c794:	3203      	addne	r2, #3
   1c796:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   1c79a:	f1c2 0320 	rsb	r3, r2, #32
   1c79e:	fa00 fc03 	lsl.w	ip, r0, r3
   1c7a2:	fa20 f002 	lsr.w	r0, r0, r2
   1c7a6:	fa01 fe03 	lsl.w	lr, r1, r3
   1c7aa:	ea40 000e 	orr.w	r0, r0, lr
   1c7ae:	fa21 f102 	lsr.w	r1, r1, r2
   1c7b2:	4414      	add	r4, r2
   1c7b4:	e6bd      	b.n	1c532 <__adddf3+0xe6>
   1c7b6:	bf00      	nop

0001c7b8 <__aeabi_dmul>:
   1c7b8:	b570      	push	{r4, r5, r6, lr}
   1c7ba:	f04f 0cff 	mov.w	ip, #255	; 0xff
   1c7be:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   1c7c2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   1c7c6:	bf1d      	ittte	ne
   1c7c8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   1c7cc:	ea94 0f0c 	teqne	r4, ip
   1c7d0:	ea95 0f0c 	teqne	r5, ip
   1c7d4:	f000 f8de 	bleq	1c994 <__aeabi_dmul+0x1dc>
   1c7d8:	442c      	add	r4, r5
   1c7da:	ea81 0603 	eor.w	r6, r1, r3
   1c7de:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   1c7e2:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   1c7e6:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   1c7ea:	bf18      	it	ne
   1c7ec:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   1c7f0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1c7f4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   1c7f8:	d038      	beq.n	1c86c <__aeabi_dmul+0xb4>
   1c7fa:	fba0 ce02 	umull	ip, lr, r0, r2
   1c7fe:	f04f 0500 	mov.w	r5, #0
   1c802:	fbe1 e502 	umlal	lr, r5, r1, r2
   1c806:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   1c80a:	fbe0 e503 	umlal	lr, r5, r0, r3
   1c80e:	f04f 0600 	mov.w	r6, #0
   1c812:	fbe1 5603 	umlal	r5, r6, r1, r3
   1c816:	f09c 0f00 	teq	ip, #0
   1c81a:	bf18      	it	ne
   1c81c:	f04e 0e01 	orrne.w	lr, lr, #1
   1c820:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   1c824:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   1c828:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   1c82c:	d204      	bcs.n	1c838 <__aeabi_dmul+0x80>
   1c82e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   1c832:	416d      	adcs	r5, r5
   1c834:	eb46 0606 	adc.w	r6, r6, r6
   1c838:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   1c83c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   1c840:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   1c844:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   1c848:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   1c84c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   1c850:	bf88      	it	hi
   1c852:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   1c856:	d81e      	bhi.n	1c896 <__aeabi_dmul+0xde>
   1c858:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   1c85c:	bf08      	it	eq
   1c85e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   1c862:	f150 0000 	adcs.w	r0, r0, #0
   1c866:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   1c86a:	bd70      	pop	{r4, r5, r6, pc}
   1c86c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   1c870:	ea46 0101 	orr.w	r1, r6, r1
   1c874:	ea40 0002 	orr.w	r0, r0, r2
   1c878:	ea81 0103 	eor.w	r1, r1, r3
   1c87c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   1c880:	bfc2      	ittt	gt
   1c882:	ebd4 050c 	rsbsgt	r5, r4, ip
   1c886:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   1c88a:	bd70      	popgt	{r4, r5, r6, pc}
   1c88c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1c890:	f04f 0e00 	mov.w	lr, #0
   1c894:	3c01      	subs	r4, #1
   1c896:	f300 80ab 	bgt.w	1c9f0 <__aeabi_dmul+0x238>
   1c89a:	f114 0f36 	cmn.w	r4, #54	; 0x36
   1c89e:	bfde      	ittt	le
   1c8a0:	2000      	movle	r0, #0
   1c8a2:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   1c8a6:	bd70      	pople	{r4, r5, r6, pc}
   1c8a8:	f1c4 0400 	rsb	r4, r4, #0
   1c8ac:	3c20      	subs	r4, #32
   1c8ae:	da35      	bge.n	1c91c <__aeabi_dmul+0x164>
   1c8b0:	340c      	adds	r4, #12
   1c8b2:	dc1b      	bgt.n	1c8ec <__aeabi_dmul+0x134>
   1c8b4:	f104 0414 	add.w	r4, r4, #20
   1c8b8:	f1c4 0520 	rsb	r5, r4, #32
   1c8bc:	fa00 f305 	lsl.w	r3, r0, r5
   1c8c0:	fa20 f004 	lsr.w	r0, r0, r4
   1c8c4:	fa01 f205 	lsl.w	r2, r1, r5
   1c8c8:	ea40 0002 	orr.w	r0, r0, r2
   1c8cc:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   1c8d0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   1c8d4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   1c8d8:	fa21 f604 	lsr.w	r6, r1, r4
   1c8dc:	eb42 0106 	adc.w	r1, r2, r6
   1c8e0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   1c8e4:	bf08      	it	eq
   1c8e6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   1c8ea:	bd70      	pop	{r4, r5, r6, pc}
   1c8ec:	f1c4 040c 	rsb	r4, r4, #12
   1c8f0:	f1c4 0520 	rsb	r5, r4, #32
   1c8f4:	fa00 f304 	lsl.w	r3, r0, r4
   1c8f8:	fa20 f005 	lsr.w	r0, r0, r5
   1c8fc:	fa01 f204 	lsl.w	r2, r1, r4
   1c900:	ea40 0002 	orr.w	r0, r0, r2
   1c904:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   1c908:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   1c90c:	f141 0100 	adc.w	r1, r1, #0
   1c910:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   1c914:	bf08      	it	eq
   1c916:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   1c91a:	bd70      	pop	{r4, r5, r6, pc}
   1c91c:	f1c4 0520 	rsb	r5, r4, #32
   1c920:	fa00 f205 	lsl.w	r2, r0, r5
   1c924:	ea4e 0e02 	orr.w	lr, lr, r2
   1c928:	fa20 f304 	lsr.w	r3, r0, r4
   1c92c:	fa01 f205 	lsl.w	r2, r1, r5
   1c930:	ea43 0302 	orr.w	r3, r3, r2
   1c934:	fa21 f004 	lsr.w	r0, r1, r4
   1c938:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   1c93c:	fa21 f204 	lsr.w	r2, r1, r4
   1c940:	ea20 0002 	bic.w	r0, r0, r2
   1c944:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   1c948:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   1c94c:	bf08      	it	eq
   1c94e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   1c952:	bd70      	pop	{r4, r5, r6, pc}
   1c954:	f094 0f00 	teq	r4, #0
   1c958:	d10f      	bne.n	1c97a <__aeabi_dmul+0x1c2>
   1c95a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   1c95e:	0040      	lsls	r0, r0, #1
   1c960:	eb41 0101 	adc.w	r1, r1, r1
   1c964:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   1c968:	bf08      	it	eq
   1c96a:	3c01      	subeq	r4, #1
   1c96c:	d0f7      	beq.n	1c95e <__aeabi_dmul+0x1a6>
   1c96e:	ea41 0106 	orr.w	r1, r1, r6
   1c972:	f095 0f00 	teq	r5, #0
   1c976:	bf18      	it	ne
   1c978:	4770      	bxne	lr
   1c97a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   1c97e:	0052      	lsls	r2, r2, #1
   1c980:	eb43 0303 	adc.w	r3, r3, r3
   1c984:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   1c988:	bf08      	it	eq
   1c98a:	3d01      	subeq	r5, #1
   1c98c:	d0f7      	beq.n	1c97e <__aeabi_dmul+0x1c6>
   1c98e:	ea43 0306 	orr.w	r3, r3, r6
   1c992:	4770      	bx	lr
   1c994:	ea94 0f0c 	teq	r4, ip
   1c998:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   1c99c:	bf18      	it	ne
   1c99e:	ea95 0f0c 	teqne	r5, ip
   1c9a2:	d00c      	beq.n	1c9be <__aeabi_dmul+0x206>
   1c9a4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   1c9a8:	bf18      	it	ne
   1c9aa:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   1c9ae:	d1d1      	bne.n	1c954 <__aeabi_dmul+0x19c>
   1c9b0:	ea81 0103 	eor.w	r1, r1, r3
   1c9b4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   1c9b8:	f04f 0000 	mov.w	r0, #0
   1c9bc:	bd70      	pop	{r4, r5, r6, pc}
   1c9be:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   1c9c2:	bf06      	itte	eq
   1c9c4:	4610      	moveq	r0, r2
   1c9c6:	4619      	moveq	r1, r3
   1c9c8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   1c9cc:	d019      	beq.n	1ca02 <__aeabi_dmul+0x24a>
   1c9ce:	ea94 0f0c 	teq	r4, ip
   1c9d2:	d102      	bne.n	1c9da <__aeabi_dmul+0x222>
   1c9d4:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   1c9d8:	d113      	bne.n	1ca02 <__aeabi_dmul+0x24a>
   1c9da:	ea95 0f0c 	teq	r5, ip
   1c9de:	d105      	bne.n	1c9ec <__aeabi_dmul+0x234>
   1c9e0:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   1c9e4:	bf1c      	itt	ne
   1c9e6:	4610      	movne	r0, r2
   1c9e8:	4619      	movne	r1, r3
   1c9ea:	d10a      	bne.n	1ca02 <__aeabi_dmul+0x24a>
   1c9ec:	ea81 0103 	eor.w	r1, r1, r3
   1c9f0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   1c9f4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   1c9f8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   1c9fc:	f04f 0000 	mov.w	r0, #0
   1ca00:	bd70      	pop	{r4, r5, r6, pc}
   1ca02:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   1ca06:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   1ca0a:	bd70      	pop	{r4, r5, r6, pc}

0001ca0c <__aeabi_ddiv>:
   1ca0c:	b570      	push	{r4, r5, r6, lr}
   1ca0e:	f04f 0cff 	mov.w	ip, #255	; 0xff
   1ca12:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   1ca16:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   1ca1a:	bf1d      	ittte	ne
   1ca1c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   1ca20:	ea94 0f0c 	teqne	r4, ip
   1ca24:	ea95 0f0c 	teqne	r5, ip
   1ca28:	f000 f8a7 	bleq	1cb7a <__aeabi_ddiv+0x16e>
   1ca2c:	eba4 0405 	sub.w	r4, r4, r5
   1ca30:	ea81 0e03 	eor.w	lr, r1, r3
   1ca34:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   1ca38:	ea4f 3101 	mov.w	r1, r1, lsl #12
   1ca3c:	f000 8088 	beq.w	1cb50 <__aeabi_ddiv+0x144>
   1ca40:	ea4f 3303 	mov.w	r3, r3, lsl #12
   1ca44:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   1ca48:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   1ca4c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   1ca50:	ea4f 2202 	mov.w	r2, r2, lsl #8
   1ca54:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   1ca58:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   1ca5c:	ea4f 2600 	mov.w	r6, r0, lsl #8
   1ca60:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   1ca64:	429d      	cmp	r5, r3
   1ca66:	bf08      	it	eq
   1ca68:	4296      	cmpeq	r6, r2
   1ca6a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   1ca6e:	f504 7440 	add.w	r4, r4, #768	; 0x300
   1ca72:	d202      	bcs.n	1ca7a <__aeabi_ddiv+0x6e>
   1ca74:	085b      	lsrs	r3, r3, #1
   1ca76:	ea4f 0232 	mov.w	r2, r2, rrx
   1ca7a:	1ab6      	subs	r6, r6, r2
   1ca7c:	eb65 0503 	sbc.w	r5, r5, r3
   1ca80:	085b      	lsrs	r3, r3, #1
   1ca82:	ea4f 0232 	mov.w	r2, r2, rrx
   1ca86:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   1ca8a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   1ca8e:	ebb6 0e02 	subs.w	lr, r6, r2
   1ca92:	eb75 0e03 	sbcs.w	lr, r5, r3
   1ca96:	bf22      	ittt	cs
   1ca98:	1ab6      	subcs	r6, r6, r2
   1ca9a:	4675      	movcs	r5, lr
   1ca9c:	ea40 000c 	orrcs.w	r0, r0, ip
   1caa0:	085b      	lsrs	r3, r3, #1
   1caa2:	ea4f 0232 	mov.w	r2, r2, rrx
   1caa6:	ebb6 0e02 	subs.w	lr, r6, r2
   1caaa:	eb75 0e03 	sbcs.w	lr, r5, r3
   1caae:	bf22      	ittt	cs
   1cab0:	1ab6      	subcs	r6, r6, r2
   1cab2:	4675      	movcs	r5, lr
   1cab4:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   1cab8:	085b      	lsrs	r3, r3, #1
   1caba:	ea4f 0232 	mov.w	r2, r2, rrx
   1cabe:	ebb6 0e02 	subs.w	lr, r6, r2
   1cac2:	eb75 0e03 	sbcs.w	lr, r5, r3
   1cac6:	bf22      	ittt	cs
   1cac8:	1ab6      	subcs	r6, r6, r2
   1caca:	4675      	movcs	r5, lr
   1cacc:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   1cad0:	085b      	lsrs	r3, r3, #1
   1cad2:	ea4f 0232 	mov.w	r2, r2, rrx
   1cad6:	ebb6 0e02 	subs.w	lr, r6, r2
   1cada:	eb75 0e03 	sbcs.w	lr, r5, r3
   1cade:	bf22      	ittt	cs
   1cae0:	1ab6      	subcs	r6, r6, r2
   1cae2:	4675      	movcs	r5, lr
   1cae4:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   1cae8:	ea55 0e06 	orrs.w	lr, r5, r6
   1caec:	d018      	beq.n	1cb20 <__aeabi_ddiv+0x114>
   1caee:	ea4f 1505 	mov.w	r5, r5, lsl #4
   1caf2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   1caf6:	ea4f 1606 	mov.w	r6, r6, lsl #4
   1cafa:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   1cafe:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   1cb02:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   1cb06:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   1cb0a:	d1c0      	bne.n	1ca8e <__aeabi_ddiv+0x82>
   1cb0c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   1cb10:	d10b      	bne.n	1cb2a <__aeabi_ddiv+0x11e>
   1cb12:	ea41 0100 	orr.w	r1, r1, r0
   1cb16:	f04f 0000 	mov.w	r0, #0
   1cb1a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   1cb1e:	e7b6      	b.n	1ca8e <__aeabi_ddiv+0x82>
   1cb20:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   1cb24:	bf04      	itt	eq
   1cb26:	4301      	orreq	r1, r0
   1cb28:	2000      	moveq	r0, #0
   1cb2a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   1cb2e:	bf88      	it	hi
   1cb30:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   1cb34:	f63f aeaf 	bhi.w	1c896 <__aeabi_dmul+0xde>
   1cb38:	ebb5 0c03 	subs.w	ip, r5, r3
   1cb3c:	bf04      	itt	eq
   1cb3e:	ebb6 0c02 	subseq.w	ip, r6, r2
   1cb42:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   1cb46:	f150 0000 	adcs.w	r0, r0, #0
   1cb4a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   1cb4e:	bd70      	pop	{r4, r5, r6, pc}
   1cb50:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   1cb54:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   1cb58:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   1cb5c:	bfc2      	ittt	gt
   1cb5e:	ebd4 050c 	rsbsgt	r5, r4, ip
   1cb62:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   1cb66:	bd70      	popgt	{r4, r5, r6, pc}
   1cb68:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1cb6c:	f04f 0e00 	mov.w	lr, #0
   1cb70:	3c01      	subs	r4, #1
   1cb72:	e690      	b.n	1c896 <__aeabi_dmul+0xde>
   1cb74:	ea45 0e06 	orr.w	lr, r5, r6
   1cb78:	e68d      	b.n	1c896 <__aeabi_dmul+0xde>
   1cb7a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   1cb7e:	ea94 0f0c 	teq	r4, ip
   1cb82:	bf08      	it	eq
   1cb84:	ea95 0f0c 	teqeq	r5, ip
   1cb88:	f43f af3b 	beq.w	1ca02 <__aeabi_dmul+0x24a>
   1cb8c:	ea94 0f0c 	teq	r4, ip
   1cb90:	d10a      	bne.n	1cba8 <__aeabi_ddiv+0x19c>
   1cb92:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   1cb96:	f47f af34 	bne.w	1ca02 <__aeabi_dmul+0x24a>
   1cb9a:	ea95 0f0c 	teq	r5, ip
   1cb9e:	f47f af25 	bne.w	1c9ec <__aeabi_dmul+0x234>
   1cba2:	4610      	mov	r0, r2
   1cba4:	4619      	mov	r1, r3
   1cba6:	e72c      	b.n	1ca02 <__aeabi_dmul+0x24a>
   1cba8:	ea95 0f0c 	teq	r5, ip
   1cbac:	d106      	bne.n	1cbbc <__aeabi_ddiv+0x1b0>
   1cbae:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   1cbb2:	f43f aefd 	beq.w	1c9b0 <__aeabi_dmul+0x1f8>
   1cbb6:	4610      	mov	r0, r2
   1cbb8:	4619      	mov	r1, r3
   1cbba:	e722      	b.n	1ca02 <__aeabi_dmul+0x24a>
   1cbbc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   1cbc0:	bf18      	it	ne
   1cbc2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   1cbc6:	f47f aec5 	bne.w	1c954 <__aeabi_dmul+0x19c>
   1cbca:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   1cbce:	f47f af0d 	bne.w	1c9ec <__aeabi_dmul+0x234>
   1cbd2:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   1cbd6:	f47f aeeb 	bne.w	1c9b0 <__aeabi_dmul+0x1f8>
   1cbda:	e712      	b.n	1ca02 <__aeabi_dmul+0x24a>

0001cbdc <__gedf2>:
   1cbdc:	f04f 3cff 	mov.w	ip, #4294967295
   1cbe0:	e006      	b.n	1cbf0 <__cmpdf2+0x4>
   1cbe2:	bf00      	nop

0001cbe4 <__ledf2>:
   1cbe4:	f04f 0c01 	mov.w	ip, #1
   1cbe8:	e002      	b.n	1cbf0 <__cmpdf2+0x4>
   1cbea:	bf00      	nop

0001cbec <__cmpdf2>:
   1cbec:	f04f 0c01 	mov.w	ip, #1
   1cbf0:	f84d cd04 	str.w	ip, [sp, #-4]!
   1cbf4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   1cbf8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1cbfc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   1cc00:	bf18      	it	ne
   1cc02:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
   1cc06:	d01b      	beq.n	1cc40 <__cmpdf2+0x54>
   1cc08:	b001      	add	sp, #4
   1cc0a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
   1cc0e:	bf0c      	ite	eq
   1cc10:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
   1cc14:	ea91 0f03 	teqne	r1, r3
   1cc18:	bf02      	ittt	eq
   1cc1a:	ea90 0f02 	teqeq	r0, r2
   1cc1e:	2000      	moveq	r0, #0
   1cc20:	4770      	bxeq	lr
   1cc22:	f110 0f00 	cmn.w	r0, #0
   1cc26:	ea91 0f03 	teq	r1, r3
   1cc2a:	bf58      	it	pl
   1cc2c:	4299      	cmppl	r1, r3
   1cc2e:	bf08      	it	eq
   1cc30:	4290      	cmpeq	r0, r2
   1cc32:	bf2c      	ite	cs
   1cc34:	17d8      	asrcs	r0, r3, #31
   1cc36:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
   1cc3a:	f040 0001 	orr.w	r0, r0, #1
   1cc3e:	4770      	bx	lr
   1cc40:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   1cc44:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1cc48:	d102      	bne.n	1cc50 <__cmpdf2+0x64>
   1cc4a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   1cc4e:	d107      	bne.n	1cc60 <__cmpdf2+0x74>
   1cc50:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   1cc54:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1cc58:	d1d6      	bne.n	1cc08 <__cmpdf2+0x1c>
   1cc5a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   1cc5e:	d0d3      	beq.n	1cc08 <__cmpdf2+0x1c>
   1cc60:	f85d 0b04 	ldr.w	r0, [sp], #4
   1cc64:	4770      	bx	lr
   1cc66:	bf00      	nop

0001cc68 <__aeabi_cdrcmple>:
   1cc68:	4684      	mov	ip, r0
   1cc6a:	4610      	mov	r0, r2
   1cc6c:	4662      	mov	r2, ip
   1cc6e:	468c      	mov	ip, r1
   1cc70:	4619      	mov	r1, r3
   1cc72:	4663      	mov	r3, ip
   1cc74:	e000      	b.n	1cc78 <__aeabi_cdcmpeq>
   1cc76:	bf00      	nop

0001cc78 <__aeabi_cdcmpeq>:
   1cc78:	b501      	push	{r0, lr}
   1cc7a:	f7ff ffb7 	bl	1cbec <__cmpdf2>
   1cc7e:	2800      	cmp	r0, #0
   1cc80:	bf48      	it	mi
   1cc82:	f110 0f00 	cmnmi.w	r0, #0
   1cc86:	bd01      	pop	{r0, pc}

0001cc88 <__aeabi_dcmpeq>:
   1cc88:	f84d ed08 	str.w	lr, [sp, #-8]!
   1cc8c:	f7ff fff4 	bl	1cc78 <__aeabi_cdcmpeq>
   1cc90:	bf0c      	ite	eq
   1cc92:	2001      	moveq	r0, #1
   1cc94:	2000      	movne	r0, #0
   1cc96:	f85d fb08 	ldr.w	pc, [sp], #8
   1cc9a:	bf00      	nop

0001cc9c <__aeabi_dcmplt>:
   1cc9c:	f84d ed08 	str.w	lr, [sp, #-8]!
   1cca0:	f7ff ffea 	bl	1cc78 <__aeabi_cdcmpeq>
   1cca4:	bf34      	ite	cc
   1cca6:	2001      	movcc	r0, #1
   1cca8:	2000      	movcs	r0, #0
   1ccaa:	f85d fb08 	ldr.w	pc, [sp], #8
   1ccae:	bf00      	nop

0001ccb0 <__aeabi_dcmple>:
   1ccb0:	f84d ed08 	str.w	lr, [sp, #-8]!
   1ccb4:	f7ff ffe0 	bl	1cc78 <__aeabi_cdcmpeq>
   1ccb8:	bf94      	ite	ls
   1ccba:	2001      	movls	r0, #1
   1ccbc:	2000      	movhi	r0, #0
   1ccbe:	f85d fb08 	ldr.w	pc, [sp], #8
   1ccc2:	bf00      	nop

0001ccc4 <__aeabi_dcmpge>:
   1ccc4:	f84d ed08 	str.w	lr, [sp, #-8]!
   1ccc8:	f7ff ffce 	bl	1cc68 <__aeabi_cdrcmple>
   1cccc:	bf94      	ite	ls
   1ccce:	2001      	movls	r0, #1
   1ccd0:	2000      	movhi	r0, #0
   1ccd2:	f85d fb08 	ldr.w	pc, [sp], #8
   1ccd6:	bf00      	nop

0001ccd8 <__aeabi_dcmpgt>:
   1ccd8:	f84d ed08 	str.w	lr, [sp, #-8]!
   1ccdc:	f7ff ffc4 	bl	1cc68 <__aeabi_cdrcmple>
   1cce0:	bf34      	ite	cc
   1cce2:	2001      	movcc	r0, #1
   1cce4:	2000      	movcs	r0, #0
   1cce6:	f85d fb08 	ldr.w	pc, [sp], #8
   1ccea:	bf00      	nop

0001ccec <__aeabi_d2uiz>:
   1ccec:	004a      	lsls	r2, r1, #1
   1ccee:	d211      	bcs.n	1cd14 <__aeabi_d2uiz+0x28>
   1ccf0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   1ccf4:	d211      	bcs.n	1cd1a <__aeabi_d2uiz+0x2e>
   1ccf6:	d50d      	bpl.n	1cd14 <__aeabi_d2uiz+0x28>
   1ccf8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   1ccfc:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   1cd00:	d40e      	bmi.n	1cd20 <__aeabi_d2uiz+0x34>
   1cd02:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1cd06:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1cd0a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   1cd0e:	fa23 f002 	lsr.w	r0, r3, r2
   1cd12:	4770      	bx	lr
   1cd14:	f04f 0000 	mov.w	r0, #0
   1cd18:	4770      	bx	lr
   1cd1a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   1cd1e:	d102      	bne.n	1cd26 <__aeabi_d2uiz+0x3a>
   1cd20:	f04f 30ff 	mov.w	r0, #4294967295
   1cd24:	4770      	bx	lr
   1cd26:	f04f 0000 	mov.w	r0, #0
   1cd2a:	4770      	bx	lr

0001cd2c <__aeabi_d2f>:
   1cd2c:	ea4f 0241 	mov.w	r2, r1, lsl #1
   1cd30:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   1cd34:	bf24      	itt	cs
   1cd36:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   1cd3a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   1cd3e:	d90d      	bls.n	1cd5c <__aeabi_d2f+0x30>
   1cd40:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   1cd44:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   1cd48:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   1cd4c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   1cd50:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   1cd54:	bf08      	it	eq
   1cd56:	f020 0001 	biceq.w	r0, r0, #1
   1cd5a:	4770      	bx	lr
   1cd5c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   1cd60:	d121      	bne.n	1cda6 <__aeabi_d2f+0x7a>
   1cd62:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   1cd66:	bfbc      	itt	lt
   1cd68:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   1cd6c:	4770      	bxlt	lr
   1cd6e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1cd72:	ea4f 5252 	mov.w	r2, r2, lsr #21
   1cd76:	f1c2 0218 	rsb	r2, r2, #24
   1cd7a:	f1c2 0c20 	rsb	ip, r2, #32
   1cd7e:	fa10 f30c 	lsls.w	r3, r0, ip
   1cd82:	fa20 f002 	lsr.w	r0, r0, r2
   1cd86:	bf18      	it	ne
   1cd88:	f040 0001 	orrne.w	r0, r0, #1
   1cd8c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1cd90:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   1cd94:	fa03 fc0c 	lsl.w	ip, r3, ip
   1cd98:	ea40 000c 	orr.w	r0, r0, ip
   1cd9c:	fa23 f302 	lsr.w	r3, r3, r2
   1cda0:	ea4f 0343 	mov.w	r3, r3, lsl #1
   1cda4:	e7cc      	b.n	1cd40 <__aeabi_d2f+0x14>
   1cda6:	ea7f 5362 	mvns.w	r3, r2, asr #21
   1cdaa:	d107      	bne.n	1cdbc <__aeabi_d2f+0x90>
   1cdac:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   1cdb0:	bf1e      	ittt	ne
   1cdb2:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   1cdb6:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   1cdba:	4770      	bxne	lr
   1cdbc:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   1cdc0:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   1cdc4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   1cdc8:	4770      	bx	lr
   1cdca:	bf00      	nop

0001cdcc <__aeabi_uldivmod>:
   1cdcc:	b953      	cbnz	r3, 1cde4 <__aeabi_uldivmod+0x18>
   1cdce:	b94a      	cbnz	r2, 1cde4 <__aeabi_uldivmod+0x18>
   1cdd0:	2900      	cmp	r1, #0
   1cdd2:	bf08      	it	eq
   1cdd4:	2800      	cmpeq	r0, #0
   1cdd6:	bf1c      	itt	ne
   1cdd8:	f04f 31ff 	movne.w	r1, #4294967295
   1cddc:	f04f 30ff 	movne.w	r0, #4294967295
   1cde0:	f000 b970 	b.w	1d0c4 <__aeabi_idiv0>
   1cde4:	f1ad 0c08 	sub.w	ip, sp, #8
   1cde8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   1cdec:	f000 f806 	bl	1cdfc <__udivmoddi4>
   1cdf0:	f8dd e004 	ldr.w	lr, [sp, #4]
   1cdf4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1cdf8:	b004      	add	sp, #16
   1cdfa:	4770      	bx	lr

0001cdfc <__udivmoddi4>:
   1cdfc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ce00:	9e09      	ldr	r6, [sp, #36]	; 0x24
   1ce02:	4604      	mov	r4, r0
   1ce04:	4689      	mov	r9, r1
   1ce06:	2b00      	cmp	r3, #0
   1ce08:	f040 8083 	bne.w	1cf12 <__udivmoddi4+0x116>
   1ce0c:	428a      	cmp	r2, r1
   1ce0e:	4615      	mov	r5, r2
   1ce10:	d945      	bls.n	1ce9e <__udivmoddi4+0xa2>
   1ce12:	fab2 f282 	clz	r2, r2
   1ce16:	b14a      	cbz	r2, 1ce2c <__udivmoddi4+0x30>
   1ce18:	f1c2 0720 	rsb	r7, r2, #32
   1ce1c:	fa01 f302 	lsl.w	r3, r1, r2
   1ce20:	4095      	lsls	r5, r2
   1ce22:	4094      	lsls	r4, r2
   1ce24:	fa20 f707 	lsr.w	r7, r0, r7
   1ce28:	ea47 0903 	orr.w	r9, r7, r3
   1ce2c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1ce30:	0c23      	lsrs	r3, r4, #16
   1ce32:	fa1f f885 	uxth.w	r8, r5
   1ce36:	fbb9 fcfe 	udiv	ip, r9, lr
   1ce3a:	fb0e 991c 	mls	r9, lr, ip, r9
   1ce3e:	fb0c f108 	mul.w	r1, ip, r8
   1ce42:	ea43 4309 	orr.w	r3, r3, r9, lsl #16
   1ce46:	4299      	cmp	r1, r3
   1ce48:	d90a      	bls.n	1ce60 <__udivmoddi4+0x64>
   1ce4a:	18eb      	adds	r3, r5, r3
   1ce4c:	bf2c      	ite	cs
   1ce4e:	2001      	movcs	r0, #1
   1ce50:	2000      	movcc	r0, #0
   1ce52:	4299      	cmp	r1, r3
   1ce54:	d902      	bls.n	1ce5c <__udivmoddi4+0x60>
   1ce56:	2800      	cmp	r0, #0
   1ce58:	f000 811d 	beq.w	1d096 <__udivmoddi4+0x29a>
   1ce5c:	f10c 3cff 	add.w	ip, ip, #4294967295
   1ce60:	1a59      	subs	r1, r3, r1
   1ce62:	b2a3      	uxth	r3, r4
   1ce64:	fbb1 f0fe 	udiv	r0, r1, lr
   1ce68:	fb0e 1110 	mls	r1, lr, r0, r1
   1ce6c:	fb00 f808 	mul.w	r8, r0, r8
   1ce70:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
   1ce74:	45a0      	cmp	r8, r4
   1ce76:	d905      	bls.n	1ce84 <__udivmoddi4+0x88>
   1ce78:	192c      	adds	r4, r5, r4
   1ce7a:	d202      	bcs.n	1ce82 <__udivmoddi4+0x86>
   1ce7c:	45a0      	cmp	r8, r4
   1ce7e:	f200 810e 	bhi.w	1d09e <__udivmoddi4+0x2a2>
   1ce82:	3801      	subs	r0, #1
   1ce84:	eba4 0408 	sub.w	r4, r4, r8
   1ce88:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   1ce8c:	2700      	movs	r7, #0
   1ce8e:	b11e      	cbz	r6, 1ce98 <__udivmoddi4+0x9c>
   1ce90:	40d4      	lsrs	r4, r2
   1ce92:	2300      	movs	r3, #0
   1ce94:	e9c6 4300 	strd	r4, r3, [r6]
   1ce98:	4639      	mov	r1, r7
   1ce9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ce9e:	2a00      	cmp	r2, #0
   1cea0:	d051      	beq.n	1cf46 <__udivmoddi4+0x14a>
   1cea2:	fab2 f282 	clz	r2, r2
   1cea6:	2a00      	cmp	r2, #0
   1cea8:	f040 80af 	bne.w	1d00a <__udivmoddi4+0x20e>
   1ceac:	1b49      	subs	r1, r1, r5
   1ceae:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1ceb2:	fa1f f885 	uxth.w	r8, r5
   1ceb6:	2701      	movs	r7, #1
   1ceb8:	0c23      	lsrs	r3, r4, #16
   1ceba:	fbb1 fcfe 	udiv	ip, r1, lr
   1cebe:	fb0e 111c 	mls	r1, lr, ip, r1
   1cec2:	fb08 f00c 	mul.w	r0, r8, ip
   1cec6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   1ceca:	4298      	cmp	r0, r3
   1cecc:	d90a      	bls.n	1cee4 <__udivmoddi4+0xe8>
   1cece:	18eb      	adds	r3, r5, r3
   1ced0:	bf2c      	ite	cs
   1ced2:	2101      	movcs	r1, #1
   1ced4:	2100      	movcc	r1, #0
   1ced6:	4298      	cmp	r0, r3
   1ced8:	d902      	bls.n	1cee0 <__udivmoddi4+0xe4>
   1ceda:	2900      	cmp	r1, #0
   1cedc:	f000 80d7 	beq.w	1d08e <__udivmoddi4+0x292>
   1cee0:	f10c 3cff 	add.w	ip, ip, #4294967295
   1cee4:	1a19      	subs	r1, r3, r0
   1cee6:	b2a3      	uxth	r3, r4
   1cee8:	fbb1 f0fe 	udiv	r0, r1, lr
   1ceec:	fb0e 1110 	mls	r1, lr, r0, r1
   1cef0:	fb08 f800 	mul.w	r8, r8, r0
   1cef4:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
   1cef8:	45a0      	cmp	r8, r4
   1cefa:	d905      	bls.n	1cf08 <__udivmoddi4+0x10c>
   1cefc:	192c      	adds	r4, r5, r4
   1cefe:	d202      	bcs.n	1cf06 <__udivmoddi4+0x10a>
   1cf00:	45a0      	cmp	r8, r4
   1cf02:	f200 80c1 	bhi.w	1d088 <__udivmoddi4+0x28c>
   1cf06:	3801      	subs	r0, #1
   1cf08:	eba4 0408 	sub.w	r4, r4, r8
   1cf0c:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   1cf10:	e7bd      	b.n	1ce8e <__udivmoddi4+0x92>
   1cf12:	428b      	cmp	r3, r1
   1cf14:	d908      	bls.n	1cf28 <__udivmoddi4+0x12c>
   1cf16:	2e00      	cmp	r6, #0
   1cf18:	d074      	beq.n	1d004 <__udivmoddi4+0x208>
   1cf1a:	2700      	movs	r7, #0
   1cf1c:	e9c6 0100 	strd	r0, r1, [r6]
   1cf20:	4638      	mov	r0, r7
   1cf22:	4639      	mov	r1, r7
   1cf24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1cf28:	fab3 f783 	clz	r7, r3
   1cf2c:	b967      	cbnz	r7, 1cf48 <__udivmoddi4+0x14c>
   1cf2e:	428b      	cmp	r3, r1
   1cf30:	f0c0 80a4 	bcc.w	1d07c <__udivmoddi4+0x280>
   1cf34:	4282      	cmp	r2, r0
   1cf36:	f240 80a1 	bls.w	1d07c <__udivmoddi4+0x280>
   1cf3a:	4638      	mov	r0, r7
   1cf3c:	2e00      	cmp	r6, #0
   1cf3e:	d0ab      	beq.n	1ce98 <__udivmoddi4+0x9c>
   1cf40:	e9c6 4900 	strd	r4, r9, [r6]
   1cf44:	e7a8      	b.n	1ce98 <__udivmoddi4+0x9c>
   1cf46:	deff      	udf	#255	; 0xff
   1cf48:	f1c7 0520 	rsb	r5, r7, #32
   1cf4c:	40bb      	lsls	r3, r7
   1cf4e:	fa02 fc07 	lsl.w	ip, r2, r7
   1cf52:	fa01 f407 	lsl.w	r4, r1, r7
   1cf56:	40ea      	lsrs	r2, r5
   1cf58:	fa20 f805 	lsr.w	r8, r0, r5
   1cf5c:	40e9      	lsrs	r1, r5
   1cf5e:	fa00 fe07 	lsl.w	lr, r0, r7
   1cf62:	431a      	orrs	r2, r3
   1cf64:	ea48 0404 	orr.w	r4, r8, r4
   1cf68:	ea4f 4812 	mov.w	r8, r2, lsr #16
   1cf6c:	0c20      	lsrs	r0, r4, #16
   1cf6e:	fa1f f982 	uxth.w	r9, r2
   1cf72:	fbb1 faf8 	udiv	sl, r1, r8
   1cf76:	fb08 111a 	mls	r1, r8, sl, r1
   1cf7a:	fb0a fb09 	mul.w	fp, sl, r9
   1cf7e:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
   1cf82:	458b      	cmp	fp, r1
   1cf84:	d90a      	bls.n	1cf9c <__udivmoddi4+0x1a0>
   1cf86:	1851      	adds	r1, r2, r1
   1cf88:	bf2c      	ite	cs
   1cf8a:	2301      	movcs	r3, #1
   1cf8c:	2300      	movcc	r3, #0
   1cf8e:	458b      	cmp	fp, r1
   1cf90:	d902      	bls.n	1cf98 <__udivmoddi4+0x19c>
   1cf92:	2b00      	cmp	r3, #0
   1cf94:	f000 8088 	beq.w	1d0a8 <__udivmoddi4+0x2ac>
   1cf98:	f10a 3aff 	add.w	sl, sl, #4294967295
   1cf9c:	eba1 010b 	sub.w	r1, r1, fp
   1cfa0:	b2a4      	uxth	r4, r4
   1cfa2:	fbb1 f0f8 	udiv	r0, r1, r8
   1cfa6:	fb08 1110 	mls	r1, r8, r0, r1
   1cfaa:	fb00 f909 	mul.w	r9, r0, r9
   1cfae:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
   1cfb2:	4589      	cmp	r9, r1
   1cfb4:	d904      	bls.n	1cfc0 <__udivmoddi4+0x1c4>
   1cfb6:	1851      	adds	r1, r2, r1
   1cfb8:	d201      	bcs.n	1cfbe <__udivmoddi4+0x1c2>
   1cfba:	4589      	cmp	r9, r1
   1cfbc:	d87b      	bhi.n	1d0b6 <__udivmoddi4+0x2ba>
   1cfbe:	3801      	subs	r0, #1
   1cfc0:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
   1cfc4:	eba1 0109 	sub.w	r1, r1, r9
   1cfc8:	fba0 890c 	umull	r8, r9, r0, ip
   1cfcc:	4549      	cmp	r1, r9
   1cfce:	4644      	mov	r4, r8
   1cfd0:	464b      	mov	r3, r9
   1cfd2:	d302      	bcc.n	1cfda <__udivmoddi4+0x1de>
   1cfd4:	d106      	bne.n	1cfe4 <__udivmoddi4+0x1e8>
   1cfd6:	45c6      	cmp	lr, r8
   1cfd8:	d204      	bcs.n	1cfe4 <__udivmoddi4+0x1e8>
   1cfda:	3801      	subs	r0, #1
   1cfdc:	ebb8 040c 	subs.w	r4, r8, ip
   1cfe0:	eb69 0302 	sbc.w	r3, r9, r2
   1cfe4:	2e00      	cmp	r6, #0
   1cfe6:	d05d      	beq.n	1d0a4 <__udivmoddi4+0x2a8>
   1cfe8:	ebbe 0204 	subs.w	r2, lr, r4
   1cfec:	eb61 0103 	sbc.w	r1, r1, r3
   1cff0:	fa01 f505 	lsl.w	r5, r1, r5
   1cff4:	fa22 f307 	lsr.w	r3, r2, r7
   1cff8:	40f9      	lsrs	r1, r7
   1cffa:	2700      	movs	r7, #0
   1cffc:	431d      	orrs	r5, r3
   1cffe:	e9c6 5100 	strd	r5, r1, [r6]
   1d002:	e749      	b.n	1ce98 <__udivmoddi4+0x9c>
   1d004:	4637      	mov	r7, r6
   1d006:	4630      	mov	r0, r6
   1d008:	e746      	b.n	1ce98 <__udivmoddi4+0x9c>
   1d00a:	f1c2 0020 	rsb	r0, r2, #32
   1d00e:	4095      	lsls	r5, r2
   1d010:	fa01 f702 	lsl.w	r7, r1, r2
   1d014:	fa21 f300 	lsr.w	r3, r1, r0
   1d018:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1d01c:	fa24 f100 	lsr.w	r1, r4, r0
   1d020:	fa1f f885 	uxth.w	r8, r5
   1d024:	4094      	lsls	r4, r2
   1d026:	4339      	orrs	r1, r7
   1d028:	fbb3 f0fe 	udiv	r0, r3, lr
   1d02c:	0c0f      	lsrs	r7, r1, #16
   1d02e:	fb0e 3310 	mls	r3, lr, r0, r3
   1d032:	fb00 fc08 	mul.w	ip, r0, r8
   1d036:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
   1d03a:	459c      	cmp	ip, r3
   1d03c:	d907      	bls.n	1d04e <__udivmoddi4+0x252>
   1d03e:	18eb      	adds	r3, r5, r3
   1d040:	bf2c      	ite	cs
   1d042:	2701      	movcs	r7, #1
   1d044:	2700      	movcc	r7, #0
   1d046:	459c      	cmp	ip, r3
   1d048:	d900      	bls.n	1d04c <__udivmoddi4+0x250>
   1d04a:	b38f      	cbz	r7, 1d0b0 <__udivmoddi4+0x2b4>
   1d04c:	3801      	subs	r0, #1
   1d04e:	eba3 030c 	sub.w	r3, r3, ip
   1d052:	b289      	uxth	r1, r1
   1d054:	fbb3 f7fe 	udiv	r7, r3, lr
   1d058:	fb0e 3317 	mls	r3, lr, r7, r3
   1d05c:	fb07 fc08 	mul.w	ip, r7, r8
   1d060:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   1d064:	458c      	cmp	ip, r1
   1d066:	d904      	bls.n	1d072 <__udivmoddi4+0x276>
   1d068:	1869      	adds	r1, r5, r1
   1d06a:	d201      	bcs.n	1d070 <__udivmoddi4+0x274>
   1d06c:	458c      	cmp	ip, r1
   1d06e:	d825      	bhi.n	1d0bc <__udivmoddi4+0x2c0>
   1d070:	3f01      	subs	r7, #1
   1d072:	eba1 010c 	sub.w	r1, r1, ip
   1d076:	ea47 4700 	orr.w	r7, r7, r0, lsl #16
   1d07a:	e71d      	b.n	1ceb8 <__udivmoddi4+0xbc>
   1d07c:	1a84      	subs	r4, r0, r2
   1d07e:	eb61 0303 	sbc.w	r3, r1, r3
   1d082:	2001      	movs	r0, #1
   1d084:	4699      	mov	r9, r3
   1d086:	e759      	b.n	1cf3c <__udivmoddi4+0x140>
   1d088:	3802      	subs	r0, #2
   1d08a:	442c      	add	r4, r5
   1d08c:	e73c      	b.n	1cf08 <__udivmoddi4+0x10c>
   1d08e:	f1ac 0c02 	sub.w	ip, ip, #2
   1d092:	442b      	add	r3, r5
   1d094:	e726      	b.n	1cee4 <__udivmoddi4+0xe8>
   1d096:	f1ac 0c02 	sub.w	ip, ip, #2
   1d09a:	442b      	add	r3, r5
   1d09c:	e6e0      	b.n	1ce60 <__udivmoddi4+0x64>
   1d09e:	3802      	subs	r0, #2
   1d0a0:	442c      	add	r4, r5
   1d0a2:	e6ef      	b.n	1ce84 <__udivmoddi4+0x88>
   1d0a4:	4637      	mov	r7, r6
   1d0a6:	e6f7      	b.n	1ce98 <__udivmoddi4+0x9c>
   1d0a8:	f1aa 0a02 	sub.w	sl, sl, #2
   1d0ac:	4411      	add	r1, r2
   1d0ae:	e775      	b.n	1cf9c <__udivmoddi4+0x1a0>
   1d0b0:	3802      	subs	r0, #2
   1d0b2:	442b      	add	r3, r5
   1d0b4:	e7cb      	b.n	1d04e <__udivmoddi4+0x252>
   1d0b6:	3802      	subs	r0, #2
   1d0b8:	4411      	add	r1, r2
   1d0ba:	e781      	b.n	1cfc0 <__udivmoddi4+0x1c4>
   1d0bc:	3f02      	subs	r7, #2
   1d0be:	4429      	add	r1, r5
   1d0c0:	e7d7      	b.n	1d072 <__udivmoddi4+0x276>
   1d0c2:	bf00      	nop

0001d0c4 <__aeabi_idiv0>:
   1d0c4:	4770      	bx	lr
   1d0c6:	bf00      	nop

0001d0c8 <__aeabi_dcmpun>:
   1d0c8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   1d0cc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1d0d0:	d102      	bne.n	1d0d8 <__aeabi_dcmpun+0x10>
   1d0d2:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   1d0d6:	d10a      	bne.n	1d0ee <__aeabi_dcmpun+0x26>
   1d0d8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   1d0dc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   1d0e0:	d102      	bne.n	1d0e8 <__aeabi_dcmpun+0x20>
   1d0e2:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   1d0e6:	d102      	bne.n	1d0ee <__aeabi_dcmpun+0x26>
   1d0e8:	f04f 0000 	mov.w	r0, #0
   1d0ec:	4770      	bx	lr
   1d0ee:	f04f 0001 	mov.w	r0, #1
   1d0f2:	4770      	bx	lr

0001d0f4 <__aeabi_d2iz>:
   1d0f4:	ea4f 0241 	mov.w	r2, r1, lsl #1
   1d0f8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   1d0fc:	d215      	bcs.n	1d12a <__aeabi_d2iz+0x36>
   1d0fe:	d511      	bpl.n	1d124 <__aeabi_d2iz+0x30>
   1d100:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   1d104:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   1d108:	d912      	bls.n	1d130 <__aeabi_d2iz+0x3c>
   1d10a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1d10e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1d112:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   1d116:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   1d11a:	fa23 f002 	lsr.w	r0, r3, r2
   1d11e:	bf18      	it	ne
   1d120:	4240      	negne	r0, r0
   1d122:	4770      	bx	lr
   1d124:	f04f 0000 	mov.w	r0, #0
   1d128:	4770      	bx	lr
   1d12a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   1d12e:	d105      	bne.n	1d13c <__aeabi_d2iz+0x48>
   1d130:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
   1d134:	bf08      	it	eq
   1d136:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   1d13a:	4770      	bx	lr
   1d13c:	f04f 0000 	mov.w	r0, #0
   1d140:	4770      	bx	lr
   1d142:	bf00      	nop

0001d144 <strcmp>:
   1d144:	f810 2b01 	ldrb.w	r2, [r0], #1
   1d148:	f811 3b01 	ldrb.w	r3, [r1], #1
   1d14c:	2a01      	cmp	r2, #1
   1d14e:	bf28      	it	cs
   1d150:	429a      	cmpcs	r2, r3
   1d152:	d0f7      	beq.n	1d144 <strcmp>
   1d154:	1ad0      	subs	r0, r2, r3
   1d156:	4770      	bx	lr

0001d158 <strlen>:
   1d158:	4603      	mov	r3, r0
   1d15a:	f813 2b01 	ldrb.w	r2, [r3], #1
   1d15e:	2a00      	cmp	r2, #0
   1d160:	d1fb      	bne.n	1d15a <strlen+0x2>
   1d162:	1a18      	subs	r0, r3, r0
   1d164:	3801      	subs	r0, #1
   1d166:	4770      	bx	lr

0001d168 <APP_Ask_GPS_Data_timerout>:
}
#endif

void APP_Ask_GPS_Data_timerout(struct k_timer *timer)
{
	u8_t str_gps[20] = {0};
   1d168:	2300      	movs	r3, #0
	u32_t tmp1;
	double tmp2;
	
	APP_wait_gps = false;
   1d16a:	4a4b      	ldr	r2, [pc, #300]	; (1d298 <APP_Ask_GPS_Data_timerout+0x130>)
{
   1d16c:	b5f0      	push	{r4, r5, r6, r7, lr}
	APP_wait_gps = false;
   1d16e:	7013      	strb	r3, [r2, #0]
	app_gps_off = true;
   1d170:	2201      	movs	r2, #1
{
   1d172:	b087      	sub	sp, #28

	//UTC date&time
	//year
	str_gps[0] = last_fix.pvt.datetime.year>>8;
   1d174:	4c49      	ldr	r4, [pc, #292]	; (1d29c <APP_Ask_GPS_Data_timerout+0x134>)
	u8_t str_gps[20] = {0};
   1d176:	9305      	str	r3, [sp, #20]
	app_gps_off = true;
   1d178:	4b49      	ldr	r3, [pc, #292]	; (1d2a0 <APP_Ask_GPS_Data_timerout+0x138>)
	//seconds
	str_gps[6] = last_fix.pvt.datetime.seconds;

	//longitude
	str_gps[7] = 'E';
	if(last_fix.pvt.longitude < 0)
   1d17a:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
	app_gps_off = true;
   1d17e:	701a      	strb	r2, [r3, #0]
	str_gps[0] = last_fix.pvt.datetime.year>>8;
   1d180:	8d23      	ldrh	r3, [r4, #40]	; 0x28
	str_gps[2] = last_fix.pvt.datetime.month;
   1d182:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
	str_gps[0] = last_fix.pvt.datetime.year>>8;
   1d184:	ba5b      	rev16	r3, r3
   1d186:	f8ad 3004 	strh.w	r3, [sp, #4]
	str_gps[6] = last_fix.pvt.datetime.seconds;
   1d18a:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
	str_gps[2] = last_fix.pvt.datetime.month;
   1d18e:	f8ad 2006 	strh.w	r2, [sp, #6]
	str_gps[6] = last_fix.pvt.datetime.seconds;
   1d192:	f88d 300a 	strb.w	r3, [sp, #10]
	str_gps[7] = 'E';
   1d196:	2345      	movs	r3, #69	; 0x45
	str_gps[4] = last_fix.pvt.datetime.hour;
   1d198:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
	str_gps[7] = 'E';
   1d19a:	f88d 300b 	strb.w	r3, [sp, #11]
	str_gps[4] = last_fix.pvt.datetime.hour;
   1d19e:	f8ad 2008 	strh.w	r2, [sp, #8]
	if(last_fix.pvt.longitude < 0)
   1d1a2:	2300      	movs	r3, #0
   1d1a4:	2200      	movs	r2, #0
   1d1a6:	4630      	mov	r0, r6
   1d1a8:	4639      	mov	r1, r7
   1d1aa:	f7ff fd77 	bl	1cc9c <__aeabi_dcmplt>
   1d1ae:	b130      	cbz	r0, 1d1be <APP_Ask_GPS_Data_timerout+0x56>
	{
		str_gps[7] = 'W';
   1d1b0:	2357      	movs	r3, #87	; 0x57
   1d1b2:	f88d 300b 	strb.w	r3, [sp, #11]
		last_fix.pvt.longitude = -last_fix.pvt.longitude;
   1d1b6:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
   1d1ba:	6126      	str	r6, [r4, #16]
   1d1bc:	6163      	str	r3, [r4, #20]
	}

	tmp1 = (u32_t)(last_fix.pvt.longitude);	//
   1d1be:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
   1d1c2:	4639      	mov	r1, r7
   1d1c4:	4630      	mov	r0, r6
   1d1c6:	f7ff fd91 	bl	1ccec <__aeabi_d2uiz>
	tmp2 = last_fix.pvt.longitude - tmp1;	//
	
	str_gps[8] = tmp1;//
   1d1ca:	f88d 000c 	strb.w	r0, [sp, #12]
	tmp2 = last_fix.pvt.longitude - tmp1;	//
   1d1ce:	f7ff fa79 	bl	1c6c4 <__aeabi_ui2d>
   1d1d2:	4602      	mov	r2, r0
   1d1d4:	460b      	mov	r3, r1
   1d1d6:	4630      	mov	r0, r6
   1d1d8:	4639      	mov	r1, r7
   1d1da:	f7ff f935 	bl	1c448 <__aeabi_dsub>
	tmp1 = (u32_t)(tmp2*1000000);
   1d1de:	a32c      	add	r3, pc, #176	; (adr r3, 1d290 <APP_Ask_GPS_Data_timerout+0x128>)
   1d1e0:	e9d3 2300 	ldrd	r2, r3, [r3]
   1d1e4:	f7ff fae8 	bl	1c7b8 <__aeabi_dmul>
   1d1e8:	f7ff fd80 	bl	1ccec <__aeabi_d2uiz>
	tmp1 = tmp1%100;
	str_gps[11] = (u8_t)(tmp1);
	
	//latitude
	str_gps[12] = 'N';
	if(last_fix.pvt.latitude < 0)
   1d1ec:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
	str_gps[9] = (u8_t)(tmp1/10000);
   1d1f0:	f242 7210 	movw	r2, #10000	; 0x2710
   1d1f4:	fbb0 f3f2 	udiv	r3, r0, r2
   1d1f8:	f88d 300d 	strb.w	r3, [sp, #13]
	tmp1 = tmp1%10000;
   1d1fc:	fb02 0313 	mls	r3, r2, r3, r0
	str_gps[10] = (u8_t)(tmp1/100);
   1d200:	2264      	movs	r2, #100	; 0x64
   1d202:	fbb3 f0f2 	udiv	r0, r3, r2
	tmp1 = tmp1%100;
   1d206:	fb02 3310 	mls	r3, r2, r0, r3
	str_gps[11] = (u8_t)(tmp1);
   1d20a:	f88d 300f 	strb.w	r3, [sp, #15]
	str_gps[12] = 'N';
   1d20e:	234e      	movs	r3, #78	; 0x4e
	str_gps[10] = (u8_t)(tmp1/100);
   1d210:	f88d 000e 	strb.w	r0, [sp, #14]
	str_gps[12] = 'N';
   1d214:	f88d 3010 	strb.w	r3, [sp, #16]
	if(last_fix.pvt.latitude < 0)
   1d218:	2200      	movs	r2, #0
   1d21a:	2300      	movs	r3, #0
   1d21c:	4630      	mov	r0, r6
   1d21e:	4639      	mov	r1, r7
   1d220:	f7ff fd3c 	bl	1cc9c <__aeabi_dcmplt>
   1d224:	b130      	cbz	r0, 1d234 <APP_Ask_GPS_Data_timerout+0xcc>
	{
		str_gps[12] = 'S';
   1d226:	2353      	movs	r3, #83	; 0x53
   1d228:	f88d 3010 	strb.w	r3, [sp, #16]
		last_fix.pvt.latitude = -last_fix.pvt.latitude;
   1d22c:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
   1d230:	60a6      	str	r6, [r4, #8]
   1d232:	60e3      	str	r3, [r4, #12]
	}

	tmp1 = (u32_t)(last_fix.pvt.latitude);	//
   1d234:	e9d4 4502 	ldrd	r4, r5, [r4, #8]
   1d238:	4629      	mov	r1, r5
   1d23a:	4620      	mov	r0, r4
   1d23c:	f7ff fd56 	bl	1ccec <__aeabi_d2uiz>
	tmp2 = last_fix.pvt.latitude - tmp1;	//
	
	str_gps[13] = tmp1;//
   1d240:	f88d 0011 	strb.w	r0, [sp, #17]
	tmp2 = last_fix.pvt.latitude - tmp1;	//
   1d244:	f7ff fa3e 	bl	1c6c4 <__aeabi_ui2d>
   1d248:	4602      	mov	r2, r0
   1d24a:	460b      	mov	r3, r1
   1d24c:	4620      	mov	r0, r4
   1d24e:	4629      	mov	r1, r5
   1d250:	f7ff f8fa 	bl	1c448 <__aeabi_dsub>
	tmp1 = (u32_t)(tmp2*1000000);
   1d254:	a30e      	add	r3, pc, #56	; (adr r3, 1d290 <APP_Ask_GPS_Data_timerout+0x128>)
   1d256:	e9d3 2300 	ldrd	r2, r3, [r3]
   1d25a:	f7ff faad 	bl	1c7b8 <__aeabi_dmul>
   1d25e:	f7ff fd45 	bl	1ccec <__aeabi_d2uiz>
	str_gps[14] = (u8_t)(tmp1/10000);
   1d262:	f242 7210 	movw	r2, #10000	; 0x2710
   1d266:	fbb0 f3f2 	udiv	r3, r0, r2
   1d26a:	f88d 3012 	strb.w	r3, [sp, #18]
	tmp1 = tmp1%10000;
   1d26e:	fb02 0313 	mls	r3, r2, r3, r0
	str_gps[15] = (u8_t)(tmp1/100);
   1d272:	2264      	movs	r2, #100	; 0x64
   1d274:	fbb3 f0f2 	udiv	r0, r3, r2
	tmp1 = tmp1%100;
   1d278:	fb02 3310 	mls	r3, r2, r0, r3
	str_gps[15] = (u8_t)(tmp1/100);
   1d27c:	f88d 0013 	strb.w	r0, [sp, #19]
	str_gps[16] = (u8_t)(tmp1);

	APP_get_location_data_reply(str_gps, 17);
   1d280:	2111      	movs	r1, #17
   1d282:	a801      	add	r0, sp, #4
	str_gps[16] = (u8_t)(tmp1);
   1d284:	f88d 3014 	strb.w	r3, [sp, #20]
	APP_get_location_data_reply(str_gps, 17);
   1d288:	f01d fc0b 	bl	3aaa2 <APP_get_location_data_reply>
}
   1d28c:	b007      	add	sp, #28
   1d28e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d290:	00000000 	.word	0x00000000
   1d294:	412e8480 	.word	0x412e8480
   1d298:	2002b926 	.word	0x2002b926
   1d29c:	20020008 	.word	0x20020008
   1d2a0:	2002bdae 	.word	0x2002bdae
   1d2a4:	00000000 	.word	0x00000000

0001d2a8 <gps_data_receive>:
{
	app_gps_off = true;
}

void gps_data_receive(void)
{
   1d2a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1d2ac:	b0be      	sub	sp, #248	; 0xf8
	do
	{
		/* Loop until we don't have more
		 * data to read
		 */
	}while(process_gps_data(&gps_data) > 0);
   1d2ae:	a808      	add	r0, sp, #32
   1d2b0:	f005 fc60 	bl	22b74 <process_gps_data>
   1d2b4:	2800      	cmp	r0, #0
   1d2b6:	dcfa      	bgt.n	1d2ae <gps_data_receive+0x6>

	if(!got_first_fix)
   1d2b8:	4dd7      	ldr	r5, [pc, #860]	; (1d618 <gps_data_receive+0x370>)
   1d2ba:	782b      	ldrb	r3, [r5, #0]
   1d2bc:	bb93      	cbnz	r3, 1d324 <gps_data_receive+0x7c>
	{
		cnt++;
   1d2be:	f8df 83a8 	ldr.w	r8, [pc, #936]	; 1d668 <gps_data_receive+0x3c0>
		LOG_INF("\033[1;1H");
   1d2c2:	f04f 0000 	mov.w	r0, #0
		cnt++;
   1d2c6:	f898 3000 	ldrb.w	r3, [r8]
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
   1d2ca:	4cd4      	ldr	r4, [pc, #848]	; (1d61c <gps_data_receive+0x374>)
   1d2cc:	3301      	adds	r3, #1
   1d2ce:	f888 3000 	strb.w	r3, [r8]
		LOG_INF("\033[1;1H");
   1d2d2:	2303      	movs	r3, #3
   1d2d4:	f363 0007 	bfi	r0, r3, #0, #8
   1d2d8:	4bd1      	ldr	r3, [pc, #836]	; (1d620 <gps_data_receive+0x378>)
   1d2da:	49d2      	ldr	r1, [pc, #840]	; (1d624 <gps_data_receive+0x37c>)
   1d2dc:	1ae4      	subs	r4, r4, r3
   1d2de:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1d2e2:	f364 108f 	bfi	r0, r4, #6, #10
   1d2e6:	f01f fa78 	bl	3c7da <log_string_sync>
		LOG_INF("\033[2J");
   1d2ea:	2303      	movs	r3, #3
   1d2ec:	f04f 0000 	mov.w	r0, #0
   1d2f0:	f363 0007 	bfi	r0, r3, #0, #8
   1d2f4:	49cc      	ldr	r1, [pc, #816]	; (1d628 <gps_data_receive+0x380>)
   1d2f6:	f364 108f 	bfi	r0, r4, #6, #10
   1d2fa:	f01f fa6e 	bl	3c7da <log_string_sync>
		print_satellite_stats(&gps_data);
   1d2fe:	a808      	add	r0, sp, #32
   1d300:	f005 fbe4 	bl	22acc <print_satellite_stats>
		LOG_INF("\nScanning [%c] ",
   1d304:	2303      	movs	r3, #3
   1d306:	f04f 0000 	mov.w	r0, #0
   1d30a:	f363 0007 	bfi	r0, r3, #0, #8
   1d30e:	f898 3000 	ldrb.w	r3, [r8]
   1d312:	4ac6      	ldr	r2, [pc, #792]	; (1d62c <gps_data_receive+0x384>)
   1d314:	f003 0303 	and.w	r3, r3, #3
   1d318:	f364 108f 	bfi	r0, r4, #6, #10
   1d31c:	5cd2      	ldrb	r2, [r2, r3]
   1d31e:	49c4      	ldr	r1, [pc, #784]	; (1d630 <gps_data_receive+0x388>)
   1d320:	f01f fa5b 	bl	3c7da <log_string_sync>
		(void)arch_syscall_invoke1((uintptr_t)&ret64, K_SYSCALL_K_UPTIME_GET);
		return (s64_t)ret64;
	}
#endif
	compiler_barrier();
	return z_impl_k_uptime_get();
   1d324:	f021 f9d5 	bl	3e6d2 <z_impl_k_uptime_get>
		sprintf(tmpbuf, "Scanning [%c] ", update_indicator[cnt%4]);
		show_infor(tmpbuf);
	#endif	
	}

	if(((k_uptime_get() - fix_timestamp) >= 1) && (got_first_fix))
   1d328:	f8df 9340 	ldr.w	r9, [pc, #832]	; 1d66c <gps_data_receive+0x3c4>
   1d32c:	e9d9 2300 	ldrd	r2, r3, [r9]
   1d330:	428b      	cmp	r3, r1
   1d332:	bf08      	it	eq
   1d334:	4282      	cmpeq	r2, r0
   1d336:	f000 819b 	beq.w	1d670 <gps_data_receive+0x3c8>
   1d33a:	782b      	ldrb	r3, [r5, #0]
   1d33c:	2b00      	cmp	r3, #0
   1d33e:	f000 8197 	beq.w	1d670 <gps_data_receive+0x3c8>
	{
		LOG_INF("\033[1;1H");
   1d342:	2303      	movs	r3, #3
   1d344:	f04f 0000 	mov.w	r0, #0
   1d348:	4db4      	ldr	r5, [pc, #720]	; (1d61c <gps_data_receive+0x374>)
   1d34a:	f363 0007 	bfi	r0, r3, #0, #8
   1d34e:	4bb4      	ldr	r3, [pc, #720]	; (1d620 <gps_data_receive+0x378>)
   1d350:	49b4      	ldr	r1, [pc, #720]	; (1d624 <gps_data_receive+0x37c>)
   1d352:	1aed      	subs	r5, r5, r3
   1d354:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   1d358:	f365 108f 	bfi	r0, r5, #6, #10
   1d35c:	f01f fa3d 	bl	3c7da <log_string_sync>
		LOG_INF("\033[2J");
   1d360:	2303      	movs	r3, #3
   1d362:	f04f 0000 	mov.w	r0, #0
   1d366:	f363 0007 	bfi	r0, r3, #0, #8
   1d36a:	f365 108f 	bfi	r0, r5, #6, #10
   1d36e:	49ae      	ldr	r1, [pc, #696]	; (1d628 <gps_data_receive+0x380>)
   1d370:	f01f fa33 	bl	3c7da <log_string_sync>

		print_satellite_stats(&gps_data);
   1d374:	a808      	add	r0, sp, #32
   1d376:	f005 fba9 	bl	22acc <print_satellite_stats>

		LOG_INF("---------------------------------\n");
   1d37a:	2303      	movs	r3, #3
   1d37c:	f04f 0000 	mov.w	r0, #0
	LCD_Fill(0,20,240,200,BLACK);
   1d380:	f04f 0800 	mov.w	r8, #0
		LOG_INF("---------------------------------\n");
   1d384:	f363 0007 	bfi	r0, r3, #0, #8
   1d388:	f365 108f 	bfi	r0, r5, #6, #10
   1d38c:	49a9      	ldr	r1, [pc, #676]	; (1d634 <gps_data_receive+0x38c>)
   1d38e:	f01f fa24 	bl	3c7da <log_string_sync>
	LCD_Fill(0,20,240,200,BLACK);
   1d392:	4640      	mov	r0, r8
   1d394:	f8cd 8000 	str.w	r8, [sp]
   1d398:	23c8      	movs	r3, #200	; 0xc8
   1d39a:	22f0      	movs	r2, #240	; 0xf0
   1d39c:	2114      	movs	r1, #20
   1d39e:	f003 fb93 	bl	20ac8 <LCD_Fill>
	LOG_INF("Longitude:  %f\n", pvt_data->pvt.longitude);
   1d3a2:	2303      	movs	r3, #3
   1d3a4:	f04f 0000 	mov.w	r0, #0
   1d3a8:	4ca3      	ldr	r4, [pc, #652]	; (1d638 <gps_data_receive+0x390>)
   1d3aa:	f363 0007 	bfi	r0, r3, #0, #8
   1d3ae:	f365 108f 	bfi	r0, r5, #6, #10
   1d3b2:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
   1d3b6:	49a1      	ldr	r1, [pc, #644]	; (1d63c <gps_data_receive+0x394>)
   1d3b8:	f01f fa0f 	bl	3c7da <log_string_sync>
	LOG_INF("Latitude:   %f\n", pvt_data->pvt.latitude);
   1d3bc:	2303      	movs	r3, #3
   1d3be:	f04f 0000 	mov.w	r0, #0
   1d3c2:	f363 0007 	bfi	r0, r3, #0, #8
   1d3c6:	f365 108f 	bfi	r0, r5, #6, #10
   1d3ca:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
   1d3ce:	499c      	ldr	r1, [pc, #624]	; (1d640 <gps_data_receive+0x398>)
   1d3d0:	f01f fa03 	bl	3c7da <log_string_sync>
	LOG_INF("Altitude:   %f\n", pvt_data->pvt.altitude);
   1d3d4:	f04f 0a00 	mov.w	sl, #0
   1d3d8:	2303      	movs	r3, #3
   1d3da:	69a0      	ldr	r0, [r4, #24]
   1d3dc:	f363 0a07 	bfi	sl, r3, #0, #8
   1d3e0:	f7ff f992 	bl	1c708 <__aeabi_f2d>
   1d3e4:	f365 1a8f 	bfi	sl, r5, #6, #10
   1d3e8:	4602      	mov	r2, r0
   1d3ea:	460b      	mov	r3, r1
   1d3ec:	4650      	mov	r0, sl
   1d3ee:	4995      	ldr	r1, [pc, #596]	; (1d644 <gps_data_receive+0x39c>)
   1d3f0:	f01f f9f3 	bl	3c7da <log_string_sync>
	LOG_INF("Speed:      %f\n", pvt_data->pvt.speed);
   1d3f4:	f04f 0a00 	mov.w	sl, #0
   1d3f8:	2303      	movs	r3, #3
   1d3fa:	6a20      	ldr	r0, [r4, #32]
   1d3fc:	f363 0a07 	bfi	sl, r3, #0, #8
   1d400:	f7ff f982 	bl	1c708 <__aeabi_f2d>
   1d404:	f365 1a8f 	bfi	sl, r5, #6, #10
   1d408:	4602      	mov	r2, r0
   1d40a:	460b      	mov	r3, r1
   1d40c:	4650      	mov	r0, sl
   1d40e:	498e      	ldr	r1, [pc, #568]	; (1d648 <gps_data_receive+0x3a0>)
   1d410:	f01f f9e3 	bl	3c7da <log_string_sync>
	LOG_INF("Heading:    %f\n", pvt_data->pvt.heading);
   1d414:	f04f 0a00 	mov.w	sl, #0
   1d418:	2303      	movs	r3, #3
   1d41a:	6a60      	ldr	r0, [r4, #36]	; 0x24
   1d41c:	f363 0a07 	bfi	sl, r3, #0, #8
   1d420:	f7ff f972 	bl	1c708 <__aeabi_f2d>
   1d424:	f365 1a8f 	bfi	sl, r5, #6, #10
   1d428:	4602      	mov	r2, r0
   1d42a:	460b      	mov	r3, r1
   1d42c:	4650      	mov	r0, sl
   1d42e:	4987      	ldr	r1, [pc, #540]	; (1d64c <gps_data_receive+0x3a4>)
   1d430:	f01f f9d3 	bl	3c7da <log_string_sync>
	LOG_INF("Date:       %02u-%02u-%02u", pvt_data->pvt.datetime.year,
   1d434:	2303      	movs	r3, #3
   1d436:	f04f 0000 	mov.w	r0, #0
   1d43a:	f363 0007 	bfi	r0, r3, #0, #8
   1d43e:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
   1d442:	f365 108f 	bfi	r0, r5, #6, #10
   1d446:	9300      	str	r3, [sp, #0]
   1d448:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
   1d44c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
   1d44e:	4980      	ldr	r1, [pc, #512]	; (1d650 <gps_data_receive+0x3a8>)
   1d450:	f01f f9c3 	bl	3c7da <log_string_sync>
	LOG_INF("Time (UTC): %02u:%02u:%02u", pvt_data->pvt.datetime.hour,
   1d454:	2303      	movs	r3, #3
   1d456:	f04f 0000 	mov.w	r0, #0
   1d45a:	f363 0007 	bfi	r0, r3, #0, #8
   1d45e:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   1d462:	f365 108f 	bfi	r0, r5, #6, #10
   1d466:	9300      	str	r3, [sp, #0]
   1d468:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
   1d46c:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
   1d470:	4978      	ldr	r1, [pc, #480]	; (1d654 <gps_data_receive+0x3ac>)
   1d472:	f01f f9b2 	bl	3c7da <log_string_sync>
		print_pvt_data(&last_fix);
		LOG_INF("\n");
   1d476:	2303      	movs	r3, #3
   1d478:	f04f 0000 	mov.w	r0, #0
   1d47c:	f363 0007 	bfi	r0, r3, #0, #8
   1d480:	f365 108f 	bfi	r0, r5, #6, #10
   1d484:	4974      	ldr	r1, [pc, #464]	; (1d658 <gps_data_receive+0x3b0>)
   1d486:	f01f f9a8 	bl	3c7da <log_string_sync>
		print_nmea_data();
   1d48a:	f005 fae5 	bl	22a58 <print_nmea_data>
		LOG_INF("---------------------------------");
   1d48e:	2303      	movs	r3, #3
   1d490:	f04f 0000 	mov.w	r0, #0
   1d494:	f363 0007 	bfi	r0, r3, #0, #8
   1d498:	f365 108f 	bfi	r0, r5, #6, #10
   1d49c:	496f      	ldr	r1, [pc, #444]	; (1d65c <gps_data_receive+0x3b4>)
   1d49e:	f01f f99c 	bl	3c7da <log_string_sync>
   1d4a2:	f021 f916 	bl	3e6d2 <z_impl_k_uptime_get>

		update_terminal = false;

		if(((k_uptime_get() - fix_timestamp) >= 5) && (APP_wait_gps))
   1d4a6:	e9d9 3200 	ldrd	r3, r2, [r9]
   1d4aa:	1ac6      	subs	r6, r0, r3
   1d4ac:	eb61 0702 	sbc.w	r7, r1, r2
   1d4b0:	2f00      	cmp	r7, #0
   1d4b2:	bf08      	it	eq
   1d4b4:	2e05      	cmpeq	r6, #5
   1d4b6:	f0c0 80db 	bcc.w	1d670 <gps_data_receive+0x3c8>
   1d4ba:	4d69      	ldr	r5, [pc, #420]	; (1d660 <gps_data_receive+0x3b8>)
   1d4bc:	782a      	ldrb	r2, [r5, #0]
   1d4be:	2a00      	cmp	r2, #0
   1d4c0:	f000 80d6 	beq.w	1d670 <gps_data_receive+0x3c8>
		{
			u8_t str_gps[20] = {0};
   1d4c4:	2214      	movs	r2, #20
   1d4c6:	4641      	mov	r1, r8
   1d4c8:	a803      	add	r0, sp, #12
   1d4ca:	f021 f9df 	bl	3e88c <memset>
 */
__syscall u32_t k_timer_remaining_get(struct k_timer *timer);

static inline u32_t z_impl_k_timer_remaining_get(struct k_timer *timer)
{
	const s32_t ticks = z_timeout_remaining(&timer->timeout);
   1d4ce:	4865      	ldr	r0, [pc, #404]	; (1d664 <gps_data_receive+0x3bc>)
   1d4d0:	f01a fec4 	bl	3825c <z_timeout_remaining>
	return (ticks > 0) ? (u32_t)k_ticks_to_ms_floor64(ticks) : 0U;
   1d4d4:	2800      	cmp	r0, #0
   1d4d6:	dd0a      	ble.n	1d4ee <gps_data_receive+0x246>
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
   1d4d8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1d4dc:	fb80 0103 	smull	r0, r1, r0, r3
   1d4e0:	0bc3      	lsrs	r3, r0, #15
			u32_t tmp1;
			double tmp2;

			if(k_timer_remaining_get(&app_wait_gps_timer) > 0)
   1d4e2:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
   1d4e6:	d002      	beq.n	1d4ee <gps_data_receive+0x246>
	z_impl_k_timer_stop(timer);
   1d4e8:	485e      	ldr	r0, [pc, #376]	; (1d664 <gps_data_receive+0x3bc>)
   1d4ea:	f021 f90c 	bl	3e706 <z_impl_k_timer_stop>
				k_timer_stop(&app_wait_gps_timer);

			APP_wait_gps = false;
   1d4ee:	2300      	movs	r3, #0
   1d4f0:	702b      	strb	r3, [r5, #0]
			gps_off();
   1d4f2:	f005 fc9b 	bl	22e2c <gps_off>
			//seconds
			str_gps[6] = last_fix.pvt.datetime.seconds;

			//longitude
			str_gps[7] = 'E';
			if(last_fix.pvt.longitude < 0)
   1d4f6:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
			str_gps[0] = last_fix.pvt.datetime.year>>8;
   1d4fa:	8d23      	ldrh	r3, [r4, #40]	; 0x28
			str_gps[2] = last_fix.pvt.datetime.month;
   1d4fc:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
			str_gps[0] = last_fix.pvt.datetime.year>>8;
   1d4fe:	ba5b      	rev16	r3, r3
   1d500:	f8ad 300c 	strh.w	r3, [sp, #12]
			str_gps[6] = last_fix.pvt.datetime.seconds;
   1d504:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
			str_gps[2] = last_fix.pvt.datetime.month;
   1d508:	f8ad 200e 	strh.w	r2, [sp, #14]
			str_gps[6] = last_fix.pvt.datetime.seconds;
   1d50c:	f88d 3012 	strb.w	r3, [sp, #18]
			str_gps[7] = 'E';
   1d510:	2345      	movs	r3, #69	; 0x45
			str_gps[4] = last_fix.pvt.datetime.hour;
   1d512:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
			str_gps[7] = 'E';
   1d514:	f88d 3013 	strb.w	r3, [sp, #19]
			str_gps[4] = last_fix.pvt.datetime.hour;
   1d518:	f8ad 2010 	strh.w	r2, [sp, #16]
			if(last_fix.pvt.longitude < 0)
   1d51c:	2300      	movs	r3, #0
   1d51e:	2200      	movs	r2, #0
   1d520:	4630      	mov	r0, r6
   1d522:	4639      	mov	r1, r7
   1d524:	f7ff fbba 	bl	1cc9c <__aeabi_dcmplt>
   1d528:	b130      	cbz	r0, 1d538 <gps_data_receive+0x290>
			{
				str_gps[7] = 'W';
   1d52a:	2357      	movs	r3, #87	; 0x57
   1d52c:	f88d 3013 	strb.w	r3, [sp, #19]
				last_fix.pvt.longitude = -last_fix.pvt.longitude;
   1d530:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
   1d534:	6126      	str	r6, [r4, #16]
   1d536:	6163      	str	r3, [r4, #20]
			}

			tmp1 = (u32_t)(last_fix.pvt.longitude);	//
   1d538:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
   1d53c:	4639      	mov	r1, r7
   1d53e:	4630      	mov	r0, r6
   1d540:	f7ff fbd4 	bl	1ccec <__aeabi_d2uiz>
			tmp2 = last_fix.pvt.longitude - tmp1;	//
			
			str_gps[8] = tmp1;//
   1d544:	f88d 0014 	strb.w	r0, [sp, #20]
			tmp2 = last_fix.pvt.longitude - tmp1;	//
   1d548:	f7ff f8bc 	bl	1c6c4 <__aeabi_ui2d>
   1d54c:	4602      	mov	r2, r0
   1d54e:	460b      	mov	r3, r1
   1d550:	4630      	mov	r0, r6
   1d552:	4639      	mov	r1, r7
   1d554:	f7fe ff78 	bl	1c448 <__aeabi_dsub>
			tmp1 = (u32_t)(tmp2*1000000);
   1d558:	a32d      	add	r3, pc, #180	; (adr r3, 1d610 <gps_data_receive+0x368>)
   1d55a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1d55e:	f7ff f92b 	bl	1c7b8 <__aeabi_dmul>
   1d562:	f7ff fbc3 	bl	1ccec <__aeabi_d2uiz>
			tmp1 = tmp1%100;
			str_gps[11] = (u8_t)(tmp1);
			
			//latitude
			str_gps[12] = 'N';
			if(last_fix.pvt.latitude < 0)
   1d566:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
			str_gps[9] = (u8_t)(tmp1/10000);
   1d56a:	f242 7210 	movw	r2, #10000	; 0x2710
   1d56e:	fbb0 f3f2 	udiv	r3, r0, r2
   1d572:	f88d 3015 	strb.w	r3, [sp, #21]
			tmp1 = tmp1%10000;
   1d576:	fb02 0313 	mls	r3, r2, r3, r0
			str_gps[10] = (u8_t)(tmp1/100);
   1d57a:	2264      	movs	r2, #100	; 0x64
   1d57c:	fbb3 f0f2 	udiv	r0, r3, r2
			tmp1 = tmp1%100;
   1d580:	fb02 3310 	mls	r3, r2, r0, r3
			str_gps[11] = (u8_t)(tmp1);
   1d584:	f88d 3017 	strb.w	r3, [sp, #23]
			str_gps[12] = 'N';
   1d588:	234e      	movs	r3, #78	; 0x4e
			str_gps[10] = (u8_t)(tmp1/100);
   1d58a:	f88d 0016 	strb.w	r0, [sp, #22]
			str_gps[12] = 'N';
   1d58e:	f88d 3018 	strb.w	r3, [sp, #24]
			if(last_fix.pvt.latitude < 0)
   1d592:	2200      	movs	r2, #0
   1d594:	2300      	movs	r3, #0
   1d596:	4630      	mov	r0, r6
   1d598:	4639      	mov	r1, r7
   1d59a:	f7ff fb7f 	bl	1cc9c <__aeabi_dcmplt>
   1d59e:	b130      	cbz	r0, 1d5ae <gps_data_receive+0x306>
			{
				str_gps[12] = 'S';
   1d5a0:	2353      	movs	r3, #83	; 0x53
   1d5a2:	f88d 3018 	strb.w	r3, [sp, #24]
				last_fix.pvt.latitude = -last_fix.pvt.latitude;
   1d5a6:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
   1d5aa:	60a6      	str	r6, [r4, #8]
   1d5ac:	60e3      	str	r3, [r4, #12]
			}

			tmp1 = (u32_t)(last_fix.pvt.latitude);	//
   1d5ae:	e9d4 4502 	ldrd	r4, r5, [r4, #8]
   1d5b2:	4629      	mov	r1, r5
   1d5b4:	4620      	mov	r0, r4
   1d5b6:	f7ff fb99 	bl	1ccec <__aeabi_d2uiz>
			tmp2 = last_fix.pvt.latitude - tmp1;	//
			
			str_gps[13] = tmp1;//
   1d5ba:	f88d 0019 	strb.w	r0, [sp, #25]
			tmp2 = last_fix.pvt.latitude - tmp1;	//
   1d5be:	f7ff f881 	bl	1c6c4 <__aeabi_ui2d>
   1d5c2:	4602      	mov	r2, r0
   1d5c4:	460b      	mov	r3, r1
   1d5c6:	4620      	mov	r0, r4
   1d5c8:	4629      	mov	r1, r5
   1d5ca:	f7fe ff3d 	bl	1c448 <__aeabi_dsub>
			tmp1 = (u32_t)(tmp2*1000000);
   1d5ce:	a310      	add	r3, pc, #64	; (adr r3, 1d610 <gps_data_receive+0x368>)
   1d5d0:	e9d3 2300 	ldrd	r2, r3, [r3]
   1d5d4:	f7ff f8f0 	bl	1c7b8 <__aeabi_dmul>
   1d5d8:	f7ff fb88 	bl	1ccec <__aeabi_d2uiz>
			str_gps[14] = (u8_t)(tmp1/10000);
   1d5dc:	f242 7210 	movw	r2, #10000	; 0x2710
   1d5e0:	fbb0 f3f2 	udiv	r3, r0, r2
   1d5e4:	f88d 301a 	strb.w	r3, [sp, #26]
			tmp1 = tmp1%10000;
   1d5e8:	fb02 0313 	mls	r3, r2, r3, r0
			str_gps[15] = (u8_t)(tmp1/100);
   1d5ec:	2264      	movs	r2, #100	; 0x64
   1d5ee:	fbb3 f0f2 	udiv	r0, r3, r2
			tmp1 = tmp1%100;
   1d5f2:	fb02 3310 	mls	r3, r2, r0, r3
			str_gps[15] = (u8_t)(tmp1/100);
   1d5f6:	f88d 001b 	strb.w	r0, [sp, #27]
			str_gps[16] = (u8_t)(tmp1);

			APP_get_location_data_reply(str_gps, 17);
   1d5fa:	2111      	movs	r1, #17
   1d5fc:	a803      	add	r0, sp, #12
			str_gps[16] = (u8_t)(tmp1);
   1d5fe:	f88d 301c 	strb.w	r3, [sp, #28]
			APP_get_location_data_reply(str_gps, 17);
   1d602:	f01d fa4e 	bl	3aaa2 <APP_get_location_data_reply>
	#endif
		return;
	}
	
	print_nmea_data();
}
   1d606:	b03e      	add	sp, #248	; 0xf8
   1d608:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1d60c:	f3af 8000 	nop.w
   1d610:	00000000 	.word	0x00000000
   1d614:	412e8480 	.word	0x412e8480
   1d618:	2002bdb1 	.word	0x2002bdb1
   1d61c:	0003f944 	.word	0x0003f944
   1d620:	0003f8d4 	.word	0x0003f8d4
   1d624:	00040a54 	.word	0x00040a54
   1d628:	00040a5b 	.word	0x00040a5b
   1d62c:	00040cb3 	.word	0x00040cb3
   1d630:	00040a60 	.word	0x00040a60
   1d634:	00040a70 	.word	0x00040a70
   1d638:	20020008 	.word	0x20020008
   1d63c:	00040a93 	.word	0x00040a93
   1d640:	00040aa3 	.word	0x00040aa3
   1d644:	00040ab3 	.word	0x00040ab3
   1d648:	00040ac3 	.word	0x00040ac3
   1d64c:	00040ad3 	.word	0x00040ad3
   1d650:	00040ae3 	.word	0x00040ae3
   1d654:	00040afe 	.word	0x00040afe
   1d658:	00042743 	.word	0x00042743
   1d65c:	00040b19 	.word	0x00040b19
   1d660:	2002b926 	.word	0x2002b926
   1d664:	20020cbc 	.word	0x20020cbc
   1d668:	2002bdb0 	.word	0x2002bdb0
   1d66c:	20020000 	.word	0x20020000
	if(!gps_is_on)
   1d670:	4b03      	ldr	r3, [pc, #12]	; (1d680 <gps_data_receive+0x3d8>)
   1d672:	781b      	ldrb	r3, [r3, #0]
   1d674:	2b00      	cmp	r3, #0
   1d676:	d0c6      	beq.n	1d606 <gps_data_receive+0x35e>
	print_nmea_data();
   1d678:	f005 f9ee 	bl	22a58 <print_nmea_data>
   1d67c:	e7c3      	b.n	1d606 <gps_data_receive+0x35e>
   1d67e:	bf00      	nop
   1d680:	2002bdb4 	.word	0x2002bdb4
   1d684:	00000000 	.word	0x00000000

0001d688 <fall_detection>:
/*@brief Fall detection analyse
*
* @return If fall return 1, otherwise return 0
*/
void fall_detection(void)
{
   1d688:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1d68c:	ed2d 8b06 	vpush	{d8-d10}
   1d690:	b0ac      	sub	sp, #176	; 0xb0
	historic_buffer();
   1d692:	f006 fd93 	bl	241bc <historic_buffer>
	LOG_INF("fall detecting 1");
   1d696:	2303      	movs	r3, #3
   1d698:	f04f 0000 	mov.w	r0, #0
   1d69c:	4cdc      	ldr	r4, [pc, #880]	; (1da10 <fall_detection+0x388>)
   1d69e:	f363 0007 	bfi	r0, r3, #0, #8
   1d6a2:	4bdc      	ldr	r3, [pc, #880]	; (1da14 <fall_detection+0x38c>)

	if(hist_buff_flag)
   1d6a4:	4ddc      	ldr	r5, [pc, #880]	; (1da18 <fall_detection+0x390>)
	LOG_INF("fall detecting 1");
   1d6a6:	1ae4      	subs	r4, r4, r3
   1d6a8:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1d6ac:	f364 108f 	bfi	r0, r4, #6, #10
   1d6b0:	49da      	ldr	r1, [pc, #872]	; (1da1c <fall_detection+0x394>)
   1d6b2:	f01f f892 	bl	3c7da <log_string_sync>
	if(hist_buff_flag)
   1d6b6:	782b      	ldrb	r3, [r5, #0]
   1d6b8:	b16b      	cbz	r3, 1d6d6 <fall_detection+0x4e>
	{
		curr_vrif_buffers();
   1d6ba:	f006 fe45 	bl	24348 <curr_vrif_buffers>
		hist_buff_flag = false;
   1d6be:	2300      	movs	r3, #0
		LOG_INF("fall detecting 2");
   1d6c0:	f04f 0000 	mov.w	r0, #0
		hist_buff_flag = false;
   1d6c4:	702b      	strb	r3, [r5, #0]
		LOG_INF("fall detecting 2");
   1d6c6:	2303      	movs	r3, #3
   1d6c8:	f363 0007 	bfi	r0, r3, #0, #8
   1d6cc:	f364 108f 	bfi	r0, r4, #6, #10
   1d6d0:	49d3      	ldr	r1, [pc, #844]	; (1da20 <fall_detection+0x398>)
   1d6d2:	f01f f882 	bl	3c7da <log_string_sync>
	}

	if(curr_vrif_buff_flag)
   1d6d6:	4dd3      	ldr	r5, [pc, #844]	; (1da24 <fall_detection+0x39c>)
   1d6d8:	782b      	ldrb	r3, [r5, #0]
   1d6da:	2b00      	cmp	r3, #0
   1d6dc:	f000 84fa 	beq.w	1e0d4 <fall_detection+0xa4c>
	volatile float acc_magn_square = 0, max_acc_magn_square = 0;
   1d6e0:	f04f 0a00 	mov.w	sl, #0
	for(i=0;i<ACC_GYRO_FIFO_BUF_LEN*2;i++)
   1d6e4:	2300      	movs	r3, #0
			acc_magn_square = pow(get_acc_magn(acc_x_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_acc_magn(acc_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_acc_magn(acc_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
   1d6e6:	ed9f 8bc6 	vldr	d8, [pc, #792]	; 1da00 <fall_detection+0x378>
   1d6ea:	4ecf      	ldr	r6, [pc, #828]	; (1da28 <fall_detection+0x3a0>)
   1d6ec:	4fcf      	ldr	r7, [pc, #828]	; (1da2c <fall_detection+0x3a4>)
	volatile float acc_magn_square = 0, max_acc_magn_square = 0;
   1d6ee:	f8cd a078 	str.w	sl, [sp, #120]	; 0x78
   1d6f2:	f8cd a07c 	str.w	sl, [sp, #124]	; 0x7c
	for(i=0;i<ACC_GYRO_FIFO_BUF_LEN*2;i++)
   1d6f6:	f8ad 3012 	strh.w	r3, [sp, #18]
   1d6fa:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   1d6fe:	2bc7      	cmp	r3, #199	; 0xc7
   1d700:	f240 82c3 	bls.w	1dc8a <fall_detection+0x602>
	return max_acc_magn_square;		//do once sqrt() to get acc magnitude
   1d704:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
	{       
		acc_magn_square = acceleration_analyse_fifo();
   1d706:	4bca      	ldr	r3, [pc, #808]	; (1da30 <fall_detection+0x3a8>)
	volatile float angle_degree=0,avg_index=20;
   1d708:	f8cd a050 	str.w	sl, [sp, #80]	; 0x50
		acc_magn_square = acceleration_analyse_fifo();
   1d70c:	601a      	str	r2, [r3, #0]
	volatile float angle_degree=0,avg_index=20;
   1d70e:	4bc9      	ldr	r3, [pc, #804]	; (1da34 <fall_detection+0x3ac>)
	volatile double angle=0;
   1d710:	2200      	movs	r2, #0
	volatile float angle_degree=0,avg_index=20;
   1d712:	9315      	str	r3, [sp, #84]	; 0x54
	volatile double angle=0;
   1d714:	2300      	movs	r3, #0
	volatile float start_avg_accel_x=0,start_avg_accel_y=0,start_avg_accel_z=0;
   1d716:	f8cd a058 	str.w	sl, [sp, #88]	; 0x58
   1d71a:	f8cd a05c 	str.w	sl, [sp, #92]	; 0x5c
   1d71e:	f8cd a060 	str.w	sl, [sp, #96]	; 0x60
	volatile float end_avg_accel_x=0, end_avg_accel_y=0, end_avg_accel_z=0;
   1d722:	f8cd a064 	str.w	sl, [sp, #100]	; 0x64
   1d726:	f8cd a068 	str.w	sl, [sp, #104]	; 0x68
   1d72a:	f8cd a06c 	str.w	sl, [sp, #108]	; 0x6c
	volatile float num=0,denom=0;
   1d72e:	f8cd a070 	str.w	sl, [sp, #112]	; 0x70
   1d732:	f8cd a074 	str.w	sl, [sp, #116]	; 0x74
	volatile double angle=0;
   1d736:	e9cd 2320 	strd	r2, r3, [sp, #128]	; 0x80
	for(i = 0; i < avg_index; i++ )
   1d73a:	2300      	movs	r3, #0
		start_avg_accel_x += acc_x_hist_buffer[i];
   1d73c:	4abe      	ldr	r2, [pc, #760]	; (1da38 <fall_detection+0x3b0>)
		start_avg_accel_y += acc_y_hist_buffer[i];
   1d73e:	49bf      	ldr	r1, [pc, #764]	; (1da3c <fall_detection+0x3b4>)
		start_avg_accel_z += acc_z_hist_buffer[i];
   1d740:	48bf      	ldr	r0, [pc, #764]	; (1da40 <fall_detection+0x3b8>)
	for(i = 0; i < avg_index; i++ )
   1d742:	f8ad 3010 	strh.w	r3, [sp, #16]
   1d746:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   1d74a:	ed9d 7a15 	vldr	s14, [sp, #84]	; 0x54
   1d74e:	ee07 3a90 	vmov	s15, r3
   1d752:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1d756:	eef4 7ac7 	vcmpe.f32	s15, s14
   1d75a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1d75e:	f100 831d 	bmi.w	1dd9c <fall_detection+0x714>
	start_avg_accel_x /=avg_index;										//get average for each axis
   1d762:	ed9d 7a15 	vldr	s14, [sp, #84]	; 0x54
   1d766:	eddd 6a16 	vldr	s13, [sp, #88]	; 0x58
   1d76a:	eec6 7a87 	vdiv.f32	s15, s13, s14
   1d76e:	edcd 7a16 	vstr	s15, [sp, #88]	; 0x58
	start_avg_accel_y /=avg_index;
   1d772:	ed9d 7a15 	vldr	s14, [sp, #84]	; 0x54
   1d776:	eddd 6a17 	vldr	s13, [sp, #92]	; 0x5c
   1d77a:	eec6 7a87 	vdiv.f32	s15, s13, s14
   1d77e:	edcd 7a17 	vstr	s15, [sp, #92]	; 0x5c
	start_avg_accel_z /=avg_index;
   1d782:	ed9d 7a15 	vldr	s14, [sp, #84]	; 0x54
   1d786:	eddd 6a18 	vldr	s13, [sp, #96]	; 0x60
   1d78a:	eec6 7a87 	vdiv.f32	s15, s13, s14
   1d78e:	edcd 7a18 	vstr	s15, [sp, #96]	; 0x60
	start_avg_accel_x = get_acc_magn(start_avg_accel_x);			//get acc magnitude
   1d792:	9b16      	ldr	r3, [sp, #88]	; 0x58
	for(i = ACC_GYRO_FIFO_BUF_LEN-avg_index; i < ACC_GYRO_FIFO_BUF_LEN; i++)
   1d794:	ed9f 8aab 	vldr	s16, [pc, #684]	; 1da44 <fall_detection+0x3bc>
	start_avg_accel_x = get_acc_magn(start_avg_accel_x);			//get acc magnitude
   1d798:	9316      	str	r3, [sp, #88]	; 0x58
	start_avg_accel_y = get_acc_magn(start_avg_accel_y);
   1d79a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
		end_avg_accel_x += acc_x_cur_buffer[i];
   1d79c:	4aa2      	ldr	r2, [pc, #648]	; (1da28 <fall_detection+0x3a0>)
	start_avg_accel_y = get_acc_magn(start_avg_accel_y);
   1d79e:	9317      	str	r3, [sp, #92]	; 0x5c
	start_avg_accel_z = get_acc_magn(start_avg_accel_z);
   1d7a0:	9b18      	ldr	r3, [sp, #96]	; 0x60
		end_avg_accel_y += acc_y_cur_buffer[i];
   1d7a2:	49a2      	ldr	r1, [pc, #648]	; (1da2c <fall_detection+0x3a4>)
	start_avg_accel_z = get_acc_magn(start_avg_accel_z);
   1d7a4:	9318      	str	r3, [sp, #96]	; 0x60
	for(i = ACC_GYRO_FIFO_BUF_LEN-avg_index; i < ACC_GYRO_FIFO_BUF_LEN; i++)
   1d7a6:	eddd 7a15 	vldr	s15, [sp, #84]	; 0x54
   1d7aa:	ee78 7a67 	vsub.f32	s15, s16, s15
   1d7ae:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1d7b2:	ee17 3a90 	vmov	r3, s15
		end_avg_accel_z += acc_z_cur_buffer[i];
   1d7b6:	48a4      	ldr	r0, [pc, #656]	; (1da48 <fall_detection+0x3c0>)
	for(i = ACC_GYRO_FIFO_BUF_LEN-avg_index; i < ACC_GYRO_FIFO_BUF_LEN; i++)
   1d7b8:	b29b      	uxth	r3, r3
   1d7ba:	f8ad 3010 	strh.w	r3, [sp, #16]
   1d7be:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   1d7c2:	2b63      	cmp	r3, #99	; 0x63
   1d7c4:	f240 8338 	bls.w	1de38 <fall_detection+0x7b0>
	end_avg_accel_x /=avg_index;										//get average for each axis
   1d7c8:	ed9d 7a15 	vldr	s14, [sp, #84]	; 0x54
   1d7cc:	eddd 6a19 	vldr	s13, [sp, #100]	; 0x64
   1d7d0:	eec6 7a87 	vdiv.f32	s15, s13, s14
   1d7d4:	edcd 7a19 	vstr	s15, [sp, #100]	; 0x64
	end_avg_accel_y /=avg_index;
   1d7d8:	ed9d 7a15 	vldr	s14, [sp, #84]	; 0x54
   1d7dc:	eddd 6a1a 	vldr	s13, [sp, #104]	; 0x68
   1d7e0:	eec6 7a87 	vdiv.f32	s15, s13, s14
   1d7e4:	edcd 7a1a 	vstr	s15, [sp, #104]	; 0x68
	end_avg_accel_z /=avg_index;
   1d7e8:	ed9d 7a15 	vldr	s14, [sp, #84]	; 0x54
   1d7ec:	eddd 6a1b 	vldr	s13, [sp, #108]	; 0x6c
   1d7f0:	eec6 7a87 	vdiv.f32	s15, s13, s14
   1d7f4:	edcd 7a1b 	vstr	s15, [sp, #108]	; 0x6c
	end_avg_accel_x = get_acc_magn(end_avg_accel_x);			//get acc magnitude
   1d7f8:	9b19      	ldr	r3, [sp, #100]	; 0x64
			gyro_magn_square = pow(get_gyro_magn(gyro_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_gyro_magn(gyro_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
   1d7fa:	ed9f 9b81 	vldr	d9, [pc, #516]	; 1da00 <fall_detection+0x378>
	end_avg_accel_x = get_acc_magn(end_avg_accel_x);			//get acc magnitude
   1d7fe:	9319      	str	r3, [sp, #100]	; 0x64
	end_avg_accel_y = get_acc_magn(end_avg_accel_y);
   1d800:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   1d802:	931a      	str	r3, [sp, #104]	; 0x68
	end_avg_accel_z = get_acc_magn(end_avg_accel_z);
   1d804:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
   1d806:	931b      	str	r3, [sp, #108]	; 0x6c
	num= (start_avg_accel_x*end_avg_accel_x) + (start_avg_accel_y*end_avg_accel_y) + (start_avg_accel_z*end_avg_accel_z);
   1d808:	eddd 5a16 	vldr	s11, [sp, #88]	; 0x58
   1d80c:	ed9d 6a19 	vldr	s12, [sp, #100]	; 0x64
   1d810:	eddd 7a17 	vldr	s15, [sp, #92]	; 0x5c
   1d814:	ed9d 5a1a 	vldr	s10, [sp, #104]	; 0x68
   1d818:	ee67 7a85 	vmul.f32	s15, s15, s10
   1d81c:	eddd 6a18 	vldr	s13, [sp, #96]	; 0x60
   1d820:	ee45 7a86 	vmla.f32	s15, s11, s12
   1d824:	ed9d 7a1b 	vldr	s14, [sp, #108]	; 0x6c
   1d828:	ee46 7a87 	vmla.f32	s15, s13, s14
   1d82c:	edcd 7a1c 	vstr	s15, [sp, #112]	; 0x70
	denom= (pow(start_avg_accel_x,2) + pow(start_avg_accel_y,2) + pow(start_avg_accel_z,2)) * (pow(end_avg_accel_x,2)+pow(end_avg_accel_y,2)+pow(end_avg_accel_z,2));
   1d830:	9816      	ldr	r0, [sp, #88]	; 0x58
   1d832:	f7fe ff69 	bl	1c708 <__aeabi_f2d>
   1d836:	ed9f 1b72 	vldr	d1, [pc, #456]	; 1da00 <fall_detection+0x378>
   1d83a:	ec41 0b10 	vmov	d0, r0, r1
   1d83e:	f000 fdf7 	bl	1e430 <pow>
   1d842:	9817      	ldr	r0, [sp, #92]	; 0x5c
   1d844:	ec57 6b10 	vmov	r6, r7, d0
   1d848:	f7fe ff5e 	bl	1c708 <__aeabi_f2d>
   1d84c:	ed9f 1b6c 	vldr	d1, [pc, #432]	; 1da00 <fall_detection+0x378>
   1d850:	ec41 0b10 	vmov	d0, r0, r1
   1d854:	f000 fdec 	bl	1e430 <pow>
   1d858:	4630      	mov	r0, r6
   1d85a:	ec53 2b10 	vmov	r2, r3, d0
   1d85e:	4639      	mov	r1, r7
   1d860:	f7fe fdf4 	bl	1c44c <__adddf3>
   1d864:	4606      	mov	r6, r0
   1d866:	9818      	ldr	r0, [sp, #96]	; 0x60
   1d868:	460f      	mov	r7, r1
   1d86a:	f7fe ff4d 	bl	1c708 <__aeabi_f2d>
   1d86e:	ed9f 1b64 	vldr	d1, [pc, #400]	; 1da00 <fall_detection+0x378>
   1d872:	ec41 0b10 	vmov	d0, r0, r1
   1d876:	f000 fddb 	bl	1e430 <pow>
   1d87a:	4630      	mov	r0, r6
   1d87c:	ec53 2b10 	vmov	r2, r3, d0
   1d880:	4639      	mov	r1, r7
   1d882:	f7fe fde3 	bl	1c44c <__adddf3>
   1d886:	4606      	mov	r6, r0
   1d888:	9819      	ldr	r0, [sp, #100]	; 0x64
   1d88a:	460f      	mov	r7, r1
   1d88c:	f7fe ff3c 	bl	1c708 <__aeabi_f2d>
   1d890:	ed9f 1b5b 	vldr	d1, [pc, #364]	; 1da00 <fall_detection+0x378>
   1d894:	ec41 0b10 	vmov	d0, r0, r1
   1d898:	f000 fdca 	bl	1e430 <pow>
   1d89c:	981a      	ldr	r0, [sp, #104]	; 0x68
   1d89e:	ec59 8b10 	vmov	r8, r9, d0
   1d8a2:	f7fe ff31 	bl	1c708 <__aeabi_f2d>
   1d8a6:	ed9f 1b56 	vldr	d1, [pc, #344]	; 1da00 <fall_detection+0x378>
   1d8aa:	ec41 0b10 	vmov	d0, r0, r1
   1d8ae:	f000 fdbf 	bl	1e430 <pow>
   1d8b2:	4640      	mov	r0, r8
   1d8b4:	ec53 2b10 	vmov	r2, r3, d0
   1d8b8:	4649      	mov	r1, r9
   1d8ba:	f7fe fdc7 	bl	1c44c <__adddf3>
   1d8be:	4680      	mov	r8, r0
   1d8c0:	981b      	ldr	r0, [sp, #108]	; 0x6c
   1d8c2:	4689      	mov	r9, r1
   1d8c4:	f7fe ff20 	bl	1c708 <__aeabi_f2d>
   1d8c8:	ed9f 1b4d 	vldr	d1, [pc, #308]	; 1da00 <fall_detection+0x378>
   1d8cc:	ec41 0b10 	vmov	d0, r0, r1
   1d8d0:	f000 fdae 	bl	1e430 <pow>
   1d8d4:	4640      	mov	r0, r8
   1d8d6:	ec53 2b10 	vmov	r2, r3, d0
   1d8da:	4649      	mov	r1, r9
   1d8dc:	f7fe fdb6 	bl	1c44c <__adddf3>
   1d8e0:	4632      	mov	r2, r6
   1d8e2:	463b      	mov	r3, r7
   1d8e4:	f7fe ff68 	bl	1c7b8 <__aeabi_dmul>
   1d8e8:	f7ff fa20 	bl	1cd2c <__aeabi_d2f>
   1d8ec:	901d      	str	r0, [sp, #116]	; 0x74
	angle=acos(num/sqrt(denom));
   1d8ee:	9e1c      	ldr	r6, [sp, #112]	; 0x70
   1d8f0:	981d      	ldr	r0, [sp, #116]	; 0x74
   1d8f2:	f7fe ff09 	bl	1c708 <__aeabi_f2d>
   1d8f6:	ec41 0b10 	vmov	d0, r0, r1
   1d8fa:	f01b faa3 	bl	38e44 <sqrt>
   1d8fe:	ec53 2b10 	vmov	r2, r3, d0
   1d902:	4630      	mov	r0, r6
   1d904:	e9cd 2300 	strd	r2, r3, [sp]
   1d908:	f7fe fefe 	bl	1c708 <__aeabi_f2d>
   1d90c:	e9dd 2300 	ldrd	r2, r3, [sp]
   1d910:	f7ff f87c 	bl	1ca0c <__aeabi_ddiv>
   1d914:	ec41 0b10 	vmov	d0, r0, r1
   1d918:	f01b fa5a 	bl	38dd0 <acos>
	angle_degree=angle *(180.0f/3.14159265f);						//get angle in degree
   1d91c:	a33a      	add	r3, pc, #232	; (adr r3, 1da08 <fall_detection+0x380>)
   1d91e:	e9d3 2300 	ldrd	r2, r3, [r3]
	angle=acos(num/sqrt(denom));
   1d922:	ed8d 0b20 	vstr	d0, [sp, #128]	; 0x80
	angle_degree=angle *(180.0f/3.14159265f);						//get angle in degree
   1d926:	e9dd 0120 	ldrd	r0, r1, [sp, #128]	; 0x80
   1d92a:	f7fe ff45 	bl	1c7b8 <__aeabi_dmul>
   1d92e:	f7ff f9fd 	bl	1cd2c <__aeabi_d2f>
   1d932:	9014      	str	r0, [sp, #80]	; 0x50
	return angle_degree;
   1d934:	9b14      	ldr	r3, [sp, #80]	; 0x50
		cur_angle = angle_analyse_fifo();
   1d936:	4e45      	ldr	r6, [pc, #276]	; (1da4c <fall_detection+0x3c4>)
			gyro_magn_square = pow(get_gyro_magn(gyro_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_gyro_magn(gyro_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
   1d938:	4f45      	ldr	r7, [pc, #276]	; (1da50 <fall_detection+0x3c8>)
		cur_angle = angle_analyse_fifo();
   1d93a:	6033      	str	r3, [r6, #0]
	for(i=0;i<ACC_GYRO_FIFO_BUF_LEN*2;i++)
   1d93c:	2300      	movs	r3, #0
			gyro_magn_square = pow(get_gyro_magn(gyro_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_gyro_magn(gyro_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
   1d93e:	f8df 811c 	ldr.w	r8, [pc, #284]	; 1da5c <fall_detection+0x3d4>
	volatile float gyro_magn_square = 0, max_gyro_magn_square = 0;
   1d942:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
   1d946:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
	for(i=0;i<ACC_GYRO_FIFO_BUF_LEN*2;i++)
   1d94a:	f8ad 300e 	strh.w	r3, [sp, #14]
   1d94e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   1d952:	2bc7      	cmp	r3, #199	; 0xc7
   1d954:	f240 829b 	bls.w	1de8e <fall_detection+0x806>
	return sqrt(max_gyro_magn_square);		//do once sqrt() to get gyroscope magnitude
   1d958:	9813      	ldr	r0, [sp, #76]	; 0x4c
   1d95a:	f7fe fed5 	bl	1c708 <__aeabi_f2d>
   1d95e:	ec41 0b10 	vmov	d0, r0, r1
   1d962:	f01b fa6f 	bl	38e44 <sqrt>
   1d966:	ec51 0b10 	vmov	r0, r1, d0
   1d96a:	f7ff f9df 	bl	1cd2c <__aeabi_d2f>
	volatile uint8_t i=0;
   1d96e:	2200      	movs	r2, #0
	low_angle_degree =    get_input_degree(current_angle, MEDIUM_ANGLE, 0, LOW_ANGLE, MEDIUM_ANGLE);
   1d970:	ed9f 2a38 	vldr	s4, [pc, #224]	; 1da54 <fall_detection+0x3cc>
		cur_max_gyro_magn = gyroscope_analyse_fifo();
   1d974:	4b38      	ldr	r3, [pc, #224]	; (1da58 <fall_detection+0x3d0>)
	volatile uint8_t i=0;
   1d976:	f88d 200b 	strb.w	r2, [sp, #11]
		cur_max_gyro_magn = gyroscope_analyse_fifo();
   1d97a:	6018      	str	r0, [r3, #0]
		cur_fuzzy_output = fuzzy_analyse(cur_angle, cur_max_gyro_magn);
   1d97c:	6833      	ldr	r3, [r6, #0]
	volatile float sum_firestrenths = 0;
   1d97e:	f8cd a020 	str.w	sl, [sp, #32]
	volatile float output_value=0;
   1d982:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
	volatile float low_angle_degree=0, medium_angle_degree=0, high_angle_degree=0;
   1d986:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
   1d98a:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
   1d98e:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
	volatile float low_gyro_magnitude_degree=0, medium_gyro_magnitude_degree=0, high_gyro_magnitude_degree=0;
   1d992:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
   1d996:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
   1d99a:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
	volatile float current_angle = angle;  // should compute this value continously from sensor
   1d99e:	9310      	str	r3, [sp, #64]	; 0x40
	volatile float current_max_gyro_magn = max_gyro_magn;
   1d9a0:	9011      	str	r0, [sp, #68]	; 0x44
	low_angle_degree =    get_input_degree(current_angle, MEDIUM_ANGLE, 0, LOW_ANGLE, MEDIUM_ANGLE);
   1d9a2:	eef0 0a42 	vmov.f32	s1, s4
   1d9a6:	eef2 1a0e 	vmov.f32	s3, #46	; 0x41700000  15.0
   1d9aa:	ed9f 1a2f 	vldr	s2, [pc, #188]	; 1da68 <fall_detection+0x3e0>
   1d9ae:	ed9d 0a10 	vldr	s0, [sp, #64]	; 0x40
   1d9b2:	f01d f912 	bl	3abda <get_input_degree>
	medium_angle_degree = get_input_degree(current_angle, LOW_ANGLE, MEDIUM_ANGLE, HIGH_ANGLE, HIGH_ANGLE);
   1d9b6:	ed9f 2a2a 	vldr	s4, [pc, #168]	; 1da60 <fall_detection+0x3d8>
	low_angle_degree =    get_input_degree(current_angle, MEDIUM_ANGLE, 0, LOW_ANGLE, MEDIUM_ANGLE);
   1d9ba:	ed8d 0a0a 	vstr	s0, [sp, #40]	; 0x28
	medium_angle_degree = get_input_degree(current_angle, LOW_ANGLE, MEDIUM_ANGLE, HIGH_ANGLE, HIGH_ANGLE);
   1d9be:	eef0 1a42 	vmov.f32	s3, s4
   1d9c2:	ed9f 1a24 	vldr	s2, [pc, #144]	; 1da54 <fall_detection+0x3cc>
   1d9c6:	eef2 0a0e 	vmov.f32	s1, #46	; 0x41700000  15.0
   1d9ca:	ed9d 0a10 	vldr	s0, [sp, #64]	; 0x40
   1d9ce:	f01d f904 	bl	3abda <get_input_degree>
	high_angle_degree =   get_input_degree(current_angle, MEDIUM_ANGLE, HIGH_ANGLE, 0, HIGH_ANGLE);
   1d9d2:	ed9f 2a23 	vldr	s4, [pc, #140]	; 1da60 <fall_detection+0x3d8>
	medium_angle_degree = get_input_degree(current_angle, LOW_ANGLE, MEDIUM_ANGLE, HIGH_ANGLE, HIGH_ANGLE);
   1d9d6:	ed8d 0a0b 	vstr	s0, [sp, #44]	; 0x2c
	high_angle_degree =   get_input_degree(current_angle, MEDIUM_ANGLE, HIGH_ANGLE, 0, HIGH_ANGLE);
   1d9da:	eeb0 1a42 	vmov.f32	s2, s4
   1d9de:	eddf 1a22 	vldr	s3, [pc, #136]	; 1da68 <fall_detection+0x3e0>
   1d9e2:	eddf 0a1c 	vldr	s1, [pc, #112]	; 1da54 <fall_detection+0x3cc>
   1d9e6:	ed9d 0a10 	vldr	s0, [sp, #64]	; 0x40
   1d9ea:	f01d f8f6 	bl	3abda <get_input_degree>
	low_gyro_magnitude_degree =    get_input_degree(current_max_gyro_magn, MEDIUM_GYRO_MAGNITUDE, 0, LOW_GYRO_MAGNITUDE, MEDIUM_GYRO_MAGNITUDE);
   1d9ee:	ed9f 2a1f 	vldr	s4, [pc, #124]	; 1da6c <fall_detection+0x3e4>
	high_angle_degree =   get_input_degree(current_angle, MEDIUM_ANGLE, HIGH_ANGLE, 0, HIGH_ANGLE);
   1d9f2:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
	low_gyro_magnitude_degree =    get_input_degree(current_max_gyro_magn, MEDIUM_GYRO_MAGNITUDE, 0, LOW_GYRO_MAGNITUDE, MEDIUM_GYRO_MAGNITUDE);
   1d9f6:	eef0 0a42 	vmov.f32	s1, s4
   1d9fa:	e039      	b.n	1da70 <fall_detection+0x3e8>
   1d9fc:	f3af 8000 	nop.w
   1da00:	00000000 	.word	0x00000000
   1da04:	40000000 	.word	0x40000000
   1da08:	00000000 	.word	0x00000000
   1da0c:	404ca5dc 	.word	0x404ca5dc
   1da10:	0003f964 	.word	0x0003f964
   1da14:	0003f8d4 	.word	0x0003f8d4
   1da18:	2002c31c 	.word	0x2002c31c
   1da1c:	000415c2 	.word	0x000415c2
   1da20:	000415d3 	.word	0x000415d3
   1da24:	2002c317 	.word	0x2002c317
   1da28:	20020db0 	.word	0x20020db0
   1da2c:	20021580 	.word	0x20021580
   1da30:	20020dac 	.word	0x20020dac
   1da34:	41a00000 	.word	0x41a00000
   1da38:	20020f40 	.word	0x20020f40
   1da3c:	20021710 	.word	0x20021710
   1da40:	20021ee0 	.word	0x20021ee0
   1da44:	42c80000 	.word	0x42c80000
   1da48:	20021d50 	.word	0x20021d50
   1da4c:	200229e8 	.word	0x200229e8
   1da50:	20023690 	.word	0x20023690
   1da54:	42200000 	.word	0x42200000
   1da58:	200229f0 	.word	0x200229f0
   1da5c:	20023e60 	.word	0x20023e60
   1da60:	42a00000 	.word	0x42a00000
   1da64:	43960000 	.word	0x43960000
   1da68:	00000000 	.word	0x00000000
   1da6c:	43340000 	.word	0x43340000
   1da70:	ed5f 1a05 	vldr	s3, [pc, #-20]	; 1da60 <fall_detection+0x3d8>
   1da74:	ed1f 1a04 	vldr	s2, [pc, #-16]	; 1da68 <fall_detection+0x3e0>
   1da78:	ed9d 0a11 	vldr	s0, [sp, #68]	; 0x44
   1da7c:	f01d f8ad 	bl	3abda <get_input_degree>
	medium_gyro_magnitude_degree = get_input_degree(current_max_gyro_magn, LOW_GYRO_MAGNITUDE, MEDIUM_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE);
   1da80:	ed1f 2a08 	vldr	s4, [pc, #-32]	; 1da64 <fall_detection+0x3dc>
	low_gyro_magnitude_degree =    get_input_degree(current_max_gyro_magn, MEDIUM_GYRO_MAGNITUDE, 0, LOW_GYRO_MAGNITUDE, MEDIUM_GYRO_MAGNITUDE);
   1da84:	ed8d 0a0d 	vstr	s0, [sp, #52]	; 0x34
	medium_gyro_magnitude_degree = get_input_degree(current_max_gyro_magn, LOW_GYRO_MAGNITUDE, MEDIUM_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE);
   1da88:	eef0 1a42 	vmov.f32	s3, s4
   1da8c:	ed1f 1a09 	vldr	s2, [pc, #-36]	; 1da6c <fall_detection+0x3e4>
   1da90:	ed5f 0a0d 	vldr	s1, [pc, #-52]	; 1da60 <fall_detection+0x3d8>
   1da94:	ed9d 0a11 	vldr	s0, [sp, #68]	; 0x44
   1da98:	f01d f89f 	bl	3abda <get_input_degree>
	high_gyro_magnitude_degree =   get_input_degree(current_max_gyro_magn, MEDIUM_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE, 0, HIGH_GYRO_MAGNITUDE);
   1da9c:	ed1f 2a0f 	vldr	s4, [pc, #-60]	; 1da64 <fall_detection+0x3dc>
	medium_gyro_magnitude_degree = get_input_degree(current_max_gyro_magn, LOW_GYRO_MAGNITUDE, MEDIUM_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE);
   1daa0:	ed8d 0a0e 	vstr	s0, [sp, #56]	; 0x38
	high_gyro_magnitude_degree =   get_input_degree(current_max_gyro_magn, MEDIUM_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE, 0, HIGH_GYRO_MAGNITUDE);
   1daa4:	ed9d 0a11 	vldr	s0, [sp, #68]	; 0x44
   1daa8:	ed5f 1a11 	vldr	s3, [pc, #-68]	; 1da68 <fall_detection+0x3e0>
   1daac:	eeb0 1a42 	vmov.f32	s2, s4
   1dab0:	ed5f 0a12 	vldr	s1, [pc, #-72]	; 1da6c <fall_detection+0x3e4>
   1dab4:	f01d f891 	bl	3abda <get_input_degree>
   1dab8:	ed8d 0a0f 	vstr	s0, [sp, #60]	; 0x3c
	fire_strength[0] = min(low_angle_degree   , low_gyro_magnitude_degree);
   1dabc:	ed9d 7a0a 	vldr	s14, [sp, #40]	; 0x28
   1dac0:	eddd 7a0d 	vldr	s15, [sp, #52]	; 0x34
   1dac4:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1dac8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1dacc:	bf4c      	ite	mi
   1dace:	9b0a      	ldrmi	r3, [sp, #40]	; 0x28
   1dad0:	9b0d      	ldrpl	r3, [sp, #52]	; 0x34
		output_value += fire_strength[i] * get_output_from_memship(suspicion_rules[i][2]);
   1dad2:	4acb      	ldr	r2, [pc, #812]	; (1de00 <fall_detection+0x778>)
	fire_strength[0] = min(low_angle_degree   , low_gyro_magnitude_degree);
   1dad4:	9323      	str	r3, [sp, #140]	; 0x8c
	fire_strength[1] = min(low_angle_degree   , medium_gyro_magnitude_degree);
   1dad6:	ed9d 7a0a 	vldr	s14, [sp, #40]	; 0x28
   1dada:	eddd 7a0e 	vldr	s15, [sp, #56]	; 0x38
   1dade:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1dae2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1dae6:	bf4c      	ite	mi
   1dae8:	9b0a      	ldrmi	r3, [sp, #40]	; 0x28
   1daea:	9b0e      	ldrpl	r3, [sp, #56]	; 0x38
   1daec:	9324      	str	r3, [sp, #144]	; 0x90
	fire_strength[2] = min(low_angle_degree   , high_gyro_magnitude_degree);
   1daee:	ed9d 7a0a 	vldr	s14, [sp, #40]	; 0x28
   1daf2:	eddd 7a0f 	vldr	s15, [sp, #60]	; 0x3c
   1daf6:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1dafa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1dafe:	bf4c      	ite	mi
   1db00:	9b0a      	ldrmi	r3, [sp, #40]	; 0x28
   1db02:	9b0f      	ldrpl	r3, [sp, #60]	; 0x3c
   1db04:	9325      	str	r3, [sp, #148]	; 0x94
	fire_strength[3] = min(medium_angle_degree, low_gyro_magnitude_degree);
   1db06:	ed9d 7a0b 	vldr	s14, [sp, #44]	; 0x2c
   1db0a:	eddd 7a0d 	vldr	s15, [sp, #52]	; 0x34
   1db0e:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1db12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1db16:	bf4c      	ite	mi
   1db18:	9b0b      	ldrmi	r3, [sp, #44]	; 0x2c
   1db1a:	9b0d      	ldrpl	r3, [sp, #52]	; 0x34
   1db1c:	9326      	str	r3, [sp, #152]	; 0x98
	fire_strength[4] = min(medium_angle_degree, medium_gyro_magnitude_degree);
   1db1e:	ed9d 7a0b 	vldr	s14, [sp, #44]	; 0x2c
   1db22:	eddd 7a0e 	vldr	s15, [sp, #56]	; 0x38
   1db26:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1db2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1db2e:	bf4c      	ite	mi
   1db30:	9b0b      	ldrmi	r3, [sp, #44]	; 0x2c
   1db32:	9b0e      	ldrpl	r3, [sp, #56]	; 0x38
   1db34:	9327      	str	r3, [sp, #156]	; 0x9c
	fire_strength[5] = min(medium_angle_degree, high_gyro_magnitude_degree);
   1db36:	ed9d 7a0b 	vldr	s14, [sp, #44]	; 0x2c
   1db3a:	eddd 7a0f 	vldr	s15, [sp, #60]	; 0x3c
   1db3e:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1db42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1db46:	bf4c      	ite	mi
   1db48:	9b0b      	ldrmi	r3, [sp, #44]	; 0x2c
   1db4a:	9b0f      	ldrpl	r3, [sp, #60]	; 0x3c
   1db4c:	9328      	str	r3, [sp, #160]	; 0xa0
	fire_strength[6] = min(high_angle_degree  , low_gyro_magnitude_degree);
   1db4e:	ed9d 7a0c 	vldr	s14, [sp, #48]	; 0x30
   1db52:	eddd 7a0d 	vldr	s15, [sp, #52]	; 0x34
   1db56:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1db5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1db5e:	bf4c      	ite	mi
   1db60:	9b0c      	ldrmi	r3, [sp, #48]	; 0x30
   1db62:	9b0d      	ldrpl	r3, [sp, #52]	; 0x34
   1db64:	9329      	str	r3, [sp, #164]	; 0xa4
	fire_strength[7] = min(high_angle_degree  , medium_gyro_magnitude_degree);
   1db66:	ed9d 7a0c 	vldr	s14, [sp, #48]	; 0x30
   1db6a:	eddd 7a0e 	vldr	s15, [sp, #56]	; 0x38
   1db6e:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1db72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1db76:	bf4c      	ite	mi
   1db78:	9b0c      	ldrmi	r3, [sp, #48]	; 0x30
   1db7a:	9b0e      	ldrpl	r3, [sp, #56]	; 0x38
   1db7c:	932a      	str	r3, [sp, #168]	; 0xa8
	fire_strength[8] = min(high_angle_degree  , high_gyro_magnitude_degree);
   1db7e:	ed9d 7a0c 	vldr	s14, [sp, #48]	; 0x30
   1db82:	eddd 7a0f 	vldr	s15, [sp, #60]	; 0x3c
   1db86:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1db8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1db8e:	bf4c      	ite	mi
   1db90:	9b0c      	ldrmi	r3, [sp, #48]	; 0x30
   1db92:	9b0f      	ldrpl	r3, [sp, #60]	; 0x3c
   1db94:	932b      	str	r3, [sp, #172]	; 0xac
	for (i = 0; i < 9; i++)
   1db96:	2300      	movs	r3, #0
   1db98:	f88d 300b 	strb.w	r3, [sp, #11]
   1db9c:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1dba0:	2b08      	cmp	r3, #8
   1dba2:	f240 81d1 	bls.w	1df48 <fall_detection+0x8c0>
	output_value /= sum_firestrenths;
   1dba6:	ed9d 7a08 	vldr	s14, [sp, #32]
   1dbaa:	eddd 6a09 	vldr	s13, [sp, #36]	; 0x24
   1dbae:	eec6 7a87 	vdiv.f32	s15, s13, s14
   1dbb2:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24
	return output_value;
   1dbb6:	9b09      	ldr	r3, [sp, #36]	; 0x24
		cur_fuzzy_output = fuzzy_analyse(cur_angle, cur_max_gyro_magn);
   1dbb8:	4e92      	ldr	r6, [pc, #584]	; (1de04 <fall_detection+0x77c>)
	memset(verify_acc_magn,0x00,VERIFY_DATA_BUF_LEN);
   1dbba:	2264      	movs	r2, #100	; 0x64
   1dbbc:	2100      	movs	r1, #0
   1dbbe:	4892      	ldr	r0, [pc, #584]	; (1de08 <fall_detection+0x780>)
	volatile float std_deviation = 0, variance=0,average = 0;
   1dbc0:	f8cd a014 	str.w	sl, [sp, #20]
		cur_fuzzy_output = fuzzy_analyse(cur_angle, cur_max_gyro_magn);
   1dbc4:	6033      	str	r3, [r6, #0]
	volatile float std_deviation = 0, variance=0,average = 0;
   1dbc6:	f8cd a018 	str.w	sl, [sp, #24]
   1dbca:	f8cd a01c 	str.w	sl, [sp, #28]
	memset(verify_acc_magn,0x00,VERIFY_DATA_BUF_LEN);
   1dbce:	f020 fe5d 	bl	3e88c <memset>
	for(i=0;i<VERIFY_DATA_BUF_LEN;i++)
   1dbd2:	2300      	movs	r3, #0
		verify_acc_magn[i] = sqrt(pow(get_acc_magn(acc_x_vrif_buffer_1[i]),2)+ pow(get_acc_magn(acc_y_vrif_buffer_1[i]),2) + pow(get_acc_magn(acc_z_vrif_buffer_1[i]),2));
   1dbd4:	ed9f 9b88 	vldr	d9, [pc, #544]	; 1ddf8 <fall_detection+0x770>
   1dbd8:	4f8c      	ldr	r7, [pc, #560]	; (1de0c <fall_detection+0x784>)
   1dbda:	f8df a258 	ldr.w	sl, [pc, #600]	; 1de34 <fall_detection+0x7ac>
	for(i=0;i<VERIFY_DATA_BUF_LEN;i++)
   1dbde:	f8ad 300c 	strh.w	r3, [sp, #12]
   1dbe2:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   1dbe6:	2b63      	cmp	r3, #99	; 0x63
   1dbe8:	f240 81e6 	bls.w	1dfb8 <fall_detection+0x930>
	average /= (float)VERIFY_DATA_BUF_LEN;
   1dbec:	ed9d 7a07 	vldr	s14, [sp, #28]
	for(i=0;i<VERIFY_DATA_BUF_LEN;i++)
   1dbf0:	2300      	movs	r3, #0
	average /= (float)VERIFY_DATA_BUF_LEN;
   1dbf2:	eec7 7a08 	vdiv.f32	s15, s14, s16
		variance += pow((verify_acc_magn[i]-average),2);
   1dbf6:	ed9f 9b80 	vldr	d9, [pc, #512]	; 1ddf8 <fall_detection+0x770>
   1dbfa:	4f83      	ldr	r7, [pc, #524]	; (1de08 <fall_detection+0x780>)
	average /= (float)VERIFY_DATA_BUF_LEN;
   1dbfc:	edcd 7a07 	vstr	s15, [sp, #28]
	for(i=0;i<VERIFY_DATA_BUF_LEN;i++)
   1dc00:	f8ad 300c 	strh.w	r3, [sp, #12]
   1dc04:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   1dc08:	2b63      	cmp	r3, #99	; 0x63
   1dc0a:	f240 8236 	bls.w	1e07a <fall_detection+0x9f2>
	std_deviation = sqrt(variance/(float)(VERIFY_DATA_BUF_LEN));
   1dc0e:	eddd 7a06 	vldr	s15, [sp, #24]
   1dc12:	eec7 7a88 	vdiv.f32	s15, s15, s16
   1dc16:	ee17 0a90 	vmov	r0, s15
   1dc1a:	f7fe fd75 	bl	1c708 <__aeabi_f2d>
   1dc1e:	ec41 0b10 	vmov	d0, r0, r1
   1dc22:	f01b f90f 	bl	38e44 <sqrt>
   1dc26:	ec51 0b10 	vmov	r0, r1, d0
   1dc2a:	f7ff f87f 	bl	1cd2c <__aeabi_d2f>
		LCD_ShowString(20,120,tmpbuf);
		sprintf(tmpbuf, "Fuzzy Output is: %f", cur_fuzzy_output);
		LCD_ShowString(20,140,tmpbuf);
		*/

		if(cur_fuzzy_output > FUZZY_OUT_THRES_DEF)
   1dc2e:	edd6 6a00 	vldr	s13, [r6]
   1dc32:	ed9f 7a77 	vldr	s14, [pc, #476]	; 1de10 <fall_detection+0x788>
   1dc36:	eef4 6ac7 	vcmpe.f32	s13, s14
	std_deviation = sqrt(variance/(float)(VERIFY_DATA_BUF_LEN));
   1dc3a:	9005      	str	r0, [sp, #20]
	return std_deviation;
   1dc3c:	eddd 7a05 	vldr	s15, [sp, #20]
		if(cur_fuzzy_output > FUZZY_OUT_THRES_DEF)
   1dc40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		std_devi = fall_verification_fifo_skip();
   1dc44:	4b73      	ldr	r3, [pc, #460]	; (1de14 <fall_detection+0x78c>)
   1dc46:	edc3 7a00 	vstr	s15, [r3]
		if(cur_fuzzy_output > FUZZY_OUT_THRES_DEF)
   1dc4a:	4b73      	ldr	r3, [pc, #460]	; (1de18 <fall_detection+0x790>)
   1dc4c:	f340 8240 	ble.w	1e0d0 <fall_detection+0xa48>
		{
			if(std_devi < STD_VARIANCE_THRES_DEF)
   1dc50:	ed9f 7a72 	vldr	s14, [pc, #456]	; 1de1c <fall_detection+0x794>
   1dc54:	eef4 7ac7 	vcmpe.f32	s15, s14
   1dc58:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1dc5c:	f140 8238 	bpl.w	1e0d0 <fall_detection+0xa48>
			{
				fall_result = true;
   1dc60:	2201      	movs	r2, #1
				fall_result = false; //std not satisfied
			}
		}
		else
		{
			fall_result = false; //fuzzy output not satisfied
   1dc62:	701a      	strb	r2, [r3, #0]
		}
		
		curr_vrif_buff_flag = false;
   1dc64:	2300      	movs	r3, #0
   1dc66:	702b      	strb	r3, [r5, #0]
		sensor_init(); //resets the algorithm, will work continuosly on every tap
   1dc68:	f006 f950 	bl	23f0c <sensor_init>
		LOG_INF("fall detecting 3");
   1dc6c:	2303      	movs	r3, #3
   1dc6e:	f04f 0000 	mov.w	r0, #0
   1dc72:	496b      	ldr	r1, [pc, #428]	; (1de20 <fall_detection+0x798>)
   1dc74:	f363 0007 	bfi	r0, r3, #0, #8
   1dc78:	f364 108f 	bfi	r0, r4, #6, #10
	} 
}
   1dc7c:	b02c      	add	sp, #176	; 0xb0
   1dc7e:	ecbd 8b06 	vpop	{d8-d10}
   1dc82:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		LOG_INF("fall detecting 3");
   1dc86:	f01e bda8 	b.w	3c7da <log_string_sync>
		if(i<ACC_GYRO_FIFO_BUF_LEN)
   1dc8a:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   1dc8e:	2b63      	cmp	r3, #99	; 0x63
   1dc90:	d854      	bhi.n	1dd3c <fall_detection+0x6b4>
			acc_magn_square = pow(get_acc_magn(acc_x_hist_buffer[i]),2)+pow(get_acc_magn(acc_y_hist_buffer[i]),2)+pow(get_acc_magn(acc_z_hist_buffer[i]),2);
   1dc92:	f8bd 2012 	ldrh.w	r2, [sp, #18]
   1dc96:	4b63      	ldr	r3, [pc, #396]	; (1de24 <fall_detection+0x79c>)
   1dc98:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   1dc9c:	6818      	ldr	r0, [r3, #0]
   1dc9e:	f7fe fd33 	bl	1c708 <__aeabi_f2d>
   1dca2:	eeb0 1a48 	vmov.f32	s2, s16
   1dca6:	eef0 1a68 	vmov.f32	s3, s17
   1dcaa:	ec41 0b10 	vmov	d0, r0, r1
   1dcae:	f000 fbbf 	bl	1e430 <pow>
   1dcb2:	f8bd 2012 	ldrh.w	r2, [sp, #18]
   1dcb6:	4b5c      	ldr	r3, [pc, #368]	; (1de28 <fall_detection+0x7a0>)
   1dcb8:	ec59 8b10 	vmov	r8, r9, d0
   1dcbc:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   1dcc0:	6818      	ldr	r0, [r3, #0]
   1dcc2:	f7fe fd21 	bl	1c708 <__aeabi_f2d>
   1dcc6:	eeb0 1a48 	vmov.f32	s2, s16
   1dcca:	eef0 1a68 	vmov.f32	s3, s17
   1dcce:	ec41 0b10 	vmov	d0, r0, r1
   1dcd2:	f000 fbad 	bl	1e430 <pow>
   1dcd6:	4640      	mov	r0, r8
   1dcd8:	ec53 2b10 	vmov	r2, r3, d0
   1dcdc:	4649      	mov	r1, r9
   1dcde:	f7fe fbb5 	bl	1c44c <__adddf3>
   1dce2:	4680      	mov	r8, r0
   1dce4:	4689      	mov	r9, r1
   1dce6:	f8bd 2012 	ldrh.w	r2, [sp, #18]
   1dcea:	4b50      	ldr	r3, [pc, #320]	; (1de2c <fall_detection+0x7a4>)
			acc_magn_square = pow(get_acc_magn(acc_x_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_acc_magn(acc_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_acc_magn(acc_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
   1dcec:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   1dcf0:	6818      	ldr	r0, [r3, #0]
   1dcf2:	f7fe fd09 	bl	1c708 <__aeabi_f2d>
   1dcf6:	eeb0 1a48 	vmov.f32	s2, s16
   1dcfa:	eef0 1a68 	vmov.f32	s3, s17
   1dcfe:	ec41 0b10 	vmov	d0, r0, r1
   1dd02:	f000 fb95 	bl	1e430 <pow>
   1dd06:	4640      	mov	r0, r8
   1dd08:	ec53 2b10 	vmov	r2, r3, d0
   1dd0c:	4649      	mov	r1, r9
   1dd0e:	f7fe fb9d 	bl	1c44c <__adddf3>
   1dd12:	f7ff f80b 	bl	1cd2c <__aeabi_d2f>
   1dd16:	901e      	str	r0, [sp, #120]	; 0x78
		if(acc_magn_square > max_acc_magn_square) max_acc_magn_square = acc_magn_square;	//get the maximum acc magnitude square
   1dd18:	ed9d 7a1e 	vldr	s14, [sp, #120]	; 0x78
   1dd1c:	eddd 7a1f 	vldr	s15, [sp, #124]	; 0x7c
   1dd20:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1dd24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1dd28:	bfc4      	itt	gt
   1dd2a:	9b1e      	ldrgt	r3, [sp, #120]	; 0x78
   1dd2c:	931f      	strgt	r3, [sp, #124]	; 0x7c
	for(i=0;i<ACC_GYRO_FIFO_BUF_LEN*2;i++)
   1dd2e:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   1dd32:	3301      	adds	r3, #1
   1dd34:	b29b      	uxth	r3, r3
   1dd36:	f8ad 3012 	strh.w	r3, [sp, #18]
   1dd3a:	e4de      	b.n	1d6fa <fall_detection+0x72>
			acc_magn_square = pow(get_acc_magn(acc_x_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_acc_magn(acc_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_acc_magn(acc_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
   1dd3c:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   1dd40:	3b64      	subs	r3, #100	; 0x64
   1dd42:	eb06 0383 	add.w	r3, r6, r3, lsl #2
   1dd46:	6818      	ldr	r0, [r3, #0]
   1dd48:	f7fe fcde 	bl	1c708 <__aeabi_f2d>
   1dd4c:	eeb0 1a48 	vmov.f32	s2, s16
   1dd50:	eef0 1a68 	vmov.f32	s3, s17
   1dd54:	ec41 0b10 	vmov	d0, r0, r1
   1dd58:	f000 fb6a 	bl	1e430 <pow>
   1dd5c:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   1dd60:	ec59 8b10 	vmov	r8, r9, d0
   1dd64:	3b64      	subs	r3, #100	; 0x64
   1dd66:	eb07 0383 	add.w	r3, r7, r3, lsl #2
   1dd6a:	6818      	ldr	r0, [r3, #0]
   1dd6c:	f7fe fccc 	bl	1c708 <__aeabi_f2d>
   1dd70:	eeb0 1a48 	vmov.f32	s2, s16
   1dd74:	eef0 1a68 	vmov.f32	s3, s17
   1dd78:	ec41 0b10 	vmov	d0, r0, r1
   1dd7c:	f000 fb58 	bl	1e430 <pow>
   1dd80:	4640      	mov	r0, r8
   1dd82:	ec53 2b10 	vmov	r2, r3, d0
   1dd86:	4649      	mov	r1, r9
   1dd88:	f7fe fb60 	bl	1c44c <__adddf3>
   1dd8c:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   1dd90:	4680      	mov	r8, r0
   1dd92:	f1a3 0264 	sub.w	r2, r3, #100	; 0x64
   1dd96:	4689      	mov	r9, r1
   1dd98:	4b25      	ldr	r3, [pc, #148]	; (1de30 <fall_detection+0x7a8>)
   1dd9a:	e7a7      	b.n	1dcec <fall_detection+0x664>
		start_avg_accel_x += acc_x_hist_buffer[i];
   1dd9c:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   1dda0:	eddd 7a16 	vldr	s15, [sp, #88]	; 0x58
   1dda4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   1dda8:	ed93 7a00 	vldr	s14, [r3]
   1ddac:	ee77 7a87 	vadd.f32	s15, s15, s14
   1ddb0:	edcd 7a16 	vstr	s15, [sp, #88]	; 0x58
		start_avg_accel_y += acc_y_hist_buffer[i];
   1ddb4:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   1ddb8:	eddd 7a17 	vldr	s15, [sp, #92]	; 0x5c
   1ddbc:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   1ddc0:	ed93 7a00 	vldr	s14, [r3]
   1ddc4:	ee77 7a87 	vadd.f32	s15, s15, s14
   1ddc8:	edcd 7a17 	vstr	s15, [sp, #92]	; 0x5c
		start_avg_accel_z += acc_z_hist_buffer[i];
   1ddcc:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   1ddd0:	eddd 7a18 	vldr	s15, [sp, #96]	; 0x60
   1ddd4:	eb00 0383 	add.w	r3, r0, r3, lsl #2
   1ddd8:	ed93 7a00 	vldr	s14, [r3]
   1dddc:	ee77 7a87 	vadd.f32	s15, s15, s14
   1dde0:	edcd 7a18 	vstr	s15, [sp, #96]	; 0x60
	for(i = 0; i < avg_index; i++ )
   1dde4:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   1dde8:	3301      	adds	r3, #1
   1ddea:	b29b      	uxth	r3, r3
   1ddec:	f8ad 3010 	strh.w	r3, [sp, #16]
   1ddf0:	e4a9      	b.n	1d746 <fall_detection+0xbe>
   1ddf2:	bf00      	nop
   1ddf4:	f3af 8000 	nop.w
   1ddf8:	00000000 	.word	0x00000000
   1ddfc:	40000000 	.word	0x40000000
   1de00:	200378e5 	.word	0x200378e5
   1de04:	200229ec 	.word	0x200229ec
   1de08:	20024654 	.word	0x20024654
   1de0c:	200213f0 	.word	0x200213f0
   1de10:	42340000 	.word	0x42340000
   1de14:	20024650 	.word	0x20024650
   1de18:	2002c318 	.word	0x2002c318
   1de1c:	3e051eb8 	.word	0x3e051eb8
   1de20:	000415e4 	.word	0x000415e4
   1de24:	20020f40 	.word	0x20020f40
   1de28:	20021710 	.word	0x20021710
   1de2c:	20021ee0 	.word	0x20021ee0
   1de30:	20021d50 	.word	0x20021d50
   1de34:	20021bc0 	.word	0x20021bc0
		end_avg_accel_x += acc_x_cur_buffer[i];
   1de38:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   1de3c:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
   1de40:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   1de44:	ed93 7a00 	vldr	s14, [r3]
   1de48:	ee77 7a87 	vadd.f32	s15, s15, s14
   1de4c:	edcd 7a19 	vstr	s15, [sp, #100]	; 0x64
		end_avg_accel_y += acc_y_cur_buffer[i];
   1de50:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   1de54:	eddd 7a1a 	vldr	s15, [sp, #104]	; 0x68
   1de58:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   1de5c:	ed93 7a00 	vldr	s14, [r3]
   1de60:	ee77 7a87 	vadd.f32	s15, s15, s14
   1de64:	edcd 7a1a 	vstr	s15, [sp, #104]	; 0x68
		end_avg_accel_z += acc_z_cur_buffer[i];
   1de68:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   1de6c:	eddd 7a1b 	vldr	s15, [sp, #108]	; 0x6c
   1de70:	eb00 0383 	add.w	r3, r0, r3, lsl #2
   1de74:	ed93 7a00 	vldr	s14, [r3]
   1de78:	ee77 7a87 	vadd.f32	s15, s15, s14
   1de7c:	edcd 7a1b 	vstr	s15, [sp, #108]	; 0x6c
	for(i = ACC_GYRO_FIFO_BUF_LEN-avg_index; i < ACC_GYRO_FIFO_BUF_LEN; i++)
   1de80:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   1de84:	3301      	adds	r3, #1
   1de86:	b29b      	uxth	r3, r3
   1de88:	f8ad 3010 	strh.w	r3, [sp, #16]
   1de8c:	e497      	b.n	1d7be <fall_detection+0x136>
		if(i < ACC_GYRO_FIFO_BUF_LEN)
   1de8e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   1de92:	2b63      	cmp	r3, #99	; 0x63
   1de94:	d83e      	bhi.n	1df14 <fall_detection+0x88c>
			gyro_magn_square = pow(get_gyro_magn(gyro_y_hist_buffer[i]),2)+pow(get_gyro_magn(gyro_z_hist_buffer[i]),2);
   1de96:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   1de9a:	4b91      	ldr	r3, [pc, #580]	; (1e0e0 <fall_detection+0xa58>)
   1de9c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   1dea0:	6818      	ldr	r0, [r3, #0]
   1dea2:	f7fe fc31 	bl	1c708 <__aeabi_f2d>
   1dea6:	eeb0 1a49 	vmov.f32	s2, s18
   1deaa:	eef0 1a69 	vmov.f32	s3, s19
   1deae:	ec41 0b10 	vmov	d0, r0, r1
   1deb2:	f000 fabd 	bl	1e430 <pow>
   1deb6:	eeb0 aa40 	vmov.f32	s20, s0
   1deba:	eef0 aa60 	vmov.f32	s21, s1
   1debe:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   1dec2:	4b88      	ldr	r3, [pc, #544]	; (1e0e4 <fall_detection+0xa5c>)
   1dec4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
			gyro_magn_square = pow(get_gyro_magn(gyro_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_gyro_magn(gyro_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
   1dec8:	6818      	ldr	r0, [r3, #0]
   1deca:	f7fe fc1d 	bl	1c708 <__aeabi_f2d>
   1dece:	eeb0 1a49 	vmov.f32	s2, s18
   1ded2:	eef0 1a69 	vmov.f32	s3, s19
   1ded6:	ec41 0b10 	vmov	d0, r0, r1
   1deda:	f000 faa9 	bl	1e430 <pow>
   1dede:	ec51 0b1a 	vmov	r0, r1, d10
   1dee2:	ec53 2b10 	vmov	r2, r3, d0
   1dee6:	f7fe fab1 	bl	1c44c <__adddf3>
   1deea:	f7fe ff1f 	bl	1cd2c <__aeabi_d2f>
   1deee:	9012      	str	r0, [sp, #72]	; 0x48
		if(gyro_magn_square > max_gyro_magn_square) max_gyro_magn_square = gyro_magn_square;	//get the maximum gyroscope magnitude square
   1def0:	ed9d 7a12 	vldr	s14, [sp, #72]	; 0x48
   1def4:	eddd 7a13 	vldr	s15, [sp, #76]	; 0x4c
   1def8:	eeb4 7ae7 	vcmpe.f32	s14, s15
   1defc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1df00:	bfc4      	itt	gt
   1df02:	9b12      	ldrgt	r3, [sp, #72]	; 0x48
   1df04:	9313      	strgt	r3, [sp, #76]	; 0x4c
	for(i=0;i<ACC_GYRO_FIFO_BUF_LEN*2;i++)
   1df06:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   1df0a:	3301      	adds	r3, #1
   1df0c:	b29b      	uxth	r3, r3
   1df0e:	f8ad 300e 	strh.w	r3, [sp, #14]
   1df12:	e51c      	b.n	1d94e <fall_detection+0x2c6>
			gyro_magn_square = pow(get_gyro_magn(gyro_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_gyro_magn(gyro_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
   1df14:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   1df18:	3b64      	subs	r3, #100	; 0x64
   1df1a:	eb07 0383 	add.w	r3, r7, r3, lsl #2
   1df1e:	6818      	ldr	r0, [r3, #0]
   1df20:	f7fe fbf2 	bl	1c708 <__aeabi_f2d>
   1df24:	eeb0 1a49 	vmov.f32	s2, s18
   1df28:	eef0 1a69 	vmov.f32	s3, s19
   1df2c:	ec41 0b10 	vmov	d0, r0, r1
   1df30:	f000 fa7e 	bl	1e430 <pow>
   1df34:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   1df38:	eeb0 aa40 	vmov.f32	s20, s0
   1df3c:	eef0 aa60 	vmov.f32	s21, s1
   1df40:	3b64      	subs	r3, #100	; 0x64
   1df42:	eb08 0383 	add.w	r3, r8, r3, lsl #2
   1df46:	e7bf      	b.n	1dec8 <fall_detection+0x840>
		output_value += fire_strength[i] * get_output_from_memship(suspicion_rules[i][2]);
   1df48:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1df4c:	a92c      	add	r1, sp, #176	; 0xb0
   1df4e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   1df52:	ed53 6a09 	vldr	s13, [r3, #-36]	; 0xffffffdc
   1df56:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1df5a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1df5e:	4413      	add	r3, r2
   1df60:	789b      	ldrb	r3, [r3, #2]
   1df62:	b2db      	uxtb	r3, r3
	if(memship == LOW_MS)    
   1df64:	2b01      	cmp	r3, #1
   1df66:	d023      	beq.n	1dfb0 <fall_detection+0x928>
	else if(memship == MEDIUM_MS) 
   1df68:	2b02      	cmp	r3, #2
   1df6a:	d023      	beq.n	1dfb4 <fall_detection+0x92c>
		return 0;
   1df6c:	2b03      	cmp	r3, #3
   1df6e:	bf0c      	ite	eq
   1df70:	2332      	moveq	r3, #50	; 0x32
   1df72:	2300      	movne	r3, #0
		output_value += fire_strength[i] * get_output_from_memship(suspicion_rules[i][2]);
   1df74:	ee07 3a90 	vmov	s15, r3
   1df78:	ed9d 7a09 	vldr	s14, [sp, #36]	; 0x24
   1df7c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1df80:	ee07 7aa6 	vmla.f32	s14, s15, s13
   1df84:	ed8d 7a09 	vstr	s14, [sp, #36]	; 0x24
		sum_firestrenths += fire_strength[i];
   1df88:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1df8c:	a92c      	add	r1, sp, #176	; 0xb0
   1df8e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   1df92:	ed53 7a09 	vldr	s15, [r3, #-36]	; 0xffffffdc
   1df96:	ed9d 7a08 	vldr	s14, [sp, #32]
   1df9a:	ee77 7a87 	vadd.f32	s15, s15, s14
   1df9e:	edcd 7a08 	vstr	s15, [sp, #32]
	for (i = 0; i < 9; i++)
   1dfa2:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1dfa6:	3301      	adds	r3, #1
   1dfa8:	b2db      	uxtb	r3, r3
   1dfaa:	f88d 300b 	strb.w	r3, [sp, #11]
   1dfae:	e5f5      	b.n	1db9c <fall_detection+0x514>
		return WEIGHT_VALUE_10;
   1dfb0:	230a      	movs	r3, #10
   1dfb2:	e7df      	b.n	1df74 <fall_detection+0x8ec>
		return WEIGHT_VALUE_30;
   1dfb4:	231e      	movs	r3, #30
   1dfb6:	e7dd      	b.n	1df74 <fall_detection+0x8ec>
		verify_acc_magn[i] = sqrt(pow(get_acc_magn(acc_x_vrif_buffer_1[i]),2)+ pow(get_acc_magn(acc_y_vrif_buffer_1[i]),2) + pow(get_acc_magn(acc_z_vrif_buffer_1[i]),2));
   1dfb8:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   1dfbc:	eb07 0383 	add.w	r3, r7, r3, lsl #2
   1dfc0:	6818      	ldr	r0, [r3, #0]
   1dfc2:	f7fe fba1 	bl	1c708 <__aeabi_f2d>
   1dfc6:	eeb0 1a49 	vmov.f32	s2, s18
   1dfca:	eef0 1a69 	vmov.f32	s3, s19
   1dfce:	ec41 0b10 	vmov	d0, r0, r1
   1dfd2:	f000 fa2d 	bl	1e430 <pow>
   1dfd6:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   1dfda:	ec59 8b10 	vmov	r8, r9, d0
   1dfde:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
   1dfe2:	6818      	ldr	r0, [r3, #0]
   1dfe4:	f7fe fb90 	bl	1c708 <__aeabi_f2d>
   1dfe8:	eeb0 1a49 	vmov.f32	s2, s18
   1dfec:	eef0 1a69 	vmov.f32	s3, s19
   1dff0:	ec41 0b10 	vmov	d0, r0, r1
   1dff4:	f000 fa1c 	bl	1e430 <pow>
   1dff8:	4640      	mov	r0, r8
   1dffa:	ec53 2b10 	vmov	r2, r3, d0
   1dffe:	4649      	mov	r1, r9
   1e000:	f7fe fa24 	bl	1c44c <__adddf3>
   1e004:	f8bd 200c 	ldrh.w	r2, [sp, #12]
   1e008:	4b37      	ldr	r3, [pc, #220]	; (1e0e8 <fall_detection+0xa60>)
   1e00a:	4680      	mov	r8, r0
   1e00c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   1e010:	6818      	ldr	r0, [r3, #0]
   1e012:	4689      	mov	r9, r1
   1e014:	f7fe fb78 	bl	1c708 <__aeabi_f2d>
   1e018:	eeb0 1a49 	vmov.f32	s2, s18
   1e01c:	eef0 1a69 	vmov.f32	s3, s19
   1e020:	ec41 0b10 	vmov	d0, r0, r1
   1e024:	f000 fa04 	bl	1e430 <pow>
   1e028:	4640      	mov	r0, r8
   1e02a:	ec53 2b10 	vmov	r2, r3, d0
   1e02e:	4649      	mov	r1, r9
   1e030:	f7fe fa0c 	bl	1c44c <__adddf3>
   1e034:	ec41 0b10 	vmov	d0, r0, r1
   1e038:	f01a ff04 	bl	38e44 <sqrt>
   1e03c:	ec51 0b10 	vmov	r0, r1, d0
   1e040:	f7fe fe74 	bl	1cd2c <__aeabi_d2f>
   1e044:	f8bd 900c 	ldrh.w	r9, [sp, #12]
   1e048:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 1e0ec <fall_detection+0xa64>
		average += verify_acc_magn[i];
   1e04c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
		verify_acc_magn[i] = sqrt(pow(get_acc_magn(acc_x_vrif_buffer_1[i]),2)+ pow(get_acc_magn(acc_y_vrif_buffer_1[i]),2) + pow(get_acc_magn(acc_z_vrif_buffer_1[i]),2));
   1e050:	eb08 0989 	add.w	r9, r8, r9, lsl #2
   1e054:	f8c9 0000 	str.w	r0, [r9]
		average += verify_acc_magn[i];
   1e058:	eb08 0883 	add.w	r8, r8, r3, lsl #2
   1e05c:	eddd 7a07 	vldr	s15, [sp, #28]
   1e060:	ed98 7a00 	vldr	s14, [r8]
   1e064:	ee77 7a87 	vadd.f32	s15, s15, s14
   1e068:	edcd 7a07 	vstr	s15, [sp, #28]
	for(i=0;i<VERIFY_DATA_BUF_LEN;i++)
   1e06c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   1e070:	3301      	adds	r3, #1
   1e072:	b29b      	uxth	r3, r3
   1e074:	f8ad 300c 	strh.w	r3, [sp, #12]
   1e078:	e5b3      	b.n	1dbe2 <fall_detection+0x55a>
		variance += pow((verify_acc_magn[i]-average),2);
   1e07a:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   1e07e:	eddd 7a07 	vldr	s15, [sp, #28]
   1e082:	eb07 0383 	add.w	r3, r7, r3, lsl #2
   1e086:	ed93 7a00 	vldr	s14, [r3]
   1e08a:	ee77 7a67 	vsub.f32	s15, s14, s15
   1e08e:	ee17 0a90 	vmov	r0, s15
   1e092:	f7fe fb39 	bl	1c708 <__aeabi_f2d>
   1e096:	eeb0 1a49 	vmov.f32	s2, s18
   1e09a:	eef0 1a69 	vmov.f32	s3, s19
   1e09e:	ec41 0b10 	vmov	d0, r0, r1
   1e0a2:	f000 f9c5 	bl	1e430 <pow>
   1e0a6:	ec53 2b10 	vmov	r2, r3, d0
   1e0aa:	9806      	ldr	r0, [sp, #24]
   1e0ac:	e9cd 2300 	strd	r2, r3, [sp]
   1e0b0:	f7fe fb2a 	bl	1c708 <__aeabi_f2d>
   1e0b4:	e9dd 2300 	ldrd	r2, r3, [sp]
   1e0b8:	f7fe f9c8 	bl	1c44c <__adddf3>
   1e0bc:	f7fe fe36 	bl	1cd2c <__aeabi_d2f>
   1e0c0:	9006      	str	r0, [sp, #24]
	for(i=0;i<VERIFY_DATA_BUF_LEN;i++)
   1e0c2:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   1e0c6:	3301      	adds	r3, #1
   1e0c8:	b29b      	uxth	r3, r3
   1e0ca:	f8ad 300c 	strh.w	r3, [sp, #12]
   1e0ce:	e599      	b.n	1dc04 <fall_detection+0x57c>
			fall_result = false; //fuzzy output not satisfied
   1e0d0:	2200      	movs	r2, #0
   1e0d2:	e5c6      	b.n	1dc62 <fall_detection+0x5da>
}
   1e0d4:	b02c      	add	sp, #176	; 0xb0
   1e0d6:	ecbd 8b06 	vpop	{d8-d10}
   1e0da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1e0de:	bf00      	nop
   1e0e0:	20023820 	.word	0x20023820
   1e0e4:	20023ff0 	.word	0x20023ff0
   1e0e8:	20022390 	.word	0x20022390
   1e0ec:	20024654 	.word	0x20024654

0001e0f0 <UpdateIMUData>:
{
	lsm6dso_number_of_steps_get(&imu_dev_ctx, steps);
}

void UpdateIMUData(void)
{
   1e0f0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	GetImuSteps(&g_steps);
   1e0f2:	4c1f      	ldr	r4, [pc, #124]	; (1e170 <UpdateIMUData+0x80>)
   1e0f4:	4620      	mov	r0, r4
   1e0f6:	f006 fae3 	bl	246c0 <GetImuSteps>

	g_distance = 0.7*g_steps;
   1e0fa:	8825      	ldrh	r5, [r4, #0]
   1e0fc:	4628      	mov	r0, r5
   1e0fe:	f7fe faf1 	bl	1c6e4 <__aeabi_i2d>
   1e102:	a317      	add	r3, pc, #92	; (adr r3, 1e160 <UpdateIMUData+0x70>)
   1e104:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e108:	f7fe fb56 	bl	1c7b8 <__aeabi_dmul>
   1e10c:	f7fe fdee 	bl	1ccec <__aeabi_d2uiz>
   1e110:	b284      	uxth	r4, r0
	g_calorie = 0.8214*60*(g_distance/1000);
   1e112:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	g_distance = 0.7*g_steps;
   1e116:	4b17      	ldr	r3, [pc, #92]	; (1e174 <UpdateIMUData+0x84>)
	g_calorie = 0.8214*60*(g_distance/1000);
   1e118:	fbb4 f0f0 	udiv	r0, r4, r0
	g_distance = 0.7*g_steps;
   1e11c:	801c      	strh	r4, [r3, #0]
	g_calorie = 0.8214*60*(g_distance/1000);
   1e11e:	f7fe fae1 	bl	1c6e4 <__aeabi_i2d>
   1e122:	a311      	add	r3, pc, #68	; (adr r3, 1e168 <UpdateIMUData+0x78>)
   1e124:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e128:	f7fe fb46 	bl	1c7b8 <__aeabi_dmul>
   1e12c:	f7fe fdde 	bl	1ccec <__aeabi_d2uiz>
   1e130:	4b11      	ldr	r3, [pc, #68]	; (1e178 <UpdateIMUData+0x88>)
   1e132:	b282      	uxth	r2, r0
   1e134:	801a      	strh	r2, [r3, #0]

	LOG_INF("g_steps:%d,g_distance:%d,g_calorie:%d\n", g_steps, g_distance, g_calorie);
   1e136:	f04f 0000 	mov.w	r0, #0
   1e13a:	2303      	movs	r3, #3
   1e13c:	490f      	ldr	r1, [pc, #60]	; (1e17c <UpdateIMUData+0x8c>)
   1e13e:	f363 0007 	bfi	r0, r3, #0, #8
   1e142:	4b0f      	ldr	r3, [pc, #60]	; (1e180 <UpdateIMUData+0x90>)
   1e144:	9200      	str	r2, [sp, #0]
   1e146:	1a5b      	subs	r3, r3, r1
   1e148:	08db      	lsrs	r3, r3, #3
   1e14a:	f363 108f 	bfi	r0, r3, #6, #10
   1e14e:	462a      	mov	r2, r5
   1e150:	4623      	mov	r3, r4
   1e152:	490c      	ldr	r1, [pc, #48]	; (1e184 <UpdateIMUData+0x94>)
   1e154:	f01e fb41 	bl	3c7da <log_string_sync>
}
   1e158:	b003      	add	sp, #12
   1e15a:	bd30      	pop	{r4, r5, pc}
   1e15c:	f3af 8000 	nop.w
   1e160:	66666666 	.word	0x66666666
   1e164:	3fe66666 	.word	0x3fe66666
   1e168:	1cac0831 	.word	0x1cac0831
   1e16c:	4048a45a 	.word	0x4048a45a
   1e170:	20029900 	.word	0x20029900
   1e174:	200298fe 	.word	0x200298fe
   1e178:	200298fc 	.word	0x200298fc
   1e17c:	0003f8d4 	.word	0x0003f8d4
   1e180:	0003f964 	.word	0x0003f964
   1e184:	0004159b 	.word	0x0004159b

0001e188 <MAX20353_UpdateTemper>:
	WriteWord(0x0C, RCOMP, 0x5C);
	return RCOMP;
}

void MAX20353_UpdateTemper(void)
{
   1e188:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1e18c:	ed2d 8b02 	vpush	{d8}
   1e190:	b0a5      	sub	sp, #148	; 0x94
	u8_t thm;
	s8_t begin,end,tmp;
	float resistance;
	s16_t temper=25;
	u8_t tmpbuf[128] = {0};
   1e192:	2100      	movs	r1, #0
   1e194:	2280      	movs	r2, #128	; 0x80
   1e196:	a804      	add	r0, sp, #16
   1e198:	f020 fb78 	bl	3e88c <memset>
	static u8_t pre_thm=0;
	static u16_t pre_temper=25;	//25
	
	thm = MAX20353_ReadTHM();
   1e19c:	f008 f95e 	bl	2645c <MAX20353_ReadTHM>
	if(thm == pre_thm)
   1e1a0:	4b95      	ldr	r3, [pc, #596]	; (1e3f8 <MAX20353_UpdateTemper+0x270>)
   1e1a2:	7819      	ldrb	r1, [r3, #0]
   1e1a4:	4281      	cmp	r1, r0
   1e1a6:	f000 80bd 	beq.w	1e324 <MAX20353_UpdateTemper+0x19c>
		return;

	pre_thm = thm;
   1e1aa:	7018      	strb	r0, [r3, #0]
	resistance = (float)10/(255.00/thm-1);
   1e1ac:	f7fe fa9a 	bl	1c6e4 <__aeabi_i2d>
   1e1b0:	4602      	mov	r2, r0
   1e1b2:	460b      	mov	r3, r1
   1e1b4:	a18e      	add	r1, pc, #568	; (adr r1, 1e3f0 <MAX20353_UpdateTemper+0x268>)
   1e1b6:	e9d1 0100 	ldrd	r0, r1, [r1]
   1e1ba:	f7fe fc27 	bl	1ca0c <__aeabi_ddiv>
   1e1be:	2200      	movs	r2, #0
   1e1c0:	4b8e      	ldr	r3, [pc, #568]	; (1e3fc <MAX20353_UpdateTemper+0x274>)
   1e1c2:	f7fe f941 	bl	1c448 <__aeabi_dsub>
   1e1c6:	4602      	mov	r2, r0
   1e1c8:	460b      	mov	r3, r1
   1e1ca:	2000      	movs	r0, #0
   1e1cc:	498c      	ldr	r1, [pc, #560]	; (1e400 <MAX20353_UpdateTemper+0x278>)
   1e1ce:	f7fe fc1d 	bl	1ca0c <__aeabi_ddiv>
   1e1d2:	f7fe fdab 	bl	1cd2c <__aeabi_d2f>
   1e1d6:	ee08 0a10 	vmov	s16, r0

	sprintf(tmpbuf, "resistance:%.4f", resistance);
   1e1da:	f7fe fa95 	bl	1c708 <__aeabi_f2d>
   1e1de:	4b89      	ldr	r3, [pc, #548]	; (1e404 <MAX20353_UpdateTemper+0x27c>)
   1e1e0:	e9cd 0100 	strd	r0, r1, [sp]
   1e1e4:	2280      	movs	r2, #128	; 0x80
   1e1e6:	2100      	movs	r1, #0
   1e1e8:	a804      	add	r0, sp, #16
   1e1ea:	f020 fc91 	bl	3eb10 <__sprintf_chk>
	LOG_INF("%s\n", tmpbuf);
   1e1ee:	2303      	movs	r3, #3
   1e1f0:	f04f 0000 	mov.w	r0, #0
   1e1f4:	4c84      	ldr	r4, [pc, #528]	; (1e408 <MAX20353_UpdateTemper+0x280>)
   1e1f6:	f363 0007 	bfi	r0, r3, #0, #8
   1e1fa:	4b84      	ldr	r3, [pc, #528]	; (1e40c <MAX20353_UpdateTemper+0x284>)
	end = TEMPER_NUM_MAX-1;
	while(begin <= end)
	{
		tmp = (begin+end)/2;
		
		if(ntc_table[tmp].impedance == resistance)
   1e1fc:	f8df 922c 	ldr.w	r9, [pc, #556]	; 1e42c <MAX20353_UpdateTemper+0x2a4>
	LOG_INF("%s\n", tmpbuf);
   1e200:	1ae4      	subs	r4, r4, r3
   1e202:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1e206:	f364 108f 	bfi	r0, r4, #6, #10
   1e20a:	aa04      	add	r2, sp, #16
   1e20c:	4980      	ldr	r1, [pc, #512]	; (1e410 <MAX20353_UpdateTemper+0x288>)
   1e20e:	f01e fae4 	bl	3c7da <log_string_sync>
	end = TEMPER_NUM_MAX-1;
   1e212:	f04f 0821 	mov.w	r8, #33	; 0x21
	begin = 0;
   1e216:	2600      	movs	r6, #0
   1e218:	464f      	mov	r7, r9
		tmp = (begin+end)/2;
   1e21a:	eb06 0308 	add.w	r3, r6, r8
   1e21e:	105b      	asrs	r3, r3, #1
   1e220:	b25d      	sxtb	r5, r3
		if(ntc_table[tmp].impedance == resistance)
   1e222:	eb09 03c3 	add.w	r3, r9, r3, lsl #3
   1e226:	edd3 7a01 	vldr	s15, [r3, #4]
   1e22a:	eef4 7a48 	vcmp.f32	s15, s16
   1e22e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1e232:	f000 80cf 	beq.w	1e3d4 <MAX20353_UpdateTemper+0x24c>
			break;

		if(ntc_table[tmp].impedance > resistance)
   1e236:	eef4 7ac8 	vcmpe.f32	s15, s16
   1e23a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		{
			begin = tmp+1;
   1e23e:	bfcb      	itete	gt
   1e240:	1c6e      	addgt	r6, r5, #1
		}
		else
		{
			end = tmp-1;
   1e242:	f105 38ff 	addle.w	r8, r5, #4294967295
			begin = tmp+1;
   1e246:	b276      	sxtbgt	r6, r6
			end = tmp-1;
   1e248:	fa4f f888 	sxtble.w	r8, r8
	while(begin <= end)
   1e24c:	4546      	cmp	r6, r8
   1e24e:	dde4      	ble.n	1e21a <MAX20353_UpdateTemper+0x92>
	}
	else			//select closeet
	{
		float com1,com2;

		LOG_INF("select closeet!\n");
   1e250:	2303      	movs	r3, #3
   1e252:	f04f 0000 	mov.w	r0, #0
   1e256:	f363 0007 	bfi	r0, r3, #0, #8
   1e25a:	f364 108f 	bfi	r0, r4, #6, #10
   1e25e:	496d      	ldr	r1, [pc, #436]	; (1e414 <MAX20353_UpdateTemper+0x28c>)
   1e260:	f01e fabb 	bl	3c7da <log_string_sync>
		
		if(begin == tmp+1)
   1e264:	1c6b      	adds	r3, r5, #1
   1e266:	429e      	cmp	r6, r3
   1e268:	d161      	bne.n	1e32e <MAX20353_UpdateTemper+0x1a6>
		{
			com1 = fabs(ntc_table[tmp].impedance-resistance);
   1e26a:	eb07 03c5 	add.w	r3, r7, r5, lsl #3
   1e26e:	edd3 7a01 	vldr	s15, [r3, #4]
   1e272:	ee77 7ac8 	vsub.f32	s15, s15, s16
   1e276:	ee17 0a90 	vmov	r0, s15
   1e27a:	f7fe fa45 	bl	1c708 <__aeabi_f2d>
   1e27e:	ec41 0b10 	vmov	d0, r0, r1
   1e282:	f01a fd9b 	bl	38dbc <fabs>
   1e286:	ec51 0b10 	vmov	r0, r1, d0
   1e28a:	f7fe fd4f 	bl	1cd2c <__aeabi_d2f>
			com2 = fabs(ntc_table[tmp+1].impedance-resistance);
   1e28e:	eb07 03c6 	add.w	r3, r7, r6, lsl #3
   1e292:	edd3 7a01 	vldr	s15, [r3, #4]
   1e296:	ee77 7ac8 	vsub.f32	s15, s15, s16
			com1 = fabs(ntc_table[tmp].impedance-resistance);
   1e29a:	ee08 0a90 	vmov	s17, r0
			com2 = fabs(ntc_table[tmp+1].impedance-resistance);
   1e29e:	ee17 0a90 	vmov	r0, s15
   1e2a2:	f7fe fa31 	bl	1c708 <__aeabi_f2d>
   1e2a6:	ec41 0b10 	vmov	d0, r0, r1
   1e2aa:	f01a fd87 	bl	38dbc <fabs>
   1e2ae:	ec51 0b10 	vmov	r0, r1, d0
   1e2b2:	f7fe fd3b 	bl	1cd2c <__aeabi_d2f>
   1e2b6:	ee08 0a10 	vmov	s16, r0
			sprintf(tmpbuf, "001 com1:%.4f, com2:%04f", com1, com2);
   1e2ba:	f7fe fa25 	bl	1c708 <__aeabi_f2d>
   1e2be:	e9cd 0102 	strd	r0, r1, [sp, #8]
   1e2c2:	ee18 0a90 	vmov	r0, s17
   1e2c6:	f7fe fa1f 	bl	1c708 <__aeabi_f2d>
   1e2ca:	4b53      	ldr	r3, [pc, #332]	; (1e418 <MAX20353_UpdateTemper+0x290>)
   1e2cc:	e9cd 0100 	strd	r0, r1, [sp]
   1e2d0:	2280      	movs	r2, #128	; 0x80
   1e2d2:	2100      	movs	r1, #0
   1e2d4:	a804      	add	r0, sp, #16
   1e2d6:	f020 fc1b 	bl	3eb10 <__sprintf_chk>
			LOG_INF("%s\n", tmpbuf);
   1e2da:	2303      	movs	r3, #3
   1e2dc:	f04f 0000 	mov.w	r0, #0
   1e2e0:	f363 0007 	bfi	r0, r3, #0, #8
   1e2e4:	f364 108f 	bfi	r0, r4, #6, #10
   1e2e8:	aa04      	add	r2, sp, #16
   1e2ea:	4949      	ldr	r1, [pc, #292]	; (1e410 <MAX20353_UpdateTemper+0x288>)
   1e2ec:	f01e fa75 	bl	3c7da <log_string_sync>
			if(com1 > com2)
   1e2f0:	eef4 8ac8 	vcmpe.f32	s17, s16
   1e2f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1e2f8:	dd67      	ble.n	1e3ca <MAX20353_UpdateTemper+0x242>
			{
				temper = ntc_table[tmp+1].temperature;
   1e2fa:	f937 5036 	ldrsh.w	r5, [r7, r6, lsl #3]
				temper = ntc_table[tmp].temperature;
			}			
		}
	}

	LOG_INF("temper:%d\n", temper);
   1e2fe:	2303      	movs	r3, #3
   1e300:	f04f 0000 	mov.w	r0, #0
   1e304:	f363 0007 	bfi	r0, r3, #0, #8
   1e308:	462a      	mov	r2, r5
   1e30a:	f364 108f 	bfi	r0, r4, #6, #10
   1e30e:	4943      	ldr	r1, [pc, #268]	; (1e41c <MAX20353_UpdateTemper+0x294>)
   1e310:	f01e fa63 	bl	3c7da <log_string_sync>

	if(temper != pre_temper)
   1e314:	4b42      	ldr	r3, [pc, #264]	; (1e420 <MAX20353_UpdateTemper+0x298>)
   1e316:	881a      	ldrh	r2, [r3, #0]
   1e318:	4295      	cmp	r5, r2
   1e31a:	d003      	beq.n	1e324 <MAX20353_UpdateTemper+0x19c>
	{
		pre_temper = temper;
		MAX20353_UpdateRCOMP(temper);	
   1e31c:	4628      	mov	r0, r5
		pre_temper = temper;
   1e31e:	801d      	strh	r5, [r3, #0]
		MAX20353_UpdateRCOMP(temper);	
   1e320:	f008 f8d2 	bl	264c8 <MAX20353_UpdateRCOMP>
	}
}
   1e324:	b025      	add	sp, #148	; 0x94
   1e326:	ecbd 8b02 	vpop	{d8}
   1e32a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		else if(end == tmp-1)
   1e32e:	1e6b      	subs	r3, r5, #1
   1e330:	4598      	cmp	r8, r3
   1e332:	d14d      	bne.n	1e3d0 <MAX20353_UpdateTemper+0x248>
			com1 = fabs(ntc_table[tmp].impedance-resistance);
   1e334:	eb07 03c5 	add.w	r3, r7, r5, lsl #3
   1e338:	edd3 7a01 	vldr	s15, [r3, #4]
   1e33c:	ee77 7ac8 	vsub.f32	s15, s15, s16
   1e340:	ee17 0a90 	vmov	r0, s15
   1e344:	f7fe f9e0 	bl	1c708 <__aeabi_f2d>
   1e348:	ec41 0b10 	vmov	d0, r0, r1
   1e34c:	f01a fd36 	bl	38dbc <fabs>
   1e350:	ec51 0b10 	vmov	r0, r1, d0
   1e354:	f7fe fcea 	bl	1cd2c <__aeabi_d2f>
			com2 = fabs(ntc_table[tmp-1].impedance-resistance);
   1e358:	eb07 03c8 	add.w	r3, r7, r8, lsl #3
   1e35c:	edd3 7a01 	vldr	s15, [r3, #4]
   1e360:	ee77 7ac8 	vsub.f32	s15, s15, s16
			com1 = fabs(ntc_table[tmp].impedance-resistance);
   1e364:	ee08 0a90 	vmov	s17, r0
			com2 = fabs(ntc_table[tmp-1].impedance-resistance);
   1e368:	ee17 0a90 	vmov	r0, s15
   1e36c:	f7fe f9cc 	bl	1c708 <__aeabi_f2d>
   1e370:	ec41 0b10 	vmov	d0, r0, r1
   1e374:	f01a fd22 	bl	38dbc <fabs>
   1e378:	ec51 0b10 	vmov	r0, r1, d0
   1e37c:	f7fe fcd6 	bl	1cd2c <__aeabi_d2f>
   1e380:	ee08 0a10 	vmov	s16, r0
			sprintf(tmpbuf, "002 com1:%.4f, com2:%04f", com1, com2);
   1e384:	f7fe f9c0 	bl	1c708 <__aeabi_f2d>
   1e388:	e9cd 0102 	strd	r0, r1, [sp, #8]
   1e38c:	ee18 0a90 	vmov	r0, s17
   1e390:	f7fe f9ba 	bl	1c708 <__aeabi_f2d>
   1e394:	4b23      	ldr	r3, [pc, #140]	; (1e424 <MAX20353_UpdateTemper+0x29c>)
   1e396:	e9cd 0100 	strd	r0, r1, [sp]
   1e39a:	2280      	movs	r2, #128	; 0x80
   1e39c:	2100      	movs	r1, #0
   1e39e:	a804      	add	r0, sp, #16
   1e3a0:	f020 fbb6 	bl	3eb10 <__sprintf_chk>
			LOG_INF("%s\n", tmpbuf);
   1e3a4:	2303      	movs	r3, #3
   1e3a6:	f04f 0000 	mov.w	r0, #0
   1e3aa:	f363 0007 	bfi	r0, r3, #0, #8
   1e3ae:	f364 108f 	bfi	r0, r4, #6, #10
   1e3b2:	aa04      	add	r2, sp, #16
   1e3b4:	4916      	ldr	r1, [pc, #88]	; (1e410 <MAX20353_UpdateTemper+0x288>)
   1e3b6:	f01e fa10 	bl	3c7da <log_string_sync>
			if(com1 > com2)
   1e3ba:	eef4 8ac8 	vcmpe.f32	s17, s16
   1e3be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1e3c2:	dd02      	ble.n	1e3ca <MAX20353_UpdateTemper+0x242>
				temper = ntc_table[tmp-1].temperature;
   1e3c4:	f937 5038 	ldrsh.w	r5, [r7, r8, lsl #3]
   1e3c8:	e799      	b.n	1e2fe <MAX20353_UpdateTemper+0x176>
				temper = ntc_table[tmp].temperature;
   1e3ca:	f937 5035 	ldrsh.w	r5, [r7, r5, lsl #3]
   1e3ce:	e796      	b.n	1e2fe <MAX20353_UpdateTemper+0x176>
	s16_t temper=25;
   1e3d0:	2519      	movs	r5, #25
   1e3d2:	e794      	b.n	1e2fe <MAX20353_UpdateTemper+0x176>
		LOG_INF("find success!\n");
   1e3d4:	2303      	movs	r3, #3
   1e3d6:	f04f 0000 	mov.w	r0, #0
   1e3da:	f363 0007 	bfi	r0, r3, #0, #8
   1e3de:	f364 108f 	bfi	r0, r4, #6, #10
   1e3e2:	4911      	ldr	r1, [pc, #68]	; (1e428 <MAX20353_UpdateTemper+0x2a0>)
   1e3e4:	f01e f9f9 	bl	3c7da <log_string_sync>
		temper = ntc_table[tmp].temperature;
   1e3e8:	f939 5035 	ldrsh.w	r5, [r9, r5, lsl #3]
   1e3ec:	e787      	b.n	1e2fe <MAX20353_UpdateTemper+0x176>
   1e3ee:	bf00      	nop
   1e3f0:	00000000 	.word	0x00000000
   1e3f4:	406fe000 	.word	0x406fe000
   1e3f8:	2002c3ae 	.word	0x2002c3ae
   1e3fc:	3ff00000 	.word	0x3ff00000
   1e400:	40240000 	.word	0x40240000
   1e404:	000418a5 	.word	0x000418a5
   1e408:	0003f97c 	.word	0x0003f97c
   1e40c:	0003f8d4 	.word	0x0003f8d4
   1e410:	00042f6c 	.word	0x00042f6c
   1e414:	00041901 	.word	0x00041901
   1e418:	000418b5 	.word	0x000418b5
   1e41c:	000418e7 	.word	0x000418e7
   1e420:	200348de 	.word	0x200348de
   1e424:	000418ce 	.word	0x000418ce
   1e428:	000418f2 	.word	0x000418f2
   1e42c:	0003fcf8 	.word	0x0003fcf8

0001e430 <pow>:
   1e430:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e432:	ed2d 8b02 	vpush	{d8}
   1e436:	ec57 6b10 	vmov	r6, r7, d0
   1e43a:	ec55 4b11 	vmov	r4, r5, d1
   1e43e:	f000 fb37 	bl	1eab0 <__ieee754_pow>
   1e442:	4b61      	ldr	r3, [pc, #388]	; (1e5c8 <pow+0x198>)
   1e444:	eeb0 8a40 	vmov.f32	s16, s0
   1e448:	eef0 8a60 	vmov.f32	s17, s1
   1e44c:	f993 3000 	ldrsb.w	r3, [r3]
   1e450:	3301      	adds	r3, #1
   1e452:	d02a      	beq.n	1e4aa <pow+0x7a>
   1e454:	4622      	mov	r2, r4
   1e456:	462b      	mov	r3, r5
   1e458:	4620      	mov	r0, r4
   1e45a:	4629      	mov	r1, r5
   1e45c:	f7fe fe34 	bl	1d0c8 <__aeabi_dcmpun>
   1e460:	bb18      	cbnz	r0, 1e4aa <pow+0x7a>
   1e462:	4632      	mov	r2, r6
   1e464:	463b      	mov	r3, r7
   1e466:	4630      	mov	r0, r6
   1e468:	4639      	mov	r1, r7
   1e46a:	f7fe fe2d 	bl	1d0c8 <__aeabi_dcmpun>
   1e46e:	2800      	cmp	r0, #0
   1e470:	d144      	bne.n	1e4fc <pow+0xcc>
   1e472:	2200      	movs	r2, #0
   1e474:	2300      	movs	r3, #0
   1e476:	4630      	mov	r0, r6
   1e478:	4639      	mov	r1, r7
   1e47a:	f7fe fc05 	bl	1cc88 <__aeabi_dcmpeq>
   1e47e:	b1d8      	cbz	r0, 1e4b8 <pow+0x88>
   1e480:	2200      	movs	r2, #0
   1e482:	2300      	movs	r3, #0
   1e484:	4620      	mov	r0, r4
   1e486:	4629      	mov	r1, r5
   1e488:	f7fe fbfe 	bl	1cc88 <__aeabi_dcmpeq>
   1e48c:	2800      	cmp	r0, #0
   1e48e:	d13d      	bne.n	1e50c <pow+0xdc>
   1e490:	ec45 4b10 	vmov	d0, r4, r5
   1e494:	f01a fddc 	bl	39050 <finite>
   1e498:	b138      	cbz	r0, 1e4aa <pow+0x7a>
   1e49a:	4620      	mov	r0, r4
   1e49c:	4629      	mov	r1, r5
   1e49e:	2200      	movs	r2, #0
   1e4a0:	2300      	movs	r3, #0
   1e4a2:	f7fe fbfb 	bl	1cc9c <__aeabi_dcmplt>
   1e4a6:	2800      	cmp	r0, #0
   1e4a8:	d15b      	bne.n	1e562 <pow+0x132>
   1e4aa:	eeb0 0a48 	vmov.f32	s0, s16
   1e4ae:	eef0 0a68 	vmov.f32	s1, s17
   1e4b2:	ecbd 8b02 	vpop	{d8}
   1e4b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e4b8:	eeb0 0a48 	vmov.f32	s0, s16
   1e4bc:	eef0 0a68 	vmov.f32	s1, s17
   1e4c0:	f01a fdc6 	bl	39050 <finite>
   1e4c4:	b358      	cbz	r0, 1e51e <pow+0xee>
   1e4c6:	2200      	movs	r2, #0
   1e4c8:	2300      	movs	r3, #0
   1e4ca:	ec51 0b18 	vmov	r0, r1, d8
   1e4ce:	f7fe fbdb 	bl	1cc88 <__aeabi_dcmpeq>
   1e4d2:	2800      	cmp	r0, #0
   1e4d4:	d0e9      	beq.n	1e4aa <pow+0x7a>
   1e4d6:	ec47 6b10 	vmov	d0, r6, r7
   1e4da:	f01a fdb9 	bl	39050 <finite>
   1e4de:	2800      	cmp	r0, #0
   1e4e0:	d0e3      	beq.n	1e4aa <pow+0x7a>
   1e4e2:	ec45 4b10 	vmov	d0, r4, r5
   1e4e6:	f01a fdb3 	bl	39050 <finite>
   1e4ea:	2800      	cmp	r0, #0
   1e4ec:	d0dd      	beq.n	1e4aa <pow+0x7a>
   1e4ee:	f01e fb18 	bl	3cb22 <__errno>
   1e4f2:	2322      	movs	r3, #34	; 0x22
   1e4f4:	ed9f 8b2c 	vldr	d8, [pc, #176]	; 1e5a8 <pow+0x178>
   1e4f8:	6003      	str	r3, [r0, #0]
   1e4fa:	e7d6      	b.n	1e4aa <pow+0x7a>
   1e4fc:	4620      	mov	r0, r4
   1e4fe:	4629      	mov	r1, r5
   1e500:	2200      	movs	r2, #0
   1e502:	2300      	movs	r3, #0
   1e504:	f7fe fbc0 	bl	1cc88 <__aeabi_dcmpeq>
   1e508:	2800      	cmp	r0, #0
   1e50a:	d0ce      	beq.n	1e4aa <pow+0x7a>
   1e50c:	ed9f 8b28 	vldr	d8, [pc, #160]	; 1e5b0 <pow+0x180>
   1e510:	eeb0 0a48 	vmov.f32	s0, s16
   1e514:	eef0 0a68 	vmov.f32	s1, s17
   1e518:	ecbd 8b02 	vpop	{d8}
   1e51c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e51e:	ec47 6b10 	vmov	d0, r6, r7
   1e522:	f01a fd95 	bl	39050 <finite>
   1e526:	2800      	cmp	r0, #0
   1e528:	d0cd      	beq.n	1e4c6 <pow+0x96>
   1e52a:	ec45 4b10 	vmov	d0, r4, r5
   1e52e:	f01a fd8f 	bl	39050 <finite>
   1e532:	2800      	cmp	r0, #0
   1e534:	d0c7      	beq.n	1e4c6 <pow+0x96>
   1e536:	ee18 0a10 	vmov	r0, s16
   1e53a:	ec53 2b18 	vmov	r2, r3, d8
   1e53e:	4619      	mov	r1, r3
   1e540:	f7fe fdc2 	bl	1d0c8 <__aeabi_dcmpun>
   1e544:	bb18      	cbnz	r0, 1e58e <pow+0x15e>
   1e546:	f01e faec 	bl	3cb22 <__errno>
   1e54a:	2322      	movs	r3, #34	; 0x22
   1e54c:	2200      	movs	r2, #0
   1e54e:	4639      	mov	r1, r7
   1e550:	6003      	str	r3, [r0, #0]
   1e552:	2300      	movs	r3, #0
   1e554:	4630      	mov	r0, r6
   1e556:	f7fe fba1 	bl	1cc9c <__aeabi_dcmplt>
   1e55a:	b948      	cbnz	r0, 1e570 <pow+0x140>
   1e55c:	ed9f 8b16 	vldr	d8, [pc, #88]	; 1e5b8 <pow+0x188>
   1e560:	e7a3      	b.n	1e4aa <pow+0x7a>
   1e562:	f01e fade 	bl	3cb22 <__errno>
   1e566:	2321      	movs	r3, #33	; 0x21
   1e568:	ed9f 8b15 	vldr	d8, [pc, #84]	; 1e5c0 <pow+0x190>
   1e56c:	6003      	str	r3, [r0, #0]
   1e56e:	e79c      	b.n	1e4aa <pow+0x7a>
   1e570:	ec45 4b10 	vmov	d0, r4, r5
   1e574:	f01a fd76 	bl	39064 <rint>
   1e578:	4622      	mov	r2, r4
   1e57a:	462b      	mov	r3, r5
   1e57c:	ec51 0b10 	vmov	r0, r1, d0
   1e580:	f7fe fb82 	bl	1cc88 <__aeabi_dcmpeq>
   1e584:	2800      	cmp	r0, #0
   1e586:	d1e9      	bne.n	1e55c <pow+0x12c>
   1e588:	ed9f 8b0d 	vldr	d8, [pc, #52]	; 1e5c0 <pow+0x190>
   1e58c:	e78d      	b.n	1e4aa <pow+0x7a>
   1e58e:	f01e fac8 	bl	3cb22 <__errno>
   1e592:	2121      	movs	r1, #33	; 0x21
   1e594:	2200      	movs	r2, #0
   1e596:	2300      	movs	r3, #0
   1e598:	6001      	str	r1, [r0, #0]
   1e59a:	4610      	mov	r0, r2
   1e59c:	4619      	mov	r1, r3
   1e59e:	f7fe fa35 	bl	1ca0c <__aeabi_ddiv>
   1e5a2:	ec41 0b18 	vmov	d8, r0, r1
   1e5a6:	e780      	b.n	1e4aa <pow+0x7a>
	...
   1e5b4:	3ff00000 	.word	0x3ff00000
   1e5b8:	00000000 	.word	0x00000000
   1e5bc:	7ff00000 	.word	0x7ff00000
   1e5c0:	00000000 	.word	0x00000000
   1e5c4:	fff00000 	.word	0xfff00000
   1e5c8:	20037902 	.word	0x20037902
   1e5cc:	00000000 	.word	0x00000000

0001e5d0 <__ieee754_acos>:
   1e5d0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1e5d4:	ec55 4b10 	vmov	r4, r5, d0
   1e5d8:	49cd      	ldr	r1, [pc, #820]	; (1e910 <__ieee754_acos+0x340>)
   1e5da:	f025 4300 	bic.w	r3, r5, #2147483648	; 0x80000000
   1e5de:	428b      	cmp	r3, r1
   1e5e0:	dd0c      	ble.n	1e5fc <__ieee754_acos+0x2c>
   1e5e2:	48cc      	ldr	r0, [pc, #816]	; (1e914 <__ieee754_acos+0x344>)
   1e5e4:	4418      	add	r0, r3
   1e5e6:	4623      	mov	r3, r4
   1e5e8:	4303      	orrs	r3, r0
   1e5ea:	f040 80bd 	bne.w	1e768 <__ieee754_acos+0x198>
   1e5ee:	2d00      	cmp	r5, #0
   1e5f0:	f340 80c9 	ble.w	1e786 <__ieee754_acos+0x1b6>
   1e5f4:	ed9f 0baa 	vldr	d0, [pc, #680]	; 1e8a0 <__ieee754_acos+0x2d0>
   1e5f8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e5fc:	49c6      	ldr	r1, [pc, #792]	; (1e918 <__ieee754_acos+0x348>)
   1e5fe:	428b      	cmp	r3, r1
   1e600:	dc07      	bgt.n	1e612 <__ieee754_acos+0x42>
   1e602:	4ac6      	ldr	r2, [pc, #792]	; (1e91c <__ieee754_acos+0x34c>)
   1e604:	4293      	cmp	r3, r2
   1e606:	f300 80c2 	bgt.w	1e78e <__ieee754_acos+0x1be>
   1e60a:	ed9f 0ba7 	vldr	d0, [pc, #668]	; 1e8a8 <__ieee754_acos+0x2d8>
   1e60e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e612:	2d00      	cmp	r5, #0
   1e614:	f2c0 8188 	blt.w	1e928 <__ieee754_acos+0x358>
   1e618:	ee10 2a10 	vmov	r2, s0
   1e61c:	462b      	mov	r3, r5
   1e61e:	2000      	movs	r0, #0
   1e620:	49bf      	ldr	r1, [pc, #764]	; (1e920 <__ieee754_acos+0x350>)
   1e622:	f7fd ff11 	bl	1c448 <__aeabi_dsub>
   1e626:	2200      	movs	r2, #0
   1e628:	4bbe      	ldr	r3, [pc, #760]	; (1e924 <__ieee754_acos+0x354>)
   1e62a:	2600      	movs	r6, #0
   1e62c:	f7fe f8c4 	bl	1c7b8 <__aeabi_dmul>
   1e630:	4604      	mov	r4, r0
   1e632:	460d      	mov	r5, r1
   1e634:	ec45 4b10 	vmov	d0, r4, r5
   1e638:	f01a fc3e 	bl	38eb8 <__ieee754_sqrt>
   1e63c:	4620      	mov	r0, r4
   1e63e:	4629      	mov	r1, r5
   1e640:	a39b      	add	r3, pc, #620	; (adr r3, 1e8b0 <__ieee754_acos+0x2e0>)
   1e642:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e646:	ec59 8b10 	vmov	r8, r9, d0
   1e64a:	f7fe f8b5 	bl	1c7b8 <__aeabi_dmul>
   1e64e:	a39a      	add	r3, pc, #616	; (adr r3, 1e8b8 <__ieee754_acos+0x2e8>)
   1e650:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e654:	f7fd fefa 	bl	1c44c <__adddf3>
   1e658:	4622      	mov	r2, r4
   1e65a:	462b      	mov	r3, r5
   1e65c:	f7fe f8ac 	bl	1c7b8 <__aeabi_dmul>
   1e660:	a397      	add	r3, pc, #604	; (adr r3, 1e8c0 <__ieee754_acos+0x2f0>)
   1e662:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e666:	f7fd feef 	bl	1c448 <__aeabi_dsub>
   1e66a:	4622      	mov	r2, r4
   1e66c:	462b      	mov	r3, r5
   1e66e:	f7fe f8a3 	bl	1c7b8 <__aeabi_dmul>
   1e672:	a395      	add	r3, pc, #596	; (adr r3, 1e8c8 <__ieee754_acos+0x2f8>)
   1e674:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e678:	f7fd fee8 	bl	1c44c <__adddf3>
   1e67c:	4622      	mov	r2, r4
   1e67e:	462b      	mov	r3, r5
   1e680:	f7fe f89a 	bl	1c7b8 <__aeabi_dmul>
   1e684:	a392      	add	r3, pc, #584	; (adr r3, 1e8d0 <__ieee754_acos+0x300>)
   1e686:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e68a:	f7fd fedd 	bl	1c448 <__aeabi_dsub>
   1e68e:	4622      	mov	r2, r4
   1e690:	462b      	mov	r3, r5
   1e692:	f7fe f891 	bl	1c7b8 <__aeabi_dmul>
   1e696:	a390      	add	r3, pc, #576	; (adr r3, 1e8d8 <__ieee754_acos+0x308>)
   1e698:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e69c:	f7fd fed6 	bl	1c44c <__adddf3>
   1e6a0:	4622      	mov	r2, r4
   1e6a2:	462b      	mov	r3, r5
   1e6a4:	f7fe f888 	bl	1c7b8 <__aeabi_dmul>
   1e6a8:	4682      	mov	sl, r0
   1e6aa:	468b      	mov	fp, r1
   1e6ac:	4620      	mov	r0, r4
   1e6ae:	4629      	mov	r1, r5
   1e6b0:	a38b      	add	r3, pc, #556	; (adr r3, 1e8e0 <__ieee754_acos+0x310>)
   1e6b2:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e6b6:	f7fe f87f 	bl	1c7b8 <__aeabi_dmul>
   1e6ba:	a38b      	add	r3, pc, #556	; (adr r3, 1e8e8 <__ieee754_acos+0x318>)
   1e6bc:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e6c0:	f7fd fec2 	bl	1c448 <__aeabi_dsub>
   1e6c4:	4622      	mov	r2, r4
   1e6c6:	462b      	mov	r3, r5
   1e6c8:	f7fe f876 	bl	1c7b8 <__aeabi_dmul>
   1e6cc:	a388      	add	r3, pc, #544	; (adr r3, 1e8f0 <__ieee754_acos+0x320>)
   1e6ce:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e6d2:	f7fd febb 	bl	1c44c <__adddf3>
   1e6d6:	4622      	mov	r2, r4
   1e6d8:	462b      	mov	r3, r5
   1e6da:	f7fe f86d 	bl	1c7b8 <__aeabi_dmul>
   1e6de:	a386      	add	r3, pc, #536	; (adr r3, 1e8f8 <__ieee754_acos+0x328>)
   1e6e0:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e6e4:	f7fd feb0 	bl	1c448 <__aeabi_dsub>
   1e6e8:	4622      	mov	r2, r4
   1e6ea:	462b      	mov	r3, r5
   1e6ec:	f7fe f864 	bl	1c7b8 <__aeabi_dmul>
   1e6f0:	2200      	movs	r2, #0
   1e6f2:	4b8b      	ldr	r3, [pc, #556]	; (1e920 <__ieee754_acos+0x350>)
   1e6f4:	f7fd feaa 	bl	1c44c <__adddf3>
   1e6f8:	4602      	mov	r2, r0
   1e6fa:	460b      	mov	r3, r1
   1e6fc:	4650      	mov	r0, sl
   1e6fe:	4659      	mov	r1, fp
   1e700:	f7fe f984 	bl	1ca0c <__aeabi_ddiv>
   1e704:	4642      	mov	r2, r8
   1e706:	464b      	mov	r3, r9
   1e708:	f7fe f856 	bl	1c7b8 <__aeabi_dmul>
   1e70c:	4632      	mov	r2, r6
   1e70e:	4682      	mov	sl, r0
   1e710:	468b      	mov	fp, r1
   1e712:	464b      	mov	r3, r9
   1e714:	4630      	mov	r0, r6
   1e716:	4649      	mov	r1, r9
   1e718:	f7fe f84e 	bl	1c7b8 <__aeabi_dmul>
   1e71c:	4602      	mov	r2, r0
   1e71e:	460b      	mov	r3, r1
   1e720:	4620      	mov	r0, r4
   1e722:	4629      	mov	r1, r5
   1e724:	f7fd fe90 	bl	1c448 <__aeabi_dsub>
   1e728:	4604      	mov	r4, r0
   1e72a:	460d      	mov	r5, r1
   1e72c:	4632      	mov	r2, r6
   1e72e:	464b      	mov	r3, r9
   1e730:	4640      	mov	r0, r8
   1e732:	4649      	mov	r1, r9
   1e734:	f7fd fe8a 	bl	1c44c <__adddf3>
   1e738:	4602      	mov	r2, r0
   1e73a:	460b      	mov	r3, r1
   1e73c:	4620      	mov	r0, r4
   1e73e:	4629      	mov	r1, r5
   1e740:	f7fe f964 	bl	1ca0c <__aeabi_ddiv>
   1e744:	4602      	mov	r2, r0
   1e746:	460b      	mov	r3, r1
   1e748:	4650      	mov	r0, sl
   1e74a:	4659      	mov	r1, fp
   1e74c:	f7fd fe7e 	bl	1c44c <__adddf3>
   1e750:	4632      	mov	r2, r6
   1e752:	464b      	mov	r3, r9
   1e754:	f7fd fe7a 	bl	1c44c <__adddf3>
   1e758:	4602      	mov	r2, r0
   1e75a:	460b      	mov	r3, r1
   1e75c:	f7fd fe76 	bl	1c44c <__adddf3>
   1e760:	ec41 0b10 	vmov	d0, r0, r1
   1e764:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e768:	ee10 2a10 	vmov	r2, s0
   1e76c:	462b      	mov	r3, r5
   1e76e:	4620      	mov	r0, r4
   1e770:	4629      	mov	r1, r5
   1e772:	f7fd fe69 	bl	1c448 <__aeabi_dsub>
   1e776:	4602      	mov	r2, r0
   1e778:	460b      	mov	r3, r1
   1e77a:	f7fe f947 	bl	1ca0c <__aeabi_ddiv>
   1e77e:	ec41 0b10 	vmov	d0, r0, r1
   1e782:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e786:	ed9f 0b5e 	vldr	d0, [pc, #376]	; 1e900 <__ieee754_acos+0x330>
   1e78a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e78e:	ee10 2a10 	vmov	r2, s0
   1e792:	ee10 0a10 	vmov	r0, s0
   1e796:	462b      	mov	r3, r5
   1e798:	4629      	mov	r1, r5
   1e79a:	f7fe f80d 	bl	1c7b8 <__aeabi_dmul>
   1e79e:	4606      	mov	r6, r0
   1e7a0:	460f      	mov	r7, r1
   1e7a2:	a343      	add	r3, pc, #268	; (adr r3, 1e8b0 <__ieee754_acos+0x2e0>)
   1e7a4:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e7a8:	f7fe f806 	bl	1c7b8 <__aeabi_dmul>
   1e7ac:	a342      	add	r3, pc, #264	; (adr r3, 1e8b8 <__ieee754_acos+0x2e8>)
   1e7ae:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e7b2:	f7fd fe4b 	bl	1c44c <__adddf3>
   1e7b6:	4632      	mov	r2, r6
   1e7b8:	463b      	mov	r3, r7
   1e7ba:	f7fd fffd 	bl	1c7b8 <__aeabi_dmul>
   1e7be:	a340      	add	r3, pc, #256	; (adr r3, 1e8c0 <__ieee754_acos+0x2f0>)
   1e7c0:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e7c4:	f7fd fe40 	bl	1c448 <__aeabi_dsub>
   1e7c8:	4632      	mov	r2, r6
   1e7ca:	463b      	mov	r3, r7
   1e7cc:	f7fd fff4 	bl	1c7b8 <__aeabi_dmul>
   1e7d0:	a33d      	add	r3, pc, #244	; (adr r3, 1e8c8 <__ieee754_acos+0x2f8>)
   1e7d2:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e7d6:	f7fd fe39 	bl	1c44c <__adddf3>
   1e7da:	4632      	mov	r2, r6
   1e7dc:	463b      	mov	r3, r7
   1e7de:	f7fd ffeb 	bl	1c7b8 <__aeabi_dmul>
   1e7e2:	a33b      	add	r3, pc, #236	; (adr r3, 1e8d0 <__ieee754_acos+0x300>)
   1e7e4:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e7e8:	f7fd fe2e 	bl	1c448 <__aeabi_dsub>
   1e7ec:	4632      	mov	r2, r6
   1e7ee:	463b      	mov	r3, r7
   1e7f0:	f7fd ffe2 	bl	1c7b8 <__aeabi_dmul>
   1e7f4:	a338      	add	r3, pc, #224	; (adr r3, 1e8d8 <__ieee754_acos+0x308>)
   1e7f6:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e7fa:	f7fd fe27 	bl	1c44c <__adddf3>
   1e7fe:	4632      	mov	r2, r6
   1e800:	463b      	mov	r3, r7
   1e802:	f7fd ffd9 	bl	1c7b8 <__aeabi_dmul>
   1e806:	4680      	mov	r8, r0
   1e808:	4689      	mov	r9, r1
   1e80a:	4630      	mov	r0, r6
   1e80c:	4639      	mov	r1, r7
   1e80e:	a334      	add	r3, pc, #208	; (adr r3, 1e8e0 <__ieee754_acos+0x310>)
   1e810:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e814:	f7fd ffd0 	bl	1c7b8 <__aeabi_dmul>
   1e818:	a333      	add	r3, pc, #204	; (adr r3, 1e8e8 <__ieee754_acos+0x318>)
   1e81a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e81e:	f7fd fe13 	bl	1c448 <__aeabi_dsub>
   1e822:	4632      	mov	r2, r6
   1e824:	463b      	mov	r3, r7
   1e826:	f7fd ffc7 	bl	1c7b8 <__aeabi_dmul>
   1e82a:	a331      	add	r3, pc, #196	; (adr r3, 1e8f0 <__ieee754_acos+0x320>)
   1e82c:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e830:	f7fd fe0c 	bl	1c44c <__adddf3>
   1e834:	4632      	mov	r2, r6
   1e836:	463b      	mov	r3, r7
   1e838:	f7fd ffbe 	bl	1c7b8 <__aeabi_dmul>
   1e83c:	a32e      	add	r3, pc, #184	; (adr r3, 1e8f8 <__ieee754_acos+0x328>)
   1e83e:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e842:	f7fd fe01 	bl	1c448 <__aeabi_dsub>
   1e846:	4632      	mov	r2, r6
   1e848:	463b      	mov	r3, r7
   1e84a:	f7fd ffb5 	bl	1c7b8 <__aeabi_dmul>
   1e84e:	2200      	movs	r2, #0
   1e850:	4b33      	ldr	r3, [pc, #204]	; (1e920 <__ieee754_acos+0x350>)
   1e852:	f7fd fdfb 	bl	1c44c <__adddf3>
   1e856:	4602      	mov	r2, r0
   1e858:	460b      	mov	r3, r1
   1e85a:	4640      	mov	r0, r8
   1e85c:	4649      	mov	r1, r9
   1e85e:	f7fe f8d5 	bl	1ca0c <__aeabi_ddiv>
   1e862:	4622      	mov	r2, r4
   1e864:	462b      	mov	r3, r5
   1e866:	f7fd ffa7 	bl	1c7b8 <__aeabi_dmul>
   1e86a:	4602      	mov	r2, r0
   1e86c:	460b      	mov	r3, r1
   1e86e:	a126      	add	r1, pc, #152	; (adr r1, 1e908 <__ieee754_acos+0x338>)
   1e870:	e9d1 0100 	ldrd	r0, r1, [r1]
   1e874:	f7fd fde8 	bl	1c448 <__aeabi_dsub>
   1e878:	4602      	mov	r2, r0
   1e87a:	460b      	mov	r3, r1
   1e87c:	4620      	mov	r0, r4
   1e87e:	4629      	mov	r1, r5
   1e880:	f7fd fde2 	bl	1c448 <__aeabi_dsub>
   1e884:	4602      	mov	r2, r0
   1e886:	460b      	mov	r3, r1
   1e888:	a107      	add	r1, pc, #28	; (adr r1, 1e8a8 <__ieee754_acos+0x2d8>)
   1e88a:	e9d1 0100 	ldrd	r0, r1, [r1]
   1e88e:	f7fd fddb 	bl	1c448 <__aeabi_dsub>
   1e892:	ec41 0b10 	vmov	d0, r0, r1
   1e896:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e89a:	bf00      	nop
   1e89c:	f3af 8000 	nop.w
	...
   1e8a8:	54442d18 	.word	0x54442d18
   1e8ac:	3ff921fb 	.word	0x3ff921fb
   1e8b0:	0dfdf709 	.word	0x0dfdf709
   1e8b4:	3f023de1 	.word	0x3f023de1
   1e8b8:	7501b288 	.word	0x7501b288
   1e8bc:	3f49efe0 	.word	0x3f49efe0
   1e8c0:	b5688f3b 	.word	0xb5688f3b
   1e8c4:	3fa48228 	.word	0x3fa48228
   1e8c8:	0e884455 	.word	0x0e884455
   1e8cc:	3fc9c155 	.word	0x3fc9c155
   1e8d0:	03eb6f7d 	.word	0x03eb6f7d
   1e8d4:	3fd4d612 	.word	0x3fd4d612
   1e8d8:	55555555 	.word	0x55555555
   1e8dc:	3fc55555 	.word	0x3fc55555
   1e8e0:	b12e9282 	.word	0xb12e9282
   1e8e4:	3fb3b8c5 	.word	0x3fb3b8c5
   1e8e8:	1b8d0159 	.word	0x1b8d0159
   1e8ec:	3fe6066c 	.word	0x3fe6066c
   1e8f0:	9c598ac8 	.word	0x9c598ac8
   1e8f4:	40002ae5 	.word	0x40002ae5
   1e8f8:	1c8a2d4b 	.word	0x1c8a2d4b
   1e8fc:	40033a27 	.word	0x40033a27
   1e900:	54442d18 	.word	0x54442d18
   1e904:	400921fb 	.word	0x400921fb
   1e908:	33145c07 	.word	0x33145c07
   1e90c:	3c91a626 	.word	0x3c91a626
   1e910:	3fefffff 	.word	0x3fefffff
   1e914:	c0100000 	.word	0xc0100000
   1e918:	3fdfffff 	.word	0x3fdfffff
   1e91c:	3c600000 	.word	0x3c600000
   1e920:	3ff00000 	.word	0x3ff00000
   1e924:	3fe00000 	.word	0x3fe00000
   1e928:	ee10 0a10 	vmov	r0, s0
   1e92c:	4629      	mov	r1, r5
   1e92e:	2200      	movs	r2, #0
   1e930:	4b5d      	ldr	r3, [pc, #372]	; (1eaa8 <__ieee754_acos+0x4d8>)
   1e932:	f7fd fd8b 	bl	1c44c <__adddf3>
   1e936:	2200      	movs	r2, #0
   1e938:	4b5c      	ldr	r3, [pc, #368]	; (1eaac <__ieee754_acos+0x4dc>)
   1e93a:	f7fd ff3d 	bl	1c7b8 <__aeabi_dmul>
   1e93e:	4604      	mov	r4, r0
   1e940:	460d      	mov	r5, r1
   1e942:	a341      	add	r3, pc, #260	; (adr r3, 1ea48 <__ieee754_acos+0x478>)
   1e944:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e948:	f7fd ff36 	bl	1c7b8 <__aeabi_dmul>
   1e94c:	a340      	add	r3, pc, #256	; (adr r3, 1ea50 <__ieee754_acos+0x480>)
   1e94e:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e952:	f7fd fd7b 	bl	1c44c <__adddf3>
   1e956:	4622      	mov	r2, r4
   1e958:	462b      	mov	r3, r5
   1e95a:	f7fd ff2d 	bl	1c7b8 <__aeabi_dmul>
   1e95e:	a33e      	add	r3, pc, #248	; (adr r3, 1ea58 <__ieee754_acos+0x488>)
   1e960:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e964:	f7fd fd70 	bl	1c448 <__aeabi_dsub>
   1e968:	4622      	mov	r2, r4
   1e96a:	462b      	mov	r3, r5
   1e96c:	f7fd ff24 	bl	1c7b8 <__aeabi_dmul>
   1e970:	a33b      	add	r3, pc, #236	; (adr r3, 1ea60 <__ieee754_acos+0x490>)
   1e972:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e976:	f7fd fd69 	bl	1c44c <__adddf3>
   1e97a:	4622      	mov	r2, r4
   1e97c:	462b      	mov	r3, r5
   1e97e:	f7fd ff1b 	bl	1c7b8 <__aeabi_dmul>
   1e982:	a339      	add	r3, pc, #228	; (adr r3, 1ea68 <__ieee754_acos+0x498>)
   1e984:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e988:	f7fd fd5e 	bl	1c448 <__aeabi_dsub>
   1e98c:	4622      	mov	r2, r4
   1e98e:	462b      	mov	r3, r5
   1e990:	f7fd ff12 	bl	1c7b8 <__aeabi_dmul>
   1e994:	a336      	add	r3, pc, #216	; (adr r3, 1ea70 <__ieee754_acos+0x4a0>)
   1e996:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e99a:	f7fd fd57 	bl	1c44c <__adddf3>
   1e99e:	4622      	mov	r2, r4
   1e9a0:	462b      	mov	r3, r5
   1e9a2:	f7fd ff09 	bl	1c7b8 <__aeabi_dmul>
   1e9a6:	4680      	mov	r8, r0
   1e9a8:	4689      	mov	r9, r1
   1e9aa:	ec45 4b10 	vmov	d0, r4, r5
   1e9ae:	f01a fa83 	bl	38eb8 <__ieee754_sqrt>
   1e9b2:	4620      	mov	r0, r4
   1e9b4:	4629      	mov	r1, r5
   1e9b6:	a330      	add	r3, pc, #192	; (adr r3, 1ea78 <__ieee754_acos+0x4a8>)
   1e9b8:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e9bc:	ec57 6b10 	vmov	r6, r7, d0
   1e9c0:	f7fd fefa 	bl	1c7b8 <__aeabi_dmul>
   1e9c4:	a32e      	add	r3, pc, #184	; (adr r3, 1ea80 <__ieee754_acos+0x4b0>)
   1e9c6:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e9ca:	f7fd fd3d 	bl	1c448 <__aeabi_dsub>
   1e9ce:	4622      	mov	r2, r4
   1e9d0:	462b      	mov	r3, r5
   1e9d2:	f7fd fef1 	bl	1c7b8 <__aeabi_dmul>
   1e9d6:	a32c      	add	r3, pc, #176	; (adr r3, 1ea88 <__ieee754_acos+0x4b8>)
   1e9d8:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e9dc:	f7fd fd36 	bl	1c44c <__adddf3>
   1e9e0:	4622      	mov	r2, r4
   1e9e2:	462b      	mov	r3, r5
   1e9e4:	f7fd fee8 	bl	1c7b8 <__aeabi_dmul>
   1e9e8:	a329      	add	r3, pc, #164	; (adr r3, 1ea90 <__ieee754_acos+0x4c0>)
   1e9ea:	e9d3 2300 	ldrd	r2, r3, [r3]
   1e9ee:	f7fd fd2b 	bl	1c448 <__aeabi_dsub>
   1e9f2:	4622      	mov	r2, r4
   1e9f4:	462b      	mov	r3, r5
   1e9f6:	f7fd fedf 	bl	1c7b8 <__aeabi_dmul>
   1e9fa:	2200      	movs	r2, #0
   1e9fc:	4b2a      	ldr	r3, [pc, #168]	; (1eaa8 <__ieee754_acos+0x4d8>)
   1e9fe:	f7fd fd25 	bl	1c44c <__adddf3>
   1ea02:	4602      	mov	r2, r0
   1ea04:	460b      	mov	r3, r1
   1ea06:	4640      	mov	r0, r8
   1ea08:	4649      	mov	r1, r9
   1ea0a:	f7fd ffff 	bl	1ca0c <__aeabi_ddiv>
   1ea0e:	4632      	mov	r2, r6
   1ea10:	463b      	mov	r3, r7
   1ea12:	f7fd fed1 	bl	1c7b8 <__aeabi_dmul>
   1ea16:	a320      	add	r3, pc, #128	; (adr r3, 1ea98 <__ieee754_acos+0x4c8>)
   1ea18:	e9d3 2300 	ldrd	r2, r3, [r3]
   1ea1c:	f7fd fd14 	bl	1c448 <__aeabi_dsub>
   1ea20:	4632      	mov	r2, r6
   1ea22:	463b      	mov	r3, r7
   1ea24:	f7fd fd12 	bl	1c44c <__adddf3>
   1ea28:	4602      	mov	r2, r0
   1ea2a:	460b      	mov	r3, r1
   1ea2c:	f7fd fd0e 	bl	1c44c <__adddf3>
   1ea30:	4602      	mov	r2, r0
   1ea32:	460b      	mov	r3, r1
   1ea34:	a11a      	add	r1, pc, #104	; (adr r1, 1eaa0 <__ieee754_acos+0x4d0>)
   1ea36:	e9d1 0100 	ldrd	r0, r1, [r1]
   1ea3a:	f7fd fd05 	bl	1c448 <__aeabi_dsub>
   1ea3e:	ec41 0b10 	vmov	d0, r0, r1
   1ea42:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ea46:	bf00      	nop
   1ea48:	0dfdf709 	.word	0x0dfdf709
   1ea4c:	3f023de1 	.word	0x3f023de1
   1ea50:	7501b288 	.word	0x7501b288
   1ea54:	3f49efe0 	.word	0x3f49efe0
   1ea58:	b5688f3b 	.word	0xb5688f3b
   1ea5c:	3fa48228 	.word	0x3fa48228
   1ea60:	0e884455 	.word	0x0e884455
   1ea64:	3fc9c155 	.word	0x3fc9c155
   1ea68:	03eb6f7d 	.word	0x03eb6f7d
   1ea6c:	3fd4d612 	.word	0x3fd4d612
   1ea70:	55555555 	.word	0x55555555
   1ea74:	3fc55555 	.word	0x3fc55555
   1ea78:	b12e9282 	.word	0xb12e9282
   1ea7c:	3fb3b8c5 	.word	0x3fb3b8c5
   1ea80:	1b8d0159 	.word	0x1b8d0159
   1ea84:	3fe6066c 	.word	0x3fe6066c
   1ea88:	9c598ac8 	.word	0x9c598ac8
   1ea8c:	40002ae5 	.word	0x40002ae5
   1ea90:	1c8a2d4b 	.word	0x1c8a2d4b
   1ea94:	40033a27 	.word	0x40033a27
   1ea98:	33145c07 	.word	0x33145c07
   1ea9c:	3c91a626 	.word	0x3c91a626
   1eaa0:	54442d18 	.word	0x54442d18
   1eaa4:	400921fb 	.word	0x400921fb
   1eaa8:	3ff00000 	.word	0x3ff00000
   1eaac:	3fe00000 	.word	0x3fe00000

0001eab0 <__ieee754_pow>:
   1eab0:	ec51 0b11 	vmov	r0, r1, d1
   1eab4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1eab8:	f021 4800 	bic.w	r8, r1, #2147483648	; 0x80000000
   1eabc:	b093      	sub	sp, #76	; 0x4c
   1eabe:	ea58 0400 	orrs.w	r4, r8, r0
   1eac2:	d020      	beq.n	1eb06 <__ieee754_pow+0x56>
   1eac4:	4c5c      	ldr	r4, [pc, #368]	; (1ec38 <__ieee754_pow+0x188>)
   1eac6:	ee10 aa10 	vmov	sl, s0
   1eaca:	ec53 2b10 	vmov	r2, r3, d0
   1eace:	f023 4600 	bic.w	r6, r3, #2147483648	; 0x80000000
   1ead2:	461f      	mov	r7, r3
   1ead4:	42a6      	cmp	r6, r4
   1ead6:	dc11      	bgt.n	1eafc <__ieee754_pow+0x4c>
   1ead8:	4689      	mov	r9, r1
   1eada:	ee11 ca10 	vmov	ip, s2
   1eade:	d106      	bne.n	1eaee <__ieee754_pow+0x3e>
   1eae0:	b12a      	cbz	r2, 1eaee <__ieee754_pow+0x3e>
   1eae2:	4856      	ldr	r0, [pc, #344]	; (1ec3c <__ieee754_pow+0x18c>)
   1eae4:	b013      	add	sp, #76	; 0x4c
   1eae6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1eaea:	f000 bd61 	b.w	1f5b0 <nan>
   1eaee:	4c52      	ldr	r4, [pc, #328]	; (1ec38 <__ieee754_pow+0x188>)
   1eaf0:	45a0      	cmp	r8, r4
   1eaf2:	dc03      	bgt.n	1eafc <__ieee754_pow+0x4c>
   1eaf4:	d10e      	bne.n	1eb14 <__ieee754_pow+0x64>
   1eaf6:	f1bc 0f00 	cmp.w	ip, #0
   1eafa:	d00b      	beq.n	1eb14 <__ieee754_pow+0x64>
   1eafc:	4b50      	ldr	r3, [pc, #320]	; (1ec40 <__ieee754_pow+0x190>)
   1eafe:	4433      	add	r3, r6
   1eb00:	ea53 030a 	orrs.w	r3, r3, sl
   1eb04:	d1ed      	bne.n	1eae2 <__ieee754_pow+0x32>
   1eb06:	2000      	movs	r0, #0
   1eb08:	494e      	ldr	r1, [pc, #312]	; (1ec44 <__ieee754_pow+0x194>)
   1eb0a:	ec41 0b10 	vmov	d0, r0, r1
   1eb0e:	b013      	add	sp, #76	; 0x4c
   1eb10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1eb14:	2f00      	cmp	r7, #0
   1eb16:	4614      	mov	r4, r2
   1eb18:	461d      	mov	r5, r3
   1eb1a:	e9cd 0100 	strd	r0, r1, [sp]
   1eb1e:	db44      	blt.n	1ebaa <__ieee754_pow+0xfa>
   1eb20:	f04f 0b00 	mov.w	fp, #0
   1eb24:	f1bc 0f00 	cmp.w	ip, #0
   1eb28:	d10f      	bne.n	1eb4a <__ieee754_pow+0x9a>
   1eb2a:	4b43      	ldr	r3, [pc, #268]	; (1ec38 <__ieee754_pow+0x188>)
   1eb2c:	4598      	cmp	r8, r3
   1eb2e:	d057      	beq.n	1ebe0 <__ieee754_pow+0x130>
   1eb30:	4b44      	ldr	r3, [pc, #272]	; (1ec44 <__ieee754_pow+0x194>)
   1eb32:	4598      	cmp	r8, r3
   1eb34:	d067      	beq.n	1ec06 <__ieee754_pow+0x156>
   1eb36:	f1b9 4f80 	cmp.w	r9, #1073741824	; 0x40000000
   1eb3a:	f000 84a9 	beq.w	1f490 <__ieee754_pow+0x9e0>
   1eb3e:	4b42      	ldr	r3, [pc, #264]	; (1ec48 <__ieee754_pow+0x198>)
   1eb40:	4599      	cmp	r9, r3
   1eb42:	d102      	bne.n	1eb4a <__ieee754_pow+0x9a>
   1eb44:	2f00      	cmp	r7, #0
   1eb46:	f280 84f1 	bge.w	1f52c <__ieee754_pow+0xa7c>
   1eb4a:	ec45 4b10 	vmov	d0, r4, r5
   1eb4e:	f01a f935 	bl	38dbc <fabs>
   1eb52:	ec51 0b10 	vmov	r0, r1, d0
   1eb56:	f1ba 0f00 	cmp.w	sl, #0
   1eb5a:	d108      	bne.n	1eb6e <__ieee754_pow+0xbe>
   1eb5c:	f027 4340 	bic.w	r3, r7, #3221225472	; 0xc0000000
   1eb60:	4a38      	ldr	r2, [pc, #224]	; (1ec44 <__ieee754_pow+0x194>)
   1eb62:	4293      	cmp	r3, r2
   1eb64:	f000 8395 	beq.w	1f292 <__ieee754_pow+0x7e2>
   1eb68:	2e00      	cmp	r6, #0
   1eb6a:	f000 8392 	beq.w	1f292 <__ieee754_pow+0x7e2>
   1eb6e:	0ffb      	lsrs	r3, r7, #31
   1eb70:	f103 3aff 	add.w	sl, r3, #4294967295
   1eb74:	ea5b 030a 	orrs.w	r3, fp, sl
   1eb78:	d04c      	beq.n	1ec14 <__ieee754_pow+0x164>
   1eb7a:	4b34      	ldr	r3, [pc, #208]	; (1ec4c <__ieee754_pow+0x19c>)
   1eb7c:	4598      	cmp	r8, r3
   1eb7e:	dd6b      	ble.n	1ec58 <__ieee754_pow+0x1a8>
   1eb80:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
   1eb84:	4598      	cmp	r8, r3
   1eb86:	f340 8411 	ble.w	1f3ac <__ieee754_pow+0x8fc>
   1eb8a:	4b31      	ldr	r3, [pc, #196]	; (1ec50 <__ieee754_pow+0x1a0>)
   1eb8c:	429e      	cmp	r6, r3
   1eb8e:	f340 8395 	ble.w	1f2bc <__ieee754_pow+0x80c>
   1eb92:	f1b9 0f00 	cmp.w	r9, #0
   1eb96:	f340 8395 	ble.w	1f2c4 <__ieee754_pow+0x814>
   1eb9a:	a325      	add	r3, pc, #148	; (adr r3, 1ec30 <__ieee754_pow+0x180>)
   1eb9c:	e9d3 2300 	ldrd	r2, r3, [r3]
   1eba0:	4610      	mov	r0, r2
   1eba2:	4619      	mov	r1, r3
   1eba4:	f7fd fe08 	bl	1c7b8 <__aeabi_dmul>
   1eba8:	e7af      	b.n	1eb0a <__ieee754_pow+0x5a>
   1ebaa:	4b2a      	ldr	r3, [pc, #168]	; (1ec54 <__ieee754_pow+0x1a4>)
   1ebac:	4598      	cmp	r8, r3
   1ebae:	dc27      	bgt.n	1ec00 <__ieee754_pow+0x150>
   1ebb0:	f1a3 7354 	sub.w	r3, r3, #55574528	; 0x3500000
   1ebb4:	4598      	cmp	r8, r3
   1ebb6:	ddb3      	ble.n	1eb20 <__ieee754_pow+0x70>
   1ebb8:	ea4f 5328 	mov.w	r3, r8, asr #20
   1ebbc:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
   1ebc0:	2b14      	cmp	r3, #20
   1ebc2:	f340 846d 	ble.w	1f4a0 <__ieee754_pow+0x9f0>
   1ebc6:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
   1ebca:	fa2c f203 	lsr.w	r2, ip, r3
   1ebce:	fa02 f303 	lsl.w	r3, r2, r3
   1ebd2:	4563      	cmp	r3, ip
   1ebd4:	d1a4      	bne.n	1eb20 <__ieee754_pow+0x70>
   1ebd6:	f002 0201 	and.w	r2, r2, #1
   1ebda:	f1c2 0b02 	rsb	fp, r2, #2
   1ebde:	e7a1      	b.n	1eb24 <__ieee754_pow+0x74>
   1ebe0:	4b17      	ldr	r3, [pc, #92]	; (1ec40 <__ieee754_pow+0x190>)
   1ebe2:	4433      	add	r3, r6
   1ebe4:	ea53 030a 	orrs.w	r3, r3, sl
   1ebe8:	d08d      	beq.n	1eb06 <__ieee754_pow+0x56>
   1ebea:	4b19      	ldr	r3, [pc, #100]	; (1ec50 <__ieee754_pow+0x1a0>)
   1ebec:	429e      	cmp	r6, r3
   1ebee:	f340 8394 	ble.w	1f31a <__ieee754_pow+0x86a>
   1ebf2:	f1b9 0f00 	cmp.w	r9, #0
   1ebf6:	f2c0 8365 	blt.w	1f2c4 <__ieee754_pow+0x814>
   1ebfa:	e9dd 0100 	ldrd	r0, r1, [sp]
   1ebfe:	e784      	b.n	1eb0a <__ieee754_pow+0x5a>
   1ec00:	f04f 0b02 	mov.w	fp, #2
   1ec04:	e78e      	b.n	1eb24 <__ieee754_pow+0x74>
   1ec06:	f1b9 0f00 	cmp.w	r9, #0
   1ec0a:	f2c0 8439 	blt.w	1f480 <__ieee754_pow+0x9d0>
   1ec0e:	4620      	mov	r0, r4
   1ec10:	4629      	mov	r1, r5
   1ec12:	e77a      	b.n	1eb0a <__ieee754_pow+0x5a>
   1ec14:	4622      	mov	r2, r4
   1ec16:	462b      	mov	r3, r5
   1ec18:	4610      	mov	r0, r2
   1ec1a:	4619      	mov	r1, r3
   1ec1c:	f7fd fc14 	bl	1c448 <__aeabi_dsub>
   1ec20:	4602      	mov	r2, r0
   1ec22:	460b      	mov	r3, r1
   1ec24:	f7fd fef2 	bl	1ca0c <__aeabi_ddiv>
   1ec28:	e76f      	b.n	1eb0a <__ieee754_pow+0x5a>
   1ec2a:	bf00      	nop
   1ec2c:	f3af 8000 	nop.w
   1ec30:	8800759c 	.word	0x8800759c
   1ec34:	7e37e43c 	.word	0x7e37e43c
   1ec38:	7ff00000 	.word	0x7ff00000
   1ec3c:	0004025c 	.word	0x0004025c
   1ec40:	c0100000 	.word	0xc0100000
   1ec44:	3ff00000 	.word	0x3ff00000
   1ec48:	3fe00000 	.word	0x3fe00000
   1ec4c:	41e00000 	.word	0x41e00000
   1ec50:	3fefffff 	.word	0x3fefffff
   1ec54:	433fffff 	.word	0x433fffff
   1ec58:	4bd3      	ldr	r3, [pc, #844]	; (1efa8 <__ieee754_pow+0x4f8>)
   1ec5a:	403b      	ands	r3, r7
   1ec5c:	2b00      	cmp	r3, #0
   1ec5e:	f040 840c 	bne.w	1f47a <__ieee754_pow+0x9ca>
   1ec62:	2200      	movs	r2, #0
   1ec64:	4bd1      	ldr	r3, [pc, #836]	; (1efac <__ieee754_pow+0x4fc>)
   1ec66:	f7fd fda7 	bl	1c7b8 <__aeabi_dmul>
   1ec6a:	f06f 0534 	mvn.w	r5, #52	; 0x34
   1ec6e:	460e      	mov	r6, r1
   1ec70:	1533      	asrs	r3, r6, #20
   1ec72:	4acf      	ldr	r2, [pc, #828]	; (1efb0 <__ieee754_pow+0x500>)
   1ec74:	f3c6 0613 	ubfx	r6, r6, #0, #20
   1ec78:	4cce      	ldr	r4, [pc, #824]	; (1efb4 <__ieee754_pow+0x504>)
   1ec7a:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
   1ec7e:	4296      	cmp	r6, r2
   1ec80:	ea44 0406 	orr.w	r4, r4, r6
   1ec84:	441d      	add	r5, r3
   1ec86:	950b      	str	r5, [sp, #44]	; 0x2c
   1ec88:	f340 83eb 	ble.w	1f462 <__ieee754_pow+0x9b2>
   1ec8c:	4bca      	ldr	r3, [pc, #808]	; (1efb8 <__ieee754_pow+0x508>)
   1ec8e:	429e      	cmp	r6, r3
   1ec90:	f340 842b 	ble.w	1f4ea <__ieee754_pow+0xa3a>
   1ec94:	3501      	adds	r5, #1
   1ec96:	f5a4 1480 	sub.w	r4, r4, #1048576	; 0x100000
   1ec9a:	ed9f 7bad 	vldr	d7, [pc, #692]	; 1ef50 <__ieee754_pow+0x4a0>
   1ec9e:	950b      	str	r5, [sp, #44]	; 0x2c
   1eca0:	2500      	movs	r5, #0
   1eca2:	ed8d 7b08 	vstr	d7, [sp, #32]
   1eca6:	ed9f 7bac 	vldr	d7, [pc, #688]	; 1ef58 <__ieee754_pow+0x4a8>
   1ecaa:	ed8d 7b06 	vstr	d7, [sp, #24]
   1ecae:	ed9f 7ba8 	vldr	d7, [pc, #672]	; 1ef50 <__ieee754_pow+0x4a0>
   1ecb2:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
   1ecb6:	4680      	mov	r8, r0
   1ecb8:	46a1      	mov	r9, r4
   1ecba:	4621      	mov	r1, r4
   1ecbc:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   1ecc0:	f7fd fbc2 	bl	1c448 <__aeabi_dsub>
   1ecc4:	4606      	mov	r6, r0
   1ecc6:	460f      	mov	r7, r1
   1ecc8:	4640      	mov	r0, r8
   1ecca:	4621      	mov	r1, r4
   1eccc:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   1ecd0:	e9cd 890c 	strd	r8, r9, [sp, #48]	; 0x30
   1ecd4:	f7fd fbba 	bl	1c44c <__adddf3>
   1ecd8:	4602      	mov	r2, r0
   1ecda:	460b      	mov	r3, r1
   1ecdc:	2000      	movs	r0, #0
   1ecde:	49b5      	ldr	r1, [pc, #724]	; (1efb4 <__ieee754_pow+0x504>)
   1ece0:	f7fd fe94 	bl	1ca0c <__aeabi_ddiv>
   1ece4:	460a      	mov	r2, r1
   1ece6:	4601      	mov	r1, r0
   1ece8:	4613      	mov	r3, r2
   1ecea:	e9cd 120e 	strd	r1, r2, [sp, #56]	; 0x38
   1ecee:	4602      	mov	r2, r0
   1ecf0:	4639      	mov	r1, r7
   1ecf2:	4630      	mov	r0, r6
   1ecf4:	f7fd fd60 	bl	1c7b8 <__aeabi_dmul>
   1ecf8:	4680      	mov	r8, r0
   1ecfa:	1063      	asrs	r3, r4, #1
   1ecfc:	4689      	mov	r9, r1
   1ecfe:	2400      	movs	r4, #0
   1ed00:	2000      	movs	r0, #0
   1ed02:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   1ed06:	4602      	mov	r2, r0
   1ed08:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
   1ed0c:	e9cd 8902 	strd	r8, r9, [sp, #8]
   1ed10:	9402      	str	r4, [sp, #8]
   1ed12:	1959      	adds	r1, r3, r5
   1ed14:	4604      	mov	r4, r0
   1ed16:	460d      	mov	r5, r1
   1ed18:	460b      	mov	r3, r1
   1ed1a:	e9cd 8904 	strd	r8, r9, [sp, #16]
   1ed1e:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
   1ed22:	4640      	mov	r0, r8
   1ed24:	4649      	mov	r1, r9
   1ed26:	f7fd fd47 	bl	1c7b8 <__aeabi_dmul>
   1ed2a:	4602      	mov	r2, r0
   1ed2c:	460b      	mov	r3, r1
   1ed2e:	4630      	mov	r0, r6
   1ed30:	4639      	mov	r1, r7
   1ed32:	f7fd fb89 	bl	1c448 <__aeabi_dsub>
   1ed36:	4606      	mov	r6, r0
   1ed38:	460f      	mov	r7, r1
   1ed3a:	4620      	mov	r0, r4
   1ed3c:	4629      	mov	r1, r5
   1ed3e:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   1ed42:	f7fd fb81 	bl	1c448 <__aeabi_dsub>
   1ed46:	4602      	mov	r2, r0
   1ed48:	460b      	mov	r3, r1
   1ed4a:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   1ed4e:	f7fd fb7b 	bl	1c448 <__aeabi_dsub>
   1ed52:	4642      	mov	r2, r8
   1ed54:	464b      	mov	r3, r9
   1ed56:	f7fd fd2f 	bl	1c7b8 <__aeabi_dmul>
   1ed5a:	4602      	mov	r2, r0
   1ed5c:	460b      	mov	r3, r1
   1ed5e:	4630      	mov	r0, r6
   1ed60:	4639      	mov	r1, r7
   1ed62:	f7fd fb71 	bl	1c448 <__aeabi_dsub>
   1ed66:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
   1ed6a:	f7fd fd25 	bl	1c7b8 <__aeabi_dmul>
   1ed6e:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
   1ed72:	e9cd 0106 	strd	r0, r1, [sp, #24]
   1ed76:	4622      	mov	r2, r4
   1ed78:	462b      	mov	r3, r5
   1ed7a:	4620      	mov	r0, r4
   1ed7c:	4629      	mov	r1, r5
   1ed7e:	f7fd fd1b 	bl	1c7b8 <__aeabi_dmul>
   1ed82:	4604      	mov	r4, r0
   1ed84:	460d      	mov	r5, r1
   1ed86:	a376      	add	r3, pc, #472	; (adr r3, 1ef60 <__ieee754_pow+0x4b0>)
   1ed88:	e9d3 2300 	ldrd	r2, r3, [r3]
   1ed8c:	f7fd fd14 	bl	1c7b8 <__aeabi_dmul>
   1ed90:	a375      	add	r3, pc, #468	; (adr r3, 1ef68 <__ieee754_pow+0x4b8>)
   1ed92:	e9d3 2300 	ldrd	r2, r3, [r3]
   1ed96:	f7fd fb59 	bl	1c44c <__adddf3>
   1ed9a:	4622      	mov	r2, r4
   1ed9c:	462b      	mov	r3, r5
   1ed9e:	f7fd fd0b 	bl	1c7b8 <__aeabi_dmul>
   1eda2:	a373      	add	r3, pc, #460	; (adr r3, 1ef70 <__ieee754_pow+0x4c0>)
   1eda4:	e9d3 2300 	ldrd	r2, r3, [r3]
   1eda8:	f7fd fb50 	bl	1c44c <__adddf3>
   1edac:	4622      	mov	r2, r4
   1edae:	462b      	mov	r3, r5
   1edb0:	f7fd fd02 	bl	1c7b8 <__aeabi_dmul>
   1edb4:	a370      	add	r3, pc, #448	; (adr r3, 1ef78 <__ieee754_pow+0x4c8>)
   1edb6:	e9d3 2300 	ldrd	r2, r3, [r3]
   1edba:	f7fd fb47 	bl	1c44c <__adddf3>
   1edbe:	4622      	mov	r2, r4
   1edc0:	462b      	mov	r3, r5
   1edc2:	f7fd fcf9 	bl	1c7b8 <__aeabi_dmul>
   1edc6:	a36e      	add	r3, pc, #440	; (adr r3, 1ef80 <__ieee754_pow+0x4d0>)
   1edc8:	e9d3 2300 	ldrd	r2, r3, [r3]
   1edcc:	f7fd fb3e 	bl	1c44c <__adddf3>
   1edd0:	4622      	mov	r2, r4
   1edd2:	462b      	mov	r3, r5
   1edd4:	f7fd fcf0 	bl	1c7b8 <__aeabi_dmul>
   1edd8:	a36b      	add	r3, pc, #428	; (adr r3, 1ef88 <__ieee754_pow+0x4d8>)
   1edda:	e9d3 2300 	ldrd	r2, r3, [r3]
   1edde:	f7fd fb35 	bl	1c44c <__adddf3>
   1ede2:	4606      	mov	r6, r0
   1ede4:	460f      	mov	r7, r1
   1ede6:	4622      	mov	r2, r4
   1ede8:	462b      	mov	r3, r5
   1edea:	4620      	mov	r0, r4
   1edec:	4629      	mov	r1, r5
   1edee:	f7fd fce3 	bl	1c7b8 <__aeabi_dmul>
   1edf2:	4602      	mov	r2, r0
   1edf4:	460b      	mov	r3, r1
   1edf6:	4630      	mov	r0, r6
   1edf8:	4639      	mov	r1, r7
   1edfa:	f7fd fcdd 	bl	1c7b8 <__aeabi_dmul>
   1edfe:	4642      	mov	r2, r8
   1ee00:	4604      	mov	r4, r0
   1ee02:	460d      	mov	r5, r1
   1ee04:	464b      	mov	r3, r9
   1ee06:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   1ee0a:	f7fd fb1f 	bl	1c44c <__adddf3>
   1ee0e:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   1ee12:	f7fd fcd1 	bl	1c7b8 <__aeabi_dmul>
   1ee16:	4622      	mov	r2, r4
   1ee18:	462b      	mov	r3, r5
   1ee1a:	f7fd fb17 	bl	1c44c <__adddf3>
   1ee1e:	4642      	mov	r2, r8
   1ee20:	4604      	mov	r4, r0
   1ee22:	460d      	mov	r5, r1
   1ee24:	464b      	mov	r3, r9
   1ee26:	4640      	mov	r0, r8
   1ee28:	4649      	mov	r1, r9
   1ee2a:	f7fd fcc5 	bl	1c7b8 <__aeabi_dmul>
   1ee2e:	2200      	movs	r2, #0
   1ee30:	4b62      	ldr	r3, [pc, #392]	; (1efbc <__ieee754_pow+0x50c>)
   1ee32:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   1ee36:	f7fd fb09 	bl	1c44c <__adddf3>
   1ee3a:	4622      	mov	r2, r4
   1ee3c:	462b      	mov	r3, r5
   1ee3e:	f7fd fb05 	bl	1c44c <__adddf3>
   1ee42:	9802      	ldr	r0, [sp, #8]
   1ee44:	460f      	mov	r7, r1
   1ee46:	4649      	mov	r1, r9
   1ee48:	4606      	mov	r6, r0
   1ee4a:	4640      	mov	r0, r8
   1ee4c:	463b      	mov	r3, r7
   1ee4e:	4632      	mov	r2, r6
   1ee50:	f7fd fcb2 	bl	1c7b8 <__aeabi_dmul>
   1ee54:	2200      	movs	r2, #0
   1ee56:	4680      	mov	r8, r0
   1ee58:	4689      	mov	r9, r1
   1ee5a:	4b58      	ldr	r3, [pc, #352]	; (1efbc <__ieee754_pow+0x50c>)
   1ee5c:	4630      	mov	r0, r6
   1ee5e:	4639      	mov	r1, r7
   1ee60:	f7fd faf2 	bl	1c448 <__aeabi_dsub>
   1ee64:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   1ee68:	f7fd faee 	bl	1c448 <__aeabi_dsub>
   1ee6c:	4602      	mov	r2, r0
   1ee6e:	460b      	mov	r3, r1
   1ee70:	4620      	mov	r0, r4
   1ee72:	4629      	mov	r1, r5
   1ee74:	f7fd fae8 	bl	1c448 <__aeabi_dsub>
   1ee78:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1ee7c:	f7fd fc9c 	bl	1c7b8 <__aeabi_dmul>
   1ee80:	4604      	mov	r4, r0
   1ee82:	460d      	mov	r5, r1
   1ee84:	4632      	mov	r2, r6
   1ee86:	463b      	mov	r3, r7
   1ee88:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   1ee8c:	f7fd fc94 	bl	1c7b8 <__aeabi_dmul>
   1ee90:	4602      	mov	r2, r0
   1ee92:	460b      	mov	r3, r1
   1ee94:	4620      	mov	r0, r4
   1ee96:	4629      	mov	r1, r5
   1ee98:	f7fd fad8 	bl	1c44c <__adddf3>
   1ee9c:	4604      	mov	r4, r0
   1ee9e:	460d      	mov	r5, r1
   1eea0:	4602      	mov	r2, r0
   1eea2:	460b      	mov	r3, r1
   1eea4:	4640      	mov	r0, r8
   1eea6:	4649      	mov	r1, r9
   1eea8:	f7fd fad0 	bl	1c44c <__adddf3>
   1eeac:	9802      	ldr	r0, [sp, #8]
   1eeae:	460f      	mov	r7, r1
   1eeb0:	4606      	mov	r6, r0
   1eeb2:	a337      	add	r3, pc, #220	; (adr r3, 1ef90 <__ieee754_pow+0x4e0>)
   1eeb4:	e9d3 2300 	ldrd	r2, r3, [r3]
   1eeb8:	f7fd fc7e 	bl	1c7b8 <__aeabi_dmul>
   1eebc:	4642      	mov	r2, r8
   1eebe:	464b      	mov	r3, r9
   1eec0:	e9cd 0104 	strd	r0, r1, [sp, #16]
   1eec4:	4630      	mov	r0, r6
   1eec6:	4639      	mov	r1, r7
   1eec8:	f7fd fabe 	bl	1c448 <__aeabi_dsub>
   1eecc:	4602      	mov	r2, r0
   1eece:	460b      	mov	r3, r1
   1eed0:	4620      	mov	r0, r4
   1eed2:	4629      	mov	r1, r5
   1eed4:	f7fd fab8 	bl	1c448 <__aeabi_dsub>
   1eed8:	a32f      	add	r3, pc, #188	; (adr r3, 1ef98 <__ieee754_pow+0x4e8>)
   1eeda:	e9d3 2300 	ldrd	r2, r3, [r3]
   1eede:	f7fd fc6b 	bl	1c7b8 <__aeabi_dmul>
   1eee2:	4604      	mov	r4, r0
   1eee4:	460d      	mov	r5, r1
   1eee6:	4630      	mov	r0, r6
   1eee8:	4639      	mov	r1, r7
   1eeea:	a32d      	add	r3, pc, #180	; (adr r3, 1efa0 <__ieee754_pow+0x4f0>)
   1eeec:	e9d3 2300 	ldrd	r2, r3, [r3]
   1eef0:	f7fd fc62 	bl	1c7b8 <__aeabi_dmul>
   1eef4:	4602      	mov	r2, r0
   1eef6:	460b      	mov	r3, r1
   1eef8:	4620      	mov	r0, r4
   1eefa:	4629      	mov	r1, r5
   1eefc:	f7fd faa6 	bl	1c44c <__adddf3>
   1ef00:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
   1ef04:	f7fd faa2 	bl	1c44c <__adddf3>
   1ef08:	4606      	mov	r6, r0
   1ef0a:	460f      	mov	r7, r1
   1ef0c:	980b      	ldr	r0, [sp, #44]	; 0x2c
   1ef0e:	f7fd fbe9 	bl	1c6e4 <__aeabi_i2d>
   1ef12:	4632      	mov	r2, r6
   1ef14:	4680      	mov	r8, r0
   1ef16:	4689      	mov	r9, r1
   1ef18:	463b      	mov	r3, r7
   1ef1a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   1ef1e:	f7fd fa95 	bl	1c44c <__adddf3>
   1ef22:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   1ef26:	f7fd fa91 	bl	1c44c <__adddf3>
   1ef2a:	4642      	mov	r2, r8
   1ef2c:	464b      	mov	r3, r9
   1ef2e:	f7fd fa8d 	bl	1c44c <__adddf3>
   1ef32:	9802      	ldr	r0, [sp, #8]
   1ef34:	4642      	mov	r2, r8
   1ef36:	464b      	mov	r3, r9
   1ef38:	4604      	mov	r4, r0
   1ef3a:	460d      	mov	r5, r1
   1ef3c:	f7fd fa84 	bl	1c448 <__aeabi_dsub>
   1ef40:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   1ef44:	f7fd fa80 	bl	1c448 <__aeabi_dsub>
   1ef48:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1ef4c:	e038      	b.n	1efc0 <__ieee754_pow+0x510>
   1ef4e:	bf00      	nop
	...
   1ef5c:	3ff00000 	.word	0x3ff00000
   1ef60:	4a454eef 	.word	0x4a454eef
   1ef64:	3fca7e28 	.word	0x3fca7e28
   1ef68:	93c9db65 	.word	0x93c9db65
   1ef6c:	3fcd864a 	.word	0x3fcd864a
   1ef70:	a91d4101 	.word	0xa91d4101
   1ef74:	3fd17460 	.word	0x3fd17460
   1ef78:	518f264d 	.word	0x518f264d
   1ef7c:	3fd55555 	.word	0x3fd55555
   1ef80:	db6fabff 	.word	0xdb6fabff
   1ef84:	3fdb6db6 	.word	0x3fdb6db6
   1ef88:	33333303 	.word	0x33333303
   1ef8c:	3fe33333 	.word	0x3fe33333
   1ef90:	e0000000 	.word	0xe0000000
   1ef94:	3feec709 	.word	0x3feec709
   1ef98:	dc3a03fd 	.word	0xdc3a03fd
   1ef9c:	3feec709 	.word	0x3feec709
   1efa0:	145b01f5 	.word	0x145b01f5
   1efa4:	be3e2fe0 	.word	0xbe3e2fe0
   1efa8:	7ff00000 	.word	0x7ff00000
   1efac:	43400000 	.word	0x43400000
   1efb0:	0003988e 	.word	0x0003988e
   1efb4:	3ff00000 	.word	0x3ff00000
   1efb8:	000bb679 	.word	0x000bb679
   1efbc:	40080000 	.word	0x40080000
   1efc0:	f7fd fa42 	bl	1c448 <__aeabi_dsub>
   1efc4:	460b      	mov	r3, r1
   1efc6:	4602      	mov	r2, r0
   1efc8:	4639      	mov	r1, r7
   1efca:	4630      	mov	r0, r6
   1efcc:	f7fd fa3c 	bl	1c448 <__aeabi_dsub>
   1efd0:	f10b 33ff 	add.w	r3, fp, #4294967295
   1efd4:	ea53 030a 	orrs.w	r3, r3, sl
   1efd8:	e9cd 0102 	strd	r0, r1, [sp, #8]
   1efdc:	f040 8175 	bne.w	1f2ca <__ieee754_pow+0x81a>
   1efe0:	ed9f 7bd3 	vldr	d7, [pc, #844]	; 1f330 <__ieee754_pow+0x880>
   1efe4:	ed8d 7b04 	vstr	d7, [sp, #16]
   1efe8:	e9dd ab00 	ldrd	sl, fp, [sp]
   1efec:	4652      	mov	r2, sl
   1efee:	465b      	mov	r3, fp
   1eff0:	4650      	mov	r0, sl
   1eff2:	4659      	mov	r1, fp
   1eff4:	e9cd 2300 	strd	r2, r3, [sp]
   1eff8:	2300      	movs	r3, #0
   1effa:	9300      	str	r3, [sp, #0]
   1effc:	e9dd 6700 	ldrd	r6, r7, [sp]
   1f000:	4632      	mov	r2, r6
   1f002:	463b      	mov	r3, r7
   1f004:	f7fd fa20 	bl	1c448 <__aeabi_dsub>
   1f008:	4622      	mov	r2, r4
   1f00a:	462b      	mov	r3, r5
   1f00c:	f7fd fbd4 	bl	1c7b8 <__aeabi_dmul>
   1f010:	4680      	mov	r8, r0
   1f012:	4689      	mov	r9, r1
   1f014:	4652      	mov	r2, sl
   1f016:	465b      	mov	r3, fp
   1f018:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1f01c:	f7fd fbcc 	bl	1c7b8 <__aeabi_dmul>
   1f020:	4602      	mov	r2, r0
   1f022:	460b      	mov	r3, r1
   1f024:	4640      	mov	r0, r8
   1f026:	4649      	mov	r1, r9
   1f028:	f7fd fa10 	bl	1c44c <__adddf3>
   1f02c:	468b      	mov	fp, r1
   1f02e:	4682      	mov	sl, r0
   1f030:	4632      	mov	r2, r6
   1f032:	463b      	mov	r3, r7
   1f034:	4620      	mov	r0, r4
   1f036:	4629      	mov	r1, r5
   1f038:	e9cd ab02 	strd	sl, fp, [sp, #8]
   1f03c:	f7fd fbbc 	bl	1c7b8 <__aeabi_dmul>
   1f040:	460b      	mov	r3, r1
   1f042:	4602      	mov	r2, r0
   1f044:	4680      	mov	r8, r0
   1f046:	4689      	mov	r9, r1
   1f048:	4650      	mov	r0, sl
   1f04a:	4659      	mov	r1, fp
   1f04c:	f7fd f9fe 	bl	1c44c <__adddf3>
   1f050:	4bcf      	ldr	r3, [pc, #828]	; (1f390 <__ieee754_pow+0x8e0>)
   1f052:	4604      	mov	r4, r0
   1f054:	460d      	mov	r5, r1
   1f056:	4299      	cmp	r1, r3
   1f058:	468b      	mov	fp, r1
   1f05a:	f340 813b 	ble.w	1f2d4 <__ieee754_pow+0x824>
   1f05e:	4bcd      	ldr	r3, [pc, #820]	; (1f394 <__ieee754_pow+0x8e4>)
   1f060:	440b      	add	r3, r1
   1f062:	4303      	orrs	r3, r0
   1f064:	f040 8233 	bne.w	1f4ce <__ieee754_pow+0xa1e>
   1f068:	a3b3      	add	r3, pc, #716	; (adr r3, 1f338 <__ieee754_pow+0x888>)
   1f06a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f06e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1f072:	f7fd f9eb 	bl	1c44c <__adddf3>
   1f076:	4606      	mov	r6, r0
   1f078:	460f      	mov	r7, r1
   1f07a:	4642      	mov	r2, r8
   1f07c:	464b      	mov	r3, r9
   1f07e:	4620      	mov	r0, r4
   1f080:	4629      	mov	r1, r5
   1f082:	f7fd f9e1 	bl	1c448 <__aeabi_dsub>
   1f086:	4602      	mov	r2, r0
   1f088:	460b      	mov	r3, r1
   1f08a:	4630      	mov	r0, r6
   1f08c:	4639      	mov	r1, r7
   1f08e:	f7fd fe23 	bl	1ccd8 <__aeabi_dcmpgt>
   1f092:	2800      	cmp	r0, #0
   1f094:	f040 821b 	bne.w	1f4ce <__ieee754_pow+0xa1e>
   1f098:	f3cb 530a 	ubfx	r3, fp, #20, #11
   1f09c:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
   1f0a0:	f2a3 33fe 	subw	r3, r3, #1022	; 0x3fe
   1f0a4:	4cbc      	ldr	r4, [pc, #752]	; (1f398 <__ieee754_pow+0x8e8>)
   1f0a6:	f1bb 0f00 	cmp.w	fp, #0
   1f0aa:	fa42 f303 	asr.w	r3, r2, r3
   1f0ae:	f04f 0000 	mov.w	r0, #0
   1f0b2:	445b      	add	r3, fp
   1f0b4:	f3c3 520a 	ubfx	r2, r3, #20, #11
   1f0b8:	f3c3 0a13 	ubfx	sl, r3, #0, #20
   1f0bc:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
   1f0c0:	f44a 1a80 	orr.w	sl, sl, #1048576	; 0x100000
   1f0c4:	fa44 f402 	asr.w	r4, r4, r2
   1f0c8:	f1c2 0214 	rsb	r2, r2, #20
   1f0cc:	ea23 0104 	bic.w	r1, r3, r4
   1f0d0:	fa4a fa02 	asr.w	sl, sl, r2
   1f0d4:	4602      	mov	r2, r0
   1f0d6:	4640      	mov	r0, r8
   1f0d8:	460b      	mov	r3, r1
   1f0da:	bfb8      	it	lt
   1f0dc:	f1ca 0a00 	rsblt	sl, sl, #0
   1f0e0:	4649      	mov	r1, r9
   1f0e2:	f7fd f9b1 	bl	1c448 <__aeabi_dsub>
   1f0e6:	4602      	mov	r2, r0
   1f0e8:	460b      	mov	r3, r1
   1f0ea:	4680      	mov	r8, r0
   1f0ec:	4689      	mov	r9, r1
   1f0ee:	ea4f 5b0a 	mov.w	fp, sl, lsl #20
   1f0f2:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1f0f6:	f7fd f9a9 	bl	1c44c <__adddf3>
   1f0fa:	460d      	mov	r5, r1
   1f0fc:	2400      	movs	r4, #0
   1f0fe:	4629      	mov	r1, r5
   1f100:	a38f      	add	r3, pc, #572	; (adr r3, 1f340 <__ieee754_pow+0x890>)
   1f102:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f106:	4620      	mov	r0, r4
   1f108:	f7fd fb56 	bl	1c7b8 <__aeabi_dmul>
   1f10c:	4642      	mov	r2, r8
   1f10e:	4606      	mov	r6, r0
   1f110:	460f      	mov	r7, r1
   1f112:	464b      	mov	r3, r9
   1f114:	4620      	mov	r0, r4
   1f116:	4629      	mov	r1, r5
   1f118:	f7fd f996 	bl	1c448 <__aeabi_dsub>
   1f11c:	4602      	mov	r2, r0
   1f11e:	460b      	mov	r3, r1
   1f120:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1f124:	f7fd f990 	bl	1c448 <__aeabi_dsub>
   1f128:	a387      	add	r3, pc, #540	; (adr r3, 1f348 <__ieee754_pow+0x898>)
   1f12a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f12e:	f7fd fb43 	bl	1c7b8 <__aeabi_dmul>
   1f132:	4680      	mov	r8, r0
   1f134:	4689      	mov	r9, r1
   1f136:	4620      	mov	r0, r4
   1f138:	4629      	mov	r1, r5
   1f13a:	a385      	add	r3, pc, #532	; (adr r3, 1f350 <__ieee754_pow+0x8a0>)
   1f13c:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f140:	f7fd fb3a 	bl	1c7b8 <__aeabi_dmul>
   1f144:	4602      	mov	r2, r0
   1f146:	460b      	mov	r3, r1
   1f148:	4640      	mov	r0, r8
   1f14a:	4649      	mov	r1, r9
   1f14c:	f7fd f97e 	bl	1c44c <__adddf3>
   1f150:	4604      	mov	r4, r0
   1f152:	460d      	mov	r5, r1
   1f154:	4602      	mov	r2, r0
   1f156:	460b      	mov	r3, r1
   1f158:	4630      	mov	r0, r6
   1f15a:	4639      	mov	r1, r7
   1f15c:	f7fd f976 	bl	1c44c <__adddf3>
   1f160:	4632      	mov	r2, r6
   1f162:	4680      	mov	r8, r0
   1f164:	4689      	mov	r9, r1
   1f166:	463b      	mov	r3, r7
   1f168:	f7fd f96e 	bl	1c448 <__aeabi_dsub>
   1f16c:	4602      	mov	r2, r0
   1f16e:	460b      	mov	r3, r1
   1f170:	4620      	mov	r0, r4
   1f172:	4629      	mov	r1, r5
   1f174:	f7fd f968 	bl	1c448 <__aeabi_dsub>
   1f178:	4642      	mov	r2, r8
   1f17a:	4606      	mov	r6, r0
   1f17c:	460f      	mov	r7, r1
   1f17e:	464b      	mov	r3, r9
   1f180:	4640      	mov	r0, r8
   1f182:	4649      	mov	r1, r9
   1f184:	f7fd fb18 	bl	1c7b8 <__aeabi_dmul>
   1f188:	4604      	mov	r4, r0
   1f18a:	460d      	mov	r5, r1
   1f18c:	a372      	add	r3, pc, #456	; (adr r3, 1f358 <__ieee754_pow+0x8a8>)
   1f18e:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f192:	f7fd fb11 	bl	1c7b8 <__aeabi_dmul>
   1f196:	a372      	add	r3, pc, #456	; (adr r3, 1f360 <__ieee754_pow+0x8b0>)
   1f198:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f19c:	f7fd f954 	bl	1c448 <__aeabi_dsub>
   1f1a0:	4622      	mov	r2, r4
   1f1a2:	462b      	mov	r3, r5
   1f1a4:	f7fd fb08 	bl	1c7b8 <__aeabi_dmul>
   1f1a8:	a36f      	add	r3, pc, #444	; (adr r3, 1f368 <__ieee754_pow+0x8b8>)
   1f1aa:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f1ae:	f7fd f94d 	bl	1c44c <__adddf3>
   1f1b2:	4622      	mov	r2, r4
   1f1b4:	462b      	mov	r3, r5
   1f1b6:	f7fd faff 	bl	1c7b8 <__aeabi_dmul>
   1f1ba:	a36d      	add	r3, pc, #436	; (adr r3, 1f370 <__ieee754_pow+0x8c0>)
   1f1bc:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f1c0:	f7fd f942 	bl	1c448 <__aeabi_dsub>
   1f1c4:	4622      	mov	r2, r4
   1f1c6:	462b      	mov	r3, r5
   1f1c8:	f7fd faf6 	bl	1c7b8 <__aeabi_dmul>
   1f1cc:	a36a      	add	r3, pc, #424	; (adr r3, 1f378 <__ieee754_pow+0x8c8>)
   1f1ce:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f1d2:	f7fd f93b 	bl	1c44c <__adddf3>
   1f1d6:	4622      	mov	r2, r4
   1f1d8:	462b      	mov	r3, r5
   1f1da:	f7fd faed 	bl	1c7b8 <__aeabi_dmul>
   1f1de:	4602      	mov	r2, r0
   1f1e0:	460b      	mov	r3, r1
   1f1e2:	4640      	mov	r0, r8
   1f1e4:	4649      	mov	r1, r9
   1f1e6:	f7fd f92f 	bl	1c448 <__aeabi_dsub>
   1f1ea:	4604      	mov	r4, r0
   1f1ec:	460d      	mov	r5, r1
   1f1ee:	4602      	mov	r2, r0
   1f1f0:	460b      	mov	r3, r1
   1f1f2:	4640      	mov	r0, r8
   1f1f4:	4649      	mov	r1, r9
   1f1f6:	f7fd fadf 	bl	1c7b8 <__aeabi_dmul>
   1f1fa:	2200      	movs	r2, #0
   1f1fc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1f200:	e9cd 0100 	strd	r0, r1, [sp]
   1f204:	4620      	mov	r0, r4
   1f206:	4629      	mov	r1, r5
   1f208:	f7fd f91e 	bl	1c448 <__aeabi_dsub>
   1f20c:	4602      	mov	r2, r0
   1f20e:	460b      	mov	r3, r1
   1f210:	e9dd 0100 	ldrd	r0, r1, [sp]
   1f214:	f7fd fbfa 	bl	1ca0c <__aeabi_ddiv>
   1f218:	4632      	mov	r2, r6
   1f21a:	4604      	mov	r4, r0
   1f21c:	460d      	mov	r5, r1
   1f21e:	463b      	mov	r3, r7
   1f220:	4640      	mov	r0, r8
   1f222:	4649      	mov	r1, r9
   1f224:	f7fd fac8 	bl	1c7b8 <__aeabi_dmul>
   1f228:	4632      	mov	r2, r6
   1f22a:	463b      	mov	r3, r7
   1f22c:	f7fd f90e 	bl	1c44c <__adddf3>
   1f230:	4602      	mov	r2, r0
   1f232:	460b      	mov	r3, r1
   1f234:	4620      	mov	r0, r4
   1f236:	4629      	mov	r1, r5
   1f238:	f7fd f906 	bl	1c448 <__aeabi_dsub>
   1f23c:	4642      	mov	r2, r8
   1f23e:	464b      	mov	r3, r9
   1f240:	f7fd f902 	bl	1c448 <__aeabi_dsub>
   1f244:	4602      	mov	r2, r0
   1f246:	460b      	mov	r3, r1
   1f248:	2000      	movs	r0, #0
   1f24a:	4954      	ldr	r1, [pc, #336]	; (1f39c <__ieee754_pow+0x8ec>)
   1f24c:	f7fd f8fc 	bl	1c448 <__aeabi_dsub>
   1f250:	448b      	add	fp, r1
   1f252:	4602      	mov	r2, r0
   1f254:	460b      	mov	r3, r1
   1f256:	f5bb 1f80 	cmp.w	fp, #1048576	; 0x100000
   1f25a:	f2c0 815f 	blt.w	1f51c <__ieee754_pow+0xa6c>
   1f25e:	4659      	mov	r1, fp
   1f260:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1f264:	f7fd faa8 	bl	1c7b8 <__aeabi_dmul>
   1f268:	e44f      	b.n	1eb0a <__ieee754_pow+0x5a>
   1f26a:	ec45 4b10 	vmov	d0, r4, r5
   1f26e:	f019 fda5 	bl	38dbc <fabs>
   1f272:	ec51 0b10 	vmov	r0, r1, d0
   1f276:	f1ba 0f00 	cmp.w	sl, #0
   1f27a:	f47f accb 	bne.w	1ec14 <__ieee754_pow+0x164>
   1f27e:	f027 4340 	bic.w	r3, r7, #3221225472	; 0xc0000000
   1f282:	4a46      	ldr	r2, [pc, #280]	; (1f39c <__ieee754_pow+0x8ec>)
   1f284:	4293      	cmp	r3, r2
   1f286:	d002      	beq.n	1f28e <__ieee754_pow+0x7de>
   1f288:	2e00      	cmp	r6, #0
   1f28a:	f47f acc3 	bne.w	1ec14 <__ieee754_pow+0x164>
   1f28e:	f04f 0b00 	mov.w	fp, #0
   1f292:	f1b9 0f00 	cmp.w	r9, #0
   1f296:	da05      	bge.n	1f2a4 <__ieee754_pow+0x7f4>
   1f298:	4602      	mov	r2, r0
   1f29a:	460b      	mov	r3, r1
   1f29c:	2000      	movs	r0, #0
   1f29e:	493f      	ldr	r1, [pc, #252]	; (1f39c <__ieee754_pow+0x8ec>)
   1f2a0:	f7fd fbb4 	bl	1ca0c <__aeabi_ddiv>
   1f2a4:	2f00      	cmp	r7, #0
   1f2a6:	f6bf ac30 	bge.w	1eb0a <__ieee754_pow+0x5a>
   1f2aa:	4b3d      	ldr	r3, [pc, #244]	; (1f3a0 <__ieee754_pow+0x8f0>)
   1f2ac:	4433      	add	r3, r6
   1f2ae:	ea53 030b 	orrs.w	r3, r3, fp
   1f2b2:	f040 812a 	bne.w	1f50a <__ieee754_pow+0xa5a>
   1f2b6:	4602      	mov	r2, r0
   1f2b8:	460b      	mov	r3, r1
   1f2ba:	e4ad      	b.n	1ec18 <__ieee754_pow+0x168>
   1f2bc:	f1b9 0f00 	cmp.w	r9, #0
   1f2c0:	f6ff ac6b 	blt.w	1eb9a <__ieee754_pow+0xea>
   1f2c4:	2000      	movs	r0, #0
   1f2c6:	2100      	movs	r1, #0
   1f2c8:	e41f      	b.n	1eb0a <__ieee754_pow+0x5a>
   1f2ca:	ed9f 7b2d 	vldr	d7, [pc, #180]	; 1f380 <__ieee754_pow+0x8d0>
   1f2ce:	ed8d 7b04 	vstr	d7, [sp, #16]
   1f2d2:	e689      	b.n	1efe8 <__ieee754_pow+0x538>
   1f2d4:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   1f2d8:	4e32      	ldr	r6, [pc, #200]	; (1f3a4 <__ieee754_pow+0x8f4>)
   1f2da:	42b3      	cmp	r3, r6
   1f2dc:	f340 80ef 	ble.w	1f4be <__ieee754_pow+0xa0e>
   1f2e0:	4b31      	ldr	r3, [pc, #196]	; (1f3a8 <__ieee754_pow+0x8f8>)
   1f2e2:	440b      	add	r3, r1
   1f2e4:	4303      	orrs	r3, r0
   1f2e6:	d10a      	bne.n	1f2fe <__ieee754_pow+0x84e>
   1f2e8:	4642      	mov	r2, r8
   1f2ea:	464b      	mov	r3, r9
   1f2ec:	f7fd f8ac 	bl	1c448 <__aeabi_dsub>
   1f2f0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1f2f4:	f7fd fce6 	bl	1ccc4 <__aeabi_dcmpge>
   1f2f8:	2800      	cmp	r0, #0
   1f2fa:	f43f aecd 	beq.w	1f098 <__ieee754_pow+0x5e8>
   1f2fe:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   1f302:	a321      	add	r3, pc, #132	; (adr r3, 1f388 <__ieee754_pow+0x8d8>)
   1f304:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f308:	f7fd fa56 	bl	1c7b8 <__aeabi_dmul>
   1f30c:	a31e      	add	r3, pc, #120	; (adr r3, 1f388 <__ieee754_pow+0x8d8>)
   1f30e:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f312:	f7fd fa51 	bl	1c7b8 <__aeabi_dmul>
   1f316:	f7ff bbf8 	b.w	1eb0a <__ieee754_pow+0x5a>
   1f31a:	f1b9 0f00 	cmp.w	r9, #0
   1f31e:	dad1      	bge.n	1f2c4 <__ieee754_pow+0x814>
   1f320:	e9dd 3400 	ldrd	r3, r4, [sp]
   1f324:	4618      	mov	r0, r3
   1f326:	f104 4100 	add.w	r1, r4, #2147483648	; 0x80000000
   1f32a:	f7ff bbee 	b.w	1eb0a <__ieee754_pow+0x5a>
   1f32e:	bf00      	nop
   1f330:	00000000 	.word	0x00000000
   1f334:	bff00000 	.word	0xbff00000
   1f338:	652b82fe 	.word	0x652b82fe
   1f33c:	3c971547 	.word	0x3c971547
   1f340:	00000000 	.word	0x00000000
   1f344:	3fe62e43 	.word	0x3fe62e43
   1f348:	fefa39ef 	.word	0xfefa39ef
   1f34c:	3fe62e42 	.word	0x3fe62e42
   1f350:	0ca86c39 	.word	0x0ca86c39
   1f354:	be205c61 	.word	0xbe205c61
   1f358:	72bea4d0 	.word	0x72bea4d0
   1f35c:	3e663769 	.word	0x3e663769
   1f360:	c5d26bf1 	.word	0xc5d26bf1
   1f364:	3ebbbd41 	.word	0x3ebbbd41
   1f368:	af25de2c 	.word	0xaf25de2c
   1f36c:	3f11566a 	.word	0x3f11566a
   1f370:	16bebd93 	.word	0x16bebd93
   1f374:	3f66c16c 	.word	0x3f66c16c
   1f378:	5555553e 	.word	0x5555553e
   1f37c:	3fc55555 	.word	0x3fc55555
   1f380:	00000000 	.word	0x00000000
   1f384:	3ff00000 	.word	0x3ff00000
   1f388:	c2f8f359 	.word	0xc2f8f359
   1f38c:	01a56e1f 	.word	0x01a56e1f
   1f390:	408fffff 	.word	0x408fffff
   1f394:	bf700000 	.word	0xbf700000
   1f398:	000fffff 	.word	0x000fffff
   1f39c:	3ff00000 	.word	0x3ff00000
   1f3a0:	c0100000 	.word	0xc0100000
   1f3a4:	4090cbff 	.word	0x4090cbff
   1f3a8:	3f6f3400 	.word	0x3f6f3400
   1f3ac:	4b7c      	ldr	r3, [pc, #496]	; (1f5a0 <__ieee754_pow+0xaf0>)
   1f3ae:	429e      	cmp	r6, r3
   1f3b0:	dd84      	ble.n	1f2bc <__ieee754_pow+0x80c>
   1f3b2:	4b7c      	ldr	r3, [pc, #496]	; (1f5a4 <__ieee754_pow+0xaf4>)
   1f3b4:	429e      	cmp	r6, r3
   1f3b6:	f73f abec 	bgt.w	1eb92 <__ieee754_pow+0xe2>
   1f3ba:	2200      	movs	r2, #0
   1f3bc:	4b79      	ldr	r3, [pc, #484]	; (1f5a4 <__ieee754_pow+0xaf4>)
   1f3be:	f7fd f843 	bl	1c448 <__aeabi_dsub>
   1f3c2:	4604      	mov	r4, r0
   1f3c4:	460d      	mov	r5, r1
   1f3c6:	a362      	add	r3, pc, #392	; (adr r3, 1f550 <__ieee754_pow+0xaa0>)
   1f3c8:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f3cc:	f7fd f9f4 	bl	1c7b8 <__aeabi_dmul>
   1f3d0:	4680      	mov	r8, r0
   1f3d2:	4689      	mov	r9, r1
   1f3d4:	4620      	mov	r0, r4
   1f3d6:	4629      	mov	r1, r5
   1f3d8:	a35f      	add	r3, pc, #380	; (adr r3, 1f558 <__ieee754_pow+0xaa8>)
   1f3da:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f3de:	f7fd f9eb 	bl	1c7b8 <__aeabi_dmul>
   1f3e2:	2200      	movs	r2, #0
   1f3e4:	4b70      	ldr	r3, [pc, #448]	; (1f5a8 <__ieee754_pow+0xaf8>)
   1f3e6:	e9cd 0102 	strd	r0, r1, [sp, #8]
   1f3ea:	4620      	mov	r0, r4
   1f3ec:	4629      	mov	r1, r5
   1f3ee:	f7fd f9e3 	bl	1c7b8 <__aeabi_dmul>
   1f3f2:	4602      	mov	r2, r0
   1f3f4:	460b      	mov	r3, r1
   1f3f6:	a15a      	add	r1, pc, #360	; (adr r1, 1f560 <__ieee754_pow+0xab0>)
   1f3f8:	e9d1 0100 	ldrd	r0, r1, [r1]
   1f3fc:	f7fd f824 	bl	1c448 <__aeabi_dsub>
   1f400:	4622      	mov	r2, r4
   1f402:	462b      	mov	r3, r5
   1f404:	f7fd f9d8 	bl	1c7b8 <__aeabi_dmul>
   1f408:	4602      	mov	r2, r0
   1f40a:	460b      	mov	r3, r1
   1f40c:	2000      	movs	r0, #0
   1f40e:	4967      	ldr	r1, [pc, #412]	; (1f5ac <__ieee754_pow+0xafc>)
   1f410:	f7fd f81a 	bl	1c448 <__aeabi_dsub>
   1f414:	4606      	mov	r6, r0
   1f416:	460f      	mov	r7, r1
   1f418:	4622      	mov	r2, r4
   1f41a:	462b      	mov	r3, r5
   1f41c:	4620      	mov	r0, r4
   1f41e:	4629      	mov	r1, r5
   1f420:	f7fd f9ca 	bl	1c7b8 <__aeabi_dmul>
   1f424:	4602      	mov	r2, r0
   1f426:	460b      	mov	r3, r1
   1f428:	4630      	mov	r0, r6
   1f42a:	4639      	mov	r1, r7
   1f42c:	f7fd f9c4 	bl	1c7b8 <__aeabi_dmul>
   1f430:	a34d      	add	r3, pc, #308	; (adr r3, 1f568 <__ieee754_pow+0xab8>)
   1f432:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f436:	f7fd f9bf 	bl	1c7b8 <__aeabi_dmul>
   1f43a:	4602      	mov	r2, r0
   1f43c:	460b      	mov	r3, r1
   1f43e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1f442:	f7fd f801 	bl	1c448 <__aeabi_dsub>
   1f446:	4602      	mov	r2, r0
   1f448:	460b      	mov	r3, r1
   1f44a:	4606      	mov	r6, r0
   1f44c:	460f      	mov	r7, r1
   1f44e:	4640      	mov	r0, r8
   1f450:	4649      	mov	r1, r9
   1f452:	f7fc fffb 	bl	1c44c <__adddf3>
   1f456:	2000      	movs	r0, #0
   1f458:	460d      	mov	r5, r1
   1f45a:	4642      	mov	r2, r8
   1f45c:	4604      	mov	r4, r0
   1f45e:	464b      	mov	r3, r9
   1f460:	e5ae      	b.n	1efc0 <__ieee754_pow+0x510>
   1f462:	ed9f 7b43 	vldr	d7, [pc, #268]	; 1f570 <__ieee754_pow+0xac0>
   1f466:	2500      	movs	r5, #0
   1f468:	ed8d 7b08 	vstr	d7, [sp, #32]
   1f46c:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
   1f470:	ed9f 7b41 	vldr	d7, [pc, #260]	; 1f578 <__ieee754_pow+0xac8>
   1f474:	ed8d 7b06 	vstr	d7, [sp, #24]
   1f478:	e41d      	b.n	1ecb6 <__ieee754_pow+0x206>
   1f47a:	2500      	movs	r5, #0
   1f47c:	f7ff bbf8 	b.w	1ec70 <__ieee754_pow+0x1c0>
   1f480:	4622      	mov	r2, r4
   1f482:	462b      	mov	r3, r5
   1f484:	2000      	movs	r0, #0
   1f486:	4947      	ldr	r1, [pc, #284]	; (1f5a4 <__ieee754_pow+0xaf4>)
   1f488:	f7fd fac0 	bl	1ca0c <__aeabi_ddiv>
   1f48c:	f7ff bb3d 	b.w	1eb0a <__ieee754_pow+0x5a>
   1f490:	4622      	mov	r2, r4
   1f492:	462b      	mov	r3, r5
   1f494:	4620      	mov	r0, r4
   1f496:	4629      	mov	r1, r5
   1f498:	f7fd f98e 	bl	1c7b8 <__aeabi_dmul>
   1f49c:	f7ff bb35 	b.w	1eb0a <__ieee754_pow+0x5a>
   1f4a0:	f1bc 0f00 	cmp.w	ip, #0
   1f4a4:	f47f aee1 	bne.w	1f26a <__ieee754_pow+0x7ba>
   1f4a8:	f1c3 0314 	rsb	r3, r3, #20
   1f4ac:	fa48 f203 	asr.w	r2, r8, r3
   1f4b0:	fa02 f303 	lsl.w	r3, r2, r3
   1f4b4:	4543      	cmp	r3, r8
   1f4b6:	d040      	beq.n	1f53a <__ieee754_pow+0xa8a>
   1f4b8:	46e3      	mov	fp, ip
   1f4ba:	f7ff bb39 	b.w	1eb30 <__ieee754_pow+0x80>
   1f4be:	4a3b      	ldr	r2, [pc, #236]	; (1f5ac <__ieee754_pow+0xafc>)
   1f4c0:	4293      	cmp	r3, r2
   1f4c2:	dc40      	bgt.n	1f546 <__ieee754_pow+0xa96>
   1f4c4:	e9dd 2300 	ldrd	r2, r3, [sp]
   1f4c8:	4693      	mov	fp, r2
   1f4ca:	4692      	mov	sl, r2
   1f4cc:	e616      	b.n	1f0fc <__ieee754_pow+0x64c>
   1f4ce:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   1f4d2:	a32b      	add	r3, pc, #172	; (adr r3, 1f580 <__ieee754_pow+0xad0>)
   1f4d4:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f4d8:	f7fd f96e 	bl	1c7b8 <__aeabi_dmul>
   1f4dc:	a328      	add	r3, pc, #160	; (adr r3, 1f580 <__ieee754_pow+0xad0>)
   1f4de:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f4e2:	f7fd f969 	bl	1c7b8 <__aeabi_dmul>
   1f4e6:	f7ff bb10 	b.w	1eb0a <__ieee754_pow+0x5a>
   1f4ea:	ed9f 7b27 	vldr	d7, [pc, #156]	; 1f588 <__ieee754_pow+0xad8>
   1f4ee:	f44f 2580 	mov.w	r5, #262144	; 0x40000
   1f4f2:	ed8d 7b08 	vstr	d7, [sp, #32]
   1f4f6:	ed9f 7b26 	vldr	d7, [pc, #152]	; 1f590 <__ieee754_pow+0xae0>
   1f4fa:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
   1f4fe:	ed9f 7b26 	vldr	d7, [pc, #152]	; 1f598 <__ieee754_pow+0xae8>
   1f502:	ed8d 7b06 	vstr	d7, [sp, #24]
   1f506:	f7ff bbd6 	b.w	1ecb6 <__ieee754_pow+0x206>
   1f50a:	f1bb 0f01 	cmp.w	fp, #1
   1f50e:	f47f aafc 	bne.w	1eb0a <__ieee754_pow+0x5a>
   1f512:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
   1f516:	4619      	mov	r1, r3
   1f518:	f7ff baf7 	b.w	1eb0a <__ieee754_pow+0x5a>
   1f51c:	4650      	mov	r0, sl
   1f51e:	ec43 2b10 	vmov	d0, r2, r3
   1f522:	f000 f84d 	bl	1f5c0 <scalbn>
   1f526:	ec51 0b10 	vmov	r0, r1, d0
   1f52a:	e699      	b.n	1f260 <__ieee754_pow+0x7b0>
   1f52c:	ec45 4b10 	vmov	d0, r4, r5
   1f530:	b013      	add	sp, #76	; 0x4c
   1f532:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1f536:	f019 bcbf 	b.w	38eb8 <__ieee754_sqrt>
   1f53a:	f002 0201 	and.w	r2, r2, #1
   1f53e:	f1c2 0b02 	rsb	fp, r2, #2
   1f542:	f7ff baf5 	b.w	1eb30 <__ieee754_pow+0x80>
   1f546:	151b      	asrs	r3, r3, #20
   1f548:	e5a8      	b.n	1f09c <__ieee754_pow+0x5ec>
   1f54a:	bf00      	nop
   1f54c:	f3af 8000 	nop.w
   1f550:	60000000 	.word	0x60000000
   1f554:	3ff71547 	.word	0x3ff71547
   1f558:	f85ddf44 	.word	0xf85ddf44
   1f55c:	3e54ae0b 	.word	0x3e54ae0b
   1f560:	55555555 	.word	0x55555555
   1f564:	3fd55555 	.word	0x3fd55555
   1f568:	652b82fe 	.word	0x652b82fe
   1f56c:	3ff71547 	.word	0x3ff71547
	...
   1f57c:	3ff00000 	.word	0x3ff00000
   1f580:	8800759c 	.word	0x8800759c
   1f584:	7e37e43c 	.word	0x7e37e43c
   1f588:	40000000 	.word	0x40000000
   1f58c:	3fe2b803 	.word	0x3fe2b803
   1f590:	43cfd006 	.word	0x43cfd006
   1f594:	3e4cfdeb 	.word	0x3e4cfdeb
   1f598:	00000000 	.word	0x00000000
   1f59c:	3ff80000 	.word	0x3ff80000
   1f5a0:	3feffffe 	.word	0x3feffffe
   1f5a4:	3ff00000 	.word	0x3ff00000
   1f5a8:	3fd00000 	.word	0x3fd00000
   1f5ac:	3fe00000 	.word	0x3fe00000

0001f5b0 <nan>:
   1f5b0:	ed9f 0b01 	vldr	d0, [pc, #4]	; 1f5b8 <nan+0x8>
   1f5b4:	4770      	bx	lr
   1f5b6:	bf00      	nop
   1f5b8:	00000000 	.word	0x00000000
   1f5bc:	7ff80000 	.word	0x7ff80000

0001f5c0 <scalbn>:
   1f5c0:	b538      	push	{r3, r4, r5, lr}
   1f5c2:	ec53 2b10 	vmov	r2, r3, d0
   1f5c6:	f3c3 510a 	ubfx	r1, r3, #20, #11
   1f5ca:	461c      	mov	r4, r3
   1f5cc:	4605      	mov	r5, r0
   1f5ce:	bb81      	cbnz	r1, 1f632 <scalbn+0x72>
   1f5d0:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
   1f5d4:	ee10 1a10 	vmov	r1, s0
   1f5d8:	4321      	orrs	r1, r4
   1f5da:	d029      	beq.n	1f630 <scalbn+0x70>
   1f5dc:	4c3c      	ldr	r4, [pc, #240]	; (1f6d0 <scalbn+0x110>)
   1f5de:	4619      	mov	r1, r3
   1f5e0:	2200      	movs	r2, #0
   1f5e2:	4b3c      	ldr	r3, [pc, #240]	; (1f6d4 <scalbn+0x114>)
   1f5e4:	ee10 0a10 	vmov	r0, s0
   1f5e8:	f7fd f8e6 	bl	1c7b8 <__aeabi_dmul>
   1f5ec:	42a5      	cmp	r5, r4
   1f5ee:	4602      	mov	r2, r0
   1f5f0:	460b      	mov	r3, r1
   1f5f2:	db16      	blt.n	1f622 <scalbn+0x62>
   1f5f4:	460c      	mov	r4, r1
   1f5f6:	f3c1 510a 	ubfx	r1, r1, #20, #11
   1f5fa:	3936      	subs	r1, #54	; 0x36
   1f5fc:	4429      	add	r1, r5
   1f5fe:	f240 70fe 	movw	r0, #2046	; 0x7fe
   1f602:	4281      	cmp	r1, r0
   1f604:	dc21      	bgt.n	1f64a <scalbn+0x8a>
   1f606:	2900      	cmp	r1, #0
   1f608:	dc45      	bgt.n	1f696 <scalbn+0xd6>
   1f60a:	f111 0f35 	cmn.w	r1, #53	; 0x35
   1f60e:	da34      	bge.n	1f67a <scalbn+0xba>
   1f610:	f24c 3150 	movw	r1, #50000	; 0xc350
   1f614:	428d      	cmp	r5, r1
   1f616:	dc18      	bgt.n	1f64a <scalbn+0x8a>
   1f618:	2b00      	cmp	r3, #0
   1f61a:	a125      	add	r1, pc, #148	; (adr r1, 1f6b0 <scalbn+0xf0>)
   1f61c:	e9d1 0100 	ldrd	r0, r1, [r1]
   1f620:	db40      	blt.n	1f6a4 <scalbn+0xe4>
   1f622:	a323      	add	r3, pc, #140	; (adr r3, 1f6b0 <scalbn+0xf0>)
   1f624:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f628:	f7fd f8c6 	bl	1c7b8 <__aeabi_dmul>
   1f62c:	ec41 0b10 	vmov	d0, r0, r1
   1f630:	bd38      	pop	{r3, r4, r5, pc}
   1f632:	f240 70ff 	movw	r0, #2047	; 0x7ff
   1f636:	4281      	cmp	r1, r0
   1f638:	d1e0      	bne.n	1f5fc <scalbn+0x3c>
   1f63a:	ee10 0a10 	vmov	r0, s0
   1f63e:	4619      	mov	r1, r3
   1f640:	f7fc ff04 	bl	1c44c <__adddf3>
   1f644:	ec41 0b10 	vmov	d0, r0, r1
   1f648:	bd38      	pop	{r3, r4, r5, pc}
   1f64a:	2b00      	cmp	r3, #0
   1f64c:	a11a      	add	r1, pc, #104	; (adr r1, 1f6b8 <scalbn+0xf8>)
   1f64e:	e9d1 0100 	ldrd	r0, r1, [r1]
   1f652:	db07      	blt.n	1f664 <scalbn+0xa4>
   1f654:	a318      	add	r3, pc, #96	; (adr r3, 1f6b8 <scalbn+0xf8>)
   1f656:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f65a:	f7fd f8ad 	bl	1c7b8 <__aeabi_dmul>
   1f65e:	ec41 0b10 	vmov	d0, r0, r1
   1f662:	bd38      	pop	{r3, r4, r5, pc}
   1f664:	a116      	add	r1, pc, #88	; (adr r1, 1f6c0 <scalbn+0x100>)
   1f666:	e9d1 0100 	ldrd	r0, r1, [r1]
   1f66a:	a313      	add	r3, pc, #76	; (adr r3, 1f6b8 <scalbn+0xf8>)
   1f66c:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f670:	f7fd f8a2 	bl	1c7b8 <__aeabi_dmul>
   1f674:	ec41 0b10 	vmov	d0, r0, r1
   1f678:	e7f3      	b.n	1f662 <scalbn+0xa2>
   1f67a:	4817      	ldr	r0, [pc, #92]	; (1f6d8 <scalbn+0x118>)
   1f67c:	3136      	adds	r1, #54	; 0x36
   1f67e:	4020      	ands	r0, r4
   1f680:	ea40 5301 	orr.w	r3, r0, r1, lsl #20
   1f684:	4610      	mov	r0, r2
   1f686:	2200      	movs	r2, #0
   1f688:	4619      	mov	r1, r3
   1f68a:	4b14      	ldr	r3, [pc, #80]	; (1f6dc <scalbn+0x11c>)
   1f68c:	f7fd f894 	bl	1c7b8 <__aeabi_dmul>
   1f690:	ec41 0b10 	vmov	d0, r0, r1
   1f694:	bd38      	pop	{r3, r4, r5, pc}
   1f696:	4810      	ldr	r0, [pc, #64]	; (1f6d8 <scalbn+0x118>)
   1f698:	4020      	ands	r0, r4
   1f69a:	ea40 5301 	orr.w	r3, r0, r1, lsl #20
   1f69e:	ec43 2b10 	vmov	d0, r2, r3
   1f6a2:	bd38      	pop	{r3, r4, r5, pc}
   1f6a4:	a108      	add	r1, pc, #32	; (adr r1, 1f6c8 <scalbn+0x108>)
   1f6a6:	e9d1 0100 	ldrd	r0, r1, [r1]
   1f6aa:	e7ba      	b.n	1f622 <scalbn+0x62>
   1f6ac:	f3af 8000 	nop.w
   1f6b0:	c2f8f359 	.word	0xc2f8f359
   1f6b4:	01a56e1f 	.word	0x01a56e1f
   1f6b8:	8800759c 	.word	0x8800759c
   1f6bc:	7e37e43c 	.word	0x7e37e43c
   1f6c0:	8800759c 	.word	0x8800759c
   1f6c4:	fe37e43c 	.word	0xfe37e43c
   1f6c8:	c2f8f359 	.word	0xc2f8f359
   1f6cc:	81a56e1f 	.word	0x81a56e1f
   1f6d0:	ffff3cb0 	.word	0xffff3cb0
   1f6d4:	43500000 	.word	0x43500000
   1f6d8:	800fffff 	.word	0x800fffff
   1f6dc:	3c900000 	.word	0x3c900000

0001f6e0 <_dtoa_r>:
   1f6e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1f6e4:	6a47      	ldr	r7, [r0, #36]	; 0x24
   1f6e6:	b099      	sub	sp, #100	; 0x64
   1f6e8:	4683      	mov	fp, r0
   1f6ea:	9108      	str	r1, [sp, #32]
   1f6ec:	920d      	str	r2, [sp, #52]	; 0x34
   1f6ee:	9314      	str	r3, [sp, #80]	; 0x50
   1f6f0:	9e22      	ldr	r6, [sp, #136]	; 0x88
   1f6f2:	ec55 4b10 	vmov	r4, r5, d0
   1f6f6:	e9cd 4500 	strd	r4, r5, [sp]
   1f6fa:	b947      	cbnz	r7, 1f70e <_dtoa_r+0x2e>
   1f6fc:	2010      	movs	r0, #16
   1f6fe:	f01a fe07 	bl	3a310 <malloc>
   1f702:	f8cb 0024 	str.w	r0, [fp, #36]	; 0x24
   1f706:	6007      	str	r7, [r0, #0]
   1f708:	60c7      	str	r7, [r0, #12]
   1f70a:	e9c0 7701 	strd	r7, r7, [r0, #4]
   1f70e:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
   1f712:	6819      	ldr	r1, [r3, #0]
   1f714:	b159      	cbz	r1, 1f72e <_dtoa_r+0x4e>
   1f716:	685a      	ldr	r2, [r3, #4]
   1f718:	2301      	movs	r3, #1
   1f71a:	4658      	mov	r0, fp
   1f71c:	4093      	lsls	r3, r2
   1f71e:	604a      	str	r2, [r1, #4]
   1f720:	608b      	str	r3, [r1, #8]
   1f722:	f01f fbca 	bl	3eeba <_Bfree>
   1f726:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
   1f72a:	2200      	movs	r2, #0
   1f72c:	601a      	str	r2, [r3, #0]
   1f72e:	1e2b      	subs	r3, r5, #0
   1f730:	bfb7      	itett	lt
   1f732:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
   1f736:	2300      	movge	r3, #0
   1f738:	2201      	movlt	r2, #1
   1f73a:	9301      	strlt	r3, [sp, #4]
   1f73c:	bfa8      	it	ge
   1f73e:	6033      	strge	r3, [r6, #0]
   1f740:	9c01      	ldr	r4, [sp, #4]
   1f742:	4bb1      	ldr	r3, [pc, #708]	; (1fa08 <_dtoa_r+0x328>)
   1f744:	bfb8      	it	lt
   1f746:	6032      	strlt	r2, [r6, #0]
   1f748:	43a3      	bics	r3, r4
   1f74a:	d11a      	bne.n	1f782 <_dtoa_r+0xa2>
   1f74c:	f242 730f 	movw	r3, #9999	; 0x270f
   1f750:	9a14      	ldr	r2, [sp, #80]	; 0x50
   1f752:	6013      	str	r3, [r2, #0]
   1f754:	f3c4 0313 	ubfx	r3, r4, #0, #20
   1f758:	9a00      	ldr	r2, [sp, #0]
   1f75a:	4313      	orrs	r3, r2
   1f75c:	f000 8547 	beq.w	201ee <__kernel_ram_size+0x1ee>
   1f760:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   1f762:	b953      	cbnz	r3, 1f77a <_dtoa_r+0x9a>
   1f764:	4ba9      	ldr	r3, [pc, #676]	; (1fa0c <_dtoa_r+0x32c>)
   1f766:	e023      	b.n	1f7b0 <_dtoa_r+0xd0>
   1f768:	4ba9      	ldr	r3, [pc, #676]	; (1fa10 <_dtoa_r+0x330>)
   1f76a:	9303      	str	r3, [sp, #12]
   1f76c:	3308      	adds	r3, #8
   1f76e:	9a23      	ldr	r2, [sp, #140]	; 0x8c
   1f770:	6013      	str	r3, [r2, #0]
   1f772:	9803      	ldr	r0, [sp, #12]
   1f774:	b019      	add	sp, #100	; 0x64
   1f776:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1f77a:	4ba4      	ldr	r3, [pc, #656]	; (1fa0c <_dtoa_r+0x32c>)
   1f77c:	9303      	str	r3, [sp, #12]
   1f77e:	3303      	adds	r3, #3
   1f780:	e7f5      	b.n	1f76e <_dtoa_r+0x8e>
   1f782:	ed9d 7b00 	vldr	d7, [sp]
   1f786:	2200      	movs	r2, #0
   1f788:	2300      	movs	r3, #0
   1f78a:	ec51 0b17 	vmov	r0, r1, d7
   1f78e:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
   1f792:	f7fd fa79 	bl	1cc88 <__aeabi_dcmpeq>
   1f796:	4607      	mov	r7, r0
   1f798:	b160      	cbz	r0, 1f7b4 <_dtoa_r+0xd4>
   1f79a:	2301      	movs	r3, #1
   1f79c:	9a14      	ldr	r2, [sp, #80]	; 0x50
   1f79e:	6013      	str	r3, [r2, #0]
   1f7a0:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   1f7a2:	2b00      	cmp	r3, #0
   1f7a4:	f000 8520 	beq.w	201e8 <__kernel_ram_size+0x1e8>
   1f7a8:	4b9a      	ldr	r3, [pc, #616]	; (1fa14 <_dtoa_r+0x334>)
   1f7aa:	9a23      	ldr	r2, [sp, #140]	; 0x8c
   1f7ac:	6013      	str	r3, [r2, #0]
   1f7ae:	3b01      	subs	r3, #1
   1f7b0:	9303      	str	r3, [sp, #12]
   1f7b2:	e7de      	b.n	1f772 <_dtoa_r+0x92>
   1f7b4:	f3c4 560a 	ubfx	r6, r4, #20, #11
   1f7b8:	aa16      	add	r2, sp, #88	; 0x58
   1f7ba:	a917      	add	r1, sp, #92	; 0x5c
   1f7bc:	4658      	mov	r0, fp
   1f7be:	ed9d 0b0e 	vldr	d0, [sp, #56]	; 0x38
   1f7c2:	f01f fd83 	bl	3f2cc <__d2b>
   1f7c6:	4680      	mov	r8, r0
   1f7c8:	2e00      	cmp	r6, #0
   1f7ca:	d07d      	beq.n	1f8c8 <_dtoa_r+0x1e8>
   1f7cc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1f7ce:	f2a6 36ff 	subw	r6, r6, #1023	; 0x3ff
   1f7d2:	9715      	str	r7, [sp, #84]	; 0x54
   1f7d4:	f3c3 0313 	ubfx	r3, r3, #0, #20
   1f7d8:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
   1f7dc:	f043 557f 	orr.w	r5, r3, #1069547520	; 0x3fc00000
   1f7e0:	f445 1540 	orr.w	r5, r5, #3145728	; 0x300000
   1f7e4:	2200      	movs	r2, #0
   1f7e6:	4b8c      	ldr	r3, [pc, #560]	; (1fa18 <_dtoa_r+0x338>)
   1f7e8:	4620      	mov	r0, r4
   1f7ea:	4629      	mov	r1, r5
   1f7ec:	f7fc fe2c 	bl	1c448 <__aeabi_dsub>
   1f7f0:	a37f      	add	r3, pc, #508	; (adr r3, 1f9f0 <_dtoa_r+0x310>)
   1f7f2:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f7f6:	f7fc ffdf 	bl	1c7b8 <__aeabi_dmul>
   1f7fa:	a37f      	add	r3, pc, #508	; (adr r3, 1f9f8 <_dtoa_r+0x318>)
   1f7fc:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f800:	f7fc fe24 	bl	1c44c <__adddf3>
   1f804:	4604      	mov	r4, r0
   1f806:	460d      	mov	r5, r1
   1f808:	4630      	mov	r0, r6
   1f80a:	f7fc ff6b 	bl	1c6e4 <__aeabi_i2d>
   1f80e:	a37c      	add	r3, pc, #496	; (adr r3, 1fa00 <_dtoa_r+0x320>)
   1f810:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f814:	f7fc ffd0 	bl	1c7b8 <__aeabi_dmul>
   1f818:	4602      	mov	r2, r0
   1f81a:	460b      	mov	r3, r1
   1f81c:	4620      	mov	r0, r4
   1f81e:	4629      	mov	r1, r5
   1f820:	f7fc fe14 	bl	1c44c <__adddf3>
   1f824:	4604      	mov	r4, r0
   1f826:	460d      	mov	r5, r1
   1f828:	f7fd fc64 	bl	1d0f4 <__aeabi_d2iz>
   1f82c:	2200      	movs	r2, #0
   1f82e:	4682      	mov	sl, r0
   1f830:	2300      	movs	r3, #0
   1f832:	4620      	mov	r0, r4
   1f834:	4629      	mov	r1, r5
   1f836:	f7fd fa31 	bl	1cc9c <__aeabi_dcmplt>
   1f83a:	b148      	cbz	r0, 1f850 <_dtoa_r+0x170>
   1f83c:	4650      	mov	r0, sl
   1f83e:	f7fc ff51 	bl	1c6e4 <__aeabi_i2d>
   1f842:	4622      	mov	r2, r4
   1f844:	462b      	mov	r3, r5
   1f846:	f7fd fa1f 	bl	1cc88 <__aeabi_dcmpeq>
   1f84a:	b908      	cbnz	r0, 1f850 <_dtoa_r+0x170>
   1f84c:	f10a 3aff 	add.w	sl, sl, #4294967295
   1f850:	f1ba 0f16 	cmp.w	sl, #22
   1f854:	d857      	bhi.n	1f906 <_dtoa_r+0x226>
   1f856:	4b71      	ldr	r3, [pc, #452]	; (1fa1c <_dtoa_r+0x33c>)
   1f858:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
   1f85c:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   1f860:	e9d3 2300 	ldrd	r2, r3, [r3]
   1f864:	f7fd fa1a 	bl	1cc9c <__aeabi_dcmplt>
   1f868:	2800      	cmp	r0, #0
   1f86a:	d04e      	beq.n	1f90a <_dtoa_r+0x22a>
   1f86c:	f10a 3aff 	add.w	sl, sl, #4294967295
   1f870:	2300      	movs	r3, #0
   1f872:	9311      	str	r3, [sp, #68]	; 0x44
   1f874:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1f876:	1b9e      	subs	r6, r3, r6
   1f878:	1e73      	subs	r3, r6, #1
   1f87a:	9307      	str	r3, [sp, #28]
   1f87c:	bf49      	itett	mi
   1f87e:	f1c6 0301 	rsbmi	r3, r6, #1
   1f882:	2300      	movpl	r3, #0
   1f884:	9306      	strmi	r3, [sp, #24]
   1f886:	2300      	movmi	r3, #0
   1f888:	bf54      	ite	pl
   1f88a:	9306      	strpl	r3, [sp, #24]
   1f88c:	9307      	strmi	r3, [sp, #28]
   1f88e:	f1ba 0f00 	cmp.w	sl, #0
   1f892:	db3c      	blt.n	1f90e <_dtoa_r+0x22e>
   1f894:	9b07      	ldr	r3, [sp, #28]
   1f896:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
   1f89a:	4453      	add	r3, sl
   1f89c:	9307      	str	r3, [sp, #28]
   1f89e:	2300      	movs	r3, #0
   1f8a0:	9309      	str	r3, [sp, #36]	; 0x24
   1f8a2:	9b08      	ldr	r3, [sp, #32]
   1f8a4:	2b09      	cmp	r3, #9
   1f8a6:	f200 808d 	bhi.w	1f9c4 <_dtoa_r+0x2e4>
   1f8aa:	2b05      	cmp	r3, #5
   1f8ac:	bfc5      	ittet	gt
   1f8ae:	3b04      	subgt	r3, #4
   1f8b0:	2400      	movgt	r4, #0
   1f8b2:	2401      	movle	r4, #1
   1f8b4:	9308      	strgt	r3, [sp, #32]
   1f8b6:	9b08      	ldr	r3, [sp, #32]
   1f8b8:	3b02      	subs	r3, #2
   1f8ba:	2b03      	cmp	r3, #3
   1f8bc:	f200 808d 	bhi.w	1f9da <_dtoa_r+0x2fa>
   1f8c0:	e8df f003 	tbb	[pc, r3]
   1f8c4:	7e3a3c2f 	.word	0x7e3a3c2f
   1f8c8:	e9dd 6316 	ldrd	r6, r3, [sp, #88]	; 0x58
   1f8cc:	441e      	add	r6, r3
   1f8ce:	f206 4032 	addw	r0, r6, #1074	; 0x432
   1f8d2:	2820      	cmp	r0, #32
   1f8d4:	dd11      	ble.n	1f8fa <_dtoa_r+0x21a>
   1f8d6:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
   1f8da:	9b00      	ldr	r3, [sp, #0]
   1f8dc:	4084      	lsls	r4, r0
   1f8de:	f206 4012 	addw	r0, r6, #1042	; 0x412
   1f8e2:	fa23 f000 	lsr.w	r0, r3, r0
   1f8e6:	4320      	orrs	r0, r4
   1f8e8:	f7fc feec 	bl	1c6c4 <__aeabi_ui2d>
   1f8ec:	2301      	movs	r3, #1
   1f8ee:	4604      	mov	r4, r0
   1f8f0:	f1a1 75f8 	sub.w	r5, r1, #32505856	; 0x1f00000
   1f8f4:	3e01      	subs	r6, #1
   1f8f6:	9315      	str	r3, [sp, #84]	; 0x54
   1f8f8:	e774      	b.n	1f7e4 <_dtoa_r+0x104>
   1f8fa:	f1c0 0020 	rsb	r0, r0, #32
   1f8fe:	9b00      	ldr	r3, [sp, #0]
   1f900:	fa03 f000 	lsl.w	r0, r3, r0
   1f904:	e7f0      	b.n	1f8e8 <_dtoa_r+0x208>
   1f906:	2301      	movs	r3, #1
   1f908:	e7b3      	b.n	1f872 <_dtoa_r+0x192>
   1f90a:	9011      	str	r0, [sp, #68]	; 0x44
   1f90c:	e7b2      	b.n	1f874 <_dtoa_r+0x194>
   1f90e:	9b06      	ldr	r3, [sp, #24]
   1f910:	eba3 030a 	sub.w	r3, r3, sl
   1f914:	9306      	str	r3, [sp, #24]
   1f916:	f1ca 0300 	rsb	r3, sl, #0
   1f91a:	9309      	str	r3, [sp, #36]	; 0x24
   1f91c:	2300      	movs	r3, #0
   1f91e:	9310      	str	r3, [sp, #64]	; 0x40
   1f920:	e7bf      	b.n	1f8a2 <_dtoa_r+0x1c2>
   1f922:	2300      	movs	r3, #0
   1f924:	930c      	str	r3, [sp, #48]	; 0x30
   1f926:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1f928:	2b00      	cmp	r3, #0
   1f92a:	dc59      	bgt.n	1f9e0 <_dtoa_r+0x300>
   1f92c:	2301      	movs	r3, #1
   1f92e:	4699      	mov	r9, r3
   1f930:	461a      	mov	r2, r3
   1f932:	9304      	str	r3, [sp, #16]
   1f934:	920d      	str	r2, [sp, #52]	; 0x34
   1f936:	e00c      	b.n	1f952 <_dtoa_r+0x272>
   1f938:	2301      	movs	r3, #1
   1f93a:	e7f3      	b.n	1f924 <_dtoa_r+0x244>
   1f93c:	2300      	movs	r3, #0
   1f93e:	930c      	str	r3, [sp, #48]	; 0x30
   1f940:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1f942:	4453      	add	r3, sl
   1f944:	f103 0901 	add.w	r9, r3, #1
   1f948:	9304      	str	r3, [sp, #16]
   1f94a:	464b      	mov	r3, r9
   1f94c:	2b01      	cmp	r3, #1
   1f94e:	bfb8      	it	lt
   1f950:	2301      	movlt	r3, #1
   1f952:	2200      	movs	r2, #0
   1f954:	f8db 5024 	ldr.w	r5, [fp, #36]	; 0x24
   1f958:	606a      	str	r2, [r5, #4]
   1f95a:	2204      	movs	r2, #4
   1f95c:	f102 0014 	add.w	r0, r2, #20
   1f960:	6869      	ldr	r1, [r5, #4]
   1f962:	4298      	cmp	r0, r3
   1f964:	d940      	bls.n	1f9e8 <_dtoa_r+0x308>
   1f966:	4658      	mov	r0, fp
   1f968:	f01f fa73 	bl	3ee52 <_Balloc>
   1f96c:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
   1f970:	6028      	str	r0, [r5, #0]
   1f972:	f1b9 0f0e 	cmp.w	r9, #14
   1f976:	681b      	ldr	r3, [r3, #0]
   1f978:	9303      	str	r3, [sp, #12]
   1f97a:	f200 80d4 	bhi.w	1fb26 <_dtoa_r+0x446>
   1f97e:	2c00      	cmp	r4, #0
   1f980:	f000 80d1 	beq.w	1fb26 <_dtoa_r+0x446>
   1f984:	f1ba 0f00 	cmp.w	sl, #0
   1f988:	dd66      	ble.n	1fa58 <_dtoa_r+0x378>
   1f98a:	4a24      	ldr	r2, [pc, #144]	; (1fa1c <_dtoa_r+0x33c>)
   1f98c:	f00a 030f 	and.w	r3, sl, #15
   1f990:	ea4f 142a 	mov.w	r4, sl, asr #4
   1f994:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   1f998:	06e2      	lsls	r2, r4, #27
   1f99a:	ed93 7b00 	vldr	d7, [r3]
   1f99e:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
   1f9a2:	d557      	bpl.n	1fa54 <_dtoa_r+0x374>
   1f9a4:	4b1e      	ldr	r3, [pc, #120]	; (1fa20 <_dtoa_r+0x340>)
   1f9a6:	f004 040f 	and.w	r4, r4, #15
   1f9aa:	2603      	movs	r6, #3
   1f9ac:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
   1f9b0:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   1f9b4:	f7fd f82a 	bl	1ca0c <__aeabi_ddiv>
   1f9b8:	e9cd 0100 	strd	r0, r1, [sp]
   1f9bc:	4d18      	ldr	r5, [pc, #96]	; (1fa20 <_dtoa_r+0x340>)
   1f9be:	e03e      	b.n	1fa3e <_dtoa_r+0x35e>
   1f9c0:	2301      	movs	r3, #1
   1f9c2:	e7bc      	b.n	1f93e <_dtoa_r+0x25e>
   1f9c4:	2401      	movs	r4, #1
   1f9c6:	2300      	movs	r3, #0
   1f9c8:	940c      	str	r4, [sp, #48]	; 0x30
   1f9ca:	9308      	str	r3, [sp, #32]
   1f9cc:	f04f 33ff 	mov.w	r3, #4294967295
   1f9d0:	2200      	movs	r2, #0
   1f9d2:	9304      	str	r3, [sp, #16]
   1f9d4:	4699      	mov	r9, r3
   1f9d6:	2312      	movs	r3, #18
   1f9d8:	e7ac      	b.n	1f934 <_dtoa_r+0x254>
   1f9da:	2301      	movs	r3, #1
   1f9dc:	930c      	str	r3, [sp, #48]	; 0x30
   1f9de:	e7f5      	b.n	1f9cc <_dtoa_r+0x2ec>
   1f9e0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1f9e2:	9304      	str	r3, [sp, #16]
   1f9e4:	4699      	mov	r9, r3
   1f9e6:	e7b4      	b.n	1f952 <_dtoa_r+0x272>
   1f9e8:	3101      	adds	r1, #1
   1f9ea:	0052      	lsls	r2, r2, #1
   1f9ec:	6069      	str	r1, [r5, #4]
   1f9ee:	e7b5      	b.n	1f95c <_dtoa_r+0x27c>
   1f9f0:	636f4361 	.word	0x636f4361
   1f9f4:	3fd287a7 	.word	0x3fd287a7
   1f9f8:	8b60c8b3 	.word	0x8b60c8b3
   1f9fc:	3fc68a28 	.word	0x3fc68a28
   1fa00:	509f79fb 	.word	0x509f79fb
   1fa04:	3fd34413 	.word	0x3fd34413
   1fa08:	7ff00000 	.word	0x7ff00000
   1fa0c:	0004449d 	.word	0x0004449d
   1fa10:	00044494 	.word	0x00044494
   1fa14:	00043e6c 	.word	0x00043e6c
   1fa18:	3ff80000 	.word	0x3ff80000
   1fa1c:	0003fc20 	.word	0x0003fc20
   1fa20:	0003fbf8 	.word	0x0003fbf8
   1fa24:	07e3      	lsls	r3, r4, #31
   1fa26:	d508      	bpl.n	1fa3a <_dtoa_r+0x35a>
   1fa28:	3601      	adds	r6, #1
   1fa2a:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   1fa2e:	e9d5 2300 	ldrd	r2, r3, [r5]
   1fa32:	f7fc fec1 	bl	1c7b8 <__aeabi_dmul>
   1fa36:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   1fa3a:	1064      	asrs	r4, r4, #1
   1fa3c:	3508      	adds	r5, #8
   1fa3e:	2c00      	cmp	r4, #0
   1fa40:	d1f0      	bne.n	1fa24 <_dtoa_r+0x344>
   1fa42:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
   1fa46:	e9dd 0100 	ldrd	r0, r1, [sp]
   1fa4a:	f7fc ffdf 	bl	1ca0c <__aeabi_ddiv>
   1fa4e:	e9cd 0100 	strd	r0, r1, [sp]
   1fa52:	e01a      	b.n	1fa8a <_dtoa_r+0x3aa>
   1fa54:	2602      	movs	r6, #2
   1fa56:	e7b1      	b.n	1f9bc <_dtoa_r+0x2dc>
   1fa58:	f000 809f 	beq.w	1fb9a <_dtoa_r+0x4ba>
   1fa5c:	f1ca 0400 	rsb	r4, sl, #0
   1fa60:	4b9e      	ldr	r3, [pc, #632]	; (1fcdc <_dtoa_r+0x5fc>)
   1fa62:	4d9f      	ldr	r5, [pc, #636]	; (1fce0 <_dtoa_r+0x600>)
   1fa64:	2602      	movs	r6, #2
   1fa66:	f004 020f 	and.w	r2, r4, #15
   1fa6a:	1124      	asrs	r4, r4, #4
   1fa6c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   1fa70:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   1fa74:	e9d3 2300 	ldrd	r2, r3, [r3]
   1fa78:	f7fc fe9e 	bl	1c7b8 <__aeabi_dmul>
   1fa7c:	2300      	movs	r3, #0
   1fa7e:	e9cd 0100 	strd	r0, r1, [sp]
   1fa82:	2c00      	cmp	r4, #0
   1fa84:	d17e      	bne.n	1fb84 <_dtoa_r+0x4a4>
   1fa86:	2b00      	cmp	r3, #0
   1fa88:	d1e1      	bne.n	1fa4e <_dtoa_r+0x36e>
   1fa8a:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1fa8c:	2b00      	cmp	r3, #0
   1fa8e:	f000 8086 	beq.w	1fb9e <_dtoa_r+0x4be>
   1fa92:	2200      	movs	r2, #0
   1fa94:	4b93      	ldr	r3, [pc, #588]	; (1fce4 <_dtoa_r+0x604>)
   1fa96:	e9dd 4500 	ldrd	r4, r5, [sp]
   1fa9a:	4620      	mov	r0, r4
   1fa9c:	4629      	mov	r1, r5
   1fa9e:	f7fd f8fd 	bl	1cc9c <__aeabi_dcmplt>
   1faa2:	2800      	cmp	r0, #0
   1faa4:	d07b      	beq.n	1fb9e <_dtoa_r+0x4be>
   1faa6:	f1b9 0f00 	cmp.w	r9, #0
   1faaa:	d078      	beq.n	1fb9e <_dtoa_r+0x4be>
   1faac:	9b04      	ldr	r3, [sp, #16]
   1faae:	2b00      	cmp	r3, #0
   1fab0:	dd35      	ble.n	1fb1e <_dtoa_r+0x43e>
   1fab2:	f10a 33ff 	add.w	r3, sl, #4294967295
   1fab6:	4620      	mov	r0, r4
   1fab8:	2200      	movs	r2, #0
   1faba:	4629      	mov	r1, r5
   1fabc:	930a      	str	r3, [sp, #40]	; 0x28
   1fabe:	3601      	adds	r6, #1
   1fac0:	4b89      	ldr	r3, [pc, #548]	; (1fce8 <_dtoa_r+0x608>)
   1fac2:	f7fc fe79 	bl	1c7b8 <__aeabi_dmul>
   1fac6:	9c04      	ldr	r4, [sp, #16]
   1fac8:	e9cd 0100 	strd	r0, r1, [sp]
   1facc:	4630      	mov	r0, r6
   1face:	f7fc fe09 	bl	1c6e4 <__aeabi_i2d>
   1fad2:	e9dd 2300 	ldrd	r2, r3, [sp]
   1fad6:	f7fc fe6f 	bl	1c7b8 <__aeabi_dmul>
   1fada:	2200      	movs	r2, #0
   1fadc:	4b83      	ldr	r3, [pc, #524]	; (1fcec <_dtoa_r+0x60c>)
   1fade:	f7fc fcb5 	bl	1c44c <__adddf3>
   1fae2:	4606      	mov	r6, r0
   1fae4:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
   1fae8:	2c00      	cmp	r4, #0
   1faea:	d15c      	bne.n	1fba6 <_dtoa_r+0x4c6>
   1faec:	2200      	movs	r2, #0
   1faee:	4b80      	ldr	r3, [pc, #512]	; (1fcf0 <_dtoa_r+0x610>)
   1faf0:	e9dd 0100 	ldrd	r0, r1, [sp]
   1faf4:	f7fc fca8 	bl	1c448 <__aeabi_dsub>
   1faf8:	4632      	mov	r2, r6
   1fafa:	463b      	mov	r3, r7
   1fafc:	e9cd 0100 	strd	r0, r1, [sp]
   1fb00:	f7fd f8ea 	bl	1ccd8 <__aeabi_dcmpgt>
   1fb04:	2800      	cmp	r0, #0
   1fb06:	f040 8289 	bne.w	2001c <__kernel_ram_size+0x1c>
   1fb0a:	4632      	mov	r2, r6
   1fb0c:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
   1fb10:	e9dd 0100 	ldrd	r0, r1, [sp]
   1fb14:	f7fd f8c2 	bl	1cc9c <__aeabi_dcmplt>
   1fb18:	2800      	cmp	r0, #0
   1fb1a:	f040 827d 	bne.w	20018 <__kernel_ram_size+0x18>
   1fb1e:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
   1fb22:	e9cd 3400 	strd	r3, r4, [sp]
   1fb26:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   1fb28:	2b00      	cmp	r3, #0
   1fb2a:	f2c0 814c 	blt.w	1fdc6 <_dtoa_r+0x6e6>
   1fb2e:	f1ba 0f0e 	cmp.w	sl, #14
   1fb32:	f300 8148 	bgt.w	1fdc6 <_dtoa_r+0x6e6>
   1fb36:	4b69      	ldr	r3, [pc, #420]	; (1fcdc <_dtoa_r+0x5fc>)
   1fb38:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
   1fb3c:	ed93 7b00 	vldr	d7, [r3]
   1fb40:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1fb42:	2b00      	cmp	r3, #0
   1fb44:	ed8d 7b04 	vstr	d7, [sp, #16]
   1fb48:	f280 80d6 	bge.w	1fcf8 <_dtoa_r+0x618>
   1fb4c:	f1b9 0f00 	cmp.w	r9, #0
   1fb50:	f300 80d2 	bgt.w	1fcf8 <_dtoa_r+0x618>
   1fb54:	f040 825f 	bne.w	20016 <__kernel_ram_size+0x16>
   1fb58:	2200      	movs	r2, #0
   1fb5a:	4b65      	ldr	r3, [pc, #404]	; (1fcf0 <_dtoa_r+0x610>)
   1fb5c:	464c      	mov	r4, r9
   1fb5e:	464e      	mov	r6, r9
   1fb60:	ec51 0b17 	vmov	r0, r1, d7
   1fb64:	f7fc fe28 	bl	1c7b8 <__aeabi_dmul>
   1fb68:	e9dd 2300 	ldrd	r2, r3, [sp]
   1fb6c:	f7fd f8aa 	bl	1ccc4 <__aeabi_dcmpge>
   1fb70:	2800      	cmp	r0, #0
   1fb72:	f040 8238 	bne.w	1ffe6 <_dtoa_r+0x906>
   1fb76:	9d03      	ldr	r5, [sp, #12]
   1fb78:	2331      	movs	r3, #49	; 0x31
   1fb7a:	f10a 0a01 	add.w	sl, sl, #1
   1fb7e:	f805 3b01 	strb.w	r3, [r5], #1
   1fb82:	e234      	b.n	1ffee <_dtoa_r+0x90e>
   1fb84:	07e7      	lsls	r7, r4, #31
   1fb86:	d505      	bpl.n	1fb94 <_dtoa_r+0x4b4>
   1fb88:	3601      	adds	r6, #1
   1fb8a:	e9d5 2300 	ldrd	r2, r3, [r5]
   1fb8e:	f7fc fe13 	bl	1c7b8 <__aeabi_dmul>
   1fb92:	2301      	movs	r3, #1
   1fb94:	1064      	asrs	r4, r4, #1
   1fb96:	3508      	adds	r5, #8
   1fb98:	e773      	b.n	1fa82 <_dtoa_r+0x3a2>
   1fb9a:	2602      	movs	r6, #2
   1fb9c:	e775      	b.n	1fa8a <_dtoa_r+0x3aa>
   1fb9e:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
   1fba2:	464c      	mov	r4, r9
   1fba4:	e792      	b.n	1facc <_dtoa_r+0x3ec>
   1fba6:	4b4d      	ldr	r3, [pc, #308]	; (1fcdc <_dtoa_r+0x5fc>)
   1fba8:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
   1fbac:	e953 0102 	ldrd	r0, r1, [r3, #-8]
   1fbb0:	9b03      	ldr	r3, [sp, #12]
   1fbb2:	441c      	add	r4, r3
   1fbb4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1fbb6:	2b00      	cmp	r3, #0
   1fbb8:	d046      	beq.n	1fc48 <_dtoa_r+0x568>
   1fbba:	4602      	mov	r2, r0
   1fbbc:	460b      	mov	r3, r1
   1fbbe:	2000      	movs	r0, #0
   1fbc0:	494c      	ldr	r1, [pc, #304]	; (1fcf4 <_dtoa_r+0x614>)
   1fbc2:	f7fc ff23 	bl	1ca0c <__aeabi_ddiv>
   1fbc6:	4632      	mov	r2, r6
   1fbc8:	463b      	mov	r3, r7
   1fbca:	f7fc fc3d 	bl	1c448 <__aeabi_dsub>
   1fbce:	9d03      	ldr	r5, [sp, #12]
   1fbd0:	4606      	mov	r6, r0
   1fbd2:	460f      	mov	r7, r1
   1fbd4:	e9dd 0100 	ldrd	r0, r1, [sp]
   1fbd8:	f7fd fa8c 	bl	1d0f4 <__aeabi_d2iz>
   1fbdc:	9012      	str	r0, [sp, #72]	; 0x48
   1fbde:	f7fc fd81 	bl	1c6e4 <__aeabi_i2d>
   1fbe2:	4602      	mov	r2, r0
   1fbe4:	460b      	mov	r3, r1
   1fbe6:	e9dd 0100 	ldrd	r0, r1, [sp]
   1fbea:	f7fc fc2d 	bl	1c448 <__aeabi_dsub>
   1fbee:	9b12      	ldr	r3, [sp, #72]	; 0x48
   1fbf0:	4632      	mov	r2, r6
   1fbf2:	3330      	adds	r3, #48	; 0x30
   1fbf4:	f805 3b01 	strb.w	r3, [r5], #1
   1fbf8:	463b      	mov	r3, r7
   1fbfa:	e9cd 0100 	strd	r0, r1, [sp]
   1fbfe:	f7fd f84d 	bl	1cc9c <__aeabi_dcmplt>
   1fc02:	2800      	cmp	r0, #0
   1fc04:	d15f      	bne.n	1fcc6 <_dtoa_r+0x5e6>
   1fc06:	2000      	movs	r0, #0
   1fc08:	4936      	ldr	r1, [pc, #216]	; (1fce4 <_dtoa_r+0x604>)
   1fc0a:	e9dd 2300 	ldrd	r2, r3, [sp]
   1fc0e:	f7fc fc1b 	bl	1c448 <__aeabi_dsub>
   1fc12:	4632      	mov	r2, r6
   1fc14:	463b      	mov	r3, r7
   1fc16:	f7fd f841 	bl	1cc9c <__aeabi_dcmplt>
   1fc1a:	2800      	cmp	r0, #0
   1fc1c:	f040 80b2 	bne.w	1fd84 <_dtoa_r+0x6a4>
   1fc20:	42a5      	cmp	r5, r4
   1fc22:	f43f af7c 	beq.w	1fb1e <_dtoa_r+0x43e>
   1fc26:	2200      	movs	r2, #0
   1fc28:	4b2f      	ldr	r3, [pc, #188]	; (1fce8 <_dtoa_r+0x608>)
   1fc2a:	4630      	mov	r0, r6
   1fc2c:	4639      	mov	r1, r7
   1fc2e:	f7fc fdc3 	bl	1c7b8 <__aeabi_dmul>
   1fc32:	2200      	movs	r2, #0
   1fc34:	4606      	mov	r6, r0
   1fc36:	460f      	mov	r7, r1
   1fc38:	4b2b      	ldr	r3, [pc, #172]	; (1fce8 <_dtoa_r+0x608>)
   1fc3a:	e9dd 0100 	ldrd	r0, r1, [sp]
   1fc3e:	f7fc fdbb 	bl	1c7b8 <__aeabi_dmul>
   1fc42:	e9cd 0100 	strd	r0, r1, [sp]
   1fc46:	e7c5      	b.n	1fbd4 <_dtoa_r+0x4f4>
   1fc48:	4632      	mov	r2, r6
   1fc4a:	463b      	mov	r3, r7
   1fc4c:	f7fc fdb4 	bl	1c7b8 <__aeabi_dmul>
   1fc50:	4625      	mov	r5, r4
   1fc52:	9e03      	ldr	r6, [sp, #12]
   1fc54:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
   1fc58:	e9dd 0100 	ldrd	r0, r1, [sp]
   1fc5c:	f7fd fa4a 	bl	1d0f4 <__aeabi_d2iz>
   1fc60:	4607      	mov	r7, r0
   1fc62:	f7fc fd3f 	bl	1c6e4 <__aeabi_i2d>
   1fc66:	4602      	mov	r2, r0
   1fc68:	3730      	adds	r7, #48	; 0x30
   1fc6a:	460b      	mov	r3, r1
   1fc6c:	e9dd 0100 	ldrd	r0, r1, [sp]
   1fc70:	f7fc fbea 	bl	1c448 <__aeabi_dsub>
   1fc74:	f806 7b01 	strb.w	r7, [r6], #1
   1fc78:	42a6      	cmp	r6, r4
   1fc7a:	f04f 0200 	mov.w	r2, #0
   1fc7e:	e9cd 0100 	strd	r0, r1, [sp]
   1fc82:	d125      	bne.n	1fcd0 <_dtoa_r+0x5f0>
   1fc84:	4b1b      	ldr	r3, [pc, #108]	; (1fcf4 <_dtoa_r+0x614>)
   1fc86:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
   1fc8a:	f7fc fbdf 	bl	1c44c <__adddf3>
   1fc8e:	4602      	mov	r2, r0
   1fc90:	460b      	mov	r3, r1
   1fc92:	e9dd 0100 	ldrd	r0, r1, [sp]
   1fc96:	f7fd f81f 	bl	1ccd8 <__aeabi_dcmpgt>
   1fc9a:	2800      	cmp	r0, #0
   1fc9c:	d172      	bne.n	1fd84 <_dtoa_r+0x6a4>
   1fc9e:	2000      	movs	r0, #0
   1fca0:	4914      	ldr	r1, [pc, #80]	; (1fcf4 <_dtoa_r+0x614>)
   1fca2:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
   1fca6:	f7fc fbcf 	bl	1c448 <__aeabi_dsub>
   1fcaa:	4602      	mov	r2, r0
   1fcac:	460b      	mov	r3, r1
   1fcae:	e9dd 0100 	ldrd	r0, r1, [sp]
   1fcb2:	f7fc fff3 	bl	1cc9c <__aeabi_dcmplt>
   1fcb6:	2800      	cmp	r0, #0
   1fcb8:	f43f af31 	beq.w	1fb1e <_dtoa_r+0x43e>
   1fcbc:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   1fcc0:	1e6a      	subs	r2, r5, #1
   1fcc2:	2b30      	cmp	r3, #48	; 0x30
   1fcc4:	d002      	beq.n	1fccc <_dtoa_r+0x5ec>
   1fcc6:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
   1fcca:	e049      	b.n	1fd60 <_dtoa_r+0x680>
   1fccc:	4615      	mov	r5, r2
   1fcce:	e7f5      	b.n	1fcbc <_dtoa_r+0x5dc>
   1fcd0:	4b05      	ldr	r3, [pc, #20]	; (1fce8 <_dtoa_r+0x608>)
   1fcd2:	f7fc fd71 	bl	1c7b8 <__aeabi_dmul>
   1fcd6:	e9cd 0100 	strd	r0, r1, [sp]
   1fcda:	e7bd      	b.n	1fc58 <_dtoa_r+0x578>
   1fcdc:	0003fc20 	.word	0x0003fc20
   1fce0:	0003fbf8 	.word	0x0003fbf8
   1fce4:	3ff00000 	.word	0x3ff00000
   1fce8:	40240000 	.word	0x40240000
   1fcec:	401c0000 	.word	0x401c0000
   1fcf0:	40140000 	.word	0x40140000
   1fcf4:	3fe00000 	.word	0x3fe00000
   1fcf8:	e9dd 6700 	ldrd	r6, r7, [sp]
   1fcfc:	9d03      	ldr	r5, [sp, #12]
   1fcfe:	4630      	mov	r0, r6
   1fd00:	4639      	mov	r1, r7
   1fd02:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1fd06:	f7fc fe81 	bl	1ca0c <__aeabi_ddiv>
   1fd0a:	f7fd f9f3 	bl	1d0f4 <__aeabi_d2iz>
   1fd0e:	4604      	mov	r4, r0
   1fd10:	f7fc fce8 	bl	1c6e4 <__aeabi_i2d>
   1fd14:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1fd18:	f7fc fd4e 	bl	1c7b8 <__aeabi_dmul>
   1fd1c:	4602      	mov	r2, r0
   1fd1e:	4630      	mov	r0, r6
   1fd20:	f104 0630 	add.w	r6, r4, #48	; 0x30
   1fd24:	460b      	mov	r3, r1
   1fd26:	4639      	mov	r1, r7
   1fd28:	f7fc fb8e 	bl	1c448 <__aeabi_dsub>
   1fd2c:	f805 6b01 	strb.w	r6, [r5], #1
   1fd30:	9e03      	ldr	r6, [sp, #12]
   1fd32:	4602      	mov	r2, r0
   1fd34:	460b      	mov	r3, r1
   1fd36:	1bae      	subs	r6, r5, r6
   1fd38:	45b1      	cmp	r9, r6
   1fd3a:	d137      	bne.n	1fdac <_dtoa_r+0x6cc>
   1fd3c:	f7fc fb86 	bl	1c44c <__adddf3>
   1fd40:	4606      	mov	r6, r0
   1fd42:	460f      	mov	r7, r1
   1fd44:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1fd48:	f7fc ffc6 	bl	1ccd8 <__aeabi_dcmpgt>
   1fd4c:	b9c0      	cbnz	r0, 1fd80 <_dtoa_r+0x6a0>
   1fd4e:	4630      	mov	r0, r6
   1fd50:	4639      	mov	r1, r7
   1fd52:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1fd56:	f7fc ff97 	bl	1cc88 <__aeabi_dcmpeq>
   1fd5a:	b108      	cbz	r0, 1fd60 <_dtoa_r+0x680>
   1fd5c:	07e1      	lsls	r1, r4, #31
   1fd5e:	d40f      	bmi.n	1fd80 <_dtoa_r+0x6a0>
   1fd60:	4641      	mov	r1, r8
   1fd62:	4658      	mov	r0, fp
   1fd64:	f01f f8a9 	bl	3eeba <_Bfree>
   1fd68:	2300      	movs	r3, #0
   1fd6a:	9a14      	ldr	r2, [sp, #80]	; 0x50
   1fd6c:	702b      	strb	r3, [r5, #0]
   1fd6e:	f10a 0301 	add.w	r3, sl, #1
   1fd72:	6013      	str	r3, [r2, #0]
   1fd74:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   1fd76:	2b00      	cmp	r3, #0
   1fd78:	f43f acfb 	beq.w	1f772 <_dtoa_r+0x92>
   1fd7c:	601d      	str	r5, [r3, #0]
   1fd7e:	e4f8      	b.n	1f772 <_dtoa_r+0x92>
   1fd80:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
   1fd84:	f815 2c01 	ldrb.w	r2, [r5, #-1]
   1fd88:	1e6b      	subs	r3, r5, #1
   1fd8a:	2a39      	cmp	r2, #57	; 0x39
   1fd8c:	d108      	bne.n	1fda0 <_dtoa_r+0x6c0>
   1fd8e:	9a03      	ldr	r2, [sp, #12]
   1fd90:	429a      	cmp	r2, r3
   1fd92:	d109      	bne.n	1fda8 <_dtoa_r+0x6c8>
   1fd94:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1fd96:	9903      	ldr	r1, [sp, #12]
   1fd98:	3201      	adds	r2, #1
   1fd9a:	920a      	str	r2, [sp, #40]	; 0x28
   1fd9c:	2230      	movs	r2, #48	; 0x30
   1fd9e:	700a      	strb	r2, [r1, #0]
   1fda0:	781a      	ldrb	r2, [r3, #0]
   1fda2:	3201      	adds	r2, #1
   1fda4:	701a      	strb	r2, [r3, #0]
   1fda6:	e78e      	b.n	1fcc6 <_dtoa_r+0x5e6>
   1fda8:	461d      	mov	r5, r3
   1fdaa:	e7eb      	b.n	1fd84 <_dtoa_r+0x6a4>
   1fdac:	2200      	movs	r2, #0
   1fdae:	4b9d      	ldr	r3, [pc, #628]	; (20024 <__kernel_ram_size+0x24>)
   1fdb0:	f7fc fd02 	bl	1c7b8 <__aeabi_dmul>
   1fdb4:	2200      	movs	r2, #0
   1fdb6:	2300      	movs	r3, #0
   1fdb8:	4606      	mov	r6, r0
   1fdba:	460f      	mov	r7, r1
   1fdbc:	f7fc ff64 	bl	1cc88 <__aeabi_dcmpeq>
   1fdc0:	2800      	cmp	r0, #0
   1fdc2:	d09c      	beq.n	1fcfe <_dtoa_r+0x61e>
   1fdc4:	e7cc      	b.n	1fd60 <_dtoa_r+0x680>
   1fdc6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1fdc8:	2a00      	cmp	r2, #0
   1fdca:	f000 80cb 	beq.w	1ff64 <_dtoa_r+0x884>
   1fdce:	9a08      	ldr	r2, [sp, #32]
   1fdd0:	2a01      	cmp	r2, #1
   1fdd2:	f300 80ae 	bgt.w	1ff32 <_dtoa_r+0x852>
   1fdd6:	9a15      	ldr	r2, [sp, #84]	; 0x54
   1fdd8:	2a00      	cmp	r2, #0
   1fdda:	f000 80a6 	beq.w	1ff2a <_dtoa_r+0x84a>
   1fdde:	f203 4333 	addw	r3, r3, #1075	; 0x433
   1fde2:	9c09      	ldr	r4, [sp, #36]	; 0x24
   1fde4:	9d06      	ldr	r5, [sp, #24]
   1fde6:	9a06      	ldr	r2, [sp, #24]
   1fde8:	2101      	movs	r1, #1
   1fdea:	4658      	mov	r0, fp
   1fdec:	441a      	add	r2, r3
   1fdee:	9206      	str	r2, [sp, #24]
   1fdf0:	9a07      	ldr	r2, [sp, #28]
   1fdf2:	441a      	add	r2, r3
   1fdf4:	9207      	str	r2, [sp, #28]
   1fdf6:	f01f f904 	bl	3f002 <__i2b>
   1fdfa:	4606      	mov	r6, r0
   1fdfc:	2d00      	cmp	r5, #0
   1fdfe:	dd0c      	ble.n	1fe1a <_dtoa_r+0x73a>
   1fe00:	9b07      	ldr	r3, [sp, #28]
   1fe02:	2b00      	cmp	r3, #0
   1fe04:	dd09      	ble.n	1fe1a <_dtoa_r+0x73a>
   1fe06:	42ab      	cmp	r3, r5
   1fe08:	9a06      	ldr	r2, [sp, #24]
   1fe0a:	bfa8      	it	ge
   1fe0c:	462b      	movge	r3, r5
   1fe0e:	1ad2      	subs	r2, r2, r3
   1fe10:	1aed      	subs	r5, r5, r3
   1fe12:	9206      	str	r2, [sp, #24]
   1fe14:	9a07      	ldr	r2, [sp, #28]
   1fe16:	1ad3      	subs	r3, r2, r3
   1fe18:	9307      	str	r3, [sp, #28]
   1fe1a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1fe1c:	b1f3      	cbz	r3, 1fe5c <_dtoa_r+0x77c>
   1fe1e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1fe20:	2b00      	cmp	r3, #0
   1fe22:	f000 80a3 	beq.w	1ff6c <_dtoa_r+0x88c>
   1fe26:	2c00      	cmp	r4, #0
   1fe28:	dd10      	ble.n	1fe4c <_dtoa_r+0x76c>
   1fe2a:	4631      	mov	r1, r6
   1fe2c:	4622      	mov	r2, r4
   1fe2e:	4658      	mov	r0, fp
   1fe30:	f01a fa76 	bl	3a320 <__pow5mult>
   1fe34:	4642      	mov	r2, r8
   1fe36:	4601      	mov	r1, r0
   1fe38:	4606      	mov	r6, r0
   1fe3a:	4658      	mov	r0, fp
   1fe3c:	f01f f8ea 	bl	3f014 <__multiply>
   1fe40:	4607      	mov	r7, r0
   1fe42:	4641      	mov	r1, r8
   1fe44:	4658      	mov	r0, fp
   1fe46:	46b8      	mov	r8, r7
   1fe48:	f01f f837 	bl	3eeba <_Bfree>
   1fe4c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1fe4e:	1b1a      	subs	r2, r3, r4
   1fe50:	d004      	beq.n	1fe5c <_dtoa_r+0x77c>
   1fe52:	4641      	mov	r1, r8
   1fe54:	4658      	mov	r0, fp
   1fe56:	f01a fa63 	bl	3a320 <__pow5mult>
   1fe5a:	4680      	mov	r8, r0
   1fe5c:	2101      	movs	r1, #1
   1fe5e:	4658      	mov	r0, fp
   1fe60:	f01f f8cf 	bl	3f002 <__i2b>
   1fe64:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1fe66:	4604      	mov	r4, r0
   1fe68:	2b00      	cmp	r3, #0
   1fe6a:	f340 8081 	ble.w	1ff70 <_dtoa_r+0x890>
   1fe6e:	461a      	mov	r2, r3
   1fe70:	4601      	mov	r1, r0
   1fe72:	4658      	mov	r0, fp
   1fe74:	f01a fa54 	bl	3a320 <__pow5mult>
   1fe78:	9b08      	ldr	r3, [sp, #32]
   1fe7a:	4604      	mov	r4, r0
   1fe7c:	2b01      	cmp	r3, #1
   1fe7e:	dd7a      	ble.n	1ff76 <_dtoa_r+0x896>
   1fe80:	2700      	movs	r7, #0
   1fe82:	6923      	ldr	r3, [r4, #16]
   1fe84:	eb04 0383 	add.w	r3, r4, r3, lsl #2
   1fe88:	6918      	ldr	r0, [r3, #16]
   1fe8a:	f01f f86a 	bl	3ef62 <__hi0bits>
   1fe8e:	f1c0 0020 	rsb	r0, r0, #32
   1fe92:	9b07      	ldr	r3, [sp, #28]
   1fe94:	4418      	add	r0, r3
   1fe96:	f010 001f 	ands.w	r0, r0, #31
   1fe9a:	f000 808b 	beq.w	1ffb4 <_dtoa_r+0x8d4>
   1fe9e:	f1c0 0320 	rsb	r3, r0, #32
   1fea2:	2b04      	cmp	r3, #4
   1fea4:	f340 8084 	ble.w	1ffb0 <_dtoa_r+0x8d0>
   1fea8:	f1c0 001c 	rsb	r0, r0, #28
   1feac:	9b06      	ldr	r3, [sp, #24]
   1feae:	4405      	add	r5, r0
   1feb0:	4403      	add	r3, r0
   1feb2:	9306      	str	r3, [sp, #24]
   1feb4:	9b07      	ldr	r3, [sp, #28]
   1feb6:	4403      	add	r3, r0
   1feb8:	9307      	str	r3, [sp, #28]
   1feba:	9b06      	ldr	r3, [sp, #24]
   1febc:	2b00      	cmp	r3, #0
   1febe:	dd05      	ble.n	1fecc <_dtoa_r+0x7ec>
   1fec0:	4641      	mov	r1, r8
   1fec2:	461a      	mov	r2, r3
   1fec4:	4658      	mov	r0, fp
   1fec6:	f01f f934 	bl	3f132 <__lshift>
   1feca:	4680      	mov	r8, r0
   1fecc:	9b07      	ldr	r3, [sp, #28]
   1fece:	2b00      	cmp	r3, #0
   1fed0:	dd05      	ble.n	1fede <_dtoa_r+0x7fe>
   1fed2:	4621      	mov	r1, r4
   1fed4:	461a      	mov	r2, r3
   1fed6:	4658      	mov	r0, fp
   1fed8:	f01f f92b 	bl	3f132 <__lshift>
   1fedc:	4604      	mov	r4, r0
   1fede:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1fee0:	2b00      	cmp	r3, #0
   1fee2:	d069      	beq.n	1ffb8 <_dtoa_r+0x8d8>
   1fee4:	4621      	mov	r1, r4
   1fee6:	4640      	mov	r0, r8
   1fee8:	f01f f976 	bl	3f1d8 <__mcmp>
   1feec:	2800      	cmp	r0, #0
   1feee:	da63      	bge.n	1ffb8 <_dtoa_r+0x8d8>
   1fef0:	2300      	movs	r3, #0
   1fef2:	4641      	mov	r1, r8
   1fef4:	220a      	movs	r2, #10
   1fef6:	4658      	mov	r0, fp
   1fef8:	f01e fff6 	bl	3eee8 <__multadd>
   1fefc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1fefe:	f10a 3aff 	add.w	sl, sl, #4294967295
   1ff02:	4680      	mov	r8, r0
   1ff04:	2b00      	cmp	r3, #0
   1ff06:	f000 8179 	beq.w	201fc <__kernel_ram_size+0x1fc>
   1ff0a:	2300      	movs	r3, #0
   1ff0c:	4631      	mov	r1, r6
   1ff0e:	220a      	movs	r2, #10
   1ff10:	4658      	mov	r0, fp
   1ff12:	f01e ffe9 	bl	3eee8 <__multadd>
   1ff16:	9b04      	ldr	r3, [sp, #16]
   1ff18:	4606      	mov	r6, r0
   1ff1a:	2b00      	cmp	r3, #0
   1ff1c:	f300 808a 	bgt.w	20034 <__kernel_ram_size+0x34>
   1ff20:	9b08      	ldr	r3, [sp, #32]
   1ff22:	2b02      	cmp	r3, #2
   1ff24:	f340 8086 	ble.w	20034 <__kernel_ram_size+0x34>
   1ff28:	e04e      	b.n	1ffc8 <_dtoa_r+0x8e8>
   1ff2a:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1ff2c:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
   1ff30:	e757      	b.n	1fde2 <_dtoa_r+0x702>
   1ff32:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1ff34:	f109 34ff 	add.w	r4, r9, #4294967295
   1ff38:	42a3      	cmp	r3, r4
   1ff3a:	bfb7      	itett	lt
   1ff3c:	9b09      	ldrlt	r3, [sp, #36]	; 0x24
   1ff3e:	1b1c      	subge	r4, r3, r4
   1ff40:	9409      	strlt	r4, [sp, #36]	; 0x24
   1ff42:	1ae2      	sublt	r2, r4, r3
   1ff44:	bfbf      	itttt	lt
   1ff46:	9b10      	ldrlt	r3, [sp, #64]	; 0x40
   1ff48:	2400      	movlt	r4, #0
   1ff4a:	189b      	addlt	r3, r3, r2
   1ff4c:	9310      	strlt	r3, [sp, #64]	; 0x40
   1ff4e:	f1b9 0f00 	cmp.w	r9, #0
   1ff52:	bfb3      	iteet	lt
   1ff54:	9b06      	ldrlt	r3, [sp, #24]
   1ff56:	464b      	movge	r3, r9
   1ff58:	9d06      	ldrge	r5, [sp, #24]
   1ff5a:	eba3 0509 	sublt.w	r5, r3, r9
   1ff5e:	bfb8      	it	lt
   1ff60:	2300      	movlt	r3, #0
   1ff62:	e740      	b.n	1fde6 <_dtoa_r+0x706>
   1ff64:	9c09      	ldr	r4, [sp, #36]	; 0x24
   1ff66:	9d06      	ldr	r5, [sp, #24]
   1ff68:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   1ff6a:	e747      	b.n	1fdfc <_dtoa_r+0x71c>
   1ff6c:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1ff6e:	e770      	b.n	1fe52 <_dtoa_r+0x772>
   1ff70:	9b08      	ldr	r3, [sp, #32]
   1ff72:	2b01      	cmp	r3, #1
   1ff74:	dc18      	bgt.n	1ffa8 <_dtoa_r+0x8c8>
   1ff76:	9b00      	ldr	r3, [sp, #0]
   1ff78:	b9b3      	cbnz	r3, 1ffa8 <_dtoa_r+0x8c8>
   1ff7a:	9b01      	ldr	r3, [sp, #4]
   1ff7c:	f3c3 0313 	ubfx	r3, r3, #0, #20
   1ff80:	b9a3      	cbnz	r3, 1ffac <_dtoa_r+0x8cc>
   1ff82:	9b01      	ldr	r3, [sp, #4]
   1ff84:	f023 4700 	bic.w	r7, r3, #2147483648	; 0x80000000
   1ff88:	0d3f      	lsrs	r7, r7, #20
   1ff8a:	053f      	lsls	r7, r7, #20
   1ff8c:	b137      	cbz	r7, 1ff9c <_dtoa_r+0x8bc>
   1ff8e:	9b06      	ldr	r3, [sp, #24]
   1ff90:	2701      	movs	r7, #1
   1ff92:	3301      	adds	r3, #1
   1ff94:	9306      	str	r3, [sp, #24]
   1ff96:	9b07      	ldr	r3, [sp, #28]
   1ff98:	3301      	adds	r3, #1
   1ff9a:	9307      	str	r3, [sp, #28]
   1ff9c:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1ff9e:	2b00      	cmp	r3, #0
   1ffa0:	f47f af6f 	bne.w	1fe82 <_dtoa_r+0x7a2>
   1ffa4:	2001      	movs	r0, #1
   1ffa6:	e774      	b.n	1fe92 <_dtoa_r+0x7b2>
   1ffa8:	2700      	movs	r7, #0
   1ffaa:	e7f7      	b.n	1ff9c <_dtoa_r+0x8bc>
   1ffac:	9f00      	ldr	r7, [sp, #0]
   1ffae:	e7f5      	b.n	1ff9c <_dtoa_r+0x8bc>
   1ffb0:	d083      	beq.n	1feba <_dtoa_r+0x7da>
   1ffb2:	4618      	mov	r0, r3
   1ffb4:	301c      	adds	r0, #28
   1ffb6:	e779      	b.n	1feac <_dtoa_r+0x7cc>
   1ffb8:	f1b9 0f00 	cmp.w	r9, #0
   1ffbc:	dc34      	bgt.n	20028 <__kernel_ram_size+0x28>
   1ffbe:	9b08      	ldr	r3, [sp, #32]
   1ffc0:	2b02      	cmp	r3, #2
   1ffc2:	dd31      	ble.n	20028 <__kernel_ram_size+0x28>
   1ffc4:	f8cd 9010 	str.w	r9, [sp, #16]
   1ffc8:	9b04      	ldr	r3, [sp, #16]
   1ffca:	b963      	cbnz	r3, 1ffe6 <_dtoa_r+0x906>
   1ffcc:	4621      	mov	r1, r4
   1ffce:	2205      	movs	r2, #5
   1ffd0:	4658      	mov	r0, fp
   1ffd2:	f01e ff89 	bl	3eee8 <__multadd>
   1ffd6:	4601      	mov	r1, r0
   1ffd8:	4604      	mov	r4, r0
   1ffda:	4640      	mov	r0, r8
   1ffdc:	f01f f8fc 	bl	3f1d8 <__mcmp>
   1ffe0:	2800      	cmp	r0, #0
   1ffe2:	f73f adc8 	bgt.w	1fb76 <_dtoa_r+0x496>
   1ffe6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1ffe8:	9d03      	ldr	r5, [sp, #12]
   1ffea:	ea6f 0a03 	mvn.w	sl, r3
   1ffee:	2700      	movs	r7, #0
   1fff0:	4621      	mov	r1, r4
   1fff2:	4658      	mov	r0, fp
   1fff4:	f01e ff61 	bl	3eeba <_Bfree>
   1fff8:	2e00      	cmp	r6, #0
   1fffa:	f43f aeb1 	beq.w	1fd60 <_dtoa_r+0x680>
   1fffe:	b12f      	cbz	r7, 2000c <__kernel_ram_size+0xc>
   20000:	42b7      	cmp	r7, r6
   20002:	d003      	beq.n	2000c <__kernel_ram_size+0xc>
   20004:	4639      	mov	r1, r7
   20006:	4658      	mov	r0, fp
   20008:	f01e ff57 	bl	3eeba <_Bfree>
   2000c:	4631      	mov	r1, r6
   2000e:	4658      	mov	r0, fp
   20010:	f01e ff53 	bl	3eeba <_Bfree>
   20014:	e6a4      	b.n	1fd60 <_dtoa_r+0x680>
   20016:	2400      	movs	r4, #0
   20018:	4626      	mov	r6, r4
   2001a:	e7e4      	b.n	1ffe6 <_dtoa_r+0x906>
   2001c:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
   20020:	4626      	mov	r6, r4
   20022:	e5a8      	b.n	1fb76 <_dtoa_r+0x496>
   20024:	40240000 	.word	0x40240000
   20028:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   2002a:	f8cd 9010 	str.w	r9, [sp, #16]
   2002e:	2b00      	cmp	r3, #0
   20030:	f000 80eb 	beq.w	2020a <__kernel_ram_size+0x20a>
   20034:	2d00      	cmp	r5, #0
   20036:	dd05      	ble.n	20044 <__kernel_ram_size+0x44>
   20038:	4631      	mov	r1, r6
   2003a:	462a      	mov	r2, r5
   2003c:	4658      	mov	r0, fp
   2003e:	f01f f878 	bl	3f132 <__lshift>
   20042:	4606      	mov	r6, r0
   20044:	2f00      	cmp	r7, #0
   20046:	d056      	beq.n	200f6 <__kernel_ram_size+0xf6>
   20048:	6871      	ldr	r1, [r6, #4]
   2004a:	4658      	mov	r0, fp
   2004c:	f01e ff01 	bl	3ee52 <_Balloc>
   20050:	6932      	ldr	r2, [r6, #16]
   20052:	4605      	mov	r5, r0
   20054:	f106 010c 	add.w	r1, r6, #12
   20058:	3202      	adds	r2, #2
   2005a:	300c      	adds	r0, #12
   2005c:	0092      	lsls	r2, r2, #2
   2005e:	f01e fbf5 	bl	3e84c <memcpy>
   20062:	2201      	movs	r2, #1
   20064:	4629      	mov	r1, r5
   20066:	4658      	mov	r0, fp
   20068:	f01f f863 	bl	3f132 <__lshift>
   2006c:	9b03      	ldr	r3, [sp, #12]
   2006e:	4637      	mov	r7, r6
   20070:	4606      	mov	r6, r0
   20072:	f103 0901 	add.w	r9, r3, #1
   20076:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
   2007a:	4413      	add	r3, r2
   2007c:	9309      	str	r3, [sp, #36]	; 0x24
   2007e:	9b00      	ldr	r3, [sp, #0]
   20080:	f003 0301 	and.w	r3, r3, #1
   20084:	9307      	str	r3, [sp, #28]
   20086:	f109 33ff 	add.w	r3, r9, #4294967295
   2008a:	4621      	mov	r1, r4
   2008c:	4640      	mov	r0, r8
   2008e:	9300      	str	r3, [sp, #0]
   20090:	f01e fddc 	bl	3ec4c <quorem>
   20094:	4603      	mov	r3, r0
   20096:	9004      	str	r0, [sp, #16]
   20098:	4639      	mov	r1, r7
   2009a:	4640      	mov	r0, r8
   2009c:	3330      	adds	r3, #48	; 0x30
   2009e:	930a      	str	r3, [sp, #40]	; 0x28
   200a0:	f01f f89a 	bl	3f1d8 <__mcmp>
   200a4:	4632      	mov	r2, r6
   200a6:	9006      	str	r0, [sp, #24]
   200a8:	4621      	mov	r1, r4
   200aa:	4658      	mov	r0, fp
   200ac:	f01f f8ae 	bl	3f20c <__mdiff>
   200b0:	68c2      	ldr	r2, [r0, #12]
   200b2:	4605      	mov	r5, r0
   200b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   200b6:	bb02      	cbnz	r2, 200fa <__kernel_ram_size+0xfa>
   200b8:	4601      	mov	r1, r0
   200ba:	4640      	mov	r0, r8
   200bc:	f01f f88c 	bl	3f1d8 <__mcmp>
   200c0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   200c2:	4602      	mov	r2, r0
   200c4:	4629      	mov	r1, r5
   200c6:	4658      	mov	r0, fp
   200c8:	920c      	str	r2, [sp, #48]	; 0x30
   200ca:	464d      	mov	r5, r9
   200cc:	930a      	str	r3, [sp, #40]	; 0x28
   200ce:	f01e fef4 	bl	3eeba <_Bfree>
   200d2:	9b08      	ldr	r3, [sp, #32]
   200d4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   200d6:	ea43 0102 	orr.w	r1, r3, r2
   200da:	9b07      	ldr	r3, [sp, #28]
   200dc:	430b      	orrs	r3, r1
   200de:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   200e0:	d10d      	bne.n	200fe <__kernel_ram_size+0xfe>
   200e2:	2b39      	cmp	r3, #57	; 0x39
   200e4:	d027      	beq.n	20136 <__kernel_ram_size+0x136>
   200e6:	9a06      	ldr	r2, [sp, #24]
   200e8:	2a00      	cmp	r2, #0
   200ea:	dd01      	ble.n	200f0 <__kernel_ram_size+0xf0>
   200ec:	9b04      	ldr	r3, [sp, #16]
   200ee:	3331      	adds	r3, #49	; 0x31
   200f0:	9a00      	ldr	r2, [sp, #0]
   200f2:	7013      	strb	r3, [r2, #0]
   200f4:	e77c      	b.n	1fff0 <_dtoa_r+0x910>
   200f6:	4630      	mov	r0, r6
   200f8:	e7b8      	b.n	2006c <__kernel_ram_size+0x6c>
   200fa:	2201      	movs	r2, #1
   200fc:	e7e2      	b.n	200c4 <__kernel_ram_size+0xc4>
   200fe:	9906      	ldr	r1, [sp, #24]
   20100:	2900      	cmp	r1, #0
   20102:	db04      	blt.n	2010e <__kernel_ram_size+0x10e>
   20104:	9808      	ldr	r0, [sp, #32]
   20106:	4301      	orrs	r1, r0
   20108:	9807      	ldr	r0, [sp, #28]
   2010a:	4301      	orrs	r1, r0
   2010c:	d11d      	bne.n	2014a <__kernel_ram_size+0x14a>
   2010e:	2a00      	cmp	r2, #0
   20110:	ddee      	ble.n	200f0 <__kernel_ram_size+0xf0>
   20112:	4641      	mov	r1, r8
   20114:	2201      	movs	r2, #1
   20116:	4658      	mov	r0, fp
   20118:	9306      	str	r3, [sp, #24]
   2011a:	f01f f80a 	bl	3f132 <__lshift>
   2011e:	4621      	mov	r1, r4
   20120:	4680      	mov	r8, r0
   20122:	f01f f859 	bl	3f1d8 <__mcmp>
   20126:	2800      	cmp	r0, #0
   20128:	9b06      	ldr	r3, [sp, #24]
   2012a:	dc02      	bgt.n	20132 <__kernel_ram_size+0x132>
   2012c:	d1e0      	bne.n	200f0 <__kernel_ram_size+0xf0>
   2012e:	07da      	lsls	r2, r3, #31
   20130:	d5de      	bpl.n	200f0 <__kernel_ram_size+0xf0>
   20132:	2b39      	cmp	r3, #57	; 0x39
   20134:	d1da      	bne.n	200ec <__kernel_ram_size+0xec>
   20136:	2339      	movs	r3, #57	; 0x39
   20138:	9a00      	ldr	r2, [sp, #0]
   2013a:	7013      	strb	r3, [r2, #0]
   2013c:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   20140:	1e6a      	subs	r2, r5, #1
   20142:	2b39      	cmp	r3, #57	; 0x39
   20144:	d046      	beq.n	201d4 <__kernel_ram_size+0x1d4>
   20146:	3301      	adds	r3, #1
   20148:	e7d3      	b.n	200f2 <__kernel_ram_size+0xf2>
   2014a:	2a00      	cmp	r2, #0
   2014c:	dd03      	ble.n	20156 <__kernel_ram_size+0x156>
   2014e:	2b39      	cmp	r3, #57	; 0x39
   20150:	d0f1      	beq.n	20136 <__kernel_ram_size+0x136>
   20152:	3301      	adds	r3, #1
   20154:	e7cc      	b.n	200f0 <__kernel_ram_size+0xf0>
   20156:	9a09      	ldr	r2, [sp, #36]	; 0x24
   20158:	f809 3c01 	strb.w	r3, [r9, #-1]
   2015c:	4591      	cmp	r9, r2
   2015e:	d021      	beq.n	201a4 <__kernel_ram_size+0x1a4>
   20160:	4641      	mov	r1, r8
   20162:	2300      	movs	r3, #0
   20164:	220a      	movs	r2, #10
   20166:	4658      	mov	r0, fp
   20168:	f01e febe 	bl	3eee8 <__multadd>
   2016c:	42b7      	cmp	r7, r6
   2016e:	4680      	mov	r8, r0
   20170:	f04f 0300 	mov.w	r3, #0
   20174:	f04f 020a 	mov.w	r2, #10
   20178:	4639      	mov	r1, r7
   2017a:	4658      	mov	r0, fp
   2017c:	d106      	bne.n	2018c <__kernel_ram_size+0x18c>
   2017e:	f01e feb3 	bl	3eee8 <__multadd>
   20182:	4607      	mov	r7, r0
   20184:	4606      	mov	r6, r0
   20186:	f109 0901 	add.w	r9, r9, #1
   2018a:	e77c      	b.n	20086 <__kernel_ram_size+0x86>
   2018c:	f01e feac 	bl	3eee8 <__multadd>
   20190:	4631      	mov	r1, r6
   20192:	4607      	mov	r7, r0
   20194:	2300      	movs	r3, #0
   20196:	220a      	movs	r2, #10
   20198:	4658      	mov	r0, fp
   2019a:	f01e fea5 	bl	3eee8 <__multadd>
   2019e:	4606      	mov	r6, r0
   201a0:	e7f1      	b.n	20186 <__kernel_ram_size+0x186>
   201a2:	2700      	movs	r7, #0
   201a4:	4641      	mov	r1, r8
   201a6:	2201      	movs	r2, #1
   201a8:	4658      	mov	r0, fp
   201aa:	9300      	str	r3, [sp, #0]
   201ac:	f01e ffc1 	bl	3f132 <__lshift>
   201b0:	4621      	mov	r1, r4
   201b2:	4680      	mov	r8, r0
   201b4:	f01f f810 	bl	3f1d8 <__mcmp>
   201b8:	2800      	cmp	r0, #0
   201ba:	dcbf      	bgt.n	2013c <__kernel_ram_size+0x13c>
   201bc:	d102      	bne.n	201c4 <__kernel_ram_size+0x1c4>
   201be:	9b00      	ldr	r3, [sp, #0]
   201c0:	07db      	lsls	r3, r3, #31
   201c2:	d4bb      	bmi.n	2013c <__kernel_ram_size+0x13c>
   201c4:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   201c8:	1e6a      	subs	r2, r5, #1
   201ca:	2b30      	cmp	r3, #48	; 0x30
   201cc:	f47f af10 	bne.w	1fff0 <_dtoa_r+0x910>
   201d0:	4615      	mov	r5, r2
   201d2:	e7f7      	b.n	201c4 <__kernel_ram_size+0x1c4>
   201d4:	9b03      	ldr	r3, [sp, #12]
   201d6:	4293      	cmp	r3, r2
   201d8:	d104      	bne.n	201e4 <__kernel_ram_size+0x1e4>
   201da:	f10a 0a01 	add.w	sl, sl, #1
   201de:	2331      	movs	r3, #49	; 0x31
   201e0:	9a03      	ldr	r2, [sp, #12]
   201e2:	e786      	b.n	200f2 <__kernel_ram_size+0xf2>
   201e4:	4615      	mov	r5, r2
   201e6:	e7a9      	b.n	2013c <__kernel_ram_size+0x13c>
   201e8:	4b13      	ldr	r3, [pc, #76]	; (20238 <__kernel_ram_size+0x238>)
   201ea:	f7ff bae1 	b.w	1f7b0 <_dtoa_r+0xd0>
   201ee:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   201f0:	2b00      	cmp	r3, #0
   201f2:	f47f aab9 	bne.w	1f768 <_dtoa_r+0x88>
   201f6:	4b11      	ldr	r3, [pc, #68]	; (2023c <__kernel_ram_size+0x23c>)
   201f8:	f7ff bada 	b.w	1f7b0 <_dtoa_r+0xd0>
   201fc:	9b04      	ldr	r3, [sp, #16]
   201fe:	2b00      	cmp	r3, #0
   20200:	dc03      	bgt.n	2020a <__kernel_ram_size+0x20a>
   20202:	9b08      	ldr	r3, [sp, #32]
   20204:	2b02      	cmp	r3, #2
   20206:	f73f aedf 	bgt.w	1ffc8 <_dtoa_r+0x8e8>
   2020a:	9d03      	ldr	r5, [sp, #12]
   2020c:	4621      	mov	r1, r4
   2020e:	4640      	mov	r0, r8
   20210:	f01e fd1c 	bl	3ec4c <quorem>
   20214:	9a03      	ldr	r2, [sp, #12]
   20216:	f100 0330 	add.w	r3, r0, #48	; 0x30
   2021a:	9904      	ldr	r1, [sp, #16]
   2021c:	f805 3b01 	strb.w	r3, [r5], #1
   20220:	1aaa      	subs	r2, r5, r2
   20222:	4291      	cmp	r1, r2
   20224:	ddbd      	ble.n	201a2 <__kernel_ram_size+0x1a2>
   20226:	4641      	mov	r1, r8
   20228:	2300      	movs	r3, #0
   2022a:	220a      	movs	r2, #10
   2022c:	4658      	mov	r0, fp
   2022e:	f01e fe5b 	bl	3eee8 <__multadd>
   20232:	4680      	mov	r8, r0
   20234:	e7ea      	b.n	2020c <__kernel_ram_size+0x20c>
   20236:	bf00      	nop
   20238:	00043e6b 	.word	0x00043e6b
   2023c:	00044494 	.word	0x00044494

00020240 <system_init>:
#endif
#endif
}

void system_init(void)
{
   20240:	b508      	push	{r3, lr}
	InitSystemSettings();
   20242:	f001 fc1f 	bl	21a84 <InitSystemSettings>
	
	pmu_init();
   20246:	f005 fca5 	bl	25b94 <pmu_init>
	flash_init();
   2024a:	f001 fcdd 	bl	21c08 <flash_init>
	LCD_Init();
   2024e:	f000 ff1d 	bl	2108c <LCD_Init>
	
	//ShowBootUpLogo();

	key_init();
   20252:	f001 fa9d 	bl	21790 <key_init>
	IMU_init(&imu_work_q);
   20256:	4806      	ldr	r0, [pc, #24]	; (20270 <system_init+0x30>)
   20258:	f004 fa5e 	bl	24718 <IMU_init>
	ble_init();//UART_0ATAT
   2025c:	f002 fbb6 	bl	229cc <ble_init>
	NB_init(&nb_work_q);
   20260:	4804      	ldr	r0, [pc, #16]	; (20274 <system_init+0x34>)
   20262:	f003 fd63 	bl	23d2c <NB_init>
	
	EnterIdleScreen();
}
   20266:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	EnterIdleScreen();
   2026a:	f005 b9bf 	b.w	255ec <EnterIdleScreen>
   2026e:	bf00      	nop
   20270:	20020960 	.word	0x20020960
   20274:	20020a24 	.word	0x20020a24

00020278 <work_init>:

void work_init(void)
{
   20278:	b510      	push	{r4, lr}
	k_work_q_start(&nb_work_q, nb_stack_area,
   2027a:	f04f 33ff 	mov.w	r3, #4294967295
   2027e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   20282:	4907      	ldr	r1, [pc, #28]	; (202a0 <work_init+0x28>)
   20284:	4807      	ldr	r0, [pc, #28]	; (202a4 <work_init+0x2c>)
   20286:	f017 fe0b 	bl	37ea0 <k_work_q_start>
		       		K_THREAD_STACK_SIZEOF(nb_stack_area),
		       		CONFIG_APPLICATION_WORKQUEUE_PRIORITY);
    k_work_q_start(&imu_work_q, imu_stack_area,
					K_THREAD_STACK_SIZEOF(imu_stack_area),
					CONFIG_APPLICATION_WORKQUEUE_PRIORITY);
}
   2028a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    k_work_q_start(&imu_work_q, imu_stack_area,
   2028e:	f04f 33ff 	mov.w	r3, #4294967295
   20292:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   20296:	4904      	ldr	r1, [pc, #16]	; (202a8 <work_init+0x30>)
   20298:	4804      	ldr	r0, [pc, #16]	; (202ac <work_init+0x34>)
   2029a:	f017 be01 	b.w	37ea0 <k_work_q_start>
   2029e:	bf00      	nop
   202a0:	2002d948 	.word	0x2002d948
   202a4:	20020a24 	.word	0x20020a24
   202a8:	2002e948 	.word	0x2002e948
   202ac:	20020960 	.word	0x20020960

000202b0 <clock_timer_handler>:
	}
}

static void clock_timer_handler(struct k_timer *timer)
{
	sys_time_count = true;
   202b0:	2201      	movs	r2, #1
   202b2:	4b01      	ldr	r3, [pc, #4]	; (202b8 <clock_timer_handler+0x8>)
   202b4:	701a      	strb	r2, [r3, #0]
}
   202b6:	4770      	bx	lr
   202b8:	20029917 	.word	0x20029917

000202bc <DateIncreaseOne>:
{
   202bc:	b510      	push	{r4, lr}
	(*date).day++;
   202be:	78c2      	ldrb	r2, [r0, #3]
	if((*date).month == 1 \
   202c0:	7883      	ldrb	r3, [r0, #2]
	(*date).day++;
   202c2:	3201      	adds	r2, #1
   202c4:	b2d2      	uxtb	r2, r2
	if((*date).month == 1 \
   202c6:	2b0c      	cmp	r3, #12
{
   202c8:	4604      	mov	r4, r0
	(*date).day++;
   202ca:	70c2      	strb	r2, [r0, #3]
	if((*date).month == 1 \
   202cc:	d804      	bhi.n	202d8 <DateIncreaseOne+0x1c>
   202ce:	f241 51aa 	movw	r1, #5546	; 0x15aa
   202d2:	40d9      	lsrs	r1, r3
   202d4:	07c9      	lsls	r1, r1, #31
   202d6:	d41e      	bmi.n	20316 <DateIncreaseOne+0x5a>
	else if((*date).month == 4 \
   202d8:	f003 01fd 	and.w	r1, r3, #253	; 0xfd
   202dc:	2904      	cmp	r1, #4
   202de:	d124      	bne.n	2032a <DateIncreaseOne+0x6e>
		if((*date).day > 30)
   202e0:	2a1e      	cmp	r2, #30
   202e2:	d909      	bls.n	202f8 <DateIncreaseOne+0x3c>
			(*date).day = 1;
   202e4:	2201      	movs	r2, #1
			(*date).month++;
   202e6:	4413      	add	r3, r2
   202e8:	b2db      	uxtb	r3, r3
			if((*date).month > 12)
   202ea:	2b0c      	cmp	r3, #12
			(*date).day = 1;
   202ec:	70e2      	strb	r2, [r4, #3]
			if((*date).month > 12)
   202ee:	d91a      	bls.n	20326 <DateIncreaseOne+0x6a>
				(*date).year++;
   202f0:	8823      	ldrh	r3, [r4, #0]
				(*date).month = 1;
   202f2:	70a2      	strb	r2, [r4, #2]
				(*date).year++;
   202f4:	3301      	adds	r3, #1
   202f6:	8023      	strh	r3, [r4, #0]
	(*date).week = GetWeekDayByDate((*date));
   202f8:	6861      	ldr	r1, [r4, #4]
   202fa:	6820      	ldr	r0, [r4, #0]
   202fc:	f01a fab6 	bl	3a86c <GetWeekDayByDate>
	if(screen_id == SCREEN_ID_IDLE)
   20300:	4b14      	ldr	r3, [pc, #80]	; (20354 <DateIncreaseOne+0x98>)
	(*date).week = GetWeekDayByDate((*date));
   20302:	71e0      	strb	r0, [r4, #7]
	if(screen_id == SCREEN_ID_IDLE)
   20304:	781b      	ldrb	r3, [r3, #0]
   20306:	2b01      	cmp	r3, #1
		scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);
   20308:	bf01      	itttt	eq
   2030a:	4a13      	ldreq	r2, [pc, #76]	; (20358 <DateIncreaseOne+0x9c>)
   2030c:	68d3      	ldreq	r3, [r2, #12]
   2030e:	f043 0318 	orreq.w	r3, r3, #24
   20312:	60d3      	streq	r3, [r2, #12]
}
   20314:	bd10      	pop	{r4, pc}
		if((*date).day > 31)
   20316:	2a1f      	cmp	r2, #31
   20318:	d9ee      	bls.n	202f8 <DateIncreaseOne+0x3c>
			(*date).day = 1;
   2031a:	2201      	movs	r2, #1
			(*date).month++;
   2031c:	4413      	add	r3, r2
   2031e:	b2db      	uxtb	r3, r3
			if((*date).month > 12)
   20320:	2b0d      	cmp	r3, #13
			(*date).day = 1;
   20322:	70c2      	strb	r2, [r0, #3]
			if((*date).month > 12)
   20324:	d0e4      	beq.n	202f0 <DateIncreaseOne+0x34>
			(*date).month++;
   20326:	70a3      	strb	r3, [r4, #2]
   20328:	e7e6      	b.n	202f8 <DateIncreaseOne+0x3c>
		|| (*date).month == 9 \
   2032a:	2909      	cmp	r1, #9
   2032c:	d0d8      	beq.n	202e0 <DateIncreaseOne+0x24>
		if((*date).year%4 == 0)
   2032e:	8821      	ldrh	r1, [r4, #0]
		if((*date).day > (28+Leap))
   20330:	f011 0f03 	tst.w	r1, #3
   20334:	bf0c      	ite	eq
   20336:	201d      	moveq	r0, #29
   20338:	201c      	movne	r0, #28
   2033a:	4282      	cmp	r2, r0
   2033c:	dddc      	ble.n	202f8 <DateIncreaseOne+0x3c>
			(*date).day = 1;
   2033e:	2201      	movs	r2, #1
			(*date).month++;
   20340:	4413      	add	r3, r2
   20342:	b2db      	uxtb	r3, r3
			if((*date).month > 12)
   20344:	2b0c      	cmp	r3, #12
			(*date).day = 1;
   20346:	70e2      	strb	r2, [r4, #3]
			if((*date).month > 12)
   20348:	d9ed      	bls.n	20326 <DateIncreaseOne+0x6a>
				(*date).year++;
   2034a:	3101      	adds	r1, #1
				(*date).month = 1;
   2034c:	70a2      	strb	r2, [r4, #2]
				(*date).year++;
   2034e:	8021      	strh	r1, [r4, #0]
   20350:	e7d2      	b.n	202f8 <DateIncreaseOne+0x3c>
   20352:	bf00      	nop
   20354:	2002c382 	.word	0x2002c382
   20358:	200249ec 	.word	0x200249ec

0002035c <DateDecreaseOne>:
{
   2035c:	b510      	push	{r4, lr}
	if((*date).day > 1)
   2035e:	78c3      	ldrb	r3, [r0, #3]
{
   20360:	4604      	mov	r4, r0
	if((*date).day > 1)
   20362:	2b01      	cmp	r3, #1
   20364:	d910      	bls.n	20388 <DateDecreaseOne+0x2c>
		(*date).day--;
   20366:	3b01      	subs	r3, #1
   20368:	70c3      	strb	r3, [r0, #3]
	(*date).week = GetWeekDayByDate((*date));
   2036a:	6861      	ldr	r1, [r4, #4]
   2036c:	6820      	ldr	r0, [r4, #0]
   2036e:	f01a fa7d 	bl	3a86c <GetWeekDayByDate>
	if(screen_id == SCREEN_ID_IDLE)
   20372:	4b18      	ldr	r3, [pc, #96]	; (203d4 <DateDecreaseOne+0x78>)
	(*date).week = GetWeekDayByDate((*date));
   20374:	71e0      	strb	r0, [r4, #7]
	if(screen_id == SCREEN_ID_IDLE)
   20376:	781b      	ldrb	r3, [r3, #0]
   20378:	2b01      	cmp	r3, #1
		scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);
   2037a:	bf01      	itttt	eq
   2037c:	4a16      	ldreq	r2, [pc, #88]	; (203d8 <DateDecreaseOne+0x7c>)
   2037e:	68d3      	ldreq	r3, [r2, #12]
   20380:	f043 0318 	orreq.w	r3, r3, #24
   20384:	60d3      	streq	r3, [r2, #12]
}
   20386:	bd10      	pop	{r4, pc}
		if((*date).month == 1 \
   20388:	7882      	ldrb	r2, [r0, #2]
		|| (*date).month == 2 \
   2038a:	1e53      	subs	r3, r2, #1
   2038c:	b2db      	uxtb	r3, r3
		if((*date).month == 1 \
   2038e:	2b0a      	cmp	r3, #10
   20390:	d90a      	bls.n	203a8 <DateDecreaseOne+0x4c>
		else if((*date).month == 5 \
   20392:	2a0c      	cmp	r2, #12
   20394:	d817      	bhi.n	203c6 <DateDecreaseOne+0x6a>
   20396:	f44f 51a5 	mov.w	r1, #5280	; 0x14a0
   2039a:	fa21 f202 	lsr.w	r2, r1, r2
   2039e:	07d2      	lsls	r2, r2, #31
   203a0:	d511      	bpl.n	203c6 <DateDecreaseOne+0x6a>
			(*date).day = 30;
   203a2:	221e      	movs	r2, #30
			(*date).day = (28+Leap);
   203a4:	70e2      	strb	r2, [r4, #3]
   203a6:	e00c      	b.n	203c2 <DateDecreaseOne+0x66>
		if((*date).month == 1 \
   203a8:	f240 51ab 	movw	r1, #1451	; 0x5ab
   203ac:	40d9      	lsrs	r1, r3
   203ae:	07c9      	lsls	r1, r1, #31
   203b0:	d5f1      	bpl.n	20396 <DateDecreaseOne+0x3a>
			(*date).day = 31;
   203b2:	211f      	movs	r1, #31
			if((*date).month == 1)
   203b4:	2a01      	cmp	r2, #1
			(*date).day = 31;
   203b6:	70c1      	strb	r1, [r0, #3]
			if((*date).month == 1)
   203b8:	d103      	bne.n	203c2 <DateDecreaseOne+0x66>
				(*date).year--;
   203ba:	8803      	ldrh	r3, [r0, #0]
   203bc:	3b01      	subs	r3, #1
   203be:	8003      	strh	r3, [r0, #0]
				(*date).month = 12;
   203c0:	230c      	movs	r3, #12
			(*date).month--;
   203c2:	70a3      	strb	r3, [r4, #2]
   203c4:	e7d1      	b.n	2036a <DateDecreaseOne+0xe>
			if((*date).year%4 == 0)
   203c6:	8822      	ldrh	r2, [r4, #0]
   203c8:	f012 0f03 	tst.w	r2, #3
			(*date).day = (28+Leap);
   203cc:	bf14      	ite	ne
   203ce:	221c      	movne	r2, #28
   203d0:	221d      	moveq	r2, #29
   203d2:	e7e7      	b.n	203a4 <DateDecreaseOne+0x48>
   203d4:	2002c382 	.word	0x2002c382
   203d8:	200249ec 	.word	0x200249ec

000203dc <TimeIncrease>:
{
   203dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	m_add = minutes%60;
   203e0:	f04f 083c 	mov.w	r8, #60	; 0x3c
{
   203e4:	4606      	mov	r6, r0
	m_add = minutes%60;
   203e6:	fbb1 f4f8 	udiv	r4, r1, r8
	LOG_INF("m_add:%d, h_add:%d\n", m_add, h_add);
   203ea:	2303      	movs	r3, #3
   203ec:	f04f 0000 	mov.w	r0, #0
	m_add = minutes%60;
   203f0:	fb08 1714 	mls	r7, r8, r4, r1
	LOG_INF("m_add:%d, h_add:%d\n", m_add, h_add);
   203f4:	f363 0007 	bfi	r0, r3, #0, #8
   203f8:	4a21      	ldr	r2, [pc, #132]	; (20480 <TimeIncrease+0xa4>)
   203fa:	4b22      	ldr	r3, [pc, #136]	; (20484 <TimeIncrease+0xa8>)
	h_add = minutes/60;
   203fc:	b2e4      	uxtb	r4, r4
   203fe:	1a9b      	subs	r3, r3, r2
   20400:	08db      	lsrs	r3, r3, #3
	LOG_INF("m_add:%d, h_add:%d\n", m_add, h_add);
   20402:	f363 108f 	bfi	r0, r3, #6, #10
   20406:	4920      	ldr	r1, [pc, #128]	; (20488 <TimeIncrease+0xac>)
   20408:	4623      	mov	r3, r4
   2040a:	463a      	mov	r2, r7
   2040c:	f01c f9e5 	bl	3c7da <log_string_sync>
	(*date).minute += m_add;
   20410:	7971      	ldrb	r1, [r6, #5]
	day_add = h_add/24;
   20412:	2518      	movs	r5, #24
	(*date).minute += m_add;
   20414:	4439      	add	r1, r7
   20416:	b2c9      	uxtb	r1, r1
	if((*date).minute > 59)
   20418:	293b      	cmp	r1, #59	; 0x3b
		(*date).minute = (*date).minute%60;
   2041a:	bf88      	it	hi
   2041c:	fbb1 f3f8 	udivhi	r3, r1, r8
	day_add = h_add/24;
   20420:	fbb4 f5f5 	udiv	r5, r4, r5
		(*date).minute = (*date).minute%60;
   20424:	bf84      	itt	hi
   20426:	fb08 1113 	mlshi	r1, r8, r3, r1
		h_add++;
   2042a:	3401      	addhi	r4, #1
	(*date).hour += h_add;
   2042c:	7933      	ldrb	r3, [r6, #4]
		h_add++;
   2042e:	bf88      	it	hi
   20430:	b2e4      	uxtbhi	r4, r4
	(*date).hour += h_add;
   20432:	441c      	add	r4, r3
   20434:	b2e4      	uxtb	r4, r4
	(*date).minute += m_add;
   20436:	bf94      	ite	ls
   20438:	7171      	strbls	r1, [r6, #5]
		(*date).minute = (*date).minute%60;
   2043a:	7171      	strbhi	r1, [r6, #5]
	if((*date).hour > 23)
   2043c:	2c17      	cmp	r4, #23
   2043e:	d811      	bhi.n	20464 <TimeIncrease+0x88>
	(*date).hour += h_add;
   20440:	7134      	strb	r4, [r6, #4]
	while(day_add>0)
   20442:	b9c5      	cbnz	r5, 20476 <TimeIncrease+0x9a>
	(*date).week = GetWeekDayByDate((*date));
   20444:	6871      	ldr	r1, [r6, #4]
   20446:	6830      	ldr	r0, [r6, #0]
   20448:	f01a fa10 	bl	3a86c <GetWeekDayByDate>
	if(screen_id == SCREEN_ID_IDLE)
   2044c:	4b0f      	ldr	r3, [pc, #60]	; (2048c <TimeIncrease+0xb0>)
	(*date).week = GetWeekDayByDate((*date));
   2044e:	71f0      	strb	r0, [r6, #7]
	if(screen_id == SCREEN_ID_IDLE)
   20450:	781b      	ldrb	r3, [r3, #0]
   20452:	2b01      	cmp	r3, #1
		scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);	
   20454:	bf01      	itttt	eq
   20456:	4a0e      	ldreq	r2, [pc, #56]	; (20490 <TimeIncrease+0xb4>)
   20458:	68d3      	ldreq	r3, [r2, #12]
   2045a:	f043 0318 	orreq.w	r3, r3, #24
   2045e:	60d3      	streq	r3, [r2, #12]
}
   20460:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		(*date).hour = (*date).hour%24;
   20464:	2218      	movs	r2, #24
   20466:	fbb4 f3f2 	udiv	r3, r4, r2
   2046a:	fb02 4413 	mls	r4, r2, r3, r4
		day_add++;
   2046e:	3501      	adds	r5, #1
		(*date).hour = (*date).hour%24;
   20470:	7134      	strb	r4, [r6, #4]
		day_add--;
   20472:	b2ed      	uxtb	r5, r5
   20474:	e7e5      	b.n	20442 <TimeIncrease+0x66>
		DateIncreaseOne(date);
   20476:	4630      	mov	r0, r6
   20478:	f7ff ff20 	bl	202bc <DateIncreaseOne>
		day_add--;
   2047c:	3d01      	subs	r5, #1
   2047e:	e7f8      	b.n	20472 <TimeIncrease+0x96>
   20480:	0003f8d4 	.word	0x0003f8d4
   20484:	0003f914 	.word	0x0003f914
   20488:	000404a3 	.word	0x000404a3
   2048c:	2002c382 	.word	0x2002c382
   20490:	200249ec 	.word	0x200249ec

00020494 <TimeDecrease>:
	m_dec = minutes%60;
   20494:	223c      	movs	r2, #60	; 0x3c
{
   20496:	b538      	push	{r3, r4, r5, lr}
	m_dec = minutes%60;
   20498:	fbb1 f3f2 	udiv	r3, r1, r2
{
   2049c:	4605      	mov	r5, r0
	day_dec = h_dec/24;
   2049e:	2418      	movs	r4, #24
	m_dec = minutes%60;
   204a0:	fb02 1113 	mls	r1, r2, r3, r1
	if((*date).minute >= m_dec)
   204a4:	7940      	ldrb	r0, [r0, #5]
	m_dec = minutes%60;
   204a6:	b2c9      	uxtb	r1, r1
	h_dec = minutes/60;
   204a8:	1a42      	subs	r2, r0, r1
	if((*date).minute >= m_dec)
   204aa:	4288      	cmp	r0, r1
	h_dec = minutes/60;
   204ac:	b2db      	uxtb	r3, r3
	day_dec = h_dec/24;
   204ae:	b2d2      	uxtb	r2, r2
		(*date).minute = ((*date).minute+60)-m_dec;
   204b0:	bf38      	it	cc
   204b2:	323c      	addcc	r2, #60	; 0x3c
	day_dec = h_dec/24;
   204b4:	fbb3 f4f4 	udiv	r4, r3, r4
	if((*date).hour >= h_dec)
   204b8:	7929      	ldrb	r1, [r5, #4]
		h_dec++;
   204ba:	bf3e      	ittt	cc
   204bc:	3301      	addcc	r3, #1
		(*date).minute = ((*date).minute+60)-m_dec;
   204be:	b2d2      	uxtbcc	r2, r2
		h_dec++;
   204c0:	b2db      	uxtbcc	r3, r3
   204c2:	716a      	strb	r2, [r5, #5]
	if((*date).hour >= h_dec)
   204c4:	4299      	cmp	r1, r3
   204c6:	eba1 0203 	sub.w	r2, r1, r3
   204ca:	b2d2      	uxtb	r2, r2
   204cc:	d310      	bcc.n	204f0 <TimeDecrease+0x5c>
   204ce:	712a      	strb	r2, [r5, #4]
	while(day_dec>0)
   204d0:	b99c      	cbnz	r4, 204fa <TimeDecrease+0x66>
	(*date).week = GetWeekDayByDate((*date));
   204d2:	6869      	ldr	r1, [r5, #4]
   204d4:	6828      	ldr	r0, [r5, #0]
   204d6:	f01a f9c9 	bl	3a86c <GetWeekDayByDate>
	if(screen_id == SCREEN_ID_IDLE)
   204da:	4b0b      	ldr	r3, [pc, #44]	; (20508 <TimeDecrease+0x74>)
	(*date).week = GetWeekDayByDate((*date));
   204dc:	71e8      	strb	r0, [r5, #7]
	if(screen_id == SCREEN_ID_IDLE)
   204de:	781b      	ldrb	r3, [r3, #0]
   204e0:	2b01      	cmp	r3, #1
		scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);	
   204e2:	bf01      	itttt	eq
   204e4:	4a09      	ldreq	r2, [pc, #36]	; (2050c <TimeDecrease+0x78>)
   204e6:	68d3      	ldreq	r3, [r2, #12]
   204e8:	f043 0318 	orreq.w	r3, r3, #24
   204ec:	60d3      	streq	r3, [r2, #12]
}
   204ee:	bd38      	pop	{r3, r4, r5, pc}
		(*date).hour = ((*date).hour+24)-h_dec;
   204f0:	3218      	adds	r2, #24
		day_dec++;
   204f2:	3401      	adds	r4, #1
		(*date).hour = ((*date).hour+24)-h_dec;
   204f4:	b2d2      	uxtb	r2, r2
		day_dec++;
   204f6:	b2e4      	uxtb	r4, r4
   204f8:	e7e9      	b.n	204ce <TimeDecrease+0x3a>
		DateDecreaseOne(date);
   204fa:	4628      	mov	r0, r5
		day_dec--;
   204fc:	3c01      	subs	r4, #1
		DateDecreaseOne(date);
   204fe:	f7ff ff2d 	bl	2035c <DateDecreaseOne>
		day_dec--;
   20502:	b2e4      	uxtb	r4, r4
   20504:	e7e4      	b.n	204d0 <TimeDecrease+0x3c>
   20506:	bf00      	nop
   20508:	2002c382 	.word	0x2002c382
   2050c:	200249ec 	.word	0x200249ec

00020510 <RedrawSystemTime>:
	if(screen_id == SCREEN_ID_IDLE)
   20510:	4b04      	ldr	r3, [pc, #16]	; (20524 <RedrawSystemTime+0x14>)
   20512:	781b      	ldrb	r3, [r3, #0]
   20514:	2b01      	cmp	r3, #1
		scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_TIME|SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);
   20516:	bf01      	itttt	eq
   20518:	4a03      	ldreq	r2, [pc, #12]	; (20528 <RedrawSystemTime+0x18>)
   2051a:	68d3      	ldreq	r3, [r2, #12]
   2051c:	f043 031c 	orreq.w	r3, r3, #28
   20520:	60d3      	streq	r3, [r2, #12]
}
   20522:	4770      	bx	lr
   20524:	2002c382 	.word	0x2002c382
   20528:	200249ec 	.word	0x200249ec

0002052c <UpdateSystemTime>:
{
   2052c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   	memcpy(&last_date_time, &date_time, sizeof(sys_date_timer_t));
   2052e:	4b55      	ldr	r3, [pc, #340]	; (20684 <UpdateSystemTime+0x158>)
   20530:	4955      	ldr	r1, [pc, #340]	; (20688 <UpdateSystemTime+0x15c>)
   20532:	681a      	ldr	r2, [r3, #0]
   20534:	4c55      	ldr	r4, [pc, #340]	; (2068c <UpdateSystemTime+0x160>)
   20536:	600a      	str	r2, [r1, #0]
   20538:	685a      	ldr	r2, [r3, #4]
   2053a:	604a      	str	r2, [r1, #4]
	if(screen_id == SCREEN_ID_IDLE)
   2053c:	4a54      	ldr	r2, [pc, #336]	; (20690 <UpdateSystemTime+0x164>)
   2053e:	7815      	ldrb	r5, [r2, #0]
   20540:	2d01      	cmp	r5, #1
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_TIME;
   20542:	bf01      	itttt	eq
   20544:	4953      	ldreq	r1, [pc, #332]	; (20694 <UpdateSystemTime+0x168>)
   20546:	68ca      	ldreq	r2, [r1, #12]
   20548:	f042 0204 	orreq.w	r2, r2, #4
   2054c:	60ca      	streq	r2, [r1, #12]
	date_time.second++;	// += (timeskip/1000);
   2054e:	799a      	ldrb	r2, [r3, #6]
   20550:	3201      	adds	r2, #1
   20552:	b2d2      	uxtb	r2, r2
	if(date_time.second > 59)
   20554:	2a3b      	cmp	r2, #59	; 0x3b
	date_time.second++;	// += (timeskip/1000);
   20556:	719a      	strb	r2, [r3, #6]
	if(date_time.second > 59)
   20558:	d94d      	bls.n	205f6 <UpdateSystemTime+0xca>
		date_time.second = date_time.second%60;
   2055a:	263c      	movs	r6, #60	; 0x3c
   2055c:	fbb2 f0f6 	udiv	r0, r2, r6
   20560:	fb06 2210 	mls	r2, r6, r0, r2
   20564:	719a      	strb	r2, [r3, #6]
		date_time.minute++;
   20566:	795a      	ldrb	r2, [r3, #5]
   20568:	7821      	ldrb	r1, [r4, #0]
   2056a:	3201      	adds	r2, #1
   2056c:	b2d2      	uxtb	r2, r2
		date_time_changed = date_time_changed|0x02;
   2056e:	f041 0002 	orr.w	r0, r1, #2
		if(date_time.minute > 59)
   20572:	2a3b      	cmp	r2, #59	; 0x3b
		date_time.minute++;
   20574:	715a      	strb	r2, [r3, #5]
		date_time_changed = date_time_changed|0x02;
   20576:	7020      	strb	r0, [r4, #0]
		if(date_time.minute > 59)
   20578:	d93d      	bls.n	205f6 <UpdateSystemTime+0xca>
			date_time.minute = 0;
   2057a:	2600      	movs	r6, #0
			date_time.hour++;
   2057c:	791a      	ldrb	r2, [r3, #4]
			date_time_changed = date_time_changed|0x04;
   2057e:	f041 0006 	orr.w	r0, r1, #6
			date_time.hour++;
   20582:	3201      	adds	r2, #1
   20584:	b2d2      	uxtb	r2, r2
			if(date_time.hour > 23)
   20586:	2a17      	cmp	r2, #23
			date_time.minute = 0;
   20588:	715e      	strb	r6, [r3, #5]
			date_time.hour++;
   2058a:	711a      	strb	r2, [r3, #4]
			date_time_changed = date_time_changed|0x04;
   2058c:	7020      	strb	r0, [r4, #0]
			if(date_time.hour > 23)
   2058e:	d932      	bls.n	205f6 <UpdateSystemTime+0xca>
				date_time.week++;
   20590:	79da      	ldrb	r2, [r3, #7]
				date_time.day++;
   20592:	78d8      	ldrb	r0, [r3, #3]
				date_time.week++;
   20594:	3201      	adds	r2, #1
   20596:	b2d2      	uxtb	r2, r2
				if(date_time.week > 6)
   20598:	2a06      	cmp	r2, #6
				date_time.week++;
   2059a:	bf98      	it	ls
   2059c:	71da      	strbls	r2, [r3, #7]
				date_time_changed = date_time_changed|0x08;
   2059e:	f041 020e 	orr.w	r2, r1, #14
   205a2:	7022      	strb	r2, [r4, #0]
				if(date_time.month == 1 \
   205a4:	789a      	ldrb	r2, [r3, #2]
				date_time.day++;
   205a6:	f100 0001 	add.w	r0, r0, #1
   205aa:	b2c0      	uxtb	r0, r0
					date_time.week = 0;
   205ac:	bf88      	it	hi
   205ae:	71de      	strbhi	r6, [r3, #7]
				if(date_time.month == 1 \
   205b0:	2a0c      	cmp	r2, #12
				date_time.hour = 0;
   205b2:	711e      	strb	r6, [r3, #4]
				date_time.day++;
   205b4:	70d8      	strb	r0, [r3, #3]
				if(date_time.month == 1 \
   205b6:	d804      	bhi.n	205c2 <UpdateSystemTime+0x96>
   205b8:	f241 56aa 	movw	r6, #5546	; 0x15aa
   205bc:	40d6      	lsrs	r6, r2
   205be:	07f6      	lsls	r6, r6, #31
   205c0:	d429      	bmi.n	20616 <UpdateSystemTime+0xea>
				else if(date_time.month == 4 \
   205c2:	f002 06fd 	and.w	r6, r2, #253	; 0xfd
   205c6:	2e04      	cmp	r6, #4
   205c8:	d139      	bne.n	2063e <UpdateSystemTime+0x112>
					if(date_time.day > 30)
   205ca:	281e      	cmp	r0, #30
   205cc:	d909      	bls.n	205e2 <UpdateSystemTime+0xb6>
						date_time.day = 1;
   205ce:	2001      	movs	r0, #1
						date_time.month++;
   205d0:	4402      	add	r2, r0
   205d2:	b2d2      	uxtb	r2, r2
						date_time_changed = date_time_changed|0x10;
   205d4:	f041 061e 	orr.w	r6, r1, #30
						if(date_time.month > 12)
   205d8:	2a0c      	cmp	r2, #12
						date_time.day = 1;
   205da:	70d8      	strb	r0, [r3, #3]
						date_time.month++;
   205dc:	709a      	strb	r2, [r3, #2]
						date_time_changed = date_time_changed|0x10;
   205de:	7026      	strb	r6, [r4, #0]
						if(date_time.month > 12)
   205e0:	d825      	bhi.n	2062e <UpdateSystemTime+0x102>
				update_date_time = true;
   205e2:	2101      	movs	r1, #1
   205e4:	4a2c      	ldr	r2, [pc, #176]	; (20698 <UpdateSystemTime+0x16c>)
				if(screen_id == SCREEN_ID_IDLE)
   205e6:	428d      	cmp	r5, r1
				update_date_time = true;
   205e8:	7011      	strb	r1, [r2, #0]
					scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);
   205ea:	bf01      	itttt	eq
   205ec:	4929      	ldreq	r1, [pc, #164]	; (20694 <UpdateSystemTime+0x168>)
   205ee:	68ca      	ldreq	r2, [r1, #12]
   205f0:	f042 0218 	orreq.w	r2, r2, #24
   205f4:	60ca      	streq	r2, [r1, #12]
	date_time_changed = date_time_changed|0x01;
   205f6:	7822      	ldrb	r2, [r4, #0]
	if((date_time_changed&0x02) != 0)
   205f8:	0791      	lsls	r1, r2, #30
   205fa:	d438      	bmi.n	2066e <UpdateSystemTime+0x142>
	date_time_changed = date_time_changed|0x01;
   205fc:	f042 0201 	orr.w	r2, r2, #1
   20600:	7022      	strb	r2, [r4, #0]
	if((date_time_changed&0x08) != 0)
   20602:	7823      	ldrb	r3, [r4, #0]
   20604:	071a      	lsls	r2, r3, #28
   20606:	d505      	bpl.n	20614 <UpdateSystemTime+0xe8>
		reset_steps = true;
   20608:	2201      	movs	r2, #1
		date_time_changed = date_time_changed&0xF7;
   2060a:	f023 0308 	bic.w	r3, r3, #8
   2060e:	7023      	strb	r3, [r4, #0]
		reset_steps = true;
   20610:	4b22      	ldr	r3, [pc, #136]	; (2069c <UpdateSystemTime+0x170>)
   20612:	701a      	strb	r2, [r3, #0]
}
   20614:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					if(date_time.day > 31)
   20616:	281f      	cmp	r0, #31
   20618:	d9e3      	bls.n	205e2 <UpdateSystemTime+0xb6>
						date_time.day = 1;
   2061a:	2001      	movs	r0, #1
						date_time.month++;
   2061c:	4402      	add	r2, r0
   2061e:	b2d2      	uxtb	r2, r2
						date_time_changed = date_time_changed|0x10;
   20620:	f041 061e 	orr.w	r6, r1, #30
						if(date_time.month > 12)
   20624:	2a0d      	cmp	r2, #13
						date_time.day = 1;
   20626:	70d8      	strb	r0, [r3, #3]
						date_time.month++;
   20628:	709a      	strb	r2, [r3, #2]
						date_time_changed = date_time_changed|0x10;
   2062a:	7026      	strb	r6, [r4, #0]
						if(date_time.month > 12)
   2062c:	d1d9      	bne.n	205e2 <UpdateSystemTime+0xb6>
							date_time.year++;
   2062e:	881a      	ldrh	r2, [r3, #0]
							date_time.month = 1;
   20630:	7098      	strb	r0, [r3, #2]
							date_time.year++;
   20632:	4402      	add	r2, r0
   20634:	801a      	strh	r2, [r3, #0]
							date_time_changed = date_time_changed|0x20;
   20636:	f041 013e 	orr.w	r1, r1, #62	; 0x3e
   2063a:	7021      	strb	r1, [r4, #0]
   2063c:	e7d1      	b.n	205e2 <UpdateSystemTime+0xb6>
					|| date_time.month == 9 \
   2063e:	2e09      	cmp	r6, #9
   20640:	d0c3      	beq.n	205ca <UpdateSystemTime+0x9e>
					if(date_time.year%4 == 0)
   20642:	881e      	ldrh	r6, [r3, #0]
					if(date_time.day > (28+Leap))
   20644:	f016 0f03 	tst.w	r6, #3
   20648:	bf0c      	ite	eq
   2064a:	271d      	moveq	r7, #29
   2064c:	271c      	movne	r7, #28
   2064e:	42b8      	cmp	r0, r7
   20650:	ddc7      	ble.n	205e2 <UpdateSystemTime+0xb6>
						date_time.day = 1;
   20652:	2001      	movs	r0, #1
						date_time.month++;
   20654:	4402      	add	r2, r0
   20656:	b2d2      	uxtb	r2, r2
						date_time_changed = date_time_changed|0x10;
   20658:	f041 071e 	orr.w	r7, r1, #30
						if(date_time.month > 12)
   2065c:	2a0c      	cmp	r2, #12
						date_time.day = 1;
   2065e:	70d8      	strb	r0, [r3, #3]
						date_time.month++;
   20660:	709a      	strb	r2, [r3, #2]
						date_time_changed = date_time_changed|0x10;
   20662:	7027      	strb	r7, [r4, #0]
						if(date_time.month > 12)
   20664:	d9bd      	bls.n	205e2 <UpdateSystemTime+0xb6>
							date_time.year++;
   20666:	4406      	add	r6, r0
							date_time.month = 1;
   20668:	7098      	strb	r0, [r3, #2]
							date_time.year++;
   2066a:	801e      	strh	r6, [r3, #0]
   2066c:	e7e3      	b.n	20636 <UpdateSystemTime+0x10a>
		date_time_changed = date_time_changed&0xFD;
   2066e:	f022 0202 	bic.w	r2, r2, #2
   20672:	f042 0201 	orr.w	r2, r2, #1
		AlarmRemindCheck(date_time);
   20676:	6818      	ldr	r0, [r3, #0]
   20678:	6859      	ldr	r1, [r3, #4]
		date_time_changed = date_time_changed&0xFD;
   2067a:	7022      	strb	r2, [r4, #0]
		AlarmRemindCheck(date_time);
   2067c:	f000 f96c 	bl	20958 <AlarmRemindCheck>
   20680:	e7bf      	b.n	20602 <UpdateSystemTime+0xd6>
   20682:	bf00      	nop
   20684:	20029894 	.word	0x20029894
   20688:	2002989c 	.word	0x2002989c
   2068c:	20029916 	.word	0x20029916
   20690:	2002c382 	.word	0x2002c382
   20694:	200249ec 	.word	0x200249ec
   20698:	20029918 	.word	0x20029918
   2069c:	2002c329 	.word	0x2002c329

000206a0 <StartSystemDateTime>:

void StartSystemDateTime(void)
{
   206a0:	b510      	push	{r4, lr}
	k_timer_init(&clock_timer, clock_timer_handler, NULL);
   206a2:	4c07      	ldr	r4, [pc, #28]	; (206c0 <StartSystemDateTime+0x20>)
   206a4:	2200      	movs	r2, #0
   206a6:	4907      	ldr	r1, [pc, #28]	; (206c4 <StartSystemDateTime+0x24>)
   206a8:	4620      	mov	r0, r4
   206aa:	f01e f820 	bl	3e6ee <k_timer_init>
	z_impl_k_timer_start(timer, duration, period);
   206ae:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   206b2:	4620      	mov	r0, r4
	k_timer_start(&clock_timer, K_MSEC(1000), K_MSEC(1000));
}
   206b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   206b8:	4611      	mov	r1, r2
   206ba:	f017 bfef 	b.w	3869c <z_impl_k_timer_start>
   206be:	bf00      	nop
   206c0:	20020ae8 	.word	0x20020ae8
   206c4:	000202b1 	.word	0x000202b1

000206c8 <GetSystemDateStrings>:

void GetSystemDateStrings(u8_t *str_date)
{
	u8_t tmpbuf[128] = {0};
	
	switch(global_settings.date_format)
   206c8:	4b10      	ldr	r3, [pc, #64]	; (2070c <GetSystemDateStrings+0x44>)
{
   206ca:	b507      	push	{r0, r1, r2, lr}
	switch(global_settings.date_format)
   206cc:	7a9b      	ldrb	r3, [r3, #10]
   206ce:	2b01      	cmp	r3, #1
   206d0:	d00e      	beq.n	206f0 <GetSystemDateStrings+0x28>
   206d2:	b123      	cbz	r3, 206de <GetSystemDateStrings+0x16>
   206d4:	2b02      	cmp	r3, #2
   206d6:	d012      	beq.n	206fe <GetSystemDateStrings+0x36>

#ifdef FONTMAKER_UNICODE_FONT
	strcpy(tmpbuf, str_date);
	mmi_asc_to_ucs2(str_date, tmpbuf);
#endif
}
   206d8:	b003      	add	sp, #12
   206da:	f85d fb04 	ldr.w	pc, [sp], #4
		sprintf((char*)str_date, "%04d/%02d/%02d", date_time.year, date_time.month, date_time.day);
   206de:	4a0c      	ldr	r2, [pc, #48]	; (20710 <GetSystemDateStrings+0x48>)
   206e0:	490c      	ldr	r1, [pc, #48]	; (20714 <GetSystemDateStrings+0x4c>)
   206e2:	78d3      	ldrb	r3, [r2, #3]
   206e4:	9300      	str	r3, [sp, #0]
   206e6:	7893      	ldrb	r3, [r2, #2]
   206e8:	8812      	ldrh	r2, [r2, #0]
		sprintf((char*)str_date, "%02d/%02d/%04d", date_time.day, date_time.month, date_time.year);
   206ea:	f019 fa1b 	bl	39b24 <siprintf>
}
   206ee:	e7f3      	b.n	206d8 <GetSystemDateStrings+0x10>
		sprintf((char*)str_date, "%02d/%02d/%04d", date_time.month, date_time.day, date_time.year);
   206f0:	4a07      	ldr	r2, [pc, #28]	; (20710 <GetSystemDateStrings+0x48>)
   206f2:	8813      	ldrh	r3, [r2, #0]
   206f4:	9300      	str	r3, [sp, #0]
   206f6:	78d3      	ldrb	r3, [r2, #3]
   206f8:	7892      	ldrb	r2, [r2, #2]
		sprintf((char*)str_date, "%02d/%02d/%04d", date_time.day, date_time.month, date_time.year);
   206fa:	4907      	ldr	r1, [pc, #28]	; (20718 <GetSystemDateStrings+0x50>)
   206fc:	e7f5      	b.n	206ea <GetSystemDateStrings+0x22>
   206fe:	4a04      	ldr	r2, [pc, #16]	; (20710 <GetSystemDateStrings+0x48>)
   20700:	8813      	ldrh	r3, [r2, #0]
   20702:	9300      	str	r3, [sp, #0]
   20704:	7893      	ldrb	r3, [r2, #2]
   20706:	78d2      	ldrb	r2, [r2, #3]
   20708:	e7f7      	b.n	206fa <GetSystemDateStrings+0x32>
   2070a:	bf00      	nop
   2070c:	200298a6 	.word	0x200298a6
   20710:	20029894 	.word	0x20029894
   20714:	0004042d 	.word	0x0004042d
   20718:	0004043c 	.word	0x0004043c

0002071c <GetSysteAmPmStrings>:

void GetSysteAmPmStrings(u8_t *str_ampm)
{
	u8_t flag = 0;
	u8_t *am_pm[2] = {"am", "pm"};
   2071c:	4b0d      	ldr	r3, [pc, #52]	; (20754 <GetSysteAmPmStrings+0x38>)
{
   2071e:	b082      	sub	sp, #8
	u8_t *am_pm[2] = {"am", "pm"};
   20720:	9300      	str	r3, [sp, #0]
   20722:	4b0d      	ldr	r3, [pc, #52]	; (20758 <GetSysteAmPmStrings+0x3c>)
   20724:	9301      	str	r3, [sp, #4]
	u8_t tmpbuf[128] = {0};

	if(date_time.hour > 12)
		flag = 1;
	
	switch(global_settings.time_format)
   20726:	4b0d      	ldr	r3, [pc, #52]	; (2075c <GetSysteAmPmStrings+0x40>)
   20728:	7a1b      	ldrb	r3, [r3, #8]
   2072a:	b11b      	cbz	r3, 20734 <GetSysteAmPmStrings+0x18>
   2072c:	2b01      	cmp	r3, #1
   2072e:	d005      	beq.n	2073c <GetSysteAmPmStrings+0x20>
#ifdef FONTMAKER_UNICODE_FONT
	strcpy(tmpbuf, str_ampm);
	mmi_asc_to_ucs2(str_ampm, tmpbuf);
#endif

}
   20730:	b002      	add	sp, #8
   20732:	4770      	bx	lr
		sprintf((char*)str_ampm, "  ");
   20734:	490a      	ldr	r1, [pc, #40]	; (20760 <GetSysteAmPmStrings+0x44>)
}
   20736:	b002      	add	sp, #8
		sprintf((char*)str_ampm, "%s", am_pm[flag]);
   20738:	f01e ba11 	b.w	3eb5e <strcpy>
	if(date_time.hour > 12)
   2073c:	4b09      	ldr	r3, [pc, #36]	; (20764 <GetSysteAmPmStrings+0x48>)
		sprintf((char*)str_ampm, "%s", am_pm[flag]);
   2073e:	aa02      	add	r2, sp, #8
	if(date_time.hour > 12)
   20740:	791b      	ldrb	r3, [r3, #4]
   20742:	2b0c      	cmp	r3, #12
   20744:	bf94      	ite	ls
   20746:	2300      	movls	r3, #0
   20748:	2301      	movhi	r3, #1
		sprintf((char*)str_ampm, "%s", am_pm[flag]);
   2074a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   2074e:	f853 1c08 	ldr.w	r1, [r3, #-8]
   20752:	e7f0      	b.n	20736 <GetSysteAmPmStrings+0x1a>
   20754:	000404b7 	.word	0x000404b7
   20758:	000404ba 	.word	0x000404ba
   2075c:	200298a6 	.word	0x200298a6
   20760:	00040882 	.word	0x00040882
   20764:	20029894 	.word	0x20029894

00020768 <GetSystemTimeStrings>:

void GetSystemTimeStrings(u8_t *str_time)
{
	u8_t tmpbuf[128] = {0};
	
	switch(global_settings.time_format)
   20768:	4b0d      	ldr	r3, [pc, #52]	; (207a0 <GetSystemTimeStrings+0x38>)
{
   2076a:	b513      	push	{r0, r1, r4, lr}
	switch(global_settings.time_format)
   2076c:	7a1b      	ldrb	r3, [r3, #8]
   2076e:	b11b      	cbz	r3, 20778 <GetSystemTimeStrings+0x10>
   20770:	2b01      	cmp	r3, #1
   20772:	d00a      	beq.n	2078a <GetSystemTimeStrings+0x22>

#ifdef FONTMAKER_UNICODE_FONT
	strcpy(tmpbuf, str_time);
	mmi_asc_to_ucs2(str_time, tmpbuf);
#endif
}
   20774:	b002      	add	sp, #8
   20776:	bd10      	pop	{r4, pc}
		sprintf((char*)str_time, "%02d:%02d:%02d", date_time.hour, date_time.minute, date_time.second);
   20778:	4a0a      	ldr	r2, [pc, #40]	; (207a4 <GetSystemTimeStrings+0x3c>)
   2077a:	490b      	ldr	r1, [pc, #44]	; (207a8 <GetSystemTimeStrings+0x40>)
   2077c:	7993      	ldrb	r3, [r2, #6]
   2077e:	9300      	str	r3, [sp, #0]
   20780:	7953      	ldrb	r3, [r2, #5]
   20782:	7912      	ldrb	r2, [r2, #4]
		sprintf((char*)str_time, "%02d:%02d:%02d", (date_time.hour>12 ? (date_time.hour-12):date_time.hour), date_time.minute, date_time.second);
   20784:	f019 f9ce 	bl	39b24 <siprintf>
}
   20788:	e7f4      	b.n	20774 <GetSystemTimeStrings+0xc>
		sprintf((char*)str_time, "%02d:%02d:%02d", (date_time.hour>12 ? (date_time.hour-12):date_time.hour), date_time.minute, date_time.second);
   2078a:	4b06      	ldr	r3, [pc, #24]	; (207a4 <GetSystemTimeStrings+0x3c>)
   2078c:	791a      	ldrb	r2, [r3, #4]
   2078e:	7999      	ldrb	r1, [r3, #6]
   20790:	2a0c      	cmp	r2, #12
   20792:	9100      	str	r1, [sp, #0]
   20794:	bf88      	it	hi
   20796:	3a0c      	subhi	r2, #12
   20798:	795b      	ldrb	r3, [r3, #5]
   2079a:	4903      	ldr	r1, [pc, #12]	; (207a8 <GetSystemTimeStrings+0x40>)
   2079c:	e7f2      	b.n	20784 <GetSystemTimeStrings+0x1c>
   2079e:	bf00      	nop
   207a0:	200298a6 	.word	0x200298a6
   207a4:	20029894 	.word	0x20029894
   207a8:	0004044b 	.word	0x0004044b

000207ac <GetSystemWeekStrings>:

void GetSystemWeekStrings(u8_t *str_week)
{
   207ac:	b570      	push	{r4, r5, r6, lr}
	u8_t *week_en[7] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
   207ae:	4c25      	ldr	r4, [pc, #148]	; (20844 <GetSystemWeekStrings+0x98>)
{
   207b0:	b09e      	sub	sp, #120	; 0x78
	u8_t *week_en[7] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
   207b2:	ad01      	add	r5, sp, #4
{
   207b4:	4606      	mov	r6, r0
	u8_t *week_en[7] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
   207b6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   207b8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   207ba:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
	u8_t *week_chn[7] = {"", "", "", "", "", "", ""};
   207be:	340c      	adds	r4, #12
	u8_t *week_en[7] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
   207c0:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	u8_t *week_chn[7] = {"", "", "", "", "", "", ""};
   207c4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   207c6:	ad08      	add	r5, sp, #32
   207c8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   207ca:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
   207ce:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	u8_t *week_jpn[15] = {"", "", "", "", "", "", ""};
   207d2:	2220      	movs	r2, #32
   207d4:	2100      	movs	r1, #0
   207d6:	a816      	add	r0, sp, #88	; 0x58
   207d8:	f01e f858 	bl	3e88c <memset>
   207dc:	4b1a      	ldr	r3, [pc, #104]	; (20848 <GetSystemWeekStrings+0x9c>)
   207de:	930f      	str	r3, [sp, #60]	; 0x3c
   207e0:	4b1a      	ldr	r3, [pc, #104]	; (2084c <GetSystemWeekStrings+0xa0>)
   207e2:	9310      	str	r3, [sp, #64]	; 0x40
   207e4:	4b1a      	ldr	r3, [pc, #104]	; (20850 <GetSystemWeekStrings+0xa4>)
   207e6:	9311      	str	r3, [sp, #68]	; 0x44
   207e8:	4b1a      	ldr	r3, [pc, #104]	; (20854 <GetSystemWeekStrings+0xa8>)
   207ea:	9312      	str	r3, [sp, #72]	; 0x48
   207ec:	4b1a      	ldr	r3, [pc, #104]	; (20858 <GetSystemWeekStrings+0xac>)
   207ee:	9313      	str	r3, [sp, #76]	; 0x4c
   207f0:	4b1a      	ldr	r3, [pc, #104]	; (2085c <GetSystemWeekStrings+0xb0>)
   207f2:	9314      	str	r3, [sp, #80]	; 0x50
   207f4:	4b1a      	ldr	r3, [pc, #104]	; (20860 <GetSystemWeekStrings+0xb4>)
   207f6:	9315      	str	r3, [sp, #84]	; 0x54
								{0x304D,0x3093,0x3088,0x3046,0x3073,0x0000},
								{0x3069,0x3088,0x3046,0x3073,0x0000}
							};
#endif

	switch(global_settings.language)
   207f8:	4b1a      	ldr	r3, [pc, #104]	; (20864 <GetSystemWeekStrings+0xb8>)
   207fa:	7a5b      	ldrb	r3, [r3, #9]
   207fc:	2b01      	cmp	r3, #1
   207fe:	d004      	beq.n	2080a <GetSystemWeekStrings+0x5e>
   20800:	b183      	cbz	r3, 20824 <GetSystemWeekStrings+0x78>
   20802:	2b02      	cmp	r3, #2
   20804:	d016      	beq.n	20834 <GetSystemWeekStrings+0x88>
	#else
		strcpy((char*)str_week, (const char*)week_jpn[date_time.week]);
	#endif
		break;
	}
}
   20806:	b01e      	add	sp, #120	; 0x78
   20808:	bd70      	pop	{r4, r5, r6, pc}
		strcpy((char*)str_week, (const char*)week_chn[date_time.week]);
   2080a:	4b17      	ldr	r3, [pc, #92]	; (20868 <GetSystemWeekStrings+0xbc>)
   2080c:	aa1e      	add	r2, sp, #120	; 0x78
   2080e:	79db      	ldrb	r3, [r3, #7]
   20810:	eb02 0383 	add.w	r3, r2, r3, lsl #2
__ssp_bos_icheck3(memset, void *, int)
__ssp_bos_icheck2_restrict(stpcpy, char *, const char *)
#if __GNUC_PREREQ__(4,8) || defined(__clang__)
__ssp_bos_icheck3_restrict(stpncpy, char *, const char *)
#endif
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
   20814:	f853 1c58 	ldr.w	r1, [r3, #-88]
   20818:	4630      	mov	r0, r6
}
   2081a:	b01e      	add	sp, #120	; 0x78
   2081c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   20820:	f01e b99d 	b.w	3eb5e <strcpy>
		strcpy((char*)str_week, (const char*)week_en[date_time.week]);
   20824:	4b10      	ldr	r3, [pc, #64]	; (20868 <GetSystemWeekStrings+0xbc>)
   20826:	aa1e      	add	r2, sp, #120	; 0x78
   20828:	79db      	ldrb	r3, [r3, #7]
   2082a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   2082e:	f853 1c74 	ldr.w	r1, [r3, #-116]
   20832:	e7f1      	b.n	20818 <GetSystemWeekStrings+0x6c>
		strcpy((char*)str_week, (const char*)week_jpn[date_time.week]);
   20834:	4b0c      	ldr	r3, [pc, #48]	; (20868 <GetSystemWeekStrings+0xbc>)
   20836:	aa1e      	add	r2, sp, #120	; 0x78
   20838:	79db      	ldrb	r3, [r3, #7]
   2083a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   2083e:	f853 1c3c 	ldr.w	r1, [r3, #-60]
   20842:	e7e9      	b.n	20818 <GetSystemWeekStrings+0x6c>
   20844:	0003fa20 	.word	0x0003fa20
   20848:	0004045a 	.word	0x0004045a
   2084c:	00040465 	.word	0x00040465
   20850:	00040470 	.word	0x00040470
   20854:	00040479 	.word	0x00040479
   20858:	00040484 	.word	0x00040484
   2085c:	0004048f 	.word	0x0004048f
   20860:	0004049a 	.word	0x0004049a
   20864:	200298a6 	.word	0x200298a6
   20868:	20029894 	.word	0x20029894

0002086c <TimeMsgProcess>:

void TimeMsgProcess(void)
{
   2086c:	b508      	push	{r3, lr}
	if(sys_time_count)
   2086e:	4b07      	ldr	r3, [pc, #28]	; (2088c <TimeMsgProcess+0x20>)
   20870:	781a      	ldrb	r2, [r3, #0]
   20872:	b152      	cbz	r2, 2088a <TimeMsgProcess+0x1e>
	{
		sys_time_count = false;
   20874:	2200      	movs	r2, #0
   20876:	701a      	strb	r2, [r3, #0]
		UpdateSystemTime();
   20878:	f7ff fe58 	bl	2052c <UpdateSystemTime>

		if(screen_id == SCREEN_ID_IDLE)
   2087c:	4b04      	ldr	r3, [pc, #16]	; (20890 <TimeMsgProcess+0x24>)
   2087e:	781b      	ldrb	r3, [r3, #0]
   20880:	2b01      	cmp	r3, #1
			scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   20882:	bf02      	ittt	eq
   20884:	2202      	moveq	r2, #2
   20886:	4b03      	ldreq	r3, [pc, #12]	; (20894 <TimeMsgProcess+0x28>)
   20888:	725a      	strbeq	r2, [r3, #9]
	}
}
   2088a:	bd08      	pop	{r3, pc}
   2088c:	20029917 	.word	0x20029917
   20890:	2002c382 	.word	0x2002c382
   20894:	200249ec 	.word	0x200249ec

00020898 <AlarmRemindStop>:
extern void VibrateStart(void);
extern void VibrateStop(void);

void AlarmRemindStop(void)
{
	vibrate_stop_flag = true;
   20898:	2201      	movs	r2, #1
{
   2089a:	b508      	push	{r3, lr}
	vibrate_stop_flag = true;
   2089c:	4b07      	ldr	r3, [pc, #28]	; (208bc <AlarmRemindStop+0x24>)
   2089e:	701a      	strb	r2, [r3, #0]

	alarm_is_running = false;
   208a0:	2300      	movs	r3, #0
   208a2:	4a07      	ldr	r2, [pc, #28]	; (208c0 <AlarmRemindStop+0x28>)
   208a4:	7013      	strb	r3, [r2, #0]
	vibrating = false;
   208a6:	4a07      	ldr	r2, [pc, #28]	; (208c4 <AlarmRemindStop+0x2c>)
   208a8:	7013      	strb	r3, [r2, #0]
	count = 0;
   208aa:	4a07      	ldr	r2, [pc, #28]	; (208c8 <AlarmRemindStop+0x30>)
   208ac:	7013      	strb	r3, [r2, #0]
	z_impl_k_timer_stop(timer);
   208ae:	4807      	ldr	r0, [pc, #28]	; (208cc <AlarmRemindStop+0x34>)
   208b0:	f01d ff29 	bl	3e706 <z_impl_k_timer_stop>

	k_timer_stop(&alarm_timer);

	GoBackHistoryScreen();
}
   208b4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	GoBackHistoryScreen();
   208b8:	f004 bf0a 	b.w	256d0 <GoBackHistoryScreen>
   208bc:	2002c38c 	.word	0x2002c38c
   208c0:	20029919 	.word	0x20029919
   208c4:	2002991d 	.word	0x2002991d
   208c8:	2002991b 	.word	0x2002991b
   208cc:	20020b14 	.word	0x20020b14

000208d0 <AlarmRemindTimeout>:

void AlarmRemindTimeout(struct k_timer *timer)
{
	if(vibrating)
   208d0:	4b0d      	ldr	r3, [pc, #52]	; (20908 <AlarmRemindTimeout+0x38>)
   208d2:	2101      	movs	r1, #1
   208d4:	781a      	ldrb	r2, [r3, #0]
   208d6:	b182      	cbz	r2, 208fa <AlarmRemindTimeout+0x2a>
	{
		vibrate_stop_flag = true;
   208d8:	4a0c      	ldr	r2, [pc, #48]	; (2090c <AlarmRemindTimeout+0x3c>)
   208da:	7011      	strb	r1, [r2, #0]
		vibrating = false;
   208dc:	2200      	movs	r2, #0

		count--;
   208de:	490c      	ldr	r1, [pc, #48]	; (20910 <AlarmRemindTimeout+0x40>)
		vibrating = false;
   208e0:	701a      	strb	r2, [r3, #0]
		count--;
   208e2:	780b      	ldrb	r3, [r1, #0]
   208e4:	3b01      	subs	r3, #1
   208e6:	b2db      	uxtb	r3, r3
   208e8:	700b      	strb	r3, [r1, #0]
		if(count>0)
   208ea:	b123      	cbz	r3, 208f6 <AlarmRemindTimeout+0x26>
	z_impl_k_timer_start(timer, duration, period);
   208ec:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
   208f0:	4808      	ldr	r0, [pc, #32]	; (20914 <AlarmRemindTimeout+0x44>)
   208f2:	f017 bed3 	b.w	3869c <z_impl_k_timer_start>
		{
			k_timer_start(&alarm_timer, K_MSEC(ALARM_VIB_OFF_SEC), NULL);
		}
		else
		{
			AlarmRemindStop();
   208f6:	f7ff bfcf 	b.w	20898 <AlarmRemindStop>
		}
	}
	else
	{
		vibrate_start_flag = true;
   208fa:	4807      	ldr	r0, [pc, #28]	; (20918 <AlarmRemindTimeout+0x48>)
		vibrating = true;
   208fc:	7019      	strb	r1, [r3, #0]
		vibrate_start_flag = true;
   208fe:	7001      	strb	r1, [r0, #0]
   20900:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   20904:	e7f4      	b.n	208f0 <AlarmRemindTimeout+0x20>
   20906:	bf00      	nop
   20908:	2002991d 	.word	0x2002991d
   2090c:	2002c38c 	.word	0x2002c38c
   20910:	2002991b 	.word	0x2002991b
   20914:	20020b14 	.word	0x20020b14
   20918:	2002c38b 	.word	0x2002c38b

0002091c <AlarmRemindStart>:
	}
}

void AlarmRemindStart(void)
{
	lcd_sleep_out = true;
   2091c:	2301      	movs	r3, #1
	alarm_is_running = true;
	
	count = ALARM_VIB_REPEAT_MAX;
   2091e:	2105      	movs	r1, #5
	lcd_sleep_out = true;
   20920:	4a07      	ldr	r2, [pc, #28]	; (20940 <AlarmRemindStart+0x24>)
   20922:	7013      	strb	r3, [r2, #0]
	alarm_is_running = true;
   20924:	4a07      	ldr	r2, [pc, #28]	; (20944 <AlarmRemindStart+0x28>)
   20926:	7013      	strb	r3, [r2, #0]
	count = ALARM_VIB_REPEAT_MAX;
   20928:	4a07      	ldr	r2, [pc, #28]	; (20948 <AlarmRemindStart+0x2c>)
   2092a:	7011      	strb	r1, [r2, #0]
	vibrating = true;
   2092c:	4a07      	ldr	r2, [pc, #28]	; (2094c <AlarmRemindStart+0x30>)
   2092e:	7013      	strb	r3, [r2, #0]

	vibrate_start_flag = true;
   20930:	4a07      	ldr	r2, [pc, #28]	; (20950 <AlarmRemindStart+0x34>)
   20932:	7013      	strb	r3, [r2, #0]
   20934:	2200      	movs	r2, #0
   20936:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   2093a:	4806      	ldr	r0, [pc, #24]	; (20954 <AlarmRemindStart+0x38>)
   2093c:	f017 beae 	b.w	3869c <z_impl_k_timer_start>
   20940:	2002991f 	.word	0x2002991f
   20944:	20029919 	.word	0x20029919
   20948:	2002991b 	.word	0x2002991b
   2094c:	2002991d 	.word	0x2002991d
   20950:	2002c38b 	.word	0x2002c38b
   20954:	20020b14 	.word	0x20020b14

00020958 <AlarmRemindCheck>:

	k_timer_start(&alarm_timer, K_MSEC(ALARM_VIB_ON_SEC), NULL);
}

void AlarmRemindCheck(sys_date_timer_t time)
{
   20958:	b4f3      	push	{r0, r1, r4, r5, r6, r7}
   2095a:	ab02      	add	r3, sp, #8
   2095c:	e903 0003 	stmdb	r3, {r0, r1}
   20960:	4b17      	ldr	r3, [pc, #92]	; (209c0 <AlarmRemindCheck+0x68>)
	{
		if((global_settings.alarm[i].is_on)
			&&(global_settings.alarm[i].hour == time.hour)
			&&(global_settings.alarm[i].minute == time.minute))
		{
			switch(time.week)
   20962:	2200      	movs	r2, #0
   20964:	4618      	mov	r0, r3
			&&(global_settings.alarm[i].hour == time.hour)
   20966:	f89d 4004 	ldrb.w	r4, [sp, #4]
			&&(global_settings.alarm[i].minute == time.minute))
   2096a:	f89d 5005 	ldrb.w	r5, [sp, #5]
			switch(time.week)
   2096e:	f89d 6007 	ldrb.w	r6, [sp, #7]
		if((global_settings.alarm[i].is_on)
   20972:	7c19      	ldrb	r1, [r3, #16]
   20974:	b1c1      	cbz	r1, 209a8 <AlarmRemindCheck+0x50>
			&&(global_settings.alarm[i].hour == time.hour)
   20976:	7c59      	ldrb	r1, [r3, #17]
   20978:	42a1      	cmp	r1, r4
   2097a:	d115      	bne.n	209a8 <AlarmRemindCheck+0x50>
			&&(global_settings.alarm[i].minute == time.minute))
   2097c:	7c99      	ldrb	r1, [r3, #18]
   2097e:	42a9      	cmp	r1, r5
   20980:	d112      	bne.n	209a8 <AlarmRemindCheck+0x50>
			switch(time.week)
   20982:	2e06      	cmp	r6, #6
   20984:	7cd9      	ldrb	r1, [r3, #19]
   20986:	d817      	bhi.n	209b8 <AlarmRemindCheck+0x60>
				{
					flag = true;
				}
				break;
			case 6://Saturday
				if(global_settings.alarm[i].repeat&0x02 != 0)
   20988:	f001 0701 	and.w	r7, r1, #1
				break;
			default:
				break;
			}
			
			if(global_settings.alarm[i].repeat == 0)
   2098c:	b951      	cbnz	r1, 209a4 <AlarmRemindCheck+0x4c>
			{
				flag = true;
				global_settings.alarm[i].is_on = false;
   2098e:	2300      	movs	r3, #0
   20990:	3204      	adds	r2, #4
   20992:	f800 3022 	strb.w	r3, [r0, r2, lsl #2]
				need_save_settings = true;
   20996:	2201      	movs	r2, #1
   20998:	4b0a      	ldr	r3, [pc, #40]	; (209c4 <AlarmRemindCheck+0x6c>)
   2099a:	701a      	strb	r2, [r3, #0]
				AlarmRemindEntryScreen();
				break;
			}
		}
	}
}
   2099c:	b002      	add	sp, #8
   2099e:	bcf0      	pop	{r4, r5, r6, r7}
				AlarmRemindEntryScreen();
   209a0:	f01a b802 	b.w	3a9a8 <AlarmRemindEntryScreen>
			if(flag)
   209a4:	2f00      	cmp	r7, #0
   209a6:	d1f9      	bne.n	2099c <AlarmRemindCheck+0x44>
   209a8:	3201      	adds	r2, #1
	for(i=0;i<ALARM_MAX;i++)
   209aa:	2a08      	cmp	r2, #8
   209ac:	f103 0304 	add.w	r3, r3, #4
   209b0:	d1df      	bne.n	20972 <AlarmRemindCheck+0x1a>
}
   209b2:	b002      	add	sp, #8
   209b4:	bcf0      	pop	{r4, r5, r6, r7}
   209b6:	4770      	bx	lr
			if(global_settings.alarm[i].repeat == 0)
   209b8:	2900      	cmp	r1, #0
   209ba:	d1f5      	bne.n	209a8 <AlarmRemindCheck+0x50>
   209bc:	e7e7      	b.n	2098e <AlarmRemindCheck+0x36>
   209be:	bf00      	nop
   209c0:	200298a6 	.word	0x200298a6
   209c4:	2002b923 	.word	0x2002b923

000209c8 <FindDeviceStop>:
	AlarmRemindStart();
}

void FindDeviceStop(void)
{
	vibrate_stop_flag = true;
   209c8:	2201      	movs	r2, #1
{
   209ca:	b508      	push	{r3, lr}
	vibrate_stop_flag = true;
   209cc:	4b07      	ldr	r3, [pc, #28]	; (209ec <FindDeviceStop+0x24>)
   209ce:	701a      	strb	r2, [r3, #0]

	find_is_running = false;
   209d0:	2300      	movs	r3, #0
   209d2:	4a07      	ldr	r2, [pc, #28]	; (209f0 <FindDeviceStop+0x28>)
   209d4:	7013      	strb	r3, [r2, #0]
	vibrating = false;
   209d6:	4a07      	ldr	r2, [pc, #28]	; (209f4 <FindDeviceStop+0x2c>)
   209d8:	7013      	strb	r3, [r2, #0]
	count = 0;
   209da:	4a07      	ldr	r2, [pc, #28]	; (209f8 <FindDeviceStop+0x30>)
   209dc:	7013      	strb	r3, [r2, #0]
	z_impl_k_timer_stop(timer);
   209de:	4807      	ldr	r0, [pc, #28]	; (209fc <FindDeviceStop+0x34>)
   209e0:	f01d fe91 	bl	3e706 <z_impl_k_timer_stop>

	k_timer_stop(&find_timer);

	GoBackHistoryScreen();
}
   209e4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	GoBackHistoryScreen();
   209e8:	f004 be72 	b.w	256d0 <GoBackHistoryScreen>
   209ec:	2002c38c 	.word	0x2002c38c
   209f0:	2002991c 	.word	0x2002991c
   209f4:	2002991d 	.word	0x2002991d
   209f8:	2002991b 	.word	0x2002991b
   209fc:	20020b40 	.word	0x20020b40

00020a00 <FindDeviceTimeout>:

void FindDeviceTimeout(struct k_timer *timer)
{
	if(vibrating)
   20a00:	4b0d      	ldr	r3, [pc, #52]	; (20a38 <FindDeviceTimeout+0x38>)
   20a02:	2101      	movs	r1, #1
   20a04:	781a      	ldrb	r2, [r3, #0]
   20a06:	b182      	cbz	r2, 20a2a <FindDeviceTimeout+0x2a>
	{
		vibrate_stop_flag = true;
   20a08:	4a0c      	ldr	r2, [pc, #48]	; (20a3c <FindDeviceTimeout+0x3c>)
   20a0a:	7011      	strb	r1, [r2, #0]
		vibrating = false;
   20a0c:	2200      	movs	r2, #0

		count--;
   20a0e:	490c      	ldr	r1, [pc, #48]	; (20a40 <FindDeviceTimeout+0x40>)
		vibrating = false;
   20a10:	701a      	strb	r2, [r3, #0]
		count--;
   20a12:	780b      	ldrb	r3, [r1, #0]
   20a14:	3b01      	subs	r3, #1
   20a16:	b2db      	uxtb	r3, r3
   20a18:	700b      	strb	r3, [r1, #0]
		if(count>0)
   20a1a:	b123      	cbz	r3, 20a26 <FindDeviceTimeout+0x26>
	z_impl_k_timer_start(timer, duration, period);
   20a1c:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
   20a20:	4808      	ldr	r0, [pc, #32]	; (20a44 <FindDeviceTimeout+0x44>)
   20a22:	f017 be3b 	b.w	3869c <z_impl_k_timer_start>
		{
			k_timer_start(&find_timer, K_MSEC(FIND_VIB_OFF_SEC), NULL);
		}
		else
		{
			FindDeviceStop();
   20a26:	f7ff bfcf 	b.w	209c8 <FindDeviceStop>
		}
	}
	else
	{
		vibrate_start_flag = true;
   20a2a:	4807      	ldr	r0, [pc, #28]	; (20a48 <FindDeviceTimeout+0x48>)
		vibrating = true;
   20a2c:	7019      	strb	r1, [r3, #0]
		vibrate_start_flag = true;
   20a2e:	7001      	strb	r1, [r0, #0]
   20a30:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   20a34:	e7f4      	b.n	20a20 <FindDeviceTimeout+0x20>
   20a36:	bf00      	nop
   20a38:	2002991d 	.word	0x2002991d
   20a3c:	2002c38c 	.word	0x2002c38c
   20a40:	2002991b 	.word	0x2002991b
   20a44:	20020b40 	.word	0x20020b40
   20a48:	2002c38b 	.word	0x2002c38b

00020a4c <FindDeviceStart>:
	}
}

void FindDeviceStart(void)
{
	lcd_sleep_out = true;
   20a4c:	2301      	movs	r3, #1
	find_is_running = true;
	
	count = FIND_VIN_REPEAT_MAX;
   20a4e:	210a      	movs	r1, #10
	lcd_sleep_out = true;
   20a50:	4a07      	ldr	r2, [pc, #28]	; (20a70 <FindDeviceStart+0x24>)
   20a52:	7013      	strb	r3, [r2, #0]
	find_is_running = true;
   20a54:	4a07      	ldr	r2, [pc, #28]	; (20a74 <FindDeviceStart+0x28>)
   20a56:	7013      	strb	r3, [r2, #0]
	count = FIND_VIN_REPEAT_MAX;
   20a58:	4a07      	ldr	r2, [pc, #28]	; (20a78 <FindDeviceStart+0x2c>)
   20a5a:	7011      	strb	r1, [r2, #0]
	vibrating = true;
   20a5c:	4a07      	ldr	r2, [pc, #28]	; (20a7c <FindDeviceStart+0x30>)
   20a5e:	7013      	strb	r3, [r2, #0]

	vibrate_start_flag = true;
   20a60:	4a07      	ldr	r2, [pc, #28]	; (20a80 <FindDeviceStart+0x34>)
   20a62:	7013      	strb	r3, [r2, #0]
   20a64:	2200      	movs	r2, #0
   20a66:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   20a6a:	4806      	ldr	r0, [pc, #24]	; (20a84 <FindDeviceStart+0x38>)
   20a6c:	f017 be16 	b.w	3869c <z_impl_k_timer_start>
   20a70:	2002991f 	.word	0x2002991f
   20a74:	2002991c 	.word	0x2002991c
   20a78:	2002991b 	.word	0x2002991b
   20a7c:	2002991d 	.word	0x2002991d
   20a80:	2002c38b 	.word	0x2002c38b
   20a84:	20020b40 	.word	0x20020b40

00020a88 <AlarmRemindInit>:
	EnterFindDeviceScreen();
	FindDeviceStart();
}

void AlarmRemindInit(void)
{
   20a88:	b508      	push	{r3, lr}
	k_timer_init(&alarm_timer, AlarmRemindTimeout, NULL);
   20a8a:	2200      	movs	r2, #0
   20a8c:	4905      	ldr	r1, [pc, #20]	; (20aa4 <AlarmRemindInit+0x1c>)
   20a8e:	4806      	ldr	r0, [pc, #24]	; (20aa8 <AlarmRemindInit+0x20>)
   20a90:	f01d fe2d 	bl	3e6ee <k_timer_init>
	k_timer_init(&find_timer, FindDeviceTimeout, NULL);
}
   20a94:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	k_timer_init(&find_timer, FindDeviceTimeout, NULL);
   20a98:	2200      	movs	r2, #0
   20a9a:	4904      	ldr	r1, [pc, #16]	; (20aac <AlarmRemindInit+0x24>)
   20a9c:	4804      	ldr	r0, [pc, #16]	; (20ab0 <AlarmRemindInit+0x28>)
   20a9e:	f01d be26 	b.w	3e6ee <k_timer_init>
   20aa2:	bf00      	nop
   20aa4:	000208d1 	.word	0x000208d1
   20aa8:	20020b14 	.word	0x20020b14
   20aac:	00020a01 	.word	0x00020a01
   20ab0:	20020b40 	.word	0x20020b40

00020ab4 <AlarmMsgProcess>:

void AlarmMsgProcess(void)
{
	if(app_find_device)
   20ab4:	4b03      	ldr	r3, [pc, #12]	; (20ac4 <AlarmMsgProcess+0x10>)
   20ab6:	781a      	ldrb	r2, [r3, #0]
   20ab8:	b11a      	cbz	r2, 20ac2 <AlarmMsgProcess+0xe>
	{
		app_find_device = false;
   20aba:	2200      	movs	r2, #0
   20abc:	701a      	strb	r2, [r3, #0]
		FindDeviceEntryScreen();
   20abe:	f019 bf7a 	b.w	3a9b6 <FindDeviceEntryScreen>
	}
}
   20ac2:	4770      	bx	lr
   20ac4:	2002991a 	.word	0x2002991a

00020ac8 <LCD_Fill>:

//
//(x,y),(w,h):,:w*h   
//color:
void LCD_Fill(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color)
{          
   20ac8:	b570      	push	{r4, r5, r6, lr}
   20aca:	461d      	mov	r5, r3
   20acc:	4614      	mov	r4, r2
	u32_t i;

	if((x+w)>LCD_WIDTH)
   20ace:	4b0e      	ldr	r3, [pc, #56]	; (20b08 <LCD_Fill+0x40>)
   20ad0:	1882      	adds	r2, r0, r2
   20ad2:	881b      	ldrh	r3, [r3, #0]
{          
   20ad4:	f8bd 6010 	ldrh.w	r6, [sp, #16]
	if((x+w)>LCD_WIDTH)
   20ad8:	429a      	cmp	r2, r3
		w = LCD_WIDTH - x;
   20ada:	bfc8      	it	gt
   20adc:	1a1c      	subgt	r4, r3, r0
	if((y+h)>LCD_HEIGHT)
   20ade:	4b0b      	ldr	r3, [pc, #44]	; (20b0c <LCD_Fill+0x44>)
   20ae0:	eb01 0205 	add.w	r2, r1, r5
   20ae4:	881b      	ldrh	r3, [r3, #0]
		w = LCD_WIDTH - x;
   20ae6:	bfc8      	it	gt
   20ae8:	b2a4      	uxthgt	r4, r4
	if((y+h)>LCD_HEIGHT)
   20aea:	429a      	cmp	r2, r3
		h = LCD_HEIGHT - y;
   20aec:	bfc4      	itt	gt
   20aee:	1a5d      	subgt	r5, r3, r1
   20af0:	b2ad      	uxthgt	r5, r5
	
	BlockWrite(x,y,w,h);
   20af2:	462b      	mov	r3, r5
   20af4:	4622      	mov	r2, r4
   20af6:	f019 ff7b 	bl	3a9f0 <BlockWrite>

#ifdef LCD_TYPE_SPI
	DispColor((w*h), color);
   20afa:	4631      	mov	r1, r6
   20afc:	fb05 f004 	mul.w	r0, r5, r4
#else
	for(i=0;i<(w*h);i++)
		WriteOneDot(color); // 
#endif
}
   20b00:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	DispColor((w*h), color);
   20b04:	f000 ba24 	b.w	20f50 <DispColor>
   20b08:	200348da 	.word	0x200348da
   20b0c:	200348d8 	.word	0x200348d8

00020b10 <LCD_DrawRectangle>:
}    

//	  
//(x1,y1),(x2,y2):
void LCD_DrawRectangle(uint16_t x, uint16_t y, uint16_t w, uint16_t h)
{
   20b10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   20b14:	4616      	mov	r6, r2
   20b16:	461c      	mov	r4, r3
   20b18:	4607      	mov	r7, r0
   20b1a:	4688      	mov	r8, r1
#ifdef LCD_TYPE_SPI
	BlockWrite(x,y,w,1);
	DispColor(w, POINT_COLOR);
   20b1c:	4d14      	ldr	r5, [pc, #80]	; (20b70 <LCD_DrawRectangle+0x60>)
	BlockWrite(x,y,w,1);
   20b1e:	2301      	movs	r3, #1
   20b20:	f019 ff66 	bl	3a9f0 <BlockWrite>
	DispColor(w, POINT_COLOR);
   20b24:	8829      	ldrh	r1, [r5, #0]
   20b26:	4630      	mov	r0, r6
   20b28:	f000 fa12 	bl	20f50 <DispColor>
	BlockWrite(x,y,1,h);
   20b2c:	4623      	mov	r3, r4
   20b2e:	2201      	movs	r2, #1
   20b30:	4641      	mov	r1, r8
   20b32:	4638      	mov	r0, r7
   20b34:	f019 ff5c 	bl	3a9f0 <BlockWrite>
	DispColor(h, POINT_COLOR);
   20b38:	8829      	ldrh	r1, [r5, #0]
   20b3a:	4620      	mov	r0, r4
   20b3c:	f000 fa08 	bl	20f50 <DispColor>
	BlockWrite(x,y+h,w,1);
   20b40:	4632      	mov	r2, r6
   20b42:	2301      	movs	r3, #1
   20b44:	eb08 0104 	add.w	r1, r8, r4
   20b48:	4638      	mov	r0, r7
   20b4a:	f019 ff51 	bl	3a9f0 <BlockWrite>
	DispColor(w, POINT_COLOR);
   20b4e:	8829      	ldrh	r1, [r5, #0]
   20b50:	4630      	mov	r0, r6
   20b52:	f000 f9fd 	bl	20f50 <DispColor>
	BlockWrite(x+w,y,1,h);
   20b56:	4641      	mov	r1, r8
   20b58:	19b8      	adds	r0, r7, r6
   20b5a:	4623      	mov	r3, r4
   20b5c:	2201      	movs	r2, #1
   20b5e:	f019 ff47 	bl	3a9f0 <BlockWrite>
	DispColor(h, POINT_COLOR);	
   20b62:	8829      	ldrh	r1, [r5, #0]
   20b64:	4620      	mov	r0, r4
	LCD_DrawLine(x,y,x+w,y);
	LCD_DrawLine(x,y,x,y+h);
	LCD_DrawLine(x,y+h,x+w,y+h);
	LCD_DrawLine(x+w,y,x+w,y+h);
#endif
}
   20b66:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	DispColor(h, POINT_COLOR);	
   20b6a:	f000 b9f1 	b.w	20f50 <DispColor>
   20b6e:	bf00      	nop
   20b70:	200348dc 	.word	0x200348dc

00020b74 <LCD_ShowChar>:
//
//x,y:
//num::" "--->"~"
//mode:(1)(0)
void LCD_ShowChar(uint16_t x,uint16_t y,uint8_t num,uint8_t mode)
{
   20b74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20b78:	f5ad 7d3f 	sub.w	sp, sp, #764	; 0x2fc
   20b7c:	9305      	str	r3, [sp, #20]
    u8_t temp,t1,t,i=0;
	u16_t y0=y,x0=x,w=(system_font/2),h=system_font;
   20b7e:	4b66      	ldr	r3, [pc, #408]	; (20d18 <LCD_ShowChar+0x1a4>)
{
   20b80:	4615      	mov	r5, r2
	u16_t y0=y,x0=x,w=(system_font/2),h=system_font;
   20b82:	f893 b000 	ldrb.w	fp, [r3]
	u8_t cbyte=(system_font/2)/8+(((system_font/2)%8)?1:0);		//()
	u8_t csize=cbyte*system_font;		//	
	u8_t fontbuf[256] = {0};	
   20b86:	f44f 7280 	mov.w	r2, #256	; 0x100
	u16_t y0=y,x0=x,w=(system_font/2),h=system_font;
   20b8a:	ea4f 0a5b 	mov.w	sl, fp, lsr #1
	u8_t cbyte=(system_font/2)/8+(((system_font/2)%8)?1:0);		//()
   20b8e:	f01a 0607 	ands.w	r6, sl, #7
   20b92:	bf18      	it	ne
   20b94:	2601      	movne	r6, #1
   20b96:	eb06 161b 	add.w	r6, r6, fp, lsr #4
	u8_t csize=cbyte*system_font;		//	
   20b9a:	fb1b f806 	smulbb	r8, fp, r6
{
   20b9e:	4607      	mov	r7, r0
   20ba0:	460c      	mov	r4, r1
	u8_t fontbuf[256] = {0};	
   20ba2:	a806      	add	r0, sp, #24
   20ba4:	2100      	movs	r1, #0
   20ba6:	f01d fe71 	bl	3e88c <memset>
 	u8_t databuf[2*COL] = {0};
   20baa:	2100      	movs	r1, #0
   20bac:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
   20bb0:	a846      	add	r0, sp, #280	; 0x118
   20bb2:	f01d fe6b 	bl	3e88c <memset>

	num=num-' ';//ASCII-' '
   20bb6:	f1a5 0120 	sub.w	r1, r5, #32
	switch(system_font)
   20bba:	f1bb 0f18 	cmp.w	fp, #24
	u8_t csize=cbyte*system_font;		//	
   20bbe:	fa5f f888 	uxtb.w	r8, r8
	num=num-' ';//ASCII-' '
   20bc2:	b2c9      	uxtb	r1, r1
	switch(system_font)
   20bc4:	d078      	beq.n	20cb8 <LCD_ShowChar+0x144>
   20bc6:	f1bb 0f20 	cmp.w	fp, #32
   20bca:	d07a      	beq.n	20cc2 <LCD_ShowChar+0x14e>
   20bcc:	f1bb 0f10 	cmp.w	fp, #16
   20bd0:	f040 8097 	bne.w	20d02 <LCD_ShowChar+0x18e>
	{
	#ifdef FONT_16
		case FONT_SIZE_16:
			memcpy(fontbuf, asc2_1608[num], csize);	//1608
   20bd4:	4642      	mov	r2, r8
   20bd6:	4b51      	ldr	r3, [pc, #324]	; (20d1c <LCD_ShowChar+0x1a8>)
			break;
	#endif
	#ifdef FONT_24
		case FONT_SIZE_24:
			memcpy(fontbuf, asc2_2412[num], csize);	//1608
   20bd8:	eb03 1101 	add.w	r1, r3, r1, lsl #4
			break;
	#endif
	#ifdef FONT_32
		case FONT_SIZE_32:
			memcpy(fontbuf, asc2_3216[num], csize);	//1608
   20bdc:	a806      	add	r0, sp, #24
   20bde:	f01d fe35 	bl	3e84c <memcpy>
		default:
			return;							//
	}

#ifdef LCD_TYPE_SPI
	if((x+w)>=LCD_WIDTH)
   20be2:	4b4f      	ldr	r3, [pc, #316]	; (20d20 <LCD_ShowChar+0x1ac>)
		w = LCD_WIDTH - x;
	if((y+h)>=LCD_HEIGHT)
   20be4:	eb0b 0104 	add.w	r1, fp, r4
	if((x+w)>=LCD_WIDTH)
   20be8:	881a      	ldrh	r2, [r3, #0]
   20bea:	eb0a 0307 	add.w	r3, sl, r7
   20bee:	4293      	cmp	r3, r2
	if((y+h)>=LCD_HEIGHT)
   20bf0:	4b4c      	ldr	r3, [pc, #304]	; (20d24 <LCD_ShowChar+0x1b0>)
		w = LCD_WIDTH - x;
   20bf2:	bfa8      	it	ge
   20bf4:	1bd2      	subge	r2, r2, r7
	if((y+h)>=LCD_HEIGHT)
   20bf6:	881b      	ldrh	r3, [r3, #0]
	u16_t y0=y,x0=x,w=(system_font/2),h=system_font;
   20bf8:	bfb4      	ite	lt
   20bfa:	fa1f f28a 	uxthlt.w	r2, sl
		w = LCD_WIDTH - x;
   20bfe:	b292      	uxthge	r2, r2
	if((y+h)>=LCD_HEIGHT)
   20c00:	4299      	cmp	r1, r3
		h = LCD_HEIGHT - y;
   20c02:	bfa8      	it	ge
   20c04:	1b1b      	subge	r3, r3, r4
	BlockWrite(x,y,w,h);	//
   20c06:	4621      	mov	r1, r4
   20c08:	4638      	mov	r0, r7
	u16_t y0=y,x0=x,w=(system_font/2),h=system_font;
   20c0a:	bfb4      	ite	lt
   20c0c:	fa1f f38b 	uxthlt.w	r3, fp
		h = LCD_HEIGHT - y;
   20c10:	b29b      	uxthge	r3, r3
	BlockWrite(x,y,w,h);	//
   20c12:	f019 feed 	bl	3a9f0 <BlockWrite>
    u8_t temp,t1,t,i=0;
   20c16:	2000      	movs	r0, #0
#endif
		
	for(t=0;t<csize;t++)
   20c18:	4639      	mov	r1, r7
   20c1a:	4605      	mov	r5, r0
   20c1c:	4545      	cmp	r5, r8
   20c1e:	d270      	bcs.n	20d02 <LCD_ShowChar+0x18e>
	{
		temp = fontbuf[t];
   20c20:	ab06      	add	r3, sp, #24
   20c22:	f813 c005 	ldrb.w	ip, [r3, r5]
				databuf[2*i] = POINT_COLOR>>8;
				databuf[2*i+1] = POINT_COLOR;
			}
			else if(mode==0)
			{
				databuf[2*i] = BACK_COLOR>>8;
   20c26:	4b40      	ldr	r3, [pc, #256]	; (20d28 <LCD_ShowChar+0x1b4>)
   20c28:	f50d 7e8c 	add.w	lr, sp, #280	; 0x118
   20c2c:	881b      	ldrh	r3, [r3, #0]
   20c2e:	0a1a      	lsrs	r2, r3, #8
				databuf[2*i+1] = BACK_COLOR;
   20c30:	b2db      	uxtb	r3, r3
   20c32:	9303      	str	r3, [sp, #12]
				databuf[2*i] = POINT_COLOR>>8;
   20c34:	4b3d      	ldr	r3, [pc, #244]	; (20d2c <LCD_ShowChar+0x1b8>)
				databuf[2*i] = BACK_COLOR>>8;
   20c36:	9202      	str	r2, [sp, #8]
				databuf[2*i] = POINT_COLOR>>8;
   20c38:	881b      	ldrh	r3, [r3, #0]
   20c3a:	1c4a      	adds	r2, r1, #1
   20c3c:	ea4f 2913 	mov.w	r9, r3, lsr #8
				databuf[2*i+1] = POINT_COLOR;
   20c40:	b2db      	uxtb	r3, r3
   20c42:	9301      	str	r3, [sp, #4]
			}
			
			temp<<=1;
			i++;
			x++;
			if(x>=LCD_WIDTH)				//
   20c44:	4b36      	ldr	r3, [pc, #216]	; (20d20 <LCD_ShowChar+0x1ac>)
   20c46:	881b      	ldrh	r3, [r3, #0]
   20c48:	9304      	str	r3, [sp, #16]
				if(y>=LCD_HEIGHT)return;	//
				t=t+(cbyte-(t%cbyte))-1;	//for11
				break;

			}
			if((x-x0)==(system_font/2))
   20c4a:	4b33      	ldr	r3, [pc, #204]	; (20d18 <LCD_ShowChar+0x1a4>)
   20c4c:	f893 a000 	ldrb.w	sl, [r3]
   20c50:	b293      	uxth	r3, r2
   20c52:	9300      	str	r3, [sp, #0]
   20c54:	f100 0308 	add.w	r3, r0, #8
   20c58:	ea4f 0a5a 	mov.w	sl, sl, lsr #1
   20c5c:	b2db      	uxtb	r3, r3
			if(temp&0x80)
   20c5e:	f01c 0f80 	tst.w	ip, #128	; 0x80
   20c62:	d033      	beq.n	20ccc <LCD_ShowChar+0x158>
				databuf[2*i] = POINT_COLOR>>8;
   20c64:	b201      	sxth	r1, r0
				databuf[2*i+1] = POINT_COLOR;
   20c66:	9a01      	ldr	r2, [sp, #4]
				databuf[2*i] = POINT_COLOR>>8;
   20c68:	f80e 9011 	strb.w	r9, [lr, r1, lsl #1]
				databuf[2*i+1] = POINT_COLOR;
   20c6c:	eb0e 0141 	add.w	r1, lr, r1, lsl #1
				databuf[2*i+1] = BACK_COLOR;
   20c70:	704a      	strb	r2, [r1, #1]
			temp<<=1;
   20c72:	f8bd 1000 	ldrh.w	r1, [sp]
			if(x>=LCD_WIDTH)				//
   20c76:	9a04      	ldr	r2, [sp, #16]
			temp<<=1;
   20c78:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
			i++;
   20c7c:	3001      	adds	r0, #1
			if(x>=LCD_WIDTH)				//
   20c7e:	428a      	cmp	r2, r1
			temp<<=1;
   20c80:	fa5f fc8c 	uxtb.w	ip, ip
			i++;
   20c84:	b2c0      	uxtb	r0, r0
			if(x>=LCD_WIDTH)				//
   20c86:	d82c      	bhi.n	20ce2 <LCD_ShowChar+0x16e>
				DispDate(2*i, databuf);
   20c88:	a946      	add	r1, sp, #280	; 0x118
   20c8a:	0040      	lsls	r0, r0, #1
   20c8c:	f000 f98a 	bl	20fa4 <DispDate>
				if(y>=LCD_HEIGHT)return;	//
   20c90:	4b24      	ldr	r3, [pc, #144]	; (20d24 <LCD_ShowChar+0x1b0>)
				y++;
   20c92:	3401      	adds	r4, #1
				if(y>=LCD_HEIGHT)return;	//
   20c94:	881b      	ldrh	r3, [r3, #0]
				y++;
   20c96:	b2a4      	uxth	r4, r4
				if(y>=LCD_HEIGHT)return;	//
   20c98:	42a3      	cmp	r3, r4
   20c9a:	d932      	bls.n	20d02 <LCD_ShowChar+0x18e>
				t=t+(cbyte-(t%cbyte))-1;	//for11
   20c9c:	fbb5 f3f6 	udiv	r3, r5, r6
   20ca0:	fb06 5313 	mls	r3, r6, r3, r5
   20ca4:	3d01      	subs	r5, #1
   20ca6:	1af3      	subs	r3, r6, r3
   20ca8:	441d      	add	r5, r3
   20caa:	b2ed      	uxtb	r5, r5
			{
				DispDate(2*i, databuf);
				i=0;
				
				x=x0;
   20cac:	4639      	mov	r1, r7
				i=0;
   20cae:	2300      	movs	r3, #0
	for(t=0;t<csize;t++)
   20cb0:	3501      	adds	r5, #1
   20cb2:	b2ed      	uxtb	r5, r5
   20cb4:	4618      	mov	r0, r3
   20cb6:	e7b1      	b.n	20c1c <LCD_ShowChar+0xa8>
			memcpy(fontbuf, asc2_2412[num], csize);	//1608
   20cb8:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   20cbc:	4642      	mov	r2, r8
   20cbe:	4b1c      	ldr	r3, [pc, #112]	; (20d30 <LCD_ShowChar+0x1bc>)
   20cc0:	e78a      	b.n	20bd8 <LCD_ShowChar+0x64>
			memcpy(fontbuf, asc2_3216[num], csize);	//1608
   20cc2:	4b1c      	ldr	r3, [pc, #112]	; (20d34 <LCD_ShowChar+0x1c0>)
   20cc4:	4642      	mov	r2, r8
   20cc6:	eb03 1181 	add.w	r1, r3, r1, lsl #6
   20cca:	e787      	b.n	20bdc <LCD_ShowChar+0x68>
			else if(mode==0)
   20ccc:	9a05      	ldr	r2, [sp, #20]
   20cce:	2a00      	cmp	r2, #0
   20cd0:	d1cf      	bne.n	20c72 <LCD_ShowChar+0xfe>
				databuf[2*i] = BACK_COLOR>>8;
   20cd2:	9a02      	ldr	r2, [sp, #8]
   20cd4:	b201      	sxth	r1, r0
   20cd6:	f80e 2011 	strb.w	r2, [lr, r1, lsl #1]
				databuf[2*i+1] = BACK_COLOR;
   20cda:	eb0e 0141 	add.w	r1, lr, r1, lsl #1
   20cde:	9a03      	ldr	r2, [sp, #12]
   20ce0:	e7c6      	b.n	20c70 <LCD_ShowChar+0xfc>
			if((x-x0)==(system_font/2))
   20ce2:	9a00      	ldr	r2, [sp, #0]
   20ce4:	eba2 0b07 	sub.w	fp, r2, r7
   20ce8:	45d3      	cmp	fp, sl
   20cea:	d10e      	bne.n	20d0a <LCD_ShowChar+0x196>
				DispDate(2*i, databuf);
   20cec:	b200      	sxth	r0, r0
   20cee:	a946      	add	r1, sp, #280	; 0x118
   20cf0:	0040      	lsls	r0, r0, #1
   20cf2:	f000 f957 	bl	20fa4 <DispDate>
				y++;
				if(y>=LCD_HEIGHT)return;	//
   20cf6:	4b0b      	ldr	r3, [pc, #44]	; (20d24 <LCD_ShowChar+0x1b0>)
				y++;
   20cf8:	3401      	adds	r4, #1
				if(y>=LCD_HEIGHT)return;	//
   20cfa:	881b      	ldrh	r3, [r3, #0]
				y++;
   20cfc:	b2a4      	uxth	r4, r4
				if(y>=LCD_HEIGHT)return;	//
   20cfe:	42a3      	cmp	r3, r4
   20d00:	d8d4      	bhi.n	20cac <LCD_ShowChar+0x138>
				break;
			}
		#endif
		}	
	}  	    	   	 	  
}
   20d02:	f50d 7d3f 	add.w	sp, sp, #764	; 0x2fc
   20d06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   20d0a:	9a00      	ldr	r2, [sp, #0]
		for(t1=0;t1<8;t1++)
   20d0c:	4298      	cmp	r0, r3
   20d0e:	f102 0201 	add.w	r2, r2, #1
   20d12:	9200      	str	r2, [sp, #0]
   20d14:	d1a3      	bne.n	20c5e <LCD_ShowChar+0xea>
   20d16:	e7cb      	b.n	20cb0 <LCD_ShowChar+0x13c>
   20d18:	200378e1 	.word	0x200378e1
   20d1c:	200348e0 	.word	0x200348e0
   20d20:	200348da 	.word	0x200348da
   20d24:	200348d8 	.word	0x200348d8
   20d28:	200298a4 	.word	0x200298a4
   20d2c:	200348dc 	.word	0x200348dc
   20d30:	20034ee0 	.word	0x20034ee0
   20d34:	200360e0 	.word	0x200360e0

00020d38 <LCD_ShowStringInRect>:
//
//x,y:
//width,height:  
//*p:	
void LCD_ShowStringInRect(uint16_t x,uint16_t y,uint16_t width,uint16_t height,uint8_t *p)
{
   20d38:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   20d3c:	460e      	mov	r6, r1
	uint8_t x0=x;
	uint16_t phz=0;

	width+=x;
	height+=y;
	while(*p)
   20d3e:	4604      	mov	r4, r0
	width+=x;
   20d40:	4402      	add	r2, r0
	height+=y;
   20d42:	440b      	add	r3, r1
{
   20d44:	9d08      	ldr	r5, [sp, #32]
	{       
		if(x>=width){x=x0;y+=system_font;}
   20d46:	4f19      	ldr	r7, [pc, #100]	; (20dac <LCD_ShowStringInRect+0x74>)
	width+=x;
   20d48:	fa1f f882 	uxth.w	r8, r2
	height+=y;
   20d4c:	fa1f f983 	uxth.w	r9, r3
	while(*p)
   20d50:	fa5f fa80 	uxtb.w	sl, r0
   20d54:	782a      	ldrb	r2, [r5, #0]
   20d56:	b90a      	cbnz	r2, 20d5c <LCD_ShowStringInRect+0x24>
		#endif
			x+=system_font;
			p+=2;
		}        
	}
}
   20d58:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if(x>=width){x=x0;y+=system_font;}
   20d5c:	4544      	cmp	r4, r8
   20d5e:	bf21      	itttt	cs
   20d60:	783b      	ldrbcs	r3, [r7, #0]
   20d62:	4654      	movcs	r4, sl
   20d64:	18f6      	addcs	r6, r6, r3
   20d66:	b2b6      	uxthcs	r6, r6
		if(*p=='\n'){x=x0;y+=system_font;p++;}
   20d68:	2a0a      	cmp	r2, #10
   20d6a:	d104      	bne.n	20d76 <LCD_ShowStringInRect+0x3e>
   20d6c:	4654      	mov	r4, sl
   20d6e:	783b      	ldrb	r3, [r7, #0]
   20d70:	3501      	adds	r5, #1
   20d72:	441e      	add	r6, r3
   20d74:	b2b6      	uxth	r6, r6
		if(y>=height)break;//
   20d76:	454e      	cmp	r6, r9
   20d78:	d2ee      	bcs.n	20d58 <LCD_ShowStringInRect+0x20>
		if(*p==0x00)break;//
   20d7a:	782a      	ldrb	r2, [r5, #0]
   20d7c:	2a00      	cmp	r2, #0
   20d7e:	d0eb      	beq.n	20d58 <LCD_ShowStringInRect+0x20>
		if(*p<0x80)
   20d80:	0613      	lsls	r3, r2, #24
   20d82:	d40a      	bmi.n	20d9a <LCD_ShowStringInRect+0x62>
			LCD_ShowChar(x,y,*p,0);
   20d84:	4620      	mov	r0, r4
   20d86:	2300      	movs	r3, #0
   20d88:	4631      	mov	r1, r6
   20d8a:	f7ff fef3 	bl	20b74 <LCD_ShowChar>
			x+=system_font/2;
   20d8e:	7838      	ldrb	r0, [r7, #0]
			p++;
   20d90:	3501      	adds	r5, #1
			x+=system_font/2;
   20d92:	eb04 0450 	add.w	r4, r4, r0, lsr #1
   20d96:	b2a4      	uxth	r4, r4
			p++;
   20d98:	e7dc      	b.n	20d54 <LCD_ShowStringInRect+0x1c>
		else if(*(p+1))
   20d9a:	786b      	ldrb	r3, [r5, #1]
   20d9c:	2b00      	cmp	r3, #0
   20d9e:	d0d9      	beq.n	20d54 <LCD_ShowStringInRect+0x1c>
			x+=system_font;
   20da0:	7838      	ldrb	r0, [r7, #0]
			p+=2;
   20da2:	3502      	adds	r5, #2
			x+=system_font;
   20da4:	4404      	add	r4, r0
   20da6:	b2a4      	uxth	r4, r4
			p+=2;
   20da8:	e7d4      	b.n	20d54 <LCD_ShowStringInRect+0x1c>
   20daa:	bf00      	nop
   20dac:	200378e1 	.word	0x200378e1

00020db0 <LCD_ShowString>:

//
//x,y:
//*p:	
void LCD_ShowString(uint16_t x,uint16_t y,uint8_t *p)
{
   20db0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   20db4:	4605      	mov	r5, r0
   20db6:	460e      	mov	r6, r1
   20db8:	4614      	mov	r4, r2
	uint8_t width;
	uint16_t phz=0;

	while(*p)
	{       
		if(x>=LCD_WIDTH)break;//
   20dba:	f8df 8050 	ldr.w	r8, [pc, #80]	; 20e0c <LCD_ShowString+0x5c>
		if(y>=LCD_HEIGHT)break;//
   20dbe:	f8df 9050 	ldr.w	r9, [pc, #80]	; 20e10 <LCD_ShowString+0x60>
			LCD_ShowChineseChar_from_flash(x,y,phz,0);
		  #endif
		#else
			LCD_ShowChineseChar(x,y,phz,0);
		#endif
			x+=system_font;
   20dc2:	4f11      	ldr	r7, [pc, #68]	; (20e08 <LCD_ShowString+0x58>)
	while(*p)
   20dc4:	7822      	ldrb	r2, [r4, #0]
   20dc6:	b90a      	cbnz	r2, 20dcc <LCD_ShowString+0x1c>
			p+=2;
		}        
	}
}
   20dc8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if(x>=LCD_WIDTH)break;//
   20dcc:	f8b8 3000 	ldrh.w	r3, [r8]
   20dd0:	42ab      	cmp	r3, r5
   20dd2:	d9f9      	bls.n	20dc8 <LCD_ShowString+0x18>
		if(y>=LCD_HEIGHT)break;//
   20dd4:	f8b9 3000 	ldrh.w	r3, [r9]
   20dd8:	42b3      	cmp	r3, r6
   20dda:	d9f5      	bls.n	20dc8 <LCD_ShowString+0x18>
		if(*p<0x80)
   20ddc:	0613      	lsls	r3, r2, #24
   20dde:	d40a      	bmi.n	20df6 <LCD_ShowString+0x46>
			LCD_ShowChar(x,y,*p,0);
   20de0:	2300      	movs	r3, #0
   20de2:	4628      	mov	r0, r5
   20de4:	4631      	mov	r1, r6
   20de6:	f7ff fec5 	bl	20b74 <LCD_ShowChar>
		  	x += system_font/2;
   20dea:	783b      	ldrb	r3, [r7, #0]
			p++;
   20dec:	3401      	adds	r4, #1
		  	x += system_font/2;
   20dee:	eb05 0553 	add.w	r5, r5, r3, lsr #1
   20df2:	b2ad      	uxth	r5, r5
			p++;
   20df4:	e7e6      	b.n	20dc4 <LCD_ShowString+0x14>
		else if(*(p+1))
   20df6:	7863      	ldrb	r3, [r4, #1]
   20df8:	2b00      	cmp	r3, #0
   20dfa:	d0e3      	beq.n	20dc4 <LCD_ShowString+0x14>
			x+=system_font;
   20dfc:	783b      	ldrb	r3, [r7, #0]
			p+=2;
   20dfe:	3402      	adds	r4, #2
			x+=system_font;
   20e00:	441d      	add	r5, r3
   20e02:	b2ad      	uxth	r5, r5
			p+=2;
   20e04:	e7de      	b.n	20dc4 <LCD_ShowString+0x14>
   20e06:	bf00      	nop
   20e08:	200378e1 	.word	0x200378e1
   20e0c:	200348da 	.word	0x200348da
   20e10:	200348d8 	.word	0x200348d8

00020e14 <LCD_MeasureString>:
//width,height:
void LCD_MeasureString(uint8_t *p, uint16_t *width,uint16_t *height)
{
	uint8_t font_size;

	*width = 0;
   20e14:	2300      	movs	r3, #0
{
   20e16:	b570      	push	{r4, r5, r6, lr}
	*width = 0;
   20e18:	800b      	strh	r3, [r1, #0]
{
   20e1a:	460d      	mov	r5, r1
   20e1c:	4616      	mov	r6, r2
	*height = 0;
   20e1e:	8013      	strh	r3, [r2, #0]

	if(p == NULL || strlen((const char *)p) == 0)
   20e20:	4604      	mov	r4, r0
   20e22:	b148      	cbz	r0, 20e38 <LCD_MeasureString+0x24>
   20e24:	f7fc f998 	bl	1d158 <strlen>
   20e28:	b130      	cbz	r0, 20e38 <LCD_MeasureString+0x24>
		return;

	(*height) = system_font;
   20e2a:	4b0b      	ldr	r3, [pc, #44]	; (20e58 <LCD_MeasureString+0x44>)
   20e2c:	781b      	ldrb	r3, [r3, #0]
   20e2e:	b299      	uxth	r1, r3
   20e30:	8031      	strh	r1, [r6, #0]
		if(*p<0x80)
		{
		#ifdef FONTMAKER_MBCS_FONT
			(*width) += LCD_Measure_Mbcs_Byte(*p);
		#else
			(*width) += system_font/2;
   20e32:	085b      	lsrs	r3, r3, #1
	while(*p)
   20e34:	7822      	ldrb	r2, [r4, #0]
   20e36:	b902      	cbnz	r2, 20e3a <LCD_MeasureString+0x26>
		{
			(*width) += system_font;
			p += 2;
		}        
	}  
}
   20e38:	bd70      	pop	{r4, r5, r6, pc}
		if(*p<0x80)
   20e3a:	0612      	lsls	r2, r2, #24
   20e3c:	d404      	bmi.n	20e48 <LCD_MeasureString+0x34>
			(*width) += system_font/2;
   20e3e:	882a      	ldrh	r2, [r5, #0]
			p++;
   20e40:	3401      	adds	r4, #1
			(*width) += system_font/2;
   20e42:	441a      	add	r2, r3
   20e44:	802a      	strh	r2, [r5, #0]
			p++;
   20e46:	e7f5      	b.n	20e34 <LCD_MeasureString+0x20>
		else if(*(p+1))
   20e48:	7862      	ldrb	r2, [r4, #1]
   20e4a:	2a00      	cmp	r2, #0
   20e4c:	d0f2      	beq.n	20e34 <LCD_MeasureString+0x20>
			(*width) += system_font;
   20e4e:	882a      	ldrh	r2, [r5, #0]
			p += 2;
   20e50:	3402      	adds	r4, #2
			(*width) += system_font;
   20e52:	440a      	add	r2, r1
   20e54:	802a      	strh	r2, [r5, #0]
			p += 2;
   20e56:	e7ed      	b.n	20e34 <LCD_MeasureString+0x20>
   20e58:	200378e1 	.word	0x200378e1

00020e5c <LCD_SetFontSize>:

//
//font_size:
void LCD_SetFontSize(uint8_t font_size)
{
	if(font_size > FONT_SIZE_MIN && font_size < FONT_SIZE_MAX)
   20e5c:	1e43      	subs	r3, r0, #1
   20e5e:	2b1f      	cmp	r3, #31
		system_font = font_size;
   20e60:	bf9c      	itt	ls
   20e62:	4b01      	ldrls	r3, [pc, #4]	; (20e68 <LCD_SetFontSize+0xc>)
   20e64:	7018      	strbls	r0, [r3, #0]
}
   20e66:	4770      	bx	lr
   20e68:	200378e1 	.word	0x200378e1

00020e6c <LCDMsgProcess>:

void LCDMsgProcess(void)
{
   20e6c:	b508      	push	{r3, lr}
	if(lcd_sleep_in)
   20e6e:	4b08      	ldr	r3, [pc, #32]	; (20e90 <LCDMsgProcess+0x24>)
   20e70:	781a      	ldrb	r2, [r3, #0]
   20e72:	b11a      	cbz	r2, 20e7c <LCDMsgProcess+0x10>
	{
		lcd_sleep_in = false;
   20e74:	2200      	movs	r2, #0
   20e76:	701a      	strb	r2, [r3, #0]
		LCD_SleepIn();
   20e78:	f000 f8ba 	bl	20ff0 <LCD_SleepIn>
	}

	if(lcd_sleep_out)
   20e7c:	4b05      	ldr	r3, [pc, #20]	; (20e94 <LCDMsgProcess+0x28>)
   20e7e:	781a      	ldrb	r2, [r3, #0]
   20e80:	b12a      	cbz	r2, 20e8e <LCDMsgProcess+0x22>
	{
		lcd_sleep_out = false;
   20e82:	2200      	movs	r2, #0
   20e84:	701a      	strb	r2, [r3, #0]
		LCD_SleepOut();
	}
}
   20e86:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		LCD_SleepOut();
   20e8a:	f000 b8c5 	b.w	21018 <LCD_SleepOut>
}
   20e8e:	bd08      	pop	{r3, pc}
   20e90:	2002991e 	.word	0x2002991e
   20e94:	2002991f 	.word	0x2002991f

00020e98 <backlight_timer_handler>:
	k_sleep(K_MSEC(dly));
}

static void backlight_timer_handler(struct k_timer *timer)
{
	lcd_sleep_in = true;
   20e98:	2201      	movs	r2, #1
   20e9a:	4b01      	ldr	r3, [pc, #4]	; (20ea0 <backlight_timer_handler+0x8>)
   20e9c:	701a      	strb	r2, [r3, #0]
}
   20e9e:	4770      	bx	lr
   20ea0:	2002991e 	.word	0x2002991e

00020ea4 <LCD_SPI_Transceive.constprop.0>:
	tx_buff.buf = txbuf;
   20ea4:	4b0e      	ldr	r3, [pc, #56]	; (20ee0 <LCD_SPI_Transceive.constprop.0+0x3c>)
   20ea6:	4a0f      	ldr	r2, [pc, #60]	; (20ee4 <LCD_SPI_Transceive.constprop.0+0x40>)
static void LCD_SPI_Transceive(u8_t *txbuf, u32_t txbuflen, u8_t *rxbuf, u32_t rxbuflen)
   20ea8:	b510      	push	{r4, lr}
	tx_buff.len = txbuflen;
   20eaa:	e9c3 2000 	strd	r2, r0, [r3]
	tx_bufs.buffers = &tx_buff;
   20eae:	4a0e      	ldr	r2, [pc, #56]	; (20ee8 <LCD_SPI_Transceive.constprop.0+0x44>)
	tx_bufs.count = 1;
   20eb0:	2001      	movs	r0, #1
	tx_bufs.buffers = &tx_buff;
   20eb2:	6013      	str	r3, [r2, #0]
	rx_buff.buf = rxbuf;
   20eb4:	2300      	movs	r3, #0
   20eb6:	490d      	ldr	r1, [pc, #52]	; (20eec <LCD_SPI_Transceive.constprop.0+0x48>)
	tx_bufs.count = 1;
   20eb8:	6050      	str	r0, [r2, #4]
	rx_buff.len = rxbuflen;
   20eba:	e9c1 3300 	strd	r3, r3, [r1]
	rx_bufs.buffers = &rx_buff;
   20ebe:	4b0c      	ldr	r3, [pc, #48]	; (20ef0 <LCD_SPI_Transceive.constprop.0+0x4c>)
	rx_bufs.count = 1;
   20ec0:	e9c3 1000 	strd	r1, r0, [r3]
	err = spi_transceive(spi_lcd, &spi_cfg, &tx_bufs, &rx_bufs);
   20ec4:	490b      	ldr	r1, [pc, #44]	; (20ef4 <LCD_SPI_Transceive.constprop.0+0x50>)
   20ec6:	6808      	ldr	r0, [r1, #0]
				       const struct spi_buf_set *rx_bufs)
{
	const struct spi_driver_api *api =
		(const struct spi_driver_api *)dev->driver_api;

	return api->transceive(dev, config, tx_bufs, rx_bufs);
   20ec8:	6841      	ldr	r1, [r0, #4]
   20eca:	680c      	ldr	r4, [r1, #0]
   20ecc:	490a      	ldr	r1, [pc, #40]	; (20ef8 <LCD_SPI_Transceive.constprop.0+0x54>)
   20ece:	47a0      	blx	r4
	if(err)
   20ed0:	4601      	mov	r1, r0
   20ed2:	b120      	cbz	r0, 20ede <LCD_SPI_Transceive.constprop.0+0x3a>
}
   20ed4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		printk("SPI error: %d\n", err);
   20ed8:	4808      	ldr	r0, [pc, #32]	; (20efc <LCD_SPI_Transceive.constprop.0+0x58>)
   20eda:	f01b bc27 	b.w	3c72c <printk>
}
   20ede:	bd10      	pop	{r4, pc}
   20ee0:	20020bc8 	.word	0x20020bc8
   20ee4:	20029921 	.word	0x20029921
   20ee8:	20020bd0 	.word	0x20020bd0
   20eec:	20020b9c 	.word	0x20020b9c
   20ef0:	20020ba4 	.word	0x20020ba4
   20ef4:	20020bc4 	.word	0x20020bc4
   20ef8:	20020bac 	.word	0x20020bac
   20efc:	0004059b 	.word	0x0004059b

00020f00 <Write_Data>:

//
//i:8
void Write_Data(uint8_t i) 
{	
	lcd_data_buffer[0] = i;
   20f00:	4b02      	ldr	r3, [pc, #8]	; (20f0c <Write_Data+0xc>)
   20f02:	7018      	strb	r0, [r3, #0]
	
	LCD_SPI_Transceive(lcd_data_buffer, 1, NULL, 0);
   20f04:	2001      	movs	r0, #1
   20f06:	f7ff bfcd 	b.w	20ea4 <LCD_SPI_Transceive.constprop.0>
   20f0a:	bf00      	nop
   20f0c:	20029921 	.word	0x20029921

00020f10 <WriteComm>:

//----------------------------------------------------------------------
//
//i:
void WriteComm(u8_t i)
{
   20f10:	b510      	push	{r4, lr}
   20f12:	4604      	mov	r4, r0
	gpio_pin_write(gpio_lcd, RS, 0);
   20f14:	4b05      	ldr	r3, [pc, #20]	; (20f2c <WriteComm+0x1c>)
   20f16:	2200      	movs	r2, #0
   20f18:	2115      	movs	r1, #21
   20f1a:	6818      	ldr	r0, [r3, #0]
   20f1c:	f019 fd54 	bl	3a9c8 <gpio_pin_write>
	Write_Data(i);
   20f20:	4620      	mov	r0, r4
}
   20f22:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	Write_Data(i);
   20f26:	f7ff bfeb 	b.w	20f00 <Write_Data>
   20f2a:	bf00      	nop
   20f2c:	20020b98 	.word	0x20020b98

00020f30 <WriteData>:

//LCD
//i:
void WriteData(u8_t i)
{
   20f30:	b510      	push	{r4, lr}
   20f32:	4604      	mov	r4, r0
	gpio_pin_write(gpio_lcd, RS, 1);
   20f34:	4b05      	ldr	r3, [pc, #20]	; (20f4c <WriteData+0x1c>)
   20f36:	2201      	movs	r2, #1
   20f38:	2115      	movs	r1, #21
   20f3a:	6818      	ldr	r0, [r3, #0]
   20f3c:	f019 fd44 	bl	3a9c8 <gpio_pin_write>
	Write_Data(i);  
   20f40:	4620      	mov	r0, r4
}
   20f42:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	Write_Data(i);  
   20f46:	f7ff bfdb 	b.w	20f00 <Write_Data>
   20f4a:	bf00      	nop
   20f4c:	20020b98 	.word	0x20020b98

00020f50 <DispColor>:

	WriteComm(0x2c);
}

void DispColor(u32_t total, u16_t color)
{
   20f50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t i,remain;      

	gpio_pin_write(gpio_lcd, RS, 1);
   20f52:	4b12      	ldr	r3, [pc, #72]	; (20f9c <DispColor+0x4c>)
{
   20f54:	460e      	mov	r6, r1
   20f56:	4605      	mov	r5, r0
	gpio_pin_write(gpio_lcd, RS, 1);
   20f58:	2201      	movs	r2, #1
   20f5a:	2115      	movs	r1, #21
   20f5c:	6818      	ldr	r0, [r3, #0]
   20f5e:	f019 fd33 	bl	3a9c8 <gpio_pin_write>
		else
			remain = LCD_DATA_LEN;
		
		for(i=0;i<remain;i++)
		{
			lcd_data_buffer[2*i] = color>>8;
   20f62:	0a37      	lsrs	r7, r6, #8
		if(total <= LCD_DATA_LEN)
   20f64:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
   20f68:	462a      	mov	r2, r5
		for(i=0;i<remain;i++)
   20f6a:	f04f 0400 	mov.w	r4, #0
   20f6e:	bf28      	it	cs
   20f70:	f44f 5280 	movcs.w	r2, #4096	; 0x1000
   20f74:	4b0a      	ldr	r3, [pc, #40]	; (20fa0 <DispColor+0x50>)
   20f76:	4294      	cmp	r4, r2
   20f78:	f103 0302 	add.w	r3, r3, #2
   20f7c:	d107      	bne.n	20f8e <DispColor+0x3e>
			lcd_data_buffer[2*i+1] = color;
		}
		
		LCD_SPI_Transceive(lcd_data_buffer, 2*remain, NULL, 0);
   20f7e:	0060      	lsls	r0, r4, #1
   20f80:	f7ff ff90 	bl	20ea4 <LCD_SPI_Transceive.constprop.0>

		if(remain == total)
   20f84:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
   20f88:	d907      	bls.n	20f9a <DispColor+0x4a>
			break;

		total -= remain;
   20f8a:	1b2d      	subs	r5, r5, r4
		if(total <= LCD_DATA_LEN)
   20f8c:	e7ea      	b.n	20f64 <DispColor+0x14>
			lcd_data_buffer[2*i] = color>>8;
   20f8e:	f803 7c02 	strb.w	r7, [r3, #-2]
			lcd_data_buffer[2*i+1] = color;
   20f92:	f803 6c01 	strb.w	r6, [r3, #-1]
		for(i=0;i<remain;i++)
   20f96:	3401      	adds	r4, #1
   20f98:	e7ed      	b.n	20f76 <DispColor+0x26>
	}
}
   20f9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   20f9c:	20020b98 	.word	0x20020b98
   20fa0:	20029921 	.word	0x20029921

00020fa4 <DispDate>:

void DispDate(u32_t total, u8_t *data)
{
	u32_t i,remain;      

	gpio_pin_write(gpio_lcd, RS, 1);
   20fa4:	4b10      	ldr	r3, [pc, #64]	; (20fe8 <DispDate+0x44>)
{
   20fa6:	b570      	push	{r4, r5, r6, lr}
	gpio_pin_write(gpio_lcd, RS, 1);
   20fa8:	2201      	movs	r2, #1
{
   20faa:	4604      	mov	r4, r0
   20fac:	460e      	mov	r6, r1
	gpio_pin_write(gpio_lcd, RS, 1);
   20fae:	6818      	ldr	r0, [r3, #0]
   20fb0:	2115      	movs	r1, #21
   20fb2:	f019 fd09 	bl	3a9c8 <gpio_pin_write>
	
	while(1)
	{
		if(total <= 2*LCD_DATA_LEN)
   20fb6:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
   20fba:	4625      	mov	r5, r4
   20fbc:	bf28      	it	cs
   20fbe:	f44f 5500 	movcs.w	r5, #8192	; 0x2000
			remain = total;
		else
			remain = 2*LCD_DATA_LEN;
		
		for(i=0;i<remain;i++)
   20fc2:	4633      	mov	r3, r6
   20fc4:	4a09      	ldr	r2, [pc, #36]	; (20fec <DispDate+0x48>)
   20fc6:	1971      	adds	r1, r6, r5
   20fc8:	428b      	cmp	r3, r1
   20fca:	d107      	bne.n	20fdc <DispDate+0x38>
		{
			lcd_data_buffer[i] = data[i];
		}
		
		LCD_SPI_Transceive(lcd_data_buffer, remain, NULL, 0);
   20fcc:	4628      	mov	r0, r5
   20fce:	f7ff ff69 	bl	20ea4 <LCD_SPI_Transceive.constprop.0>

		if(remain == total)
   20fd2:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
   20fd6:	d906      	bls.n	20fe6 <DispDate+0x42>
			break;

		total -= remain;
   20fd8:	1b64      	subs	r4, r4, r5
		if(total <= 2*LCD_DATA_LEN)
   20fda:	e7ec      	b.n	20fb6 <DispDate+0x12>
			lcd_data_buffer[i] = data[i];
   20fdc:	f813 0b01 	ldrb.w	r0, [r3], #1
   20fe0:	f802 0b01 	strb.w	r0, [r2], #1
   20fe4:	e7f0      	b.n	20fc8 <DispDate+0x24>
	}
}
   20fe6:	bd70      	pop	{r4, r5, r6, pc}
   20fe8:	20020b98 	.word	0x20020b98
   20fec:	20029921 	.word	0x20029921

00020ff0 <LCD_SleepIn>:
	DispColor(COL*ROW, color);
} 

//
void LCD_SleepIn(void)
{
   20ff0:	b510      	push	{r4, lr}
	if(lcd_is_sleeping)
   20ff2:	4c08      	ldr	r4, [pc, #32]	; (21014 <LCD_SleepIn+0x24>)
   20ff4:	7823      	ldrb	r3, [r4, #0]
   20ff6:	b963      	cbnz	r3, 21012 <LCD_SleepIn+0x22>
		return;

	//
#ifdef LCD_BACKLIGHT_CONTROLED_BY_PMU
	Set_Screen_Backlight_Off();
   20ff8:	f01b f85d 	bl	3c0b6 <Set_Screen_Backlight_Off>
#else
	//gpio_pin_write(gpio_lcd, LEDK, 1);
	gpio_pin_write(gpio_lcd, LEDA, 0);
#endif

	WriteComm(0x28);	
   20ffc:	2028      	movs	r0, #40	; 0x28
   20ffe:	f7ff ff87 	bl	20f10 <WriteComm>
	WriteComm(0x10);  		//Sleep in	
   21002:	2010      	movs	r0, #16
   21004:	f7ff ff84 	bl	20f10 <WriteComm>
	k_sleep(K_MSEC(dly));
   21008:	2078      	movs	r0, #120	; 0x78
   2100a:	f019 fcdb 	bl	3a9c4 <k_sleep>
	Delay(120);             //120ms

	lcd_is_sleeping = true;
   2100e:	2301      	movs	r3, #1
   21010:	7023      	strb	r3, [r4, #0]
}
   21012:	bd10      	pop	{r4, pc}
   21014:	200378e0 	.word	0x200378e0

00021018 <LCD_SleepOut>:

//
void LCD_SleepOut(void)
{
   21018:	b510      	push	{r4, lr}
	const s32_t ticks = z_timeout_remaining(&timer->timeout);
   2101a:	4818      	ldr	r0, [pc, #96]	; (2107c <LCD_SleepOut+0x64>)
   2101c:	f017 f91e 	bl	3825c <z_timeout_remaining>
	return (ticks > 0) ? (u32_t)k_ticks_to_ms_floor64(ticks) : 0U;
   21020:	2800      	cmp	r0, #0
   21022:	dd0a      	ble.n	2103a <LCD_SleepOut+0x22>
   21024:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   21028:	fb80 0103 	smull	r0, r1, r0, r3
   2102c:	0bc3      	lsrs	r3, r0, #15
	u16_t bk_time;
	
	if(k_timer_remaining_get(&backlight_timer) > 0)
   2102e:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
   21032:	d002      	beq.n	2103a <LCD_SleepOut+0x22>
	z_impl_k_timer_stop(timer);
   21034:	4811      	ldr	r0, [pc, #68]	; (2107c <LCD_SleepOut+0x64>)
   21036:	f01d fb66 	bl	3e706 <z_impl_k_timer_stop>
		k_timer_stop(&backlight_timer);

	if(global_settings.backlight_time != 0)
   2103a:	4b11      	ldr	r3, [pc, #68]	; (21080 <LCD_SleepOut+0x68>)
   2103c:	899b      	ldrh	r3, [r3, #12]
   2103e:	b163      	cbz	r3, 2105a <LCD_SleepOut+0x42>
	{
		bk_time = global_settings.backlight_time;
		//xb add 2020-12-31 5
		if(sleep_out_by_wrist)
   21040:	4a10      	ldr	r2, [pc, #64]	; (21084 <LCD_SleepOut+0x6c>)
   21042:	7811      	ldrb	r1, [r2, #0]
   21044:	b111      	cbz	r1, 2104c <LCD_SleepOut+0x34>
		{
			sleep_out_by_wrist = false;
   21046:	2300      	movs	r3, #0
   21048:	7013      	strb	r3, [r2, #0]
			bk_time = 5;
   2104a:	2305      	movs	r3, #5
	z_impl_k_timer_start(timer, duration, period);
   2104c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   21050:	2200      	movs	r2, #0
   21052:	4359      	muls	r1, r3
   21054:	4809      	ldr	r0, [pc, #36]	; (2107c <LCD_SleepOut+0x64>)
   21056:	f017 fb21 	bl	3869c <z_impl_k_timer_start>
		}

		k_timer_start(&backlight_timer, K_SECONDS(bk_time), NULL);
	}

	if(!lcd_is_sleeping)
   2105a:	4c0b      	ldr	r4, [pc, #44]	; (21088 <LCD_SleepOut+0x70>)
   2105c:	7823      	ldrb	r3, [r4, #0]
   2105e:	b163      	cbz	r3, 2107a <LCD_SleepOut+0x62>
		return;
	
	WriteComm(0x11);  		//Sleep out	
   21060:	2011      	movs	r0, #17
   21062:	f7ff ff55 	bl	20f10 <WriteComm>
	k_sleep(K_MSEC(dly));
   21066:	2078      	movs	r0, #120	; 0x78
   21068:	f019 fcac 	bl	3a9c4 <k_sleep>
	Delay(120);             //120ms
	WriteComm(0x29);
   2106c:	2029      	movs	r0, #41	; 0x29
   2106e:	f7ff ff4f 	bl	20f10 <WriteComm>

	//
#ifdef LCD_BACKLIGHT_CONTROLED_BY_PMU
	Set_Screen_Backlight_On();
   21072:	f01b f81b 	bl	3c0ac <Set_Screen_Backlight_On>
#else
	//gpio_pin_write(gpio_lcd, LEDK, 0);
	gpio_pin_write(gpio_lcd, LEDA, 1);                                                                                                         
#endif

	lcd_is_sleeping = false;
   21076:	2300      	movs	r3, #0
   21078:	7023      	strb	r3, [r4, #0]
}
   2107a:	bd10      	pop	{r4, pc}
   2107c:	20020b6c 	.word	0x20020b6c
   21080:	200298a6 	.word	0x200298a6
   21084:	20029920 	.word	0x20029920
   21088:	200378e0 	.word	0x200378e0

0002108c <LCD_Init>:

//LCD
void LCD_Init(void)
{
   2108c:	b538      	push	{r3, r4, r5, lr}
	int err;
	
	printk("LCD_Init\n");
   2108e:	48a6      	ldr	r0, [pc, #664]	; (21328 <LCD_Init+0x29c>)
   21090:	f01b fb4c 	bl	3c72c <printk>
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
   21094:	48a5      	ldr	r0, [pc, #660]	; (2132c <LCD_Init+0x2a0>)
   21096:	f014 fac3 	bl	35620 <z_impl_device_get_binding>
	
  	//
  	gpio_lcd = device_get_binding(LCD_PORT);
   2109a:	4ca5      	ldr	r4, [pc, #660]	; (21330 <LCD_Init+0x2a4>)
   2109c:	6020      	str	r0, [r4, #0]
	if(!gpio_lcd)
   2109e:	b920      	cbnz	r0, 210aa <LCD_Init+0x1e>

	k_timer_init(&backlight_timer, backlight_timer_handler, NULL);

	if(global_settings.backlight_time != 0)
		k_timer_start(&backlight_timer, K_SECONDS(global_settings.backlight_time), NULL);	
}
   210a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		printk("Cannot bind gpio device\n");
   210a4:	48a3      	ldr	r0, [pc, #652]	; (21334 <LCD_Init+0x2a8>)
   210a6:	f01b bb41 	b.w	3c72c <printk>
	gpio_pin_configure(gpio_lcd, LEDA, GPIO_DIR_OUT);
   210aa:	210e      	movs	r1, #14
   210ac:	f019 fc96 	bl	3a9dc <gpio_pin_configure.constprop.2>
	gpio_pin_configure(gpio_lcd, CS, GPIO_DIR_OUT);
   210b0:	2117      	movs	r1, #23
   210b2:	6820      	ldr	r0, [r4, #0]
   210b4:	f019 fc92 	bl	3a9dc <gpio_pin_configure.constprop.2>
	gpio_pin_configure(gpio_lcd, RST, GPIO_DIR_OUT);
   210b8:	2118      	movs	r1, #24
   210ba:	6820      	ldr	r0, [r4, #0]
   210bc:	f019 fc8e 	bl	3a9dc <gpio_pin_configure.constprop.2>
	gpio_pin_configure(gpio_lcd, RS, GPIO_DIR_OUT);
   210c0:	2115      	movs	r1, #21
   210c2:	6820      	ldr	r0, [r4, #0]
   210c4:	f019 fc8a 	bl	3a9dc <gpio_pin_configure.constprop.2>
	gpio_pin_configure(gpio_lcd, VDD, GPIO_DIR_OUT);
   210c8:	2112      	movs	r1, #18
   210ca:	6820      	ldr	r0, [r4, #0]
   210cc:	f019 fc86 	bl	3a9dc <gpio_pin_configure.constprop.2>
	gpio_pin_write(gpio_lcd, VDD, 1);
   210d0:	2201      	movs	r2, #1
   210d2:	2112      	movs	r1, #18
   210d4:	6820      	ldr	r0, [r4, #0]
   210d6:	f019 fc77 	bl	3a9c8 <gpio_pin_write>
   210da:	4897      	ldr	r0, [pc, #604]	; (21338 <LCD_Init+0x2ac>)
   210dc:	f014 faa0 	bl	35620 <z_impl_device_get_binding>
	spi_lcd = device_get_binding(LCD_DEV);
   210e0:	4b96      	ldr	r3, [pc, #600]	; (2133c <LCD_Init+0x2b0>)
   210e2:	6018      	str	r0, [r3, #0]
	if(!spi_lcd) 
   210e4:	2800      	cmp	r0, #0
   210e6:	f040 8107 	bne.w	212f8 <LCD_Init+0x26c>
		printk("Could not get %s device\n", LCD_DEV);
   210ea:	4993      	ldr	r1, [pc, #588]	; (21338 <LCD_Init+0x2ac>)
   210ec:	4894      	ldr	r0, [pc, #592]	; (21340 <LCD_Init+0x2b4>)
   210ee:	f01b fb1d 	bl	3c72c <printk>
	gpio_pin_write(gpio_lcd, RST, 1);
   210f2:	2201      	movs	r2, #1
   210f4:	2118      	movs	r1, #24
   210f6:	6820      	ldr	r0, [r4, #0]
   210f8:	f019 fc66 	bl	3a9c8 <gpio_pin_write>
	k_sleep(K_MSEC(dly));
   210fc:	200a      	movs	r0, #10
   210fe:	f019 fc61 	bl	3a9c4 <k_sleep>
	gpio_pin_write(gpio_lcd, RST, 0);
   21102:	2200      	movs	r2, #0
   21104:	2118      	movs	r1, #24
   21106:	6820      	ldr	r0, [r4, #0]
   21108:	f019 fc5e 	bl	3a9c8 <gpio_pin_write>
	k_sleep(K_MSEC(dly));
   2110c:	200a      	movs	r0, #10
   2110e:	f019 fc59 	bl	3a9c4 <k_sleep>
	gpio_pin_write(gpio_lcd, RST, 1);
   21112:	2201      	movs	r2, #1
   21114:	2118      	movs	r1, #24
   21116:	6820      	ldr	r0, [r4, #0]
   21118:	f019 fc56 	bl	3a9c8 <gpio_pin_write>
	k_sleep(K_MSEC(dly));
   2111c:	2078      	movs	r0, #120	; 0x78
   2111e:	f019 fc51 	bl	3a9c4 <k_sleep>
	WriteComm(0x11);     //Sleep out
   21122:	2011      	movs	r0, #17
   21124:	f7ff fef4 	bl	20f10 <WriteComm>
	k_sleep(K_MSEC(dly));
   21128:	2078      	movs	r0, #120	; 0x78
   2112a:	f019 fc4b 	bl	3a9c4 <k_sleep>
	WriteComm(0xfe);
   2112e:	20fe      	movs	r0, #254	; 0xfe
   21130:	f7ff feee 	bl	20f10 <WriteComm>
	WriteComm(0xef);	
   21134:	20ef      	movs	r0, #239	; 0xef
   21136:	f7ff feeb 	bl	20f10 <WriteComm>
	WriteComm(0x36);	
   2113a:	2036      	movs	r0, #54	; 0x36
   2113c:	f7ff fee8 	bl	20f10 <WriteComm>
	WriteData(0x48);	
   21140:	2048      	movs	r0, #72	; 0x48
   21142:	f7ff fef5 	bl	20f30 <WriteData>
	WriteComm(0x3a);	
   21146:	203a      	movs	r0, #58	; 0x3a
   21148:	f7ff fee2 	bl	20f10 <WriteComm>
	WriteData(0x05);	
   2114c:	2005      	movs	r0, #5
   2114e:	f7ff feef 	bl	20f30 <WriteData>
	WriteComm(0x86);	
   21152:	2086      	movs	r0, #134	; 0x86
   21154:	f7ff fedc 	bl	20f10 <WriteComm>
	WriteData(0x98);	
   21158:	2098      	movs	r0, #152	; 0x98
   2115a:	f7ff fee9 	bl	20f30 <WriteData>
	WriteComm(0x89);	
   2115e:	2089      	movs	r0, #137	; 0x89
   21160:	f7ff fed6 	bl	20f10 <WriteComm>
	WriteData(0x03);
   21164:	2003      	movs	r0, #3
   21166:	f7ff fee3 	bl	20f30 <WriteData>
	WriteComm(0x8b);	
   2116a:	208b      	movs	r0, #139	; 0x8b
   2116c:	f7ff fed0 	bl	20f10 <WriteComm>
	WriteData(0x80);	
   21170:	2080      	movs	r0, #128	; 0x80
   21172:	f7ff fedd 	bl	20f30 <WriteData>
	WriteComm(0x8d);	
   21176:	208d      	movs	r0, #141	; 0x8d
   21178:	f7ff feca 	bl	20f10 <WriteComm>
	WriteData(0x33);	
   2117c:	2033      	movs	r0, #51	; 0x33
   2117e:	f7ff fed7 	bl	20f30 <WriteData>
	WriteComm(0x8e);	
   21182:	208e      	movs	r0, #142	; 0x8e
   21184:	f7ff fec4 	bl	20f10 <WriteComm>
	WriteData(0x8f);	
   21188:	208f      	movs	r0, #143	; 0x8f
   2118a:	f7ff fed1 	bl	20f30 <WriteData>
	WriteComm(0xe8);
   2118e:	20e8      	movs	r0, #232	; 0xe8
   21190:	f7ff febe 	bl	20f10 <WriteComm>
	WriteData(0x12);
   21194:	2012      	movs	r0, #18
   21196:	f7ff fecb 	bl	20f30 <WriteData>
	WriteData(0x00);	
   2119a:	2000      	movs	r0, #0
   2119c:	f7ff fec8 	bl	20f30 <WriteData>
	WriteComm(0xc3);	
   211a0:	20c3      	movs	r0, #195	; 0xc3
   211a2:	f7ff feb5 	bl	20f10 <WriteComm>
	WriteData(0x20);
   211a6:	2020      	movs	r0, #32
   211a8:	f7ff fec2 	bl	20f30 <WriteData>
	WriteComm(0xc4);	
   211ac:	20c4      	movs	r0, #196	; 0xc4
   211ae:	f7ff feaf 	bl	20f10 <WriteComm>
	WriteData(0x30);
   211b2:	2030      	movs	r0, #48	; 0x30
   211b4:	f7ff febc 	bl	20f30 <WriteData>
	WriteComm(0xc9);	
   211b8:	20c9      	movs	r0, #201	; 0xc9
   211ba:	f7ff fea9 	bl	20f10 <WriteComm>
	WriteData(0x08);
   211be:	2008      	movs	r0, #8
   211c0:	f7ff feb6 	bl	20f30 <WriteData>
	WriteComm(0xff);
   211c4:	20ff      	movs	r0, #255	; 0xff
   211c6:	f7ff fea3 	bl	20f10 <WriteComm>
	WriteData(0x62);
   211ca:	2062      	movs	r0, #98	; 0x62
   211cc:	f7ff feb0 	bl	20f30 <WriteData>
	WriteComm(0x99);	
   211d0:	2099      	movs	r0, #153	; 0x99
   211d2:	f7ff fe9d 	bl	20f10 <WriteComm>
	WriteData(0x3e);
   211d6:	203e      	movs	r0, #62	; 0x3e
   211d8:	f7ff feaa 	bl	20f30 <WriteData>
	WriteComm(0x9d);	
   211dc:	209d      	movs	r0, #157	; 0x9d
   211de:	f7ff fe97 	bl	20f10 <WriteComm>
	WriteData(0x4b);
   211e2:	204b      	movs	r0, #75	; 0x4b
   211e4:	f7ff fea4 	bl	20f30 <WriteData>
	WriteComm(0x98);	
   211e8:	2098      	movs	r0, #152	; 0x98
   211ea:	f7ff fe91 	bl	20f10 <WriteComm>
	WriteData(0x3e);
   211ee:	203e      	movs	r0, #62	; 0x3e
   211f0:	f7ff fe9e 	bl	20f30 <WriteData>
	WriteComm(0x9c);	
   211f4:	209c      	movs	r0, #156	; 0x9c
   211f6:	f7ff fe8b 	bl	20f10 <WriteComm>
	WriteData(0x4b);
   211fa:	204b      	movs	r0, #75	; 0x4b
   211fc:	f7ff fe98 	bl	20f30 <WriteData>
	WriteComm(0xf0);
   21200:	20f0      	movs	r0, #240	; 0xf0
   21202:	f7ff fe85 	bl	20f10 <WriteComm>
	WriteData(0x13);
   21206:	2013      	movs	r0, #19
   21208:	f7ff fe92 	bl	20f30 <WriteData>
	WriteData(0x14);
   2120c:	2014      	movs	r0, #20
   2120e:	f7ff fe8f 	bl	20f30 <WriteData>
	lcd_is_sleeping = false;
   21212:	2400      	movs	r4, #0
	WriteData(0x07);
   21214:	2007      	movs	r0, #7
   21216:	f7ff fe8b 	bl	20f30 <WriteData>
	WriteData(0x05);
   2121a:	2005      	movs	r0, #5
   2121c:	f7ff fe88 	bl	20f30 <WriteData>
	WriteData(0xf0);
   21220:	20f0      	movs	r0, #240	; 0xf0
   21222:	f7ff fe85 	bl	20f30 <WriteData>
	WriteData(0x29);
   21226:	2029      	movs	r0, #41	; 0x29
   21228:	f7ff fe82 	bl	20f30 <WriteData>
	WriteComm(0xf1);
   2122c:	20f1      	movs	r0, #241	; 0xf1
   2122e:	f7ff fe6f 	bl	20f10 <WriteComm>
	WriteData(0x3e);
   21232:	203e      	movs	r0, #62	; 0x3e
   21234:	f7ff fe7c 	bl	20f30 <WriteData>
	WriteData(0x92);
   21238:	2092      	movs	r0, #146	; 0x92
   2123a:	f7ff fe79 	bl	20f30 <WriteData>
	WriteData(0x90);
   2123e:	2090      	movs	r0, #144	; 0x90
   21240:	f7ff fe76 	bl	20f30 <WriteData>
	WriteData(0x21);
   21244:	2021      	movs	r0, #33	; 0x21
   21246:	f7ff fe73 	bl	20f30 <WriteData>
	WriteData(0x23);
   2124a:	2023      	movs	r0, #35	; 0x23
   2124c:	f7ff fe70 	bl	20f30 <WriteData>
	WriteData(0x9f);
   21250:	209f      	movs	r0, #159	; 0x9f
   21252:	f7ff fe6d 	bl	20f30 <WriteData>
	WriteComm(0xf2);
   21256:	20f2      	movs	r0, #242	; 0xf2
   21258:	f7ff fe5a 	bl	20f10 <WriteComm>
	WriteData(0x13);
   2125c:	2013      	movs	r0, #19
   2125e:	f7ff fe67 	bl	20f30 <WriteData>
	WriteData(0x14);
   21262:	2014      	movs	r0, #20
   21264:	f7ff fe64 	bl	20f30 <WriteData>
	WriteData(0x07);
   21268:	2007      	movs	r0, #7
   2126a:	f7ff fe61 	bl	20f30 <WriteData>
	WriteData(0x05);
   2126e:	2005      	movs	r0, #5
   21270:	f7ff fe5e 	bl	20f30 <WriteData>
	WriteData(0xf0);
   21274:	20f0      	movs	r0, #240	; 0xf0
   21276:	f7ff fe5b 	bl	20f30 <WriteData>
	WriteData(0x29);
   2127a:	2029      	movs	r0, #41	; 0x29
   2127c:	f7ff fe58 	bl	20f30 <WriteData>
	WriteComm(0xf3);
   21280:	20f3      	movs	r0, #243	; 0xf3
   21282:	f7ff fe45 	bl	20f10 <WriteComm>
	WriteData(0x3e);
   21286:	203e      	movs	r0, #62	; 0x3e
   21288:	f7ff fe52 	bl	20f30 <WriteData>
	WriteData(0x92);
   2128c:	2092      	movs	r0, #146	; 0x92
   2128e:	f7ff fe4f 	bl	20f30 <WriteData>
	WriteData(0x90);
   21292:	2090      	movs	r0, #144	; 0x90
   21294:	f7ff fe4c 	bl	20f30 <WriteData>
	WriteData(0x21);
   21298:	2021      	movs	r0, #33	; 0x21
   2129a:	f7ff fe49 	bl	20f30 <WriteData>
	WriteData(0x23);
   2129e:	2023      	movs	r0, #35	; 0x23
   212a0:	f7ff fe46 	bl	20f30 <WriteData>
	WriteData(0x9f);
   212a4:	209f      	movs	r0, #159	; 0x9f
   212a6:	f7ff fe43 	bl	20f30 <WriteData>
	WriteComm(0x11);
   212aa:	2011      	movs	r0, #17
   212ac:	f7ff fe30 	bl	20f10 <WriteComm>
	k_sleep(K_MSEC(dly));
   212b0:	2078      	movs	r0, #120	; 0x78
   212b2:	f019 fb87 	bl	3a9c4 <k_sleep>
	WriteComm(0x29);
   212b6:	2029      	movs	r0, #41	; 0x29
   212b8:	f7ff fe2a 	bl	20f10 <WriteComm>
	WriteComm(0x2c);
   212bc:	202c      	movs	r0, #44	; 0x2c
   212be:	f7ff fe27 	bl	20f10 <WriteComm>
	LCD_Clear(BLACK);		//
   212c2:	2000      	movs	r0, #0
   212c4:	f019 fbcc 	bl	3aa60 <LCD_Clear>
	k_sleep(K_MSEC(dly));
   212c8:	2014      	movs	r0, #20
   212ca:	f019 fb7b 	bl	3a9c4 <k_sleep>
	Set_Screen_Backlight_On();
   212ce:	f01a feed 	bl	3c0ac <Set_Screen_Backlight_On>
	lcd_is_sleeping = false;
   212d2:	4b1c      	ldr	r3, [pc, #112]	; (21344 <LCD_Init+0x2b8>)
	k_timer_init(&backlight_timer, backlight_timer_handler, NULL);
   212d4:	4622      	mov	r2, r4
   212d6:	491c      	ldr	r1, [pc, #112]	; (21348 <LCD_Init+0x2bc>)
   212d8:	481c      	ldr	r0, [pc, #112]	; (2134c <LCD_Init+0x2c0>)
	lcd_is_sleeping = false;
   212da:	701c      	strb	r4, [r3, #0]
	k_timer_init(&backlight_timer, backlight_timer_handler, NULL);
   212dc:	f01d fa07 	bl	3e6ee <k_timer_init>
	if(global_settings.backlight_time != 0)
   212e0:	4b1b      	ldr	r3, [pc, #108]	; (21350 <LCD_Init+0x2c4>)
   212e2:	899b      	ldrh	r3, [r3, #12]
   212e4:	b1f3      	cbz	r3, 21324 <LCD_Init+0x298>
   212e6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   212ea:	4622      	mov	r2, r4
   212ec:	4359      	muls	r1, r3
}
   212ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   212f2:	4816      	ldr	r0, [pc, #88]	; (2134c <LCD_Init+0x2c0>)
   212f4:	f017 b9d2 	b.w	3869c <z_impl_k_timer_start>
	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
   212f8:	f44f 7380 	mov.w	r3, #256	; 0x100
	spi_cfg.frequency = 4000000;
   212fc:	4d15      	ldr	r5, [pc, #84]	; (21354 <LCD_Init+0x2c8>)
	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
   212fe:	4816      	ldr	r0, [pc, #88]	; (21358 <LCD_Init+0x2cc>)
   21300:	e9c5 0300 	strd	r0, r3, [r5]
   21304:	4809      	ldr	r0, [pc, #36]	; (2132c <LCD_Init+0x2a0>)
   21306:	f014 f98b 	bl	35620 <z_impl_device_get_binding>
	spi_cs_ctr.gpio_dev = device_get_binding(LCD_PORT);
   2130a:	4b14      	ldr	r3, [pc, #80]	; (2135c <LCD_Init+0x2d0>)
   2130c:	6018      	str	r0, [r3, #0]
	if (!spi_cs_ctr.gpio_dev)
   2130e:	b918      	cbnz	r0, 21318 <LCD_Init+0x28c>
		printk("Unable to get GPIO SPI CS device\n");
   21310:	4813      	ldr	r0, [pc, #76]	; (21360 <LCD_Init+0x2d4>)
   21312:	f01b fa0b 	bl	3c72c <printk>
		return;
   21316:	e6ec      	b.n	210f2 <LCD_Init+0x66>
	spi_cs_ctr.delay = 0U;
   21318:	2117      	movs	r1, #23
   2131a:	2200      	movs	r2, #0
	spi_cfg.cs = &spi_cs_ctr;
   2131c:	60ab      	str	r3, [r5, #8]
	spi_cs_ctr.delay = 0U;
   2131e:	e9c3 1201 	strd	r1, r2, [r3, #4]
	spi_cfg.cs = &spi_cs_ctr;
   21322:	e6e6      	b.n	210f2 <LCD_Init+0x66>
}
   21324:	bd38      	pop	{r3, r4, r5, pc}
   21326:	bf00      	nop
   21328:	00040530 	.word	0x00040530
   2132c:	0004053a 	.word	0x0004053a
   21330:	20020b98 	.word	0x20020b98
   21334:	00040541 	.word	0x00040541
   21338:	0004055a 	.word	0x0004055a
   2133c:	20020bc4 	.word	0x20020bc4
   21340:	00040560 	.word	0x00040560
   21344:	200378e0 	.word	0x200378e0
   21348:	00020e99 	.word	0x00020e99
   2134c:	20020b6c 	.word	0x20020b6c
   21350:	200298a6 	.word	0x200298a6
   21354:	20020bac 	.word	0x20020bac
   21358:	003d0900 	.word	0x003d0900
   2135c:	20020bb8 	.word	0x20020bb8
   21360:	00040579 	.word	0x00040579

00021364 <key_event_handler>:

static void key_event_handler(u8_t key_code, u8_t key_type)
{
	//LOG_INF("key_code:%d, key_type:%d, KEY_SOS:%d,KEY_PWR:%d\n", key_code, key_type,	KEY_SOS, KEY_PWR);

	switch(key_code)
   21364:	2802      	cmp	r0, #2
{
   21366:	b508      	push	{r3, lr}
	switch(key_code)
   21368:	d112      	bne.n	21390 <key_event_handler+0x2c>
		case KEY_LONG_PRESS:
			break;
		}
		break;
	case KEY_PWR:
		switch(key_type)
   2136a:	2902      	cmp	r1, #2
   2136c:	d110      	bne.n	21390 <key_event_handler+0x2c>
		case KEY_DOWN:
			break;
		case KEY_UP:
			break;
		case KEY_LONG_PRESS:
			sys_pwr_off = true;
   2136e:	2201      	movs	r2, #1
   21370:	4b0e      	ldr	r3, [pc, #56]	; (213ac <key_event_handler+0x48>)
   21372:	701a      	strb	r2, [r3, #0]
			lcd_sleep_out = true;
		else
			lcd_sleep_in = true;
	}

	if(alarm_is_running)
   21374:	4b0e      	ldr	r3, [pc, #56]	; (213b0 <key_event_handler+0x4c>)
   21376:	781b      	ldrb	r3, [r3, #0]
   21378:	b10b      	cbz	r3, 2137e <key_event_handler+0x1a>
	{
		AlarmRemindStop();
   2137a:	f7ff fa8d 	bl	20898 <AlarmRemindStop>
	}

	if(find_is_running)
   2137e:	4b0d      	ldr	r3, [pc, #52]	; (213b4 <key_event_handler+0x50>)
   21380:	781b      	ldrb	r3, [r3, #0]
   21382:	b10b      	cbz	r3, 21388 <key_event_handler+0x24>
	{
		FindDeviceStop();
   21384:	f7ff fb20 	bl	209c8 <FindDeviceStop>
	}

	ExitNotifyScreen();
}
   21388:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	ExitNotifyScreen();
   2138c:	f004 b9b4 	b.w	256f8 <ExitNotifyScreen>
	if((key_type == KEY_UP))
   21390:	2900      	cmp	r1, #0
   21392:	d1ef      	bne.n	21374 <key_event_handler+0x10>
		sleep_out_by_wrist = false;
   21394:	4b08      	ldr	r3, [pc, #32]	; (213b8 <key_event_handler+0x54>)
   21396:	7019      	strb	r1, [r3, #0]
		if(lcd_is_sleeping)
   21398:	4b08      	ldr	r3, [pc, #32]	; (213bc <key_event_handler+0x58>)
   2139a:	781a      	ldrb	r2, [r3, #0]
   2139c:	2301      	movs	r3, #1
   2139e:	b112      	cbz	r2, 213a6 <key_event_handler+0x42>
			lcd_sleep_out = true;
   213a0:	4a07      	ldr	r2, [pc, #28]	; (213c0 <key_event_handler+0x5c>)
			lcd_sleep_in = true;
   213a2:	7013      	strb	r3, [r2, #0]
   213a4:	e7e6      	b.n	21374 <key_event_handler+0x10>
   213a6:	4a07      	ldr	r2, [pc, #28]	; (213c4 <key_event_handler+0x60>)
   213a8:	e7fb      	b.n	213a2 <key_event_handler+0x3e>
   213aa:	bf00      	nop
   213ac:	2002c38a 	.word	0x2002c38a
   213b0:	20029919 	.word	0x20029919
   213b4:	2002991c 	.word	0x2002991c
   213b8:	20029920 	.word	0x20029920
   213bc:	200378e0 	.word	0x200378e0
   213c0:	2002991f 	.word	0x2002991f
   213c4:	2002991e 	.word	0x2002991e

000213c8 <long_press_timer_handler>:
	key_event_handler(keycode, keytype);
}

static void long_press_timer_handler(struct k_timer *timer)
{
    key_event_handler(keycode, KEY_LONG_PRESS);
   213c8:	4b02      	ldr	r3, [pc, #8]	; (213d4 <long_press_timer_handler+0xc>)
   213ca:	2102      	movs	r1, #2
   213cc:	7818      	ldrb	r0, [r3, #0]
   213ce:	f7ff bfc9 	b.w	21364 <key_event_handler>
   213d2:	bf00      	nop
   213d4:	20020c50 	.word	0x20020c50

000213d8 <button_handler>:
{
   213d8:	b538      	push	{r3, r4, r5, lr}
   213da:	4602      	mov	r2, r0
	u32_t buttons = (button_state & has_changed);
   213dc:	ea00 0501 	and.w	r5, r0, r1
	LOG_INF("button_state:%d, has_changed:%d\n", button_state, has_changed);
   213e0:	2303      	movs	r3, #3
   213e2:	f04f 0000 	mov.w	r0, #0
{
   213e6:	460c      	mov	r4, r1
	LOG_INF("button_state:%d, has_changed:%d\n", button_state, has_changed);
   213e8:	f363 0007 	bfi	r0, r3, #0, #8
   213ec:	4912      	ldr	r1, [pc, #72]	; (21438 <button_handler+0x60>)
   213ee:	4b13      	ldr	r3, [pc, #76]	; (2143c <button_handler+0x64>)
   213f0:	1a5b      	subs	r3, r3, r1
   213f2:	08db      	lsrs	r3, r3, #3
   213f4:	4912      	ldr	r1, [pc, #72]	; (21440 <button_handler+0x68>)
   213f6:	f363 108f 	bfi	r0, r3, #6, #10
   213fa:	4623      	mov	r3, r4
   213fc:	f01b f9ed 	bl	3c7da <log_string_sync>
	keytype = (buttons>0 ? KEY_DOWN:KEY_UP);
   21400:	2d00      	cmp	r5, #0
   21402:	bf14      	ite	ne
   21404:	2101      	movne	r1, #1
   21406:	2100      	moveq	r1, #0
	keycode = has_changed;
   21408:	4b0e      	ldr	r3, [pc, #56]	; (21444 <button_handler+0x6c>)
	keytype = (buttons>0 ? KEY_DOWN:KEY_UP);
   2140a:	4a0f      	ldr	r2, [pc, #60]	; (21448 <button_handler+0x70>)
	keycode = has_changed;
   2140c:	601c      	str	r4, [r3, #0]
	keytype = (buttons>0 ? KEY_DOWN:KEY_UP);
   2140e:	6011      	str	r1, [r2, #0]
	switch(keytype)
   21410:	461c      	mov	r4, r3
   21412:	4615      	mov	r5, r2
   21414:	d00b      	beq.n	2142e <button_handler+0x56>
   21416:	2200      	movs	r2, #0
   21418:	f241 3188 	movw	r1, #5000	; 0x1388
   2141c:	480b      	ldr	r0, [pc, #44]	; (2144c <button_handler+0x74>)
   2141e:	f017 f93d 	bl	3869c <z_impl_k_timer_start>
	key_event_handler(keycode, keytype);
   21422:	7829      	ldrb	r1, [r5, #0]
   21424:	7820      	ldrb	r0, [r4, #0]
}
   21426:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	key_event_handler(keycode, keytype);
   2142a:	f7ff bf9b 	b.w	21364 <key_event_handler>
	z_impl_k_timer_stop(timer);
   2142e:	4807      	ldr	r0, [pc, #28]	; (2144c <button_handler+0x74>)
   21430:	f01d f969 	bl	3e706 <z_impl_k_timer_stop>
   21434:	e7f5      	b.n	21422 <button_handler+0x4a>
   21436:	bf00      	nop
   21438:	0003f8d4 	.word	0x0003f8d4
   2143c:	0003f954 	.word	0x0003f954
   21440:	000405aa 	.word	0x000405aa
   21444:	20020c50 	.word	0x20020c50
   21448:	20020c54 	.word	0x20020c54
   2144c:	20020c18 	.word	0x20020c18

00021450 <button_pressed>:

	last_state = current_state;
}

static void button_pressed(struct device *gpio_dev, struct gpio_callback *cb, u32_t pins)
{
   21450:	b538      	push	{r3, r4, r5, lr}
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
   21452:	f04f 0320 	mov.w	r3, #32
   21456:	f3ef 8411 	mrs	r4, BASEPRI
   2145a:	f383 8811 	msr	BASEPRI, r3
   2145e:	f3bf 8f6f 	isb	sy
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   21462:	4833      	ldr	r0, [pc, #204]	; (21530 <button_pressed+0xe0>)
   21464:	f016 fb6c 	bl	37b40 <z_spin_lock_valid>
   21468:	b968      	cbnz	r0, 21486 <button_pressed+0x36>
   2146a:	234a      	movs	r3, #74	; 0x4a
   2146c:	4a31      	ldr	r2, [pc, #196]	; (21534 <button_pressed+0xe4>)
   2146e:	4932      	ldr	r1, [pc, #200]	; (21538 <button_pressed+0xe8>)
   21470:	4832      	ldr	r0, [pc, #200]	; (2153c <button_pressed+0xec>)
   21472:	f01b f95b 	bl	3c72c <printk>
   21476:	492e      	ldr	r1, [pc, #184]	; (21530 <button_pressed+0xe0>)
   21478:	4831      	ldr	r0, [pc, #196]	; (21540 <button_pressed+0xf0>)
   2147a:	f01b f957 	bl	3c72c <printk>
   2147e:	214a      	movs	r1, #74	; 0x4a
   21480:	482c      	ldr	r0, [pc, #176]	; (21534 <button_pressed+0xe4>)
   21482:	f01b f999 	bl	3c7b8 <assert_post_action>
			err = gpio_pin_disable_callback(button_devs[i], button_pins[i].number);
   21486:	4d2f      	ldr	r5, [pc, #188]	; (21544 <button_pressed+0xf4>)
	while (!atomic_cas(&l->locked, 0, 1)) {
	}
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
   21488:	4829      	ldr	r0, [pc, #164]	; (21530 <button_pressed+0xe0>)
   2148a:	f016 fb77 	bl	37b7c <z_spin_lock_set_owner>
   2148e:	6828      	ldr	r0, [r5, #0]
					      int access_op, u32_t pin)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	if (api->disable_callback == NULL) {
   21490:	6843      	ldr	r3, [r0, #4]
   21492:	695b      	ldr	r3, [r3, #20]
   21494:	2b00      	cmp	r3, #0
   21496:	d12e      	bne.n	214f6 <button_pressed+0xa6>
	/* Disable GPIO interrupt */
	int err = callback_ctrl(false);

	if(err)
	{
		LOG_INF("Cannot disable callbacks");
   21498:	2303      	movs	r3, #3
   2149a:	f04f 0000 	mov.w	r0, #0
   2149e:	4a2a      	ldr	r2, [pc, #168]	; (21548 <button_pressed+0xf8>)
   214a0:	f363 0007 	bfi	r0, r3, #0, #8
   214a4:	4b29      	ldr	r3, [pc, #164]	; (2154c <button_pressed+0xfc>)
   214a6:	492a      	ldr	r1, [pc, #168]	; (21550 <button_pressed+0x100>)
   214a8:	1a9b      	subs	r3, r3, r2
   214aa:	08db      	lsrs	r3, r3, #3
   214ac:	f363 108f 	bfi	r0, r3, #6, #10
   214b0:	f01b f993 	bl	3c7da <log_string_sync>
	}

	switch (state)
   214b4:	4b27      	ldr	r3, [pc, #156]	; (21554 <button_pressed+0x104>)
   214b6:	781a      	ldrb	r2, [r3, #0]
   214b8:	2a00      	cmp	r2, #0
   214ba:	d12c      	bne.n	21516 <button_pressed+0xc6>
	{
	case STATE_WAITING:
		state = STATE_SCANNING;
   214bc:	2201      	movs	r2, #1
 * @req K-DWORK-001
 */
static inline int k_delayed_work_submit(struct k_delayed_work *work,
					s32_t delay)
{
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   214be:	4926      	ldr	r1, [pc, #152]	; (21558 <button_pressed+0x108>)
   214c0:	4826      	ldr	r0, [pc, #152]	; (2155c <button_pressed+0x10c>)
   214c2:	701a      	strb	r2, [r3, #0]
   214c4:	f016 fd10 	bl	37ee8 <k_delayed_work_submit_to_queue>
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   214c8:	4819      	ldr	r0, [pc, #100]	; (21530 <button_pressed+0xe0>)
   214ca:	f016 fb47 	bl	37b5c <z_spin_unlock_valid>
   214ce:	b968      	cbnz	r0, 214ec <button_pressed+0x9c>
   214d0:	235d      	movs	r3, #93	; 0x5d
   214d2:	4a18      	ldr	r2, [pc, #96]	; (21534 <button_pressed+0xe4>)
   214d4:	4922      	ldr	r1, [pc, #136]	; (21560 <button_pressed+0x110>)
   214d6:	4819      	ldr	r0, [pc, #100]	; (2153c <button_pressed+0xec>)
   214d8:	f01b f928 	bl	3c72c <printk>
   214dc:	4914      	ldr	r1, [pc, #80]	; (21530 <button_pressed+0xe0>)
   214de:	4821      	ldr	r0, [pc, #132]	; (21564 <button_pressed+0x114>)
   214e0:	f01b f924 	bl	3c72c <printk>
   214e4:	215d      	movs	r1, #93	; 0x5d
   214e6:	4813      	ldr	r0, [pc, #76]	; (21534 <button_pressed+0xe4>)
   214e8:	f01b f966 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   214ec:	f384 8811 	msr	BASEPRI, r4
   214f0:	f3bf 8f6f 	isb	sy
		__ASSERT_NO_MSG(false);
		break;
	}

	k_spin_unlock(&lock, key);
}
   214f4:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOTSUP;
	}

	return api->disable_callback(port, access_op, pin);
   214f6:	2100      	movs	r1, #0
   214f8:	221a      	movs	r2, #26
   214fa:	4798      	blx	r3
	for(size_t i = 0; (i < ARRAY_SIZE(button_pins)) && !err; i++)
   214fc:	4601      	mov	r1, r0
   214fe:	2800      	cmp	r0, #0
   21500:	d1ca      	bne.n	21498 <button_pressed+0x48>
			err = gpio_pin_disable_callback(button_devs[i], button_pins[i].number);
   21502:	6868      	ldr	r0, [r5, #4]
	if (api->disable_callback == NULL) {
   21504:	6843      	ldr	r3, [r0, #4]
   21506:	695b      	ldr	r3, [r3, #20]
   21508:	2b00      	cmp	r3, #0
   2150a:	d0c5      	beq.n	21498 <button_pressed+0x48>
	return api->disable_callback(port, access_op, pin);
   2150c:	220f      	movs	r2, #15
   2150e:	4798      	blx	r3
	if(err)
   21510:	2800      	cmp	r0, #0
   21512:	d0cf      	beq.n	214b4 <button_pressed+0x64>
   21514:	e7c0      	b.n	21498 <button_pressed+0x48>
		__ASSERT_NO_MSG(false);
   21516:	f44f 73ab 	mov.w	r3, #342	; 0x156
   2151a:	4a13      	ldr	r2, [pc, #76]	; (21568 <button_pressed+0x118>)
   2151c:	4913      	ldr	r1, [pc, #76]	; (2156c <button_pressed+0x11c>)
   2151e:	4807      	ldr	r0, [pc, #28]	; (2153c <button_pressed+0xec>)
   21520:	f01b f904 	bl	3c72c <printk>
   21524:	f44f 71ab 	mov.w	r1, #342	; 0x156
   21528:	480f      	ldr	r0, [pc, #60]	; (21568 <button_pressed+0x118>)
   2152a:	f01b f945 	bl	3c7b8 <assert_post_action>
		break;
   2152e:	e7cb      	b.n	214c8 <button_pressed+0x78>
   21530:	20020c60 	.word	0x20020c60
   21534:	000405cb 	.word	0x000405cb
   21538:	000405f1 	.word	0x000405f1
   2153c:	00040606 	.word	0x00040606
   21540:	00040623 	.word	0x00040623
   21544:	20020bd8 	.word	0x20020bd8
   21548:	0003f8d4 	.word	0x0003f8d4
   2154c:	0003f954 	.word	0x0003f954
   21550:	0004063b 	.word	0x0004063b
   21554:	2002b921 	.word	0x2002b921
   21558:	20020bf8 	.word	0x20020bf8
   2155c:	200297b4 	.word	0x200297b4
   21560:	00040665 	.word	0x00040665
   21564:	0004067c 	.word	0x0004067c
   21568:	00040654 	.word	0x00040654
   2156c:	00043e6b 	.word	0x00043e6b

00021570 <buttons_scan_fn>:
{
   21570:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   21574:	2500      	movs	r5, #0
   21576:	f8df 9214 	ldr.w	r9, [pc, #532]	; 2178c <buttons_scan_fn+0x21c>
	u32_t ret = 0;
   2157a:	462c      	mov	r4, r5
	for(size_t i = 0; i < ARRAY_SIZE(button_pins); i++)
   2157c:	46a8      	mov	r8, r5
   2157e:	464f      	mov	r7, r9
			ret |= 1U << i;
   21580:	f04f 0a01 	mov.w	sl, #1
   21584:	4e6a      	ldr	r6, [pc, #424]	; (21730 <buttons_scan_fn+0x1c0>)
		if(gpio_pin_read(button_devs[i], button_pins[i].number, &val))
   21586:	f859 0b04 	ldr.w	r0, [r9], #4
   2158a:	7932      	ldrb	r2, [r6, #4]
	return api->read(port, access_op, pin, value);
   2158c:	6843      	ldr	r3, [r0, #4]
   2158e:	2100      	movs	r1, #0
   21590:	f8d3 b008 	ldr.w	fp, [r3, #8]
   21594:	ab01      	add	r3, sp, #4
   21596:	47d8      	blx	fp
   21598:	2800      	cmp	r0, #0
   2159a:	d044      	beq.n	21626 <buttons_scan_fn+0xb6>
			LOG_INF("Cannot read gpio pin");
   2159c:	2303      	movs	r3, #3
   2159e:	f04f 0000 	mov.w	r0, #0
   215a2:	4a64      	ldr	r2, [pc, #400]	; (21734 <buttons_scan_fn+0x1c4>)
   215a4:	f363 0007 	bfi	r0, r3, #0, #8
   215a8:	4b63      	ldr	r3, [pc, #396]	; (21738 <buttons_scan_fn+0x1c8>)
   215aa:	4964      	ldr	r1, [pc, #400]	; (2173c <buttons_scan_fn+0x1cc>)
   215ac:	1a9b      	subs	r3, r3, r2
   215ae:	08db      	lsrs	r3, r3, #3
   215b0:	f363 108f 	bfi	r0, r3, #6, #10
   215b4:	f01b f911 	bl	3c7da <log_string_sync>
			return 0;
   215b8:	2400      	movs	r4, #0
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   215ba:	4b61      	ldr	r3, [pc, #388]	; (21740 <buttons_scan_fn+0x1d0>)
   215bc:	e8d3 2fef 	ldaex	r2, [r3]
   215c0:	e8c3 4fe1 	stlex	r1, r4, [r3]
   215c4:	2900      	cmp	r1, #0
   215c6:	d1f9      	bne.n	215bc <buttons_scan_fn+0x4c>
	if(!initial_run)
   215c8:	4b5e      	ldr	r3, [pc, #376]	; (21744 <buttons_scan_fn+0x1d4>)
   215ca:	4d5f      	ldr	r5, [pc, #380]	; (21748 <buttons_scan_fn+0x1d8>)
   215cc:	781a      	ldrb	r2, [r3, #0]
   215ce:	2a00      	cmp	r2, #0
   215d0:	d140      	bne.n	21654 <buttons_scan_fn+0xe4>
		if(button_scan != last_button_scan)
   215d2:	6829      	ldr	r1, [r5, #0]
   215d4:	42a1      	cmp	r1, r4
   215d6:	d00d      	beq.n	215f4 <buttons_scan_fn+0x84>
	if(button_handler_cb != NULL)
   215d8:	4b5c      	ldr	r3, [pc, #368]	; (2174c <buttons_scan_fn+0x1dc>)
   215da:	681b      	ldr	r3, [r3, #0]
   215dc:	b113      	cbz	r3, 215e4 <buttons_scan_fn+0x74>
		button_handler_cb(button_state, has_changed);
   215de:	4061      	eors	r1, r4
   215e0:	4620      	mov	r0, r4
   215e2:	4798      	blx	r3
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&mutex, *(uintptr_t *)&timeout, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
   215e4:	f04f 31ff 	mov.w	r1, #4294967295
   215e8:	4859      	ldr	r0, [pc, #356]	; (21750 <buttons_scan_fn+0x1e0>)
   215ea:	f014 fcfd 	bl	35fe8 <z_impl_k_mutex_lock>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_unlock(mutex);
   215ee:	4858      	ldr	r0, [pc, #352]	; (21750 <buttons_scan_fn+0x1e0>)
   215f0:	f014 fdd8 	bl	361a4 <z_impl_k_mutex_unlock>
	last_button_scan = button_scan;
   215f4:	602c      	str	r4, [r5, #0]
	if (button_scan != 0)
   215f6:	b384      	cbz	r4, 2165a <buttons_scan_fn+0xea>
   215f8:	220a      	movs	r2, #10
   215fa:	4956      	ldr	r1, [pc, #344]	; (21754 <buttons_scan_fn+0x1e4>)
   215fc:	4856      	ldr	r0, [pc, #344]	; (21758 <buttons_scan_fn+0x1e8>)
   215fe:	f016 fc73 	bl	37ee8 <k_delayed_work_submit_to_queue>
		if(err)
   21602:	b168      	cbz	r0, 21620 <buttons_scan_fn+0xb0>
			LOG_INF("Cannot add work to workqueue");
   21604:	2303      	movs	r3, #3
   21606:	f04f 0000 	mov.w	r0, #0
   2160a:	4a4a      	ldr	r2, [pc, #296]	; (21734 <buttons_scan_fn+0x1c4>)
   2160c:	f363 0007 	bfi	r0, r3, #0, #8
   21610:	4b49      	ldr	r3, [pc, #292]	; (21738 <buttons_scan_fn+0x1c8>)
   21612:	4952      	ldr	r1, [pc, #328]	; (2175c <buttons_scan_fn+0x1ec>)
   21614:	1a9b      	subs	r3, r3, r2
   21616:	08db      	lsrs	r3, r3, #3
   21618:	f363 108f 	bfi	r0, r3, #6, #10
			LOG_INF("Cannot enable callbacks");
   2161c:	f01b f8dd 	bl	3c7da <log_string_sync>
}
   21620:	b003      	add	sp, #12
   21622:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		switch(button_pins[i].active_flag)
   21626:	7973      	ldrb	r3, [r6, #5]
   21628:	b163      	cbz	r3, 21644 <buttons_scan_fn+0xd4>
			actived_low = false;
   2162a:	2b01      	cmp	r3, #1
   2162c:	bf08      	it	eq
   2162e:	2500      	moveq	r5, #0
		if((!val && actived_low)||
   21630:	9b01      	ldr	r3, [sp, #4]
   21632:	b94b      	cbnz	r3, 21648 <buttons_scan_fn+0xd8>
   21634:	b955      	cbnz	r5, 2164c <buttons_scan_fn+0xdc>
   21636:	3608      	adds	r6, #8
	for(size_t i = 0; i < ARRAY_SIZE(button_pins); i++)
   21638:	f1b8 0f00 	cmp.w	r8, #0
   2163c:	d1bd      	bne.n	215ba <buttons_scan_fn+0x4a>
   2163e:	f04f 0801 	mov.w	r8, #1
   21642:	e7a0      	b.n	21586 <buttons_scan_fn+0x16>
			actived_low = true;
   21644:	2501      	movs	r5, #1
   21646:	e7f3      	b.n	21630 <buttons_scan_fn+0xc0>
			(val && !actived_low))
   21648:	2d00      	cmp	r5, #0
   2164a:	d1f4      	bne.n	21636 <buttons_scan_fn+0xc6>
			ret |= 1U << i;
   2164c:	fa0a f308 	lsl.w	r3, sl, r8
   21650:	431c      	orrs	r4, r3
   21652:	e7f0      	b.n	21636 <buttons_scan_fn+0xc6>
		initial_run = false;
   21654:	2200      	movs	r2, #0
   21656:	701a      	strb	r2, [r3, #0]
   21658:	e7cc      	b.n	215f4 <buttons_scan_fn+0x84>
	__asm__ volatile(
   2165a:	f04f 0320 	mov.w	r3, #32
   2165e:	f3ef 8511 	mrs	r5, BASEPRI
   21662:	f383 8811 	msr	BASEPRI, r3
   21666:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2166a:	483d      	ldr	r0, [pc, #244]	; (21760 <buttons_scan_fn+0x1f0>)
   2166c:	f016 fa68 	bl	37b40 <z_spin_lock_valid>
   21670:	b968      	cbnz	r0, 2168e <buttons_scan_fn+0x11e>
   21672:	234a      	movs	r3, #74	; 0x4a
   21674:	4a3b      	ldr	r2, [pc, #236]	; (21764 <buttons_scan_fn+0x1f4>)
   21676:	493c      	ldr	r1, [pc, #240]	; (21768 <buttons_scan_fn+0x1f8>)
   21678:	483c      	ldr	r0, [pc, #240]	; (2176c <buttons_scan_fn+0x1fc>)
   2167a:	f01b f857 	bl	3c72c <printk>
   2167e:	4938      	ldr	r1, [pc, #224]	; (21760 <buttons_scan_fn+0x1f0>)
   21680:	483b      	ldr	r0, [pc, #236]	; (21770 <buttons_scan_fn+0x200>)
   21682:	f01b f853 	bl	3c72c <printk>
   21686:	214a      	movs	r1, #74	; 0x4a
   21688:	4836      	ldr	r0, [pc, #216]	; (21764 <buttons_scan_fn+0x1f4>)
   2168a:	f01b f895 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   2168e:	4834      	ldr	r0, [pc, #208]	; (21760 <buttons_scan_fn+0x1f0>)
   21690:	f016 fa74 	bl	37b7c <z_spin_lock_set_owner>
		switch (state)
   21694:	4b37      	ldr	r3, [pc, #220]	; (21774 <buttons_scan_fn+0x204>)
   21696:	781a      	ldrb	r2, [r3, #0]
   21698:	2a01      	cmp	r2, #1
   2169a:	d13b      	bne.n	21714 <buttons_scan_fn+0x1a4>
			state = STATE_WAITING;
   2169c:	2100      	movs	r1, #0
			err = gpio_pin_enable_callback(button_devs[i], button_pins[i].number);
   2169e:	6838      	ldr	r0, [r7, #0]
			state = STATE_WAITING;
   216a0:	7019      	strb	r1, [r3, #0]
	if (api->enable_callback == NULL) {
   216a2:	6843      	ldr	r3, [r0, #4]
   216a4:	691b      	ldr	r3, [r3, #16]
   216a6:	bb33      	cbnz	r3, 216f6 <buttons_scan_fn+0x186>
		return -ENOTSUP;
   216a8:	f06f 0485 	mvn.w	r4, #133	; 0x85
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   216ac:	482c      	ldr	r0, [pc, #176]	; (21760 <buttons_scan_fn+0x1f0>)
   216ae:	f016 fa55 	bl	37b5c <z_spin_unlock_valid>
   216b2:	b968      	cbnz	r0, 216d0 <buttons_scan_fn+0x160>
   216b4:	235d      	movs	r3, #93	; 0x5d
   216b6:	4a2b      	ldr	r2, [pc, #172]	; (21764 <buttons_scan_fn+0x1f4>)
   216b8:	492f      	ldr	r1, [pc, #188]	; (21778 <buttons_scan_fn+0x208>)
   216ba:	482c      	ldr	r0, [pc, #176]	; (2176c <buttons_scan_fn+0x1fc>)
   216bc:	f01b f836 	bl	3c72c <printk>
   216c0:	4927      	ldr	r1, [pc, #156]	; (21760 <buttons_scan_fn+0x1f0>)
   216c2:	482e      	ldr	r0, [pc, #184]	; (2177c <buttons_scan_fn+0x20c>)
   216c4:	f01b f832 	bl	3c72c <printk>
   216c8:	215d      	movs	r1, #93	; 0x5d
   216ca:	4826      	ldr	r0, [pc, #152]	; (21764 <buttons_scan_fn+0x1f4>)
   216cc:	f01b f874 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   216d0:	f385 8811 	msr	BASEPRI, r5
   216d4:	f3bf 8f6f 	isb	sy
		if(err)
   216d8:	2c00      	cmp	r4, #0
   216da:	d0a1      	beq.n	21620 <buttons_scan_fn+0xb0>
			LOG_INF("Cannot enable callbacks");
   216dc:	2303      	movs	r3, #3
   216de:	f04f 0000 	mov.w	r0, #0
   216e2:	4a14      	ldr	r2, [pc, #80]	; (21734 <buttons_scan_fn+0x1c4>)
   216e4:	f363 0007 	bfi	r0, r3, #0, #8
   216e8:	4b13      	ldr	r3, [pc, #76]	; (21738 <buttons_scan_fn+0x1c8>)
   216ea:	4925      	ldr	r1, [pc, #148]	; (21780 <buttons_scan_fn+0x210>)
   216ec:	1a9b      	subs	r3, r3, r2
   216ee:	08db      	lsrs	r3, r3, #3
   216f0:	f363 108f 	bfi	r0, r3, #6, #10
   216f4:	e792      	b.n	2161c <buttons_scan_fn+0xac>
	return api->enable_callback(port, access_op, pin);
   216f6:	221a      	movs	r2, #26
   216f8:	4798      	blx	r3
	for(size_t i = 0; (i < ARRAY_SIZE(button_pins)) && !err; i++)
   216fa:	4604      	mov	r4, r0
   216fc:	2800      	cmp	r0, #0
   216fe:	d1d5      	bne.n	216ac <buttons_scan_fn+0x13c>
			err = gpio_pin_enable_callback(button_devs[i], button_pins[i].number);
   21700:	6878      	ldr	r0, [r7, #4]
	if (api->enable_callback == NULL) {
   21702:	6843      	ldr	r3, [r0, #4]
   21704:	691b      	ldr	r3, [r3, #16]
   21706:	2b00      	cmp	r3, #0
   21708:	d0ce      	beq.n	216a8 <buttons_scan_fn+0x138>
	return api->enable_callback(port, access_op, pin);
   2170a:	4621      	mov	r1, r4
   2170c:	220f      	movs	r2, #15
   2170e:	4798      	blx	r3
   21710:	4604      	mov	r4, r0
   21712:	e7cb      	b.n	216ac <buttons_scan_fn+0x13c>
			__ASSERT_NO_MSG(false);
   21714:	f240 1311 	movw	r3, #273	; 0x111
   21718:	4a1a      	ldr	r2, [pc, #104]	; (21784 <buttons_scan_fn+0x214>)
   2171a:	491b      	ldr	r1, [pc, #108]	; (21788 <buttons_scan_fn+0x218>)
   2171c:	4813      	ldr	r0, [pc, #76]	; (2176c <buttons_scan_fn+0x1fc>)
   2171e:	f01b f805 	bl	3c72c <printk>
   21722:	f240 1111 	movw	r1, #273	; 0x111
   21726:	4817      	ldr	r0, [pc, #92]	; (21784 <buttons_scan_fn+0x214>)
   21728:	f01b f846 	bl	3c7b8 <assert_post_action>
		int err = 0;
   2172c:	2400      	movs	r4, #0
   2172e:	e7bd      	b.n	216ac <buttons_scan_fn+0x13c>
   21730:	0003fce8 	.word	0x0003fce8
   21734:	0003f8d4 	.word	0x0003f8d4
   21738:	0003f954 	.word	0x0003f954
   2173c:	00040691 	.word	0x00040691
   21740:	20020c64 	.word	0x20020c64
   21744:	200378e2 	.word	0x200378e2
   21748:	20020c58 	.word	0x20020c58
   2174c:	20020be0 	.word	0x20020be0
   21750:	20020be4 	.word	0x20020be4
   21754:	20020bf8 	.word	0x20020bf8
   21758:	200297b4 	.word	0x200297b4
   2175c:	000406a6 	.word	0x000406a6
   21760:	20020c60 	.word	0x20020c60
   21764:	000405cb 	.word	0x000405cb
   21768:	000405f1 	.word	0x000405f1
   2176c:	00040606 	.word	0x00040606
   21770:	00040623 	.word	0x00040623
   21774:	2002b921 	.word	0x2002b921
   21778:	00040665 	.word	0x00040665
   2177c:	0004067c 	.word	0x0004067c
   21780:	000406c3 	.word	0x000406c3
   21784:	00040654 	.word	0x00040654
   21788:	00043e6b 	.word	0x00043e6b
   2178c:	20020bd8 	.word	0x20020bd8

00021790 <key_init>:

	return 0;
}

void key_init(void)
{
   21790:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int err;

	LOG_INF("key_init\n");
   21792:	f04f 0000 	mov.w	r0, #0
   21796:	2303      	movs	r3, #3
   21798:	4d6a      	ldr	r5, [pc, #424]	; (21944 <key_init+0x1b4>)
   2179a:	f363 0007 	bfi	r0, r3, #0, #8
   2179e:	4b6a      	ldr	r3, [pc, #424]	; (21948 <key_init+0x1b8>)
   217a0:	496a      	ldr	r1, [pc, #424]	; (2194c <key_init+0x1bc>)
   217a2:	1aed      	subs	r5, r5, r3
   217a4:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   217a8:	f365 108f 	bfi	r0, r5, #6, #10
   217ac:	f01b f815 	bl	3c7da <log_string_sync>
	button_handler_cb = button_handler;
   217b0:	4b67      	ldr	r3, [pc, #412]	; (21950 <key_init+0x1c0>)
   217b2:	4a68      	ldr	r2, [pc, #416]	; (21954 <key_init+0x1c4>)
   217b4:	601a      	str	r2, [r3, #0]
	return z_impl_k_mutex_init(mutex);
   217b6:	4868      	ldr	r0, [pc, #416]	; (21958 <key_init+0x1c8>)
   217b8:	f01c fe93 	bl	3e4e2 <z_impl_k_mutex_init>
   217bc:	4867      	ldr	r0, [pc, #412]	; (2195c <key_init+0x1cc>)
   217be:	f013 ff2f 	bl	35620 <z_impl_device_get_binding>
		button_devs[i] = device_get_binding(button_pins[i].port);
   217c2:	4e67      	ldr	r6, [pc, #412]	; (21960 <key_init+0x1d0>)
   217c4:	6030      	str	r0, [r6, #0]
		if (!button_devs[i])
   217c6:	b350      	cbz	r0, 2181e <key_init+0x8e>
	return api->config(port, access_op, pin, flags);
   217c8:	6843      	ldr	r3, [r0, #4]
   217ca:	221a      	movs	r2, #26
   217cc:	681c      	ldr	r4, [r3, #0]
   217ce:	2100      	movs	r1, #0
   217d0:	f44f 7380 	mov.w	r3, #256	; 0x100
   217d4:	47a0      	blx	r4
		if(err)
   217d6:	4604      	mov	r4, r0
   217d8:	2800      	cmp	r0, #0
   217da:	d139      	bne.n	21850 <key_init+0xc0>
   217dc:	485f      	ldr	r0, [pc, #380]	; (2195c <key_init+0x1cc>)
   217de:	f013 ff1f 	bl	35620 <z_impl_device_get_binding>
		button_devs[i] = device_get_binding(button_pins[i].port);
   217e2:	6070      	str	r0, [r6, #4]
		if (!button_devs[i])
   217e4:	b1d8      	cbz	r0, 2181e <key_init+0x8e>
   217e6:	6843      	ldr	r3, [r0, #4]
   217e8:	4621      	mov	r1, r4
   217ea:	681f      	ldr	r7, [r3, #0]
   217ec:	220f      	movs	r2, #15
   217ee:	f44f 7380 	mov.w	r3, #256	; 0x100
   217f2:	47b8      	blx	r7
		if(err)
   217f4:	4604      	mov	r4, r0
   217f6:	bb58      	cbnz	r0, 21850 <key_init+0xc0>
		err = gpio_pin_configure(button_devs[i], button_pins[i].number, flags);
   217f8:	6830      	ldr	r0, [r6, #0]
   217fa:	6843      	ldr	r3, [r0, #4]
   217fc:	4621      	mov	r1, r4
   217fe:	681f      	ldr	r7, [r3, #0]
   21800:	221a      	movs	r2, #26
   21802:	f44f 7381 	mov.w	r3, #258	; 0x102
   21806:	47b8      	blx	r7
	for(size_t i = 0; (i < ARRAY_SIZE(button_pins)) && !err; i++)
   21808:	4604      	mov	r4, r0
   2180a:	b360      	cbz	r0, 21866 <key_init+0xd6>
		LOG_INF("Cannot set interrupt mode");
   2180c:	f04f 0000 	mov.w	r0, #0
   21810:	2303      	movs	r3, #3
   21812:	f363 0007 	bfi	r0, r3, #0, #8
   21816:	f365 108f 	bfi	r0, r5, #6, #10
   2181a:	4952      	ldr	r1, [pc, #328]	; (21964 <key_init+0x1d4>)
   2181c:	e020      	b.n	21860 <key_init+0xd0>
			LOG_INF("Cannot bind gpio device");
   2181e:	2303      	movs	r3, #3
   21820:	f04f 0000 	mov.w	r0, #0
   21824:	f363 0007 	bfi	r0, r3, #0, #8
   21828:	f365 108f 	bfi	r0, r5, #6, #10
   2182c:	494e      	ldr	r1, [pc, #312]	; (21968 <key_init+0x1d8>)
   2182e:	f01a ffd4 	bl	3c7da <log_string_sync>
			return -ENODEV;
   21832:	f06f 0412 	mvn.w	r4, #18
	
	err = buttons_init(button_handler);
	if (err)
	{
		LOG_INF("Could not initialize buttons, err code: %d\n", err);
   21836:	2303      	movs	r3, #3
   21838:	f04f 0000 	mov.w	r0, #0
   2183c:	f363 0007 	bfi	r0, r3, #0, #8
   21840:	f365 108f 	bfi	r0, r5, #6, #10
   21844:	4622      	mov	r2, r4
		return;
	}

	k_timer_init(&g_long_press_timer_id, long_press_timer_handler, NULL);
}
   21846:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		LOG_INF("Could not initialize buttons, err code: %d\n", err);
   2184a:	4948      	ldr	r1, [pc, #288]	; (2196c <key_init+0x1dc>)
   2184c:	f01a bfc5 	b.w	3c7da <log_string_sync>
			LOG_INF("Cannot configure button gpio");
   21850:	f04f 0000 	mov.w	r0, #0
   21854:	2303      	movs	r3, #3
   21856:	4946      	ldr	r1, [pc, #280]	; (21970 <key_init+0x1e0>)
   21858:	f363 0007 	bfi	r0, r3, #0, #8
   2185c:	f365 108f 	bfi	r0, r5, #6, #10
		LOG_INF("Cannot set interrupt mode");
   21860:	f01a ffbb 	bl	3c7da <log_string_sync>
		return err;
   21864:	e7e7      	b.n	21836 <key_init+0xa6>
		err = gpio_pin_configure(button_devs[i], button_pins[i].number, flags);
   21866:	6870      	ldr	r0, [r6, #4]
   21868:	6843      	ldr	r3, [r0, #4]
   2186a:	4621      	mov	r1, r4
   2186c:	681f      	ldr	r7, [r3, #0]
   2186e:	220f      	movs	r2, #15
   21870:	f44f 7381 	mov.w	r3, #258	; 0x102
   21874:	47b8      	blx	r7
	if(err)
   21876:	4604      	mov	r4, r0
   21878:	2800      	cmp	r0, #0
   2187a:	d1c7      	bne.n	2180c <key_init+0x7c>
		err = gpio_pin_disable_callback(button_devs[i], button_pins[i].number);
   2187c:	6830      	ldr	r0, [r6, #0]
	if (api->disable_callback == NULL) {
   2187e:	6843      	ldr	r3, [r0, #4]
   21880:	695b      	ldr	r3, [r3, #20]
   21882:	b313      	cbz	r3, 218ca <key_init+0x13a>
	return api->disable_callback(port, access_op, pin);
   21884:	4621      	mov	r1, r4
   21886:	221a      	movs	r2, #26
   21888:	4798      	blx	r3
		if(err)
   2188a:	4604      	mov	r4, r0
   2188c:	b9f8      	cbnz	r0, 218ce <key_init+0x13e>
		err = gpio_pin_disable_callback(button_devs[i], button_pins[i].number);
   2188e:	6870      	ldr	r0, [r6, #4]
	if (api->disable_callback == NULL) {
   21890:	6843      	ldr	r3, [r0, #4]
   21892:	695b      	ldr	r3, [r3, #20]
   21894:	b1cb      	cbz	r3, 218ca <key_init+0x13a>
	return api->disable_callback(port, access_op, pin);
   21896:	4621      	mov	r1, r4
   21898:	220f      	movs	r2, #15
   2189a:	4798      	blx	r3
		if(err)
   2189c:	4604      	mov	r4, r0
   2189e:	b9b0      	cbnz	r0, 218ce <key_init+0x13e>
				      u32_t pin_mask)
{
	__ASSERT(callback, "Callback pointer should not be NULL");
	__ASSERT(handler, "Callback handler pointer should not be NULL");

	callback->handler = handler;
   218a0:	4f34      	ldr	r7, [pc, #208]	; (21974 <key_init+0x1e4>)
   218a2:	4b35      	ldr	r3, [pc, #212]	; (21978 <key_init+0x1e8>)
		err = gpio_add_callback(button_devs[i], &gpio_cb);
   218a4:	6830      	ldr	r0, [r6, #0]
   218a6:	607b      	str	r3, [r7, #4]
	callback->pin_mask = pin_mask;
   218a8:	4b34      	ldr	r3, [pc, #208]	; (2197c <key_init+0x1ec>)
   218aa:	60bb      	str	r3, [r7, #8]
				    struct gpio_callback *callback)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	if (api->manage_callback == NULL) {
   218ac:	6843      	ldr	r3, [r0, #4]
   218ae:	68db      	ldr	r3, [r3, #12]
   218b0:	b143      	cbz	r3, 218c4 <key_init+0x134>
		return -ENOTSUP;
	}

	return api->manage_callback(port, callback, true);
   218b2:	2201      	movs	r2, #1
   218b4:	4639      	mov	r1, r7
   218b6:	4798      	blx	r3
		if(err)
   218b8:	4604      	mov	r4, r0
   218ba:	b9b0      	cbnz	r0, 218ea <key_init+0x15a>
		err = gpio_add_callback(button_devs[i], &gpio_cb);
   218bc:	6870      	ldr	r0, [r6, #4]
	if (api->manage_callback == NULL) {
   218be:	6843      	ldr	r3, [r0, #4]
   218c0:	68db      	ldr	r3, [r3, #12]
   218c2:	b96b      	cbnz	r3, 218e0 <key_init+0x150>
		return -ENOTSUP;
   218c4:	f06f 0485 	mvn.w	r4, #133	; 0x85
   218c8:	e00f      	b.n	218ea <key_init+0x15a>
		return -ENOTSUP;
   218ca:	f06f 0485 	mvn.w	r4, #133	; 0x85
			LOG_INF("Cannot disable callbacks()");
   218ce:	f04f 0000 	mov.w	r0, #0
   218d2:	2303      	movs	r3, #3
   218d4:	f363 0007 	bfi	r0, r3, #0, #8
   218d8:	f365 108f 	bfi	r0, r5, #6, #10
   218dc:	4928      	ldr	r1, [pc, #160]	; (21980 <key_init+0x1f0>)
   218de:	e7bf      	b.n	21860 <key_init+0xd0>
	return api->manage_callback(port, callback, true);
   218e0:	2201      	movs	r2, #1
   218e2:	4639      	mov	r1, r7
   218e4:	4798      	blx	r3
		if(err)
   218e6:	4604      	mov	r4, r0
   218e8:	b140      	cbz	r0, 218fc <key_init+0x16c>
			LOG_INF("Cannot add callback");
   218ea:	f04f 0000 	mov.w	r0, #0
   218ee:	2303      	movs	r3, #3
   218f0:	f363 0007 	bfi	r0, r3, #0, #8
   218f4:	f365 108f 	bfi	r0, r5, #6, #10
   218f8:	4922      	ldr	r1, [pc, #136]	; (21984 <key_init+0x1f4>)
   218fa:	e7b1      	b.n	21860 <key_init+0xd0>
	k_delayed_work_init(&buttons_scan, buttons_scan_fn);
   218fc:	4922      	ldr	r1, [pc, #136]	; (21988 <key_init+0x1f8>)
   218fe:	4823      	ldr	r0, [pc, #140]	; (2198c <key_init+0x1fc>)
   21900:	f01c fedb 	bl	3e6ba <k_delayed_work_init>
	state = STATE_SCANNING;
   21904:	2201      	movs	r2, #1
   21906:	4b22      	ldr	r3, [pc, #136]	; (21990 <key_init+0x200>)
   21908:	4920      	ldr	r1, [pc, #128]	; (2198c <key_init+0x1fc>)
   2190a:	701a      	strb	r2, [r3, #0]
   2190c:	4821      	ldr	r0, [pc, #132]	; (21994 <key_init+0x204>)
   2190e:	4622      	mov	r2, r4
   21910:	f016 faea 	bl	37ee8 <k_delayed_work_submit_to_queue>
	if(err)
   21914:	4604      	mov	r4, r0
   21916:	b140      	cbz	r0, 2192a <key_init+0x19a>
		LOG_INF("Cannot add work to workqueue");
   21918:	f04f 0000 	mov.w	r0, #0
   2191c:	2303      	movs	r3, #3
   2191e:	f363 0007 	bfi	r0, r3, #0, #8
   21922:	f365 108f 	bfi	r0, r5, #6, #10
   21926:	491c      	ldr	r1, [pc, #112]	; (21998 <key_init+0x208>)
   21928:	e79a      	b.n	21860 <key_init+0xd0>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2192a:	4b1c      	ldr	r3, [pc, #112]	; (2199c <key_init+0x20c>)
   2192c:	e8d3 2faf 	lda	r2, [r3]
	last_state = current_state;
   21930:	4b1b      	ldr	r3, [pc, #108]	; (219a0 <key_init+0x210>)
	k_timer_init(&g_long_press_timer_id, long_press_timer_handler, NULL);
   21932:	491c      	ldr	r1, [pc, #112]	; (219a4 <key_init+0x214>)
	last_state = current_state;
   21934:	601a      	str	r2, [r3, #0]
	k_timer_init(&g_long_press_timer_id, long_press_timer_handler, NULL);
   21936:	4602      	mov	r2, r0
}
   21938:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	k_timer_init(&g_long_press_timer_id, long_press_timer_handler, NULL);
   2193c:	481a      	ldr	r0, [pc, #104]	; (219a8 <key_init+0x218>)
   2193e:	f01c bed6 	b.w	3e6ee <k_timer_init>
   21942:	bf00      	nop
   21944:	0003f954 	.word	0x0003f954
   21948:	0003f8d4 	.word	0x0003f8d4
   2194c:	000406db 	.word	0x000406db
   21950:	20020be0 	.word	0x20020be0
   21954:	000213d9 	.word	0x000213d9
   21958:	20020be4 	.word	0x20020be4
   2195c:	0004053a 	.word	0x0004053a
   21960:	20020bd8 	.word	0x20020bd8
   21964:	0004071a 	.word	0x0004071a
   21968:	000406e5 	.word	0x000406e5
   2196c:	00040763 	.word	0x00040763
   21970:	000406fd 	.word	0x000406fd
   21974:	20020c44 	.word	0x20020c44
   21978:	00021451 	.word	0x00021451
   2197c:	04008000 	.word	0x04008000
   21980:	00040734 	.word	0x00040734
   21984:	0004074f 	.word	0x0004074f
   21988:	00021571 	.word	0x00021571
   2198c:	20020bf8 	.word	0x20020bf8
   21990:	2002b921 	.word	0x2002b921
   21994:	200297b4 	.word	0x200297b4
   21998:	000406a6 	.word	0x000406a6
   2199c:	20020c64 	.word	0x20020c64
   219a0:	20020c5c 	.word	0x20020c5c
   219a4:	000213c9 	.word	0x000213c9
   219a8:	20020c18 	.word	0x20020c18

000219ac <SaveSystemDateTime>:
	return err;
}

void SaveSystemDateTime(void)
{
	nvs_write(&fs, DATETIME_ID, &date_time, sizeof(sys_date_timer_t));
   219ac:	2308      	movs	r3, #8
   219ae:	4a02      	ldr	r2, [pc, #8]	; (219b8 <SaveSystemDateTime+0xc>)
   219b0:	2101      	movs	r1, #1
   219b2:	4802      	ldr	r0, [pc, #8]	; (219bc <SaveSystemDateTime+0x10>)
   219b4:	f005 bdb6 	b.w	27524 <nvs_write>
   219b8:	20029894 	.word	0x20029894
   219bc:	20020c68 	.word	0x20020c68

000219c0 <ResetSystemTime>:
}

void ResetSystemTime(void)
{
	memcpy(&date_time, &FACTORY_DEFAULT_TIME, sizeof(sys_date_timer_t));
   219c0:	4903      	ldr	r1, [pc, #12]	; (219d0 <ResetSystemTime+0x10>)
   219c2:	4a04      	ldr	r2, [pc, #16]	; (219d4 <ResetSystemTime+0x14>)
   219c4:	680b      	ldr	r3, [r1, #0]
   219c6:	6013      	str	r3, [r2, #0]
   219c8:	684b      	ldr	r3, [r1, #4]
   219ca:	6053      	str	r3, [r2, #4]
	SaveSystemDateTime();
   219cc:	f7ff bfee 	b.w	219ac <SaveSystemDateTime>
   219d0:	0004041c 	.word	0x0004041c
   219d4:	20029894 	.word	0x20029894

000219d8 <InitSystemDateTime>:
}

void InitSystemDateTime(void)
{
   219d8:	b513      	push	{r0, r1, r4, lr}
	int err = 0;
	sys_date_timer_t mytime = {0};
   219da:	2300      	movs	r3, #0
   219dc:	466c      	mov	r4, sp
   219de:	9300      	str	r3, [sp, #0]
   219e0:	6063      	str	r3, [r4, #4]

	err = nvs_read(&fs, DATETIME_ID, &date_time, sizeof(sys_date_timer_t));
   219e2:	4a15      	ldr	r2, [pc, #84]	; (21a38 <InitSystemDateTime+0x60>)
   219e4:	2308      	movs	r3, #8
   219e6:	2101      	movs	r1, #1
   219e8:	4814      	ldr	r0, [pc, #80]	; (21a3c <InitSystemDateTime+0x64>)
   219ea:	f01b f80b 	bl	3ca04 <nvs_read>
	if(err < 0)
   219ee:	1e02      	subs	r2, r0, #0
   219f0:	da0d      	bge.n	21a0e <InitSystemDateTime+0x36>
	{
		LOG_INF("get datetime err:%d\n", err);
   219f2:	2303      	movs	r3, #3
   219f4:	f04f 0000 	mov.w	r0, #0
   219f8:	4911      	ldr	r1, [pc, #68]	; (21a40 <InitSystemDateTime+0x68>)
   219fa:	f363 0007 	bfi	r0, r3, #0, #8
   219fe:	4b11      	ldr	r3, [pc, #68]	; (21a44 <InitSystemDateTime+0x6c>)
   21a00:	1a5b      	subs	r3, r3, r1
   21a02:	08db      	lsrs	r3, r3, #3
   21a04:	f363 108f 	bfi	r0, r3, #6, #10
   21a08:	490f      	ldr	r1, [pc, #60]	; (21a48 <InitSystemDateTime+0x70>)
   21a0a:	f01a fee6 	bl	3c7da <log_string_sync>
	}
	
	if(!CheckSystemDateTimeIsValid(mytime))
   21a0e:	e894 0003 	ldmia.w	r4, {r0, r1}
   21a12:	f018 ff83 	bl	3a91c <CheckSystemDateTimeIsValid>
   21a16:	b920      	cbnz	r0, 21a22 <InitSystemDateTime+0x4a>
	{
		memcpy(&mytime, &FACTORY_DEFAULT_TIME, sizeof(sys_date_timer_t));
   21a18:	4623      	mov	r3, r4
   21a1a:	4a0c      	ldr	r2, [pc, #48]	; (21a4c <InitSystemDateTime+0x74>)
   21a1c:	6810      	ldr	r0, [r2, #0]
   21a1e:	6851      	ldr	r1, [r2, #4]
   21a20:	c303      	stmia	r3!, {r0, r1}
	}
	memcpy(&date_time, &mytime, sizeof(sys_date_timer_t));
   21a22:	cc03      	ldmia	r4!, {r0, r1}
   21a24:	4b04      	ldr	r3, [pc, #16]	; (21a38 <InitSystemDateTime+0x60>)
   21a26:	6018      	str	r0, [r3, #0]
   21a28:	6059      	str	r1, [r3, #4]

	SaveSystemDateTime();
   21a2a:	f7ff ffbf 	bl	219ac <SaveSystemDateTime>
	StartSystemDateTime();
}
   21a2e:	b002      	add	sp, #8
   21a30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	StartSystemDateTime();
   21a34:	f7fe be34 	b.w	206a0 <StartSystemDateTime>
   21a38:	20029894 	.word	0x20029894
   21a3c:	20020c68 	.word	0x20020c68
   21a40:	0003f8d4 	.word	0x0003f8d4
   21a44:	0003f9c4 	.word	0x0003f9c4
   21a48:	00040793 	.word	0x00040793
   21a4c:	0004041c 	.word	0x0004041c

00021a50 <SaveSystemSettings>:

void SaveSystemSettings(void)
{
	nvs_write(&fs, SETTINGS_ID, &global_settings, sizeof(global_settings_t));
   21a50:	2330      	movs	r3, #48	; 0x30
   21a52:	4a02      	ldr	r2, [pc, #8]	; (21a5c <SaveSystemSettings+0xc>)
   21a54:	2102      	movs	r1, #2
   21a56:	4802      	ldr	r0, [pc, #8]	; (21a60 <SaveSystemSettings+0x10>)
   21a58:	f005 bd64 	b.w	27524 <nvs_write>
   21a5c:	200298a6 	.word	0x200298a6
   21a60:	20020c68 	.word	0x20020c68

00021a64 <ResetSystemSettings>:
}

void ResetSystemSettings(void)
{
	memcpy(&global_settings, &FACTORY_DEFAULT_SETTINGS, sizeof(global_settings_t));
   21a64:	4b05      	ldr	r3, [pc, #20]	; (21a7c <ResetSystemSettings+0x18>)
   21a66:	4a06      	ldr	r2, [pc, #24]	; (21a80 <ResetSystemSettings+0x1c>)
   21a68:	f103 0130 	add.w	r1, r3, #48	; 0x30
   21a6c:	f853 0b04 	ldr.w	r0, [r3], #4
   21a70:	428b      	cmp	r3, r1
   21a72:	f842 0b04 	str.w	r0, [r2], #4
   21a76:	d1f9      	bne.n	21a6c <ResetSystemSettings+0x8>
	SaveSystemSettings();
   21a78:	f7ff bfea 	b.w	21a50 <SaveSystemSettings>
   21a7c:	000403ec 	.word	0x000403ec
   21a80:	200298a6 	.word	0x200298a6

00021a84 <InitSystemSettings>:
}

void InitSystemSettings(void)
{
   21a84:	b570      	push	{r4, r5, r6, lr}
	int err;

	if(!nvs_init_flag)
   21a86:	4d2c      	ldr	r5, [pc, #176]	; (21b38 <InitSystemSettings+0xb4>)
   21a88:	782b      	ldrb	r3, [r5, #0]
   21a8a:	b9c3      	cbnz	r3, 21abe <InitSystemSettings+0x3a>
	fs.offset = DT_FLASH_AREA_STORAGE_OFFSET;	
   21a8c:	f44f 237a 	mov.w	r3, #1024000	; 0xfa000
   21a90:	4c2a      	ldr	r4, [pc, #168]	; (21b3c <InitSystemSettings+0xb8>)
   21a92:	6023      	str	r3, [r4, #0]
   21a94:	482a      	ldr	r0, [pc, #168]	; (21b40 <InitSystemSettings+0xbc>)
   21a96:	f013 fdc3 	bl	35620 <z_impl_device_get_binding>
	err = flash_get_page_info_by_offs(device_get_binding(DT_FLASH_DEV_NAME), fs.offset, &info);	
   21a9a:	6821      	ldr	r1, [r4, #0]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&offset, *(uintptr_t *)&info, K_SYSCALL_FLASH_GET_PAGE_INFO_BY_OFFS);
	}
#endif
	compiler_barrier();
	return z_impl_flash_get_page_info_by_offs(dev, offset, info);
   21a9c:	4e29      	ldr	r6, [pc, #164]	; (21b44 <InitSystemSettings+0xc0>)
   21a9e:	4632      	mov	r2, r6
   21aa0:	f01b fe42 	bl	3d728 <z_impl_flash_get_page_info_by_offs>
	if(err)
   21aa4:	2800      	cmp	r0, #0
   21aa6:	d136      	bne.n	21b16 <InitSystemSettings+0x92>
	fs.sector_size = info.size;
   21aa8:	6873      	ldr	r3, [r6, #4]
	err = nvs_init(&fs, DT_FLASH_DEV_NAME);
   21aaa:	4925      	ldr	r1, [pc, #148]	; (21b40 <InitSystemSettings+0xbc>)
	fs.sector_size = info.size;
   21aac:	81a3      	strh	r3, [r4, #12]
	fs.sector_count = 6U;
   21aae:	2306      	movs	r3, #6
	err = nvs_init(&fs, DT_FLASH_DEV_NAME);
   21ab0:	4620      	mov	r0, r4
	fs.sector_count = 6U;
   21ab2:	81e3      	strh	r3, [r4, #14]
	err = nvs_init(&fs, DT_FLASH_DEV_NAME);
   21ab4:	f005 fbcc 	bl	27250 <nvs_init>
	if(err)
   21ab8:	bb68      	cbnz	r0, 21b16 <InitSystemSettings+0x92>
	nvs_init_flag = true;
   21aba:	2301      	movs	r3, #1
   21abc:	702b      	strb	r3, [r5, #0]
			LOG_INF("Flash Init failed, return!\n");
			return;
		}
	}
	
	err = nvs_read(&fs, SETTINGS_ID, &global_settings, sizeof(global_settings_t));
   21abe:	4a22      	ldr	r2, [pc, #136]	; (21b48 <InitSystemSettings+0xc4>)
   21ac0:	2330      	movs	r3, #48	; 0x30
   21ac2:	2102      	movs	r1, #2
   21ac4:	481d      	ldr	r0, [pc, #116]	; (21b3c <InitSystemSettings+0xb8>)
   21ac6:	f01a ff9d 	bl	3ca04 <nvs_read>
	if(err < 0)
   21aca:	1e02      	subs	r2, r0, #0
   21acc:	da0d      	bge.n	21aea <InitSystemSettings+0x66>
	{
		LOG_INF("get settins err:%d\n", err);
   21ace:	2303      	movs	r3, #3
   21ad0:	f04f 0000 	mov.w	r0, #0
   21ad4:	491d      	ldr	r1, [pc, #116]	; (21b4c <InitSystemSettings+0xc8>)
   21ad6:	f363 0007 	bfi	r0, r3, #0, #8
   21ada:	4b1d      	ldr	r3, [pc, #116]	; (21b50 <InitSystemSettings+0xcc>)
   21adc:	1a5b      	subs	r3, r3, r1
   21ade:	08db      	lsrs	r3, r3, #3
   21ae0:	f363 108f 	bfi	r0, r3, #6, #10
   21ae4:	491b      	ldr	r1, [pc, #108]	; (21b54 <InitSystemSettings+0xd0>)
   21ae6:	f01a fe78 	bl	3c7da <log_string_sync>
	}

	if(!global_settings.init)
   21aea:	4b17      	ldr	r3, [pc, #92]	; (21b48 <InitSystemSettings+0xc4>)
   21aec:	781a      	ldrb	r2, [r3, #0]
   21aee:	b952      	cbnz	r2, 21b06 <InitSystemSettings+0x82>
	{
		memcpy(&global_settings, &FACTORY_DEFAULT_SETTINGS, sizeof(global_settings_t));
   21af0:	4a19      	ldr	r2, [pc, #100]	; (21b58 <InitSystemSettings+0xd4>)
   21af2:	f102 0130 	add.w	r1, r2, #48	; 0x30
   21af6:	f852 0b04 	ldr.w	r0, [r2], #4
   21afa:	428a      	cmp	r2, r1
   21afc:	f843 0b04 	str.w	r0, [r3], #4
   21b00:	d1f9      	bne.n	21af6 <InitSystemSettings+0x72>
		SaveSystemSettings();
   21b02:	f7ff ffa5 	bl	21a50 <SaveSystemSettings>
	}

	InitSystemDateTime();
   21b06:	f7ff ff67 	bl	219d8 <InitSystemDateTime>
	AlarmRemindInit();
   21b0a:	f7fe ffbd 	bl	20a88 <AlarmRemindInit>

	mmi_chset_init();
}
   21b0e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	mmi_chset_init();
   21b12:	f01a bb6b 	b.w	3c1ec <mmi_chset_init>
			LOG_INF("Flash Init failed, return!\n");
   21b16:	2303      	movs	r3, #3
}
   21b18:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			LOG_INF("Flash Init failed, return!\n");
   21b1c:	f04f 0000 	mov.w	r0, #0
   21b20:	4a0a      	ldr	r2, [pc, #40]	; (21b4c <InitSystemSettings+0xc8>)
   21b22:	f363 0007 	bfi	r0, r3, #0, #8
   21b26:	4b0a      	ldr	r3, [pc, #40]	; (21b50 <InitSystemSettings+0xcc>)
   21b28:	490c      	ldr	r1, [pc, #48]	; (21b5c <InitSystemSettings+0xd8>)
   21b2a:	1a9b      	subs	r3, r3, r2
   21b2c:	08db      	lsrs	r3, r3, #3
   21b2e:	f363 108f 	bfi	r0, r3, #6, #10
   21b32:	f01a be52 	b.w	3c7da <log_string_sync>
   21b36:	bf00      	nop
   21b38:	2002b925 	.word	0x2002b925
   21b3c:	20020c68 	.word	0x20020c68
   21b40:	000407a8 	.word	0x000407a8
   21b44:	20020c94 	.word	0x20020c94
   21b48:	200298a6 	.word	0x200298a6
   21b4c:	0003f8d4 	.word	0x0003f8d4
   21b50:	0003f9c4 	.word	0x0003f9c4
   21b54:	000407bb 	.word	0x000407bb
   21b58:	000403ec 	.word	0x000403ec
   21b5c:	000407cf 	.word	0x000407cf

00021b60 <SettingsMsgPorcess>:

void SettingsMsgPorcess(void)
{
   21b60:	b510      	push	{r4, lr}
	if(need_save_time)
   21b62:	4c0e      	ldr	r4, [pc, #56]	; (21b9c <SettingsMsgPorcess+0x3c>)
   21b64:	7823      	ldrb	r3, [r4, #0]
   21b66:	b11b      	cbz	r3, 21b70 <SettingsMsgPorcess+0x10>
	{
		SaveSystemDateTime();
   21b68:	f7ff ff20 	bl	219ac <SaveSystemDateTime>
		need_save_time = false;
   21b6c:	2300      	movs	r3, #0
   21b6e:	7023      	strb	r3, [r4, #0]
	}
	
	if(need_save_settings)
   21b70:	4b0b      	ldr	r3, [pc, #44]	; (21ba0 <SettingsMsgPorcess+0x40>)
   21b72:	781a      	ldrb	r2, [r3, #0]
   21b74:	b11a      	cbz	r2, 21b7e <SettingsMsgPorcess+0x1e>
	{
		need_save_settings = false;
   21b76:	2200      	movs	r2, #0
   21b78:	701a      	strb	r2, [r3, #0]
		SaveSystemSettings();
   21b7a:	f7ff ff69 	bl	21a50 <SaveSystemSettings>
	}

	if(need_reset_settings)
   21b7e:	4b09      	ldr	r3, [pc, #36]	; (21ba4 <SettingsMsgPorcess+0x44>)
   21b80:	781a      	ldrb	r2, [r3, #0]
   21b82:	b152      	cbz	r2, 21b9a <SettingsMsgPorcess+0x3a>
	{
		need_reset_settings = false;
   21b84:	2200      	movs	r2, #0
   21b86:	701a      	strb	r2, [r3, #0]
		ResetSystemSettings();
   21b88:	f7ff ff6c 	bl	21a64 <ResetSystemSettings>
		ResetSystemTime();
   21b8c:	f7ff ff18 	bl	219c0 <ResetSystemTime>

		lcd_sleep_out = true;
   21b90:	2301      	movs	r3, #1
   21b92:	4a05      	ldr	r2, [pc, #20]	; (21ba8 <SettingsMsgPorcess+0x48>)
   21b94:	7013      	strb	r3, [r2, #0]
		update_date_time = true;
   21b96:	4a05      	ldr	r2, [pc, #20]	; (21bac <SettingsMsgPorcess+0x4c>)
   21b98:	7013      	strb	r3, [r2, #0]
	}
}
   21b9a:	bd10      	pop	{r4, pc}
   21b9c:	2002b924 	.word	0x2002b924
   21ba0:	2002b923 	.word	0x2002b923
   21ba4:	2002b922 	.word	0x2002b922
   21ba8:	2002991f 	.word	0x2002991f
   21bac:	20029918 	.word	0x20029918

00021bb0 <SPI_Flash_Init>:
**   W25Q64FW,CSSPI
**   
** 
******************************************************************************/
void SPI_Flash_Init(void)
{
   21bb0:	b508      	push	{r3, lr}
   21bb2:	480e      	ldr	r0, [pc, #56]	; (21bec <SPI_Flash_Init+0x3c>)
   21bb4:	f013 fd34 	bl	35620 <z_impl_device_get_binding>
	spi_flash = device_get_binding(FLASH_DEVICE);
   21bb8:	4b0d      	ldr	r3, [pc, #52]	; (21bf0 <SPI_Flash_Init+0x40>)
   21bba:	6018      	str	r0, [r3, #0]
	if (!spi_flash) 
   21bbc:	b970      	cbnz	r0, 21bdc <SPI_Flash_Init+0x2c>
	{
		LOG_INF("Could not get %s device\n", FLASH_DEVICE);
   21bbe:	2303      	movs	r3, #3
   21bc0:	4a0c      	ldr	r2, [pc, #48]	; (21bf4 <SPI_Flash_Init+0x44>)
   21bc2:	f363 0007 	bfi	r0, r3, #0, #8
   21bc6:	4b0c      	ldr	r3, [pc, #48]	; (21bf8 <SPI_Flash_Init+0x48>)
   21bc8:	490c      	ldr	r1, [pc, #48]	; (21bfc <SPI_Flash_Init+0x4c>)
   21bca:	1a9b      	subs	r3, r3, r2
   21bcc:	08db      	lsrs	r3, r3, #3
   21bce:	f363 108f 	bfi	r0, r3, #6, #10
   21bd2:	4a06      	ldr	r2, [pc, #24]	; (21bec <SPI_Flash_Init+0x3c>)
	}

	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
	spi_cfg.frequency = 4000000;
	spi_cfg.slave = 0;
}
   21bd4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		LOG_INF("Could not get %s device\n", FLASH_DEVICE);
   21bd8:	f01a bdff 	b.w	3c7da <log_string_sync>
	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
   21bdc:	f44f 7280 	mov.w	r2, #256	; 0x100
	spi_cfg.frequency = 4000000;
   21be0:	4b07      	ldr	r3, [pc, #28]	; (21c00 <SPI_Flash_Init+0x50>)
	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
   21be2:	4908      	ldr	r1, [pc, #32]	; (21c04 <SPI_Flash_Init+0x54>)
   21be4:	e9c3 1200 	strd	r1, r2, [r3]
}
   21be8:	bd08      	pop	{r3, pc}
   21bea:	bf00      	nop
   21bec:	000407f4 	.word	0x000407f4
   21bf0:	20020cb0 	.word	0x20020cb0
   21bf4:	0003f8d4 	.word	0x0003f8d4
   21bf8:	0003f924 	.word	0x0003f924
   21bfc:	00040560 	.word	0x00040560
   21c00:	20020ca4 	.word	0x20020ca4
   21c04:	003d0900 	.word	0x003d0900

00021c08 <flash_init>:

void flash_init(void)
{
   21c08:	b538      	push	{r3, r4, r5, lr}
	LOG_INF("flash_init\n");
   21c0a:	f04f 0000 	mov.w	r0, #0
   21c0e:	2303      	movs	r3, #3
   21c10:	4c17      	ldr	r4, [pc, #92]	; (21c70 <flash_init+0x68>)
   21c12:	f363 0007 	bfi	r0, r3, #0, #8
   21c16:	4b17      	ldr	r3, [pc, #92]	; (21c74 <flash_init+0x6c>)
   21c18:	4917      	ldr	r1, [pc, #92]	; (21c78 <flash_init+0x70>)
   21c1a:	1ae4      	subs	r4, r4, r3
   21c1c:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   21c20:	f364 108f 	bfi	r0, r4, #6, #10
   21c24:	f01a fdd9 	bl	3c7da <log_string_sync>
   21c28:	4814      	ldr	r0, [pc, #80]	; (21c7c <flash_init+0x74>)
   21c2a:	f013 fcf9 	bl	35620 <z_impl_device_get_binding>
		
	gpio_flash = device_get_binding(FLASH_PORT);
   21c2e:	4d14      	ldr	r5, [pc, #80]	; (21c80 <flash_init+0x78>)
   21c30:	6028      	str	r0, [r5, #0]
	if(!gpio_flash)
   21c32:	b958      	cbnz	r0, 21c4c <flash_init+0x44>
	{
		LOG_INF("Cannot bind gpio device\n");
   21c34:	2303      	movs	r3, #3
   21c36:	f04f 0000 	mov.w	r0, #0
   21c3a:	f363 0007 	bfi	r0, r3, #0, #8
   21c3e:	f364 108f 	bfi	r0, r4, #6, #10
   21c42:	4910      	ldr	r1, [pc, #64]	; (21c84 <flash_init+0x7c>)

	gpio_pin_configure(gpio_flash, CS, GPIO_DIR_OUT);
	gpio_pin_write(gpio_flash, CS, 1);

	SPI_Flash_Init();
}
   21c44:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		LOG_INF("Cannot bind gpio device\n");
   21c48:	f01a bdc7 	b.w	3c7da <log_string_sync>
	return api->config(port, access_op, pin, flags);
   21c4c:	6843      	ldr	r3, [r0, #4]
   21c4e:	2202      	movs	r2, #2
   21c50:	681c      	ldr	r4, [r3, #0]
   21c52:	2100      	movs	r1, #0
   21c54:	2301      	movs	r3, #1
   21c56:	47a0      	blx	r4
	gpio_pin_write(gpio_flash, CS, 1);
   21c58:	6828      	ldr	r0, [r5, #0]
	return api->write(port, access_op, pin, value);
   21c5a:	6843      	ldr	r3, [r0, #4]
   21c5c:	2202      	movs	r2, #2
   21c5e:	685c      	ldr	r4, [r3, #4]
   21c60:	2100      	movs	r1, #0
   21c62:	2301      	movs	r3, #1
   21c64:	47a0      	blx	r4
}
   21c66:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	SPI_Flash_Init();
   21c6a:	f7ff bfa1 	b.w	21bb0 <SPI_Flash_Init>
   21c6e:	bf00      	nop
   21c70:	0003f924 	.word	0x0003f924
   21c74:	0003f8d4 	.word	0x0003f8d4
   21c78:	000407fa 	.word	0x000407fa
   21c7c:	0004053a 	.word	0x0004053a
   21c80:	20020ca0 	.word	0x20020ca0
   21c84:	00040541 	.word	0x00040541

00021c88 <ble_connect_or_disconnect_handle>:
extern bool app_find_device;

static void MCU_send_heart_rate(void);

void ble_connect_or_disconnect_handle(u8_t *buf, u32_t len)
{
   21c88:	b510      	push	{r4, lr}
	LOG_INF("BLE status:%x\n", buf[6]);
   21c8a:	2303      	movs	r3, #3
{
   21c8c:	4604      	mov	r4, r0
	LOG_INF("BLE status:%x\n", buf[6]);
   21c8e:	f04f 0000 	mov.w	r0, #0
   21c92:	4a09      	ldr	r2, [pc, #36]	; (21cb8 <ble_connect_or_disconnect_handle+0x30>)
   21c94:	f363 0007 	bfi	r0, r3, #0, #8
   21c98:	4b08      	ldr	r3, [pc, #32]	; (21cbc <ble_connect_or_disconnect_handle+0x34>)
   21c9a:	4909      	ldr	r1, [pc, #36]	; (21cc0 <ble_connect_or_disconnect_handle+0x38>)
   21c9c:	1a9b      	subs	r3, r3, r2
   21c9e:	08db      	lsrs	r3, r3, #3
   21ca0:	f363 108f 	bfi	r0, r3, #6, #10
   21ca4:	79a2      	ldrb	r2, [r4, #6]
   21ca6:	f01a fd98 	bl	3c7da <log_string_sync>
	
	if(buf[6] == 0x01)				//control
   21caa:	79a2      	ldrb	r2, [r4, #6]
   21cac:	4b05      	ldr	r3, [pc, #20]	; (21cc4 <ble_connect_or_disconnect_handle+0x3c>)
   21cae:	2a01      	cmp	r2, #1
		BLE_is_connected = true;
	else if(buf[6] == 0x00)
		BLE_is_connected = false;
   21cb0:	bf18      	it	ne
   21cb2:	2200      	movne	r2, #0
   21cb4:	701a      	strb	r2, [r3, #0]
	else
		BLE_is_connected = false;
}
   21cb6:	bd10      	pop	{r4, pc}
   21cb8:	0003f8d4 	.word	0x0003f8d4
   21cbc:	0003f9e4 	.word	0x0003f9e4
   21cc0:	000408e0 	.word	0x000408e0
   21cc4:	2002b927 	.word	0x2002b927

00021cc8 <CTP_notify_handle>:

void CTP_notify_handle(u8_t *buf, u32_t len)
{
   21cc8:	b530      	push	{r4, r5, lr}
   21cca:	b0a5      	sub	sp, #148	; 0x94
   21ccc:	4604      	mov	r4, r0
	u8_t tmpbuf[128] = {0};
   21cce:	2280      	movs	r2, #128	; 0x80
   21cd0:	2100      	movs	r1, #0
   21cd2:	a804      	add	r0, sp, #16
   21cd4:	f01c fdda 	bl	3e88c <memset>
	u8_t tp_type = TP_EVENT_MAX;
	u16_t tp_x,tp_y;
	
	LOG_INF("%x,%x,%x,%x,%x,%x\n",buf[5],buf[6],buf[7],buf[8],buf[9],buf[10]);
   21cd8:	2303      	movs	r3, #3
   21cda:	f04f 0000 	mov.w	r0, #0
   21cde:	4a2e      	ldr	r2, [pc, #184]	; (21d98 <CTP_notify_handle+0xd0>)
   21ce0:	f363 0007 	bfi	r0, r3, #0, #8
   21ce4:	4b2d      	ldr	r3, [pc, #180]	; (21d9c <CTP_notify_handle+0xd4>)
   21ce6:	492e      	ldr	r1, [pc, #184]	; (21da0 <CTP_notify_handle+0xd8>)
   21ce8:	1a9b      	subs	r3, r3, r2
   21cea:	08db      	lsrs	r3, r3, #3
   21cec:	f363 108f 	bfi	r0, r3, #6, #10
   21cf0:	7aa3      	ldrb	r3, [r4, #10]
   21cf2:	7962      	ldrb	r2, [r4, #5]
   21cf4:	9303      	str	r3, [sp, #12]
   21cf6:	7a63      	ldrb	r3, [r4, #9]
   21cf8:	9302      	str	r3, [sp, #8]
   21cfa:	7a23      	ldrb	r3, [r4, #8]
   21cfc:	9301      	str	r3, [sp, #4]
   21cfe:	79e3      	ldrb	r3, [r4, #7]
   21d00:	9300      	str	r3, [sp, #0]
   21d02:	79a3      	ldrb	r3, [r4, #6]
   21d04:	f01a fd69 	bl	3c7da <log_string_sync>
	switch(buf[5])
   21d08:	7965      	ldrb	r5, [r4, #5]
   21d0a:	2d0c      	cmp	r5, #12
   21d0c:	d80c      	bhi.n	21d28 <CTP_notify_handle+0x60>
   21d0e:	e8df f005 	tbb	[pc, r5]
   21d12:	2007      	.short	0x2007
   21d14:	312b250d 	.word	0x312b250d
   21d18:	0b0b0b0b 	.word	0x0b0b0b0b
   21d1c:	370b      	.short	0x370b
   21d1e:	3d          	.byte	0x3d
   21d1f:	00          	.byte	0x00
	{
	case GESTURE_NONE:
		sprintf(tmpbuf, "GESTURE_NONE        ");
   21d20:	4920      	ldr	r1, [pc, #128]	; (21da4 <CTP_notify_handle+0xdc>)
   21d22:	a804      	add	r0, sp, #16
   21d24:	f01c ff1b 	bl	3eb5e <strcpy>
	{
		tp_x = buf[7]*0x100+buf[8];
		tp_y = buf[9]*0x100+buf[10];
		touch_panel_event_handle(tp_type, tp_x, tp_y);
	}
}
   21d28:	b025      	add	sp, #148	; 0x94
   21d2a:	bd30      	pop	{r4, r5, pc}
		sprintf(tmpbuf, "MOVING_UP   ");
   21d2c:	491e      	ldr	r1, [pc, #120]	; (21da8 <CTP_notify_handle+0xe0>)
   21d2e:	a804      	add	r0, sp, #16
   21d30:	f01c ff15 	bl	3eb5e <strcpy>
		tp_type = TP_EVENT_MOVING_UP;
   21d34:	2500      	movs	r5, #0
		tp_y = buf[9]*0x100+buf[10];
   21d36:	7a63      	ldrb	r3, [r4, #9]
   21d38:	7aa2      	ldrb	r2, [r4, #10]
		tp_x = buf[7]*0x100+buf[8];
   21d3a:	7a21      	ldrb	r1, [r4, #8]
		tp_y = buf[9]*0x100+buf[10];
   21d3c:	eb02 2203 	add.w	r2, r2, r3, lsl #8
		tp_x = buf[7]*0x100+buf[8];
   21d40:	79e3      	ldrb	r3, [r4, #7]
		touch_panel_event_handle(tp_type, tp_x, tp_y);
   21d42:	b292      	uxth	r2, r2
		tp_x = buf[7]*0x100+buf[8];
   21d44:	eb01 2103 	add.w	r1, r1, r3, lsl #8
		touch_panel_event_handle(tp_type, tp_x, tp_y);
   21d48:	b289      	uxth	r1, r1
   21d4a:	4628      	mov	r0, r5
   21d4c:	f002 f80c 	bl	23d68 <touch_panel_event_handle>
}
   21d50:	e7ea      	b.n	21d28 <CTP_notify_handle+0x60>
		sprintf(tmpbuf, "MOVING_DOWN ");
   21d52:	4916      	ldr	r1, [pc, #88]	; (21dac <CTP_notify_handle+0xe4>)
   21d54:	a804      	add	r0, sp, #16
   21d56:	f01c ff02 	bl	3eb5e <strcpy>
	if(tp_type != TP_EVENT_MAX)
   21d5a:	e7ec      	b.n	21d36 <CTP_notify_handle+0x6e>
		sprintf(tmpbuf, "MOVING_LEFT ");
   21d5c:	4914      	ldr	r1, [pc, #80]	; (21db0 <CTP_notify_handle+0xe8>)
   21d5e:	a804      	add	r0, sp, #16
   21d60:	f01c fefd 	bl	3eb5e <strcpy>
		tp_type = TP_EVENT_MOVING_LEFT;
   21d64:	2502      	movs	r5, #2
   21d66:	e7e6      	b.n	21d36 <CTP_notify_handle+0x6e>
		sprintf(tmpbuf, "MOVING_RIGHT");
   21d68:	4912      	ldr	r1, [pc, #72]	; (21db4 <CTP_notify_handle+0xec>)
   21d6a:	a804      	add	r0, sp, #16
   21d6c:	f01c fef7 	bl	3eb5e <strcpy>
		tp_type = TP_EVENT_MOVING_RIGHT;
   21d70:	2503      	movs	r5, #3
   21d72:	e7e0      	b.n	21d36 <CTP_notify_handle+0x6e>
		sprintf(tmpbuf, "SINGLE_CLICK");
   21d74:	4910      	ldr	r1, [pc, #64]	; (21db8 <CTP_notify_handle+0xf0>)
   21d76:	a804      	add	r0, sp, #16
   21d78:	f01c fef1 	bl	3eb5e <strcpy>
		tp_type = TP_EVENT_SINGLE_CLICK;
   21d7c:	2504      	movs	r5, #4
   21d7e:	e7da      	b.n	21d36 <CTP_notify_handle+0x6e>
		sprintf(tmpbuf, "DOUBLE_CLICK");
   21d80:	490e      	ldr	r1, [pc, #56]	; (21dbc <CTP_notify_handle+0xf4>)
   21d82:	a804      	add	r0, sp, #16
   21d84:	f01c feeb 	bl	3eb5e <strcpy>
		tp_type = TP_EVENT_DOUBLE_CLICK;
   21d88:	2505      	movs	r5, #5
   21d8a:	e7d4      	b.n	21d36 <CTP_notify_handle+0x6e>
		sprintf(tmpbuf, "LONG_PRESS  ");
   21d8c:	490c      	ldr	r1, [pc, #48]	; (21dc0 <CTP_notify_handle+0xf8>)
   21d8e:	a804      	add	r0, sp, #16
   21d90:	f01c fee5 	bl	3eb5e <strcpy>
		tp_type = TP_EVENT_LONG_PRESS;
   21d94:	2506      	movs	r5, #6
   21d96:	e7ce      	b.n	21d36 <CTP_notify_handle+0x6e>
   21d98:	0003f8d4 	.word	0x0003f8d4
   21d9c:	0003f9e4 	.word	0x0003f9e4
   21da0:	0004085d 	.word	0x0004085d
   21da4:	00040870 	.word	0x00040870
   21da8:	00040885 	.word	0x00040885
   21dac:	00040892 	.word	0x00040892
   21db0:	0004089f 	.word	0x0004089f
   21db4:	000408ac 	.word	0x000408ac
   21db8:	000408b9 	.word	0x000408b9
   21dbc:	000408c6 	.word	0x000408c6
   21dc0:	000408d3 	.word	0x000408d3

00021dc4 <APP_reply_find_phone>:
	ble_send_date_handle(reply, reply_len);
}

//APP
void APP_reply_find_phone(u8_t *buf, u32_t len)
{
   21dc4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	u32_t i;

	LOG_INF("APP_reply_find_phone\n");
   21dc8:	2303      	movs	r3, #3
{
   21dca:	4680      	mov	r8, r0
	LOG_INF("APP_reply_find_phone\n");
   21dcc:	f04f 0000 	mov.w	r0, #0
   21dd0:	4c12      	ldr	r4, [pc, #72]	; (21e1c <APP_reply_find_phone+0x58>)
   21dd2:	f363 0007 	bfi	r0, r3, #0, #8
   21dd6:	4b12      	ldr	r3, [pc, #72]	; (21e20 <APP_reply_find_phone+0x5c>)
{
   21dd8:	460f      	mov	r7, r1
	LOG_INF("APP_reply_find_phone\n");
   21dda:	1ae4      	subs	r4, r4, r3
   21ddc:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   21de0:	f364 108f 	bfi	r0, r4, #6, #10
   21de4:	490f      	ldr	r1, [pc, #60]	; (21e24 <APP_reply_find_phone+0x60>)
   21de6:	f01a fcf8 	bl	3c7da <log_string_sync>
	
	for(i=0;i<len;i++)
   21dea:	2500      	movs	r5, #0
	{
		LOG_INF("i:%d, data:%02X\n", i, buf[i]);
   21dec:	f8df 9038 	ldr.w	r9, [pc, #56]	; 21e28 <APP_reply_find_phone+0x64>
	for(i=0;i<len;i++)
   21df0:	42af      	cmp	r7, r5
   21df2:	d101      	bne.n	21df8 <APP_reply_find_phone+0x34>
	}
}
   21df4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		LOG_INF("i:%d, data:%02X\n", i, buf[i]);
   21df8:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   21dfc:	f043 0303 	orr.w	r3, r3, #3
   21e00:	f363 0607 	bfi	r6, r3, #0, #8
   21e04:	f364 168f 	bfi	r6, r4, #6, #10
   21e08:	f818 3005 	ldrb.w	r3, [r8, r5]
   21e0c:	462a      	mov	r2, r5
   21e0e:	4649      	mov	r1, r9
   21e10:	4630      	mov	r0, r6
   21e12:	f01a fce2 	bl	3c7da <log_string_sync>
	for(i=0;i<len;i++)
   21e16:	3501      	adds	r5, #1
   21e18:	e7ea      	b.n	21df0 <APP_reply_find_phone+0x2c>
   21e1a:	bf00      	nop
   21e1c:	0003f9e4 	.word	0x0003f9e4
   21e20:	0003f8d4 	.word	0x0003f8d4
   21e24:	00040815 	.word	0x00040815
   21e28:	0004082b 	.word	0x0004082b

00021e2c <get_nrf52810_ver_response>:

void get_nrf52810_ver_response(u8_t *buf, u32_t len)
{
	u32_t i;

	for(i=0;i<len-9;i++)
   21e2c:	4401      	add	r1, r0
   21e2e:	4a0c      	ldr	r2, [pc, #48]	; (21e60 <get_nrf52810_ver_response+0x34>)
   21e30:	1d83      	adds	r3, r0, #6
   21e32:	3903      	subs	r1, #3
   21e34:	428b      	cmp	r3, r1
   21e36:	d10e      	bne.n	21e56 <get_nrf52810_ver_response+0x2a>
	{
		str_nrf52810_ver[i] = buf[7+i];
	}

	LOG_INF("str_nrf52810_ver:%s\n", str_nrf52810_ver);
   21e38:	2303      	movs	r3, #3
   21e3a:	f04f 0000 	mov.w	r0, #0
   21e3e:	4a09      	ldr	r2, [pc, #36]	; (21e64 <get_nrf52810_ver_response+0x38>)
   21e40:	f363 0007 	bfi	r0, r3, #0, #8
   21e44:	4b08      	ldr	r3, [pc, #32]	; (21e68 <get_nrf52810_ver_response+0x3c>)
   21e46:	4909      	ldr	r1, [pc, #36]	; (21e6c <get_nrf52810_ver_response+0x40>)
   21e48:	1a9b      	subs	r3, r3, r2
   21e4a:	08db      	lsrs	r3, r3, #3
   21e4c:	f363 108f 	bfi	r0, r3, #6, #10
   21e50:	4a03      	ldr	r2, [pc, #12]	; (21e60 <get_nrf52810_ver_response+0x34>)
   21e52:	f01a bcc2 	b.w	3c7da <log_string_sync>
		str_nrf52810_ver[i] = buf[7+i];
   21e56:	f813 0f01 	ldrb.w	r0, [r3, #1]!
   21e5a:	f802 0b01 	strb.w	r0, [r2], #1
   21e5e:	e7e9      	b.n	21e34 <get_nrf52810_ver_response+0x8>
   21e60:	2002bd2e 	.word	0x2002bd2e
   21e64:	0003f8d4 	.word	0x0003f8d4
   21e68:	0003f9e4 	.word	0x0003f9e4
   21e6c:	000409a8 	.word	0x000409a8

00021e70 <get_ble_mac_address_response>:
}

void get_ble_mac_address_response(u8_t *buf, u32_t len)
{
   21e70:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   21e72:	4912      	ldr	r1, [pc, #72]	; (21ebc <get_ble_mac_address_response+0x4c>)
   21e74:	1d83      	adds	r3, r0, #6
   21e76:	460a      	mov	r2, r1
   21e78:	300c      	adds	r0, #12
	u32_t i;

	for(i=0;i<6;i++)
	{
		ble_mac_addr[i] = buf[7+i];
   21e7a:	f813 4f01 	ldrb.w	r4, [r3, #1]!
	for(i=0;i<6;i++)
   21e7e:	4283      	cmp	r3, r0
		ble_mac_addr[i] = buf[7+i];
   21e80:	f801 4b01 	strb.w	r4, [r1], #1
	for(i=0;i<6;i++)
   21e84:	d1f9      	bne.n	21e7a <get_ble_mac_address_response+0xa>
	}

	LOG_INF("ble_mac_addr %02X:%02X:%02X:%02X:%02X:%02X\n",
   21e86:	2303      	movs	r3, #3
   21e88:	f04f 0000 	mov.w	r0, #0
   21e8c:	490c      	ldr	r1, [pc, #48]	; (21ec0 <get_ble_mac_address_response+0x50>)
   21e8e:	f363 0007 	bfi	r0, r3, #0, #8
   21e92:	4b0c      	ldr	r3, [pc, #48]	; (21ec4 <get_ble_mac_address_response+0x54>)
   21e94:	1a5b      	subs	r3, r3, r1
   21e96:	08db      	lsrs	r3, r3, #3
   21e98:	f363 108f 	bfi	r0, r3, #6, #10
   21e9c:	7953      	ldrb	r3, [r2, #5]
   21e9e:	490a      	ldr	r1, [pc, #40]	; (21ec8 <get_ble_mac_address_response+0x58>)
   21ea0:	9303      	str	r3, [sp, #12]
   21ea2:	7913      	ldrb	r3, [r2, #4]
   21ea4:	9302      	str	r3, [sp, #8]
   21ea6:	78d3      	ldrb	r3, [r2, #3]
   21ea8:	9301      	str	r3, [sp, #4]
   21eaa:	7893      	ldrb	r3, [r2, #2]
   21eac:	9300      	str	r3, [sp, #0]
   21eae:	7853      	ldrb	r3, [r2, #1]
   21eb0:	7812      	ldrb	r2, [r2, #0]
   21eb2:	f01a fc92 	bl	3c7da <log_string_sync>
							ble_mac_addr[2],
							ble_mac_addr[3],
							ble_mac_addr[4],
							ble_mac_addr[5]
							);
}
   21eb6:	b004      	add	sp, #16
   21eb8:	bd10      	pop	{r4, pc}
   21eba:	bf00      	nop
   21ebc:	2002b928 	.word	0x2002b928
   21ec0:	0003f8d4 	.word	0x0003f8d4
   21ec4:	0003f9e4 	.word	0x0003f9e4
   21ec8:	0004096d 	.word	0x0004096d

00021ecc <get_ble_status_response>:

void get_ble_status_response(u8_t *buf, u32_t len)
{
   21ecc:	b510      	push	{r4, lr}
	LOG_INF("BLE_status:%d\n", buf[6]);
   21ece:	2303      	movs	r3, #3
{
   21ed0:	4604      	mov	r4, r0
	LOG_INF("BLE_status:%d\n", buf[6]);
   21ed2:	f04f 0000 	mov.w	r0, #0
   21ed6:	4a08      	ldr	r2, [pc, #32]	; (21ef8 <get_ble_status_response+0x2c>)
   21ed8:	f363 0007 	bfi	r0, r3, #0, #8
   21edc:	4b07      	ldr	r3, [pc, #28]	; (21efc <get_ble_status_response+0x30>)
   21ede:	4908      	ldr	r1, [pc, #32]	; (21f00 <get_ble_status_response+0x34>)
   21ee0:	1a9b      	subs	r3, r3, r2
   21ee2:	08db      	lsrs	r3, r3, #3
   21ee4:	f363 108f 	bfi	r0, r3, #6, #10
   21ee8:	79a2      	ldrb	r2, [r4, #6]
   21eea:	f01a fc76 	bl	3c7da <log_string_sync>

	g_ble_status = buf[6];
   21eee:	79a2      	ldrb	r2, [r4, #6]
   21ef0:	4b04      	ldr	r3, [pc, #16]	; (21f04 <get_ble_status_response+0x38>)
   21ef2:	701a      	strb	r2, [r3, #0]
}
   21ef4:	bd10      	pop	{r4, pc}
   21ef6:	bf00      	nop
   21ef8:	0003f8d4 	.word	0x0003f8d4
   21efc:	0003f9e4 	.word	0x0003f9e4
   21f00:	00040999 	.word	0x00040999
   21f04:	200378e3 	.word	0x200378e3

00021f08 <ble_send_date_handle>:
		break;
	}
}

void ble_send_date_handle(u8_t *buf, u32_t len)
{
   21f08:	b570      	push	{r4, r5, r6, lr}
	LOG_INF("ble_send_date_handle\n");
   21f0a:	2303      	movs	r3, #3
{
   21f0c:	4605      	mov	r5, r0
	LOG_INF("ble_send_date_handle\n");
   21f0e:	f04f 0000 	mov.w	r0, #0
{
   21f12:	460e      	mov	r6, r1
   21f14:	4a0a      	ldr	r2, [pc, #40]	; (21f40 <ble_send_date_handle+0x38>)
	LOG_INF("ble_send_date_handle\n");
   21f16:	f363 0007 	bfi	r0, r3, #0, #8
   21f1a:	4b0a      	ldr	r3, [pc, #40]	; (21f44 <ble_send_date_handle+0x3c>)

	uart_fifo_fill(uart_ble, buf, len);
   21f1c:	4c0a      	ldr	r4, [pc, #40]	; (21f48 <ble_send_date_handle+0x40>)
   21f1e:	1a9b      	subs	r3, r3, r2
   21f20:	08db      	lsrs	r3, r3, #3
	LOG_INF("ble_send_date_handle\n");
   21f22:	f363 108f 	bfi	r0, r3, #6, #10
   21f26:	4909      	ldr	r1, [pc, #36]	; (21f4c <ble_send_date_handle+0x44>)
   21f28:	f01a fc57 	bl	3c7da <log_string_sync>
	uart_fifo_fill(uart_ble, buf, len);
   21f2c:	4632      	mov	r2, r6
   21f2e:	4629      	mov	r1, r5
   21f30:	6820      	ldr	r0, [r4, #0]
   21f32:	f018 fda6 	bl	3aa82 <uart_fifo_fill>
	uart_irq_tx_enable(uart_ble); 
   21f36:	6820      	ldr	r0, [r4, #0]
}
   21f38:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		arch_syscall_invoke1(*(uintptr_t *)&dev, K_SYSCALL_UART_IRQ_TX_ENABLE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_tx_enable(dev);
   21f3c:	f018 bda7 	b.w	3aa8e <z_impl_uart_irq_tx_enable>
   21f40:	0003f8d4 	.word	0x0003f8d4
   21f44:	0003f9e4 	.word	0x0003f9e4
   21f48:	20020cb8 	.word	0x20020cb8
   21f4c:	00040957 	.word	0x00040957

00021f50 <APP_set_find_device>:
{
   21f50:	b500      	push	{lr}
   21f52:	b0a1      	sub	sp, #132	; 0x84
	u8_t reply[128] = {0};
   21f54:	2100      	movs	r1, #0
   21f56:	2280      	movs	r2, #128	; 0x80
   21f58:	4668      	mov	r0, sp
   21f5a:	f01c fc97 	bl	3e88c <memset>
	reply[reply_len++] = PACKET_HEAD;
   21f5e:	23ab      	movs	r3, #171	; 0xab
   21f60:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   21f64:	f64f 7306 	movw	r3, #65286	; 0xff06
   21f68:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(FIND_DEVICE_ID&0x00ff);
   21f6c:	f248 0337 	movw	r3, #32823	; 0x8037
   21f70:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   21f74:	2388      	movs	r3, #136	; 0x88
   21f76:	4669      	mov	r1, sp
   21f78:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   21f7c:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   21f7e:	f811 2b01 	ldrb.w	r2, [r1], #1
   21f82:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   21f86:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   21f88:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   21f8a:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   21f8c:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   21f90:	d1f5      	bne.n	21f7e <APP_set_find_device+0x2e>
	ble_send_date_handle(reply, reply_len);
   21f92:	2109      	movs	r1, #9
   21f94:	4668      	mov	r0, sp
   21f96:	f7ff ffb7 	bl	21f08 <ble_send_date_handle>
	app_find_device = true;	
   21f9a:	2201      	movs	r2, #1
   21f9c:	4b02      	ldr	r3, [pc, #8]	; (21fa8 <APP_set_find_device+0x58>)
   21f9e:	701a      	strb	r2, [r3, #0]
}
   21fa0:	b021      	add	sp, #132	; 0x84
   21fa2:	f85d fb04 	ldr.w	pc, [sp], #4
   21fa6:	bf00      	nop
   21fa8:	2002991a 	.word	0x2002991a

00021fac <APP_set_language>:
{
   21fac:	b510      	push	{r4, lr}
   21fae:	4604      	mov	r4, r0
   21fb0:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   21fb2:	2280      	movs	r2, #128	; 0x80
   21fb4:	2100      	movs	r1, #0
   21fb6:	4668      	mov	r0, sp
   21fb8:	f01c fc68 	bl	3e88c <memset>
	if(buf[7] == 0x00)
   21fbc:	79e2      	ldrb	r2, [r4, #7]
   21fbe:	4b1b      	ldr	r3, [pc, #108]	; (2202c <APP_set_language+0x80>)
   21fc0:	bb7a      	cbnz	r2, 22022 <APP_set_language+0x76>
		global_settings.language = LANGUAGE_CHN;
   21fc2:	2201      	movs	r2, #1
		global_settings.language = LANGUAGE_JPN;
   21fc4:	725a      	strb	r2, [r3, #9]
	reply[reply_len++] = PACKET_HEAD;
   21fc6:	23ab      	movs	r3, #171	; 0xab
   21fc8:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   21fcc:	f64f 7306 	movw	r3, #65286	; 0xff06
   21fd0:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(LANGUAGE_SETTING_ID&0x00ff);
   21fd4:	f248 0345 	movw	r3, #32837	; 0x8045
   21fd8:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   21fdc:	2388      	movs	r3, #136	; 0x88
   21fde:	4669      	mov	r1, sp
   21fe0:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   21fe4:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   21fe6:	f811 2b01 	ldrb.w	r2, [r1], #1
   21fea:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   21fee:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   21ff0:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   21ff2:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   21ff4:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   21ff8:	d1f5      	bne.n	21fe6 <APP_set_language+0x3a>
	ble_send_date_handle(reply, reply_len);
   21ffa:	2109      	movs	r1, #9
   21ffc:	4668      	mov	r0, sp
   21ffe:	f7ff ff83 	bl	21f08 <ble_send_date_handle>
	if(screen_id == SCREEN_ID_IDLE)
   22002:	4b0b      	ldr	r3, [pc, #44]	; (22030 <APP_set_language+0x84>)
   22004:	781b      	ldrb	r3, [r3, #0]
   22006:	2b01      	cmp	r3, #1
   22008:	d106      	bne.n	22018 <APP_set_language+0x6c>
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_WEEK;
   2200a:	4b0a      	ldr	r3, [pc, #40]	; (22034 <APP_set_language+0x88>)
   2200c:	68da      	ldr	r2, [r3, #12]
   2200e:	f042 0210 	orr.w	r2, r2, #16
   22012:	60da      	str	r2, [r3, #12]
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   22014:	2202      	movs	r2, #2
   22016:	725a      	strb	r2, [r3, #9]
	need_save_settings = true;
   22018:	2201      	movs	r2, #1
   2201a:	4b07      	ldr	r3, [pc, #28]	; (22038 <APP_set_language+0x8c>)
   2201c:	701a      	strb	r2, [r3, #0]
}
   2201e:	b020      	add	sp, #128	; 0x80
   22020:	bd10      	pop	{r4, pc}
	else if(buf[7] == 0x01)
   22022:	2a02      	cmp	r2, #2
		global_settings.language = LANGUAGE_EN;
   22024:	bf18      	it	ne
   22026:	2200      	movne	r2, #0
   22028:	e7cc      	b.n	21fc4 <APP_set_language+0x18>
   2202a:	bf00      	nop
   2202c:	200298a6 	.word	0x200298a6
   22030:	2002c382 	.word	0x2002c382
   22034:	200249ec 	.word	0x200249ec
   22038:	2002b923 	.word	0x2002b923

0002203c <APP_set_time_24_format>:
{
   2203c:	b510      	push	{r4, lr}
   2203e:	4604      	mov	r4, r0
   22040:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   22042:	2280      	movs	r2, #128	; 0x80
   22044:	2100      	movs	r1, #0
   22046:	4668      	mov	r0, sp
   22048:	f01c fc20 	bl	3e88c <memset>
	if(buf[7] == 0x00)
   2204c:	79e2      	ldrb	r2, [r4, #7]
   2204e:	4b19      	ldr	r3, [pc, #100]	; (220b4 <APP_set_time_24_format+0x78>)
   22050:	2a01      	cmp	r2, #1
		global_settings.time_format = TIME_FORMAT_24;//24 format
   22052:	bf18      	it	ne
   22054:	2200      	movne	r2, #0
		global_settings.time_format = TIME_FORMAT_12;//12 format
   22056:	721a      	strb	r2, [r3, #8]
	reply[reply_len++] = PACKET_HEAD;
   22058:	23ab      	movs	r3, #171	; 0xab
   2205a:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   2205e:	f64f 7306 	movw	r3, #65286	; 0xff06
   22062:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(TIME_24_SETTING_ID&0x00ff);
   22066:	f248 0346 	movw	r3, #32838	; 0x8046
   2206a:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   2206e:	2388      	movs	r3, #136	; 0x88
   22070:	4669      	mov	r1, sp
   22072:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   22076:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   22078:	f811 2b01 	ldrb.w	r2, [r1], #1
   2207c:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   22080:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   22082:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   22084:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   22086:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   2208a:	d1f5      	bne.n	22078 <APP_set_time_24_format+0x3c>
	ble_send_date_handle(reply, reply_len);
   2208c:	2109      	movs	r1, #9
   2208e:	4668      	mov	r0, sp
   22090:	f7ff ff3a 	bl	21f08 <ble_send_date_handle>
	if(screen_id == SCREEN_ID_IDLE)
   22094:	4b08      	ldr	r3, [pc, #32]	; (220b8 <APP_set_time_24_format+0x7c>)
   22096:	781b      	ldrb	r3, [r3, #0]
   22098:	2b01      	cmp	r3, #1
   2209a:	d106      	bne.n	220aa <APP_set_time_24_format+0x6e>
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_TIME;
   2209c:	4b07      	ldr	r3, [pc, #28]	; (220bc <APP_set_time_24_format+0x80>)
   2209e:	68da      	ldr	r2, [r3, #12]
   220a0:	f042 0204 	orr.w	r2, r2, #4
   220a4:	60da      	str	r2, [r3, #12]
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   220a6:	2202      	movs	r2, #2
   220a8:	725a      	strb	r2, [r3, #9]
	need_save_settings = true;	
   220aa:	2201      	movs	r2, #1
   220ac:	4b04      	ldr	r3, [pc, #16]	; (220c0 <APP_set_time_24_format+0x84>)
   220ae:	701a      	strb	r2, [r3, #0]
}
   220b0:	b020      	add	sp, #128	; 0x80
   220b2:	bd10      	pop	{r4, pc}
   220b4:	200298a6 	.word	0x200298a6
   220b8:	2002c382 	.word	0x2002c382
   220bc:	200249ec 	.word	0x200249ec
   220c0:	2002b923 	.word	0x2002b923

000220c4 <APP_set_date_format>:
{
   220c4:	b510      	push	{r4, lr}
   220c6:	4604      	mov	r4, r0
   220c8:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   220ca:	2280      	movs	r2, #128	; 0x80
   220cc:	2100      	movs	r1, #0
   220ce:	4668      	mov	r0, sp
   220d0:	f01c fbdc 	bl	3e88c <memset>
	if(buf[7] == 0x00)
   220d4:	79e3      	ldrb	r3, [r4, #7]
   220d6:	4a1b      	ldr	r2, [pc, #108]	; (22144 <APP_set_date_format+0x80>)
   220d8:	bb7b      	cbnz	r3, 2213a <APP_set_date_format+0x76>
		global_settings.date_format = DATE_FORMAT_YYYYMMDD;
   220da:	2300      	movs	r3, #0
		global_settings.date_format = DATE_FORMAT_DDMMYYYY;
   220dc:	7293      	strb	r3, [r2, #10]
	reply[reply_len++] = PACKET_HEAD;
   220de:	23ab      	movs	r3, #171	; 0xab
   220e0:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   220e4:	f64f 7306 	movw	r3, #65286	; 0xff06
   220e8:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(DATE_FORMAT_ID&0x00ff);
   220ec:	f248 0356 	movw	r3, #32854	; 0x8056
   220f0:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   220f4:	2388      	movs	r3, #136	; 0x88
   220f6:	4669      	mov	r1, sp
   220f8:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   220fc:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   220fe:	f811 2b01 	ldrb.w	r2, [r1], #1
   22102:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   22106:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   22108:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   2210a:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   2210c:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   22110:	d1f5      	bne.n	220fe <APP_set_date_format+0x3a>
	ble_send_date_handle(reply, reply_len);
   22112:	2109      	movs	r1, #9
   22114:	4668      	mov	r0, sp
   22116:	f7ff fef7 	bl	21f08 <ble_send_date_handle>
	if(screen_id == SCREEN_ID_IDLE)
   2211a:	4b0b      	ldr	r3, [pc, #44]	; (22148 <APP_set_date_format+0x84>)
   2211c:	781b      	ldrb	r3, [r3, #0]
   2211e:	2b01      	cmp	r3, #1
   22120:	d106      	bne.n	22130 <APP_set_date_format+0x6c>
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_DATE;
   22122:	4b0a      	ldr	r3, [pc, #40]	; (2214c <APP_set_date_format+0x88>)
   22124:	68da      	ldr	r2, [r3, #12]
   22126:	f042 0208 	orr.w	r2, r2, #8
   2212a:	60da      	str	r2, [r3, #12]
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   2212c:	2202      	movs	r2, #2
   2212e:	725a      	strb	r2, [r3, #9]
	need_save_settings = true;
   22130:	2201      	movs	r2, #1
   22132:	4b07      	ldr	r3, [pc, #28]	; (22150 <APP_set_date_format+0x8c>)
   22134:	701a      	strb	r2, [r3, #0]
}
   22136:	b020      	add	sp, #128	; 0x80
   22138:	bd10      	pop	{r4, pc}
	else if(buf[7] == 0x01)
   2213a:	2b01      	cmp	r3, #1
   2213c:	d0ce      	beq.n	220dc <APP_set_date_format+0x18>
	else if(buf[7] == 0x02)
   2213e:	2b02      	cmp	r3, #2
   22140:	d1cb      	bne.n	220da <APP_set_date_format+0x16>
   22142:	e7cb      	b.n	220dc <APP_set_date_format+0x18>
   22144:	200298a6 	.word	0x200298a6
   22148:	2002c382 	.word	0x2002c382
   2214c:	200249ec 	.word	0x200249ec
   22150:	2002b923 	.word	0x2002b923

00022154 <APP_set_date_time>:
{
   22154:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   22158:	4604      	mov	r4, r0
   2215a:	b0a2      	sub	sp, #136	; 0x88
	u8_t reply[128] = {0};
   2215c:	2100      	movs	r1, #0
   2215e:	2280      	movs	r2, #128	; 0x80
   22160:	a802      	add	r0, sp, #8
   22162:	f01c fb93 	bl	3e88c <memset>
	datetime.year = 256*buf[7]+buf[8];
   22166:	79e3      	ldrb	r3, [r4, #7]
   22168:	7a25      	ldrb	r5, [r4, #8]
	datetime.month = buf[9];
   2216a:	f894 9009 	ldrb.w	r9, [r4, #9]
	datetime.year = 256*buf[7]+buf[8];
   2216e:	eb05 2503 	add.w	r5, r5, r3, lsl #8
	if(CheckSystemDateTimeIsValid(datetime))
   22172:	2300      	movs	r3, #0
	datetime.day = buf[10];
   22174:	f894 800a 	ldrb.w	r8, [r4, #10]
	datetime.hour = buf[11];
   22178:	7ae7      	ldrb	r7, [r4, #11]
	datetime.minute = buf[12];
   2217a:	7b26      	ldrb	r6, [r4, #12]
	datetime.second = buf[13];
   2217c:	f894 a00d 	ldrb.w	sl, [r4, #13]
	if(CheckSystemDateTimeIsValid(datetime))
   22180:	466c      	mov	r4, sp
	datetime.year = 256*buf[7]+buf[8];
   22182:	b2ad      	uxth	r5, r5
	if(CheckSystemDateTimeIsValid(datetime))
   22184:	f8ad 5000 	strh.w	r5, [sp]
   22188:	f88d 9002 	strb.w	r9, [sp, #2]
   2218c:	f88d 8003 	strb.w	r8, [sp, #3]
   22190:	f88d 7004 	strb.w	r7, [sp, #4]
   22194:	f88d 6005 	strb.w	r6, [sp, #5]
   22198:	f88d a006 	strb.w	sl, [sp, #6]
   2219c:	f88d 3007 	strb.w	r3, [sp, #7]
   221a0:	e894 0003 	ldmia.w	r4, {r0, r1}
   221a4:	f018 fbba 	bl	3a91c <CheckSystemDateTimeIsValid>
   221a8:	b1e0      	cbz	r0, 221e4 <APP_set_date_time+0x90>
		datetime.week = GetWeekDayByDate(datetime);
   221aa:	e894 0003 	ldmia.w	r4, {r0, r1}
   221ae:	f018 fb5d 	bl	3a86c <GetWeekDayByDate>
		memcpy(&date_time, &datetime, sizeof(sys_date_timer_t));
   221b2:	4b1a      	ldr	r3, [pc, #104]	; (2221c <APP_set_date_time+0xc8>)
   221b4:	801d      	strh	r5, [r3, #0]
   221b6:	f883 9002 	strb.w	r9, [r3, #2]
   221ba:	f883 8003 	strb.w	r8, [r3, #3]
   221be:	711f      	strb	r7, [r3, #4]
   221c0:	715e      	strb	r6, [r3, #5]
   221c2:	f883 a006 	strb.w	sl, [r3, #6]
		datetime.week = GetWeekDayByDate(datetime);
   221c6:	71d8      	strb	r0, [r3, #7]
		if(screen_id == SCREEN_ID_IDLE)
   221c8:	4b15      	ldr	r3, [pc, #84]	; (22220 <APP_set_date_time+0xcc>)
   221ca:	781b      	ldrb	r3, [r3, #0]
   221cc:	2b01      	cmp	r3, #1
   221ce:	d106      	bne.n	221de <APP_set_date_time+0x8a>
			scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_TIME|SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);
   221d0:	4b14      	ldr	r3, [pc, #80]	; (22224 <APP_set_date_time+0xd0>)
   221d2:	68da      	ldr	r2, [r3, #12]
   221d4:	f042 021c 	orr.w	r2, r2, #28
   221d8:	60da      	str	r2, [r3, #12]
			scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   221da:	2202      	movs	r2, #2
   221dc:	725a      	strb	r2, [r3, #9]
		need_save_time = true;
   221de:	2201      	movs	r2, #1
   221e0:	4b11      	ldr	r3, [pc, #68]	; (22228 <APP_set_date_time+0xd4>)
   221e2:	701a      	strb	r2, [r3, #0]
	reply[reply_len++] = (u8_t)(TIME_SYNC_ID&0x00ff);
   221e4:	f248 0349 	movw	r3, #32841	; 0x8049
   221e8:	4a10      	ldr	r2, [pc, #64]	; (2222c <APP_set_date_time+0xd8>)
   221ea:	a902      	add	r1, sp, #8
   221ec:	e9cd 2302 	strd	r2, r3, [sp, #8]
	reply[reply_len++] = PACKET_END;
   221f0:	2388      	movs	r3, #136	; 0x88
   221f2:	f88d 3010 	strb.w	r3, [sp, #16]
	for(i=0;i<(reply_len-2);i++)
   221f6:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   221f8:	f811 2b01 	ldrb.w	r2, [r1], #1
   221fc:	f89d 000f 	ldrb.w	r0, [sp, #15]
	for(i=0;i<(reply_len-2);i++)
   22200:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   22202:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   22204:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   22206:	f88d 200f 	strb.w	r2, [sp, #15]
	for(i=0;i<(reply_len-2);i++)
   2220a:	d1f5      	bne.n	221f8 <APP_set_date_time+0xa4>
	ble_send_date_handle(reply, reply_len);	
   2220c:	2109      	movs	r1, #9
   2220e:	a802      	add	r0, sp, #8
   22210:	f7ff fe7a 	bl	21f08 <ble_send_date_handle>
}
   22214:	b022      	add	sp, #136	; 0x88
   22216:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2221a:	bf00      	nop
   2221c:	20029894 	.word	0x20029894
   22220:	2002c382 	.word	0x2002c382
   22224:	200249ec 	.word	0x200249ec
   22228:	2002b924 	.word	0x2002b924
   2222c:	ff0600ab 	.word	0xff0600ab

00022230 <APP_set_alarm>:
{
   22230:	b510      	push	{r4, lr}
   22232:	b0a2      	sub	sp, #136	; 0x88
   22234:	4604      	mov	r4, r0
	u8_t result=0,reply[128] = {0};
   22236:	2280      	movs	r2, #128	; 0x80
   22238:	2100      	movs	r1, #0
   2223a:	a802      	add	r0, sp, #8
   2223c:	f01c fb26 	bl	3e88c <memset>
	alarm_infor_t infor = {0};
   22240:	2300      	movs	r3, #0
   22242:	9301      	str	r3, [sp, #4]
	index = buf[7];
   22244:	79e3      	ldrb	r3, [r4, #7]
	if(index <= 7)
   22246:	2b07      	cmp	r3, #7
   22248:	d921      	bls.n	2228e <APP_set_alarm+0x5e>
	u8_t result=0,reply[128] = {0};
   2224a:	2300      	movs	r3, #0
	reply[reply_len++] = PACKET_HEAD;
   2224c:	22ab      	movs	r2, #171	; 0xab
   2224e:	f88d 2008 	strb.w	r2, [sp, #8]
	reply[reply_len++] = 0x06;
   22252:	f64f 7206 	movw	r2, #65286	; 0xff06
	reply[reply_len++] = result;
   22256:	f88d 300d 	strb.w	r3, [sp, #13]
	reply[reply_len++] = PACKET_END;
   2225a:	2388      	movs	r3, #136	; 0x88
	reply[reply_len++] = 0x06;
   2225c:	f8ad 200a 	strh.w	r2, [sp, #10]
	reply[reply_len++] = (u8_t)(ALARM_SETTING_ID&0x00ff);
   22260:	2239      	movs	r2, #57	; 0x39
	reply[reply_len++] = PACKET_END;
   22262:	f88d 3010 	strb.w	r3, [sp, #16]
	for(i=0;i<(reply_len-2);i++)
   22266:	2300      	movs	r3, #0
	reply[reply_len++] = (u8_t)(ALARM_SETTING_ID&0x00ff);
   22268:	f88d 200c 	strb.w	r2, [sp, #12]
	for(i=0;i<(reply_len-2);i++)
   2226c:	a902      	add	r1, sp, #8
		reply[reply_len-2] += reply[i];
   2226e:	f811 2b01 	ldrb.w	r2, [r1], #1
   22272:	f89d 000f 	ldrb.w	r0, [sp, #15]
	for(i=0;i<(reply_len-2);i++)
   22276:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   22278:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   2227a:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   2227c:	f88d 200f 	strb.w	r2, [sp, #15]
	for(i=0;i<(reply_len-2);i++)
   22280:	d1f5      	bne.n	2226e <APP_set_alarm+0x3e>
	ble_send_date_handle(reply, reply_len);	
   22282:	2109      	movs	r1, #9
   22284:	a802      	add	r0, sp, #8
   22286:	f7ff fe3f 	bl	21f08 <ble_send_date_handle>
}
   2228a:	b022      	add	sp, #136	; 0x88
   2228c:	bd10      	pop	{r4, pc}
		infor.is_on = buf[8];	//on\off
   2228e:	7a22      	ldrb	r2, [r4, #8]
		infor.hour = buf[9];	//hour
   22290:	7a60      	ldrb	r0, [r4, #9]
		infor.is_on = buf[8];	//on\off
   22292:	3200      	adds	r2, #0
   22294:	bf18      	it	ne
   22296:	2201      	movne	r2, #1
		infor.minute = buf[10];//minute
   22298:	7aa1      	ldrb	r1, [r4, #10]
		infor.is_on = buf[8];	//on\off
   2229a:	f88d 2004 	strb.w	r2, [sp, #4]
		infor.repeat = buf[11];//repeat from monday to sunday, for example:0x1111100 means repeat in workday
   2229e:	7ae2      	ldrb	r2, [r4, #11]
		if((buf[9]<=23)&&(buf[10]<=59)&&(buf[11]<=0x7f))
   222a0:	2817      	cmp	r0, #23
		infor.hour = buf[9];	//hour
   222a2:	f88d 0005 	strb.w	r0, [sp, #5]
		infor.minute = buf[10];//minute
   222a6:	f88d 1006 	strb.w	r1, [sp, #6]
		infor.repeat = buf[11];//repeat from monday to sunday, for example:0x1111100 means repeat in workday
   222aa:	f88d 2007 	strb.w	r2, [sp, #7]
		if((buf[9]<=23)&&(buf[10]<=59)&&(buf[11]<=0x7f))
   222ae:	d8cc      	bhi.n	2224a <APP_set_alarm+0x1a>
   222b0:	293b      	cmp	r1, #59	; 0x3b
   222b2:	d8ca      	bhi.n	2224a <APP_set_alarm+0x1a>
   222b4:	0612      	lsls	r2, r2, #24
   222b6:	d4c8      	bmi.n	2224a <APP_set_alarm+0x1a>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   222b8:	4a04      	ldr	r2, [pc, #16]	; (222cc <APP_set_alarm+0x9c>)
   222ba:	9901      	ldr	r1, [sp, #4]
			memcpy((alarm_infor_t*)&global_settings.alarm[index], (alarm_infor_t*)&infor, sizeof(alarm_infor_t));
   222bc:	3304      	adds	r3, #4
   222be:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
			need_save_settings = true;
   222c2:	2201      	movs	r2, #1
   222c4:	4b02      	ldr	r3, [pc, #8]	; (222d0 <APP_set_alarm+0xa0>)
   222c6:	701a      	strb	r2, [r3, #0]
			result = 0x80;
   222c8:	2380      	movs	r3, #128	; 0x80
   222ca:	e7bf      	b.n	2224c <APP_set_alarm+0x1c>
   222cc:	200298a6 	.word	0x200298a6
   222d0:	2002b923 	.word	0x2002b923

000222d4 <APP_set_PHD_interval>:
{
   222d4:	b510      	push	{r4, lr}
   222d6:	4604      	mov	r4, r0
   222d8:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   222da:	2280      	movs	r2, #128	; 0x80
   222dc:	2100      	movs	r1, #0
   222de:	4668      	mov	r0, sp
   222e0:	f01c fad4 	bl	3e88c <memset>
	if(buf[6] == 1)
   222e4:	79a3      	ldrb	r3, [r4, #6]
   222e6:	4a16      	ldr	r2, [pc, #88]	; (22340 <APP_set_PHD_interval+0x6c>)
   222e8:	1e59      	subs	r1, r3, #1
   222ea:	424b      	negs	r3, r1
   222ec:	414b      	adcs	r3, r1
   222ee:	7393      	strb	r3, [r2, #14]
	global_settings.phd_infor.interval = buf[7];
   222f0:	79e3      	ldrb	r3, [r4, #7]
	need_save_settings = true;
   222f2:	4c14      	ldr	r4, [pc, #80]	; (22344 <APP_set_PHD_interval+0x70>)
	global_settings.phd_infor.interval = buf[7];
   222f4:	73d3      	strb	r3, [r2, #15]
	need_save_settings = true;
   222f6:	2201      	movs	r2, #1
   222f8:	7022      	strb	r2, [r4, #0]
	reply[reply_len++] = PACKET_HEAD;
   222fa:	22ab      	movs	r2, #171	; 0xab
   222fc:	f88d 2000 	strb.w	r2, [sp]
	reply[reply_len++] = 0x06;
   22300:	f64f 7206 	movw	r2, #65286	; 0xff06
   22304:	f8ad 2002 	strh.w	r2, [sp, #2]
	reply[reply_len++] = (u8_t)(MEASURE_HOURLY_ID&0x00ff);
   22308:	f248 0243 	movw	r2, #32835	; 0x8043
   2230c:	f8ad 2004 	strh.w	r2, [sp, #4]
	reply[reply_len++] = PACKET_END;
   22310:	2288      	movs	r2, #136	; 0x88
   22312:	4669      	mov	r1, sp
   22314:	f88d 2008 	strb.w	r2, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   22318:	2200      	movs	r2, #0
		reply[reply_len-2] += reply[i];
   2231a:	f811 3b01 	ldrb.w	r3, [r1], #1
   2231e:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   22322:	3201      	adds	r2, #1
		reply[reply_len-2] += reply[i];
   22324:	4403      	add	r3, r0
	for(i=0;i<(reply_len-2);i++)
   22326:	2a07      	cmp	r2, #7
		reply[reply_len-2] += reply[i];
   22328:	f88d 3007 	strb.w	r3, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   2232c:	d1f5      	bne.n	2231a <APP_set_PHD_interval+0x46>
	ble_send_date_handle(reply, reply_len);
   2232e:	2109      	movs	r1, #9
   22330:	4668      	mov	r0, sp
   22332:	f7ff fde9 	bl	21f08 <ble_send_date_handle>
	need_save_settings = true;	
   22336:	2301      	movs	r3, #1
   22338:	7023      	strb	r3, [r4, #0]
}
   2233a:	b020      	add	sp, #128	; 0x80
   2233c:	bd10      	pop	{r4, pc}
   2233e:	bf00      	nop
   22340:	200298a6 	.word	0x200298a6
   22344:	2002b923 	.word	0x2002b923

00022348 <APP_set_wake_screen_by_wrist>:
{
   22348:	b510      	push	{r4, lr}
   2234a:	4604      	mov	r4, r0
   2234c:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   2234e:	2280      	movs	r2, #128	; 0x80
   22350:	2100      	movs	r1, #0
   22352:	4668      	mov	r0, sp
   22354:	f01c fa9a 	bl	3e88c <memset>
	if(buf[6] == 1)
   22358:	79a3      	ldrb	r3, [r4, #6]
   2235a:	4669      	mov	r1, sp
   2235c:	1e5a      	subs	r2, r3, #1
   2235e:	4253      	negs	r3, r2
   22360:	4153      	adcs	r3, r2
   22362:	4a12      	ldr	r2, [pc, #72]	; (223ac <APP_set_wake_screen_by_wrist+0x64>)
   22364:	7113      	strb	r3, [r2, #4]
	reply[reply_len++] = PACKET_HEAD;
   22366:	23ab      	movs	r3, #171	; 0xab
   22368:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   2236c:	f64f 7306 	movw	r3, #65286	; 0xff06
   22370:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(SHAKE_SCREEN_ID&0x00ff);
   22374:	f248 0342 	movw	r3, #32834	; 0x8042
   22378:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   2237c:	2388      	movs	r3, #136	; 0x88
   2237e:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   22382:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   22384:	f811 2b01 	ldrb.w	r2, [r1], #1
   22388:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   2238c:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   2238e:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   22390:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   22392:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   22396:	d1f5      	bne.n	22384 <APP_set_wake_screen_by_wrist+0x3c>
	ble_send_date_handle(reply, reply_len);
   22398:	2109      	movs	r1, #9
   2239a:	4668      	mov	r0, sp
   2239c:	f7ff fdb4 	bl	21f08 <ble_send_date_handle>
	need_save_settings = true;
   223a0:	2201      	movs	r2, #1
   223a2:	4b03      	ldr	r3, [pc, #12]	; (223b0 <APP_set_wake_screen_by_wrist+0x68>)
   223a4:	701a      	strb	r2, [r3, #0]
}
   223a6:	b020      	add	sp, #128	; 0x80
   223a8:	bd10      	pop	{r4, pc}
   223aa:	bf00      	nop
   223ac:	200298a6 	.word	0x200298a6
   223b0:	2002b923 	.word	0x2002b923

000223b4 <APP_set_factory_reset>:
{
   223b4:	b500      	push	{lr}
   223b6:	b0a1      	sub	sp, #132	; 0x84
	u8_t reply[128] = {0};
   223b8:	2100      	movs	r1, #0
   223ba:	2280      	movs	r2, #128	; 0x80
   223bc:	4668      	mov	r0, sp
   223be:	f01c fa65 	bl	3e88c <memset>
	reply[reply_len++] = PACKET_HEAD;
   223c2:	23ab      	movs	r3, #171	; 0xab
   223c4:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   223c8:	f64f 7306 	movw	r3, #65286	; 0xff06
   223cc:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(FACTORY_RESET_ID&0x00ff);
   223d0:	f248 0353 	movw	r3, #32851	; 0x8053
   223d4:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   223d8:	2388      	movs	r3, #136	; 0x88
   223da:	4669      	mov	r1, sp
   223dc:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   223e0:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   223e2:	f811 2b01 	ldrb.w	r2, [r1], #1
   223e6:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   223ea:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   223ec:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   223ee:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   223f0:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   223f4:	d1f5      	bne.n	223e2 <APP_set_factory_reset+0x2e>
	ble_send_date_handle(reply, reply_len);
   223f6:	2109      	movs	r1, #9
   223f8:	4668      	mov	r0, sp
   223fa:	f7ff fd85 	bl	21f08 <ble_send_date_handle>
	need_reset_settings = true;
   223fe:	2201      	movs	r2, #1
   22400:	4b02      	ldr	r3, [pc, #8]	; (2240c <APP_set_factory_reset+0x58>)
   22402:	701a      	strb	r2, [r3, #0]
}
   22404:	b021      	add	sp, #132	; 0x84
   22406:	f85d fb04 	ldr.w	pc, [sp], #4
   2240a:	bf00      	nop
   2240c:	2002b922 	.word	0x2002b922

00022410 <APP_set_target_steps>:
{
   22410:	b510      	push	{r4, lr}
   22412:	b0a0      	sub	sp, #128	; 0x80
   22414:	4604      	mov	r4, r0
	u8_t reply[128] = {0};
   22416:	2280      	movs	r2, #128	; 0x80
   22418:	2100      	movs	r1, #0
   2241a:	4668      	mov	r0, sp
   2241c:	f01c fa36 	bl	3e88c <memset>
	LOG_INF("APP_set_target_steps: %02X,%02X\n", buf[7], buf[8]);
   22420:	2303      	movs	r3, #3
   22422:	f04f 0000 	mov.w	r0, #0
   22426:	4a1a      	ldr	r2, [pc, #104]	; (22490 <APP_set_target_steps+0x80>)
   22428:	f363 0007 	bfi	r0, r3, #0, #8
   2242c:	4b19      	ldr	r3, [pc, #100]	; (22494 <APP_set_target_steps+0x84>)
   2242e:	491a      	ldr	r1, [pc, #104]	; (22498 <APP_set_target_steps+0x88>)
   22430:	1a9b      	subs	r3, r3, r2
   22432:	08db      	lsrs	r3, r3, #3
   22434:	f363 108f 	bfi	r0, r3, #6, #10
   22438:	79e2      	ldrb	r2, [r4, #7]
   2243a:	7a23      	ldrb	r3, [r4, #8]
   2243c:	f01a f9cd 	bl	3c7da <log_string_sync>
	global_settings.target_steps = buf[7]*100+buf[8];
   22440:	79e3      	ldrb	r3, [r4, #7]
   22442:	7a22      	ldrb	r2, [r4, #8]
   22444:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   22448:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   2244c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   22450:	4a12      	ldr	r2, [pc, #72]	; (2249c <APP_set_target_steps+0x8c>)
   22452:	4669      	mov	r1, sp
   22454:	80d3      	strh	r3, [r2, #6]
	reply[reply_len++] = (u8_t)(TARGET_STEPS_ID&0x00ff);
   22456:	f248 0350 	movw	r3, #32848	; 0x8050
   2245a:	4a11      	ldr	r2, [pc, #68]	; (224a0 <APP_set_target_steps+0x90>)
   2245c:	e9cd 2300 	strd	r2, r3, [sp]
	reply[reply_len++] = PACKET_END;
   22460:	2388      	movs	r3, #136	; 0x88
   22462:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   22466:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   22468:	f811 2b01 	ldrb.w	r2, [r1], #1
   2246c:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   22470:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   22472:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   22474:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   22476:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   2247a:	d1f5      	bne.n	22468 <APP_set_target_steps+0x58>
	ble_send_date_handle(reply, reply_len);
   2247c:	2109      	movs	r1, #9
   2247e:	4668      	mov	r0, sp
   22480:	f7ff fd42 	bl	21f08 <ble_send_date_handle>
	need_save_settings = true;
   22484:	2201      	movs	r2, #1
   22486:	4b07      	ldr	r3, [pc, #28]	; (224a4 <APP_set_target_steps+0x94>)
   22488:	701a      	strb	r2, [r3, #0]
}
   2248a:	b020      	add	sp, #128	; 0x80
   2248c:	bd10      	pop	{r4, pc}
   2248e:	bf00      	nop
   22490:	0003f8d4 	.word	0x0003f8d4
   22494:	0003f9e4 	.word	0x0003f9e4
   22498:	0004083c 	.word	0x0004083c
   2249c:	200298a6 	.word	0x200298a6
   224a0:	ff0600ab 	.word	0xff0600ab
   224a4:	2002b923 	.word	0x2002b923

000224a8 <APP_get_current_data>:
{
   224a8:	b500      	push	{lr}
   224aa:	b0c5      	sub	sp, #276	; 0x114
	u8_t wake,reply[128] = {0};
   224ac:	2280      	movs	r2, #128	; 0x80
   224ae:	2100      	movs	r1, #0
   224b0:	a804      	add	r0, sp, #16
   224b2:	f01c f9eb 	bl	3e88c <memset>
	GetSportData(&steps, &calorie, &distance);
   224b6:	f10d 020a 	add.w	r2, sp, #10
   224ba:	a902      	add	r1, sp, #8
   224bc:	f10d 0006 	add.w	r0, sp, #6
   224c0:	f002 f904 	bl	246cc <GetSportData>
	GetSleepTimeData(&deep_sleep, &light_sleep);
   224c4:	a903      	add	r1, sp, #12
   224c6:	f10d 000e 	add.w	r0, sp, #14
   224ca:	f002 fb6f 	bl	24bac <GetSleepTimeData>
	reply[reply_len++] = (steps>>8);
   224ce:	f8bd 2006 	ldrh.w	r2, [sp, #6]
	reply[reply_len++] = PACKET_HEAD;
   224d2:	4b3f      	ldr	r3, [pc, #252]	; (225d0 <APP_get_current_data+0x128>)
	reply[reply_len++] = (steps>>8);
   224d4:	0a11      	lsrs	r1, r2, #8
	reply[reply_len++] = (u8_t)(steps&0x00ff);
   224d6:	f88d 2018 	strb.w	r2, [sp, #24]
	reply[reply_len++] = (calorie>>8);
   224da:	f8bd 2008 	ldrh.w	r2, [sp, #8]
	reply[reply_len++] = (steps>>8);
   224de:	f88d 1017 	strb.w	r1, [sp, #23]
	reply[reply_len++] = (u8_t)(calorie&0x00ff);
   224e2:	f88d 201a 	strb.w	r2, [sp, #26]
	reply[reply_len++] = (calorie>>8);
   224e6:	0a11      	lsrs	r1, r2, #8
	reply[reply_len++] = (distance>>8);
   224e8:	f8bd 200a 	ldrh.w	r2, [sp, #10]
	reply[reply_len++] = (calorie>>8);
   224ec:	f88d 1019 	strb.w	r1, [sp, #25]
	reply[reply_len++] = (u8_t)(distance&0x00ff);
   224f0:	f88d 201c 	strb.w	r2, [sp, #28]
	reply[reply_len++] = (distance>>8);
   224f4:	0a11      	lsrs	r1, r2, #8
	reply[reply_len++] = (light_sleep>>8);
   224f6:	f8bd 200c 	ldrh.w	r2, [sp, #12]
	reply[reply_len++] = (distance>>8);
   224fa:	f88d 101b 	strb.w	r1, [sp, #27]
	reply[reply_len++] = (u8_t)(light_sleep&0x00ff);
   224fe:	f88d 201e 	strb.w	r2, [sp, #30]
	reply[reply_len++] = (light_sleep>>8);
   22502:	0a11      	lsrs	r1, r2, #8
	reply[reply_len++] = (deep_sleep>>8);
   22504:	f8bd 200e 	ldrh.w	r2, [sp, #14]
	reply[reply_len++] = PACKET_HEAD;
   22508:	9304      	str	r3, [sp, #16]
	reply[reply_len++] = (light_sleep>>8);
   2250a:	f88d 101d 	strb.w	r1, [sp, #29]
	reply[reply_len++] = (u8_t)(PULL_REFRESH_ID&0x00ff);
   2250e:	f248 0335 	movw	r3, #32821	; 0x8035
	reply[reply_len++] = (deep_sleep>>8);
   22512:	0a11      	lsrs	r1, r2, #8
	reply[reply_len++] = (u8_t)(deep_sleep&0x00ff);
   22514:	f88d 2020 	strb.w	r2, [sp, #32]
	reply[reply_len++] = wake;
   22518:	2208      	movs	r2, #8
	reply[reply_len++] = (u8_t)(PULL_REFRESH_ID&0x00ff);
   2251a:	f8ad 3014 	strh.w	r3, [sp, #20]
	reply[reply_len++] = wake;
   2251e:	f88d 2021 	strb.w	r2, [sp, #33]	; 0x21
	reply[reply_len++] = 0x00;
   22522:	2300      	movs	r3, #0
	reply[reply_len++] = 0x00;
   22524:	f44f 4208 	mov.w	r2, #34816	; 0x8800
	reply[reply_len++] = (deep_sleep>>8);
   22528:	f88d 101f 	strb.w	r1, [sp, #31]
	reply[reply_len++] = 0x00;
   2252c:	f88d 3016 	strb.w	r3, [sp, #22]
	reply[reply_len++] = 0x00;
   22530:	f8ad 2022 	strh.w	r2, [sp, #34]	; 0x22
	for(i=0;i<(reply_len-2);i++)
   22534:	a904      	add	r1, sp, #16
		reply[reply_len-2] += reply[i];
   22536:	f811 2b01 	ldrb.w	r2, [r1], #1
   2253a:	f89d 0022 	ldrb.w	r0, [sp, #34]	; 0x22
	for(i=0;i<(reply_len-2);i++)
   2253e:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   22540:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   22542:	2b12      	cmp	r3, #18
		reply[reply_len-2] += reply[i];
   22544:	f88d 2022 	strb.w	r2, [sp, #34]	; 0x22
	for(i=0;i<(reply_len-2);i++)
   22548:	d1f5      	bne.n	22536 <APP_get_current_data+0x8e>
	ble_send_date_handle(reply, reply_len);
   2254a:	2114      	movs	r1, #20
   2254c:	a804      	add	r0, sp, #16
   2254e:	f7ff fcdb 	bl	21f08 <ble_send_date_handle>
	u8_t heart_rate,reply[128] = {0};
   22552:	2280      	movs	r2, #128	; 0x80
   22554:	2100      	movs	r1, #0
   22556:	a824      	add	r0, sp, #144	; 0x90
   22558:	f01c f998 	bl	3e88c <memset>
	GetHeartRate(&heart_rate);
   2255c:	f10d 0005 	add.w	r0, sp, #5
   22560:	f019 fe35 	bl	3c1ce <GetHeartRate>
	reply[reply_len++] = PACKET_HEAD;
   22564:	4b1b      	ldr	r3, [pc, #108]	; (225d4 <APP_get_current_data+0x12c>)
	reply[reply_len++] = (u8_t)(date_time.year>>8);
   22566:	4a1c      	ldr	r2, [pc, #112]	; (225d8 <APP_get_current_data+0x130>)
	reply[reply_len++] = PACKET_HEAD;
   22568:	9324      	str	r3, [sp, #144]	; 0x90
	reply[reply_len++] = (u8_t)(PULL_REFRESH_ID&0x00ff);
   2256a:	f248 1335 	movw	r3, #33077	; 0x8135
	reply[reply_len++] = (u8_t)(date_time.year>>8);
   2256e:	8811      	ldrh	r1, [r2, #0]
	reply[reply_len++] = (u8_t)(PULL_REFRESH_ID&0x00ff);
   22570:	f8ad 3094 	strh.w	r3, [sp, #148]	; 0x94
	reply[reply_len++] = (u8_t)(date_time.year>>8);
   22574:	0a08      	lsrs	r0, r1, #8
	reply[reply_len++] = (u8_t)(date_time.year&0x00ff);
   22576:	f88d 1098 	strb.w	r1, [sp, #152]	; 0x98
	reply[reply_len++] = date_time.month;
   2257a:	7891      	ldrb	r1, [r2, #2]
	reply[reply_len++] = 0x00;
   2257c:	2300      	movs	r3, #0
	reply[reply_len++] = date_time.month;
   2257e:	f88d 1099 	strb.w	r1, [sp, #153]	; 0x99
	reply[reply_len++] = date_time.day;
   22582:	78d1      	ldrb	r1, [r2, #3]
	reply[reply_len++] = 0x00;
   22584:	f88d 3096 	strb.w	r3, [sp, #150]	; 0x96
	reply[reply_len++] = date_time.day;
   22588:	f88d 109a 	strb.w	r1, [sp, #154]	; 0x9a
	reply[reply_len++] = date_time.hour;
   2258c:	7911      	ldrb	r1, [r2, #4]
	reply[reply_len++] = date_time.minute;
   2258e:	7952      	ldrb	r2, [r2, #5]
	reply[reply_len++] = date_time.hour;
   22590:	f88d 109b 	strb.w	r1, [sp, #155]	; 0x9b
	reply[reply_len++] = date_time.minute;
   22594:	f88d 209c 	strb.w	r2, [sp, #156]	; 0x9c
	reply[reply_len++] = heart_rate;
   22598:	f89d 2005 	ldrb.w	r2, [sp, #5]
	reply[reply_len++] = (u8_t)(date_time.year>>8);
   2259c:	f88d 0097 	strb.w	r0, [sp, #151]	; 0x97
	reply[reply_len++] = heart_rate;
   225a0:	f88d 209d 	strb.w	r2, [sp, #157]	; 0x9d
	reply[reply_len++] = 0x00;
   225a4:	f44f 4208 	mov.w	r2, #34816	; 0x8800
   225a8:	a924      	add	r1, sp, #144	; 0x90
   225aa:	f8ad 209e 	strh.w	r2, [sp, #158]	; 0x9e
		reply[reply_len-2] += reply[i];
   225ae:	f811 2b01 	ldrb.w	r2, [r1], #1
   225b2:	f89d 009e 	ldrb.w	r0, [sp, #158]	; 0x9e
	for(i=0;i<(reply_len-2);i++)
   225b6:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   225b8:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   225ba:	2b0e      	cmp	r3, #14
		reply[reply_len-2] += reply[i];
   225bc:	f88d 209e 	strb.w	r2, [sp, #158]	; 0x9e
	for(i=0;i<(reply_len-2);i++)
   225c0:	d1f5      	bne.n	225ae <APP_get_current_data+0x106>
	ble_send_date_handle(reply, reply_len);	
   225c2:	2110      	movs	r1, #16
   225c4:	a824      	add	r0, sp, #144	; 0x90
   225c6:	f7ff fc9f 	bl	21f08 <ble_send_date_handle>
}
   225ca:	b045      	add	sp, #276	; 0x114
   225cc:	f85d fb04 	ldr.w	pc, [sp], #4
   225d0:	ff1100ab 	.word	0xff1100ab
   225d4:	ff0d00ab 	.word	0xff0d00ab
   225d8:	20029894 	.word	0x20029894

000225dc <APP_get_battery_level>:
{
   225dc:	b570      	push	{r4, r5, r6, lr}
   225de:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   225e0:	2280      	movs	r2, #128	; 0x80
   225e2:	2100      	movs	r1, #0
   225e4:	4668      	mov	r0, sp
   225e6:	f01c f951 	bl	3e88c <memset>
	reply[reply_len++] = PACKET_HEAD;
   225ea:	23ab      	movs	r3, #171	; 0xab
   225ec:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x07;
   225f0:	f64f 7307 	movw	r3, #65287	; 0xff07
   225f4:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(BATTERY_LEVEL_ID&0x00ff);
   225f8:	2351      	movs	r3, #81	; 0x51
   225fa:	f88d 3004 	strb.w	r3, [sp, #4]
	switch(g_chg_status)
   225fe:	4b16      	ldr	r3, [pc, #88]	; (22658 <APP_get_battery_level+0x7c>)
   22600:	781b      	ldrb	r3, [r3, #0]
   22602:	b123      	cbz	r3, 2260e <APP_get_battery_level+0x32>
   22604:	2b02      	cmp	r3, #2
   22606:	d825      	bhi.n	22654 <APP_get_battery_level+0x78>
		reply[reply_len++] = 0x01;
   22608:	2301      	movs	r3, #1
   2260a:	f88d 3005 	strb.w	r3, [sp, #5]
		reply[reply_len++] = 0x00;
   2260e:	2106      	movs	r1, #6
	reply[reply_len++] = 0x00;
   22610:	ab20      	add	r3, sp, #128	; 0x80
   22612:	1858      	adds	r0, r3, r1
	reply[reply_len++] = PACKET_END;
   22614:	2588      	movs	r5, #136	; 0x88
	reply[reply_len++] = 0x00;
   22616:	2300      	movs	r3, #0
	reply[reply_len++] = g_bat_soc;
   22618:	4a10      	ldr	r2, [pc, #64]	; (2265c <APP_get_battery_level+0x80>)
   2261a:	1c8c      	adds	r4, r1, #2
   2261c:	7812      	ldrb	r2, [r2, #0]
	reply[reply_len++] = 0x00;
   2261e:	f800 3c80 	strb.w	r3, [r0, #-128]
	reply[reply_len++] = g_bat_soc;
   22622:	f800 2c7f 	strb.w	r2, [r0, #-127]
	reply[reply_len++] = 0x00;
   22626:	aa20      	add	r2, sp, #128	; 0x80
   22628:	4422      	add	r2, r4
   2262a:	f802 3c80 	strb.w	r3, [r2, #-128]
	reply[reply_len++] = PACKET_END;
   2262e:	f800 5c7d 	strb.w	r5, [r0, #-125]
   22632:	466d      	mov	r5, sp
   22634:	3104      	adds	r1, #4
		reply[reply_len-2] += reply[i];
   22636:	f815 0b01 	ldrb.w	r0, [r5], #1
   2263a:	f812 6c80 	ldrb.w	r6, [r2, #-128]
	for(i=0;i<(reply_len-2);i++)
   2263e:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   22640:	4430      	add	r0, r6
	for(i=0;i<(reply_len-2);i++)
   22642:	429c      	cmp	r4, r3
		reply[reply_len-2] += reply[i];
   22644:	f802 0c80 	strb.w	r0, [r2, #-128]
	for(i=0;i<(reply_len-2);i++)
   22648:	d8f5      	bhi.n	22636 <APP_get_battery_level+0x5a>
	ble_send_date_handle(reply, reply_len);
   2264a:	4668      	mov	r0, sp
   2264c:	f7ff fc5c 	bl	21f08 <ble_send_date_handle>
}
   22650:	b020      	add	sp, #128	; 0x80
   22652:	bd70      	pop	{r4, r5, r6, pc}
	reply[reply_len++] = (u8_t)(BATTERY_LEVEL_ID&0x00ff);
   22654:	2105      	movs	r1, #5
   22656:	e7db      	b.n	22610 <APP_get_battery_level+0x34>
   22658:	2002c385 	.word	0x2002c385
   2265c:	2002c384 	.word	0x2002c384

00022660 <APP_get_heart_rate>:
{
   22660:	b500      	push	{lr}
   22662:	b0a3      	sub	sp, #140	; 0x8c
	u8_t heart_rate,reply[128] = {0};
   22664:	2100      	movs	r1, #0
   22666:	2280      	movs	r2, #128	; 0x80
   22668:	a802      	add	r0, sp, #8
   2266a:	f01c f90f 	bl	3e88c <memset>
	GetHeartRate(&heart_rate);
   2266e:	f10d 0007 	add.w	r0, sp, #7
   22672:	f019 fdac 	bl	3c1ce <GetHeartRate>
	reply[reply_len++] = PACKET_HEAD;
   22676:	4b12      	ldr	r3, [pc, #72]	; (226c0 <APP_get_heart_rate+0x60>)
   22678:	a902      	add	r1, sp, #8
   2267a:	9302      	str	r3, [sp, #8]
	reply[reply_len++] = (u8_t)(HEART_RATE_ID&0x00ff);
   2267c:	f240 2331 	movw	r3, #561	; 0x231
   22680:	f8ad 300c 	strh.w	r3, [sp, #12]
	reply[reply_len++] = 0x01;
   22684:	2301      	movs	r3, #1
   22686:	f88d 300e 	strb.w	r3, [sp, #14]
	reply[reply_len++] = heart_rate;	//V2.0
   2268a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   2268e:	f88d 300f 	strb.w	r3, [sp, #15]
	reply[reply_len++] = 0x00;
   22692:	f44f 4308 	mov.w	r3, #34816	; 0x8800
   22696:	f8ad 3010 	strh.w	r3, [sp, #16]
	for(i=0;i<(reply_len-2);i++)
   2269a:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   2269c:	f811 2b01 	ldrb.w	r2, [r1], #1
   226a0:	f89d 0010 	ldrb.w	r0, [sp, #16]
	for(i=0;i<(reply_len-2);i++)
   226a4:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   226a6:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   226a8:	2b08      	cmp	r3, #8
		reply[reply_len-2] += reply[i];
   226aa:	f88d 2010 	strb.w	r2, [sp, #16]
	for(i=0;i<(reply_len-2);i++)
   226ae:	d1f5      	bne.n	2269c <APP_get_heart_rate+0x3c>
	ble_send_date_handle(reply, reply_len);
   226b0:	210a      	movs	r1, #10
   226b2:	a802      	add	r0, sp, #8
   226b4:	f7ff fc28 	bl	21f08 <ble_send_date_handle>
}
   226b8:	b023      	add	sp, #140	; 0x8c
   226ba:	f85d fb04 	ldr.w	pc, [sp], #4
   226be:	bf00      	nop
   226c0:	ff0700ab 	.word	0xff0700ab

000226c4 <ble_receive_date_handle>:
{
   226c4:	b430      	push	{r4, r5}
	if((buf[0] != PACKET_HEAD) || (buf[len-1] != PACKET_END))	//format is error
   226c6:	7802      	ldrb	r2, [r0, #0]
   226c8:	1843      	adds	r3, r0, r1
   226ca:	2aab      	cmp	r2, #171	; 0xab
   226cc:	f813 3c01 	ldrb.w	r3, [r3, #-1]
   226d0:	d101      	bne.n	226d6 <ble_receive_date_handle+0x12>
   226d2:	2b88      	cmp	r3, #136	; 0x88
   226d4:	d024      	beq.n	22720 <ble_receive_date_handle+0x5c>
		LOG_INF("format is error! HEAD:%x, END:%x\n", buf[0], buf[len-1]);
   226d6:	2103      	movs	r1, #3
   226d8:	f04f 0000 	mov.w	r0, #0
   226dc:	4c6a      	ldr	r4, [pc, #424]	; (22888 <ble_receive_date_handle+0x1c4>)
   226de:	f361 0007 	bfi	r0, r1, #0, #8
   226e2:	496a      	ldr	r1, [pc, #424]	; (2288c <ble_receive_date_handle+0x1c8>)
   226e4:	1b09      	subs	r1, r1, r4
   226e6:	08c9      	lsrs	r1, r1, #3
   226e8:	f361 108f 	bfi	r0, r1, #6, #10
   226ec:	4968      	ldr	r1, [pc, #416]	; (22890 <ble_receive_date_handle+0x1cc>)
}
   226ee:	bc30      	pop	{r4, r5}
		LOG_INF("CRC is error! data:%x, CRC:%x\n", buf[len-2], CRC_data);
   226f0:	f01a b873 	b.w	3c7da <log_string_sync>
		CRC_data = CRC_data+buf[i];
   226f4:	5c85      	ldrb	r5, [r0, r2]
	for(i=0;i<len-2;i++)
   226f6:	3201      	adds	r2, #1
		CRC_data = CRC_data+buf[i];
   226f8:	442b      	add	r3, r5
   226fa:	b2db      	uxtb	r3, r3
	for(i=0;i<len-2;i++)
   226fc:	42a2      	cmp	r2, r4
   226fe:	d3f9      	bcc.n	226f4 <ble_receive_date_handle+0x30>
	if(CRC_data != buf[len-2])									//crc is error
   22700:	5d02      	ldrb	r2, [r0, r4]
   22702:	4293      	cmp	r3, r2
   22704:	d010      	beq.n	22728 <ble_receive_date_handle+0x64>
		LOG_INF("CRC is error! data:%x, CRC:%x\n", buf[len-2], CRC_data);
   22706:	2103      	movs	r1, #3
   22708:	f04f 0000 	mov.w	r0, #0
   2270c:	4c5e      	ldr	r4, [pc, #376]	; (22888 <ble_receive_date_handle+0x1c4>)
   2270e:	f361 0007 	bfi	r0, r1, #0, #8
   22712:	495e      	ldr	r1, [pc, #376]	; (2288c <ble_receive_date_handle+0x1c8>)
   22714:	1b09      	subs	r1, r1, r4
   22716:	08c9      	lsrs	r1, r1, #3
   22718:	f361 108f 	bfi	r0, r1, #6, #10
   2271c:	495d      	ldr	r1, [pc, #372]	; (22894 <ble_receive_date_handle+0x1d0>)
   2271e:	e7e6      	b.n	226ee <ble_receive_date_handle+0x2a>
	for(i=0;i<len-2;i++)
   22720:	2200      	movs	r2, #0
   22722:	1e8c      	subs	r4, r1, #2
	u8_t CRC_data=0,data_status;
   22724:	4613      	mov	r3, r2
   22726:	e7e9      	b.n	226fc <ble_receive_date_handle+0x38>
	data_ID = buf[3]*256+buf[4];
   22728:	78c2      	ldrb	r2, [r0, #3]
   2272a:	7903      	ldrb	r3, [r0, #4]
   2272c:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	switch(data_ID)
   22730:	f64f 7247 	movw	r2, #65351	; 0xff47
	data_ID = buf[3]*256+buf[4];
   22734:	b29b      	uxth	r3, r3
	switch(data_ID)
   22736:	4293      	cmp	r3, r2
   22738:	f000 8088 	beq.w	2284c <ble_receive_date_handle+0x188>
   2273c:	d83b      	bhi.n	227b6 <ble_receive_date_handle+0xf2>
   2273e:	f64f 7239 	movw	r2, #65337	; 0xff39
   22742:	4293      	cmp	r3, r2
   22744:	d079      	beq.n	2283a <ble_receive_date_handle+0x176>
   22746:	d81e      	bhi.n	22786 <ble_receive_date_handle+0xc2>
   22748:	f64f 7235 	movw	r2, #65333	; 0xff35
   2274c:	4293      	cmp	r3, r2
   2274e:	d06e      	beq.n	2282e <ble_receive_date_handle+0x16a>
   22750:	d813      	bhi.n	2277a <ble_receive_date_handle+0xb6>
   22752:	f64f 7231 	movw	r2, #65329	; 0xff31
   22756:	4293      	cmp	r3, r2
   22758:	d066      	beq.n	22828 <ble_receive_date_handle+0x164>
   2275a:	d212      	bcs.n	22782 <ble_receive_date_handle+0xbe>
}
   2275c:	bc30      	pop	{r4, r5}
		LOG_INF("data_id is unknown! \n");
   2275e:	2303      	movs	r3, #3
   22760:	f04f 0000 	mov.w	r0, #0
   22764:	4a48      	ldr	r2, [pc, #288]	; (22888 <ble_receive_date_handle+0x1c4>)
   22766:	f363 0007 	bfi	r0, r3, #0, #8
   2276a:	4b48      	ldr	r3, [pc, #288]	; (2288c <ble_receive_date_handle+0x1c8>)
   2276c:	494a      	ldr	r1, [pc, #296]	; (22898 <ble_receive_date_handle+0x1d4>)
   2276e:	1a9b      	subs	r3, r3, r2
   22770:	08db      	lsrs	r3, r3, #3
   22772:	f363 108f 	bfi	r0, r3, #6, #10
   22776:	f01a b830 	b.w	3c7da <log_string_sync>
	switch(data_ID)
   2277a:	f64f 7237 	movw	r2, #65335	; 0xff37
   2277e:	4293      	cmp	r3, r2
   22780:	d058      	beq.n	22834 <ble_receive_date_handle+0x170>
}
   22782:	bc30      	pop	{r4, r5}
   22784:	4770      	bx	lr
	switch(data_ID)
   22786:	f64f 7243 	movw	r2, #65347	; 0xff43
   2278a:	4293      	cmp	r3, r2
   2278c:	d058      	beq.n	22840 <ble_receive_date_handle+0x17c>
   2278e:	d80a      	bhi.n	227a6 <ble_receive_date_handle+0xe2>
   22790:	f64f 7240 	movw	r2, #65344	; 0xff40
   22794:	4293      	cmp	r3, r2
   22796:	d3e1      	bcc.n	2275c <ble_receive_date_handle+0x98>
   22798:	f64f 7241 	movw	r2, #65345	; 0xff41
   2279c:	4293      	cmp	r3, r2
   2279e:	d9f0      	bls.n	22782 <ble_receive_date_handle+0xbe>
}
   227a0:	bc30      	pop	{r4, r5}
		APP_set_wake_screen_by_wrist(buf, len);
   227a2:	f7ff bdd1 	b.w	22348 <APP_set_wake_screen_by_wrist>
	switch(data_ID)
   227a6:	f64f 7245 	movw	r2, #65349	; 0xff45
   227aa:	4293      	cmp	r3, r2
   227ac:	d04b      	beq.n	22846 <ble_receive_date_handle+0x182>
   227ae:	d9e8      	bls.n	22782 <ble_receive_date_handle+0xbe>
}
   227b0:	bc30      	pop	{r4, r5}
		APP_set_time_24_format(buf, len);
   227b2:	f7ff bc43 	b.w	2203c <APP_set_time_24_format>
	switch(data_ID)
   227b6:	f64f 7255 	movw	r2, #65365	; 0xff55
   227ba:	4293      	cmp	r3, r2
   227bc:	d052      	beq.n	22864 <ble_receive_date_handle+0x1a0>
   227be:	d818      	bhi.n	227f2 <ble_receive_date_handle+0x12e>
   227c0:	f64f 7251 	movw	r2, #65361	; 0xff51
   227c4:	4293      	cmp	r3, r2
   227c6:	d047      	beq.n	22858 <ble_receive_date_handle+0x194>
   227c8:	d80b      	bhi.n	227e2 <ble_receive_date_handle+0x11e>
   227ca:	f64f 7249 	movw	r2, #65353	; 0xff49
   227ce:	4293      	cmp	r3, r2
   227d0:	d03f      	beq.n	22852 <ble_receive_date_handle+0x18e>
   227d2:	d3d6      	bcc.n	22782 <ble_receive_date_handle+0xbe>
   227d4:	f64f 7250 	movw	r2, #65360	; 0xff50
   227d8:	4293      	cmp	r3, r2
   227da:	d1bf      	bne.n	2275c <ble_receive_date_handle+0x98>
}
   227dc:	bc30      	pop	{r4, r5}
		APP_set_target_steps(buf, len);
   227de:	f7ff be17 	b.w	22410 <APP_set_target_steps>
	switch(data_ID)
   227e2:	f64f 7253 	movw	r2, #65363	; 0xff53
   227e6:	4293      	cmp	r3, r2
   227e8:	d039      	beq.n	2285e <ble_receive_date_handle+0x19a>
   227ea:	d8ca      	bhi.n	22782 <ble_receive_date_handle+0xbe>
}
   227ec:	bc30      	pop	{r4, r5}
		APP_get_firmware_version(buf, len);
   227ee:	f018 b9b3 	b.w	3ab58 <APP_get_firmware_version>
	switch(data_ID)
   227f2:	f64f 72b2 	movw	r2, #65458	; 0xffb2
   227f6:	4293      	cmp	r3, r2
   227f8:	d03d      	beq.n	22876 <ble_receive_date_handle+0x1b2>
   227fa:	d80b      	bhi.n	22814 <ble_receive_date_handle+0x150>
   227fc:	f64f 72b0 	movw	r2, #65456	; 0xffb0
   22800:	4293      	cmp	r3, r2
   22802:	d032      	beq.n	2286a <ble_receive_date_handle+0x1a6>
   22804:	d834      	bhi.n	22870 <ble_receive_date_handle+0x1ac>
   22806:	f64f 7256 	movw	r2, #65366	; 0xff56
   2280a:	4293      	cmp	r3, r2
   2280c:	d1a6      	bne.n	2275c <ble_receive_date_handle+0x98>
}
   2280e:	bc30      	pop	{r4, r5}
		APP_set_date_format(buf, len);
   22810:	f7ff bc58 	b.w	220c4 <APP_set_date_format>
	switch(data_ID)
   22814:	f64f 72b4 	movw	r2, #65460	; 0xffb4
   22818:	4293      	cmp	r3, r2
   2281a:	d032      	beq.n	22882 <ble_receive_date_handle+0x1be>
   2281c:	d32e      	bcc.n	2287c <ble_receive_date_handle+0x1b8>
   2281e:	f64f 72b5 	movw	r2, #65461	; 0xffb5
   22822:	4293      	cmp	r3, r2
   22824:	d19a      	bne.n	2275c <ble_receive_date_handle+0x98>
   22826:	e7ac      	b.n	22782 <ble_receive_date_handle+0xbe>
}
   22828:	bc30      	pop	{r4, r5}
		APP_get_heart_rate(buf, len);
   2282a:	f7ff bf19 	b.w	22660 <APP_get_heart_rate>
}
   2282e:	bc30      	pop	{r4, r5}
		APP_get_current_data(buf, len);
   22830:	f7ff be3a 	b.w	224a8 <APP_get_current_data>
}
   22834:	bc30      	pop	{r4, r5}
		APP_set_find_device(buf, len);
   22836:	f7ff bb8b 	b.w	21f50 <APP_set_find_device>
}
   2283a:	bc30      	pop	{r4, r5}
		APP_set_alarm(buf, len);
   2283c:	f7ff bcf8 	b.w	22230 <APP_set_alarm>
}
   22840:	bc30      	pop	{r4, r5}
		APP_set_PHD_interval(buf, len);
   22842:	f7ff bd47 	b.w	222d4 <APP_set_PHD_interval>
}
   22846:	bc30      	pop	{r4, r5}
		APP_set_language(buf, len);
   22848:	f7ff bbb0 	b.w	21fac <APP_set_language>
}
   2284c:	bc30      	pop	{r4, r5}
		APP_reply_find_phone(buf, len);
   2284e:	f7ff bab9 	b.w	21dc4 <APP_reply_find_phone>
}
   22852:	bc30      	pop	{r4, r5}
		APP_set_date_time(buf, len);
   22854:	f7ff bc7e 	b.w	22154 <APP_set_date_time>
}
   22858:	bc30      	pop	{r4, r5}
		APP_get_battery_level(buf, len);
   2285a:	f7ff bebf 	b.w	225dc <APP_get_battery_level>
}
   2285e:	bc30      	pop	{r4, r5}
		APP_set_factory_reset(buf, len);
   22860:	f7ff bda8 	b.w	223b4 <APP_set_factory_reset>
}
   22864:	bc30      	pop	{r4, r5}
	APP_Ask_GPS_Data();
   22866:	f000 b9d3 	b.w	22c10 <APP_Ask_GPS_Data>
}
   2286a:	bc30      	pop	{r4, r5}
		ble_connect_or_disconnect_handle(buf, len);
   2286c:	f7ff ba0c 	b.w	21c88 <ble_connect_or_disconnect_handle>
}
   22870:	bc30      	pop	{r4, r5}
		CTP_notify_handle(buf, len);
   22872:	f7ff ba29 	b.w	21cc8 <CTP_notify_handle>
}
   22876:	bc30      	pop	{r4, r5}
		get_nrf52810_ver_response(buf, len);
   22878:	f7ff bad8 	b.w	21e2c <get_nrf52810_ver_response>
}
   2287c:	bc30      	pop	{r4, r5}
		get_ble_mac_address_response(buf, len);
   2287e:	f7ff baf7 	b.w	21e70 <get_ble_mac_address_response>
}
   22882:	bc30      	pop	{r4, r5}
		get_ble_status_response(buf, len);
   22884:	f7ff bb22 	b.w	21ecc <get_ble_status_response>
   22888:	0003f8d4 	.word	0x0003f8d4
   2288c:	0003f9e4 	.word	0x0003f9e4
   22890:	00040900 	.word	0x00040900
   22894:	00040922 	.word	0x00040922
   22898:	00040941 	.word	0x00040941

0002289c <uart_cb>:
	uart_irq_tx_enable(uart_ble); 
}

static void uart_cb(struct device *x)
{
	u8_t tmpbyte = 0;
   2289c:	2300      	movs	r3, #0
{
   2289e:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   228a2:	4604      	mov	r4, r0
	u8_t tmpbyte = 0;
   228a4:	f88d 3007 	strb.w	r3, [sp, #7]
static inline int z_impl_uart_irq_update(struct device *dev)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	if (api->irq_update) {
   228a8:	6843      	ldr	r3, [r0, #4]
   228aa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   228ac:	b103      	cbz	r3, 228b0 <uart_cb+0x14>
		return api->irq_update(dev);
   228ae:	4798      	blx	r3
	if (api->irq_rx_ready) {
   228b0:	6863      	ldr	r3, [r4, #4]
   228b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   228b4:	b933      	cbnz	r3, 228c4 <uart_cb+0x28>
	if (api->irq_tx_ready) {
   228b6:	6863      	ldr	r3, [r4, #4]
   228b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   228ba:	2b00      	cmp	r3, #0
   228bc:	d14c      	bne.n	22958 <uart_cb+0xbc>
			uart_irq_tx_disable(x);
		}

		k_free(buf);
	}
}
   228be:	b002      	add	sp, #8
   228c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return api->irq_rx_ready(dev);
   228c4:	4620      	mov	r0, r4
   228c6:	4798      	blx	r3
	if(uart_irq_rx_ready(x)) 
   228c8:	2800      	cmp	r0, #0
   228ca:	d0f4      	beq.n	228b6 <uart_cb+0x1a>
   228cc:	4d39      	ldr	r5, [pc, #228]	; (229b4 <uart_cb+0x118>)
	LOG_INF("uart_rece:%02X\n", data);
   228ce:	4b3a      	ldr	r3, [pc, #232]	; (229b8 <uart_cb+0x11c>)
   228d0:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 229c8 <uart_cb+0x12c>
   228d4:	1aed      	subs	r5, r5, r3
   228d6:	4e39      	ldr	r6, [pc, #228]	; (229bc <uart_cb+0x120>)
   228d8:	f3c5 05c9 	ubfx	r5, r5, #3, #10
		memset(rx_buf, 0, sizeof(rx_buf));
   228dc:	4f38      	ldr	r7, [pc, #224]	; (229c0 <uart_cb+0x124>)
	if (api->fifo_read) {
   228de:	6863      	ldr	r3, [r4, #4]
   228e0:	699b      	ldr	r3, [r3, #24]
   228e2:	2b00      	cmp	r3, #0
   228e4:	d0e7      	beq.n	228b6 <uart_cb+0x1a>
		return api->fifo_read(dev, rx_data, size);
   228e6:	2201      	movs	r2, #1
   228e8:	f10d 0107 	add.w	r1, sp, #7
   228ec:	4620      	mov	r0, r4
   228ee:	4798      	blx	r3
		while((len = uart_fifo_read(x, &tmpbyte, 1)) > 0)
   228f0:	2800      	cmp	r0, #0
   228f2:	d0e0      	beq.n	228b6 <uart_cb+0x1a>
	LOG_INF("uart_rece:%02X\n", data);
   228f4:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   228f8:	f043 0303 	orr.w	r3, r3, #3
			uart_receive_data(tmpbyte, 1);
   228fc:	f89d a007 	ldrb.w	sl, [sp, #7]
	LOG_INF("uart_rece:%02X\n", data);
   22900:	f363 0807 	bfi	r8, r3, #0, #8
   22904:	f365 188f 	bfi	r8, r5, #6, #10
   22908:	4652      	mov	r2, sl
   2290a:	4649      	mov	r1, r9
   2290c:	4640      	mov	r0, r8
   2290e:	f019 ff64 	bl	3c7da <log_string_sync>
	if(data == 0xAB)
   22912:	f1ba 0fab 	cmp.w	sl, #171	; 0xab
   22916:	d107      	bne.n	22928 <uart_cb+0x8c>
		memset(rx_buf, 0, sizeof(rx_buf));
   22918:	f44f 6280 	mov.w	r2, #1024	; 0x400
   2291c:	2100      	movs	r1, #0
   2291e:	4638      	mov	r0, r7
   22920:	f01b ffb4 	bl	3e88c <memset>
		rece_len = 0;
   22924:	2300      	movs	r3, #0
   22926:	6033      	str	r3, [r6, #0]
	rx_buf[rece_len++] = data;
   22928:	6833      	ldr	r3, [r6, #0]
   2292a:	f807 a003 	strb.w	sl, [r7, r3]
   2292e:	1c59      	adds	r1, r3, #1
	if(rece_len == (256*rx_buf[1]+rx_buf[2]+3))	//receivive complete
   22930:	78bb      	ldrb	r3, [r7, #2]
   22932:	787a      	ldrb	r2, [r7, #1]
   22934:	3303      	adds	r3, #3
   22936:	eb03 2302 	add.w	r3, r3, r2, lsl #8
   2293a:	4299      	cmp	r1, r3
	rx_buf[rece_len++] = data;
   2293c:	6031      	str	r1, [r6, #0]
	if(rece_len == (256*rx_buf[1]+rx_buf[2]+3))	//receivive complete
   2293e:	d1ce      	bne.n	228de <uart_cb+0x42>
		ble_receive_date_handle(rx_buf, rece_len);
   22940:	481f      	ldr	r0, [pc, #124]	; (229c0 <uart_cb+0x124>)
   22942:	f7ff febf 	bl	226c4 <ble_receive_date_handle>
		memset(rx_buf, 0, sizeof(rx_buf));
   22946:	f44f 6280 	mov.w	r2, #1024	; 0x400
   2294a:	2100      	movs	r1, #0
   2294c:	481c      	ldr	r0, [pc, #112]	; (229c0 <uart_cb+0x124>)
   2294e:	f01b ff9d 	bl	3e88c <memset>
		rece_len = 0;
   22952:	2300      	movs	r3, #0
   22954:	6033      	str	r3, [r6, #0]
   22956:	e7c1      	b.n	228dc <uart_cb+0x40>
		return api->irq_tx_ready(dev);
   22958:	4620      	mov	r0, r4
   2295a:	4798      	blx	r3
	if(uart_irq_tx_ready(x))
   2295c:	2800      	cmp	r0, #0
   2295e:	d0ae      	beq.n	228be <uart_cb+0x22>
	return z_impl_k_queue_get(queue, timeout);
   22960:	2100      	movs	r1, #0
   22962:	4818      	ldr	r0, [pc, #96]	; (229c4 <uart_cb+0x128>)
   22964:	f013 fd64 	bl	36430 <z_impl_k_queue_get>
		if(!buf)
   22968:	4606      	mov	r6, r0
   2296a:	bb00      	cbnz	r0, 229ae <uart_cb+0x112>
			uart_irq_tx_disable(x);
   2296c:	4620      	mov	r0, r4
   2296e:	f018 f893 	bl	3aa98 <uart_irq_tx_disable>
			return;
   22972:	e7a4      	b.n	228be <uart_cb+0x22>
			written += uart_fifo_fill(x, &buf->data[written], buf->len - written);
   22974:	1d29      	adds	r1, r5, #4
   22976:	1b52      	subs	r2, r2, r5
   22978:	4431      	add	r1, r6
   2297a:	4620      	mov	r0, r4
   2297c:	f018 f881 	bl	3aa82 <uart_fifo_fill>
   22980:	4405      	add	r5, r0
   22982:	b2ad      	uxth	r5, r5
		while(buf->len > written)
   22984:	f8b6 2404 	ldrh.w	r2, [r6, #1028]	; 0x404
   22988:	42aa      	cmp	r2, r5
   2298a:	d8f3      	bhi.n	22974 <uart_cb+0xd8>
	if (api->irq_tx_complete) {
   2298c:	6863      	ldr	r3, [r4, #4]
   2298e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   22990:	b11b      	cbz	r3, 2299a <uart_cb+0xfe>
		return api->irq_tx_complete(dev);
   22992:	4620      	mov	r0, r4
   22994:	4798      	blx	r3
		while (!uart_irq_tx_complete(x))
   22996:	2800      	cmp	r0, #0
   22998:	d0f8      	beq.n	2298c <uart_cb+0xf0>
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_sflist_is_empty(sys_sflist_t *list);

Z_GENLIST_IS_EMPTY(sflist)
   2299a:	4b0a      	ldr	r3, [pc, #40]	; (229c4 <uart_cb+0x128>)
		if (k_fifo_is_empty(&fifo_uart_tx_data))
   2299c:	681b      	ldr	r3, [r3, #0]
   2299e:	b913      	cbnz	r3, 229a6 <uart_cb+0x10a>
			uart_irq_tx_disable(x);
   229a0:	4620      	mov	r0, r4
   229a2:	f018 f879 	bl	3aa98 <uart_irq_tx_disable>
		k_free(buf);
   229a6:	4630      	mov	r0, r6
   229a8:	f01b fd81 	bl	3e4ae <k_free>
   229ac:	e787      	b.n	228be <uart_cb+0x22>
		u16_t written = 0;
   229ae:	2500      	movs	r5, #0
   229b0:	e7e8      	b.n	22984 <uart_cb+0xe8>
   229b2:	bf00      	nop
   229b4:	0003f9e4 	.word	0x0003f9e4
   229b8:	0003f8d4 	.word	0x0003f8d4
   229bc:	20020cb4 	.word	0x20020cb4
   229c0:	2002b92e 	.word	0x2002b92e
   229c4:	20037b2c 	.word	0x20037b2c
   229c8:	000409c8 	.word	0x000409c8

000229cc <ble_init>:

void ble_init(void)
{
	LOG_INF("ble_init\n");
   229cc:	2303      	movs	r3, #3
   229ce:	f04f 0000 	mov.w	r0, #0
{
   229d2:	b570      	push	{r4, r5, r6, lr}
	LOG_INF("ble_init\n");
   229d4:	f363 0007 	bfi	r0, r3, #0, #8
   229d8:	4c15      	ldr	r4, [pc, #84]	; (22a30 <ble_init+0x64>)
   229da:	4b16      	ldr	r3, [pc, #88]	; (22a34 <ble_init+0x68>)
   229dc:	4916      	ldr	r1, [pc, #88]	; (22a38 <ble_init+0x6c>)
   229de:	1ae4      	subs	r4, r4, r3
   229e0:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   229e4:	f364 108f 	bfi	r0, r4, #6, #10
   229e8:	f019 fef7 	bl	3c7da <log_string_sync>
   229ec:	4813      	ldr	r0, [pc, #76]	; (22a3c <ble_init+0x70>)
   229ee:	f012 fe17 	bl	35620 <z_impl_device_get_binding>
	
	uart_ble = device_get_binding(BLE_DEV);
   229f2:	4d13      	ldr	r5, [pc, #76]	; (22a40 <ble_init+0x74>)
   229f4:	4602      	mov	r2, r0
   229f6:	6028      	str	r0, [r5, #0]
	if(!uart_ble)
   229f8:	b960      	cbnz	r0, 22a14 <ble_init+0x48>
	{
		LOG_INF("Could not get %s device\n", BLE_DEV);
   229fa:	f04f 0000 	mov.w	r0, #0
   229fe:	2303      	movs	r3, #3
   22a00:	f363 0007 	bfi	r0, r3, #0, #8
   22a04:	f364 108f 	bfi	r0, r4, #6, #10
   22a08:	4a0c      	ldr	r2, [pc, #48]	; (22a3c <ble_init+0x70>)
   22a0a:	490e      	ldr	r1, [pc, #56]	; (22a44 <ble_init+0x78>)
		return;
	}

	uart_irq_callback_set(uart_ble, uart_cb);
	uart_irq_rx_enable(uart_ble);
}
   22a0c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LOG_INF("Could not get %s device\n", BLE_DEV);
   22a10:	f019 bee3 	b.w	3c7da <log_string_sync>
static inline void uart_irq_callback_user_data_set(
					struct device *dev,
					uart_irq_callback_user_data_t cb,
					void *user_data)
{
	const struct uart_driver_api *api =
   22a14:	6843      	ldr	r3, [r0, #4]
		(const struct uart_driver_api *)dev->driver_api;

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
   22a16:	b11b      	cbz	r3, 22a20 <ble_init+0x54>
   22a18:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   22a1a:	b10b      	cbz	r3, 22a20 <ble_init+0x54>
		api->irq_callback_set(dev, cb, user_data);
   22a1c:	490a      	ldr	r1, [pc, #40]	; (22a48 <ble_init+0x7c>)
   22a1e:	4798      	blx	r3
	uart_irq_rx_enable(uart_ble);
   22a20:	6828      	ldr	r0, [r5, #0]
	if (api->irq_rx_enable) {
   22a22:	6843      	ldr	r3, [r0, #4]
   22a24:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   22a26:	b113      	cbz	r3, 22a2e <ble_init+0x62>
}
   22a28:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		api->irq_rx_enable(dev);
   22a2c:	4718      	bx	r3
   22a2e:	bd70      	pop	{r4, r5, r6, pc}
   22a30:	0003f9e4 	.word	0x0003f9e4
   22a34:	0003f8d4 	.word	0x0003f8d4
   22a38:	000408ef 	.word	0x000408ef
   22a3c:	000408f9 	.word	0x000408f9
   22a40:	20020cb8 	.word	0x20020cb8
   22a44:	00040560 	.word	0x00040560
   22a48:	0002289d 	.word	0x0002289d

00022a4c <gps_data_wait_timerout>:

void gps_data_wait_timerout(struct k_timer *timer)
{
	gps_data_incoming = true;
   22a4c:	2201      	movs	r2, #1
   22a4e:	4b01      	ldr	r3, [pc, #4]	; (22a54 <gps_data_wait_timerout+0x8>)
   22a50:	701a      	strb	r2, [r3, #0]
}
   22a52:	4770      	bx	lr
   22a54:	2002bdb2 	.word	0x2002bdb2

00022a58 <print_nmea_data>:
{
   22a58:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	LOG_INF("\n");
   22a5c:	f04f 0000 	mov.w	r0, #0
   22a60:	2303      	movs	r3, #3
   22a62:	4c14      	ldr	r4, [pc, #80]	; (22ab4 <print_nmea_data+0x5c>)
   22a64:	f363 0007 	bfi	r0, r3, #0, #8
   22a68:	4b13      	ldr	r3, [pc, #76]	; (22ab8 <print_nmea_data+0x60>)
   22a6a:	4914      	ldr	r1, [pc, #80]	; (22abc <print_nmea_data+0x64>)
   22a6c:	1ae4      	subs	r4, r4, r3
   22a6e:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   22a72:	f364 108f 	bfi	r0, r4, #6, #10
   22a76:	f019 feb0 	bl	3c7da <log_string_sync>
	for(i = 0; i < nmea_string_cnt; ++i)
   22a7a:	2500      	movs	r5, #0
   22a7c:	4f10      	ldr	r7, [pc, #64]	; (22ac0 <print_nmea_data+0x68>)
		LOG_INF("%s", nmea_strings[i]);
   22a7e:	f8df 8044 	ldr.w	r8, [pc, #68]	; 22ac4 <print_nmea_data+0x6c>
   22a82:	f8df 9044 	ldr.w	r9, [pc, #68]	; 22ac8 <print_nmea_data+0x70>
	for(i = 0; i < nmea_string_cnt; ++i)
   22a86:	683b      	ldr	r3, [r7, #0]
   22a88:	429d      	cmp	r5, r3
   22a8a:	d301      	bcc.n	22a90 <print_nmea_data+0x38>
}
   22a8c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		LOG_INF("%s", nmea_strings[i]);
   22a90:	2253      	movs	r2, #83	; 0x53
   22a92:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   22a96:	f043 0303 	orr.w	r3, r3, #3
   22a9a:	f363 0607 	bfi	r6, r3, #0, #8
   22a9e:	f364 168f 	bfi	r6, r4, #6, #10
   22aa2:	fb02 8205 	mla	r2, r2, r5, r8
   22aa6:	4649      	mov	r1, r9
   22aa8:	4630      	mov	r0, r6
   22aaa:	f019 fe96 	bl	3c7da <log_string_sync>
	for(i = 0; i < nmea_string_cnt; ++i)
   22aae:	3501      	adds	r5, #1
   22ab0:	e7e9      	b.n	22a86 <print_nmea_data+0x2e>
   22ab2:	bf00      	nop
   22ab4:	0003f944 	.word	0x0003f944
   22ab8:	0003f8d4 	.word	0x0003f8d4
   22abc:	00042743 	.word	0x00042743
   22ac0:	20020d18 	.word	0x20020d18
   22ac4:	2002bdb5 	.word	0x2002bdb5
   22ac8:	00042b08 	.word	0x00042b08

00022acc <print_satellite_stats>:
{
   22acc:	b573      	push	{r0, r1, r4, r5, r6, lr}
	u8_t unhealthy = 0;
   22ace:	2100      	movs	r1, #0
	u8_t in_fix = 0;
   22ad0:	460b      	mov	r3, r1
	u8_t tracked = 0;
   22ad2:	460a      	mov	r2, r1
   22ad4:	f100 0590 	add.w	r5, r0, #144	; 0x90
		if ((pvt_data->pvt.sv[i].sv > 0) && (pvt_data->pvt.sv[i].sv < 33))
   22ad8:	f8b0 4046 	ldrh.w	r4, [r0, #70]	; 0x46
   22adc:	3c01      	subs	r4, #1
   22ade:	2c1f      	cmp	r4, #31
   22ae0:	d80c      	bhi.n	22afc <print_satellite_stats+0x30>
			if (pvt_data->pvt.sv[i].flags & NRF_GNSS_SV_FLAG_USED_IN_FIX)
   22ae2:	f890 4050 	ldrb.w	r4, [r0, #80]	; 0x50
			tracked++;
   22ae6:	3201      	adds	r2, #1
			if (pvt_data->pvt.sv[i].flags & NRF_GNSS_SV_FLAG_USED_IN_FIX)
   22ae8:	07a6      	lsls	r6, r4, #30
				in_fix++;
   22aea:	bf44      	itt	mi
   22aec:	3301      	addmi	r3, #1
   22aee:	b2db      	uxtbmi	r3, r3
			if (pvt_data->pvt.sv[i].flags & NRF_GNSS_SV_FLAG_UNHEALTHY)
   22af0:	0724      	lsls	r4, r4, #28
				unhealthy++;
   22af2:	bf48      	it	mi
   22af4:	3101      	addmi	r1, #1
			tracked++;
   22af6:	b2d2      	uxtb	r2, r2
				unhealthy++;
   22af8:	bf48      	it	mi
   22afa:	b2c9      	uxtbmi	r1, r1
   22afc:	300c      	adds	r0, #12
	for(i = 0; i < NRF_GNSS_MAX_SATELLITES; ++i)
   22afe:	42a8      	cmp	r0, r5
   22b00:	d1ea      	bne.n	22ad8 <print_satellite_stats+0xc>
	LOG_INF("Tracking: %d Using: %d Unhealthy: %d", tracked, in_fix, unhealthy);
   22b02:	2403      	movs	r4, #3
   22b04:	f04f 0000 	mov.w	r0, #0
   22b08:	4d15      	ldr	r5, [pc, #84]	; (22b60 <print_satellite_stats+0x94>)
   22b0a:	f364 0007 	bfi	r0, r4, #0, #8
   22b0e:	4c15      	ldr	r4, [pc, #84]	; (22b64 <print_satellite_stats+0x98>)
   22b10:	9100      	str	r1, [sp, #0]
   22b12:	1b64      	subs	r4, r4, r5
   22b14:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   22b18:	f364 108f 	bfi	r0, r4, #6, #10
   22b1c:	4912      	ldr	r1, [pc, #72]	; (22b68 <print_satellite_stats+0x9c>)
   22b1e:	f019 fe5c 	bl	3c7da <log_string_sync>
	LOG_INF("\nSeconds since last fix %lld\n", (k_uptime_get() - fix_timestamp) / 1000);
   22b22:	f04f 0500 	mov.w	r5, #0
   22b26:	2303      	movs	r3, #3
   22b28:	f363 0507 	bfi	r5, r3, #0, #8
   22b2c:	f364 158f 	bfi	r5, r4, #6, #10
	return z_impl_k_uptime_get();
   22b30:	f01b fdcf 	bl	3e6d2 <z_impl_k_uptime_get>
   22b34:	4b0d      	ldr	r3, [pc, #52]	; (22b6c <print_satellite_stats+0xa0>)
   22b36:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   22b3a:	e9d3 4600 	ldrd	r4, r6, [r3]
   22b3e:	1b00      	subs	r0, r0, r4
   22b40:	f04f 0300 	mov.w	r3, #0
   22b44:	eb61 0106 	sbc.w	r1, r1, r6
   22b48:	f7fa f940 	bl	1cdcc <__aeabi_uldivmod>
   22b4c:	4602      	mov	r2, r0
   22b4e:	460b      	mov	r3, r1
   22b50:	4628      	mov	r0, r5
   22b52:	4907      	ldr	r1, [pc, #28]	; (22b70 <print_satellite_stats+0xa4>)
}
   22b54:	b002      	add	sp, #8
   22b56:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	LOG_INF("\nSeconds since last fix %lld\n", (k_uptime_get() - fix_timestamp) / 1000);
   22b5a:	f019 be3e 	b.w	3c7da <log_string_sync>
   22b5e:	bf00      	nop
   22b60:	0003f8d4 	.word	0x0003f8d4
   22b64:	0003f944 	.word	0x0003f944
   22b68:	00040c6c 	.word	0x00040c6c
   22b6c:	20020000 	.word	0x20020000
   22b70:	00040c91 	.word	0x00040c91

00022b74 <process_gps_data>:
{
   22b74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	retval = nrf_recv(gnss_fd,
   22b76:	4601      	mov	r1, r0
{
   22b78:	4604      	mov	r4, r0
	retval = nrf_recv(gnss_fd,
   22b7a:	481f      	ldr	r0, [pc, #124]	; (22bf8 <process_gps_data+0x84>)
   22b7c:	2302      	movs	r3, #2
   22b7e:	22d8      	movs	r2, #216	; 0xd8
   22b80:	6800      	ldr	r0, [r0, #0]
   22b82:	f00e f9ef 	bl	30f64 <nrf_recv>
	if(retval > 0) 
   22b86:	1e06      	subs	r6, r0, #0
   22b88:	dd04      	ble.n	22b94 <process_gps_data+0x20>
		switch (gps_data->data_id)
   22b8a:	7823      	ldrb	r3, [r4, #0]
   22b8c:	2b01      	cmp	r3, #1
   22b8e:	d003      	beq.n	22b98 <process_gps_data+0x24>
   22b90:	2b02      	cmp	r3, #2
   22b92:	d01c      	beq.n	22bce <process_gps_data+0x5a>
}
   22b94:	4630      	mov	r0, r6
   22b96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if((gps_data->pvt.flags & NRF_GNSS_PVT_FLAG_FIX_VALID_BIT)	== NRF_GNSS_PVT_FLAG_FIX_VALID_BIT)
   22b98:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
   22b9c:	4d17      	ldr	r5, [pc, #92]	; (22bfc <process_gps_data+0x88>)
   22b9e:	f012 0f01 	tst.w	r2, #1
   22ba2:	d00f      	beq.n	22bc4 <process_gps_data+0x50>
				if (!got_first_fix)
   22ba4:	4a16      	ldr	r2, [pc, #88]	; (22c00 <process_gps_data+0x8c>)
   22ba6:	7811      	ldrb	r1, [r2, #0]
   22ba8:	b901      	cbnz	r1, 22bac <process_gps_data+0x38>
					got_first_fix = true;
   22baa:	7013      	strb	r3, [r2, #0]
   22bac:	f01b fd91 	bl	3e6d2 <z_impl_k_uptime_get>
				fix_timestamp = k_uptime_get();
   22bb0:	4b14      	ldr	r3, [pc, #80]	; (22c04 <process_gps_data+0x90>)
				memcpy(&last_fix,
   22bb2:	22d8      	movs	r2, #216	; 0xd8
				fix_timestamp = k_uptime_get();
   22bb4:	e9c3 0100 	strd	r0, r1, [r3]
				memcpy(&last_fix,
   22bb8:	4621      	mov	r1, r4
   22bba:	4813      	ldr	r0, [pc, #76]	; (22c08 <process_gps_data+0x94>)
   22bbc:	f01b fe46 	bl	3e84c <memcpy>
				nmea_string_cnt = 0;
   22bc0:	2300      	movs	r3, #0
   22bc2:	602b      	str	r3, [r5, #0]
			print_nmea_data();
   22bc4:	f7ff ff48 	bl	22a58 <print_nmea_data>
			nmea_string_cnt = 0;
   22bc8:	2300      	movs	r3, #0
   22bca:	602b      	str	r3, [r5, #0]
			break;
   22bcc:	e7e2      	b.n	22b94 <process_gps_data+0x20>
			if (nmea_string_cnt < 10) 
   22bce:	4f0b      	ldr	r7, [pc, #44]	; (22bfc <process_gps_data+0x88>)
   22bd0:	683d      	ldr	r5, [r7, #0]
   22bd2:	2d09      	cmp	r5, #9
   22bd4:	d8de      	bhi.n	22b94 <process_gps_data+0x20>
				memset(nmea_strings[nmea_string_cnt],
   22bd6:	2253      	movs	r2, #83	; 0x53
   22bd8:	4b0c      	ldr	r3, [pc, #48]	; (22c0c <process_gps_data+0x98>)
__ssp_bos_icheck3(memset, void *, int)
   22bda:	2100      	movs	r1, #0
   22bdc:	fb02 3305 	mla	r3, r2, r5, r3
   22be0:	4618      	mov	r0, r3
   22be2:	f01b fe53 	bl	3e88c <memset>
				memcpy(nmea_strings[nmea_string_cnt++],
   22be6:	3501      	adds	r5, #1
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   22be8:	4632      	mov	r2, r6
   22bea:	f104 0108 	add.w	r1, r4, #8
   22bee:	603d      	str	r5, [r7, #0]
   22bf0:	f01b fe2c 	bl	3e84c <memcpy>
	return retval;
   22bf4:	e7ce      	b.n	22b94 <process_gps_data+0x20>
   22bf6:	bf00      	nop
   22bf8:	20020ce8 	.word	0x20020ce8
   22bfc:	20020d18 	.word	0x20020d18
   22c00:	2002bdb1 	.word	0x2002bdb1
   22c04:	20020000 	.word	0x20020000
   22c08:	20020008 	.word	0x20020008
   22c0c:	2002bdb5 	.word	0x2002bdb5

00022c10 <APP_Ask_GPS_Data>:
{
   22c10:	b508      	push	{r3, lr}
	app_gps_on = true;
   22c12:	2301      	movs	r3, #1
   22c14:	4a09      	ldr	r2, [pc, #36]	; (22c3c <APP_Ask_GPS_Data+0x2c>)
	if(time_init == false)
   22c16:	490a      	ldr	r1, [pc, #40]	; (22c40 <APP_Ask_GPS_Data+0x30>)
	app_gps_on = true;
   22c18:	7013      	strb	r3, [r2, #0]
	APP_wait_gps = true;
   22c1a:	4a0a      	ldr	r2, [pc, #40]	; (22c44 <APP_Ask_GPS_Data+0x34>)
   22c1c:	7013      	strb	r3, [r2, #0]
	if(time_init == false)
   22c1e:	780a      	ldrb	r2, [r1, #0]
   22c20:	b922      	cbnz	r2, 22c2c <APP_Ask_GPS_Data+0x1c>
		time_init = true;
   22c22:	700b      	strb	r3, [r1, #0]
		k_timer_init(&app_wait_gps_timer, APP_Ask_GPS_Data_timerout, NULL);
   22c24:	4808      	ldr	r0, [pc, #32]	; (22c48 <APP_Ask_GPS_Data+0x38>)
   22c26:	4909      	ldr	r1, [pc, #36]	; (22c4c <APP_Ask_GPS_Data+0x3c>)
   22c28:	f01b fd61 	bl	3e6ee <k_timer_init>
}
   22c2c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_impl_k_timer_start(timer, duration, period);
   22c30:	2200      	movs	r2, #0
   22c32:	4907      	ldr	r1, [pc, #28]	; (22c50 <APP_Ask_GPS_Data+0x40>)
   22c34:	4804      	ldr	r0, [pc, #16]	; (22c48 <APP_Ask_GPS_Data+0x38>)
   22c36:	f015 bd31 	b.w	3869c <z_impl_k_timer_start>
   22c3a:	bf00      	nop
   22c3c:	2002bdaf 	.word	0x2002bdaf
   22c40:	2002c0f3 	.word	0x2002c0f3
   22c44:	2002b926 	.word	0x2002b926
   22c48:	20020cbc 	.word	0x20020cbc
   22c4c:	0001d169 	.word	0x0001d169
   22c50:	0002bf20 	.word	0x0002bf20

00022c54 <gps_init>:

void gps_init(void)
{
   22c54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	for(i = 0; i < ARRAY_SIZE(at_commands_activate_gps); i++)
   22c58:	2700      	movs	r7, #0
   22c5a:	4c52      	ldr	r4, [pc, #328]	; (22da4 <gps_init+0x150>)
{
   22c5c:	b086      	sub	sp, #24
		if(at_cmd_write(at_commands_activate_gps[i], NULL, 0, NULL) != 0)
   22c5e:	2300      	movs	r3, #0
   22c60:	4620      	mov	r0, r4
   22c62:	461a      	mov	r2, r3
   22c64:	4619      	mov	r1, r3
   22c66:	f008 fbf3 	bl	2b450 <at_cmd_write>
   22c6a:	2800      	cmp	r0, #0
   22c6c:	f040 808c 	bne.w	22d88 <gps_init+0x134>
	for(i = 0; i < ARRAY_SIZE(at_commands_activate_gps); i++)
   22c70:	3701      	adds	r7, #1
   22c72:	2f04      	cmp	r7, #4
   22c74:	f104 041f 	add.w	r4, r4, #31
   22c78:	d1f1      	bne.n	22c5e <gps_init+0xa>
	nrf_gnss_fix_interval_t fix_interval = 1;
   22c7a:	f04f 0801 	mov.w	r8, #1
	nrf_gnss_nmea_mask_t nmea_mask = NRF_GNSS_NMEA_GSV_MASK |
   22c7e:	231f      	movs	r3, #31
	nrf_gnss_fix_retry_t fix_retry    = 0;
   22c80:	f8ad 000e 	strh.w	r0, [sp, #14]
	nrf_gnss_delete_mask_t delete_mask  = 0;
   22c84:	9005      	str	r0, [sp, #20]
		gnss_fd = nrf_socket(NRF_AF_LOCAL,
   22c86:	f44f 7201 	mov.w	r2, #516	; 0x204
   22c8a:	2102      	movs	r1, #2
   22c8c:	4640      	mov	r0, r8
	nrf_gnss_nmea_mask_t nmea_mask = NRF_GNSS_NMEA_GSV_MASK |
   22c8e:	f8ad 3012 	strh.w	r3, [sp, #18]
	nrf_gnss_fix_interval_t fix_interval = 1;
   22c92:	f8ad 8010 	strh.w	r8, [sp, #16]
		gnss_fd = nrf_socket(NRF_AF_LOCAL,
   22c96:	f00e f8f3 	bl	30e80 <nrf_socket>
   22c9a:	4c43      	ldr	r4, [pc, #268]	; (22da8 <gps_init+0x154>)
   22c9c:	4b43      	ldr	r3, [pc, #268]	; (22dac <gps_init+0x158>)
   22c9e:	4d44      	ldr	r5, [pc, #272]	; (22db0 <gps_init+0x15c>)
   22ca0:	1ae4      	subs	r4, r4, r3
		if(gnss_fd >= 0)
   22ca2:	2800      	cmp	r0, #0
		gnss_fd = nrf_socket(NRF_AF_LOCAL,
   22ca4:	4602      	mov	r2, r0
   22ca6:	6028      	str	r0, [r5, #0]
		if(gnss_fd >= 0)
   22ca8:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   22cac:	da0c      	bge.n	22cc8 <gps_init+0x74>
			LOG_INF("Could not init socket (err: %d)\n", gnss_fd);
   22cae:	f04f 0000 	mov.w	r0, #0
   22cb2:	2303      	movs	r3, #3
   22cb4:	f363 0007 	bfi	r0, r3, #0, #8
   22cb8:	f364 108f 	bfi	r0, r4, #6, #10
   22cbc:	493d      	ldr	r1, [pc, #244]	; (22db4 <gps_init+0x160>)
   22cbe:	f019 fd8c 	bl	3c7da <log_string_sync>
	}

	gps_is_inited = true;

	k_timer_init(&gps_data_timer, gps_data_wait_timerout, NULL);
}
   22cc2:	b006      	add	sp, #24
   22cc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			LOG_INF("GPS Socket created\n");
   22cc8:	2303      	movs	r3, #3
   22cca:	f04f 0000 	mov.w	r0, #0
		retval = nrf_setsockopt(gnss_fd,
   22cce:	2602      	movs	r6, #2
			LOG_INF("GPS Socket created\n");
   22cd0:	f363 0007 	bfi	r0, r3, #0, #8
   22cd4:	f364 108f 	bfi	r0, r4, #6, #10
   22cd8:	4937      	ldr	r1, [pc, #220]	; (22db8 <gps_init+0x164>)
   22cda:	f019 fd7e 	bl	3c7da <log_string_sync>
		retval = nrf_setsockopt(gnss_fd,
   22cde:	9600      	str	r6, [sp, #0]
   22ce0:	f10d 030e 	add.w	r3, sp, #14
   22ce4:	4632      	mov	r2, r6
   22ce6:	f44f 7101 	mov.w	r1, #516	; 0x204
   22cea:	6828      	ldr	r0, [r5, #0]
   22cec:	f00e f99e 	bl	3102c <nrf_setsockopt>
		if(retval != 0)
   22cf0:	b150      	cbz	r0, 22d08 <gps_init+0xb4>
			LOG_INF("Failed to set fix retry value\n");
   22cf2:	f04f 0000 	mov.w	r0, #0
   22cf6:	2303      	movs	r3, #3
   22cf8:	4930      	ldr	r1, [pc, #192]	; (22dbc <gps_init+0x168>)
   22cfa:	f363 0007 	bfi	r0, r3, #0, #8
   22cfe:	f364 108f 	bfi	r0, r4, #6, #10
		LOG_INF("Failed to initialize modem\n");
   22d02:	f019 fd6a 	bl	3c7da <log_string_sync>
		return -1;
   22d06:	e7dc      	b.n	22cc2 <gps_init+0x6e>
		retval = nrf_setsockopt(gnss_fd,
   22d08:	9600      	str	r6, [sp, #0]
   22d0a:	ab04      	add	r3, sp, #16
   22d0c:	4642      	mov	r2, r8
   22d0e:	f44f 7101 	mov.w	r1, #516	; 0x204
   22d12:	6828      	ldr	r0, [r5, #0]
   22d14:	f00e f98a 	bl	3102c <nrf_setsockopt>
		if(retval != 0)
   22d18:	b140      	cbz	r0, 22d2c <gps_init+0xd8>
			LOG_INF("Failed to set fix interval value\n");
   22d1a:	f04f 0000 	mov.w	r0, #0
   22d1e:	2303      	movs	r3, #3
   22d20:	f363 0007 	bfi	r0, r3, #0, #8
   22d24:	f364 108f 	bfi	r0, r4, #6, #10
   22d28:	4925      	ldr	r1, [pc, #148]	; (22dc0 <gps_init+0x16c>)
   22d2a:	e7ea      	b.n	22d02 <gps_init+0xae>
		retval = nrf_setsockopt(gnss_fd,
   22d2c:	9600      	str	r6, [sp, #0]
   22d2e:	f10d 0312 	add.w	r3, sp, #18
   22d32:	463a      	mov	r2, r7
   22d34:	f44f 7101 	mov.w	r1, #516	; 0x204
   22d38:	6828      	ldr	r0, [r5, #0]
   22d3a:	f00e f977 	bl	3102c <nrf_setsockopt>
		if(retval != 0)
   22d3e:	b140      	cbz	r0, 22d52 <gps_init+0xfe>
			LOG_INF("Failed to set nmea mask\n");
   22d40:	f04f 0000 	mov.w	r0, #0
   22d44:	2303      	movs	r3, #3
   22d46:	f363 0007 	bfi	r0, r3, #0, #8
   22d4a:	f364 108f 	bfi	r0, r4, #6, #10
   22d4e:	491d      	ldr	r1, [pc, #116]	; (22dc4 <gps_init+0x170>)
   22d50:	e7d7      	b.n	22d02 <gps_init+0xae>
		retval = nrf_setsockopt(gnss_fd,
   22d52:	2207      	movs	r2, #7
   22d54:	9700      	str	r7, [sp, #0]
   22d56:	ab05      	add	r3, sp, #20
   22d58:	f44f 7101 	mov.w	r1, #516	; 0x204
   22d5c:	6828      	ldr	r0, [r5, #0]
   22d5e:	f00e f965 	bl	3102c <nrf_setsockopt>
		if(retval != 0)
   22d62:	4602      	mov	r2, r0
   22d64:	b938      	cbnz	r0, 22d76 <gps_init+0x122>
	gps_is_inited = true;
   22d66:	4b18      	ldr	r3, [pc, #96]	; (22dc8 <gps_init+0x174>)
	k_timer_init(&gps_data_timer, gps_data_wait_timerout, NULL);
   22d68:	4918      	ldr	r1, [pc, #96]	; (22dcc <gps_init+0x178>)
   22d6a:	4819      	ldr	r0, [pc, #100]	; (22dd0 <gps_init+0x17c>)
	gps_is_inited = true;
   22d6c:	f883 8000 	strb.w	r8, [r3]
	k_timer_init(&gps_data_timer, gps_data_wait_timerout, NULL);
   22d70:	f01b fcbd 	bl	3e6ee <k_timer_init>
   22d74:	e7a5      	b.n	22cc2 <gps_init+0x6e>
			LOG_INF("Failed to start GPS\n");
   22d76:	f04f 0000 	mov.w	r0, #0
   22d7a:	2303      	movs	r3, #3
   22d7c:	f363 0007 	bfi	r0, r3, #0, #8
   22d80:	f364 108f 	bfi	r0, r4, #6, #10
   22d84:	4913      	ldr	r1, [pc, #76]	; (22dd4 <gps_init+0x180>)
   22d86:	e7bc      	b.n	22d02 <gps_init+0xae>
		LOG_INF("Failed to initialize modem\n");
   22d88:	2303      	movs	r3, #3
   22d8a:	f04f 0000 	mov.w	r0, #0
   22d8e:	4a07      	ldr	r2, [pc, #28]	; (22dac <gps_init+0x158>)
   22d90:	f363 0007 	bfi	r0, r3, #0, #8
   22d94:	4b04      	ldr	r3, [pc, #16]	; (22da8 <gps_init+0x154>)
   22d96:	4910      	ldr	r1, [pc, #64]	; (22dd8 <gps_init+0x184>)
   22d98:	1a9b      	subs	r3, r3, r2
   22d9a:	08db      	lsrs	r3, r3, #3
   22d9c:	f363 108f 	bfi	r0, r3, #6, #10
   22da0:	e7af      	b.n	22d02 <gps_init+0xae>
   22da2:	bf00      	nop
   22da4:	000409d8 	.word	0x000409d8
   22da8:	0003f944 	.word	0x0003f944
   22dac:	0003f8d4 	.word	0x0003f8d4
   22db0:	20020ce8 	.word	0x20020ce8
   22db4:	00040b4f 	.word	0x00040b4f
   22db8:	00040b3b 	.word	0x00040b3b
   22dbc:	00040b70 	.word	0x00040b70
   22dc0:	00040b8f 	.word	0x00040b8f
   22dc4:	00040bb1 	.word	0x00040bb1
   22dc8:	2002bdb3 	.word	0x2002bdb3
   22dcc:	00022a4d 	.word	0x00022a4d
   22dd0:	20020cec 	.word	0x20020cec
   22dd4:	00040bca 	.word	0x00040bca
   22dd8:	00040bdf 	.word	0x00040bdf

00022ddc <gps_restart>:

void gps_restart(void)
{
   22ddc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	nrf_gnss_delete_mask_t delete_mask  = 0;
   22dde:	2300      	movs	r3, #0
   22de0:	9303      	str	r3, [sp, #12]
		retval = nrf_setsockopt(gnss_fd,
   22de2:	2304      	movs	r3, #4
   22de4:	480d      	ldr	r0, [pc, #52]	; (22e1c <gps_restart+0x40>)
   22de6:	9300      	str	r3, [sp, #0]
   22de8:	2207      	movs	r2, #7
   22dea:	ab03      	add	r3, sp, #12
   22dec:	f44f 7101 	mov.w	r1, #516	; 0x204
   22df0:	6800      	ldr	r0, [r0, #0]
   22df2:	f00e f91b 	bl	3102c <nrf_setsockopt>
		if(retval != 0)
   22df6:	b168      	cbz	r0, 22e14 <gps_restart+0x38>
			LOG_INF("Failed to start GPS\n");
   22df8:	2303      	movs	r3, #3
   22dfa:	f04f 0000 	mov.w	r0, #0
   22dfe:	4a08      	ldr	r2, [pc, #32]	; (22e20 <gps_restart+0x44>)
   22e00:	f363 0007 	bfi	r0, r3, #0, #8
   22e04:	4b07      	ldr	r3, [pc, #28]	; (22e24 <gps_restart+0x48>)
   22e06:	4908      	ldr	r1, [pc, #32]	; (22e28 <gps_restart+0x4c>)
   22e08:	1a9b      	subs	r3, r3, r2
   22e0a:	08db      	lsrs	r3, r3, #3
   22e0c:	f363 108f 	bfi	r0, r3, #6, #10
   22e10:	f019 fce3 	bl	3c7da <log_string_sync>
	gnss_ctrl(GNSS_RESTART);
}
   22e14:	b005      	add	sp, #20
   22e16:	f85d fb04 	ldr.w	pc, [sp], #4
   22e1a:	bf00      	nop
   22e1c:	20020ce8 	.word	0x20020ce8
   22e20:	0003f8d4 	.word	0x0003f8d4
   22e24:	0003f944 	.word	0x0003f944
   22e28:	00040bca 	.word	0x00040bca

00022e2c <gps_off>:

void gps_off(void)
{
   22e2c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	if(!gps_is_on)
   22e2e:	4b1d      	ldr	r3, [pc, #116]	; (22ea4 <gps_off+0x78>)
   22e30:	781a      	ldrb	r2, [r3, #0]
   22e32:	b98a      	cbnz	r2, 22e58 <gps_off+0x2c>
	{
		LOG_INF("gps is been truned off\n");
   22e34:	2303      	movs	r3, #3
   22e36:	f04f 0000 	mov.w	r0, #0
   22e3a:	4a1b      	ldr	r2, [pc, #108]	; (22ea8 <gps_off+0x7c>)
   22e3c:	f363 0007 	bfi	r0, r3, #0, #8
   22e40:	4b1a      	ldr	r3, [pc, #104]	; (22eac <gps_off+0x80>)
   22e42:	491b      	ldr	r1, [pc, #108]	; (22eb0 <gps_off+0x84>)
   22e44:	1a9b      	subs	r3, r3, r2
   22e46:	08db      	lsrs	r3, r3, #3
   22e48:	f363 108f 	bfi	r0, r3, #6, #10
			LOG_INF("Failed to stop GPS\n");
   22e4c:	f019 fcc5 	bl	3c7da <log_string_sync>
	//#ifdef SHOW_LOG_IN_SCREEN	
	//	show_infor("Failed to reset modem");
	//#endif	
	//}

	GoBackHistoryScreen();
   22e50:	f002 fc3e 	bl	256d0 <GoBackHistoryScreen>
}
   22e54:	b004      	add	sp, #16
   22e56:	bd10      	pop	{r4, pc}
	gps_is_on = false;
   22e58:	2400      	movs	r4, #0
   22e5a:	701c      	strb	r4, [r3, #0]
	got_first_fix = false;
   22e5c:	4b15      	ldr	r3, [pc, #84]	; (22eb4 <gps_off+0x88>)
   22e5e:	701c      	strb	r4, [r3, #0]
	gps_data_incoming = false;
   22e60:	4b15      	ldr	r3, [pc, #84]	; (22eb8 <gps_off+0x8c>)
   22e62:	701c      	strb	r4, [r3, #0]
	z_impl_k_timer_stop(timer);
   22e64:	4815      	ldr	r0, [pc, #84]	; (22ebc <gps_off+0x90>)
   22e66:	f01b fc4e 	bl	3e706 <z_impl_k_timer_stop>
   22e6a:	4815      	ldr	r0, [pc, #84]	; (22ec0 <gps_off+0x94>)
   22e6c:	f01b fc4b 	bl	3e706 <z_impl_k_timer_stop>
		retval = nrf_setsockopt(gnss_fd,
   22e70:	2304      	movs	r3, #4
   22e72:	4814      	ldr	r0, [pc, #80]	; (22ec4 <gps_off+0x98>)
   22e74:	9300      	str	r3, [sp, #0]
   22e76:	2208      	movs	r2, #8
   22e78:	ab03      	add	r3, sp, #12
   22e7a:	f44f 7101 	mov.w	r1, #516	; 0x204
   22e7e:	6800      	ldr	r0, [r0, #0]
	nrf_gnss_delete_mask_t delete_mask  = 0;
   22e80:	9403      	str	r4, [sp, #12]
		retval = nrf_setsockopt(gnss_fd,
   22e82:	f00e f8d3 	bl	3102c <nrf_setsockopt>
		if(retval != 0)
   22e86:	2800      	cmp	r0, #0
   22e88:	d0e2      	beq.n	22e50 <gps_off+0x24>
			LOG_INF("Failed to stop GPS\n");
   22e8a:	2303      	movs	r3, #3
   22e8c:	f04f 0000 	mov.w	r0, #0
   22e90:	4a05      	ldr	r2, [pc, #20]	; (22ea8 <gps_off+0x7c>)
   22e92:	f363 0007 	bfi	r0, r3, #0, #8
   22e96:	4b05      	ldr	r3, [pc, #20]	; (22eac <gps_off+0x80>)
   22e98:	490b      	ldr	r1, [pc, #44]	; (22ec8 <gps_off+0x9c>)
   22e9a:	1a9b      	subs	r3, r3, r2
   22e9c:	08db      	lsrs	r3, r3, #3
   22e9e:	f363 108f 	bfi	r0, r3, #6, #10
   22ea2:	e7d3      	b.n	22e4c <gps_off+0x20>
   22ea4:	2002bdb4 	.word	0x2002bdb4
   22ea8:	0003f8d4 	.word	0x0003f8d4
   22eac:	0003f944 	.word	0x0003f944
   22eb0:	00040bfb 	.word	0x00040bfb
   22eb4:	2002bdb1 	.word	0x2002bdb1
   22eb8:	2002bdb2 	.word	0x2002bdb2
   22ebc:	20020cec 	.word	0x20020cec
   22ec0:	20020cbc 	.word	0x20020cbc
   22ec4:	20020ce8 	.word	0x20020ce8
   22ec8:	00040c13 	.word	0x00040c13

00022ecc <gps_on>:

void gps_on(void)
{
   22ecc:	b538      	push	{r3, r4, r5, lr}
		.logger     = supl_logger,
		.counter_ms = k_uptime_get
	};
#endif

	if(gps_is_on)
   22ece:	4d20      	ldr	r5, [pc, #128]	; (22f50 <gps_on+0x84>)
   22ed0:	4c20      	ldr	r4, [pc, #128]	; (22f54 <gps_on+0x88>)
   22ed2:	4b21      	ldr	r3, [pc, #132]	; (22f58 <gps_on+0x8c>)
   22ed4:	782a      	ldrb	r2, [r5, #0]
   22ed6:	1ae4      	subs	r4, r4, r3
   22ed8:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   22edc:	b15a      	cbz	r2, 22ef6 <gps_on+0x2a>
	{
		LOG_INF("gps is been truned on\n");
   22ede:	2303      	movs	r3, #3
   22ee0:	f04f 0000 	mov.w	r0, #0
   22ee4:	f363 0007 	bfi	r0, r3, #0, #8
   22ee8:	f364 108f 	bfi	r0, r4, #6, #10
   22eec:	491b      	ldr	r1, [pc, #108]	; (22f5c <gps_on+0x90>)
#ifdef SHOW_LOG_IN_SCREEN
	show_infor("Getting GPS data...");
#endif

	k_timer_start(&gps_data_timer, K_MSEC(500), K_MSEC(1000));
}
   22eee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		LOG_INF("gps is been truned on\n");
   22ef2:	f019 bc72 	b.w	3c7da <log_string_sync>
	EnterGPSTestScreen();
   22ef6:	f002 fbbb 	bl	25670 <EnterGPSTestScreen>
	LOG_INF("Staring GPS application\n");
   22efa:	2303      	movs	r3, #3
   22efc:	f04f 0000 	mov.w	r0, #0
   22f00:	f363 0007 	bfi	r0, r3, #0, #8
   22f04:	f364 108f 	bfi	r0, r4, #6, #10
   22f08:	4915      	ldr	r1, [pc, #84]	; (22f60 <gps_on+0x94>)
   22f0a:	f019 fc66 	bl	3c7da <log_string_sync>
	if(gps_is_inited == false)
   22f0e:	4b15      	ldr	r3, [pc, #84]	; (22f64 <gps_on+0x98>)
   22f10:	781b      	ldrb	r3, [r3, #0]
   22f12:	b9cb      	cbnz	r3, 22f48 <gps_on+0x7c>
		gps_init();
   22f14:	f7ff fe9e 	bl	22c54 <gps_init>
	cnt = 0;
   22f18:	2200      	movs	r2, #0
   22f1a:	4b13      	ldr	r3, [pc, #76]	; (22f68 <gps_on+0x9c>)
	LOG_INF("Getting GPS data...\n");
   22f1c:	f04f 0000 	mov.w	r0, #0
	cnt = 0;
   22f20:	701a      	strb	r2, [r3, #0]
	gps_is_on = true;
   22f22:	2301      	movs	r3, #1
   22f24:	702b      	strb	r3, [r5, #0]
	LOG_INF("Getting GPS data...\n");
   22f26:	2303      	movs	r3, #3
   22f28:	f363 0007 	bfi	r0, r3, #0, #8
   22f2c:	f364 108f 	bfi	r0, r4, #6, #10
   22f30:	490e      	ldr	r1, [pc, #56]	; (22f6c <gps_on+0xa0>)
   22f32:	f019 fc52 	bl	3c7da <log_string_sync>
}
   22f36:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_timer_start(timer, duration, period);
   22f3a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   22f3e:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
   22f42:	480b      	ldr	r0, [pc, #44]	; (22f70 <gps_on+0xa4>)
   22f44:	f015 bbaa 	b.w	3869c <z_impl_k_timer_start>
		gps_restart();
   22f48:	f7ff ff48 	bl	22ddc <gps_restart>
   22f4c:	e7e4      	b.n	22f18 <gps_on+0x4c>
   22f4e:	bf00      	nop
   22f50:	2002bdb4 	.word	0x2002bdb4
   22f54:	0003f944 	.word	0x0003f944
   22f58:	0003f8d4 	.word	0x0003f8d4
   22f5c:	00040c27 	.word	0x00040c27
   22f60:	00040c3e 	.word	0x00040c3e
   22f64:	2002bdb3 	.word	0x2002bdb3
   22f68:	2002bdb0 	.word	0x2002bdb0
   22f6c:	00040c57 	.word	0x00040c57
   22f70:	20020cec 	.word	0x20020cec

00022f74 <GPSMsgProcess>:

void GPSMsgProcess(void)
{
   22f74:	b508      	push	{r3, lr}
	if(app_gps_on)
   22f76:	4b0c      	ldr	r3, [pc, #48]	; (22fa8 <GPSMsgProcess+0x34>)
   22f78:	781a      	ldrb	r2, [r3, #0]
   22f7a:	b11a      	cbz	r2, 22f84 <GPSMsgProcess+0x10>
	{
		app_gps_on = false;
   22f7c:	2200      	movs	r2, #0
   22f7e:	701a      	strb	r2, [r3, #0]
		gps_on();
   22f80:	f7ff ffa4 	bl	22ecc <gps_on>
	}
	if(app_gps_off)
   22f84:	4b09      	ldr	r3, [pc, #36]	; (22fac <GPSMsgProcess+0x38>)
   22f86:	781a      	ldrb	r2, [r3, #0]
   22f88:	b11a      	cbz	r2, 22f92 <GPSMsgProcess+0x1e>
	{
		app_gps_off = false;
   22f8a:	2200      	movs	r2, #0
   22f8c:	701a      	strb	r2, [r3, #0]
		gps_off();
   22f8e:	f7ff ff4d 	bl	22e2c <gps_off>
	}
	if(gps_data_incoming)
   22f92:	4b07      	ldr	r3, [pc, #28]	; (22fb0 <GPSMsgProcess+0x3c>)
   22f94:	781a      	ldrb	r2, [r3, #0]
   22f96:	b12a      	cbz	r2, 22fa4 <GPSMsgProcess+0x30>
	{
		gps_data_incoming = false;
   22f98:	2200      	movs	r2, #0
   22f9a:	701a      	strb	r2, [r3, #0]
		gps_data_receive();
	}	
}
   22f9c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		gps_data_receive();
   22fa0:	f7fa b982 	b.w	1d2a8 <gps_data_receive>
}
   22fa4:	bd08      	pop	{r3, pc}
   22fa6:	bf00      	nop
   22fa8:	2002bdaf 	.word	0x2002bdaf
   22fac:	2002bdae 	.word	0x2002bdae
   22fb0:	2002bdb2 	.word	0x2002bdb2

00022fb4 <modem_rsrp_handler>:
}

#if CONFIG_MODEM_INFO
/**@brief Callback handler for LTE RSRP data. */
static void modem_rsrp_handler(char rsrp_value)
{
   22fb4:	b510      	push	{r4, lr}
	/* RSRP raw values that represent actual signal strength are
	 * 0 through 97 (per "nRF91 AT Commands" v1.1). If the received value
	 * falls outside this range, we should not send the value.
	 */
	LOG_INF("rsrp_value:%d\n", rsrp_value);
   22fb6:	2303      	movs	r3, #3
{
   22fb8:	4604      	mov	r4, r0
	LOG_INF("rsrp_value:%d\n", rsrp_value);
   22fba:	f04f 0000 	mov.w	r0, #0
   22fbe:	4a11      	ldr	r2, [pc, #68]	; (23004 <modem_rsrp_handler+0x50>)
   22fc0:	f363 0007 	bfi	r0, r3, #0, #8
   22fc4:	4b10      	ldr	r3, [pc, #64]	; (23008 <modem_rsrp_handler+0x54>)
   22fc6:	4911      	ldr	r1, [pc, #68]	; (2300c <modem_rsrp_handler+0x58>)
   22fc8:	1a9b      	subs	r3, r3, r2
   22fca:	08db      	lsrs	r3, r3, #3
   22fcc:	f363 108f 	bfi	r0, r3, #6, #10
   22fd0:	4622      	mov	r2, r4
   22fd2:	f019 fc02 	bl	3c7da <log_string_sync>

	if(rsrp_value > 97)
   22fd6:	2c61      	cmp	r4, #97	; 0x61
   22fd8:	4b0d      	ldr	r3, [pc, #52]	; (23010 <modem_rsrp_handler+0x5c>)
   22fda:	d902      	bls.n	22fe2 <modem_rsrp_handler+0x2e>
	{
		g_nb_sig = NB_SIG_LEVEL_NO;
   22fdc:	2200      	movs	r2, #0
	{
		g_nb_sig = NB_SIG_LEVEL_2;
	}
	else if(rsrp_value >= 20)
	{
		g_nb_sig = NB_SIG_LEVEL_1;
   22fde:	701a      	strb	r2, [r3, #0]
	{
		g_nb_sig = NB_SIG_LEVEL_0;
	}

	nb_redraw_sig_flag = true;
}
   22fe0:	bd10      	pop	{r4, pc}
	else if(rsrp_value >= 80)
   22fe2:	2c4f      	cmp	r4, #79	; 0x4f
   22fe4:	d901      	bls.n	22fea <modem_rsrp_handler+0x36>
		g_nb_sig = NB_SIG_LEVEL_4;
   22fe6:	2204      	movs	r2, #4
   22fe8:	e7f9      	b.n	22fde <modem_rsrp_handler+0x2a>
	else if(rsrp_value >= 60)
   22fea:	2c3b      	cmp	r4, #59	; 0x3b
   22fec:	d901      	bls.n	22ff2 <modem_rsrp_handler+0x3e>
		g_nb_sig = NB_SIG_LEVEL_3;
   22fee:	2203      	movs	r2, #3
   22ff0:	e7f5      	b.n	22fde <modem_rsrp_handler+0x2a>
	else if(rsrp_value >= 40)
   22ff2:	2c27      	cmp	r4, #39	; 0x27
   22ff4:	d901      	bls.n	22ffa <modem_rsrp_handler+0x46>
		g_nb_sig = NB_SIG_LEVEL_2;
   22ff6:	2202      	movs	r2, #2
   22ff8:	e7f1      	b.n	22fde <modem_rsrp_handler+0x2a>
	else if(rsrp_value >= 20)
   22ffa:	2c13      	cmp	r4, #19
   22ffc:	d9ee      	bls.n	22fdc <modem_rsrp_handler+0x28>
		g_nb_sig = NB_SIG_LEVEL_1;
   22ffe:	2201      	movs	r2, #1
   23000:	e7ed      	b.n	22fde <modem_rsrp_handler+0x2a>
   23002:	bf00      	nop
   23004:	0003f8d4 	.word	0x0003f8d4
   23008:	0003f99c 	.word	0x0003f99c
   2300c:	00040d9e 	.word	0x00040d9e
   23010:	2002c115 	.word	0x2002c115

00023014 <data_print.constprop.4>:
static void data_print(u8_t *prefix, u8_t *data, size_t len)
   23014:	b5b0      	push	{r4, r5, r7, lr}
	char buf[len + 1];
   23016:	f101 0308 	add.w	r3, r1, #8
   2301a:	f023 0307 	bic.w	r3, r3, #7
static void data_print(u8_t *prefix, u8_t *data, size_t len)
   2301e:	af00      	add	r7, sp, #0
	char buf[len + 1];
   23020:	ebad 0d03 	sub.w	sp, sp, r3
static void data_print(u8_t *prefix, u8_t *data, size_t len)
   23024:	4605      	mov	r5, r0
   23026:	460c      	mov	r4, r1
   23028:	460a      	mov	r2, r1
   2302a:	4668      	mov	r0, sp
   2302c:	490b      	ldr	r1, [pc, #44]	; (2305c <data_print.constprop.4+0x48>)
   2302e:	f01b fc0d 	bl	3e84c <memcpy>
	buf[len] = 0;
   23032:	2300      	movs	r3, #0
	LOG_INF("%s%s\n", prefix, buf);
   23034:	f04f 0000 	mov.w	r0, #0
	buf[len] = 0;
   23038:	f80d 3004 	strb.w	r3, [sp, r4]
	LOG_INF("%s%s\n", prefix, buf);
   2303c:	2303      	movs	r3, #3
   2303e:	4a08      	ldr	r2, [pc, #32]	; (23060 <data_print.constprop.4+0x4c>)
   23040:	f363 0007 	bfi	r0, r3, #0, #8
   23044:	4b07      	ldr	r3, [pc, #28]	; (23064 <data_print.constprop.4+0x50>)
   23046:	4908      	ldr	r1, [pc, #32]	; (23068 <data_print.constprop.4+0x54>)
   23048:	1a9b      	subs	r3, r3, r2
   2304a:	08db      	lsrs	r3, r3, #3
   2304c:	f363 108f 	bfi	r0, r3, #6, #10
   23050:	462a      	mov	r2, r5
   23052:	466b      	mov	r3, sp
   23054:	f019 fbc1 	bl	3c7da <log_string_sync>
}
   23058:	46bd      	mov	sp, r7
   2305a:	bdb0      	pop	{r4, r5, r7, pc}
   2305c:	2002c117 	.word	0x2002c117
   23060:	0003f8d4 	.word	0x0003f8d4
   23064:	0003f99c 	.word	0x0003f99c
   23068:	00044320 	.word	0x00044320

0002306c <poll.constprop.7>:
	__ASSERT_NO_MSG(socket_ops->connect);

	return socket_ops->connect(sock, addr, addrlen);
}

static inline int poll(struct pollfd *fds, int nfds, int timeout)
   2306c:	b570      	push	{r4, r5, r6, lr}
{
	__ASSERT_NO_MSG(socket_ops);
   2306e:	4c11      	ldr	r4, [pc, #68]	; (230b4 <poll.constprop.7+0x48>)
static inline int poll(struct pollfd *fds, int nfds, int timeout)
   23070:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(socket_ops);
   23072:	6823      	ldr	r3, [r4, #0]
   23074:	b94b      	cbnz	r3, 2308a <poll.constprop.7+0x1e>
   23076:	4910      	ldr	r1, [pc, #64]	; (230b8 <poll.constprop.7+0x4c>)
   23078:	4810      	ldr	r0, [pc, #64]	; (230bc <poll.constprop.7+0x50>)
   2307a:	234d      	movs	r3, #77	; 0x4d
   2307c:	4a10      	ldr	r2, [pc, #64]	; (230c0 <poll.constprop.7+0x54>)
   2307e:	f019 fb55 	bl	3c72c <printk>
   23082:	214d      	movs	r1, #77	; 0x4d
   23084:	480e      	ldr	r0, [pc, #56]	; (230c0 <poll.constprop.7+0x54>)
   23086:	f019 fb97 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->poll);
   2308a:	6823      	ldr	r3, [r4, #0]
   2308c:	699b      	ldr	r3, [r3, #24]
   2308e:	b94b      	cbnz	r3, 230a4 <poll.constprop.7+0x38>
   23090:	490c      	ldr	r1, [pc, #48]	; (230c4 <poll.constprop.7+0x58>)
   23092:	480a      	ldr	r0, [pc, #40]	; (230bc <poll.constprop.7+0x50>)
   23094:	234e      	movs	r3, #78	; 0x4e
   23096:	4a0a      	ldr	r2, [pc, #40]	; (230c0 <poll.constprop.7+0x54>)
   23098:	f019 fb48 	bl	3c72c <printk>
   2309c:	214e      	movs	r1, #78	; 0x4e
   2309e:	4808      	ldr	r0, [pc, #32]	; (230c0 <poll.constprop.7+0x54>)
   230a0:	f019 fb8a 	bl	3c7b8 <assert_post_action>

	return socket_ops->poll(fds, nfds, timeout);
   230a4:	6823      	ldr	r3, [r4, #0]
   230a6:	462a      	mov	r2, r5
}
   230a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return socket_ops->poll(fds, nfds, timeout);
   230ac:	699b      	ldr	r3, [r3, #24]
   230ae:	2101      	movs	r1, #1
   230b0:	4805      	ldr	r0, [pc, #20]	; (230c8 <poll.constprop.7+0x5c>)
   230b2:	4718      	bx	r3
   230b4:	20024aec 	.word	0x20024aec
   230b8:	000411aa 	.word	0x000411aa
   230bc:	00040606 	.word	0x00040606
   230c0:	0004117a 	.word	0x0004117a
   230c4:	000411b5 	.word	0x000411b5
   230c8:	20020d98 	.word	0x20020d98

000230cc <mqtt_evt_handler>:
{
   230cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   230d0:	4abb      	ldr	r2, [pc, #748]	; (233c0 <mqtt_evt_handler+0x2f4>)
   230d2:	4dbc      	ldr	r5, [pc, #752]	; (233c4 <mqtt_evt_handler+0x2f8>)
	switch(evt->type)
   230d4:	780b      	ldrb	r3, [r1, #0]
   230d6:	1aad      	subs	r5, r5, r2
{
   230d8:	b08d      	sub	sp, #52	; 0x34
   230da:	4681      	mov	r9, r0
   230dc:	460c      	mov	r4, r1
   230de:	f3c5 05c9 	ubfx	r5, r5, #3, #10
	switch(evt->type)
   230e2:	2b07      	cmp	r3, #7
   230e4:	f200 81e3 	bhi.w	234ae <mqtt_evt_handler+0x3e2>
   230e8:	e8df f013 	tbh	[pc, r3, lsl #1]
   230ec:	00670008 	.word	0x00670008
   230f0:	01570084 	.word	0x01570084
   230f4:	01e101e1 	.word	0x01e101e1
   230f8:	01bf01e1 	.word	0x01bf01e1
			LOG_INF("MQTT connect failed %d\n", evt->result);
   230fc:	f04f 0000 	mov.w	r0, #0
   23100:	2303      	movs	r3, #3
		if (evt->result != 0)
   23102:	69ce      	ldr	r6, [r1, #28]
			LOG_INF("MQTT connect failed %d\n", evt->result);
   23104:	f363 0007 	bfi	r0, r3, #0, #8
   23108:	f365 108f 	bfi	r0, r5, #6, #10
		if (evt->result != 0)
   2310c:	b17e      	cbz	r6, 2312e <mqtt_evt_handler+0x62>
			LOG_INF("MQTT connect failed %d\n", evt->result);
   2310e:	4632      	mov	r2, r6
   23110:	49ad      	ldr	r1, [pc, #692]	; (233c8 <mqtt_evt_handler+0x2fc>)
   23112:	f019 fb62 	bl	3c7da <log_string_sync>
			sprintf(tmpbuf, "MQTT connect failed %d", evt->result);
   23116:	69e3      	ldr	r3, [r4, #28]
   23118:	9300      	str	r3, [sp, #0]
   2311a:	4bac      	ldr	r3, [pc, #688]	; (233cc <mqtt_evt_handler+0x300>)
			sprintf(tmpbuf, "MQTT SUBACK error %d", evt->result);
   2311c:	2280      	movs	r2, #128	; 0x80
   2311e:	2100      	movs	r1, #0
   23120:	48ab      	ldr	r0, [pc, #684]	; (233d0 <mqtt_evt_handler+0x304>)
   23122:	f01b fcf5 	bl	3eb10 <__sprintf_chk>
		show_infor(tmpbuf);
   23126:	48aa      	ldr	r0, [pc, #680]	; (233d0 <mqtt_evt_handler+0x304>)
   23128:	f017 fd41 	bl	3abae <show_infor>
}
   2312c:	e042      	b.n	231b4 <mqtt_evt_handler+0xe8>
		LOG_INF("[%s:%d] MQTT client connected!\n", __func__, __LINE__);
   2312e:	4ca9      	ldr	r4, [pc, #676]	; (233d4 <mqtt_evt_handler+0x308>)
   23130:	f240 130d 	movw	r3, #269	; 0x10d
   23134:	4622      	mov	r2, r4
   23136:	49a8      	ldr	r1, [pc, #672]	; (233d8 <mqtt_evt_handler+0x30c>)
   23138:	f019 fb4f 	bl	3c7da <log_string_sync>
		sprintf(tmpbuf, "[%s:%d] MQTT client connected!", __func__, __LINE__);
   2313c:	f240 130f 	movw	r3, #271	; 0x10f
   23140:	2280      	movs	r2, #128	; 0x80
   23142:	4631      	mov	r1, r6
   23144:	e9cd 4300 	strd	r4, r3, [sp]
   23148:	48a1      	ldr	r0, [pc, #644]	; (233d0 <mqtt_evt_handler+0x304>)
	struct mqtt_topic subscribe_topic = {
   2314a:	4ca4      	ldr	r4, [pc, #656]	; (233dc <mqtt_evt_handler+0x310>)
		sprintf(tmpbuf, "[%s:%d] MQTT client connected!", __func__, __LINE__);
   2314c:	4ba4      	ldr	r3, [pc, #656]	; (233e0 <mqtt_evt_handler+0x314>)
   2314e:	f01b fcdf 	bl	3eb10 <__sprintf_chk>
		show_infor(tmpbuf);
   23152:	489f      	ldr	r0, [pc, #636]	; (233d0 <mqtt_evt_handler+0x304>)
   23154:	f017 fd2b 	bl	3abae <show_infor>
			.size = strlen(CONFIG_MQTT_SUB_TOPIC)
   23158:	4620      	mov	r0, r4
	struct mqtt_topic subscribe_topic = {
   2315a:	9406      	str	r4, [sp, #24]
			.size = strlen(CONFIG_MQTT_SUB_TOPIC)
   2315c:	f7f9 fffc 	bl	1d158 <strlen>
	struct mqtt_topic subscribe_topic = {
   23160:	2301      	movs	r3, #1
   23162:	f88d 3020 	strb.w	r3, [sp, #32]
	const struct mqtt_subscription_list subscription_list = {
   23166:	ab06      	add	r3, sp, #24
   23168:	9304      	str	r3, [sp, #16]
   2316a:	4b9e      	ldr	r3, [pc, #632]	; (233e4 <mqtt_evt_handler+0x318>)
	LOG_INF("Subscribing to: %s len %u\n", CONFIG_MQTT_SUB_TOPIC,
   2316c:	f04f 0700 	mov.w	r7, #0
	const struct mqtt_subscription_list subscription_list = {
   23170:	9305      	str	r3, [sp, #20]
	LOG_INF("Subscribing to: %s len %u\n", CONFIG_MQTT_SUB_TOPIC,
   23172:	2303      	movs	r3, #3
	struct mqtt_topic subscribe_topic = {
   23174:	9007      	str	r0, [sp, #28]
	LOG_INF("Subscribing to: %s len %u\n", CONFIG_MQTT_SUB_TOPIC,
   23176:	4620      	mov	r0, r4
   23178:	f363 0707 	bfi	r7, r3, #0, #8
   2317c:	f7f9 ffec 	bl	1d158 <strlen>
   23180:	f365 178f 	bfi	r7, r5, #6, #10
   23184:	4603      	mov	r3, r0
   23186:	4622      	mov	r2, r4
   23188:	4997      	ldr	r1, [pc, #604]	; (233e8 <mqtt_evt_handler+0x31c>)
   2318a:	4638      	mov	r0, r7
   2318c:	f019 fb25 	bl	3c7da <log_string_sync>
	sprintf(tmpbuf, "Subscribing to: %s len %u", CONFIG_MQTT_SUB_TOPIC,
   23190:	4620      	mov	r0, r4
   23192:	f7f9 ffe1 	bl	1d158 <strlen>
   23196:	4631      	mov	r1, r6
   23198:	e9cd 4000 	strd	r4, r0, [sp]
   2319c:	4b93      	ldr	r3, [pc, #588]	; (233ec <mqtt_evt_handler+0x320>)
   2319e:	2280      	movs	r2, #128	; 0x80
   231a0:	488b      	ldr	r0, [pc, #556]	; (233d0 <mqtt_evt_handler+0x304>)
   231a2:	f01b fcb5 	bl	3eb10 <__sprintf_chk>
	show_infor(tmpbuf);
   231a6:	488a      	ldr	r0, [pc, #552]	; (233d0 <mqtt_evt_handler+0x304>)
   231a8:	f017 fd01 	bl	3abae <show_infor>
	return mqtt_subscribe(&client, &subscription_list);
   231ac:	a904      	add	r1, sp, #16
   231ae:	4890      	ldr	r0, [pc, #576]	; (233f0 <mqtt_evt_handler+0x324>)
   231b0:	f01a f8a6 	bl	3d300 <mqtt_subscribe>
}
   231b4:	b00d      	add	sp, #52	; 0x34
   231b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		LOG_INF("[%s:%d] MQTT client disconnected %d\n", __func__,
   231ba:	2303      	movs	r3, #3
   231bc:	f04f 0000 	mov.w	r0, #0
   231c0:	f363 0007 	bfi	r0, r3, #0, #8
   231c4:	f365 108f 	bfi	r0, r5, #6, #10
   231c8:	69cb      	ldr	r3, [r1, #28]
   231ca:	4d82      	ldr	r5, [pc, #520]	; (233d4 <mqtt_evt_handler+0x308>)
   231cc:	9300      	str	r3, [sp, #0]
   231ce:	462a      	mov	r2, r5
   231d0:	f240 1317 	movw	r3, #279	; 0x117
   231d4:	4987      	ldr	r1, [pc, #540]	; (233f4 <mqtt_evt_handler+0x328>)
   231d6:	f019 fb00 	bl	3c7da <log_string_sync>
		sprintf(tmpbuf, "[%s:%d] MQTT client disconnected %d", __func__,
   231da:	69e3      	ldr	r3, [r4, #28]
   231dc:	9302      	str	r3, [sp, #8]
   231de:	f44f 738d 	mov.w	r3, #282	; 0x11a
   231e2:	e9cd 5300 	strd	r5, r3, [sp]
   231e6:	4b84      	ldr	r3, [pc, #528]	; (233f8 <mqtt_evt_handler+0x32c>)
		sprintf(tmpbuf, "[%s:%d] default: %d", __func__, __LINE__,
   231e8:	2280      	movs	r2, #128	; 0x80
   231ea:	2100      	movs	r1, #0
   231ec:	4878      	ldr	r0, [pc, #480]	; (233d0 <mqtt_evt_handler+0x304>)
   231ee:	f01b fc8f 	bl	3eb10 <__sprintf_chk>
   231f2:	e798      	b.n	23126 <mqtt_evt_handler+0x5a>
			LOG_INF("[%s:%d] MQTT PUBLISH result=%d len=%d\n", __func__,
   231f4:	2303      	movs	r3, #3
   231f6:	f04f 0000 	mov.w	r0, #0
   231fa:	f363 0007 	bfi	r0, r3, #0, #8
   231fe:	694b      	ldr	r3, [r1, #20]
   23200:	4e74      	ldr	r6, [pc, #464]	; (233d4 <mqtt_evt_handler+0x308>)
   23202:	9301      	str	r3, [sp, #4]
   23204:	69cb      	ldr	r3, [r1, #28]
   23206:	f365 108f 	bfi	r0, r5, #6, #10
   2320a:	9300      	str	r3, [sp, #0]
   2320c:	4632      	mov	r2, r6
   2320e:	f44f 7393 	mov.w	r3, #294	; 0x126
   23212:	497a      	ldr	r1, [pc, #488]	; (233fc <mqtt_evt_handler+0x330>)
   23214:	f019 fae1 	bl	3c7da <log_string_sync>
			sprintf(tmpbuf, "[%s:%d] MQTT PUBLISH result=%d len=%d", __func__,
   23218:	6963      	ldr	r3, [r4, #20]
   2321a:	2280      	movs	r2, #128	; 0x80
   2321c:	9303      	str	r3, [sp, #12]
   2321e:	69e3      	ldr	r3, [r4, #28]
   23220:	2100      	movs	r1, #0
   23222:	9302      	str	r3, [sp, #8]
   23224:	f240 1329 	movw	r3, #297	; 0x129
   23228:	4869      	ldr	r0, [pc, #420]	; (233d0 <mqtt_evt_handler+0x304>)
   2322a:	e9cd 6300 	strd	r6, r3, [sp]
   2322e:	4b74      	ldr	r3, [pc, #464]	; (23400 <mqtt_evt_handler+0x334>)
   23230:	f01b fc6e 	bl	3eb10 <__sprintf_chk>
			show_infor(tmpbuf);
   23234:	4866      	ldr	r0, [pc, #408]	; (233d0 <mqtt_evt_handler+0x304>)
   23236:	f017 fcba 	bl	3abae <show_infor>
			err = publish_get_payload(c, p->message.payload.len);
   2323a:	6963      	ldr	r3, [r4, #20]
	u8_t *end = buf + length;
   2323c:	4f71      	ldr	r7, [pc, #452]	; (23404 <mqtt_evt_handler+0x338>)
	if (length > sizeof(payload_buf)) {
   2323e:	2b80      	cmp	r3, #128	; 0x80
	u8_t *end = buf + length;
   23240:	eb07 0a03 	add.w	sl, r7, r3
	if (length > sizeof(payload_buf)) {
   23244:	f200 80a6 	bhi.w	23394 <mqtt_evt_handler+0x2c8>
	u8_t *buf = payload_buf;
   23248:	46bb      	mov	fp, r7
	while (buf < end) {
   2324a:	45da      	cmp	sl, fp
   2324c:	d840      	bhi.n	232d0 <mqtt_evt_handler+0x204>
				data_print("Received: ", payload_buf,
   2324e:	6961      	ldr	r1, [r4, #20]
   23250:	486d      	ldr	r0, [pc, #436]	; (23408 <mqtt_evt_handler+0x33c>)
   23252:	f7ff fedf 	bl	23014 <data_print.constprop.4>
	param.message.topic.qos = qos;
   23256:	2301      	movs	r3, #1
				data_publish(&client, MQTT_QOS_1_AT_LEAST_ONCE,
   23258:	6966      	ldr	r6, [r4, #20]
	param.message.topic.topic.utf8 = CONFIG_MQTT_PUB_TOPIC;
   2325a:	4c6c      	ldr	r4, [pc, #432]	; (2340c <mqtt_evt_handler+0x340>)
	param.message.topic.qos = qos;
   2325c:	f88d 3020 	strb.w	r3, [sp, #32]
	param.message.topic.topic.size = strlen(CONFIG_MQTT_PUB_TOPIC);
   23260:	4620      	mov	r0, r4
	param.message.topic.topic.utf8 = CONFIG_MQTT_PUB_TOPIC;
   23262:	9406      	str	r4, [sp, #24]
	param.message.topic.topic.size = strlen(CONFIG_MQTT_PUB_TOPIC);
   23264:	f7f9 ff78 	bl	1d158 <strlen>
	param.message.payload.len = len;
   23268:	e9cd 7609 	strd	r7, r6, [sp, #36]	; 0x24
	param.message.topic.topic.size = strlen(CONFIG_MQTT_PUB_TOPIC);
   2326c:	9007      	str	r0, [sp, #28]
	param.message_id = sys_rand32_get();
   2326e:	f006 fc65 	bl	29b3c <sys_rand32_get>
	param.dup_flag = 0;
   23272:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
	data_print("Publishing: ", data, len);
   23276:	4631      	mov	r1, r6
	param.message_id = sys_rand32_get();
   23278:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
	param.dup_flag = 0;
   2327c:	f023 0303 	bic.w	r3, r3, #3
	data_print("Publishing: ", data, len);
   23280:	4863      	ldr	r0, [pc, #396]	; (23410 <mqtt_evt_handler+0x344>)
	param.dup_flag = 0;
   23282:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
	LOG_INF("to topic: %s len: %u\n",
   23286:	f04f 0600 	mov.w	r6, #0
	data_print("Publishing: ", data, len);
   2328a:	f7ff fec3 	bl	23014 <data_print.constprop.4>
	LOG_INF("to topic: %s len: %u\n",
   2328e:	2303      	movs	r3, #3
   23290:	4620      	mov	r0, r4
   23292:	f363 0607 	bfi	r6, r3, #0, #8
   23296:	f7f9 ff5f 	bl	1d158 <strlen>
   2329a:	f365 168f 	bfi	r6, r5, #6, #10
   2329e:	4603      	mov	r3, r0
   232a0:	4622      	mov	r2, r4
   232a2:	495c      	ldr	r1, [pc, #368]	; (23414 <mqtt_evt_handler+0x348>)
   232a4:	4630      	mov	r0, r6
   232a6:	f019 fa98 	bl	3c7da <log_string_sync>
	sprintf(tmpbuf, "to topic: %s len: %u",
   232aa:	4620      	mov	r0, r4
   232ac:	f7f9 ff54 	bl	1d158 <strlen>
   232b0:	4b59      	ldr	r3, [pc, #356]	; (23418 <mqtt_evt_handler+0x34c>)
   232b2:	e9cd 4000 	strd	r4, r0, [sp]
   232b6:	2280      	movs	r2, #128	; 0x80
   232b8:	2100      	movs	r1, #0
   232ba:	4845      	ldr	r0, [pc, #276]	; (233d0 <mqtt_evt_handler+0x304>)
   232bc:	f01b fc28 	bl	3eb10 <__sprintf_chk>
	show_infor(tmpbuf);
   232c0:	4843      	ldr	r0, [pc, #268]	; (233d0 <mqtt_evt_handler+0x304>)
   232c2:	f017 fc74 	bl	3abae <show_infor>
	return mqtt_publish(c, &param);
   232c6:	a906      	add	r1, sp, #24
   232c8:	4849      	ldr	r0, [pc, #292]	; (233f0 <mqtt_evt_handler+0x324>)
   232ca:	f019 ffc2 	bl	3d252 <mqtt_publish>
   232ce:	e771      	b.n	231b4 <mqtt_evt_handler+0xe8>
		int ret = mqtt_read_publish_payload(c, buf, end - buf);
   232d0:	ebaa 020b 	sub.w	r2, sl, fp
   232d4:	4659      	mov	r1, fp
   232d6:	4648      	mov	r0, r9
   232d8:	f01a f8c3 	bl	3d462 <mqtt_read_publish_payload>
		if (ret < 0) {
   232dc:	1e06      	subs	r6, r0, #0
   232de:	da56      	bge.n	2338e <mqtt_evt_handler+0x2c2>
			if (ret != -EAGAIN) {
   232e0:	f116 0f0b 	cmn.w	r6, #11
   232e4:	d116      	bne.n	23314 <mqtt_evt_handler+0x248>
			LOG_INF("mqtt_read_publish_payload: EAGAIN\n");
   232e6:	f028 023f 	bic.w	r2, r8, #63	; 0x3f
   232ea:	f042 0203 	orr.w	r2, r2, #3
   232ee:	f362 0807 	bfi	r8, r2, #0, #8
   232f2:	f365 188f 	bfi	r8, r5, #6, #10
   232f6:	4949      	ldr	r1, [pc, #292]	; (2341c <mqtt_evt_handler+0x350>)
   232f8:	4640      	mov	r0, r8
   232fa:	f019 fa6e 	bl	3c7da <log_string_sync>
			show_infor("mqtt_read_publish_payload: EAGAIN");
   232fe:	4848      	ldr	r0, [pc, #288]	; (23420 <mqtt_evt_handler+0x354>)
   23300:	f017 fc55 	bl	3abae <show_infor>
			err = poll(&fds, 1,
   23304:	f64e 2060 	movw	r0, #60000	; 0xea60
   23308:	f7ff feb0 	bl	2306c <poll.constprop.7>
			if (err > 0 && (fds.revents & POLLIN) == POLLIN) {
   2330c:	2800      	cmp	r0, #0
   2330e:	dc38      	bgt.n	23382 <mqtt_evt_handler+0x2b6>
				return -EIO;
   23310:	f06f 0604 	mvn.w	r6, #4
				LOG_INF("mqtt_read_publish_payload: Failed! %d\n", err);
   23314:	2303      	movs	r3, #3
   23316:	f04f 0000 	mov.w	r0, #0
   2331a:	f363 0007 	bfi	r0, r3, #0, #8
   2331e:	4632      	mov	r2, r6
   23320:	f365 108f 	bfi	r0, r5, #6, #10
   23324:	493f      	ldr	r1, [pc, #252]	; (23424 <mqtt_evt_handler+0x358>)
   23326:	f019 fa58 	bl	3c7da <log_string_sync>
				LOG_INF("Disconnecting MQTT client...\n");
   2332a:	2303      	movs	r3, #3
   2332c:	f04f 0000 	mov.w	r0, #0
   23330:	f363 0007 	bfi	r0, r3, #0, #8
   23334:	f365 108f 	bfi	r0, r5, #6, #10
   23338:	493b      	ldr	r1, [pc, #236]	; (23428 <mqtt_evt_handler+0x35c>)
   2333a:	f019 fa4e 	bl	3c7da <log_string_sync>
				sprintf(tmpbuf, "mqtt_read_publish_payload: Failed! %d", err);
   2333e:	4b3b      	ldr	r3, [pc, #236]	; (2342c <mqtt_evt_handler+0x360>)
   23340:	2280      	movs	r2, #128	; 0x80
   23342:	2100      	movs	r1, #0
   23344:	9600      	str	r6, [sp, #0]
   23346:	4822      	ldr	r0, [pc, #136]	; (233d0 <mqtt_evt_handler+0x304>)
   23348:	f01b fbe2 	bl	3eb10 <__sprintf_chk>
				show_infor(tmpbuf);
   2334c:	4820      	ldr	r0, [pc, #128]	; (233d0 <mqtt_evt_handler+0x304>)
   2334e:	f017 fc2e 	bl	3abae <show_infor>
				show_infor("Disconnecting MQTT client...");
   23352:	4837      	ldr	r0, [pc, #220]	; (23430 <mqtt_evt_handler+0x364>)
   23354:	f017 fc2b 	bl	3abae <show_infor>
				err = mqtt_disconnect(c);
   23358:	4648      	mov	r0, r9
   2335a:	f019 ffa8 	bl	3d2ae <mqtt_disconnect>
				if(err)
   2335e:	4604      	mov	r4, r0
   23360:	2800      	cmp	r0, #0
   23362:	f43f af27 	beq.w	231b4 <mqtt_evt_handler+0xe8>
					LOG_INF("Could not disconnect: %d\n", err);
   23366:	2303      	movs	r3, #3
   23368:	f04f 0000 	mov.w	r0, #0
   2336c:	f363 0007 	bfi	r0, r3, #0, #8
   23370:	f365 108f 	bfi	r0, r5, #6, #10
   23374:	4622      	mov	r2, r4
   23376:	492f      	ldr	r1, [pc, #188]	; (23434 <mqtt_evt_handler+0x368>)
   23378:	f019 fa2f 	bl	3c7da <log_string_sync>
					sprintf(tmpbuf, "Could not disconnect: %d", err);
   2337c:	9400      	str	r4, [sp, #0]
   2337e:	4b2e      	ldr	r3, [pc, #184]	; (23438 <mqtt_evt_handler+0x36c>)
   23380:	e6cc      	b.n	2311c <mqtt_evt_handler+0x50>
			if (err > 0 && (fds.revents & POLLIN) == POLLIN) {
   23382:	4b2e      	ldr	r3, [pc, #184]	; (2343c <mqtt_evt_handler+0x370>)
   23384:	88da      	ldrh	r2, [r3, #6]
   23386:	07d3      	lsls	r3, r2, #31
   23388:	f53f af5f 	bmi.w	2324a <mqtt_evt_handler+0x17e>
   2338c:	e7c0      	b.n	23310 <mqtt_evt_handler+0x244>
		if (ret == 0) {
   2338e:	d0bf      	beq.n	23310 <mqtt_evt_handler+0x244>
		buf += ret;
   23390:	44b3      	add	fp, r6
   23392:	e75a      	b.n	2324a <mqtt_evt_handler+0x17e>
		return -EMSGSIZE;
   23394:	f06f 0679 	mvn.w	r6, #121	; 0x79
   23398:	e7bc      	b.n	23314 <mqtt_evt_handler+0x248>
			LOG_INF("MQTT PUBACK error %d\n", evt->result);
   2339a:	f04f 0000 	mov.w	r0, #0
   2339e:	2303      	movs	r3, #3
		if(evt->result != 0)
   233a0:	69ce      	ldr	r6, [r1, #28]
			LOG_INF("MQTT PUBACK error %d\n", evt->result);
   233a2:	f363 0007 	bfi	r0, r3, #0, #8
   233a6:	f365 108f 	bfi	r0, r5, #6, #10
		if(evt->result != 0)
   233aa:	2e00      	cmp	r6, #0
   233ac:	d04c      	beq.n	23448 <mqtt_evt_handler+0x37c>
			LOG_INF("MQTT PUBACK error %d\n", evt->result);
   233ae:	4632      	mov	r2, r6
   233b0:	4923      	ldr	r1, [pc, #140]	; (23440 <mqtt_evt_handler+0x374>)
   233b2:	f019 fa12 	bl	3c7da <log_string_sync>
			sprintf(tmpbuf, "MQTT PUBACK error %d", evt->result);
   233b6:	69e3      	ldr	r3, [r4, #28]
   233b8:	9300      	str	r3, [sp, #0]
   233ba:	4b22      	ldr	r3, [pc, #136]	; (23444 <mqtt_evt_handler+0x378>)
   233bc:	e6ae      	b.n	2311c <mqtt_evt_handler+0x50>
   233be:	bf00      	nop
   233c0:	0003f8d4 	.word	0x0003f8d4
   233c4:	0003f99c 	.word	0x0003f99c
   233c8:	00040dad 	.word	0x00040dad
   233cc:	00040dc5 	.word	0x00040dc5
   233d0:	2002c217 	.word	0x2002c217
   233d4:	00040d65 	.word	0x00040d65
   233d8:	00040ddc 	.word	0x00040ddc
   233dc:	00040e1b 	.word	0x00040e1b
   233e0:	00040dfc 	.word	0x00040dfc
   233e4:	04d20001 	.word	0x04d20001
   233e8:	00040e2e 	.word	0x00040e2e
   233ec:	00040e49 	.word	0x00040e49
   233f0:	20020d1c 	.word	0x20020d1c
   233f4:	00040e63 	.word	0x00040e63
   233f8:	00040e88 	.word	0x00040e88
   233fc:	00040eac 	.word	0x00040eac
   23400:	00040ed3 	.word	0x00040ed3
   23404:	2002c117 	.word	0x2002c117
   23408:	000410ee 	.word	0x000410ee
   2340c:	000410f9 	.word	0x000410f9
   23410:	0004110a 	.word	0x0004110a
   23414:	00041117 	.word	0x00041117
   23418:	0004112d 	.word	0x0004112d
   2341c:	00040ef9 	.word	0x00040ef9
   23420:	00040f1c 	.word	0x00040f1c
   23424:	00040f3e 	.word	0x00040f3e
   23428:	00040f65 	.word	0x00040f65
   2342c:	00040f83 	.word	0x00040f83
   23430:	00040fa9 	.word	0x00040fa9
   23434:	00040fc6 	.word	0x00040fc6
   23438:	00040fe0 	.word	0x00040fe0
   2343c:	20020d98 	.word	0x20020d98
   23440:	00040ff9 	.word	0x00040ff9
   23444:	0004100f 	.word	0x0004100f
		LOG_INF("[%s:%d] PUBACK packet id: %u\n", __func__, __LINE__,
   23448:	888b      	ldrh	r3, [r1, #4]
   2344a:	4d24      	ldr	r5, [pc, #144]	; (234dc <mqtt_evt_handler+0x410>)
   2344c:	9300      	str	r3, [sp, #0]
   2344e:	462a      	mov	r2, r5
   23450:	f240 1359 	movw	r3, #345	; 0x159
   23454:	4922      	ldr	r1, [pc, #136]	; (234e0 <mqtt_evt_handler+0x414>)
   23456:	f019 f9c0 	bl	3c7da <log_string_sync>
		sprintf(tmpbuf, "[%s:%d] PUBACK packet id: %u", __func__, __LINE__,
   2345a:	88a3      	ldrh	r3, [r4, #4]
   2345c:	9302      	str	r3, [sp, #8]
   2345e:	f44f 73ae 	mov.w	r3, #348	; 0x15c
   23462:	e9cd 5300 	strd	r5, r3, [sp]
   23466:	4b1f      	ldr	r3, [pc, #124]	; (234e4 <mqtt_evt_handler+0x418>)
   23468:	e6be      	b.n	231e8 <mqtt_evt_handler+0x11c>
			LOG_INF("MQTT SUBACK error %d\n", evt->result);
   2346a:	f04f 0000 	mov.w	r0, #0
   2346e:	2303      	movs	r3, #3
		if(evt->result != 0)
   23470:	69ce      	ldr	r6, [r1, #28]
			LOG_INF("MQTT SUBACK error %d\n", evt->result);
   23472:	f363 0007 	bfi	r0, r3, #0, #8
   23476:	f365 108f 	bfi	r0, r5, #6, #10
		if(evt->result != 0)
   2347a:	b13e      	cbz	r6, 2348c <mqtt_evt_handler+0x3c0>
			LOG_INF("MQTT SUBACK error %d\n", evt->result);
   2347c:	4632      	mov	r2, r6
   2347e:	491a      	ldr	r1, [pc, #104]	; (234e8 <mqtt_evt_handler+0x41c>)
   23480:	f019 f9ab 	bl	3c7da <log_string_sync>
			sprintf(tmpbuf, "MQTT SUBACK error %d", evt->result);
   23484:	69e3      	ldr	r3, [r4, #28]
   23486:	9300      	str	r3, [sp, #0]
   23488:	4b18      	ldr	r3, [pc, #96]	; (234ec <mqtt_evt_handler+0x420>)
   2348a:	e647      	b.n	2311c <mqtt_evt_handler+0x50>
		LOG_INF("[%s:%d] SUBACK packet id: %u\n", __func__, __LINE__,
   2348c:	888b      	ldrh	r3, [r1, #4]
   2348e:	4d13      	ldr	r5, [pc, #76]	; (234dc <mqtt_evt_handler+0x410>)
   23490:	9300      	str	r3, [sp, #0]
   23492:	462a      	mov	r2, r5
   23494:	f240 136d 	movw	r3, #365	; 0x16d
   23498:	4915      	ldr	r1, [pc, #84]	; (234f0 <mqtt_evt_handler+0x424>)
   2349a:	f019 f99e 	bl	3c7da <log_string_sync>
		sprintf(tmpbuf, "[%s:%d] SUBACK packet id: %u", __func__, __LINE__,
   2349e:	88a3      	ldrh	r3, [r4, #4]
   234a0:	9302      	str	r3, [sp, #8]
   234a2:	f44f 73b8 	mov.w	r3, #368	; 0x170
   234a6:	e9cd 5300 	strd	r5, r3, [sp]
   234aa:	4b12      	ldr	r3, [pc, #72]	; (234f4 <mqtt_evt_handler+0x428>)
   234ac:	e69c      	b.n	231e8 <mqtt_evt_handler+0x11c>
		LOG_INF("[%s:%d] default: %d\n", __func__, __LINE__,
   234ae:	2203      	movs	r2, #3
   234b0:	f04f 0000 	mov.w	r0, #0
   234b4:	f362 0007 	bfi	r0, r2, #0, #8
   234b8:	f365 108f 	bfi	r0, r5, #6, #10
   234bc:	4d07      	ldr	r5, [pc, #28]	; (234dc <mqtt_evt_handler+0x410>)
	switch(evt->type)
   234be:	9300      	str	r3, [sp, #0]
		LOG_INF("[%s:%d] default: %d\n", __func__, __LINE__,
   234c0:	462a      	mov	r2, r5
   234c2:	f240 1377 	movw	r3, #375	; 0x177
   234c6:	490c      	ldr	r1, [pc, #48]	; (234f8 <mqtt_evt_handler+0x42c>)
   234c8:	f019 f987 	bl	3c7da <log_string_sync>
		sprintf(tmpbuf, "[%s:%d] default: %d", __func__, __LINE__,
   234cc:	7823      	ldrb	r3, [r4, #0]
   234ce:	9302      	str	r3, [sp, #8]
   234d0:	f44f 73bd 	mov.w	r3, #378	; 0x17a
   234d4:	e9cd 5300 	strd	r5, r3, [sp]
   234d8:	4b08      	ldr	r3, [pc, #32]	; (234fc <mqtt_evt_handler+0x430>)
   234da:	e685      	b.n	231e8 <mqtt_evt_handler+0x11c>
   234dc:	00040d65 	.word	0x00040d65
   234e0:	00041024 	.word	0x00041024
   234e4:	00041042 	.word	0x00041042
   234e8:	0004105f 	.word	0x0004105f
   234ec:	00041075 	.word	0x00041075
   234f0:	0004108a 	.word	0x0004108a
   234f4:	000410a8 	.word	0x000410a8
   234f8:	000410c5 	.word	0x000410c5
   234fc:	000410da 	.word	0x000410da

00023500 <modem_data_init>:

/**brief Initialize LTE status containers. */
void modem_data_init(void)
{
   23500:	b508      	push	{r3, lr}
	int err;

	err = modem_info_init();
   23502:	f008 ff8b 	bl	2c41c <modem_info_init>
	if(err)
   23506:	4602      	mov	r2, r0
   23508:	b178      	cbz	r0, 2352a <modem_data_init+0x2a>
	{
		LOG_INF("Modem info could not be established: %d", err);
   2350a:	2303      	movs	r3, #3
   2350c:	f04f 0000 	mov.w	r0, #0
   23510:	490a      	ldr	r1, [pc, #40]	; (2353c <modem_data_init+0x3c>)
   23512:	f363 0007 	bfi	r0, r3, #0, #8
   23516:	4b0a      	ldr	r3, [pc, #40]	; (23540 <modem_data_init+0x40>)
   23518:	1a5b      	subs	r3, r3, r1
   2351a:	08db      	lsrs	r3, r3, #3
   2351c:	f363 108f 	bfi	r0, r3, #6, #10
   23520:	4908      	ldr	r1, [pc, #32]	; (23544 <modem_data_init+0x44>)
		return;
	}

	modem_info_params_init(&modem_param);
	modem_info_rsrp_register(modem_rsrp_handler);
}
   23522:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		LOG_INF("Modem info could not be established: %d", err);
   23526:	f019 b958 	b.w	3c7da <log_string_sync>
	modem_info_params_init(&modem_param);
   2352a:	4807      	ldr	r0, [pc, #28]	; (23548 <modem_data_init+0x48>)
   2352c:	f008 ff7c 	bl	2c428 <modem_info_params_init>
}
   23530:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	modem_info_rsrp_register(modem_rsrp_handler);
   23534:	4805      	ldr	r0, [pc, #20]	; (2354c <modem_data_init+0x4c>)
   23536:	f008 bf3f 	b.w	2c3b8 <modem_info_rsrp_register>
   2353a:	bf00      	nop
   2353c:	0003f8d4 	.word	0x0003f8d4
   23540:	0003f99c 	.word	0x0003f99c
   23544:	00040d76 	.word	0x00040d76
   23548:	200200e0 	.word	0x200200e0
   2354c:	00022fb5 	.word	0x00022fb5

00023550 <test_nb>:

void test_nb(void)
{
	int err;

	nb_is_running = true;
   23550:	2201      	movs	r2, #1
   23552:	4ba8      	ldr	r3, [pc, #672]	; (237f4 <test_nb+0x2a4>)
{
   23554:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	
	LOG_INF("Start NB-IoT test!\n");
   23558:	f04f 0000 	mov.w	r0, #0
	nb_is_running = true;
   2355c:	701a      	strb	r2, [r3, #0]
	LOG_INF("Start NB-IoT test!\n");
   2355e:	2303      	movs	r3, #3
   23560:	4da5      	ldr	r5, [pc, #660]	; (237f8 <test_nb+0x2a8>)
   23562:	f363 0007 	bfi	r0, r3, #0, #8
   23566:	4ba5      	ldr	r3, [pc, #660]	; (237fc <test_nb+0x2ac>)
{
   23568:	b093      	sub	sp, #76	; 0x4c
	LOG_INF("Start NB-IoT test!\n");
   2356a:	1aed      	subs	r5, r5, r3
   2356c:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   23570:	49a3      	ldr	r1, [pc, #652]	; (23800 <test_nb+0x2b0>)
   23572:	f365 108f 	bfi	r0, r5, #6, #10
   23576:	f019 f930 	bl	3c7da <log_string_sync>

	EnterNBTestScreen();
   2357a:	f002 f891 	bl	256a0 <EnterNBTestScreen>
	
#ifdef SHOW_LOG_IN_SCREEN
	show_infor("Start NB-IoT test!");
   2357e:	48a1      	ldr	r0, [pc, #644]	; (23804 <test_nb+0x2b4>)
   23580:	f017 fb15 	bl	3abae <show_infor>
	show_infor("modem_configure");
   23584:	48a0      	ldr	r0, [pc, #640]	; (23808 <test_nb+0x2b8>)
   23586:	f017 fb12 	bl	3abae <show_infor>
	if(at_cmd_write("AT%CESQ=1", NULL, 0, NULL) != 0)
   2358a:	2300      	movs	r3, #0
   2358c:	489f      	ldr	r0, [pc, #636]	; (2380c <test_nb+0x2bc>)
   2358e:	461a      	mov	r2, r3
   23590:	4619      	mov	r1, r3
   23592:	f007 ff5d 	bl	2b450 <at_cmd_write>
   23596:	2800      	cmp	r0, #0
   23598:	f000 8093 	beq.w	236c2 <test_nb+0x172>
		LOG_INF("AT_CMD write fail!\n");
   2359c:	f04f 0000 	mov.w	r0, #0
   235a0:	2303      	movs	r3, #3
   235a2:	f363 0007 	bfi	r0, r3, #0, #8
   235a6:	f365 108f 	bfi	r0, r5, #6, #10
   235aa:	4999      	ldr	r1, [pc, #612]	; (23810 <test_nb+0x2c0>)
   235ac:	f019 f915 	bl	3c7da <log_string_sync>
	mqtt_client_init(client);
   235b0:	4898      	ldr	r0, [pc, #608]	; (23814 <test_nb+0x2c4>)
   235b2:	f019 fdf1 	bl	3d198 <mqtt_client_init>
	struct addrinfo hints = {
   235b6:	2220      	movs	r2, #32
   235b8:	2100      	movs	r1, #0
   235ba:	a80a      	add	r0, sp, #40	; 0x28
   235bc:	f01b f966 	bl	3e88c <memset>
   235c0:	2301      	movs	r3, #1

static inline int getaddrinfo(const char *node, const char *service,
			      const struct addrinfo *hints,
			      struct addrinfo **res)
{
	__ASSERT_NO_MSG(socket_ops);
   235c2:	4c95      	ldr	r4, [pc, #596]	; (23818 <test_nb+0x2c8>)
   235c4:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
   235c8:	6823      	ldr	r3, [r4, #0]
   235ca:	b94b      	cbnz	r3, 235e0 <test_nb+0x90>
   235cc:	4993      	ldr	r1, [pc, #588]	; (2381c <test_nb+0x2cc>)
   235ce:	4894      	ldr	r0, [pc, #592]	; (23820 <test_nb+0x2d0>)
   235d0:	2393      	movs	r3, #147	; 0x93
   235d2:	4a94      	ldr	r2, [pc, #592]	; (23824 <test_nb+0x2d4>)
   235d4:	f019 f8aa 	bl	3c72c <printk>
   235d8:	2193      	movs	r1, #147	; 0x93
   235da:	4892      	ldr	r0, [pc, #584]	; (23824 <test_nb+0x2d4>)
   235dc:	f019 f8ec 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->getaddrinfo);
   235e0:	6823      	ldr	r3, [r4, #0]
   235e2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   235e4:	b94b      	cbnz	r3, 235fa <test_nb+0xaa>
   235e6:	4990      	ldr	r1, [pc, #576]	; (23828 <test_nb+0x2d8>)
   235e8:	488d      	ldr	r0, [pc, #564]	; (23820 <test_nb+0x2d0>)
   235ea:	2394      	movs	r3, #148	; 0x94
   235ec:	4a8d      	ldr	r2, [pc, #564]	; (23824 <test_nb+0x2d4>)
   235ee:	f019 f89d 	bl	3c72c <printk>
   235f2:	2194      	movs	r1, #148	; 0x94
   235f4:	488b      	ldr	r0, [pc, #556]	; (23824 <test_nb+0x2d4>)
   235f6:	f019 f8df 	bl	3c7b8 <assert_post_action>

	return socket_ops->getaddrinfo(node, service, hints, res);
   235fa:	6823      	ldr	r3, [r4, #0]
   235fc:	aa0a      	add	r2, sp, #40	; 0x28
   235fe:	6b5e      	ldr	r6, [r3, #52]	; 0x34
   23600:	2100      	movs	r1, #0
   23602:	ab05      	add	r3, sp, #20
   23604:	4889      	ldr	r0, [pc, #548]	; (2382c <test_nb+0x2dc>)
   23606:	47b0      	blx	r6
	if(err)
   23608:	4e89      	ldr	r6, [pc, #548]	; (23830 <test_nb+0x2e0>)
   2360a:	4607      	mov	r7, r0
   2360c:	2800      	cmp	r0, #0
   2360e:	f000 8085 	beq.w	2371c <test_nb+0x1cc>
		LOG_INF("ERROR: getaddrinfo failed %d\n", err);
   23612:	2303      	movs	r3, #3
   23614:	f04f 0000 	mov.w	r0, #0
   23618:	f363 0007 	bfi	r0, r3, #0, #8
   2361c:	f365 108f 	bfi	r0, r5, #6, #10
   23620:	463a      	mov	r2, r7
   23622:	4984      	ldr	r1, [pc, #528]	; (23834 <test_nb+0x2e4>)
   23624:	f019 f8d9 	bl	3c7da <log_string_sync>
		sprintf(tmpbuf, "ERROR: getaddrinfo failed %d", err);
   23628:	9700      	str	r7, [sp, #0]
   2362a:	4b83      	ldr	r3, [pc, #524]	; (23838 <test_nb+0x2e8>)
   2362c:	2280      	movs	r2, #128	; 0x80
   2362e:	2100      	movs	r1, #0
   23630:	4882      	ldr	r0, [pc, #520]	; (2383c <test_nb+0x2ec>)
   23632:	f01b fa6d 	bl	3eb10 <__sprintf_chk>
		show_infor(tmpbuf);	
   23636:	4881      	ldr	r0, [pc, #516]	; (2383c <test_nb+0x2ec>)
   23638:	f017 fab9 	bl	3abae <show_infor>
	client->broker = &broker;
   2363c:	4c75      	ldr	r4, [pc, #468]	; (23814 <test_nb+0x2c4>)
	client->evt_cb = mqtt_evt_handler;
   2363e:	4b80      	ldr	r3, [pc, #512]	; (23840 <test_nb+0x2f0>)
	client->client_id.utf8 = (u8_t *)CONFIG_MQTT_CLIENT_ID;
   23640:	4880      	ldr	r0, [pc, #512]	; (23844 <test_nb+0x2f4>)
	client->broker = &broker;
   23642:	64e6      	str	r6, [r4, #76]	; 0x4c
	client->evt_cb = mqtt_evt_handler;
   23644:	6623      	str	r3, [r4, #96]	; 0x60
	client->client_id.utf8 = (u8_t *)CONFIG_MQTT_CLIENT_ID;
   23646:	6460      	str	r0, [r4, #68]	; 0x44
	client->client_id.size = strlen(CONFIG_MQTT_CLIENT_ID);
   23648:	f7f9 fd86 	bl	1d158 <strlen>
	client->protocol_version = MQTT_VERSION_3_1_1;
   2364c:	2304      	movs	r3, #4
	client->rx_buf_size = sizeof(rx_buffer);
   2364e:	f04f 0880 	mov.w	r8, #128	; 0x80
	client->password = NULL;
   23652:	2600      	movs	r6, #0
    client->transport.type = MQTT_TRANSPORT_SECURE;
   23654:	2701      	movs	r7, #1
	client->protocol_version = MQTT_VERSION_3_1_1;
   23656:	f884 3076 	strb.w	r3, [r4, #118]	; 0x76
	client->rx_buf = rx_buffer;
   2365a:	4b7b      	ldr	r3, [pc, #492]	; (23848 <test_nb+0x2f8>)
	client->client_id.size = strlen(CONFIG_MQTT_CLIENT_ID);
   2365c:	64a0      	str	r0, [r4, #72]	; 0x48
	client->rx_buf = rx_buffer;
   2365e:	6663      	str	r3, [r4, #100]	; 0x64
	client->tx_buf = tx_buffer;
   23660:	4b7a      	ldr	r3, [pc, #488]	; (2384c <test_nb+0x2fc>)
    tls_config->cipher_count = 0;
   23662:	e9c4 760b 	strd	r7, r6, [r4, #44]	; 0x2c
	client->tx_buf_size = sizeof(tx_buffer);
   23666:	e9c4 381b 	strd	r3, r8, [r4, #108]	; 0x6c
    tls_config->sec_tag_list = sec_tag_list;
   2366a:	4b79      	ldr	r3, [pc, #484]	; (23850 <test_nb+0x300>)
    tls_config->sec_tag_count = ARRAY_SIZE(sec_tag_list);
   2366c:	e9c4 670d 	strd	r6, r7, [r4, #52]	; 0x34
    tls_config->sec_tag_list = sec_tag_list;
   23670:	63e3      	str	r3, [r4, #60]	; 0x3c
    tls_config->hostname = CONFIG_MQTT_BROKER_HOSTNAME;
   23672:	4b6e      	ldr	r3, [pc, #440]	; (2382c <test_nb+0x2dc>)

	modem_configure();

	client_init(&client);

	err = mqtt_connect(&client);
   23674:	4620      	mov	r0, r4
    tls_config->hostname = CONFIG_MQTT_BROKER_HOSTNAME;
   23676:	6423      	str	r3, [r4, #64]	; 0x40
	client->user_name = NULL;
   23678:	e9c4 6614 	strd	r6, r6, [r4, #80]	; 0x50
	client->rx_buf_size = sizeof(rx_buffer);
   2367c:	f8c4 8068 	str.w	r8, [r4, #104]	; 0x68
    client->transport.type = MQTT_TRANSPORT_SECURE;
   23680:	f884 7024 	strb.w	r7, [r4, #36]	; 0x24
	err = mqtt_connect(&client);
   23684:	f019 fda1 	bl	3d1ca <mqtt_connect>
	if(err != 0)
   23688:	4681      	mov	r9, r0
   2368a:	2800      	cmp	r0, #0
   2368c:	f000 80fe 	beq.w	2388c <test_nb+0x33c>
	{
		LOG_INF("ERROR: mqtt_connect %d\n", err);
   23690:	2303      	movs	r3, #3
   23692:	f04f 0000 	mov.w	r0, #0
   23696:	f363 0007 	bfi	r0, r3, #0, #8
   2369a:	f365 108f 	bfi	r0, r5, #6, #10
   2369e:	464a      	mov	r2, r9
   236a0:	496c      	ldr	r1, [pc, #432]	; (23854 <test_nb+0x304>)
   236a2:	f019 f89a 	bl	3c7da <log_string_sync>
	#ifdef SHOW_LOG_IN_SCREEN
		sprintf(tmpbuf, "ERROR: mqtt_connect %d", err);
   236a6:	4b6c      	ldr	r3, [pc, #432]	; (23858 <test_nb+0x308>)
   236a8:	f8cd 9000 	str.w	r9, [sp]
	err = mqtt_disconnect(&client);
	if(err)
	{
		LOG_INF("Could not disconnect MQTT client. Error: %d\n", err);
	#ifdef SHOW_LOG_IN_SCREEN	
		sprintf(tmpbuf, "Could not disconnect MQTT client. Error: %d", err);
   236ac:	2280      	movs	r2, #128	; 0x80
   236ae:	2100      	movs	r1, #0
   236b0:	4862      	ldr	r0, [pc, #392]	; (2383c <test_nb+0x2ec>)
   236b2:	f01b fa2d 	bl	3eb10 <__sprintf_chk>
		show_infor(tmpbuf);
   236b6:	4861      	ldr	r0, [pc, #388]	; (2383c <test_nb+0x2ec>)
   236b8:	f017 fa79 	bl	3abae <show_infor>
	#endif
	}
}
   236bc:	b013      	add	sp, #76	; 0x4c
   236be:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		LOG_INF("LTE Link Connecting ...\n");
   236c2:	2303      	movs	r3, #3
   236c4:	f04f 0000 	mov.w	r0, #0
   236c8:	f363 0007 	bfi	r0, r3, #0, #8
   236cc:	f365 108f 	bfi	r0, r5, #6, #10
   236d0:	4962      	ldr	r1, [pc, #392]	; (2385c <test_nb+0x30c>)
   236d2:	f019 f882 	bl	3c7da <log_string_sync>
		show_infor("LTE Link Connecting ...");
   236d6:	4862      	ldr	r0, [pc, #392]	; (23860 <test_nb+0x310>)
   236d8:	f017 fa69 	bl	3abae <show_infor>
		err = lte_lc_init_and_connect();
   236dc:	f01a fe79 	bl	3e3d2 <lte_lc_init_and_connect>
		__ASSERT(err == 0, "LTE link could not be established.");
   236e0:	b170      	cbz	r0, 23700 <test_nb+0x1b0>
   236e2:	4960      	ldr	r1, [pc, #384]	; (23864 <test_nb+0x314>)
   236e4:	f240 2372 	movw	r3, #626	; 0x272
   236e8:	4a5f      	ldr	r2, [pc, #380]	; (23868 <test_nb+0x318>)
   236ea:	484d      	ldr	r0, [pc, #308]	; (23820 <test_nb+0x2d0>)
   236ec:	f019 f81e 	bl	3c72c <printk>
   236f0:	485e      	ldr	r0, [pc, #376]	; (2386c <test_nb+0x31c>)
   236f2:	f019 f81b 	bl	3c72c <printk>
   236f6:	f240 2172 	movw	r1, #626	; 0x272
   236fa:	485b      	ldr	r0, [pc, #364]	; (23868 <test_nb+0x318>)
   236fc:	f019 f85c 	bl	3c7b8 <assert_post_action>
		LOG_INF("LTE Link Connected!\n");
   23700:	2303      	movs	r3, #3
   23702:	f04f 0000 	mov.w	r0, #0
   23706:	f363 0007 	bfi	r0, r3, #0, #8
   2370a:	f365 108f 	bfi	r0, r5, #6, #10
   2370e:	4958      	ldr	r1, [pc, #352]	; (23870 <test_nb+0x320>)
   23710:	f019 f863 	bl	3c7da <log_string_sync>
		show_infor("LTE Link Connected!");
   23714:	4857      	ldr	r0, [pc, #348]	; (23874 <test_nb+0x324>)
   23716:	f017 fa4a 	bl	3abae <show_infor>
   2371a:	e749      	b.n	235b0 <test_nb+0x60>
	addr = result;
   2371c:	f8dd 8014 	ldr.w	r8, [sp, #20]
	while(addr != NULL)
   23720:	f1b8 0f00 	cmp.w	r8, #0
   23724:	d029      	beq.n	2377a <test_nb+0x22a>
		if (addr->ai_addrlen == sizeof(struct sockaddr_in))
   23726:	f8d8 2010 	ldr.w	r2, [r8, #16]
   2372a:	2a08      	cmp	r2, #8
   2372c:	d144      	bne.n	237b8 <test_nb+0x268>
				->sin_addr.s_addr;
   2372e:	f8d8 3014 	ldr.w	r3, [r8, #20]
			broker4->sin_family = AF_INET;
   23732:	2001      	movs	r0, #1
				->sin_addr.s_addr;
   23734:	685b      	ldr	r3, [r3, #4]
			broker4->sin_family = AF_INET;
   23736:	8030      	strh	r0, [r6, #0]
			broker4->sin_addr.s_addr =
   23738:	6073      	str	r3, [r6, #4]
			broker4->sin_port = htons(CONFIG_MQTT_BROKER_PORT);
   2373a:	f24b 4322 	movw	r3, #46114	; 0xb422
   2373e:	8073      	strh	r3, [r6, #2]
	if (z_syscall_trap()) {
		return (char *) arch_syscall_invoke4(*(uintptr_t *)&family, *(uintptr_t *)&src, *(uintptr_t *)&dst, *(uintptr_t *)&size, K_SYSCALL_NET_ADDR_NTOP);
	}
#endif
	compiler_barrier();
	return z_impl_net_addr_ntop(family, src, dst, size);
   23740:	f10d 0818 	add.w	r8, sp, #24
   23744:	2310      	movs	r3, #16
   23746:	4642      	mov	r2, r8
   23748:	1d31      	adds	r1, r6, #4
   2374a:	f005 fd31 	bl	291b0 <z_impl_net_addr_ntop>
			LOG_INF("IPv4 Address found %s\n", ipv4_addr);
   2374e:	2303      	movs	r3, #3
   23750:	f04f 0000 	mov.w	r0, #0
   23754:	f363 0007 	bfi	r0, r3, #0, #8
   23758:	f365 108f 	bfi	r0, r5, #6, #10
   2375c:	4642      	mov	r2, r8
   2375e:	4946      	ldr	r1, [pc, #280]	; (23878 <test_nb+0x328>)
   23760:	f019 f83b 	bl	3c7da <log_string_sync>
			sprintf(tmpbuf, "IPv4 Address found %s", ipv4_addr);
   23764:	f8cd 8000 	str.w	r8, [sp]
   23768:	4b44      	ldr	r3, [pc, #272]	; (2387c <test_nb+0x32c>)
   2376a:	2280      	movs	r2, #128	; 0x80
   2376c:	4639      	mov	r1, r7
   2376e:	4833      	ldr	r0, [pc, #204]	; (2383c <test_nb+0x2ec>)
   23770:	f01b f9ce 	bl	3eb10 <__sprintf_chk>
			show_infor(tmpbuf);
   23774:	4831      	ldr	r0, [pc, #196]	; (2383c <test_nb+0x2ec>)
   23776:	f017 fa1a 	bl	3abae <show_infor>
}

static inline void freeaddrinfo(struct addrinfo *res)
{
	__ASSERT_NO_MSG(socket_ops);
   2377a:	6823      	ldr	r3, [r4, #0]
	freeaddrinfo(result);
   2377c:	9f05      	ldr	r7, [sp, #20]
   2377e:	b94b      	cbnz	r3, 23794 <test_nb+0x244>
   23780:	4926      	ldr	r1, [pc, #152]	; (2381c <test_nb+0x2cc>)
   23782:	4827      	ldr	r0, [pc, #156]	; (23820 <test_nb+0x2d0>)
   23784:	239b      	movs	r3, #155	; 0x9b
   23786:	4a27      	ldr	r2, [pc, #156]	; (23824 <test_nb+0x2d4>)
   23788:	f018 ffd0 	bl	3c72c <printk>
   2378c:	219b      	movs	r1, #155	; 0x9b
   2378e:	4825      	ldr	r0, [pc, #148]	; (23824 <test_nb+0x2d4>)
   23790:	f019 f812 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->freeaddrinfo);
   23794:	6823      	ldr	r3, [r4, #0]
   23796:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   23798:	b94b      	cbnz	r3, 237ae <test_nb+0x25e>
   2379a:	4939      	ldr	r1, [pc, #228]	; (23880 <test_nb+0x330>)
   2379c:	4820      	ldr	r0, [pc, #128]	; (23820 <test_nb+0x2d0>)
   2379e:	239c      	movs	r3, #156	; 0x9c
   237a0:	4a20      	ldr	r2, [pc, #128]	; (23824 <test_nb+0x2d4>)
   237a2:	f018 ffc3 	bl	3c72c <printk>
   237a6:	219c      	movs	r1, #156	; 0x9c
   237a8:	481e      	ldr	r0, [pc, #120]	; (23824 <test_nb+0x2d4>)
   237aa:	f019 f805 	bl	3c7b8 <assert_post_action>

	return socket_ops->freeaddrinfo(res);
   237ae:	6823      	ldr	r3, [r4, #0]
   237b0:	4638      	mov	r0, r7
   237b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   237b4:	4798      	blx	r3
   237b6:	e741      	b.n	2363c <test_nb+0xec>
			LOG_INF("ai_addrlen = %u should be %u or %u\n",
   237b8:	2303      	movs	r3, #3
   237ba:	f04f 0000 	mov.w	r0, #0
   237be:	f04f 0918 	mov.w	r9, #24
   237c2:	f363 0007 	bfi	r0, r3, #0, #8
   237c6:	f365 108f 	bfi	r0, r5, #6, #10
   237ca:	f8cd 9000 	str.w	r9, [sp]
   237ce:	2308      	movs	r3, #8
   237d0:	492c      	ldr	r1, [pc, #176]	; (23884 <test_nb+0x334>)
   237d2:	f019 f802 	bl	3c7da <log_string_sync>
			sprintf(tmpbuf, "ai_addrlen = %u should be %u or %u",
   237d6:	2308      	movs	r3, #8
   237d8:	f8cd 9008 	str.w	r9, [sp, #8]
   237dc:	9301      	str	r3, [sp, #4]
   237de:	f8d8 3010 	ldr.w	r3, [r8, #16]
   237e2:	2280      	movs	r2, #128	; 0x80
   237e4:	9300      	str	r3, [sp, #0]
   237e6:	4639      	mov	r1, r7
   237e8:	4b27      	ldr	r3, [pc, #156]	; (23888 <test_nb+0x338>)
   237ea:	4814      	ldr	r0, [pc, #80]	; (2383c <test_nb+0x2ec>)
   237ec:	f01b f990 	bl	3eb10 <__sprintf_chk>
   237f0:	e7c0      	b.n	23774 <test_nb+0x224>
   237f2:	bf00      	nop
   237f4:	2002c116 	.word	0x2002c116
   237f8:	0003f99c 	.word	0x0003f99c
   237fc:	0003f8d4 	.word	0x0003f8d4
   23800:	000411c9 	.word	0x000411c9
   23804:	000411dd 	.word	0x000411dd
   23808:	000411f0 	.word	0x000411f0
   2380c:	00041200 	.word	0x00041200
   23810:	0004120a 	.word	0x0004120a
   23814:	20020d1c 	.word	0x20020d1c
   23818:	20024aec 	.word	0x20024aec
   2381c:	000411aa 	.word	0x000411aa
   23820:	00040606 	.word	0x00040606
   23824:	0004117a 	.word	0x0004117a
   23828:	000412b5 	.word	0x000412b5
   2382c:	000412cd 	.word	0x000412cd
   23830:	200298d6 	.word	0x200298d6
   23834:	000412e0 	.word	0x000412e0
   23838:	000412fe 	.word	0x000412fe
   2383c:	2002c217 	.word	0x2002c217
   23840:	000230cd 	.word	0x000230cd
   23844:	000413a8 	.word	0x000413a8
   23848:	2002c197 	.word	0x2002c197
   2384c:	2002c297 	.word	0x2002c297
   23850:	200345c8 	.word	0x200345c8
   23854:	000413b7 	.word	0x000413b7
   23858:	000413cf 	.word	0x000413cf
   2385c:	0004121e 	.word	0x0004121e
   23860:	00041237 	.word	0x00041237
   23864:	0004125e 	.word	0x0004125e
   23868:	0004124f 	.word	0x0004124f
   2386c:	00041267 	.word	0x00041267
   23870:	0004128c 	.word	0x0004128c
   23874:	000412a1 	.word	0x000412a1
   23878:	0004131b 	.word	0x0004131b
   2387c:	00041332 	.word	0x00041332
   23880:	0004138f 	.word	0x0004138f
   23884:	00041348 	.word	0x00041348
   23888:	0004136c 	.word	0x0004136c
	if(c->transport.type == MQTT_TRANSPORT_NON_SECURE)
   2388c:	4e48      	ldr	r6, [pc, #288]	; (239b0 <test_nb+0x460>)
   2388e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
	fds.events = POLLIN;
   23890:	80b7      	strh	r7, [r6, #4]
   23892:	6032      	str	r2, [r6, #0]
		err = poll(&fds, 1, mqtt_keepalive_time_left(&client));
   23894:	4620      	mov	r0, r4
   23896:	f019 fdac 	bl	3d3f2 <mqtt_keepalive_time_left>
   2389a:	f7ff fbe7 	bl	2306c <poll.constprop.7>
		if(err < 0)
   2389e:	2800      	cmp	r0, #0
   238a0:	da3c      	bge.n	2391c <test_nb+0x3cc>
			LOG_INF("ERROR: poll %d\n", errno);
   238a2:	2303      	movs	r3, #3
   238a4:	f04f 0400 	mov.w	r4, #0
   238a8:	f363 0407 	bfi	r4, r3, #0, #8
   238ac:	f019 f939 	bl	3cb22 <__errno>
   238b0:	f365 148f 	bfi	r4, r5, #6, #10
   238b4:	6802      	ldr	r2, [r0, #0]
   238b6:	493f      	ldr	r1, [pc, #252]	; (239b4 <test_nb+0x464>)
   238b8:	4620      	mov	r0, r4
   238ba:	f018 ff8e 	bl	3c7da <log_string_sync>
			sprintf(tmpbuf, "ERROR: poll %d", errno);
   238be:	f019 f930 	bl	3cb22 <__errno>
   238c2:	6803      	ldr	r3, [r0, #0]
   238c4:	9300      	str	r3, [sp, #0]
   238c6:	4b3c      	ldr	r3, [pc, #240]	; (239b8 <test_nb+0x468>)
				sprintf(tmpbuf, "ERROR: mqtt_input %d", err);
   238c8:	2280      	movs	r2, #128	; 0x80
   238ca:	2100      	movs	r1, #0
   238cc:	483b      	ldr	r0, [pc, #236]	; (239bc <test_nb+0x46c>)
   238ce:	f01b f91f 	bl	3eb10 <__sprintf_chk>
				show_infor(tmpbuf);
   238d2:	483a      	ldr	r0, [pc, #232]	; (239bc <test_nb+0x46c>)
			show_infor("POLLNVAL");
   238d4:	f017 f96b 	bl	3abae <show_infor>
	LOG_INF("Disconnecting MQTT client...\n");
   238d8:	2303      	movs	r3, #3
   238da:	f04f 0000 	mov.w	r0, #0
   238de:	f363 0007 	bfi	r0, r3, #0, #8
   238e2:	4937      	ldr	r1, [pc, #220]	; (239c0 <test_nb+0x470>)
   238e4:	f365 108f 	bfi	r0, r5, #6, #10
   238e8:	f018 ff77 	bl	3c7da <log_string_sync>
	show_infor("Disconnecting MQTT client...");
   238ec:	4835      	ldr	r0, [pc, #212]	; (239c4 <test_nb+0x474>)
   238ee:	f017 f95e 	bl	3abae <show_infor>
	err = mqtt_disconnect(&client);
   238f2:	4835      	ldr	r0, [pc, #212]	; (239c8 <test_nb+0x478>)
   238f4:	f019 fcdb 	bl	3d2ae <mqtt_disconnect>
	if(err)
   238f8:	4604      	mov	r4, r0
   238fa:	2800      	cmp	r0, #0
   238fc:	f43f aede 	beq.w	236bc <test_nb+0x16c>
		LOG_INF("Could not disconnect MQTT client. Error: %d\n", err);
   23900:	2303      	movs	r3, #3
   23902:	f04f 0000 	mov.w	r0, #0
   23906:	f363 0007 	bfi	r0, r3, #0, #8
   2390a:	f365 108f 	bfi	r0, r5, #6, #10
   2390e:	4622      	mov	r2, r4
   23910:	492e      	ldr	r1, [pc, #184]	; (239cc <test_nb+0x47c>)
   23912:	f018 ff62 	bl	3c7da <log_string_sync>
		sprintf(tmpbuf, "Could not disconnect MQTT client. Error: %d", err);
   23916:	9400      	str	r4, [sp, #0]
   23918:	4b2d      	ldr	r3, [pc, #180]	; (239d0 <test_nb+0x480>)
   2391a:	e6c7      	b.n	236ac <test_nb+0x15c>
		err = mqtt_live(&client);
   2391c:	4620      	mov	r0, r4
   2391e:	f019 fd41 	bl	3d3a4 <mqtt_live>
		if((err != 0) && (err != -EAGAIN))
   23922:	4607      	mov	r7, r0
   23924:	b180      	cbz	r0, 23948 <test_nb+0x3f8>
   23926:	f110 0f0b 	cmn.w	r0, #11
   2392a:	d00d      	beq.n	23948 <test_nb+0x3f8>
			LOG_INF("ERROR: mqtt_live %d\n", err);
   2392c:	2303      	movs	r3, #3
   2392e:	f04f 0000 	mov.w	r0, #0
   23932:	f363 0007 	bfi	r0, r3, #0, #8
   23936:	f365 108f 	bfi	r0, r5, #6, #10
   2393a:	463a      	mov	r2, r7
   2393c:	4925      	ldr	r1, [pc, #148]	; (239d4 <test_nb+0x484>)
   2393e:	f018 ff4c 	bl	3c7da <log_string_sync>
			sprintf(tmpbuf, "ERROR: mqtt_live %d", err);
   23942:	9700      	str	r7, [sp, #0]
   23944:	4b24      	ldr	r3, [pc, #144]	; (239d8 <test_nb+0x488>)
   23946:	e7bf      	b.n	238c8 <test_nb+0x378>
		if((fds.revents & POLLIN) == POLLIN)
   23948:	88f3      	ldrh	r3, [r6, #6]
   2394a:	07d9      	lsls	r1, r3, #31
   2394c:	d512      	bpl.n	23974 <test_nb+0x424>
			err = mqtt_input(&client);
   2394e:	4620      	mov	r0, r4
   23950:	f019 fd66 	bl	3d420 <mqtt_input>
			if(err != 0)
   23954:	4607      	mov	r7, r0
   23956:	b168      	cbz	r0, 23974 <test_nb+0x424>
				LOG_INF("ERROR: mqtt_input %d\n", err);
   23958:	2303      	movs	r3, #3
   2395a:	f04f 0000 	mov.w	r0, #0
   2395e:	f363 0007 	bfi	r0, r3, #0, #8
   23962:	f365 108f 	bfi	r0, r5, #6, #10
   23966:	463a      	mov	r2, r7
   23968:	491c      	ldr	r1, [pc, #112]	; (239dc <test_nb+0x48c>)
   2396a:	f018 ff36 	bl	3c7da <log_string_sync>
				sprintf(tmpbuf, "ERROR: mqtt_input %d", err);
   2396e:	9700      	str	r7, [sp, #0]
   23970:	4b1b      	ldr	r3, [pc, #108]	; (239e0 <test_nb+0x490>)
   23972:	e7a9      	b.n	238c8 <test_nb+0x378>
		if((fds.revents & POLLERR) == POLLERR)
   23974:	88f3      	ldrh	r3, [r6, #6]
   23976:	071a      	lsls	r2, r3, #28
   23978:	d50b      	bpl.n	23992 <test_nb+0x442>
			LOG_INF("POLLERR\n");
   2397a:	2303      	movs	r3, #3
   2397c:	f04f 0000 	mov.w	r0, #0
   23980:	f363 0007 	bfi	r0, r3, #0, #8
   23984:	f365 108f 	bfi	r0, r5, #6, #10
   23988:	4916      	ldr	r1, [pc, #88]	; (239e4 <test_nb+0x494>)
   2398a:	f018 ff26 	bl	3c7da <log_string_sync>
			show_infor("POLLERR");
   2398e:	4816      	ldr	r0, [pc, #88]	; (239e8 <test_nb+0x498>)
   23990:	e7a0      	b.n	238d4 <test_nb+0x384>
		if((fds.revents & POLLNVAL) == POLLNVAL)
   23992:	069b      	lsls	r3, r3, #26
   23994:	f57f af7e 	bpl.w	23894 <test_nb+0x344>
			LOG_INF("POLLNVAL\n");
   23998:	2303      	movs	r3, #3
   2399a:	f04f 0000 	mov.w	r0, #0
   2399e:	f363 0007 	bfi	r0, r3, #0, #8
   239a2:	f365 108f 	bfi	r0, r5, #6, #10
   239a6:	4911      	ldr	r1, [pc, #68]	; (239ec <test_nb+0x49c>)
   239a8:	f018 ff17 	bl	3c7da <log_string_sync>
			show_infor("POLLNVAL");
   239ac:	4810      	ldr	r0, [pc, #64]	; (239f0 <test_nb+0x4a0>)
   239ae:	e791      	b.n	238d4 <test_nb+0x384>
   239b0:	20020d98 	.word	0x20020d98
   239b4:	000413e6 	.word	0x000413e6
   239b8:	000413f6 	.word	0x000413f6
   239bc:	2002c217 	.word	0x2002c217
   239c0:	00040f65 	.word	0x00040f65
   239c4:	00040fa9 	.word	0x00040fa9
   239c8:	20020d1c 	.word	0x20020d1c
   239cc:	0004147d 	.word	0x0004147d
   239d0:	000414aa 	.word	0x000414aa
   239d4:	00041405 	.word	0x00041405
   239d8:	0004141a 	.word	0x0004141a
   239dc:	0004142e 	.word	0x0004142e
   239e0:	00041444 	.word	0x00041444
   239e4:	00041459 	.word	0x00041459
   239e8:	00041462 	.word	0x00041462
   239ec:	0004146a 	.word	0x0004146a
   239f0:	00041474 	.word	0x00041474

000239f4 <GetModemDateTime>:
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
	}
}

void GetModemDateTime(void)
{
   239f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   239f8:	b0aa      	sub	sp, #168	; 0xa8
	char *ptr;
	u8_t timebuf[128] = {0};
   239fa:	2280      	movs	r2, #128	; 0x80
   239fc:	2100      	movs	r1, #0
   239fe:	a80a      	add	r0, sp, #40	; 0x28
   23a00:	f01a ff44 	bl	3e88c <memset>
	u8_t tmpbuf[10] = {0};
   23a04:	2300      	movs	r3, #0
	u8_t tz_dir[2],tz_count;

	if(at_cmd_write("AT+CCLK?", timebuf, sizeof(timebuf), NULL) != 0)
   23a06:	2280      	movs	r2, #128	; 0x80
   23a08:	a90a      	add	r1, sp, #40	; 0x28
   23a0a:	4852      	ldr	r0, [pc, #328]	; (23b54 <GetModemDateTime+0x160>)
	u8_t tmpbuf[10] = {0};
   23a0c:	e9cd 3307 	strd	r3, r3, [sp, #28]
   23a10:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	if(at_cmd_write("AT+CCLK?", timebuf, sizeof(timebuf), NULL) != 0)
   23a14:	f007 fd1c 	bl	2b450 <at_cmd_write>
   23a18:	4f4f      	ldr	r7, [pc, #316]	; (23b58 <GetModemDateTime+0x164>)
   23a1a:	4b50      	ldr	r3, [pc, #320]	; (23b5c <GetModemDateTime+0x168>)
   23a1c:	4605      	mov	r5, r0
   23a1e:	1aff      	subs	r7, r7, r3
	{
		LOG_INF("Get CCLK fail!\n");
   23a20:	f04f 0000 	mov.w	r0, #0
   23a24:	2303      	movs	r3, #3
   23a26:	f3c7 07c9 	ubfx	r7, r7, #3, #10
   23a2a:	f363 0007 	bfi	r0, r3, #0, #8
   23a2e:	f367 108f 	bfi	r0, r7, #6, #10
	if(at_cmd_write("AT+CCLK?", timebuf, sizeof(timebuf), NULL) != 0)
   23a32:	b12d      	cbz	r5, 23a40 <GetModemDateTime+0x4c>
		LOG_INF("Get CCLK fail!\n");
   23a34:	494a      	ldr	r1, [pc, #296]	; (23b60 <GetModemDateTime+0x16c>)
   23a36:	f018 fed0 	bl	3c7da <log_string_sync>
					date_time.hour,date_time.minute,date_time.second,
					date_time.week);

	RedrawSystemTime();
	SaveSystemDateTime();
}
   23a3a:	b02a      	add	sp, #168	; 0xa8
   23a3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	LOG_INF("%s\n", timebuf);
   23a40:	aa0a      	add	r2, sp, #40	; 0x28
   23a42:	4948      	ldr	r1, [pc, #288]	; (23b64 <GetModemDateTime+0x170>)
   23a44:	f018 fec9 	bl	3c7da <log_string_sync>
	ptr = strstr(timebuf, "\"");
   23a48:	4947      	ldr	r1, [pc, #284]	; (23b68 <GetModemDateTime+0x174>)
   23a4a:	a80a      	add	r0, sp, #40	; 0x28
   23a4c:	f01b f8b4 	bl	3ebb8 <strstr>
	if(ptr)
   23a50:	4c46      	ldr	r4, [pc, #280]	; (23b6c <GetModemDateTime+0x178>)
   23a52:	4606      	mov	r6, r0
   23a54:	2800      	cmp	r0, #0
   23a56:	d058      	beq.n	23b0a <GetModemDateTime+0x116>
		memcpy(tmpbuf, ptr, 2);
   23a58:	f8b0 3001 	ldrh.w	r3, [r0, #1]
		date_time.year = 2000+atoi(tmpbuf);
   23a5c:	a807      	add	r0, sp, #28
		memcpy(tmpbuf, ptr, 2);
   23a5e:	f8ad 301c 	strh.w	r3, [sp, #28]
		date_time.year = 2000+atoi(tmpbuf);
   23a62:	f01a fed3 	bl	3e80c <atoi>
		memset(tmpbuf, 0, sizeof(tmpbuf));
   23a66:	e9cd 5507 	strd	r5, r5, [sp, #28]
   23a6a:	f8ad 5024 	strh.w	r5, [sp, #36]	; 0x24
		memcpy(tmpbuf, ptr, 2);
   23a6e:	88b3      	ldrh	r3, [r6, #4]
		date_time.year = 2000+atoi(tmpbuf);
   23a70:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
   23a74:	8020      	strh	r0, [r4, #0]
		date_time.month= atoi(tmpbuf);
   23a76:	a807      	add	r0, sp, #28
		memcpy(tmpbuf, ptr, 2);
   23a78:	f8ad 301c 	strh.w	r3, [sp, #28]
		date_time.month= atoi(tmpbuf);
   23a7c:	f01a fec6 	bl	3e80c <atoi>
		memset(tmpbuf, 0, sizeof(tmpbuf));
   23a80:	e9cd 5507 	strd	r5, r5, [sp, #28]
   23a84:	f8ad 5024 	strh.w	r5, [sp, #36]	; 0x24
		memcpy(tmpbuf, ptr, 2);
   23a88:	f8b6 3007 	ldrh.w	r3, [r6, #7]
		date_time.month= atoi(tmpbuf);
   23a8c:	70a0      	strb	r0, [r4, #2]
		date_time.day = atoi(tmpbuf);
   23a8e:	a807      	add	r0, sp, #28
		memcpy(tmpbuf, ptr, 2);
   23a90:	f8ad 301c 	strh.w	r3, [sp, #28]
		date_time.day = atoi(tmpbuf);
   23a94:	f01a feba 	bl	3e80c <atoi>
		memset(tmpbuf, 0, sizeof(tmpbuf));
   23a98:	f8cd 5022 	str.w	r5, [sp, #34]	; 0x22
		memcpy(tmpbuf, ptr, 2);
   23a9c:	8973      	ldrh	r3, [r6, #10]
		date_time.day = atoi(tmpbuf);
   23a9e:	70e0      	strb	r0, [r4, #3]
		date_time.hour = atoi(tmpbuf);
   23aa0:	a807      	add	r0, sp, #28
		memcpy(tmpbuf, ptr, 2);
   23aa2:	f8ad 301c 	strh.w	r3, [sp, #28]
		memset(tmpbuf, 0, sizeof(tmpbuf));
   23aa6:	f8cd 501e 	str.w	r5, [sp, #30]
		date_time.hour = atoi(tmpbuf);
   23aaa:	f01a feaf 	bl	3e80c <atoi>
		memset(tmpbuf, 0, sizeof(tmpbuf));
   23aae:	f8cd 5022 	str.w	r5, [sp, #34]	; 0x22
		memcpy(tmpbuf, ptr, 2);
   23ab2:	f8b6 300d 	ldrh.w	r3, [r6, #13]
		date_time.hour = atoi(tmpbuf);
   23ab6:	7120      	strb	r0, [r4, #4]
		date_time.minute = atoi(tmpbuf);
   23ab8:	a807      	add	r0, sp, #28
		memcpy(tmpbuf, ptr, 2);
   23aba:	f8ad 301c 	strh.w	r3, [sp, #28]
		memset(tmpbuf, 0, sizeof(tmpbuf));
   23abe:	f8cd 501e 	str.w	r5, [sp, #30]
		date_time.minute = atoi(tmpbuf);
   23ac2:	f01a fea3 	bl	3e80c <atoi>
		memcpy(tmpbuf, ptr, 2);
   23ac6:	8a33      	ldrh	r3, [r6, #16]
		date_time.minute = atoi(tmpbuf);
   23ac8:	7160      	strb	r0, [r4, #5]
		date_time.second = atoi(tmpbuf);
   23aca:	a807      	add	r0, sp, #28
		memcpy(tmpbuf, ptr, 2);
   23acc:	f8ad 301c 	strh.w	r3, [sp, #28]
		memset(tmpbuf, 0, sizeof(tmpbuf));
   23ad0:	f8cd 501e 	str.w	r5, [sp, #30]
   23ad4:	f8cd 5022 	str.w	r5, [sp, #34]	; 0x22
		date_time.second = atoi(tmpbuf);
   23ad8:	f01a fe98 	bl	3e80c <atoi>
		memcpy(tz_dir, ptr, 1);
   23adc:	f896 8012 	ldrb.w	r8, [r6, #18]
		memcpy(tmpbuf, ptr, 2);
   23ae0:	f8b6 3013 	ldrh.w	r3, [r6, #19]
		date_time.second = atoi(tmpbuf);
   23ae4:	71a0      	strb	r0, [r4, #6]
		tz_count = atoi(tmpbuf);
   23ae6:	a807      	add	r0, sp, #28
		memset(tmpbuf, 0, sizeof(tmpbuf));
   23ae8:	f8cd 501e 	str.w	r5, [sp, #30]
   23aec:	f8cd 5022 	str.w	r5, [sp, #34]	; 0x22
		memcpy(tmpbuf, ptr, 2);
   23af0:	f8ad 301c 	strh.w	r3, [sp, #28]
		tz_count = atoi(tmpbuf);
   23af4:	f01a fe8a 	bl	3e80c <atoi>
		if(tz_dir[0] == '+')
   23af8:	f1b8 0f2b 	cmp.w	r8, #43	; 0x2b
   23afc:	d120      	bne.n	23b40 <GetModemDateTime+0x14c>
			TimeIncrease(&date_time, tz_count*15);
   23afe:	b2c1      	uxtb	r1, r0
   23b00:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
   23b04:	4620      	mov	r0, r4
   23b06:	f7fc fc69 	bl	203dc <TimeIncrease>
	LOG_INF("real time:%04d/%02d/%02d,%02d:%02d:%02d,%02d\n", 
   23b0a:	2303      	movs	r3, #3
   23b0c:	f04f 0000 	mov.w	r0, #0
   23b10:	f363 0007 	bfi	r0, r3, #0, #8
   23b14:	79e3      	ldrb	r3, [r4, #7]
   23b16:	f367 108f 	bfi	r0, r7, #6, #10
   23b1a:	9304      	str	r3, [sp, #16]
   23b1c:	79a3      	ldrb	r3, [r4, #6]
   23b1e:	8822      	ldrh	r2, [r4, #0]
   23b20:	9303      	str	r3, [sp, #12]
   23b22:	7963      	ldrb	r3, [r4, #5]
   23b24:	4912      	ldr	r1, [pc, #72]	; (23b70 <GetModemDateTime+0x17c>)
   23b26:	9302      	str	r3, [sp, #8]
   23b28:	7923      	ldrb	r3, [r4, #4]
   23b2a:	9301      	str	r3, [sp, #4]
   23b2c:	78e3      	ldrb	r3, [r4, #3]
   23b2e:	9300      	str	r3, [sp, #0]
   23b30:	78a3      	ldrb	r3, [r4, #2]
   23b32:	f018 fe52 	bl	3c7da <log_string_sync>
	RedrawSystemTime();
   23b36:	f7fc fceb 	bl	20510 <RedrawSystemTime>
	SaveSystemDateTime();
   23b3a:	f7fd ff37 	bl	219ac <SaveSystemDateTime>
   23b3e:	e77c      	b.n	23a3a <GetModemDateTime+0x46>
		else if(tz_dir[0] == '-')
   23b40:	f1b8 0f2d 	cmp.w	r8, #45	; 0x2d
   23b44:	d1e1      	bne.n	23b0a <GetModemDateTime+0x116>
			TimeDecrease(&date_time, tz_count*15);
   23b46:	b2c1      	uxtb	r1, r0
   23b48:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
   23b4c:	4620      	mov	r0, r4
   23b4e:	f7fc fca1 	bl	20494 <TimeDecrease>
   23b52:	e7da      	b.n	23b0a <GetModemDateTime+0x116>
   23b54:	00040cb7 	.word	0x00040cb7
   23b58:	0003f99c 	.word	0x0003f99c
   23b5c:	0003f8d4 	.word	0x0003f8d4
   23b60:	00040cc0 	.word	0x00040cc0
   23b64:	00042f6c 	.word	0x00042f6c
   23b68:	00040cd0 	.word	0x00040cd0
   23b6c:	20029894 	.word	0x20029894
   23b70:	00040cd2 	.word	0x00040cd2

00023b74 <GetModemInfor>:

void GetModemInfor(void)
{
   23b74:	b5f0      	push	{r4, r5, r6, r7, lr}
   23b76:	b0c1      	sub	sp, #260	; 0x104
	char *ptr;
	int i=0,len,err;
	u8_t tmpbuf[128] = {0};
   23b78:	466c      	mov	r4, sp
   23b7a:	2280      	movs	r2, #128	; 0x80
   23b7c:	2100      	movs	r1, #0
   23b7e:	4620      	mov	r0, r4
   23b80:	f01a fe84 	bl	3e88c <memset>
	u8_t strbuf[128] = {0};
   23b84:	2280      	movs	r2, #128	; 0x80
   23b86:	2100      	movs	r1, #0
   23b88:	eb0d 0002 	add.w	r0, sp, r2
   23b8c:	f01a fe7e 	bl	3e88c <memset>

	if(at_cmd_write(CMD_GET_IMEI, tmpbuf, sizeof(tmpbuf), NULL) != 0)
   23b90:	2300      	movs	r3, #0
   23b92:	2280      	movs	r2, #128	; 0x80
   23b94:	4621      	mov	r1, r4
   23b96:	4838      	ldr	r0, [pc, #224]	; (23c78 <GetModemInfor+0x104>)
   23b98:	f007 fc5a 	bl	2b450 <at_cmd_write>
   23b9c:	4d37      	ldr	r5, [pc, #220]	; (23c7c <GetModemInfor+0x108>)
   23b9e:	4b38      	ldr	r3, [pc, #224]	; (23c80 <GetModemInfor+0x10c>)
   23ba0:	4606      	mov	r6, r0
   23ba2:	1aed      	subs	r5, r5, r3
	{
		LOG_INF("Get imei fail!\n");
   23ba4:	f04f 0000 	mov.w	r0, #0
   23ba8:	2303      	movs	r3, #3
   23baa:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   23bae:	f363 0007 	bfi	r0, r3, #0, #8
   23bb2:	f365 108f 	bfi	r0, r5, #6, #10
	if(at_cmd_write(CMD_GET_IMEI, tmpbuf, sizeof(tmpbuf), NULL) != 0)
   23bb6:	b126      	cbz	r6, 23bc2 <GetModemInfor+0x4e>
		LOG_INF("Get imei fail!\n");
   23bb8:	4932      	ldr	r1, [pc, #200]	; (23c84 <GetModemInfor+0x110>)
	LOG_INF("imsi:%s\n", tmpbuf);
	strncpy(g_imsi, tmpbuf, IMSI_MAX_LEN);

	if(at_cmd_write(CMD_GET_RSRP, tmpbuf, sizeof(tmpbuf), NULL) != 0)
	{
		LOG_INF("Get rsrp fail!\n");
   23bba:	f018 fe0e 	bl	3c7da <log_string_sync>
		i++;
	}

	memcpy((char*)strbuf, ptr, len-(ptr-(char*)tmpbuf));
	modem_rsrp_handler(atoi(strbuf));
}
   23bbe:	b041      	add	sp, #260	; 0x104
   23bc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	LOG_INF("imei:%s\n", tmpbuf);
   23bc2:	4622      	mov	r2, r4
   23bc4:	4930      	ldr	r1, [pc, #192]	; (23c88 <GetModemInfor+0x114>)
   23bc6:	f018 fe08 	bl	3c7da <log_string_sync>
	strncpy(g_imei, tmpbuf, IMEI_MAX_LEN);
   23bca:	2210      	movs	r2, #16
   23bcc:	4621      	mov	r1, r4
   23bce:	482f      	ldr	r0, [pc, #188]	; (23c8c <GetModemInfor+0x118>)
   23bd0:	f01a ffdf 	bl	3eb92 <strncpy>
	if(at_cmd_write(CMD_GET_IMSI, tmpbuf, sizeof(tmpbuf), NULL) != 0)
   23bd4:	4633      	mov	r3, r6
   23bd6:	2280      	movs	r2, #128	; 0x80
   23bd8:	4621      	mov	r1, r4
   23bda:	482d      	ldr	r0, [pc, #180]	; (23c90 <GetModemInfor+0x11c>)
   23bdc:	f007 fc38 	bl	2b450 <at_cmd_write>
		LOG_INF("Get imsi fail!\n");
   23be0:	2303      	movs	r3, #3
	if(at_cmd_write(CMD_GET_IMSI, tmpbuf, sizeof(tmpbuf), NULL) != 0)
   23be2:	4606      	mov	r6, r0
		LOG_INF("Get imsi fail!\n");
   23be4:	f04f 0000 	mov.w	r0, #0
   23be8:	f363 0007 	bfi	r0, r3, #0, #8
   23bec:	f365 108f 	bfi	r0, r5, #6, #10
	if(at_cmd_write(CMD_GET_IMSI, tmpbuf, sizeof(tmpbuf), NULL) != 0)
   23bf0:	b10e      	cbz	r6, 23bf6 <GetModemInfor+0x82>
		LOG_INF("Get imsi fail!\n");
   23bf2:	4928      	ldr	r1, [pc, #160]	; (23c94 <GetModemInfor+0x120>)
   23bf4:	e7e1      	b.n	23bba <GetModemInfor+0x46>
	LOG_INF("imsi:%s\n", tmpbuf);
   23bf6:	4622      	mov	r2, r4
   23bf8:	4927      	ldr	r1, [pc, #156]	; (23c98 <GetModemInfor+0x124>)
   23bfa:	f018 fdee 	bl	3c7da <log_string_sync>
	strncpy(g_imsi, tmpbuf, IMSI_MAX_LEN);
   23bfe:	2210      	movs	r2, #16
   23c00:	4621      	mov	r1, r4
   23c02:	4826      	ldr	r0, [pc, #152]	; (23c9c <GetModemInfor+0x128>)
   23c04:	f01a ffc5 	bl	3eb92 <strncpy>
	if(at_cmd_write(CMD_GET_RSRP, tmpbuf, sizeof(tmpbuf), NULL) != 0)
   23c08:	4633      	mov	r3, r6
   23c0a:	2280      	movs	r2, #128	; 0x80
   23c0c:	4621      	mov	r1, r4
   23c0e:	4824      	ldr	r0, [pc, #144]	; (23ca0 <GetModemInfor+0x12c>)
   23c10:	f007 fc1e 	bl	2b450 <at_cmd_write>
   23c14:	b140      	cbz	r0, 23c28 <GetModemInfor+0xb4>
		LOG_INF("Get rsrp fail!\n");
   23c16:	f04f 0000 	mov.w	r0, #0
   23c1a:	2303      	movs	r3, #3
   23c1c:	f363 0007 	bfi	r0, r3, #0, #8
   23c20:	f365 108f 	bfi	r0, r5, #6, #10
   23c24:	491f      	ldr	r1, [pc, #124]	; (23ca4 <GetModemInfor+0x130>)
   23c26:	e7c8      	b.n	23bba <GetModemInfor+0x46>
	LOG_INF("rsrp:%s\n", tmpbuf);
   23c28:	2303      	movs	r3, #3
   23c2a:	f04f 0000 	mov.w	r0, #0
   23c2e:	f363 0007 	bfi	r0, r3, #0, #8
   23c32:	f365 108f 	bfi	r0, r5, #6, #10
   23c36:	4622      	mov	r2, r4
   23c38:	491b      	ldr	r1, [pc, #108]	; (23ca8 <GetModemInfor+0x134>)
   23c3a:	f018 fdce 	bl	3c7da <log_string_sync>
	len = strlen(tmpbuf);
   23c3e:	4620      	mov	r0, r4
   23c40:	f7f9 fa8a 	bl	1d158 <strlen>
   23c44:	2505      	movs	r5, #5
   23c46:	4606      	mov	r6, r0
	ptr = tmpbuf;
   23c48:	4620      	mov	r0, r4
		ptr = strstr(ptr, ",");
   23c4a:	4f18      	ldr	r7, [pc, #96]	; (23cac <GetModemInfor+0x138>)
   23c4c:	4639      	mov	r1, r7
   23c4e:	f01a ffb3 	bl	3ebb8 <strstr>
	while(i<5)
   23c52:	3d01      	subs	r5, #1
		ptr++;
   23c54:	f100 0001 	add.w	r0, r0, #1
	while(i<5)
   23c58:	d1f8      	bne.n	23c4c <GetModemInfor+0xd8>
	memcpy((char*)strbuf, ptr, len-(ptr-(char*)tmpbuf));
   23c5a:	2380      	movs	r3, #128	; 0x80
   23c5c:	1b04      	subs	r4, r0, r4
   23c5e:	4601      	mov	r1, r0
   23c60:	1b32      	subs	r2, r6, r4
   23c62:	eb0d 0003 	add.w	r0, sp, r3
   23c66:	f01a fdfe 	bl	3e866 <__memcpy_chk>
	modem_rsrp_handler(atoi(strbuf));
   23c6a:	a820      	add	r0, sp, #128	; 0x80
   23c6c:	f01a fdce 	bl	3e80c <atoi>
   23c70:	b2c0      	uxtb	r0, r0
   23c72:	f7ff f99f 	bl	22fb4 <modem_rsrp_handler>
   23c76:	e7a2      	b.n	23bbe <GetModemInfor+0x4a>
   23c78:	00040d00 	.word	0x00040d00
   23c7c:	0003f99c 	.word	0x0003f99c
   23c80:	0003f8d4 	.word	0x0003f8d4
   23c84:	00040d08 	.word	0x00040d08
   23c88:	00040d18 	.word	0x00040d18
   23c8c:	2002c0f5 	.word	0x2002c0f5
   23c90:	00040d21 	.word	0x00040d21
   23c94:	00040d29 	.word	0x00040d29
   23c98:	00040d39 	.word	0x00040d39
   23c9c:	2002c105 	.word	0x2002c105
   23ca0:	00040d42 	.word	0x00040d42
   23ca4:	00040d4a 	.word	0x00040d4a
   23ca8:	00040d5a 	.word	0x00040d5a
   23cac:	00040d63 	.word	0x00040d63

00023cb0 <nb_link>:

static void nb_link(struct k_work *work)
{
   23cb0:	b508      	push	{r3, lr}
	int err;

	err = lte_lc_init_and_connect();
   23cb2:	f01a fb8e 	bl	3e3d2 <lte_lc_init_and_connect>
	if(err)
   23cb6:	4b11      	ldr	r3, [pc, #68]	; (23cfc <nb_link+0x4c>)
   23cb8:	4a11      	ldr	r2, [pc, #68]	; (23d00 <nb_link+0x50>)
   23cba:	1a9b      	subs	r3, r3, r2
   23cbc:	f3c3 03c9 	ubfx	r3, r3, #3, #10
   23cc0:	b168      	cbz	r0, 23cde <nb_link+0x2e>
	{
		LOG_INF("Can't connected to LTE network");
   23cc2:	f04f 0000 	mov.w	r0, #0
   23cc6:	2203      	movs	r2, #3
   23cc8:	f362 0007 	bfi	r0, r2, #0, #8
   23ccc:	f363 108f 	bfi	r0, r3, #6, #10
   23cd0:	490c      	ldr	r1, [pc, #48]	; (23d04 <nb_link+0x54>)
   23cd2:	f018 fd82 	bl	3c7da <log_string_sync>
		GetModemDateTime();
		modem_data_init();
	}

	GetModemInfor();
}
   23cd6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	GetModemInfor();
   23cda:	f7ff bf4b 	b.w	23b74 <GetModemInfor>
		LOG_INF("Connected to LTE network");
   23cde:	2203      	movs	r2, #3
   23ce0:	f04f 0000 	mov.w	r0, #0
   23ce4:	f362 0007 	bfi	r0, r2, #0, #8
   23ce8:	f363 108f 	bfi	r0, r3, #6, #10
   23cec:	4906      	ldr	r1, [pc, #24]	; (23d08 <nb_link+0x58>)
   23cee:	f018 fd74 	bl	3c7da <log_string_sync>
		GetModemDateTime();
   23cf2:	f7ff fe7f 	bl	239f4 <GetModemDateTime>
		modem_data_init();
   23cf6:	f7ff fc03 	bl	23500 <modem_data_init>
   23cfa:	e7ec      	b.n	23cd6 <nb_link+0x26>
   23cfc:	0003f99c 	.word	0x0003f99c
   23d00:	0003f8d4 	.word	0x0003f8d4
   23d04:	00041142 	.word	0x00041142
   23d08:	00041161 	.word	0x00041161

00023d0c <NBMsgProcess>:
	LOG_INF("rsrp:%s\n", str_rsrp);
}

void NBMsgProcess(void)
{
	if(app_nb_on)
   23d0c:	4b05      	ldr	r3, [pc, #20]	; (23d24 <NBMsgProcess+0x18>)
   23d0e:	781a      	ldrb	r2, [r3, #0]
   23d10:	b132      	cbz	r2, 23d20 <NBMsgProcess+0x14>
	{
		app_nb_on = false;
   23d12:	2200      	movs	r2, #0
   23d14:	701a      	strb	r2, [r3, #0]
		if(nb_is_running)
   23d16:	4b04      	ldr	r3, [pc, #16]	; (23d28 <NBMsgProcess+0x1c>)
   23d18:	781b      	ldrb	r3, [r3, #0]
   23d1a:	b90b      	cbnz	r3, 23d20 <NBMsgProcess+0x14>
			return;
		
		test_nb();
   23d1c:	f7ff bc18 	b.w	23550 <test_nb>
	}
}
   23d20:	4770      	bx	lr
   23d22:	bf00      	nop
   23d24:	2002c0f4 	.word	0x2002c0f4
   23d28:	2002c116 	.word	0x2002c116

00023d2c <NB_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   23d2c:	490c      	ldr	r1, [pc, #48]	; (23d60 <NB_init+0x34>)
   23d2e:	4b0d      	ldr	r3, [pc, #52]	; (23d64 <NB_init+0x38>)

void NB_init(struct k_work_q *work_q)
{
   23d30:	b500      	push	{lr}
   23d32:	2200      	movs	r2, #0
   23d34:	604b      	str	r3, [r1, #4]
   23d36:	460b      	mov	r3, r1
   23d38:	600a      	str	r2, [r1, #0]
   23d3a:	f843 2f08 	str.w	r2, [r3, #8]!
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   23d3e:	e8d3 2fef 	ldaex	r2, [r3]
   23d42:	f042 0c01 	orr.w	ip, r2, #1
   23d46:	e8c3 cfee 	stlex	lr, ip, [r3]
   23d4a:	f1be 0f00 	cmp.w	lr, #0
   23d4e:	d1f6      	bne.n	23d3e <NB_init+0x12>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   23d50:	07d3      	lsls	r3, r2, #31
   23d52:	d403      	bmi.n	23d5c <NB_init+0x30>

	app_work_q = work_q;

	k_work_init(&link_work, nb_link);
	k_work_submit_to_queue(app_work_q, &link_work);
}
   23d54:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
   23d58:	f01a bbdf 	b.w	3e51a <k_queue_append>
   23d5c:	f85d fb04 	ldr.w	pc, [sp], #4
   23d60:	20020da0 	.word	0x20020da0
   23d64:	00023cb1 	.word	0x00023cb1

00023d68 <touch_panel_event_handle>:
	return false;
}

void touch_panel_event_handle(tp_event tp_type, u16_t x_pos, u16_t y_pos)
{
	switch(tp_type)
   23d68:	2806      	cmp	r0, #6
   23d6a:	d815      	bhi.n	23d98 <touch_panel_event_handle+0x30>
   23d6c:	e8df f000 	tbb	[pc, r0]
   23d70:	0b090704 	.word	0x0b090704
   23d74:	100d      	.short	0x100d
   23d76:	12          	.byte	0x12
   23d77:	00          	.byte	0x00
	{
	case TP_EVENT_MOVING_UP:
		printk("tp moving up!\n");
   23d78:	4808      	ldr	r0, [pc, #32]	; (23d9c <touch_panel_event_handle+0x34>)
		break;
	case TP_EVENT_MOVING_DOWN:
		printk("tp moving down!\n");
   23d7a:	f018 bcd7 	b.w	3c72c <printk>
   23d7e:	4808      	ldr	r0, [pc, #32]	; (23da0 <touch_panel_event_handle+0x38>)
   23d80:	e7fb      	b.n	23d7a <touch_panel_event_handle+0x12>
		break;
	case TP_EVENT_MOVING_LEFT:
		printk("tp moving left!\n");
   23d82:	4808      	ldr	r0, [pc, #32]	; (23da4 <touch_panel_event_handle+0x3c>)
   23d84:	e7f9      	b.n	23d7a <touch_panel_event_handle+0x12>
		break;
	case TP_EVENT_MOVING_RIGHT:
		printk("tp moving right!\n");
   23d86:	4808      	ldr	r0, [pc, #32]	; (23da8 <touch_panel_event_handle+0x40>)
   23d88:	e7f7      	b.n	23d7a <touch_panel_event_handle+0x12>
		break;
	case TP_EVENT_SINGLE_CLICK:
		printk("tp single click! x:%d, y:%d\n", x_pos,y_pos);
   23d8a:	4808      	ldr	r0, [pc, #32]	; (23dac <touch_panel_event_handle+0x44>)
		break;
	case TP_EVENT_DOUBLE_CLICK:
		printk("tp double click! x:%d, y:%d\n", x_pos,y_pos);
		break;
	case TP_EVENT_LONG_PRESS:
		printk("tp long press! x:%d, y:%d\n", x_pos,y_pos);
   23d8c:	f018 bcce 	b.w	3c72c <printk>
		printk("tp double click! x:%d, y:%d\n", x_pos,y_pos);
   23d90:	4807      	ldr	r0, [pc, #28]	; (23db0 <touch_panel_event_handle+0x48>)
   23d92:	e7fb      	b.n	23d8c <touch_panel_event_handle+0x24>
		printk("tp long press! x:%d, y:%d\n", x_pos,y_pos);
   23d94:	4807      	ldr	r0, [pc, #28]	; (23db4 <touch_panel_event_handle+0x4c>)
   23d96:	e7f9      	b.n	23d8c <touch_panel_event_handle+0x24>
		break;
	case TP_EVENT_MAX:
		break;
	}
}
   23d98:	4770      	bx	lr
   23d9a:	bf00      	nop
   23d9c:	000414d6 	.word	0x000414d6
   23da0:	000414e5 	.word	0x000414e5
   23da4:	000414f6 	.word	0x000414f6
   23da8:	00041507 	.word	0x00041507
   23dac:	00041519 	.word	0x00041519
   23db0:	00041536 	.word	0x00041536
   23db4:	00041553 	.word	0x00041553

00023db8 <interrupt_event>:
	int2_event = true;
   23db8:	2201      	movs	r2, #1
   23dba:	4b01      	ldr	r3, [pc, #4]	; (23dc0 <interrupt_event+0x8>)
   23dbc:	701a      	strb	r2, [r3, #0]
}
   23dbe:	4770      	bx	lr
   23dc0:	2002c323 	.word	0x2002c323

00023dc4 <step_event>:
	int1_event = true;
   23dc4:	2201      	movs	r2, #1
   23dc6:	4b01      	ldr	r3, [pc, #4]	; (23dcc <step_event+0x8>)
   23dc8:	701a      	strb	r2, [r3, #0]
}
   23dca:	4770      	bx	lr
   23dcc:	2002c31d 	.word	0x2002c31d

00023dd0 <platform_write>:
{
   23dd0:	b5b0      	push	{r4, r5, r7, lr}
   23dd2:	b084      	sub	sp, #16
	uint8_t data[len+1];
   23dd4:	4668      	mov	r0, sp
{
   23dd6:	4615      	mov	r5, r2
	uint8_t data[len+1];
   23dd8:	f103 0208 	add.w	r2, r3, #8
   23ddc:	08d2      	lsrs	r2, r2, #3
   23dde:	eba0 02c2 	sub.w	r2, r0, r2, lsl #3
{
   23de2:	af00      	add	r7, sp, #0
	uint8_t data[len+1];
   23de4:	4695      	mov	sp, r2
	data[0] = reg;
   23de6:	4668      	mov	r0, sp
   23de8:	461a      	mov	r2, r3
   23dea:	f800 1b01 	strb.w	r1, [r0], #1
   23dee:	4629      	mov	r1, r5
	uint8_t data[len+1];
   23df0:	1c5c      	adds	r4, r3, #1
   23df2:	f01a fd2b 	bl	3e84c <memcpy>
	rslt = i2c_write(i2c_imu, data, len+1, LSM6DSO_I2C_ADD);
   23df6:	4b08      	ldr	r3, [pc, #32]	; (23e18 <platform_write+0x48>)
static inline int i2c_write(struct device *dev, const u8_t *buf,
			    u32_t num_bytes, u16_t addr)
{
	struct i2c_msg msg;

	msg.buf = (u8_t *)buf;
   23df8:	f8c7 d004 	str.w	sp, [r7, #4]
   23dfc:	6818      	ldr	r0, [r3, #0]
	msg.len = num_bytes;
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   23dfe:	2302      	movs	r3, #2
	msg.len = num_bytes;
   23e00:	60bc      	str	r4, [r7, #8]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   23e02:	733b      	strb	r3, [r7, #12]
	return api->transfer(dev, msgs, num_msgs, addr);
   23e04:	6843      	ldr	r3, [r0, #4]
   23e06:	1d39      	adds	r1, r7, #4
   23e08:	685c      	ldr	r4, [r3, #4]
   23e0a:	2201      	movs	r2, #1
   23e0c:	236a      	movs	r3, #106	; 0x6a
   23e0e:	47a0      	blx	r4
}
   23e10:	3710      	adds	r7, #16
   23e12:	46bd      	mov	sp, r7
   23e14:	bdb0      	pop	{r4, r5, r7, pc}
   23e16:	bf00      	nop
   23e18:	20024630 	.word	0x20024630

00023e1c <platform_read>:
{
   23e1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   23e20:	b086      	sub	sp, #24
   23e22:	461e      	mov	r6, r3
	msg.buf = (u8_t *)buf;
   23e24:	f10d 0307 	add.w	r3, sp, #7
   23e28:	9303      	str	r3, [sp, #12]
	msg.len = num_bytes;
   23e2a:	2401      	movs	r4, #1
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   23e2c:	2302      	movs	r3, #2
	rslt = i2c_write(i2c_imu, &reg, 1, LSM6DSO_I2C_ADD);
   23e2e:	4d0f      	ldr	r5, [pc, #60]	; (23e6c <platform_read+0x50>)
{
   23e30:	4617      	mov	r7, r2
   23e32:	f88d 1007 	strb.w	r1, [sp, #7]
	rslt = i2c_write(i2c_imu, &reg, 1, LSM6DSO_I2C_ADD);
   23e36:	6828      	ldr	r0, [r5, #0]
	msg.len = num_bytes;
   23e38:	9404      	str	r4, [sp, #16]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   23e3a:	f88d 3014 	strb.w	r3, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   23e3e:	6843      	ldr	r3, [r0, #4]
   23e40:	4622      	mov	r2, r4
   23e42:	f8d3 8004 	ldr.w	r8, [r3, #4]
   23e46:	a903      	add	r1, sp, #12
   23e48:	236a      	movs	r3, #106	; 0x6a
   23e4a:	47c0      	blx	r8
	if(rslt == 0)
   23e4c:	b958      	cbnz	r0, 23e66 <platform_read+0x4a>
{
	struct i2c_msg msg;

	msg.buf = buf;
	msg.len = num_bytes;
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
   23e4e:	2303      	movs	r3, #3
		rslt = i2c_read(i2c_imu, bufp, len, LSM6DSO_I2C_ADD);
   23e50:	6828      	ldr	r0, [r5, #0]
   23e52:	e9cd 7603 	strd	r7, r6, [sp, #12]
   23e56:	f88d 3014 	strb.w	r3, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   23e5a:	6843      	ldr	r3, [r0, #4]
   23e5c:	4622      	mov	r2, r4
   23e5e:	685d      	ldr	r5, [r3, #4]
   23e60:	a903      	add	r1, sp, #12
   23e62:	236a      	movs	r3, #106	; 0x6a
   23e64:	47a8      	blx	r5
}
   23e66:	b006      	add	sp, #24
   23e68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   23e6c:	20024630 	.word	0x20024630

00023e70 <init_gpio>:
{
   23e70:	b510      	push	{r4, lr}
   23e72:	4820      	ldr	r0, [pc, #128]	; (23ef4 <init_gpio+0x84>)
   23e74:	f011 fbd4 	bl	35620 <z_impl_device_get_binding>
	gpio_imu = device_get_binding(IMU_PORT);
   23e78:	4c1f      	ldr	r4, [pc, #124]	; (23ef8 <init_gpio+0x88>)
	gpio_pin_configure(gpio_imu, LSM6DSO_INT1_PIN, flag);
   23e7a:	f240 2236 	movw	r2, #566	; 0x236
   23e7e:	2109      	movs	r1, #9
	gpio_imu = device_get_binding(IMU_PORT);
   23e80:	6020      	str	r0, [r4, #0]
	gpio_pin_configure(gpio_imu, LSM6DSO_INT1_PIN, flag);
   23e82:	f016 ff29 	bl	3acd8 <gpio_pin_configure>
	gpio_pin_disable_callback(gpio_imu, LSM6DSO_INT1_PIN);
   23e86:	2109      	movs	r1, #9
   23e88:	6820      	ldr	r0, [r4, #0]
   23e8a:	f016 ff13 	bl	3acb4 <gpio_pin_disable_callback>
	callback->handler = handler;
   23e8e:	491b      	ldr	r1, [pc, #108]	; (23efc <init_gpio+0x8c>)
   23e90:	4b1b      	ldr	r3, [pc, #108]	; (23f00 <init_gpio+0x90>)
	gpio_add_callback(gpio_imu, &gpio_cb1);
   23e92:	6820      	ldr	r0, [r4, #0]
   23e94:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
   23e96:	f44f 7300 	mov.w	r3, #512	; 0x200
   23e9a:	608b      	str	r3, [r1, #8]
   23e9c:	f016 fe95 	bl	3abca <gpio_add_callback>
	gpio_pin_enable_callback(gpio_imu, LSM6DSO_INT1_PIN);
   23ea0:	2109      	movs	r1, #9
   23ea2:	6820      	ldr	r0, [r4, #0]
   23ea4:	f016 ff0f 	bl	3acc6 <gpio_pin_enable_callback>
	gpio_pin_configure(gpio_imu, LSM6DSO_INT2_PIN, flag);
   23ea8:	f240 2236 	movw	r2, #566	; 0x236
   23eac:	210a      	movs	r1, #10
   23eae:	6820      	ldr	r0, [r4, #0]
   23eb0:	f016 ff12 	bl	3acd8 <gpio_pin_configure>
	gpio_pin_disable_callback(gpio_imu, LSM6DSO_INT2_PIN);
   23eb4:	210a      	movs	r1, #10
   23eb6:	6820      	ldr	r0, [r4, #0]
   23eb8:	f016 fefc 	bl	3acb4 <gpio_pin_disable_callback>
	callback->handler = handler;
   23ebc:	4911      	ldr	r1, [pc, #68]	; (23f04 <init_gpio+0x94>)
   23ebe:	4b12      	ldr	r3, [pc, #72]	; (23f08 <init_gpio+0x98>)
	gpio_add_callback(gpio_imu, &gpio_cb2);
   23ec0:	6820      	ldr	r0, [r4, #0]
   23ec2:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
   23ec4:	f44f 6380 	mov.w	r3, #1024	; 0x400
   23ec8:	608b      	str	r3, [r1, #8]
   23eca:	f016 fe7e 	bl	3abca <gpio_add_callback>
	gpio_pin_enable_callback(gpio_imu, LSM6DSO_INT2_PIN);
   23ece:	210a      	movs	r1, #10
   23ed0:	6820      	ldr	r0, [r4, #0]
   23ed2:	f016 fef8 	bl	3acc6 <gpio_pin_enable_callback>
	gpio_pin_configure(gpio_imu, 17, GPIO_DIR_OUT);
   23ed6:	2201      	movs	r2, #1
   23ed8:	2111      	movs	r1, #17
   23eda:	6820      	ldr	r0, [r4, #0]
   23edc:	f016 fefc 	bl	3acd8 <gpio_pin_configure>
	gpio_pin_write(gpio_imu, 17, 0);
   23ee0:	6820      	ldr	r0, [r4, #0]
	return api->write(port, access_op, pin, value);
   23ee2:	6843      	ldr	r3, [r0, #4]
   23ee4:	2211      	movs	r2, #17
   23ee6:	685c      	ldr	r4, [r3, #4]
   23ee8:	2300      	movs	r3, #0
   23eea:	4619      	mov	r1, r3
   23eec:	47a0      	blx	r4
}
   23eee:	2000      	movs	r0, #0
   23ef0:	bd10      	pop	{r4, pc}
   23ef2:	bf00      	nop
   23ef4:	0004053a 	.word	0x0004053a
   23ef8:	20022a0c 	.word	0x20022a0c
   23efc:	200229f4 	.word	0x200229f4
   23f00:	00023dc5 	.word	0x00023dc5
   23f04:	20022a00 	.word	0x20022a00
   23f08:	00023db9 	.word	0x00023db9

00023f0c <sensor_init>:
{
   23f0c:	b570      	push	{r4, r5, r6, lr}
	lsm6dso_device_id_get(&imu_dev_ctx, &whoamI);
   23f0e:	4c64      	ldr	r4, [pc, #400]	; (240a0 <sensor_init+0x194>)
   23f10:	4864      	ldr	r0, [pc, #400]	; (240a4 <sensor_init+0x198>)
   23f12:	4621      	mov	r1, r4
   23f14:	f017 f99a 	bl	3b24c <lsm6dso_device_id_get>
	if(whoamI != LSM6DSO_ID)
   23f18:	7823      	ldrb	r3, [r4, #0]
   23f1a:	2b6c      	cmp	r3, #108	; 0x6c
   23f1c:	d000      	beq.n	23f20 <sensor_init+0x14>
		while(1);
   23f1e:	e7fe      	b.n	23f1e <sensor_init+0x12>
	lsm6dso_reset_set(&imu_dev_ctx, PROPERTY_ENABLE);
   23f20:	2101      	movs	r1, #1
   23f22:	4860      	ldr	r0, [pc, #384]	; (240a4 <sensor_init+0x198>)
   23f24:	f017 f997 	bl	3b256 <lsm6dso_reset_set>
		lsm6dso_reset_get(&imu_dev_ctx, &rst);
   23f28:	4d5f      	ldr	r5, [pc, #380]	; (240a8 <sensor_init+0x19c>)
   23f2a:	4e5e      	ldr	r6, [pc, #376]	; (240a4 <sensor_init+0x198>)
   23f2c:	495e      	ldr	r1, [pc, #376]	; (240a8 <sensor_init+0x19c>)
   23f2e:	4630      	mov	r0, r6
   23f30:	f017 f9a8 	bl	3b284 <lsm6dso_reset_get>
	}while(rst);
   23f34:	782c      	ldrb	r4, [r5, #0]
   23f36:	2c00      	cmp	r4, #0
   23f38:	d1f8      	bne.n	23f2c <sensor_init+0x20>
	lsm6dso_i3c_disable_set(&imu_dev_ctx, LSM6DSO_I3C_DISABLE);
   23f3a:	2180      	movs	r1, #128	; 0x80
   23f3c:	4859      	ldr	r0, [pc, #356]	; (240a4 <sensor_init+0x198>)
   23f3e:	f017 f9af 	bl	3b2a0 <lsm6dso_i3c_disable_set>
	lsm6dso_xl_full_scale_set(&imu_dev_ctx, LSM6DSO_2g);
   23f42:	4621      	mov	r1, r4
   23f44:	4857      	ldr	r0, [pc, #348]	; (240a4 <sensor_init+0x198>)
   23f46:	f016 fedf 	bl	3ad08 <lsm6dso_xl_full_scale_set>
	lsm6dso_gy_full_scale_set(&imu_dev_ctx, LSM6DSO_250dps);
   23f4a:	4621      	mov	r1, r4
   23f4c:	4855      	ldr	r0, [pc, #340]	; (240a4 <sensor_init+0x198>)
   23f4e:	f016 fef2 	bl	3ad36 <lsm6dso_gy_full_scale_set>
	lsm6dso_block_data_update_set(&imu_dev_ctx, PROPERTY_ENABLE);
   23f52:	2101      	movs	r1, #1
   23f54:	4853      	ldr	r0, [pc, #332]	; (240a4 <sensor_init+0x198>)
   23f56:	f016 ff05 	bl	3ad64 <lsm6dso_block_data_update_set>
	lsm6dso_fifo_watermark_set(&imu_dev_ctx, PATTERN_LEN);
   23f5a:	21c8      	movs	r1, #200	; 0xc8
   23f5c:	4851      	ldr	r0, [pc, #324]	; (240a4 <sensor_init+0x198>)
   23f5e:	f017 fd0a 	bl	3b976 <lsm6dso_fifo_watermark_set>
	lsm6dso_fifo_stop_on_wtm_set(&imu_dev_ctx, PROPERTY_ENABLE);
   23f62:	2101      	movs	r1, #1
   23f64:	484f      	ldr	r0, [pc, #316]	; (240a4 <sensor_init+0x198>)
   23f66:	f017 fd27 	bl	3b9b8 <lsm6dso_fifo_stop_on_wtm_set>
	lsm6dso_fifo_mode_set(&imu_dev_ctx, LSM6DSO_STREAM_TO_FIFO_MODE);
   23f6a:	2103      	movs	r1, #3
   23f6c:	484d      	ldr	r0, [pc, #308]	; (240a4 <sensor_init+0x198>)
   23f6e:	f017 fd68 	bl	3ba42 <lsm6dso_fifo_mode_set>
	lsm6dso_fifo_xl_batch_set(&imu_dev_ctx, LSM6DSO_XL_BATCHED_AT_104Hz);
   23f72:	2104      	movs	r1, #4
   23f74:	484b      	ldr	r0, [pc, #300]	; (240a4 <sensor_init+0x198>)
   23f76:	f017 fd36 	bl	3b9e6 <lsm6dso_fifo_xl_batch_set>
	lsm6dso_fifo_gy_batch_set(&imu_dev_ctx, LSM6DSO_GY_BATCHED_AT_104Hz);
   23f7a:	2104      	movs	r1, #4
   23f7c:	4849      	ldr	r0, [pc, #292]	; (240a4 <sensor_init+0x198>)
   23f7e:	f017 fd49 	bl	3ba14 <lsm6dso_fifo_gy_batch_set>
	lsm6dso_xl_data_rate_set(&imu_dev_ctx, LSM6DSO_XL_ODR_104Hz);
   23f82:	2104      	movs	r1, #4
   23f84:	4847      	ldr	r0, [pc, #284]	; (240a4 <sensor_init+0x198>)
   23f86:	f017 ff0e 	bl	3bda6 <lsm6dso_xl_data_rate_set>
	lsm6dso_gy_data_rate_set(&imu_dev_ctx, LSM6DSO_GY_ODR_104Hz);
   23f8a:	2104      	movs	r1, #4
   23f8c:	4845      	ldr	r0, [pc, #276]	; (240a4 <sensor_init+0x198>)
   23f8e:	f017 ff77 	bl	3be80 <lsm6dso_gy_data_rate_set>
	lsm6dso_xl_power_mode_set(&imu_dev_ctx, LSM6DSO_LOW_NORMAL_POWER_MD);
   23f92:	2101      	movs	r1, #1
   23f94:	4843      	ldr	r0, [pc, #268]	; (240a4 <sensor_init+0x198>)
   23f96:	f016 fefc 	bl	3ad92 <lsm6dso_xl_power_mode_set>
	lsm6dso_tap_detection_on_z_set(&imu_dev_ctx, PROPERTY_ENABLE);
   23f9a:	2101      	movs	r1, #1
   23f9c:	4841      	ldr	r0, [pc, #260]	; (240a4 <sensor_init+0x198>)
   23f9e:	f017 fc1b 	bl	3b7d8 <lsm6dso_tap_detection_on_z_set>
	lsm6dso_tap_detection_on_y_set(&imu_dev_ctx, PROPERTY_ENABLE);
   23fa2:	2101      	movs	r1, #1
   23fa4:	483f      	ldr	r0, [pc, #252]	; (240a4 <sensor_init+0x198>)
   23fa6:	f017 fc2e 	bl	3b806 <lsm6dso_tap_detection_on_y_set>
	lsm6dso_tap_detection_on_x_set(&imu_dev_ctx, PROPERTY_ENABLE);
   23faa:	2101      	movs	r1, #1
   23fac:	483d      	ldr	r0, [pc, #244]	; (240a4 <sensor_init+0x198>)
   23fae:	f017 fc41 	bl	3b834 <lsm6dso_tap_detection_on_x_set>
	lsm6dso_tap_threshold_x_set(&imu_dev_ctx, 0x12);
   23fb2:	2112      	movs	r1, #18
   23fb4:	483b      	ldr	r0, [pc, #236]	; (240a4 <sensor_init+0x198>)
   23fb6:	f017 fc54 	bl	3b862 <lsm6dso_tap_threshold_x_set>
	lsm6dso_tap_threshold_y_set(&imu_dev_ctx, 0x12);
   23fba:	2112      	movs	r1, #18
   23fbc:	4839      	ldr	r0, [pc, #228]	; (240a4 <sensor_init+0x198>)
   23fbe:	f017 fc67 	bl	3b890 <lsm6dso_tap_threshold_y_set>
	lsm6dso_tap_threshold_z_set(&imu_dev_ctx, 0x12);
   23fc2:	2112      	movs	r1, #18
   23fc4:	4837      	ldr	r0, [pc, #220]	; (240a4 <sensor_init+0x198>)
   23fc6:	f017 fc7a 	bl	3b8be <lsm6dso_tap_threshold_z_set>
	lsm6dso_tap_quiet_set(&imu_dev_ctx, 0x03);
   23fca:	2103      	movs	r1, #3
   23fcc:	4835      	ldr	r0, [pc, #212]	; (240a4 <sensor_init+0x198>)
   23fce:	f017 fca4 	bl	3b91a <lsm6dso_tap_quiet_set>
	lsm6dso_tap_shock_set(&imu_dev_ctx, 0x03);
   23fd2:	2103      	movs	r1, #3
   23fd4:	4833      	ldr	r0, [pc, #204]	; (240a4 <sensor_init+0x198>)
   23fd6:	f017 fc89 	bl	3b8ec <lsm6dso_tap_shock_set>
	lsm6dso_tap_mode_set(&imu_dev_ctx, LSM6DSO_ONLY_SINGLE);
   23fda:	4621      	mov	r1, r4
   23fdc:	4831      	ldr	r0, [pc, #196]	; (240a4 <sensor_init+0x198>)
   23fde:	f017 fcb3 	bl	3b948 <lsm6dso_tap_mode_set>
	lsm6dso_pedo_sens_set(&imu_dev_ctx, LSM6DSO_PEDO_BASE_MODE);
   23fe2:	2101      	movs	r1, #1
   23fe4:	482f      	ldr	r0, [pc, #188]	; (240a4 <sensor_init+0x198>)
   23fe6:	f017 fdb3 	bl	3bb50 <lsm6dso_pedo_sens_set>
	lsm6dso_int_notification_set(&imu_dev_ctx, LSM6DSO_BASE_PULSED_EMB_LATCHED);
   23fea:	2102      	movs	r1, #2
   23fec:	482d      	ldr	r0, [pc, #180]	; (240a4 <sensor_init+0x198>)
   23fee:	f017 fbb9 	bl	3b764 <lsm6dso_int_notification_set>
	lsm6dso_long_cnt_int_value_set(&imu_dev_ctx, 0x0000U);
   23ff2:	4621      	mov	r1, r4
   23ff4:	482b      	ldr	r0, [pc, #172]	; (240a4 <sensor_init+0x198>)
   23ff6:	f017 ffb0 	bl	3bf5a <lsm6dso_long_cnt_int_value_set>
	lsm6dso_fsm_enable_get(&imu_dev_ctx, &fsm_enable);
   23ffa:	4c2c      	ldr	r4, [pc, #176]	; (240ac <sensor_init+0x1a0>)
	lsm6dso_fsm_start_address_set(&imu_dev_ctx, LSM6DSO_START_FSM_ADD);
   23ffc:	f44f 6180 	mov.w	r1, #1024	; 0x400
   24000:	4828      	ldr	r0, [pc, #160]	; (240a4 <sensor_init+0x198>)
   24002:	f017 ffcd 	bl	3bfa0 <lsm6dso_fsm_start_address_set>
	lsm6dso_fsm_number_of_programs_set(&imu_dev_ctx, 2);
   24006:	2102      	movs	r1, #2
   24008:	4826      	ldr	r0, [pc, #152]	; (240a4 <sensor_init+0x198>)
   2400a:	f017 ffbd 	bl	3bf88 <lsm6dso_fsm_number_of_programs_set>
	lsm6dso_fsm_enable_get(&imu_dev_ctx, &fsm_enable);
   2400e:	4621      	mov	r1, r4
   24010:	4824      	ldr	r0, [pc, #144]	; (240a4 <sensor_init+0x198>)
   24012:	f017 fe67 	bl	3bce4 <lsm6dso_fsm_enable_get>
	fsm_enable.fsm_enable_a.fsm1_en = PROPERTY_ENABLE;
   24016:	7823      	ldrb	r3, [r4, #0]
	lsm6dso_fsm_enable_set(&imu_dev_ctx, &fsm_enable);
   24018:	4621      	mov	r1, r4
	fsm_enable.fsm_enable_a.fsm1_en = PROPERTY_ENABLE;
   2401a:	f023 0303 	bic.w	r3, r3, #3
   2401e:	f043 0303 	orr.w	r3, r3, #3
   24022:	7023      	strb	r3, [r4, #0]
	lsm6dso_fsm_enable_set(&imu_dev_ctx, &fsm_enable);
   24024:	481f      	ldr	r0, [pc, #124]	; (240a4 <sensor_init+0x198>)
   24026:	f017 fdfb 	bl	3bc20 <lsm6dso_fsm_enable_set>
	lsm6dso_fsm_data_rate_set(&imu_dev_ctx, LSM6DSO_ODR_FSM_26Hz);
   2402a:	2101      	movs	r1, #1
   2402c:	481d      	ldr	r0, [pc, #116]	; (240a4 <sensor_init+0x198>)
   2402e:	f017 fe6e 	bl	3bd0e <lsm6dso_fsm_data_rate_set>
	fsm_addr = LSM6DSO_START_FSM_ADD;
   24032:	f44f 6180 	mov.w	r1, #1024	; 0x400
   24036:	4c1e      	ldr	r4, [pc, #120]	; (240b0 <sensor_init+0x1a4>)
	lsm6dso_ln_pg_write(&imu_dev_ctx, fsm_addr, (uint8_t*)lsm6so_prg_wrist_tilt,
   24038:	2314      	movs	r3, #20
   2403a:	4a1e      	ldr	r2, [pc, #120]	; (240b4 <sensor_init+0x1a8>)
   2403c:	4819      	ldr	r0, [pc, #100]	; (240a4 <sensor_init+0x198>)
	fsm_addr = LSM6DSO_START_FSM_ADD;
   2403e:	8021      	strh	r1, [r4, #0]
	lsm6dso_ln_pg_write(&imu_dev_ctx, fsm_addr, (uint8_t*)lsm6so_prg_wrist_tilt,
   24040:	f016 fff8 	bl	3b034 <lsm6dso_ln_pg_write>
	fsm_addr += sizeof(lsm6so_prg_wrist_tilt);
   24044:	8821      	ldrh	r1, [r4, #0]
	lsm6dso_ln_pg_write(&imu_dev_ctx, fsm_addr, (uint8_t*)falltrigger,
   24046:	4a1c      	ldr	r2, [pc, #112]	; (240b8 <sensor_init+0x1ac>)
	fsm_addr += sizeof(lsm6so_prg_wrist_tilt);
   24048:	3114      	adds	r1, #20
   2404a:	b289      	uxth	r1, r1
   2404c:	8021      	strh	r1, [r4, #0]
	lsm6dso_pin_int2_route_get(&imu_dev_ctx, &int2_route);
   2404e:	4c1b      	ldr	r4, [pc, #108]	; (240bc <sensor_init+0x1b0>)
	lsm6dso_ln_pg_write(&imu_dev_ctx, fsm_addr, (uint8_t*)falltrigger,
   24050:	2318      	movs	r3, #24
   24052:	4814      	ldr	r0, [pc, #80]	; (240a4 <sensor_init+0x198>)
   24054:	f016 ffee 	bl	3b034 <lsm6dso_ln_pg_write>
	lsm6dso_pin_int2_route_get(&imu_dev_ctx, &int2_route);
   24058:	4621      	mov	r1, r4
   2405a:	4812      	ldr	r0, [pc, #72]	; (240a4 <sensor_init+0x198>)
   2405c:	f017 fa67 	bl	3b52e <lsm6dso_pin_int2_route_get>
	int2_route.md2_cfg.int2_single_tap = PROPERTY_ENABLE;
   24060:	7863      	ldrb	r3, [r4, #1]
	lsm6dso_pin_int2_route_set(&imu_dev_ctx, &int2_route);
   24062:	4621      	mov	r1, r4
	int2_route.md2_cfg.int2_single_tap = PROPERTY_ENABLE;
   24064:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   24068:	7063      	strb	r3, [r4, #1]
	lsm6dso_pin_int1_route_get(&imu_dev_ctx, &int1_route);
   2406a:	4c15      	ldr	r4, [pc, #84]	; (240c0 <sensor_init+0x1b4>)
	lsm6dso_pin_int2_route_set(&imu_dev_ctx, &int2_route);
   2406c:	480d      	ldr	r0, [pc, #52]	; (240a4 <sensor_init+0x198>)
   2406e:	f017 f974 	bl	3b35a <lsm6dso_pin_int2_route_set>
	lsm6dso_pin_int1_route_get(&imu_dev_ctx, &int1_route);
   24072:	4621      	mov	r1, r4
   24074:	480b      	ldr	r0, [pc, #44]	; (240a4 <sensor_init+0x198>)
   24076:	f017 f93f 	bl	3b2f8 <lsm6dso_pin_int1_route_get>
	int1_route.emb_func_int1.int1_step_detector = PROPERTY_ENABLE;
   2407a:	78a3      	ldrb	r3, [r4, #2]
	lsm6dso_pin_int1_route_set(&imu_dev_ctx, &int1_route);
   2407c:	4621      	mov	r1, r4
	int1_route.emb_func_int1.int1_step_detector = PROPERTY_ENABLE;
   2407e:	f043 0308 	orr.w	r3, r3, #8
   24082:	70a3      	strb	r3, [r4, #2]
	int1_route.fsm_int1_a.int1_fsm1 = PROPERTY_ENABLE;
   24084:	78e3      	ldrb	r3, [r4, #3]
	lsm6dso_pin_int1_route_set(&imu_dev_ctx, &int1_route);
   24086:	4807      	ldr	r0, [pc, #28]	; (240a4 <sensor_init+0x198>)
	int1_route.fsm_int1_a.int1_fsm1 = PROPERTY_ENABLE;
   24088:	f043 0301 	orr.w	r3, r3, #1
   2408c:	70e3      	strb	r3, [r4, #3]
	lsm6dso_pin_int1_route_set(&imu_dev_ctx, &int1_route);
   2408e:	f017 fa7f 	bl	3b590 <lsm6dso_pin_int1_route_set>
}
   24092:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	lsm6dso_timestamp_set(&imu_dev_ctx, 1);
   24096:	2101      	movs	r1, #1
   24098:	4802      	ldr	r0, [pc, #8]	; (240a4 <sensor_init+0x198>)
   2409a:	f016 beb4 	b.w	3ae06 <lsm6dso_timestamp_set>
   2409e:	bf00      	nop
   240a0:	2002c32b 	.word	0x2002c32b
   240a4:	20024634 	.word	0x20024634
   240a8:	2002c32a 	.word	0x2002c32a
   240ac:	2002c31a 	.word	0x2002c31a
   240b0:	200298fa 	.word	0x200298fa
   240b4:	0004160d 	.word	0x0004160d
   240b8:	000415f5 	.word	0x000415f5
   240bc:	2002c324 	.word	0x2002c324
   240c0:	2002c31e 	.word	0x2002c31e

000240c4 <sensor_reset>:
{  
   240c4:	b538      	push	{r3, r4, r5, lr}
	lsm6dso_reset_set(&imu_dev_ctx, PROPERTY_ENABLE);
   240c6:	2101      	movs	r1, #1
   240c8:	481e      	ldr	r0, [pc, #120]	; (24144 <sensor_reset+0x80>)
   240ca:	f017 f8c4 	bl	3b256 <lsm6dso_reset_set>
		lsm6dso_reset_get(&imu_dev_ctx, &rst);
   240ce:	4d1e      	ldr	r5, [pc, #120]	; (24148 <sensor_reset+0x84>)
   240d0:	491d      	ldr	r1, [pc, #116]	; (24148 <sensor_reset+0x84>)
   240d2:	481c      	ldr	r0, [pc, #112]	; (24144 <sensor_reset+0x80>)
   240d4:	f017 f8d6 	bl	3b284 <lsm6dso_reset_get>
	}while(rst);
   240d8:	782c      	ldrb	r4, [r5, #0]
   240da:	2c00      	cmp	r4, #0
   240dc:	d1f8      	bne.n	240d0 <sensor_reset+0xc>
	lsm6dso_i3c_disable_set(&imu_dev_ctx, LSM6DSO_I3C_DISABLE);
   240de:	2180      	movs	r1, #128	; 0x80
   240e0:	4818      	ldr	r0, [pc, #96]	; (24144 <sensor_reset+0x80>)
   240e2:	f017 f8dd 	bl	3b2a0 <lsm6dso_i3c_disable_set>
	lsm6dso_fifo_watermark_set(&imu_dev_ctx, ACC_GYRO_FIFO_BUF_LEN);
   240e6:	2164      	movs	r1, #100	; 0x64
   240e8:	4816      	ldr	r0, [pc, #88]	; (24144 <sensor_reset+0x80>)
   240ea:	f017 fc44 	bl	3b976 <lsm6dso_fifo_watermark_set>
	lsm6dso_fifo_stop_on_wtm_set(&imu_dev_ctx, PROPERTY_ENABLE);
   240ee:	2101      	movs	r1, #1
   240f0:	4814      	ldr	r0, [pc, #80]	; (24144 <sensor_reset+0x80>)
   240f2:	f017 fc61 	bl	3b9b8 <lsm6dso_fifo_stop_on_wtm_set>
	lsm6dso_fifo_mode_set(&imu_dev_ctx, LSM6DSO_STREAM_MODE);
   240f6:	2106      	movs	r1, #6
   240f8:	4812      	ldr	r0, [pc, #72]	; (24144 <sensor_reset+0x80>)
   240fa:	f017 fca2 	bl	3ba42 <lsm6dso_fifo_mode_set>
	lsm6dso_data_ready_mode_set(&imu_dev_ctx, LSM6DSO_DRDY_PULSED);
   240fe:	2101      	movs	r1, #1
   24100:	4810      	ldr	r0, [pc, #64]	; (24144 <sensor_reset+0x80>)
   24102:	f017 f88c 	bl	3b21e <lsm6dso_data_ready_mode_set>
	lsm6dso_fifo_xl_batch_set(&imu_dev_ctx, LSM6DSO_XL_BATCHED_AT_104Hz);
   24106:	2104      	movs	r1, #4
   24108:	480e      	ldr	r0, [pc, #56]	; (24144 <sensor_reset+0x80>)
   2410a:	f017 fc6c 	bl	3b9e6 <lsm6dso_fifo_xl_batch_set>
	lsm6dso_fifo_gy_batch_set(&imu_dev_ctx, LSM6DSO_GY_BATCHED_AT_104Hz);
   2410e:	2104      	movs	r1, #4
   24110:	480c      	ldr	r0, [pc, #48]	; (24144 <sensor_reset+0x80>)
   24112:	f017 fc7f 	bl	3ba14 <lsm6dso_fifo_gy_batch_set>
	lsm6dso_xl_full_scale_set(&imu_dev_ctx, LSM6DSO_2g);
   24116:	4621      	mov	r1, r4
   24118:	480a      	ldr	r0, [pc, #40]	; (24144 <sensor_reset+0x80>)
   2411a:	f016 fdf5 	bl	3ad08 <lsm6dso_xl_full_scale_set>
	lsm6dso_gy_full_scale_set(&imu_dev_ctx, LSM6DSO_250dps);
   2411e:	4621      	mov	r1, r4
   24120:	4808      	ldr	r0, [pc, #32]	; (24144 <sensor_reset+0x80>)
   24122:	f016 fe08 	bl	3ad36 <lsm6dso_gy_full_scale_set>
	lsm6dso_block_data_update_set(&imu_dev_ctx, PROPERTY_ENABLE);
   24126:	2101      	movs	r1, #1
   24128:	4806      	ldr	r0, [pc, #24]	; (24144 <sensor_reset+0x80>)
   2412a:	f016 fe1b 	bl	3ad64 <lsm6dso_block_data_update_set>
	lsm6dso_xl_data_rate_set(&imu_dev_ctx, LSM6DSO_XL_ODR_104Hz);
   2412e:	2104      	movs	r1, #4
   24130:	4804      	ldr	r0, [pc, #16]	; (24144 <sensor_reset+0x80>)
   24132:	f017 fe38 	bl	3bda6 <lsm6dso_xl_data_rate_set>
}
   24136:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	lsm6dso_gy_data_rate_set(&imu_dev_ctx, LSM6DSO_GY_ODR_104Hz);
   2413a:	2104      	movs	r1, #4
   2413c:	4801      	ldr	r0, [pc, #4]	; (24144 <sensor_reset+0x80>)
   2413e:	f017 be9f 	b.w	3be80 <lsm6dso_gy_data_rate_set>
   24142:	bf00      	nop
   24144:	20024634 	.word	0x20024634
   24148:	2002c32a 	.word	0x2002c32a

0002414c <get_sensor_reading>:
{
   2414c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   24150:	4680      	mov	r8, r0
   24152:	460f      	mov	r7, r1
	lsm6dso_xl_flag_data_ready_get(&imu_dev_ctx, &reg);
   24154:	4816      	ldr	r0, [pc, #88]	; (241b0 <get_sensor_reading+0x64>)
   24156:	f10d 0107 	add.w	r1, sp, #7
{
   2415a:	4616      	mov	r6, r2
	lsm6dso_xl_flag_data_ready_get(&imu_dev_ctx, &reg);
   2415c:	f016 fe45 	bl	3adea <lsm6dso_xl_flag_data_ready_get>
	if(reg)
   24160:	f89d 3007 	ldrb.w	r3, [sp, #7]
   24164:	4c13      	ldr	r4, [pc, #76]	; (241b4 <get_sensor_reading+0x68>)
   24166:	b1cb      	cbz	r3, 2419c <get_sensor_reading+0x50>
		memset(data_raw_acceleration.u8bit, 0x00, 3*sizeof(int16_t));
   24168:	2300      	movs	r3, #0
   2416a:	4d13      	ldr	r5, [pc, #76]	; (241b8 <get_sensor_reading+0x6c>)
		lsm6dso_acceleration_raw_get(&imu_dev_ctx, data_raw_acceleration.u8bit);
   2416c:	4810      	ldr	r0, [pc, #64]	; (241b0 <get_sensor_reading+0x64>)
   2416e:	4629      	mov	r1, r5
		memset(data_raw_acceleration.u8bit, 0x00, 3*sizeof(int16_t));
   24170:	602b      	str	r3, [r5, #0]
   24172:	80ab      	strh	r3, [r5, #4]
		lsm6dso_acceleration_raw_get(&imu_dev_ctx, data_raw_acceleration.u8bit);
   24174:	f016 fe5e 	bl	3ae34 <lsm6dso_acceleration_raw_get>
		acceleration_mg[0] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[0]);
   24178:	f9b5 0000 	ldrsh.w	r0, [r5]
   2417c:	f000 fbfa 	bl	24974 <lsm6dso_from_fs2_to_mg>
		acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   24180:	f9b5 0002 	ldrsh.w	r0, [r5, #2]
		acceleration_mg[0] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[0]);
   24184:	ed84 0a00 	vstr	s0, [r4]
		acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   24188:	f000 fbf4 	bl	24974 <lsm6dso_from_fs2_to_mg>
		acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   2418c:	f9b5 0004 	ldrsh.w	r0, [r5, #4]
		acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   24190:	ed84 0a01 	vstr	s0, [r4, #4]
		acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   24194:	f000 fbee 	bl	24974 <lsm6dso_from_fs2_to_mg>
   24198:	ed84 0a02 	vstr	s0, [r4, #8]
	*sensor_x = acceleration_mg[0];
   2419c:	6823      	ldr	r3, [r4, #0]
   2419e:	f8c8 3000 	str.w	r3, [r8]
	*sensor_y = acceleration_mg[1];
   241a2:	6863      	ldr	r3, [r4, #4]
   241a4:	603b      	str	r3, [r7, #0]
	*sensor_z = acceleration_mg[2];
   241a6:	68a3      	ldr	r3, [r4, #8]
   241a8:	6033      	str	r3, [r6, #0]
}
   241aa:	b002      	add	sp, #8
   241ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   241b0:	20024634 	.word	0x20024634
   241b4:	200229d0 	.word	0x200229d0
   241b8:	200298ee 	.word	0x200298ee

000241bc <historic_buffer>:
{
   241bc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
	uint16_t i = 0;
   241c0:	2500      	movs	r5, #0
	uint16_t histBuff_counter = 0;
   241c2:	462c      	mov	r4, r5
		lsm6dso_fifo_wtm_flag_get(&imu_dev_ctx, &waterm);
   241c4:	4e53      	ldr	r6, [pc, #332]	; (24314 <historic_buffer+0x158>)
					memset(data_raw_angular_rate.u8bit, 0x00, 3*sizeof(int16_t));
   241c6:	4f54      	ldr	r7, [pc, #336]	; (24318 <historic_buffer+0x15c>)
		uint16_t num = 0;
   241c8:	2300      	movs	r3, #0
		lsm6dso_fifo_wtm_flag_get(&imu_dev_ctx, &waterm);
   241ca:	a901      	add	r1, sp, #4
   241cc:	4630      	mov	r0, r6
		uint16_t num = 0;
   241ce:	f8ad 3006 	strh.w	r3, [sp, #6]
		uint8_t waterm = 0;
   241d2:	f88d 3004 	strb.w	r3, [sp, #4]
		lsm6dso_fifo_wtm_flag_get(&imu_dev_ctx, &waterm);
   241d6:	f017 fc65 	bl	3baa4 <lsm6dso_fifo_wtm_flag_get>
		if(waterm>0)
   241da:	f89d 3004 	ldrb.w	r3, [sp, #4]
   241de:	b18b      	cbz	r3, 24204 <historic_buffer+0x48>
			lsm6dso_fifo_data_level_get(&imu_dev_ctx, &num);
   241e0:	f10d 0106 	add.w	r1, sp, #6
   241e4:	4630      	mov	r0, r6
   241e6:	f017 fc43 	bl	3ba70 <lsm6dso_fifo_data_level_get>
					angular_rate_mdps[0] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[0]);
   241ea:	f8df 9150 	ldr.w	r9, [pc, #336]	; 2433c <historic_buffer+0x180>
			while(num--)
   241ee:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   241f2:	1e5a      	subs	r2, r3, #1
   241f4:	f8ad 2006 	strh.w	r2, [sp, #6]
   241f8:	b93b      	cbnz	r3, 2420a <historic_buffer+0x4e>
			if(histBuff_counter == PATTERN_LEN)
   241fa:	2cc8      	cmp	r4, #200	; 0xc8
   241fc:	d1e4      	bne.n	241c8 <historic_buffer+0xc>
				hist_buff_flag = true;
   241fe:	2201      	movs	r2, #1
   24200:	4b46      	ldr	r3, [pc, #280]	; (2431c <historic_buffer+0x160>)
   24202:	701a      	strb	r2, [r3, #0]
}
   24204:	b004      	add	sp, #16
   24206:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				lsm6dso_fifo_sensor_tag_get(&imu_dev_ctx, &reg_tag);
   2420a:	f10d 0105 	add.w	r1, sp, #5
   2420e:	4630      	mov	r0, r6
   24210:	f017 fc56 	bl	3bac0 <lsm6dso_fifo_sensor_tag_get>
				switch (reg_tag)
   24214:	f89d 2005 	ldrb.w	r2, [sp, #5]
   24218:	2300      	movs	r3, #0
   2421a:	2a01      	cmp	r2, #1
   2421c:	d03b      	beq.n	24296 <historic_buffer+0xda>
   2421e:	2a02      	cmp	r2, #2
   24220:	d16f      	bne.n	24302 <historic_buffer+0x146>
					memset(data_raw_acceleration.u8bit, 0x00, 3*sizeof(int16_t));
   24222:	f8df 811c 	ldr.w	r8, [pc, #284]	; 24340 <historic_buffer+0x184>
					lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_acceleration.u8bit);
   24226:	4630      	mov	r0, r6
   24228:	4641      	mov	r1, r8
					memset(data_raw_acceleration.u8bit, 0x00, 3*sizeof(int16_t));
   2422a:	f8c8 3000 	str.w	r3, [r8]
   2422e:	f8a8 3004 	strh.w	r3, [r8, #4]
					lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_acceleration.u8bit);
   24232:	f016 fe04 	bl	3ae3e <lsm6dso_fifo_out_raw_get>
					acceleration_mg[0] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[0]);
   24236:	f9b8 0000 	ldrsh.w	r0, [r8]
   2423a:	f000 fb9b 	bl	24974 <lsm6dso_from_fs2_to_mg>
   2423e:	f8df a104 	ldr.w	sl, [pc, #260]	; 24344 <historic_buffer+0x188>
					acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   24242:	f9b8 0002 	ldrsh.w	r0, [r8, #2]
					acceleration_mg[0] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[0]);
   24246:	ed8a 0a00 	vstr	s0, [sl]
					acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   2424a:	f000 fb93 	bl	24974 <lsm6dso_from_fs2_to_mg>
					acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   2424e:	f9b8 0004 	ldrsh.w	r0, [r8, #4]
					acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   24252:	ed8a 0a01 	vstr	s0, [sl, #4]
					acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   24256:	f000 fb8d 	bl	24974 <lsm6dso_from_fs2_to_mg>
					acceleration_g[1]   = acceleration_mg[1]/1000;
   2425a:	eddf 7a31 	vldr	s15, [pc, #196]	; 24320 <historic_buffer+0x164>
   2425e:	edda 6a01 	vldr	s13, [sl, #4]
					acceleration_g[0]   = acceleration_mg[0]/1000;
   24262:	ed9a 6a00 	vldr	s12, [sl]
					acceleration_g[1]   = acceleration_mg[1]/1000;
   24266:	ee86 7aa7 	vdiv.f32	s14, s13, s15
					acceleration_g[0]   = acceleration_mg[0]/1000;
   2426a:	eec6 6a27 	vdiv.f32	s13, s12, s15
					acc_x_hist_buffer[i] = acceleration_g[0]; //[i]
   2426e:	4b2d      	ldr	r3, [pc, #180]	; (24324 <historic_buffer+0x168>)
   24270:	00aa      	lsls	r2, r5, #2
   24272:	4413      	add	r3, r2
   24274:	edc3 6a00 	vstr	s13, [r3]
					acc_y_hist_buffer[i] = acceleration_g[1];
   24278:	4b2b      	ldr	r3, [pc, #172]	; (24328 <historic_buffer+0x16c>)
					histBuff_counter++;
   2427a:	3401      	adds	r4, #1
					acc_y_hist_buffer[i] = acceleration_g[1];
   2427c:	4413      	add	r3, r2
   2427e:	ed83 7a00 	vstr	s14, [r3]
					acceleration_g[2]   = acceleration_mg[2]/1000;
   24282:	ee80 7a27 	vdiv.f32	s14, s0, s15
					acc_z_hist_buffer[i] = acceleration_g[2];   
   24286:	4b29      	ldr	r3, [pc, #164]	; (2432c <historic_buffer+0x170>)
					acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   24288:	ed8a 0a02 	vstr	s0, [sl, #8]
					acc_z_hist_buffer[i] = acceleration_g[2];   
   2428c:	4413      	add	r3, r2
   2428e:	ed83 7a00 	vstr	s14, [r3]
					histBuff_counter++;
   24292:	b2a4      	uxth	r4, r4
					break;
   24294:	e7ab      	b.n	241ee <historic_buffer+0x32>
					lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_angular_rate.u8bit);
   24296:	4639      	mov	r1, r7
   24298:	4630      	mov	r0, r6
					memset(data_raw_angular_rate.u8bit, 0x00, 3*sizeof(int16_t));
   2429a:	603b      	str	r3, [r7, #0]
   2429c:	80bb      	strh	r3, [r7, #4]
					lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_angular_rate.u8bit);
   2429e:	f016 fdce 	bl	3ae3e <lsm6dso_fifo_out_raw_get>
					angular_rate_mdps[0] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[0]);
   242a2:	f9b7 0000 	ldrsh.w	r0, [r7]
   242a6:	f000 fb71 	bl	2498c <lsm6dso_from_fs250_to_mdps>
					angular_rate_mdps[1] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[1]);
   242aa:	f9b7 0002 	ldrsh.w	r0, [r7, #2]
					angular_rate_mdps[0] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[0]);
   242ae:	ed89 0a00 	vstr	s0, [r9]
					angular_rate_mdps[1] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[1]);
   242b2:	f000 fb6b 	bl	2498c <lsm6dso_from_fs250_to_mdps>
					angular_rate_mdps[2] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[2]);
   242b6:	f9b7 0004 	ldrsh.w	r0, [r7, #4]
					angular_rate_mdps[1] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[1]);
   242ba:	ed89 0a01 	vstr	s0, [r9, #4]
					angular_rate_mdps[2] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[2]);
   242be:	f000 fb65 	bl	2498c <lsm6dso_from_fs250_to_mdps>
					angular_rate_dps[1] = angular_rate_mdps[1]/1000;
   242c2:	eddf 7a17 	vldr	s15, [pc, #92]	; 24320 <historic_buffer+0x164>
   242c6:	edd9 6a01 	vldr	s13, [r9, #4]
					angular_rate_dps[0] = angular_rate_mdps[0]/1000;
   242ca:	ed99 6a00 	vldr	s12, [r9]
					angular_rate_dps[1] = angular_rate_mdps[1]/1000;
   242ce:	ee86 7aa7 	vdiv.f32	s14, s13, s15
					angular_rate_dps[0] = angular_rate_mdps[0]/1000;
   242d2:	eec6 6a27 	vdiv.f32	s13, s12, s15
					gyro_x_hist_buffer[i] = angular_rate_dps[0];
   242d6:	4b16      	ldr	r3, [pc, #88]	; (24330 <historic_buffer+0x174>)
   242d8:	00aa      	lsls	r2, r5, #2
   242da:	4413      	add	r3, r2
   242dc:	edc3 6a00 	vstr	s13, [r3]
					gyro_y_hist_buffer[i] = angular_rate_dps[1];
   242e0:	4b14      	ldr	r3, [pc, #80]	; (24334 <historic_buffer+0x178>)
					histBuff_counter++;
   242e2:	3401      	adds	r4, #1
					gyro_y_hist_buffer[i] = angular_rate_dps[1];
   242e4:	4413      	add	r3, r2
   242e6:	ed83 7a00 	vstr	s14, [r3]
					angular_rate_dps[2] = angular_rate_mdps[2]/1000;
   242ea:	ee80 7a27 	vdiv.f32	s14, s0, s15
					gyro_z_hist_buffer[i] = angular_rate_dps[2];
   242ee:	4b12      	ldr	r3, [pc, #72]	; (24338 <historic_buffer+0x17c>)
					i++;
   242f0:	3501      	adds	r5, #1
					gyro_z_hist_buffer[i] = angular_rate_dps[2];
   242f2:	4413      	add	r3, r2
					angular_rate_mdps[2] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[2]);
   242f4:	ed89 0a02 	vstr	s0, [r9, #8]
					gyro_z_hist_buffer[i] = angular_rate_dps[2];
   242f8:	ed83 7a00 	vstr	s14, [r3]
					histBuff_counter++;
   242fc:	b2a4      	uxth	r4, r4
					i++;
   242fe:	b2ad      	uxth	r5, r5
					break;
   24300:	e775      	b.n	241ee <historic_buffer+0x32>
					lsm6dso_fifo_out_raw_get(&imu_dev_ctx, dummy.u8bit);
   24302:	a902      	add	r1, sp, #8
   24304:	4630      	mov	r0, r6
					memset(dummy.u8bit, 0x00, 3 * sizeof(int16_t));
   24306:	9302      	str	r3, [sp, #8]
   24308:	f8ad 300c 	strh.w	r3, [sp, #12]
					lsm6dso_fifo_out_raw_get(&imu_dev_ctx, dummy.u8bit);
   2430c:	f016 fd97 	bl	3ae3e <lsm6dso_fifo_out_raw_get>
					break;
   24310:	e76d      	b.n	241ee <historic_buffer+0x32>
   24312:	bf00      	nop
   24314:	20024634 	.word	0x20024634
   24318:	200298f4 	.word	0x200298f4
   2431c:	2002c31c 	.word	0x2002c31c
   24320:	447a0000 	.word	0x447a0000
   24324:	20020f40 	.word	0x20020f40
   24328:	20021710 	.word	0x20021710
   2432c:	20021ee0 	.word	0x20021ee0
   24330:	20023050 	.word	0x20023050
   24334:	20023820 	.word	0x20023820
   24338:	20023ff0 	.word	0x20023ff0
   2433c:	200229dc 	.word	0x200229dc
   24340:	200298ee 	.word	0x200298ee
   24344:	200229d0 	.word	0x200229d0

00024348 <curr_vrif_buffers>:
{
   24348:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2434c:	ed2d 8b02 	vpush	{d8}
   24350:	b089      	sub	sp, #36	; 0x24
	sensor_reset();
   24352:	f7ff feb7 	bl	240c4 <sensor_reset>
	uint16_t buff_counter = 0;
   24356:	2500      	movs	r5, #0
		uint16_t num = 0;
   24358:	2300      	movs	r3, #0
		lsm6dso_fifo_wtm_flag_get(&imu_dev_ctx, &waterm);
   2435a:	f10d 011d 	add.w	r1, sp, #29
   2435e:	48b6      	ldr	r0, [pc, #728]	; (24638 <curr_vrif_buffers+0x2f0>)
		uint16_t num = 0;
   24360:	f8ad 301e 	strh.w	r3, [sp, #30]
		uint8_t waterm = 0;
   24364:	f88d 301d 	strb.w	r3, [sp, #29]
		lsm6dso_fifo_wtm_flag_get(&imu_dev_ctx, &waterm);
   24368:	f017 fb9c 	bl	3baa4 <lsm6dso_fifo_wtm_flag_get>
		if(waterm>0)
   2436c:	f89d 301d 	ldrb.w	r3, [sp, #29]
   24370:	2b00      	cmp	r3, #0
   24372:	d0f1      	beq.n	24358 <curr_vrif_buffers+0x10>
			lsm6dso_fifo_data_level_get(&imu_dev_ctx, &num);
   24374:	f10d 011e 	add.w	r1, sp, #30
   24378:	48af      	ldr	r0, [pc, #700]	; (24638 <curr_vrif_buffers+0x2f0>)
   2437a:	f017 fb79 	bl	3ba70 <lsm6dso_fifo_data_level_get>
		uint8_t k_rev = ACC_GYRO_FIFO_BUF_LEN-1;
   2437e:	2363      	movs	r3, #99	; 0x63
		uint8_t j_rev = ACC_GYRO_FIFO_BUF_LEN-1;
   24380:	e9cd 3301 	strd	r3, r3, [sp, #4]
		uint8_t i_rev = ACC_GYRO_FIFO_BUF_LEN-1;
   24384:	9303      	str	r3, [sp, #12]
			while(num--)
   24386:	f8bd 301e 	ldrh.w	r3, [sp, #30]
   2438a:	1e5a      	subs	r2, r3, #1
   2438c:	f8ad 201e 	strh.w	r2, [sp, #30]
   24390:	b953      	cbnz	r3, 243a8 <curr_vrif_buffers+0x60>
			if(buff_counter == 6*ACC_GYRO_FIFO_BUF_LEN)
   24392:	f5b5 7f16 	cmp.w	r5, #600	; 0x258
   24396:	d1df      	bne.n	24358 <curr_vrif_buffers+0x10>
				curr_vrif_buff_flag = true;
   24398:	2201      	movs	r2, #1
   2439a:	4ba8      	ldr	r3, [pc, #672]	; (2463c <curr_vrif_buffers+0x2f4>)
   2439c:	701a      	strb	r2, [r3, #0]
}
   2439e:	b009      	add	sp, #36	; 0x24
   243a0:	ecbd 8b02 	vpop	{d8}
   243a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				memset(data_raw_angular_rate.u8bit, 0x00, 3*sizeof(int16_t));
   243a8:	f04f 0800 	mov.w	r8, #0
   243ac:	4fa4      	ldr	r7, [pc, #656]	; (24640 <curr_vrif_buffers+0x2f8>)
				lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_angular_rate.u8bit);
   243ae:	48a2      	ldr	r0, [pc, #648]	; (24638 <curr_vrif_buffers+0x2f0>)
   243b0:	4639      	mov	r1, r7
				memset(data_raw_angular_rate.u8bit, 0x00, 3*sizeof(int16_t));
   243b2:	f8c7 8000 	str.w	r8, [r7]
   243b6:	f8a7 8004 	strh.w	r8, [r7, #4]
				lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_angular_rate.u8bit);
   243ba:	f016 fd40 	bl	3ae3e <lsm6dso_fifo_out_raw_get>
				angular_rate_mdps[0] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[0]);
   243be:	f9b7 0000 	ldrsh.w	r0, [r7]
   243c2:	f000 fae3 	bl	2498c <lsm6dso_from_fs250_to_mdps>
   243c6:	4e9f      	ldr	r6, [pc, #636]	; (24644 <curr_vrif_buffers+0x2fc>)
				angular_rate_mdps[1] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[1]);
   243c8:	f9b7 0002 	ldrsh.w	r0, [r7, #2]
				angular_rate_mdps[0] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[0]);
   243cc:	ed86 0a00 	vstr	s0, [r6]
				angular_rate_mdps[1] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[1]);
   243d0:	f000 fadc 	bl	2498c <lsm6dso_from_fs250_to_mdps>
				angular_rate_mdps[2] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[2]);
   243d4:	f9b7 0004 	ldrsh.w	r0, [r7, #4]
				angular_rate_dps[1]  = angular_rate_mdps[1]/1000;
   243d8:	ed9f 8a9b 	vldr	s16, [pc, #620]	; 24648 <curr_vrif_buffers+0x300>
				angular_rate_mdps[1] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[1]);
   243dc:	ed86 0a01 	vstr	s0, [r6, #4]
				angular_rate_mdps[2] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[2]);
   243e0:	f000 fad4 	bl	2498c <lsm6dso_from_fs250_to_mdps>
				angular_rate_dps[0]  = angular_rate_mdps[0]/1000;
   243e4:	edd6 6a00 	vldr	s13, [r6]
				angular_rate_dps[1]  = angular_rate_mdps[1]/1000;
   243e8:	ed96 7a01 	vldr	s14, [r6, #4]
   243ec:	eec7 7a08 	vdiv.f32	s15, s14, s16
				angular_rate_dps[0]  = angular_rate_mdps[0]/1000;
   243f0:	ee86 7a88 	vdiv.f32	s14, s13, s16
				gyro_tempX[num]      = angular_rate_dps[0];
   243f4:	f8bd 301e 	ldrh.w	r3, [sp, #30]
   243f8:	4a94      	ldr	r2, [pc, #592]	; (2464c <curr_vrif_buffers+0x304>)
   243fa:	009b      	lsls	r3, r3, #2
				gyro_tempY[num]      = angular_rate_dps[1];
   243fc:	4f94      	ldr	r7, [pc, #592]	; (24650 <curr_vrif_buffers+0x308>)
				gyro_tempX[num]      = angular_rate_dps[0];
   243fe:	441a      	add	r2, r3
   24400:	ed82 7a00 	vstr	s14, [r2]
				gyro_tempY[num]      = angular_rate_dps[1];
   24404:	18fa      	adds	r2, r7, r3
   24406:	edc2 7a00 	vstr	s15, [r2]
				angular_rate_dps[2]  = angular_rate_mdps[2]/1000;
   2440a:	eec0 7a08 	vdiv.f32	s15, s0, s16
				memset(data_raw_acceleration.u8bit, 0x00, 3*sizeof(int16_t));
   2440e:	f8df 927c 	ldr.w	r9, [pc, #636]	; 2468c <curr_vrif_buffers+0x344>
				angular_rate_mdps[2] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[2]);
   24412:	ed86 0a02 	vstr	s0, [r6, #8]
				gyro_tempZ[num]      = angular_rate_dps[2];
   24416:	4e8f      	ldr	r6, [pc, #572]	; (24654 <curr_vrif_buffers+0x30c>)
				lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_acceleration.u8bit);
   24418:	4649      	mov	r1, r9
				gyro_tempZ[num]      = angular_rate_dps[2];
   2441a:	4433      	add	r3, r6
				memset(data_raw_acceleration.u8bit, 0x00, 3*sizeof(int16_t));
   2441c:	f8c9 8000 	str.w	r8, [r9]
   24420:	f8a9 8004 	strh.w	r8, [r9, #4]
				lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_acceleration.u8bit);
   24424:	4884      	ldr	r0, [pc, #528]	; (24638 <curr_vrif_buffers+0x2f0>)
				gyro_tempZ[num]      = angular_rate_dps[2];
   24426:	edc3 7a00 	vstr	s15, [r3]
				lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_acceleration.u8bit);
   2442a:	f016 fd08 	bl	3ae3e <lsm6dso_fifo_out_raw_get>
				acceleration_mg[0] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[0]);
   2442e:	f9b9 0000 	ldrsh.w	r0, [r9]
   24432:	f000 fa9f 	bl	24974 <lsm6dso_from_fs2_to_mg>
   24436:	f8df 8258 	ldr.w	r8, [pc, #600]	; 24690 <curr_vrif_buffers+0x348>
				acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   2443a:	f9b9 0002 	ldrsh.w	r0, [r9, #2]
				acceleration_mg[0] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[0]);
   2443e:	ed88 0a00 	vstr	s0, [r8]
				acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   24442:	f000 fa97 	bl	24974 <lsm6dso_from_fs2_to_mg>
				acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   24446:	f9b9 0004 	ldrsh.w	r0, [r9, #4]
				acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   2444a:	ed88 0a01 	vstr	s0, [r8, #4]
				acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   2444e:	f000 fa91 	bl	24974 <lsm6dso_from_fs2_to_mg>
				acceleration_g[1]  = acceleration_mg[1]/1000;
   24452:	ed98 7a01 	vldr	s14, [r8, #4]
				acceleration_g[0]  = acceleration_mg[0]/1000;
   24456:	edd8 6a00 	vldr	s13, [r8]
				acceleration_g[1]  = acceleration_mg[1]/1000;
   2445a:	eec7 7a08 	vdiv.f32	s15, s14, s16
				acceleration_g[0]  = acceleration_mg[0]/1000;
   2445e:	ee86 7a88 	vdiv.f32	s14, s13, s16
				accel_tempX[num]   = acceleration_g[0];
   24462:	f8bd 301e 	ldrh.w	r3, [sp, #30]
   24466:	487c      	ldr	r0, [pc, #496]	; (24658 <curr_vrif_buffers+0x310>)
   24468:	009b      	lsls	r3, r3, #2
				accel_tempY[num]   = acceleration_g[1];
   2446a:	497c      	ldr	r1, [pc, #496]	; (2465c <curr_vrif_buffers+0x314>)
				accel_tempX[num]   = acceleration_g[0];
   2446c:	18c2      	adds	r2, r0, r3
   2446e:	ed82 7a00 	vstr	s14, [r2]
				accel_tempY[num]   = acceleration_g[1];
   24472:	18ca      	adds	r2, r1, r3
   24474:	edc2 7a00 	vstr	s15, [r2]
				acceleration_g[2]  = acceleration_mg[2]/1000;
   24478:	eec0 7a08 	vdiv.f32	s15, s0, s16
				accel_tempZ[num]   = acceleration_g[2];
   2447c:	4a78      	ldr	r2, [pc, #480]	; (24660 <curr_vrif_buffers+0x318>)
				if(buff_counter >= ACC_GYRO_FIFO_BUF_LEN && buff_counter < 2*ACC_GYRO_FIFO_BUF_LEN)
   2447e:	f1a5 0c63 	sub.w	ip, r5, #99	; 0x63
				accel_tempZ[num]   = acceleration_g[2];
   24482:	4413      	add	r3, r2
				if(buff_counter >= ACC_GYRO_FIFO_BUF_LEN && buff_counter < 2*ACC_GYRO_FIFO_BUF_LEN)
   24484:	fa1f fc8c 	uxth.w	ip, ip
				accel_tempZ[num]   = acceleration_g[2];
   24488:	edc3 7a00 	vstr	s15, [r3]
				if(buff_counter >= ACC_GYRO_FIFO_BUF_LEN && buff_counter < 2*ACC_GYRO_FIFO_BUF_LEN)
   2448c:	f1bc 0f63 	cmp.w	ip, #99	; 0x63
				buff_counter++;
   24490:	f105 0301 	add.w	r3, r5, #1
				acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   24494:	ed88 0a02 	vstr	s0, [r8, #8]
				buff_counter++;
   24498:	b29b      	uxth	r3, r3
				if(buff_counter >= ACC_GYRO_FIFO_BUF_LEN && buff_counter < 2*ACC_GYRO_FIFO_BUF_LEN)
   2449a:	d841      	bhi.n	24520 <curr_vrif_buffers+0x1d8>
   2449c:	4b71      	ldr	r3, [pc, #452]	; (24664 <curr_vrif_buffers+0x31c>)
   2449e:	9c03      	ldr	r4, [sp, #12]
   244a0:	9304      	str	r3, [sp, #16]
   244a2:	f1a4 0a64 	sub.w	sl, r4, #100	; 0x64
   244a6:	4b70      	ldr	r3, [pc, #448]	; (24668 <curr_vrif_buffers+0x320>)
   244a8:	f8df b1e8 	ldr.w	fp, [pc, #488]	; 24694 <curr_vrif_buffers+0x34c>
   244ac:	f8df 91e8 	ldr.w	r9, [pc, #488]	; 24698 <curr_vrif_buffers+0x350>
   244b0:	f8df e1e8 	ldr.w	lr, [pc, #488]	; 2469c <curr_vrif_buffers+0x354>
   244b4:	f8df c1e8 	ldr.w	ip, [pc, #488]	; 246a0 <curr_vrif_buffers+0x358>
   244b8:	fa5f fa8a 	uxtb.w	sl, sl
						acc_z_cur_buffer[i]  = accel_tempZ[i_rev];
   244bc:	9205      	str	r2, [sp, #20]
						acc_x_cur_buffer[i]  = accel_tempX[i_rev];
   244be:	9a03      	ldr	r2, [sp, #12]
   244c0:	9c04      	ldr	r4, [sp, #16]
   244c2:	0092      	lsls	r2, r2, #2
   244c4:	eb00 0802 	add.w	r8, r0, r2
   244c8:	f8d8 8000 	ldr.w	r8, [r8]
   244cc:	f844 8b04 	str.w	r8, [r4], #4
						acc_y_cur_buffer[i]  = accel_tempY[i_rev];
   244d0:	eb01 0802 	add.w	r8, r1, r2
   244d4:	f8d8 8000 	ldr.w	r8, [r8]
						acc_x_cur_buffer[i]  = accel_tempX[i_rev];
   244d8:	9404      	str	r4, [sp, #16]
						acc_z_cur_buffer[i]  = accel_tempZ[i_rev];
   244da:	9c05      	ldr	r4, [sp, #20]
						acc_y_cur_buffer[i]  = accel_tempY[i_rev];
   244dc:	f843 8b04 	str.w	r8, [r3], #4
						acc_z_cur_buffer[i]  = accel_tempZ[i_rev];
   244e0:	eb04 0802 	add.w	r8, r4, r2
   244e4:	f8d8 8000 	ldr.w	r8, [r8]
						gyro_x_cur_buffer[i] = gyro_tempX[i_rev];
   244e8:	4c58      	ldr	r4, [pc, #352]	; (2464c <curr_vrif_buffers+0x304>)
						acc_z_cur_buffer[i]  = accel_tempZ[i_rev];
   244ea:	f84b 8b04 	str.w	r8, [fp], #4
						gyro_x_cur_buffer[i] = gyro_tempX[i_rev];
   244ee:	eb04 0802 	add.w	r8, r4, r2
   244f2:	f8d8 8000 	ldr.w	r8, [r8]
   244f6:	f849 8b04 	str.w	r8, [r9], #4
						gyro_y_cur_buffer[i] = gyro_tempY[i_rev];
   244fa:	eb07 0802 	add.w	r8, r7, r2
						gyro_z_cur_buffer[i] = gyro_tempZ[i_rev];
   244fe:	4432      	add	r2, r6
   24500:	6812      	ldr	r2, [r2, #0]
						gyro_y_cur_buffer[i] = gyro_tempY[i_rev];
   24502:	f8d8 8000 	ldr.w	r8, [r8]
						gyro_z_cur_buffer[i] = gyro_tempZ[i_rev];
   24506:	f84c 2b04 	str.w	r2, [ip], #4
						i_rev--;
   2450a:	9a03      	ldr	r2, [sp, #12]
						gyro_y_cur_buffer[i] = gyro_tempY[i_rev];
   2450c:	f84e 8b04 	str.w	r8, [lr], #4
						i_rev--;
   24510:	3a01      	subs	r2, #1
   24512:	b2d2      	uxtb	r2, r2
					for (uint8_t i = 0; i < ACC_GYRO_FIFO_BUF_LEN; i++)
   24514:	4552      	cmp	r2, sl
						i_rev--;
   24516:	9203      	str	r2, [sp, #12]
					for (uint8_t i = 0; i < ACC_GYRO_FIFO_BUF_LEN; i++)
   24518:	d1d1      	bne.n	244be <curr_vrif_buffers+0x176>
   2451a:	f105 0365 	add.w	r3, r5, #101	; 0x65
   2451e:	b29b      	uxth	r3, r3
				if(buff_counter >= 3*ACC_GYRO_FIFO_BUF_LEN && buff_counter < 4*ACC_GYRO_FIFO_BUF_LEN)
   24520:	f5a3 7296 	sub.w	r2, r3, #300	; 0x12c
   24524:	2a63      	cmp	r2, #99	; 0x63
   24526:	d842      	bhi.n	245ae <curr_vrif_buffers+0x266>
   24528:	9a02      	ldr	r2, [sp, #8]
   2452a:	f8df 8178 	ldr.w	r8, [pc, #376]	; 246a4 <curr_vrif_buffers+0x35c>
   2452e:	f1a2 0164 	sub.w	r1, r2, #100	; 0x64
   24532:	f8df c174 	ldr.w	ip, [pc, #372]	; 246a8 <curr_vrif_buffers+0x360>
   24536:	4f4d      	ldr	r7, [pc, #308]	; (2466c <curr_vrif_buffers+0x324>)
   24538:	4e4d      	ldr	r6, [pc, #308]	; (24670 <curr_vrif_buffers+0x328>)
   2453a:	4d4e      	ldr	r5, [pc, #312]	; (24674 <curr_vrif_buffers+0x32c>)
   2453c:	484e      	ldr	r0, [pc, #312]	; (24678 <curr_vrif_buffers+0x330>)
						acc_x_vrif_buffer[j]  = accel_tempX[j_rev];
   2453e:	f8df b118 	ldr.w	fp, [pc, #280]	; 24658 <curr_vrif_buffers+0x310>
						acc_y_vrif_buffer[j]  = accel_tempY[j_rev];
   24542:	f8df a118 	ldr.w	sl, [pc, #280]	; 2465c <curr_vrif_buffers+0x314>
						acc_z_vrif_buffer[j]  = accel_tempZ[j_rev];
   24546:	f8df 9118 	ldr.w	r9, [pc, #280]	; 24660 <curr_vrif_buffers+0x318>
   2454a:	b2c9      	uxtb	r1, r1
						acc_x_vrif_buffer[j]  = accel_tempX[j_rev];
   2454c:	9a02      	ldr	r2, [sp, #8]
						gyro_x_vrif_buffer[j] = gyro_tempX[j_rev];
   2454e:	4c3f      	ldr	r4, [pc, #252]	; (2464c <curr_vrif_buffers+0x304>)
						acc_x_vrif_buffer[j]  = accel_tempX[j_rev];
   24550:	0092      	lsls	r2, r2, #2
   24552:	eb0b 0e02 	add.w	lr, fp, r2
   24556:	f8de e000 	ldr.w	lr, [lr]
   2455a:	f848 eb04 	str.w	lr, [r8], #4
						acc_y_vrif_buffer[j]  = accel_tempY[j_rev];
   2455e:	eb0a 0e02 	add.w	lr, sl, r2
   24562:	f8de e000 	ldr.w	lr, [lr]
   24566:	f84c eb04 	str.w	lr, [ip], #4
						acc_z_vrif_buffer[j]  = accel_tempZ[j_rev];
   2456a:	eb09 0e02 	add.w	lr, r9, r2
   2456e:	f8de e000 	ldr.w	lr, [lr]
   24572:	f847 eb04 	str.w	lr, [r7], #4
						gyro_x_vrif_buffer[j] = gyro_tempX[j_rev];
   24576:	eb04 0e02 	add.w	lr, r4, r2
   2457a:	f8de e000 	ldr.w	lr, [lr]
						gyro_y_vrif_buffer[j] = gyro_tempY[j_rev];
   2457e:	4c34      	ldr	r4, [pc, #208]	; (24650 <curr_vrif_buffers+0x308>)
						gyro_x_vrif_buffer[j] = gyro_tempX[j_rev];
   24580:	f846 eb04 	str.w	lr, [r6], #4
						gyro_y_vrif_buffer[j] = gyro_tempY[j_rev];
   24584:	eb04 0e02 	add.w	lr, r4, r2
						gyro_z_vrif_buffer[j] = gyro_tempZ[j_rev];
   24588:	4c32      	ldr	r4, [pc, #200]	; (24654 <curr_vrif_buffers+0x30c>)
						gyro_y_vrif_buffer[j] = gyro_tempY[j_rev];
   2458a:	f8de e000 	ldr.w	lr, [lr]
						gyro_z_vrif_buffer[j] = gyro_tempZ[j_rev];
   2458e:	4422      	add	r2, r4
   24590:	6812      	ldr	r2, [r2, #0]
						gyro_y_vrif_buffer[j] = gyro_tempY[j_rev];
   24592:	f845 eb04 	str.w	lr, [r5], #4
						gyro_z_vrif_buffer[j] = gyro_tempZ[j_rev];
   24596:	f840 2b04 	str.w	r2, [r0], #4
						j_rev--;
   2459a:	9a02      	ldr	r2, [sp, #8]
   2459c:	3a01      	subs	r2, #1
   2459e:	b2d2      	uxtb	r2, r2
					for (uint8_t j = 0; j < ACC_GYRO_FIFO_BUF_LEN; j++)
   245a0:	428a      	cmp	r2, r1
						j_rev--;
   245a2:	9202      	str	r2, [sp, #8]
					for (uint8_t j = 0; j < ACC_GYRO_FIFO_BUF_LEN; j++)
   245a4:	d1d2      	bne.n	2454c <curr_vrif_buffers+0x204>
   245a6:	3364      	adds	r3, #100	; 0x64
   245a8:	b29b      	uxth	r3, r3
					for (uint8_t k = 0; k < ACC_GYRO_FIFO_BUF_LEN; k++)
   245aa:	461d      	mov	r5, r3
   245ac:	e6eb      	b.n	24386 <curr_vrif_buffers+0x3e>
				if(buff_counter >= 5*ACC_GYRO_FIFO_BUF_LEN && buff_counter < 6*ACC_GYRO_FIFO_BUF_LEN)
   245ae:	f5a3 72fa 	sub.w	r2, r3, #500	; 0x1f4
   245b2:	2a63      	cmp	r2, #99	; 0x63
   245b4:	d8f9      	bhi.n	245aa <curr_vrif_buffers+0x262>
   245b6:	9a01      	ldr	r2, [sp, #4]
   245b8:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 246ac <curr_vrif_buffers+0x364>
   245bc:	f1a2 0164 	sub.w	r1, r2, #100	; 0x64
   245c0:	f8df c0ec 	ldr.w	ip, [pc, #236]	; 246b0 <curr_vrif_buffers+0x368>
   245c4:	4f2d      	ldr	r7, [pc, #180]	; (2467c <curr_vrif_buffers+0x334>)
   245c6:	4e2e      	ldr	r6, [pc, #184]	; (24680 <curr_vrif_buffers+0x338>)
   245c8:	4d2e      	ldr	r5, [pc, #184]	; (24684 <curr_vrif_buffers+0x33c>)
   245ca:	482f      	ldr	r0, [pc, #188]	; (24688 <curr_vrif_buffers+0x340>)
						acc_x_vrif_buffer_1[k]  = accel_tempX[k_rev];
   245cc:	f8df b088 	ldr.w	fp, [pc, #136]	; 24658 <curr_vrif_buffers+0x310>
						acc_y_vrif_buffer_1[k]  = accel_tempY[k_rev];
   245d0:	f8df a088 	ldr.w	sl, [pc, #136]	; 2465c <curr_vrif_buffers+0x314>
						acc_z_vrif_buffer_1[k]  = accel_tempZ[k_rev];
   245d4:	f8df 9088 	ldr.w	r9, [pc, #136]	; 24660 <curr_vrif_buffers+0x318>
   245d8:	b2c9      	uxtb	r1, r1
						acc_x_vrif_buffer_1[k]  = accel_tempX[k_rev];
   245da:	9a01      	ldr	r2, [sp, #4]
						gyro_x_vrif_buffer_1[k] = gyro_tempX[k_rev];
   245dc:	4c1b      	ldr	r4, [pc, #108]	; (2464c <curr_vrif_buffers+0x304>)
						acc_x_vrif_buffer_1[k]  = accel_tempX[k_rev];
   245de:	0092      	lsls	r2, r2, #2
   245e0:	eb0b 0e02 	add.w	lr, fp, r2
   245e4:	f8de e000 	ldr.w	lr, [lr]
   245e8:	f848 eb04 	str.w	lr, [r8], #4
						acc_y_vrif_buffer_1[k]  = accel_tempY[k_rev];
   245ec:	eb0a 0e02 	add.w	lr, sl, r2
   245f0:	f8de e000 	ldr.w	lr, [lr]
   245f4:	f84c eb04 	str.w	lr, [ip], #4
						acc_z_vrif_buffer_1[k]  = accel_tempZ[k_rev];
   245f8:	eb09 0e02 	add.w	lr, r9, r2
   245fc:	f8de e000 	ldr.w	lr, [lr]
   24600:	f847 eb04 	str.w	lr, [r7], #4
						gyro_x_vrif_buffer_1[k] = gyro_tempX[k_rev];
   24604:	eb04 0e02 	add.w	lr, r4, r2
   24608:	f8de e000 	ldr.w	lr, [lr]
						gyro_y_vrif_buffer_1[k] = gyro_tempY[k_rev];
   2460c:	4c10      	ldr	r4, [pc, #64]	; (24650 <curr_vrif_buffers+0x308>)
						gyro_x_vrif_buffer_1[k] = gyro_tempX[k_rev];
   2460e:	f846 eb04 	str.w	lr, [r6], #4
						gyro_y_vrif_buffer_1[k] = gyro_tempY[k_rev];
   24612:	eb04 0e02 	add.w	lr, r4, r2
						gyro_z_vrif_buffer_1[k] = gyro_tempZ[k_rev];
   24616:	4c0f      	ldr	r4, [pc, #60]	; (24654 <curr_vrif_buffers+0x30c>)
						gyro_y_vrif_buffer_1[k] = gyro_tempY[k_rev];
   24618:	f8de e000 	ldr.w	lr, [lr]
						gyro_z_vrif_buffer_1[k] = gyro_tempZ[k_rev];
   2461c:	4422      	add	r2, r4
   2461e:	6812      	ldr	r2, [r2, #0]
						gyro_y_vrif_buffer_1[k] = gyro_tempY[k_rev];
   24620:	f845 eb04 	str.w	lr, [r5], #4
						gyro_z_vrif_buffer_1[k] = gyro_tempZ[k_rev];
   24624:	f840 2b04 	str.w	r2, [r0], #4
						k_rev--;
   24628:	9a01      	ldr	r2, [sp, #4]
   2462a:	1e54      	subs	r4, r2, #1
   2462c:	b2e2      	uxtb	r2, r4
					for (uint8_t k = 0; k < ACC_GYRO_FIFO_BUF_LEN; k++)
   2462e:	428a      	cmp	r2, r1
						k_rev--;
   24630:	9201      	str	r2, [sp, #4]
					for (uint8_t k = 0; k < ACC_GYRO_FIFO_BUF_LEN; k++)
   24632:	d1d2      	bne.n	245da <curr_vrif_buffers+0x292>
   24634:	e7b7      	b.n	245a6 <curr_vrif_buffers+0x25e>
   24636:	bf00      	nop
   24638:	20024634 	.word	0x20024634
   2463c:	2002c317 	.word	0x2002c317
   24640:	200298f4 	.word	0x200298f4
   24644:	200229dc 	.word	0x200229dc
   24648:	447a0000 	.word	0x447a0000
   2464c:	20022a10 	.word	0x20022a10
   24650:	20022ba0 	.word	0x20022ba0
   24654:	20022d30 	.word	0x20022d30
   24658:	20022520 	.word	0x20022520
   2465c:	200226b0 	.word	0x200226b0
   24660:	20022840 	.word	0x20022840
   24664:	20020db0 	.word	0x20020db0
   24668:	20021580 	.word	0x20021580
   2466c:	20022200 	.word	0x20022200
   24670:	20023370 	.word	0x20023370
   24674:	20023b40 	.word	0x20023b40
   24678:	20024310 	.word	0x20024310
   2467c:	20022390 	.word	0x20022390
   24680:	20023500 	.word	0x20023500
   24684:	20023cd0 	.word	0x20023cd0
   24688:	200244a0 	.word	0x200244a0
   2468c:	200298ee 	.word	0x200298ee
   24690:	200229d0 	.word	0x200229d0
   24694:	20021d50 	.word	0x20021d50
   24698:	20022ec0 	.word	0x20022ec0
   2469c:	20023690 	.word	0x20023690
   246a0:	20023e60 	.word	0x20023e60
   246a4:	20021260 	.word	0x20021260
   246a8:	20021a30 	.word	0x20021a30
   246ac:	200213f0 	.word	0x200213f0
   246b0:	20021bc0 	.word	0x20021bc0

000246b4 <ReSetImuSteps>:
	lsm6dso_steps_reset(&imu_dev_ctx);
   246b4:	4801      	ldr	r0, [pc, #4]	; (246bc <ReSetImuSteps+0x8>)
   246b6:	f016 bc39 	b.w	3af2c <lsm6dso_steps_reset>
   246ba:	bf00      	nop
   246bc:	20024634 	.word	0x20024634

000246c0 <GetImuSteps>:
	lsm6dso_number_of_steps_get(&imu_dev_ctx, steps);
   246c0:	4601      	mov	r1, r0
   246c2:	4801      	ldr	r0, [pc, #4]	; (246c8 <GetImuSteps+0x8>)
   246c4:	f016 bc1d 	b.w	3af02 <lsm6dso_number_of_steps_get>
   246c8:	20024634 	.word	0x20024634

000246cc <GetSportData>:

void GetSportData(u16_t *steps, u16_t *calorie, u16_t *distance)
{
	*steps = g_steps;
   246cc:	4b04      	ldr	r3, [pc, #16]	; (246e0 <GetSportData+0x14>)
   246ce:	881b      	ldrh	r3, [r3, #0]
   246d0:	8003      	strh	r3, [r0, #0]
	*calorie = g_calorie;
   246d2:	4b04      	ldr	r3, [pc, #16]	; (246e4 <GetSportData+0x18>)
   246d4:	881b      	ldrh	r3, [r3, #0]
   246d6:	800b      	strh	r3, [r1, #0]
	*distance = g_distance;
   246d8:	4b03      	ldr	r3, [pc, #12]	; (246e8 <GetSportData+0x1c>)
   246da:	881b      	ldrh	r3, [r3, #0]
   246dc:	8013      	strh	r3, [r2, #0]
}
   246de:	4770      	bx	lr
   246e0:	20029900 	.word	0x20029900
   246e4:	200298fc 	.word	0x200298fc
   246e8:	200298fe 	.word	0x200298fe

000246ec <lsm6dso_sensitivity>:
/*@Set Sensor sensitivity
*/
void lsm6dso_sensitivity(void)
{
	//Set the debounce steps
	uint8_t deb_step = 5;
   246ec:	2305      	movs	r3, #5
{
   246ee:	b513      	push	{r0, r1, r4, lr}
	lsm6dso_pedo_debounce_steps_set(&imu_dev_ctx, &deb_step);
   246f0:	4c08      	ldr	r4, [pc, #32]	; (24714 <lsm6dso_sensitivity+0x28>)
   246f2:	f10d 0103 	add.w	r1, sp, #3
   246f6:	4620      	mov	r0, r4
	uint8_t deb_step = 5;
   246f8:	f88d 3003 	strb.w	r3, [sp, #3]
	lsm6dso_pedo_debounce_steps_set(&imu_dev_ctx, &deb_step);
   246fc:	f017 fa79 	bl	3bbf2 <lsm6dso_pedo_debounce_steps_set>

	//Set the sensitivity of the sensor
	uint8_t delay_time[2] = {0x00U, 0x32U};
   24700:	f44f 5348 	mov.w	r3, #12800	; 0x3200
	//Lower Limit is 0 and Upper Limit is 50(32 in Hex), the delay time is 320ms
	lsm6dso_pedo_steps_period_set(&imu_dev_ctx, &delay_time);
   24704:	a901      	add	r1, sp, #4
   24706:	4620      	mov	r0, r4
	uint8_t delay_time[2] = {0x00U, 0x32U};
   24708:	f8ad 3004 	strh.w	r3, [sp, #4]
	lsm6dso_pedo_steps_period_set(&imu_dev_ctx, &delay_time);
   2470c:	f017 fa76 	bl	3bbfc <lsm6dso_pedo_steps_period_set>
}
   24710:	b002      	add	sp, #8
   24712:	bd10      	pop	{r4, pc}
   24714:	20024634 	.word	0x20024634

00024718 <IMU_init>:
		UpdateSleepPara();
	}
}

void IMU_init(struct k_work_q *work_q)
{
   24718:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2471a:	4607      	mov	r7, r0
   2471c:	481e      	ldr	r0, [pc, #120]	; (24798 <IMU_init+0x80>)
   2471e:	f010 ff7f 	bl	35620 <z_impl_device_get_binding>
   24722:	4c1e      	ldr	r4, [pc, #120]	; (2479c <IMU_init+0x84>)
   24724:	4a1e      	ldr	r2, [pc, #120]	; (247a0 <IMU_init+0x88>)
	i2c_imu = device_get_binding(IMU_DEV);
   24726:	4e1f      	ldr	r6, [pc, #124]	; (247a4 <IMU_init+0x8c>)
   24728:	1aa4      	subs	r4, r4, r2
   2472a:	6030      	str	r0, [r6, #0]
	if(!i2c_imu)
   2472c:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   24730:	b958      	cbnz	r0, 2474a <IMU_init+0x32>
		LOG_INF("ERROR SETTING UP I2C\r\n");
   24732:	f04f 0000 	mov.w	r0, #0
   24736:	2303      	movs	r3, #3
   24738:	491b      	ldr	r1, [pc, #108]	; (247a8 <IMU_init+0x90>)
   2473a:	f363 0007 	bfi	r0, r3, #0, #8
   2473e:	f364 108f 	bfi	r0, r4, #6, #10

	imu_work_q = work_q;
	k_work_init(&imu_work, mt_fall_detection);
	
	LOG_INF("IMU_init done!\n");
}
   24742:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	LOG_INF("IMU_init done!\n");
   24746:	f018 b848 	b.w	3c7da <log_string_sync>
	return api->configure(dev, dev_config);
   2474a:	6843      	ldr	r3, [r0, #4]
   2474c:	2104      	movs	r1, #4
   2474e:	681b      	ldr	r3, [r3, #0]
   24750:	4798      	blx	r3
	imu_dev_ctx.write_reg = platform_write;
   24752:	4d16      	ldr	r5, [pc, #88]	; (247ac <IMU_init+0x94>)
	init_gpio();
   24754:	f7ff fb8c 	bl	23e70 <init_gpio>
	imu_dev_ctx.write_reg = platform_write;
   24758:	4b15      	ldr	r3, [pc, #84]	; (247b0 <IMU_init+0x98>)
   2475a:	602b      	str	r3, [r5, #0]
	imu_dev_ctx.read_reg = platform_read;
   2475c:	4b15      	ldr	r3, [pc, #84]	; (247b4 <IMU_init+0x9c>)
   2475e:	606b      	str	r3, [r5, #4]
	imu_dev_ctx.handle = i2c_imu;
   24760:	6833      	ldr	r3, [r6, #0]
   24762:	60ab      	str	r3, [r5, #8]
	sensor_init();
   24764:	f7ff fbd2 	bl	23f0c <sensor_init>
	lsm6dso_steps_reset(&imu_dev_ctx); //reset step counter
   24768:	4628      	mov	r0, r5
   2476a:	f016 fbdf 	bl	3af2c <lsm6dso_steps_reset>
	lsm6dso_sensitivity();
   2476e:	f7ff ffbd 	bl	246ec <lsm6dso_sensitivity>
	StartSleepTimeMonitor();
   24772:	f000 fa07 	bl	24b84 <StartSleepTimeMonitor>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   24776:	2200      	movs	r2, #0
	imu_work_q = work_q;
   24778:	4b0f      	ldr	r3, [pc, #60]	; (247b8 <IMU_init+0xa0>)
   2477a:	4910      	ldr	r1, [pc, #64]	; (247bc <IMU_init+0xa4>)
   2477c:	601f      	str	r7, [r3, #0]
   2477e:	4b10      	ldr	r3, [pc, #64]	; (247c0 <IMU_init+0xa8>)
	LOG_INF("IMU_init done!\n");
   24780:	f04f 0000 	mov.w	r0, #0
   24784:	e9c3 1201 	strd	r1, r2, [r3, #4]
   24788:	601a      	str	r2, [r3, #0]
   2478a:	2303      	movs	r3, #3
   2478c:	f363 0007 	bfi	r0, r3, #0, #8
   24790:	f364 108f 	bfi	r0, r4, #6, #10
   24794:	490b      	ldr	r1, [pc, #44]	; (247c4 <IMU_init+0xac>)
   24796:	e7d4      	b.n	24742 <IMU_init+0x2a>
   24798:	0004156e 	.word	0x0004156e
   2479c:	0003f964 	.word	0x0003f964
   247a0:	0003f8d4 	.word	0x0003f8d4
   247a4:	20024630 	.word	0x20024630
   247a8:	00041574 	.word	0x00041574
   247ac:	20024634 	.word	0x20024634
   247b0:	00023dd1 	.word	0x00023dd1
   247b4:	00023e1d 	.word	0x00023e1d
   247b8:	2002464c 	.word	0x2002464c
   247bc:	00024811 	.word	0x00024811
   247c0:	20024640 	.word	0x20024640
   247c4:	0004158b 	.word	0x0004158b

000247c8 <is_tilt>:
/*@brief Check if a wrist tilt happend
*
* @return If tilt detected, wrist_tilt=true, otherwise false
*/
void is_tilt(void)
{
   247c8:	b507      	push	{r0, r1, r2, lr}
	lsm6dso_all_sources_t status;

	lsm6dso_all_sources_get(&imu_dev_ctx, &status);
   247ca:	4807      	ldr	r0, [pc, #28]	; (247e8 <is_tilt+0x20>)
   247cc:	4669      	mov	r1, sp
   247ce:	f016 fb52 	bl	3ae76 <lsm6dso_all_sources_get>
	if(status.fsm_status_a.is_fsm1)
   247d2:	f89d 3006 	ldrb.w	r3, [sp, #6]
   247d6:	07db      	lsls	r3, r3, #31
	{ 
		//tilt detected
		wrist_tilt = true;
   247d8:	bf42      	ittt	mi
   247da:	2201      	movmi	r2, #1
   247dc:	4b03      	ldrmi	r3, [pc, #12]	; (247ec <is_tilt+0x24>)
   247de:	701a      	strbmi	r2, [r3, #0]
	}
}
   247e0:	b003      	add	sp, #12
   247e2:	f85d fb04 	ldr.w	pc, [sp], #4
   247e6:	bf00      	nop
   247e8:	20024634 	.word	0x20024634
   247ec:	2002c32c 	.word	0x2002c32c

000247f0 <IMURedrawSteps>:
	}
}

void IMURedrawSteps(void)
{
	if(screen_id == SCREEN_ID_IDLE)
   247f0:	4b05      	ldr	r3, [pc, #20]	; (24808 <IMURedrawSteps+0x18>)
   247f2:	781b      	ldrb	r3, [r3, #0]
   247f4:	2b01      	cmp	r3, #1
   247f6:	d106      	bne.n	24806 <IMURedrawSteps+0x16>
	{
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_SPORT;
   247f8:	4b04      	ldr	r3, [pc, #16]	; (2480c <IMURedrawSteps+0x1c>)
   247fa:	68da      	ldr	r2, [r3, #12]
   247fc:	f042 0220 	orr.w	r2, r2, #32
   24800:	60da      	str	r2, [r3, #12]
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   24802:	2202      	movs	r2, #2
   24804:	725a      	strb	r2, [r3, #9]
	}
}
   24806:	4770      	bx	lr
   24808:	2002c382 	.word	0x2002c382
   2480c:	200249ec 	.word	0x200249ec

00024810 <mt_fall_detection>:
	if(int1_event)	//steps or tilt
   24810:	4b3c      	ldr	r3, [pc, #240]	; (24904 <mt_fall_detection+0xf4>)
{
   24812:	b570      	push	{r4, r5, r6, lr}
	if(int1_event)	//steps or tilt
   24814:	781a      	ldrb	r2, [r3, #0]
   24816:	b332      	cbz	r2, 24866 <mt_fall_detection+0x56>
		int1_event = false;
   24818:	2500      	movs	r5, #0
   2481a:	701d      	strb	r5, [r3, #0]
		if(!is_wearing())
   2481c:	f016 f92f 	bl	3aa7e <is_wearing>
   24820:	2800      	cmp	r0, #0
   24822:	d06d      	beq.n	24900 <mt_fall_detection+0xf0>
		if(wrist_tilt)
   24824:	4c38      	ldr	r4, [pc, #224]	; (24908 <mt_fall_detection+0xf8>)
		is_tilt();
   24826:	f7ff ffcf 	bl	247c8 <is_tilt>
		if(wrist_tilt)
   2482a:	4b38      	ldr	r3, [pc, #224]	; (2490c <mt_fall_detection+0xfc>)
   2482c:	4938      	ldr	r1, [pc, #224]	; (24910 <mt_fall_detection+0x100>)
   2482e:	7822      	ldrb	r2, [r4, #0]
   24830:	1a5b      	subs	r3, r3, r1
   24832:	f3c3 03c9 	ubfx	r3, r3, #3, #10
			LOG_INF("tilt trigger!\n");
   24836:	f04f 0000 	mov.w	r0, #0
		if(wrist_tilt)
   2483a:	2a00      	cmp	r2, #0
   2483c:	d046      	beq.n	248cc <mt_fall_detection+0xbc>
			LOG_INF("tilt trigger!\n");
   2483e:	2203      	movs	r2, #3
   24840:	f362 0007 	bfi	r0, r2, #0, #8
   24844:	f363 108f 	bfi	r0, r3, #6, #10
   24848:	4932      	ldr	r1, [pc, #200]	; (24914 <mt_fall_detection+0x104>)
   2484a:	f017 ffc6 	bl	3c7da <log_string_sync>
			if(lcd_is_sleeping && global_settings.wake_screen_by_wrist)
   2484e:	4b32      	ldr	r3, [pc, #200]	; (24918 <mt_fall_detection+0x108>)
			wrist_tilt = false;
   24850:	7025      	strb	r5, [r4, #0]
			if(lcd_is_sleeping && global_settings.wake_screen_by_wrist)
   24852:	781b      	ldrb	r3, [r3, #0]
   24854:	b13b      	cbz	r3, 24866 <mt_fall_detection+0x56>
   24856:	4b31      	ldr	r3, [pc, #196]	; (2491c <mt_fall_detection+0x10c>)
   24858:	791b      	ldrb	r3, [r3, #4]
   2485a:	b123      	cbz	r3, 24866 <mt_fall_detection+0x56>
				sleep_out_by_wrist = true;
   2485c:	2301      	movs	r3, #1
   2485e:	4a30      	ldr	r2, [pc, #192]	; (24920 <mt_fall_detection+0x110>)
   24860:	7013      	strb	r3, [r2, #0]
				lcd_sleep_out = true;
   24862:	4a30      	ldr	r2, [pc, #192]	; (24924 <mt_fall_detection+0x114>)
   24864:	7013      	strb	r3, [r2, #0]
	if(int2_event) //fall
   24866:	4b30      	ldr	r3, [pc, #192]	; (24928 <mt_fall_detection+0x118>)
   24868:	781a      	ldrb	r2, [r3, #0]
   2486a:	b312      	cbz	r2, 248b2 <mt_fall_detection+0xa2>
		int2_event = false;
   2486c:	2200      	movs	r2, #0
   2486e:	701a      	strb	r2, [r3, #0]
		if(!is_wearing()||fall_testing)
   24870:	f016 f905 	bl	3aa7e <is_wearing>
   24874:	2800      	cmp	r0, #0
   24876:	d043      	beq.n	24900 <mt_fall_detection+0xf0>
   24878:	4e2c      	ldr	r6, [pc, #176]	; (2492c <mt_fall_detection+0x11c>)
   2487a:	7835      	ldrb	r5, [r6, #0]
   2487c:	2d00      	cmp	r5, #0
   2487e:	d13f      	bne.n	24900 <mt_fall_detection+0xf0>
		if(fall_result)
   24880:	4c2b      	ldr	r4, [pc, #172]	; (24930 <mt_fall_detection+0x120>)
		fall_detection();
   24882:	f7f8 ff01 	bl	1d688 <fall_detection>
		if(fall_result)
   24886:	7823      	ldrb	r3, [r4, #0]
   24888:	b18b      	cbz	r3, 248ae <mt_fall_detection+0x9e>
			LOG_INF("Fall trigger!\n");
   2488a:	2303      	movs	r3, #3
   2488c:	f04f 0000 	mov.w	r0, #0
   24890:	4a1f      	ldr	r2, [pc, #124]	; (24910 <mt_fall_detection+0x100>)
   24892:	f363 0007 	bfi	r0, r3, #0, #8
   24896:	4b1d      	ldr	r3, [pc, #116]	; (2490c <mt_fall_detection+0xfc>)
   24898:	4926      	ldr	r1, [pc, #152]	; (24934 <mt_fall_detection+0x124>)
   2489a:	1a9b      	subs	r3, r3, r2
   2489c:	08db      	lsrs	r3, r3, #3
   2489e:	f363 108f 	bfi	r0, r3, #6, #10
   248a2:	f017 ff9a 	bl	3c7da <log_string_sync>
			lcd_sleep_out = true;
   248a6:	2201      	movs	r2, #1
   248a8:	4b1e      	ldr	r3, [pc, #120]	; (24924 <mt_fall_detection+0x114>)
			fall_result = false;
   248aa:	7025      	strb	r5, [r4, #0]
			lcd_sleep_out = true;
   248ac:	701a      	strb	r2, [r3, #0]
		fall_testing = false;
   248ae:	2300      	movs	r3, #0
   248b0:	7033      	strb	r3, [r6, #0]
	if(reset_steps)
   248b2:	4b21      	ldr	r3, [pc, #132]	; (24938 <mt_fall_detection+0x128>)
   248b4:	4c21      	ldr	r4, [pc, #132]	; (2493c <mt_fall_detection+0x12c>)
   248b6:	781a      	ldrb	r2, [r3, #0]
   248b8:	b1b2      	cbz	r2, 248e8 <mt_fall_detection+0xd8>
		reset_steps = false;
   248ba:	2200      	movs	r2, #0
   248bc:	701a      	strb	r2, [r3, #0]
		ReSetImuSteps();
   248be:	f7ff fef9 	bl	246b4 <ReSetImuSteps>
		imu_redraw_steps_flag = false;
   248c2:	2300      	movs	r3, #0
   248c4:	7023      	strb	r3, [r4, #0]
		IMURedrawSteps();
   248c6:	f7ff ff93 	bl	247f0 <IMURedrawSteps>
   248ca:	e010      	b.n	248ee <mt_fall_detection+0xde>
			LOG_INF("steps trigger!\n");
   248cc:	2203      	movs	r2, #3
   248ce:	f362 0007 	bfi	r0, r2, #0, #8
   248d2:	f363 108f 	bfi	r0, r3, #6, #10
   248d6:	491a      	ldr	r1, [pc, #104]	; (24940 <mt_fall_detection+0x130>)
   248d8:	f017 ff7f 	bl	3c7da <log_string_sync>
			UpdateIMUData();
   248dc:	f7f9 fc08 	bl	1e0f0 <UpdateIMUData>
			imu_redraw_steps_flag = true;	
   248e0:	2201      	movs	r2, #1
   248e2:	4b16      	ldr	r3, [pc, #88]	; (2493c <mt_fall_detection+0x12c>)
   248e4:	701a      	strb	r2, [r3, #0]
   248e6:	e7be      	b.n	24866 <mt_fall_detection+0x56>
	if(imu_redraw_steps_flag)
   248e8:	7823      	ldrb	r3, [r4, #0]
   248ea:	2b00      	cmp	r3, #0
   248ec:	d1e9      	bne.n	248c2 <mt_fall_detection+0xb2>
	if(update_sleep_parameter)
   248ee:	4b15      	ldr	r3, [pc, #84]	; (24944 <mt_fall_detection+0x134>)
   248f0:	781a      	ldrb	r2, [r3, #0]
   248f2:	b12a      	cbz	r2, 24900 <mt_fall_detection+0xf0>
}
   248f4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		update_sleep_parameter = false;
   248f8:	2200      	movs	r2, #0
   248fa:	701a      	strb	r2, [r3, #0]
		UpdateSleepPara();
   248fc:	f000 b962 	b.w	24bc4 <UpdateSleepPara>
}
   24900:	bd70      	pop	{r4, r5, r6, pc}
   24902:	bf00      	nop
   24904:	2002c31d 	.word	0x2002c31d
   24908:	2002c32c 	.word	0x2002c32c
   2490c:	0003f964 	.word	0x0003f964
   24910:	0003f8d4 	.word	0x0003f8d4
   24914:	00041621 	.word	0x00041621
   24918:	200378e0 	.word	0x200378e0
   2491c:	200298a6 	.word	0x200298a6
   24920:	20029920 	.word	0x20029920
   24924:	2002991f 	.word	0x2002991f
   24928:	2002c323 	.word	0x2002c323
   2492c:	2002c319 	.word	0x2002c319
   24930:	2002c318 	.word	0x2002c318
   24934:	00041640 	.word	0x00041640
   24938:	2002c329 	.word	0x2002c329
   2493c:	200378e4 	.word	0x200378e4
   24940:	00041630 	.word	0x00041630
   24944:	2002c32d 	.word	0x2002c32d

00024948 <IMUMsgProcess>:

void IMUMsgProcess(void)
{
	k_work_submit_to_queue(imu_work_q, &imu_work);
   24948:	4b08      	ldr	r3, [pc, #32]	; (2496c <IMUMsgProcess+0x24>)
   2494a:	4909      	ldr	r1, [pc, #36]	; (24970 <IMUMsgProcess+0x28>)
   2494c:	6818      	ldr	r0, [r3, #0]
   2494e:	e8d1 3fef 	ldaex	r3, [r1]
   24952:	f043 0201 	orr.w	r2, r3, #1
   24956:	e8c1 2fec 	stlex	ip, r2, [r1]
   2495a:	f1bc 0f00 	cmp.w	ip, #0
   2495e:	d1f6      	bne.n	2494e <IMUMsgProcess+0x6>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   24960:	07db      	lsls	r3, r3, #31
   24962:	d402      	bmi.n	2496a <IMUMsgProcess+0x22>
		k_queue_append(&work_q->queue, work);
   24964:	3908      	subs	r1, #8
   24966:	f019 bdd8 	b.w	3e51a <k_queue_append>
}
   2496a:	4770      	bx	lr
   2496c:	2002464c 	.word	0x2002464c
   24970:	20024648 	.word	0x20024648

00024974 <lsm6dso_from_fs2_to_mg>:
  * @{
  *
*/
float_t lsm6dso_from_fs2_to_mg(int16_t lsb)
{
  return ((float_t)lsb) * 0.061f;
   24974:	ee07 0a90 	vmov	s15, r0
   24978:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
}
   2497c:	eddf 7a02 	vldr	s15, [pc, #8]	; 24988 <lsm6dso_from_fs2_to_mg+0x14>
   24980:	ee20 0a27 	vmul.f32	s0, s0, s15
   24984:	4770      	bx	lr
   24986:	bf00      	nop
   24988:	3d79db23 	.word	0x3d79db23

0002498c <lsm6dso_from_fs250_to_mdps>:
  return ((float_t)lsb) *17.50f;
}

float_t lsm6dso_from_fs250_to_mdps(int16_t lsb)
{
  return ((float_t)lsb) *8.750f;
   2498c:	ee07 0a90 	vmov	s15, r0
   24990:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
}
   24994:	eddf 7a02 	vldr	s15, [pc, #8]	; 249a0 <lsm6dso_from_fs250_to_mdps+0x14>
   24998:	ee20 0a27 	vmul.f32	s0, s0, s15
   2499c:	4770      	bx	lr
   2499e:	bf00      	nop
   249a0:	410c0000 	.word	0x410c0000

000249a4 <sleep_timer_handler>:
	return deep_sleep_time*1.0;
}

static void sleep_timer_handler(struct k_timer *timer)
{
	update_sleep_parameter = true;
   249a4:	2201      	movs	r2, #1
   249a6:	4b01      	ldr	r3, [pc, #4]	; (249ac <sleep_timer_handler+0x8>)
   249a8:	701a      	strb	r2, [r3, #0]
}
   249aa:	4770      	bx	lr
   249ac:	2002c32d 	.word	0x2002c32d

000249b0 <Set_Gsensor_data>:
{	
   249b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   249b4:	461f      	mov	r7, r3
   249b6:	e9dd 4509 	ldrd	r4, r5, [sp, #36]	; 0x24
	if(charging)
   249ba:	2d00      	cmp	r5, #0
   249bc:	f040 8084 	bne.w	24ac8 <Set_Gsensor_data+0x118>
	test = abs(x+y+z);
   249c0:	4411      	add	r1, r2
   249c2:	4408      	add	r0, r1
   249c4:	f019 ff1e 	bl	3e804 <abs>
   249c8:	4606      	mov	r6, r0
	if((abs(gsensor-test)) >= 120)  /* gsensor */
   249ca:	f8df 91b0 	ldr.w	r9, [pc, #432]	; 24b7c <Set_Gsensor_data+0x1cc>
	hour_time = hour;
   249ce:	4b60      	ldr	r3, [pc, #384]	; (24b50 <Set_Gsensor_data+0x1a0>)
	if((abs(gsensor-test)) >= 120)  /* gsensor */
   249d0:	f8d9 0000 	ldr.w	r0, [r9]
	hour_time = hour;
   249d4:	601c      	str	r4, [r3, #0]
	if((abs(gsensor-test)) >= 120)  /* gsensor */
   249d6:	1b80      	subs	r0, r0, r6
   249d8:	f019 ff14 	bl	3e804 <abs>
   249dc:	f8df 81a0 	ldr.w	r8, [pc, #416]	; 24b80 <Set_Gsensor_data+0x1d0>
   249e0:	2877      	cmp	r0, #119	; 0x77
		watch_state++;
   249e2:	bfd8      	it	le
   249e4:	f8b8 5000 	ldrhle.w	r5, [r8]
	if(((abs(gsensor-test)) >= 200)||(hr != 0))
   249e8:	f8d9 0000 	ldr.w	r0, [r9]
		watch_state++;
   249ec:	bfdc      	itt	le
   249ee:	3501      	addle	r5, #1
   249f0:	b2ad      	uxthle	r5, r5
	if(((abs(gsensor-test)) >= 200)||(hr != 0))
   249f2:	1b80      	subs	r0, r0, r6
   249f4:	f8a8 5000 	strh.w	r5, [r8]
   249f8:	f019 ff04 	bl	3e804 <abs>
   249fc:	28c7      	cmp	r0, #199	; 0xc7
   249fe:	dc01      	bgt.n	24a04 <Set_Gsensor_data+0x54>
   24a00:	9b08      	ldr	r3, [sp, #32]
   24a02:	b13b      	cbz	r3, 24a14 <Set_Gsensor_data+0x64>
		if(hour < 6)
   24a04:	2c05      	cmp	r4, #5
			waggle_level[hour]++;  /* 06gsensor 00*/
   24a06:	bfdf      	itttt	le
   24a08:	4a52      	ldrle	r2, [pc, #328]	; (24b54 <Set_Gsensor_data+0x1a4>)
   24a0a:	f852 3024 	ldrle.w	r3, [r2, r4, lsl #2]
   24a0e:	3301      	addle	r3, #1
   24a10:	f842 3024 	strle.w	r3, [r2, r4, lsl #2]
	if((rtc_sec % 60) == 0)  /* */
   24a14:	223c      	movs	r2, #60	; 0x3c
   24a16:	4d50      	ldr	r5, [pc, #320]	; (24b58 <Set_Gsensor_data+0x1a8>)
	gsensor = test;
   24a18:	f8c9 6000 	str.w	r6, [r9]
	if((rtc_sec % 60) == 0)  /* */
   24a1c:	6829      	ldr	r1, [r5, #0]
   24a1e:	4e4f      	ldr	r6, [pc, #316]	; (24b5c <Set_Gsensor_data+0x1ac>)
   24a20:	fb91 f3f2 	sdiv	r3, r1, r2
   24a24:	fb02 1313 	mls	r3, r2, r3, r1
   24a28:	2b00      	cmp	r3, #0
   24a2a:	d149      	bne.n	24ac0 <Set_Gsensor_data+0x110>
		if(((move <step)&&(move>0))||(move_flag > 0))  /*  move_flag  */
   24a2c:	6832      	ldr	r2, [r6, #0]
   24a2e:	4b4c      	ldr	r3, [pc, #304]	; (24b60 <Set_Gsensor_data+0x1b0>)
   24a30:	4297      	cmp	r7, r2
   24a32:	dd01      	ble.n	24a38 <Set_Gsensor_data+0x88>
   24a34:	2a00      	cmp	r2, #0
   24a36:	dc02      	bgt.n	24a3e <Set_Gsensor_data+0x8e>
   24a38:	6818      	ldr	r0, [r3, #0]
   24a3a:	2800      	cmp	r0, #0
   24a3c:	dd4a      	ble.n	24ad4 <Set_Gsensor_data+0x124>
			if((move_flag == 0)||((move <step)&&(move>0)))
   24a3e:	6819      	ldr	r1, [r3, #0]
   24a40:	b119      	cbz	r1, 24a4a <Set_Gsensor_data+0x9a>
   24a42:	4297      	cmp	r7, r2
   24a44:	dd42      	ble.n	24acc <Set_Gsensor_data+0x11c>
   24a46:	2a00      	cmp	r2, #0
   24a48:	dd40      	ble.n	24acc <Set_Gsensor_data+0x11c>
				move_flag = 1;
   24a4a:	2101      	movs	r1, #1
				move_flag--;
   24a4c:	6019      	str	r1, [r3, #0]
			if(hour<8)
   24a4e:	2c07      	cmp	r4, #7
   24a50:	dc49      	bgt.n	24ae6 <Set_Gsensor_data+0x136>
				sedentary_time_temp++;
   24a52:	4944      	ldr	r1, [pc, #272]	; (24b64 <Set_Gsensor_data+0x1b4>)
				sedentary_time_temp++;   /*  */
   24a54:	680b      	ldr	r3, [r1, #0]
   24a56:	3301      	adds	r3, #1
   24a58:	600b      	str	r3, [r1, #0]
			if((hour>=6)&&(hour<=8)&&(waggle_flag==0))
   24a5a:	1fa3      	subs	r3, r4, #6
   24a5c:	2b02      	cmp	r3, #2
   24a5e:	d815      	bhi.n	24a8c <Set_Gsensor_data+0xdc>
   24a60:	4941      	ldr	r1, [pc, #260]	; (24b68 <Set_Gsensor_data+0x1b8>)
   24a62:	680b      	ldr	r3, [r1, #0]
   24a64:	b993      	cbnz	r3, 24a8c <Set_Gsensor_data+0xdc>
				for(i=0;i<6;i++)	
   24a66:	4618      	mov	r0, r3
			if((hour>=6)&&(hour<=8)&&(waggle_flag==0))
   24a68:	469c      	mov	ip, r3
   24a6a:	f8df e0e8 	ldr.w	lr, [pc, #232]	; 24b54 <Set_Gsensor_data+0x1a4>
					if(waggle_level[i]==0)
   24a6e:	f85e 9b04 	ldr.w	r9, [lr], #4
   24a72:	f1b9 0f00 	cmp.w	r9, #0
   24a76:	d102      	bne.n	24a7e <Set_Gsensor_data+0xce>
						waggle_flag++; /* 06 */
   24a78:	f04f 0c01 	mov.w	ip, #1
   24a7c:	3301      	adds	r3, #1
				for(i=0;i<6;i++)	
   24a7e:	3001      	adds	r0, #1
   24a80:	2806      	cmp	r0, #6
   24a82:	d1f4      	bne.n	24a6e <Set_Gsensor_data+0xbe>
   24a84:	f1bc 0f00 	cmp.w	ip, #0
   24a88:	d000      	beq.n	24a8c <Set_Gsensor_data+0xdc>
   24a8a:	600b      	str	r3, [r1, #0]
			if((watch_state >= (3600*2))||(waggle_flag >= 7)||/* (3)23*/
   24a8c:	f8b8 3000 	ldrh.w	r3, [r8]
   24a90:	f5b3 5fe1 	cmp.w	r3, #7200	; 0x1c20
   24a94:	d209      	bcs.n	24aaa <Set_Gsensor_data+0xfa>
   24a96:	4934      	ldr	r1, [pc, #208]	; (24b68 <Set_Gsensor_data+0x1b8>)
   24a98:	6809      	ldr	r1, [r1, #0]
   24a9a:	2906      	cmp	r1, #6
   24a9c:	dc05      	bgt.n	24aaa <Set_Gsensor_data+0xfa>
   24a9e:	2c07      	cmp	r4, #7
   24aa0:	dc39      	bgt.n	24b16 <Set_Gsensor_data+0x166>
				((hour<8)&&(sedentary_time_temp > 180)))  /* 1500*/
   24aa2:	4930      	ldr	r1, [pc, #192]	; (24b64 <Set_Gsensor_data+0x1b4>)
   24aa4:	6809      	ldr	r1, [r1, #0]
   24aa6:	29b4      	cmp	r1, #180	; 0xb4
   24aa8:	dd35      	ble.n	24b16 <Set_Gsensor_data+0x166>
				sedentary_time_temp = 0;
   24aaa:	2300      	movs	r3, #0
   24aac:	4a2d      	ldr	r2, [pc, #180]	; (24b64 <Set_Gsensor_data+0x1b4>)
   24aae:	6013      	str	r3, [r2, #0]
				light_sleep_time = 0;				 
   24ab0:	4a2e      	ldr	r2, [pc, #184]	; (24b6c <Set_Gsensor_data+0x1bc>)
   24ab2:	8013      	strh	r3, [r2, #0]
				deep_sleep_time = 0;
   24ab4:	4a2e      	ldr	r2, [pc, #184]	; (24b70 <Set_Gsensor_data+0x1c0>)
   24ab6:	8013      	strh	r3, [r2, #0]
				g_light_sleep = 0;
   24ab8:	4a2e      	ldr	r2, [pc, #184]	; (24b74 <Set_Gsensor_data+0x1c4>)
   24aba:	8013      	strh	r3, [r2, #0]
				g_deep_sleep = 0;
   24abc:	4a2e      	ldr	r2, [pc, #184]	; (24b78 <Set_Gsensor_data+0x1c8>)
   24abe:	8013      	strh	r3, [r2, #0]
	rtc_sec++;
   24ac0:	682b      	ldr	r3, [r5, #0]
	move = step;
   24ac2:	6037      	str	r7, [r6, #0]
	rtc_sec++;
   24ac4:	3301      	adds	r3, #1
   24ac6:	602b      	str	r3, [r5, #0]
}
   24ac8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			else if(move_flag > 0)
   24acc:	2900      	cmp	r1, #0
   24ace:	ddbe      	ble.n	24a4e <Set_Gsensor_data+0x9e>
				move_flag--;
   24ad0:	3901      	subs	r1, #1
   24ad2:	e7bb      	b.n	24a4c <Set_Gsensor_data+0x9c>
		else if((watch_state <= 60)&&(move_flag == 0))
   24ad4:	f8b8 1000 	ldrh.w	r1, [r8]
   24ad8:	293c      	cmp	r1, #60	; 0x3c
   24ada:	d804      	bhi.n	24ae6 <Set_Gsensor_data+0x136>
   24adc:	b918      	cbnz	r0, 24ae6 <Set_Gsensor_data+0x136>
			if(hour<8)
   24ade:	2c07      	cmp	r4, #7
   24ae0:	4920      	ldr	r1, [pc, #128]	; (24b64 <Set_Gsensor_data+0x1b4>)
   24ae2:	ddb7      	ble.n	24a54 <Set_Gsensor_data+0xa4>
				sedentary_time_temp = 0;
   24ae4:	6008      	str	r0, [r1, #0]
		if((hour>=20)||(hour<8))  /* 24 88 */
   24ae6:	f1a4 0108 	sub.w	r1, r4, #8
   24aea:	290b      	cmp	r1, #11
   24aec:	d8b5      	bhi.n	24a5a <Set_Gsensor_data+0xaa>
			gsensor = 0;
   24aee:	2100      	movs	r1, #0
			move_flag = 0;
   24af0:	6019      	str	r1, [r3, #0]
			waggle_flag = 0;
   24af2:	4b1d      	ldr	r3, [pc, #116]	; (24b68 <Set_Gsensor_data+0x1b8>)
			memset(waggle_level,0,sizeof(waggle_level)); /*  */
   24af4:	2230      	movs	r2, #48	; 0x30
			waggle_flag = 0;
   24af6:	6019      	str	r1, [r3, #0]
			deep_sleep_time = 0; 
   24af8:	4b1d      	ldr	r3, [pc, #116]	; (24b70 <Set_Gsensor_data+0x1c0>)
			memset(waggle_level,0,sizeof(waggle_level)); /*  */
   24afa:	4816      	ldr	r0, [pc, #88]	; (24b54 <Set_Gsensor_data+0x1a4>)
			deep_sleep_time = 0; 
   24afc:	8019      	strh	r1, [r3, #0]
			light_sleep_time = 0;
   24afe:	4b1b      	ldr	r3, [pc, #108]	; (24b6c <Set_Gsensor_data+0x1bc>)
			gsensor = 0;
   24b00:	f8c9 1000 	str.w	r1, [r9]
			light_sleep_time = 0;
   24b04:	8019      	strh	r1, [r3, #0]
			sedentary_time_temp = 0;			
   24b06:	4b17      	ldr	r3, [pc, #92]	; (24b64 <Set_Gsensor_data+0x1b4>)
			rtc_sec = 0;
   24b08:	6029      	str	r1, [r5, #0]
			watch_state = 0;
   24b0a:	f8a8 1000 	strh.w	r1, [r8]
			sedentary_time_temp = 0;			
   24b0e:	6019      	str	r1, [r3, #0]
			memset(waggle_level,0,sizeof(waggle_level)); /*  */
   24b10:	f019 febc 	bl	3e88c <memset>
   24b14:	e7d4      	b.n	24ac0 <Set_Gsensor_data+0x110>
			else if((move == step)&&(watch_state >= 60)) /*  */
   24b16:	4297      	cmp	r7, r2
   24b18:	d1d2      	bne.n	24ac0 <Set_Gsensor_data+0x110>
   24b1a:	2b3b      	cmp	r3, #59	; 0x3b
   24b1c:	d9d0      	bls.n	24ac0 <Set_Gsensor_data+0x110>
				if(is_wearing())	//xb add 2021-03-02 
   24b1e:	f015 ffae 	bl	3aa7e <is_wearing>
   24b22:	4a12      	ldr	r2, [pc, #72]	; (24b6c <Set_Gsensor_data+0x1bc>)
   24b24:	4b12      	ldr	r3, [pc, #72]	; (24b70 <Set_Gsensor_data+0x1c0>)
   24b26:	b158      	cbz	r0, 24b40 <Set_Gsensor_data+0x190>
					if(watch_state >= (60*10))/* 15*/
   24b28:	f8b8 1000 	ldrh.w	r1, [r8]
   24b2c:	f5b1 7f16 	cmp.w	r1, #600	; 0x258
						deep_sleep_time++; 
   24b30:	bf2b      	itete	cs
   24b32:	8819      	ldrhcs	r1, [r3, #0]
						light_sleep_time++;
   24b34:	8811      	ldrhcc	r1, [r2, #0]
						deep_sleep_time++; 
   24b36:	3101      	addcs	r1, #1
						light_sleep_time++;
   24b38:	3101      	addcc	r1, #1
						deep_sleep_time++; 
   24b3a:	bf2c      	ite	cs
   24b3c:	8019      	strhcs	r1, [r3, #0]
						light_sleep_time++;
   24b3e:	8011      	strhcc	r1, [r2, #0]
				g_light_sleep = light_sleep_time;
   24b40:	8811      	ldrh	r1, [r2, #0]
   24b42:	4a0c      	ldr	r2, [pc, #48]	; (24b74 <Set_Gsensor_data+0x1c4>)
   24b44:	8011      	strh	r1, [r2, #0]
				g_deep_sleep = deep_sleep_time;
   24b46:	881a      	ldrh	r2, [r3, #0]
   24b48:	4b0b      	ldr	r3, [pc, #44]	; (24b78 <Set_Gsensor_data+0x1c8>)
   24b4a:	801a      	strh	r2, [r3, #0]
   24b4c:	e7b8      	b.n	24ac0 <Set_Gsensor_data+0x110>
   24b4e:	bf00      	nop
   24b50:	20024978 	.word	0x20024978
   24b54:	200249bc 	.word	0x200249bc
   24b58:	20024984 	.word	0x20024984
   24b5c:	2002497c 	.word	0x2002497c
   24b60:	20024980 	.word	0x20024980
   24b64:	20024988 	.word	0x20024988
   24b68:	200249b8 	.word	0x200249b8
   24b6c:	20029908 	.word	0x20029908
   24b70:	20029902 	.word	0x20029902
   24b74:	20029906 	.word	0x20029906
   24b78:	20029904 	.word	0x20029904
   24b7c:	20024974 	.word	0x20024974
   24b80:	2002990a 	.word	0x2002990a

00024b84 <StartSleepTimeMonitor>:

void StartSleepTimeMonitor(void)
{
   24b84:	b510      	push	{r4, lr}
	k_timer_init(&sleep_timer, sleep_timer_handler, NULL);
   24b86:	4c07      	ldr	r4, [pc, #28]	; (24ba4 <StartSleepTimeMonitor+0x20>)
   24b88:	2200      	movs	r2, #0
   24b8a:	4907      	ldr	r1, [pc, #28]	; (24ba8 <StartSleepTimeMonitor+0x24>)
   24b8c:	4620      	mov	r0, r4
   24b8e:	f019 fdae 	bl	3e6ee <k_timer_init>
   24b92:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   24b96:	4620      	mov	r0, r4
	k_timer_start(&sleep_timer, K_MSEC(1000), K_MSEC(1000));
}
   24b98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   24b9c:	4611      	mov	r1, r2
   24b9e:	f013 bd7d 	b.w	3869c <z_impl_k_timer_start>
   24ba2:	bf00      	nop
   24ba4:	2002498c 	.word	0x2002498c
   24ba8:	000249a5 	.word	0x000249a5

00024bac <GetSleepTimeData>:

void GetSleepTimeData(u16_t *deep_sleep, u16_t *light_sleep)
{
	*deep_sleep = g_deep_sleep;
   24bac:	4b03      	ldr	r3, [pc, #12]	; (24bbc <GetSleepTimeData+0x10>)
   24bae:	881b      	ldrh	r3, [r3, #0]
   24bb0:	8003      	strh	r3, [r0, #0]
	*light_sleep = g_light_sleep;
   24bb2:	4b03      	ldr	r3, [pc, #12]	; (24bc0 <GetSleepTimeData+0x14>)
   24bb4:	881b      	ldrh	r3, [r3, #0]
   24bb6:	800b      	strh	r3, [r1, #0]
}
   24bb8:	4770      	bx	lr
   24bba:	bf00      	nop
   24bbc:	20029904 	.word	0x20029904
   24bc0:	20029906 	.word	0x20029906

00024bc4 <UpdateSleepPara>:

	LOG_INF("deep_sleep:%d, light_sleep:%d\n", deep_sleep, light_sleep);
}

void UpdateSleepPara(void)
{
   24bc4:	b510      	push	{r4, lr}
	u16_t steps;
	float sensor_x,sensor_y,sensor_z;
	int chg = 0;

	if(g_chg_status != BAT_CHARGING_NO)
   24bc6:	4b12      	ldr	r3, [pc, #72]	; (24c10 <UpdateSleepPara+0x4c>)
{
   24bc8:	b088      	sub	sp, #32
	if(g_chg_status != BAT_CHARGING_NO)
   24bca:	781c      	ldrb	r4, [r3, #0]
		chg = 1;
	
	get_sensor_reading(&sensor_x, &sensor_y, &sensor_z);
   24bcc:	aa07      	add	r2, sp, #28
	if(g_chg_status != BAT_CHARGING_NO)
   24bce:	3400      	adds	r4, #0
	get_sensor_reading(&sensor_x, &sensor_y, &sensor_z);
   24bd0:	a906      	add	r1, sp, #24
   24bd2:	a805      	add	r0, sp, #20
	if(g_chg_status != BAT_CHARGING_NO)
   24bd4:	bf18      	it	ne
   24bd6:	2401      	movne	r4, #1
	get_sensor_reading(&sensor_x, &sensor_y, &sensor_z);
   24bd8:	f7ff fab8 	bl	2414c <get_sensor_reading>
	GetImuSteps(&steps);
   24bdc:	f10d 0012 	add.w	r0, sp, #18
   24be0:	f7ff fd6e 	bl	246c0 <GetImuSteps>
	Set_Gsensor_data((signed short)sensor_x, (signed short)sensor_x, (signed short)sensor_x, steps, 80, date_time.hour, chg);
   24be4:	eddd 7a05 	vldr	s15, [sp, #20]
   24be8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   24bec:	ee17 3a90 	vmov	r3, s15
   24bf0:	b21a      	sxth	r2, r3
   24bf2:	4b08      	ldr	r3, [pc, #32]	; (24c14 <UpdateSleepPara+0x50>)
   24bf4:	9402      	str	r4, [sp, #8]
   24bf6:	791b      	ldrb	r3, [r3, #4]
   24bf8:	4611      	mov	r1, r2
   24bfa:	9301      	str	r3, [sp, #4]
   24bfc:	2350      	movs	r3, #80	; 0x50
   24bfe:	4610      	mov	r0, r2
   24c00:	9300      	str	r3, [sp, #0]
   24c02:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   24c06:	f7ff fed3 	bl	249b0 <Set_Gsensor_data>
}
   24c0a:	b008      	add	sp, #32
   24c0c:	bd10      	pop	{r4, pc}
   24c0e:	bf00      	nop
   24c10:	2002c385 	.word	0x2002c385
   24c14:	20029894 	.word	0x20029894

00024c18 <EnterNotifyScreen>:
	ExitNotifyScreen();
}

void EnterNotifyScreen(void)
{
	if(screen_id == SCREEN_ID_NOTIFY)
   24c18:	4908      	ldr	r1, [pc, #32]	; (24c3c <EnterNotifyScreen+0x24>)
   24c1a:	780b      	ldrb	r3, [r1, #0]
   24c1c:	2b0a      	cmp	r3, #10
   24c1e:	d00b      	beq.n	24c38 <EnterNotifyScreen+0x20>
		return;

	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   24c20:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   24c22:	4a07      	ldr	r2, [pc, #28]	; (24c40 <EnterNotifyScreen+0x28>)
   24c24:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   24c26:	4a07      	ldr	r2, [pc, #28]	; (24c44 <EnterNotifyScreen+0x2c>)
   24c28:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_NOTIFY;	
   24c2c:	230a      	movs	r3, #10
   24c2e:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_NOTIFY].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_NOTIFY].status = SCREEN_STATUS_CREATING;	
   24c30:	f240 1301 	movw	r3, #257	; 0x101
   24c34:	f8a2 3050 	strh.w	r3, [r2, #80]	; 0x50
}
   24c38:	4770      	bx	lr
   24c3a:	bf00      	nop
   24c3c:	2002c382 	.word	0x2002c382
   24c40:	2002c32e 	.word	0x2002c32e
   24c44:	200249ec 	.word	0x200249ec

00024c48 <DisplayPopUp>:

void DisplayPopUp(u8_t *message)
{
   24c48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t len;
	
	notify_msg.type = NOTIFY_TYPE_POPUP;
   24c4a:	2500      	movs	r5, #0
   24c4c:	4c10      	ldr	r4, [pc, #64]	; (24c90 <DisplayPopUp+0x48>)
{
   24c4e:	4606      	mov	r6, r0
	notify_msg.type = NOTIFY_TYPE_POPUP;
   24c50:	7025      	strb	r5, [r4, #0]
	notify_msg.align = NOTIFY_ALIGN_CENTER;
   24c52:	7065      	strb	r5, [r4, #1]
	
	len = strlen(message);
   24c54:	f7f8 fa80 	bl	1d158 <strlen>
   24c58:	4607      	mov	r7, r0
	if(len > NOTIFY_TEXT_MAX_LEN)
		len = NOTIFY_TEXT_MAX_LEN;
	memset(notify_msg.text, 0x00, sizeof(notify_msg.text));
   24c5a:	2251      	movs	r2, #81	; 0x51
   24c5c:	4629      	mov	r1, r5
   24c5e:	1ca0      	adds	r0, r4, #2
   24c60:	f019 fe14 	bl	3e88c <memset>
	memcpy(notify_msg.text, message, len);
   24c64:	2f50      	cmp	r7, #80	; 0x50
   24c66:	463a      	mov	r2, r7
   24c68:	f04f 0351 	mov.w	r3, #81	; 0x51
   24c6c:	bf28      	it	cs
   24c6e:	2250      	movcs	r2, #80	; 0x50
   24c70:	4631      	mov	r1, r6
   24c72:	1ca0      	adds	r0, r4, #2
   24c74:	f019 fdf7 	bl	3e866 <__memcpy_chk>

	if(notify_msg.type == NOTIFY_TYPE_POPUP)
   24c78:	7822      	ldrb	r2, [r4, #0]
   24c7a:	b922      	cbnz	r2, 24c86 <DisplayPopUp+0x3e>
   24c7c:	f241 3188 	movw	r1, #5000	; 0x1388
   24c80:	4804      	ldr	r0, [pc, #16]	; (24c94 <DisplayPopUp+0x4c>)
   24c82:	f013 fd0b 	bl	3869c <z_impl_k_timer_start>
	{
		k_timer_start(&notify_timer, K_SECONDS(NOTIFY_TIMER_INTERVAL), NULL);
	}
	
	EnterNotifyScreen();
}
   24c86:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	EnterNotifyScreen();
   24c8a:	f7ff bfc5 	b.w	24c18 <EnterNotifyScreen>
   24c8e:	bf00      	nop
   24c90:	2002c32f 	.word	0x2002c32f
   24c94:	20037a18 	.word	0x20037a18

00024c98 <IdleShowSystemDate>:
void IdleShowSystemDate(void)
{
   24c98:	b530      	push	{r4, r5, lr}
   24c9a:	b089      	sub	sp, #36	; 0x24
	u16_t x,y,w,h;
	u8_t str_date[20] = {0};
   24c9c:	2100      	movs	r1, #0
   24c9e:	2214      	movs	r2, #20
   24ca0:	a803      	add	r0, sp, #12
   24ca2:	f019 fdf3 	bl	3e88c <memset>

	POINT_COLOR=WHITE;
	BACK_COLOR=BLACK;
   24ca6:	2400      	movs	r4, #0
	POINT_COLOR=WHITE;
   24ca8:	f64f 72ff 	movw	r2, #65535	; 0xffff
   24cac:	4b18      	ldr	r3, [pc, #96]	; (24d10 <IdleShowSystemDate+0x78>)
	BACK_COLOR=BLACK;
   24cae:	4d19      	ldr	r5, [pc, #100]	; (24d14 <IdleShowSystemDate+0x7c>)

#ifdef FONT_32
	LCD_SetFontSize(FONT_SIZE_32);
   24cb0:	2020      	movs	r0, #32
	POINT_COLOR=WHITE;
   24cb2:	801a      	strh	r2, [r3, #0]
	BACK_COLOR=BLACK;
   24cb4:	802c      	strh	r4, [r5, #0]
	LCD_SetFontSize(FONT_SIZE_32);
   24cb6:	f7fc f8d1 	bl	20e5c <LCD_SetFontSize>
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);	
	LCD_ShowUniString(x,y,str_date);
	
#else

	GetSystemDateStrings(str_date);
   24cba:	a803      	add	r0, sp, #12
   24cbc:	f7fb fd04 	bl	206c8 <GetSystemDateStrings>
	LCD_MeasureString(str_date,&w,&h);
   24cc0:	a803      	add	r0, sp, #12
   24cc2:	f10d 020a 	add.w	r2, sp, #10
   24cc6:	a902      	add	r1, sp, #8
   24cc8:	f7fc f8a4 	bl	20e14 <LCD_MeasureString>
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   24ccc:	4629      	mov	r1, r5
   24cce:	4b12      	ldr	r3, [pc, #72]	; (24d18 <IdleShowSystemDate+0x80>)
   24cd0:	881a      	ldrh	r2, [r3, #0]
   24cd2:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   24cd6:	429a      	cmp	r2, r3
   24cd8:	bf88      	it	hi
   24cda:	1ad0      	subhi	r0, r2, r3
	y = IDLE_DATE_SHOW_Y;
   24cdc:	4b0f      	ldr	r3, [pc, #60]	; (24d1c <IdleShowSystemDate+0x84>)
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   24cde:	bf88      	it	hi
   24ce0:	eb00 70d0 	addhi.w	r0, r0, r0, lsr #31
	y = IDLE_DATE_SHOW_Y;
   24ce4:	781d      	ldrb	r5, [r3, #0]
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);	
   24ce6:	880b      	ldrh	r3, [r1, #0]
	y = IDLE_DATE_SHOW_Y;
   24ce8:	f105 0536 	add.w	r5, r5, #54	; 0x36
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   24cec:	bf88      	it	hi
   24cee:	f3c0 044f 	ubfxhi	r4, r0, #1, #16
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);	
   24cf2:	9300      	str	r3, [sp, #0]
   24cf4:	4629      	mov	r1, r5
   24cf6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
   24cfa:	2000      	movs	r0, #0
   24cfc:	f7fb fee4 	bl	20ac8 <LCD_Fill>
	LCD_ShowString(x,y,str_date);
   24d00:	aa03      	add	r2, sp, #12
   24d02:	4629      	mov	r1, r5
   24d04:	4620      	mov	r0, r4
   24d06:	f7fc f853 	bl	20db0 <LCD_ShowString>
#endif
}
   24d0a:	b009      	add	sp, #36	; 0x24
   24d0c:	bd30      	pop	{r4, r5, pc}
   24d0e:	bf00      	nop
   24d10:	200348dc 	.word	0x200348dc
   24d14:	200298a4 	.word	0x200298a4
   24d18:	200348da 	.word	0x200348da
   24d1c:	200378e1 	.word	0x200378e1

00024d20 <IdleShowSystemTime>:

void IdleShowSystemTime(void)
{
   24d20:	b510      	push	{r4, lr}
   24d22:	b088      	sub	sp, #32
	u16_t x,y,w,h,offset;
	u8_t str_time[20] = {0};
   24d24:	2100      	movs	r1, #0
   24d26:	2214      	movs	r2, #20
   24d28:	a803      	add	r0, sp, #12
   24d2a:	f019 fdaf 	bl	3e88c <memset>
	u8_t str_ampm[5] = {0};

	POINT_COLOR=WHITE;
   24d2e:	f64f 72ff 	movw	r2, #65535	; 0xffff
	u8_t str_ampm[5] = {0};
   24d32:	2400      	movs	r4, #0
	POINT_COLOR=WHITE;
   24d34:	4b19      	ldr	r3, [pc, #100]	; (24d9c <IdleShowSystemTime+0x7c>)
	BACK_COLOR=BLACK;
	
#ifdef FONT_32
	LCD_SetFontSize(FONT_SIZE_32);
   24d36:	2020      	movs	r0, #32
	POINT_COLOR=WHITE;
   24d38:	801a      	strh	r2, [r3, #0]
	BACK_COLOR=BLACK;
   24d3a:	4b19      	ldr	r3, [pc, #100]	; (24da0 <IdleShowSystemTime+0x80>)
	u8_t str_ampm[5] = {0};
   24d3c:	9401      	str	r4, [sp, #4]
	BACK_COLOR=BLACK;
   24d3e:	801c      	strh	r4, [r3, #0]
	u8_t str_ampm[5] = {0};
   24d40:	f88d 4008 	strb.w	r4, [sp, #8]
	LCD_SetFontSize(FONT_SIZE_32);
   24d44:	f7fc f88a 	bl	20e5c <LCD_SetFontSize>
	y = IDLE_TIME_SHOW_Y+offset;
	LCD_ShowUniString(x,y,str_ampm);

#else

	GetSystemTimeStrings(str_time);
   24d48:	a803      	add	r0, sp, #12
   24d4a:	f7fb fd0d 	bl	20768 <GetSystemTimeStrings>
	LCD_MeasureString(str_time,&w,&h);
   24d4e:	f10d 0202 	add.w	r2, sp, #2
   24d52:	4669      	mov	r1, sp
   24d54:	a803      	add	r0, sp, #12
   24d56:	f7fc f85d 	bl	20e14 <LCD_MeasureString>
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   24d5a:	4b12      	ldr	r3, [pc, #72]	; (24da4 <IdleShowSystemTime+0x84>)
   24d5c:	f8bd 2000 	ldrh.w	r2, [sp]
   24d60:	881b      	ldrh	r3, [r3, #0]
	y = IDLE_TIME_SHOW_Y;
	LCD_ShowString(x,y,str_time);
   24d62:	2136      	movs	r1, #54	; 0x36
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   24d64:	4293      	cmp	r3, r2
   24d66:	bf82      	ittt	hi
   24d68:	1a9c      	subhi	r4, r3, r2
   24d6a:	eb04 74d4 	addhi.w	r4, r4, r4, lsr #31
   24d6e:	f3c4 044f 	ubfxhi	r4, r4, #1, #16
	LCD_ShowString(x,y,str_time);
   24d72:	aa03      	add	r2, sp, #12
   24d74:	4620      	mov	r0, r4
   24d76:	f7fc f81b 	bl	20db0 <LCD_ShowString>

	LCD_SetFontSize(FONT_SIZE_16);
   24d7a:	2010      	movs	r0, #16
   24d7c:	f7fc f86e 	bl	20e5c <LCD_SetFontSize>
	GetSysteAmPmStrings(str_ampm);
   24d80:	a801      	add	r0, sp, #4
   24d82:	f7fb fccb 	bl	2071c <GetSysteAmPmStrings>
	x = x+w+5;
   24d86:	f8bd 0000 	ldrh.w	r0, [sp]
	y = IDLE_TIME_SHOW_Y+offset;
	LCD_ShowString(x,y,str_ampm);
   24d8a:	aa01      	add	r2, sp, #4
	x = x+w+5;
   24d8c:	4404      	add	r4, r0
   24d8e:	1d60      	adds	r0, r4, #5
	LCD_ShowString(x,y,str_ampm);
   24d90:	2146      	movs	r1, #70	; 0x46
   24d92:	b280      	uxth	r0, r0
   24d94:	f7fc f80c 	bl	20db0 <LCD_ShowString>
#endif
}
   24d98:	b008      	add	sp, #32
   24d9a:	bd10      	pop	{r4, pc}
   24d9c:	200348dc 	.word	0x200348dc
   24da0:	200298a4 	.word	0x200298a4
   24da4:	200348da 	.word	0x200348da

00024da8 <IdleShowSystemWeek>:

void IdleShowSystemWeek(void)
{
   24da8:	b570      	push	{r4, r5, r6, lr}
   24daa:	b0a4      	sub	sp, #144	; 0x90
	u16_t x,y,w,h;
	u8_t str_week[128] = {0};
   24dac:	2100      	movs	r1, #0
   24dae:	2280      	movs	r2, #128	; 0x80
   24db0:	a804      	add	r0, sp, #16
   24db2:	f019 fd6b 	bl	3e88c <memset>

	POINT_COLOR=WHITE;
   24db6:	f64f 72ff 	movw	r2, #65535	; 0xffff
   24dba:	4b20      	ldr	r3, [pc, #128]	; (24e3c <IdleShowSystemWeek+0x94>)
	BACK_COLOR=BLACK;
   24dbc:	4e20      	ldr	r6, [pc, #128]	; (24e40 <IdleShowSystemWeek+0x98>)
	POINT_COLOR=WHITE;
   24dbe:	801a      	strh	r2, [r3, #0]
	BACK_COLOR=BLACK;
   24dc0:	2300      	movs	r3, #0

#ifdef FONT_32
	LCD_SetFontSize(FONT_SIZE_32);
   24dc2:	2020      	movs	r0, #32
	BACK_COLOR=BLACK;
   24dc4:	8033      	strh	r3, [r6, #0]
	LCD_SetFontSize(FONT_SIZE_32);
   24dc6:	f7fc f849 	bl	20e5c <LCD_SetFontSize>
	LCD_SetFontSize(FONT_SIZE_24);
#else
	LCD_SetFontSize(FONT_SIZE_16);
#endif

	GetSystemWeekStrings(str_week);
   24dca:	a804      	add	r0, sp, #16
   24dcc:	f7fb fcee 	bl	207ac <GetSystemWeekStrings>
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);
	LCD_ShowUniString(x,y,str_week);

#else
	//xb add 2020-11-06
	if(global_settings.language == LANGUAGE_CHN)
   24dd0:	4b1c      	ldr	r3, [pc, #112]	; (24e44 <IdleShowSystemWeek+0x9c>)
   24dd2:	7a5b      	ldrb	r3, [r3, #9]
   24dd4:	2b01      	cmp	r3, #1
   24dd6:	d12d      	bne.n	24e34 <IdleShowSystemWeek+0x8c>
		strcpy(str_week,"It has no chinese font!");
   24dd8:	491b      	ldr	r1, [pc, #108]	; (24e48 <IdleShowSystemWeek+0xa0>)
	else if(global_settings.language == LANGUAGE_JPN)
		strcpy(str_week,"It has no japanese font!");
   24dda:	a804      	add	r0, sp, #16
   24ddc:	f019 febf 	bl	3eb5e <strcpy>
	//xb end

	LCD_MeasureString(str_week,&w,&h);
   24de0:	f10d 020e 	add.w	r2, sp, #14
   24de4:	a903      	add	r1, sp, #12
   24de6:	a804      	add	r0, sp, #16
   24de8:	f7fc f814 	bl	20e14 <LCD_MeasureString>
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   24dec:	4b17      	ldr	r3, [pc, #92]	; (24e4c <IdleShowSystemWeek+0xa4>)
   24dee:	f8bd 400c 	ldrh.w	r4, [sp, #12]
   24df2:	881a      	ldrh	r2, [r3, #0]
	y = IDLE_WEEK_SHOW_Y;
   24df4:	4b16      	ldr	r3, [pc, #88]	; (24e50 <IdleShowSystemWeek+0xa8>)
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   24df6:	42a2      	cmp	r2, r4
   24df8:	bf98      	it	ls
   24dfa:	2400      	movls	r4, #0
	y = IDLE_WEEK_SHOW_Y;
   24dfc:	781d      	ldrb	r5, [r3, #0]
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   24dfe:	bf88      	it	hi
   24e00:	1b14      	subhi	r4, r2, r4
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);
   24e02:	8833      	ldrh	r3, [r6, #0]
	y = IDLE_WEEK_SHOW_Y;
   24e04:	f105 051b 	add.w	r5, r5, #27
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   24e08:	bf88      	it	hi
   24e0a:	eb04 74d4 	addhi.w	r4, r4, r4, lsr #31
	y = IDLE_WEEK_SHOW_Y;
   24e0e:	ea4f 0545 	mov.w	r5, r5, lsl #1
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   24e12:	bf88      	it	hi
   24e14:	f3c4 044f 	ubfxhi	r4, r4, #1, #16
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);
   24e18:	9300      	str	r3, [sp, #0]
   24e1a:	4629      	mov	r1, r5
   24e1c:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   24e20:	2000      	movs	r0, #0
   24e22:	f7fb fe51 	bl	20ac8 <LCD_Fill>
	LCD_ShowString(x,y,str_week);
   24e26:	aa04      	add	r2, sp, #16
   24e28:	4629      	mov	r1, r5
   24e2a:	4620      	mov	r0, r4
   24e2c:	f7fb ffc0 	bl	20db0 <LCD_ShowString>
#endif
}
   24e30:	b024      	add	sp, #144	; 0x90
   24e32:	bd70      	pop	{r4, r5, r6, pc}
	else if(global_settings.language == LANGUAGE_JPN)
   24e34:	2b02      	cmp	r3, #2
   24e36:	d1d3      	bne.n	24de0 <IdleShowSystemWeek+0x38>
		strcpy(str_week,"It has no japanese font!");
   24e38:	4906      	ldr	r1, [pc, #24]	; (24e54 <IdleShowSystemWeek+0xac>)
   24e3a:	e7ce      	b.n	24dda <IdleShowSystemWeek+0x32>
   24e3c:	200348dc 	.word	0x200348dc
   24e40:	200298a4 	.word	0x200298a4
   24e44:	200298a6 	.word	0x200298a6
   24e48:	0004166c 	.word	0x0004166c
   24e4c:	200348da 	.word	0x200348da
   24e50:	200378e1 	.word	0x200378e1
   24e54:	00041684 	.word	0x00041684

00024e58 <IdleUpdateBatSoc>:
	IdleShowSystemDate();
	IdleShowSystemWeek();
}

void IdleUpdateBatSoc(void)
{
   24e58:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	u16_t x,y,w,h;
	u8_t strbuf[10] = {0};
   24e5a:	2300      	movs	r3, #0
	u8_t tmpbuf[128] = {0};
	
	LCD_Fill(BAT_SUBJECT_X+1,BAT_SUBJECT_Y+1,BAT_SUBJECT_W-2,BAT_SUBJECT_H-2,BLACK);
   24e5c:	223a      	movs	r2, #58	; 0x3a
	u8_t strbuf[10] = {0};
   24e5e:	e9cd 3303 	strd	r3, r3, [sp, #12]
   24e62:	f8ad 3014 	strh.w	r3, [sp, #20]
	LCD_Fill(BAT_SUBJECT_X+1,BAT_SUBJECT_Y+1,BAT_SUBJECT_W-2,BAT_SUBJECT_H-2,BLACK);
   24e66:	9300      	str	r3, [sp, #0]
   24e68:	2110      	movs	r1, #16
   24e6a:	2312      	movs	r3, #18
   24e6c:	2060      	movs	r0, #96	; 0x60
   24e6e:	f7fb fe2b 	bl	20ac8 <LCD_Fill>
	
	switch(g_chg_status)
   24e72:	4b1e      	ldr	r3, [pc, #120]	; (24eec <IdleUpdateBatSoc+0x94>)
   24e74:	781b      	ldrb	r3, [r3, #0]
   24e76:	2b01      	cmp	r3, #1
   24e78:	d031      	beq.n	24ede <IdleUpdateBatSoc+0x86>
   24e7a:	b259      	sxtb	r1, r3
   24e7c:	b331      	cbz	r1, 24ecc <IdleUpdateBatSoc+0x74>
   24e7e:	2b02      	cmp	r3, #2
   24e80:	d032      	beq.n	24ee8 <IdleUpdateBatSoc+0x90>
	case BAT_CHARGING_FINISHED:
		strcpy(strbuf, "OK");
		break;
	}

	LCD_SetFontSize(FONT_SIZE_16);
   24e82:	2010      	movs	r0, #16
   24e84:	f7fb ffea 	bl	20e5c <LCD_SetFontSize>
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
	LCD_ShowUniString(BAT_SUBJECT_X+x, BAT_SUBJECT_Y+y, tmpbuf);
	
#else

	LCD_MeasureString(strbuf, &w, &h);
   24e88:	f10d 020a 	add.w	r2, sp, #10
   24e8c:	a902      	add	r1, sp, #8
   24e8e:	a803      	add	r0, sp, #12
   24e90:	f7fb ffc0 	bl	20e14 <LCD_MeasureString>
	x = (w > BAT_SUBJECT_W ? BAT_SUBJECT_X : (BAT_SUBJECT_W-w)/2);
   24e94:	f8bd 0008 	ldrh.w	r0, [sp, #8]
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
   24e98:	f8bd 100a 	ldrh.w	r1, [sp, #10]
	x = (w > BAT_SUBJECT_W ? BAT_SUBJECT_X : (BAT_SUBJECT_W-w)/2);
   24e9c:	283c      	cmp	r0, #60	; 0x3c
   24e9e:	bf9a      	itte	ls
   24ea0:	f1c0 003c 	rsbls	r0, r0, #60	; 0x3c
   24ea4:	f3c0 004f 	ubfxls	r0, r0, #1, #16
   24ea8:	205f      	movhi	r0, #95	; 0x5f
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
   24eaa:	2914      	cmp	r1, #20
   24eac:	bf8e      	itee	hi
   24eae:	210f      	movhi	r1, #15
   24eb0:	f1c1 0114 	rsbls	r1, r1, #20
   24eb4:	f3c1 014f 	ubfxls	r1, r1, #1, #16
	LCD_ShowString(BAT_SUBJECT_X+x, BAT_SUBJECT_Y+y, strbuf);
   24eb8:	310f      	adds	r1, #15
   24eba:	305f      	adds	r0, #95	; 0x5f
   24ebc:	aa03      	add	r2, sp, #12
   24ebe:	b289      	uxth	r1, r1
   24ec0:	b280      	uxth	r0, r0
   24ec2:	f7fb ff75 	bl	20db0 <LCD_ShowString>
#endif
}
   24ec6:	b007      	add	sp, #28
   24ec8:	f85d fb04 	ldr.w	pc, [sp], #4
		sprintf(strbuf, "%02d", g_bat_soc);
   24ecc:	4b08      	ldr	r3, [pc, #32]	; (24ef0 <IdleUpdateBatSoc+0x98>)
   24ece:	220a      	movs	r2, #10
   24ed0:	781b      	ldrb	r3, [r3, #0]
   24ed2:	a803      	add	r0, sp, #12
   24ed4:	9300      	str	r3, [sp, #0]
   24ed6:	4b07      	ldr	r3, [pc, #28]	; (24ef4 <IdleUpdateBatSoc+0x9c>)
   24ed8:	f019 fe1a 	bl	3eb10 <__sprintf_chk>
		break;
   24edc:	e7d1      	b.n	24e82 <IdleUpdateBatSoc+0x2a>
		strcpy(strbuf, "CHG");
   24ede:	4906      	ldr	r1, [pc, #24]	; (24ef8 <IdleUpdateBatSoc+0xa0>)
		strcpy(strbuf, "OK");
   24ee0:	a803      	add	r0, sp, #12
   24ee2:	f019 fe3c 	bl	3eb5e <strcpy>
		break;
   24ee6:	e7cc      	b.n	24e82 <IdleUpdateBatSoc+0x2a>
		strcpy(strbuf, "OK");
   24ee8:	4904      	ldr	r1, [pc, #16]	; (24efc <IdleUpdateBatSoc+0xa4>)
   24eea:	e7f9      	b.n	24ee0 <IdleUpdateBatSoc+0x88>
   24eec:	2002c385 	.word	0x2002c385
   24ef0:	2002c384 	.word	0x2002c384
   24ef4:	00040437 	.word	0x00040437
   24ef8:	0004169d 	.word	0x0004169d
   24efc:	000416a1 	.word	0x000416a1

00024f00 <IdleShowBatSoc>:
{
	u16_t x,y,w,h;
	u8_t strbuf[10] = {0};
	u8_t tmpbuf[128] = {0};
	
	LCD_DrawRectangle(BAT_POSITIVE_X,BAT_POSITIVE_Y,BAT_POSITIVE_W,BAT_POSITIVE_H);
   24f00:	230a      	movs	r3, #10
{
   24f02:	b510      	push	{r4, lr}
	u8_t strbuf[10] = {0};
   24f04:	2400      	movs	r4, #0
{
   24f06:	b086      	sub	sp, #24
	LCD_DrawRectangle(BAT_POSITIVE_X,BAT_POSITIVE_Y,BAT_POSITIVE_W,BAT_POSITIVE_H);
   24f08:	461a      	mov	r2, r3
   24f0a:	2114      	movs	r1, #20
   24f0c:	2055      	movs	r0, #85	; 0x55
	u8_t strbuf[10] = {0};
   24f0e:	e9cd 4403 	strd	r4, r4, [sp, #12]
   24f12:	f8ad 4014 	strh.w	r4, [sp, #20]
	LCD_DrawRectangle(BAT_POSITIVE_X,BAT_POSITIVE_Y,BAT_POSITIVE_W,BAT_POSITIVE_H);
   24f16:	f7fb fdfb 	bl	20b10 <LCD_DrawRectangle>
	LCD_DrawRectangle(BAT_SUBJECT_X,BAT_SUBJECT_Y,BAT_SUBJECT_W,BAT_SUBJECT_H);
   24f1a:	2314      	movs	r3, #20
   24f1c:	223c      	movs	r2, #60	; 0x3c
   24f1e:	210f      	movs	r1, #15
   24f20:	205f      	movs	r0, #95	; 0x5f
   24f22:	f7fb fdf5 	bl	20b10 <LCD_DrawRectangle>
	LCD_Fill(BAT_SUBJECT_X+1,BAT_SUBJECT_Y+1,BAT_SUBJECT_W-2,BAT_SUBJECT_H-2,BLACK);
   24f26:	2312      	movs	r3, #18
   24f28:	9400      	str	r4, [sp, #0]
   24f2a:	223a      	movs	r2, #58	; 0x3a
   24f2c:	2110      	movs	r1, #16
   24f2e:	2060      	movs	r0, #96	; 0x60
   24f30:	f7fb fdca 	bl	20ac8 <LCD_Fill>
	
	switch(g_chg_status)
   24f34:	4b1d      	ldr	r3, [pc, #116]	; (24fac <IdleShowBatSoc+0xac>)
   24f36:	781b      	ldrb	r3, [r3, #0]
   24f38:	2b01      	cmp	r3, #1
   24f3a:	d030      	beq.n	24f9e <IdleShowBatSoc+0x9e>
   24f3c:	b259      	sxtb	r1, r3
   24f3e:	b329      	cbz	r1, 24f8c <IdleShowBatSoc+0x8c>
   24f40:	2b02      	cmp	r3, #2
   24f42:	d031      	beq.n	24fa8 <IdleShowBatSoc+0xa8>
	case BAT_CHARGING_FINISHED:
		strcpy(strbuf, "OK");
		break;
	}

	LCD_SetFontSize(FONT_SIZE_16);
   24f44:	2010      	movs	r0, #16
   24f46:	f7fb ff89 	bl	20e5c <LCD_SetFontSize>
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
	LCD_ShowUniString(BAT_SUBJECT_X+x, BAT_SUBJECT_Y+y, tmpbuf);
	
#else
	
	LCD_MeasureString(strbuf, &w, &h);
   24f4a:	f10d 020a 	add.w	r2, sp, #10
   24f4e:	a902      	add	r1, sp, #8
   24f50:	a803      	add	r0, sp, #12
   24f52:	f7fb ff5f 	bl	20e14 <LCD_MeasureString>
	x = (w > BAT_SUBJECT_W ? BAT_SUBJECT_X : (BAT_SUBJECT_W-w)/2);
   24f56:	f8bd 0008 	ldrh.w	r0, [sp, #8]
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
   24f5a:	f8bd 100a 	ldrh.w	r1, [sp, #10]
	x = (w > BAT_SUBJECT_W ? BAT_SUBJECT_X : (BAT_SUBJECT_W-w)/2);
   24f5e:	283c      	cmp	r0, #60	; 0x3c
   24f60:	bf9a      	itte	ls
   24f62:	f1c0 003c 	rsbls	r0, r0, #60	; 0x3c
   24f66:	f3c0 004f 	ubfxls	r0, r0, #1, #16
   24f6a:	205f      	movhi	r0, #95	; 0x5f
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
   24f6c:	2914      	cmp	r1, #20
   24f6e:	bf8e      	itee	hi
   24f70:	210f      	movhi	r1, #15
   24f72:	f1c1 0114 	rsbls	r1, r1, #20
   24f76:	f3c1 014f 	ubfxls	r1, r1, #1, #16
	LCD_ShowString(BAT_SUBJECT_X+x, BAT_SUBJECT_Y+y, strbuf);
   24f7a:	310f      	adds	r1, #15
   24f7c:	305f      	adds	r0, #95	; 0x5f
   24f7e:	aa03      	add	r2, sp, #12
   24f80:	b289      	uxth	r1, r1
   24f82:	b280      	uxth	r0, r0
   24f84:	f7fb ff14 	bl	20db0 <LCD_ShowString>
#endif
}
   24f88:	b006      	add	sp, #24
   24f8a:	bd10      	pop	{r4, pc}
		sprintf(strbuf, "%02d", g_bat_soc);
   24f8c:	4b08      	ldr	r3, [pc, #32]	; (24fb0 <IdleShowBatSoc+0xb0>)
   24f8e:	220a      	movs	r2, #10
   24f90:	781b      	ldrb	r3, [r3, #0]
   24f92:	a803      	add	r0, sp, #12
   24f94:	9300      	str	r3, [sp, #0]
   24f96:	4b07      	ldr	r3, [pc, #28]	; (24fb4 <IdleShowBatSoc+0xb4>)
   24f98:	f019 fdba 	bl	3eb10 <__sprintf_chk>
		break;
   24f9c:	e7d2      	b.n	24f44 <IdleShowBatSoc+0x44>
		strcpy(strbuf, "CHG");
   24f9e:	4906      	ldr	r1, [pc, #24]	; (24fb8 <IdleShowBatSoc+0xb8>)
		strcpy(strbuf, "OK");
   24fa0:	a803      	add	r0, sp, #12
   24fa2:	f019 fddc 	bl	3eb5e <strcpy>
		break;
   24fa6:	e7cd      	b.n	24f44 <IdleShowBatSoc+0x44>
		strcpy(strbuf, "OK");
   24fa8:	4904      	ldr	r1, [pc, #16]	; (24fbc <IdleShowBatSoc+0xbc>)
   24faa:	e7f9      	b.n	24fa0 <IdleShowBatSoc+0xa0>
   24fac:	2002c385 	.word	0x2002c385
   24fb0:	2002c384 	.word	0x2002c384
   24fb4:	00040437 	.word	0x00040437
   24fb8:	0004169d 	.word	0x0004169d
   24fbc:	000416a1 	.word	0x000416a1

00024fc0 <IdleUpdateSportData>:

void IdleUpdateSportData(void)
{
   24fc0:	b570      	push	{r4, r5, r6, lr}
	u16_t x,y,w,h;
	u8_t strbuf[128] = {0};
   24fc2:	2580      	movs	r5, #128	; 0x80
	LCD_ShowUniString(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3+w, IMU_STEPS_SHOW_Y, tmpbuf);

#else

	LCD_MeasureString("S:", &w, &h);		
	LCD_Fill(IMU_STEPS_SHOW_X+w, IMU_STEPS_SHOW_Y, 50, IMU_STEPS_SHOW_H, BLACK);
   24fc4:	2400      	movs	r4, #0
{
   24fc6:	b0a4      	sub	sp, #144	; 0x90
	u8_t strbuf[128] = {0};
   24fc8:	462a      	mov	r2, r5
   24fca:	2100      	movs	r1, #0
   24fcc:	a804      	add	r0, sp, #16
   24fce:	f019 fc5d 	bl	3e88c <memset>
	LCD_SetFontSize(FONT_SIZE_16);
   24fd2:	2010      	movs	r0, #16
   24fd4:	f7fb ff42 	bl	20e5c <LCD_SetFontSize>
	LCD_MeasureString("S:", &w, &h);		
   24fd8:	f10d 020e 	add.w	r2, sp, #14
   24fdc:	a903      	add	r1, sp, #12
   24fde:	4831      	ldr	r0, [pc, #196]	; (250a4 <IdleUpdateSportData+0xe4>)
   24fe0:	f7fb ff18 	bl	20e14 <LCD_MeasureString>
	LCD_Fill(IMU_STEPS_SHOW_X+w, IMU_STEPS_SHOW_Y, 50, IMU_STEPS_SHOW_H, BLACK);
   24fe4:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   24fe8:	9400      	str	r4, [sp, #0]
   24fea:	300f      	adds	r0, #15
   24fec:	2314      	movs	r3, #20
   24fee:	2232      	movs	r2, #50	; 0x32
   24ff0:	21a0      	movs	r1, #160	; 0xa0
   24ff2:	b280      	uxth	r0, r0
   24ff4:	f7fb fd68 	bl	20ac8 <LCD_Fill>
	sprintf(strbuf, "%d", g_steps);
   24ff8:	4b2b      	ldr	r3, [pc, #172]	; (250a8 <IdleUpdateSportData+0xe8>)
   24ffa:	4e2c      	ldr	r6, [pc, #176]	; (250ac <IdleUpdateSportData+0xec>)
   24ffc:	881b      	ldrh	r3, [r3, #0]
   24ffe:	462a      	mov	r2, r5
   25000:	9300      	str	r3, [sp, #0]
   25002:	4621      	mov	r1, r4
   25004:	4633      	mov	r3, r6
   25006:	a804      	add	r0, sp, #16
   25008:	f019 fd82 	bl	3eb10 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X+w, IMU_STEPS_SHOW_Y, strbuf);
   2500c:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   25010:	aa04      	add	r2, sp, #16
   25012:	300f      	adds	r0, #15
   25014:	21a0      	movs	r1, #160	; 0xa0
   25016:	b280      	uxth	r0, r0
   25018:	f7fb feca 	bl	20db0 <LCD_ShowString>

	LCD_MeasureString("D:", &w, &h);
   2501c:	f10d 020e 	add.w	r2, sp, #14
   25020:	a903      	add	r1, sp, #12
   25022:	4823      	ldr	r0, [pc, #140]	; (250b0 <IdleUpdateSportData+0xf0>)
   25024:	f7fb fef6 	bl	20e14 <LCD_MeasureString>
	LCD_Fill(IMU_STEPS_SHOW_X+IMU_STEPS_SHOW_W/3+w, IMU_STEPS_SHOW_Y, 50, IMU_STEPS_SHOW_H, BLACK);
   25028:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   2502c:	9400      	str	r4, [sp, #0]
   2502e:	3055      	adds	r0, #85	; 0x55
   25030:	2314      	movs	r3, #20
   25032:	2232      	movs	r2, #50	; 0x32
   25034:	21a0      	movs	r1, #160	; 0xa0
   25036:	b280      	uxth	r0, r0
   25038:	f7fb fd46 	bl	20ac8 <LCD_Fill>
	sprintf(strbuf, "%d", g_distance);
   2503c:	4b1d      	ldr	r3, [pc, #116]	; (250b4 <IdleUpdateSportData+0xf4>)
   2503e:	462a      	mov	r2, r5
   25040:	881b      	ldrh	r3, [r3, #0]
   25042:	4621      	mov	r1, r4
   25044:	9300      	str	r3, [sp, #0]
   25046:	a804      	add	r0, sp, #16
   25048:	4633      	mov	r3, r6
   2504a:	f019 fd61 	bl	3eb10 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X+IMU_STEPS_SHOW_W/3+w, IMU_STEPS_SHOW_Y, strbuf);
   2504e:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   25052:	aa04      	add	r2, sp, #16
   25054:	3055      	adds	r0, #85	; 0x55
   25056:	21a0      	movs	r1, #160	; 0xa0
   25058:	b280      	uxth	r0, r0
   2505a:	f7fb fea9 	bl	20db0 <LCD_ShowString>

	LCD_MeasureString("C:", &w, &h);
   2505e:	f10d 020e 	add.w	r2, sp, #14
   25062:	a903      	add	r1, sp, #12
   25064:	4814      	ldr	r0, [pc, #80]	; (250b8 <IdleUpdateSportData+0xf8>)
   25066:	f7fb fed5 	bl	20e14 <LCD_MeasureString>
	LCD_Fill(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3+w, IMU_STEPS_SHOW_Y, 50, IMU_STEPS_SHOW_H, BLACK);
   2506a:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   2506e:	9400      	str	r4, [sp, #0]
   25070:	309b      	adds	r0, #155	; 0x9b
   25072:	2314      	movs	r3, #20
   25074:	2232      	movs	r2, #50	; 0x32
   25076:	21a0      	movs	r1, #160	; 0xa0
   25078:	b280      	uxth	r0, r0
   2507a:	f7fb fd25 	bl	20ac8 <LCD_Fill>
	sprintf(strbuf, "%d", g_calorie);
   2507e:	4b0f      	ldr	r3, [pc, #60]	; (250bc <IdleUpdateSportData+0xfc>)
   25080:	462a      	mov	r2, r5
   25082:	881b      	ldrh	r3, [r3, #0]
   25084:	4621      	mov	r1, r4
   25086:	9300      	str	r3, [sp, #0]
   25088:	a804      	add	r0, sp, #16
   2508a:	4633      	mov	r3, r6
   2508c:	f019 fd40 	bl	3eb10 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3+w, IMU_STEPS_SHOW_Y, strbuf);
   25090:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   25094:	aa04      	add	r2, sp, #16
   25096:	309b      	adds	r0, #155	; 0x9b
   25098:	21a0      	movs	r1, #160	; 0xa0
   2509a:	b280      	uxth	r0, r0
   2509c:	f7fb fe88 	bl	20db0 <LCD_ShowString>
#endif
}
   250a0:	b024      	add	sp, #144	; 0x90
   250a2:	bd70      	pop	{r4, r5, r6, pc}
   250a4:	000416a4 	.word	0x000416a4
   250a8:	20029900 	.word	0x20029900
   250ac:	00040fa6 	.word	0x00040fa6
   250b0:	000416a7 	.word	0x000416a7
   250b4:	200298fe 	.word	0x200298fe
   250b8:	000416aa 	.word	0x000416aa
   250bc:	200298fc 	.word	0x200298fc

000250c0 <IdleShowSportData>:

void IdleShowSportData(void)
{
   250c0:	b530      	push	{r4, r5, lr}
	u16_t x,y,w,h;
	u8_t strbuf[128] = {0};
   250c2:	2580      	movs	r5, #128	; 0x80
	sprintf(strbuf, "C:%d", g_calorie);
	mmi_asc_to_ucs2(tmpbuf,strbuf);
	LCD_ShowUniString(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3, IMU_STEPS_SHOW_Y, tmpbuf);

#else
	LCD_Fill(IMU_STEPS_SHOW_X,IMU_STEPS_SHOW_Y,IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_H,BLACK);
   250c4:	2400      	movs	r4, #0
{
   250c6:	b0a3      	sub	sp, #140	; 0x8c
	u8_t strbuf[128] = {0};
   250c8:	462a      	mov	r2, r5
   250ca:	2100      	movs	r1, #0
   250cc:	a802      	add	r0, sp, #8
   250ce:	f019 fbdd 	bl	3e88c <memset>
	LCD_SetFontSize(FONT_SIZE_16);
   250d2:	2010      	movs	r0, #16
   250d4:	f7fb fec2 	bl	20e5c <LCD_SetFontSize>
	LCD_Fill(IMU_STEPS_SHOW_X,IMU_STEPS_SHOW_Y,IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_H,BLACK);
   250d8:	9400      	str	r4, [sp, #0]
   250da:	2314      	movs	r3, #20
   250dc:	2246      	movs	r2, #70	; 0x46
   250de:	21a0      	movs	r1, #160	; 0xa0
   250e0:	200f      	movs	r0, #15
   250e2:	f7fb fcf1 	bl	20ac8 <LCD_Fill>
	sprintf(strbuf, "S:%d", g_steps);
   250e6:	4b1d      	ldr	r3, [pc, #116]	; (2515c <IdleShowSportData+0x9c>)
   250e8:	462a      	mov	r2, r5
   250ea:	881b      	ldrh	r3, [r3, #0]
   250ec:	4621      	mov	r1, r4
   250ee:	9300      	str	r3, [sp, #0]
   250f0:	a802      	add	r0, sp, #8
   250f2:	4b1b      	ldr	r3, [pc, #108]	; (25160 <IdleShowSportData+0xa0>)
   250f4:	f019 fd0c 	bl	3eb10 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X, IMU_STEPS_SHOW_Y, strbuf);
   250f8:	aa02      	add	r2, sp, #8
   250fa:	21a0      	movs	r1, #160	; 0xa0
   250fc:	200f      	movs	r0, #15
   250fe:	f7fb fe57 	bl	20db0 <LCD_ShowString>

	LCD_Fill(IMU_STEPS_SHOW_X+IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_Y,IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_H,BLACK);
   25102:	9400      	str	r4, [sp, #0]
   25104:	2314      	movs	r3, #20
   25106:	2246      	movs	r2, #70	; 0x46
   25108:	21a0      	movs	r1, #160	; 0xa0
   2510a:	2055      	movs	r0, #85	; 0x55
   2510c:	f7fb fcdc 	bl	20ac8 <LCD_Fill>
	sprintf(strbuf, "D:%d", g_distance);
   25110:	4b14      	ldr	r3, [pc, #80]	; (25164 <IdleShowSportData+0xa4>)
   25112:	462a      	mov	r2, r5
   25114:	881b      	ldrh	r3, [r3, #0]
   25116:	4621      	mov	r1, r4
   25118:	9300      	str	r3, [sp, #0]
   2511a:	a802      	add	r0, sp, #8
   2511c:	4b12      	ldr	r3, [pc, #72]	; (25168 <IdleShowSportData+0xa8>)
   2511e:	f019 fcf7 	bl	3eb10 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X+IMU_STEPS_SHOW_W/3, IMU_STEPS_SHOW_Y, strbuf);
   25122:	aa02      	add	r2, sp, #8
   25124:	21a0      	movs	r1, #160	; 0xa0
   25126:	2055      	movs	r0, #85	; 0x55
   25128:	f7fb fe42 	bl	20db0 <LCD_ShowString>

	LCD_Fill(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_Y,IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_H,BLACK);
   2512c:	9400      	str	r4, [sp, #0]
   2512e:	2314      	movs	r3, #20
   25130:	2246      	movs	r2, #70	; 0x46
   25132:	21a0      	movs	r1, #160	; 0xa0
   25134:	209b      	movs	r0, #155	; 0x9b
   25136:	f7fb fcc7 	bl	20ac8 <LCD_Fill>
	sprintf(strbuf, "C:%d", g_calorie);
   2513a:	4b0c      	ldr	r3, [pc, #48]	; (2516c <IdleShowSportData+0xac>)
   2513c:	462a      	mov	r2, r5
   2513e:	881b      	ldrh	r3, [r3, #0]
   25140:	4621      	mov	r1, r4
   25142:	9300      	str	r3, [sp, #0]
   25144:	a802      	add	r0, sp, #8
   25146:	4b0a      	ldr	r3, [pc, #40]	; (25170 <IdleShowSportData+0xb0>)
   25148:	f019 fce2 	bl	3eb10 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3, IMU_STEPS_SHOW_Y, strbuf);
   2514c:	aa02      	add	r2, sp, #8
   2514e:	21a0      	movs	r1, #160	; 0xa0
   25150:	209b      	movs	r0, #155	; 0x9b
   25152:	f7fb fe2d 	bl	20db0 <LCD_ShowString>
#endif
}
   25156:	b023      	add	sp, #140	; 0x8c
   25158:	bd30      	pop	{r4, r5, pc}
   2515a:	bf00      	nop
   2515c:	20029900 	.word	0x20029900
   25160:	0004165d 	.word	0x0004165d
   25164:	200298fe 	.word	0x200298fe
   25168:	00041662 	.word	0x00041662
   2516c:	200298fc 	.word	0x200298fc
   25170:	00041667 	.word	0x00041667

00025174 <IdleScreenProcess>:

void IdleScreenProcess(void)
{
	switch(scr_msg[SCREEN_ID_IDLE].act)
   25174:	4b24      	ldr	r3, [pc, #144]	; (25208 <IdleScreenProcess+0x94>)
{
   25176:	b510      	push	{r4, lr}
	switch(scr_msg[SCREEN_ID_IDLE].act)
   25178:	7a5a      	ldrb	r2, [r3, #9]
   2517a:	461c      	mov	r4, r3
   2517c:	2a01      	cmp	r2, #1
   2517e:	d002      	beq.n	25186 <IdleScreenProcess+0x12>
   25180:	2a02      	cmp	r2, #2
   25182:	d00d      	beq.n	251a0 <IdleScreenProcess+0x2c>
		}

		if(scr_msg[SCREEN_ID_IDLE].para == SCREEN_EVENT_UPDATE_NO)
			scr_msg[SCREEN_ID_IDLE].act = SCREEN_ACTION_NO;
	}
}
   25184:	bd10      	pop	{r4, pc}
		scr_msg[SCREEN_ID_IDLE].status = SCREEN_STATUS_CREATED;
   25186:	2202      	movs	r2, #2
		LCD_Clear(BLACK);
   25188:	2000      	movs	r0, #0
		scr_msg[SCREEN_ID_IDLE].status = SCREEN_STATUS_CREATED;
   2518a:	811a      	strh	r2, [r3, #8]
		LCD_Clear(BLACK);
   2518c:	f015 fc68 	bl	3aa60 <LCD_Clear>
		IdleShowBatSoc();
   25190:	f7ff feb6 	bl	24f00 <IdleShowBatSoc>
		IdleShowDateTime();
   25194:	f016 ff1b 	bl	3bfce <IdleShowDateTime>
}
   25198:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		IdleShowSportData();
   2519c:	f7ff bf90 	b.w	250c0 <IdleShowSportData>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_BAT)
   251a0:	68db      	ldr	r3, [r3, #12]
   251a2:	0798      	lsls	r0, r3, #30
   251a4:	d504      	bpl.n	251b0 <IdleScreenProcess+0x3c>
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_BAT);
   251a6:	f023 0302 	bic.w	r3, r3, #2
   251aa:	60e3      	str	r3, [r4, #12]
			IdleUpdateBatSoc();
   251ac:	f7ff fe54 	bl	24e58 <IdleUpdateBatSoc>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_TIME)
   251b0:	68e3      	ldr	r3, [r4, #12]
   251b2:	0759      	lsls	r1, r3, #29
   251b4:	d504      	bpl.n	251c0 <IdleScreenProcess+0x4c>
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_TIME);
   251b6:	f023 0304 	bic.w	r3, r3, #4
   251ba:	60e3      	str	r3, [r4, #12]
			IdleShowSystemTime();
   251bc:	f7ff fdb0 	bl	24d20 <IdleShowSystemTime>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_DATE)
   251c0:	68e3      	ldr	r3, [r4, #12]
   251c2:	071a      	lsls	r2, r3, #28
   251c4:	d504      	bpl.n	251d0 <IdleScreenProcess+0x5c>
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_DATE);
   251c6:	f023 0308 	bic.w	r3, r3, #8
   251ca:	60e3      	str	r3, [r4, #12]
			IdleShowSystemDate();
   251cc:	f7ff fd64 	bl	24c98 <IdleShowSystemDate>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_WEEK)
   251d0:	68e3      	ldr	r3, [r4, #12]
   251d2:	06d8      	lsls	r0, r3, #27
   251d4:	d504      	bpl.n	251e0 <IdleScreenProcess+0x6c>
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_WEEK);
   251d6:	f023 0310 	bic.w	r3, r3, #16
   251da:	60e3      	str	r3, [r4, #12]
			IdleShowSystemWeek();
   251dc:	f7ff fde4 	bl	24da8 <IdleShowSystemWeek>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_SPORT)
   251e0:	68e3      	ldr	r3, [r4, #12]
   251e2:	0699      	lsls	r1, r3, #26
   251e4:	d504      	bpl.n	251f0 <IdleScreenProcess+0x7c>
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_SPORT);
   251e6:	f023 0320 	bic.w	r3, r3, #32
   251ea:	60e3      	str	r3, [r4, #12]
			IdleUpdateSportData();
   251ec:	f7ff fee8 	bl	24fc0 <IdleUpdateSportData>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_SLEEP)
   251f0:	68e3      	ldr	r3, [r4, #12]
   251f2:	065a      	lsls	r2, r3, #25
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_SLEEP);
   251f4:	bf44      	itt	mi
   251f6:	f023 0340 	bicmi.w	r3, r3, #64	; 0x40
   251fa:	60e3      	strmi	r3, [r4, #12]
		if(scr_msg[SCREEN_ID_IDLE].para == SCREEN_EVENT_UPDATE_NO)
   251fc:	68e3      	ldr	r3, [r4, #12]
   251fe:	2b00      	cmp	r3, #0
   25200:	d1c0      	bne.n	25184 <IdleScreenProcess+0x10>
			scr_msg[SCREEN_ID_IDLE].act = SCREEN_ACTION_NO;
   25202:	7263      	strb	r3, [r4, #9]
}
   25204:	e7be      	b.n	25184 <IdleScreenProcess+0x10>
   25206:	bf00      	nop
   25208:	200249ec 	.word	0x200249ec

0002520c <AlarmScreenProcess>:

void AlarmScreenProcess(void)
{
   2520c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   25210:	b0a5      	sub	sp, #148	; 0x94
	u16_t rect_x,rect_y,rect_w=180,rect_h=80;
	u16_t x,y,w,h;
	u8_t notify[128] = "Alarm Notify!";
   25212:	aa04      	add	r2, sp, #16
   25214:	4617      	mov	r7, r2
   25216:	4b30      	ldr	r3, [pc, #192]	; (252d8 <AlarmScreenProcess+0xcc>)
   25218:	f103 0508 	add.w	r5, r3, #8
   2521c:	4614      	mov	r4, r2
   2521e:	6818      	ldr	r0, [r3, #0]
   25220:	6859      	ldr	r1, [r3, #4]
   25222:	3308      	adds	r3, #8
   25224:	c403      	stmia	r4!, {r0, r1}
   25226:	42ab      	cmp	r3, r5
   25228:	4622      	mov	r2, r4
   2522a:	d1f7      	bne.n	2521c <AlarmScreenProcess+0x10>
   2522c:	6818      	ldr	r0, [r3, #0]
   2522e:	889b      	ldrh	r3, [r3, #4]

	switch(scr_msg[SCREEN_ID_ALARM].act)
   25230:	4e2a      	ldr	r6, [pc, #168]	; (252dc <AlarmScreenProcess+0xd0>)
	u8_t notify[128] = "Alarm Notify!";
   25232:	6020      	str	r0, [r4, #0]
   25234:	80a3      	strh	r3, [r4, #4]
   25236:	2272      	movs	r2, #114	; 0x72
   25238:	2100      	movs	r1, #0
   2523a:	f10d 001e 	add.w	r0, sp, #30
   2523e:	f019 fb25 	bl	3e88c <memset>
	switch(scr_msg[SCREEN_ID_ALARM].act)
   25242:	7c73      	ldrb	r3, [r6, #17]
   25244:	2b01      	cmp	r3, #1
   25246:	d142      	bne.n	252ce <AlarmScreenProcess+0xc2>
	{
	case SCREEN_ACTION_ENTER:
		scr_msg[SCREEN_ID_ALARM].act = SCREEN_ACTION_NO;
		scr_msg[SCREEN_ID_ALARM].status = SCREEN_STATUS_CREATED;
   25248:	2302      	movs	r3, #2
   2524a:	8233      	strh	r3, [r6, #16]
				
		rect_x = (LCD_WIDTH-rect_w)/2;
   2524c:	4b24      	ldr	r3, [pc, #144]	; (252e0 <AlarmScreenProcess+0xd4>)
		rect_y = (LCD_HEIGHT-rect_h)/2;
		
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   2524e:	22b4      	movs	r2, #180	; 0xb4
		rect_x = (LCD_WIDTH-rect_w)/2;
   25250:	881c      	ldrh	r4, [r3, #0]
		rect_y = (LCD_HEIGHT-rect_h)/2;
   25252:	4b24      	ldr	r3, [pc, #144]	; (252e4 <AlarmScreenProcess+0xd8>)
		rect_x = (LCD_WIDTH-rect_w)/2;
   25254:	3cb4      	subs	r4, #180	; 0xb4
		rect_y = (LCD_HEIGHT-rect_h)/2;
   25256:	881d      	ldrh	r5, [r3, #0]
		rect_x = (LCD_WIDTH-rect_w)/2;
   25258:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
		rect_y = (LCD_HEIGHT-rect_h)/2;
   2525c:	3d50      	subs	r5, #80	; 0x50
   2525e:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   25262:	106d      	asrs	r5, r5, #1
		rect_x = (LCD_WIDTH-rect_w)/2;
   25264:	1064      	asrs	r4, r4, #1
		rect_y = (LCD_HEIGHT-rect_h)/2;
   25266:	fa1f f985 	uxth.w	r9, r5
		rect_x = (LCD_WIDTH-rect_w)/2;
   2526a:	fa1f f884 	uxth.w	r8, r4
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   2526e:	2350      	movs	r3, #80	; 0x50
   25270:	4649      	mov	r1, r9
   25272:	4640      	mov	r0, r8
   25274:	f7fb fc4c 	bl	20b10 <LCD_DrawRectangle>
		LCD_Fill(rect_x+1, rect_y+1, rect_w-2, rect_h-2, BLACK);
   25278:	1c69      	adds	r1, r5, #1
   2527a:	2500      	movs	r5, #0
   2527c:	1c60      	adds	r0, r4, #1
   2527e:	9500      	str	r5, [sp, #0]
   25280:	234e      	movs	r3, #78	; 0x4e
   25282:	22b2      	movs	r2, #178	; 0xb2
   25284:	b289      	uxth	r1, r1
   25286:	b280      	uxth	r0, r0
   25288:	f7fb fc1e 	bl	20ac8 <LCD_Fill>

	#ifdef FONT_24
		LCD_SetFontSize(FONT_SIZE_24);
   2528c:	2018      	movs	r0, #24
   2528e:	f7fb fde5 	bl	20e5c <LCD_SetFontSize>
	#else
		LCD_SetFontSize(FONT_SIZE_16);
	#endif
		LCD_MeasureString(notify,&w,&h);
   25292:	f10d 020e 	add.w	r2, sp, #14
   25296:	a903      	add	r1, sp, #12
   25298:	4638      	mov	r0, r7
   2529a:	f7fb fdbb 	bl	20e14 <LCD_MeasureString>
		x = (w > rect_w)? 0 : (rect_w-w)/2;
   2529e:	f8bd 000c 	ldrh.w	r0, [sp, #12]
		y = (h > rect_h)? 0 : (rect_h-h)/2;
   252a2:	f8bd 100e 	ldrh.w	r1, [sp, #14]
		x = (w > rect_w)? 0 : (rect_w-w)/2;
   252a6:	28b4      	cmp	r0, #180	; 0xb4
   252a8:	bf9c      	itt	ls
   252aa:	f1c0 05b4 	rsbls	r5, r0, #180	; 0xb4
   252ae:	f3c5 054f 	ubfxls	r5, r5, #1, #16
		y = (h > rect_h)? 0 : (rect_h-h)/2;
   252b2:	2950      	cmp	r1, #80	; 0x50
   252b4:	bf8e      	itee	hi
   252b6:	2100      	movhi	r1, #0
   252b8:	f1c1 0150 	rsbls	r1, r1, #80	; 0x50
   252bc:	f3c1 014f 	ubfxls	r1, r1, #1, #16
		x += rect_x;
		y += rect_y;
   252c0:	4449      	add	r1, r9
		x += rect_x;
   252c2:	4445      	add	r5, r8
		LCD_ShowString(x,y,notify);
   252c4:	463a      	mov	r2, r7
   252c6:	b289      	uxth	r1, r1
   252c8:	b2a8      	uxth	r0, r5
   252ca:	f7fb fd71 	bl	20db0 <LCD_ShowString>
		
	case SCREEN_ACTION_UPDATE:
		break;
	}
	
	scr_msg[SCREEN_ID_ALARM].act = SCREEN_ACTION_NO;
   252ce:	2300      	movs	r3, #0
   252d0:	7473      	strb	r3, [r6, #17]
}
   252d2:	b025      	add	sp, #148	; 0x94
   252d4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   252d8:	0003fa70 	.word	0x0003fa70
   252dc:	200249ec 	.word	0x200249ec
   252e0:	200348da 	.word	0x200348da
   252e4:	200348d8 	.word	0x200348d8

000252e8 <FindDeviceScreenProcess>:

void FindDeviceScreenProcess(void)
{
   252e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   252ec:	b0a5      	sub	sp, #148	; 0x94
	u16_t rect_x,rect_y,rect_w=180,rect_h=80;
	u16_t x,y,w,h;
	u8_t notify[128] = "Find Device!";
   252ee:	aa04      	add	r2, sp, #16
   252f0:	4617      	mov	r7, r2
   252f2:	4b30      	ldr	r3, [pc, #192]	; (253b4 <FindDeviceScreenProcess+0xcc>)
   252f4:	f103 0508 	add.w	r5, r3, #8
   252f8:	4614      	mov	r4, r2
   252fa:	6818      	ldr	r0, [r3, #0]
   252fc:	6859      	ldr	r1, [r3, #4]
   252fe:	3308      	adds	r3, #8
   25300:	c403      	stmia	r4!, {r0, r1}
   25302:	42ab      	cmp	r3, r5
   25304:	4622      	mov	r2, r4
   25306:	d1f7      	bne.n	252f8 <FindDeviceScreenProcess+0x10>
   25308:	6818      	ldr	r0, [r3, #0]
   2530a:	791b      	ldrb	r3, [r3, #4]

	switch(scr_msg[SCREEN_ID_FIND_DEVICE].act)
   2530c:	4e2a      	ldr	r6, [pc, #168]	; (253b8 <FindDeviceScreenProcess+0xd0>)
	u8_t notify[128] = "Find Device!";
   2530e:	6020      	str	r0, [r4, #0]
   25310:	7123      	strb	r3, [r4, #4]
   25312:	2273      	movs	r2, #115	; 0x73
   25314:	2100      	movs	r1, #0
   25316:	f10d 001d 	add.w	r0, sp, #29
   2531a:	f019 fab7 	bl	3e88c <memset>
	switch(scr_msg[SCREEN_ID_FIND_DEVICE].act)
   2531e:	7e73      	ldrb	r3, [r6, #25]
   25320:	2b01      	cmp	r3, #1
   25322:	d142      	bne.n	253aa <FindDeviceScreenProcess+0xc2>
	{
	case SCREEN_ACTION_ENTER:
		scr_msg[SCREEN_ID_FIND_DEVICE].act = SCREEN_ACTION_NO;
		scr_msg[SCREEN_ID_FIND_DEVICE].status = SCREEN_STATUS_CREATED;
   25324:	2302      	movs	r3, #2
   25326:	8333      	strh	r3, [r6, #24]
				
		rect_x = (LCD_WIDTH-rect_w)/2;
   25328:	4b24      	ldr	r3, [pc, #144]	; (253bc <FindDeviceScreenProcess+0xd4>)
		rect_y = (LCD_HEIGHT-rect_h)/2;
		
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   2532a:	22b4      	movs	r2, #180	; 0xb4
		rect_x = (LCD_WIDTH-rect_w)/2;
   2532c:	881c      	ldrh	r4, [r3, #0]
		rect_y = (LCD_HEIGHT-rect_h)/2;
   2532e:	4b24      	ldr	r3, [pc, #144]	; (253c0 <FindDeviceScreenProcess+0xd8>)
		rect_x = (LCD_WIDTH-rect_w)/2;
   25330:	3cb4      	subs	r4, #180	; 0xb4
		rect_y = (LCD_HEIGHT-rect_h)/2;
   25332:	881d      	ldrh	r5, [r3, #0]
		rect_x = (LCD_WIDTH-rect_w)/2;
   25334:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
		rect_y = (LCD_HEIGHT-rect_h)/2;
   25338:	3d50      	subs	r5, #80	; 0x50
   2533a:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   2533e:	106d      	asrs	r5, r5, #1
		rect_x = (LCD_WIDTH-rect_w)/2;
   25340:	1064      	asrs	r4, r4, #1
		rect_y = (LCD_HEIGHT-rect_h)/2;
   25342:	fa1f f985 	uxth.w	r9, r5
		rect_x = (LCD_WIDTH-rect_w)/2;
   25346:	fa1f f884 	uxth.w	r8, r4
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   2534a:	2350      	movs	r3, #80	; 0x50
   2534c:	4649      	mov	r1, r9
   2534e:	4640      	mov	r0, r8
   25350:	f7fb fbde 	bl	20b10 <LCD_DrawRectangle>
		LCD_Fill(rect_x+1, rect_y+1, rect_w-2, rect_h-2, BLACK);
   25354:	1c69      	adds	r1, r5, #1
   25356:	2500      	movs	r5, #0
   25358:	1c60      	adds	r0, r4, #1
   2535a:	9500      	str	r5, [sp, #0]
   2535c:	234e      	movs	r3, #78	; 0x4e
   2535e:	22b2      	movs	r2, #178	; 0xb2
   25360:	b289      	uxth	r1, r1
   25362:	b280      	uxth	r0, r0
   25364:	f7fb fbb0 	bl	20ac8 <LCD_Fill>
		
	#ifdef FONT_24
		LCD_SetFontSize(FONT_SIZE_24);
   25368:	2018      	movs	r0, #24
   2536a:	f7fb fd77 	bl	20e5c <LCD_SetFontSize>
	#else
		LCD_SetFontSize(FONT_SIZE_16);
	#endif
		LCD_MeasureString(notify,&w,&h);
   2536e:	f10d 020e 	add.w	r2, sp, #14
   25372:	a903      	add	r1, sp, #12
   25374:	4638      	mov	r0, r7
   25376:	f7fb fd4d 	bl	20e14 <LCD_MeasureString>
		x = (w > rect_w)? 0 : (rect_w-w)/2;
   2537a:	f8bd 000c 	ldrh.w	r0, [sp, #12]
		y = (h > rect_h)? 0 : (rect_h-h)/2;
   2537e:	f8bd 100e 	ldrh.w	r1, [sp, #14]
		x = (w > rect_w)? 0 : (rect_w-w)/2;
   25382:	28b4      	cmp	r0, #180	; 0xb4
   25384:	bf9c      	itt	ls
   25386:	f1c0 05b4 	rsbls	r5, r0, #180	; 0xb4
   2538a:	f3c5 054f 	ubfxls	r5, r5, #1, #16
		y = (h > rect_h)? 0 : (rect_h-h)/2;
   2538e:	2950      	cmp	r1, #80	; 0x50
   25390:	bf8e      	itee	hi
   25392:	2100      	movhi	r1, #0
   25394:	f1c1 0150 	rsbls	r1, r1, #80	; 0x50
   25398:	f3c1 014f 	ubfxls	r1, r1, #1, #16
		x += rect_x;
		y += rect_y;
   2539c:	4449      	add	r1, r9
		x += rect_x;
   2539e:	4445      	add	r5, r8
		LCD_ShowString(x,y,notify);
   253a0:	463a      	mov	r2, r7
   253a2:	b289      	uxth	r1, r1
   253a4:	b2a8      	uxth	r0, r5
   253a6:	f7fb fd03 	bl	20db0 <LCD_ShowString>
		
	case SCREEN_ACTION_UPDATE:
		break;
	}
	
	scr_msg[SCREEN_ID_FIND_DEVICE].act = SCREEN_ACTION_NO;
   253aa:	2300      	movs	r3, #0
   253ac:	7673      	strb	r3, [r6, #25]
}
   253ae:	b025      	add	sp, #148	; 0x94
   253b0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   253b4:	0003faf0 	.word	0x0003faf0
   253b8:	200249ec 	.word	0x200249ec
   253bc:	200348da 	.word	0x200348da
   253c0:	200348d8 	.word	0x200348d8

000253c4 <NotifyScreenProcess>:

void NotifyScreenProcess(void)
{
   253c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u16_t rect_x,rect_y,rect_w=180,rect_h=120;
	u16_t x,y,w,h;
	u16_t offset_w=4,offset_h=4;

	switch(scr_msg[SCREEN_ID_NOTIFY].act)
   253c8:	4b83      	ldr	r3, [pc, #524]	; (255d8 <NotifyScreenProcess+0x214>)
{
   253ca:	b0a9      	sub	sp, #164	; 0xa4
	switch(scr_msg[SCREEN_ID_NOTIFY].act)
   253cc:	f893 2051 	ldrb.w	r2, [r3, #81]	; 0x51
   253d0:	9303      	str	r3, [sp, #12]
   253d2:	2a01      	cmp	r2, #1
   253d4:	d135      	bne.n	25442 <NotifyScreenProcess+0x7e>
	{
	case SCREEN_ACTION_ENTER:
		scr_msg[SCREEN_ID_NOTIFY].act = SCREEN_ACTION_NO;
		scr_msg[SCREEN_ID_NOTIFY].status = SCREEN_STATUS_CREATED;
   253d6:	2302      	movs	r3, #2
   253d8:	4a7f      	ldr	r2, [pc, #508]	; (255d8 <NotifyScreenProcess+0x214>)
		
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
		LCD_Fill(rect_x+1, rect_y+1, rect_w-2, rect_h-2, BLACK);
		
		LCD_SetFontSize(FONT_SIZE_16);
		LCD_MeasureString(notify_msg.text, &w, &h);
   253da:	f8df 920c 	ldr.w	r9, [pc, #524]	; 255e8 <NotifyScreenProcess+0x224>
		scr_msg[SCREEN_ID_NOTIFY].status = SCREEN_STATUS_CREATED;
   253de:	f8a2 3050 	strh.w	r3, [r2, #80]	; 0x50
		rect_x = (LCD_WIDTH-rect_w)/2;
   253e2:	4b7e      	ldr	r3, [pc, #504]	; (255dc <NotifyScreenProcess+0x218>)
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   253e4:	22b4      	movs	r2, #180	; 0xb4
		rect_x = (LCD_WIDTH-rect_w)/2;
   253e6:	881e      	ldrh	r6, [r3, #0]
		rect_y = (LCD_HEIGHT-rect_h)/2;
   253e8:	4b7d      	ldr	r3, [pc, #500]	; (255e0 <NotifyScreenProcess+0x21c>)
		rect_x = (LCD_WIDTH-rect_w)/2;
   253ea:	3eb4      	subs	r6, #180	; 0xb4
		rect_y = (LCD_HEIGHT-rect_h)/2;
   253ec:	881d      	ldrh	r5, [r3, #0]
		rect_x = (LCD_WIDTH-rect_w)/2;
   253ee:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
		rect_y = (LCD_HEIGHT-rect_h)/2;
   253f2:	3d78      	subs	r5, #120	; 0x78
   253f4:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
		rect_x = (LCD_WIDTH-rect_w)/2;
   253f8:	1076      	asrs	r6, r6, #1
		rect_y = (LCD_HEIGHT-rect_h)/2;
   253fa:	106d      	asrs	r5, r5, #1
		rect_x = (LCD_WIDTH-rect_w)/2;
   253fc:	b2b4      	uxth	r4, r6
		rect_y = (LCD_HEIGHT-rect_h)/2;
   253fe:	fa1f f885 	uxth.w	r8, r5
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   25402:	2378      	movs	r3, #120	; 0x78
   25404:	4641      	mov	r1, r8
   25406:	4620      	mov	r0, r4
   25408:	f7fb fb82 	bl	20b10 <LCD_DrawRectangle>
		LCD_Fill(rect_x+1, rect_y+1, rect_w-2, rect_h-2, BLACK);
   2540c:	2300      	movs	r3, #0
   2540e:	1c69      	adds	r1, r5, #1
   25410:	1c70      	adds	r0, r6, #1
   25412:	22b2      	movs	r2, #178	; 0xb2
   25414:	b289      	uxth	r1, r1
   25416:	9300      	str	r3, [sp, #0]
   25418:	b280      	uxth	r0, r0
   2541a:	2376      	movs	r3, #118	; 0x76
   2541c:	f7fb fb54 	bl	20ac8 <LCD_Fill>
		LCD_MeasureString(notify_msg.text, &w, &h);
   25420:	f109 0502 	add.w	r5, r9, #2
		LCD_SetFontSize(FONT_SIZE_16);
   25424:	2010      	movs	r0, #16
   25426:	f7fb fd19 	bl	20e5c <LCD_SetFontSize>
		LCD_MeasureString(notify_msg.text, &w, &h);
   2542a:	f10d 021e 	add.w	r2, sp, #30
   2542e:	a907      	add	r1, sp, #28
   25430:	4628      	mov	r0, r5
   25432:	f7fb fcef 	bl	20e14 <LCD_MeasureString>
		switch(notify_msg.align)
   25436:	f899 6001 	ldrb.w	r6, [r9, #1]
   2543a:	b14e      	cbz	r6, 25450 <NotifyScreenProcess+0x8c>
   2543c:	2e01      	cmp	r6, #1
   2543e:	f000 80be 	beq.w	255be <NotifyScreenProcess+0x1fa>
		
	case SCREEN_ACTION_UPDATE:
		break;
	}
	
	scr_msg[SCREEN_ID_NOTIFY].act = SCREEN_ACTION_NO;
   25442:	2300      	movs	r3, #0
   25444:	9a03      	ldr	r2, [sp, #12]
   25446:	f882 3051 	strb.w	r3, [r2, #81]	; 0x51

}
   2544a:	b029      	add	sp, #164	; 0xa4
   2544c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if(w > (rect_w-2*offset_w))
   25450:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   25454:	f108 0804 	add.w	r8, r8, #4
   25458:	2bac      	cmp	r3, #172	; 0xac
   2545a:	f8bd 701e 	ldrh.w	r7, [sp, #30]
   2545e:	fa0f f888 	sxth.w	r8, r8
   25462:	f240 8098 	bls.w	25596 <NotifyScreenProcess+0x1d2>
				line_count = w/(rect_w-2*offset_w) + ((w%(rect_w-offset_w) != 0)? 1 : 0);
   25466:	22b0      	movs	r2, #176	; 0xb0
   25468:	fbb3 f1f2 	udiv	r1, r3, r2
   2546c:	fb02 3111 	mls	r1, r2, r1, r3
   25470:	22ac      	movs	r2, #172	; 0xac
   25472:	fbb3 f3f2 	udiv	r3, r3, r2
   25476:	2270      	movs	r2, #112	; 0x70
				u16_t line_h=(h+offset_h);
   25478:	3704      	adds	r7, #4
				line_count = w/(rect_w-2*offset_w) + ((w%(rect_w-offset_w) != 0)? 1 : 0);
   2547a:	2900      	cmp	r1, #0
   2547c:	bf18      	it	ne
   2547e:	3301      	addne	r3, #1
				u16_t line_h=(h+offset_h);
   25480:	b2bf      	uxth	r7, r7
				line_count = w/(rect_w-2*offset_w) + ((w%(rect_w-offset_w) != 0)? 1 : 0);
   25482:	fbb2 f2f7 	udiv	r2, r2, r7
   25486:	b2db      	uxtb	r3, r3
				if(line_count > line_max)
   25488:	429a      	cmp	r2, r3
   2548a:	bf28      	it	cs
   2548c:	461a      	movcs	r2, r3
				text_len = strlen(notify_msg.text);
   2548e:	4628      	mov	r0, r5
   25490:	9202      	str	r2, [sp, #8]
   25492:	f7f7 fe61 	bl	1d158 <strlen>
				y = ((rect_h-2*offset_h)-line_count*line_h)/2;
   25496:	9b02      	ldr	r3, [sp, #8]
				text_len = strlen(notify_msg.text);
   25498:	fa1f fb80 	uxth.w	fp, r0
				y = ((rect_h-2*offset_h)-line_count*line_h)/2;
   2549c:	fb07 f503 	mul.w	r5, r7, r3
   254a0:	f1c5 0570 	rsb	r5, r5, #112	; 0x70
   254a4:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   254a8:	1d23      	adds	r3, r4, #4
				y += (rect_y+offset_h);
   254aa:	eb08 0565 	add.w	r5, r8, r5, asr #1
   254ae:	b21b      	sxth	r3, r3
   254b0:	b2ad      	uxth	r5, r5
					tmpbuf[i++] = notify_msg.text[byte_no++];
   254b2:	f8cd 9010 	str.w	r9, [sp, #16]
   254b6:	9305      	str	r3, [sp, #20]
				while(line_no<line_count)
   254b8:	9b02      	ldr	r3, [sp, #8]
   254ba:	2b00      	cmp	r3, #0
   254bc:	d0c1      	beq.n	25442 <NotifyScreenProcess+0x7e>
					u8_t tmpbuf[128] = {0};
   254be:	f10d 0a20 	add.w	sl, sp, #32
   254c2:	2280      	movs	r2, #128	; 0x80
   254c4:	2100      	movs	r1, #0
   254c6:	4650      	mov	r0, sl
   254c8:	f019 f9e0 	bl	3e88c <memset>
					tmpbuf[i++] = notify_msg.text[byte_no++];
   254cc:	9b04      	ldr	r3, [sp, #16]
					LCD_MeasureString(tmpbuf, &w, &h);
   254ce:	f10d 021e 	add.w	r2, sp, #30
					tmpbuf[i++] = notify_msg.text[byte_no++];
   254d2:	4433      	add	r3, r6
   254d4:	789b      	ldrb	r3, [r3, #2]
					LCD_MeasureString(tmpbuf, &w, &h);
   254d6:	a907      	add	r1, sp, #28
   254d8:	4650      	mov	r0, sl
					tmpbuf[i++] = notify_msg.text[byte_no++];
   254da:	f106 0901 	add.w	r9, r6, #1
   254de:	f88d 3020 	strb.w	r3, [sp, #32]
					LCD_MeasureString(tmpbuf, &w, &h);
   254e2:	fa1f f989 	uxth.w	r9, r9
   254e6:	f7fb fc95 	bl	20e14 <LCD_MeasureString>
					while(w < (rect_w-2*offset_w))
   254ea:	9b04      	ldr	r3, [sp, #16]
   254ec:	f109 0902 	add.w	r9, r9, #2
   254f0:	4499      	add	r9, r3
   254f2:	f04f 0801 	mov.w	r8, #1
							tmpbuf[i++] = notify_msg.text[byte_no++];
   254f6:	4653      	mov	r3, sl
					while(w < (rect_w-2*offset_w))
   254f8:	f8bd 101c 	ldrh.w	r1, [sp, #28]
   254fc:	eb06 0208 	add.w	r2, r6, r8
   25500:	29ab      	cmp	r1, #171	; 0xab
   25502:	b292      	uxth	r2, r2
   25504:	d922      	bls.n	2554c <NotifyScreenProcess+0x188>
					if(byte_no < text_len)
   25506:	4593      	cmp	fp, r2
   25508:	d930      	bls.n	2556c <NotifyScreenProcess+0x1a8>
						tmpbuf[i] = 0x00;
   2550a:	ab28      	add	r3, sp, #160	; 0xa0
						i -= 2;
   2550c:	f1a8 0802 	sub.w	r8, r8, #2
						tmpbuf[i] = 0x00;
   25510:	fa53 f888 	uxtab	r8, r3, r8
   25514:	2300      	movs	r3, #0
						byte_no -= 2;
   25516:	1e96      	subs	r6, r2, #2
						LCD_MeasureString(tmpbuf, &w, &h);
   25518:	a907      	add	r1, sp, #28
   2551a:	f10d 021e 	add.w	r2, sp, #30
   2551e:	a808      	add	r0, sp, #32
						tmpbuf[i] = 0x00;
   25520:	f808 3c80 	strb.w	r3, [r8, #-128]
						LCD_MeasureString(tmpbuf, &w, &h);
   25524:	f7fb fc76 	bl	20e14 <LCD_MeasureString>
						x = ((rect_w-2*offset_w)-w)/2;
   25528:	f8bd 001c 	ldrh.w	r0, [sp, #28]
						x += (rect_x+offset_w);
   2552c:	9b05      	ldr	r3, [sp, #20]
						x = ((rect_w-2*offset_w)-w)/2;
   2552e:	f1c0 00ac 	rsb	r0, r0, #172	; 0xac
   25532:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
						x += (rect_x+offset_w);
   25536:	eb03 0060 	add.w	r0, r3, r0, asr #1
						LCD_ShowString(x,y,tmpbuf);
   2553a:	4629      	mov	r1, r5
   2553c:	aa08      	add	r2, sp, #32
   2553e:	b280      	uxth	r0, r0
						y += line_h;
   25540:	443d      	add	r5, r7
						byte_no -= 2;
   25542:	b2b6      	uxth	r6, r6
						LCD_ShowString(x,y,tmpbuf);
   25544:	f7fb fc34 	bl	20db0 <LCD_ShowString>
						y += line_h;
   25548:	b2ad      	uxth	r5, r5
   2554a:	e7b5      	b.n	254b8 <NotifyScreenProcess+0xf4>
						if(byte_no < text_len)
   2554c:	4593      	cmp	fp, r2
   2554e:	d90d      	bls.n	2556c <NotifyScreenProcess+0x1a8>
							tmpbuf[i++] = notify_msg.text[byte_no++];
   25550:	f819 2b01 	ldrb.w	r2, [r9], #1
							LCD_MeasureString(tmpbuf, &w, &h);
   25554:	4618      	mov	r0, r3
							tmpbuf[i++] = notify_msg.text[byte_no++];
   25556:	f808 2003 	strb.w	r2, [r8, r3]
							LCD_MeasureString(tmpbuf, &w, &h);
   2555a:	a907      	add	r1, sp, #28
   2555c:	f10d 021e 	add.w	r2, sp, #30
   25560:	f7fb fc58 	bl	20e14 <LCD_MeasureString>
   25564:	f108 0801 	add.w	r8, r8, #1
   25568:	ab08      	add	r3, sp, #32
   2556a:	e7c5      	b.n	254f8 <NotifyScreenProcess+0x134>
						LCD_MeasureString(tmpbuf, &w, &h);
   2556c:	f10d 021e 	add.w	r2, sp, #30
   25570:	a907      	add	r1, sp, #28
   25572:	4650      	mov	r0, sl
   25574:	f7fb fc4e 	bl	20e14 <LCD_MeasureString>
						LCD_ShowString(x,y,tmpbuf);
   25578:	4652      	mov	r2, sl
   2557a:	4629      	mov	r1, r5
						x = ((rect_w-2*offset_w)-w)/2;
   2557c:	f8bd 001c 	ldrh.w	r0, [sp, #28]
						x += (rect_x+offset_w);
   25580:	3404      	adds	r4, #4
						x = ((rect_w-2*offset_w)-w)/2;
   25582:	f1c0 00ac 	rsb	r0, r0, #172	; 0xac
   25586:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
						x += (rect_x+offset_w);
   2558a:	eb04 0060 	add.w	r0, r4, r0, asr #1
						LCD_ShowString(x,y,tmpbuf);
   2558e:	b280      	uxth	r0, r0
				LCD_ShowString(x,y,notify_msg.text);				
   25590:	f7fb fc0e 	bl	20db0 <LCD_ShowString>
   25594:	e755      	b.n	25442 <NotifyScreenProcess+0x7e>
				y = (h > (rect_h-2*offset_h))? 0 : ((rect_h-2*offset_h)-h)/2;
   25596:	2f70      	cmp	r7, #112	; 0x70
				x = (w > (rect_w-2*offset_w))? 0 : ((rect_w-2*offset_w)-w)/2;
   25598:	f1c3 03ac 	rsb	r3, r3, #172	; 0xac
				y = (h > (rect_h-2*offset_h))? 0 : ((rect_h-2*offset_h)-h)/2;
   2559c:	bf98      	it	ls
   2559e:	f1c7 0670 	rsbls	r6, r7, #112	; 0x70
				x = (w > (rect_w-2*offset_w))? 0 : ((rect_w-2*offset_w)-w)/2;
   255a2:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
   255a6:	ea4f 0363 	mov.w	r3, r3, asr #1
				y = (h > (rect_h-2*offset_h))? 0 : ((rect_h-2*offset_h)-h)/2;
   255aa:	bf98      	it	ls
   255ac:	f3c6 064f 	ubfxls	r6, r6, #1, #16
				x += (rect_x+offset_w);
   255b0:	3404      	adds	r4, #4
				y += (rect_y+offset_h);
   255b2:	4446      	add	r6, r8
				x += (rect_x+offset_w);
   255b4:	4423      	add	r3, r4
				LCD_ShowString(x,y,notify_msg.text);				
   255b6:	4a0b      	ldr	r2, [pc, #44]	; (255e4 <NotifyScreenProcess+0x220>)
   255b8:	b2b1      	uxth	r1, r6
   255ba:	b298      	uxth	r0, r3
   255bc:	e7e8      	b.n	25590 <NotifyScreenProcess+0x1cc>
			y = (rect_y+offset_h);
   255be:	f108 0804 	add.w	r8, r8, #4
			x = (rect_x+offset_w);
   255c2:	1d20      	adds	r0, r4, #4
			LCD_ShowStringInRect(x, y, (rect_w-2*offset_w), (rect_h-2*offset_h), notify_msg.text);
   255c4:	9500      	str	r5, [sp, #0]
   255c6:	2370      	movs	r3, #112	; 0x70
   255c8:	22ac      	movs	r2, #172	; 0xac
   255ca:	fa1f f188 	uxth.w	r1, r8
   255ce:	b280      	uxth	r0, r0
   255d0:	f7fb fbb2 	bl	20d38 <LCD_ShowStringInRect>
			break;
   255d4:	e735      	b.n	25442 <NotifyScreenProcess+0x7e>
   255d6:	bf00      	nop
   255d8:	200249ec 	.word	0x200249ec
   255dc:	200348da 	.word	0x200348da
   255e0:	200348d8 	.word	0x200348d8
   255e4:	2002c331 	.word	0x2002c331
   255e8:	2002c32f 	.word	0x2002c32f

000255ec <EnterIdleScreen>:

void EnterIdleScreen(void)
{
	if(screen_id == SCREEN_ID_IDLE)
   255ec:	4907      	ldr	r1, [pc, #28]	; (2560c <EnterIdleScreen+0x20>)
   255ee:	780b      	ldrb	r3, [r1, #0]
   255f0:	2b01      	cmp	r3, #1
   255f2:	d00a      	beq.n	2560a <EnterIdleScreen+0x1e>
		return;
	
	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   255f4:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   255f6:	4a06      	ldr	r2, [pc, #24]	; (25610 <EnterIdleScreen+0x24>)
   255f8:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   255fa:	4a06      	ldr	r2, [pc, #24]	; (25614 <EnterIdleScreen+0x28>)
   255fc:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_IDLE;
   25600:	2301      	movs	r3, #1
   25602:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_IDLE].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_IDLE].status = SCREEN_STATUS_CREATING;
   25604:	f240 1301 	movw	r3, #257	; 0x101
   25608:	8113      	strh	r3, [r2, #8]
}
   2560a:	4770      	bx	lr
   2560c:	2002c382 	.word	0x2002c382
   25610:	2002c32e 	.word	0x2002c32e
   25614:	200249ec 	.word	0x200249ec

00025618 <EnterAlarmScreen>:

void EnterAlarmScreen(void)
{
	if(screen_id == SCREEN_ID_ALARM)
   25618:	4907      	ldr	r1, [pc, #28]	; (25638 <EnterAlarmScreen+0x20>)
   2561a:	780b      	ldrb	r3, [r1, #0]
   2561c:	2b02      	cmp	r3, #2
   2561e:	d00a      	beq.n	25636 <EnterAlarmScreen+0x1e>
		return;

	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   25620:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   25622:	4a06      	ldr	r2, [pc, #24]	; (2563c <EnterAlarmScreen+0x24>)
   25624:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   25626:	4a06      	ldr	r2, [pc, #24]	; (25640 <EnterAlarmScreen+0x28>)
   25628:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_ALARM;	
   2562c:	2302      	movs	r3, #2
   2562e:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_ALARM].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_ALARM].status = SCREEN_STATUS_CREATING;	
   25630:	f240 1301 	movw	r3, #257	; 0x101
   25634:	8213      	strh	r3, [r2, #16]
}
   25636:	4770      	bx	lr
   25638:	2002c382 	.word	0x2002c382
   2563c:	2002c32e 	.word	0x2002c32e
   25640:	200249ec 	.word	0x200249ec

00025644 <EnterFindDeviceScreen>:

void EnterFindDeviceScreen(void)
{
	if(screen_id == SCREEN_ID_FIND_DEVICE)
   25644:	4907      	ldr	r1, [pc, #28]	; (25664 <EnterFindDeviceScreen+0x20>)
   25646:	780b      	ldrb	r3, [r1, #0]
   25648:	2b03      	cmp	r3, #3
   2564a:	d00a      	beq.n	25662 <EnterFindDeviceScreen+0x1e>
		return;

	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   2564c:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   2564e:	4a06      	ldr	r2, [pc, #24]	; (25668 <EnterFindDeviceScreen+0x24>)
   25650:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   25652:	4a06      	ldr	r2, [pc, #24]	; (2566c <EnterFindDeviceScreen+0x28>)
   25654:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_FIND_DEVICE;	
   25658:	2303      	movs	r3, #3
   2565a:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_FIND_DEVICE].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_FIND_DEVICE].status = SCREEN_STATUS_CREATING;
   2565c:	f240 1301 	movw	r3, #257	; 0x101
   25660:	8313      	strh	r3, [r2, #24]
}
   25662:	4770      	bx	lr
   25664:	2002c382 	.word	0x2002c382
   25668:	2002c32e 	.word	0x2002c32e
   2566c:	200249ec 	.word	0x200249ec

00025670 <EnterGPSTestScreen>:

void EnterGPSTestScreen(void)
{
	if(screen_id == SCREEN_ID_GPS_TEST)
   25670:	4908      	ldr	r1, [pc, #32]	; (25694 <EnterGPSTestScreen+0x24>)
   25672:	780b      	ldrb	r3, [r1, #0]
   25674:	2b08      	cmp	r3, #8
   25676:	d00b      	beq.n	25690 <EnterGPSTestScreen+0x20>
		return;

	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   25678:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   2567a:	4a07      	ldr	r2, [pc, #28]	; (25698 <EnterGPSTestScreen+0x28>)
   2567c:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   2567e:	4a07      	ldr	r2, [pc, #28]	; (2569c <EnterGPSTestScreen+0x2c>)
   25680:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_GPS_TEST;	
   25684:	2308      	movs	r3, #8
   25686:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_GPS_TEST].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_GPS_TEST].status = SCREEN_STATUS_CREATING;	
   25688:	f240 1301 	movw	r3, #257	; 0x101
   2568c:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
}
   25690:	4770      	bx	lr
   25692:	bf00      	nop
   25694:	2002c382 	.word	0x2002c382
   25698:	2002c32e 	.word	0x2002c32e
   2569c:	200249ec 	.word	0x200249ec

000256a0 <EnterNBTestScreen>:

void EnterNBTestScreen(void)
{
	if(screen_id == SCREEN_ID_NB_TEST)
   256a0:	4908      	ldr	r1, [pc, #32]	; (256c4 <EnterNBTestScreen+0x24>)
   256a2:	780b      	ldrb	r3, [r1, #0]
   256a4:	2b09      	cmp	r3, #9
   256a6:	d00b      	beq.n	256c0 <EnterNBTestScreen+0x20>
		return;

	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   256a8:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   256aa:	4a07      	ldr	r2, [pc, #28]	; (256c8 <EnterNBTestScreen+0x28>)
   256ac:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   256ae:	4a07      	ldr	r2, [pc, #28]	; (256cc <EnterNBTestScreen+0x2c>)
   256b0:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_NB_TEST;	
   256b4:	2309      	movs	r3, #9
   256b6:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_NB_TEST].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_NB_TEST].status = SCREEN_STATUS_CREATING;		
   256b8:	f240 1301 	movw	r3, #257	; 0x101
   256bc:	f8a2 3048 	strh.w	r3, [r2, #72]	; 0x48
}
   256c0:	4770      	bx	lr
   256c2:	bf00      	nop
   256c4:	2002c382 	.word	0x2002c382
   256c8:	2002c32e 	.word	0x2002c32e
   256cc:	200249ec 	.word	0x200249ec

000256d0 <GoBackHistoryScreen>:
{
	SCREEN_ID_ENUM scr_id;
	
	scr_id = screen_id;
	scr_msg[scr_id].act = SCREEN_ACTION_NO;
	scr_msg[scr_id].status = SCREEN_STATUS_NO;
   256d0:	2000      	movs	r0, #0
	scr_id = screen_id;
   256d2:	4906      	ldr	r1, [pc, #24]	; (256ec <GoBackHistoryScreen+0x1c>)
	scr_msg[scr_id].status = SCREEN_STATUS_NO;
   256d4:	4b06      	ldr	r3, [pc, #24]	; (256f0 <GoBackHistoryScreen+0x20>)
	scr_msg[scr_id].act = SCREEN_ACTION_NO;
   256d6:	780a      	ldrb	r2, [r1, #0]
	scr_msg[scr_id].status = SCREEN_STATUS_NO;
   256d8:	f823 0032 	strh.w	r0, [r3, r2, lsl #3]

	screen_id = history_screen_id;
   256dc:	4a05      	ldr	r2, [pc, #20]	; (256f4 <GoBackHistoryScreen+0x24>)
   256de:	7812      	ldrb	r2, [r2, #0]
   256e0:	700a      	strb	r2, [r1, #0]
	scr_msg[history_screen_id].act = SCREEN_ACTION_ENTER;
	scr_msg[history_screen_id].status = SCREEN_STATUS_CREATING;	
   256e2:	f240 1101 	movw	r1, #257	; 0x101
   256e6:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
}
   256ea:	4770      	bx	lr
   256ec:	2002c382 	.word	0x2002c382
   256f0:	200249ec 	.word	0x200249ec
   256f4:	2002c32e 	.word	0x2002c32e

000256f8 <ExitNotifyScreen>:
{
   256f8:	b508      	push	{r3, lr}
	if(screen_id == SCREEN_ID_NOTIFY)
   256fa:	4b06      	ldr	r3, [pc, #24]	; (25714 <ExitNotifyScreen+0x1c>)
   256fc:	781b      	ldrb	r3, [r3, #0]
   256fe:	2b0a      	cmp	r3, #10
   25700:	d106      	bne.n	25710 <ExitNotifyScreen+0x18>
	z_impl_k_timer_stop(timer);
   25702:	4805      	ldr	r0, [pc, #20]	; (25718 <ExitNotifyScreen+0x20>)
   25704:	f018 ffff 	bl	3e706 <z_impl_k_timer_stop>
}
   25708:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		GoBackHistoryScreen();
   2570c:	f7ff bfe0 	b.w	256d0 <GoBackHistoryScreen>
}
   25710:	bd08      	pop	{r3, pc}
   25712:	bf00      	nop
   25714:	2002c382 	.word	0x2002c382
   25718:	20037a18 	.word	0x20037a18

0002571c <ScreenMsgProcess>:

void ScreenMsgProcess(void)
{
	if(scr_msg[screen_id].act != SCREEN_ACTION_NO)
   2571c:	4b0f      	ldr	r3, [pc, #60]	; (2575c <ScreenMsgProcess+0x40>)
   2571e:	4910      	ldr	r1, [pc, #64]	; (25760 <ScreenMsgProcess+0x44>)
   25720:	781b      	ldrb	r3, [r3, #0]
   25722:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
   25726:	7850      	ldrb	r0, [r2, #1]
   25728:	b1b8      	cbz	r0, 2575a <ScreenMsgProcess+0x3e>
	{
		if(scr_msg[screen_id].status != SCREEN_STATUS_CREATED)
   2572a:	f811 1033 	ldrb.w	r1, [r1, r3, lsl #3]
			scr_msg[screen_id].act = SCREEN_ACTION_ENTER;

		switch(screen_id)
   2572e:	3b01      	subs	r3, #1
		if(scr_msg[screen_id].status != SCREEN_STATUS_CREATED)
   25730:	2902      	cmp	r1, #2
			scr_msg[screen_id].act = SCREEN_ACTION_ENTER;
   25732:	bf1c      	itt	ne
   25734:	2101      	movne	r1, #1
   25736:	7051      	strbne	r1, [r2, #1]
		switch(screen_id)
   25738:	2b09      	cmp	r3, #9
   2573a:	d80e      	bhi.n	2575a <ScreenMsgProcess+0x3e>
   2573c:	e8df f003 	tbb	[pc, r3]
   25740:	0d090705 	.word	0x0d090705
   25744:	0d0d0d0d 	.word	0x0d0d0d0d
   25748:	0b0d      	.short	0x0b0d
		{
		case SCREEN_ID_IDLE:
			IdleScreenProcess();
   2574a:	f7ff bd13 	b.w	25174 <IdleScreenProcess>
			break;
		case SCREEN_ID_ALARM:
			AlarmScreenProcess();
   2574e:	f7ff bd5d 	b.w	2520c <AlarmScreenProcess>
			break;
		case SCREEN_ID_FIND_DEVICE:
			FindDeviceScreenProcess();
   25752:	f7ff bdc9 	b.w	252e8 <FindDeviceScreenProcess>
		case SCREEN_ID_GPS_TEST:
			break;
		case SCREEN_ID_NB_TEST:
			break;
		case SCREEN_ID_NOTIFY:
			NotifyScreenProcess();
   25756:	f7ff be35 	b.w	253c4 <NotifyScreenProcess>
			break;
		}
	}
}
   2575a:	4770      	bx	lr
   2575c:	2002c382 	.word	0x2002c382
   25760:	200249ec 	.word	0x200249ec

00025764 <pmu_battery_low_shutdown_timerout>:
	MAX20353_PowerOffConfig();
}

void pmu_battery_low_shutdown_timerout(void)
{
	sys_pwr_off = true;
   25764:	2201      	movs	r2, #1
   25766:	4b01      	ldr	r3, [pc, #4]	; (2576c <pmu_battery_low_shutdown_timerout+0x8>)
   25768:	701a      	strb	r2, [r3, #0]
}
   2576a:	4770      	bx	lr
   2576c:	2002c38a 	.word	0x2002c38a

00025770 <PmuInterruptHandle>:
	}while(!val);
}

void PmuInterruptHandle(void)
{
	pmu_trige_flag = true;
   25770:	2201      	movs	r2, #1
   25772:	4b01      	ldr	r3, [pc, #4]	; (25778 <PmuInterruptHandle+0x8>)
   25774:	701a      	strb	r2, [r3, #0]
}
   25776:	4770      	bx	lr
   25778:	2002c388 	.word	0x2002c388

0002577c <PmuAlertHandle>:
	MAX20353_SOCWriteReg(0x0C, 0x12, 0x5C);
}

void PmuAlertHandle(void)
{
	pmu_alert_flag = true;
   2577c:	2201      	movs	r2, #1
   2577e:	4b01      	ldr	r3, [pc, #4]	; (25784 <PmuAlertHandle+0x8>)
   25780:	701a      	strb	r2, [r3, #0]
}
   25782:	4770      	bx	lr
   25784:	2002c386 	.word	0x2002c386

00025788 <pmu_battery_stop_shutdown>:
{
   25788:	b508      	push	{r3, lr}
	const s32_t ticks = z_timeout_remaining(&timer->timeout);
   2578a:	4809      	ldr	r0, [pc, #36]	; (257b0 <pmu_battery_stop_shutdown+0x28>)
   2578c:	f012 fd66 	bl	3825c <z_timeout_remaining>
	return (ticks > 0) ? (u32_t)k_ticks_to_ms_floor64(ticks) : 0U;
   25790:	2800      	cmp	r0, #0
   25792:	dd0c      	ble.n	257ae <pmu_battery_stop_shutdown+0x26>
   25794:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   25798:	fb80 0103 	smull	r0, r1, r0, r3
   2579c:	0bc3      	lsrs	r3, r0, #15
	if(k_timer_remaining_get(&soc_pwroff) > 0)
   2579e:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
   257a2:	d004      	beq.n	257ae <pmu_battery_stop_shutdown+0x26>
}
   257a4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   257a8:	4801      	ldr	r0, [pc, #4]	; (257b0 <pmu_battery_stop_shutdown+0x28>)
   257aa:	f018 bfac 	b.w	3e706 <z_impl_k_timer_stop>
   257ae:	bd08      	pop	{r3, pc}
   257b0:	20024a70 	.word	0x20024a70

000257b4 <pmu_battery_low_shutdown>:
{
   257b4:	b510      	push	{r4, lr}
	k_timer_init(&soc_pwroff, pmu_battery_low_shutdown_timerout, NULL);
   257b6:	4c07      	ldr	r4, [pc, #28]	; (257d4 <pmu_battery_low_shutdown+0x20>)
   257b8:	2200      	movs	r2, #0
   257ba:	4907      	ldr	r1, [pc, #28]	; (257d8 <pmu_battery_low_shutdown+0x24>)
   257bc:	4620      	mov	r0, r4
   257be:	f018 ff96 	bl	3e6ee <k_timer_init>
	z_impl_k_timer_start(timer, duration, period);
   257c2:	2200      	movs	r2, #0
   257c4:	4620      	mov	r0, r4
}
   257c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   257ca:	f242 7110 	movw	r1, #10000	; 0x2710
   257ce:	f012 bf65 	b.w	3869c <z_impl_k_timer_start>
   257d2:	bf00      	nop
   257d4:	20024a70 	.word	0x20024a70
   257d8:	00025765 	.word	0x00025765

000257dc <pmu_interrupt_proc>:
{
   257dc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		LOG_INF("pmu_interrupt_proc REG_INT0:%02X\n", int0);
   257e0:	4b59      	ldr	r3, [pc, #356]	; (25948 <pmu_interrupt_proc+0x16c>)
   257e2:	4c5a      	ldr	r4, [pc, #360]	; (2594c <pmu_interrupt_proc+0x170>)
   257e4:	f8df 8184 	ldr.w	r8, [pc, #388]	; 2596c <pmu_interrupt_proc+0x190>
   257e8:	1ae4      	subs	r4, r4, r3
			LOG_INF("REG_STATUS0:%02X\n", status0);
   257ea:	f8df 9184 	ldr.w	r9, [pc, #388]	; 25970 <pmu_interrupt_proc+0x194>
			pmu_redraw_bat_flag = true;
   257ee:	4f58      	ldr	r7, [pc, #352]	; (25950 <pmu_interrupt_proc+0x174>)
		LOG_INF("pmu_interrupt_proc REG_INT0:%02X\n", int0);
   257f0:	f3c4 04c9 	ubfx	r4, r4, #3, #10
		MAX20353_ReadReg(REG_INT0, &int0);
   257f4:	a901      	add	r1, sp, #4
   257f6:	2003      	movs	r0, #3
   257f8:	f000 fc2c 	bl	26054 <MAX20353_ReadReg>
		LOG_INF("pmu_interrupt_proc REG_INT0:%02X\n", int0);
   257fc:	f025 033f 	bic.w	r3, r5, #63	; 0x3f
   25800:	f043 0303 	orr.w	r3, r3, #3
   25804:	f363 0507 	bfi	r5, r3, #0, #8
   25808:	f364 158f 	bfi	r5, r4, #6, #10
   2580c:	4628      	mov	r0, r5
   2580e:	f89d 2004 	ldrb.w	r2, [sp, #4]
   25812:	4641      	mov	r1, r8
   25814:	f016 ffe1 	bl	3c7da <log_string_sync>
		if((int0&0x40) == 0x40) //Charger status change INT  
   25818:	f89d 3004 	ldrb.w	r3, [sp, #4]
   2581c:	0658      	lsls	r0, r3, #25
   2581e:	d523      	bpl.n	25868 <pmu_interrupt_proc+0x8c>
			MAX20353_ReadReg(REG_STATUS0, &status0);
   25820:	f10d 0105 	add.w	r1, sp, #5
   25824:	2006      	movs	r0, #6
   25826:	f000 fc15 	bl	26054 <MAX20353_ReadReg>
			LOG_INF("REG_STATUS0:%02X\n", status0);
   2582a:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   2582e:	f043 0303 	orr.w	r3, r3, #3
   25832:	f363 0607 	bfi	r6, r3, #0, #8
   25836:	f364 168f 	bfi	r6, r4, #6, #10
   2583a:	f89d 2005 	ldrb.w	r2, [sp, #5]
   2583e:	4649      	mov	r1, r9
   25840:	4630      	mov	r0, r6
   25842:	f016 ffca 	bl	3c7da <log_string_sync>
			switch((status0&0x07))
   25846:	2201      	movs	r2, #1
   25848:	f89d 3005 	ldrb.w	r3, [sp, #5]
   2584c:	f003 0307 	and.w	r3, r3, #7
   25850:	fa02 f303 	lsl.w	r3, r2, r3
   25854:	f013 0f83 	tst.w	r3, #131	; 0x83
   25858:	d143      	bne.n	258e2 <pmu_interrupt_proc+0x106>
   2585a:	0659      	lsls	r1, r3, #25
   2585c:	d447      	bmi.n	258ee <pmu_interrupt_proc+0x112>
   2585e:	f013 0f3c 	tst.w	r3, #60	; 0x3c
   25862:	d142      	bne.n	258ea <pmu_interrupt_proc+0x10e>
			pmu_redraw_bat_flag = true;
   25864:	2301      	movs	r3, #1
   25866:	703b      	strb	r3, [r7, #0]
		if((int0&0x08) == 0x08) //USB OK Int
   25868:	f89d 3004 	ldrb.w	r3, [sp, #4]
   2586c:	071b      	lsls	r3, r3, #28
   2586e:	d51f      	bpl.n	258b0 <pmu_interrupt_proc+0xd4>
			MAX20353_ReadReg(REG_STATUS1, &status1);
   25870:	f10d 0106 	add.w	r1, sp, #6
   25874:	2007      	movs	r0, #7
   25876:	f000 fbed 	bl	26054 <MAX20353_ReadReg>
			if((status1&0x08) == 0x08) //USB OK   
   2587a:	f89d 3006 	ldrb.w	r3, [sp, #6]
   2587e:	4a35      	ldr	r2, [pc, #212]	; (25954 <pmu_interrupt_proc+0x178>)
   25880:	f013 0308 	ands.w	r3, r3, #8
   25884:	f8df b0dc 	ldr.w	fp, [pc, #220]	; 25964 <pmu_interrupt_proc+0x188>
   25888:	4933      	ldr	r1, [pc, #204]	; (25958 <pmu_interrupt_proc+0x17c>)
   2588a:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 25974 <pmu_interrupt_proc+0x198>
   2588e:	d033      	beq.n	258f8 <pmu_interrupt_proc+0x11c>
				pmu_battery_stop_shutdown();
   25890:	f7ff ff7a 	bl	25788 <pmu_battery_stop_shutdown>
				InitCharger();
   25894:	f000 fd58 	bl	26348 <InitCharger>
				charger_is_connected = true;
   25898:	2301      	movs	r3, #1
				g_chg_status = BAT_CHARGING_PROGRESS;
   2589a:	4a2e      	ldr	r2, [pc, #184]	; (25954 <pmu_interrupt_proc+0x178>)
				charger_is_connected = true;
   2589c:	492e      	ldr	r1, [pc, #184]	; (25958 <pmu_interrupt_proc+0x17c>)
				g_chg_status = BAT_CHARGING_PROGRESS;
   2589e:	7013      	strb	r3, [r2, #0]
				g_bat_level = BAT_LEVEL_NORMAL;
   258a0:	2202      	movs	r2, #2
				charger_is_connected = true;
   258a2:	700b      	strb	r3, [r1, #0]
				g_bat_level = BAT_LEVEL_NORMAL;
   258a4:	f88a 2000 	strb.w	r2, [sl]
				lcd_sleep_out = true;
   258a8:	f88b 3000 	strb.w	r3, [fp]
			pmu_redraw_bat_flag = true;
   258ac:	2301      	movs	r3, #1
   258ae:	703b      	strb	r3, [r7, #0]
		if(gpio_pin_read(gpio_pmu, PMU_EINT, &val))	//xb add 20201202 MCUPMU
   258b0:	4b2a      	ldr	r3, [pc, #168]	; (2595c <pmu_interrupt_proc+0x180>)
   258b2:	6818      	ldr	r0, [r3, #0]
	return api->read(port, access_op, pin, value);
   258b4:	6843      	ldr	r3, [r0, #4]
   258b6:	2208      	movs	r2, #8
   258b8:	f8d3 a008 	ldr.w	sl, [r3, #8]
   258bc:	2100      	movs	r1, #0
   258be:	f10d 0307 	add.w	r3, sp, #7
   258c2:	47d0      	blx	sl
   258c4:	2800      	cmp	r0, #0
   258c6:	d038      	beq.n	2593a <pmu_interrupt_proc+0x15e>
			LOG_INF("Cannot get pin");
   258c8:	f04f 0000 	mov.w	r0, #0
   258cc:	2303      	movs	r3, #3
   258ce:	f363 0007 	bfi	r0, r3, #0, #8
   258d2:	f364 108f 	bfi	r0, r4, #6, #10
   258d6:	4922      	ldr	r1, [pc, #136]	; (25960 <pmu_interrupt_proc+0x184>)
   258d8:	f016 ff7f 	bl	3c7da <log_string_sync>
}
   258dc:	b003      	add	sp, #12
   258de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				g_chg_status = BAT_CHARGING_NO;
   258e2:	2200      	movs	r2, #0
   258e4:	4b1b      	ldr	r3, [pc, #108]	; (25954 <pmu_interrupt_proc+0x178>)
				lcd_sleep_out = true;
   258e6:	701a      	strb	r2, [r3, #0]
				break;
   258e8:	e7bc      	b.n	25864 <pmu_interrupt_proc+0x88>
				g_chg_status = BAT_CHARGING_PROGRESS;
   258ea:	4b1a      	ldr	r3, [pc, #104]	; (25954 <pmu_interrupt_proc+0x178>)
   258ec:	e7fb      	b.n	258e6 <pmu_interrupt_proc+0x10a>
				g_chg_status = BAT_CHARGING_FINISHED;
   258ee:	2102      	movs	r1, #2
   258f0:	4b18      	ldr	r3, [pc, #96]	; (25954 <pmu_interrupt_proc+0x178>)
   258f2:	7019      	strb	r1, [r3, #0]
				lcd_sleep_out = true;
   258f4:	4b1b      	ldr	r3, [pc, #108]	; (25964 <pmu_interrupt_proc+0x188>)
   258f6:	e7f6      	b.n	258e6 <pmu_interrupt_proc+0x10a>
				g_chg_status = BAT_CHARGING_NO;
   258f8:	7013      	strb	r3, [r2, #0]
				charger_is_connected = false;
   258fa:	700b      	strb	r3, [r1, #0]
				g_bat_soc = MAX20353_CalculateSOC();
   258fc:	f000 fe2a 	bl	26554 <MAX20353_CalculateSOC>
   25900:	b2c0      	uxtb	r0, r0
				if(g_bat_soc>100)
   25902:	2864      	cmp	r0, #100	; 0x64
					g_bat_soc = 100;
   25904:	bf88      	it	hi
   25906:	2264      	movhi	r2, #100	; 0x64
   25908:	4b17      	ldr	r3, [pc, #92]	; (25968 <pmu_interrupt_proc+0x18c>)
				g_bat_soc = MAX20353_CalculateSOC();
   2590a:	bf94      	ite	ls
   2590c:	7018      	strbls	r0, [r3, #0]
					g_bat_soc = 100;
   2590e:	701a      	strbhi	r2, [r3, #0]
				if(g_bat_soc < 5)
   25910:	781b      	ldrb	r3, [r3, #0]
   25912:	2b04      	cmp	r3, #4
   25914:	d806      	bhi.n	25924 <pmu_interrupt_proc+0x148>
					g_bat_level = BAT_LEVEL_VERY_LOW;
   25916:	2300      	movs	r3, #0
   25918:	f88a 3000 	strb.w	r3, [sl]
					pmu_battery_low_shutdown();
   2591c:	f7ff ff4a 	bl	257b4 <pmu_battery_low_shutdown>
				lcd_sleep_out = true;
   25920:	2301      	movs	r3, #1
   25922:	e7c1      	b.n	258a8 <pmu_interrupt_proc+0xcc>
				else if(g_bat_soc < 20)
   25924:	2b13      	cmp	r3, #19
   25926:	d803      	bhi.n	25930 <pmu_interrupt_proc+0x154>
					g_bat_level = BAT_LEVEL_LOW;
   25928:	2301      	movs	r3, #1
					g_bat_level = BAT_LEVEL_GOOD;
   2592a:	f88a 3000 	strb.w	r3, [sl]
   2592e:	e7f7      	b.n	25920 <pmu_interrupt_proc+0x144>
				else if(g_bat_soc < 80)
   25930:	2b4f      	cmp	r3, #79	; 0x4f
					g_bat_level = BAT_LEVEL_NORMAL;
   25932:	bf94      	ite	ls
   25934:	2302      	movls	r3, #2
					g_bat_level = BAT_LEVEL_GOOD;
   25936:	2303      	movhi	r3, #3
   25938:	e7f7      	b.n	2592a <pmu_interrupt_proc+0x14e>
	}while(!val);
   2593a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   2593e:	2b00      	cmp	r3, #0
   25940:	f43f af58 	beq.w	257f4 <pmu_interrupt_proc+0x18>
   25944:	e7ca      	b.n	258dc <pmu_interrupt_proc+0x100>
   25946:	bf00      	nop
   25948:	0003f8d4 	.word	0x0003f8d4
   2594c:	0003f974 	.word	0x0003f974
   25950:	20037901 	.word	0x20037901
   25954:	2002c385 	.word	0x2002c385
   25958:	2002c383 	.word	0x2002c383
   2595c:	20024a5c 	.word	0x20024a5c
   25960:	000417f5 	.word	0x000417f5
   25964:	2002991f 	.word	0x2002991f
   25968:	2002c384 	.word	0x2002c384
   2596c:	000417c1 	.word	0x000417c1
   25970:	000417e3 	.word	0x000417e3
   25974:	20037900 	.word	0x20037900

00025978 <pmu_alert_proc>:
{
   25978:	b573      	push	{r0, r1, r4, r5, r6, lr}
	MAX20353_SOCReadReg(0x1A, &MSB, &LSB);
   2597a:	201a      	movs	r0, #26
   2597c:	f10d 0207 	add.w	r2, sp, #7
   25980:	f10d 0106 	add.w	r1, sp, #6
   25984:	f016 fbf8 	bl	3c178 <MAX20353_SOCReadReg>
	LOG_INF("pmu_alert_proc status:%02X\n", MSB);
   25988:	2303      	movs	r3, #3
   2598a:	f04f 0000 	mov.w	r0, #0
   2598e:	4c69      	ldr	r4, [pc, #420]	; (25b34 <pmu_alert_proc+0x1bc>)
   25990:	f363 0007 	bfi	r0, r3, #0, #8
   25994:	4b68      	ldr	r3, [pc, #416]	; (25b38 <pmu_alert_proc+0x1c0>)
   25996:	4969      	ldr	r1, [pc, #420]	; (25b3c <pmu_alert_proc+0x1c4>)
   25998:	1ae4      	subs	r4, r4, r3
   2599a:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   2599e:	f364 108f 	bfi	r0, r4, #6, #10
   259a2:	f89d 2006 	ldrb.w	r2, [sp, #6]
   259a6:	f016 ff18 	bl	3c7da <log_string_sync>
	if(MSB&0x40)
   259aa:	f89d 3006 	ldrb.w	r3, [sp, #6]
   259ae:	0659      	lsls	r1, r3, #25
   259b0:	d50d      	bpl.n	259ce <pmu_alert_proc+0x56>
		MSB = MSB&0xBF;
   259b2:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   259b6:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("voltage reset alert!\n");
   259ba:	f04f 0000 	mov.w	r0, #0
   259be:	2303      	movs	r3, #3
   259c0:	f363 0007 	bfi	r0, r3, #0, #8
   259c4:	f364 108f 	bfi	r0, r4, #6, #10
   259c8:	495d      	ldr	r1, [pc, #372]	; (25b40 <pmu_alert_proc+0x1c8>)
   259ca:	f016 ff06 	bl	3c7da <log_string_sync>
	if(MSB&0x20)
   259ce:	f89d 3006 	ldrb.w	r3, [sp, #6]
   259d2:	069a      	lsls	r2, r3, #26
   259d4:	d531      	bpl.n	25a3a <pmu_alert_proc+0xc2>
		MSB = MSB&0xDF;
   259d6:	f023 0320 	bic.w	r3, r3, #32
   259da:	f88d 3006 	strb.w	r3, [sp, #6]
		g_bat_soc = MAX20353_CalculateSOC();
   259de:	f000 fdb9 	bl	26554 <MAX20353_CalculateSOC>
   259e2:	b2c0      	uxtb	r0, r0
		if(g_bat_soc>100)
   259e4:	2864      	cmp	r0, #100	; 0x64
			g_bat_soc = 100;
   259e6:	bf88      	it	hi
   259e8:	2364      	movhi	r3, #100	; 0x64
   259ea:	4d56      	ldr	r5, [pc, #344]	; (25b44 <pmu_alert_proc+0x1cc>)
		LOG_INF("SOC:%d\n", g_bat_soc);
   259ec:	4956      	ldr	r1, [pc, #344]	; (25b48 <pmu_alert_proc+0x1d0>)
		g_bat_soc = MAX20353_CalculateSOC();
   259ee:	bf94      	ite	ls
   259f0:	7028      	strbls	r0, [r5, #0]
			g_bat_soc = 100;
   259f2:	702b      	strbhi	r3, [r5, #0]
		LOG_INF("SOC:%d\n", g_bat_soc);
   259f4:	f04f 0000 	mov.w	r0, #0
   259f8:	2303      	movs	r3, #3
   259fa:	f363 0007 	bfi	r0, r3, #0, #8
   259fe:	782a      	ldrb	r2, [r5, #0]
   25a00:	f364 108f 	bfi	r0, r4, #6, #10
   25a04:	f016 fee9 	bl	3c7da <log_string_sync>
		if(g_bat_soc < 5)
   25a08:	782b      	ldrb	r3, [r5, #0]
   25a0a:	4e50      	ldr	r6, [pc, #320]	; (25b4c <pmu_alert_proc+0x1d4>)
   25a0c:	2b04      	cmp	r3, #4
   25a0e:	4d50      	ldr	r5, [pc, #320]	; (25b50 <pmu_alert_proc+0x1d8>)
   25a10:	d87d      	bhi.n	25b0e <pmu_alert_proc+0x196>
			g_bat_level = BAT_LEVEL_VERY_LOW;
   25a12:	2300      	movs	r3, #0
   25a14:	702b      	strb	r3, [r5, #0]
			if(!charger_is_connected)
   25a16:	7833      	ldrb	r3, [r6, #0]
   25a18:	2b00      	cmp	r3, #0
   25a1a:	f040 8088 	bne.w	25b2e <pmu_alert_proc+0x1b6>
				DisplayPopUp("Battery voltage is very low, the system will shut down in a few seconds!");
   25a1e:	484d      	ldr	r0, [pc, #308]	; (25b54 <pmu_alert_proc+0x1dc>)
   25a20:	f7ff f912 	bl	24c48 <DisplayPopUp>
				pmu_battery_low_shutdown();
   25a24:	f7ff fec6 	bl	257b4 <pmu_battery_low_shutdown>
		if(charger_is_connected)
   25a28:	7833      	ldrb	r3, [r6, #0]
   25a2a:	2b00      	cmp	r3, #0
   25a2c:	d17f      	bne.n	25b2e <pmu_alert_proc+0x1b6>
		if(g_chg_status == BAT_CHARGING_NO)
   25a2e:	4b4a      	ldr	r3, [pc, #296]	; (25b58 <pmu_alert_proc+0x1e0>)
   25a30:	781b      	ldrb	r3, [r3, #0]
   25a32:	b913      	cbnz	r3, 25a3a <pmu_alert_proc+0xc2>
			pmu_redraw_bat_flag = true;
   25a34:	2201      	movs	r2, #1
   25a36:	4b49      	ldr	r3, [pc, #292]	; (25b5c <pmu_alert_proc+0x1e4>)
   25a38:	701a      	strb	r2, [r3, #0]
	if(MSB&0x10)
   25a3a:	f89d 3006 	ldrb.w	r3, [sp, #6]
   25a3e:	06de      	lsls	r6, r3, #27
   25a40:	d50d      	bpl.n	25a5e <pmu_alert_proc+0xe6>
		MSB = MSB&0xEF;
   25a42:	f023 0310 	bic.w	r3, r3, #16
   25a46:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("SOC low alert!\n");
   25a4a:	f04f 0000 	mov.w	r0, #0
   25a4e:	2303      	movs	r3, #3
   25a50:	f363 0007 	bfi	r0, r3, #0, #8
   25a54:	f364 108f 	bfi	r0, r4, #6, #10
   25a58:	4941      	ldr	r1, [pc, #260]	; (25b60 <pmu_alert_proc+0x1e8>)
   25a5a:	f016 febe 	bl	3c7da <log_string_sync>
	if(MSB&0x08)
   25a5e:	f89d 3006 	ldrb.w	r3, [sp, #6]
   25a62:	071d      	lsls	r5, r3, #28
   25a64:	d50d      	bpl.n	25a82 <pmu_alert_proc+0x10a>
		MSB = MSB&0xF7;
   25a66:	f023 0308 	bic.w	r3, r3, #8
   25a6a:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("voltage reset alert!\n");
   25a6e:	f04f 0000 	mov.w	r0, #0
   25a72:	2303      	movs	r3, #3
   25a74:	f363 0007 	bfi	r0, r3, #0, #8
   25a78:	f364 108f 	bfi	r0, r4, #6, #10
   25a7c:	4930      	ldr	r1, [pc, #192]	; (25b40 <pmu_alert_proc+0x1c8>)
   25a7e:	f016 feac 	bl	3c7da <log_string_sync>
	if(MSB&0x04)
   25a82:	f89d 3006 	ldrb.w	r3, [sp, #6]
   25a86:	0758      	lsls	r0, r3, #29
   25a88:	d50d      	bpl.n	25aa6 <pmu_alert_proc+0x12e>
		MSB = MSB&0xFB;
   25a8a:	f023 0304 	bic.w	r3, r3, #4
   25a8e:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("voltage low alert!\n");
   25a92:	f04f 0000 	mov.w	r0, #0
   25a96:	2303      	movs	r3, #3
   25a98:	f363 0007 	bfi	r0, r3, #0, #8
   25a9c:	f364 108f 	bfi	r0, r4, #6, #10
   25aa0:	4930      	ldr	r1, [pc, #192]	; (25b64 <pmu_alert_proc+0x1ec>)
   25aa2:	f016 fe9a 	bl	3c7da <log_string_sync>
	if(MSB&0x02)
   25aa6:	f89d 3006 	ldrb.w	r3, [sp, #6]
   25aaa:	0799      	lsls	r1, r3, #30
   25aac:	d50d      	bpl.n	25aca <pmu_alert_proc+0x152>
		MSB = MSB&0xFD;
   25aae:	f023 0302 	bic.w	r3, r3, #2
   25ab2:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("voltage high alert!\n");
   25ab6:	f04f 0000 	mov.w	r0, #0
   25aba:	2303      	movs	r3, #3
   25abc:	f363 0007 	bfi	r0, r3, #0, #8
   25ac0:	f364 108f 	bfi	r0, r4, #6, #10
   25ac4:	4928      	ldr	r1, [pc, #160]	; (25b68 <pmu_alert_proc+0x1f0>)
   25ac6:	f016 fe88 	bl	3c7da <log_string_sync>
	if(MSB&0x01)
   25aca:	f89d 3006 	ldrb.w	r3, [sp, #6]
   25ace:	07da      	lsls	r2, r3, #31
   25ad0:	d50f      	bpl.n	25af2 <pmu_alert_proc+0x17a>
		MSB = MSB&0xFE;
   25ad2:	f023 0301 	bic.w	r3, r3, #1
   25ad6:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("reset indicator alert!\n");
   25ada:	f04f 0000 	mov.w	r0, #0
   25ade:	2303      	movs	r3, #3
   25ae0:	f363 0007 	bfi	r0, r3, #0, #8
   25ae4:	f364 108f 	bfi	r0, r4, #6, #10
   25ae8:	4920      	ldr	r1, [pc, #128]	; (25b6c <pmu_alert_proc+0x1f4>)
   25aea:	f016 fe76 	bl	3c7da <log_string_sync>
		MAX20353_QuickStart();
   25aee:	f016 fb29 	bl	3c144 <MAX20353_QuickStart>
	MAX20353_SOCWriteReg(0x1A, MSB, LSB);
   25af2:	f89d 2007 	ldrb.w	r2, [sp, #7]
   25af6:	f89d 1006 	ldrb.w	r1, [sp, #6]
   25afa:	201a      	movs	r0, #26
   25afc:	f016 fb3e 	bl	3c17c <MAX20353_SOCWriteReg>
	MAX20353_SOCWriteReg(0x0C, 0x12, 0x5C);
   25b00:	225c      	movs	r2, #92	; 0x5c
   25b02:	2112      	movs	r1, #18
   25b04:	200c      	movs	r0, #12
   25b06:	f016 fb39 	bl	3c17c <MAX20353_SOCWriteReg>
}
   25b0a:	b002      	add	sp, #8
   25b0c:	bd70      	pop	{r4, r5, r6, pc}
		else if(g_bat_soc < 20)
   25b0e:	2b13      	cmp	r3, #19
   25b10:	d807      	bhi.n	25b22 <pmu_alert_proc+0x1aa>
			g_bat_level = BAT_LEVEL_LOW;
   25b12:	2201      	movs	r2, #1
   25b14:	7833      	ldrb	r3, [r6, #0]
   25b16:	702a      	strb	r2, [r5, #0]
			if(!charger_is_connected)
   25b18:	b94b      	cbnz	r3, 25b2e <pmu_alert_proc+0x1b6>
				DisplayPopUp("Battery voltage is low, please charge in time!");
   25b1a:	4815      	ldr	r0, [pc, #84]	; (25b70 <pmu_alert_proc+0x1f8>)
   25b1c:	f7ff f894 	bl	24c48 <DisplayPopUp>
   25b20:	e782      	b.n	25a28 <pmu_alert_proc+0xb0>
		else if(g_bat_soc < 80)
   25b22:	2b4f      	cmp	r3, #79	; 0x4f
			g_bat_level = BAT_LEVEL_NORMAL;
   25b24:	bf94      	ite	ls
   25b26:	2302      	movls	r3, #2
			g_bat_level = BAT_LEVEL_GOOD;
   25b28:	2303      	movhi	r3, #3
   25b2a:	702b      	strb	r3, [r5, #0]
   25b2c:	e77c      	b.n	25a28 <pmu_alert_proc+0xb0>
			g_bat_level = BAT_LEVEL_NORMAL;
   25b2e:	2302      	movs	r3, #2
   25b30:	702b      	strb	r3, [r5, #0]
   25b32:	e77c      	b.n	25a2e <pmu_alert_proc+0xb6>
   25b34:	0003f974 	.word	0x0003f974
   25b38:	0003f8d4 	.word	0x0003f8d4
   25b3c:	000416b4 	.word	0x000416b4
   25b40:	000416d0 	.word	0x000416d0
   25b44:	2002c384 	.word	0x2002c384
   25b48:	000416e6 	.word	0x000416e6
   25b4c:	2002c383 	.word	0x2002c383
   25b50:	20037900 	.word	0x20037900
   25b54:	000416ee 	.word	0x000416ee
   25b58:	2002c385 	.word	0x2002c385
   25b5c:	20037901 	.word	0x20037901
   25b60:	00041766 	.word	0x00041766
   25b64:	00041776 	.word	0x00041776
   25b68:	0004178a 	.word	0x0004178a
   25b6c:	0004179f 	.word	0x0004179f
   25b70:	00041737 	.word	0x00041737

00025b74 <MAX20353_InitData>:

void MAX20353_InitData(void)
{
   25b74:	b508      	push	{r3, lr}
	pmu_interrupt_proc();
   25b76:	f7ff fe31 	bl	257dc <pmu_interrupt_proc>
	
	g_bat_soc = MAX20353_CalculateSOC();
   25b7a:	f000 fceb 	bl	26554 <MAX20353_CalculateSOC>
   25b7e:	b2c0      	uxtb	r0, r0
	if(g_bat_soc>100)
   25b80:	2864      	cmp	r0, #100	; 0x64
		g_bat_soc = 100;
   25b82:	bf88      	it	hi
   25b84:	2264      	movhi	r2, #100	; 0x64
   25b86:	4b02      	ldr	r3, [pc, #8]	; (25b90 <MAX20353_InitData+0x1c>)
	g_bat_soc = MAX20353_CalculateSOC();
   25b88:	bf94      	ite	ls
   25b8a:	7018      	strbls	r0, [r3, #0]
		g_bat_soc = 100;
   25b8c:	701a      	strbhi	r2, [r3, #0]

	//test_soc();
}
   25b8e:	bd08      	pop	{r3, pc}
   25b90:	2002c384 	.word	0x2002c384

00025b94 <pmu_init>:
void pmu_init(void)
{
	bool rst;
	int flag = GPIO_DIR_IN|GPIO_INT|GPIO_INT_EDGE|GPIO_PUD_PULL_UP|GPIO_INT_ACTIVE_LOW|GPIO_INT_DEBOUNCE;

	LOG_INF("pmu_init\n");
   25b94:	2303      	movs	r3, #3
   25b96:	f04f 0000 	mov.w	r0, #0
{
   25b9a:	b570      	push	{r4, r5, r6, lr}
	LOG_INF("pmu_init\n");
   25b9c:	f363 0007 	bfi	r0, r3, #0, #8
   25ba0:	4d35      	ldr	r5, [pc, #212]	; (25c78 <pmu_init+0xe4>)
   25ba2:	4b36      	ldr	r3, [pc, #216]	; (25c7c <pmu_init+0xe8>)
   25ba4:	4936      	ldr	r1, [pc, #216]	; (25c80 <pmu_init+0xec>)
   25ba6:	1aed      	subs	r5, r5, r3
   25ba8:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   25bac:	f365 108f 	bfi	r0, r5, #6, #10
   25bb0:	f016 fe13 	bl	3c7da <log_string_sync>
   25bb4:	4833      	ldr	r0, [pc, #204]	; (25c84 <pmu_init+0xf0>)
   25bb6:	f00f fd33 	bl	35620 <z_impl_device_get_binding>

  	//
  	gpio_pmu = device_get_binding(PMU_PORT);
   25bba:	4c33      	ldr	r4, [pc, #204]	; (25c88 <pmu_init+0xf4>)
   25bbc:	6020      	str	r0, [r4, #0]
	if(!gpio_pmu)
   25bbe:	b958      	cbnz	r0, 25bd8 <pmu_init+0x44>
	{
		LOG_INF("Cannot bind gpio device\n");
   25bc0:	f04f 0000 	mov.w	r0, #0
   25bc4:	2303      	movs	r3, #3
   25bc6:	4931      	ldr	r1, [pc, #196]	; (25c8c <pmu_init+0xf8>)
   25bc8:	f363 0007 	bfi	r0, r3, #0, #8
   25bcc:	f365 108f 	bfi	r0, r5, #6, #10
	pmu_dev_ctx.read_reg  = platform_read;
	pmu_dev_ctx.handle    = i2c_pmu;

	MAX20353_Init();
	MAX20353_InitData();
}
   25bd0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LOG_INF("ERROR SETTING UP I2C\r\n");
   25bd4:	f016 be01 	b.w	3c7da <log_string_sync>
	return api->config(port, access_op, pin, flags);
   25bd8:	6843      	ldr	r3, [r0, #4]
   25bda:	2208      	movs	r2, #8
   25bdc:	681e      	ldr	r6, [r3, #0]
   25bde:	2100      	movs	r1, #0
   25be0:	f44f 7399 	mov.w	r3, #306	; 0x132
   25be4:	47b0      	blx	r6
	gpio_pin_disable_callback(gpio_pmu, PMU_EINT);
   25be6:	2108      	movs	r1, #8
   25be8:	6820      	ldr	r0, [r4, #0]
   25bea:	f016 fa03 	bl	3bff4 <gpio_pin_disable_callback>
	callback->handler = handler;
   25bee:	4928      	ldr	r1, [pc, #160]	; (25c90 <pmu_init+0xfc>)
   25bf0:	4b28      	ldr	r3, [pc, #160]	; (25c94 <pmu_init+0x100>)
	gpio_add_callback(gpio_pmu, &gpio_cb1);
   25bf2:	6820      	ldr	r0, [r4, #0]
   25bf4:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
   25bf6:	f44f 7380 	mov.w	r3, #256	; 0x100
   25bfa:	608b      	str	r3, [r1, #8]
   25bfc:	f016 f9f2 	bl	3bfe4 <gpio_add_callback>
	gpio_pin_enable_callback(gpio_pmu, PMU_EINT);
   25c00:	2108      	movs	r1, #8
   25c02:	6820      	ldr	r0, [r4, #0]
   25c04:	f016 f9ff 	bl	3c006 <gpio_pin_enable_callback>
	gpio_pin_configure(gpio_pmu, PMU_ALRTB, flag);
   25c08:	6820      	ldr	r0, [r4, #0]
	return api->config(port, access_op, pin, flags);
   25c0a:	6843      	ldr	r3, [r0, #4]
   25c0c:	2207      	movs	r2, #7
   25c0e:	681e      	ldr	r6, [r3, #0]
   25c10:	2100      	movs	r1, #0
   25c12:	f44f 7399 	mov.w	r3, #306	; 0x132
   25c16:	47b0      	blx	r6
	gpio_pin_disable_callback(gpio_pmu, PMU_ALRTB);
   25c18:	2107      	movs	r1, #7
   25c1a:	6820      	ldr	r0, [r4, #0]
   25c1c:	f016 f9ea 	bl	3bff4 <gpio_pin_disable_callback>
	callback->handler = handler;
   25c20:	491d      	ldr	r1, [pc, #116]	; (25c98 <pmu_init+0x104>)
   25c22:	4b1e      	ldr	r3, [pc, #120]	; (25c9c <pmu_init+0x108>)
	gpio_add_callback(gpio_pmu, &gpio_cb2);
   25c24:	6820      	ldr	r0, [r4, #0]
   25c26:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
   25c28:	2380      	movs	r3, #128	; 0x80
   25c2a:	608b      	str	r3, [r1, #8]
   25c2c:	f016 f9da 	bl	3bfe4 <gpio_add_callback>
	gpio_pin_enable_callback(gpio_pmu, PMU_ALRTB);
   25c30:	2107      	movs	r1, #7
   25c32:	6820      	ldr	r0, [r4, #0]
   25c34:	f016 f9e7 	bl	3c006 <gpio_pin_enable_callback>
   25c38:	4819      	ldr	r0, [pc, #100]	; (25ca0 <pmu_init+0x10c>)
   25c3a:	f00f fcf1 	bl	35620 <z_impl_device_get_binding>
	i2c_pmu = device_get_binding(PMU_DEV);
   25c3e:	4c19      	ldr	r4, [pc, #100]	; (25ca4 <pmu_init+0x110>)
   25c40:	6020      	str	r0, [r4, #0]
	if(!i2c_pmu)
   25c42:	b940      	cbnz	r0, 25c56 <pmu_init+0xc2>
		LOG_INF("ERROR SETTING UP I2C\r\n");
   25c44:	f04f 0000 	mov.w	r0, #0
   25c48:	2303      	movs	r3, #3
   25c4a:	f363 0007 	bfi	r0, r3, #0, #8
   25c4e:	f365 108f 	bfi	r0, r5, #6, #10
   25c52:	4915      	ldr	r1, [pc, #84]	; (25ca8 <pmu_init+0x114>)
   25c54:	e7bc      	b.n	25bd0 <pmu_init+0x3c>
   25c56:	6843      	ldr	r3, [r0, #4]
   25c58:	2104      	movs	r1, #4
   25c5a:	681b      	ldr	r3, [r3, #0]
   25c5c:	4798      	blx	r3
	pmu_dev_ctx.write_reg = platform_write;
   25c5e:	4b13      	ldr	r3, [pc, #76]	; (25cac <pmu_init+0x118>)
   25c60:	4a13      	ldr	r2, [pc, #76]	; (25cb0 <pmu_init+0x11c>)
   25c62:	601a      	str	r2, [r3, #0]
	pmu_dev_ctx.read_reg  = platform_read;
   25c64:	4a13      	ldr	r2, [pc, #76]	; (25cb4 <pmu_init+0x120>)
   25c66:	605a      	str	r2, [r3, #4]
	pmu_dev_ctx.handle    = i2c_pmu;
   25c68:	6822      	ldr	r2, [r4, #0]
   25c6a:	609a      	str	r2, [r3, #8]
	MAX20353_Init();
   25c6c:	f000 fd08 	bl	26680 <MAX20353_Init>
}
   25c70:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	MAX20353_InitData();
   25c74:	f7ff bf7e 	b.w	25b74 <MAX20353_InitData>
   25c78:	0003f974 	.word	0x0003f974
   25c7c:	0003f8d4 	.word	0x0003f8d4
   25c80:	000417b7 	.word	0x000417b7
   25c84:	0004053a 	.word	0x0004053a
   25c88:	20024a5c 	.word	0x20024a5c
   25c8c:	00040541 	.word	0x00040541
   25c90:	20024a44 	.word	0x20024a44
   25c94:	00025771 	.word	0x00025771
   25c98:	20024a50 	.word	0x20024a50
   25c9c:	0002577d 	.word	0x0002577d
   25ca0:	0004156e 	.word	0x0004156e
   25ca4:	20024a60 	.word	0x20024a60
   25ca8:	00041574 	.word	0x00041574
   25cac:	20024a64 	.word	0x20024a64
   25cb0:	0003c019 	.word	0x0003c019
   25cb4:	0003c05f 	.word	0x0003c05f

00025cb8 <test_soc_status>:
	ret |= MAX20353_ReadReg(REG_SYSTEM_ERROR, &buf_results[4]);
	return ret;
}

void test_soc_status(void)
{
   25cb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   25cbc:	ed2d 8b02 	vpush	{d8}
	u8_t MSB,LSB;
	u8_t RCOMP,Status0,Status1,Status2,Status3;
	u16_t VCell,SOC,CRate,MODE,Version,HIBRT,Config,Status,VALRT,VReset,CMD,OCV;
	u8_t strbuf[512] = {0};
   25cc0:	f44f 7b00 	mov.w	fp, #512	; 0x200
{
   25cc4:	f5ad 7d21 	sub.w	sp, sp, #644	; 0x284
	u8_t strbuf[512] = {0};
   25cc8:	465a      	mov	r2, fp
   25cca:	2100      	movs	r1, #0
   25ccc:	a820      	add	r0, sp, #128	; 0x80
   25cce:	f018 fddd 	bl	3e88c <memset>
	
	MAX20353_SOCReadReg(0x02, &MSB, &LSB);//vcell
   25cd2:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   25cd6:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
   25cda:	2002      	movs	r0, #2
   25cdc:	f016 fa4c 	bl	3c178 <MAX20353_SOCReadReg>
	VCell = ((MSB<<8)+LSB);
   25ce0:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   25ce4:	f89d 307e 	ldrb.w	r3, [sp, #126]	; 0x7e
	VCell = VCell*625/8/1000;
	
	MAX20353_SOCReadReg(0x04, &MSB, &LSB);//soc
   25ce8:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	VCell = ((MSB<<8)+LSB);
   25cec:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	VCell = VCell*625/8/1000;
   25cf0:	f240 2271 	movw	r2, #625	; 0x271
   25cf4:	b29b      	uxth	r3, r3
   25cf6:	4353      	muls	r3, r2
   25cf8:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
   25cfc:	fbb3 f3f2 	udiv	r3, r3, r2
	MAX20353_SOCReadReg(0x04, &MSB, &LSB);//soc
   25d00:	2004      	movs	r0, #4
   25d02:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
	VCell = VCell*625/8/1000;
   25d06:	9319      	str	r3, [sp, #100]	; 0x64
	MAX20353_SOCReadReg(0x04, &MSB, &LSB);//soc
   25d08:	f016 fa36 	bl	3c178 <MAX20353_SOCReadReg>
	SOC = ((MSB<<8)+LSB);
   25d0c:	f89d 307d 	ldrb.w	r3, [sp, #125]	; 0x7d
   25d10:	f89d 007e 	ldrb.w	r0, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x0C, &MSB, &LSB);//Config RCOMP(MSB)
   25d14:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
	SOC = ((MSB<<8)+LSB);
   25d18:	eb00 2003 	add.w	r0, r0, r3, lsl #8
   25d1c:	b283      	uxth	r3, r0
	MAX20353_SOCReadReg(0x0C, &MSB, &LSB);//Config RCOMP(MSB)
   25d1e:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
   25d22:	200c      	movs	r0, #12
	SOC = ((MSB<<8)+LSB);
   25d24:	ee08 3a10 	vmov	s16, r3
	MAX20353_SOCReadReg(0x0C, &MSB, &LSB);//Config RCOMP(MSB)
   25d28:	f016 fa26 	bl	3c178 <MAX20353_SOCReadReg>
	RCOMP = MSB;
	Config = ((MSB<<8)+LSB);
   25d2c:	f89d 307d 	ldrb.w	r3, [sp, #125]	; 0x7d
   25d30:	f89d 607e 	ldrb.w	r6, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x16, &MSB, &LSB);//CRate
   25d34:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   25d38:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
   25d3c:	2016      	movs	r0, #22
	Config = ((MSB<<8)+LSB);
   25d3e:	eb06 2603 	add.w	r6, r6, r3, lsl #8
   25d42:	931d      	str	r3, [sp, #116]	; 0x74
	MAX20353_SOCReadReg(0x16, &MSB, &LSB);//CRate
   25d44:	f016 fa18 	bl	3c178 <MAX20353_SOCReadReg>
	CRate = ((MSB<<8)+LSB);
   25d48:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   25d4c:	f89d 407e 	ldrb.w	r4, [sp, #126]	; 0x7e
	if(CRate&0x8000==0x8000)
		CRate |= 0xFFFF0000;
	CRate = CRate*208;
	
	MAX20353_SOCReadReg(0x06, &MSB, &LSB);//MODE
   25d50:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	CRate = ((MSB<<8)+LSB);
   25d54:	eb04 2402 	add.w	r4, r4, r2, lsl #8
	MAX20353_SOCReadReg(0x06, &MSB, &LSB);//MODE
   25d58:	2006      	movs	r0, #6
   25d5a:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   25d5e:	f016 fa0b 	bl	3c178 <MAX20353_SOCReadReg>
	MODE = ((MSB<<8)+LSB);
   25d62:	f89d 107d 	ldrb.w	r1, [sp, #125]	; 0x7d
   25d66:	f89d 207e 	ldrb.w	r2, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x08, &MSB, &LSB);//Version
   25d6a:	2008      	movs	r0, #8
	MODE = ((MSB<<8)+LSB);
   25d6c:	eb02 2201 	add.w	r2, r2, r1, lsl #8
   25d70:	b293      	uxth	r3, r2
	MAX20353_SOCReadReg(0x08, &MSB, &LSB);//Version
   25d72:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
   25d76:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
	MODE = ((MSB<<8)+LSB);
   25d7a:	931a      	str	r3, [sp, #104]	; 0x68
	MAX20353_SOCReadReg(0x08, &MSB, &LSB);//Version
   25d7c:	f016 f9fc 	bl	3c178 <MAX20353_SOCReadReg>
	Version = ((MSB<<8)+LSB);
   25d80:	f89d 107d 	ldrb.w	r1, [sp, #125]	; 0x7d
   25d84:	f89d 207e 	ldrb.w	r2, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x0A, &MSB, &LSB);//HIBRT
   25d88:	200a      	movs	r0, #10
	Version = ((MSB<<8)+LSB);
   25d8a:	eb02 2201 	add.w	r2, r2, r1, lsl #8
   25d8e:	b293      	uxth	r3, r2
	MAX20353_SOCReadReg(0x0A, &MSB, &LSB);//HIBRT
   25d90:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
   25d94:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
	Version = ((MSB<<8)+LSB);
   25d98:	931b      	str	r3, [sp, #108]	; 0x6c
	MAX20353_SOCReadReg(0x0A, &MSB, &LSB);//HIBRT
   25d9a:	f016 f9ed 	bl	3c178 <MAX20353_SOCReadReg>
	HIBRT = ((MSB<<8)+LSB);
   25d9e:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   25da2:	f89d 507e 	ldrb.w	r5, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x1A, &MSB, &LSB);//Status
   25da6:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	HIBRT = ((MSB<<8)+LSB);
   25daa:	eb05 2502 	add.w	r5, r5, r2, lsl #8
	MAX20353_SOCReadReg(0x1A, &MSB, &LSB);//Status
   25dae:	201a      	movs	r0, #26
   25db0:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   25db4:	f016 f9e0 	bl	3c178 <MAX20353_SOCReadReg>
	Status = ((MSB<<8)+LSB);
   25db8:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   25dbc:	f89d 707e 	ldrb.w	r7, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x14, &MSB, &LSB);//VALRT
   25dc0:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	Status = ((MSB<<8)+LSB);
   25dc4:	eb07 2702 	add.w	r7, r7, r2, lsl #8
	MAX20353_SOCReadReg(0x14, &MSB, &LSB);//VALRT
   25dc8:	2014      	movs	r0, #20
   25dca:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   25dce:	f016 f9d3 	bl	3c178 <MAX20353_SOCReadReg>
	VALRT = ((MSB<<8)+LSB);
   25dd2:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   25dd6:	f89d 807e 	ldrb.w	r8, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x18, &MSB, &LSB);//VReset
   25dda:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	VALRT = ((MSB<<8)+LSB);
   25dde:	eb08 2802 	add.w	r8, r8, r2, lsl #8
	MAX20353_SOCReadReg(0x18, &MSB, &LSB);//VReset
   25de2:	2018      	movs	r0, #24
   25de4:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   25de8:	f016 f9c6 	bl	3c178 <MAX20353_SOCReadReg>
	VReset = ((MSB<<8)+LSB);
   25dec:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   25df0:	f89d 907e 	ldrb.w	r9, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0xFE, &MSB, &LSB);//CMD
   25df4:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	VReset = ((MSB<<8)+LSB);
   25df8:	eb09 2902 	add.w	r9, r9, r2, lsl #8
	MAX20353_SOCReadReg(0xFE, &MSB, &LSB);//CMD
   25dfc:	20fe      	movs	r0, #254	; 0xfe
   25dfe:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   25e02:	f016 f9b9 	bl	3c178 <MAX20353_SOCReadReg>
	CMD = ((MSB<<8)+LSB);
   25e06:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   25e0a:	f89d a07e 	ldrb.w	sl, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x0E, &MSB, &LSB);//OCV
   25e0e:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	CMD = ((MSB<<8)+LSB);
   25e12:	eb0a 2a02 	add.w	sl, sl, r2, lsl #8
	MAX20353_SOCReadReg(0x0E, &MSB, &LSB);//OCV
   25e16:	200e      	movs	r0, #14
   25e18:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   25e1c:	f016 f9ac 	bl	3c178 <MAX20353_SOCReadReg>
	OCV = ((MSB<<8)+LSB);
   25e20:	f89d 107d 	ldrb.w	r1, [sp, #125]	; 0x7d
   25e24:	f89d 207e 	ldrb.w	r2, [sp, #126]	; 0x7e

	MAX20353_ReadReg(REG_STATUS0, &Status0);
   25e28:	2006      	movs	r0, #6
	OCV = ((MSB<<8)+LSB);
   25e2a:	eb02 2201 	add.w	r2, r2, r1, lsl #8
   25e2e:	b292      	uxth	r2, r2
	MAX20353_ReadReg(REG_STATUS0, &Status0);
   25e30:	f10d 017f 	add.w	r1, sp, #127	; 0x7f
	OCV = ((MSB<<8)+LSB);
   25e34:	921c      	str	r2, [sp, #112]	; 0x70
	MAX20353_ReadReg(REG_STATUS0, &Status0);
   25e36:	f000 f90d 	bl	26054 <MAX20353_ReadReg>
	Status0 = Status0&0x07;
	
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   25e3a:	9a1c      	ldr	r2, [sp, #112]	; 0x70
	CRate = ((MSB<<8)+LSB);
   25e3c:	b2a4      	uxth	r4, r4
	CMD = ((MSB<<8)+LSB);
   25e3e:	fa1f fa8a 	uxth.w	sl, sl
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   25e42:	e9cd a215 	strd	sl, r2, [sp, #84]	; 0x54
	CRate = CRate*208;
   25e46:	eb04 0244 	add.w	r2, r4, r4, lsl #1
   25e4a:	eb04 0482 	add.w	r4, r4, r2, lsl #2
   25e4e:	0124      	lsls	r4, r4, #4
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   25e50:	b2a4      	uxth	r4, r4
   25e52:	ee07 4a90 	vmov	s15, r4
   25e56:	eddf 8a35 	vldr	s17, [pc, #212]	; 25f2c <test_soc_status+0x274>
   25e5a:	eef8 7a67 	vcvt.f32.u32	s15, s15
   25e5e:	ee87 7aa8 	vdiv.f32	s14, s15, s17
   25e62:	eddf 7a33 	vldr	s15, [pc, #204]	; 25f30 <test_soc_status+0x278>
   25e66:	eec7 7a27 	vdiv.f32	s15, s14, s15
   25e6a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
	Status0 = Status0&0x07;
   25e6c:	f89d 107f 	ldrb.w	r1, [sp, #127]	; 0x7f
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   25e70:	930f      	str	r3, [sp, #60]	; 0x3c
   25e72:	9b1a      	ldr	r3, [sp, #104]	; 0x68
	Status0 = Status0&0x07;
   25e74:	f001 0107 	and.w	r1, r1, #7
	Config = ((MSB<<8)+LSB);
   25e78:	b2b6      	uxth	r6, r6
	HIBRT = ((MSB<<8)+LSB);
   25e7a:	b2ad      	uxth	r5, r5
	Status = ((MSB<<8)+LSB);
   25e7c:	b2bf      	uxth	r7, r7
	VALRT = ((MSB<<8)+LSB);
   25e7e:	fa1f f888 	uxth.w	r8, r8
	VReset = ((MSB<<8)+LSB);
   25e82:	fa1f f989 	uxth.w	r9, r9
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   25e86:	ee17 0a90 	vmov	r0, s15
   25e8a:	930e      	str	r3, [sp, #56]	; 0x38
	Status0 = Status0&0x07;
   25e8c:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   25e90:	9117      	str	r1, [sp, #92]	; 0x5c
   25e92:	e9cd 8913 	strd	r8, r9, [sp, #76]	; 0x4c
   25e96:	e9cd 6711 	strd	r6, r7, [sp, #68]	; 0x44
   25e9a:	9510      	str	r5, [sp, #64]	; 0x40
   25e9c:	f7f6 fc34 	bl	1c708 <__aeabi_f2d>
   25ea0:	eef8 7a48 	vcvt.f32.u32	s15, s16
   25ea4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   25ea6:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   25eaa:	ee17 0a90 	vmov	r0, s15
   25eae:	930a      	str	r3, [sp, #40]	; 0x28
   25eb0:	f7f6 fc2a 	bl	1c708 <__aeabi_f2d>
   25eb4:	2200      	movs	r2, #0
   25eb6:	4b1f      	ldr	r3, [pc, #124]	; (25f34 <test_soc_status+0x27c>)
   25eb8:	f7f6 fc7e 	bl	1c7b8 <__aeabi_dmul>
   25ebc:	f8bd 3064 	ldrh.w	r3, [sp, #100]	; 0x64
   25ec0:	e9cd 0108 	strd	r0, r1, [sp, #32]
   25ec4:	ee07 3a90 	vmov	s15, r3
   25ec8:	eef8 7a67 	vcvt.f32.u32	s15, s15
   25ecc:	eec7 7aa8 	vdiv.f32	s15, s15, s17
   25ed0:	ee17 0a90 	vmov	r0, s15
   25ed4:	f7f6 fc18 	bl	1c708 <__aeabi_f2d>
   25ed8:	e9cd 0106 	strd	r0, r1, [sp, #24]
   25edc:	4b16      	ldr	r3, [pc, #88]	; (25f38 <test_soc_status+0x280>)
   25ede:	2100      	movs	r1, #0
   25ee0:	799a      	ldrb	r2, [r3, #6]
   25ee2:	a820      	add	r0, sp, #128	; 0x80
   25ee4:	9205      	str	r2, [sp, #20]
   25ee6:	795a      	ldrb	r2, [r3, #5]
   25ee8:	9204      	str	r2, [sp, #16]
   25eea:	791a      	ldrb	r2, [r3, #4]
   25eec:	9203      	str	r2, [sp, #12]
   25eee:	881a      	ldrh	r2, [r3, #0]
   25ef0:	9202      	str	r2, [sp, #8]
   25ef2:	789a      	ldrb	r2, [r3, #2]
   25ef4:	9201      	str	r2, [sp, #4]
   25ef6:	78db      	ldrb	r3, [r3, #3]
   25ef8:	465a      	mov	r2, fp
   25efa:	9300      	str	r3, [sp, #0]
   25efc:	4b0f      	ldr	r3, [pc, #60]	; (25f3c <test_soc_status+0x284>)
   25efe:	f018 fe07 	bl	3eb10 <__sprintf_chk>
				(float)VCell/1000, (float)SOC/256.0,
				RCOMP,
				(float)CRate/1000/100,
				MODE, Version, HIBRT, Config, Status, VALRT, VReset, CMD, OCV, Status0);

	LOG_INF("%s", strbuf);
   25f02:	2303      	movs	r3, #3
   25f04:	f04f 0000 	mov.w	r0, #0
   25f08:	4a0d      	ldr	r2, [pc, #52]	; (25f40 <test_soc_status+0x288>)
   25f0a:	f363 0007 	bfi	r0, r3, #0, #8
   25f0e:	4b0d      	ldr	r3, [pc, #52]	; (25f44 <test_soc_status+0x28c>)
   25f10:	490d      	ldr	r1, [pc, #52]	; (25f48 <test_soc_status+0x290>)
   25f12:	1a9b      	subs	r3, r3, r2
   25f14:	08db      	lsrs	r3, r3, #3
   25f16:	f363 108f 	bfi	r0, r3, #6, #10
   25f1a:	aa20      	add	r2, sp, #128	; 0x80
   25f1c:	f016 fc5d 	bl	3c7da <log_string_sync>
}
   25f20:	f50d 7d21 	add.w	sp, sp, #644	; 0x284
   25f24:	ecbd 8b02 	vpop	{d8}
   25f28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   25f2c:	447a0000 	.word	0x447a0000
   25f30:	42c80000 	.word	0x42c80000
   25f34:	3f700000 	.word	0x3f700000
   25f38:	20029894 	.word	0x20029894
   25f3c:	0004180d 	.word	0x0004180d
   25f40:	0003f8d4 	.word	0x0003f8d4
   25f44:	0003f974 	.word	0x0003f974
   25f48:	00042b08 	.word	0x00042b08

00025f4c <PMURedrawBatStatus>:
	k_timer_start(&soc_timer, K_MSEC(10*1000), K_MSEC(15*1000));
}

void PMURedrawBatStatus(void)
{
	if(screen_id == SCREEN_ID_IDLE)
   25f4c:	4b05      	ldr	r3, [pc, #20]	; (25f64 <PMURedrawBatStatus+0x18>)
   25f4e:	781b      	ldrb	r3, [r3, #0]
   25f50:	2b01      	cmp	r3, #1
   25f52:	d106      	bne.n	25f62 <PMURedrawBatStatus+0x16>
	{
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_BAT;
   25f54:	4b04      	ldr	r3, [pc, #16]	; (25f68 <PMURedrawBatStatus+0x1c>)
   25f56:	68da      	ldr	r2, [r3, #12]
   25f58:	f042 0202 	orr.w	r2, r2, #2
   25f5c:	60da      	str	r2, [r3, #12]
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   25f5e:	2202      	movs	r2, #2
   25f60:	725a      	strb	r2, [r3, #9]
	}
}
   25f62:	4770      	bx	lr
   25f64:	2002c382 	.word	0x2002c382
   25f68:	200249ec 	.word	0x200249ec

00025f6c <PMUMsgProcess>:
	MAX20353_UpdateTemper();
}
#endif

void PMUMsgProcess(void)
{
   25f6c:	b510      	push	{r4, lr}
	if(pmu_trige_flag)
   25f6e:	4c1c      	ldr	r4, [pc, #112]	; (25fe0 <PMUMsgProcess+0x74>)
   25f70:	7823      	ldrb	r3, [r4, #0]
   25f72:	b11b      	cbz	r3, 25f7c <PMUMsgProcess+0x10>
	{
		pmu_interrupt_proc();
   25f74:	f7ff fc32 	bl	257dc <pmu_interrupt_proc>
		pmu_trige_flag = false;
   25f78:	2300      	movs	r3, #0
   25f7a:	7023      	strb	r3, [r4, #0]
	}
	
	if(pmu_alert_flag)
   25f7c:	4c19      	ldr	r4, [pc, #100]	; (25fe4 <PMUMsgProcess+0x78>)
   25f7e:	7823      	ldrb	r3, [r4, #0]
   25f80:	b11b      	cbz	r3, 25f8a <PMUMsgProcess+0x1e>
	{
		pmu_alert_proc();
   25f82:	f7ff fcf9 	bl	25978 <pmu_alert_proc>
		pmu_alert_flag = false;
   25f86:	2300      	movs	r3, #0
   25f88:	7023      	strb	r3, [r4, #0]
	}
	
	if(sys_pwr_off)
   25f8a:	4c17      	ldr	r4, [pc, #92]	; (25fe8 <PMUMsgProcess+0x7c>)
   25f8c:	7823      	ldrb	r3, [r4, #0]
   25f8e:	b11b      	cbz	r3, 25f98 <PMUMsgProcess+0x2c>
	{
		SystemShutDown();
   25f90:	f016 f896 	bl	3c0c0 <SystemShutDown>
		sys_pwr_off = false;		
   25f94:	2300      	movs	r3, #0
   25f96:	7023      	strb	r3, [r4, #0]
	}
	
	if(vibrate_start_flag)
   25f98:	4c14      	ldr	r4, [pc, #80]	; (25fec <PMUMsgProcess+0x80>)
   25f9a:	7823      	ldrb	r3, [r4, #0]
   25f9c:	b11b      	cbz	r3, 25fa6 <PMUMsgProcess+0x3a>
	{
		VibrateStart();
   25f9e:	f016 f898 	bl	3c0d2 <VibrateStart>
		vibrate_start_flag = false;
   25fa2:	2300      	movs	r3, #0
   25fa4:	7023      	strb	r3, [r4, #0]
	}
	
	if(vibrate_stop_flag)
   25fa6:	4c12      	ldr	r4, [pc, #72]	; (25ff0 <PMUMsgProcess+0x84>)
   25fa8:	7823      	ldrb	r3, [r4, #0]
   25faa:	b11b      	cbz	r3, 25fb4 <PMUMsgProcess+0x48>
	{
		VibrateStop();
   25fac:	f016 f89c 	bl	3c0e8 <VibrateStop>
		vibrate_stop_flag = false;
   25fb0:	2300      	movs	r3, #0
   25fb2:	7023      	strb	r3, [r4, #0]
	}

	if(read_soc_status)
   25fb4:	4c0f      	ldr	r4, [pc, #60]	; (25ff4 <PMUMsgProcess+0x88>)
   25fb6:	7823      	ldrb	r3, [r4, #0]
   25fb8:	b11b      	cbz	r3, 25fc2 <PMUMsgProcess+0x56>
	{
		test_soc_status();
   25fba:	f7ff fe7d 	bl	25cb8 <test_soc_status>
		read_soc_status = false;
   25fbe:	2300      	movs	r3, #0
   25fc0:	7023      	strb	r3, [r4, #0]
	}

	if(pmu_redraw_bat_flag)
   25fc2:	490d      	ldr	r1, [pc, #52]	; (25ff8 <PMUMsgProcess+0x8c>)
   25fc4:	780b      	ldrb	r3, [r1, #0]
   25fc6:	b11b      	cbz	r3, 25fd0 <PMUMsgProcess+0x64>
	{
		PMURedrawBatStatus();
   25fc8:	f7ff ffc0 	bl	25f4c <PMURedrawBatStatus>
		pmu_redraw_bat_flag = false;
   25fcc:	2300      	movs	r3, #0
   25fce:	700b      	strb	r3, [r1, #0]
	}

#ifdef BATTERT_NTC_CHECK
	if(pmu_check_temp_flag)
   25fd0:	4c0a      	ldr	r4, [pc, #40]	; (25ffc <PMUMsgProcess+0x90>)
   25fd2:	7823      	ldrb	r3, [r4, #0]
   25fd4:	b11b      	cbz	r3, 25fde <PMUMsgProcess+0x72>
	MAX20353_UpdateTemper();
   25fd6:	f7f8 f8d7 	bl	1e188 <MAX20353_UpdateTemper>
	{
		PMUUpdateTempForSOC();
		pmu_check_temp_flag = false;
   25fda:	2300      	movs	r3, #0
   25fdc:	7023      	strb	r3, [r4, #0]
	}
#endif
}
   25fde:	bd10      	pop	{r4, pc}
   25fe0:	2002c388 	.word	0x2002c388
   25fe4:	2002c386 	.word	0x2002c386
   25fe8:	2002c38a 	.word	0x2002c38a
   25fec:	2002c38b 	.word	0x2002c38b
   25ff0:	2002c38c 	.word	0x2002c38c
   25ff4:	2002c389 	.word	0x2002c389
   25ff8:	20037901 	.word	0x20037901
   25ffc:	2002c387 	.word	0x2002c387

00026000 <MAX20353_CheckTemper>:

void MAX20353_CheckTemper(void)
{
	pmu_check_temp_flag = true;
   26000:	2201      	movs	r2, #1
   26002:	4b01      	ldr	r3, [pc, #4]	; (26008 <MAX20353_CheckTemper+0x8>)
   26004:	701a      	strb	r2, [r3, #0]
}
   26006:	4770      	bx	lr
   26008:	2002c387 	.word	0x2002c387

0002600c <MAX20353_WriteRegMulti>:
{
   2600c:	b538      	push	{r3, r4, r5, lr}
	ret = pmu_dev_ctx.write_reg(pmu_dev_ctx.handle, reg, value, len);
   2600e:	4c06      	ldr	r4, [pc, #24]	; (26028 <MAX20353_WriteRegMulti+0x1c>)
   26010:	4613      	mov	r3, r2
   26012:	6825      	ldr	r5, [r4, #0]
   26014:	460a      	mov	r2, r1
   26016:	4601      	mov	r1, r0
   26018:	68a0      	ldr	r0, [r4, #8]
   2601a:	47a8      	blx	r5
	if(ret != 0)
   2601c:	3000      	adds	r0, #0
   2601e:	bf18      	it	ne
   26020:	2001      	movne	r0, #1
}
   26022:	4240      	negs	r0, r0
   26024:	bd38      	pop	{r3, r4, r5, pc}
   26026:	bf00      	nop
   26028:	20024a64 	.word	0x20024a64

0002602c <MAX20353_WriteReg>:
{ 
   2602c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	ret = pmu_dev_ctx.write_reg(pmu_dev_ctx.handle, reg, &value, 1);
   2602e:	4c08      	ldr	r4, [pc, #32]	; (26050 <MAX20353_WriteReg+0x24>)
{ 
   26030:	f88d 1007 	strb.w	r1, [sp, #7]
	ret = pmu_dev_ctx.write_reg(pmu_dev_ctx.handle, reg, &value, 1);
   26034:	6825      	ldr	r5, [r4, #0]
   26036:	4601      	mov	r1, r0
   26038:	2301      	movs	r3, #1
   2603a:	f10d 0207 	add.w	r2, sp, #7
   2603e:	68a0      	ldr	r0, [r4, #8]
   26040:	47a8      	blx	r5
	if(ret != 0)
   26042:	3000      	adds	r0, #0
   26044:	bf18      	it	ne
   26046:	2001      	movne	r0, #1
}
   26048:	4240      	negs	r0, r0
   2604a:	b003      	add	sp, #12
   2604c:	bd30      	pop	{r4, r5, pc}
   2604e:	bf00      	nop
   26050:	20024a64 	.word	0x20024a64

00026054 <MAX20353_ReadReg>:
{
   26054:	b538      	push	{r3, r4, r5, lr}
	ret = pmu_dev_ctx.read_reg(pmu_dev_ctx.handle, reg, value, 1);
   26056:	4c06      	ldr	r4, [pc, #24]	; (26070 <MAX20353_ReadReg+0x1c>)
   26058:	460a      	mov	r2, r1
   2605a:	6865      	ldr	r5, [r4, #4]
   2605c:	4601      	mov	r1, r0
   2605e:	2301      	movs	r3, #1
   26060:	68a0      	ldr	r0, [r4, #8]
   26062:	47a8      	blx	r5
    if(ret != 0)
   26064:	3000      	adds	r0, #0
   26066:	bf18      	it	ne
   26068:	2001      	movne	r0, #1
}
   2606a:	4240      	negs	r0, r0
   2606c:	bd38      	pop	{r3, r4, r5, pc}
   2606e:	bf00      	nop
   26070:	20024a64 	.word	0x20024a64

00026074 <MAX20353_AppWrite>:
{
   26074:	b538      	push	{r3, r4, r5, lr}
	ret  = MAX20353_WriteRegMulti(REG_AP_DATOUT0, appdatainoutbuffer_, dataoutlen); ///0x0F
   26076:	4602      	mov	r2, r0
   26078:	490e      	ldr	r1, [pc, #56]	; (260b4 <MAX20353_AppWrite+0x40>)
   2607a:	200f      	movs	r0, #15
   2607c:	f7ff ffc6 	bl	2600c <MAX20353_WriteRegMulti>
   26080:	4c0d      	ldr	r4, [pc, #52]	; (260b8 <MAX20353_AppWrite+0x44>)
	ret |= MAX20353_WriteReg(REG_AP_CMDOUT, appcmdoutvalue_); //0x17	
   26082:	4d0e      	ldr	r5, [pc, #56]	; (260bc <MAX20353_AppWrite+0x48>)
	ret  = MAX20353_WriteRegMulti(REG_AP_DATOUT0, appdatainoutbuffer_, dataoutlen); ///0x0F
   26084:	6020      	str	r0, [r4, #0]
	ret |= MAX20353_WriteReg(REG_AP_CMDOUT, appcmdoutvalue_); //0x17	
   26086:	7829      	ldrb	r1, [r5, #0]
   26088:	2017      	movs	r0, #23
   2608a:	f7ff ffcf 	bl	2602c <MAX20353_WriteReg>
   2608e:	6823      	ldr	r3, [r4, #0]
   26090:	4318      	orrs	r0, r3
   26092:	6020      	str	r0, [r4, #0]
	k_sleep(K_MSEC(10));
   26094:	200a      	movs	r0, #10
   26096:	f016 f81a 	bl	3c0ce <k_sleep>
	ret |= MAX20353_ReadReg(REG_AP_RESPONSE, &appcmdoutvalue_);//0x18
   2609a:	4629      	mov	r1, r5
   2609c:	2018      	movs	r0, #24
   2609e:	f7ff ffd9 	bl	26054 <MAX20353_ReadReg>
   260a2:	6823      	ldr	r3, [r4, #0]
	if(ret != 0)
   260a4:	4303      	orrs	r3, r0
   260a6:	bf14      	ite	ne
   260a8:	f04f 30ff 	movne.w	r0, #4294967295
   260ac:	2000      	moveq	r0, #0
   260ae:	6020      	str	r0, [r4, #0]
}
   260b0:	bd38      	pop	{r3, r4, r5, pc}
   260b2:	bf00      	nop
   260b4:	2002c394 	.word	0x2002c394
   260b8:	20024ac8 	.word	0x20024ac8
   260bc:	2002c393 	.word	0x2002c393

000260c0 <MAX20303_HapticConfigDCMotor>:
{
   260c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	appcmdoutvalue_ = 0xA0;
   260c2:	23a0      	movs	r3, #160	; 0xa0
   260c4:	4e24      	ldr	r6, [pc, #144]	; (26158 <MAX20303_HapticConfigDCMotor+0x98>)
	appdatainoutbuffer_[0] = 0x0A; //0x0F; // EmfEn(resonance detection)/HptSel(ERM)/ALC/ZeroCrossHysteresis
   260c6:	4c25      	ldr	r4, [pc, #148]	; (2615c <MAX20303_HapticConfigDCMotor+0x9c>)
	appcmdoutvalue_ = 0xA0;
   260c8:	7033      	strb	r3, [r6, #0]
	appdatainoutbuffer_[0] = 0x0A; //0x0F; // EmfEn(resonance detection)/HptSel(ERM)/ALC/ZeroCrossHysteresis
   260ca:	230a      	movs	r3, #10
   260cc:	7023      	strb	r3, [r4, #0]
	appdatainoutbuffer_[1] = 0xDA; //0x9F; // Initial guess of Back EMF frequency = 25.6M/64/IniGss =235/205; IniGss = 0x6A6/0x79F
   260ce:	23da      	movs	r3, #218	; 0xda
   260d0:	7063      	strb	r3, [r4, #1]
	appdatainoutbuffer_[2] = 0x16; //0x87; // ZccSlowEn=0/FltrCntrEn=0
   260d2:	2316      	movs	r3, #22
   260d4:	70a3      	strb	r3, [r4, #2]
	appdatainoutbuffer_[4] = 0x07; //0x05; // Wide Window for BEMF zero crossing
   260d6:	2307      	movs	r3, #7
	appdatainoutbuffer_[3] = 0x00; //0x00; // Skip periods before BEMF measuring
   260d8:	2700      	movs	r7, #0
	appdatainoutbuffer_[4] = 0x07; //0x05; // Wide Window for BEMF zero crossing
   260da:	7123      	strb	r3, [r4, #4]
	appdatainoutbuffer_[5] = 0x02; //0x01; // Narrow Window for BEMF zero crossing
   260dc:	2302      	movs	r3, #2
	ret |= MAX20353_AppWrite(6);
   260de:	2006      	movs	r0, #6
	appdatainoutbuffer_[3] = 0x00; //0x00; // Skip periods before BEMF measuring
   260e0:	70e7      	strb	r7, [r4, #3]
	appdatainoutbuffer_[5] = 0x02; //0x01; // Narrow Window for BEMF zero crossing
   260e2:	7163      	strb	r3, [r4, #5]
	ret |= MAX20353_AppWrite(6);
   260e4:	f7ff ffc6 	bl	26074 <MAX20353_AppWrite>
	appcmdoutvalue_ = 0xA2;
   260e8:	23a2      	movs	r3, #162	; 0xa2
   260ea:	7033      	strb	r3, [r6, #0]
	appdatainoutbuffer_[0] = 0xF0; //0x01; // EmfSkipCyc
   260ec:	23f0      	movs	r3, #240	; 0xf0
   260ee:	7023      	strb	r3, [r4, #0]
	appdatainoutbuffer_[1] = 0x88; //0x00; // BlankWdw, zero corssing comparator blanking time after enable(1/25.6MHz)
   260f0:	2388      	movs	r3, #136	; 0x88
   260f2:	7063      	strb	r3, [r4, #1]
	appdatainoutbuffer_[4] = 0xE6; //0xE6; // ETRGOdAmp, Overdrive amplitude, LSB = 0.78%VFS, 98%
   260f4:	23e6      	movs	r3, #230	; 0xe6
	appdatainoutbuffer_[2] = 0x00; //0x02; // BlankWdw, zero corssing comparator blanking time after enable(1/25.6MHz)
   260f6:	70a7      	strb	r7, [r4, #2]
	appdatainoutbuffer_[4] = 0xE6; //0xE6; // ETRGOdAmp, Overdrive amplitude, LSB = 0.78%VFS, 98%
   260f8:	7123      	strb	r3, [r4, #4]
	appdatainoutbuffer_[3] = 0xFF; //0x5D; // Vpp_Sine_max = 5.65V, Vpp_Square_max = 4V, VFS= Vpp/2 = 2V, Max_VFS = 5.5V, set VFS = 2/5.5*255 = 92 = 0x5C(square), Sine: VFS=2.8/5.5*255=0x82
   260fa:	27ff      	movs	r7, #255	; 0xff
	appdatainoutbuffer_[5] = 0x10; //0x10; // ETRGOdDur, Overdrive period, LSB = 5ms, 80ms
   260fc:	2310      	movs	r3, #16
	ret |= MAX20353_AppWrite(6);
   260fe:	4605      	mov	r5, r0
	ret |= MAX20353_AppWrite(6);
   26100:	2006      	movs	r0, #6
	appdatainoutbuffer_[5] = 0x10; //0x10; // ETRGOdDur, Overdrive period, LSB = 5ms, 80ms
   26102:	7163      	strb	r3, [r4, #5]
	appdatainoutbuffer_[3] = 0xFF; //0x5D; // Vpp_Sine_max = 5.65V, Vpp_Square_max = 4V, VFS= Vpp/2 = 2V, Max_VFS = 5.5V, set VFS = 2/5.5*255 = 92 = 0x5C(square), Sine: VFS=2.8/5.5*255=0x82
   26104:	70e7      	strb	r7, [r4, #3]
	ret |= MAX20353_AppWrite(6);
   26106:	f7ff ffb5 	bl	26074 <MAX20353_AppWrite>
	appcmdoutvalue_ = 0xA4;
   2610a:	23a4      	movs	r3, #164	; 0xa4
   2610c:	7033      	strb	r3, [r6, #0]
	appdatainoutbuffer_[0] = 0xC0; //0xC0; // ETRGActAmp, normal amplitude, , LSB = 0.78%VFS, don't care
   2610e:	23c0      	movs	r3, #192	; 0xc0
   26110:	7023      	strb	r3, [r4, #0]
	appdatainoutbuffer_[2] = 0xCD; //0xCD; // ETRGActAmp, braking amplitude, , LSB = 0.78%VFS, 80*VFS
   26112:	23cd      	movs	r3, #205	; 0xcd
   26114:	70a3      	strb	r3, [r4, #2]
	appdatainoutbuffer_[3] = 0x14; //0x14; // ETRGActDur, breaking period, LSB = 5ms, 60ms
   26116:	2314      	movs	r3, #20
	ret |= MAX20353_AppWrite(6);
   26118:	4305      	orrs	r5, r0
	appdatainoutbuffer_[3] = 0x14; //0x14; // ETRGActDur, breaking period, LSB = 5ms, 60ms
   2611a:	70e3      	strb	r3, [r4, #3]
	appdatainoutbuffer_[5] = 0x06; //0x00; // periods from wide to narrow
   2611c:	2006      	movs	r0, #6
	appdatainoutbuffer_[4] = 0x23; //0x15; // narrow window gain, wide window gain = 1
   2611e:	2323      	movs	r3, #35	; 0x23
	appdatainoutbuffer_[1] = 0xFF; //0xFF; // ETRGActDur, normal period, LSB = 10ms, don't care
   26120:	7067      	strb	r7, [r4, #1]
	appdatainoutbuffer_[4] = 0x23; //0x15; // narrow window gain, wide window gain = 1
   26122:	7123      	strb	r3, [r4, #4]
	appdatainoutbuffer_[5] = 0x06; //0x00; // periods from wide to narrow
   26124:	7160      	strb	r0, [r4, #5]
	ret |= MAX20353_AppWrite(6);
   26126:	f7ff ffa5 	bl	26074 <MAX20353_AppWrite>
	appcmdoutvalue_ = 0xA6;
   2612a:	23a6      	movs	r3, #166	; 0xa6
   2612c:	7033      	strb	r3, [r6, #0]
	appdatainoutbuffer_[0] = 0x4A; //Sys UVLO threshold = 1.6V
   2612e:	234a      	movs	r3, #74	; 0x4a
	ret |= MAX20353_AppWrite(6);
   26130:	4305      	orrs	r5, r0
	ret |= MAX20353_AppWrite(1);
   26132:	2001      	movs	r0, #1
	appdatainoutbuffer_[0] = 0x4A; //Sys UVLO threshold = 1.6V
   26134:	7023      	strb	r3, [r4, #0]
	ret |= MAX20353_AppWrite(1);
   26136:	f7ff ff9d 	bl	26074 <MAX20353_AppWrite>
	if(ret != 0)
   2613a:	ea55 0100 	orrs.w	r1, r5, r0
   2613e:	d107      	bne.n	26150 <MAX20303_HapticConfigDCMotor+0x90>
	ret |= MAX20353_WriteReg( REG_HPT_DIRECT1,  0x00); //hptExtTrig=1, HptRamEn=1, HptDrvEn=1, HptDrvMode=0x12, disable HptDrvEn
   26140:	2031      	movs	r0, #49	; 0x31
   26142:	f7ff ff73 	bl	2602c <MAX20353_WriteReg>
	if(ret != 0)
   26146:	3000      	adds	r0, #0
   26148:	bf18      	it	ne
   2614a:	2001      	movne	r0, #1
   2614c:	4240      	negs	r0, r0
}
   2614e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return MAX20353_ERROR;
   26150:	f04f 30ff 	mov.w	r0, #4294967295
   26154:	e7fb      	b.n	2614e <MAX20303_HapticConfigDCMotor+0x8e>
   26156:	bf00      	nop
   26158:	2002c393 	.word	0x2002c393
   2615c:	2002c394 	.word	0x2002c394

00026160 <MAX20353_Buck1Config>:
    appcmdoutvalue_ = 0x35;
   26160:	2235      	movs	r2, #53	; 0x35
   26162:	4b07      	ldr	r3, [pc, #28]	; (26180 <MAX20353_Buck1Config+0x20>)
    ret = MAX20353_AppWrite(4);
   26164:	2004      	movs	r0, #4
    appcmdoutvalue_ = 0x35;
   26166:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x00;  	//
   26168:	2200      	movs	r2, #0
   2616a:	4b06      	ldr	r3, [pc, #24]	; (26184 <MAX20353_Buck1Config+0x24>)
   2616c:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[1] = 0x2C;  	//0x28    0.7+(0.025V * number)    0x48*0.025 =1.8v     //0.7V to 2.275V, Linear Scale, 25mV increments
   2616e:	222c      	movs	r2, #44	; 0x2c
   26170:	705a      	strb	r2, [r3, #1]
    appdatainoutbuffer_[2] = 0x1F;  	//0x2F  	01 = 20mA, Use for 1V < Buck1VSet < 1.8V
   26172:	221f      	movs	r2, #31
   26174:	709a      	strb	r2, [r3, #2]
    appdatainoutbuffer_[3] = 0x01;  	// Enable
   26176:	2201      	movs	r2, #1
   26178:	70da      	strb	r2, [r3, #3]
    ret = MAX20353_AppWrite(4);
   2617a:	f7ff bf7b 	b.w	26074 <MAX20353_AppWrite>
   2617e:	bf00      	nop
   26180:	2002c393 	.word	0x2002c393
   26184:	2002c394 	.word	0x2002c394

00026188 <MAX20353_Buck2Config>:
    appcmdoutvalue_ = 0x3A;
   26188:	223a      	movs	r2, #58	; 0x3a
    appdatainoutbuffer_[1] = 0x32;     	//0x32    0.7V + (0.05V * number) = 3.3V;
   2618a:	2132      	movs	r1, #50	; 0x32
    appcmdoutvalue_ = 0x3A;
   2618c:	4b05      	ldr	r3, [pc, #20]	; (261a4 <MAX20353_Buck2Config+0x1c>)
    ret = MAX20353_AppWrite(4);
   2618e:	2004      	movs	r0, #4
    appcmdoutvalue_ = 0x3A;
   26190:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x01;      //
   26192:	4b05      	ldr	r3, [pc, #20]	; (261a8 <MAX20353_Buck2Config+0x20>)
   26194:	2201      	movs	r2, #1
    appdatainoutbuffer_[1] = 0x32;     	//0x32    0.7V + (0.05V * number) = 3.3V;
   26196:	7059      	strb	r1, [r3, #1]
    appdatainoutbuffer_[2] = 0x3F;		//  0x3F 375mA  01 = 20mA, Use for 1V < Buck2VSet < 1.8V
   26198:	213f      	movs	r1, #63	; 0x3f
    appdatainoutbuffer_[0] = 0x01;      //
   2619a:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[2] = 0x3F;		//  0x3F 375mA  01 = 20mA, Use for 1V < Buck2VSet < 1.8V
   2619c:	7099      	strb	r1, [r3, #2]
    appdatainoutbuffer_[3] = 0x01;		// Enable
   2619e:	70da      	strb	r2, [r3, #3]
    ret = MAX20353_AppWrite(4);
   261a0:	f7ff bf68 	b.w	26074 <MAX20353_AppWrite>
   261a4:	2002c393 	.word	0x2002c393
   261a8:	2002c394 	.word	0x2002c394

000261ac <MAX20353_LDO1Config>:
    appcmdoutvalue_ = 0x40;
   261ac:	2240      	movs	r2, #64	; 0x40
   261ae:	4b05      	ldr	r3, [pc, #20]	; (261c4 <MAX20353_LDO1Config+0x18>)
    ret = MAX20353_AppWrite(2);
   261b0:	2002      	movs	r0, #2
    appcmdoutvalue_ = 0x40;
   261b2:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x01;     //0x01  0.5V to 1.95V, Linear Scale, 25mV increments,   LDO1  
   261b4:	2201      	movs	r2, #1
   261b6:	4b04      	ldr	r3, [pc, #16]	; (261c8 <MAX20353_LDO1Config+0x1c>)
   261b8:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[1] = 0x34;     //0x28  0.5V + (0.025V * number)   =  1.95V   1.8
   261ba:	2234      	movs	r2, #52	; 0x34
   261bc:	705a      	strb	r2, [r3, #1]
    ret = MAX20353_AppWrite(2);
   261be:	f7ff bf59 	b.w	26074 <MAX20353_AppWrite>
   261c2:	bf00      	nop
   261c4:	2002c393 	.word	0x2002c393
   261c8:	2002c394 	.word	0x2002c394

000261cc <MAX20353_LDO2Config>:
    appcmdoutvalue_ = 0x42;
   261cc:	2242      	movs	r2, #66	; 0x42
   261ce:	4b05      	ldr	r3, [pc, #20]	; (261e4 <MAX20353_LDO2Config+0x18>)
    ret = MAX20353_AppWrite(2);
   261d0:	2002      	movs	r0, #2
    appcmdoutvalue_ = 0x42;
   261d2:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x01;
   261d4:	2201      	movs	r2, #1
   261d6:	4b04      	ldr	r3, [pc, #16]	; (261e8 <MAX20353_LDO2Config+0x1c>)
   261d8:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[1] = 0x13;     // 0.9V + (0.1V * number)   =  2.8V 
   261da:	2213      	movs	r2, #19
   261dc:	705a      	strb	r2, [r3, #1]
    ret = MAX20353_AppWrite(2);
   261de:	f7ff bf49 	b.w	26074 <MAX20353_AppWrite>
   261e2:	bf00      	nop
   261e4:	2002c393 	.word	0x2002c393
   261e8:	2002c394 	.word	0x2002c394

000261ec <MAX20353_BoostConfig>:
	appcmdoutvalue_ = 0x30;
   261ec:	2230      	movs	r2, #48	; 0x30
   261ee:	4b06      	ldr	r3, [pc, #24]	; (26208 <MAX20353_BoostConfig+0x1c>)
	ret = MAX20353_AppWrite(4);
   261f0:	2004      	movs	r0, #4
	appcmdoutvalue_ = 0x30;
   261f2:	701a      	strb	r2, [r3, #0]
	appdatainoutbuffer_[0] = 0x01;
   261f4:	2201      	movs	r2, #1
   261f6:	4b05      	ldr	r3, [pc, #20]	; (2620c <MAX20353_BoostConfig+0x20>)
   261f8:	701a      	strb	r2, [r3, #0]
	appdatainoutbuffer_[1] = 0x00;
   261fa:	2200      	movs	r2, #0
   261fc:	705a      	strb	r2, [r3, #1]
	appdatainoutbuffer_[2] = 0x00;
   261fe:	709a      	strb	r2, [r3, #2]
	appdatainoutbuffer_[3] = 0x00;     // 5V + (0.25V * number); 0x00:5V, 0x3B:20V; EVKIT's cap can only be upto 6.3V
   26200:	70da      	strb	r2, [r3, #3]
	ret = MAX20353_AppWrite(4);
   26202:	f7ff bf37 	b.w	26074 <MAX20353_AppWrite>
   26206:	bf00      	nop
   26208:	2002c393 	.word	0x2002c393
   2620c:	2002c394 	.word	0x2002c394

00026210 <MAX20353_ChargePumpConfig>:
    appcmdoutvalue_ = 0x46;
   26210:	2246      	movs	r2, #70	; 0x46
   26212:	4b05      	ldr	r3, [pc, #20]	; (26228 <MAX20353_ChargePumpConfig+0x18>)
    ret = MAX20353_AppWrite(2);
   26214:	2002      	movs	r0, #2
    appcmdoutvalue_ = 0x46;
   26216:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x01;	// Boost Enabled
   26218:	2201      	movs	r2, #1
   2621a:	4b04      	ldr	r3, [pc, #16]	; (2622c <MAX20353_ChargePumpConfig+0x1c>)
   2621c:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[1] = 0x03;	// 00 : 6.5V, 01: 5V
   2621e:	2203      	movs	r2, #3
   26220:	705a      	strb	r2, [r3, #1]
    ret = MAX20353_AppWrite(2);
   26222:	f7ff bf27 	b.w	26074 <MAX20353_AppWrite>
   26226:	bf00      	nop
   26228:	2002c393 	.word	0x2002c393
   2622c:	2002c394 	.word	0x2002c394

00026230 <MAX20353_BuckBoostConfig>:
    appcmdoutvalue_ = 0x70;
   26230:	2270      	movs	r2, #112	; 0x70
   26232:	4b06      	ldr	r3, [pc, #24]	; (2624c <MAX20353_BuckBoostConfig+0x1c>)
    appdatainoutbuffer_[1] = 0x04;
   26234:	2004      	movs	r0, #4
    appcmdoutvalue_ = 0x70;
   26236:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x00;
   26238:	2200      	movs	r2, #0
   2623a:	4b05      	ldr	r3, [pc, #20]	; (26250 <MAX20353_BuckBoostConfig+0x20>)
   2623c:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[2] = 0x19;		// 2.5V + (0.1V * number) = 5.0V
   2623e:	2219      	movs	r2, #25
   26240:	709a      	strb	r2, [r3, #2]
    appdatainoutbuffer_[3] = 0x41;     
   26242:	2241      	movs	r2, #65	; 0x41
    appdatainoutbuffer_[1] = 0x04;
   26244:	7058      	strb	r0, [r3, #1]
    appdatainoutbuffer_[3] = 0x41;     
   26246:	70da      	strb	r2, [r3, #3]
    ret = MAX20353_AppWrite(4);
   26248:	f7ff bf14 	b.w	26074 <MAX20353_AppWrite>
   2624c:	2002c393 	.word	0x2002c393
   26250:	2002c394 	.word	0x2002c394

00026254 <MAX20353_PowerOffConfig>:
    appcmdoutvalue_ = 0x80;
   26254:	2280      	movs	r2, #128	; 0x80
   26256:	4b04      	ldr	r3, [pc, #16]	; (26268 <MAX20353_PowerOffConfig+0x14>)
    ret = MAX20353_AppWrite(1);
   26258:	2001      	movs	r0, #1
    appcmdoutvalue_ = 0x80;
   2625a:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0xB2;
   2625c:	22b2      	movs	r2, #178	; 0xb2
   2625e:	4b03      	ldr	r3, [pc, #12]	; (2626c <MAX20353_PowerOffConfig+0x18>)
   26260:	701a      	strb	r2, [r3, #0]
    ret = MAX20353_AppWrite(1);
   26262:	f7ff bf07 	b.w	26074 <MAX20353_AppWrite>
   26266:	bf00      	nop
   26268:	2002c393 	.word	0x2002c393
   2626c:	2002c394 	.word	0x2002c394

00026270 <MAX20353_ReadRegMulti>:
{
   26270:	b538      	push	{r3, r4, r5, lr}
	ret = pmu_dev_ctx.read_reg(pmu_dev_ctx.handle, reg, value, len);
   26272:	4c06      	ldr	r4, [pc, #24]	; (2628c <MAX20353_ReadRegMulti+0x1c>)
   26274:	4613      	mov	r3, r2
   26276:	6865      	ldr	r5, [r4, #4]
   26278:	460a      	mov	r2, r1
   2627a:	4601      	mov	r1, r0
   2627c:	68a0      	ldr	r0, [r4, #8]
   2627e:	47a8      	blx	r5
    if(ret != 0)
   26280:	3000      	adds	r0, #0
   26282:	bf18      	it	ne
   26284:	2001      	movne	r0, #1
}
   26286:	4240      	negs	r0, r0
   26288:	bd38      	pop	{r3, r4, r5, pc}
   2628a:	bf00      	nop
   2628c:	20024a64 	.word	0x20024a64

00026290 <MAX20353_AppRead>:
{
   26290:	b538      	push	{r3, r4, r5, lr}
	ret = MAX20353_WriteReg(REG_AP_CMDOUT, appcmdoutvalue_);
   26292:	4b0b      	ldr	r3, [pc, #44]	; (262c0 <MAX20353_AppRead+0x30>)
{
   26294:	4605      	mov	r5, r0
	ret = MAX20353_WriteReg(REG_AP_CMDOUT, appcmdoutvalue_);
   26296:	7819      	ldrb	r1, [r3, #0]
   26298:	2017      	movs	r0, #23
   2629a:	f7ff fec7 	bl	2602c <MAX20353_WriteReg>
   2629e:	4604      	mov	r4, r0
	k_sleep(K_MSEC(10));
   262a0:	200a      	movs	r0, #10
   262a2:	f015 ff14 	bl	3c0ce <k_sleep>
	ret |= MAX20353_ReadRegMulti(REG_AP_RESPONSE, i2cbuffer_, datainlen);
   262a6:	462a      	mov	r2, r5
   262a8:	4906      	ldr	r1, [pc, #24]	; (262c4 <MAX20353_AppRead+0x34>)
   262aa:	2018      	movs	r0, #24
   262ac:	f7ff ffe0 	bl	26270 <MAX20353_ReadRegMulti>
	if(ret != 0)
   262b0:	ea54 0300 	orrs.w	r3, r4, r0
}
   262b4:	bf14      	ite	ne
   262b6:	f04f 30ff 	movne.w	r0, #4294967295
   262ba:	2000      	moveq	r0, #0
   262bc:	bd38      	pop	{r3, r4, r5, pc}
   262be:	bf00      	nop
   262c0:	2002c393 	.word	0x2002c393
   262c4:	2002c39c 	.word	0x2002c39c

000262c8 <MAX20353_ChargerCfg>:
	appcmdoutvalue_ = 0x14; 
   262c8:	2214      	movs	r2, #20
   262ca:	4b06      	ldr	r3, [pc, #24]	; (262e4 <MAX20353_ChargerCfg+0x1c>)
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   262cc:	2004      	movs	r0, #4
	appcmdoutvalue_ = 0x14; 
   262ce:	701a      	strb	r2, [r3, #0]
	appdatainoutbuffer_[1] = 0x61; // Precharge to b110:3.0V, b00:0.05IFChg for dead battery, ChgDone b01: 0.1IFChg 
   262d0:	2261      	movs	r2, #97	; 0x61
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   262d2:	4b05      	ldr	r3, [pc, #20]	; (262e8 <MAX20353_ChargerCfg+0x20>)
	appdatainoutbuffer_[1] = 0x61; // Precharge to b110:3.0V, b00:0.05IFChg for dead battery, ChgDone b01: 0.1IFChg 
   262d4:	705a      	strb	r2, [r3, #1]
	appdatainoutbuffer_[2] = 0xD6; // Auto Stop, Auto ReStart, ReChg Threshold b01:120mV, Bat Volt b0011: 4.2V, b0110:4.35 
   262d6:	22d6      	movs	r2, #214	; 0xd6
   262d8:	709a      	strb	r2, [r3, #2]
	appdatainoutbuffer_[3] = 0x07; // System min volt = 4.3V 
   262da:	2207      	movs	r2, #7
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   262dc:	7018      	strb	r0, [r3, #0]
	appdatainoutbuffer_[3] = 0x07; // System min volt = 4.3V 
   262de:	70da      	strb	r2, [r3, #3]
	ret |= MAX20353_AppWrite(4);
   262e0:	f7ff bec8 	b.w	26074 <MAX20353_AppWrite>
   262e4:	2002c393 	.word	0x2002c393
   262e8:	2002c394 	.word	0x2002c394

000262ec <MAX20353_ChargerCtrl>:
	appcmdoutvalue_ = 0x1A; 
   262ec:	221a      	movs	r2, #26
	appdatainoutbuffer_[0] = 0x01; // Thermal EN, Charger EN 
   262ee:	2001      	movs	r0, #1
	appcmdoutvalue_ = 0x1A; 
   262f0:	4b02      	ldr	r3, [pc, #8]	; (262fc <MAX20353_ChargerCtrl+0x10>)
   262f2:	701a      	strb	r2, [r3, #0]
	appdatainoutbuffer_[0] = 0x01; // Thermal EN, Charger EN 
   262f4:	4b02      	ldr	r3, [pc, #8]	; (26300 <MAX20353_ChargerCtrl+0x14>)
   262f6:	7018      	strb	r0, [r3, #0]
	ret |= MAX20353_AppWrite(1); 
   262f8:	f7ff bebc 	b.w	26074 <MAX20353_AppWrite>
   262fc:	2002c393 	.word	0x2002c393
   26300:	2002c394 	.word	0x2002c394

00026304 <MAX20353_InputCurCfg>:
	appcmdoutvalue_ = 0x10;
   26304:	2210      	movs	r2, #16
   26306:	4b04      	ldr	r3, [pc, #16]	; (26318 <MAX20353_InputCurCfg+0x14>)
	ret = MAX20353_AppWrite(1);
   26308:	2001      	movs	r0, #1
	appcmdoutvalue_ = 0x10;
   2630a:	701a      	strb	r2, [r3, #0]
	appdatainoutbuffer_[0] = 0x1E;  //500ma(+,F3160ma),10ms
   2630c:	221e      	movs	r2, #30
   2630e:	4b03      	ldr	r3, [pc, #12]	; (2631c <MAX20353_InputCurCfg+0x18>)
   26310:	701a      	strb	r2, [r3, #0]
	ret = MAX20353_AppWrite(1);
   26312:	f7ff beaf 	b.w	26074 <MAX20353_AppWrite>
   26316:	bf00      	nop
   26318:	2002c393 	.word	0x2002c393
   2631c:	2002c394 	.word	0x2002c394

00026320 <MAX20353_ChargerInit>:
{
   26320:	b508      	push	{r3, lr}
	MAX20353_ChargerCfg();
   26322:	f7ff ffd1 	bl	262c8 <MAX20353_ChargerCfg>
	MAX20353_ChargerCtrl();
   26326:	f7ff ffe1 	bl	262ec <MAX20353_ChargerCtrl>
	MAX20353_InputCurCfg();
   2632a:	f7ff ffeb 	bl	26304 <MAX20353_InputCurCfg>
	PMICIntMasks[0] = 0x48;
   2632e:	2348      	movs	r3, #72	; 0x48
   26330:	4804      	ldr	r0, [pc, #16]	; (26344 <MAX20353_ChargerInit+0x24>)
   26332:	7003      	strb	r3, [r0, #0]
	PMICIntMasks[1] = 0x00;
   26334:	2300      	movs	r3, #0
   26336:	7043      	strb	r3, [r0, #1]
	PMICIntMasks[2] = 0x00;
   26338:	7083      	strb	r3, [r0, #2]
}
   2633a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	MAX20353_EnablePMICIntMaskRegisters(PMICIntMasks);
   2633e:	f015 beeb 	b.w	3c118 <MAX20353_EnablePMICIntMaskRegisters>
   26342:	bf00      	nop
   26344:	2002c38e 	.word	0x2002c38e

00026348 <InitCharger>:
	appcmdoutvalue_ = 0x14; 
   26348:	2314      	movs	r3, #20
{ 
   2634a:	b570      	push	{r4, r5, r6, lr}
	appcmdoutvalue_ = 0x14; 
   2634c:	4d0a      	ldr	r5, [pc, #40]	; (26378 <InitCharger+0x30>)
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   2634e:	4c0b      	ldr	r4, [pc, #44]	; (2637c <InitCharger+0x34>)
	appcmdoutvalue_ = 0x14; 
   26350:	702b      	strb	r3, [r5, #0]
	appdatainoutbuffer_[1] = 0x61; // Precharge to b110:3.0V, b00:0.05IFChg for dead battery, ChgDone b01: 0.1IFChg 
   26352:	2361      	movs	r3, #97	; 0x61
   26354:	7063      	strb	r3, [r4, #1]
	appdatainoutbuffer_[2] = 0xD6; // Auto Stop, Auto ReStart, ReChg Threshold b01:120mV, Bat Volt b0011: 4.2V, b0110:4.35 
   26356:	23d6      	movs	r3, #214	; 0xd6
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   26358:	2004      	movs	r0, #4
	appdatainoutbuffer_[2] = 0xD6; // Auto Stop, Auto ReStart, ReChg Threshold b01:120mV, Bat Volt b0011: 4.2V, b0110:4.35 
   2635a:	70a3      	strb	r3, [r4, #2]
	appdatainoutbuffer_[3] = 0x07; // System min volt = 4.3V 
   2635c:	2307      	movs	r3, #7
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   2635e:	7020      	strb	r0, [r4, #0]
	appdatainoutbuffer_[3] = 0x07; // System min volt = 4.3V 
   26360:	70e3      	strb	r3, [r4, #3]
	ret |= MAX20353_AppWrite(4);
   26362:	f7ff fe87 	bl	26074 <MAX20353_AppWrite>
	appcmdoutvalue_ = 0x1A; 
   26366:	231a      	movs	r3, #26
	ret |= MAX20353_AppWrite(4);
   26368:	4606      	mov	r6, r0
	appdatainoutbuffer_[0] = 0x01; // Thermal EN, Charger EN 
   2636a:	2001      	movs	r0, #1
	appcmdoutvalue_ = 0x1A; 
   2636c:	702b      	strb	r3, [r5, #0]
	appdatainoutbuffer_[0] = 0x01; // Thermal EN, Charger EN 
   2636e:	7020      	strb	r0, [r4, #0]
	ret |= MAX20353_AppWrite(1); 
   26370:	f7ff fe80 	bl	26074 <MAX20353_AppWrite>
}
   26374:	4330      	orrs	r0, r6
   26376:	bd70      	pop	{r4, r5, r6, pc}
   26378:	2002c393 	.word	0x2002c393
   2637c:	2002c394 	.word	0x2002c394

00026380 <ReadWord>:
{
   26380:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	msg.len = num_bytes;
   26384:	2401      	movs	r4, #1
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   26386:	2502      	movs	r5, #2
   26388:	b087      	sub	sp, #28
	ret = i2c_write(pmu_dev_ctx.handle, &data, sizeof(data), MAX20353_I2C_ADDR_FUEL_GAUGE);
   2638a:	4e18      	ldr	r6, [pc, #96]	; (263ec <ReadWord+0x6c>)
	msg.buf = (u8_t *)buf;
   2638c:	f10d 0307 	add.w	r3, sp, #7
	u8_t data = reg;
   26390:	f88d 0007 	strb.w	r0, [sp, #7]
{
   26394:	4688      	mov	r8, r1
   26396:	4617      	mov	r7, r2
	ret = i2c_write(pmu_dev_ctx.handle, &data, sizeof(data), MAX20353_I2C_ADDR_FUEL_GAUGE);
   26398:	68b0      	ldr	r0, [r6, #8]
   2639a:	9303      	str	r3, [sp, #12]
	msg.len = num_bytes;
   2639c:	9404      	str	r4, [sp, #16]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   2639e:	f88d 5014 	strb.w	r5, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   263a2:	6843      	ldr	r3, [r0, #4]
   263a4:	4622      	mov	r2, r4
   263a6:	f8d3 9004 	ldr.w	r9, [r3, #4]
   263aa:	a903      	add	r1, sp, #12
   263ac:	2336      	movs	r3, #54	; 0x36
   263ae:	47c8      	blx	r9
	if(ret != 0)
   263b0:	b120      	cbz	r0, 263bc <ReadWord+0x3c>
		return MAX20353_ERROR;
   263b2:	f04f 30ff 	mov.w	r0, #4294967295
}
   263b6:	b007      	add	sp, #28
   263b8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	msg.buf = buf;
   263bc:	ab02      	add	r3, sp, #8
	msg.len = num_bytes;
   263be:	e9cd 3503 	strd	r3, r5, [sp, #12]
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
   263c2:	2303      	movs	r3, #3
	ret = i2c_read(pmu_dev_ctx.handle, value, sizeof(value), MAX20353_I2C_ADDR_FUEL_GAUGE);
   263c4:	68b0      	ldr	r0, [r6, #8]
   263c6:	f88d 3014 	strb.w	r3, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   263ca:	6843      	ldr	r3, [r0, #4]
   263cc:	4622      	mov	r2, r4
   263ce:	685d      	ldr	r5, [r3, #4]
   263d0:	a903      	add	r1, sp, #12
   263d2:	2336      	movs	r3, #54	; 0x36
   263d4:	47a8      	blx	r5
	if (ret != 0)
   263d6:	2800      	cmp	r0, #0
   263d8:	d1eb      	bne.n	263b2 <ReadWord+0x32>
	*MSB = value[0];
   263da:	f89d 3008 	ldrb.w	r3, [sp, #8]
   263de:	f888 3000 	strb.w	r3, [r8]
	*LSB = value[1];
   263e2:	f89d 3009 	ldrb.w	r3, [sp, #9]
   263e6:	703b      	strb	r3, [r7, #0]
	return MAX20353_NO_ERROR;
   263e8:	e7e5      	b.n	263b6 <ReadWord+0x36>
   263ea:	bf00      	nop
   263ec:	20024a64 	.word	0x20024a64

000263f0 <WriteWord>:
{
   263f0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	rslt = i2c_write(pmu_dev_ctx.handle, cmdData, sizeof(cmdData), MAX20353_I2C_ADDR_FUEL_GAUGE);
   263f2:	4b0d      	ldr	r3, [pc, #52]	; (26428 <WriteWord+0x38>)
	u8_t cmdData[3] = {reg, MSB, LSB};
   263f4:	f88d 0000 	strb.w	r0, [sp]
	rslt = i2c_write(pmu_dev_ctx.handle, cmdData, sizeof(cmdData), MAX20353_I2C_ADDR_FUEL_GAUGE);
   263f8:	6898      	ldr	r0, [r3, #8]
	msg.len = num_bytes;
   263fa:	2303      	movs	r3, #3
   263fc:	9302      	str	r3, [sp, #8]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   263fe:	2302      	movs	r3, #2
	u8_t cmdData[3] = {reg, MSB, LSB};
   26400:	f88d 1001 	strb.w	r1, [sp, #1]
   26404:	f88d 2002 	strb.w	r2, [sp, #2]
	msg.buf = (u8_t *)buf;
   26408:	f8cd d004 	str.w	sp, [sp, #4]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   2640c:	f88d 300c 	strb.w	r3, [sp, #12]
	return api->transfer(dev, msgs, num_msgs, addr);
   26410:	6843      	ldr	r3, [r0, #4]
   26412:	2201      	movs	r2, #1
   26414:	685c      	ldr	r4, [r3, #4]
   26416:	a901      	add	r1, sp, #4
   26418:	2336      	movs	r3, #54	; 0x36
   2641a:	47a0      	blx	r4
	if (rslt != 0)
   2641c:	3000      	adds	r0, #0
   2641e:	bf18      	it	ne
   26420:	2001      	movne	r0, #1
}
   26422:	4240      	negs	r0, r0
   26424:	b004      	add	sp, #16
   26426:	bd10      	pop	{r4, pc}
   26428:	20024a64 	.word	0x20024a64

0002642c <WriteMulti>:
	ret = i2c_write(pmu_dev_ctx.handle, data, len, MAX20353_I2C_ADDR_FUEL_GAUGE);
   2642c:	4b0a      	ldr	r3, [pc, #40]	; (26458 <WriteMulti+0x2c>)
{
   2642e:	b530      	push	{r4, r5, lr}
	ret = i2c_write(pmu_dev_ctx.handle, data, len, MAX20353_I2C_ADDR_FUEL_GAUGE);
   26430:	689c      	ldr	r4, [r3, #8]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   26432:	2302      	movs	r3, #2
{
   26434:	b085      	sub	sp, #20
	ret = i2c_write(pmu_dev_ctx.handle, data, len, MAX20353_I2C_ADDR_FUEL_GAUGE);
   26436:	e9cd 0101 	strd	r0, r1, [sp, #4]
   2643a:	f88d 300c 	strb.w	r3, [sp, #12]
	return api->transfer(dev, msgs, num_msgs, addr);
   2643e:	6863      	ldr	r3, [r4, #4]
   26440:	2201      	movs	r2, #1
   26442:	685d      	ldr	r5, [r3, #4]
   26444:	a901      	add	r1, sp, #4
   26446:	2336      	movs	r3, #54	; 0x36
   26448:	4620      	mov	r0, r4
   2644a:	47a8      	blx	r5
	if (ret != 0)
   2644c:	3000      	adds	r0, #0
   2644e:	bf18      	it	ne
   26450:	2001      	movne	r0, #1
}
   26452:	4240      	negs	r0, r0
   26454:	b005      	add	sp, #20
   26456:	bd30      	pop	{r4, r5, pc}
   26458:	20024a64 	.word	0x20024a64

0002645c <MAX20353_ReadTHM>:
{
   2645c:	b530      	push	{r4, r5, lr}
	appdatainoutbuffer_[0] = 0x22; ////4 average, THM
   2645e:	2222      	movs	r2, #34	; 0x22
	appcmdoutvalue_ = 0x53;
   26460:	2553      	movs	r5, #83	; 0x53
	appdatainoutbuffer_[0] = 0x22; ////4 average, THM
   26462:	4b13      	ldr	r3, [pc, #76]	; (264b0 <MAX20353_ReadTHM+0x54>)
	appcmdoutvalue_ = 0x53;
   26464:	4c13      	ldr	r4, [pc, #76]	; (264b4 <MAX20353_ReadTHM+0x58>)
{
   26466:	b085      	sub	sp, #20
	ret |= MAX20353_AppWrite(1);
   26468:	2001      	movs	r0, #1
	appdatainoutbuffer_[0] = 0x22; ////4 average, THM
   2646a:	701a      	strb	r2, [r3, #0]
	appcmdoutvalue_ = 0x53;
   2646c:	7025      	strb	r5, [r4, #0]
	ret |= MAX20353_AppWrite(1);
   2646e:	f7ff fe01 	bl	26074 <MAX20353_AppWrite>
	ret |= MAX20353_AppRead(5);
   26472:	2005      	movs	r0, #5
	appcmdoutvalue_ = 0x53;
   26474:	7025      	strb	r5, [r4, #0]
	ret |= MAX20353_AppRead(5);
   26476:	f7ff ff0b 	bl	26290 <MAX20353_AppRead>
	LOG_INF("%02X, %02X, %02X, %02X, %02X\n", i2cbuffer_[0], i2cbuffer_[1], i2cbuffer_[2], i2cbuffer_[3], i2cbuffer_[4]);
   2647a:	2303      	movs	r3, #3
   2647c:	f04f 0000 	mov.w	r0, #0
   26480:	4a0d      	ldr	r2, [pc, #52]	; (264b8 <MAX20353_ReadTHM+0x5c>)
   26482:	f363 0007 	bfi	r0, r3, #0, #8
   26486:	4b0d      	ldr	r3, [pc, #52]	; (264bc <MAX20353_ReadTHM+0x60>)
   26488:	4c0d      	ldr	r4, [pc, #52]	; (264c0 <MAX20353_ReadTHM+0x64>)
   2648a:	1a9b      	subs	r3, r3, r2
   2648c:	08db      	lsrs	r3, r3, #3
   2648e:	f363 108f 	bfi	r0, r3, #6, #10
   26492:	7923      	ldrb	r3, [r4, #4]
   26494:	490b      	ldr	r1, [pc, #44]	; (264c4 <MAX20353_ReadTHM+0x68>)
   26496:	9302      	str	r3, [sp, #8]
   26498:	78e3      	ldrb	r3, [r4, #3]
   2649a:	9301      	str	r3, [sp, #4]
   2649c:	78a3      	ldrb	r3, [r4, #2]
   2649e:	9300      	str	r3, [sp, #0]
   264a0:	7863      	ldrb	r3, [r4, #1]
   264a2:	7822      	ldrb	r2, [r4, #0]
   264a4:	f016 f999 	bl	3c7da <log_string_sync>
}
   264a8:	7920      	ldrb	r0, [r4, #4]
   264aa:	b005      	add	sp, #20
   264ac:	bd30      	pop	{r4, r5, pc}
   264ae:	bf00      	nop
   264b0:	2002c394 	.word	0x2002c394
   264b4:	2002c393 	.word	0x2002c393
   264b8:	0003f8d4 	.word	0x0003f8d4
   264bc:	0003f97c 	.word	0x0003f97c
   264c0:	2002c39c 	.word	0x2002c39c
   264c4:	00041887 	.word	0x00041887

000264c8 <MAX20353_UpdateRCOMP>:
	if(temp>20) // (20, ...) 
   264c8:	2814      	cmp	r0, #20
{
   264ca:	b510      	push	{r4, lr}
	if(temp>20) // (20, ...) 
   264cc:	dd17      	ble.n	264fe <MAX20353_UpdateRCOMP+0x36>
		result = INI_RCOMP + (temp - 20) * used_tempco;
   264ce:	3814      	subs	r0, #20
   264d0:	ee07 0a90 	vmov	s15, r0
   264d4:	eefe 6a07 	vmov.f32	s13, #231	; 0xbf380000 -0.7187500
   264d8:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
		result = INI_RCOMP + (temp - 20) * used_tempco;
   264dc:	eef3 7a06 	vmov.f32	s15, #54	; 0x41b00000  22.0
		result = result_0 + (temp - 0) * used_tempco;
   264e0:	ee47 7a26 	vmla.f32	s15, s14, s13
   264e4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	RCOMP = (result >= 0xff ? 0xff : (result <= 0 ?  0 : result));
   264e8:	ee17 3a90 	vmov	r3, s15
   264ec:	f383 0408 	usat	r4, #8, r3
	WriteWord(0x0C, RCOMP, 0x5C);
   264f0:	225c      	movs	r2, #92	; 0x5c
   264f2:	b2e1      	uxtb	r1, r4
   264f4:	200c      	movs	r0, #12
   264f6:	f7ff ff7b 	bl	263f0 <WriteWord>
}
   264fa:	4620      	mov	r0, r4
   264fc:	bd10      	pop	{r4, pc}
	else if(temp>0) // {0, 20)
   264fe:	2800      	cmp	r0, #0
   26500:	dd07      	ble.n	26512 <MAX20353_UpdateRCOMP+0x4a>
		result = INI_RCOMP + (temp - 20) * used_tempco;
   26502:	3814      	subs	r0, #20
   26504:	ee07 0a90 	vmov	s15, r0
   26508:	eef8 6a0f 	vmov.f32	s13, #143	; 0xc0780000 -3.875
   2650c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   26510:	e7e4      	b.n	264dc <MAX20353_UpdateRCOMP+0x14>
		result = result_0 + (temp - 0) * used_tempco;
   26512:	ee07 0a90 	vmov	s15, r0
   26516:	eddf 6a03 	vldr	s13, [pc, #12]	; 26524 <MAX20353_UpdateRCOMP+0x5c>
   2651a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   2651e:	eddf 7a02 	vldr	s15, [pc, #8]	; 26528 <MAX20353_UpdateRCOMP+0x60>
   26522:	e7dd      	b.n	264e0 <MAX20353_UpdateRCOMP+0x18>
   26524:	c07a0000 	.word	0xc07a0000
   26528:	42c60000 	.word	0x42c60000

0002652c <MAX20353_StartCheckTemper>:

void MAX20353_StartCheckTemper(void)
{
   2652c:	b510      	push	{r4, lr}
	k_timer_init(&ntc_check_timer, MAX20353_CheckTemper, NULL);
   2652e:	4c07      	ldr	r4, [pc, #28]	; (2654c <MAX20353_StartCheckTemper+0x20>)
   26530:	2200      	movs	r2, #0
   26532:	4907      	ldr	r1, [pc, #28]	; (26550 <MAX20353_StartCheckTemper+0x24>)
   26534:	4620      	mov	r0, r4
   26536:	f018 f8da 	bl	3e6ee <k_timer_init>
   2653a:	f64e 2260 	movw	r2, #60000	; 0xea60
   2653e:	4620      	mov	r0, r4
	k_timer_start(&ntc_check_timer, K_MSEC(30*1000), K_MSEC(60*1000));
}
   26540:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   26544:	f247 5130 	movw	r1, #30000	; 0x7530
   26548:	f012 b8a8 	b.w	3869c <z_impl_k_timer_start>
   2654c:	20024a9c 	.word	0x20024a9c
   26550:	00026001 	.word	0x00026001

00026554 <MAX20353_CalculateSOC>:

#endif/*BATTERT_NTC_CHECK*/

u8_t MAX20353_CalculateSOC(void)
{
   26554:	b510      	push	{r4, lr}
	u16_t tmp;
	
	ReadWord(0x04, &SOC_1, &SOC_2);
   26556:	4c04      	ldr	r4, [pc, #16]	; (26568 <MAX20353_CalculateSOC+0x14>)
   26558:	4a04      	ldr	r2, [pc, #16]	; (2656c <MAX20353_CalculateSOC+0x18>)
   2655a:	4621      	mov	r1, r4
   2655c:	2004      	movs	r0, #4
   2655e:	f7ff ff0f 	bl	26380 <ReadWord>
		SOC_percent = SOC/512;

	//SOC_percent = 26.5;
	
	return SOC_percent;
}
   26562:	7820      	ldrb	r0, [r4, #0]
   26564:	bd10      	pop	{r4, pc}
   26566:	bf00      	nop
   26568:	2002c391 	.word	0x2002c391
   2656c:	2002c392 	.word	0x2002c392

00026570 <prepare_to_load_model>:
	*/
	delay_ms(250);
}

void prepare_to_load_model(void)
{
   26570:	b538      	push	{r3, r4, r5, lr}
	Step 2. Read OCV
	The OCV Register will be modified during the process of loading the custom
	model. Read and store this value so that it can be written back to the
	device after the model has been loaded.
	*/
	ReadWord(0x0E, &original_OCV_1, &original_OCV_2);
   26572:	4c09      	ldr	r4, [pc, #36]	; (26598 <prepare_to_load_model+0x28>)
   26574:	4d09      	ldr	r5, [pc, #36]	; (2659c <prepare_to_load_model+0x2c>)
	WriteWord(0x3E, 0x4A, 0x57);
   26576:	2257      	movs	r2, #87	; 0x57
   26578:	214a      	movs	r1, #74	; 0x4a
   2657a:	203e      	movs	r0, #62	; 0x3e
   2657c:	f7ff ff38 	bl	263f0 <WriteWord>
	ReadWord(0x0E, &original_OCV_1, &original_OCV_2);
   26580:	4a05      	ldr	r2, [pc, #20]	; (26598 <prepare_to_load_model+0x28>)
   26582:	4906      	ldr	r1, [pc, #24]	; (2659c <prepare_to_load_model+0x2c>)
   26584:	200e      	movs	r0, #14
   26586:	f7ff fefb 	bl	26380 <ReadWord>
	If Model Access was correctly unlocked in Step 1, then the OCV bytes read
	in Step 2 will not be 0xFF. If the values of both bytes are 0xFF,
	that indicates that Model Access was not correctly unlocked and the
	sequence should be repeated from Step 1.
	*/
	if((original_OCV_1 == 0xFF) && (original_OCV_2 == 0xFF))
   2658a:	782b      	ldrb	r3, [r5, #0]
   2658c:	7822      	ldrb	r2, [r4, #0]
   2658e:	4013      	ands	r3, r2
   26590:	2bff      	cmp	r3, #255	; 0xff
   26592:	d0f0      	beq.n	26576 <prepare_to_load_model+0x6>
	Step 4. Write RCOMP to its Maximum Value (MAX17040/1/3/4 only)
	Make the fuel-gauge respond as slowly as possible (MSB = 0xFF), and disable
	alerts during model loading (LSB = 0x00)
	*/
	//WriteWord(0x0C, 0xFF, 0x00);
}
   26594:	bd38      	pop	{r3, r4, r5, pc}
   26596:	bf00      	nop
   26598:	2002c3ad 	.word	0x2002c3ad
   2659c:	2002c3ac 	.word	0x2002c3ac

000265a0 <load_model>:

void load_model(void)
{
   265a0:	b570      	push	{r4, r5, r6, lr}
   265a2:	b09a      	sub	sp, #104	; 0x68
	u8_t databuf[10] = {0};
	u8_t addr_mem;
	u32_t RCOMPSeg = RCOMPSEG;
	unsigned char RCOMPSeg_MSB = (RCOMPSeg >> 8) & 0xFF;
	unsigned char RCOMPSeg_LSB = RCOMPSeg & 0xFF;	
	u8_t model_data[65] = 
   265a4:	2241      	movs	r2, #65	; 0x41
   265a6:	490e      	ldr	r1, [pc, #56]	; (265e0 <load_model+0x40>)
   265a8:	a809      	add	r0, sp, #36	; 0x24
   265aa:	f018 f94f 	bl	3e84c <memcpy>
		0xD7,0x50,0x00,0x80,0x08,0xE0,0x12,0x80,0x0F,0xE0,
		0x15,0xC0,0x12,0xC0,0x19,0xE0,0x12,0xF0,0x0C,0xF0,
		0x09,0xE0,0x09,0x30,0x08,0x80,0x07,0xE0,0x09,0x00,
		0x06,0x10,0x06,0x10
	};
	u8_t RCOMP_data[33] = // 1+16*2, first byte is the memory address
   265ae:	466a      	mov	r2, sp
   265b0:	4615      	mov	r5, r2
   265b2:	4b0c      	ldr	r3, [pc, #48]	; (265e4 <load_model+0x44>)
   265b4:	f103 0620 	add.w	r6, r3, #32
   265b8:	4614      	mov	r4, r2
   265ba:	6818      	ldr	r0, [r3, #0]
   265bc:	6859      	ldr	r1, [r3, #4]
   265be:	3308      	adds	r3, #8
   265c0:	c403      	stmia	r4!, {r0, r1}
   265c2:	42b3      	cmp	r3, r6
   265c4:	4622      	mov	r2, r4
   265c6:	d1f7      	bne.n	265b8 <load_model+0x18>
   265c8:	781b      	ldrb	r3, [r3, #0]
	{
		pmu_dev_ctx.write_reg(pmu_dev_ctx.handle, addr_mem, &model_data[k], 1);
		addr_mem++;
	}
	*/
	WriteMulti(model_data, sizeof(model_data));
   265ca:	2141      	movs	r1, #65	; 0x41
	u8_t RCOMP_data[33] = // 1+16*2, first byte is the memory address
   265cc:	7023      	strb	r3, [r4, #0]
	WriteMulti(model_data, sizeof(model_data));
   265ce:	a809      	add	r0, sp, #36	; 0x24
   265d0:	f7ff ff2c 	bl	2642c <WriteMulti>
		pmu_dev_ctx.write_reg(pmu_dev_ctx.handle, addr_mem, databuf, 2);
		addr_mem+2;
	}
	*/
	/* I2C STOP */
	WriteMulti(RCOMP_data, sizeof(RCOMP_data));
   265d4:	2121      	movs	r1, #33	; 0x21
   265d6:	4628      	mov	r0, r5
   265d8:	f7ff ff28 	bl	2642c <WriteMulti>
}
   265dc:	b01a      	add	sp, #104	; 0x68
   265de:	bd70      	pop	{r4, r5, r6, pc}
   265e0:	0003fb70 	.word	0x0003fb70
   265e4:	0003fbb1 	.word	0x0003fbb1

000265e8 <verify_model_is_correct>:

bool verify_model_is_correct(void)
{
   265e8:	b510      	push	{r4, lr}
	
	/******************************************************************************
	Step 7. Write OCV
	This OCV should produce the SOC_Check values in Step 9
	*/
	WriteWord(0x0E, INI_OCVTEST_HIGH_BYTE, INI_OCVTEST_LOW_BYTE);
   265ea:	2250      	movs	r2, #80	; 0x50
   265ec:	21e1      	movs	r1, #225	; 0xe1
   265ee:	200e      	movs	r0, #14
   265f0:	f7ff fefe 	bl	263f0 <WriteWord>
	/******************************************************************************
	Step 7.1 Disable Hibernate (MAX17048/49 only)
	The IC updates SOC less frequently in hibernate mode, so make sure it
	is not hibernating
	*/
	WriteWord(0x0A, 0, 0);
   265f4:	2200      	movs	r2, #0
   265f6:	200a      	movs	r0, #10
   265f8:	4611      	mov	r1, r2
   265fa:	f7ff fef9 	bl	263f0 <WriteWord>
	Step 7.2. Lock Model Access (MAX17048/49/58/59 only)
	To allow the ModelGauge algorithm to run in MAX17048/49/58/59 only, the model
	must
	be locked. This is harmless but unnecessary for MAX17040/1/3/4
	*/
	WriteWord(0x3E, 0, 0);
   265fe:	2200      	movs	r2, #0
	register is verified to be within a specified range to verify that the
	model was loaded correctly. This value is not an indication of the state of
	the actual battery. Please note that INI_SOCCheckA and INI_SOCCheckB has a
	fixed LSB of 1/256% for both 18 and 19 bit models.
	*/
	ReadWord(0x04, &SOC_1, &SOC_2);
   26600:	4c0a      	ldr	r4, [pc, #40]	; (2662c <verify_model_is_correct+0x44>)
	WriteWord(0x3E, 0, 0);
   26602:	4611      	mov	r1, r2
   26604:	203e      	movs	r0, #62	; 0x3e
   26606:	f7ff fef3 	bl	263f0 <WriteWord>
    k_sleep(K_MSEC(period));
   2660a:	f44f 7096 	mov.w	r0, #300	; 0x12c
   2660e:	f015 fd5e 	bl	3c0ce <k_sleep>
	ReadWord(0x04, &SOC_1, &SOC_2);
   26612:	4a07      	ldr	r2, [pc, #28]	; (26630 <verify_model_is_correct+0x48>)
   26614:	4621      	mov	r1, r4
   26616:	2004      	movs	r0, #4
   26618:	f7ff feb2 	bl	26380 <ReadWord>
	if(SOC_1 >= SOCCHECKA && SOC_1 <= SOCCHECKB)
   2661c:	7820      	ldrb	r0, [r4, #0]
   2661e:	3872      	subs	r0, #114	; 0x72
	else
	{
		// model was NOT loaded successfully
		return false;
	}
}
   26620:	2802      	cmp	r0, #2
   26622:	bf8c      	ite	hi
   26624:	2000      	movhi	r0, #0
   26626:	2001      	movls	r0, #1
   26628:	bd10      	pop	{r4, pc}
   2662a:	bf00      	nop
   2662c:	2002c391 	.word	0x2002c391
   26630:	2002c392 	.word	0x2002c392

00026634 <cleanup_model_load>:

void cleanup_model_load(void)
{
   26634:	b508      	push	{r3, lr}
	/******************************************************************************
	Step 9.1. Unlock Model Access (MAX17048/49/58/59 only)
	To write OCV, MAX17048/49/58/59 requires model access to be unlocked.
	*/
	WriteWord(0x3E, 0x4A, 0x57);
   26636:	2257      	movs	r2, #87	; 0x57
   26638:	214a      	movs	r1, #74	; 0x4a
   2663a:	203e      	movs	r0, #62	; 0x3e
   2663c:	f7ff fed8 	bl	263f0 <WriteWord>
	/******************************************************************************
	Step 10. Restore CONFIG and OCV
	It is up to the application how to configure the LSB of the CONFIG
	register; any byte value is valid.
	*/
	WriteWord(0x0C, RCOMP0, 0x5C);
   26640:	225c      	movs	r2, #92	; 0x5c
   26642:	2116      	movs	r1, #22
   26644:	200c      	movs	r0, #12
   26646:	f7ff fed3 	bl	263f0 <WriteWord>
	WriteWord(0x0E, original_OCV_1, original_OCV_2);
   2664a:	4b0b      	ldr	r3, [pc, #44]	; (26678 <cleanup_model_load+0x44>)
   2664c:	200e      	movs	r0, #14
   2664e:	781a      	ldrb	r2, [r3, #0]
   26650:	4b0a      	ldr	r3, [pc, #40]	; (2667c <cleanup_model_load+0x48>)
   26652:	7819      	ldrb	r1, [r3, #0]
   26654:	f7ff fecc 	bl	263f0 <WriteWord>
	Step 10.1 Restore Hibernate (MAX17048/49 only)
	Remember to restore your desired Hibernate configuration after the
	model was verified.
	*/
	// Restore your desired value of HIBRT
	WriteWord(0x0A, 0x80, 0x30);
   26658:	2230      	movs	r2, #48	; 0x30
   2665a:	2180      	movs	r1, #128	; 0x80
   2665c:	200a      	movs	r0, #10
   2665e:	f7ff fec7 	bl	263f0 <WriteWord>
	
	/******************************************************************************
	Step 11. Lock Model Access
	*/
	WriteWord(0x3E, 0x00, 0x00);
   26662:	2200      	movs	r2, #0
   26664:	203e      	movs	r0, #62	; 0x3e
   26666:	4611      	mov	r1, r2
   26668:	f7ff fec2 	bl	263f0 <WriteWord>
	*/
	//if(SOC < SOCCHECKA)
	//	model was loaded successfully
	//else
	//	goto step C1 and reload model
}
   2666c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    k_sleep(K_MSEC(period));
   26670:	f44f 7096 	mov.w	r0, #300	; 0x12c
   26674:	f015 bd2b 	b.w	3c0ce <k_sleep>
   26678:	2002c3ad 	.word	0x2002c3ad
   2667c:	2002c3ac 	.word	0x2002c3ac

00026680 <MAX20353_Init>:
{
   26680:	b510      	push	{r4, lr}
	MAX20353_GetDeviceID(&HardwareID);
   26682:	4c0f      	ldr	r4, [pc, #60]	; (266c0 <MAX20353_Init+0x40>)
   26684:	4620      	mov	r0, r4
   26686:	f015 fd59 	bl	3c13c <MAX20353_GetDeviceID>
	if(HardwareID != MAX20353_HARDWARE_ID)
   2668a:	7823      	ldrb	r3, [r4, #0]
   2668c:	2b03      	cmp	r3, #3
   2668e:	d115      	bne.n	266bc <MAX20353_Init+0x3c>
	MAX20353_Buck1Config();	//1.8v  350mA
   26690:	f7ff fd66 	bl	26160 <MAX20353_Buck1Config>
	MAX20353_Buck2Config(); //3.3V  350mA
   26694:	f7ff fd78 	bl	26188 <MAX20353_Buck2Config>
	MAX20353_LDO1Config();	//1.8v 50mA
   26698:	f7ff fd88 	bl	261ac <MAX20353_LDO1Config>
	MAX20353_LDO2Config();	//2.8V 100mA
   2669c:	f7ff fd96 	bl	261cc <MAX20353_LDO2Config>
	MAX20353_BoostConfig(); //5V buck23.3VPPG
   266a0:	f7ff fda4 	bl	261ec <MAX20353_BoostConfig>
	MAX20353_ChargePumpConfig();
   266a4:	f7ff fdb4 	bl	26210 <MAX20353_ChargePumpConfig>
	MAX20353_BuckBoostConfig();
   266a8:	f7ff fdc2 	bl	26230 <MAX20353_BuckBoostConfig>
	MAX20303_HapticConfigDCMotor();
   266ac:	f7ff fd08 	bl	260c0 <MAX20303_HapticConfigDCMotor>
	MAX20353_SOCInit();
   266b0:	f015 fd66 	bl	3c180 <MAX20353_SOCInit>
}
   266b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	MAX20353_ChargerInit();
   266b8:	f7ff be32 	b.w	26320 <MAX20353_ChargerInit>
}
   266bc:	bd10      	pop	{r4, pc}
   266be:	bf00      	nop
   266c0:	2002c38d 	.word	0x2002c38d

000266c4 <crc8_ccitt>:
	0x00, 0x07, 0x0e, 0x09, 0x1c, 0x1b, 0x12, 0x15,
	0x38, 0x3f, 0x36, 0x31, 0x24, 0x23, 0x2a, 0x2d
};

u8_t crc8_ccitt(u8_t val, const void *buf, size_t cnt)
{
   266c4:	b510      	push	{r4, lr}
	int i;
	const u8_t *p = buf;

	for (i = 0; i < cnt; i++) {
		val ^= p[i];
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
   266c6:	4c09      	ldr	r4, [pc, #36]	; (266ec <crc8_ccitt+0x28>)
   266c8:	440a      	add	r2, r1
	for (i = 0; i < cnt; i++) {
   266ca:	4291      	cmp	r1, r2
   266cc:	d100      	bne.n	266d0 <crc8_ccitt+0xc>
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
	}
	return val;
}
   266ce:	bd10      	pop	{r4, pc}
		val ^= p[i];
   266d0:	f811 3b01 	ldrb.w	r3, [r1], #1
   266d4:	4043      	eors	r3, r0
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
   266d6:	0918      	lsrs	r0, r3, #4
   266d8:	5c20      	ldrb	r0, [r4, r0]
   266da:	ea80 1003 	eor.w	r0, r0, r3, lsl #4
   266de:	b2c3      	uxtb	r3, r0
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
   266e0:	0918      	lsrs	r0, r3, #4
   266e2:	5c20      	ldrb	r0, [r4, r0]
   266e4:	ea80 1003 	eor.w	r0, r0, r3, lsl #4
   266e8:	b2c0      	uxtb	r0, r0
   266ea:	e7ee      	b.n	266ca <crc8_ccitt+0x6>
   266ec:	00041943 	.word	0x00041943

000266f0 <z_sys_mem_pool_block_free>:
	return 0;
}

void z_sys_mem_pool_block_free(struct sys_mem_pool_base *p, u32_t level,
			      u32_t block)
{
   266f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   266f4:	b085      	sub	sp, #20
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   266f6:	7a83      	ldrb	r3, [r0, #10]
{
   266f8:	af00      	add	r7, sp, #0
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   266fa:	009b      	lsls	r3, r3, #2
   266fc:	3307      	adds	r3, #7
   266fe:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
   26702:	ebad 0d03 	sub.w	sp, sp, r3
   26706:	46eb      	mov	fp, sp
	 * to avoid having to store it in precious RAM bytes.
	 * Overhead here is somewhat higher because block_free()
	 * doesn't inherently need to traverse all the larger
	 * sublevels.
	 */
	lsizes[0] = p->max_sz;
   26708:	6843      	ldr	r3, [r0, #4]
{
   2670a:	4606      	mov	r6, r0
	lsizes[0] = p->max_sz;
   2670c:	465c      	mov	r4, fp
	for (i = 1; i <= level; i++) {
   2670e:	2001      	movs	r0, #1
	lsizes[0] = p->max_sz;
   26710:	f8cb 3000 	str.w	r3, [fp]
	for (i = 1; i <= level; i++) {
   26714:	4281      	cmp	r1, r0
   26716:	d222      	bcs.n	2675e <z_sys_mem_pool_block_free+0x6e>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   26718:	7c30      	ldrb	r0, [r6, #16]
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
	}

	block_free(p, level, lsizes, block);
   2671a:	4688      	mov	r8, r1
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   2671c:	f010 0001 	ands.w	r0, r0, #1
	block_free(p, level, lsizes, block);
   26720:	4615      	mov	r5, r2
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   26722:	d001      	beq.n	26728 <z_sys_mem_pool_block_free+0x38>
   26724:	f015 fd7a 	bl	3c21c <pool_irq_lock.isra.2.part.3>
	unsigned int key = pool_irq_lock(p);
   26728:	4604      	mov	r4, r0
	while (level >= 0) {
   2672a:	f1b8 0f00 	cmp.w	r8, #0
   2672e:	da1e      	bge.n	2676e <z_sys_mem_pool_block_free+0x7e>
	__ASSERT(0, "out of levels");
   26730:	23bc      	movs	r3, #188	; 0xbc
   26732:	4a50      	ldr	r2, [pc, #320]	; (26874 <z_sys_mem_pool_block_free+0x184>)
   26734:	4950      	ldr	r1, [pc, #320]	; (26878 <z_sys_mem_pool_block_free+0x188>)
   26736:	4851      	ldr	r0, [pc, #324]	; (2687c <z_sys_mem_pool_block_free+0x18c>)
   26738:	f015 fff8 	bl	3c72c <printk>
   2673c:	4850      	ldr	r0, [pc, #320]	; (26880 <z_sys_mem_pool_block_free+0x190>)
   2673e:	f015 fff5 	bl	3c72c <printk>
   26742:	21bc      	movs	r1, #188	; 0xbc
   26744:	484b      	ldr	r0, [pc, #300]	; (26874 <z_sys_mem_pool_block_free+0x184>)
   26746:	f016 f837 	bl	3c7b8 <assert_post_action>
	return -1;
   2674a:	f04f 34ff 	mov.w	r4, #4294967295
	pool_irq_unlock(p, key);
   2674e:	4621      	mov	r1, r4
   26750:	7c30      	ldrb	r0, [r6, #16]
   26752:	f015 fd6c 	bl	3c22e <pool_irq_unlock.isra.4>
}
   26756:	3714      	adds	r7, #20
   26758:	46bd      	mov	sp, r7
   2675a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
   2675e:	6823      	ldr	r3, [r4, #0]
	for (i = 1; i <= level; i++) {
   26760:	3001      	adds	r0, #1
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
   26762:	089b      	lsrs	r3, r3, #2
   26764:	f023 0303 	bic.w	r3, r3, #3
   26768:	f844 3f04 	str.w	r3, [r4, #4]!
   2676c:	e7d2      	b.n	26714 <z_sys_mem_pool_block_free+0x24>
		int i, lsz = lsizes[level];
   2676e:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
	int bit = get_bit_ptr(p, level, bn, &word);
   26772:	462a      	mov	r2, r5
	return (u8_t *)p->buf + lsz * block;
   26774:	fb03 fa05 	mul.w	sl, r3, r5
		int i, lsz = lsizes[level];
   26778:	607b      	str	r3, [r7, #4]
	return (u8_t *)p->buf + lsz * block;
   2677a:	6833      	ldr	r3, [r6, #0]
	int bit = get_bit_ptr(p, level, bn, &word);
   2677c:	4641      	mov	r1, r8
	return (u8_t *)p->buf + lsz * block;
   2677e:	603b      	str	r3, [r7, #0]
   26780:	eb03 090a 	add.w	r9, r3, sl
	int bit = get_bit_ptr(p, level, bn, &word);
   26784:	4630      	mov	r0, r6
   26786:	f107 030c 	add.w	r3, r7, #12
   2678a:	f015 fd30 	bl	3c1ee <get_bit_ptr>
	return (*word >> bit) & 1;
   2678e:	68fb      	ldr	r3, [r7, #12]
   26790:	681b      	ldr	r3, [r3, #0]
   26792:	fa23 f000 	lsr.w	r0, r3, r0
		__ASSERT(alloc_bit_is_set(p, level, bn),
   26796:	07c3      	lsls	r3, r0, #31
   26798:	d40d      	bmi.n	267b6 <z_sys_mem_pool_block_free+0xc6>
   2679a:	23a3      	movs	r3, #163	; 0xa3
   2679c:	4a35      	ldr	r2, [pc, #212]	; (26874 <z_sys_mem_pool_block_free+0x184>)
   2679e:	4939      	ldr	r1, [pc, #228]	; (26884 <z_sys_mem_pool_block_free+0x194>)
   267a0:	4836      	ldr	r0, [pc, #216]	; (2687c <z_sys_mem_pool_block_free+0x18c>)
   267a2:	f015 ffc3 	bl	3c72c <printk>
   267a6:	4649      	mov	r1, r9
   267a8:	4837      	ldr	r0, [pc, #220]	; (26888 <z_sys_mem_pool_block_free+0x198>)
   267aa:	f015 ffbf 	bl	3c72c <printk>
   267ae:	21a3      	movs	r1, #163	; 0xa3
   267b0:	4830      	ldr	r0, [pc, #192]	; (26874 <z_sys_mem_pool_block_free+0x184>)
   267b2:	f016 f801 	bl	3c7b8 <assert_post_action>
	int bit = get_bit_ptr(p, level, bn, &word);
   267b6:	f107 030c 	add.w	r3, r7, #12
   267ba:	462a      	mov	r2, r5
   267bc:	4641      	mov	r1, r8
   267be:	4630      	mov	r0, r6
   267c0:	f015 fd15 	bl	3c1ee <get_bit_ptr>
	*word &= ~(1<<bit);
   267c4:	2301      	movs	r3, #1
   267c6:	68fa      	ldr	r2, [r7, #12]
   267c8:	fa03 f000 	lsl.w	r0, r3, r0
   267cc:	6813      	ldr	r3, [r2, #0]
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
   267ce:	6839      	ldr	r1, [r7, #0]
   267d0:	ea23 0300 	bic.w	r3, r3, r0
   267d4:	6013      	str	r3, [r2, #0]
		sys_dlist_append(&p->levels[level].free_list, block);
   267d6:	230c      	movs	r3, #12
   267d8:	68f2      	ldr	r2, [r6, #12]
   267da:	fb03 2308 	mla	r3, r3, r8, r2
   267de:	1d1a      	adds	r2, r3, #4
   267e0:	f841 200a 	str.w	r2, [r1, sl]
	node->prev = list->tail;
   267e4:	689a      	ldr	r2, [r3, #8]
		pool_irq_unlock(p, key);
   267e6:	4621      	mov	r1, r4
   267e8:	f8c9 2004 	str.w	r2, [r9, #4]

	list->tail->next = node;
   267ec:	689a      	ldr	r2, [r3, #8]
   267ee:	f8c2 9000 	str.w	r9, [r2]
	list->tail = node;
   267f2:	f8c3 9008 	str.w	r9, [r3, #8]
   267f6:	7c30      	ldrb	r0, [r6, #16]
   267f8:	f015 fd19 	bl	3c22e <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   267fc:	7c30      	ldrb	r0, [r6, #16]
   267fe:	f010 0001 	ands.w	r0, r0, #1
   26802:	d001      	beq.n	26808 <z_sys_mem_pool_block_free+0x118>
   26804:	f015 fd0a 	bl	3c21c <pool_irq_lock.isra.2.part.3>
		key = pool_irq_lock(p);
   26808:	4604      	mov	r4, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
   2680a:	f1b8 0f00 	cmp.w	r8, #0
   2680e:	d09e      	beq.n	2674e <z_sys_mem_pool_block_free+0x5e>
	int bit = get_bit_ptr(p, level, bn, &word);
   26810:	f107 030c 	add.w	r3, r7, #12
   26814:	462a      	mov	r2, r5
   26816:	4641      	mov	r1, r8
   26818:	4630      	mov	r0, r6
   2681a:	f015 fce8 	bl	3c1ee <get_bit_ptr>
	return (*word >> (4*(bit / 4))) & 0xf;
   2681e:	68fb      	ldr	r3, [r7, #12]
   26820:	2800      	cmp	r0, #0
   26822:	bfb8      	it	lt
   26824:	3003      	addlt	r0, #3
   26826:	681b      	ldr	r3, [r3, #0]
   26828:	f020 0003 	bic.w	r0, r0, #3
   2682c:	fa23 f000 	lsr.w	r0, r3, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
   26830:	f010 000f 	ands.w	r0, r0, #15
   26834:	d18b      	bne.n	2674e <z_sys_mem_pool_block_free+0x5e>
	node->next = NULL;
   26836:	4684      	mov	ip, r0
			int b = (bn & ~3) + i;
   26838:	f025 0a03 	bic.w	sl, r5, #3
	return (u8_t *)p->buf + lsz * block;
   2683c:	687a      	ldr	r2, [r7, #4]
			int b = (bn & ~3) + i;
   2683e:	eb0a 0300 	add.w	r3, sl, r0
	return (u8_t *)p->buf + lsz * block;
   26842:	4353      	muls	r3, r2
   26844:	6832      	ldr	r2, [r6, #0]
		for (i = 0; i < 4; i++) {
   26846:	3001      	adds	r0, #1
	return (u8_t *)p->buf + lsz * block;
   26848:	18d1      	adds	r1, r2, r3
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
   2684a:	f8d1 9004 	ldr.w	r9, [r1, #4]
   2684e:	f852 e003 	ldr.w	lr, [r2, r3]
		for (i = 0; i < 4; i++) {
   26852:	2804      	cmp	r0, #4
   26854:	f8c9 e000 	str.w	lr, [r9]
	node->next->prev = node->prev;
   26858:	f8ce 9004 	str.w	r9, [lr, #4]
	node->next = NULL;
   2685c:	f842 c003 	str.w	ip, [r2, r3]
	node->prev = NULL;
   26860:	f8c1 c004 	str.w	ip, [r1, #4]
   26864:	d1ea      	bne.n	2683c <z_sys_mem_pool_block_free+0x14c>
		bn = bn / 4;
   26866:	2d00      	cmp	r5, #0
   26868:	bfb8      	it	lt
   2686a:	3503      	addlt	r5, #3
		level = level - 1;
   2686c:	f108 38ff 	add.w	r8, r8, #4294967295
		bn = bn / 4;
   26870:	10ad      	asrs	r5, r5, #2
   26872:	e75a      	b.n	2672a <z_sys_mem_pool_block_free+0x3a>
   26874:	00041953 	.word	0x00041953
   26878:	00043e6b 	.word	0x00043e6b
   2687c:	00040606 	.word	0x00040606
   26880:	000419bb 	.word	0x000419bb
   26884:	00041977 	.word	0x00041977
   26888:	00041996 	.word	0x00041996

0002688c <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
   2688c:	680b      	ldr	r3, [r1, #0]
   2688e:	3301      	adds	r3, #1
   26890:	600b      	str	r3, [r1, #0]
	return _char_out(c);
   26892:	4b01      	ldr	r3, [pc, #4]	; (26898 <char_out+0xc>)
   26894:	681b      	ldr	r3, [r3, #0]
   26896:	4718      	bx	r3
   26898:	200345cc 	.word	0x200345cc

0002689c <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
   2689c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   268a0:	b085      	sub	sp, #20
   268a2:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   268a4:	469b      	mov	fp, r3
   268a6:	2c01      	cmp	r4, #1
   268a8:	bfb8      	it	lt
   268aa:	2401      	movlt	r4, #1
   268ac:	2b01      	cmp	r3, #1
   268ae:	bf0c      	ite	eq
   268b0:	2330      	moveq	r3, #48	; 0x30
   268b2:	2320      	movne	r3, #32
   268b4:	4616      	mov	r6, r2
   268b6:	4682      	mov	sl, r0
   268b8:	4688      	mov	r8, r1
   268ba:	2501      	movs	r5, #1
   268bc:	270a      	movs	r7, #10
   268be:	2200      	movs	r2, #0
   268c0:	f8df 906c 	ldr.w	r9, [pc, #108]	; 26930 <_printk_dec_ulong+0x94>
   268c4:	9302      	str	r3, [sp, #8]
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
   268c6:	fbb6 f3f9 	udiv	r3, r6, r9
   268ca:	9301      	str	r3, [sp, #4]
   268cc:	b90a      	cbnz	r2, 268d2 <_printk_dec_ulong+0x36>
   268ce:	45b1      	cmp	r9, r6
   268d0:	d81c      	bhi.n	2690c <_printk_dec_ulong+0x70>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
   268d2:	9b01      	ldr	r3, [sp, #4]
   268d4:	4641      	mov	r1, r8
   268d6:	f103 0030 	add.w	r0, r3, #48	; 0x30
   268da:	47d0      	blx	sl
			found_largest_digit = 1;
   268dc:	2201      	movs	r2, #1
			digits++;
   268de:	3501      	adds	r5, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= pos;
   268e0:	9b01      	ldr	r3, [sp, #4]
		remaining--;
   268e2:	3f01      	subs	r7, #1
		remainder %= pos;
   268e4:	fb09 6613 	mls	r6, r9, r3, r6
		pos /= 10;
   268e8:	230a      	movs	r3, #10
	while (pos >= 10) {
   268ea:	2f01      	cmp	r7, #1
		pos /= 10;
   268ec:	fbb9 f9f3 	udiv	r9, r9, r3
	while (pos >= 10) {
   268f0:	d1e9      	bne.n	268c6 <_printk_dec_ulong+0x2a>
	}
	out((int)(remainder + 48), ctx);
   268f2:	4641      	mov	r1, r8
   268f4:	f106 0030 	add.w	r0, r6, #48	; 0x30
   268f8:	47d0      	blx	sl

	if (padding == PAD_SPACE_AFTER) {
   268fa:	f1bb 0f03 	cmp.w	fp, #3
   268fe:	d102      	bne.n	26906 <_printk_dec_ulong+0x6a>
		remaining = min_width - digits;
   26900:	1b64      	subs	r4, r4, r5
		while (remaining-- > 0) {
   26902:	2c00      	cmp	r4, #0
   26904:	dc0e      	bgt.n	26924 <_printk_dec_ulong+0x88>
			out(' ', ctx);
		}
	}
}
   26906:	b005      	add	sp, #20
   26908:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
   2690c:	42bc      	cmp	r4, r7
   2690e:	dbe7      	blt.n	268e0 <_printk_dec_ulong+0x44>
				&& padding < PAD_SPACE_AFTER) {
   26910:	f1bb 0f02 	cmp.w	fp, #2
   26914:	d8e4      	bhi.n	268e0 <_printk_dec_ulong+0x44>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
   26916:	4641      	mov	r1, r8
   26918:	9802      	ldr	r0, [sp, #8]
   2691a:	9203      	str	r2, [sp, #12]
			digits++;
   2691c:	3501      	adds	r5, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
   2691e:	47d0      	blx	sl
			digits++;
   26920:	9a03      	ldr	r2, [sp, #12]
   26922:	e7dd      	b.n	268e0 <_printk_dec_ulong+0x44>
			out(' ', ctx);
   26924:	4641      	mov	r1, r8
   26926:	2020      	movs	r0, #32
   26928:	47d0      	blx	sl
   2692a:	3c01      	subs	r4, #1
   2692c:	e7e9      	b.n	26902 <_printk_dec_ulong+0x66>
   2692e:	bf00      	nop
   26930:	3b9aca00 	.word	0x3b9aca00

00026934 <vprintk>:
	struct out_context ctx = { 0 };
   26934:	2300      	movs	r3, #0
{
   26936:	b507      	push	{r0, r1, r2, lr}
	z_vprintk(char_out, &ctx, fmt, ap);
   26938:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
   2693a:	9301      	str	r3, [sp, #4]
	z_vprintk(char_out, &ctx, fmt, ap);
   2693c:	4803      	ldr	r0, [pc, #12]	; (2694c <vprintk+0x18>)
   2693e:	460b      	mov	r3, r1
   26940:	a901      	add	r1, sp, #4
   26942:	f015 fd83 	bl	3c44c <z_vprintk>
}
   26946:	b003      	add	sp, #12
   26948:	f85d fb04 	ldr.w	pc, [sp], #4
   2694c:	0002688d 	.word	0x0002688d

00026950 <nordicsemi_nrf91_init>:
	__asm__ volatile(
   26950:	f04f 0220 	mov.w	r2, #32
   26954:	f3ef 8311 	mrs	r3, BASEPRI
   26958:	f382 8811 	msr	BASEPRI, r2
   2695c:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
   26960:	2101      	movs	r1, #1
   26962:	4a04      	ldr	r2, [pc, #16]	; (26974 <nordicsemi_nrf91_init+0x24>)
   26964:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
   26968:	f383 8811 	msr	BASEPRI, r3
   2696c:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
   26970:	2000      	movs	r0, #0
   26972:	4770      	bx	lr
   26974:	40039000 	.word	0x40039000

00026978 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   26978:	b120      	cbz	r0, 26984 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   2697a:	4b03      	ldr	r3, [pc, #12]	; (26988 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
   2697c:	0180      	lsls	r0, r0, #6
   2697e:	f043 0301 	orr.w	r3, r3, #1
   26982:	4718      	bx	r3

void arch_busy_wait(u32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
   26984:	4770      	bx	lr
   26986:	bf00      	nop
   26988:	0003fbe0 	.word	0x0003fbe0

0002698c <log_generic>:
	if (_is_user_context()) {
		log_generic_from_user(src_level, fmt, ap);
	} else  if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) &&
	    (!IS_ENABLED(CONFIG_LOG_FRONTEND))) {
		struct log_backend const *backend;
		u32_t timestamp = timestamp_func();
   2698c:	4b13      	ldr	r3, [pc, #76]	; (269dc <log_generic+0x50>)
{
   2698e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		u32_t timestamp = timestamp_func();
   26992:	681b      	ldr	r3, [r3, #0]
{
   26994:	4680      	mov	r8, r0
   26996:	4689      	mov	r9, r1
   26998:	4692      	mov	sl, r2
		u32_t timestamp = timestamp_func();
   2699a:	4798      	blx	r3

		for (int i = 0; i < log_backend_count_get(); i++) {
   2699c:	2600      	movs	r6, #0
		u32_t timestamp = timestamp_func();
   2699e:	4607      	mov	r7, r0
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
   269a0:	4c0f      	ldr	r4, [pc, #60]	; (269e0 <log_generic+0x54>)
   269a2:	4d10      	ldr	r5, [pc, #64]	; (269e4 <log_generic+0x58>)
   269a4:	1b2d      	subs	r5, r5, r4
   269a6:	112d      	asrs	r5, r5, #4
		for (int i = 0; i < log_backend_count_get(); i++) {
   269a8:	42ae      	cmp	r6, r5
   269aa:	db02      	blt.n	269b2 <log_generic+0x26>
			args[i] = va_arg(ap, log_arg_t);
		}

		log_n(fmt, args, nargs, src_level);
	}
}
   269ac:	b003      	add	sp, #12
   269ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (log_backend_is_active(backend)) {
   269b2:	4620      	mov	r0, r4
   269b4:	f015 ff0a 	bl	3c7cc <log_backend_is_active>
   269b8:	b160      	cbz	r0, 269d4 <log_generic+0x48>
	if (backend->api->put_sync_string) {
   269ba:	6823      	ldr	r3, [r4, #0]
   269bc:	f8d3 b004 	ldr.w	fp, [r3, #4]
   269c0:	f1bb 0f00 	cmp.w	fp, #0
   269c4:	d006      	beq.n	269d4 <log_generic+0x48>
		backend->api->put_sync_string(backend, src_level,
   269c6:	f8cd a000 	str.w	sl, [sp]
   269ca:	464b      	mov	r3, r9
   269cc:	463a      	mov	r2, r7
   269ce:	4641      	mov	r1, r8
   269d0:	4620      	mov	r0, r4
   269d2:	47d8      	blx	fp
		for (int i = 0; i < log_backend_count_get(); i++) {
   269d4:	3601      	adds	r6, #1
   269d6:	3410      	adds	r4, #16
   269d8:	e7e6      	b.n	269a8 <log_generic+0x1c>
   269da:	bf00      	nop
   269dc:	200345d0 	.word	0x200345d0
   269e0:	0003fa04 	.word	0x0003fa04
   269e4:	0003fa14 	.word	0x0003fa14

000269e8 <log_core_init>:
	/* Set default timestamp. */
	if (sys_clock_hw_cycles_per_sec() > 1000000) {
		timestamp_func = k_uptime_get_32;
		freq = 1000;
	} else {
		timestamp_func = k_cycle_get_32_wrapper;
   269e8:	4b03      	ldr	r3, [pc, #12]	; (269f8 <log_core_init+0x10>)
   269ea:	4a04      	ldr	r2, [pc, #16]	; (269fc <log_core_init+0x14>)
		freq = sys_clock_hw_cycles_per_sec();
	}

	log_output_timestamp_freq_set(freq);
   269ec:	f44f 4000 	mov.w	r0, #32768	; 0x8000
		timestamp_func = k_cycle_get_32_wrapper;
   269f0:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
   269f2:	f000 ba35 	b.w	26e60 <log_output_timestamp_freq_set>
   269f6:	bf00      	nop
   269f8:	200345d0 	.word	0x200345d0
   269fc:	0003c7d3 	.word	0x0003c7d3

00026a00 <log_source_name_get>:
   26a00:	4a04      	ldr	r2, [pc, #16]	; (26a14 <log_source_name_get+0x14>)
   26a02:	4b05      	ldr	r3, [pc, #20]	; (26a18 <log_source_name_get+0x18>)
   26a04:	1a9b      	subs	r3, r3, r2
	return log_sources_count();
}

const char *log_source_name_get(u32_t domain_id, u32_t src_id)
{
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
   26a06:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
   26a0a:	bf34      	ite	cc
   26a0c:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
   26a10:	2000      	movcs	r0, #0
}
   26a12:	4770      	bx	lr
   26a14:	0003f8d4 	.word	0x0003f8d4
   26a18:	0003fa04 	.word	0x0003fa04

00026a1c <log_backend_enable>:
}

void log_backend_enable(struct log_backend const *const backend,
			void *ctx,
			u32_t level)
{
   26a1c:	b570      	push	{r4, r5, r6, lr}
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	u32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
   26a1e:	4c10      	ldr	r4, [pc, #64]	; (26a60 <log_backend_enable+0x44>)
{
   26a20:	4605      	mov	r5, r0
	id += backend - log_backend_get(0);
   26a22:	1b04      	subs	r4, r0, r4
   26a24:	1124      	asrs	r4, r4, #4
   26a26:	3401      	adds	r4, #1
{
   26a28:	460e      	mov	r6, r1

	log_backend_id_set(backend, id);
   26a2a:	b2e4      	uxtb	r4, r4
	__ASSERT_NO_MSG(backend != NULL);
   26a2c:	b948      	cbnz	r0, 26a42 <log_backend_enable+0x26>
   26a2e:	490d      	ldr	r1, [pc, #52]	; (26a64 <log_backend_enable+0x48>)
   26a30:	480d      	ldr	r0, [pc, #52]	; (26a68 <log_backend_enable+0x4c>)
   26a32:	23c0      	movs	r3, #192	; 0xc0
   26a34:	4a0d      	ldr	r2, [pc, #52]	; (26a6c <log_backend_enable+0x50>)
   26a36:	f015 fe79 	bl	3c72c <printk>
   26a3a:	21c0      	movs	r1, #192	; 0xc0
   26a3c:	480b      	ldr	r0, [pc, #44]	; (26a6c <log_backend_enable+0x50>)
   26a3e:	f015 febb 	bl	3c7b8 <assert_post_action>
static inline void log_backend_activate(const struct log_backend *const backend,
					void *ctx)
{
	__ASSERT_NO_MSG(backend != NULL);
	backend->cb->ctx = ctx;
	backend->cb->active = true;
   26a42:	2201      	movs	r2, #1
	backend->cb->id = id;
   26a44:	686b      	ldr	r3, [r5, #4]
   26a46:	711c      	strb	r4, [r3, #4]
	log_backend_activate(backend, ctx);

	/* Wakeup logger thread after attaching first backend. It might be
	 * blocked with log messages pending.
	 */
	if (!backend_attached) {
   26a48:	4c09      	ldr	r4, [pc, #36]	; (26a70 <log_backend_enable+0x54>)
	backend->cb->active = true;
   26a4a:	715a      	strb	r2, [r3, #5]
   26a4c:	7822      	ldrb	r2, [r4, #0]
	backend->cb->ctx = ctx;
   26a4e:	601e      	str	r6, [r3, #0]
   26a50:	b912      	cbnz	r2, 26a58 <log_backend_enable+0x3c>
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
   26a52:	4808      	ldr	r0, [pc, #32]	; (26a74 <log_backend_enable+0x58>)
   26a54:	f010 ff76 	bl	37944 <z_impl_k_sem_give>
		k_sem_give(&log_process_thread_sem);
	}

	backend_attached = true;
   26a58:	2301      	movs	r3, #1
   26a5a:	7023      	strb	r3, [r4, #0]
}
   26a5c:	bd70      	pop	{r4, r5, r6, pc}
   26a5e:	bf00      	nop
   26a60:	0003fa04 	.word	0x0003fa04
   26a64:	00041a09 	.word	0x00041a09
   26a68:	00040606 	.word	0x00040606
   26a6c:	000419d8 	.word	0x000419d8
   26a70:	2002c3af 	.word	0x2002c3af
   26a74:	20037a94 	.word	0x20037a94

00026a78 <log_init>:
{
   26a78:	b570      	push	{r4, r5, r6, lr}
	return __log_backends_end - __log_backends_start;
   26a7a:	4b13      	ldr	r3, [pc, #76]	; (26ac8 <log_init+0x50>)
   26a7c:	4c13      	ldr	r4, [pc, #76]	; (26acc <log_init+0x54>)
   26a7e:	1b1b      	subs	r3, r3, r4
	assert(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
   26a80:	2b90      	cmp	r3, #144	; 0x90
   26a82:	dd06      	ble.n	26a92 <log_init+0x1a>
   26a84:	4b12      	ldr	r3, [pc, #72]	; (26ad0 <log_init+0x58>)
   26a86:	4a13      	ldr	r2, [pc, #76]	; (26ad4 <log_init+0x5c>)
   26a88:	f240 11ed 	movw	r1, #493	; 0x1ed
   26a8c:	4812      	ldr	r0, [pc, #72]	; (26ad8 <log_init+0x60>)
   26a8e:	f012 fb7f 	bl	39190 <__assert_func>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   26a92:	4a12      	ldr	r2, [pc, #72]	; (26adc <log_init+0x64>)
   26a94:	e8d2 6fef 	ldaex	r6, [r2]
   26a98:	1c71      	adds	r1, r6, #1
   26a9a:	e8c2 1fe0 	stlex	r0, r1, [r2]
   26a9e:	2800      	cmp	r0, #0
   26aa0:	d1f8      	bne.n	26a94 <log_init+0x1c>
	if (atomic_inc(&initialized) != 0) {
   26aa2:	b916      	cbnz	r6, 26aaa <log_init+0x32>
   26aa4:	111d      	asrs	r5, r3, #4
	for (i = 0; i < log_backend_count_get(); i++) {
   26aa6:	42ae      	cmp	r6, r5
   26aa8:	db00      	blt.n	26aac <log_init+0x34>
}
   26aaa:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
   26aac:	7b23      	ldrb	r3, [r4, #12]
   26aae:	b143      	cbz	r3, 26ac2 <log_init+0x4a>
			if (backend->api->init != NULL) {
   26ab0:	6823      	ldr	r3, [r4, #0]
   26ab2:	695b      	ldr	r3, [r3, #20]
   26ab4:	b103      	cbz	r3, 26ab8 <log_init+0x40>
				backend->api->init();
   26ab6:	4798      	blx	r3
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
   26ab8:	2204      	movs	r2, #4
   26aba:	2100      	movs	r1, #0
   26abc:	4620      	mov	r0, r4
   26abe:	f7ff ffad 	bl	26a1c <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
   26ac2:	3601      	adds	r6, #1
   26ac4:	3410      	adds	r4, #16
   26ac6:	e7ee      	b.n	26aa6 <log_init+0x2e>
   26ac8:	0003fa14 	.word	0x0003fa14
   26acc:	0003fa04 	.word	0x0003fa04
   26ad0:	00041a20 	.word	0x00041a20
   26ad4:	000419cf 	.word	0x000419cf
   26ad8:	00041a57 	.word	0x00041a57
   26adc:	20024acc 	.word	0x20024acc

00026ae0 <z_impl_log_panic>:
{
   26ae0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
   26ae2:	4f0c      	ldr	r7, [pc, #48]	; (26b14 <z_impl_log_panic+0x34>)
   26ae4:	783d      	ldrb	r5, [r7, #0]
   26ae6:	b94d      	cbnz	r5, 26afc <z_impl_log_panic+0x1c>
	log_init();
   26ae8:	f7ff ffc6 	bl	26a78 <log_init>
   26aec:	4c0a      	ldr	r4, [pc, #40]	; (26b18 <z_impl_log_panic+0x38>)
   26aee:	4e0b      	ldr	r6, [pc, #44]	; (26b1c <z_impl_log_panic+0x3c>)
   26af0:	1b36      	subs	r6, r6, r4
   26af2:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   26af4:	42b5      	cmp	r5, r6
   26af6:	db02      	blt.n	26afe <z_impl_log_panic+0x1e>
	panic_mode = true;
   26af8:	2301      	movs	r3, #1
   26afa:	703b      	strb	r3, [r7, #0]
}
   26afc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (log_backend_is_active(backend)) {
   26afe:	4620      	mov	r0, r4
   26b00:	f015 fe64 	bl	3c7cc <log_backend_is_active>
   26b04:	b118      	cbz	r0, 26b0e <z_impl_log_panic+0x2e>
	backend->api->panic(backend);
   26b06:	6823      	ldr	r3, [r4, #0]
   26b08:	4620      	mov	r0, r4
   26b0a:	691b      	ldr	r3, [r3, #16]
   26b0c:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   26b0e:	3501      	adds	r5, #1
   26b10:	3410      	adds	r4, #16
   26b12:	e7ef      	b.n	26af4 <z_impl_log_panic+0x14>
   26b14:	2002c3b0 	.word	0x2002c3b0
   26b18:	0003fa04 	.word	0x0003fa04
   26b1c:	0003fa14 	.word	0x0003fa14

00026b20 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *log_output,
			   const char *fmt, ...)
{
   26b20:	b40e      	push	{r1, r2, r3}
   26b22:	b503      	push	{r0, r1, lr}
   26b24:	ab03      	add	r3, sp, #12
   26b26:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(args, fmt);
#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, args);
#else
	z_vprintk(out_func, (void *)log_output, fmt, args);
   26b2a:	4601      	mov	r1, r0
   26b2c:	4804      	ldr	r0, [pc, #16]	; (26b40 <print_formatted+0x20>)
	va_start(args, fmt);
   26b2e:	9301      	str	r3, [sp, #4]
	z_vprintk(out_func, (void *)log_output, fmt, args);
   26b30:	f015 fc8c 	bl	3c44c <z_vprintk>
#endif
	va_end(args);

	return length;
}
   26b34:	2000      	movs	r0, #0
   26b36:	b002      	add	sp, #8
   26b38:	f85d eb04 	ldr.w	lr, [sp], #4
   26b3c:	b003      	add	sp, #12
   26b3e:	4770      	bx	lr
   26b40:	0003c801 	.word	0x0003c801

00026b44 <prefix_print>:
}

static u32_t prefix_print(const struct log_output *log_output,
			 u32_t flags, bool func_on, u32_t timestamp, u8_t level,
			 u8_t domain_id, u16_t source_id)
{
   26b44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
   26b48:	f011 0402 	ands.w	r4, r1, #2
{
   26b4c:	b085      	sub	sp, #20
   26b4e:	4606      	mov	r6, r0
   26b50:	4690      	mov	r8, r2
   26b52:	f89d 7038 	ldrb.w	r7, [sp, #56]	; 0x38
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   26b56:	f001 0901 	and.w	r9, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
   26b5a:	f001 0508 	and.w	r5, r1, #8
	if (stamp) {
   26b5e:	d007      	beq.n	26b70 <prefix_print+0x2c>
	if (!format) {
   26b60:	f011 0f44 	tst.w	r1, #68	; 0x44
   26b64:	d137      	bne.n	26bd6 <prefix_print+0x92>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
   26b66:	461a      	mov	r2, r3
   26b68:	4932      	ldr	r1, [pc, #200]	; (26c34 <prefix_print+0xf0>)
   26b6a:	f7ff ffd9 	bl	26b20 <print_formatted>
		length += timestamp_print(log_output, flags, timestamp);
   26b6e:	4604      	mov	r4, r0
	if (color) {
   26b70:	f1b9 0f00 	cmp.w	r9, #0
   26b74:	d00a      	beq.n	26b8c <prefix_print+0x48>
		const char *color = start && (colors[level] != NULL) ?
   26b76:	4b30      	ldr	r3, [pc, #192]	; (26c38 <prefix_print+0xf4>)
		print_formatted(log_output, "%s", color);
   26b78:	4930      	ldr	r1, [pc, #192]	; (26c3c <prefix_print+0xf8>)
		const char *color = start && (colors[level] != NULL) ?
   26b7a:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
		print_formatted(log_output, "%s", color);
   26b7e:	4b30      	ldr	r3, [pc, #192]	; (26c40 <prefix_print+0xfc>)
   26b80:	4630      	mov	r0, r6
   26b82:	2a00      	cmp	r2, #0
   26b84:	bf08      	it	eq
   26b86:	461a      	moveq	r2, r3
   26b88:	f7ff ffca 	bl	26b20 <print_formatted>
	if (level_on) {
   26b8c:	b13d      	cbz	r5, 26b9e <prefix_print+0x5a>
		total += print_formatted(log_output, "<%s> ", severity[level]);
   26b8e:	4b2d      	ldr	r3, [pc, #180]	; (26c44 <prefix_print+0x100>)
   26b90:	492d      	ldr	r1, [pc, #180]	; (26c48 <prefix_print+0x104>)
   26b92:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
   26b96:	4630      	mov	r0, r6
   26b98:	f7ff ffc2 	bl	26b20 <print_formatted>
   26b9c:	4605      	mov	r5, r0
	total += print_formatted(log_output,
   26b9e:	f1b8 0f00 	cmp.w	r8, #0
   26ba2:	d044      	beq.n	26c2e <prefix_print+0xea>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
   26ba4:	2301      	movs	r3, #1
   26ba6:	fa03 f707 	lsl.w	r7, r3, r7
	total += print_formatted(log_output,
   26baa:	4b28      	ldr	r3, [pc, #160]	; (26c4c <prefix_print+0x108>)
   26bac:	f017 0f10 	tst.w	r7, #16
   26bb0:	4f27      	ldr	r7, [pc, #156]	; (26c50 <prefix_print+0x10c>)
   26bb2:	bf18      	it	ne
   26bb4:	461f      	movne	r7, r3
   26bb6:	f8bd 1040 	ldrh.w	r1, [sp, #64]	; 0x40
   26bba:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
   26bbe:	f7ff ff1f 	bl	26a00 <log_source_name_get>
   26bc2:	4639      	mov	r1, r7
   26bc4:	4602      	mov	r2, r0
   26bc6:	4630      	mov	r0, r6
   26bc8:	f7ff ffaa 	bl	26b20 <print_formatted>
   26bcc:	4428      	add	r0, r5
		length += ids_print(log_output, level_on, func_on,
				    domain_id, source_id, level);
	}

	return length;
}
   26bce:	4420      	add	r0, r4
   26bd0:	b005      	add	sp, #20
   26bd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (freq != 0U) {
   26bd6:	4a1f      	ldr	r2, [pc, #124]	; (26c54 <prefix_print+0x110>)
   26bd8:	6811      	ldr	r1, [r2, #0]
   26bda:	b331      	cbz	r1, 26c2a <prefix_print+0xe6>
		timestamp /= timestamp_div;
   26bdc:	4a1e      	ldr	r2, [pc, #120]	; (26c58 <prefix_print+0x114>)
   26bde:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
   26be2:	6814      	ldr	r4, [r2, #0]
		ms = (remainder * 1000U) / freq;
   26be4:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
		timestamp /= timestamp_div;
   26be8:	fbb3 f3f4 	udiv	r3, r3, r4
		seconds = timestamp / freq;
   26bec:	fbb3 f4f1 	udiv	r4, r3, r1
		seconds -= hours * 3600U;
   26bf0:	fbb4 f2fe 	udiv	r2, r4, lr
   26bf4:	fb0e 4e12 	mls	lr, lr, r2, r4
		remainder = timestamp % freq;
   26bf8:	fb01 3414 	mls	r4, r1, r4, r3
		ms = (remainder * 1000U) / freq;
   26bfc:	fb0c f404 	mul.w	r4, ip, r4
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   26c00:	fbb4 fbf1 	udiv	fp, r4, r1
		mins = seconds / 60U;
   26c04:	f04f 0a3c 	mov.w	sl, #60	; 0x3c
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   26c08:	fb01 441b 	mls	r4, r1, fp, r4
   26c0c:	fb0c f404 	mul.w	r4, ip, r4
		mins = seconds / 60U;
   26c10:	fbbe f3fa 	udiv	r3, lr, sl
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   26c14:	fbb4 f1f1 	udiv	r1, r4, r1
			length = print_formatted(log_output,
   26c18:	e9cd b101 	strd	fp, r1, [sp, #4]
   26c1c:	fb0a e113 	mls	r1, sl, r3, lr
   26c20:	9100      	str	r1, [sp, #0]
   26c22:	490e      	ldr	r1, [pc, #56]	; (26c5c <prefix_print+0x118>)
   26c24:	f7ff ff7c 	bl	26b20 <print_formatted>
   26c28:	e7a1      	b.n	26b6e <prefix_print+0x2a>
		length = 0;
   26c2a:	4608      	mov	r0, r1
   26c2c:	e79f      	b.n	26b6e <prefix_print+0x2a>
	total += print_formatted(log_output,
   26c2e:	4f08      	ldr	r7, [pc, #32]	; (26c50 <prefix_print+0x10c>)
   26c30:	e7c1      	b.n	26bb6 <prefix_print+0x72>
   26c32:	bf00      	nop
   26c34:	00041af7 	.word	0x00041af7
   26c38:	0003fe08 	.word	0x0003fe08
   26c3c:	00042b08 	.word	0x00042b08
   26c40:	00041ae9 	.word	0x00041ae9
   26c44:	0003fe1c 	.word	0x0003fe1c
   26c48:	00041b1c 	.word	0x00041b1c
   26c4c:	00041af3 	.word	0x00041af3
   26c50:	00041aee 	.word	0x00041aee
   26c54:	20024ad0 	.word	0x20024ad0
   26c58:	20024ad4 	.word	0x20024ad4
   26c5c:	00041b00 	.word	0x00041b00

00026c60 <postfix_print>:

static void postfix_print(const struct log_output *log_output,
			  u32_t flags, u8_t level)
{
   26c60:	b538      	push	{r3, r4, r5, lr}
   26c62:	460c      	mov	r4, r1
	if (color) {
   26c64:	07e1      	lsls	r1, r4, #31
{
   26c66:	4605      	mov	r5, r0
	if (color) {
   26c68:	d503      	bpl.n	26c72 <postfix_print+0x12>
		print_formatted(log_output, "%s", color);
   26c6a:	4a08      	ldr	r2, [pc, #32]	; (26c8c <postfix_print+0x2c>)
   26c6c:	4908      	ldr	r1, [pc, #32]	; (26c90 <postfix_print+0x30>)
   26c6e:	f7ff ff57 	bl	26b20 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   26c72:	06e2      	lsls	r2, r4, #27
   26c74:	d408      	bmi.n	26c88 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   26c76:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
   26c78:	4628      	mov	r0, r5
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(log_output, flags);
}
   26c7a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\n");
   26c7e:	bf4c      	ite	mi
   26c80:	4904      	ldrmi	r1, [pc, #16]	; (26c94 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
   26c82:	4905      	ldrpl	r1, [pc, #20]	; (26c98 <postfix_print+0x38>)
   26c84:	f7ff bf4c 	b.w	26b20 <print_formatted>
}
   26c88:	bd38      	pop	{r3, r4, r5, pc}
   26c8a:	bf00      	nop
   26c8c:	00041ae9 	.word	0x00041ae9
   26c90:	00042b08 	.word	0x00042b08
   26c94:	00042743 	.word	0x00042743
   26c98:	00043581 	.word	0x00043581

00026c9c <hexdump_line_print>:
{
   26c9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   26ca0:	4698      	mov	r8, r3
   26ca2:	9b08      	ldr	r3, [sp, #32]
   26ca4:	4604      	mov	r4, r0
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   26ca6:	06dd      	lsls	r5, r3, #27
{
   26ca8:	460e      	mov	r6, r1
   26caa:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   26cac:	d405      	bmi.n	26cba <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   26cae:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
   26cb0:	bf4c      	ite	mi
   26cb2:	492a      	ldrmi	r1, [pc, #168]	; (26d5c <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
   26cb4:	492a      	ldrpl	r1, [pc, #168]	; (26d60 <hexdump_line_print+0xc4>)
   26cb6:	f7ff ff33 	bl	26b20 <print_formatted>
{
   26cba:	2500      	movs	r5, #0
		print_formatted(log_output, " ");
   26cbc:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 26d68 <hexdump_line_print+0xcc>
	for (int i = 0; i < prefix_offset; i++) {
   26cc0:	4545      	cmp	r5, r8
   26cc2:	db2d      	blt.n	26d20 <hexdump_line_print+0x84>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   26cc4:	2500      	movs	r5, #0
			print_formatted(log_output, "   ");
   26cc6:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 26d6c <hexdump_line_print+0xd0>
			print_formatted(log_output, "%02x ", data[i]);
   26cca:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 26d70 <hexdump_line_print+0xd4>
			print_formatted(log_output, " ");
   26cce:	f8df a098 	ldr.w	sl, [pc, #152]	; 26d68 <hexdump_line_print+0xcc>
		if (i < length) {
   26cd2:	42bd      	cmp	r5, r7
   26cd4:	d231      	bcs.n	26d3a <hexdump_line_print+0x9e>
			print_formatted(log_output, "%02x ", data[i]);
   26cd6:	5d72      	ldrb	r2, [r6, r5]
   26cd8:	4649      	mov	r1, r9
   26cda:	4620      	mov	r0, r4
   26cdc:	f7ff ff20 	bl	26b20 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   26ce0:	3501      	adds	r5, #1
   26ce2:	2d10      	cmp	r5, #16
   26ce4:	d122      	bne.n	26d2c <hexdump_line_print+0x90>
	print_formatted(log_output, "|");
   26ce6:	491f      	ldr	r1, [pc, #124]	; (26d64 <hexdump_line_print+0xc8>)
   26ce8:	4620      	mov	r0, r4
   26cea:	f7ff ff19 	bl	26b20 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   26cee:	2500      	movs	r5, #0
			print_formatted(log_output, " ");
   26cf0:	f8df 8074 	ldr.w	r8, [pc, #116]	; 26d68 <hexdump_line_print+0xcc>
			      isprint((int)c) ? c : '.');
   26cf4:	f8df 907c 	ldr.w	r9, [pc, #124]	; 26d74 <hexdump_line_print+0xd8>
			print_formatted(log_output, "%c",
   26cf8:	f8df a07c 	ldr.w	sl, [pc, #124]	; 26d78 <hexdump_line_print+0xdc>
		if (i < length) {
   26cfc:	42af      	cmp	r7, r5
   26cfe:	d928      	bls.n	26d52 <hexdump_line_print+0xb6>
			char c = (char)data[i];
   26d00:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(log_output, "%c",
   26d02:	4651      	mov	r1, sl
   26d04:	f812 3009 	ldrb.w	r3, [r2, r9]
   26d08:	4620      	mov	r0, r4
   26d0a:	f013 0f97 	tst.w	r3, #151	; 0x97
   26d0e:	bf08      	it	eq
   26d10:	222e      	moveq	r2, #46	; 0x2e
   26d12:	f7ff ff05 	bl	26b20 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   26d16:	3501      	adds	r5, #1
   26d18:	2d10      	cmp	r5, #16
   26d1a:	d113      	bne.n	26d44 <hexdump_line_print+0xa8>
}
   26d1c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, " ");
   26d20:	4649      	mov	r1, r9
   26d22:	4620      	mov	r0, r4
   26d24:	f7ff fefc 	bl	26b20 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
   26d28:	3501      	adds	r5, #1
   26d2a:	e7c9      	b.n	26cc0 <hexdump_line_print+0x24>
		if (i > 0 && !(i % 8)) {
   26d2c:	076a      	lsls	r2, r5, #29
   26d2e:	d1d0      	bne.n	26cd2 <hexdump_line_print+0x36>
			print_formatted(log_output, " ");
   26d30:	4651      	mov	r1, sl
   26d32:	4620      	mov	r0, r4
   26d34:	f7ff fef4 	bl	26b20 <print_formatted>
   26d38:	e7cb      	b.n	26cd2 <hexdump_line_print+0x36>
			print_formatted(log_output, "   ");
   26d3a:	4641      	mov	r1, r8
   26d3c:	4620      	mov	r0, r4
   26d3e:	f7ff feef 	bl	26b20 <print_formatted>
   26d42:	e7cd      	b.n	26ce0 <hexdump_line_print+0x44>
		if (i > 0 && !(i % 8)) {
   26d44:	076b      	lsls	r3, r5, #29
   26d46:	d1d9      	bne.n	26cfc <hexdump_line_print+0x60>
			print_formatted(log_output, " ");
   26d48:	4641      	mov	r1, r8
   26d4a:	4620      	mov	r0, r4
   26d4c:	f7ff fee8 	bl	26b20 <print_formatted>
   26d50:	e7d4      	b.n	26cfc <hexdump_line_print+0x60>
			print_formatted(log_output, " ");
   26d52:	4641      	mov	r1, r8
   26d54:	4620      	mov	r0, r4
   26d56:	f7ff fee3 	bl	26b20 <print_formatted>
   26d5a:	e7dc      	b.n	26d16 <hexdump_line_print+0x7a>
   26d5c:	00042743 	.word	0x00042743
   26d60:	00043581 	.word	0x00043581
   26d64:	00041aa2 	.word	0x00041aa2
   26d68:	00040883 	.word	0x00040883
   26d6c:	00040881 	.word	0x00040881
   26d70:	00041a9c 	.word	0x00041a9c
   26d74:	00044327 	.word	0x00044327
   26d78:	00041aa4 	.word	0x00041aa4

00026d7c <log_output_string>:
}

void log_output_string(const struct log_output *log_output,
		       struct log_msg_ids src_level, u32_t timestamp,
		       const char *fmt, va_list ap, u32_t flags)
{
   26d7c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
		log_output_string_syst_process(log_output,
				src_level, fmt, ap, flags);
		return;
	}

	if (!raw_string) {
   26d80:	f011 0407 	ands.w	r4, r1, #7
{
   26d84:	4606      	mov	r6, r0
   26d86:	e9dd 870a 	ldrd	r8, r7, [sp, #40]	; 0x28
   26d8a:	461d      	mov	r5, r3
	if (!raw_string) {
   26d8c:	d00b      	beq.n	26da6 <log_output_string+0x2a>
		prefix_print(log_output, flags, true, timestamp,
   26d8e:	f3c1 1389 	ubfx	r3, r1, #6, #10
   26d92:	f3c1 01c2 	ubfx	r1, r1, #3, #3
   26d96:	9302      	str	r3, [sp, #8]
   26d98:	e9cd 4100 	strd	r4, r1, [sp]
   26d9c:	4613      	mov	r3, r2
   26d9e:	4639      	mov	r1, r7
   26da0:	2201      	movs	r2, #1
   26da2:	f7ff fecf 	bl	26b44 <prefix_print>

#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, ap);
#else
	z_vprintk(out_func, (void *)log_output, fmt, ap);
   26da6:	4643      	mov	r3, r8
   26da8:	462a      	mov	r2, r5
   26daa:	4631      	mov	r1, r6
   26dac:	480d      	ldr	r0, [pc, #52]	; (26de4 <log_output_string+0x68>)
   26dae:	f015 fb4d 	bl	3c44c <z_vprintk>
#endif

	(void)length;

	if (raw_string) {
   26db2:	b98c      	cbnz	r4, 26dd8 <log_output_string+0x5c>
   26db4:	3d01      	subs	r5, #1
	while (*fmt != '\0') {
   26db6:	f815 3f01 	ldrb.w	r3, [r5, #1]!
   26dba:	b95b      	cbnz	r3, 26dd4 <log_output_string+0x58>
		/* add \r if string ends with newline. */
		if (ends_with_newline(fmt)) {
   26dbc:	2c0a      	cmp	r4, #10
   26dbe:	d103      	bne.n	26dc8 <log_output_string+0x4c>
			print_formatted(log_output, "\r");
   26dc0:	4909      	ldr	r1, [pc, #36]	; (26de8 <log_output_string+0x6c>)
   26dc2:	4630      	mov	r0, r6
   26dc4:	f7ff feac 	bl	26b20 <print_formatted>
		}
	} else {
		postfix_print(log_output, flags, level);
	}

	log_output_flush(log_output);
   26dc8:	4630      	mov	r0, r6
}
   26dca:	b004      	add	sp, #16
   26dcc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	log_output_flush(log_output);
   26dd0:	f015 bd2f 	b.w	3c832 <log_output_flush>
	while (*fmt != '\0') {
   26dd4:	461c      	mov	r4, r3
   26dd6:	e7ee      	b.n	26db6 <log_output_string+0x3a>
		postfix_print(log_output, flags, level);
   26dd8:	4622      	mov	r2, r4
   26dda:	4639      	mov	r1, r7
   26ddc:	4630      	mov	r0, r6
   26dde:	f7ff ff3f 	bl	26c60 <postfix_print>
   26de2:	e7f1      	b.n	26dc8 <log_output_string+0x4c>
   26de4:	0003c801 	.word	0x0003c801
   26de8:	00041ae7 	.word	0x00041ae7

00026dec <log_output_hexdump>:

void log_output_hexdump(const struct log_output *log_output,
			     struct log_msg_ids src_level, u32_t timestamp,
			     const char *metadata, const u8_t *data,
			     u32_t length, u32_t flags)
{
   26dec:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   26df0:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   26df2:	4698      	mov	r8, r3
   26df4:	e9dd 750c 	ldrd	r7, r5, [sp, #48]	; 0x30
		log_output_hexdump_syst_process(log_output,
				src_level, data, length, flags);
		return;
	}

	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   26df8:	f3c1 1389 	ubfx	r3, r1, #6, #10
	u8_t level = (u8_t)src_level.level;
   26dfc:	f001 0907 	and.w	r9, r1, #7
	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   26e00:	f3c1 01c2 	ubfx	r1, r1, #3, #3
   26e04:	9302      	str	r3, [sp, #8]
   26e06:	e9cd 9100 	strd	r9, r1, [sp]
   26e0a:	4613      	mov	r3, r2
   26e0c:	4631      	mov	r1, r6
   26e0e:	2201      	movs	r2, #1
{
   26e10:	4604      	mov	r4, r0
	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   26e12:	f7ff fe97 	bl	26b44 <prefix_print>
				     level, domain_id, source_id);

	/* Print metadata */
	print_formatted(log_output, "%s", metadata);
   26e16:	4642      	mov	r2, r8
	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   26e18:	4682      	mov	sl, r0
	print_formatted(log_output, "%s", metadata);
   26e1a:	4910      	ldr	r1, [pc, #64]	; (26e5c <log_output_hexdump+0x70>)
   26e1c:	4620      	mov	r0, r4
   26e1e:	f7ff fe7f 	bl	26b20 <print_formatted>

	while (length) {
   26e22:	b955      	cbnz	r5, 26e3a <log_output_hexdump+0x4e>

		data += part_len;
		length -= part_len;
	};

	postfix_print(log_output, flags, level);
   26e24:	4620      	mov	r0, r4
   26e26:	464a      	mov	r2, r9
   26e28:	4631      	mov	r1, r6
   26e2a:	f7ff ff19 	bl	26c60 <postfix_print>
	log_output_flush(log_output);
   26e2e:	4620      	mov	r0, r4
}
   26e30:	b004      	add	sp, #16
   26e32:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	log_output_flush(log_output);
   26e36:	f015 bcfc 	b.w	3c832 <log_output_flush>
		u32_t part_len = length > HEXDUMP_BYTES_IN_LINE ?
   26e3a:	2d10      	cmp	r5, #16
   26e3c:	46a8      	mov	r8, r5
   26e3e:	bf28      	it	cs
   26e40:	f04f 0810 	movcs.w	r8, #16
		hexdump_line_print(log_output, data, part_len,
   26e44:	4639      	mov	r1, r7
   26e46:	9600      	str	r6, [sp, #0]
   26e48:	4653      	mov	r3, sl
   26e4a:	4642      	mov	r2, r8
   26e4c:	4620      	mov	r0, r4
   26e4e:	f7ff ff25 	bl	26c9c <hexdump_line_print>
		data += part_len;
   26e52:	4447      	add	r7, r8
		length -= part_len;
   26e54:	eba5 0508 	sub.w	r5, r5, r8
   26e58:	e7e3      	b.n	26e22 <log_output_hexdump+0x36>
   26e5a:	bf00      	nop
   26e5c:	00042b08 	.word	0x00042b08

00026e60 <log_output_timestamp_freq_set>:
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
}

void log_output_timestamp_freq_set(u32_t frequency)
{
	timestamp_div = 1U;
   26e60:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
   26e62:	2100      	movs	r1, #0
	timestamp_div = 1U;
   26e64:	4a07      	ldr	r2, [pc, #28]	; (26e84 <log_output_timestamp_freq_set+0x24>)
{
   26e66:	b510      	push	{r4, lr}
	while (frequency > 1000000) {
   26e68:	4c07      	ldr	r4, [pc, #28]	; (26e88 <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
   26e6a:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
   26e6c:	42a0      	cmp	r0, r4
   26e6e:	d804      	bhi.n	26e7a <log_output_timestamp_freq_set+0x1a>
   26e70:	b101      	cbz	r1, 26e74 <log_output_timestamp_freq_set+0x14>
   26e72:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
   26e74:	4b05      	ldr	r3, [pc, #20]	; (26e8c <log_output_timestamp_freq_set+0x2c>)
   26e76:	6018      	str	r0, [r3, #0]
}
   26e78:	bd10      	pop	{r4, pc}
		frequency /= 2U;
   26e7a:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
   26e7c:	005b      	lsls	r3, r3, #1
   26e7e:	2101      	movs	r1, #1
   26e80:	e7f4      	b.n	26e6c <log_output_timestamp_freq_set+0xc>
   26e82:	bf00      	nop
   26e84:	20024ad4 	.word	0x20024ad4
   26e88:	000f4240 	.word	0x000f4240
   26e8c:	20024ad0 	.word	0x20024ad0

00026e90 <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
   26e90:	2201      	movs	r2, #1
   26e92:	4b01      	ldr	r3, [pc, #4]	; (26e98 <log_backend_rtt_init+0x8>)
   26e94:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
   26e96:	4770      	bx	lr
   26e98:	2002c3b2 	.word	0x2002c3b2

00026e9c <panic>:

static void panic(struct log_backend const *const backend)
{
   26e9c:	b508      	push	{r3, lr}
 * @param log_output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const log_output)
{
	log_output_flush(log_output);
   26e9e:	4803      	ldr	r0, [pc, #12]	; (26eac <panic+0x10>)
   26ea0:	f015 fcc7 	bl	3c832 <log_output_flush>
	log_backend_std_panic(&log_output);
	panic_mode = true;
   26ea4:	2201      	movs	r2, #1
   26ea6:	4b02      	ldr	r3, [pc, #8]	; (26eb0 <panic+0x14>)
   26ea8:	701a      	strb	r2, [r3, #0]
}
   26eaa:	bd08      	pop	{r3, pc}
   26eac:	0003fe48 	.word	0x0003fe48
   26eb0:	2002c3b3 	.word	0x2002c3b3

00026eb4 <sync_hexdump>:
}

static void sync_hexdump(const struct log_backend *const backend,
			 struct log_msg_ids src_level, u32_t timestamp,
			 const char *metadata, const u8_t *data, u32_t length)
{
   26eb4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		 * by another one, lock context for whole log processing.
		 */
		key = irq_lock();
	}

	log_output_hexdump(log_output, src_level, timestamp,
   26eb6:	200a      	movs	r0, #10
   26eb8:	9002      	str	r0, [sp, #8]
   26eba:	9807      	ldr	r0, [sp, #28]
   26ebc:	9001      	str	r0, [sp, #4]
   26ebe:	9806      	ldr	r0, [sp, #24]
   26ec0:	9000      	str	r0, [sp, #0]
   26ec2:	4803      	ldr	r0, [pc, #12]	; (26ed0 <sync_hexdump+0x1c>)
   26ec4:	f7ff ff92 	bl	26dec <log_output_hexdump>
	u32_t flag = IS_ENABLED(CONFIG_LOG_BACKEND_RTT_SYST_ENABLE) ?
		LOG_OUTPUT_FLAG_FORMAT_SYST : 0;

	log_backend_std_sync_hexdump(&log_output, flag, src_level,
				     timestamp, metadata, data, length);
}
   26ec8:	b005      	add	sp, #20
   26eca:	f85d fb04 	ldr.w	pc, [sp], #4
   26ece:	bf00      	nop
   26ed0:	0003fe48 	.word	0x0003fe48

00026ed4 <sync_string>:
{
   26ed4:	b507      	push	{r0, r1, r2, lr}
	log_output_string(log_output, src_level, timestamp, fmt, ap, flags);
   26ed6:	200a      	movs	r0, #10
   26ed8:	9001      	str	r0, [sp, #4]
   26eda:	9804      	ldr	r0, [sp, #16]
   26edc:	9000      	str	r0, [sp, #0]
   26ede:	4803      	ldr	r0, [pc, #12]	; (26eec <sync_string+0x18>)
   26ee0:	f7ff ff4c 	bl	26d7c <log_output_string>
}
   26ee4:	b003      	add	sp, #12
   26ee6:	f85d fb04 	ldr.w	pc, [sp], #4
   26eea:	bf00      	nop
   26eec:	0003fe48 	.word	0x0003fe48

00026ef0 <data_out_drop_mode>:
{
   26ef0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   26ef2:	4607      	mov	r7, r0
   26ef4:	460e      	mov	r6, r1
	int retry_cnt = CONFIG_LOG_BACKEND_RTT_RETRY_CNT;
   26ef6:	240a      	movs	r4, #10
   26ef8:	4d17      	ldr	r5, [pc, #92]	; (26f58 <data_out_drop_mode+0x68>)
		ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
   26efa:	4632      	mov	r2, r6
   26efc:	4639      	mov	r1, r7
   26efe:	2000      	movs	r0, #0
   26f00:	f000 ffee 	bl	27ee0 <SEGGER_RTT_WriteSkipNoLock>
		if (ret) {
   26f04:	b1c8      	cbz	r0, 26f3a <data_out_drop_mode+0x4a>
	host_present = true;
   26f06:	2301      	movs	r3, #1
   26f08:	702b      	strb	r3, [r5, #0]
	return panic_mode;
   26f0a:	4b14      	ldr	r3, [pc, #80]	; (26f5c <data_out_drop_mode+0x6c>)
	if (is_panic_mode()) {
   26f0c:	781b      	ldrb	r3, [r3, #0]
   26f0e:	b92b      	cbnz	r3, 26f1c <data_out_drop_mode+0x2c>
}
   26f10:	4630      	mov	r0, r6
   26f12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (retry_cnt == 0) {
   26f14:	b95c      	cbnz	r4, 26f2e <data_out_drop_mode+0x3e>
		host_present = false;
   26f16:	702c      	strb	r4, [r5, #0]
   26f18:	f04f 34ff 	mov.w	r4, #4294967295
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
   26f1c:	2000      	movs	r0, #0
   26f1e:	f001 f82b 	bl	27f78 <SEGGER_RTT_HasDataUp>
   26f22:	2800      	cmp	r0, #0
   26f24:	d0f4      	beq.n	26f10 <data_out_drop_mode+0x20>
   26f26:	782b      	ldrb	r3, [r5, #0]
   26f28:	2b00      	cmp	r3, #0
   26f2a:	d1f3      	bne.n	26f14 <data_out_drop_mode+0x24>
   26f2c:	e7f0      	b.n	26f10 <data_out_drop_mode+0x20>
			on_failed_write(retry_cnt--);
   26f2e:	3c01      	subs	r4, #1
	z_impl_k_busy_wait(usec_to_wait);
   26f30:	f242 7010 	movw	r0, #10000	; 0x2710
   26f34:	f017 fb50 	bl	3e5d8 <z_impl_k_busy_wait>
   26f38:	e7f0      	b.n	26f1c <data_out_drop_mode+0x2c>
		} else if (host_present) {
   26f3a:	782b      	ldrb	r3, [r5, #0]
   26f3c:	b113      	cbz	r3, 26f44 <data_out_drop_mode+0x54>
	if (retry_cnt == 0) {
   26f3e:	3c01      	subs	r4, #1
   26f40:	d104      	bne.n	26f4c <data_out_drop_mode+0x5c>
		host_present = false;
   26f42:	702c      	strb	r4, [r5, #0]
	} while ((ret == 0) && host_present);
   26f44:	782b      	ldrb	r3, [r5, #0]
   26f46:	2b00      	cmp	r3, #0
   26f48:	d1d7      	bne.n	26efa <data_out_drop_mode+0xa>
   26f4a:	e7e1      	b.n	26f10 <data_out_drop_mode+0x20>
   26f4c:	f242 7010 	movw	r0, #10000	; 0x2710
   26f50:	f017 fb42 	bl	3e5d8 <z_impl_k_busy_wait>
   26f54:	e7f6      	b.n	26f44 <data_out_drop_mode+0x54>
   26f56:	bf00      	nop
   26f58:	2002c3b2 	.word	0x2002c3b2
   26f5c:	2002c3b3 	.word	0x2002c3b3

00026f60 <nvs_flash_erase_sector>:

/* erase a sector by first checking it is used and then erasing if required
 * return 0 if OK, errorcode on error.
 */
static int nvs_flash_erase_sector(struct nvs_fs *fs, u32_t addr)
{
   26f60:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	int rc;
	off_t offset;

	addr &= ADDR_SECT_MASK;
   26f64:	0c0c      	lsrs	r4, r1, #16
   26f66:	0424      	lsls	r4, r4, #16
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
   26f68:	8982      	ldrh	r2, [r0, #12]
   26f6a:	4621      	mov	r1, r4
{
   26f6c:	4605      	mov	r5, r0
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
   26f6e:	f015 fcce 	bl	3c90e <nvs_flash_cmp_const.constprop.5>
	if (rc <= 0) {
   26f72:	1e06      	subs	r6, r0, #0
   26f74:	dd29      	ble.n	26fca <nvs_flash_erase_sector+0x6a>
	}

	offset = fs->offset;
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);

	rc = flash_write_protection_set(fs->flash_device, 0);
   26f76:	2100      	movs	r1, #0
   26f78:	6aa8      	ldr	r0, [r5, #40]	; 0x28
	offset = fs->offset;
   26f7a:	682f      	ldr	r7, [r5, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   26f7c:	f8b5 800c 	ldrh.w	r8, [r5, #12]
	rc = flash_write_protection_set(fs->flash_device, 0);
   26f80:	f015 fc64 	bl	3c84c <flash_write_protection_set>
	if (rc) {
   26f84:	4606      	mov	r6, r0
   26f86:	bb00      	cbnz	r0, 26fca <nvs_flash_erase_sector+0x6a>
		/* flash protection set error */
		return rc;
	}
	LOG_DBG("Erasing flash at %lx, len %d", (long int) offset,
   26f88:	2304      	movs	r3, #4
   26f8a:	f04f 0000 	mov.w	r0, #0
	return ((u8_t *)data - (u8_t *)__log_const_start)/
   26f8e:	4a11      	ldr	r2, [pc, #68]	; (26fd4 <nvs_flash_erase_sector+0x74>)
   26f90:	f363 0007 	bfi	r0, r3, #0, #8
   26f94:	4b10      	ldr	r3, [pc, #64]	; (26fd8 <nvs_flash_erase_sector+0x78>)
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   26f96:	0c24      	lsrs	r4, r4, #16
   26f98:	fb08 7404 	mla	r4, r8, r4, r7
   26f9c:	1a9b      	subs	r3, r3, r2
   26f9e:	08db      	lsrs	r3, r3, #3
	LOG_DBG("Erasing flash at %lx, len %d", (long int) offset,
   26fa0:	f363 108f 	bfi	r0, r3, #6, #10
   26fa4:	89ab      	ldrh	r3, [r5, #12]
   26fa6:	4a0d      	ldr	r2, [pc, #52]	; (26fdc <nvs_flash_erase_sector+0x7c>)
   26fa8:	9300      	str	r3, [sp, #0]
   26faa:	490d      	ldr	r1, [pc, #52]	; (26fe0 <nvs_flash_erase_sector+0x80>)
   26fac:	4623      	mov	r3, r4
   26fae:	f015 fc14 	bl	3c7da <log_string_sync>
		fs->sector_size);
	rc = flash_erase(fs->flash_device, offset, fs->sector_size);
   26fb2:	6aa8      	ldr	r0, [r5, #40]	; 0x28
   26fb4:	89aa      	ldrh	r2, [r5, #12]
				    size_t size)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->driver_api;

	return api->erase(dev, offset, size);
   26fb6:	6843      	ldr	r3, [r0, #4]
   26fb8:	4621      	mov	r1, r4
   26fba:	689b      	ldr	r3, [r3, #8]
   26fbc:	4798      	blx	r3
	if (rc) {
   26fbe:	4606      	mov	r6, r0
   26fc0:	b918      	cbnz	r0, 26fca <nvs_flash_erase_sector+0x6a>
		/* flash erase error */
		return rc;
	}
	(void) flash_write_protection_set(fs->flash_device, 1);
   26fc2:	2101      	movs	r1, #1
   26fc4:	6aa8      	ldr	r0, [r5, #40]	; 0x28
   26fc6:	f015 fc41 	bl	3c84c <flash_write_protection_set>
	return 0;
}
   26fca:	4630      	mov	r0, r6
   26fcc:	b002      	add	sp, #8
   26fce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   26fd2:	bf00      	nop
   26fd4:	0003f8d4 	.word	0x0003f8d4
   26fd8:	0003f93c 	.word	0x0003f93c
   26fdc:	00041b52 	.word	0x00041b52
   26fe0:	00041b84 	.word	0x00041b84

00026fe4 <nvs_prev_ate>:

/* walking through allocation entry list, from newest to oldest entries
 * read ate from addr, modify addr to the previous ate
 */
static int nvs_prev_ate(struct nvs_fs *fs, u32_t *addr, struct nvs_ate *ate)
{
   26fe4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   26fe8:	2308      	movs	r3, #8
{
   26fea:	b085      	sub	sp, #20
   26fec:	460d      	mov	r5, r1
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   26fee:	6809      	ldr	r1, [r1, #0]
{
   26ff0:	4607      	mov	r7, r0
	int rc;
	struct nvs_ate close_ate, end_ate;
	u32_t data_end_addr, ate_end_addr;
	size_t ate_size;

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   26ff2:	7c04      	ldrb	r4, [r0, #16]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   26ff4:	f015 fc2d 	bl	3c852 <nvs_flash_rd>

	rc = nvs_flash_ate_rd(fs, *addr, ate);
	if (rc) {
   26ff8:	b968      	cbnz	r0, 27016 <nvs_prev_ate+0x32>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   26ffa:	2108      	movs	r1, #8
   26ffc:	4620      	mov	r0, r4
   26ffe:	f015 fc73 	bl	3c8e8 <nvs_al_size.isra.1>
		return rc;
	}

	*addr += ate_size;
   27002:	6829      	ldr	r1, [r5, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
   27004:	89bb      	ldrh	r3, [r7, #12]
	*addr += ate_size;
   27006:	4401      	add	r1, r0
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
   27008:	b28a      	uxth	r2, r1
   2700a:	1a1b      	subs	r3, r3, r0
   2700c:	429a      	cmp	r2, r3
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   2700e:	4606      	mov	r6, r0
	*addr += ate_size;
   27010:	6029      	str	r1, [r5, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
   27012:	d003      	beq.n	2701c <nvs_prev_ate+0x38>
		return 0;
   27014:	2000      	movs	r0, #0
	/* remark: if there was absolutely no valid data in the sector *addr
	 * is kept at sector_end - 2*ate_size, the next read will contain
	 * invalid data and continue with a sector jump
	 */
	return 0;
}
   27016:	b005      	add	sp, #20
   27018:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (((*addr) >> ADDR_SECT_SHIFT) == 0U) {
   2701c:	0c0b      	lsrs	r3, r1, #16
		*addr += ((fs->sector_count - 1) << ADDR_SECT_SHIFT);
   2701e:	bf09      	itett	eq
   27020:	89fb      	ldrheq	r3, [r7, #14]
		*addr -= (1 << ADDR_SECT_SHIFT);
   27022:	f5a1 3180 	subne.w	r1, r1, #65536	; 0x10000
		*addr += ((fs->sector_count - 1) << ADDR_SECT_SHIFT);
   27026:	f103 33ff 	addeq.w	r3, r3, #4294967295
   2702a:	eb01 4103 	addeq.w	r1, r1, r3, lsl #16
		*addr -= (1 << ADDR_SECT_SHIFT);
   2702e:	6029      	str	r1, [r5, #0]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   27030:	2308      	movs	r3, #8
   27032:	466a      	mov	r2, sp
   27034:	4638      	mov	r0, r7
   27036:	f015 fc0c 	bl	3c852 <nvs_flash_rd>
	if (rc) {
   2703a:	2800      	cmp	r0, #0
   2703c:	d1eb      	bne.n	27016 <nvs_prev_ate+0x32>
   2703e:	466a      	mov	r2, sp
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   27040:	4603      	mov	r3, r0
		if (data8[i] != value) {
   27042:	f812 1b01 	ldrb.w	r1, [r2], #1
   27046:	29ff      	cmp	r1, #255	; 0xff
   27048:	d115      	bne.n	27076 <nvs_prev_ate+0x92>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   2704a:	3301      	adds	r3, #1
   2704c:	2b08      	cmp	r3, #8
   2704e:	d1f8      	bne.n	27042 <nvs_prev_ate+0x5e>
		*addr = fs->ate_wra;
   27050:	687b      	ldr	r3, [r7, #4]
   27052:	602b      	str	r3, [r5, #0]
		return 0;
   27054:	e7df      	b.n	27016 <nvs_prev_ate+0x32>
		if (close_ate.offset < (fs->sector_size - ate_size) &&
   27056:	89ba      	ldrh	r2, [r7, #12]
   27058:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   2705c:	1b92      	subs	r2, r2, r6
   2705e:	4293      	cmp	r3, r2
   27060:	d20f      	bcs.n	27082 <nvs_prev_ate+0x9e>
		    !(close_ate.offset % ate_size)) {
   27062:	fbb3 f2f6 	udiv	r2, r3, r6
   27066:	fb06 3212 	mls	r2, r6, r2, r3
		if (close_ate.offset < (fs->sector_size - ate_size) &&
   2706a:	b952      	cbnz	r2, 27082 <nvs_prev_ate+0x9e>
			(*addr) &= ADDR_SECT_MASK;
   2706c:	0c24      	lsrs	r4, r4, #16
   2706e:	0424      	lsls	r4, r4, #16
			(*addr) += close_ate.offset;
   27070:	441c      	add	r4, r3
   27072:	602c      	str	r4, [r5, #0]
			return 0;
   27074:	e7cf      	b.n	27016 <nvs_prev_ate+0x32>
	if (!nvs_ate_crc8_check(&close_ate)) {
   27076:	4668      	mov	r0, sp
   27078:	f015 fc21 	bl	3c8be <nvs_ate_crc8_check>
   2707c:	682c      	ldr	r4, [r5, #0]
   2707e:	2800      	cmp	r0, #0
   27080:	d0e9      	beq.n	27056 <nvs_prev_ate+0x72>
	data_end_addr = *addr & ADDR_SECT_MASK;
   27082:	4b10      	ldr	r3, [pc, #64]	; (270c4 <nvs_prev_ate+0xe0>)
	*addr -= ate_size;
   27084:	1ba4      	subs	r4, r4, r6
			data_end_addr &= ADDR_SECT_MASK;
   27086:	4699      	mov	r9, r3
	*addr -= ate_size;
   27088:	602c      	str	r4, [r5, #0]
	data_end_addr = *addr & ADDR_SECT_MASK;
   2708a:	ea04 0803 	and.w	r8, r4, r3
	while (ate_end_addr > data_end_addr) {
   2708e:	45a0      	cmp	r8, r4
   27090:	d2c0      	bcs.n	27014 <nvs_prev_ate+0x30>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   27092:	2308      	movs	r3, #8
   27094:	4621      	mov	r1, r4
   27096:	eb0d 0203 	add.w	r2, sp, r3
   2709a:	4638      	mov	r0, r7
   2709c:	f015 fbd9 	bl	3c852 <nvs_flash_rd>
		if (rc) {
   270a0:	2800      	cmp	r0, #0
   270a2:	d1b8      	bne.n	27016 <nvs_prev_ate+0x32>
		if (!nvs_ate_crc8_check(&end_ate)) {
   270a4:	a802      	add	r0, sp, #8
   270a6:	f015 fc0a 	bl	3c8be <nvs_ate_crc8_check>
   270aa:	b940      	cbnz	r0, 270be <nvs_prev_ate+0xda>
			data_end_addr += end_ate.offset + end_ate.len;
   270ac:	f8bd 300a 	ldrh.w	r3, [sp, #10]
   270b0:	f8bd 200c 	ldrh.w	r2, [sp, #12]
			data_end_addr &= ADDR_SECT_MASK;
   270b4:	ea08 0809 	and.w	r8, r8, r9
			data_end_addr += end_ate.offset + end_ate.len;
   270b8:	4413      	add	r3, r2
   270ba:	4498      	add	r8, r3
			*addr = ate_end_addr;
   270bc:	602c      	str	r4, [r5, #0]
		ate_end_addr -= ate_size;
   270be:	1ba4      	subs	r4, r4, r6
   270c0:	e7e5      	b.n	2708e <nvs_prev_ate+0xaa>
   270c2:	bf00      	nop
   270c4:	ffff0000 	.word	0xffff0000

000270c8 <nvs_gc>:
/* garbage collection: the address ate_wra has been updated to the new sector
 * that has just been started. The data to gc is in the sector after this new
 * sector.
 */
static int nvs_gc(struct nvs_fs *fs)
{
   270c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct nvs_ate close_ate, gc_ate, wlk_ate;
	u32_t sec_addr, gc_addr, gc_prev_addr, wlk_addr, wlk_prev_addr,
	      data_addr, stop_addr;
	size_t ate_size;

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   270cc:	2108      	movs	r1, #8
{
   270ce:	b097      	sub	sp, #92	; 0x5c
   270d0:	4604      	mov	r4, r0
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   270d2:	7c00      	ldrb	r0, [r0, #16]
   270d4:	f015 fc08 	bl	3c8e8 <nvs_al_size.isra.1>
   270d8:	4680      	mov	r8, r0

	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
   270da:	6863      	ldr	r3, [r4, #4]
	nvs_sector_advance(fs, &sec_addr);
   270dc:	a905      	add	r1, sp, #20
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
   270de:	0c1b      	lsrs	r3, r3, #16
   270e0:	041b      	lsls	r3, r3, #16
	nvs_sector_advance(fs, &sec_addr);
   270e2:	89e0      	ldrh	r0, [r4, #14]
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
   270e4:	9305      	str	r3, [sp, #20]
	nvs_sector_advance(fs, &sec_addr);
   270e6:	f015 fc08 	bl	3c8fa <nvs_sector_advance.isra.2>
	gc_addr = sec_addr + fs->sector_size - ate_size;
   270ea:	9b05      	ldr	r3, [sp, #20]
   270ec:	89a1      	ldrh	r1, [r4, #12]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   270ee:	ad08      	add	r5, sp, #32
	gc_addr = sec_addr + fs->sector_size - ate_size;
   270f0:	4419      	add	r1, r3
   270f2:	eba1 0108 	sub.w	r1, r1, r8
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   270f6:	462a      	mov	r2, r5
   270f8:	2308      	movs	r3, #8
   270fa:	4620      	mov	r0, r4
	gc_addr = sec_addr + fs->sector_size - ate_size;
   270fc:	9106      	str	r1, [sp, #24]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   270fe:	f015 fba8 	bl	3c852 <nvs_flash_rd>

	/* if the sector is not closed don't do gc */
	rc = nvs_flash_ate_rd(fs, gc_addr, &close_ate);
	if (rc < 0) {
   27102:	1e02      	subs	r2, r0, #0
   27104:	f2c0 8085 	blt.w	27212 <nvs_gc+0x14a>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   27108:	2300      	movs	r3, #0
		if (data8[i] != value) {
   2710a:	5cea      	ldrb	r2, [r5, r3]
   2710c:	2aff      	cmp	r2, #255	; 0xff
   2710e:	f040 8084 	bne.w	2721a <nvs_gc+0x152>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   27112:	3301      	adds	r3, #1
   27114:	2b08      	cmp	r3, #8
   27116:	d1f8      	bne.n	2710a <nvs_gc+0x42>
		return rc;
	}

	rc = nvs_ate_cmp_const(&close_ate, 0xff);
	if (!rc) {
		rc = nvs_flash_erase_sector(fs, sec_addr);
   27118:	9905      	ldr	r1, [sp, #20]
   2711a:	4620      	mov	r0, r4
   2711c:	f7ff ff20 	bl	26f60 <nvs_flash_erase_sector>
   27120:	4602      	mov	r2, r0
		if (rc) {
   27122:	e076      	b.n	27212 <nvs_gc+0x14a>
		bytes_to_copy = MIN(block_size, len);
   27124:	454e      	cmp	r6, r9
   27126:	4635      	mov	r5, r6
   27128:	bf28      	it	cs
   2712a:	464d      	movcs	r5, r9
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_copy);
   2712c:	aa0e      	add	r2, sp, #56	; 0x38
   2712e:	462b      	mov	r3, r5
   27130:	4639      	mov	r1, r7
   27132:	4620      	mov	r0, r4
   27134:	f015 fb8d 	bl	3c852 <nvs_flash_rd>
		if (rc) {
   27138:	4602      	mov	r2, r0
   2713a:	2800      	cmp	r0, #0
   2713c:	d169      	bne.n	27212 <nvs_gc+0x14a>
	if (!len) {
   2713e:	b135      	cbz	r5, 2714e <nvs_gc+0x86>
   27140:	aa0e      	add	r2, sp, #56	; 0x38
   27142:	462b      	mov	r3, r5
   27144:	68a1      	ldr	r1, [r4, #8]
   27146:	4620      	mov	r0, r4
   27148:	f015 fc05 	bl	3c956 <nvs_flash_al_wrt.part.3>
   2714c:	4602      	mov	r2, r0
	fs->data_wra += nvs_al_size(fs, len);
   2714e:	4629      	mov	r1, r5
   27150:	7c20      	ldrb	r0, [r4, #16]
   27152:	f015 fbc9 	bl	3c8e8 <nvs_al_size.isra.1>
   27156:	68a3      	ldr	r3, [r4, #8]
   27158:	4418      	add	r0, r3
   2715a:	60a0      	str	r0, [r4, #8]
		if (rc) {
   2715c:	2a00      	cmp	r2, #0
   2715e:	d158      	bne.n	27212 <nvs_gc+0x14a>
		len -= bytes_to_copy;
   27160:	eba9 0905 	sub.w	r9, r9, r5
		addr += bytes_to_copy;
   27164:	442f      	add	r7, r5
   27166:	e04a      	b.n	271fe <nvs_gc+0x136>
				return rc;
			}
		}

		/* stop gc at end of the sector */
		if (gc_prev_addr == stop_addr) {
   27168:	45d8      	cmp	r8, fp
   2716a:	d0d5      	beq.n	27118 <nvs_gc+0x50>
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
   2716c:	aa0a      	add	r2, sp, #40	; 0x28
   2716e:	a906      	add	r1, sp, #24
   27170:	4620      	mov	r0, r4
		gc_prev_addr = gc_addr;
   27172:	f8dd b018 	ldr.w	fp, [sp, #24]
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
   27176:	f7ff ff35 	bl	26fe4 <nvs_prev_ate>
		if (rc) {
   2717a:	4602      	mov	r2, r0
   2717c:	2800      	cmp	r0, #0
   2717e:	d148      	bne.n	27212 <nvs_gc+0x14a>
		wlk_addr = fs->ate_wra;
   27180:	6863      	ldr	r3, [r4, #4]
   27182:	9307      	str	r3, [sp, #28]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   27184:	aa0c      	add	r2, sp, #48	; 0x30
   27186:	a907      	add	r1, sp, #28
   27188:	4620      	mov	r0, r4
			wlk_prev_addr = wlk_addr;
   2718a:	9d07      	ldr	r5, [sp, #28]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   2718c:	f7ff ff2a 	bl	26fe4 <nvs_prev_ate>
			if (rc) {
   27190:	4602      	mov	r2, r0
   27192:	2800      	cmp	r0, #0
   27194:	d13d      	bne.n	27212 <nvs_gc+0x14a>
			if ((wlk_ate.id == gc_ate.id) &&
   27196:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
   2719a:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   2719e:	429a      	cmp	r2, r3
   271a0:	d1f0      	bne.n	27184 <nvs_gc+0xbc>
			    (!nvs_ate_crc8_check(&wlk_ate))) {
   271a2:	a80c      	add	r0, sp, #48	; 0x30
   271a4:	f015 fb8b 	bl	3c8be <nvs_ate_crc8_check>
			if ((wlk_ate.id == gc_ate.id) &&
   271a8:	2800      	cmp	r0, #0
   271aa:	d1eb      	bne.n	27184 <nvs_gc+0xbc>
		if ((wlk_prev_addr == gc_prev_addr) && gc_ate.len) {
   271ac:	45ab      	cmp	fp, r5
   271ae:	d1db      	bne.n	27168 <nvs_gc+0xa0>
   271b0:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
   271b4:	2a00      	cmp	r2, #0
   271b6:	d0d7      	beq.n	27168 <nvs_gc+0xa0>
			LOG_DBG("Moving %d, len %d", gc_ate.id, gc_ate.len);
   271b8:	f02a 033f 	bic.w	r3, sl, #63	; 0x3f
   271bc:	f043 0304 	orr.w	r3, r3, #4
   271c0:	f363 0a07 	bfi	sl, r3, #0, #8
   271c4:	9b02      	ldr	r3, [sp, #8]
   271c6:	9200      	str	r2, [sp, #0]
   271c8:	f363 1a8f 	bfi	sl, r3, #6, #10
   271cc:	4a1b      	ldr	r2, [pc, #108]	; (2723c <nvs_gc+0x174>)
   271ce:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   271d2:	491b      	ldr	r1, [pc, #108]	; (27240 <nvs_gc+0x178>)
   271d4:	4650      	mov	r0, sl
   271d6:	f015 fb00 	bl	3c7da <log_string_sync>
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
   271da:	9b03      	ldr	r3, [sp, #12]
			nvs_ate_crc8_update(&gc_ate);
   271dc:	a80a      	add	r0, sp, #40	; 0x28
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
   271de:	ea0b 0703 	and.w	r7, fp, r3
			data_addr += gc_ate.offset;
   271e2:	f8bd 302a 	ldrh.w	r3, [sp, #42]	; 0x2a
   271e6:	441f      	add	r7, r3
			gc_ate.offset = (u16_t)(fs->data_wra & ADDR_OFFS_MASK);
   271e8:	68a3      	ldr	r3, [r4, #8]
   271ea:	f8ad 302a 	strh.w	r3, [sp, #42]	; 0x2a
			nvs_ate_crc8_update(&gc_ate);
   271ee:	f015 fb72 	bl	3c8d6 <nvs_ate_crc8_update>
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   271f2:	7c26      	ldrb	r6, [r4, #16]
			rc = nvs_flash_block_move(fs, data_addr, gc_ate.len);
   271f4:	f8bd 902c 	ldrh.w	r9, [sp, #44]	; 0x2c
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   271f8:	4276      	negs	r6, r6
   271fa:	f006 0620 	and.w	r6, r6, #32
	while (len) {
   271fe:	f1b9 0f00 	cmp.w	r9, #0
   27202:	d18f      	bne.n	27124 <nvs_gc+0x5c>
			rc = nvs_flash_ate_wrt(fs, &gc_ate);
   27204:	a90a      	add	r1, sp, #40	; 0x28
   27206:	4620      	mov	r0, r4
   27208:	f015 fbeb 	bl	3c9e2 <nvs_flash_ate_wrt>
			if (rc) {
   2720c:	4602      	mov	r2, r0
   2720e:	2800      	cmp	r0, #0
   27210:	d0aa      	beq.n	27168 <nvs_gc+0xa0>
	rc = nvs_flash_erase_sector(fs, sec_addr);
	if (rc) {
		return rc;
	}
	return 0;
}
   27212:	4610      	mov	r0, r2
   27214:	b017      	add	sp, #92	; 0x5c
   27216:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	stop_addr = gc_addr - ate_size;
   2721a:	9b06      	ldr	r3, [sp, #24]
	gc_addr &= ADDR_SECT_MASK;
   2721c:	4a09      	ldr	r2, [pc, #36]	; (27244 <nvs_gc+0x17c>)
	gc_addr += close_ate.offset;
   2721e:	f8bd 1022 	ldrh.w	r1, [sp, #34]	; 0x22
	stop_addr = gc_addr - ate_size;
   27222:	eba3 0808 	sub.w	r8, r3, r8
	gc_addr &= ADDR_SECT_MASK;
   27226:	4013      	ands	r3, r2
	gc_addr += close_ate.offset;
   27228:	440b      	add	r3, r1
   2722a:	9306      	str	r3, [sp, #24]
			LOG_DBG("Moving %d, len %d", gc_ate.id, gc_ate.len);
   2722c:	4906      	ldr	r1, [pc, #24]	; (27248 <nvs_gc+0x180>)
   2722e:	4b07      	ldr	r3, [pc, #28]	; (2724c <nvs_gc+0x184>)
   27230:	1a5b      	subs	r3, r3, r1
   27232:	f3c3 03c9 	ubfx	r3, r3, #3, #10
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
   27236:	e9cd 3202 	strd	r3, r2, [sp, #8]
   2723a:	e797      	b.n	2716c <nvs_gc+0xa4>
   2723c:	00041b69 	.word	0x00041b69
   27240:	00041ba5 	.word	0x00041ba5
   27244:	ffff0000 	.word	0xffff0000
   27248:	0003f8d4 	.word	0x0003f8d4
   2724c:	0003f93c 	.word	0x0003f93c

00027250 <nvs_init>:
	}
	return 0;
}

int nvs_init(struct nvs_fs *fs, const char *dev_name)
{
   27250:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   27254:	4604      	mov	r4, r0
   27256:	b087      	sub	sp, #28
   27258:	460d      	mov	r5, r1

	int rc;
	struct flash_pages_info info;

	k_mutex_init(&fs->nvs_lock);
   2725a:	f100 0614 	add.w	r6, r0, #20
	return z_impl_k_mutex_init(mutex);
   2725e:	4630      	mov	r0, r6
   27260:	f017 f93f 	bl	3e4e2 <z_impl_k_mutex_init>
   27264:	4628      	mov	r0, r5
   27266:	f00e f9db 	bl	35620 <z_impl_device_get_binding>

	fs->flash_device = device_get_binding(dev_name);
   2726a:	62a0      	str	r0, [r4, #40]	; 0x28
	if (!fs->flash_device) {
   2726c:	b988      	cbnz	r0, 27292 <nvs_init+0x42>
		LOG_ERR("No valid flash device found");
   2726e:	2301      	movs	r3, #1
   27270:	4aa1      	ldr	r2, [pc, #644]	; (274f8 <nvs_init+0x2a8>)
   27272:	f363 0007 	bfi	r0, r3, #0, #8
   27276:	4ba1      	ldr	r3, [pc, #644]	; (274fc <nvs_init+0x2ac>)
   27278:	49a1      	ldr	r1, [pc, #644]	; (27500 <nvs_init+0x2b0>)
   2727a:	1a9b      	subs	r3, r3, r2
   2727c:	08db      	lsrs	r3, r3, #3
   2727e:	f363 108f 	bfi	r0, r3, #6, #10
   27282:	f015 faaa 	bl	3c7da <log_string_sync>
		return -ENXIO;
   27286:	f06f 0505 	mvn.w	r5, #5
	LOG_INF("data wra: %d, %x",
		(fs->data_wra >> ADDR_SECT_SHIFT),
		(fs->data_wra & ADDR_OFFS_MASK));

	return 0;
}
   2728a:	4628      	mov	r0, r5
   2728c:	b007      	add	sp, #28
   2728e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
static inline size_t z_impl_flash_get_write_block_size(struct device *dev)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->driver_api;

	return api->write_block_size;
   27292:	6843      	ldr	r3, [r0, #4]
	fs->write_block_size = flash_get_write_block_size(fs->flash_device);
   27294:	7d1b      	ldrb	r3, [r3, #20]
	if (fs->write_block_size > NVS_BLOCK_SIZE) {
   27296:	2b20      	cmp	r3, #32
	fs->write_block_size = flash_get_write_block_size(fs->flash_device);
   27298:	7423      	strb	r3, [r4, #16]
	if (fs->write_block_size > NVS_BLOCK_SIZE) {
   2729a:	d910      	bls.n	272be <nvs_init+0x6e>
		LOG_ERR("Unsupported write block size");
   2729c:	2301      	movs	r3, #1
   2729e:	f04f 0000 	mov.w	r0, #0
   272a2:	4a95      	ldr	r2, [pc, #596]	; (274f8 <nvs_init+0x2a8>)
   272a4:	f363 0007 	bfi	r0, r3, #0, #8
   272a8:	4b94      	ldr	r3, [pc, #592]	; (274fc <nvs_init+0x2ac>)
   272aa:	4996      	ldr	r1, [pc, #600]	; (27504 <nvs_init+0x2b4>)
   272ac:	1a9b      	subs	r3, r3, r2
   272ae:	08db      	lsrs	r3, r3, #3
   272b0:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Unable to get page info");
   272b4:	f015 fa91 	bl	3c7da <log_string_sync>
		return -EINVAL;
   272b8:	f06f 0515 	mvn.w	r5, #21
   272bc:	e7e5      	b.n	2728a <nvs_init+0x3a>
	rc = flash_get_page_info_by_offs(fs->flash_device, fs->offset, &info);
   272be:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   272c0:	6821      	ldr	r1, [r4, #0]
   272c2:	aa03      	add	r2, sp, #12
   272c4:	f016 fa30 	bl	3d728 <z_impl_flash_get_page_info_by_offs>
	if (rc) {
   272c8:	b160      	cbz	r0, 272e4 <nvs_init+0x94>
		LOG_ERR("Unable to get page info");
   272ca:	2301      	movs	r3, #1
   272cc:	f04f 0000 	mov.w	r0, #0
   272d0:	4a89      	ldr	r2, [pc, #548]	; (274f8 <nvs_init+0x2a8>)
   272d2:	f363 0007 	bfi	r0, r3, #0, #8
   272d6:	4b89      	ldr	r3, [pc, #548]	; (274fc <nvs_init+0x2ac>)
   272d8:	498b      	ldr	r1, [pc, #556]	; (27508 <nvs_init+0x2b8>)
   272da:	1a9b      	subs	r3, r3, r2
   272dc:	08db      	lsrs	r3, r3, #3
   272de:	f363 108f 	bfi	r0, r3, #6, #10
   272e2:	e7e7      	b.n	272b4 <nvs_init+0x64>
	if (!fs->sector_size || fs->sector_size % info.size) {
   272e4:	89a3      	ldrh	r3, [r4, #12]
   272e6:	b12b      	cbz	r3, 272f4 <nvs_init+0xa4>
   272e8:	9a04      	ldr	r2, [sp, #16]
   272ea:	fbb3 f5f2 	udiv	r5, r3, r2
   272ee:	fb02 3515 	mls	r5, r2, r5, r3
   272f2:	b165      	cbz	r5, 2730e <nvs_init+0xbe>
		LOG_ERR("Invalid sector size");
   272f4:	2301      	movs	r3, #1
   272f6:	f04f 0000 	mov.w	r0, #0
   272fa:	4a7f      	ldr	r2, [pc, #508]	; (274f8 <nvs_init+0x2a8>)
   272fc:	f363 0007 	bfi	r0, r3, #0, #8
   27300:	4b7e      	ldr	r3, [pc, #504]	; (274fc <nvs_init+0x2ac>)
   27302:	4982      	ldr	r1, [pc, #520]	; (2750c <nvs_init+0x2bc>)
   27304:	1a9b      	subs	r3, r3, r2
   27306:	08db      	lsrs	r3, r3, #3
   27308:	f363 108f 	bfi	r0, r3, #6, #10
   2730c:	e7d2      	b.n	272b4 <nvs_init+0x64>
	if (fs->sector_count < 2) {
   2730e:	89e3      	ldrh	r3, [r4, #14]
   27310:	2b01      	cmp	r3, #1
   27312:	d80c      	bhi.n	2732e <nvs_init+0xde>
		LOG_ERR("Configuration error - sector count");
   27314:	2301      	movs	r3, #1
   27316:	f04f 0000 	mov.w	r0, #0
   2731a:	4a77      	ldr	r2, [pc, #476]	; (274f8 <nvs_init+0x2a8>)
   2731c:	f363 0007 	bfi	r0, r3, #0, #8
   27320:	4b76      	ldr	r3, [pc, #472]	; (274fc <nvs_init+0x2ac>)
   27322:	497b      	ldr	r1, [pc, #492]	; (27510 <nvs_init+0x2c0>)
   27324:	1a9b      	subs	r3, r3, r2
   27326:	08db      	lsrs	r3, r3, #3
   27328:	f363 108f 	bfi	r0, r3, #6, #10
   2732c:	e7c2      	b.n	272b4 <nvs_init+0x64>
	u32_t addr = 0U;
   2732e:	9500      	str	r5, [sp, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
   27330:	f04f 31ff 	mov.w	r1, #4294967295
   27334:	4630      	mov	r0, r6
   27336:	f00e fe57 	bl	35fe8 <z_impl_k_mutex_lock>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   2733a:	2108      	movs	r1, #8
   2733c:	7c20      	ldrb	r0, [r4, #16]
   2733e:	f015 fad3 	bl	3c8e8 <nvs_al_size.isra.1>
	u16_t i, closed_sectors = 0;
   27342:	46a9      	mov	r9, r5
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   27344:	4607      	mov	r7, r0
	for (i = 0; i < fs->sector_count; i++) {
   27346:	89e3      	ldrh	r3, [r4, #14]
   27348:	fa1f f885 	uxth.w	r8, r5
   2734c:	4543      	cmp	r3, r8
   2734e:	d805      	bhi.n	2735c <nvs_init+0x10c>
	if (closed_sectors == fs->sector_count) {
   27350:	89e3      	ldrh	r3, [r4, #14]
   27352:	454b      	cmp	r3, r9
   27354:	d11e      	bne.n	27394 <nvs_init+0x144>
		return -EDEADLK;
   27356:	f06f 052c 	mvn.w	r5, #44	; 0x2c
   2735a:	e796      	b.n	2728a <nvs_init+0x3a>
		       (u16_t)(fs->sector_size - ate_size);
   2735c:	89a1      	ldrh	r1, [r4, #12]
		addr = (i << ADDR_SECT_SHIFT) +
   2735e:	042b      	lsls	r3, r5, #16
		       (u16_t)(fs->sector_size - ate_size);
   27360:	1bc9      	subs	r1, r1, r7
		addr = (i << ADDR_SECT_SHIFT) +
   27362:	fa13 f181 	uxtah	r1, r3, r1
		rc = nvs_flash_cmp_const(fs, addr, 0xff,
   27366:	2208      	movs	r2, #8
   27368:	4620      	mov	r0, r4
		addr = (i << ADDR_SECT_SHIFT) +
   2736a:	9100      	str	r1, [sp, #0]
		rc = nvs_flash_cmp_const(fs, addr, 0xff,
   2736c:	f015 facf 	bl	3c90e <nvs_flash_cmp_const.constprop.5>
		if (rc) {
   27370:	b170      	cbz	r0, 27390 <nvs_init+0x140>
			nvs_sector_advance(fs, &addr);
   27372:	4669      	mov	r1, sp
   27374:	89e0      	ldrh	r0, [r4, #14]
   27376:	f015 fac0 	bl	3c8fa <nvs_sector_advance.isra.2>
			closed_sectors++;
   2737a:	f109 0901 	add.w	r9, r9, #1
			rc = nvs_flash_cmp_const(fs, addr, 0xff,
   2737e:	2208      	movs	r2, #8
   27380:	9900      	ldr	r1, [sp, #0]
   27382:	4620      	mov	r0, r4
			closed_sectors++;
   27384:	fa1f f989 	uxth.w	r9, r9
			rc = nvs_flash_cmp_const(fs, addr, 0xff,
   27388:	f015 fac1 	bl	3c90e <nvs_flash_cmp_const.constprop.5>
			if (!rc) {
   2738c:	2800      	cmp	r0, #0
   2738e:	d0df      	beq.n	27350 <nvs_init+0x100>
   27390:	3501      	adds	r5, #1
   27392:	e7d8      	b.n	27346 <nvs_init+0xf6>
	if (i == fs->sector_count) {
   27394:	4598      	cmp	r8, r3
   27396:	d10a      	bne.n	273ae <nvs_init+0x15e>
		rc = nvs_flash_cmp_const(fs, addr - ate_size, 0xff,
   27398:	9900      	ldr	r1, [sp, #0]
   2739a:	2208      	movs	r2, #8
   2739c:	1bc9      	subs	r1, r1, r7
   2739e:	4620      	mov	r0, r4
   273a0:	f015 fab5 	bl	3c90e <nvs_flash_cmp_const.constprop.5>
		if (!rc) {
   273a4:	b918      	cbnz	r0, 273ae <nvs_init+0x15e>
			nvs_sector_advance(fs, &addr);
   273a6:	4669      	mov	r1, sp
   273a8:	89e0      	ldrh	r0, [r4, #14]
   273aa:	f015 faa6 	bl	3c8fa <nvs_sector_advance.isra.2>
	fs->ate_wra = addr - ate_size;
   273ae:	9b00      	ldr	r3, [sp, #0]
   273b0:	1bda      	subs	r2, r3, r7
   273b2:	6062      	str	r2, [r4, #4]
	fs->data_wra = addr & ADDR_SECT_MASK;
   273b4:	4a57      	ldr	r2, [pc, #348]	; (27514 <nvs_init+0x2c4>)
			fs->data_wra = addr & ADDR_SECT_MASK;
   273b6:	4690      	mov	r8, r2
	fs->data_wra = addr & ADDR_SECT_MASK;
   273b8:	4013      	ands	r3, r2
   273ba:	60a3      	str	r3, [r4, #8]
	while (fs->ate_wra >= fs->data_wra) {
   273bc:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
   273c0:	4299      	cmp	r1, r3
   273c2:	d30e      	bcc.n	273e2 <nvs_init+0x192>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   273c4:	2308      	movs	r3, #8
   273c6:	aa01      	add	r2, sp, #4
   273c8:	4620      	mov	r0, r4
   273ca:	f015 fa42 	bl	3c852 <nvs_flash_rd>
		if (rc) {
   273ce:	4605      	mov	r5, r0
   273d0:	bb18      	cbnz	r0, 2741a <nvs_init+0x1ca>
   273d2:	ab01      	add	r3, sp, #4
		if (data8[i] != value) {
   273d4:	f813 2b01 	ldrb.w	r2, [r3], #1
   273d8:	2aff      	cmp	r2, #255	; 0xff
   273da:	d175      	bne.n	274c8 <nvs_init+0x278>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   273dc:	3501      	adds	r5, #1
   273de:	2d08      	cmp	r5, #8
   273e0:	d1f8      	bne.n	273d4 <nvs_init+0x184>
	while (fs->ate_wra > fs->data_wra) {
   273e2:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
   273e6:	428a      	cmp	r2, r1
   273e8:	d906      	bls.n	273f8 <nvs_init+0x1a8>
		rc = nvs_flash_cmp_const(fs, fs->data_wra, 0xff, empty_len);
   273ea:	1a52      	subs	r2, r2, r1
   273ec:	4620      	mov	r0, r4
   273ee:	f015 fa8e 	bl	3c90e <nvs_flash_cmp_const.constprop.5>
		if (rc < 0) {
   273f2:	1e05      	subs	r5, r0, #0
   273f4:	db11      	blt.n	2741a <nvs_init+0x1ca>
		if (!rc) {
   273f6:	d14a      	bne.n	2748e <nvs_init+0x23e>
	addr = fs->ate_wra & ADDR_SECT_MASK;
   273f8:	6863      	ldr	r3, [r4, #4]
   273fa:	f8df 8118 	ldr.w	r8, [pc, #280]	; 27514 <nvs_init+0x2c4>
	nvs_sector_advance(fs, &addr);
   273fe:	4669      	mov	r1, sp
	addr = fs->ate_wra & ADDR_SECT_MASK;
   27400:	ea03 0308 	and.w	r3, r3, r8
	nvs_sector_advance(fs, &addr);
   27404:	89e0      	ldrh	r0, [r4, #14]
	addr = fs->ate_wra & ADDR_SECT_MASK;
   27406:	9300      	str	r3, [sp, #0]
	nvs_sector_advance(fs, &addr);
   27408:	f015 fa77 	bl	3c8fa <nvs_sector_advance.isra.2>
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
   2740c:	89a2      	ldrh	r2, [r4, #12]
   2740e:	9900      	ldr	r1, [sp, #0]
   27410:	4620      	mov	r0, r4
   27412:	f015 fa7c 	bl	3c90e <nvs_flash_cmp_const.constprop.5>
	if (rc < 0) {
   27416:	1e05      	subs	r5, r0, #0
   27418:	da3e      	bge.n	27498 <nvs_init+0x248>
	return z_impl_k_mutex_unlock(mutex);
   2741a:	4630      	mov	r0, r6
   2741c:	f00e fec2 	bl	361a4 <z_impl_k_mutex_unlock>
	if (rc) {
   27420:	2d00      	cmp	r5, #0
   27422:	f47f af32 	bne.w	2728a <nvs_init+0x3a>
	fs->ready = true;
   27426:	2301      	movs	r3, #1
	LOG_INF("%d Sectors of %d bytes", fs->sector_count, fs->sector_size);
   27428:	f04f 0000 	mov.w	r0, #0
	fs->ready = true;
   2742c:	7463      	strb	r3, [r4, #17]
	LOG_INF("%d Sectors of %d bytes", fs->sector_count, fs->sector_size);
   2742e:	2303      	movs	r3, #3
   27430:	4e32      	ldr	r6, [pc, #200]	; (274fc <nvs_init+0x2ac>)
   27432:	f363 0007 	bfi	r0, r3, #0, #8
   27436:	4b30      	ldr	r3, [pc, #192]	; (274f8 <nvs_init+0x2a8>)
   27438:	89e2      	ldrh	r2, [r4, #14]
   2743a:	1af6      	subs	r6, r6, r3
   2743c:	f3c6 06c9 	ubfx	r6, r6, #3, #10
   27440:	f366 108f 	bfi	r0, r6, #6, #10
   27444:	89a3      	ldrh	r3, [r4, #12]
   27446:	4934      	ldr	r1, [pc, #208]	; (27518 <nvs_init+0x2c8>)
   27448:	f015 f9c7 	bl	3c7da <log_string_sync>
	LOG_INF("alloc wra: %d, %x",
   2744c:	2303      	movs	r3, #3
   2744e:	f04f 0000 	mov.w	r0, #0
   27452:	6862      	ldr	r2, [r4, #4]
   27454:	f363 0007 	bfi	r0, r3, #0, #8
   27458:	f366 108f 	bfi	r0, r6, #6, #10
   2745c:	b293      	uxth	r3, r2
   2745e:	492f      	ldr	r1, [pc, #188]	; (2751c <nvs_init+0x2cc>)
   27460:	0c12      	lsrs	r2, r2, #16
   27462:	f015 f9ba 	bl	3c7da <log_string_sync>
	LOG_INF("data wra: %d, %x",
   27466:	2303      	movs	r3, #3
   27468:	f04f 0000 	mov.w	r0, #0
   2746c:	68a2      	ldr	r2, [r4, #8]
   2746e:	f363 0007 	bfi	r0, r3, #0, #8
   27472:	f366 108f 	bfi	r0, r6, #6, #10
   27476:	b293      	uxth	r3, r2
   27478:	4929      	ldr	r1, [pc, #164]	; (27520 <nvs_init+0x2d0>)
   2747a:	0c12      	lsrs	r2, r2, #16
   2747c:	f015 f9ad 	bl	3c7da <log_string_sync>
	return 0;
   27480:	e703      	b.n	2728a <nvs_init+0x3a>
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
   27482:	f1b9 0f00 	cmp.w	r9, #0
   27486:	d034      	beq.n	274f2 <nvs_init+0x2a2>
				return -ESPIPE;
   27488:	f06f 051c 	mvn.w	r5, #28
   2748c:	e6fd      	b.n	2728a <nvs_init+0x3a>
		fs->data_wra += fs->write_block_size;
   2748e:	68a3      	ldr	r3, [r4, #8]
   27490:	7c22      	ldrb	r2, [r4, #16]
   27492:	4413      	add	r3, r2
   27494:	60a3      	str	r3, [r4, #8]
   27496:	e7a4      	b.n	273e2 <nvs_init+0x192>
	if (rc) {
   27498:	d0bf      	beq.n	2741a <nvs_init+0x1ca>
		rc = nvs_flash_erase_sector(fs, fs->ate_wra);
   2749a:	6861      	ldr	r1, [r4, #4]
   2749c:	4620      	mov	r0, r4
   2749e:	f7ff fd5f 	bl	26f60 <nvs_flash_erase_sector>
		if (rc) {
   274a2:	4605      	mov	r5, r0
   274a4:	2800      	cmp	r0, #0
   274a6:	d1b8      	bne.n	2741a <nvs_init+0x1ca>
		fs->ate_wra &= ADDR_SECT_MASK;
   274a8:	6860      	ldr	r0, [r4, #4]
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
   274aa:	89a3      	ldrh	r3, [r4, #12]
		fs->ate_wra &= ADDR_SECT_MASK;
   274ac:	ea00 0008 	and.w	r0, r0, r8
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
   274b0:	4418      	add	r0, r3
   274b2:	eba0 0047 	sub.w	r0, r0, r7, lsl #1
   274b6:	6060      	str	r0, [r4, #4]
		fs->data_wra = (fs->ate_wra & ADDR_SECT_MASK);
   274b8:	ea00 0008 	and.w	r0, r0, r8
   274bc:	60a0      	str	r0, [r4, #8]
		rc = nvs_gc(fs);
   274be:	4620      	mov	r0, r4
   274c0:	f7ff fe02 	bl	270c8 <nvs_gc>
   274c4:	4605      	mov	r5, r0
		if (rc) {
   274c6:	e7a8      	b.n	2741a <nvs_init+0x1ca>
		if (!nvs_ate_crc8_check(&last_ate)) {
   274c8:	a801      	add	r0, sp, #4
   274ca:	f015 f9f8 	bl	3c8be <nvs_ate_crc8_check>
   274ce:	6865      	ldr	r5, [r4, #4]
   274d0:	b978      	cbnz	r0, 274f2 <nvs_init+0x2a2>
			fs->data_wra = addr & ADDR_SECT_MASK;
   274d2:	9800      	ldr	r0, [sp, #0]
			fs->data_wra += last_ate.offset;
   274d4:	f8bd 2006 	ldrh.w	r2, [sp, #6]
			fs->data_wra += nvs_al_size(fs, last_ate.len);
   274d8:	f8bd 9008 	ldrh.w	r9, [sp, #8]
			fs->data_wra = addr & ADDR_SECT_MASK;
   274dc:	ea00 0008 	and.w	r0, r0, r8
			fs->data_wra += last_ate.offset;
   274e0:	4402      	add	r2, r0
			fs->data_wra += nvs_al_size(fs, last_ate.len);
   274e2:	4649      	mov	r1, r9
   274e4:	7c20      	ldrb	r0, [r4, #16]
   274e6:	f015 f9ff 	bl	3c8e8 <nvs_al_size.isra.1>
   274ea:	4410      	add	r0, r2
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
   274ec:	42a8      	cmp	r0, r5
			fs->data_wra += nvs_al_size(fs, last_ate.len);
   274ee:	60a0      	str	r0, [r4, #8]
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
   274f0:	d0c7      	beq.n	27482 <nvs_init+0x232>
		fs->ate_wra -= ate_size;
   274f2:	1bed      	subs	r5, r5, r7
   274f4:	6065      	str	r5, [r4, #4]
   274f6:	e761      	b.n	273bc <nvs_init+0x16c>
   274f8:	0003f8d4 	.word	0x0003f8d4
   274fc:	0003f93c 	.word	0x0003f93c
   27500:	00041bbb 	.word	0x00041bbb
   27504:	00041bd7 	.word	0x00041bd7
   27508:	00041bf4 	.word	0x00041bf4
   2750c:	00041c0c 	.word	0x00041c0c
   27510:	00041c20 	.word	0x00041c20
   27514:	ffff0000 	.word	0xffff0000
   27518:	00041c43 	.word	0x00041c43
   2751c:	00041c5a 	.word	0x00041c5a
   27520:	00041c6c 	.word	0x00041c6c

00027524 <nvs_write>:

ssize_t nvs_write(struct nvs_fs *fs, u16_t id, const void *data, size_t len)
{
   27524:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27528:	461e      	mov	r6, r3
	struct nvs_ate wlk_ate;
	u32_t wlk_addr, rd_addr;
	u16_t required_space = 0U; /* no space, appropriate for delete ate */
	bool prev_found = false;

	if (!fs->ready) {
   2752a:	7c43      	ldrb	r3, [r0, #17]
{
   2752c:	b089      	sub	sp, #36	; 0x24
   2752e:	4604      	mov	r4, r0
   27530:	4689      	mov	r9, r1
   27532:	4690      	mov	r8, r2
	if (!fs->ready) {
   27534:	b99b      	cbnz	r3, 2755e <nvs_write+0x3a>
		LOG_ERR("NVS not initialized");
   27536:	2301      	movs	r3, #1
   27538:	f04f 0000 	mov.w	r0, #0
   2753c:	4a68      	ldr	r2, [pc, #416]	; (276e0 <nvs_write+0x1bc>)
   2753e:	f363 0007 	bfi	r0, r3, #0, #8
   27542:	4b68      	ldr	r3, [pc, #416]	; (276e4 <nvs_write+0x1c0>)
   27544:	4968      	ldr	r1, [pc, #416]	; (276e8 <nvs_write+0x1c4>)
   27546:	1a9b      	subs	r3, r3, r2
   27548:	08db      	lsrs	r3, r3, #3
   2754a:	f363 108f 	bfi	r0, r3, #6, #10
   2754e:	f015 f944 	bl	3c7da <log_string_sync>
		return -EACCES;
   27552:	f06f 050c 	mvn.w	r5, #12
	}
	rc = len;
end:
	k_mutex_unlock(&fs->nvs_lock);
	return rc;
}
   27556:	4628      	mov	r0, r5
   27558:	b009      	add	sp, #36	; 0x24
   2755a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   2755e:	f890 a010 	ldrb.w	sl, [r0, #16]
   27562:	2108      	movs	r1, #8
   27564:	4650      	mov	r0, sl
   27566:	f015 f9bf 	bl	3c8e8 <nvs_al_size.isra.1>
	if ((len > (fs->sector_size - 3 * ate_size)) ||
   2756a:	89a3      	ldrh	r3, [r4, #12]
   2756c:	eb00 0240 	add.w	r2, r0, r0, lsl #1
   27570:	1a9b      	subs	r3, r3, r2
   27572:	42b3      	cmp	r3, r6
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   27574:	4607      	mov	r7, r0
	if ((len > (fs->sector_size - 3 * ate_size)) ||
   27576:	f0c0 80ae 	bcc.w	276d6 <nvs_write+0x1b2>
   2757a:	b11e      	cbz	r6, 27584 <nvs_write+0x60>
	    ((len > 0) && (data == NULL))) {
   2757c:	f1b8 0f00 	cmp.w	r8, #0
   27580:	f000 80a9 	beq.w	276d6 <nvs_write+0x1b2>
	wlk_addr = fs->ate_wra;
   27584:	6863      	ldr	r3, [r4, #4]
   27586:	9303      	str	r3, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   27588:	aa04      	add	r2, sp, #16
   2758a:	a903      	add	r1, sp, #12
   2758c:	4620      	mov	r0, r4
		rd_addr = wlk_addr;
   2758e:	f8dd b00c 	ldr.w	fp, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   27592:	f7ff fd27 	bl	26fe4 <nvs_prev_ate>
		if (rc) {
   27596:	4605      	mov	r5, r0
   27598:	2800      	cmp	r0, #0
   2759a:	d1dc      	bne.n	27556 <nvs_write+0x32>
		if ((wlk_ate.id == id) && (!nvs_ate_crc8_check(&wlk_ate))) {
   2759c:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   275a0:	454b      	cmp	r3, r9
   275a2:	d005      	beq.n	275b0 <nvs_write+0x8c>
		if (wlk_addr == fs->ate_wra) {
   275a4:	6862      	ldr	r2, [r4, #4]
   275a6:	9b03      	ldr	r3, [sp, #12]
   275a8:	429a      	cmp	r2, r3
   275aa:	d1ed      	bne.n	27588 <nvs_write+0x64>
		if (len == 0) {
   275ac:	b9de      	cbnz	r6, 275e6 <nvs_write+0xc2>
   275ae:	e7d2      	b.n	27556 <nvs_write+0x32>
		if ((wlk_ate.id == id) && (!nvs_ate_crc8_check(&wlk_ate))) {
   275b0:	a804      	add	r0, sp, #16
   275b2:	f015 f984 	bl	3c8be <nvs_ate_crc8_check>
   275b6:	2800      	cmp	r0, #0
   275b8:	d1f4      	bne.n	275a4 <nvs_write+0x80>
		if (len == 0) {
   275ba:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   275be:	b186      	cbz	r6, 275e2 <nvs_write+0xbe>
		} else if (len == wlk_ate.len) {
   275c0:	42b3      	cmp	r3, r6
   275c2:	d110      	bne.n	275e6 <nvs_write+0xc2>
		rd_addr += wlk_ate.offset;
   275c4:	f8bd 0012 	ldrh.w	r0, [sp, #18]
		rd_addr &= ADDR_SECT_MASK;
   275c8:	ea4f 411b 	mov.w	r1, fp, lsr #16
   275cc:	0409      	lsls	r1, r1, #16
			rc = nvs_flash_block_cmp(fs, rd_addr, data, len);
   275ce:	4401      	add	r1, r0
   275d0:	4633      	mov	r3, r6
   275d2:	4642      	mov	r2, r8
   275d4:	4620      	mov	r0, r4
   275d6:	f015 f94a 	bl	3c86e <nvs_flash_block_cmp>
			if (rc <= 0) {
   275da:	2800      	cmp	r0, #0
   275dc:	dc03      	bgt.n	275e6 <nvs_write+0xc2>
   275de:	4605      	mov	r5, r0
   275e0:	e7b9      	b.n	27556 <nvs_write+0x32>
			if (wlk_ate.len == 0U) {
   275e2:	2b00      	cmp	r3, #0
   275e4:	d0b7      	beq.n	27556 <nvs_write+0x32>
	data_size = nvs_al_size(fs, len);
   275e6:	4631      	mov	r1, r6
   275e8:	4650      	mov	r0, sl
   275ea:	f015 f97d 	bl	3c8e8 <nvs_al_size.isra.1>
	if (data_size) {
   275ee:	2800      	cmp	r0, #0
   275f0:	d13e      	bne.n	27670 <nvs_write+0x14c>
	u16_t required_space = 0U; /* no space, appropriate for delete ate */
   275f2:	4607      	mov	r7, r0
	k_mutex_lock(&fs->nvs_lock, K_FOREVER);
   275f4:	f104 0a14 	add.w	sl, r4, #20
	return z_impl_k_mutex_lock(mutex, timeout);
   275f8:	f04f 31ff 	mov.w	r1, #4294967295
   275fc:	4650      	mov	r0, sl
   275fe:	f00e fcf3 	bl	35fe8 <z_impl_k_mutex_lock>
	gc_count = 0;
   27602:	2300      	movs	r3, #0
	fs->ate_wra &= ADDR_SECT_MASK;
   27604:	f8df b0e4 	ldr.w	fp, [pc, #228]	; 276ec <nvs_write+0x1c8>
		if (gc_count == fs->sector_count) {
   27608:	89e2      	ldrh	r2, [r4, #14]
   2760a:	4293      	cmp	r3, r2
   2760c:	d060      	beq.n	276d0 <nvs_write+0x1ac>
		if (fs->ate_wra >= fs->data_wra + required_space) {
   2760e:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
   27612:	1878      	adds	r0, r7, r1
   27614:	4282      	cmp	r2, r0
   27616:	d32e      	bcc.n	27676 <nvs_write+0x152>
	entry.part = 0xff;
   27618:	23ff      	movs	r3, #255	; 0xff
	nvs_ate_crc8_update(&entry);
   2761a:	a806      	add	r0, sp, #24
	entry.id = id;
   2761c:	f8ad 9018 	strh.w	r9, [sp, #24]
	entry.offset = (u16_t)(fs->data_wra & ADDR_OFFS_MASK);
   27620:	f8ad 101a 	strh.w	r1, [sp, #26]
	entry.len = (u16_t)len;
   27624:	f8ad 601c 	strh.w	r6, [sp, #28]
	entry.part = 0xff;
   27628:	f88d 301e 	strb.w	r3, [sp, #30]
	nvs_ate_crc8_update(&entry);
   2762c:	f015 f953 	bl	3c8d6 <nvs_ate_crc8_update>
	if (!len) {
   27630:	b136      	cbz	r6, 27640 <nvs_write+0x11c>
   27632:	4633      	mov	r3, r6
   27634:	4642      	mov	r2, r8
   27636:	68a1      	ldr	r1, [r4, #8]
   27638:	4620      	mov	r0, r4
   2763a:	f015 f98c 	bl	3c956 <nvs_flash_al_wrt.part.3>
   2763e:	4605      	mov	r5, r0
	fs->data_wra += nvs_al_size(fs, len);
   27640:	4631      	mov	r1, r6
   27642:	7c20      	ldrb	r0, [r4, #16]
   27644:	f015 f950 	bl	3c8e8 <nvs_al_size.isra.1>
   27648:	68a3      	ldr	r3, [r4, #8]
   2764a:	4418      	add	r0, r3
   2764c:	60a0      	str	r0, [r4, #8]
	if (rc) {
   2764e:	2d00      	cmp	r5, #0
   27650:	d144      	bne.n	276dc <nvs_write+0x1b8>
	rc = nvs_flash_ate_wrt(fs, &entry);
   27652:	a906      	add	r1, sp, #24
   27654:	4620      	mov	r0, r4
   27656:	f015 f9c4 	bl	3c9e2 <nvs_flash_ate_wrt>
	if (rc) {
   2765a:	4605      	mov	r5, r0
   2765c:	2800      	cmp	r0, #0
   2765e:	d13d      	bne.n	276dc <nvs_write+0x1b8>
	rc = len;
   27660:	4632      	mov	r2, r6
   27662:	9201      	str	r2, [sp, #4]
	return z_impl_k_mutex_unlock(mutex);
   27664:	4650      	mov	r0, sl
   27666:	f00e fd9d 	bl	361a4 <z_impl_k_mutex_unlock>
	return rc;
   2766a:	9a01      	ldr	r2, [sp, #4]
   2766c:	4615      	mov	r5, r2
   2766e:	e772      	b.n	27556 <nvs_write+0x32>
		required_space = data_size + ate_size;
   27670:	4407      	add	r7, r0
   27672:	b2bf      	uxth	r7, r7
   27674:	e7be      	b.n	275f4 <nvs_write+0xd0>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   27676:	2108      	movs	r1, #8
   27678:	7c20      	ldrb	r0, [r4, #16]
   2767a:	9301      	str	r3, [sp, #4]
   2767c:	f015 f934 	bl	3c8e8 <nvs_al_size.isra.1>
	close_ate.id = 0xFFFF;
   27680:	f64f 71ff 	movw	r1, #65535	; 0xffff
   27684:	f8ad 1018 	strh.w	r1, [sp, #24]
	close_ate.len = 0U;
   27688:	2100      	movs	r1, #0
   2768a:	f8ad 101c 	strh.w	r1, [sp, #28]
	close_ate.offset = (u16_t)((fs->ate_wra + ate_size) & ADDR_OFFS_MASK);
   2768e:	1811      	adds	r1, r2, r0
   27690:	f8ad 101a 	strh.w	r1, [sp, #26]
	fs->ate_wra += (fs->sector_size - ate_size);
   27694:	89a1      	ldrh	r1, [r4, #12]
	fs->ate_wra &= ADDR_SECT_MASK;
   27696:	ea02 020b 	and.w	r2, r2, fp
	fs->ate_wra += (fs->sector_size - ate_size);
   2769a:	440a      	add	r2, r1
   2769c:	1a12      	subs	r2, r2, r0
   2769e:	6062      	str	r2, [r4, #4]
	nvs_ate_crc8_update(&close_ate);
   276a0:	a806      	add	r0, sp, #24
   276a2:	f015 f918 	bl	3c8d6 <nvs_ate_crc8_update>
	rc = nvs_flash_ate_wrt(fs, &close_ate);
   276a6:	a906      	add	r1, sp, #24
   276a8:	4620      	mov	r0, r4
   276aa:	f015 f99a 	bl	3c9e2 <nvs_flash_ate_wrt>
	nvs_sector_advance(fs, &fs->ate_wra);
   276ae:	1d21      	adds	r1, r4, #4
   276b0:	89e0      	ldrh	r0, [r4, #14]
   276b2:	f015 f922 	bl	3c8fa <nvs_sector_advance.isra.2>
	fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
   276b6:	6862      	ldr	r2, [r4, #4]
		rc = nvs_gc(fs);
   276b8:	4620      	mov	r0, r4
	fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
   276ba:	ea02 020b 	and.w	r2, r2, fp
   276be:	60a2      	str	r2, [r4, #8]
		rc = nvs_gc(fs);
   276c0:	f7ff fd02 	bl	270c8 <nvs_gc>
		if (rc) {
   276c4:	4602      	mov	r2, r0
   276c6:	2800      	cmp	r0, #0
   276c8:	d1cb      	bne.n	27662 <nvs_write+0x13e>
		gc_count++;
   276ca:	9b01      	ldr	r3, [sp, #4]
   276cc:	3301      	adds	r3, #1
		if (gc_count == fs->sector_count) {
   276ce:	e79b      	b.n	27608 <nvs_write+0xe4>
			rc = -ENOSPC;
   276d0:	f06f 021b 	mvn.w	r2, #27
   276d4:	e7c5      	b.n	27662 <nvs_write+0x13e>
		return -EINVAL;
   276d6:	f06f 0515 	mvn.w	r5, #21
   276da:	e73c      	b.n	27556 <nvs_write+0x32>
			if (rc) {
   276dc:	462a      	mov	r2, r5
   276de:	e7c0      	b.n	27662 <nvs_write+0x13e>
   276e0:	0003f8d4 	.word	0x0003f8d4
   276e4:	0003f93c 	.word	0x0003f93c
   276e8:	00041b70 	.word	0x00041b70
   276ec:	ffff0000 	.word	0xffff0000

000276f0 <nvs_read_hist>:
	return nvs_write(fs, id, NULL, 0);
}

ssize_t nvs_read_hist(struct nvs_fs *fs, u16_t id, void *data, size_t len,
		      u16_t cnt)
{
   276f0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   276f4:	461f      	mov	r7, r3
	u32_t wlk_addr, rd_addr;
	u16_t cnt_his;
	struct nvs_ate wlk_ate;
	size_t ate_size;

	if (!fs->ready) {
   276f6:	7c43      	ldrb	r3, [r0, #17]
{
   276f8:	4604      	mov	r4, r0
   276fa:	468a      	mov	sl, r1
   276fc:	4691      	mov	r9, r2
   276fe:	f8bd 8030 	ldrh.w	r8, [sp, #48]	; 0x30
	if (!fs->ready) {
   27702:	b993      	cbnz	r3, 2772a <nvs_read_hist+0x3a>
		LOG_ERR("NVS not initialized");
   27704:	2301      	movs	r3, #1
   27706:	f04f 0000 	mov.w	r0, #0
   2770a:	4a2a      	ldr	r2, [pc, #168]	; (277b4 <nvs_read_hist+0xc4>)
   2770c:	f363 0007 	bfi	r0, r3, #0, #8
   27710:	4b29      	ldr	r3, [pc, #164]	; (277b8 <nvs_read_hist+0xc8>)
   27712:	492a      	ldr	r1, [pc, #168]	; (277bc <nvs_read_hist+0xcc>)
   27714:	1a9b      	subs	r3, r3, r2
   27716:	08db      	lsrs	r3, r3, #3
   27718:	f363 108f 	bfi	r0, r3, #6, #10
   2771c:	f015 f85d 	bl	3c7da <log_string_sync>
		return -EACCES;
   27720:	f06f 000c 	mvn.w	r0, #12

	return wlk_ate.len;

err:
	return rc;
}
   27724:	b004      	add	sp, #16
   27726:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   2772a:	2108      	movs	r1, #8
   2772c:	7c00      	ldrb	r0, [r0, #16]
   2772e:	f015 f8db 	bl	3c8e8 <nvs_al_size.isra.1>
	if (len > (fs->sector_size - 2 * ate_size)) {
   27732:	89a3      	ldrh	r3, [r4, #12]
   27734:	eba3 0040 	sub.w	r0, r3, r0, lsl #1
   27738:	42b8      	cmp	r0, r7
   2773a:	d338      	bcc.n	277ae <nvs_read_hist+0xbe>
	cnt_his = 0U;
   2773c:	2500      	movs	r5, #0
	wlk_addr = fs->ate_wra;
   2773e:	6863      	ldr	r3, [r4, #4]
   27740:	9301      	str	r3, [sp, #4]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   27742:	aa02      	add	r2, sp, #8
   27744:	a901      	add	r1, sp, #4
   27746:	4620      	mov	r0, r4
		rd_addr = wlk_addr;
   27748:	9e01      	ldr	r6, [sp, #4]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   2774a:	f7ff fc4b 	bl	26fe4 <nvs_prev_ate>
		if (rc) {
   2774e:	2800      	cmp	r0, #0
   27750:	d1e8      	bne.n	27724 <nvs_read_hist+0x34>
		if ((wlk_ate.id == id) &&  (!nvs_ate_crc8_check(&wlk_ate))) {
   27752:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   27756:	4553      	cmp	r3, sl
   27758:	d105      	bne.n	27766 <nvs_read_hist+0x76>
   2775a:	a802      	add	r0, sp, #8
   2775c:	f015 f8af 	bl	3c8be <nvs_ate_crc8_check>
   27760:	b908      	cbnz	r0, 27766 <nvs_read_hist+0x76>
			cnt_his++;
   27762:	3501      	adds	r5, #1
   27764:	b2ad      	uxth	r5, r5
		if (wlk_addr == fs->ate_wra) {
   27766:	6862      	ldr	r2, [r4, #4]
   27768:	9b01      	ldr	r3, [sp, #4]
   2776a:	429a      	cmp	r2, r3
   2776c:	d018      	beq.n	277a0 <nvs_read_hist+0xb0>
	while (cnt_his <= cnt) {
   2776e:	4545      	cmp	r5, r8
   27770:	d9e7      	bls.n	27742 <nvs_read_hist+0x52>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
   27772:	f8bd 300c 	ldrh.w	r3, [sp, #12]
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
   27776:	b1bb      	cbz	r3, 277a8 <nvs_read_hist+0xb8>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
   27778:	4545      	cmp	r5, r8
   2777a:	d315      	bcc.n	277a8 <nvs_read_hist+0xb8>
	rd_addr += wlk_ate.offset;
   2777c:	f8bd 000a 	ldrh.w	r0, [sp, #10]
	rd_addr &= ADDR_SECT_MASK;
   27780:	0c31      	lsrs	r1, r6, #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
   27782:	42bb      	cmp	r3, r7
	rd_addr &= ADDR_SECT_MASK;
   27784:	ea4f 4101 	mov.w	r1, r1, lsl #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
   27788:	bf28      	it	cs
   2778a:	463b      	movcs	r3, r7
   2778c:	4401      	add	r1, r0
   2778e:	464a      	mov	r2, r9
   27790:	4620      	mov	r0, r4
   27792:	f015 f85e 	bl	3c852 <nvs_flash_rd>
	if (rc) {
   27796:	2800      	cmp	r0, #0
   27798:	d1c4      	bne.n	27724 <nvs_read_hist+0x34>
	return wlk_ate.len;
   2779a:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   2779e:	e7c1      	b.n	27724 <nvs_read_hist+0x34>
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
   277a0:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   277a4:	4553      	cmp	r3, sl
   277a6:	d0e4      	beq.n	27772 <nvs_read_hist+0x82>
		return -ENOENT;
   277a8:	f06f 0001 	mvn.w	r0, #1
   277ac:	e7ba      	b.n	27724 <nvs_read_hist+0x34>
		return -EINVAL;
   277ae:	f06f 0015 	mvn.w	r0, #21
   277b2:	e7b7      	b.n	27724 <nvs_read_hist+0x34>
   277b4:	0003f8d4 	.word	0x0003f8d4
   277b8:	0003f93c 	.word	0x0003f93c
   277bc:	00041b70 	.word	0x00041b70

000277c0 <socket_offload_register>:

/* Only one provider may register socket operations upon boot. */
const struct socket_offload *socket_ops;

void socket_offload_register(const struct socket_offload *ops)
{
   277c0:	b538      	push	{r3, r4, r5, lr}
	__ASSERT_NO_MSG(ops);
   277c2:	4605      	mov	r5, r0
   277c4:	b948      	cbnz	r0, 277da <socket_offload_register+0x1a>
   277c6:	490c      	ldr	r1, [pc, #48]	; (277f8 <socket_offload_register+0x38>)
   277c8:	480c      	ldr	r0, [pc, #48]	; (277fc <socket_offload_register+0x3c>)
   277ca:	2311      	movs	r3, #17
   277cc:	4a0c      	ldr	r2, [pc, #48]	; (27800 <socket_offload_register+0x40>)
   277ce:	f014 ffad 	bl	3c72c <printk>
   277d2:	2111      	movs	r1, #17
   277d4:	480a      	ldr	r0, [pc, #40]	; (27800 <socket_offload_register+0x40>)
   277d6:	f014 ffef 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops == NULL);
   277da:	4c0a      	ldr	r4, [pc, #40]	; (27804 <socket_offload_register+0x44>)
   277dc:	6822      	ldr	r2, [r4, #0]
   277de:	b14a      	cbz	r2, 277f4 <socket_offload_register+0x34>
   277e0:	4909      	ldr	r1, [pc, #36]	; (27808 <socket_offload_register+0x48>)
   277e2:	4806      	ldr	r0, [pc, #24]	; (277fc <socket_offload_register+0x3c>)
   277e4:	2312      	movs	r3, #18
   277e6:	4a06      	ldr	r2, [pc, #24]	; (27800 <socket_offload_register+0x40>)
   277e8:	f014 ffa0 	bl	3c72c <printk>
   277ec:	2112      	movs	r1, #18
   277ee:	4804      	ldr	r0, [pc, #16]	; (27800 <socket_offload_register+0x40>)
   277f0:	f014 ffe2 	bl	3c7b8 <assert_post_action>

	socket_ops = ops;
   277f4:	6025      	str	r5, [r4, #0]
}
   277f6:	bd38      	pop	{r3, r4, r5, pc}
   277f8:	000411b1 	.word	0x000411b1
   277fc:	00040606 	.word	0x00040606
   27800:	00041c95 	.word	0x00041c95
   27804:	20024aec 	.word	0x20024aec
   27808:	00041cd0 	.word	0x00041cd0

0002780c <clk_init>:
 * symbol.
 */
void nrf_power_clock_isr(void *arg);

static int clk_init(struct device *dev)
{
   2780c:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   2780e:	2200      	movs	r2, #0
{
   27810:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   27812:	2101      	movs	r1, #1
   27814:	2005      	movs	r0, #5
   27816:	f000 fc9d 	bl	28154 <z_arm_irq_priority_set>
		    DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0_PRIORITY,
		    nrf_power_clock_isr, 0, 0);

	irq_enable(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0);
   2781a:	2005      	movs	r0, #5
   2781c:	f000 fc8a 	bl	28134 <arch_irq_enable>
    return false;
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
   27820:	2202      	movs	r2, #2
   27822:	4b07      	ldr	r3, [pc, #28]	; (27840 <clk_init+0x34>)
 *
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
   27824:	2000      	movs	r0, #0
   27826:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    p_reg->INTENSET = mask;
   2782a:	2203      	movs	r2, #3
   2782c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

	clock_irqs_enable();

	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		sys_slist_init(&(get_sub_data(dev, i)->list));
   27830:	68a3      	ldr	r3, [r4, #8]
	list->tail = NULL;
   27832:	e9c3 0000 	strd	r0, r0, [r3]
   27836:	68a3      	ldr	r3, [r4, #8]
   27838:	e9c3 0003 	strd	r0, r0, [r3, #12]
	}

	return 0;
}
   2783c:	bd10      	pop	{r4, pc}
   2783e:	bf00      	nop
   27840:	40005000 	.word	0x40005000

00027844 <get_status>:
{
   27844:	b538      	push	{r3, r4, r5, lr}
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   27846:	b2cc      	uxtb	r4, r1
   27848:	2c01      	cmp	r4, #1
{
   2784a:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   2784c:	d909      	bls.n	27862 <get_status+0x1e>
   2784e:	490b      	ldr	r1, [pc, #44]	; (2787c <get_status+0x38>)
   27850:	480b      	ldr	r0, [pc, #44]	; (27880 <get_status+0x3c>)
   27852:	2384      	movs	r3, #132	; 0x84
   27854:	4a0b      	ldr	r2, [pc, #44]	; (27884 <get_status+0x40>)
   27856:	f014 ff69 	bl	3c72c <printk>
   2785a:	2184      	movs	r1, #132	; 0x84
   2785c:	4809      	ldr	r0, [pc, #36]	; (27884 <get_status+0x40>)
   2785e:	f014 ffab 	bl	3c7b8 <assert_post_action>
	if (data->started) {
   27862:	210c      	movs	r1, #12
	data = get_sub_data(dev, type);
   27864:	68ab      	ldr	r3, [r5, #8]
	if (data->started) {
   27866:	fb04 3101 	mla	r1, r4, r1, r3
   2786a:	7a4b      	ldrb	r3, [r1, #9]
   2786c:	b923      	cbnz	r3, 27878 <get_status+0x34>
	if (data->ref > 0) {
   2786e:	7a08      	ldrb	r0, [r1, #8]
		return CLOCK_CONTROL_STATUS_ON;
   27870:	fab0 f080 	clz	r0, r0
   27874:	0940      	lsrs	r0, r0, #5
}
   27876:	bd38      	pop	{r3, r4, r5, pc}
		return CLOCK_CONTROL_STATUS_ON;
   27878:	2002      	movs	r0, #2
   2787a:	e7fc      	b.n	27876 <get_status+0x32>
   2787c:	00041d8b 	.word	0x00041d8b
   27880:	00040606 	.word	0x00040606
   27884:	00041d50 	.word	0x00041d50

00027888 <clock_async_start>:
{
   27888:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
   2788c:	b2ce      	uxtb	r6, r1
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   2788e:	2e01      	cmp	r6, #1
{
   27890:	4607      	mov	r7, r0
   27892:	4614      	mov	r4, r2
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   27894:	d909      	bls.n	278aa <clock_async_start+0x22>
   27896:	4949      	ldr	r1, [pc, #292]	; (279bc <clock_async_start+0x134>)
   27898:	4849      	ldr	r0, [pc, #292]	; (279c0 <clock_async_start+0x138>)
   2789a:	23fd      	movs	r3, #253	; 0xfd
   2789c:	4a49      	ldr	r2, [pc, #292]	; (279c4 <clock_async_start+0x13c>)
   2789e:	f014 ff45 	bl	3c72c <printk>
   278a2:	21fd      	movs	r1, #253	; 0xfd
   278a4:	4847      	ldr	r0, [pc, #284]	; (279c4 <clock_async_start+0x13c>)
   278a6:	f014 ff87 	bl	3c7b8 <assert_post_action>
	const struct nrf_clock_control_config *config =
   278aa:	683b      	ldr	r3, [r7, #0]
	clk_data = get_sub_data(dev, type);
   278ac:	f8d7 8008 	ldr.w	r8, [r7, #8]
	const struct nrf_clock_control_config *config =
   278b0:	f8d3 9008 	ldr.w	r9, [r3, #8]
	__ASSERT_NO_MSG((data == NULL) ||
   278b4:	2c00      	cmp	r4, #0
   278b6:	d157      	bne.n	27968 <clock_async_start+0xe0>
	__asm__ volatile(
   278b8:	f04f 0320 	mov.w	r3, #32
   278bc:	f3ef 8a11 	mrs	sl, BASEPRI
   278c0:	f383 8811 	msr	BASEPRI, r3
   278c4:	f3bf 8f6f 	isb	sy
	ref = ++clk_data->ref;
   278c8:	230c      	movs	r3, #12
   278ca:	fb03 8306 	mla	r3, r3, r6, r8
   278ce:	7a1d      	ldrb	r5, [r3, #8]
   278d0:	3501      	adds	r5, #1
   278d2:	b2ed      	uxtb	r5, r5
   278d4:	721d      	strb	r5, [r3, #8]
	__ASSERT_NO_MSG(clk_data->ref > 0);
   278d6:	b95d      	cbnz	r5, 278f0 <clock_async_start+0x68>
   278d8:	493b      	ldr	r1, [pc, #236]	; (279c8 <clock_async_start+0x140>)
   278da:	4839      	ldr	r0, [pc, #228]	; (279c0 <clock_async_start+0x138>)
   278dc:	f44f 7387 	mov.w	r3, #270	; 0x10e
   278e0:	4a38      	ldr	r2, [pc, #224]	; (279c4 <clock_async_start+0x13c>)
   278e2:	f014 ff23 	bl	3c72c <printk>
   278e6:	f44f 7187 	mov.w	r1, #270	; 0x10e
   278ea:	4836      	ldr	r0, [pc, #216]	; (279c4 <clock_async_start+0x13c>)
   278ec:	f014 ff64 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   278f0:	f38a 8811 	msr	BASEPRI, sl
   278f4:	f3bf 8f6f 	isb	sy
	if (data) {
   278f8:	b32c      	cbz	r4, 27946 <clock_async_start+0xbe>
    p_reg->INTENCLR = mask;
   278fa:	2203      	movs	r2, #3
   278fc:	4b33      	ldr	r3, [pc, #204]	; (279cc <clock_async_start+0x144>)
   278fe:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
		already_started = clk_data->started;
   27902:	220c      	movs	r2, #12
   27904:	4372      	muls	r2, r6
   27906:	eb08 0302 	add.w	r3, r8, r2
   2790a:	7a59      	ldrb	r1, [r3, #9]
		if (!already_started) {
   2790c:	b991      	cbnz	r1, 27934 <clock_async_start+0xac>
	__asm__ volatile(
   2790e:	f04f 0020 	mov.w	r0, #32
   27912:	f3ef 8c11 	mrs	ip, BASEPRI
   27916:	f380 8811 	msr	BASEPRI, r0
   2791a:	f3bf 8f6f 	isb	sy
	return node->next;
}

static inline void z_snode_next_set(sys_snode_t *parent, sys_snode_t *child)
{
	parent->next = child;
   2791e:	6021      	str	r1, [r4, #0]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
   27920:	6858      	ldr	r0, [r3, #4]
   27922:	2800      	cmp	r0, #0
   27924:	d13a      	bne.n	2799c <clock_async_start+0x114>
	list->tail = node;
   27926:	605c      	str	r4, [r3, #4]
	list->head = node;
   27928:	f848 4002 	str.w	r4, [r8, r2]
	__asm__ volatile(
   2792c:	f38c 8811 	msr	BASEPRI, ip
   27930:	f3bf 8f6f 	isb	sy
    p_reg->INTENSET = mask;
   27934:	2203      	movs	r2, #3
   27936:	4b25      	ldr	r3, [pc, #148]	; (279cc <clock_async_start+0x144>)
   27938:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		if (already_started) {
   2793c:	b119      	cbz	r1, 27946 <clock_async_start+0xbe>
			data->cb(dev, data->user_data);
   2793e:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
   27942:	4638      	mov	r0, r7
   27944:	4798      	blx	r3
	if (ref == 1) {
   27946:	2d01      	cmp	r5, #1
   27948:	d10c      	bne.n	27964 <clock_async_start+0xdc>
		do_start =  (config->start_handler) ?
   2794a:	0135      	lsls	r5, r6, #4
   2794c:	f859 3005 	ldr.w	r3, [r9, r5]
				config->start_handler(dev) : true;
   27950:	bb3b      	cbnz	r3, 279a2 <clock_async_start+0x11a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   27952:	2201      	movs	r2, #1
			nrf_clock_task_trigger(NRF_CLOCK,
   27954:	44a9      	add	r9, r5
   27956:	f899 300a 	ldrb.w	r3, [r9, #10]
   2795a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   2795e:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
   27962:	601a      	str	r2, [r3, #0]
	return 0;
   27964:	2000      	movs	r0, #0
   27966:	e027      	b.n	279b8 <clock_async_start+0x130>
	__ASSERT_NO_MSG((data == NULL) ||
   27968:	6863      	ldr	r3, [r4, #4]
   2796a:	b95b      	cbnz	r3, 27984 <clock_async_start+0xfc>
   2796c:	4918      	ldr	r1, [pc, #96]	; (279d0 <clock_async_start+0x148>)
   2796e:	4814      	ldr	r0, [pc, #80]	; (279c0 <clock_async_start+0x138>)
   27970:	f44f 7381 	mov.w	r3, #258	; 0x102
   27974:	4a13      	ldr	r2, [pc, #76]	; (279c4 <clock_async_start+0x13c>)
   27976:	f014 fed9 	bl	3c72c <printk>
   2797a:	f44f 7181 	mov.w	r1, #258	; 0x102
   2797e:	4811      	ldr	r0, [pc, #68]	; (279c4 <clock_async_start+0x13c>)
   27980:	f014 ff1a 	bl	3c7b8 <assert_post_action>
	sys_snode_t *item = sys_slist_peek_head(list);
   27984:	230c      	movs	r3, #12
   27986:	4373      	muls	r3, r6
   27988:	f858 3003 	ldr.w	r3, [r8, r3]
		if (item == node) {
   2798c:	429c      	cmp	r4, r3
   2798e:	d011      	beq.n	279b4 <clock_async_start+0x12c>
Z_GENLIST_PEEK_NEXT(slist, snode)
   27990:	2b00      	cmp	r3, #0
   27992:	d091      	beq.n	278b8 <clock_async_start+0x30>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   27994:	681b      	ldr	r3, [r3, #0]
	} while (item);
   27996:	2b00      	cmp	r3, #0
   27998:	d1f8      	bne.n	2798c <clock_async_start+0x104>
   2799a:	e78d      	b.n	278b8 <clock_async_start+0x30>
	parent->next = child;
   2799c:	6004      	str	r4, [r0, #0]
	list->tail = node;
   2799e:	605c      	str	r4, [r3, #4]
   279a0:	e7c4      	b.n	2792c <clock_async_start+0xa4>
				config->start_handler(dev) : true;
   279a2:	4638      	mov	r0, r7
   279a4:	4798      	blx	r3
   279a6:	2800      	cmp	r0, #0
   279a8:	d1d3      	bne.n	27952 <clock_async_start+0xca>
			clkstarted_handle(dev, type);
   279aa:	4631      	mov	r1, r6
   279ac:	4638      	mov	r0, r7
   279ae:	f015 f830 	bl	3ca12 <clkstarted_handle>
   279b2:	e7d7      	b.n	27964 <clock_async_start+0xdc>
		return -EBUSY;
   279b4:	f06f 000f 	mvn.w	r0, #15
}
   279b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   279bc:	00041d8b 	.word	0x00041d8b
   279c0:	00040606 	.word	0x00040606
   279c4:	00041d50 	.word	0x00041d50
   279c8:	00041d3e 	.word	0x00041d3e
   279cc:	40005000 	.word	0x40005000
   279d0:	00041cf0 	.word	0x00041cf0

000279d4 <clock_stop>:
{
   279d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   279d8:	b2cd      	uxtb	r5, r1
   279da:	2d01      	cmp	r5, #1
{
   279dc:	4680      	mov	r8, r0
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   279de:	d909      	bls.n	279f4 <clock_stop+0x20>
   279e0:	4925      	ldr	r1, [pc, #148]	; (27a78 <clock_stop+0xa4>)
   279e2:	4826      	ldr	r0, [pc, #152]	; (27a7c <clock_stop+0xa8>)
   279e4:	2399      	movs	r3, #153	; 0x99
   279e6:	4a26      	ldr	r2, [pc, #152]	; (27a80 <clock_stop+0xac>)
   279e8:	f014 fea0 	bl	3c72c <printk>
   279ec:	2199      	movs	r1, #153	; 0x99
   279ee:	4824      	ldr	r0, [pc, #144]	; (27a80 <clock_stop+0xac>)
   279f0:	f014 fee2 	bl	3c7b8 <assert_post_action>
	const struct nrf_clock_control_config *config =
   279f4:	f8d8 3000 	ldr.w	r3, [r8]
	data = get_sub_data(dev, type);
   279f8:	f8d8 7008 	ldr.w	r7, [r8, #8]
	const struct nrf_clock_control_config *config =
   279fc:	f8d3 9008 	ldr.w	r9, [r3, #8]
	__asm__ volatile(
   27a00:	f04f 0320 	mov.w	r3, #32
   27a04:	f3ef 8611 	mrs	r6, BASEPRI
   27a08:	f383 8811 	msr	BASEPRI, r3
   27a0c:	f3bf 8f6f 	isb	sy
	if (data->ref == 0) {
   27a10:	220c      	movs	r2, #12
   27a12:	436a      	muls	r2, r5
   27a14:	18b9      	adds	r1, r7, r2
   27a16:	7a0b      	ldrb	r3, [r1, #8]
   27a18:	b34b      	cbz	r3, 27a6e <clock_stop+0x9a>
	data->ref--;
   27a1a:	3b01      	subs	r3, #1
   27a1c:	b2db      	uxtb	r3, r3
   27a1e:	720b      	strb	r3, [r1, #8]
	if (data->ref == 0) {
   27a20:	bb43      	cbnz	r3, 27a74 <clock_stop+0xa0>
		do_stop =  (config->stop_handler) ?
   27a22:	012c      	lsls	r4, r5, #4
	list->head = NULL;
   27a24:	50bb      	str	r3, [r7, r2]
	list->tail = NULL;
   27a26:	604b      	str	r3, [r1, #4]
   27a28:	eb09 0304 	add.w	r3, r9, r4
   27a2c:	685b      	ldr	r3, [r3, #4]
				config->stop_handler(dev) : true;
   27a2e:	b9cb      	cbnz	r3, 27a64 <clock_stop+0x90>
   27a30:	2201      	movs	r2, #1
			nrf_clock_task_trigger(NRF_CLOCK, config->stop_tsk);
   27a32:	444c      	add	r4, r9
   27a34:	7ae3      	ldrb	r3, [r4, #11]
   27a36:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   27a3a:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
   27a3e:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   27a40:	2200      	movs	r2, #0
   27a42:	8923      	ldrh	r3, [r4, #8]
   27a44:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   27a48:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
   27a4c:	601a      	str	r2, [r3, #0]
		data->started = false;
   27a4e:	230c      	movs	r3, #12
   27a50:	2000      	movs	r0, #0
   27a52:	fb05 7503 	mla	r5, r5, r3, r7
   27a56:	7268      	strb	r0, [r5, #9]
	__asm__ volatile(
   27a58:	f386 8811 	msr	BASEPRI, r6
   27a5c:	f3bf 8f6f 	isb	sy
}
   27a60:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				config->stop_handler(dev) : true;
   27a64:	4640      	mov	r0, r8
   27a66:	4798      	blx	r3
   27a68:	2800      	cmp	r0, #0
   27a6a:	d1e1      	bne.n	27a30 <clock_stop+0x5c>
   27a6c:	e7ef      	b.n	27a4e <clock_stop+0x7a>
		err = -EALREADY;
   27a6e:	f06f 0077 	mvn.w	r0, #119	; 0x77
   27a72:	e7f1      	b.n	27a58 <clock_stop+0x84>
	int err = 0;
   27a74:	2000      	movs	r0, #0
   27a76:	e7ef      	b.n	27a58 <clock_stop+0x84>
   27a78:	00041d8b 	.word	0x00041d8b
   27a7c:	00040606 	.word	0x00040606
   27a80:	00041d50 	.word	0x00041d50

00027a84 <nrf_power_clock_isr>:
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
   27a84:	b508      	push	{r3, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   27a86:	4b10      	ldr	r3, [pc, #64]	; (27ac8 <nrf_power_clock_isr+0x44>)
   27a88:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
   27a8a:	b162      	cbz	r2, 27aa6 <nrf_power_clock_isr+0x22>
    return p_reg->INTENSET & mask;
   27a8c:	4a0f      	ldr	r2, [pc, #60]	; (27acc <nrf_power_clock_isr+0x48>)
   27a8e:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
   27a92:	07d1      	lsls	r1, r2, #31
   27a94:	d507      	bpl.n	27aa6 <nrf_power_clock_isr+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   27a96:	2200      	movs	r2, #0
	struct device *dev = DEVICE_GET(clock_nrf);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
   27a98:	480d      	ldr	r0, [pc, #52]	; (27ad0 <nrf_power_clock_isr+0x4c>)
   27a9a:	601a      	str	r2, [r3, #0]

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
   27a9c:	6883      	ldr	r3, [r0, #8]
   27a9e:	7a59      	ldrb	r1, [r3, #9]
   27aa0:	b909      	cbnz	r1, 27aa6 <nrf_power_clock_isr+0x22>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
   27aa2:	f014 ffb6 	bl	3ca12 <clkstarted_handle>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   27aa6:	4b0b      	ldr	r3, [pc, #44]	; (27ad4 <nrf_power_clock_isr+0x50>)
   27aa8:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
   27aaa:	b162      	cbz	r2, 27ac6 <nrf_power_clock_isr+0x42>
    return p_reg->INTENSET & mask;
   27aac:	4a07      	ldr	r2, [pc, #28]	; (27acc <nrf_power_clock_isr+0x48>)
   27aae:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
   27ab2:	0792      	lsls	r2, r2, #30
   27ab4:	d507      	bpl.n	27ac6 <nrf_power_clock_isr+0x42>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   27ab6:	2200      	movs	r2, #0
					NRF_CLOCK_INT_LF_STARTED_MASK)) {
		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started(dev);
		}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   27ab8:	2101      	movs	r1, #1
   27aba:	601a      	str	r2, [r3, #0]
   27abc:	4804      	ldr	r0, [pc, #16]	; (27ad0 <nrf_power_clock_isr+0x4c>)
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
   27abe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   27ac2:	f014 bfa6 	b.w	3ca12 <clkstarted_handle>
}
   27ac6:	bd08      	pop	{r3, pc}
   27ac8:	40005100 	.word	0x40005100
   27acc:	40005000 	.word	0x40005000
   27ad0:	20037940 	.word	0x20037940
   27ad4:	40005104 	.word	0x40005104

00027ad8 <z_clock_isr>:
#include <drivers/timer/system_timer.h>

/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
   27ad8:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(false);
   27ada:	4c06      	ldr	r4, [pc, #24]	; (27af4 <z_clock_isr+0x1c>)
   27adc:	4906      	ldr	r1, [pc, #24]	; (27af8 <z_clock_isr+0x20>)
   27ade:	4622      	mov	r2, r4
   27ae0:	4806      	ldr	r0, [pc, #24]	; (27afc <z_clock_isr+0x24>)
   27ae2:	2317      	movs	r3, #23
   27ae4:	f014 fe22 	bl	3c72c <printk>
   27ae8:	4620      	mov	r0, r4
}
   27aea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__ASSERT_NO_MSG(false);
   27aee:	2117      	movs	r1, #23
   27af0:	f014 be62 	b.w	3c7b8 <assert_post_action>
   27af4:	00041dd9 	.word	0x00041dd9
   27af8:	00043e6b 	.word	0x00043e6b
   27afc:	00040606 	.word	0x00040606

00027b00 <rtc1_nrf_isr>:
 * symbol.
 */
void rtc1_nrf_isr(void *arg)
{
	ARG_UNUSED(arg);
	RTC->EVENTS_COMPARE[0] = 0;
   27b00:	2200      	movs	r2, #0
{
   27b02:	b538      	push	{r3, r4, r5, lr}
	RTC->EVENTS_COMPARE[0] = 0;
   27b04:	4b22      	ldr	r3, [pc, #136]	; (27b90 <rtc1_nrf_isr+0x90>)
   27b06:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
	__asm__ volatile(
   27b0a:	f04f 0320 	mov.w	r3, #32
   27b0e:	f3ef 8511 	mrs	r5, BASEPRI
   27b12:	f383 8811 	msr	BASEPRI, r3
   27b16:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27b1a:	481e      	ldr	r0, [pc, #120]	; (27b94 <rtc1_nrf_isr+0x94>)
   27b1c:	f010 f810 	bl	37b40 <z_spin_lock_valid>
   27b20:	b968      	cbnz	r0, 27b3e <rtc1_nrf_isr+0x3e>
   27b22:	234a      	movs	r3, #74	; 0x4a
   27b24:	4a1c      	ldr	r2, [pc, #112]	; (27b98 <rtc1_nrf_isr+0x98>)
   27b26:	491d      	ldr	r1, [pc, #116]	; (27b9c <rtc1_nrf_isr+0x9c>)
   27b28:	481d      	ldr	r0, [pc, #116]	; (27ba0 <rtc1_nrf_isr+0xa0>)
   27b2a:	f014 fdff 	bl	3c72c <printk>
   27b2e:	4919      	ldr	r1, [pc, #100]	; (27b94 <rtc1_nrf_isr+0x94>)
   27b30:	481c      	ldr	r0, [pc, #112]	; (27ba4 <rtc1_nrf_isr+0xa4>)
   27b32:	f014 fdfb 	bl	3c72c <printk>
   27b36:	214a      	movs	r1, #74	; 0x4a
   27b38:	4817      	ldr	r0, [pc, #92]	; (27b98 <rtc1_nrf_isr+0x98>)
   27b3a:	f014 fe3d 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   27b3e:	4815      	ldr	r0, [pc, #84]	; (27b94 <rtc1_nrf_isr+0x94>)
   27b40:	f010 f81c 	bl	37b7c <z_spin_lock_set_owner>
#endif
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
   27b44:	4b12      	ldr	r3, [pc, #72]	; (27b90 <rtc1_nrf_isr+0x90>)

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t t = counter();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
   27b46:	4a18      	ldr	r2, [pc, #96]	; (27ba8 <rtc1_nrf_isr+0xa8>)
   27b48:	f8d3 4504 	ldr.w	r4, [r3, #1284]	; 0x504
   27b4c:	6813      	ldr	r3, [r2, #0]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27b4e:	4811      	ldr	r0, [pc, #68]	; (27b94 <rtc1_nrf_isr+0x94>)
	return (a - b) & COUNTER_MAX;
   27b50:	1ae4      	subs	r4, r4, r3
   27b52:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
   27b56:	4423      	add	r3, r4
   27b58:	6013      	str	r3, [r2, #0]
   27b5a:	f00f ffff 	bl	37b5c <z_spin_unlock_valid>
   27b5e:	b968      	cbnz	r0, 27b7c <rtc1_nrf_isr+0x7c>
   27b60:	235d      	movs	r3, #93	; 0x5d
   27b62:	4a0d      	ldr	r2, [pc, #52]	; (27b98 <rtc1_nrf_isr+0x98>)
   27b64:	4911      	ldr	r1, [pc, #68]	; (27bac <rtc1_nrf_isr+0xac>)
   27b66:	480e      	ldr	r0, [pc, #56]	; (27ba0 <rtc1_nrf_isr+0xa0>)
   27b68:	f014 fde0 	bl	3c72c <printk>
   27b6c:	4909      	ldr	r1, [pc, #36]	; (27b94 <rtc1_nrf_isr+0x94>)
   27b6e:	4810      	ldr	r0, [pc, #64]	; (27bb0 <rtc1_nrf_isr+0xb0>)
   27b70:	f014 fddc 	bl	3c72c <printk>
   27b74:	215d      	movs	r1, #93	; 0x5d
   27b76:	4808      	ldr	r0, [pc, #32]	; (27b98 <rtc1_nrf_isr+0x98>)
   27b78:	f014 fe1e 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   27b7c:	f385 8811 	msr	BASEPRI, r5
   27b80:	f3bf 8f6f 	isb	sy
		}
		set_comparator(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
   27b84:	4620      	mov	r0, r4
}
   27b86:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
   27b8a:	f010 bc5f 	b.w	3844c <z_clock_announce>
   27b8e:	bf00      	nop
   27b90:	40015000 	.word	0x40015000
   27b94:	20024b0c 	.word	0x20024b0c
   27b98:	000405cb 	.word	0x000405cb
   27b9c:	000405f1 	.word	0x000405f1
   27ba0:	00040606 	.word	0x00040606
   27ba4:	00040623 	.word	0x00040623
   27ba8:	20024b08 	.word	0x20024b08
   27bac:	00040665 	.word	0x00040665
   27bb0:	0004067c 	.word	0x0004067c

00027bb4 <z_clock_driver_init>:

int z_clock_driver_init(struct device *device)
{
   27bb4:	b570      	push	{r4, r5, r6, lr}
   27bb6:	4815      	ldr	r0, [pc, #84]	; (27c0c <z_clock_driver_init+0x58>)
   27bb8:	f00d fd32 	bl	35620 <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_INST_0_NORDIC_NRF_CLOCK_LABEL);
	if (!clock) {
   27bbc:	b310      	cbz	r0, 27c04 <z_clock_driver_init+0x50>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
   27bbe:	6843      	ldr	r3, [r0, #4]
   27bc0:	2101      	movs	r1, #1
   27bc2:	681b      	ldr	r3, [r3, #0]
   27bc4:	4798      	blx	r3
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
   27bc6:	2400      	movs	r4, #0
    p_reg->CC[ch] = cc_val;
   27bc8:	2601      	movs	r6, #1
    p_reg->INTENSET = mask;
   27bca:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   27bce:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    p_reg->PRESCALER = val;
   27bd2:	4d0f      	ldr	r5, [pc, #60]	; (27c10 <z_clock_driver_init+0x5c>)

	/* Clear the event flag and possible pending interrupt */
	nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_COMPARE_0);
	NVIC_ClearPendingIRQ(RTC1_IRQn);

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
   27bd4:	4631      	mov	r1, r6
   27bd6:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
   27bda:	f8c5 6540 	str.w	r6, [r5, #1344]	; 0x540
    p_reg->INTENSET = mask;
   27bde:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   27be2:	4b0c      	ldr	r3, [pc, #48]	; (27c14 <z_clock_driver_init+0x60>)
   27be4:	2015      	movs	r0, #21
   27be6:	601c      	str	r4, [r3, #0]
   27be8:	4b0b      	ldr	r3, [pc, #44]	; (27c18 <z_clock_driver_init+0x64>)
   27bea:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   27bee:	4622      	mov	r2, r4
   27bf0:	f000 fab0 	bl	28154 <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
   27bf4:	2015      	movs	r0, #21
   27bf6:	f000 fa9d 	bl	28134 <arch_irq_enable>

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
	}

	return 0;
   27bfa:	4620      	mov	r0, r4
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   27bfc:	4b07      	ldr	r3, [pc, #28]	; (27c1c <z_clock_driver_init+0x68>)
   27bfe:	601e      	str	r6, [r3, #0]
   27c00:	602e      	str	r6, [r5, #0]
}
   27c02:	bd70      	pop	{r4, r5, r6, pc}
		return -1;
   27c04:	f04f 30ff 	mov.w	r0, #4294967295
   27c08:	e7fb      	b.n	27c02 <z_clock_driver_init+0x4e>
   27c0a:	bf00      	nop
   27c0c:	00041daf 	.word	0x00041daf
   27c10:	40015000 	.word	0x40015000
   27c14:	40015140 	.word	0x40015140
   27c18:	e000e100 	.word	0xe000e100
   27c1c:	40015008 	.word	0x40015008

00027c20 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
   27c20:	b570      	push	{r4, r5, r6, lr}
	ARG_UNUSED(idle);

#ifdef CONFIG_TICKLESS_KERNEL
	ticks = (ticks == K_FOREVER) ? MAX_TICKS : ticks;
   27c22:	4c3a      	ldr	r4, [pc, #232]	; (27d0c <z_clock_set_timeout+0xec>)
   27c24:	f1b0 3fff 	cmp.w	r0, #4294967295
   27c28:	bf18      	it	ne
   27c2a:	4604      	movne	r4, r0
	__asm__ volatile(
   27c2c:	f04f 0320 	mov.w	r3, #32
   27c30:	f3ef 8511 	mrs	r5, BASEPRI
   27c34:	f383 8811 	msr	BASEPRI, r3
   27c38:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27c3c:	4834      	ldr	r0, [pc, #208]	; (27d10 <z_clock_set_timeout+0xf0>)
   27c3e:	f00f ff7f 	bl	37b40 <z_spin_lock_valid>
   27c42:	b968      	cbnz	r0, 27c60 <z_clock_set_timeout+0x40>
   27c44:	234a      	movs	r3, #74	; 0x4a
   27c46:	4a33      	ldr	r2, [pc, #204]	; (27d14 <z_clock_set_timeout+0xf4>)
   27c48:	4933      	ldr	r1, [pc, #204]	; (27d18 <z_clock_set_timeout+0xf8>)
   27c4a:	4834      	ldr	r0, [pc, #208]	; (27d1c <z_clock_set_timeout+0xfc>)
   27c4c:	f014 fd6e 	bl	3c72c <printk>
   27c50:	492f      	ldr	r1, [pc, #188]	; (27d10 <z_clock_set_timeout+0xf0>)
   27c52:	4833      	ldr	r0, [pc, #204]	; (27d20 <z_clock_set_timeout+0x100>)
   27c54:	f014 fd6a 	bl	3c72c <printk>
   27c58:	214a      	movs	r1, #74	; 0x4a
   27c5a:	482e      	ldr	r0, [pc, #184]	; (27d14 <z_clock_set_timeout+0xf4>)
   27c5c:	f014 fdac 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   27c60:	482b      	ldr	r0, [pc, #172]	; (27d10 <z_clock_set_timeout+0xf0>)
   27c62:	f00f ff8b 	bl	37b7c <z_spin_lock_set_owner>
     return p_reg->COUNTER;
   27c66:	4b2f      	ldr	r3, [pc, #188]	; (27d24 <z_clock_set_timeout+0x104>)
   27c68:	4e28      	ldr	r6, [pc, #160]	; (27d0c <z_clock_set_timeout+0xec>)
   27c6a:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t cyc, dt, t = counter();
	u32_t unannounced = counter_sub(t, last_count);
   27c6e:	4b2e      	ldr	r3, [pc, #184]	; (27d28 <z_clock_set_timeout+0x108>)
   27c70:	681b      	ldr	r3, [r3, #0]
	return (a - b) & COUNTER_MAX;
   27c72:	1ad0      	subs	r0, r2, r3
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
   27c74:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
	return (a - b) & COUNTER_MAX;
   27c78:	f020 417f 	bic.w	r1, r0, #4278190080	; 0xff000000
	if (unannounced >= COUNTER_HALF_SPAN) {
   27c7c:	d12c      	bne.n	27cd8 <z_clock_set_timeout+0xb8>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
   27c7e:	1e60      	subs	r0, r4, #1
   27c80:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   27c84:	42b0      	cmp	r0, r6
   27c86:	bfa8      	it	ge
   27c88:	4630      	movge	r0, r6
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
   27c8a:	3101      	adds	r1, #1
   27c8c:	4408      	add	r0, r1
	 */
	if (cyc > MAX_CYCLES) {
		cyc = MAX_CYCLES;
	}

	cyc += last_count;
   27c8e:	42b0      	cmp	r0, r6
   27c90:	bf94      	ite	ls
   27c92:	181b      	addls	r3, r3, r0
   27c94:	199b      	addhi	r3, r3, r6
	return (a - b) & COUNTER_MAX;
   27c96:	1a9a      	subs	r2, r3, r2
   27c98:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
   27c9c:	4921      	ldr	r1, [pc, #132]	; (27d24 <z_clock_set_timeout+0x104>)
   27c9e:	f023 407f 	bic.w	r0, r3, #4278190080	; 0xff000000
	 * least on nRF52.  Some experimentation on nrf52840 shows
	 * that you need to be early by about 400 processor cycles
	 * (about 1/5th of a RTC cycle) in order to reliably get the
	 * interrupt.  The docs say two cycles, they mean two cycles.
	 */
	if (counter_sub(cyc, t) > 2) {
   27ca2:	2a02      	cmp	r2, #2
    p_reg->CC[ch] = cc_val;
   27ca4:	f8c1 0540 	str.w	r0, [r1, #1344]	; 0x540
   27ca8:	d918      	bls.n	27cdc <z_clock_set_timeout+0xbc>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27caa:	4819      	ldr	r0, [pc, #100]	; (27d10 <z_clock_set_timeout+0xf0>)
   27cac:	f00f ff56 	bl	37b5c <z_spin_unlock_valid>
   27cb0:	b968      	cbnz	r0, 27cce <z_clock_set_timeout+0xae>
   27cb2:	235d      	movs	r3, #93	; 0x5d
   27cb4:	4a17      	ldr	r2, [pc, #92]	; (27d14 <z_clock_set_timeout+0xf4>)
   27cb6:	491d      	ldr	r1, [pc, #116]	; (27d2c <z_clock_set_timeout+0x10c>)
   27cb8:	4818      	ldr	r0, [pc, #96]	; (27d1c <z_clock_set_timeout+0xfc>)
   27cba:	f014 fd37 	bl	3c72c <printk>
   27cbe:	4914      	ldr	r1, [pc, #80]	; (27d10 <z_clock_set_timeout+0xf0>)
   27cc0:	481b      	ldr	r0, [pc, #108]	; (27d30 <z_clock_set_timeout+0x110>)
   27cc2:	f014 fd33 	bl	3c72c <printk>
   27cc6:	215d      	movs	r1, #93	; 0x5d
   27cc8:	4812      	ldr	r0, [pc, #72]	; (27d14 <z_clock_set_timeout+0xf4>)
   27cca:	f014 fd75 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   27cce:	f385 8811 	msr	BASEPRI, r5
   27cd2:	f3bf 8f6f 	isb	sy
	}
#endif

	k_spin_unlock(&lock, key);
#endif /* CONFIG_TICKLESS_KERNEL */
}
   27cd6:	bd70      	pop	{r4, r5, r6, pc}
		ticks = 0;
   27cd8:	2000      	movs	r0, #0
   27cda:	e7d6      	b.n	27c8a <z_clock_set_timeout+0x6a>
     return p_reg->COUNTER;
   27cdc:	f8d1 2504 	ldr.w	r2, [r1, #1284]	; 0x504
		if (dt == 0 || dt > 0x7fffff) {
   27ce0:	4814      	ldr	r0, [pc, #80]	; (27d34 <z_clock_set_timeout+0x114>)
	return (a - b) & COUNTER_MAX;
   27ce2:	1a9a      	subs	r2, r3, r2
   27ce4:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
		if (dt == 0 || dt > 0x7fffff) {
   27ce8:	1e54      	subs	r4, r2, #1
   27cea:	4284      	cmp	r4, r0
   27cec:	d905      	bls.n	27cfa <z_clock_set_timeout+0xda>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   27cee:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   27cf2:	4b11      	ldr	r3, [pc, #68]	; (27d38 <z_clock_set_timeout+0x118>)
   27cf4:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   27cf8:	e7d7      	b.n	27caa <z_clock_set_timeout+0x8a>
		} else if (dt == 1) {
   27cfa:	2a01      	cmp	r2, #1
			set_comparator(cyc + 2);
   27cfc:	bf02      	ittt	eq
   27cfe:	3302      	addeq	r3, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
   27d00:	f023 437f 	biceq.w	r3, r3, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
   27d04:	f8c1 3540 	streq.w	r3, [r1, #1344]	; 0x540
   27d08:	e7cf      	b.n	27caa <z_clock_set_timeout+0x8a>
   27d0a:	bf00      	nop
   27d0c:	00fffffe 	.word	0x00fffffe
   27d10:	20024b0c 	.word	0x20024b0c
   27d14:	000405cb 	.word	0x000405cb
   27d18:	000405f1 	.word	0x000405f1
   27d1c:	00040606 	.word	0x00040606
   27d20:	00040623 	.word	0x00040623
   27d24:	40015000 	.word	0x40015000
   27d28:	20024b08 	.word	0x20024b08
   27d2c:	00040665 	.word	0x00040665
   27d30:	0004067c 	.word	0x0004067c
   27d34:	007ffffe 	.word	0x007ffffe
   27d38:	e000e100 	.word	0xe000e100

00027d3c <z_clock_elapsed>:

u32_t z_clock_elapsed(void)
{
   27d3c:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   27d3e:	f04f 0320 	mov.w	r3, #32
   27d42:	f3ef 8511 	mrs	r5, BASEPRI
   27d46:	f383 8811 	msr	BASEPRI, r3
   27d4a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27d4e:	481a      	ldr	r0, [pc, #104]	; (27db8 <z_clock_elapsed+0x7c>)
   27d50:	f00f fef6 	bl	37b40 <z_spin_lock_valid>
   27d54:	b968      	cbnz	r0, 27d72 <z_clock_elapsed+0x36>
   27d56:	234a      	movs	r3, #74	; 0x4a
   27d58:	4a18      	ldr	r2, [pc, #96]	; (27dbc <z_clock_elapsed+0x80>)
   27d5a:	4919      	ldr	r1, [pc, #100]	; (27dc0 <z_clock_elapsed+0x84>)
   27d5c:	4819      	ldr	r0, [pc, #100]	; (27dc4 <z_clock_elapsed+0x88>)
   27d5e:	f014 fce5 	bl	3c72c <printk>
   27d62:	4915      	ldr	r1, [pc, #84]	; (27db8 <z_clock_elapsed+0x7c>)
   27d64:	4818      	ldr	r0, [pc, #96]	; (27dc8 <z_clock_elapsed+0x8c>)
   27d66:	f014 fce1 	bl	3c72c <printk>
   27d6a:	214a      	movs	r1, #74	; 0x4a
   27d6c:	4813      	ldr	r0, [pc, #76]	; (27dbc <z_clock_elapsed+0x80>)
   27d6e:	f014 fd23 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   27d72:	4811      	ldr	r0, [pc, #68]	; (27db8 <z_clock_elapsed+0x7c>)
   27d74:	f00f ff02 	bl	37b7c <z_spin_lock_set_owner>
     return p_reg->COUNTER;
   27d78:	4b14      	ldr	r3, [pc, #80]	; (27dcc <z_clock_elapsed+0x90>)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27d7a:	480f      	ldr	r0, [pc, #60]	; (27db8 <z_clock_elapsed+0x7c>)
   27d7c:	f8d3 4504 	ldr.w	r4, [r3, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
   27d80:	4b13      	ldr	r3, [pc, #76]	; (27dd0 <z_clock_elapsed+0x94>)
	return (a - b) & COUNTER_MAX;
   27d82:	681b      	ldr	r3, [r3, #0]
   27d84:	1ae4      	subs	r4, r4, r3
   27d86:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
   27d8a:	f00f fee7 	bl	37b5c <z_spin_unlock_valid>
   27d8e:	b968      	cbnz	r0, 27dac <z_clock_elapsed+0x70>
   27d90:	235d      	movs	r3, #93	; 0x5d
   27d92:	4a0a      	ldr	r2, [pc, #40]	; (27dbc <z_clock_elapsed+0x80>)
   27d94:	490f      	ldr	r1, [pc, #60]	; (27dd4 <z_clock_elapsed+0x98>)
   27d96:	480b      	ldr	r0, [pc, #44]	; (27dc4 <z_clock_elapsed+0x88>)
   27d98:	f014 fcc8 	bl	3c72c <printk>
   27d9c:	4906      	ldr	r1, [pc, #24]	; (27db8 <z_clock_elapsed+0x7c>)
   27d9e:	480e      	ldr	r0, [pc, #56]	; (27dd8 <z_clock_elapsed+0x9c>)
   27da0:	f014 fcc4 	bl	3c72c <printk>
   27da4:	215d      	movs	r1, #93	; 0x5d
   27da6:	4805      	ldr	r0, [pc, #20]	; (27dbc <z_clock_elapsed+0x80>)
   27da8:	f014 fd06 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   27dac:	f385 8811 	msr	BASEPRI, r5
   27db0:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
   27db4:	4620      	mov	r0, r4
   27db6:	bd38      	pop	{r3, r4, r5, pc}
   27db8:	20024b0c 	.word	0x20024b0c
   27dbc:	000405cb 	.word	0x000405cb
   27dc0:	000405f1 	.word	0x000405f1
   27dc4:	00040606 	.word	0x00040606
   27dc8:	00040623 	.word	0x00040623
   27dcc:	40015000 	.word	0x40015000
   27dd0:	20024b08 	.word	0x20024b08
   27dd4:	00040665 	.word	0x00040665
   27dd8:	0004067c 	.word	0x0004067c

00027ddc <z_timer_cycle_get_32>:

u32_t z_timer_cycle_get_32(void)
{
   27ddc:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   27dde:	f04f 0320 	mov.w	r3, #32
   27de2:	f3ef 8511 	mrs	r5, BASEPRI
   27de6:	f383 8811 	msr	BASEPRI, r3
   27dea:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27dee:	481b      	ldr	r0, [pc, #108]	; (27e5c <z_timer_cycle_get_32+0x80>)
   27df0:	f00f fea6 	bl	37b40 <z_spin_lock_valid>
   27df4:	b968      	cbnz	r0, 27e12 <z_timer_cycle_get_32+0x36>
   27df6:	234a      	movs	r3, #74	; 0x4a
   27df8:	4a19      	ldr	r2, [pc, #100]	; (27e60 <z_timer_cycle_get_32+0x84>)
   27dfa:	491a      	ldr	r1, [pc, #104]	; (27e64 <z_timer_cycle_get_32+0x88>)
   27dfc:	481a      	ldr	r0, [pc, #104]	; (27e68 <z_timer_cycle_get_32+0x8c>)
   27dfe:	f014 fc95 	bl	3c72c <printk>
   27e02:	4916      	ldr	r1, [pc, #88]	; (27e5c <z_timer_cycle_get_32+0x80>)
   27e04:	4819      	ldr	r0, [pc, #100]	; (27e6c <z_timer_cycle_get_32+0x90>)
   27e06:	f014 fc91 	bl	3c72c <printk>
   27e0a:	214a      	movs	r1, #74	; 0x4a
   27e0c:	4814      	ldr	r0, [pc, #80]	; (27e60 <z_timer_cycle_get_32+0x84>)
   27e0e:	f014 fcd3 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   27e12:	4812      	ldr	r0, [pc, #72]	; (27e5c <z_timer_cycle_get_32+0x80>)
   27e14:	f00f feb2 	bl	37b7c <z_spin_lock_set_owner>
   27e18:	4b15      	ldr	r3, [pc, #84]	; (27e70 <z_timer_cycle_get_32+0x94>)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27e1a:	4810      	ldr	r0, [pc, #64]	; (27e5c <z_timer_cycle_get_32+0x80>)
   27e1c:	f8d3 4504 	ldr.w	r4, [r3, #1284]	; 0x504
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
   27e20:	4b14      	ldr	r3, [pc, #80]	; (27e74 <z_timer_cycle_get_32+0x98>)
   27e22:	681b      	ldr	r3, [r3, #0]
	return (a - b) & COUNTER_MAX;
   27e24:	1ae4      	subs	r4, r4, r3
   27e26:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
	u32_t ret = counter_sub(counter(), last_count) + last_count;
   27e2a:	441c      	add	r4, r3
   27e2c:	f00f fe96 	bl	37b5c <z_spin_unlock_valid>
   27e30:	b968      	cbnz	r0, 27e4e <z_timer_cycle_get_32+0x72>
   27e32:	235d      	movs	r3, #93	; 0x5d
   27e34:	4a0a      	ldr	r2, [pc, #40]	; (27e60 <z_timer_cycle_get_32+0x84>)
   27e36:	4910      	ldr	r1, [pc, #64]	; (27e78 <z_timer_cycle_get_32+0x9c>)
   27e38:	480b      	ldr	r0, [pc, #44]	; (27e68 <z_timer_cycle_get_32+0x8c>)
   27e3a:	f014 fc77 	bl	3c72c <printk>
   27e3e:	4907      	ldr	r1, [pc, #28]	; (27e5c <z_timer_cycle_get_32+0x80>)
   27e40:	480e      	ldr	r0, [pc, #56]	; (27e7c <z_timer_cycle_get_32+0xa0>)
   27e42:	f014 fc73 	bl	3c72c <printk>
   27e46:	215d      	movs	r1, #93	; 0x5d
   27e48:	4805      	ldr	r0, [pc, #20]	; (27e60 <z_timer_cycle_get_32+0x84>)
   27e4a:	f014 fcb5 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   27e4e:	f385 8811 	msr	BASEPRI, r5
   27e52:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
   27e56:	4620      	mov	r0, r4
   27e58:	bd38      	pop	{r3, r4, r5, pc}
   27e5a:	bf00      	nop
   27e5c:	20024b0c 	.word	0x20024b0c
   27e60:	000405cb 	.word	0x000405cb
   27e64:	000405f1 	.word	0x000405f1
   27e68:	00040606 	.word	0x00040606
   27e6c:	00040623 	.word	0x00040623
   27e70:	40015000 	.word	0x40015000
   27e74:	20024b08 	.word	0x20024b08
   27e78:	00040665 	.word	0x00040665
   27e7c:	0004067c 	.word	0x0004067c

00027e80 <_DoInit>:
  SEGGER_RTT_CB* p;
  //
  // Initialize control block
  //
  p = &_SEGGER_RTT;
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   27e80:	2303      	movs	r3, #3
static void _DoInit(void) {
   27e82:	b510      	push	{r4, lr}
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   27e84:	4c10      	ldr	r4, [pc, #64]	; (27ec8 <_DoInit+0x48>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
   27e86:	4a11      	ldr	r2, [pc, #68]	; (27ecc <_DoInit+0x4c>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
   27e88:	e9c4 3304 	strd	r3, r3, [r4, #16]
  p->aUp[0].pBuffer       = _acUpBuffer;
   27e8c:	4b10      	ldr	r3, [pc, #64]	; (27ed0 <_DoInit+0x50>)
  p->aUp[0].sName         = "Terminal";
   27e8e:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
   27e90:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
   27e92:	f44f 6380 	mov.w	r3, #1024	; 0x400
  p->aUp[0].WrOff         = 0u;
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
   27e96:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
   27e98:	4a0e      	ldr	r2, [pc, #56]	; (27ed4 <_DoInit+0x54>)
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
   27e9a:	6223      	str	r3, [r4, #32]
  p->aDown[0].pBuffer       = _acDownBuffer;
   27e9c:	6662      	str	r2, [r4, #100]	; 0x64
  p->aUp[0].RdOff         = 0u;
   27e9e:	2300      	movs	r3, #0
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
   27ea0:	2210      	movs	r2, #16
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  strcpy(&p->acID[7], "RTT");
   27ea2:	490d      	ldr	r1, [pc, #52]	; (27ed8 <_DoInit+0x58>)
   27ea4:	1de0      	adds	r0, r4, #7
  p->aUp[0].RdOff         = 0u;
   27ea6:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
   27ea8:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   27eaa:	62e3      	str	r3, [r4, #44]	; 0x2c
  p->aDown[0].RdOff         = 0u;
   27eac:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
   27eae:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   27eb0:	6763      	str	r3, [r4, #116]	; 0x74
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
   27eb2:	66a2      	str	r2, [r4, #104]	; 0x68
  strcpy(&p->acID[7], "RTT");
   27eb4:	f016 fe53 	bl	3eb5e <strcpy>
  strcpy(&p->acID[0], "SEGGER");
   27eb8:	4908      	ldr	r1, [pc, #32]	; (27edc <_DoInit+0x5c>)
   27eba:	4620      	mov	r0, r4
   27ebc:	f016 fe4f 	bl	3eb5e <strcpy>
  p->acID[6] = ' ';
   27ec0:	2320      	movs	r3, #32
   27ec2:	71a3      	strb	r3, [r4, #6]
}
   27ec4:	bd10      	pop	{r4, pc}
   27ec6:	bf00      	nop
   27ec8:	20024b10 	.word	0x20024b10
   27ecc:	00041e0b 	.word	0x00041e0b
   27ed0:	2002c3c4 	.word	0x2002c3c4
   27ed4:	2002c3b4 	.word	0x2002c3b4
   27ed8:	00041e14 	.word	0x00041e14
   27edc:	00041e18 	.word	0x00041e18

00027ee0 <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   27ee0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  RdOff = pRing->RdOff;
   27ee4:	f04f 0b18 	mov.w	fp, #24
   27ee8:	4e22      	ldr	r6, [pc, #136]	; (27f74 <SEGGER_RTT_WriteSkipNoLock+0x94>)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   27eea:	4614      	mov	r4, r2
  RdOff = pRing->RdOff;
   27eec:	fb0b 6200 	mla	r2, fp, r0, r6
   27ef0:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
   27ef2:	6a55      	ldr	r5, [r2, #36]	; 0x24
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   27ef4:	4607      	mov	r7, r0
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   27ef6:	42ab      	cmp	r3, r5
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   27ef8:	4688      	mov	r8, r1
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   27efa:	d834      	bhi.n	27f66 <SEGGER_RTT_WriteSkipNoLock+0x86>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
   27efc:	f8d2 a020 	ldr.w	sl, [r2, #32]
   27f00:	ebaa 0905 	sub.w	r9, sl, r5
   27f04:	f109 32ff 	add.w	r2, r9, #4294967295
    if (Avail >= NumBytes) {                            // Case 1)?
   27f08:	42a2      	cmp	r2, r4
   27f0a:	d311      	bcc.n	27f30 <SEGGER_RTT_WriteSkipNoLock+0x50>
CopyStraight:
      memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
   27f0c:	f04f 0918 	mov.w	r9, #24
   27f10:	fb07 9309 	mla	r3, r7, r9, r9
   27f14:	4433      	add	r3, r6
   27f16:	6858      	ldr	r0, [r3, #4]
   27f18:	4622      	mov	r2, r4
   27f1a:	4641      	mov	r1, r8
   27f1c:	4428      	add	r0, r5
   27f1e:	f016 fc95 	bl	3e84c <memcpy>
      pRing->WrOff = WrOff + NumBytes;
   27f22:	fb09 6607 	mla	r6, r9, r7, r6
   27f26:	442c      	add	r4, r5
      //
      if (NumBytes) {
        memcpy(pRing->pBuffer, pData + Rem, NumBytes);
      }
      pRing->WrOff = NumBytes;
      return 1;
   27f28:	2001      	movs	r0, #1
      pRing->WrOff = NumBytes;
   27f2a:	6274      	str	r4, [r6, #36]	; 0x24
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
}
   27f2c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Avail += RdOff;                                     // Space incl. wrap-around
   27f30:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
   27f32:	429c      	cmp	r4, r3
   27f34:	d81b      	bhi.n	27f6e <SEGGER_RTT_WriteSkipNoLock+0x8e>
      memcpy(pRing->pBuffer + WrOff, pData, Rem);       // Copy 1st chunk
   27f36:	fb00 bb0b 	mla	fp, r0, fp, fp
   27f3a:	44b3      	add	fp, r6
   27f3c:	f8db 0004 	ldr.w	r0, [fp, #4]
   27f40:	464a      	mov	r2, r9
   27f42:	4428      	add	r0, r5
   27f44:	442c      	add	r4, r5
   27f46:	f016 fc81 	bl	3e84c <memcpy>
      if (NumBytes) {
   27f4a:	ebb4 040a 	subs.w	r4, r4, sl
   27f4e:	d006      	beq.n	27f5e <SEGGER_RTT_WriteSkipNoLock+0x7e>
   27f50:	4622      	mov	r2, r4
   27f52:	eb08 0109 	add.w	r1, r8, r9
   27f56:	f8db 0004 	ldr.w	r0, [fp, #4]
   27f5a:	f016 fc77 	bl	3e84c <memcpy>
      pRing->WrOff = NumBytes;
   27f5e:	2318      	movs	r3, #24
   27f60:	fb03 6607 	mla	r6, r3, r7, r6
   27f64:	e7e0      	b.n	27f28 <SEGGER_RTT_WriteSkipNoLock+0x48>
    Avail = RdOff - WrOff - 1u;
   27f66:	3b01      	subs	r3, #1
   27f68:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
   27f6a:	429c      	cmp	r4, r3
   27f6c:	d9ce      	bls.n	27f0c <SEGGER_RTT_WriteSkipNoLock+0x2c>
  return 0;     // No space in buffer
   27f6e:	2000      	movs	r0, #0
   27f70:	e7dc      	b.n	27f2c <SEGGER_RTT_WriteSkipNoLock+0x4c>
   27f72:	bf00      	nop
   27f74:	20024b10 	.word	0x20024b10

00027f78 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  v = pRing->RdOff;
   27f78:	2318      	movs	r3, #24
   27f7a:	4a03      	ldr	r2, [pc, #12]	; (27f88 <SEGGER_RTT_HasDataUp+0x10>)
   27f7c:	fb03 2300 	mla	r3, r3, r0, r2
   27f80:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  return pRing->WrOff - v;
   27f82:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
   27f84:	1a80      	subs	r0, r0, r2
   27f86:	4770      	bx	lr
   27f88:	20024b10 	.word	0x20024b10

00027f8c <z_arm_exc_exit>:
    /* r0 contains the caller mode */
    push {r0, lr}
#endif

#ifdef CONFIG_PREEMPT_ENABLED
    ldr r0, =_kernel
   27f8c:	4804      	ldr	r0, [pc, #16]	; (27fa0 <_EXIT_EXC+0x2>)

    ldr r1, [r0, #_kernel_offset_to_current]
   27f8e:	6881      	ldr	r1, [r0, #8]

    ldr r0, [r0, #_kernel_offset_to_ready_q_cache]
   27f90:	6a40      	ldr	r0, [r0, #36]	; 0x24
    cmp r0, r1
   27f92:	4288      	cmp	r0, r1
    beq _EXIT_EXC
   27f94:	d003      	beq.n	27f9e <_EXIT_EXC>

#if defined(CONFIG_CPU_CORTEX_M)
    /* context switch required, pend the PendSV exception */
    ldr r1, =_SCS_ICSR
   27f96:	4903      	ldr	r1, [pc, #12]	; (27fa4 <_EXIT_EXC+0x6>)
    ldr r2, =_SCS_ICSR_PENDSV
   27f98:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    str r2, [r1]
   27f9c:	600a      	str	r2, [r1, #0]

00027f9e <_EXIT_EXC>:
    bl z_check_stack_sentinel
#endif /* CONFIG_CPU_CORTEX_M */
#endif /* CONFIG_STACK_SENTINEL */

#if defined(CONFIG_CPU_CORTEX_M)
    bx lr
   27f9e:	4770      	bx	lr
    ldr r0, =_kernel
   27fa0:	2002976c 	.word	0x2002976c
    ldr r1, =_SCS_ICSR
   27fa4:	e000ed04 	.word	0xe000ed04

00027fa8 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   27fa8:	492e      	ldr	r1, [pc, #184]	; (28064 <in_fp_endif+0x40>)
    ldr r2, [r1, #_kernel_offset_to_current]
   27faa:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   27fac:	f04f 0028 	mov.w	r0, #40	; 0x28
    add r0, r2
   27fb0:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   27fb2:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   27fb6:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#ifdef CONFIG_FP_SHARING
    /* Assess whether switched-out thread had been using the FP registers. */
    ldr r0, =0x10 /* EXC_RETURN.F_Type Mask */
   27fba:	f04f 0010 	mov.w	r0, #16
    tst lr, r0    /* EXC_RETURN & EXC_RETURN.F_Type_Msk */
   27fbe:	ea1e 0f00 	tst.w	lr, r0
    beq out_fp_active
   27fc2:	d004      	beq.n	27fce <out_fp_active>
    /* FP context inactive: clear FP state */
    ldr r0, [r2, #_thread_offset_to_mode]
   27fc4:	f8d2 00ac 	ldr.w	r0, [r2, #172]	; 0xac
    bic r0, #0x4 /* _current->arch.mode &= ~(CONTROL_FPCA_Msk) */
   27fc8:	f020 0004 	bic.w	r0, r0, #4
    b out_fp_endif
   27fcc:	e007      	b.n	27fde <out_fp_endif>

00027fce <out_fp_active>:

out_fp_active:
    /* FP context active: set FP state and store callee-saved registers */
    add r0, r2, #_thread_offset_to_preempt_float
   27fce:	f102 006c 	add.w	r0, r2, #108	; 0x6c
    vstmia r0, {s16-s31}
   27fd2:	ec80 8a10 	vstmia	r0, {s16-s31}
    ldr r0, [r2, #_thread_offset_to_mode]
   27fd6:	f8d2 00ac 	ldr.w	r0, [r2, #172]	; 0xac
    orrs r0, r0, #0x4 /* _current->arch.mode |= CONTROL_FPCA_Msk */
   27fda:	f050 0004 	orrs.w	r0, r0, #4

00027fde <out_fp_endif>:

out_fp_endif:
    str r0, [r2, #_thread_offset_to_mode]
   27fde:	f8c2 00ac 	str.w	r0, [r2, #172]	; 0xac

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   27fe2:	2020      	movs	r0, #32
    msr BASEPRI, r0
   27fe4:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   27fe8:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   27fec:	4f1e      	ldr	r7, [pc, #120]	; (28068 <in_fp_endif+0x44>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   27fee:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   27ff2:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
   27ff4:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   27ff6:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   27ff8:	6e50      	ldr	r0, [r2, #100]	; 0x64
    movs r3, #0
   27ffa:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   27ffc:	6653      	str	r3, [r2, #100]	; 0x64
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   27ffe:	f380 8811 	msr	BASEPRI, r0

#ifdef CONFIG_FP_SHARING
    /* Assess whether switched-in thread had been using the FP registers. */
    ldr r0, [r2, #_thread_offset_to_mode]
   28002:	f8d2 00ac 	ldr.w	r0, [r2, #172]	; 0xac
    tst r0, #0x04 /* thread.arch.mode & CONTROL.FPCA Msk */
   28006:	f010 0f04 	tst.w	r0, #4
    bne in_fp_active
   2800a:	d105      	bne.n	28018 <in_fp_active>
    /* FP context inactive for swapped-in thread:
     * - reset FPSCR to 0
     * - set EXC_RETURN.F_Type (prevents FP frame un-stacking when returning
     *   from pendSV)
     */
    movs.n r3, #0
   2800c:	2300      	movs	r3, #0
    vmsr fpscr, r3
   2800e:	eee1 3a10 	vmsr	fpscr, r3
    orrs lr, lr, #0x10 /* EXC_RETURN & EXC_RETURN.F_Type_Msk */
   28012:	f05e 0e10 	orrs.w	lr, lr, #16
    b in_fp_endif
   28016:	e005      	b.n	28024 <in_fp_endif>

00028018 <in_fp_active>:
    /* FP context active:
     * - clear EXC_RETURN.F_Type
     * - FPSCR and caller-saved registers will be restored automatically
     * - restore callee-saved FP registers
     */
    bic lr, #0x10 /* EXC_RETURN | (~EXC_RETURN.F_Type_Msk) */
   28018:	f02e 0e10 	bic.w	lr, lr, #16
    add r0, r2, #_thread_offset_to_preempt_float
   2801c:	f102 006c 	add.w	r0, r2, #108	; 0x6c
    vldmia r0, {s16-s31}
   28020:	ec90 8a10 	vldmia	r0, {s16-s31}

00028024 <in_fp_endif>:
in_fp_endif:
    /* Clear CONTROL.FPCA that may have been set by FP instructions */
    mrs r3, CONTROL
   28024:	f3ef 8314 	mrs	r3, CONTROL
    bic r3, #0x4 /* CONTROL.FPCA Msk */
   28028:	f023 0304 	bic.w	r3, r3, #4
    msr CONTROL, r3
   2802c:	f383 8814 	msr	CONTROL, r3
    isb
   28030:	f3bf 8f6f 	isb	sy
#endif

#if defined (CONFIG_ARM_MPU)
    /* Re-program dynamic memory map */
    push {r2,lr}
   28034:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
   28036:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
   28038:	f014 fd2a 	bl	3ca90 <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
   2803c:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   28040:	f102 0028 	add.w	r0, r2, #40	; 0x28
    ldmia r0, {v1-v8, ip}
   28044:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* clear stack pointer limit before setting the PSP */
    mov r0, #0
   28048:	f04f 0000 	mov.w	r0, #0
    msr PSPLIM, r0
   2804c:	f380 880b 	msr	PSPLIM, r0
#endif /* CONFIG_BUILTIN_STACK_GUARD */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   28050:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
   28054:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
   28058:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
   2805a:	f014 fd0a 	bl	3ca72 <configure_builtin_stack_guard>
    pop {r2, lr}
   2805e:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
   28062:	4770      	bx	lr
    ldr r1, =_kernel
   28064:	2002976c 	.word	0x2002976c
    ldr v4, =_SCS_ICSR
   28068:	e000ed04 	.word	0xe000ed04

0002806c <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
   2806c:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   28070:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   28072:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   28076:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   2807a:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   2807c:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   28080:	2902      	cmp	r1, #2
    beq _oops
   28082:	d0ff      	beq.n	28084 <_oops>

00028084 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   28084:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
   28086:	f014 fcf8 	bl	3ca7a <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
   2808a:	bd01      	pop	{r0, pc}

0002808c <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr r1, =_SCB_SCR
   2808c:	4901      	ldr	r1, [pc, #4]	; (28094 <z_arm_cpu_idle_init+0x8>)
	movs.n r2, #_SCR_INIT_BITS
   2808e:	2210      	movs	r2, #16
	str r2, [r1]
   28090:	600a      	str	r2, [r1, #0]
#endif
	bx lr
   28092:	4770      	bx	lr
	ldr r1, =_SCB_SCR
   28094:	e000ed10 	.word	0xe000ed10

00028098 <arch_cpu_idle>:
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	cpsie i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* clear BASEPRI so wfi is awakened by incoming interrupts */
	eors.n r0, r0
   28098:	4040      	eors	r0, r0
	msr BASEPRI, r0
   2809a:	f380 8811 	msr	BASEPRI, r0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	wfi
   2809e:	bf30      	wfi

	bx lr
   280a0:	4770      	bx	lr
   280a2:	bf00      	nop

000280a4 <z_arm_bus_fault>:
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_reserved)

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) || \
	defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	mrs r0, MSP
   280a4:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   280a8:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
   280ac:	4672      	mov	r2, lr

	push {r0, lr}
   280ae:	b501      	push	{r0, lr}
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE || CONFIG_ARMv7_M_ARMV8_M_MAINLINE */

	bl z_arm_fault
   280b0:	f000 fbae 	bl	28810 <z_arm_fault>

#if defined(CONFIG_CPU_CORTEX_M)
	pop {r0, pc}
   280b4:	bd01      	pop	{r0, pc}
   280b6:	bf00      	nop

000280b8 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   280b8:	bf30      	wfi
    b z_SysNmiOnReset
   280ba:	f7ff bffd 	b.w	280b8 <z_SysNmiOnReset>
   280be:	bf00      	nop

000280c0 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   280c0:	b501      	push	{r0, lr}
      * FIXME: Remove the Cortex-M conditional compilation checks for `cpsid i`
      *        and `cpsie i` after the Cortex-R port is updated to support
      *        interrupt nesting.  For more details, refer to the issue #21758.
      */
#if defined(CONFIG_CPU_CORTEX_M)
	cpsid i  /* PRIMASK = 1 */
   280c2:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   280c4:	4a0b      	ldr	r2, [pc, #44]	; (280f4 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   280c6:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
   280c8:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   280ca:	bf1e      	ittt	ne
	movne	r1, #0
   280cc:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   280ce:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
   280d0:	f016 f9d8 	blne	3e484 <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   280d4:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   280d6:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   280da:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   280de:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 */
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldr r1, =_sw_isr_table
   280e2:	4905      	ldr	r1, [pc, #20]	; (280f8 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   280e4:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   280e6:	c909      	ldmia	r1!, {r0, r3}
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldm sp!,{r0-r3} /* Restore r0 to r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
   280e8:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   280ea:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   280ee:	4903      	ldr	r1, [pc, #12]	; (280fc <_isr_wrapper+0x3c>)
	bx r1
   280f0:	4708      	bx	r1
   280f2:	0000      	.short	0x0000
	ldr r2, =_kernel
   280f4:	2002976c 	.word	0x2002976c
	ldr r1, =_sw_isr_table
   280f8:	0003f5b8 	.word	0x0003f5b8
	ldr r1, =z_arm_int_exit
   280fc:	00027f8d 	.word	0x00027f8d

00028100 <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
   28100:	4a09      	ldr	r2, [pc, #36]	; (28128 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
   28102:	490a      	ldr	r1, [pc, #40]	; (2812c <arch_swap+0x2c>)
	_current->arch.basepri = key;
   28104:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   28106:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
   28108:	6658      	str	r0, [r3, #100]	; 0x64
	_current->arch.swap_return_value = _k_neg_eagain;
   2810a:	6699      	str	r1, [r3, #104]	; 0x68

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   2810c:	4908      	ldr	r1, [pc, #32]	; (28130 <arch_swap+0x30>)
   2810e:	684b      	ldr	r3, [r1, #4]
   28110:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   28114:	604b      	str	r3, [r1, #4]
   28116:	2300      	movs	r3, #0
   28118:	f383 8811 	msr	BASEPRI, r3
   2811c:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   28120:	6893      	ldr	r3, [r2, #8]
}
   28122:	6e98      	ldr	r0, [r3, #104]	; 0x68
   28124:	4770      	bx	lr
   28126:	bf00      	nop
   28128:	2002976c 	.word	0x2002976c
   2812c:	00040364 	.word	0x00040364
   28130:	e000ed00 	.word	0xe000ed00

00028134 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   28134:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
   28136:	2b00      	cmp	r3, #0
   28138:	db08      	blt.n	2814c <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   2813a:	2201      	movs	r2, #1
   2813c:	f000 001f 	and.w	r0, r0, #31
   28140:	fa02 f000 	lsl.w	r0, r2, r0
   28144:	4a02      	ldr	r2, [pc, #8]	; (28150 <arch_irq_enable+0x1c>)
   28146:	095b      	lsrs	r3, r3, #5
   28148:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   2814c:	4770      	bx	lr
   2814e:	bf00      	nop
   28150:	e000e100 	.word	0xe000e100

00028154 <z_arm_irq_priority_set>:
 * priority levels which are reserved.
 *
 * @return N/A
 */
void z_arm_irq_priority_set(unsigned int irq, unsigned int prio, u32_t flags)
{
   28154:	b570      	push	{r4, r5, r6, lr}
	} else {
		prio += _IRQ_PRIO_OFFSET;
	}
#else
	ARG_UNUSED(flags);
	prio += _IRQ_PRIO_OFFSET;
   28156:	1c4c      	adds	r4, r1, #1
	/* The last priority level is also used by PendSV exception, but
	 * allow other interrupts to use the same level, even if it ends up
	 * affecting performance (can still be useful on systems with a
	 * reduced set of priorities, like Cortex-M0/M0+).
	 */
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
   28158:	2c07      	cmp	r4, #7
{
   2815a:	4605      	mov	r5, r0
   2815c:	460e      	mov	r6, r1
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
   2815e:	d90e      	bls.n	2817e <z_arm_irq_priority_set+0x2a>
   28160:	235f      	movs	r3, #95	; 0x5f
   28162:	4a10      	ldr	r2, [pc, #64]	; (281a4 <z_arm_irq_priority_set+0x50>)
   28164:	4910      	ldr	r1, [pc, #64]	; (281a8 <z_arm_irq_priority_set+0x54>)
   28166:	4811      	ldr	r0, [pc, #68]	; (281ac <z_arm_irq_priority_set+0x58>)
   28168:	f014 fae0 	bl	3c72c <printk>
   2816c:	4631      	mov	r1, r6
   2816e:	4810      	ldr	r0, [pc, #64]	; (281b0 <z_arm_irq_priority_set+0x5c>)
   28170:	2207      	movs	r2, #7
   28172:	f014 fadb 	bl	3c72c <printk>
   28176:	215f      	movs	r1, #95	; 0x5f
   28178:	480a      	ldr	r0, [pc, #40]	; (281a4 <z_arm_irq_priority_set+0x50>)
   2817a:	f014 fb1d 	bl	3c7b8 <assert_post_action>
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(DT_NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   2817e:	b26b      	sxtb	r3, r5
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   28180:	2b00      	cmp	r3, #0
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   28182:	bfa8      	it	ge
   28184:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
   28188:	ea4f 1444 	mov.w	r4, r4, lsl #5
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2818c:	bfb8      	it	lt
   2818e:	4b09      	ldrlt	r3, [pc, #36]	; (281b4 <z_arm_irq_priority_set+0x60>)
   28190:	b2e4      	uxtb	r4, r4
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   28192:	bfab      	itete	ge
   28194:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   28198:	f005 050f 	andlt.w	r5, r5, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2819c:	f883 4300 	strbge.w	r4, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   281a0:	555c      	strblt	r4, [r3, r5]
}
   281a2:	bd70      	pop	{r4, r5, r6, pc}
   281a4:	00041e1f 	.word	0x00041e1f
   281a8:	00041e55 	.word	0x00041e55
   281ac:	00040606 	.word	0x00040606
   281b0:	00041e70 	.word	0x00041e70
   281b4:	e000ed14 	.word	0xe000ed14

000281b8 <_arch_isr_direct_pm>:
	z_arm_reserved();
}

#ifdef CONFIG_SYS_POWER_MANAGEMENT
void _arch_isr_direct_pm(void)
{
   281b8:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
   281ba:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
   281bc:	4b04      	ldr	r3, [pc, #16]	; (281d0 <_arch_isr_direct_pm+0x18>)
   281be:	6a18      	ldr	r0, [r3, #32]
   281c0:	b118      	cbz	r0, 281ca <_arch_isr_direct_pm+0x12>
		s32_t idle_val = _kernel.idle;

		_kernel.idle = 0;
   281c2:	2200      	movs	r2, #0
   281c4:	621a      	str	r2, [r3, #32]
		z_sys_power_save_idle_exit(idle_val);
   281c6:	f016 f95d 	bl	3e484 <z_sys_power_save_idle_exit>

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
   281ca:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
   281cc:	bd08      	pop	{r3, pc}
   281ce:	bf00      	nop
   281d0:	2002976c 	.word	0x2002976c

000281d4 <arch_new_thread>:
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     size_t stackSize, k_thread_entry_t pEntry,
		     void *parameter1, void *parameter2, void *parameter3,
		     int priority, unsigned int options)
{
   281d4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   281d8:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   281da:	4605      	mov	r5, r0
	char *pStackMem = Z_THREAD_STACK_BUFFER(stack);
	char *stackEnd;
	/* Offset between the top of stack and the high end of stack area. */
	u32_t top_of_stack_offset = 0U;

	Z_ASSERT_VALID_PRIO(priority, pEntry);
   281dc:	2e0f      	cmp	r6, #15
{
   281de:	4688      	mov	r8, r1
   281e0:	4691      	mov	r9, r2
   281e2:	461f      	mov	r7, r3
	Z_ASSERT_VALID_PRIO(priority, pEntry);
   281e4:	d126      	bne.n	28234 <arch_new_thread+0x60>
   281e6:	4b1e      	ldr	r3, [pc, #120]	; (28260 <arch_new_thread+0x8c>)
   281e8:	429f      	cmp	r7, r3
   281ea:	d127      	bne.n	2823c <arch_new_thread+0x68>
#endif
	stackEnd = pStackMem + stackSize;

	struct __esf *pInitCtx;

	z_new_thread_init(thread, pStackMem, stackSize, priority,
   281ec:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   281ee:	464a      	mov	r2, r9
   281f0:	9300      	str	r3, [sp, #0]
   281f2:	4641      	mov	r1, r8
   281f4:	4633      	mov	r3, r6
   281f6:	4628      	mov	r0, r5
   281f8:	f016 f9f5 	bl	3e5e6 <z_new_thread_init>
	stackEnd = pStackMem + stackSize;
   281fc:	eb08 0409 	add.w	r4, r8, r9
	pInitCtx->basic.pc = (u32_t)z_thread_entry;
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
   28200:	4a18      	ldr	r2, [pc, #96]	; (28264 <arch_new_thread+0x90>)
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
   28202:	f1a4 0320 	sub.w	r3, r4, #32
   28206:	f023 0307 	bic.w	r3, r3, #7
	pInitCtx->basic.pc &= 0xfffffffe;
   2820a:	f022 0201 	bic.w	r2, r2, #1
   2820e:	619a      	str	r2, [r3, #24]
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
	pInitCtx->basic.a2 = (u32_t)parameter1;
   28210:	9a0a      	ldr	r2, [sp, #40]	; 0x28
	pInitCtx->basic.a1 = (u32_t)pEntry;
   28212:	601f      	str	r7, [r3, #0]
	pInitCtx->basic.a2 = (u32_t)parameter1;
   28214:	605a      	str	r2, [r3, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
   28216:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   28218:	609a      	str	r2, [r3, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
   2821a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   2821c:	60da      	str	r2, [r3, #12]
	pInitCtx->basic.xpsr =
   2821e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   28222:	61da      	str	r2, [r3, #28]
		0x01000000UL; /* clear all, thumb bit is 1, even if RO */

	thread->callee_saved.psp = (u32_t)pInitCtx;
   28224:	64ab      	str	r3, [r5, #72]	; 0x48
#if defined(CONFIG_CPU_CORTEX_R)
	pInitCtx->basic.lr = (u32_t)pInitCtx->basic.pc;
	thread->callee_saved.spsr = A_BIT | T_BIT | MODE_SYS;
	thread->callee_saved.lr = (u32_t)pInitCtx->basic.pc;
#endif
	thread->arch.basepri = 0;
   28226:	2300      	movs	r3, #0
   28228:	666b      	str	r3, [r5, #100]	; 0x64

#if defined(CONFIG_USERSPACE) || defined(CONFIG_FP_SHARING)
	thread->arch.mode = 0;
   2822a:	f8c5 30ac 	str.w	r3, [r5, #172]	; 0xac

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   2822e:	b003      	add	sp, #12
   28230:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	Z_ASSERT_VALID_PRIO(priority, pEntry);
   28234:	f106 0310 	add.w	r3, r6, #16
   28238:	2b1e      	cmp	r3, #30
   2823a:	d9d7      	bls.n	281ec <arch_new_thread+0x18>
   2823c:	232d      	movs	r3, #45	; 0x2d
   2823e:	4a0a      	ldr	r2, [pc, #40]	; (28268 <arch_new_thread+0x94>)
   28240:	490a      	ldr	r1, [pc, #40]	; (2826c <arch_new_thread+0x98>)
   28242:	480b      	ldr	r0, [pc, #44]	; (28270 <arch_new_thread+0x9c>)
   28244:	f014 fa72 	bl	3c72c <printk>
   28248:	4631      	mov	r1, r6
   2824a:	f06f 030f 	mvn.w	r3, #15
   2824e:	220e      	movs	r2, #14
   28250:	4808      	ldr	r0, [pc, #32]	; (28274 <arch_new_thread+0xa0>)
   28252:	f014 fa6b 	bl	3c72c <printk>
   28256:	212d      	movs	r1, #45	; 0x2d
   28258:	4803      	ldr	r0, [pc, #12]	; (28268 <arch_new_thread+0x94>)
   2825a:	f014 faad 	bl	3c7b8 <assert_post_action>
   2825e:	e7c5      	b.n	281ec <arch_new_thread+0x18>
   28260:	00035771 	.word	0x00035771
   28264:	0003c76f 	.word	0x0003c76f
   28268:	00041ea5 	.word	0x00041ea5
   2826c:	00041ed7 	.word	0x00041ed7
   28270:	00040606 	.word	0x00040606
   28274:	00041f64 	.word	0x00041f64

00028278 <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
   28278:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2827a:	461f      	mov	r7, r3
   2827c:	4606      	mov	r6, r0
   2827e:	460d      	mov	r5, r1
   28280:	4614      	mov	r4, r2
// Re-enable using built-in when GCC has been fixed
// || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
  __builtin_arm_set_fpscr(fpscr);
#else
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
   28282:	2300      	movs	r3, #0
   28284:	eee1 3a10 	vmsr	fpscr, r3
  __ASM volatile ("MRS %0, control" : "=r" (result) );
   28288:	f3ef 8214 	mrs	r2, CONTROL
	 * initialized at thread creation for threads that make use of the FP).
	 */
	__set_FPSCR(0);
#if defined(CONFIG_FP_SHARING)
	/* In Sharing mode clearing FPSCR may set the CONTROL.FPCA flag. */
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
   2828c:	f022 0204 	bic.w	r2, r2, #4
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
   28290:	f382 8814 	msr	CONTROL, r2
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
   28294:	f3bf 8f6f 	isb	sy
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   28298:	f000 fc2a 	bl	28af0 <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);

	_current = main_thread;
   2829c:	4b0b      	ldr	r3, [pc, #44]	; (282cc <arch_switch_to_main_thread+0x54>)
	start_of_main_stack =
   2829e:	442c      	add	r4, r5
#ifdef CONFIG_ARM_MPU
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
   282a0:	4630      	mov	r0, r6
	_current = main_thread;
   282a2:	609e      	str	r6, [r3, #8]
	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);
   282a4:	f024 0407 	bic.w	r4, r4, #7
	z_arm_configure_dynamic_mpu_regions(main_thread);
   282a8:	f014 fbf2 	bl	3ca90 <z_arm_configure_dynamic_mpu_regions>
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   282ac:	f385 880b 	msr	PSPLIM, r5

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   282b0:	4638      	mov	r0, r7
   282b2:	f384 8809 	msr	PSP, r4
   282b6:	2100      	movs	r1, #0
   282b8:	b663      	cpsie	if
   282ba:	f381 8811 	msr	BASEPRI, r1
   282be:	f3bf 8f6f 	isb	sy
   282c2:	2200      	movs	r2, #0
   282c4:	2300      	movs	r3, #0
   282c6:	f014 fa52 	bl	3c76e <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   282ca:	bf00      	nop
   282cc:	2002976c 	.word	0x2002976c

000282d0 <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   282d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   282d4:	4681      	mov	r9, r0
   282d6:	b086      	sub	sp, #24

	if (esf != NULL) {
   282d8:	460c      	mov	r4, r1
   282da:	2900      	cmp	r1, #0
   282dc:	d075      	beq.n	283ca <z_arm_fatal_error+0xfa>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
   282de:	2301      	movs	r3, #1
   282e0:	f04f 0000 	mov.w	r0, #0
   282e4:	4d3c      	ldr	r5, [pc, #240]	; (283d8 <z_arm_fatal_error+0x108>)
   282e6:	f363 0007 	bfi	r0, r3, #0, #8
   282ea:	4b3c      	ldr	r3, [pc, #240]	; (283dc <z_arm_fatal_error+0x10c>)
   282ec:	4627      	mov	r7, r4
   282ee:	1aed      	subs	r5, r5, r3
   282f0:	688b      	ldr	r3, [r1, #8]
   282f2:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   282f6:	9300      	str	r3, [sp, #0]
   282f8:	e9d1 2300 	ldrd	r2, r3, [r1]
   282fc:	f365 108f 	bfi	r0, r5, #6, #10
   28300:	4937      	ldr	r1, [pc, #220]	; (283e0 <z_arm_fatal_error+0x110>)
   28302:	f014 fa6a 	bl	3c7da <log_string_sync>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
   28306:	2301      	movs	r3, #1
   28308:	f04f 0000 	mov.w	r0, #0
   2830c:	f363 0007 	bfi	r0, r3, #0, #8
   28310:	6963      	ldr	r3, [r4, #20]
   28312:	f365 108f 	bfi	r0, r5, #6, #10
   28316:	9300      	str	r3, [sp, #0]
   28318:	e9d4 2303 	ldrd	r2, r3, [r4, #12]
   2831c:	4931      	ldr	r1, [pc, #196]	; (283e4 <z_arm_fatal_error+0x114>)
   2831e:	f014 fa5c 	bl	3c7da <log_string_sync>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
   28322:	2301      	movs	r3, #1
   28324:	f04f 0000 	mov.w	r0, #0
   28328:	f363 0007 	bfi	r0, r3, #0, #8
   2832c:	f365 108f 	bfi	r0, r5, #6, #10
   28330:	69e2      	ldr	r2, [r4, #28]
   28332:	492d      	ldr	r1, [pc, #180]	; (283e8 <z_arm_fatal_error+0x118>)
   28334:	f014 fa51 	bl	3c7da <log_string_sync>
	for (int i = 0; i < 16; i += 4) {
   28338:	2600      	movs	r6, #0
		LOG_ERR("s[%2d]:  0x%08x  s[%2d]:  0x%08x"
   2833a:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 283f4 <z_arm_fatal_error+0x124>
   2833e:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
   28342:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   28346:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   2834a:	f043 0301 	orr.w	r3, r3, #1
   2834e:	f363 0807 	bfi	r8, r3, #0, #8
   28352:	1cf3      	adds	r3, r6, #3
   28354:	ed97 7a08 	vldr	s14, [r7, #32]
   28358:	9304      	str	r3, [sp, #16]
   2835a:	edcd 7a05 	vstr	s15, [sp, #20]
   2835e:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
   28362:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   28366:	1cb3      	adds	r3, r6, #2
   28368:	9302      	str	r3, [sp, #8]
   2836a:	edcd 7a03 	vstr	s15, [sp, #12]
   2836e:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
   28372:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   28376:	edcd 7a01 	vstr	s15, [sp, #4]
   2837a:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   2837e:	1c73      	adds	r3, r6, #1
   28380:	f365 188f 	bfi	r8, r5, #6, #10
   28384:	9300      	str	r3, [sp, #0]
   28386:	4632      	mov	r2, r6
   28388:	ee17 3a90 	vmov	r3, s15
   2838c:	4651      	mov	r1, sl
   2838e:	4640      	mov	r0, r8
	for (int i = 0; i < 16; i += 4) {
   28390:	3604      	adds	r6, #4
		LOG_ERR("s[%2d]:  0x%08x  s[%2d]:  0x%08x"
   28392:	f014 fa22 	bl	3c7da <log_string_sync>
	for (int i = 0; i < 16; i += 4) {
   28396:	2e10      	cmp	r6, #16
   28398:	f107 0710 	add.w	r7, r7, #16
   2839c:	d1cf      	bne.n	2833e <z_arm_fatal_error+0x6e>
	LOG_ERR("fpscr:  0x%08x", esf->fpscr);
   2839e:	2301      	movs	r3, #1
   283a0:	f04f 0000 	mov.w	r0, #0
   283a4:	f363 0007 	bfi	r0, r3, #0, #8
   283a8:	f365 108f 	bfi	r0, r5, #6, #10
   283ac:	6e22      	ldr	r2, [r4, #96]	; 0x60
   283ae:	490f      	ldr	r1, [pc, #60]	; (283ec <z_arm_fatal_error+0x11c>)
   283b0:	f014 fa13 	bl	3c7da <log_string_sync>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
   283b4:	f04f 0000 	mov.w	r0, #0
   283b8:	2301      	movs	r3, #1
   283ba:	f363 0007 	bfi	r0, r3, #0, #8
   283be:	f365 108f 	bfi	r0, r5, #6, #10
   283c2:	69a2      	ldr	r2, [r4, #24]
   283c4:	490a      	ldr	r1, [pc, #40]	; (283f0 <z_arm_fatal_error+0x120>)
   283c6:	f014 fa08 	bl	3c7da <log_string_sync>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   283ca:	4621      	mov	r1, r4
   283cc:	4648      	mov	r0, r9
}
   283ce:	b006      	add	sp, #24
   283d0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_fatal_error(reason, esf);
   283d4:	f00d b950 	b.w	35678 <z_fatal_error>
   283d8:	0003f9ac 	.word	0x0003f9ac
   283dc:	0003f8d4 	.word	0x0003f8d4
   283e0:	00041f95 	.word	0x00041f95
   283e4:	00041fc4 	.word	0x00041fc4
   283e8:	00041ff3 	.word	0x00041ff3
   283ec:	00042045 	.word	0x00042045
   283f0:	00042054 	.word	0x00042054
   283f4:	00042002 	.word	0x00042002

000283f8 <z_arm_prep_c>:
#else
#define VECTOR_ADDRESS CONFIG_SRAM_BASE_ADDRESS
#endif
static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   283f8:	4a11      	ldr	r2, [pc, #68]	; (28440 <z_arm_prep_c+0x48>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
   283fa:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   283fc:	4b11      	ldr	r3, [pc, #68]	; (28444 <z_arm_prep_c+0x4c>)
   283fe:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   28402:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   28404:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   28408:	f3bf 8f6f 	isb	sy
	SCB->CPACR |= CPACR_CP10_PRIV_ACCESS | CPACR_CP11_PRIV_ACCESS;
   2840c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   28410:	f442 02a0 	orr.w	r2, r2, #5242880	; 0x500000
   28414:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	FPU->FPCCR = FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk;
   28418:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
   2841c:	f8c3 2234 	str.w	r2, [r3, #564]	; 0x234
  __ASM volatile ("dsb 0xF":::"memory");
   28420:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   28424:	f3bf 8f6f 	isb	sy
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
   28428:	2300      	movs	r3, #0
   2842a:	eee1 3a10 	vmsr	fpscr, r3
	relocate_vector_table();
	enable_floating_point();
	z_bss_zero();
   2842e:	f00d f9b9 	bl	357a4 <z_bss_zero>
	z_data_copy();
   28432:	f00d f9c1 	bl	357b8 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_int_lib_init();
   28436:	f000 fb11 	bl	28a5c <z_arm_int_lib_init>
	z_cstart();
   2843a:	f00d f9ef 	bl	3581c <z_cstart>
   2843e:	bf00      	nop
   28440:	0001c200 	.word	0x0001c200
   28444:	e000ed00 	.word	0xe000ed00

00028448 <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
   28448:	f014 f9be 	bl	3c7c8 <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   2844c:	2020      	movs	r0, #32
    msr BASEPRI, r0
   2844e:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to _interrupt_stack during initialization.
     */
    ldr r0, =_interrupt_stack
   28452:	4808      	ldr	r0, [pc, #32]	; (28474 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
   28454:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   28458:	1840      	adds	r0, r0, r1
    msr PSP, r0
   2845a:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   2845e:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   28462:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   28464:	4308      	orrs	r0, r1
    msr CONTROL, r0
   28466:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   2846a:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   2846e:	f7ff ffc3 	bl	283f8 <z_arm_prep_c>
   28472:	0000      	.short	0x0000
    ldr r0, =_interrupt_stack
   28474:	20032088 	.word	0x20032088

00028478 <mem_manage_fault.isra.2>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   28478:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			      bool *recoverable)
{
	u32_t reason = K_ERR_CPU_EXCEPTION;
	u32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");
   2847a:	2301      	movs	r3, #1
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   2847c:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** MPU FAULT *****");
   2847e:	f04f 0000 	mov.w	r0, #0
   28482:	4c40      	ldr	r4, [pc, #256]	; (28584 <mem_manage_fault.isra.2+0x10c>)
   28484:	f363 0007 	bfi	r0, r3, #0, #8
   28488:	4b3f      	ldr	r3, [pc, #252]	; (28588 <mem_manage_fault.isra.2+0x110>)
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   2848a:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
   2848c:	1ae4      	subs	r4, r4, r3
   2848e:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   28492:	493e      	ldr	r1, [pc, #248]	; (2858c <mem_manage_fault.isra.2+0x114>)
   28494:	f364 108f 	bfi	r0, r4, #6, #10
   28498:	f014 f99f 	bl	3c7da <log_string_sync>

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   2849c:	4b3c      	ldr	r3, [pc, #240]	; (28590 <mem_manage_fault.isra.2+0x118>)
   2849e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   284a0:	06d9      	lsls	r1, r3, #27
   284a2:	d509      	bpl.n	284b8 <mem_manage_fault.isra.2+0x40>
		PR_FAULT_INFO("  Stacking error (context area might be"
   284a4:	f04f 0000 	mov.w	r0, #0
   284a8:	2301      	movs	r3, #1
   284aa:	f363 0007 	bfi	r0, r3, #0, #8
   284ae:	f364 108f 	bfi	r0, r4, #6, #10
   284b2:	4938      	ldr	r1, [pc, #224]	; (28594 <mem_manage_fault.isra.2+0x11c>)
   284b4:	f014 f991 	bl	3c7da <log_string_sync>
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   284b8:	4b35      	ldr	r3, [pc, #212]	; (28590 <mem_manage_fault.isra.2+0x118>)
   284ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   284bc:	071a      	lsls	r2, r3, #28
   284be:	d509      	bpl.n	284d4 <mem_manage_fault.isra.2+0x5c>
		PR_FAULT_INFO("  Unstacking error");
   284c0:	f04f 0000 	mov.w	r0, #0
   284c4:	2301      	movs	r3, #1
   284c6:	f363 0007 	bfi	r0, r3, #0, #8
   284ca:	f364 108f 	bfi	r0, r4, #6, #10
   284ce:	4932      	ldr	r1, [pc, #200]	; (28598 <mem_manage_fault.isra.2+0x120>)
   284d0:	f014 f983 	bl	3c7da <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   284d4:	4d2e      	ldr	r5, [pc, #184]	; (28590 <mem_manage_fault.isra.2+0x118>)
   284d6:	6aab      	ldr	r3, [r5, #40]	; 0x28
   284d8:	079b      	lsls	r3, r3, #30
   284da:	d51c      	bpl.n	28516 <mem_manage_fault.isra.2+0x9e>
		PR_FAULT_INFO("  Data Access Violation");
   284dc:	2301      	movs	r3, #1
   284de:	f04f 0000 	mov.w	r0, #0
   284e2:	f363 0007 	bfi	r0, r3, #0, #8
   284e6:	f364 108f 	bfi	r0, r4, #6, #10
   284ea:	492c      	ldr	r1, [pc, #176]	; (2859c <mem_manage_fault.isra.2+0x124>)
   284ec:	f014 f975 	bl	3c7da <log_string_sync>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		mmfar = SCB->MMFAR;
   284f0:	6b6a      	ldr	r2, [r5, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   284f2:	6aab      	ldr	r3, [r5, #40]	; 0x28
   284f4:	0618      	lsls	r0, r3, #24
   284f6:	d50e      	bpl.n	28516 <mem_manage_fault.isra.2+0x9e>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
   284f8:	f04f 0000 	mov.w	r0, #0
   284fc:	2301      	movs	r3, #1
   284fe:	f363 0007 	bfi	r0, r3, #0, #8
   28502:	f364 108f 	bfi	r0, r4, #6, #10
   28506:	4926      	ldr	r1, [pc, #152]	; (285a0 <mem_manage_fault.isra.2+0x128>)
   28508:	f014 f967 	bl	3c7da <log_string_sync>
			if (from_hard_fault) {
   2850c:	b11f      	cbz	r7, 28516 <mem_manage_fault.isra.2+0x9e>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   2850e:	6aab      	ldr	r3, [r5, #40]	; 0x28
   28510:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   28514:	62ab      	str	r3, [r5, #40]	; 0x28
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   28516:	4b1e      	ldr	r3, [pc, #120]	; (28590 <mem_manage_fault.isra.2+0x118>)
   28518:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   2851a:	07d9      	lsls	r1, r3, #31
   2851c:	d509      	bpl.n	28532 <mem_manage_fault.isra.2+0xba>
		PR_FAULT_INFO("  Instruction Access Violation");
   2851e:	f04f 0000 	mov.w	r0, #0
   28522:	2301      	movs	r3, #1
   28524:	f363 0007 	bfi	r0, r3, #0, #8
   28528:	f364 108f 	bfi	r0, r4, #6, #10
   2852c:	491d      	ldr	r1, [pc, #116]	; (285a4 <mem_manage_fault.isra.2+0x12c>)
   2852e:	f014 f954 	bl	3c7da <log_string_sync>
	}
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   28532:	4b17      	ldr	r3, [pc, #92]	; (28590 <mem_manage_fault.isra.2+0x118>)
   28534:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   28536:	069a      	lsls	r2, r3, #26
   28538:	d509      	bpl.n	2854e <mem_manage_fault.isra.2+0xd6>
		PR_FAULT_INFO(
   2853a:	f04f 0000 	mov.w	r0, #0
   2853e:	2301      	movs	r3, #1
   28540:	f363 0007 	bfi	r0, r3, #0, #8
   28544:	f364 108f 	bfi	r0, r4, #6, #10
   28548:	4917      	ldr	r1, [pc, #92]	; (285a8 <mem_manage_fault.isra.2+0x130>)
   2854a:	f014 f946 	bl	3c7da <log_string_sync>
	 * if the memory violation error is a stack corruption.
	 *
	 * By design, being a Stacking MemManage fault is a necessary
	 * and sufficient condition for a thread stack corruption.
	 */
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
   2854e:	4b10      	ldr	r3, [pc, #64]	; (28590 <mem_manage_fault.isra.2+0x118>)
   28550:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   28552:	06db      	lsls	r3, r3, #27
   28554:	d50e      	bpl.n	28574 <mem_manage_fault.isra.2+0xfc>
					"Stacking error not a stack fail\n");
			}
		}
#else
	(void)mmfar;
	__ASSERT(0,
   28556:	4915      	ldr	r1, [pc, #84]	; (285ac <mem_manage_fault.isra.2+0x134>)
   28558:	f44f 739b 	mov.w	r3, #310	; 0x136
   2855c:	4a14      	ldr	r2, [pc, #80]	; (285b0 <mem_manage_fault.isra.2+0x138>)
   2855e:	4815      	ldr	r0, [pc, #84]	; (285b4 <mem_manage_fault.isra.2+0x13c>)
   28560:	f014 f8e4 	bl	3c72c <printk>
   28564:	4814      	ldr	r0, [pc, #80]	; (285b8 <mem_manage_fault.isra.2+0x140>)
   28566:	f014 f8e1 	bl	3c72c <printk>
   2856a:	f44f 719b 	mov.w	r1, #310	; 0x136
   2856e:	4810      	ldr	r0, [pc, #64]	; (285b0 <mem_manage_fault.isra.2+0x138>)
   28570:	f014 f922 	bl	3c7b8 <assert_post_action>

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf);
   28574:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   28576:	4a06      	ldr	r2, [pc, #24]	; (28590 <mem_manage_fault.isra.2+0x118>)
   28578:	6a93      	ldr	r3, [r2, #40]	; 0x28
   2857a:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
   2857e:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
   28580:	7030      	strb	r0, [r6, #0]

	return reason;
}
   28582:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   28584:	0003f9ac 	.word	0x0003f9ac
   28588:	0003f8d4 	.word	0x0003f8d4
   2858c:	0004210a 	.word	0x0004210a
   28590:	e000ed00 	.word	0xe000ed00
   28594:	00042120 	.word	0x00042120
   28598:	00042153 	.word	0x00042153
   2859c:	00042166 	.word	0x00042166
   285a0:	0004217e 	.word	0x0004217e
   285a4:	00042194 	.word	0x00042194
   285a8:	000421b3 	.word	0x000421b3
   285ac:	00043e6b 	.word	0x00043e6b
   285b0:	000421e2 	.word	0x000421e2
   285b4:	00040606 	.word	0x00040606
   285b8:	0004221c 	.word	0x0004221c

000285bc <bus_fault.isra.3>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return N/A
 */
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   285bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");
   285be:	2301      	movs	r3, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   285c0:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** BUS FAULT *****");
   285c2:	f04f 0000 	mov.w	r0, #0
   285c6:	4c3d      	ldr	r4, [pc, #244]	; (286bc <bus_fault.isra.3+0x100>)
   285c8:	f363 0007 	bfi	r0, r3, #0, #8
   285cc:	4b3c      	ldr	r3, [pc, #240]	; (286c0 <bus_fault.isra.3+0x104>)
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   285ce:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
   285d0:	1ae4      	subs	r4, r4, r3
   285d2:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   285d6:	493b      	ldr	r1, [pc, #236]	; (286c4 <bus_fault.isra.3+0x108>)
   285d8:	f364 108f 	bfi	r0, r4, #6, #10
   285dc:	f014 f8fd 	bl	3c7da <log_string_sync>

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   285e0:	4b39      	ldr	r3, [pc, #228]	; (286c8 <bus_fault.isra.3+0x10c>)
   285e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   285e4:	04d9      	lsls	r1, r3, #19
   285e6:	d509      	bpl.n	285fc <bus_fault.isra.3+0x40>
		PR_FAULT_INFO("  Stacking error");
   285e8:	f04f 0000 	mov.w	r0, #0
   285ec:	2301      	movs	r3, #1
   285ee:	f363 0007 	bfi	r0, r3, #0, #8
   285f2:	f364 108f 	bfi	r0, r4, #6, #10
   285f6:	4935      	ldr	r1, [pc, #212]	; (286cc <bus_fault.isra.3+0x110>)
   285f8:	f014 f8ef 	bl	3c7da <log_string_sync>
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   285fc:	4b32      	ldr	r3, [pc, #200]	; (286c8 <bus_fault.isra.3+0x10c>)
   285fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   28600:	051a      	lsls	r2, r3, #20
   28602:	d509      	bpl.n	28618 <bus_fault.isra.3+0x5c>
		PR_FAULT_INFO("  Unstacking error");
   28604:	f04f 0000 	mov.w	r0, #0
   28608:	2301      	movs	r3, #1
   2860a:	f363 0007 	bfi	r0, r3, #0, #8
   2860e:	f364 108f 	bfi	r0, r4, #6, #10
   28612:	492f      	ldr	r1, [pc, #188]	; (286d0 <bus_fault.isra.3+0x114>)
   28614:	f014 f8e1 	bl	3c7da <log_string_sync>
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   28618:	4d2b      	ldr	r5, [pc, #172]	; (286c8 <bus_fault.isra.3+0x10c>)
   2861a:	6aab      	ldr	r3, [r5, #40]	; 0x28
   2861c:	059b      	lsls	r3, r3, #22
   2861e:	d51c      	bpl.n	2865a <bus_fault.isra.3+0x9e>
		PR_FAULT_INFO("  Precise data bus error");
   28620:	2301      	movs	r3, #1
   28622:	f04f 0000 	mov.w	r0, #0
   28626:	f363 0007 	bfi	r0, r3, #0, #8
   2862a:	f364 108f 	bfi	r0, r4, #6, #10
   2862e:	4929      	ldr	r1, [pc, #164]	; (286d4 <bus_fault.isra.3+0x118>)
   28630:	f014 f8d3 	bl	3c7da <log_string_sync>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
   28634:	6baa      	ldr	r2, [r5, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   28636:	6aab      	ldr	r3, [r5, #40]	; 0x28
   28638:	0418      	lsls	r0, r3, #16
   2863a:	d50e      	bpl.n	2865a <bus_fault.isra.3+0x9e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
   2863c:	f04f 0000 	mov.w	r0, #0
   28640:	2301      	movs	r3, #1
   28642:	f363 0007 	bfi	r0, r3, #0, #8
   28646:	f364 108f 	bfi	r0, r4, #6, #10
   2864a:	4923      	ldr	r1, [pc, #140]	; (286d8 <bus_fault.isra.3+0x11c>)
   2864c:	f014 f8c5 	bl	3c7da <log_string_sync>
			if (from_hard_fault) {
   28650:	b11f      	cbz	r7, 2865a <bus_fault.isra.3+0x9e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   28652:	6aab      	ldr	r3, [r5, #40]	; 0x28
   28654:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   28658:	62ab      	str	r3, [r5, #40]	; 0x28
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   2865a:	4b1b      	ldr	r3, [pc, #108]	; (286c8 <bus_fault.isra.3+0x10c>)
   2865c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   2865e:	0559      	lsls	r1, r3, #21
   28660:	d509      	bpl.n	28676 <bus_fault.isra.3+0xba>
		PR_FAULT_INFO("  Imprecise data bus error");
   28662:	f04f 0000 	mov.w	r0, #0
   28666:	2301      	movs	r3, #1
   28668:	f363 0007 	bfi	r0, r3, #0, #8
   2866c:	f364 108f 	bfi	r0, r4, #6, #10
   28670:	491a      	ldr	r1, [pc, #104]	; (286dc <bus_fault.isra.3+0x120>)
   28672:	f014 f8b2 	bl	3c7da <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   28676:	4b14      	ldr	r3, [pc, #80]	; (286c8 <bus_fault.isra.3+0x10c>)
   28678:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2867a:	05d2      	lsls	r2, r2, #23
   2867c:	d511      	bpl.n	286a2 <bus_fault.isra.3+0xe6>
		PR_FAULT_INFO("  Instruction bus error");
   2867e:	f04f 0000 	mov.w	r0, #0
   28682:	2301      	movs	r3, #1
   28684:	4916      	ldr	r1, [pc, #88]	; (286e0 <bus_fault.isra.3+0x124>)
   28686:	f363 0007 	bfi	r0, r3, #0, #8
   2868a:	f364 108f 	bfi	r0, r4, #6, #10
#if !defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	}
#else
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   2868e:	f014 f8a4 	bl	3c7da <log_string_sync>
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;

	*recoverable = memory_fault_recoverable(esf);
   28692:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   28694:	4a0c      	ldr	r2, [pc, #48]	; (286c8 <bus_fault.isra.3+0x10c>)
   28696:	6a93      	ldr	r3, [r2, #40]	; 0x28
   28698:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
   2869c:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
   2869e:	7030      	strb	r0, [r6, #0]

	return reason;
}
   286a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   286a2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   286a4:	049b      	lsls	r3, r3, #18
   286a6:	d5f4      	bpl.n	28692 <bus_fault.isra.3+0xd6>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   286a8:	f04f 0000 	mov.w	r0, #0
   286ac:	2301      	movs	r3, #1
   286ae:	f363 0007 	bfi	r0, r3, #0, #8
   286b2:	f364 108f 	bfi	r0, r4, #6, #10
   286b6:	490b      	ldr	r1, [pc, #44]	; (286e4 <bus_fault.isra.3+0x128>)
   286b8:	e7e9      	b.n	2868e <bus_fault.isra.3+0xd2>
   286ba:	bf00      	nop
   286bc:	0003f9ac 	.word	0x0003f9ac
   286c0:	0003f8d4 	.word	0x0003f8d4
   286c4:	00042082 	.word	0x00042082
   286c8:	e000ed00 	.word	0xe000ed00
   286cc:	00042098 	.word	0x00042098
   286d0:	00042153 	.word	0x00042153
   286d4:	000420a9 	.word	0x000420a9
   286d8:	000420c2 	.word	0x000420c2
   286dc:	000420d7 	.word	0x000420d7
   286e0:	000420f2 	.word	0x000420f2
   286e4:	000421b3 	.word	0x000421b3

000286e8 <usage_fault.isra.4>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t usage_fault(const z_arch_esf_t *esf)
   286e8:	b538      	push	{r3, r4, r5, lr}
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
   286ea:	f04f 0000 	mov.w	r0, #0
   286ee:	2301      	movs	r3, #1
   286f0:	4c3c      	ldr	r4, [pc, #240]	; (287e4 <usage_fault.isra.4+0xfc>)
   286f2:	f363 0007 	bfi	r0, r3, #0, #8
   286f6:	4b3c      	ldr	r3, [pc, #240]	; (287e8 <usage_fault.isra.4+0x100>)
   286f8:	493c      	ldr	r1, [pc, #240]	; (287ec <usage_fault.isra.4+0x104>)
   286fa:	1ae4      	subs	r4, r4, r3
   286fc:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   28700:	f364 108f 	bfi	r0, r4, #6, #10
   28704:	f014 f869 	bl	3c7da <log_string_sync>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   28708:	4b39      	ldr	r3, [pc, #228]	; (287f0 <usage_fault.isra.4+0x108>)
   2870a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   2870c:	019b      	lsls	r3, r3, #6
   2870e:	d509      	bpl.n	28724 <usage_fault.isra.4+0x3c>
		PR_FAULT_INFO("  Division by zero");
   28710:	f04f 0000 	mov.w	r0, #0
   28714:	2301      	movs	r3, #1
   28716:	f363 0007 	bfi	r0, r3, #0, #8
   2871a:	f364 108f 	bfi	r0, r4, #6, #10
   2871e:	4935      	ldr	r1, [pc, #212]	; (287f4 <usage_fault.isra.4+0x10c>)
   28720:	f014 f85b 	bl	3c7da <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   28724:	4b32      	ldr	r3, [pc, #200]	; (287f0 <usage_fault.isra.4+0x108>)
   28726:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   28728:	01dd      	lsls	r5, r3, #7
   2872a:	d509      	bpl.n	28740 <usage_fault.isra.4+0x58>
		PR_FAULT_INFO("  Unaligned memory access");
   2872c:	f04f 0000 	mov.w	r0, #0
   28730:	2301      	movs	r3, #1
   28732:	f363 0007 	bfi	r0, r3, #0, #8
   28736:	f364 108f 	bfi	r0, r4, #6, #10
   2873a:	492f      	ldr	r1, [pc, #188]	; (287f8 <usage_fault.isra.4+0x110>)
   2873c:	f014 f84d 	bl	3c7da <log_string_sync>
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
   28740:	4b2b      	ldr	r3, [pc, #172]	; (287f0 <usage_fault.isra.4+0x108>)
   28742:	6a9d      	ldr	r5, [r3, #40]	; 0x28
   28744:	f415 1580 	ands.w	r5, r5, #1048576	; 0x100000
   28748:	d00a      	beq.n	28760 <usage_fault.isra.4+0x78>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
   2874a:	2301      	movs	r3, #1
   2874c:	f04f 0000 	mov.w	r0, #0
   28750:	f363 0007 	bfi	r0, r3, #0, #8
   28754:	f364 108f 	bfi	r0, r4, #6, #10
   28758:	4928      	ldr	r1, [pc, #160]	; (287fc <usage_fault.isra.4+0x114>)
   2875a:	f014 f83e 	bl	3c7da <log_string_sync>
		 * prevents the context area to be loaded on the stack upon
		 * UsageFault exception entry. As a result, we cannot rely
		 * on the reported faulty instruction address, to determine
		 * the instruction that triggered the stack overflow.
		 */
		reason = K_ERR_STACK_CHK_FAIL;
   2875e:	2502      	movs	r5, #2
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   28760:	4b23      	ldr	r3, [pc, #140]	; (287f0 <usage_fault.isra.4+0x108>)
   28762:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   28764:	0318      	lsls	r0, r3, #12
   28766:	d509      	bpl.n	2877c <usage_fault.isra.4+0x94>
		PR_FAULT_INFO("  No coprocessor instructions");
   28768:	f04f 0000 	mov.w	r0, #0
   2876c:	2301      	movs	r3, #1
   2876e:	f363 0007 	bfi	r0, r3, #0, #8
   28772:	f364 108f 	bfi	r0, r4, #6, #10
   28776:	4922      	ldr	r1, [pc, #136]	; (28800 <usage_fault.isra.4+0x118>)
   28778:	f014 f82f 	bl	3c7da <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   2877c:	4b1c      	ldr	r3, [pc, #112]	; (287f0 <usage_fault.isra.4+0x108>)
   2877e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   28780:	0359      	lsls	r1, r3, #13
   28782:	d509      	bpl.n	28798 <usage_fault.isra.4+0xb0>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
   28784:	f04f 0000 	mov.w	r0, #0
   28788:	2301      	movs	r3, #1
   2878a:	f363 0007 	bfi	r0, r3, #0, #8
   2878e:	f364 108f 	bfi	r0, r4, #6, #10
   28792:	491c      	ldr	r1, [pc, #112]	; (28804 <usage_fault.isra.4+0x11c>)
   28794:	f014 f821 	bl	3c7da <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   28798:	4b15      	ldr	r3, [pc, #84]	; (287f0 <usage_fault.isra.4+0x108>)
   2879a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   2879c:	039a      	lsls	r2, r3, #14
   2879e:	d509      	bpl.n	287b4 <usage_fault.isra.4+0xcc>
		PR_FAULT_INFO("  Illegal use of the EPSR");
   287a0:	f04f 0000 	mov.w	r0, #0
   287a4:	2301      	movs	r3, #1
   287a6:	f363 0007 	bfi	r0, r3, #0, #8
   287aa:	f364 108f 	bfi	r0, r4, #6, #10
   287ae:	4916      	ldr	r1, [pc, #88]	; (28808 <usage_fault.isra.4+0x120>)
   287b0:	f014 f813 	bl	3c7da <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   287b4:	4b0e      	ldr	r3, [pc, #56]	; (287f0 <usage_fault.isra.4+0x108>)
   287b6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   287b8:	03db      	lsls	r3, r3, #15
   287ba:	d509      	bpl.n	287d0 <usage_fault.isra.4+0xe8>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
   287bc:	f04f 0000 	mov.w	r0, #0
   287c0:	2301      	movs	r3, #1
   287c2:	f363 0007 	bfi	r0, r3, #0, #8
   287c6:	f364 108f 	bfi	r0, r4, #6, #10
   287ca:	4910      	ldr	r1, [pc, #64]	; (2880c <usage_fault.isra.4+0x124>)
   287cc:	f014 f805 	bl	3c7da <log_string_sync>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   287d0:	4a07      	ldr	r2, [pc, #28]	; (287f0 <usage_fault.isra.4+0x108>)

	return reason;
}
   287d2:	4628      	mov	r0, r5
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   287d4:	6a93      	ldr	r3, [r2, #40]	; 0x28
   287d6:	ea6f 4303 	mvn.w	r3, r3, lsl #16
   287da:	ea6f 4313 	mvn.w	r3, r3, lsr #16
   287de:	6293      	str	r3, [r2, #40]	; 0x28
}
   287e0:	bd38      	pop	{r3, r4, r5, pc}
   287e2:	bf00      	nop
   287e4:	0003f9ac 	.word	0x0003f9ac
   287e8:	0003f8d4 	.word	0x0003f8d4
   287ec:	00042256 	.word	0x00042256
   287f0:	e000ed00 	.word	0xe000ed00
   287f4:	0004226e 	.word	0x0004226e
   287f8:	00042281 	.word	0x00042281
   287fc:	0004229b 	.word	0x0004229b
   28800:	000422c5 	.word	0x000422c5
   28804:	000422e3 	.word	0x000422e3
   28808:	00042308 	.word	0x00042308
   2880c:	00042322 	.word	0x00042322

00028810 <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
   28810:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   28814:	4b70      	ldr	r3, [pc, #448]	; (289d8 <z_arm_fault+0x1c8>)
{
   28816:	b09d      	sub	sp, #116	; 0x74
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   28818:	f8d3 8004 	ldr.w	r8, [r3, #4]
{
   2881c:	4606      	mov	r6, r0
   2881e:	4689      	mov	r9, r1
   28820:	4614      	mov	r4, r2
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   28822:	f3c8 0708 	ubfx	r7, r8, #0, #9
   28826:	2500      	movs	r5, #0
   28828:	f385 8811 	msr	BASEPRI, r5
   2882c:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   28830:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
   28834:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   28838:	d11b      	bne.n	28872 <z_arm_fault+0x62>
	if (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {
   2883a:	07d0      	lsls	r0, r2, #31
   2883c:	d419      	bmi.n	28872 <z_arm_fault+0x62>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
   2883e:	0651      	lsls	r1, r2, #25
   28840:	d403      	bmi.n	2884a <z_arm_fault+0x3a>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   28842:	0722      	lsls	r2, r4, #28
   28844:	d412      	bmi.n	2886c <z_arm_fault+0x5c>
			*nested_exc = true;
   28846:	2501      	movs	r5, #1
   28848:	e012      	b.n	28870 <z_arm_fault+0x60>
		PR_FAULT_INFO("Exception occurred in Secure State");
   2884a:	2301      	movs	r3, #1
   2884c:	f04f 0000 	mov.w	r0, #0
   28850:	4a62      	ldr	r2, [pc, #392]	; (289dc <z_arm_fault+0x1cc>)
   28852:	f363 0007 	bfi	r0, r3, #0, #8
   28856:	4b62      	ldr	r3, [pc, #392]	; (289e0 <z_arm_fault+0x1d0>)
   28858:	4962      	ldr	r1, [pc, #392]	; (289e4 <z_arm_fault+0x1d4>)
   2885a:	1a9b      	subs	r3, r3, r2
   2885c:	08db      	lsrs	r3, r3, #3
   2885e:	f363 108f 	bfi	r0, r3, #6, #10
   28862:	f013 ffba 	bl	3c7da <log_string_sync>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
   28866:	f014 0504 	ands.w	r5, r4, #4
   2886a:	d001      	beq.n	28870 <z_arm_fault+0x60>
			ptr_esf = (z_arch_esf_t *)psp;
   2886c:	464e      	mov	r6, r9
	*nested_exc = false;
   2886e:	2500      	movs	r5, #0

	/* Retrieve the Exception Stack Frame (ESF) to be supplied
	 * as argument to the remainder of the fault handling process.
	 */
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
   28870:	b97e      	cbnz	r6, 28892 <z_arm_fault+0x82>
   28872:	f240 33b1 	movw	r3, #945	; 0x3b1
   28876:	4a5c      	ldr	r2, [pc, #368]	; (289e8 <z_arm_fault+0x1d8>)
   28878:	495c      	ldr	r1, [pc, #368]	; (289ec <z_arm_fault+0x1dc>)
   2887a:	485d      	ldr	r0, [pc, #372]	; (289f0 <z_arm_fault+0x1e0>)
   2887c:	f013 ff56 	bl	3c72c <printk>
   28880:	485c      	ldr	r0, [pc, #368]	; (289f4 <z_arm_fault+0x1e4>)
   28882:	f013 ff53 	bl	3c72c <printk>
   28886:	f240 31b1 	movw	r1, #945	; 0x3b1
   2888a:	4857      	ldr	r0, [pc, #348]	; (289e8 <z_arm_fault+0x1d8>)
   2888c:	f013 ff94 	bl	3c7b8 <assert_post_action>
   28890:	2600      	movs	r6, #0
	*recoverable = false;
   28892:	2300      	movs	r3, #0
   28894:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
   28898:	1efb      	subs	r3, r7, #3
   2889a:	2b09      	cmp	r3, #9
   2889c:	d87f      	bhi.n	2899e <z_arm_fault+0x18e>
   2889e:	e8df f003 	tbb	[pc, r3]
   288a2:	6905      	.short	0x6905
   288a4:	7e7e4c6d 	.word	0x7e7e4c6d
   288a8:	717e7e7e 	.word	0x717e7e7e
	PR_FAULT_INFO("***** HARD FAULT *****");
   288ac:	2301      	movs	r3, #1
   288ae:	f04f 0000 	mov.w	r0, #0
	*recoverable = false;
   288b2:	f04f 0800 	mov.w	r8, #0
	PR_FAULT_INFO("***** HARD FAULT *****");
   288b6:	f363 0007 	bfi	r0, r3, #0, #8
   288ba:	4f49      	ldr	r7, [pc, #292]	; (289e0 <z_arm_fault+0x1d0>)
   288bc:	4b47      	ldr	r3, [pc, #284]	; (289dc <z_arm_fault+0x1cc>)
   288be:	494e      	ldr	r1, [pc, #312]	; (289f8 <z_arm_fault+0x1e8>)
   288c0:	1aff      	subs	r7, r7, r3
   288c2:	f3c7 07c9 	ubfx	r7, r7, #3, #10
   288c6:	f367 108f 	bfi	r0, r7, #6, #10
   288ca:	f013 ff86 	bl	3c7da <log_string_sync>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   288ce:	4b42      	ldr	r3, [pc, #264]	; (289d8 <z_arm_fault+0x1c8>)
	*recoverable = false;
   288d0:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   288d4:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   288d6:	f014 0402 	ands.w	r4, r4, #2
   288da:	d00b      	beq.n	288f4 <z_arm_fault+0xe4>
		PR_EXC("  Bus fault on vector table read");
   288dc:	f04f 0000 	mov.w	r0, #0
   288e0:	2301      	movs	r3, #1
   288e2:	4946      	ldr	r1, [pc, #280]	; (289fc <z_arm_fault+0x1ec>)
   288e4:	f363 0007 	bfi	r0, r3, #0, #8
   288e8:	f367 108f 	bfi	r0, r7, #6, #10
	PR_FAULT_INFO(
   288ec:	f013 ff75 	bl	3c7da <log_string_sync>
	u32_t reason = K_ERR_CPU_EXCEPTION;
   288f0:	2400      	movs	r4, #0
   288f2:	e025      	b.n	28940 <z_arm_fault+0x130>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   288f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   288f6:	005b      	lsls	r3, r3, #1
   288f8:	d522      	bpl.n	28940 <z_arm_fault+0x130>
		PR_EXC("  Fault escalation (see below)");
   288fa:	2301      	movs	r3, #1
   288fc:	f04f 0000 	mov.w	r0, #0
   28900:	f363 0007 	bfi	r0, r3, #0, #8
   28904:	f367 108f 	bfi	r0, r7, #6, #10
   28908:	493d      	ldr	r1, [pc, #244]	; (28a00 <z_arm_fault+0x1f0>)
   2890a:	f013 ff66 	bl	3c7da <log_string_sync>
		if (SCB_MMFSR != 0) {
   2890e:	4b3d      	ldr	r3, [pc, #244]	; (28a04 <z_arm_fault+0x1f4>)
   28910:	781b      	ldrb	r3, [r3, #0]
   28912:	b12b      	cbz	r3, 28920 <z_arm_fault+0x110>
			reason = mem_manage_fault(esf, 1, recoverable);
   28914:	2001      	movs	r0, #1
   28916:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
   2891a:	f7ff fdad 	bl	28478 <mem_manage_fault.isra.2>
   2891e:	e00e      	b.n	2893e <z_arm_fault+0x12e>
		} else if (SCB_BFSR != 0) {
   28920:	4b39      	ldr	r3, [pc, #228]	; (28a08 <z_arm_fault+0x1f8>)
   28922:	781b      	ldrb	r3, [r3, #0]
   28924:	b12b      	cbz	r3, 28932 <z_arm_fault+0x122>
			reason = bus_fault(esf, 1, recoverable);
   28926:	2001      	movs	r0, #1
   28928:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
   2892c:	f7ff fe46 	bl	285bc <bus_fault.isra.3>
   28930:	e005      	b.n	2893e <z_arm_fault+0x12e>
		} else if (SCB_UFSR != 0) {
   28932:	4b36      	ldr	r3, [pc, #216]	; (28a0c <z_arm_fault+0x1fc>)
   28934:	881b      	ldrh	r3, [r3, #0]
   28936:	b29b      	uxth	r3, r3
   28938:	b113      	cbz	r3, 28940 <z_arm_fault+0x130>
			reason = usage_fault(esf);
   2893a:	f7ff fed5 	bl	286e8 <usage_fault.isra.4>
   2893e:	4604      	mov	r4, r0
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
   28940:	f89d 3007 	ldrb.w	r3, [sp, #7]
   28944:	b99b      	cbnz	r3, 2896e <z_arm_fault+0x15e>
		return;
	}

	/* Copy ESF */
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   28946:	2268      	movs	r2, #104	; 0x68
   28948:	4631      	mov	r1, r6
   2894a:	a802      	add	r0, sp, #8
   2894c:	f015 ff7e 	bl	3e84c <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
   28950:	9b09      	ldr	r3, [sp, #36]	; 0x24
   28952:	2d00      	cmp	r5, #0
   28954:	d03a      	beq.n	289cc <z_arm_fault+0x1bc>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   28956:	f3c3 0208 	ubfx	r2, r3, #0, #9
   2895a:	b922      	cbnz	r2, 28966 <z_arm_fault+0x156>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   2895c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   28960:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   28964:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
   28966:	a902      	add	r1, sp, #8
   28968:	4620      	mov	r0, r4
   2896a:	f7ff fcb1 	bl	282d0 <z_arm_fatal_error>
}
   2896e:	b01d      	add	sp, #116	; 0x74
   28970:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
   28974:	f10d 0107 	add.w	r1, sp, #7
   28978:	2000      	movs	r0, #0
   2897a:	e7ce      	b.n	2891a <z_arm_fault+0x10a>
		reason = bus_fault(esf, 0, recoverable);
   2897c:	f10d 0107 	add.w	r1, sp, #7
   28980:	2000      	movs	r0, #0
   28982:	e7d3      	b.n	2892c <z_arm_fault+0x11c>
	PR_FAULT_INFO(
   28984:	2301      	movs	r3, #1
   28986:	f04f 0000 	mov.w	r0, #0
   2898a:	4a14      	ldr	r2, [pc, #80]	; (289dc <z_arm_fault+0x1cc>)
   2898c:	f363 0007 	bfi	r0, r3, #0, #8
   28990:	4b13      	ldr	r3, [pc, #76]	; (289e0 <z_arm_fault+0x1d0>)
   28992:	491f      	ldr	r1, [pc, #124]	; (28a10 <z_arm_fault+0x200>)
   28994:	1a9b      	subs	r3, r3, r2
   28996:	08db      	lsrs	r3, r3, #3
   28998:	f363 108f 	bfi	r0, r3, #6, #10
   2899c:	e7a6      	b.n	288ec <z_arm_fault+0xdc>
	PR_FAULT_INFO("***** %s %d) *****",
   2899e:	2301      	movs	r3, #1
   289a0:	f04f 0000 	mov.w	r0, #0
   289a4:	4a0d      	ldr	r2, [pc, #52]	; (289dc <z_arm_fault+0x1cc>)
   289a6:	f363 0007 	bfi	r0, r3, #0, #8
   289aa:	4b0d      	ldr	r3, [pc, #52]	; (289e0 <z_arm_fault+0x1d0>)
   289ac:	4919      	ldr	r1, [pc, #100]	; (28a14 <z_arm_fault+0x204>)
   289ae:	1a9b      	subs	r3, r3, r2
   289b0:	08db      	lsrs	r3, r3, #3
   289b2:	f418 7ff8 	tst.w	r8, #496	; 0x1f0
   289b6:	f363 108f 	bfi	r0, r3, #6, #10
   289ba:	4a17      	ldr	r2, [pc, #92]	; (28a18 <z_arm_fault+0x208>)
   289bc:	f1a7 0310 	sub.w	r3, r7, #16
   289c0:	bf08      	it	eq
   289c2:	460a      	moveq	r2, r1
   289c4:	4915      	ldr	r1, [pc, #84]	; (28a1c <z_arm_fault+0x20c>)
   289c6:	f013 ff08 	bl	3c7da <log_string_sync>
   289ca:	e791      	b.n	288f0 <z_arm_fault+0xe0>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   289cc:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   289d0:	f023 0301 	bic.w	r3, r3, #1
   289d4:	e7c6      	b.n	28964 <z_arm_fault+0x154>
   289d6:	bf00      	nop
   289d8:	e000ed00 	.word	0xe000ed00
   289dc:	0003f8d4 	.word	0x0003f8d4
   289e0:	0003f9ac 	.word	0x0003f9ac
   289e4:	0004237b 	.word	0x0004237b
   289e8:	000421e2 	.word	0x000421e2
   289ec:	0004239e 	.word	0x0004239e
   289f0:	00040606 	.word	0x00040606
   289f4:	000423b1 	.word	0x000423b1
   289f8:	000423ef 	.word	0x000423ef
   289fc:	00042406 	.word	0x00042406
   28a00:	00042427 	.word	0x00042427
   28a04:	e000ed28 	.word	0xe000ed28
   28a08:	e000ed29 	.word	0xe000ed29
   28a0c:	e000ed2a 	.word	0xe000ed2a
   28a10:	00042446 	.word	0x00042446
   28a14:	0004234d 	.word	0x0004234d
   28a18:	00042362 	.word	0x00042362
   28a1c:	0004247c 	.word	0x0004247c

00028a20 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   28a20:	4b04      	ldr	r3, [pc, #16]	; (28a34 <z_arm_fault_init+0x14>)
   28a22:	695a      	ldr	r2, [r3, #20]
   28a24:	f042 0210 	orr.w	r2, r2, #16
   28a28:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
   28a2a:	695a      	ldr	r2, [r3, #20]
   28a2c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   28a30:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
   28a32:	4770      	bx	lr
   28a34:	e000ed00 	.word	0xe000ed00

00028a38 <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
   28a38:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   28a3c:	4905      	ldr	r1, [pc, #20]	; (28a54 <sys_arch_reboot+0x1c>)
   28a3e:	4b06      	ldr	r3, [pc, #24]	; (28a58 <sys_arch_reboot+0x20>)
   28a40:	68ca      	ldr	r2, [r1, #12]
   28a42:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   28a46:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   28a48:	60cb      	str	r3, [r1, #12]
   28a4a:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   28a4e:	bf00      	nop
   28a50:	e7fd      	b.n	28a4e <sys_arch_reboot+0x16>
   28a52:	bf00      	nop
   28a54:	e000ed00 	.word	0xe000ed00
   28a58:	05fa0004 	.word	0x05fa0004

00028a5c <z_arm_int_lib_init>:
 * @return N/A
 */

void z_arm_int_lib_init(void)
{
	int irq = 0;
   28a5c:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   28a5e:	2120      	movs	r1, #32
   28a60:	4803      	ldr	r0, [pc, #12]	; (28a70 <z_arm_int_lib_init+0x14>)
   28a62:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   28a64:	3301      	adds	r3, #1
   28a66:	2b41      	cmp	r3, #65	; 0x41
   28a68:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   28a6c:	d1f9      	bne.n	28a62 <z_arm_int_lib_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   28a6e:	4770      	bx	lr
   28a70:	e000e100 	.word	0xe000e100

00028a74 <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
   28a74:	b538      	push	{r3, r4, r5, lr}
   28a76:	4604      	mov	r4, r0
	__asm__ volatile(
   28a78:	f04f 0320 	mov.w	r3, #32
   28a7c:	f3ef 8511 	mrs	r5, BASEPRI
   28a80:	f383 8811 	msr	BASEPRI, r3
   28a84:	f3bf 8f6f 	isb	sy
	unsigned int key;

	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
   28a88:	7b03      	ldrb	r3, [r0, #12]
   28a8a:	07db      	lsls	r3, r3, #31
   28a8c:	d50c      	bpl.n	28aa8 <z_impl_k_thread_abort+0x34>
   28a8e:	4912      	ldr	r1, [pc, #72]	; (28ad8 <z_impl_k_thread_abort+0x64>)
   28a90:	2324      	movs	r3, #36	; 0x24
   28a92:	4a12      	ldr	r2, [pc, #72]	; (28adc <z_impl_k_thread_abort+0x68>)
   28a94:	4812      	ldr	r0, [pc, #72]	; (28ae0 <z_impl_k_thread_abort+0x6c>)
   28a96:	f013 fe49 	bl	3c72c <printk>
   28a9a:	4812      	ldr	r0, [pc, #72]	; (28ae4 <z_impl_k_thread_abort+0x70>)
   28a9c:	f013 fe46 	bl	3c72c <printk>
   28aa0:	2124      	movs	r1, #36	; 0x24
   28aa2:	480e      	ldr	r0, [pc, #56]	; (28adc <z_impl_k_thread_abort+0x68>)
   28aa4:	f013 fe88 	bl	3c7b8 <assert_post_action>
		 "essential thread aborted");

	z_thread_single_abort(thread);
   28aa8:	4620      	mov	r0, r4
   28aaa:	f00e facd 	bl	37048 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
   28aae:	4b0e      	ldr	r3, [pc, #56]	; (28ae8 <z_impl_k_thread_abort+0x74>)
   28ab0:	689b      	ldr	r3, [r3, #8]
   28ab2:	42a3      	cmp	r3, r4
   28ab4:	d10b      	bne.n	28ace <z_impl_k_thread_abort+0x5a>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
   28ab6:	4b0d      	ldr	r3, [pc, #52]	; (28aec <z_impl_k_thread_abort+0x78>)
   28ab8:	685a      	ldr	r2, [r3, #4]
   28aba:	f3c2 0208 	ubfx	r2, r2, #0, #9
   28abe:	b912      	cbnz	r2, 28ac6 <z_impl_k_thread_abort+0x52>
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
   28ac0:	4628      	mov	r0, r5
   28ac2:	f7ff fb1d 	bl	28100 <arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   28ac6:	685a      	ldr	r2, [r3, #4]
   28ac8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   28acc:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
   28ace:	4628      	mov	r0, r5
}
   28ad0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
   28ad4:	f015 bd38 	b.w	3e548 <z_reschedule_irqlock>
   28ad8:	000424d0 	.word	0x000424d0
   28adc:	0004248f 	.word	0x0004248f
   28ae0:	00040606 	.word	0x00040606
   28ae4:	000424fe 	.word	0x000424fe
   28ae8:	2002976c 	.word	0x2002976c
   28aec:	e000ed00 	.word	0xe000ed00

00028af0 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
   28af0:	b510      	push	{r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
   28af2:	4b0e      	ldr	r3, [pc, #56]	; (28b2c <z_arm_configure_static_mpu_regions+0x3c>)
{
   28af4:	b088      	sub	sp, #32
		const struct k_mem_partition ramfunc_region =
   28af6:	9302      	str	r3, [sp, #8]
   28af8:	4b0d      	ldr	r3, [pc, #52]	; (28b30 <z_arm_configure_static_mpu_regions+0x40>)
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   28afa:	4c0e      	ldr	r4, [pc, #56]	; (28b34 <z_arm_configure_static_mpu_regions+0x44>)
		const struct k_mem_partition ramfunc_region =
   28afc:	9303      	str	r3, [sp, #12]
   28afe:	4b0e      	ldr	r3, [pc, #56]	; (28b38 <z_arm_configure_static_mpu_regions+0x48>)
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   28b00:	4a0e      	ldr	r2, [pc, #56]	; (28b3c <z_arm_configure_static_mpu_regions+0x4c>)
		const struct k_mem_partition ramfunc_region =
   28b02:	9304      	str	r3, [sp, #16]
	const struct k_mem_partition *static_regions[] = {
   28b04:	ab02      	add	r3, sp, #8
   28b06:	9301      	str	r3, [sp, #4]
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   28b08:	a801      	add	r0, sp, #4
   28b0a:	4623      	mov	r3, r4
   28b0c:	2101      	movs	r1, #1
   28b0e:	f000 f97d 	bl	28e0c <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of k_mem_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct k_mem_partition dyn_region_areas[] = {
   28b12:	2300      	movs	r3, #0
   28b14:	9307      	str	r3, [sp, #28]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
   28b16:	4b0a      	ldr	r3, [pc, #40]	; (28b40 <z_arm_configure_static_mpu_regions+0x50>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   28b18:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
   28b1a:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   28b1c:	a805      	add	r0, sp, #20
	const struct k_mem_partition dyn_region_areas[] = {
   28b1e:	9305      	str	r3, [sp, #20]
   28b20:	9406      	str	r4, [sp, #24]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   28b22:	f000 f997 	bl	28e54 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
   28b26:	b008      	add	sp, #32
   28b28:	bd10      	pop	{r4, pc}
   28b2a:	bf00      	nop
   28b2c:	20020000 	.word	0x20020000
   28b30:	00000000 	.word	0x00000000
   28b34:	20040000 	.word	0x20040000
   28b38:	00010006 	.word	0x00010006
   28b3c:	20020000 	.word	0x20020000
   28b40:	20020000 	.word	0x20020000

00028b44 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
   28b44:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
   28b46:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
   28b48:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
   28b4a:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
   28b4e:	f004 031f 	and.w	r3, r4, #31
   28b52:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   28b54:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   28b56:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   28b58:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
   28b5c:	4904      	ldr	r1, [pc, #16]	; (28b70 <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   28b5e:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
   28b62:	f043 0301 	orr.w	r3, r3, #1
   28b66:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
   28b68:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
   28b6a:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
   28b6c:	bd10      	pop	{r4, pc}
   28b6e:	bf00      	nop
   28b70:	e000ed90 	.word	0xe000ed90

00028b74 <region_allocate_and_init>:

static int region_allocate_and_init(const u8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1)) {
   28b74:	280f      	cmp	r0, #15
{
   28b76:	b510      	push	{r4, lr}
   28b78:	4604      	mov	r4, r0
	if (index > (get_num_regions() - 1)) {
   28b7a:	d912      	bls.n	28ba2 <region_allocate_and_init+0x2e>

		/* No available MPU region index. */
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
   28b7c:	2301      	movs	r3, #1
   28b7e:	f04f 0000 	mov.w	r0, #0
   28b82:	4a09      	ldr	r2, [pc, #36]	; (28ba8 <region_allocate_and_init+0x34>)
   28b84:	f363 0007 	bfi	r0, r3, #0, #8
   28b88:	4b08      	ldr	r3, [pc, #32]	; (28bac <region_allocate_and_init+0x38>)
   28b8a:	4909      	ldr	r1, [pc, #36]	; (28bb0 <region_allocate_and_init+0x3c>)
   28b8c:	1a9b      	subs	r3, r3, r2
   28b8e:	08db      	lsrs	r3, r3, #3
   28b90:	4622      	mov	r2, r4
   28b92:	f363 108f 	bfi	r0, r3, #6, #10
   28b96:	f013 fe20 	bl	3c7da <log_string_sync>
		return -EINVAL;
   28b9a:	f06f 0415 	mvn.w	r4, #21

	/* Program region */
	region_init(index, region_conf);

	return index;
}
   28b9e:	4620      	mov	r0, r4
   28ba0:	bd10      	pop	{r4, pc}
	region_init(index, region_conf);
   28ba2:	f7ff ffcf 	bl	28b44 <region_init>
	return index;
   28ba6:	e7fa      	b.n	28b9e <region_allocate_and_init+0x2a>
   28ba8:	0003f8d4 	.word	0x0003f8d4
   28bac:	0003f994 	.word	0x0003f994
   28bb0:	000426d1 	.word	0x000426d1

00028bb4 <mpu_configure_regions_and_partition.constprop.2>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct k_mem_partition
   28bb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   28bb8:	4607      	mov	r7, r0
   28bba:	4688      	mov	r8, r1
   28bbc:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
   28bbe:	2600      	movs	r6, #0
	MPU->RNR = index;
   28bc0:	4d58      	ldr	r5, [pc, #352]	; (28d24 <mpu_configure_regions_and_partition.constprop.2+0x170>)
static int mpu_configure_regions_and_partition(const struct k_mem_partition
   28bc2:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
   28bc4:	4546      	cmp	r6, r8
   28bc6:	da3d      	bge.n	28c44 <mpu_configure_regions_and_partition.constprop.2+0x90>
		if (regions[i]->size == 0U) {
   28bc8:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
   28bcc:	f8d3 9004 	ldr.w	r9, [r3, #4]
   28bd0:	f1b9 0f00 	cmp.w	r9, #0
   28bd4:	d059      	beq.n	28c8a <mpu_configure_regions_and_partition.constprop.2+0xd6>
		&&
   28bd6:	f1b9 0f1f 	cmp.w	r9, #31
   28bda:	d922      	bls.n	28c22 <mpu_configure_regions_and_partition.constprop.2+0x6e>
		&&
   28bdc:	f019 0f1f 	tst.w	r9, #31
   28be0:	d11f      	bne.n	28c22 <mpu_configure_regions_and_partition.constprop.2+0x6e>
		((part->start &
   28be2:	f8d3 a000 	ldr.w	sl, [r3]
		&&
   28be6:	f01a 0f1f 	tst.w	sl, #31
   28bea:	d11a      	bne.n	28c22 <mpu_configure_regions_and_partition.constprop.2+0x6e>
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
   28bec:	4650      	mov	r0, sl
   28bee:	f013 ff72 	bl	3cad6 <arm_cmse_mpu_region_get>
   28bf2:	4683      	mov	fp, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   28bf4:	eb09 000a 	add.w	r0, r9, sl
   28bf8:	3801      	subs	r0, #1
   28bfa:	f013 ff6c 	bl	3cad6 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   28bfe:	4583      	cmp	fp, r0
   28c00:	d024      	beq.n	28c4c <mpu_configure_regions_and_partition.constprop.2+0x98>
	return -EINVAL;
   28c02:	f06f 0b15 	mvn.w	fp, #21
		int u_reg_index =
			get_region_index(regions[i]->start, regions[i]->size);

		if ((u_reg_index == -EINVAL) ||
			(u_reg_index > (reg_index - 1))) {
			LOG_ERR("Invalid underlying region index %u",
   28c06:	2301      	movs	r3, #1
   28c08:	f04f 0000 	mov.w	r0, #0
   28c0c:	4a46      	ldr	r2, [pc, #280]	; (28d28 <mpu_configure_regions_and_partition.constprop.2+0x174>)
   28c0e:	f363 0007 	bfi	r0, r3, #0, #8
   28c12:	4b46      	ldr	r3, [pc, #280]	; (28d2c <mpu_configure_regions_and_partition.constprop.2+0x178>)
   28c14:	4946      	ldr	r1, [pc, #280]	; (28d30 <mpu_configure_regions_and_partition.constprop.2+0x17c>)
   28c16:	1a9b      	subs	r3, r3, r2
   28c18:	08db      	lsrs	r3, r3, #3
   28c1a:	f363 108f 	bfi	r0, r3, #6, #10
   28c1e:	465a      	mov	r2, fp
   28c20:	e00c      	b.n	28c3c <mpu_configure_regions_and_partition.constprop.2+0x88>
			LOG_ERR("Partition %u: sanity check failed.", i);
   28c22:	2301      	movs	r3, #1
   28c24:	f04f 0000 	mov.w	r0, #0
   28c28:	4a3f      	ldr	r2, [pc, #252]	; (28d28 <mpu_configure_regions_and_partition.constprop.2+0x174>)
   28c2a:	f363 0007 	bfi	r0, r3, #0, #8
   28c2e:	4b3f      	ldr	r3, [pc, #252]	; (28d2c <mpu_configure_regions_and_partition.constprop.2+0x178>)
   28c30:	4940      	ldr	r1, [pc, #256]	; (28d34 <mpu_configure_regions_and_partition.constprop.2+0x180>)
   28c32:	1a9b      	subs	r3, r3, r2
   28c34:	4632      	mov	r2, r6
   28c36:	08db      	lsrs	r3, r3, #3
   28c38:	f363 108f 	bfi	r0, r3, #6, #10
			LOG_ERR("Invalid underlying region index %u",
   28c3c:	f013 fdcd 	bl	3c7da <log_string_sync>

			reg_index =
				mpu_configure_region(reg_index, regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
   28c40:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
   28c44:	4620      	mov	r0, r4
   28c46:	b005      	add	sp, #20
   28c48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((u_reg_index == -EINVAL) ||
   28c4c:	f11b 0f16 	cmn.w	fp, #22
   28c50:	d0d9      	beq.n	28c06 <mpu_configure_regions_and_partition.constprop.2+0x52>
			(u_reg_index > (reg_index - 1))) {
   28c52:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
   28c54:	455b      	cmp	r3, fp
   28c56:	dbd6      	blt.n	28c06 <mpu_configure_regions_and_partition.constprop.2+0x52>
	MPU->RNR = index;
   28c58:	f8c5 b008 	str.w	fp, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   28c5c:	68e8      	ldr	r0, [r5, #12]
	MPU->RNR = index;
   28c5e:	f8c5 b008 	str.w	fp, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   28c62:	692b      	ldr	r3, [r5, #16]
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
   28c64:	f857 1026 	ldr.w	r1, [r7, r6, lsl #2]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   28c68:	f020 001f 	bic.w	r0, r0, #31
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   28c6c:	f043 0a1f 	orr.w	sl, r3, #31
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
   28c70:	e9d1 3200 	ldrd	r3, r2, [r1]
   28c74:	441a      	add	r2, r3
		if ((regions[i]->start == u_reg_base) &&
   28c76:	4298      	cmp	r0, r3
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
   28c78:	f102 39ff 	add.w	r9, r2, #4294967295
		if ((regions[i]->start == u_reg_base) &&
   28c7c:	d118      	bne.n	28cb0 <mpu_configure_regions_and_partition.constprop.2+0xfc>
   28c7e:	45ca      	cmp	sl, r9
   28c80:	d105      	bne.n	28c8e <mpu_configure_regions_and_partition.constprop.2+0xda>
			mpu_configure_region(u_reg_index, regions[i]);
   28c82:	fa5f f08b 	uxtb.w	r0, fp
   28c86:	f013 ff0b 	bl	3caa0 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
   28c8a:	3601      	adds	r6, #1
   28c8c:	e79a      	b.n	28bc4 <mpu_configure_regions_and_partition.constprop.2+0x10>
	MPU->RNR = index;
   28c8e:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   28c92:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
   28c94:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   28c98:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
   28c9c:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   28c9e:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, regions[i]);
   28ca0:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, regions[i]);
   28ca2:	f013 fefd 	bl	3caa0 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   28ca6:	f110 0f16 	cmn.w	r0, #22
   28caa:	d0c9      	beq.n	28c40 <mpu_configure_regions_and_partition.constprop.2+0x8c>
			reg_index++;
   28cac:	1c44      	adds	r4, r0, #1
   28cae:	e7ec      	b.n	28c8a <mpu_configure_regions_and_partition.constprop.2+0xd6>
	MPU->RNR = index;
   28cb0:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   28cb4:	692a      	ldr	r2, [r5, #16]
   28cb6:	3b01      	subs	r3, #1
   28cb8:	f023 031f 	bic.w	r3, r3, #31
   28cbc:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   28cc0:	4313      	orrs	r3, r2
		} else if (reg_last == u_reg_last) {
   28cc2:	45ca      	cmp	sl, r9
   28cc4:	b2e0      	uxtb	r0, r4
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   28cc6:	612b      	str	r3, [r5, #16]
		} else if (reg_last == u_reg_last) {
   28cc8:	d0eb      	beq.n	28ca2 <mpu_configure_regions_and_partition.constprop.2+0xee>
				mpu_configure_region(reg_index, regions[i]);
   28cca:	f013 fee9 	bl	3caa0 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   28cce:	f110 0f16 	cmn.w	r0, #22
   28cd2:	d0b5      	beq.n	28c40 <mpu_configure_regions_and_partition.constprop.2+0x8c>
	MPU->RNR = index;
   28cd4:	f8c5 b008 	str.w	fp, [r5, #8]
	attr->rbar = MPU->RBAR &
   28cd8:	68ea      	ldr	r2, [r5, #12]
   28cda:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i]->start +
   28cde:	f10a 3aff 	add.w	sl, sl, #4294967295
	attr->rbar = MPU->RBAR &
   28ce2:	f362 0304 	bfi	r3, r2, #0, #5
   28ce6:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   28cea:	692b      	ldr	r3, [r5, #16]
   28cec:	f89d 2008 	ldrb.w	r2, [sp, #8]
   28cf0:	085b      	lsrs	r3, r3, #1
   28cf2:	f363 1247 	bfi	r2, r3, #5, #3
			fill_region.base = regions[i]->start +
   28cf6:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   28cfa:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i]->start +
   28cfe:	e9d3 2300 	ldrd	r2, r3, [r3]
   28d02:	4413      	add	r3, r2
   28d04:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i]->start +
   28d06:	f023 031f 	bic.w	r3, r3, #31
   28d0a:	4453      	add	r3, sl
   28d0c:	eba3 0309 	sub.w	r3, r3, r9
			reg_index++;
   28d10:	3001      	adds	r0, #1
			REGION_LIMIT_ADDR((regions[i]->start +
   28d12:	f023 031f 	bic.w	r3, r3, #31
				region_allocate_and_init(reg_index,
   28d16:	4669      	mov	r1, sp
   28d18:	b2c0      	uxtb	r0, r0
			fill_region.attr.r_limit =
   28d1a:	9303      	str	r3, [sp, #12]
				region_allocate_and_init(reg_index,
   28d1c:	f7ff ff2a 	bl	28b74 <region_allocate_and_init>
   28d20:	e7c1      	b.n	28ca6 <mpu_configure_regions_and_partition.constprop.2+0xf2>
   28d22:	bf00      	nop
   28d24:	e000ed90 	.word	0xe000ed90
   28d28:	0003f8d4 	.word	0x0003f8d4
   28d2c:	0003f994 	.word	0x0003f994
   28d30:	000426ae 	.word	0x000426ae
   28d34:	0004268b 	.word	0x0004268b

00028d38 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   28d38:	2205      	movs	r2, #5
   28d3a:	4b03      	ldr	r3, [pc, #12]	; (28d48 <arm_core_mpu_enable+0x10>)
   28d3c:	605a      	str	r2, [r3, #4]
   28d3e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   28d42:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   28d46:	4770      	bx	lr
   28d48:	e000ed90 	.word	0xe000ed90

00028d4c <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
   28d4c:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   28d50:	2200      	movs	r2, #0
   28d52:	4b01      	ldr	r3, [pc, #4]	; (28d58 <arm_core_mpu_disable+0xc>)
   28d54:	605a      	str	r2, [r3, #4]
}
   28d56:	4770      	bx	lr
   28d58:	e000ed90 	.word	0xe000ed90

00028d5c <arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
static int arm_mpu_init(struct device *arg)
{
   28d5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   28d5e:	4f21      	ldr	r7, [pc, #132]	; (28de4 <arm_mpu_init+0x88>)
   28d60:	683e      	ldr	r6, [r7, #0]
   28d62:	2e10      	cmp	r6, #16
   28d64:	d913      	bls.n	28d8e <arm_mpu_init+0x32>
		 * what is supported by hardware. As this operation
		 * is executed during system (pre-kernel) initialization,
		 * we want to ensure we can detect an attempt to
		 * perform invalid configuration.
		 */
		__ASSERT(0,
   28d66:	f240 132d 	movw	r3, #301	; 0x12d
   28d6a:	4a1f      	ldr	r2, [pc, #124]	; (28de8 <arm_mpu_init+0x8c>)
   28d6c:	491f      	ldr	r1, [pc, #124]	; (28dec <arm_mpu_init+0x90>)
   28d6e:	4820      	ldr	r0, [pc, #128]	; (28df0 <arm_mpu_init+0x94>)
   28d70:	f013 fcdc 	bl	3c72c <printk>
   28d74:	2210      	movs	r2, #16
   28d76:	4631      	mov	r1, r6
   28d78:	481e      	ldr	r0, [pc, #120]	; (28df4 <arm_mpu_init+0x98>)
   28d7a:	f013 fcd7 	bl	3c72c <printk>
   28d7e:	481a      	ldr	r0, [pc, #104]	; (28de8 <arm_mpu_init+0x8c>)
   28d80:	f240 112d 	movw	r1, #301	; 0x12d
   28d84:	f013 fd18 	bl	3c7b8 <assert_post_action>
			"Request to configure: %u regions (supported: %u)\n",
			mpu_config.num_regions,
			get_num_regions()
		);
		return -1;
   28d88:	f04f 30ff 	mov.w	r0, #4294967295
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		DT_NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
}
   28d8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   28d8e:	2400      	movs	r4, #0
	arm_core_mpu_disable();
   28d90:	f7ff ffdc 	bl	28d4c <arm_core_mpu_disable>
	MPU->MAIR0 =
   28d94:	4d18      	ldr	r5, [pc, #96]	; (28df8 <arm_mpu_init+0x9c>)
   28d96:	4a19      	ldr	r2, [pc, #100]	; (28dfc <arm_mpu_init+0xa0>)
   28d98:	632a      	str	r2, [r5, #48]	; 0x30
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   28d9a:	42a6      	cmp	r6, r4
   28d9c:	d119      	bne.n	28dd2 <arm_mpu_init+0x76>
	static_regions_num = mpu_config.num_regions;
   28d9e:	4b18      	ldr	r3, [pc, #96]	; (28e00 <arm_mpu_init+0xa4>)
   28da0:	701e      	strb	r6, [r3, #0]
	arm_core_mpu_enable();
   28da2:	f7ff ffc9 	bl	28d38 <arm_core_mpu_enable>
	__ASSERT(
   28da6:	682b      	ldr	r3, [r5, #0]
   28da8:	f3c3 2307 	ubfx	r3, r3, #8, #8
   28dac:	2b10      	cmp	r3, #16
   28dae:	d00e      	beq.n	28dce <arm_mpu_init+0x72>
   28db0:	4914      	ldr	r1, [pc, #80]	; (28e04 <arm_mpu_init+0xa8>)
   28db2:	f44f 73a7 	mov.w	r3, #334	; 0x14e
   28db6:	4a0c      	ldr	r2, [pc, #48]	; (28de8 <arm_mpu_init+0x8c>)
   28db8:	480d      	ldr	r0, [pc, #52]	; (28df0 <arm_mpu_init+0x94>)
   28dba:	f013 fcb7 	bl	3c72c <printk>
   28dbe:	4812      	ldr	r0, [pc, #72]	; (28e08 <arm_mpu_init+0xac>)
   28dc0:	f013 fcb4 	bl	3c72c <printk>
   28dc4:	f44f 71a7 	mov.w	r1, #334	; 0x14e
   28dc8:	4807      	ldr	r0, [pc, #28]	; (28de8 <arm_mpu_init+0x8c>)
   28dca:	f013 fcf5 	bl	3c7b8 <assert_post_action>
	return 0;
   28dce:	2000      	movs	r0, #0
   28dd0:	e7dc      	b.n	28d8c <arm_mpu_init+0x30>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
   28dd2:	6879      	ldr	r1, [r7, #4]
   28dd4:	4620      	mov	r0, r4
   28dd6:	eb01 1104 	add.w	r1, r1, r4, lsl #4
   28dda:	f7ff feb3 	bl	28b44 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   28dde:	3401      	adds	r4, #1
   28de0:	e7db      	b.n	28d9a <arm_mpu_init+0x3e>
   28de2:	bf00      	nop
   28de4:	0003fe8c 	.word	0x0003fe8c
   28de8:	000425a5 	.word	0x000425a5
   28dec:	00043e6b 	.word	0x00043e6b
   28df0:	00040606 	.word	0x00040606
   28df4:	000425e5 	.word	0x000425e5
   28df8:	e000ed90 	.word	0xe000ed90
   28dfc:	0044ffaa 	.word	0x0044ffaa
   28e00:	2002c7c4 	.word	0x2002c7c4
   28e04:	00042619 	.word	0x00042619
   28e08:	0004266a 	.word	0x0004266a

00028e0c <arm_core_mpu_configure_static_mpu_regions>:
{
   28e0c:	b538      	push	{r3, r4, r5, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
   28e0e:	4c0c      	ldr	r4, [pc, #48]	; (28e40 <arm_core_mpu_configure_static_mpu_regions+0x34>)
   28e10:	460d      	mov	r5, r1
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
   28e12:	7822      	ldrb	r2, [r4, #0]
   28e14:	f7ff fece 	bl	28bb4 <mpu_configure_regions_and_partition.constprop.2>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   28e18:	7020      	strb	r0, [r4, #0]
	if (mpu_configure_static_mpu_regions(static_regions, regions_num,
   28e1a:	3016      	adds	r0, #22
   28e1c:	d10f      	bne.n	28e3e <arm_core_mpu_configure_static_mpu_regions+0x32>
		__ASSERT(0, "Configuring %u static MPU regions failed\n",
   28e1e:	23f3      	movs	r3, #243	; 0xf3
   28e20:	4a08      	ldr	r2, [pc, #32]	; (28e44 <arm_core_mpu_configure_static_mpu_regions+0x38>)
   28e22:	4909      	ldr	r1, [pc, #36]	; (28e48 <arm_core_mpu_configure_static_mpu_regions+0x3c>)
   28e24:	4809      	ldr	r0, [pc, #36]	; (28e4c <arm_core_mpu_configure_static_mpu_regions+0x40>)
   28e26:	f013 fc81 	bl	3c72c <printk>
   28e2a:	4629      	mov	r1, r5
   28e2c:	4808      	ldr	r0, [pc, #32]	; (28e50 <arm_core_mpu_configure_static_mpu_regions+0x44>)
   28e2e:	f013 fc7d 	bl	3c72c <printk>
}
   28e32:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		__ASSERT(0, "Configuring %u static MPU regions failed\n",
   28e36:	21f3      	movs	r1, #243	; 0xf3
   28e38:	4802      	ldr	r0, [pc, #8]	; (28e44 <arm_core_mpu_configure_static_mpu_regions+0x38>)
   28e3a:	f013 bcbd 	b.w	3c7b8 <assert_post_action>
}
   28e3e:	bd38      	pop	{r3, r4, r5, pc}
   28e40:	2002c7c4 	.word	0x2002c7c4
   28e44:	000425a5 	.word	0x000425a5
   28e48:	00043e6b 	.word	0x00043e6b
   28e4c:	00040606 	.word	0x00040606
   28e50:	0004254a 	.word	0x0004254a

00028e54 <arm_core_mpu_mark_areas_for_dynamic_regions>:
{
   28e54:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   28e58:	4c2e      	ldr	r4, [pc, #184]	; (28f14 <arm_core_mpu_mark_areas_for_dynamic_regions+0xc0>)
   28e5a:	4689      	mov	r9, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
   28e5c:	4680      	mov	r8, r0
   28e5e:	2700      	movs	r7, #0
   28e60:	46a2      	mov	sl, r4
	attr->rbar = MPU->RBAR &
   28e62:	f04f 0b14 	mov.w	fp, #20
	MPU->RNR = index;
   28e66:	4d2c      	ldr	r5, [pc, #176]	; (28f18 <arm_core_mpu_mark_areas_for_dynamic_regions+0xc4>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
   28e68:	454f      	cmp	r7, r9
   28e6a:	db02      	blt.n	28e72 <arm_core_mpu_mark_areas_for_dynamic_regions+0x1e>
}
   28e6c:	b003      	add	sp, #12
   28e6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (dyn_region_areas[i].size == 0U) {
   28e72:	f8d8 3004 	ldr.w	r3, [r8, #4]
   28e76:	9301      	str	r3, [sp, #4]
   28e78:	2b00      	cmp	r3, #0
   28e7a:	d046      	beq.n	28f0a <arm_core_mpu_mark_areas_for_dynamic_regions+0xb6>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
   28e7c:	f8d8 1000 	ldr.w	r1, [r8]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
   28e80:	4608      	mov	r0, r1
   28e82:	9100      	str	r1, [sp, #0]
   28e84:	f013 fe27 	bl	3cad6 <arm_cmse_mpu_region_get>
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   28e88:	e9dd 1300 	ldrd	r1, r3, [sp]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
   28e8c:	4606      	mov	r6, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   28e8e:	1858      	adds	r0, r3, r1
   28e90:	3801      	subs	r0, #1
   28e92:	f013 fe20 	bl	3cad6 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   28e96:	4286      	cmp	r6, r0
   28e98:	4a20      	ldr	r2, [pc, #128]	; (28f1c <arm_core_mpu_mark_areas_for_dynamic_regions+0xc8>)
   28e9a:	d018      	beq.n	28ece <arm_core_mpu_mark_areas_for_dynamic_regions+0x7a>
		dyn_reg_info[i].index =
   28e9c:	2314      	movs	r3, #20
   28e9e:	435f      	muls	r7, r3
   28ea0:	f06f 0315 	mvn.w	r3, #21
   28ea4:	f84a 3007 	str.w	r3, [sl, r7]
		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
   28ea8:	f240 1303 	movw	r3, #259	; 0x103
   28eac:	4a1c      	ldr	r2, [pc, #112]	; (28f20 <arm_core_mpu_mark_areas_for_dynamic_regions+0xcc>)
   28eae:	491d      	ldr	r1, [pc, #116]	; (28f24 <arm_core_mpu_mark_areas_for_dynamic_regions+0xd0>)
   28eb0:	481d      	ldr	r0, [pc, #116]	; (28f28 <arm_core_mpu_mark_areas_for_dynamic_regions+0xd4>)
   28eb2:	f013 fc3b 	bl	3c72c <printk>
   28eb6:	4649      	mov	r1, r9
   28eb8:	481c      	ldr	r0, [pc, #112]	; (28f2c <arm_core_mpu_mark_areas_for_dynamic_regions+0xd8>)
   28eba:	f013 fc37 	bl	3c72c <printk>
   28ebe:	f240 1103 	movw	r1, #259	; 0x103
   28ec2:	4817      	ldr	r0, [pc, #92]	; (28f20 <arm_core_mpu_mark_areas_for_dynamic_regions+0xcc>)
}
   28ec4:	b003      	add	sp, #12
   28ec6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
   28eca:	f013 bc75 	b.w	3c7b8 <assert_post_action>
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
   28ece:	f116 0f16 	cmn.w	r6, #22
		dyn_reg_info[i].index =
   28ed2:	6026      	str	r6, [r4, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
   28ed4:	d0e8      	beq.n	28ea8 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
   28ed6:	7813      	ldrb	r3, [r2, #0]
   28ed8:	42b3      	cmp	r3, r6
   28eda:	dde5      	ble.n	28ea8 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
	attr->rbar = MPU->RBAR &
   28edc:	fb0b a307 	mla	r3, fp, r7, sl
	MPU->RNR = index;
   28ee0:	60ae      	str	r6, [r5, #8]
	MPU->RNR = index;
   28ee2:	60ae      	str	r6, [r5, #8]
	attr->rbar = MPU->RBAR &
   28ee4:	68e8      	ldr	r0, [r5, #12]
   28ee6:	7b19      	ldrb	r1, [r3, #12]
   28ee8:	f360 0104 	bfi	r1, r0, #0, #5
   28eec:	7319      	strb	r1, [r3, #12]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   28eee:	6929      	ldr	r1, [r5, #16]
   28ef0:	7b18      	ldrb	r0, [r3, #12]
   28ef2:	0849      	lsrs	r1, r1, #1
   28ef4:	f361 1047 	bfi	r0, r1, #5, #3
   28ef8:	7318      	strb	r0, [r3, #12]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
   28efa:	68eb      	ldr	r3, [r5, #12]
   28efc:	f023 031f 	bic.w	r3, r3, #31
   28f00:	6063      	str	r3, [r4, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
   28f02:	692b      	ldr	r3, [r5, #16]
   28f04:	f023 031f 	bic.w	r3, r3, #31
   28f08:	6123      	str	r3, [r4, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
   28f0a:	3701      	adds	r7, #1
   28f0c:	3414      	adds	r4, #20
   28f0e:	f108 080c 	add.w	r8, r8, #12
   28f12:	e7a9      	b.n	28e68 <arm_core_mpu_mark_areas_for_dynamic_regions+0x14>
   28f14:	20024bb8 	.word	0x20024bb8
   28f18:	e000ed90 	.word	0xe000ed90
   28f1c:	2002c7c4 	.word	0x2002c7c4
   28f20:	000425a5 	.word	0x000425a5
   28f24:	00043e6b 	.word	0x00043e6b
   28f28:	00040606 	.word	0x00040606
   28f2c:	00042576 	.word	0x00042576

00028f30 <arm_core_mpu_configure_dynamic_mpu_regions>:
{
   28f30:	b570      	push	{r4, r5, r6, lr}
 * performed, the error signal is propagated to the caller of the function.
 */
static int mpu_configure_dynamic_mpu_regions(const struct k_mem_partition
	*dynamic_regions[], u8_t regions_num)
{
	int mpu_reg_index = static_regions_num;
   28f32:	4b16      	ldr	r3, [pc, #88]	; (28f8c <arm_core_mpu_configure_dynamic_mpu_regions+0x5c>)
   28f34:	460c      	mov	r4, r1
   28f36:	781d      	ldrb	r5, [r3, #0]
   28f38:	4606      	mov	r6, r0
   28f3a:	462b      	mov	r3, r5
  mpu->RLAR = 0U;
   28f3c:	2100      	movs	r1, #0
  mpu->RNR = rnr;
   28f3e:	4a14      	ldr	r2, [pc, #80]	; (28f90 <arm_core_mpu_configure_dynamic_mpu_regions+0x60>)

	/* Disable all MPU regions except for the static ones. */
	for (int i = mpu_reg_index; i < get_num_regions(); i++) {
   28f40:	2b0f      	cmp	r3, #15
   28f42:	dd1d      	ble.n	28f80 <arm_core_mpu_configure_dynamic_mpu_regions+0x50>
#if defined(CONFIG_MPU_GAP_FILLING)
	/* Reset MPU regions inside which dynamic memory regions may
	 * be programmed.
	 */
	for (int i = 0; i < MPU_DYNAMIC_REGION_AREAS_NUM; i++) {
		region_init(dyn_reg_info[i].index,
   28f44:	4913      	ldr	r1, [pc, #76]	; (28f94 <arm_core_mpu_configure_dynamic_mpu_regions+0x64>)
   28f46:	f851 0b04 	ldr.w	r0, [r1], #4
   28f4a:	f7ff fdfb 	bl	28b44 <region_init>

	/* In ARMv8-M architecture the dynamic regions are programmed on SRAM,
	 * forming a full partition of the background area, specified by the
	 * given boundaries.
	 */
	mpu_reg_index = mpu_configure_regions_and_partition(dynamic_regions,
   28f4e:	462a      	mov	r2, r5
   28f50:	4621      	mov	r1, r4
   28f52:	4630      	mov	r0, r6
   28f54:	f7ff fe2e 	bl	28bb4 <mpu_configure_regions_and_partition.constprop.2>
	if (mpu_configure_dynamic_mpu_regions(dynamic_regions, regions_num)
   28f58:	3016      	adds	r0, #22
   28f5a:	d115      	bne.n	28f88 <arm_core_mpu_configure_dynamic_mpu_regions+0x58>
		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
   28f5c:	f44f 7389 	mov.w	r3, #274	; 0x112
   28f60:	4a0d      	ldr	r2, [pc, #52]	; (28f98 <arm_core_mpu_configure_dynamic_mpu_regions+0x68>)
   28f62:	490e      	ldr	r1, [pc, #56]	; (28f9c <arm_core_mpu_configure_dynamic_mpu_regions+0x6c>)
   28f64:	480e      	ldr	r0, [pc, #56]	; (28fa0 <arm_core_mpu_configure_dynamic_mpu_regions+0x70>)
   28f66:	f013 fbe1 	bl	3c72c <printk>
   28f6a:	4621      	mov	r1, r4
   28f6c:	480d      	ldr	r0, [pc, #52]	; (28fa4 <arm_core_mpu_configure_dynamic_mpu_regions+0x74>)
   28f6e:	f013 fbdd 	bl	3c72c <printk>
}
   28f72:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
   28f76:	f44f 7189 	mov.w	r1, #274	; 0x112
   28f7a:	4807      	ldr	r0, [pc, #28]	; (28f98 <arm_core_mpu_configure_dynamic_mpu_regions+0x68>)
   28f7c:	f013 bc1c 	b.w	3c7b8 <assert_post_action>
   28f80:	6093      	str	r3, [r2, #8]
  mpu->RLAR = 0U;
   28f82:	6111      	str	r1, [r2, #16]
	for (int i = mpu_reg_index; i < get_num_regions(); i++) {
   28f84:	3301      	adds	r3, #1
   28f86:	e7db      	b.n	28f40 <arm_core_mpu_configure_dynamic_mpu_regions+0x10>
}
   28f88:	bd70      	pop	{r4, r5, r6, pc}
   28f8a:	bf00      	nop
   28f8c:	2002c7c4 	.word	0x2002c7c4
   28f90:	e000ed90 	.word	0xe000ed90
   28f94:	20024bb8 	.word	0x20024bb8
   28f98:	000425a5 	.word	0x000425a5
   28f9c:	00043e6b 	.word	0x00043e6b
   28fa0:	00040606 	.word	0x00040606
   28fa4:	0004251d 	.word	0x0004251d

00028fa8 <z_impl_zephyr_read_stdin>:
{
	_stdin_hook = hook;
}

int z_impl_zephyr_read_stdin(char *buf, int nbytes)
{
   28fa8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   28faa:	4606      	mov	r6, r0
   28fac:	460d      	mov	r5, r1
	int i = 0;

	for (i = 0; i < nbytes; i++) {
   28fae:	2400      	movs	r4, #0
		*(buf + i) = _stdin_hook();
   28fb0:	4f06      	ldr	r7, [pc, #24]	; (28fcc <z_impl_zephyr_read_stdin+0x24>)
	for (i = 0; i < nbytes; i++) {
   28fb2:	42ac      	cmp	r4, r5
   28fb4:	da08      	bge.n	28fc8 <z_impl_zephyr_read_stdin+0x20>
		*(buf + i) = _stdin_hook();
   28fb6:	683b      	ldr	r3, [r7, #0]
   28fb8:	4798      	blx	r3
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
   28fba:	280a      	cmp	r0, #10
		*(buf + i) = _stdin_hook();
   28fbc:	5530      	strb	r0, [r6, r4]
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
   28fbe:	f104 0401 	add.w	r4, r4, #1
   28fc2:	d001      	beq.n	28fc8 <z_impl_zephyr_read_stdin+0x20>
   28fc4:	280d      	cmp	r0, #13
   28fc6:	d1f4      	bne.n	28fb2 <z_impl_zephyr_read_stdin+0xa>
			i++;
			break;
		}
	}
	return i;
}
   28fc8:	4620      	mov	r0, r4
   28fca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   28fcc:	200345d4 	.word	0x200345d4

00028fd0 <z_impl_zephyr_write_stdout>:
}
#include <syscalls/z_zephyr_read_stdin_mrsh.c>
#endif

int z_impl_zephyr_write_stdout(const void *buffer, int nbytes)
{
   28fd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   28fd2:	460e      	mov	r6, r1
   28fd4:	4f09      	ldr	r7, [pc, #36]	; (28ffc <z_impl_zephyr_write_stdout+0x2c>)
   28fd6:	1e44      	subs	r4, r0, #1
	const char *buf = buffer;
	int i;

	for (i = 0; i < nbytes; i++) {
   28fd8:	f1c0 0501 	rsb	r5, r0, #1
   28fdc:	192b      	adds	r3, r5, r4
   28fde:	429e      	cmp	r6, r3
   28fe0:	dc01      	bgt.n	28fe6 <z_impl_zephyr_write_stdout+0x16>
			_stdout_hook('\r');
		}
		_stdout_hook(*(buf + i));
	}
	return nbytes;
}
   28fe2:	4630      	mov	r0, r6
   28fe4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (*(buf + i) == '\n') {
   28fe6:	7863      	ldrb	r3, [r4, #1]
   28fe8:	2b0a      	cmp	r3, #10
   28fea:	d102      	bne.n	28ff2 <z_impl_zephyr_write_stdout+0x22>
			_stdout_hook('\r');
   28fec:	683b      	ldr	r3, [r7, #0]
   28fee:	200d      	movs	r0, #13
   28ff0:	4798      	blx	r3
		_stdout_hook(*(buf + i));
   28ff2:	683b      	ldr	r3, [r7, #0]
   28ff4:	f814 0f01 	ldrb.w	r0, [r4, #1]!
   28ff8:	4798      	blx	r3
   28ffa:	e7ef      	b.n	28fdc <z_impl_zephyr_write_stdout+0xc>
   28ffc:	200345d8 	.word	0x200345d8

00029000 <_exit>:
	return 0;
}
__weak FUNC_ALIAS(_fstat, fstat, int);

__weak void _exit(int status)
{
   29000:	b508      	push	{r3, lr}
	return z_impl_zephyr_write_stdout(buf, nbytes);
   29002:	2105      	movs	r1, #5
   29004:	4801      	ldr	r0, [pc, #4]	; (2900c <_exit+0xc>)
   29006:	f7ff ffe3 	bl	28fd0 <z_impl_zephyr_write_stdout>
	_write(1, "exit\n", 5);
	while (1) {
		;
   2900a:	e7fe      	b.n	2900a <_exit+0xa>
   2900c:	000426f7 	.word	0x000426f7

00029010 <_sbrk>:
}

static LIBC_DATA SYS_SEM_DEFINE(heap_sem, 1, 1);

void *_sbrk(int count)
{
   29010:	b538      	push	{r3, r4, r5, lr}
   29012:	4605      	mov	r5, r0
	void *ret, *ptr;

	sys_sem_take(&heap_sem, K_FOREVER);
   29014:	f04f 31ff 	mov.w	r1, #4294967295
   29018:	480b      	ldr	r0, [pc, #44]	; (29048 <_sbrk+0x38>)
   2901a:	f013 fb99 	bl	3c750 <sys_sem_take>

#if CONFIG_NEWLIB_LIBC_ALIGNED_HEAP_SIZE
	ptr = heap_base + heap_sz;
#else
	ptr = ((char *)HEAP_BASE) + heap_sz;
   2901e:	4a0b      	ldr	r2, [pc, #44]	; (2904c <_sbrk+0x3c>)
#endif

	if ((heap_sz + count) < MAX_HEAP_SIZE) {
   29020:	490b      	ldr	r1, [pc, #44]	; (29050 <_sbrk+0x40>)
	ptr = ((char *)HEAP_BASE) + heap_sz;
   29022:	6814      	ldr	r4, [r2, #0]
	if ((heap_sz + count) < MAX_HEAP_SIZE) {
   29024:	f1c1 5300 	rsb	r3, r1, #536870912	; 0x20000000
   29028:	4425      	add	r5, r4
   2902a:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   2902e:	429d      	cmp	r5, r3
		heap_sz += count;
		ret = ptr;
	} else {
		ret = (void *)-1;
   29030:	bf2c      	ite	cs
   29032:	f04f 34ff 	movcs.w	r4, #4294967295
	ptr = ((char *)HEAP_BASE) + heap_sz;
   29036:	1864      	addcc	r4, r4, r1
	}

	sys_sem_give(&heap_sem);
   29038:	4803      	ldr	r0, [pc, #12]	; (29048 <_sbrk+0x38>)
		heap_sz += count;
   2903a:	bf38      	it	cc
   2903c:	6015      	strcc	r5, [r2, #0]
	sys_sem_give(&heap_sem);
   2903e:	f013 fb82 	bl	3c746 <sys_sem_give>

	return ret;
}
   29042:	4620      	mov	r0, r4
   29044:	bd38      	pop	{r3, r4, r5, pc}
   29046:	bf00      	nop
   29048:	20037ac4 	.word	0x20037ac4
   2904c:	20024bcc 	.word	0x20024bcc
   29050:	20037bbc 	.word	0x20037bbc

00029054 <net_if_flag_is_set>:
 *
 * @return True if the value is set, false otherwise
 */
static inline bool net_if_flag_is_set(struct net_if *iface,
				      enum net_if_flag value)
{
   29054:	b538      	push	{r3, r4, r5, lr}
   29056:	460d      	mov	r5, r1
	NET_ASSERT(iface);
   29058:	4604      	mov	r4, r0
   2905a:	b970      	cbnz	r0, 2907a <net_if_flag_is_set+0x26>
   2905c:	490b      	ldr	r1, [pc, #44]	; (2908c <net_if_flag_is_set+0x38>)
   2905e:	f240 2311 	movw	r3, #529	; 0x211
   29062:	4a0b      	ldr	r2, [pc, #44]	; (29090 <net_if_flag_is_set+0x3c>)
   29064:	480b      	ldr	r0, [pc, #44]	; (29094 <net_if_flag_is_set+0x40>)
   29066:	f013 fb61 	bl	3c72c <printk>
   2906a:	480b      	ldr	r0, [pc, #44]	; (29098 <net_if_flag_is_set+0x44>)
   2906c:	f013 fb5e 	bl	3c72c <printk>
   29070:	f240 2111 	movw	r1, #529	; 0x211
   29074:	4806      	ldr	r0, [pc, #24]	; (29090 <net_if_flag_is_set+0x3c>)
   29076:	f013 fb9f 	bl	3c7b8 <assert_post_action>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2907a:	6823      	ldr	r3, [r4, #0]
   2907c:	330c      	adds	r3, #12
   2907e:	e8d3 0faf 	lda	r0, [r3]
 */
static inline bool atomic_test_bit(const atomic_t *target, int bit)
{
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));

	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   29082:	4128      	asrs	r0, r5

	return atomic_test_bit(iface->if_dev->flags, value);
}
   29084:	f000 0001 	and.w	r0, r0, #1
   29088:	bd38      	pop	{r3, r4, r5, pc}
   2908a:	bf00      	nop
   2908c:	0004273c 	.word	0x0004273c
   29090:	00042714 	.word	0x00042714
   29094:	00040606 	.word	0x00040606
   29098:	00042742 	.word	0x00042742

0002909c <net_if_flag_set.constprop.24>:
static inline void net_if_flag_set(struct net_if *iface,
   2909c:	b510      	push	{r4, lr}
	NET_ASSERT(iface);
   2909e:	4604      	mov	r4, r0
   290a0:	b970      	cbnz	r0, 290c0 <net_if_flag_set.constprop.24+0x24>
   290a2:	490d      	ldr	r1, [pc, #52]	; (290d8 <net_if_flag_set.constprop.24+0x3c>)
   290a4:	f240 13e3 	movw	r3, #483	; 0x1e3
   290a8:	4a0c      	ldr	r2, [pc, #48]	; (290dc <net_if_flag_set.constprop.24+0x40>)
   290aa:	480d      	ldr	r0, [pc, #52]	; (290e0 <net_if_flag_set.constprop.24+0x44>)
   290ac:	f013 fb3e 	bl	3c72c <printk>
   290b0:	480c      	ldr	r0, [pc, #48]	; (290e4 <net_if_flag_set.constprop.24+0x48>)
   290b2:	f013 fb3b 	bl	3c72c <printk>
   290b6:	f240 11e3 	movw	r1, #483	; 0x1e3
   290ba:	4808      	ldr	r0, [pc, #32]	; (290dc <net_if_flag_set.constprop.24+0x40>)
   290bc:	f013 fb7c 	bl	3c7b8 <assert_post_action>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   290c0:	6823      	ldr	r3, [r4, #0]
   290c2:	330c      	adds	r3, #12
   290c4:	e8d3 2fef 	ldaex	r2, [r3]
   290c8:	f042 0201 	orr.w	r2, r2, #1
   290cc:	e8c3 2fe1 	stlex	r1, r2, [r3]
   290d0:	2900      	cmp	r1, #0
   290d2:	d1f7      	bne.n	290c4 <net_if_flag_set.constprop.24+0x28>
}
   290d4:	bd10      	pop	{r4, pc}
   290d6:	bf00      	nop
   290d8:	0004273c 	.word	0x0004273c
   290dc:	00042714 	.word	0x00042714
   290e0:	00040606 	.word	0x00040606
   290e4:	00042742 	.word	0x00042742

000290e8 <net_if_up>:
		cb(iface, user_data);
	}
}

int net_if_up(struct net_if *iface)
{
   290e8:	b538      	push	{r3, r4, r5, lr}
	int status;

	NET_DBG("iface %p", iface);

	if (net_if_flag_is_set(iface, NET_IF_UP)) {
   290ea:	2100      	movs	r1, #0
{
   290ec:	4605      	mov	r5, r0
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
   290ee:	f7ff ffb1 	bl	29054 <net_if_flag_is_set>
   290f2:	b928      	cbnz	r0, 29100 <net_if_up+0x18>
 * @return True if socket offloading is active, false otherwise.
 */
static inline bool net_if_is_socket_offloaded(struct net_if *iface)
{
#if defined(CONFIG_NET_SOCKETS_OFFLOAD)
	return iface->if_dev->offloaded;
   290f4:	682b      	ldr	r3, [r5, #0]

	if ((IS_ENABLED(CONFIG_NET_OFFLOAD) &&
	     net_if_is_ip_offloaded(iface)) ||
	    (IS_ENABLED(CONFIG_NET_SOCKETS_OFFLOAD) &&
	     net_if_is_socket_offloaded(iface))) {
		net_if_flag_set(iface, NET_IF_UP);
   290f6:	4628      	mov	r0, r5
	if ((IS_ENABLED(CONFIG_NET_OFFLOAD) &&
   290f8:	7e9b      	ldrb	r3, [r3, #26]
   290fa:	b11b      	cbz	r3, 29104 <net_if_up+0x1c>
		net_if_flag_set(iface, NET_IF_UP);
   290fc:	f7ff ffce 	bl	2909c <net_if_flag_set.constprop.24>
		return 0;
   29100:	2000      	movs	r0, #0
   29102:	e023      	b.n	2914c <net_if_up+0x64>
		goto exit;
	}

	/* If the L2 does not support enable just set the flag */
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
   29104:	f013 fd16 	bl	3cb34 <net_if_l2>
   29108:	b9c0      	cbnz	r0, 2913c <net_if_up+0x54>

done:
	/* In many places it's assumed that link address was set with
	 * net_if_set_link_addr(). Better check that now.
	 */
	NET_ASSERT(net_if_get_link_addr(iface)->addr != NULL);
   2910a:	682b      	ldr	r3, [r5, #0]
   2910c:	691b      	ldr	r3, [r3, #16]
   2910e:	b973      	cbnz	r3, 2912e <net_if_up+0x46>
   29110:	490f      	ldr	r1, [pc, #60]	; (29150 <net_if_up+0x68>)
   29112:	f640 538f 	movw	r3, #3471	; 0xd8f
   29116:	4a0f      	ldr	r2, [pc, #60]	; (29154 <net_if_up+0x6c>)
   29118:	480f      	ldr	r0, [pc, #60]	; (29158 <net_if_up+0x70>)
   2911a:	f013 fb07 	bl	3c72c <printk>
   2911e:	480f      	ldr	r0, [pc, #60]	; (2915c <net_if_up+0x74>)
   29120:	f013 fb04 	bl	3c72c <printk>
   29124:	f640 518f 	movw	r1, #3471	; 0xd8f
   29128:	480a      	ldr	r0, [pc, #40]	; (29154 <net_if_up+0x6c>)
   2912a:	f013 fb45 	bl	3c7b8 <assert_post_action>

	net_if_flag_set(iface, NET_IF_UP);
   2912e:	4628      	mov	r0, r5
   29130:	f7ff ffb4 	bl	2909c <net_if_flag_set.constprop.24>

	/* If the interface is only having point-to-point traffic then we do
	 * not need to run DAD etc for it.
	 */
	if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
   29134:	4628      	mov	r0, r5
   29136:	f013 fd02 	bl	3cb3e <l2_flags_get>
   2913a:	e7e1      	b.n	29100 <net_if_up+0x18>
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
   2913c:	6883      	ldr	r3, [r0, #8]
   2913e:	2b00      	cmp	r3, #0
   29140:	d0e3      	beq.n	2910a <net_if_up+0x22>
	status = net_if_l2(iface)->enable(iface, true);
   29142:	2101      	movs	r1, #1
   29144:	4628      	mov	r0, r5
   29146:	4798      	blx	r3
	if (status < 0) {
   29148:	2800      	cmp	r0, #0
   2914a:	dade      	bge.n	2910a <net_if_up+0x22>

exit:
	net_mgmt_event_notify(NET_EVENT_IF_UP, iface);

	return 0;
}
   2914c:	bd38      	pop	{r3, r4, r5, pc}
   2914e:	bf00      	nop
   29150:	00042745 	.word	0x00042745
   29154:	00042776 	.word	0x00042776
   29158:	00040606 	.word	0x00040606
   2915c:	00042742 	.word	0x00042742

00029160 <net_if_init>:
	k_fifo_put(&tx_ts_queue, pkt);
}
#endif /* CONFIG_NET_PKT_TIMESTAMP_THREAD */

void net_if_init(void)
{
   29160:	b538      	push	{r3, r4, r5, lr}

	NET_DBG("");

	net_tc_tx_init();

	for (iface = __net_if_start, if_count = 0; iface != __net_if_end;
   29162:	4c07      	ldr	r4, [pc, #28]	; (29180 <net_if_init+0x20>)
   29164:	4d07      	ldr	r5, [pc, #28]	; (29184 <net_if_init+0x24>)
   29166:	42ac      	cmp	r4, r5
   29168:	d100      	bne.n	2916c <net_if_init+0xc>
		NET_WARN("You have configured only %d VLAN interfaces"
			 " but you have %d network interfaces.",
			 CONFIG_NET_VLAN_COUNT, if_count);
	}
#endif
}
   2916a:	bd38      	pop	{r3, r4, r5, pc}
	return iface->if_dev->dev;
   2916c:	6823      	ldr	r3, [r4, #0]
	const struct net_if_api *api = net_if_get_device(iface)->driver_api;
   2916e:	681b      	ldr	r3, [r3, #0]
   29170:	685b      	ldr	r3, [r3, #4]
	if (!api || !api->init) {
   29172:	b11b      	cbz	r3, 2917c <net_if_init+0x1c>
   29174:	681b      	ldr	r3, [r3, #0]
   29176:	b10b      	cbz	r3, 2917c <net_if_init+0x1c>
	api->init(iface);
   29178:	4620      	mov	r0, r4
   2917a:	4798      	blx	r3
	     iface++, if_count++) {
   2917c:	3420      	adds	r4, #32
   2917e:	e7f2      	b.n	29166 <net_if_init+0x6>
   29180:	20037b80 	.word	0x20037b80
   29184:	20037ba0 	.word	0x20037ba0

00029188 <net_if_post_init>:

void net_if_post_init(void)
{
   29188:	b538      	push	{r3, r4, r5, lr}
	struct net_if *iface;

	NET_DBG("");

	/* After TX is running, attempt to bring the interface up */
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   2918a:	4c07      	ldr	r4, [pc, #28]	; (291a8 <net_if_post_init+0x20>)
   2918c:	4d07      	ldr	r5, [pc, #28]	; (291ac <net_if_post_init+0x24>)
   2918e:	42ac      	cmp	r4, r5
   29190:	d100      	bne.n	29194 <net_if_post_init+0xc>
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
			net_if_up(iface);
		}
	}
}
   29192:	bd38      	pop	{r3, r4, r5, pc}
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
   29194:	2103      	movs	r1, #3
   29196:	4620      	mov	r0, r4
   29198:	f7ff ff5c 	bl	29054 <net_if_flag_is_set>
   2919c:	b910      	cbnz	r0, 291a4 <net_if_post_init+0x1c>
			net_if_up(iface);
   2919e:	4620      	mov	r0, r4
   291a0:	f7ff ffa2 	bl	290e8 <net_if_up>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   291a4:	3420      	adds	r4, #32
   291a6:	e7f2      	b.n	2918e <net_if_post_init+0x6>
   291a8:	20037b80 	.word	0x20037b80
   291ac:	20037ba0 	.word	0x20037ba0

000291b0 <z_impl_net_addr_ntop>:
	struct in6_addr *addr6;
	u16_t *w;
	u8_t i, bl, bh, longest = 1U;
	s8_t pos = -1;
	char delim = ':';
	unsigned char zeros[8] = { 0 };
   291b0:	2300      	movs	r3, #0
{
   291b2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char *ptr = dst;
	int len = -1;
	u16_t value;
	bool needcolon = false;

	if (family == AF_INET6) {
   291b6:	2802      	cmp	r0, #2
{
   291b8:	b089      	sub	sp, #36	; 0x24
   291ba:	4681      	mov	r9, r0
   291bc:	468a      	mov	sl, r1
   291be:	4690      	mov	r8, r2
	unsigned char zeros[8] = { 0 };
   291c0:	e9cd 3306 	strd	r3, r3, [sp, #24]
	if (family == AF_INET6) {
   291c4:	d13c      	bne.n	29240 <z_impl_net_addr_ntop+0x90>
		addr6 = (struct in6_addr *)src;
		w = (u16_t *)addr6->s6_addr16;
   291c6:	aa06      	add	r2, sp, #24
   291c8:	4610      	mov	r0, r2
   291ca:	9104      	str	r1, [sp, #16]
{
   291cc:	4619      	mov	r1, r3
   291ce:	e006      	b.n	291de <z_impl_net_addr_ntop+0x2e>
			for (j = i; j < 8; j++) {
				if (UNALIGNED_GET(&w[j]) != 0) {
					break;
				}

				zeros[i]++;
   291d0:	7804      	ldrb	r4, [r0, #0]
   291d2:	3101      	adds	r1, #1
   291d4:	3401      	adds	r4, #1
   291d6:	7004      	strb	r4, [r0, #0]
			for (j = i; j < 8; j++) {
   291d8:	b2cc      	uxtb	r4, r1
   291da:	2c07      	cmp	r4, #7
   291dc:	d803      	bhi.n	291e6 <z_impl_net_addr_ntop+0x36>
				if (UNALIGNED_GET(&w[j]) != 0) {
   291de:	f83a 4011 	ldrh.w	r4, [sl, r1, lsl #1]
   291e2:	2c00      	cmp	r4, #0
   291e4:	d0f4      	beq.n	291d0 <z_impl_net_addr_ntop+0x20>
   291e6:	3301      	adds	r3, #1
		for (i = 0U; i < 8; i++) {
   291e8:	2b08      	cmp	r3, #8
   291ea:	f100 0001 	add.w	r0, r0, #1
   291ee:	d1ed      	bne.n	291cc <z_impl_net_addr_ntop+0x1c>
	s8_t pos = -1;
   291f0:	f04f 36ff 	mov.w	r6, #4294967295
	u8_t i, bl, bh, longest = 1U;
   291f4:	2701      	movs	r7, #1
			}
		}

		for (i = 0U; i < 8; i++) {
   291f6:	2300      	movs	r3, #0
			if (zeros[i] > longest) {
   291f8:	f812 1b01 	ldrb.w	r1, [r2], #1
   291fc:	42b9      	cmp	r1, r7
				longest = zeros[i];
				pos = i;
   291fe:	bf88      	it	hi
   29200:	b25e      	sxtbhi	r6, r3
		for (i = 0U; i < 8; i++) {
   29202:	f103 0301 	add.w	r3, r3, #1
   29206:	b2db      	uxtb	r3, r3
				pos = i;
   29208:	bf88      	it	hi
   2920a:	460f      	movhi	r7, r1
		for (i = 0U; i < 8; i++) {
   2920c:	2b08      	cmp	r3, #8
   2920e:	d1f3      	bne.n	291f8 <z_impl_net_addr_ntop+0x48>
		len = 8;
   29210:	9303      	str	r3, [sp, #12]
   29212:	2f01      	cmp	r7, #1
   29214:	f04f 033a 	mov.w	r3, #58	; 0x3a
   29218:	bf08      	it	eq
   2921a:	f04f 36ff 	moveq.w	r6, #4294967295
   2921e:	9302      	str	r3, [sp, #8]
	bool needcolon = false;
   29220:	2200      	movs	r2, #0
		delim = '.';
	} else {
		return NULL;
	}

	for (i = 0U; i < len; i++) {
   29222:	4644      	mov	r4, r8
   29224:	4615      	mov	r5, r2
   29226:	9b03      	ldr	r3, [sp, #12]
   29228:	429d      	cmp	r5, r3
   2922a:	db19      	blt.n	29260 <z_impl_net_addr_ntop+0xb0>
		}

		needcolon = true;
	}

	if (!(ptr - dst)) {
   2922c:	4544      	cmp	r4, r8
   2922e:	d009      	beq.n	29244 <z_impl_net_addr_ntop+0x94>
		return NULL;
	}

	if (family == AF_INET) {
   29230:	2300      	movs	r3, #0
   29232:	f1b9 0f01 	cmp.w	r9, #1
		*(ptr - 1) = '\0';
   29236:	bf0c      	ite	eq
   29238:	f804 3c01 	strbeq.w	r3, [r4, #-1]
	} else {
		*ptr = '\0';
   2923c:	7023      	strbne	r3, [r4, #0]
   2923e:	e003      	b.n	29248 <z_impl_net_addr_ntop+0x98>
	} else if (family == AF_INET) {
   29240:	2801      	cmp	r0, #1
   29242:	d005      	beq.n	29250 <z_impl_net_addr_ntop+0xa0>
		return NULL;
   29244:	f04f 0800 	mov.w	r8, #0
	}

	return dst;
}
   29248:	4640      	mov	r0, r8
   2924a:	b009      	add	sp, #36	; 0x24
   2924c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		delim = '.';
   29250:	232e      	movs	r3, #46	; 0x2e
   29252:	2204      	movs	r2, #4
	s8_t pos = -1;
   29254:	f04f 36ff 	mov.w	r6, #4294967295
		delim = '.';
   29258:	e9cd 3202 	strd	r3, r2, [sp, #8]
	u8_t i, bl, bh, longest = 1U;
   2925c:	4607      	mov	r7, r0
   2925e:	e7df      	b.n	29220 <z_impl_net_addr_ntop+0x70>
		if (len == 4) {
   29260:	9b03      	ldr	r3, [sp, #12]
   29262:	2b04      	cmp	r3, #4
   29264:	d134      	bne.n	292d0 <z_impl_net_addr_ntop+0x120>
			value = (u32_t)addr->s4_addr[i];
   29266:	f81a 1005 	ldrb.w	r1, [sl, r5]
			if (value == 0U) {
   2926a:	b949      	cbnz	r1, 29280 <z_impl_net_addr_ntop+0xd0>
				*ptr++ = '0';
   2926c:	2330      	movs	r3, #48	; 0x30
   2926e:	4620      	mov	r0, r4
   29270:	f800 3b02 	strb.w	r3, [r0], #2
				*ptr++ = delim;
   29274:	9b02      	ldr	r3, [sp, #8]
   29276:	7063      	strb	r3, [r4, #1]
	for (i = 0U; i < len; i++) {
   29278:	3501      	adds	r5, #1
   2927a:	b2ed      	uxtb	r5, r5
   2927c:	4604      	mov	r4, r0
   2927e:	e7d2      	b.n	29226 <z_impl_net_addr_ntop+0x76>
			l = net_value_to_udec(ptr, value, 0);
   29280:	2009      	movs	r0, #9
   29282:	f04f 0b00 	mov.w	fp, #0
   29286:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 29360 <z_impl_net_addr_ntop+0x1b0>
   2928a:	9401      	str	r4, [sp, #4]
		temp = value / divisor;
   2928c:	fbb1 fefc 	udiv	lr, r1, ip
		value = value % divisor;
   29290:	fb0c 131e 	mls	r3, ip, lr, r1
		if ((precision > i) || (temp != 0)) {
   29294:	4583      	cmp	fp, r0
		value = value % divisor;
   29296:	9305      	str	r3, [sp, #20]
		if ((precision > i) || (temp != 0)) {
   29298:	dc01      	bgt.n	2929e <z_impl_net_addr_ntop+0xee>
   2929a:	4561      	cmp	r1, ip
   2929c:	d306      	bcc.n	292ac <z_impl_net_addr_ntop+0xfc>
			*buf++ = (char) (temp + '0');
   2929e:	4683      	mov	fp, r0
   292a0:	9b01      	ldr	r3, [sp, #4]
   292a2:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
   292a6:	f803 eb01 	strb.w	lr, [r3], #1
   292aa:	9301      	str	r3, [sp, #4]
	for (i = 9; i >= 0; i--, divisor /= 10U) {
   292ac:	230a      	movs	r3, #10
   292ae:	3801      	subs	r0, #1
   292b0:	fbbc fcf3 	udiv	ip, ip, r3
   292b4:	1c43      	adds	r3, r0, #1
		value = value % divisor;
   292b6:	9905      	ldr	r1, [sp, #20]
	for (i = 9; i >= 0; i--, divisor /= 10U) {
   292b8:	d1e8      	bne.n	2928c <z_impl_net_addr_ntop+0xdc>
	*buf = 0;
   292ba:	f04f 0300 	mov.w	r3, #0
   292be:	9901      	ldr	r1, [sp, #4]
   292c0:	700b      	strb	r3, [r1, #0]
	return buf - start;
   292c2:	1b0b      	subs	r3, r1, r4
			ptr += l;
   292c4:	b2db      	uxtb	r3, r3
			*ptr++ = delim;
   292c6:	9902      	ldr	r1, [sp, #8]
			ptr += l;
   292c8:	18e0      	adds	r0, r4, r3
			*ptr++ = delim;
   292ca:	3001      	adds	r0, #1
   292cc:	54e1      	strb	r1, [r4, r3]
			continue;
   292ce:	e7d3      	b.n	29278 <z_impl_net_addr_ntop+0xc8>
		if (i == pos) {
   292d0:	42ae      	cmp	r6, r5
   292d2:	d10d      	bne.n	292f0 <z_impl_net_addr_ntop+0x140>
			if (needcolon || i == 0U) {
   292d4:	b902      	cbnz	r2, 292d8 <z_impl_net_addr_ntop+0x128>
   292d6:	b916      	cbnz	r6, 292de <z_impl_net_addr_ntop+0x12e>
				*ptr++ = ':';
   292d8:	233a      	movs	r3, #58	; 0x3a
   292da:	f804 3b01 	strb.w	r3, [r4], #1
			*ptr++ = ':';
   292de:	233a      	movs	r3, #58	; 0x3a
   292e0:	4620      	mov	r0, r4
   292e2:	f800 3b01 	strb.w	r3, [r0], #1
			i += longest - 1U;
   292e6:	1e7b      	subs	r3, r7, #1
   292e8:	441d      	add	r5, r3
   292ea:	b2ed      	uxtb	r5, r5
			needcolon = false;
   292ec:	2200      	movs	r2, #0
			continue;
   292ee:	e7c3      	b.n	29278 <z_impl_net_addr_ntop+0xc8>
		if (needcolon) {
   292f0:	b112      	cbz	r2, 292f8 <z_impl_net_addr_ntop+0x148>
			*ptr++ = ':';
   292f2:	233a      	movs	r3, #58	; 0x3a
   292f4:	f804 3b01 	strb.w	r3, [r4], #1
		value = (u32_t)sys_be16_to_cpu(UNALIGNED_GET(&w[i]));
   292f8:	9b04      	ldr	r3, [sp, #16]
   292fa:	f833 3015 	ldrh.w	r3, [r3, r5, lsl #1]
   292fe:	021a      	lsls	r2, r3, #8
   29300:	ea42 2213 	orr.w	r2, r2, r3, lsr #8
   29304:	b212      	sxth	r2, r2
		bh = value >> 8;
   29306:	f3c2 2307 	ubfx	r3, r2, #8, #8
		bl = value & 0xff;
   2930a:	fa5f fb82 	uxtb.w	fp, r2
		if (bh) {
   2930e:	b1b3      	cbz	r3, 2933e <z_impl_net_addr_ntop+0x18e>
			if (bh > 0x0f) {
   29310:	2b0f      	cmp	r3, #15
		bh = value >> 8;
   29312:	b2d9      	uxtb	r1, r3
			if (bh > 0x0f) {
   29314:	d90b      	bls.n	2932e <z_impl_net_addr_ntop+0x17e>
				ptr = net_byte_to_hex(ptr, bh, 'a', false);
   29316:	2300      	movs	r3, #0
   29318:	2261      	movs	r2, #97	; 0x61
   2931a:	4620      	mov	r0, r4
   2931c:	f013 fc1c 	bl	3cb58 <net_byte_to_hex>
			ptr = net_byte_to_hex(ptr, bl, 'a', true);
   29320:	2301      	movs	r3, #1
   29322:	2261      	movs	r2, #97	; 0x61
   29324:	4659      	mov	r1, fp
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
   29326:	f013 fc17 	bl	3cb58 <net_byte_to_hex>
		needcolon = true;
   2932a:	2201      	movs	r2, #1
   2932c:	e7a4      	b.n	29278 <z_impl_net_addr_ntop+0xc8>
				if (bh < 10) {
   2932e:	b25b      	sxtb	r3, r3
   29330:	2909      	cmp	r1, #9
					*ptr++ = (char)(bh + '0');
   29332:	bf94      	ite	ls
   29334:	3330      	addls	r3, #48	; 0x30
					*ptr++ = (char) (bh - 10 + 'a');
   29336:	3357      	addhi	r3, #87	; 0x57
   29338:	1c60      	adds	r0, r4, #1
   2933a:	7023      	strb	r3, [r4, #0]
   2933c:	e7f0      	b.n	29320 <z_impl_net_addr_ntop+0x170>
		} else if (bl > 0x0f) {
   2933e:	f1bb 0f0f 	cmp.w	fp, #15
   29342:	d903      	bls.n	2934c <z_impl_net_addr_ntop+0x19c>
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
   29344:	2261      	movs	r2, #97	; 0x61
   29346:	4659      	mov	r1, fp
   29348:	4620      	mov	r0, r4
   2934a:	e7ec      	b.n	29326 <z_impl_net_addr_ntop+0x176>
			if (bl < 10) {
   2934c:	b252      	sxtb	r2, r2
   2934e:	f1bb 0f09 	cmp.w	fp, #9
				*ptr++ = (char)(bl + '0');
   29352:	bf94      	ite	ls
   29354:	3230      	addls	r2, #48	; 0x30
				*ptr++ = (char) (bl - 10 + 'a');
   29356:	3257      	addhi	r2, #87	; 0x57
   29358:	1c60      	adds	r0, r4, #1
   2935a:	7022      	strb	r2, [r4, #0]
   2935c:	e7e5      	b.n	2932a <z_impl_net_addr_ntop+0x17a>
   2935e:	bf00      	nop
   29360:	3b9aca00 	.word	0x3b9aca00

00029364 <connect_request_encode>:
	return mqtt_encode_fixed_header(message_type, start, buf);
}

int connect_request_encode(const struct mqtt_client *client,
			   struct buf_ctx *buf)
{
   29364:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	} else {
		mqtt_proto_desc = &mqtt_3_1_0_proto_desc;
	}

	/* Reserve space for fixed header. */
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   29368:	680f      	ldr	r7, [r1, #0]
	u8_t connect_flags = client->clean_session << 1;
   2936a:	f890 5078 	ldrb.w	r5, [r0, #120]	; 0x78
	start = buf->cur;

	MQTT_TRC("Encoding Protocol Description. Str:%s Size:%08x.",
		 mqtt_proto_desc->utf8, mqtt_proto_desc->size);

	err_code = pack_utf8_str(mqtt_proto_desc, buf);
   2936e:	4b3b      	ldr	r3, [pc, #236]	; (2945c <connect_request_encode+0xf8>)
   29370:	4a3b      	ldr	r2, [pc, #236]	; (29460 <connect_request_encode+0xfc>)
{
   29372:	4606      	mov	r6, r0
	if (client->protocol_version == MQTT_VERSION_3_1_1) {
   29374:	f890 0076 	ldrb.w	r0, [r0, #118]	; 0x76
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   29378:	3705      	adds	r7, #5
	err_code = pack_utf8_str(mqtt_proto_desc, buf);
   2937a:	2804      	cmp	r0, #4
   2937c:	bf0c      	ite	eq
   2937e:	4610      	moveq	r0, r2
   29380:	4618      	movne	r0, r3
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   29382:	600f      	str	r7, [r1, #0]
{
   29384:	460c      	mov	r4, r1
	err_code = pack_utf8_str(mqtt_proto_desc, buf);
   29386:	f013 fccf 	bl	3cd28 <pack_utf8_str>
	u8_t connect_flags = client->clean_session << 1;
   2938a:	f3c5 0540 	ubfx	r5, r5, #1, #1
	if (err_code != 0) {
   2938e:	4603      	mov	r3, r0
   29390:	b938      	cbnz	r0, 293a2 <connect_request_encode+0x3e>
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   29392:	e9d4 2000 	ldrd	r2, r0, [r4]
   29396:	4290      	cmp	r0, r2
		return err_code;
	}

	MQTT_TRC("Encoding Protocol Version %02x.", client->protocol_version);
	err_code = pack_uint8(client->protocol_version, buf);
   29398:	f896 1076 	ldrb.w	r1, [r6, #118]	; 0x76
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   2939c:	d104      	bne.n	293a8 <connect_request_encode+0x44>
		return -ENOMEM;
   2939e:	f06f 030b 	mvn.w	r3, #11

	/* Write the flags the connect flags. */
	*connect_flags_pos = connect_flags;

	return mqtt_encode_fixed_header(message_type, start, buf);
}
   293a2:	4618      	mov	r0, r3
   293a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	*(buf->cur++) = val;
   293a8:	1c50      	adds	r0, r2, #1
   293aa:	6020      	str	r0, [r4, #0]
   293ac:	7011      	strb	r1, [r2, #0]
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   293ae:	e9d4 8200 	ldrd	r8, r2, [r4]
   293b2:	4590      	cmp	r8, r2
   293b4:	d0f3      	beq.n	2939e <connect_request_encode+0x3a>
	*(buf->cur++) = val;
   293b6:	f108 0201 	add.w	r2, r8, #1
   293ba:	6022      	str	r2, [r4, #0]
   293bc:	f888 3000 	strb.w	r3, [r8]
	err_code = pack_uint16(client->keepalive, buf);
   293c0:	4621      	mov	r1, r4
   293c2:	f8b6 0074 	ldrh.w	r0, [r6, #116]	; 0x74
   293c6:	f013 fc9d 	bl	3cd04 <pack_uint16>
	if (err_code != 0) {
   293ca:	4603      	mov	r3, r0
   293cc:	2800      	cmp	r0, #0
   293ce:	d1e8      	bne.n	293a2 <connect_request_encode+0x3e>
	err_code = pack_utf8_str(&client->client_id, buf);
   293d0:	f106 0044 	add.w	r0, r6, #68	; 0x44
   293d4:	f013 fca8 	bl	3cd28 <pack_utf8_str>
	if (err_code != 0) {
   293d8:	4603      	mov	r3, r0
   293da:	2800      	cmp	r0, #0
   293dc:	d1e1      	bne.n	293a2 <connect_request_encode+0x3e>
	if (client->will_topic != NULL) {
   293de:	6db0      	ldr	r0, [r6, #88]	; 0x58
	u8_t connect_flags = client->clean_session << 1;
   293e0:	006d      	lsls	r5, r5, #1
	if (client->will_topic != NULL) {
   293e2:	b1d8      	cbz	r0, 2941c <connect_request_encode+0xb8>
		connect_flags |= client->will_retain << 5;
   293e4:	f896 3078 	ldrb.w	r3, [r6, #120]	; 0x78
		connect_flags |= MQTT_CONNECT_FLAG_WILL_TOPIC;
   293e8:	f045 0504 	orr.w	r5, r5, #4
		connect_flags |= client->will_retain << 5;
   293ec:	f003 0301 	and.w	r3, r3, #1
   293f0:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
		connect_flags |= ((client->will_topic->qos & 0x03) << 3);
   293f4:	7a03      	ldrb	r3, [r0, #8]
		err_code = pack_utf8_str(&client->will_topic->topic, buf);
   293f6:	4621      	mov	r1, r4
		connect_flags |= ((client->will_topic->qos & 0x03) << 3);
   293f8:	00db      	lsls	r3, r3, #3
   293fa:	f003 0318 	and.w	r3, r3, #24
		connect_flags |= client->will_retain << 5;
   293fe:	431d      	orrs	r5, r3
		err_code = pack_utf8_str(&client->will_topic->topic, buf);
   29400:	f013 fc92 	bl	3cd28 <pack_utf8_str>
		if (err_code != 0) {
   29404:	4603      	mov	r3, r0
   29406:	2800      	cmp	r0, #0
   29408:	d1cb      	bne.n	293a2 <connect_request_encode+0x3e>
		if (client->will_message != NULL) {
   2940a:	6df3      	ldr	r3, [r6, #92]	; 0x5c
			err_code = pack_utf8_str(client->will_message, buf);
   2940c:	4621      	mov	r1, r4
		if (client->will_message != NULL) {
   2940e:	b313      	cbz	r3, 29456 <connect_request_encode+0xf2>
			err_code = pack_utf8_str(client->will_message, buf);
   29410:	4618      	mov	r0, r3
   29412:	f013 fc89 	bl	3cd28 <pack_utf8_str>
			if (err_code != 0) {
   29416:	4603      	mov	r3, r0
   29418:	2800      	cmp	r0, #0
   2941a:	d1c2      	bne.n	293a2 <connect_request_encode+0x3e>
	if (client->user_name != NULL) {
   2941c:	6d30      	ldr	r0, [r6, #80]	; 0x50
   2941e:	b138      	cbz	r0, 29430 <connect_request_encode+0xcc>
		err_code = pack_utf8_str(client->user_name, buf);
   29420:	4621      	mov	r1, r4
   29422:	f013 fc81 	bl	3cd28 <pack_utf8_str>
		if (err_code != 0) {
   29426:	4603      	mov	r3, r0
   29428:	2800      	cmp	r0, #0
   2942a:	d1ba      	bne.n	293a2 <connect_request_encode+0x3e>
		connect_flags |= MQTT_CONNECT_FLAG_USERNAME;
   2942c:	f045 0580 	orr.w	r5, r5, #128	; 0x80
	if (client->password != NULL) {
   29430:	6d70      	ldr	r0, [r6, #84]	; 0x54
   29432:	b138      	cbz	r0, 29444 <connect_request_encode+0xe0>
		err_code = pack_utf8_str(client->password, buf);
   29434:	4621      	mov	r1, r4
   29436:	f013 fc77 	bl	3cd28 <pack_utf8_str>
		if (err_code != 0) {
   2943a:	4603      	mov	r3, r0
   2943c:	2800      	cmp	r0, #0
   2943e:	d1b0      	bne.n	293a2 <connect_request_encode+0x3e>
		connect_flags |= MQTT_CONNECT_FLAG_PASSWORD;
   29440:	f045 0540 	orr.w	r5, r5, #64	; 0x40
	*connect_flags_pos = connect_flags;
   29444:	f888 5000 	strb.w	r5, [r8]
	return mqtt_encode_fixed_header(message_type, start, buf);
   29448:	4622      	mov	r2, r4
   2944a:	4639      	mov	r1, r7
}
   2944c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return mqtt_encode_fixed_header(message_type, start, buf);
   29450:	2010      	movs	r0, #16
   29452:	f013 bc84 	b.w	3cd5e <mqtt_encode_fixed_header>
	return pack_uint16(0x0000, buf);
   29456:	f013 fc55 	bl	3cd04 <pack_uint16>
   2945a:	e7dc      	b.n	29416 <connect_request_encode+0xb2>
   2945c:	0003feb4 	.word	0x0003feb4
   29460:	0003febc 	.word	0x0003febc

00029464 <disconnect_encode>:
	return mqtt_message_id_only_enc(message_type, param->message_id, buf);
}

int disconnect_encode(struct buf_ctx *buf)
{
	if (buf->end - buf->cur < sizeof(disc_packet)) {
   29464:	e9d0 2300 	ldrd	r2, r3, [r0]
   29468:	1a9b      	subs	r3, r3, r2
   2946a:	2b01      	cmp	r3, #1
   2946c:	bf81      	itttt	hi
   2946e:	4b05      	ldrhi	r3, [pc, #20]	; (29484 <disconnect_encode+0x20>)
   29470:	881b      	ldrhhi	r3, [r3, #0]
   29472:	8013      	strhhi	r3, [r2, #0]
		return -ENOMEM;
	}

	memcpy(buf->cur, disc_packet, sizeof(disc_packet));
	buf->end = buf->cur + sizeof(disc_packet);
   29474:	6803      	ldrhi	r3, [r0, #0]
   29476:	bf83      	ittte	hi
   29478:	3302      	addhi	r3, #2
   2947a:	6043      	strhi	r3, [r0, #4]

	return 0;
   2947c:	2000      	movhi	r0, #0
		return -ENOMEM;
   2947e:	f06f 000b 	mvnls.w	r0, #11
}
   29482:	4770      	bx	lr
   29484:	000427a0 	.word	0x000427a0

00029488 <ping_request_encode>:
	return mqtt_encode_fixed_header(message_type, start, buf);
}

int ping_request_encode(struct buf_ctx *buf)
{
	if (buf->end - buf->cur < sizeof(ping_packet)) {
   29488:	e9d0 2300 	ldrd	r2, r3, [r0]
   2948c:	1a9b      	subs	r3, r3, r2
   2948e:	2b01      	cmp	r3, #1
   29490:	bf81      	itttt	hi
   29492:	4b05      	ldrhi	r3, [pc, #20]	; (294a8 <ping_request_encode+0x20>)
   29494:	881b      	ldrhhi	r3, [r3, #0]
   29496:	8013      	strhhi	r3, [r2, #0]
		return -ENOMEM;
	}

	memcpy(buf->cur, ping_packet, sizeof(ping_packet));
	buf->end = buf->cur + sizeof(ping_packet);
   29498:	6803      	ldrhi	r3, [r0, #0]
   2949a:	bf83      	ittte	hi
   2949c:	3302      	addhi	r3, #2
   2949e:	6043      	strhi	r3, [r0, #4]

	return 0;
   294a0:	2000      	movhi	r0, #0
		return -ENOMEM;
   294a2:	f06f 000b 	mvnls.w	r0, #11
}
   294a6:	4770      	bx	lr
   294a8:	000427ac 	.word	0x000427ac

000294ac <close>:
{
   294ac:	b570      	push	{r4, r5, r6, lr}
	__ASSERT_NO_MSG(socket_ops);
   294ae:	4c10      	ldr	r4, [pc, #64]	; (294f0 <close+0x44>)
{
   294b0:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(socket_ops);
   294b2:	6823      	ldr	r3, [r4, #0]
   294b4:	b94b      	cbnz	r3, 294ca <close+0x1e>
   294b6:	490f      	ldr	r1, [pc, #60]	; (294f4 <close+0x48>)
   294b8:	480f      	ldr	r0, [pc, #60]	; (294f8 <close+0x4c>)
   294ba:	2321      	movs	r3, #33	; 0x21
   294bc:	4a0f      	ldr	r2, [pc, #60]	; (294fc <close+0x50>)
   294be:	f013 f935 	bl	3c72c <printk>
   294c2:	2121      	movs	r1, #33	; 0x21
   294c4:	480d      	ldr	r0, [pc, #52]	; (294fc <close+0x50>)
   294c6:	f013 f977 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->close);
   294ca:	6823      	ldr	r3, [r4, #0]
   294cc:	685b      	ldr	r3, [r3, #4]
   294ce:	b94b      	cbnz	r3, 294e4 <close+0x38>
   294d0:	490b      	ldr	r1, [pc, #44]	; (29500 <close+0x54>)
   294d2:	4809      	ldr	r0, [pc, #36]	; (294f8 <close+0x4c>)
   294d4:	2322      	movs	r3, #34	; 0x22
   294d6:	4a09      	ldr	r2, [pc, #36]	; (294fc <close+0x50>)
   294d8:	f013 f928 	bl	3c72c <printk>
   294dc:	2122      	movs	r1, #34	; 0x22
   294de:	4807      	ldr	r0, [pc, #28]	; (294fc <close+0x50>)
   294e0:	f013 f96a 	bl	3c7b8 <assert_post_action>
	return socket_ops->close(sock);
   294e4:	6823      	ldr	r3, [r4, #0]
   294e6:	4628      	mov	r0, r5
}
   294e8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return socket_ops->close(sock);
   294ec:	685b      	ldr	r3, [r3, #4]
   294ee:	4718      	bx	r3
   294f0:	20024aec 	.word	0x20024aec
   294f4:	000411aa 	.word	0x000411aa
   294f8:	00040606 	.word	0x00040606
   294fc:	0004117a 	.word	0x0004117a
   29500:	000427ae 	.word	0x000427ae

00029504 <mqtt_client_tcp_connect>:
#include <net/mqtt.h>

#include "mqtt_os.h"

int mqtt_client_tcp_connect(struct mqtt_client *client)
{
   29504:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(socket_ops);
   29508:	4c2d      	ldr	r4, [pc, #180]	; (295c0 <mqtt_client_tcp_connect+0xbc>)
	const struct sockaddr *broker = client->broker;
   2950a:	6cc5      	ldr	r5, [r0, #76]	; 0x4c
   2950c:	6823      	ldr	r3, [r4, #0]
{
   2950e:	4606      	mov	r6, r0
	int ret;

	client->transport.tcp.sock = socket(broker->sa_family, SOCK_STREAM,
   29510:	882f      	ldrh	r7, [r5, #0]
   29512:	b94b      	cbnz	r3, 29528 <mqtt_client_tcp_connect+0x24>
   29514:	492b      	ldr	r1, [pc, #172]	; (295c4 <mqtt_client_tcp_connect+0xc0>)
   29516:	482c      	ldr	r0, [pc, #176]	; (295c8 <mqtt_client_tcp_connect+0xc4>)
   29518:	2319      	movs	r3, #25
   2951a:	4a2c      	ldr	r2, [pc, #176]	; (295cc <mqtt_client_tcp_connect+0xc8>)
   2951c:	f013 f906 	bl	3c72c <printk>
   29520:	2119      	movs	r1, #25
   29522:	482a      	ldr	r0, [pc, #168]	; (295cc <mqtt_client_tcp_connect+0xc8>)
   29524:	f013 f948 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->socket);
   29528:	6823      	ldr	r3, [r4, #0]
   2952a:	681b      	ldr	r3, [r3, #0]
   2952c:	b94b      	cbnz	r3, 29542 <mqtt_client_tcp_connect+0x3e>
   2952e:	4928      	ldr	r1, [pc, #160]	; (295d0 <mqtt_client_tcp_connect+0xcc>)
   29530:	4825      	ldr	r0, [pc, #148]	; (295c8 <mqtt_client_tcp_connect+0xc4>)
   29532:	231a      	movs	r3, #26
   29534:	4a25      	ldr	r2, [pc, #148]	; (295cc <mqtt_client_tcp_connect+0xc8>)
   29536:	f013 f8f9 	bl	3c72c <printk>
   2953a:	211a      	movs	r1, #26
   2953c:	4823      	ldr	r0, [pc, #140]	; (295cc <mqtt_client_tcp_connect+0xc8>)
   2953e:	f013 f93b 	bl	3c7b8 <assert_post_action>
	return socket_ops->socket(family, type, proto);
   29542:	6823      	ldr	r3, [r4, #0]
   29544:	4638      	mov	r0, r7
   29546:	681b      	ldr	r3, [r3, #0]
   29548:	2206      	movs	r2, #6
   2954a:	2101      	movs	r1, #1
   2954c:	4798      	blx	r3
					    IPPROTO_TCP);
	if (client->transport.tcp.sock < 0) {
   2954e:	2800      	cmp	r0, #0
   29550:	4607      	mov	r7, r0
	client->transport.tcp.sock = socket(broker->sa_family, SOCK_STREAM,
   29552:	62b0      	str	r0, [r6, #40]	; 0x28
	if (client->transport.tcp.sock < 0) {
   29554:	da05      	bge.n	29562 <mqtt_client_tcp_connect+0x5e>

	ret = connect(client->transport.tcp.sock, client->broker,
		      peer_addr_size);
	if (ret < 0) {
		(void)close(client->transport.tcp.sock);
		return -errno;
   29556:	f013 fae4 	bl	3cb22 <__errno>
   2955a:	6800      	ldr	r0, [r0, #0]
   2955c:	4240      	negs	r0, r0
	}

	MQTT_TRC("Connect completed");
	return 0;
}
   2955e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (broker->sa_family == AF_INET) {
   29562:	882b      	ldrh	r3, [r5, #0]
	ret = connect(client->transport.tcp.sock, client->broker,
   29564:	6cf5      	ldr	r5, [r6, #76]	; 0x4c
		peer_addr_size = sizeof(struct sockaddr_in);
   29566:	2b01      	cmp	r3, #1
	__ASSERT_NO_MSG(socket_ops);
   29568:	6823      	ldr	r3, [r4, #0]
   2956a:	bf14      	ite	ne
   2956c:	f04f 0818 	movne.w	r8, #24
   29570:	f04f 0808 	moveq.w	r8, #8
   29574:	b94b      	cbnz	r3, 2958a <mqtt_client_tcp_connect+0x86>
   29576:	4913      	ldr	r1, [pc, #76]	; (295c4 <mqtt_client_tcp_connect+0xc0>)
   29578:	4813      	ldr	r0, [pc, #76]	; (295c8 <mqtt_client_tcp_connect+0xc4>)
   2957a:	2345      	movs	r3, #69	; 0x45
   2957c:	4a13      	ldr	r2, [pc, #76]	; (295cc <mqtt_client_tcp_connect+0xc8>)
   2957e:	f013 f8d5 	bl	3c72c <printk>
   29582:	2145      	movs	r1, #69	; 0x45
   29584:	4811      	ldr	r0, [pc, #68]	; (295cc <mqtt_client_tcp_connect+0xc8>)
   29586:	f013 f917 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->connect);
   2958a:	6823      	ldr	r3, [r4, #0]
   2958c:	695b      	ldr	r3, [r3, #20]
   2958e:	b94b      	cbnz	r3, 295a4 <mqtt_client_tcp_connect+0xa0>
   29590:	4910      	ldr	r1, [pc, #64]	; (295d4 <mqtt_client_tcp_connect+0xd0>)
   29592:	480d      	ldr	r0, [pc, #52]	; (295c8 <mqtt_client_tcp_connect+0xc4>)
   29594:	2346      	movs	r3, #70	; 0x46
   29596:	4a0d      	ldr	r2, [pc, #52]	; (295cc <mqtt_client_tcp_connect+0xc8>)
   29598:	f013 f8c8 	bl	3c72c <printk>
   2959c:	2146      	movs	r1, #70	; 0x46
   2959e:	480b      	ldr	r0, [pc, #44]	; (295cc <mqtt_client_tcp_connect+0xc8>)
   295a0:	f013 f90a 	bl	3c7b8 <assert_post_action>
	return socket_ops->connect(sock, addr, addrlen);
   295a4:	6823      	ldr	r3, [r4, #0]
   295a6:	4642      	mov	r2, r8
   295a8:	695b      	ldr	r3, [r3, #20]
   295aa:	4629      	mov	r1, r5
   295ac:	4638      	mov	r0, r7
   295ae:	4798      	blx	r3
	if (ret < 0) {
   295b0:	2800      	cmp	r0, #0
   295b2:	da03      	bge.n	295bc <mqtt_client_tcp_connect+0xb8>
		(void)close(client->transport.tcp.sock);
   295b4:	6ab0      	ldr	r0, [r6, #40]	; 0x28
   295b6:	f7ff ff79 	bl	294ac <close>
   295ba:	e7cc      	b.n	29556 <mqtt_client_tcp_connect+0x52>
	return 0;
   295bc:	2000      	movs	r0, #0
   295be:	e7ce      	b.n	2955e <mqtt_client_tcp_connect+0x5a>
   295c0:	20024aec 	.word	0x20024aec
   295c4:	000411aa 	.word	0x000411aa
   295c8:	00040606 	.word	0x00040606
   295cc:	0004117a 	.word	0x0004117a
   295d0:	000427c0 	.word	0x000427c0
   295d4:	000427d3 	.word	0x000427d3

000295d8 <mqtt_client_tcp_write>:

int mqtt_client_tcp_write(struct mqtt_client *client, const u8_t *data,
			  u32_t datalen)
{
   295d8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   295dc:	4680      	mov	r8, r0
   295de:	4689      	mov	r9, r1
   295e0:	4617      	mov	r7, r2
	u32_t offset = 0U;
   295e2:	2400      	movs	r4, #0
	__ASSERT_NO_MSG(socket_ops);
   295e4:	4d1d      	ldr	r5, [pc, #116]	; (2965c <mqtt_client_tcp_write+0x84>)
	int ret;

	while (offset < datalen) {
   295e6:	42bc      	cmp	r4, r7
   295e8:	d301      	bcc.n	295ee <mqtt_client_tcp_write+0x16>
		}

		offset += ret;
	}

	return 0;
   295ea:	2000      	movs	r0, #0
   295ec:	e031      	b.n	29652 <mqtt_client_tcp_write+0x7a>
		ret = send(client->transport.tcp.sock, data + offset,
   295ee:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
   295f2:	eb09 0a04 	add.w	sl, r9, r4
   295f6:	461e      	mov	r6, r3
   295f8:	4b19      	ldr	r3, [pc, #100]	; (29660 <mqtt_client_tcp_write+0x88>)
   295fa:	eba7 0b04 	sub.w	fp, r7, r4
   295fe:	681b      	ldr	r3, [r3, #0]
   29600:	b94b      	cbnz	r3, 29616 <mqtt_client_tcp_write+0x3e>
   29602:	4918      	ldr	r1, [pc, #96]	; (29664 <mqtt_client_tcp_write+0x8c>)
   29604:	4818      	ldr	r0, [pc, #96]	; (29668 <mqtt_client_tcp_write+0x90>)
   29606:	237e      	movs	r3, #126	; 0x7e
   29608:	462a      	mov	r2, r5
   2960a:	f013 f88f 	bl	3c72c <printk>
   2960e:	217e      	movs	r1, #126	; 0x7e
   29610:	4628      	mov	r0, r5
   29612:	f013 f8d1 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->send);
   29616:	4b12      	ldr	r3, [pc, #72]	; (29660 <mqtt_client_tcp_write+0x88>)
   29618:	681b      	ldr	r3, [r3, #0]
   2961a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2961c:	b94b      	cbnz	r3, 29632 <mqtt_client_tcp_write+0x5a>
   2961e:	4913      	ldr	r1, [pc, #76]	; (2966c <mqtt_client_tcp_write+0x94>)
   29620:	4811      	ldr	r0, [pc, #68]	; (29668 <mqtt_client_tcp_write+0x90>)
   29622:	237f      	movs	r3, #127	; 0x7f
   29624:	462a      	mov	r2, r5
   29626:	f013 f881 	bl	3c72c <printk>
   2962a:	217f      	movs	r1, #127	; 0x7f
   2962c:	4628      	mov	r0, r5
   2962e:	f013 f8c3 	bl	3c7b8 <assert_post_action>
	return socket_ops->send(sock, buf, len, flags);
   29632:	4b0b      	ldr	r3, [pc, #44]	; (29660 <mqtt_client_tcp_write+0x88>)
   29634:	4630      	mov	r0, r6
   29636:	681b      	ldr	r3, [r3, #0]
   29638:	465a      	mov	r2, fp
   2963a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2963c:	4651      	mov	r1, sl
   2963e:	469c      	mov	ip, r3
   29640:	2300      	movs	r3, #0
   29642:	4666      	mov	r6, ip
   29644:	47b0      	blx	r6
		if (ret < 0) {
   29646:	2800      	cmp	r0, #0
   29648:	da05      	bge.n	29656 <mqtt_client_tcp_write+0x7e>
			return -errno;
   2964a:	f013 fa6a 	bl	3cb22 <__errno>
   2964e:	6800      	ldr	r0, [r0, #0]
   29650:	4240      	negs	r0, r0
}
   29652:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		offset += ret;
   29656:	4404      	add	r4, r0
   29658:	e7c5      	b.n	295e6 <mqtt_client_tcp_write+0xe>
   2965a:	bf00      	nop
   2965c:	0004117a 	.word	0x0004117a
   29660:	20024aec 	.word	0x20024aec
   29664:	000411aa 	.word	0x000411aa
   29668:	00040606 	.word	0x00040606
   2966c:	000427f8 	.word	0x000427f8

00029670 <mqtt_client_tcp_read>:

int mqtt_client_tcp_read(struct mqtt_client *client, u8_t *data, u32_t buflen,
			 bool shall_block)
{
   29670:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(socket_ops);
   29674:	4c18      	ldr	r4, [pc, #96]	; (296d8 <mqtt_client_tcp_read+0x68>)
	int flags = 0;
	int ret;

	if (!shall_block) {
		flags |= MSG_DONTWAIT;
   29676:	2b00      	cmp	r3, #0
   29678:	6823      	ldr	r3, [r4, #0]
{
   2967a:	460e      	mov	r6, r1
   2967c:	4617      	mov	r7, r2
		flags |= MSG_DONTWAIT;
   2967e:	bf14      	ite	ne
   29680:	f04f 0800 	movne.w	r8, #0
   29684:	f04f 0840 	moveq.w	r8, #64	; 0x40
	}

	ret = recv(client->transport.tcp.sock, data, buflen, flags);
   29688:	6a85      	ldr	r5, [r0, #40]	; 0x28
   2968a:	b94b      	cbnz	r3, 296a0 <mqtt_client_tcp_read+0x30>
   2968c:	4913      	ldr	r1, [pc, #76]	; (296dc <mqtt_client_tcp_read+0x6c>)
   2968e:	4814      	ldr	r0, [pc, #80]	; (296e0 <mqtt_client_tcp_read+0x70>)
   29690:	2369      	movs	r3, #105	; 0x69
   29692:	4a14      	ldr	r2, [pc, #80]	; (296e4 <mqtt_client_tcp_read+0x74>)
   29694:	f013 f84a 	bl	3c72c <printk>
   29698:	2169      	movs	r1, #105	; 0x69
   2969a:	4812      	ldr	r0, [pc, #72]	; (296e4 <mqtt_client_tcp_read+0x74>)
   2969c:	f013 f88c 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->recv);
   296a0:	6823      	ldr	r3, [r4, #0]
   296a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   296a4:	b94b      	cbnz	r3, 296ba <mqtt_client_tcp_read+0x4a>
   296a6:	4910      	ldr	r1, [pc, #64]	; (296e8 <mqtt_client_tcp_read+0x78>)
   296a8:	480d      	ldr	r0, [pc, #52]	; (296e0 <mqtt_client_tcp_read+0x70>)
   296aa:	236a      	movs	r3, #106	; 0x6a
   296ac:	4a0d      	ldr	r2, [pc, #52]	; (296e4 <mqtt_client_tcp_read+0x74>)
   296ae:	f013 f83d 	bl	3c72c <printk>
   296b2:	216a      	movs	r1, #106	; 0x6a
   296b4:	480b      	ldr	r0, [pc, #44]	; (296e4 <mqtt_client_tcp_read+0x74>)
   296b6:	f013 f87f 	bl	3c7b8 <assert_post_action>
	return socket_ops->recv(sock, buf, max_len, flags);
   296ba:	6823      	ldr	r3, [r4, #0]
   296bc:	463a      	mov	r2, r7
   296be:	6a5c      	ldr	r4, [r3, #36]	; 0x24
   296c0:	4631      	mov	r1, r6
   296c2:	4643      	mov	r3, r8
   296c4:	4628      	mov	r0, r5
   296c6:	47a0      	blx	r4
	if (ret < 0) {
   296c8:	2800      	cmp	r0, #0
   296ca:	da03      	bge.n	296d4 <mqtt_client_tcp_read+0x64>
		return -errno;
   296cc:	f013 fa29 	bl	3cb22 <__errno>
   296d0:	6800      	ldr	r0, [r0, #0]
   296d2:	4240      	negs	r0, r0
	}

	return ret;
}
   296d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   296d8:	20024aec 	.word	0x20024aec
   296dc:	000411aa 	.word	0x000411aa
   296e0:	00040606 	.word	0x00040606
   296e4:	0004117a 	.word	0x0004117a
   296e8:	000427e7 	.word	0x000427e7

000296ec <mqtt_transport_connect>:
#endif /* CONFIG_MQTT_LIB_WEBSOCKET */
};

int mqtt_transport_connect(struct mqtt_client *client)
{
	return transport_fn[client->transport.type].connect(client);
   296ec:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
   296f0:	4a01      	ldr	r2, [pc, #4]	; (296f8 <mqtt_transport_connect+0xc>)
   296f2:	011b      	lsls	r3, r3, #4
   296f4:	58d3      	ldr	r3, [r2, r3]
   296f6:	4718      	bx	r3
   296f8:	0003fec4 	.word	0x0003fec4

000296fc <mqtt_transport_write>:
}

int mqtt_transport_write(struct mqtt_client *client, const u8_t *data,
			 u32_t datalen)
{
   296fc:	b410      	push	{r4}
	return transport_fn[client->transport.type].write(client, data,
   296fe:	4b04      	ldr	r3, [pc, #16]	; (29710 <mqtt_transport_write+0x14>)
   29700:	f890 4024 	ldrb.w	r4, [r0, #36]	; 0x24
   29704:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   29708:	685b      	ldr	r3, [r3, #4]
							  datalen);
}
   2970a:	f85d 4b04 	ldr.w	r4, [sp], #4
	return transport_fn[client->transport.type].write(client, data,
   2970e:	4718      	bx	r3
   29710:	0003fec4 	.word	0x0003fec4

00029714 <mqtt_transport_read>:

int mqtt_transport_read(struct mqtt_client *client, u8_t *data, u32_t buflen,
			bool shall_block)
{
   29714:	b430      	push	{r4, r5}
	return transport_fn[client->transport.type].read(client, data, buflen,
   29716:	f890 5024 	ldrb.w	r5, [r0, #36]	; 0x24
   2971a:	4c03      	ldr	r4, [pc, #12]	; (29728 <mqtt_transport_read+0x14>)
   2971c:	eb04 1405 	add.w	r4, r4, r5, lsl #4
   29720:	68a4      	ldr	r4, [r4, #8]
   29722:	46a4      	mov	ip, r4
							 shall_block);
}
   29724:	bc30      	pop	{r4, r5}
	return transport_fn[client->transport.type].read(client, data, buflen,
   29726:	4760      	bx	ip
   29728:	0003fec4 	.word	0x0003fec4

0002972c <mqtt_transport_disconnect>:

int mqtt_transport_disconnect(struct mqtt_client *client)
{
	return transport_fn[client->transport.type].disconnect(client);
   2972c:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
   29730:	4b02      	ldr	r3, [pc, #8]	; (2973c <mqtt_transport_disconnect+0x10>)
   29732:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   29736:	68db      	ldr	r3, [r3, #12]
   29738:	4718      	bx	r3
   2973a:	bf00      	nop
   2973c:	0003fec4 	.word	0x0003fec4

00029740 <mqtt_mutex_unlock>:
	return k_mutex_lock(&mutex->kernel_mutex, timeout);
}

static inline int sys_mutex_unlock(struct sys_mutex *mutex)
{
	if (mutex->kernel_mutex.lock_count == 0) {
   29740:	68c2      	ldr	r2, [r0, #12]
}

/**@brief Release the lock on the module specific mutex, if any.
 */
static inline void mqtt_mutex_unlock(struct mqtt_client *client)
{
   29742:	b510      	push	{r4, lr}
   29744:	b142      	cbz	r2, 29758 <mqtt_mutex_unlock+0x18>
		return -EINVAL;
	}

	if (mutex->kernel_mutex.owner != _current) {
   29746:	4b0f      	ldr	r3, [pc, #60]	; (29784 <mqtt_mutex_unlock+0x44>)
   29748:	6882      	ldr	r2, [r0, #8]
   2974a:	689b      	ldr	r3, [r3, #8]
   2974c:	429a      	cmp	r2, r3
   2974e:	d115      	bne.n	2977c <mqtt_mutex_unlock+0x3c>
	int ret = sys_mutex_unlock(&client->internal.mutex);

	__ASSERT(ret == 0, "sys_mutex_unlock failed with %d", ret);
	(void)ret;
}
   29750:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   29754:	f00c bd26 	b.w	361a4 <z_impl_k_mutex_unlock>
		return -EINVAL;
   29758:	f06f 0415 	mvn.w	r4, #21
	__ASSERT(ret == 0, "sys_mutex_unlock failed with %d", ret);
   2975c:	2343      	movs	r3, #67	; 0x43
   2975e:	4a0a      	ldr	r2, [pc, #40]	; (29788 <mqtt_mutex_unlock+0x48>)
   29760:	490a      	ldr	r1, [pc, #40]	; (2978c <mqtt_mutex_unlock+0x4c>)
   29762:	480b      	ldr	r0, [pc, #44]	; (29790 <mqtt_mutex_unlock+0x50>)
   29764:	f012 ffe2 	bl	3c72c <printk>
   29768:	4621      	mov	r1, r4
   2976a:	480a      	ldr	r0, [pc, #40]	; (29794 <mqtt_mutex_unlock+0x54>)
   2976c:	f012 ffde 	bl	3c72c <printk>
}
   29770:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__ASSERT(ret == 0, "sys_mutex_unlock failed with %d", ret);
   29774:	2143      	movs	r1, #67	; 0x43
   29776:	4804      	ldr	r0, [pc, #16]	; (29788 <mqtt_mutex_unlock+0x48>)
   29778:	f013 b81e 	b.w	3c7b8 <assert_post_action>
		return -EPERM;
   2977c:	f04f 34ff 	mov.w	r4, #4294967295
   29780:	e7ec      	b.n	2975c <mqtt_mutex_unlock+0x1c>
   29782:	bf00      	nop
   29784:	2002976c 	.word	0x2002976c
   29788:	00042829 	.word	0x00042829
   2978c:	0004285a 	.word	0x0004285a
   29790:	00040606 	.word	0x00040606
   29794:	00042863 	.word	0x00042863

00029798 <mqtt_mutex_lock>:
{
   29798:	b510      	push	{r4, lr}
	return z_impl_k_mutex_lock(mutex, timeout);
   2979a:	f04f 31ff 	mov.w	r1, #4294967295
   2979e:	f00c fc23 	bl	35fe8 <z_impl_k_mutex_lock>
	__ASSERT(ret == 0, "sys_mutex_lock failed with %d", ret);
   297a2:	4604      	mov	r4, r0
   297a4:	b178      	cbz	r0, 297c6 <mqtt_mutex_lock+0x2e>
   297a6:	2339      	movs	r3, #57	; 0x39
   297a8:	4a07      	ldr	r2, [pc, #28]	; (297c8 <mqtt_mutex_lock+0x30>)
   297aa:	4908      	ldr	r1, [pc, #32]	; (297cc <mqtt_mutex_lock+0x34>)
   297ac:	4808      	ldr	r0, [pc, #32]	; (297d0 <mqtt_mutex_lock+0x38>)
   297ae:	f012 ffbd 	bl	3c72c <printk>
   297b2:	4621      	mov	r1, r4
   297b4:	4807      	ldr	r0, [pc, #28]	; (297d4 <mqtt_mutex_lock+0x3c>)
   297b6:	f012 ffb9 	bl	3c72c <printk>
}
   297ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__ASSERT(ret == 0, "sys_mutex_lock failed with %d", ret);
   297be:	2139      	movs	r1, #57	; 0x39
   297c0:	4801      	ldr	r0, [pc, #4]	; (297c8 <mqtt_mutex_lock+0x30>)
   297c2:	f012 bff9 	b.w	3c7b8 <assert_post_action>
}
   297c6:	bd10      	pop	{r4, pc}
   297c8:	00042829 	.word	0x00042829
   297cc:	0004285a 	.word	0x0004285a
   297d0:	00040606 	.word	0x00040606
   297d4:	00042809 	.word	0x00042809

000297d8 <close>:
{
   297d8:	b570      	push	{r4, r5, r6, lr}
	__ASSERT_NO_MSG(socket_ops);
   297da:	4c10      	ldr	r4, [pc, #64]	; (2981c <close+0x44>)
{
   297dc:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(socket_ops);
   297de:	6823      	ldr	r3, [r4, #0]
   297e0:	b94b      	cbnz	r3, 297f6 <close+0x1e>
   297e2:	490f      	ldr	r1, [pc, #60]	; (29820 <close+0x48>)
   297e4:	480f      	ldr	r0, [pc, #60]	; (29824 <close+0x4c>)
   297e6:	2321      	movs	r3, #33	; 0x21
   297e8:	4a0f      	ldr	r2, [pc, #60]	; (29828 <close+0x50>)
   297ea:	f012 ff9f 	bl	3c72c <printk>
   297ee:	2121      	movs	r1, #33	; 0x21
   297f0:	480d      	ldr	r0, [pc, #52]	; (29828 <close+0x50>)
   297f2:	f012 ffe1 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->close);
   297f6:	6823      	ldr	r3, [r4, #0]
   297f8:	685b      	ldr	r3, [r3, #4]
   297fa:	b94b      	cbnz	r3, 29810 <close+0x38>
   297fc:	490b      	ldr	r1, [pc, #44]	; (2982c <close+0x54>)
   297fe:	4809      	ldr	r0, [pc, #36]	; (29824 <close+0x4c>)
   29800:	2322      	movs	r3, #34	; 0x22
   29802:	4a09      	ldr	r2, [pc, #36]	; (29828 <close+0x50>)
   29804:	f012 ff92 	bl	3c72c <printk>
   29808:	2122      	movs	r1, #34	; 0x22
   2980a:	4807      	ldr	r0, [pc, #28]	; (29828 <close+0x50>)
   2980c:	f012 ffd4 	bl	3c7b8 <assert_post_action>
	return socket_ops->close(sock);
   29810:	6823      	ldr	r3, [r4, #0]
   29812:	4628      	mov	r0, r5
}
   29814:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return socket_ops->close(sock);
   29818:	685b      	ldr	r3, [r3, #4]
   2981a:	4718      	bx	r3
   2981c:	20024aec 	.word	0x20024aec
   29820:	000411aa 	.word	0x000411aa
   29824:	00040606 	.word	0x00040606
   29828:	0004117a 	.word	0x0004117a
   2982c:	000427ae 	.word	0x000427ae

00029830 <setsockopt.constprop.1>:
static inline int setsockopt(int sock, int level, int optname,
   29830:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(socket_ops);
   29834:	4c15      	ldr	r4, [pc, #84]	; (2988c <setsockopt.constprop.1+0x5c>)
static inline int setsockopt(int sock, int level, int optname,
   29836:	4698      	mov	r8, r3
	__ASSERT_NO_MSG(socket_ops);
   29838:	6823      	ldr	r3, [r4, #0]
static inline int setsockopt(int sock, int level, int optname,
   2983a:	4605      	mov	r5, r0
   2983c:	460e      	mov	r6, r1
   2983e:	4617      	mov	r7, r2
	__ASSERT_NO_MSG(socket_ops);
   29840:	b94b      	cbnz	r3, 29856 <setsockopt.constprop.1+0x26>
   29842:	4913      	ldr	r1, [pc, #76]	; (29890 <setsockopt.constprop.1+0x60>)
   29844:	4813      	ldr	r0, [pc, #76]	; (29894 <setsockopt.constprop.1+0x64>)
   29846:	2357      	movs	r3, #87	; 0x57
   29848:	4a13      	ldr	r2, [pc, #76]	; (29898 <setsockopt.constprop.1+0x68>)
   2984a:	f012 ff6f 	bl	3c72c <printk>
   2984e:	2157      	movs	r1, #87	; 0x57
   29850:	4811      	ldr	r0, [pc, #68]	; (29898 <setsockopt.constprop.1+0x68>)
   29852:	f012 ffb1 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->setsockopt);
   29856:	6823      	ldr	r3, [r4, #0]
   29858:	69db      	ldr	r3, [r3, #28]
   2985a:	b94b      	cbnz	r3, 29870 <setsockopt.constprop.1+0x40>
   2985c:	490f      	ldr	r1, [pc, #60]	; (2989c <setsockopt.constprop.1+0x6c>)
   2985e:	480d      	ldr	r0, [pc, #52]	; (29894 <setsockopt.constprop.1+0x64>)
   29860:	2358      	movs	r3, #88	; 0x58
   29862:	4a0d      	ldr	r2, [pc, #52]	; (29898 <setsockopt.constprop.1+0x68>)
   29864:	f012 ff62 	bl	3c72c <printk>
   29868:	2158      	movs	r1, #88	; 0x58
   2986a:	480b      	ldr	r0, [pc, #44]	; (29898 <setsockopt.constprop.1+0x68>)
   2986c:	f012 ffa4 	bl	3c7b8 <assert_post_action>
	return socket_ops->setsockopt(sock, level, optname, optval, optlen);
   29870:	6823      	ldr	r3, [r4, #0]
   29872:	f8cd 8000 	str.w	r8, [sp]
   29876:	69dc      	ldr	r4, [r3, #28]
   29878:	4632      	mov	r2, r6
   2987a:	463b      	mov	r3, r7
   2987c:	f44f 718d 	mov.w	r1, #282	; 0x11a
   29880:	4628      	mov	r0, r5
   29882:	47a0      	blx	r4
}
   29884:	b002      	add	sp, #8
   29886:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2988a:	bf00      	nop
   2988c:	20024aec 	.word	0x20024aec
   29890:	000411aa 	.word	0x000411aa
   29894:	00040606 	.word	0x00040606
   29898:	0004117a 	.word	0x0004117a
   2989c:	00042885 	.word	0x00042885

000298a0 <mqtt_client_tls_connect>:
#include <net/mqtt.h>

#include "mqtt_os.h"

int mqtt_client_tls_connect(struct mqtt_client *client)
{
   298a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(socket_ops);
   298a4:	4d48      	ldr	r5, [pc, #288]	; (299c8 <mqtt_client_tls_connect+0x128>)
	const struct sockaddr *broker = client->broker;
   298a6:	6cc7      	ldr	r7, [r0, #76]	; 0x4c
   298a8:	682b      	ldr	r3, [r5, #0]
{
   298aa:	4604      	mov	r4, r0
	struct mqtt_sec_config *tls_config = &client->transport.tls.config;
	int ret;

	client->transport.tls.sock = socket(broker->sa_family,
   298ac:	883e      	ldrh	r6, [r7, #0]
   298ae:	b94b      	cbnz	r3, 298c4 <mqtt_client_tls_connect+0x24>
   298b0:	4946      	ldr	r1, [pc, #280]	; (299cc <mqtt_client_tls_connect+0x12c>)
   298b2:	4847      	ldr	r0, [pc, #284]	; (299d0 <mqtt_client_tls_connect+0x130>)
   298b4:	2319      	movs	r3, #25
   298b6:	4a47      	ldr	r2, [pc, #284]	; (299d4 <mqtt_client_tls_connect+0x134>)
   298b8:	f012 ff38 	bl	3c72c <printk>
   298bc:	2119      	movs	r1, #25
   298be:	4845      	ldr	r0, [pc, #276]	; (299d4 <mqtt_client_tls_connect+0x134>)
   298c0:	f012 ff7a 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->socket);
   298c4:	682b      	ldr	r3, [r5, #0]
   298c6:	681b      	ldr	r3, [r3, #0]
   298c8:	b94b      	cbnz	r3, 298de <mqtt_client_tls_connect+0x3e>
   298ca:	4943      	ldr	r1, [pc, #268]	; (299d8 <mqtt_client_tls_connect+0x138>)
   298cc:	4840      	ldr	r0, [pc, #256]	; (299d0 <mqtt_client_tls_connect+0x130>)
   298ce:	231a      	movs	r3, #26
   298d0:	4a40      	ldr	r2, [pc, #256]	; (299d4 <mqtt_client_tls_connect+0x134>)
   298d2:	f012 ff2b 	bl	3c72c <printk>
   298d6:	211a      	movs	r1, #26
   298d8:	483e      	ldr	r0, [pc, #248]	; (299d4 <mqtt_client_tls_connect+0x134>)
   298da:	f012 ff6d 	bl	3c7b8 <assert_post_action>
	return socket_ops->socket(family, type, proto);
   298de:	682b      	ldr	r3, [r5, #0]
   298e0:	f44f 7281 	mov.w	r2, #258	; 0x102
   298e4:	681b      	ldr	r3, [r3, #0]
   298e6:	2101      	movs	r1, #1
   298e8:	4630      	mov	r0, r6
   298ea:	4798      	blx	r3
					    SOCK_STREAM, IPPROTO_TLS_1_2);
	if (client->transport.tls.sock < 0) {
   298ec:	2800      	cmp	r0, #0
	client->transport.tls.sock = socket(broker->sa_family,
   298ee:	62a0      	str	r0, [r4, #40]	; 0x28
	if (client->transport.tls.sock < 0) {
   298f0:	da05      	bge.n	298fe <mqtt_client_tls_connect+0x5e>
	MQTT_TRC("Connect completed");
	return 0;

error:
	(void)close(client->transport.tls.sock);
	return -errno;
   298f2:	f013 f916 	bl	3cb22 <__errno>
   298f6:	6800      	ldr	r0, [r0, #0]
   298f8:	4240      	negs	r0, r0
}
   298fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ret = setsockopt(client->transport.tls.sock, SOL_TLS, TLS_PEER_VERIFY,
   298fe:	2304      	movs	r3, #4
   29900:	f104 022c 	add.w	r2, r4, #44	; 0x2c
   29904:	2105      	movs	r1, #5
   29906:	f7ff ff93 	bl	29830 <setsockopt.constprop.1>
	if (ret < 0) {
   2990a:	2800      	cmp	r0, #0
   2990c:	da03      	bge.n	29916 <mqtt_client_tls_connect+0x76>
	(void)close(client->transport.tls.sock);
   2990e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   29910:	f7ff ff62 	bl	297d8 <close>
   29914:	e7ed      	b.n	298f2 <mqtt_client_tls_connect+0x52>
	if (tls_config->cipher_list != NULL && tls_config->cipher_count > 0) {
   29916:	6b62      	ldr	r2, [r4, #52]	; 0x34
   29918:	2a00      	cmp	r2, #0
   2991a:	d131      	bne.n	29980 <mqtt_client_tls_connect+0xe0>
	if (tls_config->sec_tag_list != NULL && tls_config->sec_tag_count > 0) {
   2991c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   2991e:	2a00      	cmp	r2, #0
   29920:	d139      	bne.n	29996 <mqtt_client_tls_connect+0xf6>
	if (tls_config->hostname) {
   29922:	6c26      	ldr	r6, [r4, #64]	; 0x40
   29924:	2e00      	cmp	r6, #0
   29926:	d141      	bne.n	299ac <mqtt_client_tls_connect+0x10c>
	if (broker->sa_family == AF_INET) {
   29928:	883b      	ldrh	r3, [r7, #0]
	ret = connect(client->transport.tls.sock, client->broker,
   2992a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
	size_t peer_addr_size = sizeof(struct sockaddr_in6);
   2992c:	2b01      	cmp	r3, #1
	__ASSERT_NO_MSG(socket_ops);
   2992e:	682b      	ldr	r3, [r5, #0]
   29930:	bf0c      	ite	eq
   29932:	f04f 0808 	moveq.w	r8, #8
   29936:	f04f 0818 	movne.w	r8, #24
	ret = connect(client->transport.tls.sock, client->broker,
   2993a:	6ce7      	ldr	r7, [r4, #76]	; 0x4c
   2993c:	b94b      	cbnz	r3, 29952 <mqtt_client_tls_connect+0xb2>
   2993e:	4923      	ldr	r1, [pc, #140]	; (299cc <mqtt_client_tls_connect+0x12c>)
   29940:	4823      	ldr	r0, [pc, #140]	; (299d0 <mqtt_client_tls_connect+0x130>)
   29942:	2345      	movs	r3, #69	; 0x45
   29944:	4a23      	ldr	r2, [pc, #140]	; (299d4 <mqtt_client_tls_connect+0x134>)
   29946:	f012 fef1 	bl	3c72c <printk>
   2994a:	2145      	movs	r1, #69	; 0x45
   2994c:	4821      	ldr	r0, [pc, #132]	; (299d4 <mqtt_client_tls_connect+0x134>)
   2994e:	f012 ff33 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->connect);
   29952:	682b      	ldr	r3, [r5, #0]
   29954:	695b      	ldr	r3, [r3, #20]
   29956:	b94b      	cbnz	r3, 2996c <mqtt_client_tls_connect+0xcc>
   29958:	4920      	ldr	r1, [pc, #128]	; (299dc <mqtt_client_tls_connect+0x13c>)
   2995a:	481d      	ldr	r0, [pc, #116]	; (299d0 <mqtt_client_tls_connect+0x130>)
   2995c:	2346      	movs	r3, #70	; 0x46
   2995e:	4a1d      	ldr	r2, [pc, #116]	; (299d4 <mqtt_client_tls_connect+0x134>)
   29960:	f012 fee4 	bl	3c72c <printk>
   29964:	2146      	movs	r1, #70	; 0x46
   29966:	481b      	ldr	r0, [pc, #108]	; (299d4 <mqtt_client_tls_connect+0x134>)
   29968:	f012 ff26 	bl	3c7b8 <assert_post_action>
	return socket_ops->connect(sock, addr, addrlen);
   2996c:	682b      	ldr	r3, [r5, #0]
   2996e:	4642      	mov	r2, r8
   29970:	695b      	ldr	r3, [r3, #20]
   29972:	4639      	mov	r1, r7
   29974:	4630      	mov	r0, r6
   29976:	4798      	blx	r3
	if (ret < 0) {
   29978:	2800      	cmp	r0, #0
   2997a:	dbc8      	blt.n	2990e <mqtt_client_tls_connect+0x6e>
	return 0;
   2997c:	2000      	movs	r0, #0
   2997e:	e7bc      	b.n	298fa <mqtt_client_tls_connect+0x5a>
	if (tls_config->cipher_list != NULL && tls_config->cipher_count > 0) {
   29980:	6b23      	ldr	r3, [r4, #48]	; 0x30
   29982:	2b00      	cmp	r3, #0
   29984:	d0ca      	beq.n	2991c <mqtt_client_tls_connect+0x7c>
		ret = setsockopt(client->transport.tls.sock, SOL_TLS,
   29986:	009b      	lsls	r3, r3, #2
   29988:	2103      	movs	r1, #3
   2998a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   2998c:	f7ff ff50 	bl	29830 <setsockopt.constprop.1>
		if (ret < 0) {
   29990:	2800      	cmp	r0, #0
   29992:	dac3      	bge.n	2991c <mqtt_client_tls_connect+0x7c>
   29994:	e7bb      	b.n	2990e <mqtt_client_tls_connect+0x6e>
	if (tls_config->sec_tag_list != NULL && tls_config->sec_tag_count > 0) {
   29996:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   29998:	2b00      	cmp	r3, #0
   2999a:	d0c2      	beq.n	29922 <mqtt_client_tls_connect+0x82>
		ret = setsockopt(client->transport.tls.sock, SOL_TLS,
   2999c:	009b      	lsls	r3, r3, #2
   2999e:	2101      	movs	r1, #1
   299a0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   299a2:	f7ff ff45 	bl	29830 <setsockopt.constprop.1>
		if (ret < 0) {
   299a6:	2800      	cmp	r0, #0
   299a8:	dabb      	bge.n	29922 <mqtt_client_tls_connect+0x82>
   299aa:	e7b0      	b.n	2990e <mqtt_client_tls_connect+0x6e>
		ret = setsockopt(client->transport.tls.sock, SOL_TLS,
   299ac:	4630      	mov	r0, r6
   299ae:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
   299b2:	f7f3 fbd1 	bl	1d158 <strlen>
   299b6:	4632      	mov	r2, r6
   299b8:	4603      	mov	r3, r0
   299ba:	2102      	movs	r1, #2
   299bc:	4640      	mov	r0, r8
   299be:	f7ff ff37 	bl	29830 <setsockopt.constprop.1>
		if (ret < 0) {
   299c2:	2800      	cmp	r0, #0
   299c4:	dab0      	bge.n	29928 <mqtt_client_tls_connect+0x88>
   299c6:	e7a2      	b.n	2990e <mqtt_client_tls_connect+0x6e>
   299c8:	20024aec 	.word	0x20024aec
   299cc:	000411aa 	.word	0x000411aa
   299d0:	00040606 	.word	0x00040606
   299d4:	0004117a 	.word	0x0004117a
   299d8:	000427c0 	.word	0x000427c0
   299dc:	000427d3 	.word	0x000427d3

000299e0 <mqtt_client_tls_write>:

int mqtt_client_tls_write(struct mqtt_client *client, const u8_t *data,
			  u32_t datalen)
{
   299e0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   299e4:	4680      	mov	r8, r0
   299e6:	4689      	mov	r9, r1
   299e8:	4617      	mov	r7, r2
	u32_t offset = 0U;
   299ea:	2400      	movs	r4, #0
	__ASSERT_NO_MSG(socket_ops);
   299ec:	4d1d      	ldr	r5, [pc, #116]	; (29a64 <mqtt_client_tls_write+0x84>)
	int ret;

	while (offset < datalen) {
   299ee:	42bc      	cmp	r4, r7
   299f0:	d301      	bcc.n	299f6 <mqtt_client_tls_write+0x16>
		}

		offset += ret;
	}

	return 0;
   299f2:	2000      	movs	r0, #0
   299f4:	e031      	b.n	29a5a <mqtt_client_tls_write+0x7a>
		ret = send(client->transport.tls.sock, data + offset,
   299f6:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
   299fa:	eb09 0a04 	add.w	sl, r9, r4
   299fe:	461e      	mov	r6, r3
   29a00:	4b19      	ldr	r3, [pc, #100]	; (29a68 <mqtt_client_tls_write+0x88>)
   29a02:	eba7 0b04 	sub.w	fp, r7, r4
   29a06:	681b      	ldr	r3, [r3, #0]
   29a08:	b94b      	cbnz	r3, 29a1e <mqtt_client_tls_write+0x3e>
   29a0a:	4918      	ldr	r1, [pc, #96]	; (29a6c <mqtt_client_tls_write+0x8c>)
   29a0c:	4818      	ldr	r0, [pc, #96]	; (29a70 <mqtt_client_tls_write+0x90>)
   29a0e:	237e      	movs	r3, #126	; 0x7e
   29a10:	462a      	mov	r2, r5
   29a12:	f012 fe8b 	bl	3c72c <printk>
   29a16:	217e      	movs	r1, #126	; 0x7e
   29a18:	4628      	mov	r0, r5
   29a1a:	f012 fecd 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->send);
   29a1e:	4b12      	ldr	r3, [pc, #72]	; (29a68 <mqtt_client_tls_write+0x88>)
   29a20:	681b      	ldr	r3, [r3, #0]
   29a22:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   29a24:	b94b      	cbnz	r3, 29a3a <mqtt_client_tls_write+0x5a>
   29a26:	4913      	ldr	r1, [pc, #76]	; (29a74 <mqtt_client_tls_write+0x94>)
   29a28:	4811      	ldr	r0, [pc, #68]	; (29a70 <mqtt_client_tls_write+0x90>)
   29a2a:	237f      	movs	r3, #127	; 0x7f
   29a2c:	462a      	mov	r2, r5
   29a2e:	f012 fe7d 	bl	3c72c <printk>
   29a32:	217f      	movs	r1, #127	; 0x7f
   29a34:	4628      	mov	r0, r5
   29a36:	f012 febf 	bl	3c7b8 <assert_post_action>
	return socket_ops->send(sock, buf, len, flags);
   29a3a:	4b0b      	ldr	r3, [pc, #44]	; (29a68 <mqtt_client_tls_write+0x88>)
   29a3c:	4630      	mov	r0, r6
   29a3e:	681b      	ldr	r3, [r3, #0]
   29a40:	465a      	mov	r2, fp
   29a42:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   29a44:	4651      	mov	r1, sl
   29a46:	469c      	mov	ip, r3
   29a48:	2300      	movs	r3, #0
   29a4a:	4666      	mov	r6, ip
   29a4c:	47b0      	blx	r6
		if (ret < 0) {
   29a4e:	2800      	cmp	r0, #0
   29a50:	da05      	bge.n	29a5e <mqtt_client_tls_write+0x7e>
			return -errno;
   29a52:	f013 f866 	bl	3cb22 <__errno>
   29a56:	6800      	ldr	r0, [r0, #0]
   29a58:	4240      	negs	r0, r0
}
   29a5a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		offset += ret;
   29a5e:	4404      	add	r4, r0
   29a60:	e7c5      	b.n	299ee <mqtt_client_tls_write+0xe>
   29a62:	bf00      	nop
   29a64:	0004117a 	.word	0x0004117a
   29a68:	20024aec 	.word	0x20024aec
   29a6c:	000411aa 	.word	0x000411aa
   29a70:	00040606 	.word	0x00040606
   29a74:	000427f8 	.word	0x000427f8

00029a78 <mqtt_client_tls_read>:

int mqtt_client_tls_read(struct mqtt_client *client, u8_t *data, u32_t buflen,
			 bool shall_block)
{
   29a78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(socket_ops);
   29a7c:	4c18      	ldr	r4, [pc, #96]	; (29ae0 <mqtt_client_tls_read+0x68>)
	int flags = 0;
	int ret;

	if (!shall_block) {
		flags |= MSG_DONTWAIT;
   29a7e:	2b00      	cmp	r3, #0
   29a80:	6823      	ldr	r3, [r4, #0]
{
   29a82:	460e      	mov	r6, r1
   29a84:	4617      	mov	r7, r2
		flags |= MSG_DONTWAIT;
   29a86:	bf14      	ite	ne
   29a88:	f04f 0800 	movne.w	r8, #0
   29a8c:	f04f 0840 	moveq.w	r8, #64	; 0x40
	}

	ret = recv(client->transport.tls.sock, data, buflen, flags);
   29a90:	6a85      	ldr	r5, [r0, #40]	; 0x28
   29a92:	b94b      	cbnz	r3, 29aa8 <mqtt_client_tls_read+0x30>
   29a94:	4913      	ldr	r1, [pc, #76]	; (29ae4 <mqtt_client_tls_read+0x6c>)
   29a96:	4814      	ldr	r0, [pc, #80]	; (29ae8 <mqtt_client_tls_read+0x70>)
   29a98:	2369      	movs	r3, #105	; 0x69
   29a9a:	4a14      	ldr	r2, [pc, #80]	; (29aec <mqtt_client_tls_read+0x74>)
   29a9c:	f012 fe46 	bl	3c72c <printk>
   29aa0:	2169      	movs	r1, #105	; 0x69
   29aa2:	4812      	ldr	r0, [pc, #72]	; (29aec <mqtt_client_tls_read+0x74>)
   29aa4:	f012 fe88 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->recv);
   29aa8:	6823      	ldr	r3, [r4, #0]
   29aaa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   29aac:	b94b      	cbnz	r3, 29ac2 <mqtt_client_tls_read+0x4a>
   29aae:	4910      	ldr	r1, [pc, #64]	; (29af0 <mqtt_client_tls_read+0x78>)
   29ab0:	480d      	ldr	r0, [pc, #52]	; (29ae8 <mqtt_client_tls_read+0x70>)
   29ab2:	236a      	movs	r3, #106	; 0x6a
   29ab4:	4a0d      	ldr	r2, [pc, #52]	; (29aec <mqtt_client_tls_read+0x74>)
   29ab6:	f012 fe39 	bl	3c72c <printk>
   29aba:	216a      	movs	r1, #106	; 0x6a
   29abc:	480b      	ldr	r0, [pc, #44]	; (29aec <mqtt_client_tls_read+0x74>)
   29abe:	f012 fe7b 	bl	3c7b8 <assert_post_action>
	return socket_ops->recv(sock, buf, max_len, flags);
   29ac2:	6823      	ldr	r3, [r4, #0]
   29ac4:	463a      	mov	r2, r7
   29ac6:	6a5c      	ldr	r4, [r3, #36]	; 0x24
   29ac8:	4631      	mov	r1, r6
   29aca:	4643      	mov	r3, r8
   29acc:	4628      	mov	r0, r5
   29ace:	47a0      	blx	r4
	if (ret < 0) {
   29ad0:	2800      	cmp	r0, #0
   29ad2:	da03      	bge.n	29adc <mqtt_client_tls_read+0x64>
		return -errno;
   29ad4:	f013 f825 	bl	3cb22 <__errno>
   29ad8:	6800      	ldr	r0, [r0, #0]
   29ada:	4240      	negs	r0, r0
	}

	return ret;
}
   29adc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   29ae0:	20024aec 	.word	0x20024aec
   29ae4:	000411aa 	.word	0x000411aa
   29ae8:	00040606 	.word	0x00040606
   29aec:	0004117a 	.word	0x0004117a
   29af0:	000427e7 	.word	0x000427e7

00029af4 <z_impl_entropy_get_entropy>:
				  u16_t length);

static inline int z_impl_entropy_get_entropy(struct device *dev,
					    u8_t *buffer,
					    u16_t length)
{
   29af4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct entropy_driver_api *api =
   29af8:	6845      	ldr	r5, [r0, #4]
{
   29afa:	4604      	mov	r4, r0
		(const struct entropy_driver_api *)dev->driver_api;

	__ASSERT(api->get_entropy != NULL,
   29afc:	682b      	ldr	r3, [r5, #0]
{
   29afe:	460e      	mov	r6, r1
   29b00:	4617      	mov	r7, r2
	__ASSERT(api->get_entropy != NULL,
   29b02:	b963      	cbnz	r3, 29b1e <z_impl_entropy_get_entropy+0x2a>
   29b04:	4909      	ldr	r1, [pc, #36]	; (29b2c <z_impl_entropy_get_entropy+0x38>)
   29b06:	234c      	movs	r3, #76	; 0x4c
   29b08:	4a09      	ldr	r2, [pc, #36]	; (29b30 <z_impl_entropy_get_entropy+0x3c>)
   29b0a:	480a      	ldr	r0, [pc, #40]	; (29b34 <z_impl_entropy_get_entropy+0x40>)
   29b0c:	f012 fe0e 	bl	3c72c <printk>
   29b10:	4809      	ldr	r0, [pc, #36]	; (29b38 <z_impl_entropy_get_entropy+0x44>)
   29b12:	f012 fe0b 	bl	3c72c <printk>
   29b16:	214c      	movs	r1, #76	; 0x4c
   29b18:	4805      	ldr	r0, [pc, #20]	; (29b30 <z_impl_entropy_get_entropy+0x3c>)
   29b1a:	f012 fe4d 	bl	3c7b8 <assert_post_action>
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
   29b1e:	682b      	ldr	r3, [r5, #0]
   29b20:	463a      	mov	r2, r7
   29b22:	4631      	mov	r1, r6
   29b24:	4620      	mov	r0, r4
}
   29b26:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return api->get_entropy(dev, buffer, length);
   29b2a:	4718      	bx	r3
   29b2c:	00042979 	.word	0x00042979
   29b30:	0004294c 	.word	0x0004294c
   29b34:	00040606 	.word	0x00040606
   29b38:	00042999 	.word	0x00042999

00029b3c <sys_rand32_get>:

static struct device *entropy_driver;

#if defined(CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR)
u32_t sys_rand32_get(void)
{
   29b3c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct device *dev = entropy_driver;
   29b3e:	4d12      	ldr	r5, [pc, #72]	; (29b88 <sys_rand32_get+0x4c>)
   29b40:	682c      	ldr	r4, [r5, #0]
	u32_t random_num;
	int ret;

	if (unlikely(!dev)) {
   29b42:	b99c      	cbnz	r4, 29b6c <sys_rand32_get+0x30>
   29b44:	4811      	ldr	r0, [pc, #68]	; (29b8c <sys_rand32_get+0x50>)
   29b46:	f00b fd6b 	bl	35620 <z_impl_device_get_binding>
		/* Only one entropy device exists, so this is safe even
		 * if the whole operation isn't atomic.
		 */
		dev = device_get_binding(CONFIG_ENTROPY_NAME);
		__ASSERT((dev != NULL),
   29b4a:	4604      	mov	r4, r0
   29b4c:	b968      	cbnz	r0, 29b6a <sys_rand32_get+0x2e>
   29b4e:	231d      	movs	r3, #29
   29b50:	4a0f      	ldr	r2, [pc, #60]	; (29b90 <sys_rand32_get+0x54>)
   29b52:	4910      	ldr	r1, [pc, #64]	; (29b94 <sys_rand32_get+0x58>)
   29b54:	4810      	ldr	r0, [pc, #64]	; (29b98 <sys_rand32_get+0x5c>)
   29b56:	f012 fde9 	bl	3c72c <printk>
   29b5a:	490c      	ldr	r1, [pc, #48]	; (29b8c <sys_rand32_get+0x50>)
   29b5c:	480f      	ldr	r0, [pc, #60]	; (29b9c <sys_rand32_get+0x60>)
   29b5e:	f012 fde5 	bl	3c72c <printk>
   29b62:	211d      	movs	r1, #29
   29b64:	480a      	ldr	r0, [pc, #40]	; (29b90 <sys_rand32_get+0x54>)
   29b66:	f012 fe27 	bl	3c7b8 <assert_post_action>
			"Device driver for %s (CONFIG_ENTROPY_NAME) not found. "
			"Check your build configuration!",
			CONFIG_ENTROPY_NAME);
		entropy_driver = dev;
   29b6a:	602c      	str	r4, [r5, #0]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&buffer, *(uintptr_t *)&length, K_SYSCALL_ENTROPY_GET_ENTROPY);
	}
#endif
	compiler_barrier();
	return z_impl_entropy_get_entropy(dev, buffer, length);
   29b6c:	2204      	movs	r2, #4
   29b6e:	4620      	mov	r0, r4
   29b70:	eb0d 0102 	add.w	r1, sp, r2
   29b74:	f7ff ffbe 	bl	29af4 <z_impl_entropy_get_entropy>
	}

	ret = entropy_get_entropy(dev, (u8_t *)&random_num,
				  sizeof(random_num));
	if (unlikely(ret < 0)) {
   29b78:	2800      	cmp	r0, #0
   29b7a:	da02      	bge.n	29b82 <sys_rand32_get+0x46>
#ifndef _ASMLANGUAGE
extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
   29b7c:	f7fe f92e 	bl	27ddc <z_timer_cycle_get_32>
		 * 32-bit of data.  There's not much that can be done in this
		 * situation.  An __ASSERT() isn't used here as the HWRNG might
		 * still be gathering entropy during early boot situations.
		 */

		random_num = k_cycle_get_32();
   29b80:	9001      	str	r0, [sp, #4]
	}

	return random_num;
}
   29b82:	9801      	ldr	r0, [sp, #4]
   29b84:	b003      	add	sp, #12
   29b86:	bd30      	pop	{r4, r5, pc}
   29b88:	20024bd0 	.word	0x20024bd0
   29b8c:	0004289c 	.word	0x0004289c
   29b90:	000428a6 	.word	0x000428a6
   29b94:	000428df 	.word	0x000428df
   29b98:	00040606 	.word	0x00040606
   29b9c:	000428f4 	.word	0x000428f4

00029ba0 <gpio_nrfx_manage_callback>:
}

static int gpio_nrfx_manage_callback(struct device *port,
				     struct gpio_callback *callback,
				     bool set)
{
   29ba0:	b570      	push	{r4, r5, r6, lr}
   29ba2:	4616      	mov	r6, r2
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   29ba4:	6884      	ldr	r4, [r0, #8]
 */
static inline int gpio_manage_callback(sys_slist_t *callbacks,
					struct gpio_callback *callback,
					bool set)
{
	__ASSERT(callback, "No callback!");
   29ba6:	460d      	mov	r5, r1
   29ba8:	b961      	cbnz	r1, 29bc4 <gpio_nrfx_manage_callback+0x24>
   29baa:	4922      	ldr	r1, [pc, #136]	; (29c34 <gpio_nrfx_manage_callback+0x94>)
   29bac:	231c      	movs	r3, #28
   29bae:	4a22      	ldr	r2, [pc, #136]	; (29c38 <gpio_nrfx_manage_callback+0x98>)
   29bb0:	4822      	ldr	r0, [pc, #136]	; (29c3c <gpio_nrfx_manage_callback+0x9c>)
   29bb2:	f012 fdbb 	bl	3c72c <printk>
   29bb6:	4822      	ldr	r0, [pc, #136]	; (29c40 <gpio_nrfx_manage_callback+0xa0>)
   29bb8:	f012 fdb8 	bl	3c72c <printk>
   29bbc:	211c      	movs	r1, #28
   29bbe:	481e      	ldr	r0, [pc, #120]	; (29c38 <gpio_nrfx_manage_callback+0x98>)
   29bc0:	f012 fdfa 	bl	3c7b8 <assert_post_action>
	__ASSERT(callback->handler, "No callback handler!");
   29bc4:	686b      	ldr	r3, [r5, #4]
   29bc6:	b963      	cbnz	r3, 29be2 <gpio_nrfx_manage_callback+0x42>
   29bc8:	491e      	ldr	r1, [pc, #120]	; (29c44 <gpio_nrfx_manage_callback+0xa4>)
   29bca:	231d      	movs	r3, #29
   29bcc:	4a1a      	ldr	r2, [pc, #104]	; (29c38 <gpio_nrfx_manage_callback+0x98>)
   29bce:	481b      	ldr	r0, [pc, #108]	; (29c3c <gpio_nrfx_manage_callback+0x9c>)
   29bd0:	f012 fdac 	bl	3c72c <printk>
   29bd4:	481c      	ldr	r0, [pc, #112]	; (29c48 <gpio_nrfx_manage_callback+0xa8>)
   29bd6:	f012 fda9 	bl	3c72c <printk>
   29bda:	211d      	movs	r1, #29
   29bdc:	4816      	ldr	r0, [pc, #88]	; (29c38 <gpio_nrfx_manage_callback+0x98>)
   29bde:	f012 fdeb 	bl	3c7b8 <assert_post_action>
Z_GENLIST_IS_EMPTY(slist)
   29be2:	6823      	ldr	r3, [r4, #0]

	if (!sys_slist_is_empty(callbacks)) {
   29be4:	b15b      	cbz	r3, 29bfe <gpio_nrfx_manage_callback+0x5e>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   29be6:	2200      	movs	r2, #0
   29be8:	429d      	cmp	r5, r3
   29bea:	d113      	bne.n	29c14 <gpio_nrfx_manage_callback+0x74>
Z_GENLIST_REMOVE(slist, snode)
   29bec:	682b      	ldr	r3, [r5, #0]
   29bee:	b95a      	cbnz	r2, 29c08 <gpio_nrfx_manage_callback+0x68>
   29bf0:	6862      	ldr	r2, [r4, #4]
	list->head = node;
   29bf2:	6023      	str	r3, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   29bf4:	4295      	cmp	r5, r2
   29bf6:	d100      	bne.n	29bfa <gpio_nrfx_manage_callback+0x5a>
	list->tail = node;
   29bf8:	6063      	str	r3, [r4, #4]
	parent->next = child;
   29bfa:	2300      	movs	r3, #0
   29bfc:	602b      	str	r3, [r5, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
   29bfe:	b976      	cbnz	r6, 29c1e <gpio_nrfx_manage_callback+0x7e>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
   29c00:	2000      	movs	r0, #0
				     callback, set);
}
   29c02:	bd70      	pop	{r4, r5, r6, pc}
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   29c04:	460b      	mov	r3, r1
   29c06:	e7ef      	b.n	29be8 <gpio_nrfx_manage_callback+0x48>
	parent->next = child;
   29c08:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   29c0a:	6863      	ldr	r3, [r4, #4]
   29c0c:	429d      	cmp	r5, r3
	list->tail = node;
   29c0e:	bf08      	it	eq
   29c10:	6062      	streq	r2, [r4, #4]
   29c12:	e7f2      	b.n	29bfa <gpio_nrfx_manage_callback+0x5a>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   29c14:	6819      	ldr	r1, [r3, #0]
	return node->next;
   29c16:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   29c18:	2900      	cmp	r1, #0
   29c1a:	d1f3      	bne.n	29c04 <gpio_nrfx_manage_callback+0x64>
			if (!set) {
   29c1c:	b13e      	cbz	r6, 29c2e <gpio_nrfx_manage_callback+0x8e>
Z_GENLIST_PREPEND(slist, snode)
   29c1e:	6823      	ldr	r3, [r4, #0]
	parent->next = child;
   29c20:	602b      	str	r3, [r5, #0]
Z_GENLIST_PREPEND(slist, snode)
   29c22:	6860      	ldr	r0, [r4, #4]
	list->head = node;
   29c24:	6025      	str	r5, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
   29c26:	2800      	cmp	r0, #0
   29c28:	d1ea      	bne.n	29c00 <gpio_nrfx_manage_callback+0x60>
	list->tail = node;
   29c2a:	6065      	str	r5, [r4, #4]
   29c2c:	e7e9      	b.n	29c02 <gpio_nrfx_manage_callback+0x62>
				return -EINVAL;
   29c2e:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   29c32:	e7e6      	b.n	29c02 <gpio_nrfx_manage_callback+0x62>
   29c34:	0004075a 	.word	0x0004075a
   29c38:	000429d8 	.word	0x000429d8
   29c3c:	00040606 	.word	0x00040606
   29c40:	00042a05 	.word	0x00042a05
   29c44:	00042a14 	.word	0x00042a14
   29c48:	00042a26 	.word	0x00042a26

00029c4c <nrf_gpio_pin_port_decode.isra.8.part.9>:
 *
 * @param[in,out] p_pin Pointer to the absolute pin number overriden by the pin number that is relative to the port.
 *
 * @return Pointer to port register set.
 */
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   29c4c:	b508      	push	{r3, lr}
{
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   29c4e:	4a03      	ldr	r2, [pc, #12]	; (29c5c <nrf_gpio_pin_port_decode.isra.8.part.9+0x10>)
   29c50:	4b03      	ldr	r3, [pc, #12]	; (29c60 <nrf_gpio_pin_port_decode.isra.8.part.9+0x14>)
   29c52:	f240 11ff 	movw	r1, #511	; 0x1ff
   29c56:	4803      	ldr	r0, [pc, #12]	; (29c64 <nrf_gpio_pin_port_decode.isra.8.part.9+0x18>)
   29c58:	f00f fa9a 	bl	39190 <__assert_func>
   29c5c:	000429bf 	.word	0x000429bf
   29c60:	00042a69 	.word	0x00042a69
   29c64:	00042a77 	.word	0x00042a77

00029c68 <nrf_gpio_cfg_sense_set>:
   29c68:	281f      	cmp	r0, #31
}


NRF_STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t             pin_number,
                                              nrf_gpio_pin_sense_t sense_config)
{
   29c6a:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   29c6c:	d901      	bls.n	29c72 <nrf_gpio_cfg_sense_set+0xa>
   29c6e:	f7ff ffed 	bl	29c4c <nrf_gpio_pin_port_decode.isra.8.part.9>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
   29c72:	4a06      	ldr	r2, [pc, #24]	; (29c8c <nrf_gpio_cfg_sense_set+0x24>)
   29c74:	eb02 0080 	add.w	r0, r2, r0, lsl #2
   29c78:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
   29c7c:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000

    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   29c80:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   29c84:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
}
   29c88:	bd08      	pop	{r3, pc}
   29c8a:	bf00      	nop
   29c8c:	40842500 	.word	0x40842500

00029c90 <gpio_nrfx_init>:
#endif
	}
}

static int gpio_nrfx_init(struct device *port)
{
   29c90:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
   29c92:	4b09      	ldr	r3, [pc, #36]	; (29cb8 <gpio_nrfx_init+0x28>)
   29c94:	781a      	ldrb	r2, [r3, #0]
   29c96:	b96a      	cbnz	r2, 29cb4 <gpio_nrfx_init+0x24>
		gpio_initialized = true;
   29c98:	2101      	movs	r1, #1
		IRQ_CONNECT(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0,
   29c9a:	2031      	movs	r0, #49	; 0x31
		gpio_initialized = true;
   29c9c:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0,
   29c9e:	2105      	movs	r1, #5
   29ca0:	f7fe fa58 	bl	28154 <z_arm_irq_priority_set>
			    DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0_PRIORITY,
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0);
   29ca4:	2031      	movs	r0, #49	; 0x31
   29ca6:	f7fe fa45 	bl	28134 <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   29caa:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   29cae:	4b03      	ldr	r3, [pc, #12]	; (29cbc <gpio_nrfx_init+0x2c>)
   29cb0:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
   29cb4:	2000      	movs	r0, #0
   29cb6:	bd08      	pop	{r3, pc}
   29cb8:	2002c7c5 	.word	0x2002c7c5
   29cbc:	40031000 	.word	0x40031000

00029cc0 <gpiote_pin_int_cfg>:
{
   29cc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return port->config->config_info;
   29cc4:	6803      	ldr	r3, [r0, #0]
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   29cc6:	f001 041f 	and.w	r4, r1, #31
   29cca:	689b      	ldr	r3, [r3, #8]
{
   29ccc:	460d      	mov	r5, r1
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   29cce:	791b      	ldrb	r3, [r3, #4]
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
   29cd0:	4e4b      	ldr	r6, [pc, #300]	; (29e00 <gpiote_pin_int_cfg+0x140>)
   29cd2:	ea44 1443 	orr.w	r4, r4, r3, lsl #5
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   29cd6:	2300      	movs	r3, #0
   29cd8:	f8d6 2304 	ldr.w	r2, [r6, #772]	; 0x304
	struct gpio_nrfx_data *data = get_port_data(port);
   29cdc:	6887      	ldr	r7, [r0, #8]
   29cde:	b2d2      	uxtb	r2, r2
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   29ce0:	f503 71a2 	add.w	r1, r3, #324	; 0x144
   29ce4:	f856 1021 	ldr.w	r1, [r6, r1, lsl #2]
   29ce8:	f3c1 2104 	ubfx	r1, r1, #8, #5
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
   29cec:	428c      	cmp	r4, r1
   29cee:	d16c      	bne.n	29dca <gpiote_pin_int_cfg+0x10a>
		    && (intenset & BIT(i))) {
   29cf0:	fa22 f103 	lsr.w	r1, r2, r3
   29cf4:	07c9      	lsls	r1, r1, #31
   29cf6:	d568      	bpl.n	29dca <gpiote_pin_int_cfg+0x10a>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
   29cf8:	009a      	lsls	r2, r3, #2
   29cfa:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   29cfe:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   29d02:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
   29d06:	f021 0101 	bic.w	r1, r1, #1
   29d0a:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
   29d0e:	2201      	movs	r2, #1
   29d10:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENCLR = mask;
   29d14:	f8c6 3308 	str.w	r3, [r6, #776]	; 0x308
	nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   29d18:	4620      	mov	r0, r4
   29d1a:	2100      	movs	r1, #0
   29d1c:	f7ff ffa4 	bl	29c68 <nrf_gpio_cfg_sense_set>
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
   29d20:	68b8      	ldr	r0, [r7, #8]
   29d22:	40e8      	lsrs	r0, r5
   29d24:	f010 0001 	ands.w	r0, r0, #1
   29d28:	d04d      	beq.n	29dc6 <gpiote_pin_int_cfg+0x106>
   29d2a:	68f8      	ldr	r0, [r7, #12]
   29d2c:	40e8      	lsrs	r0, r5
   29d2e:	f010 0001 	ands.w	r0, r0, #1
   29d32:	d048      	beq.n	29dc6 <gpiote_pin_int_cfg+0x106>
		if (data->trig_edge & BIT(pin)) {
   29d34:	6978      	ldr	r0, [r7, #20]
   29d36:	40e8      	lsrs	r0, r5
   29d38:	f010 0801 	ands.w	r8, r0, #1
   29d3c:	d051      	beq.n	29de2 <gpiote_pin_int_cfg+0x122>
			if (data->double_edge & BIT(pin)) {
   29d3e:	69bb      	ldr	r3, [r7, #24]
   29d40:	40eb      	lsrs	r3, r5
   29d42:	07db      	lsls	r3, r3, #31
   29d44:	d445      	bmi.n	29dd2 <gpiote_pin_int_cfg+0x112>
			} else if (((data->active_level & BIT(pin)) != 0U)
   29d46:	693b      	ldr	r3, [r7, #16]
				   ^ ((BIT(pin) & data->inverted) != 0)) {
   29d48:	69fa      	ldr	r2, [r7, #28]
			} else if (((data->active_level & BIT(pin)) != 0U)
   29d4a:	40eb      	lsrs	r3, r5
				   ^ ((BIT(pin) & data->inverted) != 0)) {
   29d4c:	fa22 f505 	lsr.w	r5, r2, r5
			} else if (((data->active_level & BIT(pin)) != 0U)
   29d50:	f003 0301 	and.w	r3, r3, #1
   29d54:	f005 0501 	and.w	r5, r5, #1
				pol = NRF_GPIOTE_POLARITY_HITOLO;
   29d58:	42ab      	cmp	r3, r5
   29d5a:	bf14      	ite	ne
   29d5c:	2501      	movne	r5, #1
   29d5e:	2502      	moveq	r5, #2
   29d60:	2100      	movs	r1, #0
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
   29d62:	f501 73a2 	add.w	r3, r1, #324	; 0x144
   29d66:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
   29d6a:	f010 0003 	ands.w	r0, r0, #3
   29d6e:	d132      	bne.n	29dd6 <gpiote_pin_int_cfg+0x116>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   29d70:	008b      	lsls	r3, r1, #2
   29d72:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   29d76:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   29d7a:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   29d7e:	0224      	lsls	r4, r4, #8
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   29d80:	f422 3247 	bic.w	r2, r2, #203776	; 0x31c00
   29d84:	f422 7240 	bic.w	r2, r2, #768	; 0x300
   29d88:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   29d8c:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   29d90:	f404 54f8 	and.w	r4, r4, #7936	; 0x1f00
   29d94:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
   29d98:	4315      	orrs	r5, r2
			nrf_gpiote_event_t evt =
   29d9a:	f101 0240 	add.w	r2, r1, #64	; 0x40
   29d9e:	0092      	lsls	r2, r2, #2
    return ((uint32_t)p_reg + event);
   29da0:	b292      	uxth	r2, r2
   29da2:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   29da6:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   29daa:	f8c3 5510 	str.w	r5, [r3, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   29dae:	6010      	str	r0, [r2, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   29db0:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   29db4:	f042 0201 	orr.w	r2, r2, #1
   29db8:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
   29dbc:	2301      	movs	r3, #1
   29dbe:	fa03 f101 	lsl.w	r1, r3, r1
    p_reg->INTENSET = mask;
   29dc2:	f8c6 1304 	str.w	r1, [r6, #772]	; 0x304
}
   29dc6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   29dca:	3301      	adds	r3, #1
   29dcc:	2b08      	cmp	r3, #8
   29dce:	d187      	bne.n	29ce0 <gpiote_pin_int_cfg+0x20>
   29dd0:	e7a2      	b.n	29d18 <gpiote_pin_int_cfg+0x58>
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
   29dd2:	2503      	movs	r5, #3
   29dd4:	e7c4      	b.n	29d60 <gpiote_pin_int_cfg+0xa0>
   29dd6:	3101      	adds	r1, #1
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
   29dd8:	2908      	cmp	r1, #8
   29dda:	d1c2      	bne.n	29d62 <gpiote_pin_int_cfg+0xa2>
	return -ENODEV;
   29ddc:	f06f 0012 	mvn.w	r0, #18
   29de0:	e7f1      	b.n	29dc6 <gpiote_pin_int_cfg+0x106>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   29de2:	693b      	ldr	r3, [r7, #16]
   29de4:	69fa      	ldr	r2, [r7, #28]
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   29de6:	4620      	mov	r0, r4
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   29de8:	4053      	eors	r3, r2
   29dea:	fa23 f505 	lsr.w	r5, r3, r5
		return NRF_GPIO_PIN_SENSE_HIGH;
   29dee:	f015 0f01 	tst.w	r5, #1
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   29df2:	bf0c      	ite	eq
   29df4:	2103      	moveq	r1, #3
   29df6:	2102      	movne	r1, #2
   29df8:	f7ff ff36 	bl	29c68 <nrf_gpio_cfg_sense_set>
	int res = 0;
   29dfc:	4640      	mov	r0, r8
   29dfe:	e7e2      	b.n	29dc6 <gpiote_pin_int_cfg+0x106>
   29e00:	40031000 	.word	0x40031000

00029e04 <gpio_nrfx_config>:
{
   29e04:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   29e08:	4680      	mov	r8, r0
	struct gpio_nrfx_data *data = get_port_data(port);
   29e0a:	6885      	ldr	r5, [r0, #8]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   29e0c:	f403 4070 	and.w	r0, r3, #61440	; 0xf000
   29e10:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
{
   29e14:	461e      	mov	r6, r3
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   29e16:	d040      	beq.n	29e9a <gpio_nrfx_config+0x96>
   29e18:	dc09      	bgt.n	29e2e <gpio_nrfx_config+0x2a>
   29e1a:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   29e1e:	d03e      	beq.n	29e9e <gpio_nrfx_config+0x9a>
   29e20:	f5b0 5f40 	cmp.w	r0, #12288	; 0x3000
   29e24:	d03d      	beq.n	29ea2 <gpio_nrfx_config+0x9e>
   29e26:	b190      	cbz	r0, 29e4e <gpio_nrfx_config+0x4a>
		return -EINVAL;
   29e28:	f06f 0015 	mvn.w	r0, #21
   29e2c:	e032      	b.n	29e94 <gpio_nrfx_config+0x90>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   29e2e:	f5b0 4fe0 	cmp.w	r0, #28672	; 0x7000
   29e32:	d038      	beq.n	29ea6 <gpio_nrfx_config+0xa2>
   29e34:	dc04      	bgt.n	29e40 <gpio_nrfx_config+0x3c>
   29e36:	f5b0 4fa0 	cmp.w	r0, #20480	; 0x5000
   29e3a:	d1f5      	bne.n	29e28 <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0H1;
   29e3c:	2003      	movs	r0, #3
   29e3e:	e006      	b.n	29e4e <gpio_nrfx_config+0x4a>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   29e40:	f5b0 4f40 	cmp.w	r0, #49152	; 0xc000
   29e44:	d031      	beq.n	29eaa <gpio_nrfx_config+0xa6>
   29e46:	f5b0 4f50 	cmp.w	r0, #53248	; 0xd000
   29e4a:	d1ed      	bne.n	29e28 <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0D1;
   29e4c:	2007      	movs	r0, #7
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
   29e4e:	f406 7740 	and.w	r7, r6, #768	; 0x300
   29e52:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
   29e56:	d02a      	beq.n	29eae <gpio_nrfx_config+0xaa>
		pull = NRF_GPIO_PIN_NOPULL;
   29e58:	f5a7 7400 	sub.w	r4, r7, #512	; 0x200
   29e5c:	4263      	negs	r3, r4
   29e5e:	4163      	adcs	r3, r4
	if (access_op == GPIO_ACCESS_BY_PORT) {
   29e60:	2901      	cmp	r1, #1
		from_pin = pin;
   29e62:	bf19      	ittee	ne
   29e64:	b2d4      	uxtbne	r4, r2
		to_pin   = pin;
   29e66:	46a1      	movne	r9, r4
		to_pin   = 31U;
   29e68:	f04f 091f 	moveq.w	r9, #31
		from_pin = 0U;
   29e6c:	2400      	moveq	r4, #0
   29e6e:	f04f 0b01 	mov.w	fp, #1
	dir = ((flags & GPIO_DIR_MASK) == GPIO_DIR_OUT)
   29e72:	f006 0c01 	and.w	ip, r6, #1
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
   29e76:	ea4f 074c 	mov.w	r7, ip, lsl #1
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   29e7a:	ea47 070c 	orr.w	r7, r7, ip
   29e7e:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   29e82:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 29f2c <gpio_nrfx_config+0x128>
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   29e86:	ea40 0783 	orr.w	r7, r0, r3, lsl #2
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   29e8a:	f006 0302 	and.w	r3, r6, #2
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   29e8e:	45a1      	cmp	r9, r4
   29e90:	d20f      	bcs.n	29eb2 <gpio_nrfx_config+0xae>
	return 0;
   29e92:	2000      	movs	r0, #0
}
   29e94:	b003      	add	sp, #12
   29e96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		drive = NRF_GPIO_PIN_S0H1;
   29e9a:	2002      	movs	r0, #2
   29e9c:	e7d7      	b.n	29e4e <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_H0S1;
   29e9e:	2001      	movs	r0, #1
   29ea0:	e7d5      	b.n	29e4e <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0S1;
   29ea2:	2004      	movs	r0, #4
   29ea4:	e7d3      	b.n	29e4e <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0H1;
   29ea6:	2005      	movs	r0, #5
   29ea8:	e7d1      	b.n	29e4e <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_S0D1;
   29eaa:	2006      	movs	r0, #6
   29eac:	e7cf      	b.n	29e4e <gpio_nrfx_config+0x4a>
		pull = NRF_GPIO_PIN_PULLUP;
   29eae:	2303      	movs	r3, #3
   29eb0:	e7d6      	b.n	29e60 <gpio_nrfx_config+0x5c>
	return port->config->config_info;
   29eb2:	f8d8 2000 	ldr.w	r2, [r8]
		nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num,
   29eb6:	6892      	ldr	r2, [r2, #8]
   29eb8:	7911      	ldrb	r1, [r2, #4]
   29eba:	f004 021f 	and.w	r2, r4, #31
   29ebe:	ea42 1241 	orr.w	r2, r2, r1, lsl #5
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   29ec2:	2a1f      	cmp	r2, #31
   29ec4:	dd01      	ble.n	29eca <gpio_nrfx_config+0xc6>
   29ec6:	f7ff fec1 	bl	29c4c <nrf_gpio_pin_port_decode.isra.8.part.9>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   29eca:	3280      	adds	r2, #128	; 0x80
   29ecc:	f84a 7022 	str.w	r7, [sl, r2, lsl #2]
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   29ed0:	68a9      	ldr	r1, [r5, #8]
   29ed2:	fa0b f204 	lsl.w	r2, fp, r4
   29ed6:	2b00      	cmp	r3, #0
   29ed8:	d025      	beq.n	29f26 <gpio_nrfx_config+0x122>
   29eda:	4311      	orrs	r1, r2
   29edc:	60a9      	str	r1, [r5, #8]
		WRITE_BIT(data->trig_edge, curr_pin, flags & GPIO_INT_EDGE);
   29ede:	6969      	ldr	r1, [r5, #20]
   29ee0:	06b0      	lsls	r0, r6, #26
   29ee2:	bf4c      	ite	mi
   29ee4:	4311      	orrmi	r1, r2
   29ee6:	4391      	bicpl	r1, r2
   29ee8:	6169      	str	r1, [r5, #20]
		WRITE_BIT(data->double_edge, curr_pin,
   29eea:	69a9      	ldr	r1, [r5, #24]
   29eec:	0670      	lsls	r0, r6, #25
   29eee:	bf4c      	ite	mi
   29ef0:	4311      	orrmi	r1, r2
   29ef2:	4391      	bicpl	r1, r2
   29ef4:	61a9      	str	r1, [r5, #24]
		WRITE_BIT(data->active_level, curr_pin,
   29ef6:	6929      	ldr	r1, [r5, #16]
   29ef8:	0770      	lsls	r0, r6, #29
   29efa:	bf4c      	ite	mi
   29efc:	4311      	orrmi	r1, r2
   29efe:	4391      	bicpl	r1, r2
   29f00:	6129      	str	r1, [r5, #16]
		WRITE_BIT(data->inverted, curr_pin, flags & GPIO_POL_INV);
   29f02:	69e9      	ldr	r1, [r5, #28]
   29f04:	0630      	lsls	r0, r6, #24
   29f06:	bf4c      	ite	mi
   29f08:	430a      	orrmi	r2, r1
   29f0a:	ea21 0202 	bicpl.w	r2, r1, r2
   29f0e:	61ea      	str	r2, [r5, #28]
		res = gpiote_pin_int_cfg(port, curr_pin);
   29f10:	4621      	mov	r1, r4
   29f12:	4640      	mov	r0, r8
   29f14:	9301      	str	r3, [sp, #4]
   29f16:	f7ff fed3 	bl	29cc0 <gpiote_pin_int_cfg>
		if (res != 0) {
   29f1a:	2800      	cmp	r0, #0
   29f1c:	d1ba      	bne.n	29e94 <gpio_nrfx_config+0x90>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   29f1e:	3401      	adds	r4, #1
   29f20:	b2e4      	uxtb	r4, r4
   29f22:	9b01      	ldr	r3, [sp, #4]
   29f24:	e7b3      	b.n	29e8e <gpio_nrfx_config+0x8a>
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   29f26:	ea21 0102 	bic.w	r1, r1, r2
   29f2a:	e7d7      	b.n	29edc <gpio_nrfx_config+0xd8>
   29f2c:	40842500 	.word	0x40842500

00029f30 <gpiote_event_handler>:
{
   29f30:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   29f34:	4b56      	ldr	r3, [pc, #344]	; (2a090 <gpiote_event_handler+0x160>)
   29f36:	681e      	ldr	r6, [r3, #0]
	if (port_event) {
   29f38:	4698      	mov	r8, r3
   29f3a:	2e00      	cmp	r6, #0
   29f3c:	d05e      	beq.n	29ffc <gpiote_event_handler+0xcc>
	u32_t bit = 1U << pin;
   29f3e:	2701      	movs	r7, #1
	u32_t pin = 0U;
   29f40:	f04f 0a00 	mov.w	sl, #0
	struct gpio_nrfx_data *data = get_port_data(port);
   29f44:	4a53      	ldr	r2, [pc, #332]	; (2a094 <gpiote_event_handler+0x164>)
   29f46:	6893      	ldr	r3, [r2, #8]
	return port->config->config_info;
   29f48:	6812      	ldr	r2, [r2, #0]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
   29f4a:	69dc      	ldr	r4, [r3, #28]
	return port->config->config_info;
   29f4c:	f8d2 9008 	ldr.w	r9, [r2, #8]
	u32_t out = data->int_en & data->pin_int_en;
   29f50:	e9d3 2502 	ldrd	r2, r5, [r3, #8]
   29f54:	4015      	ands	r5, r2
	out &= ~data->trig_edge & ~data->double_edge;
   29f56:	e9d3 2105 	ldrd	r2, r1, [r3, #20]
   29f5a:	430a      	orrs	r2, r1
   29f5c:	ea25 0502 	bic.w	r5, r5, r2
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
   29f60:	f8d9 2000 	ldr.w	r2, [r9]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
   29f64:	691b      	ldr	r3, [r3, #16]
}


NRF_STATIC_INLINE uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const * p_reg)
{
    return p_reg->IN;
   29f66:	6912      	ldr	r2, [r2, #16]
   29f68:	405c      	eors	r4, r3
   29f6a:	4054      	eors	r4, r2
	u32_t out = pin_states & level_pins;
   29f6c:	ea25 0404 	bic.w	r4, r5, r4
	while (level_pins) {
   29f70:	bb9d      	cbnz	r5, 29fda <gpiote_event_handler+0xaa>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   29f72:	f8c8 5000 	str.w	r5, [r8]
	u32_t fired_triggers[GPIO_COUNT] = {0};
   29f76:	2300      	movs	r3, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
   29f78:	2001      	movs	r0, #1
   29f7a:	461f      	mov	r7, r3
    return p_reg->INTENSET & mask;
   29f7c:	4946      	ldr	r1, [pc, #280]	; (2a098 <gpiote_event_handler+0x168>)
   29f7e:	4d47      	ldr	r5, [pc, #284]	; (2a09c <gpiote_event_handler+0x16c>)
   29f80:	f8d1 2304 	ldr.w	r2, [r1, #772]	; 0x304
   29f84:	fa00 fc03 	lsl.w	ip, r0, r3
   29f88:	ea1c 0f02 	tst.w	ip, r2
   29f8c:	d00d      	beq.n	29faa <gpiote_event_handler+0x7a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   29f8e:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
   29f92:	b152      	cbz	r2, 29faa <gpiote_event_handler+0x7a>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   29f94:	f503 72a2 	add.w	r2, r3, #324	; 0x144
   29f98:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   29f9c:	f845 7023 	str.w	r7, [r5, r3, lsl #2]
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   29fa0:	f3c2 2204 	ubfx	r2, r2, #8, #5
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
   29fa4:	fa00 f202 	lsl.w	r2, r0, r2
   29fa8:	4314      	orrs	r4, r2
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   29faa:	3301      	adds	r3, #1
   29fac:	2b08      	cmp	r3, #8
   29fae:	d1e7      	bne.n	29f80 <gpiote_event_handler+0x50>
	if (fired_triggers[0]) {
   29fb0:	bb34      	cbnz	r4, 2a000 <gpiote_event_handler+0xd0>
	if (port_event) {
   29fb2:	b186      	cbz	r6, 29fd6 <gpiote_event_handler+0xa6>
	u32_t bit = 1U << pin;
   29fb4:	2701      	movs	r7, #1
	u32_t pin = 0U;
   29fb6:	f04f 0800 	mov.w	r8, #0
	const struct gpio_nrfx_data *data = get_port_data(port);
   29fba:	4b36      	ldr	r3, [pc, #216]	; (2a094 <gpiote_event_handler+0x164>)
   29fbc:	689d      	ldr	r5, [r3, #8]
	return port->config->config_info;
   29fbe:	681b      	ldr	r3, [r3, #0]
   29fc0:	689e      	ldr	r6, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
   29fc2:	e9d5 3402 	ldrd	r3, r4, [r5, #8]
   29fc6:	401c      	ands	r4, r3
	out &= ~data->trig_edge & ~data->double_edge;
   29fc8:	e9d5 3205 	ldrd	r3, r2, [r5, #20]
   29fcc:	4313      	orrs	r3, r2
   29fce:	ea24 0403 	bic.w	r4, r4, r3
	while (level_pins) {
   29fd2:	2c00      	cmp	r4, #0
   29fd4:	d142      	bne.n	2a05c <gpiote_event_handler+0x12c>
}
   29fd6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (level_pins & bit) {
   29fda:	423d      	tst	r5, r7
   29fdc:	d00a      	beq.n	29ff4 <gpiote_event_handler+0xc4>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   29fde:	f899 3004 	ldrb.w	r3, [r9, #4]
   29fe2:	f00a 001f 	and.w	r0, sl, #31
			nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   29fe6:	2100      	movs	r1, #0
   29fe8:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
   29fec:	f7ff fe3c 	bl	29c68 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   29ff0:	ea25 0507 	bic.w	r5, r5, r7
		++pin;
   29ff4:	f10a 0a01 	add.w	sl, sl, #1
		bit <<= 1;
   29ff8:	007f      	lsls	r7, r7, #1
   29ffa:	e7b9      	b.n	29f70 <gpiote_event_handler+0x40>
	u32_t fired_triggers[GPIO_COUNT] = {0};
   29ffc:	4634      	mov	r4, r6
   29ffe:	e7ba      	b.n	29f76 <gpiote_event_handler+0x46>
	struct gpio_nrfx_data *data = get_port_data(port);
   2a000:	4b24      	ldr	r3, [pc, #144]	; (2a094 <gpiote_event_handler+0x164>)
   2a002:	f8d3 9008 	ldr.w	r9, [r3, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   2a006:	f8d9 5000 	ldr.w	r5, [r9]
   2a00a:	2d00      	cmp	r5, #0
   2a00c:	d0d1      	beq.n	29fb2 <gpiote_event_handler+0x82>
			cb->handler(port, cb, pins);
   2a00e:	4698      	mov	r8, r3
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   2a010:	682f      	ldr	r7, [r5, #0]
			__ASSERT(cb->handler, "No callback handler!");
   2a012:	f8df a094 	ldr.w	sl, [pc, #148]	; 2a0a8 <gpiote_event_handler+0x178>
   2a016:	f8df b094 	ldr.w	fp, [pc, #148]	; 2a0ac <gpiote_event_handler+0x17c>
		if ((cb->pin_mask & pins) & data->int_en) {
   2a01a:	f8d9 300c 	ldr.w	r3, [r9, #12]
   2a01e:	68aa      	ldr	r2, [r5, #8]
   2a020:	4023      	ands	r3, r4
   2a022:	4213      	tst	r3, r2
   2a024:	d015      	beq.n	2a052 <gpiote_event_handler+0x122>
			__ASSERT(cb->handler, "No callback handler!");
   2a026:	686b      	ldr	r3, [r5, #4]
   2a028:	b973      	cbnz	r3, 2a048 <gpiote_event_handler+0x118>
   2a02a:	4659      	mov	r1, fp
   2a02c:	f44f 73d2 	mov.w	r3, #420	; 0x1a4
   2a030:	4652      	mov	r2, sl
   2a032:	481b      	ldr	r0, [pc, #108]	; (2a0a0 <gpiote_event_handler+0x170>)
   2a034:	f012 fb7a 	bl	3c72c <printk>
   2a038:	481a      	ldr	r0, [pc, #104]	; (2a0a4 <gpiote_event_handler+0x174>)
   2a03a:	f012 fb77 	bl	3c72c <printk>
   2a03e:	f44f 71d2 	mov.w	r1, #420	; 0x1a4
   2a042:	4650      	mov	r0, sl
   2a044:	f012 fbb8 	bl	3c7b8 <assert_post_action>
			cb->handler(port, cb, pins);
   2a048:	686b      	ldr	r3, [r5, #4]
   2a04a:	4622      	mov	r2, r4
   2a04c:	4629      	mov	r1, r5
   2a04e:	4640      	mov	r0, r8
   2a050:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   2a052:	2f00      	cmp	r7, #0
   2a054:	d0ad      	beq.n	29fb2 <gpiote_event_handler+0x82>
   2a056:	463d      	mov	r5, r7
   2a058:	683f      	ldr	r7, [r7, #0]
   2a05a:	e7de      	b.n	2a01a <gpiote_event_handler+0xea>
		if (level_pins & bit) {
   2a05c:	4227      	tst	r7, r4
   2a05e:	d013      	beq.n	2a088 <gpiote_event_handler+0x158>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   2a060:	692b      	ldr	r3, [r5, #16]
   2a062:	69ea      	ldr	r2, [r5, #28]
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   2a064:	f896 c004 	ldrb.w	ip, [r6, #4]
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   2a068:	4053      	eors	r3, r2
   2a06a:	fa23 f308 	lsr.w	r3, r3, r8
		return NRF_GPIO_PIN_SENSE_HIGH;
   2a06e:	f013 0f01 	tst.w	r3, #1
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   2a072:	f008 001f 	and.w	r0, r8, #31
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   2a076:	bf0c      	ite	eq
   2a078:	2103      	moveq	r1, #3
   2a07a:	2102      	movne	r1, #2
   2a07c:	ea40 104c 	orr.w	r0, r0, ip, lsl #5
   2a080:	f7ff fdf2 	bl	29c68 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   2a084:	ea24 0407 	bic.w	r4, r4, r7
		++pin;
   2a088:	f108 0801 	add.w	r8, r8, #1
		bit <<= 1;
   2a08c:	007f      	lsls	r7, r7, #1
   2a08e:	e7a0      	b.n	29fd2 <gpiote_event_handler+0xa2>
   2a090:	4003117c 	.word	0x4003117c
   2a094:	20037988 	.word	0x20037988
   2a098:	40031000 	.word	0x40031000
   2a09c:	40031100 	.word	0x40031100
   2a0a0:	00040606 	.word	0x00040606
   2a0a4:	00042a26 	.word	0x00042a26
   2a0a8:	00042a3d 	.word	0x00042a3d
   2a0ac:	0004369c 	.word	0x0004369c

0002a0b0 <twim_1_init>:
#ifdef CONFIG_I2C_0_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(0);
#endif

#ifdef CONFIG_I2C_1_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(1);
   2a0b0:	b510      	push	{r4, lr}
   2a0b2:	4604      	mov	r4, r0
   2a0b4:	2200      	movs	r2, #0
   2a0b6:	2101      	movs	r1, #1
   2a0b8:	2009      	movs	r0, #9
   2a0ba:	f7fe f84b 	bl	28154 <z_arm_irq_priority_set>
	return dev->config->config_info;
   2a0be:	6823      	ldr	r3, [r4, #0]
	nrfx_err_t result = nrfx_twim_init(&get_dev_config(dev)->twim,
   2a0c0:	4a0f      	ldr	r2, [pc, #60]	; (2a100 <twim_1_init+0x50>)
	return dev->config->config_info;
   2a0c2:	6898      	ldr	r0, [r3, #8]
	nrfx_err_t result = nrfx_twim_init(&get_dev_config(dev)->twim,
   2a0c4:	4623      	mov	r3, r4
   2a0c6:	f100 0108 	add.w	r1, r0, #8
   2a0ca:	f00a ff91 	bl	34ff0 <nrfx_twim_init>
	if (result != NRFX_SUCCESS) {
   2a0ce:	4b0d      	ldr	r3, [pc, #52]	; (2a104 <twim_1_init+0x54>)
   2a0d0:	4298      	cmp	r0, r3
   2a0d2:	d012      	beq.n	2a0fa <twim_1_init+0x4a>
		LOG_ERR("Failed to initialize device: %s",
   2a0d4:	2301      	movs	r3, #1
   2a0d6:	f04f 0000 	mov.w	r0, #0
   2a0da:	4a0b      	ldr	r2, [pc, #44]	; (2a108 <twim_1_init+0x58>)
   2a0dc:	f363 0007 	bfi	r0, r3, #0, #8
   2a0e0:	4b0a      	ldr	r3, [pc, #40]	; (2a10c <twim_1_init+0x5c>)
   2a0e2:	490b      	ldr	r1, [pc, #44]	; (2a110 <twim_1_init+0x60>)
   2a0e4:	1a9b      	subs	r3, r3, r2
   2a0e6:	08db      	lsrs	r3, r3, #3
   2a0e8:	f363 108f 	bfi	r0, r3, #6, #10
   2a0ec:	6823      	ldr	r3, [r4, #0]
   2a0ee:	681a      	ldr	r2, [r3, #0]
   2a0f0:	f012 fb73 	bl	3c7da <log_string_sync>
		return -EBUSY;
   2a0f4:	f06f 000f 	mvn.w	r0, #15
I2C_NRFX_TWIM_DEVICE(1);
   2a0f8:	bd10      	pop	{r4, pc}
	return 0;
   2a0fa:	2000      	movs	r0, #0
I2C_NRFX_TWIM_DEVICE(1);
   2a0fc:	e7fc      	b.n	2a0f8 <twim_1_init+0x48>
   2a0fe:	bf00      	nop
   2a100:	0002a261 	.word	0x0002a261
   2a104:	0bad0000 	.word	0x0bad0000
   2a108:	0003f8d4 	.word	0x0003f8d4
   2a10c:	0003f94c 	.word	0x0003f94c
   2a110:	00042aeb 	.word	0x00042aeb

0002a114 <i2c_nrfx_twim_configure>:
{
   2a114:	b508      	push	{r3, lr}
	return dev->config->config_info;
   2a116:	6803      	ldr	r3, [r0, #0]
	if (I2C_ADDR_10_BITS & dev_config) {
   2a118:	07ca      	lsls	r2, r1, #31
	return dev->config->config_info;
   2a11a:	689b      	ldr	r3, [r3, #8]
	if (I2C_ADDR_10_BITS & dev_config) {
   2a11c:	d413      	bmi.n	2a146 <i2c_nrfx_twim_configure+0x32>
	switch (I2C_SPEED_GET(dev_config)) {
   2a11e:	f3c1 0242 	ubfx	r2, r1, #1, #3
   2a122:	2a01      	cmp	r2, #1
   2a124:	d012      	beq.n	2a14c <i2c_nrfx_twim_configure+0x38>
   2a126:	2a02      	cmp	r2, #2
   2a128:	d019      	beq.n	2a15e <i2c_nrfx_twim_configure+0x4a>
		LOG_ERR("unsupported speed");
   2a12a:	2301      	movs	r3, #1
   2a12c:	f04f 0000 	mov.w	r0, #0
   2a130:	4a0d      	ldr	r2, [pc, #52]	; (2a168 <i2c_nrfx_twim_configure+0x54>)
   2a132:	f363 0007 	bfi	r0, r3, #0, #8
   2a136:	4b0d      	ldr	r3, [pc, #52]	; (2a16c <i2c_nrfx_twim_configure+0x58>)
   2a138:	490d      	ldr	r1, [pc, #52]	; (2a170 <i2c_nrfx_twim_configure+0x5c>)
   2a13a:	1a9b      	subs	r3, r3, r2
   2a13c:	08db      	lsrs	r3, r3, #3
   2a13e:	f363 108f 	bfi	r0, r3, #6, #10
   2a142:	f012 fb4a 	bl	3c7da <log_string_sync>
		return -EINVAL;
   2a146:	f06f 0015 	mvn.w	r0, #21
   2a14a:	e007      	b.n	2a15c <i2c_nrfx_twim_configure+0x48>
}

NRF_STATIC_INLINE void nrf_twim_frequency_set(NRF_TWIM_Type * p_reg,
                                              nrf_twim_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
   2a14c:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
		nrf_twim_frequency_set(inst->p_twim, NRF_TWIM_FREQ_100K);
   2a150:	681b      	ldr	r3, [r3, #0]
   2a152:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	get_dev_data(dev)->dev_config = dev_config;
   2a156:	6883      	ldr	r3, [r0, #8]
	return 0;
   2a158:	2000      	movs	r0, #0
	get_dev_data(dev)->dev_config = dev_config;
   2a15a:	6359      	str	r1, [r3, #52]	; 0x34
}
   2a15c:	bd08      	pop	{r3, pc}
		nrf_twim_frequency_set(inst->p_twim, NRF_TWIM_FREQ_400K);
   2a15e:	681b      	ldr	r3, [r3, #0]
   2a160:	f04f 62c8 	mov.w	r2, #104857600	; 0x6400000
   2a164:	e7f5      	b.n	2a152 <i2c_nrfx_twim_configure+0x3e>
   2a166:	bf00      	nop
   2a168:	0003f8d4 	.word	0x0003f8d4
   2a16c:	0003f94c 	.word	0x0003f94c
   2a170:	00042aaa 	.word	0x00042aaa

0002a174 <i2c_nrfx_twim_transfer>:
{
   2a174:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2a178:	4604      	mov	r4, r0
   2a17a:	b087      	sub	sp, #28
   2a17c:	460d      	mov	r5, r1
   2a17e:	4691      	mov	r9, r2
   2a180:	469a      	mov	sl, r3
	k_sem_take(&(get_dev_data(dev)->transfer_sync), K_FOREVER);
   2a182:	6880      	ldr	r0, [r0, #8]
	return z_impl_k_sem_take(sem, timeout);
   2a184:	f04f 31ff 	mov.w	r1, #4294967295
   2a188:	f00d fc26 	bl	379d8 <z_impl_k_sem_take>
	return dev->config->config_info;
   2a18c:	6823      	ldr	r3, [r4, #0]
	for (size_t i = 0; i < num_msgs; i++) {
   2a18e:	2600      	movs	r6, #0
	nrfx_twim_enable(&get_dev_config(dev)->twim);
   2a190:	6898      	ldr	r0, [r3, #8]
   2a192:	f00a ff8d 	bl	350b0 <nrfx_twim_enable>
		if (res != NRFX_SUCCESS) {
   2a196:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 2a25c <i2c_nrfx_twim_transfer+0xe8>
   2a19a:	6823      	ldr	r3, [r4, #0]
	for (size_t i = 0; i < num_msgs; i++) {
   2a19c:	454e      	cmp	r6, r9
   2a19e:	f8d3 b008 	ldr.w	fp, [r3, #8]
   2a1a2:	d301      	bcc.n	2a1a8 <i2c_nrfx_twim_transfer+0x34>
	int ret = 0;
   2a1a4:	2500      	movs	r5, #0
   2a1a6:	e024      	b.n	2a1f2 <i2c_nrfx_twim_transfer+0x7e>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
   2a1a8:	7a2f      	ldrb	r7, [r5, #8]
   2a1aa:	f017 0108 	ands.w	r1, r7, #8
   2a1ae:	d14a      	bne.n	2a246 <i2c_nrfx_twim_transfer+0xd2>
		nrfx_twim_xfer_desc_t cur_xfer = {
   2a1b0:	2212      	movs	r2, #18
   2a1b2:	f10d 0006 	add.w	r0, sp, #6
   2a1b6:	f014 fb69 	bl	3e88c <memset>
					  NRFX_TWIM_XFER_RX : NRFX_TWIM_XFER_TX
   2a1ba:	f007 0301 	and.w	r3, r7, #1
		nrfx_twim_xfer_desc_t cur_xfer = {
   2a1be:	f88d 3004 	strb.w	r3, [sp, #4]
   2a1c2:	686b      	ldr	r3, [r5, #4]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
   2a1c4:	f017 0f02 	tst.w	r7, #2
		nrfx_twim_xfer_desc_t cur_xfer = {
   2a1c8:	9302      	str	r3, [sp, #8]
   2a1ca:	682b      	ldr	r3, [r5, #0]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
   2a1cc:	bf0c      	ite	eq
   2a1ce:	2220      	moveq	r2, #32
   2a1d0:	2200      	movne	r2, #0
   2a1d2:	a901      	add	r1, sp, #4
   2a1d4:	4658      	mov	r0, fp
		nrfx_twim_xfer_desc_t cur_xfer = {
   2a1d6:	f88d a005 	strb.w	sl, [sp, #5]
   2a1da:	9304      	str	r3, [sp, #16]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
   2a1dc:	f00a ffb6 	bl	3514c <nrfx_twim_xfer>
		if (res != NRFX_SUCCESS) {
   2a1e0:	4540      	cmp	r0, r8
   2a1e2:	d011      	beq.n	2a208 <i2c_nrfx_twim_transfer+0x94>
			if (res == NRFX_ERROR_BUSY) {
   2a1e4:	4b19      	ldr	r3, [pc, #100]	; (2a24c <i2c_nrfx_twim_transfer+0xd8>)
				ret = -EIO;
   2a1e6:	4298      	cmp	r0, r3
   2a1e8:	bf0c      	ite	eq
   2a1ea:	f06f 050f 	mvneq.w	r5, #15
   2a1ee:	f06f 0504 	mvnne.w	r5, #4
	return dev->config->config_info;
   2a1f2:	6823      	ldr	r3, [r4, #0]
	nrfx_twim_disable(&get_dev_config(dev)->twim);
   2a1f4:	6898      	ldr	r0, [r3, #8]
   2a1f6:	f00a ff7d 	bl	350f4 <nrfx_twim_disable>
	k_sem_give(&(get_dev_data(dev)->transfer_sync));
   2a1fa:	68a0      	ldr	r0, [r4, #8]
	z_impl_k_sem_give(sem);
   2a1fc:	f00d fba2 	bl	37944 <z_impl_k_sem_give>
}
   2a200:	4628      	mov	r0, r5
   2a202:	b007      	add	sp, #28
   2a204:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		k_sem_take(&(get_dev_data(dev)->completion_sync), K_FOREVER);
   2a208:	68a0      	ldr	r0, [r4, #8]
   2a20a:	3018      	adds	r0, #24
	return z_impl_k_sem_take(sem, timeout);
   2a20c:	f04f 31ff 	mov.w	r1, #4294967295
   2a210:	f00d fbe2 	bl	379d8 <z_impl_k_sem_take>
		res = get_dev_data(dev)->res;
   2a214:	68a3      	ldr	r3, [r4, #8]
	return dev->driver_data;
   2a216:	350c      	adds	r5, #12
		res = get_dev_data(dev)->res;
   2a218:	6b1a      	ldr	r2, [r3, #48]	; 0x30
		if (res != NRFX_SUCCESS) {
   2a21a:	4542      	cmp	r2, r8
   2a21c:	d011      	beq.n	2a242 <i2c_nrfx_twim_transfer+0xce>
			LOG_ERR("Error %d occurred for message %d", res, i);
   2a21e:	2301      	movs	r3, #1
   2a220:	f04f 0000 	mov.w	r0, #0
   2a224:	490a      	ldr	r1, [pc, #40]	; (2a250 <i2c_nrfx_twim_transfer+0xdc>)
   2a226:	f363 0007 	bfi	r0, r3, #0, #8
   2a22a:	4b0a      	ldr	r3, [pc, #40]	; (2a254 <i2c_nrfx_twim_transfer+0xe0>)
			ret = -EIO;
   2a22c:	f06f 0504 	mvn.w	r5, #4
   2a230:	1ac9      	subs	r1, r1, r3
   2a232:	08c9      	lsrs	r1, r1, #3
			LOG_ERR("Error %d occurred for message %d", res, i);
   2a234:	f361 108f 	bfi	r0, r1, #6, #10
   2a238:	4633      	mov	r3, r6
   2a23a:	4907      	ldr	r1, [pc, #28]	; (2a258 <i2c_nrfx_twim_transfer+0xe4>)
   2a23c:	f012 facd 	bl	3c7da <log_string_sync>
			break;
   2a240:	e7d7      	b.n	2a1f2 <i2c_nrfx_twim_transfer+0x7e>
	for (size_t i = 0; i < num_msgs; i++) {
   2a242:	3601      	adds	r6, #1
   2a244:	e7a9      	b.n	2a19a <i2c_nrfx_twim_transfer+0x26>
			ret = -ENOTSUP;
   2a246:	f06f 0585 	mvn.w	r5, #133	; 0x85
   2a24a:	e7d2      	b.n	2a1f2 <i2c_nrfx_twim_transfer+0x7e>
   2a24c:	0bad000b 	.word	0x0bad000b
   2a250:	0003f94c 	.word	0x0003f94c
   2a254:	0003f8d4 	.word	0x0003f8d4
   2a258:	00042abc 	.word	0x00042abc
   2a25c:	0bad0000 	.word	0x0bad0000

0002a260 <event_handler>:
	switch (p_event->type) {
   2a260:	7802      	ldrb	r2, [r0, #0]
	struct i2c_nrfx_twim_data *dev_data = get_dev_data(dev);
   2a262:	688b      	ldr	r3, [r1, #8]
	switch (p_event->type) {
   2a264:	2a01      	cmp	r2, #1
   2a266:	d00a      	beq.n	2a27e <event_handler+0x1e>
   2a268:	b11a      	cbz	r2, 2a272 <event_handler+0x12>
   2a26a:	2a02      	cmp	r2, #2
   2a26c:	d009      	beq.n	2a282 <event_handler+0x22>
		dev_data->res = NRFX_ERROR_INTERNAL;
   2a26e:	4a06      	ldr	r2, [pc, #24]	; (2a288 <event_handler+0x28>)
   2a270:	e000      	b.n	2a274 <event_handler+0x14>
		dev_data->res = NRFX_SUCCESS;
   2a272:	4a06      	ldr	r2, [pc, #24]	; (2a28c <event_handler+0x2c>)
		dev_data->res = NRFX_ERROR_INTERNAL;
   2a274:	631a      	str	r2, [r3, #48]	; 0x30
	z_impl_k_sem_give(sem);
   2a276:	f103 0018 	add.w	r0, r3, #24
   2a27a:	f00d bb63 	b.w	37944 <z_impl_k_sem_give>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   2a27e:	4a04      	ldr	r2, [pc, #16]	; (2a290 <event_handler+0x30>)
   2a280:	e7f8      	b.n	2a274 <event_handler+0x14>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   2a282:	4a04      	ldr	r2, [pc, #16]	; (2a294 <event_handler+0x34>)
   2a284:	e7f6      	b.n	2a274 <event_handler+0x14>
   2a286:	bf00      	nop
   2a288:	0bad0001 	.word	0x0bad0001
   2a28c:	0bad0000 	.word	0x0bad0000
   2a290:	0bae0001 	.word	0x0bae0001
   2a294:	0bae0002 	.word	0x0bae0002

0002a298 <init_spim>:
		transfer_next_chunk(dev);
	}
}

static int init_spim(struct device *dev)
{
   2a298:	b510      	push	{r4, lr}
   2a29a:	4604      	mov	r4, r0
	return dev->config->config_info;
   2a29c:	6803      	ldr	r3, [r0, #0]
	/* This sets only default values of frequency, mode and bit order.
	 * The proper ones are set in configure() when a transfer is started.
	 */
	nrfx_err_t result = nrfx_spim_init(&get_dev_config(dev)->spim,
   2a29e:	4a11      	ldr	r2, [pc, #68]	; (2a2e4 <init_spim+0x4c>)
	return dev->config->config_info;
   2a2a0:	6898      	ldr	r0, [r3, #8]
	nrfx_err_t result = nrfx_spim_init(&get_dev_config(dev)->spim,
   2a2a2:	4623      	mov	r3, r4
   2a2a4:	f100 010c 	add.w	r1, r0, #12
   2a2a8:	f00a fce0 	bl	34c6c <nrfx_spim_init>
					   &get_dev_config(dev)->config,
					   event_handler,
					   dev);
	if (result != NRFX_SUCCESS) {
   2a2ac:	4b0e      	ldr	r3, [pc, #56]	; (2a2e8 <init_spim+0x50>)
   2a2ae:	4298      	cmp	r0, r3
   2a2b0:	d012      	beq.n	2a2d8 <init_spim+0x40>
		LOG_ERR("Failed to initialize device: %s",
   2a2b2:	2301      	movs	r3, #1
   2a2b4:	f04f 0000 	mov.w	r0, #0
   2a2b8:	4a0c      	ldr	r2, [pc, #48]	; (2a2ec <init_spim+0x54>)
   2a2ba:	f363 0007 	bfi	r0, r3, #0, #8
   2a2be:	4b0c      	ldr	r3, [pc, #48]	; (2a2f0 <init_spim+0x58>)
   2a2c0:	490c      	ldr	r1, [pc, #48]	; (2a2f4 <init_spim+0x5c>)
   2a2c2:	1a9b      	subs	r3, r3, r2
   2a2c4:	08db      	lsrs	r3, r3, #3
   2a2c6:	f363 108f 	bfi	r0, r3, #6, #10
   2a2ca:	6823      	ldr	r3, [r4, #0]
   2a2cc:	681a      	ldr	r2, [r3, #0]
   2a2ce:	f012 fa84 	bl	3c7da <log_string_sync>
			    dev->config->name);
		return -EBUSY;
   2a2d2:	f06f 000f 	mvn.w	r0, #15
	get_dev_data(dev)->pm_state = DEVICE_PM_ACTIVE_STATE;
#endif
	spi_context_unlock_unconditionally(&get_dev_data(dev)->ctx);

	return 0;
}
   2a2d6:	bd10      	pop	{r4, pc}
	spi_context_unlock_unconditionally(&get_dev_data(dev)->ctx);
   2a2d8:	68a0      	ldr	r0, [r4, #8]
   2a2da:	f013 f97a 	bl	3d5d2 <spi_context_unlock_unconditionally>
	return 0;
   2a2de:	2000      	movs	r0, #0
   2a2e0:	e7f9      	b.n	2a2d6 <init_spim+0x3e>
   2a2e2:	bf00      	nop
   2a2e4:	0002a385 	.word	0x0002a385
   2a2e8:	0bad0000 	.word	0x0bad0000
   2a2ec:	0003f8d4 	.word	0x0003f8d4
   2a2f0:	0003f9dc 	.word	0x0003f9dc
   2a2f4:	00042aeb 	.word	0x00042aeb

0002a2f8 <transfer_next_chunk>:
{
   2a2f8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   2a2fa:	6885      	ldr	r5, [r0, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
}

static inline size_t spi_context_longest_current_buf(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
   2a2fc:	6cea      	ldr	r2, [r5, #76]	; 0x4c
   2a2fe:	6d6b      	ldr	r3, [r5, #84]	; 0x54
   2a300:	b98a      	cbnz	r2, 2a326 <transfer_next_chunk+0x2e>
	if (chunk_len > 0) {
   2a302:	2b00      	cmp	r3, #0
   2a304:	d133      	bne.n	2a36e <transfer_next_chunk+0x76>
	int error = 0;
   2a306:	461c      	mov	r4, r3
	_spi_context_cs_control(ctx, on, false);
   2a308:	2200      	movs	r2, #0
   2a30a:	4628      	mov	r0, r5
   2a30c:	4611      	mov	r1, r2
   2a30e:	f013 f936 	bl	3d57e <_spi_context_cs_control.isra.7>
	ctx->sync_status = status;
   2a312:	636c      	str	r4, [r5, #52]	; 0x34
   2a314:	f105 001c 	add.w	r0, r5, #28
   2a318:	f00d fb14 	bl	37944 <z_impl_k_sem_give>
	dev_data->busy = false;
   2a31c:	2300      	movs	r3, #0
   2a31e:	f885 305c 	strb.w	r3, [r5, #92]	; 0x5c
}
   2a322:	b004      	add	sp, #16
   2a324:	bd70      	pop	{r4, r5, r6, pc}
		return ctx->rx_len;
	} else if (!ctx->rx_len) {
   2a326:	b323      	cbz	r3, 2a372 <transfer_next_chunk+0x7a>
		return ctx->tx_len;
	} else if (ctx->tx_len < ctx->rx_len) {
   2a328:	4293      	cmp	r3, r2
   2a32a:	4619      	mov	r1, r3
   2a32c:	bf28      	it	cs
   2a32e:	4611      	movcs	r1, r2
	return dev->config->config_info;
   2a330:	6800      	ldr	r0, [r0, #0]
		const u8_t *tx_buf = ctx->tx_buf;
   2a332:	6cac      	ldr	r4, [r5, #72]	; 0x48
	return dev->config->config_info;
   2a334:	6880      	ldr	r0, [r0, #8]
		xfer.p_tx_buffer = tx_buf;
   2a336:	9400      	str	r4, [sp, #0]
   2a338:	6886      	ldr	r6, [r0, #8]
   2a33a:	42b1      	cmp	r1, r6
   2a33c:	bf28      	it	cs
   2a33e:	4631      	movcs	r1, r6
		dev_data->chunk_len = chunk_len;
   2a340:	65a9      	str	r1, [r5, #88]	; 0x58
	return !!(ctx->tx_buf && ctx->tx_len);
   2a342:	b1c4      	cbz	r4, 2a376 <transfer_next_chunk+0x7e>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
   2a344:	2a00      	cmp	r2, #0
   2a346:	bf18      	it	ne
   2a348:	460a      	movne	r2, r1
   2a34a:	9201      	str	r2, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
   2a34c:	6d2a      	ldr	r2, [r5, #80]	; 0x50
   2a34e:	9202      	str	r2, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
   2a350:	b19a      	cbz	r2, 2a37a <transfer_next_chunk+0x82>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   2a352:	2b00      	cmp	r3, #0
   2a354:	bf18      	it	ne
   2a356:	460b      	movne	r3, r1
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
   2a358:	2200      	movs	r2, #0
   2a35a:	4669      	mov	r1, sp
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   2a35c:	9303      	str	r3, [sp, #12]
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
   2a35e:	f00a fd3d 	bl	34ddc <nrfx_spim_xfer>
			if (result == NRFX_SUCCESS) {
   2a362:	4b07      	ldr	r3, [pc, #28]	; (2a380 <transfer_next_chunk+0x88>)
   2a364:	4298      	cmp	r0, r3
   2a366:	d0dc      	beq.n	2a322 <transfer_next_chunk+0x2a>
			error = -EIO;
   2a368:	f06f 0404 	mvn.w	r4, #4
   2a36c:	e7cc      	b.n	2a308 <transfer_next_chunk+0x10>
   2a36e:	4619      	mov	r1, r3
   2a370:	e7de      	b.n	2a330 <transfer_next_chunk+0x38>
	} else if (!ctx->rx_len) {
   2a372:	4611      	mov	r1, r2
   2a374:	e7dc      	b.n	2a330 <transfer_next_chunk+0x38>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
   2a376:	4622      	mov	r2, r4
   2a378:	e7e7      	b.n	2a34a <transfer_next_chunk+0x52>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   2a37a:	4613      	mov	r3, r2
   2a37c:	e7ec      	b.n	2a358 <transfer_next_chunk+0x60>
   2a37e:	bf00      	nop
   2a380:	0bad0000 	.word	0x0bad0000

0002a384 <event_handler>:
{
   2a384:	b538      	push	{r3, r4, r5, lr}
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   2a386:	7803      	ldrb	r3, [r0, #0]
{
   2a388:	460d      	mov	r5, r1
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   2a38a:	2b00      	cmp	r3, #0
   2a38c:	d157      	bne.n	2a43e <event_handler+0xba>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   2a38e:	688c      	ldr	r4, [r1, #8]
	if (!ctx->tx_len) {
   2a390:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   2a392:	b183      	cbz	r3, 2a3b6 <event_handler+0x32>
		spi_context_update_tx(&dev_data->ctx, 1, dev_data->chunk_len);
   2a394:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (len > ctx->tx_len) {
   2a396:	429a      	cmp	r2, r3
   2a398:	d925      	bls.n	2a3e6 <event_handler+0x62>
		LOG_ERR("Update exceeds current buffer");
   2a39a:	2301      	movs	r3, #1
   2a39c:	f04f 0000 	mov.w	r0, #0
   2a3a0:	4a27      	ldr	r2, [pc, #156]	; (2a440 <event_handler+0xbc>)
   2a3a2:	f363 0007 	bfi	r0, r3, #0, #8
   2a3a6:	4b27      	ldr	r3, [pc, #156]	; (2a444 <event_handler+0xc0>)
   2a3a8:	4927      	ldr	r1, [pc, #156]	; (2a448 <event_handler+0xc4>)
   2a3aa:	1a9b      	subs	r3, r3, r2
   2a3ac:	08db      	lsrs	r3, r3, #3
   2a3ae:	f363 108f 	bfi	r0, r3, #6, #10
   2a3b2:	f012 fa12 	bl	3c7da <log_string_sync>
	if (!ctx->rx_len) {
   2a3b6:	6d63      	ldr	r3, [r4, #84]	; 0x54
   2a3b8:	b183      	cbz	r3, 2a3dc <event_handler+0x58>
		spi_context_update_rx(&dev_data->ctx, 1, dev_data->chunk_len);
   2a3ba:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (len > ctx->rx_len) {
   2a3bc:	429a      	cmp	r2, r3
   2a3be:	d928      	bls.n	2a412 <event_handler+0x8e>
		LOG_ERR("Update exceeds current buffer");
   2a3c0:	2301      	movs	r3, #1
   2a3c2:	f04f 0000 	mov.w	r0, #0
   2a3c6:	4a1e      	ldr	r2, [pc, #120]	; (2a440 <event_handler+0xbc>)
   2a3c8:	f363 0007 	bfi	r0, r3, #0, #8
   2a3cc:	4b1d      	ldr	r3, [pc, #116]	; (2a444 <event_handler+0xc0>)
   2a3ce:	491e      	ldr	r1, [pc, #120]	; (2a448 <event_handler+0xc4>)
   2a3d0:	1a9b      	subs	r3, r3, r2
   2a3d2:	08db      	lsrs	r3, r3, #3
   2a3d4:	f363 108f 	bfi	r0, r3, #6, #10
   2a3d8:	f012 f9ff 	bl	3c7da <log_string_sync>
		transfer_next_chunk(dev);
   2a3dc:	4628      	mov	r0, r5
}
   2a3de:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		transfer_next_chunk(dev);
   2a3e2:	f7ff bf89 	b.w	2a2f8 <transfer_next_chunk>
	ctx->tx_len -= len;
   2a3e6:	1a9b      	subs	r3, r3, r2
   2a3e8:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (!ctx->tx_len) {
   2a3ea:	b963      	cbnz	r3, 2a406 <event_handler+0x82>
		ctx->tx_count--;
   2a3ec:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   2a3ee:	3b01      	subs	r3, #1
   2a3f0:	63e3      	str	r3, [r4, #60]	; 0x3c
		if (ctx->tx_count) {
   2a3f2:	b163      	cbz	r3, 2a40e <event_handler+0x8a>
			ctx->current_tx++;
   2a3f4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   2a3f6:	f103 0208 	add.w	r2, r3, #8
   2a3fa:	63a2      	str	r2, [r4, #56]	; 0x38
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   2a3fc:	689a      	ldr	r2, [r3, #8]
			ctx->tx_len = ctx->current_tx->len / dfs;
   2a3fe:	68db      	ldr	r3, [r3, #12]
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   2a400:	64a2      	str	r2, [r4, #72]	; 0x48
			ctx->tx_len = ctx->current_tx->len / dfs;
   2a402:	64e3      	str	r3, [r4, #76]	; 0x4c
   2a404:	e7d7      	b.n	2a3b6 <event_handler+0x32>
	} else if (ctx->tx_buf) {
   2a406:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   2a408:	2b00      	cmp	r3, #0
   2a40a:	d0d4      	beq.n	2a3b6 <event_handler+0x32>
		ctx->tx_buf += dfs * len;
   2a40c:	4413      	add	r3, r2
   2a40e:	64a3      	str	r3, [r4, #72]	; 0x48
   2a410:	e7d1      	b.n	2a3b6 <event_handler+0x32>
	ctx->rx_len -= len;
   2a412:	1a9b      	subs	r3, r3, r2
   2a414:	6563      	str	r3, [r4, #84]	; 0x54
	if (!ctx->rx_len) {
   2a416:	b963      	cbnz	r3, 2a432 <event_handler+0xae>
		ctx->rx_count--;
   2a418:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2a41a:	3b01      	subs	r3, #1
   2a41c:	6463      	str	r3, [r4, #68]	; 0x44
		if (ctx->rx_count) {
   2a41e:	b163      	cbz	r3, 2a43a <event_handler+0xb6>
			ctx->current_rx++;
   2a420:	6c23      	ldr	r3, [r4, #64]	; 0x40
   2a422:	f103 0208 	add.w	r2, r3, #8
   2a426:	6422      	str	r2, [r4, #64]	; 0x40
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   2a428:	689a      	ldr	r2, [r3, #8]
			ctx->rx_len = ctx->current_rx->len / dfs;
   2a42a:	68db      	ldr	r3, [r3, #12]
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   2a42c:	6522      	str	r2, [r4, #80]	; 0x50
			ctx->rx_len = ctx->current_rx->len / dfs;
   2a42e:	6563      	str	r3, [r4, #84]	; 0x54
   2a430:	e7d4      	b.n	2a3dc <event_handler+0x58>
	} else if (ctx->rx_buf) {
   2a432:	6d23      	ldr	r3, [r4, #80]	; 0x50
   2a434:	2b00      	cmp	r3, #0
   2a436:	d0d1      	beq.n	2a3dc <event_handler+0x58>
		ctx->rx_buf += dfs * len;
   2a438:	4413      	add	r3, r2
   2a43a:	6523      	str	r3, [r4, #80]	; 0x50
   2a43c:	e7ce      	b.n	2a3dc <event_handler+0x58>
}
   2a43e:	bd38      	pop	{r3, r4, r5, pc}
   2a440:	0003f8d4 	.word	0x0003f8d4
   2a444:	0003f9dc 	.word	0x0003f9dc
   2a448:	00042b0b 	.word	0x00042b0b

0002a44c <spi_nrfx_transceive>:
{
   2a44c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2a450:	4607      	mov	r7, r0
	k_sem_take(&ctx->lock, K_FOREVER);
   2a452:	6880      	ldr	r0, [r0, #8]
   2a454:	4688      	mov	r8, r1
   2a456:	4616      	mov	r6, r2
   2a458:	461d      	mov	r5, r3
   2a45a:	3004      	adds	r0, #4
	return z_impl_k_sem_take(sem, timeout);
   2a45c:	f04f 31ff 	mov.w	r1, #4294967295
   2a460:	f00d faba 	bl	379d8 <z_impl_k_sem_take>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   2a464:	68bc      	ldr	r4, [r7, #8]
	if (spi_context_configured(ctx, spi_cfg)) {
   2a466:	6823      	ldr	r3, [r4, #0]
   2a468:	4598      	cmp	r8, r3
   2a46a:	f000 80b0 	beq.w	2a5ce <spi_nrfx_transceive+0x182>
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
   2a46e:	f8b8 3004 	ldrh.w	r3, [r8, #4]
	const nrfx_spim_t *spim = &get_dev_config(dev)->spim;
   2a472:	683a      	ldr	r2, [r7, #0]
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
   2a474:	07d8      	lsls	r0, r3, #31
   2a476:	d516      	bpl.n	2a4a6 <spi_nrfx_transceive+0x5a>
		LOG_ERR("Slave mode is not supported on %s",
   2a478:	2301      	movs	r3, #1
   2a47a:	f04f 0000 	mov.w	r0, #0
   2a47e:	4981      	ldr	r1, [pc, #516]	; (2a684 <spi_nrfx_transceive+0x238>)
   2a480:	f363 0007 	bfi	r0, r3, #0, #8
   2a484:	4b80      	ldr	r3, [pc, #512]	; (2a688 <spi_nrfx_transceive+0x23c>)
   2a486:	6812      	ldr	r2, [r2, #0]
   2a488:	1a5b      	subs	r3, r3, r1
   2a48a:	08db      	lsrs	r3, r3, #3
   2a48c:	f363 108f 	bfi	r0, r3, #6, #10
   2a490:	497e      	ldr	r1, [pc, #504]	; (2a68c <spi_nrfx_transceive+0x240>)
   2a492:	f012 f9a2 	bl	3c7da <log_string_sync>
		return -EINVAL;
   2a496:	f06f 0515 	mvn.w	r5, #21
	z_impl_k_sem_give(sem);
   2a49a:	1d20      	adds	r0, r4, #4
   2a49c:	f00d fa52 	bl	37944 <z_impl_k_sem_give>
}
   2a4a0:	4628      	mov	r0, r5
   2a4a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (spi_cfg->operation & SPI_MODE_LOOP) {
   2a4a6:	0719      	lsls	r1, r3, #28
   2a4a8:	d50e      	bpl.n	2a4c8 <spi_nrfx_transceive+0x7c>
		LOG_ERR("Loopback mode is not supported");
   2a4aa:	2301      	movs	r3, #1
   2a4ac:	f04f 0000 	mov.w	r0, #0
   2a4b0:	4a74      	ldr	r2, [pc, #464]	; (2a684 <spi_nrfx_transceive+0x238>)
   2a4b2:	f363 0007 	bfi	r0, r3, #0, #8
   2a4b6:	4b74      	ldr	r3, [pc, #464]	; (2a688 <spi_nrfx_transceive+0x23c>)
   2a4b8:	4975      	ldr	r1, [pc, #468]	; (2a690 <spi_nrfx_transceive+0x244>)
   2a4ba:	1a9b      	subs	r3, r3, r2
   2a4bc:	08db      	lsrs	r3, r3, #3
   2a4be:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Word sizes other than 8 bits"
   2a4c2:	f012 f98a 	bl	3c7da <log_string_sync>
   2a4c6:	e7e6      	b.n	2a496 <spi_nrfx_transceive+0x4a>
	if ((spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
   2a4c8:	f413 51c0 	ands.w	r1, r3, #6144	; 0x1800
   2a4cc:	d00c      	beq.n	2a4e8 <spi_nrfx_transceive+0x9c>
		LOG_ERR("Only single line mode is supported");
   2a4ce:	2301      	movs	r3, #1
   2a4d0:	f04f 0000 	mov.w	r0, #0
   2a4d4:	4a6b      	ldr	r2, [pc, #428]	; (2a684 <spi_nrfx_transceive+0x238>)
   2a4d6:	f363 0007 	bfi	r0, r3, #0, #8
   2a4da:	4b6b      	ldr	r3, [pc, #428]	; (2a688 <spi_nrfx_transceive+0x23c>)
   2a4dc:	496d      	ldr	r1, [pc, #436]	; (2a694 <spi_nrfx_transceive+0x248>)
   2a4de:	1a9b      	subs	r3, r3, r2
   2a4e0:	08db      	lsrs	r3, r3, #3
   2a4e2:	f363 108f 	bfi	r0, r3, #6, #10
   2a4e6:	e7ec      	b.n	2a4c2 <spi_nrfx_transceive+0x76>
	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
   2a4e8:	f3c3 1345 	ubfx	r3, r3, #5, #6
   2a4ec:	2b08      	cmp	r3, #8
   2a4ee:	d00c      	beq.n	2a50a <spi_nrfx_transceive+0xbe>
		LOG_ERR("Word sizes other than 8 bits"
   2a4f0:	2301      	movs	r3, #1
   2a4f2:	f04f 0000 	mov.w	r0, #0
   2a4f6:	4a63      	ldr	r2, [pc, #396]	; (2a684 <spi_nrfx_transceive+0x238>)
   2a4f8:	f363 0007 	bfi	r0, r3, #0, #8
   2a4fc:	4b62      	ldr	r3, [pc, #392]	; (2a688 <spi_nrfx_transceive+0x23c>)
   2a4fe:	4966      	ldr	r1, [pc, #408]	; (2a698 <spi_nrfx_transceive+0x24c>)
   2a500:	1a9b      	subs	r3, r3, r2
   2a502:	08db      	lsrs	r3, r3, #3
   2a504:	f363 108f 	bfi	r0, r3, #6, #10
   2a508:	e7db      	b.n	2a4c2 <spi_nrfx_transceive+0x76>
	if (spi_cfg->frequency < 125000) {
   2a50a:	f8d8 0000 	ldr.w	r0, [r8]
   2a50e:	4b63      	ldr	r3, [pc, #396]	; (2a69c <spi_nrfx_transceive+0x250>)
   2a510:	4298      	cmp	r0, r3
   2a512:	d80c      	bhi.n	2a52e <spi_nrfx_transceive+0xe2>
		LOG_ERR("Frequencies lower than 125 kHz are not supported");
   2a514:	2301      	movs	r3, #1
   2a516:	f04f 0000 	mov.w	r0, #0
   2a51a:	4a5a      	ldr	r2, [pc, #360]	; (2a684 <spi_nrfx_transceive+0x238>)
   2a51c:	f363 0007 	bfi	r0, r3, #0, #8
   2a520:	4b59      	ldr	r3, [pc, #356]	; (2a688 <spi_nrfx_transceive+0x23c>)
   2a522:	495f      	ldr	r1, [pc, #380]	; (2a6a0 <spi_nrfx_transceive+0x254>)
   2a524:	1a9b      	subs	r3, r3, r2
   2a526:	08db      	lsrs	r3, r3, #3
   2a528:	f363 108f 	bfi	r0, r3, #6, #10
   2a52c:	e7c9      	b.n	2a4c2 <spi_nrfx_transceive+0x76>
	if (ctx->config->cs && ctx->config->cs->gpio_dev) {
   2a52e:	f8d8 3008 	ldr.w	r3, [r8, #8]
	return dev->config->config_info;
   2a532:	f8d2 9008 	ldr.w	r9, [r2, #8]
	ctx->config = spi_cfg;
   2a536:	f8c4 8000 	str.w	r8, [r4]
   2a53a:	2b00      	cmp	r3, #0
   2a53c:	d06f      	beq.n	2a61e <spi_nrfx_transceive+0x1d2>
   2a53e:	6818      	ldr	r0, [r3, #0]
   2a540:	2800      	cmp	r0, #0
   2a542:	d06c      	beq.n	2a61e <spi_nrfx_transceive+0x1d2>
		gpio_pin_configure(ctx->config->cs->gpio_dev,
   2a544:	685a      	ldr	r2, [r3, #4]
	return api->config(port, access_op, pin, flags);
   2a546:	6843      	ldr	r3, [r0, #4]
   2a548:	f8d3 a000 	ldr.w	sl, [r3]
   2a54c:	2301      	movs	r3, #1
   2a54e:	47d0      	blx	sl
		gpio_pin_write(ctx->config->cs->gpio_dev,
   2a550:	6822      	ldr	r2, [r4, #0]
   2a552:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   2a554:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
		gpio_pin_write(ctx->config->cs->gpio_dev,
   2a558:	e9d3 0100 	ldrd	r0, r1, [r3]
   2a55c:	43d2      	mvns	r2, r2
   2a55e:	0fd2      	lsrs	r2, r2, #31
   2a560:	f013 f803 	bl	3d56a <gpio_pin_write>
	nrf_spim_configure(spim->p_reg,
   2a564:	f8b8 3004 	ldrh.w	r3, [r8, #4]
   2a568:	f8d9 1000 	ldr.w	r1, [r9]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
   2a56c:	0798      	lsls	r0, r3, #30
   2a56e:	f003 0204 	and.w	r2, r3, #4
   2a572:	d563      	bpl.n	2a63c <spi_nrfx_transceive+0x1f0>
			return NRF_SPIM_MODE_2;
   2a574:	2a00      	cmp	r2, #0
   2a576:	bf14      	ite	ne
   2a578:	2203      	movne	r2, #3
   2a57a:	2202      	moveq	r2, #2
                                          nrf_spim_mode_t      spi_mode,
                                          nrf_spim_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPIM_BIT_ORDER_MSB_FIRST ?
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
    switch (spi_mode)
   2a57c:	2a02      	cmp	r2, #2
	if (operation & SPI_TRANSFER_LSB) {
   2a57e:	f3c3 1300 	ubfx	r3, r3, #4, #1
   2a582:	d05f      	beq.n	2a644 <spi_nrfx_transceive+0x1f8>
   2a584:	2a03      	cmp	r2, #3
   2a586:	d060      	beq.n	2a64a <spi_nrfx_transceive+0x1fe>
   2a588:	2a01      	cmp	r2, #1
   2a58a:	d101      	bne.n	2a590 <spi_nrfx_transceive+0x144>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Leading    << SPIM_CONFIG_CPHA_Pos);
        break;

    case NRF_SPIM_MODE_1:
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
   2a58c:	f043 0302 	orr.w	r3, r3, #2
    case NRF_SPIM_MODE_3:
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Trailing   << SPIM_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
   2a590:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
	if (frequency < 250000) {
   2a594:	4a43      	ldr	r2, [pc, #268]	; (2a6a4 <spi_nrfx_transceive+0x258>)
	nrf_spim_frequency_set(spim->p_reg,
   2a596:	f8d8 3000 	ldr.w	r3, [r8]
	if (frequency < 250000) {
   2a59a:	4293      	cmp	r3, r2
   2a59c:	d958      	bls.n	2a650 <spi_nrfx_transceive+0x204>
	} else if (frequency < 500000) {
   2a59e:	4a42      	ldr	r2, [pc, #264]	; (2a6a8 <spi_nrfx_transceive+0x25c>)
   2a5a0:	4293      	cmp	r3, r2
   2a5a2:	d958      	bls.n	2a656 <spi_nrfx_transceive+0x20a>
	} else if (frequency < 1000000) {
   2a5a4:	4a41      	ldr	r2, [pc, #260]	; (2a6ac <spi_nrfx_transceive+0x260>)
   2a5a6:	4293      	cmp	r3, r2
   2a5a8:	d958      	bls.n	2a65c <spi_nrfx_transceive+0x210>
	} else if (frequency < 2000000) {
   2a5aa:	4a41      	ldr	r2, [pc, #260]	; (2a6b0 <spi_nrfx_transceive+0x264>)
   2a5ac:	4293      	cmp	r3, r2
   2a5ae:	d958      	bls.n	2a662 <spi_nrfx_transceive+0x216>
	} else if (frequency < 4000000) {
   2a5b0:	4a40      	ldr	r2, [pc, #256]	; (2a6b4 <spi_nrfx_transceive+0x268>)
   2a5b2:	4293      	cmp	r3, r2
   2a5b4:	d958      	bls.n	2a668 <spi_nrfx_transceive+0x21c>
		return NRF_SPIM_FREQ_8M;
   2a5b6:	f502 1274 	add.w	r2, r2, #3997696	; 0x3d0000
   2a5ba:	f502 6210 	add.w	r2, r2, #2304	; 0x900
   2a5be:	4293      	cmp	r3, r2
   2a5c0:	bf94      	ite	ls
   2a5c2:	f04f 4380 	movls.w	r3, #1073741824	; 0x40000000
   2a5c6:	f04f 4300 	movhi.w	r3, #2147483648	; 0x80000000
    p_reg->FREQUENCY = (uint32_t)frequency;
   2a5ca:	f8c1 3524 	str.w	r3, [r1, #1316]	; 0x524
		dev_data->busy = true;
   2a5ce:	2301      	movs	r3, #1
   2a5d0:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
	if (tx_bufs) {
   2a5d4:	2e00      	cmp	r6, #0
   2a5d6:	d04a      	beq.n	2a66e <spi_nrfx_transceive+0x222>
		ctx->current_tx = tx_bufs->buffers;
   2a5d8:	6833      	ldr	r3, [r6, #0]
		ctx->tx_count = tx_bufs->count;
   2a5da:	6872      	ldr	r2, [r6, #4]
		ctx->current_tx = tx_bufs->buffers;
   2a5dc:	63a3      	str	r3, [r4, #56]	; 0x38
		ctx->tx_count = tx_bufs->count;
   2a5de:	63e2      	str	r2, [r4, #60]	; 0x3c
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   2a5e0:	681a      	ldr	r2, [r3, #0]
		ctx->tx_len = ctx->current_tx->len / dfs;
   2a5e2:	685b      	ldr	r3, [r3, #4]
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   2a5e4:	64a2      	str	r2, [r4, #72]	; 0x48
		ctx->tx_len = ctx->current_tx->len / dfs;
   2a5e6:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (rx_bufs) {
   2a5e8:	2d00      	cmp	r5, #0
   2a5ea:	d045      	beq.n	2a678 <spi_nrfx_transceive+0x22c>
		ctx->current_rx = rx_bufs->buffers;
   2a5ec:	682b      	ldr	r3, [r5, #0]
		ctx->rx_count = rx_bufs->count;
   2a5ee:	686a      	ldr	r2, [r5, #4]
		ctx->current_rx = rx_bufs->buffers;
   2a5f0:	6423      	str	r3, [r4, #64]	; 0x40
		ctx->rx_count = rx_bufs->count;
   2a5f2:	6462      	str	r2, [r4, #68]	; 0x44
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   2a5f4:	681a      	ldr	r2, [r3, #0]
		ctx->rx_len = ctx->current_rx->len / dfs;
   2a5f6:	685b      	ldr	r3, [r3, #4]
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   2a5f8:	6522      	str	r2, [r4, #80]	; 0x50
		ctx->rx_len = ctx->current_rx->len / dfs;
   2a5fa:	6563      	str	r3, [r4, #84]	; 0x54
	ctx->sync_status = 0;
   2a5fc:	2200      	movs	r2, #0
	_spi_context_cs_control(ctx, on, false);
   2a5fe:	2101      	movs	r1, #1
	ctx->sync_status = 0;
   2a600:	6362      	str	r2, [r4, #52]	; 0x34
	_spi_context_cs_control(ctx, on, false);
   2a602:	4620      	mov	r0, r4
   2a604:	f012 ffbb 	bl	3d57e <_spi_context_cs_control.isra.7>
		transfer_next_chunk(dev);
   2a608:	4638      	mov	r0, r7
   2a60a:	f7ff fe75 	bl	2a2f8 <transfer_next_chunk>
	return z_impl_k_sem_take(sem, timeout);
   2a60e:	f04f 31ff 	mov.w	r1, #4294967295
   2a612:	f104 001c 	add.w	r0, r4, #28
   2a616:	f00d f9df 	bl	379d8 <z_impl_k_sem_take>
	status = ctx->sync_status;
   2a61a:	6b65      	ldr	r5, [r4, #52]	; 0x34
	return status;
   2a61c:	e73d      	b.n	2a49a <spi_nrfx_transceive+0x4e>
		LOG_INF("CS control inhibited (no GPIO device)");
   2a61e:	2303      	movs	r3, #3
   2a620:	f04f 0000 	mov.w	r0, #0
   2a624:	4a17      	ldr	r2, [pc, #92]	; (2a684 <spi_nrfx_transceive+0x238>)
   2a626:	f363 0007 	bfi	r0, r3, #0, #8
   2a62a:	4b17      	ldr	r3, [pc, #92]	; (2a688 <spi_nrfx_transceive+0x23c>)
   2a62c:	4922      	ldr	r1, [pc, #136]	; (2a6b8 <spi_nrfx_transceive+0x26c>)
   2a62e:	1a9b      	subs	r3, r3, r2
   2a630:	08db      	lsrs	r3, r3, #3
   2a632:	f363 108f 	bfi	r0, r3, #6, #10
   2a636:	f012 f8d0 	bl	3c7da <log_string_sync>
   2a63a:	e793      	b.n	2a564 <spi_nrfx_transceive+0x118>
			return NRF_SPIM_MODE_0;
   2a63c:	3200      	adds	r2, #0
   2a63e:	bf18      	it	ne
   2a640:	2201      	movne	r2, #1
   2a642:	e79b      	b.n	2a57c <spi_nrfx_transceive+0x130>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   2a644:	f043 0304 	orr.w	r3, r3, #4
        break;
   2a648:	e7a2      	b.n	2a590 <spi_nrfx_transceive+0x144>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   2a64a:	f043 0306 	orr.w	r3, r3, #6
        break;
   2a64e:	e79f      	b.n	2a590 <spi_nrfx_transceive+0x144>
		return NRF_SPIM_FREQ_125K;
   2a650:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   2a654:	e7b9      	b.n	2a5ca <spi_nrfx_transceive+0x17e>
		return NRF_SPIM_FREQ_250K;
   2a656:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   2a65a:	e7b6      	b.n	2a5ca <spi_nrfx_transceive+0x17e>
		return NRF_SPIM_FREQ_500K;
   2a65c:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
   2a660:	e7b3      	b.n	2a5ca <spi_nrfx_transceive+0x17e>
		return NRF_SPIM_FREQ_1M;
   2a662:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   2a666:	e7b0      	b.n	2a5ca <spi_nrfx_transceive+0x17e>
		return NRF_SPIM_FREQ_2M;
   2a668:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
   2a66c:	e7ad      	b.n	2a5ca <spi_nrfx_transceive+0x17e>
		ctx->tx_count = 0;
   2a66e:	e9c4 660e 	strd	r6, r6, [r4, #56]	; 0x38
		ctx->tx_len = 0;
   2a672:	e9c4 6612 	strd	r6, r6, [r4, #72]	; 0x48
   2a676:	e7b7      	b.n	2a5e8 <spi_nrfx_transceive+0x19c>
		ctx->rx_count = 0;
   2a678:	e9c4 5510 	strd	r5, r5, [r4, #64]	; 0x40
		ctx->rx_len = 0;
   2a67c:	e9c4 5514 	strd	r5, r5, [r4, #80]	; 0x50
   2a680:	e7bc      	b.n	2a5fc <spi_nrfx_transceive+0x1b0>
   2a682:	bf00      	nop
   2a684:	0003f8d4 	.word	0x0003f8d4
   2a688:	0003f9dc 	.word	0x0003f9dc
   2a68c:	00042b29 	.word	0x00042b29
   2a690:	00042b4b 	.word	0x00042b4b
   2a694:	00042b6a 	.word	0x00042b6a
   2a698:	00042b8d 	.word	0x00042b8d
   2a69c:	0001e847 	.word	0x0001e847
   2a6a0:	00042bbc 	.word	0x00042bbc
   2a6a4:	0003d08f 	.word	0x0003d08f
   2a6a8:	0007a11f 	.word	0x0007a11f
   2a6ac:	000f423f 	.word	0x000f423f
   2a6b0:	001e847f 	.word	0x001e847f
   2a6b4:	003d08ff 	.word	0x003d08ff
   2a6b8:	00042bed 	.word	0x00042bed

0002a6bc <flash_nrf_pages_layout>:

static void flash_nrf_pages_layout(struct device *dev,
				     const struct flash_pages_layout **layout,
				     size_t *layout_size)
{
	*layout = &dev_layout;
   2a6bc:	4b02      	ldr	r3, [pc, #8]	; (2a6c8 <flash_nrf_pages_layout+0xc>)
   2a6be:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
   2a6c0:	2301      	movs	r3, #1
   2a6c2:	6013      	str	r3, [r2, #0]
}
   2a6c4:	4770      	bx	lr
   2a6c6:	bf00      	nop
   2a6c8:	20024bf4 	.word	0x20024bf4

0002a6cc <flash_nrf_erase>:
{
   2a6cc:	b570      	push	{r4, r5, r6, lr}
   2a6ce:	460d      	mov	r5, r1
   2a6d0:	4614      	mov	r4, r2
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   2a6d2:	f013 fe8b 	bl	3e3ec <nrfx_nvmc_flash_page_size_get>
	if (is_regular_addr_valid(addr, size)) {
   2a6d6:	4621      	mov	r1, r4
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   2a6d8:	4606      	mov	r6, r0
	if (is_regular_addr_valid(addr, size)) {
   2a6da:	4628      	mov	r0, r5
   2a6dc:	f012 ffb3 	bl	3d646 <is_regular_addr_valid>
   2a6e0:	b1f0      	cbz	r0, 2a720 <flash_nrf_erase+0x54>
		if (((addr % pg_size) != 0) || ((size % pg_size) != 0)) {
   2a6e2:	fbb5 f3f6 	udiv	r3, r5, r6
   2a6e6:	fb06 5313 	mls	r3, r6, r3, r5
   2a6ea:	b9cb      	cbnz	r3, 2a720 <flash_nrf_erase+0x54>
   2a6ec:	fbb4 f0f6 	udiv	r0, r4, r6
   2a6f0:	fb06 4010 	mls	r0, r6, r0, r4
   2a6f4:	b9a0      	cbnz	r0, 2a720 <flash_nrf_erase+0x54>
		if (!n_pages) {
   2a6f6:	42a6      	cmp	r6, r4
   2a6f8:	d811      	bhi.n	2a71e <flash_nrf_erase+0x52>
   2a6fa:	f04f 31ff 	mov.w	r1, #4294967295
   2a6fe:	480a      	ldr	r0, [pc, #40]	; (2a728 <flash_nrf_erase+0x5c>)
   2a700:	f00d f96a 	bl	379d8 <z_impl_k_sem_take>

#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

static int erase_op(void *context)
{
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   2a704:	f013 fe72 	bl	3e3ec <nrfx_nvmc_flash_page_size_get>
   2a708:	4606      	mov	r6, r0
		return FLASH_OP_DONE;
	}
#endif

	do {
		(void)nrfx_nvmc_page_erase(e_ctx->flash_addr);
   2a70a:	4628      	mov	r0, r5
   2a70c:	f00a fa28 	bl	34b60 <nrfx_nvmc_page_erase>
				break;
			}
		}
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

	} while (e_ctx->len > 0);
   2a710:	1ba4      	subs	r4, r4, r6
   2a712:	4435      	add	r5, r6
   2a714:	d1f9      	bne.n	2a70a <flash_nrf_erase+0x3e>
	z_impl_k_sem_give(sem);
   2a716:	4804      	ldr	r0, [pc, #16]	; (2a728 <flash_nrf_erase+0x5c>)
   2a718:	f00d f914 	bl	37944 <z_impl_k_sem_give>
	return ret;
   2a71c:	4620      	mov	r0, r4
}
   2a71e:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   2a720:	f06f 0015 	mvn.w	r0, #21
   2a724:	e7fb      	b.n	2a71e <flash_nrf_erase+0x52>
   2a726:	bf00      	nop
   2a728:	20024bfc 	.word	0x20024bfc

0002a72c <nrf_flash_init>:
{
   2a72c:	b510      	push	{r4, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
   2a72e:	2201      	movs	r2, #1
   2a730:	4806      	ldr	r0, [pc, #24]	; (2a74c <nrf_flash_init+0x20>)
   2a732:	4611      	mov	r1, r2
   2a734:	f013 ff3a 	bl	3e5ac <z_impl_k_sem_init>
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
   2a738:	f013 fe5b 	bl	3e3f2 <nrfx_nvmc_flash_page_count_get>
   2a73c:	4c04      	ldr	r4, [pc, #16]	; (2a750 <nrf_flash_init+0x24>)
   2a73e:	6020      	str	r0, [r4, #0]
	dev_layout.pages_size = nrfx_nvmc_flash_page_size_get();
   2a740:	f013 fe54 	bl	3e3ec <nrfx_nvmc_flash_page_size_get>
   2a744:	6060      	str	r0, [r4, #4]
}
   2a746:	2000      	movs	r0, #0
   2a748:	bd10      	pop	{r4, pc}
   2a74a:	bf00      	nop
   2a74c:	20024bfc 	.word	0x20024bfc
   2a750:	20024bf4 	.word	0x20024bf4

0002a754 <flash_nrf_write>:
{
   2a754:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2a756:	460e      	mov	r6, r1
	if (is_regular_addr_valid(addr, len)) {
   2a758:	4619      	mov	r1, r3
   2a75a:	4630      	mov	r0, r6
{
   2a75c:	4617      	mov	r7, r2
   2a75e:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   2a760:	f012 ff71 	bl	3d646 <is_regular_addr_valid>
   2a764:	b1f8      	cbz	r0, 2a7a6 <flash_nrf_write+0x52>
	return (data & 0x3) ? false : true;
   2a766:	ea46 0504 	orr.w	r5, r6, r4
	if (!is_aligned_32(addr) || (len % sizeof(u32_t))) {
   2a76a:	f015 0503 	ands.w	r5, r5, #3
   2a76e:	d11a      	bne.n	2a7a6 <flash_nrf_write+0x52>
	if (!len) {
   2a770:	b1e4      	cbz	r4, 2a7ac <flash_nrf_write+0x58>
	return z_impl_k_sem_take(sem, timeout);
   2a772:	f04f 31ff 	mov.w	r1, #4294967295
   2a776:	480e      	ldr	r0, [pc, #56]	; (2a7b0 <flash_nrf_write+0x5c>)
   2a778:	f00d f92e 	bl	379d8 <z_impl_k_sem_take>
	w_ctx->flash_addr += shift;
	w_ctx->data_addr += shift;
	w_ctx->len -= shift;
}

static int write_op(void *context)
   2a77c:	f024 0403 	bic.w	r4, r4, #3
		}
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */
	}
#endif /* CONFIG_SOC_FLASH_NRF_EMULATE_ONE_BYTE_WRITE_ACCESS */
	/* Write all the 4-byte aligned data */
	while (w_ctx->len >= sizeof(u32_t)) {
   2a780:	42a5      	cmp	r5, r4
   2a782:	eb06 0005 	add.w	r0, r6, r5
   2a786:	d109      	bne.n	2a79c <flash_nrf_write+0x48>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrf_nvmc_ready_check(NRF_NVMC_Type const * p_reg)
{
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   2a788:	4a0a      	ldr	r2, [pc, #40]	; (2a7b4 <flash_nrf_write+0x60>)
   2a78a:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
   2a78e:	07db      	lsls	r3, r3, #31
   2a790:	d5fb      	bpl.n	2a78a <flash_nrf_write+0x36>
	z_impl_k_sem_give(sem);
   2a792:	4807      	ldr	r0, [pc, #28]	; (2a7b0 <flash_nrf_write+0x5c>)
   2a794:	f00d f8d6 	bl	37944 <z_impl_k_sem_give>
   2a798:	2000      	movs	r0, #0
}
   2a79a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		nrfx_nvmc_word_write(w_ctx->flash_addr,
   2a79c:	5979      	ldr	r1, [r7, r5]
   2a79e:	f00a fa0b 	bl	34bb8 <nrfx_nvmc_word_write>
	w_ctx->len -= shift;
   2a7a2:	3504      	adds	r5, #4
   2a7a4:	e7ec      	b.n	2a780 <flash_nrf_write+0x2c>
		return -EINVAL;
   2a7a6:	f06f 0015 	mvn.w	r0, #21
   2a7aa:	e7f6      	b.n	2a79a <flash_nrf_write+0x46>
		return 0;
   2a7ac:	4620      	mov	r0, r4
   2a7ae:	e7f4      	b.n	2a79a <flash_nrf_write+0x46>
   2a7b0:	20024bfc 	.word	0x20024bfc
   2a7b4:	40039000 	.word	0x40039000

0002a7b8 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(struct device *dev,
				const struct uart_config *cfg)
{
   2a7b8:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
   2a7ba:	794b      	ldrb	r3, [r1, #5]
   2a7bc:	2b01      	cmp	r3, #1
   2a7be:	d029      	beq.n	2a814 <uarte_nrfx_configure+0x5c>
   2a7c0:	2b03      	cmp	r3, #3
   2a7c2:	d124      	bne.n	2a80e <uarte_nrfx_configure+0x56>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
   2a7c4:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   2a7c6:	798b      	ldrb	r3, [r1, #6]
   2a7c8:	2b03      	cmp	r3, #3
   2a7ca:	d120      	bne.n	2a80e <uarte_nrfx_configure+0x56>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
   2a7cc:	79cc      	ldrb	r4, [r1, #7]
   2a7ce:	b12c      	cbz	r4, 2a7dc <uarte_nrfx_configure+0x24>
   2a7d0:	2c01      	cmp	r4, #1
   2a7d2:	d11c      	bne.n	2a80e <uarte_nrfx_configure+0x56>
	return dev->config->config_info;
   2a7d4:	6803      	ldr	r3, [r0, #0]
	case UART_CFG_FLOW_CTRL_NONE:
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
		break;
	case UART_CFG_FLOW_CTRL_RTS_CTS:
		if (get_dev_config(dev)->rts_cts_pins_set) {
   2a7d6:	689b      	ldr	r3, [r3, #8]
   2a7d8:	791b      	ldrb	r3, [r3, #4]
   2a7da:	b1c3      	cbz	r3, 2a80e <uarte_nrfx_configure+0x56>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
   2a7dc:	790a      	ldrb	r2, [r1, #4]
   2a7de:	b112      	cbz	r2, 2a7e6 <uarte_nrfx_configure+0x2e>
   2a7e0:	2a02      	cmp	r2, #2
   2a7e2:	d114      	bne.n	2a80e <uarte_nrfx_configure+0x56>
	case UART_CFG_PARITY_NONE:
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
   2a7e4:	220e      	movs	r2, #14
	switch (baudrate) {
   2a7e6:	f647 2712 	movw	r7, #31250	; 0x7a12
	return dev->config->config_info;
   2a7ea:	6805      	ldr	r5, [r0, #0]
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
   2a7ec:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
   2a7ee:	68ad      	ldr	r5, [r5, #8]
	switch (baudrate) {
   2a7f0:	42bb      	cmp	r3, r7
	return config->uarte_regs;
   2a7f2:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
   2a7f4:	d062      	beq.n	2a8bc <uarte_nrfx_configure+0x104>
   2a7f6:	d829      	bhi.n	2a84c <uarte_nrfx_configure+0x94>
   2a7f8:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
   2a7fc:	d061      	beq.n	2a8c2 <uarte_nrfx_configure+0x10a>
   2a7fe:	d814      	bhi.n	2a82a <uarte_nrfx_configure+0x72>
   2a800:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
   2a804:	d05f      	beq.n	2a8c6 <uarte_nrfx_configure+0x10e>
   2a806:	d807      	bhi.n	2a818 <uarte_nrfx_configure+0x60>
   2a808:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   2a80c:	d05e      	beq.n	2a8cc <uarte_nrfx_configure+0x114>
		return -ENOTSUP;
   2a80e:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2a812:	e052      	b.n	2a8ba <uarte_nrfx_configure+0x102>
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
   2a814:	2600      	movs	r6, #0
   2a816:	e7d6      	b.n	2a7c6 <uarte_nrfx_configure+0xe>
	switch (baudrate) {
   2a818:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
   2a81c:	d059      	beq.n	2a8d2 <uarte_nrfx_configure+0x11a>
   2a81e:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
   2a822:	d1f4      	bne.n	2a80e <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
   2a824:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
   2a828:	e03c      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   2a82a:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
   2a82e:	d053      	beq.n	2a8d8 <uarte_nrfx_configure+0x120>
   2a830:	d804      	bhi.n	2a83c <uarte_nrfx_configure+0x84>
   2a832:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   2a836:	d1ea      	bne.n	2a80e <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
   2a838:	4b32      	ldr	r3, [pc, #200]	; (2a904 <uarte_nrfx_configure+0x14c>)
   2a83a:	e033      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   2a83c:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
   2a840:	d04c      	beq.n	2a8dc <uarte_nrfx_configure+0x124>
   2a842:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
   2a846:	d1e2      	bne.n	2a80e <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
   2a848:	4b2f      	ldr	r3, [pc, #188]	; (2a908 <uarte_nrfx_configure+0x150>)
   2a84a:	e02b      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   2a84c:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
   2a850:	d046      	beq.n	2a8e0 <uarte_nrfx_configure+0x128>
   2a852:	d812      	bhi.n	2a87a <uarte_nrfx_configure+0xc2>
   2a854:	f64d 27c0 	movw	r7, #56000	; 0xdac0
   2a858:	42bb      	cmp	r3, r7
   2a85a:	d044      	beq.n	2a8e6 <uarte_nrfx_configure+0x12e>
   2a85c:	d805      	bhi.n	2a86a <uarte_nrfx_configure+0xb2>
   2a85e:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
   2a862:	d1d4      	bne.n	2a80e <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
   2a864:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
   2a868:	e01c      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   2a86a:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   2a86e:	d03d      	beq.n	2a8ec <uarte_nrfx_configure+0x134>
   2a870:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
   2a874:	d1cb      	bne.n	2a80e <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
   2a876:	4b25      	ldr	r3, [pc, #148]	; (2a90c <uarte_nrfx_configure+0x154>)
   2a878:	e014      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   2a87a:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
   2a87e:	d038      	beq.n	2a8f2 <uarte_nrfx_configure+0x13a>
   2a880:	d808      	bhi.n	2a894 <uarte_nrfx_configure+0xdc>
   2a882:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   2a886:	d037      	beq.n	2a8f8 <uarte_nrfx_configure+0x140>
   2a888:	4f21      	ldr	r7, [pc, #132]	; (2a910 <uarte_nrfx_configure+0x158>)
   2a88a:	42bb      	cmp	r3, r7
   2a88c:	d1bf      	bne.n	2a80e <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
   2a88e:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   2a892:	e007      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   2a894:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
   2a898:	d031      	beq.n	2a8fe <uarte_nrfx_configure+0x146>
   2a89a:	4f1e      	ldr	r7, [pc, #120]	; (2a914 <uarte_nrfx_configure+0x15c>)
   2a89c:	42bb      	cmp	r3, r7
   2a89e:	d1b6      	bne.n	2a80e <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
   2a8a0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
   2a8a4:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
                    | (uint32_t)p_cfg->hwfc;
   2a8a8:	4334      	orrs	r4, r6
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
   2a8aa:	6883      	ldr	r3, [r0, #8]
   2a8ac:	4322      	orrs	r2, r4
   2a8ae:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   2a8b0:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
   2a8b4:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
   2a8b8:	2000      	movs	r0, #0
}
   2a8ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
   2a8bc:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   2a8c0:	e7f0      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
   2a8c2:	4b15      	ldr	r3, [pc, #84]	; (2a918 <uarte_nrfx_configure+0x160>)
   2a8c4:	e7ee      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
		nrf_baudrate = 0x00027000;
   2a8c6:	f44f 331c 	mov.w	r3, #159744	; 0x27000
   2a8ca:	e7eb      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
		nrf_baudrate = 0x00014000;
   2a8cc:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
   2a8d0:	e7e8      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
   2a8d2:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
   2a8d6:	e7e5      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
   2a8d8:	4b10      	ldr	r3, [pc, #64]	; (2a91c <uarte_nrfx_configure+0x164>)
   2a8da:	e7e3      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
   2a8dc:	4b10      	ldr	r3, [pc, #64]	; (2a920 <uarte_nrfx_configure+0x168>)
   2a8de:	e7e1      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
   2a8e0:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
   2a8e4:	e7de      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
   2a8e6:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
   2a8ea:	e7db      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
   2a8ec:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
   2a8f0:	e7d8      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
   2a8f2:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
   2a8f6:	e7d5      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
   2a8f8:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
   2a8fc:	e7d2      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
   2a8fe:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   2a902:	e7cf      	b.n	2a8a4 <uarte_nrfx_configure+0xec>
   2a904:	00275000 	.word	0x00275000
   2a908:	0075c000 	.word	0x0075c000
   2a90c:	013a9000 	.word	0x013a9000
   2a910:	0003d090 	.word	0x0003d090
   2a914:	000f4240 	.word	0x000f4240
   2a918:	0013b000 	.word	0x0013b000
   2a91c:	003af000 	.word	0x003af000
   2a920:	004ea000 	.word	0x004ea000

0002a924 <uarte_0_init>:
	#endif
	#if !defined(DT_NORDIC_NRF_UARTE_UART_0_RX_PIN)
	#define DT_NORDIC_NRF_UARTE_UART_0_RX_PIN NRF_UARTE_PSEL_DISCONNECTED
	#endif

	UART_NRF_UARTE_DEVICE(0);
   2a924:	b570      	push	{r4, r5, r6, lr}
   2a926:	4606      	mov	r6, r0
   2a928:	2200      	movs	r2, #0
   2a92a:	2101      	movs	r1, #1
   2a92c:	2008      	movs	r0, #8
   2a92e:	f7fd fc11 	bl	28154 <z_arm_irq_priority_set>
   2a932:	2008      	movs	r0, #8
   2a934:	f7fd fbfe 	bl	28134 <arch_irq_enable>
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
   2a938:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
	return dev->config->config_info;
   2a93c:	6833      	ldr	r3, [r6, #0]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   2a93e:	68b5      	ldr	r5, [r6, #8]
	return config->uarte_regs;
   2a940:	689b      	ldr	r3, [r3, #8]
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   2a942:	4629      	mov	r1, r5
	return config->uarte_regs;
   2a944:	681c      	ldr	r4, [r3, #0]
   2a946:	4b14      	ldr	r3, [pc, #80]	; (2a998 <uarte_0_init+0x74>)
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   2a948:	4630      	mov	r0, r6
   2a94a:	609a      	str	r2, [r3, #8]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   2a94c:	2203      	movs	r2, #3
   2a94e:	f8c3 2274 	str.w	r2, [r3, #628]	; 0x274
   2a952:	2200      	movs	r2, #0
   2a954:	f8c3 2270 	str.w	r2, [r3, #624]	; 0x270
    p_reg->PSEL.TXD = pseltxd;
   2a958:	231d      	movs	r3, #29
   2a95a:	f8c4 350c 	str.w	r3, [r4, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
   2a95e:	231c      	movs	r3, #28
   2a960:	f8c4 3514 	str.w	r3, [r4, #1300]	; 0x514
   2a964:	f7ff ff28 	bl	2a7b8 <uarte_nrfx_configure>
	if (err) {
   2a968:	b9a0      	cbnz	r0, 2a994 <uarte_0_init+0x70>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   2a96a:	2308      	movs	r3, #8
   2a96c:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
		nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
   2a970:	f105 030c 	add.w	r3, r5, #12
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2a974:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   2a978:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   2a97c:	2301      	movs	r3, #1
		nrf_uarte_tx_buffer_set(uarte, data->int_driven->tx_buffer, 0);
   2a97e:	68aa      	ldr	r2, [r5, #8]
   2a980:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   2a984:	6892      	ldr	r2, [r2, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2a986:	6023      	str	r3, [r4, #0]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   2a988:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   2a98c:	f8c4 0548 	str.w	r0, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2a990:	60a3      	str	r3, [r4, #8]
   2a992:	60e3      	str	r3, [r4, #12]
	UART_NRF_UARTE_DEVICE(0);
   2a994:	bd70      	pop	{r4, r5, r6, pc}
   2a996:	bf00      	nop
   2a998:	40842500 	.word	0x40842500

0002a99c <entropy_cc310_rng_get_entropy>:
#include "nrf_cc310_platform_entropy.h"
#endif

static int entropy_cc310_rng_get_entropy(struct device *dev, u8_t *buffer,
					 u16_t length)
{
   2a99c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2a99e:	460d      	mov	r5, r1
   2a9a0:	4614      	mov	r4, r2
	int res = -EINVAL;
	size_t olen;

	__ASSERT_NO_MSG(dev != NULL);
   2a9a2:	b948      	cbnz	r0, 2a9b8 <entropy_cc310_rng_get_entropy+0x1c>
   2a9a4:	4910      	ldr	r1, [pc, #64]	; (2a9e8 <entropy_cc310_rng_get_entropy+0x4c>)
   2a9a6:	4811      	ldr	r0, [pc, #68]	; (2a9ec <entropy_cc310_rng_get_entropy+0x50>)
   2a9a8:	231e      	movs	r3, #30
   2a9aa:	4a11      	ldr	r2, [pc, #68]	; (2a9f0 <entropy_cc310_rng_get_entropy+0x54>)
   2a9ac:	f011 febe 	bl	3c72c <printk>
   2a9b0:	211e      	movs	r1, #30
   2a9b2:	480f      	ldr	r0, [pc, #60]	; (2a9f0 <entropy_cc310_rng_get_entropy+0x54>)
   2a9b4:	f011 ff00 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(buffer != NULL);
   2a9b8:	b94d      	cbnz	r5, 2a9ce <entropy_cc310_rng_get_entropy+0x32>
   2a9ba:	490e      	ldr	r1, [pc, #56]	; (2a9f4 <entropy_cc310_rng_get_entropy+0x58>)
   2a9bc:	480b      	ldr	r0, [pc, #44]	; (2a9ec <entropy_cc310_rng_get_entropy+0x50>)
   2a9be:	231f      	movs	r3, #31
   2a9c0:	4a0b      	ldr	r2, [pc, #44]	; (2a9f0 <entropy_cc310_rng_get_entropy+0x54>)
   2a9c2:	f011 feb3 	bl	3c72c <printk>
   2a9c6:	211f      	movs	r1, #31
   2a9c8:	4809      	ldr	r0, [pc, #36]	; (2a9f0 <entropy_cc310_rng_get_entropy+0x54>)
   2a9ca:	f011 fef5 	bl	3c7b8 <assert_post_action>

#if defined(CONFIG_SPM)
	/** This is a call from a non-secure app that enables secure services,
	 *  in which case entropy is gathered by calling through SPM
	 */
	res = spm_request_random_number(buffer, length, &olen);
   2a9ce:	aa01      	add	r2, sp, #4
   2a9d0:	4621      	mov	r1, r4
   2a9d2:	4628      	mov	r0, r5
   2a9d4:	f7ed fb0c 	bl	17ff0 <spm_request_random_number>
	if (olen != length) {
   2a9d8:	9b01      	ldr	r3, [sp, #4]
		return -EINVAL;
   2a9da:	429c      	cmp	r4, r3
		return -EINVAL;
	}
#endif

	return res;
}
   2a9dc:	bf18      	it	ne
   2a9de:	f06f 0015 	mvnne.w	r0, #21
   2a9e2:	b003      	add	sp, #12
   2a9e4:	bd30      	pop	{r4, r5, pc}
   2a9e6:	bf00      	nop
   2a9e8:	00042c61 	.word	0x00042c61
   2a9ec:	00040606 	.word	0x00040606
   2a9f0:	00042c31 	.word	0x00042c31
   2a9f4:	00042c74 	.word	0x00042c74

0002a9f8 <_bsdlib_init>:
static int _bsdlib_init(struct device *unused)
{
	/* Setup the network IRQ used by the BSD library.
	 * Note: No call to irq_enable() here, that is done through bsd_init().
	 */
	IRQ_DIRECT_CONNECT(BSD_NETWORK_IRQ, BSD_NETWORK_IRQ_PRIORITY,
   2a9f8:	2200      	movs	r2, #0
{
   2a9fa:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(BSD_NETWORK_IRQ, BSD_NETWORK_IRQ_PRIORITY,
   2a9fc:	4611      	mov	r1, r2
   2a9fe:	202a      	movs	r0, #42	; 0x2a
   2aa00:	f7fd fba8 	bl	28154 <z_arm_irq_priority_set>
			   ipc_proxy_irq_handler, 0);

	init_ret = bsd_init();
   2aa04:	f003 ff72 	bl	2e8ec <bsd_init>
   2aa08:	4b01      	ldr	r3, [pc, #4]	; (2aa10 <_bsdlib_init+0x18>)
   2aa0a:	6018      	str	r0, [r3, #0]
		 */
		return 0;
	}

	return init_ret;
}
   2aa0c:	2000      	movs	r0, #0
   2aa0e:	bd08      	pop	{r3, pc}
   2aa10:	20024c14 	.word	0x20024c14

0002aa14 <thread_monitor_entry_get>:

/* Get thread monitor structure assigned to a specific thread id, with a RPC
 * counter value at which bsdlib last checked the 'readiness' of a thread
 */
static struct thread_monitor_entry *thread_monitor_entry_get(k_tid_t id)
{
   2aa14:	b570      	push	{r4, r5, r6, lr}
			new_entry = entry;
			break;
		}

		/* Identify oldest entry. */
		entry_age = rpc_event_cnt - entry->cnt;
   2aa16:	4b0d      	ldr	r3, [pc, #52]	; (2aa4c <thread_monitor_entry_get+0x38>)
	struct thread_monitor_entry *new_entry = thread_event_monitor;
   2aa18:	4c0d      	ldr	r4, [pc, #52]	; (2aa50 <thread_monitor_entry_get+0x3c>)
		entry_age = rpc_event_cnt - entry->cnt;
   2aa1a:	681a      	ldr	r2, [r3, #0]
   2aa1c:	250a      	movs	r5, #10
	int entry_age, oldest_entry_age = 0;
   2aa1e:	2600      	movs	r6, #0
	struct thread_monitor_entry *entry = thread_event_monitor;
   2aa20:	4623      	mov	r3, r4
		if (entry->id == id) {
   2aa22:	6819      	ldr	r1, [r3, #0]
   2aa24:	4281      	cmp	r1, r0
   2aa26:	d00e      	beq.n	2aa46 <thread_monitor_entry_get+0x32>
		} else if (entry->id == 0) {
   2aa28:	b151      	cbz	r1, 2aa40 <thread_monitor_entry_get+0x2c>
		entry_age = rpc_event_cnt - entry->cnt;
   2aa2a:	6859      	ldr	r1, [r3, #4]
   2aa2c:	1a51      	subs	r1, r2, r1
		if (entry_age > oldest_entry_age) {
   2aa2e:	42b1      	cmp	r1, r6
   2aa30:	bfc4      	itt	gt
   2aa32:	461c      	movgt	r4, r3
   2aa34:	460e      	movgt	r6, r1
	for ( ; PART_OF_ARRAY(thread_event_monitor, entry); entry++) {
   2aa36:	3d01      	subs	r5, #1
   2aa38:	f103 0308 	add.w	r3, r3, #8
   2aa3c:	d1f1      	bne.n	2aa22 <thread_monitor_entry_get+0xe>
   2aa3e:	4623      	mov	r3, r4
			new_entry = entry;
		}
	}

	new_entry->id = id;
	new_entry->cnt = rpc_event_cnt - 1;
   2aa40:	3a01      	subs	r2, #1
	new_entry->id = id;
   2aa42:	6018      	str	r0, [r3, #0]
	new_entry->cnt = rpc_event_cnt - 1;
   2aa44:	605a      	str	r2, [r3, #4]

	return new_entry;
}
   2aa46:	4618      	mov	r0, r3
   2aa48:	bd70      	pop	{r4, r5, r6, pc}
   2aa4a:	bf00      	nop
   2aa4c:	20024c18 	.word	0x20024c18
   2aa50:	20024c24 	.word	0x20024c24

0002aa54 <rpc_proxy_irq_handler>:
			  */

	return 1; /* We should check if scheduling decision should be made */
}

ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   2aa54:	4668      	mov	r0, sp
   2aa56:	f020 0107 	bic.w	r1, r0, #7
   2aa5a:	468d      	mov	sp, r1
   2aa5c:	b519      	push	{r0, r3, r4, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   2aa5e:	4b0d      	ldr	r3, [pc, #52]	; (2aa94 <rpc_proxy_irq_handler+0x40>)
   2aa60:	e8d3 2fef 	ldaex	r2, [r3]
   2aa64:	3201      	adds	r2, #1
   2aa66:	e8c3 2fe1 	stlex	r1, r2, [r3]
   2aa6a:	2900      	cmp	r1, #0
   2aa6c:	d1f8      	bne.n	2aa60 <rpc_proxy_irq_handler+0xc>
{
	atomic_inc(&rpc_event_cnt);

	bsd_os_application_irq_handler();
   2aa6e:	f008 f8f5 	bl	32c5c <bsd_os_application_irq_handler>

	struct sleeping_thread *thread;

	/* Wake up all sleeping threads. */
	SYS_SLIST_FOR_EACH_CONTAINER(&sleeping_threads, thread, node) {
   2aa72:	4b09      	ldr	r3, [pc, #36]	; (2aa98 <rpc_proxy_irq_handler+0x44>)
   2aa74:	681c      	ldr	r4, [r3, #0]
   2aa76:	b93c      	cbnz	r4, 2aa88 <rpc_proxy_irq_handler+0x34>
		k_sem_give(&thread->sem);
	}

	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   2aa78:	f7fd fb9e 	bl	281b8 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING
	sys_trace_isr_exit();
#endif
	if (maybe_swap) {
		z_arm_int_exit();
   2aa7c:	f7fd fa86 	bl	27f8c <z_arm_exc_exit>
ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   2aa80:	e8bd 4019 	ldmia.w	sp!, {r0, r3, r4, lr}
   2aa84:	4685      	mov	sp, r0
   2aa86:	4770      	bx	lr
   2aa88:	1d20      	adds	r0, r4, #4
   2aa8a:	f00c ff5b 	bl	37944 <z_impl_k_sem_give>
   2aa8e:	6824      	ldr	r4, [r4, #0]
	return node->next;
   2aa90:	e7f1      	b.n	2aa76 <rpc_proxy_irq_handler+0x22>
   2aa92:	bf00      	nop
   2aa94:	20024c18 	.word	0x20024c18
   2aa98:	20024c1c 	.word	0x20024c1c

0002aa9c <bsd_os_timedwait>:
{
   2aa9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2aaa0:	4688      	mov	r8, r1
   2aaa2:	b089      	sub	sp, #36	; 0x24
	return z_impl_k_uptime_get();
   2aaa4:	f013 fe15 	bl	3e6d2 <z_impl_k_uptime_get>
	if (*timeout == 0) {
   2aaa8:	f8d8 3000 	ldr.w	r3, [r8]
   2aaac:	4606      	mov	r6, r0
   2aaae:	2b00      	cmp	r3, #0
   2aab0:	460f      	mov	r7, r1
   2aab2:	d103      	bne.n	2aabc <bsd_os_timedwait+0x20>
	z_impl_k_yield();
   2aab4:	f00c fdc2 	bl	3763c <z_impl_k_yield>
		return NRF_ETIMEDOUT;
   2aab8:	203c      	movs	r0, #60	; 0x3c
   2aaba:	e06e      	b.n	2ab9a <bsd_os_timedwait+0xfe>
		*timeout = K_FOREVER;
   2aabc:	bfbc      	itt	lt
   2aabe:	f04f 33ff 	movlt.w	r3, #4294967295
   2aac2:	f8c8 3000 	strlt.w	r3, [r8]
	return z_impl_k_sem_init(sem, initial_count, limit);
   2aac6:	2201      	movs	r2, #1
   2aac8:	2100      	movs	r1, #0
   2aaca:	a802      	add	r0, sp, #8
   2aacc:	f013 fd6e 	bl	3e5ac <z_impl_k_sem_init>
   2aad0:	f10d 0a04 	add.w	sl, sp, #4
   2aad4:	f04f 0320 	mov.w	r3, #32
   2aad8:	f3ef 8b11 	mrs	fp, BASEPRI
   2aadc:	f383 8811 	msr	BASEPRI, r3
   2aae0:	f3bf 8f6f 	isb	sy
	return z_impl_k_current_get();
   2aae4:	f00c ff28 	bl	37938 <z_impl_k_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   2aae8:	f7ff ff94 	bl	2aa14 <thread_monitor_entry_get>
	if (rpc_event_cnt != entry->cnt) {
   2aaec:	4933      	ldr	r1, [pc, #204]	; (2abbc <bsd_os_timedwait+0x120>)
   2aaee:	6843      	ldr	r3, [r0, #4]
   2aaf0:	680a      	ldr	r2, [r1, #0]
   2aaf2:	4689      	mov	r9, r1
   2aaf4:	4293      	cmp	r3, r2
   2aaf6:	f04f 0300 	mov.w	r3, #0
   2aafa:	d108      	bne.n	2ab0e <bsd_os_timedwait+0x72>
	parent->next = child;
   2aafc:	9301      	str	r3, [sp, #4]
Z_GENLIST_APPEND(slist, snode)
   2aafe:	4b30      	ldr	r3, [pc, #192]	; (2abc0 <bsd_os_timedwait+0x124>)
   2ab00:	685a      	ldr	r2, [r3, #4]
   2ab02:	2a00      	cmp	r2, #0
   2ab04:	d14c      	bne.n	2aba0 <bsd_os_timedwait+0x104>
	list->head = node;
   2ab06:	e9c3 aa00 	strd	sl, sl, [r3]
		allow_to_sleep = true;
   2ab0a:	2301      	movs	r3, #1
   2ab0c:	e000      	b.n	2ab10 <bsd_os_timedwait+0x74>
	entry->cnt = rpc_event_cnt;
   2ab0e:	6042      	str	r2, [r0, #4]
	__asm__ volatile(
   2ab10:	f38b 8811 	msr	BASEPRI, fp
   2ab14:	f3bf 8f6f 	isb	sy
	if (!sleeping_thread_add(&thread)) {
   2ab18:	2b00      	cmp	r3, #0
   2ab1a:	d03d      	beq.n	2ab98 <bsd_os_timedwait+0xfc>
	(void)k_sem_take(&thread.sem, *timeout);
   2ab1c:	f8d8 1000 	ldr.w	r1, [r8]
	return z_impl_k_sem_take(sem, timeout);
   2ab20:	a802      	add	r0, sp, #8
   2ab22:	f00c ff59 	bl	379d8 <z_impl_k_sem_take>
	__asm__ volatile(
   2ab26:	f04f 0320 	mov.w	r3, #32
   2ab2a:	f3ef 8b11 	mrs	fp, BASEPRI
   2ab2e:	f383 8811 	msr	BASEPRI, r3
   2ab32:	f3bf 8f6f 	isb	sy
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2ab36:	2000      	movs	r0, #0
   2ab38:	4b21      	ldr	r3, [pc, #132]	; (2abc0 <bsd_os_timedwait+0x124>)
   2ab3a:	681a      	ldr	r2, [r3, #0]
   2ab3c:	b152      	cbz	r2, 2ab54 <bsd_os_timedwait+0xb8>
   2ab3e:	4552      	cmp	r2, sl
   2ab40:	d139      	bne.n	2abb6 <bsd_os_timedwait+0x11a>
Z_GENLIST_REMOVE(slist, snode)
   2ab42:	9901      	ldr	r1, [sp, #4]
   2ab44:	bb88      	cbnz	r0, 2abaa <bsd_os_timedwait+0x10e>
   2ab46:	6858      	ldr	r0, [r3, #4]
	list->head = node;
   2ab48:	6019      	str	r1, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   2ab4a:	4290      	cmp	r0, r2
   2ab4c:	d100      	bne.n	2ab50 <bsd_os_timedwait+0xb4>
	list->tail = node;
   2ab4e:	6059      	str	r1, [r3, #4]
	parent->next = child;
   2ab50:	2300      	movs	r3, #0
   2ab52:	9301      	str	r3, [sp, #4]
	return z_impl_k_current_get();
   2ab54:	f00c fef0 	bl	37938 <z_impl_k_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   2ab58:	f7ff ff5c 	bl	2aa14 <thread_monitor_entry_get>
	entry->cnt = rpc_event_cnt;
   2ab5c:	f8d9 3000 	ldr.w	r3, [r9]
   2ab60:	6043      	str	r3, [r0, #4]
	__asm__ volatile(
   2ab62:	f38b 8811 	msr	BASEPRI, fp
   2ab66:	f3bf 8f6f 	isb	sy
	if (*timeout == K_FOREVER) {
   2ab6a:	f8d8 9000 	ldr.w	r9, [r8]
   2ab6e:	f1b9 3fff 	cmp.w	r9, #4294967295
   2ab72:	d011      	beq.n	2ab98 <bsd_os_timedwait+0xfc>
	return z_impl_k_uptime_get();
   2ab74:	f013 fdad 	bl	3e6d2 <z_impl_k_uptime_get>
	remaining = *timeout - (k_uptime_get() - start);
   2ab78:	eb16 0209 	adds.w	r2, r6, r9
   2ab7c:	eb47 73e9 	adc.w	r3, r7, r9, asr #31
   2ab80:	1a14      	subs	r4, r2, r0
   2ab82:	eb63 0501 	sbc.w	r5, r3, r1
	*timeout = remaining > 0 ? remaining : 0;
   2ab86:	2c00      	cmp	r4, #0
   2ab88:	f175 0300 	sbcs.w	r3, r5, #0
   2ab8c:	bfb8      	it	lt
   2ab8e:	2400      	movlt	r4, #0
   2ab90:	f8c8 4000 	str.w	r4, [r8]
	if (*timeout == 0) {
   2ab94:	2c00      	cmp	r4, #0
   2ab96:	d08f      	beq.n	2aab8 <bsd_os_timedwait+0x1c>
	return 0;
   2ab98:	2000      	movs	r0, #0
}
   2ab9a:	b009      	add	sp, #36	; 0x24
   2ab9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2aba0:	f8c2 a000 	str.w	sl, [r2]
	list->tail = node;
   2aba4:	f8c3 a004 	str.w	sl, [r3, #4]
   2aba8:	e7af      	b.n	2ab0a <bsd_os_timedwait+0x6e>
	parent->next = child;
   2abaa:	6001      	str	r1, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   2abac:	6859      	ldr	r1, [r3, #4]
   2abae:	4291      	cmp	r1, r2
	list->tail = node;
   2abb0:	bf08      	it	eq
   2abb2:	6058      	streq	r0, [r3, #4]
   2abb4:	e7cc      	b.n	2ab50 <bsd_os_timedwait+0xb4>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2abb6:	4610      	mov	r0, r2
   2abb8:	6812      	ldr	r2, [r2, #0]
   2abba:	e7bf      	b.n	2ab3c <bsd_os_timedwait+0xa0>
   2abbc:	20024c18 	.word	0x20024c18
   2abc0:	20024c1c 	.word	0x20024c1c

0002abc4 <bsd_os_errno_set>:
	switch (err_code) {
   2abc4:	282d      	cmp	r0, #45	; 0x2d
{
   2abc6:	b510      	push	{r4, lr}
   2abc8:	4604      	mov	r4, r0
	switch (err_code) {
   2abca:	f000 80a8 	beq.w	2ad1e <bsd_os_errno_set+0x15a>
   2abce:	dc50      	bgt.n	2ac72 <bsd_os_errno_set+0xae>
   2abd0:	2816      	cmp	r0, #22
   2abd2:	d009      	beq.n	2abe8 <bsd_os_errno_set+0x24>
   2abd4:	dc38      	bgt.n	2ac48 <bsd_os_errno_set+0x84>
   2abd6:	2808      	cmp	r0, #8
   2abd8:	d006      	beq.n	2abe8 <bsd_os_errno_set+0x24>
   2abda:	dc09      	bgt.n	2abf0 <bsd_os_errno_set+0x2c>
   2abdc:	2802      	cmp	r0, #2
   2abde:	d003      	beq.n	2abe8 <bsd_os_errno_set+0x24>
   2abe0:	2805      	cmp	r0, #5
   2abe2:	d001      	beq.n	2abe8 <bsd_os_errno_set+0x24>
   2abe4:	2801      	cmp	r0, #1
   2abe6:	d10c      	bne.n	2ac02 <bsd_os_errno_set+0x3e>
		errno = ENOBUFS;
   2abe8:	f011 ff9b 	bl	3cb22 <__errno>
   2abec:	6004      	str	r4, [r0, #0]
}
   2abee:	bd10      	pop	{r4, pc}
	switch (err_code) {
   2abf0:	280c      	cmp	r0, #12
   2abf2:	d0f9      	beq.n	2abe8 <bsd_os_errno_set+0x24>
   2abf4:	dc01      	bgt.n	2abfa <bsd_os_errno_set+0x36>
   2abf6:	2809      	cmp	r0, #9
   2abf8:	e7f5      	b.n	2abe6 <bsd_os_errno_set+0x22>
   2abfa:	280d      	cmp	r0, #13
   2abfc:	d0f4      	beq.n	2abe8 <bsd_os_errno_set+0x24>
   2abfe:	280e      	cmp	r0, #14
   2ac00:	d074      	beq.n	2acec <bsd_os_errno_set+0x128>
		__ASSERT(false, "Untranslated errno %d set by bsdlib!", err_code);
   2ac02:	f44f 73a5 	mov.w	r3, #330	; 0x14a
   2ac06:	4a63      	ldr	r2, [pc, #396]	; (2ad94 <bsd_os_errno_set+0x1d0>)
   2ac08:	4963      	ldr	r1, [pc, #396]	; (2ad98 <bsd_os_errno_set+0x1d4>)
   2ac0a:	4864      	ldr	r0, [pc, #400]	; (2ad9c <bsd_os_errno_set+0x1d8>)
   2ac0c:	f011 fd8e 	bl	3c72c <printk>
   2ac10:	4621      	mov	r1, r4
   2ac12:	4863      	ldr	r0, [pc, #396]	; (2ada0 <bsd_os_errno_set+0x1dc>)
   2ac14:	f011 fd8a 	bl	3c72c <printk>
   2ac18:	f44f 71a5 	mov.w	r1, #330	; 0x14a
   2ac1c:	485d      	ldr	r0, [pc, #372]	; (2ad94 <bsd_os_errno_set+0x1d0>)
   2ac1e:	f011 fdcb 	bl	3c7b8 <assert_post_action>
		LOG_ERR("Untranslated errno %d set by bsdlib!", err_code);
   2ac22:	2301      	movs	r3, #1
   2ac24:	f04f 0000 	mov.w	r0, #0
   2ac28:	4a5e      	ldr	r2, [pc, #376]	; (2ada4 <bsd_os_errno_set+0x1e0>)
   2ac2a:	f363 0007 	bfi	r0, r3, #0, #8
   2ac2e:	4b5e      	ldr	r3, [pc, #376]	; (2ada8 <bsd_os_errno_set+0x1e4>)
   2ac30:	495e      	ldr	r1, [pc, #376]	; (2adac <bsd_os_errno_set+0x1e8>)
   2ac32:	1a9b      	subs	r3, r3, r2
   2ac34:	08db      	lsrs	r3, r3, #3
   2ac36:	f363 108f 	bfi	r0, r3, #6, #10
   2ac3a:	4622      	mov	r2, r4
   2ac3c:	f011 fdcd 	bl	3c7da <log_string_sync>
		errno = 0xBAADBAAD;
   2ac40:	f011 ff6f 	bl	3cb22 <__errno>
   2ac44:	4b5a      	ldr	r3, [pc, #360]	; (2adb0 <bsd_os_errno_set+0x1ec>)
   2ac46:	e054      	b.n	2acf2 <bsd_os_errno_set+0x12e>
	switch (err_code) {
   2ac48:	2828      	cmp	r0, #40	; 0x28
   2ac4a:	f000 809f 	beq.w	2ad8c <bsd_os_errno_set+0x1c8>
   2ac4e:	dc05      	bgt.n	2ac5c <bsd_os_errno_set+0x98>
   2ac50:	2823      	cmp	r0, #35	; 0x23
   2ac52:	d050      	beq.n	2acf6 <bsd_os_errno_set+0x132>
   2ac54:	2825      	cmp	r0, #37	; 0x25
   2ac56:	d052      	beq.n	2acfe <bsd_os_errno_set+0x13a>
   2ac58:	2818      	cmp	r0, #24
   2ac5a:	e7c4      	b.n	2abe6 <bsd_os_errno_set+0x22>
   2ac5c:	282a      	cmp	r0, #42	; 0x2a
   2ac5e:	d056      	beq.n	2ad0e <bsd_os_errno_set+0x14a>
   2ac60:	db51      	blt.n	2ad06 <bsd_os_errno_set+0x142>
   2ac62:	282b      	cmp	r0, #43	; 0x2b
   2ac64:	d057      	beq.n	2ad16 <bsd_os_errno_set+0x152>
   2ac66:	282c      	cmp	r0, #44	; 0x2c
   2ac68:	d1cb      	bne.n	2ac02 <bsd_os_errno_set+0x3e>
		errno = ESOCKTNOSUPPORT;
   2ac6a:	f011 ff5a 	bl	3cb22 <__errno>
   2ac6e:	237c      	movs	r3, #124	; 0x7c
   2ac70:	e03f      	b.n	2acf2 <bsd_os_errno_set+0x12e>
	switch (err_code) {
   2ac72:	283c      	cmp	r0, #60	; 0x3c
   2ac74:	d06b      	beq.n	2ad4e <bsd_os_errno_set+0x18a>
   2ac76:	dc1d      	bgt.n	2acb4 <bsd_os_errno_set+0xf0>
   2ac78:	2833      	cmp	r0, #51	; 0x33
   2ac7a:	d05c      	beq.n	2ad36 <bsd_os_errno_set+0x172>
   2ac7c:	dc09      	bgt.n	2ac92 <bsd_os_errno_set+0xce>
   2ac7e:	2830      	cmp	r0, #48	; 0x30
   2ac80:	d051      	beq.n	2ad26 <bsd_os_errno_set+0x162>
   2ac82:	2832      	cmp	r0, #50	; 0x32
   2ac84:	d053      	beq.n	2ad2e <bsd_os_errno_set+0x16a>
   2ac86:	282f      	cmp	r0, #47	; 0x2f
   2ac88:	d1bb      	bne.n	2ac02 <bsd_os_errno_set+0x3e>
		errno = EAFNOSUPPORT;
   2ac8a:	f011 ff4a 	bl	3cb22 <__errno>
   2ac8e:	236a      	movs	r3, #106	; 0x6a
   2ac90:	e02f      	b.n	2acf2 <bsd_os_errno_set+0x12e>
	switch (err_code) {
   2ac92:	2836      	cmp	r0, #54	; 0x36
   2ac94:	d053      	beq.n	2ad3e <bsd_os_errno_set+0x17a>
   2ac96:	dc05      	bgt.n	2aca4 <bsd_os_errno_set+0xe0>
   2ac98:	2834      	cmp	r0, #52	; 0x34
   2ac9a:	d1b2      	bne.n	2ac02 <bsd_os_errno_set+0x3e>
		errno = ENETRESET;
   2ac9c:	f011 ff41 	bl	3cb22 <__errno>
   2aca0:	237e      	movs	r3, #126	; 0x7e
   2aca2:	e026      	b.n	2acf2 <bsd_os_errno_set+0x12e>
	switch (err_code) {
   2aca4:	2838      	cmp	r0, #56	; 0x38
   2aca6:	d04e      	beq.n	2ad46 <bsd_os_errno_set+0x182>
   2aca8:	2839      	cmp	r0, #57	; 0x39
   2acaa:	d1aa      	bne.n	2ac02 <bsd_os_errno_set+0x3e>
		errno = ENOTCONN;
   2acac:	f011 ff39 	bl	3cb22 <__errno>
   2acb0:	2380      	movs	r3, #128	; 0x80
   2acb2:	e01e      	b.n	2acf2 <bsd_os_errno_set+0x12e>
	switch (err_code) {
   2acb4:	287d      	cmp	r0, #125	; 0x7d
   2acb6:	d056      	beq.n	2ad66 <bsd_os_errno_set+0x1a2>
   2acb8:	dc0c      	bgt.n	2acd4 <bsd_os_errno_set+0x110>
   2acba:	2870      	cmp	r0, #112	; 0x70
   2acbc:	d04b      	beq.n	2ad56 <bsd_os_errno_set+0x192>
   2acbe:	dc01      	bgt.n	2acc4 <bsd_os_errno_set+0x100>
   2acc0:	2869      	cmp	r0, #105	; 0x69
   2acc2:	e790      	b.n	2abe6 <bsd_os_errno_set+0x22>
   2acc4:	2872      	cmp	r0, #114	; 0x72
   2acc6:	d04a      	beq.n	2ad5e <bsd_os_errno_set+0x19a>
   2acc8:	2873      	cmp	r0, #115	; 0x73
   2acca:	d19a      	bne.n	2ac02 <bsd_os_errno_set+0x3e>
		errno = EINPROGRESS;
   2accc:	f011 ff29 	bl	3cb22 <__errno>
   2acd0:	2377      	movs	r3, #119	; 0x77
   2acd2:	e00e      	b.n	2acf2 <bsd_os_errno_set+0x12e>
	switch (err_code) {
   2acd4:	287f      	cmp	r0, #127	; 0x7f
   2acd6:	d04f      	beq.n	2ad78 <bsd_os_errno_set+0x1b4>
   2acd8:	db49      	blt.n	2ad6e <bsd_os_errno_set+0x1aa>
   2acda:	2880      	cmp	r0, #128	; 0x80
   2acdc:	d051      	beq.n	2ad82 <bsd_os_errno_set+0x1be>
   2acde:	2881      	cmp	r0, #129	; 0x81
   2ace0:	d18f      	bne.n	2ac02 <bsd_os_errno_set+0x3e>
		errno = EKEYREJECTED;
   2ace2:	f011 ff1e 	bl	3cb22 <__errno>
   2ace6:	f240 73d4 	movw	r3, #2004	; 0x7d4
   2acea:	e002      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = EFAULT;
   2acec:	f011 ff19 	bl	3cb22 <__errno>
   2acf0:	230e      	movs	r3, #14
		errno = 0xBAADBAAD;
   2acf2:	6003      	str	r3, [r0, #0]
}
   2acf4:	e77b      	b.n	2abee <bsd_os_errno_set+0x2a>
		errno = EAGAIN;
   2acf6:	f011 ff14 	bl	3cb22 <__errno>
   2acfa:	230b      	movs	r3, #11
   2acfc:	e7f9      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = EDOM;
   2acfe:	f011 ff10 	bl	3cb22 <__errno>
   2ad02:	2321      	movs	r3, #33	; 0x21
   2ad04:	e7f5      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = EPROTOTYPE;
   2ad06:	f011 ff0c 	bl	3cb22 <__errno>
   2ad0a:	236b      	movs	r3, #107	; 0x6b
   2ad0c:	e7f1      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = ENOPROTOOPT;
   2ad0e:	f011 ff08 	bl	3cb22 <__errno>
   2ad12:	236d      	movs	r3, #109	; 0x6d
   2ad14:	e7ed      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = EPROTONOSUPPORT;
   2ad16:	f011 ff04 	bl	3cb22 <__errno>
   2ad1a:	237b      	movs	r3, #123	; 0x7b
   2ad1c:	e7e9      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = EOPNOTSUPP;
   2ad1e:	f011 ff00 	bl	3cb22 <__errno>
   2ad22:	235f      	movs	r3, #95	; 0x5f
   2ad24:	e7e5      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = EADDRINUSE;
   2ad26:	f011 fefc 	bl	3cb22 <__errno>
   2ad2a:	2370      	movs	r3, #112	; 0x70
   2ad2c:	e7e1      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = ENETDOWN;
   2ad2e:	f011 fef8 	bl	3cb22 <__errno>
   2ad32:	2373      	movs	r3, #115	; 0x73
   2ad34:	e7dd      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = ENETUNREACH;
   2ad36:	f011 fef4 	bl	3cb22 <__errno>
   2ad3a:	2372      	movs	r3, #114	; 0x72
   2ad3c:	e7d9      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = ECONNRESET;
   2ad3e:	f011 fef0 	bl	3cb22 <__errno>
   2ad42:	2368      	movs	r3, #104	; 0x68
   2ad44:	e7d5      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = EISCONN;
   2ad46:	f011 feec 	bl	3cb22 <__errno>
   2ad4a:	237f      	movs	r3, #127	; 0x7f
   2ad4c:	e7d1      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = ETIMEDOUT;
   2ad4e:	f011 fee8 	bl	3cb22 <__errno>
   2ad52:	2374      	movs	r3, #116	; 0x74
   2ad54:	e7cd      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = EHOSTDOWN;
   2ad56:	f011 fee4 	bl	3cb22 <__errno>
   2ad5a:	2375      	movs	r3, #117	; 0x75
   2ad5c:	e7c9      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = EALREADY;
   2ad5e:	f011 fee0 	bl	3cb22 <__errno>
   2ad62:	2378      	movs	r3, #120	; 0x78
   2ad64:	e7c5      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = ECANCELED;
   2ad66:	f011 fedc 	bl	3cb22 <__errno>
   2ad6a:	238c      	movs	r3, #140	; 0x8c
   2ad6c:	e7c1      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = ENOKEY;
   2ad6e:	f011 fed8 	bl	3cb22 <__errno>
   2ad72:	f240 73d1 	movw	r3, #2001	; 0x7d1
   2ad76:	e7bc      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = EKEYEXPIRED;
   2ad78:	f011 fed3 	bl	3cb22 <__errno>
   2ad7c:	f240 73d2 	movw	r3, #2002	; 0x7d2
   2ad80:	e7b7      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = EKEYREVOKED;
   2ad82:	f011 fece 	bl	3cb22 <__errno>
   2ad86:	f240 73d3 	movw	r3, #2003	; 0x7d3
   2ad8a:	e7b2      	b.n	2acf2 <bsd_os_errno_set+0x12e>
		errno = EMSGSIZE;
   2ad8c:	f011 fec9 	bl	3cb22 <__errno>
   2ad90:	237a      	movs	r3, #122	; 0x7a
   2ad92:	e7ae      	b.n	2acf2 <bsd_os_errno_set+0x12e>
   2ad94:	00042c8a 	.word	0x00042c8a
   2ad98:	00043e6b 	.word	0x00043e6b
   2ad9c:	00040606 	.word	0x00040606
   2ada0:	00042cae 	.word	0x00042cae
   2ada4:	0003f8d4 	.word	0x0003f8d4
   2ada8:	0003f8f4 	.word	0x0003f8f4
   2adac:	00042cd5 	.word	0x00042cd5
   2adb0:	baadbaad 	.word	0xbaadbaad

0002adb4 <bsd_os_application_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   2adb4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2adb8:	4b01      	ldr	r3, [pc, #4]	; (2adc0 <bsd_os_application_irq_set+0xc>)
   2adba:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   2adbe:	4770      	bx	lr
   2adc0:	e000e100 	.word	0xe000e100

0002adc4 <bsd_os_application_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   2adc4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2adc8:	4b01      	ldr	r3, [pc, #4]	; (2add0 <bsd_os_application_irq_clear+0xc>)
   2adca:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   2adce:	4770      	bx	lr
   2add0:	e000e100 	.word	0xe000e100

0002add4 <bsd_os_trace_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   2add4:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   2add8:	4b01      	ldr	r3, [pc, #4]	; (2ade0 <bsd_os_trace_irq_set+0xc>)
   2adda:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   2adde:	4770      	bx	lr
   2ade0:	e000e100 	.word	0xe000e100

0002ade4 <bsd_os_trace_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   2ade4:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   2ade8:	4b01      	ldr	r3, [pc, #4]	; (2adf0 <bsd_os_trace_irq_clear+0xc>)
   2adea:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   2adee:	4770      	bx	lr
   2adf0:	e000e100 	.word	0xe000e100

0002adf4 <bsd_os_init>:
#endif
}

/* This function is called by bsd_init and must not be called explicitly. */
void bsd_os_init(void)
{
   2adf4:	b508      	push	{r3, lr}
	list->head = NULL;
   2adf6:	2300      	movs	r3, #0
   2adf8:	4a07      	ldr	r2, [pc, #28]	; (2ae18 <bsd_os_init+0x24>)
	list->tail = NULL;
   2adfa:	e9c2 3300 	strd	r3, r3, [r2]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   2adfe:	4a07      	ldr	r2, [pc, #28]	; (2ae1c <bsd_os_init+0x28>)
   2ae00:	e8d2 1fef 	ldaex	r1, [r2]
   2ae04:	e8c2 3fe0 	stlex	r0, r3, [r2]
   2ae08:	2800      	cmp	r0, #0
   2ae0a:	d1f9      	bne.n	2ae00 <bsd_os_init+0xc>
	sys_slist_init(&sleeping_threads);
	atomic_clear(&rpc_event_cnt);

	read_task_create();
   2ae0c:	f012 fdab 	bl	3d966 <read_task_create>

	/* Configure and enable modem tracing over UART. */
	trace_uart_init();
	trace_task_create();
}
   2ae10:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	trace_task_create();
   2ae14:	f012 bd9c 	b.w	3d950 <trace_task_create>
   2ae18:	20024c1c 	.word	0x20024c1c
   2ae1c:	20024c18 	.word	0x20024c18

0002ae20 <z_to_nrf_optname>:
static int z_to_nrf_optname(int z_in_level, int z_in_optname,
			    int *nrf_out_optname)
{
	int retval = 0;

	switch (z_in_level) {
   2ae20:	f5b0 7f8d 	cmp.w	r0, #282	; 0x11a
   2ae24:	d03c      	beq.n	2aea0 <z_to_nrf_optname+0x80>
   2ae26:	dc04      	bgt.n	2ae32 <z_to_nrf_optname+0x12>
   2ae28:	2801      	cmp	r0, #1
   2ae2a:	d044      	beq.n	2aeb6 <z_to_nrf_optname+0x96>
			break;
		}
		break;

	default:
		retval = -1;
   2ae2c:	f04f 30ff 	mov.w	r0, #4294967295
		break;
	}

	return retval;
}
   2ae30:	4770      	bx	lr
	switch (z_in_level) {
   2ae32:	f240 2302 	movw	r3, #514	; 0x202
   2ae36:	4298      	cmp	r0, r3
   2ae38:	d052      	beq.n	2aee0 <z_to_nrf_optname+0xc0>
   2ae3a:	f240 2303 	movw	r3, #515	; 0x203
   2ae3e:	4298      	cmp	r0, r3
   2ae40:	d1f4      	bne.n	2ae2c <z_to_nrf_optname+0xc>
		switch (z_in_optname) {
   2ae42:	3901      	subs	r1, #1
   2ae44:	2913      	cmp	r1, #19
   2ae46:	d8f1      	bhi.n	2ae2c <z_to_nrf_optname+0xc>
   2ae48:	a301      	add	r3, pc, #4	; (adr r3, 2ae50 <z_to_nrf_optname+0x30>)
   2ae4a:	f853 f021 	ldr.w	pc, [r3, r1, lsl #2]
   2ae4e:	bf00      	nop
   2ae50:	0002aeed 	.word	0x0002aeed
   2ae54:	0002aeb1 	.word	0x0002aeb1
   2ae58:	0002aed1 	.word	0x0002aed1
   2ae5c:	0002aec3 	.word	0x0002aec3
   2ae60:	0002aed5 	.word	0x0002aed5
   2ae64:	0002aed9 	.word	0x0002aed9
   2ae68:	0002aedd 	.word	0x0002aedd
   2ae6c:	0002ae2d 	.word	0x0002ae2d
   2ae70:	0002ae2d 	.word	0x0002ae2d
   2ae74:	0002ae2d 	.word	0x0002ae2d
   2ae78:	0002ae2d 	.word	0x0002ae2d
   2ae7c:	0002ae2d 	.word	0x0002ae2d
   2ae80:	0002ae2d 	.word	0x0002ae2d
   2ae84:	0002ae2d 	.word	0x0002ae2d
   2ae88:	0002ae2d 	.word	0x0002ae2d
   2ae8c:	0002ae2d 	.word	0x0002ae2d
   2ae90:	0002ae2d 	.word	0x0002ae2d
   2ae94:	0002ae2d 	.word	0x0002ae2d
   2ae98:	0002ae2d 	.word	0x0002ae2d
   2ae9c:	0002aec7 	.word	0x0002aec7
		switch (z_in_optname) {
   2aea0:	3901      	subs	r1, #1
   2aea2:	2905      	cmp	r1, #5
   2aea4:	d8c2      	bhi.n	2ae2c <z_to_nrf_optname+0xc>
   2aea6:	e8df f001 	tbb	[pc, r1]
   2aeaa:	1503      	.short	0x1503
   2aeac:	210c1917 	.word	0x210c1917
			*nrf_out_optname = NRF_SO_SEC_TAG_LIST;
   2aeb0:	2302      	movs	r3, #2
			*nrf_out_optname = NRF_SO_DFU_OFFSET;
   2aeb2:	6013      	str	r3, [r2, #0]
   2aeb4:	e00a      	b.n	2aecc <z_to_nrf_optname+0xac>
		switch (z_in_optname) {
   2aeb6:	2914      	cmp	r1, #20
   2aeb8:	d005      	beq.n	2aec6 <z_to_nrf_optname+0xa6>
   2aeba:	2919      	cmp	r1, #25
   2aebc:	d005      	beq.n	2aeca <z_to_nrf_optname+0xaa>
   2aebe:	2904      	cmp	r1, #4
   2aec0:	d1b4      	bne.n	2ae2c <z_to_nrf_optname+0xc>
			*nrf_out_optname = NRF_SO_SEC_PEER_VERIFY;
   2aec2:	2304      	movs	r3, #4
   2aec4:	e7f5      	b.n	2aeb2 <z_to_nrf_optname+0x92>
			*nrf_out_optname = NRF_SO_RCVTIMEO;
   2aec6:	2314      	movs	r3, #20
   2aec8:	e7f3      	b.n	2aeb2 <z_to_nrf_optname+0x92>
			*nrf_out_optname = NRF_SO_BINDTODEVICE;
   2aeca:	6011      	str	r1, [r2, #0]
	int retval = 0;
   2aecc:	2000      	movs	r0, #0
			break;
   2aece:	4770      	bx	lr
			*nrf_out_optname = NRF_SO_DFU_TIMEO;
   2aed0:	2303      	movs	r3, #3
   2aed2:	e7ee      	b.n	2aeb2 <z_to_nrf_optname+0x92>
			*nrf_out_optname = NRF_SO_DFU_REVERT;
   2aed4:	2305      	movs	r3, #5
   2aed6:	e7ec      	b.n	2aeb2 <z_to_nrf_optname+0x92>
			*nrf_out_optname = NRF_SO_DFU_BACKUP_DELETE;
   2aed8:	2306      	movs	r3, #6
   2aeda:	e7ea      	b.n	2aeb2 <z_to_nrf_optname+0x92>
			*nrf_out_optname = NRF_SO_DFU_OFFSET;
   2aedc:	2307      	movs	r3, #7
   2aede:	e7e8      	b.n	2aeb2 <z_to_nrf_optname+0x92>
		switch (z_in_optname) {
   2aee0:	2902      	cmp	r1, #2
   2aee2:	d0e5      	beq.n	2aeb0 <z_to_nrf_optname+0x90>
   2aee4:	2903      	cmp	r1, #3
   2aee6:	d0f3      	beq.n	2aed0 <z_to_nrf_optname+0xb0>
   2aee8:	2901      	cmp	r1, #1
   2aeea:	d19f      	bne.n	2ae2c <z_to_nrf_optname+0xc>
			*nrf_out_optname = NRF_SO_SEC_ROLE;
   2aeec:	2301      	movs	r3, #1
   2aeee:	e7e0      	b.n	2aeb2 <z_to_nrf_optname+0x92>

0002aef0 <nrf91_socket_iface_init>:

static void nrf91_socket_iface_init(struct net_if *iface)
{
	nrf91_socket_iface_data.iface = iface;

	iface->if_dev->offloaded = true;
   2aef0:	2201      	movs	r2, #1
	nrf91_socket_iface_data.iface = iface;
   2aef2:	4b03      	ldr	r3, [pc, #12]	; (2af00 <nrf91_socket_iface_init+0x10>)
   2aef4:	6018      	str	r0, [r3, #0]
	iface->if_dev->offloaded = true;
   2aef6:	6803      	ldr	r3, [r0, #0]

	socket_offload_register(&nrf91_socket_offload_ops);
   2aef8:	4802      	ldr	r0, [pc, #8]	; (2af04 <nrf91_socket_iface_init+0x14>)
	iface->if_dev->offloaded = true;
   2aefa:	769a      	strb	r2, [r3, #26]
	socket_offload_register(&nrf91_socket_offload_ops);
   2aefc:	f7fc bc60 	b.w	277c0 <socket_offload_register>
   2af00:	20024c74 	.word	0x20024c74
   2af04:	0003ffe4 	.word	0x0003ffe4

0002af08 <close>:
{
   2af08:	b570      	push	{r4, r5, r6, lr}
	__ASSERT_NO_MSG(socket_ops);
   2af0a:	4c10      	ldr	r4, [pc, #64]	; (2af4c <close+0x44>)
{
   2af0c:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(socket_ops);
   2af0e:	6823      	ldr	r3, [r4, #0]
   2af10:	b94b      	cbnz	r3, 2af26 <close+0x1e>
   2af12:	490f      	ldr	r1, [pc, #60]	; (2af50 <close+0x48>)
   2af14:	480f      	ldr	r0, [pc, #60]	; (2af54 <close+0x4c>)
   2af16:	2321      	movs	r3, #33	; 0x21
   2af18:	4a0f      	ldr	r2, [pc, #60]	; (2af58 <close+0x50>)
   2af1a:	f011 fc07 	bl	3c72c <printk>
   2af1e:	2121      	movs	r1, #33	; 0x21
   2af20:	480d      	ldr	r0, [pc, #52]	; (2af58 <close+0x50>)
   2af22:	f011 fc49 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->close);
   2af26:	6823      	ldr	r3, [r4, #0]
   2af28:	685b      	ldr	r3, [r3, #4]
   2af2a:	b94b      	cbnz	r3, 2af40 <close+0x38>
   2af2c:	490b      	ldr	r1, [pc, #44]	; (2af5c <close+0x54>)
   2af2e:	4809      	ldr	r0, [pc, #36]	; (2af54 <close+0x4c>)
   2af30:	2322      	movs	r3, #34	; 0x22
   2af32:	4a09      	ldr	r2, [pc, #36]	; (2af58 <close+0x50>)
   2af34:	f011 fbfa 	bl	3c72c <printk>
   2af38:	2122      	movs	r1, #34	; 0x22
   2af3a:	4807      	ldr	r0, [pc, #28]	; (2af58 <close+0x50>)
   2af3c:	f011 fc3c 	bl	3c7b8 <assert_post_action>
	return socket_ops->close(sock);
   2af40:	6823      	ldr	r3, [r4, #0]
   2af42:	4628      	mov	r0, r5
}
   2af44:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return socket_ops->close(sock);
   2af48:	685b      	ldr	r3, [r3, #4]
   2af4a:	4718      	bx	r3
   2af4c:	20024aec 	.word	0x20024aec
   2af50:	000411aa 	.word	0x000411aa
   2af54:	00040606 	.word	0x00040606
   2af58:	0004117a 	.word	0x0004117a
   2af5c:	000427ae 	.word	0x000427ae

0002af60 <callback_worker>:

	return new_len;
}

static void callback_worker(struct k_work *item)
{
   2af60:	b507      	push	{r0, r1, r2, lr}
	struct callback_work_item *data =
   2af62:	9001      	str	r0, [sp, #4]
		CONTAINER_OF(item, struct callback_work_item, work);

	if (data != NULL) {
   2af64:	b118      	cbz	r0, 2af6e <callback_worker+0xe>
		data->callback(data->data);
   2af66:	f8d0 3a98 	ldr.w	r3, [r0, #2712]	; 0xa98
   2af6a:	300c      	adds	r0, #12
   2af6c:	4798      	blx	r3
	}

	k_mem_slab_free(&rsp_work_items, (void **)&data);
   2af6e:	a901      	add	r1, sp, #4
   2af70:	4802      	ldr	r0, [pc, #8]	; (2af7c <callback_worker+0x1c>)
   2af72:	f00a fd7b 	bl	35a6c <k_mem_slab_free>
}
   2af76:	b003      	add	sp, #12
   2af78:	f85d fb04 	ldr.w	pc, [sp], #4
   2af7c:	20037a44 	.word	0x20037a44

0002af80 <open_socket>:
{
   2af80:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(socket_ops);
   2af82:	4c16      	ldr	r4, [pc, #88]	; (2afdc <open_socket+0x5c>)
   2af84:	6823      	ldr	r3, [r4, #0]
   2af86:	b94b      	cbnz	r3, 2af9c <open_socket+0x1c>
   2af88:	4915      	ldr	r1, [pc, #84]	; (2afe0 <open_socket+0x60>)
   2af8a:	4816      	ldr	r0, [pc, #88]	; (2afe4 <open_socket+0x64>)
   2af8c:	2319      	movs	r3, #25
   2af8e:	4a16      	ldr	r2, [pc, #88]	; (2afe8 <open_socket+0x68>)
   2af90:	f011 fbcc 	bl	3c72c <printk>
   2af94:	2119      	movs	r1, #25
   2af96:	4814      	ldr	r0, [pc, #80]	; (2afe8 <open_socket+0x68>)
   2af98:	f011 fc0e 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->socket);
   2af9c:	6823      	ldr	r3, [r4, #0]
   2af9e:	681b      	ldr	r3, [r3, #0]
   2afa0:	b94b      	cbnz	r3, 2afb6 <open_socket+0x36>
   2afa2:	4912      	ldr	r1, [pc, #72]	; (2afec <open_socket+0x6c>)
   2afa4:	480f      	ldr	r0, [pc, #60]	; (2afe4 <open_socket+0x64>)
   2afa6:	231a      	movs	r3, #26
   2afa8:	4a0f      	ldr	r2, [pc, #60]	; (2afe8 <open_socket+0x68>)
   2afaa:	f011 fbbf 	bl	3c72c <printk>
   2afae:	211a      	movs	r1, #26
   2afb0:	480d      	ldr	r0, [pc, #52]	; (2afe8 <open_socket+0x68>)
   2afb2:	f011 fc01 	bl	3c7b8 <assert_post_action>
	return socket_ops->socket(family, type, proto);
   2afb6:	6823      	ldr	r3, [r4, #0]
   2afb8:	f240 2201 	movw	r2, #513	; 0x201
   2afbc:	681b      	ldr	r3, [r3, #0]
   2afbe:	2102      	movs	r1, #2
   2afc0:	2066      	movs	r0, #102	; 0x66
   2afc2:	4798      	blx	r3
	common_socket_fd = socket(AF_LTE, SOCK_DGRAM, NPROTO_AT);
   2afc4:	4b0a      	ldr	r3, [pc, #40]	; (2aff0 <open_socket+0x70>)
   2afc6:	6018      	str	r0, [r3, #0]
	if (common_socket_fd == -1) {
   2afc8:	3001      	adds	r0, #1
   2afca:	d104      	bne.n	2afd6 <open_socket+0x56>
		return -errno;
   2afcc:	f011 fda9 	bl	3cb22 <__errno>
   2afd0:	6800      	ldr	r0, [r0, #0]
   2afd2:	4240      	negs	r0, r0
}
   2afd4:	bd10      	pop	{r4, pc}
	return 0;
   2afd6:	2000      	movs	r0, #0
   2afd8:	e7fc      	b.n	2afd4 <open_socket+0x54>
   2afda:	bf00      	nop
   2afdc:	20024aec 	.word	0x20024aec
   2afe0:	000411aa 	.word	0x000411aa
   2afe4:	00040606 	.word	0x00040606
   2afe8:	0004117a 	.word	0x0004117a
   2afec:	000427c0 	.word	0x000427c0
   2aff0:	20024c78 	.word	0x20024c78

0002aff4 <at_write>:
		}
	}
}

static inline int at_write(const char *const cmd, enum at_cmd_state *state)
{
   2aff4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   2aff8:	4680      	mov	r8, r0
   2affa:	460d      	mov	r5, r1
	int bytes_sent;
	int bytes_to_send = strlen(cmd);
   2affc:	f7f2 f8ac 	bl	1d158 <strlen>
	__ASSERT_NO_MSG(socket_ops);
   2b000:	4c30      	ldr	r4, [pc, #192]	; (2b0c4 <at_write+0xd0>)
	struct return_state_object ret;

	LOG_DBG("Sending command %s", log_strdup(cmd));

	bytes_sent = send(common_socket_fd, cmd, bytes_to_send, 0);
   2b002:	4b31      	ldr	r3, [pc, #196]	; (2b0c8 <at_write+0xd4>)
	int bytes_to_send = strlen(cmd);
   2b004:	4606      	mov	r6, r0
	bytes_sent = send(common_socket_fd, cmd, bytes_to_send, 0);
   2b006:	681f      	ldr	r7, [r3, #0]
   2b008:	6823      	ldr	r3, [r4, #0]
   2b00a:	b94b      	cbnz	r3, 2b020 <at_write+0x2c>
   2b00c:	492f      	ldr	r1, [pc, #188]	; (2b0cc <at_write+0xd8>)
   2b00e:	4830      	ldr	r0, [pc, #192]	; (2b0d0 <at_write+0xdc>)
   2b010:	237e      	movs	r3, #126	; 0x7e
   2b012:	4a30      	ldr	r2, [pc, #192]	; (2b0d4 <at_write+0xe0>)
   2b014:	f011 fb8a 	bl	3c72c <printk>
   2b018:	217e      	movs	r1, #126	; 0x7e
   2b01a:	482e      	ldr	r0, [pc, #184]	; (2b0d4 <at_write+0xe0>)
   2b01c:	f011 fbcc 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->send);
   2b020:	6823      	ldr	r3, [r4, #0]
   2b022:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2b024:	b94b      	cbnz	r3, 2b03a <at_write+0x46>
   2b026:	492c      	ldr	r1, [pc, #176]	; (2b0d8 <at_write+0xe4>)
   2b028:	4829      	ldr	r0, [pc, #164]	; (2b0d0 <at_write+0xdc>)
   2b02a:	237f      	movs	r3, #127	; 0x7f
   2b02c:	4a29      	ldr	r2, [pc, #164]	; (2b0d4 <at_write+0xe0>)
   2b02e:	f011 fb7d 	bl	3c72c <printk>
   2b032:	217f      	movs	r1, #127	; 0x7f
   2b034:	4827      	ldr	r0, [pc, #156]	; (2b0d4 <at_write+0xe0>)
   2b036:	f011 fbbf 	bl	3c7b8 <assert_post_action>
	return socket_ops->send(sock, buf, len, flags);
   2b03a:	6823      	ldr	r3, [r4, #0]
   2b03c:	4632      	mov	r2, r6
   2b03e:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   2b040:	4641      	mov	r1, r8
   2b042:	2300      	movs	r3, #0
   2b044:	4638      	mov	r0, r7
   2b046:	47a0      	blx	r4

	if (bytes_sent == -1) {
   2b048:	1c43      	adds	r3, r0, #1
   2b04a:	4604      	mov	r4, r0
   2b04c:	d121      	bne.n	2b092 <at_write+0x9e>
		LOG_ERR("Failed to send AT command (err:%d)", errno);
   2b04e:	2301      	movs	r3, #1
   2b050:	f04f 0400 	mov.w	r4, #0
   2b054:	4a21      	ldr	r2, [pc, #132]	; (2b0dc <at_write+0xe8>)
   2b056:	f363 0407 	bfi	r4, r3, #0, #8
   2b05a:	4b21      	ldr	r3, [pc, #132]	; (2b0e0 <at_write+0xec>)
   2b05c:	1a9b      	subs	r3, r3, r2
   2b05e:	08db      	lsrs	r3, r3, #3
   2b060:	f363 148f 	bfi	r4, r3, #6, #10
   2b064:	f011 fd5d 	bl	3cb22 <__errno>
   2b068:	491e      	ldr	r1, [pc, #120]	; (2b0e4 <at_write+0xf0>)
   2b06a:	6802      	ldr	r2, [r0, #0]
   2b06c:	4620      	mov	r0, r4
   2b06e:	f011 fbb4 	bl	3c7da <log_string_sync>
		ret.code  = -errno;
   2b072:	f011 fd56 	bl	3cb22 <__errno>
   2b076:	6803      	ldr	r3, [r0, #0]
   2b078:	425b      	negs	r3, r3
   2b07a:	9300      	str	r3, [sp, #0]
		ret.state = AT_CMD_ERROR;
   2b07c:	2301      	movs	r3, #1
   2b07e:	f88d 3004 	strb.w	r3, [sp, #4]
				"same as expected (%d)",
				bytes_sent, bytes_to_send);
		}
	}

	if (state) {
   2b082:	b115      	cbz	r5, 2b08a <at_write+0x96>
		*state = ret.state;
   2b084:	f89d 3004 	ldrb.w	r3, [sp, #4]
   2b088:	702b      	strb	r3, [r5, #0]
	}

	return ret.code;
}
   2b08a:	9800      	ldr	r0, [sp, #0]
   2b08c:	b002      	add	sp, #8
   2b08e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&msgq, *(uintptr_t *)&data, *(uintptr_t *)&timeout, K_SYSCALL_K_MSGQ_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_get(msgq, data, timeout);
   2b092:	f04f 32ff 	mov.w	r2, #4294967295
   2b096:	4669      	mov	r1, sp
   2b098:	4813      	ldr	r0, [pc, #76]	; (2b0e8 <at_write+0xf4>)
   2b09a:	f00a fef9 	bl	35e90 <z_impl_k_msgq_get>
		if (bytes_sent != bytes_to_send) {
   2b09e:	42a6      	cmp	r6, r4
   2b0a0:	d0ef      	beq.n	2b082 <at_write+0x8e>
			LOG_ERR("Bytes sent (%d) was not the "
   2b0a2:	2301      	movs	r3, #1
   2b0a4:	f04f 0000 	mov.w	r0, #0
   2b0a8:	4a0c      	ldr	r2, [pc, #48]	; (2b0dc <at_write+0xe8>)
   2b0aa:	f363 0007 	bfi	r0, r3, #0, #8
   2b0ae:	4b0c      	ldr	r3, [pc, #48]	; (2b0e0 <at_write+0xec>)
   2b0b0:	490e      	ldr	r1, [pc, #56]	; (2b0ec <at_write+0xf8>)
   2b0b2:	1a9b      	subs	r3, r3, r2
   2b0b4:	08db      	lsrs	r3, r3, #3
   2b0b6:	f363 108f 	bfi	r0, r3, #6, #10
   2b0ba:	4622      	mov	r2, r4
   2b0bc:	4633      	mov	r3, r6
   2b0be:	f011 fb8c 	bl	3c7da <log_string_sync>
   2b0c2:	e7de      	b.n	2b082 <at_write+0x8e>
   2b0c4:	20024aec 	.word	0x20024aec
   2b0c8:	20024c78 	.word	0x20024c78
   2b0cc:	000411aa 	.word	0x000411aa
   2b0d0:	00040606 	.word	0x00040606
   2b0d4:	0004117a 	.word	0x0004117a
   2b0d8:	000427f8 	.word	0x000427f8
   2b0dc:	0003f8d4 	.word	0x0003f8d4
   2b0e0:	0003f8dc 	.word	0x0003f8dc
   2b0e4:	00042d6d 	.word	0x00042d6d
   2b0e8:	20037b40 	.word	0x20037b40
   2b0ec:	00042d90 	.word	0x00042d90

0002b0f0 <socket_thread_fn>:
{
   2b0f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
					LOG_ERR("Response buffer not large "
   2b0f4:	4b9e      	ldr	r3, [pc, #632]	; (2b370 <socket_thread_fn+0x280>)
   2b0f6:	4c9f      	ldr	r4, [pc, #636]	; (2b374 <socket_thread_fn+0x284>)
{
   2b0f8:	b087      	sub	sp, #28
					LOG_ERR("Response buffer not large "
   2b0fa:	1ae4      	subs	r4, r4, r3
   2b0fc:	f3c4 04c9 	ubfx	r4, r4, #3, #10
		k_mem_slab_alloc(&rsp_work_items, (void **)&item, K_FOREVER);
   2b100:	f04f 32ff 	mov.w	r2, #4294967295
   2b104:	a903      	add	r1, sp, #12
   2b106:	489c      	ldr	r0, [pc, #624]	; (2b378 <socket_thread_fn+0x288>)
   2b108:	f00a fc4c 	bl	359a4 <k_mem_slab_alloc>
		ret.code  = 0;
   2b10c:	2300      	movs	r3, #0
		item->callback = NULL;
   2b10e:	9d03      	ldr	r5, [sp, #12]
		ret.code  = 0;
   2b110:	9304      	str	r3, [sp, #16]
		item->callback = NULL;
   2b112:	f8c5 3a98 	str.w	r3, [r5, #2712]	; 0xa98
		ret.state = AT_CMD_OK;
   2b116:	f88d 3014 	strb.w	r3, [sp, #20]
	__ASSERT_NO_MSG(socket_ops);
   2b11a:	f8df a2b4 	ldr.w	sl, [pc, #692]	; 2b3d0 <socket_thread_fn+0x2e0>
		bytes_read = recv(common_socket_fd, item->data,
   2b11e:	4b97      	ldr	r3, [pc, #604]	; (2b37c <socket_thread_fn+0x28c>)
   2b120:	350c      	adds	r5, #12
   2b122:	f8d3 b000 	ldr.w	fp, [r3]
   2b126:	f8da 3000 	ldr.w	r3, [sl]
   2b12a:	b94b      	cbnz	r3, 2b140 <socket_thread_fn+0x50>
   2b12c:	4994      	ldr	r1, [pc, #592]	; (2b380 <socket_thread_fn+0x290>)
   2b12e:	4895      	ldr	r0, [pc, #596]	; (2b384 <socket_thread_fn+0x294>)
   2b130:	2369      	movs	r3, #105	; 0x69
   2b132:	4a95      	ldr	r2, [pc, #596]	; (2b388 <socket_thread_fn+0x298>)
   2b134:	f011 fafa 	bl	3c72c <printk>
   2b138:	2169      	movs	r1, #105	; 0x69
   2b13a:	4893      	ldr	r0, [pc, #588]	; (2b388 <socket_thread_fn+0x298>)
   2b13c:	f011 fb3c 	bl	3c7b8 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->recv);
   2b140:	f8da 3000 	ldr.w	r3, [sl]
   2b144:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   2b146:	b94b      	cbnz	r3, 2b15c <socket_thread_fn+0x6c>
   2b148:	4990      	ldr	r1, [pc, #576]	; (2b38c <socket_thread_fn+0x29c>)
   2b14a:	488e      	ldr	r0, [pc, #568]	; (2b384 <socket_thread_fn+0x294>)
   2b14c:	236a      	movs	r3, #106	; 0x6a
   2b14e:	4a8e      	ldr	r2, [pc, #568]	; (2b388 <socket_thread_fn+0x298>)
   2b150:	f011 faec 	bl	3c72c <printk>
   2b154:	216a      	movs	r1, #106	; 0x6a
   2b156:	488c      	ldr	r0, [pc, #560]	; (2b388 <socket_thread_fn+0x298>)
   2b158:	f011 fb2e 	bl	3c7b8 <assert_post_action>
	return socket_ops->recv(sock, buf, max_len, flags);
   2b15c:	f8da 3000 	ldr.w	r3, [sl]
   2b160:	f640 228c 	movw	r2, #2700	; 0xa8c
   2b164:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
   2b168:	4629      	mov	r1, r5
   2b16a:	2300      	movs	r3, #0
   2b16c:	4658      	mov	r0, fp
   2b16e:	47d0      	blx	sl
		if (bytes_read < 0) {
   2b170:	1e02      	subs	r2, r0, #0
   2b172:	da58      	bge.n	2b226 <socket_thread_fn+0x136>
			LOG_ERR("AT socket recv failed with err %d",
   2b174:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   2b178:	f043 0301 	orr.w	r3, r3, #1
   2b17c:	f363 0607 	bfi	r6, r3, #0, #8
   2b180:	f364 168f 	bfi	r6, r4, #6, #10
   2b184:	4630      	mov	r0, r6
   2b186:	4982      	ldr	r1, [pc, #520]	; (2b390 <socket_thread_fn+0x2a0>)
   2b188:	f011 fb27 	bl	3c7da <log_string_sync>
			if ((close(common_socket_fd) == 0) &&
   2b18c:	4b7b      	ldr	r3, [pc, #492]	; (2b37c <socket_thread_fn+0x28c>)
   2b18e:	6818      	ldr	r0, [r3, #0]
   2b190:	f7ff feba 	bl	2af08 <close>
   2b194:	2800      	cmp	r0, #0
   2b196:	d131      	bne.n	2b1fc <socket_thread_fn+0x10c>
			    (open_socket() == 0)) {
   2b198:	f7ff fef2 	bl	2af80 <open_socket>
			if ((close(common_socket_fd) == 0) &&
   2b19c:	bb70      	cbnz	r0, 2b1fc <socket_thread_fn+0x10c>
				LOG_INF("AT socket recovered");
   2b19e:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
   2b1a2:	f043 0303 	orr.w	r3, r3, #3
   2b1a6:	f363 0707 	bfi	r7, r3, #0, #8
   2b1aa:	f364 178f 	bfi	r7, r4, #6, #10
   2b1ae:	4979      	ldr	r1, [pc, #484]	; (2b394 <socket_thread_fn+0x2a4>)
   2b1b0:	4638      	mov	r0, r7
   2b1b2:	f011 fb12 	bl	3c7da <log_string_sync>
				ret.state = AT_CMD_ERROR;
   2b1b6:	2301      	movs	r3, #1
   2b1b8:	f88d 3014 	strb.w	r3, [sp, #20]
				ret.code  = -errno;
   2b1bc:	f011 fcb1 	bl	3cb22 <__errno>
   2b1c0:	6803      	ldr	r3, [r0, #0]
   2b1c2:	425b      	negs	r3, r3
			ret.code  = -ENOBUFS;
   2b1c4:	9304      	str	r3, [sp, #16]
		if (item->callback == NULL) {
   2b1c6:	9903      	ldr	r1, [sp, #12]
   2b1c8:	f8d1 3a98 	ldr.w	r3, [r1, #2712]	; 0xa98
   2b1cc:	2b00      	cmp	r3, #0
   2b1ce:	f040 80a5 	bne.w	2b31c <socket_thread_fn+0x22c>
			k_mem_slab_free(&rsp_work_items, (void **)&item);
   2b1d2:	a903      	add	r1, sp, #12
   2b1d4:	4868      	ldr	r0, [pc, #416]	; (2b378 <socket_thread_fn+0x288>)
   2b1d6:	f00a fc49 	bl	35a6c <k_mem_slab_free>
	return z_impl_k_sem_count_get(sem);
   2b1da:	4b6f      	ldr	r3, [pc, #444]	; (2b398 <socket_thread_fn+0x2a8>)
		if ((k_sem_count_get(&cmd_pending) == 0) &&
   2b1dc:	689b      	ldr	r3, [r3, #8]
   2b1de:	2b00      	cmp	r3, #0
   2b1e0:	d18e      	bne.n	2b100 <socket_thread_fn+0x10>
   2b1e2:	f89d 2014 	ldrb.w	r2, [sp, #20]
   2b1e6:	2a04      	cmp	r2, #4
   2b1e8:	d08a      	beq.n	2b100 <socket_thread_fn+0x10>
			current_cmd_handler = NULL;
   2b1ea:	4a6c      	ldr	r2, [pc, #432]	; (2b39c <socket_thread_fn+0x2ac>)
   2b1ec:	6013      	str	r3, [r2, #0]
	return z_impl_k_msgq_put(msgq, data, timeout);
   2b1ee:	f04f 32ff 	mov.w	r2, #4294967295
   2b1f2:	a904      	add	r1, sp, #16
   2b1f4:	486a      	ldr	r0, [pc, #424]	; (2b3a0 <socket_thread_fn+0x2b0>)
   2b1f6:	f00a fdab 	bl	35d50 <z_impl_k_msgq_put>
   2b1fa:	e781      	b.n	2b100 <socket_thread_fn+0x10>
			LOG_ERR("Unrecoverable reception error (err: %d), "
   2b1fc:	2301      	movs	r3, #1
   2b1fe:	f04f 0500 	mov.w	r5, #0
   2b202:	f363 0507 	bfi	r5, r3, #0, #8
   2b206:	f011 fc8c 	bl	3cb22 <__errno>
   2b20a:	f364 158f 	bfi	r5, r4, #6, #10
   2b20e:	6802      	ldr	r2, [r0, #0]
   2b210:	4964      	ldr	r1, [pc, #400]	; (2b3a4 <socket_thread_fn+0x2b4>)
   2b212:	4628      	mov	r0, r5
   2b214:	f011 fae1 	bl	3c7da <log_string_sync>
			close(common_socket_fd);
   2b218:	4b58      	ldr	r3, [pc, #352]	; (2b37c <socket_thread_fn+0x28c>)
   2b21a:	6818      	ldr	r0, [r3, #0]
   2b21c:	f7ff fe74 	bl	2af08 <close>
}
   2b220:	b007      	add	sp, #28
   2b222:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (bytes_read == sizeof(item->data) ||
   2b226:	f640 238c 	movw	r3, #2700	; 0xa8c
   2b22a:	429a      	cmp	r2, r3
   2b22c:	d004      	beq.n	2b238 <socket_thread_fn+0x148>
			   item->data[bytes_read - 1] != '\0') {
   2b22e:	f8dd a00c 	ldr.w	sl, [sp, #12]
   2b232:	4452      	add	r2, sl
		} else if (bytes_read == sizeof(item->data) ||
   2b234:	7ad3      	ldrb	r3, [r2, #11]
   2b236:	b173      	cbz	r3, 2b256 <socket_thread_fn+0x166>
			LOG_ERR("AT message to large for reception buffer or "
   2b238:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   2b23c:	f043 0301 	orr.w	r3, r3, #1
   2b240:	f363 0807 	bfi	r8, r3, #0, #8
   2b244:	f364 188f 	bfi	r8, r4, #6, #10
   2b248:	4957      	ldr	r1, [pc, #348]	; (2b3a8 <socket_thread_fn+0x2b8>)
   2b24a:	4640      	mov	r0, r8
   2b24c:	f011 fac5 	bl	3c7da <log_string_sync>
			ret.code  = -ENOBUFS;
   2b250:	f06f 0368 	mvn.w	r3, #104	; 0x68
   2b254:	e7b6      	b.n	2b1c4 <socket_thread_fn+0xd4>
	ret->state = AT_CMD_NOTIFICATION;
   2b256:	2204      	movs	r2, #4
		payload_len = get_return_code(item->data, &ret);
   2b258:	f10a 050c 	add.w	r5, sl, #12
		tmpstr = strstr(buf, AT_CMD_OK_STR);
   2b25c:	4953      	ldr	r1, [pc, #332]	; (2b3ac <socket_thread_fn+0x2bc>)
   2b25e:	4628      	mov	r0, r5
   2b260:	9301      	str	r3, [sp, #4]
	ret->state = AT_CMD_NOTIFICATION;
   2b262:	f88d 2014 	strb.w	r2, [sp, #20]
		tmpstr = strstr(buf, AT_CMD_OK_STR);
   2b266:	f013 fca7 	bl	3ebb8 <strstr>
		if (tmpstr) {
   2b26a:	4683      	mov	fp, r0
   2b26c:	b120      	cbz	r0, 2b278 <socket_thread_fn+0x188>
			ret->state = AT_CMD_OK;
   2b26e:	9b01      	ldr	r3, [sp, #4]
   2b270:	f88d 3014 	strb.w	r3, [sp, #20]
			ret->code  = -ENOEXEC;
   2b274:	9304      	str	r3, [sp, #16]
			break;
   2b276:	e00d      	b.n	2b294 <socket_thread_fn+0x1a4>
		tmpstr = strstr(buf, AT_CMD_CMS_STR);
   2b278:	494d      	ldr	r1, [pc, #308]	; (2b3b0 <socket_thread_fn+0x2c0>)
   2b27a:	4628      	mov	r0, r5
   2b27c:	f013 fc9c 	bl	3ebb8 <strstr>
		if (tmpstr) {
   2b280:	4683      	mov	fp, r0
   2b282:	b330      	cbz	r0, 2b2d2 <socket_thread_fn+0x1e2>
			ret->state = AT_CMD_ERROR_CMS;
   2b284:	2302      	movs	r3, #2
			ret->code = atoi(&buf[ARRAY_SIZE(AT_CMD_CMS_STR) - 1]);
   2b286:	f10a 0017 	add.w	r0, sl, #23
			ret->state = AT_CMD_ERROR_CME;
   2b28a:	f88d 3014 	strb.w	r3, [sp, #20]
			ret->code = atoi(&buf[ARRAY_SIZE(AT_CMD_CMS_STR) - 1]);
   2b28e:	f013 fabd 	bl	3e80c <atoi>
   2b292:	9004      	str	r0, [sp, #16]
		buf[new_len++] = '\0';
   2b294:	2300      	movs	r3, #0
		new_len = tmpstr - buf;
   2b296:	ebab 0205 	sub.w	r2, fp, r5
		buf[new_len++] = '\0';
   2b29a:	3201      	adds	r2, #1
   2b29c:	f88b 3000 	strb.w	r3, [fp]
		if (ret.state != AT_CMD_NOTIFICATION) {
   2b2a0:	f89d 3014 	ldrb.w	r3, [sp, #20]
   2b2a4:	2b04      	cmp	r3, #4
   2b2a6:	d04f      	beq.n	2b348 <socket_thread_fn+0x258>
			if ((response_buf_len > 0) &&
   2b2a8:	f8df a128 	ldr.w	sl, [pc, #296]	; 2b3d4 <socket_thread_fn+0x2e4>
   2b2ac:	f8da 3000 	ldr.w	r3, [sl]
   2b2b0:	2b00      	cmp	r3, #0
   2b2b2:	d052      	beq.n	2b35a <socket_thread_fn+0x26a>
			    (response_buf != NULL)) {
   2b2b4:	4d3f      	ldr	r5, [pc, #252]	; (2b3b4 <socket_thread_fn+0x2c4>)
   2b2b6:	6828      	ldr	r0, [r5, #0]
			if ((response_buf_len > 0) &&
   2b2b8:	2800      	cmp	r0, #0
   2b2ba:	d04e      	beq.n	2b35a <socket_thread_fn+0x26a>
				if (response_buf_len > payload_len) {
   2b2bc:	4293      	cmp	r3, r2
   2b2be:	d91d      	bls.n	2b2fc <socket_thread_fn+0x20c>
   2b2c0:	9903      	ldr	r1, [sp, #12]
   2b2c2:	310c      	adds	r1, #12
   2b2c4:	f013 fac2 	bl	3e84c <memcpy>
				response_buf_len = 0;
   2b2c8:	2300      	movs	r3, #0
   2b2ca:	f8ca 3000 	str.w	r3, [sl]
				response_buf     = NULL;
   2b2ce:	602b      	str	r3, [r5, #0]
				goto next;
   2b2d0:	e779      	b.n	2b1c6 <socket_thread_fn+0xd6>
		tmpstr = strstr(buf, AT_CMD_CME_STR);
   2b2d2:	4939      	ldr	r1, [pc, #228]	; (2b3b8 <socket_thread_fn+0x2c8>)
   2b2d4:	4628      	mov	r0, r5
   2b2d6:	f013 fc6f 	bl	3ebb8 <strstr>
		if (tmpstr) {
   2b2da:	4683      	mov	fp, r0
   2b2dc:	b108      	cbz	r0, 2b2e2 <socket_thread_fn+0x1f2>
			ret->state = AT_CMD_ERROR_CME;
   2b2de:	2303      	movs	r3, #3
   2b2e0:	e7d1      	b.n	2b286 <socket_thread_fn+0x196>
		tmpstr = strstr(buf, AT_CMD_ERROR_STR);
   2b2e2:	4936      	ldr	r1, [pc, #216]	; (2b3bc <socket_thread_fn+0x2cc>)
   2b2e4:	4628      	mov	r0, r5
   2b2e6:	f013 fc67 	bl	3ebb8 <strstr>
		if (tmpstr) {
   2b2ea:	4683      	mov	fp, r0
   2b2ec:	2800      	cmp	r0, #0
   2b2ee:	d039      	beq.n	2b364 <socket_thread_fn+0x274>
			ret->state = AT_CMD_ERROR;
   2b2f0:	2301      	movs	r3, #1
   2b2f2:	f88d 3014 	strb.w	r3, [sp, #20]
			ret->code  = -ENOEXEC;
   2b2f6:	f06f 0307 	mvn.w	r3, #7
   2b2fa:	e7bb      	b.n	2b274 <socket_thread_fn+0x184>
					LOG_ERR("Response buffer not large "
   2b2fc:	f029 033f 	bic.w	r3, r9, #63	; 0x3f
   2b300:	f043 0301 	orr.w	r3, r3, #1
   2b304:	f363 0907 	bfi	r9, r3, #0, #8
   2b308:	f364 198f 	bfi	r9, r4, #6, #10
   2b30c:	492c      	ldr	r1, [pc, #176]	; (2b3c0 <socket_thread_fn+0x2d0>)
   2b30e:	4648      	mov	r0, r9
   2b310:	f011 fa63 	bl	3c7da <log_string_sync>
					ret.code  = -EMSGSIZE;
   2b314:	f06f 0379 	mvn.w	r3, #121	; 0x79
   2b318:	9304      	str	r3, [sp, #16]
   2b31a:	e7d5      	b.n	2b2c8 <socket_thread_fn+0x1d8>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   2b31c:	4b29      	ldr	r3, [pc, #164]	; (2b3c4 <socket_thread_fn+0x2d4>)
   2b31e:	2200      	movs	r2, #0
   2b320:	604b      	str	r3, [r1, #4]
   2b322:	460b      	mov	r3, r1
   2b324:	600a      	str	r2, [r1, #0]
   2b326:	f843 2f08 	str.w	r2, [r3, #8]!
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2b32a:	e8d3 2fef 	ldaex	r2, [r3]
   2b32e:	f042 0001 	orr.w	r0, r2, #1
   2b332:	e8c3 0fe5 	stlex	r5, r0, [r3]
   2b336:	2d00      	cmp	r5, #0
   2b338:	d1f7      	bne.n	2b32a <socket_thread_fn+0x23a>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   2b33a:	07d3      	lsls	r3, r2, #31
   2b33c:	f53f af4d 	bmi.w	2b1da <socket_thread_fn+0xea>
		k_queue_append(&work_q->queue, work);
   2b340:	4821      	ldr	r0, [pc, #132]	; (2b3c8 <socket_thread_fn+0x2d8>)
   2b342:	f013 f8ea 	bl	3e51a <k_queue_append>
   2b346:	e748      	b.n	2b1da <socket_thread_fn+0xea>
		if (payload_len == 0) {
   2b348:	2a00      	cmp	r2, #0
   2b34a:	f43f af3c 	beq.w	2b1c6 <socket_thread_fn+0xd6>
			item->callback = notification_handler;
   2b34e:	4b1f      	ldr	r3, [pc, #124]	; (2b3cc <socket_thread_fn+0x2dc>)
			item->callback = current_cmd_handler;
   2b350:	681a      	ldr	r2, [r3, #0]
   2b352:	9b03      	ldr	r3, [sp, #12]
   2b354:	f8c3 2a98 	str.w	r2, [r3, #2712]	; 0xa98
   2b358:	e735      	b.n	2b1c6 <socket_thread_fn+0xd6>
		if (payload_len == 0) {
   2b35a:	2a00      	cmp	r2, #0
   2b35c:	f43f af33 	beq.w	2b1c6 <socket_thread_fn+0xd6>
			item->callback = current_cmd_handler;
   2b360:	4b0e      	ldr	r3, [pc, #56]	; (2b39c <socket_thread_fn+0x2ac>)
   2b362:	e7f5      	b.n	2b350 <socket_thread_fn+0x260>
		new_len = strlen(buf) + 1;
   2b364:	4628      	mov	r0, r5
   2b366:	f7f1 fef7 	bl	1d158 <strlen>
   2b36a:	1c42      	adds	r2, r0, #1
   2b36c:	e798      	b.n	2b2a0 <socket_thread_fn+0x1b0>
   2b36e:	bf00      	nop
   2b370:	0003f8d4 	.word	0x0003f8d4
   2b374:	0003f8dc 	.word	0x0003f8dc
   2b378:	20037a44 	.word	0x20037a44
   2b37c:	20024c78 	.word	0x20024c78
   2b380:	000411aa 	.word	0x000411aa
   2b384:	00040606 	.word	0x00040606
   2b388:	0004117a 	.word	0x0004117a
   2b38c:	000427e7 	.word	0x000427e7
   2b390:	00042dc2 	.word	0x00042dc2
   2b394:	00042de4 	.word	0x00042de4
   2b398:	20037aac 	.word	0x20037aac
   2b39c:	20024c7c 	.word	0x20024c7c
   2b3a0:	20037b40 	.word	0x20037b40
   2b3a4:	00042df8 	.word	0x00042df8
   2b3a8:	00042e2f 	.word	0x00042e2f
   2b3ac:	000416a1 	.word	0x000416a1
   2b3b0:	00042e79 	.word	0x00042e79
   2b3b4:	20024c84 	.word	0x20024c84
   2b3b8:	00042e85 	.word	0x00042e85
   2b3bc:	00042e91 	.word	0x00042e91
   2b3c0:	00042e97 	.word	0x00042e97
   2b3c4:	0002af61 	.word	0x0002af61
   2b3c8:	200297b4 	.word	0x200297b4
   2b3cc:	20024c80 	.word	0x20024c80
   2b3d0:	20024aec 	.word	0x20024aec
   2b3d4:	20024c88 	.word	0x20024c88

0002b3d8 <at_cmd_driver_init>:

	k_sem_give(&cmd_pending);
}

static int at_cmd_driver_init(struct device *dev)
{
   2b3d8:	b510      	push	{r4, lr}
	static bool initialized;

	if (initialized) {
   2b3da:	4b16      	ldr	r3, [pc, #88]	; (2b434 <at_cmd_driver_init+0x5c>)
{
   2b3dc:	b086      	sub	sp, #24
	if (initialized) {
   2b3de:	781a      	ldrb	r2, [r3, #0]
   2b3e0:	bb32      	cbnz	r2, 2b430 <at_cmd_driver_init+0x58>
		return 0;
	}

	initialized = true;
   2b3e2:	2201      	movs	r2, #1
   2b3e4:	701a      	strb	r2, [r3, #0]

	int err;

	ARG_UNUSED(dev);

	err = open_socket();
   2b3e6:	f7ff fdcb 	bl	2af80 <open_socket>
	if (err) {
   2b3ea:	4604      	mov	r4, r0
   2b3ec:	b188      	cbz	r0, 2b412 <at_cmd_driver_init+0x3a>
		LOG_ERR("Failed to open AT socket (err:%d)", err);
   2b3ee:	2301      	movs	r3, #1
   2b3f0:	f04f 0000 	mov.w	r0, #0
   2b3f4:	4a10      	ldr	r2, [pc, #64]	; (2b438 <at_cmd_driver_init+0x60>)
   2b3f6:	f363 0007 	bfi	r0, r3, #0, #8
   2b3fa:	4b10      	ldr	r3, [pc, #64]	; (2b43c <at_cmd_driver_init+0x64>)
   2b3fc:	4910      	ldr	r1, [pc, #64]	; (2b440 <at_cmd_driver_init+0x68>)
   2b3fe:	1a9b      	subs	r3, r3, r2
   2b400:	08db      	lsrs	r3, r3, #3
   2b402:	f363 108f 	bfi	r0, r3, #6, #10
   2b406:	4622      	mov	r2, r4
   2b408:	f011 f9e7 	bl	3c7da <log_string_sync>
			THREAD_PRIORITY, 0, K_NO_WAIT);

	LOG_DBG("Common AT socket processing thread created");

	return 0;
}
   2b40c:	4620      	mov	r0, r4
   2b40e:	b006      	add	sp, #24
   2b410:	bd10      	pop	{r4, pc}
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   2b412:	230a      	movs	r3, #10
   2b414:	e9cd 0004 	strd	r0, r0, [sp, #16]
   2b418:	e9cd 0302 	strd	r0, r3, [sp, #8]
   2b41c:	e9cd 0000 	strd	r0, r0, [sp]
   2b420:	4b08      	ldr	r3, [pc, #32]	; (2b444 <at_cmd_driver_init+0x6c>)
   2b422:	f44f 6280 	mov.w	r2, #1024	; 0x400
   2b426:	4908      	ldr	r1, [pc, #32]	; (2b448 <at_cmd_driver_init+0x70>)
   2b428:	4808      	ldr	r0, [pc, #32]	; (2b44c <at_cmd_driver_init+0x74>)
   2b42a:	f00c fc07 	bl	37c3c <z_impl_k_thread_create>
	return 0;
   2b42e:	e7ed      	b.n	2b40c <at_cmd_driver_init+0x34>
		return 0;
   2b430:	2400      	movs	r4, #0
   2b432:	e7eb      	b.n	2b40c <at_cmd_driver_init+0x34>
   2b434:	2002c7e6 	.word	0x2002c7e6
   2b438:	0003f8d4 	.word	0x0003f8d4
   2b43c:	0003f8dc 	.word	0x0003f8dc
   2b440:	00042d22 	.word	0x00042d22
   2b444:	0002b0f1 	.word	0x0002b0f1
   2b448:	2002f948 	.word	0x2002f948
   2b44c:	20024c8c 	.word	0x20024c8c

0002b450 <at_cmd_write>:
{
   2b450:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2b454:	4605      	mov	r5, r0
   2b456:	4688      	mov	r8, r1
   2b458:	4617      	mov	r7, r2
   2b45a:	461e      	mov	r6, r3
	return z_impl_k_sem_take(sem, timeout);
   2b45c:	4c0a      	ldr	r4, [pc, #40]	; (2b488 <at_cmd_write+0x38>)
   2b45e:	f04f 31ff 	mov.w	r1, #4294967295
   2b462:	4620      	mov	r0, r4
   2b464:	f00c fab8 	bl	379d8 <z_impl_k_sem_take>
	response_buf     = buf;
   2b468:	4b08      	ldr	r3, [pc, #32]	; (2b48c <at_cmd_write+0x3c>)
	int return_code = at_write(cmd, state);
   2b46a:	4631      	mov	r1, r6
	response_buf     = buf;
   2b46c:	f8c3 8000 	str.w	r8, [r3]
	response_buf_len = buf_len;
   2b470:	4b07      	ldr	r3, [pc, #28]	; (2b490 <at_cmd_write+0x40>)
	int return_code = at_write(cmd, state);
   2b472:	4628      	mov	r0, r5
	response_buf_len = buf_len;
   2b474:	601f      	str	r7, [r3, #0]
	int return_code = at_write(cmd, state);
   2b476:	f7ff fdbd 	bl	2aff4 <at_write>
   2b47a:	4605      	mov	r5, r0
	z_impl_k_sem_give(sem);
   2b47c:	4620      	mov	r0, r4
   2b47e:	f00c fa61 	bl	37944 <z_impl_k_sem_give>
}
   2b482:	4628      	mov	r0, r5
   2b484:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2b488:	20037aac 	.word	0x20037aac
   2b48c:	20024c84 	.word	0x20024c84
   2b490:	20024c88 	.word	0x20024c88

0002b494 <at_cmd_set_notification_handler>:
{
   2b494:	b538      	push	{r3, r4, r5, lr}
	if (notification_handler != NULL && handler != notification_handler) {
   2b496:	4c0f      	ldr	r4, [pc, #60]	; (2b4d4 <at_cmd_set_notification_handler+0x40>)
{
   2b498:	4605      	mov	r5, r0
	if (notification_handler != NULL && handler != notification_handler) {
   2b49a:	6822      	ldr	r2, [r4, #0]
   2b49c:	b17a      	cbz	r2, 2b4be <at_cmd_set_notification_handler+0x2a>
   2b49e:	4282      	cmp	r2, r0
   2b4a0:	d00d      	beq.n	2b4be <at_cmd_set_notification_handler+0x2a>
		LOG_WRN("Forgetting prior notification handler %p",
   2b4a2:	2302      	movs	r3, #2
   2b4a4:	f04f 0000 	mov.w	r0, #0
   2b4a8:	490b      	ldr	r1, [pc, #44]	; (2b4d8 <at_cmd_set_notification_handler+0x44>)
   2b4aa:	f363 0007 	bfi	r0, r3, #0, #8
   2b4ae:	4b0b      	ldr	r3, [pc, #44]	; (2b4dc <at_cmd_set_notification_handler+0x48>)
   2b4b0:	1a5b      	subs	r3, r3, r1
   2b4b2:	08db      	lsrs	r3, r3, #3
   2b4b4:	f363 108f 	bfi	r0, r3, #6, #10
   2b4b8:	4909      	ldr	r1, [pc, #36]	; (2b4e0 <at_cmd_set_notification_handler+0x4c>)
   2b4ba:	f011 f98e 	bl	3c7da <log_string_sync>
	return z_impl_k_sem_take(sem, timeout);
   2b4be:	f04f 31ff 	mov.w	r1, #4294967295
   2b4c2:	4808      	ldr	r0, [pc, #32]	; (2b4e4 <at_cmd_set_notification_handler+0x50>)
   2b4c4:	f00c fa88 	bl	379d8 <z_impl_k_sem_take>
	notification_handler = handler;
   2b4c8:	6025      	str	r5, [r4, #0]
	z_impl_k_sem_give(sem);
   2b4ca:	4806      	ldr	r0, [pc, #24]	; (2b4e4 <at_cmd_set_notification_handler+0x50>)
}
   2b4cc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2b4d0:	f00c ba38 	b.w	37944 <z_impl_k_sem_give>
   2b4d4:	20024c80 	.word	0x20024c80
   2b4d8:	0003f8d4 	.word	0x0003f8d4
   2b4dc:	0003f8dc 	.word	0x0003f8dc
   2b4e0:	00042d44 	.word	0x00042d44
   2b4e4:	20037aac 	.word	0x20037aac

0002b4e8 <find_node>:
static struct notif_handler *find_node(struct notif_handler **prev_out,
	void *ctx, at_notif_handler_t handler)
{
	struct notif_handler *prev = NULL, *curr, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   2b4e8:	4b0b      	ldr	r3, [pc, #44]	; (2b518 <find_node+0x30>)
{
   2b4ea:	b570      	push	{r4, r5, r6, lr}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   2b4ec:	681b      	ldr	r3, [r3, #0]
   2b4ee:	b153      	cbz	r3, 2b506 <find_node+0x1e>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   2b4f0:	2500      	movs	r5, #0
   2b4f2:	461c      	mov	r4, r3
   2b4f4:	681b      	ldr	r3, [r3, #0]
		if (curr->ctx == ctx && curr->handler == handler) {
   2b4f6:	6866      	ldr	r6, [r4, #4]
   2b4f8:	428e      	cmp	r6, r1
   2b4fa:	d106      	bne.n	2b50a <find_node+0x22>
   2b4fc:	68a6      	ldr	r6, [r4, #8]
   2b4fe:	4296      	cmp	r6, r2
   2b500:	d103      	bne.n	2b50a <find_node+0x22>
			*prev_out = prev;
			return curr;
   2b502:	4623      	mov	r3, r4
			*prev_out = prev;
   2b504:	6005      	str	r5, [r0, #0]
		}
		prev = curr;
	}
	return NULL;
}
   2b506:	4618      	mov	r0, r3
   2b508:	bd70      	pop	{r4, r5, r6, pc}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   2b50a:	2b00      	cmp	r3, #0
   2b50c:	d0fb      	beq.n	2b506 <find_node+0x1e>
   2b50e:	4625      	mov	r5, r4
   2b510:	461c      	mov	r4, r3
   2b512:	681b      	ldr	r3, [r3, #0]
   2b514:	e7ef      	b.n	2b4f6 <find_node+0xe>
   2b516:	bf00      	nop
   2b518:	20024d3c 	.word	0x20024d3c

0002b51c <module_init>:
{
	ARG_UNUSED(dev);

	static bool initialized;

	if (initialized) {
   2b51c:	4a0e      	ldr	r2, [pc, #56]	; (2b558 <module_init+0x3c>)
{
   2b51e:	b508      	push	{r3, lr}
	if (initialized) {
   2b520:	7813      	ldrb	r3, [r2, #0]
   2b522:	b17b      	cbz	r3, 2b544 <module_init+0x28>
		LOG_WRN("Already initialized. Nothing to do");
   2b524:	2302      	movs	r3, #2
   2b526:	f04f 0000 	mov.w	r0, #0
   2b52a:	4a0c      	ldr	r2, [pc, #48]	; (2b55c <module_init+0x40>)
   2b52c:	f363 0007 	bfi	r0, r3, #0, #8
   2b530:	4b0b      	ldr	r3, [pc, #44]	; (2b560 <module_init+0x44>)
   2b532:	490c      	ldr	r1, [pc, #48]	; (2b564 <module_init+0x48>)
   2b534:	1a9b      	subs	r3, r3, r2
   2b536:	08db      	lsrs	r3, r3, #3
   2b538:	f363 108f 	bfi	r0, r3, #6, #10
   2b53c:	f011 f94d 	bl	3c7da <log_string_sync>

	LOG_DBG("Initialization");
	sys_slist_init(&handler_list);
	at_cmd_set_notification_handler(notif_dispatch);
	return 0;
}
   2b540:	2000      	movs	r0, #0
   2b542:	bd08      	pop	{r3, pc}
	initialized = true;
   2b544:	2101      	movs	r1, #1
   2b546:	7011      	strb	r1, [r2, #0]
	list->head = NULL;
   2b548:	4a07      	ldr	r2, [pc, #28]	; (2b568 <module_init+0x4c>)
	at_cmd_set_notification_handler(notif_dispatch);
   2b54a:	4808      	ldr	r0, [pc, #32]	; (2b56c <module_init+0x50>)
	list->tail = NULL;
   2b54c:	e9c2 3300 	strd	r3, r3, [r2]
   2b550:	f7ff ffa0 	bl	2b494 <at_cmd_set_notification_handler>
	return 0;
   2b554:	e7f4      	b.n	2b540 <module_init+0x24>
   2b556:	bf00      	nop
   2b558:	2002c7e7 	.word	0x2002c7e7
   2b55c:	0003f8d4 	.word	0x0003f8d4
   2b560:	0003f8ec 	.word	0x0003f8ec
   2b564:	00042f16 	.word	0x00042f16
   2b568:	20024d3c 	.word	0x20024d3c
   2b56c:	0002b57d 	.word	0x0002b57d

0002b570 <k_mutex_unlock.constprop.7>:
	return z_impl_k_mutex_unlock(mutex);
   2b570:	4801      	ldr	r0, [pc, #4]	; (2b578 <k_mutex_unlock.constprop.7+0x8>)
   2b572:	f00a be17 	b.w	361a4 <z_impl_k_mutex_unlock>
   2b576:	bf00      	nop
   2b578:	20037b04 	.word	0x20037b04

0002b57c <notif_dispatch>:
{
   2b57c:	b538      	push	{r3, r4, r5, lr}
   2b57e:	4605      	mov	r5, r0
	return z_impl_k_mutex_lock(mutex, timeout);
   2b580:	f04f 31ff 	mov.w	r1, #4294967295
   2b584:	4809      	ldr	r0, [pc, #36]	; (2b5ac <notif_dispatch+0x30>)
   2b586:	f00a fd2f 	bl	35fe8 <z_impl_k_mutex_lock>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   2b58a:	4b09      	ldr	r3, [pc, #36]	; (2b5b0 <notif_dispatch+0x34>)
   2b58c:	681b      	ldr	r3, [r3, #0]
   2b58e:	b91b      	cbnz	r3, 2b598 <notif_dispatch+0x1c>
}
   2b590:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	k_mutex_unlock(&list_mtx);
   2b594:	f7ff bfec 	b.w	2b570 <k_mutex_unlock.constprop.7>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   2b598:	681c      	ldr	r4, [r3, #0]
		curr->handler(curr->ctx, response);
   2b59a:	689a      	ldr	r2, [r3, #8]
   2b59c:	4629      	mov	r1, r5
   2b59e:	6858      	ldr	r0, [r3, #4]
   2b5a0:	4790      	blx	r2
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   2b5a2:	2c00      	cmp	r4, #0
   2b5a4:	d0f4      	beq.n	2b590 <notif_dispatch+0x14>
   2b5a6:	4623      	mov	r3, r4
   2b5a8:	6824      	ldr	r4, [r4, #0]
   2b5aa:	e7f6      	b.n	2b59a <notif_dispatch+0x1e>
   2b5ac:	20037b04 	.word	0x20037b04
   2b5b0:	20024d3c 	.word	0x20024d3c

0002b5b4 <at_notif_register_handler>:
{
	return module_init(NULL);
}

int at_notif_register_handler(void *context, at_notif_handler_t handler)
{
   2b5b4:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2b5b6:	4606      	mov	r6, r0
	if (handler == NULL) {
   2b5b8:	460d      	mov	r5, r1
   2b5ba:	b999      	cbnz	r1, 2b5e4 <at_notif_register_handler+0x30>
		LOG_ERR("Invalid handler (context=0x%08X, handler=0x%08X)",
   2b5bc:	2301      	movs	r3, #1
   2b5be:	f04f 0000 	mov.w	r0, #0
   2b5c2:	4a1d      	ldr	r2, [pc, #116]	; (2b638 <at_notif_register_handler+0x84>)
   2b5c4:	f363 0007 	bfi	r0, r3, #0, #8
   2b5c8:	4b1c      	ldr	r3, [pc, #112]	; (2b63c <at_notif_register_handler+0x88>)
   2b5ca:	1a9b      	subs	r3, r3, r2
   2b5cc:	08db      	lsrs	r3, r3, #3
   2b5ce:	f363 108f 	bfi	r0, r3, #6, #10
   2b5d2:	4632      	mov	r2, r6
   2b5d4:	460b      	mov	r3, r1
   2b5d6:	491a      	ldr	r1, [pc, #104]	; (2b640 <at_notif_register_handler+0x8c>)
   2b5d8:	f011 f8ff 	bl	3c7da <log_string_sync>
			(u32_t)context, (u32_t)handler);
		return -EINVAL;
   2b5dc:	f06f 0015 	mvn.w	r0, #21
	}
	return append_notif_handler(context, handler);
}
   2b5e0:	b002      	add	sp, #8
   2b5e2:	bd70      	pop	{r4, r5, r6, pc}
   2b5e4:	f04f 31ff 	mov.w	r1, #4294967295
   2b5e8:	4816      	ldr	r0, [pc, #88]	; (2b644 <at_notif_register_handler+0x90>)
   2b5ea:	f00a fcfd 	bl	35fe8 <z_impl_k_mutex_lock>
	if (find_node(&to_ins, ctx, handler) != NULL) {
   2b5ee:	462a      	mov	r2, r5
   2b5f0:	4631      	mov	r1, r6
   2b5f2:	a801      	add	r0, sp, #4
   2b5f4:	f7ff ff78 	bl	2b4e8 <find_node>
   2b5f8:	4604      	mov	r4, r0
   2b5fa:	b118      	cbz	r0, 2b604 <at_notif_register_handler+0x50>
		k_mutex_unlock(&list_mtx);
   2b5fc:	f7ff ffb8 	bl	2b570 <k_mutex_unlock.constprop.7>
		return 0;
   2b600:	2000      	movs	r0, #0
   2b602:	e7ed      	b.n	2b5e0 <at_notif_register_handler+0x2c>
	to_ins = (struct notif_handler *)k_malloc(sizeof(struct notif_handler));
   2b604:	200c      	movs	r0, #12
   2b606:	f00a fb87 	bl	35d18 <k_malloc>
   2b60a:	9001      	str	r0, [sp, #4]
	if (to_ins == NULL) {
   2b60c:	b920      	cbnz	r0, 2b618 <at_notif_register_handler+0x64>
		k_mutex_unlock(&list_mtx);
   2b60e:	f7ff ffaf 	bl	2b570 <k_mutex_unlock.constprop.7>
		return -ENOBUFS;
   2b612:	f06f 0068 	mvn.w	r0, #104	; 0x68
   2b616:	e7e3      	b.n	2b5e0 <at_notif_register_handler+0x2c>
__ssp_bos_icheck3(memset, void *, int)
   2b618:	6004      	str	r4, [r0, #0]
	to_ins->ctx     = ctx;
   2b61a:	9b01      	ldr	r3, [sp, #4]
Z_GENLIST_APPEND(slist, snode)
   2b61c:	4a0a      	ldr	r2, [pc, #40]	; (2b648 <at_notif_register_handler+0x94>)
   2b61e:	6044      	str	r4, [r0, #4]
   2b620:	6084      	str	r4, [r0, #8]
	parent->next = child;
   2b622:	601c      	str	r4, [r3, #0]
Z_GENLIST_APPEND(slist, snode)
   2b624:	6851      	ldr	r1, [r2, #4]
	to_ins->handler = handler;
   2b626:	e9c3 6501 	strd	r6, r5, [r3, #4]
   2b62a:	b911      	cbnz	r1, 2b632 <at_notif_register_handler+0x7e>
	list->head = node;
   2b62c:	e9c2 3300 	strd	r3, r3, [r2]
   2b630:	e7e4      	b.n	2b5fc <at_notif_register_handler+0x48>
	parent->next = child;
   2b632:	600b      	str	r3, [r1, #0]
	list->tail = node;
   2b634:	6053      	str	r3, [r2, #4]
   2b636:	e7e1      	b.n	2b5fc <at_notif_register_handler+0x48>
   2b638:	0003f8d4 	.word	0x0003f8d4
   2b63c:	0003f8ec 	.word	0x0003f8ec
   2b640:	00042ee5 	.word	0x00042ee5
   2b644:	20037b04 	.word	0x20037b04
   2b648:	20024d3c 	.word	0x20024d3c

0002b64c <at_notif_deregister_handler>:

int at_notif_deregister_handler(void *context, at_notif_handler_t handler)
{
   2b64c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2b64e:	4605      	mov	r5, r0
	if (handler == NULL) {
   2b650:	460c      	mov	r4, r1
   2b652:	b999      	cbnz	r1, 2b67c <at_notif_deregister_handler+0x30>
		LOG_ERR("Invalid handler (context=0x%08X, handler=0x%08X)",
   2b654:	2301      	movs	r3, #1
   2b656:	f04f 0000 	mov.w	r0, #0
   2b65a:	4921      	ldr	r1, [pc, #132]	; (2b6e0 <at_notif_deregister_handler+0x94>)
   2b65c:	f363 0007 	bfi	r0, r3, #0, #8
   2b660:	4b20      	ldr	r3, [pc, #128]	; (2b6e4 <at_notif_deregister_handler+0x98>)
   2b662:	462a      	mov	r2, r5
   2b664:	1ac9      	subs	r1, r1, r3
   2b666:	08c9      	lsrs	r1, r1, #3
   2b668:	f361 108f 	bfi	r0, r1, #6, #10
   2b66c:	4623      	mov	r3, r4
   2b66e:	491e      	ldr	r1, [pc, #120]	; (2b6e8 <at_notif_deregister_handler+0x9c>)
   2b670:	f011 f8b3 	bl	3c7da <log_string_sync>
			(u32_t)context, (u32_t)handler);
		return -EINVAL;
   2b674:	f06f 0015 	mvn.w	r0, #21
	}
	return remove_notif_handler(context, handler);
}
   2b678:	b003      	add	sp, #12
   2b67a:	bd30      	pop	{r4, r5, pc}
	struct notif_handler *curr, *prev = NULL;
   2b67c:	2300      	movs	r3, #0
   2b67e:	9301      	str	r3, [sp, #4]
   2b680:	f04f 31ff 	mov.w	r1, #4294967295
   2b684:	4819      	ldr	r0, [pc, #100]	; (2b6ec <at_notif_deregister_handler+0xa0>)
   2b686:	f00a fcaf 	bl	35fe8 <z_impl_k_mutex_lock>
	curr = find_node(&prev, ctx, handler);
   2b68a:	4622      	mov	r2, r4
   2b68c:	4629      	mov	r1, r5
   2b68e:	a801      	add	r0, sp, #4
   2b690:	f7ff ff2a 	bl	2b4e8 <find_node>
	if (curr == NULL) {
   2b694:	b978      	cbnz	r0, 2b6b6 <at_notif_deregister_handler+0x6a>
		LOG_WRN("Handler not registered. Nothing to do");
   2b696:	2302      	movs	r3, #2
   2b698:	4a12      	ldr	r2, [pc, #72]	; (2b6e4 <at_notif_deregister_handler+0x98>)
   2b69a:	f363 0007 	bfi	r0, r3, #0, #8
   2b69e:	4b10      	ldr	r3, [pc, #64]	; (2b6e0 <at_notif_deregister_handler+0x94>)
   2b6a0:	4913      	ldr	r1, [pc, #76]	; (2b6f0 <at_notif_deregister_handler+0xa4>)
   2b6a2:	1a9b      	subs	r3, r3, r2
   2b6a4:	08db      	lsrs	r3, r3, #3
   2b6a6:	f363 108f 	bfi	r0, r3, #6, #10
   2b6aa:	f011 f896 	bl	3c7da <log_string_sync>
	k_mutex_unlock(&list_mtx);
   2b6ae:	f7ff ff5f 	bl	2b570 <k_mutex_unlock.constprop.7>
	return remove_notif_handler(context, handler);
   2b6b2:	2000      	movs	r0, #0
   2b6b4:	e7e0      	b.n	2b678 <at_notif_deregister_handler+0x2c>
	sys_slist_remove(&handler_list, &prev->node, &curr->node);
   2b6b6:	9a01      	ldr	r2, [sp, #4]
Z_GENLIST_REMOVE(slist, snode)
   2b6b8:	6801      	ldr	r1, [r0, #0]
   2b6ba:	4b0e      	ldr	r3, [pc, #56]	; (2b6f4 <at_notif_deregister_handler+0xa8>)
   2b6bc:	b94a      	cbnz	r2, 2b6d2 <at_notif_deregister_handler+0x86>
   2b6be:	685a      	ldr	r2, [r3, #4]
	list->head = node;
   2b6c0:	6019      	str	r1, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   2b6c2:	4290      	cmp	r0, r2
   2b6c4:	d100      	bne.n	2b6c8 <at_notif_deregister_handler+0x7c>
	list->tail = node;
   2b6c6:	6059      	str	r1, [r3, #4]
	parent->next = child;
   2b6c8:	2300      	movs	r3, #0
   2b6ca:	6003      	str	r3, [r0, #0]
	k_free(curr);
   2b6cc:	f012 feef 	bl	3e4ae <k_free>
   2b6d0:	e7ed      	b.n	2b6ae <at_notif_deregister_handler+0x62>
   2b6d2:	6011      	str	r1, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   2b6d4:	6859      	ldr	r1, [r3, #4]
   2b6d6:	4288      	cmp	r0, r1
	list->tail = node;
   2b6d8:	bf08      	it	eq
   2b6da:	605a      	streq	r2, [r3, #4]
   2b6dc:	e7f4      	b.n	2b6c8 <at_notif_deregister_handler+0x7c>
   2b6de:	bf00      	nop
   2b6e0:	0003f8ec 	.word	0x0003f8ec
   2b6e4:	0003f8d4 	.word	0x0003f8d4
   2b6e8:	00042ee5 	.word	0x00042ee5
   2b6ec:	20037b04 	.word	0x20037b04
   2b6f0:	00042ebf 	.word	0x00042ebf
   2b6f4:	20024d3c 	.word	0x20024d3c

0002b6f8 <write_uart_string>:
static struct k_work cmd_send_work;



static inline void write_uart_string(const char *str)
{
   2b6f8:	b538      	push	{r3, r4, r5, lr}
	/* Send characters until, but not including, null */
	for (size_t i = 0; str[i]; i++) {
		uart_poll_out(uart_dev, str[i]);
   2b6fa:	4d05      	ldr	r5, [pc, #20]	; (2b710 <write_uart_string+0x18>)
   2b6fc:	1e44      	subs	r4, r0, #1
	for (size_t i = 0; str[i]; i++) {
   2b6fe:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   2b702:	b901      	cbnz	r1, 2b706 <write_uart_string+0xe>
	}
}
   2b704:	bd38      	pop	{r3, r4, r5, pc}
		uart_poll_out(uart_dev, str[i]);
   2b706:	6828      	ldr	r0, [r5, #0]
	api->poll_out(dev, out_char);
   2b708:	6843      	ldr	r3, [r0, #4]
   2b70a:	685b      	ldr	r3, [r3, #4]
   2b70c:	4798      	blx	r3
   2b70e:	e7f6      	b.n	2b6fe <write_uart_string+0x6>
   2b710:	20024e18 	.word	0x20024e18

0002b714 <cmd_send>:
	/* Forward the data over UART */
	write_uart_string(response);
}

static void cmd_send(struct k_work *work)
{
   2b714:	b500      	push	{lr}
	enum at_cmd_state state;
	int               err;

	ARG_UNUSED(work);

	err = at_cmd_write(at_buf, at_buf,
   2b716:	4923      	ldr	r1, [pc, #140]	; (2b7a4 <cmd_send+0x90>)
{
   2b718:	b08b      	sub	sp, #44	; 0x2c
	err = at_cmd_write(at_buf, at_buf,
   2b71a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   2b71e:	f10d 030b 	add.w	r3, sp, #11
   2b722:	4608      	mov	r0, r1
   2b724:	f7ff fe94 	bl	2b450 <at_cmd_write>
			   sizeof(at_buf), &state);
	if (err < 0) {
   2b728:	1e02      	subs	r2, r0, #0
   2b72a:	da12      	bge.n	2b752 <cmd_send+0x3e>
		LOG_ERR("Error while processing AT command: %d", err);
   2b72c:	2301      	movs	r3, #1
   2b72e:	f04f 0000 	mov.w	r0, #0
   2b732:	491d      	ldr	r1, [pc, #116]	; (2b7a8 <cmd_send+0x94>)
   2b734:	f363 0007 	bfi	r0, r3, #0, #8
   2b738:	4b1c      	ldr	r3, [pc, #112]	; (2b7ac <cmd_send+0x98>)
   2b73a:	1a5b      	subs	r3, r3, r1
   2b73c:	08db      	lsrs	r3, r3, #3
   2b73e:	f363 108f 	bfi	r0, r3, #6, #10
   2b742:	491b      	ldr	r1, [pc, #108]	; (2b7b0 <cmd_send+0x9c>)
   2b744:	f011 f849 	bl	3c7da <log_string_sync>
		state = AT_CMD_ERROR;
   2b748:	2301      	movs	r3, #1
   2b74a:	f88d 300b 	strb.w	r3, [sp, #11]
	case AT_CMD_OK:
		write_uart_string(at_buf);
		write_uart_string(OK_STR);
		break;
	case AT_CMD_ERROR:
		write_uart_string(ERROR_STR);
   2b74e:	4819      	ldr	r0, [pc, #100]	; (2b7b4 <cmd_send+0xa0>)
   2b750:	e012      	b.n	2b778 <cmd_send+0x64>
	switch (state) {
   2b752:	f89d 300b 	ldrb.w	r3, [sp, #11]
   2b756:	2b03      	cmp	r3, #3
   2b758:	d810      	bhi.n	2b77c <cmd_send+0x68>
   2b75a:	a101      	add	r1, pc, #4	; (adr r1, 2b760 <cmd_send+0x4c>)
   2b75c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
   2b760:	0002b771 	.word	0x0002b771
   2b764:	0002b74f 	.word	0x0002b74f
   2b768:	0002b78b 	.word	0x0002b78b
   2b76c:	0002b79d 	.word	0x0002b79d
		write_uart_string(at_buf);
   2b770:	480c      	ldr	r0, [pc, #48]	; (2b7a4 <cmd_send+0x90>)
   2b772:	f7ff ffc1 	bl	2b6f8 <write_uart_string>
		write_uart_string(OK_STR);
   2b776:	4810      	ldr	r0, [pc, #64]	; (2b7b8 <cmd_send+0xa4>)
		sprintf(str, "+CMS ERROR: %d\r\n", err);
		write_uart_string(str);
		break;
	case AT_CMD_ERROR_CME:
		sprintf(str, "+CME ERROR: %d\r\n", err);
		write_uart_string(str);
   2b778:	f7ff ffbe 	bl	2b6f8 <write_uart_string>
		break;
	default:
		break;
	}

	uart_irq_rx_enable(uart_dev);
   2b77c:	4b0f      	ldr	r3, [pc, #60]	; (2b7bc <cmd_send+0xa8>)
   2b77e:	6818      	ldr	r0, [r3, #0]
		arch_syscall_invoke1(*(uintptr_t *)&dev, K_SYSCALL_UART_IRQ_RX_ENABLE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_rx_enable(dev);
   2b780:	f012 fcde 	bl	3e140 <z_impl_uart_irq_rx_enable>
}
   2b784:	b00b      	add	sp, #44	; 0x2c
   2b786:	f85d fb04 	ldr.w	pc, [sp], #4
		sprintf(str, "+CMS ERROR: %d\r\n", err);
   2b78a:	4b0d      	ldr	r3, [pc, #52]	; (2b7c0 <cmd_send+0xac>)
   2b78c:	9200      	str	r2, [sp, #0]
		sprintf(str, "+CME ERROR: %d\r\n", err);
   2b78e:	2219      	movs	r2, #25
   2b790:	2100      	movs	r1, #0
   2b792:	a803      	add	r0, sp, #12
   2b794:	f013 f9bc 	bl	3eb10 <__sprintf_chk>
		write_uart_string(str);
   2b798:	a803      	add	r0, sp, #12
   2b79a:	e7ed      	b.n	2b778 <cmd_send+0x64>
		sprintf(str, "+CME ERROR: %d\r\n", err);
   2b79c:	9200      	str	r2, [sp, #0]
   2b79e:	4b09      	ldr	r3, [pc, #36]	; (2b7c4 <cmd_send+0xb0>)
   2b7a0:	e7f5      	b.n	2b78e <cmd_send+0x7a>
   2b7a2:	bf00      	nop
   2b7a4:	2002c7e8 	.word	0x2002c7e8
   2b7a8:	0003f8d4 	.word	0x0003f8d4
   2b7ac:	0003f8e4 	.word	0x0003f8e4
   2b7b0:	00042ffd 	.word	0x00042ffd
   2b7b4:	00043028 	.word	0x00043028
   2b7b8:	00043023 	.word	0x00043023
   2b7bc:	20024e18 	.word	0x20024e18
   2b7c0:	00043030 	.word	0x00043030
   2b7c4:	00043041 	.word	0x00043041

0002b7c8 <isr>:
		k_work_submit_to_queue(&at_host_work_q, &cmd_send_work);
	}
}

static void isr(struct device *dev)
{
   2b7c8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   2b7cc:	4606      	mov	r6, r0
	if (api->irq_update) {
   2b7ce:	6843      	ldr	r3, [r0, #4]
   2b7d0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   2b7d2:	b103      	cbz	r3, 2b7d6 <isr+0xe>
		return api->irq_update(dev);
   2b7d4:	4798      	blx	r3
	if (api->irq_rx_ready) {
   2b7d6:	6873      	ldr	r3, [r6, #4]
   2b7d8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   2b7da:	b1c3      	cbz	r3, 2b80e <isr+0x46>
		return api->irq_rx_ready(dev);
   2b7dc:	4630      	mov	r0, r6
   2b7de:	4798      	blx	r3
	u8_t character;

	uart_irq_update(dev);

	if (!uart_irq_rx_ready(dev)) {
   2b7e0:	b1a8      	cbz	r0, 2b80e <isr+0x46>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2b7e2:	f8df a14c 	ldr.w	sl, [pc, #332]	; 2b930 <_flash_used+0x90>
   2b7e6:	4d47      	ldr	r5, [pc, #284]	; (2b904 <_flash_used+0x64>)
   2b7e8:	46d1      	mov	r9, sl
			LOG_WRN("Ignored null; would terminate string early.");
   2b7ea:	4b47      	ldr	r3, [pc, #284]	; (2b908 <_flash_used+0x68>)
		if (at_cmd_len > 0) {
   2b7ec:	4c47      	ldr	r4, [pc, #284]	; (2b90c <_flash_used+0x6c>)
			LOG_WRN("Ignored null; would terminate string early.");
   2b7ee:	1aed      	subs	r5, r5, r3
   2b7f0:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   2b7f4:	e8da 3faf 	lda	r3, [sl]

	/*
	 * Check that we are not sending data (buffer must be preserved then),
	 * and that a new character is available before handling each character
	 */
	while ((!k_work_pending(&cmd_send_work)) &&
   2b7f8:	07db      	lsls	r3, r3, #31
   2b7fa:	d408      	bmi.n	2b80e <isr+0x46>
	if (api->fifo_read) {
   2b7fc:	6873      	ldr	r3, [r6, #4]
   2b7fe:	699b      	ldr	r3, [r3, #24]
   2b800:	b12b      	cbz	r3, 2b80e <isr+0x46>
		return api->fifo_read(dev, rx_data, size);
   2b802:	2201      	movs	r2, #1
   2b804:	f10d 0107 	add.w	r1, sp, #7
   2b808:	4630      	mov	r0, r6
   2b80a:	4798      	blx	r3
   2b80c:	b910      	cbnz	r0, 2b814 <isr+0x4c>
	       (uart_fifo_read(dev, &character, 1))) {
		uart_rx_handler(character);
	}
}
   2b80e:	b002      	add	sp, #8
   2b810:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uart_rx_handler(character);
   2b814:	f89d 2007 	ldrb.w	r2, [sp, #7]
	switch (character) {
   2b818:	2a08      	cmp	r2, #8
   2b81a:	d001      	beq.n	2b820 <isr+0x58>
   2b81c:	2a7f      	cmp	r2, #127	; 0x7f
   2b81e:	d105      	bne.n	2b82c <isr+0x64>
		if (at_cmd_len > 0) {
   2b820:	6823      	ldr	r3, [r4, #0]
   2b822:	2b00      	cmp	r3, #0
   2b824:	d0e6      	beq.n	2b7f4 <isr+0x2c>
			at_cmd_len--;
   2b826:	3b01      	subs	r3, #1
   2b828:	6023      	str	r3, [r4, #0]
   2b82a:	e7e3      	b.n	2b7f4 <isr+0x2c>
	if (!inside_quotes) {
   2b82c:	4938      	ldr	r1, [pc, #224]	; (2b910 <_flash_used+0x70>)
   2b82e:	780b      	ldrb	r3, [r1, #0]
   2b830:	b9cb      	cbnz	r3, 2b866 <isr+0x9e>
		switch (character) {
   2b832:	2a0a      	cmp	r2, #10
   2b834:	d02b      	beq.n	2b88e <isr+0xc6>
   2b836:	2a0d      	cmp	r2, #13
   2b838:	d011      	beq.n	2b85e <isr+0x96>
   2b83a:	b9a2      	cbnz	r2, 2b866 <isr+0x9e>
			if (term_mode == MODE_NULL_TERM) {
   2b83c:	4b35      	ldr	r3, [pc, #212]	; (2b914 <_flash_used+0x74>)
   2b83e:	781b      	ldrb	r3, [r3, #0]
   2b840:	2b00      	cmp	r3, #0
   2b842:	d040      	beq.n	2b8c6 <_flash_used+0x26>
			LOG_WRN("Ignored null; would terminate string early.");
   2b844:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
   2b848:	f043 0302 	orr.w	r3, r3, #2
   2b84c:	f363 0707 	bfi	r7, r3, #0, #8
   2b850:	f365 178f 	bfi	r7, r5, #6, #10
   2b854:	4930      	ldr	r1, [pc, #192]	; (2b918 <_flash_used+0x78>)
   2b856:	4638      	mov	r0, r7
   2b858:	f010 ffbf 	bl	3c7da <log_string_sync>
			return;
   2b85c:	e7ca      	b.n	2b7f4 <isr+0x2c>
			if (term_mode == MODE_CR) {
   2b85e:	482d      	ldr	r0, [pc, #180]	; (2b914 <_flash_used+0x74>)
   2b860:	7800      	ldrb	r0, [r0, #0]
   2b862:	2801      	cmp	r0, #1
			    at_cmd_len > 0 &&
   2b864:	d02f      	beq.n	2b8c6 <_flash_used+0x26>
	if (at_cmd_len + 1 > sizeof(at_buf) - 1) {
   2b866:	f8d4 c000 	ldr.w	ip, [r4]
   2b86a:	f10c 0001 	add.w	r0, ip, #1
   2b86e:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   2b872:	d31d      	bcc.n	2b8b0 <_flash_used+0x10>
		LOG_ERR("Buffer overflow, dropping '%c'\n", character);
   2b874:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   2b878:	f043 0301 	orr.w	r3, r3, #1
   2b87c:	f363 0807 	bfi	r8, r3, #0, #8
   2b880:	f365 188f 	bfi	r8, r5, #6, #10
   2b884:	4925      	ldr	r1, [pc, #148]	; (2b91c <_flash_used+0x7c>)
   2b886:	4640      	mov	r0, r8
   2b888:	f010 ffa7 	bl	3c7da <log_string_sync>
		return;
   2b88c:	e7b2      	b.n	2b7f4 <isr+0x2c>
			if (term_mode == MODE_LF) {
   2b88e:	4821      	ldr	r0, [pc, #132]	; (2b914 <_flash_used+0x74>)
   2b890:	7800      	ldrb	r0, [r0, #0]
   2b892:	2802      	cmp	r0, #2
   2b894:	d017      	beq.n	2b8c6 <_flash_used+0x26>
			if (term_mode == MODE_CR_LF &&
   2b896:	2803      	cmp	r0, #3
   2b898:	d1e5      	bne.n	2b866 <isr+0x9e>
   2b89a:	f8d4 c000 	ldr.w	ip, [r4]
   2b89e:	f1bc 0f00 	cmp.w	ip, #0
   2b8a2:	d0e0      	beq.n	2b866 <isr+0x9e>
			    at_buf[at_cmd_len - 1] == '\r') {
   2b8a4:	481e      	ldr	r0, [pc, #120]	; (2b920 <_flash_used+0x80>)
   2b8a6:	4460      	add	r0, ip
			    at_cmd_len > 0 &&
   2b8a8:	f810 0c01 	ldrb.w	r0, [r0, #-1]
   2b8ac:	280d      	cmp	r0, #13
   2b8ae:	e7d9      	b.n	2b864 <isr+0x9c>
	at_buf[at_cmd_len] = character;
   2b8b0:	f8df e06c 	ldr.w	lr, [pc, #108]	; 2b920 <_flash_used+0x80>
	if (character == '"') {
   2b8b4:	2a22      	cmp	r2, #34	; 0x22
	at_buf[at_cmd_len] = character;
   2b8b6:	f80e 200c 	strb.w	r2, [lr, ip]
	at_cmd_len++;
   2b8ba:	6020      	str	r0, [r4, #0]
	if (character == '"') {
   2b8bc:	d19a      	bne.n	2b7f4 <isr+0x2c>
	if (!inside_quotes) {
   2b8be:	f083 0301 	eor.w	r3, r3, #1
		inside_quotes = !inside_quotes;
   2b8c2:	700b      	strb	r3, [r1, #0]
   2b8c4:	e796      	b.n	2b7f4 <isr+0x2c>
	at_buf[at_cmd_len] = '\0'; /* Terminate the command string */
   2b8c6:	2300      	movs	r3, #0
   2b8c8:	4a15      	ldr	r2, [pc, #84]	; (2b920 <_flash_used+0x80>)
   2b8ca:	6820      	ldr	r0, [r4, #0]
	inside_quotes = false;
   2b8cc:	700b      	strb	r3, [r1, #0]
	at_buf[at_cmd_len] = '\0'; /* Terminate the command string */
   2b8ce:	5413      	strb	r3, [r2, r0]
	at_cmd_len = 0;
   2b8d0:	6023      	str	r3, [r4, #0]
	if (at_buf[0]) {
   2b8d2:	7813      	ldrb	r3, [r2, #0]
   2b8d4:	2b00      	cmp	r3, #0
   2b8d6:	d08d      	beq.n	2b7f4 <isr+0x2c>
		uart_irq_rx_disable(uart_dev); /* Stop UART to protect at_buf */
   2b8d8:	4b12      	ldr	r3, [pc, #72]	; (2b924 <_flash_used+0x84>)
   2b8da:	6818      	ldr	r0, [r3, #0]
	if (api->irq_rx_disable) {
   2b8dc:	6843      	ldr	r3, [r0, #4]
   2b8de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2b8e0:	b103      	cbz	r3, 2b8e4 <_flash_used+0x44>
		api->irq_rx_disable(dev);
   2b8e2:	4798      	blx	r3
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2b8e4:	e8d9 3fef 	ldaex	r3, [r9]
   2b8e8:	f043 0201 	orr.w	r2, r3, #1
   2b8ec:	e8c9 2fe1 	stlex	r1, r2, [r9]
   2b8f0:	2900      	cmp	r1, #0
   2b8f2:	d1f7      	bne.n	2b8e4 <_flash_used+0x44>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   2b8f4:	07da      	lsls	r2, r3, #31
   2b8f6:	f53f af7d 	bmi.w	2b7f4 <isr+0x2c>
		k_queue_append(&work_q->queue, work);
   2b8fa:	490b      	ldr	r1, [pc, #44]	; (2b928 <_flash_used+0x88>)
   2b8fc:	480b      	ldr	r0, [pc, #44]	; (2b92c <_flash_used+0x8c>)
   2b8fe:	f012 fe0c 	bl	3e51a <k_queue_append>
   2b902:	e777      	b.n	2b7f4 <isr+0x2c>
   2b904:	0003f8e4 	.word	0x0003f8e4
   2b908:	0003f8d4 	.word	0x0003f8d4
   2b90c:	20024d44 	.word	0x20024d44
   2b910:	2002d7e8 	.word	0x2002d7e8
   2b914:	2002d7e9 	.word	0x2002d7e9
   2b918:	00043052 	.word	0x00043052
   2b91c:	0004307e 	.word	0x0004307e
   2b920:	2002c7e8 	.word	0x2002c7e8
   2b924:	20024e18 	.word	0x20024e18
   2b928:	20024e0c 	.word	0x20024e0c
   2b92c:	20024d48 	.word	0x20024d48
   2b930:	20024e14 	.word	0x20024e14

0002b934 <at_host_init>:

	ARG_UNUSED(arg);

	/* Choosing the termination mode */
	if (mode < MODE_COUNT) {
		term_mode = mode;
   2b934:	2202      	movs	r2, #2
   2b936:	4b49      	ldr	r3, [pc, #292]	; (2ba5c <at_host_init+0x128>)
{
   2b938:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	default:
		LOG_ERR("Unknown UART instance %d", uart_id);
		return -EINVAL;
	}

	err = at_notif_register_handler(NULL, response_handler);
   2b93c:	4948      	ldr	r1, [pc, #288]	; (2ba60 <at_host_init+0x12c>)
   2b93e:	2000      	movs	r0, #0
		term_mode = mode;
   2b940:	701a      	strb	r2, [r3, #0]
	err = at_notif_register_handler(NULL, response_handler);
   2b942:	f7ff fe37 	bl	2b5b4 <at_notif_register_handler>
	if (err != 0) {
   2b946:	4c47      	ldr	r4, [pc, #284]	; (2ba64 <at_host_init+0x130>)
   2b948:	4b47      	ldr	r3, [pc, #284]	; (2ba68 <at_host_init+0x134>)
   2b94a:	4606      	mov	r6, r0
   2b94c:	1ae4      	subs	r4, r4, r3
   2b94e:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   2b952:	b170      	cbz	r0, 2b972 <at_host_init+0x3e>
		LOG_ERR("Can't register handler err=%d", err);
   2b954:	f04f 0000 	mov.w	r0, #0
   2b958:	2301      	movs	r3, #1
   2b95a:	f363 0007 	bfi	r0, r3, #0, #8
   2b95e:	f364 108f 	bfi	r0, r4, #6, #10
   2b962:	4632      	mov	r2, r6
   2b964:	4941      	ldr	r1, [pc, #260]	; (2ba6c <at_host_init+0x138>)
   2b966:	f010 ff38 	bl	3c7da <log_string_sync>
		       K_THREAD_STACK_SIZEOF(at_host_stack_area),
		       CONFIG_AT_HOST_THREAD_PRIO);
	uart_irq_rx_enable(uart_dev);

	return err;
}
   2b96a:	4630      	mov	r0, r6
   2b96c:	b002      	add	sp, #8
   2b96e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2b972:	483f      	ldr	r0, [pc, #252]	; (2ba70 <at_host_init+0x13c>)
   2b974:	f009 fe54 	bl	35620 <z_impl_device_get_binding>
	uart_dev = device_get_binding(uart_dev_name);
   2b978:	4d3e      	ldr	r5, [pc, #248]	; (2ba74 <at_host_init+0x140>)
   2b97a:	6028      	str	r0, [r5, #0]
	if (uart_dev == NULL) {
   2b97c:	b9b8      	cbnz	r0, 2b9ae <at_host_init+0x7a>
		LOG_ERR("Cannot bind %s\n", uart_dev_name);
   2b97e:	2301      	movs	r3, #1
   2b980:	f363 0007 	bfi	r0, r3, #0, #8
   2b984:	4a3a      	ldr	r2, [pc, #232]	; (2ba70 <at_host_init+0x13c>)
   2b986:	f364 108f 	bfi	r0, r4, #6, #10
   2b98a:	493b      	ldr	r1, [pc, #236]	; (2ba78 <at_host_init+0x144>)
   2b98c:	f010 ff25 	bl	3c7da <log_string_sync>
		return -EINVAL;
   2b990:	f06f 0215 	mvn.w	r2, #21
		LOG_ERR("UART could not be initialized: %d", err);
   2b994:	2301      	movs	r3, #1
   2b996:	f04f 0000 	mov.w	r0, #0
   2b99a:	f363 0007 	bfi	r0, r3, #0, #8
   2b99e:	f364 108f 	bfi	r0, r4, #6, #10
   2b9a2:	4936      	ldr	r1, [pc, #216]	; (2ba7c <at_host_init+0x148>)
   2b9a4:	f010 ff19 	bl	3c7da <log_string_sync>
		return -EFAULT;
   2b9a8:	f06f 060d 	mvn.w	r6, #13
   2b9ac:	e7dd      	b.n	2b96a <at_host_init+0x36>
	return z_impl_k_uptime_get();
   2b9ae:	f012 fe90 	bl	3e6d2 <z_impl_k_uptime_get>
   2b9b2:	4681      	mov	r9, r0
			LOG_INF("UART check failed: %d. "
   2b9b4:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 2ba98 <at_host_init+0x164>
		err = uart_err_check(uart_dev);
   2b9b8:	6828      	ldr	r0, [r5, #0]
	if (api->err_check != NULL) {
   2b9ba:	6843      	ldr	r3, [r0, #4]
   2b9bc:	689b      	ldr	r3, [r3, #8]
   2b9be:	b39b      	cbz	r3, 2ba28 <at_host_init+0xf4>
		return api->err_check(dev);
   2b9c0:	4798      	blx	r3
		if (err) {
   2b9c2:	4680      	mov	r8, r0
   2b9c4:	b380      	cbz	r0, 2ba28 <at_host_init+0xf4>
   2b9c6:	f012 fe84 	bl	3e6d2 <z_impl_k_uptime_get>
			if (k_uptime_get_32() - start_time >
   2b9ca:	eba0 0009 	sub.w	r0, r0, r9
   2b9ce:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
   2b9d2:	d90d      	bls.n	2b9f0 <at_host_init+0xbc>
				LOG_ERR("UART check failed: %d. "
   2b9d4:	2301      	movs	r3, #1
   2b9d6:	f04f 0000 	mov.w	r0, #0
   2b9da:	f363 0007 	bfi	r0, r3, #0, #8
   2b9de:	4642      	mov	r2, r8
   2b9e0:	f364 108f 	bfi	r0, r4, #6, #10
   2b9e4:	4926      	ldr	r1, [pc, #152]	; (2ba80 <at_host_init+0x14c>)
   2b9e6:	f010 fef8 	bl	3c7da <log_string_sync>
				return -EIO;
   2b9ea:	f06f 0204 	mvn.w	r2, #4
   2b9ee:	e7d1      	b.n	2b994 <at_host_init+0x60>
			LOG_INF("UART check failed: %d. "
   2b9f0:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
   2b9f4:	f043 0303 	orr.w	r3, r3, #3
   2b9f8:	f363 0707 	bfi	r7, r3, #0, #8
   2b9fc:	f364 178f 	bfi	r7, r4, #6, #10
   2ba00:	4642      	mov	r2, r8
   2ba02:	4651      	mov	r1, sl
   2ba04:	4638      	mov	r0, r7
   2ba06:	f010 fee8 	bl	3c7da <log_string_sync>
			while (uart_fifo_read(uart_dev, &dummy, 1)) {
   2ba0a:	6828      	ldr	r0, [r5, #0]
	if (api->fifo_read) {
   2ba0c:	6843      	ldr	r3, [r0, #4]
   2ba0e:	699b      	ldr	r3, [r3, #24]
   2ba10:	b91b      	cbnz	r3, 2ba1a <at_host_init+0xe6>
	return z_impl_k_sleep(ms);
   2ba12:	200a      	movs	r0, #10
   2ba14:	f00b ff54 	bl	378c0 <z_impl_k_sleep>
   2ba18:	e7ce      	b.n	2b9b8 <at_host_init+0x84>
		return api->fifo_read(dev, rx_data, size);
   2ba1a:	2201      	movs	r2, #1
   2ba1c:	f10d 0107 	add.w	r1, sp, #7
   2ba20:	4798      	blx	r3
   2ba22:	2800      	cmp	r0, #0
   2ba24:	d1f1      	bne.n	2ba0a <at_host_init+0xd6>
   2ba26:	e7f4      	b.n	2ba12 <at_host_init+0xde>
	uart_irq_callback_set(uart_dev, isr);
   2ba28:	682a      	ldr	r2, [r5, #0]
	const struct uart_driver_api *api =
   2ba2a:	6853      	ldr	r3, [r2, #4]
	if ((api != NULL) && (api->irq_callback_set != NULL)) {
   2ba2c:	b123      	cbz	r3, 2ba38 <at_host_init+0x104>
   2ba2e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   2ba30:	b113      	cbz	r3, 2ba38 <at_host_init+0x104>
		api->irq_callback_set(dev, cb, user_data);
   2ba32:	4914      	ldr	r1, [pc, #80]	; (2ba84 <at_host_init+0x150>)
   2ba34:	4610      	mov	r0, r2
   2ba36:	4798      	blx	r3
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   2ba38:	2200      	movs	r2, #0
   2ba3a:	4b13      	ldr	r3, [pc, #76]	; (2ba88 <at_host_init+0x154>)
   2ba3c:	4913      	ldr	r1, [pc, #76]	; (2ba8c <at_host_init+0x158>)
   2ba3e:	601a      	str	r2, [r3, #0]
   2ba40:	e9c3 1201 	strd	r1, r2, [r3, #4]
	k_work_q_start(&at_host_work_q, at_host_stack_area,
   2ba44:	4812      	ldr	r0, [pc, #72]	; (2ba90 <at_host_init+0x15c>)
   2ba46:	230a      	movs	r3, #10
   2ba48:	f44f 7200 	mov.w	r2, #512	; 0x200
   2ba4c:	4911      	ldr	r1, [pc, #68]	; (2ba94 <at_host_init+0x160>)
   2ba4e:	f00c fa27 	bl	37ea0 <k_work_q_start>
	uart_irq_rx_enable(uart_dev);
   2ba52:	6828      	ldr	r0, [r5, #0]
   2ba54:	f012 fb74 	bl	3e140 <z_impl_uart_irq_rx_enable>
	return err;
   2ba58:	e787      	b.n	2b96a <at_host_init+0x36>
   2ba5a:	bf00      	nop
   2ba5c:	2002d7e9 	.word	0x2002d7e9
   2ba60:	0003e14b 	.word	0x0003e14b
   2ba64:	0003f8e4 	.word	0x0003f8e4
   2ba68:	0003f8d4 	.word	0x0003f8d4
   2ba6c:	00042f42 	.word	0x00042f42
   2ba70:	000408f9 	.word	0x000408f9
   2ba74:	20024e18 	.word	0x20024e18
   2ba78:	00042f60 	.word	0x00042f60
   2ba7c:	00042fdb 	.word	0x00042fdb
   2ba80:	00042f70 	.word	0x00042f70
   2ba84:	0002b7c9 	.word	0x0002b7c9
   2ba88:	20024e0c 	.word	0x20024e0c
   2ba8c:	0002b715 	.word	0x0002b715
   2ba90:	20024d48 	.word	0x20024d48
   2ba94:	2002fd48 	.word	0x2002fd48
   2ba98:	00042fa6 	.word	0x00042fa6

0002ba9c <is_valid_notification_char>:
 * @retval true  If character is valid
 * @retval false If character is not valid
 */
static inline bool is_valid_notification_char(char chr)
{
	chr = toupper(chr);
   2ba9c:	4b06      	ldr	r3, [pc, #24]	; (2bab8 <is_valid_notification_char+0x1c>)
   2ba9e:	5cc3      	ldrb	r3, [r0, r3]
   2baa0:	f003 0303 	and.w	r3, r3, #3
   2baa4:	2b02      	cmp	r3, #2
   2baa6:	bf08      	it	eq
   2baa8:	3820      	subeq	r0, #32

	if ((chr >= 'A') && (chr <= 'Z')) {
   2baaa:	3841      	subs	r0, #65	; 0x41
   2baac:	b2c0      	uxtb	r0, r0
		return true;
	}

	return false;
}
   2baae:	2819      	cmp	r0, #25
   2bab0:	bf8c      	ite	hi
   2bab2:	2000      	movhi	r0, #0
   2bab4:	2001      	movls	r0, #1
   2bab6:	4770      	bx	lr
   2bab8:	00044327 	.word	0x00044327

0002babc <at_parse_process_element>:
	return 0;
}

static int at_parse_process_element(const char **str, int index,
				    struct at_param_list *const list)
{
   2babc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	const char *tmpstr = *str;
   2bac0:	6805      	ldr	r5, [r0, #0]
{
   2bac2:	b0a3      	sub	sp, #140	; 0x8c
	const char *tmpstr = *str;
   2bac4:	9500      	str	r5, [sp, #0]
 * @retval true  If character is 0
 * @retval false If character is not 0
 */
static inline bool is_terminated(char chr)
{
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   2bac6:	782b      	ldrb	r3, [r5, #0]
{
   2bac8:	4680      	mov	r8, r0
   2baca:	460f      	mov	r7, r1
   2bacc:	4616      	mov	r6, r2
   2bace:	2b00      	cmp	r3, #0
   2bad0:	f000 80bd 	beq.w	2bc4e <at_parse_process_element+0x192>

	if (is_terminated(*tmpstr)) {
		return -1;
	}

	if (state == NOTIFICATION) {
   2bad4:	4b5f      	ldr	r3, [pc, #380]	; (2bc54 <at_parse_process_element+0x198>)
   2bad6:	781c      	ldrb	r4, [r3, #0]
   2bad8:	2c05      	cmp	r4, #5
   2bada:	d110      	bne.n	2bafe <at_parse_process_element+0x42>
		const char *start_ptr = tmpstr++;
   2badc:	1c6b      	adds	r3, r5, #1
   2bade:	9300      	str	r3, [sp, #0]

		while (is_valid_notification_char(*tmpstr)) {
   2bae0:	9a00      	ldr	r2, [sp, #0]
   2bae2:	7810      	ldrb	r0, [r2, #0]
   2bae4:	f7ff ffda 	bl	2ba9c <is_valid_notification_char>
   2bae8:	b930      	cbnz	r0, 2baf8 <at_parse_process_element+0x3c>
			tmpstr++;
		}

		at_params_string_put(list, index, start_ptr,
   2baea:	1b53      	subs	r3, r2, r5

		while (isxdigit((int)*tmpstr)) {
			tmpstr++;
		}

		at_params_string_put(list, index, start_ptr,
   2baec:	462a      	mov	r2, r5
   2baee:	4639      	mov	r1, r7
   2baf0:	4630      	mov	r0, r6
   2baf2:	f012 fba3 	bl	3e23c <at_params_string_put>
   2baf6:	e01b      	b.n	2bb30 <at_parse_process_element+0x74>
			tmpstr++;
   2baf8:	3201      	adds	r2, #1
   2bafa:	9200      	str	r2, [sp, #0]
   2bafc:	e7f0      	b.n	2bae0 <at_parse_process_element+0x24>
	} else if (state == COMMAND) {
   2bafe:	2c06      	cmp	r4, #6
   2bb00:	d124      	bne.n	2bb4c <at_parse_process_element+0x90>
		skip_command_prefix(&tmpstr);
   2bb02:	4668      	mov	r0, sp
   2bb04:	f012 fb2d 	bl	3e162 <skip_command_prefix>
		while (is_valid_notification_char(*tmpstr)) {
   2bb08:	9a00      	ldr	r2, [sp, #0]
   2bb0a:	7810      	ldrb	r0, [r2, #0]
   2bb0c:	f7ff ffc6 	bl	2ba9c <is_valid_notification_char>
   2bb10:	b9a8      	cbnz	r0, 2bb3e <at_parse_process_element+0x82>
		at_params_string_put(list, index, start_ptr,
   2bb12:	1b53      	subs	r3, r2, r5
   2bb14:	4639      	mov	r1, r7
   2bb16:	462a      	mov	r2, r5
   2bb18:	4630      	mov	r0, r6
   2bb1a:	f012 fb8f 	bl	3e23c <at_params_string_put>
		if ((*tmpstr == AT_CMD_SEPARATOR) &&
   2bb1e:	9b00      	ldr	r3, [sp, #0]
   2bb20:	781a      	ldrb	r2, [r3, #0]
   2bb22:	2a3d      	cmp	r2, #61	; 0x3d
   2bb24:	d10e      	bne.n	2bb44 <at_parse_process_element+0x88>
   2bb26:	785a      	ldrb	r2, [r3, #1]
   2bb28:	2a3f      	cmp	r2, #63	; 0x3f
   2bb2a:	d101      	bne.n	2bb30 <at_parse_process_element+0x74>
			tmpstr += 2;
   2bb2c:	3302      	adds	r3, #2
			tmpstr++;
   2bb2e:	9300      	str	r3, [sp, #0]
				     tmpstr - start_ptr);
	}

	*str = tmpstr;
	return 0;
   2bb30:	2000      	movs	r0, #0
	*str = tmpstr;
   2bb32:	9b00      	ldr	r3, [sp, #0]
   2bb34:	f8c8 3000 	str.w	r3, [r8]
}
   2bb38:	b023      	add	sp, #140	; 0x8c
   2bb3a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			tmpstr++;
   2bb3e:	3201      	adds	r2, #1
   2bb40:	9200      	str	r2, [sp, #0]
   2bb42:	e7e1      	b.n	2bb08 <at_parse_process_element+0x4c>
		} else if (*tmpstr == AT_CMD_READ_TEST_IDENTIFIER) {
   2bb44:	2a3f      	cmp	r2, #63	; 0x3f
   2bb46:	d1f3      	bne.n	2bb30 <at_parse_process_element+0x74>
			tmpstr++;
   2bb48:	3301      	adds	r3, #1
   2bb4a:	e7f0      	b.n	2bb2e <at_parse_process_element+0x72>
	} else if (state == OPTIONAL) {
   2bb4c:	2c07      	cmp	r4, #7
   2bb4e:	d103      	bne.n	2bb58 <at_parse_process_element+0x9c>
		at_params_empty_put(list, index);
   2bb50:	4610      	mov	r0, r2
   2bb52:	f012 fb4a 	bl	3e1ea <at_params_empty_put>
   2bb56:	e7eb      	b.n	2bb30 <at_parse_process_element+0x74>
	} else if (state == STRING) {
   2bb58:	2c02      	cmp	r4, #2
   2bb5a:	d112      	bne.n	2bb82 <at_parse_process_element+0xc6>
		while (!is_dblquote(*tmpstr) && !is_terminated(*tmpstr) &&
   2bb5c:	9a00      	ldr	r2, [sp, #0]
   2bb5e:	7810      	ldrb	r0, [r2, #0]
 * @retval true  If character is "
 * @retval false If character is something else
 */
static inline bool is_dblquote(char chr)
{
	if (chr == '"') {
   2bb60:	2822      	cmp	r0, #34	; 0x22
   2bb62:	d003      	beq.n	2bb6c <at_parse_process_element+0xb0>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   2bb64:	b110      	cbz	r0, 2bb6c <at_parse_process_element+0xb0>
		       !is_lfcr(*tmpstr)) {
   2bb66:	f012 faf3 	bl	3e150 <is_lfcr>
		while (!is_dblquote(*tmpstr) && !is_terminated(*tmpstr) &&
   2bb6a:	b138      	cbz	r0, 2bb7c <at_parse_process_element+0xc0>
		at_params_string_put(list, index, start_ptr,
   2bb6c:	1b53      	subs	r3, r2, r5
   2bb6e:	4639      	mov	r1, r7
   2bb70:	462a      	mov	r2, r5
   2bb72:	4630      	mov	r0, r6
   2bb74:	f012 fb62 	bl	3e23c <at_params_string_put>
		tmpstr++;
   2bb78:	9b00      	ldr	r3, [sp, #0]
   2bb7a:	e7e5      	b.n	2bb48 <at_parse_process_element+0x8c>
			tmpstr++;
   2bb7c:	3201      	adds	r2, #1
   2bb7e:	9200      	str	r2, [sp, #0]
   2bb80:	e7ec      	b.n	2bb5c <at_parse_process_element+0xa0>
	} else if (state == ARRAY) {
   2bb82:	2c01      	cmp	r4, #1
   2bb84:	d13c      	bne.n	2bc00 <at_parse_process_element+0x144>
		tmparray[i++] = (u32_t)strtoul(tmpstr, &next, 10);
   2bb86:	4628      	mov	r0, r5
   2bb88:	220a      	movs	r2, #10
   2bb8a:	a901      	add	r1, sp, #4
   2bb8c:	f00e f8e0 	bl	39d50 <strtoul>
		tmpstr = next;
   2bb90:	9b01      	ldr	r3, [sp, #4]
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   2bb92:	4d31      	ldr	r5, [pc, #196]	; (2bc58 <at_parse_process_element+0x19c>)
		tmparray[i++] = (u32_t)strtoul(tmpstr, &next, 10);
   2bb94:	9002      	str	r0, [sp, #8]
		tmpstr = next;
   2bb96:	9300      	str	r3, [sp, #0]
		while (!is_array_stop(*tmpstr) && !is_terminated(*tmpstr)) {
   2bb98:	9800      	ldr	r0, [sp, #0]
   2bb9a:	7803      	ldrb	r3, [r0, #0]
 * @retval true  If character is )
 * @retval false If character is something else
 */
static inline bool is_array_stop(char chr)
{
	if (chr == ')') {
   2bb9c:	2b29      	cmp	r3, #41	; 0x29
   2bb9e:	d028      	beq.n	2bbf2 <at_parse_process_element+0x136>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   2bba0:	b33b      	cbz	r3, 2bbf2 <at_parse_process_element+0x136>
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   2bba2:	3b2c      	subs	r3, #44	; 0x2c
   2bba4:	b2db      	uxtb	r3, r3
   2bba6:	3001      	adds	r0, #1
   2bba8:	2b11      	cmp	r3, #17
				tmparray[i++] =
   2bbaa:	9000      	str	r0, [sp, #0]
   2bbac:	d803      	bhi.n	2bbb6 <at_parse_process_element+0xfa>
   2bbae:	fa25 f303 	lsr.w	r3, r5, r3
   2bbb2:	07db      	lsls	r3, r3, #31
   2bbb4:	d408      	bmi.n	2bbc8 <at_parse_process_element+0x10c>
				tmpstr++;
   2bbb6:	46a1      	mov	r9, r4
   2bbb8:	e004      	b.n	2bbc4 <at_parse_process_element+0x108>
					tmpstr = next;
   2bbba:	9b01      	ldr	r3, [sp, #4]
			if (i == AT_CMD_MAX_ARRAY_SIZE) {
   2bbbc:	f1b9 0f20 	cmp.w	r9, #32
					tmpstr = next;
   2bbc0:	9300      	str	r3, [sp, #0]
			if (i == AT_CMD_MAX_ARRAY_SIZE) {
   2bbc2:	d015      	beq.n	2bbf0 <at_parse_process_element+0x134>
				tmpstr++;
   2bbc4:	464c      	mov	r4, r9
   2bbc6:	e7e7      	b.n	2bb98 <at_parse_process_element+0xdc>
					(u32_t)strtoul(++tmpstr, &next, 10);
   2bbc8:	220a      	movs	r2, #10
   2bbca:	a901      	add	r1, sp, #4
   2bbcc:	f00e f8c0 	bl	39d50 <strtoul>
				tmparray[i++] =
   2bbd0:	ab22      	add	r3, sp, #136	; 0x88
   2bbd2:	f104 0901 	add.w	r9, r4, #1
   2bbd6:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   2bbda:	f844 0c80 	str.w	r0, [r4, #-128]
				if (strlen(tmpstr) == strlen(next)) {
   2bbde:	9800      	ldr	r0, [sp, #0]
   2bbe0:	f7f1 faba 	bl	1d158 <strlen>
   2bbe4:	4604      	mov	r4, r0
   2bbe6:	9801      	ldr	r0, [sp, #4]
   2bbe8:	f7f1 fab6 	bl	1d158 <strlen>
   2bbec:	4284      	cmp	r4, r0
   2bbee:	d1e4      	bne.n	2bbba <at_parse_process_element+0xfe>
   2bbf0:	464c      	mov	r4, r9
		at_params_array_put(list, index, tmparray, i * sizeof(u32_t));
   2bbf2:	00a3      	lsls	r3, r4, #2
   2bbf4:	aa02      	add	r2, sp, #8
   2bbf6:	4639      	mov	r1, r7
   2bbf8:	4630      	mov	r0, r6
   2bbfa:	f012 fb45 	bl	3e288 <at_params_array_put>
   2bbfe:	e7bb      	b.n	2bb78 <at_parse_process_element+0xbc>
	} else if (state == NUMBER) {
   2bc00:	2c03      	cmp	r4, #3
   2bc02:	d115      	bne.n	2bc30 <at_parse_process_element+0x174>
		int value = (u32_t)strtoul(tmpstr, &next, 10);
   2bc04:	220a      	movs	r2, #10
   2bc06:	a902      	add	r1, sp, #8
   2bc08:	4628      	mov	r0, r5
   2bc0a:	f00e f8a1 	bl	39d50 <strtoul>
		tmpstr = next;
   2bc0e:	9b02      	ldr	r3, [sp, #8]
		if (value <= USHRT_MAX) {
   2bc10:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
		int value = (u32_t)strtoul(tmpstr, &next, 10);
   2bc14:	4602      	mov	r2, r0
		tmpstr = next;
   2bc16:	9300      	str	r3, [sp, #0]
		if (value <= USHRT_MAX) {
   2bc18:	da05      	bge.n	2bc26 <at_parse_process_element+0x16a>
			at_params_short_put(list, index, (u16_t)value);
   2bc1a:	b282      	uxth	r2, r0
   2bc1c:	4639      	mov	r1, r7
   2bc1e:	4630      	mov	r0, r6
   2bc20:	f012 face 	bl	3e1c0 <at_params_short_put>
   2bc24:	e784      	b.n	2bb30 <at_parse_process_element+0x74>
			at_params_int_put(list, index, value);
   2bc26:	4639      	mov	r1, r7
   2bc28:	4630      	mov	r0, r6
   2bc2a:	f012 faf2 	bl	3e212 <at_params_int_put>
   2bc2e:	e77f      	b.n	2bb30 <at_parse_process_element+0x74>
	} else if (state == SMS_PDU) {
   2bc30:	2c04      	cmp	r4, #4
   2bc32:	f47f af7d 	bne.w	2bb30 <at_parse_process_element+0x74>
		while (isxdigit((int)*tmpstr)) {
   2bc36:	4909      	ldr	r1, [pc, #36]	; (2bc5c <at_parse_process_element+0x1a0>)
   2bc38:	9b00      	ldr	r3, [sp, #0]
   2bc3a:	781a      	ldrb	r2, [r3, #0]
   2bc3c:	5c52      	ldrb	r2, [r2, r1]
   2bc3e:	f012 0f44 	tst.w	r2, #68	; 0x44
   2bc42:	d101      	bne.n	2bc48 <at_parse_process_element+0x18c>
		at_params_string_put(list, index, start_ptr,
   2bc44:	1b5b      	subs	r3, r3, r5
   2bc46:	e751      	b.n	2baec <at_parse_process_element+0x30>
			tmpstr++;
   2bc48:	3301      	adds	r3, #1
   2bc4a:	9300      	str	r3, [sp, #0]
   2bc4c:	e7f4      	b.n	2bc38 <at_parse_process_element+0x17c>
		return -1;
   2bc4e:	f04f 30ff 	mov.w	r0, #4294967295
   2bc52:	e771      	b.n	2bb38 <at_parse_process_element+0x7c>
   2bc54:	2002d7ea 	.word	0x2002d7ea
   2bc58:	00024001 	.word	0x00024001
   2bc5c:	00044327 	.word	0x00044327

0002bc60 <is_command>:
 *
 * @retval true  If the string is an AT command
 * @retval false Otherwise
 */
static inline bool is_command(const char *str)
{
   2bc60:	b510      	push	{r4, lr}
   2bc62:	4604      	mov	r4, r0
	if (strlen(str) < 2) {
   2bc64:	f7f1 fa78 	bl	1d158 <strlen>
   2bc68:	2801      	cmp	r0, #1
   2bc6a:	d922      	bls.n	2bcb2 <is_command+0x52>
		return false;
	}

	if ((toupper(str[0]) != 'A') || (toupper(str[1]) != 'T')) {
   2bc6c:	7821      	ldrb	r1, [r4, #0]
   2bc6e:	4b13      	ldr	r3, [pc, #76]	; (2bcbc <is_command+0x5c>)
   2bc70:	5cca      	ldrb	r2, [r1, r3]
   2bc72:	f002 0203 	and.w	r2, r2, #3
   2bc76:	2a02      	cmp	r2, #2
   2bc78:	bf08      	it	eq
   2bc7a:	3920      	subeq	r1, #32
   2bc7c:	2941      	cmp	r1, #65	; 0x41
   2bc7e:	461a      	mov	r2, r3
   2bc80:	d117      	bne.n	2bcb2 <is_command+0x52>
   2bc82:	7863      	ldrb	r3, [r4, #1]
   2bc84:	5cd2      	ldrb	r2, [r2, r3]
   2bc86:	f002 0203 	and.w	r2, r2, #3
   2bc8a:	2a02      	cmp	r2, #2
   2bc8c:	bf08      	it	eq
   2bc8e:	3b20      	subeq	r3, #32
   2bc90:	2b54      	cmp	r3, #84	; 0x54
   2bc92:	d10e      	bne.n	2bcb2 <is_command+0x52>
	}

	/* Third character has be one of the command special characters.
	 * The special case is a lone "AT" command.
	 */
	if ((str[2] == AT_STANDARD_NOTIFICATION_PREFIX) ||
   2bc94:	78a2      	ldrb	r2, [r4, #2]
   2bc96:	2a25      	cmp	r2, #37	; 0x25
   2bc98:	d00d      	beq.n	2bcb6 <is_command+0x56>
	    (str[2] == AT_PROP_NOTIFICATION_PREFX) ||
   2bc9a:	f002 03f7 	and.w	r3, r2, #247	; 0xf7
   2bc9e:	2b23      	cmp	r3, #35	; 0x23
   2bca0:	d009      	beq.n	2bcb6 <is_command+0x56>
	    (str[2] == AT_CUSTOM_COMMAND_PREFX) ||
	    is_lfcr(str[2]) || is_terminated(str[2])) {
   2bca2:	4610      	mov	r0, r2
   2bca4:	f012 fa54 	bl	3e150 <is_lfcr>
	    (str[2] == AT_CUSTOM_COMMAND_PREFX) ||
   2bca8:	b910      	cbnz	r0, 2bcb0 <is_command+0x50>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   2bcaa:	fab2 f082 	clz	r0, r2
   2bcae:	0940      	lsrs	r0, r0, #5
		return true;
	}

	return false;
}
   2bcb0:	bd10      	pop	{r4, pc}
	return false;
   2bcb2:	2000      	movs	r0, #0
   2bcb4:	e7fc      	b.n	2bcb0 <is_command+0x50>
		return true;
   2bcb6:	2001      	movs	r0, #1
   2bcb8:	e7fa      	b.n	2bcb0 <is_command+0x50>
   2bcba:	bf00      	nop
   2bcbc:	00044327 	.word	0x00044327

0002bcc0 <at_parse_detect_type>:
{
   2bcc0:	b570      	push	{r4, r5, r6, lr}
	const char *tmpstr = *str;
   2bcc2:	6804      	ldr	r4, [r0, #0]
	if ((index == 0) && is_notification(*tmpstr)) {
   2bcc4:	2900      	cmp	r1, #0
{
   2bcc6:	4606      	mov	r6, r0
   2bcc8:	7822      	ldrb	r2, [r4, #0]
	if ((index == 0) && is_notification(*tmpstr)) {
   2bcca:	d141      	bne.n	2bd50 <at_parse_detect_type+0x90>
	if ((chr == AT_STANDARD_NOTIFICATION_PREFIX) ||
   2bccc:	2a2b      	cmp	r2, #43	; 0x2b
   2bcce:	4d29      	ldr	r5, [pc, #164]	; (2bd74 <at_parse_detect_type+0xb4>)
   2bcd0:	d001      	beq.n	2bcd6 <at_parse_detect_type+0x16>
   2bcd2:	2a25      	cmp	r2, #37	; 0x25
   2bcd4:	d104      	bne.n	2bce0 <at_parse_detect_type+0x20>
	state = new_state;
   2bcd6:	2305      	movs	r3, #5
   2bcd8:	702b      	strb	r3, [r5, #0]
	return 0;
   2bcda:	2000      	movs	r0, #0
	*str = tmpstr;
   2bcdc:	6034      	str	r4, [r6, #0]
}
   2bcde:	bd70      	pop	{r4, r5, r6, pc}
	} else if ((index == 0) && is_command(tmpstr)) {
   2bce0:	4620      	mov	r0, r4
   2bce2:	f7ff ffbd 	bl	2bc60 <is_command>
   2bce6:	b388      	cbz	r0, 2bd4c <at_parse_detect_type+0x8c>
	state = new_state;
   2bce8:	2306      	movs	r3, #6
   2bcea:	e7f5      	b.n	2bcd8 <at_parse_detect_type+0x18>
	if (chr == '"') {
   2bcec:	2a22      	cmp	r2, #34	; 0x22
   2bcee:	d006      	beq.n	2bcfe <at_parse_detect_type+0x3e>
	if (chr == '(') {
   2bcf0:	2a28      	cmp	r2, #40	; 0x28
   2bcf2:	d109      	bne.n	2bd08 <at_parse_detect_type+0x48>
   2bcf4:	2201      	movs	r2, #1
   2bcf6:	4b1f      	ldr	r3, [pc, #124]	; (2bd74 <at_parse_detect_type+0xb4>)
		tmpstr++;
   2bcf8:	4414      	add	r4, r2
	state = new_state;
   2bcfa:	701a      	strb	r2, [r3, #0]
		tmpstr++;
   2bcfc:	e7ed      	b.n	2bcda <at_parse_detect_type+0x1a>
	state = new_state;
   2bcfe:	2202      	movs	r2, #2
   2bd00:	4b1c      	ldr	r3, [pc, #112]	; (2bd74 <at_parse_detect_type+0xb4>)
		tmpstr++;
   2bd02:	3401      	adds	r4, #1
	state = new_state;
   2bd04:	701a      	strb	r2, [r3, #0]
		tmpstr++;
   2bd06:	e7e8      	b.n	2bcda <at_parse_detect_type+0x1a>
	} else if (is_lfcr(*tmpstr) && (state == NUMBER)) {
   2bd08:	4610      	mov	r0, r2
   2bd0a:	f012 fa21 	bl	3e150 <is_lfcr>
   2bd0e:	b170      	cbz	r0, 2bd2e <at_parse_detect_type+0x6e>
   2bd10:	4918      	ldr	r1, [pc, #96]	; (2bd74 <at_parse_detect_type+0xb4>)
   2bd12:	7808      	ldrb	r0, [r1, #0]
   2bd14:	2803      	cmp	r0, #3
   2bd16:	d108      	bne.n	2bd2a <at_parse_detect_type+0x6a>
		while (is_lfcr(*tmpstr)) {
   2bd18:	f814 0f01 	ldrb.w	r0, [r4, #1]!
   2bd1c:	f012 fa18 	bl	3e150 <is_lfcr>
   2bd20:	2800      	cmp	r0, #0
   2bd22:	d1f9      	bne.n	2bd18 <at_parse_detect_type+0x58>
	state = new_state;
   2bd24:	2304      	movs	r3, #4
   2bd26:	700b      	strb	r3, [r1, #0]
   2bd28:	e7d7      	b.n	2bcda <at_parse_detect_type+0x1a>
	} else if (is_lfcr(*tmpstr) && (state == OPTIONAL)) {
   2bd2a:	2807      	cmp	r0, #7
   2bd2c:	d0d5      	beq.n	2bcda <at_parse_detect_type+0x1a>
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   2bd2e:	3a2c      	subs	r2, #44	; 0x2c
   2bd30:	b2d2      	uxtb	r2, r2
   2bd32:	2a11      	cmp	r2, #17
   2bd34:	d807      	bhi.n	2bd46 <at_parse_detect_type+0x86>
   2bd36:	4b10      	ldr	r3, [pc, #64]	; (2bd78 <at_parse_detect_type+0xb8>)
   2bd38:	fa23 f202 	lsr.w	r2, r3, r2
   2bd3c:	07d3      	lsls	r3, r2, #31
   2bd3e:	d502      	bpl.n	2bd46 <at_parse_detect_type+0x86>
	state = new_state;
   2bd40:	4b0c      	ldr	r3, [pc, #48]	; (2bd74 <at_parse_detect_type+0xb4>)
   2bd42:	2207      	movs	r2, #7
   2bd44:	e013      	b.n	2bd6e <at_parse_detect_type+0xae>
		return -1;
   2bd46:	f04f 30ff 	mov.w	r0, #4294967295
   2bd4a:	e7c8      	b.n	2bcde <at_parse_detect_type+0x1e>
	state = new_state;
   2bd4c:	2302      	movs	r3, #2
   2bd4e:	e7c3      	b.n	2bcd8 <at_parse_detect_type+0x18>
	} else if ((index > 0) && is_notification(*tmpstr)) {
   2bd50:	dd03      	ble.n	2bd5a <at_parse_detect_type+0x9a>
	if ((chr == AT_STANDARD_NOTIFICATION_PREFIX) ||
   2bd52:	2a2b      	cmp	r2, #43	; 0x2b
   2bd54:	d0f7      	beq.n	2bd46 <at_parse_detect_type+0x86>
   2bd56:	2a25      	cmp	r2, #37	; 0x25
   2bd58:	d0f5      	beq.n	2bd46 <at_parse_detect_type+0x86>
	if (isdigit(chr) || (chr == '-') || (chr == '+')) {
   2bd5a:	4b08      	ldr	r3, [pc, #32]	; (2bd7c <at_parse_detect_type+0xbc>)
   2bd5c:	5cd3      	ldrb	r3, [r2, r3]
   2bd5e:	0759      	lsls	r1, r3, #29
   2bd60:	d403      	bmi.n	2bd6a <at_parse_detect_type+0xaa>
   2bd62:	2a2d      	cmp	r2, #45	; 0x2d
   2bd64:	d001      	beq.n	2bd6a <at_parse_detect_type+0xaa>
   2bd66:	2a2b      	cmp	r2, #43	; 0x2b
   2bd68:	d1c0      	bne.n	2bcec <at_parse_detect_type+0x2c>
	state = new_state;
   2bd6a:	2203      	movs	r2, #3
   2bd6c:	4b01      	ldr	r3, [pc, #4]	; (2bd74 <at_parse_detect_type+0xb4>)
   2bd6e:	701a      	strb	r2, [r3, #0]
   2bd70:	e7b3      	b.n	2bcda <at_parse_detect_type+0x1a>
   2bd72:	bf00      	nop
   2bd74:	2002d7ea 	.word	0x2002d7ea
   2bd78:	00024001 	.word	0x00024001
   2bd7c:	00044327 	.word	0x00044327

0002bd80 <at_parser_max_params_from_str>:

int at_parser_max_params_from_str(const char *at_params_str,
				  char **next_param_str,
				  struct at_param_list *const list,
				  size_t max_params_count)
{
   2bd80:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2bd84:	4688      	mov	r8, r1
   2bd86:	4616      	mov	r6, r2
   2bd88:	461f      	mov	r7, r3
	int err = 0;

	if (at_params_str == NULL || list == NULL || list->params == NULL) {
   2bd8a:	4604      	mov	r4, r0
   2bd8c:	2800      	cmp	r0, #0
   2bd8e:	d07e      	beq.n	2be8e <at_parser_max_params_from_str+0x10e>
   2bd90:	2a00      	cmp	r2, #0
   2bd92:	d07c      	beq.n	2be8e <at_parser_max_params_from_str+0x10e>
   2bd94:	6853      	ldr	r3, [r2, #4]
   2bd96:	2b00      	cmp	r3, #0
   2bd98:	d079      	beq.n	2be8e <at_parser_max_params_from_str+0x10e>
	state = IDLE;
   2bd9a:	2500      	movs	r5, #0
		return -EINVAL;
	}

	at_params_list_clear(list);
   2bd9c:	4610      	mov	r0, r2
   2bd9e:	f000 f8eb 	bl	2bf78 <at_params_list_clear>

	max_params_count = MIN(max_params_count, list->param_count);
   2bda2:	6832      	ldr	r2, [r6, #0]
	const char *str = *at_params_str;
   2bda4:	9401      	str	r4, [sp, #4]
	max_params_count = MIN(max_params_count, list->param_count);
   2bda6:	4297      	cmp	r7, r2
   2bda8:	bf28      	it	cs
   2bdaa:	4617      	movcs	r7, r2
	int index = 0;
   2bdac:	462c      	mov	r4, r5
	state = IDLE;
   2bdae:	4b39      	ldr	r3, [pc, #228]	; (2be94 <at_parser_max_params_from_str+0x114>)
		if (isspace((int)*str)) {
   2bdb0:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 2be98 <at_parser_max_params_from_str+0x118>
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   2bdb4:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 2be9c <at_parser_max_params_from_str+0x11c>
	state = IDLE;
   2bdb8:	701d      	strb	r5, [r3, #0]
	while ((!is_terminated(*str)) && (index < max_params)) {
   2bdba:	9b01      	ldr	r3, [sp, #4]
   2bdbc:	781a      	ldrb	r2, [r3, #0]
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   2bdbe:	2a00      	cmp	r2, #0
   2bdc0:	d04b      	beq.n	2be5a <at_parser_max_params_from_str+0xda>
   2bdc2:	42a7      	cmp	r7, r4
   2bdc4:	d949      	bls.n	2be5a <at_parser_max_params_from_str+0xda>
		if (isspace((int)*str)) {
   2bdc6:	f812 2009 	ldrb.w	r2, [r2, r9]
		if (at_parse_detect_type(&str, index) == -1) {
   2bdca:	a801      	add	r0, sp, #4
		if (isspace((int)*str)) {
   2bdcc:	0711      	lsls	r1, r2, #28
			str++;
   2bdce:	bf48      	it	mi
   2bdd0:	3301      	addmi	r3, #1
		if (at_parse_detect_type(&str, index) == -1) {
   2bdd2:	4621      	mov	r1, r4
			str++;
   2bdd4:	bf48      	it	mi
   2bdd6:	9301      	strmi	r3, [sp, #4]
		if (at_parse_detect_type(&str, index) == -1) {
   2bdd8:	f7ff ff72 	bl	2bcc0 <at_parse_detect_type>
   2bddc:	1c42      	adds	r2, r0, #1
   2bdde:	d03c      	beq.n	2be5a <at_parser_max_params_from_str+0xda>
		if (at_parse_process_element(&str, index, list) == -1) {
   2bde0:	4632      	mov	r2, r6
   2bde2:	4621      	mov	r1, r4
   2bde4:	a801      	add	r0, sp, #4
   2bde6:	f7ff fe69 	bl	2babc <at_parse_process_element>
   2bdea:	1c43      	adds	r3, r0, #1
   2bdec:	d035      	beq.n	2be5a <at_parser_max_params_from_str+0xda>
		if (is_separator(*str)) {
   2bdee:	9b01      	ldr	r3, [sp, #4]
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   2bdf0:	781a      	ldrb	r2, [r3, #0]
   2bdf2:	3a2c      	subs	r2, #44	; 0x2c
   2bdf4:	b2d2      	uxtb	r2, r2
   2bdf6:	2a11      	cmp	r2, #17
   2bdf8:	d81a      	bhi.n	2be30 <at_parser_max_params_from_str+0xb0>
   2bdfa:	fa2a f202 	lsr.w	r2, sl, r2
   2bdfe:	07d1      	lsls	r1, r2, #31
   2be00:	d516      	bpl.n	2be30 <at_parser_max_params_from_str+0xb0>
			if (is_lfcr(*(str + 1))) {
   2be02:	7858      	ldrb	r0, [r3, #1]
   2be04:	f012 f9a4 	bl	3e150 <is_lfcr>
   2be08:	b178      	cbz	r0, 2be2a <at_parser_max_params_from_str+0xaa>
				index++;
   2be0a:	3401      	adds	r4, #1
				if (index == max_params) {
   2be0c:	42bc      	cmp	r4, r7
   2be0e:	d039      	beq.n	2be84 <at_parser_max_params_from_str+0x104>
				if (at_parse_detect_type(&str, index) == -1) {
   2be10:	4621      	mov	r1, r4
   2be12:	a801      	add	r0, sp, #4
   2be14:	f7ff ff54 	bl	2bcc0 <at_parse_detect_type>
   2be18:	1c42      	adds	r2, r0, #1
   2be1a:	d01e      	beq.n	2be5a <at_parser_max_params_from_str+0xda>
				if (at_parse_process_element(&str, index,
   2be1c:	4632      	mov	r2, r6
   2be1e:	4621      	mov	r1, r4
   2be20:	a801      	add	r0, sp, #4
   2be22:	f7ff fe4b 	bl	2babc <at_parse_process_element>
   2be26:	1c43      	adds	r3, r0, #1
   2be28:	d017      	beq.n	2be5a <at_parser_max_params_from_str+0xda>
			str++;
   2be2a:	9b01      	ldr	r3, [sp, #4]
   2be2c:	3301      	adds	r3, #1
   2be2e:	9301      	str	r3, [sp, #4]
		if (is_lfcr(*str)) {
   2be30:	9a01      	ldr	r2, [sp, #4]
   2be32:	7810      	ldrb	r0, [r2, #0]
   2be34:	f012 f98c 	bl	3e150 <is_lfcr>
   2be38:	b1f8      	cbz	r0, 2be7a <at_parser_max_params_from_str+0xfa>
   2be3a:	3201      	adds	r2, #1
			while (is_lfcr(str[++i])) {
   2be3c:	7811      	ldrb	r1, [r2, #0]
   2be3e:	4693      	mov	fp, r2
   2be40:	4608      	mov	r0, r1
   2be42:	3201      	adds	r2, #1
   2be44:	f012 f984 	bl	3e150 <is_lfcr>
   2be48:	2800      	cmp	r0, #0
   2be4a:	d1f7      	bne.n	2be3c <at_parser_max_params_from_str+0xbc>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   2be4c:	b119      	cbz	r1, 2be56 <at_parser_max_params_from_str+0xd6>
	if ((chr == AT_STANDARD_NOTIFICATION_PREFIX) ||
   2be4e:	292b      	cmp	r1, #43	; 0x2b
   2be50:	d001      	beq.n	2be56 <at_parser_max_params_from_str+0xd6>
   2be52:	2925      	cmp	r1, #37	; 0x25
   2be54:	d111      	bne.n	2be7a <at_parser_max_params_from_str+0xfa>
				str += i;
   2be56:	f8cd b004 	str.w	fp, [sp, #4]
	*at_params_str = str;
   2be5a:	9b01      	ldr	r3, [sp, #4]
	if (oversized) {
   2be5c:	b9a5      	cbnz	r5, 2be88 <at_parser_max_params_from_str+0x108>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   2be5e:	781a      	ldrb	r2, [r3, #0]
		return -EAGAIN;
   2be60:	2a00      	cmp	r2, #0
   2be62:	bf0c      	ite	eq
   2be64:	2000      	moveq	r0, #0
   2be66:	f06f 000a 	mvnne.w	r0, #10

	err = at_parse_param(&at_params_str, list, max_params_count);

	if (next_param_str) {
   2be6a:	f1b8 0f00 	cmp.w	r8, #0
   2be6e:	d001      	beq.n	2be74 <at_parser_max_params_from_str+0xf4>
		*next_param_str = (char *)at_params_str;
   2be70:	f8c8 3000 	str.w	r3, [r8]
	}

	return err;
}
   2be74:	b003      	add	sp, #12
   2be76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		index++;
   2be7a:	3401      	adds	r4, #1
			oversized = true;
   2be7c:	42bc      	cmp	r4, r7
   2be7e:	bf08      	it	eq
   2be80:	2501      	moveq	r5, #1
   2be82:	e79a      	b.n	2bdba <at_parser_max_params_from_str+0x3a>
					oversized = true;
   2be84:	4605      	mov	r5, r0
   2be86:	e7e8      	b.n	2be5a <at_parser_max_params_from_str+0xda>
		return -E2BIG;
   2be88:	f06f 0006 	mvn.w	r0, #6
   2be8c:	e7ed      	b.n	2be6a <at_parser_max_params_from_str+0xea>
		return -EINVAL;
   2be8e:	f06f 0015 	mvn.w	r0, #21
   2be92:	e7ef      	b.n	2be74 <at_parser_max_params_from_str+0xf4>
   2be94:	2002d7ea 	.word	0x2002d7ea
   2be98:	00044327 	.word	0x00044327
   2be9c:	00024001 	.word	0x00024001

0002bea0 <at_params_get>:
}

/* Internal function. Parameter cannot be null. */
static struct at_param *at_params_get(const struct at_param_list *list,
				      size_t index)
{
   2bea0:	b538      	push	{r3, r4, r5, lr}
   2bea2:	460c      	mov	r4, r1
	__ASSERT(list != NULL, "Parameter list cannot be NULL.");
   2bea4:	4605      	mov	r5, r0
   2bea6:	b960      	cbnz	r0, 2bec2 <at_params_get+0x22>
   2bea8:	490a      	ldr	r1, [pc, #40]	; (2bed4 <at_params_get+0x34>)
   2beaa:	232b      	movs	r3, #43	; 0x2b
   2beac:	4a0a      	ldr	r2, [pc, #40]	; (2bed8 <at_params_get+0x38>)
   2beae:	480b      	ldr	r0, [pc, #44]	; (2bedc <at_params_get+0x3c>)
   2beb0:	f010 fc3c 	bl	3c72c <printk>
   2beb4:	480a      	ldr	r0, [pc, #40]	; (2bee0 <at_params_get+0x40>)
   2beb6:	f010 fc39 	bl	3c72c <printk>
   2beba:	212b      	movs	r1, #43	; 0x2b
   2bebc:	4806      	ldr	r0, [pc, #24]	; (2bed8 <at_params_get+0x38>)
   2bebe:	f010 fc7b 	bl	3c7b8 <assert_post_action>

	if (index >= list->param_count) {
   2bec2:	682b      	ldr	r3, [r5, #0]
   2bec4:	42a3      	cmp	r3, r4
		return NULL;
	}

	struct at_param *param = list->params;

	return &param[index];
   2bec6:	bf85      	ittet	hi
   2bec8:	230c      	movhi	r3, #12
   2beca:	6868      	ldrhi	r0, [r5, #4]
		return NULL;
   2becc:	2000      	movls	r0, #0
	return &param[index];
   2bece:	fb03 0004 	mlahi	r0, r3, r4, r0
}
   2bed2:	bd38      	pop	{r3, r4, r5, pc}
   2bed4:	00043105 	.word	0x00043105
   2bed8:	000430d7 	.word	0x000430d7
   2bedc:	00040606 	.word	0x00040606
   2bee0:	00043119 	.word	0x00043119

0002bee4 <at_param_size>:

/* Internal function. Parameter cannot be null. */
static size_t at_param_size(const struct at_param *param)
{
   2bee4:	b510      	push	{r4, lr}
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   2bee6:	4604      	mov	r4, r0
   2bee8:	b960      	cbnz	r0, 2bf04 <at_param_size+0x20>
   2beea:	490e      	ldr	r1, [pc, #56]	; (2bf24 <at_param_size+0x40>)
   2beec:	2339      	movs	r3, #57	; 0x39
   2beee:	4a0e      	ldr	r2, [pc, #56]	; (2bf28 <at_param_size+0x44>)
   2bef0:	480e      	ldr	r0, [pc, #56]	; (2bf2c <at_param_size+0x48>)
   2bef2:	f010 fc1b 	bl	3c72c <printk>
   2bef6:	480e      	ldr	r0, [pc, #56]	; (2bf30 <at_param_size+0x4c>)
   2bef8:	f010 fc18 	bl	3c72c <printk>
   2befc:	2139      	movs	r1, #57	; 0x39
   2befe:	480a      	ldr	r0, [pc, #40]	; (2bf28 <at_param_size+0x44>)
   2bf00:	f010 fc5a 	bl	3c7b8 <assert_post_action>

	if (param->type == AT_PARAM_TYPE_NUM_SHORT) {
   2bf04:	7823      	ldrb	r3, [r4, #0]
   2bf06:	2b01      	cmp	r3, #1
   2bf08:	d006      	beq.n	2bf18 <at_param_size+0x34>
		return sizeof(u16_t);
	} else if (param->type == AT_PARAM_TYPE_NUM_INT) {
   2bf0a:	2b02      	cmp	r3, #2
   2bf0c:	d006      	beq.n	2bf1c <at_param_size+0x38>
		return sizeof(u32_t);
	} else if ((param->type == AT_PARAM_TYPE_STRING) ||
   2bf0e:	3b03      	subs	r3, #3
   2bf10:	2b01      	cmp	r3, #1
   2bf12:	d805      	bhi.n	2bf20 <at_param_size+0x3c>
		   (param->type == AT_PARAM_TYPE_ARRAY)) {
		return param->size;
   2bf14:	6860      	ldr	r0, [r4, #4]
	}

	return 0;
}
   2bf16:	bd10      	pop	{r4, pc}
		return sizeof(u16_t);
   2bf18:	2002      	movs	r0, #2
   2bf1a:	e7fc      	b.n	2bf16 <at_param_size+0x32>
		return sizeof(u32_t);
   2bf1c:	2004      	movs	r0, #4
   2bf1e:	e7fa      	b.n	2bf16 <at_param_size+0x32>
	return 0;
   2bf20:	2000      	movs	r0, #0
   2bf22:	e7f8      	b.n	2bf16 <at_param_size+0x32>
   2bf24:	000430a6 	.word	0x000430a6
   2bf28:	000430d7 	.word	0x000430d7
   2bf2c:	00040606 	.word	0x00040606
   2bf30:	000430bb 	.word	0x000430bb

0002bf34 <at_param_clear>:
{
   2bf34:	b510      	push	{r4, lr}
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   2bf36:	4604      	mov	r4, r0
   2bf38:	b960      	cbnz	r0, 2bf54 <at_param_clear+0x20>
   2bf3a:	490b      	ldr	r1, [pc, #44]	; (2bf68 <at_param_clear+0x34>)
   2bf3c:	231d      	movs	r3, #29
   2bf3e:	4a0b      	ldr	r2, [pc, #44]	; (2bf6c <at_param_clear+0x38>)
   2bf40:	480b      	ldr	r0, [pc, #44]	; (2bf70 <at_param_clear+0x3c>)
   2bf42:	f010 fbf3 	bl	3c72c <printk>
   2bf46:	480b      	ldr	r0, [pc, #44]	; (2bf74 <at_param_clear+0x40>)
   2bf48:	f010 fbf0 	bl	3c72c <printk>
   2bf4c:	211d      	movs	r1, #29
   2bf4e:	4807      	ldr	r0, [pc, #28]	; (2bf6c <at_param_clear+0x38>)
   2bf50:	f010 fc32 	bl	3c7b8 <assert_post_action>
	if ((param->type == AT_PARAM_TYPE_STRING) ||
   2bf54:	7823      	ldrb	r3, [r4, #0]
   2bf56:	3b03      	subs	r3, #3
   2bf58:	2b01      	cmp	r3, #1
   2bf5a:	d802      	bhi.n	2bf62 <at_param_clear+0x2e>
		k_free(param->value.str_val);
   2bf5c:	68a0      	ldr	r0, [r4, #8]
   2bf5e:	f012 faa6 	bl	3e4ae <k_free>
	param->value.int_val = 0;
   2bf62:	2300      	movs	r3, #0
   2bf64:	60a3      	str	r3, [r4, #8]
}
   2bf66:	bd10      	pop	{r4, pc}
   2bf68:	000430a6 	.word	0x000430a6
   2bf6c:	000430d7 	.word	0x000430d7
   2bf70:	00040606 	.word	0x00040606
   2bf74:	000430bb 	.word	0x000430bb

0002bf78 <at_params_list_clear>:
	list->param_count = max_params_count;
	return 0;
}

void at_params_list_clear(struct at_param_list *list)
{
   2bf78:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (list == NULL || list->params == NULL) {
   2bf7c:	4605      	mov	r5, r0
   2bf7e:	b158      	cbz	r0, 2bf98 <at_params_list_clear+0x20>
   2bf80:	6843      	ldr	r3, [r0, #4]
   2bf82:	b14b      	cbz	r3, 2bf98 <at_params_list_clear+0x20>
		return;
	}

	for (size_t i = 0; i < list->param_count; ++i) {
   2bf84:	2400      	movs	r4, #0
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   2bf86:	f8df 8054 	ldr.w	r8, [pc, #84]	; 2bfdc <at_params_list_clear+0x64>
   2bf8a:	f8df a054 	ldr.w	sl, [pc, #84]	; 2bfe0 <at_params_list_clear+0x68>
   2bf8e:	f8df b054 	ldr.w	fp, [pc, #84]	; 2bfe4 <at_params_list_clear+0x6c>
	for (size_t i = 0; i < list->param_count; ++i) {
   2bf92:	682b      	ldr	r3, [r5, #0]
   2bf94:	429c      	cmp	r4, r3
   2bf96:	d301      	bcc.n	2bf9c <at_params_list_clear+0x24>
		struct at_param *params = list->params;

		at_param_clear(&params[i]);
		at_param_init(&params[i]);
	}
}
   2bf98:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		at_param_clear(&params[i]);
   2bf9c:	270c      	movs	r7, #12
   2bf9e:	4367      	muls	r7, r4
   2bfa0:	f8d5 9004 	ldr.w	r9, [r5, #4]
   2bfa4:	eb09 0607 	add.w	r6, r9, r7
   2bfa8:	4630      	mov	r0, r6
   2bfaa:	f7ff ffc3 	bl	2bf34 <at_param_clear>
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   2bfae:	b966      	cbnz	r6, 2bfca <at_params_list_clear+0x52>
   2bfb0:	4651      	mov	r1, sl
   2bfb2:	2314      	movs	r3, #20
   2bfb4:	4642      	mov	r2, r8
   2bfb6:	4658      	mov	r0, fp
   2bfb8:	f010 fbb8 	bl	3c72c <printk>
   2bfbc:	4806      	ldr	r0, [pc, #24]	; (2bfd8 <at_params_list_clear+0x60>)
   2bfbe:	f010 fbb5 	bl	3c72c <printk>
   2bfc2:	2114      	movs	r1, #20
   2bfc4:	4640      	mov	r0, r8
   2bfc6:	f010 fbf7 	bl	3c7b8 <assert_post_action>
   2bfca:	2300      	movs	r3, #0
	for (size_t i = 0; i < list->param_count; ++i) {
   2bfcc:	3401      	adds	r4, #1
   2bfce:	f849 3007 	str.w	r3, [r9, r7]
   2bfd2:	6073      	str	r3, [r6, #4]
   2bfd4:	60b3      	str	r3, [r6, #8]
   2bfd6:	e7dc      	b.n	2bf92 <at_params_list_clear+0x1a>
   2bfd8:	000430bb 	.word	0x000430bb
   2bfdc:	000430d7 	.word	0x000430d7
   2bfe0:	000430a6 	.word	0x000430a6
   2bfe4:	00040606 	.word	0x00040606

0002bfe8 <w_lte_lc_init>:
	}
}

static int w_lte_lc_init(void)
{
	if (at_cmd_write(nw_mode_preferred, NULL, 0, NULL) != 0) {
   2bfe8:	2300      	movs	r3, #0
{
   2bfea:	b510      	push	{r4, lr}
	if (at_cmd_write(nw_mode_preferred, NULL, 0, NULL) != 0) {
   2bfec:	461a      	mov	r2, r3
   2bfee:	4619      	mov	r1, r3
   2bff0:	4813      	ldr	r0, [pc, #76]	; (2c040 <w_lte_lc_init+0x58>)
   2bff2:	f7ff fa2d 	bl	2b450 <at_cmd_write>
   2bff6:	4603      	mov	r3, r0
   2bff8:	b118      	cbz	r0, 2c002 <w_lte_lc_init+0x1a>
		return -EIO;
   2bffa:	f06f 0404 	mvn.w	r4, #4
	}
	LOG_INF("PDN Auth: %s", log_strdup(cgauth));
#endif

	return 0;
}
   2bffe:	4620      	mov	r0, r4
   2c000:	bd10      	pop	{r4, pc}
	if (at_cmd_write(cereg_5_subscribe, NULL, 0, NULL) != 0) {
   2c002:	4602      	mov	r2, r0
   2c004:	4601      	mov	r1, r0
   2c006:	480f      	ldr	r0, [pc, #60]	; (2c044 <w_lte_lc_init+0x5c>)
   2c008:	f7ff fa22 	bl	2b450 <at_cmd_write>
   2c00c:	4603      	mov	r3, r0
   2c00e:	2800      	cmp	r0, #0
   2c010:	d1f3      	bne.n	2bffa <w_lte_lc_init+0x12>
	if (at_cmd_write(legacy_pco, NULL, 0, NULL) != 0) {
   2c012:	4602      	mov	r2, r0
   2c014:	4601      	mov	r1, r0
   2c016:	480c      	ldr	r0, [pc, #48]	; (2c048 <w_lte_lc_init+0x60>)
   2c018:	f7ff fa1a 	bl	2b450 <at_cmd_write>
   2c01c:	4604      	mov	r4, r0
   2c01e:	2800      	cmp	r0, #0
   2c020:	d1eb      	bne.n	2bffa <w_lte_lc_init+0x12>
	LOG_INF("Using legacy LTE PCO mode...");
   2c022:	2303      	movs	r3, #3
   2c024:	f04f 0000 	mov.w	r0, #0
   2c028:	4a08      	ldr	r2, [pc, #32]	; (2c04c <w_lte_lc_init+0x64>)
   2c02a:	f363 0007 	bfi	r0, r3, #0, #8
   2c02e:	4b08      	ldr	r3, [pc, #32]	; (2c050 <w_lte_lc_init+0x68>)
   2c030:	4908      	ldr	r1, [pc, #32]	; (2c054 <w_lte_lc_init+0x6c>)
   2c032:	1a9b      	subs	r3, r3, r2
   2c034:	08db      	lsrs	r3, r3, #3
   2c036:	f363 108f 	bfi	r0, r3, #6, #10
   2c03a:	f010 fbce 	bl	3c7da <log_string_sync>
	return 0;
   2c03e:	e7de      	b.n	2bffe <w_lte_lc_init+0x16>
   2c040:	000431a4 	.word	0x000431a4
   2c044:	00043184 	.word	0x00043184
   2c048:	0004318f 	.word	0x0004318f
   2c04c:	0003f8d4 	.word	0x0003f8d4
   2c050:	0003f96c 	.word	0x0003f96c
   2c054:	000432ff 	.word	0x000432ff

0002c058 <parse_nw_reg_status>:
static int parse_nw_reg_status(const char *at_response,
			       enum lte_lc_nw_reg_status *status,
			       size_t reg_status_index)
{
	int err, reg_status;
	struct at_param_list resp_list = {0};
   2c058:	2300      	movs	r3, #0
{
   2c05a:	b5f0      	push	{r4, r5, r6, r7, lr}
   2c05c:	b087      	sub	sp, #28
	char  response_prefix[sizeof(AT_CEREG_RESPONSE_PREFIX)] = {0};
   2c05e:	9302      	str	r3, [sp, #8]
	struct at_param_list resp_list = {0};
   2c060:	e9cd 3304 	strd	r3, r3, [sp, #16]
	char  response_prefix[sizeof(AT_CEREG_RESPONSE_PREFIX)] = {0};
   2c064:	f8cd 300b 	str.w	r3, [sp, #11]
	size_t response_prefix_len = sizeof(response_prefix);
   2c068:	2307      	movs	r3, #7
{
   2c06a:	460d      	mov	r5, r1
   2c06c:	4617      	mov	r7, r2
	size_t response_prefix_len = sizeof(response_prefix);
   2c06e:	9301      	str	r3, [sp, #4]

	if ((at_response == NULL) || (status == NULL)) {
   2c070:	4606      	mov	r6, r0
   2c072:	2800      	cmp	r0, #0
   2c074:	f000 8082 	beq.w	2c17c <parse_nw_reg_status+0x124>
   2c078:	2900      	cmp	r1, #0
   2c07a:	d07f      	beq.n	2c17c <parse_nw_reg_status+0x124>
		return -EINVAL;
	}

	err = at_params_list_init(&resp_list, AT_CEREG_PARAMS_COUNT_MAX);
   2c07c:	210a      	movs	r1, #10
   2c07e:	a804      	add	r0, sp, #16
   2c080:	f012 f87d 	bl	3e17e <at_params_list_init>
	if (err) {
   2c084:	4604      	mov	r4, r0
   2c086:	b188      	cbz	r0, 2c0ac <parse_nw_reg_status+0x54>
		LOG_ERR("Could not init AT params list, error: %d", err);
   2c088:	2301      	movs	r3, #1
   2c08a:	f04f 0000 	mov.w	r0, #0
   2c08e:	4a3d      	ldr	r2, [pc, #244]	; (2c184 <parse_nw_reg_status+0x12c>)
   2c090:	f363 0007 	bfi	r0, r3, #0, #8
   2c094:	4b3c      	ldr	r3, [pc, #240]	; (2c188 <parse_nw_reg_status+0x130>)
   2c096:	493d      	ldr	r1, [pc, #244]	; (2c18c <parse_nw_reg_status+0x134>)
   2c098:	1a9b      	subs	r3, r3, r2
   2c09a:	08db      	lsrs	r3, r3, #3
   2c09c:	f363 108f 	bfi	r0, r3, #6, #10
   2c0a0:	4622      	mov	r2, r4
   2c0a2:	f010 fb9a 	bl	3c7da <log_string_sync>

clean_exit:
	at_params_list_free(&resp_list);

	return err;
}
   2c0a6:	4620      	mov	r0, r4
   2c0a8:	b007      	add	sp, #28
   2c0aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
	err = at_parser_max_params_from_str(at_response,
   2c0ac:	4601      	mov	r1, r0
   2c0ae:	230a      	movs	r3, #10
   2c0b0:	aa04      	add	r2, sp, #16
   2c0b2:	4630      	mov	r0, r6
   2c0b4:	f7ff fe64 	bl	2bd80 <at_parser_max_params_from_str>
	if (err) {
   2c0b8:	4604      	mov	r4, r0
   2c0ba:	b190      	cbz	r0, 2c0e2 <parse_nw_reg_status+0x8a>
		LOG_ERR("Could not parse AT+CEREG response, error: %d", err);
   2c0bc:	2301      	movs	r3, #1
   2c0be:	f04f 0000 	mov.w	r0, #0
   2c0c2:	4a30      	ldr	r2, [pc, #192]	; (2c184 <parse_nw_reg_status+0x12c>)
   2c0c4:	f363 0007 	bfi	r0, r3, #0, #8
   2c0c8:	4b2f      	ldr	r3, [pc, #188]	; (2c188 <parse_nw_reg_status+0x130>)
   2c0ca:	4931      	ldr	r1, [pc, #196]	; (2c190 <parse_nw_reg_status+0x138>)
   2c0cc:	1a9b      	subs	r3, r3, r2
   2c0ce:	4622      	mov	r2, r4
   2c0d0:	08db      	lsrs	r3, r3, #3
   2c0d2:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Could not get response prefix, error: %d", err);
   2c0d6:	f010 fb80 	bl	3c7da <log_string_sync>
	at_params_list_free(&resp_list);
   2c0da:	a804      	add	r0, sp, #16
   2c0dc:	f012 f862 	bl	3e1a4 <at_params_list_free>
	return err;
   2c0e0:	e7e1      	b.n	2c0a6 <parse_nw_reg_status+0x4e>
	err = at_params_string_get(&resp_list,
   2c0e2:	4601      	mov	r1, r0
   2c0e4:	ab01      	add	r3, sp, #4
   2c0e6:	aa02      	add	r2, sp, #8
   2c0e8:	a804      	add	r0, sp, #16
   2c0ea:	f012 f920 	bl	3e32e <at_params_string_get>
	if (err) {
   2c0ee:	4604      	mov	r4, r0
   2c0f0:	b168      	cbz	r0, 2c10e <parse_nw_reg_status+0xb6>
		LOG_ERR("Could not get response prefix, error: %d", err);
   2c0f2:	2301      	movs	r3, #1
   2c0f4:	f04f 0000 	mov.w	r0, #0
   2c0f8:	4a22      	ldr	r2, [pc, #136]	; (2c184 <parse_nw_reg_status+0x12c>)
   2c0fa:	f363 0007 	bfi	r0, r3, #0, #8
   2c0fe:	4b22      	ldr	r3, [pc, #136]	; (2c188 <parse_nw_reg_status+0x130>)
   2c100:	4924      	ldr	r1, [pc, #144]	; (2c194 <parse_nw_reg_status+0x13c>)
   2c102:	1a9b      	subs	r3, r3, r2
   2c104:	08db      	lsrs	r3, r3, #3
   2c106:	f363 108f 	bfi	r0, r3, #6, #10
   2c10a:	4622      	mov	r2, r4
   2c10c:	e7e3      	b.n	2c0d6 <parse_nw_reg_status+0x7e>
	if (!response_is_valid(response_prefix, response_prefix_len,
   2c10e:	4a22      	ldr	r2, [pc, #136]	; (2c198 <parse_nw_reg_status+0x140>)
   2c110:	9901      	ldr	r1, [sp, #4]
   2c112:	a802      	add	r0, sp, #8
   2c114:	f012 f949 	bl	3e3aa <response_is_valid>
   2c118:	2800      	cmp	r0, #0
   2c11a:	d0de      	beq.n	2c0da <parse_nw_reg_status+0x82>
	err = at_params_int_get(&resp_list, reg_status_index,
   2c11c:	466a      	mov	r2, sp
   2c11e:	4639      	mov	r1, r7
   2c120:	a804      	add	r0, sp, #16
   2c122:	f012 f8ed 	bl	3e300 <at_params_int_get>
	if (err) {
   2c126:	4604      	mov	r4, r0
   2c128:	b168      	cbz	r0, 2c146 <parse_nw_reg_status+0xee>
		LOG_ERR("Could not get registration status, error: %d", err);
   2c12a:	2301      	movs	r3, #1
   2c12c:	f04f 0000 	mov.w	r0, #0
   2c130:	4a14      	ldr	r2, [pc, #80]	; (2c184 <parse_nw_reg_status+0x12c>)
   2c132:	f363 0007 	bfi	r0, r3, #0, #8
   2c136:	4b14      	ldr	r3, [pc, #80]	; (2c188 <parse_nw_reg_status+0x130>)
   2c138:	4918      	ldr	r1, [pc, #96]	; (2c19c <parse_nw_reg_status+0x144>)
   2c13a:	1a9b      	subs	r3, r3, r2
   2c13c:	08db      	lsrs	r3, r3, #3
   2c13e:	f363 108f 	bfi	r0, r3, #6, #10
   2c142:	4622      	mov	r2, r4
   2c144:	e7c7      	b.n	2c0d6 <parse_nw_reg_status+0x7e>
	switch (reg_status) {
   2c146:	9a00      	ldr	r2, [sp, #0]
   2c148:	2a08      	cmp	r2, #8
   2c14a:	d015      	beq.n	2c178 <parse_nw_reg_status+0x120>
   2c14c:	dc12      	bgt.n	2c174 <parse_nw_reg_status+0x11c>
   2c14e:	2a05      	cmp	r2, #5
   2c150:	d912      	bls.n	2c178 <parse_nw_reg_status+0x120>
		LOG_ERR("Invalid network registration status: %d", reg_status);
   2c152:	2301      	movs	r3, #1
   2c154:	f04f 0000 	mov.w	r0, #0
   2c158:	490a      	ldr	r1, [pc, #40]	; (2c184 <parse_nw_reg_status+0x12c>)
   2c15a:	f363 0007 	bfi	r0, r3, #0, #8
   2c15e:	4b0a      	ldr	r3, [pc, #40]	; (2c188 <parse_nw_reg_status+0x130>)
		err = -EIO;
   2c160:	f06f 0404 	mvn.w	r4, #4
   2c164:	1a5b      	subs	r3, r3, r1
   2c166:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Invalid network registration status: %d", reg_status);
   2c168:	f363 108f 	bfi	r0, r3, #6, #10
   2c16c:	490c      	ldr	r1, [pc, #48]	; (2c1a0 <parse_nw_reg_status+0x148>)
   2c16e:	f010 fb34 	bl	3c7da <log_string_sync>
		err = -EIO;
   2c172:	e7b2      	b.n	2c0da <parse_nw_reg_status+0x82>
	switch (reg_status) {
   2c174:	2a5a      	cmp	r2, #90	; 0x5a
   2c176:	d1ec      	bne.n	2c152 <parse_nw_reg_status+0xfa>
		*status = reg_status;
   2c178:	702a      	strb	r2, [r5, #0]
		LOG_DBG("Network registration status: %d", reg_status);
   2c17a:	e7ae      	b.n	2c0da <parse_nw_reg_status+0x82>
		return -EINVAL;
   2c17c:	f06f 0415 	mvn.w	r4, #21
   2c180:	e791      	b.n	2c0a6 <parse_nw_reg_status+0x4e>
   2c182:	bf00      	nop
   2c184:	0003f8d4 	.word	0x0003f8d4
   2c188:	0003f96c 	.word	0x0003f96c
   2c18c:	000431bb 	.word	0x000431bb
   2c190:	000431e4 	.word	0x000431e4
   2c194:	00043211 	.word	0x00043211
   2c198:	0004323a 	.word	0x0004323a
   2c19c:	00043241 	.word	0x00043241
   2c1a0:	0004326e 	.word	0x0004326e

0002c1a4 <at_handler>:
{
   2c1a4:	b507      	push	{r0, r1, r2, lr}
	if (response == NULL) {
   2c1a6:	4608      	mov	r0, r1
   2c1a8:	b971      	cbnz	r1, 2c1c8 <at_handler+0x24>
		LOG_ERR("Response buffer is NULL-pointer");
   2c1aa:	2301      	movs	r3, #1
   2c1ac:	4a15      	ldr	r2, [pc, #84]	; (2c204 <at_handler+0x60>)
   2c1ae:	f363 0007 	bfi	r0, r3, #0, #8
   2c1b2:	4b15      	ldr	r3, [pc, #84]	; (2c208 <at_handler+0x64>)
   2c1b4:	4915      	ldr	r1, [pc, #84]	; (2c20c <at_handler+0x68>)
   2c1b6:	1a9b      	subs	r3, r3, r2
   2c1b8:	08db      	lsrs	r3, r3, #3
   2c1ba:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Could not get network registration status");
   2c1be:	f010 fb0c 	bl	3c7da <log_string_sync>
}
   2c1c2:	b003      	add	sp, #12
   2c1c4:	f85d fb04 	ldr.w	pc, [sp], #4
	err = parse_nw_reg_status(response, &status, AT_CEREG_REG_STATUS_INDEX);
   2c1c8:	2201      	movs	r2, #1
   2c1ca:	f10d 0107 	add.w	r1, sp, #7
   2c1ce:	f7ff ff43 	bl	2c058 <parse_nw_reg_status>
	if (err) {
   2c1d2:	b160      	cbz	r0, 2c1ee <at_handler+0x4a>
		LOG_ERR("Could not get network registration status");
   2c1d4:	2301      	movs	r3, #1
   2c1d6:	f04f 0000 	mov.w	r0, #0
   2c1da:	4a0a      	ldr	r2, [pc, #40]	; (2c204 <at_handler+0x60>)
   2c1dc:	f363 0007 	bfi	r0, r3, #0, #8
   2c1e0:	4b09      	ldr	r3, [pc, #36]	; (2c208 <at_handler+0x64>)
   2c1e2:	490b      	ldr	r1, [pc, #44]	; (2c210 <at_handler+0x6c>)
   2c1e4:	1a9b      	subs	r3, r3, r2
   2c1e6:	08db      	lsrs	r3, r3, #3
   2c1e8:	f363 108f 	bfi	r0, r3, #6, #10
   2c1ec:	e7e7      	b.n	2c1be <at_handler+0x1a>
	if ((status == LTE_LC_NW_REG_REGISTERED_HOME) ||
   2c1ee:	f89d 3007 	ldrb.w	r3, [sp, #7]
   2c1f2:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
   2c1f6:	2b01      	cmp	r3, #1
   2c1f8:	d1e3      	bne.n	2c1c2 <at_handler+0x1e>
	z_impl_k_sem_give(sem);
   2c1fa:	4806      	ldr	r0, [pc, #24]	; (2c214 <at_handler+0x70>)
   2c1fc:	f00b fba2 	bl	37944 <z_impl_k_sem_give>
   2c200:	e7df      	b.n	2c1c2 <at_handler+0x1e>
   2c202:	bf00      	nop
   2c204:	0003f8d4 	.word	0x0003f8d4
   2c208:	0003f96c 	.word	0x0003f96c
   2c20c:	0004313a 	.word	0x0004313a
   2c210:	0004315a 	.word	0x0004315a
   2c214:	20024e1c 	.word	0x20024e1c

0002c218 <w_lte_lc_connect>:
{
   2c218:	b510      	push	{r4, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
   2c21a:	2201      	movs	r2, #1
   2c21c:	2100      	movs	r1, #0
   2c21e:	482c      	ldr	r0, [pc, #176]	; (2c2d0 <w_lte_lc_connect+0xb8>)
   2c220:	f012 f9c4 	bl	3e5ac <z_impl_k_sem_init>
	rc = at_notif_register_handler(NULL, at_handler);
   2c224:	492b      	ldr	r1, [pc, #172]	; (2c2d4 <w_lte_lc_connect+0xbc>)
   2c226:	2000      	movs	r0, #0
   2c228:	f7ff f9c4 	bl	2b5b4 <at_notif_register_handler>
	if (rc != 0) {
   2c22c:	4604      	mov	r4, r0
   2c22e:	b180      	cbz	r0, 2c252 <w_lte_lc_connect+0x3a>
		LOG_ERR("Can't register handler rc=%d", rc);
   2c230:	2301      	movs	r3, #1
   2c232:	f04f 0000 	mov.w	r0, #0
   2c236:	4a28      	ldr	r2, [pc, #160]	; (2c2d8 <w_lte_lc_connect+0xc0>)
   2c238:	f363 0007 	bfi	r0, r3, #0, #8
   2c23c:	4b27      	ldr	r3, [pc, #156]	; (2c2dc <w_lte_lc_connect+0xc4>)
   2c23e:	4928      	ldr	r1, [pc, #160]	; (2c2e0 <w_lte_lc_connect+0xc8>)
   2c240:	1a9b      	subs	r3, r3, r2
   2c242:	4622      	mov	r2, r4
   2c244:	08db      	lsrs	r3, r3, #3
   2c246:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Can't de-register handler rc=%d", rc);
   2c24a:	f010 fac6 	bl	3c7da <log_string_sync>
}
   2c24e:	4620      	mov	r0, r4
   2c250:	bd10      	pop	{r4, pc}
		if (at_cmd_write(current_network_mode, NULL, 0, NULL) != 0) {
   2c252:	4603      	mov	r3, r0
   2c254:	4602      	mov	r2, r0
   2c256:	4601      	mov	r1, r0
   2c258:	4822      	ldr	r0, [pc, #136]	; (2c2e4 <w_lte_lc_connect+0xcc>)
   2c25a:	f7ff f8f9 	bl	2b450 <at_cmd_write>
   2c25e:	b1a8      	cbz	r0, 2c28c <w_lte_lc_connect+0x74>
			err = -EIO;
   2c260:	f06f 0404 	mvn.w	r4, #4
	rc = at_notif_deregister_handler(NULL, at_handler);
   2c264:	491b      	ldr	r1, [pc, #108]	; (2c2d4 <w_lte_lc_connect+0xbc>)
   2c266:	2000      	movs	r0, #0
   2c268:	f7ff f9f0 	bl	2b64c <at_notif_deregister_handler>
	if (rc != 0) {
   2c26c:	4602      	mov	r2, r0
   2c26e:	2800      	cmp	r0, #0
   2c270:	d0ed      	beq.n	2c24e <w_lte_lc_connect+0x36>
		LOG_ERR("Can't de-register handler rc=%d", rc);
   2c272:	2301      	movs	r3, #1
   2c274:	f04f 0000 	mov.w	r0, #0
   2c278:	4917      	ldr	r1, [pc, #92]	; (2c2d8 <w_lte_lc_connect+0xc0>)
   2c27a:	f363 0007 	bfi	r0, r3, #0, #8
   2c27e:	4b17      	ldr	r3, [pc, #92]	; (2c2dc <w_lte_lc_connect+0xc4>)
   2c280:	1a5b      	subs	r3, r3, r1
   2c282:	08db      	lsrs	r3, r3, #3
   2c284:	f363 108f 	bfi	r0, r3, #6, #10
   2c288:	4917      	ldr	r1, [pc, #92]	; (2c2e8 <w_lte_lc_connect+0xd0>)
   2c28a:	e7de      	b.n	2c24a <w_lte_lc_connect+0x32>
		if (at_cmd_write(normal, NULL, 0, NULL) != 0) {
   2c28c:	4623      	mov	r3, r4
   2c28e:	4622      	mov	r2, r4
   2c290:	4621      	mov	r1, r4
   2c292:	4816      	ldr	r0, [pc, #88]	; (2c2ec <w_lte_lc_connect+0xd4>)
   2c294:	f7ff f8dc 	bl	2b450 <at_cmd_write>
   2c298:	2800      	cmp	r0, #0
   2c29a:	d1e1      	bne.n	2c260 <w_lte_lc_connect+0x48>
	return z_impl_k_sem_take(sem, timeout);
   2c29c:	f64e 2160 	movw	r1, #60000	; 0xea60
   2c2a0:	480b      	ldr	r0, [pc, #44]	; (2c2d0 <w_lte_lc_connect+0xb8>)
   2c2a2:	f00b fb99 	bl	379d8 <z_impl_k_sem_take>
		if (err == -EAGAIN) {
   2c2a6:	f110 0f0b 	cmn.w	r0, #11
   2c2aa:	4604      	mov	r4, r0
   2c2ac:	d1da      	bne.n	2c264 <w_lte_lc_connect+0x4c>
			LOG_INF("Network connection attempt timed out");
   2c2ae:	2303      	movs	r3, #3
   2c2b0:	f04f 0000 	mov.w	r0, #0
   2c2b4:	4a08      	ldr	r2, [pc, #32]	; (2c2d8 <w_lte_lc_connect+0xc0>)
   2c2b6:	f363 0007 	bfi	r0, r3, #0, #8
   2c2ba:	4b08      	ldr	r3, [pc, #32]	; (2c2dc <w_lte_lc_connect+0xc4>)
   2c2bc:	490c      	ldr	r1, [pc, #48]	; (2c2f0 <w_lte_lc_connect+0xd8>)
   2c2be:	1a9b      	subs	r3, r3, r2
   2c2c0:	08db      	lsrs	r3, r3, #3
   2c2c2:	f363 108f 	bfi	r0, r3, #6, #10
   2c2c6:	f010 fa88 	bl	3c7da <log_string_sync>
				err = -ETIMEDOUT;
   2c2ca:	f06f 0473 	mvn.w	r4, #115	; 0x73
   2c2ce:	e7c9      	b.n	2c264 <w_lte_lc_connect+0x4c>
   2c2d0:	20024e1c 	.word	0x20024e1c
   2c2d4:	0002c1a5 	.word	0x0002c1a5
   2c2d8:	0003f8d4 	.word	0x0003f8d4
   2c2dc:	0003f96c 	.word	0x0003f96c
   2c2e0:	0004329d 	.word	0x0004329d
   2c2e4:	000431a4 	.word	0x000431a4
   2c2e8:	000432df 	.word	0x000432df
   2c2ec:	0004319a 	.word	0x0004319a
   2c2f0:	000432ba 	.word	0x000432ba

0002c2f4 <modem_info_parse.isra.0>:
		buf[i] = next_char;
		buf[i + 1] = current_char;
	}
}

static int modem_info_parse(const struct modem_info_data *modem_data,
   2c2f4:	b538      	push	{r3, r4, r5, lr}
   2c2f6:	4605      	mov	r5, r0
			    const char *buf)
{
	int err;
	u32_t param_index;

	err = at_parser_max_params_from_str(buf, NULL, &m_param_list,
   2c2f8:	4a08      	ldr	r2, [pc, #32]	; (2c31c <modem_info_parse.isra.0+0x28>)
static int modem_info_parse(const struct modem_info_data *modem_data,
   2c2fa:	4608      	mov	r0, r1
	err = at_parser_max_params_from_str(buf, NULL, &m_param_list,
   2c2fc:	782b      	ldrb	r3, [r5, #0]
   2c2fe:	2100      	movs	r1, #0
   2c300:	f7ff fd3e 	bl	2bd80 <at_parser_max_params_from_str>
					    modem_data->param_count);

	if (err != 0) {
   2c304:	4604      	mov	r4, r0
   2c306:	b938      	cbnz	r0, 2c318 <modem_info_parse.isra.0+0x24>
		return err;
	}

	param_index = at_params_valid_count_get(&m_param_list);
   2c308:	4804      	ldr	r0, [pc, #16]	; (2c31c <modem_info_parse.isra.0+0x28>)
   2c30a:	f012 f837 	bl	3e37c <at_params_valid_count_get>
	if (param_index > modem_data->param_count) {
   2c30e:	782b      	ldrb	r3, [r5, #0]
		return -EAGAIN;
   2c310:	4298      	cmp	r0, r3
   2c312:	bf88      	it	hi
   2c314:	f06f 040a 	mvnhi.w	r4, #10
	}

	return err;
}
   2c318:	4620      	mov	r0, r4
   2c31a:	bd38      	pop	{r3, r4, r5, pc}
   2c31c:	20024e34 	.word	0x20024e34

0002c320 <modem_info_rsrp_subscribe_handler>:

	return len <= 0 ? -ENOTSUP : len;
}

static void modem_info_rsrp_subscribe_handler(void *context, const char *response)
{
   2c320:	b513      	push	{r0, r1, r4, lr}
   2c322:	460c      	mov	r4, r1
	ARG_UNUSED(context);

	u16_t param_value;
	int err;

	if (!is_cesq_notification(response, strlen(response))) {
   2c324:	4608      	mov	r0, r1
   2c326:	f7f0 ff17 	bl	1d158 <strlen>
	return strstr(buf, AT_CMD_CESQ_RESP) ? true : false;
   2c32a:	491b      	ldr	r1, [pc, #108]	; (2c398 <modem_info_rsrp_subscribe_handler+0x78>)
   2c32c:	4620      	mov	r0, r4
   2c32e:	f012 fc43 	bl	3ebb8 <strstr>
	if (!is_cesq_notification(response, strlen(response))) {
   2c332:	b198      	cbz	r0, 2c35c <modem_info_rsrp_subscribe_handler+0x3c>
		return;
	}

	err = modem_info_parse(modem_data[MODEM_INFO_RSRP],
   2c334:	4621      	mov	r1, r4
   2c336:	4819      	ldr	r0, [pc, #100]	; (2c39c <modem_info_rsrp_subscribe_handler+0x7c>)
   2c338:	f7ff ffdc 	bl	2c2f4 <modem_info_parse.isra.0>
			       response);
	if (err != 0) {
   2c33c:	4602      	mov	r2, r0
   2c33e:	b178      	cbz	r0, 2c360 <modem_info_rsrp_subscribe_handler+0x40>
		LOG_ERR("modem_info_parse failed to parse "
   2c340:	2301      	movs	r3, #1
   2c342:	f04f 0000 	mov.w	r0, #0
   2c346:	4916      	ldr	r1, [pc, #88]	; (2c3a0 <modem_info_rsrp_subscribe_handler+0x80>)
   2c348:	f363 0007 	bfi	r0, r3, #0, #8
   2c34c:	4b15      	ldr	r3, [pc, #84]	; (2c3a4 <modem_info_rsrp_subscribe_handler+0x84>)
   2c34e:	1a5b      	subs	r3, r3, r1
   2c350:	08db      	lsrs	r3, r3, #3
   2c352:	4915      	ldr	r1, [pc, #84]	; (2c3a8 <modem_info_rsrp_subscribe_handler+0x88>)
   2c354:	f363 108f 	bfi	r0, r3, #6, #10

	err = at_params_short_get(&m_param_list,
				  modem_data[MODEM_INFO_RSRP]->param_index,
				  &param_value);
	if (err != 0) {
		LOG_ERR("Failed to obtain RSRP value, %d", err);
   2c358:	f010 fa3f 	bl	3c7da <log_string_sync>
		return;
	}

	modem_info_rsrp_cb(param_value);
}
   2c35c:	b002      	add	sp, #8
   2c35e:	bd10      	pop	{r4, pc}
	err = at_params_short_get(&m_param_list,
   2c360:	f10d 0206 	add.w	r2, sp, #6
   2c364:	2101      	movs	r1, #1
   2c366:	4811      	ldr	r0, [pc, #68]	; (2c3ac <modem_info_rsrp_subscribe_handler+0x8c>)
   2c368:	f011 ffb4 	bl	3e2d4 <at_params_short_get>
	if (err != 0) {
   2c36c:	4602      	mov	r2, r0
   2c36e:	b160      	cbz	r0, 2c38a <modem_info_rsrp_subscribe_handler+0x6a>
		LOG_ERR("Failed to obtain RSRP value, %d", err);
   2c370:	2301      	movs	r3, #1
   2c372:	f04f 0000 	mov.w	r0, #0
   2c376:	490a      	ldr	r1, [pc, #40]	; (2c3a0 <modem_info_rsrp_subscribe_handler+0x80>)
   2c378:	f363 0007 	bfi	r0, r3, #0, #8
   2c37c:	4b09      	ldr	r3, [pc, #36]	; (2c3a4 <modem_info_rsrp_subscribe_handler+0x84>)
   2c37e:	1a5b      	subs	r3, r3, r1
   2c380:	08db      	lsrs	r3, r3, #3
   2c382:	f363 108f 	bfi	r0, r3, #6, #10
   2c386:	490a      	ldr	r1, [pc, #40]	; (2c3b0 <modem_info_rsrp_subscribe_handler+0x90>)
   2c388:	e7e6      	b.n	2c358 <modem_info_rsrp_subscribe_handler+0x38>
	modem_info_rsrp_cb(param_value);
   2c38a:	4b0a      	ldr	r3, [pc, #40]	; (2c3b4 <modem_info_rsrp_subscribe_handler+0x94>)
   2c38c:	f89d 0006 	ldrb.w	r0, [sp, #6]
   2c390:	681b      	ldr	r3, [r3, #0]
   2c392:	4798      	blx	r3
   2c394:	e7e2      	b.n	2c35c <modem_info_rsrp_subscribe_handler+0x3c>
   2c396:	bf00      	nop
   2c398:	0004331c 	.word	0x0004331c
   2c39c:	0004002d 	.word	0x0004002d
   2c3a0:	0003f8d4 	.word	0x0003f8d4
   2c3a4:	0003f984 	.word	0x0003f984
   2c3a8:	00043322 	.word	0x00043322
   2c3ac:	20024e34 	.word	0x20024e34
   2c3b0:	00043359 	.word	0x00043359
   2c3b4:	20024e3c 	.word	0x20024e3c

0002c3b8 <modem_info_rsrp_register>:

int modem_info_rsrp_register(rsrp_cb_t cb)
{
	modem_info_rsrp_cb = cb;
   2c3b8:	4b12      	ldr	r3, [pc, #72]	; (2c404 <modem_info_rsrp_register+0x4c>)
{
   2c3ba:	b510      	push	{r4, lr}

	int rc = at_notif_register_handler(NULL,
   2c3bc:	4912      	ldr	r1, [pc, #72]	; (2c408 <modem_info_rsrp_register+0x50>)
	modem_info_rsrp_cb = cb;
   2c3be:	6018      	str	r0, [r3, #0]
	int rc = at_notif_register_handler(NULL,
   2c3c0:	2000      	movs	r0, #0
   2c3c2:	f7ff f8f7 	bl	2b5b4 <at_notif_register_handler>
		modem_info_rsrp_subscribe_handler);
	if (rc != 0) {
   2c3c6:	4604      	mov	r4, r0
   2c3c8:	b180      	cbz	r0, 2c3ec <modem_info_rsrp_register+0x34>
		LOG_ERR("Can't register handler rc=%d", rc);
   2c3ca:	2301      	movs	r3, #1
   2c3cc:	f04f 0000 	mov.w	r0, #0
   2c3d0:	4a0e      	ldr	r2, [pc, #56]	; (2c40c <modem_info_rsrp_register+0x54>)
   2c3d2:	f363 0007 	bfi	r0, r3, #0, #8
   2c3d6:	4b0e      	ldr	r3, [pc, #56]	; (2c410 <modem_info_rsrp_register+0x58>)
   2c3d8:	490e      	ldr	r1, [pc, #56]	; (2c414 <modem_info_rsrp_register+0x5c>)
   2c3da:	1a9b      	subs	r3, r3, r2
   2c3dc:	08db      	lsrs	r3, r3, #3
   2c3de:	f363 108f 	bfi	r0, r3, #6, #10
   2c3e2:	4622      	mov	r2, r4
   2c3e4:	f010 f9f9 	bl	3c7da <log_string_sync>
	if (at_cmd_write(AT_CMD_CESQ_ON, NULL, 0, NULL) != 0) {
		return -EIO;
	}

	return 0;
}
   2c3e8:	4620      	mov	r0, r4
   2c3ea:	bd10      	pop	{r4, pc}
	if (at_cmd_write(AT_CMD_CESQ_ON, NULL, 0, NULL) != 0) {
   2c3ec:	4603      	mov	r3, r0
   2c3ee:	4602      	mov	r2, r0
   2c3f0:	4601      	mov	r1, r0
   2c3f2:	4809      	ldr	r0, [pc, #36]	; (2c418 <modem_info_rsrp_register+0x60>)
   2c3f4:	f7ff f82c 	bl	2b450 <at_cmd_write>
   2c3f8:	1e04      	subs	r4, r0, #0
		return -EIO;
   2c3fa:	bf18      	it	ne
   2c3fc:	f06f 0404 	mvnne.w	r4, #4
   2c400:	e7f2      	b.n	2c3e8 <modem_info_rsrp_register+0x30>
   2c402:	bf00      	nop
   2c404:	20024e3c 	.word	0x20024e3c
   2c408:	0002c321 	.word	0x0002c321
   2c40c:	0003f8d4 	.word	0x0003f8d4
   2c410:	0003f984 	.word	0x0003f984
   2c414:	0004329d 	.word	0x0004329d
   2c418:	00041200 	.word	0x00041200

0002c41c <modem_info_init>:

int modem_info_init(void)
{
	/* Init at_cmd_parser storage module */
	int err = at_params_list_init(&m_param_list,
   2c41c:	210a      	movs	r1, #10
   2c41e:	4801      	ldr	r0, [pc, #4]	; (2c424 <modem_info_init+0x8>)
   2c420:	f011 bead 	b.w	3e17e <at_params_list_init>
   2c424:	20024e34 	.word	0x20024e34

0002c428 <modem_info_params_init>:

LOG_MODULE_REGISTER(modem_info_params);

int modem_info_params_init(struct modem_param_info *modem)
{
	if (modem == NULL) {
   2c428:	2800      	cmp	r0, #0
   2c42a:	d043      	beq.n	2c4b4 <modem_info_params_init+0x8c>
		return -EINVAL;
	}

	modem->network.current_band.type	= MODEM_INFO_CUR_BAND;
   2c42c:	2301      	movs	r3, #1
   2c42e:	f880 306c 	strb.w	r3, [r0, #108]	; 0x6c
	modem->network.sup_band.type		= MODEM_INFO_SUP_BAND;
   2c432:	2302      	movs	r3, #2
   2c434:	f880 30dc 	strb.w	r3, [r0, #220]	; 0xdc
	modem->network.area_code.type		= MODEM_INFO_AREA_CODE;
   2c438:	2303      	movs	r3, #3
   2c43a:	f880 314c 	strb.w	r3, [r0, #332]	; 0x14c
	modem->network.current_operator.type	= MODEM_INFO_OPERATOR;
   2c43e:	2305      	movs	r3, #5
   2c440:	f880 31bc 	strb.w	r3, [r0, #444]	; 0x1bc
	modem->network.mcc.type			= MODEM_INFO_MCC;
   2c444:	2306      	movs	r3, #6
   2c446:	f880 322c 	strb.w	r3, [r0, #556]	; 0x22c
	modem->network.mnc.type			= MODEM_INFO_MNC;
   2c44a:	2307      	movs	r3, #7
   2c44c:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
	modem->network.cellid_hex.type		= MODEM_INFO_CELLID;
   2c450:	2308      	movs	r3, #8
   2c452:	f880 330c 	strb.w	r3, [r0, #780]	; 0x30c
	modem->network.ip_address.type		= MODEM_INFO_IP_ADDRESS;
   2c456:	2309      	movs	r3, #9
   2c458:	f880 337c 	strb.w	r3, [r0, #892]	; 0x37c
	modem->network.ue_mode.type		= MODEM_INFO_UE_MODE;
   2c45c:	2304      	movs	r3, #4
   2c45e:	f880 33ec 	strb.w	r3, [r0, #1004]	; 0x3ec
	modem->network.lte_mode.type		= MODEM_INFO_LTE_MODE;
   2c462:	230f      	movs	r3, #15
   2c464:	f880 345c 	strb.w	r3, [r0, #1116]	; 0x45c
	modem->network.nbiot_mode.type		= MODEM_INFO_NBIOT_MODE;
   2c468:	2310      	movs	r3, #16
   2c46a:	f880 34cc 	strb.w	r3, [r0, #1228]	; 0x4cc
	modem->network.gps_mode.type		= MODEM_INFO_GPS_MODE;
   2c46e:	2311      	movs	r3, #17
   2c470:	f880 353c 	strb.w	r3, [r0, #1340]	; 0x53c
	modem->network.date_time.type		= MODEM_INFO_DATE_TIME;
   2c474:	2314      	movs	r3, #20
   2c476:	f880 35ac 	strb.w	r3, [r0, #1452]	; 0x5ac

	modem->sim.uicc.type			= MODEM_INFO_UICC;
   2c47a:	230a      	movs	r3, #10
   2c47c:	f880 3634 	strb.w	r3, [r0, #1588]	; 0x634
	modem->sim.iccid.type			= MODEM_INFO_ICCID;
   2c480:	230e      	movs	r3, #14
   2c482:	f880 36a4 	strb.w	r3, [r0, #1700]	; 0x6a4
	modem->sim.imsi.type		        = MODEM_INFO_IMSI;
   2c486:	2312      	movs	r3, #18
   2c488:	f880 3714 	strb.w	r3, [r0, #1812]	; 0x714

	modem->device.modem_fw.type		= MODEM_INFO_FW_VERSION;
   2c48c:	230d      	movs	r3, #13
   2c48e:	f880 3784 	strb.w	r3, [r0, #1924]	; 0x784
	modem->device.battery.type		= MODEM_INFO_BATTERY;
   2c492:	230b      	movs	r3, #11
   2c494:	f880 37f4 	strb.w	r3, [r0, #2036]	; 0x7f4
	modem->device.imei.type			= MODEM_INFO_IMEI;
   2c498:	2313      	movs	r3, #19
   2c49a:	f880 3864 	strb.w	r3, [r0, #2148]	; 0x864
	modem->device.board			= CONFIG_BOARD;
   2c49e:	4b07      	ldr	r3, [pc, #28]	; (2c4bc <modem_info_params_init+0x94>)
   2c4a0:	f8c0 3868 	str.w	r3, [r0, #2152]	; 0x868
	modem->device.app_version		= STRINGIFY(APP_VERSION);
   2c4a4:	4b06      	ldr	r3, [pc, #24]	; (2c4c0 <modem_info_params_init+0x98>)
   2c4a6:	f8c0 386c 	str.w	r3, [r0, #2156]	; 0x86c
	modem->device.app_name			= STRINGIFY(PROJECT_NAME);
   2c4aa:	4b06      	ldr	r3, [pc, #24]	; (2c4c4 <modem_info_params_init+0x9c>)
   2c4ac:	f8c0 3870 	str.w	r3, [r0, #2160]	; 0x870

	return 0;
   2c4b0:	2000      	movs	r0, #0
   2c4b2:	4770      	bx	lr
		return -EINVAL;
   2c4b4:	f06f 0015 	mvn.w	r0, #21
}
   2c4b8:	4770      	bx	lr
   2c4ba:	bf00      	nop
   2c4bc:	000434c2 	.word	0x000434c2
   2c4c0:	000434d3 	.word	0x000434d3
   2c4c4:	000434ec 	.word	0x000434ec

0002c4c8 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
   2c4c8:	b508      	push	{r3, lr}
		arch_syscall_invoke0(K_SYSCALL_LOG_PANIC);
		return;
	}
#endif
	compiler_barrier();
	z_impl_log_panic();
   2c4ca:	f7fa fb09 	bl	26ae0 <z_impl_log_panic>
	ARG_UNUSED(esf);
	ARG_UNUSED(reason);

	LOG_PANIC();

	LOG_ERR("Resetting system");
   2c4ce:	2301      	movs	r3, #1
   2c4d0:	f04f 0000 	mov.w	r0, #0
   2c4d4:	4a06      	ldr	r2, [pc, #24]	; (2c4f0 <k_sys_fatal_error_handler+0x28>)
   2c4d6:	f363 0007 	bfi	r0, r3, #0, #8
   2c4da:	4b06      	ldr	r3, [pc, #24]	; (2c4f4 <k_sys_fatal_error_handler+0x2c>)
   2c4dc:	4906      	ldr	r1, [pc, #24]	; (2c4f8 <k_sys_fatal_error_handler+0x30>)
   2c4de:	1a9b      	subs	r3, r3, r2
   2c4e0:	08db      	lsrs	r3, r3, #3
   2c4e2:	f363 108f 	bfi	r0, r3, #6, #10
   2c4e6:	f010 f978 	bl	3c7da <log_string_sync>
	sys_arch_reboot(0);
   2c4ea:	2000      	movs	r0, #0
   2c4ec:	f7fc faa4 	bl	28a38 <sys_arch_reboot>

	CODE_UNREACHABLE;
   2c4f0:	0003f8d4 	.word	0x0003f8d4
   2c4f4:	0003f92c 	.word	0x0003f92c
   2c4f8:	0004350b 	.word	0x0004350b

0002c4fc <check_ext_api_requests>:
	}
};
#endif

static int check_ext_api_requests(struct device *dev)
{
   2c4fc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	(void)dev;

	const struct fw_info_ext_api_request *ext_api_req =
			skip_ext_apis(&m_firmware_info);

	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   2c500:	2500      	movs	r5, #0
			skip_ext_apis(&m_firmware_info);
   2c502:	4c21      	ldr	r4, [pc, #132]	; (2c588 <check_ext_api_requests+0x8c>)
 */
static inline const struct fw_info_ext_api *fw_info_ext_api_check(
							u32_t ext_api_addr)
{
	const struct fw_info_ext_api *ext_api;
	const u32_t ext_api_magic[] = {EXT_API_MAGIC};
   2c504:	4e21      	ldr	r6, [pc, #132]	; (2c58c <check_ext_api_requests+0x90>)
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   2c506:	f854 8c04 	ldr.w	r8, [r4, #-4]
			/* EXT_API hard requirement not met. */
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
			k_panic();
		} else {
			/* EXT_API soft requirement not met. */
			printk("WARNING: Optional EXT_API request not "
   2c50a:	f8df 9088 	ldr.w	r9, [pc, #136]	; 2c594 <check_ext_api_requests+0x98>
{
   2c50e:	b085      	sub	sp, #20
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   2c510:	45a8      	cmp	r8, r5
   2c512:	d803      	bhi.n	2c51c <check_ext_api_requests+0x20>
		}
		ADVANCE_EXT_API_REQ(ext_api_req);
	}

	return 0;
}
   2c514:	2000      	movs	r0, #0
   2c516:	b005      	add	sp, #20
   2c518:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (fw_info_ext_api_check((u32_t)*(ext_api_req->ext_api))
   2c51c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2c51e:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
   2c522:	681f      	ldr	r7, [r3, #0]
   2c524:	ab01      	add	r3, sp, #4
   2c526:	e883 0007 	stmia.w	r3, {r0, r1, r2}

	ext_api = (const struct fw_info_ext_api *)(ext_api_addr);
	if (memcmp(ext_api->magic, ext_api_magic, CONFIG_FW_INFO_MAGIC_LEN)
   2c52a:	220c      	movs	r2, #12
   2c52c:	4619      	mov	r1, r3
   2c52e:	4638      	mov	r0, r7
   2c530:	f012 f97e 	bl	3e830 <memcmp>
   2c534:	b990      	cbnz	r0, 2c55c <check_ext_api_requests+0x60>
   2c536:	b18f      	cbz	r7, 2c55c <check_ext_api_requests+0x60>
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
   2c538:	6a63      	ldr	r3, [r4, #36]	; 0x24
	const u32_t req_id = ext_api_req->request.ext_api_id;
   2c53a:	6921      	ldr	r1, [r4, #16]
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
   2c53c:	681b      	ldr	r3, [r3, #0]
	return ((ext_api->ext_api_id == req_id)
   2c53e:	691a      	ldr	r2, [r3, #16]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
   2c540:	4291      	cmp	r1, r2
   2c542:	d10b      	bne.n	2c55c <check_ext_api_requests+0x60>
		&&  (ext_api->ext_api_version >= req_min_version)
   2c544:	699a      	ldr	r2, [r3, #24]
	const u32_t req_min_version = ext_api_req->request.ext_api_version;
   2c546:	69a1      	ldr	r1, [r4, #24]
		&&  (ext_api->ext_api_version >= req_min_version)
   2c548:	4291      	cmp	r1, r2
   2c54a:	d807      	bhi.n	2c55c <check_ext_api_requests+0x60>
	const u32_t req_max_version = ext_api_req->ext_api_max_version;
   2c54c:	69e1      	ldr	r1, [r4, #28]
		&&  (ext_api->ext_api_version <  req_max_version)
   2c54e:	4291      	cmp	r1, r2
   2c550:	d904      	bls.n	2c55c <check_ext_api_requests+0x60>
	const u32_t req_flags = ext_api_req->request.ext_api_flags;
   2c552:	6962      	ldr	r2, [r4, #20]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
   2c554:	695b      	ldr	r3, [r3, #20]
   2c556:	ea32 0303 	bics.w	r3, r2, r3
   2c55a:	d00a      	beq.n	2c572 <check_ext_api_requests+0x76>
		} else if (ext_api_req->required) {
   2c55c:	6a27      	ldr	r7, [r4, #32]
   2c55e:	b167      	cbz	r7, 2c57a <check_ext_api_requests+0x7e>
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
   2c560:	480b      	ldr	r0, [pc, #44]	; (2c590 <check_ext_api_requests+0x94>)
   2c562:	f010 f8e3 	bl	3c72c <printk>
			k_panic();
   2c566:	4040      	eors	r0, r0
   2c568:	f380 8811 	msr	BASEPRI, r0
   2c56c:	f04f 0004 	mov.w	r0, #4
   2c570:	df02      	svc	2
		ADVANCE_EXT_API_REQ(ext_api_req);
   2c572:	68e3      	ldr	r3, [r4, #12]
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   2c574:	3501      	adds	r5, #1
		ADVANCE_EXT_API_REQ(ext_api_req);
   2c576:	441c      	add	r4, r3
   2c578:	e7ca      	b.n	2c510 <check_ext_api_requests+0x14>
			printk("WARNING: Optional EXT_API request not "
   2c57a:	4648      	mov	r0, r9
   2c57c:	f010 f8d6 	bl	3c72c <printk>
			*ext_api_req->ext_api = NULL;
   2c580:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2c582:	601f      	str	r7, [r3, #0]
   2c584:	e7f5      	b.n	2c572 <check_ext_api_requests+0x76>
   2c586:	bf00      	nop
   2c588:	0001c43c 	.word	0x0001c43c
   2c58c:	0003fa58 	.word	0x0003fa58
   2c590:	00043528 	.word	0x00043528
   2c594:	00043551 	.word	0x00043551

0002c598 <rpc_logobj_client_evt_handler>:
   2c598:	b120      	cbz	r0, 2c5a4 <rpc_logobj_client_evt_handler+0xc>
   2c59a:	f850 1b08 	ldr.w	r1, [r0], #8
   2c59e:	0c09      	lsrs	r1, r1, #16
   2c5a0:	f000 b852 	b.w	2c648 <logobj_event_handler>
   2c5a4:	4770      	bx	lr
   2c5a6:	bf00      	nop

0002c5a8 <rpc_logobj_client_init>:
   2c5a8:	4801      	ldr	r0, [pc, #4]	; (2c5b0 <rpc_logobj_client_init+0x8>)
   2c5aa:	f006 bbd1 	b.w	32d50 <rpc_client_register>
   2c5ae:	bf00      	nop
   2c5b0:	00040030 	.word	0x00040030

0002c5b4 <rpc_logobj_client_request_alloc>:
   2c5b4:	2300      	movs	r3, #0
   2c5b6:	b510      	push	{r4, lr}
   2c5b8:	b082      	sub	sp, #8
   2c5ba:	9301      	str	r3, [sp, #4]
   2c5bc:	b961      	cbnz	r1, 2c5d8 <rpc_logobj_client_request_alloc+0x24>
   2c5be:	b170      	cbz	r0, 2c5de <rpc_logobj_client_request_alloc+0x2a>
   2c5c0:	4604      	mov	r4, r0
   2c5c2:	aa01      	add	r2, sp, #4
   2c5c4:	2009      	movs	r0, #9
   2c5c6:	f006 fdfb 	bl	331c0 <rpc_message_alloc>
   2c5ca:	b918      	cbnz	r0, 2c5d4 <rpc_logobj_client_request_alloc+0x20>
   2c5cc:	9b01      	ldr	r3, [sp, #4]
   2c5ce:	b10b      	cbz	r3, 2c5d4 <rpc_logobj_client_request_alloc+0x20>
   2c5d0:	3308      	adds	r3, #8
   2c5d2:	6023      	str	r3, [r4, #0]
   2c5d4:	b002      	add	sp, #8
   2c5d6:	bd10      	pop	{r4, pc}
   2c5d8:	200f      	movs	r0, #15
   2c5da:	b002      	add	sp, #8
   2c5dc:	bd10      	pop	{r4, pc}
   2c5de:	200e      	movs	r0, #14
   2c5e0:	b002      	add	sp, #8
   2c5e2:	bd10      	pop	{r4, pc}

0002c5e4 <rpc_logobj_client_request_send>:
   2c5e4:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   2c5e8:	f5b3 4fe0 	cmp.w	r3, #28672	; 0x7000
   2c5ec:	d10b      	bne.n	2c606 <rpc_logobj_client_request_send+0x22>
   2c5ee:	b160      	cbz	r0, 2c60a <rpc_logobj_client_request_send+0x26>
   2c5f0:	4603      	mov	r3, r0
   2c5f2:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   2c5f6:	2009      	movs	r0, #9
   2c5f8:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   2c5fc:	f843 1d08 	str.w	r1, [r3, #-8]!
   2c600:	4619      	mov	r1, r3
   2c602:	f006 bdc5 	b.w	33190 <rpc_message_send>
   2c606:	200f      	movs	r0, #15
   2c608:	4770      	bx	lr
   2c60a:	200e      	movs	r0, #14
   2c60c:	4770      	bx	lr
   2c60e:	bf00      	nop

0002c610 <rpc_logobj_client_message_free>:
   2c610:	b120      	cbz	r0, 2c61c <rpc_logobj_client_message_free+0xc>
   2c612:	f1a0 0108 	sub.w	r1, r0, #8
   2c616:	2009      	movs	r0, #9
   2c618:	f006 be04 	b.w	33224 <rpc_message_free>
   2c61c:	200e      	movs	r0, #14
   2c61e:	4770      	bx	lr

0002c620 <rpc_logobj_client_data_free>:
   2c620:	b118      	cbz	r0, 2c62a <rpc_logobj_client_data_free+0xa>
   2c622:	4601      	mov	r1, r0
   2c624:	2009      	movs	r0, #9
   2c626:	f006 bf0f 	b.w	33448 <rpc_message_data_free>
   2c62a:	200e      	movs	r0, #14
   2c62c:	4770      	bx	lr
   2c62e:	bf00      	nop

0002c630 <packet_free_cb>:
   2c630:	b510      	push	{r4, lr}
   2c632:	4604      	mov	r4, r0
   2c634:	6800      	ldr	r0, [r0, #0]
   2c636:	f7ff fff3 	bl	2c620 <rpc_logobj_client_data_free>
   2c63a:	68a0      	ldr	r0, [r4, #8]
   2c63c:	b118      	cbz	r0, 2c646 <packet_free_cb+0x16>
   2c63e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2c642:	f001 b935 	b.w	2d8b0 <nrf_free>
   2c646:	bd10      	pop	{r4, pc}

0002c648 <logobj_event_handler>:
   2c648:	b530      	push	{r4, r5, lr}
   2c64a:	4b3b      	ldr	r3, [pc, #236]	; (2c738 <logobj_event_handler+0xf0>)
   2c64c:	b085      	sub	sp, #20
   2c64e:	681d      	ldr	r5, [r3, #0]
   2c650:	2d00      	cmp	r5, #0
   2c652:	d04c      	beq.n	2c6ee <logobj_event_handler+0xa6>
   2c654:	f248 0302 	movw	r3, #32770	; 0x8002
   2c658:	4299      	cmp	r1, r3
   2c65a:	d053      	beq.n	2c704 <logobj_event_handler+0xbc>
   2c65c:	d91c      	bls.n	2c698 <logobj_event_handler+0x50>
   2c65e:	f248 0303 	movw	r3, #32771	; 0x8003
   2c662:	4299      	cmp	r1, r3
   2c664:	d05a      	beq.n	2c71c <logobj_event_handler+0xd4>
   2c666:	f249 0301 	movw	r3, #36865	; 0x9001
   2c66a:	4299      	cmp	r1, r3
   2c66c:	d147      	bne.n	2c6fe <logobj_event_handler+0xb6>
   2c66e:	2400      	movs	r4, #0
   2c670:	6843      	ldr	r3, [r0, #4]
   2c672:	6802      	ldr	r2, [r0, #0]
   2c674:	e9cd 4402 	strd	r4, r4, [sp, #8]
   2c678:	e9cd 2300 	strd	r2, r3, [sp]
   2c67c:	69e8      	ldr	r0, [r5, #28]
   2c67e:	4669      	mov	r1, sp
   2c680:	6803      	ldr	r3, [r0, #0]
   2c682:	685b      	ldr	r3, [r3, #4]
   2c684:	4798      	blx	r3
   2c686:	3001      	adds	r0, #1
   2c688:	d04e      	beq.n	2c728 <logobj_event_handler+0xe0>
   2c68a:	4620      	mov	r0, r4
   2c68c:	682b      	ldr	r3, [r5, #0]
   2c68e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   2c692:	602b      	str	r3, [r5, #0]
   2c694:	b005      	add	sp, #20
   2c696:	bd30      	pop	{r4, r5, pc}
   2c698:	f248 0301 	movw	r3, #32769	; 0x8001
   2c69c:	4299      	cmp	r1, r3
   2c69e:	d12e      	bne.n	2c6fe <logobj_event_handler+0xb6>
   2c6a0:	68c3      	ldr	r3, [r0, #12]
   2c6a2:	2b00      	cmp	r3, #0
   2c6a4:	d135      	bne.n	2c712 <logobj_event_handler+0xca>
   2c6a6:	6828      	ldr	r0, [r5, #0]
   2c6a8:	f410 0080 	ands.w	r0, r0, #4194304	; 0x400000
   2c6ac:	d03e      	beq.n	2c72c <logobj_event_handler+0xe4>
   2c6ae:	682b      	ldr	r3, [r5, #0]
   2c6b0:	b29b      	uxth	r3, r3
   2c6b2:	2b01      	cmp	r3, #1
   2c6b4:	d105      	bne.n	2c6c2 <logobj_event_handler+0x7a>
   2c6b6:	682b      	ldr	r3, [r5, #0]
   2c6b8:	0c1b      	lsrs	r3, r3, #16
   2c6ba:	041b      	lsls	r3, r3, #16
   2c6bc:	f043 0302 	orr.w	r3, r3, #2
   2c6c0:	602b      	str	r3, [r5, #0]
   2c6c2:	4b1e      	ldr	r3, [pc, #120]	; (2c73c <logobj_event_handler+0xf4>)
   2c6c4:	781a      	ldrb	r2, [r3, #0]
   2c6c6:	f002 01ff 	and.w	r1, r2, #255	; 0xff
   2c6ca:	2a00      	cmp	r2, #0
   2c6cc:	d031      	beq.n	2c732 <logobj_event_handler+0xea>
   2c6ce:	4a1c      	ldr	r2, [pc, #112]	; (2c740 <logobj_event_handler+0xf8>)
   2c6d0:	7811      	ldrb	r1, [r2, #0]
   2c6d2:	b909      	cbnz	r1, 2c6d8 <logobj_event_handler+0x90>
   2c6d4:	2101      	movs	r1, #1
   2c6d6:	7011      	strb	r1, [r2, #0]
   2c6d8:	2000      	movs	r0, #0
   2c6da:	7018      	strb	r0, [r3, #0]
   2c6dc:	682b      	ldr	r3, [r5, #0]
   2c6de:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   2c6e2:	602b      	str	r3, [r5, #0]
   2c6e4:	682b      	ldr	r3, [r5, #0]
   2c6e6:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   2c6ea:	602b      	str	r3, [r5, #0]
   2c6ec:	e7d2      	b.n	2c694 <logobj_event_handler+0x4c>
   2c6ee:	6800      	ldr	r0, [r0, #0]
   2c6f0:	2800      	cmp	r0, #0
   2c6f2:	d0cf      	beq.n	2c694 <logobj_event_handler+0x4c>
   2c6f4:	f7ff ff94 	bl	2c620 <rpc_logobj_client_data_free>
   2c6f8:	4628      	mov	r0, r5
   2c6fa:	b005      	add	sp, #20
   2c6fc:	bd30      	pop	{r4, r5, pc}
   2c6fe:	2000      	movs	r0, #0
   2c700:	b005      	add	sp, #20
   2c702:	bd30      	pop	{r4, r5, pc}
   2c704:	682b      	ldr	r3, [r5, #0]
   2c706:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
   2c70a:	d00b      	beq.n	2c724 <logobj_event_handler+0xdc>
   2c70c:	68c0      	ldr	r0, [r0, #12]
   2c70e:	2800      	cmp	r0, #0
   2c710:	d0e4      	beq.n	2c6dc <logobj_event_handler+0x94>
   2c712:	230e      	movs	r3, #14
   2c714:	2000      	movs	r0, #0
   2c716:	606b      	str	r3, [r5, #4]
   2c718:	b005      	add	sp, #20
   2c71a:	bd30      	pop	{r4, r5, pc}
   2c71c:	68c3      	ldr	r3, [r0, #12]
   2c71e:	2b01      	cmp	r3, #1
   2c720:	d1a5      	bne.n	2c66e <logobj_event_handler+0x26>
   2c722:	e7f6      	b.n	2c712 <logobj_event_handler+0xca>
   2c724:	4618      	mov	r0, r3
   2c726:	e7b5      	b.n	2c694 <logobj_event_handler+0x4c>
   2c728:	2002      	movs	r0, #2
   2c72a:	e7b3      	b.n	2c694 <logobj_event_handler+0x4c>
   2c72c:	230e      	movs	r3, #14
   2c72e:	606b      	str	r3, [r5, #4]
   2c730:	e7b0      	b.n	2c694 <logobj_event_handler+0x4c>
   2c732:	4a03      	ldr	r2, [pc, #12]	; (2c740 <logobj_event_handler+0xf8>)
   2c734:	7011      	strb	r1, [r2, #0]
   2c736:	e7cf      	b.n	2c6d8 <logobj_event_handler+0x90>
   2c738:	20024e44 	.word	0x20024e44
   2c73c:	2002d7eb 	.word	0x2002d7eb
   2c740:	2002d7ec 	.word	0x2002d7ec

0002c744 <logobj_interface_init>:
   2c744:	2300      	movs	r3, #0
   2c746:	b510      	push	{r4, lr}
   2c748:	4907      	ldr	r1, [pc, #28]	; (2c768 <logobj_interface_init+0x24>)
   2c74a:	4a08      	ldr	r2, [pc, #32]	; (2c76c <logobj_interface_init+0x28>)
   2c74c:	4c08      	ldr	r4, [pc, #32]	; (2c770 <logobj_interface_init+0x2c>)
   2c74e:	4809      	ldr	r0, [pc, #36]	; (2c774 <logobj_interface_init+0x30>)
   2c750:	7023      	strb	r3, [r4, #0]
   2c752:	6003      	str	r3, [r0, #0]
   2c754:	700b      	strb	r3, [r1, #0]
   2c756:	6013      	str	r3, [r2, #0]
   2c758:	f7ff ff26 	bl	2c5a8 <rpc_logobj_client_init>
   2c75c:	3000      	adds	r0, #0
   2c75e:	bf18      	it	ne
   2c760:	2001      	movne	r0, #1
   2c762:	4240      	negs	r0, r0
   2c764:	bd10      	pop	{r4, pc}
   2c766:	bf00      	nop
   2c768:	2002d7eb 	.word	0x2002d7eb
   2c76c:	20024e40 	.word	0x20024e40
   2c770:	2002d7ec 	.word	0x2002d7ec
   2c774:	20024e44 	.word	0x20024e44

0002c778 <logobj_interface_open>:
   2c778:	2300      	movs	r3, #0
   2c77a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2c77e:	2866      	cmp	r0, #102	; 0x66
   2c780:	b082      	sub	sp, #8
   2c782:	9300      	str	r3, [sp, #0]
   2c784:	d172      	bne.n	2c86c <logobj_interface_open+0xf4>
   2c786:	2902      	cmp	r1, #2
   2c788:	4689      	mov	r9, r1
   2c78a:	d16f      	bne.n	2c86c <logobj_interface_open+0xf4>
   2c78c:	f240 2305 	movw	r3, #517	; 0x205
   2c790:	429a      	cmp	r2, r3
   2c792:	4692      	mov	sl, r2
   2c794:	d16a      	bne.n	2c86c <logobj_interface_open+0xf4>
   2c796:	4f48      	ldr	r7, [pc, #288]	; (2c8b8 <logobj_interface_open+0x140>)
   2c798:	683d      	ldr	r5, [r7, #0]
   2c79a:	2d00      	cmp	r5, #0
   2c79c:	d17c      	bne.n	2c898 <logobj_interface_open+0x120>
   2c79e:	4680      	mov	r8, r0
   2c7a0:	4a46      	ldr	r2, [pc, #280]	; (2c8bc <logobj_interface_open+0x144>)
   2c7a2:	4668      	mov	r0, sp
   2c7a4:	f006 f872 	bl	3288c <interface_socket_allocate>
   2c7a8:	9b00      	ldr	r3, [sp, #0]
   2c7aa:	4606      	mov	r6, r0
   2c7ac:	2b00      	cmp	r3, #0
   2c7ae:	d07d      	beq.n	2c8ac <logobj_interface_open+0x134>
   2c7b0:	4629      	mov	r1, r5
   2c7b2:	2204      	movs	r2, #4
   2c7b4:	4842      	ldr	r0, [pc, #264]	; (2c8c0 <logobj_interface_open+0x148>)
   2c7b6:	603b      	str	r3, [r7, #0]
   2c7b8:	f012 f868 	bl	3e88c <memset>
   2c7bc:	9c00      	ldr	r4, [sp, #0]
   2c7be:	4629      	mov	r1, r5
   2c7c0:	e9c4 8903 	strd	r8, r9, [r4, #12]
   2c7c4:	f8c4 a014 	str.w	sl, [r4, #20]
   2c7c8:	a801      	add	r0, sp, #4
   2c7ca:	f7ff fef3 	bl	2c5b4 <rpc_logobj_client_request_alloc>
   2c7ce:	2800      	cmp	r0, #0
   2c7d0:	d13c      	bne.n	2c84c <logobj_interface_open+0xd4>
   2c7d2:	2201      	movs	r2, #1
   2c7d4:	2104      	movs	r1, #4
   2c7d6:	9b01      	ldr	r3, [sp, #4]
   2c7d8:	4d3a      	ldr	r5, [pc, #232]	; (2c8c4 <logobj_interface_open+0x14c>)
   2c7da:	7358      	strb	r0, [r3, #13]
   2c7dc:	7398      	strb	r0, [r3, #14]
   2c7de:	73d8      	strb	r0, [r3, #15]
   2c7e0:	7258      	strb	r0, [r3, #9]
   2c7e2:	7298      	strb	r0, [r3, #10]
   2c7e4:	72d8      	strb	r0, [r3, #11]
   2c7e6:	7219      	strb	r1, [r3, #8]
   2c7e8:	702a      	strb	r2, [r5, #0]
   2c7ea:	731a      	strb	r2, [r3, #12]
   2c7ec:	6822      	ldr	r2, [r4, #0]
   2c7ee:	4618      	mov	r0, r3
   2c7f0:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
   2c7f4:	6022      	str	r2, [r4, #0]
   2c7f6:	f247 0101 	movw	r1, #28673	; 0x7001
   2c7fa:	f7ff fef3 	bl	2c5e4 <rpc_logobj_client_request_send>
   2c7fe:	bb38      	cbnz	r0, 2c850 <logobj_interface_open+0xd8>
   2c800:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   2c804:	f04f 33ff 	mov.w	r3, #4294967295
   2c808:	4611      	mov	r1, r2
   2c80a:	4630      	mov	r0, r6
   2c80c:	f006 f8f0 	bl	329f0 <interface_socket_wait>
   2c810:	4604      	mov	r4, r0
   2c812:	b310      	cbz	r0, 2c85a <logobj_interface_open+0xe2>
   2c814:	9a00      	ldr	r2, [sp, #0]
   2c816:	2e00      	cmp	r6, #0
   2c818:	6813      	ldr	r3, [r2, #0]
   2c81a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2c81e:	6013      	str	r3, [r2, #0]
   2c820:	9a00      	ldr	r2, [sp, #0]
   2c822:	6813      	ldr	r3, [r2, #0]
   2c824:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   2c828:	6013      	str	r3, [r2, #0]
   2c82a:	9a00      	ldr	r2, [sp, #0]
   2c82c:	6813      	ldr	r3, [r2, #0]
   2c82e:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   2c832:	6013      	str	r3, [r2, #0]
   2c834:	da36      	bge.n	2c8a4 <logobj_interface_open+0x12c>
   2c836:	2300      	movs	r3, #0
   2c838:	4620      	mov	r0, r4
   2c83a:	603b      	str	r3, [r7, #0]
   2c83c:	f04f 36ff 	mov.w	r6, #4294967295
   2c840:	f7fe f9c0 	bl	2abc4 <bsd_os_errno_set>
   2c844:	4630      	mov	r0, r6
   2c846:	b002      	add	sp, #8
   2c848:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2c84c:	240c      	movs	r4, #12
   2c84e:	e7e1      	b.n	2c814 <logobj_interface_open+0x9c>
   2c850:	9801      	ldr	r0, [sp, #4]
   2c852:	f7ff fedd 	bl	2c610 <rpc_logobj_client_message_free>
   2c856:	2405      	movs	r4, #5
   2c858:	e7dc      	b.n	2c814 <logobj_interface_open+0x9c>
   2c85a:	4630      	mov	r0, r6
   2c85c:	f006 f93c 	bl	32ad8 <interface_socket_from_handle_get>
   2c860:	b150      	cbz	r0, 2c878 <logobj_interface_open+0x100>
   2c862:	6844      	ldr	r4, [r0, #4]
   2c864:	b144      	cbz	r4, 2c878 <logobj_interface_open+0x100>
   2c866:	2300      	movs	r3, #0
   2c868:	6043      	str	r3, [r0, #4]
   2c86a:	e7d3      	b.n	2c814 <logobj_interface_open+0x9c>
   2c86c:	2016      	movs	r0, #22
   2c86e:	f7fe f9a9 	bl	2abc4 <bsd_os_errno_set>
   2c872:	f04f 36ff 	mov.w	r6, #4294967295
   2c876:	e7e5      	b.n	2c844 <logobj_interface_open+0xcc>
   2c878:	9a00      	ldr	r2, [sp, #0]
   2c87a:	6813      	ldr	r3, [r2, #0]
   2c87c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2c880:	6013      	str	r3, [r2, #0]
   2c882:	9a00      	ldr	r2, [sp, #0]
   2c884:	6813      	ldr	r3, [r2, #0]
   2c886:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   2c88a:	6013      	str	r3, [r2, #0]
   2c88c:	9a00      	ldr	r2, [sp, #0]
   2c88e:	6813      	ldr	r3, [r2, #0]
   2c890:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   2c894:	6013      	str	r3, [r2, #0]
   2c896:	e7d5      	b.n	2c844 <logobj_interface_open+0xcc>
   2c898:	2001      	movs	r0, #1
   2c89a:	f7fe f993 	bl	2abc4 <bsd_os_errno_set>
   2c89e:	f04f 36ff 	mov.w	r6, #4294967295
   2c8a2:	e7cf      	b.n	2c844 <logobj_interface_open+0xcc>
   2c8a4:	4630      	mov	r0, r6
   2c8a6:	f006 f855 	bl	32954 <interface_socket_free>
   2c8aa:	e7c4      	b.n	2c836 <logobj_interface_open+0xbe>
   2c8ac:	2018      	movs	r0, #24
   2c8ae:	f7fe f989 	bl	2abc4 <bsd_os_errno_set>
   2c8b2:	f04f 36ff 	mov.w	r6, #4294967295
   2c8b6:	e7c5      	b.n	2c844 <logobj_interface_open+0xcc>
   2c8b8:	20024e44 	.word	0x20024e44
   2c8bc:	0002c631 	.word	0x0002c631
   2c8c0:	20024e40 	.word	0x20024e40
   2c8c4:	2002d7eb 	.word	0x2002d7eb

0002c8c8 <logobj_interface_read>:
   2c8c8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2c8cc:	b085      	sub	sp, #20
   2c8ce:	2900      	cmp	r1, #0
   2c8d0:	d068      	beq.n	2c9a4 <logobj_interface_read+0xdc>
   2c8d2:	2a00      	cmp	r2, #0
   2c8d4:	4617      	mov	r7, r2
   2c8d6:	dd65      	ble.n	2c9a4 <logobj_interface_read+0xdc>
   2c8d8:	461d      	mov	r5, r3
   2c8da:	4680      	mov	r8, r0
   2c8dc:	460e      	mov	r6, r1
   2c8de:	f006 f8fb 	bl	32ad8 <interface_socket_from_handle_get>
   2c8e2:	4604      	mov	r4, r0
   2c8e4:	2800      	cmp	r0, #0
   2c8e6:	d063      	beq.n	2c9b0 <logobj_interface_read+0xe8>
   2c8e8:	bb4d      	cbnz	r5, 2c93e <logobj_interface_read+0x76>
   2c8ea:	69e0      	ldr	r0, [r4, #28]
   2c8ec:	07aa      	lsls	r2, r5, #30
   2c8ee:	6803      	ldr	r3, [r0, #0]
   2c8f0:	68db      	ldr	r3, [r3, #12]
   2c8f2:	d52d      	bpl.n	2c950 <logobj_interface_read+0x88>
   2c8f4:	4798      	blx	r3
   2c8f6:	3001      	adds	r0, #1
   2c8f8:	d044      	beq.n	2c984 <logobj_interface_read+0xbc>
   2c8fa:	6823      	ldr	r3, [r4, #0]
   2c8fc:	69e0      	ldr	r0, [r4, #28]
   2c8fe:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
   2c902:	d041      	beq.n	2c988 <logobj_interface_read+0xc0>
   2c904:	2100      	movs	r1, #0
   2c906:	6823      	ldr	r3, [r4, #0]
   2c908:	462a      	mov	r2, r5
   2c90a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   2c90e:	6023      	str	r3, [r4, #0]
   2c910:	e9cd 1102 	strd	r1, r1, [sp, #8]
   2c914:	e9cd 6700 	strd	r6, r7, [sp]
   2c918:	6803      	ldr	r3, [r0, #0]
   2c91a:	4669      	mov	r1, sp
   2c91c:	689b      	ldr	r3, [r3, #8]
   2c91e:	4798      	blx	r3
   2c920:	4605      	mov	r5, r0
   2c922:	69e0      	ldr	r0, [r4, #28]
   2c924:	6803      	ldr	r3, [r0, #0]
   2c926:	68db      	ldr	r3, [r3, #12]
   2c928:	4798      	blx	r3
   2c92a:	3001      	adds	r0, #1
   2c92c:	d003      	beq.n	2c936 <logobj_interface_read+0x6e>
   2c92e:	6823      	ldr	r3, [r4, #0]
   2c930:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   2c934:	6023      	str	r3, [r4, #0]
   2c936:	4628      	mov	r0, r5
   2c938:	b005      	add	sp, #20
   2c93a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2c93e:	f015 0f0a 	tst.w	r5, #10
   2c942:	d1d2      	bne.n	2c8ea <logobj_interface_read+0x22>
   2c944:	202d      	movs	r0, #45	; 0x2d
   2c946:	f7fe f93d 	bl	2abc4 <bsd_os_errno_set>
   2c94a:	f04f 35ff 	mov.w	r5, #4294967295
   2c94e:	e7f2      	b.n	2c936 <logobj_interface_read+0x6e>
   2c950:	6822      	ldr	r2, [r4, #0]
   2c952:	f012 5980 	ands.w	r9, r2, #268435456	; 0x10000000
   2c956:	d1cd      	bne.n	2c8f4 <logobj_interface_read+0x2c>
   2c958:	4798      	blx	r3
   2c95a:	1c43      	adds	r3, r0, #1
   2c95c:	d1cd      	bne.n	2c8fa <logobj_interface_read+0x32>
   2c95e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   2c962:	6a23      	ldr	r3, [r4, #32]
   2c964:	4611      	mov	r1, r2
   2c966:	2b00      	cmp	r3, #0
   2c968:	bf08      	it	eq
   2c96a:	4603      	moveq	r3, r0
   2c96c:	4640      	mov	r0, r8
   2c96e:	f006 f83f 	bl	329f0 <interface_socket_wait>
   2c972:	b158      	cbz	r0, 2c98c <logobj_interface_read+0xc4>
   2c974:	f04f 35ff 	mov.w	r5, #4294967295
   2c978:	f7fe f924 	bl	2abc4 <bsd_os_errno_set>
   2c97c:	4628      	mov	r0, r5
   2c97e:	b005      	add	sp, #20
   2c980:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2c984:	2023      	movs	r0, #35	; 0x23
   2c986:	e7f5      	b.n	2c974 <logobj_interface_read+0xac>
   2c988:	461d      	mov	r5, r3
   2c98a:	e7cb      	b.n	2c924 <logobj_interface_read+0x5c>
   2c98c:	4640      	mov	r0, r8
   2c98e:	f006 f8a3 	bl	32ad8 <interface_socket_from_handle_get>
   2c992:	4603      	mov	r3, r0
   2c994:	2800      	cmp	r0, #0
   2c996:	d0b0      	beq.n	2c8fa <logobj_interface_read+0x32>
   2c998:	6840      	ldr	r0, [r0, #4]
   2c99a:	2800      	cmp	r0, #0
   2c99c:	d0ad      	beq.n	2c8fa <logobj_interface_read+0x32>
   2c99e:	f8c3 9004 	str.w	r9, [r3, #4]
   2c9a2:	e7e7      	b.n	2c974 <logobj_interface_read+0xac>
   2c9a4:	2016      	movs	r0, #22
   2c9a6:	f7fe f90d 	bl	2abc4 <bsd_os_errno_set>
   2c9aa:	f04f 35ff 	mov.w	r5, #4294967295
   2c9ae:	e7c2      	b.n	2c936 <logobj_interface_read+0x6e>
   2c9b0:	2009      	movs	r0, #9
   2c9b2:	f7fe f907 	bl	2abc4 <bsd_os_errno_set>
   2c9b6:	f04f 35ff 	mov.w	r5, #4294967295
   2c9ba:	e7bc      	b.n	2c936 <logobj_interface_read+0x6e>

0002c9bc <logobj_interface_write>:
   2c9bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2c9c0:	b082      	sub	sp, #8
   2c9c2:	2900      	cmp	r1, #0
   2c9c4:	d05e      	beq.n	2ca84 <logobj_interface_write+0xc8>
   2c9c6:	2a04      	cmp	r2, #4
   2c9c8:	d15c      	bne.n	2ca84 <logobj_interface_write+0xc8>
   2c9ca:	461e      	mov	r6, r3
   2c9cc:	4607      	mov	r7, r0
   2c9ce:	460d      	mov	r5, r1
   2c9d0:	f006 f882 	bl	32ad8 <interface_socket_from_handle_get>
   2c9d4:	4604      	mov	r4, r0
   2c9d6:	2800      	cmp	r0, #0
   2c9d8:	d070      	beq.n	2cabc <logobj_interface_write+0x100>
   2c9da:	b1e6      	cbz	r6, 2ca16 <logobj_interface_write+0x5a>
   2c9dc:	07b0      	lsls	r0, r6, #30
   2c9de:	d567      	bpl.n	2cab0 <logobj_interface_write+0xf4>
   2c9e0:	6823      	ldr	r3, [r4, #0]
   2c9e2:	039b      	lsls	r3, r3, #14
   2c9e4:	d560      	bpl.n	2caa8 <logobj_interface_write+0xec>
   2c9e6:	2600      	movs	r6, #0
   2c9e8:	6823      	ldr	r3, [r4, #0]
   2c9ea:	2100      	movs	r1, #0
   2c9ec:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   2c9f0:	6023      	str	r3, [r4, #0]
   2c9f2:	a801      	add	r0, sp, #4
   2c9f4:	f8d5 8000 	ldr.w	r8, [r5]
   2c9f8:	f7ff fddc 	bl	2c5b4 <rpc_logobj_client_request_alloc>
   2c9fc:	b198      	cbz	r0, 2ca26 <logobj_interface_write+0x6a>
   2c9fe:	200c      	movs	r0, #12
   2ca00:	6823      	ldr	r3, [r4, #0]
   2ca02:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2ca06:	6023      	str	r3, [r4, #0]
   2ca08:	f7fe f8dc 	bl	2abc4 <bsd_os_errno_set>
   2ca0c:	f04f 30ff 	mov.w	r0, #4294967295
   2ca10:	b002      	add	sp, #8
   2ca12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2ca16:	6803      	ldr	r3, [r0, #0]
   2ca18:	00d9      	lsls	r1, r3, #3
   2ca1a:	d4e1      	bmi.n	2c9e0 <logobj_interface_write+0x24>
   2ca1c:	6803      	ldr	r3, [r0, #0]
   2ca1e:	039a      	lsls	r2, r3, #14
   2ca20:	d544      	bpl.n	2caac <logobj_interface_write+0xf0>
   2ca22:	2601      	movs	r6, #1
   2ca24:	e7e0      	b.n	2c9e8 <logobj_interface_write+0x2c>
   2ca26:	2504      	movs	r5, #4
   2ca28:	9b01      	ldr	r3, [sp, #4]
   2ca2a:	f247 0103 	movw	r1, #28675	; 0x7003
   2ca2e:	f8c3 800c 	str.w	r8, [r3, #12]
   2ca32:	7258      	strb	r0, [r3, #9]
   2ca34:	7298      	strb	r0, [r3, #10]
   2ca36:	72d8      	strb	r0, [r3, #11]
   2ca38:	721d      	strb	r5, [r3, #8]
   2ca3a:	4618      	mov	r0, r3
   2ca3c:	f7ff fdd2 	bl	2c5e4 <rpc_logobj_client_request_send>
   2ca40:	4680      	mov	r8, r0
   2ca42:	b9b0      	cbnz	r0, 2ca72 <logobj_interface_write+0xb6>
   2ca44:	b93e      	cbnz	r6, 2ca56 <logobj_interface_write+0x9a>
   2ca46:	4628      	mov	r0, r5
   2ca48:	6823      	ldr	r3, [r4, #0]
   2ca4a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2ca4e:	6023      	str	r3, [r4, #0]
   2ca50:	b002      	add	sp, #8
   2ca52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2ca56:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   2ca5a:	f04f 33ff 	mov.w	r3, #4294967295
   2ca5e:	4611      	mov	r1, r2
   2ca60:	4638      	mov	r0, r7
   2ca62:	f005 ffc5 	bl	329f0 <interface_socket_wait>
   2ca66:	b198      	cbz	r0, 2ca90 <logobj_interface_write+0xd4>
   2ca68:	6823      	ldr	r3, [r4, #0]
   2ca6a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2ca6e:	6023      	str	r3, [r4, #0]
   2ca70:	e7ca      	b.n	2ca08 <logobj_interface_write+0x4c>
   2ca72:	9801      	ldr	r0, [sp, #4]
   2ca74:	f7ff fdcc 	bl	2c610 <rpc_logobj_client_message_free>
   2ca78:	6823      	ldr	r3, [r4, #0]
   2ca7a:	2005      	movs	r0, #5
   2ca7c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2ca80:	6023      	str	r3, [r4, #0]
   2ca82:	e7c1      	b.n	2ca08 <logobj_interface_write+0x4c>
   2ca84:	2016      	movs	r0, #22
   2ca86:	f7fe f89d 	bl	2abc4 <bsd_os_errno_set>
   2ca8a:	f04f 30ff 	mov.w	r0, #4294967295
   2ca8e:	e7bf      	b.n	2ca10 <logobj_interface_write+0x54>
   2ca90:	4638      	mov	r0, r7
   2ca92:	f006 f821 	bl	32ad8 <interface_socket_from_handle_get>
   2ca96:	4603      	mov	r3, r0
   2ca98:	2800      	cmp	r0, #0
   2ca9a:	d0d4      	beq.n	2ca46 <logobj_interface_write+0x8a>
   2ca9c:	6840      	ldr	r0, [r0, #4]
   2ca9e:	2800      	cmp	r0, #0
   2caa0:	d0d1      	beq.n	2ca46 <logobj_interface_write+0x8a>
   2caa2:	f8c3 8004 	str.w	r8, [r3, #4]
   2caa6:	e7df      	b.n	2ca68 <logobj_interface_write+0xac>
   2caa8:	2073      	movs	r0, #115	; 0x73
   2caaa:	e7ad      	b.n	2ca08 <logobj_interface_write+0x4c>
   2caac:	2009      	movs	r0, #9
   2caae:	e7ab      	b.n	2ca08 <logobj_interface_write+0x4c>
   2cab0:	202d      	movs	r0, #45	; 0x2d
   2cab2:	f7fe f887 	bl	2abc4 <bsd_os_errno_set>
   2cab6:	f04f 30ff 	mov.w	r0, #4294967295
   2caba:	e7a9      	b.n	2ca10 <logobj_interface_write+0x54>
   2cabc:	2009      	movs	r0, #9
   2cabe:	f7fe f881 	bl	2abc4 <bsd_os_errno_set>
   2cac2:	f04f 30ff 	mov.w	r0, #4294967295
   2cac6:	e7a3      	b.n	2ca10 <logobj_interface_write+0x54>

0002cac8 <logobj_interface_setopt>:
   2cac8:	b5f0      	push	{r4, r5, r6, r7, lr}
   2caca:	2901      	cmp	r1, #1
   2cacc:	b085      	sub	sp, #20
   2cace:	d068      	beq.n	2cba2 <logobj_interface_setopt+0xda>
   2cad0:	461e      	mov	r6, r3
   2cad2:	f240 2305 	movw	r3, #517	; 0x205
   2cad6:	4299      	cmp	r1, r3
   2cad8:	f040 8095 	bne.w	2cc06 <logobj_interface_setopt+0x13e>
   2cadc:	4607      	mov	r7, r0
   2cade:	4615      	mov	r5, r2
   2cae0:	f005 fffa 	bl	32ad8 <interface_socket_from_handle_get>
   2cae4:	4604      	mov	r4, r0
   2cae6:	2800      	cmp	r0, #0
   2cae8:	f000 80b2 	beq.w	2cc50 <logobj_interface_setopt+0x188>
   2caec:	2d01      	cmp	r5, #1
   2caee:	d019      	beq.n	2cb24 <logobj_interface_setopt+0x5c>
   2caf0:	2d02      	cmp	r5, #2
   2caf2:	d010      	beq.n	2cb16 <logobj_interface_setopt+0x4e>
   2caf4:	252a      	movs	r5, #42	; 0x2a
   2caf6:	6803      	ldr	r3, [r0, #0]
   2caf8:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   2cafc:	6023      	str	r3, [r4, #0]
   2cafe:	6823      	ldr	r3, [r4, #0]
   2cb00:	4628      	mov	r0, r5
   2cb02:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   2cb06:	6023      	str	r3, [r4, #0]
   2cb08:	f7fe f85c 	bl	2abc4 <bsd_os_errno_set>
   2cb0c:	f04f 35ff 	mov.w	r5, #4294967295
   2cb10:	4628      	mov	r0, r5
   2cb12:	b005      	add	sp, #20
   2cb14:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2cb16:	b116      	cbz	r6, 2cb1e <logobj_interface_setopt+0x56>
   2cb18:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2cb1a:	2b01      	cmp	r3, #1
   2cb1c:	d049      	beq.n	2cbb2 <logobj_interface_setopt+0xea>
   2cb1e:	6823      	ldr	r3, [r4, #0]
   2cb20:	2516      	movs	r5, #22
   2cb22:	e7e9      	b.n	2caf8 <logobj_interface_setopt+0x30>
   2cb24:	2e00      	cmp	r6, #0
   2cb26:	d0fa      	beq.n	2cb1e <logobj_interface_setopt+0x56>
   2cb28:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2cb2a:	2b04      	cmp	r3, #4
   2cb2c:	d1f7      	bne.n	2cb1e <logobj_interface_setopt+0x56>
   2cb2e:	2100      	movs	r1, #0
   2cb30:	a803      	add	r0, sp, #12
   2cb32:	f7ff fd3f 	bl	2c5b4 <rpc_logobj_client_request_alloc>
   2cb36:	4605      	mov	r5, r0
   2cb38:	2800      	cmp	r0, #0
   2cb3a:	d16a      	bne.n	2cc12 <logobj_interface_setopt+0x14a>
   2cb3c:	9803      	ldr	r0, [sp, #12]
   2cb3e:	2208      	movs	r2, #8
   2cb40:	4629      	mov	r1, r5
   2cb42:	300c      	adds	r0, #12
   2cb44:	f011 fea2 	bl	3e88c <memset>
   2cb48:	9803      	ldr	r0, [sp, #12]
   2cb4a:	4631      	mov	r1, r6
   2cb4c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   2cb4e:	300c      	adds	r0, #12
   2cb50:	f011 fe7c 	bl	3e84c <memcpy>
   2cb54:	2308      	movs	r3, #8
   2cb56:	9803      	ldr	r0, [sp, #12]
   2cb58:	f247 0102 	movw	r1, #28674	; 0x7002
   2cb5c:	7203      	strb	r3, [r0, #8]
   2cb5e:	7245      	strb	r5, [r0, #9]
   2cb60:	7285      	strb	r5, [r0, #10]
   2cb62:	72c5      	strb	r5, [r0, #11]
   2cb64:	6823      	ldr	r3, [r4, #0]
   2cb66:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   2cb6a:	6023      	str	r3, [r4, #0]
   2cb6c:	f7ff fd3a 	bl	2c5e4 <rpc_logobj_client_request_send>
   2cb70:	2800      	cmp	r0, #0
   2cb72:	d151      	bne.n	2cc18 <logobj_interface_setopt+0x150>
   2cb74:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   2cb78:	f04f 33ff 	mov.w	r3, #4294967295
   2cb7c:	4611      	mov	r1, r2
   2cb7e:	4638      	mov	r0, r7
   2cb80:	f005 ff36 	bl	329f0 <interface_socket_wait>
   2cb84:	4605      	mov	r5, r0
   2cb86:	2800      	cmp	r0, #0
   2cb88:	d13b      	bne.n	2cc02 <logobj_interface_setopt+0x13a>
   2cb8a:	4638      	mov	r0, r7
   2cb8c:	f005 ffa4 	bl	32ad8 <interface_socket_from_handle_get>
   2cb90:	2800      	cmp	r0, #0
   2cb92:	d04f      	beq.n	2cc34 <logobj_interface_setopt+0x16c>
   2cb94:	6843      	ldr	r3, [r0, #4]
   2cb96:	2b00      	cmp	r3, #0
   2cb98:	d04c      	beq.n	2cc34 <logobj_interface_setopt+0x16c>
   2cb9a:	2200      	movs	r2, #0
   2cb9c:	461d      	mov	r5, r3
   2cb9e:	6042      	str	r2, [r0, #4]
   2cba0:	e02f      	b.n	2cc02 <logobj_interface_setopt+0x13a>
   2cba2:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   2cba4:	9400      	str	r4, [sp, #0]
   2cba6:	f005 ffbf 	bl	32b28 <interface_socket_setopt>
   2cbaa:	4605      	mov	r5, r0
   2cbac:	4628      	mov	r0, r5
   2cbae:	b005      	add	sp, #20
   2cbb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2cbb2:	2100      	movs	r1, #0
   2cbb4:	a803      	add	r0, sp, #12
   2cbb6:	7835      	ldrb	r5, [r6, #0]
   2cbb8:	f7ff fcfc 	bl	2c5b4 <rpc_logobj_client_request_alloc>
   2cbbc:	bb48      	cbnz	r0, 2cc12 <logobj_interface_setopt+0x14a>
   2cbbe:	2d01      	cmp	r5, #1
   2cbc0:	bf08      	it	eq
   2cbc2:	4b26      	ldreq	r3, [pc, #152]	; (2cc5c <logobj_interface_setopt+0x194>)
   2cbc4:	f04f 0204 	mov.w	r2, #4
   2cbc8:	bf08      	it	eq
   2cbca:	701d      	strbeq	r5, [r3, #0]
   2cbcc:	2300      	movs	r3, #0
   2cbce:	9803      	ldr	r0, [sp, #12]
   2cbd0:	f247 0101 	movw	r1, #28673	; 0x7001
   2cbd4:	7243      	strb	r3, [r0, #9]
   2cbd6:	60c5      	str	r5, [r0, #12]
   2cbd8:	7283      	strb	r3, [r0, #10]
   2cbda:	72c3      	strb	r3, [r0, #11]
   2cbdc:	7202      	strb	r2, [r0, #8]
   2cbde:	6823      	ldr	r3, [r4, #0]
   2cbe0:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   2cbe4:	6023      	str	r3, [r4, #0]
   2cbe6:	f7ff fcfd 	bl	2c5e4 <rpc_logobj_client_request_send>
   2cbea:	4606      	mov	r6, r0
   2cbec:	b9a0      	cbnz	r0, 2cc18 <logobj_interface_setopt+0x150>
   2cbee:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   2cbf2:	f04f 33ff 	mov.w	r3, #4294967295
   2cbf6:	4611      	mov	r1, r2
   2cbf8:	4638      	mov	r0, r7
   2cbfa:	f005 fef9 	bl	329f0 <interface_socket_wait>
   2cbfe:	4605      	mov	r5, r0
   2cc00:	b180      	cbz	r0, 2cc24 <logobj_interface_setopt+0x15c>
   2cc02:	6823      	ldr	r3, [r4, #0]
   2cc04:	e778      	b.n	2caf8 <logobj_interface_setopt+0x30>
   2cc06:	202a      	movs	r0, #42	; 0x2a
   2cc08:	f7fd ffdc 	bl	2abc4 <bsd_os_errno_set>
   2cc0c:	f04f 35ff 	mov.w	r5, #4294967295
   2cc10:	e77e      	b.n	2cb10 <logobj_interface_setopt+0x48>
   2cc12:	6823      	ldr	r3, [r4, #0]
   2cc14:	250c      	movs	r5, #12
   2cc16:	e76f      	b.n	2caf8 <logobj_interface_setopt+0x30>
   2cc18:	9803      	ldr	r0, [sp, #12]
   2cc1a:	f7ff fcf9 	bl	2c610 <rpc_logobj_client_message_free>
   2cc1e:	2505      	movs	r5, #5
   2cc20:	6823      	ldr	r3, [r4, #0]
   2cc22:	e769      	b.n	2caf8 <logobj_interface_setopt+0x30>
   2cc24:	4638      	mov	r0, r7
   2cc26:	f005 ff57 	bl	32ad8 <interface_socket_from_handle_get>
   2cc2a:	b140      	cbz	r0, 2cc3e <logobj_interface_setopt+0x176>
   2cc2c:	6845      	ldr	r5, [r0, #4]
   2cc2e:	b135      	cbz	r5, 2cc3e <logobj_interface_setopt+0x176>
   2cc30:	6046      	str	r6, [r0, #4]
   2cc32:	e7e6      	b.n	2cc02 <logobj_interface_setopt+0x13a>
   2cc34:	4631      	mov	r1, r6
   2cc36:	2204      	movs	r2, #4
   2cc38:	4809      	ldr	r0, [pc, #36]	; (2cc60 <logobj_interface_setopt+0x198>)
   2cc3a:	f011 fe07 	bl	3e84c <memcpy>
   2cc3e:	6823      	ldr	r3, [r4, #0]
   2cc40:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   2cc44:	6023      	str	r3, [r4, #0]
   2cc46:	6823      	ldr	r3, [r4, #0]
   2cc48:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   2cc4c:	6023      	str	r3, [r4, #0]
   2cc4e:	e75f      	b.n	2cb10 <logobj_interface_setopt+0x48>
   2cc50:	2009      	movs	r0, #9
   2cc52:	f7fd ffb7 	bl	2abc4 <bsd_os_errno_set>
   2cc56:	f04f 35ff 	mov.w	r5, #4294967295
   2cc5a:	e759      	b.n	2cb10 <logobj_interface_setopt+0x48>
   2cc5c:	2002d7eb 	.word	0x2002d7eb
   2cc60:	20024e40 	.word	0x20024e40

0002cc64 <logobj_interface_getopt>:
   2cc64:	b5f0      	push	{r4, r5, r6, r7, lr}
   2cc66:	2901      	cmp	r1, #1
   2cc68:	b083      	sub	sp, #12
   2cc6a:	9e08      	ldr	r6, [sp, #32]
   2cc6c:	d030      	beq.n	2ccd0 <logobj_interface_getopt+0x6c>
   2cc6e:	461f      	mov	r7, r3
   2cc70:	f240 2305 	movw	r3, #517	; 0x205
   2cc74:	4299      	cmp	r1, r3
   2cc76:	d134      	bne.n	2cce2 <logobj_interface_getopt+0x7e>
   2cc78:	4615      	mov	r5, r2
   2cc7a:	f005 ff2d 	bl	32ad8 <interface_socket_from_handle_get>
   2cc7e:	2800      	cmp	r0, #0
   2cc80:	d037      	beq.n	2ccf2 <logobj_interface_getopt+0x8e>
   2cc82:	2d01      	cmp	r5, #1
   2cc84:	d015      	beq.n	2ccb2 <logobj_interface_getopt+0x4e>
   2cc86:	2d02      	cmp	r5, #2
   2cc88:	d10b      	bne.n	2cca2 <logobj_interface_getopt+0x3e>
   2cc8a:	b387      	cbz	r7, 2ccee <logobj_interface_getopt+0x8a>
   2cc8c:	6833      	ldr	r3, [r6, #0]
   2cc8e:	b373      	cbz	r3, 2ccee <logobj_interface_getopt+0x8a>
   2cc90:	2300      	movs	r3, #0
   2cc92:	2201      	movs	r2, #1
   2cc94:	4618      	mov	r0, r3
   2cc96:	491a      	ldr	r1, [pc, #104]	; (2cd00 <logobj_interface_getopt+0x9c>)
   2cc98:	7809      	ldrb	r1, [r1, #0]
   2cc9a:	7039      	strb	r1, [r7, #0]
   2cc9c:	6032      	str	r2, [r6, #0]
   2cc9e:	b003      	add	sp, #12
   2cca0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2cca2:	2009      	movs	r0, #9
   2cca4:	f7fd ff8e 	bl	2abc4 <bsd_os_errno_set>
   2cca8:	f04f 33ff 	mov.w	r3, #4294967295
   2ccac:	4618      	mov	r0, r3
   2ccae:	b003      	add	sp, #12
   2ccb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2ccb2:	b1e7      	cbz	r7, 2ccee <logobj_interface_getopt+0x8a>
   2ccb4:	6833      	ldr	r3, [r6, #0]
   2ccb6:	2b03      	cmp	r3, #3
   2ccb8:	d919      	bls.n	2ccee <logobj_interface_getopt+0x8a>
   2ccba:	4638      	mov	r0, r7
   2ccbc:	2204      	movs	r2, #4
   2ccbe:	4911      	ldr	r1, [pc, #68]	; (2cd04 <logobj_interface_getopt+0xa0>)
   2ccc0:	f011 fdc4 	bl	3e84c <memcpy>
   2ccc4:	2300      	movs	r3, #0
   2ccc6:	2204      	movs	r2, #4
   2ccc8:	4618      	mov	r0, r3
   2ccca:	6032      	str	r2, [r6, #0]
   2cccc:	b003      	add	sp, #12
   2ccce:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2ccd0:	9600      	str	r6, [sp, #0]
   2ccd2:	f005 ff6b 	bl	32bac <interface_socket_getopt>
   2ccd6:	4603      	mov	r3, r0
   2ccd8:	2800      	cmp	r0, #0
   2ccda:	d1e3      	bne.n	2cca4 <logobj_interface_getopt+0x40>
   2ccdc:	4618      	mov	r0, r3
   2ccde:	b003      	add	sp, #12
   2cce0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2cce2:	202a      	movs	r0, #42	; 0x2a
   2cce4:	f7fd ff6e 	bl	2abc4 <bsd_os_errno_set>
   2cce8:	f04f 33ff 	mov.w	r3, #4294967295
   2ccec:	e7de      	b.n	2ccac <logobj_interface_getopt+0x48>
   2ccee:	2016      	movs	r0, #22
   2ccf0:	e7d8      	b.n	2cca4 <logobj_interface_getopt+0x40>
   2ccf2:	2009      	movs	r0, #9
   2ccf4:	f7fd ff66 	bl	2abc4 <bsd_os_errno_set>
   2ccf8:	f04f 33ff 	mov.w	r3, #4294967295
   2ccfc:	e7d6      	b.n	2ccac <logobj_interface_getopt+0x48>
   2ccfe:	bf00      	nop
   2cd00:	2002d7ec 	.word	0x2002d7ec
   2cd04:	20024e40 	.word	0x20024e40

0002cd08 <logobj_interface_close>:
   2cd08:	b510      	push	{r4, lr}
   2cd0a:	4604      	mov	r4, r0
   2cd0c:	f005 fee4 	bl	32ad8 <interface_socket_from_handle_get>
   2cd10:	b138      	cbz	r0, 2cd22 <logobj_interface_close+0x1a>
   2cd12:	4620      	mov	r0, r4
   2cd14:	f005 fe1e 	bl	32954 <interface_socket_free>
   2cd18:	2300      	movs	r3, #0
   2cd1a:	4a05      	ldr	r2, [pc, #20]	; (2cd30 <logobj_interface_close+0x28>)
   2cd1c:	4618      	mov	r0, r3
   2cd1e:	6013      	str	r3, [r2, #0]
   2cd20:	bd10      	pop	{r4, pc}
   2cd22:	2009      	movs	r0, #9
   2cd24:	f7fd ff4e 	bl	2abc4 <bsd_os_errno_set>
   2cd28:	f04f 30ff 	mov.w	r0, #4294967295
   2cd2c:	bd10      	pop	{r4, pc}
   2cd2e:	bf00      	nop
   2cd30:	20024e44 	.word	0x20024e44

0002cd34 <packet_free_cb>:
   2cd34:	6800      	ldr	r0, [r0, #0]
   2cd36:	f004 b9f1 	b.w	3111c <rpc_at_client_data_free>
   2cd3a:	bf00      	nop

0002cd3c <at_interface_write>:
   2cd3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2cd40:	b082      	sub	sp, #8
   2cd42:	9c08      	ldr	r4, [sp, #32]
   2cd44:	2c00      	cmp	r4, #0
   2cd46:	d15b      	bne.n	2ce00 <at_interface_write+0xc4>
   2cd48:	460f      	mov	r7, r1
   2cd4a:	4615      	mov	r5, r2
   2cd4c:	4698      	mov	r8, r3
   2cd4e:	4606      	mov	r6, r0
   2cd50:	f005 fec2 	bl	32ad8 <interface_socket_from_handle_get>
   2cd54:	4604      	mov	r4, r0
   2cd56:	f1b8 0f00 	cmp.w	r8, #0
   2cd5a:	d12b      	bne.n	2cdb4 <at_interface_write+0x78>
   2cd5c:	2800      	cmp	r0, #0
   2cd5e:	d055      	beq.n	2ce0c <at_interface_write+0xd0>
   2cd60:	6803      	ldr	r3, [r0, #0]
   2cd62:	039b      	lsls	r3, r3, #14
   2cd64:	d552      	bpl.n	2ce0c <at_interface_write+0xd0>
   2cd66:	6803      	ldr	r3, [r0, #0]
   2cd68:	4629      	mov	r1, r5
   2cd6a:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   2cd6e:	6003      	str	r3, [r0, #0]
   2cd70:	6803      	ldr	r3, [r0, #0]
   2cd72:	a801      	add	r0, sp, #4
   2cd74:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
   2cd78:	6023      	str	r3, [r4, #0]
   2cd7a:	f004 f9a5 	bl	310c8 <rpc_at_client_request_alloc>
   2cd7e:	bb08      	cbnz	r0, 2cdc4 <at_interface_write+0x88>
   2cd80:	2204      	movs	r2, #4
   2cd82:	9b01      	ldr	r3, [sp, #4]
   2cd84:	721a      	strb	r2, [r3, #8]
   2cd86:	7258      	strb	r0, [r3, #9]
   2cd88:	7298      	strb	r0, [r3, #10]
   2cd8a:	72d8      	strb	r0, [r3, #11]
   2cd8c:	60de      	str	r6, [r3, #12]
   2cd8e:	b9fd      	cbnz	r5, 2cdd0 <at_interface_write+0x94>
   2cd90:	4618      	mov	r0, r3
   2cd92:	2101      	movs	r1, #1
   2cd94:	f004 f9ac 	bl	310f0 <rpc_at_client_request_send>
   2cd98:	bb48      	cbnz	r0, 2cdee <at_interface_write+0xb2>
   2cd9a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   2cd9e:	4630      	mov	r0, r6
   2cda0:	4611      	mov	r1, r2
   2cda2:	f04f 33ff 	mov.w	r3, #4294967295
   2cda6:	f005 fe23 	bl	329f0 <interface_socket_wait>
   2cdaa:	b960      	cbnz	r0, 2cdc6 <at_interface_write+0x8a>
   2cdac:	4628      	mov	r0, r5
   2cdae:	b002      	add	sp, #8
   2cdb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2cdb4:	b360      	cbz	r0, 2ce10 <at_interface_write+0xd4>
   2cdb6:	6803      	ldr	r3, [r0, #0]
   2cdb8:	202d      	movs	r0, #45	; 0x2d
   2cdba:	f7fd ff03 	bl	2abc4 <bsd_os_errno_set>
   2cdbe:	f04f 30ff 	mov.w	r0, #4294967295
   2cdc2:	e7f4      	b.n	2cdae <at_interface_write+0x72>
   2cdc4:	200c      	movs	r0, #12
   2cdc6:	6823      	ldr	r3, [r4, #0]
   2cdc8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2cdcc:	6023      	str	r3, [r4, #0]
   2cdce:	e7f4      	b.n	2cdba <at_interface_write+0x7e>
   2cdd0:	4639      	mov	r1, r7
   2cdd2:	6818      	ldr	r0, [r3, #0]
   2cdd4:	462a      	mov	r2, r5
   2cdd6:	f011 fd39 	bl	3e84c <memcpy>
   2cdda:	2101      	movs	r1, #1
   2cddc:	9801      	ldr	r0, [sp, #4]
   2cdde:	f004 f987 	bl	310f0 <rpc_at_client_request_send>
   2cde2:	2800      	cmp	r0, #0
   2cde4:	d0d9      	beq.n	2cd9a <at_interface_write+0x5e>
   2cde6:	9b01      	ldr	r3, [sp, #4]
   2cde8:	6818      	ldr	r0, [r3, #0]
   2cdea:	f004 f997 	bl	3111c <rpc_at_client_data_free>
   2cdee:	9801      	ldr	r0, [sp, #4]
   2cdf0:	f004 f98c 	bl	3110c <rpc_at_client_message_free>
   2cdf4:	6823      	ldr	r3, [r4, #0]
   2cdf6:	2023      	movs	r0, #35	; 0x23
   2cdf8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2cdfc:	6023      	str	r3, [r4, #0]
   2cdfe:	e7dc      	b.n	2cdba <at_interface_write+0x7e>
   2ce00:	2038      	movs	r0, #56	; 0x38
   2ce02:	f7fd fedf 	bl	2abc4 <bsd_os_errno_set>
   2ce06:	f04f 30ff 	mov.w	r0, #4294967295
   2ce0a:	e7d0      	b.n	2cdae <at_interface_write+0x72>
   2ce0c:	2016      	movs	r0, #22
   2ce0e:	e7d4      	b.n	2cdba <at_interface_write+0x7e>
   2ce10:	202d      	movs	r0, #45	; 0x2d
   2ce12:	e7d2      	b.n	2cdba <at_interface_write+0x7e>

0002ce14 <at_interface_init>:
   2ce14:	f004 b952 	b.w	310bc <rpc_at_client_init>

0002ce18 <at_interface_open>:
   2ce18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2ce1c:	2600      	movs	r6, #0
   2ce1e:	b082      	sub	sp, #8
   2ce20:	2902      	cmp	r1, #2
   2ce22:	9600      	str	r6, [sp, #0]
   2ce24:	d13e      	bne.n	2cea4 <at_interface_open+0x8c>
   2ce26:	4680      	mov	r8, r0
   2ce28:	4617      	mov	r7, r2
   2ce2a:	4668      	mov	r0, sp
   2ce2c:	4a20      	ldr	r2, [pc, #128]	; (2ceb0 <at_interface_open+0x98>)
   2ce2e:	460c      	mov	r4, r1
   2ce30:	f005 fd2c 	bl	3288c <interface_socket_allocate>
   2ce34:	9b00      	ldr	r3, [sp, #0]
   2ce36:	4605      	mov	r5, r0
   2ce38:	b30b      	cbz	r3, 2ce7e <at_interface_open+0x66>
   2ce3a:	e9c3 8403 	strd	r8, r4, [r3, #12]
   2ce3e:	615f      	str	r7, [r3, #20]
   2ce40:	4631      	mov	r1, r6
   2ce42:	a801      	add	r0, sp, #4
   2ce44:	f004 f940 	bl	310c8 <rpc_at_client_request_alloc>
   2ce48:	bb50      	cbnz	r0, 2cea0 <at_interface_open+0x88>
   2ce4a:	2204      	movs	r2, #4
   2ce4c:	9b01      	ldr	r3, [sp, #4]
   2ce4e:	2105      	movs	r1, #5
   2ce50:	7258      	strb	r0, [r3, #9]
   2ce52:	7298      	strb	r0, [r3, #10]
   2ce54:	72d8      	strb	r0, [r3, #11]
   2ce56:	721a      	strb	r2, [r3, #8]
   2ce58:	60dd      	str	r5, [r3, #12]
   2ce5a:	4618      	mov	r0, r3
   2ce5c:	f004 f948 	bl	310f0 <rpc_at_client_request_send>
   2ce60:	b988      	cbnz	r0, 2ce86 <at_interface_open+0x6e>
   2ce62:	4622      	mov	r2, r4
   2ce64:	4621      	mov	r1, r4
   2ce66:	f04f 33ff 	mov.w	r3, #4294967295
   2ce6a:	4628      	mov	r0, r5
   2ce6c:	f005 fdc0 	bl	329f0 <interface_socket_wait>
   2ce70:	4604      	mov	r4, r0
   2ce72:	b960      	cbnz	r0, 2ce8e <at_interface_open+0x76>
   2ce74:	9a00      	ldr	r2, [sp, #0]
   2ce76:	6813      	ldr	r3, [r2, #0]
   2ce78:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2ce7c:	6013      	str	r3, [r2, #0]
   2ce7e:	4628      	mov	r0, r5
   2ce80:	b002      	add	sp, #8
   2ce82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2ce86:	9801      	ldr	r0, [sp, #4]
   2ce88:	f004 f940 	bl	3110c <rpc_at_client_message_free>
   2ce8c:	2423      	movs	r4, #35	; 0x23
   2ce8e:	4628      	mov	r0, r5
   2ce90:	f005 fd60 	bl	32954 <interface_socket_free>
   2ce94:	4620      	mov	r0, r4
   2ce96:	f7fd fe95 	bl	2abc4 <bsd_os_errno_set>
   2ce9a:	f04f 35ff 	mov.w	r5, #4294967295
   2ce9e:	e7ee      	b.n	2ce7e <at_interface_open+0x66>
   2cea0:	240c      	movs	r4, #12
   2cea2:	e7f4      	b.n	2ce8e <at_interface_open+0x76>
   2cea4:	2029      	movs	r0, #41	; 0x29
   2cea6:	f7fd fe8d 	bl	2abc4 <bsd_os_errno_set>
   2ceaa:	f04f 35ff 	mov.w	r5, #4294967295
   2ceae:	e7e6      	b.n	2ce7e <at_interface_open+0x66>
   2ceb0:	0002cd35 	.word	0x0002cd35

0002ceb4 <at_interface_close>:
   2ceb4:	b5f0      	push	{r4, r5, r6, r7, lr}
   2ceb6:	b083      	sub	sp, #12
   2ceb8:	4606      	mov	r6, r0
   2ceba:	f005 fe0d 	bl	32ad8 <interface_socket_from_handle_get>
   2cebe:	2800      	cmp	r0, #0
   2cec0:	d03d      	beq.n	2cf3e <at_interface_close+0x8a>
   2cec2:	230d      	movs	r3, #13
   2cec4:	6807      	ldr	r7, [r0, #0]
   2cec6:	6003      	str	r3, [r0, #0]
   2cec8:	6803      	ldr	r3, [r0, #0]
   2ceca:	4604      	mov	r4, r0
   2cecc:	039b      	lsls	r3, r3, #14
   2cece:	d41f      	bmi.n	2cf10 <at_interface_close+0x5c>
   2ced0:	2100      	movs	r1, #0
   2ced2:	a801      	add	r0, sp, #4
   2ced4:	f004 f8f8 	bl	310c8 <rpc_at_client_request_alloc>
   2ced8:	bb20      	cbnz	r0, 2cf24 <at_interface_close+0x70>
   2ceda:	2204      	movs	r2, #4
   2cedc:	9b01      	ldr	r3, [sp, #4]
   2cede:	2106      	movs	r1, #6
   2cee0:	7258      	strb	r0, [r3, #9]
   2cee2:	7298      	strb	r0, [r3, #10]
   2cee4:	72d8      	strb	r0, [r3, #11]
   2cee6:	721a      	strb	r2, [r3, #8]
   2cee8:	60de      	str	r6, [r3, #12]
   2ceea:	4618      	mov	r0, r3
   2ceec:	f004 f900 	bl	310f0 <rpc_at_client_request_send>
   2cef0:	b9d0      	cbnz	r0, 2cf28 <at_interface_close+0x74>
   2cef2:	220e      	movs	r2, #14
   2cef4:	f04f 33ff 	mov.w	r3, #4294967295
   2cef8:	4611      	mov	r1, r2
   2cefa:	4630      	mov	r0, r6
   2cefc:	f005 fd78 	bl	329f0 <interface_socket_wait>
   2cf00:	4605      	mov	r5, r0
   2cf02:	b9a8      	cbnz	r0, 2cf30 <at_interface_close+0x7c>
   2cf04:	4630      	mov	r0, r6
   2cf06:	f005 fd25 	bl	32954 <interface_socket_free>
   2cf0a:	4628      	mov	r0, r5
   2cf0c:	b003      	add	sp, #12
   2cf0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2cf10:	6803      	ldr	r3, [r0, #0]
   2cf12:	2100      	movs	r1, #0
   2cf14:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   2cf18:	6003      	str	r3, [r0, #0]
   2cf1a:	a801      	add	r0, sp, #4
   2cf1c:	f004 f8d4 	bl	310c8 <rpc_at_client_request_alloc>
   2cf20:	2800      	cmp	r0, #0
   2cf22:	d0da      	beq.n	2ceda <at_interface_close+0x26>
   2cf24:	250c      	movs	r5, #12
   2cf26:	e003      	b.n	2cf30 <at_interface_close+0x7c>
   2cf28:	9801      	ldr	r0, [sp, #4]
   2cf2a:	f004 f8ef 	bl	3110c <rpc_at_client_message_free>
   2cf2e:	2523      	movs	r5, #35	; 0x23
   2cf30:	6027      	str	r7, [r4, #0]
   2cf32:	4628      	mov	r0, r5
   2cf34:	f7fd fe46 	bl	2abc4 <bsd_os_errno_set>
   2cf38:	f04f 35ff 	mov.w	r5, #4294967295
   2cf3c:	e7e5      	b.n	2cf0a <at_interface_close+0x56>
   2cf3e:	2516      	movs	r5, #22
   2cf40:	e7f7      	b.n	2cf32 <at_interface_close+0x7e>
   2cf42:	bf00      	nop

0002cf44 <at_interface_read>:
   2cf44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2cf48:	b084      	sub	sp, #16
   2cf4a:	4688      	mov	r8, r1
   2cf4c:	4615      	mov	r5, r2
   2cf4e:	461e      	mov	r6, r3
   2cf50:	4607      	mov	r7, r0
   2cf52:	f005 fdc1 	bl	32ad8 <interface_socket_from_handle_get>
   2cf56:	2800      	cmp	r0, #0
   2cf58:	d043      	beq.n	2cfe2 <at_interface_read+0x9e>
   2cf5a:	2300      	movs	r3, #0
   2cf5c:	4604      	mov	r4, r0
   2cf5e:	e9cd 8500 	strd	r8, r5, [sp]
   2cf62:	e9cd 3302 	strd	r3, r3, [sp, #8]
   2cf66:	bb2e      	cbnz	r6, 2cfb4 <at_interface_read+0x70>
   2cf68:	f016 0502 	ands.w	r5, r6, #2
   2cf6c:	d00d      	beq.n	2cf8a <at_interface_read+0x46>
   2cf6e:	e028      	b.n	2cfc2 <at_interface_read+0x7e>
   2cf70:	b9cd      	cbnz	r5, 2cfa6 <at_interface_read+0x62>
   2cf72:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   2cf76:	6a23      	ldr	r3, [r4, #32]
   2cf78:	4611      	mov	r1, r2
   2cf7a:	2b00      	cmp	r3, #0
   2cf7c:	bf08      	it	eq
   2cf7e:	f04f 33ff 	moveq.w	r3, #4294967295
   2cf82:	4638      	mov	r0, r7
   2cf84:	f005 fd34 	bl	329f0 <interface_socket_wait>
   2cf88:	4605      	mov	r5, r0
   2cf8a:	6823      	ldr	r3, [r4, #0]
   2cf8c:	69e0      	ldr	r0, [r4, #28]
   2cf8e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   2cf92:	6023      	str	r3, [r4, #0]
   2cf94:	6803      	ldr	r3, [r0, #0]
   2cf96:	4632      	mov	r2, r6
   2cf98:	689b      	ldr	r3, [r3, #8]
   2cf9a:	4669      	mov	r1, sp
   2cf9c:	4798      	blx	r3
   2cf9e:	f1b0 0800 	subs.w	r8, r0, #0
   2cfa2:	dbe5      	blt.n	2cf70 <at_interface_read+0x2c>
   2cfa4:	b115      	cbz	r5, 2cfac <at_interface_read+0x68>
   2cfa6:	4628      	mov	r0, r5
   2cfa8:	f7fd fe0c 	bl	2abc4 <bsd_os_errno_set>
   2cfac:	4640      	mov	r0, r8
   2cfae:	b004      	add	sp, #16
   2cfb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2cfb4:	f016 0f0a 	tst.w	r6, #10
   2cfb8:	d1d6      	bne.n	2cf68 <at_interface_read+0x24>
   2cfba:	252d      	movs	r5, #45	; 0x2d
   2cfbc:	f04f 38ff 	mov.w	r8, #4294967295
   2cfc0:	e7f1      	b.n	2cfa6 <at_interface_read+0x62>
   2cfc2:	6823      	ldr	r3, [r4, #0]
   2cfc4:	69e0      	ldr	r0, [r4, #28]
   2cfc6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   2cfca:	6023      	str	r3, [r4, #0]
   2cfcc:	6803      	ldr	r3, [r0, #0]
   2cfce:	4632      	mov	r2, r6
   2cfd0:	689b      	ldr	r3, [r3, #8]
   2cfd2:	4669      	mov	r1, sp
   2cfd4:	4798      	blx	r3
   2cfd6:	f1b0 3fff 	cmp.w	r0, #4294967295
   2cfda:	4680      	mov	r8, r0
   2cfdc:	d1e6      	bne.n	2cfac <at_interface_read+0x68>
   2cfde:	2523      	movs	r5, #35	; 0x23
   2cfe0:	e7e1      	b.n	2cfa6 <at_interface_read+0x62>
   2cfe2:	2516      	movs	r5, #22
   2cfe4:	f04f 38ff 	mov.w	r8, #4294967295
   2cfe8:	e7dd      	b.n	2cfa6 <at_interface_read+0x62>
   2cfea:	bf00      	nop

0002cfec <at_interface_getopt>:
   2cfec:	f005 bdde 	b.w	32bac <interface_socket_getopt>

0002cff0 <at_interface_setopt>:
   2cff0:	f005 bd9a 	b.w	32b28 <interface_socket_setopt>

0002cff4 <rpc_at_event_handler>:
   2cff4:	b570      	push	{r4, r5, r6, lr}
   2cff6:	4606      	mov	r6, r0
   2cff8:	b084      	sub	sp, #16
   2cffa:	68c0      	ldr	r0, [r0, #12]
   2cffc:	460d      	mov	r5, r1
   2cffe:	f005 fd6b 	bl	32ad8 <interface_socket_from_handle_get>
   2d002:	4604      	mov	r4, r0
   2d004:	b348      	cbz	r0, 2d05a <rpc_at_event_handler+0x66>
   2d006:	6803      	ldr	r3, [r0, #0]
   2d008:	b29b      	uxth	r3, r3
   2d00a:	2b01      	cmp	r3, #1
   2d00c:	d01f      	beq.n	2d04e <rpc_at_event_handler+0x5a>
   2d00e:	6803      	ldr	r3, [r0, #0]
   2d010:	b29b      	uxth	r3, r3
   2d012:	2b0d      	cmp	r3, #13
   2d014:	d029      	beq.n	2d06a <rpc_at_event_handler+0x76>
   2d016:	6803      	ldr	r3, [r0, #0]
   2d018:	b29b      	uxth	r3, r3
   2d01a:	2b02      	cmp	r3, #2
   2d01c:	d02d      	beq.n	2d07a <rpc_at_event_handler+0x86>
   2d01e:	3d03      	subs	r5, #3
   2d020:	2d01      	cmp	r5, #1
   2d022:	d817      	bhi.n	2d054 <rpc_at_event_handler+0x60>
   2d024:	2500      	movs	r5, #0
   2d026:	6873      	ldr	r3, [r6, #4]
   2d028:	6832      	ldr	r2, [r6, #0]
   2d02a:	e9cd 5502 	strd	r5, r5, [sp, #8]
   2d02e:	e9cd 2300 	strd	r2, r3, [sp]
   2d032:	69e0      	ldr	r0, [r4, #28]
   2d034:	4669      	mov	r1, sp
   2d036:	6803      	ldr	r3, [r0, #0]
   2d038:	685b      	ldr	r3, [r3, #4]
   2d03a:	4798      	blx	r3
   2d03c:	3001      	adds	r0, #1
   2d03e:	d019      	beq.n	2d074 <rpc_at_event_handler+0x80>
   2d040:	4628      	mov	r0, r5
   2d042:	6823      	ldr	r3, [r4, #0]
   2d044:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   2d048:	6023      	str	r3, [r4, #0]
   2d04a:	b004      	add	sp, #16
   2d04c:	bd70      	pop	{r4, r5, r6, pc}
   2d04e:	2d02      	cmp	r5, #2
   2d050:	d1e5      	bne.n	2d01e <rpc_at_event_handler+0x2a>
   2d052:	6005      	str	r5, [r0, #0]
   2d054:	2000      	movs	r0, #0
   2d056:	b004      	add	sp, #16
   2d058:	bd70      	pop	{r4, r5, r6, pc}
   2d05a:	6830      	ldr	r0, [r6, #0]
   2d05c:	2800      	cmp	r0, #0
   2d05e:	d0f9      	beq.n	2d054 <rpc_at_event_handler+0x60>
   2d060:	f004 f85c 	bl	3111c <rpc_at_client_data_free>
   2d064:	4620      	mov	r0, r4
   2d066:	b004      	add	sp, #16
   2d068:	bd70      	pop	{r4, r5, r6, pc}
   2d06a:	2d02      	cmp	r5, #2
   2d06c:	d1d7      	bne.n	2d01e <rpc_at_event_handler+0x2a>
   2d06e:	230e      	movs	r3, #14
   2d070:	6003      	str	r3, [r0, #0]
   2d072:	e7ef      	b.n	2d054 <rpc_at_event_handler+0x60>
   2d074:	2002      	movs	r0, #2
   2d076:	b004      	add	sp, #16
   2d078:	bd70      	pop	{r4, r5, r6, pc}
   2d07a:	6803      	ldr	r3, [r0, #0]
   2d07c:	029b      	lsls	r3, r3, #10
   2d07e:	d5ce      	bpl.n	2d01e <rpc_at_event_handler+0x2a>
   2d080:	2d02      	cmp	r5, #2
   2d082:	d1cc      	bne.n	2d01e <rpc_at_event_handler+0x2a>
   2d084:	6803      	ldr	r3, [r0, #0]
   2d086:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   2d08a:	6003      	str	r3, [r0, #0]
   2d08c:	6803      	ldr	r3, [r0, #0]
   2d08e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2d092:	6003      	str	r3, [r0, #0]
   2d094:	e7de      	b.n	2d054 <rpc_at_event_handler+0x60>
   2d096:	bf00      	nop

0002d098 <dfu_client_event_handler>:
   2d098:	f850 1b08 	ldr.w	r1, [r0], #8
   2d09c:	0c09      	lsrs	r1, r1, #16
   2d09e:	f001 b925 	b.w	2e2ec <rpc_dfu_event_handler>
   2d0a2:	bf00      	nop

0002d0a4 <rpc_dfu_client_init>:
   2d0a4:	4801      	ldr	r0, [pc, #4]	; (2d0ac <rpc_dfu_client_init+0x8>)
   2d0a6:	f005 be53 	b.w	32d50 <rpc_client_register>
   2d0aa:	bf00      	nop
   2d0ac:	00040040 	.word	0x00040040

0002d0b0 <rpc_dfu_client_request_alloc>:
   2d0b0:	2300      	movs	r3, #0
   2d0b2:	b510      	push	{r4, lr}
   2d0b4:	b082      	sub	sp, #8
   2d0b6:	9301      	str	r3, [sp, #4]
   2d0b8:	b158      	cbz	r0, 2d0d2 <rpc_dfu_client_request_alloc+0x22>
   2d0ba:	4604      	mov	r4, r0
   2d0bc:	aa01      	add	r2, sp, #4
   2d0be:	2006      	movs	r0, #6
   2d0c0:	f006 f87e 	bl	331c0 <rpc_message_alloc>
   2d0c4:	b918      	cbnz	r0, 2d0ce <rpc_dfu_client_request_alloc+0x1e>
   2d0c6:	9b01      	ldr	r3, [sp, #4]
   2d0c8:	b10b      	cbz	r3, 2d0ce <rpc_dfu_client_request_alloc+0x1e>
   2d0ca:	3308      	adds	r3, #8
   2d0cc:	6023      	str	r3, [r4, #0]
   2d0ce:	b002      	add	sp, #8
   2d0d0:	bd10      	pop	{r4, pc}
   2d0d2:	2007      	movs	r0, #7
   2d0d4:	b002      	add	sp, #8
   2d0d6:	bd10      	pop	{r4, pc}

0002d0d8 <rpc_dfu_client_request_send>:
   2d0d8:	f411 4f70 	tst.w	r1, #61440	; 0xf000
   2d0dc:	d10b      	bne.n	2d0f6 <rpc_dfu_client_request_send+0x1e>
   2d0de:	b160      	cbz	r0, 2d0fa <rpc_dfu_client_request_send+0x22>
   2d0e0:	4603      	mov	r3, r0
   2d0e2:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   2d0e6:	2006      	movs	r0, #6
   2d0e8:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   2d0ec:	f843 1d08 	str.w	r1, [r3, #-8]!
   2d0f0:	4619      	mov	r1, r3
   2d0f2:	f006 b84d 	b.w	33190 <rpc_message_send>
   2d0f6:	200f      	movs	r0, #15
   2d0f8:	4770      	bx	lr
   2d0fa:	2007      	movs	r0, #7
   2d0fc:	4770      	bx	lr
   2d0fe:	bf00      	nop

0002d100 <rpc_dfu_client_message_free>:
   2d100:	b120      	cbz	r0, 2d10c <rpc_dfu_client_message_free+0xc>
   2d102:	f1a0 0108 	sub.w	r1, r0, #8
   2d106:	2006      	movs	r0, #6
   2d108:	f006 b88c 	b.w	33224 <rpc_message_free>
   2d10c:	2007      	movs	r0, #7
   2d10e:	4770      	bx	lr

0002d110 <rpc_dfu_client_data_free>:
   2d110:	b118      	cbz	r0, 2d11a <rpc_dfu_client_data_free+0xa>
   2d112:	4601      	mov	r1, r0
   2d114:	2006      	movs	r0, #6
   2d116:	f006 b997 	b.w	33448 <rpc_message_data_free>
   2d11a:	2007      	movs	r0, #7
   2d11c:	4770      	bx	lr
   2d11e:	bf00      	nop

0002d120 <mem_free>:
   2d120:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2d124:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 2d1f4 <mem_free+0xd4>
   2d128:	b083      	sub	sp, #12
   2d12a:	9000      	str	r0, [sp, #0]
   2d12c:	f10c 0b3c 	add.w	fp, ip, #60	; 0x3c
   2d130:	f8dc 3008 	ldr.w	r3, [ip, #8]
   2d134:	b12b      	cbz	r3, 2d142 <mem_free+0x22>
   2d136:	f8dc 2000 	ldr.w	r2, [ip]
   2d13a:	9c00      	ldr	r4, [sp, #0]
   2d13c:	7810      	ldrb	r0, [r2, #0]
   2d13e:	42a0      	cmp	r0, r4
   2d140:	d006      	beq.n	2d150 <mem_free+0x30>
   2d142:	f10c 0c0c 	add.w	ip, ip, #12
   2d146:	45e3      	cmp	fp, ip
   2d148:	d1f2      	bne.n	2d130 <mem_free+0x10>
   2d14a:	b003      	add	sp, #12
   2d14c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2d150:	f8dc a004 	ldr.w	sl, [ip, #4]
   2d154:	eb03 080a 	add.w	r8, r3, sl
   2d158:	45c2      	cmp	sl, r8
   2d15a:	d2f2      	bcs.n	2d142 <mem_free+0x22>
   2d15c:	6853      	ldr	r3, [r2, #4]
   2d15e:	f8cd c004 	str.w	ip, [sp, #4]
   2d162:	46d6      	mov	lr, sl
   2d164:	469c      	mov	ip, r3
   2d166:	f8d2 9010 	ldr.w	r9, [r2, #16]
   2d16a:	8997      	ldrh	r7, [r2, #12]
   2d16c:	ebae 000a 	sub.w	r0, lr, sl
   2d170:	b3df      	cbz	r7, 2d1ea <mem_free+0xca>
   2d172:	f8b9 2002 	ldrh.w	r2, [r9, #2]
   2d176:	4290      	cmp	r0, r2
   2d178:	d31c      	bcc.n	2d1b4 <mem_free+0x94>
   2d17a:	4665      	mov	r5, ip
   2d17c:	2400      	movs	r4, #0
   2d17e:	f109 0304 	add.w	r3, r9, #4
   2d182:	e003      	b.n	2d18c <mem_free+0x6c>
   2d184:	885a      	ldrh	r2, [r3, #2]
   2d186:	3304      	adds	r3, #4
   2d188:	4282      	cmp	r2, r0
   2d18a:	d815      	bhi.n	2d1b8 <mem_free+0x98>
   2d18c:	f833 6c04 	ldrh.w	r6, [r3, #-4]
   2d190:	3401      	adds	r4, #1
   2d192:	42a7      	cmp	r7, r4
   2d194:	fb02 5506 	mla	r5, r2, r6, r5
   2d198:	eba0 0002 	sub.w	r0, r0, r2
   2d19c:	461e      	mov	r6, r3
   2d19e:	d1f1      	bne.n	2d184 <mem_free+0x64>
   2d1a0:	2000      	movs	r0, #0
   2d1a2:	4281      	cmp	r1, r0
   2d1a4:	d00d      	beq.n	2d1c2 <mem_free+0xa2>
   2d1a6:	f10e 0e01 	add.w	lr, lr, #1
   2d1aa:	45f0      	cmp	r8, lr
   2d1ac:	d1de      	bne.n	2d16c <mem_free+0x4c>
   2d1ae:	f8dd c004 	ldr.w	ip, [sp, #4]
   2d1b2:	e7c6      	b.n	2d142 <mem_free+0x22>
   2d1b4:	4665      	mov	r5, ip
   2d1b6:	464e      	mov	r6, r9
   2d1b8:	8833      	ldrh	r3, [r6, #0]
   2d1ba:	fb00 5003 	mla	r0, r0, r3, r5
   2d1be:	4281      	cmp	r1, r0
   2d1c0:	d1f1      	bne.n	2d1a6 <mem_free+0x86>
   2d1c2:	f5be 7f00 	cmp.w	lr, #512	; 0x200
   2d1c6:	f8dd c004 	ldr.w	ip, [sp, #4]
   2d1ca:	d0ba      	beq.n	2d142 <mem_free+0x22>
   2d1cc:	2301      	movs	r3, #1
   2d1ce:	4a08      	ldr	r2, [pc, #32]	; (2d1f0 <mem_free+0xd0>)
   2d1d0:	ea4f 115e 	mov.w	r1, lr, lsr #5
   2d1d4:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
   2d1d8:	f00e 0e1f 	and.w	lr, lr, #31
   2d1dc:	fa03 fe0e 	lsl.w	lr, r3, lr
   2d1e0:	ea4e 0000 	orr.w	r0, lr, r0
   2d1e4:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
   2d1e8:	e7af      	b.n	2d14a <mem_free+0x2a>
   2d1ea:	4638      	mov	r0, r7
   2d1ec:	e7d9      	b.n	2d1a2 <mem_free+0x82>
   2d1ee:	bf00      	nop
   2d1f0:	20024e48 	.word	0x20024e48
   2d1f4:	20024e8c 	.word	0x20024e8c

0002d1f8 <mem_alloc.constprop.5>:
   2d1f8:	2800      	cmp	r0, #0
   2d1fa:	d050      	beq.n	2d29e <mem_alloc.constprop.5+0xa6>
   2d1fc:	4b6d      	ldr	r3, [pc, #436]	; (2d3b4 <mem_alloc.constprop.5+0x1bc>)
   2d1fe:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   2d202:	4290      	cmp	r0, r2
   2d204:	d84b      	bhi.n	2d29e <mem_alloc.constprop.5+0xa6>
   2d206:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2d20a:	f8d3 b08c 	ldr.w	fp, [r3, #140]	; 0x8c
   2d20e:	b083      	sub	sp, #12
   2d210:	f1bb 0f00 	cmp.w	fp, #0
   2d214:	d054      	beq.n	2d2c0 <mem_alloc.constprop.5+0xc8>
   2d216:	f10b 32ff 	add.w	r2, fp, #4294967295
   2d21a:	4691      	mov	r9, r2
   2d21c:	2600      	movs	r6, #0
   2d21e:	f04f 0812 	mov.w	r8, #18
   2d222:	4f65      	ldr	r7, [pc, #404]	; (2d3b8 <mem_alloc.constprop.5+0x1c0>)
   2d224:	9201      	str	r2, [sp, #4]
   2d226:	f10b 0e11 	add.w	lr, fp, #17
   2d22a:	eb06 0209 	add.w	r2, r6, r9
   2d22e:	f853 4038 	ldr.w	r4, [r3, r8, lsl #3]
   2d232:	3201      	adds	r2, #1
   2d234:	0852      	lsrs	r2, r2, #1
   2d236:	eb04 0c44 	add.w	ip, r4, r4, lsl #1
   2d23a:	f102 0112 	add.w	r1, r2, #18
   2d23e:	f853 5031 	ldr.w	r5, [r3, r1, lsl #3]
   2d242:	f857 a02c 	ldr.w	sl, [r7, ip, lsl #2]
   2d246:	f853 403e 	ldr.w	r4, [r3, lr, lsl #3]
   2d24a:	eb03 0cc8 	add.w	ip, r3, r8, lsl #3
   2d24e:	f8dc c004 	ldr.w	ip, [ip, #4]
   2d252:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   2d256:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   2d25a:	f8da a010 	ldr.w	sl, [sl, #16]
   2d25e:	f857 5025 	ldr.w	r5, [r7, r5, lsl #2]
   2d262:	f857 4024 	ldr.w	r4, [r7, r4, lsl #2]
   2d266:	f83a a02c 	ldrh.w	sl, [sl, ip, lsl #2]
   2d26a:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   2d26e:	eb03 0cce 	add.w	ip, r3, lr, lsl #3
   2d272:	6849      	ldr	r1, [r1, #4]
   2d274:	692d      	ldr	r5, [r5, #16]
   2d276:	6924      	ldr	r4, [r4, #16]
   2d278:	f8dc c004 	ldr.w	ip, [ip, #4]
   2d27c:	4550      	cmp	r0, sl
   2d27e:	f835 5021 	ldrh.w	r5, [r5, r1, lsl #2]
   2d282:	f834 102c 	ldrh.w	r1, [r4, ip, lsl #2]
   2d286:	d915      	bls.n	2d2b4 <mem_alloc.constprop.5+0xbc>
   2d288:	4288      	cmp	r0, r1
   2d28a:	d211      	bcs.n	2d2b0 <mem_alloc.constprop.5+0xb8>
   2d28c:	42a8      	cmp	r0, r5
   2d28e:	d908      	bls.n	2d2a2 <mem_alloc.constprop.5+0xaa>
   2d290:	1c56      	adds	r6, r2, #1
   2d292:	45b1      	cmp	r9, r6
   2d294:	f0c0 8087 	bcc.w	2d3a6 <mem_alloc.constprop.5+0x1ae>
   2d298:	f102 0813 	add.w	r8, r2, #19
   2d29c:	e7c5      	b.n	2d22a <mem_alloc.constprop.5+0x32>
   2d29e:	2000      	movs	r0, #0
   2d2a0:	4770      	bx	lr
   2d2a2:	f102 39ff 	add.w	r9, r2, #4294967295
   2d2a6:	454e      	cmp	r6, r9
   2d2a8:	d87d      	bhi.n	2d3a6 <mem_alloc.constprop.5+0x1ae>
   2d2aa:	f102 0e11 	add.w	lr, r2, #17
   2d2ae:	e7bc      	b.n	2d22a <mem_alloc.constprop.5+0x32>
   2d2b0:	f109 0601 	add.w	r6, r9, #1
   2d2b4:	45b3      	cmp	fp, r6
   2d2b6:	d007      	beq.n	2d2c8 <mem_alloc.constprop.5+0xd0>
   2d2b8:	2e10      	cmp	r6, #16
   2d2ba:	d001      	beq.n	2d2c0 <mem_alloc.constprop.5+0xc8>
   2d2bc:	45b3      	cmp	fp, r6
   2d2be:	d808      	bhi.n	2d2d2 <mem_alloc.constprop.5+0xda>
   2d2c0:	2000      	movs	r0, #0
   2d2c2:	b003      	add	sp, #12
   2d2c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2d2c8:	9a01      	ldr	r2, [sp, #4]
   2d2ca:	2a10      	cmp	r2, #16
   2d2cc:	bf18      	it	ne
   2d2ce:	4616      	movne	r6, r2
   2d2d0:	d0f6      	beq.n	2d2c0 <mem_alloc.constprop.5+0xc8>
   2d2d2:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 2d3bc <mem_alloc.constprop.5+0x1c4>
   2d2d6:	eb03 08c6 	add.w	r8, r3, r6, lsl #3
   2d2da:	e9d8 2424 	ldrd	r2, r4, [r8, #144]	; 0x90
   2d2de:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   2d2e2:	f857 3022 	ldr.w	r3, [r7, r2, lsl #2]
   2d2e6:	eb07 0282 	add.w	r2, r7, r2, lsl #2
   2d2ea:	f8d2 e004 	ldr.w	lr, [r2, #4]
   2d2ee:	691d      	ldr	r5, [r3, #16]
   2d2f0:	2c00      	cmp	r4, #0
   2d2f2:	d056      	beq.n	2d3a2 <mem_alloc.constprop.5+0x1aa>
   2d2f4:	462a      	mov	r2, r5
   2d2f6:	4670      	mov	r0, lr
   2d2f8:	00a4      	lsls	r4, r4, #2
   2d2fa:	eb05 0904 	add.w	r9, r5, r4
   2d2fe:	8851      	ldrh	r1, [r2, #2]
   2d300:	3204      	adds	r2, #4
   2d302:	4591      	cmp	r9, r2
   2d304:	4408      	add	r0, r1
   2d306:	d1fa      	bne.n	2d2fe <mem_alloc.constprop.5+0x106>
   2d308:	1929      	adds	r1, r5, r4
   2d30a:	f8b1 a002 	ldrh.w	sl, [r1, #2]
   2d30e:	4482      	add	sl, r0
   2d310:	4582      	cmp	sl, r0
   2d312:	d918      	bls.n	2d346 <mem_alloc.constprop.5+0x14e>
   2d314:	0941      	lsrs	r1, r0, #5
   2d316:	f85c 2021 	ldr.w	r2, [ip, r1, lsl #2]
   2d31a:	f000 041f 	and.w	r4, r0, #31
   2d31e:	fa22 f904 	lsr.w	r9, r2, r4
   2d322:	f019 0f01 	tst.w	r9, #1
   2d326:	d007      	beq.n	2d338 <mem_alloc.constprop.5+0x140>
   2d328:	e013      	b.n	2d352 <mem_alloc.constprop.5+0x15a>
   2d32a:	f85c 2021 	ldr.w	r2, [ip, r1, lsl #2]
   2d32e:	fa22 f904 	lsr.w	r9, r2, r4
   2d332:	f019 0f01 	tst.w	r9, #1
   2d336:	d10c      	bne.n	2d352 <mem_alloc.constprop.5+0x15a>
   2d338:	3001      	adds	r0, #1
   2d33a:	4582      	cmp	sl, r0
   2d33c:	ea4f 1150 	mov.w	r1, r0, lsr #5
   2d340:	f000 041f 	and.w	r4, r0, #31
   2d344:	d1f1      	bne.n	2d32a <mem_alloc.constprop.5+0x132>
   2d346:	3601      	adds	r6, #1
   2d348:	455e      	cmp	r6, fp
   2d34a:	f108 0808 	add.w	r8, r8, #8
   2d34e:	d3c4      	bcc.n	2d2da <mem_alloc.constprop.5+0xe2>
   2d350:	e7b6      	b.n	2d2c0 <mem_alloc.constprop.5+0xc8>
   2d352:	2601      	movs	r6, #1
   2d354:	fa06 f404 	lsl.w	r4, r6, r4
   2d358:	899e      	ldrh	r6, [r3, #12]
   2d35a:	ea22 0204 	bic.w	r2, r2, r4
   2d35e:	eba0 000e 	sub.w	r0, r0, lr
   2d362:	f84c 2021 	str.w	r2, [ip, r1, lsl #2]
   2d366:	685c      	ldr	r4, [r3, #4]
   2d368:	2e00      	cmp	r6, #0
   2d36a:	d0a9      	beq.n	2d2c0 <mem_alloc.constprop.5+0xc8>
   2d36c:	886a      	ldrh	r2, [r5, #2]
   2d36e:	4282      	cmp	r2, r0
   2d370:	d811      	bhi.n	2d396 <mem_alloc.constprop.5+0x19e>
   2d372:	2100      	movs	r1, #0
   2d374:	1d2b      	adds	r3, r5, #4
   2d376:	e003      	b.n	2d380 <mem_alloc.constprop.5+0x188>
   2d378:	885a      	ldrh	r2, [r3, #2]
   2d37a:	3304      	adds	r3, #4
   2d37c:	4282      	cmp	r2, r0
   2d37e:	d80a      	bhi.n	2d396 <mem_alloc.constprop.5+0x19e>
   2d380:	f833 5c04 	ldrh.w	r5, [r3, #-4]
   2d384:	3101      	adds	r1, #1
   2d386:	428e      	cmp	r6, r1
   2d388:	fb02 4405 	mla	r4, r2, r5, r4
   2d38c:	eba0 0002 	sub.w	r0, r0, r2
   2d390:	461d      	mov	r5, r3
   2d392:	d1f1      	bne.n	2d378 <mem_alloc.constprop.5+0x180>
   2d394:	e794      	b.n	2d2c0 <mem_alloc.constprop.5+0xc8>
   2d396:	882b      	ldrh	r3, [r5, #0]
   2d398:	fb00 4003 	mla	r0, r0, r3, r4
   2d39c:	b003      	add	sp, #12
   2d39e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2d3a2:	4670      	mov	r0, lr
   2d3a4:	e7b0      	b.n	2d308 <mem_alloc.constprop.5+0x110>
   2d3a6:	f1bb 0f10 	cmp.w	fp, #16
   2d3aa:	bf08      	it	eq
   2d3ac:	260f      	moveq	r6, #15
   2d3ae:	d090      	beq.n	2d2d2 <mem_alloc.constprop.5+0xda>
   2d3b0:	e786      	b.n	2d2c0 <mem_alloc.constprop.5+0xc8>
   2d3b2:	bf00      	nop
   2d3b4:	20024ec8 	.word	0x20024ec8
   2d3b8:	20024e8c 	.word	0x20024e8c
   2d3bc:	20024e48 	.word	0x20024e48

0002d3c0 <mem_alloc.constprop.4>:
   2d3c0:	2800      	cmp	r0, #0
   2d3c2:	d04c      	beq.n	2d45e <mem_alloc.constprop.4+0x9e>
   2d3c4:	4b6b      	ldr	r3, [pc, #428]	; (2d574 <mem_alloc.constprop.4+0x1b4>)
   2d3c6:	681a      	ldr	r2, [r3, #0]
   2d3c8:	4290      	cmp	r0, r2
   2d3ca:	d848      	bhi.n	2d45e <mem_alloc.constprop.4+0x9e>
   2d3cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2d3d0:	685f      	ldr	r7, [r3, #4]
   2d3d2:	b083      	sub	sp, #12
   2d3d4:	9700      	str	r7, [sp, #0]
   2d3d6:	2f00      	cmp	r7, #0
   2d3d8:	d051      	beq.n	2d47e <mem_alloc.constprop.4+0xbe>
   2d3da:	1e7a      	subs	r2, r7, #1
   2d3dc:	4696      	mov	lr, r2
   2d3de:	2100      	movs	r1, #0
   2d3e0:	f04f 0c01 	mov.w	ip, #1
   2d3e4:	4c64      	ldr	r4, [pc, #400]	; (2d578 <mem_alloc.constprop.4+0x1b8>)
   2d3e6:	9201      	str	r2, [sp, #4]
   2d3e8:	eb01 020e 	add.w	r2, r1, lr
   2d3ec:	3201      	adds	r2, #1
   2d3ee:	f853 503c 	ldr.w	r5, [r3, ip, lsl #3]
   2d3f2:	0852      	lsrs	r2, r2, #1
   2d3f4:	f102 0801 	add.w	r8, r2, #1
   2d3f8:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   2d3fc:	f853 9037 	ldr.w	r9, [r3, r7, lsl #3]
   2d400:	f854 a025 	ldr.w	sl, [r4, r5, lsl #2]
   2d404:	f853 6038 	ldr.w	r6, [r3, r8, lsl #3]
   2d408:	eb09 0549 	add.w	r5, r9, r9, lsl #1
   2d40c:	eb03 09cc 	add.w	r9, r3, ip, lsl #3
   2d410:	f8d9 9004 	ldr.w	r9, [r9, #4]
   2d414:	eb06 0646 	add.w	r6, r6, r6, lsl #1
   2d418:	f8da a010 	ldr.w	sl, [sl, #16]
   2d41c:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
   2d420:	f854 5025 	ldr.w	r5, [r4, r5, lsl #2]
   2d424:	f83a a029 	ldrh.w	sl, [sl, r9, lsl #2]
   2d428:	eb03 0bc8 	add.w	fp, r3, r8, lsl #3
   2d42c:	eb03 09c7 	add.w	r9, r3, r7, lsl #3
   2d430:	6936      	ldr	r6, [r6, #16]
   2d432:	f8db b004 	ldr.w	fp, [fp, #4]
   2d436:	692d      	ldr	r5, [r5, #16]
   2d438:	f8d9 9004 	ldr.w	r9, [r9, #4]
   2d43c:	4550      	cmp	r0, sl
   2d43e:	f836 602b 	ldrh.w	r6, [r6, fp, lsl #2]
   2d442:	f835 5029 	ldrh.w	r5, [r5, r9, lsl #2]
   2d446:	d913      	bls.n	2d470 <mem_alloc.constprop.4+0xb0>
   2d448:	42a8      	cmp	r0, r5
   2d44a:	d210      	bcs.n	2d46e <mem_alloc.constprop.4+0xae>
   2d44c:	42b0      	cmp	r0, r6
   2d44e:	d908      	bls.n	2d462 <mem_alloc.constprop.4+0xa2>
   2d450:	45c6      	cmp	lr, r8
   2d452:	4641      	mov	r1, r8
   2d454:	f0c0 8087 	bcc.w	2d566 <mem_alloc.constprop.4+0x1a6>
   2d458:	f108 0c01 	add.w	ip, r8, #1
   2d45c:	e7c4      	b.n	2d3e8 <mem_alloc.constprop.4+0x28>
   2d45e:	2000      	movs	r0, #0
   2d460:	4770      	bx	lr
   2d462:	f102 3eff 	add.w	lr, r2, #4294967295
   2d466:	4571      	cmp	r1, lr
   2d468:	d87d      	bhi.n	2d566 <mem_alloc.constprop.4+0x1a6>
   2d46a:	4617      	mov	r7, r2
   2d46c:	e7bc      	b.n	2d3e8 <mem_alloc.constprop.4+0x28>
   2d46e:	4639      	mov	r1, r7
   2d470:	9a00      	ldr	r2, [sp, #0]
   2d472:	428a      	cmp	r2, r1
   2d474:	d007      	beq.n	2d486 <mem_alloc.constprop.4+0xc6>
   2d476:	2910      	cmp	r1, #16
   2d478:	d001      	beq.n	2d47e <mem_alloc.constprop.4+0xbe>
   2d47a:	428a      	cmp	r2, r1
   2d47c:	d808      	bhi.n	2d490 <mem_alloc.constprop.4+0xd0>
   2d47e:	2000      	movs	r0, #0
   2d480:	b003      	add	sp, #12
   2d482:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2d486:	9a01      	ldr	r2, [sp, #4]
   2d488:	2a10      	cmp	r2, #16
   2d48a:	bf18      	it	ne
   2d48c:	4611      	movne	r1, r2
   2d48e:	d0f6      	beq.n	2d47e <mem_alloc.constprop.4+0xbe>
   2d490:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 2d57c <mem_alloc.constprop.4+0x1bc>
   2d494:	f8dd 9000 	ldr.w	r9, [sp]
   2d498:	eb03 08c1 	add.w	r8, r3, r1, lsl #3
   2d49c:	e9d8 2602 	ldrd	r2, r6, [r8, #8]
   2d4a0:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   2d4a4:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
   2d4a8:	eb04 0282 	add.w	r2, r4, r2, lsl #2
   2d4ac:	f8d2 e004 	ldr.w	lr, [r2, #4]
   2d4b0:	691f      	ldr	r7, [r3, #16]
   2d4b2:	2e00      	cmp	r6, #0
   2d4b4:	d055      	beq.n	2d562 <mem_alloc.constprop.4+0x1a2>
   2d4b6:	463a      	mov	r2, r7
   2d4b8:	4670      	mov	r0, lr
   2d4ba:	00b6      	lsls	r6, r6, #2
   2d4bc:	eb07 0a06 	add.w	sl, r7, r6
   2d4c0:	8855      	ldrh	r5, [r2, #2]
   2d4c2:	3204      	adds	r2, #4
   2d4c4:	4592      	cmp	sl, r2
   2d4c6:	4428      	add	r0, r5
   2d4c8:	d1fa      	bne.n	2d4c0 <mem_alloc.constprop.4+0x100>
   2d4ca:	19bd      	adds	r5, r7, r6
   2d4cc:	f8b5 b002 	ldrh.w	fp, [r5, #2]
   2d4d0:	4483      	add	fp, r0
   2d4d2:	4583      	cmp	fp, r0
   2d4d4:	d918      	bls.n	2d508 <mem_alloc.constprop.4+0x148>
   2d4d6:	0945      	lsrs	r5, r0, #5
   2d4d8:	f85c 2025 	ldr.w	r2, [ip, r5, lsl #2]
   2d4dc:	f000 061f 	and.w	r6, r0, #31
   2d4e0:	fa22 fa06 	lsr.w	sl, r2, r6
   2d4e4:	f01a 0f01 	tst.w	sl, #1
   2d4e8:	d007      	beq.n	2d4fa <mem_alloc.constprop.4+0x13a>
   2d4ea:	e013      	b.n	2d514 <mem_alloc.constprop.4+0x154>
   2d4ec:	f85c 2025 	ldr.w	r2, [ip, r5, lsl #2]
   2d4f0:	fa22 fa06 	lsr.w	sl, r2, r6
   2d4f4:	f01a 0f01 	tst.w	sl, #1
   2d4f8:	d10c      	bne.n	2d514 <mem_alloc.constprop.4+0x154>
   2d4fa:	3001      	adds	r0, #1
   2d4fc:	4583      	cmp	fp, r0
   2d4fe:	ea4f 1550 	mov.w	r5, r0, lsr #5
   2d502:	f000 061f 	and.w	r6, r0, #31
   2d506:	d1f1      	bne.n	2d4ec <mem_alloc.constprop.4+0x12c>
   2d508:	3101      	adds	r1, #1
   2d50a:	4549      	cmp	r1, r9
   2d50c:	f108 0808 	add.w	r8, r8, #8
   2d510:	d3c4      	bcc.n	2d49c <mem_alloc.constprop.4+0xdc>
   2d512:	e7b4      	b.n	2d47e <mem_alloc.constprop.4+0xbe>
   2d514:	2101      	movs	r1, #1
   2d516:	40b1      	lsls	r1, r6
   2d518:	899e      	ldrh	r6, [r3, #12]
   2d51a:	ea22 0201 	bic.w	r2, r2, r1
   2d51e:	eba0 000e 	sub.w	r0, r0, lr
   2d522:	f84c 2025 	str.w	r2, [ip, r5, lsl #2]
   2d526:	685c      	ldr	r4, [r3, #4]
   2d528:	2e00      	cmp	r6, #0
   2d52a:	d0a8      	beq.n	2d47e <mem_alloc.constprop.4+0xbe>
   2d52c:	887a      	ldrh	r2, [r7, #2]
   2d52e:	4282      	cmp	r2, r0
   2d530:	d811      	bhi.n	2d556 <mem_alloc.constprop.4+0x196>
   2d532:	2100      	movs	r1, #0
   2d534:	1d3b      	adds	r3, r7, #4
   2d536:	e003      	b.n	2d540 <mem_alloc.constprop.4+0x180>
   2d538:	885a      	ldrh	r2, [r3, #2]
   2d53a:	3304      	adds	r3, #4
   2d53c:	4282      	cmp	r2, r0
   2d53e:	d80a      	bhi.n	2d556 <mem_alloc.constprop.4+0x196>
   2d540:	f833 5c04 	ldrh.w	r5, [r3, #-4]
   2d544:	3101      	adds	r1, #1
   2d546:	428e      	cmp	r6, r1
   2d548:	eba0 0002 	sub.w	r0, r0, r2
   2d54c:	fb02 4405 	mla	r4, r2, r5, r4
   2d550:	461f      	mov	r7, r3
   2d552:	d1f1      	bne.n	2d538 <mem_alloc.constprop.4+0x178>
   2d554:	e793      	b.n	2d47e <mem_alloc.constprop.4+0xbe>
   2d556:	883b      	ldrh	r3, [r7, #0]
   2d558:	fb00 4003 	mla	r0, r0, r3, r4
   2d55c:	b003      	add	sp, #12
   2d55e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2d562:	4670      	mov	r0, lr
   2d564:	e7b1      	b.n	2d4ca <mem_alloc.constprop.4+0x10a>
   2d566:	9a00      	ldr	r2, [sp, #0]
   2d568:	2a10      	cmp	r2, #16
   2d56a:	bf08      	it	eq
   2d56c:	210f      	moveq	r1, #15
   2d56e:	d08f      	beq.n	2d490 <mem_alloc.constprop.4+0xd0>
   2d570:	e785      	b.n	2d47e <mem_alloc.constprop.4+0xbe>
   2d572:	bf00      	nop
   2d574:	20024ec8 	.word	0x20024ec8
   2d578:	20024e8c 	.word	0x20024e8c
   2d57c:	20024e48 	.word	0x20024e48

0002d580 <nrf_mem_init>:
   2d580:	b570      	push	{r4, r5, r6, lr}
   2d582:	2200      	movs	r2, #0
   2d584:	2501      	movs	r5, #1
   2d586:	4833      	ldr	r0, [pc, #204]	; (2d654 <nrf_mem_init+0xd4>)
   2d588:	0951      	lsrs	r1, r2, #5
   2d58a:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
   2d58e:	f002 031f 	and.w	r3, r2, #31
   2d592:	fa05 f303 	lsl.w	r3, r5, r3
   2d596:	3201      	adds	r2, #1
   2d598:	4323      	orrs	r3, r4
   2d59a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   2d59e:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
   2d5a2:	d1f1      	bne.n	2d588 <nrf_mem_init+0x8>
   2d5a4:	2400      	movs	r4, #0
   2d5a6:	4b2c      	ldr	r3, [pc, #176]	; (2d658 <nrf_mem_init+0xd8>)
   2d5a8:	4621      	mov	r1, r4
   2d5aa:	223c      	movs	r2, #60	; 0x3c
   2d5ac:	482b      	ldr	r0, [pc, #172]	; (2d65c <nrf_mem_init+0xdc>)
   2d5ae:	601c      	str	r4, [r3, #0]
   2d5b0:	f011 f96c 	bl	3e88c <memset>
   2d5b4:	2110      	movs	r1, #16
   2d5b6:	2205      	movs	r2, #5
   2d5b8:	4b29      	ldr	r3, [pc, #164]	; (2d660 <nrf_mem_init+0xe0>)
   2d5ba:	4e2a      	ldr	r6, [pc, #168]	; (2d664 <nrf_mem_init+0xe4>)
   2d5bc:	e9c3 4400 	strd	r4, r4, [r3]
   2d5c0:	60d9      	str	r1, [r3, #12]
   2d5c2:	6159      	str	r1, [r3, #20]
   2d5c4:	61d9      	str	r1, [r3, #28]
   2d5c6:	6259      	str	r1, [r3, #36]	; 0x24
   2d5c8:	62d9      	str	r1, [r3, #44]	; 0x2c
   2d5ca:	6359      	str	r1, [r3, #52]	; 0x34
   2d5cc:	63d9      	str	r1, [r3, #60]	; 0x3c
   2d5ce:	6459      	str	r1, [r3, #68]	; 0x44
   2d5d0:	64d9      	str	r1, [r3, #76]	; 0x4c
   2d5d2:	6559      	str	r1, [r3, #84]	; 0x54
   2d5d4:	65d9      	str	r1, [r3, #92]	; 0x5c
   2d5d6:	6659      	str	r1, [r3, #100]	; 0x64
   2d5d8:	66d9      	str	r1, [r3, #108]	; 0x6c
   2d5da:	6759      	str	r1, [r3, #116]	; 0x74
   2d5dc:	67d9      	str	r1, [r3, #124]	; 0x7c
   2d5de:	609a      	str	r2, [r3, #8]
   2d5e0:	611a      	str	r2, [r3, #16]
   2d5e2:	619a      	str	r2, [r3, #24]
   2d5e4:	621a      	str	r2, [r3, #32]
   2d5e6:	629a      	str	r2, [r3, #40]	; 0x28
   2d5e8:	631a      	str	r2, [r3, #48]	; 0x30
   2d5ea:	639a      	str	r2, [r3, #56]	; 0x38
   2d5ec:	641a      	str	r2, [r3, #64]	; 0x40
   2d5ee:	649a      	str	r2, [r3, #72]	; 0x48
   2d5f0:	651a      	str	r2, [r3, #80]	; 0x50
   2d5f2:	659a      	str	r2, [r3, #88]	; 0x58
   2d5f4:	661a      	str	r2, [r3, #96]	; 0x60
   2d5f6:	669a      	str	r2, [r3, #104]	; 0x68
   2d5f8:	671a      	str	r2, [r3, #112]	; 0x70
   2d5fa:	679a      	str	r2, [r3, #120]	; 0x78
   2d5fc:	e9c3 2120 	strd	r2, r1, [r3, #128]	; 0x80
   2d600:	e9c3 4422 	strd	r4, r4, [r3, #136]	; 0x88
   2d604:	e9c3 2124 	strd	r2, r1, [r3, #144]	; 0x90
   2d608:	e9c3 2126 	strd	r2, r1, [r3, #152]	; 0x98
   2d60c:	e9c3 2128 	strd	r2, r1, [r3, #160]	; 0xa0
   2d610:	e9c3 212a 	strd	r2, r1, [r3, #168]	; 0xa8
   2d614:	e9c3 212c 	strd	r2, r1, [r3, #176]	; 0xb0
   2d618:	e9c3 212e 	strd	r2, r1, [r3, #184]	; 0xb8
   2d61c:	e9c3 2130 	strd	r2, r1, [r3, #192]	; 0xc0
   2d620:	e9c3 2132 	strd	r2, r1, [r3, #200]	; 0xc8
   2d624:	e9c3 2134 	strd	r2, r1, [r3, #208]	; 0xd0
   2d628:	e9c3 2136 	strd	r2, r1, [r3, #216]	; 0xd8
   2d62c:	e9c3 2138 	strd	r2, r1, [r3, #224]	; 0xe0
   2d630:	e9c3 213a 	strd	r2, r1, [r3, #232]	; 0xe8
   2d634:	e9c3 213c 	strd	r2, r1, [r3, #240]	; 0xf0
   2d638:	e9c3 213e 	strd	r2, r1, [r3, #248]	; 0xf8
   2d63c:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
   2d640:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   2d644:	f8c3 110c 	str.w	r1, [r3, #268]	; 0x10c
   2d648:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   2d64c:	4620      	mov	r0, r4
   2d64e:	7035      	strb	r5, [r6, #0]
   2d650:	bd70      	pop	{r4, r5, r6, pc}
   2d652:	bf00      	nop
   2d654:	20024e48 	.word	0x20024e48
   2d658:	20024e88 	.word	0x20024e88
   2d65c:	20024e8c 	.word	0x20024e8c
   2d660:	20024ec8 	.word	0x20024ec8
   2d664:	2002d7ed 	.word	0x2002d7ed

0002d668 <nrf_mem_register>:
   2d668:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2d66c:	4b87      	ldr	r3, [pc, #540]	; (2d88c <nrf_mem_register+0x224>)
   2d66e:	b087      	sub	sp, #28
   2d670:	781b      	ldrb	r3, [r3, #0]
   2d672:	2b00      	cmp	r3, #0
   2d674:	f000 808c 	beq.w	2d790 <nrf_mem_register+0x128>
   2d678:	b328      	cbz	r0, 2d6c6 <nrf_mem_register+0x5e>
   2d67a:	b321      	cbz	r1, 2d6c6 <nrf_mem_register+0x5e>
   2d67c:	780b      	ldrb	r3, [r1, #0]
   2d67e:	f8df 8218 	ldr.w	r8, [pc, #536]	; 2d898 <nrf_mem_register+0x230>
   2d682:	eb03 1303 	add.w	r3, r3, r3, lsl #4
   2d686:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
   2d68a:	685b      	ldr	r3, [r3, #4]
   2d68c:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
   2d690:	4463      	add	r3, ip
   2d692:	2b10      	cmp	r3, #16
   2d694:	d811      	bhi.n	2d6ba <nrf_mem_register+0x52>
   2d696:	f04f 0a00 	mov.w	sl, #0
   2d69a:	4689      	mov	r9, r1
   2d69c:	4b7c      	ldr	r3, [pc, #496]	; (2d890 <nrf_mem_register+0x228>)
   2d69e:	4f7d      	ldr	r7, [pc, #500]	; (2d894 <nrf_mem_register+0x22c>)
   2d6a0:	681b      	ldr	r3, [r3, #0]
   2d6a2:	ea4f 0e8c 	mov.w	lr, ip, lsl #2
   2d6a6:	9300      	str	r3, [sp, #0]
   2d6a8:	68b9      	ldr	r1, [r7, #8]
   2d6aa:	b191      	cbz	r1, 2d6d2 <nrf_mem_register+0x6a>
   2d6ac:	f10a 0a01 	add.w	sl, sl, #1
   2d6b0:	f1ba 0f05 	cmp.w	sl, #5
   2d6b4:	f107 070c 	add.w	r7, r7, #12
   2d6b8:	d1f6      	bne.n	2d6a8 <nrf_mem_register+0x40>
   2d6ba:	f248 1b07 	movw	fp, #33031	; 0x8107
   2d6be:	4658      	mov	r0, fp
   2d6c0:	b007      	add	sp, #28
   2d6c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2d6c6:	f248 1b0e 	movw	fp, #33038	; 0x810e
   2d6ca:	4658      	mov	r0, fp
   2d6cc:	b007      	add	sp, #28
   2d6ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2d6d2:	f1bc 0f00 	cmp.w	ip, #0
   2d6d6:	d061      	beq.n	2d79c <nrf_mem_register+0x134>
   2d6d8:	460d      	mov	r5, r1
   2d6da:	460c      	mov	r4, r1
   2d6dc:	f8d9 3010 	ldr.w	r3, [r9, #16]
   2d6e0:	eb0e 0b03 	add.w	fp, lr, r3
   2d6e4:	885a      	ldrh	r2, [r3, #2]
   2d6e6:	f833 6b04 	ldrh.w	r6, [r3], #4
   2d6ea:	4415      	add	r5, r2
   2d6ec:	459b      	cmp	fp, r3
   2d6ee:	fb02 4406 	mla	r4, r2, r6, r4
   2d6f2:	d1f7      	bne.n	2d6e4 <nrf_mem_register+0x7c>
   2d6f4:	f8d9 3008 	ldr.w	r3, [r9, #8]
   2d6f8:	42a3      	cmp	r3, r4
   2d6fa:	d3d7      	bcc.n	2d6ac <nrf_mem_register+0x44>
   2d6fc:	9b00      	ldr	r3, [sp, #0]
   2d6fe:	442b      	add	r3, r5
   2d700:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   2d704:	d2d2      	bcs.n	2d6ac <nrf_mem_register+0x44>
   2d706:	4c63      	ldr	r4, [pc, #396]	; (2d894 <nrf_mem_register+0x22c>)
   2d708:	eb0a 024a 	add.w	r2, sl, sl, lsl #1
   2d70c:	0092      	lsls	r2, r2, #2
   2d70e:	f8c0 a000 	str.w	sl, [r0]
   2d712:	18a0      	adds	r0, r4, r2
   2d714:	f844 9002 	str.w	r9, [r4, r2]
   2d718:	9a00      	ldr	r2, [sp, #0]
   2d71a:	468b      	mov	fp, r1
   2d71c:	e9c0 2501 	strd	r2, r5, [r0, #4]
   2d720:	f899 2001 	ldrb.w	r2, [r9, #1]
   2d724:	485a      	ldr	r0, [pc, #360]	; (2d890 <nrf_mem_register+0x228>)
   2d726:	2a01      	cmp	r2, #1
   2d728:	6003      	str	r3, [r0, #0]
   2d72a:	d0c8      	beq.n	2d6be <nrf_mem_register+0x56>
   2d72c:	f8b9 300c 	ldrh.w	r3, [r9, #12]
   2d730:	2b00      	cmp	r3, #0
   2d732:	d0c4      	beq.n	2d6be <nrf_mem_register+0x56>
   2d734:	2500      	movs	r5, #0
   2d736:	f8cd 9004 	str.w	r9, [sp, #4]
   2d73a:	f8cd a00c 	str.w	sl, [sp, #12]
   2d73e:	f8cd b014 	str.w	fp, [sp, #20]
   2d742:	9b01      	ldr	r3, [sp, #4]
   2d744:	781f      	ldrb	r7, [r3, #0]
   2d746:	691a      	ldr	r2, [r3, #16]
   2d748:	013b      	lsls	r3, r7, #4
   2d74a:	eb03 0907 	add.w	r9, r3, r7
   2d74e:	9300      	str	r3, [sp, #0]
   2d750:	eb08 03c9 	add.w	r3, r8, r9, lsl #3
   2d754:	6859      	ldr	r1, [r3, #4]
   2d756:	f832 4025 	ldrh.w	r4, [r2, r5, lsl #2]
   2d75a:	9102      	str	r1, [sp, #8]
   2d75c:	bb39      	cbnz	r1, 2d7ae <nrf_mem_register+0x146>
   2d75e:	9a03      	ldr	r2, [sp, #12]
   2d760:	60dd      	str	r5, [r3, #12]
   2d762:	609a      	str	r2, [r3, #8]
   2d764:	9b00      	ldr	r3, [sp, #0]
   2d766:	443b      	add	r3, r7
   2d768:	461f      	mov	r7, r3
   2d76a:	eb08 01c3 	add.w	r1, r8, r3, lsl #3
   2d76e:	684b      	ldr	r3, [r1, #4]
   2d770:	f858 2037 	ldr.w	r2, [r8, r7, lsl #3]
   2d774:	3301      	adds	r3, #1
   2d776:	4294      	cmp	r4, r2
   2d778:	604b      	str	r3, [r1, #4]
   2d77a:	d912      	bls.n	2d7a2 <nrf_mem_register+0x13a>
   2d77c:	9b01      	ldr	r3, [sp, #4]
   2d77e:	f848 4037 	str.w	r4, [r8, r7, lsl #3]
   2d782:	899b      	ldrh	r3, [r3, #12]
   2d784:	3501      	adds	r5, #1
   2d786:	429d      	cmp	r5, r3
   2d788:	d3db      	bcc.n	2d742 <nrf_mem_register+0xda>
   2d78a:	f8dd b014 	ldr.w	fp, [sp, #20]
   2d78e:	e796      	b.n	2d6be <nrf_mem_register+0x56>
   2d790:	f248 1b08 	movw	fp, #33032	; 0x8108
   2d794:	4658      	mov	r0, fp
   2d796:	b007      	add	sp, #28
   2d798:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2d79c:	9b00      	ldr	r3, [sp, #0]
   2d79e:	4665      	mov	r5, ip
   2d7a0:	e7ae      	b.n	2d700 <nrf_mem_register+0x98>
   2d7a2:	9b01      	ldr	r3, [sp, #4]
   2d7a4:	3501      	adds	r5, #1
   2d7a6:	899b      	ldrh	r3, [r3, #12]
   2d7a8:	42ab      	cmp	r3, r5
   2d7aa:	d8ca      	bhi.n	2d742 <nrf_mem_register+0xda>
   2d7ac:	e7ed      	b.n	2d78a <nrf_mem_register+0x122>
   2d7ae:	2600      	movs	r6, #0
   2d7b0:	f101 3aff 	add.w	sl, r1, #4294967295
   2d7b4:	9504      	str	r5, [sp, #16]
   2d7b6:	eb06 000a 	add.w	r0, r6, sl
   2d7ba:	eb09 0206 	add.w	r2, r9, r6
   2d7be:	3201      	adds	r2, #1
   2d7c0:	3001      	adds	r0, #1
   2d7c2:	f858 c032 	ldr.w	ip, [r8, r2, lsl #3]
   2d7c6:	0840      	lsrs	r0, r0, #1
   2d7c8:	4d32      	ldr	r5, [pc, #200]	; (2d894 <nrf_mem_register+0x22c>)
   2d7ca:	eb09 0100 	add.w	r1, r9, r0
   2d7ce:	eb09 030a 	add.w	r3, r9, sl
   2d7d2:	3101      	adds	r1, #1
   2d7d4:	3301      	adds	r3, #1
   2d7d6:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
   2d7da:	f858 e031 	ldr.w	lr, [r8, r1, lsl #3]
   2d7de:	f855 b02c 	ldr.w	fp, [r5, ip, lsl #2]
   2d7e2:	f858 c033 	ldr.w	ip, [r8, r3, lsl #3]
   2d7e6:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
   2d7ea:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
   2d7ee:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
   2d7f2:	f8db b010 	ldr.w	fp, [fp, #16]
   2d7f6:	6852      	ldr	r2, [r2, #4]
   2d7f8:	f855 e02e 	ldr.w	lr, [r5, lr, lsl #2]
   2d7fc:	f855 c02c 	ldr.w	ip, [r5, ip, lsl #2]
   2d800:	eb08 01c1 	add.w	r1, r8, r1, lsl #3
   2d804:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
   2d808:	f83b 2022 	ldrh.w	r2, [fp, r2, lsl #2]
   2d80c:	f8de e010 	ldr.w	lr, [lr, #16]
   2d810:	6849      	ldr	r1, [r1, #4]
   2d812:	f8dc c010 	ldr.w	ip, [ip, #16]
   2d816:	685b      	ldr	r3, [r3, #4]
   2d818:	4294      	cmp	r4, r2
   2d81a:	f83e 1021 	ldrh.w	r1, [lr, r1, lsl #2]
   2d81e:	f83c 3023 	ldrh.w	r3, [ip, r3, lsl #2]
   2d822:	d92d      	bls.n	2d880 <nrf_mem_register+0x218>
   2d824:	429c      	cmp	r4, r3
   2d826:	d22d      	bcs.n	2d884 <nrf_mem_register+0x21c>
   2d828:	428c      	cmp	r4, r1
   2d82a:	d924      	bls.n	2d876 <nrf_mem_register+0x20e>
   2d82c:	1c46      	adds	r6, r0, #1
   2d82e:	45b2      	cmp	sl, r6
   2d830:	d2c1      	bcs.n	2d7b6 <nrf_mem_register+0x14e>
   2d832:	2610      	movs	r6, #16
   2d834:	9d04      	ldr	r5, [sp, #16]
   2d836:	9a02      	ldr	r2, [sp, #8]
   2d838:	42b2      	cmp	r2, r6
   2d83a:	d911      	bls.n	2d860 <nrf_mem_register+0x1f8>
   2d83c:	9b00      	ldr	r3, [sp, #0]
   2d83e:	443b      	add	r3, r7
   2d840:	441a      	add	r2, r3
   2d842:	4433      	add	r3, r6
   2d844:	eb08 0ac2 	add.w	sl, r8, r2, lsl #3
   2d848:	eb08 09c3 	add.w	r9, r8, r3, lsl #3
   2d84c:	2208      	movs	r2, #8
   2d84e:	4651      	mov	r1, sl
   2d850:	eb0a 0002 	add.w	r0, sl, r2
   2d854:	f1aa 0a08 	sub.w	sl, sl, #8
   2d858:	f010 fff8 	bl	3e84c <memcpy>
   2d85c:	45d1      	cmp	r9, sl
   2d85e:	d1f5      	bne.n	2d84c <nrf_mem_register+0x1e4>
   2d860:	9b00      	ldr	r3, [sp, #0]
   2d862:	9903      	ldr	r1, [sp, #12]
   2d864:	443b      	add	r3, r7
   2d866:	4433      	add	r3, r6
   2d868:	3301      	adds	r3, #1
   2d86a:	eb08 02c3 	add.w	r2, r8, r3, lsl #3
   2d86e:	f848 1033 	str.w	r1, [r8, r3, lsl #3]
   2d872:	6055      	str	r5, [r2, #4]
   2d874:	e776      	b.n	2d764 <nrf_mem_register+0xfc>
   2d876:	f100 3aff 	add.w	sl, r0, #4294967295
   2d87a:	4556      	cmp	r6, sl
   2d87c:	d99b      	bls.n	2d7b6 <nrf_mem_register+0x14e>
   2d87e:	e7d8      	b.n	2d832 <nrf_mem_register+0x1ca>
   2d880:	9d04      	ldr	r5, [sp, #16]
   2d882:	e7d8      	b.n	2d836 <nrf_mem_register+0x1ce>
   2d884:	9d04      	ldr	r5, [sp, #16]
   2d886:	f10a 0601 	add.w	r6, sl, #1
   2d88a:	e7d4      	b.n	2d836 <nrf_mem_register+0x1ce>
   2d88c:	2002d7ed 	.word	0x2002d7ed
   2d890:	20024e88 	.word	0x20024e88
   2d894:	20024e8c 	.word	0x20024e8c
   2d898:	20024ec8 	.word	0x20024ec8

0002d89c <nrf_malloc>:
   2d89c:	4b03      	ldr	r3, [pc, #12]	; (2d8ac <nrf_malloc+0x10>)
   2d89e:	781b      	ldrb	r3, [r3, #0]
   2d8a0:	b10b      	cbz	r3, 2d8a6 <nrf_malloc+0xa>
   2d8a2:	f7ff bd8d 	b.w	2d3c0 <mem_alloc.constprop.4>
   2d8a6:	4618      	mov	r0, r3
   2d8a8:	4770      	bx	lr
   2d8aa:	bf00      	nop
   2d8ac:	2002d7ed 	.word	0x2002d7ed

0002d8b0 <nrf_free>:
   2d8b0:	4b04      	ldr	r3, [pc, #16]	; (2d8c4 <nrf_free+0x14>)
   2d8b2:	781b      	ldrb	r3, [r3, #0]
   2d8b4:	b123      	cbz	r3, 2d8c0 <nrf_free+0x10>
   2d8b6:	b118      	cbz	r0, 2d8c0 <nrf_free+0x10>
   2d8b8:	4601      	mov	r1, r0
   2d8ba:	2000      	movs	r0, #0
   2d8bc:	f7ff bc30 	b.w	2d120 <mem_free>
   2d8c0:	4770      	bx	lr
   2d8c2:	bf00      	nop
   2d8c4:	2002d7ed 	.word	0x2002d7ed

0002d8c8 <nrf_shared_malloc>:
   2d8c8:	4b03      	ldr	r3, [pc, #12]	; (2d8d8 <nrf_shared_malloc+0x10>)
   2d8ca:	781b      	ldrb	r3, [r3, #0]
   2d8cc:	b10b      	cbz	r3, 2d8d2 <nrf_shared_malloc+0xa>
   2d8ce:	f7ff bc93 	b.w	2d1f8 <mem_alloc.constprop.5>
   2d8d2:	4618      	mov	r0, r3
   2d8d4:	4770      	bx	lr
   2d8d6:	bf00      	nop
   2d8d8:	2002d7ed 	.word	0x2002d7ed

0002d8dc <nrf_shared_free>:
   2d8dc:	4b04      	ldr	r3, [pc, #16]	; (2d8f0 <nrf_shared_free+0x14>)
   2d8de:	781b      	ldrb	r3, [r3, #0]
   2d8e0:	b123      	cbz	r3, 2d8ec <nrf_shared_free+0x10>
   2d8e2:	b118      	cbz	r0, 2d8ec <nrf_shared_free+0x10>
   2d8e4:	4601      	mov	r1, r0
   2d8e6:	2001      	movs	r0, #1
   2d8e8:	f7ff bc1a 	b.w	2d120 <mem_free>
   2d8ec:	4770      	bx	lr
   2d8ee:	bf00      	nop
   2d8f0:	2002d7ed 	.word	0x2002d7ed

0002d8f4 <ip_client_event_handler>:
   2d8f4:	f850 1b08 	ldr.w	r1, [r0], #8
   2d8f8:	0c09      	lsrs	r1, r1, #16
   2d8fa:	f004 bd35 	b.w	32368 <rpc_ip_event_handler>
   2d8fe:	bf00      	nop

0002d900 <rpc_ip_client_init>:
   2d900:	4801      	ldr	r0, [pc, #4]	; (2d908 <rpc_ip_client_init+0x8>)
   2d902:	f005 ba25 	b.w	32d50 <rpc_client_register>
   2d906:	bf00      	nop
   2d908:	00040050 	.word	0x00040050

0002d90c <rpc_ip_client_request_alloc>:
   2d90c:	2300      	movs	r3, #0
   2d90e:	b510      	push	{r4, lr}
   2d910:	b082      	sub	sp, #8
   2d912:	9301      	str	r3, [sp, #4]
   2d914:	b158      	cbz	r0, 2d92e <rpc_ip_client_request_alloc+0x22>
   2d916:	4604      	mov	r4, r0
   2d918:	aa01      	add	r2, sp, #4
   2d91a:	2004      	movs	r0, #4
   2d91c:	f005 fc50 	bl	331c0 <rpc_message_alloc>
   2d920:	b918      	cbnz	r0, 2d92a <rpc_ip_client_request_alloc+0x1e>
   2d922:	9b01      	ldr	r3, [sp, #4]
   2d924:	b10b      	cbz	r3, 2d92a <rpc_ip_client_request_alloc+0x1e>
   2d926:	3308      	adds	r3, #8
   2d928:	6023      	str	r3, [r4, #0]
   2d92a:	b002      	add	sp, #8
   2d92c:	bd10      	pop	{r4, pc}
   2d92e:	2007      	movs	r0, #7
   2d930:	b002      	add	sp, #8
   2d932:	bd10      	pop	{r4, pc}

0002d934 <rpc_ip_client_request_send>:
   2d934:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   2d938:	f5b3 4fe0 	cmp.w	r3, #28672	; 0x7000
   2d93c:	d10b      	bne.n	2d956 <rpc_ip_client_request_send+0x22>
   2d93e:	b160      	cbz	r0, 2d95a <rpc_ip_client_request_send+0x26>
   2d940:	4603      	mov	r3, r0
   2d942:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   2d946:	2004      	movs	r0, #4
   2d948:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   2d94c:	f843 1d08 	str.w	r1, [r3, #-8]!
   2d950:	4619      	mov	r1, r3
   2d952:	f005 bc1d 	b.w	33190 <rpc_message_send>
   2d956:	200f      	movs	r0, #15
   2d958:	4770      	bx	lr
   2d95a:	2007      	movs	r0, #7
   2d95c:	4770      	bx	lr
   2d95e:	bf00      	nop

0002d960 <rpc_ip_client_message_free>:
   2d960:	b120      	cbz	r0, 2d96c <rpc_ip_client_message_free+0xc>
   2d962:	f1a0 0108 	sub.w	r1, r0, #8
   2d966:	2004      	movs	r0, #4
   2d968:	f005 bc5c 	b.w	33224 <rpc_message_free>
   2d96c:	2007      	movs	r0, #7
   2d96e:	4770      	bx	lr

0002d970 <rpc_ip_client_data_free>:
   2d970:	b118      	cbz	r0, 2d97a <rpc_ip_client_data_free+0xa>
   2d972:	4601      	mov	r1, r0
   2d974:	2004      	movs	r0, #4
   2d976:	f005 bd67 	b.w	33448 <rpc_message_data_free>
   2d97a:	2007      	movs	r0, #7
   2d97c:	4770      	bx	lr
   2d97e:	bf00      	nop

0002d980 <secure_client_socket>:
   2d980:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2d984:	460c      	mov	r4, r1
   2d986:	680b      	ldr	r3, [r1, #0]
   2d988:	4f46      	ldr	r7, [pc, #280]	; (2daa4 <secure_client_socket+0x124>)
   2d98a:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   2d98e:	600b      	str	r3, [r1, #0]
   2d990:	680b      	ldr	r3, [r1, #0]
   2d992:	00c6      	lsls	r6, r0, #3
   2d994:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   2d998:	600b      	str	r3, [r1, #0]
   2d99a:	eb07 0a06 	add.w	sl, r7, r6
   2d99e:	b082      	sub	sp, #8
   2d9a0:	f8da 3004 	ldr.w	r3, [sl, #4]
   2d9a4:	6989      	ldr	r1, [r1, #24]
   2d9a6:	f247 0281 	movw	r2, #28801	; 0x7081
   2d9aa:	4605      	mov	r5, r0
   2d9ac:	f8d4 8000 	ldr.w	r8, [r4]
   2d9b0:	f003 fbd2 	bl	31158 <ip_interface_request_create>
   2d9b4:	2800      	cmp	r0, #0
   2d9b6:	d06f      	beq.n	2da98 <secure_client_socket+0x118>
   2d9b8:	f8da 2004 	ldr.w	r2, [sl, #4]
   2d9bc:	4681      	mov	r9, r0
   2d9be:	2a00      	cmp	r2, #0
   2d9c0:	d15f      	bne.n	2da82 <secure_client_socket+0x102>
   2d9c2:	4b39      	ldr	r3, [pc, #228]	; (2daa8 <secure_client_socket+0x128>)
   2d9c4:	1971      	adds	r1, r6, r5
   2d9c6:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   2d9ca:	2224      	movs	r2, #36	; 0x24
   2d9cc:	f109 0014 	add.w	r0, r9, #20
   2d9d0:	f010 ff3c 	bl	3e84c <memcpy>
   2d9d4:	f8d9 3008 	ldr.w	r3, [r9, #8]
   2d9d8:	4649      	mov	r1, r9
   2d9da:	3324      	adds	r3, #36	; 0x24
   2d9dc:	f8c9 3008 	str.w	r3, [r9, #8]
   2d9e0:	6822      	ldr	r2, [r4, #0]
   2d9e2:	4643      	mov	r3, r8
   2d9e4:	0c12      	lsrs	r2, r2, #16
   2d9e6:	0412      	lsls	r2, r2, #16
   2d9e8:	f042 020a 	orr.w	r2, r2, #10
   2d9ec:	6022      	str	r2, [r4, #0]
   2d9ee:	4620      	mov	r0, r4
   2d9f0:	f247 0281 	movw	r2, #28801	; 0x7081
   2d9f4:	f003 fbd0 	bl	31198 <ip_interface_request_send>
   2d9f8:	4603      	mov	r3, r0
   2d9fa:	b970      	cbnz	r0, 2da1a <secure_client_socket+0x9a>
   2d9fc:	6823      	ldr	r3, [r4, #0]
   2d9fe:	00db      	lsls	r3, r3, #3
   2da00:	d40f      	bmi.n	2da22 <secure_client_socket+0xa2>
   2da02:	f04f 33ff 	mov.w	r3, #4294967295
   2da06:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2da0a:	210b      	movs	r1, #11
   2da0c:	4628      	mov	r0, r5
   2da0e:	f003 fbd7 	bl	311c0 <ip_interface_wait>
   2da12:	4603      	mov	r3, r0
   2da14:	b150      	cbz	r0, 2da2c <secure_client_socket+0xac>
   2da16:	f8c4 8000 	str.w	r8, [r4]
   2da1a:	4618      	mov	r0, r3
   2da1c:	b002      	add	sp, #8
   2da1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2da22:	2373      	movs	r3, #115	; 0x73
   2da24:	4618      	mov	r0, r3
   2da26:	b002      	add	sp, #8
   2da28:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2da2c:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
   2da30:	f04f 33ff 	mov.w	r3, #4294967295
   2da34:	4611      	mov	r1, r2
   2da36:	4628      	mov	r0, r5
   2da38:	f003 fbc2 	bl	311c0 <ip_interface_wait>
   2da3c:	4603      	mov	r3, r0
   2da3e:	bb30      	cbnz	r0, 2da8e <secure_client_socket+0x10e>
   2da40:	f857 0035 	ldr.w	r0, [r7, r5, lsl #3]
   2da44:	b138      	cbz	r0, 2da56 <secure_client_socket+0xd6>
   2da46:	9301      	str	r3, [sp, #4]
   2da48:	f7ff ff32 	bl	2d8b0 <nrf_free>
   2da4c:	9b01      	ldr	r3, [sp, #4]
   2da4e:	443e      	add	r6, r7
   2da50:	6073      	str	r3, [r6, #4]
   2da52:	f847 3035 	str.w	r3, [r7, r5, lsl #3]
   2da56:	4618      	mov	r0, r3
   2da58:	6822      	ldr	r2, [r4, #0]
   2da5a:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
   2da5e:	6022      	str	r2, [r4, #0]
   2da60:	6822      	ldr	r2, [r4, #0]
   2da62:	0c12      	lsrs	r2, r2, #16
   2da64:	0412      	lsls	r2, r2, #16
   2da66:	f042 020c 	orr.w	r2, r2, #12
   2da6a:	6022      	str	r2, [r4, #0]
   2da6c:	6822      	ldr	r2, [r4, #0]
   2da6e:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   2da72:	6022      	str	r2, [r4, #0]
   2da74:	6822      	ldr	r2, [r4, #0]
   2da76:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
   2da7a:	6022      	str	r2, [r4, #0]
   2da7c:	b002      	add	sp, #8
   2da7e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2da82:	f857 1035 	ldr.w	r1, [r7, r5, lsl #3]
   2da86:	6800      	ldr	r0, [r0, #0]
   2da88:	f010 fee0 	bl	3e84c <memcpy>
   2da8c:	e799      	b.n	2d9c2 <secure_client_socket+0x42>
   2da8e:	2b73      	cmp	r3, #115	; 0x73
   2da90:	d0c3      	beq.n	2da1a <secure_client_socket+0x9a>
   2da92:	f8c4 8000 	str.w	r8, [r4]
   2da96:	e7c0      	b.n	2da1a <secure_client_socket+0x9a>
   2da98:	230c      	movs	r3, #12
   2da9a:	4618      	mov	r0, r3
   2da9c:	b002      	add	sp, #8
   2da9e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2daa2:	bf00      	nop
   2daa4:	2002511c 	.word	0x2002511c
   2daa8:	20024fd8 	.word	0x20024fd8

0002daac <tls_interface_init>:
   2daac:	2000      	movs	r0, #0
   2daae:	4770      	bx	lr

0002dab0 <tls_interface_open>:
   2dab0:	b538      	push	{r3, r4, r5, lr}
   2dab2:	1e4b      	subs	r3, r1, #1
   2dab4:	2b01      	cmp	r3, #1
   2dab6:	d808      	bhi.n	2daca <tls_interface_open+0x1a>
   2dab8:	4614      	mov	r4, r2
   2daba:	b162      	cbz	r2, 2dad6 <tls_interface_open+0x26>
   2dabc:	2901      	cmp	r1, #1
   2dabe:	d02d      	beq.n	2db1c <tls_interface_open+0x6c>
   2dac0:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   2dac4:	bf08      	it	eq
   2dac6:	2202      	moveq	r2, #2
   2dac8:	d00d      	beq.n	2dae6 <tls_interface_open+0x36>
   2daca:	2029      	movs	r0, #41	; 0x29
   2dacc:	f7fd f87a 	bl	2abc4 <bsd_os_errno_set>
   2dad0:	f04f 35ff 	mov.w	r5, #4294967295
   2dad4:	e020      	b.n	2db18 <tls_interface_open+0x68>
   2dad6:	2901      	cmp	r1, #1
   2dad8:	bf0b      	itete	eq
   2dada:	2201      	moveq	r2, #1
   2dadc:	2202      	movne	r2, #2
   2dade:	f44f 7482 	moveq.w	r4, #260	; 0x104
   2dae2:	f44f 7487 	movne.w	r4, #270	; 0x10e
   2dae6:	f003 fb97 	bl	31218 <ip_interface_open>
   2daea:	1e05      	subs	r5, r0, #0
   2daec:	db1b      	blt.n	2db26 <tls_interface_open+0x76>
   2daee:	4b0f      	ldr	r3, [pc, #60]	; (2db2c <tls_interface_open+0x7c>)
   2daf0:	eb05 00c5 	add.w	r0, r5, r5, lsl #3
   2daf4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   2daf8:	2224      	movs	r2, #36	; 0x24
   2dafa:	490d      	ldr	r1, [pc, #52]	; (2db30 <tls_interface_open+0x80>)
   2dafc:	f010 fea6 	bl	3e84c <memcpy>
   2db00:	4628      	mov	r0, r5
   2db02:	f004 ffe9 	bl	32ad8 <interface_socket_from_handle_get>
   2db06:	6803      	ldr	r3, [r0, #0]
   2db08:	6144      	str	r4, [r0, #20]
   2db0a:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   2db0e:	6003      	str	r3, [r0, #0]
   2db10:	6803      	ldr	r3, [r0, #0]
   2db12:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   2db16:	6003      	str	r3, [r0, #0]
   2db18:	4628      	mov	r0, r5
   2db1a:	bd38      	pop	{r3, r4, r5, pc}
   2db1c:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   2db20:	d1d3      	bne.n	2daca <tls_interface_open+0x1a>
   2db22:	460a      	mov	r2, r1
   2db24:	e7df      	b.n	2dae6 <tls_interface_open+0x36>
   2db26:	f04f 35ff 	mov.w	r5, #4294967295
   2db2a:	e7f5      	b.n	2db18 <tls_interface_open+0x68>
   2db2c:	20024fd8 	.word	0x20024fd8
   2db30:	00040060 	.word	0x00040060

0002db34 <tls_interface_close>:
   2db34:	b538      	push	{r3, r4, r5, lr}
   2db36:	4604      	mov	r4, r0
   2db38:	f004 ffce 	bl	32ad8 <interface_socket_from_handle_get>
   2db3c:	b180      	cbz	r0, 2db60 <tls_interface_close+0x2c>
   2db3e:	4d0b      	ldr	r5, [pc, #44]	; (2db6c <tls_interface_close+0x38>)
   2db40:	f855 0034 	ldr.w	r0, [r5, r4, lsl #3]
   2db44:	b138      	cbz	r0, 2db56 <tls_interface_close+0x22>
   2db46:	f7ff feb3 	bl	2d8b0 <nrf_free>
   2db4a:	2300      	movs	r3, #0
   2db4c:	eb05 02c4 	add.w	r2, r5, r4, lsl #3
   2db50:	f845 3034 	str.w	r3, [r5, r4, lsl #3]
   2db54:	6053      	str	r3, [r2, #4]
   2db56:	4620      	mov	r0, r4
   2db58:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2db5c:	f003 bc0e 	b.w	3137c <ip_interface_close>
   2db60:	2009      	movs	r0, #9
   2db62:	f7fd f82f 	bl	2abc4 <bsd_os_errno_set>
   2db66:	f04f 30ff 	mov.w	r0, #4294967295
   2db6a:	bd38      	pop	{r3, r4, r5, pc}
   2db6c:	2002511c 	.word	0x2002511c

0002db70 <tls_interface_sendto>:
   2db70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2db74:	460d      	mov	r5, r1
   2db76:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   2db7a:	4616      	mov	r6, r2
   2db7c:	461f      	mov	r7, r3
   2db7e:	4604      	mov	r4, r0
   2db80:	f004 ffaa 	bl	32ad8 <interface_socket_from_handle_get>
   2db84:	2800      	cmp	r0, #0
   2db86:	d03b      	beq.n	2dc00 <tls_interface_sendto+0x90>
   2db88:	6803      	ldr	r3, [r0, #0]
   2db8a:	b29b      	uxth	r3, r3
   2db8c:	2b0c      	cmp	r3, #12
   2db8e:	d039      	beq.n	2dc04 <tls_interface_sendto+0x94>
   2db90:	6803      	ldr	r3, [r0, #0]
   2db92:	b29b      	uxth	r3, r3
   2db94:	2b0b      	cmp	r3, #11
   2db96:	d111      	bne.n	2dbbc <tls_interface_sendto+0x4c>
   2db98:	4b20      	ldr	r3, [pc, #128]	; (2dc1c <tls_interface_sendto+0xac>)
   2db9a:	eb04 04c4 	add.w	r4, r4, r4, lsl #3
   2db9e:	f813 3024 	ldrb.w	r3, [r3, r4, lsl #2]
   2dba2:	2b02      	cmp	r3, #2
   2dba4:	d038      	beq.n	2dc18 <tls_interface_sendto+0xa8>
   2dba6:	6903      	ldr	r3, [r0, #16]
   2dba8:	2b01      	cmp	r3, #1
   2dbaa:	bf14      	ite	ne
   2dbac:	2039      	movne	r0, #57	; 0x39
   2dbae:	202a      	moveq	r0, #42	; 0x2a
   2dbb0:	f7fd f808 	bl	2abc4 <bsd_os_errno_set>
   2dbb4:	f04f 30ff 	mov.w	r0, #4294967295
   2dbb8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2dbbc:	6903      	ldr	r3, [r0, #16]
   2dbbe:	2b01      	cmp	r3, #1
   2dbc0:	d00b      	beq.n	2dbda <tls_interface_sendto+0x6a>
   2dbc2:	2b02      	cmp	r3, #2
   2dbc4:	d001      	beq.n	2dbca <tls_interface_sendto+0x5a>
   2dbc6:	2039      	movs	r0, #57	; 0x39
   2dbc8:	e7f2      	b.n	2dbb0 <tls_interface_sendto+0x40>
   2dbca:	6803      	ldr	r3, [r0, #0]
   2dbcc:	b29b      	uxth	r3, r3
   2dbce:	2b02      	cmp	r3, #2
   2dbd0:	d007      	beq.n	2dbe2 <tls_interface_sendto+0x72>
   2dbd2:	6803      	ldr	r3, [r0, #0]
   2dbd4:	b29b      	uxth	r3, r3
   2dbd6:	2b04      	cmp	r3, #4
   2dbd8:	d003      	beq.n	2dbe2 <tls_interface_sendto+0x72>
   2dbda:	6803      	ldr	r3, [r0, #0]
   2dbdc:	b29b      	uxth	r3, r3
   2dbde:	2b05      	cmp	r3, #5
   2dbe0:	d1f1      	bne.n	2dbc6 <tls_interface_sendto+0x56>
   2dbe2:	4b0e      	ldr	r3, [pc, #56]	; (2dc1c <tls_interface_sendto+0xac>)
   2dbe4:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
   2dbe8:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   2dbec:	2b02      	cmp	r3, #2
   2dbee:	d1ea      	bne.n	2dbc6 <tls_interface_sendto+0x56>
   2dbf0:	4601      	mov	r1, r0
   2dbf2:	4620      	mov	r0, r4
   2dbf4:	f7ff fec4 	bl	2d980 <secure_client_socket>
   2dbf8:	2800      	cmp	r0, #0
   2dbfa:	d003      	beq.n	2dc04 <tls_interface_sendto+0x94>
   2dbfc:	dcd8      	bgt.n	2dbb0 <tls_interface_sendto+0x40>
   2dbfe:	e7d9      	b.n	2dbb4 <tls_interface_sendto+0x44>
   2dc00:	2009      	movs	r0, #9
   2dc02:	e7d5      	b.n	2dbb0 <tls_interface_sendto+0x40>
   2dc04:	e9cd 8908 	strd	r8, r9, [sp, #32]
   2dc08:	463b      	mov	r3, r7
   2dc0a:	4632      	mov	r2, r6
   2dc0c:	4629      	mov	r1, r5
   2dc0e:	4620      	mov	r0, r4
   2dc10:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2dc14:	f003 bc22 	b.w	3145c <ip_interface_sendto>
   2dc18:	2023      	movs	r0, #35	; 0x23
   2dc1a:	e7c9      	b.n	2dbb0 <tls_interface_sendto+0x40>
   2dc1c:	20024fd8 	.word	0x20024fd8

0002dc20 <tls_interface_recvfrom>:
   2dc20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2dc24:	460d      	mov	r5, r1
   2dc26:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   2dc2a:	4616      	mov	r6, r2
   2dc2c:	461f      	mov	r7, r3
   2dc2e:	4604      	mov	r4, r0
   2dc30:	f004 ff52 	bl	32ad8 <interface_socket_from_handle_get>
   2dc34:	2800      	cmp	r0, #0
   2dc36:	d038      	beq.n	2dcaa <tls_interface_recvfrom+0x8a>
   2dc38:	6803      	ldr	r3, [r0, #0]
   2dc3a:	b29b      	uxth	r3, r3
   2dc3c:	2b0c      	cmp	r3, #12
   2dc3e:	d00f      	beq.n	2dc60 <tls_interface_recvfrom+0x40>
   2dc40:	6803      	ldr	r3, [r0, #0]
   2dc42:	b29b      	uxth	r3, r3
   2dc44:	2b0d      	cmp	r3, #13
   2dc46:	d00b      	beq.n	2dc60 <tls_interface_recvfrom+0x40>
   2dc48:	6903      	ldr	r3, [r0, #16]
   2dc4a:	2b01      	cmp	r3, #1
   2dc4c:	d01a      	beq.n	2dc84 <tls_interface_recvfrom+0x64>
   2dc4e:	2b02      	cmp	r3, #2
   2dc50:	d010      	beq.n	2dc74 <tls_interface_recvfrom+0x54>
   2dc52:	2023      	movs	r0, #35	; 0x23
   2dc54:	f7fc ffb6 	bl	2abc4 <bsd_os_errno_set>
   2dc58:	f04f 30ff 	mov.w	r0, #4294967295
   2dc5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2dc60:	e9cd 8908 	strd	r8, r9, [sp, #32]
   2dc64:	463b      	mov	r3, r7
   2dc66:	4632      	mov	r2, r6
   2dc68:	4629      	mov	r1, r5
   2dc6a:	4620      	mov	r0, r4
   2dc6c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2dc70:	f003 bd6c 	b.w	3174c <ip_interface_recvfrom>
   2dc74:	6803      	ldr	r3, [r0, #0]
   2dc76:	b29b      	uxth	r3, r3
   2dc78:	2b02      	cmp	r3, #2
   2dc7a:	d007      	beq.n	2dc8c <tls_interface_recvfrom+0x6c>
   2dc7c:	6803      	ldr	r3, [r0, #0]
   2dc7e:	b29b      	uxth	r3, r3
   2dc80:	2b04      	cmp	r3, #4
   2dc82:	d003      	beq.n	2dc8c <tls_interface_recvfrom+0x6c>
   2dc84:	6803      	ldr	r3, [r0, #0]
   2dc86:	b29b      	uxth	r3, r3
   2dc88:	2b05      	cmp	r3, #5
   2dc8a:	d1e2      	bne.n	2dc52 <tls_interface_recvfrom+0x32>
   2dc8c:	4b08      	ldr	r3, [pc, #32]	; (2dcb0 <tls_interface_recvfrom+0x90>)
   2dc8e:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
   2dc92:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   2dc96:	2b02      	cmp	r3, #2
   2dc98:	d1db      	bne.n	2dc52 <tls_interface_recvfrom+0x32>
   2dc9a:	4601      	mov	r1, r0
   2dc9c:	4620      	mov	r0, r4
   2dc9e:	f7ff fe6f 	bl	2d980 <secure_client_socket>
   2dca2:	2800      	cmp	r0, #0
   2dca4:	d0dc      	beq.n	2dc60 <tls_interface_recvfrom+0x40>
   2dca6:	dcd5      	bgt.n	2dc54 <tls_interface_recvfrom+0x34>
   2dca8:	e7d6      	b.n	2dc58 <tls_interface_recvfrom+0x38>
   2dcaa:	2009      	movs	r0, #9
   2dcac:	e7d2      	b.n	2dc54 <tls_interface_recvfrom+0x34>
   2dcae:	bf00      	nop
   2dcb0:	20024fd8 	.word	0x20024fd8

0002dcb4 <tls_interface_bind>:
   2dcb4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2dcb8:	460c      	mov	r4, r1
   2dcba:	4617      	mov	r7, r2
   2dcbc:	4606      	mov	r6, r0
   2dcbe:	f004 ff0b 	bl	32ad8 <interface_socket_from_handle_get>
   2dcc2:	2800      	cmp	r0, #0
   2dcc4:	d06d      	beq.n	2dda2 <tls_interface_bind+0xee>
   2dcc6:	6803      	ldr	r3, [r0, #0]
   2dcc8:	4605      	mov	r5, r0
   2dcca:	b29b      	uxth	r3, r3
   2dccc:	2b02      	cmp	r3, #2
   2dcce:	d15a      	bne.n	2dd86 <tls_interface_bind+0xd2>
   2dcd0:	4621      	mov	r1, r4
   2dcd2:	463a      	mov	r2, r7
   2dcd4:	4630      	mov	r0, r6
   2dcd6:	f003 ff27 	bl	31b28 <ip_interface_bind>
   2dcda:	4604      	mov	r4, r0
   2dcdc:	2800      	cmp	r0, #0
   2dcde:	d148      	bne.n	2dd72 <tls_interface_bind+0xbe>
   2dce0:	00f7      	lsls	r7, r6, #3
   2dce2:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 2dda8 <tls_interface_bind+0xf4>
   2dce6:	19bb      	adds	r3, r7, r6
   2dce8:	f818 3023 	ldrb.w	r3, [r8, r3, lsl #2]
   2dcec:	2b01      	cmp	r3, #1
   2dcee:	d002      	beq.n	2dcf6 <tls_interface_bind+0x42>
   2dcf0:	4620      	mov	r0, r4
   2dcf2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2dcf6:	f8df b0b4 	ldr.w	fp, [pc, #180]	; 2ddac <tls_interface_bind+0xf8>
   2dcfa:	f247 0281 	movw	r2, #28801	; 0x7081
   2dcfe:	eb0b 0a07 	add.w	sl, fp, r7
   2dd02:	f8da 3004 	ldr.w	r3, [sl, #4]
   2dd06:	69a9      	ldr	r1, [r5, #24]
   2dd08:	4630      	mov	r0, r6
   2dd0a:	f003 fa25 	bl	31158 <ip_interface_request_create>
   2dd0e:	4681      	mov	r9, r0
   2dd10:	2800      	cmp	r0, #0
   2dd12:	d044      	beq.n	2dd9e <tls_interface_bind+0xea>
   2dd14:	f8da 2004 	ldr.w	r2, [sl, #4]
   2dd18:	2a00      	cmp	r2, #0
   2dd1a:	d13a      	bne.n	2dd92 <tls_interface_bind+0xde>
   2dd1c:	19b9      	adds	r1, r7, r6
   2dd1e:	eb08 0181 	add.w	r1, r8, r1, lsl #2
   2dd22:	2224      	movs	r2, #36	; 0x24
   2dd24:	f109 0014 	add.w	r0, r9, #20
   2dd28:	f010 fd90 	bl	3e84c <memcpy>
   2dd2c:	f8d9 3008 	ldr.w	r3, [r9, #8]
   2dd30:	4649      	mov	r1, r9
   2dd32:	3324      	adds	r3, #36	; 0x24
   2dd34:	f8c9 3008 	str.w	r3, [r9, #8]
   2dd38:	682a      	ldr	r2, [r5, #0]
   2dd3a:	2304      	movs	r3, #4
   2dd3c:	0c12      	lsrs	r2, r2, #16
   2dd3e:	0412      	lsls	r2, r2, #16
   2dd40:	f042 020a 	orr.w	r2, r2, #10
   2dd44:	602a      	str	r2, [r5, #0]
   2dd46:	4628      	mov	r0, r5
   2dd48:	f247 0281 	movw	r2, #28801	; 0x7081
   2dd4c:	f003 fa24 	bl	31198 <ip_interface_request_send>
   2dd50:	b9e8      	cbnz	r0, 2dd8e <tls_interface_bind+0xda>
   2dd52:	682b      	ldr	r3, [r5, #0]
   2dd54:	00db      	lsls	r3, r3, #3
   2dd56:	d418      	bmi.n	2dd8a <tls_interface_bind+0xd6>
   2dd58:	4630      	mov	r0, r6
   2dd5a:	f04f 33ff 	mov.w	r3, #4294967295
   2dd5e:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2dd62:	210b      	movs	r1, #11
   2dd64:	f003 fa2c 	bl	311c0 <ip_interface_wait>
   2dd68:	2800      	cmp	r0, #0
   2dd6a:	d0c1      	beq.n	2dcf0 <tls_interface_bind+0x3c>
   2dd6c:	2304      	movs	r3, #4
   2dd6e:	4604      	mov	r4, r0
   2dd70:	602b      	str	r3, [r5, #0]
   2dd72:	2c00      	cmp	r4, #0
   2dd74:	ddbc      	ble.n	2dcf0 <tls_interface_bind+0x3c>
   2dd76:	4620      	mov	r0, r4
   2dd78:	f04f 34ff 	mov.w	r4, #4294967295
   2dd7c:	f7fc ff22 	bl	2abc4 <bsd_os_errno_set>
   2dd80:	4620      	mov	r0, r4
   2dd82:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2dd86:	242d      	movs	r4, #45	; 0x2d
   2dd88:	e7f5      	b.n	2dd76 <tls_interface_bind+0xc2>
   2dd8a:	2473      	movs	r4, #115	; 0x73
   2dd8c:	e7f3      	b.n	2dd76 <tls_interface_bind+0xc2>
   2dd8e:	4604      	mov	r4, r0
   2dd90:	e7ef      	b.n	2dd72 <tls_interface_bind+0xbe>
   2dd92:	f85b 1036 	ldr.w	r1, [fp, r6, lsl #3]
   2dd96:	6800      	ldr	r0, [r0, #0]
   2dd98:	f010 fd58 	bl	3e84c <memcpy>
   2dd9c:	e7be      	b.n	2dd1c <tls_interface_bind+0x68>
   2dd9e:	240c      	movs	r4, #12
   2dda0:	e7e9      	b.n	2dd76 <tls_interface_bind+0xc2>
   2dda2:	2409      	movs	r4, #9
   2dda4:	e7e7      	b.n	2dd76 <tls_interface_bind+0xc2>
   2dda6:	bf00      	nop
   2dda8:	20024fd8 	.word	0x20024fd8
   2ddac:	2002511c 	.word	0x2002511c

0002ddb0 <tls_interface_connect>:
   2ddb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2ddb2:	460e      	mov	r6, r1
   2ddb4:	4617      	mov	r7, r2
   2ddb6:	4604      	mov	r4, r0
   2ddb8:	f004 fe8e 	bl	32ad8 <interface_socket_from_handle_get>
   2ddbc:	b1e8      	cbz	r0, 2ddfa <tls_interface_connect+0x4a>
   2ddbe:	4b13      	ldr	r3, [pc, #76]	; (2de0c <tls_interface_connect+0x5c>)
   2ddc0:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
   2ddc4:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   2ddc8:	2b02      	cmp	r3, #2
   2ddca:	d11c      	bne.n	2de06 <tls_interface_connect+0x56>
   2ddcc:	6803      	ldr	r3, [r0, #0]
   2ddce:	4605      	mov	r5, r0
   2ddd0:	b29b      	uxth	r3, r3
   2ddd2:	2b02      	cmp	r3, #2
   2ddd4:	d003      	beq.n	2ddde <tls_interface_connect+0x2e>
   2ddd6:	6803      	ldr	r3, [r0, #0]
   2ddd8:	b29b      	uxth	r3, r3
   2ddda:	2b04      	cmp	r3, #4
   2dddc:	d113      	bne.n	2de06 <tls_interface_connect+0x56>
   2ddde:	463a      	mov	r2, r7
   2dde0:	4631      	mov	r1, r6
   2dde2:	4620      	mov	r0, r4
   2dde4:	f003 fde6 	bl	319b4 <ip_interface_connect>
   2dde8:	b110      	cbz	r0, 2ddf0 <tls_interface_connect+0x40>
   2ddea:	2800      	cmp	r0, #0
   2ddec:	dc06      	bgt.n	2ddfc <tls_interface_connect+0x4c>
   2ddee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2ddf0:	4629      	mov	r1, r5
   2ddf2:	4620      	mov	r0, r4
   2ddf4:	f7ff fdc4 	bl	2d980 <secure_client_socket>
   2ddf8:	e7f7      	b.n	2ddea <tls_interface_connect+0x3a>
   2ddfa:	2009      	movs	r0, #9
   2ddfc:	f7fc fee2 	bl	2abc4 <bsd_os_errno_set>
   2de00:	f04f 30ff 	mov.w	r0, #4294967295
   2de04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2de06:	202d      	movs	r0, #45	; 0x2d
   2de08:	e7f8      	b.n	2ddfc <tls_interface_connect+0x4c>
   2de0a:	bf00      	nop
   2de0c:	20024fd8 	.word	0x20024fd8

0002de10 <tls_interface_listen>:
   2de10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2de14:	b083      	sub	sp, #12
   2de16:	9101      	str	r1, [sp, #4]
   2de18:	4605      	mov	r5, r0
   2de1a:	f004 fe5d 	bl	32ad8 <interface_socket_from_handle_get>
   2de1e:	2800      	cmp	r0, #0
   2de20:	d079      	beq.n	2df16 <tls_interface_listen+0x106>
   2de22:	6903      	ldr	r3, [r0, #16]
   2de24:	4604      	mov	r4, r0
   2de26:	2b01      	cmp	r3, #1
   2de28:	d173      	bne.n	2df12 <tls_interface_listen+0x102>
   2de2a:	6803      	ldr	r3, [r0, #0]
   2de2c:	b29b      	uxth	r3, r3
   2de2e:	2b04      	cmp	r3, #4
   2de30:	d05f      	beq.n	2def2 <tls_interface_listen+0xe2>
   2de32:	6823      	ldr	r3, [r4, #0]
   2de34:	b29b      	uxth	r3, r3
   2de36:	2b0b      	cmp	r3, #11
   2de38:	d16b      	bne.n	2df12 <tls_interface_listen+0x102>
   2de3a:	00ee      	lsls	r6, r5, #3
   2de3c:	4f37      	ldr	r7, [pc, #220]	; (2df1c <tls_interface_listen+0x10c>)
   2de3e:	1973      	adds	r3, r6, r5
   2de40:	f817 3023 	ldrb.w	r3, [r7, r3, lsl #2]
   2de44:	2b01      	cmp	r3, #1
   2de46:	d164      	bne.n	2df12 <tls_interface_listen+0x102>
   2de48:	2201      	movs	r2, #1
   2de4a:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 2df20 <tls_interface_listen+0x110>
   2de4e:	1973      	adds	r3, r6, r5
   2de50:	00ee      	lsls	r6, r5, #3
   2de52:	f807 2023 	strb.w	r2, [r7, r3, lsl #2]
   2de56:	eb09 0806 	add.w	r8, r9, r6
   2de5a:	69a1      	ldr	r1, [r4, #24]
   2de5c:	f8d8 3004 	ldr.w	r3, [r8, #4]
   2de60:	f247 0281 	movw	r2, #28801	; 0x7081
   2de64:	4628      	mov	r0, r5
   2de66:	f8d4 a000 	ldr.w	sl, [r4]
   2de6a:	f003 f975 	bl	31158 <ip_interface_request_create>
   2de6e:	4683      	mov	fp, r0
   2de70:	2800      	cmp	r0, #0
   2de72:	d04c      	beq.n	2df0e <tls_interface_listen+0xfe>
   2de74:	f8d8 2004 	ldr.w	r2, [r8, #4]
   2de78:	2a00      	cmp	r2, #0
   2de7a:	d142      	bne.n	2df02 <tls_interface_listen+0xf2>
   2de7c:	1971      	adds	r1, r6, r5
   2de7e:	eb07 0181 	add.w	r1, r7, r1, lsl #2
   2de82:	2224      	movs	r2, #36	; 0x24
   2de84:	f10b 0014 	add.w	r0, fp, #20
   2de88:	f010 fce0 	bl	3e84c <memcpy>
   2de8c:	f8db 2008 	ldr.w	r2, [fp, #8]
   2de90:	4659      	mov	r1, fp
   2de92:	3224      	adds	r2, #36	; 0x24
   2de94:	f8cb 2008 	str.w	r2, [fp, #8]
   2de98:	6822      	ldr	r2, [r4, #0]
   2de9a:	4653      	mov	r3, sl
   2de9c:	0c12      	lsrs	r2, r2, #16
   2de9e:	0412      	lsls	r2, r2, #16
   2dea0:	f042 020a 	orr.w	r2, r2, #10
   2dea4:	6022      	str	r2, [r4, #0]
   2dea6:	4620      	mov	r0, r4
   2dea8:	f247 0281 	movw	r2, #28801	; 0x7081
   2deac:	f003 f974 	bl	31198 <ip_interface_request_send>
   2deb0:	b968      	cbnz	r0, 2dece <tls_interface_listen+0xbe>
   2deb2:	6823      	ldr	r3, [r4, #0]
   2deb4:	00db      	lsls	r3, r3, #3
   2deb6:	d40f      	bmi.n	2ded8 <tls_interface_listen+0xc8>
   2deb8:	f04f 33ff 	mov.w	r3, #4294967295
   2debc:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2dec0:	210b      	movs	r1, #11
   2dec2:	4628      	mov	r0, r5
   2dec4:	f003 f97c 	bl	311c0 <ip_interface_wait>
   2dec8:	b170      	cbz	r0, 2dee8 <tls_interface_listen+0xd8>
   2deca:	f8c4 a000 	str.w	sl, [r4]
   2dece:	2800      	cmp	r0, #0
   2ded0:	dc03      	bgt.n	2deda <tls_interface_listen+0xca>
   2ded2:	b003      	add	sp, #12
   2ded4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2ded8:	2073      	movs	r0, #115	; 0x73
   2deda:	f7fc fe73 	bl	2abc4 <bsd_os_errno_set>
   2dede:	f04f 30ff 	mov.w	r0, #4294967295
   2dee2:	b003      	add	sp, #12
   2dee4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2dee8:	9901      	ldr	r1, [sp, #4]
   2deea:	4628      	mov	r0, r5
   2deec:	f003 febc 	bl	31c68 <ip_interface_listen>
   2def0:	e7ed      	b.n	2dece <tls_interface_listen+0xbe>
   2def2:	00ee      	lsls	r6, r5, #3
   2def4:	4f09      	ldr	r7, [pc, #36]	; (2df1c <tls_interface_listen+0x10c>)
   2def6:	1973      	adds	r3, r6, r5
   2def8:	f817 3023 	ldrb.w	r3, [r7, r3, lsl #2]
   2defc:	2b02      	cmp	r3, #2
   2defe:	d198      	bne.n	2de32 <tls_interface_listen+0x22>
   2df00:	e7a2      	b.n	2de48 <tls_interface_listen+0x38>
   2df02:	f859 1035 	ldr.w	r1, [r9, r5, lsl #3]
   2df06:	6800      	ldr	r0, [r0, #0]
   2df08:	f010 fca0 	bl	3e84c <memcpy>
   2df0c:	e7b6      	b.n	2de7c <tls_interface_listen+0x6c>
   2df0e:	200c      	movs	r0, #12
   2df10:	e7e3      	b.n	2deda <tls_interface_listen+0xca>
   2df12:	202d      	movs	r0, #45	; 0x2d
   2df14:	e7e1      	b.n	2deda <tls_interface_listen+0xca>
   2df16:	2009      	movs	r0, #9
   2df18:	e7df      	b.n	2deda <tls_interface_listen+0xca>
   2df1a:	bf00      	nop
   2df1c:	20024fd8 	.word	0x20024fd8
   2df20:	2002511c 	.word	0x2002511c

0002df24 <tls_interface_accept>:
   2df24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2df26:	460c      	mov	r4, r1
   2df28:	4616      	mov	r6, r2
   2df2a:	461f      	mov	r7, r3
   2df2c:	4605      	mov	r5, r0
   2df2e:	f004 fdd3 	bl	32ad8 <interface_socket_from_handle_get>
   2df32:	2800      	cmp	r0, #0
   2df34:	d03b      	beq.n	2dfae <tls_interface_accept+0x8a>
   2df36:	6800      	ldr	r0, [r0, #0]
   2df38:	b280      	uxth	r0, r0
   2df3a:	2806      	cmp	r0, #6
   2df3c:	d137      	bne.n	2dfae <tls_interface_accept+0x8a>
   2df3e:	4621      	mov	r1, r4
   2df40:	463b      	mov	r3, r7
   2df42:	4632      	mov	r2, r6
   2df44:	4628      	mov	r0, r5
   2df46:	f003 ff05 	bl	31d54 <ip_interface_accept>
   2df4a:	4604      	mov	r4, r0
   2df4c:	b118      	cbz	r0, 2df56 <tls_interface_accept+0x32>
   2df4e:	2c00      	cmp	r4, #0
   2df50:	dc2e      	bgt.n	2dfb0 <tls_interface_accept+0x8c>
   2df52:	4620      	mov	r0, r4
   2df54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2df56:	4628      	mov	r0, r5
   2df58:	f004 fdbe 	bl	32ad8 <interface_socket_from_handle_get>
   2df5c:	6803      	ldr	r3, [r0, #0]
   2df5e:	4f18      	ldr	r7, [pc, #96]	; (2dfc0 <tls_interface_accept+0x9c>)
   2df60:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   2df64:	6003      	str	r3, [r0, #0]
   2df66:	6803      	ldr	r3, [r0, #0]
   2df68:	eb05 05c5 	add.w	r5, r5, r5, lsl #3
   2df6c:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   2df70:	4606      	mov	r6, r0
   2df72:	6003      	str	r3, [r0, #0]
   2df74:	eb07 0185 	add.w	r1, r7, r5, lsl #2
   2df78:	2224      	movs	r2, #36	; 0x24
   2df7a:	4638      	mov	r0, r7
   2df7c:	f010 fc66 	bl	3e84c <memcpy>
   2df80:	2302      	movs	r3, #2
   2df82:	703b      	strb	r3, [r7, #0]
   2df84:	6833      	ldr	r3, [r6, #0]
   2df86:	4620      	mov	r0, r4
   2df88:	0c1b      	lsrs	r3, r3, #16
   2df8a:	041b      	lsls	r3, r3, #16
   2df8c:	f043 030b 	orr.w	r3, r3, #11
   2df90:	6033      	str	r3, [r6, #0]
   2df92:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2df96:	f04f 33ff 	mov.w	r3, #4294967295
   2df9a:	210c      	movs	r1, #12
   2df9c:	f003 f910 	bl	311c0 <ip_interface_wait>
   2dfa0:	4604      	mov	r4, r0
   2dfa2:	2800      	cmp	r0, #0
   2dfa4:	d0d5      	beq.n	2df52 <tls_interface_accept+0x2e>
   2dfa6:	2000      	movs	r0, #0
   2dfa8:	f003 f9e8 	bl	3137c <ip_interface_close>
   2dfac:	e7cf      	b.n	2df4e <tls_interface_accept+0x2a>
   2dfae:	2409      	movs	r4, #9
   2dfb0:	4620      	mov	r0, r4
   2dfb2:	f04f 34ff 	mov.w	r4, #4294967295
   2dfb6:	f7fc fe05 	bl	2abc4 <bsd_os_errno_set>
   2dfba:	4620      	mov	r0, r4
   2dfbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2dfbe:	bf00      	nop
   2dfc0:	20024fd8 	.word	0x20024fd8

0002dfc4 <tls_interface_setopt>:
   2dfc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2dfc8:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
   2dfcc:	9e06      	ldr	r6, [sp, #24]
   2dfce:	d11e      	bne.n	2e00e <tls_interface_setopt+0x4a>
   2dfd0:	461f      	mov	r7, r3
   2dfd2:	4605      	mov	r5, r0
   2dfd4:	2b00      	cmp	r3, #0
   2dfd6:	f000 808c 	beq.w	2e0f2 <tls_interface_setopt+0x12e>
   2dfda:	4690      	mov	r8, r2
   2dfdc:	f004 fd7c 	bl	32ad8 <interface_socket_from_handle_get>
   2dfe0:	2800      	cmp	r0, #0
   2dfe2:	d07b      	beq.n	2e0dc <tls_interface_setopt+0x118>
   2dfe4:	6804      	ldr	r4, [r0, #0]
   2dfe6:	b2a4      	uxth	r4, r4
   2dfe8:	2c02      	cmp	r4, #2
   2dfea:	d007      	beq.n	2dffc <tls_interface_setopt+0x38>
   2dfec:	6803      	ldr	r3, [r0, #0]
   2dfee:	b29b      	uxth	r3, r3
   2dff0:	2b04      	cmp	r3, #4
   2dff2:	d003      	beq.n	2dffc <tls_interface_setopt+0x38>
   2dff4:	6803      	ldr	r3, [r0, #0]
   2dff6:	b29b      	uxth	r3, r3
   2dff8:	2b05      	cmp	r3, #5
   2dffa:	d16f      	bne.n	2e0dc <tls_interface_setopt+0x118>
   2dffc:	f108 32ff 	add.w	r2, r8, #4294967295
   2e000:	2a04      	cmp	r2, #4
   2e002:	d87c      	bhi.n	2e0fe <tls_interface_setopt+0x13a>
   2e004:	e8df f002 	tbb	[pc, r2]
   2e008:	41324e24 	.word	0x41324e24
   2e00c:	07          	.byte	0x07
   2e00d:	00          	.byte	0x00
   2e00e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   2e012:	f003 bfd7 	b.w	31fc4 <ip_interface_setopt>
   2e016:	4c3b      	ldr	r4, [pc, #236]	; (2e104 <tls_interface_setopt+0x140>)
   2e018:	f854 0035 	ldr.w	r0, [r4, r5, lsl #3]
   2e01c:	b138      	cbz	r0, 2e02e <tls_interface_setopt+0x6a>
   2e01e:	f7ff fc47 	bl	2d8b0 <nrf_free>
   2e022:	2200      	movs	r2, #0
   2e024:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
   2e028:	f844 2035 	str.w	r2, [r4, r5, lsl #3]
   2e02c:	605a      	str	r2, [r3, #4]
   2e02e:	4630      	mov	r0, r6
   2e030:	b34e      	cbz	r6, 2e086 <tls_interface_setopt+0xc2>
   2e032:	f7ff fc33 	bl	2d89c <nrf_malloc>
   2e036:	f844 0035 	str.w	r0, [r4, r5, lsl #3]
   2e03a:	2800      	cmp	r0, #0
   2e03c:	d057      	beq.n	2e0ee <tls_interface_setopt+0x12a>
   2e03e:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   2e042:	4632      	mov	r2, r6
   2e044:	4639      	mov	r1, r7
   2e046:	6066      	str	r6, [r4, #4]
   2e048:	f010 fc00 	bl	3e84c <memcpy>
   2e04c:	2000      	movs	r0, #0
   2e04e:	e01a      	b.n	2e086 <tls_interface_setopt+0xc2>
   2e050:	2e04      	cmp	r6, #4
   2e052:	d14a      	bne.n	2e0ea <tls_interface_setopt+0x126>
   2e054:	6838      	ldr	r0, [r7, #0]
   2e056:	2800      	cmp	r0, #0
   2e058:	d039      	beq.n	2e0ce <tls_interface_setopt+0x10a>
   2e05a:	2801      	cmp	r0, #1
   2e05c:	d145      	bne.n	2e0ea <tls_interface_setopt+0x126>
   2e05e:	4a2a      	ldr	r2, [pc, #168]	; (2e108 <tls_interface_setopt+0x144>)
   2e060:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   2e064:	f802 0024 	strb.w	r0, [r2, r4, lsl #2]
   2e068:	2000      	movs	r0, #0
   2e06a:	e00c      	b.n	2e086 <tls_interface_setopt+0xc2>
   2e06c:	2e01      	cmp	r6, #1
   2e06e:	d13c      	bne.n	2e0ea <tls_interface_setopt+0x126>
   2e070:	783a      	ldrb	r2, [r7, #0]
   2e072:	2000      	movs	r0, #0
   2e074:	3200      	adds	r2, #0
   2e076:	bf18      	it	ne
   2e078:	2201      	movne	r2, #1
   2e07a:	4b23      	ldr	r3, [pc, #140]	; (2e108 <tls_interface_setopt+0x144>)
   2e07c:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   2e080:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   2e084:	7062      	strb	r2, [r4, #1]
   2e086:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2e08a:	2e04      	cmp	r6, #4
   2e08c:	d12d      	bne.n	2e0ea <tls_interface_setopt+0x126>
   2e08e:	683a      	ldr	r2, [r7, #0]
   2e090:	2a02      	cmp	r2, #2
   2e092:	d82a      	bhi.n	2e0ea <tls_interface_setopt+0x126>
   2e094:	4b1c      	ldr	r3, [pc, #112]	; (2e108 <tls_interface_setopt+0x144>)
   2e096:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   2e09a:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   2e09e:	70a2      	strb	r2, [r4, #2]
   2e0a0:	2000      	movs	r0, #0
   2e0a2:	e7f0      	b.n	2e086 <tls_interface_setopt+0xc2>
   2e0a4:	ea5f 0c96 	movs.w	ip, r6, lsr #2
   2e0a8:	d01f      	beq.n	2e0ea <tls_interface_setopt+0x126>
   2e0aa:	f016 0403 	ands.w	r4, r6, #3
   2e0ae:	d11c      	bne.n	2e0ea <tls_interface_setopt+0x126>
   2e0b0:	eb05 05c5 	add.w	r5, r5, r5, lsl #3
   2e0b4:	00ad      	lsls	r5, r5, #2
   2e0b6:	4b14      	ldr	r3, [pc, #80]	; (2e108 <tls_interface_setopt+0x144>)
   2e0b8:	1d28      	adds	r0, r5, #4
   2e0ba:	4418      	add	r0, r3
   2e0bc:	442b      	add	r3, r5
   2e0be:	4632      	mov	r2, r6
   2e0c0:	4639      	mov	r1, r7
   2e0c2:	f883 c003 	strb.w	ip, [r3, #3]
   2e0c6:	f010 fbc1 	bl	3e84c <memcpy>
   2e0ca:	4620      	mov	r0, r4
   2e0cc:	e7db      	b.n	2e086 <tls_interface_setopt+0xc2>
   2e0ce:	2102      	movs	r1, #2
   2e0d0:	4a0d      	ldr	r2, [pc, #52]	; (2e108 <tls_interface_setopt+0x144>)
   2e0d2:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   2e0d6:	f802 1024 	strb.w	r1, [r2, r4, lsl #2]
   2e0da:	e7d4      	b.n	2e086 <tls_interface_setopt+0xc2>
   2e0dc:	2009      	movs	r0, #9
   2e0de:	f7fc fd71 	bl	2abc4 <bsd_os_errno_set>
   2e0e2:	f04f 30ff 	mov.w	r0, #4294967295
   2e0e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2e0ea:	2016      	movs	r0, #22
   2e0ec:	e7f7      	b.n	2e0de <tls_interface_setopt+0x11a>
   2e0ee:	200c      	movs	r0, #12
   2e0f0:	e7f5      	b.n	2e0de <tls_interface_setopt+0x11a>
   2e0f2:	200e      	movs	r0, #14
   2e0f4:	f7fc fd66 	bl	2abc4 <bsd_os_errno_set>
   2e0f8:	f04f 30ff 	mov.w	r0, #4294967295
   2e0fc:	e7c3      	b.n	2e086 <tls_interface_setopt+0xc2>
   2e0fe:	202a      	movs	r0, #42	; 0x2a
   2e100:	e7ed      	b.n	2e0de <tls_interface_setopt+0x11a>
   2e102:	bf00      	nop
   2e104:	2002511c 	.word	0x2002511c
   2e108:	20024fd8 	.word	0x20024fd8

0002e10c <tls_interface_getopt>:
   2e10c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2e110:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
   2e114:	9f06      	ldr	r7, [sp, #24]
   2e116:	d112      	bne.n	2e13e <tls_interface_getopt+0x32>
   2e118:	461d      	mov	r5, r3
   2e11a:	b16b      	cbz	r3, 2e138 <tls_interface_getopt+0x2c>
   2e11c:	b167      	cbz	r7, 2e138 <tls_interface_getopt+0x2c>
   2e11e:	4606      	mov	r6, r0
   2e120:	4614      	mov	r4, r2
   2e122:	f004 fcd9 	bl	32ad8 <interface_socket_from_handle_get>
   2e126:	2800      	cmp	r0, #0
   2e128:	d04f      	beq.n	2e1ca <tls_interface_getopt+0xbe>
   2e12a:	3c01      	subs	r4, #1
   2e12c:	2c03      	cmp	r4, #3
   2e12e:	d852      	bhi.n	2e1d6 <tls_interface_getopt+0xca>
   2e130:	e8df f004 	tbb	[pc, r4]
   2e134:	09152139 	.word	0x09152139
   2e138:	200e      	movs	r0, #14
   2e13a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2e13e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   2e142:	f003 bffb 	b.w	3213c <ip_interface_getopt>
   2e146:	683b      	ldr	r3, [r7, #0]
   2e148:	2b04      	cmp	r3, #4
   2e14a:	d13c      	bne.n	2e1c6 <tls_interface_getopt+0xba>
   2e14c:	4b23      	ldr	r3, [pc, #140]	; (2e1dc <tls_interface_getopt+0xd0>)
   2e14e:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   2e152:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   2e156:	78b3      	ldrb	r3, [r6, #2]
   2e158:	2000      	movs	r0, #0
   2e15a:	602b      	str	r3, [r5, #0]
   2e15c:	e7ed      	b.n	2e13a <tls_interface_getopt+0x2e>
   2e15e:	683b      	ldr	r3, [r7, #0]
   2e160:	2b01      	cmp	r3, #1
   2e162:	d130      	bne.n	2e1c6 <tls_interface_getopt+0xba>
   2e164:	4b1d      	ldr	r3, [pc, #116]	; (2e1dc <tls_interface_getopt+0xd0>)
   2e166:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   2e16a:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   2e16e:	7873      	ldrb	r3, [r6, #1]
   2e170:	2000      	movs	r0, #0
   2e172:	702b      	strb	r3, [r5, #0]
   2e174:	e7e1      	b.n	2e13a <tls_interface_getopt+0x2e>
   2e176:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   2e17a:	4918      	ldr	r1, [pc, #96]	; (2e1dc <tls_interface_getopt+0xd0>)
   2e17c:	683b      	ldr	r3, [r7, #0]
   2e17e:	00b6      	lsls	r6, r6, #2
   2e180:	198a      	adds	r2, r1, r6
   2e182:	f013 0403 	ands.w	r4, r3, #3
   2e186:	78d0      	ldrb	r0, [r2, #3]
   2e188:	d121      	bne.n	2e1ce <tls_interface_getopt+0xc2>
   2e18a:	089b      	lsrs	r3, r3, #2
   2e18c:	4283      	cmp	r3, r0
   2e18e:	bf28      	it	cs
   2e190:	4603      	movcs	r3, r0
   2e192:	009a      	lsls	r2, r3, #2
   2e194:	b1db      	cbz	r3, 2e1ce <tls_interface_getopt+0xc2>
   2e196:	3604      	adds	r6, #4
   2e198:	4431      	add	r1, r6
   2e19a:	603a      	str	r2, [r7, #0]
   2e19c:	4628      	mov	r0, r5
   2e19e:	f010 fb55 	bl	3e84c <memcpy>
   2e1a2:	4620      	mov	r0, r4
   2e1a4:	e7c9      	b.n	2e13a <tls_interface_getopt+0x2e>
   2e1a6:	683b      	ldr	r3, [r7, #0]
   2e1a8:	2b04      	cmp	r3, #4
   2e1aa:	d10c      	bne.n	2e1c6 <tls_interface_getopt+0xba>
   2e1ac:	4b0b      	ldr	r3, [pc, #44]	; (2e1dc <tls_interface_getopt+0xd0>)
   2e1ae:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   2e1b2:	f813 3026 	ldrb.w	r3, [r3, r6, lsl #2]
   2e1b6:	2000      	movs	r0, #0
   2e1b8:	f1a3 0301 	sub.w	r3, r3, #1
   2e1bc:	fab3 f383 	clz	r3, r3
   2e1c0:	095b      	lsrs	r3, r3, #5
   2e1c2:	602b      	str	r3, [r5, #0]
   2e1c4:	e7b9      	b.n	2e13a <tls_interface_getopt+0x2e>
   2e1c6:	2016      	movs	r0, #22
   2e1c8:	e7b7      	b.n	2e13a <tls_interface_getopt+0x2e>
   2e1ca:	2009      	movs	r0, #9
   2e1cc:	e7b5      	b.n	2e13a <tls_interface_getopt+0x2e>
   2e1ce:	2800      	cmp	r0, #0
   2e1d0:	d1f9      	bne.n	2e1c6 <tls_interface_getopt+0xba>
   2e1d2:	6038      	str	r0, [r7, #0]
   2e1d4:	e7b1      	b.n	2e13a <tls_interface_getopt+0x2e>
   2e1d6:	202a      	movs	r0, #42	; 0x2a
   2e1d8:	e7af      	b.n	2e13a <tls_interface_getopt+0x2e>
   2e1da:	bf00      	nop
   2e1dc:	20024fd8 	.word	0x20024fd8

0002e1e0 <tls_rpc_ip_event_handler>:
   2e1e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2e1e2:	f248 0581 	movw	r5, #32897	; 0x8081
   2e1e6:	42ab      	cmp	r3, r5
   2e1e8:	460c      	mov	r4, r1
   2e1ea:	d062      	beq.n	2e2b2 <tls_rpc_ip_event_handler+0xd2>
   2e1ec:	f249 0182 	movw	r1, #36994	; 0x9082
   2e1f0:	428b      	cmp	r3, r1
   2e1f2:	4606      	mov	r6, r0
   2e1f4:	d02e      	beq.n	2e254 <tls_rpc_ip_event_handler+0x74>
   2e1f6:	f248 0102 	movw	r1, #32770	; 0x8002
   2e1fa:	428b      	cmp	r3, r1
   2e1fc:	d001      	beq.n	2e202 <tls_rpc_ip_event_handler+0x22>
   2e1fe:	2001      	movs	r0, #1
   2e200:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2e202:	2c00      	cmp	r4, #0
   2e204:	d0fb      	beq.n	2e1fe <tls_rpc_ip_event_handler+0x1e>
   2e206:	6963      	ldr	r3, [r4, #20]
   2e208:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
   2e20c:	d002      	beq.n	2e214 <tls_rpc_ip_event_handler+0x34>
   2e20e:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   2e212:	d1f4      	bne.n	2e1fe <tls_rpc_ip_event_handler+0x1e>
   2e214:	6823      	ldr	r3, [r4, #0]
   2e216:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   2e21a:	6023      	str	r3, [r4, #0]
   2e21c:	6955      	ldr	r5, [r2, #20]
   2e21e:	2d00      	cmp	r5, #0
   2e220:	d156      	bne.n	2e2d0 <tls_rpc_ip_event_handler+0xf0>
   2e222:	6823      	ldr	r3, [r4, #0]
   2e224:	0c1b      	lsrs	r3, r3, #16
   2e226:	041b      	lsls	r3, r3, #16
   2e228:	f043 0305 	orr.w	r3, r3, #5
   2e22c:	6023      	str	r3, [r4, #0]
   2e22e:	6823      	ldr	r3, [r4, #0]
   2e230:	00da      	lsls	r2, r3, #3
   2e232:	d50d      	bpl.n	2e250 <tls_rpc_ip_event_handler+0x70>
   2e234:	4b2b      	ldr	r3, [pc, #172]	; (2e2e4 <tls_rpc_ip_event_handler+0x104>)
   2e236:	eb06 02c6 	add.w	r2, r6, r6, lsl #3
   2e23a:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   2e23e:	2b02      	cmp	r3, #2
   2e240:	d106      	bne.n	2e250 <tls_rpc_ip_event_handler+0x70>
   2e242:	4630      	mov	r0, r6
   2e244:	4621      	mov	r1, r4
   2e246:	f7ff fb9b 	bl	2d980 <secure_client_socket>
   2e24a:	b108      	cbz	r0, 2e250 <tls_rpc_ip_event_handler+0x70>
   2e24c:	2873      	cmp	r0, #115	; 0x73
   2e24e:	d142      	bne.n	2e2d6 <tls_rpc_ip_event_handler+0xf6>
   2e250:	2000      	movs	r0, #0
   2e252:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2e254:	2c00      	cmp	r4, #0
   2e256:	d0fb      	beq.n	2e250 <tls_rpc_ip_event_handler+0x70>
   2e258:	6823      	ldr	r3, [r4, #0]
   2e25a:	b29b      	uxth	r3, r3
   2e25c:	2b0b      	cmp	r3, #11
   2e25e:	d1f7      	bne.n	2e250 <tls_rpc_ip_event_handler+0x70>
   2e260:	6915      	ldr	r5, [r2, #16]
   2e262:	2d00      	cmp	r5, #0
   2e264:	d134      	bne.n	2e2d0 <tls_rpc_ip_event_handler+0xf0>
   2e266:	6823      	ldr	r3, [r4, #0]
   2e268:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   2e26c:	6023      	str	r3, [r4, #0]
   2e26e:	6823      	ldr	r3, [r4, #0]
   2e270:	00db      	lsls	r3, r3, #3
   2e272:	d5ed      	bpl.n	2e250 <tls_rpc_ip_event_handler+0x70>
   2e274:	4f1c      	ldr	r7, [pc, #112]	; (2e2e8 <tls_rpc_ip_event_handler+0x108>)
   2e276:	f857 0030 	ldr.w	r0, [r7, r0, lsl #3]
   2e27a:	b130      	cbz	r0, 2e28a <tls_rpc_ip_event_handler+0xaa>
   2e27c:	f7ff fb18 	bl	2d8b0 <nrf_free>
   2e280:	eb07 03c6 	add.w	r3, r7, r6, lsl #3
   2e284:	f847 5036 	str.w	r5, [r7, r6, lsl #3]
   2e288:	605d      	str	r5, [r3, #4]
   2e28a:	6823      	ldr	r3, [r4, #0]
   2e28c:	2000      	movs	r0, #0
   2e28e:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   2e292:	6023      	str	r3, [r4, #0]
   2e294:	6823      	ldr	r3, [r4, #0]
   2e296:	0c1b      	lsrs	r3, r3, #16
   2e298:	041b      	lsls	r3, r3, #16
   2e29a:	f043 030c 	orr.w	r3, r3, #12
   2e29e:	6023      	str	r3, [r4, #0]
   2e2a0:	6823      	ldr	r3, [r4, #0]
   2e2a2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2e2a6:	6023      	str	r3, [r4, #0]
   2e2a8:	6823      	ldr	r3, [r4, #0]
   2e2aa:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   2e2ae:	6023      	str	r3, [r4, #0]
   2e2b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2e2b2:	2900      	cmp	r1, #0
   2e2b4:	d0cc      	beq.n	2e250 <tls_rpc_ip_event_handler+0x70>
   2e2b6:	680b      	ldr	r3, [r1, #0]
   2e2b8:	b29b      	uxth	r3, r3
   2e2ba:	2b0a      	cmp	r3, #10
   2e2bc:	d1c8      	bne.n	2e250 <tls_rpc_ip_event_handler+0x70>
   2e2be:	6950      	ldr	r0, [r2, #20]
   2e2c0:	b938      	cbnz	r0, 2e2d2 <tls_rpc_ip_event_handler+0xf2>
   2e2c2:	680b      	ldr	r3, [r1, #0]
   2e2c4:	0c1b      	lsrs	r3, r3, #16
   2e2c6:	041b      	lsls	r3, r3, #16
   2e2c8:	f043 030b 	orr.w	r3, r3, #11
   2e2cc:	600b      	str	r3, [r1, #0]
   2e2ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2e2d0:	4628      	mov	r0, r5
   2e2d2:	f002 ff37 	bl	31144 <rpc_error_to_nrf_bsd_error>
   2e2d6:	6060      	str	r0, [r4, #4]
   2e2d8:	6823      	ldr	r3, [r4, #0]
   2e2da:	2000      	movs	r0, #0
   2e2dc:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   2e2e0:	6023      	str	r3, [r4, #0]
   2e2e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2e2e4:	20024fd8 	.word	0x20024fd8
   2e2e8:	2002511c 	.word	0x2002511c

0002e2ec <rpc_dfu_event_handler>:
   2e2ec:	b508      	push	{r3, lr}
   2e2ee:	4a08      	ldr	r2, [pc, #32]	; (2e310 <rpc_dfu_event_handler+0x24>)
   2e2f0:	68c1      	ldr	r1, [r0, #12]
   2e2f2:	8812      	ldrh	r2, [r2, #0]
   2e2f4:	4603      	mov	r3, r0
   2e2f6:	ebb2 4f11 	cmp.w	r2, r1, lsr #16
   2e2fa:	d005      	beq.n	2e308 <rpc_dfu_event_handler+0x1c>
   2e2fc:	6800      	ldr	r0, [r0, #0]
   2e2fe:	b110      	cbz	r0, 2e306 <rpc_dfu_event_handler+0x1a>
   2e300:	f7fe ff06 	bl	2d110 <rpc_dfu_client_data_free>
   2e304:	2000      	movs	r0, #0
   2e306:	bd08      	pop	{r3, pc}
   2e308:	4a02      	ldr	r2, [pc, #8]	; (2e314 <rpc_dfu_event_handler+0x28>)
   2e30a:	2001      	movs	r0, #1
   2e30c:	6013      	str	r3, [r2, #0]
   2e30e:	bd08      	pop	{r3, pc}
   2e310:	2002990c 	.word	0x2002990c
   2e314:	20025168 	.word	0x20025168

0002e318 <mfu_interface_init>:
   2e318:	2300      	movs	r3, #0
   2e31a:	b510      	push	{r4, lr}
   2e31c:	4808      	ldr	r0, [pc, #32]	; (2e340 <mfu_interface_init+0x28>)
   2e31e:	4909      	ldr	r1, [pc, #36]	; (2e344 <mfu_interface_init+0x2c>)
   2e320:	4a09      	ldr	r2, [pc, #36]	; (2e348 <mfu_interface_init+0x30>)
   2e322:	4c0a      	ldr	r4, [pc, #40]	; (2e34c <mfu_interface_init+0x34>)
   2e324:	8003      	strh	r3, [r0, #0]
   2e326:	600b      	str	r3, [r1, #0]
   2e328:	6013      	str	r3, [r2, #0]
   2e32a:	6023      	str	r3, [r4, #0]
   2e32c:	f7fe feba 	bl	2d0a4 <rpc_dfu_client_init>
   2e330:	b910      	cbnz	r0, 2e338 <mfu_interface_init+0x20>
   2e332:	2301      	movs	r3, #1
   2e334:	6023      	str	r3, [r4, #0]
   2e336:	bd10      	pop	{r4, pc}
   2e338:	f04f 30ff 	mov.w	r0, #4294967295
   2e33c:	bd10      	pop	{r4, pc}
   2e33e:	bf00      	nop
   2e340:	2002990c 	.word	0x2002990c
   2e344:	20025168 	.word	0x20025168
   2e348:	20025164 	.word	0x20025164
   2e34c:	2002515c 	.word	0x2002515c

0002e350 <mfu_interface_open>:
   2e350:	b508      	push	{r3, lr}
   2e352:	4b07      	ldr	r3, [pc, #28]	; (2e370 <mfu_interface_open+0x20>)
   2e354:	681a      	ldr	r2, [r3, #0]
   2e356:	2a01      	cmp	r2, #1
   2e358:	d103      	bne.n	2e362 <mfu_interface_open+0x12>
   2e35a:	2202      	movs	r2, #2
   2e35c:	601a      	str	r2, [r3, #0]
   2e35e:	4805      	ldr	r0, [pc, #20]	; (2e374 <mfu_interface_open+0x24>)
   2e360:	bd08      	pop	{r3, pc}
   2e362:	2001      	movs	r0, #1
   2e364:	f7fc fc2e 	bl	2abc4 <bsd_os_errno_set>
   2e368:	f04f 30ff 	mov.w	r0, #4294967295
   2e36c:	bd08      	pop	{r3, pc}
   2e36e:	bf00      	nop
   2e370:	2002515c 	.word	0x2002515c
   2e374:	49765432 	.word	0x49765432

0002e378 <mfu_interface_close>:
   2e378:	b5f0      	push	{r4, r5, r6, r7, lr}
   2e37a:	4c32      	ldr	r4, [pc, #200]	; (2e444 <mfu_interface_close+0xcc>)
   2e37c:	b083      	sub	sp, #12
   2e37e:	6823      	ldr	r3, [r4, #0]
   2e380:	1e9a      	subs	r2, r3, #2
   2e382:	2a01      	cmp	r2, #1
   2e384:	d857      	bhi.n	2e436 <mfu_interface_close+0xbe>
   2e386:	2b03      	cmp	r3, #3
   2e388:	d004      	beq.n	2e394 <mfu_interface_close+0x1c>
   2e38a:	2301      	movs	r3, #1
   2e38c:	2000      	movs	r0, #0
   2e38e:	6023      	str	r3, [r4, #0]
   2e390:	b003      	add	sp, #12
   2e392:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2e394:	2100      	movs	r1, #0
   2e396:	4668      	mov	r0, sp
   2e398:	f7fe fe8a 	bl	2d0b0 <rpc_dfu_client_request_alloc>
   2e39c:	4603      	mov	r3, r0
   2e39e:	2800      	cmp	r0, #0
   2e3a0:	d13d      	bne.n	2e41e <mfu_interface_close+0xa6>
   2e3a2:	2104      	movs	r1, #4
   2e3a4:	4e28      	ldr	r6, [pc, #160]	; (2e448 <mfu_interface_close+0xd0>)
   2e3a6:	9800      	ldr	r0, [sp, #0]
   2e3a8:	8832      	ldrh	r2, [r6, #0]
   2e3aa:	7201      	strb	r1, [r0, #8]
   2e3ac:	3201      	adds	r2, #1
   2e3ae:	b292      	uxth	r2, r2
   2e3b0:	0411      	lsls	r1, r2, #16
   2e3b2:	f041 0106 	orr.w	r1, r1, #6
   2e3b6:	4d25      	ldr	r5, [pc, #148]	; (2e44c <mfu_interface_close+0xd4>)
   2e3b8:	60c1      	str	r1, [r0, #12]
   2e3ba:	7103      	strb	r3, [r0, #4]
   2e3bc:	7143      	strb	r3, [r0, #5]
   2e3be:	7183      	strb	r3, [r0, #6]
   2e3c0:	71c3      	strb	r3, [r0, #7]
   2e3c2:	7243      	strb	r3, [r0, #9]
   2e3c4:	7283      	strb	r3, [r0, #10]
   2e3c6:	72c3      	strb	r3, [r0, #11]
   2e3c8:	2106      	movs	r1, #6
   2e3ca:	8032      	strh	r2, [r6, #0]
   2e3cc:	602b      	str	r3, [r5, #0]
   2e3ce:	f7fe fe83 	bl	2d0d8 <rpc_dfu_client_request_send>
   2e3d2:	b9d8      	cbnz	r0, 2e40c <mfu_interface_close+0x94>
   2e3d4:	f04f 33ff 	mov.w	r3, #4294967295
   2e3d8:	ae02      	add	r6, sp, #8
   2e3da:	4627      	mov	r7, r4
   2e3dc:	f846 3d04 	str.w	r3, [r6, #-4]!
   2e3e0:	e004      	b.n	2e3ec <mfu_interface_close+0x74>
   2e3e2:	4631      	mov	r1, r6
   2e3e4:	4638      	mov	r0, r7
   2e3e6:	f7fc fb59 	bl	2aa9c <bsd_os_timedwait>
   2e3ea:	b9f0      	cbnz	r0, 2e42a <mfu_interface_close+0xb2>
   2e3ec:	6828      	ldr	r0, [r5, #0]
   2e3ee:	2800      	cmp	r0, #0
   2e3f0:	d0f7      	beq.n	2e3e2 <mfu_interface_close+0x6a>
   2e3f2:	6905      	ldr	r5, [r0, #16]
   2e3f4:	f7fe fe84 	bl	2d100 <rpc_dfu_client_message_free>
   2e3f8:	2d00      	cmp	r5, #0
   2e3fa:	d0c6      	beq.n	2e38a <mfu_interface_close+0x12>
   2e3fc:	4b14      	ldr	r3, [pc, #80]	; (2e450 <mfu_interface_close+0xd8>)
   2e3fe:	2008      	movs	r0, #8
   2e400:	601d      	str	r5, [r3, #0]
   2e402:	f7fc fbdf 	bl	2abc4 <bsd_os_errno_set>
   2e406:	f04f 30ff 	mov.w	r0, #4294967295
   2e40a:	e7c1      	b.n	2e390 <mfu_interface_close+0x18>
   2e40c:	9800      	ldr	r0, [sp, #0]
   2e40e:	6803      	ldr	r3, [r0, #0]
   2e410:	b11b      	cbz	r3, 2e41a <mfu_interface_close+0xa2>
   2e412:	4618      	mov	r0, r3
   2e414:	f7fe fe7c 	bl	2d110 <rpc_dfu_client_data_free>
   2e418:	9800      	ldr	r0, [sp, #0]
   2e41a:	f7fe fe71 	bl	2d100 <rpc_dfu_client_message_free>
   2e41e:	200c      	movs	r0, #12
   2e420:	f7fc fbd0 	bl	2abc4 <bsd_os_errno_set>
   2e424:	f04f 30ff 	mov.w	r0, #4294967295
   2e428:	e7b2      	b.n	2e390 <mfu_interface_close+0x18>
   2e42a:	203c      	movs	r0, #60	; 0x3c
   2e42c:	f7fc fbca 	bl	2abc4 <bsd_os_errno_set>
   2e430:	f04f 30ff 	mov.w	r0, #4294967295
   2e434:	e7ac      	b.n	2e390 <mfu_interface_close+0x18>
   2e436:	2001      	movs	r0, #1
   2e438:	f7fc fbc4 	bl	2abc4 <bsd_os_errno_set>
   2e43c:	f04f 30ff 	mov.w	r0, #4294967295
   2e440:	e7a6      	b.n	2e390 <mfu_interface_close+0x18>
   2e442:	bf00      	nop
   2e444:	2002515c 	.word	0x2002515c
   2e448:	2002990c 	.word	0x2002990c
   2e44c:	20025168 	.word	0x20025168
   2e450:	20025160 	.word	0x20025160

0002e454 <mfu_interface_sendto>:
   2e454:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2e458:	4e64      	ldr	r6, [pc, #400]	; (2e5ec <mfu_interface_sendto+0x198>)
   2e45a:	460f      	mov	r7, r1
   2e45c:	6831      	ldr	r1, [r6, #0]
   2e45e:	4615      	mov	r5, r2
   2e460:	1e8a      	subs	r2, r1, #2
   2e462:	2a01      	cmp	r2, #1
   2e464:	b082      	sub	sp, #8
   2e466:	f200 80b4 	bhi.w	2e5d2 <mfu_interface_sendto+0x17e>
   2e46a:	2f00      	cmp	r7, #0
   2e46c:	f000 80a5 	beq.w	2e5ba <mfu_interface_sendto+0x166>
   2e470:	2d00      	cmp	r5, #0
   2e472:	f000 80a2 	beq.w	2e5ba <mfu_interface_sendto+0x166>
   2e476:	2b00      	cmp	r3, #0
   2e478:	f040 80b1 	bne.w	2e5de <mfu_interface_sendto+0x18a>
   2e47c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2e47e:	2b00      	cmp	r3, #0
   2e480:	f040 80a1 	bne.w	2e5c6 <mfu_interface_sendto+0x172>
   2e484:	2902      	cmp	r1, #2
   2e486:	d04f      	beq.n	2e528 <mfu_interface_sendto+0xd4>
   2e488:	46e8      	mov	r8, sp
   2e48a:	4640      	mov	r0, r8
   2e48c:	4629      	mov	r1, r5
   2e48e:	f7fe fe0f 	bl	2d0b0 <rpc_dfu_client_request_alloc>
   2e492:	4606      	mov	r6, r0
   2e494:	b140      	cbz	r0, 2e4a8 <mfu_interface_sendto+0x54>
   2e496:	200c      	movs	r0, #12
   2e498:	f7fc fb94 	bl	2abc4 <bsd_os_errno_set>
   2e49c:	f04f 35ff 	mov.w	r5, #4294967295
   2e4a0:	4628      	mov	r0, r5
   2e4a2:	b002      	add	sp, #8
   2e4a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2e4a8:	9b00      	ldr	r3, [sp, #0]
   2e4aa:	4639      	mov	r1, r7
   2e4ac:	6818      	ldr	r0, [r3, #0]
   2e4ae:	462a      	mov	r2, r5
   2e4b0:	f010 f9cc 	bl	3e84c <memcpy>
   2e4b4:	2104      	movs	r1, #4
   2e4b6:	4c4e      	ldr	r4, [pc, #312]	; (2e5f0 <mfu_interface_sendto+0x19c>)
   2e4b8:	9800      	ldr	r0, [sp, #0]
   2e4ba:	8823      	ldrh	r3, [r4, #0]
   2e4bc:	6045      	str	r5, [r0, #4]
   2e4be:	3301      	adds	r3, #1
   2e4c0:	b29b      	uxth	r3, r3
   2e4c2:	041a      	lsls	r2, r3, #16
   2e4c4:	8023      	strh	r3, [r4, #0]
   2e4c6:	430a      	orrs	r2, r1
   2e4c8:	4c4a      	ldr	r4, [pc, #296]	; (2e5f4 <mfu_interface_sendto+0x1a0>)
   2e4ca:	60c2      	str	r2, [r0, #12]
   2e4cc:	7246      	strb	r6, [r0, #9]
   2e4ce:	7286      	strb	r6, [r0, #10]
   2e4d0:	72c6      	strb	r6, [r0, #11]
   2e4d2:	7201      	strb	r1, [r0, #8]
   2e4d4:	6026      	str	r6, [r4, #0]
   2e4d6:	f7fe fdff 	bl	2d0d8 <rpc_dfu_client_request_send>
   2e4da:	2800      	cmp	r0, #0
   2e4dc:	d163      	bne.n	2e5a6 <mfu_interface_sendto+0x152>
   2e4de:	f04f 33ff 	mov.w	r3, #4294967295
   2e4e2:	ae02      	add	r6, sp, #8
   2e4e4:	4f41      	ldr	r7, [pc, #260]	; (2e5ec <mfu_interface_sendto+0x198>)
   2e4e6:	f846 3d04 	str.w	r3, [r6, #-4]!
   2e4ea:	e004      	b.n	2e4f6 <mfu_interface_sendto+0xa2>
   2e4ec:	4631      	mov	r1, r6
   2e4ee:	4638      	mov	r0, r7
   2e4f0:	f7fc fad4 	bl	2aa9c <bsd_os_timedwait>
   2e4f4:	b978      	cbnz	r0, 2e516 <mfu_interface_sendto+0xc2>
   2e4f6:	6820      	ldr	r0, [r4, #0]
   2e4f8:	2800      	cmp	r0, #0
   2e4fa:	d0f7      	beq.n	2e4ec <mfu_interface_sendto+0x98>
   2e4fc:	6904      	ldr	r4, [r0, #16]
   2e4fe:	f7fe fdff 	bl	2d100 <rpc_dfu_client_message_free>
   2e502:	2c00      	cmp	r4, #0
   2e504:	d0cc      	beq.n	2e4a0 <mfu_interface_sendto+0x4c>
   2e506:	4b3c      	ldr	r3, [pc, #240]	; (2e5f8 <mfu_interface_sendto+0x1a4>)
   2e508:	2008      	movs	r0, #8
   2e50a:	601c      	str	r4, [r3, #0]
   2e50c:	f04f 35ff 	mov.w	r5, #4294967295
   2e510:	f7fc fb58 	bl	2abc4 <bsd_os_errno_set>
   2e514:	e7c4      	b.n	2e4a0 <mfu_interface_sendto+0x4c>
   2e516:	f04f 35ff 	mov.w	r5, #4294967295
   2e51a:	203c      	movs	r0, #60	; 0x3c
   2e51c:	f7fc fb52 	bl	2abc4 <bsd_os_errno_set>
   2e520:	4628      	mov	r0, r5
   2e522:	b002      	add	sp, #8
   2e524:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2e528:	46e8      	mov	r8, sp
   2e52a:	4619      	mov	r1, r3
   2e52c:	4640      	mov	r0, r8
   2e52e:	f7fe fdbf 	bl	2d0b0 <rpc_dfu_client_request_alloc>
   2e532:	4602      	mov	r2, r0
   2e534:	2800      	cmp	r0, #0
   2e536:	d1ae      	bne.n	2e496 <mfu_interface_sendto+0x42>
   2e538:	f04f 0c08 	mov.w	ip, #8
   2e53c:	492c      	ldr	r1, [pc, #176]	; (2e5f0 <mfu_interface_sendto+0x19c>)
   2e53e:	482f      	ldr	r0, [pc, #188]	; (2e5fc <mfu_interface_sendto+0x1a8>)
   2e540:	880b      	ldrh	r3, [r1, #0]
   2e542:	6804      	ldr	r4, [r0, #0]
   2e544:	3301      	adds	r3, #1
   2e546:	9800      	ldr	r0, [sp, #0]
   2e548:	b29b      	uxth	r3, r3
   2e54a:	800b      	strh	r3, [r1, #0]
   2e54c:	041b      	lsls	r3, r3, #16
   2e54e:	f043 0303 	orr.w	r3, r3, #3
   2e552:	6104      	str	r4, [r0, #16]
   2e554:	4c27      	ldr	r4, [pc, #156]	; (2e5f4 <mfu_interface_sendto+0x1a0>)
   2e556:	60c3      	str	r3, [r0, #12]
   2e558:	7102      	strb	r2, [r0, #4]
   2e55a:	7142      	strb	r2, [r0, #5]
   2e55c:	7182      	strb	r2, [r0, #6]
   2e55e:	71c2      	strb	r2, [r0, #7]
   2e560:	7242      	strb	r2, [r0, #9]
   2e562:	7282      	strb	r2, [r0, #10]
   2e564:	72c2      	strb	r2, [r0, #11]
   2e566:	f880 c008 	strb.w	ip, [r0, #8]
   2e56a:	2103      	movs	r1, #3
   2e56c:	6022      	str	r2, [r4, #0]
   2e56e:	f7fe fdb3 	bl	2d0d8 <rpc_dfu_client_request_send>
   2e572:	b9c0      	cbnz	r0, 2e5a6 <mfu_interface_sendto+0x152>
   2e574:	f04f 33ff 	mov.w	r3, #4294967295
   2e578:	f10d 0908 	add.w	r9, sp, #8
   2e57c:	f849 3d04 	str.w	r3, [r9, #-4]!
   2e580:	46b2      	mov	sl, r6
   2e582:	e005      	b.n	2e590 <mfu_interface_sendto+0x13c>
   2e584:	4649      	mov	r1, r9
   2e586:	4650      	mov	r0, sl
   2e588:	f7fc fa88 	bl	2aa9c <bsd_os_timedwait>
   2e58c:	2800      	cmp	r0, #0
   2e58e:	d1c2      	bne.n	2e516 <mfu_interface_sendto+0xc2>
   2e590:	6820      	ldr	r0, [r4, #0]
   2e592:	2800      	cmp	r0, #0
   2e594:	d0f6      	beq.n	2e584 <mfu_interface_sendto+0x130>
   2e596:	6904      	ldr	r4, [r0, #16]
   2e598:	f7fe fdb2 	bl	2d100 <rpc_dfu_client_message_free>
   2e59c:	2c00      	cmp	r4, #0
   2e59e:	d1b2      	bne.n	2e506 <mfu_interface_sendto+0xb2>
   2e5a0:	2303      	movs	r3, #3
   2e5a2:	6033      	str	r3, [r6, #0]
   2e5a4:	e771      	b.n	2e48a <mfu_interface_sendto+0x36>
   2e5a6:	9800      	ldr	r0, [sp, #0]
   2e5a8:	6803      	ldr	r3, [r0, #0]
   2e5aa:	b11b      	cbz	r3, 2e5b4 <mfu_interface_sendto+0x160>
   2e5ac:	4618      	mov	r0, r3
   2e5ae:	f7fe fdaf 	bl	2d110 <rpc_dfu_client_data_free>
   2e5b2:	9800      	ldr	r0, [sp, #0]
   2e5b4:	f7fe fda4 	bl	2d100 <rpc_dfu_client_message_free>
   2e5b8:	e76d      	b.n	2e496 <mfu_interface_sendto+0x42>
   2e5ba:	2016      	movs	r0, #22
   2e5bc:	f7fc fb02 	bl	2abc4 <bsd_os_errno_set>
   2e5c0:	f04f 35ff 	mov.w	r5, #4294967295
   2e5c4:	e76c      	b.n	2e4a0 <mfu_interface_sendto+0x4c>
   2e5c6:	2038      	movs	r0, #56	; 0x38
   2e5c8:	f7fc fafc 	bl	2abc4 <bsd_os_errno_set>
   2e5cc:	f04f 35ff 	mov.w	r5, #4294967295
   2e5d0:	e766      	b.n	2e4a0 <mfu_interface_sendto+0x4c>
   2e5d2:	2001      	movs	r0, #1
   2e5d4:	f7fc faf6 	bl	2abc4 <bsd_os_errno_set>
   2e5d8:	f04f 35ff 	mov.w	r5, #4294967295
   2e5dc:	e760      	b.n	2e4a0 <mfu_interface_sendto+0x4c>
   2e5de:	202d      	movs	r0, #45	; 0x2d
   2e5e0:	f7fc faf0 	bl	2abc4 <bsd_os_errno_set>
   2e5e4:	f04f 35ff 	mov.w	r5, #4294967295
   2e5e8:	e75a      	b.n	2e4a0 <mfu_interface_sendto+0x4c>
   2e5ea:	bf00      	nop
   2e5ec:	2002515c 	.word	0x2002515c
   2e5f0:	2002990c 	.word	0x2002990c
   2e5f4:	20025168 	.word	0x20025168
   2e5f8:	20025160 	.word	0x20025160
   2e5fc:	20025164 	.word	0x20025164

0002e600 <mfu_interface_setopt>:
   2e600:	b5f0      	push	{r4, r5, r6, r7, lr}
   2e602:	4846      	ldr	r0, [pc, #280]	; (2e71c <mfu_interface_setopt+0x11c>)
   2e604:	b083      	sub	sp, #12
   2e606:	6800      	ldr	r0, [r0, #0]
   2e608:	3802      	subs	r0, #2
   2e60a:	2801      	cmp	r0, #1
   2e60c:	d877      	bhi.n	2e6fe <mfu_interface_setopt+0xfe>
   2e60e:	f240 2003 	movw	r0, #515	; 0x203
   2e612:	4281      	cmp	r1, r0
   2e614:	d16d      	bne.n	2e6f2 <mfu_interface_setopt+0xf2>
   2e616:	3a04      	subs	r2, #4
   2e618:	2a03      	cmp	r2, #3
   2e61a:	d85c      	bhi.n	2e6d6 <mfu_interface_setopt+0xd6>
   2e61c:	e8df f002 	tbb	[pc, r2]
   2e620:	514e024b 	.word	0x514e024b
   2e624:	2407      	movs	r4, #7
   2e626:	4625      	mov	r5, r4
   2e628:	2100      	movs	r1, #0
   2e62a:	4668      	mov	r0, sp
   2e62c:	f7fe fd40 	bl	2d0b0 <rpc_dfu_client_request_alloc>
   2e630:	4603      	mov	r3, r0
   2e632:	2800      	cmp	r0, #0
   2e634:	d138      	bne.n	2e6a8 <mfu_interface_setopt+0xa8>
   2e636:	2704      	movs	r7, #4
   2e638:	4e39      	ldr	r6, [pc, #228]	; (2e720 <mfu_interface_setopt+0x120>)
   2e63a:	9800      	ldr	r0, [sp, #0]
   2e63c:	8832      	ldrh	r2, [r6, #0]
   2e63e:	4629      	mov	r1, r5
   2e640:	3201      	adds	r2, #1
   2e642:	b292      	uxth	r2, r2
   2e644:	ea44 4502 	orr.w	r5, r4, r2, lsl #16
   2e648:	4c36      	ldr	r4, [pc, #216]	; (2e724 <mfu_interface_setopt+0x124>)
   2e64a:	60c5      	str	r5, [r0, #12]
   2e64c:	7103      	strb	r3, [r0, #4]
   2e64e:	7143      	strb	r3, [r0, #5]
   2e650:	7183      	strb	r3, [r0, #6]
   2e652:	71c3      	strb	r3, [r0, #7]
   2e654:	7243      	strb	r3, [r0, #9]
   2e656:	7283      	strb	r3, [r0, #10]
   2e658:	72c3      	strb	r3, [r0, #11]
   2e65a:	7207      	strb	r7, [r0, #8]
   2e65c:	8032      	strh	r2, [r6, #0]
   2e65e:	6023      	str	r3, [r4, #0]
   2e660:	f7fe fd3a 	bl	2d0d8 <rpc_dfu_client_request_send>
   2e664:	b9b8      	cbnz	r0, 2e696 <mfu_interface_setopt+0x96>
   2e666:	f04f 33ff 	mov.w	r3, #4294967295
   2e66a:	ad02      	add	r5, sp, #8
   2e66c:	4e2b      	ldr	r6, [pc, #172]	; (2e71c <mfu_interface_setopt+0x11c>)
   2e66e:	f845 3d04 	str.w	r3, [r5, #-4]!
   2e672:	e005      	b.n	2e680 <mfu_interface_setopt+0x80>
   2e674:	4629      	mov	r1, r5
   2e676:	4630      	mov	r0, r6
   2e678:	f7fc fa10 	bl	2aa9c <bsd_os_timedwait>
   2e67c:	2800      	cmp	r0, #0
   2e67e:	d131      	bne.n	2e6e4 <mfu_interface_setopt+0xe4>
   2e680:	6820      	ldr	r0, [r4, #0]
   2e682:	2800      	cmp	r0, #0
   2e684:	d0f6      	beq.n	2e674 <mfu_interface_setopt+0x74>
   2e686:	6904      	ldr	r4, [r0, #16]
   2e688:	f7fe fd3a 	bl	2d100 <rpc_dfu_client_message_free>
   2e68c:	2c00      	cmp	r4, #0
   2e68e:	d13c      	bne.n	2e70a <mfu_interface_setopt+0x10a>
   2e690:	4620      	mov	r0, r4
   2e692:	b003      	add	sp, #12
   2e694:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2e696:	9800      	ldr	r0, [sp, #0]
   2e698:	6803      	ldr	r3, [r0, #0]
   2e69a:	b11b      	cbz	r3, 2e6a4 <mfu_interface_setopt+0xa4>
   2e69c:	4618      	mov	r0, r3
   2e69e:	f7fe fd37 	bl	2d110 <rpc_dfu_client_data_free>
   2e6a2:	9800      	ldr	r0, [sp, #0]
   2e6a4:	f7fe fd2c 	bl	2d100 <rpc_dfu_client_message_free>
   2e6a8:	200c      	movs	r0, #12
   2e6aa:	f7fc fa8b 	bl	2abc4 <bsd_os_errno_set>
   2e6ae:	f04f 30ff 	mov.w	r0, #4294967295
   2e6b2:	b003      	add	sp, #12
   2e6b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2e6b6:	2405      	movs	r4, #5
   2e6b8:	4625      	mov	r5, r4
   2e6ba:	e7b5      	b.n	2e628 <mfu_interface_setopt+0x28>
   2e6bc:	2408      	movs	r4, #8
   2e6be:	4625      	mov	r5, r4
   2e6c0:	e7b2      	b.n	2e628 <mfu_interface_setopt+0x28>
   2e6c2:	b1b3      	cbz	r3, 2e6f2 <mfu_interface_setopt+0xf2>
   2e6c4:	9a08      	ldr	r2, [sp, #32]
   2e6c6:	2a04      	cmp	r2, #4
   2e6c8:	d113      	bne.n	2e6f2 <mfu_interface_setopt+0xf2>
   2e6ca:	2000      	movs	r0, #0
   2e6cc:	681a      	ldr	r2, [r3, #0]
   2e6ce:	4b16      	ldr	r3, [pc, #88]	; (2e728 <mfu_interface_setopt+0x128>)
   2e6d0:	601a      	str	r2, [r3, #0]
   2e6d2:	b003      	add	sp, #12
   2e6d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2e6d6:	202a      	movs	r0, #42	; 0x2a
   2e6d8:	f7fc fa74 	bl	2abc4 <bsd_os_errno_set>
   2e6dc:	f04f 30ff 	mov.w	r0, #4294967295
   2e6e0:	b003      	add	sp, #12
   2e6e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2e6e4:	203c      	movs	r0, #60	; 0x3c
   2e6e6:	f7fc fa6d 	bl	2abc4 <bsd_os_errno_set>
   2e6ea:	f04f 30ff 	mov.w	r0, #4294967295
   2e6ee:	b003      	add	sp, #12
   2e6f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2e6f2:	2016      	movs	r0, #22
   2e6f4:	f7fc fa66 	bl	2abc4 <bsd_os_errno_set>
   2e6f8:	f04f 30ff 	mov.w	r0, #4294967295
   2e6fc:	e7c9      	b.n	2e692 <mfu_interface_setopt+0x92>
   2e6fe:	2001      	movs	r0, #1
   2e700:	f7fc fa60 	bl	2abc4 <bsd_os_errno_set>
   2e704:	f04f 30ff 	mov.w	r0, #4294967295
   2e708:	e7c3      	b.n	2e692 <mfu_interface_setopt+0x92>
   2e70a:	4b08      	ldr	r3, [pc, #32]	; (2e72c <mfu_interface_setopt+0x12c>)
   2e70c:	2008      	movs	r0, #8
   2e70e:	601c      	str	r4, [r3, #0]
   2e710:	f7fc fa58 	bl	2abc4 <bsd_os_errno_set>
   2e714:	f04f 30ff 	mov.w	r0, #4294967295
   2e718:	e7bb      	b.n	2e692 <mfu_interface_setopt+0x92>
   2e71a:	bf00      	nop
   2e71c:	2002515c 	.word	0x2002515c
   2e720:	2002990c 	.word	0x2002990c
   2e724:	20025168 	.word	0x20025168
   2e728:	20025164 	.word	0x20025164
   2e72c:	20025160 	.word	0x20025160

0002e730 <mfu_interface_getopt>:
   2e730:	f240 2003 	movw	r0, #515	; 0x203
   2e734:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2e738:	4281      	cmp	r1, r0
   2e73a:	b082      	sub	sp, #8
   2e73c:	9e08      	ldr	r6, [sp, #32]
   2e73e:	f040 80ae 	bne.w	2e89e <mfu_interface_getopt+0x16e>
   2e742:	461d      	mov	r5, r3
   2e744:	2b00      	cmp	r3, #0
   2e746:	f000 80aa 	beq.w	2e89e <mfu_interface_getopt+0x16e>
   2e74a:	2e00      	cmp	r6, #0
   2e74c:	f000 80a7 	beq.w	2e89e <mfu_interface_getopt+0x16e>
   2e750:	4b5e      	ldr	r3, [pc, #376]	; (2e8cc <mfu_interface_getopt+0x19c>)
   2e752:	681b      	ldr	r3, [r3, #0]
   2e754:	3b02      	subs	r3, #2
   2e756:	2b01      	cmp	r3, #1
   2e758:	f200 80a7 	bhi.w	2e8aa <mfu_interface_getopt+0x17a>
   2e75c:	3a01      	subs	r2, #1
   2e75e:	2a13      	cmp	r2, #19
   2e760:	d879      	bhi.n	2e856 <mfu_interface_getopt+0x126>
   2e762:	e8df f002 	tbb	[pc, r2]
   2e766:	5f17      	.short	0x5f17
   2e768:	78787878 	.word	0x78787878
   2e76c:	78787872 	.word	0x78787872
   2e770:	78787878 	.word	0x78787878
   2e774:	78787878 	.word	0x78787878
   2e778:	0a78      	.short	0x0a78
   2e77a:	6833      	ldr	r3, [r6, #0]
   2e77c:	2b04      	cmp	r3, #4
   2e77e:	f040 808e 	bne.w	2e89e <mfu_interface_getopt+0x16e>
   2e782:	2200      	movs	r2, #0
   2e784:	4610      	mov	r0, r2
   2e786:	4b52      	ldr	r3, [pc, #328]	; (2e8d0 <mfu_interface_getopt+0x1a0>)
   2e788:	6819      	ldr	r1, [r3, #0]
   2e78a:	601a      	str	r2, [r3, #0]
   2e78c:	6029      	str	r1, [r5, #0]
   2e78e:	b002      	add	sp, #8
   2e790:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2e794:	6833      	ldr	r3, [r6, #0]
   2e796:	2b24      	cmp	r3, #36	; 0x24
   2e798:	f040 8081 	bne.w	2e89e <mfu_interface_getopt+0x16e>
   2e79c:	2401      	movs	r4, #1
   2e79e:	46a0      	mov	r8, r4
   2e7a0:	2100      	movs	r1, #0
   2e7a2:	4668      	mov	r0, sp
   2e7a4:	f7fe fc84 	bl	2d0b0 <rpc_dfu_client_request_alloc>
   2e7a8:	2800      	cmp	r0, #0
   2e7aa:	d146      	bne.n	2e83a <mfu_interface_getopt+0x10a>
   2e7ac:	4949      	ldr	r1, [pc, #292]	; (2e8d4 <mfu_interface_getopt+0x1a4>)
   2e7ae:	9b00      	ldr	r3, [sp, #0]
   2e7b0:	880a      	ldrh	r2, [r1, #0]
   2e7b2:	f1b8 0f03 	cmp.w	r8, #3
   2e7b6:	f102 0201 	add.w	r2, r2, #1
   2e7ba:	b292      	uxth	r2, r2
   2e7bc:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
   2e7c0:	7118      	strb	r0, [r3, #4]
   2e7c2:	800a      	strh	r2, [r1, #0]
   2e7c4:	60dc      	str	r4, [r3, #12]
   2e7c6:	7158      	strb	r0, [r3, #5]
   2e7c8:	7198      	strb	r0, [r3, #6]
   2e7ca:	71d8      	strb	r0, [r3, #7]
   2e7cc:	d04b      	beq.n	2e866 <mfu_interface_getopt+0x136>
   2e7ce:	2104      	movs	r1, #4
   2e7d0:	2200      	movs	r2, #0
   2e7d2:	4f41      	ldr	r7, [pc, #260]	; (2e8d8 <mfu_interface_getopt+0x1a8>)
   2e7d4:	6099      	str	r1, [r3, #8]
   2e7d6:	4618      	mov	r0, r3
   2e7d8:	4641      	mov	r1, r8
   2e7da:	603a      	str	r2, [r7, #0]
   2e7dc:	f7fe fc7c 	bl	2d0d8 <rpc_dfu_client_request_send>
   2e7e0:	2800      	cmp	r0, #0
   2e7e2:	d14d      	bne.n	2e880 <mfu_interface_getopt+0x150>
   2e7e4:	f04f 33ff 	mov.w	r3, #4294967295
   2e7e8:	ac02      	add	r4, sp, #8
   2e7ea:	f844 3d04 	str.w	r3, [r4, #-4]!
   2e7ee:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 2e8cc <mfu_interface_getopt+0x19c>
   2e7f2:	e005      	b.n	2e800 <mfu_interface_getopt+0xd0>
   2e7f4:	4621      	mov	r1, r4
   2e7f6:	4640      	mov	r0, r8
   2e7f8:	f7fc f950 	bl	2aa9c <bsd_os_timedwait>
   2e7fc:	2800      	cmp	r0, #0
   2e7fe:	d137      	bne.n	2e870 <mfu_interface_getopt+0x140>
   2e800:	6839      	ldr	r1, [r7, #0]
   2e802:	2900      	cmp	r1, #0
   2e804:	d0f6      	beq.n	2e7f4 <mfu_interface_getopt+0xc4>
   2e806:	690c      	ldr	r4, [r1, #16]
   2e808:	2c00      	cmp	r4, #0
   2e80a:	d154      	bne.n	2e8b6 <mfu_interface_getopt+0x186>
   2e80c:	6832      	ldr	r2, [r6, #0]
   2e80e:	3114      	adds	r1, #20
   2e810:	4628      	mov	r0, r5
   2e812:	f010 f81b 	bl	3e84c <memcpy>
   2e816:	6838      	ldr	r0, [r7, #0]
   2e818:	f7fe fc72 	bl	2d100 <rpc_dfu_client_message_free>
   2e81c:	4620      	mov	r0, r4
   2e81e:	b002      	add	sp, #8
   2e820:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2e824:	6833      	ldr	r3, [r6, #0]
   2e826:	2b04      	cmp	r3, #4
   2e828:	d139      	bne.n	2e89e <mfu_interface_getopt+0x16e>
   2e82a:	2402      	movs	r4, #2
   2e82c:	2100      	movs	r1, #0
   2e82e:	4668      	mov	r0, sp
   2e830:	46a0      	mov	r8, r4
   2e832:	f7fe fc3d 	bl	2d0b0 <rpc_dfu_client_request_alloc>
   2e836:	2800      	cmp	r0, #0
   2e838:	d0b8      	beq.n	2e7ac <mfu_interface_getopt+0x7c>
   2e83a:	200c      	movs	r0, #12
   2e83c:	f7fc f9c2 	bl	2abc4 <bsd_os_errno_set>
   2e840:	f04f 30ff 	mov.w	r0, #4294967295
   2e844:	b002      	add	sp, #8
   2e846:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2e84a:	6833      	ldr	r3, [r6, #0]
   2e84c:	2b04      	cmp	r3, #4
   2e84e:	d126      	bne.n	2e89e <mfu_interface_getopt+0x16e>
   2e850:	2409      	movs	r4, #9
   2e852:	46a0      	mov	r8, r4
   2e854:	e7a4      	b.n	2e7a0 <mfu_interface_getopt+0x70>
   2e856:	202a      	movs	r0, #42	; 0x2a
   2e858:	f7fc f9b4 	bl	2abc4 <bsd_os_errno_set>
   2e85c:	f04f 30ff 	mov.w	r0, #4294967295
   2e860:	b002      	add	sp, #8
   2e862:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2e866:	4a1d      	ldr	r2, [pc, #116]	; (2e8dc <mfu_interface_getopt+0x1ac>)
   2e868:	2108      	movs	r1, #8
   2e86a:	6812      	ldr	r2, [r2, #0]
   2e86c:	611a      	str	r2, [r3, #16]
   2e86e:	e7af      	b.n	2e7d0 <mfu_interface_getopt+0xa0>
   2e870:	203c      	movs	r0, #60	; 0x3c
   2e872:	f7fc f9a7 	bl	2abc4 <bsd_os_errno_set>
   2e876:	f04f 30ff 	mov.w	r0, #4294967295
   2e87a:	b002      	add	sp, #8
   2e87c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2e880:	9800      	ldr	r0, [sp, #0]
   2e882:	6803      	ldr	r3, [r0, #0]
   2e884:	b11b      	cbz	r3, 2e88e <mfu_interface_getopt+0x15e>
   2e886:	4618      	mov	r0, r3
   2e888:	f7fe fc42 	bl	2d110 <rpc_dfu_client_data_free>
   2e88c:	9800      	ldr	r0, [sp, #0]
   2e88e:	f7fe fc37 	bl	2d100 <rpc_dfu_client_message_free>
   2e892:	200c      	movs	r0, #12
   2e894:	f7fc f996 	bl	2abc4 <bsd_os_errno_set>
   2e898:	f04f 30ff 	mov.w	r0, #4294967295
   2e89c:	e7d2      	b.n	2e844 <mfu_interface_getopt+0x114>
   2e89e:	2016      	movs	r0, #22
   2e8a0:	f7fc f990 	bl	2abc4 <bsd_os_errno_set>
   2e8a4:	f04f 30ff 	mov.w	r0, #4294967295
   2e8a8:	e771      	b.n	2e78e <mfu_interface_getopt+0x5e>
   2e8aa:	2001      	movs	r0, #1
   2e8ac:	f7fc f98a 	bl	2abc4 <bsd_os_errno_set>
   2e8b0:	f04f 30ff 	mov.w	r0, #4294967295
   2e8b4:	e76b      	b.n	2e78e <mfu_interface_getopt+0x5e>
   2e8b6:	4b06      	ldr	r3, [pc, #24]	; (2e8d0 <mfu_interface_getopt+0x1a0>)
   2e8b8:	2008      	movs	r0, #8
   2e8ba:	601c      	str	r4, [r3, #0]
   2e8bc:	f7fc f982 	bl	2abc4 <bsd_os_errno_set>
   2e8c0:	6838      	ldr	r0, [r7, #0]
   2e8c2:	f7fe fc1d 	bl	2d100 <rpc_dfu_client_message_free>
   2e8c6:	f04f 30ff 	mov.w	r0, #4294967295
   2e8ca:	e760      	b.n	2e78e <mfu_interface_getopt+0x5e>
   2e8cc:	2002515c 	.word	0x2002515c
   2e8d0:	20025160 	.word	0x20025160
   2e8d4:	2002990c 	.word	0x2002990c
   2e8d8:	20025168 	.word	0x20025168
   2e8dc:	20025164 	.word	0x20025164

0002e8e0 <bsd_recoverable_error_handler>:
   2e8e0:	4770      	bx	lr
   2e8e2:	bf00      	nop

0002e8e4 <bsd_platform_error_handler>:
   2e8e4:	b508      	push	{r3, lr}
   2e8e6:	f7ff fffb 	bl	2e8e0 <bsd_recoverable_error_handler>
   2e8ea:	bd08      	pop	{r3, pc}

0002e8ec <bsd_init>:
   2e8ec:	b510      	push	{r4, lr}
   2e8ee:	4c06      	ldr	r4, [pc, #24]	; (2e908 <bsd_init+0x1c>)
   2e8f0:	7823      	ldrb	r3, [r4, #0]
   2e8f2:	b92b      	cbnz	r3, 2e900 <bsd_init+0x14>
   2e8f4:	f000 f818 	bl	2e928 <bsd_platform_init>
   2e8f8:	b908      	cbnz	r0, 2e8fe <bsd_init+0x12>
   2e8fa:	2301      	movs	r3, #1
   2e8fc:	7023      	strb	r3, [r4, #0]
   2e8fe:	bd10      	pop	{r4, pc}
   2e900:	f04f 30ff 	mov.w	r0, #4294967295
   2e904:	bd10      	pop	{r4, pc}
   2e906:	bf00      	nop
   2e908:	2002d7ee 	.word	0x2002d7ee

0002e90c <unimplemented_method>:
   2e90c:	b40f      	push	{r0, r1, r2, r3}
   2e90e:	b508      	push	{r3, lr}
   2e910:	202d      	movs	r0, #45	; 0x2d
   2e912:	f7fc f957 	bl	2abc4 <bsd_os_errno_set>
   2e916:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   2e91a:	f04f 30ff 	mov.w	r0, #4294967295
   2e91e:	b004      	add	sp, #16
   2e920:	4770      	bx	lr
   2e922:	bf00      	nop

0002e924 <rpc_transport_ipc_fault_handler>:
   2e924:	f7ff bfde 	b.w	2e8e4 <bsd_platform_error_handler>

0002e928 <bsd_platform_init>:
   2e928:	b5f0      	push	{r4, r5, r6, r7, lr}
   2e92a:	b093      	sub	sp, #76	; 0x4c
   2e92c:	f7fe fe28 	bl	2d580 <nrf_mem_init>
   2e930:	2800      	cmp	r0, #0
   2e932:	d14c      	bne.n	2e9ce <bsd_platform_init+0xa6>
   2e934:	4928      	ldr	r1, [pc, #160]	; (2e9d8 <bsd_platform_init+0xb0>)
   2e936:	a801      	add	r0, sp, #4
   2e938:	f7fe fe96 	bl	2d668 <nrf_mem_register>
   2e93c:	2800      	cmp	r0, #0
   2e93e:	d146      	bne.n	2e9ce <bsd_platform_init+0xa6>
   2e940:	f7fc fa58 	bl	2adf4 <bsd_os_init>
   2e944:	f004 f9fa 	bl	32d3c <rpc_framework_init>
   2e948:	2800      	cmp	r0, #0
   2e94a:	d140      	bne.n	2e9ce <bsd_platform_init+0xa6>
   2e94c:	2320      	movs	r3, #32
   2e94e:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   2e952:	2208      	movs	r2, #8
   2e954:	f44f 5c40 	mov.w	ip, #12288	; 0x3000
   2e958:	4f20      	ldr	r7, [pc, #128]	; (2e9dc <bsd_platform_init+0xb4>)
   2e95a:	4e21      	ldr	r6, [pc, #132]	; (2e9e0 <bsd_platform_init+0xb8>)
   2e95c:	9303      	str	r3, [sp, #12]
   2e95e:	9305      	str	r3, [sp, #20]
   2e960:	9307      	str	r3, [sp, #28]
   2e962:	4d20      	ldr	r5, [pc, #128]	; (2e9e4 <bsd_platform_init+0xbc>)
   2e964:	9109      	str	r1, [sp, #36]	; 0x24
   2e966:	910d      	str	r1, [sp, #52]	; 0x34
   2e968:	4c1f      	ldr	r4, [pc, #124]	; (2e9e8 <bsd_platform_init+0xc0>)
   2e96a:	4920      	ldr	r1, [pc, #128]	; (2e9ec <bsd_platform_init+0xc4>)
   2e96c:	4b20      	ldr	r3, [pc, #128]	; (2e9f0 <bsd_platform_init+0xc8>)
   2e96e:	e9cd 0010 	strd	r0, r0, [sp, #64]	; 0x40
   2e972:	eb0d 0002 	add.w	r0, sp, r2
   2e976:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
   2e97a:	e9cd 220e 	strd	r2, r2, [sp, #56]	; 0x38
   2e97e:	9702      	str	r7, [sp, #8]
   2e980:	9604      	str	r6, [sp, #16]
   2e982:	9506      	str	r5, [sp, #24]
   2e984:	9408      	str	r4, [sp, #32]
   2e986:	910a      	str	r1, [sp, #40]	; 0x28
   2e988:	930c      	str	r3, [sp, #48]	; 0x30
   2e98a:	f000 fbe9 	bl	2f160 <rpc_transport_ipc_init>
   2e98e:	b108      	cbz	r0, 2e994 <bsd_platform_init+0x6c>
   2e990:	b013      	add	sp, #76	; 0x4c
   2e992:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2e994:	f003 ff6e 	bl	32874 <interface_init>
   2e998:	b9c8      	cbnz	r0, 2e9ce <bsd_platform_init+0xa6>
   2e99a:	f7fe fa3b 	bl	2ce14 <at_interface_init>
   2e99e:	b9b0      	cbnz	r0, 2e9ce <bsd_platform_init+0xa6>
   2e9a0:	f002 fc22 	bl	311e8 <ip_interface_init>
   2e9a4:	b998      	cbnz	r0, 2e9ce <bsd_platform_init+0xa6>
   2e9a6:	f7ff f881 	bl	2daac <tls_interface_init>
   2e9aa:	b980      	cbnz	r0, 2e9ce <bsd_platform_init+0xa6>
   2e9ac:	f7ff fcb4 	bl	2e318 <mfu_interface_init>
   2e9b0:	b968      	cbnz	r0, 2e9ce <bsd_platform_init+0xa6>
   2e9b2:	f001 f9e9 	bl	2fd88 <pdn_interface_init>
   2e9b6:	b950      	cbnz	r0, 2e9ce <bsd_platform_init+0xa6>
   2e9b8:	f005 fc94 	bl	342e4 <gnss_interface_init>
   2e9bc:	b938      	cbnz	r0, 2e9ce <bsd_platform_init+0xa6>
   2e9be:	f7fd fec1 	bl	2c744 <logobj_interface_init>
   2e9c2:	3000      	adds	r0, #0
   2e9c4:	bf18      	it	ne
   2e9c6:	2001      	movne	r0, #1
   2e9c8:	4240      	negs	r0, r0
   2e9ca:	b013      	add	sp, #76	; 0x4c
   2e9cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2e9ce:	f04f 30ff 	mov.w	r0, #4294967295
   2e9d2:	b013      	add	sp, #76	; 0x4c
   2e9d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2e9d6:	bf00      	nop
   2e9d8:	000401dc 	.word	0x000401dc
   2e9dc:	20010000 	.word	0x20010000
   2e9e0:	20010040 	.word	0x20010040
   2e9e4:	20010020 	.word	0x20010020
   2e9e8:	20017060 	.word	0x20017060
   2e9ec:	20010060 	.word	0x20010060
   2e9f0:	20013060 	.word	0x20013060

0002e9f4 <bsd_platform_af_method_table_get>:
   2e9f4:	2805      	cmp	r0, #5
   2e9f6:	d02a      	beq.n	2ea4e <bsd_platform_af_method_table_get+0x5a>
   2e9f8:	b508      	push	{r3, lr}
   2e9fa:	d914      	bls.n	2ea26 <bsd_platform_af_method_table_get+0x32>
   2e9fc:	280a      	cmp	r0, #10
   2e9fe:	d016      	beq.n	2ea2e <bsd_platform_af_method_table_get+0x3a>
   2ea00:	2866      	cmp	r0, #102	; 0x66
   2ea02:	d11f      	bne.n	2ea44 <bsd_platform_af_method_table_get+0x50>
   2ea04:	f240 2302 	movw	r3, #514	; 0x202
   2ea08:	429a      	cmp	r2, r3
   2ea0a:	d035      	beq.n	2ea78 <bsd_platform_af_method_table_get+0x84>
   2ea0c:	f240 2305 	movw	r3, #517	; 0x205
   2ea10:	429a      	cmp	r2, r3
   2ea12:	d035      	beq.n	2ea80 <bsd_platform_af_method_table_get+0x8c>
   2ea14:	f240 2301 	movw	r3, #513	; 0x201
   2ea18:	429a      	cmp	r2, r3
   2ea1a:	d02f      	beq.n	2ea7c <bsd_platform_af_method_table_get+0x88>
   2ea1c:	202b      	movs	r0, #43	; 0x2b
   2ea1e:	f7fc f8d1 	bl	2abc4 <bsd_os_errno_set>
   2ea22:	2000      	movs	r0, #0
   2ea24:	bd08      	pop	{r3, pc}
   2ea26:	2801      	cmp	r0, #1
   2ea28:	d016      	beq.n	2ea58 <bsd_platform_af_method_table_get+0x64>
   2ea2a:	2802      	cmp	r0, #2
   2ea2c:	d10a      	bne.n	2ea44 <bsd_platform_af_method_table_get+0x50>
   2ea2e:	f5b2 7f83 	cmp.w	r2, #262	; 0x106
   2ea32:	d21a      	bcs.n	2ea6a <bsd_platform_af_method_table_get+0x76>
   2ea34:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   2ea38:	d21a      	bcs.n	2ea70 <bsd_platform_af_method_table_get+0x7c>
   2ea3a:	3a01      	subs	r2, #1
   2ea3c:	2a01      	cmp	r2, #1
   2ea3e:	d8ed      	bhi.n	2ea1c <bsd_platform_af_method_table_get+0x28>
   2ea40:	4810      	ldr	r0, [pc, #64]	; (2ea84 <bsd_platform_af_method_table_get+0x90>)
   2ea42:	bd08      	pop	{r3, pc}
   2ea44:	2016      	movs	r0, #22
   2ea46:	f7fc f8bd 	bl	2abc4 <bsd_os_errno_set>
   2ea4a:	2000      	movs	r0, #0
   2ea4c:	bd08      	pop	{r3, pc}
   2ea4e:	2903      	cmp	r1, #3
   2ea50:	480d      	ldr	r0, [pc, #52]	; (2ea88 <bsd_platform_af_method_table_get+0x94>)
   2ea52:	bf18      	it	ne
   2ea54:	2000      	movne	r0, #0
   2ea56:	4770      	bx	lr
   2ea58:	f240 2303 	movw	r3, #515	; 0x203
   2ea5c:	429a      	cmp	r2, r3
   2ea5e:	d009      	beq.n	2ea74 <bsd_platform_af_method_table_get+0x80>
   2ea60:	f5b2 7f01 	cmp.w	r2, #516	; 0x204
   2ea64:	d1da      	bne.n	2ea1c <bsd_platform_af_method_table_get+0x28>
   2ea66:	4809      	ldr	r0, [pc, #36]	; (2ea8c <bsd_platform_af_method_table_get+0x98>)
   2ea68:	bd08      	pop	{r3, pc}
   2ea6a:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   2ea6e:	d1d5      	bne.n	2ea1c <bsd_platform_af_method_table_get+0x28>
   2ea70:	4807      	ldr	r0, [pc, #28]	; (2ea90 <bsd_platform_af_method_table_get+0x9c>)
   2ea72:	bd08      	pop	{r3, pc}
   2ea74:	4807      	ldr	r0, [pc, #28]	; (2ea94 <bsd_platform_af_method_table_get+0xa0>)
   2ea76:	bd08      	pop	{r3, pc}
   2ea78:	4807      	ldr	r0, [pc, #28]	; (2ea98 <bsd_platform_af_method_table_get+0xa4>)
   2ea7a:	bd08      	pop	{r3, pc}
   2ea7c:	4807      	ldr	r0, [pc, #28]	; (2ea9c <bsd_platform_af_method_table_get+0xa8>)
   2ea7e:	bd08      	pop	{r3, pc}
   2ea80:	4807      	ldr	r0, [pc, #28]	; (2eaa0 <bsd_platform_af_method_table_get+0xac>)
   2ea82:	bd08      	pop	{r3, pc}
   2ea84:	000400ac 	.word	0x000400ac
   2ea88:	0004019c 	.word	0x0004019c
   2ea8c:	0004014c 	.word	0x0004014c
   2ea90:	000400d4 	.word	0x000400d4
   2ea94:	000400fc 	.word	0x000400fc
   2ea98:	00040124 	.word	0x00040124
   2ea9c:	00040084 	.word	0x00040084
   2eaa0:	00040174 	.word	0x00040174

0002eaa4 <bsd_platform_fd_method_table_get>:
   2eaa4:	b538      	push	{r3, r4, r5, lr}
   2eaa6:	4605      	mov	r5, r0
   2eaa8:	f004 f816 	bl	32ad8 <interface_socket_from_handle_get>
   2eaac:	4604      	mov	r4, r0
   2eaae:	b960      	cbnz	r0, 2eaca <bsd_platform_fd_method_table_get+0x26>
   2eab0:	4b2c      	ldr	r3, [pc, #176]	; (2eb64 <bsd_platform_fd_method_table_get+0xc0>)
   2eab2:	429d      	cmp	r5, r3
   2eab4:	d02f      	beq.n	2eb16 <bsd_platform_fd_method_table_get+0x72>
   2eab6:	0c2b      	lsrs	r3, r5, #16
   2eab8:	4a2b      	ldr	r2, [pc, #172]	; (2eb68 <bsd_platform_fd_method_table_get+0xc4>)
   2eaba:	041b      	lsls	r3, r3, #16
   2eabc:	4293      	cmp	r3, r2
   2eabe:	d03d      	beq.n	2eb3c <bsd_platform_fd_method_table_get+0x98>
   2eac0:	4b2a      	ldr	r3, [pc, #168]	; (2eb6c <bsd_platform_fd_method_table_get+0xc8>)
   2eac2:	429d      	cmp	r5, r3
   2eac4:	d149      	bne.n	2eb5a <bsd_platform_fd_method_table_get+0xb6>
   2eac6:	482a      	ldr	r0, [pc, #168]	; (2eb70 <bsd_platform_fd_method_table_get+0xcc>)
   2eac8:	bd38      	pop	{r3, r4, r5, pc}
   2eaca:	68c3      	ldr	r3, [r0, #12]
   2eacc:	6942      	ldr	r2, [r0, #20]
   2eace:	2b05      	cmp	r3, #5
   2ead0:	d036      	beq.n	2eb40 <bsd_platform_fd_method_table_get+0x9c>
   2ead2:	d911      	bls.n	2eaf8 <bsd_platform_fd_method_table_get+0x54>
   2ead4:	2b0a      	cmp	r3, #10
   2ead6:	d013      	beq.n	2eb00 <bsd_platform_fd_method_table_get+0x5c>
   2ead8:	2b66      	cmp	r3, #102	; 0x66
   2eada:	d11e      	bne.n	2eb1a <bsd_platform_fd_method_table_get+0x76>
   2eadc:	f240 2302 	movw	r3, #514	; 0x202
   2eae0:	429a      	cmp	r2, r3
   2eae2:	d02b      	beq.n	2eb3c <bsd_platform_fd_method_table_get+0x98>
   2eae4:	f240 2305 	movw	r3, #517	; 0x205
   2eae8:	429a      	cmp	r2, r3
   2eaea:	d02f      	beq.n	2eb4c <bsd_platform_fd_method_table_get+0xa8>
   2eaec:	f240 2301 	movw	r3, #513	; 0x201
   2eaf0:	429a      	cmp	r2, r3
   2eaf2:	d11e      	bne.n	2eb32 <bsd_platform_fd_method_table_get+0x8e>
   2eaf4:	481f      	ldr	r0, [pc, #124]	; (2eb74 <bsd_platform_fd_method_table_get+0xd0>)
   2eaf6:	bd38      	pop	{r3, r4, r5, pc}
   2eaf8:	2b01      	cmp	r3, #1
   2eafa:	d013      	beq.n	2eb24 <bsd_platform_fd_method_table_get+0x80>
   2eafc:	2b02      	cmp	r3, #2
   2eafe:	d10c      	bne.n	2eb1a <bsd_platform_fd_method_table_get+0x76>
   2eb00:	f5b2 7f83 	cmp.w	r2, #262	; 0x106
   2eb04:	d224      	bcs.n	2eb50 <bsd_platform_fd_method_table_get+0xac>
   2eb06:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   2eb0a:	d224      	bcs.n	2eb56 <bsd_platform_fd_method_table_get+0xb2>
   2eb0c:	3a01      	subs	r2, #1
   2eb0e:	2a01      	cmp	r2, #1
   2eb10:	d80f      	bhi.n	2eb32 <bsd_platform_fd_method_table_get+0x8e>
   2eb12:	4819      	ldr	r0, [pc, #100]	; (2eb78 <bsd_platform_fd_method_table_get+0xd4>)
   2eb14:	bd38      	pop	{r3, r4, r5, pc}
   2eb16:	4819      	ldr	r0, [pc, #100]	; (2eb7c <bsd_platform_fd_method_table_get+0xd8>)
   2eb18:	bd38      	pop	{r3, r4, r5, pc}
   2eb1a:	2016      	movs	r0, #22
   2eb1c:	f7fc f852 	bl	2abc4 <bsd_os_errno_set>
   2eb20:	2000      	movs	r0, #0
   2eb22:	bd38      	pop	{r3, r4, r5, pc}
   2eb24:	f240 2303 	movw	r3, #515	; 0x203
   2eb28:	429a      	cmp	r2, r3
   2eb2a:	d0f4      	beq.n	2eb16 <bsd_platform_fd_method_table_get+0x72>
   2eb2c:	f5b2 7f01 	cmp.w	r2, #516	; 0x204
   2eb30:	d0c9      	beq.n	2eac6 <bsd_platform_fd_method_table_get+0x22>
   2eb32:	202b      	movs	r0, #43	; 0x2b
   2eb34:	f7fc f846 	bl	2abc4 <bsd_os_errno_set>
   2eb38:	2000      	movs	r0, #0
   2eb3a:	bd38      	pop	{r3, r4, r5, pc}
   2eb3c:	4810      	ldr	r0, [pc, #64]	; (2eb80 <bsd_platform_fd_method_table_get+0xdc>)
   2eb3e:	bd38      	pop	{r3, r4, r5, pc}
   2eb40:	6903      	ldr	r3, [r0, #16]
   2eb42:	4810      	ldr	r0, [pc, #64]	; (2eb84 <bsd_platform_fd_method_table_get+0xe0>)
   2eb44:	2b03      	cmp	r3, #3
   2eb46:	bf18      	it	ne
   2eb48:	2000      	movne	r0, #0
   2eb4a:	bd38      	pop	{r3, r4, r5, pc}
   2eb4c:	480e      	ldr	r0, [pc, #56]	; (2eb88 <bsd_platform_fd_method_table_get+0xe4>)
   2eb4e:	bd38      	pop	{r3, r4, r5, pc}
   2eb50:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   2eb54:	d1ed      	bne.n	2eb32 <bsd_platform_fd_method_table_get+0x8e>
   2eb56:	480d      	ldr	r0, [pc, #52]	; (2eb8c <bsd_platform_fd_method_table_get+0xe8>)
   2eb58:	bd38      	pop	{r3, r4, r5, pc}
   2eb5a:	2009      	movs	r0, #9
   2eb5c:	f7fc f832 	bl	2abc4 <bsd_os_errno_set>
   2eb60:	4620      	mov	r0, r4
   2eb62:	bd38      	pop	{r3, r4, r5, pc}
   2eb64:	49765432 	.word	0x49765432
   2eb68:	789a0000 	.word	0x789a0000
   2eb6c:	49765443 	.word	0x49765443
   2eb70:	0004014c 	.word	0x0004014c
   2eb74:	00040084 	.word	0x00040084
   2eb78:	000400ac 	.word	0x000400ac
   2eb7c:	000400fc 	.word	0x000400fc
   2eb80:	00040124 	.word	0x00040124
   2eb84:	0004019c 	.word	0x0004019c
   2eb88:	00040174 	.word	0x00040174
   2eb8c:	000400d4 	.word	0x000400d4

0002eb90 <bsd_platform_getaddrinfo>:
   2eb90:	f003 bad6 	b.w	32140 <ip_interface_getaddrinfo>

0002eb94 <bsd_platform_freeaddrinfo>:
   2eb94:	f003 bbca 	b.w	3232c <ip_interface_freeaddrinfo>

0002eb98 <bsd_platform_poll>:
   2eb98:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2eb9c:	ea42 72e2 	orr.w	r2, r2, r2, asr #31
   2eba0:	b083      	sub	sp, #12
   2eba2:	9200      	str	r2, [sp, #0]
   2eba4:	2800      	cmp	r0, #0
   2eba6:	d048      	beq.n	2ec3a <bsd_platform_poll+0xa2>
   2eba8:	1e4b      	subs	r3, r1, #1
   2ebaa:	2b08      	cmp	r3, #8
   2ebac:	d845      	bhi.n	2ec3a <bsd_platform_poll+0xa2>
   2ebae:	4680      	mov	r8, r0
   2ebb0:	4605      	mov	r5, r0
   2ebb2:	2400      	movs	r4, #0
   2ebb4:	eb00 07c1 	add.w	r7, r0, r1, lsl #3
   2ebb8:	88ab      	ldrh	r3, [r5, #4]
   2ebba:	6828      	ldr	r0, [r5, #0]
   2ebbc:	f003 0303 	and.w	r3, r3, #3
   2ebc0:	a901      	add	r1, sp, #4
   2ebc2:	f043 061c 	orr.w	r6, r3, #28
   2ebc6:	f003 ff95 	bl	32af4 <interface_socket_event_get>
   2ebca:	9b01      	ldr	r3, [sp, #4]
   2ebcc:	3508      	adds	r5, #8
   2ebce:	4033      	ands	r3, r6
   2ebd0:	f825 3c02 	strh.w	r3, [r5, #-2]
   2ebd4:	b103      	cbz	r3, 2ebd8 <bsd_platform_poll+0x40>
   2ebd6:	3401      	adds	r4, #1
   2ebd8:	42af      	cmp	r7, r5
   2ebda:	d1ed      	bne.n	2ebb8 <bsd_platform_poll+0x20>
   2ebdc:	bb9c      	cbnz	r4, 2ec46 <bsd_platform_poll+0xae>
   2ebde:	4669      	mov	r1, sp
   2ebe0:	4640      	mov	r0, r8
   2ebe2:	f7fb ff5b 	bl	2aa9c <bsd_os_timedwait>
   2ebe6:	4607      	mov	r7, r0
   2ebe8:	b108      	cbz	r0, 2ebee <bsd_platform_poll+0x56>
   2ebea:	283c      	cmp	r0, #60	; 0x3c
   2ebec:	d11d      	bne.n	2ec2a <bsd_platform_poll+0x92>
   2ebee:	46c1      	mov	r9, r8
   2ebf0:	2600      	movs	r6, #0
   2ebf2:	f8b9 3004 	ldrh.w	r3, [r9, #4]
   2ebf6:	f8d9 0000 	ldr.w	r0, [r9]
   2ebfa:	f003 0303 	and.w	r3, r3, #3
   2ebfe:	a901      	add	r1, sp, #4
   2ec00:	f043 041c 	orr.w	r4, r3, #28
   2ec04:	f003 ff76 	bl	32af4 <interface_socket_event_get>
   2ec08:	9b01      	ldr	r3, [sp, #4]
   2ec0a:	f109 0908 	add.w	r9, r9, #8
   2ec0e:	4023      	ands	r3, r4
   2ec10:	f829 3c02 	strh.w	r3, [r9, #-2]
   2ec14:	b103      	cbz	r3, 2ec18 <bsd_platform_poll+0x80>
   2ec16:	3601      	adds	r6, #1
   2ec18:	454d      	cmp	r5, r9
   2ec1a:	d1ea      	bne.n	2ebf2 <bsd_platform_poll+0x5a>
   2ec1c:	b90e      	cbnz	r6, 2ec22 <bsd_platform_poll+0x8a>
   2ec1e:	2f00      	cmp	r7, #0
   2ec20:	d0dd      	beq.n	2ebde <bsd_platform_poll+0x46>
   2ec22:	4630      	mov	r0, r6
   2ec24:	b003      	add	sp, #12
   2ec26:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2ec2a:	2023      	movs	r0, #35	; 0x23
   2ec2c:	f7fb ffca 	bl	2abc4 <bsd_os_errno_set>
   2ec30:	f04f 30ff 	mov.w	r0, #4294967295
   2ec34:	b003      	add	sp, #12
   2ec36:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2ec3a:	2016      	movs	r0, #22
   2ec3c:	f7fb ffc2 	bl	2abc4 <bsd_os_errno_set>
   2ec40:	f04f 30ff 	mov.w	r0, #4294967295
   2ec44:	e7ee      	b.n	2ec24 <bsd_platform_poll+0x8c>
   2ec46:	4620      	mov	r0, r4
   2ec48:	e7ec      	b.n	2ec24 <bsd_platform_poll+0x8c>
   2ec4a:	bf00      	nop

0002ec4c <bsd_platform_fcntl>:
   2ec4c:	b508      	push	{r3, lr}
   2ec4e:	4b06      	ldr	r3, [pc, #24]	; (2ec68 <bsd_platform_fcntl+0x1c>)
   2ec50:	4298      	cmp	r0, r3
   2ec52:	d003      	beq.n	2ec5c <bsd_platform_fcntl+0x10>
   2ec54:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   2ec58:	f003 bfd6 	b.w	32c08 <interface_socket_fcntl>
   2ec5c:	202d      	movs	r0, #45	; 0x2d
   2ec5e:	f7fb ffb1 	bl	2abc4 <bsd_os_errno_set>
   2ec62:	f04f 30ff 	mov.w	r0, #4294967295
   2ec66:	bd08      	pop	{r3, pc}
   2ec68:	49765432 	.word	0x49765432

0002ec6c <ipc_trace_init>:
   2ec6c:	4b01      	ldr	r3, [pc, #4]	; (2ec74 <ipc_trace_init+0x8>)
   2ec6e:	6018      	str	r0, [r3, #0]
   2ec70:	4770      	bx	lr
   2ec72:	bf00      	nop
   2ec74:	20025178 	.word	0x20025178

0002ec78 <bsd_os_trace_irq_handler>:
   2ec78:	b5f0      	push	{r4, r5, r6, r7, lr}
   2ec7a:	4b6c      	ldr	r3, [pc, #432]	; (2ee2c <bsd_os_trace_irq_handler+0x1b4>)
   2ec7c:	b083      	sub	sp, #12
   2ec7e:	781b      	ldrb	r3, [r3, #0]
   2ec80:	2b00      	cmp	r3, #0
   2ec82:	f000 80ad 	beq.w	2ede0 <bsd_os_trace_irq_handler+0x168>
   2ec86:	4b6a      	ldr	r3, [pc, #424]	; (2ee30 <bsd_os_trace_irq_handler+0x1b8>)
   2ec88:	681c      	ldr	r4, [r3, #0]
   2ec8a:	68a2      	ldr	r2, [r4, #8]
   2ec8c:	6863      	ldr	r3, [r4, #4]
   2ec8e:	429a      	cmp	r2, r3
   2ec90:	d02d      	beq.n	2ecee <bsd_os_trace_irq_handler+0x76>
   2ec92:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   2ec96:	f8ad 3000 	strh.w	r3, [sp]
   2ec9a:	7823      	ldrb	r3, [r4, #0]
   2ec9c:	466e      	mov	r6, sp
   2ec9e:	f88d 3004 	strb.w	r3, [sp, #4]
   2eca2:	6863      	ldr	r3, [r4, #4]
   2eca4:	2105      	movs	r1, #5
   2eca6:	429a      	cmp	r2, r3
   2eca8:	bf2a      	itet	cs
   2ecaa:	6927      	ldrcs	r7, [r4, #16]
   2ecac:	1a9f      	subcc	r7, r3, r2
   2ecae:	1abf      	subcs	r7, r7, r2
   2ecb0:	429a      	cmp	r2, r3
   2ecb2:	bf94      	ite	ls
   2ecb4:	2500      	movls	r5, #0
   2ecb6:	68e5      	ldrhi	r5, [r4, #12]
   2ecb8:	b2bf      	uxth	r7, r7
   2ecba:	bf88      	it	hi
   2ecbc:	1b5b      	subhi	r3, r3, r5
   2ecbe:	4630      	mov	r0, r6
   2ecc0:	bf88      	it	hi
   2ecc2:	b29d      	uxthhi	r5, r3
   2ecc4:	f8ad 7002 	strh.w	r7, [sp, #2]
   2ecc8:	f00e fe58 	bl	3d97c <bsd_os_trace_put>
   2eccc:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2ecd0:	68a0      	ldr	r0, [r4, #8]
   2ecd2:	f00e fe53 	bl	3d97c <bsd_os_trace_put>
   2ecd6:	68a3      	ldr	r3, [r4, #8]
   2ecd8:	6922      	ldr	r2, [r4, #16]
   2ecda:	441f      	add	r7, r3
   2ecdc:	4297      	cmp	r7, r2
   2ecde:	bf08      	it	eq
   2ece0:	68e3      	ldreq	r3, [r4, #12]
   2ece2:	60a7      	str	r7, [r4, #8]
   2ece4:	bf08      	it	eq
   2ece6:	60a3      	streq	r3, [r4, #8]
   2ece8:	2d00      	cmp	r5, #0
   2ecea:	f040 808d 	bne.w	2ee08 <bsd_os_trace_irq_handler+0x190>
   2ecee:	4b51      	ldr	r3, [pc, #324]	; (2ee34 <bsd_os_trace_irq_handler+0x1bc>)
   2ecf0:	681c      	ldr	r4, [r3, #0]
   2ecf2:	68a2      	ldr	r2, [r4, #8]
   2ecf4:	6863      	ldr	r3, [r4, #4]
   2ecf6:	429a      	cmp	r2, r3
   2ecf8:	d02c      	beq.n	2ed54 <bsd_os_trace_irq_handler+0xdc>
   2ecfa:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   2ecfe:	f8ad 3000 	strh.w	r3, [sp]
   2ed02:	7823      	ldrb	r3, [r4, #0]
   2ed04:	466e      	mov	r6, sp
   2ed06:	f88d 3004 	strb.w	r3, [sp, #4]
   2ed0a:	6863      	ldr	r3, [r4, #4]
   2ed0c:	2105      	movs	r1, #5
   2ed0e:	429a      	cmp	r2, r3
   2ed10:	bf2a      	itet	cs
   2ed12:	6927      	ldrcs	r7, [r4, #16]
   2ed14:	1a9f      	subcc	r7, r3, r2
   2ed16:	1abf      	subcs	r7, r7, r2
   2ed18:	429a      	cmp	r2, r3
   2ed1a:	bf94      	ite	ls
   2ed1c:	2500      	movls	r5, #0
   2ed1e:	68e5      	ldrhi	r5, [r4, #12]
   2ed20:	b2bf      	uxth	r7, r7
   2ed22:	bf88      	it	hi
   2ed24:	1b5b      	subhi	r3, r3, r5
   2ed26:	4630      	mov	r0, r6
   2ed28:	bf88      	it	hi
   2ed2a:	b29d      	uxthhi	r5, r3
   2ed2c:	f8ad 7002 	strh.w	r7, [sp, #2]
   2ed30:	f00e fe24 	bl	3d97c <bsd_os_trace_put>
   2ed34:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2ed38:	68a0      	ldr	r0, [r4, #8]
   2ed3a:	f00e fe1f 	bl	3d97c <bsd_os_trace_put>
   2ed3e:	68a3      	ldr	r3, [r4, #8]
   2ed40:	6922      	ldr	r2, [r4, #16]
   2ed42:	441f      	add	r7, r3
   2ed44:	4297      	cmp	r7, r2
   2ed46:	bf08      	it	eq
   2ed48:	68e3      	ldreq	r3, [r4, #12]
   2ed4a:	60a7      	str	r7, [r4, #8]
   2ed4c:	bf08      	it	eq
   2ed4e:	60a3      	streq	r3, [r4, #8]
   2ed50:	2d00      	cmp	r5, #0
   2ed52:	d148      	bne.n	2ede6 <bsd_os_trace_irq_handler+0x16e>
   2ed54:	4b38      	ldr	r3, [pc, #224]	; (2ee38 <bsd_os_trace_irq_handler+0x1c0>)
   2ed56:	681c      	ldr	r4, [r3, #0]
   2ed58:	68a2      	ldr	r2, [r4, #8]
   2ed5a:	6863      	ldr	r3, [r4, #4]
   2ed5c:	429a      	cmp	r2, r3
   2ed5e:	d02b      	beq.n	2edb8 <bsd_os_trace_irq_handler+0x140>
   2ed60:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   2ed64:	f8ad 3000 	strh.w	r3, [sp]
   2ed68:	7823      	ldrb	r3, [r4, #0]
   2ed6a:	466e      	mov	r6, sp
   2ed6c:	f88d 3004 	strb.w	r3, [sp, #4]
   2ed70:	6863      	ldr	r3, [r4, #4]
   2ed72:	2105      	movs	r1, #5
   2ed74:	429a      	cmp	r2, r3
   2ed76:	bf2a      	itet	cs
   2ed78:	6927      	ldrcs	r7, [r4, #16]
   2ed7a:	1a9f      	subcc	r7, r3, r2
   2ed7c:	1abf      	subcs	r7, r7, r2
   2ed7e:	429a      	cmp	r2, r3
   2ed80:	bf94      	ite	ls
   2ed82:	2500      	movls	r5, #0
   2ed84:	68e5      	ldrhi	r5, [r4, #12]
   2ed86:	b2bf      	uxth	r7, r7
   2ed88:	bf88      	it	hi
   2ed8a:	1b5b      	subhi	r3, r3, r5
   2ed8c:	4630      	mov	r0, r6
   2ed8e:	bf88      	it	hi
   2ed90:	b29d      	uxthhi	r5, r3
   2ed92:	f8ad 7002 	strh.w	r7, [sp, #2]
   2ed96:	f00e fdf1 	bl	3d97c <bsd_os_trace_put>
   2ed9a:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2ed9e:	68a0      	ldr	r0, [r4, #8]
   2eda0:	f00e fdec 	bl	3d97c <bsd_os_trace_put>
   2eda4:	68a3      	ldr	r3, [r4, #8]
   2eda6:	6922      	ldr	r2, [r4, #16]
   2eda8:	441f      	add	r7, r3
   2edaa:	4297      	cmp	r7, r2
   2edac:	bf08      	it	eq
   2edae:	68e3      	ldreq	r3, [r4, #12]
   2edb0:	60a7      	str	r7, [r4, #8]
   2edb2:	bf08      	it	eq
   2edb4:	60a3      	streq	r3, [r4, #8]
   2edb6:	b90d      	cbnz	r5, 2edbc <bsd_os_trace_irq_handler+0x144>
   2edb8:	b003      	add	sp, #12
   2edba:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2edbc:	4630      	mov	r0, r6
   2edbe:	2105      	movs	r1, #5
   2edc0:	f8ad 5002 	strh.w	r5, [sp, #2]
   2edc4:	f00e fdda 	bl	3d97c <bsd_os_trace_put>
   2edc8:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2edcc:	68e0      	ldr	r0, [r4, #12]
   2edce:	f00e fdd5 	bl	3d97c <bsd_os_trace_put>
   2edd2:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   2edd6:	68e3      	ldr	r3, [r4, #12]
   2edd8:	4413      	add	r3, r2
   2edda:	60a3      	str	r3, [r4, #8]
   2eddc:	b003      	add	sp, #12
   2edde:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2ede0:	f7fc f800 	bl	2ade4 <bsd_os_trace_irq_clear>
   2ede4:	e74f      	b.n	2ec86 <bsd_os_trace_irq_handler+0xe>
   2ede6:	2105      	movs	r1, #5
   2ede8:	4630      	mov	r0, r6
   2edea:	f8ad 5002 	strh.w	r5, [sp, #2]
   2edee:	f00e fdc5 	bl	3d97c <bsd_os_trace_put>
   2edf2:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2edf6:	68e0      	ldr	r0, [r4, #12]
   2edf8:	f00e fdc0 	bl	3d97c <bsd_os_trace_put>
   2edfc:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   2ee00:	68e3      	ldr	r3, [r4, #12]
   2ee02:	4413      	add	r3, r2
   2ee04:	60a3      	str	r3, [r4, #8]
   2ee06:	e7a5      	b.n	2ed54 <bsd_os_trace_irq_handler+0xdc>
   2ee08:	2105      	movs	r1, #5
   2ee0a:	4630      	mov	r0, r6
   2ee0c:	f8ad 5002 	strh.w	r5, [sp, #2]
   2ee10:	f00e fdb4 	bl	3d97c <bsd_os_trace_put>
   2ee14:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2ee18:	68e0      	ldr	r0, [r4, #12]
   2ee1a:	f00e fdaf 	bl	3d97c <bsd_os_trace_put>
   2ee1e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   2ee22:	68e3      	ldr	r3, [r4, #12]
   2ee24:	4413      	add	r3, r2
   2ee26:	60a3      	str	r3, [r4, #8]
   2ee28:	e761      	b.n	2ecee <bsd_os_trace_irq_handler+0x76>
   2ee2a:	bf00      	nop
   2ee2c:	2002d7ef 	.word	0x2002d7ef
   2ee30:	20025174 	.word	0x20025174
   2ee34:	2002516c 	.word	0x2002516c
   2ee38:	20025170 	.word	0x20025170

0002ee3c <ipc_trace_handle>:
   2ee3c:	2200      	movs	r2, #0
   2ee3e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2ee42:	4bb0      	ldr	r3, [pc, #704]	; (2f104 <ipc_trace_handle+0x2c8>)
   2ee44:	b083      	sub	sp, #12
   2ee46:	681b      	ldr	r3, [r3, #0]
   2ee48:	6919      	ldr	r1, [r3, #16]
   2ee4a:	695c      	ldr	r4, [r3, #20]
   2ee4c:	7c18      	ldrb	r0, [r3, #16]
   2ee4e:	741a      	strb	r2, [r3, #16]
   2ee50:	7c58      	ldrb	r0, [r3, #17]
   2ee52:	745a      	strb	r2, [r3, #17]
   2ee54:	7c98      	ldrb	r0, [r3, #18]
   2ee56:	749a      	strb	r2, [r3, #18]
   2ee58:	7cd8      	ldrb	r0, [r3, #19]
   2ee5a:	74da      	strb	r2, [r3, #19]
   2ee5c:	7d18      	ldrb	r0, [r3, #20]
   2ee5e:	751a      	strb	r2, [r3, #20]
   2ee60:	7d58      	ldrb	r0, [r3, #21]
   2ee62:	755a      	strb	r2, [r3, #21]
   2ee64:	7d98      	ldrb	r0, [r3, #22]
   2ee66:	759a      	strb	r2, [r3, #22]
   2ee68:	7dd8      	ldrb	r0, [r3, #23]
   2ee6a:	75da      	strb	r2, [r3, #23]
   2ee6c:	b1b9      	cbz	r1, 2ee9e <ipc_trace_handle+0x62>
   2ee6e:	3901      	subs	r1, #1
   2ee70:	2903      	cmp	r1, #3
   2ee72:	d814      	bhi.n	2ee9e <ipc_trace_handle+0x62>
   2ee74:	e8df f011 	tbh	[pc, r1, lsl #1]
   2ee78:	010300d6 	.word	0x010300d6
   2ee7c:	00160004 	.word	0x00160004
   2ee80:	2501      	movs	r5, #1
   2ee82:	2003      	movs	r0, #3
   2ee84:	2200      	movs	r2, #0
   2ee86:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   2ee8a:	4c9f      	ldr	r4, [pc, #636]	; (2f108 <ipc_trace_handle+0x2cc>)
   2ee8c:	7025      	strb	r5, [r4, #0]
   2ee8e:	7a1c      	ldrb	r4, [r3, #8]
   2ee90:	7218      	strb	r0, [r3, #8]
   2ee92:	7a58      	ldrb	r0, [r3, #9]
   2ee94:	725a      	strb	r2, [r3, #9]
   2ee96:	7a98      	ldrb	r0, [r3, #10]
   2ee98:	729a      	strb	r2, [r3, #10]
   2ee9a:	7ada      	ldrb	r2, [r3, #11]
   2ee9c:	72d9      	strb	r1, [r3, #11]
   2ee9e:	b003      	add	sp, #12
   2eea0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2eea4:	2104      	movs	r1, #4
   2eea6:	2200      	movs	r2, #0
   2eea8:	f06f 005f 	mvn.w	r0, #95	; 0x5f
   2eeac:	7a1c      	ldrb	r4, [r3, #8]
   2eeae:	7219      	strb	r1, [r3, #8]
   2eeb0:	7a59      	ldrb	r1, [r3, #9]
   2eeb2:	725a      	strb	r2, [r3, #9]
   2eeb4:	4994      	ldr	r1, [pc, #592]	; (2f108 <ipc_trace_handle+0x2cc>)
   2eeb6:	7a9c      	ldrb	r4, [r3, #10]
   2eeb8:	729a      	strb	r2, [r3, #10]
   2eeba:	7adc      	ldrb	r4, [r3, #11]
   2eebc:	72d8      	strb	r0, [r3, #11]
   2eebe:	700a      	strb	r2, [r1, #0]
   2eec0:	780b      	ldrb	r3, [r1, #0]
   2eec2:	2b00      	cmp	r3, #0
   2eec4:	f000 8117 	beq.w	2f0f6 <ipc_trace_handle+0x2ba>
   2eec8:	4b90      	ldr	r3, [pc, #576]	; (2f10c <ipc_trace_handle+0x2d0>)
   2eeca:	681c      	ldr	r4, [r3, #0]
   2eecc:	68a2      	ldr	r2, [r4, #8]
   2eece:	6863      	ldr	r3, [r4, #4]
   2eed0:	429a      	cmp	r2, r3
   2eed2:	d02d      	beq.n	2ef30 <ipc_trace_handle+0xf4>
   2eed4:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   2eed8:	f8ad 3000 	strh.w	r3, [sp]
   2eedc:	7823      	ldrb	r3, [r4, #0]
   2eede:	466e      	mov	r6, sp
   2eee0:	f88d 3004 	strb.w	r3, [sp, #4]
   2eee4:	6863      	ldr	r3, [r4, #4]
   2eee6:	2105      	movs	r1, #5
   2eee8:	429a      	cmp	r2, r3
   2eeea:	bf2a      	itet	cs
   2eeec:	6927      	ldrcs	r7, [r4, #16]
   2eeee:	1a9f      	subcc	r7, r3, r2
   2eef0:	1abf      	subcs	r7, r7, r2
   2eef2:	429a      	cmp	r2, r3
   2eef4:	bf94      	ite	ls
   2eef6:	2500      	movls	r5, #0
   2eef8:	68e5      	ldrhi	r5, [r4, #12]
   2eefa:	b2bf      	uxth	r7, r7
   2eefc:	bf88      	it	hi
   2eefe:	1b5b      	subhi	r3, r3, r5
   2ef00:	4630      	mov	r0, r6
   2ef02:	bf88      	it	hi
   2ef04:	b29d      	uxthhi	r5, r3
   2ef06:	f8ad 7002 	strh.w	r7, [sp, #2]
   2ef0a:	f00e fd37 	bl	3d97c <bsd_os_trace_put>
   2ef0e:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2ef12:	68a0      	ldr	r0, [r4, #8]
   2ef14:	f00e fd32 	bl	3d97c <bsd_os_trace_put>
   2ef18:	68a3      	ldr	r3, [r4, #8]
   2ef1a:	6922      	ldr	r2, [r4, #16]
   2ef1c:	441f      	add	r7, r3
   2ef1e:	4297      	cmp	r7, r2
   2ef20:	bf08      	it	eq
   2ef22:	68e3      	ldreq	r3, [r4, #12]
   2ef24:	60a7      	str	r7, [r4, #8]
   2ef26:	bf08      	it	eq
   2ef28:	60a3      	streq	r3, [r4, #8]
   2ef2a:	2d00      	cmp	r5, #0
   2ef2c:	f040 80d2 	bne.w	2f0d4 <ipc_trace_handle+0x298>
   2ef30:	4b77      	ldr	r3, [pc, #476]	; (2f110 <ipc_trace_handle+0x2d4>)
   2ef32:	681c      	ldr	r4, [r3, #0]
   2ef34:	68a2      	ldr	r2, [r4, #8]
   2ef36:	6863      	ldr	r3, [r4, #4]
   2ef38:	429a      	cmp	r2, r3
   2ef3a:	d02d      	beq.n	2ef98 <ipc_trace_handle+0x15c>
   2ef3c:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   2ef40:	f8ad 3000 	strh.w	r3, [sp]
   2ef44:	7823      	ldrb	r3, [r4, #0]
   2ef46:	466e      	mov	r6, sp
   2ef48:	f88d 3004 	strb.w	r3, [sp, #4]
   2ef4c:	6863      	ldr	r3, [r4, #4]
   2ef4e:	2105      	movs	r1, #5
   2ef50:	429a      	cmp	r2, r3
   2ef52:	bf2a      	itet	cs
   2ef54:	6927      	ldrcs	r7, [r4, #16]
   2ef56:	1a9f      	subcc	r7, r3, r2
   2ef58:	1abf      	subcs	r7, r7, r2
   2ef5a:	429a      	cmp	r2, r3
   2ef5c:	bf94      	ite	ls
   2ef5e:	2500      	movls	r5, #0
   2ef60:	68e5      	ldrhi	r5, [r4, #12]
   2ef62:	b2bf      	uxth	r7, r7
   2ef64:	bf88      	it	hi
   2ef66:	1b5b      	subhi	r3, r3, r5
   2ef68:	4630      	mov	r0, r6
   2ef6a:	bf88      	it	hi
   2ef6c:	b29d      	uxthhi	r5, r3
   2ef6e:	f8ad 7002 	strh.w	r7, [sp, #2]
   2ef72:	f00e fd03 	bl	3d97c <bsd_os_trace_put>
   2ef76:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2ef7a:	68a0      	ldr	r0, [r4, #8]
   2ef7c:	f00e fcfe 	bl	3d97c <bsd_os_trace_put>
   2ef80:	68a3      	ldr	r3, [r4, #8]
   2ef82:	6922      	ldr	r2, [r4, #16]
   2ef84:	441f      	add	r7, r3
   2ef86:	4297      	cmp	r7, r2
   2ef88:	bf08      	it	eq
   2ef8a:	68e3      	ldreq	r3, [r4, #12]
   2ef8c:	60a7      	str	r7, [r4, #8]
   2ef8e:	bf08      	it	eq
   2ef90:	60a3      	streq	r3, [r4, #8]
   2ef92:	2d00      	cmp	r5, #0
   2ef94:	f040 808d 	bne.w	2f0b2 <ipc_trace_handle+0x276>
   2ef98:	4b5e      	ldr	r3, [pc, #376]	; (2f114 <ipc_trace_handle+0x2d8>)
   2ef9a:	681c      	ldr	r4, [r3, #0]
   2ef9c:	68a2      	ldr	r2, [r4, #8]
   2ef9e:	6863      	ldr	r3, [r4, #4]
   2efa0:	429a      	cmp	r2, r3
   2efa2:	f43f af7c 	beq.w	2ee9e <ipc_trace_handle+0x62>
   2efa6:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   2efaa:	f8ad 3000 	strh.w	r3, [sp]
   2efae:	7823      	ldrb	r3, [r4, #0]
   2efb0:	466e      	mov	r6, sp
   2efb2:	f88d 3004 	strb.w	r3, [sp, #4]
   2efb6:	6863      	ldr	r3, [r4, #4]
   2efb8:	2105      	movs	r1, #5
   2efba:	429a      	cmp	r2, r3
   2efbc:	bf2a      	itet	cs
   2efbe:	6927      	ldrcs	r7, [r4, #16]
   2efc0:	1a9f      	subcc	r7, r3, r2
   2efc2:	1abf      	subcs	r7, r7, r2
   2efc4:	429a      	cmp	r2, r3
   2efc6:	bf94      	ite	ls
   2efc8:	2500      	movls	r5, #0
   2efca:	68e5      	ldrhi	r5, [r4, #12]
   2efcc:	b2bf      	uxth	r7, r7
   2efce:	bf88      	it	hi
   2efd0:	1b5b      	subhi	r3, r3, r5
   2efd2:	4630      	mov	r0, r6
   2efd4:	bf88      	it	hi
   2efd6:	b29d      	uxthhi	r5, r3
   2efd8:	f8ad 7002 	strh.w	r7, [sp, #2]
   2efdc:	f00e fcce 	bl	3d97c <bsd_os_trace_put>
   2efe0:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2efe4:	68a0      	ldr	r0, [r4, #8]
   2efe6:	f00e fcc9 	bl	3d97c <bsd_os_trace_put>
   2efea:	68a3      	ldr	r3, [r4, #8]
   2efec:	6922      	ldr	r2, [r4, #16]
   2efee:	441f      	add	r7, r3
   2eff0:	4297      	cmp	r7, r2
   2eff2:	bf08      	it	eq
   2eff4:	68e3      	ldreq	r3, [r4, #12]
   2eff6:	60a7      	str	r7, [r4, #8]
   2eff8:	bf08      	it	eq
   2effa:	60a3      	streq	r3, [r4, #8]
   2effc:	2d00      	cmp	r5, #0
   2effe:	f43f af4e 	beq.w	2ee9e <ipc_trace_handle+0x62>
   2f002:	2105      	movs	r1, #5
   2f004:	4630      	mov	r0, r6
   2f006:	f8ad 5002 	strh.w	r5, [sp, #2]
   2f00a:	f00e fcb7 	bl	3d97c <bsd_os_trace_put>
   2f00e:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2f012:	68e0      	ldr	r0, [r4, #12]
   2f014:	f00e fcb2 	bl	3d97c <bsd_os_trace_put>
   2f018:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   2f01c:	68e3      	ldr	r3, [r4, #12]
   2f01e:	4413      	add	r3, r2
   2f020:	60a3      	str	r3, [r4, #8]
   2f022:	e73c      	b.n	2ee9e <ipc_trace_handle+0x62>
   2f024:	4a38      	ldr	r2, [pc, #224]	; (2f108 <ipc_trace_handle+0x2cc>)
   2f026:	7811      	ldrb	r1, [r2, #0]
   2f028:	b109      	cbz	r1, 2f02e <ipc_trace_handle+0x1f2>
   2f02a:	2100      	movs	r1, #0
   2f02c:	7011      	strb	r1, [r2, #0]
   2f02e:	68a5      	ldr	r5, [r4, #8]
   2f030:	2d00      	cmp	r5, #0
   2f032:	d039      	beq.n	2f0a8 <ipc_trace_handle+0x26c>
   2f034:	f04f 0c00 	mov.w	ip, #0
   2f038:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 2f110 <ipc_trace_handle+0x2d4>
   2f03c:	f8df b0cc 	ldr.w	fp, [pc, #204]	; 2f10c <ipc_trace_handle+0x2d0>
   2f040:	4934      	ldr	r1, [pc, #208]	; (2f114 <ipc_trace_handle+0x2d8>)
   2f042:	46e1      	mov	r9, ip
   2f044:	4666      	mov	r6, ip
   2f046:	4662      	mov	r2, ip
   2f048:	f8d1 e000 	ldr.w	lr, [r1]
   2f04c:	f8da 8000 	ldr.w	r8, [sl]
   2f050:	f8db 7000 	ldr.w	r7, [fp]
   2f054:	e008      	b.n	2f068 <ipc_trace_handle+0x22c>
   2f056:	2963      	cmp	r1, #99	; 0x63
   2f058:	d016      	beq.n	2f088 <ipc_trace_handle+0x24c>
   2f05a:	2961      	cmp	r1, #97	; 0x61
   2f05c:	bf04      	itt	eq
   2f05e:	4607      	moveq	r7, r0
   2f060:	2601      	moveq	r6, #1
   2f062:	3201      	adds	r2, #1
   2f064:	42aa      	cmp	r2, r5
   2f066:	d013      	beq.n	2f090 <ipc_trace_handle+0x254>
   2f068:	1c91      	adds	r1, r2, #2
   2f06a:	eb04 0181 	add.w	r1, r4, r1, lsl #2
   2f06e:	6848      	ldr	r0, [r1, #4]
   2f070:	7801      	ldrb	r1, [r0, #0]
   2f072:	2962      	cmp	r1, #98	; 0x62
   2f074:	d1ef      	bne.n	2f056 <ipc_trace_handle+0x21a>
   2f076:	4680      	mov	r8, r0
   2f078:	f04f 0901 	mov.w	r9, #1
   2f07c:	e7f1      	b.n	2f062 <ipc_trace_handle+0x226>
   2f07e:	f7fb fea9 	bl	2add4 <bsd_os_trace_irq_set>
   2f082:	b003      	add	sp, #12
   2f084:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2f088:	4686      	mov	lr, r0
   2f08a:	f04f 0c01 	mov.w	ip, #1
   2f08e:	e7e8      	b.n	2f062 <ipc_trace_handle+0x226>
   2f090:	bba6      	cbnz	r6, 2f0fc <ipc_trace_handle+0x2c0>
   2f092:	f1b9 0f00 	cmp.w	r9, #0
   2f096:	d001      	beq.n	2f09c <ipc_trace_handle+0x260>
   2f098:	f8ca 8000 	str.w	r8, [sl]
   2f09c:	f1bc 0f00 	cmp.w	ip, #0
   2f0a0:	d002      	beq.n	2f0a8 <ipc_trace_handle+0x26c>
   2f0a2:	4a1c      	ldr	r2, [pc, #112]	; (2f114 <ipc_trace_handle+0x2d8>)
   2f0a4:	f8c2 e000 	str.w	lr, [r2]
   2f0a8:	2001      	movs	r0, #1
   2f0aa:	2200      	movs	r2, #0
   2f0ac:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   2f0b0:	e6ed      	b.n	2ee8e <ipc_trace_handle+0x52>
   2f0b2:	2105      	movs	r1, #5
   2f0b4:	4630      	mov	r0, r6
   2f0b6:	f8ad 5002 	strh.w	r5, [sp, #2]
   2f0ba:	f00e fc5f 	bl	3d97c <bsd_os_trace_put>
   2f0be:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2f0c2:	68e0      	ldr	r0, [r4, #12]
   2f0c4:	f00e fc5a 	bl	3d97c <bsd_os_trace_put>
   2f0c8:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   2f0cc:	68e3      	ldr	r3, [r4, #12]
   2f0ce:	4413      	add	r3, r2
   2f0d0:	60a3      	str	r3, [r4, #8]
   2f0d2:	e761      	b.n	2ef98 <ipc_trace_handle+0x15c>
   2f0d4:	2105      	movs	r1, #5
   2f0d6:	4630      	mov	r0, r6
   2f0d8:	f8ad 5002 	strh.w	r5, [sp, #2]
   2f0dc:	f00e fc4e 	bl	3d97c <bsd_os_trace_put>
   2f0e0:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2f0e4:	68e0      	ldr	r0, [r4, #12]
   2f0e6:	f00e fc49 	bl	3d97c <bsd_os_trace_put>
   2f0ea:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   2f0ee:	68e3      	ldr	r3, [r4, #12]
   2f0f0:	4413      	add	r3, r2
   2f0f2:	60a3      	str	r3, [r4, #8]
   2f0f4:	e71c      	b.n	2ef30 <ipc_trace_handle+0xf4>
   2f0f6:	f7fb fe75 	bl	2ade4 <bsd_os_trace_irq_clear>
   2f0fa:	e6e5      	b.n	2eec8 <ipc_trace_handle+0x8c>
   2f0fc:	f8cb 7000 	str.w	r7, [fp]
   2f100:	e7c7      	b.n	2f092 <ipc_trace_handle+0x256>
   2f102:	bf00      	nop
   2f104:	20025178 	.word	0x20025178
   2f108:	2002d7ef 	.word	0x2002d7ef
   2f10c:	20025174 	.word	0x20025174
   2f110:	2002516c 	.word	0x2002516c
   2f114:	20025170 	.word	0x20025170

0002f118 <rpc_trace_coredump_in_progress>:
   2f118:	4b01      	ldr	r3, [pc, #4]	; (2f120 <rpc_trace_coredump_in_progress+0x8>)
   2f11a:	7818      	ldrb	r0, [r3, #0]
   2f11c:	4770      	bx	lr
   2f11e:	bf00      	nop
   2f120:	2002d7ef 	.word	0x2002d7ef

0002f124 <transport_reset>:
   2f124:	2000      	movs	r0, #0
   2f126:	4770      	bx	lr

0002f128 <transport_data_free>:
   2f128:	4b0b      	ldr	r3, [pc, #44]	; (2f158 <transport_data_free+0x30>)
   2f12a:	e9d3 2300 	ldrd	r2, r3, [r3]
   2f12e:	4413      	add	r3, r2
   2f130:	4298      	cmp	r0, r3
   2f132:	d20d      	bcs.n	2f150 <transport_data_free+0x28>
   2f134:	4282      	cmp	r2, r0
   2f136:	d80b      	bhi.n	2f150 <transport_data_free+0x28>
   2f138:	b510      	push	{r4, lr}
   2f13a:	4604      	mov	r4, r0
   2f13c:	f000 fd5a 	bl	2fbf4 <rpc_transport_ipc_tx_rpc_ctrl_alloc>
   2f140:	b140      	cbz	r0, 2f154 <transport_data_free+0x2c>
   2f142:	4a06      	ldr	r2, [pc, #24]	; (2f15c <transport_data_free+0x34>)
   2f144:	6084      	str	r4, [r0, #8]
   2f146:	6002      	str	r2, [r0, #0]
   2f148:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2f14c:	f000 bc9a 	b.w	2fa84 <rpc_transport_ipc_tx_send>
   2f150:	f7fe bbc4 	b.w	2d8dc <nrf_shared_free>
   2f154:	bd10      	pop	{r4, pc}
   2f156:	bf00      	nop
   2f158:	2002517c 	.word	0x2002517c
   2f15c:	00020001 	.word	0x00020001

0002f160 <rpc_transport_ipc_init>:
   2f160:	2800      	cmp	r0, #0
   2f162:	d02b      	beq.n	2f1bc <rpc_transport_ipc_init+0x5c>
   2f164:	b530      	push	{r4, r5, lr}
   2f166:	b089      	sub	sp, #36	; 0x24
   2f168:	aa01      	add	r2, sp, #4
   2f16a:	4669      	mov	r1, sp
   2f16c:	4604      	mov	r4, r0
   2f16e:	f000 fb9f 	bl	2f8b0 <rpc_transport_ipc_tx_init>
   2f172:	4603      	mov	r3, r0
   2f174:	b140      	cbz	r0, 2f188 <rpc_transport_ipc_init+0x28>
   2f176:	4a13      	ldr	r2, [pc, #76]	; (2f1c4 <rpc_transport_ipc_init+0x64>)
   2f178:	f104 0028 	add.w	r0, r4, #40	; 0x28
   2f17c:	c803      	ldmia	r0, {r0, r1}
   2f17e:	e882 0003 	stmia.w	r2, {r0, r1}
   2f182:	4618      	mov	r0, r3
   2f184:	b009      	add	sp, #36	; 0x24
   2f186:	bd30      	pop	{r4, r5, pc}
   2f188:	e9dd 1200 	ldrd	r1, r2, [sp]
   2f18c:	4620      	mov	r0, r4
   2f18e:	f000 f84b 	bl	2f228 <rpc_transport_ipc_rx_init>
   2f192:	4603      	mov	r3, r0
   2f194:	2800      	cmp	r0, #0
   2f196:	d1ee      	bne.n	2f176 <rpc_transport_ipc_init+0x16>
   2f198:	4b0b      	ldr	r3, [pc, #44]	; (2f1c8 <rpc_transport_ipc_init+0x68>)
   2f19a:	490c      	ldr	r1, [pc, #48]	; (2f1cc <rpc_transport_ipc_init+0x6c>)
   2f19c:	480c      	ldr	r0, [pc, #48]	; (2f1d0 <rpc_transport_ipc_init+0x70>)
   2f19e:	4a0d      	ldr	r2, [pc, #52]	; (2f1d4 <rpc_transport_ipc_init+0x74>)
   2f1a0:	9303      	str	r3, [sp, #12]
   2f1a2:	4d0d      	ldr	r5, [pc, #52]	; (2f1d8 <rpc_transport_ipc_init+0x78>)
   2f1a4:	4b0d      	ldr	r3, [pc, #52]	; (2f1dc <rpc_transport_ipc_init+0x7c>)
   2f1a6:	9104      	str	r1, [sp, #16]
   2f1a8:	9005      	str	r0, [sp, #20]
   2f1aa:	490d      	ldr	r1, [pc, #52]	; (2f1e0 <rpc_transport_ipc_init+0x80>)
   2f1ac:	a802      	add	r0, sp, #8
   2f1ae:	9307      	str	r3, [sp, #28]
   2f1b0:	9506      	str	r5, [sp, #24]
   2f1b2:	9202      	str	r2, [sp, #8]
   2f1b4:	f003 ff44 	bl	33040 <rpc_transport_register>
   2f1b8:	4603      	mov	r3, r0
   2f1ba:	e7dc      	b.n	2f176 <rpc_transport_ipc_init+0x16>
   2f1bc:	230e      	movs	r3, #14
   2f1be:	4618      	mov	r0, r3
   2f1c0:	4770      	bx	lr
   2f1c2:	bf00      	nop
   2f1c4:	2002517c 	.word	0x2002517c
   2f1c8:	0002fb85 	.word	0x0002fb85
   2f1cc:	0002fc55 	.word	0x0002fc55
   2f1d0:	0002f845 	.word	0x0002f845
   2f1d4:	0002fa85 	.word	0x0002fa85
   2f1d8:	0002f129 	.word	0x0002f129
   2f1dc:	0002f125 	.word	0x0002f125
   2f1e0:	20025184 	.word	0x20025184

0002f1e4 <rpc_transport_rx_handle>:
   2f1e4:	b160      	cbz	r0, 2f200 <rpc_transport_rx_handle+0x1c>
   2f1e6:	b508      	push	{r3, lr}
   2f1e8:	6843      	ldr	r3, [r0, #4]
   2f1ea:	b2db      	uxtb	r3, r3
   2f1ec:	2b02      	cmp	r3, #2
   2f1ee:	d00e      	beq.n	2f20e <rpc_transport_rx_handle+0x2a>
   2f1f0:	6803      	ldr	r3, [r0, #0]
   2f1f2:	0c1b      	lsrs	r3, r3, #16
   2f1f4:	2b02      	cmp	r3, #2
   2f1f6:	d005      	beq.n	2f204 <rpc_transport_rx_handle+0x20>
   2f1f8:	2b04      	cmp	r3, #4
   2f1fa:	d00e      	beq.n	2f21a <rpc_transport_rx_handle+0x36>
   2f1fc:	2000      	movs	r0, #0
   2f1fe:	bd08      	pop	{r3, pc}
   2f200:	2000      	movs	r0, #0
   2f202:	4770      	bx	lr
   2f204:	6880      	ldr	r0, [r0, #8]
   2f206:	f7fe fb69 	bl	2d8dc <nrf_shared_free>
   2f20a:	2000      	movs	r0, #0
   2f20c:	bd08      	pop	{r3, pc}
   2f20e:	4601      	mov	r1, r0
   2f210:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   2f214:	4803      	ldr	r0, [pc, #12]	; (2f224 <rpc_transport_rx_handle+0x40>)
   2f216:	f003 be05 	b.w	32e24 <rpc_transport_input>
   2f21a:	4802      	ldr	r0, [pc, #8]	; (2f224 <rpc_transport_rx_handle+0x40>)
   2f21c:	f003 ff70 	bl	33100 <rpc_transport_unregister>
   2f220:	2000      	movs	r0, #0
   2f222:	bd08      	pop	{r3, pc}
   2f224:	20025184 	.word	0x20025184

0002f228 <rpc_transport_ipc_rx_init>:
   2f228:	2800      	cmp	r0, #0
   2f22a:	f000 80ff 	beq.w	2f42c <rpc_transport_ipc_rx_init+0x204>
   2f22e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2f232:	6805      	ldr	r5, [r0, #0]
   2f234:	b095      	sub	sp, #84	; 0x54
   2f236:	2d00      	cmp	r5, #0
   2f238:	f000 80ee 	beq.w	2f418 <rpc_transport_ipc_rx_init+0x1f0>
   2f23c:	6883      	ldr	r3, [r0, #8]
   2f23e:	2b00      	cmp	r3, #0
   2f240:	f000 80ea 	beq.w	2f418 <rpc_transport_ipc_rx_init+0x1f0>
   2f244:	6907      	ldr	r7, [r0, #16]
   2f246:	2f00      	cmp	r7, #0
   2f248:	f000 80e6 	beq.w	2f418 <rpc_transport_ipc_rx_init+0x1f0>
   2f24c:	6a84      	ldr	r4, [r0, #40]	; 0x28
   2f24e:	2c00      	cmp	r4, #0
   2f250:	f000 80e2 	beq.w	2f418 <rpc_transport_ipc_rx_init+0x1f0>
   2f254:	6844      	ldr	r4, [r0, #4]
   2f256:	2c1b      	cmp	r4, #27
   2f258:	f240 80e3 	bls.w	2f422 <rpc_transport_ipc_rx_init+0x1fa>
   2f25c:	68c4      	ldr	r4, [r0, #12]
   2f25e:	2c0b      	cmp	r4, #11
   2f260:	f240 80df 	bls.w	2f422 <rpc_transport_ipc_rx_init+0x1fa>
   2f264:	f8d0 e014 	ldr.w	lr, [r0, #20]
   2f268:	f1be 0f17 	cmp.w	lr, #23
   2f26c:	f240 80d9 	bls.w	2f422 <rpc_transport_ipc_rx_init+0x1fa>
   2f270:	2600      	movs	r6, #0
   2f272:	4604      	mov	r4, r0
   2f274:	486f      	ldr	r0, [pc, #444]	; (2f434 <rpc_transport_ipc_rx_init+0x20c>)
   2f276:	e9cd 1200 	strd	r1, r2, [sp]
   2f27a:	f8df a1d8 	ldr.w	sl, [pc, #472]	; 2f454 <rpc_transport_ipc_rx_init+0x22c>
   2f27e:	496e      	ldr	r1, [pc, #440]	; (2f438 <rpc_transport_ipc_rx_init+0x210>)
   2f280:	8006      	strh	r6, [r0, #0]
   2f282:	6ba0      	ldr	r0, [r4, #56]	; 0x38
   2f284:	f8df c1d0 	ldr.w	ip, [pc, #464]	; 2f458 <rpc_transport_ipc_rx_init+0x230>
   2f288:	f8df 81d0 	ldr.w	r8, [pc, #464]	; 2f45c <rpc_transport_ipc_rx_init+0x234>
   2f28c:	f8df b1d0 	ldr.w	fp, [pc, #464]	; 2f460 <rpc_transport_ipc_rx_init+0x238>
   2f290:	f8df 91d0 	ldr.w	r9, [pc, #464]	; 2f464 <rpc_transport_ipc_rx_init+0x23c>
   2f294:	4672      	mov	r2, lr
   2f296:	600e      	str	r6, [r1, #0]
   2f298:	f8ca 0000 	str.w	r0, [sl]
   2f29c:	4631      	mov	r1, r6
   2f29e:	4638      	mov	r0, r7
   2f2a0:	f8cc 6000 	str.w	r6, [ip]
   2f2a4:	f8cb 3000 	str.w	r3, [fp]
   2f2a8:	f8c8 6000 	str.w	r6, [r8]
   2f2ac:	f8c9 6000 	str.w	r6, [r9]
   2f2b0:	f00f faec 	bl	3e88c <memset>
   2f2b4:	69e3      	ldr	r3, [r4, #28]
   2f2b6:	4638      	mov	r0, r7
   2f2b8:	603b      	str	r3, [r7, #0]
   2f2ba:	69a3      	ldr	r3, [r4, #24]
   2f2bc:	607b      	str	r3, [r7, #4]
   2f2be:	f7ff fcd5 	bl	2ec6c <ipc_trace_init>
   2f2c2:	2201      	movs	r2, #1
   2f2c4:	f04f 0c04 	mov.w	ip, #4
   2f2c8:	4b5c      	ldr	r3, [pc, #368]	; (2f43c <rpc_transport_ipc_rx_init+0x214>)
   2f2ca:	495d      	ldr	r1, [pc, #372]	; (2f440 <rpc_transport_ipc_rx_init+0x218>)
   2f2cc:	f8c3 5610 	str.w	r5, [r3, #1552]	; 0x610
   2f2d0:	6809      	ldr	r1, [r1, #0]
   2f2d2:	2080      	movs	r0, #128	; 0x80
   2f2d4:	9104      	str	r1, [sp, #16]
   2f2d6:	495b      	ldr	r1, [pc, #364]	; (2f444 <rpc_transport_ipc_rx_init+0x21c>)
   2f2d8:	f8dd e010 	ldr.w	lr, [sp, #16]
   2f2dc:	f8c3 6614 	str.w	r6, [r3, #1556]	; 0x614
   2f2e0:	6809      	ldr	r1, [r1, #0]
   2f2e2:	702e      	strb	r6, [r5, #0]
   2f2e4:	9103      	str	r1, [sp, #12]
   2f2e6:	706e      	strb	r6, [r5, #1]
   2f2e8:	70ee      	strb	r6, [r5, #3]
   2f2ea:	70aa      	strb	r2, [r5, #2]
   2f2ec:	9903      	ldr	r1, [sp, #12]
   2f2ee:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   2f2f0:	f8db e000 	ldr.w	lr, [fp]
   2f2f4:	6069      	str	r1, [r5, #4]
   2f2f6:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   2f2f8:	9c01      	ldr	r4, [sp, #4]
   2f2fa:	60a9      	str	r1, [r5, #8]
   2f2fc:	60ec      	str	r4, [r5, #12]
   2f2fe:	9c00      	ldr	r4, [sp, #0]
   2f300:	4951      	ldr	r1, [pc, #324]	; (2f448 <rpc_transport_ipc_rx_init+0x220>)
   2f302:	61af      	str	r7, [r5, #24]
   2f304:	f8c5 e014 	str.w	lr, [r5, #20]
   2f308:	612c      	str	r4, [r5, #16]
   2f30a:	f8c3 2590 	str.w	r2, [r3, #1424]	; 0x590
   2f30e:	680c      	ldr	r4, [r1, #0]
   2f310:	f5a1 6192 	sub.w	r1, r1, #1168	; 0x490
   2f314:	9405      	str	r4, [sp, #20]
   2f316:	9c05      	ldr	r4, [sp, #20]
   2f318:	f8c3 c598 	str.w	ip, [r3, #1432]	; 0x598
   2f31c:	f8d1 4498 	ldr.w	r4, [r1, #1176]	; 0x498
   2f320:	f44f 6780 	mov.w	r7, #1024	; 0x400
   2f324:	9406      	str	r4, [sp, #24]
   2f326:	9c06      	ldr	r4, [sp, #24]
   2f328:	2410      	movs	r4, #16
   2f32a:	f8c3 45a0 	str.w	r4, [r3, #1440]	; 0x5a0
   2f32e:	f8d1 44a0 	ldr.w	r4, [r1, #1184]	; 0x4a0
   2f332:	4d46      	ldr	r5, [pc, #280]	; (2f44c <rpc_transport_ipc_rx_init+0x224>)
   2f334:	9407      	str	r4, [sp, #28]
   2f336:	9c07      	ldr	r4, [sp, #28]
   2f338:	2440      	movs	r4, #64	; 0x40
   2f33a:	f8c3 45a8 	str.w	r4, [r3, #1448]	; 0x5a8
   2f33e:	f8d1 44a8 	ldr.w	r4, [r1, #1192]	; 0x4a8
   2f342:	9408      	str	r4, [sp, #32]
   2f344:	9c08      	ldr	r4, [sp, #32]
   2f346:	f8c3 05ac 	str.w	r0, [r3, #1452]	; 0x5ac
   2f34a:	f8d1 04ac 	ldr.w	r0, [r1, #1196]	; 0x4ac
   2f34e:	9009      	str	r0, [sp, #36]	; 0x24
   2f350:	9809      	ldr	r0, [sp, #36]	; 0x24
   2f352:	f8c3 6100 	str.w	r6, [r3, #256]	; 0x100
   2f356:	6808      	ldr	r0, [r1, #0]
   2f358:	900a      	str	r0, [sp, #40]	; 0x28
   2f35a:	980a      	ldr	r0, [sp, #40]	; 0x28
   2f35c:	f8c3 6108 	str.w	r6, [r3, #264]	; 0x108
   2f360:	6888      	ldr	r0, [r1, #8]
   2f362:	900b      	str	r0, [sp, #44]	; 0x2c
   2f364:	980b      	ldr	r0, [sp, #44]	; 0x2c
   2f366:	f8c3 6110 	str.w	r6, [r3, #272]	; 0x110
   2f36a:	6908      	ldr	r0, [r1, #16]
   2f36c:	900c      	str	r0, [sp, #48]	; 0x30
   2f36e:	980c      	ldr	r0, [sp, #48]	; 0x30
   2f370:	f8c3 6118 	str.w	r6, [r3, #280]	; 0x118
   2f374:	6988      	ldr	r0, [r1, #24]
   2f376:	900d      	str	r0, [sp, #52]	; 0x34
   2f378:	980d      	ldr	r0, [sp, #52]	; 0x34
   2f37a:	f8c3 611c 	str.w	r6, [r3, #284]	; 0x11c
   2f37e:	69c8      	ldr	r0, [r1, #28]
   2f380:	f501 7101 	add.w	r1, r1, #516	; 0x204
   2f384:	900e      	str	r0, [sp, #56]	; 0x38
   2f386:	980e      	ldr	r0, [sp, #56]	; 0x38
   2f388:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
   2f38c:	4310      	orrs	r0, r2
   2f38e:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
   2f392:	680c      	ldr	r4, [r1, #0]
   2f394:	482e      	ldr	r0, [pc, #184]	; (2f450 <rpc_transport_ipc_rx_init+0x228>)
   2f396:	940f      	str	r4, [sp, #60]	; 0x3c
   2f398:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
   2f39a:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   2f39e:	ea44 040c 	orr.w	r4, r4, ip
   2f3a2:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   2f3a6:	680c      	ldr	r4, [r1, #0]
   2f3a8:	9410      	str	r4, [sp, #64]	; 0x40
   2f3aa:	9c10      	ldr	r4, [sp, #64]	; 0x40
   2f3ac:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   2f3b0:	f044 0410 	orr.w	r4, r4, #16
   2f3b4:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   2f3b8:	680c      	ldr	r4, [r1, #0]
   2f3ba:	9411      	str	r4, [sp, #68]	; 0x44
   2f3bc:	9c11      	ldr	r4, [sp, #68]	; 0x44
   2f3be:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   2f3c2:	f044 0440 	orr.w	r4, r4, #64	; 0x40
   2f3c6:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   2f3ca:	680c      	ldr	r4, [r1, #0]
   2f3cc:	9412      	str	r4, [sp, #72]	; 0x48
   2f3ce:	9c12      	ldr	r4, [sp, #72]	; 0x48
   2f3d0:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   2f3d4:	f044 0480 	orr.w	r4, r4, #128	; 0x80
   2f3d8:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   2f3dc:	f8da 3000 	ldr.w	r3, [sl]
   2f3e0:	6809      	ldr	r1, [r1, #0]
   2f3e2:	015b      	lsls	r3, r3, #5
   2f3e4:	9113      	str	r1, [sp, #76]	; 0x4c
   2f3e6:	b2db      	uxtb	r3, r3
   2f3e8:	9913      	ldr	r1, [sp, #76]	; 0x4c
   2f3ea:	f8c8 2000 	str.w	r2, [r8]
   2f3ee:	f880 332a 	strb.w	r3, [r0, #810]	; 0x32a
   2f3f2:	f8c0 7184 	str.w	r7, [r0, #388]	; 0x184
   2f3f6:	6047      	str	r7, [r0, #4]
   2f3f8:	9602      	str	r6, [sp, #8]
   2f3fa:	f8c5 6610 	str.w	r6, [r5, #1552]	; 0x610
   2f3fe:	f8d5 3610 	ldr.w	r3, [r5, #1552]	; 0x610
   2f402:	9302      	str	r3, [sp, #8]
   2f404:	9b02      	ldr	r3, [sp, #8]
   2f406:	f8d8 3000 	ldr.w	r3, [r8]
   2f40a:	2b01      	cmp	r3, #1
   2f40c:	d0fb      	beq.n	2f406 <rpc_transport_ipc_rx_init+0x1de>
   2f40e:	f8d9 0000 	ldr.w	r0, [r9]
   2f412:	b015      	add	sp, #84	; 0x54
   2f414:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2f418:	f24c 000e 	movw	r0, #49166	; 0xc00e
   2f41c:	b015      	add	sp, #84	; 0x54
   2f41e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2f422:	f24c 0009 	movw	r0, #49161	; 0xc009
   2f426:	b015      	add	sp, #84	; 0x54
   2f428:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2f42c:	f24c 000e 	movw	r0, #49166	; 0xc00e
   2f430:	4770      	bx	lr
   2f432:	bf00      	nop
   2f434:	2002990e 	.word	0x2002990e
   2f438:	20025194 	.word	0x20025194
   2f43c:	4002a000 	.word	0x4002a000
   2f440:	4002a610 	.word	0x4002a610
   2f444:	4002a614 	.word	0x4002a614
   2f448:	4002a590 	.word	0x4002a590
   2f44c:	40005000 	.word	0x40005000
   2f450:	e000e100 	.word	0xe000e100
   2f454:	2002518c 	.word	0x2002518c
   2f458:	20025198 	.word	0x20025198
   2f45c:	20025190 	.word	0x20025190
   2f460:	2002519c 	.word	0x2002519c
   2f464:	20025188 	.word	0x20025188

0002f468 <IPC_IRQHandler>:
   2f468:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2f46c:	f44f 6580 	mov.w	r5, #1024	; 0x400
   2f470:	4ca7      	ldr	r4, [pc, #668]	; (2f710 <IPC_IRQHandler+0x2a8>)
   2f472:	b087      	sub	sp, #28
   2f474:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
   2f478:	f3bf 8f4f 	dsb	sy
   2f47c:	f3bf 8f6f 	isb	sy
   2f480:	4ea4      	ldr	r6, [pc, #656]	; (2f714 <IPC_IRQHandler+0x2ac>)
   2f482:	f8c4 5184 	str.w	r5, [r4, #388]	; 0x184
   2f486:	f8d6 330c 	ldr.w	r3, [r6, #780]	; 0x30c
   2f48a:	061f      	lsls	r7, r3, #24
   2f48c:	f100 80c8 	bmi.w	2f620 <IPC_IRQHandler+0x1b8>
   2f490:	4ba0      	ldr	r3, [pc, #640]	; (2f714 <IPC_IRQHandler+0x2ac>)
   2f492:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
   2f496:	07d0      	lsls	r0, r2, #31
   2f498:	f100 80d4 	bmi.w	2f644 <IPC_IRQHandler+0x1dc>
   2f49c:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
   2f4a0:	f012 0240 	ands.w	r2, r2, #64	; 0x40
   2f4a4:	f040 80b6 	bne.w	2f614 <IPC_IRQHandler+0x1ac>
   2f4a8:	f8d3 130c 	ldr.w	r1, [r3, #780]	; 0x30c
   2f4ac:	0749      	lsls	r1, r1, #29
   2f4ae:	f100 80e6 	bmi.w	2f67e <IPC_IRQHandler+0x216>
   2f4b2:	f8d3 330c 	ldr.w	r3, [r3, #780]	; 0x30c
   2f4b6:	06da      	lsls	r2, r3, #27
   2f4b8:	f140 809d 	bpl.w	2f5f6 <IPC_IRQHandler+0x18e>
   2f4bc:	2100      	movs	r1, #0
   2f4be:	4a95      	ldr	r2, [pc, #596]	; (2f714 <IPC_IRQHandler+0x2ac>)
   2f4c0:	4b95      	ldr	r3, [pc, #596]	; (2f718 <IPC_IRQHandler+0x2b0>)
   2f4c2:	f8c2 1110 	str.w	r1, [r2, #272]	; 0x110
   2f4c6:	681b      	ldr	r3, [r3, #0]
   2f4c8:	9304      	str	r3, [sp, #16]
   2f4ca:	9b04      	ldr	r3, [sp, #16]
   2f4cc:	f8df 8270 	ldr.w	r8, [pc, #624]	; 2f740 <IPC_IRQHandler+0x2d8>
   2f4d0:	4f92      	ldr	r7, [pc, #584]	; (2f71c <IPC_IRQHandler+0x2b4>)
   2f4d2:	f8df 9270 	ldr.w	r9, [pc, #624]	; 2f744 <IPC_IRQHandler+0x2dc>
   2f4d6:	f8d8 a000 	ldr.w	sl, [r8]
   2f4da:	f8da 1000 	ldr.w	r1, [sl]
   2f4de:	2900      	cmp	r1, #0
   2f4e0:	d03f      	beq.n	2f562 <IPC_IRQHandler+0xfa>
   2f4e2:	2200      	movs	r2, #0
   2f4e4:	4614      	mov	r4, r2
   2f4e6:	e002      	b.n	2f4ee <IPC_IRQHandler+0x86>
   2f4e8:	3401      	adds	r4, #1
   2f4ea:	428c      	cmp	r4, r1
   2f4ec:	d227      	bcs.n	2f53e <IPC_IRQHandler+0xd6>
   2f4ee:	eb0a 05c4 	add.w	r5, sl, r4, lsl #3
   2f4f2:	68ab      	ldr	r3, [r5, #8]
   2f4f4:	2b00      	cmp	r3, #0
   2f4f6:	d0f7      	beq.n	2f4e8 <IPC_IRQHandler+0x80>
   2f4f8:	686e      	ldr	r6, [r5, #4]
   2f4fa:	b2f6      	uxtb	r6, r6
   2f4fc:	2e01      	cmp	r6, #1
   2f4fe:	d1f3      	bne.n	2f4e8 <IPC_IRQHandler+0x80>
   2f500:	6868      	ldr	r0, [r5, #4]
   2f502:	f8b9 3000 	ldrh.w	r3, [r9]
   2f506:	ebb3 4f10 	cmp.w	r3, r0, lsr #16
   2f50a:	d1ed      	bne.n	2f4e8 <IPC_IRQHandler+0x80>
   2f50c:	686a      	ldr	r2, [r5, #4]
   2f50e:	3301      	adds	r3, #1
   2f510:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   2f514:	f042 0202 	orr.w	r2, r2, #2
   2f518:	606a      	str	r2, [r5, #4]
   2f51a:	68a8      	ldr	r0, [r5, #8]
   2f51c:	f8a9 3000 	strh.w	r3, [r9]
   2f520:	f7ff fe60 	bl	2f1e4 <rpc_transport_rx_handle>
   2f524:	4632      	mov	r2, r6
   2f526:	b928      	cbnz	r0, 2f534 <IPC_IRQHandler+0xcc>
   2f528:	686b      	ldr	r3, [r5, #4]
   2f52a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   2f52e:	f043 0303 	orr.w	r3, r3, #3
   2f532:	606b      	str	r3, [r5, #4]
   2f534:	f8da 1000 	ldr.w	r1, [sl]
   2f538:	3401      	adds	r4, #1
   2f53a:	428c      	cmp	r4, r1
   2f53c:	d3d7      	bcc.n	2f4ee <IPC_IRQHandler+0x86>
   2f53e:	2a00      	cmp	r2, #0
   2f540:	d1cd      	bne.n	2f4de <IPC_IRQHandler+0x76>
   2f542:	b171      	cbz	r1, 2f562 <IPC_IRQHandler+0xfa>
   2f544:	4613      	mov	r3, r2
   2f546:	eb0a 02c3 	add.w	r2, sl, r3, lsl #3
   2f54a:	6890      	ldr	r0, [r2, #8]
   2f54c:	3301      	adds	r3, #1
   2f54e:	b130      	cbz	r0, 2f55e <IPC_IRQHandler+0xf6>
   2f550:	f8d2 b004 	ldr.w	fp, [r2, #4]
   2f554:	fa5f fb8b 	uxtb.w	fp, fp
   2f558:	f1bb 0f01 	cmp.w	fp, #1
   2f55c:	d003      	beq.n	2f566 <IPC_IRQHandler+0xfe>
   2f55e:	428b      	cmp	r3, r1
   2f560:	d1f1      	bne.n	2f546 <IPC_IRQHandler+0xde>
   2f562:	f04f 0b00 	mov.w	fp, #0
   2f566:	f8d7 a000 	ldr.w	sl, [r7]
   2f56a:	f8da 2000 	ldr.w	r2, [sl]
   2f56e:	2a00      	cmp	r2, #0
   2f570:	d03d      	beq.n	2f5ee <IPC_IRQHandler+0x186>
   2f572:	2100      	movs	r1, #0
   2f574:	460c      	mov	r4, r1
   2f576:	e002      	b.n	2f57e <IPC_IRQHandler+0x116>
   2f578:	3401      	adds	r4, #1
   2f57a:	4294      	cmp	r4, r2
   2f57c:	d227      	bcs.n	2f5ce <IPC_IRQHandler+0x166>
   2f57e:	eb0a 05c4 	add.w	r5, sl, r4, lsl #3
   2f582:	68ab      	ldr	r3, [r5, #8]
   2f584:	2b00      	cmp	r3, #0
   2f586:	d0f7      	beq.n	2f578 <IPC_IRQHandler+0x110>
   2f588:	686e      	ldr	r6, [r5, #4]
   2f58a:	b2f6      	uxtb	r6, r6
   2f58c:	2e01      	cmp	r6, #1
   2f58e:	d1f3      	bne.n	2f578 <IPC_IRQHandler+0x110>
   2f590:	6868      	ldr	r0, [r5, #4]
   2f592:	f8b9 3000 	ldrh.w	r3, [r9]
   2f596:	ebb3 4f10 	cmp.w	r3, r0, lsr #16
   2f59a:	d1ed      	bne.n	2f578 <IPC_IRQHandler+0x110>
   2f59c:	686a      	ldr	r2, [r5, #4]
   2f59e:	3301      	adds	r3, #1
   2f5a0:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   2f5a4:	f042 0202 	orr.w	r2, r2, #2
   2f5a8:	606a      	str	r2, [r5, #4]
   2f5aa:	68a8      	ldr	r0, [r5, #8]
   2f5ac:	f8a9 3000 	strh.w	r3, [r9]
   2f5b0:	f7ff fe18 	bl	2f1e4 <rpc_transport_rx_handle>
   2f5b4:	4631      	mov	r1, r6
   2f5b6:	b928      	cbnz	r0, 2f5c4 <IPC_IRQHandler+0x15c>
   2f5b8:	686a      	ldr	r2, [r5, #4]
   2f5ba:	f022 03ff 	bic.w	r3, r2, #255	; 0xff
   2f5be:	f043 0303 	orr.w	r3, r3, #3
   2f5c2:	606b      	str	r3, [r5, #4]
   2f5c4:	f8da 2000 	ldr.w	r2, [sl]
   2f5c8:	3401      	adds	r4, #1
   2f5ca:	4294      	cmp	r4, r2
   2f5cc:	d3d7      	bcc.n	2f57e <IPC_IRQHandler+0x116>
   2f5ce:	2900      	cmp	r1, #0
   2f5d0:	d1cd      	bne.n	2f56e <IPC_IRQHandler+0x106>
   2f5d2:	b162      	cbz	r2, 2f5ee <IPC_IRQHandler+0x186>
   2f5d4:	460b      	mov	r3, r1
   2f5d6:	eb0a 01c3 	add.w	r1, sl, r3, lsl #3
   2f5da:	6888      	ldr	r0, [r1, #8]
   2f5dc:	3301      	adds	r3, #1
   2f5de:	b120      	cbz	r0, 2f5ea <IPC_IRQHandler+0x182>
   2f5e0:	6849      	ldr	r1, [r1, #4]
   2f5e2:	b2c9      	uxtb	r1, r1
   2f5e4:	2901      	cmp	r1, #1
   2f5e6:	f43f af76 	beq.w	2f4d6 <IPC_IRQHandler+0x6e>
   2f5ea:	4293      	cmp	r3, r2
   2f5ec:	d1f3      	bne.n	2f5d6 <IPC_IRQHandler+0x16e>
   2f5ee:	f1bb 0f00 	cmp.w	fp, #0
   2f5f2:	f47f af70 	bne.w	2f4d6 <IPC_IRQHandler+0x6e>
   2f5f6:	f44f 6180 	mov.w	r1, #1024	; 0x400
   2f5fa:	4b49      	ldr	r3, [pc, #292]	; (2f720 <IPC_IRQHandler+0x2b8>)
   2f5fc:	4a44      	ldr	r2, [pc, #272]	; (2f710 <IPC_IRQHandler+0x2a8>)
   2f5fe:	681b      	ldr	r3, [r3, #0]
   2f600:	015b      	lsls	r3, r3, #5
   2f602:	b2db      	uxtb	r3, r3
   2f604:	f882 332a 	strb.w	r3, [r2, #810]	; 0x32a
   2f608:	f8c2 1184 	str.w	r1, [r2, #388]	; 0x184
   2f60c:	6051      	str	r1, [r2, #4]
   2f60e:	b007      	add	sp, #28
   2f610:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2f614:	2206      	movs	r2, #6
   2f616:	4b43      	ldr	r3, [pc, #268]	; (2f724 <IPC_IRQHandler+0x2bc>)
   2f618:	601a      	str	r2, [r3, #0]
   2f61a:	b007      	add	sp, #28
   2f61c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2f620:	f7ff fc0c 	bl	2ee3c <ipc_trace_handle>
   2f624:	f7ff fd78 	bl	2f118 <rpc_trace_coredump_in_progress>
   2f628:	2800      	cmp	r0, #0
   2f62a:	d149      	bne.n	2f6c0 <IPC_IRQHandler+0x258>
   2f62c:	4b3e      	ldr	r3, [pc, #248]	; (2f728 <IPC_IRQHandler+0x2c0>)
   2f62e:	f8c6 011c 	str.w	r0, [r6, #284]	; 0x11c
   2f632:	681b      	ldr	r3, [r3, #0]
   2f634:	9301      	str	r3, [sp, #4]
   2f636:	9b01      	ldr	r3, [sp, #4]
   2f638:	4b36      	ldr	r3, [pc, #216]	; (2f714 <IPC_IRQHandler+0x2ac>)
   2f63a:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
   2f63e:	07d0      	lsls	r0, r2, #31
   2f640:	f57f af2c 	bpl.w	2f49c <IPC_IRQHandler+0x34>
   2f644:	2000      	movs	r0, #0
   2f646:	f248 0202 	movw	r2, #32770	; 0x8002
   2f64a:	4938      	ldr	r1, [pc, #224]	; (2f72c <IPC_IRQHandler+0x2c4>)
   2f64c:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
   2f650:	6809      	ldr	r1, [r1, #0]
   2f652:	9102      	str	r1, [sp, #8]
   2f654:	9902      	ldr	r1, [sp, #8]
   2f656:	f8d3 3614 	ldr.w	r3, [r3, #1556]	; 0x614
   2f65a:	4293      	cmp	r3, r2
   2f65c:	d040      	beq.n	2f6e0 <IPC_IRQHandler+0x278>
   2f65e:	d81e      	bhi.n	2f69e <IPC_IRQHandler+0x236>
   2f660:	2b00      	cmp	r3, #0
   2f662:	d04f      	beq.n	2f704 <IPC_IRQHandler+0x29c>
   2f664:	2b02      	cmp	r3, #2
   2f666:	d942      	bls.n	2f6ee <IPC_IRQHandler+0x286>
   2f668:	f248 0201 	movw	r2, #32769	; 0x8001
   2f66c:	4293      	cmp	r3, r2
   2f66e:	d149      	bne.n	2f704 <IPC_IRQHandler+0x29c>
   2f670:	2003      	movs	r0, #3
   2f672:	2207      	movs	r2, #7
   2f674:	492b      	ldr	r1, [pc, #172]	; (2f724 <IPC_IRQHandler+0x2bc>)
   2f676:	4b2e      	ldr	r3, [pc, #184]	; (2f730 <IPC_IRQHandler+0x2c8>)
   2f678:	6008      	str	r0, [r1, #0]
   2f67a:	601a      	str	r2, [r3, #0]
   2f67c:	e7cd      	b.n	2f61a <IPC_IRQHandler+0x1b2>
   2f67e:	4d29      	ldr	r5, [pc, #164]	; (2f724 <IPC_IRQHandler+0x2bc>)
   2f680:	6829      	ldr	r1, [r5, #0]
   2f682:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   2f686:	2901      	cmp	r1, #1
   2f688:	492a      	ldr	r1, [pc, #168]	; (2f734 <IPC_IRQHandler+0x2cc>)
   2f68a:	d05d      	beq.n	2f748 <IPC_IRQHandler+0x2e0>
   2f68c:	680a      	ldr	r2, [r1, #0]
   2f68e:	9203      	str	r2, [sp, #12]
   2f690:	9a03      	ldr	r2, [sp, #12]
   2f692:	f8d3 330c 	ldr.w	r3, [r3, #780]	; 0x30c
   2f696:	06db      	lsls	r3, r3, #27
   2f698:	f53f af10 	bmi.w	2f4bc <IPC_IRQHandler+0x54>
   2f69c:	e716      	b.n	2f4cc <IPC_IRQHandler+0x64>
   2f69e:	4a26      	ldr	r2, [pc, #152]	; (2f738 <IPC_IRQHandler+0x2d0>)
   2f6a0:	4293      	cmp	r3, r2
   2f6a2:	d814      	bhi.n	2f6ce <IPC_IRQHandler+0x266>
   2f6a4:	f1b3 6f88 	cmp.w	r3, #71303168	; 0x4400000
   2f6a8:	d814      	bhi.n	2f6d4 <IPC_IRQHandler+0x26c>
   2f6aa:	f248 0203 	movw	r2, #32771	; 0x8003
   2f6ae:	4293      	cmp	r3, r2
   2f6b0:	d128      	bne.n	2f704 <IPC_IRQHandler+0x29c>
   2f6b2:	2003      	movs	r0, #3
   2f6b4:	2204      	movs	r2, #4
   2f6b6:	491b      	ldr	r1, [pc, #108]	; (2f724 <IPC_IRQHandler+0x2bc>)
   2f6b8:	4b1d      	ldr	r3, [pc, #116]	; (2f730 <IPC_IRQHandler+0x2c8>)
   2f6ba:	6008      	str	r0, [r1, #0]
   2f6bc:	601a      	str	r2, [r3, #0]
   2f6be:	e7ac      	b.n	2f61a <IPC_IRQHandler+0x1b2>
   2f6c0:	23e0      	movs	r3, #224	; 0xe0
   2f6c2:	f884 332a 	strb.w	r3, [r4, #810]	; 0x32a
   2f6c6:	6065      	str	r5, [r4, #4]
   2f6c8:	b007      	add	sp, #28
   2f6ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2f6ce:	4a1b      	ldr	r2, [pc, #108]	; (2f73c <IPC_IRQHandler+0x2d4>)
   2f6d0:	4293      	cmp	r3, r2
   2f6d2:	d117      	bne.n	2f704 <IPC_IRQHandler+0x29c>
   2f6d4:	2003      	movs	r0, #3
   2f6d6:	4913      	ldr	r1, [pc, #76]	; (2f724 <IPC_IRQHandler+0x2bc>)
   2f6d8:	4a15      	ldr	r2, [pc, #84]	; (2f730 <IPC_IRQHandler+0x2c8>)
   2f6da:	6008      	str	r0, [r1, #0]
   2f6dc:	6013      	str	r3, [r2, #0]
   2f6de:	e79c      	b.n	2f61a <IPC_IRQHandler+0x1b2>
   2f6e0:	2003      	movs	r0, #3
   2f6e2:	2206      	movs	r2, #6
   2f6e4:	490f      	ldr	r1, [pc, #60]	; (2f724 <IPC_IRQHandler+0x2bc>)
   2f6e6:	4b12      	ldr	r3, [pc, #72]	; (2f730 <IPC_IRQHandler+0x2c8>)
   2f6e8:	6008      	str	r0, [r1, #0]
   2f6ea:	601a      	str	r2, [r3, #0]
   2f6ec:	e795      	b.n	2f61a <IPC_IRQHandler+0x1b2>
   2f6ee:	2303      	movs	r3, #3
   2f6f0:	4618      	mov	r0, r3
   2f6f2:	490c      	ldr	r1, [pc, #48]	; (2f724 <IPC_IRQHandler+0x2bc>)
   2f6f4:	4a0e      	ldr	r2, [pc, #56]	; (2f730 <IPC_IRQHandler+0x2c8>)
   2f6f6:	600b      	str	r3, [r1, #0]
   2f6f8:	6013      	str	r3, [r2, #0]
   2f6fa:	b007      	add	sp, #28
   2f6fc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2f700:	f7ff b910 	b.w	2e924 <rpc_transport_ipc_fault_handler>
   2f704:	2303      	movs	r3, #3
   2f706:	4907      	ldr	r1, [pc, #28]	; (2f724 <IPC_IRQHandler+0x2bc>)
   2f708:	4a09      	ldr	r2, [pc, #36]	; (2f730 <IPC_IRQHandler+0x2c8>)
   2f70a:	600b      	str	r3, [r1, #0]
   2f70c:	6013      	str	r3, [r2, #0]
   2f70e:	e784      	b.n	2f61a <IPC_IRQHandler+0x1b2>
   2f710:	e000e100 	.word	0xe000e100
   2f714:	4002a000 	.word	0x4002a000
   2f718:	4002a110 	.word	0x4002a110
   2f71c:	20025194 	.word	0x20025194
   2f720:	2002518c 	.word	0x2002518c
   2f724:	20025190 	.word	0x20025190
   2f728:	4002a11c 	.word	0x4002a11c
   2f72c:	4002a100 	.word	0x4002a100
   2f730:	20025188 	.word	0x20025188
   2f734:	4002a108 	.word	0x4002a108
   2f738:	04400004 	.word	0x04400004
   2f73c:	05500001 	.word	0x05500001
   2f740:	20025198 	.word	0x20025198
   2f744:	2002990e 	.word	0x2002990e
   2f748:	4a37      	ldr	r2, [pc, #220]	; (2f828 <IPC_IRQHandler+0x3c0>)
   2f74a:	680b      	ldr	r3, [r1, #0]
   2f74c:	6812      	ldr	r2, [r2, #0]
   2f74e:	9305      	str	r3, [sp, #20]
   2f750:	6893      	ldr	r3, [r2, #8]
   2f752:	4836      	ldr	r0, [pc, #216]	; (2f82c <IPC_IRQHandler+0x3c4>)
   2f754:	4936      	ldr	r1, [pc, #216]	; (2f830 <IPC_IRQHandler+0x3c8>)
   2f756:	6003      	str	r3, [r0, #0]
   2f758:	6854      	ldr	r4, [r2, #4]
   2f75a:	9a05      	ldr	r2, [sp, #20]
   2f75c:	600c      	str	r4, [r1, #0]
   2f75e:	b16b      	cbz	r3, 2f77c <IPC_IRQHandler+0x314>
   2f760:	b164      	cbz	r4, 2f77c <IPC_IRQHandler+0x314>
   2f762:	681b      	ldr	r3, [r3, #0]
   2f764:	2b10      	cmp	r3, #16
   2f766:	d802      	bhi.n	2f76e <IPC_IRQHandler+0x306>
   2f768:	6822      	ldr	r2, [r4, #0]
   2f76a:	2a10      	cmp	r2, #16
   2f76c:	d90c      	bls.n	2f788 <IPC_IRQHandler+0x320>
   2f76e:	2103      	movs	r1, #3
   2f770:	f24c 0206 	movw	r2, #49158	; 0xc006
   2f774:	4b2f      	ldr	r3, [pc, #188]	; (2f834 <IPC_IRQHandler+0x3cc>)
   2f776:	6029      	str	r1, [r5, #0]
   2f778:	601a      	str	r2, [r3, #0]
   2f77a:	e74e      	b.n	2f61a <IPC_IRQHandler+0x1b2>
   2f77c:	2103      	movs	r1, #3
   2f77e:	2210      	movs	r2, #16
   2f780:	4b2c      	ldr	r3, [pc, #176]	; (2f834 <IPC_IRQHandler+0x3cc>)
   2f782:	6029      	str	r1, [r5, #0]
   2f784:	601a      	str	r2, [r3, #0]
   2f786:	e748      	b.n	2f61a <IPC_IRQHandler+0x1b2>
   2f788:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 2f840 <IPC_IRQHandler+0x3d8>
   2f78c:	2a00      	cmp	r2, #0
   2f78e:	d042      	beq.n	2f816 <IPC_IRQHandler+0x3ae>
   2f790:	2300      	movs	r3, #0
   2f792:	f104 0904 	add.w	r9, r4, #4
   2f796:	461e      	mov	r6, r3
   2f798:	e002      	b.n	2f7a0 <IPC_IRQHandler+0x338>
   2f79a:	3601      	adds	r6, #1
   2f79c:	4296      	cmp	r6, r2
   2f79e:	d22a      	bcs.n	2f7f6 <IPC_IRQHandler+0x38e>
   2f7a0:	00f7      	lsls	r7, r6, #3
   2f7a2:	19e1      	adds	r1, r4, r7
   2f7a4:	6888      	ldr	r0, [r1, #8]
   2f7a6:	2800      	cmp	r0, #0
   2f7a8:	d0f7      	beq.n	2f79a <IPC_IRQHandler+0x332>
   2f7aa:	f8d1 a004 	ldr.w	sl, [r1, #4]
   2f7ae:	fa5f fa8a 	uxtb.w	sl, sl
   2f7b2:	f1ba 0f01 	cmp.w	sl, #1
   2f7b6:	d1f0      	bne.n	2f79a <IPC_IRQHandler+0x332>
   2f7b8:	f8d1 c004 	ldr.w	ip, [r1, #4]
   2f7bc:	f8b8 0000 	ldrh.w	r0, [r8]
   2f7c0:	ebb0 4f1c 	cmp.w	r0, ip, lsr #16
   2f7c4:	d1e9      	bne.n	2f79a <IPC_IRQHandler+0x332>
   2f7c6:	684b      	ldr	r3, [r1, #4]
   2f7c8:	1c42      	adds	r2, r0, #1
   2f7ca:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   2f7ce:	f043 0302 	orr.w	r3, r3, #2
   2f7d2:	604b      	str	r3, [r1, #4]
   2f7d4:	6888      	ldr	r0, [r1, #8]
   2f7d6:	f8a8 2000 	strh.w	r2, [r8]
   2f7da:	f7ff fd03 	bl	2f1e4 <rpc_transport_rx_handle>
   2f7de:	4653      	mov	r3, sl
   2f7e0:	b938      	cbnz	r0, 2f7f2 <IPC_IRQHandler+0x38a>
   2f7e2:	f859 2007 	ldr.w	r2, [r9, r7]
   2f7e6:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   2f7ea:	f042 0203 	orr.w	r2, r2, #3
   2f7ee:	f849 2007 	str.w	r2, [r9, r7]
   2f7f2:	6822      	ldr	r2, [r4, #0]
   2f7f4:	e7d1      	b.n	2f79a <IPC_IRQHandler+0x332>
   2f7f6:	2b00      	cmp	r3, #0
   2f7f8:	d1c8      	bne.n	2f78c <IPC_IRQHandler+0x324>
   2f7fa:	b912      	cbnz	r2, 2f802 <IPC_IRQHandler+0x39a>
   2f7fc:	e00b      	b.n	2f816 <IPC_IRQHandler+0x3ae>
   2f7fe:	4293      	cmp	r3, r2
   2f800:	d009      	beq.n	2f816 <IPC_IRQHandler+0x3ae>
   2f802:	eb04 01c3 	add.w	r1, r4, r3, lsl #3
   2f806:	6888      	ldr	r0, [r1, #8]
   2f808:	3301      	adds	r3, #1
   2f80a:	2800      	cmp	r0, #0
   2f80c:	d0f7      	beq.n	2f7fe <IPC_IRQHandler+0x396>
   2f80e:	6849      	ldr	r1, [r1, #4]
   2f810:	b2c9      	uxtb	r1, r1
   2f812:	2901      	cmp	r1, #1
   2f814:	d1f3      	bne.n	2f7fe <IPC_IRQHandler+0x396>
   2f816:	2002      	movs	r0, #2
   2f818:	4b07      	ldr	r3, [pc, #28]	; (2f838 <IPC_IRQHandler+0x3d0>)
   2f81a:	f44f 6180 	mov.w	r1, #1024	; 0x400
   2f81e:	4a07      	ldr	r2, [pc, #28]	; (2f83c <IPC_IRQHandler+0x3d4>)
   2f820:	681b      	ldr	r3, [r3, #0]
   2f822:	6028      	str	r0, [r5, #0]
   2f824:	e6ec      	b.n	2f600 <IPC_IRQHandler+0x198>
   2f826:	bf00      	nop
   2f828:	2002519c 	.word	0x2002519c
   2f82c:	20025198 	.word	0x20025198
   2f830:	20025194 	.word	0x20025194
   2f834:	20025188 	.word	0x20025188
   2f838:	2002518c 	.word	0x2002518c
   2f83c:	e000e100 	.word	0xe000e100
   2f840:	2002990e 	.word	0x2002990e

0002f844 <rpc_transport_msg_free>:
   2f844:	b430      	push	{r4, r5}
   2f846:	4b18      	ldr	r3, [pc, #96]	; (2f8a8 <rpc_transport_msg_free+0x64>)
   2f848:	681c      	ldr	r4, [r3, #0]
   2f84a:	6825      	ldr	r5, [r4, #0]
   2f84c:	b16d      	cbz	r5, 2f86a <rpc_transport_msg_free+0x26>
   2f84e:	68a3      	ldr	r3, [r4, #8]
   2f850:	4283      	cmp	r3, r0
   2f852:	d027      	beq.n	2f8a4 <rpc_transport_msg_free+0x60>
   2f854:	2300      	movs	r3, #0
   2f856:	e002      	b.n	2f85e <rpc_transport_msg_free+0x1a>
   2f858:	6889      	ldr	r1, [r1, #8]
   2f85a:	4281      	cmp	r1, r0
   2f85c:	d019      	beq.n	2f892 <rpc_transport_msg_free+0x4e>
   2f85e:	3301      	adds	r3, #1
   2f860:	00da      	lsls	r2, r3, #3
   2f862:	42ab      	cmp	r3, r5
   2f864:	eb04 0102 	add.w	r1, r4, r2
   2f868:	d1f6      	bne.n	2f858 <rpc_transport_msg_free+0x14>
   2f86a:	4b10      	ldr	r3, [pc, #64]	; (2f8ac <rpc_transport_msg_free+0x68>)
   2f86c:	681c      	ldr	r4, [r3, #0]
   2f86e:	6825      	ldr	r5, [r4, #0]
   2f870:	b16d      	cbz	r5, 2f88e <rpc_transport_msg_free+0x4a>
   2f872:	68a3      	ldr	r3, [r4, #8]
   2f874:	4283      	cmp	r3, r0
   2f876:	d015      	beq.n	2f8a4 <rpc_transport_msg_free+0x60>
   2f878:	2300      	movs	r3, #0
   2f87a:	e002      	b.n	2f882 <rpc_transport_msg_free+0x3e>
   2f87c:	6889      	ldr	r1, [r1, #8]
   2f87e:	4281      	cmp	r1, r0
   2f880:	d007      	beq.n	2f892 <rpc_transport_msg_free+0x4e>
   2f882:	3301      	adds	r3, #1
   2f884:	00da      	lsls	r2, r3, #3
   2f886:	429d      	cmp	r5, r3
   2f888:	eb04 0102 	add.w	r1, r4, r2
   2f88c:	d1f6      	bne.n	2f87c <rpc_transport_msg_free+0x38>
   2f88e:	bc30      	pop	{r4, r5}
   2f890:	4770      	bx	lr
   2f892:	3204      	adds	r2, #4
   2f894:	58a3      	ldr	r3, [r4, r2]
   2f896:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   2f89a:	f043 0303 	orr.w	r3, r3, #3
   2f89e:	50a3      	str	r3, [r4, r2]
   2f8a0:	bc30      	pop	{r4, r5}
   2f8a2:	4770      	bx	lr
   2f8a4:	2204      	movs	r2, #4
   2f8a6:	e7f5      	b.n	2f894 <rpc_transport_msg_free+0x50>
   2f8a8:	20025198 	.word	0x20025198
   2f8ac:	20025194 	.word	0x20025194

0002f8b0 <rpc_transport_ipc_tx_init>:
   2f8b0:	2800      	cmp	r0, #0
   2f8b2:	f000 80b8 	beq.w	2fa26 <rpc_transport_ipc_tx_init+0x176>
   2f8b6:	2900      	cmp	r1, #0
   2f8b8:	f000 80b5 	beq.w	2fa26 <rpc_transport_ipc_tx_init+0x176>
   2f8bc:	2a00      	cmp	r2, #0
   2f8be:	f000 80b2 	beq.w	2fa26 <rpc_transport_ipc_tx_init+0x176>
   2f8c2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2f8c6:	6a04      	ldr	r4, [r0, #32]
   2f8c8:	b085      	sub	sp, #20
   2f8ca:	2c00      	cmp	r4, #0
   2f8cc:	f000 80a6 	beq.w	2fa1c <rpc_transport_ipc_tx_init+0x16c>
   2f8d0:	6a40      	ldr	r0, [r0, #36]	; 0x24
   2f8d2:	2800      	cmp	r0, #0
   2f8d4:	f000 80a2 	beq.w	2fa1c <rpc_transport_ipc_tx_init+0x16c>
   2f8d8:	f642 4587 	movw	r5, #11399	; 0x2c87
   2f8dc:	f04f 0a00 	mov.w	sl, #0
   2f8e0:	4e55      	ldr	r6, [pc, #340]	; (2fa38 <rpc_transport_ipc_tx_init+0x188>)
   2f8e2:	42a8      	cmp	r0, r5
   2f8e4:	f886 a000 	strb.w	sl, [r6]
   2f8e8:	f240 80a0 	bls.w	2fa2c <rpc_transport_ipc_tx_init+0x17c>
   2f8ec:	2708      	movs	r7, #8
   2f8ee:	f8df 9180 	ldr.w	r9, [pc, #384]	; 2fa70 <rpc_transport_ipc_tx_init+0x1c0>
   2f8f2:	4620      	mov	r0, r4
   2f8f4:	4616      	mov	r6, r2
   2f8f6:	460d      	mov	r5, r1
   2f8f8:	2244      	movs	r2, #68	; 0x44
   2f8fa:	4651      	mov	r1, sl
   2f8fc:	f8c9 4000 	str.w	r4, [r9]
   2f900:	f00e ffc4 	bl	3e88c <memset>
   2f904:	f8d9 2000 	ldr.w	r2, [r9]
   2f908:	f104 0344 	add.w	r3, r4, #68	; 0x44
   2f90c:	f8df 8164 	ldr.w	r8, [pc, #356]	; 2fa74 <rpc_transport_ipc_tx_init+0x1c4>
   2f910:	f882 a001 	strb.w	sl, [r2, #1]
   2f914:	f882 a002 	strb.w	sl, [r2, #2]
   2f918:	f882 a003 	strb.w	sl, [r2, #3]
   2f91c:	7017      	strb	r7, [r2, #0]
   2f91e:	4618      	mov	r0, r3
   2f920:	2244      	movs	r2, #68	; 0x44
   2f922:	4651      	mov	r1, sl
   2f924:	f8c8 3000 	str.w	r3, [r8]
   2f928:	f00e ffb0 	bl	3e88c <memset>
   2f92c:	f8d8 2000 	ldr.w	r2, [r8]
   2f930:	f104 0388 	add.w	r3, r4, #136	; 0x88
   2f934:	f8df b140 	ldr.w	fp, [pc, #320]	; 2fa78 <rpc_transport_ipc_tx_init+0x1c8>
   2f938:	7017      	strb	r7, [r2, #0]
   2f93a:	f882 a001 	strb.w	sl, [r2, #1]
   2f93e:	f882 a002 	strb.w	sl, [r2, #2]
   2f942:	f882 a003 	strb.w	sl, [r2, #3]
   2f946:	4618      	mov	r0, r3
   2f948:	f44f 7200 	mov.w	r2, #512	; 0x200
   2f94c:	4651      	mov	r1, sl
   2f94e:	f8cb 3000 	str.w	r3, [fp]
   2f952:	f00e ff9b 	bl	3e88c <memset>
   2f956:	4b39      	ldr	r3, [pc, #228]	; (2fa3c <rpc_transport_ipc_tx_init+0x18c>)
   2f958:	f504 7c22 	add.w	ip, r4, #648	; 0x288
   2f95c:	f8c3 c000 	str.w	ip, [r3]
   2f960:	4651      	mov	r1, sl
   2f962:	4660      	mov	r0, ip
   2f964:	f44f 7200 	mov.w	r2, #512	; 0x200
   2f968:	f00e ff90 	bl	3e88c <memset>
   2f96c:	f44f 5c20 	mov.w	ip, #10240	; 0x2800
   2f970:	2106      	movs	r1, #6
   2f972:	f04f 0e01 	mov.w	lr, #1
   2f976:	f44f 3001 	mov.w	r0, #132096	; 0x20400
   2f97a:	f44f 3288 	mov.w	r2, #69632	; 0x11000
   2f97e:	4b30      	ldr	r3, [pc, #192]	; (2fa40 <rpc_transport_ipc_tx_init+0x190>)
   2f980:	f504 6491 	add.w	r4, r4, #1160	; 0x488
   2f984:	605c      	str	r4, [r3, #4]
   2f986:	4c2f      	ldr	r4, [pc, #188]	; (2fa44 <rpc_transport_ipc_tx_init+0x194>)
   2f988:	f8c3 c008 	str.w	ip, [r3, #8]
   2f98c:	8199      	strh	r1, [r3, #12]
   2f98e:	f8a3 e000 	strh.w	lr, [r3]
   2f992:	4619      	mov	r1, r3
   2f994:	611c      	str	r4, [r3, #16]
   2f996:	4b2c      	ldr	r3, [pc, #176]	; (2fa48 <rpc_transport_ipc_tx_init+0x198>)
   2f998:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 2fa7c <rpc_transport_ipc_tx_init+0x1cc>
   2f99c:	6120      	str	r0, [r4, #16]
   2f99e:	482b      	ldr	r0, [pc, #172]	; (2fa4c <rpc_transport_ipc_tx_init+0x19c>)
   2f9a0:	6063      	str	r3, [r4, #4]
   2f9a2:	f503 73c0 	add.w	r3, r3, #384	; 0x180
   2f9a6:	60a0      	str	r0, [r4, #8]
   2f9a8:	f8c4 c000 	str.w	ip, [r4]
   2f9ac:	4828      	ldr	r0, [pc, #160]	; (2fa50 <rpc_transport_ipc_tx_init+0x1a0>)
   2f9ae:	60e3      	str	r3, [r4, #12]
   2f9b0:	6162      	str	r2, [r4, #20]
   2f9b2:	f7fd fe59 	bl	2d668 <nrf_mem_register>
   2f9b6:	2800      	cmp	r0, #0
   2f9b8:	d132      	bne.n	2fa20 <rpc_transport_ipc_tx_init+0x170>
   2f9ba:	f04f 0c02 	mov.w	ip, #2
   2f9be:	2420      	movs	r4, #32
   2f9c0:	f8d9 1000 	ldr.w	r1, [r9]
   2f9c4:	f8db 2000 	ldr.w	r2, [fp]
   2f9c8:	6029      	str	r1, [r5, #0]
   2f9ca:	4b1c      	ldr	r3, [pc, #112]	; (2fa3c <rpc_transport_ipc_tx_init+0x18c>)
   2f9cc:	f8d8 1000 	ldr.w	r1, [r8]
   2f9d0:	f8df e0ac 	ldr.w	lr, [pc, #172]	; 2fa80 <rpc_transport_ipc_tx_init+0x1d0>
   2f9d4:	4d1f      	ldr	r5, [pc, #124]	; (2fa54 <rpc_transport_ipc_tx_init+0x1a4>)
   2f9d6:	6031      	str	r1, [r6, #0]
   2f9d8:	f8ce 2000 	str.w	r2, [lr]
   2f9dc:	681b      	ldr	r3, [r3, #0]
   2f9de:	491e      	ldr	r1, [pc, #120]	; (2fa58 <rpc_transport_ipc_tx_init+0x1a8>)
   2f9e0:	f502 7200 	add.w	r2, r2, #512	; 0x200
   2f9e4:	602a      	str	r2, [r5, #0]
   2f9e6:	4e1d      	ldr	r6, [pc, #116]	; (2fa5c <rpc_transport_ipc_tx_init+0x1ac>)
   2f9e8:	4a1d      	ldr	r2, [pc, #116]	; (2fa60 <rpc_transport_ipc_tx_init+0x1b0>)
   2f9ea:	4d1e      	ldr	r5, [pc, #120]	; (2fa64 <rpc_transport_ipc_tx_init+0x1b4>)
   2f9ec:	600b      	str	r3, [r1, #0]
   2f9ee:	f503 7300 	add.w	r3, r3, #512	; 0x200
   2f9f2:	491d      	ldr	r1, [pc, #116]	; (2fa68 <rpc_transport_ipc_tx_init+0x1b8>)
   2f9f4:	6033      	str	r3, [r6, #0]
   2f9f6:	8028      	strh	r0, [r5, #0]
   2f9f8:	f8c2 c514 	str.w	ip, [r2, #1300]	; 0x514
   2f9fc:	6809      	ldr	r1, [r1, #0]
   2f9fe:	4b1b      	ldr	r3, [pc, #108]	; (2fa6c <rpc_transport_ipc_tx_init+0x1bc>)
   2fa00:	9103      	str	r1, [sp, #12]
   2fa02:	9903      	ldr	r1, [sp, #12]
   2fa04:	f8c2 751c 	str.w	r7, [r2, #1308]	; 0x51c
   2fa08:	6819      	ldr	r1, [r3, #0]
   2fa0a:	443b      	add	r3, r7
   2fa0c:	9102      	str	r1, [sp, #8]
   2fa0e:	9902      	ldr	r1, [sp, #8]
   2fa10:	f8c2 4524 	str.w	r4, [r2, #1316]	; 0x524
   2fa14:	681b      	ldr	r3, [r3, #0]
   2fa16:	9301      	str	r3, [sp, #4]
   2fa18:	9b01      	ldr	r3, [sp, #4]
   2fa1a:	e001      	b.n	2fa20 <rpc_transport_ipc_tx_init+0x170>
   2fa1c:	f24c 0007 	movw	r0, #49159	; 0xc007
   2fa20:	b005      	add	sp, #20
   2fa22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2fa26:	f24c 000e 	movw	r0, #49166	; 0xc00e
   2fa2a:	4770      	bx	lr
   2fa2c:	f24c 0004 	movw	r0, #49156	; 0xc004
   2fa30:	b005      	add	sp, #20
   2fa32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2fa36:	bf00      	nop
   2fa38:	2002d7f0 	.word	0x2002d7f0
   2fa3c:	200251c8 	.word	0x200251c8
   2fa40:	200251b4 	.word	0x200251b4
   2fa44:	200251d8 	.word	0x200251d8
   2fa48:	00040080 	.word	0x00040080
   2fa4c:	00040100 	.word	0x00040100
   2fa50:	200251a0 	.word	0x200251a0
   2fa54:	200251ac 	.word	0x200251ac
   2fa58:	200251a8 	.word	0x200251a8
   2fa5c:	200251a4 	.word	0x200251a4
   2fa60:	4002a000 	.word	0x4002a000
   2fa64:	20029910 	.word	0x20029910
   2fa68:	4002a514 	.word	0x4002a514
   2fa6c:	4002a51c 	.word	0x4002a51c
   2fa70:	200251d4 	.word	0x200251d4
   2fa74:	200251cc 	.word	0x200251cc
   2fa78:	200251d0 	.word	0x200251d0
   2fa7c:	00080040 	.word	0x00080040
   2fa80:	200251b0 	.word	0x200251b0

0002fa84 <rpc_transport_ipc_tx_send>:
   2fa84:	2800      	cmp	r0, #0
   2fa86:	d05f      	beq.n	2fb48 <rpc_transport_ipc_tx_send+0xc4>
   2fa88:	b470      	push	{r4, r5, r6}
   2fa8a:	4b33      	ldr	r3, [pc, #204]	; (2fb58 <rpc_transport_ipc_tx_send+0xd4>)
   2fa8c:	b083      	sub	sp, #12
   2fa8e:	681a      	ldr	r2, [r3, #0]
   2fa90:	4b32      	ldr	r3, [pc, #200]	; (2fb5c <rpc_transport_ipc_tx_send+0xd8>)
   2fa92:	4282      	cmp	r2, r0
   2fa94:	d81e      	bhi.n	2fad4 <rpc_transport_ipc_tx_send+0x50>
   2fa96:	681b      	ldr	r3, [r3, #0]
   2fa98:	4931      	ldr	r1, [pc, #196]	; (2fb60 <rpc_transport_ipc_tx_send+0xdc>)
   2fa9a:	4283      	cmp	r3, r0
   2fa9c:	6809      	ldr	r1, [r1, #0]
   2fa9e:	d803      	bhi.n	2faa8 <rpc_transport_ipc_tx_send+0x24>
   2faa0:	4c30      	ldr	r4, [pc, #192]	; (2fb64 <rpc_transport_ipc_tx_send+0xe0>)
   2faa2:	6824      	ldr	r4, [r4, #0]
   2faa4:	4284      	cmp	r4, r0
   2faa6:	d847      	bhi.n	2fb38 <rpc_transport_ipc_tx_send+0xb4>
   2faa8:	4281      	cmp	r1, r0
   2faaa:	d90e      	bls.n	2faca <rpc_transport_ipc_tx_send+0x46>
   2faac:	4b2e      	ldr	r3, [pc, #184]	; (2fb68 <rpc_transport_ipc_tx_send+0xe4>)
   2faae:	781b      	ldrb	r3, [r3, #0]
   2fab0:	2b00      	cmp	r3, #0
   2fab2:	d14c      	bne.n	2fb4e <rpc_transport_ipc_tx_send+0xca>
   2fab4:	1a83      	subs	r3, r0, r2
   2fab6:	492d      	ldr	r1, [pc, #180]	; (2fb6c <rpc_transport_ipc_tx_send+0xe8>)
   2fab8:	099e      	lsrs	r6, r3, #6
   2faba:	069b      	lsls	r3, r3, #26
   2fabc:	680a      	ldr	r2, [r1, #0]
   2fabe:	4c2c      	ldr	r4, [pc, #176]	; (2fb70 <rpc_transport_ipc_tx_send+0xec>)
   2fac0:	f04f 0103 	mov.w	r1, #3
   2fac4:	f04f 0502 	mov.w	r5, #2
   2fac8:	d014      	beq.n	2faf4 <rpc_transport_ipc_tx_send+0x70>
   2faca:	f24c 0010 	movw	r0, #49168	; 0xc010
   2face:	b003      	add	sp, #12
   2fad0:	bc70      	pop	{r4, r5, r6}
   2fad2:	4770      	bx	lr
   2fad4:	681b      	ldr	r3, [r3, #0]
   2fad6:	4298      	cmp	r0, r3
   2fad8:	d3f7      	bcc.n	2faca <rpc_transport_ipc_tx_send+0x46>
   2fada:	4a22      	ldr	r2, [pc, #136]	; (2fb64 <rpc_transport_ipc_tx_send+0xe0>)
   2fadc:	6812      	ldr	r2, [r2, #0]
   2fade:	4290      	cmp	r0, r2
   2fae0:	d2f3      	bcs.n	2faca <rpc_transport_ipc_tx_send+0x46>
   2fae2:	2101      	movs	r1, #1
   2fae4:	1ac3      	subs	r3, r0, r3
   2fae6:	4a23      	ldr	r2, [pc, #140]	; (2fb74 <rpc_transport_ipc_tx_send+0xf0>)
   2fae8:	099e      	lsrs	r6, r3, #6
   2faea:	069b      	lsls	r3, r3, #26
   2faec:	460d      	mov	r5, r1
   2faee:	6812      	ldr	r2, [r2, #0]
   2faf0:	4c21      	ldr	r4, [pc, #132]	; (2fb78 <rpc_transport_ipc_tx_send+0xf4>)
   2faf2:	d1ea      	bne.n	2faca <rpc_transport_ipc_tx_send+0x46>
   2faf4:	6843      	ldr	r3, [r0, #4]
   2faf6:	b2db      	uxtb	r3, r3
   2faf8:	429d      	cmp	r5, r3
   2fafa:	d120      	bne.n	2fb3e <rpc_transport_ipc_tx_send+0xba>
   2fafc:	2020      	movs	r0, #32
   2fafe:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
   2fb02:	4d1e      	ldr	r5, [pc, #120]	; (2fb7c <rpc_transport_ipc_tx_send+0xf8>)
   2fb04:	6853      	ldr	r3, [r2, #4]
   2fb06:	882e      	ldrh	r6, [r5, #0]
   2fb08:	b29b      	uxth	r3, r3
   2fb0a:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   2fb0e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   2fb12:	f043 0301 	orr.w	r3, r3, #1
   2fb16:	6053      	str	r3, [r2, #4]
   2fb18:	bf00      	nop
   2fb1a:	3801      	subs	r0, #1
   2fb1c:	d1fc      	bne.n	2fb18 <rpc_transport_ipc_tx_send+0x94>
   2fb1e:	2201      	movs	r2, #1
   2fb20:	4b17      	ldr	r3, [pc, #92]	; (2fb80 <rpc_transport_ipc_tx_send+0xfc>)
   2fb22:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
   2fb26:	6822      	ldr	r2, [r4, #0]
   2fb28:	882b      	ldrh	r3, [r5, #0]
   2fb2a:	9201      	str	r2, [sp, #4]
   2fb2c:	9a01      	ldr	r2, [sp, #4]
   2fb2e:	3301      	adds	r3, #1
   2fb30:	802b      	strh	r3, [r5, #0]
   2fb32:	b003      	add	sp, #12
   2fb34:	bc70      	pop	{r4, r5, r6}
   2fb36:	4770      	bx	lr
   2fb38:	4281      	cmp	r1, r0
   2fb3a:	d9d2      	bls.n	2fae2 <rpc_transport_ipc_tx_send+0x5e>
   2fb3c:	e7b6      	b.n	2faac <rpc_transport_ipc_tx_send+0x28>
   2fb3e:	f24c 0007 	movw	r0, #49159	; 0xc007
   2fb42:	b003      	add	sp, #12
   2fb44:	bc70      	pop	{r4, r5, r6}
   2fb46:	4770      	bx	lr
   2fb48:	f24c 000e 	movw	r0, #49166	; 0xc00e
   2fb4c:	4770      	bx	lr
   2fb4e:	f24c 000f 	movw	r0, #49167	; 0xc00f
   2fb52:	b003      	add	sp, #12
   2fb54:	bc70      	pop	{r4, r5, r6}
   2fb56:	4770      	bx	lr
   2fb58:	200251b0 	.word	0x200251b0
   2fb5c:	200251a8 	.word	0x200251a8
   2fb60:	200251ac 	.word	0x200251ac
   2fb64:	200251a4 	.word	0x200251a4
   2fb68:	2002d7f0 	.word	0x2002d7f0
   2fb6c:	200251d4 	.word	0x200251d4
   2fb70:	4002a00c 	.word	0x4002a00c
   2fb74:	200251cc 	.word	0x200251cc
   2fb78:	4002a004 	.word	0x4002a004
   2fb7c:	20029910 	.word	0x20029910
   2fb80:	4002a000 	.word	0x4002a000

0002fb84 <rpc_transport_ipc_tx_rpc_data_alloc>:
   2fb84:	4b18      	ldr	r3, [pc, #96]	; (2fbe8 <rpc_transport_ipc_tx_rpc_data_alloc+0x64>)
   2fb86:	781b      	ldrb	r3, [r3, #0]
   2fb88:	bb63      	cbnz	r3, 2fbe4 <rpc_transport_ipc_tx_rpc_data_alloc+0x60>
   2fb8a:	b4f0      	push	{r4, r5, r6, r7}
   2fb8c:	4a17      	ldr	r2, [pc, #92]	; (2fbec <rpc_transport_ipc_tx_rpc_data_alloc+0x68>)
   2fb8e:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   2fb92:	6814      	ldr	r4, [r2, #0]
   2fb94:	4b16      	ldr	r3, [pc, #88]	; (2fbf0 <rpc_transport_ipc_tx_rpc_data_alloc+0x6c>)
   2fb96:	6825      	ldr	r5, [r4, #0]
   2fb98:	681e      	ldr	r6, [r3, #0]
   2fb9a:	b1a5      	cbz	r5, 2fbc6 <rpc_transport_ipc_tx_rpc_data_alloc+0x42>
   2fb9c:	4607      	mov	r7, r0
   2fb9e:	00c1      	lsls	r1, r0, #3
   2fba0:	1863      	adds	r3, r4, r1
   2fba2:	685a      	ldr	r2, [r3, #4]
   2fba4:	b2d2      	uxtb	r2, r2
   2fba6:	2a03      	cmp	r2, #3
   2fba8:	d104      	bne.n	2fbb4 <rpc_transport_ipc_tx_rpc_data_alloc+0x30>
   2fbaa:	609f      	str	r7, [r3, #8]
   2fbac:	685a      	ldr	r2, [r3, #4]
   2fbae:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   2fbb2:	605a      	str	r2, [r3, #4]
   2fbb4:	685a      	ldr	r2, [r3, #4]
   2fbb6:	f012 0fff 	tst.w	r2, #255	; 0xff
   2fbba:	d101      	bne.n	2fbc0 <rpc_transport_ipc_tx_rpc_data_alloc+0x3c>
   2fbbc:	689b      	ldr	r3, [r3, #8]
   2fbbe:	b12b      	cbz	r3, 2fbcc <rpc_transport_ipc_tx_rpc_data_alloc+0x48>
   2fbc0:	3001      	adds	r0, #1
   2fbc2:	42a8      	cmp	r0, r5
   2fbc4:	d1eb      	bne.n	2fb9e <rpc_transport_ipc_tx_rpc_data_alloc+0x1a>
   2fbc6:	2000      	movs	r0, #0
   2fbc8:	bcf0      	pop	{r4, r5, r6, r7}
   2fbca:	4770      	bx	lr
   2fbcc:	eb06 1080 	add.w	r0, r6, r0, lsl #6
   2fbd0:	4421      	add	r1, r4
   2fbd2:	6088      	str	r0, [r1, #8]
   2fbd4:	6843      	ldr	r3, [r0, #4]
   2fbd6:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   2fbda:	f043 0302 	orr.w	r3, r3, #2
   2fbde:	6043      	str	r3, [r0, #4]
   2fbe0:	bcf0      	pop	{r4, r5, r6, r7}
   2fbe2:	4770      	bx	lr
   2fbe4:	2000      	movs	r0, #0
   2fbe6:	4770      	bx	lr
   2fbe8:	2002d7f0 	.word	0x2002d7f0
   2fbec:	200251d4 	.word	0x200251d4
   2fbf0:	200251d0 	.word	0x200251d0

0002fbf4 <rpc_transport_ipc_tx_rpc_ctrl_alloc>:
   2fbf4:	b4f0      	push	{r4, r5, r6, r7}
   2fbf6:	4a15      	ldr	r2, [pc, #84]	; (2fc4c <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x58>)
   2fbf8:	4b15      	ldr	r3, [pc, #84]	; (2fc50 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x5c>)
   2fbfa:	6814      	ldr	r4, [r2, #0]
   2fbfc:	681e      	ldr	r6, [r3, #0]
   2fbfe:	6825      	ldr	r5, [r4, #0]
   2fc00:	b1ad      	cbz	r5, 2fc2e <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x3a>
   2fc02:	2000      	movs	r0, #0
   2fc04:	4607      	mov	r7, r0
   2fc06:	00c1      	lsls	r1, r0, #3
   2fc08:	1863      	adds	r3, r4, r1
   2fc0a:	685a      	ldr	r2, [r3, #4]
   2fc0c:	b2d2      	uxtb	r2, r2
   2fc0e:	2a03      	cmp	r2, #3
   2fc10:	d104      	bne.n	2fc1c <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x28>
   2fc12:	609f      	str	r7, [r3, #8]
   2fc14:	685a      	ldr	r2, [r3, #4]
   2fc16:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   2fc1a:	605a      	str	r2, [r3, #4]
   2fc1c:	685a      	ldr	r2, [r3, #4]
   2fc1e:	f012 0fff 	tst.w	r2, #255	; 0xff
   2fc22:	d101      	bne.n	2fc28 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x34>
   2fc24:	689b      	ldr	r3, [r3, #8]
   2fc26:	b12b      	cbz	r3, 2fc34 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x40>
   2fc28:	3001      	adds	r0, #1
   2fc2a:	4285      	cmp	r5, r0
   2fc2c:	d1eb      	bne.n	2fc06 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x12>
   2fc2e:	2000      	movs	r0, #0
   2fc30:	bcf0      	pop	{r4, r5, r6, r7}
   2fc32:	4770      	bx	lr
   2fc34:	eb06 1080 	add.w	r0, r6, r0, lsl #6
   2fc38:	4421      	add	r1, r4
   2fc3a:	6088      	str	r0, [r1, #8]
   2fc3c:	6843      	ldr	r3, [r0, #4]
   2fc3e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   2fc42:	f043 0301 	orr.w	r3, r3, #1
   2fc46:	6043      	str	r3, [r0, #4]
   2fc48:	bcf0      	pop	{r4, r5, r6, r7}
   2fc4a:	4770      	bx	lr
   2fc4c:	200251cc 	.word	0x200251cc
   2fc50:	200251c8 	.word	0x200251c8

0002fc54 <rpc_transport_ipc_tx_data_alloc>:
   2fc54:	4b03      	ldr	r3, [pc, #12]	; (2fc64 <rpc_transport_ipc_tx_data_alloc+0x10>)
   2fc56:	781b      	ldrb	r3, [r3, #0]
   2fc58:	b90b      	cbnz	r3, 2fc5e <rpc_transport_ipc_tx_data_alloc+0xa>
   2fc5a:	f7fd be35 	b.w	2d8c8 <nrf_shared_malloc>
   2fc5e:	2000      	movs	r0, #0
   2fc60:	4770      	bx	lr
   2fc62:	bf00      	nop
   2fc64:	2002d7f0 	.word	0x2002d7f0

0002fc68 <ok_rsp_parser>:
   2fc68:	2000      	movs	r0, #0
   2fc6a:	4770      	bx	lr

0002fc6c <pdn_state_get_parser>:
   2fc6c:	2200      	movs	r2, #0
   2fc6e:	b570      	push	{r4, r5, r6, lr}
   2fc70:	780b      	ldrb	r3, [r1, #0]
   2fc72:	b084      	sub	sp, #16
   2fc74:	460e      	mov	r6, r1
   2fc76:	e9cd 2200 	strd	r2, r2, [sp]
   2fc7a:	e9cd 2202 	strd	r2, r2, [sp, #8]
   2fc7e:	b323      	cbz	r3, 2fcca <pdn_state_get_parser+0x5e>
   2fc80:	460c      	mov	r4, r1
   2fc82:	2b20      	cmp	r3, #32
   2fc84:	460d      	mov	r5, r1
   2fc86:	d01b      	beq.n	2fcc0 <pdn_state_get_parser+0x54>
   2fc88:	700b      	strb	r3, [r1, #0]
   2fc8a:	3201      	adds	r2, #1
   2fc8c:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   2fc90:	18b1      	adds	r1, r6, r2
   2fc92:	460d      	mov	r5, r1
   2fc94:	2b00      	cmp	r3, #0
   2fc96:	d1f4      	bne.n	2fc82 <pdn_state_get_parser+0x16>
   2fc98:	2200      	movs	r2, #0
   2fc9a:	4b0d      	ldr	r3, [pc, #52]	; (2fcd0 <pdn_state_get_parser+0x64>)
   2fc9c:	702a      	strb	r2, [r5, #0]
   2fc9e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   2fca2:	4a0c      	ldr	r2, [pc, #48]	; (2fcd4 <pdn_state_get_parser+0x68>)
   2fca4:	681b      	ldr	r3, [r3, #0]
   2fca6:	2110      	movs	r1, #16
   2fca8:	4668      	mov	r0, sp
   2fcaa:	f009 ff07 	bl	39abc <sniprintf>
   2fcae:	4669      	mov	r1, sp
   2fcb0:	4630      	mov	r0, r6
   2fcb2:	f00e ff81 	bl	3ebb8 <strstr>
   2fcb6:	3000      	adds	r0, #0
   2fcb8:	bf18      	it	ne
   2fcba:	2001      	movne	r0, #1
   2fcbc:	b004      	add	sp, #16
   2fcbe:	bd70      	pop	{r4, r5, r6, pc}
   2fcc0:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   2fcc4:	2b00      	cmp	r3, #0
   2fcc6:	d1dc      	bne.n	2fc82 <pdn_state_get_parser+0x16>
   2fcc8:	e7e6      	b.n	2fc98 <pdn_state_get_parser+0x2c>
   2fcca:	460d      	mov	r5, r1
   2fccc:	e7e4      	b.n	2fc98 <pdn_state_get_parser+0x2c>
   2fcce:	bf00      	nop
   2fcd0:	200252f4 	.word	0x200252f4
   2fcd4:	00040298 	.word	0x00040298

0002fcd8 <pdn_id_get_parser>:
   2fcd8:	b570      	push	{r4, r5, r6, lr}
   2fcda:	780b      	ldrb	r3, [r1, #0]
   2fcdc:	4606      	mov	r6, r0
   2fcde:	b313      	cbz	r3, 2fd26 <pdn_id_get_parser+0x4e>
   2fce0:	4608      	mov	r0, r1
   2fce2:	2400      	movs	r4, #0
   2fce4:	460a      	mov	r2, r1
   2fce6:	2b20      	cmp	r3, #32
   2fce8:	4615      	mov	r5, r2
   2fcea:	d017      	beq.n	2fd1c <pdn_id_get_parser+0x44>
   2fcec:	7013      	strb	r3, [r2, #0]
   2fcee:	3401      	adds	r4, #1
   2fcf0:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   2fcf4:	190a      	adds	r2, r1, r4
   2fcf6:	4615      	mov	r5, r2
   2fcf8:	2b00      	cmp	r3, #0
   2fcfa:	d1f4      	bne.n	2fce6 <pdn_id_get_parser+0xe>
   2fcfc:	2300      	movs	r3, #0
   2fcfe:	4608      	mov	r0, r1
   2fd00:	702b      	strb	r3, [r5, #0]
   2fd02:	213a      	movs	r1, #58	; 0x3a
   2fd04:	f00e ff1e 	bl	3eb44 <strchr>
   2fd08:	b130      	cbz	r0, 2fd18 <pdn_id_get_parser+0x40>
   2fd0a:	3001      	adds	r0, #1
   2fd0c:	f00e fd7e 	bl	3e80c <atoi>
   2fd10:	4b06      	ldr	r3, [pc, #24]	; (2fd2c <pdn_id_get_parser+0x54>)
   2fd12:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
   2fd16:	6058      	str	r0, [r3, #4]
   2fd18:	2000      	movs	r0, #0
   2fd1a:	bd70      	pop	{r4, r5, r6, pc}
   2fd1c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   2fd20:	2b00      	cmp	r3, #0
   2fd22:	d1e0      	bne.n	2fce6 <pdn_id_get_parser+0xe>
   2fd24:	e7ea      	b.n	2fcfc <pdn_id_get_parser+0x24>
   2fd26:	460d      	mov	r5, r1
   2fd28:	e7e8      	b.n	2fcfc <pdn_id_get_parser+0x24>
   2fd2a:	bf00      	nop
   2fd2c:	200252f4 	.word	0x200252f4

0002fd30 <context_create_parser>:
   2fd30:	b570      	push	{r4, r5, r6, lr}
   2fd32:	780b      	ldrb	r3, [r1, #0]
   2fd34:	4606      	mov	r6, r0
   2fd36:	b313      	cbz	r3, 2fd7e <context_create_parser+0x4e>
   2fd38:	4608      	mov	r0, r1
   2fd3a:	2400      	movs	r4, #0
   2fd3c:	460a      	mov	r2, r1
   2fd3e:	2b20      	cmp	r3, #32
   2fd40:	4615      	mov	r5, r2
   2fd42:	d017      	beq.n	2fd74 <context_create_parser+0x44>
   2fd44:	7013      	strb	r3, [r2, #0]
   2fd46:	3401      	adds	r4, #1
   2fd48:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   2fd4c:	190a      	adds	r2, r1, r4
   2fd4e:	4615      	mov	r5, r2
   2fd50:	2b00      	cmp	r3, #0
   2fd52:	d1f4      	bne.n	2fd3e <context_create_parser+0xe>
   2fd54:	2300      	movs	r3, #0
   2fd56:	4608      	mov	r0, r1
   2fd58:	702b      	strb	r3, [r5, #0]
   2fd5a:	213a      	movs	r1, #58	; 0x3a
   2fd5c:	f00e fef2 	bl	3eb44 <strchr>
   2fd60:	b130      	cbz	r0, 2fd70 <context_create_parser+0x40>
   2fd62:	4b08      	ldr	r3, [pc, #32]	; (2fd84 <context_create_parser+0x54>)
   2fd64:	3001      	adds	r0, #1
   2fd66:	f853 4026 	ldr.w	r4, [r3, r6, lsl #2]
   2fd6a:	f00e fd4f 	bl	3e80c <atoi>
   2fd6e:	6020      	str	r0, [r4, #0]
   2fd70:	2000      	movs	r0, #0
   2fd72:	bd70      	pop	{r4, r5, r6, pc}
   2fd74:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   2fd78:	2b00      	cmp	r3, #0
   2fd7a:	d1e0      	bne.n	2fd3e <context_create_parser+0xe>
   2fd7c:	e7ea      	b.n	2fd54 <context_create_parser+0x24>
   2fd7e:	460d      	mov	r5, r1
   2fd80:	e7e8      	b.n	2fd54 <context_create_parser+0x24>
   2fd82:	bf00      	nop
   2fd84:	200252f4 	.word	0x200252f4

0002fd88 <pdn_interface_init>:
   2fd88:	f04f 33ff 	mov.w	r3, #4294967295
   2fd8c:	b510      	push	{r4, lr}
   2fd8e:	4c09      	ldr	r4, [pc, #36]	; (2fdb4 <pdn_interface_init+0x2c>)
   2fd90:	2228      	movs	r2, #40	; 0x28
   2fd92:	2100      	movs	r1, #0
   2fd94:	4808      	ldr	r0, [pc, #32]	; (2fdb8 <pdn_interface_init+0x30>)
   2fd96:	6023      	str	r3, [r4, #0]
   2fd98:	f00e fd78 	bl	3e88c <memset>
   2fd9c:	f240 2201 	movw	r2, #513	; 0x201
   2fda0:	2102      	movs	r1, #2
   2fda2:	2066      	movs	r0, #102	; 0x66
   2fda4:	f7fd f838 	bl	2ce18 <at_interface_open>
   2fda8:	2800      	cmp	r0, #0
   2fdaa:	6020      	str	r0, [r4, #0]
   2fdac:	bfb4      	ite	lt
   2fdae:	2003      	movlt	r0, #3
   2fdb0:	2000      	movge	r0, #0
   2fdb2:	bd10      	pop	{r4, pc}
   2fdb4:	200251f0 	.word	0x200251f0
   2fdb8:	200252f4 	.word	0x200252f4

0002fdbc <pdn_interface_open>:
   2fdbc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2fdc0:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   2fdc4:	b083      	sub	sp, #12
   2fdc6:	f040 80ad 	bne.w	2ff24 <pdn_interface_open+0x168>
   2fdca:	4c5f      	ldr	r4, [pc, #380]	; (2ff48 <pdn_interface_open+0x18c>)
   2fdcc:	6825      	ldr	r5, [r4, #0]
   2fdce:	b34d      	cbz	r5, 2fe24 <pdn_interface_open+0x68>
   2fdd0:	6863      	ldr	r3, [r4, #4]
   2fdd2:	2b00      	cmp	r3, #0
   2fdd4:	f000 8098 	beq.w	2ff08 <pdn_interface_open+0x14c>
   2fdd8:	68a3      	ldr	r3, [r4, #8]
   2fdda:	2b00      	cmp	r3, #0
   2fddc:	f000 8096 	beq.w	2ff0c <pdn_interface_open+0x150>
   2fde0:	68e3      	ldr	r3, [r4, #12]
   2fde2:	2b00      	cmp	r3, #0
   2fde4:	f000 8094 	beq.w	2ff10 <pdn_interface_open+0x154>
   2fde8:	6923      	ldr	r3, [r4, #16]
   2fdea:	2b00      	cmp	r3, #0
   2fdec:	f000 8092 	beq.w	2ff14 <pdn_interface_open+0x158>
   2fdf0:	6963      	ldr	r3, [r4, #20]
   2fdf2:	2b00      	cmp	r3, #0
   2fdf4:	f000 8090 	beq.w	2ff18 <pdn_interface_open+0x15c>
   2fdf8:	69a3      	ldr	r3, [r4, #24]
   2fdfa:	2b00      	cmp	r3, #0
   2fdfc:	f000 808e 	beq.w	2ff1c <pdn_interface_open+0x160>
   2fe00:	69e3      	ldr	r3, [r4, #28]
   2fe02:	2b00      	cmp	r3, #0
   2fe04:	f000 808c 	beq.w	2ff20 <pdn_interface_open+0x164>
   2fe08:	6a23      	ldr	r3, [r4, #32]
   2fe0a:	b153      	cbz	r3, 2fe22 <pdn_interface_open+0x66>
   2fe0c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2fe0e:	2509      	movs	r5, #9
   2fe10:	b143      	cbz	r3, 2fe24 <pdn_interface_open+0x68>
   2fe12:	200c      	movs	r0, #12
   2fe14:	f7fa fed6 	bl	2abc4 <bsd_os_errno_set>
   2fe18:	f04f 30ff 	mov.w	r0, #4294967295
   2fe1c:	b003      	add	sp, #12
   2fe1e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2fe22:	2508      	movs	r5, #8
   2fe24:	2074      	movs	r0, #116	; 0x74
   2fe26:	f7fd fd39 	bl	2d89c <nrf_malloc>
   2fe2a:	f844 0025 	str.w	r0, [r4, r5, lsl #2]
   2fe2e:	2800      	cmp	r0, #0
   2fe30:	d0ef      	beq.n	2fe12 <pdn_interface_open+0x56>
   2fe32:	2274      	movs	r2, #116	; 0x74
   2fe34:	2100      	movs	r1, #0
   2fe36:	f00e fd29 	bl	3e88c <memset>
   2fe3a:	2101      	movs	r1, #1
   2fe3c:	2003      	movs	r0, #3
   2fe3e:	f04f 37ff 	mov.w	r7, #4294967295
   2fe42:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   2fe46:	4a41      	ldr	r2, [pc, #260]	; (2ff4c <pdn_interface_open+0x190>)
   2fe48:	6099      	str	r1, [r3, #8]
   2fe4a:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   2fe4e:	f44f 7180 	mov.w	r1, #256	; 0x100
   2fe52:	6718      	str	r0, [r3, #112]	; 0x70
   2fe54:	605f      	str	r7, [r3, #4]
   2fe56:	483e      	ldr	r0, [pc, #248]	; (2ff50 <pdn_interface_open+0x194>)
   2fe58:	f8df 8100 	ldr.w	r8, [pc, #256]	; 2ff5c <pdn_interface_open+0x1a0>
   2fe5c:	f009 fe2e 	bl	39abc <sniprintf>
   2fe60:	483b      	ldr	r0, [pc, #236]	; (2ff50 <pdn_interface_open+0x194>)
   2fe62:	f8d8 9000 	ldr.w	r9, [r8]
   2fe66:	2600      	movs	r6, #0
   2fe68:	f7ed f976 	bl	1d158 <strlen>
   2fe6c:	4633      	mov	r3, r6
   2fe6e:	4602      	mov	r2, r0
   2fe70:	4937      	ldr	r1, [pc, #220]	; (2ff50 <pdn_interface_open+0x194>)
   2fe72:	4648      	mov	r0, r9
   2fe74:	9601      	str	r6, [sp, #4]
   2fe76:	9600      	str	r6, [sp, #0]
   2fe78:	f7fc ff60 	bl	2cd3c <at_interface_write>
   2fe7c:	4681      	mov	r9, r0
   2fe7e:	4834      	ldr	r0, [pc, #208]	; (2ff50 <pdn_interface_open+0x194>)
   2fe80:	f7ed f96a 	bl	1d158 <strlen>
   2fe84:	4548      	cmp	r0, r9
   2fe86:	d153      	bne.n	2ff30 <pdn_interface_open+0x174>
   2fe88:	4633      	mov	r3, r6
   2fe8a:	e9cd 6600 	strd	r6, r6, [sp]
   2fe8e:	f44f 7280 	mov.w	r2, #256	; 0x100
   2fe92:	492f      	ldr	r1, [pc, #188]	; (2ff50 <pdn_interface_open+0x194>)
   2fe94:	f8d8 0000 	ldr.w	r0, [r8]
   2fe98:	f7fd f854 	bl	2cf44 <at_interface_read>
   2fe9c:	4606      	mov	r6, r0
   2fe9e:	482d      	ldr	r0, [pc, #180]	; (2ff54 <pdn_interface_open+0x198>)
   2fea0:	f7ed f95a 	bl	1d158 <strlen>
   2fea4:	4286      	cmp	r6, r0
   2fea6:	db15      	blt.n	2fed4 <pdn_interface_open+0x118>
   2fea8:	4602      	mov	r2, r0
   2feaa:	4929      	ldr	r1, [pc, #164]	; (2ff50 <pdn_interface_open+0x194>)
   2feac:	4829      	ldr	r0, [pc, #164]	; (2ff54 <pdn_interface_open+0x198>)
   2feae:	f00e fe5e 	bl	3eb6e <strncmp>
   2feb2:	b978      	cbnz	r0, 2fed4 <pdn_interface_open+0x118>
   2feb4:	4926      	ldr	r1, [pc, #152]	; (2ff50 <pdn_interface_open+0x194>)
   2feb6:	4628      	mov	r0, r5
   2feb8:	f7ff ff3a 	bl	2fd30 <context_create_parser>
   2febc:	b9b0      	cbnz	r0, 2feec <pdn_interface_open+0x130>
   2febe:	2202      	movs	r2, #2
   2fec0:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   2fec4:	f045 40f1 	orr.w	r0, r5, #2021654528	; 0x78800000
   2fec8:	f440 10d0 	orr.w	r0, r0, #1703936	; 0x1a0000
   2fecc:	609a      	str	r2, [r3, #8]
   2fece:	b003      	add	sp, #12
   2fed0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2fed4:	4820      	ldr	r0, [pc, #128]	; (2ff58 <pdn_interface_open+0x19c>)
   2fed6:	f7ed f93f 	bl	1d158 <strlen>
   2feda:	491d      	ldr	r1, [pc, #116]	; (2ff50 <pdn_interface_open+0x194>)
   2fedc:	4602      	mov	r2, r0
   2fede:	481e      	ldr	r0, [pc, #120]	; (2ff58 <pdn_interface_open+0x19c>)
   2fee0:	f00e fe45 	bl	3eb6e <strncmp>
   2fee4:	b960      	cbnz	r0, 2ff00 <pdn_interface_open+0x144>
   2fee6:	2008      	movs	r0, #8
   2fee8:	f7fa fe6c 	bl	2abc4 <bsd_os_errno_set>
   2feec:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
   2fef0:	f7fd fcde 	bl	2d8b0 <nrf_free>
   2fef4:	2300      	movs	r3, #0
   2fef6:	f04f 30ff 	mov.w	r0, #4294967295
   2fefa:	f844 3025 	str.w	r3, [r4, r5, lsl #2]
   2fefe:	e78d      	b.n	2fe1c <pdn_interface_open+0x60>
   2ff00:	2005      	movs	r0, #5
   2ff02:	f7fa fe5f 	bl	2abc4 <bsd_os_errno_set>
   2ff06:	e7f1      	b.n	2feec <pdn_interface_open+0x130>
   2ff08:	2501      	movs	r5, #1
   2ff0a:	e78b      	b.n	2fe24 <pdn_interface_open+0x68>
   2ff0c:	2502      	movs	r5, #2
   2ff0e:	e789      	b.n	2fe24 <pdn_interface_open+0x68>
   2ff10:	2503      	movs	r5, #3
   2ff12:	e787      	b.n	2fe24 <pdn_interface_open+0x68>
   2ff14:	2504      	movs	r5, #4
   2ff16:	e785      	b.n	2fe24 <pdn_interface_open+0x68>
   2ff18:	2505      	movs	r5, #5
   2ff1a:	e783      	b.n	2fe24 <pdn_interface_open+0x68>
   2ff1c:	2506      	movs	r5, #6
   2ff1e:	e781      	b.n	2fe24 <pdn_interface_open+0x68>
   2ff20:	2507      	movs	r5, #7
   2ff22:	e77f      	b.n	2fe24 <pdn_interface_open+0x68>
   2ff24:	2029      	movs	r0, #41	; 0x29
   2ff26:	f7fa fe4d 	bl	2abc4 <bsd_os_errno_set>
   2ff2a:	f04f 30ff 	mov.w	r0, #4294967295
   2ff2e:	e775      	b.n	2fe1c <pdn_interface_open+0x60>
   2ff30:	2005      	movs	r0, #5
   2ff32:	f7fa fe47 	bl	2abc4 <bsd_os_errno_set>
   2ff36:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
   2ff3a:	f7fd fcb9 	bl	2d8b0 <nrf_free>
   2ff3e:	f844 6025 	str.w	r6, [r4, r5, lsl #2]
   2ff42:	4638      	mov	r0, r7
   2ff44:	e76a      	b.n	2fe1c <pdn_interface_open+0x60>
   2ff46:	bf00      	nop
   2ff48:	200252f4 	.word	0x200252f4
   2ff4c:	00040274 	.word	0x00040274
   2ff50:	200251f4 	.word	0x200251f4
   2ff54:	00040284 	.word	0x00040284
   2ff58:	00040290 	.word	0x00040290
   2ff5c:	200251f0 	.word	0x200251f0

0002ff60 <pdn_interface_connect>:
   2ff60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2ff64:	b083      	sub	sp, #12
   2ff66:	2900      	cmp	r1, #0
   2ff68:	f000 813d 	beq.w	301e6 <pdn_interface_connect+0x286>
   2ff6c:	2a64      	cmp	r2, #100	; 0x64
   2ff6e:	4691      	mov	r9, r2
   2ff70:	f200 8139 	bhi.w	301e6 <pdn_interface_connect+0x286>
   2ff74:	4605      	mov	r5, r0
   2ff76:	4608      	mov	r0, r1
   2ff78:	4688      	mov	r8, r1
   2ff7a:	f7ed f8ed 	bl	1d158 <strlen>
   2ff7e:	2864      	cmp	r0, #100	; 0x64
   2ff80:	f200 8131 	bhi.w	301e6 <pdn_interface_connect+0x286>
   2ff84:	0c2b      	lsrs	r3, r5, #16
   2ff86:	4aa5      	ldr	r2, [pc, #660]	; (3021c <pdn_interface_connect+0x2bc>)
   2ff88:	041b      	lsls	r3, r3, #16
   2ff8a:	4293      	cmp	r3, r2
   2ff8c:	f040 8122 	bne.w	301d4 <pdn_interface_connect+0x274>
   2ff90:	f025 45f1 	bic.w	r5, r5, #2021654528	; 0x78800000
   2ff94:	f425 15d0 	bic.w	r5, r5, #1703936	; 0x1a0000
   2ff98:	2d09      	cmp	r5, #9
   2ff9a:	f300 811b 	bgt.w	301d4 <pdn_interface_connect+0x274>
   2ff9e:	4fa0      	ldr	r7, [pc, #640]	; (30220 <pdn_interface_connect+0x2c0>)
   2ffa0:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   2ffa4:	2b00      	cmp	r3, #0
   2ffa6:	f000 8115 	beq.w	301d4 <pdn_interface_connect+0x274>
   2ffaa:	689a      	ldr	r2, [r3, #8]
   2ffac:	2a00      	cmp	r2, #0
   2ffae:	f000 8111 	beq.w	301d4 <pdn_interface_connect+0x274>
   2ffb2:	689b      	ldr	r3, [r3, #8]
   2ffb4:	2b02      	cmp	r3, #2
   2ffb6:	f040 810d 	bne.w	301d4 <pdn_interface_connect+0x274>
   2ffba:	4e9a      	ldr	r6, [pc, #616]	; (30224 <pdn_interface_connect+0x2c4>)
   2ffbc:	4a9a      	ldr	r2, [pc, #616]	; (30228 <pdn_interface_connect+0x2c8>)
   2ffbe:	f44f 7180 	mov.w	r1, #256	; 0x100
   2ffc2:	4630      	mov	r0, r6
   2ffc4:	f009 fd7a 	bl	39abc <sniprintf>
   2ffc8:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   2ffcc:	4604      	mov	r4, r0
   2ffce:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   2ffd2:	681b      	ldr	r3, [r3, #0]
   2ffd4:	4a95      	ldr	r2, [pc, #596]	; (3022c <pdn_interface_connect+0x2cc>)
   2ffd6:	1830      	adds	r0, r6, r0
   2ffd8:	f009 fd70 	bl	39abc <sniprintf>
   2ffdc:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   2ffe0:	4404      	add	r4, r0
   2ffe2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   2ffe4:	f003 0203 	and.w	r2, r3, #3
   2ffe8:	2a03      	cmp	r2, #3
   2ffea:	f000 80ea 	beq.w	301c2 <pdn_interface_connect+0x262>
   2ffee:	079b      	lsls	r3, r3, #30
   2fff0:	eb06 0004 	add.w	r0, r6, r4
   2fff4:	f5c4 7180 	rsb	r1, r4, #256	; 0x100
   2fff8:	bf4c      	ite	mi
   2fffa:	4b8d      	ldrmi	r3, [pc, #564]	; (30230 <pdn_interface_connect+0x2d0>)
   2fffc:	4b8d      	ldrpl	r3, [pc, #564]	; (30234 <pdn_interface_connect+0x2d4>)
   2fffe:	4a8e      	ldr	r2, [pc, #568]	; (30238 <pdn_interface_connect+0x2d8>)
   30000:	f009 fd5c 	bl	39abc <sniprintf>
   30004:	4404      	add	r4, r0
   30006:	4643      	mov	r3, r8
   30008:	4a8c      	ldr	r2, [pc, #560]	; (3023c <pdn_interface_connect+0x2dc>)
   3000a:	f5c4 7180 	rsb	r1, r4, #256	; 0x100
   3000e:	1930      	adds	r0, r6, r4
   30010:	f009 fd54 	bl	39abc <sniprintf>
   30014:	4420      	add	r0, r4
   30016:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
   3001a:	f300 80f7 	bgt.w	3020c <pdn_interface_connect+0x2ac>
   3001e:	f8df a23c 	ldr.w	sl, [pc, #572]	; 3025c <pdn_interface_connect+0x2fc>
   30022:	4880      	ldr	r0, [pc, #512]	; (30224 <pdn_interface_connect+0x2c4>)
   30024:	f8da b000 	ldr.w	fp, [sl]
   30028:	2400      	movs	r4, #0
   3002a:	f7ed f895 	bl	1d158 <strlen>
   3002e:	4623      	mov	r3, r4
   30030:	4602      	mov	r2, r0
   30032:	497c      	ldr	r1, [pc, #496]	; (30224 <pdn_interface_connect+0x2c4>)
   30034:	4658      	mov	r0, fp
   30036:	9401      	str	r4, [sp, #4]
   30038:	9400      	str	r4, [sp, #0]
   3003a:	f7fc fe7f 	bl	2cd3c <at_interface_write>
   3003e:	4683      	mov	fp, r0
   30040:	4878      	ldr	r0, [pc, #480]	; (30224 <pdn_interface_connect+0x2c4>)
   30042:	f7ed f889 	bl	1d158 <strlen>
   30046:	4558      	cmp	r0, fp
   30048:	d008      	beq.n	3005c <pdn_interface_connect+0xfc>
   3004a:	2005      	movs	r0, #5
   3004c:	f7fa fdba 	bl	2abc4 <bsd_os_errno_set>
   30050:	f04f 34ff 	mov.w	r4, #4294967295
   30054:	4620      	mov	r0, r4
   30056:	b003      	add	sp, #12
   30058:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3005c:	4623      	mov	r3, r4
   3005e:	e9cd 4400 	strd	r4, r4, [sp]
   30062:	f44f 7280 	mov.w	r2, #256	; 0x100
   30066:	496f      	ldr	r1, [pc, #444]	; (30224 <pdn_interface_connect+0x2c4>)
   30068:	f8da 0000 	ldr.w	r0, [sl]
   3006c:	f7fc ff6a 	bl	2cf44 <at_interface_read>
   30070:	4604      	mov	r4, r0
   30072:	4873      	ldr	r0, [pc, #460]	; (30240 <pdn_interface_connect+0x2e0>)
   30074:	f7ed f870 	bl	1d158 <strlen>
   30078:	4284      	cmp	r4, r0
   3007a:	f2c0 8091 	blt.w	301a0 <pdn_interface_connect+0x240>
   3007e:	4602      	mov	r2, r0
   30080:	4968      	ldr	r1, [pc, #416]	; (30224 <pdn_interface_connect+0x2c4>)
   30082:	486f      	ldr	r0, [pc, #444]	; (30240 <pdn_interface_connect+0x2e0>)
   30084:	f00e fd73 	bl	3eb6e <strncmp>
   30088:	2800      	cmp	r0, #0
   3008a:	f040 8089 	bne.w	301a0 <pdn_interface_connect+0x240>
   3008e:	4965      	ldr	r1, [pc, #404]	; (30224 <pdn_interface_connect+0x2c4>)
   30090:	4628      	mov	r0, r5
   30092:	f7ff fde9 	bl	2fc68 <ok_rsp_parser>
   30096:	4604      	mov	r4, r0
   30098:	2800      	cmp	r0, #0
   3009a:	d1db      	bne.n	30054 <pdn_interface_connect+0xf4>
   3009c:	4a69      	ldr	r2, [pc, #420]	; (30244 <pdn_interface_connect+0x2e4>)
   3009e:	f44f 7180 	mov.w	r1, #256	; 0x100
   300a2:	4860      	ldr	r0, [pc, #384]	; (30224 <pdn_interface_connect+0x2c4>)
   300a4:	f009 fd0a 	bl	39abc <sniprintf>
   300a8:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   300ac:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   300b0:	681b      	ldr	r3, [r3, #0]
   300b2:	4a65      	ldr	r2, [pc, #404]	; (30248 <pdn_interface_connect+0x2e8>)
   300b4:	4430      	add	r0, r6
   300b6:	f009 fd01 	bl	39abc <sniprintf>
   300ba:	485a      	ldr	r0, [pc, #360]	; (30224 <pdn_interface_connect+0x2c4>)
   300bc:	f8da b000 	ldr.w	fp, [sl]
   300c0:	f7ed f84a 	bl	1d158 <strlen>
   300c4:	4623      	mov	r3, r4
   300c6:	4602      	mov	r2, r0
   300c8:	4956      	ldr	r1, [pc, #344]	; (30224 <pdn_interface_connect+0x2c4>)
   300ca:	4658      	mov	r0, fp
   300cc:	9401      	str	r4, [sp, #4]
   300ce:	9400      	str	r4, [sp, #0]
   300d0:	f7fc fe34 	bl	2cd3c <at_interface_write>
   300d4:	4683      	mov	fp, r0
   300d6:	4853      	ldr	r0, [pc, #332]	; (30224 <pdn_interface_connect+0x2c4>)
   300d8:	f7ed f83e 	bl	1d158 <strlen>
   300dc:	4558      	cmp	r0, fp
   300de:	d1b4      	bne.n	3004a <pdn_interface_connect+0xea>
   300e0:	4623      	mov	r3, r4
   300e2:	f44f 7280 	mov.w	r2, #256	; 0x100
   300e6:	494f      	ldr	r1, [pc, #316]	; (30224 <pdn_interface_connect+0x2c4>)
   300e8:	f8da 0000 	ldr.w	r0, [sl]
   300ec:	e9cd 4400 	strd	r4, r4, [sp]
   300f0:	f7fc ff28 	bl	2cf44 <at_interface_read>
   300f4:	4683      	mov	fp, r0
   300f6:	4852      	ldr	r0, [pc, #328]	; (30240 <pdn_interface_connect+0x2e0>)
   300f8:	f7ed f82e 	bl	1d158 <strlen>
   300fc:	4583      	cmp	fp, r0
   300fe:	db4f      	blt.n	301a0 <pdn_interface_connect+0x240>
   30100:	4602      	mov	r2, r0
   30102:	4948      	ldr	r1, [pc, #288]	; (30224 <pdn_interface_connect+0x2c4>)
   30104:	484e      	ldr	r0, [pc, #312]	; (30240 <pdn_interface_connect+0x2e0>)
   30106:	f00e fd32 	bl	3eb6e <strncmp>
   3010a:	2800      	cmp	r0, #0
   3010c:	d148      	bne.n	301a0 <pdn_interface_connect+0x240>
   3010e:	2103      	movs	r1, #3
   30110:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   30114:	464a      	mov	r2, r9
   30116:	6099      	str	r1, [r3, #8]
   30118:	f857 0025 	ldr.w	r0, [r7, r5, lsl #2]
   3011c:	4641      	mov	r1, r8
   3011e:	300c      	adds	r0, #12
   30120:	f00e fb94 	bl	3e84c <memcpy>
   30124:	4a49      	ldr	r2, [pc, #292]	; (3024c <pdn_interface_connect+0x2ec>)
   30126:	f44f 7180 	mov.w	r1, #256	; 0x100
   3012a:	483e      	ldr	r0, [pc, #248]	; (30224 <pdn_interface_connect+0x2c4>)
   3012c:	f009 fcc6 	bl	39abc <sniprintf>
   30130:	4601      	mov	r1, r0
   30132:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   30136:	f5c1 7180 	rsb	r1, r1, #256	; 0x100
   3013a:	681b      	ldr	r3, [r3, #0]
   3013c:	4a42      	ldr	r2, [pc, #264]	; (30248 <pdn_interface_connect+0x2e8>)
   3013e:	1830      	adds	r0, r6, r0
   30140:	f009 fcbc 	bl	39abc <sniprintf>
   30144:	4837      	ldr	r0, [pc, #220]	; (30224 <pdn_interface_connect+0x2c4>)
   30146:	f8da 6000 	ldr.w	r6, [sl]
   3014a:	f7ed f805 	bl	1d158 <strlen>
   3014e:	4623      	mov	r3, r4
   30150:	4602      	mov	r2, r0
   30152:	4934      	ldr	r1, [pc, #208]	; (30224 <pdn_interface_connect+0x2c4>)
   30154:	4630      	mov	r0, r6
   30156:	9401      	str	r4, [sp, #4]
   30158:	9400      	str	r4, [sp, #0]
   3015a:	f7fc fdef 	bl	2cd3c <at_interface_write>
   3015e:	4606      	mov	r6, r0
   30160:	4830      	ldr	r0, [pc, #192]	; (30224 <pdn_interface_connect+0x2c4>)
   30162:	f7ec fff9 	bl	1d158 <strlen>
   30166:	42b0      	cmp	r0, r6
   30168:	d153      	bne.n	30212 <pdn_interface_connect+0x2b2>
   3016a:	4623      	mov	r3, r4
   3016c:	f44f 7280 	mov.w	r2, #256	; 0x100
   30170:	492c      	ldr	r1, [pc, #176]	; (30224 <pdn_interface_connect+0x2c4>)
   30172:	f8da 0000 	ldr.w	r0, [sl]
   30176:	e9cd 4400 	strd	r4, r4, [sp]
   3017a:	f7fc fee3 	bl	2cf44 <at_interface_read>
   3017e:	4606      	mov	r6, r0
   30180:	4833      	ldr	r0, [pc, #204]	; (30250 <pdn_interface_connect+0x2f0>)
   30182:	f7ec ffe9 	bl	1d158 <strlen>
   30186:	4286      	cmp	r6, r0
   30188:	db33      	blt.n	301f2 <pdn_interface_connect+0x292>
   3018a:	4602      	mov	r2, r0
   3018c:	4925      	ldr	r1, [pc, #148]	; (30224 <pdn_interface_connect+0x2c4>)
   3018e:	4830      	ldr	r0, [pc, #192]	; (30250 <pdn_interface_connect+0x2f0>)
   30190:	f00e fced 	bl	3eb6e <strncmp>
   30194:	bb68      	cbnz	r0, 301f2 <pdn_interface_connect+0x292>
   30196:	4628      	mov	r0, r5
   30198:	4922      	ldr	r1, [pc, #136]	; (30224 <pdn_interface_connect+0x2c4>)
   3019a:	f7ff fd9d 	bl	2fcd8 <pdn_id_get_parser>
   3019e:	e759      	b.n	30054 <pdn_interface_connect+0xf4>
   301a0:	482c      	ldr	r0, [pc, #176]	; (30254 <pdn_interface_connect+0x2f4>)
   301a2:	f7ec ffd9 	bl	1d158 <strlen>
   301a6:	491f      	ldr	r1, [pc, #124]	; (30224 <pdn_interface_connect+0x2c4>)
   301a8:	4602      	mov	r2, r0
   301aa:	482a      	ldr	r0, [pc, #168]	; (30254 <pdn_interface_connect+0x2f4>)
   301ac:	f00e fcdf 	bl	3eb6e <strncmp>
   301b0:	2800      	cmp	r0, #0
   301b2:	f47f af4a 	bne.w	3004a <pdn_interface_connect+0xea>
   301b6:	2008      	movs	r0, #8
   301b8:	f7fa fd04 	bl	2abc4 <bsd_os_errno_set>
   301bc:	f04f 34ff 	mov.w	r4, #4294967295
   301c0:	e748      	b.n	30054 <pdn_interface_connect+0xf4>
   301c2:	f5c4 7180 	rsb	r1, r4, #256	; 0x100
   301c6:	1930      	adds	r0, r6, r4
   301c8:	4b23      	ldr	r3, [pc, #140]	; (30258 <pdn_interface_connect+0x2f8>)
   301ca:	4a1b      	ldr	r2, [pc, #108]	; (30238 <pdn_interface_connect+0x2d8>)
   301cc:	f009 fc76 	bl	39abc <sniprintf>
   301d0:	4404      	add	r4, r0
   301d2:	e718      	b.n	30006 <pdn_interface_connect+0xa6>
   301d4:	f04f 34ff 	mov.w	r4, #4294967295
   301d8:	2009      	movs	r0, #9
   301da:	f7fa fcf3 	bl	2abc4 <bsd_os_errno_set>
   301de:	4620      	mov	r0, r4
   301e0:	b003      	add	sp, #12
   301e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   301e6:	2016      	movs	r0, #22
   301e8:	f7fa fcec 	bl	2abc4 <bsd_os_errno_set>
   301ec:	f04f 34ff 	mov.w	r4, #4294967295
   301f0:	e730      	b.n	30054 <pdn_interface_connect+0xf4>
   301f2:	4818      	ldr	r0, [pc, #96]	; (30254 <pdn_interface_connect+0x2f4>)
   301f4:	f7ec ffb0 	bl	1d158 <strlen>
   301f8:	490a      	ldr	r1, [pc, #40]	; (30224 <pdn_interface_connect+0x2c4>)
   301fa:	4602      	mov	r2, r0
   301fc:	4815      	ldr	r0, [pc, #84]	; (30254 <pdn_interface_connect+0x2f4>)
   301fe:	f00e fcb6 	bl	3eb6e <strncmp>
   30202:	b930      	cbnz	r0, 30212 <pdn_interface_connect+0x2b2>
   30204:	2008      	movs	r0, #8
   30206:	f7fa fcdd 	bl	2abc4 <bsd_os_errno_set>
   3020a:	e723      	b.n	30054 <pdn_interface_connect+0xf4>
   3020c:	f04f 34ff 	mov.w	r4, #4294967295
   30210:	e720      	b.n	30054 <pdn_interface_connect+0xf4>
   30212:	2005      	movs	r0, #5
   30214:	f7fa fcd6 	bl	2abc4 <bsd_os_errno_set>
   30218:	e71c      	b.n	30054 <pdn_interface_connect+0xf4>
   3021a:	bf00      	nop
   3021c:	789a0000 	.word	0x789a0000
   30220:	200252f4 	.word	0x200252f4
   30224:	200251f4 	.word	0x200251f4
   30228:	000401fc 	.word	0x000401fc
   3022c:	00040208 	.word	0x00040208
   30230:	0004021c 	.word	0x0004021c
   30234:	00040224 	.word	0x00040224
   30238:	00040214 	.word	0x00040214
   3023c:	00040258 	.word	0x00040258
   30240:	00040228 	.word	0x00040228
   30244:	0004022c 	.word	0x0004022c
   30248:	00040238 	.word	0x00040238
   3024c:	0004023c 	.word	0x0004023c
   30250:	0004024c 	.word	0x0004024c
   30254:	00040290 	.word	0x00040290
   30258:	0004020c 	.word	0x0004020c
   3025c:	200251f0 	.word	0x200251f0

00030260 <pdn_interface_close>:
   30260:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   30264:	4a64      	ldr	r2, [pc, #400]	; (303f8 <pdn_interface_close+0x198>)
   30266:	0c03      	lsrs	r3, r0, #16
   30268:	041b      	lsls	r3, r3, #16
   3026a:	4293      	cmp	r3, r2
   3026c:	b083      	sub	sp, #12
   3026e:	f040 809d 	bne.w	303ac <pdn_interface_close+0x14c>
   30272:	f020 44f1 	bic.w	r4, r0, #2021654528	; 0x78800000
   30276:	f424 14d0 	bic.w	r4, r4, #1703936	; 0x1a0000
   3027a:	2c09      	cmp	r4, #9
   3027c:	f300 8096 	bgt.w	303ac <pdn_interface_close+0x14c>
   30280:	4d5e      	ldr	r5, [pc, #376]	; (303fc <pdn_interface_close+0x19c>)
   30282:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   30286:	2800      	cmp	r0, #0
   30288:	f000 8090 	beq.w	303ac <pdn_interface_close+0x14c>
   3028c:	6883      	ldr	r3, [r0, #8]
   3028e:	2b00      	cmp	r3, #0
   30290:	f000 808c 	beq.w	303ac <pdn_interface_close+0x14c>
   30294:	6883      	ldr	r3, [r0, #8]
   30296:	2b03      	cmp	r3, #3
   30298:	d008      	beq.n	302ac <pdn_interface_close+0x4c>
   3029a:	f7fd fb09 	bl	2d8b0 <nrf_free>
   3029e:	2300      	movs	r3, #0
   302a0:	4618      	mov	r0, r3
   302a2:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
   302a6:	b003      	add	sp, #12
   302a8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   302ac:	4e54      	ldr	r6, [pc, #336]	; (30400 <pdn_interface_close+0x1a0>)
   302ae:	4a55      	ldr	r2, [pc, #340]	; (30404 <pdn_interface_close+0x1a4>)
   302b0:	f44f 7180 	mov.w	r1, #256	; 0x100
   302b4:	4630      	mov	r0, r6
   302b6:	f009 fc01 	bl	39abc <sniprintf>
   302ba:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   302be:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   302c2:	681b      	ldr	r3, [r3, #0]
   302c4:	4a50      	ldr	r2, [pc, #320]	; (30408 <pdn_interface_close+0x1a8>)
   302c6:	4430      	add	r0, r6
   302c8:	f8df 814c 	ldr.w	r8, [pc, #332]	; 30418 <pdn_interface_close+0x1b8>
   302cc:	f009 fbf6 	bl	39abc <sniprintf>
   302d0:	4630      	mov	r0, r6
   302d2:	f8d8 9000 	ldr.w	r9, [r8]
   302d6:	2700      	movs	r7, #0
   302d8:	f7ec ff3e 	bl	1d158 <strlen>
   302dc:	4631      	mov	r1, r6
   302de:	4602      	mov	r2, r0
   302e0:	463b      	mov	r3, r7
   302e2:	4648      	mov	r0, r9
   302e4:	9701      	str	r7, [sp, #4]
   302e6:	9700      	str	r7, [sp, #0]
   302e8:	f7fc fd28 	bl	2cd3c <at_interface_write>
   302ec:	4681      	mov	r9, r0
   302ee:	4630      	mov	r0, r6
   302f0:	f7ec ff32 	bl	1d158 <strlen>
   302f4:	4548      	cmp	r0, r9
   302f6:	d176      	bne.n	303e6 <pdn_interface_close+0x186>
   302f8:	463b      	mov	r3, r7
   302fa:	e9cd 7700 	strd	r7, r7, [sp]
   302fe:	f44f 7280 	mov.w	r2, #256	; 0x100
   30302:	4631      	mov	r1, r6
   30304:	f8d8 0000 	ldr.w	r0, [r8]
   30308:	f7fc fe1c 	bl	2cf44 <at_interface_read>
   3030c:	4607      	mov	r7, r0
   3030e:	483f      	ldr	r0, [pc, #252]	; (3040c <pdn_interface_close+0x1ac>)
   30310:	f7ec ff22 	bl	1d158 <strlen>
   30314:	4287      	cmp	r7, r0
   30316:	da4f      	bge.n	303b8 <pdn_interface_close+0x158>
   30318:	483d      	ldr	r0, [pc, #244]	; (30410 <pdn_interface_close+0x1b0>)
   3031a:	f7ec ff1d 	bl	1d158 <strlen>
   3031e:	4938      	ldr	r1, [pc, #224]	; (30400 <pdn_interface_close+0x1a0>)
   30320:	4602      	mov	r2, r0
   30322:	483b      	ldr	r0, [pc, #236]	; (30410 <pdn_interface_close+0x1b0>)
   30324:	f00e fc23 	bl	3eb6e <strncmp>
   30328:	2800      	cmp	r0, #0
   3032a:	d15c      	bne.n	303e6 <pdn_interface_close+0x186>
   3032c:	2008      	movs	r0, #8
   3032e:	f7fa fc49 	bl	2abc4 <bsd_os_errno_set>
   30332:	4a38      	ldr	r2, [pc, #224]	; (30414 <pdn_interface_close+0x1b4>)
   30334:	f44f 7180 	mov.w	r1, #256	; 0x100
   30338:	4831      	ldr	r0, [pc, #196]	; (30400 <pdn_interface_close+0x1a0>)
   3033a:	f009 fbbf 	bl	39abc <sniprintf>
   3033e:	4601      	mov	r1, r0
   30340:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   30344:	f5c1 7180 	rsb	r1, r1, #256	; 0x100
   30348:	681b      	ldr	r3, [r3, #0]
   3034a:	4a2f      	ldr	r2, [pc, #188]	; (30408 <pdn_interface_close+0x1a8>)
   3034c:	1830      	adds	r0, r6, r0
   3034e:	f009 fbb5 	bl	39abc <sniprintf>
   30352:	482b      	ldr	r0, [pc, #172]	; (30400 <pdn_interface_close+0x1a0>)
   30354:	f8d8 7000 	ldr.w	r7, [r8]
   30358:	2600      	movs	r6, #0
   3035a:	f7ec fefd 	bl	1d158 <strlen>
   3035e:	4633      	mov	r3, r6
   30360:	4602      	mov	r2, r0
   30362:	4927      	ldr	r1, [pc, #156]	; (30400 <pdn_interface_close+0x1a0>)
   30364:	4638      	mov	r0, r7
   30366:	9601      	str	r6, [sp, #4]
   30368:	9600      	str	r6, [sp, #0]
   3036a:	f7fc fce7 	bl	2cd3c <at_interface_write>
   3036e:	4607      	mov	r7, r0
   30370:	4823      	ldr	r0, [pc, #140]	; (30400 <pdn_interface_close+0x1a0>)
   30372:	f7ec fef1 	bl	1d158 <strlen>
   30376:	42b8      	cmp	r0, r7
   30378:	d139      	bne.n	303ee <pdn_interface_close+0x18e>
   3037a:	4633      	mov	r3, r6
   3037c:	e9cd 6600 	strd	r6, r6, [sp]
   30380:	f44f 7280 	mov.w	r2, #256	; 0x100
   30384:	491e      	ldr	r1, [pc, #120]	; (30400 <pdn_interface_close+0x1a0>)
   30386:	f8d8 0000 	ldr.w	r0, [r8]
   3038a:	f7fc fddb 	bl	2cf44 <at_interface_read>
   3038e:	4606      	mov	r6, r0
   30390:	481e      	ldr	r0, [pc, #120]	; (3040c <pdn_interface_close+0x1ac>)
   30392:	f7ec fee1 	bl	1d158 <strlen>
   30396:	4286      	cmp	r6, r0
   30398:	db16      	blt.n	303c8 <pdn_interface_close+0x168>
   3039a:	4602      	mov	r2, r0
   3039c:	4918      	ldr	r1, [pc, #96]	; (30400 <pdn_interface_close+0x1a0>)
   3039e:	481b      	ldr	r0, [pc, #108]	; (3040c <pdn_interface_close+0x1ac>)
   303a0:	f00e fbe5 	bl	3eb6e <strncmp>
   303a4:	b980      	cbnz	r0, 303c8 <pdn_interface_close+0x168>
   303a6:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   303aa:	e776      	b.n	3029a <pdn_interface_close+0x3a>
   303ac:	2009      	movs	r0, #9
   303ae:	f7fa fc09 	bl	2abc4 <bsd_os_errno_set>
   303b2:	f04f 30ff 	mov.w	r0, #4294967295
   303b6:	e776      	b.n	302a6 <pdn_interface_close+0x46>
   303b8:	4602      	mov	r2, r0
   303ba:	4631      	mov	r1, r6
   303bc:	4813      	ldr	r0, [pc, #76]	; (3040c <pdn_interface_close+0x1ac>)
   303be:	f00e fbd6 	bl	3eb6e <strncmp>
   303c2:	2800      	cmp	r0, #0
   303c4:	d0b5      	beq.n	30332 <pdn_interface_close+0xd2>
   303c6:	e7a7      	b.n	30318 <pdn_interface_close+0xb8>
   303c8:	4811      	ldr	r0, [pc, #68]	; (30410 <pdn_interface_close+0x1b0>)
   303ca:	f7ec fec5 	bl	1d158 <strlen>
   303ce:	490c      	ldr	r1, [pc, #48]	; (30400 <pdn_interface_close+0x1a0>)
   303d0:	4602      	mov	r2, r0
   303d2:	480f      	ldr	r0, [pc, #60]	; (30410 <pdn_interface_close+0x1b0>)
   303d4:	f00e fbcb 	bl	3eb6e <strncmp>
   303d8:	b948      	cbnz	r0, 303ee <pdn_interface_close+0x18e>
   303da:	2008      	movs	r0, #8
   303dc:	f7fa fbf2 	bl	2abc4 <bsd_os_errno_set>
   303e0:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   303e4:	e759      	b.n	3029a <pdn_interface_close+0x3a>
   303e6:	2005      	movs	r0, #5
   303e8:	f7fa fbec 	bl	2abc4 <bsd_os_errno_set>
   303ec:	e7a1      	b.n	30332 <pdn_interface_close+0xd2>
   303ee:	2005      	movs	r0, #5
   303f0:	f7fa fbe8 	bl	2abc4 <bsd_os_errno_set>
   303f4:	e7d7      	b.n	303a6 <pdn_interface_close+0x146>
   303f6:	bf00      	nop
   303f8:	789a0000 	.word	0x789a0000
   303fc:	200252f4 	.word	0x200252f4
   30400:	200251f4 	.word	0x200251f4
   30404:	000401f0 	.word	0x000401f0
   30408:	00040238 	.word	0x00040238
   3040c:	00040228 	.word	0x00040228
   30410:	00040290 	.word	0x00040290
   30414:	000401fc 	.word	0x000401fc
   30418:	200251f0 	.word	0x200251f0

0003041c <pdn_interface_setopt>:
   3041c:	b510      	push	{r4, lr}
   3041e:	f240 2402 	movw	r4, #514	; 0x202
   30422:	42a1      	cmp	r1, r4
   30424:	d10d      	bne.n	30442 <pdn_interface_setopt+0x26>
   30426:	b163      	cbz	r3, 30442 <pdn_interface_setopt+0x26>
   30428:	9902      	ldr	r1, [sp, #8]
   3042a:	b151      	cbz	r1, 30442 <pdn_interface_setopt+0x26>
   3042c:	0c01      	lsrs	r1, r0, #16
   3042e:	4c25      	ldr	r4, [pc, #148]	; (304c4 <pdn_interface_setopt+0xa8>)
   30430:	0409      	lsls	r1, r1, #16
   30432:	42a1      	cmp	r1, r4
   30434:	d00b      	beq.n	3044e <pdn_interface_setopt+0x32>
   30436:	2009      	movs	r0, #9
   30438:	f7fa fbc4 	bl	2abc4 <bsd_os_errno_set>
   3043c:	f04f 30ff 	mov.w	r0, #4294967295
   30440:	bd10      	pop	{r4, pc}
   30442:	2016      	movs	r0, #22
   30444:	f7fa fbbe 	bl	2abc4 <bsd_os_errno_set>
   30448:	f04f 30ff 	mov.w	r0, #4294967295
   3044c:	bd10      	pop	{r4, pc}
   3044e:	f020 40f1 	bic.w	r0, r0, #2021654528	; 0x78800000
   30452:	f420 10d0 	bic.w	r0, r0, #1703936	; 0x1a0000
   30456:	2809      	cmp	r0, #9
   30458:	dced      	bgt.n	30436 <pdn_interface_setopt+0x1a>
   3045a:	491b      	ldr	r1, [pc, #108]	; (304c8 <pdn_interface_setopt+0xac>)
   3045c:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
   30460:	2900      	cmp	r1, #0
   30462:	d0e8      	beq.n	30436 <pdn_interface_setopt+0x1a>
   30464:	6888      	ldr	r0, [r1, #8]
   30466:	2800      	cmp	r0, #0
   30468:	d0e5      	beq.n	30436 <pdn_interface_setopt+0x1a>
   3046a:	2a01      	cmp	r2, #1
   3046c:	d001      	beq.n	30472 <pdn_interface_setopt+0x56>
   3046e:	202d      	movs	r0, #45	; 0x2d
   30470:	e7e8      	b.n	30444 <pdn_interface_setopt+0x28>
   30472:	688a      	ldr	r2, [r1, #8]
   30474:	b1fa      	cbz	r2, 304b6 <pdn_interface_setopt+0x9a>
   30476:	688a      	ldr	r2, [r1, #8]
   30478:	2a03      	cmp	r2, #3
   3047a:	d01c      	beq.n	304b6 <pdn_interface_setopt+0x9a>
   3047c:	688a      	ldr	r2, [r1, #8]
   3047e:	2a04      	cmp	r2, #4
   30480:	d019      	beq.n	304b6 <pdn_interface_setopt+0x9a>
   30482:	9a02      	ldr	r2, [sp, #8]
   30484:	0890      	lsrs	r0, r2, #2
   30486:	1e42      	subs	r2, r0, #1
   30488:	2a01      	cmp	r2, #1
   3048a:	d8da      	bhi.n	30442 <pdn_interface_setopt+0x26>
   3048c:	9a02      	ldr	r2, [sp, #8]
   3048e:	0792      	lsls	r2, r2, #30
   30490:	d1d7      	bne.n	30442 <pdn_interface_setopt+0x26>
   30492:	681a      	ldr	r2, [r3, #0]
   30494:	2a02      	cmp	r2, #2
   30496:	d010      	beq.n	304ba <pdn_interface_setopt+0x9e>
   30498:	2a0a      	cmp	r2, #10
   3049a:	d1d2      	bne.n	30442 <pdn_interface_setopt+0x26>
   3049c:	2202      	movs	r2, #2
   3049e:	2802      	cmp	r0, #2
   304a0:	d106      	bne.n	304b0 <pdn_interface_setopt+0x94>
   304a2:	685b      	ldr	r3, [r3, #4]
   304a4:	2b02      	cmp	r3, #2
   304a6:	d00a      	beq.n	304be <pdn_interface_setopt+0xa2>
   304a8:	2b0a      	cmp	r3, #10
   304aa:	d1ca      	bne.n	30442 <pdn_interface_setopt+0x26>
   304ac:	f042 0202 	orr.w	r2, r2, #2
   304b0:	670a      	str	r2, [r1, #112]	; 0x70
   304b2:	2000      	movs	r0, #0
   304b4:	e7c6      	b.n	30444 <pdn_interface_setopt+0x28>
   304b6:	200e      	movs	r0, #14
   304b8:	e7c4      	b.n	30444 <pdn_interface_setopt+0x28>
   304ba:	2201      	movs	r2, #1
   304bc:	e7ef      	b.n	3049e <pdn_interface_setopt+0x82>
   304be:	f042 0201 	orr.w	r2, r2, #1
   304c2:	e7f5      	b.n	304b0 <pdn_interface_setopt+0x94>
   304c4:	789a0000 	.word	0x789a0000
   304c8:	200252f4 	.word	0x200252f4

000304cc <pdn_interface_getopt>:
   304cc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   304d0:	f240 2402 	movw	r4, #514	; 0x202
   304d4:	b083      	sub	sp, #12
   304d6:	42a1      	cmp	r1, r4
   304d8:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   304da:	f040 80a9 	bne.w	30630 <pdn_interface_getopt+0x164>
   304de:	461e      	mov	r6, r3
   304e0:	2b00      	cmp	r3, #0
   304e2:	f000 80a5 	beq.w	30630 <pdn_interface_getopt+0x164>
   304e6:	2d00      	cmp	r5, #0
   304e8:	f000 80a2 	beq.w	30630 <pdn_interface_getopt+0x164>
   304ec:	0c03      	lsrs	r3, r0, #16
   304ee:	4956      	ldr	r1, [pc, #344]	; (30648 <pdn_interface_getopt+0x17c>)
   304f0:	041b      	lsls	r3, r3, #16
   304f2:	428b      	cmp	r3, r1
   304f4:	f040 8082 	bne.w	305fc <pdn_interface_getopt+0x130>
   304f8:	f020 44f1 	bic.w	r4, r0, #2021654528	; 0x78800000
   304fc:	f424 14d0 	bic.w	r4, r4, #1703936	; 0x1a0000
   30500:	2c09      	cmp	r4, #9
   30502:	dc7b      	bgt.n	305fc <pdn_interface_getopt+0x130>
   30504:	4b51      	ldr	r3, [pc, #324]	; (3064c <pdn_interface_getopt+0x180>)
   30506:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   3050a:	2b00      	cmp	r3, #0
   3050c:	d076      	beq.n	305fc <pdn_interface_getopt+0x130>
   3050e:	6899      	ldr	r1, [r3, #8]
   30510:	2900      	cmp	r1, #0
   30512:	d073      	beq.n	305fc <pdn_interface_getopt+0x130>
   30514:	2a02      	cmp	r2, #2
   30516:	d00e      	beq.n	30536 <pdn_interface_getopt+0x6a>
   30518:	2a03      	cmp	r2, #3
   3051a:	d008      	beq.n	3052e <pdn_interface_getopt+0x62>
   3051c:	2a01      	cmp	r2, #1
   3051e:	d015      	beq.n	3054c <pdn_interface_getopt+0x80>
   30520:	202d      	movs	r0, #45	; 0x2d
   30522:	f7fa fb4f 	bl	2abc4 <bsd_os_errno_set>
   30526:	2000      	movs	r0, #0
   30528:	b003      	add	sp, #12
   3052a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   3052e:	682b      	ldr	r3, [r5, #0]
   30530:	bb23      	cbnz	r3, 3057c <pdn_interface_getopt+0xb0>
   30532:	2016      	movs	r0, #22
   30534:	e7f5      	b.n	30522 <pdn_interface_getopt+0x56>
   30536:	682a      	ldr	r2, [r5, #0]
   30538:	2a00      	cmp	r2, #0
   3053a:	d0fa      	beq.n	30532 <pdn_interface_getopt+0x66>
   3053c:	2201      	movs	r2, #1
   3053e:	2000      	movs	r0, #0
   30540:	681b      	ldr	r3, [r3, #0]
   30542:	7033      	strb	r3, [r6, #0]
   30544:	602a      	str	r2, [r5, #0]
   30546:	b003      	add	sp, #12
   30548:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   3054c:	689a      	ldr	r2, [r3, #8]
   3054e:	2a00      	cmp	r2, #0
   30550:	d052      	beq.n	305f8 <pdn_interface_getopt+0x12c>
   30552:	689a      	ldr	r2, [r3, #8]
   30554:	2a04      	cmp	r2, #4
   30556:	d04f      	beq.n	305f8 <pdn_interface_getopt+0x12c>
   30558:	682a      	ldr	r2, [r5, #0]
   3055a:	2a07      	cmp	r2, #7
   3055c:	d9e9      	bls.n	30532 <pdn_interface_getopt+0x66>
   3055e:	f012 0203 	ands.w	r2, r2, #3
   30562:	d1e6      	bne.n	30532 <pdn_interface_getopt+0x66>
   30564:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   30566:	0799      	lsls	r1, r3, #30
   30568:	d45d      	bmi.n	30626 <pdn_interface_getopt+0x15a>
   3056a:	2104      	movs	r1, #4
   3056c:	07db      	lsls	r3, r3, #31
   3056e:	d502      	bpl.n	30576 <pdn_interface_getopt+0xaa>
   30570:	2302      	movs	r3, #2
   30572:	50b3      	str	r3, [r6, r2]
   30574:	460a      	mov	r2, r1
   30576:	602a      	str	r2, [r5, #0]
   30578:	2000      	movs	r0, #0
   3057a:	e7d5      	b.n	30528 <pdn_interface_getopt+0x5c>
   3057c:	4a34      	ldr	r2, [pc, #208]	; (30650 <pdn_interface_getopt+0x184>)
   3057e:	f44f 7180 	mov.w	r1, #256	; 0x100
   30582:	4834      	ldr	r0, [pc, #208]	; (30654 <pdn_interface_getopt+0x188>)
   30584:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 30660 <pdn_interface_getopt+0x194>
   30588:	f009 fa98 	bl	39abc <sniprintf>
   3058c:	4831      	ldr	r0, [pc, #196]	; (30654 <pdn_interface_getopt+0x188>)
   3058e:	f8d8 9000 	ldr.w	r9, [r8]
   30592:	2700      	movs	r7, #0
   30594:	f7ec fde0 	bl	1d158 <strlen>
   30598:	463b      	mov	r3, r7
   3059a:	4602      	mov	r2, r0
   3059c:	492d      	ldr	r1, [pc, #180]	; (30654 <pdn_interface_getopt+0x188>)
   3059e:	4648      	mov	r0, r9
   305a0:	9701      	str	r7, [sp, #4]
   305a2:	9700      	str	r7, [sp, #0]
   305a4:	f7fc fbca 	bl	2cd3c <at_interface_write>
   305a8:	4681      	mov	r9, r0
   305aa:	482a      	ldr	r0, [pc, #168]	; (30654 <pdn_interface_getopt+0x188>)
   305ac:	f7ec fdd4 	bl	1d158 <strlen>
   305b0:	4548      	cmp	r0, r9
   305b2:	d143      	bne.n	3063c <pdn_interface_getopt+0x170>
   305b4:	463b      	mov	r3, r7
   305b6:	e9cd 7700 	strd	r7, r7, [sp]
   305ba:	f44f 7280 	mov.w	r2, #256	; 0x100
   305be:	4925      	ldr	r1, [pc, #148]	; (30654 <pdn_interface_getopt+0x188>)
   305c0:	f8d8 0000 	ldr.w	r0, [r8]
   305c4:	f7fc fcbe 	bl	2cf44 <at_interface_read>
   305c8:	4607      	mov	r7, r0
   305ca:	4823      	ldr	r0, [pc, #140]	; (30658 <pdn_interface_getopt+0x18c>)
   305cc:	f7ec fdc4 	bl	1d158 <strlen>
   305d0:	4287      	cmp	r7, r0
   305d2:	db19      	blt.n	30608 <pdn_interface_getopt+0x13c>
   305d4:	4602      	mov	r2, r0
   305d6:	491f      	ldr	r1, [pc, #124]	; (30654 <pdn_interface_getopt+0x188>)
   305d8:	481f      	ldr	r0, [pc, #124]	; (30658 <pdn_interface_getopt+0x18c>)
   305da:	f00e fac8 	bl	3eb6e <strncmp>
   305de:	4607      	mov	r7, r0
   305e0:	b990      	cbnz	r0, 30608 <pdn_interface_getopt+0x13c>
   305e2:	4620      	mov	r0, r4
   305e4:	491b      	ldr	r1, [pc, #108]	; (30654 <pdn_interface_getopt+0x188>)
   305e6:	f7ff fb41 	bl	2fc6c <pdn_state_get_parser>
   305ea:	2800      	cmp	r0, #0
   305ec:	db99      	blt.n	30522 <pdn_interface_getopt+0x56>
   305ee:	2301      	movs	r3, #1
   305f0:	7030      	strb	r0, [r6, #0]
   305f2:	4638      	mov	r0, r7
   305f4:	602b      	str	r3, [r5, #0]
   305f6:	e797      	b.n	30528 <pdn_interface_getopt+0x5c>
   305f8:	200e      	movs	r0, #14
   305fa:	e792      	b.n	30522 <pdn_interface_getopt+0x56>
   305fc:	2009      	movs	r0, #9
   305fe:	f7fa fae1 	bl	2abc4 <bsd_os_errno_set>
   30602:	f04f 30ff 	mov.w	r0, #4294967295
   30606:	e78f      	b.n	30528 <pdn_interface_getopt+0x5c>
   30608:	4814      	ldr	r0, [pc, #80]	; (3065c <pdn_interface_getopt+0x190>)
   3060a:	f7ec fda5 	bl	1d158 <strlen>
   3060e:	4911      	ldr	r1, [pc, #68]	; (30654 <pdn_interface_getopt+0x188>)
   30610:	4602      	mov	r2, r0
   30612:	4812      	ldr	r0, [pc, #72]	; (3065c <pdn_interface_getopt+0x190>)
   30614:	f00e faab 	bl	3eb6e <strncmp>
   30618:	b980      	cbnz	r0, 3063c <pdn_interface_getopt+0x170>
   3061a:	2008      	movs	r0, #8
   3061c:	f7fa fad2 	bl	2abc4 <bsd_os_errno_set>
   30620:	f04f 30ff 	mov.w	r0, #4294967295
   30624:	e77d      	b.n	30522 <pdn_interface_getopt+0x56>
   30626:	220a      	movs	r2, #10
   30628:	2108      	movs	r1, #8
   3062a:	6032      	str	r2, [r6, #0]
   3062c:	2204      	movs	r2, #4
   3062e:	e79d      	b.n	3056c <pdn_interface_getopt+0xa0>
   30630:	2016      	movs	r0, #22
   30632:	f7fa fac7 	bl	2abc4 <bsd_os_errno_set>
   30636:	f04f 30ff 	mov.w	r0, #4294967295
   3063a:	e775      	b.n	30528 <pdn_interface_getopt+0x5c>
   3063c:	2005      	movs	r0, #5
   3063e:	f7fa fac1 	bl	2abc4 <bsd_os_errno_set>
   30642:	f04f 30ff 	mov.w	r0, #4294967295
   30646:	e76c      	b.n	30522 <pdn_interface_getopt+0x56>
   30648:	789a0000 	.word	0x789a0000
   3064c:	200252f4 	.word	0x200252f4
   30650:	00040260 	.word	0x00040260
   30654:	200251f4 	.word	0x200251f4
   30658:	0004026c 	.word	0x0004026c
   3065c:	00040290 	.word	0x00040290
   30660:	200251f0 	.word	0x200251f0

00030664 <pdn_interface_pdn_id_get>:
   30664:	2900      	cmp	r1, #0
   30666:	f000 83b9 	beq.w	30ddc <pdn_interface_pdn_id_get+0x778>
   3066a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   3066e:	4ca3      	ldr	r4, [pc, #652]	; (308fc <pdn_interface_pdn_id_get+0x298>)
   30670:	2802      	cmp	r0, #2
   30672:	b083      	sub	sp, #12
   30674:	460d      	mov	r5, r1
   30676:	6823      	ldr	r3, [r4, #0]
   30678:	f000 8094 	beq.w	307a4 <pdn_interface_pdn_id_get+0x140>
   3067c:	280a      	cmp	r0, #10
   3067e:	d03f      	beq.n	30700 <pdn_interface_pdn_id_get+0x9c>
   30680:	b11b      	cbz	r3, 3068a <pdn_interface_pdn_id_get+0x26>
   30682:	689b      	ldr	r3, [r3, #8]
   30684:	2b03      	cmp	r3, #3
   30686:	f000 8127 	beq.w	308d8 <pdn_interface_pdn_id_get+0x274>
   3068a:	6863      	ldr	r3, [r4, #4]
   3068c:	b11b      	cbz	r3, 30696 <pdn_interface_pdn_id_get+0x32>
   3068e:	689b      	ldr	r3, [r3, #8]
   30690:	2b03      	cmp	r3, #3
   30692:	f000 8110 	beq.w	308b6 <pdn_interface_pdn_id_get+0x252>
   30696:	68a3      	ldr	r3, [r4, #8]
   30698:	b11b      	cbz	r3, 306a2 <pdn_interface_pdn_id_get+0x3e>
   3069a:	689b      	ldr	r3, [r3, #8]
   3069c:	2b03      	cmp	r3, #3
   3069e:	f000 80f9 	beq.w	30894 <pdn_interface_pdn_id_get+0x230>
   306a2:	68e3      	ldr	r3, [r4, #12]
   306a4:	b11b      	cbz	r3, 306ae <pdn_interface_pdn_id_get+0x4a>
   306a6:	689b      	ldr	r3, [r3, #8]
   306a8:	2b03      	cmp	r3, #3
   306aa:	f000 80e2 	beq.w	30872 <pdn_interface_pdn_id_get+0x20e>
   306ae:	6923      	ldr	r3, [r4, #16]
   306b0:	b11b      	cbz	r3, 306ba <pdn_interface_pdn_id_get+0x56>
   306b2:	689b      	ldr	r3, [r3, #8]
   306b4:	2b03      	cmp	r3, #3
   306b6:	f000 8123 	beq.w	30900 <pdn_interface_pdn_id_get+0x29c>
   306ba:	6963      	ldr	r3, [r4, #20]
   306bc:	b11b      	cbz	r3, 306c6 <pdn_interface_pdn_id_get+0x62>
   306be:	689b      	ldr	r3, [r3, #8]
   306c0:	2b03      	cmp	r3, #3
   306c2:	f000 8161 	beq.w	30988 <pdn_interface_pdn_id_get+0x324>
   306c6:	69a3      	ldr	r3, [r4, #24]
   306c8:	b11b      	cbz	r3, 306d2 <pdn_interface_pdn_id_get+0x6e>
   306ca:	689b      	ldr	r3, [r3, #8]
   306cc:	2b03      	cmp	r3, #3
   306ce:	f000 814a 	beq.w	30966 <pdn_interface_pdn_id_get+0x302>
   306d2:	69e3      	ldr	r3, [r4, #28]
   306d4:	b11b      	cbz	r3, 306de <pdn_interface_pdn_id_get+0x7a>
   306d6:	689b      	ldr	r3, [r3, #8]
   306d8:	2b03      	cmp	r3, #3
   306da:	f000 8133 	beq.w	30944 <pdn_interface_pdn_id_get+0x2e0>
   306de:	6a23      	ldr	r3, [r4, #32]
   306e0:	b11b      	cbz	r3, 306ea <pdn_interface_pdn_id_get+0x86>
   306e2:	689b      	ldr	r3, [r3, #8]
   306e4:	2b03      	cmp	r3, #3
   306e6:	f000 811c 	beq.w	30922 <pdn_interface_pdn_id_get+0x2be>
   306ea:	6a63      	ldr	r3, [r4, #36]	; 0x24
   306ec:	b11b      	cbz	r3, 306f6 <pdn_interface_pdn_id_get+0x92>
   306ee:	689b      	ldr	r3, [r3, #8]
   306f0:	2b03      	cmp	r3, #3
   306f2:	f000 80ad 	beq.w	30850 <pdn_interface_pdn_id_get+0x1ec>
   306f6:	f04f 30ff 	mov.w	r0, #4294967295
   306fa:	b003      	add	sp, #12
   306fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   30700:	b11b      	cbz	r3, 3070a <pdn_interface_pdn_id_get+0xa6>
   30702:	689b      	ldr	r3, [r3, #8]
   30704:	2b03      	cmp	r3, #3
   30706:	f000 8335 	beq.w	30d74 <pdn_interface_pdn_id_get+0x710>
   3070a:	6863      	ldr	r3, [r4, #4]
   3070c:	b11b      	cbz	r3, 30716 <pdn_interface_pdn_id_get+0xb2>
   3070e:	689b      	ldr	r3, [r3, #8]
   30710:	2b03      	cmp	r3, #3
   30712:	f000 82fd 	beq.w	30d10 <pdn_interface_pdn_id_get+0x6ac>
   30716:	68a3      	ldr	r3, [r4, #8]
   30718:	b11b      	cbz	r3, 30722 <pdn_interface_pdn_id_get+0xbe>
   3071a:	689b      	ldr	r3, [r3, #8]
   3071c:	2b03      	cmp	r3, #3
   3071e:	f000 82d5 	beq.w	30ccc <pdn_interface_pdn_id_get+0x668>
   30722:	68e3      	ldr	r3, [r4, #12]
   30724:	b11b      	cbz	r3, 3072e <pdn_interface_pdn_id_get+0xca>
   30726:	689e      	ldr	r6, [r3, #8]
   30728:	2e03      	cmp	r6, #3
   3072a:	f000 81f0 	beq.w	30b0e <pdn_interface_pdn_id_get+0x4aa>
   3072e:	6923      	ldr	r3, [r4, #16]
   30730:	b11b      	cbz	r3, 3073a <pdn_interface_pdn_id_get+0xd6>
   30732:	689b      	ldr	r3, [r3, #8]
   30734:	2b03      	cmp	r3, #3
   30736:	f000 8203 	beq.w	30b40 <pdn_interface_pdn_id_get+0x4dc>
   3073a:	6963      	ldr	r3, [r4, #20]
   3073c:	b11b      	cbz	r3, 30746 <pdn_interface_pdn_id_get+0xe2>
   3073e:	689b      	ldr	r3, [r3, #8]
   30740:	2b03      	cmp	r3, #3
   30742:	f000 8215 	beq.w	30b70 <pdn_interface_pdn_id_get+0x50c>
   30746:	69a3      	ldr	r3, [r4, #24]
   30748:	b11b      	cbz	r3, 30752 <pdn_interface_pdn_id_get+0xee>
   3074a:	689b      	ldr	r3, [r3, #8]
   3074c:	2b03      	cmp	r3, #3
   3074e:	f000 8227 	beq.w	30ba0 <pdn_interface_pdn_id_get+0x53c>
   30752:	69e3      	ldr	r3, [r4, #28]
   30754:	b11b      	cbz	r3, 3075e <pdn_interface_pdn_id_get+0xfa>
   30756:	689b      	ldr	r3, [r3, #8]
   30758:	2b03      	cmp	r3, #3
   3075a:	f000 8239 	beq.w	30bd0 <pdn_interface_pdn_id_get+0x56c>
   3075e:	6a23      	ldr	r3, [r4, #32]
   30760:	b11b      	cbz	r3, 3076a <pdn_interface_pdn_id_get+0x106>
   30762:	689b      	ldr	r3, [r3, #8]
   30764:	2b03      	cmp	r3, #3
   30766:	f000 824d 	beq.w	30c04 <pdn_interface_pdn_id_get+0x5a0>
   3076a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   3076c:	2b00      	cmp	r3, #0
   3076e:	d0c2      	beq.n	306f6 <pdn_interface_pdn_id_get+0x92>
   30770:	689b      	ldr	r3, [r3, #8]
   30772:	2b03      	cmp	r3, #3
   30774:	d1bf      	bne.n	306f6 <pdn_interface_pdn_id_get+0x92>
   30776:	4628      	mov	r0, r5
   30778:	f7ec fcee 	bl	1d158 <strlen>
   3077c:	4606      	mov	r6, r0
   3077e:	6a60      	ldr	r0, [r4, #36]	; 0x24
   30780:	300c      	adds	r0, #12
   30782:	f7ec fce9 	bl	1d158 <strlen>
   30786:	42b0      	cmp	r0, r6
   30788:	d1b5      	bne.n	306f6 <pdn_interface_pdn_id_get+0x92>
   3078a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   3078c:	4628      	mov	r0, r5
   3078e:	310c      	adds	r1, #12
   30790:	f7ec fcd8 	bl	1d144 <strcmp>
   30794:	2800      	cmp	r0, #0
   30796:	d1ae      	bne.n	306f6 <pdn_interface_pdn_id_get+0x92>
   30798:	6a63      	ldr	r3, [r4, #36]	; 0x24
   3079a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   3079c:	0792      	lsls	r2, r2, #30
   3079e:	d5aa      	bpl.n	306f6 <pdn_interface_pdn_id_get+0x92>
   307a0:	2609      	movs	r6, #9
   307a2:	e11a      	b.n	309da <pdn_interface_pdn_id_get+0x376>
   307a4:	b11b      	cbz	r3, 307ae <pdn_interface_pdn_id_get+0x14a>
   307a6:	689b      	ldr	r3, [r3, #8]
   307a8:	2b03      	cmp	r3, #3
   307aa:	f000 82fd 	beq.w	30da8 <pdn_interface_pdn_id_get+0x744>
   307ae:	6863      	ldr	r3, [r4, #4]
   307b0:	b11b      	cbz	r3, 307ba <pdn_interface_pdn_id_get+0x156>
   307b2:	689b      	ldr	r3, [r3, #8]
   307b4:	2b03      	cmp	r3, #3
   307b6:	f000 82c5 	beq.w	30d44 <pdn_interface_pdn_id_get+0x6e0>
   307ba:	68a3      	ldr	r3, [r4, #8]
   307bc:	b11b      	cbz	r3, 307c6 <pdn_interface_pdn_id_get+0x162>
   307be:	689b      	ldr	r3, [r3, #8]
   307c0:	2b03      	cmp	r3, #3
   307c2:	f000 8269 	beq.w	30c98 <pdn_interface_pdn_id_get+0x634>
   307c6:	68e3      	ldr	r3, [r4, #12]
   307c8:	b11b      	cbz	r3, 307d2 <pdn_interface_pdn_id_get+0x16e>
   307ca:	689e      	ldr	r6, [r3, #8]
   307cc:	2e03      	cmp	r6, #3
   307ce:	f000 80ec 	beq.w	309aa <pdn_interface_pdn_id_get+0x346>
   307d2:	6923      	ldr	r3, [r4, #16]
   307d4:	b11b      	cbz	r3, 307de <pdn_interface_pdn_id_get+0x17a>
   307d6:	689b      	ldr	r3, [r3, #8]
   307d8:	2b03      	cmp	r3, #3
   307da:	f000 814a 	beq.w	30a72 <pdn_interface_pdn_id_get+0x40e>
   307de:	6963      	ldr	r3, [r4, #20]
   307e0:	b11b      	cbz	r3, 307ea <pdn_interface_pdn_id_get+0x186>
   307e2:	689b      	ldr	r3, [r3, #8]
   307e4:	2b03      	cmp	r3, #3
   307e6:	f000 815e 	beq.w	30aa6 <pdn_interface_pdn_id_get+0x442>
   307ea:	69a3      	ldr	r3, [r4, #24]
   307ec:	b11b      	cbz	r3, 307f6 <pdn_interface_pdn_id_get+0x192>
   307ee:	689b      	ldr	r3, [r3, #8]
   307f0:	2b03      	cmp	r3, #3
   307f2:	f000 8172 	beq.w	30ada <pdn_interface_pdn_id_get+0x476>
   307f6:	69e3      	ldr	r3, [r4, #28]
   307f8:	b11b      	cbz	r3, 30802 <pdn_interface_pdn_id_get+0x19e>
   307fa:	689b      	ldr	r3, [r3, #8]
   307fc:	2b03      	cmp	r3, #3
   307fe:	f000 821b 	beq.w	30c38 <pdn_interface_pdn_id_get+0x5d4>
   30802:	6a23      	ldr	r3, [r4, #32]
   30804:	b11b      	cbz	r3, 3080e <pdn_interface_pdn_id_get+0x1aa>
   30806:	689b      	ldr	r3, [r3, #8]
   30808:	2b03      	cmp	r3, #3
   3080a:	f000 822d 	beq.w	30c68 <pdn_interface_pdn_id_get+0x604>
   3080e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   30810:	2b00      	cmp	r3, #0
   30812:	f43f af70 	beq.w	306f6 <pdn_interface_pdn_id_get+0x92>
   30816:	689b      	ldr	r3, [r3, #8]
   30818:	2b03      	cmp	r3, #3
   3081a:	f47f af6c 	bne.w	306f6 <pdn_interface_pdn_id_get+0x92>
   3081e:	4628      	mov	r0, r5
   30820:	f7ec fc9a 	bl	1d158 <strlen>
   30824:	4606      	mov	r6, r0
   30826:	6a60      	ldr	r0, [r4, #36]	; 0x24
   30828:	300c      	adds	r0, #12
   3082a:	f7ec fc95 	bl	1d158 <strlen>
   3082e:	4286      	cmp	r6, r0
   30830:	f47f af61 	bne.w	306f6 <pdn_interface_pdn_id_get+0x92>
   30834:	6a61      	ldr	r1, [r4, #36]	; 0x24
   30836:	4628      	mov	r0, r5
   30838:	310c      	adds	r1, #12
   3083a:	f7ec fc83 	bl	1d144 <strcmp>
   3083e:	2800      	cmp	r0, #0
   30840:	f47f af59 	bne.w	306f6 <pdn_interface_pdn_id_get+0x92>
   30844:	6a63      	ldr	r3, [r4, #36]	; 0x24
   30846:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30848:	07d2      	lsls	r2, r2, #31
   3084a:	f57f af54 	bpl.w	306f6 <pdn_interface_pdn_id_get+0x92>
   3084e:	e7a7      	b.n	307a0 <pdn_interface_pdn_id_get+0x13c>
   30850:	4628      	mov	r0, r5
   30852:	f7ec fc81 	bl	1d158 <strlen>
   30856:	4606      	mov	r6, r0
   30858:	6a60      	ldr	r0, [r4, #36]	; 0x24
   3085a:	300c      	adds	r0, #12
   3085c:	f7ec fc7c 	bl	1d158 <strlen>
   30860:	42b0      	cmp	r0, r6
   30862:	f47f af48 	bne.w	306f6 <pdn_interface_pdn_id_get+0x92>
   30866:	6a61      	ldr	r1, [r4, #36]	; 0x24
   30868:	4628      	mov	r0, r5
   3086a:	310c      	adds	r1, #12
   3086c:	f7ec fc6a 	bl	1d144 <strcmp>
   30870:	e741      	b.n	306f6 <pdn_interface_pdn_id_get+0x92>
   30872:	4628      	mov	r0, r5
   30874:	f7ec fc70 	bl	1d158 <strlen>
   30878:	4606      	mov	r6, r0
   3087a:	68e0      	ldr	r0, [r4, #12]
   3087c:	300c      	adds	r0, #12
   3087e:	f7ec fc6b 	bl	1d158 <strlen>
   30882:	4286      	cmp	r6, r0
   30884:	f47f af13 	bne.w	306ae <pdn_interface_pdn_id_get+0x4a>
   30888:	68e1      	ldr	r1, [r4, #12]
   3088a:	4628      	mov	r0, r5
   3088c:	310c      	adds	r1, #12
   3088e:	f7ec fc59 	bl	1d144 <strcmp>
   30892:	e70c      	b.n	306ae <pdn_interface_pdn_id_get+0x4a>
   30894:	4628      	mov	r0, r5
   30896:	f7ec fc5f 	bl	1d158 <strlen>
   3089a:	4606      	mov	r6, r0
   3089c:	68a0      	ldr	r0, [r4, #8]
   3089e:	300c      	adds	r0, #12
   308a0:	f7ec fc5a 	bl	1d158 <strlen>
   308a4:	4286      	cmp	r6, r0
   308a6:	f47f aefc 	bne.w	306a2 <pdn_interface_pdn_id_get+0x3e>
   308aa:	68a1      	ldr	r1, [r4, #8]
   308ac:	4628      	mov	r0, r5
   308ae:	310c      	adds	r1, #12
   308b0:	f7ec fc48 	bl	1d144 <strcmp>
   308b4:	e6f5      	b.n	306a2 <pdn_interface_pdn_id_get+0x3e>
   308b6:	4628      	mov	r0, r5
   308b8:	f7ec fc4e 	bl	1d158 <strlen>
   308bc:	4606      	mov	r6, r0
   308be:	6860      	ldr	r0, [r4, #4]
   308c0:	300c      	adds	r0, #12
   308c2:	f7ec fc49 	bl	1d158 <strlen>
   308c6:	4286      	cmp	r6, r0
   308c8:	f47f aee5 	bne.w	30696 <pdn_interface_pdn_id_get+0x32>
   308cc:	6861      	ldr	r1, [r4, #4]
   308ce:	4628      	mov	r0, r5
   308d0:	310c      	adds	r1, #12
   308d2:	f7ec fc37 	bl	1d144 <strcmp>
   308d6:	e6de      	b.n	30696 <pdn_interface_pdn_id_get+0x32>
   308d8:	4608      	mov	r0, r1
   308da:	f7ec fc3d 	bl	1d158 <strlen>
   308de:	4606      	mov	r6, r0
   308e0:	6820      	ldr	r0, [r4, #0]
   308e2:	300c      	adds	r0, #12
   308e4:	f7ec fc38 	bl	1d158 <strlen>
   308e8:	4286      	cmp	r6, r0
   308ea:	f47f aece 	bne.w	3068a <pdn_interface_pdn_id_get+0x26>
   308ee:	6821      	ldr	r1, [r4, #0]
   308f0:	4628      	mov	r0, r5
   308f2:	310c      	adds	r1, #12
   308f4:	f7ec fc26 	bl	1d144 <strcmp>
   308f8:	e6c7      	b.n	3068a <pdn_interface_pdn_id_get+0x26>
   308fa:	bf00      	nop
   308fc:	200252f4 	.word	0x200252f4
   30900:	4628      	mov	r0, r5
   30902:	f7ec fc29 	bl	1d158 <strlen>
   30906:	4606      	mov	r6, r0
   30908:	6920      	ldr	r0, [r4, #16]
   3090a:	300c      	adds	r0, #12
   3090c:	f7ec fc24 	bl	1d158 <strlen>
   30910:	4286      	cmp	r6, r0
   30912:	f47f aed2 	bne.w	306ba <pdn_interface_pdn_id_get+0x56>
   30916:	6921      	ldr	r1, [r4, #16]
   30918:	4628      	mov	r0, r5
   3091a:	310c      	adds	r1, #12
   3091c:	f7ec fc12 	bl	1d144 <strcmp>
   30920:	e6cb      	b.n	306ba <pdn_interface_pdn_id_get+0x56>
   30922:	4628      	mov	r0, r5
   30924:	f7ec fc18 	bl	1d158 <strlen>
   30928:	4606      	mov	r6, r0
   3092a:	6a20      	ldr	r0, [r4, #32]
   3092c:	300c      	adds	r0, #12
   3092e:	f7ec fc13 	bl	1d158 <strlen>
   30932:	4286      	cmp	r6, r0
   30934:	f47f aed9 	bne.w	306ea <pdn_interface_pdn_id_get+0x86>
   30938:	6a21      	ldr	r1, [r4, #32]
   3093a:	4628      	mov	r0, r5
   3093c:	310c      	adds	r1, #12
   3093e:	f7ec fc01 	bl	1d144 <strcmp>
   30942:	e6d2      	b.n	306ea <pdn_interface_pdn_id_get+0x86>
   30944:	4628      	mov	r0, r5
   30946:	f7ec fc07 	bl	1d158 <strlen>
   3094a:	4606      	mov	r6, r0
   3094c:	69e0      	ldr	r0, [r4, #28]
   3094e:	300c      	adds	r0, #12
   30950:	f7ec fc02 	bl	1d158 <strlen>
   30954:	4286      	cmp	r6, r0
   30956:	f47f aec2 	bne.w	306de <pdn_interface_pdn_id_get+0x7a>
   3095a:	69e1      	ldr	r1, [r4, #28]
   3095c:	4628      	mov	r0, r5
   3095e:	310c      	adds	r1, #12
   30960:	f7ec fbf0 	bl	1d144 <strcmp>
   30964:	e6bb      	b.n	306de <pdn_interface_pdn_id_get+0x7a>
   30966:	4628      	mov	r0, r5
   30968:	f7ec fbf6 	bl	1d158 <strlen>
   3096c:	4606      	mov	r6, r0
   3096e:	69a0      	ldr	r0, [r4, #24]
   30970:	300c      	adds	r0, #12
   30972:	f7ec fbf1 	bl	1d158 <strlen>
   30976:	4286      	cmp	r6, r0
   30978:	f47f aeab 	bne.w	306d2 <pdn_interface_pdn_id_get+0x6e>
   3097c:	69a1      	ldr	r1, [r4, #24]
   3097e:	4628      	mov	r0, r5
   30980:	310c      	adds	r1, #12
   30982:	f7ec fbdf 	bl	1d144 <strcmp>
   30986:	e6a4      	b.n	306d2 <pdn_interface_pdn_id_get+0x6e>
   30988:	4628      	mov	r0, r5
   3098a:	f7ec fbe5 	bl	1d158 <strlen>
   3098e:	4606      	mov	r6, r0
   30990:	6960      	ldr	r0, [r4, #20]
   30992:	300c      	adds	r0, #12
   30994:	f7ec fbe0 	bl	1d158 <strlen>
   30998:	4286      	cmp	r6, r0
   3099a:	f47f ae94 	bne.w	306c6 <pdn_interface_pdn_id_get+0x62>
   3099e:	6961      	ldr	r1, [r4, #20]
   309a0:	4628      	mov	r0, r5
   309a2:	310c      	adds	r1, #12
   309a4:	f7ec fbce 	bl	1d144 <strcmp>
   309a8:	e68d      	b.n	306c6 <pdn_interface_pdn_id_get+0x62>
   309aa:	4628      	mov	r0, r5
   309ac:	f7ec fbd4 	bl	1d158 <strlen>
   309b0:	4607      	mov	r7, r0
   309b2:	68e0      	ldr	r0, [r4, #12]
   309b4:	300c      	adds	r0, #12
   309b6:	f7ec fbcf 	bl	1d158 <strlen>
   309ba:	4287      	cmp	r7, r0
   309bc:	f47f af09 	bne.w	307d2 <pdn_interface_pdn_id_get+0x16e>
   309c0:	68e1      	ldr	r1, [r4, #12]
   309c2:	4628      	mov	r0, r5
   309c4:	310c      	adds	r1, #12
   309c6:	f7ec fbbd 	bl	1d144 <strcmp>
   309ca:	2800      	cmp	r0, #0
   309cc:	f47f af01 	bne.w	307d2 <pdn_interface_pdn_id_get+0x16e>
   309d0:	68e3      	ldr	r3, [r4, #12]
   309d2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   309d4:	07d1      	lsls	r1, r2, #31
   309d6:	f57f aefc 	bpl.w	307d2 <pdn_interface_pdn_id_get+0x16e>
   309da:	6858      	ldr	r0, [r3, #4]
   309dc:	1c43      	adds	r3, r0, #1
   309de:	f47f ae8c 	bne.w	306fa <pdn_interface_pdn_id_get+0x96>
   309e2:	4dc6      	ldr	r5, [pc, #792]	; (30cfc <pdn_interface_pdn_id_get+0x698>)
   309e4:	4ac6      	ldr	r2, [pc, #792]	; (30d00 <pdn_interface_pdn_id_get+0x69c>)
   309e6:	f44f 7180 	mov.w	r1, #256	; 0x100
   309ea:	4628      	mov	r0, r5
   309ec:	f009 f866 	bl	39abc <sniprintf>
   309f0:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   309f4:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   309f8:	681b      	ldr	r3, [r3, #0]
   309fa:	4ac2      	ldr	r2, [pc, #776]	; (30d04 <pdn_interface_pdn_id_get+0x6a0>)
   309fc:	4428      	add	r0, r5
   309fe:	f8df 830c 	ldr.w	r8, [pc, #780]	; 30d0c <pdn_interface_pdn_id_get+0x6a8>
   30a02:	f009 f85b 	bl	39abc <sniprintf>
   30a06:	4628      	mov	r0, r5
   30a08:	f8d8 9000 	ldr.w	r9, [r8]
   30a0c:	2700      	movs	r7, #0
   30a0e:	f7ec fba3 	bl	1d158 <strlen>
   30a12:	4629      	mov	r1, r5
   30a14:	4602      	mov	r2, r0
   30a16:	463b      	mov	r3, r7
   30a18:	4648      	mov	r0, r9
   30a1a:	9701      	str	r7, [sp, #4]
   30a1c:	9700      	str	r7, [sp, #0]
   30a1e:	f7fc f98d 	bl	2cd3c <at_interface_write>
   30a22:	4681      	mov	r9, r0
   30a24:	4628      	mov	r0, r5
   30a26:	f7ec fb97 	bl	1d158 <strlen>
   30a2a:	4548      	cmp	r0, r9
   30a2c:	f040 81e9 	bne.w	30e02 <pdn_interface_pdn_id_get+0x79e>
   30a30:	463b      	mov	r3, r7
   30a32:	f44f 7280 	mov.w	r2, #256	; 0x100
   30a36:	e9cd 7700 	strd	r7, r7, [sp]
   30a3a:	4629      	mov	r1, r5
   30a3c:	f8d8 0000 	ldr.w	r0, [r8]
   30a40:	f7fc fa80 	bl	2cf44 <at_interface_read>
   30a44:	4607      	mov	r7, r0
   30a46:	48b0      	ldr	r0, [pc, #704]	; (30d08 <pdn_interface_pdn_id_get+0x6a4>)
   30a48:	f7ec fb86 	bl	1d158 <strlen>
   30a4c:	4287      	cmp	r7, r0
   30a4e:	4602      	mov	r2, r0
   30a50:	f2c0 81c7 	blt.w	30de2 <pdn_interface_pdn_id_get+0x77e>
   30a54:	4629      	mov	r1, r5
   30a56:	48ac      	ldr	r0, [pc, #688]	; (30d08 <pdn_interface_pdn_id_get+0x6a4>)
   30a58:	f00e f889 	bl	3eb6e <strncmp>
   30a5c:	2800      	cmp	r0, #0
   30a5e:	f040 81c0 	bne.w	30de2 <pdn_interface_pdn_id_get+0x77e>
   30a62:	4629      	mov	r1, r5
   30a64:	4630      	mov	r0, r6
   30a66:	f7ff f937 	bl	2fcd8 <pdn_id_get_parser>
   30a6a:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   30a6e:	6858      	ldr	r0, [r3, #4]
   30a70:	e643      	b.n	306fa <pdn_interface_pdn_id_get+0x96>
   30a72:	4628      	mov	r0, r5
   30a74:	f7ec fb70 	bl	1d158 <strlen>
   30a78:	4606      	mov	r6, r0
   30a7a:	6920      	ldr	r0, [r4, #16]
   30a7c:	300c      	adds	r0, #12
   30a7e:	f7ec fb6b 	bl	1d158 <strlen>
   30a82:	4286      	cmp	r6, r0
   30a84:	f47f aeab 	bne.w	307de <pdn_interface_pdn_id_get+0x17a>
   30a88:	6921      	ldr	r1, [r4, #16]
   30a8a:	4628      	mov	r0, r5
   30a8c:	310c      	adds	r1, #12
   30a8e:	f7ec fb59 	bl	1d144 <strcmp>
   30a92:	2800      	cmp	r0, #0
   30a94:	f47f aea3 	bne.w	307de <pdn_interface_pdn_id_get+0x17a>
   30a98:	6923      	ldr	r3, [r4, #16]
   30a9a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30a9c:	07d2      	lsls	r2, r2, #31
   30a9e:	f57f ae9e 	bpl.w	307de <pdn_interface_pdn_id_get+0x17a>
   30aa2:	2604      	movs	r6, #4
   30aa4:	e799      	b.n	309da <pdn_interface_pdn_id_get+0x376>
   30aa6:	4628      	mov	r0, r5
   30aa8:	f7ec fb56 	bl	1d158 <strlen>
   30aac:	4606      	mov	r6, r0
   30aae:	6960      	ldr	r0, [r4, #20]
   30ab0:	300c      	adds	r0, #12
   30ab2:	f7ec fb51 	bl	1d158 <strlen>
   30ab6:	4286      	cmp	r6, r0
   30ab8:	f47f ae97 	bne.w	307ea <pdn_interface_pdn_id_get+0x186>
   30abc:	6961      	ldr	r1, [r4, #20]
   30abe:	4628      	mov	r0, r5
   30ac0:	310c      	adds	r1, #12
   30ac2:	f7ec fb3f 	bl	1d144 <strcmp>
   30ac6:	2800      	cmp	r0, #0
   30ac8:	f47f ae8f 	bne.w	307ea <pdn_interface_pdn_id_get+0x186>
   30acc:	6963      	ldr	r3, [r4, #20]
   30ace:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30ad0:	07d7      	lsls	r7, r2, #31
   30ad2:	f57f ae8a 	bpl.w	307ea <pdn_interface_pdn_id_get+0x186>
   30ad6:	2605      	movs	r6, #5
   30ad8:	e77f      	b.n	309da <pdn_interface_pdn_id_get+0x376>
   30ada:	4628      	mov	r0, r5
   30adc:	f7ec fb3c 	bl	1d158 <strlen>
   30ae0:	4606      	mov	r6, r0
   30ae2:	69a0      	ldr	r0, [r4, #24]
   30ae4:	300c      	adds	r0, #12
   30ae6:	f7ec fb37 	bl	1d158 <strlen>
   30aea:	4286      	cmp	r6, r0
   30aec:	f47f ae83 	bne.w	307f6 <pdn_interface_pdn_id_get+0x192>
   30af0:	69a1      	ldr	r1, [r4, #24]
   30af2:	4628      	mov	r0, r5
   30af4:	310c      	adds	r1, #12
   30af6:	f7ec fb25 	bl	1d144 <strcmp>
   30afa:	2800      	cmp	r0, #0
   30afc:	f47f ae7b 	bne.w	307f6 <pdn_interface_pdn_id_get+0x192>
   30b00:	69a3      	ldr	r3, [r4, #24]
   30b02:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30b04:	07d6      	lsls	r6, r2, #31
   30b06:	f57f ae76 	bpl.w	307f6 <pdn_interface_pdn_id_get+0x192>
   30b0a:	2606      	movs	r6, #6
   30b0c:	e765      	b.n	309da <pdn_interface_pdn_id_get+0x376>
   30b0e:	4628      	mov	r0, r5
   30b10:	f7ec fb22 	bl	1d158 <strlen>
   30b14:	4607      	mov	r7, r0
   30b16:	68e0      	ldr	r0, [r4, #12]
   30b18:	300c      	adds	r0, #12
   30b1a:	f7ec fb1d 	bl	1d158 <strlen>
   30b1e:	4287      	cmp	r7, r0
   30b20:	f47f ae05 	bne.w	3072e <pdn_interface_pdn_id_get+0xca>
   30b24:	68e1      	ldr	r1, [r4, #12]
   30b26:	4628      	mov	r0, r5
   30b28:	310c      	adds	r1, #12
   30b2a:	f7ec fb0b 	bl	1d144 <strcmp>
   30b2e:	2800      	cmp	r0, #0
   30b30:	f47f adfd 	bne.w	3072e <pdn_interface_pdn_id_get+0xca>
   30b34:	68e3      	ldr	r3, [r4, #12]
   30b36:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30b38:	0791      	lsls	r1, r2, #30
   30b3a:	f53f af4e 	bmi.w	309da <pdn_interface_pdn_id_get+0x376>
   30b3e:	e5f6      	b.n	3072e <pdn_interface_pdn_id_get+0xca>
   30b40:	4628      	mov	r0, r5
   30b42:	f7ec fb09 	bl	1d158 <strlen>
   30b46:	4606      	mov	r6, r0
   30b48:	6920      	ldr	r0, [r4, #16]
   30b4a:	300c      	adds	r0, #12
   30b4c:	f7ec fb04 	bl	1d158 <strlen>
   30b50:	4286      	cmp	r6, r0
   30b52:	f47f adf2 	bne.w	3073a <pdn_interface_pdn_id_get+0xd6>
   30b56:	6921      	ldr	r1, [r4, #16]
   30b58:	4628      	mov	r0, r5
   30b5a:	310c      	adds	r1, #12
   30b5c:	f7ec faf2 	bl	1d144 <strcmp>
   30b60:	2800      	cmp	r0, #0
   30b62:	f47f adea 	bne.w	3073a <pdn_interface_pdn_id_get+0xd6>
   30b66:	6923      	ldr	r3, [r4, #16]
   30b68:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30b6a:	0792      	lsls	r2, r2, #30
   30b6c:	d499      	bmi.n	30aa2 <pdn_interface_pdn_id_get+0x43e>
   30b6e:	e5e4      	b.n	3073a <pdn_interface_pdn_id_get+0xd6>
   30b70:	4628      	mov	r0, r5
   30b72:	f7ec faf1 	bl	1d158 <strlen>
   30b76:	4606      	mov	r6, r0
   30b78:	6960      	ldr	r0, [r4, #20]
   30b7a:	300c      	adds	r0, #12
   30b7c:	f7ec faec 	bl	1d158 <strlen>
   30b80:	4286      	cmp	r6, r0
   30b82:	f47f ade0 	bne.w	30746 <pdn_interface_pdn_id_get+0xe2>
   30b86:	6961      	ldr	r1, [r4, #20]
   30b88:	4628      	mov	r0, r5
   30b8a:	310c      	adds	r1, #12
   30b8c:	f7ec fada 	bl	1d144 <strcmp>
   30b90:	2800      	cmp	r0, #0
   30b92:	f47f add8 	bne.w	30746 <pdn_interface_pdn_id_get+0xe2>
   30b96:	6963      	ldr	r3, [r4, #20]
   30b98:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30b9a:	0797      	lsls	r7, r2, #30
   30b9c:	d49b      	bmi.n	30ad6 <pdn_interface_pdn_id_get+0x472>
   30b9e:	e5d2      	b.n	30746 <pdn_interface_pdn_id_get+0xe2>
   30ba0:	4628      	mov	r0, r5
   30ba2:	f7ec fad9 	bl	1d158 <strlen>
   30ba6:	4606      	mov	r6, r0
   30ba8:	69a0      	ldr	r0, [r4, #24]
   30baa:	300c      	adds	r0, #12
   30bac:	f7ec fad4 	bl	1d158 <strlen>
   30bb0:	4286      	cmp	r6, r0
   30bb2:	f47f adce 	bne.w	30752 <pdn_interface_pdn_id_get+0xee>
   30bb6:	69a1      	ldr	r1, [r4, #24]
   30bb8:	4628      	mov	r0, r5
   30bba:	310c      	adds	r1, #12
   30bbc:	f7ec fac2 	bl	1d144 <strcmp>
   30bc0:	2800      	cmp	r0, #0
   30bc2:	f47f adc6 	bne.w	30752 <pdn_interface_pdn_id_get+0xee>
   30bc6:	69a3      	ldr	r3, [r4, #24]
   30bc8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30bca:	0796      	lsls	r6, r2, #30
   30bcc:	d49d      	bmi.n	30b0a <pdn_interface_pdn_id_get+0x4a6>
   30bce:	e5c0      	b.n	30752 <pdn_interface_pdn_id_get+0xee>
   30bd0:	4628      	mov	r0, r5
   30bd2:	f7ec fac1 	bl	1d158 <strlen>
   30bd6:	4606      	mov	r6, r0
   30bd8:	69e0      	ldr	r0, [r4, #28]
   30bda:	300c      	adds	r0, #12
   30bdc:	f7ec fabc 	bl	1d158 <strlen>
   30be0:	4286      	cmp	r6, r0
   30be2:	f47f adbc 	bne.w	3075e <pdn_interface_pdn_id_get+0xfa>
   30be6:	69e1      	ldr	r1, [r4, #28]
   30be8:	4628      	mov	r0, r5
   30bea:	310c      	adds	r1, #12
   30bec:	f7ec faaa 	bl	1d144 <strcmp>
   30bf0:	2800      	cmp	r0, #0
   30bf2:	f47f adb4 	bne.w	3075e <pdn_interface_pdn_id_get+0xfa>
   30bf6:	69e3      	ldr	r3, [r4, #28]
   30bf8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30bfa:	0790      	lsls	r0, r2, #30
   30bfc:	f57f adaf 	bpl.w	3075e <pdn_interface_pdn_id_get+0xfa>
   30c00:	2607      	movs	r6, #7
   30c02:	e6ea      	b.n	309da <pdn_interface_pdn_id_get+0x376>
   30c04:	4628      	mov	r0, r5
   30c06:	f7ec faa7 	bl	1d158 <strlen>
   30c0a:	4606      	mov	r6, r0
   30c0c:	6a20      	ldr	r0, [r4, #32]
   30c0e:	300c      	adds	r0, #12
   30c10:	f7ec faa2 	bl	1d158 <strlen>
   30c14:	4286      	cmp	r6, r0
   30c16:	f47f ada8 	bne.w	3076a <pdn_interface_pdn_id_get+0x106>
   30c1a:	6a21      	ldr	r1, [r4, #32]
   30c1c:	4628      	mov	r0, r5
   30c1e:	310c      	adds	r1, #12
   30c20:	f7ec fa90 	bl	1d144 <strcmp>
   30c24:	2800      	cmp	r0, #0
   30c26:	f47f ada0 	bne.w	3076a <pdn_interface_pdn_id_get+0x106>
   30c2a:	6a23      	ldr	r3, [r4, #32]
   30c2c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30c2e:	0791      	lsls	r1, r2, #30
   30c30:	f57f ad9b 	bpl.w	3076a <pdn_interface_pdn_id_get+0x106>
   30c34:	2608      	movs	r6, #8
   30c36:	e6d0      	b.n	309da <pdn_interface_pdn_id_get+0x376>
   30c38:	4628      	mov	r0, r5
   30c3a:	f7ec fa8d 	bl	1d158 <strlen>
   30c3e:	4606      	mov	r6, r0
   30c40:	69e0      	ldr	r0, [r4, #28]
   30c42:	300c      	adds	r0, #12
   30c44:	f7ec fa88 	bl	1d158 <strlen>
   30c48:	4286      	cmp	r6, r0
   30c4a:	f47f adda 	bne.w	30802 <pdn_interface_pdn_id_get+0x19e>
   30c4e:	69e1      	ldr	r1, [r4, #28]
   30c50:	4628      	mov	r0, r5
   30c52:	310c      	adds	r1, #12
   30c54:	f7ec fa76 	bl	1d144 <strcmp>
   30c58:	2800      	cmp	r0, #0
   30c5a:	f47f add2 	bne.w	30802 <pdn_interface_pdn_id_get+0x19e>
   30c5e:	69e3      	ldr	r3, [r4, #28]
   30c60:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30c62:	07d0      	lsls	r0, r2, #31
   30c64:	d4cc      	bmi.n	30c00 <pdn_interface_pdn_id_get+0x59c>
   30c66:	e5cc      	b.n	30802 <pdn_interface_pdn_id_get+0x19e>
   30c68:	4628      	mov	r0, r5
   30c6a:	f7ec fa75 	bl	1d158 <strlen>
   30c6e:	4606      	mov	r6, r0
   30c70:	6a20      	ldr	r0, [r4, #32]
   30c72:	300c      	adds	r0, #12
   30c74:	f7ec fa70 	bl	1d158 <strlen>
   30c78:	4286      	cmp	r6, r0
   30c7a:	f47f adc8 	bne.w	3080e <pdn_interface_pdn_id_get+0x1aa>
   30c7e:	6a21      	ldr	r1, [r4, #32]
   30c80:	4628      	mov	r0, r5
   30c82:	310c      	adds	r1, #12
   30c84:	f7ec fa5e 	bl	1d144 <strcmp>
   30c88:	2800      	cmp	r0, #0
   30c8a:	f47f adc0 	bne.w	3080e <pdn_interface_pdn_id_get+0x1aa>
   30c8e:	6a23      	ldr	r3, [r4, #32]
   30c90:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30c92:	07d1      	lsls	r1, r2, #31
   30c94:	d4ce      	bmi.n	30c34 <pdn_interface_pdn_id_get+0x5d0>
   30c96:	e5ba      	b.n	3080e <pdn_interface_pdn_id_get+0x1aa>
   30c98:	4628      	mov	r0, r5
   30c9a:	f7ec fa5d 	bl	1d158 <strlen>
   30c9e:	4606      	mov	r6, r0
   30ca0:	68a0      	ldr	r0, [r4, #8]
   30ca2:	300c      	adds	r0, #12
   30ca4:	f7ec fa58 	bl	1d158 <strlen>
   30ca8:	4286      	cmp	r6, r0
   30caa:	f47f ad8c 	bne.w	307c6 <pdn_interface_pdn_id_get+0x162>
   30cae:	68a1      	ldr	r1, [r4, #8]
   30cb0:	4628      	mov	r0, r5
   30cb2:	310c      	adds	r1, #12
   30cb4:	f7ec fa46 	bl	1d144 <strcmp>
   30cb8:	2800      	cmp	r0, #0
   30cba:	f47f ad84 	bne.w	307c6 <pdn_interface_pdn_id_get+0x162>
   30cbe:	68a3      	ldr	r3, [r4, #8]
   30cc0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30cc2:	07d0      	lsls	r0, r2, #31
   30cc4:	f57f ad7f 	bpl.w	307c6 <pdn_interface_pdn_id_get+0x162>
   30cc8:	2602      	movs	r6, #2
   30cca:	e686      	b.n	309da <pdn_interface_pdn_id_get+0x376>
   30ccc:	4628      	mov	r0, r5
   30cce:	f7ec fa43 	bl	1d158 <strlen>
   30cd2:	4606      	mov	r6, r0
   30cd4:	68a0      	ldr	r0, [r4, #8]
   30cd6:	300c      	adds	r0, #12
   30cd8:	f7ec fa3e 	bl	1d158 <strlen>
   30cdc:	4286      	cmp	r6, r0
   30cde:	f47f ad20 	bne.w	30722 <pdn_interface_pdn_id_get+0xbe>
   30ce2:	68a1      	ldr	r1, [r4, #8]
   30ce4:	4628      	mov	r0, r5
   30ce6:	310c      	adds	r1, #12
   30ce8:	f7ec fa2c 	bl	1d144 <strcmp>
   30cec:	2800      	cmp	r0, #0
   30cee:	f47f ad18 	bne.w	30722 <pdn_interface_pdn_id_get+0xbe>
   30cf2:	68a3      	ldr	r3, [r4, #8]
   30cf4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30cf6:	0790      	lsls	r0, r2, #30
   30cf8:	d4e6      	bmi.n	30cc8 <pdn_interface_pdn_id_get+0x664>
   30cfa:	e512      	b.n	30722 <pdn_interface_pdn_id_get+0xbe>
   30cfc:	200251f4 	.word	0x200251f4
   30d00:	0004023c 	.word	0x0004023c
   30d04:	00040238 	.word	0x00040238
   30d08:	0004024c 	.word	0x0004024c
   30d0c:	200251f0 	.word	0x200251f0
   30d10:	4628      	mov	r0, r5
   30d12:	f7ec fa21 	bl	1d158 <strlen>
   30d16:	4606      	mov	r6, r0
   30d18:	6860      	ldr	r0, [r4, #4]
   30d1a:	300c      	adds	r0, #12
   30d1c:	f7ec fa1c 	bl	1d158 <strlen>
   30d20:	4286      	cmp	r6, r0
   30d22:	f47f acf8 	bne.w	30716 <pdn_interface_pdn_id_get+0xb2>
   30d26:	6861      	ldr	r1, [r4, #4]
   30d28:	4628      	mov	r0, r5
   30d2a:	310c      	adds	r1, #12
   30d2c:	f7ec fa0a 	bl	1d144 <strcmp>
   30d30:	2800      	cmp	r0, #0
   30d32:	f47f acf0 	bne.w	30716 <pdn_interface_pdn_id_get+0xb2>
   30d36:	6863      	ldr	r3, [r4, #4]
   30d38:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30d3a:	0796      	lsls	r6, r2, #30
   30d3c:	f57f aceb 	bpl.w	30716 <pdn_interface_pdn_id_get+0xb2>
   30d40:	2601      	movs	r6, #1
   30d42:	e64a      	b.n	309da <pdn_interface_pdn_id_get+0x376>
   30d44:	4628      	mov	r0, r5
   30d46:	f7ec fa07 	bl	1d158 <strlen>
   30d4a:	4606      	mov	r6, r0
   30d4c:	6860      	ldr	r0, [r4, #4]
   30d4e:	300c      	adds	r0, #12
   30d50:	f7ec fa02 	bl	1d158 <strlen>
   30d54:	4286      	cmp	r6, r0
   30d56:	f47f ad30 	bne.w	307ba <pdn_interface_pdn_id_get+0x156>
   30d5a:	6861      	ldr	r1, [r4, #4]
   30d5c:	4628      	mov	r0, r5
   30d5e:	310c      	adds	r1, #12
   30d60:	f7ec f9f0 	bl	1d144 <strcmp>
   30d64:	2800      	cmp	r0, #0
   30d66:	f47f ad28 	bne.w	307ba <pdn_interface_pdn_id_get+0x156>
   30d6a:	6863      	ldr	r3, [r4, #4]
   30d6c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30d6e:	07d6      	lsls	r6, r2, #31
   30d70:	d4e6      	bmi.n	30d40 <pdn_interface_pdn_id_get+0x6dc>
   30d72:	e522      	b.n	307ba <pdn_interface_pdn_id_get+0x156>
   30d74:	4608      	mov	r0, r1
   30d76:	f7ec f9ef 	bl	1d158 <strlen>
   30d7a:	4606      	mov	r6, r0
   30d7c:	6820      	ldr	r0, [r4, #0]
   30d7e:	300c      	adds	r0, #12
   30d80:	f7ec f9ea 	bl	1d158 <strlen>
   30d84:	4286      	cmp	r6, r0
   30d86:	f47f acc0 	bne.w	3070a <pdn_interface_pdn_id_get+0xa6>
   30d8a:	6821      	ldr	r1, [r4, #0]
   30d8c:	4628      	mov	r0, r5
   30d8e:	310c      	adds	r1, #12
   30d90:	f7ec f9d8 	bl	1d144 <strcmp>
   30d94:	4606      	mov	r6, r0
   30d96:	2800      	cmp	r0, #0
   30d98:	f47f acb7 	bne.w	3070a <pdn_interface_pdn_id_get+0xa6>
   30d9c:	6823      	ldr	r3, [r4, #0]
   30d9e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30da0:	0797      	lsls	r7, r2, #30
   30da2:	f53f ae1a 	bmi.w	309da <pdn_interface_pdn_id_get+0x376>
   30da6:	e4b0      	b.n	3070a <pdn_interface_pdn_id_get+0xa6>
   30da8:	4608      	mov	r0, r1
   30daa:	f7ec f9d5 	bl	1d158 <strlen>
   30dae:	4606      	mov	r6, r0
   30db0:	6820      	ldr	r0, [r4, #0]
   30db2:	300c      	adds	r0, #12
   30db4:	f7ec f9d0 	bl	1d158 <strlen>
   30db8:	4286      	cmp	r6, r0
   30dba:	f47f acf8 	bne.w	307ae <pdn_interface_pdn_id_get+0x14a>
   30dbe:	6821      	ldr	r1, [r4, #0]
   30dc0:	4628      	mov	r0, r5
   30dc2:	310c      	adds	r1, #12
   30dc4:	f7ec f9be 	bl	1d144 <strcmp>
   30dc8:	4606      	mov	r6, r0
   30dca:	2800      	cmp	r0, #0
   30dcc:	f47f acef 	bne.w	307ae <pdn_interface_pdn_id_get+0x14a>
   30dd0:	6823      	ldr	r3, [r4, #0]
   30dd2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   30dd4:	07d7      	lsls	r7, r2, #31
   30dd6:	f53f ae00 	bmi.w	309da <pdn_interface_pdn_id_get+0x376>
   30dda:	e4e8      	b.n	307ae <pdn_interface_pdn_id_get+0x14a>
   30ddc:	f04f 30ff 	mov.w	r0, #4294967295
   30de0:	4770      	bx	lr
   30de2:	480b      	ldr	r0, [pc, #44]	; (30e10 <pdn_interface_pdn_id_get+0x7ac>)
   30de4:	f7ec f9b8 	bl	1d158 <strlen>
   30de8:	490a      	ldr	r1, [pc, #40]	; (30e14 <pdn_interface_pdn_id_get+0x7b0>)
   30dea:	4602      	mov	r2, r0
   30dec:	4808      	ldr	r0, [pc, #32]	; (30e10 <pdn_interface_pdn_id_get+0x7ac>)
   30dee:	f00d febe 	bl	3eb6e <strncmp>
   30df2:	b930      	cbnz	r0, 30e02 <pdn_interface_pdn_id_get+0x79e>
   30df4:	2008      	movs	r0, #8
   30df6:	f7f9 fee5 	bl	2abc4 <bsd_os_errno_set>
   30dfa:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   30dfe:	6858      	ldr	r0, [r3, #4]
   30e00:	e47b      	b.n	306fa <pdn_interface_pdn_id_get+0x96>
   30e02:	2005      	movs	r0, #5
   30e04:	f7f9 fede 	bl	2abc4 <bsd_os_errno_set>
   30e08:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   30e0c:	6858      	ldr	r0, [r3, #4]
   30e0e:	e474      	b.n	306fa <pdn_interface_pdn_id_get+0x96>
   30e10:	00040290 	.word	0x00040290
   30e14:	200251f4 	.word	0x200251f4

00030e18 <linked_list_init>:
   30e18:	b128      	cbz	r0, 30e26 <linked_list_init+0xe>
   30e1a:	2300      	movs	r3, #0
   30e1c:	6003      	str	r3, [r0, #0]
   30e1e:	e9c0 3301 	strd	r3, r3, [r0, #4]
   30e22:	4618      	mov	r0, r3
   30e24:	4770      	bx	lr
   30e26:	2007      	movs	r0, #7
   30e28:	4770      	bx	lr
   30e2a:	bf00      	nop

00030e2c <linked_list_push>:
   30e2c:	6802      	ldr	r2, [r0, #0]
   30e2e:	4603      	mov	r3, r0
   30e30:	3201      	adds	r2, #1
   30e32:	d00e      	beq.n	30e52 <linked_list_push+0x26>
   30e34:	2200      	movs	r2, #0
   30e36:	600a      	str	r2, [r1, #0]
   30e38:	6802      	ldr	r2, [r0, #0]
   30e3a:	b13a      	cbz	r2, 30e4c <linked_list_push+0x20>
   30e3c:	6882      	ldr	r2, [r0, #8]
   30e3e:	6011      	str	r1, [r2, #0]
   30e40:	6081      	str	r1, [r0, #8]
   30e42:	681a      	ldr	r2, [r3, #0]
   30e44:	2000      	movs	r0, #0
   30e46:	3201      	adds	r2, #1
   30e48:	601a      	str	r2, [r3, #0]
   30e4a:	4770      	bx	lr
   30e4c:	e9c0 1101 	strd	r1, r1, [r0, #4]
   30e50:	e7f7      	b.n	30e42 <linked_list_push+0x16>
   30e52:	2004      	movs	r0, #4
   30e54:	4770      	bx	lr
   30e56:	bf00      	nop

00030e58 <linked_list_pop>:
   30e58:	4603      	mov	r3, r0
   30e5a:	6800      	ldr	r0, [r0, #0]
   30e5c:	b128      	cbz	r0, 30e6a <linked_list_pop+0x12>
   30e5e:	6858      	ldr	r0, [r3, #4]
   30e60:	681a      	ldr	r2, [r3, #0]
   30e62:	6801      	ldr	r1, [r0, #0]
   30e64:	3a01      	subs	r2, #1
   30e66:	6059      	str	r1, [r3, #4]
   30e68:	601a      	str	r2, [r3, #0]
   30e6a:	4770      	bx	lr

00030e6c <linked_list_peek>:
   30e6c:	6803      	ldr	r3, [r0, #0]
   30e6e:	b10b      	cbz	r3, 30e74 <linked_list_peek+0x8>
   30e70:	6840      	ldr	r0, [r0, #4]
   30e72:	4770      	bx	lr
   30e74:	4618      	mov	r0, r3
   30e76:	4770      	bx	lr

00030e78 <linked_list_size_get>:
   30e78:	6800      	ldr	r0, [r0, #0]
   30e7a:	4770      	bx	lr

00030e7c <linked_list_get_next>:
   30e7c:	6800      	ldr	r0, [r0, #0]
   30e7e:	4770      	bx	lr

00030e80 <nrf_socket>:
   30e80:	b570      	push	{r4, r5, r6, lr}
   30e82:	4604      	mov	r4, r0
   30e84:	460d      	mov	r5, r1
   30e86:	4616      	mov	r6, r2
   30e88:	f7fd fdb4 	bl	2e9f4 <bsd_platform_af_method_table_get>
   30e8c:	b130      	cbz	r0, 30e9c <nrf_socket+0x1c>
   30e8e:	6803      	ldr	r3, [r0, #0]
   30e90:	4632      	mov	r2, r6
   30e92:	4629      	mov	r1, r5
   30e94:	4620      	mov	r0, r4
   30e96:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   30e9a:	4718      	bx	r3
   30e9c:	f04f 30ff 	mov.w	r0, #4294967295
   30ea0:	bd70      	pop	{r4, r5, r6, pc}
   30ea2:	bf00      	nop

00030ea4 <nrf_close>:
   30ea4:	b510      	push	{r4, lr}
   30ea6:	4604      	mov	r4, r0
   30ea8:	f7fd fdfc 	bl	2eaa4 <bsd_platform_fd_method_table_get>
   30eac:	b120      	cbz	r0, 30eb8 <nrf_close+0x14>
   30eae:	6843      	ldr	r3, [r0, #4]
   30eb0:	4620      	mov	r0, r4
   30eb2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   30eb6:	4718      	bx	r3
   30eb8:	f04f 30ff 	mov.w	r0, #4294967295
   30ebc:	bd10      	pop	{r4, pc}
   30ebe:	bf00      	nop

00030ec0 <nrf_sendto>:
   30ec0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   30ec4:	460d      	mov	r5, r1
   30ec6:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   30eca:	4616      	mov	r6, r2
   30ecc:	461f      	mov	r7, r3
   30ece:	4604      	mov	r4, r0
   30ed0:	f7fd fde8 	bl	2eaa4 <bsd_platform_fd_method_table_get>
   30ed4:	b158      	cbz	r0, 30eee <nrf_sendto+0x2e>
   30ed6:	e9cd 8908 	strd	r8, r9, [sp, #32]
   30eda:	f8d0 e008 	ldr.w	lr, [r0, #8]
   30ede:	463b      	mov	r3, r7
   30ee0:	4632      	mov	r2, r6
   30ee2:	4629      	mov	r1, r5
   30ee4:	4620      	mov	r0, r4
   30ee6:	46f4      	mov	ip, lr
   30ee8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   30eec:	4760      	bx	ip
   30eee:	f04f 30ff 	mov.w	r0, #4294967295
   30ef2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   30ef6:	bf00      	nop

00030ef8 <nrf_send>:
   30ef8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   30efc:	b082      	sub	sp, #8
   30efe:	460e      	mov	r6, r1
   30f00:	4617      	mov	r7, r2
   30f02:	4698      	mov	r8, r3
   30f04:	4605      	mov	r5, r0
   30f06:	f7fd fdcd 	bl	2eaa4 <bsd_platform_fd_method_table_get>
   30f0a:	b160      	cbz	r0, 30f26 <nrf_send+0x2e>
   30f0c:	4604      	mov	r4, r0
   30f0e:	2000      	movs	r0, #0
   30f10:	e9cd 0000 	strd	r0, r0, [sp]
   30f14:	4643      	mov	r3, r8
   30f16:	463a      	mov	r2, r7
   30f18:	4631      	mov	r1, r6
   30f1a:	4628      	mov	r0, r5
   30f1c:	68a4      	ldr	r4, [r4, #8]
   30f1e:	47a0      	blx	r4
   30f20:	b002      	add	sp, #8
   30f22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   30f26:	f04f 30ff 	mov.w	r0, #4294967295
   30f2a:	e7f9      	b.n	30f20 <nrf_send+0x28>

00030f2c <nrf_recvfrom>:
   30f2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   30f30:	460d      	mov	r5, r1
   30f32:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   30f36:	4616      	mov	r6, r2
   30f38:	461f      	mov	r7, r3
   30f3a:	4604      	mov	r4, r0
   30f3c:	f7fd fdb2 	bl	2eaa4 <bsd_platform_fd_method_table_get>
   30f40:	b158      	cbz	r0, 30f5a <nrf_recvfrom+0x2e>
   30f42:	e9cd 8908 	strd	r8, r9, [sp, #32]
   30f46:	f8d0 e00c 	ldr.w	lr, [r0, #12]
   30f4a:	463b      	mov	r3, r7
   30f4c:	4632      	mov	r2, r6
   30f4e:	4629      	mov	r1, r5
   30f50:	4620      	mov	r0, r4
   30f52:	46f4      	mov	ip, lr
   30f54:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   30f58:	4760      	bx	ip
   30f5a:	f04f 30ff 	mov.w	r0, #4294967295
   30f5e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   30f62:	bf00      	nop

00030f64 <nrf_recv>:
   30f64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   30f68:	b082      	sub	sp, #8
   30f6a:	460e      	mov	r6, r1
   30f6c:	4617      	mov	r7, r2
   30f6e:	4698      	mov	r8, r3
   30f70:	4605      	mov	r5, r0
   30f72:	f7fd fd97 	bl	2eaa4 <bsd_platform_fd_method_table_get>
   30f76:	b160      	cbz	r0, 30f92 <nrf_recv+0x2e>
   30f78:	4604      	mov	r4, r0
   30f7a:	2000      	movs	r0, #0
   30f7c:	e9cd 0000 	strd	r0, r0, [sp]
   30f80:	4643      	mov	r3, r8
   30f82:	463a      	mov	r2, r7
   30f84:	4631      	mov	r1, r6
   30f86:	4628      	mov	r0, r5
   30f88:	68e4      	ldr	r4, [r4, #12]
   30f8a:	47a0      	blx	r4
   30f8c:	b002      	add	sp, #8
   30f8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   30f92:	f04f 30ff 	mov.w	r0, #4294967295
   30f96:	e7f9      	b.n	30f8c <nrf_recv+0x28>

00030f98 <nrf_connect>:
   30f98:	b570      	push	{r4, r5, r6, lr}
   30f9a:	460d      	mov	r5, r1
   30f9c:	4616      	mov	r6, r2
   30f9e:	4604      	mov	r4, r0
   30fa0:	f7fd fd80 	bl	2eaa4 <bsd_platform_fd_method_table_get>
   30fa4:	b130      	cbz	r0, 30fb4 <nrf_connect+0x1c>
   30fa6:	6943      	ldr	r3, [r0, #20]
   30fa8:	4632      	mov	r2, r6
   30faa:	4629      	mov	r1, r5
   30fac:	4620      	mov	r0, r4
   30fae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   30fb2:	4718      	bx	r3
   30fb4:	f04f 30ff 	mov.w	r0, #4294967295
   30fb8:	bd70      	pop	{r4, r5, r6, pc}
   30fba:	bf00      	nop

00030fbc <nrf_listen>:
   30fbc:	b570      	push	{r4, r5, r6, lr}
   30fbe:	460d      	mov	r5, r1
   30fc0:	4604      	mov	r4, r0
   30fc2:	f7fd fd6f 	bl	2eaa4 <bsd_platform_fd_method_table_get>
   30fc6:	b128      	cbz	r0, 30fd4 <nrf_listen+0x18>
   30fc8:	6983      	ldr	r3, [r0, #24]
   30fca:	4629      	mov	r1, r5
   30fcc:	4620      	mov	r0, r4
   30fce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   30fd2:	4718      	bx	r3
   30fd4:	f04f 30ff 	mov.w	r0, #4294967295
   30fd8:	bd70      	pop	{r4, r5, r6, pc}
   30fda:	bf00      	nop

00030fdc <nrf_accept>:
   30fdc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   30fe0:	460d      	mov	r5, r1
   30fe2:	4616      	mov	r6, r2
   30fe4:	4604      	mov	r4, r0
   30fe6:	f7fd fd5d 	bl	2eaa4 <bsd_platform_fd_method_table_get>
   30fea:	b140      	cbz	r0, 30ffe <nrf_accept+0x22>
   30fec:	69c7      	ldr	r7, [r0, #28]
   30fee:	4632      	mov	r2, r6
   30ff0:	4629      	mov	r1, r5
   30ff2:	4620      	mov	r0, r4
   30ff4:	46bc      	mov	ip, r7
   30ff6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   30ffa:	2300      	movs	r3, #0
   30ffc:	4760      	bx	ip
   30ffe:	f04f 30ff 	mov.w	r0, #4294967295
   31002:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   31006:	bf00      	nop

00031008 <nrf_bind>:
   31008:	b570      	push	{r4, r5, r6, lr}
   3100a:	460d      	mov	r5, r1
   3100c:	4616      	mov	r6, r2
   3100e:	4604      	mov	r4, r0
   31010:	f7fd fd48 	bl	2eaa4 <bsd_platform_fd_method_table_get>
   31014:	b130      	cbz	r0, 31024 <nrf_bind+0x1c>
   31016:	6903      	ldr	r3, [r0, #16]
   31018:	4632      	mov	r2, r6
   3101a:	4629      	mov	r1, r5
   3101c:	4620      	mov	r0, r4
   3101e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   31022:	4718      	bx	r3
   31024:	f04f 30ff 	mov.w	r0, #4294967295
   31028:	bd70      	pop	{r4, r5, r6, pc}
   3102a:	bf00      	nop

0003102c <nrf_setsockopt>:
   3102c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   31030:	f8dd 8018 	ldr.w	r8, [sp, #24]
   31034:	460d      	mov	r5, r1
   31036:	4616      	mov	r6, r2
   31038:	461f      	mov	r7, r3
   3103a:	4604      	mov	r4, r0
   3103c:	f7fd fd32 	bl	2eaa4 <bsd_platform_fd_method_table_get>
   31040:	b158      	cbz	r0, 3105a <nrf_setsockopt+0x2e>
   31042:	f8cd 8018 	str.w	r8, [sp, #24]
   31046:	f8d0 e020 	ldr.w	lr, [r0, #32]
   3104a:	463b      	mov	r3, r7
   3104c:	4632      	mov	r2, r6
   3104e:	4629      	mov	r1, r5
   31050:	4620      	mov	r0, r4
   31052:	46f4      	mov	ip, lr
   31054:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   31058:	4760      	bx	ip
   3105a:	f04f 30ff 	mov.w	r0, #4294967295
   3105e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   31062:	bf00      	nop

00031064 <nrf_getsockopt>:
   31064:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   31068:	f8dd 8018 	ldr.w	r8, [sp, #24]
   3106c:	460d      	mov	r5, r1
   3106e:	4616      	mov	r6, r2
   31070:	461f      	mov	r7, r3
   31072:	4604      	mov	r4, r0
   31074:	f7fd fd16 	bl	2eaa4 <bsd_platform_fd_method_table_get>
   31078:	b158      	cbz	r0, 31092 <nrf_getsockopt+0x2e>
   3107a:	f8cd 8018 	str.w	r8, [sp, #24]
   3107e:	f8d0 e024 	ldr.w	lr, [r0, #36]	; 0x24
   31082:	463b      	mov	r3, r7
   31084:	4632      	mov	r2, r6
   31086:	4629      	mov	r1, r5
   31088:	4620      	mov	r0, r4
   3108a:	46f4      	mov	ip, lr
   3108c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   31090:	4760      	bx	ip
   31092:	f04f 30ff 	mov.w	r0, #4294967295
   31096:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   3109a:	bf00      	nop

0003109c <nrf_getaddrinfo>:
   3109c:	f7fd bd78 	b.w	2eb90 <bsd_platform_getaddrinfo>

000310a0 <nrf_freeaddrinfo>:
   310a0:	f7fd bd78 	b.w	2eb94 <bsd_platform_freeaddrinfo>

000310a4 <nrf_poll>:
   310a4:	f7fd bd78 	b.w	2eb98 <bsd_platform_poll>

000310a8 <nrf_fcntl>:
   310a8:	f7fd bdd0 	b.w	2ec4c <bsd_platform_fcntl>

000310ac <at_client_evt_handler>:
   310ac:	b120      	cbz	r0, 310b8 <at_client_evt_handler+0xc>
   310ae:	f850 1b08 	ldr.w	r1, [r0], #8
   310b2:	0c09      	lsrs	r1, r1, #16
   310b4:	f7fb bf9e 	b.w	2cff4 <rpc_at_event_handler>
   310b8:	4770      	bx	lr
   310ba:	bf00      	nop

000310bc <rpc_at_client_init>:
   310bc:	4801      	ldr	r0, [pc, #4]	; (310c4 <rpc_at_client_init+0x8>)
   310be:	f001 be47 	b.w	32d50 <rpc_client_register>
   310c2:	bf00      	nop
   310c4:	000402a4 	.word	0x000402a4

000310c8 <rpc_at_client_request_alloc>:
   310c8:	b180      	cbz	r0, 310ec <rpc_at_client_request_alloc+0x24>
   310ca:	2300      	movs	r3, #0
   310cc:	b510      	push	{r4, lr}
   310ce:	b082      	sub	sp, #8
   310d0:	aa02      	add	r2, sp, #8
   310d2:	4604      	mov	r4, r0
   310d4:	f842 3d04 	str.w	r3, [r2, #-4]!
   310d8:	2003      	movs	r0, #3
   310da:	f002 f871 	bl	331c0 <rpc_message_alloc>
   310de:	b918      	cbnz	r0, 310e8 <rpc_at_client_request_alloc+0x20>
   310e0:	9b01      	ldr	r3, [sp, #4]
   310e2:	b10b      	cbz	r3, 310e8 <rpc_at_client_request_alloc+0x20>
   310e4:	3308      	adds	r3, #8
   310e6:	6023      	str	r3, [r4, #0]
   310e8:	b002      	add	sp, #8
   310ea:	bd10      	pop	{r4, pc}
   310ec:	200e      	movs	r0, #14
   310ee:	4770      	bx	lr

000310f0 <rpc_at_client_request_send>:
   310f0:	b150      	cbz	r0, 31108 <rpc_at_client_request_send+0x18>
   310f2:	4603      	mov	r3, r0
   310f4:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   310f8:	2003      	movs	r0, #3
   310fa:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   310fe:	f843 1d08 	str.w	r1, [r3, #-8]!
   31102:	4619      	mov	r1, r3
   31104:	f002 b844 	b.w	33190 <rpc_message_send>
   31108:	200e      	movs	r0, #14
   3110a:	4770      	bx	lr

0003110c <rpc_at_client_message_free>:
   3110c:	b120      	cbz	r0, 31118 <rpc_at_client_message_free+0xc>
   3110e:	f1a0 0108 	sub.w	r1, r0, #8
   31112:	2003      	movs	r0, #3
   31114:	f002 b886 	b.w	33224 <rpc_message_free>
   31118:	200e      	movs	r0, #14
   3111a:	4770      	bx	lr

0003111c <rpc_at_client_data_free>:
   3111c:	b118      	cbz	r0, 31126 <rpc_at_client_data_free+0xa>
   3111e:	4601      	mov	r1, r0
   31120:	2003      	movs	r0, #3
   31122:	f002 b991 	b.w	33448 <rpc_message_data_free>
   31126:	200e      	movs	r0, #14
   31128:	4770      	bx	lr
   3112a:	bf00      	nop

0003112c <ip_recvd_packet_free_cb>:
   3112c:	b510      	push	{r4, lr}
   3112e:	4604      	mov	r4, r0
   31130:	6800      	ldr	r0, [r0, #0]
   31132:	f7fc fc1d 	bl	2d970 <rpc_ip_client_data_free>
   31136:	68a0      	ldr	r0, [r4, #8]
   31138:	b118      	cbz	r0, 31142 <ip_recvd_packet_free_cb+0x16>
   3113a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   3113e:	f7fc bbb7 	b.w	2d8b0 <nrf_free>
   31142:	bd10      	pop	{r4, pc}

00031144 <rpc_error_to_nrf_bsd_error>:
   31144:	2810      	cmp	r0, #16
   31146:	bf9a      	itte	ls
   31148:	4b02      	ldrls	r3, [pc, #8]	; (31154 <rpc_error_to_nrf_bsd_error+0x10>)
   3114a:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
   3114e:	202d      	movhi	r0, #45	; 0x2d
   31150:	4770      	bx	lr
   31152:	bf00      	nop
   31154:	000402b4 	.word	0x000402b4

00031158 <ip_interface_request_create>:
   31158:	b570      	push	{r4, r5, r6, lr}
   3115a:	2500      	movs	r5, #0
   3115c:	b082      	sub	sp, #8
   3115e:	ac02      	add	r4, sp, #8
   31160:	f844 5d04 	str.w	r5, [r4, #-4]!
   31164:	4606      	mov	r6, r0
   31166:	460d      	mov	r5, r1
   31168:	4620      	mov	r0, r4
   3116a:	4619      	mov	r1, r3
   3116c:	4614      	mov	r4, r2
   3116e:	f7fc fbcd 	bl	2d90c <rpc_ip_client_request_alloc>
   31172:	b960      	cbnz	r0, 3118e <ip_interface_request_create+0x36>
   31174:	9b01      	ldr	r3, [sp, #4]
   31176:	2208      	movs	r2, #8
   31178:	7258      	strb	r0, [r3, #9]
   3117a:	7298      	strb	r0, [r3, #10]
   3117c:	72d8      	strb	r0, [r3, #11]
   3117e:	4618      	mov	r0, r3
   31180:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
   31184:	60dc      	str	r4, [r3, #12]
   31186:	611d      	str	r5, [r3, #16]
   31188:	721a      	strb	r2, [r3, #8]
   3118a:	b002      	add	sp, #8
   3118c:	bd70      	pop	{r4, r5, r6, pc}
   3118e:	9b01      	ldr	r3, [sp, #4]
   31190:	4618      	mov	r0, r3
   31192:	b002      	add	sp, #8
   31194:	bd70      	pop	{r4, r5, r6, pc}
   31196:	bf00      	nop

00031198 <ip_interface_request_send>:
   31198:	b570      	push	{r4, r5, r6, lr}
   3119a:	460c      	mov	r4, r1
   3119c:	4605      	mov	r5, r0
   3119e:	4611      	mov	r1, r2
   311a0:	4620      	mov	r0, r4
   311a2:	461e      	mov	r6, r3
   311a4:	f7fc fbc6 	bl	2d934 <rpc_ip_client_request_send>
   311a8:	b900      	cbnz	r0, 311ac <ip_interface_request_send+0x14>
   311aa:	bd70      	pop	{r4, r5, r6, pc}
   311ac:	6820      	ldr	r0, [r4, #0]
   311ae:	b108      	cbz	r0, 311b4 <ip_interface_request_send+0x1c>
   311b0:	f7fc fbde 	bl	2d970 <rpc_ip_client_data_free>
   311b4:	4620      	mov	r0, r4
   311b6:	f7fc fbd3 	bl	2d960 <rpc_ip_client_message_free>
   311ba:	602e      	str	r6, [r5, #0]
   311bc:	2023      	movs	r0, #35	; 0x23
   311be:	bd70      	pop	{r4, r5, r6, pc}

000311c0 <ip_interface_wait>:
   311c0:	b538      	push	{r3, r4, r5, lr}
   311c2:	4605      	mov	r5, r0
   311c4:	f001 fc14 	bl	329f0 <interface_socket_wait>
   311c8:	4604      	mov	r4, r0
   311ca:	b108      	cbz	r0, 311d0 <ip_interface_wait+0x10>
   311cc:	4620      	mov	r0, r4
   311ce:	bd38      	pop	{r3, r4, r5, pc}
   311d0:	4628      	mov	r0, r5
   311d2:	f001 fc81 	bl	32ad8 <interface_socket_from_handle_get>
   311d6:	2800      	cmp	r0, #0
   311d8:	d0f8      	beq.n	311cc <ip_interface_wait+0xc>
   311da:	6844      	ldr	r4, [r0, #4]
   311dc:	2c00      	cmp	r4, #0
   311de:	d0f5      	beq.n	311cc <ip_interface_wait+0xc>
   311e0:	2300      	movs	r3, #0
   311e2:	6043      	str	r3, [r0, #4]
   311e4:	4620      	mov	r0, r4
   311e6:	bd38      	pop	{r3, r4, r5, pc}

000311e8 <ip_interface_init>:
   311e8:	b538      	push	{r3, r4, r5, lr}
   311ea:	2300      	movs	r3, #0
   311ec:	4d07      	ldr	r5, [pc, #28]	; (3120c <ip_interface_init+0x24>)
   311ee:	4c08      	ldr	r4, [pc, #32]	; (31210 <ip_interface_init+0x28>)
   311f0:	4619      	mov	r1, r3
   311f2:	2224      	movs	r2, #36	; 0x24
   311f4:	4807      	ldr	r0, [pc, #28]	; (31214 <ip_interface_init+0x2c>)
   311f6:	602b      	str	r3, [r5, #0]
   311f8:	6023      	str	r3, [r4, #0]
   311fa:	f00d fb47 	bl	3e88c <memset>
   311fe:	f7fc fb7f 	bl	2d900 <rpc_ip_client_init>
   31202:	3000      	adds	r0, #0
   31204:	bf18      	it	ne
   31206:	2001      	movne	r0, #1
   31208:	4240      	negs	r0, r0
   3120a:	bd38      	pop	{r3, r4, r5, pc}
   3120c:	2002532c 	.word	0x2002532c
   31210:	20025328 	.word	0x20025328
   31214:	20025334 	.word	0x20025334

00031218 <ip_interface_open>:
   31218:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3121c:	4606      	mov	r6, r0
   3121e:	2000      	movs	r0, #0
   31220:	f026 0308 	bic.w	r3, r6, #8
   31224:	b082      	sub	sp, #8
   31226:	2b02      	cmp	r3, #2
   31228:	460c      	mov	r4, r1
   3122a:	4617      	mov	r7, r2
   3122c:	9000      	str	r0, [sp, #0]
   3122e:	d002      	beq.n	31236 <ip_interface_open+0x1e>
   31230:	2e05      	cmp	r6, #5
   31232:	f040 8085 	bne.w	31340 <ip_interface_open+0x128>
   31236:	1e63      	subs	r3, r4, #1
   31238:	2b02      	cmp	r3, #2
   3123a:	f200 8097 	bhi.w	3136c <ip_interface_open+0x154>
   3123e:	2f00      	cmp	r7, #0
   31240:	d154      	bne.n	312ec <ip_interface_open+0xd4>
   31242:	2c01      	cmp	r4, #1
   31244:	d067      	beq.n	31316 <ip_interface_open+0xfe>
   31246:	2c03      	cmp	r4, #3
   31248:	bf18      	it	ne
   3124a:	2702      	movne	r7, #2
   3124c:	4a4a      	ldr	r2, [pc, #296]	; (31378 <ip_interface_open+0x160>)
   3124e:	4621      	mov	r1, r4
   31250:	4668      	mov	r0, sp
   31252:	f001 fb1b 	bl	3288c <interface_socket_allocate>
   31256:	9b00      	ldr	r3, [sp, #0]
   31258:	4680      	mov	r8, r0
   3125a:	2b00      	cmp	r3, #0
   3125c:	d059      	beq.n	31312 <ip_interface_open+0xfa>
   3125e:	2100      	movs	r1, #0
   31260:	a802      	add	r0, sp, #8
   31262:	f840 1d04 	str.w	r1, [r0, #-4]!
   31266:	e9c3 6403 	strd	r6, r4, [r3, #12]
   3126a:	615f      	str	r7, [r3, #20]
   3126c:	f7fc fb4e 	bl	2d90c <rpc_ip_client_request_alloc>
   31270:	2800      	cmp	r0, #0
   31272:	d14b      	bne.n	3130c <ip_interface_open+0xf4>
   31274:	f247 0201 	movw	r2, #28673	; 0x7001
   31278:	f04f 33ff 	mov.w	r3, #4294967295
   3127c:	2108      	movs	r1, #8
   3127e:	9d01      	ldr	r5, [sp, #4]
   31280:	ea42 4208 	orr.w	r2, r2, r8, lsl #16
   31284:	60ea      	str	r2, [r5, #12]
   31286:	7268      	strb	r0, [r5, #9]
   31288:	72a8      	strb	r0, [r5, #10]
   3128a:	72e8      	strb	r0, [r5, #11]
   3128c:	7229      	strb	r1, [r5, #8]
   3128e:	742b      	strb	r3, [r5, #16]
   31290:	746b      	strb	r3, [r5, #17]
   31292:	74ab      	strb	r3, [r5, #18]
   31294:	74eb      	strb	r3, [r5, #19]
   31296:	68ab      	ldr	r3, [r5, #8]
   31298:	2e05      	cmp	r6, #5
   3129a:	f103 030c 	add.w	r3, r3, #12
   3129e:	60ab      	str	r3, [r5, #8]
   312a0:	d003      	beq.n	312aa <ip_interface_open+0x92>
   312a2:	2e0a      	cmp	r6, #10
   312a4:	bf14      	ite	ne
   312a6:	2601      	movne	r6, #1
   312a8:	2602      	moveq	r6, #2
   312aa:	616e      	str	r6, [r5, #20]
   312ac:	61ef      	str	r7, [r5, #28]
   312ae:	61ac      	str	r4, [r5, #24]
   312b0:	f247 0101 	movw	r1, #28673	; 0x7001
   312b4:	4628      	mov	r0, r5
   312b6:	9f00      	ldr	r7, [sp, #0]
   312b8:	f7fc fb3c 	bl	2d934 <rpc_ip_client_request_send>
   312bc:	4606      	mov	r6, r0
   312be:	b360      	cbz	r0, 3131a <ip_interface_open+0x102>
   312c0:	6828      	ldr	r0, [r5, #0]
   312c2:	b108      	cbz	r0, 312c8 <ip_interface_open+0xb0>
   312c4:	f7fc fb54 	bl	2d970 <rpc_ip_client_data_free>
   312c8:	4628      	mov	r0, r5
   312ca:	f7fc fb49 	bl	2d960 <rpc_ip_client_message_free>
   312ce:	2301      	movs	r3, #1
   312d0:	2523      	movs	r5, #35	; 0x23
   312d2:	603b      	str	r3, [r7, #0]
   312d4:	4640      	mov	r0, r8
   312d6:	f001 fb3d 	bl	32954 <interface_socket_free>
   312da:	4628      	mov	r0, r5
   312dc:	f7f9 fc72 	bl	2abc4 <bsd_os_errno_set>
   312e0:	f04f 38ff 	mov.w	r8, #4294967295
   312e4:	4640      	mov	r0, r8
   312e6:	b002      	add	sp, #8
   312e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   312ec:	2c01      	cmp	r4, #1
   312ee:	d009      	beq.n	31304 <ip_interface_open+0xec>
   312f0:	2c02      	cmp	r4, #2
   312f2:	d109      	bne.n	31308 <ip_interface_open+0xf0>
   312f4:	2f02      	cmp	r7, #2
   312f6:	d0a9      	beq.n	3124c <ip_interface_open+0x34>
   312f8:	2029      	movs	r0, #41	; 0x29
   312fa:	f7f9 fc63 	bl	2abc4 <bsd_os_errno_set>
   312fe:	f04f 38ff 	mov.w	r8, #4294967295
   31302:	e7ef      	b.n	312e4 <ip_interface_open+0xcc>
   31304:	2f01      	cmp	r7, #1
   31306:	d1f7      	bne.n	312f8 <ip_interface_open+0xe0>
   31308:	2702      	movs	r7, #2
   3130a:	e79f      	b.n	3124c <ip_interface_open+0x34>
   3130c:	9d01      	ldr	r5, [sp, #4]
   3130e:	2d00      	cmp	r5, #0
   31310:	d1c1      	bne.n	31296 <ip_interface_open+0x7e>
   31312:	250c      	movs	r5, #12
   31314:	e7de      	b.n	312d4 <ip_interface_open+0xbc>
   31316:	4627      	mov	r7, r4
   31318:	e798      	b.n	3124c <ip_interface_open+0x34>
   3131a:	f04f 33ff 	mov.w	r3, #4294967295
   3131e:	f64f 72ff 	movw	r2, #65535	; 0xffff
   31322:	2102      	movs	r1, #2
   31324:	4640      	mov	r0, r8
   31326:	f001 fb63 	bl	329f0 <interface_socket_wait>
   3132a:	4605      	mov	r5, r0
   3132c:	2800      	cmp	r0, #0
   3132e:	d1d1      	bne.n	312d4 <ip_interface_open+0xbc>
   31330:	4640      	mov	r0, r8
   31332:	f001 fbd1 	bl	32ad8 <interface_socket_from_handle_get>
   31336:	b148      	cbz	r0, 3134c <ip_interface_open+0x134>
   31338:	6845      	ldr	r5, [r0, #4]
   3133a:	b13d      	cbz	r5, 3134c <ip_interface_open+0x134>
   3133c:	6046      	str	r6, [r0, #4]
   3133e:	e7c9      	b.n	312d4 <ip_interface_open+0xbc>
   31340:	202f      	movs	r0, #47	; 0x2f
   31342:	f7f9 fc3f 	bl	2abc4 <bsd_os_errno_set>
   31346:	f04f 38ff 	mov.w	r8, #4294967295
   3134a:	e7cb      	b.n	312e4 <ip_interface_open+0xcc>
   3134c:	3c02      	subs	r4, #2
   3134e:	2c01      	cmp	r4, #1
   31350:	d8c8      	bhi.n	312e4 <ip_interface_open+0xcc>
   31352:	4640      	mov	r0, r8
   31354:	9b00      	ldr	r3, [sp, #0]
   31356:	681a      	ldr	r2, [r3, #0]
   31358:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   3135c:	601a      	str	r2, [r3, #0]
   3135e:	681a      	ldr	r2, [r3, #0]
   31360:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
   31364:	601a      	str	r2, [r3, #0]
   31366:	b002      	add	sp, #8
   31368:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   3136c:	2016      	movs	r0, #22
   3136e:	f7f9 fc29 	bl	2abc4 <bsd_os_errno_set>
   31372:	f04f 38ff 	mov.w	r8, #4294967295
   31376:	e7b5      	b.n	312e4 <ip_interface_open+0xcc>
   31378:	0003112d 	.word	0x0003112d

0003137c <ip_interface_close>:
   3137c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   31380:	b082      	sub	sp, #8
   31382:	4606      	mov	r6, r0
   31384:	f001 fba8 	bl	32ad8 <interface_socket_from_handle_get>
   31388:	2800      	cmp	r0, #0
   3138a:	d063      	beq.n	31454 <ip_interface_close+0xd8>
   3138c:	4604      	mov	r4, r0
   3138e:	2100      	movs	r1, #0
   31390:	a802      	add	r0, sp, #8
   31392:	6827      	ldr	r7, [r4, #0]
   31394:	f840 1d04 	str.w	r1, [r0, #-4]!
   31398:	f8d4 8018 	ldr.w	r8, [r4, #24]
   3139c:	f7fc fab6 	bl	2d90c <rpc_ip_client_request_alloc>
   313a0:	2800      	cmp	r0, #0
   313a2:	d13a      	bne.n	3141a <ip_interface_close+0x9e>
   313a4:	f247 0309 	movw	r3, #28681	; 0x7009
   313a8:	2208      	movs	r2, #8
   313aa:	9d01      	ldr	r5, [sp, #4]
   313ac:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   313b0:	60eb      	str	r3, [r5, #12]
   313b2:	f8c5 8010 	str.w	r8, [r5, #16]
   313b6:	7268      	strb	r0, [r5, #9]
   313b8:	72a8      	strb	r0, [r5, #10]
   313ba:	72e8      	strb	r0, [r5, #11]
   313bc:	722a      	strb	r2, [r5, #8]
   313be:	6823      	ldr	r3, [r4, #0]
   313c0:	f247 0109 	movw	r1, #28681	; 0x7009
   313c4:	0c1b      	lsrs	r3, r3, #16
   313c6:	041b      	lsls	r3, r3, #16
   313c8:	f043 030d 	orr.w	r3, r3, #13
   313cc:	6023      	str	r3, [r4, #0]
   313ce:	6823      	ldr	r3, [r4, #0]
   313d0:	4628      	mov	r0, r5
   313d2:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   313d6:	6023      	str	r3, [r4, #0]
   313d8:	6823      	ldr	r3, [r4, #0]
   313da:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   313de:	6023      	str	r3, [r4, #0]
   313e0:	f7fc faa8 	bl	2d934 <rpc_ip_client_request_send>
   313e4:	bb40      	cbnz	r0, 31438 <ip_interface_close+0xbc>
   313e6:	f04f 33ff 	mov.w	r3, #4294967295
   313ea:	f64f 72ff 	movw	r2, #65535	; 0xffff
   313ee:	210e      	movs	r1, #14
   313f0:	4630      	mov	r0, r6
   313f2:	f001 fafd 	bl	329f0 <interface_socket_wait>
   313f6:	4604      	mov	r4, r0
   313f8:	b1a0      	cbz	r0, 31424 <ip_interface_close+0xa8>
   313fa:	4c17      	ldr	r4, [pc, #92]	; (31458 <ip_interface_close+0xdc>)
   313fc:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
   31400:	b120      	cbz	r0, 3140c <ip_interface_close+0x90>
   31402:	f7fc faad 	bl	2d960 <rpc_ip_client_message_free>
   31406:	2300      	movs	r3, #0
   31408:	f844 3026 	str.w	r3, [r4, r6, lsl #2]
   3140c:	4630      	mov	r0, r6
   3140e:	f001 faa1 	bl	32954 <interface_socket_free>
   31412:	2000      	movs	r0, #0
   31414:	b002      	add	sp, #8
   31416:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   3141a:	9d01      	ldr	r5, [sp, #4]
   3141c:	200c      	movs	r0, #12
   3141e:	2d00      	cmp	r5, #0
   31420:	d1cd      	bne.n	313be <ip_interface_close+0x42>
   31422:	e012      	b.n	3144a <ip_interface_close+0xce>
   31424:	4630      	mov	r0, r6
   31426:	f001 fb57 	bl	32ad8 <interface_socket_from_handle_get>
   3142a:	2800      	cmp	r0, #0
   3142c:	d0e5      	beq.n	313fa <ip_interface_close+0x7e>
   3142e:	6843      	ldr	r3, [r0, #4]
   31430:	2b00      	cmp	r3, #0
   31432:	d0e2      	beq.n	313fa <ip_interface_close+0x7e>
   31434:	6044      	str	r4, [r0, #4]
   31436:	e7e0      	b.n	313fa <ip_interface_close+0x7e>
   31438:	6828      	ldr	r0, [r5, #0]
   3143a:	b108      	cbz	r0, 31440 <ip_interface_close+0xc4>
   3143c:	f7fc fa98 	bl	2d970 <rpc_ip_client_data_free>
   31440:	4628      	mov	r0, r5
   31442:	f7fc fa8d 	bl	2d960 <rpc_ip_client_message_free>
   31446:	2023      	movs	r0, #35	; 0x23
   31448:	6027      	str	r7, [r4, #0]
   3144a:	f7f9 fbbb 	bl	2abc4 <bsd_os_errno_set>
   3144e:	f04f 30ff 	mov.w	r0, #4294967295
   31452:	e7df      	b.n	31414 <ip_interface_close+0x98>
   31454:	2009      	movs	r0, #9
   31456:	e7f8      	b.n	3144a <ip_interface_close+0xce>
   31458:	20025334 	.word	0x20025334

0003145c <ip_interface_sendto>:
   3145c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   31460:	2400      	movs	r4, #0
   31462:	b089      	sub	sp, #36	; 0x24
   31464:	9102      	str	r1, [sp, #8]
   31466:	4615      	mov	r5, r2
   31468:	4699      	mov	r9, r3
   3146a:	9407      	str	r4, [sp, #28]
   3146c:	4607      	mov	r7, r0
   3146e:	9e12      	ldr	r6, [sp, #72]	; 0x48
   31470:	f001 fb32 	bl	32ad8 <interface_socket_from_handle_get>
   31474:	2800      	cmp	r0, #0
   31476:	f000 815f 	beq.w	31738 <ip_interface_sendto+0x2dc>
   3147a:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
   3147e:	f300 814c 	bgt.w	3171a <ip_interface_sendto+0x2be>
   31482:	6903      	ldr	r3, [r0, #16]
   31484:	4604      	mov	r4, r0
   31486:	2b01      	cmp	r3, #1
   31488:	f000 80fb 	beq.w	31682 <ip_interface_sendto+0x226>
   3148c:	6822      	ldr	r2, [r4, #0]
   3148e:	0390      	lsls	r0, r2, #14
   31490:	d562      	bpl.n	31558 <ip_interface_sendto+0xfc>
   31492:	f1b9 0f00 	cmp.w	r9, #0
   31496:	f000 80fc 	beq.w	31692 <ip_interface_sendto+0x236>
   3149a:	f019 0f02 	tst.w	r9, #2
   3149e:	f000 8146 	beq.w	3172e <ip_interface_sendto+0x2d2>
   314a2:	2300      	movs	r3, #0
   314a4:	9303      	str	r3, [sp, #12]
   314a6:	f247 0806 	movw	r8, #28678	; 0x7006
   314aa:	f04f 0b0c 	mov.w	fp, #12
   314ae:	4ba6      	ldr	r3, [pc, #664]	; (31748 <ip_interface_sendto+0x2ec>)
   314b0:	9300      	str	r3, [sp, #0]
   314b2:	043b      	lsls	r3, r7, #16
   314b4:	9304      	str	r3, [sp, #16]
   314b6:	4629      	mov	r1, r5
   314b8:	a807      	add	r0, sp, #28
   314ba:	f7fc fa27 	bl	2d90c <rpc_ip_client_request_alloc>
   314be:	2804      	cmp	r0, #4
   314c0:	d063      	beq.n	3158a <ip_interface_sendto+0x12e>
   314c2:	2800      	cmp	r0, #0
   314c4:	f040 813d 	bne.w	31742 <ip_interface_sendto+0x2e6>
   314c8:	9b07      	ldr	r3, [sp, #28]
   314ca:	f883 b008 	strb.w	fp, [r3, #8]
   314ce:	7258      	strb	r0, [r3, #9]
   314d0:	7298      	strb	r0, [r3, #10]
   314d2:	72d8      	strb	r0, [r3, #11]
   314d4:	2e00      	cmp	r6, #0
   314d6:	d074      	beq.n	315c2 <ip_interface_sendto+0x166>
   314d8:	68e2      	ldr	r2, [r4, #12]
   314da:	6871      	ldr	r1, [r6, #4]
   314dc:	428a      	cmp	r2, r1
   314de:	f040 80a2 	bne.w	31626 <ip_interface_sendto+0x1ca>
   314e2:	7831      	ldrb	r1, [r6, #0]
   314e4:	9813      	ldr	r0, [sp, #76]	; 0x4c
   314e6:	4288      	cmp	r0, r1
   314e8:	d10a      	bne.n	31500 <ip_interface_sendto+0xa4>
   314ea:	2a02      	cmp	r2, #2
   314ec:	f103 001c 	add.w	r0, r3, #28
   314f0:	f000 8101 	beq.w	316f6 <ip_interface_sendto+0x29a>
   314f4:	2a0a      	cmp	r2, #10
   314f6:	d103      	bne.n	31500 <ip_interface_sendto+0xa4>
   314f8:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   314fa:	2a24      	cmp	r2, #36	; 0x24
   314fc:	f000 80e8 	beq.w	316d0 <ip_interface_sendto+0x274>
   31500:	f04f 0a16 	mov.w	sl, #22
   31504:	6818      	ldr	r0, [r3, #0]
   31506:	b110      	cbz	r0, 3150e <ip_interface_sendto+0xb2>
   31508:	f7fc fa32 	bl	2d970 <rpc_ip_client_data_free>
   3150c:	9b07      	ldr	r3, [sp, #28]
   3150e:	4618      	mov	r0, r3
   31510:	f7fc fa26 	bl	2d960 <rpc_ip_client_message_free>
   31514:	6823      	ldr	r3, [r4, #0]
   31516:	031a      	lsls	r2, r3, #12
   31518:	d43f      	bmi.n	3159a <ip_interface_sendto+0x13e>
   3151a:	6823      	ldr	r3, [r4, #0]
   3151c:	b29b      	uxth	r3, r3
   3151e:	2b0d      	cmp	r3, #13
   31520:	d007      	beq.n	31532 <ip_interface_sendto+0xd6>
   31522:	6823      	ldr	r3, [r4, #0]
   31524:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   31528:	6023      	str	r3, [r4, #0]
   3152a:	6823      	ldr	r3, [r4, #0]
   3152c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   31530:	6023      	str	r3, [r4, #0]
   31532:	f1ba 0f00 	cmp.w	sl, #0
   31536:	d130      	bne.n	3159a <ip_interface_sendto+0x13e>
   31538:	6823      	ldr	r3, [r4, #0]
   3153a:	0118      	lsls	r0, r3, #4
   3153c:	d576      	bpl.n	3162c <ip_interface_sendto+0x1d0>
   3153e:	6823      	ldr	r3, [r4, #0]
   31540:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
   31544:	6023      	str	r3, [r4, #0]
   31546:	9b00      	ldr	r3, [sp, #0]
   31548:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   3154c:	2800      	cmp	r0, #0
   3154e:	d12e      	bne.n	315ae <ip_interface_sendto+0x152>
   31550:	4628      	mov	r0, r5
   31552:	b009      	add	sp, #36	; 0x24
   31554:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   31558:	6822      	ldr	r2, [r4, #0]
   3155a:	0091      	lsls	r1, r2, #2
   3155c:	d406      	bmi.n	3156c <ip_interface_sendto+0x110>
   3155e:	2b01      	cmp	r3, #1
   31560:	f000 80b0 	beq.w	316c4 <ip_interface_sendto+0x268>
   31564:	6823      	ldr	r3, [r4, #0]
   31566:	031a      	lsls	r2, r3, #12
   31568:	f140 80d2 	bpl.w	31710 <ip_interface_sendto+0x2b4>
   3156c:	6823      	ldr	r3, [r4, #0]
   3156e:	031b      	lsls	r3, r3, #12
   31570:	f140 80d8 	bpl.w	31724 <ip_interface_sendto+0x2c8>
   31574:	4b74      	ldr	r3, [pc, #464]	; (31748 <ip_interface_sendto+0x2ec>)
   31576:	f8d4 a008 	ldr.w	sl, [r4, #8]
   3157a:	9300      	str	r3, [sp, #0]
   3157c:	e7d9      	b.n	31532 <ip_interface_sendto+0xd6>
   3157e:	9b00      	ldr	r3, [sp, #0]
   31580:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   31584:	b108      	cbz	r0, 3158a <ip_interface_sendto+0x12e>
   31586:	f7fc f9eb 	bl	2d960 <rpc_ip_client_message_free>
   3158a:	9b03      	ldr	r3, [sp, #12]
   3158c:	2b00      	cmp	r3, #0
   3158e:	d192      	bne.n	314b6 <ip_interface_sendto+0x5a>
   31590:	6823      	ldr	r3, [r4, #0]
   31592:	f04f 0a23 	mov.w	sl, #35	; 0x23
   31596:	031a      	lsls	r2, r3, #12
   31598:	d5bf      	bpl.n	3151a <ip_interface_sendto+0xbe>
   3159a:	4650      	mov	r0, sl
   3159c:	f7f9 fb12 	bl	2abc4 <bsd_os_errno_set>
   315a0:	9b00      	ldr	r3, [sp, #0]
   315a2:	f04f 35ff 	mov.w	r5, #4294967295
   315a6:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   315aa:	2800      	cmp	r0, #0
   315ac:	d0d0      	beq.n	31550 <ip_interface_sendto+0xf4>
   315ae:	f7fc f9d7 	bl	2d960 <rpc_ip_client_message_free>
   315b2:	2300      	movs	r3, #0
   315b4:	9a00      	ldr	r2, [sp, #0]
   315b6:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
   315ba:	4628      	mov	r0, r5
   315bc:	b009      	add	sp, #36	; 0x24
   315be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   315c2:	4642      	mov	r2, r8
   315c4:	f8c3 9014 	str.w	r9, [r3, #20]
   315c8:	69a1      	ldr	r1, [r4, #24]
   315ca:	9804      	ldr	r0, [sp, #16]
   315cc:	6119      	str	r1, [r3, #16]
   315ce:	9902      	ldr	r1, [sp, #8]
   315d0:	4302      	orrs	r2, r0
   315d2:	60da      	str	r2, [r3, #12]
   315d4:	605d      	str	r5, [r3, #4]
   315d6:	b119      	cbz	r1, 315e0 <ip_interface_sendto+0x184>
   315d8:	6818      	ldr	r0, [r3, #0]
   315da:	462a      	mov	r2, r5
   315dc:	f00d f936 	bl	3e84c <memcpy>
   315e0:	6823      	ldr	r3, [r4, #0]
   315e2:	4641      	mov	r1, r8
   315e4:	9305      	str	r3, [sp, #20]
   315e6:	6823      	ldr	r3, [r4, #0]
   315e8:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   315ec:	6023      	str	r3, [r4, #0]
   315ee:	6823      	ldr	r3, [r4, #0]
   315f0:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
   315f4:	6023      	str	r3, [r4, #0]
   315f6:	9b07      	ldr	r3, [sp, #28]
   315f8:	4618      	mov	r0, r3
   315fa:	9301      	str	r3, [sp, #4]
   315fc:	f7fc f99a 	bl	2d934 <rpc_ip_client_request_send>
   31600:	9b01      	ldr	r3, [sp, #4]
   31602:	4682      	mov	sl, r0
   31604:	b9e8      	cbnz	r0, 31642 <ip_interface_sendto+0x1e6>
   31606:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   3160a:	f04f 33ff 	mov.w	r3, #4294967295
   3160e:	4611      	mov	r1, r2
   31610:	4638      	mov	r0, r7
   31612:	f001 f9ed 	bl	329f0 <interface_socket_wait>
   31616:	b308      	cbz	r0, 3165c <ip_interface_sendto+0x200>
   31618:	6823      	ldr	r3, [r4, #0]
   3161a:	0319      	lsls	r1, r3, #12
   3161c:	d42a      	bmi.n	31674 <ip_interface_sendto+0x218>
   3161e:	280c      	cmp	r0, #12
   31620:	d0ad      	beq.n	3157e <ip_interface_sendto+0x122>
   31622:	4682      	mov	sl, r0
   31624:	e776      	b.n	31514 <ip_interface_sendto+0xb8>
   31626:	f04f 0a2f 	mov.w	sl, #47	; 0x2f
   3162a:	e76b      	b.n	31504 <ip_interface_sendto+0xa8>
   3162c:	9b00      	ldr	r3, [sp, #0]
   3162e:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   31632:	6985      	ldr	r5, [r0, #24]
   31634:	f7fc f994 	bl	2d960 <rpc_ip_client_message_free>
   31638:	2300      	movs	r3, #0
   3163a:	9a00      	ldr	r2, [sp, #0]
   3163c:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
   31640:	e7bb      	b.n	315ba <ip_interface_sendto+0x15e>
   31642:	6818      	ldr	r0, [r3, #0]
   31644:	469a      	mov	sl, r3
   31646:	b108      	cbz	r0, 3164c <ip_interface_sendto+0x1f0>
   31648:	f7fc f992 	bl	2d970 <rpc_ip_client_data_free>
   3164c:	4650      	mov	r0, sl
   3164e:	f7fc f987 	bl	2d960 <rpc_ip_client_message_free>
   31652:	9b05      	ldr	r3, [sp, #20]
   31654:	f04f 0a23 	mov.w	sl, #35	; 0x23
   31658:	6023      	str	r3, [r4, #0]
   3165a:	e75b      	b.n	31514 <ip_interface_sendto+0xb8>
   3165c:	4638      	mov	r0, r7
   3165e:	f001 fa3b 	bl	32ad8 <interface_socket_from_handle_get>
   31662:	4603      	mov	r3, r0
   31664:	b1e0      	cbz	r0, 316a0 <ip_interface_sendto+0x244>
   31666:	6840      	ldr	r0, [r0, #4]
   31668:	b1d0      	cbz	r0, 316a0 <ip_interface_sendto+0x244>
   3166a:	f8c3 a004 	str.w	sl, [r3, #4]
   3166e:	6823      	ldr	r3, [r4, #0]
   31670:	0319      	lsls	r1, r3, #12
   31672:	d5d4      	bpl.n	3161e <ip_interface_sendto+0x1c2>
   31674:	f8d4 a008 	ldr.w	sl, [r4, #8]
   31678:	6823      	ldr	r3, [r4, #0]
   3167a:	031e      	lsls	r6, r3, #12
   3167c:	f57f af4d 	bpl.w	3151a <ip_interface_sendto+0xbe>
   31680:	e757      	b.n	31532 <ip_interface_sendto+0xd6>
   31682:	2e00      	cmp	r6, #0
   31684:	f43f af02 	beq.w	3148c <ip_interface_sendto+0x30>
   31688:	4b2f      	ldr	r3, [pc, #188]	; (31748 <ip_interface_sendto+0x2ec>)
   3168a:	f04f 0a38 	mov.w	sl, #56	; 0x38
   3168e:	9300      	str	r3, [sp, #0]
   31690:	e783      	b.n	3159a <ip_interface_sendto+0x13e>
   31692:	6823      	ldr	r3, [r4, #0]
   31694:	f083 5380 	eor.w	r3, r3, #268435456	; 0x10000000
   31698:	f3c3 7300 	ubfx	r3, r3, #28, #1
   3169c:	9303      	str	r3, [sp, #12]
   3169e:	e702      	b.n	314a6 <ip_interface_sendto+0x4a>
   316a0:	6823      	ldr	r3, [r4, #0]
   316a2:	031b      	lsls	r3, r3, #12
   316a4:	f53f af48 	bmi.w	31538 <ip_interface_sendto+0xdc>
   316a8:	6823      	ldr	r3, [r4, #0]
   316aa:	b29b      	uxth	r3, r3
   316ac:	2b0d      	cmp	r3, #13
   316ae:	f43f af43 	beq.w	31538 <ip_interface_sendto+0xdc>
   316b2:	6823      	ldr	r3, [r4, #0]
   316b4:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   316b8:	6023      	str	r3, [r4, #0]
   316ba:	6823      	ldr	r3, [r4, #0]
   316bc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   316c0:	6023      	str	r3, [r4, #0]
   316c2:	e739      	b.n	31538 <ip_interface_sendto+0xdc>
   316c4:	6823      	ldr	r3, [r4, #0]
   316c6:	b29b      	uxth	r3, r3
   316c8:	2b05      	cmp	r3, #5
   316ca:	f47f af4f 	bne.w	3156c <ip_interface_sendto+0x110>
   316ce:	e749      	b.n	31564 <ip_interface_sendto+0x108>
   316d0:	2210      	movs	r2, #16
   316d2:	8931      	ldrh	r1, [r6, #8]
   316d4:	835a      	strh	r2, [r3, #26]
   316d6:	8319      	strh	r1, [r3, #24]
   316d8:	18b1      	adds	r1, r6, r2
   316da:	f00d f8b7 	bl	3e84c <memcpy>
   316de:	f247 0207 	movw	r2, #28679	; 0x7007
   316e2:	9b07      	ldr	r3, [sp, #28]
   316e4:	4690      	mov	r8, r2
   316e6:	6899      	ldr	r1, [r3, #8]
   316e8:	8b58      	ldrh	r0, [r3, #26]
   316ea:	3104      	adds	r1, #4
   316ec:	4401      	add	r1, r0
   316ee:	f8c3 9014 	str.w	r9, [r3, #20]
   316f2:	6099      	str	r1, [r3, #8]
   316f4:	e768      	b.n	315c8 <ip_interface_sendto+0x16c>
   316f6:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   316f8:	2a10      	cmp	r2, #16
   316fa:	f47f af01 	bne.w	31500 <ip_interface_sendto+0xa4>
   316fe:	2204      	movs	r2, #4
   31700:	8931      	ldrh	r1, [r6, #8]
   31702:	835a      	strh	r2, [r3, #26]
   31704:	8319      	strh	r1, [r3, #24]
   31706:	f106 010c 	add.w	r1, r6, #12
   3170a:	f00d f89f 	bl	3e84c <memcpy>
   3170e:	e7e6      	b.n	316de <ip_interface_sendto+0x282>
   31710:	4b0d      	ldr	r3, [pc, #52]	; (31748 <ip_interface_sendto+0x2ec>)
   31712:	f04f 0a23 	mov.w	sl, #35	; 0x23
   31716:	9300      	str	r3, [sp, #0]
   31718:	e73f      	b.n	3159a <ip_interface_sendto+0x13e>
   3171a:	4b0b      	ldr	r3, [pc, #44]	; (31748 <ip_interface_sendto+0x2ec>)
   3171c:	f04f 0a28 	mov.w	sl, #40	; 0x28
   31720:	9300      	str	r3, [sp, #0]
   31722:	e73a      	b.n	3159a <ip_interface_sendto+0x13e>
   31724:	4b08      	ldr	r3, [pc, #32]	; (31748 <ip_interface_sendto+0x2ec>)
   31726:	f04f 0a39 	mov.w	sl, #57	; 0x39
   3172a:	9300      	str	r3, [sp, #0]
   3172c:	e735      	b.n	3159a <ip_interface_sendto+0x13e>
   3172e:	4b06      	ldr	r3, [pc, #24]	; (31748 <ip_interface_sendto+0x2ec>)
   31730:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
   31734:	9300      	str	r3, [sp, #0]
   31736:	e730      	b.n	3159a <ip_interface_sendto+0x13e>
   31738:	4b03      	ldr	r3, [pc, #12]	; (31748 <ip_interface_sendto+0x2ec>)
   3173a:	f04f 0a09 	mov.w	sl, #9
   3173e:	9300      	str	r3, [sp, #0]
   31740:	e72b      	b.n	3159a <ip_interface_sendto+0x13e>
   31742:	f04f 0a0c 	mov.w	sl, #12
   31746:	e6e5      	b.n	31514 <ip_interface_sendto+0xb8>
   31748:	20025334 	.word	0x20025334

0003174c <ip_interface_recvfrom>:
   3174c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   31750:	b085      	sub	sp, #20
   31752:	2a00      	cmp	r2, #0
   31754:	f000 811b 	beq.w	3198e <ip_interface_recvfrom+0x242>
   31758:	4605      	mov	r5, r0
   3175a:	468a      	mov	sl, r1
   3175c:	4698      	mov	r8, r3
   3175e:	4617      	mov	r7, r2
   31760:	b11b      	cbz	r3, 3176a <ip_interface_recvfrom+0x1e>
   31762:	f013 0f1a 	tst.w	r3, #26
   31766:	f000 810f 	beq.w	31988 <ip_interface_recvfrom+0x23c>
   3176a:	4628      	mov	r0, r5
   3176c:	f001 f9b4 	bl	32ad8 <interface_socket_from_handle_get>
   31770:	4604      	mov	r4, r0
   31772:	2800      	cmp	r0, #0
   31774:	f000 810e 	beq.w	31994 <ip_interface_recvfrom+0x248>
   31778:	6803      	ldr	r3, [r0, #0]
   3177a:	02d9      	lsls	r1, r3, #11
   3177c:	d564      	bpl.n	31848 <ip_interface_recvfrom+0xfc>
   3177e:	f018 0f02 	tst.w	r8, #2
   31782:	bf18      	it	ne
   31784:	f04f 0900 	movne.w	r9, #0
   31788:	f04f 3bff 	mov.w	fp, #4294967295
   3178c:	bf08      	it	eq
   3178e:	6803      	ldreq	r3, [r0, #0]
   31790:	f008 0610 	and.w	r6, r8, #16
   31794:	bf04      	itt	eq
   31796:	f083 5980 	eoreq.w	r9, r3, #268435456	; 0x10000000
   3179a:	f3c9 7900 	ubfxeq	r9, r9, #28, #1
   3179e:	6823      	ldr	r3, [r4, #0]
   317a0:	03da      	lsls	r2, r3, #15
   317a2:	d56c      	bpl.n	3187e <ip_interface_recvfrom+0x132>
   317a4:	6823      	ldr	r3, [r4, #0]
   317a6:	69e0      	ldr	r0, [r4, #28]
   317a8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   317ac:	6023      	str	r3, [r4, #0]
   317ae:	6803      	ldr	r3, [r0, #0]
   317b0:	68db      	ldr	r3, [r3, #12]
   317b2:	4798      	blx	r3
   317b4:	f1b0 3fff 	cmp.w	r0, #4294967295
   317b8:	4683      	mov	fp, r0
   317ba:	d07f      	beq.n	318bc <ip_interface_recvfrom+0x170>
   317bc:	4287      	cmp	r7, r0
   317be:	dd03      	ble.n	317c8 <ip_interface_recvfrom+0x7c>
   317c0:	6923      	ldr	r3, [r4, #16]
   317c2:	2b01      	cmp	r3, #1
   317c4:	f000 80a6 	beq.w	31914 <ip_interface_recvfrom+0x1c8>
   317c8:	2600      	movs	r6, #0
   317ca:	69e0      	ldr	r0, [r4, #28]
   317cc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   317ce:	b103      	cbz	r3, 317d2 <ip_interface_recvfrom+0x86>
   317d0:	681b      	ldr	r3, [r3, #0]
   317d2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   317d4:	e9cd a700 	strd	sl, r7, [sp]
   317d8:	e9cd 2302 	strd	r2, r3, [sp, #8]
   317dc:	6803      	ldr	r3, [r0, #0]
   317de:	4642      	mov	r2, r8
   317e0:	689b      	ldr	r3, [r3, #8]
   317e2:	4669      	mov	r1, sp
   317e4:	4798      	blx	r3
   317e6:	4683      	mov	fp, r0
   317e8:	69e0      	ldr	r0, [r4, #28]
   317ea:	f1bb 3fff 	cmp.w	fp, #4294967295
   317ee:	6803      	ldr	r3, [r0, #0]
   317f0:	bf18      	it	ne
   317f2:	2501      	movne	r5, #1
   317f4:	68db      	ldr	r3, [r3, #12]
   317f6:	bf0a      	itet	eq
   317f8:	2500      	moveq	r5, #0
   317fa:	f04f 0900 	movne.w	r9, #0
   317fe:	f04f 0923 	moveq.w	r9, #35	; 0x23
   31802:	4798      	blx	r3
   31804:	3001      	adds	r0, #1
   31806:	d135      	bne.n	31874 <ip_interface_recvfrom+0x128>
   31808:	2e00      	cmp	r6, #0
   3180a:	f000 80b5 	beq.w	31978 <ip_interface_recvfrom+0x22c>
   3180e:	2d00      	cmp	r5, #0
   31810:	f000 80a5 	beq.w	3195e <ip_interface_recvfrom+0x212>
   31814:	6823      	ldr	r3, [r4, #0]
   31816:	0319      	lsls	r1, r3, #12
   31818:	d506      	bpl.n	31828 <ip_interface_recvfrom+0xdc>
   3181a:	6823      	ldr	r3, [r4, #0]
   3181c:	b29b      	uxth	r3, r3
   3181e:	2b0d      	cmp	r3, #13
   31820:	d002      	beq.n	31828 <ip_interface_recvfrom+0xdc>
   31822:	6923      	ldr	r3, [r4, #16]
   31824:	2b01      	cmp	r3, #1
   31826:	d025      	beq.n	31874 <ip_interface_recvfrom+0x128>
   31828:	6823      	ldr	r3, [r4, #0]
   3182a:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
   3182e:	6823      	ldr	r3, [r4, #0]
   31830:	f040 80b3 	bne.w	3199a <ip_interface_recvfrom+0x24e>
   31834:	031a      	lsls	r2, r3, #12
   31836:	d474      	bmi.n	31922 <ip_interface_recvfrom+0x1d6>
   31838:	f1b9 0f00 	cmp.w	r9, #0
   3183c:	f040 8089 	bne.w	31952 <ip_interface_recvfrom+0x206>
   31840:	4658      	mov	r0, fp
   31842:	b005      	add	sp, #20
   31844:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   31848:	6803      	ldr	r3, [r0, #0]
   3184a:	b29b      	uxth	r3, r3
   3184c:	2b06      	cmp	r3, #6
   3184e:	d072      	beq.n	31936 <ip_interface_recvfrom+0x1ea>
   31850:	6803      	ldr	r3, [r0, #0]
   31852:	b29b      	uxth	r3, r3
   31854:	2b07      	cmp	r3, #7
   31856:	bf0c      	ite	eq
   31858:	f04f 0909 	moveq.w	r9, #9
   3185c:	f04f 0939 	movne.w	r9, #57	; 0x39
   31860:	69e0      	ldr	r0, [r4, #28]
   31862:	6803      	ldr	r3, [r0, #0]
   31864:	68db      	ldr	r3, [r3, #12]
   31866:	4798      	blx	r3
   31868:	f1b0 3fff 	cmp.w	r0, #4294967295
   3186c:	4683      	mov	fp, r0
   3186e:	d0db      	beq.n	31828 <ip_interface_recvfrom+0xdc>
   31870:	f04f 3bff 	mov.w	fp, #4294967295
   31874:	6823      	ldr	r3, [r4, #0]
   31876:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   3187a:	6023      	str	r3, [r4, #0]
   3187c:	e7dc      	b.n	31838 <ip_interface_recvfrom+0xec>
   3187e:	f1b9 0f00 	cmp.w	r9, #0
   31882:	d07d      	beq.n	31980 <ip_interface_recvfrom+0x234>
   31884:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   31888:	6a23      	ldr	r3, [r4, #32]
   3188a:	4611      	mov	r1, r2
   3188c:	2b00      	cmp	r3, #0
   3188e:	bf08      	it	eq
   31890:	f04f 33ff 	moveq.w	r3, #4294967295
   31894:	4628      	mov	r0, r5
   31896:	f001 f8ab 	bl	329f0 <interface_socket_wait>
   3189a:	4681      	mov	r9, r0
   3189c:	b358      	cbz	r0, 318f6 <ip_interface_recvfrom+0x1aa>
   3189e:	6823      	ldr	r3, [r4, #0]
   318a0:	69e0      	ldr	r0, [r4, #28]
   318a2:	031b      	lsls	r3, r3, #12
   318a4:	d521      	bpl.n	318ea <ip_interface_recvfrom+0x19e>
   318a6:	6823      	ldr	r3, [r4, #0]
   318a8:	b29b      	uxth	r3, r3
   318aa:	2b0d      	cmp	r3, #13
   318ac:	d01d      	beq.n	318ea <ip_interface_recvfrom+0x19e>
   318ae:	6926      	ldr	r6, [r4, #16]
   318b0:	f1a6 0601 	sub.w	r6, r6, #1
   318b4:	fab6 f686 	clz	r6, r6
   318b8:	0976      	lsrs	r6, r6, #5
   318ba:	e787      	b.n	317cc <ip_interface_recvfrom+0x80>
   318bc:	6823      	ldr	r3, [r4, #0]
   318be:	0318      	lsls	r0, r3, #12
   318c0:	d5dd      	bpl.n	3187e <ip_interface_recvfrom+0x132>
   318c2:	6823      	ldr	r3, [r4, #0]
   318c4:	b29b      	uxth	r3, r3
   318c6:	2b0d      	cmp	r3, #13
   318c8:	d0d9      	beq.n	3187e <ip_interface_recvfrom+0x132>
   318ca:	6923      	ldr	r3, [r4, #16]
   318cc:	69e0      	ldr	r0, [r4, #28]
   318ce:	2b01      	cmp	r3, #1
   318d0:	d034      	beq.n	3193c <ip_interface_recvfrom+0x1f0>
   318d2:	f04f 0939 	mov.w	r9, #57	; 0x39
   318d6:	6823      	ldr	r3, [r4, #0]
   318d8:	0c1b      	lsrs	r3, r3, #16
   318da:	041b      	lsls	r3, r3, #16
   318dc:	f043 030d 	orr.w	r3, r3, #13
   318e0:	6023      	str	r3, [r4, #0]
   318e2:	6823      	ldr	r3, [r4, #0]
   318e4:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   318e8:	6023      	str	r3, [r4, #0]
   318ea:	6803      	ldr	r3, [r0, #0]
   318ec:	68db      	ldr	r3, [r3, #12]
   318ee:	4798      	blx	r3
   318f0:	3001      	adds	r0, #1
   318f2:	d1bf      	bne.n	31874 <ip_interface_recvfrom+0x128>
   318f4:	e798      	b.n	31828 <ip_interface_recvfrom+0xdc>
   318f6:	4628      	mov	r0, r5
   318f8:	f001 f8ee 	bl	32ad8 <interface_socket_from_handle_get>
   318fc:	b138      	cbz	r0, 3190e <ip_interface_recvfrom+0x1c2>
   318fe:	f8d0 9004 	ldr.w	r9, [r0, #4]
   31902:	f1b9 0f00 	cmp.w	r9, #0
   31906:	d002      	beq.n	3190e <ip_interface_recvfrom+0x1c2>
   31908:	2300      	movs	r3, #0
   3190a:	6043      	str	r3, [r0, #4]
   3190c:	e7c7      	b.n	3189e <ip_interface_recvfrom+0x152>
   3190e:	f04f 0901 	mov.w	r9, #1
   31912:	e744      	b.n	3179e <ip_interface_recvfrom+0x52>
   31914:	b11e      	cbz	r6, 3191e <ip_interface_recvfrom+0x1d2>
   31916:	6823      	ldr	r3, [r4, #0]
   31918:	00db      	lsls	r3, r3, #3
   3191a:	d5b3      	bpl.n	31884 <ip_interface_recvfrom+0x138>
   3191c:	e754      	b.n	317c8 <ip_interface_recvfrom+0x7c>
   3191e:	69e0      	ldr	r0, [r4, #28]
   31920:	e754      	b.n	317cc <ip_interface_recvfrom+0x80>
   31922:	6823      	ldr	r3, [r4, #0]
   31924:	b29b      	uxth	r3, r3
   31926:	2b0d      	cmp	r3, #13
   31928:	d186      	bne.n	31838 <ip_interface_recvfrom+0xec>
   3192a:	68a3      	ldr	r3, [r4, #8]
   3192c:	2b00      	cmp	r3, #0
   3192e:	d083      	beq.n	31838 <ip_interface_recvfrom+0xec>
   31930:	f8d4 9008 	ldr.w	r9, [r4, #8]
   31934:	e780      	b.n	31838 <ip_interface_recvfrom+0xec>
   31936:	f04f 0909 	mov.w	r9, #9
   3193a:	e791      	b.n	31860 <ip_interface_recvfrom+0x114>
   3193c:	6803      	ldr	r3, [r0, #0]
   3193e:	68db      	ldr	r3, [r3, #12]
   31940:	4798      	blx	r3
   31942:	3001      	adds	r0, #1
   31944:	d00b      	beq.n	3195e <ip_interface_recvfrom+0x212>
   31946:	f04f 0923 	mov.w	r9, #35	; 0x23
   3194a:	6823      	ldr	r3, [r4, #0]
   3194c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   31950:	6023      	str	r3, [r4, #0]
   31952:	4648      	mov	r0, r9
   31954:	f7f9 f936 	bl	2abc4 <bsd_os_errno_set>
   31958:	f04f 3bff 	mov.w	fp, #4294967295
   3195c:	e770      	b.n	31840 <ip_interface_recvfrom+0xf4>
   3195e:	6823      	ldr	r3, [r4, #0]
   31960:	f04f 0b00 	mov.w	fp, #0
   31964:	0c1b      	lsrs	r3, r3, #16
   31966:	041b      	lsls	r3, r3, #16
   31968:	f043 030d 	orr.w	r3, r3, #13
   3196c:	6023      	str	r3, [r4, #0]
   3196e:	6823      	ldr	r3, [r4, #0]
   31970:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   31974:	6023      	str	r3, [r4, #0]
   31976:	e763      	b.n	31840 <ip_interface_recvfrom+0xf4>
   31978:	2d00      	cmp	r5, #0
   3197a:	f47f af4b 	bne.w	31814 <ip_interface_recvfrom+0xc8>
   3197e:	e753      	b.n	31828 <ip_interface_recvfrom+0xdc>
   31980:	f04f 0923 	mov.w	r9, #35	; 0x23
   31984:	69e0      	ldr	r0, [r4, #28]
   31986:	e7b0      	b.n	318ea <ip_interface_recvfrom+0x19e>
   31988:	f04f 092d 	mov.w	r9, #45	; 0x2d
   3198c:	e7e1      	b.n	31952 <ip_interface_recvfrom+0x206>
   3198e:	f04f 0916 	mov.w	r9, #22
   31992:	e7de      	b.n	31952 <ip_interface_recvfrom+0x206>
   31994:	f04f 0909 	mov.w	r9, #9
   31998:	e7db      	b.n	31952 <ip_interface_recvfrom+0x206>
   3199a:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
   3199e:	6023      	str	r3, [r4, #0]
   319a0:	6823      	ldr	r3, [r4, #0]
   319a2:	f04f 0969 	mov.w	r9, #105	; 0x69
   319a6:	0c1b      	lsrs	r3, r3, #16
   319a8:	041b      	lsls	r3, r3, #16
   319aa:	f043 030d 	orr.w	r3, r3, #13
   319ae:	6023      	str	r3, [r4, #0]
   319b0:	e7cf      	b.n	31952 <ip_interface_recvfrom+0x206>
   319b2:	bf00      	nop

000319b4 <ip_interface_connect>:
   319b4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   319b8:	b083      	sub	sp, #12
   319ba:	2900      	cmp	r1, #0
   319bc:	d049      	beq.n	31a52 <ip_interface_connect+0x9e>
   319be:	4616      	mov	r6, r2
   319c0:	2a00      	cmp	r2, #0
   319c2:	d046      	beq.n	31a52 <ip_interface_connect+0x9e>
   319c4:	4607      	mov	r7, r0
   319c6:	4688      	mov	r8, r1
   319c8:	f001 f886 	bl	32ad8 <interface_socket_from_handle_get>
   319cc:	4605      	mov	r5, r0
   319ce:	2800      	cmp	r0, #0
   319d0:	f000 80a8 	beq.w	31b24 <ip_interface_connect+0x170>
   319d4:	6803      	ldr	r3, [r0, #0]
   319d6:	b29b      	uxth	r3, r3
   319d8:	2b02      	cmp	r3, #2
   319da:	d004      	beq.n	319e6 <ip_interface_connect+0x32>
   319dc:	6803      	ldr	r3, [r0, #0]
   319de:	b29b      	uxth	r3, r3
   319e0:	2b04      	cmp	r3, #4
   319e2:	f040 808b 	bne.w	31afc <ip_interface_connect+0x148>
   319e6:	6829      	ldr	r1, [r5, #0]
   319e8:	f011 5100 	ands.w	r1, r1, #536870912	; 0x20000000
   319ec:	f040 8082 	bne.w	31af4 <ip_interface_connect+0x140>
   319f0:	a802      	add	r0, sp, #8
   319f2:	f840 1d04 	str.w	r1, [r0, #-4]!
   319f6:	f8d5 9018 	ldr.w	r9, [r5, #24]
   319fa:	f7fb ff87 	bl	2d90c <rpc_ip_client_request_alloc>
   319fe:	bb90      	cbnz	r0, 31a66 <ip_interface_connect+0xb2>
   31a00:	2108      	movs	r1, #8
   31a02:	043b      	lsls	r3, r7, #16
   31a04:	9c01      	ldr	r4, [sp, #4]
   31a06:	f443 42e0 	orr.w	r2, r3, #28672	; 0x7000
   31a0a:	f042 0202 	orr.w	r2, r2, #2
   31a0e:	60e2      	str	r2, [r4, #12]
   31a10:	f8c4 9010 	str.w	r9, [r4, #16]
   31a14:	7260      	strb	r0, [r4, #9]
   31a16:	72a0      	strb	r0, [r4, #10]
   31a18:	72e0      	strb	r0, [r4, #11]
   31a1a:	7221      	strb	r1, [r4, #8]
   31a1c:	f443 43e0 	orr.w	r3, r3, #28672	; 0x7000
   31a20:	f043 0302 	orr.w	r3, r3, #2
   31a24:	60e3      	str	r3, [r4, #12]
   31a26:	68a3      	ldr	r3, [r4, #8]
   31a28:	69aa      	ldr	r2, [r5, #24]
   31a2a:	3304      	adds	r3, #4
   31a2c:	6122      	str	r2, [r4, #16]
   31a2e:	60a3      	str	r3, [r4, #8]
   31a30:	68eb      	ldr	r3, [r5, #12]
   31a32:	f8d8 2004 	ldr.w	r2, [r8, #4]
   31a36:	4293      	cmp	r3, r2
   31a38:	d11a      	bne.n	31a70 <ip_interface_connect+0xbc>
   31a3a:	f898 2000 	ldrb.w	r2, [r8]
   31a3e:	4296      	cmp	r6, r2
   31a40:	d107      	bne.n	31a52 <ip_interface_connect+0x9e>
   31a42:	2b02      	cmp	r3, #2
   31a44:	f104 0018 	add.w	r0, r4, #24
   31a48:	d014      	beq.n	31a74 <ip_interface_connect+0xc0>
   31a4a:	2b0a      	cmp	r3, #10
   31a4c:	d101      	bne.n	31a52 <ip_interface_connect+0x9e>
   31a4e:	2e24      	cmp	r6, #36	; 0x24
   31a50:	d01c      	beq.n	31a8c <ip_interface_connect+0xd8>
   31a52:	2416      	movs	r4, #22
   31a54:	4620      	mov	r0, r4
   31a56:	f7f9 f8b5 	bl	2abc4 <bsd_os_errno_set>
   31a5a:	f04f 34ff 	mov.w	r4, #4294967295
   31a5e:	4620      	mov	r0, r4
   31a60:	b003      	add	sp, #12
   31a62:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   31a66:	9c01      	ldr	r4, [sp, #4]
   31a68:	2c00      	cmp	r4, #0
   31a6a:	d059      	beq.n	31b20 <ip_interface_connect+0x16c>
   31a6c:	043b      	lsls	r3, r7, #16
   31a6e:	e7d5      	b.n	31a1c <ip_interface_connect+0x68>
   31a70:	242f      	movs	r4, #47	; 0x2f
   31a72:	e7ef      	b.n	31a54 <ip_interface_connect+0xa0>
   31a74:	2e10      	cmp	r6, #16
   31a76:	d1ec      	bne.n	31a52 <ip_interface_connect+0x9e>
   31a78:	2204      	movs	r2, #4
   31a7a:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   31a7e:	f108 010c 	add.w	r1, r8, #12
   31a82:	82e2      	strh	r2, [r4, #22]
   31a84:	82a3      	strh	r3, [r4, #20]
   31a86:	f00c fee1 	bl	3e84c <memcpy>
   31a8a:	e008      	b.n	31a9e <ip_interface_connect+0xea>
   31a8c:	2210      	movs	r2, #16
   31a8e:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   31a92:	eb08 0102 	add.w	r1, r8, r2
   31a96:	82e2      	strh	r2, [r4, #22]
   31a98:	82a3      	strh	r3, [r4, #20]
   31a9a:	f00c fed7 	bl	3e84c <memcpy>
   31a9e:	68a3      	ldr	r3, [r4, #8]
   31aa0:	8ae2      	ldrh	r2, [r4, #22]
   31aa2:	f247 0102 	movw	r1, #28674	; 0x7002
   31aa6:	4413      	add	r3, r2
   31aa8:	60a3      	str	r3, [r4, #8]
   31aaa:	682e      	ldr	r6, [r5, #0]
   31aac:	682b      	ldr	r3, [r5, #0]
   31aae:	4620      	mov	r0, r4
   31ab0:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   31ab4:	602b      	str	r3, [r5, #0]
   31ab6:	f7fb ff3d 	bl	2d934 <rpc_ip_client_request_send>
   31aba:	b988      	cbnz	r0, 31ae0 <ip_interface_connect+0x12c>
   31abc:	682b      	ldr	r3, [r5, #0]
   31abe:	f013 5880 	ands.w	r8, r3, #268435456	; 0x10000000
   31ac2:	d119      	bne.n	31af8 <ip_interface_connect+0x144>
   31ac4:	f04f 33ff 	mov.w	r3, #4294967295
   31ac8:	f64f 72ff 	movw	r2, #65535	; 0xffff
   31acc:	2105      	movs	r1, #5
   31ace:	4638      	mov	r0, r7
   31ad0:	f000 ff8e 	bl	329f0 <interface_socket_wait>
   31ad4:	4604      	mov	r4, r0
   31ad6:	b1c0      	cbz	r0, 31b0a <ip_interface_connect+0x156>
   31ad8:	2c73      	cmp	r4, #115	; 0x73
   31ada:	d0bb      	beq.n	31a54 <ip_interface_connect+0xa0>
   31adc:	602e      	str	r6, [r5, #0]
   31ade:	e7b9      	b.n	31a54 <ip_interface_connect+0xa0>
   31ae0:	6820      	ldr	r0, [r4, #0]
   31ae2:	b108      	cbz	r0, 31ae8 <ip_interface_connect+0x134>
   31ae4:	f7fb ff44 	bl	2d970 <rpc_ip_client_data_free>
   31ae8:	4620      	mov	r0, r4
   31aea:	f7fb ff39 	bl	2d960 <rpc_ip_client_message_free>
   31aee:	2423      	movs	r4, #35	; 0x23
   31af0:	602e      	str	r6, [r5, #0]
   31af2:	e7af      	b.n	31a54 <ip_interface_connect+0xa0>
   31af4:	2472      	movs	r4, #114	; 0x72
   31af6:	e7ad      	b.n	31a54 <ip_interface_connect+0xa0>
   31af8:	2473      	movs	r4, #115	; 0x73
   31afa:	e7ab      	b.n	31a54 <ip_interface_connect+0xa0>
   31afc:	6803      	ldr	r3, [r0, #0]
   31afe:	b29b      	uxth	r3, r3
   31b00:	2b05      	cmp	r3, #5
   31b02:	bf14      	ite	ne
   31b04:	2409      	movne	r4, #9
   31b06:	2438      	moveq	r4, #56	; 0x38
   31b08:	e7a4      	b.n	31a54 <ip_interface_connect+0xa0>
   31b0a:	4638      	mov	r0, r7
   31b0c:	f000 ffe4 	bl	32ad8 <interface_socket_from_handle_get>
   31b10:	2800      	cmp	r0, #0
   31b12:	d0a4      	beq.n	31a5e <ip_interface_connect+0xaa>
   31b14:	6844      	ldr	r4, [r0, #4]
   31b16:	2c00      	cmp	r4, #0
   31b18:	d0a1      	beq.n	31a5e <ip_interface_connect+0xaa>
   31b1a:	f8c0 8004 	str.w	r8, [r0, #4]
   31b1e:	e7db      	b.n	31ad8 <ip_interface_connect+0x124>
   31b20:	240c      	movs	r4, #12
   31b22:	e797      	b.n	31a54 <ip_interface_connect+0xa0>
   31b24:	2409      	movs	r4, #9
   31b26:	e795      	b.n	31a54 <ip_interface_connect+0xa0>

00031b28 <ip_interface_bind>:
   31b28:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   31b2c:	b083      	sub	sp, #12
   31b2e:	b3b1      	cbz	r1, 31b9e <ip_interface_bind+0x76>
   31b30:	4616      	mov	r6, r2
   31b32:	b3a2      	cbz	r2, 31b9e <ip_interface_bind+0x76>
   31b34:	4607      	mov	r7, r0
   31b36:	4688      	mov	r8, r1
   31b38:	f000 ffce 	bl	32ad8 <interface_socket_from_handle_get>
   31b3c:	4605      	mov	r5, r0
   31b3e:	2800      	cmp	r0, #0
   31b40:	d04a      	beq.n	31bd8 <ip_interface_bind+0xb0>
   31b42:	6803      	ldr	r3, [r0, #0]
   31b44:	b29b      	uxth	r3, r3
   31b46:	2b02      	cmp	r3, #2
   31b48:	d146      	bne.n	31bd8 <ip_interface_bind+0xb0>
   31b4a:	2100      	movs	r1, #0
   31b4c:	a802      	add	r0, sp, #8
   31b4e:	f840 1d04 	str.w	r1, [r0, #-4]!
   31b52:	f8d5 9018 	ldr.w	r9, [r5, #24]
   31b56:	f7fb fed9 	bl	2d90c <rpc_ip_client_request_alloc>
   31b5a:	bb50      	cbnz	r0, 31bb2 <ip_interface_bind+0x8a>
   31b5c:	f247 0305 	movw	r3, #28677	; 0x7005
   31b60:	2208      	movs	r2, #8
   31b62:	9c01      	ldr	r4, [sp, #4]
   31b64:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
   31b68:	60e3      	str	r3, [r4, #12]
   31b6a:	f8c4 9010 	str.w	r9, [r4, #16]
   31b6e:	7260      	strb	r0, [r4, #9]
   31b70:	72a0      	strb	r0, [r4, #10]
   31b72:	72e0      	strb	r0, [r4, #11]
   31b74:	7222      	strb	r2, [r4, #8]
   31b76:	68a3      	ldr	r3, [r4, #8]
   31b78:	3304      	adds	r3, #4
   31b7a:	60a3      	str	r3, [r4, #8]
   31b7c:	68eb      	ldr	r3, [r5, #12]
   31b7e:	f8d8 2004 	ldr.w	r2, [r8, #4]
   31b82:	4293      	cmp	r3, r2
   31b84:	d11a      	bne.n	31bbc <ip_interface_bind+0x94>
   31b86:	f898 2000 	ldrb.w	r2, [r8]
   31b8a:	4296      	cmp	r6, r2
   31b8c:	d107      	bne.n	31b9e <ip_interface_bind+0x76>
   31b8e:	2b02      	cmp	r3, #2
   31b90:	f104 0018 	add.w	r0, r4, #24
   31b94:	d014      	beq.n	31bc0 <ip_interface_bind+0x98>
   31b96:	2b0a      	cmp	r3, #10
   31b98:	d101      	bne.n	31b9e <ip_interface_bind+0x76>
   31b9a:	2e24      	cmp	r6, #36	; 0x24
   31b9c:	d01e      	beq.n	31bdc <ip_interface_bind+0xb4>
   31b9e:	2416      	movs	r4, #22
   31ba0:	4620      	mov	r0, r4
   31ba2:	f7f9 f80f 	bl	2abc4 <bsd_os_errno_set>
   31ba6:	f04f 34ff 	mov.w	r4, #4294967295
   31baa:	4620      	mov	r0, r4
   31bac:	b003      	add	sp, #12
   31bae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   31bb2:	9c01      	ldr	r4, [sp, #4]
   31bb4:	2c00      	cmp	r4, #0
   31bb6:	d1de      	bne.n	31b76 <ip_interface_bind+0x4e>
   31bb8:	240c      	movs	r4, #12
   31bba:	e7f1      	b.n	31ba0 <ip_interface_bind+0x78>
   31bbc:	242f      	movs	r4, #47	; 0x2f
   31bbe:	e7ef      	b.n	31ba0 <ip_interface_bind+0x78>
   31bc0:	2e10      	cmp	r6, #16
   31bc2:	d1ec      	bne.n	31b9e <ip_interface_bind+0x76>
   31bc4:	2204      	movs	r2, #4
   31bc6:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   31bca:	f108 010c 	add.w	r1, r8, #12
   31bce:	82e2      	strh	r2, [r4, #22]
   31bd0:	82a3      	strh	r3, [r4, #20]
   31bd2:	f00c fe3b 	bl	3e84c <memcpy>
   31bd6:	e00a      	b.n	31bee <ip_interface_bind+0xc6>
   31bd8:	2409      	movs	r4, #9
   31bda:	e7e1      	b.n	31ba0 <ip_interface_bind+0x78>
   31bdc:	2210      	movs	r2, #16
   31bde:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   31be2:	eb08 0102 	add.w	r1, r8, r2
   31be6:	82e2      	strh	r2, [r4, #22]
   31be8:	82a3      	strh	r3, [r4, #20]
   31bea:	f00c fe2f 	bl	3e84c <memcpy>
   31bee:	68a3      	ldr	r3, [r4, #8]
   31bf0:	8ae2      	ldrh	r2, [r4, #22]
   31bf2:	f247 0105 	movw	r1, #28677	; 0x7005
   31bf6:	4413      	add	r3, r2
   31bf8:	60a3      	str	r3, [r4, #8]
   31bfa:	682b      	ldr	r3, [r5, #0]
   31bfc:	4620      	mov	r0, r4
   31bfe:	0c1b      	lsrs	r3, r3, #16
   31c00:	041b      	lsls	r3, r3, #16
   31c02:	f043 0303 	orr.w	r3, r3, #3
   31c06:	602b      	str	r3, [r5, #0]
   31c08:	682e      	ldr	r6, [r5, #0]
   31c0a:	f7fb fe93 	bl	2d934 <rpc_ip_client_request_send>
   31c0e:	4680      	mov	r8, r0
   31c10:	b980      	cbnz	r0, 31c34 <ip_interface_bind+0x10c>
   31c12:	f04f 33ff 	mov.w	r3, #4294967295
   31c16:	f64f 72ff 	movw	r2, #65535	; 0xffff
   31c1a:	2104      	movs	r1, #4
   31c1c:	4638      	mov	r0, r7
   31c1e:	f000 fee7 	bl	329f0 <interface_socket_wait>
   31c22:	4604      	mov	r4, r0
   31c24:	b1a0      	cbz	r0, 31c50 <ip_interface_bind+0x128>
   31c26:	682b      	ldr	r3, [r5, #0]
   31c28:	0c1b      	lsrs	r3, r3, #16
   31c2a:	041b      	lsls	r3, r3, #16
   31c2c:	f043 0302 	orr.w	r3, r3, #2
   31c30:	602b      	str	r3, [r5, #0]
   31c32:	e7b5      	b.n	31ba0 <ip_interface_bind+0x78>
   31c34:	6820      	ldr	r0, [r4, #0]
   31c36:	b108      	cbz	r0, 31c3c <ip_interface_bind+0x114>
   31c38:	f7fb fe9a 	bl	2d970 <rpc_ip_client_data_free>
   31c3c:	0c36      	lsrs	r6, r6, #16
   31c3e:	0436      	lsls	r6, r6, #16
   31c40:	4620      	mov	r0, r4
   31c42:	f046 0602 	orr.w	r6, r6, #2
   31c46:	f7fb fe8b 	bl	2d960 <rpc_ip_client_message_free>
   31c4a:	2423      	movs	r4, #35	; 0x23
   31c4c:	602e      	str	r6, [r5, #0]
   31c4e:	e7a7      	b.n	31ba0 <ip_interface_bind+0x78>
   31c50:	4638      	mov	r0, r7
   31c52:	f000 ff41 	bl	32ad8 <interface_socket_from_handle_get>
   31c56:	2800      	cmp	r0, #0
   31c58:	d0a7      	beq.n	31baa <ip_interface_bind+0x82>
   31c5a:	6844      	ldr	r4, [r0, #4]
   31c5c:	2c00      	cmp	r4, #0
   31c5e:	d0a4      	beq.n	31baa <ip_interface_bind+0x82>
   31c60:	f8c0 8004 	str.w	r8, [r0, #4]
   31c64:	e7df      	b.n	31c26 <ip_interface_bind+0xfe>
   31c66:	bf00      	nop

00031c68 <ip_interface_listen>:
   31c68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   31c6c:	b082      	sub	sp, #8
   31c6e:	4606      	mov	r6, r0
   31c70:	f000 ff32 	bl	32ad8 <interface_socket_from_handle_get>
   31c74:	2800      	cmp	r0, #0
   31c76:	d067      	beq.n	31d48 <ip_interface_listen+0xe0>
   31c78:	6803      	ldr	r3, [r0, #0]
   31c7a:	4605      	mov	r5, r0
   31c7c:	b29b      	uxth	r3, r3
   31c7e:	2b04      	cmp	r3, #4
   31c80:	d162      	bne.n	31d48 <ip_interface_listen+0xe0>
   31c82:	2100      	movs	r1, #0
   31c84:	4a32      	ldr	r2, [pc, #200]	; (31d50 <ip_interface_listen+0xe8>)
   31c86:	4630      	mov	r0, r6
   31c88:	f000 fe7a 	bl	32980 <interface_socket_packet_handler_update>
   31c8c:	4601      	mov	r1, r0
   31c8e:	2800      	cmp	r0, #0
   31c90:	d15c      	bne.n	31d4c <ip_interface_listen+0xe4>
   31c92:	a802      	add	r0, sp, #8
   31c94:	f840 1d04 	str.w	r1, [r0, #-4]!
   31c98:	69af      	ldr	r7, [r5, #24]
   31c9a:	f7fb fe37 	bl	2d90c <rpc_ip_client_request_alloc>
   31c9e:	bba8      	cbnz	r0, 31d0c <ip_interface_listen+0xa4>
   31ca0:	f247 0308 	movw	r3, #28680	; 0x7008
   31ca4:	2208      	movs	r2, #8
   31ca6:	9c01      	ldr	r4, [sp, #4]
   31ca8:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   31cac:	60e3      	str	r3, [r4, #12]
   31cae:	6127      	str	r7, [r4, #16]
   31cb0:	7260      	strb	r0, [r4, #9]
   31cb2:	72a0      	strb	r0, [r4, #10]
   31cb4:	72e0      	strb	r0, [r4, #11]
   31cb6:	7222      	strb	r2, [r4, #8]
   31cb8:	68a3      	ldr	r3, [r4, #8]
   31cba:	f247 0108 	movw	r1, #28680	; 0x7008
   31cbe:	3304      	adds	r3, #4
   31cc0:	60a3      	str	r3, [r4, #8]
   31cc2:	682b      	ldr	r3, [r5, #0]
   31cc4:	4620      	mov	r0, r4
   31cc6:	0c1b      	lsrs	r3, r3, #16
   31cc8:	041b      	lsls	r3, r3, #16
   31cca:	f043 0306 	orr.w	r3, r3, #6
   31cce:	602b      	str	r3, [r5, #0]
   31cd0:	682f      	ldr	r7, [r5, #0]
   31cd2:	f7fb fe2f 	bl	2d934 <rpc_ip_client_request_send>
   31cd6:	4680      	mov	r8, r0
   31cd8:	b9e8      	cbnz	r0, 31d16 <ip_interface_listen+0xae>
   31cda:	f04f 33ff 	mov.w	r3, #4294967295
   31cde:	f64f 72ff 	movw	r2, #65535	; 0xffff
   31ce2:	2107      	movs	r1, #7
   31ce4:	4630      	mov	r0, r6
   31ce6:	f000 fe83 	bl	329f0 <interface_socket_wait>
   31cea:	4604      	mov	r4, r0
   31cec:	b308      	cbz	r0, 31d32 <ip_interface_listen+0xca>
   31cee:	682b      	ldr	r3, [r5, #0]
   31cf0:	0c1b      	lsrs	r3, r3, #16
   31cf2:	041b      	lsls	r3, r3, #16
   31cf4:	f043 0304 	orr.w	r3, r3, #4
   31cf8:	602b      	str	r3, [r5, #0]
   31cfa:	4620      	mov	r0, r4
   31cfc:	f7f8 ff62 	bl	2abc4 <bsd_os_errno_set>
   31d00:	f04f 34ff 	mov.w	r4, #4294967295
   31d04:	4620      	mov	r0, r4
   31d06:	b002      	add	sp, #8
   31d08:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   31d0c:	9c01      	ldr	r4, [sp, #4]
   31d0e:	2c00      	cmp	r4, #0
   31d10:	d1d2      	bne.n	31cb8 <ip_interface_listen+0x50>
   31d12:	240c      	movs	r4, #12
   31d14:	e7f1      	b.n	31cfa <ip_interface_listen+0x92>
   31d16:	6820      	ldr	r0, [r4, #0]
   31d18:	b108      	cbz	r0, 31d1e <ip_interface_listen+0xb6>
   31d1a:	f7fb fe29 	bl	2d970 <rpc_ip_client_data_free>
   31d1e:	0c3f      	lsrs	r7, r7, #16
   31d20:	043f      	lsls	r7, r7, #16
   31d22:	4620      	mov	r0, r4
   31d24:	f047 0704 	orr.w	r7, r7, #4
   31d28:	f7fb fe1a 	bl	2d960 <rpc_ip_client_message_free>
   31d2c:	2423      	movs	r4, #35	; 0x23
   31d2e:	602f      	str	r7, [r5, #0]
   31d30:	e7e3      	b.n	31cfa <ip_interface_listen+0x92>
   31d32:	4630      	mov	r0, r6
   31d34:	f000 fed0 	bl	32ad8 <interface_socket_from_handle_get>
   31d38:	2800      	cmp	r0, #0
   31d3a:	d0e3      	beq.n	31d04 <ip_interface_listen+0x9c>
   31d3c:	6844      	ldr	r4, [r0, #4]
   31d3e:	2c00      	cmp	r4, #0
   31d40:	d0e0      	beq.n	31d04 <ip_interface_listen+0x9c>
   31d42:	f8c0 8004 	str.w	r8, [r0, #4]
   31d46:	e7d2      	b.n	31cee <ip_interface_listen+0x86>
   31d48:	2409      	movs	r4, #9
   31d4a:	e7d6      	b.n	31cfa <ip_interface_listen+0x92>
   31d4c:	2423      	movs	r4, #35	; 0x23
   31d4e:	e7d4      	b.n	31cfa <ip_interface_listen+0x92>
   31d50:	0003112d 	.word	0x0003112d

00031d54 <ip_interface_accept>:
   31d54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   31d58:	2500      	movs	r5, #0
   31d5a:	b085      	sub	sp, #20
   31d5c:	460f      	mov	r7, r1
   31d5e:	4690      	mov	r8, r2
   31d60:	9502      	str	r5, [sp, #8]
   31d62:	4606      	mov	r6, r0
   31d64:	f000 feb8 	bl	32ad8 <interface_socket_from_handle_get>
   31d68:	4604      	mov	r4, r0
   31d6a:	2800      	cmp	r0, #0
   31d6c:	f000 811c 	beq.w	31fa8 <ip_interface_accept+0x254>
   31d70:	6803      	ldr	r3, [r0, #0]
   31d72:	b29b      	uxth	r3, r3
   31d74:	2b07      	cmp	r3, #7
   31d76:	d10a      	bne.n	31d8e <ip_interface_accept+0x3a>
   31d78:	6803      	ldr	r3, [r0, #0]
   31d7a:	6805      	ldr	r5, [r0, #0]
   31d7c:	00db      	lsls	r3, r3, #3
   31d7e:	d416      	bmi.n	31dae <ip_interface_accept+0x5a>
   31d80:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   31d84:	d019      	beq.n	31dba <ip_interface_accept+0x66>
   31d86:	6805      	ldr	r5, [r0, #0]
   31d88:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   31d8c:	d124      	bne.n	31dd8 <ip_interface_accept+0x84>
   31d8e:	f04f 0909 	mov.w	r9, #9
   31d92:	9b02      	ldr	r3, [sp, #8]
   31d94:	b113      	cbz	r3, 31d9c <ip_interface_accept+0x48>
   31d96:	4628      	mov	r0, r5
   31d98:	f000 fddc 	bl	32954 <interface_socket_free>
   31d9c:	4648      	mov	r0, r9
   31d9e:	f04f 39ff 	mov.w	r9, #4294967295
   31da2:	f7f8 ff0f 	bl	2abc4 <bsd_os_errno_set>
   31da6:	4648      	mov	r0, r9
   31da8:	b005      	add	sp, #20
   31daa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   31dae:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   31db2:	d16d      	bne.n	31e90 <ip_interface_accept+0x13c>
   31db4:	f04f 0923 	mov.w	r9, #35	; 0x23
   31db8:	e7eb      	b.n	31d92 <ip_interface_accept+0x3e>
   31dba:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   31dbe:	f04f 33ff 	mov.w	r3, #4294967295
   31dc2:	4611      	mov	r1, r2
   31dc4:	4630      	mov	r0, r6
   31dc6:	f000 fe13 	bl	329f0 <interface_socket_wait>
   31dca:	4681      	mov	r9, r0
   31dcc:	2800      	cmp	r0, #0
   31dce:	d07e      	beq.n	31ece <ip_interface_accept+0x17a>
   31dd0:	6825      	ldr	r5, [r4, #0]
   31dd2:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   31dd6:	d0dc      	beq.n	31d92 <ip_interface_accept+0x3e>
   31dd8:	f04f 30ff 	mov.w	r0, #4294967295
   31ddc:	2300      	movs	r3, #0
   31dde:	e9cd 0300 	strd	r0, r3, [sp]
   31de2:	4a75      	ldr	r2, [pc, #468]	; (31fb8 <ip_interface_accept+0x264>)
   31de4:	6921      	ldr	r1, [r4, #16]
   31de6:	a802      	add	r0, sp, #8
   31de8:	f000 fd50 	bl	3288c <interface_socket_allocate>
   31dec:	9b02      	ldr	r3, [sp, #8]
   31dee:	4605      	mov	r5, r0
   31df0:	2b00      	cmp	r3, #0
   31df2:	f000 80dd 	beq.w	31fb0 <ip_interface_accept+0x25c>
   31df6:	2100      	movs	r1, #0
   31df8:	6962      	ldr	r2, [r4, #20]
   31dfa:	a804      	add	r0, sp, #16
   31dfc:	615a      	str	r2, [r3, #20]
   31dfe:	68e2      	ldr	r2, [r4, #12]
   31e00:	f840 1d04 	str.w	r1, [r0, #-4]!
   31e04:	60da      	str	r2, [r3, #12]
   31e06:	6922      	ldr	r2, [r4, #16]
   31e08:	611a      	str	r2, [r3, #16]
   31e0a:	f8d4 9018 	ldr.w	r9, [r4, #24]
   31e0e:	f7fb fd7d 	bl	2d90c <rpc_ip_client_request_alloc>
   31e12:	2800      	cmp	r0, #0
   31e14:	d143      	bne.n	31e9e <ip_interface_accept+0x14a>
   31e16:	f247 030c 	movw	r3, #28684	; 0x700c
   31e1a:	2108      	movs	r1, #8
   31e1c:	f8dd b00c 	ldr.w	fp, [sp, #12]
   31e20:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   31e24:	f8cb 300c 	str.w	r3, [fp, #12]
   31e28:	f8cb 9010 	str.w	r9, [fp, #16]
   31e2c:	f88b 0009 	strb.w	r0, [fp, #9]
   31e30:	f88b 000a 	strb.w	r0, [fp, #10]
   31e34:	f88b 000b 	strb.w	r0, [fp, #11]
   31e38:	f88b 1008 	strb.w	r1, [fp, #8]
   31e3c:	6823      	ldr	r3, [r4, #0]
   31e3e:	f247 010c 	movw	r1, #28684	; 0x700c
   31e42:	0c1b      	lsrs	r3, r3, #16
   31e44:	041b      	lsls	r3, r3, #16
   31e46:	f043 0308 	orr.w	r3, r3, #8
   31e4a:	6023      	str	r3, [r4, #0]
   31e4c:	4658      	mov	r0, fp
   31e4e:	f8d4 9000 	ldr.w	r9, [r4]
   31e52:	f7fb fd6f 	bl	2d934 <rpc_ip_client_request_send>
   31e56:	4682      	mov	sl, r0
   31e58:	bb48      	cbnz	r0, 31eae <ip_interface_accept+0x15a>
   31e5a:	6822      	ldr	r2, [r4, #0]
   31e5c:	9900      	ldr	r1, [sp, #0]
   31e5e:	f04f 33ff 	mov.w	r3, #4294967295
   31e62:	400a      	ands	r2, r1
   31e64:	6022      	str	r2, [r4, #0]
   31e66:	2109      	movs	r1, #9
   31e68:	f64f 72ff 	movw	r2, #65535	; 0xffff
   31e6c:	4630      	mov	r0, r6
   31e6e:	f000 fdbf 	bl	329f0 <interface_socket_wait>
   31e72:	4681      	mov	r9, r0
   31e74:	2800      	cmp	r0, #0
   31e76:	f000 8085 	beq.w	31f84 <ip_interface_accept+0x230>
   31e7a:	6823      	ldr	r3, [r4, #0]
   31e7c:	9a01      	ldr	r2, [sp, #4]
   31e7e:	431a      	orrs	r2, r3
   31e80:	6022      	str	r2, [r4, #0]
   31e82:	6823      	ldr	r3, [r4, #0]
   31e84:	0c1b      	lsrs	r3, r3, #16
   31e86:	041b      	lsls	r3, r3, #16
   31e88:	f043 0307 	orr.w	r3, r3, #7
   31e8c:	6023      	str	r3, [r4, #0]
   31e8e:	e780      	b.n	31d92 <ip_interface_accept+0x3e>
   31e90:	f06f 5280 	mvn.w	r2, #268435456	; 0x10000000
   31e94:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   31e98:	e9cd 2300 	strd	r2, r3, [sp]
   31e9c:	e7a1      	b.n	31de2 <ip_interface_accept+0x8e>
   31e9e:	f8dd b00c 	ldr.w	fp, [sp, #12]
   31ea2:	f04f 090c 	mov.w	r9, #12
   31ea6:	f1bb 0f00 	cmp.w	fp, #0
   31eaa:	d1c7      	bne.n	31e3c <ip_interface_accept+0xe8>
   31eac:	e771      	b.n	31d92 <ip_interface_accept+0x3e>
   31eae:	f8db 0000 	ldr.w	r0, [fp]
   31eb2:	b108      	cbz	r0, 31eb8 <ip_interface_accept+0x164>
   31eb4:	f7fb fd5c 	bl	2d970 <rpc_ip_client_data_free>
   31eb8:	ea4f 4919 	mov.w	r9, r9, lsr #16
   31ebc:	4658      	mov	r0, fp
   31ebe:	ea4f 4909 	mov.w	r9, r9, lsl #16
   31ec2:	f7fb fd4d 	bl	2d960 <rpc_ip_client_message_free>
   31ec6:	f049 0307 	orr.w	r3, r9, #7
   31eca:	6023      	str	r3, [r4, #0]
   31ecc:	e772      	b.n	31db4 <ip_interface_accept+0x60>
   31ece:	4630      	mov	r0, r6
   31ed0:	f000 fe02 	bl	32ad8 <interface_socket_from_handle_get>
   31ed4:	b130      	cbz	r0, 31ee4 <ip_interface_accept+0x190>
   31ed6:	f8d0 9004 	ldr.w	r9, [r0, #4]
   31eda:	f1b9 0f00 	cmp.w	r9, #0
   31ede:	d001      	beq.n	31ee4 <ip_interface_accept+0x190>
   31ee0:	6045      	str	r5, [r0, #4]
   31ee2:	e775      	b.n	31dd0 <ip_interface_accept+0x7c>
   31ee4:	6823      	ldr	r3, [r4, #0]
   31ee6:	03d9      	lsls	r1, r3, #15
   31ee8:	f53f af76 	bmi.w	31dd8 <ip_interface_accept+0x84>
   31eec:	4d33      	ldr	r5, [pc, #204]	; (31fbc <ip_interface_accept+0x268>)
   31eee:	9902      	ldr	r1, [sp, #8]
   31ef0:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
   31ef4:	699b      	ldr	r3, [r3, #24]
   31ef6:	618b      	str	r3, [r1, #24]
   31ef8:	b147      	cbz	r7, 31f0c <ip_interface_accept+0x1b8>
   31efa:	68cb      	ldr	r3, [r1, #12]
   31efc:	2b0a      	cmp	r3, #10
   31efe:	d024      	beq.n	31f4a <ip_interface_accept+0x1f6>
   31f00:	2b02      	cmp	r3, #2
   31f02:	d103      	bne.n	31f0c <ip_interface_accept+0x1b8>
   31f04:	f8d8 2000 	ldr.w	r2, [r8]
   31f08:	2a10      	cmp	r2, #16
   31f0a:	d032      	beq.n	31f72 <ip_interface_accept+0x21e>
   31f0c:	680a      	ldr	r2, [r1, #0]
   31f0e:	482c      	ldr	r0, [pc, #176]	; (31fc0 <ip_interface_accept+0x26c>)
   31f10:	4002      	ands	r2, r0
   31f12:	f042 0205 	orr.w	r2, r2, #5
   31f16:	600a      	str	r2, [r1, #0]
   31f18:	9a02      	ldr	r2, [sp, #8]
   31f1a:	6811      	ldr	r1, [r2, #0]
   31f1c:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
   31f20:	6011      	str	r1, [r2, #0]
   31f22:	6811      	ldr	r1, [r2, #0]
   31f24:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   31f28:	6011      	str	r1, [r2, #0]
   31f2a:	6823      	ldr	r3, [r4, #0]
   31f2c:	4003      	ands	r3, r0
   31f2e:	f043 0307 	orr.w	r3, r3, #7
   31f32:	6023      	str	r3, [r4, #0]
   31f34:	f855 0026 	ldr.w	r0, [r5, r6, lsl #2]
   31f38:	f7fb fd12 	bl	2d960 <rpc_ip_client_message_free>
   31f3c:	2300      	movs	r3, #0
   31f3e:	4648      	mov	r0, r9
   31f40:	f845 3026 	str.w	r3, [r5, r6, lsl #2]
   31f44:	b005      	add	sp, #20
   31f46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   31f4a:	f8d8 2000 	ldr.w	r2, [r8]
   31f4e:	2a24      	cmp	r2, #36	; 0x24
   31f50:	d1dc      	bne.n	31f0c <ip_interface_accept+0x1b8>
   31f52:	703a      	strb	r2, [r7, #0]
   31f54:	2210      	movs	r2, #16
   31f56:	607b      	str	r3, [r7, #4]
   31f58:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
   31f5c:	f107 0010 	add.w	r0, r7, #16
   31f60:	8b9b      	ldrh	r3, [r3, #28]
   31f62:	813b      	strh	r3, [r7, #8]
   31f64:	f855 1026 	ldr.w	r1, [r5, r6, lsl #2]
   31f68:	3120      	adds	r1, #32
   31f6a:	f00c fc6f 	bl	3e84c <memcpy>
   31f6e:	9902      	ldr	r1, [sp, #8]
   31f70:	e7cc      	b.n	31f0c <ip_interface_accept+0x1b8>
   31f72:	703a      	strb	r2, [r7, #0]
   31f74:	607b      	str	r3, [r7, #4]
   31f76:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
   31f7a:	f107 000c 	add.w	r0, r7, #12
   31f7e:	8b9b      	ldrh	r3, [r3, #28]
   31f80:	2204      	movs	r2, #4
   31f82:	e7ee      	b.n	31f62 <ip_interface_accept+0x20e>
   31f84:	4630      	mov	r0, r6
   31f86:	f000 fda7 	bl	32ad8 <interface_socket_from_handle_get>
   31f8a:	b138      	cbz	r0, 31f9c <ip_interface_accept+0x248>
   31f8c:	f8d0 9004 	ldr.w	r9, [r0, #4]
   31f90:	f1b9 0f00 	cmp.w	r9, #0
   31f94:	d002      	beq.n	31f9c <ip_interface_accept+0x248>
   31f96:	f8c0 a004 	str.w	sl, [r0, #4]
   31f9a:	e76e      	b.n	31e7a <ip_interface_accept+0x126>
   31f9c:	6823      	ldr	r3, [r4, #0]
   31f9e:	9a01      	ldr	r2, [sp, #4]
   31fa0:	46a9      	mov	r9, r5
   31fa2:	4313      	orrs	r3, r2
   31fa4:	6023      	str	r3, [r4, #0]
   31fa6:	e7a1      	b.n	31eec <ip_interface_accept+0x198>
   31fa8:	4605      	mov	r5, r0
   31faa:	f04f 0909 	mov.w	r9, #9
   31fae:	e6f0      	b.n	31d92 <ip_interface_accept+0x3e>
   31fb0:	f04f 090c 	mov.w	r9, #12
   31fb4:	e6f2      	b.n	31d9c <ip_interface_accept+0x48>
   31fb6:	bf00      	nop
   31fb8:	0003112d 	.word	0x0003112d
   31fbc:	20025334 	.word	0x20025334
   31fc0:	ffff0000 	.word	0xffff0000

00031fc4 <ip_interface_setopt>:
   31fc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   31fc8:	2901      	cmp	r1, #1
   31fca:	b084      	sub	sp, #16
   31fcc:	f040 809c 	bne.w	32108 <ip_interface_setopt+0x144>
   31fd0:	460e      	mov	r6, r1
   31fd2:	4690      	mov	r8, r2
   31fd4:	461d      	mov	r5, r3
   31fd6:	4607      	mov	r7, r0
   31fd8:	f000 fd7e 	bl	32ad8 <interface_socket_from_handle_get>
   31fdc:	4604      	mov	r4, r0
   31fde:	2800      	cmp	r0, #0
   31fe0:	f000 80a5 	beq.w	3212e <ip_interface_setopt+0x16a>
   31fe4:	f1b8 0f19 	cmp.w	r8, #25
   31fe8:	d16e      	bne.n	320c8 <ip_interface_setopt+0x104>
   31fea:	2d00      	cmp	r5, #0
   31fec:	f000 8092 	beq.w	32114 <ip_interface_setopt+0x150>
   31ff0:	4628      	mov	r0, r5
   31ff2:	f7eb f8b1 	bl	1d158 <strlen>
   31ff6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   31ff8:	4298      	cmp	r0, r3
   31ffa:	f040 808b 	bne.w	32114 <ip_interface_setopt+0x150>
   31ffe:	6823      	ldr	r3, [r4, #0]
   32000:	b29b      	uxth	r3, r3
   32002:	2b02      	cmp	r3, #2
   32004:	d173      	bne.n	320ee <ip_interface_setopt+0x12a>
   32006:	4629      	mov	r1, r5
   32008:	68e0      	ldr	r0, [r4, #12]
   3200a:	f7fe fb2b 	bl	30664 <pdn_interface_pdn_id_get>
   3200e:	9002      	str	r0, [sp, #8]
   32010:	3001      	adds	r0, #1
   32012:	bf08      	it	eq
   32014:	2516      	moveq	r5, #22
   32016:	d04e      	beq.n	320b6 <ip_interface_setopt+0xf2>
   32018:	6823      	ldr	r3, [r4, #0]
   3201a:	025b      	lsls	r3, r3, #9
   3201c:	d44a      	bmi.n	320b4 <ip_interface_setopt+0xf0>
   3201e:	6823      	ldr	r3, [r4, #0]
   32020:	f413 0300 	ands.w	r3, r3, #8388608	; 0x800000
   32024:	d146      	bne.n	320b4 <ip_interface_setopt+0xf0>
   32026:	6826      	ldr	r6, [r4, #0]
   32028:	6822      	ldr	r2, [r4, #0]
   3202a:	a804      	add	r0, sp, #16
   3202c:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
   32030:	6022      	str	r2, [r4, #0]
   32032:	2104      	movs	r1, #4
   32034:	f840 3d04 	str.w	r3, [r0, #-4]!
   32038:	f8d4 8018 	ldr.w	r8, [r4, #24]
   3203c:	f7fb fc66 	bl	2d90c <rpc_ip_client_request_alloc>
   32040:	2800      	cmp	r0, #0
   32042:	d14e      	bne.n	320e2 <ip_interface_setopt+0x11e>
   32044:	f247 0203 	movw	r2, #28675	; 0x7003
   32048:	2300      	movs	r3, #0
   3204a:	2108      	movs	r1, #8
   3204c:	9d03      	ldr	r5, [sp, #12]
   3204e:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
   32052:	60ea      	str	r2, [r5, #12]
   32054:	f8c5 8010 	str.w	r8, [r5, #16]
   32058:	7229      	strb	r1, [r5, #8]
   3205a:	726b      	strb	r3, [r5, #9]
   3205c:	72ab      	strb	r3, [r5, #10]
   3205e:	72eb      	strb	r3, [r5, #11]
   32060:	f04f 0c08 	mov.w	ip, #8
   32064:	2300      	movs	r3, #0
   32066:	2010      	movs	r0, #16
   32068:	2130      	movs	r1, #48	; 0x30
   3206a:	68aa      	ldr	r2, [r5, #8]
   3206c:	756b      	strb	r3, [r5, #21]
   3206e:	4462      	add	r2, ip
   32070:	60aa      	str	r2, [r5, #8]
   32072:	75ab      	strb	r3, [r5, #22]
   32074:	75eb      	strb	r3, [r5, #23]
   32076:	76ab      	strb	r3, [r5, #26]
   32078:	76eb      	strb	r3, [r5, #27]
   3207a:	f885 c014 	strb.w	ip, [r5, #20]
   3207e:	7628      	strb	r0, [r5, #24]
   32080:	7669      	strb	r1, [r5, #25]
   32082:	2204      	movs	r2, #4
   32084:	eb0d 010c 	add.w	r1, sp, ip
   32088:	6828      	ldr	r0, [r5, #0]
   3208a:	f00c fbdf 	bl	3e84c <memcpy>
   3208e:	f247 0103 	movw	r1, #28675	; 0x7003
   32092:	4628      	mov	r0, r5
   32094:	f7fb fc4e 	bl	2d934 <rpc_ip_client_request_send>
   32098:	4680      	mov	r8, r0
   3209a:	bb50      	cbnz	r0, 320f2 <ip_interface_setopt+0x12e>
   3209c:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   320a0:	f04f 33ff 	mov.w	r3, #4294967295
   320a4:	4611      	mov	r1, r2
   320a6:	4638      	mov	r0, r7
   320a8:	f000 fca2 	bl	329f0 <interface_socket_wait>
   320ac:	4605      	mov	r5, r0
   320ae:	b398      	cbz	r0, 32118 <ip_interface_setopt+0x154>
   320b0:	6026      	str	r6, [r4, #0]
   320b2:	e000      	b.n	320b6 <ip_interface_setopt+0xf2>
   320b4:	2523      	movs	r5, #35	; 0x23
   320b6:	4628      	mov	r0, r5
   320b8:	f7f8 fd84 	bl	2abc4 <bsd_os_errno_set>
   320bc:	f04f 35ff 	mov.w	r5, #4294967295
   320c0:	4628      	mov	r0, r5
   320c2:	b004      	add	sp, #16
   320c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   320c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   320ca:	4642      	mov	r2, r8
   320cc:	9300      	str	r3, [sp, #0]
   320ce:	4631      	mov	r1, r6
   320d0:	462b      	mov	r3, r5
   320d2:	4638      	mov	r0, r7
   320d4:	f000 fd28 	bl	32b28 <interface_socket_setopt>
   320d8:	4605      	mov	r5, r0
   320da:	4628      	mov	r0, r5
   320dc:	b004      	add	sp, #16
   320de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   320e2:	9d03      	ldr	r5, [sp, #12]
   320e4:	2d00      	cmp	r5, #0
   320e6:	d1bb      	bne.n	32060 <ip_interface_setopt+0x9c>
   320e8:	6026      	str	r6, [r4, #0]
   320ea:	250c      	movs	r5, #12
   320ec:	e7e3      	b.n	320b6 <ip_interface_setopt+0xf2>
   320ee:	2509      	movs	r5, #9
   320f0:	e7e1      	b.n	320b6 <ip_interface_setopt+0xf2>
   320f2:	6828      	ldr	r0, [r5, #0]
   320f4:	b108      	cbz	r0, 320fa <ip_interface_setopt+0x136>
   320f6:	f7fb fc3b 	bl	2d970 <rpc_ip_client_data_free>
   320fa:	4628      	mov	r0, r5
   320fc:	f7fb fc30 	bl	2d960 <rpc_ip_client_message_free>
   32100:	2523      	movs	r5, #35	; 0x23
   32102:	6026      	str	r6, [r4, #0]
   32104:	6026      	str	r6, [r4, #0]
   32106:	e7d6      	b.n	320b6 <ip_interface_setopt+0xf2>
   32108:	202a      	movs	r0, #42	; 0x2a
   3210a:	f7f8 fd5b 	bl	2abc4 <bsd_os_errno_set>
   3210e:	f04f 35ff 	mov.w	r5, #4294967295
   32112:	e7d5      	b.n	320c0 <ip_interface_setopt+0xfc>
   32114:	250e      	movs	r5, #14
   32116:	e7ce      	b.n	320b6 <ip_interface_setopt+0xf2>
   32118:	4638      	mov	r0, r7
   3211a:	f000 fcdd 	bl	32ad8 <interface_socket_from_handle_get>
   3211e:	b120      	cbz	r0, 3212a <ip_interface_setopt+0x166>
   32120:	6845      	ldr	r5, [r0, #4]
   32122:	b115      	cbz	r5, 3212a <ip_interface_setopt+0x166>
   32124:	f8c0 8004 	str.w	r8, [r0, #4]
   32128:	e7c2      	b.n	320b0 <ip_interface_setopt+0xec>
   3212a:	6026      	str	r6, [r4, #0]
   3212c:	e7c8      	b.n	320c0 <ip_interface_setopt+0xfc>
   3212e:	2009      	movs	r0, #9
   32130:	f7f8 fd48 	bl	2abc4 <bsd_os_errno_set>
   32134:	f04f 35ff 	mov.w	r5, #4294967295
   32138:	e7c2      	b.n	320c0 <ip_interface_setopt+0xfc>
   3213a:	bf00      	nop

0003213c <ip_interface_getopt>:
   3213c:	f000 bd36 	b.w	32bac <interface_socket_getopt>

00032140 <ip_interface_getaddrinfo>:
   32140:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   32144:	f04f 0c00 	mov.w	ip, #0
   32148:	2401      	movs	r4, #1
   3214a:	4e72      	ldr	r6, [pc, #456]	; (32314 <ip_interface_getaddrinfo+0x1d4>)
   3214c:	f8df a1d0 	ldr.w	sl, [pc, #464]	; 32320 <ip_interface_getaddrinfo+0x1e0>
   32150:	f8df 91d0 	ldr.w	r9, [pc, #464]	; 32324 <ip_interface_getaddrinfo+0x1e4>
   32154:	b085      	sub	sp, #20
   32156:	4607      	mov	r7, r0
   32158:	4615      	mov	r5, r2
   3215a:	9301      	str	r3, [sp, #4]
   3215c:	f8a6 c000 	strh.w	ip, [r6]
   32160:	f8ca 4000 	str.w	r4, [sl]
   32164:	f8c9 4000 	str.w	r4, [r9]
   32168:	b171      	cbz	r1, 32188 <ip_interface_getaddrinfo+0x48>
   3216a:	4608      	mov	r0, r1
   3216c:	220a      	movs	r2, #10
   3216e:	4661      	mov	r1, ip
   32170:	f007 fd70 	bl	39c54 <strtol>
   32174:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   32178:	1e42      	subs	r2, r0, #1
   3217a:	429a      	cmp	r2, r3
   3217c:	f200 8083 	bhi.w	32286 <ip_interface_getaddrinfo+0x146>
   32180:	0203      	lsls	r3, r0, #8
   32182:	ea43 2020 	orr.w	r0, r3, r0, asr #8
   32186:	8030      	strh	r0, [r6, #0]
   32188:	f8df 819c 	ldr.w	r8, [pc, #412]	; 32328 <ip_interface_getaddrinfo+0x1e8>
   3218c:	f8d8 3000 	ldr.w	r3, [r8]
   32190:	2b00      	cmp	r3, #0
   32192:	d174      	bne.n	3227e <ip_interface_getaddrinfo+0x13e>
   32194:	4a60      	ldr	r2, [pc, #384]	; (32318 <ip_interface_getaddrinfo+0x1d8>)
   32196:	6013      	str	r3, [r2, #0]
   32198:	4a60      	ldr	r2, [pc, #384]	; (3231c <ip_interface_getaddrinfo+0x1dc>)
   3219a:	6013      	str	r3, [r2, #0]
   3219c:	2f00      	cmp	r7, #0
   3219e:	d062      	beq.n	32266 <ip_interface_getaddrinfo+0x126>
   321a0:	4638      	mov	r0, r7
   321a2:	f7ea ffd9 	bl	1d158 <strlen>
   321a6:	4683      	mov	fp, r0
   321a8:	b125      	cbz	r5, 321b4 <ip_interface_getaddrinfo+0x74>
   321aa:	69ea      	ldr	r2, [r5, #28]
   321ac:	b112      	cbz	r2, 321b4 <ip_interface_getaddrinfo+0x74>
   321ae:	6851      	ldr	r1, [r2, #4]
   321b0:	2966      	cmp	r1, #102	; 0x66
   321b2:	d06c      	beq.n	3228e <ip_interface_getaddrinfo+0x14e>
   321b4:	f04f 32ff 	mov.w	r2, #4294967295
   321b8:	2100      	movs	r1, #0
   321ba:	ae04      	add	r6, sp, #16
   321bc:	f846 1d04 	str.w	r1, [r6, #-4]!
   321c0:	4630      	mov	r0, r6
   321c2:	4659      	mov	r1, fp
   321c4:	9200      	str	r2, [sp, #0]
   321c6:	f7fb fba1 	bl	2d90c <rpc_ip_client_request_alloc>
   321ca:	9a00      	ldr	r2, [sp, #0]
   321cc:	2800      	cmp	r0, #0
   321ce:	d14c      	bne.n	3226a <ip_interface_getaddrinfo+0x12a>
   321d0:	f247 010d 	movw	r1, #28685	; 0x700d
   321d4:	f04f 0c08 	mov.w	ip, #8
   321d8:	9c03      	ldr	r4, [sp, #12]
   321da:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   321de:	60e1      	str	r1, [r4, #12]
   321e0:	6122      	str	r2, [r4, #16]
   321e2:	7260      	strb	r0, [r4, #9]
   321e4:	72a0      	strb	r0, [r4, #10]
   321e6:	72e0      	strb	r0, [r4, #11]
   321e8:	f884 c008 	strb.w	ip, [r4, #8]
   321ec:	2d00      	cmp	r5, #0
   321ee:	d076      	beq.n	322de <ip_interface_getaddrinfo+0x19e>
   321f0:	686a      	ldr	r2, [r5, #4]
   321f2:	f022 0108 	bic.w	r1, r2, #8
   321f6:	2902      	cmp	r1, #2
   321f8:	d05c      	beq.n	322b4 <ip_interface_getaddrinfo+0x174>
   321fa:	2a05      	cmp	r2, #5
   321fc:	d178      	bne.n	322f0 <ip_interface_getaddrinfo+0x1b0>
   321fe:	68a9      	ldr	r1, [r5, #8]
   32200:	2902      	cmp	r1, #2
   32202:	f8c9 1000 	str.w	r1, [r9]
   32206:	d061      	beq.n	322cc <ip_interface_getaddrinfo+0x18c>
   32208:	61a2      	str	r2, [r4, #24]
   3220a:	68ea      	ldr	r2, [r5, #12]
   3220c:	6222      	str	r2, [r4, #32]
   3220e:	68aa      	ldr	r2, [r5, #8]
   32210:	61e2      	str	r2, [r4, #28]
   32212:	682a      	ldr	r2, [r5, #0]
   32214:	6162      	str	r2, [r4, #20]
   32216:	68a2      	ldr	r2, [r4, #8]
   32218:	3210      	adds	r2, #16
   3221a:	60a2      	str	r2, [r4, #8]
   3221c:	b12f      	cbz	r7, 3222a <ip_interface_getaddrinfo+0xea>
   3221e:	6820      	ldr	r0, [r4, #0]
   32220:	b118      	cbz	r0, 3222a <ip_interface_getaddrinfo+0xea>
   32222:	465a      	mov	r2, fp
   32224:	4639      	mov	r1, r7
   32226:	f00c fb11 	bl	3e84c <memcpy>
   3222a:	2301      	movs	r3, #1
   3222c:	f247 010d 	movw	r1, #28685	; 0x700d
   32230:	4620      	mov	r0, r4
   32232:	f8c8 3000 	str.w	r3, [r8]
   32236:	f7fb fb7d 	bl	2d934 <rpc_ip_client_request_send>
   3223a:	2800      	cmp	r0, #0
   3223c:	d156      	bne.n	322ec <ip_interface_getaddrinfo+0x1ac>
   3223e:	f04f 33ff 	mov.w	r3, #4294967295
   32242:	9303      	str	r3, [sp, #12]
   32244:	4631      	mov	r1, r6
   32246:	4620      	mov	r0, r4
   32248:	f7f8 fc28 	bl	2aa9c <bsd_os_timedwait>
   3224c:	f8d8 3000 	ldr.w	r3, [r8]
   32250:	2b01      	cmp	r3, #1
   32252:	d0f7      	beq.n	32244 <ip_interface_getaddrinfo+0x104>
   32254:	4b31      	ldr	r3, [pc, #196]	; (3231c <ip_interface_getaddrinfo+0x1dc>)
   32256:	6818      	ldr	r0, [r3, #0]
   32258:	2800      	cmp	r0, #0
   3225a:	d13b      	bne.n	322d4 <ip_interface_getaddrinfo+0x194>
   3225c:	4b2e      	ldr	r3, [pc, #184]	; (32318 <ip_interface_getaddrinfo+0x1d8>)
   3225e:	9a01      	ldr	r2, [sp, #4]
   32260:	681b      	ldr	r3, [r3, #0]
   32262:	6013      	str	r3, [r2, #0]
   32264:	e00c      	b.n	32280 <ip_interface_getaddrinfo+0x140>
   32266:	46bb      	mov	fp, r7
   32268:	e79e      	b.n	321a8 <ip_interface_getaddrinfo+0x68>
   3226a:	9c03      	ldr	r4, [sp, #12]
   3226c:	2c00      	cmp	r4, #0
   3226e:	d1bd      	bne.n	321ec <ip_interface_getaddrinfo+0xac>
   32270:	200c      	movs	r0, #12
   32272:	2300      	movs	r3, #0
   32274:	f8c8 3000 	str.w	r3, [r8]
   32278:	b005      	add	sp, #20
   3227a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3227e:	2073      	movs	r0, #115	; 0x73
   32280:	b005      	add	sp, #20
   32282:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   32286:	2016      	movs	r0, #22
   32288:	b005      	add	sp, #20
   3228a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3228e:	6891      	ldr	r1, [r2, #8]
   32290:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   32294:	d18e      	bne.n	321b4 <ip_interface_getaddrinfo+0x74>
   32296:	f240 2102 	movw	r1, #514	; 0x202
   3229a:	68d0      	ldr	r0, [r2, #12]
   3229c:	4288      	cmp	r0, r1
   3229e:	d189      	bne.n	321b4 <ip_interface_getaddrinfo+0x74>
   322a0:	6991      	ldr	r1, [r2, #24]
   322a2:	2900      	cmp	r1, #0
   322a4:	d086      	beq.n	321b4 <ip_interface_getaddrinfo+0x74>
   322a6:	6868      	ldr	r0, [r5, #4]
   322a8:	f7fe f9dc 	bl	30664 <pdn_interface_pdn_id_get>
   322ac:	1c43      	adds	r3, r0, #1
   322ae:	d081      	beq.n	321b4 <ip_interface_getaddrinfo+0x74>
   322b0:	4602      	mov	r2, r0
   322b2:	e781      	b.n	321b8 <ip_interface_getaddrinfo+0x78>
   322b4:	68a9      	ldr	r1, [r5, #8]
   322b6:	2902      	cmp	r1, #2
   322b8:	f8c9 1000 	str.w	r1, [r9]
   322bc:	d006      	beq.n	322cc <ip_interface_getaddrinfo+0x18c>
   322be:	2a05      	cmp	r2, #5
   322c0:	d0a2      	beq.n	32208 <ip_interface_getaddrinfo+0xc8>
   322c2:	2a0a      	cmp	r2, #10
   322c4:	bf14      	ite	ne
   322c6:	2201      	movne	r2, #1
   322c8:	2202      	moveq	r2, #2
   322ca:	e79d      	b.n	32208 <ip_interface_getaddrinfo+0xc8>
   322cc:	2102      	movs	r1, #2
   322ce:	f8ca 1000 	str.w	r1, [sl]
   322d2:	e7f4      	b.n	322be <ip_interface_getaddrinfo+0x17e>
   322d4:	4b11      	ldr	r3, [pc, #68]	; (3231c <ip_interface_getaddrinfo+0x1dc>)
   322d6:	6818      	ldr	r0, [r3, #0]
   322d8:	2800      	cmp	r0, #0
   322da:	d0d1      	beq.n	32280 <ip_interface_getaddrinfo+0x140>
   322dc:	e7c9      	b.n	32272 <ip_interface_getaddrinfo+0x132>
   322de:	4629      	mov	r1, r5
   322e0:	2210      	movs	r2, #16
   322e2:	f104 0014 	add.w	r0, r4, #20
   322e6:	f00c fad1 	bl	3e88c <memset>
   322ea:	e794      	b.n	32216 <ip_interface_getaddrinfo+0xd6>
   322ec:	2023      	movs	r0, #35	; 0x23
   322ee:	e7c0      	b.n	32272 <ip_interface_getaddrinfo+0x132>
   322f0:	202f      	movs	r0, #47	; 0x2f
   322f2:	f7f8 fc67 	bl	2abc4 <bsd_os_errno_set>
   322f6:	68a2      	ldr	r2, [r4, #8]
   322f8:	3210      	adds	r2, #16
   322fa:	60a2      	str	r2, [r4, #8]
   322fc:	b917      	cbnz	r7, 32304 <ip_interface_getaddrinfo+0x1c4>
   322fe:	f04f 30ff 	mov.w	r0, #4294967295
   32302:	e7b6      	b.n	32272 <ip_interface_getaddrinfo+0x132>
   32304:	6820      	ldr	r0, [r4, #0]
   32306:	2800      	cmp	r0, #0
   32308:	d0f9      	beq.n	322fe <ip_interface_getaddrinfo+0x1be>
   3230a:	465a      	mov	r2, fp
   3230c:	4639      	mov	r1, r7
   3230e:	f00c fa9d 	bl	3e84c <memcpy>
   32312:	e7f4      	b.n	322fe <ip_interface_getaddrinfo+0x1be>
   32314:	20029912 	.word	0x20029912
   32318:	2002532c 	.word	0x2002532c
   3231c:	20025324 	.word	0x20025324
   32320:	2002531c 	.word	0x2002531c
   32324:	20025320 	.word	0x20025320
   32328:	20025328 	.word	0x20025328

0003232c <ip_interface_freeaddrinfo>:
   3232c:	b538      	push	{r3, r4, r5, lr}
   3232e:	4c0b      	ldr	r4, [pc, #44]	; (3235c <ip_interface_freeaddrinfo+0x30>)
   32330:	6823      	ldr	r3, [r4, #0]
   32332:	2b02      	cmp	r3, #2
   32334:	d000      	beq.n	32338 <ip_interface_freeaddrinfo+0xc>
   32336:	bd38      	pop	{r3, r4, r5, pc}
   32338:	b130      	cbz	r0, 32348 <ip_interface_freeaddrinfo+0x1c>
   3233a:	4605      	mov	r5, r0
   3233c:	6940      	ldr	r0, [r0, #20]
   3233e:	f7fb fab7 	bl	2d8b0 <nrf_free>
   32342:	4628      	mov	r0, r5
   32344:	f7fb fab4 	bl	2d8b0 <nrf_free>
   32348:	2300      	movs	r3, #0
   3234a:	4a05      	ldr	r2, [pc, #20]	; (32360 <ip_interface_freeaddrinfo+0x34>)
   3234c:	4905      	ldr	r1, [pc, #20]	; (32364 <ip_interface_freeaddrinfo+0x38>)
   3234e:	6023      	str	r3, [r4, #0]
   32350:	6013      	str	r3, [r2, #0]
   32352:	6808      	ldr	r0, [r1, #0]
   32354:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   32358:	f7fb bb0a 	b.w	2d970 <rpc_ip_client_data_free>
   3235c:	20025328 	.word	0x20025328
   32360:	20025324 	.word	0x20025324
   32364:	20025330 	.word	0x20025330

00032368 <rpc_ip_event_handler>:
   32368:	f248 030d 	movw	r3, #32781	; 0x800d
   3236c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   32370:	4299      	cmp	r1, r3
   32372:	b089      	sub	sp, #36	; 0x24
   32374:	4605      	mov	r5, r0
   32376:	d062      	beq.n	3243e <rpc_ip_event_handler+0xd6>
   32378:	f248 030f 	movw	r3, #32783	; 0x800f
   3237c:	4299      	cmp	r1, r3
   3237e:	460c      	mov	r4, r1
   32380:	d04b      	beq.n	3241a <rpc_ip_event_handler+0xb2>
   32382:	f401 4310 	and.w	r3, r1, #36864	; 0x9000
   32386:	f5b3 4f10 	cmp.w	r3, #36864	; 0x9000
   3238a:	68c0      	ldr	r0, [r0, #12]
   3238c:	d07b      	beq.n	32486 <rpc_ip_event_handler+0x11e>
   3238e:	0c07      	lsrs	r7, r0, #16
   32390:	4638      	mov	r0, r7
   32392:	f000 fba1 	bl	32ad8 <interface_socket_from_handle_get>
   32396:	4606      	mov	r6, r0
   32398:	2800      	cmp	r0, #0
   3239a:	d05f      	beq.n	3245c <rpc_ip_event_handler+0xf4>
   3239c:	4601      	mov	r1, r0
   3239e:	4623      	mov	r3, r4
   323a0:	462a      	mov	r2, r5
   323a2:	4638      	mov	r0, r7
   323a4:	f7fb ff1c 	bl	2e1e0 <tls_rpc_ip_event_handler>
   323a8:	2800      	cmp	r0, #0
   323aa:	d053      	beq.n	32454 <rpc_ip_event_handler+0xec>
   323ac:	f248 0307 	movw	r3, #32775	; 0x8007
   323b0:	429c      	cmp	r4, r3
   323b2:	d97d      	bls.n	324b0 <rpc_ip_event_handler+0x148>
   323b4:	f248 030c 	movw	r3, #32780	; 0x800c
   323b8:	429c      	cmp	r4, r3
   323ba:	d068      	beq.n	3248e <rpc_ip_event_handler+0x126>
   323bc:	f240 8119 	bls.w	325f2 <rpc_ip_event_handler+0x28a>
   323c0:	f249 0302 	movw	r3, #36866	; 0x9002
   323c4:	429c      	cmp	r4, r3
   323c6:	f000 8195 	beq.w	326f4 <rpc_ip_event_handler+0x38c>
   323ca:	f249 0303 	movw	r3, #36867	; 0x9003
   323ce:	429c      	cmp	r4, r3
   323d0:	f000 81aa 	beq.w	32728 <rpc_ip_event_handler+0x3c0>
   323d4:	f249 0301 	movw	r3, #36865	; 0x9001
   323d8:	429c      	cmp	r4, r3
   323da:	d13f      	bne.n	3245c <rpc_ip_event_handler+0xf4>
   323dc:	6834      	ldr	r4, [r6, #0]
   323de:	f414 1480 	ands.w	r4, r4, #1048576	; 0x100000
   323e2:	f000 81c2 	beq.w	3276a <rpc_ip_event_handler+0x402>
   323e6:	68ab      	ldr	r3, [r5, #8]
   323e8:	2b04      	cmp	r3, #4
   323ea:	f200 81ff 	bhi.w	327ec <rpc_ip_event_handler+0x484>
   323ee:	2400      	movs	r4, #0
   323f0:	4627      	mov	r7, r4
   323f2:	6829      	ldr	r1, [r5, #0]
   323f4:	686a      	ldr	r2, [r5, #4]
   323f6:	e9cd 7406 	strd	r7, r4, [sp, #24]
   323fa:	e9cd 1204 	strd	r1, r2, [sp, #16]
   323fe:	69f0      	ldr	r0, [r6, #28]
   32400:	a904      	add	r1, sp, #16
   32402:	6803      	ldr	r3, [r0, #0]
   32404:	685b      	ldr	r3, [r3, #4]
   32406:	4798      	blx	r3
   32408:	3001      	adds	r0, #1
   3240a:	f000 81db 	beq.w	327c4 <rpc_ip_event_handler+0x45c>
   3240e:	6833      	ldr	r3, [r6, #0]
   32410:	2000      	movs	r0, #0
   32412:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   32416:	6033      	str	r3, [r6, #0]
   32418:	e00e      	b.n	32438 <rpc_ip_event_handler+0xd0>
   3241a:	6943      	ldr	r3, [r0, #20]
   3241c:	2001      	movs	r0, #1
   3241e:	2b10      	cmp	r3, #16
   32420:	49b7      	ldr	r1, [pc, #732]	; (32700 <rpc_ip_event_handler+0x398>)
   32422:	bf88      	it	hi
   32424:	222d      	movhi	r2, #45	; 0x2d
   32426:	7008      	strb	r0, [r1, #0]
   32428:	f04f 0000 	mov.w	r0, #0
   3242c:	bf9c      	itt	ls
   3242e:	4ab5      	ldrls	r2, [pc, #724]	; (32704 <rpc_ip_event_handler+0x39c>)
   32430:	f852 2023 	ldrls.w	r2, [r2, r3, lsl #2]
   32434:	4bb4      	ldr	r3, [pc, #720]	; (32708 <rpc_ip_event_handler+0x3a0>)
   32436:	601a      	str	r2, [r3, #0]
   32438:	b009      	add	sp, #36	; 0x24
   3243a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3243e:	f8df 92dc 	ldr.w	r9, [pc, #732]	; 3271c <rpc_ip_event_handler+0x3b4>
   32442:	6807      	ldr	r7, [r0, #0]
   32444:	f8d9 3000 	ldr.w	r3, [r9]
   32448:	2b01      	cmp	r3, #1
   3244a:	d00b      	beq.n	32464 <rpc_ip_event_handler+0xfc>
   3244c:	b117      	cbz	r7, 32454 <rpc_ip_event_handler+0xec>
   3244e:	4638      	mov	r0, r7
   32450:	f7fb fa8e 	bl	2d970 <rpc_ip_client_data_free>
   32454:	2000      	movs	r0, #0
   32456:	b009      	add	sp, #36	; 0x24
   32458:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3245c:	6828      	ldr	r0, [r5, #0]
   3245e:	2800      	cmp	r0, #0
   32460:	d1f6      	bne.n	32450 <rpc_ip_event_handler+0xe8>
   32462:	e7f7      	b.n	32454 <rpc_ip_event_handler+0xec>
   32464:	6943      	ldr	r3, [r0, #20]
   32466:	2b00      	cmp	r3, #0
   32468:	d046      	beq.n	324f8 <rpc_ip_event_handler+0x190>
   3246a:	2b10      	cmp	r3, #16
   3246c:	bf96      	itet	ls
   3246e:	4aa5      	ldrls	r2, [pc, #660]	; (32704 <rpc_ip_event_handler+0x39c>)
   32470:	232d      	movhi	r3, #45	; 0x2d
   32472:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
   32476:	2202      	movs	r2, #2
   32478:	49a4      	ldr	r1, [pc, #656]	; (3270c <rpc_ip_event_handler+0x3a4>)
   3247a:	600b      	str	r3, [r1, #0]
   3247c:	f8c9 2000 	str.w	r2, [r9]
   32480:	2f00      	cmp	r7, #0
   32482:	d1e4      	bne.n	3244e <rpc_ip_event_handler+0xe6>
   32484:	e7e6      	b.n	32454 <rpc_ip_event_handler+0xec>
   32486:	f000 fad5 	bl	32a34 <interface_from_internal_id_search>
   3248a:	4607      	mov	r7, r0
   3248c:	e780      	b.n	32390 <rpc_ip_event_handler+0x28>
   3248e:	6833      	ldr	r3, [r6, #0]
   32490:	b29b      	uxth	r3, r3
   32492:	2b08      	cmp	r3, #8
   32494:	d1de      	bne.n	32454 <rpc_ip_event_handler+0xec>
   32496:	696b      	ldr	r3, [r5, #20]
   32498:	2b00      	cmp	r3, #0
   3249a:	f000 819c 	beq.w	327d6 <rpc_ip_event_handler+0x46e>
   3249e:	2b10      	cmp	r3, #16
   324a0:	f200 8161 	bhi.w	32766 <rpc_ip_event_handler+0x3fe>
   324a4:	4a97      	ldr	r2, [pc, #604]	; (32704 <rpc_ip_event_handler+0x39c>)
   324a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   324aa:	6073      	str	r3, [r6, #4]
   324ac:	2000      	movs	r0, #0
   324ae:	e7c3      	b.n	32438 <rpc_ip_event_handler+0xd0>
   324b0:	f248 0306 	movw	r3, #32774	; 0x8006
   324b4:	429c      	cmp	r4, r3
   324b6:	f080 810d 	bcs.w	326d4 <rpc_ip_event_handler+0x36c>
   324ba:	f248 0302 	movw	r3, #32770	; 0x8002
   324be:	429c      	cmp	r4, r3
   324c0:	f000 80f0 	beq.w	326a4 <rpc_ip_event_handler+0x33c>
   324c4:	f240 80be 	bls.w	32644 <rpc_ip_event_handler+0x2dc>
   324c8:	f248 0303 	movw	r3, #32771	; 0x8003
   324cc:	429c      	cmp	r4, r3
   324ce:	f000 80ca 	beq.w	32666 <rpc_ip_event_handler+0x2fe>
   324d2:	f248 0305 	movw	r3, #32773	; 0x8005
   324d6:	429c      	cmp	r4, r3
   324d8:	d1c0      	bne.n	3245c <rpc_ip_event_handler+0xf4>
   324da:	6833      	ldr	r3, [r6, #0]
   324dc:	b29b      	uxth	r3, r3
   324de:	2b03      	cmp	r3, #3
   324e0:	d1b8      	bne.n	32454 <rpc_ip_event_handler+0xec>
   324e2:	696b      	ldr	r3, [r5, #20]
   324e4:	2b00      	cmp	r3, #0
   324e6:	d1da      	bne.n	3249e <rpc_ip_event_handler+0x136>
   324e8:	6833      	ldr	r3, [r6, #0]
   324ea:	2000      	movs	r0, #0
   324ec:	0c1b      	lsrs	r3, r3, #16
   324ee:	041b      	lsls	r3, r3, #16
   324f0:	f043 0304 	orr.w	r3, r3, #4
   324f4:	6033      	str	r3, [r6, #0]
   324f6:	e79f      	b.n	32438 <rpc_ip_event_handler+0xd0>
   324f8:	4b85      	ldr	r3, [pc, #532]	; (32710 <rpc_ip_event_handler+0x3a8>)
   324fa:	601f      	str	r7, [r3, #0]
   324fc:	6984      	ldr	r4, [r0, #24]
   324fe:	0163      	lsls	r3, r4, #5
   32500:	4618      	mov	r0, r3
   32502:	9303      	str	r3, [sp, #12]
   32504:	f7fb f9ca 	bl	2d89c <nrf_malloc>
   32508:	9002      	str	r0, [sp, #8]
   3250a:	2800      	cmp	r0, #0
   3250c:	f000 808a 	beq.w	32624 <rpc_ip_event_handler+0x2bc>
   32510:	00e5      	lsls	r5, r4, #3
   32512:	1928      	adds	r0, r5, r4
   32514:	0080      	lsls	r0, r0, #2
   32516:	f7fb f9c1 	bl	2d89c <nrf_malloc>
   3251a:	2800      	cmp	r0, #0
   3251c:	f000 811f 	beq.w	3275e <rpc_ip_event_handler+0x3f6>
   32520:	2c00      	cmp	r4, #0
   32522:	d05e      	beq.n	325e2 <rpc_ip_event_handler+0x27a>
   32524:	3510      	adds	r5, #16
   32526:	1943      	adds	r3, r0, r5
   32528:	9301      	str	r3, [sp, #4]
   3252a:	9b02      	ldr	r3, [sp, #8]
   3252c:	2404      	movs	r4, #4
   3252e:	f8df a1f0 	ldr.w	sl, [pc, #496]	; 32720 <rpc_ip_event_handler+0x3b8>
   32532:	f8df b1f0 	ldr.w	fp, [pc, #496]	; 32724 <rpc_ip_event_handler+0x3bc>
   32536:	f100 0810 	add.w	r8, r0, #16
   3253a:	f103 0620 	add.w	r6, r3, #32
   3253e:	e01d      	b.n	3257c <rpc_ip_event_handler+0x214>
   32540:	220a      	movs	r2, #10
   32542:	f848 2c0c 	str.w	r2, [r8, #-12]
   32546:	f04f 0224 	mov.w	r2, #36	; 0x24
   3254a:	4640      	mov	r0, r8
   3254c:	f808 2c10 	strb.w	r2, [r8, #-16]
   32550:	f828 3c08 	strh.w	r3, [r8, #-8]
   32554:	f856 2c10 	ldr.w	r2, [r6, #-16]
   32558:	f00c f978 	bl	3e84c <memcpy>
   3255c:	f856 3c10 	ldr.w	r3, [r6, #-16]
   32560:	f108 0808 	add.w	r8, r8, #8
   32564:	441c      	add	r4, r3
   32566:	193b      	adds	r3, r7, r4
   32568:	f846 3c08 	str.w	r3, [r6, #-8]
   3256c:	9b01      	ldr	r3, [sp, #4]
   3256e:	f846 6c04 	str.w	r6, [r6, #-4]
   32572:	4598      	cmp	r8, r3
   32574:	442c      	add	r4, r5
   32576:	f106 0620 	add.w	r6, r6, #32
   3257a:	d02c      	beq.n	325d6 <rpc_ip_event_handler+0x26e>
   3257c:	593b      	ldr	r3, [r7, r4]
   3257e:	193a      	adds	r2, r7, r4
   32580:	f846 3c20 	str.w	r3, [r6, #-32]
   32584:	6853      	ldr	r3, [r2, #4]
   32586:	f8da 1000 	ldr.w	r1, [sl]
   3258a:	2b02      	cmp	r3, #2
   3258c:	bf14      	ite	ne
   3258e:	2002      	movne	r0, #2
   32590:	200a      	moveq	r0, #10
   32592:	f8db 3000 	ldr.w	r3, [fp]
   32596:	e946 0107 	strd	r0, r1, [r6, #-28]
   3259a:	f846 3c14 	str.w	r3, [r6, #-20]
   3259e:	8a10      	ldrh	r0, [r2, #16]
   325a0:	f1a8 0310 	sub.w	r3, r8, #16
   325a4:	f846 0c10 	str.w	r0, [r6, #-16]
   325a8:	8a55      	ldrh	r5, [r2, #18]
   325aa:	f846 3c0c 	str.w	r3, [r6, #-12]
   325ae:	4b59      	ldr	r3, [pc, #356]	; (32714 <rpc_ip_event_handler+0x3ac>)
   325b0:	3414      	adds	r4, #20
   325b2:	2804      	cmp	r0, #4
   325b4:	eb07 0104 	add.w	r1, r7, r4
   325b8:	881b      	ldrh	r3, [r3, #0]
   325ba:	d1c1      	bne.n	32540 <rpc_ip_event_handler+0x1d8>
   325bc:	2210      	movs	r2, #16
   325be:	2002      	movs	r0, #2
   325c0:	f828 3c08 	strh.w	r3, [r8, #-8]
   325c4:	f848 0c0c 	str.w	r0, [r8, #-12]
   325c8:	f808 2c10 	strb.w	r2, [r8, #-16]
   325cc:	f856 2c10 	ldr.w	r2, [r6, #-16]
   325d0:	f1a8 0004 	sub.w	r0, r8, #4
   325d4:	e7c0      	b.n	32558 <rpc_ip_event_handler+0x1f0>
   325d6:	2200      	movs	r2, #0
   325d8:	e9dd 1302 	ldrd	r1, r3, [sp, #8]
   325dc:	440b      	add	r3, r1
   325de:	f843 2c04 	str.w	r2, [r3, #-4]
   325e2:	2202      	movs	r2, #2
   325e4:	4b4c      	ldr	r3, [pc, #304]	; (32718 <rpc_ip_event_handler+0x3b0>)
   325e6:	f8c9 2000 	str.w	r2, [r9]
   325ea:	9a02      	ldr	r2, [sp, #8]
   325ec:	2000      	movs	r0, #0
   325ee:	601a      	str	r2, [r3, #0]
   325f0:	e722      	b.n	32438 <rpc_ip_event_handler+0xd0>
   325f2:	f248 0308 	movw	r3, #32776	; 0x8008
   325f6:	429c      	cmp	r4, r3
   325f8:	d045      	beq.n	32686 <rpc_ip_event_handler+0x31e>
   325fa:	f248 0309 	movw	r3, #32777	; 0x8009
   325fe:	429c      	cmp	r4, r3
   32600:	f47f af2c 	bne.w	3245c <rpc_ip_event_handler+0xf4>
   32604:	6833      	ldr	r3, [r6, #0]
   32606:	b29b      	uxth	r3, r3
   32608:	2b0d      	cmp	r3, #13
   3260a:	f47f af23 	bne.w	32454 <rpc_ip_event_handler+0xec>
   3260e:	6968      	ldr	r0, [r5, #20]
   32610:	2800      	cmp	r0, #0
   32612:	f000 80d9 	beq.w	327c8 <rpc_ip_event_handler+0x460>
   32616:	2810      	cmp	r0, #16
   32618:	f200 80a5 	bhi.w	32766 <rpc_ip_event_handler+0x3fe>
   3261c:	4b39      	ldr	r3, [pc, #228]	; (32704 <rpc_ip_event_handler+0x39c>)
   3261e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   32622:	e742      	b.n	324aa <rpc_ip_event_handler+0x142>
   32624:	f7fb f944 	bl	2d8b0 <nrf_free>
   32628:	200c      	movs	r0, #12
   3262a:	2302      	movs	r3, #2
   3262c:	4937      	ldr	r1, [pc, #220]	; (3270c <rpc_ip_event_handler+0x3a4>)
   3262e:	4a3a      	ldr	r2, [pc, #232]	; (32718 <rpc_ip_event_handler+0x3b0>)
   32630:	6008      	str	r0, [r1, #0]
   32632:	682f      	ldr	r7, [r5, #0]
   32634:	9902      	ldr	r1, [sp, #8]
   32636:	f8c9 3000 	str.w	r3, [r9]
   3263a:	6011      	str	r1, [r2, #0]
   3263c:	2f00      	cmp	r7, #0
   3263e:	f47f af06 	bne.w	3244e <rpc_ip_event_handler+0xe6>
   32642:	e707      	b.n	32454 <rpc_ip_event_handler+0xec>
   32644:	f248 0301 	movw	r3, #32769	; 0x8001
   32648:	429c      	cmp	r4, r3
   3264a:	f47f af07 	bne.w	3245c <rpc_ip_event_handler+0xf4>
   3264e:	6833      	ldr	r3, [r6, #0]
   32650:	2b01      	cmp	r3, #1
   32652:	f47f aeff 	bne.w	32454 <rpc_ip_event_handler+0xec>
   32656:	6968      	ldr	r0, [r5, #20]
   32658:	2800      	cmp	r0, #0
   3265a:	d1dc      	bne.n	32616 <rpc_ip_event_handler+0x2ae>
   3265c:	2302      	movs	r3, #2
   3265e:	6033      	str	r3, [r6, #0]
   32660:	69ab      	ldr	r3, [r5, #24]
   32662:	61b3      	str	r3, [r6, #24]
   32664:	e6e8      	b.n	32438 <rpc_ip_event_handler+0xd0>
   32666:	6833      	ldr	r3, [r6, #0]
   32668:	025b      	lsls	r3, r3, #9
   3266a:	f57f aef3 	bpl.w	32454 <rpc_ip_event_handler+0xec>
   3266e:	6968      	ldr	r0, [r5, #20]
   32670:	2800      	cmp	r0, #0
   32672:	f000 80a0 	beq.w	327b6 <rpc_ip_event_handler+0x44e>
   32676:	2810      	cmp	r0, #16
   32678:	bf8e      	itee	hi
   3267a:	232d      	movhi	r3, #45	; 0x2d
   3267c:	4b21      	ldrls	r3, [pc, #132]	; (32704 <rpc_ip_event_handler+0x39c>)
   3267e:	f853 3020 	ldrls.w	r3, [r3, r0, lsl #2]
   32682:	6073      	str	r3, [r6, #4]
   32684:	e6e6      	b.n	32454 <rpc_ip_event_handler+0xec>
   32686:	6833      	ldr	r3, [r6, #0]
   32688:	b29b      	uxth	r3, r3
   3268a:	2b06      	cmp	r3, #6
   3268c:	f47f aee2 	bne.w	32454 <rpc_ip_event_handler+0xec>
   32690:	6968      	ldr	r0, [r5, #20]
   32692:	2800      	cmp	r0, #0
   32694:	d1bf      	bne.n	32616 <rpc_ip_event_handler+0x2ae>
   32696:	6833      	ldr	r3, [r6, #0]
   32698:	0c1b      	lsrs	r3, r3, #16
   3269a:	041b      	lsls	r3, r3, #16
   3269c:	f043 0307 	orr.w	r3, r3, #7
   326a0:	6033      	str	r3, [r6, #0]
   326a2:	e6c9      	b.n	32438 <rpc_ip_event_handler+0xd0>
   326a4:	6833      	ldr	r3, [r6, #0]
   326a6:	0099      	lsls	r1, r3, #2
   326a8:	f57f aed4 	bpl.w	32454 <rpc_ip_event_handler+0xec>
   326ac:	6833      	ldr	r3, [r6, #0]
   326ae:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   326b2:	6033      	str	r3, [r6, #0]
   326b4:	6968      	ldr	r0, [r5, #20]
   326b6:	2800      	cmp	r0, #0
   326b8:	d06e      	beq.n	32798 <rpc_ip_event_handler+0x430>
   326ba:	2810      	cmp	r0, #16
   326bc:	f200 8080 	bhi.w	327c0 <rpc_ip_event_handler+0x458>
   326c0:	4b10      	ldr	r3, [pc, #64]	; (32704 <rpc_ip_event_handler+0x39c>)
   326c2:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   326c6:	6073      	str	r3, [r6, #4]
   326c8:	6833      	ldr	r3, [r6, #0]
   326ca:	2000      	movs	r0, #0
   326cc:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   326d0:	6033      	str	r3, [r6, #0]
   326d2:	e6b1      	b.n	32438 <rpc_ip_event_handler+0xd0>
   326d4:	6833      	ldr	r3, [r6, #0]
   326d6:	029a      	lsls	r2, r3, #10
   326d8:	f57f aebc 	bpl.w	32454 <rpc_ip_event_handler+0xec>
   326dc:	696b      	ldr	r3, [r5, #20]
   326de:	2b00      	cmp	r3, #0
   326e0:	d051      	beq.n	32786 <rpc_ip_event_handler+0x41e>
   326e2:	2b6b      	cmp	r3, #107	; 0x6b
   326e4:	f000 8086 	beq.w	327f4 <rpc_ip_event_handler+0x48c>
   326e8:	2b10      	cmp	r3, #16
   326ea:	d869      	bhi.n	327c0 <rpc_ip_event_handler+0x458>
   326ec:	4a05      	ldr	r2, [pc, #20]	; (32704 <rpc_ip_event_handler+0x39c>)
   326ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   326f2:	e7e8      	b.n	326c6 <rpc_ip_event_handler+0x35e>
   326f4:	6833      	ldr	r3, [r6, #0]
   326f6:	b29b      	uxth	r3, r3
   326f8:	2b07      	cmp	r3, #7
   326fa:	f47f aeab 	bne.w	32454 <rpc_ip_event_handler+0xec>
   326fe:	e686      	b.n	3240e <rpc_ip_event_handler+0xa6>
   32700:	2002d7f1 	.word	0x2002d7f1
   32704:	000402b4 	.word	0x000402b4
   32708:	20025358 	.word	0x20025358
   3270c:	20025324 	.word	0x20025324
   32710:	20025330 	.word	0x20025330
   32714:	20029912 	.word	0x20029912
   32718:	2002532c 	.word	0x2002532c
   3271c:	20025328 	.word	0x20025328
   32720:	20025320 	.word	0x20025320
   32724:	2002531c 	.word	0x2002531c
   32728:	6833      	ldr	r3, [r6, #0]
   3272a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
   3272e:	6033      	str	r3, [r6, #0]
   32730:	6833      	ldr	r3, [r6, #0]
   32732:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   32736:	6033      	str	r3, [r6, #0]
   32738:	6833      	ldr	r3, [r6, #0]
   3273a:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   3273e:	6033      	str	r3, [r6, #0]
   32740:	692b      	ldr	r3, [r5, #16]
   32742:	2b6c      	cmp	r3, #108	; 0x6c
   32744:	d016      	beq.n	32774 <rpc_ip_event_handler+0x40c>
   32746:	2b10      	cmp	r3, #16
   32748:	bf8c      	ite	hi
   3274a:	232d      	movhi	r3, #45	; 0x2d
   3274c:	4a46      	ldrls	r2, [pc, #280]	; (32868 <rpc_ip_event_handler+0x500>)
   3274e:	f04f 0000 	mov.w	r0, #0
   32752:	bf98      	it	ls
   32754:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
   32758:	6073      	str	r3, [r6, #4]
   3275a:	60b3      	str	r3, [r6, #8]
   3275c:	e66c      	b.n	32438 <rpc_ip_event_handler+0xd0>
   3275e:	220c      	movs	r2, #12
   32760:	4b42      	ldr	r3, [pc, #264]	; (3286c <rpc_ip_event_handler+0x504>)
   32762:	601a      	str	r2, [r3, #0]
   32764:	e73d      	b.n	325e2 <rpc_ip_event_handler+0x27a>
   32766:	232d      	movs	r3, #45	; 0x2d
   32768:	e69f      	b.n	324aa <rpc_ip_event_handler+0x142>
   3276a:	6828      	ldr	r0, [r5, #0]
   3276c:	f7fb f900 	bl	2d970 <rpc_ip_client_data_free>
   32770:	4620      	mov	r0, r4
   32772:	e661      	b.n	32438 <rpc_ip_event_handler+0xd0>
   32774:	2239      	movs	r2, #57	; 0x39
   32776:	6833      	ldr	r3, [r6, #0]
   32778:	2000      	movs	r0, #0
   3277a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   3277e:	6033      	str	r3, [r6, #0]
   32780:	6072      	str	r2, [r6, #4]
   32782:	60b2      	str	r2, [r6, #8]
   32784:	e658      	b.n	32438 <rpc_ip_event_handler+0xd0>
   32786:	6833      	ldr	r3, [r6, #0]
   32788:	4a39      	ldr	r2, [pc, #228]	; (32870 <rpc_ip_event_handler+0x508>)
   3278a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   3278e:	6033      	str	r3, [r6, #0]
   32790:	2001      	movs	r0, #1
   32792:	f842 5027 	str.w	r5, [r2, r7, lsl #2]
   32796:	e64f      	b.n	32438 <rpc_ip_event_handler+0xd0>
   32798:	6833      	ldr	r3, [r6, #0]
   3279a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   3279e:	6033      	str	r3, [r6, #0]
   327a0:	6833      	ldr	r3, [r6, #0]
   327a2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   327a6:	6033      	str	r3, [r6, #0]
   327a8:	6833      	ldr	r3, [r6, #0]
   327aa:	0c1b      	lsrs	r3, r3, #16
   327ac:	041b      	lsls	r3, r3, #16
   327ae:	f043 0305 	orr.w	r3, r3, #5
   327b2:	6033      	str	r3, [r6, #0]
   327b4:	e640      	b.n	32438 <rpc_ip_event_handler+0xd0>
   327b6:	6833      	ldr	r3, [r6, #0]
   327b8:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   327bc:	6033      	str	r3, [r6, #0]
   327be:	e63b      	b.n	32438 <rpc_ip_event_handler+0xd0>
   327c0:	232d      	movs	r3, #45	; 0x2d
   327c2:	e780      	b.n	326c6 <rpc_ip_event_handler+0x35e>
   327c4:	2002      	movs	r0, #2
   327c6:	e637      	b.n	32438 <rpc_ip_event_handler+0xd0>
   327c8:	6833      	ldr	r3, [r6, #0]
   327ca:	0c1b      	lsrs	r3, r3, #16
   327cc:	041b      	lsls	r3, r3, #16
   327ce:	f043 030e 	orr.w	r3, r3, #14
   327d2:	6033      	str	r3, [r6, #0]
   327d4:	e630      	b.n	32438 <rpc_ip_event_handler+0xd0>
   327d6:	4b26      	ldr	r3, [pc, #152]	; (32870 <rpc_ip_event_handler+0x508>)
   327d8:	2001      	movs	r0, #1
   327da:	f843 5027 	str.w	r5, [r3, r7, lsl #2]
   327de:	6833      	ldr	r3, [r6, #0]
   327e0:	0c1b      	lsrs	r3, r3, #16
   327e2:	041b      	lsls	r3, r3, #16
   327e4:	f043 0309 	orr.w	r3, r3, #9
   327e8:	6033      	str	r3, [r6, #0]
   327ea:	e625      	b.n	32438 <rpc_ip_event_handler+0xd0>
   327ec:	8a6c      	ldrh	r4, [r5, #18]
   327ee:	b934      	cbnz	r4, 327fe <rpc_ip_event_handler+0x496>
   327f0:	4627      	mov	r7, r4
   327f2:	e5fe      	b.n	323f2 <rpc_ip_event_handler+0x8a>
   327f4:	6933      	ldr	r3, [r6, #16]
   327f6:	2b01      	cmp	r3, #1
   327f8:	d012      	beq.n	32820 <rpc_ip_event_handler+0x4b8>
   327fa:	230c      	movs	r3, #12
   327fc:	e763      	b.n	326c6 <rpc_ip_event_handler+0x35e>
   327fe:	2024      	movs	r0, #36	; 0x24
   32800:	f7fb f84c 	bl	2d89c <nrf_malloc>
   32804:	4607      	mov	r7, r0
   32806:	b358      	cbz	r0, 32860 <rpc_ip_event_handler+0x4f8>
   32808:	8a6a      	ldrh	r2, [r5, #18]
   3280a:	2a10      	cmp	r2, #16
   3280c:	d01c      	beq.n	32848 <rpc_ip_event_handler+0x4e0>
   3280e:	2a04      	cmp	r2, #4
   32810:	d00e      	beq.n	32830 <rpc_ip_event_handler+0x4c8>
   32812:	6828      	ldr	r0, [r5, #0]
   32814:	f7fb f8ac 	bl	2d970 <rpc_ip_client_data_free>
   32818:	4638      	mov	r0, r7
   3281a:	f7fb f849 	bl	2d8b0 <nrf_free>
   3281e:	e619      	b.n	32454 <rpc_ip_event_handler+0xec>
   32820:	220c      	movs	r2, #12
   32822:	6833      	ldr	r3, [r6, #0]
   32824:	2000      	movs	r0, #0
   32826:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   3282a:	6033      	str	r3, [r6, #0]
   3282c:	6072      	str	r2, [r6, #4]
   3282e:	e603      	b.n	32438 <rpc_ip_event_handler+0xd0>
   32830:	2302      	movs	r3, #2
   32832:	2410      	movs	r4, #16
   32834:	6043      	str	r3, [r0, #4]
   32836:	7004      	strb	r4, [r0, #0]
   32838:	8a2b      	ldrh	r3, [r5, #16]
   3283a:	f105 0114 	add.w	r1, r5, #20
   3283e:	8103      	strh	r3, [r0, #8]
   32840:	300c      	adds	r0, #12
   32842:	f00c f803 	bl	3e84c <memcpy>
   32846:	e5d4      	b.n	323f2 <rpc_ip_event_handler+0x8a>
   32848:	230a      	movs	r3, #10
   3284a:	2424      	movs	r4, #36	; 0x24
   3284c:	6043      	str	r3, [r0, #4]
   3284e:	7004      	strb	r4, [r0, #0]
   32850:	8a2b      	ldrh	r3, [r5, #16]
   32852:	f105 0114 	add.w	r1, r5, #20
   32856:	8103      	strh	r3, [r0, #8]
   32858:	3010      	adds	r0, #16
   3285a:	f00b fff7 	bl	3e84c <memcpy>
   3285e:	e5c8      	b.n	323f2 <rpc_ip_event_handler+0x8a>
   32860:	6828      	ldr	r0, [r5, #0]
   32862:	f7fb f885 	bl	2d970 <rpc_ip_client_data_free>
   32866:	e5f5      	b.n	32454 <rpc_ip_event_handler+0xec>
   32868:	000402b4 	.word	0x000402b4
   3286c:	20025324 	.word	0x20025324
   32870:	20025334 	.word	0x20025334

00032874 <interface_init>:
   32874:	b508      	push	{r3, lr}
   32876:	f44f 72a2 	mov.w	r2, #324	; 0x144
   3287a:	2100      	movs	r1, #0
   3287c:	4802      	ldr	r0, [pc, #8]	; (32888 <interface_init+0x14>)
   3287e:	f00c f805 	bl	3e88c <memset>
   32882:	2000      	movs	r0, #0
   32884:	bd08      	pop	{r3, pc}
   32886:	bf00      	nop
   32888:	2002d7f4 	.word	0x2002d7f4

0003288c <interface_socket_allocate>:
   3288c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3288e:	4b30      	ldr	r3, [pc, #192]	; (32950 <interface_socket_allocate+0xc4>)
   32890:	4606      	mov	r6, r0
   32892:	681d      	ldr	r5, [r3, #0]
   32894:	4608      	mov	r0, r1
   32896:	b31d      	cbz	r5, 328e0 <interface_socket_allocate+0x54>
   32898:	6a5c      	ldr	r4, [r3, #36]	; 0x24
   3289a:	2c00      	cmp	r4, #0
   3289c:	d04a      	beq.n	32934 <interface_socket_allocate+0xa8>
   3289e:	6c9c      	ldr	r4, [r3, #72]	; 0x48
   328a0:	2c00      	cmp	r4, #0
   328a2:	d049      	beq.n	32938 <interface_socket_allocate+0xac>
   328a4:	6edc      	ldr	r4, [r3, #108]	; 0x6c
   328a6:	2c00      	cmp	r4, #0
   328a8:	d048      	beq.n	3293c <interface_socket_allocate+0xb0>
   328aa:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
   328ae:	2900      	cmp	r1, #0
   328b0:	d046      	beq.n	32940 <interface_socket_allocate+0xb4>
   328b2:	f8d3 10b4 	ldr.w	r1, [r3, #180]	; 0xb4
   328b6:	b191      	cbz	r1, 328de <interface_socket_allocate+0x52>
   328b8:	f8d3 10d8 	ldr.w	r1, [r3, #216]	; 0xd8
   328bc:	2900      	cmp	r1, #0
   328be:	d043      	beq.n	32948 <interface_socket_allocate+0xbc>
   328c0:	f8d3 10fc 	ldr.w	r1, [r3, #252]	; 0xfc
   328c4:	2900      	cmp	r1, #0
   328c6:	d041      	beq.n	3294c <interface_socket_allocate+0xc0>
   328c8:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
   328cc:	2900      	cmp	r1, #0
   328ce:	d039      	beq.n	32944 <interface_socket_allocate+0xb8>
   328d0:	f04f 35ff 	mov.w	r5, #4294967295
   328d4:	2069      	movs	r0, #105	; 0x69
   328d6:	f7f8 f975 	bl	2abc4 <bsd_os_errno_set>
   328da:	4628      	mov	r0, r5
   328dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   328de:	2505      	movs	r5, #5
   328e0:	f04f 0c01 	mov.w	ip, #1
   328e4:	f04f 37ff 	mov.w	r7, #4294967295
   328e8:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   328ec:	00a4      	lsls	r4, r4, #2
   328ee:	f843 c004 	str.w	ip, [r3, r4]
   328f2:	441c      	add	r4, r3
   328f4:	4611      	mov	r1, r2
   328f6:	61a7      	str	r7, [r4, #24]
   328f8:	4622      	mov	r2, r4
   328fa:	f001 ffd1 	bl	348a0 <packet_handler_create>
   328fe:	4603      	mov	r3, r0
   32900:	61e0      	str	r0, [r4, #28]
   32902:	b158      	cbz	r0, 3291c <interface_socket_allocate+0x90>
   32904:	681b      	ldr	r3, [r3, #0]
   32906:	681b      	ldr	r3, [r3, #0]
   32908:	4798      	blx	r3
   3290a:	b910      	cbnz	r0, 32912 <interface_socket_allocate+0x86>
   3290c:	6034      	str	r4, [r6, #0]
   3290e:	4628      	mov	r0, r5
   32910:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   32912:	69e0      	ldr	r0, [r4, #28]
   32914:	f001 ffe4 	bl	348e0 <packet_handler_delete>
   32918:	2300      	movs	r3, #0
   3291a:	61e3      	str	r3, [r4, #28]
   3291c:	f04f 35ff 	mov.w	r5, #4294967295
   32920:	2224      	movs	r2, #36	; 0x24
   32922:	2100      	movs	r1, #0
   32924:	4620      	mov	r0, r4
   32926:	f00b ffb1 	bl	3e88c <memset>
   3292a:	200c      	movs	r0, #12
   3292c:	f7f8 f94a 	bl	2abc4 <bsd_os_errno_set>
   32930:	4628      	mov	r0, r5
   32932:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   32934:	2501      	movs	r5, #1
   32936:	e7d3      	b.n	328e0 <interface_socket_allocate+0x54>
   32938:	2502      	movs	r5, #2
   3293a:	e7d1      	b.n	328e0 <interface_socket_allocate+0x54>
   3293c:	2503      	movs	r5, #3
   3293e:	e7cf      	b.n	328e0 <interface_socket_allocate+0x54>
   32940:	2504      	movs	r5, #4
   32942:	e7cd      	b.n	328e0 <interface_socket_allocate+0x54>
   32944:	2508      	movs	r5, #8
   32946:	e7cb      	b.n	328e0 <interface_socket_allocate+0x54>
   32948:	2506      	movs	r5, #6
   3294a:	e7c9      	b.n	328e0 <interface_socket_allocate+0x54>
   3294c:	2507      	movs	r5, #7
   3294e:	e7c7      	b.n	328e0 <interface_socket_allocate+0x54>
   32950:	2002d7f4 	.word	0x2002d7f4

00032954 <interface_socket_free>:
   32954:	2808      	cmp	r0, #8
   32956:	d900      	bls.n	3295a <interface_socket_free+0x6>
   32958:	4770      	bx	lr
   3295a:	b510      	push	{r4, lr}
   3295c:	4c07      	ldr	r4, [pc, #28]	; (3297c <interface_socket_free+0x28>)
   3295e:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   32962:	eb04 0480 	add.w	r4, r4, r0, lsl #2
   32966:	69e0      	ldr	r0, [r4, #28]
   32968:	b108      	cbz	r0, 3296e <interface_socket_free+0x1a>
   3296a:	f001 ffb9 	bl	348e0 <packet_handler_delete>
   3296e:	4620      	mov	r0, r4
   32970:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   32974:	2224      	movs	r2, #36	; 0x24
   32976:	2100      	movs	r1, #0
   32978:	f00b bf88 	b.w	3e88c <memset>
   3297c:	2002d7f4 	.word	0x2002d7f4

00032980 <interface_socket_packet_handler_update>:
   32980:	2808      	cmp	r0, #8
   32982:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   32986:	d81e      	bhi.n	329c6 <interface_socket_packet_handler_update+0x46>
   32988:	ea4f 08c0 	mov.w	r8, r0, lsl #3
   3298c:	4e17      	ldr	r6, [pc, #92]	; (329ec <interface_socket_packet_handler_update+0x6c>)
   3298e:	eb08 0300 	add.w	r3, r8, r0
   32992:	009b      	lsls	r3, r3, #2
   32994:	58f4      	ldr	r4, [r6, r3]
   32996:	18f5      	adds	r5, r6, r3
   32998:	b1ac      	cbz	r4, 329c6 <interface_socket_packet_handler_update+0x46>
   3299a:	460b      	mov	r3, r1
   3299c:	4604      	mov	r4, r0
   3299e:	4611      	mov	r1, r2
   329a0:	4618      	mov	r0, r3
   329a2:	462a      	mov	r2, r5
   329a4:	f8d5 901c 	ldr.w	r9, [r5, #28]
   329a8:	f001 ff7a 	bl	348a0 <packet_handler_create>
   329ac:	61e8      	str	r0, [r5, #28]
   329ae:	b1d0      	cbz	r0, 329e6 <interface_socket_packet_handler_update+0x66>
   329b0:	6803      	ldr	r3, [r0, #0]
   329b2:	681b      	ldr	r3, [r3, #0]
   329b4:	4798      	blx	r3
   329b6:	4607      	mov	r7, r0
   329b8:	b948      	cbnz	r0, 329ce <interface_socket_packet_handler_update+0x4e>
   329ba:	4648      	mov	r0, r9
   329bc:	f001 ff90 	bl	348e0 <packet_handler_delete>
   329c0:	4638      	mov	r0, r7
   329c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   329c6:	2705      	movs	r7, #5
   329c8:	4638      	mov	r0, r7
   329ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   329ce:	69e8      	ldr	r0, [r5, #28]
   329d0:	f001 ff86 	bl	348e0 <packet_handler_delete>
   329d4:	eb08 0004 	add.w	r0, r8, r4
   329d8:	eb06 0680 	add.w	r6, r6, r0, lsl #2
   329dc:	f8c6 901c 	str.w	r9, [r6, #28]
   329e0:	4638      	mov	r0, r7
   329e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   329e6:	2704      	movs	r7, #4
   329e8:	e7f4      	b.n	329d4 <interface_socket_packet_handler_update+0x54>
   329ea:	bf00      	nop
   329ec:	2002d7f4 	.word	0x2002d7f4

000329f0 <interface_socket_wait>:
   329f0:	b5f0      	push	{r4, r5, r6, r7, lr}
   329f2:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   329f6:	4c0e      	ldr	r4, [pc, #56]	; (32a30 <interface_socket_wait+0x40>)
   329f8:	0080      	lsls	r0, r0, #2
   329fa:	5825      	ldr	r5, [r4, r0]
   329fc:	b083      	sub	sp, #12
   329fe:	4015      	ands	r5, r2
   32a00:	428d      	cmp	r5, r1
   32a02:	9301      	str	r3, [sp, #4]
   32a04:	4404      	add	r4, r0
   32a06:	d010      	beq.n	32a2a <interface_socket_wait+0x3a>
   32a08:	6863      	ldr	r3, [r4, #4]
   32a0a:	b973      	cbnz	r3, 32a2a <interface_socket_wait+0x3a>
   32a0c:	460f      	mov	r7, r1
   32a0e:	4616      	mov	r6, r2
   32a10:	4625      	mov	r5, r4
   32a12:	e006      	b.n	32a22 <interface_socket_wait+0x32>
   32a14:	686b      	ldr	r3, [r5, #4]
   32a16:	b943      	cbnz	r3, 32a2a <interface_socket_wait+0x3a>
   32a18:	a901      	add	r1, sp, #4
   32a1a:	4620      	mov	r0, r4
   32a1c:	f7f8 f83e 	bl	2aa9c <bsd_os_timedwait>
   32a20:	b920      	cbnz	r0, 32a2c <interface_socket_wait+0x3c>
   32a22:	682b      	ldr	r3, [r5, #0]
   32a24:	4033      	ands	r3, r6
   32a26:	42bb      	cmp	r3, r7
   32a28:	d1f4      	bne.n	32a14 <interface_socket_wait+0x24>
   32a2a:	2000      	movs	r0, #0
   32a2c:	b003      	add	sp, #12
   32a2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   32a30:	2002d7f4 	.word	0x2002d7f4

00032a34 <interface_from_internal_id_search>:
   32a34:	4b27      	ldr	r3, [pc, #156]	; (32ad4 <interface_from_internal_id_search+0xa0>)
   32a36:	681a      	ldr	r2, [r3, #0]
   32a38:	b112      	cbz	r2, 32a40 <interface_from_internal_id_search+0xc>
   32a3a:	699a      	ldr	r2, [r3, #24]
   32a3c:	4282      	cmp	r2, r0
   32a3e:	d039      	beq.n	32ab4 <interface_from_internal_id_search+0x80>
   32a40:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   32a42:	b112      	cbz	r2, 32a4a <interface_from_internal_id_search+0x16>
   32a44:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   32a46:	4282      	cmp	r2, r0
   32a48:	d036      	beq.n	32ab8 <interface_from_internal_id_search+0x84>
   32a4a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   32a4c:	b112      	cbz	r2, 32a54 <interface_from_internal_id_search+0x20>
   32a4e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   32a50:	4282      	cmp	r2, r0
   32a52:	d033      	beq.n	32abc <interface_from_internal_id_search+0x88>
   32a54:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   32a56:	b11a      	cbz	r2, 32a60 <interface_from_internal_id_search+0x2c>
   32a58:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   32a5c:	4282      	cmp	r2, r0
   32a5e:	d02f      	beq.n	32ac0 <interface_from_internal_id_search+0x8c>
   32a60:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   32a64:	b11a      	cbz	r2, 32a6e <interface_from_internal_id_search+0x3a>
   32a66:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
   32a6a:	4282      	cmp	r2, r0
   32a6c:	d02a      	beq.n	32ac4 <interface_from_internal_id_search+0x90>
   32a6e:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
   32a72:	b11a      	cbz	r2, 32a7c <interface_from_internal_id_search+0x48>
   32a74:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
   32a78:	4282      	cmp	r2, r0
   32a7a:	d025      	beq.n	32ac8 <interface_from_internal_id_search+0x94>
   32a7c:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
   32a80:	b11a      	cbz	r2, 32a8a <interface_from_internal_id_search+0x56>
   32a82:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
   32a86:	4282      	cmp	r2, r0
   32a88:	d020      	beq.n	32acc <interface_from_internal_id_search+0x98>
   32a8a:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
   32a8e:	b11a      	cbz	r2, 32a98 <interface_from_internal_id_search+0x64>
   32a90:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
   32a94:	4282      	cmp	r2, r0
   32a96:	d01b      	beq.n	32ad0 <interface_from_internal_id_search+0x9c>
   32a98:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   32a9c:	b13a      	cbz	r2, 32aae <interface_from_internal_id_search+0x7a>
   32a9e:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
   32aa2:	4283      	cmp	r3, r0
   32aa4:	bf14      	ite	ne
   32aa6:	f04f 30ff 	movne.w	r0, #4294967295
   32aaa:	2008      	moveq	r0, #8
   32aac:	4770      	bx	lr
   32aae:	f04f 30ff 	mov.w	r0, #4294967295
   32ab2:	4770      	bx	lr
   32ab4:	2000      	movs	r0, #0
   32ab6:	4770      	bx	lr
   32ab8:	2001      	movs	r0, #1
   32aba:	4770      	bx	lr
   32abc:	2002      	movs	r0, #2
   32abe:	4770      	bx	lr
   32ac0:	2003      	movs	r0, #3
   32ac2:	4770      	bx	lr
   32ac4:	2004      	movs	r0, #4
   32ac6:	4770      	bx	lr
   32ac8:	2005      	movs	r0, #5
   32aca:	4770      	bx	lr
   32acc:	2006      	movs	r0, #6
   32ace:	4770      	bx	lr
   32ad0:	2007      	movs	r0, #7
   32ad2:	4770      	bx	lr
   32ad4:	2002d7f4 	.word	0x2002d7f4

00032ad8 <interface_socket_from_handle_get>:
   32ad8:	2808      	cmp	r0, #8
   32ada:	d807      	bhi.n	32aec <interface_socket_from_handle_get+0x14>
   32adc:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   32ae0:	4b03      	ldr	r3, [pc, #12]	; (32af0 <interface_socket_from_handle_get+0x18>)
   32ae2:	0080      	lsls	r0, r0, #2
   32ae4:	581a      	ldr	r2, [r3, r0]
   32ae6:	b10a      	cbz	r2, 32aec <interface_socket_from_handle_get+0x14>
   32ae8:	4418      	add	r0, r3
   32aea:	4770      	bx	lr
   32aec:	2000      	movs	r0, #0
   32aee:	4770      	bx	lr
   32af0:	2002d7f4 	.word	0x2002d7f4

00032af4 <interface_socket_event_get>:
   32af4:	b119      	cbz	r1, 32afe <interface_socket_event_get+0xa>
   32af6:	2808      	cmp	r0, #8
   32af8:	d902      	bls.n	32b00 <interface_socket_event_get+0xc>
   32afa:	2310      	movs	r3, #16
   32afc:	600b      	str	r3, [r1, #0]
   32afe:	4770      	bx	lr
   32b00:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   32b04:	4b07      	ldr	r3, [pc, #28]	; (32b24 <interface_socket_event_get+0x30>)
   32b06:	0080      	lsls	r0, r0, #2
   32b08:	581a      	ldr	r2, [r3, r0]
   32b0a:	2a00      	cmp	r2, #0
   32b0c:	d0f5      	beq.n	32afa <interface_socket_event_get+0x6>
   32b0e:	581b      	ldr	r3, [r3, r0]
   32b10:	0c1b      	lsrs	r3, r3, #16
   32b12:	f003 020a 	and.w	r2, r3, #10
   32b16:	2a0a      	cmp	r2, #10
   32b18:	bf14      	ite	ne
   32b1a:	f003 030f 	andne.w	r3, r3, #15
   32b1e:	f003 030d 	andeq.w	r3, r3, #13
   32b22:	e7eb      	b.n	32afc <interface_socket_event_get+0x8>
   32b24:	2002d7f4 	.word	0x2002d7f4

00032b28 <interface_socket_setopt>:
   32b28:	2808      	cmp	r0, #8
   32b2a:	b538      	push	{r3, r4, r5, lr}
   32b2c:	d82d      	bhi.n	32b8a <interface_socket_setopt+0x62>
   32b2e:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   32b32:	4c1c      	ldr	r4, [pc, #112]	; (32ba4 <interface_socket_setopt+0x7c>)
   32b34:	0080      	lsls	r0, r0, #2
   32b36:	461d      	mov	r5, r3
   32b38:	5823      	ldr	r3, [r4, r0]
   32b3a:	b333      	cbz	r3, 32b8a <interface_socket_setopt+0x62>
   32b3c:	2901      	cmp	r1, #1
   32b3e:	d11e      	bne.n	32b7e <interface_socket_setopt+0x56>
   32b40:	2a14      	cmp	r2, #20
   32b42:	d11c      	bne.n	32b7e <interface_socket_setopt+0x56>
   32b44:	b1ad      	cbz	r5, 32b72 <interface_socket_setopt+0x4a>
   32b46:	9b04      	ldr	r3, [sp, #16]
   32b48:	2b08      	cmp	r3, #8
   32b4a:	d112      	bne.n	32b72 <interface_socket_setopt+0x4a>
   32b4c:	686a      	ldr	r2, [r5, #4]
   32b4e:	4b16      	ldr	r3, [pc, #88]	; (32ba8 <interface_socket_setopt+0x80>)
   32b50:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   32b54:	fba3 3202 	umull	r3, r2, r3, r2
   32b58:	2300      	movs	r3, #0
   32b5a:	682d      	ldr	r5, [r5, #0]
   32b5c:	0992      	lsrs	r2, r2, #6
   32b5e:	fbe1 2305 	umlal	r2, r3, r1, r5
   32b62:	2b01      	cmp	r3, #1
   32b64:	bf08      	it	eq
   32b66:	2a00      	cmpeq	r2, #0
   32b68:	d215      	bcs.n	32b96 <interface_socket_setopt+0x6e>
   32b6a:	4420      	add	r0, r4
   32b6c:	6202      	str	r2, [r0, #32]
   32b6e:	2000      	movs	r0, #0
   32b70:	bd38      	pop	{r3, r4, r5, pc}
   32b72:	2016      	movs	r0, #22
   32b74:	f7f8 f826 	bl	2abc4 <bsd_os_errno_set>
   32b78:	f04f 30ff 	mov.w	r0, #4294967295
   32b7c:	bd38      	pop	{r3, r4, r5, pc}
   32b7e:	202a      	movs	r0, #42	; 0x2a
   32b80:	f7f8 f820 	bl	2abc4 <bsd_os_errno_set>
   32b84:	f04f 30ff 	mov.w	r0, #4294967295
   32b88:	bd38      	pop	{r3, r4, r5, pc}
   32b8a:	2009      	movs	r0, #9
   32b8c:	f7f8 f81a 	bl	2abc4 <bsd_os_errno_set>
   32b90:	f04f 30ff 	mov.w	r0, #4294967295
   32b94:	bd38      	pop	{r3, r4, r5, pc}
   32b96:	2025      	movs	r0, #37	; 0x25
   32b98:	f7f8 f814 	bl	2abc4 <bsd_os_errno_set>
   32b9c:	f04f 30ff 	mov.w	r0, #4294967295
   32ba0:	bd38      	pop	{r3, r4, r5, pc}
   32ba2:	bf00      	nop
   32ba4:	2002d7f4 	.word	0x2002d7f4
   32ba8:	10624dd3 	.word	0x10624dd3

00032bac <interface_socket_getopt>:
   32bac:	b570      	push	{r4, r5, r6, lr}
   32bae:	2808      	cmp	r0, #8
   32bb0:	9d04      	ldr	r5, [sp, #16]
   32bb2:	d821      	bhi.n	32bf8 <interface_socket_getopt+0x4c>
   32bb4:	4c13      	ldr	r4, [pc, #76]	; (32c04 <interface_socket_getopt+0x58>)
   32bb6:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   32bba:	0080      	lsls	r0, r0, #2
   32bbc:	5826      	ldr	r6, [r4, r0]
   32bbe:	4404      	add	r4, r0
   32bc0:	b1d6      	cbz	r6, 32bf8 <interface_socket_getopt+0x4c>
   32bc2:	2901      	cmp	r1, #1
   32bc4:	d112      	bne.n	32bec <interface_socket_getopt+0x40>
   32bc6:	2a04      	cmp	r2, #4
   32bc8:	d110      	bne.n	32bec <interface_socket_getopt+0x40>
   32bca:	b14b      	cbz	r3, 32be0 <interface_socket_getopt+0x34>
   32bcc:	b145      	cbz	r5, 32be0 <interface_socket_getopt+0x34>
   32bce:	682a      	ldr	r2, [r5, #0]
   32bd0:	2a04      	cmp	r2, #4
   32bd2:	d105      	bne.n	32be0 <interface_socket_getopt+0x34>
   32bd4:	2200      	movs	r2, #0
   32bd6:	6861      	ldr	r1, [r4, #4]
   32bd8:	4610      	mov	r0, r2
   32bda:	6019      	str	r1, [r3, #0]
   32bdc:	6062      	str	r2, [r4, #4]
   32bde:	bd70      	pop	{r4, r5, r6, pc}
   32be0:	2016      	movs	r0, #22
   32be2:	f7f7 ffef 	bl	2abc4 <bsd_os_errno_set>
   32be6:	f04f 30ff 	mov.w	r0, #4294967295
   32bea:	bd70      	pop	{r4, r5, r6, pc}
   32bec:	202a      	movs	r0, #42	; 0x2a
   32bee:	f7f7 ffe9 	bl	2abc4 <bsd_os_errno_set>
   32bf2:	f04f 30ff 	mov.w	r0, #4294967295
   32bf6:	bd70      	pop	{r4, r5, r6, pc}
   32bf8:	2009      	movs	r0, #9
   32bfa:	f7f7 ffe3 	bl	2abc4 <bsd_os_errno_set>
   32bfe:	f04f 30ff 	mov.w	r0, #4294967295
   32c02:	bd70      	pop	{r4, r5, r6, pc}
   32c04:	2002d7f4 	.word	0x2002d7f4

00032c08 <interface_socket_fcntl>:
   32c08:	2808      	cmp	r0, #8
   32c0a:	b510      	push	{r4, lr}
   32c0c:	d818      	bhi.n	32c40 <interface_socket_fcntl+0x38>
   32c0e:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   32c12:	4c11      	ldr	r4, [pc, #68]	; (32c58 <interface_socket_fcntl+0x50>)
   32c14:	0083      	lsls	r3, r0, #2
   32c16:	58e0      	ldr	r0, [r4, r3]
   32c18:	b190      	cbz	r0, 32c40 <interface_socket_fcntl+0x38>
   32c1a:	2901      	cmp	r1, #1
   32c1c:	d005      	beq.n	32c2a <interface_socket_fcntl+0x22>
   32c1e:	2902      	cmp	r1, #2
   32c20:	d114      	bne.n	32c4c <interface_socket_fcntl+0x44>
   32c22:	58e0      	ldr	r0, [r4, r3]
   32c24:	f3c0 7000 	ubfx	r0, r0, #28, #1
   32c28:	bd10      	pop	{r4, pc}
   32c2a:	f012 0001 	ands.w	r0, r2, #1
   32c2e:	58e2      	ldr	r2, [r4, r3]
   32c30:	bf1a      	itte	ne
   32c32:	2000      	movne	r0, #0
   32c34:	f042 5280 	orrne.w	r2, r2, #268435456	; 0x10000000
   32c38:	f022 5280 	biceq.w	r2, r2, #268435456	; 0x10000000
   32c3c:	50e2      	str	r2, [r4, r3]
   32c3e:	bd10      	pop	{r4, pc}
   32c40:	2009      	movs	r0, #9
   32c42:	f7f7 ffbf 	bl	2abc4 <bsd_os_errno_set>
   32c46:	f04f 30ff 	mov.w	r0, #4294967295
   32c4a:	bd10      	pop	{r4, pc}
   32c4c:	2016      	movs	r0, #22
   32c4e:	f7f7 ffb9 	bl	2abc4 <bsd_os_errno_set>
   32c52:	f04f 30ff 	mov.w	r0, #4294967295
   32c56:	bd10      	pop	{r4, pc}
   32c58:	2002d7f4 	.word	0x2002d7f4

00032c5c <bsd_os_application_irq_handler>:
   32c5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   32c60:	4c33      	ldr	r4, [pc, #204]	; (32d30 <bsd_os_application_irq_handler+0xd4>)
   32c62:	f7f8 f8af 	bl	2adc4 <bsd_os_application_irq_clear>
   32c66:	f04f 0803 	mov.w	r8, #3
   32c6a:	4d32      	ldr	r5, [pc, #200]	; (32d34 <bsd_os_application_irq_handler+0xd8>)
   32c6c:	4f32      	ldr	r7, [pc, #200]	; (32d38 <bsd_os_application_irq_handler+0xdc>)
   32c6e:	f104 0680 	add.w	r6, r4, #128	; 0x80
   32c72:	e004      	b.n	32c7e <bsd_os_application_irq_handler+0x22>
   32c74:	2b04      	cmp	r3, #4
   32c76:	d006      	beq.n	32c86 <bsd_os_application_irq_handler+0x2a>
   32c78:	3408      	adds	r4, #8
   32c7a:	42b4      	cmp	r4, r6
   32c7c:	d03b      	beq.n	32cf6 <bsd_os_application_irq_handler+0x9a>
   32c7e:	f814 3c04 	ldrb.w	r3, [r4, #-4]
   32c82:	2b02      	cmp	r3, #2
   32c84:	d1f6      	bne.n	32c74 <bsd_os_application_irq_handler+0x18>
   32c86:	6820      	ldr	r0, [r4, #0]
   32c88:	882a      	ldrh	r2, [r5, #0]
   32c8a:	6803      	ldr	r3, [r0, #0]
   32c8c:	b29b      	uxth	r3, r3
   32c8e:	429a      	cmp	r2, r3
   32c90:	d033      	beq.n	32cfa <bsd_os_application_irq_handler+0x9e>
   32c92:	8a2a      	ldrh	r2, [r5, #16]
   32c94:	429a      	cmp	r2, r3
   32c96:	d032      	beq.n	32cfe <bsd_os_application_irq_handler+0xa2>
   32c98:	8c2a      	ldrh	r2, [r5, #32]
   32c9a:	429a      	cmp	r2, r3
   32c9c:	d031      	beq.n	32d02 <bsd_os_application_irq_handler+0xa6>
   32c9e:	8e2a      	ldrh	r2, [r5, #48]	; 0x30
   32ca0:	429a      	cmp	r2, r3
   32ca2:	d030      	beq.n	32d06 <bsd_os_application_irq_handler+0xaa>
   32ca4:	f8b5 2040 	ldrh.w	r2, [r5, #64]	; 0x40
   32ca8:	429a      	cmp	r2, r3
   32caa:	d036      	beq.n	32d1a <bsd_os_application_irq_handler+0xbe>
   32cac:	f8b5 2050 	ldrh.w	r2, [r5, #80]	; 0x50
   32cb0:	429a      	cmp	r2, r3
   32cb2:	d034      	beq.n	32d1e <bsd_os_application_irq_handler+0xc2>
   32cb4:	f8b5 2060 	ldrh.w	r2, [r5, #96]	; 0x60
   32cb8:	429a      	cmp	r2, r3
   32cba:	d032      	beq.n	32d22 <bsd_os_application_irq_handler+0xc6>
   32cbc:	f8b5 2070 	ldrh.w	r2, [r5, #112]	; 0x70
   32cc0:	429a      	cmp	r2, r3
   32cc2:	d030      	beq.n	32d26 <bsd_os_application_irq_handler+0xca>
   32cc4:	f8b5 2080 	ldrh.w	r2, [r5, #128]	; 0x80
   32cc8:	429a      	cmp	r2, r3
   32cca:	d02e      	beq.n	32d2a <bsd_os_application_irq_handler+0xce>
   32ccc:	f8b5 2090 	ldrh.w	r2, [r5, #144]	; 0x90
   32cd0:	429a      	cmp	r2, r3
   32cd2:	bf08      	it	eq
   32cd4:	2309      	moveq	r3, #9
   32cd6:	d1cf      	bne.n	32c78 <bsd_os_application_irq_handler+0x1c>
   32cd8:	eb05 1303 	add.w	r3, r5, r3, lsl #4
   32cdc:	685a      	ldr	r2, [r3, #4]
   32cde:	68d9      	ldr	r1, [r3, #12]
   32ce0:	4790      	blx	r2
   32ce2:	b990      	cbnz	r0, 32d0a <bsd_os_application_irq_handler+0xae>
   32ce4:	2201      	movs	r2, #1
   32ce6:	6820      	ldr	r0, [r4, #0]
   32ce8:	f804 2c04 	strb.w	r2, [r4, #-4]
   32cec:	68fb      	ldr	r3, [r7, #12]
   32cee:	3408      	adds	r4, #8
   32cf0:	4798      	blx	r3
   32cf2:	42b4      	cmp	r4, r6
   32cf4:	d1c3      	bne.n	32c7e <bsd_os_application_irq_handler+0x22>
   32cf6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   32cfa:	2300      	movs	r3, #0
   32cfc:	e7ec      	b.n	32cd8 <bsd_os_application_irq_handler+0x7c>
   32cfe:	2301      	movs	r3, #1
   32d00:	e7ea      	b.n	32cd8 <bsd_os_application_irq_handler+0x7c>
   32d02:	2302      	movs	r3, #2
   32d04:	e7e8      	b.n	32cd8 <bsd_os_application_irq_handler+0x7c>
   32d06:	2303      	movs	r3, #3
   32d08:	e7e6      	b.n	32cd8 <bsd_os_application_irq_handler+0x7c>
   32d0a:	2802      	cmp	r0, #2
   32d0c:	bf0a      	itet	eq
   32d0e:	2304      	moveq	r3, #4
   32d10:	f804 8c04 	strbne.w	r8, [r4, #-4]
   32d14:	f804 3c04 	strbeq.w	r3, [r4, #-4]
   32d18:	e7ae      	b.n	32c78 <bsd_os_application_irq_handler+0x1c>
   32d1a:	2304      	movs	r3, #4
   32d1c:	e7dc      	b.n	32cd8 <bsd_os_application_irq_handler+0x7c>
   32d1e:	2305      	movs	r3, #5
   32d20:	e7da      	b.n	32cd8 <bsd_os_application_irq_handler+0x7c>
   32d22:	2306      	movs	r3, #6
   32d24:	e7d8      	b.n	32cd8 <bsd_os_application_irq_handler+0x7c>
   32d26:	2307      	movs	r3, #7
   32d28:	e7d6      	b.n	32cd8 <bsd_os_application_irq_handler+0x7c>
   32d2a:	2308      	movs	r3, #8
   32d2c:	e7d4      	b.n	32cd8 <bsd_os_application_irq_handler+0x7c>
   32d2e:	bf00      	nop
   32d30:	20025498 	.word	0x20025498
   32d34:	2002535c 	.word	0x2002535c
   32d38:	200253fc 	.word	0x200253fc

00032d3c <rpc_framework_init>:
   32d3c:	b508      	push	{r3, lr}
   32d3e:	22a0      	movs	r2, #160	; 0xa0
   32d40:	2100      	movs	r1, #0
   32d42:	4802      	ldr	r0, [pc, #8]	; (32d4c <rpc_framework_init+0x10>)
   32d44:	f00b fda2 	bl	3e88c <memset>
   32d48:	2000      	movs	r0, #0
   32d4a:	bd08      	pop	{r3, pc}
   32d4c:	2002535c 	.word	0x2002535c

00032d50 <rpc_client_register>:
   32d50:	8803      	ldrh	r3, [r0, #0]
   32d52:	2b00      	cmp	r3, #0
   32d54:	d045      	beq.n	32de2 <rpc_client_register+0x92>
   32d56:	6842      	ldr	r2, [r0, #4]
   32d58:	4601      	mov	r1, r0
   32d5a:	2a00      	cmp	r2, #0
   32d5c:	d050      	beq.n	32e00 <rpc_client_register+0xb0>
   32d5e:	4a30      	ldr	r2, [pc, #192]	; (32e20 <rpc_client_register+0xd0>)
   32d60:	8810      	ldrh	r0, [r2, #0]
   32d62:	4283      	cmp	r3, r0
   32d64:	d03d      	beq.n	32de2 <rpc_client_register+0x92>
   32d66:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   32d6a:	8a14      	ldrh	r4, [r2, #16]
   32d6c:	42a3      	cmp	r3, r4
   32d6e:	d035      	beq.n	32ddc <rpc_client_register+0x8c>
   32d70:	8c15      	ldrh	r5, [r2, #32]
   32d72:	42ab      	cmp	r3, r5
   32d74:	d032      	beq.n	32ddc <rpc_client_register+0x8c>
   32d76:	8e16      	ldrh	r6, [r2, #48]	; 0x30
   32d78:	42b3      	cmp	r3, r6
   32d7a:	d02f      	beq.n	32ddc <rpc_client_register+0x8c>
   32d7c:	f8b2 7040 	ldrh.w	r7, [r2, #64]	; 0x40
   32d80:	42bb      	cmp	r3, r7
   32d82:	d02b      	beq.n	32ddc <rpc_client_register+0x8c>
   32d84:	f8b2 c050 	ldrh.w	ip, [r2, #80]	; 0x50
   32d88:	4563      	cmp	r3, ip
   32d8a:	d027      	beq.n	32ddc <rpc_client_register+0x8c>
   32d8c:	f8b2 e060 	ldrh.w	lr, [r2, #96]	; 0x60
   32d90:	4573      	cmp	r3, lr
   32d92:	d023      	beq.n	32ddc <rpc_client_register+0x8c>
   32d94:	f8b2 8070 	ldrh.w	r8, [r2, #112]	; 0x70
   32d98:	4543      	cmp	r3, r8
   32d9a:	d01f      	beq.n	32ddc <rpc_client_register+0x8c>
   32d9c:	f8b2 9080 	ldrh.w	r9, [r2, #128]	; 0x80
   32da0:	454b      	cmp	r3, r9
   32da2:	d01b      	beq.n	32ddc <rpc_client_register+0x8c>
   32da4:	f8b2 a090 	ldrh.w	sl, [r2, #144]	; 0x90
   32da8:	4553      	cmp	r3, sl
   32daa:	d017      	beq.n	32ddc <rpc_client_register+0x8c>
   32dac:	b1e0      	cbz	r0, 32de8 <rpc_client_register+0x98>
   32dae:	b35c      	cbz	r4, 32e08 <rpc_client_register+0xb8>
   32db0:	b365      	cbz	r5, 32e0c <rpc_client_register+0xbc>
   32db2:	b36e      	cbz	r6, 32e10 <rpc_client_register+0xc0>
   32db4:	b377      	cbz	r7, 32e14 <rpc_client_register+0xc4>
   32db6:	f1bc 0f00 	cmp.w	ip, #0
   32dba:	d02d      	beq.n	32e18 <rpc_client_register+0xc8>
   32dbc:	f1be 0f00 	cmp.w	lr, #0
   32dc0:	d020      	beq.n	32e04 <rpc_client_register+0xb4>
   32dc2:	f1b8 0f00 	cmp.w	r8, #0
   32dc6:	d029      	beq.n	32e1c <rpc_client_register+0xcc>
   32dc8:	f1b9 0f00 	cmp.w	r9, #0
   32dcc:	d00b      	beq.n	32de6 <rpc_client_register+0x96>
   32dce:	2009      	movs	r0, #9
   32dd0:	f1ba 0f00 	cmp.w	sl, #0
   32dd4:	d008      	beq.n	32de8 <rpc_client_register+0x98>
   32dd6:	2004      	movs	r0, #4
   32dd8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   32ddc:	2007      	movs	r0, #7
   32dde:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   32de2:	2007      	movs	r0, #7
   32de4:	4770      	bx	lr
   32de6:	2008      	movs	r0, #8
   32de8:	0100      	lsls	r0, r0, #4
   32dea:	5213      	strh	r3, [r2, r0]
   32dec:	684b      	ldr	r3, [r1, #4]
   32dee:	4402      	add	r2, r0
   32df0:	6053      	str	r3, [r2, #4]
   32df2:	688b      	ldr	r3, [r1, #8]
   32df4:	2000      	movs	r0, #0
   32df6:	6093      	str	r3, [r2, #8]
   32df8:	68cb      	ldr	r3, [r1, #12]
   32dfa:	60d3      	str	r3, [r2, #12]
   32dfc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   32e00:	200e      	movs	r0, #14
   32e02:	4770      	bx	lr
   32e04:	2006      	movs	r0, #6
   32e06:	e7ef      	b.n	32de8 <rpc_client_register+0x98>
   32e08:	2001      	movs	r0, #1
   32e0a:	e7ed      	b.n	32de8 <rpc_client_register+0x98>
   32e0c:	2002      	movs	r0, #2
   32e0e:	e7eb      	b.n	32de8 <rpc_client_register+0x98>
   32e10:	2003      	movs	r0, #3
   32e12:	e7e9      	b.n	32de8 <rpc_client_register+0x98>
   32e14:	2004      	movs	r0, #4
   32e16:	e7e7      	b.n	32de8 <rpc_client_register+0x98>
   32e18:	2005      	movs	r0, #5
   32e1a:	e7e5      	b.n	32de8 <rpc_client_register+0x98>
   32e1c:	2007      	movs	r0, #7
   32e1e:	e7e3      	b.n	32de8 <rpc_client_register+0x98>
   32e20:	2002535c 	.word	0x2002535c

00032e24 <rpc_transport_input>:
   32e24:	b538      	push	{r3, r4, r5, lr}
   32e26:	4a82      	ldr	r2, [pc, #520]	; (33030 <rpc_transport_input+0x20c>)
   32e28:	680b      	ldr	r3, [r1, #0]
   32e2a:	8810      	ldrh	r0, [r2, #0]
   32e2c:	b29b      	uxth	r3, r3
   32e2e:	4298      	cmp	r0, r3
   32e30:	d027      	beq.n	32e82 <rpc_transport_input+0x5e>
   32e32:	8a10      	ldrh	r0, [r2, #16]
   32e34:	4298      	cmp	r0, r3
   32e36:	d024      	beq.n	32e82 <rpc_transport_input+0x5e>
   32e38:	8c10      	ldrh	r0, [r2, #32]
   32e3a:	4298      	cmp	r0, r3
   32e3c:	d021      	beq.n	32e82 <rpc_transport_input+0x5e>
   32e3e:	8e10      	ldrh	r0, [r2, #48]	; 0x30
   32e40:	4298      	cmp	r0, r3
   32e42:	d01e      	beq.n	32e82 <rpc_transport_input+0x5e>
   32e44:	f8b2 0040 	ldrh.w	r0, [r2, #64]	; 0x40
   32e48:	4298      	cmp	r0, r3
   32e4a:	d01a      	beq.n	32e82 <rpc_transport_input+0x5e>
   32e4c:	f8b2 0050 	ldrh.w	r0, [r2, #80]	; 0x50
   32e50:	4298      	cmp	r0, r3
   32e52:	d016      	beq.n	32e82 <rpc_transport_input+0x5e>
   32e54:	f8b2 0060 	ldrh.w	r0, [r2, #96]	; 0x60
   32e58:	4298      	cmp	r0, r3
   32e5a:	d012      	beq.n	32e82 <rpc_transport_input+0x5e>
   32e5c:	f8b2 0070 	ldrh.w	r0, [r2, #112]	; 0x70
   32e60:	4298      	cmp	r0, r3
   32e62:	d00e      	beq.n	32e82 <rpc_transport_input+0x5e>
   32e64:	f8b2 0080 	ldrh.w	r0, [r2, #128]	; 0x80
   32e68:	4298      	cmp	r0, r3
   32e6a:	d00a      	beq.n	32e82 <rpc_transport_input+0x5e>
   32e6c:	f8b2 2090 	ldrh.w	r2, [r2, #144]	; 0x90
   32e70:	429a      	cmp	r2, r3
   32e72:	d006      	beq.n	32e82 <rpc_transport_input+0x5e>
   32e74:	6888      	ldr	r0, [r1, #8]
   32e76:	b118      	cbz	r0, 32e80 <rpc_transport_input+0x5c>
   32e78:	4b6e      	ldr	r3, [pc, #440]	; (33034 <rpc_transport_input+0x210>)
   32e7a:	691b      	ldr	r3, [r3, #16]
   32e7c:	4798      	blx	r3
   32e7e:	2000      	movs	r0, #0
   32e80:	bd38      	pop	{r3, r4, r5, pc}
   32e82:	6888      	ldr	r0, [r1, #8]
   32e84:	2800      	cmp	r0, #0
   32e86:	f000 8098 	beq.w	32fba <rpc_transport_input+0x196>
   32e8a:	4a6b      	ldr	r2, [pc, #428]	; (33038 <rpc_transport_input+0x214>)
   32e8c:	6814      	ldr	r4, [r2, #0]
   32e8e:	2c00      	cmp	r4, #0
   32e90:	d03c      	beq.n	32f0c <rpc_transport_input+0xe8>
   32e92:	6894      	ldr	r4, [r2, #8]
   32e94:	2c00      	cmp	r4, #0
   32e96:	f000 809a 	beq.w	32fce <rpc_transport_input+0x1aa>
   32e9a:	6914      	ldr	r4, [r2, #16]
   32e9c:	2c00      	cmp	r4, #0
   32e9e:	f000 809a 	beq.w	32fd6 <rpc_transport_input+0x1b2>
   32ea2:	6994      	ldr	r4, [r2, #24]
   32ea4:	2c00      	cmp	r4, #0
   32ea6:	f000 809a 	beq.w	32fde <rpc_transport_input+0x1ba>
   32eaa:	6a14      	ldr	r4, [r2, #32]
   32eac:	2c00      	cmp	r4, #0
   32eae:	f000 809a 	beq.w	32fe6 <rpc_transport_input+0x1c2>
   32eb2:	6a94      	ldr	r4, [r2, #40]	; 0x28
   32eb4:	2c00      	cmp	r4, #0
   32eb6:	f000 8084 	beq.w	32fc2 <rpc_transport_input+0x19e>
   32eba:	6b14      	ldr	r4, [r2, #48]	; 0x30
   32ebc:	2c00      	cmp	r4, #0
   32ebe:	f000 8098 	beq.w	32ff2 <rpc_transport_input+0x1ce>
   32ec2:	6b94      	ldr	r4, [r2, #56]	; 0x38
   32ec4:	2c00      	cmp	r4, #0
   32ec6:	f000 8096 	beq.w	32ff6 <rpc_transport_input+0x1d2>
   32eca:	6c14      	ldr	r4, [r2, #64]	; 0x40
   32ecc:	2c00      	cmp	r4, #0
   32ece:	f000 8096 	beq.w	32ffe <rpc_transport_input+0x1da>
   32ed2:	6c94      	ldr	r4, [r2, #72]	; 0x48
   32ed4:	2c00      	cmp	r4, #0
   32ed6:	f000 8096 	beq.w	33006 <rpc_transport_input+0x1e2>
   32eda:	6d14      	ldr	r4, [r2, #80]	; 0x50
   32edc:	2c00      	cmp	r4, #0
   32ede:	f000 8096 	beq.w	3300e <rpc_transport_input+0x1ea>
   32ee2:	6d94      	ldr	r4, [r2, #88]	; 0x58
   32ee4:	2c00      	cmp	r4, #0
   32ee6:	f000 8098 	beq.w	3301a <rpc_transport_input+0x1f6>
   32eea:	6e14      	ldr	r4, [r2, #96]	; 0x60
   32eec:	2c00      	cmp	r4, #0
   32eee:	f000 8098 	beq.w	33022 <rpc_transport_input+0x1fe>
   32ef2:	6e94      	ldr	r4, [r2, #104]	; 0x68
   32ef4:	2c00      	cmp	r4, #0
   32ef6:	f000 8096 	beq.w	33026 <rpc_transport_input+0x202>
   32efa:	6f14      	ldr	r4, [r2, #112]	; 0x70
   32efc:	2c00      	cmp	r4, #0
   32efe:	f000 8094 	beq.w	3302a <rpc_transport_input+0x206>
   32f02:	6f94      	ldr	r4, [r2, #120]	; 0x78
   32f04:	b10c      	cbz	r4, 32f0a <rpc_transport_input+0xe6>
   32f06:	2001      	movs	r0, #1
   32f08:	bd38      	pop	{r3, r4, r5, pc}
   32f0a:	240f      	movs	r4, #15
   32f0c:	eb02 05c4 	add.w	r5, r2, r4, lsl #3
   32f10:	f842 0034 	str.w	r0, [r2, r4, lsl #3]
   32f14:	80ab      	strh	r3, [r5, #4]
   32f16:	4b49      	ldr	r3, [pc, #292]	; (3303c <rpc_transport_input+0x218>)
   32f18:	781a      	ldrb	r2, [r3, #0]
   32f1a:	2a01      	cmp	r2, #1
   32f1c:	d053      	beq.n	32fc6 <rpc_transport_input+0x1a2>
   32f1e:	7a1a      	ldrb	r2, [r3, #8]
   32f20:	2a01      	cmp	r2, #1
   32f22:	d041      	beq.n	32fa8 <rpc_transport_input+0x184>
   32f24:	7c1a      	ldrb	r2, [r3, #16]
   32f26:	2a01      	cmp	r2, #1
   32f28:	d04f      	beq.n	32fca <rpc_transport_input+0x1a6>
   32f2a:	7e1a      	ldrb	r2, [r3, #24]
   32f2c:	2a01      	cmp	r2, #1
   32f2e:	d050      	beq.n	32fd2 <rpc_transport_input+0x1ae>
   32f30:	f893 2020 	ldrb.w	r2, [r3, #32]
   32f34:	2a01      	cmp	r2, #1
   32f36:	d050      	beq.n	32fda <rpc_transport_input+0x1b6>
   32f38:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
   32f3c:	2a01      	cmp	r2, #1
   32f3e:	d050      	beq.n	32fe2 <rpc_transport_input+0x1be>
   32f40:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
   32f44:	2a01      	cmp	r2, #1
   32f46:	d03a      	beq.n	32fbe <rpc_transport_input+0x19a>
   32f48:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
   32f4c:	2a01      	cmp	r2, #1
   32f4e:	d04c      	beq.n	32fea <rpc_transport_input+0x1c6>
   32f50:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
   32f54:	2a01      	cmp	r2, #1
   32f56:	d04a      	beq.n	32fee <rpc_transport_input+0x1ca>
   32f58:	f893 2048 	ldrb.w	r2, [r3, #72]	; 0x48
   32f5c:	2a01      	cmp	r2, #1
   32f5e:	d04c      	beq.n	32ffa <rpc_transport_input+0x1d6>
   32f60:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
   32f64:	2a01      	cmp	r2, #1
   32f66:	d04c      	beq.n	33002 <rpc_transport_input+0x1de>
   32f68:	f893 2058 	ldrb.w	r2, [r3, #88]	; 0x58
   32f6c:	2a01      	cmp	r2, #1
   32f6e:	d04c      	beq.n	3300a <rpc_transport_input+0x1e6>
   32f70:	f893 2060 	ldrb.w	r2, [r3, #96]	; 0x60
   32f74:	2a01      	cmp	r2, #1
   32f76:	d04c      	beq.n	33012 <rpc_transport_input+0x1ee>
   32f78:	f893 2068 	ldrb.w	r2, [r3, #104]	; 0x68
   32f7c:	2a01      	cmp	r2, #1
   32f7e:	d04a      	beq.n	33016 <rpc_transport_input+0x1f2>
   32f80:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
   32f84:	2a01      	cmp	r2, #1
   32f86:	d04a      	beq.n	3301e <rpc_transport_input+0x1fa>
   32f88:	f893 2078 	ldrb.w	r2, [r3, #120]	; 0x78
   32f8c:	2a01      	cmp	r2, #1
   32f8e:	d00a      	beq.n	32fa6 <rpc_transport_input+0x182>
   32f90:	2c10      	cmp	r4, #16
   32f92:	d0b8      	beq.n	32f06 <rpc_transport_input+0xe2>
   32f94:	2200      	movs	r2, #0
   32f96:	4b28      	ldr	r3, [pc, #160]	; (33038 <rpc_transport_input+0x214>)
   32f98:	2001      	movs	r0, #1
   32f9a:	eb03 01c4 	add.w	r1, r3, r4, lsl #3
   32f9e:	808a      	strh	r2, [r1, #4]
   32fa0:	f843 2034 	str.w	r2, [r3, r4, lsl #3]
   32fa4:	bd38      	pop	{r3, r4, r5, pc}
   32fa6:	220f      	movs	r2, #15
   32fa8:	2402      	movs	r4, #2
   32faa:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
   32fae:	f803 4032 	strb.w	r4, [r3, r2, lsl #3]
   32fb2:	6041      	str	r1, [r0, #4]
   32fb4:	f7f7 fefe 	bl	2adb4 <bsd_os_application_irq_set>
   32fb8:	e7a5      	b.n	32f06 <rpc_transport_input+0xe2>
   32fba:	2410      	movs	r4, #16
   32fbc:	e7ab      	b.n	32f16 <rpc_transport_input+0xf2>
   32fbe:	2206      	movs	r2, #6
   32fc0:	e7f2      	b.n	32fa8 <rpc_transport_input+0x184>
   32fc2:	2405      	movs	r4, #5
   32fc4:	e7a2      	b.n	32f0c <rpc_transport_input+0xe8>
   32fc6:	2200      	movs	r2, #0
   32fc8:	e7ee      	b.n	32fa8 <rpc_transport_input+0x184>
   32fca:	2202      	movs	r2, #2
   32fcc:	e7ec      	b.n	32fa8 <rpc_transport_input+0x184>
   32fce:	2401      	movs	r4, #1
   32fd0:	e79c      	b.n	32f0c <rpc_transport_input+0xe8>
   32fd2:	2203      	movs	r2, #3
   32fd4:	e7e8      	b.n	32fa8 <rpc_transport_input+0x184>
   32fd6:	2402      	movs	r4, #2
   32fd8:	e798      	b.n	32f0c <rpc_transport_input+0xe8>
   32fda:	2204      	movs	r2, #4
   32fdc:	e7e4      	b.n	32fa8 <rpc_transport_input+0x184>
   32fde:	2403      	movs	r4, #3
   32fe0:	e794      	b.n	32f0c <rpc_transport_input+0xe8>
   32fe2:	2205      	movs	r2, #5
   32fe4:	e7e0      	b.n	32fa8 <rpc_transport_input+0x184>
   32fe6:	2404      	movs	r4, #4
   32fe8:	e790      	b.n	32f0c <rpc_transport_input+0xe8>
   32fea:	2207      	movs	r2, #7
   32fec:	e7dc      	b.n	32fa8 <rpc_transport_input+0x184>
   32fee:	2208      	movs	r2, #8
   32ff0:	e7da      	b.n	32fa8 <rpc_transport_input+0x184>
   32ff2:	2406      	movs	r4, #6
   32ff4:	e78a      	b.n	32f0c <rpc_transport_input+0xe8>
   32ff6:	2407      	movs	r4, #7
   32ff8:	e788      	b.n	32f0c <rpc_transport_input+0xe8>
   32ffa:	2209      	movs	r2, #9
   32ffc:	e7d4      	b.n	32fa8 <rpc_transport_input+0x184>
   32ffe:	2408      	movs	r4, #8
   33000:	e784      	b.n	32f0c <rpc_transport_input+0xe8>
   33002:	220a      	movs	r2, #10
   33004:	e7d0      	b.n	32fa8 <rpc_transport_input+0x184>
   33006:	2409      	movs	r4, #9
   33008:	e780      	b.n	32f0c <rpc_transport_input+0xe8>
   3300a:	220b      	movs	r2, #11
   3300c:	e7cc      	b.n	32fa8 <rpc_transport_input+0x184>
   3300e:	240a      	movs	r4, #10
   33010:	e77c      	b.n	32f0c <rpc_transport_input+0xe8>
   33012:	220c      	movs	r2, #12
   33014:	e7c8      	b.n	32fa8 <rpc_transport_input+0x184>
   33016:	220d      	movs	r2, #13
   33018:	e7c6      	b.n	32fa8 <rpc_transport_input+0x184>
   3301a:	240b      	movs	r4, #11
   3301c:	e776      	b.n	32f0c <rpc_transport_input+0xe8>
   3301e:	220e      	movs	r2, #14
   33020:	e7c2      	b.n	32fa8 <rpc_transport_input+0x184>
   33022:	240c      	movs	r4, #12
   33024:	e772      	b.n	32f0c <rpc_transport_input+0xe8>
   33026:	240d      	movs	r4, #13
   33028:	e770      	b.n	32f0c <rpc_transport_input+0xe8>
   3302a:	240e      	movs	r4, #14
   3302c:	e76e      	b.n	32f0c <rpc_transport_input+0xe8>
   3302e:	bf00      	nop
   33030:	2002535c 	.word	0x2002535c
   33034:	200253fc 	.word	0x200253fc
   33038:	20025414 	.word	0x20025414
   3303c:	20025494 	.word	0x20025494

00033040 <rpc_transport_register>:
   33040:	b4f0      	push	{r4, r5, r6, r7}
   33042:	2900      	cmp	r1, #0
   33044:	d052      	beq.n	330ec <rpc_transport_register+0xac>
   33046:	2800      	cmp	r0, #0
   33048:	d050      	beq.n	330ec <rpc_transport_register+0xac>
   3304a:	6883      	ldr	r3, [r0, #8]
   3304c:	2b00      	cmp	r3, #0
   3304e:	d04d      	beq.n	330ec <rpc_transport_register+0xac>
   33050:	6903      	ldr	r3, [r0, #16]
   33052:	2b00      	cmp	r3, #0
   33054:	d04a      	beq.n	330ec <rpc_transport_register+0xac>
   33056:	6843      	ldr	r3, [r0, #4]
   33058:	2b00      	cmp	r3, #0
   3305a:	d047      	beq.n	330ec <rpc_transport_register+0xac>
   3305c:	68c3      	ldr	r3, [r0, #12]
   3305e:	2b00      	cmp	r3, #0
   33060:	d044      	beq.n	330ec <rpc_transport_register+0xac>
   33062:	6803      	ldr	r3, [r0, #0]
   33064:	2b00      	cmp	r3, #0
   33066:	d041      	beq.n	330ec <rpc_transport_register+0xac>
   33068:	6943      	ldr	r3, [r0, #20]
   3306a:	2b00      	cmp	r3, #0
   3306c:	d03e      	beq.n	330ec <rpc_transport_register+0xac>
   3306e:	2601      	movs	r6, #1
   33070:	2500      	movs	r5, #0
   33072:	4604      	mov	r4, r0
   33074:	460f      	mov	r7, r1
   33076:	4a1f      	ldr	r2, [pc, #124]	; (330f4 <rpc_transport_register+0xb4>)
   33078:	4b1f      	ldr	r3, [pc, #124]	; (330f8 <rpc_transport_register+0xb8>)
   3307a:	f8df c080 	ldr.w	ip, [pc, #128]	; 330fc <rpc_transport_register+0xbc>
   3307e:	7416      	strb	r6, [r2, #16]
   33080:	7616      	strb	r6, [r2, #24]
   33082:	f882 6020 	strb.w	r6, [r2, #32]
   33086:	f882 6028 	strb.w	r6, [r2, #40]	; 0x28
   3308a:	f882 6030 	strb.w	r6, [r2, #48]	; 0x30
   3308e:	f882 6038 	strb.w	r6, [r2, #56]	; 0x38
   33092:	f882 6040 	strb.w	r6, [r2, #64]	; 0x40
   33096:	f882 6048 	strb.w	r6, [r2, #72]	; 0x48
   3309a:	f882 6050 	strb.w	r6, [r2, #80]	; 0x50
   3309e:	f882 6058 	strb.w	r6, [r2, #88]	; 0x58
   330a2:	f882 6060 	strb.w	r6, [r2, #96]	; 0x60
   330a6:	f882 6068 	strb.w	r6, [r2, #104]	; 0x68
   330aa:	f882 6070 	strb.w	r6, [r2, #112]	; 0x70
   330ae:	f882 6078 	strb.w	r6, [r2, #120]	; 0x78
   330b2:	611d      	str	r5, [r3, #16]
   330b4:	619d      	str	r5, [r3, #24]
   330b6:	621d      	str	r5, [r3, #32]
   330b8:	629d      	str	r5, [r3, #40]	; 0x28
   330ba:	631d      	str	r5, [r3, #48]	; 0x30
   330bc:	639d      	str	r5, [r3, #56]	; 0x38
   330be:	641d      	str	r5, [r3, #64]	; 0x40
   330c0:	649d      	str	r5, [r3, #72]	; 0x48
   330c2:	651d      	str	r5, [r3, #80]	; 0x50
   330c4:	659d      	str	r5, [r3, #88]	; 0x58
   330c6:	661d      	str	r5, [r3, #96]	; 0x60
   330c8:	669d      	str	r5, [r3, #104]	; 0x68
   330ca:	671d      	str	r5, [r3, #112]	; 0x70
   330cc:	679d      	str	r5, [r3, #120]	; 0x78
   330ce:	7016      	strb	r6, [r2, #0]
   330d0:	7216      	strb	r6, [r2, #8]
   330d2:	601d      	str	r5, [r3, #0]
   330d4:	609d      	str	r5, [r3, #8]
   330d6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   330d8:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   330dc:	e894 0003 	ldmia.w	r4, {r0, r1}
   330e0:	e88c 0003 	stmia.w	ip, {r0, r1}
   330e4:	603e      	str	r6, [r7, #0]
   330e6:	4628      	mov	r0, r5
   330e8:	bcf0      	pop	{r4, r5, r6, r7}
   330ea:	4770      	bx	lr
   330ec:	250e      	movs	r5, #14
   330ee:	4628      	mov	r0, r5
   330f0:	bcf0      	pop	{r4, r5, r6, r7}
   330f2:	4770      	bx	lr
   330f4:	20025494 	.word	0x20025494
   330f8:	20025414 	.word	0x20025414
   330fc:	200253fc 	.word	0x200253fc

00033100 <rpc_transport_unregister>:
   33100:	2800      	cmp	r0, #0
   33102:	d03a      	beq.n	3317a <rpc_transport_unregister+0x7a>
   33104:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   33108:	4680      	mov	r8, r0
   3310a:	4c1d      	ldr	r4, [pc, #116]	; (33180 <rpc_transport_unregister+0x80>)
   3310c:	f104 05a0 	add.w	r5, r4, #160	; 0xa0
   33110:	68a3      	ldr	r3, [r4, #8]
   33112:	3410      	adds	r4, #16
   33114:	b103      	cbz	r3, 33118 <rpc_transport_unregister+0x18>
   33116:	4798      	blx	r3
   33118:	42ac      	cmp	r4, r5
   3311a:	d1f9      	bne.n	33110 <rpc_transport_unregister+0x10>
   3311c:	f04f 0901 	mov.w	r9, #1
   33120:	2600      	movs	r6, #0
   33122:	4c18      	ldr	r4, [pc, #96]	; (33184 <rpc_transport_unregister+0x84>)
   33124:	4d18      	ldr	r5, [pc, #96]	; (33188 <rpc_transport_unregister+0x88>)
   33126:	f8df a064 	ldr.w	sl, [pc, #100]	; 3318c <rpc_transport_unregister+0x8c>
   3312a:	f104 0780 	add.w	r7, r4, #128	; 0x80
   3312e:	f814 3c04 	ldrb.w	r3, [r4, #-4]
   33132:	2b01      	cmp	r3, #1
   33134:	d005      	beq.n	33142 <rpc_transport_unregister+0x42>
   33136:	f8da 300c 	ldr.w	r3, [sl, #12]
   3313a:	6820      	ldr	r0, [r4, #0]
   3313c:	4798      	blx	r3
   3313e:	f804 9c04 	strb.w	r9, [r4, #-4]
   33142:	f855 0c04 	ldr.w	r0, [r5, #-4]
   33146:	3408      	adds	r4, #8
   33148:	b128      	cbz	r0, 33156 <rpc_transport_unregister+0x56>
   3314a:	f8da 3010 	ldr.w	r3, [sl, #16]
   3314e:	4798      	blx	r3
   33150:	802e      	strh	r6, [r5, #0]
   33152:	f845 6c04 	str.w	r6, [r5, #-4]
   33156:	42bc      	cmp	r4, r7
   33158:	f105 0508 	add.w	r5, r5, #8
   3315c:	d1e7      	bne.n	3312e <rpc_transport_unregister+0x2e>
   3315e:	f8d8 0000 	ldr.w	r0, [r8]
   33162:	2218      	movs	r2, #24
   33164:	3801      	subs	r0, #1
   33166:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   3316a:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
   3316e:	2100      	movs	r1, #0
   33170:	f00b fb8c 	bl	3e88c <memset>
   33174:	2000      	movs	r0, #0
   33176:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3317a:	200e      	movs	r0, #14
   3317c:	4770      	bx	lr
   3317e:	bf00      	nop
   33180:	2002535c 	.word	0x2002535c
   33184:	20025498 	.word	0x20025498
   33188:	20025418 	.word	0x20025418
   3318c:	200253fc 	.word	0x200253fc

00033190 <rpc_message_send>:
   33190:	b168      	cbz	r0, 331ae <rpc_message_send+0x1e>
   33192:	b171      	cbz	r1, 331b2 <rpc_message_send+0x22>
   33194:	4a09      	ldr	r2, [pc, #36]	; (331bc <rpc_message_send+0x2c>)
   33196:	6853      	ldr	r3, [r2, #4]
   33198:	b16b      	cbz	r3, 331b6 <rpc_message_send+0x26>
   3319a:	684b      	ldr	r3, [r1, #4]
   3319c:	8008      	strh	r0, [r1, #0]
   3319e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   331a2:	f043 0302 	orr.w	r3, r3, #2
   331a6:	6812      	ldr	r2, [r2, #0]
   331a8:	604b      	str	r3, [r1, #4]
   331aa:	4608      	mov	r0, r1
   331ac:	4710      	bx	r2
   331ae:	2007      	movs	r0, #7
   331b0:	4770      	bx	lr
   331b2:	200e      	movs	r0, #14
   331b4:	4770      	bx	lr
   331b6:	2008      	movs	r0, #8
   331b8:	4770      	bx	lr
   331ba:	bf00      	nop
   331bc:	200253fc 	.word	0x200253fc

000331c0 <rpc_message_alloc>:
   331c0:	b35a      	cbz	r2, 3321a <rpc_message_alloc+0x5a>
   331c2:	b330      	cbz	r0, 33212 <rpc_message_alloc+0x52>
   331c4:	2300      	movs	r3, #0
   331c6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   331ca:	4f15      	ldr	r7, [pc, #84]	; (33220 <rpc_message_alloc+0x60>)
   331cc:	6013      	str	r3, [r2, #0]
   331ce:	687b      	ldr	r3, [r7, #4]
   331d0:	b30b      	cbz	r3, 33216 <rpc_message_alloc+0x56>
   331d2:	4615      	mov	r5, r2
   331d4:	460c      	mov	r4, r1
   331d6:	4606      	mov	r6, r0
   331d8:	b959      	cbnz	r1, 331f2 <rpc_message_alloc+0x32>
   331da:	4798      	blx	r3
   331dc:	4603      	mov	r3, r0
   331de:	b1a8      	cbz	r0, 3320c <rpc_message_alloc+0x4c>
   331e0:	46a0      	mov	r8, r4
   331e2:	60dc      	str	r4, [r3, #12]
   331e4:	f8c3 8008 	str.w	r8, [r3, #8]
   331e8:	801e      	strh	r6, [r3, #0]
   331ea:	602b      	str	r3, [r5, #0]
   331ec:	2000      	movs	r0, #0
   331ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   331f2:	68bb      	ldr	r3, [r7, #8]
   331f4:	4608      	mov	r0, r1
   331f6:	4798      	blx	r3
   331f8:	4680      	mov	r8, r0
   331fa:	b138      	cbz	r0, 3320c <rpc_message_alloc+0x4c>
   331fc:	687b      	ldr	r3, [r7, #4]
   331fe:	4798      	blx	r3
   33200:	4603      	mov	r3, r0
   33202:	2800      	cmp	r0, #0
   33204:	d1ed      	bne.n	331e2 <rpc_message_alloc+0x22>
   33206:	693b      	ldr	r3, [r7, #16]
   33208:	4640      	mov	r0, r8
   3320a:	4798      	blx	r3
   3320c:	2004      	movs	r0, #4
   3320e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   33212:	2007      	movs	r0, #7
   33214:	4770      	bx	lr
   33216:	2008      	movs	r0, #8
   33218:	e7f9      	b.n	3320e <rpc_message_alloc+0x4e>
   3321a:	200e      	movs	r0, #14
   3321c:	4770      	bx	lr
   3321e:	bf00      	nop
   33220:	200253fc 	.word	0x200253fc

00033224 <rpc_message_free>:
   33224:	2800      	cmp	r0, #0
   33226:	f000 808c 	beq.w	33342 <rpc_message_free+0x11e>
   3322a:	2900      	cmp	r1, #0
   3322c:	f000 80e9 	beq.w	33402 <rpc_message_free+0x1de>
   33230:	b538      	push	{r3, r4, r5, lr}
   33232:	4a83      	ldr	r2, [pc, #524]	; (33440 <rpc_message_free+0x21c>)
   33234:	6853      	ldr	r3, [r2, #4]
   33236:	2b00      	cmp	r3, #0
   33238:	f000 8085 	beq.w	33346 <rpc_message_free+0x122>
   3323c:	4c81      	ldr	r4, [pc, #516]	; (33444 <rpc_message_free+0x220>)
   3323e:	4608      	mov	r0, r1
   33240:	6863      	ldr	r3, [r4, #4]
   33242:	4299      	cmp	r1, r3
   33244:	f000 8085 	beq.w	33352 <rpc_message_free+0x12e>
   33248:	68e3      	ldr	r3, [r4, #12]
   3324a:	4298      	cmp	r0, r3
   3324c:	f000 808e 	beq.w	3336c <rpc_message_free+0x148>
   33250:	6963      	ldr	r3, [r4, #20]
   33252:	4298      	cmp	r0, r3
   33254:	f000 8090 	beq.w	33378 <rpc_message_free+0x154>
   33258:	69e3      	ldr	r3, [r4, #28]
   3325a:	4298      	cmp	r0, r3
   3325c:	f000 8092 	beq.w	33384 <rpc_message_free+0x160>
   33260:	6a63      	ldr	r3, [r4, #36]	; 0x24
   33262:	4298      	cmp	r0, r3
   33264:	f000 8095 	beq.w	33392 <rpc_message_free+0x16e>
   33268:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   3326a:	4298      	cmp	r0, r3
   3326c:	f000 8098 	beq.w	333a0 <rpc_message_free+0x17c>
   33270:	6b63      	ldr	r3, [r4, #52]	; 0x34
   33272:	4298      	cmp	r0, r3
   33274:	f000 809b 	beq.w	333ae <rpc_message_free+0x18a>
   33278:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   3327a:	4298      	cmp	r0, r3
   3327c:	f000 809e 	beq.w	333bc <rpc_message_free+0x198>
   33280:	6c63      	ldr	r3, [r4, #68]	; 0x44
   33282:	4298      	cmp	r0, r3
   33284:	f000 80a1 	beq.w	333ca <rpc_message_free+0x1a6>
   33288:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   3328a:	4298      	cmp	r0, r3
   3328c:	f000 80a4 	beq.w	333d8 <rpc_message_free+0x1b4>
   33290:	6d63      	ldr	r3, [r4, #84]	; 0x54
   33292:	4298      	cmp	r0, r3
   33294:	f000 80a7 	beq.w	333e6 <rpc_message_free+0x1c2>
   33298:	6de3      	ldr	r3, [r4, #92]	; 0x5c
   3329a:	4298      	cmp	r0, r3
   3329c:	f000 80aa 	beq.w	333f4 <rpc_message_free+0x1d0>
   332a0:	6e63      	ldr	r3, [r4, #100]	; 0x64
   332a2:	4298      	cmp	r0, r3
   332a4:	f000 80af 	beq.w	33406 <rpc_message_free+0x1e2>
   332a8:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   332aa:	4298      	cmp	r0, r3
   332ac:	f000 80b2 	beq.w	33414 <rpc_message_free+0x1f0>
   332b0:	6f63      	ldr	r3, [r4, #116]	; 0x74
   332b2:	4298      	cmp	r0, r3
   332b4:	f000 80b5 	beq.w	33422 <rpc_message_free+0x1fe>
   332b8:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
   332ba:	4283      	cmp	r3, r0
   332bc:	f000 80b8 	beq.w	33430 <rpc_message_free+0x20c>
   332c0:	68d3      	ldr	r3, [r2, #12]
   332c2:	4798      	blx	r3
   332c4:	7823      	ldrb	r3, [r4, #0]
   332c6:	2b04      	cmp	r3, #4
   332c8:	d03f      	beq.n	3334a <rpc_message_free+0x126>
   332ca:	7a23      	ldrb	r3, [r4, #8]
   332cc:	2b04      	cmp	r3, #4
   332ce:	d03c      	beq.n	3334a <rpc_message_free+0x126>
   332d0:	7c23      	ldrb	r3, [r4, #16]
   332d2:	2b04      	cmp	r3, #4
   332d4:	d039      	beq.n	3334a <rpc_message_free+0x126>
   332d6:	7e23      	ldrb	r3, [r4, #24]
   332d8:	2b04      	cmp	r3, #4
   332da:	d036      	beq.n	3334a <rpc_message_free+0x126>
   332dc:	f894 3020 	ldrb.w	r3, [r4, #32]
   332e0:	2b04      	cmp	r3, #4
   332e2:	d032      	beq.n	3334a <rpc_message_free+0x126>
   332e4:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
   332e8:	2b04      	cmp	r3, #4
   332ea:	d02e      	beq.n	3334a <rpc_message_free+0x126>
   332ec:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   332f0:	2b04      	cmp	r3, #4
   332f2:	d02a      	beq.n	3334a <rpc_message_free+0x126>
   332f4:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
   332f8:	2b04      	cmp	r3, #4
   332fa:	d026      	beq.n	3334a <rpc_message_free+0x126>
   332fc:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   33300:	2b04      	cmp	r3, #4
   33302:	d022      	beq.n	3334a <rpc_message_free+0x126>
   33304:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
   33308:	2b04      	cmp	r3, #4
   3330a:	d01e      	beq.n	3334a <rpc_message_free+0x126>
   3330c:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
   33310:	2b04      	cmp	r3, #4
   33312:	d01a      	beq.n	3334a <rpc_message_free+0x126>
   33314:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
   33318:	2b04      	cmp	r3, #4
   3331a:	d016      	beq.n	3334a <rpc_message_free+0x126>
   3331c:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
   33320:	2b04      	cmp	r3, #4
   33322:	d012      	beq.n	3334a <rpc_message_free+0x126>
   33324:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
   33328:	2b04      	cmp	r3, #4
   3332a:	d00e      	beq.n	3334a <rpc_message_free+0x126>
   3332c:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
   33330:	2b04      	cmp	r3, #4
   33332:	d00a      	beq.n	3334a <rpc_message_free+0x126>
   33334:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
   33338:	2b04      	cmp	r3, #4
   3333a:	bf18      	it	ne
   3333c:	2000      	movne	r0, #0
   3333e:	d004      	beq.n	3334a <rpc_message_free+0x126>
   33340:	bd38      	pop	{r3, r4, r5, pc}
   33342:	2007      	movs	r0, #7
   33344:	4770      	bx	lr
   33346:	2008      	movs	r0, #8
   33348:	bd38      	pop	{r3, r4, r5, pc}
   3334a:	f7f7 fd33 	bl	2adb4 <bsd_os_application_irq_set>
   3334e:	2000      	movs	r0, #0
   33350:	bd38      	pop	{r3, r4, r5, pc}
   33352:	7821      	ldrb	r1, [r4, #0]
   33354:	2903      	cmp	r1, #3
   33356:	f47f af77 	bne.w	33248 <rpc_message_free+0x24>
   3335a:	2100      	movs	r1, #0
   3335c:	2501      	movs	r5, #1
   3335e:	4618      	mov	r0, r3
   33360:	68d2      	ldr	r2, [r2, #12]
   33362:	f804 5031 	strb.w	r5, [r4, r1, lsl #3]
   33366:	4790      	blx	r2
   33368:	2000      	movs	r0, #0
   3336a:	bd38      	pop	{r3, r4, r5, pc}
   3336c:	7a21      	ldrb	r1, [r4, #8]
   3336e:	2903      	cmp	r1, #3
   33370:	f47f af6e 	bne.w	33250 <rpc_message_free+0x2c>
   33374:	2101      	movs	r1, #1
   33376:	e7f1      	b.n	3335c <rpc_message_free+0x138>
   33378:	7c21      	ldrb	r1, [r4, #16]
   3337a:	2903      	cmp	r1, #3
   3337c:	f47f af6c 	bne.w	33258 <rpc_message_free+0x34>
   33380:	2102      	movs	r1, #2
   33382:	e7eb      	b.n	3335c <rpc_message_free+0x138>
   33384:	7e21      	ldrb	r1, [r4, #24]
   33386:	2903      	cmp	r1, #3
   33388:	d0e8      	beq.n	3335c <rpc_message_free+0x138>
   3338a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   3338c:	4298      	cmp	r0, r3
   3338e:	f47f af6b 	bne.w	33268 <rpc_message_free+0x44>
   33392:	f894 1020 	ldrb.w	r1, [r4, #32]
   33396:	2903      	cmp	r1, #3
   33398:	f47f af66 	bne.w	33268 <rpc_message_free+0x44>
   3339c:	2104      	movs	r1, #4
   3339e:	e7dd      	b.n	3335c <rpc_message_free+0x138>
   333a0:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
   333a4:	2903      	cmp	r1, #3
   333a6:	f47f af63 	bne.w	33270 <rpc_message_free+0x4c>
   333aa:	2105      	movs	r1, #5
   333ac:	e7d6      	b.n	3335c <rpc_message_free+0x138>
   333ae:	f894 1030 	ldrb.w	r1, [r4, #48]	; 0x30
   333b2:	2903      	cmp	r1, #3
   333b4:	f47f af60 	bne.w	33278 <rpc_message_free+0x54>
   333b8:	2106      	movs	r1, #6
   333ba:	e7cf      	b.n	3335c <rpc_message_free+0x138>
   333bc:	f894 1038 	ldrb.w	r1, [r4, #56]	; 0x38
   333c0:	2903      	cmp	r1, #3
   333c2:	f47f af5d 	bne.w	33280 <rpc_message_free+0x5c>
   333c6:	2107      	movs	r1, #7
   333c8:	e7c8      	b.n	3335c <rpc_message_free+0x138>
   333ca:	f894 1040 	ldrb.w	r1, [r4, #64]	; 0x40
   333ce:	2903      	cmp	r1, #3
   333d0:	f47f af5a 	bne.w	33288 <rpc_message_free+0x64>
   333d4:	2108      	movs	r1, #8
   333d6:	e7c1      	b.n	3335c <rpc_message_free+0x138>
   333d8:	f894 1048 	ldrb.w	r1, [r4, #72]	; 0x48
   333dc:	2903      	cmp	r1, #3
   333de:	f47f af57 	bne.w	33290 <rpc_message_free+0x6c>
   333e2:	2109      	movs	r1, #9
   333e4:	e7ba      	b.n	3335c <rpc_message_free+0x138>
   333e6:	f894 1050 	ldrb.w	r1, [r4, #80]	; 0x50
   333ea:	2903      	cmp	r1, #3
   333ec:	f47f af54 	bne.w	33298 <rpc_message_free+0x74>
   333f0:	210a      	movs	r1, #10
   333f2:	e7b3      	b.n	3335c <rpc_message_free+0x138>
   333f4:	f894 1058 	ldrb.w	r1, [r4, #88]	; 0x58
   333f8:	2903      	cmp	r1, #3
   333fa:	f47f af51 	bne.w	332a0 <rpc_message_free+0x7c>
   333fe:	210b      	movs	r1, #11
   33400:	e7ac      	b.n	3335c <rpc_message_free+0x138>
   33402:	200e      	movs	r0, #14
   33404:	4770      	bx	lr
   33406:	f894 1060 	ldrb.w	r1, [r4, #96]	; 0x60
   3340a:	2903      	cmp	r1, #3
   3340c:	f47f af4c 	bne.w	332a8 <rpc_message_free+0x84>
   33410:	210c      	movs	r1, #12
   33412:	e7a3      	b.n	3335c <rpc_message_free+0x138>
   33414:	f894 1068 	ldrb.w	r1, [r4, #104]	; 0x68
   33418:	2903      	cmp	r1, #3
   3341a:	f47f af49 	bne.w	332b0 <rpc_message_free+0x8c>
   3341e:	210d      	movs	r1, #13
   33420:	e79c      	b.n	3335c <rpc_message_free+0x138>
   33422:	f894 1070 	ldrb.w	r1, [r4, #112]	; 0x70
   33426:	2903      	cmp	r1, #3
   33428:	f47f af46 	bne.w	332b8 <rpc_message_free+0x94>
   3342c:	210e      	movs	r1, #14
   3342e:	e795      	b.n	3335c <rpc_message_free+0x138>
   33430:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
   33434:	2b03      	cmp	r3, #3
   33436:	f47f af43 	bne.w	332c0 <rpc_message_free+0x9c>
   3343a:	4603      	mov	r3, r0
   3343c:	210f      	movs	r1, #15
   3343e:	e78d      	b.n	3335c <rpc_message_free+0x138>
   33440:	200253fc 	.word	0x200253fc
   33444:	20025494 	.word	0x20025494

00033448 <rpc_message_data_free>:
   33448:	2800      	cmp	r0, #0
   3344a:	f000 8091 	beq.w	33570 <rpc_message_data_free+0x128>
   3344e:	2900      	cmp	r1, #0
   33450:	f000 80e4 	beq.w	3361c <rpc_message_data_free+0x1d4>
   33454:	b538      	push	{r3, r4, r5, lr}
   33456:	4a81      	ldr	r2, [pc, #516]	; (3365c <rpc_message_data_free+0x214>)
   33458:	6853      	ldr	r3, [r2, #4]
   3345a:	2b00      	cmp	r3, #0
   3345c:	f000 808a 	beq.w	33574 <rpc_message_data_free+0x12c>
   33460:	4b7f      	ldr	r3, [pc, #508]	; (33660 <rpc_message_data_free+0x218>)
   33462:	681c      	ldr	r4, [r3, #0]
   33464:	42a1      	cmp	r1, r4
   33466:	f000 8087 	beq.w	33578 <rpc_message_data_free+0x130>
   3346a:	689c      	ldr	r4, [r3, #8]
   3346c:	42a1      	cmp	r1, r4
   3346e:	f000 808f 	beq.w	33590 <rpc_message_data_free+0x148>
   33472:	691c      	ldr	r4, [r3, #16]
   33474:	42a1      	cmp	r1, r4
   33476:	f000 8091 	beq.w	3359c <rpc_message_data_free+0x154>
   3347a:	699c      	ldr	r4, [r3, #24]
   3347c:	42a1      	cmp	r1, r4
   3347e:	f000 8093 	beq.w	335a8 <rpc_message_data_free+0x160>
   33482:	6a1c      	ldr	r4, [r3, #32]
   33484:	42a1      	cmp	r1, r4
   33486:	f000 8095 	beq.w	335b4 <rpc_message_data_free+0x16c>
   3348a:	6a9c      	ldr	r4, [r3, #40]	; 0x28
   3348c:	42a1      	cmp	r1, r4
   3348e:	f000 8097 	beq.w	335c0 <rpc_message_data_free+0x178>
   33492:	6b1c      	ldr	r4, [r3, #48]	; 0x30
   33494:	42a1      	cmp	r1, r4
   33496:	f000 8099 	beq.w	335cc <rpc_message_data_free+0x184>
   3349a:	6b9c      	ldr	r4, [r3, #56]	; 0x38
   3349c:	42a1      	cmp	r1, r4
   3349e:	f000 809b 	beq.w	335d8 <rpc_message_data_free+0x190>
   334a2:	6c1c      	ldr	r4, [r3, #64]	; 0x40
   334a4:	42a1      	cmp	r1, r4
   334a6:	f000 809d 	beq.w	335e4 <rpc_message_data_free+0x19c>
   334aa:	6c9c      	ldr	r4, [r3, #72]	; 0x48
   334ac:	42a1      	cmp	r1, r4
   334ae:	f000 80a0 	beq.w	335f2 <rpc_message_data_free+0x1aa>
   334b2:	6d1c      	ldr	r4, [r3, #80]	; 0x50
   334b4:	42a1      	cmp	r1, r4
   334b6:	f000 80a3 	beq.w	33600 <rpc_message_data_free+0x1b8>
   334ba:	6d9c      	ldr	r4, [r3, #88]	; 0x58
   334bc:	42a1      	cmp	r1, r4
   334be:	f000 80a6 	beq.w	3360e <rpc_message_data_free+0x1c6>
   334c2:	6e1c      	ldr	r4, [r3, #96]	; 0x60
   334c4:	42a1      	cmp	r1, r4
   334c6:	f000 80ab 	beq.w	33620 <rpc_message_data_free+0x1d8>
   334ca:	6e9c      	ldr	r4, [r3, #104]	; 0x68
   334cc:	42a1      	cmp	r1, r4
   334ce:	f000 80ae 	beq.w	3362e <rpc_message_data_free+0x1e6>
   334d2:	6f1c      	ldr	r4, [r3, #112]	; 0x70
   334d4:	42a1      	cmp	r1, r4
   334d6:	f000 80b1 	beq.w	3363c <rpc_message_data_free+0x1f4>
   334da:	6f9c      	ldr	r4, [r3, #120]	; 0x78
   334dc:	428c      	cmp	r4, r1
   334de:	f000 80b4 	beq.w	3364a <rpc_message_data_free+0x202>
   334e2:	6913      	ldr	r3, [r2, #16]
   334e4:	4608      	mov	r0, r1
   334e6:	4798      	blx	r3
   334e8:	4b5e      	ldr	r3, [pc, #376]	; (33664 <rpc_message_data_free+0x21c>)
   334ea:	781a      	ldrb	r2, [r3, #0]
   334ec:	2a04      	cmp	r2, #4
   334ee:	d03b      	beq.n	33568 <rpc_message_data_free+0x120>
   334f0:	7a1a      	ldrb	r2, [r3, #8]
   334f2:	2a04      	cmp	r2, #4
   334f4:	d038      	beq.n	33568 <rpc_message_data_free+0x120>
   334f6:	7c1a      	ldrb	r2, [r3, #16]
   334f8:	2a04      	cmp	r2, #4
   334fa:	d035      	beq.n	33568 <rpc_message_data_free+0x120>
   334fc:	7e1a      	ldrb	r2, [r3, #24]
   334fe:	2a04      	cmp	r2, #4
   33500:	d032      	beq.n	33568 <rpc_message_data_free+0x120>
   33502:	f893 2020 	ldrb.w	r2, [r3, #32]
   33506:	2a04      	cmp	r2, #4
   33508:	d02e      	beq.n	33568 <rpc_message_data_free+0x120>
   3350a:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
   3350e:	2a04      	cmp	r2, #4
   33510:	d02a      	beq.n	33568 <rpc_message_data_free+0x120>
   33512:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
   33516:	2a04      	cmp	r2, #4
   33518:	d026      	beq.n	33568 <rpc_message_data_free+0x120>
   3351a:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
   3351e:	2a04      	cmp	r2, #4
   33520:	d022      	beq.n	33568 <rpc_message_data_free+0x120>
   33522:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
   33526:	2a04      	cmp	r2, #4
   33528:	d01e      	beq.n	33568 <rpc_message_data_free+0x120>
   3352a:	f893 2048 	ldrb.w	r2, [r3, #72]	; 0x48
   3352e:	2a04      	cmp	r2, #4
   33530:	d01a      	beq.n	33568 <rpc_message_data_free+0x120>
   33532:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
   33536:	2a04      	cmp	r2, #4
   33538:	d016      	beq.n	33568 <rpc_message_data_free+0x120>
   3353a:	f893 2058 	ldrb.w	r2, [r3, #88]	; 0x58
   3353e:	2a04      	cmp	r2, #4
   33540:	d012      	beq.n	33568 <rpc_message_data_free+0x120>
   33542:	f893 2060 	ldrb.w	r2, [r3, #96]	; 0x60
   33546:	2a04      	cmp	r2, #4
   33548:	d00e      	beq.n	33568 <rpc_message_data_free+0x120>
   3354a:	f893 2068 	ldrb.w	r2, [r3, #104]	; 0x68
   3354e:	2a04      	cmp	r2, #4
   33550:	d00a      	beq.n	33568 <rpc_message_data_free+0x120>
   33552:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
   33556:	2a04      	cmp	r2, #4
   33558:	d006      	beq.n	33568 <rpc_message_data_free+0x120>
   3355a:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
   3355e:	2b04      	cmp	r3, #4
   33560:	bf18      	it	ne
   33562:	2000      	movne	r0, #0
   33564:	d000      	beq.n	33568 <rpc_message_data_free+0x120>
   33566:	bd38      	pop	{r3, r4, r5, pc}
   33568:	f7f7 fc24 	bl	2adb4 <bsd_os_application_irq_set>
   3356c:	2000      	movs	r0, #0
   3356e:	bd38      	pop	{r3, r4, r5, pc}
   33570:	2007      	movs	r0, #7
   33572:	4770      	bx	lr
   33574:	2008      	movs	r0, #8
   33576:	bd38      	pop	{r3, r4, r5, pc}
   33578:	889c      	ldrh	r4, [r3, #4]
   3357a:	4284      	cmp	r4, r0
   3357c:	f47f af75 	bne.w	3346a <rpc_message_data_free+0x22>
   33580:	2400      	movs	r4, #0
   33582:	2000      	movs	r0, #0
   33584:	eb03 05c4 	add.w	r5, r3, r4, lsl #3
   33588:	f843 0034 	str.w	r0, [r3, r4, lsl #3]
   3358c:	80a8      	strh	r0, [r5, #4]
   3358e:	e7a8      	b.n	334e2 <rpc_message_data_free+0x9a>
   33590:	899c      	ldrh	r4, [r3, #12]
   33592:	4284      	cmp	r4, r0
   33594:	f47f af6d 	bne.w	33472 <rpc_message_data_free+0x2a>
   33598:	2401      	movs	r4, #1
   3359a:	e7f2      	b.n	33582 <rpc_message_data_free+0x13a>
   3359c:	8a9c      	ldrh	r4, [r3, #20]
   3359e:	4284      	cmp	r4, r0
   335a0:	f47f af6b 	bne.w	3347a <rpc_message_data_free+0x32>
   335a4:	2402      	movs	r4, #2
   335a6:	e7ec      	b.n	33582 <rpc_message_data_free+0x13a>
   335a8:	8b9c      	ldrh	r4, [r3, #28]
   335aa:	4284      	cmp	r4, r0
   335ac:	f47f af69 	bne.w	33482 <rpc_message_data_free+0x3a>
   335b0:	2403      	movs	r4, #3
   335b2:	e7e6      	b.n	33582 <rpc_message_data_free+0x13a>
   335b4:	8c9c      	ldrh	r4, [r3, #36]	; 0x24
   335b6:	4284      	cmp	r4, r0
   335b8:	f47f af67 	bne.w	3348a <rpc_message_data_free+0x42>
   335bc:	2404      	movs	r4, #4
   335be:	e7e0      	b.n	33582 <rpc_message_data_free+0x13a>
   335c0:	8d9c      	ldrh	r4, [r3, #44]	; 0x2c
   335c2:	4284      	cmp	r4, r0
   335c4:	f47f af65 	bne.w	33492 <rpc_message_data_free+0x4a>
   335c8:	2405      	movs	r4, #5
   335ca:	e7da      	b.n	33582 <rpc_message_data_free+0x13a>
   335cc:	8e9c      	ldrh	r4, [r3, #52]	; 0x34
   335ce:	4284      	cmp	r4, r0
   335d0:	f47f af63 	bne.w	3349a <rpc_message_data_free+0x52>
   335d4:	2406      	movs	r4, #6
   335d6:	e7d4      	b.n	33582 <rpc_message_data_free+0x13a>
   335d8:	8f9c      	ldrh	r4, [r3, #60]	; 0x3c
   335da:	4284      	cmp	r4, r0
   335dc:	f47f af61 	bne.w	334a2 <rpc_message_data_free+0x5a>
   335e0:	2407      	movs	r4, #7
   335e2:	e7ce      	b.n	33582 <rpc_message_data_free+0x13a>
   335e4:	f8b3 4044 	ldrh.w	r4, [r3, #68]	; 0x44
   335e8:	4284      	cmp	r4, r0
   335ea:	f47f af5e 	bne.w	334aa <rpc_message_data_free+0x62>
   335ee:	2408      	movs	r4, #8
   335f0:	e7c7      	b.n	33582 <rpc_message_data_free+0x13a>
   335f2:	f8b3 404c 	ldrh.w	r4, [r3, #76]	; 0x4c
   335f6:	4284      	cmp	r4, r0
   335f8:	f47f af5b 	bne.w	334b2 <rpc_message_data_free+0x6a>
   335fc:	2409      	movs	r4, #9
   335fe:	e7c0      	b.n	33582 <rpc_message_data_free+0x13a>
   33600:	f8b3 4054 	ldrh.w	r4, [r3, #84]	; 0x54
   33604:	4284      	cmp	r4, r0
   33606:	f47f af58 	bne.w	334ba <rpc_message_data_free+0x72>
   3360a:	240a      	movs	r4, #10
   3360c:	e7b9      	b.n	33582 <rpc_message_data_free+0x13a>
   3360e:	f8b3 405c 	ldrh.w	r4, [r3, #92]	; 0x5c
   33612:	4284      	cmp	r4, r0
   33614:	f47f af55 	bne.w	334c2 <rpc_message_data_free+0x7a>
   33618:	240b      	movs	r4, #11
   3361a:	e7b2      	b.n	33582 <rpc_message_data_free+0x13a>
   3361c:	200e      	movs	r0, #14
   3361e:	4770      	bx	lr
   33620:	f8b3 4064 	ldrh.w	r4, [r3, #100]	; 0x64
   33624:	4284      	cmp	r4, r0
   33626:	f47f af50 	bne.w	334ca <rpc_message_data_free+0x82>
   3362a:	240c      	movs	r4, #12
   3362c:	e7a9      	b.n	33582 <rpc_message_data_free+0x13a>
   3362e:	f8b3 406c 	ldrh.w	r4, [r3, #108]	; 0x6c
   33632:	4284      	cmp	r4, r0
   33634:	f47f af4d 	bne.w	334d2 <rpc_message_data_free+0x8a>
   33638:	240d      	movs	r4, #13
   3363a:	e7a2      	b.n	33582 <rpc_message_data_free+0x13a>
   3363c:	f8b3 4074 	ldrh.w	r4, [r3, #116]	; 0x74
   33640:	4284      	cmp	r4, r0
   33642:	f47f af4a 	bne.w	334da <rpc_message_data_free+0x92>
   33646:	240e      	movs	r4, #14
   33648:	e79b      	b.n	33582 <rpc_message_data_free+0x13a>
   3364a:	f8b3 407c 	ldrh.w	r4, [r3, #124]	; 0x7c
   3364e:	4284      	cmp	r4, r0
   33650:	bf08      	it	eq
   33652:	240f      	moveq	r4, #15
   33654:	f47f af45 	bne.w	334e2 <rpc_message_data_free+0x9a>
   33658:	e793      	b.n	33582 <rpc_message_data_free+0x13a>
   3365a:	bf00      	nop
   3365c:	200253fc 	.word	0x200253fc
   33660:	20025414 	.word	0x20025414
   33664:	20025494 	.word	0x20025494

00033668 <packet_free_cb>:
   33668:	b510      	push	{r4, lr}
   3366a:	4604      	mov	r4, r0
   3366c:	b118      	cbz	r0, 33676 <packet_free_cb+0xe>
   3366e:	6800      	ldr	r0, [r0, #0]
   33670:	b108      	cbz	r0, 33676 <packet_free_cb+0xe>
   33672:	f001 f82f 	bl	346d4 <rpc_gnss_client_data_free>
   33676:	68a0      	ldr	r0, [r4, #8]
   33678:	b118      	cbz	r0, 33682 <packet_free_cb+0x1a>
   3367a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   3367e:	f7fa b917 	b.w	2d8b0 <nrf_free>
   33682:	bd10      	pop	{r4, pc}

00033684 <rpc_gnss_event_handler>:
   33684:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   33688:	4b64      	ldr	r3, [pc, #400]	; (3381c <rpc_gnss_event_handler+0x198>)
   3368a:	4606      	mov	r6, r0
   3368c:	6800      	ldr	r0, [r0, #0]
   3368e:	881b      	ldrh	r3, [r3, #0]
   33690:	6802      	ldr	r2, [r0, #0]
   33692:	4f63      	ldr	r7, [pc, #396]	; (33820 <rpc_gnss_event_handler+0x19c>)
   33694:	ebb3 4f12 	cmp.w	r3, r2, lsr #16
   33698:	b084      	sub	sp, #16
   3369a:	460d      	mov	r5, r1
   3369c:	6038      	str	r0, [r7, #0]
   3369e:	d038      	beq.n	33712 <rpc_gnss_event_handler+0x8e>
   336a0:	f505 433f 	add.w	r3, r5, #48896	; 0xbf00
   336a4:	33ff      	adds	r3, #255	; 0xff
   336a6:	b29b      	uxth	r3, r3
   336a8:	2b02      	cmp	r3, #2
   336aa:	d810      	bhi.n	336ce <rpc_gnss_event_handler+0x4a>
   336ac:	4c5d      	ldr	r4, [pc, #372]	; (33824 <rpc_gnss_event_handler+0x1a0>)
   336ae:	6823      	ldr	r3, [r4, #0]
   336b0:	075a      	lsls	r2, r3, #29
   336b2:	d410      	bmi.n	336d6 <rpc_gnss_event_handler+0x52>
   336b4:	6823      	ldr	r3, [r4, #0]
   336b6:	079b      	lsls	r3, r3, #30
   336b8:	d503      	bpl.n	336c2 <rpc_gnss_event_handler+0x3e>
   336ba:	f244 0303 	movw	r3, #16387	; 0x4003
   336be:	429d      	cmp	r5, r3
   336c0:	d009      	beq.n	336d6 <rpc_gnss_event_handler+0x52>
   336c2:	6830      	ldr	r0, [r6, #0]
   336c4:	b118      	cbz	r0, 336ce <rpc_gnss_event_handler+0x4a>
   336c6:	f001 f805 	bl	346d4 <rpc_gnss_client_data_free>
   336ca:	2300      	movs	r3, #0
   336cc:	603b      	str	r3, [r7, #0]
   336ce:	2000      	movs	r0, #0
   336d0:	b004      	add	sp, #16
   336d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   336d6:	2002      	movs	r0, #2
   336d8:	f7fa f8e0 	bl	2d89c <nrf_malloc>
   336dc:	4680      	mov	r8, r0
   336de:	2800      	cmp	r0, #0
   336e0:	f000 8093 	beq.w	3380a <rpc_gnss_event_handler+0x186>
   336e4:	2302      	movs	r3, #2
   336e6:	8005      	strh	r5, [r0, #0]
   336e8:	6831      	ldr	r1, [r6, #0]
   336ea:	6872      	ldr	r2, [r6, #4]
   336ec:	484e      	ldr	r0, [pc, #312]	; (33828 <rpc_gnss_event_handler+0x1a4>)
   336ee:	e88d 0106 	stmia.w	sp, {r1, r2, r8}
   336f2:	6800      	ldr	r0, [r0, #0]
   336f4:	9303      	str	r3, [sp, #12]
   336f6:	6803      	ldr	r3, [r0, #0]
   336f8:	4669      	mov	r1, sp
   336fa:	685b      	ldr	r3, [r3, #4]
   336fc:	4798      	blx	r3
   336fe:	3001      	adds	r0, #1
   33700:	d070      	beq.n	337e4 <rpc_gnss_event_handler+0x160>
   33702:	2000      	movs	r0, #0
   33704:	6823      	ldr	r3, [r4, #0]
   33706:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   3370a:	6023      	str	r3, [r4, #0]
   3370c:	b004      	add	sp, #16
   3370e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   33712:	4c44      	ldr	r4, [pc, #272]	; (33824 <rpc_gnss_event_handler+0x1a0>)
   33714:	6823      	ldr	r3, [r4, #0]
   33716:	01d9      	lsls	r1, r3, #7
   33718:	d523      	bpl.n	33762 <rpc_gnss_event_handler+0xde>
   3371a:	f242 1302 	movw	r3, #8450	; 0x2102
   3371e:	429d      	cmp	r5, r3
   33720:	d11f      	bne.n	33762 <rpc_gnss_event_handler+0xde>
   33722:	6843      	ldr	r3, [r0, #4]
   33724:	b91b      	cbnz	r3, 3372e <rpc_gnss_event_handler+0xaa>
   33726:	6823      	ldr	r3, [r4, #0]
   33728:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   3372c:	6023      	str	r3, [r4, #0]
   3372e:	6823      	ldr	r3, [r4, #0]
   33730:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   33734:	6023      	str	r3, [r4, #0]
   33736:	6823      	ldr	r3, [r4, #0]
   33738:	025a      	lsls	r2, r3, #9
   3373a:	d430      	bmi.n	3379e <rpc_gnss_event_handler+0x11a>
   3373c:	f242 0305 	movw	r3, #8197	; 0x2005
   33740:	429d      	cmp	r5, r3
   33742:	d12c      	bne.n	3379e <rpc_gnss_event_handler+0x11a>
   33744:	6823      	ldr	r3, [r4, #0]
   33746:	0299      	lsls	r1, r3, #10
   33748:	d529      	bpl.n	3379e <rpc_gnss_event_handler+0x11a>
   3374a:	6843      	ldr	r3, [r0, #4]
   3374c:	2b00      	cmp	r3, #0
   3374e:	d157      	bne.n	33800 <rpc_gnss_event_handler+0x17c>
   33750:	6823      	ldr	r3, [r4, #0]
   33752:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   33756:	6023      	str	r3, [r4, #0]
   33758:	6823      	ldr	r3, [r4, #0]
   3375a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   3375e:	6023      	str	r3, [r4, #0]
   33760:	e01d      	b.n	3379e <rpc_gnss_event_handler+0x11a>
   33762:	6823      	ldr	r3, [r4, #0]
   33764:	025b      	lsls	r3, r3, #9
   33766:	d50e      	bpl.n	33786 <rpc_gnss_event_handler+0x102>
   33768:	f242 1303 	movw	r3, #8451	; 0x2103
   3376c:	429d      	cmp	r5, r3
   3376e:	d10a      	bne.n	33786 <rpc_gnss_event_handler+0x102>
   33770:	6843      	ldr	r3, [r0, #4]
   33772:	b91b      	cbnz	r3, 3377c <rpc_gnss_event_handler+0xf8>
   33774:	6823      	ldr	r3, [r4, #0]
   33776:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   3377a:	6023      	str	r3, [r4, #0]
   3377c:	6823      	ldr	r3, [r4, #0]
   3377e:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   33782:	6023      	str	r3, [r4, #0]
   33784:	e00b      	b.n	3379e <rpc_gnss_event_handler+0x11a>
   33786:	f242 0301 	movw	r3, #8193	; 0x2001
   3378a:	429d      	cmp	r5, r3
   3378c:	d10c      	bne.n	337a8 <rpc_gnss_event_handler+0x124>
   3378e:	6843      	ldr	r3, [r0, #4]
   33790:	b92b      	cbnz	r3, 3379e <rpc_gnss_event_handler+0x11a>
   33792:	6823      	ldr	r3, [r4, #0]
   33794:	0c1b      	lsrs	r3, r3, #16
   33796:	041b      	lsls	r3, r3, #16
   33798:	f043 0302 	orr.w	r3, r3, #2
   3379c:	6023      	str	r3, [r4, #0]
   3379e:	f000 ff99 	bl	346d4 <rpc_gnss_client_data_free>
   337a2:	2300      	movs	r3, #0
   337a4:	603b      	str	r3, [r7, #0]
   337a6:	e77b      	b.n	336a0 <rpc_gnss_event_handler+0x1c>
   337a8:	f242 0304 	movw	r3, #8196	; 0x2004
   337ac:	429d      	cmp	r5, r3
   337ae:	d1c5      	bne.n	3373c <rpc_gnss_event_handler+0xb8>
   337b0:	6843      	ldr	r3, [r0, #4]
   337b2:	b993      	cbnz	r3, 337da <rpc_gnss_event_handler+0x156>
   337b4:	6823      	ldr	r3, [r4, #0]
   337b6:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   337ba:	6023      	str	r3, [r4, #0]
   337bc:	6823      	ldr	r3, [r4, #0]
   337be:	b29b      	uxth	r3, r3
   337c0:	2b03      	cmp	r3, #3
   337c2:	6823      	ldr	r3, [r4, #0]
   337c4:	d016      	beq.n	337f4 <rpc_gnss_event_handler+0x170>
   337c6:	b29b      	uxth	r3, r3
   337c8:	2b04      	cmp	r3, #4
   337ca:	d1d7      	bne.n	3377c <rpc_gnss_event_handler+0xf8>
   337cc:	6823      	ldr	r3, [r4, #0]
   337ce:	0c1b      	lsrs	r3, r3, #16
   337d0:	041b      	lsls	r3, r3, #16
   337d2:	f043 0302 	orr.w	r3, r3, #2
   337d6:	6023      	str	r3, [r4, #0]
   337d8:	e7d0      	b.n	3377c <rpc_gnss_event_handler+0xf8>
   337da:	6823      	ldr	r3, [r4, #0]
   337dc:	b29b      	uxth	r3, r3
   337de:	2b03      	cmp	r3, #3
   337e0:	d1cc      	bne.n	3377c <rpc_gnss_event_handler+0xf8>
   337e2:	e7f3      	b.n	337cc <rpc_gnss_event_handler+0x148>
   337e4:	4640      	mov	r0, r8
   337e6:	f7fa f863 	bl	2d8b0 <nrf_free>
   337ea:	6830      	ldr	r0, [r6, #0]
   337ec:	2800      	cmp	r0, #0
   337ee:	f47f af6a 	bne.w	336c6 <rpc_gnss_event_handler+0x42>
   337f2:	e76c      	b.n	336ce <rpc_gnss_event_handler+0x4a>
   337f4:	0c1b      	lsrs	r3, r3, #16
   337f6:	041b      	lsls	r3, r3, #16
   337f8:	f043 0304 	orr.w	r3, r3, #4
   337fc:	6023      	str	r3, [r4, #0]
   337fe:	e7bd      	b.n	3377c <rpc_gnss_event_handler+0xf8>
   33800:	6823      	ldr	r3, [r4, #0]
   33802:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   33806:	6023      	str	r3, [r4, #0]
   33808:	e7c9      	b.n	3379e <rpc_gnss_event_handler+0x11a>
   3380a:	6830      	ldr	r0, [r6, #0]
   3380c:	2800      	cmp	r0, #0
   3380e:	f43f af5e 	beq.w	336ce <rpc_gnss_event_handler+0x4a>
   33812:	f000 ff5f 	bl	346d4 <rpc_gnss_client_data_free>
   33816:	f8c7 8000 	str.w	r8, [r7]
   3381a:	e758      	b.n	336ce <rpc_gnss_event_handler+0x4a>
   3381c:	20029914 	.word	0x20029914
   33820:	20025518 	.word	0x20025518
   33824:	20025514 	.word	0x20025514
   33828:	2002551c 	.word	0x2002551c

0003382c <gnss_interface_write>:
   3382c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   33830:	4a74      	ldr	r2, [pc, #464]	; (33a04 <gnss_interface_write+0x1d8>)
   33832:	b09f      	sub	sp, #124	; 0x7c
   33834:	4290      	cmp	r0, r2
   33836:	9d26      	ldr	r5, [sp, #152]	; 0x98
   33838:	f040 80d7 	bne.w	339ea <gnss_interface_write+0x1be>
   3383c:	2900      	cmp	r1, #0
   3383e:	f000 80c6 	beq.w	339ce <gnss_interface_write+0x1a2>
   33842:	2d00      	cmp	r5, #0
   33844:	f000 80c3 	beq.w	339ce <gnss_interface_write+0x1a2>
   33848:	9a27      	ldr	r2, [sp, #156]	; 0x9c
   3384a:	2a02      	cmp	r2, #2
   3384c:	f040 80bf 	bne.w	339ce <gnss_interface_write+0x1a2>
   33850:	4c6d      	ldr	r4, [pc, #436]	; (33a08 <gnss_interface_write+0x1dc>)
   33852:	6822      	ldr	r2, [r4, #0]
   33854:	b292      	uxth	r2, r2
   33856:	2a02      	cmp	r2, #2
   33858:	d004      	beq.n	33864 <gnss_interface_write+0x38>
   3385a:	6822      	ldr	r2, [r4, #0]
   3385c:	b292      	uxth	r2, r2
   3385e:	2a04      	cmp	r2, #4
   33860:	f040 80bd 	bne.w	339de <gnss_interface_write+0x1b2>
   33864:	2b00      	cmp	r3, #0
   33866:	f040 80c6 	bne.w	339f6 <gnss_interface_write+0x1ca>
   3386a:	6822      	ldr	r2, [r4, #0]
   3386c:	0390      	lsls	r0, r2, #14
   3386e:	d512      	bpl.n	33896 <gnss_interface_write+0x6a>
   33870:	6822      	ldr	r2, [r4, #0]
   33872:	882b      	ldrh	r3, [r5, #0]
   33874:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
   33878:	6022      	str	r2, [r4, #0]
   3387a:	6822      	ldr	r2, [r4, #0]
   3387c:	3b01      	subs	r3, #1
   3387e:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
   33882:	6022      	str	r2, [r4, #0]
   33884:	2b07      	cmp	r3, #7
   33886:	f200 80a2 	bhi.w	339ce <gnss_interface_write+0x1a2>
   3388a:	e8df f003 	tbb	[pc, r3]
   3388e:	7d82      	.short	0x7d82
   33890:	646e7378 	.word	0x646e7378
   33894:	0869      	.short	0x0869
   33896:	2000      	movs	r0, #0
   33898:	b01f      	add	sp, #124	; 0x7c
   3389a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   3389e:	4608      	mov	r0, r1
   338a0:	a902      	add	r1, sp, #8
   338a2:	f000 fecb 	bl	3463c <rpc_gnss_serialize_integrity>
   338a6:	2172      	movs	r1, #114	; 0x72
   338a8:	4668      	mov	r0, sp
   338aa:	f000 fee1 	bl	34670 <rpc_gnss_client_request_alloc>
   338ae:	4605      	mov	r5, r0
   338b0:	9800      	ldr	r0, [sp, #0]
   338b2:	2d00      	cmp	r5, #0
   338b4:	d172      	bne.n	3399c <gnss_interface_write+0x170>
   338b6:	2800      	cmp	r0, #0
   338b8:	d077      	beq.n	339aa <gnss_interface_write+0x17e>
   338ba:	f241 0605 	movw	r6, #4101	; 0x1005
   338be:	f04f 0c49 	mov.w	ip, #73	; 0x49
   338c2:	2272      	movs	r2, #114	; 0x72
   338c4:	f04f 0e76 	mov.w	lr, #118	; 0x76
   338c8:	f04f 0943 	mov.w	r9, #67	; 0x43
   338cc:	f04f 0854 	mov.w	r8, #84	; 0x54
   338d0:	4f4e      	ldr	r7, [pc, #312]	; (33a0c <gnss_interface_write+0x1e0>)
   338d2:	a91e      	add	r1, sp, #120	; 0x78
   338d4:	883b      	ldrh	r3, [r7, #0]
   338d6:	f880 c00f 	strb.w	ip, [r0, #15]
   338da:	3301      	adds	r3, #1
   338dc:	b29b      	uxth	r3, r3
   338de:	ea46 4c03 	orr.w	ip, r6, r3, lsl #16
   338e2:	f841 cd74 	str.w	ip, [r1, #-116]!
   338e6:	7145      	strb	r5, [r0, #5]
   338e8:	7185      	strb	r5, [r0, #6]
   338ea:	71c5      	strb	r5, [r0, #7]
   338ec:	7205      	strb	r5, [r0, #8]
   338ee:	7245      	strb	r5, [r0, #9]
   338f0:	7285      	strb	r5, [r0, #10]
   338f2:	72c5      	strb	r5, [r0, #11]
   338f4:	7102      	strb	r2, [r0, #4]
   338f6:	f880 900c 	strb.w	r9, [r0, #12]
   338fa:	f880 800d 	strb.w	r8, [r0, #13]
   338fe:	f880 e00e 	strb.w	lr, [r0, #14]
   33902:	6800      	ldr	r0, [r0, #0]
   33904:	803b      	strh	r3, [r7, #0]
   33906:	f00a ffa1 	bl	3e84c <memcpy>
   3390a:	4b41      	ldr	r3, [pc, #260]	; (33a10 <gnss_interface_write+0x1e4>)
   3390c:	4631      	mov	r1, r6
   3390e:	9800      	ldr	r0, [sp, #0]
   33910:	601d      	str	r5, [r3, #0]
   33912:	f000 fec1 	bl	34698 <rpc_gnss_client_request_send>
   33916:	2800      	cmp	r0, #0
   33918:	d14e      	bne.n	339b8 <gnss_interface_write+0x18c>
   3391a:	6823      	ldr	r3, [r4, #0]
   3391c:	0299      	lsls	r1, r3, #10
   3391e:	d50b      	bpl.n	33938 <gnss_interface_write+0x10c>
   33920:	4e3c      	ldr	r6, [pc, #240]	; (33a14 <gnss_interface_write+0x1e8>)
   33922:	4d38      	ldr	r5, [pc, #224]	; (33a04 <gnss_interface_write+0x1d8>)
   33924:	e000      	b.n	33928 <gnss_interface_write+0xfc>
   33926:	b978      	cbnz	r0, 33948 <gnss_interface_write+0x11c>
   33928:	4631      	mov	r1, r6
   3392a:	4628      	mov	r0, r5
   3392c:	f7f7 f8b6 	bl	2aa9c <bsd_os_timedwait>
   33930:	6823      	ldr	r3, [r4, #0]
   33932:	029a      	lsls	r2, r3, #10
   33934:	d4f7      	bmi.n	33926 <gnss_interface_write+0xfa>
   33936:	b938      	cbnz	r0, 33948 <gnss_interface_write+0x11c>
   33938:	6823      	ldr	r3, [r4, #0]
   3393a:	039b      	lsls	r3, r3, #14
   3393c:	d4ab      	bmi.n	33896 <gnss_interface_write+0x6a>
   3393e:	2005      	movs	r0, #5
   33940:	6823      	ldr	r3, [r4, #0]
   33942:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   33946:	6023      	str	r3, [r4, #0]
   33948:	f7f7 f93c 	bl	2abc4 <bsd_os_errno_set>
   3394c:	f04f 30ff 	mov.w	r0, #4294967295
   33950:	b01f      	add	sp, #124	; 0x7c
   33952:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   33956:	4608      	mov	r0, r1
   33958:	a902      	add	r1, sp, #8
   3395a:	f000 fe27 	bl	345ac <rpc_gnss_serialize_time_and_sv_tow>
   3395e:	e7a2      	b.n	338a6 <gnss_interface_write+0x7a>
   33960:	4608      	mov	r0, r1
   33962:	a902      	add	r1, sp, #8
   33964:	f000 fe4a 	bl	345fc <rpc_gnss_serialize_location>
   33968:	e79d      	b.n	338a6 <gnss_interface_write+0x7a>
   3396a:	4608      	mov	r0, r1
   3396c:	a902      	add	r1, sp, #8
   3396e:	f000 fe03 	bl	34578 <rpc_gnss_serialize_nequick>
   33972:	e798      	b.n	338a6 <gnss_interface_write+0x7a>
   33974:	4608      	mov	r0, r1
   33976:	a902      	add	r1, sp, #8
   33978:	f000 fdda 	bl	34530 <rpc_gnss_serialize_klob>
   3397c:	e793      	b.n	338a6 <gnss_interface_write+0x7a>
   3397e:	4608      	mov	r0, r1
   33980:	a902      	add	r1, sp, #8
   33982:	f000 fda3 	bl	344cc <rpc_gnss_serialize_alm>
   33986:	e78e      	b.n	338a6 <gnss_interface_write+0x7a>
   33988:	4608      	mov	r0, r1
   3398a:	a902      	add	r1, sp, #8
   3398c:	f000 fd4c 	bl	34428 <rpc_gnss_serialize_ephe>
   33990:	e789      	b.n	338a6 <gnss_interface_write+0x7a>
   33992:	4608      	mov	r0, r1
   33994:	a902      	add	r1, sp, #8
   33996:	f000 fd25 	bl	343e4 <rpc_gnss_serialize_utc>
   3399a:	e784      	b.n	338a6 <gnss_interface_write+0x7a>
   3399c:	b128      	cbz	r0, 339aa <gnss_interface_write+0x17e>
   3399e:	6803      	ldr	r3, [r0, #0]
   339a0:	b11b      	cbz	r3, 339aa <gnss_interface_write+0x17e>
   339a2:	4618      	mov	r0, r3
   339a4:	f000 fe96 	bl	346d4 <rpc_gnss_client_data_free>
   339a8:	9800      	ldr	r0, [sp, #0]
   339aa:	f000 fe8b 	bl	346c4 <rpc_gnss_client_message_free>
   339ae:	2023      	movs	r0, #35	; 0x23
   339b0:	f7f7 f908 	bl	2abc4 <bsd_os_errno_set>
   339b4:	f04f 30ff 	mov.w	r0, #4294967295
   339b8:	6823      	ldr	r3, [r4, #0]
   339ba:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   339be:	6023      	str	r3, [r4, #0]
   339c0:	6823      	ldr	r3, [r4, #0]
   339c2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   339c6:	6023      	str	r3, [r4, #0]
   339c8:	b01f      	add	sp, #124	; 0x7c
   339ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   339ce:	2016      	movs	r0, #22
   339d0:	f7f7 f8f8 	bl	2abc4 <bsd_os_errno_set>
   339d4:	f04f 30ff 	mov.w	r0, #4294967295
   339d8:	b01f      	add	sp, #124	; 0x7c
   339da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   339de:	2039      	movs	r0, #57	; 0x39
   339e0:	f7f7 f8f0 	bl	2abc4 <bsd_os_errno_set>
   339e4:	f04f 30ff 	mov.w	r0, #4294967295
   339e8:	e756      	b.n	33898 <gnss_interface_write+0x6c>
   339ea:	2009      	movs	r0, #9
   339ec:	f7f7 f8ea 	bl	2abc4 <bsd_os_errno_set>
   339f0:	f04f 30ff 	mov.w	r0, #4294967295
   339f4:	e750      	b.n	33898 <gnss_interface_write+0x6c>
   339f6:	202d      	movs	r0, #45	; 0x2d
   339f8:	f7f7 f8e4 	bl	2abc4 <bsd_os_errno_set>
   339fc:	f04f 30ff 	mov.w	r0, #4294967295
   33a00:	e74a      	b.n	33898 <gnss_interface_write+0x6c>
   33a02:	bf00      	nop
   33a04:	49765443 	.word	0x49765443
   33a08:	20025514 	.word	0x20025514
   33a0c:	20029914 	.word	0x20029914
   33a10:	20025518 	.word	0x20025518
   33a14:	200346f8 	.word	0x200346f8

00033a18 <gnss_interface_read>:
   33a18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   33a1c:	4c50      	ldr	r4, [pc, #320]	; (33b60 <gnss_interface_read+0x148>)
   33a1e:	b0b7      	sub	sp, #220	; 0xdc
   33a20:	42a0      	cmp	r0, r4
   33a22:	f040 81fe 	bne.w	33e22 <gnss_interface_read+0x40a>
   33a26:	4688      	mov	r8, r1
   33a28:	2900      	cmp	r1, #0
   33a2a:	f000 81f4 	beq.w	33e16 <gnss_interface_read+0x3fe>
   33a2e:	2ad7      	cmp	r2, #215	; 0xd7
   33a30:	f240 81f1 	bls.w	33e16 <gnss_interface_read+0x3fe>
   33a34:	4d4b      	ldr	r5, [pc, #300]	; (33b64 <gnss_interface_read+0x14c>)
   33a36:	4699      	mov	r9, r3
   33a38:	682b      	ldr	r3, [r5, #0]
   33a3a:	b29b      	uxth	r3, r3
   33a3c:	2b04      	cmp	r3, #4
   33a3e:	d004      	beq.n	33a4a <gnss_interface_read+0x32>
   33a40:	682b      	ldr	r3, [r5, #0]
   33a42:	b29b      	uxth	r3, r3
   33a44:	2b02      	cmp	r3, #2
   33a46:	f040 81e0 	bne.w	33e0a <gnss_interface_read+0x3f2>
   33a4a:	f1b9 0f00 	cmp.w	r9, #0
   33a4e:	d158      	bne.n	33b02 <gnss_interface_read+0xea>
   33a50:	2102      	movs	r1, #2
   33a52:	20b6      	movs	r0, #182	; 0xb6
   33a54:	2400      	movs	r4, #0
   33a56:	682b      	ldr	r3, [r5, #0]
   33a58:	f10d 020e 	add.w	r2, sp, #14
   33a5c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   33a60:	602b      	str	r3, [r5, #0]
   33a62:	f8df a108 	ldr.w	sl, [pc, #264]	; 33b6c <gnss_interface_read+0x154>
   33a66:	ab08      	add	r3, sp, #32
   33a68:	4f3f      	ldr	r7, [pc, #252]	; (33b68 <gnss_interface_read+0x150>)
   33a6a:	4e3d      	ldr	r6, [pc, #244]	; (33b60 <gnss_interface_read+0x148>)
   33a6c:	9005      	str	r0, [sp, #20]
   33a6e:	9107      	str	r1, [sp, #28]
   33a70:	9304      	str	r3, [sp, #16]
   33a72:	9206      	str	r2, [sp, #24]
   33a74:	ea09 0b01 	and.w	fp, r9, r1
   33a78:	f8da 0000 	ldr.w	r0, [sl]
   33a7c:	464a      	mov	r2, r9
   33a7e:	6803      	ldr	r3, [r0, #0]
   33a80:	a904      	add	r1, sp, #16
   33a82:	689b      	ldr	r3, [r3, #8]
   33a84:	4798      	blx	r3
   33a86:	2800      	cmp	r0, #0
   33a88:	da11      	bge.n	33aae <gnss_interface_read+0x96>
   33a8a:	f1bb 0f00 	cmp.w	fp, #0
   33a8e:	d141      	bne.n	33b14 <gnss_interface_read+0xfc>
   33a90:	682b      	ldr	r3, [r5, #0]
   33a92:	03d8      	lsls	r0, r3, #15
   33a94:	d4f0      	bmi.n	33a78 <gnss_interface_read+0x60>
   33a96:	b10c      	cbz	r4, 33a9c <gnss_interface_read+0x84>
   33a98:	e7ee      	b.n	33a78 <gnss_interface_read+0x60>
   33a9a:	b930      	cbnz	r0, 33aaa <gnss_interface_read+0x92>
   33a9c:	4639      	mov	r1, r7
   33a9e:	4630      	mov	r0, r6
   33aa0:	f7f6 fffc 	bl	2aa9c <bsd_os_timedwait>
   33aa4:	682b      	ldr	r3, [r5, #0]
   33aa6:	03d9      	lsls	r1, r3, #15
   33aa8:	d5f7      	bpl.n	33a9a <gnss_interface_read+0x82>
   33aaa:	4604      	mov	r4, r0
   33aac:	e7e4      	b.n	33a78 <gnss_interface_read+0x60>
   33aae:	f244 0202 	movw	r2, #16386	; 0x4002
   33ab2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   33ab6:	4293      	cmp	r3, r2
   33ab8:	d042      	beq.n	33b40 <gnss_interface_read+0x128>
   33aba:	f244 0201 	movw	r2, #16385	; 0x4001
   33abe:	4293      	cmp	r3, r2
   33ac0:	d056      	beq.n	33b70 <gnss_interface_read+0x158>
   33ac2:	f244 0203 	movw	r2, #16387	; 0x4003
   33ac6:	4293      	cmp	r3, r2
   33ac8:	f040 81a5 	bne.w	33e16 <gnss_interface_read+0x3fe>
   33acc:	2203      	movs	r2, #3
   33ace:	2414      	movs	r4, #20
   33ad0:	9b08      	ldr	r3, [sp, #32]
   33ad2:	f888 2000 	strb.w	r2, [r8]
   33ad6:	9a09      	ldr	r2, [sp, #36]	; 0x24
   33ad8:	f8c8 3008 	str.w	r3, [r8, #8]
   33adc:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   33ae0:	e9c8 2303 	strd	r2, r3, [r8, #12]
   33ae4:	f8da 0000 	ldr.w	r0, [sl]
   33ae8:	6803      	ldr	r3, [r0, #0]
   33aea:	68db      	ldr	r3, [r3, #12]
   33aec:	4798      	blx	r3
   33aee:	2800      	cmp	r0, #0
   33af0:	dd03      	ble.n	33afa <gnss_interface_read+0xe2>
   33af2:	682b      	ldr	r3, [r5, #0]
   33af4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   33af8:	602b      	str	r3, [r5, #0]
   33afa:	4620      	mov	r0, r4
   33afc:	b037      	add	sp, #220	; 0xdc
   33afe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   33b02:	f019 0f0a 	tst.w	r9, #10
   33b06:	d1a3      	bne.n	33a50 <gnss_interface_read+0x38>
   33b08:	202d      	movs	r0, #45	; 0x2d
   33b0a:	f7f7 f85b 	bl	2abc4 <bsd_os_errno_set>
   33b0e:	f04f 34ff 	mov.w	r4, #4294967295
   33b12:	e7f2      	b.n	33afa <gnss_interface_read+0xe2>
   33b14:	1c42      	adds	r2, r0, #1
   33b16:	4603      	mov	r3, r0
   33b18:	d1c9      	bne.n	33aae <gnss_interface_read+0x96>
   33b1a:	b93c      	cbnz	r4, 33b2c <gnss_interface_read+0x114>
   33b1c:	461c      	mov	r4, r3
   33b1e:	2023      	movs	r0, #35	; 0x23
   33b20:	f7f7 f850 	bl	2abc4 <bsd_os_errno_set>
   33b24:	4620      	mov	r0, r4
   33b26:	b037      	add	sp, #220	; 0xdc
   33b28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   33b2c:	9001      	str	r0, [sp, #4]
   33b2e:	4620      	mov	r0, r4
   33b30:	f7f7 f848 	bl	2abc4 <bsd_os_errno_set>
   33b34:	9b01      	ldr	r3, [sp, #4]
   33b36:	461c      	mov	r4, r3
   33b38:	4620      	mov	r0, r4
   33b3a:	b037      	add	sp, #220	; 0xdc
   33b3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   33b40:	a808      	add	r0, sp, #32
   33b42:	f7e9 fb09 	bl	1d158 <strlen>
   33b46:	2302      	movs	r3, #2
   33b48:	1c44      	adds	r4, r0, #1
   33b4a:	b2a4      	uxth	r4, r4
   33b4c:	f808 3b08 	strb.w	r3, [r8], #8
   33b50:	4622      	mov	r2, r4
   33b52:	a908      	add	r1, sp, #32
   33b54:	4640      	mov	r0, r8
   33b56:	f00a fe79 	bl	3e84c <memcpy>
   33b5a:	3408      	adds	r4, #8
   33b5c:	e7c2      	b.n	33ae4 <gnss_interface_read+0xcc>
   33b5e:	bf00      	nop
   33b60:	49765443 	.word	0x49765443
   33b64:	20025514 	.word	0x20025514
   33b68:	200346f8 	.word	0x200346f8
   33b6c:	2002551c 	.word	0x2002551c
   33b70:	2401      	movs	r4, #1
   33b72:	a809      	add	r0, sp, #36	; 0x24
   33b74:	c80f      	ldmia	r0, {r0, r1, r2, r3}
   33b76:	e9c8 0102 	strd	r0, r1, [r8, #8]
   33b7a:	e9c8 2304 	strd	r2, r3, [r8, #16]
   33b7e:	990d      	ldr	r1, [sp, #52]	; 0x34
   33b80:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   33b82:	f888 4000 	strb.w	r4, [r8]
   33b86:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   33b88:	f8c8 1018 	str.w	r1, [r8, #24]
   33b8c:	9910      	ldr	r1, [sp, #64]	; 0x40
   33b8e:	f8c8 201c 	str.w	r2, [r8, #28]
   33b92:	f8c8 3020 	str.w	r3, [r8, #32]
   33b96:	f89d 205d 	ldrb.w	r2, [sp, #93]	; 0x5d
   33b9a:	f8dd 304d 	ldr.w	r3, [sp, #77]	; 0x4d
   33b9e:	f8c8 1024 	str.w	r1, [r8, #36]	; 0x24
   33ba2:	f8dd 1051 	ldr.w	r1, [sp, #81]	; 0x51
   33ba6:	f888 2044 	strb.w	r2, [r8, #68]	; 0x44
   33baa:	f8dd 2055 	ldr.w	r2, [sp, #85]	; 0x55
   33bae:	f8c8 3034 	str.w	r3, [r8, #52]	; 0x34
   33bb2:	f8dd 3059 	ldr.w	r3, [sp, #89]	; 0x59
   33bb6:	f8c8 1038 	str.w	r1, [r8, #56]	; 0x38
   33bba:	f8bd 1044 	ldrh.w	r1, [sp, #68]	; 0x44
   33bbe:	f8c8 203c 	str.w	r2, [r8, #60]	; 0x3c
   33bc2:	f8c8 3040 	str.w	r3, [r8, #64]	; 0x40
   33bc6:	f8dd 2046 	ldr.w	r2, [sp, #70]	; 0x46
   33bca:	f89d 304a 	ldrb.w	r3, [sp, #74]	; 0x4a
   33bce:	f8a8 1028 	strh.w	r1, [r8, #40]	; 0x28
   33bd2:	f888 302e 	strb.w	r3, [r8, #46]	; 0x2e
   33bd6:	f8c8 202a 	str.w	r2, [r8, #42]	; 0x2a
   33bda:	f89d 004b 	ldrb.w	r0, [sp, #75]	; 0x4b
   33bde:	f89d 204c 	ldrb.w	r2, [sp, #76]	; 0x4c
   33be2:	9b18      	ldr	r3, [sp, #96]	; 0x60
   33be4:	f89d 406c 	ldrb.w	r4, [sp, #108]	; 0x6c
   33be8:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
   33bec:	f89d 206b 	ldrb.w	r2, [sp, #107]	; 0x6b
   33bf0:	f3c3 210f 	ubfx	r1, r3, #8, #16
   33bf4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   33bf6:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
   33bfa:	f8a8 0030 	strh.w	r0, [r8, #48]	; 0x30
   33bfe:	f8a8 104a 	strh.w	r1, [r8, #74]	; 0x4a
   33c02:	f8bd 105e 	ldrh.w	r1, [sp, #94]	; 0x5e
   33c06:	f3c3 230f 	ubfx	r3, r3, #8, #16
   33c0a:	f8a8 2056 	strh.w	r2, [r8, #86]	; 0x56
   33c0e:	f89d 2060 	ldrb.w	r2, [sp, #96]	; 0x60
   33c12:	f8a8 3062 	strh.w	r3, [r8, #98]	; 0x62
   33c16:	f8dd 3063 	ldr.w	r3, [sp, #99]	; 0x63
   33c1a:	f8a8 1046 	strh.w	r1, [r8, #70]	; 0x46
   33c1e:	f888 2048 	strb.w	r2, [r8, #72]	; 0x48
   33c22:	f8bd 2068 	ldrh.w	r2, [sp, #104]	; 0x68
   33c26:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
   33c2a:	f8c8 304c 	str.w	r3, [r8, #76]	; 0x4c
   33c2e:	f89d 306a 	ldrb.w	r3, [sp, #106]	; 0x6a
   33c32:	f888 1050 	strb.w	r1, [r8, #80]	; 0x50
   33c36:	f8a8 2052 	strh.w	r2, [r8, #82]	; 0x52
   33c3a:	f888 3054 	strb.w	r3, [r8, #84]	; 0x54
   33c3e:	f8bd 3072 	ldrh.w	r3, [sp, #114]	; 0x72
   33c42:	f8dd 106d 	ldr.w	r1, [sp, #109]	; 0x6d
   33c46:	f89d 2071 	ldrb.w	r2, [sp, #113]	; 0x71
   33c4a:	f8c8 1058 	str.w	r1, [r8, #88]	; 0x58
   33c4e:	f888 205c 	strb.w	r2, [r8, #92]	; 0x5c
   33c52:	f89d 1074 	ldrb.w	r1, [sp, #116]	; 0x74
   33c56:	f8dd 2077 	ldr.w	r2, [sp, #119]	; 0x77
   33c5a:	f8a8 305e 	strh.w	r3, [r8, #94]	; 0x5e
   33c5e:	f89d 307b 	ldrb.w	r3, [sp, #123]	; 0x7b
   33c62:	f888 1060 	strb.w	r1, [r8, #96]	; 0x60
   33c66:	f8c8 2064 	str.w	r2, [r8, #100]	; 0x64
   33c6a:	f888 3068 	strb.w	r3, [r8, #104]	; 0x68
   33c6e:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
   33c72:	f89d 107f 	ldrb.w	r1, [sp, #127]	; 0x7f
   33c76:	9a22      	ldr	r2, [sp, #136]	; 0x88
   33c78:	f89d 0094 	ldrb.w	r0, [sp, #148]	; 0x94
   33c7c:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
   33c80:	f89d 3093 	ldrb.w	r3, [sp, #147]	; 0x93
   33c84:	f3c2 220f 	ubfx	r2, r2, #8, #16
   33c88:	f8a8 106e 	strh.w	r1, [r8, #110]	; 0x6e
   33c8c:	f8bd 107c 	ldrh.w	r1, [sp, #124]	; 0x7c
   33c90:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   33c94:	f8a8 207a 	strh.w	r2, [r8, #122]	; 0x7a
   33c98:	f89d 207e 	ldrb.w	r2, [sp, #126]	; 0x7e
   33c9c:	f8a8 3086 	strh.w	r3, [r8, #134]	; 0x86
   33ca0:	f8dd 3081 	ldr.w	r3, [sp, #129]	; 0x81
   33ca4:	f8a8 106a 	strh.w	r1, [r8, #106]	; 0x6a
   33ca8:	f888 206c 	strb.w	r2, [r8, #108]	; 0x6c
   33cac:	f8bd 2086 	ldrh.w	r2, [sp, #134]	; 0x86
   33cb0:	f89d 1085 	ldrb.w	r1, [sp, #133]	; 0x85
   33cb4:	f8c8 3070 	str.w	r3, [r8, #112]	; 0x70
   33cb8:	f89d 3088 	ldrb.w	r3, [sp, #136]	; 0x88
   33cbc:	f888 1074 	strb.w	r1, [r8, #116]	; 0x74
   33cc0:	f8a8 2076 	strh.w	r2, [r8, #118]	; 0x76
   33cc4:	f888 3078 	strb.w	r3, [r8, #120]	; 0x78
   33cc8:	f8bd 3090 	ldrh.w	r3, [sp, #144]	; 0x90
   33ccc:	f8dd 108b 	ldr.w	r1, [sp, #139]	; 0x8b
   33cd0:	f89d 208f 	ldrb.w	r2, [sp, #143]	; 0x8f
   33cd4:	f8c8 107c 	str.w	r1, [r8, #124]	; 0x7c
   33cd8:	f888 2080 	strb.w	r2, [r8, #128]	; 0x80
   33cdc:	f89d 1092 	ldrb.w	r1, [sp, #146]	; 0x92
   33ce0:	f8dd 2095 	ldr.w	r2, [sp, #149]	; 0x95
   33ce4:	f8a8 3082 	strh.w	r3, [r8, #130]	; 0x82
   33ce8:	f89d 3099 	ldrb.w	r3, [sp, #153]	; 0x99
   33cec:	f888 1084 	strb.w	r1, [r8, #132]	; 0x84
   33cf0:	f8c8 2088 	str.w	r2, [r8, #136]	; 0x88
   33cf4:	f888 308c 	strb.w	r3, [r8, #140]	; 0x8c
   33cf8:	f8bd 009a 	ldrh.w	r0, [sp, #154]	; 0x9a
   33cfc:	9b27      	ldr	r3, [sp, #156]	; 0x9c
   33cfe:	f89d 40a8 	ldrb.w	r4, [sp, #168]	; 0xa8
   33d02:	f89d 20a7 	ldrb.w	r2, [sp, #167]	; 0xa7
   33d06:	f3c3 210f 	ubfx	r1, r3, #8, #16
   33d0a:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   33d0c:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
   33d10:	f8a8 1092 	strh.w	r1, [r8, #146]	; 0x92
   33d14:	f89d 109c 	ldrb.w	r1, [sp, #156]	; 0x9c
   33d18:	f8a8 209e 	strh.w	r2, [r8, #158]	; 0x9e
   33d1c:	f3c3 230f 	ubfx	r3, r3, #8, #16
   33d20:	f8dd 209f 	ldr.w	r2, [sp, #159]	; 0x9f
   33d24:	f8a8 008e 	strh.w	r0, [r8, #142]	; 0x8e
   33d28:	f8a8 30aa 	strh.w	r3, [r8, #170]	; 0xaa
   33d2c:	f888 1090 	strb.w	r1, [r8, #144]	; 0x90
   33d30:	f89d 30a3 	ldrb.w	r3, [sp, #163]	; 0xa3
   33d34:	f8bd 10a4 	ldrh.w	r1, [sp, #164]	; 0xa4
   33d38:	f8c8 2094 	str.w	r2, [r8, #148]	; 0x94
   33d3c:	f89d 20a6 	ldrb.w	r2, [sp, #166]	; 0xa6
   33d40:	f888 3098 	strb.w	r3, [r8, #152]	; 0x98
   33d44:	f8dd 30a9 	ldr.w	r3, [sp, #169]	; 0xa9
   33d48:	f8a8 109a 	strh.w	r1, [r8, #154]	; 0x9a
   33d4c:	f888 209c 	strb.w	r2, [r8, #156]	; 0x9c
   33d50:	f8bd 20ae 	ldrh.w	r2, [sp, #174]	; 0xae
   33d54:	f89d 10ad 	ldrb.w	r1, [sp, #173]	; 0xad
   33d58:	f8c8 30a0 	str.w	r3, [r8, #160]	; 0xa0
   33d5c:	f89d 30b0 	ldrb.w	r3, [sp, #176]	; 0xb0
   33d60:	f888 10a4 	strb.w	r1, [r8, #164]	; 0xa4
   33d64:	f8a8 20a6 	strh.w	r2, [r8, #166]	; 0xa6
   33d68:	f888 30a8 	strb.w	r3, [r8, #168]	; 0xa8
   33d6c:	f8bd 30b8 	ldrh.w	r3, [sp, #184]	; 0xb8
   33d70:	f8dd 10b3 	ldr.w	r1, [sp, #179]	; 0xb3
   33d74:	f89d 20b7 	ldrb.w	r2, [sp, #183]	; 0xb7
   33d78:	f8c8 10ac 	str.w	r1, [r8, #172]	; 0xac
   33d7c:	f888 20b0 	strb.w	r2, [r8, #176]	; 0xb0
   33d80:	f8a8 30b2 	strh.w	r3, [r8, #178]	; 0xb2
   33d84:	f89d 30bc 	ldrb.w	r3, [sp, #188]	; 0xbc
   33d88:	f89d 10bb 	ldrb.w	r1, [sp, #187]	; 0xbb
   33d8c:	f89d 00d0 	ldrb.w	r0, [sp, #208]	; 0xd0
   33d90:	9a31      	ldr	r2, [sp, #196]	; 0xc4
   33d92:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
   33d96:	f89d 30cf 	ldrb.w	r3, [sp, #207]	; 0xcf
   33d9a:	f89d 40ba 	ldrb.w	r4, [sp, #186]	; 0xba
   33d9e:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   33da2:	f3c2 220f 	ubfx	r2, r2, #8, #16
   33da6:	f8a8 10b6 	strh.w	r1, [r8, #182]	; 0xb6
   33daa:	f8a8 30ce 	strh.w	r3, [r8, #206]	; 0xce
   33dae:	f888 40b4 	strb.w	r4, [r8, #180]	; 0xb4
   33db2:	f8a8 20c2 	strh.w	r2, [r8, #194]	; 0xc2
   33db6:	f8bd 20c2 	ldrh.w	r2, [sp, #194]	; 0xc2
   33dba:	f89d 10c1 	ldrb.w	r1, [sp, #193]	; 0xc1
   33dbe:	f89d 30c4 	ldrb.w	r3, [sp, #196]	; 0xc4
   33dc2:	f8dd 00bd 	ldr.w	r0, [sp, #189]	; 0xbd
   33dc6:	f888 10bc 	strb.w	r1, [r8, #188]	; 0xbc
   33dca:	f8a8 20be 	strh.w	r2, [r8, #190]	; 0xbe
   33dce:	f8c8 00b8 	str.w	r0, [r8, #184]	; 0xb8
   33dd2:	f888 30c0 	strb.w	r3, [r8, #192]	; 0xc0
   33dd6:	f8bd 30cc 	ldrh.w	r3, [sp, #204]	; 0xcc
   33dda:	f8dd 10c7 	ldr.w	r1, [sp, #199]	; 0xc7
   33dde:	f89d 20cb 	ldrb.w	r2, [sp, #203]	; 0xcb
   33de2:	f8c8 10c4 	str.w	r1, [r8, #196]	; 0xc4
   33de6:	f888 20c8 	strb.w	r2, [r8, #200]	; 0xc8
   33dea:	f89d 10ce 	ldrb.w	r1, [sp, #206]	; 0xce
   33dee:	f8dd 20d1 	ldr.w	r2, [sp, #209]	; 0xd1
   33df2:	f8a8 30ca 	strh.w	r3, [r8, #202]	; 0xca
   33df6:	f89d 30d5 	ldrb.w	r3, [sp, #213]	; 0xd5
   33dfa:	f888 10cc 	strb.w	r1, [r8, #204]	; 0xcc
   33dfe:	f8c8 20d0 	str.w	r2, [r8, #208]	; 0xd0
   33e02:	f888 30d4 	strb.w	r3, [r8, #212]	; 0xd4
   33e06:	24d8      	movs	r4, #216	; 0xd8
   33e08:	e66c      	b.n	33ae4 <gnss_interface_read+0xcc>
   33e0a:	2039      	movs	r0, #57	; 0x39
   33e0c:	f7f6 feda 	bl	2abc4 <bsd_os_errno_set>
   33e10:	f04f 34ff 	mov.w	r4, #4294967295
   33e14:	e671      	b.n	33afa <gnss_interface_read+0xe2>
   33e16:	2016      	movs	r0, #22
   33e18:	f7f6 fed4 	bl	2abc4 <bsd_os_errno_set>
   33e1c:	f04f 34ff 	mov.w	r4, #4294967295
   33e20:	e66b      	b.n	33afa <gnss_interface_read+0xe2>
   33e22:	2009      	movs	r0, #9
   33e24:	f7f6 fece 	bl	2abc4 <bsd_os_errno_set>
   33e28:	f04f 34ff 	mov.w	r4, #4294967295
   33e2c:	e665      	b.n	33afa <gnss_interface_read+0xe2>
   33e2e:	bf00      	nop

00033e30 <gnss_interface_setopt>:
   33e30:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   33e34:	f241 1402 	movw	r4, #4354	; 0x1102
   33e38:	4222      	tst	r2, r4
   33e3a:	b086      	sub	sp, #24
   33e3c:	4d9c      	ldr	r5, [pc, #624]	; (340b0 <gnss_interface_setopt+0x280>)
   33e3e:	d004      	beq.n	33e4a <gnss_interface_setopt+0x1a>
   33e40:	682c      	ldr	r4, [r5, #0]
   33e42:	b2a4      	uxth	r4, r4
   33e44:	2c02      	cmp	r4, #2
   33e46:	f040 8104 	bne.w	34052 <gnss_interface_setopt+0x222>
   33e4a:	682c      	ldr	r4, [r5, #0]
   33e4c:	0264      	lsls	r4, r4, #9
   33e4e:	f100 8128 	bmi.w	340a2 <gnss_interface_setopt+0x272>
   33e52:	f5b1 7f01 	cmp.w	r1, #516	; 0x204
   33e56:	f040 811e 	bne.w	34096 <gnss_interface_setopt+0x266>
   33e5a:	4996      	ldr	r1, [pc, #600]	; (340b4 <gnss_interface_setopt+0x284>)
   33e5c:	4288      	cmp	r0, r1
   33e5e:	f040 8114 	bne.w	3408a <gnss_interface_setopt+0x25a>
   33e62:	3a01      	subs	r2, #1
   33e64:	2a08      	cmp	r2, #8
   33e66:	f200 80ec 	bhi.w	34042 <gnss_interface_setopt+0x212>
   33e6a:	e8df f012 	tbh	[pc, r2, lsl #1]
   33e6e:	0075      	.short	0x0075
   33e70:	00c200d8 	.word	0x00c200d8
   33e74:	008100cc 	.word	0x008100cc
   33e78:	0098008c 	.word	0x0098008c
   33e7c:	000900af 	.word	0x000900af
   33e80:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   33e82:	2a01      	cmp	r2, #1
   33e84:	f040 80dd 	bne.w	34042 <gnss_interface_setopt+0x212>
   33e88:	f241 1603 	movw	r6, #4355	; 0x1103
   33e8c:	2240      	movs	r2, #64	; 0x40
   33e8e:	4637      	mov	r7, r6
   33e90:	781b      	ldrb	r3, [r3, #0]
   33e92:	9202      	str	r2, [sp, #8]
   33e94:	f88d 3015 	strb.w	r3, [sp, #21]
   33e98:	682b      	ldr	r3, [r5, #0]
   33e9a:	2112      	movs	r1, #18
   33e9c:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   33ea0:	4668      	mov	r0, sp
   33ea2:	602b      	str	r3, [r5, #0]
   33ea4:	f000 fbe4 	bl	34670 <rpc_gnss_client_request_alloc>
   33ea8:	4604      	mov	r4, r0
   33eaa:	9800      	ldr	r0, [sp, #0]
   33eac:	2c00      	cmp	r4, #0
   33eae:	f040 80d6 	bne.w	3405e <gnss_interface_setopt+0x22e>
   33eb2:	2800      	cmp	r0, #0
   33eb4:	f000 80da 	beq.w	3406c <gnss_interface_setopt+0x23c>
   33eb8:	2212      	movs	r2, #18
   33eba:	f04f 0876 	mov.w	r8, #118	; 0x76
   33ebe:	f04f 0e49 	mov.w	lr, #73	; 0x49
   33ec2:	f04f 0a43 	mov.w	sl, #67	; 0x43
   33ec6:	f04f 0954 	mov.w	r9, #84	; 0x54
   33eca:	f8df c1f0 	ldr.w	ip, [pc, #496]	; 340bc <gnss_interface_setopt+0x28c>
   33ece:	a906      	add	r1, sp, #24
   33ed0:	f8bc 3000 	ldrh.w	r3, [ip]
   33ed4:	f880 800e 	strb.w	r8, [r0, #14]
   33ed8:	3301      	adds	r3, #1
   33eda:	b29b      	uxth	r3, r3
   33edc:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
   33ee0:	f841 6d14 	str.w	r6, [r1, #-20]!
   33ee4:	7144      	strb	r4, [r0, #5]
   33ee6:	7184      	strb	r4, [r0, #6]
   33ee8:	71c4      	strb	r4, [r0, #7]
   33eea:	7204      	strb	r4, [r0, #8]
   33eec:	7244      	strb	r4, [r0, #9]
   33eee:	7284      	strb	r4, [r0, #10]
   33ef0:	72c4      	strb	r4, [r0, #11]
   33ef2:	7102      	strb	r2, [r0, #4]
   33ef4:	f880 a00c 	strb.w	sl, [r0, #12]
   33ef8:	f880 900d 	strb.w	r9, [r0, #13]
   33efc:	f880 e00f 	strb.w	lr, [r0, #15]
   33f00:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 340c0 <gnss_interface_setopt+0x290>
   33f04:	6800      	ldr	r0, [r0, #0]
   33f06:	f8ac 3000 	strh.w	r3, [ip]
   33f0a:	f00a fc9f 	bl	3e84c <memcpy>
   33f0e:	4639      	mov	r1, r7
   33f10:	9800      	ldr	r0, [sp, #0]
   33f12:	f8c8 4000 	str.w	r4, [r8]
   33f16:	f000 fbbf 	bl	34698 <rpc_gnss_client_request_send>
   33f1a:	2800      	cmp	r0, #0
   33f1c:	f040 80ab 	bne.w	34076 <gnss_interface_setopt+0x246>
   33f20:	4f65      	ldr	r7, [pc, #404]	; (340b8 <gnss_interface_setopt+0x288>)
   33f22:	4e64      	ldr	r6, [pc, #400]	; (340b4 <gnss_interface_setopt+0x284>)
   33f24:	4639      	mov	r1, r7
   33f26:	4630      	mov	r0, r6
   33f28:	f7f6 fdb8 	bl	2aa9c <bsd_os_timedwait>
   33f2c:	682c      	ldr	r4, [r5, #0]
   33f2e:	f414 0480 	ands.w	r4, r4, #4194304	; 0x400000
   33f32:	d1f7      	bne.n	33f24 <gnss_interface_setopt+0xf4>
   33f34:	f8d8 0000 	ldr.w	r0, [r8]
   33f38:	b118      	cbz	r0, 33f42 <gnss_interface_setopt+0x112>
   33f3a:	f000 fbcb 	bl	346d4 <rpc_gnss_client_data_free>
   33f3e:	f8c8 4000 	str.w	r4, [r8]
   33f42:	682b      	ldr	r3, [r5, #0]
   33f44:	021b      	lsls	r3, r3, #8
   33f46:	d576      	bpl.n	34036 <gnss_interface_setopt+0x206>
   33f48:	2000      	movs	r0, #0
   33f4a:	682b      	ldr	r3, [r5, #0]
   33f4c:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   33f50:	602b      	str	r3, [r5, #0]
   33f52:	b006      	add	sp, #24
   33f54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   33f58:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   33f5a:	2a02      	cmp	r2, #2
   33f5c:	d171      	bne.n	34042 <gnss_interface_setopt+0x212>
   33f5e:	2208      	movs	r2, #8
   33f60:	f241 1603 	movw	r6, #4355	; 0x1103
   33f64:	881b      	ldrh	r3, [r3, #0]
   33f66:	9202      	str	r2, [sp, #8]
   33f68:	f8ad 300f 	strh.w	r3, [sp, #15]
   33f6c:	4637      	mov	r7, r6
   33f6e:	e793      	b.n	33e98 <gnss_interface_setopt+0x68>
   33f70:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   33f72:	2a01      	cmp	r2, #1
   33f74:	d165      	bne.n	34042 <gnss_interface_setopt+0x212>
   33f76:	f241 1603 	movw	r6, #4355	; 0x1103
   33f7a:	781b      	ldrb	r3, [r3, #0]
   33f7c:	9202      	str	r2, [sp, #8]
   33f7e:	f88d 300c 	strb.w	r3, [sp, #12]
   33f82:	4637      	mov	r7, r6
   33f84:	e788      	b.n	33e98 <gnss_interface_setopt+0x68>
   33f86:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   33f88:	2a01      	cmp	r2, #1
   33f8a:	d15a      	bne.n	34042 <gnss_interface_setopt+0x212>
   33f8c:	2202      	movs	r2, #2
   33f8e:	f241 1603 	movw	r6, #4355	; 0x1103
   33f92:	781b      	ldrb	r3, [r3, #0]
   33f94:	9202      	str	r2, [sp, #8]
   33f96:	f88d 300d 	strb.w	r3, [sp, #13]
   33f9a:	4637      	mov	r7, r6
   33f9c:	e77c      	b.n	33e98 <gnss_interface_setopt+0x68>
   33f9e:	682a      	ldr	r2, [r5, #0]
   33fa0:	b292      	uxth	r2, r2
   33fa2:	2a02      	cmp	r2, #2
   33fa4:	d155      	bne.n	34052 <gnss_interface_setopt+0x222>
   33fa6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   33fa8:	2a04      	cmp	r2, #4
   33faa:	d14a      	bne.n	34042 <gnss_interface_setopt+0x212>
   33fac:	2101      	movs	r1, #1
   33fae:	f241 0604 	movw	r6, #4100	; 0x1004
   33fb2:	682a      	ldr	r2, [r5, #0]
   33fb4:	6818      	ldr	r0, [r3, #0]
   33fb6:	0c13      	lsrs	r3, r2, #16
   33fb8:	041b      	lsls	r3, r3, #16
   33fba:	f043 0303 	orr.w	r3, r3, #3
   33fbe:	f8cd 0009 	str.w	r0, [sp, #9]
   33fc2:	602b      	str	r3, [r5, #0]
   33fc4:	f88d 1008 	strb.w	r1, [sp, #8]
   33fc8:	4637      	mov	r7, r6
   33fca:	e765      	b.n	33e98 <gnss_interface_setopt+0x68>
   33fcc:	682b      	ldr	r3, [r5, #0]
   33fce:	b29b      	uxth	r3, r3
   33fd0:	2b04      	cmp	r3, #4
   33fd2:	d13e      	bne.n	34052 <gnss_interface_setopt+0x222>
   33fd4:	2300      	movs	r3, #0
   33fd6:	f241 0604 	movw	r6, #4100	; 0x1004
   33fda:	f88d 3008 	strb.w	r3, [sp, #8]
   33fde:	f88d 3009 	strb.w	r3, [sp, #9]
   33fe2:	f88d 300a 	strb.w	r3, [sp, #10]
   33fe6:	f88d 300b 	strb.w	r3, [sp, #11]
   33fea:	f88d 300c 	strb.w	r3, [sp, #12]
   33fee:	4637      	mov	r7, r6
   33ff0:	e752      	b.n	33e98 <gnss_interface_setopt+0x68>
   33ff2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   33ff4:	2a01      	cmp	r2, #1
   33ff6:	d124      	bne.n	34042 <gnss_interface_setopt+0x212>
   33ff8:	781b      	ldrb	r3, [r3, #0]
   33ffa:	2b01      	cmp	r3, #1
   33ffc:	d121      	bne.n	34042 <gnss_interface_setopt+0x212>
   33ffe:	f241 1603 	movw	r6, #4355	; 0x1103
   34002:	4637      	mov	r7, r6
   34004:	e748      	b.n	33e98 <gnss_interface_setopt+0x68>
   34006:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   34008:	2a02      	cmp	r2, #2
   3400a:	d11a      	bne.n	34042 <gnss_interface_setopt+0x212>
   3400c:	2220      	movs	r2, #32
   3400e:	f241 1603 	movw	r6, #4355	; 0x1103
   34012:	881b      	ldrh	r3, [r3, #0]
   34014:	9202      	str	r2, [sp, #8]
   34016:	f8ad 3013 	strh.w	r3, [sp, #19]
   3401a:	4637      	mov	r7, r6
   3401c:	e73c      	b.n	33e98 <gnss_interface_setopt+0x68>
   3401e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   34020:	2a02      	cmp	r2, #2
   34022:	d10e      	bne.n	34042 <gnss_interface_setopt+0x212>
   34024:	2210      	movs	r2, #16
   34026:	f241 1603 	movw	r6, #4355	; 0x1103
   3402a:	881b      	ldrh	r3, [r3, #0]
   3402c:	9202      	str	r2, [sp, #8]
   3402e:	f8ad 3011 	strh.w	r3, [sp, #17]
   34032:	4637      	mov	r7, r6
   34034:	e730      	b.n	33e98 <gnss_interface_setopt+0x68>
   34036:	200e      	movs	r0, #14
   34038:	f7f6 fdc4 	bl	2abc4 <bsd_os_errno_set>
   3403c:	f04f 30ff 	mov.w	r0, #4294967295
   34040:	e783      	b.n	33f4a <gnss_interface_setopt+0x11a>
   34042:	2016      	movs	r0, #22
   34044:	f7f6 fdbe 	bl	2abc4 <bsd_os_errno_set>
   34048:	f04f 30ff 	mov.w	r0, #4294967295
   3404c:	b006      	add	sp, #24
   3404e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   34052:	200e      	movs	r0, #14
   34054:	f7f6 fdb6 	bl	2abc4 <bsd_os_errno_set>
   34058:	f04f 30ff 	mov.w	r0, #4294967295
   3405c:	e779      	b.n	33f52 <gnss_interface_setopt+0x122>
   3405e:	b128      	cbz	r0, 3406c <gnss_interface_setopt+0x23c>
   34060:	6803      	ldr	r3, [r0, #0]
   34062:	b11b      	cbz	r3, 3406c <gnss_interface_setopt+0x23c>
   34064:	4618      	mov	r0, r3
   34066:	f000 fb35 	bl	346d4 <rpc_gnss_client_data_free>
   3406a:	9800      	ldr	r0, [sp, #0]
   3406c:	f000 fb2a 	bl	346c4 <rpc_gnss_client_message_free>
   34070:	2023      	movs	r0, #35	; 0x23
   34072:	f7f6 fda7 	bl	2abc4 <bsd_os_errno_set>
   34076:	682b      	ldr	r3, [r5, #0]
   34078:	200e      	movs	r0, #14
   3407a:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   3407e:	602b      	str	r3, [r5, #0]
   34080:	f7f6 fda0 	bl	2abc4 <bsd_os_errno_set>
   34084:	f04f 30ff 	mov.w	r0, #4294967295
   34088:	e763      	b.n	33f52 <gnss_interface_setopt+0x122>
   3408a:	2009      	movs	r0, #9
   3408c:	f7f6 fd9a 	bl	2abc4 <bsd_os_errno_set>
   34090:	f04f 30ff 	mov.w	r0, #4294967295
   34094:	e75d      	b.n	33f52 <gnss_interface_setopt+0x122>
   34096:	202a      	movs	r0, #42	; 0x2a
   34098:	f7f6 fd94 	bl	2abc4 <bsd_os_errno_set>
   3409c:	f04f 30ff 	mov.w	r0, #4294967295
   340a0:	e757      	b.n	33f52 <gnss_interface_setopt+0x122>
   340a2:	2073      	movs	r0, #115	; 0x73
   340a4:	f7f6 fd8e 	bl	2abc4 <bsd_os_errno_set>
   340a8:	f04f 30ff 	mov.w	r0, #4294967295
   340ac:	e751      	b.n	33f52 <gnss_interface_setopt+0x122>
   340ae:	bf00      	nop
   340b0:	20025514 	.word	0x20025514
   340b4:	49765443 	.word	0x49765443
   340b8:	200346f8 	.word	0x200346f8
   340bc:	20029914 	.word	0x20029914
   340c0:	20025518 	.word	0x20025518

000340c4 <gnss_interface_getopt>:
   340c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   340c8:	4c81      	ldr	r4, [pc, #516]	; (342d0 <gnss_interface_getopt+0x20c>)
   340ca:	b087      	sub	sp, #28
   340cc:	6825      	ldr	r5, [r4, #0]
   340ce:	4698      	mov	r8, r3
   340d0:	b2ad      	uxth	r5, r5
   340d2:	2d02      	cmp	r5, #2
   340d4:	9b10      	ldr	r3, [sp, #64]	; 0x40
   340d6:	f040 80dd 	bne.w	34294 <gnss_interface_getopt+0x1d0>
   340da:	6825      	ldr	r5, [r4, #0]
   340dc:	03ee      	lsls	r6, r5, #15
   340de:	f100 80eb 	bmi.w	342b8 <gnss_interface_getopt+0x1f4>
   340e2:	6825      	ldr	r5, [r4, #0]
   340e4:	01ed      	lsls	r5, r5, #7
   340e6:	f100 80ed 	bmi.w	342c4 <gnss_interface_getopt+0x200>
   340ea:	f5b1 7f01 	cmp.w	r1, #516	; 0x204
   340ee:	f040 80d7 	bne.w	342a0 <gnss_interface_getopt+0x1dc>
   340f2:	4978      	ldr	r1, [pc, #480]	; (342d4 <gnss_interface_getopt+0x210>)
   340f4:	4288      	cmp	r0, r1
   340f6:	f040 80d9 	bne.w	342ac <gnss_interface_getopt+0x1e8>
   340fa:	f1b8 0f00 	cmp.w	r8, #0
   340fe:	d00b      	beq.n	34118 <gnss_interface_getopt+0x54>
   34100:	b153      	cbz	r3, 34118 <gnss_interface_getopt+0x54>
   34102:	1e57      	subs	r7, r2, #1
   34104:	2f05      	cmp	r7, #5
   34106:	d807      	bhi.n	34118 <gnss_interface_getopt+0x54>
   34108:	e8df f007 	tbb	[pc, r7]
   3410c:	0f030f0f 	.word	0x0f030f0f
   34110:	0303      	.short	0x0303
   34112:	681b      	ldr	r3, [r3, #0]
   34114:	2b01      	cmp	r3, #1
   34116:	d00b      	beq.n	34130 <gnss_interface_getopt+0x6c>
   34118:	2016      	movs	r0, #22
   3411a:	f7f6 fd53 	bl	2abc4 <bsd_os_errno_set>
   3411e:	f04f 35ff 	mov.w	r5, #4294967295
   34122:	4628      	mov	r0, r5
   34124:	b007      	add	sp, #28
   34126:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3412a:	681b      	ldr	r3, [r3, #0]
   3412c:	2b02      	cmp	r3, #2
   3412e:	d1f3      	bne.n	34118 <gnss_interface_getopt+0x54>
   34130:	6823      	ldr	r3, [r4, #0]
   34132:	2212      	movs	r2, #18
   34134:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   34138:	2100      	movs	r1, #0
   3413a:	a801      	add	r0, sp, #4
   3413c:	6023      	str	r3, [r4, #0]
   3413e:	f00a fba5 	bl	3e88c <memset>
   34142:	2112      	movs	r1, #18
   34144:	4668      	mov	r0, sp
   34146:	f000 fa93 	bl	34670 <rpc_gnss_client_request_alloc>
   3414a:	4605      	mov	r5, r0
   3414c:	9800      	ldr	r0, [sp, #0]
   3414e:	2d00      	cmp	r5, #0
   34150:	f040 808a 	bne.w	34268 <gnss_interface_getopt+0x1a4>
   34154:	2800      	cmp	r0, #0
   34156:	f000 808e 	beq.w	34276 <gnss_interface_getopt+0x1b2>
   3415a:	f241 1602 	movw	r6, #4354	; 0x1102
   3415e:	f04f 0e49 	mov.w	lr, #73	; 0x49
   34162:	2212      	movs	r2, #18
   34164:	f04f 0976 	mov.w	r9, #118	; 0x76
   34168:	f04f 0b43 	mov.w	fp, #67	; 0x43
   3416c:	f04f 0a54 	mov.w	sl, #84	; 0x54
   34170:	f8df c168 	ldr.w	ip, [pc, #360]	; 342dc <gnss_interface_getopt+0x218>
   34174:	f880 e00f 	strb.w	lr, [r0, #15]
   34178:	f8bc 3000 	ldrh.w	r3, [ip]
   3417c:	f880 900e 	strb.w	r9, [r0, #14]
   34180:	3301      	adds	r3, #1
   34182:	b29b      	uxth	r3, r3
   34184:	ea46 4e03 	orr.w	lr, r6, r3, lsl #16
   34188:	f8cd e004 	str.w	lr, [sp, #4]
   3418c:	7145      	strb	r5, [r0, #5]
   3418e:	7185      	strb	r5, [r0, #6]
   34190:	71c5      	strb	r5, [r0, #7]
   34192:	7205      	strb	r5, [r0, #8]
   34194:	7245      	strb	r5, [r0, #9]
   34196:	7285      	strb	r5, [r0, #10]
   34198:	72c5      	strb	r5, [r0, #11]
   3419a:	a901      	add	r1, sp, #4
   3419c:	7102      	strb	r2, [r0, #4]
   3419e:	f880 b00c 	strb.w	fp, [r0, #12]
   341a2:	f880 a00d 	strb.w	sl, [r0, #13]
   341a6:	f8df 9138 	ldr.w	r9, [pc, #312]	; 342e0 <gnss_interface_getopt+0x21c>
   341aa:	6800      	ldr	r0, [r0, #0]
   341ac:	f8ac 3000 	strh.w	r3, [ip]
   341b0:	f00a fb4c 	bl	3e84c <memcpy>
   341b4:	4631      	mov	r1, r6
   341b6:	9800      	ldr	r0, [sp, #0]
   341b8:	f8c9 5000 	str.w	r5, [r9]
   341bc:	f000 fa6c 	bl	34698 <rpc_gnss_client_request_send>
   341c0:	2800      	cmp	r0, #0
   341c2:	d15d      	bne.n	34280 <gnss_interface_getopt+0x1bc>
   341c4:	4e44      	ldr	r6, [pc, #272]	; (342d8 <gnss_interface_getopt+0x214>)
   341c6:	4d43      	ldr	r5, [pc, #268]	; (342d4 <gnss_interface_getopt+0x210>)
   341c8:	4631      	mov	r1, r6
   341ca:	4628      	mov	r0, r5
   341cc:	f7f6 fc66 	bl	2aa9c <bsd_os_timedwait>
   341d0:	6823      	ldr	r3, [r4, #0]
   341d2:	01db      	lsls	r3, r3, #7
   341d4:	d4f8      	bmi.n	341c8 <gnss_interface_getopt+0x104>
   341d6:	f8d9 0000 	ldr.w	r0, [r9]
   341da:	b1d8      	cbz	r0, 34214 <gnss_interface_getopt+0x150>
   341dc:	6825      	ldr	r5, [r4, #0]
   341de:	f015 7500 	ands.w	r5, r5, #33554432	; 0x2000000
   341e2:	d00f      	beq.n	34204 <gnss_interface_getopt+0x140>
   341e4:	2f05      	cmp	r7, #5
   341e6:	d837      	bhi.n	34258 <gnss_interface_getopt+0x194>
   341e8:	e8df f007 	tbb	[pc, r7]
   341ec:	2b26201a 	.word	0x2b26201a
   341f0:	0331      	.short	0x0331
   341f2:	2500      	movs	r5, #0
   341f4:	7b43      	ldrb	r3, [r0, #13]
   341f6:	f888 3000 	strb.w	r3, [r8]
   341fa:	f000 fa6b 	bl	346d4 <rpc_gnss_client_data_free>
   341fe:	2300      	movs	r3, #0
   34200:	f8c9 3000 	str.w	r3, [r9]
   34204:	6823      	ldr	r3, [r4, #0]
   34206:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
   3420a:	6023      	str	r3, [r4, #0]
   3420c:	4628      	mov	r0, r5
   3420e:	b007      	add	sp, #28
   34210:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   34214:	6823      	ldr	r3, [r4, #0]
   34216:	4605      	mov	r5, r0
   34218:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
   3421c:	6023      	str	r3, [r4, #0]
   3421e:	e7f5      	b.n	3420c <gnss_interface_getopt+0x148>
   34220:	f8b0 300f 	ldrh.w	r3, [r0, #15]
   34224:	2500      	movs	r5, #0
   34226:	f8a8 3000 	strh.w	r3, [r8]
   3422a:	e7e6      	b.n	341fa <gnss_interface_getopt+0x136>
   3422c:	f8b0 3011 	ldrh.w	r3, [r0, #17]
   34230:	2500      	movs	r5, #0
   34232:	f8a8 3000 	strh.w	r3, [r8]
   34236:	e7e0      	b.n	341fa <gnss_interface_getopt+0x136>
   34238:	7b83      	ldrb	r3, [r0, #14]
   3423a:	2500      	movs	r5, #0
   3423c:	f888 3000 	strb.w	r3, [r8]
   34240:	e7db      	b.n	341fa <gnss_interface_getopt+0x136>
   34242:	f8b0 3013 	ldrh.w	r3, [r0, #19]
   34246:	2500      	movs	r5, #0
   34248:	f8a8 3000 	strh.w	r3, [r8]
   3424c:	e7d5      	b.n	341fa <gnss_interface_getopt+0x136>
   3424e:	7b03      	ldrb	r3, [r0, #12]
   34250:	2500      	movs	r5, #0
   34252:	f888 3000 	strb.w	r3, [r8]
   34256:	e7d0      	b.n	341fa <gnss_interface_getopt+0x136>
   34258:	2016      	movs	r0, #22
   3425a:	f7f6 fcb3 	bl	2abc4 <bsd_os_errno_set>
   3425e:	f04f 35ff 	mov.w	r5, #4294967295
   34262:	f8d9 0000 	ldr.w	r0, [r9]
   34266:	e7c8      	b.n	341fa <gnss_interface_getopt+0x136>
   34268:	b128      	cbz	r0, 34276 <gnss_interface_getopt+0x1b2>
   3426a:	6803      	ldr	r3, [r0, #0]
   3426c:	b11b      	cbz	r3, 34276 <gnss_interface_getopt+0x1b2>
   3426e:	4618      	mov	r0, r3
   34270:	f000 fa30 	bl	346d4 <rpc_gnss_client_data_free>
   34274:	9800      	ldr	r0, [sp, #0]
   34276:	f000 fa25 	bl	346c4 <rpc_gnss_client_message_free>
   3427a:	2023      	movs	r0, #35	; 0x23
   3427c:	f7f6 fca2 	bl	2abc4 <bsd_os_errno_set>
   34280:	6823      	ldr	r3, [r4, #0]
   34282:	200e      	movs	r0, #14
   34284:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   34288:	6023      	str	r3, [r4, #0]
   3428a:	f04f 35ff 	mov.w	r5, #4294967295
   3428e:	f7f6 fc99 	bl	2abc4 <bsd_os_errno_set>
   34292:	e746      	b.n	34122 <gnss_interface_getopt+0x5e>
   34294:	200e      	movs	r0, #14
   34296:	f7f6 fc95 	bl	2abc4 <bsd_os_errno_set>
   3429a:	f04f 35ff 	mov.w	r5, #4294967295
   3429e:	e740      	b.n	34122 <gnss_interface_getopt+0x5e>
   342a0:	202a      	movs	r0, #42	; 0x2a
   342a2:	f7f6 fc8f 	bl	2abc4 <bsd_os_errno_set>
   342a6:	f04f 35ff 	mov.w	r5, #4294967295
   342aa:	e73a      	b.n	34122 <gnss_interface_getopt+0x5e>
   342ac:	2009      	movs	r0, #9
   342ae:	f7f6 fc89 	bl	2abc4 <bsd_os_errno_set>
   342b2:	f04f 35ff 	mov.w	r5, #4294967295
   342b6:	e734      	b.n	34122 <gnss_interface_getopt+0x5e>
   342b8:	2005      	movs	r0, #5
   342ba:	f7f6 fc83 	bl	2abc4 <bsd_os_errno_set>
   342be:	f04f 35ff 	mov.w	r5, #4294967295
   342c2:	e72e      	b.n	34122 <gnss_interface_getopt+0x5e>
   342c4:	2073      	movs	r0, #115	; 0x73
   342c6:	f7f6 fc7d 	bl	2abc4 <bsd_os_errno_set>
   342ca:	f04f 35ff 	mov.w	r5, #4294967295
   342ce:	e728      	b.n	34122 <gnss_interface_getopt+0x5e>
   342d0:	20025514 	.word	0x20025514
   342d4:	49765443 	.word	0x49765443
   342d8:	200346f8 	.word	0x200346f8
   342dc:	20029914 	.word	0x20029914
   342e0:	20025518 	.word	0x20025518

000342e4 <gnss_interface_init>:
   342e4:	2100      	movs	r1, #0
   342e6:	b538      	push	{r3, r4, r5, lr}
   342e8:	4c09      	ldr	r4, [pc, #36]	; (34310 <gnss_interface_init+0x2c>)
   342ea:	4d0a      	ldr	r5, [pc, #40]	; (34314 <gnss_interface_init+0x30>)
   342ec:	6822      	ldr	r2, [r4, #0]
   342ee:	480a      	ldr	r0, [pc, #40]	; (34318 <gnss_interface_init+0x34>)
   342f0:	4b0a      	ldr	r3, [pc, #40]	; (3431c <gnss_interface_init+0x38>)
   342f2:	402a      	ands	r2, r5
   342f4:	6022      	str	r2, [r4, #0]
   342f6:	8001      	strh	r1, [r0, #0]
   342f8:	6019      	str	r1, [r3, #0]
   342fa:	f000 f9b3 	bl	34664 <rpc_gnss_client_init>
   342fe:	b928      	cbnz	r0, 3430c <gnss_interface_init+0x28>
   34300:	6823      	ldr	r3, [r4, #0]
   34302:	402b      	ands	r3, r5
   34304:	f043 0301 	orr.w	r3, r3, #1
   34308:	6023      	str	r3, [r4, #0]
   3430a:	bd38      	pop	{r3, r4, r5, pc}
   3430c:	2003      	movs	r0, #3
   3430e:	bd38      	pop	{r3, r4, r5, pc}
   34310:	20025514 	.word	0x20025514
   34314:	ffff0000 	.word	0xffff0000
   34318:	20029914 	.word	0x20029914
   3431c:	20025518 	.word	0x20025518

00034320 <gnss_interface_open>:
   34320:	2902      	cmp	r1, #2
   34322:	b510      	push	{r4, lr}
   34324:	d121      	bne.n	3436a <gnss_interface_open+0x4a>
   34326:	4c14      	ldr	r4, [pc, #80]	; (34378 <gnss_interface_open+0x58>)
   34328:	6823      	ldr	r3, [r4, #0]
   3432a:	b29b      	uxth	r3, r3
   3432c:	2b01      	cmp	r3, #1
   3432e:	d116      	bne.n	3435e <gnss_interface_open+0x3e>
   34330:	6823      	ldr	r3, [r4, #0]
   34332:	4608      	mov	r0, r1
   34334:	0c1b      	lsrs	r3, r3, #16
   34336:	041b      	lsls	r3, r3, #16
   34338:	f043 0302 	orr.w	r3, r3, #2
   3433c:	2200      	movs	r2, #0
   3433e:	490f      	ldr	r1, [pc, #60]	; (3437c <gnss_interface_open+0x5c>)
   34340:	6023      	str	r3, [r4, #0]
   34342:	f000 faad 	bl	348a0 <packet_handler_create>
   34346:	4a0e      	ldr	r2, [pc, #56]	; (34380 <gnss_interface_open+0x60>)
   34348:	6010      	str	r0, [r2, #0]
   3434a:	b140      	cbz	r0, 3435e <gnss_interface_open+0x3e>
   3434c:	6823      	ldr	r3, [r4, #0]
   3434e:	6802      	ldr	r2, [r0, #0]
   34350:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   34354:	6812      	ldr	r2, [r2, #0]
   34356:	6023      	str	r3, [r4, #0]
   34358:	4790      	blx	r2
   3435a:	480a      	ldr	r0, [pc, #40]	; (34384 <gnss_interface_open+0x64>)
   3435c:	bd10      	pop	{r4, pc}
   3435e:	200e      	movs	r0, #14
   34360:	f7f6 fc30 	bl	2abc4 <bsd_os_errno_set>
   34364:	f04f 30ff 	mov.w	r0, #4294967295
   34368:	bd10      	pop	{r4, pc}
   3436a:	2029      	movs	r0, #41	; 0x29
   3436c:	f7f6 fc2a 	bl	2abc4 <bsd_os_errno_set>
   34370:	f04f 30ff 	mov.w	r0, #4294967295
   34374:	bd10      	pop	{r4, pc}
   34376:	bf00      	nop
   34378:	20025514 	.word	0x20025514
   3437c:	00033669 	.word	0x00033669
   34380:	2002551c 	.word	0x2002551c
   34384:	49765443 	.word	0x49765443

00034388 <gnss_interface_close>:
   34388:	b530      	push	{r4, r5, lr}
   3438a:	4b13      	ldr	r3, [pc, #76]	; (343d8 <gnss_interface_close+0x50>)
   3438c:	b083      	sub	sp, #12
   3438e:	4298      	cmp	r0, r3
   34390:	d11c      	bne.n	343cc <gnss_interface_close+0x44>
   34392:	4c12      	ldr	r4, [pc, #72]	; (343dc <gnss_interface_close+0x54>)
   34394:	6823      	ldr	r3, [r4, #0]
   34396:	b29b      	uxth	r3, r3
   34398:	2b04      	cmp	r3, #4
   3439a:	d00f      	beq.n	343bc <gnss_interface_close+0x34>
   3439c:	4d10      	ldr	r5, [pc, #64]	; (343e0 <gnss_interface_close+0x58>)
   3439e:	6828      	ldr	r0, [r5, #0]
   343a0:	b118      	cbz	r0, 343aa <gnss_interface_close+0x22>
   343a2:	f000 fa9d 	bl	348e0 <packet_handler_delete>
   343a6:	2300      	movs	r3, #0
   343a8:	602b      	str	r3, [r5, #0]
   343aa:	2000      	movs	r0, #0
   343ac:	6823      	ldr	r3, [r4, #0]
   343ae:	0c1b      	lsrs	r3, r3, #16
   343b0:	041b      	lsls	r3, r3, #16
   343b2:	f043 0301 	orr.w	r3, r3, #1
   343b6:	6023      	str	r3, [r4, #0]
   343b8:	b003      	add	sp, #12
   343ba:	bd30      	pop	{r4, r5, pc}
   343bc:	2300      	movs	r3, #0
   343be:	2208      	movs	r2, #8
   343c0:	9300      	str	r3, [sp, #0]
   343c2:	f44f 7101 	mov.w	r1, #516	; 0x204
   343c6:	f7fc fe31 	bl	3102c <nrf_setsockopt>
   343ca:	e7e7      	b.n	3439c <gnss_interface_close+0x14>
   343cc:	2009      	movs	r0, #9
   343ce:	f7f6 fbf9 	bl	2abc4 <bsd_os_errno_set>
   343d2:	f04f 30ff 	mov.w	r0, #4294967295
   343d6:	e7ef      	b.n	343b8 <gnss_interface_close+0x30>
   343d8:	49765443 	.word	0x49765443
   343dc:	20025514 	.word	0x20025514
   343e0:	2002551c 	.word	0x2002551c

000343e4 <rpc_gnss_serialize_utc>:
   343e4:	4603      	mov	r3, r0
   343e6:	b1d8      	cbz	r0, 34420 <rpc_gnss_serialize_utc+0x3c>
   343e8:	b1d1      	cbz	r1, 34420 <rpc_gnss_serialize_utc+0x3c>
   343ea:	2000      	movs	r0, #0
   343ec:	2201      	movs	r2, #1
   343ee:	7048      	strb	r0, [r1, #1]
   343f0:	700a      	strb	r2, [r1, #0]
   343f2:	685a      	ldr	r2, [r3, #4]
   343f4:	2010      	movs	r0, #16
   343f6:	f8c1 2006 	str.w	r2, [r1, #6]
   343fa:	681a      	ldr	r2, [r3, #0]
   343fc:	f8c1 2002 	str.w	r2, [r1, #2]
   34400:	f993 200a 	ldrsb.w	r2, [r3, #10]
   34404:	730a      	strb	r2, [r1, #12]
   34406:	f993 200d 	ldrsb.w	r2, [r3, #13]
   3440a:	73ca      	strb	r2, [r1, #15]
   3440c:	f993 200c 	ldrsb.w	r2, [r3, #12]
   34410:	738a      	strb	r2, [r1, #14]
   34412:	7a1a      	ldrb	r2, [r3, #8]
   34414:	728a      	strb	r2, [r1, #10]
   34416:	7ada      	ldrb	r2, [r3, #11]
   34418:	734a      	strb	r2, [r1, #13]
   3441a:	7a5b      	ldrb	r3, [r3, #9]
   3441c:	72cb      	strb	r3, [r1, #11]
   3441e:	4770      	bx	lr
   34420:	f04f 30ff 	mov.w	r0, #4294967295
   34424:	4770      	bx	lr
   34426:	bf00      	nop

00034428 <rpc_gnss_serialize_ephe>:
   34428:	4603      	mov	r3, r0
   3442a:	2800      	cmp	r0, #0
   3442c:	d04b      	beq.n	344c6 <rpc_gnss_serialize_ephe+0x9e>
   3442e:	2900      	cmp	r1, #0
   34430:	d049      	beq.n	344c6 <rpc_gnss_serialize_ephe+0x9e>
   34432:	2000      	movs	r0, #0
   34434:	2202      	movs	r2, #2
   34436:	7048      	strb	r0, [r1, #1]
   34438:	700a      	strb	r2, [r1, #0]
   3443a:	68da      	ldr	r2, [r3, #12]
   3443c:	2040      	movs	r0, #64	; 0x40
   3443e:	f8c1 200b 	str.w	r2, [r1, #11]
   34442:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   34446:	f8a1 2009 	strh.w	r2, [r1, #9]
   3444a:	f993 2006 	ldrsb.w	r2, [r3, #6]
   3444e:	720a      	strb	r2, [r1, #8]
   34450:	f9b3 2044 	ldrsh.w	r2, [r3, #68]	; 0x44
   34454:	878a      	strh	r2, [r1, #60]	; 0x3c
   34456:	f9b3 203e 	ldrsh.w	r2, [r3, #62]	; 0x3e
   3445a:	86ca      	strh	r2, [r1, #54]	; 0x36
   3445c:	f9b3 2042 	ldrsh.w	r2, [r3, #66]	; 0x42
   34460:	874a      	strh	r2, [r1, #58]	; 0x3a
   34462:	f9b3 203c 	ldrsh.w	r2, [r3, #60]	; 0x3c
   34466:	868a      	strh	r2, [r1, #52]	; 0x34
   34468:	f9b3 2046 	ldrsh.w	r2, [r3, #70]	; 0x46
   3446c:	87ca      	strh	r2, [r1, #62]	; 0x3e
   3446e:	f9b3 2040 	ldrsh.w	r2, [r3, #64]	; 0x40
   34472:	870a      	strh	r2, [r1, #56]	; 0x38
   34474:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
   34478:	830a      	strh	r2, [r1, #24]
   3447a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   3447c:	f8c1 2022 	str.w	r2, [r1, #34]	; 0x22
   34480:	7c9a      	ldrb	r2, [r3, #18]
   34482:	744a      	strb	r2, [r1, #17]
   34484:	785a      	ldrb	r2, [r3, #1]
   34486:	70ca      	strb	r2, [r1, #3]
   34488:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   3448a:	62ca      	str	r2, [r1, #44]	; 0x2c
   3448c:	f9b3 202c 	ldrsh.w	r2, [r3, #44]	; 0x2c
   34490:	84ca      	strh	r2, [r1, #38]	; 0x26
   34492:	885a      	ldrh	r2, [r3, #2]
   34494:	808a      	strh	r2, [r1, #4]
   34496:	6a1a      	ldr	r2, [r3, #32]
   34498:	f8c1 201a 	str.w	r2, [r1, #26]
   3449c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   3449e:	630a      	str	r2, [r1, #48]	; 0x30
   344a0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   344a2:	f8c1 201e 	str.w	r2, [r1, #30]
   344a6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   344a8:	628a      	str	r2, [r1, #40]	; 0x28
   344aa:	781a      	ldrb	r2, [r3, #0]
   344ac:	708a      	strb	r2, [r1, #2]
   344ae:	f993 2010 	ldrsb.w	r2, [r3, #16]
   344b2:	73ca      	strb	r2, [r1, #15]
   344b4:	889a      	ldrh	r2, [r3, #4]
   344b6:	80ca      	strh	r2, [r1, #6]
   344b8:	8a9a      	ldrh	r2, [r3, #20]
   344ba:	824a      	strh	r2, [r1, #18]
   344bc:	7c5a      	ldrb	r2, [r3, #17]
   344be:	740a      	strb	r2, [r1, #16]
   344c0:	699b      	ldr	r3, [r3, #24]
   344c2:	614b      	str	r3, [r1, #20]
   344c4:	4770      	bx	lr
   344c6:	f04f 30ff 	mov.w	r0, #4294967295
   344ca:	4770      	bx	lr

000344cc <rpc_gnss_serialize_alm>:
   344cc:	4603      	mov	r3, r0
   344ce:	b360      	cbz	r0, 3452a <rpc_gnss_serialize_alm+0x5e>
   344d0:	b359      	cbz	r1, 3452a <rpc_gnss_serialize_alm+0x5e>
   344d2:	2000      	movs	r0, #0
   344d4:	2203      	movs	r2, #3
   344d6:	7048      	strb	r0, [r1, #1]
   344d8:	700a      	strb	r2, [r1, #0]
   344da:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
   344de:	2021      	movs	r0, #33	; 0x21
   344e0:	f8a1 201d 	strh.w	r2, [r1, #29]
   344e4:	f9b3 201e 	ldrsh.w	r2, [r3, #30]
   344e8:	f8a1 201f 	strh.w	r2, [r1, #31]
   344ec:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
   344f0:	810a      	strh	r2, [r1, #8]
   344f2:	889a      	ldrh	r2, [r3, #4]
   344f4:	80ca      	strh	r2, [r1, #6]
   344f6:	78da      	ldrb	r2, [r3, #3]
   344f8:	714a      	strb	r2, [r1, #5]
   344fa:	699a      	ldr	r2, [r3, #24]
   344fc:	f8c1 2019 	str.w	r2, [r1, #25]
   34500:	691a      	ldr	r2, [r3, #16]
   34502:	f8c1 2011 	str.w	r2, [r1, #17]
   34506:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   3450a:	814a      	strh	r2, [r1, #10]
   3450c:	68da      	ldr	r2, [r3, #12]
   3450e:	f8c1 200d 	str.w	r2, [r1, #13]
   34512:	7a9a      	ldrb	r2, [r3, #10]
   34514:	730a      	strb	r2, [r1, #12]
   34516:	781a      	ldrb	r2, [r3, #0]
   34518:	708a      	strb	r2, [r1, #2]
   3451a:	789a      	ldrb	r2, [r3, #2]
   3451c:	710a      	strb	r2, [r1, #4]
   3451e:	695a      	ldr	r2, [r3, #20]
   34520:	f8c1 2015 	str.w	r2, [r1, #21]
   34524:	785b      	ldrb	r3, [r3, #1]
   34526:	70cb      	strb	r3, [r1, #3]
   34528:	4770      	bx	lr
   3452a:	f04f 30ff 	mov.w	r0, #4294967295
   3452e:	4770      	bx	lr

00034530 <rpc_gnss_serialize_klob>:
   34530:	4603      	mov	r3, r0
   34532:	b1f0      	cbz	r0, 34572 <rpc_gnss_serialize_klob+0x42>
   34534:	b1e9      	cbz	r1, 34572 <rpc_gnss_serialize_klob+0x42>
   34536:	2000      	movs	r0, #0
   34538:	2204      	movs	r2, #4
   3453a:	7048      	strb	r0, [r1, #1]
   3453c:	700a      	strb	r2, [r1, #0]
   3453e:	f993 2000 	ldrsb.w	r2, [r3]
   34542:	200a      	movs	r0, #10
   34544:	708a      	strb	r2, [r1, #2]
   34546:	f993 2001 	ldrsb.w	r2, [r3, #1]
   3454a:	70ca      	strb	r2, [r1, #3]
   3454c:	f993 2002 	ldrsb.w	r2, [r3, #2]
   34550:	710a      	strb	r2, [r1, #4]
   34552:	f993 2003 	ldrsb.w	r2, [r3, #3]
   34556:	714a      	strb	r2, [r1, #5]
   34558:	f993 2004 	ldrsb.w	r2, [r3, #4]
   3455c:	718a      	strb	r2, [r1, #6]
   3455e:	f993 2005 	ldrsb.w	r2, [r3, #5]
   34562:	71ca      	strb	r2, [r1, #7]
   34564:	f993 2006 	ldrsb.w	r2, [r3, #6]
   34568:	720a      	strb	r2, [r1, #8]
   3456a:	f993 3007 	ldrsb.w	r3, [r3, #7]
   3456e:	724b      	strb	r3, [r1, #9]
   34570:	4770      	bx	lr
   34572:	f04f 30ff 	mov.w	r0, #4294967295
   34576:	4770      	bx	lr

00034578 <rpc_gnss_serialize_nequick>:
   34578:	4603      	mov	r3, r0
   3457a:	b198      	cbz	r0, 345a4 <rpc_gnss_serialize_nequick+0x2c>
   3457c:	b191      	cbz	r1, 345a4 <rpc_gnss_serialize_nequick+0x2c>
   3457e:	2000      	movs	r0, #0
   34580:	2205      	movs	r2, #5
   34582:	7048      	strb	r0, [r1, #1]
   34584:	700a      	strb	r2, [r1, #0]
   34586:	f9b3 2000 	ldrsh.w	r2, [r3]
   3458a:	200a      	movs	r0, #10
   3458c:	804a      	strh	r2, [r1, #2]
   3458e:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
   34592:	808a      	strh	r2, [r1, #4]
   34594:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
   34598:	80ca      	strh	r2, [r1, #6]
   3459a:	799a      	ldrb	r2, [r3, #6]
   3459c:	720a      	strb	r2, [r1, #8]
   3459e:	79db      	ldrb	r3, [r3, #7]
   345a0:	724b      	strb	r3, [r1, #9]
   345a2:	4770      	bx	lr
   345a4:	f04f 30ff 	mov.w	r0, #4294967295
   345a8:	4770      	bx	lr
   345aa:	bf00      	nop

000345ac <rpc_gnss_serialize_time_and_sv_tow>:
   345ac:	b310      	cbz	r0, 345f4 <rpc_gnss_serialize_time_and_sv_tow+0x48>
   345ae:	b309      	cbz	r1, 345f4 <rpc_gnss_serialize_time_and_sv_tow+0x48>
   345b0:	b470      	push	{r4, r5, r6}
   345b2:	2500      	movs	r5, #0
   345b4:	2606      	movs	r6, #6
   345b6:	460c      	mov	r4, r1
   345b8:	704d      	strb	r5, [r1, #1]
   345ba:	700e      	strb	r6, [r1, #0]
   345bc:	462b      	mov	r3, r5
   345be:	8805      	ldrh	r5, [r0, #0]
   345c0:	4602      	mov	r2, r0
   345c2:	804d      	strh	r5, [r1, #2]
   345c4:	68c5      	ldr	r5, [r0, #12]
   345c6:	f8c1 500a 	str.w	r5, [r1, #10]
   345ca:	8905      	ldrh	r5, [r0, #8]
   345cc:	810d      	strh	r5, [r1, #8]
   345ce:	6840      	ldr	r0, [r0, #4]
   345d0:	6048      	str	r0, [r1, #4]
   345d2:	8a15      	ldrh	r5, [r2, #16]
   345d4:	eb03 0043 	add.w	r0, r3, r3, lsl #1
   345d8:	4408      	add	r0, r1
   345da:	81c5      	strh	r5, [r0, #14]
   345dc:	7c90      	ldrb	r0, [r2, #18]
   345de:	3301      	adds	r3, #1
   345e0:	2b20      	cmp	r3, #32
   345e2:	7420      	strb	r0, [r4, #16]
   345e4:	f102 0204 	add.w	r2, r2, #4
   345e8:	f104 0403 	add.w	r4, r4, #3
   345ec:	d1f1      	bne.n	345d2 <rpc_gnss_serialize_time_and_sv_tow+0x26>
   345ee:	206e      	movs	r0, #110	; 0x6e
   345f0:	bc70      	pop	{r4, r5, r6}
   345f2:	4770      	bx	lr
   345f4:	f04f 30ff 	mov.w	r0, #4294967295
   345f8:	4770      	bx	lr
   345fa:	bf00      	nop

000345fc <rpc_gnss_serialize_location>:
   345fc:	4603      	mov	r3, r0
   345fe:	b1c8      	cbz	r0, 34634 <rpc_gnss_serialize_location+0x38>
   34600:	b1c1      	cbz	r1, 34634 <rpc_gnss_serialize_location+0x38>
   34602:	2000      	movs	r0, #0
   34604:	2207      	movs	r2, #7
   34606:	7048      	strb	r0, [r1, #1]
   34608:	700a      	strb	r2, [r1, #0]
   3460a:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   3460e:	2011      	movs	r0, #17
   34610:	814a      	strh	r2, [r1, #10]
   34612:	7b9a      	ldrb	r2, [r3, #14]
   34614:	740a      	strb	r2, [r1, #16]
   34616:	681a      	ldr	r2, [r3, #0]
   34618:	f8c1 2002 	str.w	r2, [r1, #2]
   3461c:	685a      	ldr	r2, [r3, #4]
   3461e:	f8c1 2006 	str.w	r2, [r1, #6]
   34622:	7b1a      	ldrb	r2, [r3, #12]
   34624:	738a      	strb	r2, [r1, #14]
   34626:	7b5a      	ldrb	r2, [r3, #13]
   34628:	73ca      	strb	r2, [r1, #15]
   3462a:	7a9a      	ldrb	r2, [r3, #10]
   3462c:	730a      	strb	r2, [r1, #12]
   3462e:	7adb      	ldrb	r3, [r3, #11]
   34630:	734b      	strb	r3, [r1, #13]
   34632:	4770      	bx	lr
   34634:	f04f 30ff 	mov.w	r0, #4294967295
   34638:	4770      	bx	lr
   3463a:	bf00      	nop

0003463c <rpc_gnss_serialize_integrity>:
   3463c:	b148      	cbz	r0, 34652 <rpc_gnss_serialize_integrity+0x16>
   3463e:	b141      	cbz	r1, 34652 <rpc_gnss_serialize_integrity+0x16>
   34640:	2200      	movs	r2, #0
   34642:	2308      	movs	r3, #8
   34644:	704a      	strb	r2, [r1, #1]
   34646:	700b      	strb	r3, [r1, #0]
   34648:	6803      	ldr	r3, [r0, #0]
   3464a:	2006      	movs	r0, #6
   3464c:	f8c1 3002 	str.w	r3, [r1, #2]
   34650:	4770      	bx	lr
   34652:	f04f 30ff 	mov.w	r0, #4294967295
   34656:	4770      	bx	lr

00034658 <gnss_client_event_handler>:
   34658:	f850 1b08 	ldr.w	r1, [r0], #8
   3465c:	0c09      	lsrs	r1, r1, #16
   3465e:	f7ff b811 	b.w	33684 <rpc_gnss_event_handler>
   34662:	bf00      	nop

00034664 <rpc_gnss_client_init>:
   34664:	4801      	ldr	r0, [pc, #4]	; (3466c <rpc_gnss_client_init+0x8>)
   34666:	f7fe bb73 	b.w	32d50 <rpc_client_register>
   3466a:	bf00      	nop
   3466c:	000402f8 	.word	0x000402f8

00034670 <rpc_gnss_client_request_alloc>:
   34670:	2300      	movs	r3, #0
   34672:	b510      	push	{r4, lr}
   34674:	b082      	sub	sp, #8
   34676:	9301      	str	r3, [sp, #4]
   34678:	b158      	cbz	r0, 34692 <rpc_gnss_client_request_alloc+0x22>
   3467a:	4604      	mov	r4, r0
   3467c:	aa01      	add	r2, sp, #4
   3467e:	2007      	movs	r0, #7
   34680:	f7fe fd9e 	bl	331c0 <rpc_message_alloc>
   34684:	b918      	cbnz	r0, 3468e <rpc_gnss_client_request_alloc+0x1e>
   34686:	9b01      	ldr	r3, [sp, #4]
   34688:	b10b      	cbz	r3, 3468e <rpc_gnss_client_request_alloc+0x1e>
   3468a:	3308      	adds	r3, #8
   3468c:	6023      	str	r3, [r4, #0]
   3468e:	b002      	add	sp, #8
   34690:	bd10      	pop	{r4, pc}
   34692:	2007      	movs	r0, #7
   34694:	b002      	add	sp, #8
   34696:	bd10      	pop	{r4, pc}

00034698 <rpc_gnss_client_request_send>:
   34698:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   3469c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   346a0:	d10b      	bne.n	346ba <rpc_gnss_client_request_send+0x22>
   346a2:	b160      	cbz	r0, 346be <rpc_gnss_client_request_send+0x26>
   346a4:	4603      	mov	r3, r0
   346a6:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   346aa:	2007      	movs	r0, #7
   346ac:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   346b0:	f843 1d08 	str.w	r1, [r3, #-8]!
   346b4:	4619      	mov	r1, r3
   346b6:	f7fe bd6b 	b.w	33190 <rpc_message_send>
   346ba:	200f      	movs	r0, #15
   346bc:	4770      	bx	lr
   346be:	2007      	movs	r0, #7
   346c0:	4770      	bx	lr
   346c2:	bf00      	nop

000346c4 <rpc_gnss_client_message_free>:
   346c4:	b120      	cbz	r0, 346d0 <rpc_gnss_client_message_free+0xc>
   346c6:	f1a0 0108 	sub.w	r1, r0, #8
   346ca:	2007      	movs	r0, #7
   346cc:	f7fe bdaa 	b.w	33224 <rpc_message_free>
   346d0:	2007      	movs	r0, #7
   346d2:	4770      	bx	lr

000346d4 <rpc_gnss_client_data_free>:
   346d4:	b118      	cbz	r0, 346de <rpc_gnss_client_data_free+0xa>
   346d6:	4601      	mov	r1, r0
   346d8:	2007      	movs	r0, #7
   346da:	f7fe beb5 	b.w	33448 <rpc_message_data_free>
   346de:	2007      	movs	r0, #7
   346e0:	4770      	bx	lr
   346e2:	bf00      	nop

000346e4 <datagram_handler_init>:
   346e4:	b510      	push	{r4, lr}
   346e6:	4604      	mov	r4, r0
   346e8:	200c      	movs	r0, #12
   346ea:	f7f9 f8d7 	bl	2d89c <nrf_malloc>
   346ee:	60e0      	str	r0, [r4, #12]
   346f0:	b118      	cbz	r0, 346fa <datagram_handler_init+0x16>
   346f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   346f6:	f7fc bb8f 	b.w	30e18 <linked_list_init>
   346fa:	2004      	movs	r0, #4
   346fc:	bd10      	pop	{r4, pc}
   346fe:	bf00      	nop

00034700 <datagram_handler_put>:
   34700:	b570      	push	{r4, r5, r6, lr}
   34702:	4606      	mov	r6, r0
   34704:	2014      	movs	r0, #20
   34706:	460d      	mov	r5, r1
   34708:	f7f9 f8c8 	bl	2d89c <nrf_malloc>
   3470c:	b178      	cbz	r0, 3472e <datagram_handler_put+0x2e>
   3470e:	682b      	ldr	r3, [r5, #0]
   34710:	4604      	mov	r4, r0
   34712:	6043      	str	r3, [r0, #4]
   34714:	686b      	ldr	r3, [r5, #4]
   34716:	4601      	mov	r1, r0
   34718:	6083      	str	r3, [r0, #8]
   3471a:	68eb      	ldr	r3, [r5, #12]
   3471c:	60c3      	str	r3, [r0, #12]
   3471e:	68ab      	ldr	r3, [r5, #8]
   34720:	6103      	str	r3, [r0, #16]
   34722:	68f0      	ldr	r0, [r6, #12]
   34724:	f7fc fb82 	bl	30e2c <linked_list_push>
   34728:	b920      	cbnz	r0, 34734 <datagram_handler_put+0x34>
   3472a:	6868      	ldr	r0, [r5, #4]
   3472c:	bd70      	pop	{r4, r5, r6, pc}
   3472e:	f04f 30ff 	mov.w	r0, #4294967295
   34732:	bd70      	pop	{r4, r5, r6, pc}
   34734:	4620      	mov	r0, r4
   34736:	f7f9 f8bb 	bl	2d8b0 <nrf_free>
   3473a:	f04f 30ff 	mov.w	r0, #4294967295
   3473e:	bd70      	pop	{r4, r5, r6, pc}

00034740 <datagram_handler_get>:
   34740:	b5f0      	push	{r4, r5, r6, r7, lr}
   34742:	4606      	mov	r6, r0
   34744:	b085      	sub	sp, #20
   34746:	68c0      	ldr	r0, [r0, #12]
   34748:	460c      	mov	r4, r1
   3474a:	4617      	mov	r7, r2
   3474c:	f7fc fb8e 	bl	30e6c <linked_list_peek>
   34750:	2800      	cmp	r0, #0
   34752:	d037      	beq.n	347c4 <datagram_handler_get+0x84>
   34754:	6882      	ldr	r2, [r0, #8]
   34756:	4605      	mov	r5, r0
   34758:	e9d4 0300 	ldrd	r0, r3, [r4]
   3475c:	429a      	cmp	r2, r3
   3475e:	bf28      	it	cs
   34760:	461a      	movcs	r2, r3
   34762:	6062      	str	r2, [r4, #4]
   34764:	b110      	cbz	r0, 3476c <datagram_handler_get+0x2c>
   34766:	6869      	ldr	r1, [r5, #4]
   34768:	f00a f870 	bl	3e84c <memcpy>
   3476c:	68a0      	ldr	r0, [r4, #8]
   3476e:	b118      	cbz	r0, 34778 <datagram_handler_get+0x38>
   34770:	692b      	ldr	r3, [r5, #16]
   34772:	b10b      	cbz	r3, 34778 <datagram_handler_get+0x38>
   34774:	68ea      	ldr	r2, [r5, #12]
   34776:	b9e2      	cbnz	r2, 347b2 <datagram_handler_get+0x72>
   34778:	2300      	movs	r3, #0
   3477a:	60e3      	str	r3, [r4, #12]
   3477c:	073b      	lsls	r3, r7, #28
   3477e:	d502      	bpl.n	34786 <datagram_handler_get+0x46>
   34780:	6860      	ldr	r0, [r4, #4]
   34782:	b005      	add	sp, #20
   34784:	bdf0      	pop	{r4, r5, r6, r7, pc}
   34786:	68f0      	ldr	r0, [r6, #12]
   34788:	f7fc fb66 	bl	30e58 <linked_list_pop>
   3478c:	4605      	mov	r5, r0
   3478e:	2800      	cmp	r0, #0
   34790:	d0f6      	beq.n	34780 <datagram_handler_get+0x40>
   34792:	e9d0 3101 	ldrd	r3, r1, [r0, #4]
   34796:	6902      	ldr	r2, [r0, #16]
   34798:	9300      	str	r3, [sp, #0]
   3479a:	68c3      	ldr	r3, [r0, #12]
   3479c:	e9cd 1201 	strd	r1, r2, [sp, #4]
   347a0:	9303      	str	r3, [sp, #12]
   347a2:	4668      	mov	r0, sp
   347a4:	e9d6 3101 	ldrd	r3, r1, [r6, #4]
   347a8:	4798      	blx	r3
   347aa:	4628      	mov	r0, r5
   347ac:	f7f9 f880 	bl	2d8b0 <nrf_free>
   347b0:	e7e6      	b.n	34780 <datagram_handler_get+0x40>
   347b2:	68e3      	ldr	r3, [r4, #12]
   347b4:	429a      	cmp	r2, r3
   347b6:	bf28      	it	cs
   347b8:	461a      	movcs	r2, r3
   347ba:	60e2      	str	r2, [r4, #12]
   347bc:	6929      	ldr	r1, [r5, #16]
   347be:	f00a f845 	bl	3e84c <memcpy>
   347c2:	e7db      	b.n	3477c <datagram_handler_get+0x3c>
   347c4:	f04f 30ff 	mov.w	r0, #4294967295
   347c8:	e7db      	b.n	34782 <datagram_handler_get+0x42>
   347ca:	bf00      	nop

000347cc <datagram_handler_available>:
   347cc:	b508      	push	{r3, lr}
   347ce:	68c0      	ldr	r0, [r0, #12]
   347d0:	f7fc fb4c 	bl	30e6c <linked_list_peek>
   347d4:	b108      	cbz	r0, 347da <datagram_handler_available+0xe>
   347d6:	6880      	ldr	r0, [r0, #8]
   347d8:	bd08      	pop	{r3, pc}
   347da:	f04f 30ff 	mov.w	r0, #4294967295
   347de:	bd08      	pop	{r3, pc}

000347e0 <datagram_handler_flush>:
   347e0:	b530      	push	{r4, r5, lr}
   347e2:	4605      	mov	r5, r0
   347e4:	68c0      	ldr	r0, [r0, #12]
   347e6:	b085      	sub	sp, #20
   347e8:	b9a8      	cbnz	r0, 34816 <datagram_handler_flush+0x36>
   347ea:	e01a      	b.n	34822 <datagram_handler_flush+0x42>
   347ec:	68e8      	ldr	r0, [r5, #12]
   347ee:	f7fc fb33 	bl	30e58 <linked_list_pop>
   347f2:	4604      	mov	r4, r0
   347f4:	b170      	cbz	r0, 34814 <datagram_handler_flush+0x34>
   347f6:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   347fa:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   347fe:	e9cd 0100 	strd	r0, r1, [sp]
   34802:	e9cd 2302 	strd	r2, r3, [sp, #8]
   34806:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   3480a:	4668      	mov	r0, sp
   3480c:	4798      	blx	r3
   3480e:	4620      	mov	r0, r4
   34810:	f7f9 f84e 	bl	2d8b0 <nrf_free>
   34814:	68e8      	ldr	r0, [r5, #12]
   34816:	f7fc fb2f 	bl	30e78 <linked_list_size_get>
   3481a:	2800      	cmp	r0, #0
   3481c:	d1e6      	bne.n	347ec <datagram_handler_flush+0xc>
   3481e:	b005      	add	sp, #20
   34820:	bd30      	pop	{r4, r5, pc}
   34822:	2008      	movs	r0, #8
   34824:	b005      	add	sp, #20
   34826:	bd30      	pop	{r4, r5, pc}

00034828 <datagram_handler_free>:
   34828:	b530      	push	{r4, r5, lr}
   3482a:	4605      	mov	r5, r0
   3482c:	68c0      	ldr	r0, [r0, #12]
   3482e:	b085      	sub	sp, #20
   34830:	b9a0      	cbnz	r0, 3485c <datagram_handler_free+0x34>
   34832:	e01c      	b.n	3486e <datagram_handler_free+0x46>
   34834:	f7fc fb10 	bl	30e58 <linked_list_pop>
   34838:	4604      	mov	r4, r0
   3483a:	b170      	cbz	r0, 3485a <datagram_handler_free+0x32>
   3483c:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   34840:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   34844:	e9cd 0100 	strd	r0, r1, [sp]
   34848:	e9cd 2302 	strd	r2, r3, [sp, #8]
   3484c:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   34850:	4668      	mov	r0, sp
   34852:	4798      	blx	r3
   34854:	4620      	mov	r0, r4
   34856:	f7f9 f82b 	bl	2d8b0 <nrf_free>
   3485a:	68e8      	ldr	r0, [r5, #12]
   3485c:	f7fc fb0c 	bl	30e78 <linked_list_size_get>
   34860:	4604      	mov	r4, r0
   34862:	68e8      	ldr	r0, [r5, #12]
   34864:	2c00      	cmp	r4, #0
   34866:	d1e5      	bne.n	34834 <datagram_handler_free+0xc>
   34868:	f7f9 f822 	bl	2d8b0 <nrf_free>
   3486c:	60ec      	str	r4, [r5, #12]
   3486e:	b005      	add	sp, #20
   34870:	bd30      	pop	{r4, r5, pc}
   34872:	bf00      	nop

00034874 <null_handler_init>:
   34874:	2000      	movs	r0, #0
   34876:	4770      	bx	lr

00034878 <null_handler_put>:
   34878:	b510      	push	{r4, lr}
   3487a:	460c      	mov	r4, r1
   3487c:	e9d0 3101 	ldrd	r3, r1, [r0, #4]
   34880:	4620      	mov	r0, r4
   34882:	4798      	blx	r3
   34884:	6860      	ldr	r0, [r4, #4]
   34886:	bd10      	pop	{r4, pc}

00034888 <null_handler_get>:
   34888:	f04f 30ff 	mov.w	r0, #4294967295
   3488c:	4770      	bx	lr
   3488e:	bf00      	nop

00034890 <null_handler_available>:
   34890:	f04f 30ff 	mov.w	r0, #4294967295
   34894:	4770      	bx	lr
   34896:	bf00      	nop

00034898 <null_handler_flush>:
   34898:	2000      	movs	r0, #0
   3489a:	4770      	bx	lr

0003489c <null_handler_free>:
   3489c:	4770      	bx	lr
   3489e:	bf00      	nop

000348a0 <packet_handler_create>:
   348a0:	2801      	cmp	r0, #1
   348a2:	b538      	push	{r3, r4, r5, lr}
   348a4:	460d      	mov	r5, r1
   348a6:	4614      	mov	r4, r2
   348a8:	d00d      	beq.n	348c6 <packet_handler_create+0x26>
   348aa:	db11      	blt.n	348d0 <packet_handler_create+0x30>
   348ac:	2803      	cmp	r0, #3
   348ae:	dc0f      	bgt.n	348d0 <packet_handler_create+0x30>
   348b0:	2010      	movs	r0, #16
   348b2:	f7f8 fff3 	bl	2d89c <nrf_malloc>
   348b6:	2218      	movs	r2, #24
   348b8:	b120      	cbz	r0, 348c4 <packet_handler_create+0x24>
   348ba:	4b08      	ldr	r3, [pc, #32]	; (348dc <packet_handler_create+0x3c>)
   348bc:	6045      	str	r5, [r0, #4]
   348be:	4413      	add	r3, r2
   348c0:	6084      	str	r4, [r0, #8]
   348c2:	6003      	str	r3, [r0, #0]
   348c4:	bd38      	pop	{r3, r4, r5, pc}
   348c6:	2014      	movs	r0, #20
   348c8:	f7f8 ffe8 	bl	2d89c <nrf_malloc>
   348cc:	2230      	movs	r2, #48	; 0x30
   348ce:	e7f3      	b.n	348b8 <packet_handler_create+0x18>
   348d0:	200c      	movs	r0, #12
   348d2:	f7f8 ffe3 	bl	2d89c <nrf_malloc>
   348d6:	2200      	movs	r2, #0
   348d8:	e7ee      	b.n	348b8 <packet_handler_create+0x18>
   348da:	bf00      	nop
   348dc:	00040308 	.word	0x00040308

000348e0 <packet_handler_delete>:
   348e0:	b510      	push	{r4, lr}
   348e2:	4604      	mov	r4, r0
   348e4:	6803      	ldr	r3, [r0, #0]
   348e6:	691b      	ldr	r3, [r3, #16]
   348e8:	4798      	blx	r3
   348ea:	6823      	ldr	r3, [r4, #0]
   348ec:	4620      	mov	r0, r4
   348ee:	695b      	ldr	r3, [r3, #20]
   348f0:	4798      	blx	r3
   348f2:	4620      	mov	r0, r4
   348f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   348f8:	f7f8 bfda 	b.w	2d8b0 <nrf_free>

000348fc <stream_handler_init>:
   348fc:	b510      	push	{r4, lr}
   348fe:	4604      	mov	r4, r0
   34900:	200c      	movs	r0, #12
   34902:	f7f8 ffcb 	bl	2d89c <nrf_malloc>
   34906:	60e0      	str	r0, [r4, #12]
   34908:	b128      	cbz	r0, 34916 <stream_handler_init+0x1a>
   3490a:	2300      	movs	r3, #0
   3490c:	6123      	str	r3, [r4, #16]
   3490e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   34912:	f7fc ba81 	b.w	30e18 <linked_list_init>
   34916:	2004      	movs	r0, #4
   34918:	bd10      	pop	{r4, pc}
   3491a:	bf00      	nop

0003491c <stream_handler_put>:
   3491c:	b570      	push	{r4, r5, r6, lr}
   3491e:	4606      	mov	r6, r0
   34920:	2014      	movs	r0, #20
   34922:	460d      	mov	r5, r1
   34924:	f7f8 ffba 	bl	2d89c <nrf_malloc>
   34928:	b178      	cbz	r0, 3494a <stream_handler_put+0x2e>
   3492a:	682b      	ldr	r3, [r5, #0]
   3492c:	4604      	mov	r4, r0
   3492e:	6043      	str	r3, [r0, #4]
   34930:	686b      	ldr	r3, [r5, #4]
   34932:	4601      	mov	r1, r0
   34934:	6083      	str	r3, [r0, #8]
   34936:	68eb      	ldr	r3, [r5, #12]
   34938:	60c3      	str	r3, [r0, #12]
   3493a:	68ab      	ldr	r3, [r5, #8]
   3493c:	6103      	str	r3, [r0, #16]
   3493e:	68f0      	ldr	r0, [r6, #12]
   34940:	f7fc fa74 	bl	30e2c <linked_list_push>
   34944:	b920      	cbnz	r0, 34950 <stream_handler_put+0x34>
   34946:	6868      	ldr	r0, [r5, #4]
   34948:	bd70      	pop	{r4, r5, r6, pc}
   3494a:	f04f 30ff 	mov.w	r0, #4294967295
   3494e:	bd70      	pop	{r4, r5, r6, pc}
   34950:	4620      	mov	r0, r4
   34952:	f7f8 ffad 	bl	2d8b0 <nrf_free>
   34956:	f04f 30ff 	mov.w	r0, #4294967295
   3495a:	bd70      	pop	{r4, r5, r6, pc}

0003495c <stream_handler_get>:
   3495c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   34960:	4682      	mov	sl, r0
   34962:	b087      	sub	sp, #28
   34964:	68c0      	ldr	r0, [r0, #12]
   34966:	4689      	mov	r9, r1
   34968:	4693      	mov	fp, r2
   3496a:	f7fc fa7f 	bl	30e6c <linked_list_peek>
   3496e:	2800      	cmp	r0, #0
   34970:	d072      	beq.n	34a58 <stream_handler_get+0xfc>
   34972:	4605      	mov	r5, r0
   34974:	f8d9 0008 	ldr.w	r0, [r9, #8]
   34978:	b120      	cbz	r0, 34984 <stream_handler_get+0x28>
   3497a:	692b      	ldr	r3, [r5, #16]
   3497c:	b113      	cbz	r3, 34984 <stream_handler_get+0x28>
   3497e:	68ea      	ldr	r2, [r5, #12]
   34980:	2a00      	cmp	r2, #0
   34982:	d15c      	bne.n	34a3e <stream_handler_get+0xe2>
   34984:	2300      	movs	r3, #0
   34986:	f8c9 300c 	str.w	r3, [r9, #12]
   3498a:	f8d9 2000 	ldr.w	r2, [r9]
   3498e:	f8d9 8004 	ldr.w	r8, [r9, #4]
   34992:	f8da 1010 	ldr.w	r1, [sl, #16]
   34996:	9201      	str	r2, [sp, #4]
   34998:	f1b8 0f00 	cmp.w	r8, #0
   3499c:	d05a      	beq.n	34a54 <stream_handler_get+0xf8>
   3499e:	f00b 0308 	and.w	r3, fp, #8
   349a2:	2400      	movs	r4, #0
   349a4:	9300      	str	r3, [sp, #0]
   349a6:	e010      	b.n	349ca <stream_handler_get+0x6e>
   349a8:	f8da 3010 	ldr.w	r3, [sl, #16]
   349ac:	443b      	add	r3, r7
   349ae:	f8ca 3010 	str.w	r3, [sl, #16]
   349b2:	4628      	mov	r0, r5
   349b4:	f7fc fa62 	bl	30e7c <linked_list_get_next>
   349b8:	443c      	add	r4, r7
   349ba:	4605      	mov	r5, r0
   349bc:	2800      	cmp	r0, #0
   349be:	d038      	beq.n	34a32 <stream_handler_get+0xd6>
   349c0:	45a0      	cmp	r8, r4
   349c2:	d936      	bls.n	34a32 <stream_handler_get+0xd6>
   349c4:	2100      	movs	r1, #0
   349c6:	f8d9 2000 	ldr.w	r2, [r9]
   349ca:	68ae      	ldr	r6, [r5, #8]
   349cc:	eba8 0b04 	sub.w	fp, r8, r4
   349d0:	1a76      	subs	r6, r6, r1
   349d2:	455e      	cmp	r6, fp
   349d4:	4637      	mov	r7, r6
   349d6:	bf28      	it	cs
   349d8:	465f      	movcs	r7, fp
   349da:	b132      	cbz	r2, 349ea <stream_handler_get+0x8e>
   349dc:	6868      	ldr	r0, [r5, #4]
   349de:	9b01      	ldr	r3, [sp, #4]
   349e0:	4401      	add	r1, r0
   349e2:	463a      	mov	r2, r7
   349e4:	1918      	adds	r0, r3, r4
   349e6:	f009 ff31 	bl	3e84c <memcpy>
   349ea:	9b00      	ldr	r3, [sp, #0]
   349ec:	2b00      	cmp	r3, #0
   349ee:	d1e0      	bne.n	349b2 <stream_handler_get+0x56>
   349f0:	455e      	cmp	r6, fp
   349f2:	d8d9      	bhi.n	349a8 <stream_handler_get+0x4c>
   349f4:	f8da 000c 	ldr.w	r0, [sl, #12]
   349f8:	f7fc fa2e 	bl	30e58 <linked_list_pop>
   349fc:	4606      	mov	r6, r0
   349fe:	b170      	cbz	r0, 34a1e <stream_handler_get+0xc2>
   34a00:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
   34a04:	e9d0 0103 	ldrd	r0, r1, [r0, #12]
   34a08:	e9cd 2302 	strd	r2, r3, [sp, #8]
   34a0c:	e9cd 1004 	strd	r1, r0, [sp, #16]
   34a10:	e9da 3101 	ldrd	r3, r1, [sl, #4]
   34a14:	a802      	add	r0, sp, #8
   34a16:	4798      	blx	r3
   34a18:	4630      	mov	r0, r6
   34a1a:	f7f8 ff49 	bl	2d8b0 <nrf_free>
   34a1e:	2300      	movs	r3, #0
   34a20:	4628      	mov	r0, r5
   34a22:	f8ca 3010 	str.w	r3, [sl, #16]
   34a26:	f7fc fa29 	bl	30e7c <linked_list_get_next>
   34a2a:	443c      	add	r4, r7
   34a2c:	4605      	mov	r5, r0
   34a2e:	2800      	cmp	r0, #0
   34a30:	d1c6      	bne.n	349c0 <stream_handler_get+0x64>
   34a32:	4620      	mov	r0, r4
   34a34:	f8c9 4004 	str.w	r4, [r9, #4]
   34a38:	b007      	add	sp, #28
   34a3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   34a3e:	f8d9 300c 	ldr.w	r3, [r9, #12]
   34a42:	429a      	cmp	r2, r3
   34a44:	bf28      	it	cs
   34a46:	461a      	movcs	r2, r3
   34a48:	f8c9 200c 	str.w	r2, [r9, #12]
   34a4c:	6929      	ldr	r1, [r5, #16]
   34a4e:	f009 fefd 	bl	3e84c <memcpy>
   34a52:	e79a      	b.n	3498a <stream_handler_get+0x2e>
   34a54:	4644      	mov	r4, r8
   34a56:	e7ec      	b.n	34a32 <stream_handler_get+0xd6>
   34a58:	f04f 30ff 	mov.w	r0, #4294967295
   34a5c:	e7ec      	b.n	34a38 <stream_handler_get+0xdc>
   34a5e:	bf00      	nop

00034a60 <stream_handler_available>:
   34a60:	b510      	push	{r4, lr}
   34a62:	4604      	mov	r4, r0
   34a64:	68c0      	ldr	r0, [r0, #12]
   34a66:	f7fc fa01 	bl	30e6c <linked_list_peek>
   34a6a:	b150      	cbz	r0, 34a82 <stream_handler_available+0x22>
   34a6c:	6924      	ldr	r4, [r4, #16]
   34a6e:	4264      	negs	r4, r4
   34a70:	6883      	ldr	r3, [r0, #8]
   34a72:	441c      	add	r4, r3
   34a74:	f7fc fa02 	bl	30e7c <linked_list_get_next>
   34a78:	2800      	cmp	r0, #0
   34a7a:	d1f9      	bne.n	34a70 <stream_handler_available+0x10>
   34a7c:	ea24 70e4 	bic.w	r0, r4, r4, asr #31
   34a80:	bd10      	pop	{r4, pc}
   34a82:	f04f 30ff 	mov.w	r0, #4294967295
   34a86:	bd10      	pop	{r4, pc}

00034a88 <stream_handler_flush>:
   34a88:	b530      	push	{r4, r5, lr}
   34a8a:	4605      	mov	r5, r0
   34a8c:	68c0      	ldr	r0, [r0, #12]
   34a8e:	b085      	sub	sp, #20
   34a90:	b9a8      	cbnz	r0, 34abe <stream_handler_flush+0x36>
   34a92:	e01a      	b.n	34aca <stream_handler_flush+0x42>
   34a94:	68e8      	ldr	r0, [r5, #12]
   34a96:	f7fc f9df 	bl	30e58 <linked_list_pop>
   34a9a:	4604      	mov	r4, r0
   34a9c:	b170      	cbz	r0, 34abc <stream_handler_flush+0x34>
   34a9e:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   34aa2:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   34aa6:	e9cd 0100 	strd	r0, r1, [sp]
   34aaa:	e9cd 2302 	strd	r2, r3, [sp, #8]
   34aae:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   34ab2:	4668      	mov	r0, sp
   34ab4:	4798      	blx	r3
   34ab6:	4620      	mov	r0, r4
   34ab8:	f7f8 fefa 	bl	2d8b0 <nrf_free>
   34abc:	68e8      	ldr	r0, [r5, #12]
   34abe:	f7fc f9db 	bl	30e78 <linked_list_size_get>
   34ac2:	2800      	cmp	r0, #0
   34ac4:	d1e6      	bne.n	34a94 <stream_handler_flush+0xc>
   34ac6:	b005      	add	sp, #20
   34ac8:	bd30      	pop	{r4, r5, pc}
   34aca:	2008      	movs	r0, #8
   34acc:	b005      	add	sp, #20
   34ace:	bd30      	pop	{r4, r5, pc}

00034ad0 <stream_handler_free>:
   34ad0:	b530      	push	{r4, r5, lr}
   34ad2:	4605      	mov	r5, r0
   34ad4:	68c0      	ldr	r0, [r0, #12]
   34ad6:	b085      	sub	sp, #20
   34ad8:	b9a0      	cbnz	r0, 34b04 <stream_handler_free+0x34>
   34ada:	e01c      	b.n	34b16 <stream_handler_free+0x46>
   34adc:	f7fc f9bc 	bl	30e58 <linked_list_pop>
   34ae0:	4604      	mov	r4, r0
   34ae2:	b170      	cbz	r0, 34b02 <stream_handler_free+0x32>
   34ae4:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   34ae8:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   34aec:	e9cd 0100 	strd	r0, r1, [sp]
   34af0:	e9cd 2302 	strd	r2, r3, [sp, #8]
   34af4:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   34af8:	4668      	mov	r0, sp
   34afa:	4798      	blx	r3
   34afc:	4620      	mov	r0, r4
   34afe:	f7f8 fed7 	bl	2d8b0 <nrf_free>
   34b02:	68e8      	ldr	r0, [r5, #12]
   34b04:	f7fc f9b8 	bl	30e78 <linked_list_size_get>
   34b08:	4604      	mov	r4, r0
   34b0a:	68e8      	ldr	r0, [r5, #12]
   34b0c:	2c00      	cmp	r4, #0
   34b0e:	d1e5      	bne.n	34adc <stream_handler_free+0xc>
   34b10:	f7f8 fece 	bl	2d8b0 <nrf_free>
   34b14:	60ec      	str	r4, [r5, #12]
   34b16:	b005      	add	sp, #20
   34b18:	bd30      	pop	{r4, r5, pc}
   34b1a:	bf00      	nop

00034b1c <SystemInit>:
    
    /* Enable the FPU if the compiler used floating point unit instructions. __FPU_USED is a MACRO defined by the
    * compiler. Since the FPU consumes energy, remember to disable FPU use in the compiler if floating point unit
    * operations are not used in your code. */
    #if (__FPU_USED == 1)
      SCB->CPACR |= (3UL << 20) | (3UL << 22);
   34b1c:	4a07      	ldr	r2, [pc, #28]	; (34b3c <SystemInit+0x20>)
   34b1e:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
   34b22:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
   34b26:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
   34b2a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   34b2e:	f3bf 8f6f 	isb	sy
    SystemCoreClock = __SYSTEM_CLOCK;
   34b32:	4b03      	ldr	r3, [pc, #12]	; (34b40 <SystemInit+0x24>)
   34b34:	4a03      	ldr	r2, [pc, #12]	; (34b44 <SystemInit+0x28>)
   34b36:	601a      	str	r2, [r3, #0]
      __DSB();
      __ISB();
    #endif
    
    SystemCoreClockUpdate();
}
   34b38:	4770      	bx	lr
   34b3a:	bf00      	nop
   34b3c:	e000ed00 	.word	0xe000ed00
   34b40:	200346fc 	.word	0x200346fc
   34b44:	03d09000 	.word	0x03d09000

00034b48 <nvmc_word_write>:
}

#if defined(NVMC_READYNEXT_READYNEXT_Msk)
NRF_STATIC_INLINE bool nrf_nvmc_write_ready_check(NRF_NVMC_Type const * p_reg)
{
    return (bool)(p_reg->READYNEXT & NVMC_READYNEXT_READYNEXT_Msk);
   34b48:	4a04      	ldr	r2, [pc, #16]	; (34b5c <nvmc_word_write+0x14>)
   34b4a:	f8d2 3408 	ldr.w	r3, [r2, #1032]	; 0x408
}

static void nvmc_word_write(uint32_t addr, uint32_t value)
{
#if defined(NRF9160_XXAA)
    while (!nrf_nvmc_write_ready_check(NRF_NVMC))
   34b4e:	07db      	lsls	r3, r3, #31
   34b50:	d5fb      	bpl.n	34b4a <nvmc_word_write+0x2>
#else
    while (!nrf_nvmc_ready_check(NRF_NVMC))
    {}
#endif

    *(volatile uint32_t *)addr = value;
   34b52:	6001      	str	r1, [r0, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   34b54:	f3bf 8f5f 	dmb	sy
    __DMB();
}
   34b58:	4770      	bx	lr
   34b5a:	bf00      	nop
   34b5c:	40039000 	.word	0x40039000

00034b60 <nrfx_nvmc_page_erase>:
    }
}

nrfx_err_t nrfx_nvmc_page_erase(uint32_t addr)
{
    NRFX_ASSERT((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get());
   34b60:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
{
   34b64:	b508      	push	{r3, lr}
    NRFX_ASSERT((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get());
   34b66:	d305      	bcc.n	34b74 <nrfx_nvmc_page_erase+0x14>
   34b68:	4b0d      	ldr	r3, [pc, #52]	; (34ba0 <nrfx_nvmc_page_erase+0x40>)
   34b6a:	4a0e      	ldr	r2, [pc, #56]	; (34ba4 <nrfx_nvmc_page_erase+0x44>)
   34b6c:	21dd      	movs	r1, #221	; 0xdd
   34b6e:	480e      	ldr	r0, [pc, #56]	; (34ba8 <nrfx_nvmc_page_erase+0x48>)
   34b70:	f004 fb0e 	bl	39190 <__assert_func>
    return !(addr % flash_page_size_get());
   34b74:	f3c0 030b 	ubfx	r3, r0, #0, #12

    if (!is_page_aligned_check(addr))
   34b78:	b97b      	cbnz	r3, 34b9a <nrfx_nvmc_page_erase+0x3a>

#if defined(NVMC_CONFIGNS_WEN_Msk)
NRF_STATIC_INLINE void nrf_nvmc_nonsecure_mode_set(NRF_NVMC_Type *    p_reg,
                                                   nrf_nvmc_ns_mode_t mode)
{
    p_reg->CONFIGNS = (uint32_t)mode;
   34b7a:	2202      	movs	r2, #2
   34b7c:	4b0b      	ldr	r3, [pc, #44]	; (34bac <nrfx_nvmc_page_erase+0x4c>)
   34b7e:	f8c3 2584 	str.w	r2, [r3, #1412]	; 0x584
        p_reg->ERASEPCR1 = page_addr;
    }
#elif defined(NRF52_SERIES)
    p_reg->ERASEPAGE = page_addr;
#elif defined(NRF9160_XXAA) || defined(NRF5340_XXAA_APPLICATION) || defined(NRF5340_XXAA_NETWORK)
    *(volatile uint32_t *)page_addr = 0xFFFFFFFF;
   34b82:	f04f 32ff 	mov.w	r2, #4294967295
   34b86:	6002      	str	r2, [r0, #0]
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   34b88:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
        return NRFX_ERROR_INVALID_ADDR;
    }

    nvmc_erase_mode_set();
    nrf_nvmc_page_erase_start(NRF_NVMC, addr);
    while (!nrf_nvmc_ready_check(NRF_NVMC))
   34b8c:	07d2      	lsls	r2, r2, #31
   34b8e:	d5fb      	bpl.n	34b88 <nrfx_nvmc_page_erase+0x28>
    p_reg->CONFIGNS = (uint32_t)mode;
   34b90:	2200      	movs	r2, #0
    {}
    nvmc_readonly_mode_set();

    return NRFX_SUCCESS;
   34b92:	4807      	ldr	r0, [pc, #28]	; (34bb0 <nrfx_nvmc_page_erase+0x50>)
   34b94:	f8c3 2584 	str.w	r2, [r3, #1412]	; 0x584
}
   34b98:	bd08      	pop	{r3, pc}
        return NRFX_ERROR_INVALID_ADDR;
   34b9a:	4806      	ldr	r0, [pc, #24]	; (34bb4 <nrfx_nvmc_page_erase+0x54>)
   34b9c:	e7fc      	b.n	34b98 <nrfx_nvmc_page_erase+0x38>
   34b9e:	bf00      	nop
   34ba0:	000435ae 	.word	0x000435ae
   34ba4:	00043584 	.word	0x00043584
   34ba8:	0004361b 	.word	0x0004361b
   34bac:	40039000 	.word	0x40039000
   34bb0:	0bad0000 	.word	0x0bad0000
   34bb4:	0bad000a 	.word	0x0bad000a

00034bb8 <nrfx_nvmc_word_write>:
    nrfx_nvmc_word_write(aligned_addr, partial_word_create(addr, &value, 1));
}

void nrfx_nvmc_word_write(uint32_t addr, uint32_t value)
{
    NRFX_ASSERT((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get());
   34bb8:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
{
   34bbc:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get());
   34bbe:	d306      	bcc.n	34bce <nrfx_nvmc_word_write+0x16>
   34bc0:	f240 114d 	movw	r1, #333	; 0x14d
   34bc4:	4b0a      	ldr	r3, [pc, #40]	; (34bf0 <nrfx_nvmc_word_write+0x38>)
   34bc6:	4a0b      	ldr	r2, [pc, #44]	; (34bf4 <nrfx_nvmc_word_write+0x3c>)
    NRFX_ASSERT(nrfx_is_word_aligned((void const *)addr));
   34bc8:	480b      	ldr	r0, [pc, #44]	; (34bf8 <nrfx_nvmc_word_write+0x40>)
   34bca:	f004 fae1 	bl	39190 <__assert_func>
   34bce:	f010 0403 	ands.w	r4, r0, #3
   34bd2:	d004      	beq.n	34bde <nrfx_nvmc_word_write+0x26>
   34bd4:	4b09      	ldr	r3, [pc, #36]	; (34bfc <nrfx_nvmc_word_write+0x44>)
   34bd6:	4a07      	ldr	r2, [pc, #28]	; (34bf4 <nrfx_nvmc_word_write+0x3c>)
   34bd8:	f44f 71a7 	mov.w	r1, #334	; 0x14e
   34bdc:	e7f4      	b.n	34bc8 <nrfx_nvmc_word_write+0x10>
   34bde:	2301      	movs	r3, #1
   34be0:	4d07      	ldr	r5, [pc, #28]	; (34c00 <nrfx_nvmc_word_write+0x48>)
   34be2:	f8c5 3584 	str.w	r3, [r5, #1412]	; 0x584

    nvmc_write_mode_set();

    nvmc_word_write(addr, value);
   34be6:	f7ff ffaf 	bl	34b48 <nvmc_word_write>
   34bea:	f8c5 4584 	str.w	r4, [r5, #1412]	; 0x584

    nvmc_readonly_mode_set();
}
   34bee:	bd38      	pop	{r3, r4, r5, pc}
   34bf0:	000435ae 	.word	0x000435ae
   34bf4:	00043599 	.word	0x00043599
   34bf8:	0004361b 	.word	0x0004361b
   34bfc:	000435d2 	.word	0x000435d2
   34c00:	40039000 	.word	0x40039000

00034c04 <nrf_gpio_pin_port_decode.isra.0.part.1>:
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   34c04:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   34c06:	4a03      	ldr	r2, [pc, #12]	; (34c14 <nrf_gpio_pin_port_decode.isra.0.part.1+0x10>)
   34c08:	4b03      	ldr	r3, [pc, #12]	; (34c18 <nrf_gpio_pin_port_decode.isra.0.part.1+0x14>)
   34c0a:	f240 11ff 	movw	r1, #511	; 0x1ff
   34c0e:	4803      	ldr	r0, [pc, #12]	; (34c1c <nrf_gpio_pin_port_decode.isra.0.part.1+0x18>)
   34c10:	f004 fabe 	bl	39190 <__assert_func>
   34c14:	00043657 	.word	0x00043657
   34c18:	00042a69 	.word	0x00042a69
   34c1c:	00042a77 	.word	0x00042a77

00034c20 <nrf_gpio_pin_clear>:
   34c20:	281f      	cmp	r0, #31
{
   34c22:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   34c24:	d901      	bls.n	34c2a <nrf_gpio_pin_clear+0xa>
   34c26:	f7ff ffed 	bl	34c04 <nrf_gpio_pin_port_decode.isra.0.part.1>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   34c2a:	2301      	movs	r3, #1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
   34c2c:	4a01      	ldr	r2, [pc, #4]	; (34c34 <nrf_gpio_pin_clear+0x14>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   34c2e:	4083      	lsls	r3, r0
    p_reg->OUTCLR = clr_mask;
   34c30:	60d3      	str	r3, [r2, #12]
}
   34c32:	bd08      	pop	{r3, pc}
   34c34:	40842500 	.word	0x40842500

00034c38 <nrf_gpio_pin_set>:
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   34c38:	281f      	cmp	r0, #31
{
   34c3a:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   34c3c:	d901      	bls.n	34c42 <nrf_gpio_pin_set+0xa>
   34c3e:	f7ff ffe1 	bl	34c04 <nrf_gpio_pin_port_decode.isra.0.part.1>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   34c42:	2301      	movs	r3, #1
    p_reg->OUTSET = set_mask;
   34c44:	4a01      	ldr	r2, [pc, #4]	; (34c4c <nrf_gpio_pin_set+0x14>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   34c46:	4083      	lsls	r3, r0
    p_reg->OUTSET = set_mask;
   34c48:	6093      	str	r3, [r2, #8]
}
   34c4a:	bd08      	pop	{r3, pc}
   34c4c:	40842500 	.word	0x40842500

00034c50 <irq_handler.part.2>:
{
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
    return nrf_spim_event_address_get(p_spim, NRF_SPIM_EVENT_END);
}

static void irq_handler(NRF_SPIM_Type * p_spim, spim_control_block_t * p_cb)
   34c50:	b508      	push	{r3, lr}
        {
            anomaly_198_disable();
        }
#endif
        nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_END);
        NRFX_ASSERT(p_cb->handler);
   34c52:	4a03      	ldr	r2, [pc, #12]	; (34c60 <irq_handler.part.2+0x10>)
   34c54:	4b03      	ldr	r3, [pc, #12]	; (34c64 <irq_handler.part.2+0x14>)
   34c56:	f240 21e7 	movw	r1, #743	; 0x2e7
   34c5a:	4803      	ldr	r0, [pc, #12]	; (34c68 <irq_handler.part.2+0x18>)
   34c5c:	f004 fa98 	bl	39190 <__assert_func>
   34c60:	0004368e 	.word	0x0004368e
   34c64:	0004369a 	.word	0x0004369a
   34c68:	000436a8 	.word	0x000436a8

00034c6c <nrfx_spim_init>:
{
   34c6c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   34c70:	4681      	mov	r9, r0
    NRFX_ASSERT(p_config);
   34c72:	460c      	mov	r4, r1
   34c74:	b929      	cbnz	r1, 34c82 <nrfx_spim_init+0x16>
   34c76:	4b52      	ldr	r3, [pc, #328]	; (34dc0 <nrfx_spim_init+0x154>)
   34c78:	4a52      	ldr	r2, [pc, #328]	; (34dc4 <nrfx_spim_init+0x158>)
   34c7a:	21f4      	movs	r1, #244	; 0xf4
   34c7c:	4852      	ldr	r0, [pc, #328]	; (34dc8 <nrfx_spim_init+0x15c>)
   34c7e:	f004 fa87 	bl	39190 <__assert_func>
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   34c82:	2124      	movs	r1, #36	; 0x24
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   34c84:	7905      	ldrb	r5, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   34c86:	4e51      	ldr	r6, [pc, #324]	; (34dcc <nrfx_spim_init+0x160>)
   34c88:	4369      	muls	r1, r5
   34c8a:	1870      	adds	r0, r6, r1
   34c8c:	7f07      	ldrb	r7, [r0, #28]
   34c8e:	2f00      	cmp	r7, #0
   34c90:	f040 8094 	bne.w	34dbc <nrfx_spim_init+0x150>
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
   34c94:	f8d9 7000 	ldr.w	r7, [r9]
    p_cb->p_context = p_context;
   34c98:	6043      	str	r3, [r0, #4]
    if (p_config->mode <= NRF_SPIM_MODE_1)
   34c9a:	7b23      	ldrb	r3, [r4, #12]
    p_cb->handler = handler;
   34c9c:	5072      	str	r2, [r6, r1]
    if (p_config->mode <= NRF_SPIM_MODE_1)
   34c9e:	2b01      	cmp	r3, #1
   34ca0:	7820      	ldrb	r0, [r4, #0]
   34ca2:	d806      	bhi.n	34cb2 <nrfx_spim_init+0x46>
        nrf_gpio_pin_clear(p_config->sck_pin);
   34ca4:	f7ff ffbc 	bl	34c20 <nrf_gpio_pin_clear>
    nrf_gpio_cfg(p_config->sck_pin,
   34ca8:	7823      	ldrb	r3, [r4, #0]
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   34caa:	2b1f      	cmp	r3, #31
   34cac:	d904      	bls.n	34cb8 <nrfx_spim_init+0x4c>
   34cae:	f7ff ffa9 	bl	34c04 <nrf_gpio_pin_port_decode.isra.0.part.1>
        nrf_gpio_pin_set(p_config->sck_pin);
   34cb2:	f7ff ffc1 	bl	34c38 <nrf_gpio_pin_set>
   34cb6:	e7f7      	b.n	34ca8 <nrfx_spim_init+0x3c>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   34cb8:	2101      	movs	r1, #1
   34cba:	4a45      	ldr	r2, [pc, #276]	; (34dd0 <nrfx_spim_init+0x164>)
   34cbc:	3380      	adds	r3, #128	; 0x80
   34cbe:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    if (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
   34cc2:	f894 8001 	ldrb.w	r8, [r4, #1]
   34cc6:	4692      	mov	sl, r2
   34cc8:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
   34ccc:	d067      	beq.n	34d9e <nrfx_spim_init+0x132>
        nrf_gpio_pin_clear(mosi_pin);
   34cce:	4640      	mov	r0, r8
   34cd0:	f7ff ffa6 	bl	34c20 <nrf_gpio_pin_clear>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   34cd4:	f1b8 0f1f 	cmp.w	r8, #31
   34cd8:	d8e9      	bhi.n	34cae <nrfx_spim_init+0x42>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   34cda:	2203      	movs	r2, #3
   34cdc:	f108 0380 	add.w	r3, r8, #128	; 0x80
   34ce0:	f84a 2023 	str.w	r2, [sl, r3, lsl #2]
    if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
   34ce4:	78a3      	ldrb	r3, [r4, #2]
   34ce6:	2bff      	cmp	r3, #255	; 0xff
   34ce8:	d05c      	beq.n	34da4 <nrfx_spim_init+0x138>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   34cea:	2b1f      	cmp	r3, #31
        miso_pin = p_config->miso_pin;
   34cec:	469b      	mov	fp, r3
        nrf_gpio_cfg_input(miso_pin, p_config->miso_pull);
   34cee:	7ba2      	ldrb	r2, [r4, #14]
   34cf0:	d8dd      	bhi.n	34cae <nrfx_spim_init+0x42>
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
   34cf2:	0092      	lsls	r2, r2, #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   34cf4:	f103 0180 	add.w	r1, r3, #128	; 0x80
   34cf8:	f84a 2021 	str.w	r2, [sl, r1, lsl #2]
    p_cb->miso_pin = p_config->miso_pin;
   34cfc:	2224      	movs	r2, #36	; 0x24
   34cfe:	fb02 6205 	mla	r2, r2, r5, r6
   34d02:	f882 3020 	strb.w	r3, [r2, #32]
    p_cb->ss_pin = p_config->ss_pin;
   34d06:	78e0      	ldrb	r0, [r4, #3]
    if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   34d08:	28ff      	cmp	r0, #255	; 0xff
    p_cb->ss_pin = p_config->ss_pin;
   34d0a:	77d0      	strb	r0, [r2, #31]
    if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   34d0c:	d010      	beq.n	34d30 <nrfx_spim_init+0xc4>
        if (p_config->ss_active_high)
   34d0e:	7923      	ldrb	r3, [r4, #4]
   34d10:	2b00      	cmp	r3, #0
   34d12:	d04a      	beq.n	34daa <nrfx_spim_init+0x13e>
            nrf_gpio_pin_clear(p_config->ss_pin);
   34d14:	f7ff ff84 	bl	34c20 <nrf_gpio_pin_clear>
        nrf_gpio_cfg_output(p_config->ss_pin);
   34d18:	78e3      	ldrb	r3, [r4, #3]
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   34d1a:	2b1f      	cmp	r3, #31
   34d1c:	d8c7      	bhi.n	34cae <nrfx_spim_init+0x42>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   34d1e:	2203      	movs	r2, #3
   34d20:	3380      	adds	r3, #128	; 0x80
   34d22:	f84a 2023 	str.w	r2, [sl, r3, lsl #2]
        p_cb->ss_active_high = p_config->ss_active_high;
   34d26:	2324      	movs	r3, #36	; 0x24
   34d28:	fb03 6305 	mla	r3, r3, r5, r6
   34d2c:	7922      	ldrb	r2, [r4, #4]
   34d2e:	779a      	strb	r2, [r3, #30]
    nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
   34d30:	7823      	ldrb	r3, [r4, #0]
    nrf_spim_configure(p_spim, p_config->mode, p_config->bit_order);
   34d32:	7b22      	ldrb	r2, [r4, #12]
    p_reg->PSEL.SCK  = sck_pin;
   34d34:	f8c7 3508 	str.w	r3, [r7, #1288]	; 0x508
    p_reg->FREQUENCY = (uint32_t)frequency;
   34d38:	68a3      	ldr	r3, [r4, #8]
    p_reg->PSEL.MOSI = mosi_pin;
   34d3a:	f8c7 850c 	str.w	r8, [r7, #1292]	; 0x50c
    p_reg->PSEL.MISO = miso_pin;
   34d3e:	f8c7 b510 	str.w	fp, [r7, #1296]	; 0x510
    p_reg->FREQUENCY = (uint32_t)frequency;
   34d42:	f8c7 3524 	str.w	r3, [r7, #1316]	; 0x524
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
   34d46:	7b63      	ldrb	r3, [r4, #13]
   34d48:	3300      	adds	r3, #0
   34d4a:	bf18      	it	ne
   34d4c:	2301      	movne	r3, #1
    switch (spi_mode)
   34d4e:	2a02      	cmp	r2, #2
   34d50:	d02e      	beq.n	34db0 <nrfx_spim_init+0x144>
   34d52:	2a03      	cmp	r2, #3
   34d54:	d02f      	beq.n	34db6 <nrfx_spim_init+0x14a>
   34d56:	2a01      	cmp	r2, #1
   34d58:	d101      	bne.n	34d5e <nrfx_spim_init+0xf2>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
   34d5a:	f043 0302 	orr.w	r3, r3, #2
    p_reg->CONFIG = config;
   34d5e:	f8c7 3554 	str.w	r3, [r7, #1364]	; 0x554
}

NRF_STATIC_INLINE void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
                                        uint8_t         orc)
{
    p_reg->ORC = orc;
   34d62:	79a3      	ldrb	r3, [r4, #6]
   34d64:	f8c7 35c0 	str.w	r3, [r7, #1472]	; 0x5c0
    if (p_cb->handler)
   34d68:	2324      	movs	r3, #36	; 0x24
   34d6a:	436b      	muls	r3, r5
   34d6c:	58f3      	ldr	r3, [r6, r3]
   34d6e:	b113      	cbz	r3, 34d76 <nrfx_spim_init+0x10a>
    p_reg->INTENSET = mask;
   34d70:	2240      	movs	r2, #64	; 0x40
   34d72:	f8c7 2304 	str.w	r2, [r7, #772]	; 0x304
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Enabled << SPIM_ENABLE_ENABLE_Pos);
   34d76:	2207      	movs	r2, #7
   34d78:	f8c7 2500 	str.w	r2, [r7, #1280]	; 0x500
    if (p_cb->handler)
   34d7c:	b12b      	cbz	r3, 34d8a <nrfx_spim_init+0x11e>
    return ((((uint32_t)p_object) & 0x3u) == 0u);
}

NRF_STATIC_INLINE IRQn_Type nrfx_get_irq_number(void const * p_reg)
{
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
   34d7e:	f8d9 0000 	ldr.w	r0, [r9]
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
   34d82:	f340 3007 	sbfx	r0, r0, #12, #8
   34d86:	f7f3 f9d5 	bl	28134 <arch_irq_enable>
    p_cb->transfer_in_progress = false;
   34d8a:	2324      	movs	r3, #36	; 0x24
   34d8c:	fb03 6505 	mla	r5, r3, r5, r6
   34d90:	2300      	movs	r3, #0
   34d92:	776b      	strb	r3, [r5, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   34d94:	2301      	movs	r3, #1
    return err_code;
   34d96:	480f      	ldr	r0, [pc, #60]	; (34dd4 <nrfx_spim_init+0x168>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   34d98:	772b      	strb	r3, [r5, #28]
}
   34d9a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        mosi_pin = NRF_SPIM_PIN_NOT_CONNECTED;
   34d9e:	f04f 38ff 	mov.w	r8, #4294967295
   34da2:	e79f      	b.n	34ce4 <nrfx_spim_init+0x78>
        miso_pin = NRF_SPIM_PIN_NOT_CONNECTED;
   34da4:	f04f 3bff 	mov.w	fp, #4294967295
   34da8:	e7a8      	b.n	34cfc <nrfx_spim_init+0x90>
            nrf_gpio_pin_set(p_config->ss_pin);
   34daa:	f7ff ff45 	bl	34c38 <nrf_gpio_pin_set>
   34dae:	e7b3      	b.n	34d18 <nrfx_spim_init+0xac>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   34db0:	f043 0304 	orr.w	r3, r3, #4
        break;
   34db4:	e7d3      	b.n	34d5e <nrfx_spim_init+0xf2>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   34db6:	f043 0306 	orr.w	r3, r3, #6
        break;
   34dba:	e7d0      	b.n	34d5e <nrfx_spim_init+0xf2>
        return err_code;
   34dbc:	4806      	ldr	r0, [pc, #24]	; (34dd8 <nrfx_spim_init+0x16c>)
   34dbe:	e7ec      	b.n	34d9a <nrfx_spim_init+0x12e>
   34dc0:	000436e4 	.word	0x000436e4
   34dc4:	00043670 	.word	0x00043670
   34dc8:	000436a8 	.word	0x000436a8
   34dcc:	20025520 	.word	0x20025520
   34dd0:	40842500 	.word	0x40842500
   34dd4:	0bad0000 	.word	0x0bad0000
   34dd8:	0bad0005 	.word	0x0bad0005

00034ddc <nrfx_spim_xfer>:
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   34ddc:	2324      	movs	r3, #36	; 0x24
{
   34dde:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   34de2:	4d58      	ldr	r5, [pc, #352]	; (34f44 <nrfx_spim_xfer+0x168>)
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   34de4:	7906      	ldrb	r6, [r0, #4]
{
   34de6:	4680      	mov	r8, r0
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   34de8:	fb03 5306 	mla	r3, r3, r6, r5
   34dec:	7f1b      	ldrb	r3, [r3, #28]
{
   34dee:	460c      	mov	r4, r1
   34df0:	4617      	mov	r7, r2
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   34df2:	b933      	cbnz	r3, 34e02 <nrfx_spim_xfer+0x26>
   34df4:	f240 217d 	movw	r1, #637	; 0x27d
   34df8:	4b53      	ldr	r3, [pc, #332]	; (34f48 <nrfx_spim_xfer+0x16c>)
   34dfa:	4a54      	ldr	r2, [pc, #336]	; (34f4c <nrfx_spim_xfer+0x170>)
    NRFX_ASSERT(p_xfer_desc->p_tx_buffer != NULL || p_xfer_desc->tx_length == 0);
   34dfc:	4854      	ldr	r0, [pc, #336]	; (34f50 <nrfx_spim_xfer+0x174>)
   34dfe:	f004 f9c7 	bl	39190 <__assert_func>
   34e02:	680b      	ldr	r3, [r1, #0]
   34e04:	b933      	cbnz	r3, 34e14 <nrfx_spim_xfer+0x38>
   34e06:	684b      	ldr	r3, [r1, #4]
   34e08:	b123      	cbz	r3, 34e14 <nrfx_spim_xfer+0x38>
   34e0a:	4b52      	ldr	r3, [pc, #328]	; (34f54 <nrfx_spim_xfer+0x178>)
   34e0c:	4a4f      	ldr	r2, [pc, #316]	; (34f4c <nrfx_spim_xfer+0x170>)
   34e0e:	f240 217e 	movw	r1, #638	; 0x27e
   34e12:	e7f3      	b.n	34dfc <nrfx_spim_xfer+0x20>
    NRFX_ASSERT(p_xfer_desc->p_rx_buffer != NULL || p_xfer_desc->rx_length == 0);
   34e14:	68a3      	ldr	r3, [r4, #8]
   34e16:	b943      	cbnz	r3, 34e2a <nrfx_spim_xfer+0x4e>
   34e18:	68e3      	ldr	r3, [r4, #12]
   34e1a:	2b00      	cmp	r3, #0
   34e1c:	f000 808e 	beq.w	34f3c <nrfx_spim_xfer+0x160>
   34e20:	4b4d      	ldr	r3, [pc, #308]	; (34f58 <nrfx_spim_xfer+0x17c>)
   34e22:	4a4a      	ldr	r2, [pc, #296]	; (34f4c <nrfx_spim_xfer+0x170>)
   34e24:	f240 217f 	movw	r1, #639	; 0x27f
   34e28:	e7e8      	b.n	34dfc <nrfx_spim_xfer+0x20>
    NRFX_ASSERT(SPIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   34e2a:	2e01      	cmp	r6, #1
   34e2c:	d807      	bhi.n	34e3e <nrfx_spim_xfer+0x62>
   34e2e:	68e3      	ldr	r3, [r4, #12]
   34e30:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   34e34:	d203      	bcs.n	34e3e <nrfx_spim_xfer+0x62>
   34e36:	6863      	ldr	r3, [r4, #4]
   34e38:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   34e3c:	d304      	bcc.n	34e48 <nrfx_spim_xfer+0x6c>
   34e3e:	4b47      	ldr	r3, [pc, #284]	; (34f5c <nrfx_spim_xfer+0x180>)
   34e40:	4a42      	ldr	r2, [pc, #264]	; (34f4c <nrfx_spim_xfer+0x170>)
   34e42:	f240 2182 	movw	r1, #642	; 0x282
   34e46:	e7d9      	b.n	34dfc <nrfx_spim_xfer+0x20>
    if (p_cb->transfer_in_progress)
   34e48:	2324      	movs	r3, #36	; 0x24
   34e4a:	4373      	muls	r3, r6
   34e4c:	18ea      	adds	r2, r5, r3
   34e4e:	7f51      	ldrb	r1, [r2, #29]
   34e50:	2900      	cmp	r1, #0
   34e52:	d171      	bne.n	34f38 <nrfx_spim_xfer+0x15c>
        if (p_cb->handler && !(flags & (NRFX_SPIM_FLAG_REPEATED_XFER |
   34e54:	58eb      	ldr	r3, [r5, r3]
   34e56:	b123      	cbz	r3, 34e62 <nrfx_spim_xfer+0x86>
   34e58:	f017 0f14 	tst.w	r7, #20
            p_cb->transfer_in_progress = true;
   34e5c:	bf04      	itt	eq
   34e5e:	2301      	moveq	r3, #1
   34e60:	7753      	strbeq	r3, [r2, #29]
    p_cb->evt.xfer_desc = *p_xfer_desc;
   34e62:	f04f 0c24 	mov.w	ip, #36	; 0x24
   34e66:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   34e6a:	fb0c 5c06 	mla	ip, ip, r6, r5
   34e6e:	f10c 0e0c 	add.w	lr, ip, #12
   34e72:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   34e76:	f89c 001f 	ldrb.w	r0, [ip, #31]
   34e7a:	28ff      	cmp	r0, #255	; 0xff
   34e7c:	d004      	beq.n	34e88 <nrfx_spim_xfer+0xac>
            if (p_cb->ss_active_high)
   34e7e:	f89c 301e 	ldrb.w	r3, [ip, #30]
   34e82:	b1bb      	cbz	r3, 34eb4 <nrfx_spim_xfer+0xd8>
                nrf_gpio_pin_set(p_cb->ss_pin);
   34e84:	f7ff fed8 	bl	34c38 <nrf_gpio_pin_set>
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   34e88:	6821      	ldr	r1, [r4, #0]
   34e8a:	b121      	cbz	r1, 34e96 <nrfx_spim_xfer+0xba>
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   34e8c:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
   34e90:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   34e94:	d106      	bne.n	34ea4 <nrfx_spim_xfer+0xc8>
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   34e96:	68a2      	ldr	r2, [r4, #8]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   34e98:	b17a      	cbz	r2, 34eba <nrfx_spim_xfer+0xde>
   34e9a:	f002 4360 	and.w	r3, r2, #3758096384	; 0xe0000000
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   34e9e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   34ea2:	d00a      	beq.n	34eba <nrfx_spim_xfer+0xde>
        p_cb->transfer_in_progress = false;
   34ea4:	2324      	movs	r3, #36	; 0x24
   34ea6:	fb03 5506 	mla	r5, r3, r6, r5
   34eaa:	2300      	movs	r3, #0
        return err_code;
   34eac:	482c      	ldr	r0, [pc, #176]	; (34f60 <nrfx_spim_xfer+0x184>)
        p_cb->transfer_in_progress = false;
   34eae:	776b      	strb	r3, [r5, #29]
}
   34eb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                nrf_gpio_pin_clear(p_cb->ss_pin);
   34eb4:	f7ff feb4 	bl	34c20 <nrf_gpio_pin_clear>
   34eb8:	e7e6      	b.n	34e88 <nrfx_spim_xfer+0xac>
    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
   34eba:	f8d8 3000 	ldr.w	r3, [r8]
    nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
   34ebe:	6860      	ldr	r0, [r4, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   34ec0:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   34ec4:	f8c3 0548 	str.w	r0, [r3, #1352]	; 0x548
    nrf_spim_rx_buffer_set(p_spim, p_xfer_desc->p_rx_buffer, p_xfer_desc->rx_length);
   34ec8:	68e1      	ldr	r1, [r4, #12]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   34eca:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   34ece:	2200      	movs	r2, #0
    p_reg->RXD.MAXCNT = length;
   34ed0:	f8c3 1538 	str.w	r1, [r3, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   34ed4:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    if (NRFX_SPIM_FLAG_TX_POSTINC & flags)
   34ed8:	f017 0201 	ands.w	r2, r7, #1
}


NRF_STATIC_INLINE void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_ArrayList << SPIM_TXD_LIST_LIST_Pos;
   34edc:	bf18      	it	ne
   34ede:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_tx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_Disabled << SPIM_TXD_LIST_LIST_Pos;
   34ee0:	f8c3 2550 	str.w	r2, [r3, #1360]	; 0x550
    if (NRFX_SPIM_FLAG_RX_POSTINC & flags)
   34ee4:	f017 0202 	ands.w	r2, r7, #2
}

NRF_STATIC_INLINE void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_ArrayList << SPIM_RXD_LIST_LIST_Pos;
   34ee8:	bf18      	it	ne
   34eea:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_Disabled << SPIM_RXD_LIST_LIST_Pos;
   34eec:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
   34ef0:	073a      	lsls	r2, r7, #28
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   34ef2:	bf5c      	itt	pl
   34ef4:	2201      	movpl	r2, #1
   34ef6:	611a      	strpl	r2, [r3, #16]
    if (!p_cb->handler)
   34ef8:	2224      	movs	r2, #36	; 0x24
   34efa:	4372      	muls	r2, r6
   34efc:	58aa      	ldr	r2, [r5, r2]
   34efe:	b992      	cbnz	r2, 34f26 <nrfx_spim_xfer+0x14a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   34f00:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
        while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END)){}
   34f04:	2a00      	cmp	r2, #0
   34f06:	d0fb      	beq.n	34f00 <nrfx_spim_xfer+0x124>
        if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   34f08:	2324      	movs	r3, #36	; 0x24
   34f0a:	fb03 5506 	mla	r5, r3, r6, r5
   34f0e:	7fe8      	ldrb	r0, [r5, #31]
   34f10:	28ff      	cmp	r0, #255	; 0xff
   34f12:	d003      	beq.n	34f1c <nrfx_spim_xfer+0x140>
                if (p_cb->ss_active_high)
   34f14:	7fab      	ldrb	r3, [r5, #30]
   34f16:	b11b      	cbz	r3, 34f20 <nrfx_spim_xfer+0x144>
                    nrf_gpio_pin_clear(p_cb->ss_pin);
   34f18:	f7ff fe82 	bl	34c20 <nrf_gpio_pin_clear>
    return err_code;
   34f1c:	4811      	ldr	r0, [pc, #68]	; (34f64 <nrfx_spim_xfer+0x188>)
   34f1e:	e7c7      	b.n	34eb0 <nrfx_spim_xfer+0xd4>
                    nrf_gpio_pin_set(p_cb->ss_pin);
   34f20:	f7ff fe8a 	bl	34c38 <nrf_gpio_pin_set>
   34f24:	e7fa      	b.n	34f1c <nrfx_spim_xfer+0x140>
    if (!enable)
   34f26:	2240      	movs	r2, #64	; 0x40
   34f28:	f017 0f04 	tst.w	r7, #4
    p_reg->INTENCLR = mask;
   34f2c:	bf14      	ite	ne
   34f2e:	f8c3 2308 	strne.w	r2, [r3, #776]	; 0x308
    p_reg->INTENSET = mask;
   34f32:	f8c3 2304 	streq.w	r2, [r3, #772]	; 0x304
   34f36:	e7f1      	b.n	34f1c <nrfx_spim_xfer+0x140>
        return err_code;
   34f38:	480b      	ldr	r0, [pc, #44]	; (34f68 <nrfx_spim_xfer+0x18c>)
   34f3a:	e7b9      	b.n	34eb0 <nrfx_spim_xfer+0xd4>
    NRFX_ASSERT(SPIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   34f3c:	2e01      	cmp	r6, #1
   34f3e:	f67f af7a 	bls.w	34e36 <nrfx_spim_xfer+0x5a>
   34f42:	e77c      	b.n	34e3e <nrfx_spim_xfer+0x62>
   34f44:	20025520 	.word	0x20025520
   34f48:	000436ed 	.word	0x000436ed
   34f4c:	0004367f 	.word	0x0004367f
   34f50:	000436a8 	.word	0x000436a8
   34f54:	00043719 	.word	0x00043719
   34f58:	00043760 	.word	0x00043760
   34f5c:	000437a7 	.word	0x000437a7
   34f60:	0bad000a 	.word	0x0bad000a
   34f64:	0bad0000 	.word	0x0bad0000
   34f68:	0bad000b 	.word	0x0bad000b

00034f6c <nrfx_spim_2_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_SPIM2_ENABLED)
void nrfx_spim_2_irq_handler(void)
{
   34f6c:	b508      	push	{r3, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   34f6e:	4b08      	ldr	r3, [pc, #32]	; (34f90 <nrfx_spim_2_irq_handler+0x24>)
   34f70:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   34f74:	b15a      	cbz	r2, 34f8e <nrfx_spim_2_irq_handler+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   34f76:	2200      	movs	r2, #0
        NRFX_ASSERT(p_cb->handler);
   34f78:	4806      	ldr	r0, [pc, #24]	; (34f94 <nrfx_spim_2_irq_handler+0x28>)
   34f7a:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   34f7e:	6803      	ldr	r3, [r0, #0]
   34f80:	b90b      	cbnz	r3, 34f86 <nrfx_spim_2_irq_handler+0x1a>
   34f82:	f7ff fe65 	bl	34c50 <irq_handler.part.2>
    irq_handler(NRF_SPIM2, &m_cb[NRFX_SPIM2_INST_IDX]);
}
   34f86:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        finish_transfer(p_cb);
   34f8a:	f009 ba35 	b.w	3e3f8 <finish_transfer>
}
   34f8e:	bd08      	pop	{r3, pc}
   34f90:	4000a000 	.word	0x4000a000
   34f94:	20025520 	.word	0x20025520

00034f98 <nrfx_spim_3_irq_handler>:
#endif

#if NRFX_CHECK(NRFX_SPIM3_ENABLED)
void nrfx_spim_3_irq_handler(void)
{
   34f98:	b508      	push	{r3, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   34f9a:	4b09      	ldr	r3, [pc, #36]	; (34fc0 <nrfx_spim_3_irq_handler+0x28>)
   34f9c:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   34fa0:	b162      	cbz	r2, 34fbc <nrfx_spim_3_irq_handler+0x24>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   34fa2:	2200      	movs	r2, #0
        NRFX_ASSERT(p_cb->handler);
   34fa4:	4807      	ldr	r0, [pc, #28]	; (34fc4 <nrfx_spim_3_irq_handler+0x2c>)
   34fa6:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   34faa:	6a43      	ldr	r3, [r0, #36]	; 0x24
   34fac:	b90b      	cbnz	r3, 34fb2 <nrfx_spim_3_irq_handler+0x1a>
   34fae:	f7ff fe4f 	bl	34c50 <irq_handler.part.2>
        finish_transfer(p_cb);
   34fb2:	3024      	adds	r0, #36	; 0x24
    irq_handler(NRF_SPIM3, &m_cb[NRFX_SPIM3_INST_IDX]);
}
   34fb4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        finish_transfer(p_cb);
   34fb8:	f009 ba1e 	b.w	3e3f8 <finish_transfer>
}
   34fbc:	bd08      	pop	{r3, pc}
   34fbe:	bf00      	nop
   34fc0:	4000b000 	.word	0x4000b000
   34fc4:	20025520 	.word	0x20025520

00034fc8 <nrf_gpio_pin_port_decode.isra.1>:
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   34fc8:	281f      	cmp	r0, #31
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   34fca:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   34fcc:	d906      	bls.n	34fdc <nrf_gpio_pin_port_decode.isra.1+0x14>
   34fce:	4b04      	ldr	r3, [pc, #16]	; (34fe0 <nrf_gpio_pin_port_decode.isra.1+0x18>)
   34fd0:	4a04      	ldr	r2, [pc, #16]	; (34fe4 <nrf_gpio_pin_port_decode.isra.1+0x1c>)
   34fd2:	f240 11ff 	movw	r1, #511	; 0x1ff
   34fd6:	4804      	ldr	r0, [pc, #16]	; (34fe8 <nrf_gpio_pin_port_decode.isra.1+0x20>)
   34fd8:	f004 f8da 	bl	39190 <__assert_func>
}
   34fdc:	4803      	ldr	r0, [pc, #12]	; (34fec <nrf_gpio_pin_port_decode.isra.1+0x24>)
   34fde:	bd08      	pop	{r3, pc}
   34fe0:	00042a69 	.word	0x00042a69
   34fe4:	000438d7 	.word	0x000438d7
   34fe8:	00042a77 	.word	0x00042a77
   34fec:	40842500 	.word	0x40842500

00034ff0 <nrfx_twim_init>:

nrfx_err_t nrfx_twim_init(nrfx_twim_t const *        p_instance,
                          nrfx_twim_config_t const * p_config,
                          nrfx_twim_evt_handler_t    event_handler,
                          void *                     p_context)
{
   34ff0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   34ff4:	4682      	mov	sl, r0
   34ff6:	4691      	mov	r9, r2
    NRFX_ASSERT(p_config);
   34ff8:	460d      	mov	r5, r1
   34ffa:	b929      	cbnz	r1, 35008 <nrfx_twim_init+0x18>
   34ffc:	21de      	movs	r1, #222	; 0xde
   34ffe:	4b25      	ldr	r3, [pc, #148]	; (35094 <nrfx_twim_init+0xa4>)
   35000:	4a25      	ldr	r2, [pc, #148]	; (35098 <nrfx_twim_init+0xa8>)
    NRFX_ASSERT(p_config->scl != p_config->sda);
   35002:	4826      	ldr	r0, [pc, #152]	; (3509c <nrfx_twim_init+0xac>)
   35004:	f004 f8c4 	bl	39190 <__assert_func>
   35008:	e9d1 8700 	ldrd	r8, r7, [r1]
   3500c:	45b8      	cmp	r8, r7
   3500e:	d103      	bne.n	35018 <nrfx_twim_init+0x28>
   35010:	4b23      	ldr	r3, [pc, #140]	; (350a0 <nrfx_twim_init+0xb0>)
   35012:	4a21      	ldr	r2, [pc, #132]	; (35098 <nrfx_twim_init+0xa8>)
   35014:	21df      	movs	r1, #223	; 0xdf
   35016:	e7f4      	b.n	35002 <nrfx_twim_init+0x12>
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   35018:	2134      	movs	r1, #52	; 0x34
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   3501a:	7906      	ldrb	r6, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   3501c:	4c21      	ldr	r4, [pc, #132]	; (350a4 <nrfx_twim_init+0xb4>)
   3501e:	4371      	muls	r1, r6
   35020:	1860      	adds	r0, r4, r1
   35022:	f890 202d 	ldrb.w	r2, [r0, #45]	; 0x2d
   35026:	bb9a      	cbnz	r2, 35090 <nrfx_twim_init+0xa0>
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler         = event_handler;
    p_cb->p_context       = p_context;
   35028:	6043      	str	r3, [r0, #4]
    p_cb->int_mask        = 0;
    p_cb->repeated        = false;
    p_cb->busy            = false;
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   3502a:	7b6b      	ldrb	r3, [r5, #13]
    p_cb->int_mask        = 0;
   3502c:	6082      	str	r2, [r0, #8]
    p_cb->repeated        = false;
   3502e:	f880 2030 	strb.w	r2, [r0, #48]	; 0x30
    p_cb->busy            = false;
   35032:	f880 202f 	strb.w	r2, [r0, #47]	; 0x2f
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   35036:	f880 3032 	strb.w	r3, [r0, #50]	; 0x32
    p_cb->handler         = event_handler;
   3503a:	f844 9001 	str.w	r9, [r4, r1]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   3503e:	4640      	mov	r0, r8
   35040:	f7ff ffc2 	bl	34fc8 <nrf_gpio_pin_port_decode.isra.1>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   35044:	f240 6b0c 	movw	fp, #1548	; 0x60c
   35048:	f108 0380 	add.w	r3, r8, #128	; 0x80
   3504c:	f840 b023 	str.w	fp, [r0, r3, lsl #2]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   35050:	4638      	mov	r0, r7
   35052:	f7ff ffb9 	bl	34fc8 <nrf_gpio_pin_port_decode.isra.1>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   35056:	f107 0380 	add.w	r3, r7, #128	; 0x80
   3505a:	f840 b023 	str.w	fp, [r0, r3, lsl #2]
       disabled, these pins must be configured in the GPIO peripheral.
    */
    TWIM_PIN_INIT(p_config->scl);
    TWIM_PIN_INIT(p_config->sda);

    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   3505e:	f8da 0000 	ldr.w	r0, [sl]
    nrf_twim_pins_set(p_twim, p_config->scl, p_config->sda);
    nrf_twim_frequency_set(p_twim,
        (nrf_twim_frequency_t)p_config->frequency);
   35062:	68ab      	ldr	r3, [r5, #8]
    p_reg->PSEL.SCL = scl_pin;
   35064:	f8c0 8508 	str.w	r8, [r0, #1288]	; 0x508
    p_reg->PSEL.SDA = sda_pin;
   35068:	f8c0 750c 	str.w	r7, [r0, #1292]	; 0x50c
    p_reg->FREQUENCY = frequency;
   3506c:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524

    if (p_cb->handler)
   35070:	f1b9 0f00 	cmp.w	r9, #0
   35074:	d003      	beq.n	3507e <nrfx_twim_init+0x8e>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_twim),
            p_config->interrupt_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twim));
   35076:	f340 3007 	sbfx	r0, r0, #12, #8
   3507a:	f7f3 f85b 	bl	28134 <arch_irq_enable>
    }

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   3507e:	2334      	movs	r3, #52	; 0x34
   35080:	fb03 4406 	mla	r4, r3, r6, r4
   35084:	2301      	movs	r3, #1

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   35086:	4808      	ldr	r0, [pc, #32]	; (350a8 <nrfx_twim_init+0xb8>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   35088:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
   3508c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return err_code;
   35090:	4806      	ldr	r0, [pc, #24]	; (350ac <nrfx_twim_init+0xbc>)
   35092:	e7fb      	b.n	3508c <nrfx_twim_init+0x9c>
   35094:	000436e4 	.word	0x000436e4
   35098:	000438f0 	.word	0x000438f0
   3509c:	00043976 	.word	0x00043976
   350a0:	000439b2 	.word	0x000439b2
   350a4:	20025568 	.word	0x20025568
   350a8:	0bad0000 	.word	0x0bad0000
   350ac:	0bad0005 	.word	0x0bad0005

000350b0 <nrfx_twim_enable>:
}

void nrfx_twim_enable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   350b0:	2134      	movs	r1, #52	; 0x34
{
   350b2:	b508      	push	{r3, lr}
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   350b4:	4a0b      	ldr	r2, [pc, #44]	; (350e4 <nrfx_twim_enable+0x34>)
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   350b6:	7903      	ldrb	r3, [r0, #4]
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   350b8:	fb01 2303 	mla	r3, r1, r3, r2
   350bc:	f893 202d 	ldrb.w	r2, [r3, #45]	; 0x2d
   350c0:	2a01      	cmp	r2, #1
   350c2:	d006      	beq.n	350d2 <nrfx_twim_enable+0x22>
   350c4:	4b08      	ldr	r3, [pc, #32]	; (350e8 <nrfx_twim_enable+0x38>)
   350c6:	4a09      	ldr	r2, [pc, #36]	; (350ec <nrfx_twim_enable+0x3c>)
   350c8:	f44f 71a3 	mov.w	r1, #326	; 0x146
   350cc:	4808      	ldr	r0, [pc, #32]	; (350f0 <nrfx_twim_enable+0x40>)
   350ce:	f004 f85f 	bl	39190 <__assert_func>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   350d2:	2106      	movs	r1, #6

    nrf_twim_enable(p_instance->p_twim);
   350d4:	6802      	ldr	r2, [r0, #0]
   350d6:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500

    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
   350da:	2202      	movs	r2, #2
   350dc:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance enabled: %d.", p_instance->drv_inst_idx);
}
   350e0:	bd08      	pop	{r3, pc}
   350e2:	bf00      	nop
   350e4:	20025568 	.word	0x20025568
   350e8:	0004394c 	.word	0x0004394c
   350ec:	000438ff 	.word	0x000438ff
   350f0:	00043976 	.word	0x00043976

000350f4 <nrfx_twim_disable>:

void nrfx_twim_disable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   350f4:	2134      	movs	r1, #52	; 0x34
{
   350f6:	b508      	push	{r3, lr}
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   350f8:	4a0f      	ldr	r2, [pc, #60]	; (35138 <nrfx_twim_disable+0x44>)
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   350fa:	7903      	ldrb	r3, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   350fc:	fb01 2303 	mla	r3, r1, r3, r2
   35100:	f893 202d 	ldrb.w	r2, [r3, #45]	; 0x2d
   35104:	b932      	cbnz	r2, 35114 <nrfx_twim_disable+0x20>
   35106:	4b0d      	ldr	r3, [pc, #52]	; (3513c <nrfx_twim_disable+0x48>)
   35108:	4a0d      	ldr	r2, [pc, #52]	; (35140 <nrfx_twim_disable+0x4c>)
   3510a:	f240 1151 	movw	r1, #337	; 0x151
   3510e:	480d      	ldr	r0, [pc, #52]	; (35144 <nrfx_twim_disable+0x50>)
   35110:	f004 f83e 	bl	39190 <__assert_func>

    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   35114:	6802      	ldr	r2, [r0, #0]
    p_cb->int_mask = 0;
   35116:	2000      	movs	r0, #0
    p_reg->INTENCLR = mask;
   35118:	490b      	ldr	r1, [pc, #44]	; (35148 <nrfx_twim_disable+0x54>)
   3511a:	6098      	str	r0, [r3, #8]
   3511c:	f8c2 1308 	str.w	r1, [r2, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
   35120:	f8d2 1200 	ldr.w	r1, [r2, #512]	; 0x200
   35124:	f421 51bc 	bic.w	r1, r1, #6016	; 0x1780
   35128:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   3512c:	f8c2 0500 	str.w	r0, [r2, #1280]	; 0x500
    nrf_twim_int_disable(p_twim, NRF_TWIM_ALL_INTS_MASK);
    nrf_twim_shorts_disable(p_twim, NRF_TWIM_ALL_SHORTS_MASK);
    nrf_twim_disable(p_twim);

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   35130:	2201      	movs	r2, #1
   35132:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance disabled: %d.", p_instance->drv_inst_idx);
}
   35136:	bd08      	pop	{r3, pc}
   35138:	20025568 	.word	0x20025568
   3513c:	000436ed 	.word	0x000436ed
   35140:	00043910 	.word	0x00043910
   35144:	00043976 	.word	0x00043976
   35148:	019c0202 	.word	0x019c0202

0003514c <nrfx_twim_xfer>:


nrfx_err_t nrfx_twim_xfer(nrfx_twim_t           const * p_instance,
                          nrfx_twim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
   3514c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    NRFX_ASSERT(TWIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   35150:	f890 8004 	ldrb.w	r8, [r0, #4]
{
   35154:	460e      	mov	r6, r1
   35156:	4617      	mov	r7, r2
    NRFX_ASSERT(TWIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   35158:	f1b8 0f00 	cmp.w	r8, #0
   3515c:	d107      	bne.n	3516e <nrfx_twim_xfer+0x22>
   3515e:	684b      	ldr	r3, [r1, #4]
   35160:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   35164:	d203      	bcs.n	3516e <nrfx_twim_xfer+0x22>
   35166:	688b      	ldr	r3, [r1, #8]
   35168:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   3516c:	d306      	bcc.n	3517c <nrfx_twim_xfer+0x30>
   3516e:	f240 2163 	movw	r1, #611	; 0x263
   35172:	4ba9      	ldr	r3, [pc, #676]	; (35418 <nrfx_twim_xfer+0x2cc>)
   35174:	4aa9      	ldr	r2, [pc, #676]	; (3541c <nrfx_twim_xfer+0x2d0>)

    nrfx_err_t err_code = NRFX_SUCCESS;
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];

    // TXRX and TXTX transfers are supported only in non-blocking mode.
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWIM_XFER_TXRX)));
   35176:	48aa      	ldr	r0, [pc, #680]	; (35420 <nrfx_twim_xfer+0x2d4>)
   35178:	f004 f80a 	bl	39190 <__assert_func>
   3517c:	4da9      	ldr	r5, [pc, #676]	; (35424 <nrfx_twim_xfer+0x2d8>)
   3517e:	682b      	ldr	r3, [r5, #0]
   35180:	b973      	cbnz	r3, 351a0 <nrfx_twim_xfer+0x54>
   35182:	780b      	ldrb	r3, [r1, #0]
   35184:	2b02      	cmp	r3, #2
   35186:	d104      	bne.n	35192 <nrfx_twim_xfer+0x46>
   35188:	4ba7      	ldr	r3, [pc, #668]	; (35428 <nrfx_twim_xfer+0x2dc>)
   3518a:	4aa4      	ldr	r2, [pc, #656]	; (3541c <nrfx_twim_xfer+0x2d0>)
   3518c:	f240 2169 	movw	r1, #617	; 0x269
   35190:	e7f1      	b.n	35176 <nrfx_twim_xfer+0x2a>
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWIM_XFER_TXTX)));
   35192:	2b03      	cmp	r3, #3
   35194:	d104      	bne.n	351a0 <nrfx_twim_xfer+0x54>
   35196:	4ba5      	ldr	r3, [pc, #660]	; (3542c <nrfx_twim_xfer+0x2e0>)
   35198:	4aa0      	ldr	r2, [pc, #640]	; (3541c <nrfx_twim_xfer+0x2d0>)
   3519a:	f240 216a 	movw	r1, #618	; 0x26a
   3519e:	e7ea      	b.n	35176 <nrfx_twim_xfer+0x2a>
    p_cb->error = false;
   351a0:	2300      	movs	r3, #0
                           p_xfer_desc->primary_length * sizeof(p_xfer_desc->p_primary_buf[0]));
    NRFX_LOG_DEBUG("Secondary buffer data:");
    NRFX_LOG_HEXDUMP_DEBUG(p_xfer_desc->p_secondary_buf,
                           p_xfer_desc->secondary_length * sizeof(p_xfer_desc->p_secondary_buf[0]));

    err_code = twim_xfer(p_cb, (NRF_TWIM_Type *)p_instance->p_twim, p_xfer_desc, flags);
   351a2:	6804      	ldr	r4, [r0, #0]
    p_cb->error = false;
   351a4:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e
   351a8:	68f3      	ldr	r3, [r6, #12]
   351aa:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
    if (!nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   351ae:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   351b2:	d003      	beq.n	351bc <nrfx_twim_xfer+0x70>
        return err_code;
   351b4:	4e9e      	ldr	r6, [pc, #632]	; (35430 <nrfx_twim_xfer+0x2e4>)
    NRFX_LOG_WARNING("Function: %s, error code: %s.",
                     __func__,
                     NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   351b6:	4630      	mov	r0, r6
   351b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    p_reg->INTENCLR = mask;
   351bc:	4b9d      	ldr	r3, [pc, #628]	; (35434 <nrfx_twim_xfer+0x2e8>)
   351be:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    if (p_cb->busy)
   351c2:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
   351c6:	f003 09ff 	and.w	r9, r3, #255	; 0xff
   351ca:	b123      	cbz	r3, 351d6 <nrfx_twim_xfer+0x8a>
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   351cc:	68ab      	ldr	r3, [r5, #8]
        return err_code;
   351ce:	4e9a      	ldr	r6, [pc, #616]	; (35438 <nrfx_twim_xfer+0x2ec>)
    p_reg->INTENSET = mask;
   351d0:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   351d4:	e7ef      	b.n	351b6 <nrfx_twim_xfer+0x6a>
                      (NRFX_TWIM_FLAG_REPEATED_XFER & flags)) ? false: true;
   351d6:	f017 0f14 	tst.w	r7, #20
   351da:	bf0c      	ite	eq
   351dc:	2301      	moveq	r3, #1
   351de:	2300      	movne	r3, #0
    p_cb->xfer_desc = *p_xfer_desc;
   351e0:	46b6      	mov	lr, r6
   351e2:	f8df c27c 	ldr.w	ip, [pc, #636]	; 35460 <nrfx_twim_xfer+0x314>
        p_cb->busy = ((NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER & flags) ||
   351e6:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    p_cb->xfer_desc = *p_xfer_desc;
   351ea:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   351ee:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   351f2:	f8de 3000 	ldr.w	r3, [lr]
    p_cb->flags = flags;
   351f6:	622f      	str	r7, [r5, #32]
    p_cb->xfer_desc = *p_xfer_desc;
   351f8:	f8cc 3000 	str.w	r3, [ip]
    p_cb->repeated = (flags & NRFX_TWIM_FLAG_REPEATED_XFER) ? true : false;
   351fc:	f3c7 1300 	ubfx	r3, r7, #4, #1
   35200:	f885 3030 	strb.w	r3, [r5, #48]	; 0x30
}

NRF_STATIC_INLINE void nrf_twim_address_set(NRF_TWIM_Type * p_reg,
                                            uint8_t address)
{
    p_reg->ADDRESS = address;
   35204:	7873      	ldrb	r3, [r6, #1]
   35206:	f8c4 3588 	str.w	r3, [r4, #1416]	; 0x588
    if (NRFX_TWIM_FLAG_TX_POSTINC & flags)
   3520a:	f017 0301 	ands.w	r3, r7, #1
    return p_reg->RXD.AMOUNT;
}

NRF_STATIC_INLINE void nrf_twim_tx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_ArrayList << TWIM_TXD_LIST_LIST_Pos;
   3520e:	bf18      	it	ne
   35210:	2301      	movne	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   35212:	f8c4 9104 	str.w	r9, [r4, #260]	; 0x104
   35216:	f8c4 9124 	str.w	r9, [r4, #292]	; 0x124
   3521a:	f8c4 9160 	str.w	r9, [r4, #352]	; 0x160
   3521e:	f8c4 9148 	str.w	r9, [r4, #328]	; 0x148
}

NRF_STATIC_INLINE void nrf_twim_tx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_Disabled << TWIM_TXD_LIST_LIST_Pos;
   35222:	f8c4 3550 	str.w	r3, [r4, #1360]	; 0x550
    if (NRFX_TWIM_FLAG_RX_POSTINC & flags)
   35226:	f017 0302 	ands.w	r3, r7, #2
}

NRF_STATIC_INLINE void nrf_twim_rx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_ArrayList << TWIM_RXD_LIST_LIST_Pos;
   3522a:	bf18      	it	ne
   3522c:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_rx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_Disabled << TWIM_RXD_LIST_LIST_Pos;
   3522e:	f8c4 3540 	str.w	r3, [r4, #1344]	; 0x540
    switch (p_xfer_desc->type)
   35232:	7833      	ldrb	r3, [r6, #0]
   35234:	2b03      	cmp	r3, #3
   35236:	f200 80ac 	bhi.w	35392 <nrfx_twim_xfer+0x246>
   3523a:	e8df f003 	tbb	[pc, r3]
   3523e:	9b86      	.short	0x9b86
   35240:	026e      	.short	0x026e
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_REPEATED_XFER));
   35242:	06f9      	lsls	r1, r7, #27
   35244:	d504      	bpl.n	35250 <nrfx_twim_xfer+0x104>
   35246:	4b7d      	ldr	r3, [pc, #500]	; (3543c <nrfx_twim_xfer+0x2f0>)
   35248:	4a7d      	ldr	r2, [pc, #500]	; (35440 <nrfx_twim_xfer+0x2f4>)
   3524a:	f240 11a9 	movw	r1, #425	; 0x1a9
   3524e:	e792      	b.n	35176 <nrfx_twim_xfer+0x2a>
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_HOLD_XFER));
   35250:	073a      	lsls	r2, r7, #28
   35252:	d504      	bpl.n	3525e <nrfx_twim_xfer+0x112>
   35254:	4b7b      	ldr	r3, [pc, #492]	; (35444 <nrfx_twim_xfer+0x2f8>)
   35256:	4a7a      	ldr	r2, [pc, #488]	; (35440 <nrfx_twim_xfer+0x2f4>)
   35258:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
   3525c:	e78b      	b.n	35176 <nrfx_twim_xfer+0x2a>
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER));
   3525e:	f017 0c04 	ands.w	ip, r7, #4
   35262:	d004      	beq.n	3526e <nrfx_twim_xfer+0x122>
   35264:	4b78      	ldr	r3, [pc, #480]	; (35448 <nrfx_twim_xfer+0x2fc>)
   35266:	4a76      	ldr	r2, [pc, #472]	; (35440 <nrfx_twim_xfer+0x2f4>)
   35268:	f240 11ab 	movw	r1, #427	; 0x1ab
   3526c:	e783      	b.n	35176 <nrfx_twim_xfer+0x2a>
   3526e:	6932      	ldr	r2, [r6, #16]
   35270:	f002 4060 	and.w	r0, r2, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   35274:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
   35278:	d19c      	bne.n	351b4 <nrfx_twim_xfer+0x68>
    p_reg->SHORTS = mask;
   3527a:	f44f 7080 	mov.w	r0, #256	; 0x100
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   3527e:	68f1      	ldr	r1, [r6, #12]
    p_reg->SHORTS = mask;
   35280:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   35284:	6870      	ldr	r0, [r6, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   35286:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   3528a:	2101      	movs	r1, #1
    p_reg->TXD.MAXCNT = length;
   3528c:	f8c4 0548 	str.w	r0, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   35290:	f8c4 c150 	str.w	ip, [r4, #336]	; 0x150
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   35294:	6221      	str	r1, [r4, #32]
   35296:	60a1      	str	r1, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   35298:	f8d4 1150 	ldr.w	r1, [r4, #336]	; 0x150
        while (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_TXSTARTED))
   3529c:	2900      	cmp	r1, #0
   3529e:	d0fb      	beq.n	35298 <nrfx_twim_xfer+0x14c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   352a0:	2100      	movs	r1, #0
   352a2:	f8c4 1150 	str.w	r1, [r4, #336]	; 0x150
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   352a6:	68b1      	ldr	r1, [r6, #8]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   352a8:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
        p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   352ac:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    p_reg->TXD.MAXCNT = length;
   352b0:	f8c4 1548 	str.w	r1, [r4, #1352]	; 0x548
   352b4:	60aa      	str	r2, [r5, #8]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   352b6:	f04f 0808 	mov.w	r8, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
   352ba:	4e64      	ldr	r6, [pc, #400]	; (3544c <nrfx_twim_xfer+0x300>)
    if (!(flags & NRFX_TWIM_FLAG_HOLD_XFER) && (p_xfer_desc->type != NRFX_TWIM_XFER_TXTX))
   352bc:	0739      	lsls	r1, r7, #28
   352be:	d404      	bmi.n	352ca <nrfx_twim_xfer+0x17e>
   352c0:	2b03      	cmp	r3, #3
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   352c2:	bf1c      	itt	ne
   352c4:	2301      	movne	r3, #1
   352c6:	f844 3008 	strne.w	r3, [r4, r8]
    if (p_cb->handler)
   352ca:	682b      	ldr	r3, [r5, #0]
   352cc:	2b00      	cmp	r3, #0
   352ce:	d164      	bne.n	3539a <nrfx_twim_xfer+0x24e>
                transmission_finished = true;
   352d0:	2101      	movs	r1, #1
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   352d2:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
   352d6:	f8d4 0104 	ldr.w	r0, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   352da:	2800      	cmp	r0, #0
   352dc:	d16f      	bne.n	353be <nrfx_twim_xfer+0x272>
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_SUSPENDED))
   352de:	3200      	adds	r2, #0
   352e0:	bf18      	it	ne
   352e2:	2201      	movne	r2, #1
   352e4:	f8d4 0124 	ldr.w	r0, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   352e8:	2800      	cmp	r0, #0
   352ea:	d06c      	beq.n	353c6 <nrfx_twim_xfer+0x27a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   352ec:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   352f0:	f8d4 c160 	ldr.w	ip, [r4, #352]	; 0x160
    return p_reg->SHORTS;
   352f4:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
                if (!(lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_STOP_MASK)))
   352f8:	f1bc 0f00 	cmp.w	ip, #0
   352fc:	d002      	beq.n	35304 <nrfx_twim_xfer+0x1b8>
   352fe:	f410 7f00 	tst.w	r0, #512	; 0x200
   35302:	d105      	bne.n	35310 <nrfx_twim_xfer+0x1c4>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   35304:	6221      	str	r1, [r4, #32]
   35306:	6161      	str	r1, [r4, #20]
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   35308:	f1bc 0f00 	cmp.w	ip, #0
   3530c:	d0e1      	beq.n	352d2 <nrfx_twim_xfer+0x186>
                    transmission_finished = false;
   3530e:	2200      	movs	r2, #0
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   35310:	05c0      	lsls	r0, r0, #23
   35312:	d558      	bpl.n	353c6 <nrfx_twim_xfer+0x27a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   35314:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
                    transmission_finished = false;
   35318:	e7db      	b.n	352d2 <nrfx_twim_xfer+0x186>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   3531a:	6872      	ldr	r2, [r6, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   3531c:	68f1      	ldr	r1, [r6, #12]
   3531e:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   35322:	f8c4 2548 	str.w	r2, [r4, #1352]	; 0x548
   35326:	6932      	ldr	r2, [r6, #16]
   35328:	f002 4160 	and.w	r1, r2, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   3532c:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
   35330:	f47f af40 	bne.w	351b4 <nrfx_twim_xfer+0x68>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   35334:	68b1      	ldr	r1, [r6, #8]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   35336:	f8c4 2534 	str.w	r2, [r4, #1332]	; 0x534
    p_reg->SHORTS = mask;
   3533a:	f44f 5284 	mov.w	r2, #4224	; 0x1080
    p_reg->RXD.MAXCNT = length;
   3533e:	f8c4 1538 	str.w	r1, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   35342:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   35346:	2202      	movs	r2, #2
   35348:	e00d      	b.n	35366 <nrfx_twim_xfer+0x21a>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   3534a:	6872      	ldr	r2, [r6, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   3534c:	68f1      	ldr	r1, [r6, #12]
        if (NRFX_TWIM_FLAG_TX_NO_STOP & flags)
   3534e:	06b8      	lsls	r0, r7, #26
   35350:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   35354:	f8c4 2548 	str.w	r2, [r4, #1352]	; 0x548
   35358:	d509      	bpl.n	3536e <nrfx_twim_xfer+0x222>
    p_reg->SHORTS = mask;
   3535a:	f44f 7280 	mov.w	r2, #256	; 0x100
   3535e:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   35362:	f44f 2280 	mov.w	r2, #262144	; 0x40000
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   35366:	60aa      	str	r2, [r5, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   35368:	2201      	movs	r2, #1
   3536a:	6222      	str	r2, [r4, #32]
   3536c:	e7a3      	b.n	352b6 <nrfx_twim_xfer+0x16a>
    p_reg->SHORTS = mask;
   3536e:	f44f 7200 	mov.w	r2, #512	; 0x200
   35372:	e7e6      	b.n	35342 <nrfx_twim_xfer+0x1f6>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   35374:	6872      	ldr	r2, [r6, #4]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   35376:	68f1      	ldr	r1, [r6, #12]
   35378:	f8c4 1534 	str.w	r1, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   3537c:	f8c4 2538 	str.w	r2, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   35380:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   35384:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   35388:	2202      	movs	r2, #2
   3538a:	60aa      	str	r2, [r5, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   3538c:	2201      	movs	r2, #1
   3538e:	6222      	str	r2, [r4, #32]
   35390:	e793      	b.n	352ba <nrfx_twim_xfer+0x16e>
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   35392:	f04f 0808 	mov.w	r8, #8
        err_code = NRFX_ERROR_INVALID_PARAM;
   35396:	4e2e      	ldr	r6, [pc, #184]	; (35450 <nrfx_twim_xfer+0x304>)
   35398:	e790      	b.n	352bc <nrfx_twim_xfer+0x170>
        if (flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER)
   3539a:	077a      	lsls	r2, r7, #29
            p_cb->int_mask = 0;
   3539c:	bf44      	itt	mi
   3539e:	2300      	movmi	r3, #0
   353a0:	60ab      	strmi	r3, [r5, #8]
        if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK))
   353a2:	067b      	lsls	r3, r7, #25
            p_cb->int_mask |= NRF_TWIM_INT_STOPPED_MASK;
   353a4:	bf5e      	ittt	pl
   353a6:	68ab      	ldrpl	r3, [r5, #8]
   353a8:	f043 0302 	orrpl.w	r3, r3, #2
   353ac:	60ab      	strpl	r3, [r5, #8]
        p_cb->int_mask |= NRF_TWIM_INT_ERROR_MASK;
   353ae:	68ab      	ldr	r3, [r5, #8]
   353b0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   353b4:	60ab      	str	r3, [r5, #8]
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   353b6:	68ab      	ldr	r3, [r5, #8]
    p_reg->INTENSET = mask;
   353b8:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   353bc:	e6fb      	b.n	351b6 <nrfx_twim_xfer+0x6a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   353be:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
                transmission_finished = true;
   353c2:	2201      	movs	r2, #1
   353c4:	e78e      	b.n	352e4 <nrfx_twim_xfer+0x198>
        } while (!transmission_finished);
   353c6:	2a00      	cmp	r2, #0
   353c8:	d083      	beq.n	352d2 <nrfx_twim_xfer+0x186>
        p_cb->busy = false;
   353ca:	2200      	movs	r2, #0
    uint32_t error_source = p_reg->ERRORSRC;
   353cc:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   353d0:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
   353d4:	f885 202f 	strb.w	r2, [r5, #47]	; 0x2f
        if (errorsrc)
   353d8:	b18b      	cbz	r3, 353fe <nrfx_twim_xfer+0x2b2>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
   353da:	4a1e      	ldr	r2, [pc, #120]	; (35454 <nrfx_twim_xfer+0x308>)
   353dc:	f013 0f01 	tst.w	r3, #1
   353e0:	4e1d      	ldr	r6, [pc, #116]	; (35458 <nrfx_twim_xfer+0x30c>)
   353e2:	bf18      	it	ne
   353e4:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   353e6:	f013 0f02 	tst.w	r3, #2
   353ea:	f102 0201 	add.w	r2, r2, #1
   353ee:	bf18      	it	ne
   353f0:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   353f2:	f013 0f04 	tst.w	r3, #4
   353f6:	4b19      	ldr	r3, [pc, #100]	; (3545c <nrfx_twim_xfer+0x310>)
   353f8:	bf18      	it	ne
   353fa:	461e      	movne	r6, r3
   353fc:	e6db      	b.n	351b6 <nrfx_twim_xfer+0x6a>
            if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) &&
   353fe:	067b      	lsls	r3, r7, #25
   35400:	f53f aed9 	bmi.w	351b6 <nrfx_twim_xfer+0x6a>
                !xfer_completeness_check(p_twim, p_cb))
   35404:	4907      	ldr	r1, [pc, #28]	; (35424 <nrfx_twim_xfer+0x2d8>)
   35406:	4620      	mov	r0, r4
   35408:	f009 f80c 	bl	3e424 <xfer_completeness_check>
                err_code = NRFX_ERROR_INTERNAL;
   3540c:	4b12      	ldr	r3, [pc, #72]	; (35458 <nrfx_twim_xfer+0x30c>)
   3540e:	2800      	cmp	r0, #0
   35410:	bf08      	it	eq
   35412:	461e      	moveq	r6, r3
   35414:	e6cf      	b.n	351b6 <nrfx_twim_xfer+0x6a>
   35416:	bf00      	nop
   35418:	000439d1 	.word	0x000439d1
   3541c:	0004392c 	.word	0x0004392c
   35420:	00043976 	.word	0x00043976
   35424:	20025568 	.word	0x20025568
   35428:	00043a7c 	.word	0x00043a7c
   3542c:	00043acc 	.word	0x00043acc
   35430:	0bad000a 	.word	0x0bad000a
   35434:	019c0202 	.word	0x019c0202
   35438:	0bad000b 	.word	0x0bad000b
   3543c:	00043b1c 	.word	0x00043b1c
   35440:	00043922 	.word	0x00043922
   35444:	00043b32 	.word	0x00043b32
   35448:	00043b48 	.word	0x00043b48
   3544c:	0bad0000 	.word	0x0bad0000
   35450:	0bad0004 	.word	0x0bad0004
   35454:	0bae0000 	.word	0x0bae0000
   35458:	0bad0001 	.word	0x0bad0001
   3545c:	0bae0002 	.word	0x0bae0002
   35460:	20025574 	.word	0x20025574

00035464 <nrfx_twim_1_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_TWIM1_ENABLED)
void nrfx_twim_1_irq_handler(void)
{
   35464:	b5f0      	push	{r4, r5, r6, r7, lr}
    NRFX_ASSERT(p_cb->handler);
   35466:	4c5b      	ldr	r4, [pc, #364]	; (355d4 <nrfx_twim_1_irq_handler+0x170>)
{
   35468:	b087      	sub	sp, #28
    NRFX_ASSERT(p_cb->handler);
   3546a:	6823      	ldr	r3, [r4, #0]
   3546c:	b933      	cbnz	r3, 3547c <nrfx_twim_1_irq_handler+0x18>
   3546e:	4b5a      	ldr	r3, [pc, #360]	; (355d8 <nrfx_twim_1_irq_handler+0x174>)
   35470:	4a5a      	ldr	r2, [pc, #360]	; (355dc <nrfx_twim_1_irq_handler+0x178>)
   35472:	f44f 7129 	mov.w	r1, #676	; 0x2a4
   35476:	485a      	ldr	r0, [pc, #360]	; (355e0 <nrfx_twim_1_irq_handler+0x17c>)
   35478:	f003 fe8a 	bl	39190 <__assert_func>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   3547c:	4b59      	ldr	r3, [pc, #356]	; (355e4 <nrfx_twim_1_irq_handler+0x180>)
   3547e:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
   35482:	461d      	mov	r5, r3
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   35484:	b1ea      	cbz	r2, 354c2 <nrfx_twim_1_irq_handler+0x5e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   35486:	2200      	movs	r2, #0
   35488:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   3548c:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
        if (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   35490:	b9ba      	cbnz	r2, 354c2 <nrfx_twim_1_irq_handler+0x5e>
            nrf_twim_int_disable(p_twim, p_cb->int_mask);
   35492:	68a2      	ldr	r2, [r4, #8]
    p_reg->INTENCLR = mask;
   35494:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   35498:	2202      	movs	r2, #2
   3549a:	60a2      	str	r2, [r4, #8]
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   3549c:	68a2      	ldr	r2, [r4, #8]
    p_reg->INTENSET = mask;
   3549e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   354a2:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
            if (!(nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_LASTTX) &&
   354a6:	b11a      	cbz	r2, 354b0 <nrfx_twim_1_irq_handler+0x4c>
    return p_reg->SHORTS;
   354a8:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
   354ac:	059e      	lsls	r6, r3, #22
   354ae:	d403      	bmi.n	354b8 <nrfx_twim_1_irq_handler+0x54>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   354b0:	2201      	movs	r2, #1
   354b2:	4b4c      	ldr	r3, [pc, #304]	; (355e4 <nrfx_twim_1_irq_handler+0x180>)
   354b4:	621a      	str	r2, [r3, #32]
   354b6:	615a      	str	r2, [r3, #20]
            p_cb->error = true;
   354b8:	2301      	movs	r3, #1
   354ba:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
    twim_irq_handler(NRF_TWIM1, &m_cb[NRFX_TWIM1_INST_IDX]);
}
   354be:	b007      	add	sp, #28
   354c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   354c2:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   354c6:	2b00      	cmp	r3, #0
   354c8:	d04e      	beq.n	35568 <nrfx_twim_1_irq_handler+0x104>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   354ca:	2300      	movs	r3, #0
   354cc:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) && !p_cb->error)
   354d0:	6a23      	ldr	r3, [r4, #32]
   354d2:	065d      	lsls	r5, r3, #25
   354d4:	d40a      	bmi.n	354ec <nrfx_twim_1_irq_handler+0x88>
   354d6:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   354da:	b93b      	cbnz	r3, 354ec <nrfx_twim_1_irq_handler+0x88>
            p_cb->error = !xfer_completeness_check(p_twim, p_cb);
   354dc:	493d      	ldr	r1, [pc, #244]	; (355d4 <nrfx_twim_1_irq_handler+0x170>)
   354de:	4841      	ldr	r0, [pc, #260]	; (355e4 <nrfx_twim_1_irq_handler+0x180>)
   354e0:	f008 ffa0 	bl	3e424 <xfer_completeness_check>
   354e4:	f080 0001 	eor.w	r0, r0, #1
   354e8:	f884 002e 	strb.w	r0, [r4, #46]	; 0x2e
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
   354ec:	6a23      	ldr	r3, [r4, #32]
   354ee:	f013 0704 	ands.w	r7, r3, #4
   354f2:	d11e      	bne.n	35532 <nrfx_twim_1_irq_handler+0xce>
            event.xfer_desc = p_cb->xfer_desc;
   354f4:	4e3c      	ldr	r6, [pc, #240]	; (355e8 <nrfx_twim_1_irq_handler+0x184>)
   354f6:	ad01      	add	r5, sp, #4
   354f8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   354fa:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   354fc:	6833      	ldr	r3, [r6, #0]
   354fe:	f894 c030 	ldrb.w	ip, [r4, #48]	; 0x30
   35502:	602b      	str	r3, [r5, #0]
   35504:	4b37      	ldr	r3, [pc, #220]	; (355e4 <nrfx_twim_1_irq_handler+0x180>)
   35506:	f8c3 7160 	str.w	r7, [r3, #352]	; 0x160
   3550a:	f8c3 715c 	str.w	r7, [r3, #348]	; 0x15c
            if (!p_cb->repeated || p_cb->error)
   3550e:	f1bc 0f00 	cmp.w	ip, #0
   35512:	d002      	beq.n	3551a <nrfx_twim_1_irq_handler+0xb6>
   35514:	f894 202e 	ldrb.w	r2, [r4, #46]	; 0x2e
   35518:	b15a      	cbz	r2, 35532 <nrfx_twim_1_irq_handler+0xce>
    p_reg->SHORTS = mask;
   3551a:	2200      	movs	r2, #0
   3551c:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
                p_cb->int_mask = 0;
   35520:	60a2      	str	r2, [r4, #8]
    p_reg->INTENCLR = mask;
   35522:	4a32      	ldr	r2, [pc, #200]	; (355ec <nrfx_twim_1_irq_handler+0x188>)
   35524:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   35528:	f44f 7200 	mov.w	r2, #512	; 0x200
   3552c:	4b30      	ldr	r3, [pc, #192]	; (355f0 <nrfx_twim_1_irq_handler+0x18c>)
   3552e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    uint32_t error_source = p_reg->ERRORSRC;
   35532:	4a2c      	ldr	r2, [pc, #176]	; (355e4 <nrfx_twim_1_irq_handler+0x180>)
   35534:	f8d2 34c4 	ldr.w	r3, [r2, #1220]	; 0x4c4
    if (errorsrc & NRF_TWIM_ERROR_ADDRESS_NACK)
   35538:	0798      	lsls	r0, r3, #30
    p_reg->ERRORSRC = error_source;
   3553a:	f8c2 34c4 	str.w	r3, [r2, #1220]	; 0x4c4
   3553e:	d53a      	bpl.n	355b6 <nrfx_twim_1_irq_handler+0x152>
        event.type = NRFX_TWIM_EVT_ADDRESS_NACK;
   35540:	2301      	movs	r3, #1
        event.type = NRFX_TWIM_EVT_DONE;
   35542:	f88d 3000 	strb.w	r3, [sp]
    if (!p_cb->repeated)
   35546:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   3554a:	b90b      	cbnz	r3, 35550 <nrfx_twim_1_irq_handler+0xec>
        p_cb->busy = false;
   3554c:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
    if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER) || p_cb->error)
   35550:	6a23      	ldr	r3, [r4, #32]
   35552:	075b      	lsls	r3, r3, #29
   35554:	d503      	bpl.n	3555e <nrfx_twim_1_irq_handler+0xfa>
   35556:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   3555a:	2b00      	cmp	r3, #0
   3555c:	d0af      	beq.n	354be <nrfx_twim_1_irq_handler+0x5a>
        p_cb->handler(&event, p_cb->p_context);
   3555e:	e9d4 3100 	ldrd	r3, r1, [r4]
   35562:	4668      	mov	r0, sp
   35564:	4798      	blx	r3
}
   35566:	e7aa      	b.n	354be <nrfx_twim_1_irq_handler+0x5a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   35568:	f8c5 3148 	str.w	r3, [r5, #328]	; 0x148
        if (p_cb->xfer_desc.type == NRFX_TWIM_XFER_TX)
   3556c:	7b23      	ldrb	r3, [r4, #12]
   3556e:	b983      	cbnz	r3, 35592 <nrfx_twim_1_irq_handler+0x12e>
            event.xfer_desc = p_cb->xfer_desc;
   35570:	4f1d      	ldr	r7, [pc, #116]	; (355e8 <nrfx_twim_1_irq_handler+0x184>)
   35572:	ae01      	add	r6, sp, #4
   35574:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
   35576:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   35578:	683b      	ldr	r3, [r7, #0]
   3557a:	6033      	str	r3, [r6, #0]
            if (!p_cb->repeated)
   3557c:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   35580:	2b00      	cmp	r3, #0
   35582:	d1d6      	bne.n	35532 <nrfx_twim_1_irq_handler+0xce>
    p_reg->SHORTS = mask;
   35584:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
                p_cb->int_mask = 0;
   35588:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   3558a:	4b18      	ldr	r3, [pc, #96]	; (355ec <nrfx_twim_1_irq_handler+0x188>)
   3558c:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
   35590:	e7ca      	b.n	35528 <nrfx_twim_1_irq_handler+0xc4>
    p_reg->SHORTS = mask;
   35592:	f44f 7300 	mov.w	r3, #512	; 0x200
   35596:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK | NRF_TWIM_INT_ERROR_MASK;
   3559a:	f240 2302 	movw	r3, #514	; 0x202
   3559e:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   355a0:	f103 73ce 	add.w	r3, r3, #27000832	; 0x19c0000
   355a4:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   355a8:	68a3      	ldr	r3, [r4, #8]
    p_reg->INTENSET = mask;
   355aa:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   355ae:	2301      	movs	r3, #1
   355b0:	60ab      	str	r3, [r5, #8]
   355b2:	622b      	str	r3, [r5, #32]
            return;
   355b4:	e783      	b.n	354be <nrfx_twim_1_irq_handler+0x5a>
    else if (errorsrc & NRF_TWIM_ERROR_DATA_NACK)
   355b6:	0759      	lsls	r1, r3, #29
   355b8:	d501      	bpl.n	355be <nrfx_twim_1_irq_handler+0x15a>
        event.type = NRFX_TWIM_EVT_DATA_NACK;
   355ba:	2302      	movs	r3, #2
   355bc:	e7c1      	b.n	35542 <nrfx_twim_1_irq_handler+0xde>
    else if (errorsrc & NRF_TWIM_ERROR_OVERRUN)
   355be:	07da      	lsls	r2, r3, #31
   355c0:	d501      	bpl.n	355c6 <nrfx_twim_1_irq_handler+0x162>
        event.type = NRFX_TWIM_EVT_OVERRUN;
   355c2:	2303      	movs	r3, #3
   355c4:	e7bd      	b.n	35542 <nrfx_twim_1_irq_handler+0xde>
    else if (p_cb->error)
   355c6:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   355ca:	2b00      	cmp	r3, #0
   355cc:	d0b9      	beq.n	35542 <nrfx_twim_1_irq_handler+0xde>
        event.type = NRFX_TWIM_EVT_BUS_ERROR;
   355ce:	2304      	movs	r3, #4
   355d0:	e7b7      	b.n	35542 <nrfx_twim_1_irq_handler+0xde>
   355d2:	bf00      	nop
   355d4:	20025568 	.word	0x20025568
   355d8:	0004369a 	.word	0x0004369a
   355dc:	0004393b 	.word	0x0004393b
   355e0:	00043976 	.word	0x00043976
   355e4:	40009000 	.word	0x40009000
   355e8:	20025574 	.word	0x20025574
   355ec:	019c0202 	.word	0x019c0202
   355f0:	e000e100 	.word	0xe000e100

000355f4 <z_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_device_do_config_level(s32_t level)
{
   355f4:	b570      	push	{r4, r5, r6, lr}
		retval = device_conf->init(info);
		if (retval != 0) {
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
   355f6:	2600      	movs	r6, #0
	for (info = config_levels[level]; info < config_levels[level+1];
   355f8:	4b08      	ldr	r3, [pc, #32]	; (3561c <z_sys_device_do_config_level+0x28>)
   355fa:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   355fe:	3001      	adds	r0, #1
   35600:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
   35604:	42a5      	cmp	r5, r4
   35606:	d800      	bhi.n	3560a <z_sys_device_do_config_level+0x16>
		} else {
			z_object_init(info);
		}
	}
}
   35608:	bd70      	pop	{r4, r5, r6, pc}
		retval = device_conf->init(info);
   3560a:	6823      	ldr	r3, [r4, #0]
   3560c:	4620      	mov	r0, r4
   3560e:	685b      	ldr	r3, [r3, #4]
   35610:	4798      	blx	r3
		if (retval != 0) {
   35612:	b100      	cbz	r0, 35616 <z_sys_device_do_config_level+0x22>
			info->driver_api = NULL;
   35614:	6066      	str	r6, [r4, #4]
								info++) {
   35616:	340c      	adds	r4, #12
   35618:	e7f4      	b.n	35604 <z_sys_device_do_config_level+0x10>
   3561a:	bf00      	nop
   3561c:	00040350 	.word	0x00040350

00035620 <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
   35620:	4b10      	ldr	r3, [pc, #64]	; (35664 <z_impl_device_get_binding+0x44>)
{
   35622:	b570      	push	{r4, r5, r6, lr}
   35624:	4605      	mov	r5, r0
   35626:	461e      	mov	r6, r3
	for (info = __device_init_start; info != __device_init_end; info++) {
   35628:	4c0f      	ldr	r4, [pc, #60]	; (35668 <z_impl_device_get_binding+0x48>)
   3562a:	429c      	cmp	r4, r3
   3562c:	d104      	bne.n	35638 <z_impl_device_get_binding+0x18>
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
   3562e:	4c0e      	ldr	r4, [pc, #56]	; (35668 <z_impl_device_get_binding+0x48>)
   35630:	42b4      	cmp	r4, r6
   35632:	d109      	bne.n	35648 <z_impl_device_get_binding+0x28>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
   35634:	2400      	movs	r4, #0
   35636:	e012      	b.n	3565e <z_impl_device_get_binding+0x3e>
		if ((info->driver_api != NULL) &&
   35638:	6862      	ldr	r2, [r4, #4]
   3563a:	b11a      	cbz	r2, 35644 <z_impl_device_get_binding+0x24>
		    (info->config->name == name)) {
   3563c:	6822      	ldr	r2, [r4, #0]
		if ((info->driver_api != NULL) &&
   3563e:	6812      	ldr	r2, [r2, #0]
   35640:	42aa      	cmp	r2, r5
   35642:	d00c      	beq.n	3565e <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
   35644:	340c      	adds	r4, #12
   35646:	e7f0      	b.n	3562a <z_impl_device_get_binding+0xa>
		if (info->driver_api == NULL) {
   35648:	6863      	ldr	r3, [r4, #4]
   3564a:	b90b      	cbnz	r3, 35650 <z_impl_device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
   3564c:	340c      	adds	r4, #12
   3564e:	e7ef      	b.n	35630 <z_impl_device_get_binding+0x10>
		if (strcmp(name, info->config->name) == 0) {
   35650:	6823      	ldr	r3, [r4, #0]
   35652:	4628      	mov	r0, r5
   35654:	6819      	ldr	r1, [r3, #0]
   35656:	f7e7 fd75 	bl	1d144 <strcmp>
   3565a:	2800      	cmp	r0, #0
   3565c:	d1f6      	bne.n	3564c <z_impl_device_get_binding+0x2c>
}
   3565e:	4620      	mov	r0, r4
   35660:	bd70      	pop	{r4, r5, r6, pc}
   35662:	bf00      	nop
   35664:	20037a18 	.word	0x20037a18
   35668:	20037904 	.word	0x20037904

0003566c <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   3566c:	4b01      	ldr	r3, [pc, #4]	; (35674 <z_impl_z_errno+0x8>)
   3566e:	6898      	ldr	r0, [r3, #8]
}
   35670:	3054      	adds	r0, #84	; 0x54
   35672:	4770      	bx	lr
   35674:	2002976c 	.word	0x2002976c

00035678 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   35678:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   3567c:	4605      	mov	r5, r0
   3567e:	4688      	mov	r8, r1
	return z_impl_k_current_get();
   35680:	f002 f95a 	bl	37938 <z_impl_k_current_get>
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   35684:	2301      	movs	r3, #1
   35686:	4606      	mov	r6, r0
   35688:	f04f 0000 	mov.w	r0, #0
   3568c:	2200      	movs	r2, #0
   3568e:	f363 0007 	bfi	r0, r3, #0, #8
   35692:	4c2b      	ldr	r4, [pc, #172]	; (35740 <z_fatal_error+0xc8>)
   35694:	4b2b      	ldr	r3, [pc, #172]	; (35744 <z_fatal_error+0xcc>)
   35696:	2d04      	cmp	r5, #4
   35698:	eba4 0403 	sub.w	r4, r4, r3
   3569c:	bf98      	it	ls
   3569e:	4b2a      	ldrls	r3, [pc, #168]	; (35748 <z_fatal_error+0xd0>)
   356a0:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   356a4:	bf94      	ite	ls
   356a6:	f853 3025 	ldrls.w	r3, [r3, r5, lsl #2]
   356aa:	4b28      	ldrhi	r3, [pc, #160]	; (3574c <z_fatal_error+0xd4>)
   356ac:	9200      	str	r2, [sp, #0]
   356ae:	f364 108f 	bfi	r0, r4, #6, #10
   356b2:	462a      	mov	r2, r5
   356b4:	4926      	ldr	r1, [pc, #152]	; (35750 <z_fatal_error+0xd8>)
   356b6:	f007 f890 	bl	3c7da <log_string_sync>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   356ba:	f8d8 301c 	ldr.w	r3, [r8, #28]
   356be:	f3c3 0308 	ubfx	r3, r3, #0, #9
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if (arch_is_in_nested_exception(esf)) {
   356c2:	b14b      	cbz	r3, 356d8 <z_fatal_error+0x60>
		LOG_ERR("Fault during interrupt handling\n");
   356c4:	f04f 0000 	mov.w	r0, #0
   356c8:	2301      	movs	r3, #1
   356ca:	f363 0007 	bfi	r0, r3, #0, #8
   356ce:	f364 108f 	bfi	r0, r4, #6, #10
   356d2:	4920      	ldr	r1, [pc, #128]	; (35754 <z_fatal_error+0xdc>)
   356d4:	f007 f881 	bl	3c7da <log_string_sync>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   356d8:	f04f 0700 	mov.w	r7, #0
   356dc:	2301      	movs	r3, #1
	const char *thread_name = k_thread_name_get(thread);
   356de:	4630      	mov	r0, r6
	LOG_ERR("Current thread: %p (%s)", thread,
   356e0:	f363 0707 	bfi	r7, r3, #0, #8
   356e4:	f364 178f 	bfi	r7, r4, #6, #10
	const char *thread_name = k_thread_name_get(thread);
   356e8:	f008 ff7b 	bl	3e5e2 <k_thread_name_get>
	if (thread_name == NULL || thread_name[0] == '\0') {
   356ec:	b328      	cbz	r0, 3573a <z_fatal_error+0xc2>
   356ee:	7802      	ldrb	r2, [r0, #0]
		thread_name = "unknown";
   356f0:	4b19      	ldr	r3, [pc, #100]	; (35758 <z_fatal_error+0xe0>)
   356f2:	2a00      	cmp	r2, #0
   356f4:	bf08      	it	eq
   356f6:	4618      	moveq	r0, r3
	LOG_ERR("Current thread: %p (%s)", thread,
   356f8:	f007 f881 	bl	3c7fe <log_strdup>
   356fc:	4632      	mov	r2, r6
   356fe:	4603      	mov	r3, r0
   35700:	4916      	ldr	r1, [pc, #88]	; (3575c <z_fatal_error+0xe4>)
   35702:	4638      	mov	r0, r7
   35704:	f007 f869 	bl	3c7da <log_string_sync>
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
   35708:	4641      	mov	r1, r8
   3570a:	4628      	mov	r0, r5
   3570c:	f7f6 fedc 	bl	2c4c8 <k_sys_fatal_error_handler>
	 *
	 * Note that k_thread_abort() returns on some architectures but
	 * not others; e.g. on ARC, x86_64, Xtensa with ASM2, ARM
	 */
	if (!IS_ENABLED(CONFIG_TEST)) {
		__ASSERT(reason != K_ERR_KERNEL_PANIC,
   35710:	2d04      	cmp	r5, #4
   35712:	d10c      	bne.n	3572e <z_fatal_error+0xb6>
   35714:	4912      	ldr	r1, [pc, #72]	; (35760 <z_fatal_error+0xe8>)
   35716:	2387      	movs	r3, #135	; 0x87
   35718:	4a12      	ldr	r2, [pc, #72]	; (35764 <z_fatal_error+0xec>)
   3571a:	4813      	ldr	r0, [pc, #76]	; (35768 <z_fatal_error+0xf0>)
   3571c:	f007 f806 	bl	3c72c <printk>
   35720:	4812      	ldr	r0, [pc, #72]	; (3576c <z_fatal_error+0xf4>)
   35722:	f007 f803 	bl	3c72c <printk>
   35726:	2187      	movs	r1, #135	; 0x87
   35728:	480e      	ldr	r0, [pc, #56]	; (35764 <z_fatal_error+0xec>)
   3572a:	f007 f845 	bl	3c7b8 <assert_post_action>
	z_impl_k_thread_abort(thread);
   3572e:	4630      	mov	r0, r6
			}
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	k_thread_abort(thread);
}
   35730:	b002      	add	sp, #8
   35732:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   35736:	f7f3 b99d 	b.w	28a74 <z_impl_k_thread_abort>
		thread_name = "unknown";
   3573a:	4807      	ldr	r0, [pc, #28]	; (35758 <z_fatal_error+0xe0>)
   3573c:	e7dc      	b.n	356f8 <z_fatal_error+0x80>
   3573e:	bf00      	nop
   35740:	0003f9ac 	.word	0x0003f9ac
   35744:	0003f8d4 	.word	0x0003f8d4
   35748:	00040368 	.word	0x00040368
   3574c:	00043ba8 	.word	0x00043ba8
   35750:	00043bbe 	.word	0x00043bbe
   35754:	00043be6 	.word	0x00043be6
   35758:	00043bb6 	.word	0x00043bb6
   3575c:	00043c07 	.word	0x00043c07
   35760:	00043c41 	.word	0x00043c41
   35764:	00043c1f 	.word	0x00043c1f
   35768:	00040606 	.word	0x00040606
   3576c:	00043c5e 	.word	0x00043c5e

00035770 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
   35770:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
   35772:	4d0b      	ldr	r5, [pc, #44]	; (357a0 <idle+0x30>)
	__asm__ volatile(
   35774:	f04f 0220 	mov.w	r2, #32
   35778:	f3ef 8311 	mrs	r3, BASEPRI
   3577c:	f382 8811 	msr	BASEPRI, r2
   35780:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
   35784:	f002 fdca 	bl	3831c <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   35788:	2101      	movs	r1, #1
	s32_t ticks = z_get_next_timeout_expiry();
   3578a:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   3578c:	2802      	cmp	r0, #2
   3578e:	bfd8      	it	le
   35790:	4608      	movle	r0, r1
   35792:	f002 fe0b 	bl	383ac <z_set_timeout_expiry>
	_kernel.idle = ticks;
   35796:	622c      	str	r4, [r5, #32]
 * @return N/A
 * @req K-CPU-IDLE-001
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
   35798:	f7f2 fc7e 	bl	28098 <arch_cpu_idle>
   3579c:	e7ea      	b.n	35774 <idle+0x4>
   3579e:	bf00      	nop
   357a0:	2002976c 	.word	0x2002976c

000357a4 <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   357a4:	4802      	ldr	r0, [pc, #8]	; (357b0 <z_bss_zero+0xc>)
   357a6:	4a03      	ldr	r2, [pc, #12]	; (357b4 <z_bss_zero+0x10>)
   357a8:	2100      	movs	r1, #0
   357aa:	1a12      	subs	r2, r2, r0
   357ac:	f009 b86e 	b.w	3e88c <memset>
   357b0:	20020000 	.word	0x20020000
   357b4:	2002d948 	.word	0x2002d948

000357b8 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   357b8:	b508      	push	{r3, lr}
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   357ba:	4806      	ldr	r0, [pc, #24]	; (357d4 <z_data_copy+0x1c>)
   357bc:	4a06      	ldr	r2, [pc, #24]	; (357d8 <z_data_copy+0x20>)
   357be:	4907      	ldr	r1, [pc, #28]	; (357dc <z_data_copy+0x24>)
   357c0:	1a12      	subs	r2, r2, r0
   357c2:	f009 f843 	bl	3e84c <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   357c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   357ca:	4a05      	ldr	r2, [pc, #20]	; (357e0 <z_data_copy+0x28>)
   357cc:	4905      	ldr	r1, [pc, #20]	; (357e4 <z_data_copy+0x2c>)
   357ce:	4806      	ldr	r0, [pc, #24]	; (357e8 <z_data_copy+0x30>)
   357d0:	f009 b83c 	b.w	3e84c <memcpy>
   357d4:	200345c8 	.word	0x200345c8
   357d8:	20037bbc 	.word	0x20037bbc
   357dc:	000444ac 	.word	0x000444ac
   357e0:	00000000 	.word	0x00000000
   357e4:	000444ac 	.word	0x000444ac
   357e8:	20020000 	.word	0x20020000

000357ec <bg_thread_main>:
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
   357ec:	2201      	movs	r2, #1
{
   357ee:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   357f0:	4b08      	ldr	r3, [pc, #32]	; (35814 <bg_thread_main+0x28>)

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   357f2:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   357f4:	701a      	strb	r2, [r3, #0]
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   357f6:	f7ff fefd 	bl	355f4 <z_sys_device_do_config_level>
			KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
   357fa:	2003      	movs	r0, #3
   357fc:	f7ff fefa 	bl	355f4 <z_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
   35800:	f002 fa70 	bl	37ce4 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
   35804:	f005 f818 	bl	3a838 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   35808:	4a03      	ldr	r2, [pc, #12]	; (35818 <bg_thread_main+0x2c>)
   3580a:	7b13      	ldrb	r3, [r2, #12]
   3580c:	f023 0301 	bic.w	r3, r3, #1
   35810:	7313      	strb	r3, [r2, #12]

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   35812:	bd08      	pop	{r3, pc}
   35814:	2002d7f2 	.word	0x2002d7f2
   35818:	2002564c 	.word	0x2002564c

0003581c <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
   3581c:	b580      	push	{r7, lr}
   3581e:	b0b2      	sub	sp, #200	; 0xc8
#endif	/* CONFIG_STACK_CANARIES */

	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
   35820:	f7f1 f8e2 	bl	269e8 <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(_interrupt_stack)) +
   35824:	4b35      	ldr	r3, [pc, #212]	; (358fc <z_cstart+0xe0>)
   35826:	f503 6200 	add.w	r2, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   3582a:	f382 8808 	msr	MSP, r2
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
   3582e:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   35832:	2400      	movs	r4, #0
   35834:	23e0      	movs	r3, #224	; 0xe0
   35836:	4d32      	ldr	r5, [pc, #200]	; (35900 <z_cstart+0xe4>)

	/* perform any architecture-specific initialization */
	arch_kernel_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
   35838:	2701      	movs	r7, #1
   3583a:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   3583e:	77ec      	strb	r4, [r5, #31]
   35840:	762c      	strb	r4, [r5, #24]
   35842:	766c      	strb	r4, [r5, #25]
   35844:	76ac      	strb	r4, [r5, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   35846:	6a6b      	ldr	r3, [r5, #36]	; 0x24
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
   35848:	4e2e      	ldr	r6, [pc, #184]	; (35904 <z_cstart+0xe8>)
   3584a:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   3584e:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   35850:	f7f3 f8e6 	bl	28a20 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   35854:	f7f2 fc1a 	bl	2808c <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   35858:	f04f 33ff 	mov.w	r3, #4294967295
   3585c:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   3585e:	62eb      	str	r3, [r5, #44]	; 0x2c
	struct k_thread dummy_thread = {
   35860:	ab06      	add	r3, sp, #24
   35862:	22b0      	movs	r2, #176	; 0xb0
   35864:	4621      	mov	r1, r4
   35866:	4618      	mov	r0, r3
   35868:	f009 f810 	bl	3e88c <memset>
	_current = &dummy_thread;
   3586c:	60b0      	str	r0, [r6, #8]
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   3586e:	4620      	mov	r0, r4
	struct k_thread dummy_thread = {
   35870:	f88d 7025 	strb.w	r7, [sp, #37]	; 0x25
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   35874:	f7ff febe 	bl	355f4 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   35878:	4638      	mov	r0, r7
   3587a:	f7ff febb 	bl	355f4 <z_sys_device_do_config_level>
	_kernel.ready_q.cache = &z_main_thread;
   3587e:	4d22      	ldr	r5, [pc, #136]	; (35908 <z_cstart+0xec>)
	z_sched_init();
   35880:	f001 fed0 	bl	37624 <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
   35884:	4b21      	ldr	r3, [pc, #132]	; (3590c <z_cstart+0xf0>)
   35886:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   3588a:	e9cd 7304 	strd	r7, r3, [sp, #16]
   3588e:	e9cd 4402 	strd	r4, r4, [sp, #8]
   35892:	4b1f      	ldr	r3, [pc, #124]	; (35910 <z_cstart+0xf4>)
   35894:	e9cd 4400 	strd	r4, r4, [sp]
   35898:	491e      	ldr	r1, [pc, #120]	; (35914 <z_cstart+0xf8>)
   3589a:	4628      	mov	r0, r5
	_kernel.ready_q.cache = &z_main_thread;
   3589c:	6275      	str	r5, [r6, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
   3589e:	f002 f937 	bl	37b10 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   358a2:	7b6b      	ldrb	r3, [r5, #13]
   358a4:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   358a8:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
   358ac:	736a      	strb	r2, [r5, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   358ae:	d104      	bne.n	358ba <z_cstart+0x9e>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
   358b0:	69ab      	ldr	r3, [r5, #24]
   358b2:	b913      	cbnz	r3, 358ba <z_cstart+0x9e>
		z_add_thread_to_ready_q(thread);
   358b4:	4628      	mov	r0, r5
   358b6:	f001 f9af 	bl	36c18 <z_add_thread_to_ready_q>
	z_setup_new_thread(thread, stack,
   358ba:	4b17      	ldr	r3, [pc, #92]	; (35918 <z_cstart+0xfc>)
   358bc:	2201      	movs	r2, #1
   358be:	9305      	str	r3, [sp, #20]
   358c0:	230f      	movs	r3, #15
   358c2:	e9cd 3203 	strd	r3, r2, [sp, #12]
   358c6:	2300      	movs	r3, #0
   358c8:	4d14      	ldr	r5, [pc, #80]	; (3591c <z_cstart+0x100>)
   358ca:	e9cd 3301 	strd	r3, r3, [sp, #4]
   358ce:	9300      	str	r3, [sp, #0]
   358d0:	f44f 72a0 	mov.w	r2, #320	; 0x140
   358d4:	4b12      	ldr	r3, [pc, #72]	; (35920 <z_cstart+0x104>)
   358d6:	4913      	ldr	r1, [pc, #76]	; (35924 <z_cstart+0x108>)
   358d8:	4628      	mov	r0, r5
   358da:	f002 f919 	bl	37b10 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   358de:	7b6b      	ldrb	r3, [r5, #13]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
   358e0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   358e4:	f023 0304 	bic.w	r3, r3, #4
   358e8:	736b      	strb	r3, [r5, #13]
	list->head = (sys_dnode_t *)list;
   358ea:	4b0f      	ldr	r3, [pc, #60]	; (35928 <z_cstart+0x10c>)
   358ec:	4909      	ldr	r1, [pc, #36]	; (35914 <z_cstart+0xf8>)
	list->tail = (sys_dnode_t *)list;
   358ee:	e9c6 3306 	strd	r3, r3, [r6, #24]
   358f2:	4805      	ldr	r0, [pc, #20]	; (35908 <z_cstart+0xec>)
   358f4:	4b06      	ldr	r3, [pc, #24]	; (35910 <z_cstart+0xf4>)
	_kernel.cpus[0].idle_thread = &z_idle_thread;
   358f6:	60f5      	str	r5, [r6, #12]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
   358f8:	f7f2 fcbe 	bl	28278 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   358fc:	20032088 	.word	0x20032088
   35900:	e000ed00 	.word	0xe000ed00
   35904:	2002976c 	.word	0x2002976c
   35908:	2002564c 	.word	0x2002564c
   3590c:	00043c96 	.word	0x00043c96
   35910:	000357ed 	.word	0x000357ed
   35914:	2002ff48 	.word	0x2002ff48
   35918:	00043c9b 	.word	0x00043c9b
   3591c:	2002559c 	.word	0x2002559c
   35920:	00035771 	.word	0x00035771
   35924:	20031f48 	.word	0x20031f48
   35928:	20029784 	.word	0x20029784

0003592c <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(struct device *dev)
{
   3592c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   35930:	4d16      	ldr	r5, [pc, #88]	; (3598c <init_mem_slab_module+0x60>)
   35932:	4c17      	ldr	r4, [pc, #92]	; (35990 <init_mem_slab_module+0x64>)
   35934:	46a8      	mov	r8, r5
   35936:	4e17      	ldr	r6, [pc, #92]	; (35994 <init_mem_slab_module+0x68>)
   35938:	42ac      	cmp	r4, r5
   3593a:	d90c      	bls.n	35956 <init_mem_slab_module+0x2a>
   3593c:	4916      	ldr	r1, [pc, #88]	; (35998 <init_mem_slab_module+0x6c>)
   3593e:	2342      	movs	r3, #66	; 0x42
   35940:	4632      	mov	r2, r6
   35942:	4816      	ldr	r0, [pc, #88]	; (3599c <init_mem_slab_module+0x70>)
   35944:	f006 fef2 	bl	3c72c <printk>
   35948:	4815      	ldr	r0, [pc, #84]	; (359a0 <init_mem_slab_module+0x74>)
   3594a:	f006 feef 	bl	3c72c <printk>
   3594e:	2142      	movs	r1, #66	; 0x42
   35950:	4630      	mov	r0, r6
   35952:	f006 ff31 	bl	3c7b8 <assert_post_action>
   35956:	4544      	cmp	r4, r8
   35958:	d302      	bcc.n	35960 <init_mem_slab_module+0x34>
		}
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}

out:
   3595a:	2000      	movs	r0, #0
	return rc;
}
   3595c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   35960:	e9d4 1203 	ldrd	r1, r2, [r4, #12]
   35964:	ea42 0301 	orr.w	r3, r2, r1
   35968:	f013 0303 	ands.w	r3, r3, #3
   3596c:	d10b      	bne.n	35986 <init_mem_slab_module+0x5a>
	for (j = 0U; j < slab->num_blocks; j++) {
   3596e:	68a0      	ldr	r0, [r4, #8]
	slab->free_list = NULL;
   35970:	6163      	str	r3, [r4, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   35972:	4283      	cmp	r3, r0
   35974:	d101      	bne.n	3597a <init_mem_slab_module+0x4e>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   35976:	341c      	adds	r4, #28
   35978:	e7de      	b.n	35938 <init_mem_slab_module+0xc>
		*(char **)p = slab->free_list;
   3597a:	6967      	ldr	r7, [r4, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   3597c:	3301      	adds	r3, #1
		*(char **)p = slab->free_list;
   3597e:	6017      	str	r7, [r2, #0]
		slab->free_list = p;
   35980:	6162      	str	r2, [r4, #20]
		p += slab->block_size;
   35982:	440a      	add	r2, r1
   35984:	e7f5      	b.n	35972 <init_mem_slab_module+0x46>
		return -EINVAL;
   35986:	f06f 0015 	mvn.w	r0, #21
	return rc;
   3598a:	e7e7      	b.n	3595c <init_mem_slab_module+0x30>
   3598c:	20037a60 	.word	0x20037a60
   35990:	20037a44 	.word	0x20037a44
   35994:	00043ca0 	.word	0x00043ca0
   35998:	00043cc5 	.word	0x00043cc5
   3599c:	00040606 	.word	0x00040606
   359a0:	00043ce2 	.word	0x00043ce2

000359a4 <k_mem_slab_alloc>:
out:
	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)
{
   359a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   359a6:	4604      	mov	r4, r0
   359a8:	460d      	mov	r5, r1
   359aa:	4616      	mov	r6, r2
   359ac:	f04f 0320 	mov.w	r3, #32
   359b0:	f3ef 8711 	mrs	r7, BASEPRI
   359b4:	f383 8811 	msr	BASEPRI, r3
   359b8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   359bc:	4823      	ldr	r0, [pc, #140]	; (35a4c <k_mem_slab_alloc+0xa8>)
   359be:	f002 f8bf 	bl	37b40 <z_spin_lock_valid>
   359c2:	b968      	cbnz	r0, 359e0 <k_mem_slab_alloc+0x3c>
   359c4:	234a      	movs	r3, #74	; 0x4a
   359c6:	4a22      	ldr	r2, [pc, #136]	; (35a50 <k_mem_slab_alloc+0xac>)
   359c8:	4922      	ldr	r1, [pc, #136]	; (35a54 <k_mem_slab_alloc+0xb0>)
   359ca:	4823      	ldr	r0, [pc, #140]	; (35a58 <k_mem_slab_alloc+0xb4>)
   359cc:	f006 feae 	bl	3c72c <printk>
   359d0:	491e      	ldr	r1, [pc, #120]	; (35a4c <k_mem_slab_alloc+0xa8>)
   359d2:	4822      	ldr	r0, [pc, #136]	; (35a5c <k_mem_slab_alloc+0xb8>)
   359d4:	f006 feaa 	bl	3c72c <printk>
   359d8:	214a      	movs	r1, #74	; 0x4a
   359da:	481d      	ldr	r0, [pc, #116]	; (35a50 <k_mem_slab_alloc+0xac>)
   359dc:	f006 feec 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   359e0:	481a      	ldr	r0, [pc, #104]	; (35a4c <k_mem_slab_alloc+0xa8>)
   359e2:	f002 f8cb 	bl	37b7c <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
   359e6:	6963      	ldr	r3, [r4, #20]
   359e8:	b1eb      	cbz	r3, 35a26 <k_mem_slab_alloc+0x82>
		/* take a free block */
		*mem = slab->free_list;
   359ea:	602b      	str	r3, [r5, #0]
		slab->free_list = *(char **)(slab->free_list);
   359ec:	681b      	ldr	r3, [r3, #0]
   359ee:	6163      	str	r3, [r4, #20]
		slab->num_used++;
   359f0:	69a3      	ldr	r3, [r4, #24]
   359f2:	3301      	adds	r3, #1
   359f4:	61a3      	str	r3, [r4, #24]
		result = 0;
   359f6:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   359f8:	4814      	ldr	r0, [pc, #80]	; (35a4c <k_mem_slab_alloc+0xa8>)
   359fa:	f002 f8af 	bl	37b5c <z_spin_unlock_valid>
   359fe:	b968      	cbnz	r0, 35a1c <k_mem_slab_alloc+0x78>
   35a00:	235d      	movs	r3, #93	; 0x5d
   35a02:	4a13      	ldr	r2, [pc, #76]	; (35a50 <k_mem_slab_alloc+0xac>)
   35a04:	4916      	ldr	r1, [pc, #88]	; (35a60 <k_mem_slab_alloc+0xbc>)
   35a06:	4814      	ldr	r0, [pc, #80]	; (35a58 <k_mem_slab_alloc+0xb4>)
   35a08:	f006 fe90 	bl	3c72c <printk>
   35a0c:	490f      	ldr	r1, [pc, #60]	; (35a4c <k_mem_slab_alloc+0xa8>)
   35a0e:	4815      	ldr	r0, [pc, #84]	; (35a64 <k_mem_slab_alloc+0xc0>)
   35a10:	f006 fe8c 	bl	3c72c <printk>
   35a14:	215d      	movs	r1, #93	; 0x5d
   35a16:	480e      	ldr	r0, [pc, #56]	; (35a50 <k_mem_slab_alloc+0xac>)
   35a18:	f006 fece 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   35a1c:	f387 8811 	msr	BASEPRI, r7
   35a20:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
   35a24:	e010      	b.n	35a48 <k_mem_slab_alloc+0xa4>
	} else if (timeout == K_NO_WAIT) {
   35a26:	b91e      	cbnz	r6, 35a30 <k_mem_slab_alloc+0x8c>
		*mem = NULL;
   35a28:	602e      	str	r6, [r5, #0]
		result = -ENOMEM;
   35a2a:	f06f 040b 	mvn.w	r4, #11
   35a2e:	e7e3      	b.n	359f8 <k_mem_slab_alloc+0x54>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
   35a30:	4622      	mov	r2, r4
   35a32:	4633      	mov	r3, r6
   35a34:	4639      	mov	r1, r7
   35a36:	4805      	ldr	r0, [pc, #20]	; (35a4c <k_mem_slab_alloc+0xa8>)
   35a38:	f001 fca8 	bl	3738c <z_pend_curr>
		if (result == 0) {
   35a3c:	4604      	mov	r4, r0
   35a3e:	b918      	cbnz	r0, 35a48 <k_mem_slab_alloc+0xa4>
			*mem = _current->base.swap_data;
   35a40:	4b09      	ldr	r3, [pc, #36]	; (35a68 <k_mem_slab_alloc+0xc4>)
   35a42:	689b      	ldr	r3, [r3, #8]
   35a44:	695b      	ldr	r3, [r3, #20]
   35a46:	602b      	str	r3, [r5, #0]
}
   35a48:	4620      	mov	r0, r4
   35a4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   35a4c:	200256fc 	.word	0x200256fc
   35a50:	000405cb 	.word	0x000405cb
   35a54:	000405f1 	.word	0x000405f1
   35a58:	00040606 	.word	0x00040606
   35a5c:	00040623 	.word	0x00040623
   35a60:	00040665 	.word	0x00040665
   35a64:	0004067c 	.word	0x0004067c
   35a68:	2002976c 	.word	0x2002976c

00035a6c <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   35a6c:	b570      	push	{r4, r5, r6, lr}
   35a6e:	4604      	mov	r4, r0
   35a70:	460d      	mov	r5, r1
	__asm__ volatile(
   35a72:	f04f 0320 	mov.w	r3, #32
   35a76:	f3ef 8611 	mrs	r6, BASEPRI
   35a7a:	f383 8811 	msr	BASEPRI, r3
   35a7e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   35a82:	4824      	ldr	r0, [pc, #144]	; (35b14 <k_mem_slab_free+0xa8>)
   35a84:	f002 f85c 	bl	37b40 <z_spin_lock_valid>
   35a88:	b968      	cbnz	r0, 35aa6 <k_mem_slab_free+0x3a>
   35a8a:	234a      	movs	r3, #74	; 0x4a
   35a8c:	4a22      	ldr	r2, [pc, #136]	; (35b18 <k_mem_slab_free+0xac>)
   35a8e:	4923      	ldr	r1, [pc, #140]	; (35b1c <k_mem_slab_free+0xb0>)
   35a90:	4823      	ldr	r0, [pc, #140]	; (35b20 <k_mem_slab_free+0xb4>)
   35a92:	f006 fe4b 	bl	3c72c <printk>
   35a96:	491f      	ldr	r1, [pc, #124]	; (35b14 <k_mem_slab_free+0xa8>)
   35a98:	4822      	ldr	r0, [pc, #136]	; (35b24 <k_mem_slab_free+0xb8>)
   35a9a:	f006 fe47 	bl	3c72c <printk>
   35a9e:	214a      	movs	r1, #74	; 0x4a
   35aa0:	481d      	ldr	r0, [pc, #116]	; (35b18 <k_mem_slab_free+0xac>)
   35aa2:	f006 fe89 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   35aa6:	481b      	ldr	r0, [pc, #108]	; (35b14 <k_mem_slab_free+0xa8>)
   35aa8:	f002 f868 	bl	37b7c <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   35aac:	4620      	mov	r0, r4
   35aae:	f001 fd29 	bl	37504 <z_unpend_first_thread>

	if (pending_thread != NULL) {
   35ab2:	b180      	cbz	r0, 35ad6 <k_mem_slab_free+0x6a>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   35ab4:	2100      	movs	r1, #0
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   35ab6:	682a      	ldr	r2, [r5, #0]
   35ab8:	6681      	str	r1, [r0, #104]	; 0x68
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   35aba:	6142      	str	r2, [r0, #20]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   35abc:	7b42      	ldrb	r2, [r0, #13]
   35abe:	06d2      	lsls	r2, r2, #27
   35ac0:	d103      	bne.n	35aca <k_mem_slab_free+0x5e>
	if (z_is_thread_ready(thread)) {
   35ac2:	6983      	ldr	r3, [r0, #24]
   35ac4:	b90b      	cbnz	r3, 35aca <k_mem_slab_free+0x5e>
		z_add_thread_to_ready_q(thread);
   35ac6:	f001 f8a7 	bl	36c18 <z_add_thread_to_ready_q>
		z_ready_thread(pending_thread);
		z_reschedule(&lock, key);
   35aca:	4631      	mov	r1, r6
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
   35acc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   35ad0:	4810      	ldr	r0, [pc, #64]	; (35b14 <k_mem_slab_free+0xa8>)
   35ad2:	f000 beb7 	b.w	36844 <z_reschedule>
		**(char ***)mem = slab->free_list;
   35ad6:	682b      	ldr	r3, [r5, #0]
   35ad8:	6962      	ldr	r2, [r4, #20]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   35ada:	480e      	ldr	r0, [pc, #56]	; (35b14 <k_mem_slab_free+0xa8>)
   35adc:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
   35ade:	682b      	ldr	r3, [r5, #0]
   35ae0:	6163      	str	r3, [r4, #20]
		slab->num_used--;
   35ae2:	69a3      	ldr	r3, [r4, #24]
   35ae4:	3b01      	subs	r3, #1
   35ae6:	61a3      	str	r3, [r4, #24]
   35ae8:	f002 f838 	bl	37b5c <z_spin_unlock_valid>
   35aec:	b968      	cbnz	r0, 35b0a <k_mem_slab_free+0x9e>
   35aee:	235d      	movs	r3, #93	; 0x5d
   35af0:	4a09      	ldr	r2, [pc, #36]	; (35b18 <k_mem_slab_free+0xac>)
   35af2:	490d      	ldr	r1, [pc, #52]	; (35b28 <k_mem_slab_free+0xbc>)
   35af4:	480a      	ldr	r0, [pc, #40]	; (35b20 <k_mem_slab_free+0xb4>)
   35af6:	f006 fe19 	bl	3c72c <printk>
   35afa:	4906      	ldr	r1, [pc, #24]	; (35b14 <k_mem_slab_free+0xa8>)
   35afc:	480b      	ldr	r0, [pc, #44]	; (35b2c <k_mem_slab_free+0xc0>)
   35afe:	f006 fe15 	bl	3c72c <printk>
   35b02:	215d      	movs	r1, #93	; 0x5d
   35b04:	4804      	ldr	r0, [pc, #16]	; (35b18 <k_mem_slab_free+0xac>)
   35b06:	f006 fe57 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   35b0a:	f386 8811 	msr	BASEPRI, r6
   35b0e:	f3bf 8f6f 	isb	sy
}
   35b12:	bd70      	pop	{r4, r5, r6, pc}
   35b14:	200256fc 	.word	0x200256fc
   35b18:	000405cb 	.word	0x000405cb
   35b1c:	000405f1 	.word	0x000405f1
   35b20:	00040606 	.word	0x00040606
   35b24:	00040623 	.word	0x00040623
   35b28:	00040665 	.word	0x00040665
   35b2c:	0004067c 	.word	0x0004067c

00035b30 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
   35b30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ARG_UNUSED(unused);

	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
   35b32:	4d10      	ldr	r5, [pc, #64]	; (35b74 <init_static_pools+0x44>)
   35b34:	4c10      	ldr	r4, [pc, #64]	; (35b78 <init_static_pools+0x48>)
   35b36:	462f      	mov	r7, r5
   35b38:	4e10      	ldr	r6, [pc, #64]	; (35b7c <init_static_pools+0x4c>)
   35b3a:	42ac      	cmp	r4, r5
   35b3c:	d90c      	bls.n	35b58 <init_static_pools+0x28>
   35b3e:	4910      	ldr	r1, [pc, #64]	; (35b80 <init_static_pools+0x50>)
   35b40:	2328      	movs	r3, #40	; 0x28
   35b42:	4632      	mov	r2, r6
   35b44:	480f      	ldr	r0, [pc, #60]	; (35b84 <init_static_pools+0x54>)
   35b46:	f006 fdf1 	bl	3c72c <printk>
   35b4a:	480f      	ldr	r0, [pc, #60]	; (35b88 <init_static_pools+0x58>)
   35b4c:	f006 fdee 	bl	3c72c <printk>
   35b50:	2128      	movs	r1, #40	; 0x28
   35b52:	4630      	mov	r0, r6
   35b54:	f006 fe30 	bl	3c7b8 <assert_post_action>
   35b58:	42bc      	cmp	r4, r7
   35b5a:	d301      	bcc.n	35b60 <init_static_pools+0x30>
		k_mem_pool_init(p);
	}

	return 0;
}
   35b5c:	2000      	movs	r0, #0
   35b5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   35b60:	f104 0314 	add.w	r3, r4, #20
	z_sys_mem_pool_base_init(&p->base);
   35b64:	4620      	mov	r0, r4
   35b66:	e9c4 3305 	strd	r3, r3, [r4, #20]
   35b6a:	f006 fb67 	bl	3c23c <z_sys_mem_pool_base_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
   35b6e:	341c      	adds	r4, #28
   35b70:	e7e3      	b.n	35b3a <init_static_pools+0xa>
   35b72:	bf00      	nop
   35b74:	20037a7c 	.word	0x20037a7c
   35b78:	20037a60 	.word	0x20037a60
   35b7c:	00043d01 	.word	0x00043d01
   35b80:	00043d25 	.word	0x00043d25
   35b84:	00040606 	.word	0x00040606
   35b88:	00043ce2 	.word	0x00043ce2

00035b8c <k_mem_pool_alloc>:

SYS_INIT(init_static_pools, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, s32_t timeout)
{
   35b8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   35b90:	4607      	mov	r7, r0
   35b92:	b085      	sub	sp, #20
   35b94:	460d      	mov	r5, r1
   35b96:	4692      	mov	sl, r2
   35b98:	461c      	mov	r4, r3
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   35b9a:	f3ef 8305 	mrs	r3, IPSR
	int ret;
	s64_t end = 0;

	__ASSERT(!(arch_is_in_isr() && timeout != K_NO_WAIT), "");
   35b9e:	2b00      	cmp	r3, #0
   35ba0:	d048      	beq.n	35c34 <k_mem_pool_alloc+0xa8>
   35ba2:	2c00      	cmp	r4, #0
   35ba4:	d139      	bne.n	35c1a <k_mem_pool_alloc+0x8e>
	s64_t end = 0;
   35ba6:	f04f 0800 	mov.w	r8, #0
	return pool - &_k_mem_pool_list_start[0];
   35baa:	4b26      	ldr	r3, [pc, #152]	; (35c44 <k_mem_pool_alloc+0xb8>)
   35bac:	4e26      	ldr	r6, [pc, #152]	; (35c48 <k_mem_pool_alloc+0xbc>)
   35bae:	1afb      	subs	r3, r7, r3
   35bb0:	109b      	asrs	r3, r3, #2
   35bb2:	435e      	muls	r6, r3
		if (ret == 0 || timeout == K_NO_WAIT ||
		    ret != -ENOMEM) {
			return ret;
		}

		z_pend_curr_unlocked(&p->wait_q, timeout);
   35bb4:	f107 0b14 	add.w	fp, r7, #20
		block->id.pool = pool_id(p);
   35bb8:	b2f6      	uxtb	r6, r6
		ret = z_sys_mem_pool_block_alloc(&p->base, size,
   35bba:	ab03      	add	r3, sp, #12
   35bbc:	aa02      	add	r2, sp, #8
   35bbe:	9500      	str	r5, [sp, #0]
   35bc0:	4651      	mov	r1, sl
   35bc2:	4638      	mov	r0, r7
   35bc4:	f006 fb80 	bl	3c2c8 <z_sys_mem_pool_block_alloc>
		block->id.level = level_num;
   35bc8:	796b      	ldrb	r3, [r5, #5]
   35bca:	9a02      	ldr	r2, [sp, #8]
		block->id.pool = pool_id(p);
   35bcc:	712e      	strb	r6, [r5, #4]
		block->id.level = level_num;
   35bce:	f362 0303 	bfi	r3, r2, #0, #4
   35bd2:	716b      	strb	r3, [r5, #5]
		block->id.block = block_num;
   35bd4:	686b      	ldr	r3, [r5, #4]
   35bd6:	9a03      	ldr	r2, [sp, #12]
   35bd8:	f362 331f 	bfi	r3, r2, #12, #20
   35bdc:	606b      	str	r3, [r5, #4]
		if (ret == 0 || timeout == K_NO_WAIT ||
   35bde:	b1c8      	cbz	r0, 35c14 <k_mem_pool_alloc+0x88>
   35be0:	b1c4      	cbz	r4, 35c14 <k_mem_pool_alloc+0x88>
   35be2:	f110 0f0c 	cmn.w	r0, #12
   35be6:	d115      	bne.n	35c14 <k_mem_pool_alloc+0x88>
	__asm__ volatile(
   35be8:	f04f 0320 	mov.w	r3, #32
   35bec:	f3ef 8011 	mrs	r0, BASEPRI
   35bf0:	f383 8811 	msr	BASEPRI, r3
   35bf4:	f3bf 8f6f 	isb	sy
	(void) z_pend_curr_irqlock(arch_irq_lock(), wait_q, timeout);
   35bf8:	4622      	mov	r2, r4
   35bfa:	4659      	mov	r1, fp
   35bfc:	f001 fb6c 	bl	372d8 <z_pend_curr_irqlock>

		if (timeout != K_FOREVER) {
   35c00:	1c63      	adds	r3, r4, #1
   35c02:	d0da      	beq.n	35bba <k_mem_pool_alloc+0x2e>
	return z_impl_k_uptime_get();
   35c04:	f008 fd65 	bl	3e6d2 <z_impl_k_uptime_get>
			timeout = end - k_uptime_get();
   35c08:	eba8 0400 	sub.w	r4, r8, r0
			if (timeout <= 0) {
   35c0c:	2c00      	cmp	r4, #0
   35c0e:	dcd4      	bgt.n	35bba <k_mem_pool_alloc+0x2e>
				break;
			}
		}
	}

	return -EAGAIN;
   35c10:	f06f 000a 	mvn.w	r0, #10
}
   35c14:	b005      	add	sp, #20
   35c16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	__ASSERT(!(arch_is_in_isr() && timeout != K_NO_WAIT), "");
   35c1a:	490c      	ldr	r1, [pc, #48]	; (35c4c <k_mem_pool_alloc+0xc0>)
   35c1c:	2337      	movs	r3, #55	; 0x37
   35c1e:	4a0c      	ldr	r2, [pc, #48]	; (35c50 <k_mem_pool_alloc+0xc4>)
   35c20:	480c      	ldr	r0, [pc, #48]	; (35c54 <k_mem_pool_alloc+0xc8>)
   35c22:	f006 fd83 	bl	3c72c <printk>
   35c26:	480c      	ldr	r0, [pc, #48]	; (35c58 <k_mem_pool_alloc+0xcc>)
   35c28:	f006 fd80 	bl	3c72c <printk>
   35c2c:	2137      	movs	r1, #55	; 0x37
   35c2e:	4808      	ldr	r0, [pc, #32]	; (35c50 <k_mem_pool_alloc+0xc4>)
   35c30:	f006 fdc2 	bl	3c7b8 <assert_post_action>
	if (timeout > 0) {
   35c34:	2c00      	cmp	r4, #0
   35c36:	ddb6      	ble.n	35ba6 <k_mem_pool_alloc+0x1a>
   35c38:	f008 fd4b 	bl	3e6d2 <z_impl_k_uptime_get>
		end = k_uptime_get() + timeout;
   35c3c:	eb10 0804 	adds.w	r8, r0, r4
   35c40:	e7b3      	b.n	35baa <k_mem_pool_alloc+0x1e>
   35c42:	bf00      	nop
   35c44:	20037a60 	.word	0x20037a60
   35c48:	b6db6db7 	.word	0xb6db6db7
   35c4c:	00043d3f 	.word	0x00043d3f
   35c50:	00043d01 	.word	0x00043d01
   35c54:	00040606 	.word	0x00040606
   35c58:	00042742 	.word	0x00042742

00035c5c <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
   35c5c:	b570      	push	{r4, r5, r6, lr}
   35c5e:	7804      	ldrb	r4, [r0, #0]
	int need_sched = 0;
	struct k_mem_pool *p = get_pool(id->pool);

	z_sys_mem_pool_block_free(&p->base, id->level, id->block);
   35c60:	6802      	ldr	r2, [r0, #0]
   35c62:	7841      	ldrb	r1, [r0, #1]
   35c64:	4d24      	ldr	r5, [pc, #144]	; (35cf8 <k_mem_pool_free_id+0x9c>)
   35c66:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   35c6a:	00a4      	lsls	r4, r4, #2
   35c6c:	0b12      	lsrs	r2, r2, #12
   35c6e:	f001 010f 	and.w	r1, r1, #15
   35c72:	1928      	adds	r0, r5, r4
   35c74:	f7f0 fd3c 	bl	266f0 <z_sys_mem_pool_block_free>
   35c78:	f04f 0320 	mov.w	r3, #32
   35c7c:	f3ef 8611 	mrs	r6, BASEPRI
   35c80:	f383 8811 	msr	BASEPRI, r3
   35c84:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   35c88:	481c      	ldr	r0, [pc, #112]	; (35cfc <k_mem_pool_free_id+0xa0>)
   35c8a:	f001 ff59 	bl	37b40 <z_spin_lock_valid>
   35c8e:	b968      	cbnz	r0, 35cac <k_mem_pool_free_id+0x50>
   35c90:	234a      	movs	r3, #74	; 0x4a
   35c92:	4a1b      	ldr	r2, [pc, #108]	; (35d00 <k_mem_pool_free_id+0xa4>)
   35c94:	491b      	ldr	r1, [pc, #108]	; (35d04 <k_mem_pool_free_id+0xa8>)
   35c96:	481c      	ldr	r0, [pc, #112]	; (35d08 <k_mem_pool_free_id+0xac>)
   35c98:	f006 fd48 	bl	3c72c <printk>
   35c9c:	4917      	ldr	r1, [pc, #92]	; (35cfc <k_mem_pool_free_id+0xa0>)
   35c9e:	481b      	ldr	r0, [pc, #108]	; (35d0c <k_mem_pool_free_id+0xb0>)
   35ca0:	f006 fd44 	bl	3c72c <printk>
   35ca4:	214a      	movs	r1, #74	; 0x4a
   35ca6:	4816      	ldr	r0, [pc, #88]	; (35d00 <k_mem_pool_free_id+0xa4>)
   35ca8:	f006 fd86 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   35cac:	4813      	ldr	r0, [pc, #76]	; (35cfc <k_mem_pool_free_id+0xa0>)
   35cae:	f001 ff65 	bl	37b7c <z_spin_lock_set_owner>
	 * is unsynchronized.  Maybe we want to put the lock into the
	 * wait_q instead and make the API safe?)
	 */
	k_spinlock_key_t key = k_spin_lock(&lock);

	need_sched = z_unpend_all(&p->wait_q);
   35cb2:	f104 0014 	add.w	r0, r4, #20
   35cb6:	4428      	add	r0, r5
   35cb8:	f008 fc62 	bl	3e580 <z_unpend_all>

	if (need_sched != 0) {
   35cbc:	b128      	cbz	r0, 35cca <k_mem_pool_free_id+0x6e>
		z_reschedule(&lock, key);
   35cbe:	4631      	mov	r1, r6
	} else {
		k_spin_unlock(&lock, key);
	}
}
   35cc0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   35cc4:	480d      	ldr	r0, [pc, #52]	; (35cfc <k_mem_pool_free_id+0xa0>)
   35cc6:	f000 bdbd 	b.w	36844 <z_reschedule>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   35cca:	480c      	ldr	r0, [pc, #48]	; (35cfc <k_mem_pool_free_id+0xa0>)
   35ccc:	f001 ff46 	bl	37b5c <z_spin_unlock_valid>
   35cd0:	b968      	cbnz	r0, 35cee <k_mem_pool_free_id+0x92>
   35cd2:	235d      	movs	r3, #93	; 0x5d
   35cd4:	4a0a      	ldr	r2, [pc, #40]	; (35d00 <k_mem_pool_free_id+0xa4>)
   35cd6:	490e      	ldr	r1, [pc, #56]	; (35d10 <k_mem_pool_free_id+0xb4>)
   35cd8:	480b      	ldr	r0, [pc, #44]	; (35d08 <k_mem_pool_free_id+0xac>)
   35cda:	f006 fd27 	bl	3c72c <printk>
   35cde:	4907      	ldr	r1, [pc, #28]	; (35cfc <k_mem_pool_free_id+0xa0>)
   35ce0:	480c      	ldr	r0, [pc, #48]	; (35d14 <k_mem_pool_free_id+0xb8>)
   35ce2:	f006 fd23 	bl	3c72c <printk>
   35ce6:	215d      	movs	r1, #93	; 0x5d
   35ce8:	4805      	ldr	r0, [pc, #20]	; (35d00 <k_mem_pool_free_id+0xa4>)
   35cea:	f006 fd65 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   35cee:	f386 8811 	msr	BASEPRI, r6
   35cf2:	f3bf 8f6f 	isb	sy
}
   35cf6:	bd70      	pop	{r4, r5, r6, pc}
   35cf8:	20037a60 	.word	0x20037a60
   35cfc:	20029764 	.word	0x20029764
   35d00:	000405cb 	.word	0x000405cb
   35d04:	000405f1 	.word	0x000405f1
   35d08:	00040606 	.word	0x00040606
   35d0c:	00040623 	.word	0x00040623
   35d10:	00040665 	.word	0x00040665
   35d14:	0004067c 	.word	0x0004067c

00035d18 <k_malloc>:
		  CONFIG_HEAP_MEM_POOL_SIZE, 1, 4);
#define _HEAP_MEM_POOL (&_heap_mem_pool)

void *k_malloc(size_t size)
{
	return k_mem_pool_malloc(_HEAP_MEM_POOL, size);
   35d18:	4601      	mov	r1, r0
   35d1a:	4801      	ldr	r0, [pc, #4]	; (35d20 <k_malloc+0x8>)
   35d1c:	f008 bbb4 	b.w	3e488 <k_mem_pool_malloc>
   35d20:	20037a60 	.word	0x20037a60

00035d24 <z_thread_malloc>:
#else
#define _HEAP_MEM_POOL	NULL
#endif

void *z_thread_malloc(size_t size)
{
   35d24:	b510      	push	{r4, lr}
   35d26:	4604      	mov	r4, r0
	void *ret;
	struct k_mem_pool *pool;

	if (k_is_in_isr()) {
   35d28:	f008 fc50 	bl	3e5cc <k_is_in_isr>
   35d2c:	b948      	cbnz	r0, 35d42 <z_thread_malloc+0x1e>
		pool = _HEAP_MEM_POOL;
	} else {
		pool = _current->resource_pool;
   35d2e:	4b06      	ldr	r3, [pc, #24]	; (35d48 <z_thread_malloc+0x24>)
   35d30:	689b      	ldr	r3, [r3, #8]
   35d32:	6e1b      	ldr	r3, [r3, #96]	; 0x60
	}

	if (pool) {
   35d34:	b13b      	cbz	r3, 35d46 <z_thread_malloc+0x22>
		ret = k_mem_pool_malloc(pool, size);
   35d36:	4621      	mov	r1, r4
	} else {
		ret = NULL;
	}

	return ret;
}
   35d38:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ret = k_mem_pool_malloc(pool, size);
   35d3c:	4618      	mov	r0, r3
   35d3e:	f008 bba3 	b.w	3e488 <k_mem_pool_malloc>
		pool = _HEAP_MEM_POOL;
   35d42:	4b02      	ldr	r3, [pc, #8]	; (35d4c <z_thread_malloc+0x28>)
   35d44:	e7f7      	b.n	35d36 <z_thread_malloc+0x12>
}
   35d46:	bd10      	pop	{r4, pc}
   35d48:	2002976c 	.word	0x2002976c
   35d4c:	20037a60 	.word	0x20037a60

00035d50 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, void *data, s32_t timeout)
{
   35d50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   35d54:	4604      	mov	r4, r0
   35d56:	4688      	mov	r8, r1
   35d58:	4616      	mov	r6, r2
   35d5a:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr() || timeout == K_NO_WAIT, "");
   35d5e:	b16b      	cbz	r3, 35d7c <z_impl_k_msgq_put+0x2c>
   35d60:	b162      	cbz	r2, 35d7c <z_impl_k_msgq_put+0x2c>
   35d62:	4941      	ldr	r1, [pc, #260]	; (35e68 <z_impl_k_msgq_put+0x118>)
   35d64:	2376      	movs	r3, #118	; 0x76
   35d66:	4a41      	ldr	r2, [pc, #260]	; (35e6c <z_impl_k_msgq_put+0x11c>)
   35d68:	4841      	ldr	r0, [pc, #260]	; (35e70 <z_impl_k_msgq_put+0x120>)
   35d6a:	f006 fcdf 	bl	3c72c <printk>
   35d6e:	4841      	ldr	r0, [pc, #260]	; (35e74 <z_impl_k_msgq_put+0x124>)
   35d70:	f006 fcdc 	bl	3c72c <printk>
   35d74:	2176      	movs	r1, #118	; 0x76
   35d76:	483d      	ldr	r0, [pc, #244]	; (35e6c <z_impl_k_msgq_put+0x11c>)
   35d78:	f006 fd1e 	bl	3c7b8 <assert_post_action>

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
   35d7c:	f104 0508 	add.w	r5, r4, #8
	__asm__ volatile(
   35d80:	f04f 0320 	mov.w	r3, #32
   35d84:	f3ef 8711 	mrs	r7, BASEPRI
   35d88:	f383 8811 	msr	BASEPRI, r3
   35d8c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   35d90:	4628      	mov	r0, r5
   35d92:	f001 fed5 	bl	37b40 <z_spin_lock_valid>
   35d96:	b968      	cbnz	r0, 35db4 <z_impl_k_msgq_put+0x64>
   35d98:	234a      	movs	r3, #74	; 0x4a
   35d9a:	4a37      	ldr	r2, [pc, #220]	; (35e78 <z_impl_k_msgq_put+0x128>)
   35d9c:	4937      	ldr	r1, [pc, #220]	; (35e7c <z_impl_k_msgq_put+0x12c>)
   35d9e:	4834      	ldr	r0, [pc, #208]	; (35e70 <z_impl_k_msgq_put+0x120>)
   35da0:	f006 fcc4 	bl	3c72c <printk>
   35da4:	4629      	mov	r1, r5
   35da6:	4836      	ldr	r0, [pc, #216]	; (35e80 <z_impl_k_msgq_put+0x130>)
   35da8:	f006 fcc0 	bl	3c72c <printk>
   35dac:	214a      	movs	r1, #74	; 0x4a
   35dae:	4832      	ldr	r0, [pc, #200]	; (35e78 <z_impl_k_msgq_put+0x128>)
   35db0:	f006 fd02 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   35db4:	4628      	mov	r0, r5
   35db6:	f001 fee1 	bl	37b7c <z_spin_lock_set_owner>

	if (msgq->used_msgs < msgq->max_msgs) {
   35dba:	6a62      	ldr	r2, [r4, #36]	; 0x24
   35dbc:	6923      	ldr	r3, [r4, #16]
   35dbe:	429a      	cmp	r2, r3
   35dc0:	d242      	bcs.n	35e48 <z_impl_k_msgq_put+0xf8>
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   35dc2:	4620      	mov	r0, r4
   35dc4:	f001 fb9e 	bl	37504 <z_unpend_first_thread>
		if (pending_thread != NULL) {
   35dc8:	68e2      	ldr	r2, [r4, #12]
   35dca:	4606      	mov	r6, r0
   35dcc:	4641      	mov	r1, r8
   35dce:	b1a0      	cbz	r0, 35dfa <z_impl_k_msgq_put+0xaa>
   35dd0:	6940      	ldr	r0, [r0, #20]
   35dd2:	f008 fd3b 	bl	3e84c <memcpy>
   35dd6:	2300      	movs	r3, #0
   35dd8:	66b3      	str	r3, [r6, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   35dda:	7b73      	ldrb	r3, [r6, #13]
   35ddc:	06db      	lsls	r3, r3, #27
   35dde:	d104      	bne.n	35dea <z_impl_k_msgq_put+0x9a>
	if (z_is_thread_ready(thread)) {
   35de0:	69b3      	ldr	r3, [r6, #24]
   35de2:	b913      	cbnz	r3, 35dea <z_impl_k_msgq_put+0x9a>
		z_add_thread_to_ready_q(thread);
   35de4:	4630      	mov	r0, r6
   35de6:	f000 ff17 	bl	36c18 <z_add_thread_to_ready_q>
			(void)memcpy(pending_thread->base.swap_data, data,
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
   35dea:	4639      	mov	r1, r7
   35dec:	4628      	mov	r0, r5
   35dee:	f000 fd29 	bl	36844 <z_reschedule>
			return 0;
   35df2:	2400      	movs	r4, #0
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   35df4:	4620      	mov	r0, r4
   35df6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   35dfa:	6a20      	ldr	r0, [r4, #32]
   35dfc:	f008 fd26 	bl	3e84c <memcpy>
			msgq->write_ptr += msgq->msg_size;
   35e00:	6a23      	ldr	r3, [r4, #32]
   35e02:	68e2      	ldr	r2, [r4, #12]
   35e04:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   35e06:	69a2      	ldr	r2, [r4, #24]
			msgq->write_ptr += msgq->msg_size;
   35e08:	6223      	str	r3, [r4, #32]
			if (msgq->write_ptr == msgq->buffer_end) {
   35e0a:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   35e0c:	bf04      	itt	eq
   35e0e:	6963      	ldreq	r3, [r4, #20]
   35e10:	6223      	streq	r3, [r4, #32]
			msgq->used_msgs++;
   35e12:	6a63      	ldr	r3, [r4, #36]	; 0x24
   35e14:	3301      	adds	r3, #1
   35e16:	6263      	str	r3, [r4, #36]	; 0x24
		result = 0;
   35e18:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   35e1a:	4628      	mov	r0, r5
   35e1c:	f001 fe9e 	bl	37b5c <z_spin_unlock_valid>
   35e20:	b968      	cbnz	r0, 35e3e <z_impl_k_msgq_put+0xee>
   35e22:	235d      	movs	r3, #93	; 0x5d
   35e24:	4a14      	ldr	r2, [pc, #80]	; (35e78 <z_impl_k_msgq_put+0x128>)
   35e26:	4917      	ldr	r1, [pc, #92]	; (35e84 <z_impl_k_msgq_put+0x134>)
   35e28:	4811      	ldr	r0, [pc, #68]	; (35e70 <z_impl_k_msgq_put+0x120>)
   35e2a:	f006 fc7f 	bl	3c72c <printk>
   35e2e:	4629      	mov	r1, r5
   35e30:	4815      	ldr	r0, [pc, #84]	; (35e88 <z_impl_k_msgq_put+0x138>)
   35e32:	f006 fc7b 	bl	3c72c <printk>
   35e36:	215d      	movs	r1, #93	; 0x5d
   35e38:	480f      	ldr	r0, [pc, #60]	; (35e78 <z_impl_k_msgq_put+0x128>)
   35e3a:	f006 fcbd 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   35e3e:	f387 8811 	msr	BASEPRI, r7
   35e42:	f3bf 8f6f 	isb	sy
	return result;
   35e46:	e7d5      	b.n	35df4 <z_impl_k_msgq_put+0xa4>
	} else if (timeout == K_NO_WAIT) {
   35e48:	b15e      	cbz	r6, 35e62 <z_impl_k_msgq_put+0x112>
		_current->base.swap_data = data;
   35e4a:	4b10      	ldr	r3, [pc, #64]	; (35e8c <z_impl_k_msgq_put+0x13c>)
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   35e4c:	4622      	mov	r2, r4
		_current->base.swap_data = data;
   35e4e:	689b      	ldr	r3, [r3, #8]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   35e50:	4639      	mov	r1, r7
		_current->base.swap_data = data;
   35e52:	f8c3 8014 	str.w	r8, [r3, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   35e56:	4628      	mov	r0, r5
   35e58:	4633      	mov	r3, r6
}
   35e5a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   35e5e:	f001 ba95 	b.w	3738c <z_pend_curr>
		result = -ENOMSG;
   35e62:	f06f 0422 	mvn.w	r4, #34	; 0x22
   35e66:	e7d8      	b.n	35e1a <z_impl_k_msgq_put+0xca>
   35e68:	00043d85 	.word	0x00043d85
   35e6c:	00043d63 	.word	0x00043d63
   35e70:	00040606 	.word	0x00040606
   35e74:	00042742 	.word	0x00042742
   35e78:	000405cb 	.word	0x000405cb
   35e7c:	000405f1 	.word	0x000405f1
   35e80:	00040623 	.word	0x00040623
   35e84:	00040665 	.word	0x00040665
   35e88:	0004067c 	.word	0x0004067c
   35e8c:	2002976c 	.word	0x2002976c

00035e90 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, s32_t timeout)
{
   35e90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   35e94:	4604      	mov	r4, r0
   35e96:	4688      	mov	r8, r1
   35e98:	4615      	mov	r5, r2
   35e9a:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr() || timeout == K_NO_WAIT, "");
   35e9e:	b16b      	cbz	r3, 35ebc <z_impl_k_msgq_get+0x2c>
   35ea0:	b162      	cbz	r2, 35ebc <z_impl_k_msgq_get+0x2c>
   35ea2:	4947      	ldr	r1, [pc, #284]	; (35fc0 <z_impl_k_msgq_get+0x130>)
   35ea4:	23c1      	movs	r3, #193	; 0xc1
   35ea6:	4a47      	ldr	r2, [pc, #284]	; (35fc4 <z_impl_k_msgq_get+0x134>)
   35ea8:	4847      	ldr	r0, [pc, #284]	; (35fc8 <z_impl_k_msgq_get+0x138>)
   35eaa:	f006 fc3f 	bl	3c72c <printk>
   35eae:	4847      	ldr	r0, [pc, #284]	; (35fcc <z_impl_k_msgq_get+0x13c>)
   35eb0:	f006 fc3c 	bl	3c72c <printk>
   35eb4:	21c1      	movs	r1, #193	; 0xc1
   35eb6:	4843      	ldr	r0, [pc, #268]	; (35fc4 <z_impl_k_msgq_get+0x134>)
   35eb8:	f006 fc7e 	bl	3c7b8 <assert_post_action>

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
   35ebc:	f104 0608 	add.w	r6, r4, #8
	__asm__ volatile(
   35ec0:	f04f 0320 	mov.w	r3, #32
   35ec4:	f3ef 8711 	mrs	r7, BASEPRI
   35ec8:	f383 8811 	msr	BASEPRI, r3
   35ecc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   35ed0:	4630      	mov	r0, r6
   35ed2:	f001 fe35 	bl	37b40 <z_spin_lock_valid>
   35ed6:	b968      	cbnz	r0, 35ef4 <z_impl_k_msgq_get+0x64>
   35ed8:	234a      	movs	r3, #74	; 0x4a
   35eda:	4a3d      	ldr	r2, [pc, #244]	; (35fd0 <z_impl_k_msgq_get+0x140>)
   35edc:	493d      	ldr	r1, [pc, #244]	; (35fd4 <z_impl_k_msgq_get+0x144>)
   35ede:	483a      	ldr	r0, [pc, #232]	; (35fc8 <z_impl_k_msgq_get+0x138>)
   35ee0:	f006 fc24 	bl	3c72c <printk>
   35ee4:	4631      	mov	r1, r6
   35ee6:	483c      	ldr	r0, [pc, #240]	; (35fd8 <z_impl_k_msgq_get+0x148>)
   35ee8:	f006 fc20 	bl	3c72c <printk>
   35eec:	214a      	movs	r1, #74	; 0x4a
   35eee:	4838      	ldr	r0, [pc, #224]	; (35fd0 <z_impl_k_msgq_get+0x140>)
   35ef0:	f006 fc62 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   35ef4:	4630      	mov	r0, r6
   35ef6:	f001 fe41 	bl	37b7c <z_spin_lock_set_owner>

	if (msgq->used_msgs > 0) {
   35efa:	6a63      	ldr	r3, [r4, #36]	; 0x24
   35efc:	2b00      	cmp	r3, #0
   35efe:	d039      	beq.n	35f74 <z_impl_k_msgq_get+0xe4>
   35f00:	68e2      	ldr	r2, [r4, #12]
   35f02:	69e1      	ldr	r1, [r4, #28]
   35f04:	4640      	mov	r0, r8
   35f06:	f008 fca1 	bl	3e84c <memcpy>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
   35f0a:	69e3      	ldr	r3, [r4, #28]
   35f0c:	68e2      	ldr	r2, [r4, #12]
			msgq->read_ptr = msgq->buffer_start;
		}
		msgq->used_msgs--;

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   35f0e:	4620      	mov	r0, r4
		msgq->read_ptr += msgq->msg_size;
   35f10:	4413      	add	r3, r2
		if (msgq->read_ptr == msgq->buffer_end) {
   35f12:	69a2      	ldr	r2, [r4, #24]
		msgq->read_ptr += msgq->msg_size;
   35f14:	61e3      	str	r3, [r4, #28]
		if (msgq->read_ptr == msgq->buffer_end) {
   35f16:	4293      	cmp	r3, r2
			msgq->read_ptr = msgq->buffer_start;
   35f18:	bf04      	itt	eq
   35f1a:	6963      	ldreq	r3, [r4, #20]
   35f1c:	61e3      	streq	r3, [r4, #28]
		msgq->used_msgs--;
   35f1e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   35f20:	3b01      	subs	r3, #1
   35f22:	6263      	str	r3, [r4, #36]	; 0x24
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   35f24:	f001 faee 	bl	37504 <z_unpend_first_thread>
		if (pending_thread != NULL) {
   35f28:	4605      	mov	r5, r0
   35f2a:	2800      	cmp	r0, #0
   35f2c:	d031      	beq.n	35f92 <z_impl_k_msgq_get+0x102>
   35f2e:	68e2      	ldr	r2, [r4, #12]
   35f30:	6941      	ldr	r1, [r0, #20]
   35f32:	6a20      	ldr	r0, [r4, #32]
   35f34:	f008 fc8a 	bl	3e84c <memcpy>
			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
   35f38:	6a23      	ldr	r3, [r4, #32]
   35f3a:	68e2      	ldr	r2, [r4, #12]
   35f3c:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   35f3e:	69a2      	ldr	r2, [r4, #24]
			msgq->write_ptr += msgq->msg_size;
   35f40:	6223      	str	r3, [r4, #32]
			if (msgq->write_ptr == msgq->buffer_end) {
   35f42:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   35f44:	bf04      	itt	eq
   35f46:	6963      	ldreq	r3, [r4, #20]
   35f48:	6223      	streq	r3, [r4, #32]
			}
			msgq->used_msgs++;
   35f4a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   35f4c:	3301      	adds	r3, #1
   35f4e:	6263      	str	r3, [r4, #36]	; 0x24
   35f50:	2300      	movs	r3, #0
   35f52:	66ab      	str	r3, [r5, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   35f54:	7b6b      	ldrb	r3, [r5, #13]
   35f56:	06db      	lsls	r3, r3, #27
   35f58:	d104      	bne.n	35f64 <z_impl_k_msgq_get+0xd4>
	if (z_is_thread_ready(thread)) {
   35f5a:	69ab      	ldr	r3, [r5, #24]
   35f5c:	b913      	cbnz	r3, 35f64 <z_impl_k_msgq_get+0xd4>
		z_add_thread_to_ready_q(thread);
   35f5e:	4628      	mov	r0, r5
   35f60:	f000 fe5a 	bl	36c18 <z_add_thread_to_ready_q>

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
   35f64:	4639      	mov	r1, r7
   35f66:	4630      	mov	r0, r6
   35f68:	f000 fc6c 	bl	36844 <z_reschedule>
			return 0;
   35f6c:	2500      	movs	r5, #0
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   35f6e:	4628      	mov	r0, r5
   35f70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (timeout == K_NO_WAIT) {
   35f74:	b15d      	cbz	r5, 35f8e <z_impl_k_msgq_get+0xfe>
		_current->base.swap_data = data;
   35f76:	4b19      	ldr	r3, [pc, #100]	; (35fdc <z_impl_k_msgq_get+0x14c>)
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   35f78:	4622      	mov	r2, r4
		_current->base.swap_data = data;
   35f7a:	689b      	ldr	r3, [r3, #8]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   35f7c:	4639      	mov	r1, r7
		_current->base.swap_data = data;
   35f7e:	f8c3 8014 	str.w	r8, [r3, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   35f82:	4630      	mov	r0, r6
   35f84:	462b      	mov	r3, r5
}
   35f86:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   35f8a:	f001 b9ff 	b.w	3738c <z_pend_curr>
		result = -ENOMSG;
   35f8e:	f06f 0522 	mvn.w	r5, #34	; 0x22
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   35f92:	4630      	mov	r0, r6
   35f94:	f001 fde2 	bl	37b5c <z_spin_unlock_valid>
   35f98:	b968      	cbnz	r0, 35fb6 <z_impl_k_msgq_get+0x126>
   35f9a:	235d      	movs	r3, #93	; 0x5d
   35f9c:	4a0c      	ldr	r2, [pc, #48]	; (35fd0 <z_impl_k_msgq_get+0x140>)
   35f9e:	4910      	ldr	r1, [pc, #64]	; (35fe0 <z_impl_k_msgq_get+0x150>)
   35fa0:	4809      	ldr	r0, [pc, #36]	; (35fc8 <z_impl_k_msgq_get+0x138>)
   35fa2:	f006 fbc3 	bl	3c72c <printk>
   35fa6:	4631      	mov	r1, r6
   35fa8:	480e      	ldr	r0, [pc, #56]	; (35fe4 <z_impl_k_msgq_get+0x154>)
   35faa:	f006 fbbf 	bl	3c72c <printk>
   35fae:	215d      	movs	r1, #93	; 0x5d
   35fb0:	4807      	ldr	r0, [pc, #28]	; (35fd0 <z_impl_k_msgq_get+0x140>)
   35fb2:	f006 fc01 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   35fb6:	f387 8811 	msr	BASEPRI, r7
   35fba:	f3bf 8f6f 	isb	sy
	return result;
   35fbe:	e7d6      	b.n	35f6e <z_impl_k_msgq_get+0xde>
   35fc0:	00043d85 	.word	0x00043d85
   35fc4:	00043d63 	.word	0x00043d63
   35fc8:	00040606 	.word	0x00040606
   35fcc:	00042742 	.word	0x00042742
   35fd0:	000405cb 	.word	0x000405cb
   35fd4:	000405f1 	.word	0x000405f1
   35fd8:	00040623 	.word	0x00040623
   35fdc:	2002976c 	.word	0x2002976c
   35fe0:	00040665 	.word	0x00040665
   35fe4:	0004067c 	.word	0x0004067c

00035fe8 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, s32_t timeout)
{
   35fe8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   35fea:	4604      	mov	r4, r0
   35fec:	460e      	mov	r6, r1
	__asm__ volatile(
   35fee:	f04f 0320 	mov.w	r3, #32
   35ff2:	f3ef 8511 	mrs	r5, BASEPRI
   35ff6:	f383 8811 	msr	BASEPRI, r3
   35ffa:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   35ffe:	4861      	ldr	r0, [pc, #388]	; (36184 <z_impl_k_mutex_lock+0x19c>)
   36000:	f001 fd9e 	bl	37b40 <z_spin_lock_valid>
   36004:	b968      	cbnz	r0, 36022 <z_impl_k_mutex_lock+0x3a>
   36006:	234a      	movs	r3, #74	; 0x4a
   36008:	4a5f      	ldr	r2, [pc, #380]	; (36188 <z_impl_k_mutex_lock+0x1a0>)
   3600a:	4960      	ldr	r1, [pc, #384]	; (3618c <z_impl_k_mutex_lock+0x1a4>)
   3600c:	4860      	ldr	r0, [pc, #384]	; (36190 <z_impl_k_mutex_lock+0x1a8>)
   3600e:	f006 fb8d 	bl	3c72c <printk>
   36012:	495c      	ldr	r1, [pc, #368]	; (36184 <z_impl_k_mutex_lock+0x19c>)
   36014:	485f      	ldr	r0, [pc, #380]	; (36194 <z_impl_k_mutex_lock+0x1ac>)
   36016:	f006 fb89 	bl	3c72c <printk>
   3601a:	214a      	movs	r1, #74	; 0x4a
   3601c:	485a      	ldr	r0, [pc, #360]	; (36188 <z_impl_k_mutex_lock+0x1a0>)
   3601e:	f006 fbcb 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   36022:	4858      	ldr	r0, [pc, #352]	; (36184 <z_impl_k_mutex_lock+0x19c>)
   36024:	f001 fdaa 	bl	37b7c <z_spin_lock_set_owner>
	bool resched = false;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   36028:	68e3      	ldr	r3, [r4, #12]
   3602a:	4a5b      	ldr	r2, [pc, #364]	; (36198 <z_impl_k_mutex_lock+0x1b0>)
   3602c:	b1f3      	cbz	r3, 3606c <z_impl_k_mutex_lock+0x84>
   3602e:	68a0      	ldr	r0, [r4, #8]
   36030:	6891      	ldr	r1, [r2, #8]
   36032:	4288      	cmp	r0, r1
   36034:	d03a      	beq.n	360ac <z_impl_k_mutex_lock+0xc4>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(timeout == (s32_t)K_NO_WAIT)) {
   36036:	2e00      	cmp	r6, #0
   36038:	d13a      	bne.n	360b0 <z_impl_k_mutex_lock+0xc8>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   3603a:	4852      	ldr	r0, [pc, #328]	; (36184 <z_impl_k_mutex_lock+0x19c>)
   3603c:	f001 fd8e 	bl	37b5c <z_spin_unlock_valid>
   36040:	b968      	cbnz	r0, 3605e <z_impl_k_mutex_lock+0x76>
   36042:	235d      	movs	r3, #93	; 0x5d
   36044:	4a50      	ldr	r2, [pc, #320]	; (36188 <z_impl_k_mutex_lock+0x1a0>)
   36046:	4955      	ldr	r1, [pc, #340]	; (3619c <z_impl_k_mutex_lock+0x1b4>)
   36048:	4851      	ldr	r0, [pc, #324]	; (36190 <z_impl_k_mutex_lock+0x1a8>)
   3604a:	f006 fb6f 	bl	3c72c <printk>
   3604e:	494d      	ldr	r1, [pc, #308]	; (36184 <z_impl_k_mutex_lock+0x19c>)
   36050:	4853      	ldr	r0, [pc, #332]	; (361a0 <z_impl_k_mutex_lock+0x1b8>)
   36052:	f006 fb6b 	bl	3c72c <printk>
   36056:	215d      	movs	r1, #93	; 0x5d
   36058:	484b      	ldr	r0, [pc, #300]	; (36188 <z_impl_k_mutex_lock+0x1a0>)
   3605a:	f006 fbad 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   3605e:	f385 8811 	msr	BASEPRI, r5
   36062:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
   36066:	f06f 000f 	mvn.w	r0, #15
   3606a:	e01e      	b.n	360aa <z_impl_k_mutex_lock+0xc2>
					_current->base.prio :
   3606c:	6891      	ldr	r1, [r2, #8]
   3606e:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
   36072:	3301      	adds	r3, #1
   36074:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   36076:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   36078:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
   3607a:	60a3      	str	r3, [r4, #8]
   3607c:	4841      	ldr	r0, [pc, #260]	; (36184 <z_impl_k_mutex_lock+0x19c>)
   3607e:	f001 fd6d 	bl	37b5c <z_spin_unlock_valid>
   36082:	b968      	cbnz	r0, 360a0 <z_impl_k_mutex_lock+0xb8>
   36084:	235d      	movs	r3, #93	; 0x5d
   36086:	4a40      	ldr	r2, [pc, #256]	; (36188 <z_impl_k_mutex_lock+0x1a0>)
   36088:	4944      	ldr	r1, [pc, #272]	; (3619c <z_impl_k_mutex_lock+0x1b4>)
   3608a:	4841      	ldr	r0, [pc, #260]	; (36190 <z_impl_k_mutex_lock+0x1a8>)
   3608c:	f006 fb4e 	bl	3c72c <printk>
   36090:	493c      	ldr	r1, [pc, #240]	; (36184 <z_impl_k_mutex_lock+0x19c>)
   36092:	4843      	ldr	r0, [pc, #268]	; (361a0 <z_impl_k_mutex_lock+0x1b8>)
   36094:	f006 fb4a 	bl	3c72c <printk>
   36098:	215d      	movs	r1, #93	; 0x5d
   3609a:	483b      	ldr	r0, [pc, #236]	; (36188 <z_impl_k_mutex_lock+0x1a0>)
   3609c:	f006 fb8c 	bl	3c7b8 <assert_post_action>
   360a0:	f385 8811 	msr	BASEPRI, r5
   360a4:	f3bf 8f6f 	isb	sy
		return 0;
   360a8:	2000      	movs	r0, #0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
   360aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					_current->base.prio :
   360ac:	6921      	ldr	r1, [r4, #16]
   360ae:	e7e0      	b.n	36072 <z_impl_k_mutex_lock+0x8a>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   360b0:	f990 300e 	ldrsb.w	r3, [r0, #14]
   360b4:	f991 100e 	ldrsb.w	r1, [r1, #14]
   360b8:	4299      	cmp	r1, r3
   360ba:	bfa8      	it	ge
   360bc:	4619      	movge	r1, r3
   360be:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   360c2:	4299      	cmp	r1, r3
   360c4:	da40      	bge.n	36148 <z_impl_k_mutex_lock+0x160>
		return z_set_prio(mutex->owner, new_prio);
   360c6:	f001 f98f 	bl	373e8 <z_set_prio>
   360ca:	4607      	mov	r7, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   360cc:	4633      	mov	r3, r6
   360ce:	4622      	mov	r2, r4
   360d0:	4629      	mov	r1, r5
   360d2:	482c      	ldr	r0, [pc, #176]	; (36184 <z_impl_k_mutex_lock+0x19c>)
   360d4:	f001 f95a 	bl	3738c <z_pend_curr>
	if (got_mutex == 0) {
   360d8:	2800      	cmp	r0, #0
   360da:	d0e6      	beq.n	360aa <z_impl_k_mutex_lock+0xc2>
	__asm__ volatile(
   360dc:	f04f 0320 	mov.w	r3, #32
   360e0:	f3ef 8511 	mrs	r5, BASEPRI
   360e4:	f383 8811 	msr	BASEPRI, r3
   360e8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   360ec:	4825      	ldr	r0, [pc, #148]	; (36184 <z_impl_k_mutex_lock+0x19c>)
   360ee:	f001 fd27 	bl	37b40 <z_spin_lock_valid>
   360f2:	b968      	cbnz	r0, 36110 <z_impl_k_mutex_lock+0x128>
   360f4:	234a      	movs	r3, #74	; 0x4a
   360f6:	4a24      	ldr	r2, [pc, #144]	; (36188 <z_impl_k_mutex_lock+0x1a0>)
   360f8:	4924      	ldr	r1, [pc, #144]	; (3618c <z_impl_k_mutex_lock+0x1a4>)
   360fa:	4825      	ldr	r0, [pc, #148]	; (36190 <z_impl_k_mutex_lock+0x1a8>)
   360fc:	f006 fb16 	bl	3c72c <printk>
   36100:	4920      	ldr	r1, [pc, #128]	; (36184 <z_impl_k_mutex_lock+0x19c>)
   36102:	4824      	ldr	r0, [pc, #144]	; (36194 <z_impl_k_mutex_lock+0x1ac>)
   36104:	f006 fb12 	bl	3c72c <printk>
   36108:	214a      	movs	r1, #74	; 0x4a
   3610a:	481f      	ldr	r0, [pc, #124]	; (36188 <z_impl_k_mutex_lock+0x1a0>)
   3610c:	f006 fb54 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   36110:	481c      	ldr	r0, [pc, #112]	; (36184 <z_impl_k_mutex_lock+0x19c>)
   36112:	f001 fd33 	bl	37b7c <z_spin_lock_set_owner>
	return list->head == list;
   36116:	6823      	ldr	r3, [r4, #0]
   36118:	6921      	ldr	r1, [r4, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   3611a:	429c      	cmp	r4, r3
   3611c:	d007      	beq.n	3612e <z_impl_k_mutex_lock+0x146>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   3611e:	b133      	cbz	r3, 3612e <z_impl_k_mutex_lock+0x146>
   36120:	f993 300e 	ldrsb.w	r3, [r3, #14]
   36124:	4299      	cmp	r1, r3
   36126:	bfa8      	it	ge
   36128:	4619      	movge	r1, r3
   3612a:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   3612e:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   36130:	f990 300e 	ldrsb.w	r3, [r0, #14]
   36134:	4299      	cmp	r1, r3
   36136:	d109      	bne.n	3614c <z_impl_k_mutex_lock+0x164>
	if (resched) {
   36138:	b16f      	cbz	r7, 36156 <z_impl_k_mutex_lock+0x16e>
		z_reschedule(&lock, key);
   3613a:	4629      	mov	r1, r5
   3613c:	4811      	ldr	r0, [pc, #68]	; (36184 <z_impl_k_mutex_lock+0x19c>)
   3613e:	f000 fb81 	bl	36844 <z_reschedule>
	return -EAGAIN;
   36142:	f06f 000a 	mvn.w	r0, #10
   36146:	e7b0      	b.n	360aa <z_impl_k_mutex_lock+0xc2>
	bool resched = false;
   36148:	2700      	movs	r7, #0
   3614a:	e7bf      	b.n	360cc <z_impl_k_mutex_lock+0xe4>
		return z_set_prio(mutex->owner, new_prio);
   3614c:	f001 f94c 	bl	373e8 <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   36150:	2800      	cmp	r0, #0
   36152:	d1f2      	bne.n	3613a <z_impl_k_mutex_lock+0x152>
   36154:	e7f0      	b.n	36138 <z_impl_k_mutex_lock+0x150>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   36156:	480b      	ldr	r0, [pc, #44]	; (36184 <z_impl_k_mutex_lock+0x19c>)
   36158:	f001 fd00 	bl	37b5c <z_spin_unlock_valid>
   3615c:	b968      	cbnz	r0, 3617a <z_impl_k_mutex_lock+0x192>
   3615e:	235d      	movs	r3, #93	; 0x5d
   36160:	4a09      	ldr	r2, [pc, #36]	; (36188 <z_impl_k_mutex_lock+0x1a0>)
   36162:	490e      	ldr	r1, [pc, #56]	; (3619c <z_impl_k_mutex_lock+0x1b4>)
   36164:	480a      	ldr	r0, [pc, #40]	; (36190 <z_impl_k_mutex_lock+0x1a8>)
   36166:	f006 fae1 	bl	3c72c <printk>
   3616a:	4906      	ldr	r1, [pc, #24]	; (36184 <z_impl_k_mutex_lock+0x19c>)
   3616c:	480c      	ldr	r0, [pc, #48]	; (361a0 <z_impl_k_mutex_lock+0x1b8>)
   3616e:	f006 fadd 	bl	3c72c <printk>
   36172:	215d      	movs	r1, #93	; 0x5d
   36174:	4804      	ldr	r0, [pc, #16]	; (36188 <z_impl_k_mutex_lock+0x1a0>)
   36176:	f006 fb1f 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   3617a:	f385 8811 	msr	BASEPRI, r5
   3617e:	f3bf 8f6f 	isb	sy
   36182:	e7de      	b.n	36142 <z_impl_k_mutex_lock+0x15a>
   36184:	20029768 	.word	0x20029768
   36188:	000405cb 	.word	0x000405cb
   3618c:	000405f1 	.word	0x000405f1
   36190:	00040606 	.word	0x00040606
   36194:	00040623 	.word	0x00040623
   36198:	2002976c 	.word	0x2002976c
   3619c:	00040665 	.word	0x00040665
   361a0:	0004067c 	.word	0x0004067c

000361a4 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   361a4:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *new_owner;

	CHECKIF(mutex->owner == NULL) {
   361a6:	6883      	ldr	r3, [r0, #8]
{
   361a8:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   361aa:	2b00      	cmp	r3, #0
   361ac:	f000 8096 	beq.w	362dc <z_impl_k_mutex_unlock+0x138>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   361b0:	4d4d      	ldr	r5, [pc, #308]	; (362e8 <z_impl_k_mutex_unlock+0x144>)
   361b2:	68aa      	ldr	r2, [r5, #8]
   361b4:	4293      	cmp	r3, r2
   361b6:	f040 8094 	bne.w	362e2 <z_impl_k_mutex_unlock+0x13e>
	 * Attempt to unlock a mutex which is unlocked. mutex->lock_count
	 * cannot be zero if the current thread is equal to mutex->owner,
	 * therefore no underflow check is required. Use assert to catch
	 * undefined behavior.
	 */
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
   361ba:	68c3      	ldr	r3, [r0, #12]
   361bc:	b94b      	cbnz	r3, 361d2 <z_impl_k_mutex_unlock+0x2e>
   361be:	494b      	ldr	r1, [pc, #300]	; (362ec <z_impl_k_mutex_unlock+0x148>)
   361c0:	484b      	ldr	r0, [pc, #300]	; (362f0 <z_impl_k_mutex_unlock+0x14c>)
   361c2:	23e5      	movs	r3, #229	; 0xe5
   361c4:	4a4b      	ldr	r2, [pc, #300]	; (362f4 <z_impl_k_mutex_unlock+0x150>)
   361c6:	f006 fab1 	bl	3c72c <printk>
   361ca:	21e5      	movs	r1, #229	; 0xe5
   361cc:	4849      	ldr	r0, [pc, #292]	; (362f4 <z_impl_k_mutex_unlock+0x150>)
   361ce:	f006 faf3 	bl	3c7b8 <assert_post_action>
   361d2:	f3ef 8305 	mrs	r3, IPSR
}

static inline void z_sched_lock(void)
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
   361d6:	b173      	cbz	r3, 361f6 <z_impl_k_mutex_unlock+0x52>
   361d8:	4947      	ldr	r1, [pc, #284]	; (362f8 <z_impl_k_mutex_unlock+0x154>)
   361da:	f240 130d 	movw	r3, #269	; 0x10d
   361de:	4a47      	ldr	r2, [pc, #284]	; (362fc <z_impl_k_mutex_unlock+0x158>)
   361e0:	4843      	ldr	r0, [pc, #268]	; (362f0 <z_impl_k_mutex_unlock+0x14c>)
   361e2:	f006 faa3 	bl	3c72c <printk>
   361e6:	4846      	ldr	r0, [pc, #280]	; (36300 <z_impl_k_mutex_unlock+0x15c>)
   361e8:	f006 faa0 	bl	3c72c <printk>
   361ec:	f240 110d 	movw	r1, #269	; 0x10d
   361f0:	4842      	ldr	r0, [pc, #264]	; (362fc <z_impl_k_mutex_unlock+0x158>)
   361f2:	f006 fae1 	bl	3c7b8 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1, "");
   361f6:	68ab      	ldr	r3, [r5, #8]
   361f8:	7bdb      	ldrb	r3, [r3, #15]
   361fa:	2b01      	cmp	r3, #1
   361fc:	d10e      	bne.n	3621c <z_impl_k_mutex_unlock+0x78>
   361fe:	4941      	ldr	r1, [pc, #260]	; (36304 <z_impl_k_mutex_unlock+0x160>)
   36200:	f44f 7387 	mov.w	r3, #270	; 0x10e
   36204:	4a3d      	ldr	r2, [pc, #244]	; (362fc <z_impl_k_mutex_unlock+0x158>)
   36206:	483a      	ldr	r0, [pc, #232]	; (362f0 <z_impl_k_mutex_unlock+0x14c>)
   36208:	f006 fa90 	bl	3c72c <printk>
   3620c:	483c      	ldr	r0, [pc, #240]	; (36300 <z_impl_k_mutex_unlock+0x15c>)
   3620e:	f006 fa8d 	bl	3c72c <printk>
   36212:	f44f 7187 	mov.w	r1, #270	; 0x10e
   36216:	4839      	ldr	r0, [pc, #228]	; (362fc <z_impl_k_mutex_unlock+0x158>)
   36218:	f006 face 	bl	3c7b8 <assert_post_action>

	--_current->base.sched_locked;
   3621c:	68aa      	ldr	r2, [r5, #8]
   3621e:	7bd3      	ldrb	r3, [r2, #15]
   36220:	3b01      	subs	r3, #1
   36222:	73d3      	strb	r3, [r2, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count - 1U != 0U) {
   36224:	68e3      	ldr	r3, [r4, #12]
   36226:	2b01      	cmp	r3, #1
   36228:	d005      	beq.n	36236 <z_impl_k_mutex_unlock+0x92>
		mutex->lock_count--;
   3622a:	3b01      	subs	r3, #1
   3622c:	60e3      	str	r3, [r4, #12]
		k_spin_unlock(&lock, key);
	}


k_mutex_unlock_return:
	k_sched_unlock();
   3622e:	f000 fc77 	bl	36b20 <k_sched_unlock>
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);

	return 0;
   36232:	2000      	movs	r0, #0
}
   36234:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   36236:	f04f 0320 	mov.w	r3, #32
   3623a:	f3ef 8511 	mrs	r5, BASEPRI
   3623e:	f383 8811 	msr	BASEPRI, r3
   36242:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   36246:	4830      	ldr	r0, [pc, #192]	; (36308 <z_impl_k_mutex_unlock+0x164>)
   36248:	f001 fc7a 	bl	37b40 <z_spin_lock_valid>
   3624c:	b968      	cbnz	r0, 3626a <z_impl_k_mutex_unlock+0xc6>
   3624e:	234a      	movs	r3, #74	; 0x4a
   36250:	4a2e      	ldr	r2, [pc, #184]	; (3630c <z_impl_k_mutex_unlock+0x168>)
   36252:	492f      	ldr	r1, [pc, #188]	; (36310 <z_impl_k_mutex_unlock+0x16c>)
   36254:	4826      	ldr	r0, [pc, #152]	; (362f0 <z_impl_k_mutex_unlock+0x14c>)
   36256:	f006 fa69 	bl	3c72c <printk>
   3625a:	492b      	ldr	r1, [pc, #172]	; (36308 <z_impl_k_mutex_unlock+0x164>)
   3625c:	482d      	ldr	r0, [pc, #180]	; (36314 <z_impl_k_mutex_unlock+0x170>)
   3625e:	f006 fa65 	bl	3c72c <printk>
   36262:	214a      	movs	r1, #74	; 0x4a
   36264:	4829      	ldr	r0, [pc, #164]	; (3630c <z_impl_k_mutex_unlock+0x168>)
   36266:	f006 faa7 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   3626a:	4827      	ldr	r0, [pc, #156]	; (36308 <z_impl_k_mutex_unlock+0x164>)
   3626c:	f001 fc86 	bl	37b7c <z_spin_lock_set_owner>
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   36270:	68a0      	ldr	r0, [r4, #8]
   36272:	6921      	ldr	r1, [r4, #16]
	if (mutex->owner->base.prio != new_prio) {
   36274:	f990 300e 	ldrsb.w	r3, [r0, #14]
   36278:	4299      	cmp	r1, r3
   3627a:	d001      	beq.n	36280 <z_impl_k_mutex_unlock+0xdc>
		return z_set_prio(mutex->owner, new_prio);
   3627c:	f001 f8b4 	bl	373e8 <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   36280:	4620      	mov	r0, r4
   36282:	f001 f93f 	bl	37504 <z_unpend_first_thread>
	mutex->owner = new_owner;
   36286:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   36288:	b180      	cbz	r0, 362ac <z_impl_k_mutex_unlock+0x108>
		mutex->owner_orig_prio = new_owner->base.prio;
   3628a:	f990 200e 	ldrsb.w	r2, [r0, #14]
   3628e:	6122      	str	r2, [r4, #16]
   36290:	2200      	movs	r2, #0
   36292:	6682      	str	r2, [r0, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   36294:	7b42      	ldrb	r2, [r0, #13]
   36296:	06d2      	lsls	r2, r2, #27
   36298:	d103      	bne.n	362a2 <z_impl_k_mutex_unlock+0xfe>
	if (z_is_thread_ready(thread)) {
   3629a:	6983      	ldr	r3, [r0, #24]
   3629c:	b90b      	cbnz	r3, 362a2 <z_impl_k_mutex_unlock+0xfe>
		z_add_thread_to_ready_q(thread);
   3629e:	f000 fcbb 	bl	36c18 <z_add_thread_to_ready_q>
		z_reschedule(&lock, key);
   362a2:	4629      	mov	r1, r5
   362a4:	4818      	ldr	r0, [pc, #96]	; (36308 <z_impl_k_mutex_unlock+0x164>)
   362a6:	f000 facd 	bl	36844 <z_reschedule>
   362aa:	e7c0      	b.n	3622e <z_impl_k_mutex_unlock+0x8a>
		mutex->lock_count = 0U;
   362ac:	60e0      	str	r0, [r4, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   362ae:	4816      	ldr	r0, [pc, #88]	; (36308 <z_impl_k_mutex_unlock+0x164>)
   362b0:	f001 fc54 	bl	37b5c <z_spin_unlock_valid>
   362b4:	b968      	cbnz	r0, 362d2 <z_impl_k_mutex_unlock+0x12e>
   362b6:	235d      	movs	r3, #93	; 0x5d
   362b8:	4a14      	ldr	r2, [pc, #80]	; (3630c <z_impl_k_mutex_unlock+0x168>)
   362ba:	4917      	ldr	r1, [pc, #92]	; (36318 <z_impl_k_mutex_unlock+0x174>)
   362bc:	480c      	ldr	r0, [pc, #48]	; (362f0 <z_impl_k_mutex_unlock+0x14c>)
   362be:	f006 fa35 	bl	3c72c <printk>
   362c2:	4911      	ldr	r1, [pc, #68]	; (36308 <z_impl_k_mutex_unlock+0x164>)
   362c4:	4815      	ldr	r0, [pc, #84]	; (3631c <z_impl_k_mutex_unlock+0x178>)
   362c6:	f006 fa31 	bl	3c72c <printk>
   362ca:	215d      	movs	r1, #93	; 0x5d
   362cc:	480f      	ldr	r0, [pc, #60]	; (3630c <z_impl_k_mutex_unlock+0x168>)
   362ce:	f006 fa73 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   362d2:	f385 8811 	msr	BASEPRI, r5
   362d6:	f3bf 8f6f 	isb	sy
   362da:	e7a8      	b.n	3622e <z_impl_k_mutex_unlock+0x8a>
		return -EINVAL;
   362dc:	f06f 0015 	mvn.w	r0, #21
   362e0:	e7a8      	b.n	36234 <z_impl_k_mutex_unlock+0x90>
		return -EPERM;
   362e2:	f04f 30ff 	mov.w	r0, #4294967295
   362e6:	e7a5      	b.n	36234 <z_impl_k_mutex_unlock+0x90>
   362e8:	2002976c 	.word	0x2002976c
   362ec:	00043dc9 	.word	0x00043dc9
   362f0:	00040606 	.word	0x00040606
   362f4:	00043da7 	.word	0x00043da7
   362f8:	00043e0b 	.word	0x00043e0b
   362fc:	00043de0 	.word	0x00043de0
   36300:	00042742 	.word	0x00042742
   36304:	00043e1d 	.word	0x00043e1d
   36308:	20029768 	.word	0x20029768
   3630c:	000405cb 	.word	0x000405cb
   36310:	000405f1 	.word	0x000405f1
   36314:	00040623 	.word	0x00040623
   36318:	00040665 	.word	0x00040665
   3631c:	0004067c 	.word	0x0004067c

00036320 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static s32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			  bool alloc)
{
   36320:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   36324:	4604      	mov	r4, r0
   36326:	460e      	mov	r6, r1
   36328:	4690      	mov	r8, r2
   3632a:	4699      	mov	r9, r3
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   3632c:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   36330:	f04f 0320 	mov.w	r3, #32
   36334:	f3ef 8711 	mrs	r7, BASEPRI
   36338:	f383 8811 	msr	BASEPRI, r3
   3633c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   36340:	4628      	mov	r0, r5
   36342:	f001 fbfd 	bl	37b40 <z_spin_lock_valid>
   36346:	b968      	cbnz	r0, 36364 <queue_insert+0x44>
   36348:	234a      	movs	r3, #74	; 0x4a
   3634a:	4a33      	ldr	r2, [pc, #204]	; (36418 <queue_insert+0xf8>)
   3634c:	4933      	ldr	r1, [pc, #204]	; (3641c <queue_insert+0xfc>)
   3634e:	4834      	ldr	r0, [pc, #208]	; (36420 <queue_insert+0x100>)
   36350:	f006 f9ec 	bl	3c72c <printk>
   36354:	4629      	mov	r1, r5
   36356:	4833      	ldr	r0, [pc, #204]	; (36424 <queue_insert+0x104>)
   36358:	f006 f9e8 	bl	3c72c <printk>
   3635c:	214a      	movs	r1, #74	; 0x4a
   3635e:	482e      	ldr	r0, [pc, #184]	; (36418 <queue_insert+0xf8>)
   36360:	f006 fa2a 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   36364:	4628      	mov	r0, r5
   36366:	f001 fc09 	bl	37b7c <z_spin_lock_set_owner>
		return 0;
	}
#endif /* !CONFIG_POLL */

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
   3636a:	f1b9 0f00 	cmp.w	r9, #0
   3636e:	d02d      	beq.n	363cc <queue_insert+0xac>
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
   36370:	2008      	movs	r0, #8
   36372:	f7ff fcd7 	bl	35d24 <z_thread_malloc>
		if (anode == NULL) {
   36376:	b9c8      	cbnz	r0, 363ac <queue_insert+0x8c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   36378:	4628      	mov	r0, r5
   3637a:	f001 fbef 	bl	37b5c <z_spin_unlock_valid>
   3637e:	b968      	cbnz	r0, 3639c <queue_insert+0x7c>
   36380:	235d      	movs	r3, #93	; 0x5d
   36382:	4a25      	ldr	r2, [pc, #148]	; (36418 <queue_insert+0xf8>)
   36384:	4928      	ldr	r1, [pc, #160]	; (36428 <queue_insert+0x108>)
   36386:	4826      	ldr	r0, [pc, #152]	; (36420 <queue_insert+0x100>)
   36388:	f006 f9d0 	bl	3c72c <printk>
   3638c:	4629      	mov	r1, r5
   3638e:	4827      	ldr	r0, [pc, #156]	; (3642c <queue_insert+0x10c>)
   36390:	f006 f9cc 	bl	3c72c <printk>
   36394:	215d      	movs	r1, #93	; 0x5d
   36396:	4820      	ldr	r0, [pc, #128]	; (36418 <queue_insert+0xf8>)
   36398:	f006 fa0e 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   3639c:	f387 8811 	msr	BASEPRI, r7
   363a0:	f3bf 8f6f 	isb	sy
			k_spin_unlock(&queue->lock, key);
			return -ENOMEM;
   363a4:	f06f 000b 	mvn.w	r0, #11
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* CONFIG_POLL */

	z_reschedule(&queue->lock, key);
	return 0;
}
   363a8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	node->next_and_flags = flags;
   363ac:	2301      	movs	r3, #1
		anode->data = data;
   363ae:	f8c0 8004 	str.w	r8, [r0, #4]
   363b2:	6003      	str	r3, [r0, #0]
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
   363b4:	6803      	ldr	r3, [r0, #0]
   363b6:	f003 0203 	and.w	r2, r3, #3
   363ba:	b95e      	cbnz	r6, 363d4 <queue_insert+0xb4>
	parent->next_and_flags = cur_flags | (unative_t)child;
   363bc:	6823      	ldr	r3, [r4, #0]
   363be:	4313      	orrs	r3, r2
   363c0:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   363c2:	6863      	ldr	r3, [r4, #4]
	list->head = node;
   363c4:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   363c6:	b973      	cbnz	r3, 363e6 <queue_insert+0xc6>
	list->tail = node;
   363c8:	6060      	str	r0, [r4, #4]
   363ca:	e00c      	b.n	363e6 <queue_insert+0xc6>
	node->next_and_flags = flags;
   363cc:	f8c8 9000 	str.w	r9, [r8]
   363d0:	4640      	mov	r0, r8
   363d2:	e7ef      	b.n	363b4 <queue_insert+0x94>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   363d4:	6833      	ldr	r3, [r6, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   363d6:	f033 0303 	bics.w	r3, r3, #3
   363da:	d115      	bne.n	36408 <queue_insert+0xe8>
	parent->next_and_flags = cur_flags | (unative_t)child;
   363dc:	6002      	str	r2, [r0, #0]
Z_GENLIST_APPEND(sflist, sfnode)
   363de:	6862      	ldr	r2, [r4, #4]
   363e0:	b962      	cbnz	r2, 363fc <queue_insert+0xdc>
	list->head = node;
   363e2:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   363e6:	2104      	movs	r1, #4
   363e8:	f104 000c 	add.w	r0, r4, #12
   363ec:	f008 f9fb 	bl	3e7e6 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   363f0:	4628      	mov	r0, r5
   363f2:	4639      	mov	r1, r7
   363f4:	f000 fa26 	bl	36844 <z_reschedule>
	return 0;
   363f8:	2000      	movs	r0, #0
   363fa:	e7d5      	b.n	363a8 <queue_insert+0x88>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   363fc:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   363fe:	f003 0303 	and.w	r3, r3, #3
   36402:	4303      	orrs	r3, r0
   36404:	6013      	str	r3, [r2, #0]
   36406:	e7df      	b.n	363c8 <queue_insert+0xa8>
   36408:	4313      	orrs	r3, r2
   3640a:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   3640c:	6833      	ldr	r3, [r6, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   3640e:	f003 0303 	and.w	r3, r3, #3
   36412:	4318      	orrs	r0, r3
   36414:	6030      	str	r0, [r6, #0]
   36416:	e7e6      	b.n	363e6 <queue_insert+0xc6>
   36418:	000405cb 	.word	0x000405cb
   3641c:	000405f1 	.word	0x000405f1
   36420:	00040606 	.word	0x00040606
   36424:	00040623 	.word	0x00040623
   36428:	00040665 	.word	0x00040665
   3642c:	0004067c 	.word	0x0004067c

00036430 <z_impl_k_queue_get>:
	return val;
}
#endif /* CONFIG_POLL */

void *z_impl_k_queue_get(struct k_queue *queue, s32_t timeout)
{
   36430:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   36434:	4606      	mov	r6, r0
   36436:	b089      	sub	sp, #36	; 0x24
   36438:	460f      	mov	r7, r1
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   3643a:	f100 0408 	add.w	r4, r0, #8
	__asm__ volatile(
   3643e:	f04f 0320 	mov.w	r3, #32
   36442:	f3ef 8811 	mrs	r8, BASEPRI
   36446:	f383 8811 	msr	BASEPRI, r3
   3644a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   3644e:	4620      	mov	r0, r4
   36450:	f001 fb76 	bl	37b40 <z_spin_lock_valid>
   36454:	b968      	cbnz	r0, 36472 <z_impl_k_queue_get+0x42>
   36456:	234a      	movs	r3, #74	; 0x4a
   36458:	4a5f      	ldr	r2, [pc, #380]	; (365d8 <z_impl_k_queue_get+0x1a8>)
   3645a:	4960      	ldr	r1, [pc, #384]	; (365dc <z_impl_k_queue_get+0x1ac>)
   3645c:	4860      	ldr	r0, [pc, #384]	; (365e0 <z_impl_k_queue_get+0x1b0>)
   3645e:	f006 f965 	bl	3c72c <printk>
   36462:	4621      	mov	r1, r4
   36464:	485f      	ldr	r0, [pc, #380]	; (365e4 <z_impl_k_queue_get+0x1b4>)
   36466:	f006 f961 	bl	3c72c <printk>
   3646a:	214a      	movs	r1, #74	; 0x4a
   3646c:	485a      	ldr	r0, [pc, #360]	; (365d8 <z_impl_k_queue_get+0x1a8>)
   3646e:	f006 f9a3 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   36472:	4620      	mov	r0, r4
   36474:	f001 fb82 	bl	37b7c <z_spin_lock_set_owner>
Z_GENLIST_IS_EMPTY(sflist)
   36478:	6835      	ldr	r5, [r6, #0]
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   3647a:	b335      	cbz	r5, 364ca <z_impl_k_queue_get+0x9a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   3647c:	682b      	ldr	r3, [r5, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   3647e:	6872      	ldr	r2, [r6, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   36480:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   36484:	4295      	cmp	r5, r2
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   36486:	4628      	mov	r0, r5
	list->head = node;
   36488:	6033      	str	r3, [r6, #0]
	list->tail = node;
   3648a:	bf08      	it	eq
   3648c:	6073      	streq	r3, [r6, #4]
   3648e:	2101      	movs	r1, #1
   36490:	f008 f82e 	bl	3e4f0 <z_queue_node_peek>
   36494:	4605      	mov	r5, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   36496:	4620      	mov	r0, r4
   36498:	f001 fb60 	bl	37b5c <z_spin_unlock_valid>
   3649c:	b968      	cbnz	r0, 364ba <z_impl_k_queue_get+0x8a>
   3649e:	235d      	movs	r3, #93	; 0x5d
   364a0:	4a4d      	ldr	r2, [pc, #308]	; (365d8 <z_impl_k_queue_get+0x1a8>)
   364a2:	4951      	ldr	r1, [pc, #324]	; (365e8 <z_impl_k_queue_get+0x1b8>)
   364a4:	484e      	ldr	r0, [pc, #312]	; (365e0 <z_impl_k_queue_get+0x1b0>)
   364a6:	f006 f941 	bl	3c72c <printk>
   364aa:	4621      	mov	r1, r4
   364ac:	484f      	ldr	r0, [pc, #316]	; (365ec <z_impl_k_queue_get+0x1bc>)
   364ae:	f006 f93d 	bl	3c72c <printk>
   364b2:	215d      	movs	r1, #93	; 0x5d
   364b4:	4848      	ldr	r0, [pc, #288]	; (365d8 <z_impl_k_queue_get+0x1a8>)
   364b6:	f006 f97f 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   364ba:	f388 8811 	msr	BASEPRI, r8
   364be:	f3bf 8f6f 	isb	sy
#else
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
#endif /* CONFIG_POLL */
}
   364c2:	4628      	mov	r0, r5
   364c4:	b009      	add	sp, #36	; 0x24
   364c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   364ca:	4620      	mov	r0, r4
	if (timeout == K_NO_WAIT) {
   364cc:	2f00      	cmp	r7, #0
   364ce:	d0e3      	beq.n	36498 <z_impl_k_queue_get+0x68>
   364d0:	f001 fb44 	bl	37b5c <z_spin_unlock_valid>
   364d4:	b968      	cbnz	r0, 364f2 <z_impl_k_queue_get+0xc2>
   364d6:	235d      	movs	r3, #93	; 0x5d
   364d8:	4a3f      	ldr	r2, [pc, #252]	; (365d8 <z_impl_k_queue_get+0x1a8>)
   364da:	4943      	ldr	r1, [pc, #268]	; (365e8 <z_impl_k_queue_get+0x1b8>)
   364dc:	4840      	ldr	r0, [pc, #256]	; (365e0 <z_impl_k_queue_get+0x1b0>)
   364de:	f006 f925 	bl	3c72c <printk>
   364e2:	4621      	mov	r1, r4
   364e4:	4841      	ldr	r0, [pc, #260]	; (365ec <z_impl_k_queue_get+0x1bc>)
   364e6:	f006 f921 	bl	3c72c <printk>
   364ea:	215d      	movs	r1, #93	; 0x5d
   364ec:	483a      	ldr	r0, [pc, #232]	; (365d8 <z_impl_k_queue_get+0x1a8>)
   364ee:	f006 f963 	bl	3c7b8 <assert_post_action>
   364f2:	f388 8811 	msr	BASEPRI, r8
   364f6:	f3bf 8f6f 	isb	sy
	k_poll_event_init(&event, K_POLL_TYPE_FIFO_DATA_AVAILABLE,
   364fa:	2200      	movs	r2, #0
   364fc:	4633      	mov	r3, r6
   364fe:	2104      	movs	r1, #4
   36500:	a803      	add	r0, sp, #12
   36502:	f002 fb03 	bl	38b0c <k_poll_event_init>
	if (timeout != K_FOREVER) {
   36506:	1c7a      	adds	r2, r7, #1
   36508:	d002      	beq.n	36510 <z_impl_k_queue_get+0xe0>
   3650a:	f008 f8e2 	bl	3e6d2 <z_impl_k_uptime_get>
   3650e:	4683      	mov	fp, r0
{
   36510:	f04f 0900 	mov.w	r9, #0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   36514:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 365d8 <z_impl_k_queue_get+0x1a8>
   36518:	f8df a0c4 	ldr.w	sl, [pc, #196]	; 365e0 <z_impl_k_queue_get+0x1b0>
		event.state = K_POLL_STATE_NOT_READY;
   3651c:	9b06      	ldr	r3, [sp, #24]
   3651e:	f36f 3310 	bfc	r3, #12, #5
   36522:	9306      	str	r3, [sp, #24]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&events, *(uintptr_t *)&num_events, *(uintptr_t *)&timeout, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
   36524:	2101      	movs	r1, #1
   36526:	eba7 0209 	sub.w	r2, r7, r9
   3652a:	a803      	add	r0, sp, #12
   3652c:	f002 fb40 	bl	38bb0 <z_impl_k_poll>
		if (err && err != -EAGAIN) {
   36530:	b118      	cbz	r0, 3653a <z_impl_k_queue_get+0x10a>
   36532:	300b      	adds	r0, #11
   36534:	d001      	beq.n	3653a <z_impl_k_queue_get+0x10a>
			return NULL;
   36536:	2500      	movs	r5, #0
   36538:	e7c3      	b.n	364c2 <z_impl_k_queue_get+0x92>
	__asm__ volatile(
   3653a:	f04f 0320 	mov.w	r3, #32
   3653e:	f3ef 8211 	mrs	r2, BASEPRI
   36542:	f383 8811 	msr	BASEPRI, r3
   36546:	f3bf 8f6f 	isb	sy
   3654a:	4620      	mov	r0, r4
   3654c:	9201      	str	r2, [sp, #4]
   3654e:	f001 faf7 	bl	37b40 <z_spin_lock_valid>
   36552:	b968      	cbnz	r0, 36570 <z_impl_k_queue_get+0x140>
   36554:	234a      	movs	r3, #74	; 0x4a
   36556:	4642      	mov	r2, r8
   36558:	4920      	ldr	r1, [pc, #128]	; (365dc <z_impl_k_queue_get+0x1ac>)
   3655a:	4650      	mov	r0, sl
   3655c:	f006 f8e6 	bl	3c72c <printk>
   36560:	4621      	mov	r1, r4
   36562:	4820      	ldr	r0, [pc, #128]	; (365e4 <z_impl_k_queue_get+0x1b4>)
   36564:	f006 f8e2 	bl	3c72c <printk>
   36568:	214a      	movs	r1, #74	; 0x4a
   3656a:	4640      	mov	r0, r8
   3656c:	f006 f924 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   36570:	4620      	mov	r0, r4
   36572:	f001 fb03 	bl	37b7c <z_spin_lock_set_owner>
Z_GENLIST_IS_EMPTY(sflist)
   36576:	6830      	ldr	r0, [r6, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_sfnode_t *sys_sflist_get(sys_sflist_t *list);

Z_GENLIST_GET(sflist, sfnode)
   36578:	b138      	cbz	r0, 3658a <z_impl_k_queue_get+0x15a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   3657a:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   3657c:	6872      	ldr	r2, [r6, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   3657e:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   36582:	4290      	cmp	r0, r2
	list->head = node;
   36584:	6033      	str	r3, [r6, #0]
	list->tail = node;
   36586:	bf08      	it	eq
   36588:	6073      	streq	r3, [r6, #4]
		val = z_queue_node_peek(sys_sflist_get(&queue->data_q), true);
   3658a:	2101      	movs	r1, #1
   3658c:	f007 ffb0 	bl	3e4f0 <z_queue_node_peek>
   36590:	4605      	mov	r5, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   36592:	4620      	mov	r0, r4
   36594:	f001 fae2 	bl	37b5c <z_spin_unlock_valid>
   36598:	b968      	cbnz	r0, 365b6 <z_impl_k_queue_get+0x186>
   3659a:	235d      	movs	r3, #93	; 0x5d
   3659c:	4642      	mov	r2, r8
   3659e:	4912      	ldr	r1, [pc, #72]	; (365e8 <z_impl_k_queue_get+0x1b8>)
   365a0:	4650      	mov	r0, sl
   365a2:	f006 f8c3 	bl	3c72c <printk>
   365a6:	4621      	mov	r1, r4
   365a8:	4810      	ldr	r0, [pc, #64]	; (365ec <z_impl_k_queue_get+0x1bc>)
   365aa:	f006 f8bf 	bl	3c72c <printk>
   365ae:	215d      	movs	r1, #93	; 0x5d
   365b0:	4640      	mov	r0, r8
   365b2:	f006 f901 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   365b6:	9b01      	ldr	r3, [sp, #4]
   365b8:	f383 8811 	msr	BASEPRI, r3
   365bc:	f3bf 8f6f 	isb	sy
		if ((val == NULL) && (timeout != K_FOREVER)) {
   365c0:	2d00      	cmp	r5, #0
   365c2:	f47f af7e 	bne.w	364c2 <z_impl_k_queue_get+0x92>
   365c6:	1c7b      	adds	r3, r7, #1
   365c8:	d0a8      	beq.n	3651c <z_impl_k_queue_get+0xec>
	return z_impl_k_uptime_get();
   365ca:	f008 f882 	bl	3e6d2 <z_impl_k_uptime_get>
			elapsed = k_uptime_get_32() - start;
   365ce:	eba0 090b 	sub.w	r9, r0, fp
	} while (!val && !done);
   365d2:	454f      	cmp	r7, r9
   365d4:	daa2      	bge.n	3651c <z_impl_k_queue_get+0xec>
   365d6:	e7ae      	b.n	36536 <z_impl_k_queue_get+0x106>
   365d8:	000405cb 	.word	0x000405cb
   365dc:	000405f1 	.word	0x000405f1
   365e0:	00040606 	.word	0x00040606
   365e4:	00040623 	.word	0x00040623
   365e8:	00040665 	.word	0x00040665
   365ec:	0004067c 	.word	0x0004067c

000365f0 <pended_on.isra.17>:
	}
}

static _wait_q_t *pended_on(struct k_thread *thread)
{
	__ASSERT_NO_MSG(thread->base.pended_on);
   365f0:	6803      	ldr	r3, [r0, #0]
static _wait_q_t *pended_on(struct k_thread *thread)
   365f2:	b510      	push	{r4, lr}
   365f4:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(thread->base.pended_on);
   365f6:	b95b      	cbnz	r3, 36610 <pended_on.isra.17+0x20>
   365f8:	4906      	ldr	r1, [pc, #24]	; (36614 <pended_on.isra.17+0x24>)
   365fa:	4807      	ldr	r0, [pc, #28]	; (36618 <pended_on.isra.17+0x28>)
   365fc:	f240 139d 	movw	r3, #413	; 0x19d
   36600:	4a06      	ldr	r2, [pc, #24]	; (3661c <pended_on.isra.17+0x2c>)
   36602:	f006 f893 	bl	3c72c <printk>
   36606:	f240 119d 	movw	r1, #413	; 0x19d
   3660a:	4804      	ldr	r0, [pc, #16]	; (3661c <pended_on.isra.17+0x2c>)
   3660c:	f006 f8d4 	bl	3c7b8 <assert_post_action>

	return thread->base.pended_on;
}
   36610:	6820      	ldr	r0, [r4, #0]
   36612:	bd10      	pop	{r4, pc}
   36614:	00043ec5 	.word	0x00043ec5
   36618:	00040606 	.word	0x00040606
   3661c:	00043ea3 	.word	0x00043ea3

00036620 <z_reset_time_slice>:
{
   36620:	b510      	push	{r4, lr}
	if (slice_time != 0) {
   36622:	4c08      	ldr	r4, [pc, #32]	; (36644 <z_reset_time_slice+0x24>)
   36624:	6823      	ldr	r3, [r4, #0]
   36626:	b15b      	cbz	r3, 36640 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   36628:	f7f1 fb88 	bl	27d3c <z_clock_elapsed>
   3662c:	6823      	ldr	r3, [r4, #0]
   3662e:	4a06      	ldr	r2, [pc, #24]	; (36648 <z_reset_time_slice+0x28>)
   36630:	4418      	add	r0, r3
   36632:	6110      	str	r0, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   36634:	2100      	movs	r1, #0
}
   36636:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_set_timeout_expiry(slice_time, false);
   3663a:	4618      	mov	r0, r3
   3663c:	f001 beb6 	b.w	383ac <z_set_timeout_expiry>
}
   36640:	bd10      	pop	{r4, pc}
   36642:	bf00      	nop
   36644:	200297ac 	.word	0x200297ac
   36648:	2002976c 	.word	0x2002976c

0003664c <k_sched_time_slice_set>:
{
   3664c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3664e:	4607      	mov	r7, r0
   36650:	460d      	mov	r5, r1
	__asm__ volatile(
   36652:	f04f 0320 	mov.w	r3, #32
   36656:	f3ef 8411 	mrs	r4, BASEPRI
   3665a:	f383 8811 	msr	BASEPRI, r3
   3665e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   36662:	4820      	ldr	r0, [pc, #128]	; (366e4 <k_sched_time_slice_set+0x98>)
   36664:	f001 fa6c 	bl	37b40 <z_spin_lock_valid>
   36668:	b968      	cbnz	r0, 36686 <k_sched_time_slice_set+0x3a>
   3666a:	234a      	movs	r3, #74	; 0x4a
   3666c:	4a1e      	ldr	r2, [pc, #120]	; (366e8 <k_sched_time_slice_set+0x9c>)
   3666e:	491f      	ldr	r1, [pc, #124]	; (366ec <k_sched_time_slice_set+0xa0>)
   36670:	481f      	ldr	r0, [pc, #124]	; (366f0 <k_sched_time_slice_set+0xa4>)
   36672:	f006 f85b 	bl	3c72c <printk>
   36676:	491b      	ldr	r1, [pc, #108]	; (366e4 <k_sched_time_slice_set+0x98>)
   36678:	481e      	ldr	r0, [pc, #120]	; (366f4 <k_sched_time_slice_set+0xa8>)
   3667a:	f006 f857 	bl	3c72c <printk>
   3667e:	214a      	movs	r1, #74	; 0x4a
   36680:	4819      	ldr	r0, [pc, #100]	; (366e8 <k_sched_time_slice_set+0x9c>)
   36682:	f006 f899 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   36686:	4817      	ldr	r0, [pc, #92]	; (366e4 <k_sched_time_slice_set+0x98>)
   36688:	f001 fa78 	bl	37b7c <z_spin_lock_set_owner>
			return (u32_t)((t * to_hz + off) / from_hz);
   3668c:	f44f 4600 	mov.w	r6, #32768	; 0x8000
		_current_cpu->slice_ticks = 0;
   36690:	2200      	movs	r2, #0
   36692:	f240 30e7 	movw	r0, #999	; 0x3e7
   36696:	2100      	movs	r1, #0
   36698:	4b17      	ldr	r3, [pc, #92]	; (366f8 <k_sched_time_slice_set+0xac>)
   3669a:	fbe6 0107 	umlal	r0, r1, r6, r7
   3669e:	611a      	str	r2, [r3, #16]
   366a0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   366a4:	2300      	movs	r3, #0
   366a6:	f7e6 fb91 	bl	1cdcc <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
   366aa:	4b14      	ldr	r3, [pc, #80]	; (366fc <k_sched_time_slice_set+0xb0>)
   366ac:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
   366ae:	4b14      	ldr	r3, [pc, #80]	; (36700 <k_sched_time_slice_set+0xb4>)
   366b0:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
   366b2:	f7ff ffb5 	bl	36620 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   366b6:	480b      	ldr	r0, [pc, #44]	; (366e4 <k_sched_time_slice_set+0x98>)
   366b8:	f001 fa50 	bl	37b5c <z_spin_unlock_valid>
   366bc:	b968      	cbnz	r0, 366da <k_sched_time_slice_set+0x8e>
   366be:	235d      	movs	r3, #93	; 0x5d
   366c0:	4a09      	ldr	r2, [pc, #36]	; (366e8 <k_sched_time_slice_set+0x9c>)
   366c2:	4910      	ldr	r1, [pc, #64]	; (36704 <k_sched_time_slice_set+0xb8>)
   366c4:	480a      	ldr	r0, [pc, #40]	; (366f0 <k_sched_time_slice_set+0xa4>)
   366c6:	f006 f831 	bl	3c72c <printk>
   366ca:	4906      	ldr	r1, [pc, #24]	; (366e4 <k_sched_time_slice_set+0x98>)
   366cc:	480e      	ldr	r0, [pc, #56]	; (36708 <k_sched_time_slice_set+0xbc>)
   366ce:	f006 f82d 	bl	3c72c <printk>
   366d2:	215d      	movs	r1, #93	; 0x5d
   366d4:	4804      	ldr	r0, [pc, #16]	; (366e8 <k_sched_time_slice_set+0x9c>)
   366d6:	f006 f86f 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   366da:	f384 8811 	msr	BASEPRI, r4
   366de:	f3bf 8f6f 	isb	sy
}
   366e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   366e4:	200297a4 	.word	0x200297a4
   366e8:	000405cb 	.word	0x000405cb
   366ec:	000405f1 	.word	0x000405f1
   366f0:	00040606 	.word	0x00040606
   366f4:	00040623 	.word	0x00040623
   366f8:	2002976c 	.word	0x2002976c
   366fc:	200297ac 	.word	0x200297ac
   36700:	200297a8 	.word	0x200297a8
   36704:	00040665 	.word	0x00040665
   36708:	0004067c 	.word	0x0004067c

0003670c <z_find_first_thread_to_unpend>:
	pend(thread, wait_q, timeout);
}

ALWAYS_INLINE struct k_thread *z_find_first_thread_to_unpend(_wait_q_t *wait_q,
						     struct k_thread *from)
{
   3670c:	b538      	push	{r3, r4, r5, lr}
   3670e:	4604      	mov	r4, r0
	__asm__ volatile(
   36710:	f04f 0320 	mov.w	r3, #32
   36714:	f3ef 8511 	mrs	r5, BASEPRI
   36718:	f383 8811 	msr	BASEPRI, r3
   3671c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   36720:	4818      	ldr	r0, [pc, #96]	; (36784 <z_find_first_thread_to_unpend+0x78>)
   36722:	f001 fa0d 	bl	37b40 <z_spin_lock_valid>
   36726:	b968      	cbnz	r0, 36744 <z_find_first_thread_to_unpend+0x38>
   36728:	234a      	movs	r3, #74	; 0x4a
   3672a:	4a17      	ldr	r2, [pc, #92]	; (36788 <z_find_first_thread_to_unpend+0x7c>)
   3672c:	4917      	ldr	r1, [pc, #92]	; (3678c <z_find_first_thread_to_unpend+0x80>)
   3672e:	4818      	ldr	r0, [pc, #96]	; (36790 <z_find_first_thread_to_unpend+0x84>)
   36730:	f005 fffc 	bl	3c72c <printk>
   36734:	4913      	ldr	r1, [pc, #76]	; (36784 <z_find_first_thread_to_unpend+0x78>)
   36736:	4817      	ldr	r0, [pc, #92]	; (36794 <z_find_first_thread_to_unpend+0x88>)
   36738:	f005 fff8 	bl	3c72c <printk>
   3673c:	214a      	movs	r1, #74	; 0x4a
   3673e:	4812      	ldr	r0, [pc, #72]	; (36788 <z_find_first_thread_to_unpend+0x7c>)
   36740:	f006 f83a 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   36744:	480f      	ldr	r0, [pc, #60]	; (36784 <z_find_first_thread_to_unpend+0x78>)
   36746:	f001 fa19 	bl	37b7c <z_spin_lock_set_owner>
	ARG_UNUSED(from);

	struct k_thread *ret = NULL;

	LOCKED(&sched_spinlock) {
		ret = _priq_wait_best(&wait_q->waitq);
   3674a:	4620      	mov	r0, r4
   3674c:	f007 ff12 	bl	3e574 <z_priq_dumb_best>
   36750:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   36752:	480c      	ldr	r0, [pc, #48]	; (36784 <z_find_first_thread_to_unpend+0x78>)
   36754:	f001 fa02 	bl	37b5c <z_spin_unlock_valid>
   36758:	b968      	cbnz	r0, 36776 <z_find_first_thread_to_unpend+0x6a>
   3675a:	235d      	movs	r3, #93	; 0x5d
   3675c:	4a0a      	ldr	r2, [pc, #40]	; (36788 <z_find_first_thread_to_unpend+0x7c>)
   3675e:	490e      	ldr	r1, [pc, #56]	; (36798 <z_find_first_thread_to_unpend+0x8c>)
   36760:	480b      	ldr	r0, [pc, #44]	; (36790 <z_find_first_thread_to_unpend+0x84>)
   36762:	f005 ffe3 	bl	3c72c <printk>
   36766:	4907      	ldr	r1, [pc, #28]	; (36784 <z_find_first_thread_to_unpend+0x78>)
   36768:	480c      	ldr	r0, [pc, #48]	; (3679c <z_find_first_thread_to_unpend+0x90>)
   3676a:	f005 ffdf 	bl	3c72c <printk>
   3676e:	215d      	movs	r1, #93	; 0x5d
   36770:	4805      	ldr	r0, [pc, #20]	; (36788 <z_find_first_thread_to_unpend+0x7c>)
   36772:	f006 f821 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   36776:	f385 8811 	msr	BASEPRI, r5
   3677a:	f3bf 8f6f 	isb	sy
	}

	return ret;
}
   3677e:	4620      	mov	r0, r4
   36780:	bd38      	pop	{r3, r4, r5, pc}
   36782:	bf00      	nop
   36784:	200297a4 	.word	0x200297a4
   36788:	000405cb 	.word	0x000405cb
   3678c:	000405f1 	.word	0x000405f1
   36790:	00040606 	.word	0x00040606
   36794:	00040623 	.word	0x00040623
   36798:	00040665 	.word	0x00040665
   3679c:	0004067c 	.word	0x0004067c

000367a0 <z_unpend_thread_no_timeout>:

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
   367a0:	b538      	push	{r3, r4, r5, lr}
   367a2:	4604      	mov	r4, r0
	__asm__ volatile(
   367a4:	f04f 0320 	mov.w	r3, #32
   367a8:	f3ef 8511 	mrs	r5, BASEPRI
   367ac:	f383 8811 	msr	BASEPRI, r3
   367b0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   367b4:	481c      	ldr	r0, [pc, #112]	; (36828 <z_unpend_thread_no_timeout+0x88>)
   367b6:	f001 f9c3 	bl	37b40 <z_spin_lock_valid>
   367ba:	b968      	cbnz	r0, 367d8 <z_unpend_thread_no_timeout+0x38>
   367bc:	234a      	movs	r3, #74	; 0x4a
   367be:	4a1b      	ldr	r2, [pc, #108]	; (3682c <z_unpend_thread_no_timeout+0x8c>)
   367c0:	491b      	ldr	r1, [pc, #108]	; (36830 <z_unpend_thread_no_timeout+0x90>)
   367c2:	481c      	ldr	r0, [pc, #112]	; (36834 <z_unpend_thread_no_timeout+0x94>)
   367c4:	f005 ffb2 	bl	3c72c <printk>
   367c8:	4917      	ldr	r1, [pc, #92]	; (36828 <z_unpend_thread_no_timeout+0x88>)
   367ca:	481b      	ldr	r0, [pc, #108]	; (36838 <z_unpend_thread_no_timeout+0x98>)
   367cc:	f005 ffae 	bl	3c72c <printk>
   367d0:	214a      	movs	r1, #74	; 0x4a
   367d2:	4816      	ldr	r0, [pc, #88]	; (3682c <z_unpend_thread_no_timeout+0x8c>)
   367d4:	f005 fff0 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   367d8:	4813      	ldr	r0, [pc, #76]	; (36828 <z_unpend_thread_no_timeout+0x88>)
   367da:	f001 f9cf 	bl	37b7c <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   367de:	f104 0008 	add.w	r0, r4, #8
   367e2:	f7ff ff05 	bl	365f0 <pended_on.isra.17>
   367e6:	4621      	mov	r1, r4
   367e8:	f000 f8e0 	bl	369ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   367ec:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   367ee:	480e      	ldr	r0, [pc, #56]	; (36828 <z_unpend_thread_no_timeout+0x88>)
   367f0:	f023 0302 	bic.w	r3, r3, #2
   367f4:	7363      	strb	r3, [r4, #13]
   367f6:	f001 f9b1 	bl	37b5c <z_spin_unlock_valid>
   367fa:	b968      	cbnz	r0, 36818 <z_unpend_thread_no_timeout+0x78>
   367fc:	235d      	movs	r3, #93	; 0x5d
   367fe:	4a0b      	ldr	r2, [pc, #44]	; (3682c <z_unpend_thread_no_timeout+0x8c>)
   36800:	490e      	ldr	r1, [pc, #56]	; (3683c <z_unpend_thread_no_timeout+0x9c>)
   36802:	480c      	ldr	r0, [pc, #48]	; (36834 <z_unpend_thread_no_timeout+0x94>)
   36804:	f005 ff92 	bl	3c72c <printk>
   36808:	4907      	ldr	r1, [pc, #28]	; (36828 <z_unpend_thread_no_timeout+0x88>)
   3680a:	480d      	ldr	r0, [pc, #52]	; (36840 <z_unpend_thread_no_timeout+0xa0>)
   3680c:	f005 ff8e 	bl	3c72c <printk>
   36810:	215d      	movs	r1, #93	; 0x5d
   36812:	4806      	ldr	r0, [pc, #24]	; (3682c <z_unpend_thread_no_timeout+0x8c>)
   36814:	f005 ffd0 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   36818:	f385 8811 	msr	BASEPRI, r5
   3681c:	f3bf 8f6f 	isb	sy
		z_mark_thread_as_not_pending(thread);
	}

	thread->base.pended_on = NULL;
   36820:	2300      	movs	r3, #0
   36822:	60a3      	str	r3, [r4, #8]
}
   36824:	bd38      	pop	{r3, r4, r5, pc}
   36826:	bf00      	nop
   36828:	200297a4 	.word	0x200297a4
   3682c:	000405cb 	.word	0x000405cb
   36830:	000405f1 	.word	0x000405f1
   36834:	00040606 	.word	0x00040606
   36838:	00040623 	.word	0x00040623
   3683c:	00040665 	.word	0x00040665
   36840:	0004067c 	.word	0x0004067c

00036844 <z_reschedule>:

	return arch_irq_unlocked(key) && !arch_is_in_isr();
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
   36844:	b538      	push	{r3, r4, r5, lr}
   36846:	4604      	mov	r4, r0
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   36848:	460d      	mov	r5, r1
   3684a:	b9c1      	cbnz	r1, 3687e <z_reschedule+0x3a>
   3684c:	f3ef 8305 	mrs	r3, IPSR
   36850:	b9ab      	cbnz	r3, 3687e <z_reschedule+0x3a>
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   36852:	f001 f983 	bl	37b5c <z_spin_unlock_valid>
   36856:	b968      	cbnz	r0, 36874 <z_reschedule+0x30>
   36858:	2374      	movs	r3, #116	; 0x74
   3685a:	4a14      	ldr	r2, [pc, #80]	; (368ac <z_reschedule+0x68>)
   3685c:	4914      	ldr	r1, [pc, #80]	; (368b0 <z_reschedule+0x6c>)
   3685e:	4815      	ldr	r0, [pc, #84]	; (368b4 <z_reschedule+0x70>)
   36860:	f005 ff64 	bl	3c72c <printk>
   36864:	4621      	mov	r1, r4
   36866:	4814      	ldr	r0, [pc, #80]	; (368b8 <z_reschedule+0x74>)
   36868:	f005 ff60 	bl	3c72c <printk>
   3686c:	2174      	movs	r1, #116	; 0x74
   3686e:	480f      	ldr	r0, [pc, #60]	; (368ac <z_reschedule+0x68>)
   36870:	f005 ffa2 	bl	3c7b8 <assert_post_action>
	if (resched(key.key)) {
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
   36874:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   36878:	2000      	movs	r0, #0
   3687a:	f7f1 bc41 	b.w	28100 <arch_swap>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   3687e:	4620      	mov	r0, r4
   36880:	f001 f96c 	bl	37b5c <z_spin_unlock_valid>
   36884:	b968      	cbnz	r0, 368a2 <z_reschedule+0x5e>
   36886:	235d      	movs	r3, #93	; 0x5d
   36888:	4a08      	ldr	r2, [pc, #32]	; (368ac <z_reschedule+0x68>)
   3688a:	4909      	ldr	r1, [pc, #36]	; (368b0 <z_reschedule+0x6c>)
   3688c:	4809      	ldr	r0, [pc, #36]	; (368b4 <z_reschedule+0x70>)
   3688e:	f005 ff4d 	bl	3c72c <printk>
   36892:	4621      	mov	r1, r4
   36894:	4808      	ldr	r0, [pc, #32]	; (368b8 <z_reschedule+0x74>)
   36896:	f005 ff49 	bl	3c72c <printk>
   3689a:	215d      	movs	r1, #93	; 0x5d
   3689c:	4803      	ldr	r0, [pc, #12]	; (368ac <z_reschedule+0x68>)
   3689e:	f005 ff8b 	bl	3c7b8 <assert_post_action>
   368a2:	f385 8811 	msr	BASEPRI, r5
   368a6:	f3bf 8f6f 	isb	sy
   368aa:	bd38      	pop	{r3, r4, r5, pc}
   368ac:	000405cb 	.word	0x000405cb
   368b0:	00040665 	.word	0x00040665
   368b4:	00040606 	.word	0x00040606
   368b8:	0004067c 	.word	0x0004067c

000368bc <k_sched_lock>:
		irq_unlock(key);
	}
}

void k_sched_lock(void)
{
   368bc:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   368be:	f04f 0320 	mov.w	r3, #32
   368c2:	f3ef 8511 	mrs	r5, BASEPRI
   368c6:	f383 8811 	msr	BASEPRI, r3
   368ca:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   368ce:	482b      	ldr	r0, [pc, #172]	; (3697c <k_sched_lock+0xc0>)
   368d0:	f001 f936 	bl	37b40 <z_spin_lock_valid>
   368d4:	b968      	cbnz	r0, 368f2 <k_sched_lock+0x36>
   368d6:	234a      	movs	r3, #74	; 0x4a
   368d8:	4a29      	ldr	r2, [pc, #164]	; (36980 <k_sched_lock+0xc4>)
   368da:	492a      	ldr	r1, [pc, #168]	; (36984 <k_sched_lock+0xc8>)
   368dc:	482a      	ldr	r0, [pc, #168]	; (36988 <k_sched_lock+0xcc>)
   368de:	f005 ff25 	bl	3c72c <printk>
   368e2:	4926      	ldr	r1, [pc, #152]	; (3697c <k_sched_lock+0xc0>)
   368e4:	4829      	ldr	r0, [pc, #164]	; (3698c <k_sched_lock+0xd0>)
   368e6:	f005 ff21 	bl	3c72c <printk>
   368ea:	214a      	movs	r1, #74	; 0x4a
   368ec:	4824      	ldr	r0, [pc, #144]	; (36980 <k_sched_lock+0xc4>)
   368ee:	f005 ff63 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   368f2:	4822      	ldr	r0, [pc, #136]	; (3697c <k_sched_lock+0xc0>)
   368f4:	f001 f942 	bl	37b7c <z_spin_lock_set_owner>
   368f8:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   368fc:	b173      	cbz	r3, 3691c <k_sched_lock+0x60>
   368fe:	4924      	ldr	r1, [pc, #144]	; (36990 <k_sched_lock+0xd4>)
   36900:	f240 130d 	movw	r3, #269	; 0x10d
   36904:	4a23      	ldr	r2, [pc, #140]	; (36994 <k_sched_lock+0xd8>)
   36906:	4820      	ldr	r0, [pc, #128]	; (36988 <k_sched_lock+0xcc>)
   36908:	f005 ff10 	bl	3c72c <printk>
   3690c:	4822      	ldr	r0, [pc, #136]	; (36998 <k_sched_lock+0xdc>)
   3690e:	f005 ff0d 	bl	3c72c <printk>
   36912:	f240 110d 	movw	r1, #269	; 0x10d
   36916:	481f      	ldr	r0, [pc, #124]	; (36994 <k_sched_lock+0xd8>)
   36918:	f005 ff4e 	bl	3c7b8 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1, "");
   3691c:	4c1f      	ldr	r4, [pc, #124]	; (3699c <k_sched_lock+0xe0>)
   3691e:	68a2      	ldr	r2, [r4, #8]
   36920:	7bd2      	ldrb	r2, [r2, #15]
   36922:	2a01      	cmp	r2, #1
   36924:	d10e      	bne.n	36944 <k_sched_lock+0x88>
   36926:	491e      	ldr	r1, [pc, #120]	; (369a0 <k_sched_lock+0xe4>)
   36928:	f44f 7387 	mov.w	r3, #270	; 0x10e
   3692c:	4a19      	ldr	r2, [pc, #100]	; (36994 <k_sched_lock+0xd8>)
   3692e:	4816      	ldr	r0, [pc, #88]	; (36988 <k_sched_lock+0xcc>)
   36930:	f005 fefc 	bl	3c72c <printk>
   36934:	4818      	ldr	r0, [pc, #96]	; (36998 <k_sched_lock+0xdc>)
   36936:	f005 fef9 	bl	3c72c <printk>
   3693a:	f44f 7187 	mov.w	r1, #270	; 0x10e
   3693e:	4815      	ldr	r0, [pc, #84]	; (36994 <k_sched_lock+0xd8>)
   36940:	f005 ff3a 	bl	3c7b8 <assert_post_action>
	--_current->base.sched_locked;
   36944:	68a2      	ldr	r2, [r4, #8]
   36946:	7bd3      	ldrb	r3, [r2, #15]
   36948:	3b01      	subs	r3, #1
   3694a:	73d3      	strb	r3, [r2, #15]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   3694c:	480b      	ldr	r0, [pc, #44]	; (3697c <k_sched_lock+0xc0>)
   3694e:	f001 f905 	bl	37b5c <z_spin_unlock_valid>
   36952:	b968      	cbnz	r0, 36970 <k_sched_lock+0xb4>
   36954:	235d      	movs	r3, #93	; 0x5d
   36956:	4a0a      	ldr	r2, [pc, #40]	; (36980 <k_sched_lock+0xc4>)
   36958:	4912      	ldr	r1, [pc, #72]	; (369a4 <k_sched_lock+0xe8>)
   3695a:	480b      	ldr	r0, [pc, #44]	; (36988 <k_sched_lock+0xcc>)
   3695c:	f005 fee6 	bl	3c72c <printk>
   36960:	4906      	ldr	r1, [pc, #24]	; (3697c <k_sched_lock+0xc0>)
   36962:	4811      	ldr	r0, [pc, #68]	; (369a8 <k_sched_lock+0xec>)
   36964:	f005 fee2 	bl	3c72c <printk>
   36968:	215d      	movs	r1, #93	; 0x5d
   3696a:	4805      	ldr	r0, [pc, #20]	; (36980 <k_sched_lock+0xc4>)
   3696c:	f005 ff24 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   36970:	f385 8811 	msr	BASEPRI, r5
   36974:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
   36978:	bd38      	pop	{r3, r4, r5, pc}
   3697a:	bf00      	nop
   3697c:	200297a4 	.word	0x200297a4
   36980:	000405cb 	.word	0x000405cb
   36984:	000405f1 	.word	0x000405f1
   36988:	00040606 	.word	0x00040606
   3698c:	00040623 	.word	0x00040623
   36990:	00043e0b 	.word	0x00043e0b
   36994:	00043de0 	.word	0x00043de0
   36998:	00042742 	.word	0x00042742
   3699c:	2002976c 	.word	0x2002976c
   369a0:	00043e1d 	.word	0x00043e1d
   369a4:	00040665 	.word	0x00040665
   369a8:	0004067c 	.word	0x0004067c

000369ac <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   369ac:	4b11      	ldr	r3, [pc, #68]	; (369f4 <z_priq_dumb_remove+0x48>)
{
   369ae:	b510      	push	{r4, lr}
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   369b0:	f103 0228 	add.w	r2, r3, #40	; 0x28
   369b4:	4282      	cmp	r2, r0
{
   369b6:	460c      	mov	r4, r1
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   369b8:	d105      	bne.n	369c6 <z_priq_dumb_remove+0x1a>
   369ba:	689b      	ldr	r3, [r3, #8]
   369bc:	428b      	cmp	r3, r1
   369be:	d102      	bne.n	369c6 <z_priq_dumb_remove+0x1a>
   369c0:	7b4b      	ldrb	r3, [r1, #13]
   369c2:	06db      	lsls	r3, r3, #27
   369c4:	d115      	bne.n	369f2 <z_priq_dumb_remove+0x46>
	    z_is_thread_prevented_from_running(thread)) {
		return;
	}
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   369c6:	4b0c      	ldr	r3, [pc, #48]	; (369f8 <z_priq_dumb_remove+0x4c>)
   369c8:	429c      	cmp	r4, r3
   369ca:	d10b      	bne.n	369e4 <z_priq_dumb_remove+0x38>
   369cc:	490b      	ldr	r1, [pc, #44]	; (369fc <z_priq_dumb_remove+0x50>)
   369ce:	480c      	ldr	r0, [pc, #48]	; (36a00 <z_priq_dumb_remove+0x54>)
   369d0:	f44f 7346 	mov.w	r3, #792	; 0x318
   369d4:	4a0b      	ldr	r2, [pc, #44]	; (36a04 <z_priq_dumb_remove+0x58>)
   369d6:	f005 fea9 	bl	3c72c <printk>
   369da:	f44f 7146 	mov.w	r1, #792	; 0x318
   369de:	4809      	ldr	r0, [pc, #36]	; (36a04 <z_priq_dumb_remove+0x58>)
   369e0:	f005 feea 	bl	3c7b8 <assert_post_action>
	node->prev->next = node->next;
   369e4:	e9d4 3200 	ldrd	r3, r2, [r4]
   369e8:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   369ea:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   369ec:	2300      	movs	r3, #0
	node->prev = NULL;
   369ee:	e9c4 3300 	strd	r3, r3, [r4]

	sys_dlist_remove(&thread->base.qnode_dlist);
}
   369f2:	bd10      	pop	{r4, pc}
   369f4:	2002976c 	.word	0x2002976c
   369f8:	2002559c 	.word	0x2002559c
   369fc:	00043efb 	.word	0x00043efb
   36a00:	00040606 	.word	0x00040606
   36a04:	00043ea3 	.word	0x00043ea3

00036a08 <z_unpend_thread>:
{
   36a08:	b538      	push	{r3, r4, r5, lr}
   36a0a:	4604      	mov	r4, r0
	__asm__ volatile(
   36a0c:	f04f 0320 	mov.w	r3, #32
   36a10:	f3ef 8511 	mrs	r5, BASEPRI
   36a14:	f383 8811 	msr	BASEPRI, r3
   36a18:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   36a1c:	481e      	ldr	r0, [pc, #120]	; (36a98 <z_unpend_thread+0x90>)
   36a1e:	f001 f88f 	bl	37b40 <z_spin_lock_valid>
   36a22:	b968      	cbnz	r0, 36a40 <z_unpend_thread+0x38>
   36a24:	234a      	movs	r3, #74	; 0x4a
   36a26:	4a1d      	ldr	r2, [pc, #116]	; (36a9c <z_unpend_thread+0x94>)
   36a28:	491d      	ldr	r1, [pc, #116]	; (36aa0 <z_unpend_thread+0x98>)
   36a2a:	481e      	ldr	r0, [pc, #120]	; (36aa4 <z_unpend_thread+0x9c>)
   36a2c:	f005 fe7e 	bl	3c72c <printk>
   36a30:	4919      	ldr	r1, [pc, #100]	; (36a98 <z_unpend_thread+0x90>)
   36a32:	481d      	ldr	r0, [pc, #116]	; (36aa8 <z_unpend_thread+0xa0>)
   36a34:	f005 fe7a 	bl	3c72c <printk>
   36a38:	214a      	movs	r1, #74	; 0x4a
   36a3a:	4818      	ldr	r0, [pc, #96]	; (36a9c <z_unpend_thread+0x94>)
   36a3c:	f005 febc 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   36a40:	4815      	ldr	r0, [pc, #84]	; (36a98 <z_unpend_thread+0x90>)
   36a42:	f001 f89b 	bl	37b7c <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   36a46:	f104 0008 	add.w	r0, r4, #8
   36a4a:	f7ff fdd1 	bl	365f0 <pended_on.isra.17>
   36a4e:	4621      	mov	r1, r4
   36a50:	f7ff ffac 	bl	369ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   36a54:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   36a56:	4810      	ldr	r0, [pc, #64]	; (36a98 <z_unpend_thread+0x90>)
   36a58:	f023 0302 	bic.w	r3, r3, #2
   36a5c:	7363      	strb	r3, [r4, #13]
   36a5e:	f001 f87d 	bl	37b5c <z_spin_unlock_valid>
   36a62:	b968      	cbnz	r0, 36a80 <z_unpend_thread+0x78>
   36a64:	235d      	movs	r3, #93	; 0x5d
   36a66:	4a0d      	ldr	r2, [pc, #52]	; (36a9c <z_unpend_thread+0x94>)
   36a68:	4910      	ldr	r1, [pc, #64]	; (36aac <z_unpend_thread+0xa4>)
   36a6a:	480e      	ldr	r0, [pc, #56]	; (36aa4 <z_unpend_thread+0x9c>)
   36a6c:	f005 fe5e 	bl	3c72c <printk>
   36a70:	4909      	ldr	r1, [pc, #36]	; (36a98 <z_unpend_thread+0x90>)
   36a72:	480f      	ldr	r0, [pc, #60]	; (36ab0 <z_unpend_thread+0xa8>)
   36a74:	f005 fe5a 	bl	3c72c <printk>
   36a78:	215d      	movs	r1, #93	; 0x5d
   36a7a:	4808      	ldr	r0, [pc, #32]	; (36a9c <z_unpend_thread+0x94>)
   36a7c:	f005 fe9c 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   36a80:	f385 8811 	msr	BASEPRI, r5
   36a84:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   36a88:	2300      	movs	r3, #0
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   36a8a:	f104 0018 	add.w	r0, r4, #24
   36a8e:	60a3      	str	r3, [r4, #8]
}
   36a90:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   36a94:	f001 bb94 	b.w	381c0 <z_abort_timeout>
   36a98:	200297a4 	.word	0x200297a4
   36a9c:	000405cb 	.word	0x000405cb
   36aa0:	000405f1 	.word	0x000405f1
   36aa4:	00040606 	.word	0x00040606
   36aa8:	00040623 	.word	0x00040623
   36aac:	00040665 	.word	0x00040665
   36ab0:	0004067c 	.word	0x0004067c

00036ab4 <update_cache>:
{
   36ab4:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   36ab6:	4c15      	ldr	r4, [pc, #84]	; (36b0c <update_cache+0x58>)
{
   36ab8:	4602      	mov	r2, r0
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   36aba:	f104 0028 	add.w	r0, r4, #40	; 0x28
   36abe:	f007 fd59 	bl	3e574 <z_priq_dumb_best>
	return thread ? thread : _current_cpu->idle_thread;
   36ac2:	4605      	mov	r5, r0
   36ac4:	b900      	cbnz	r0, 36ac8 <update_cache+0x14>
   36ac6:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
   36ac8:	b9ca      	cbnz	r2, 36afe <update_cache+0x4a>
	__ASSERT(_current != NULL, "");
   36aca:	68a3      	ldr	r3, [r4, #8]
   36acc:	b963      	cbnz	r3, 36ae8 <update_cache+0x34>
   36ace:	4910      	ldr	r1, [pc, #64]	; (36b10 <update_cache+0x5c>)
   36ad0:	237e      	movs	r3, #126	; 0x7e
   36ad2:	4a10      	ldr	r2, [pc, #64]	; (36b14 <update_cache+0x60>)
   36ad4:	4810      	ldr	r0, [pc, #64]	; (36b18 <update_cache+0x64>)
   36ad6:	f005 fe29 	bl	3c72c <printk>
   36ada:	4810      	ldr	r0, [pc, #64]	; (36b1c <update_cache+0x68>)
   36adc:	f005 fe26 	bl	3c72c <printk>
   36ae0:	217e      	movs	r1, #126	; 0x7e
   36ae2:	480c      	ldr	r0, [pc, #48]	; (36b14 <update_cache+0x60>)
   36ae4:	f005 fe68 	bl	3c7b8 <assert_post_action>
	if (z_is_thread_prevented_from_running(_current)) {
   36ae8:	68a3      	ldr	r3, [r4, #8]
   36aea:	7b5a      	ldrb	r2, [r3, #13]
   36aec:	06d2      	lsls	r2, r2, #27
   36aee:	d106      	bne.n	36afe <update_cache+0x4a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   36af0:	69aa      	ldr	r2, [r5, #24]
   36af2:	b922      	cbnz	r2, 36afe <update_cache+0x4a>
	if (is_preempt(_current) || is_metairq(thread)) {
   36af4:	89da      	ldrh	r2, [r3, #14]
   36af6:	2a7f      	cmp	r2, #127	; 0x7f
   36af8:	d901      	bls.n	36afe <update_cache+0x4a>
		_kernel.ready_q.cache = _current;
   36afa:	6263      	str	r3, [r4, #36]	; 0x24
}
   36afc:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
   36afe:	68a3      	ldr	r3, [r4, #8]
   36b00:	42ab      	cmp	r3, r5
   36b02:	d001      	beq.n	36b08 <update_cache+0x54>
			z_reset_time_slice();
   36b04:	f7ff fd8c 	bl	36620 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   36b08:	6265      	str	r5, [r4, #36]	; 0x24
}
   36b0a:	e7f7      	b.n	36afc <update_cache+0x48>
   36b0c:	2002976c 	.word	0x2002976c
   36b10:	00043edc 	.word	0x00043edc
   36b14:	00043ea3 	.word	0x00043ea3
   36b18:	00040606 	.word	0x00040606
   36b1c:	00042742 	.word	0x00042742

00036b20 <k_sched_unlock>:
{
   36b20:	b538      	push	{r3, r4, r5, lr}
	__ASSERT(_current->base.sched_locked != 0, "");
   36b22:	4c31      	ldr	r4, [pc, #196]	; (36be8 <k_sched_unlock+0xc8>)
   36b24:	68a2      	ldr	r2, [r4, #8]
   36b26:	7bd2      	ldrb	r2, [r2, #15]
   36b28:	b972      	cbnz	r2, 36b48 <k_sched_unlock+0x28>
   36b2a:	4930      	ldr	r1, [pc, #192]	; (36bec <k_sched_unlock+0xcc>)
   36b2c:	f240 23ad 	movw	r3, #685	; 0x2ad
   36b30:	4a2f      	ldr	r2, [pc, #188]	; (36bf0 <k_sched_unlock+0xd0>)
   36b32:	4830      	ldr	r0, [pc, #192]	; (36bf4 <k_sched_unlock+0xd4>)
   36b34:	f005 fdfa 	bl	3c72c <printk>
   36b38:	482f      	ldr	r0, [pc, #188]	; (36bf8 <k_sched_unlock+0xd8>)
   36b3a:	f005 fdf7 	bl	3c72c <printk>
   36b3e:	f240 21ad 	movw	r1, #685	; 0x2ad
   36b42:	482b      	ldr	r0, [pc, #172]	; (36bf0 <k_sched_unlock+0xd0>)
   36b44:	f005 fe38 	bl	3c7b8 <assert_post_action>
   36b48:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   36b4c:	b173      	cbz	r3, 36b6c <k_sched_unlock+0x4c>
   36b4e:	492b      	ldr	r1, [pc, #172]	; (36bfc <k_sched_unlock+0xdc>)
   36b50:	f240 23ae 	movw	r3, #686	; 0x2ae
   36b54:	4a26      	ldr	r2, [pc, #152]	; (36bf0 <k_sched_unlock+0xd0>)
   36b56:	4827      	ldr	r0, [pc, #156]	; (36bf4 <k_sched_unlock+0xd4>)
   36b58:	f005 fde8 	bl	3c72c <printk>
   36b5c:	4826      	ldr	r0, [pc, #152]	; (36bf8 <k_sched_unlock+0xd8>)
   36b5e:	f005 fde5 	bl	3c72c <printk>
   36b62:	f240 21ae 	movw	r1, #686	; 0x2ae
   36b66:	4822      	ldr	r0, [pc, #136]	; (36bf0 <k_sched_unlock+0xd0>)
   36b68:	f005 fe26 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   36b6c:	f04f 0320 	mov.w	r3, #32
   36b70:	f3ef 8511 	mrs	r5, BASEPRI
   36b74:	f383 8811 	msr	BASEPRI, r3
   36b78:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   36b7c:	4820      	ldr	r0, [pc, #128]	; (36c00 <k_sched_unlock+0xe0>)
   36b7e:	f000 ffdf 	bl	37b40 <z_spin_lock_valid>
   36b82:	b968      	cbnz	r0, 36ba0 <k_sched_unlock+0x80>
   36b84:	234a      	movs	r3, #74	; 0x4a
   36b86:	4a1f      	ldr	r2, [pc, #124]	; (36c04 <k_sched_unlock+0xe4>)
   36b88:	491f      	ldr	r1, [pc, #124]	; (36c08 <k_sched_unlock+0xe8>)
   36b8a:	481a      	ldr	r0, [pc, #104]	; (36bf4 <k_sched_unlock+0xd4>)
   36b8c:	f005 fdce 	bl	3c72c <printk>
   36b90:	491b      	ldr	r1, [pc, #108]	; (36c00 <k_sched_unlock+0xe0>)
   36b92:	481e      	ldr	r0, [pc, #120]	; (36c0c <k_sched_unlock+0xec>)
   36b94:	f005 fdca 	bl	3c72c <printk>
   36b98:	214a      	movs	r1, #74	; 0x4a
   36b9a:	481a      	ldr	r0, [pc, #104]	; (36c04 <k_sched_unlock+0xe4>)
   36b9c:	f005 fe0c 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   36ba0:	4817      	ldr	r0, [pc, #92]	; (36c00 <k_sched_unlock+0xe0>)
   36ba2:	f000 ffeb 	bl	37b7c <z_spin_lock_set_owner>
		++_current->base.sched_locked;
   36ba6:	68a2      	ldr	r2, [r4, #8]
		update_cache(0);
   36ba8:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   36baa:	7bd3      	ldrb	r3, [r2, #15]
   36bac:	3301      	adds	r3, #1
   36bae:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   36bb0:	f7ff ff80 	bl	36ab4 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   36bb4:	4812      	ldr	r0, [pc, #72]	; (36c00 <k_sched_unlock+0xe0>)
   36bb6:	f000 ffd1 	bl	37b5c <z_spin_unlock_valid>
   36bba:	b968      	cbnz	r0, 36bd8 <k_sched_unlock+0xb8>
   36bbc:	235d      	movs	r3, #93	; 0x5d
   36bbe:	4a11      	ldr	r2, [pc, #68]	; (36c04 <k_sched_unlock+0xe4>)
   36bc0:	4913      	ldr	r1, [pc, #76]	; (36c10 <k_sched_unlock+0xf0>)
   36bc2:	480c      	ldr	r0, [pc, #48]	; (36bf4 <k_sched_unlock+0xd4>)
   36bc4:	f005 fdb2 	bl	3c72c <printk>
   36bc8:	490d      	ldr	r1, [pc, #52]	; (36c00 <k_sched_unlock+0xe0>)
   36bca:	4812      	ldr	r0, [pc, #72]	; (36c14 <k_sched_unlock+0xf4>)
   36bcc:	f005 fdae 	bl	3c72c <printk>
   36bd0:	215d      	movs	r1, #93	; 0x5d
   36bd2:	480c      	ldr	r0, [pc, #48]	; (36c04 <k_sched_unlock+0xe4>)
   36bd4:	f005 fdf0 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   36bd8:	f385 8811 	msr	BASEPRI, r5
   36bdc:	f3bf 8f6f 	isb	sy
}
   36be0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_unlocked();
   36be4:	f007 bcbc 	b.w	3e560 <z_reschedule_unlocked>
   36be8:	2002976c 	.word	0x2002976c
   36bec:	00043e45 	.word	0x00043e45
   36bf0:	00043ea3 	.word	0x00043ea3
   36bf4:	00040606 	.word	0x00040606
   36bf8:	00042742 	.word	0x00042742
   36bfc:	00043e0b 	.word	0x00043e0b
   36c00:	200297a4 	.word	0x200297a4
   36c04:	000405cb 	.word	0x000405cb
   36c08:	000405f1 	.word	0x000405f1
   36c0c:	00040623 	.word	0x00040623
   36c10:	00040665 	.word	0x00040665
   36c14:	0004067c 	.word	0x0004067c

00036c18 <z_add_thread_to_ready_q>:
{
   36c18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   36c1a:	4604      	mov	r4, r0
	__asm__ volatile(
   36c1c:	f04f 0320 	mov.w	r3, #32
   36c20:	f3ef 8511 	mrs	r5, BASEPRI
   36c24:	f383 8811 	msr	BASEPRI, r3
   36c28:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   36c2c:	482f      	ldr	r0, [pc, #188]	; (36cec <z_add_thread_to_ready_q+0xd4>)
   36c2e:	f000 ff87 	bl	37b40 <z_spin_lock_valid>
   36c32:	b968      	cbnz	r0, 36c50 <z_add_thread_to_ready_q+0x38>
   36c34:	234a      	movs	r3, #74	; 0x4a
   36c36:	4a2e      	ldr	r2, [pc, #184]	; (36cf0 <z_add_thread_to_ready_q+0xd8>)
   36c38:	492e      	ldr	r1, [pc, #184]	; (36cf4 <z_add_thread_to_ready_q+0xdc>)
   36c3a:	482f      	ldr	r0, [pc, #188]	; (36cf8 <z_add_thread_to_ready_q+0xe0>)
   36c3c:	f005 fd76 	bl	3c72c <printk>
   36c40:	492a      	ldr	r1, [pc, #168]	; (36cec <z_add_thread_to_ready_q+0xd4>)
   36c42:	482e      	ldr	r0, [pc, #184]	; (36cfc <z_add_thread_to_ready_q+0xe4>)
   36c44:	f005 fd72 	bl	3c72c <printk>
   36c48:	214a      	movs	r1, #74	; 0x4a
   36c4a:	4829      	ldr	r0, [pc, #164]	; (36cf0 <z_add_thread_to_ready_q+0xd8>)
   36c4c:	f005 fdb4 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   36c50:	4826      	ldr	r0, [pc, #152]	; (36cec <z_add_thread_to_ready_q+0xd4>)
   36c52:	f000 ff93 	bl	37b7c <z_spin_lock_set_owner>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   36c56:	4b2a      	ldr	r3, [pc, #168]	; (36d00 <z_add_thread_to_ready_q+0xe8>)
   36c58:	429c      	cmp	r4, r3
   36c5a:	d10b      	bne.n	36c74 <z_add_thread_to_ready_q+0x5c>
   36c5c:	4929      	ldr	r1, [pc, #164]	; (36d04 <z_add_thread_to_ready_q+0xec>)
   36c5e:	4826      	ldr	r0, [pc, #152]	; (36cf8 <z_add_thread_to_ready_q+0xe0>)
   36c60:	f240 3302 	movw	r3, #770	; 0x302
   36c64:	4a28      	ldr	r2, [pc, #160]	; (36d08 <z_add_thread_to_ready_q+0xf0>)
   36c66:	f005 fd61 	bl	3c72c <printk>
   36c6a:	f240 3102 	movw	r1, #770	; 0x302
   36c6e:	4826      	ldr	r0, [pc, #152]	; (36d08 <z_add_thread_to_ready_q+0xf0>)
   36c70:	f005 fda2 	bl	3c7b8 <assert_post_action>
	return list->head == list;
   36c74:	4a25      	ldr	r2, [pc, #148]	; (36d0c <z_add_thread_to_ready_q+0xf4>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
   36c76:	f102 0128 	add.w	r1, r2, #40	; 0x28
   36c7a:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
   36c7e:	428b      	cmp	r3, r1
   36c80:	d02e      	beq.n	36ce0 <z_add_thread_to_ready_q+0xc8>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   36c82:	b36b      	cbz	r3, 36ce0 <z_add_thread_to_ready_q+0xc8>
	if (thread_1->base.prio < thread_2->base.prio) {
   36c84:	f994 600e 	ldrsb.w	r6, [r4, #14]
   36c88:	f993 700e 	ldrsb.w	r7, [r3, #14]
   36c8c:	42b7      	cmp	r7, r6
   36c8e:	dd22      	ble.n	36cd6 <z_add_thread_to_ready_q+0xbe>
	node->prev = successor->prev;
   36c90:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   36c92:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   36c96:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   36c98:	605c      	str	r4, [r3, #4]
	thread->base.thread_state |= states;
   36c9a:	7b63      	ldrb	r3, [r4, #13]
		update_cache(0);
   36c9c:	2000      	movs	r0, #0
   36c9e:	f063 037f 	orn	r3, r3, #127	; 0x7f
   36ca2:	7363      	strb	r3, [r4, #13]
   36ca4:	f7ff ff06 	bl	36ab4 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   36ca8:	4810      	ldr	r0, [pc, #64]	; (36cec <z_add_thread_to_ready_q+0xd4>)
   36caa:	f000 ff57 	bl	37b5c <z_spin_unlock_valid>
   36cae:	b968      	cbnz	r0, 36ccc <z_add_thread_to_ready_q+0xb4>
   36cb0:	235d      	movs	r3, #93	; 0x5d
   36cb2:	4a0f      	ldr	r2, [pc, #60]	; (36cf0 <z_add_thread_to_ready_q+0xd8>)
   36cb4:	4916      	ldr	r1, [pc, #88]	; (36d10 <z_add_thread_to_ready_q+0xf8>)
   36cb6:	4810      	ldr	r0, [pc, #64]	; (36cf8 <z_add_thread_to_ready_q+0xe0>)
   36cb8:	f005 fd38 	bl	3c72c <printk>
   36cbc:	490b      	ldr	r1, [pc, #44]	; (36cec <z_add_thread_to_ready_q+0xd4>)
   36cbe:	4815      	ldr	r0, [pc, #84]	; (36d14 <z_add_thread_to_ready_q+0xfc>)
   36cc0:	f005 fd34 	bl	3c72c <printk>
   36cc4:	215d      	movs	r1, #93	; 0x5d
   36cc6:	480a      	ldr	r0, [pc, #40]	; (36cf0 <z_add_thread_to_ready_q+0xd8>)
   36cc8:	f005 fd76 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   36ccc:	f385 8811 	msr	BASEPRI, r5
   36cd0:	f3bf 8f6f 	isb	sy
}
   36cd4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   36cd6:	4298      	cmp	r0, r3
   36cd8:	d002      	beq.n	36ce0 <z_add_thread_to_ready_q+0xc8>
   36cda:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   36cdc:	2b00      	cmp	r3, #0
   36cde:	d1d3      	bne.n	36c88 <z_add_thread_to_ready_q+0x70>
	node->prev = list->tail;
   36ce0:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   36ce4:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   36ce6:	601c      	str	r4, [r3, #0]
	list->tail = node;
   36ce8:	62d4      	str	r4, [r2, #44]	; 0x2c
   36cea:	e7d6      	b.n	36c9a <z_add_thread_to_ready_q+0x82>
   36cec:	200297a4 	.word	0x200297a4
   36cf0:	000405cb 	.word	0x000405cb
   36cf4:	000405f1 	.word	0x000405f1
   36cf8:	00040606 	.word	0x00040606
   36cfc:	00040623 	.word	0x00040623
   36d00:	2002559c 	.word	0x2002559c
   36d04:	00043efb 	.word	0x00043efb
   36d08:	00043ea3 	.word	0x00043ea3
   36d0c:	2002976c 	.word	0x2002976c
   36d10:	00040665 	.word	0x00040665
   36d14:	0004067c 	.word	0x0004067c

00036d18 <z_thread_timeout>:
	if (thread->base.pended_on != NULL) {
   36d18:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
   36d1c:	b570      	push	{r4, r5, r6, lr}
   36d1e:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
   36d20:	f1a0 0518 	sub.w	r5, r0, #24
	if (thread->base.pended_on != NULL) {
   36d24:	2b00      	cmp	r3, #0
   36d26:	d042      	beq.n	36dae <z_thread_timeout+0x96>
	__asm__ volatile(
   36d28:	f04f 0320 	mov.w	r3, #32
   36d2c:	f3ef 8611 	mrs	r6, BASEPRI
   36d30:	f383 8811 	msr	BASEPRI, r3
   36d34:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   36d38:	4825      	ldr	r0, [pc, #148]	; (36dd0 <z_thread_timeout+0xb8>)
   36d3a:	f000 ff01 	bl	37b40 <z_spin_lock_valid>
   36d3e:	b968      	cbnz	r0, 36d5c <z_thread_timeout+0x44>
   36d40:	234a      	movs	r3, #74	; 0x4a
   36d42:	4a24      	ldr	r2, [pc, #144]	; (36dd4 <z_thread_timeout+0xbc>)
   36d44:	4924      	ldr	r1, [pc, #144]	; (36dd8 <z_thread_timeout+0xc0>)
   36d46:	4825      	ldr	r0, [pc, #148]	; (36ddc <z_thread_timeout+0xc4>)
   36d48:	f005 fcf0 	bl	3c72c <printk>
   36d4c:	4920      	ldr	r1, [pc, #128]	; (36dd0 <z_thread_timeout+0xb8>)
   36d4e:	4824      	ldr	r0, [pc, #144]	; (36de0 <z_thread_timeout+0xc8>)
   36d50:	f005 fcec 	bl	3c72c <printk>
   36d54:	214a      	movs	r1, #74	; 0x4a
   36d56:	481f      	ldr	r0, [pc, #124]	; (36dd4 <z_thread_timeout+0xbc>)
   36d58:	f005 fd2e 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   36d5c:	481c      	ldr	r0, [pc, #112]	; (36dd0 <z_thread_timeout+0xb8>)
   36d5e:	f000 ff0d 	bl	37b7c <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   36d62:	f1a4 0010 	sub.w	r0, r4, #16
   36d66:	f7ff fc43 	bl	365f0 <pended_on.isra.17>
   36d6a:	4629      	mov	r1, r5
   36d6c:	f7ff fe1e 	bl	369ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   36d70:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   36d74:	4816      	ldr	r0, [pc, #88]	; (36dd0 <z_thread_timeout+0xb8>)
   36d76:	f023 0302 	bic.w	r3, r3, #2
   36d7a:	f804 3c0b 	strb.w	r3, [r4, #-11]
   36d7e:	f000 feed 	bl	37b5c <z_spin_unlock_valid>
   36d82:	b968      	cbnz	r0, 36da0 <z_thread_timeout+0x88>
   36d84:	235d      	movs	r3, #93	; 0x5d
   36d86:	4a13      	ldr	r2, [pc, #76]	; (36dd4 <z_thread_timeout+0xbc>)
   36d88:	4916      	ldr	r1, [pc, #88]	; (36de4 <z_thread_timeout+0xcc>)
   36d8a:	4814      	ldr	r0, [pc, #80]	; (36ddc <z_thread_timeout+0xc4>)
   36d8c:	f005 fcce 	bl	3c72c <printk>
   36d90:	490f      	ldr	r1, [pc, #60]	; (36dd0 <z_thread_timeout+0xb8>)
   36d92:	4815      	ldr	r0, [pc, #84]	; (36de8 <z_thread_timeout+0xd0>)
   36d94:	f005 fcca 	bl	3c72c <printk>
   36d98:	215d      	movs	r1, #93	; 0x5d
   36d9a:	480e      	ldr	r0, [pc, #56]	; (36dd4 <z_thread_timeout+0xbc>)
   36d9c:	f005 fd0c 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   36da0:	f386 8811 	msr	BASEPRI, r6
   36da4:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   36da8:	2300      	movs	r3, #0
   36daa:	f844 3c10 	str.w	r3, [r4, #-16]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   36dae:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
   36db2:	4628      	mov	r0, r5
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   36db4:	f023 0314 	bic.w	r3, r3, #20
   36db8:	f804 3c0b 	strb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
   36dbc:	f007 fbb2 	bl	3e524 <z_is_thread_ready>
   36dc0:	b120      	cbz	r0, 36dcc <z_thread_timeout+0xb4>
		z_add_thread_to_ready_q(thread);
   36dc2:	4628      	mov	r0, r5
}
   36dc4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   36dc8:	f7ff bf26 	b.w	36c18 <z_add_thread_to_ready_q>
   36dcc:	bd70      	pop	{r4, r5, r6, pc}
   36dce:	bf00      	nop
   36dd0:	200297a4 	.word	0x200297a4
   36dd4:	000405cb 	.word	0x000405cb
   36dd8:	000405f1 	.word	0x000405f1
   36ddc:	00040606 	.word	0x00040606
   36de0:	00040623 	.word	0x00040623
   36de4:	00040665 	.word	0x00040665
   36de8:	0004067c 	.word	0x0004067c

00036dec <z_move_thread_to_end_of_prio_q>:
{
   36dec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   36dee:	4604      	mov	r4, r0
	__asm__ volatile(
   36df0:	f04f 0320 	mov.w	r3, #32
   36df4:	f3ef 8511 	mrs	r5, BASEPRI
   36df8:	f383 8811 	msr	BASEPRI, r3
   36dfc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   36e00:	4835      	ldr	r0, [pc, #212]	; (36ed8 <z_move_thread_to_end_of_prio_q+0xec>)
   36e02:	f000 fe9d 	bl	37b40 <z_spin_lock_valid>
   36e06:	b968      	cbnz	r0, 36e24 <z_move_thread_to_end_of_prio_q+0x38>
   36e08:	234a      	movs	r3, #74	; 0x4a
   36e0a:	4a34      	ldr	r2, [pc, #208]	; (36edc <z_move_thread_to_end_of_prio_q+0xf0>)
   36e0c:	4934      	ldr	r1, [pc, #208]	; (36ee0 <z_move_thread_to_end_of_prio_q+0xf4>)
   36e0e:	4835      	ldr	r0, [pc, #212]	; (36ee4 <z_move_thread_to_end_of_prio_q+0xf8>)
   36e10:	f005 fc8c 	bl	3c72c <printk>
   36e14:	4930      	ldr	r1, [pc, #192]	; (36ed8 <z_move_thread_to_end_of_prio_q+0xec>)
   36e16:	4834      	ldr	r0, [pc, #208]	; (36ee8 <z_move_thread_to_end_of_prio_q+0xfc>)
   36e18:	f005 fc88 	bl	3c72c <printk>
   36e1c:	214a      	movs	r1, #74	; 0x4a
   36e1e:	482f      	ldr	r0, [pc, #188]	; (36edc <z_move_thread_to_end_of_prio_q+0xf0>)
   36e20:	f005 fcca 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   36e24:	482c      	ldr	r0, [pc, #176]	; (36ed8 <z_move_thread_to_end_of_prio_q+0xec>)
   36e26:	f000 fea9 	bl	37b7c <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
   36e2a:	f994 300d 	ldrsb.w	r3, [r4, #13]
   36e2e:	2b00      	cmp	r3, #0
   36e30:	da03      	bge.n	36e3a <z_move_thread_to_end_of_prio_q+0x4e>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   36e32:	4621      	mov	r1, r4
   36e34:	482d      	ldr	r0, [pc, #180]	; (36eec <z_move_thread_to_end_of_prio_q+0x100>)
   36e36:	f7ff fdb9 	bl	369ac <z_priq_dumb_remove>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   36e3a:	4b2d      	ldr	r3, [pc, #180]	; (36ef0 <z_move_thread_to_end_of_prio_q+0x104>)
   36e3c:	429c      	cmp	r4, r3
   36e3e:	d10b      	bne.n	36e58 <z_move_thread_to_end_of_prio_q+0x6c>
   36e40:	492c      	ldr	r1, [pc, #176]	; (36ef4 <z_move_thread_to_end_of_prio_q+0x108>)
   36e42:	4828      	ldr	r0, [pc, #160]	; (36ee4 <z_move_thread_to_end_of_prio_q+0xf8>)
   36e44:	f240 3302 	movw	r3, #770	; 0x302
   36e48:	4a2b      	ldr	r2, [pc, #172]	; (36ef8 <z_move_thread_to_end_of_prio_q+0x10c>)
   36e4a:	f005 fc6f 	bl	3c72c <printk>
   36e4e:	f240 3102 	movw	r1, #770	; 0x302
   36e52:	4829      	ldr	r0, [pc, #164]	; (36ef8 <z_move_thread_to_end_of_prio_q+0x10c>)
   36e54:	f005 fcb0 	bl	3c7b8 <assert_post_action>
	return list->head == list;
   36e58:	4a28      	ldr	r2, [pc, #160]	; (36efc <z_move_thread_to_end_of_prio_q+0x110>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
   36e5a:	f102 0128 	add.w	r1, r2, #40	; 0x28
   36e5e:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
   36e62:	428b      	cmp	r3, r1
   36e64:	d032      	beq.n	36ecc <z_move_thread_to_end_of_prio_q+0xe0>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   36e66:	2b00      	cmp	r3, #0
   36e68:	d030      	beq.n	36ecc <z_move_thread_to_end_of_prio_q+0xe0>
	if (thread_1->base.prio < thread_2->base.prio) {
   36e6a:	f994 600e 	ldrsb.w	r6, [r4, #14]
   36e6e:	f993 700e 	ldrsb.w	r7, [r3, #14]
   36e72:	42b7      	cmp	r7, r6
   36e74:	dd25      	ble.n	36ec2 <z_move_thread_to_end_of_prio_q+0xd6>
	node->prev = successor->prev;
   36e76:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   36e78:	e9c4 3100 	strd	r3, r1, [r4]
	successor->prev->next = node;
   36e7c:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   36e7e:	605c      	str	r4, [r3, #4]
	thread->base.thread_state |= states;
   36e80:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
   36e82:	6890      	ldr	r0, [r2, #8]
   36e84:	f063 037f 	orn	r3, r3, #127	; 0x7f
   36e88:	7363      	strb	r3, [r4, #13]
   36e8a:	1b03      	subs	r3, r0, r4
   36e8c:	4258      	negs	r0, r3
   36e8e:	4158      	adcs	r0, r3
   36e90:	f7ff fe10 	bl	36ab4 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   36e94:	4810      	ldr	r0, [pc, #64]	; (36ed8 <z_move_thread_to_end_of_prio_q+0xec>)
   36e96:	f000 fe61 	bl	37b5c <z_spin_unlock_valid>
   36e9a:	b968      	cbnz	r0, 36eb8 <z_move_thread_to_end_of_prio_q+0xcc>
   36e9c:	235d      	movs	r3, #93	; 0x5d
   36e9e:	4a0f      	ldr	r2, [pc, #60]	; (36edc <z_move_thread_to_end_of_prio_q+0xf0>)
   36ea0:	4917      	ldr	r1, [pc, #92]	; (36f00 <z_move_thread_to_end_of_prio_q+0x114>)
   36ea2:	4810      	ldr	r0, [pc, #64]	; (36ee4 <z_move_thread_to_end_of_prio_q+0xf8>)
   36ea4:	f005 fc42 	bl	3c72c <printk>
   36ea8:	490b      	ldr	r1, [pc, #44]	; (36ed8 <z_move_thread_to_end_of_prio_q+0xec>)
   36eaa:	4816      	ldr	r0, [pc, #88]	; (36f04 <z_move_thread_to_end_of_prio_q+0x118>)
   36eac:	f005 fc3e 	bl	3c72c <printk>
   36eb0:	215d      	movs	r1, #93	; 0x5d
   36eb2:	480a      	ldr	r0, [pc, #40]	; (36edc <z_move_thread_to_end_of_prio_q+0xf0>)
   36eb4:	f005 fc80 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   36eb8:	f385 8811 	msr	BASEPRI, r5
   36ebc:	f3bf 8f6f 	isb	sy
}
   36ec0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   36ec2:	4298      	cmp	r0, r3
   36ec4:	d002      	beq.n	36ecc <z_move_thread_to_end_of_prio_q+0xe0>
   36ec6:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   36ec8:	2b00      	cmp	r3, #0
   36eca:	d1d0      	bne.n	36e6e <z_move_thread_to_end_of_prio_q+0x82>
	node->prev = list->tail;
   36ecc:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   36ed0:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   36ed2:	601c      	str	r4, [r3, #0]
	list->tail = node;
   36ed4:	62d4      	str	r4, [r2, #44]	; 0x2c
   36ed6:	e7d3      	b.n	36e80 <z_move_thread_to_end_of_prio_q+0x94>
   36ed8:	200297a4 	.word	0x200297a4
   36edc:	000405cb 	.word	0x000405cb
   36ee0:	000405f1 	.word	0x000405f1
   36ee4:	00040606 	.word	0x00040606
   36ee8:	00040623 	.word	0x00040623
   36eec:	20029794 	.word	0x20029794
   36ef0:	2002559c 	.word	0x2002559c
   36ef4:	00043efb 	.word	0x00043efb
   36ef8:	00043ea3 	.word	0x00043ea3
   36efc:	2002976c 	.word	0x2002976c
   36f00:	00040665 	.word	0x00040665
   36f04:	0004067c 	.word	0x0004067c

00036f08 <z_time_slice>:
	if (pending_current == _current) {
   36f08:	4a15      	ldr	r2, [pc, #84]	; (36f60 <z_time_slice+0x58>)
   36f0a:	4916      	ldr	r1, [pc, #88]	; (36f64 <z_time_slice+0x5c>)
{
   36f0c:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
   36f0e:	680c      	ldr	r4, [r1, #0]
   36f10:	6893      	ldr	r3, [r2, #8]
   36f12:	42a3      	cmp	r3, r4
   36f14:	4614      	mov	r4, r2
   36f16:	d103      	bne.n	36f20 <z_time_slice+0x18>
}
   36f18:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
   36f1c:	f7ff bb80 	b.w	36620 <z_reset_time_slice>
	pending_current = NULL;
   36f20:	2500      	movs	r5, #0
   36f22:	600d      	str	r5, [r1, #0]
	if (slice_time && sliceable(_current)) {
   36f24:	4910      	ldr	r1, [pc, #64]	; (36f68 <z_time_slice+0x60>)
   36f26:	6809      	ldr	r1, [r1, #0]
   36f28:	b1b9      	cbz	r1, 36f5a <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   36f2a:	89d9      	ldrh	r1, [r3, #14]
   36f2c:	297f      	cmp	r1, #127	; 0x7f
   36f2e:	d814      	bhi.n	36f5a <z_time_slice+0x52>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   36f30:	490e      	ldr	r1, [pc, #56]	; (36f6c <z_time_slice+0x64>)
   36f32:	f993 500e 	ldrsb.w	r5, [r3, #14]
   36f36:	6809      	ldr	r1, [r1, #0]
   36f38:	428d      	cmp	r5, r1
   36f3a:	db0e      	blt.n	36f5a <z_time_slice+0x52>
		&& !z_is_idle_thread_object(thread)
   36f3c:	490c      	ldr	r1, [pc, #48]	; (36f70 <z_time_slice+0x68>)
   36f3e:	428b      	cmp	r3, r1
   36f40:	d00b      	beq.n	36f5a <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   36f42:	6999      	ldr	r1, [r3, #24]
   36f44:	b949      	cbnz	r1, 36f5a <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
   36f46:	6911      	ldr	r1, [r2, #16]
   36f48:	4281      	cmp	r1, r0
   36f4a:	dc03      	bgt.n	36f54 <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
   36f4c:	4618      	mov	r0, r3
   36f4e:	f7ff ff4d 	bl	36dec <z_move_thread_to_end_of_prio_q>
   36f52:	e7e1      	b.n	36f18 <z_time_slice+0x10>
			_current_cpu->slice_ticks -= ticks;
   36f54:	1a09      	subs	r1, r1, r0
   36f56:	6111      	str	r1, [r2, #16]
}
   36f58:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
   36f5a:	2300      	movs	r3, #0
   36f5c:	6123      	str	r3, [r4, #16]
   36f5e:	e7fb      	b.n	36f58 <z_time_slice+0x50>
   36f60:	2002976c 	.word	0x2002976c
   36f64:	200297a0 	.word	0x200297a0
   36f68:	200297ac 	.word	0x200297ac
   36f6c:	200297a8 	.word	0x200297a8
   36f70:	2002559c 	.word	0x2002559c

00036f74 <z_thread_single_suspend>:
{
   36f74:	b570      	push	{r4, r5, r6, lr}
   36f76:	4604      	mov	r4, r0
   36f78:	3018      	adds	r0, #24
   36f7a:	f001 f921 	bl	381c0 <z_abort_timeout>
	__asm__ volatile(
   36f7e:	f04f 0320 	mov.w	r3, #32
   36f82:	f3ef 8611 	mrs	r6, BASEPRI
   36f86:	f383 8811 	msr	BASEPRI, r3
   36f8a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   36f8e:	4825      	ldr	r0, [pc, #148]	; (37024 <z_thread_single_suspend+0xb0>)
   36f90:	f000 fdd6 	bl	37b40 <z_spin_lock_valid>
   36f94:	b968      	cbnz	r0, 36fb2 <z_thread_single_suspend+0x3e>
   36f96:	234a      	movs	r3, #74	; 0x4a
   36f98:	4a23      	ldr	r2, [pc, #140]	; (37028 <z_thread_single_suspend+0xb4>)
   36f9a:	4924      	ldr	r1, [pc, #144]	; (3702c <z_thread_single_suspend+0xb8>)
   36f9c:	4824      	ldr	r0, [pc, #144]	; (37030 <z_thread_single_suspend+0xbc>)
   36f9e:	f005 fbc5 	bl	3c72c <printk>
   36fa2:	4920      	ldr	r1, [pc, #128]	; (37024 <z_thread_single_suspend+0xb0>)
   36fa4:	4823      	ldr	r0, [pc, #140]	; (37034 <z_thread_single_suspend+0xc0>)
   36fa6:	f005 fbc1 	bl	3c72c <printk>
   36faa:	214a      	movs	r1, #74	; 0x4a
   36fac:	481e      	ldr	r0, [pc, #120]	; (37028 <z_thread_single_suspend+0xb4>)
   36fae:	f005 fc03 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   36fb2:	481c      	ldr	r0, [pc, #112]	; (37024 <z_thread_single_suspend+0xb0>)
   36fb4:	f000 fde2 	bl	37b7c <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
   36fb8:	f994 300d 	ldrsb.w	r3, [r4, #13]
   36fbc:	2b00      	cmp	r3, #0
   36fbe:	da07      	bge.n	36fd0 <z_thread_single_suspend+0x5c>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   36fc0:	4621      	mov	r1, r4
   36fc2:	481d      	ldr	r0, [pc, #116]	; (37038 <z_thread_single_suspend+0xc4>)
   36fc4:	f7ff fcf2 	bl	369ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   36fc8:	7b63      	ldrb	r3, [r4, #13]
   36fca:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   36fce:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   36fd0:	4d1a      	ldr	r5, [pc, #104]	; (3703c <z_thread_single_suspend+0xc8>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   36fd2:	7b63      	ldrb	r3, [r4, #13]
   36fd4:	68a8      	ldr	r0, [r5, #8]
   36fd6:	f043 0310 	orr.w	r3, r3, #16
   36fda:	7363      	strb	r3, [r4, #13]
   36fdc:	1b03      	subs	r3, r0, r4
   36fde:	4258      	negs	r0, r3
   36fe0:	4158      	adcs	r0, r3
   36fe2:	f7ff fd67 	bl	36ab4 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   36fe6:	480f      	ldr	r0, [pc, #60]	; (37024 <z_thread_single_suspend+0xb0>)
   36fe8:	f000 fdb8 	bl	37b5c <z_spin_unlock_valid>
   36fec:	b968      	cbnz	r0, 3700a <z_thread_single_suspend+0x96>
   36fee:	235d      	movs	r3, #93	; 0x5d
   36ff0:	4a0d      	ldr	r2, [pc, #52]	; (37028 <z_thread_single_suspend+0xb4>)
   36ff2:	4913      	ldr	r1, [pc, #76]	; (37040 <z_thread_single_suspend+0xcc>)
   36ff4:	480e      	ldr	r0, [pc, #56]	; (37030 <z_thread_single_suspend+0xbc>)
   36ff6:	f005 fb99 	bl	3c72c <printk>
   36ffa:	490a      	ldr	r1, [pc, #40]	; (37024 <z_thread_single_suspend+0xb0>)
   36ffc:	4811      	ldr	r0, [pc, #68]	; (37044 <z_thread_single_suspend+0xd0>)
   36ffe:	f005 fb95 	bl	3c72c <printk>
   37002:	215d      	movs	r1, #93	; 0x5d
   37004:	4808      	ldr	r0, [pc, #32]	; (37028 <z_thread_single_suspend+0xb4>)
   37006:	f005 fbd7 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   3700a:	f386 8811 	msr	BASEPRI, r6
   3700e:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   37012:	68ab      	ldr	r3, [r5, #8]
   37014:	42a3      	cmp	r3, r4
   37016:	d103      	bne.n	37020 <z_thread_single_suspend+0xac>
}
   37018:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   3701c:	f007 baa0 	b.w	3e560 <z_reschedule_unlocked>
}
   37020:	bd70      	pop	{r4, r5, r6, pc}
   37022:	bf00      	nop
   37024:	200297a4 	.word	0x200297a4
   37028:	000405cb 	.word	0x000405cb
   3702c:	000405f1 	.word	0x000405f1
   37030:	00040606 	.word	0x00040606
   37034:	00040623 	.word	0x00040623
   37038:	20029794 	.word	0x20029794
   3703c:	2002976c 	.word	0x2002976c
   37040:	00040665 	.word	0x00040665
   37044:	0004067c 	.word	0x0004067c

00037048 <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
   37048:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
   3704a:	b570      	push	{r4, r5, r6, lr}
   3704c:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
   3704e:	b103      	cbz	r3, 37052 <z_thread_single_abort+0xa>
		thread->fn_abort();
   37050:	4798      	blx	r3
   37052:	f104 0018 	add.w	r0, r4, #24
   37056:	f001 f8b3 	bl	381c0 <z_abort_timeout>
	__asm__ volatile(
   3705a:	f04f 0320 	mov.w	r3, #32
   3705e:	f3ef 8511 	mrs	r5, BASEPRI
   37062:	f383 8811 	msr	BASEPRI, r3
   37066:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   3706a:	482c      	ldr	r0, [pc, #176]	; (3711c <z_thread_single_abort+0xd4>)
   3706c:	f000 fd68 	bl	37b40 <z_spin_lock_valid>
   37070:	b968      	cbnz	r0, 3708e <z_thread_single_abort+0x46>
   37072:	234a      	movs	r3, #74	; 0x4a
   37074:	4a2a      	ldr	r2, [pc, #168]	; (37120 <z_thread_single_abort+0xd8>)
   37076:	492b      	ldr	r1, [pc, #172]	; (37124 <z_thread_single_abort+0xdc>)
   37078:	482b      	ldr	r0, [pc, #172]	; (37128 <z_thread_single_abort+0xe0>)
   3707a:	f005 fb57 	bl	3c72c <printk>
   3707e:	4927      	ldr	r1, [pc, #156]	; (3711c <z_thread_single_abort+0xd4>)
   37080:	482a      	ldr	r0, [pc, #168]	; (3712c <z_thread_single_abort+0xe4>)
   37082:	f005 fb53 	bl	3c72c <printk>
   37086:	214a      	movs	r1, #74	; 0x4a
   37088:	4825      	ldr	r0, [pc, #148]	; (37120 <z_thread_single_abort+0xd8>)
   3708a:	f005 fb95 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   3708e:	4823      	ldr	r0, [pc, #140]	; (3711c <z_thread_single_abort+0xd4>)
   37090:	f000 fd74 	bl	37b7c <z_spin_lock_set_owner>
		if (z_is_thread_ready(thread)) {
   37094:	4620      	mov	r0, r4
   37096:	f007 fa45 	bl	3e524 <z_is_thread_ready>
   3709a:	4606      	mov	r6, r0
   3709c:	b368      	cbz	r0, 370fa <z_thread_single_abort+0xb2>
			if (z_is_thread_queued(thread)) {
   3709e:	f994 300d 	ldrsb.w	r3, [r4, #13]
   370a2:	2b00      	cmp	r3, #0
   370a4:	da07      	bge.n	370b6 <z_thread_single_abort+0x6e>
				_priq_run_remove(&_kernel.ready_q.runq,
   370a6:	4621      	mov	r1, r4
   370a8:	4821      	ldr	r0, [pc, #132]	; (37130 <z_thread_single_abort+0xe8>)
   370aa:	f7ff fc7f 	bl	369ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   370ae:	7b63      	ldrb	r3, [r4, #13]
   370b0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   370b4:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
   370b6:	4b1f      	ldr	r3, [pc, #124]	; (37134 <z_thread_single_abort+0xec>)
   370b8:	6898      	ldr	r0, [r3, #8]
   370ba:	1b02      	subs	r2, r0, r4
   370bc:	4250      	negs	r0, r2
   370be:	4150      	adcs	r0, r2
   370c0:	f7ff fcf8 	bl	36ab4 <update_cache>
		thread->base.thread_state |= mask;
   370c4:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   370c6:	4815      	ldr	r0, [pc, #84]	; (3711c <z_thread_single_abort+0xd4>)
   370c8:	f043 0308 	orr.w	r3, r3, #8
   370cc:	7363      	strb	r3, [r4, #13]
   370ce:	f000 fd45 	bl	37b5c <z_spin_unlock_valid>
   370d2:	b968      	cbnz	r0, 370f0 <z_thread_single_abort+0xa8>
   370d4:	235d      	movs	r3, #93	; 0x5d
   370d6:	4a12      	ldr	r2, [pc, #72]	; (37120 <z_thread_single_abort+0xd8>)
   370d8:	4917      	ldr	r1, [pc, #92]	; (37138 <z_thread_single_abort+0xf0>)
   370da:	4813      	ldr	r0, [pc, #76]	; (37128 <z_thread_single_abort+0xe0>)
   370dc:	f005 fb26 	bl	3c72c <printk>
   370e0:	490e      	ldr	r1, [pc, #56]	; (3711c <z_thread_single_abort+0xd4>)
   370e2:	4816      	ldr	r0, [pc, #88]	; (3713c <z_thread_single_abort+0xf4>)
   370e4:	f005 fb22 	bl	3c72c <printk>
   370e8:	215d      	movs	r1, #93	; 0x5d
   370ea:	480d      	ldr	r0, [pc, #52]	; (37120 <z_thread_single_abort+0xd8>)
   370ec:	f005 fb64 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   370f0:	f385 8811 	msr	BASEPRI, r5
   370f4:	f3bf 8f6f 	isb	sy
}
   370f8:	bd70      	pop	{r4, r5, r6, pc}
			if (z_is_thread_pending(thread)) {
   370fa:	7b63      	ldrb	r3, [r4, #13]
   370fc:	079b      	lsls	r3, r3, #30
   370fe:	d5e1      	bpl.n	370c4 <z_thread_single_abort+0x7c>
				_priq_wait_remove(&pended_on(thread)->waitq,
   37100:	f104 0008 	add.w	r0, r4, #8
   37104:	f7ff fa74 	bl	365f0 <pended_on.isra.17>
   37108:	4621      	mov	r1, r4
   3710a:	f7ff fc4f 	bl	369ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   3710e:	7b63      	ldrb	r3, [r4, #13]
				thread->base.pended_on = NULL;
   37110:	60a6      	str	r6, [r4, #8]
   37112:	f023 0302 	bic.w	r3, r3, #2
   37116:	7363      	strb	r3, [r4, #13]
   37118:	e7d4      	b.n	370c4 <z_thread_single_abort+0x7c>
   3711a:	bf00      	nop
   3711c:	200297a4 	.word	0x200297a4
   37120:	000405cb 	.word	0x000405cb
   37124:	000405f1 	.word	0x000405f1
   37128:	00040606 	.word	0x00040606
   3712c:	00040623 	.word	0x00040623
   37130:	20029794 	.word	0x20029794
   37134:	2002976c 	.word	0x2002976c
   37138:	00040665 	.word	0x00040665
   3713c:	0004067c 	.word	0x0004067c

00037140 <z_remove_thread_from_ready_q>:
{
   37140:	b538      	push	{r3, r4, r5, lr}
   37142:	4604      	mov	r4, r0
	__asm__ volatile(
   37144:	f04f 0320 	mov.w	r3, #32
   37148:	f3ef 8511 	mrs	r5, BASEPRI
   3714c:	f383 8811 	msr	BASEPRI, r3
   37150:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   37154:	481f      	ldr	r0, [pc, #124]	; (371d4 <z_remove_thread_from_ready_q+0x94>)
   37156:	f000 fcf3 	bl	37b40 <z_spin_lock_valid>
   3715a:	b968      	cbnz	r0, 37178 <z_remove_thread_from_ready_q+0x38>
   3715c:	234a      	movs	r3, #74	; 0x4a
   3715e:	4a1e      	ldr	r2, [pc, #120]	; (371d8 <z_remove_thread_from_ready_q+0x98>)
   37160:	491e      	ldr	r1, [pc, #120]	; (371dc <z_remove_thread_from_ready_q+0x9c>)
   37162:	481f      	ldr	r0, [pc, #124]	; (371e0 <z_remove_thread_from_ready_q+0xa0>)
   37164:	f005 fae2 	bl	3c72c <printk>
   37168:	491a      	ldr	r1, [pc, #104]	; (371d4 <z_remove_thread_from_ready_q+0x94>)
   3716a:	481e      	ldr	r0, [pc, #120]	; (371e4 <z_remove_thread_from_ready_q+0xa4>)
   3716c:	f005 fade 	bl	3c72c <printk>
   37170:	214a      	movs	r1, #74	; 0x4a
   37172:	4819      	ldr	r0, [pc, #100]	; (371d8 <z_remove_thread_from_ready_q+0x98>)
   37174:	f005 fb20 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   37178:	4816      	ldr	r0, [pc, #88]	; (371d4 <z_remove_thread_from_ready_q+0x94>)
   3717a:	f000 fcff 	bl	37b7c <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
   3717e:	f994 300d 	ldrsb.w	r3, [r4, #13]
   37182:	2b00      	cmp	r3, #0
   37184:	da07      	bge.n	37196 <z_remove_thread_from_ready_q+0x56>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   37186:	4621      	mov	r1, r4
   37188:	4817      	ldr	r0, [pc, #92]	; (371e8 <z_remove_thread_from_ready_q+0xa8>)
   3718a:	f7ff fc0f 	bl	369ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   3718e:	7b63      	ldrb	r3, [r4, #13]
   37190:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   37194:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   37196:	4b15      	ldr	r3, [pc, #84]	; (371ec <z_remove_thread_from_ready_q+0xac>)
   37198:	6898      	ldr	r0, [r3, #8]
   3719a:	1b03      	subs	r3, r0, r4
   3719c:	4258      	negs	r0, r3
   3719e:	4158      	adcs	r0, r3
   371a0:	f7ff fc88 	bl	36ab4 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   371a4:	480b      	ldr	r0, [pc, #44]	; (371d4 <z_remove_thread_from_ready_q+0x94>)
   371a6:	f000 fcd9 	bl	37b5c <z_spin_unlock_valid>
   371aa:	b968      	cbnz	r0, 371c8 <z_remove_thread_from_ready_q+0x88>
   371ac:	235d      	movs	r3, #93	; 0x5d
   371ae:	4a0a      	ldr	r2, [pc, #40]	; (371d8 <z_remove_thread_from_ready_q+0x98>)
   371b0:	490f      	ldr	r1, [pc, #60]	; (371f0 <z_remove_thread_from_ready_q+0xb0>)
   371b2:	480b      	ldr	r0, [pc, #44]	; (371e0 <z_remove_thread_from_ready_q+0xa0>)
   371b4:	f005 faba 	bl	3c72c <printk>
   371b8:	4906      	ldr	r1, [pc, #24]	; (371d4 <z_remove_thread_from_ready_q+0x94>)
   371ba:	480e      	ldr	r0, [pc, #56]	; (371f4 <z_remove_thread_from_ready_q+0xb4>)
   371bc:	f005 fab6 	bl	3c72c <printk>
   371c0:	215d      	movs	r1, #93	; 0x5d
   371c2:	4805      	ldr	r0, [pc, #20]	; (371d8 <z_remove_thread_from_ready_q+0x98>)
   371c4:	f005 faf8 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   371c8:	f385 8811 	msr	BASEPRI, r5
   371cc:	f3bf 8f6f 	isb	sy
}
   371d0:	bd38      	pop	{r3, r4, r5, pc}
   371d2:	bf00      	nop
   371d4:	200297a4 	.word	0x200297a4
   371d8:	000405cb 	.word	0x000405cb
   371dc:	000405f1 	.word	0x000405f1
   371e0:	00040606 	.word	0x00040606
   371e4:	00040623 	.word	0x00040623
   371e8:	20029794 	.word	0x20029794
   371ec:	2002976c 	.word	0x2002976c
   371f0:	00040665 	.word	0x00040665
   371f4:	0004067c 	.word	0x0004067c

000371f8 <pend>:
{
   371f8:	b570      	push	{r4, r5, r6, lr}
   371fa:	4604      	mov	r4, r0
   371fc:	460d      	mov	r5, r1
   371fe:	4616      	mov	r6, r2
	z_remove_thread_from_ready_q(thread);
   37200:	f7ff ff9e 	bl	37140 <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_PENDING;
   37204:	7b63      	ldrb	r3, [r4, #13]
   37206:	f043 0302 	orr.w	r3, r3, #2
   3720a:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   3720c:	b1fd      	cbz	r5, 3724e <pend+0x56>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   3720e:	4b2b      	ldr	r3, [pc, #172]	; (372bc <pend+0xc4>)
		thread->base.pended_on = wait_q;
   37210:	60a5      	str	r5, [r4, #8]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   37212:	429c      	cmp	r4, r3
   37214:	d10b      	bne.n	3722e <pend+0x36>
   37216:	492a      	ldr	r1, [pc, #168]	; (372c0 <pend+0xc8>)
   37218:	482a      	ldr	r0, [pc, #168]	; (372c4 <pend+0xcc>)
   3721a:	f240 3302 	movw	r3, #770	; 0x302
   3721e:	4a2a      	ldr	r2, [pc, #168]	; (372c8 <pend+0xd0>)
   37220:	f005 fa84 	bl	3c72c <printk>
   37224:	f240 3102 	movw	r1, #770	; 0x302
   37228:	4827      	ldr	r0, [pc, #156]	; (372c8 <pend+0xd0>)
   3722a:	f005 fac5 	bl	3c7b8 <assert_post_action>
	return list->head == list;
   3722e:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   37230:	429d      	cmp	r5, r3
   37232:	d03b      	beq.n	372ac <pend+0xb4>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   37234:	2b00      	cmp	r3, #0
   37236:	d039      	beq.n	372ac <pend+0xb4>
	if (thread_1->base.prio < thread_2->base.prio) {
   37238:	f994 200e 	ldrsb.w	r2, [r4, #14]
   3723c:	f993 100e 	ldrsb.w	r1, [r3, #14]
   37240:	4291      	cmp	r1, r2
   37242:	dd2d      	ble.n	372a0 <pend+0xa8>
	node->prev = successor->prev;
   37244:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   37246:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   3724a:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   3724c:	605c      	str	r4, [r3, #4]
	if (timeout != K_FOREVER) {
   3724e:	1c73      	adds	r3, r6, #1
   37250:	d033      	beq.n	372ba <pend+0xc2>
		__ASSERT(timeout >= 0,
   37252:	2e00      	cmp	r6, #0
   37254:	da0e      	bge.n	37274 <pend+0x7c>
   37256:	491d      	ldr	r1, [pc, #116]	; (372cc <pend+0xd4>)
   37258:	f44f 73fb 	mov.w	r3, #502	; 0x1f6
   3725c:	4a1a      	ldr	r2, [pc, #104]	; (372c8 <pend+0xd0>)
   3725e:	4819      	ldr	r0, [pc, #100]	; (372c4 <pend+0xcc>)
   37260:	f005 fa64 	bl	3c72c <printk>
   37264:	481a      	ldr	r0, [pc, #104]	; (372d0 <pend+0xd8>)
   37266:	f005 fa61 	bl	3c72c <printk>
   3726a:	f44f 71fb 	mov.w	r1, #502	; 0x1f6
   3726e:	4816      	ldr	r0, [pc, #88]	; (372c8 <pend+0xd0>)
   37270:	f005 faa2 	bl	3c7b8 <assert_post_action>
   37274:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   37278:	f240 30e7 	movw	r0, #999	; 0x3e7
   3727c:	2100      	movs	r1, #0
   3727e:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
   37282:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   37286:	fbc5 0106 	smlal	r0, r1, r5, r6
   3728a:	2300      	movs	r3, #0
   3728c:	f7e5 fd9e 	bl	1cdcc <__aeabi_uldivmod>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   37290:	4910      	ldr	r1, [pc, #64]	; (372d4 <pend+0xdc>)
   37292:	1c42      	adds	r2, r0, #1
   37294:	f104 0018 	add.w	r0, r4, #24
}
   37298:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   3729c:	f000 beea 	b.w	38074 <z_add_timeout>
	return (node == list->tail) ? NULL : node->next;
   372a0:	6869      	ldr	r1, [r5, #4]
   372a2:	428b      	cmp	r3, r1
   372a4:	d002      	beq.n	372ac <pend+0xb4>
   372a6:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   372a8:	2b00      	cmp	r3, #0
   372aa:	d1c7      	bne.n	3723c <pend+0x44>
	node->prev = list->tail;
   372ac:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   372ae:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
   372b0:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   372b2:	686b      	ldr	r3, [r5, #4]
   372b4:	601c      	str	r4, [r3, #0]
	list->tail = node;
   372b6:	606c      	str	r4, [r5, #4]
   372b8:	e7c9      	b.n	3724e <pend+0x56>
}
   372ba:	bd70      	pop	{r4, r5, r6, pc}
   372bc:	2002559c 	.word	0x2002559c
   372c0:	00043efb 	.word	0x00043efb
   372c4:	00040606 	.word	0x00040606
   372c8:	00043ea3 	.word	0x00043ea3
   372cc:	00043e6d 	.word	0x00043e6d
   372d0:	00043e7a 	.word	0x00043e7a
   372d4:	00036d19 	.word	0x00036d19

000372d8 <z_pend_curr_irqlock>:
{
   372d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   372da:	4606      	mov	r6, r0
	pend(_current, wait_q, timeout);
   372dc:	4d22      	ldr	r5, [pc, #136]	; (37368 <z_pend_curr_irqlock+0x90>)
	pending_current = _current;
   372de:	4c23      	ldr	r4, [pc, #140]	; (3736c <z_pend_curr_irqlock+0x94>)
	pend(_current, wait_q, timeout);
   372e0:	68a8      	ldr	r0, [r5, #8]
   372e2:	f7ff ff89 	bl	371f8 <pend>
	pending_current = _current;
   372e6:	68ab      	ldr	r3, [r5, #8]
   372e8:	4630      	mov	r0, r6
   372ea:	6023      	str	r3, [r4, #0]
   372ec:	f7f0 ff08 	bl	28100 <arch_swap>
   372f0:	4606      	mov	r6, r0
	__asm__ volatile(
   372f2:	f04f 0320 	mov.w	r3, #32
   372f6:	f3ef 8711 	mrs	r7, BASEPRI
   372fa:	f383 8811 	msr	BASEPRI, r3
   372fe:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   37302:	481b      	ldr	r0, [pc, #108]	; (37370 <z_pend_curr_irqlock+0x98>)
   37304:	f000 fc1c 	bl	37b40 <z_spin_lock_valid>
   37308:	b968      	cbnz	r0, 37326 <z_pend_curr_irqlock+0x4e>
   3730a:	234a      	movs	r3, #74	; 0x4a
   3730c:	4a19      	ldr	r2, [pc, #100]	; (37374 <z_pend_curr_irqlock+0x9c>)
   3730e:	491a      	ldr	r1, [pc, #104]	; (37378 <z_pend_curr_irqlock+0xa0>)
   37310:	481a      	ldr	r0, [pc, #104]	; (3737c <z_pend_curr_irqlock+0xa4>)
   37312:	f005 fa0b 	bl	3c72c <printk>
   37316:	4916      	ldr	r1, [pc, #88]	; (37370 <z_pend_curr_irqlock+0x98>)
   37318:	4819      	ldr	r0, [pc, #100]	; (37380 <z_pend_curr_irqlock+0xa8>)
   3731a:	f005 fa07 	bl	3c72c <printk>
   3731e:	214a      	movs	r1, #74	; 0x4a
   37320:	4814      	ldr	r0, [pc, #80]	; (37374 <z_pend_curr_irqlock+0x9c>)
   37322:	f005 fa49 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   37326:	4812      	ldr	r0, [pc, #72]	; (37370 <z_pend_curr_irqlock+0x98>)
   37328:	f000 fc28 	bl	37b7c <z_spin_lock_set_owner>
		if (pending_current == _current) {
   3732c:	6823      	ldr	r3, [r4, #0]
   3732e:	68aa      	ldr	r2, [r5, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   37330:	480f      	ldr	r0, [pc, #60]	; (37370 <z_pend_curr_irqlock+0x98>)
   37332:	429a      	cmp	r2, r3
			pending_current = NULL;
   37334:	bf04      	itt	eq
   37336:	2300      	moveq	r3, #0
   37338:	6023      	streq	r3, [r4, #0]
   3733a:	f000 fc0f 	bl	37b5c <z_spin_unlock_valid>
   3733e:	b968      	cbnz	r0, 3735c <z_pend_curr_irqlock+0x84>
   37340:	235d      	movs	r3, #93	; 0x5d
   37342:	4a0c      	ldr	r2, [pc, #48]	; (37374 <z_pend_curr_irqlock+0x9c>)
   37344:	490f      	ldr	r1, [pc, #60]	; (37384 <z_pend_curr_irqlock+0xac>)
   37346:	480d      	ldr	r0, [pc, #52]	; (3737c <z_pend_curr_irqlock+0xa4>)
   37348:	f005 f9f0 	bl	3c72c <printk>
   3734c:	4908      	ldr	r1, [pc, #32]	; (37370 <z_pend_curr_irqlock+0x98>)
   3734e:	480e      	ldr	r0, [pc, #56]	; (37388 <z_pend_curr_irqlock+0xb0>)
   37350:	f005 f9ec 	bl	3c72c <printk>
   37354:	215d      	movs	r1, #93	; 0x5d
   37356:	4807      	ldr	r0, [pc, #28]	; (37374 <z_pend_curr_irqlock+0x9c>)
   37358:	f005 fa2e 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   3735c:	f387 8811 	msr	BASEPRI, r7
   37360:	f3bf 8f6f 	isb	sy
}
   37364:	4630      	mov	r0, r6
   37366:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   37368:	2002976c 	.word	0x2002976c
   3736c:	200297a0 	.word	0x200297a0
   37370:	200297a4 	.word	0x200297a4
   37374:	000405cb 	.word	0x000405cb
   37378:	000405f1 	.word	0x000405f1
   3737c:	00040606 	.word	0x00040606
   37380:	00040623 	.word	0x00040623
   37384:	00040665 	.word	0x00040665
   37388:	0004067c 	.word	0x0004067c

0003738c <z_pend_curr>:
{
   3738c:	b538      	push	{r3, r4, r5, lr}
   3738e:	4604      	mov	r4, r0
   37390:	460d      	mov	r5, r1
   37392:	4611      	mov	r1, r2
	pending_current = _current;
   37394:	4a0e      	ldr	r2, [pc, #56]	; (373d0 <z_pend_curr+0x44>)
   37396:	6890      	ldr	r0, [r2, #8]
   37398:	4a0e      	ldr	r2, [pc, #56]	; (373d4 <z_pend_curr+0x48>)
   3739a:	6010      	str	r0, [r2, #0]
	pend(_current, wait_q, timeout);
   3739c:	461a      	mov	r2, r3
   3739e:	f7ff ff2b 	bl	371f8 <pend>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   373a2:	4620      	mov	r0, r4
   373a4:	f000 fbda 	bl	37b5c <z_spin_unlock_valid>
   373a8:	b968      	cbnz	r0, 373c6 <z_pend_curr+0x3a>
   373aa:	2374      	movs	r3, #116	; 0x74
   373ac:	4a0a      	ldr	r2, [pc, #40]	; (373d8 <z_pend_curr+0x4c>)
   373ae:	490b      	ldr	r1, [pc, #44]	; (373dc <z_pend_curr+0x50>)
   373b0:	480b      	ldr	r0, [pc, #44]	; (373e0 <z_pend_curr+0x54>)
   373b2:	f005 f9bb 	bl	3c72c <printk>
   373b6:	4621      	mov	r1, r4
   373b8:	480a      	ldr	r0, [pc, #40]	; (373e4 <z_pend_curr+0x58>)
   373ba:	f005 f9b7 	bl	3c72c <printk>
   373be:	2174      	movs	r1, #116	; 0x74
   373c0:	4805      	ldr	r0, [pc, #20]	; (373d8 <z_pend_curr+0x4c>)
   373c2:	f005 f9f9 	bl	3c7b8 <assert_post_action>
   373c6:	4628      	mov	r0, r5
}
   373c8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   373cc:	f7f0 be98 	b.w	28100 <arch_swap>
   373d0:	2002976c 	.word	0x2002976c
   373d4:	200297a0 	.word	0x200297a0
   373d8:	000405cb 	.word	0x000405cb
   373dc:	00040665 	.word	0x00040665
   373e0:	00040606 	.word	0x00040606
   373e4:	0004067c 	.word	0x0004067c

000373e8 <z_set_prio>:
{
   373e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   373ea:	4604      	mov	r4, r0
   373ec:	460d      	mov	r5, r1
	__asm__ volatile(
   373ee:	f04f 0320 	mov.w	r3, #32
   373f2:	f3ef 8611 	mrs	r6, BASEPRI
   373f6:	f383 8811 	msr	BASEPRI, r3
   373fa:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   373fe:	4835      	ldr	r0, [pc, #212]	; (374d4 <z_set_prio+0xec>)
   37400:	f000 fb9e 	bl	37b40 <z_spin_lock_valid>
   37404:	b968      	cbnz	r0, 37422 <z_set_prio+0x3a>
   37406:	234a      	movs	r3, #74	; 0x4a
   37408:	4a33      	ldr	r2, [pc, #204]	; (374d8 <z_set_prio+0xf0>)
   3740a:	4934      	ldr	r1, [pc, #208]	; (374dc <z_set_prio+0xf4>)
   3740c:	4834      	ldr	r0, [pc, #208]	; (374e0 <z_set_prio+0xf8>)
   3740e:	f005 f98d 	bl	3c72c <printk>
   37412:	4930      	ldr	r1, [pc, #192]	; (374d4 <z_set_prio+0xec>)
   37414:	4833      	ldr	r0, [pc, #204]	; (374e4 <z_set_prio+0xfc>)
   37416:	f005 f989 	bl	3c72c <printk>
   3741a:	214a      	movs	r1, #74	; 0x4a
   3741c:	482e      	ldr	r0, [pc, #184]	; (374d8 <z_set_prio+0xf0>)
   3741e:	f005 f9cb 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   37422:	482c      	ldr	r0, [pc, #176]	; (374d4 <z_set_prio+0xec>)
   37424:	f000 fbaa 	bl	37b7c <z_spin_lock_set_owner>
		need_sched = z_is_thread_ready(thread);
   37428:	4620      	mov	r0, r4
   3742a:	f007 f87b 	bl	3e524 <z_is_thread_ready>
		if (need_sched) {
   3742e:	b26d      	sxtb	r5, r5
   37430:	4607      	mov	r7, r0
   37432:	2800      	cmp	r0, #0
   37434:	d04c      	beq.n	374d0 <z_set_prio+0xe8>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
   37436:	4621      	mov	r1, r4
   37438:	482b      	ldr	r0, [pc, #172]	; (374e8 <z_set_prio+0x100>)
   3743a:	f7ff fab7 	bl	369ac <z_priq_dumb_remove>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   3743e:	4b2b      	ldr	r3, [pc, #172]	; (374ec <z_set_prio+0x104>)
				thread->base.prio = prio;
   37440:	73a5      	strb	r5, [r4, #14]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   37442:	429c      	cmp	r4, r3
   37444:	d10b      	bne.n	3745e <z_set_prio+0x76>
   37446:	492a      	ldr	r1, [pc, #168]	; (374f0 <z_set_prio+0x108>)
   37448:	4825      	ldr	r0, [pc, #148]	; (374e0 <z_set_prio+0xf8>)
   3744a:	f240 3302 	movw	r3, #770	; 0x302
   3744e:	4a29      	ldr	r2, [pc, #164]	; (374f4 <z_set_prio+0x10c>)
   37450:	f005 f96c 	bl	3c72c <printk>
   37454:	f240 3102 	movw	r1, #770	; 0x302
   37458:	4826      	ldr	r0, [pc, #152]	; (374f4 <z_set_prio+0x10c>)
   3745a:	f005 f9ad 	bl	3c7b8 <assert_post_action>
	return list->head == list;
   3745e:	4a26      	ldr	r2, [pc, #152]	; (374f8 <z_set_prio+0x110>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
   37460:	f102 0128 	add.w	r1, r2, #40	; 0x28
   37464:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
   37468:	428b      	cmp	r3, r1
   3746a:	d02b      	beq.n	374c4 <z_set_prio+0xdc>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   3746c:	b353      	cbz	r3, 374c4 <z_set_prio+0xdc>
	if (thread_1->base.prio < thread_2->base.prio) {
   3746e:	f994 500e 	ldrsb.w	r5, [r4, #14]
   37472:	f993 c00e 	ldrsb.w	ip, [r3, #14]
   37476:	45ac      	cmp	ip, r5
   37478:	dd1f      	ble.n	374ba <z_set_prio+0xd2>
	node->prev = successor->prev;
   3747a:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   3747c:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   37480:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   37482:	605c      	str	r4, [r3, #4]
			update_cache(1);
   37484:	2001      	movs	r0, #1
   37486:	f7ff fb15 	bl	36ab4 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   3748a:	4812      	ldr	r0, [pc, #72]	; (374d4 <z_set_prio+0xec>)
   3748c:	f000 fb66 	bl	37b5c <z_spin_unlock_valid>
   37490:	b968      	cbnz	r0, 374ae <z_set_prio+0xc6>
   37492:	235d      	movs	r3, #93	; 0x5d
   37494:	4a10      	ldr	r2, [pc, #64]	; (374d8 <z_set_prio+0xf0>)
   37496:	4919      	ldr	r1, [pc, #100]	; (374fc <z_set_prio+0x114>)
   37498:	4811      	ldr	r0, [pc, #68]	; (374e0 <z_set_prio+0xf8>)
   3749a:	f005 f947 	bl	3c72c <printk>
   3749e:	490d      	ldr	r1, [pc, #52]	; (374d4 <z_set_prio+0xec>)
   374a0:	4817      	ldr	r0, [pc, #92]	; (37500 <z_set_prio+0x118>)
   374a2:	f005 f943 	bl	3c72c <printk>
   374a6:	215d      	movs	r1, #93	; 0x5d
   374a8:	480b      	ldr	r0, [pc, #44]	; (374d8 <z_set_prio+0xf0>)
   374aa:	f005 f985 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   374ae:	f386 8811 	msr	BASEPRI, r6
   374b2:	f3bf 8f6f 	isb	sy
}
   374b6:	4638      	mov	r0, r7
   374b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   374ba:	4298      	cmp	r0, r3
   374bc:	d002      	beq.n	374c4 <z_set_prio+0xdc>
   374be:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   374c0:	2b00      	cmp	r3, #0
   374c2:	d1d6      	bne.n	37472 <z_set_prio+0x8a>
	node->prev = list->tail;
   374c4:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   374c8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   374ca:	601c      	str	r4, [r3, #0]
	list->tail = node;
   374cc:	62d4      	str	r4, [r2, #44]	; 0x2c
   374ce:	e7d9      	b.n	37484 <z_set_prio+0x9c>
			thread->base.prio = prio;
   374d0:	73a5      	strb	r5, [r4, #14]
   374d2:	e7da      	b.n	3748a <z_set_prio+0xa2>
   374d4:	200297a4 	.word	0x200297a4
   374d8:	000405cb 	.word	0x000405cb
   374dc:	000405f1 	.word	0x000405f1
   374e0:	00040606 	.word	0x00040606
   374e4:	00040623 	.word	0x00040623
   374e8:	20029794 	.word	0x20029794
   374ec:	2002559c 	.word	0x2002559c
   374f0:	00043efb 	.word	0x00043efb
   374f4:	00043ea3 	.word	0x00043ea3
   374f8:	2002976c 	.word	0x2002976c
   374fc:	00040665 	.word	0x00040665
   37500:	0004067c 	.word	0x0004067c

00037504 <z_unpend_first_thread>:
{
   37504:	b538      	push	{r3, r4, r5, lr}
   37506:	4604      	mov	r4, r0
	__asm__ volatile(
   37508:	f04f 0320 	mov.w	r3, #32
   3750c:	f3ef 8511 	mrs	r5, BASEPRI
   37510:	f383 8811 	msr	BASEPRI, r3
   37514:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   37518:	483b      	ldr	r0, [pc, #236]	; (37608 <z_unpend_first_thread+0x104>)
   3751a:	f000 fb11 	bl	37b40 <z_spin_lock_valid>
   3751e:	b968      	cbnz	r0, 3753c <z_unpend_first_thread+0x38>
   37520:	234a      	movs	r3, #74	; 0x4a
   37522:	4a3a      	ldr	r2, [pc, #232]	; (3760c <z_unpend_first_thread+0x108>)
   37524:	493a      	ldr	r1, [pc, #232]	; (37610 <z_unpend_first_thread+0x10c>)
   37526:	483b      	ldr	r0, [pc, #236]	; (37614 <z_unpend_first_thread+0x110>)
   37528:	f005 f900 	bl	3c72c <printk>
   3752c:	4936      	ldr	r1, [pc, #216]	; (37608 <z_unpend_first_thread+0x104>)
   3752e:	483a      	ldr	r0, [pc, #232]	; (37618 <z_unpend_first_thread+0x114>)
   37530:	f005 f8fc 	bl	3c72c <printk>
   37534:	214a      	movs	r1, #74	; 0x4a
   37536:	4835      	ldr	r0, [pc, #212]	; (3760c <z_unpend_first_thread+0x108>)
   37538:	f005 f93e 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   3753c:	4832      	ldr	r0, [pc, #200]	; (37608 <z_unpend_first_thread+0x104>)
   3753e:	f000 fb1d 	bl	37b7c <z_spin_lock_set_owner>
		ret = _priq_wait_best(&wait_q->waitq);
   37542:	4620      	mov	r0, r4
   37544:	f007 f816 	bl	3e574 <z_priq_dumb_best>
   37548:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   3754a:	482f      	ldr	r0, [pc, #188]	; (37608 <z_unpend_first_thread+0x104>)
   3754c:	f000 fb06 	bl	37b5c <z_spin_unlock_valid>
   37550:	b968      	cbnz	r0, 3756e <z_unpend_first_thread+0x6a>
   37552:	235d      	movs	r3, #93	; 0x5d
   37554:	4a2d      	ldr	r2, [pc, #180]	; (3760c <z_unpend_first_thread+0x108>)
   37556:	4931      	ldr	r1, [pc, #196]	; (3761c <z_unpend_first_thread+0x118>)
   37558:	482e      	ldr	r0, [pc, #184]	; (37614 <z_unpend_first_thread+0x110>)
   3755a:	f005 f8e7 	bl	3c72c <printk>
   3755e:	492a      	ldr	r1, [pc, #168]	; (37608 <z_unpend_first_thread+0x104>)
   37560:	482f      	ldr	r0, [pc, #188]	; (37620 <z_unpend_first_thread+0x11c>)
   37562:	f005 f8e3 	bl	3c72c <printk>
   37566:	215d      	movs	r1, #93	; 0x5d
   37568:	4828      	ldr	r0, [pc, #160]	; (3760c <z_unpend_first_thread+0x108>)
   3756a:	f005 f925 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   3756e:	f385 8811 	msr	BASEPRI, r5
   37572:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   37576:	2c00      	cmp	r4, #0
   37578:	d043      	beq.n	37602 <z_unpend_first_thread+0xfe>
	__asm__ volatile(
   3757a:	f04f 0320 	mov.w	r3, #32
   3757e:	f3ef 8511 	mrs	r5, BASEPRI
   37582:	f383 8811 	msr	BASEPRI, r3
   37586:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   3758a:	481f      	ldr	r0, [pc, #124]	; (37608 <z_unpend_first_thread+0x104>)
   3758c:	f000 fad8 	bl	37b40 <z_spin_lock_valid>
   37590:	b968      	cbnz	r0, 375ae <z_unpend_first_thread+0xaa>
   37592:	234a      	movs	r3, #74	; 0x4a
   37594:	4a1d      	ldr	r2, [pc, #116]	; (3760c <z_unpend_first_thread+0x108>)
   37596:	491e      	ldr	r1, [pc, #120]	; (37610 <z_unpend_first_thread+0x10c>)
   37598:	481e      	ldr	r0, [pc, #120]	; (37614 <z_unpend_first_thread+0x110>)
   3759a:	f005 f8c7 	bl	3c72c <printk>
   3759e:	491a      	ldr	r1, [pc, #104]	; (37608 <z_unpend_first_thread+0x104>)
   375a0:	481d      	ldr	r0, [pc, #116]	; (37618 <z_unpend_first_thread+0x114>)
   375a2:	f005 f8c3 	bl	3c72c <printk>
   375a6:	214a      	movs	r1, #74	; 0x4a
   375a8:	4818      	ldr	r0, [pc, #96]	; (3760c <z_unpend_first_thread+0x108>)
   375aa:	f005 f905 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   375ae:	4816      	ldr	r0, [pc, #88]	; (37608 <z_unpend_first_thread+0x104>)
   375b0:	f000 fae4 	bl	37b7c <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   375b4:	f104 0008 	add.w	r0, r4, #8
   375b8:	f7ff f81a 	bl	365f0 <pended_on.isra.17>
   375bc:	4621      	mov	r1, r4
   375be:	f7ff f9f5 	bl	369ac <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   375c2:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   375c4:	4810      	ldr	r0, [pc, #64]	; (37608 <z_unpend_first_thread+0x104>)
   375c6:	f023 0302 	bic.w	r3, r3, #2
   375ca:	7363      	strb	r3, [r4, #13]
   375cc:	f000 fac6 	bl	37b5c <z_spin_unlock_valid>
   375d0:	b968      	cbnz	r0, 375ee <z_unpend_first_thread+0xea>
   375d2:	235d      	movs	r3, #93	; 0x5d
   375d4:	4a0d      	ldr	r2, [pc, #52]	; (3760c <z_unpend_first_thread+0x108>)
   375d6:	4911      	ldr	r1, [pc, #68]	; (3761c <z_unpend_first_thread+0x118>)
   375d8:	480e      	ldr	r0, [pc, #56]	; (37614 <z_unpend_first_thread+0x110>)
   375da:	f005 f8a7 	bl	3c72c <printk>
   375de:	490a      	ldr	r1, [pc, #40]	; (37608 <z_unpend_first_thread+0x104>)
   375e0:	480f      	ldr	r0, [pc, #60]	; (37620 <z_unpend_first_thread+0x11c>)
   375e2:	f005 f8a3 	bl	3c72c <printk>
   375e6:	215d      	movs	r1, #93	; 0x5d
   375e8:	4808      	ldr	r0, [pc, #32]	; (3760c <z_unpend_first_thread+0x108>)
   375ea:	f005 f8e5 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   375ee:	f385 8811 	msr	BASEPRI, r5
   375f2:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   375f6:	2300      	movs	r3, #0
	return z_abort_timeout(&thread->base.timeout);
   375f8:	f104 0018 	add.w	r0, r4, #24
   375fc:	60a3      	str	r3, [r4, #8]
   375fe:	f000 fddf 	bl	381c0 <z_abort_timeout>
}
   37602:	4620      	mov	r0, r4
   37604:	bd38      	pop	{r3, r4, r5, pc}
   37606:	bf00      	nop
   37608:	200297a4 	.word	0x200297a4
   3760c:	000405cb 	.word	0x000405cb
   37610:	000405f1 	.word	0x000405f1
   37614:	00040606 	.word	0x00040606
   37618:	00040623 	.word	0x00040623
   3761c:	00040665 	.word	0x00040665
   37620:	0004067c 	.word	0x0004067c

00037624 <z_sched_init>:
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   37624:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
   37626:	4b04      	ldr	r3, [pc, #16]	; (37638 <z_sched_init+0x14>)
   37628:	4608      	mov	r0, r1
   3762a:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
   3762e:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
   37632:	f7ff b80b 	b.w	3664c <k_sched_time_slice_set>
   37636:	bf00      	nop
   37638:	2002976c 	.word	0x2002976c

0003763c <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
   3763c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3763e:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   37642:	b173      	cbz	r3, 37662 <z_impl_k_yield+0x26>
   37644:	4945      	ldr	r1, [pc, #276]	; (3775c <z_impl_k_yield+0x120>)
   37646:	f240 430d 	movw	r3, #1037	; 0x40d
   3764a:	4a45      	ldr	r2, [pc, #276]	; (37760 <z_impl_k_yield+0x124>)
   3764c:	4845      	ldr	r0, [pc, #276]	; (37764 <z_impl_k_yield+0x128>)
   3764e:	f005 f86d 	bl	3c72c <printk>
   37652:	4845      	ldr	r0, [pc, #276]	; (37768 <z_impl_k_yield+0x12c>)
   37654:	f005 f86a 	bl	3c72c <printk>
   37658:	f240 410d 	movw	r1, #1037	; 0x40d
   3765c:	4840      	ldr	r0, [pc, #256]	; (37760 <z_impl_k_yield+0x124>)
   3765e:	f005 f8ab 	bl	3c7b8 <assert_post_action>

	if (!z_is_idle_thread_object(_current)) {
   37662:	4c42      	ldr	r4, [pc, #264]	; (3776c <z_impl_k_yield+0x130>)
   37664:	4e42      	ldr	r6, [pc, #264]	; (37770 <z_impl_k_yield+0x134>)
   37666:	68a2      	ldr	r2, [r4, #8]
   37668:	42b2      	cmp	r2, r6
   3766a:	d05f      	beq.n	3772c <z_impl_k_yield+0xf0>
	__asm__ volatile(
   3766c:	f04f 0320 	mov.w	r3, #32
   37670:	f3ef 8711 	mrs	r7, BASEPRI
   37674:	f383 8811 	msr	BASEPRI, r3
   37678:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   3767c:	483d      	ldr	r0, [pc, #244]	; (37774 <z_impl_k_yield+0x138>)
   3767e:	f000 fa5f 	bl	37b40 <z_spin_lock_valid>
   37682:	b968      	cbnz	r0, 376a0 <z_impl_k_yield+0x64>
   37684:	234a      	movs	r3, #74	; 0x4a
   37686:	4a3c      	ldr	r2, [pc, #240]	; (37778 <z_impl_k_yield+0x13c>)
   37688:	493c      	ldr	r1, [pc, #240]	; (3777c <z_impl_k_yield+0x140>)
   3768a:	4836      	ldr	r0, [pc, #216]	; (37764 <z_impl_k_yield+0x128>)
   3768c:	f005 f84e 	bl	3c72c <printk>
   37690:	4938      	ldr	r1, [pc, #224]	; (37774 <z_impl_k_yield+0x138>)
   37692:	483b      	ldr	r0, [pc, #236]	; (37780 <z_impl_k_yield+0x144>)
   37694:	f005 f84a 	bl	3c72c <printk>
   37698:	214a      	movs	r1, #74	; 0x4a
   3769a:	4837      	ldr	r0, [pc, #220]	; (37778 <z_impl_k_yield+0x13c>)
   3769c:	f005 f88c 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   376a0:	4834      	ldr	r0, [pc, #208]	; (37774 <z_impl_k_yield+0x138>)
   376a2:	f000 fa6b 	bl	37b7c <z_spin_lock_set_owner>
		LOCKED(&sched_spinlock) {
			if (!IS_ENABLED(CONFIG_SMP) ||
			    z_is_thread_queued(_current)) {
				_priq_run_remove(&_kernel.ready_q.runq,
   376a6:	68a1      	ldr	r1, [r4, #8]
   376a8:	4836      	ldr	r0, [pc, #216]	; (37784 <z_impl_k_yield+0x148>)
   376aa:	f7ff f97f 	bl	369ac <z_priq_dumb_remove>
						 _current);
			}
			_priq_run_add(&_kernel.ready_q.runq, _current);
   376ae:	68a5      	ldr	r5, [r4, #8]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   376b0:	42b5      	cmp	r5, r6
   376b2:	d10b      	bne.n	376cc <z_impl_k_yield+0x90>
   376b4:	4934      	ldr	r1, [pc, #208]	; (37788 <z_impl_k_yield+0x14c>)
   376b6:	482b      	ldr	r0, [pc, #172]	; (37764 <z_impl_k_yield+0x128>)
   376b8:	f240 3302 	movw	r3, #770	; 0x302
   376bc:	4a28      	ldr	r2, [pc, #160]	; (37760 <z_impl_k_yield+0x124>)
   376be:	f005 f835 	bl	3c72c <printk>
   376c2:	f240 3102 	movw	r1, #770	; 0x302
   376c6:	4826      	ldr	r0, [pc, #152]	; (37760 <z_impl_k_yield+0x124>)
   376c8:	f005 f876 	bl	3c7b8 <assert_post_action>
	return list->head == list;
   376cc:	e9d4 310a 	ldrd	r3, r1, [r4, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
   376d0:	4a2c      	ldr	r2, [pc, #176]	; (37784 <z_impl_k_yield+0x148>)
   376d2:	4293      	cmp	r3, r2
   376d4:	d03b      	beq.n	3774e <z_impl_k_yield+0x112>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   376d6:	2b00      	cmp	r3, #0
   376d8:	d039      	beq.n	3774e <z_impl_k_yield+0x112>
	if (thread_1->base.prio < thread_2->base.prio) {
   376da:	f995 000e 	ldrsb.w	r0, [r5, #14]
   376de:	f993 600e 	ldrsb.w	r6, [r3, #14]
   376e2:	4286      	cmp	r6, r0
   376e4:	dd2e      	ble.n	37744 <z_impl_k_yield+0x108>
	node->prev = successor->prev;
   376e6:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   376e8:	e9c5 3200 	strd	r3, r2, [r5]
	successor->prev->next = node;
   376ec:	6015      	str	r5, [r2, #0]
	successor->prev = node;
   376ee:	605d      	str	r5, [r3, #4]
			z_mark_thread_as_queued(_current);
   376f0:	68a2      	ldr	r2, [r4, #8]
			update_cache(1);
   376f2:	2001      	movs	r0, #1
	thread->base.thread_state |= states;
   376f4:	7b53      	ldrb	r3, [r2, #13]
   376f6:	f063 037f 	orn	r3, r3, #127	; 0x7f
   376fa:	7353      	strb	r3, [r2, #13]
   376fc:	f7ff f9da 	bl	36ab4 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   37700:	481c      	ldr	r0, [pc, #112]	; (37774 <z_impl_k_yield+0x138>)
   37702:	f000 fa2b 	bl	37b5c <z_spin_unlock_valid>
   37706:	b968      	cbnz	r0, 37724 <z_impl_k_yield+0xe8>
   37708:	235d      	movs	r3, #93	; 0x5d
   3770a:	4a1b      	ldr	r2, [pc, #108]	; (37778 <z_impl_k_yield+0x13c>)
   3770c:	491f      	ldr	r1, [pc, #124]	; (3778c <z_impl_k_yield+0x150>)
   3770e:	4815      	ldr	r0, [pc, #84]	; (37764 <z_impl_k_yield+0x128>)
   37710:	f005 f80c 	bl	3c72c <printk>
   37714:	4917      	ldr	r1, [pc, #92]	; (37774 <z_impl_k_yield+0x138>)
   37716:	481e      	ldr	r0, [pc, #120]	; (37790 <z_impl_k_yield+0x154>)
   37718:	f005 f808 	bl	3c72c <printk>
   3771c:	215d      	movs	r1, #93	; 0x5d
   3771e:	4816      	ldr	r0, [pc, #88]	; (37778 <z_impl_k_yield+0x13c>)
   37720:	f005 f84a 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   37724:	f387 8811 	msr	BASEPRI, r7
   37728:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   3772c:	f04f 0320 	mov.w	r3, #32
   37730:	f3ef 8011 	mrs	r0, BASEPRI
   37734:	f383 8811 	msr	BASEPRI, r3
   37738:	f3bf 8f6f 	isb	sy
		}
	}
	z_swap_unlocked();
}
   3773c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   37740:	f7f0 bcde 	b.w	28100 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   37744:	4299      	cmp	r1, r3
   37746:	d002      	beq.n	3774e <z_impl_k_yield+0x112>
   37748:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   3774a:	2b00      	cmp	r3, #0
   3774c:	d1c7      	bne.n	376de <z_impl_k_yield+0xa2>
	node->prev = list->tail;
   3774e:	e9c5 2100 	strd	r2, r1, [r5]
	list->tail->next = node;
   37752:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   37754:	601d      	str	r5, [r3, #0]
	list->tail = node;
   37756:	62e5      	str	r5, [r4, #44]	; 0x2c
   37758:	e7ca      	b.n	376f0 <z_impl_k_yield+0xb4>
   3775a:	bf00      	nop
   3775c:	00043e0b 	.word	0x00043e0b
   37760:	00043ea3 	.word	0x00043ea3
   37764:	00040606 	.word	0x00040606
   37768:	00042742 	.word	0x00042742
   3776c:	2002976c 	.word	0x2002976c
   37770:	2002559c 	.word	0x2002559c
   37774:	200297a4 	.word	0x200297a4
   37778:	000405cb 	.word	0x000405cb
   3777c:	000405f1 	.word	0x000405f1
   37780:	00040623 	.word	0x00040623
   37784:	20029794 	.word	0x20029794
   37788:	00043efb 	.word	0x00043efb
   3778c:	00040665 	.word	0x00040665
   37790:	0004067c 	.word	0x0004067c

00037794 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static s32_t z_tick_sleep(s32_t ticks)
{
   37794:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   37796:	4604      	mov	r4, r0
   37798:	f3ef 8305 	mrs	r3, IPSR
#ifdef CONFIG_MULTITHREADING
	u32_t expected_wakeup_time;

	__ASSERT(!arch_is_in_isr(), "");
   3779c:	b173      	cbz	r3, 377bc <z_tick_sleep+0x28>
   3779e:	493b      	ldr	r1, [pc, #236]	; (3788c <z_tick_sleep+0xf8>)
   377a0:	f240 432b 	movw	r3, #1067	; 0x42b
   377a4:	4a3a      	ldr	r2, [pc, #232]	; (37890 <z_tick_sleep+0xfc>)
   377a6:	483b      	ldr	r0, [pc, #236]	; (37894 <z_tick_sleep+0x100>)
   377a8:	f004 ffc0 	bl	3c72c <printk>
   377ac:	483a      	ldr	r0, [pc, #232]	; (37898 <z_tick_sleep+0x104>)
   377ae:	f004 ffbd 	bl	3c72c <printk>
   377b2:	f240 412b 	movw	r1, #1067	; 0x42b
   377b6:	4836      	ldr	r0, [pc, #216]	; (37890 <z_tick_sleep+0xfc>)
   377b8:	f004 fffe 	bl	3c7b8 <assert_post_action>

	K_DEBUG("thread %p for %d ticks\n", _current, ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   377bc:	b924      	cbnz	r4, 377c8 <z_tick_sleep+0x34>
	z_impl_k_yield();
   377be:	f7ff ff3d 	bl	3763c <z_impl_k_yield>
		return ticks;
	}
#endif

	return 0;
}
   377c2:	4620      	mov	r0, r4
   377c4:	b003      	add	sp, #12
   377c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	expected_wakeup_time = ticks + z_tick_get_32();
   377c8:	f006 ff7f 	bl	3e6ca <z_tick_get_32>
	struct k_spinlock local_lock = {};
   377cc:	2300      	movs	r3, #0
	ticks += _TICK_ALIGN;
   377ce:	1c66      	adds	r6, r4, #1
	expected_wakeup_time = ticks + z_tick_get_32();
   377d0:	1834      	adds	r4, r6, r0
	struct k_spinlock local_lock = {};
   377d2:	9301      	str	r3, [sp, #4]
   377d4:	f04f 0320 	mov.w	r3, #32
   377d8:	f3ef 8711 	mrs	r7, BASEPRI
   377dc:	f383 8811 	msr	BASEPRI, r3
   377e0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   377e4:	a801      	add	r0, sp, #4
   377e6:	f000 f9ab 	bl	37b40 <z_spin_lock_valid>
   377ea:	b968      	cbnz	r0, 37808 <z_tick_sleep+0x74>
   377ec:	234a      	movs	r3, #74	; 0x4a
   377ee:	4a2b      	ldr	r2, [pc, #172]	; (3789c <z_tick_sleep+0x108>)
   377f0:	492b      	ldr	r1, [pc, #172]	; (378a0 <z_tick_sleep+0x10c>)
   377f2:	4828      	ldr	r0, [pc, #160]	; (37894 <z_tick_sleep+0x100>)
   377f4:	f004 ff9a 	bl	3c72c <printk>
   377f8:	a901      	add	r1, sp, #4
   377fa:	482a      	ldr	r0, [pc, #168]	; (378a4 <z_tick_sleep+0x110>)
   377fc:	f004 ff96 	bl	3c72c <printk>
   37800:	214a      	movs	r1, #74	; 0x4a
   37802:	4826      	ldr	r0, [pc, #152]	; (3789c <z_tick_sleep+0x108>)
   37804:	f004 ffd8 	bl	3c7b8 <assert_post_action>
	pending_current = _current;
   37808:	4d27      	ldr	r5, [pc, #156]	; (378a8 <z_tick_sleep+0x114>)
	z_spin_lock_set_owner(l);
   3780a:	a801      	add	r0, sp, #4
   3780c:	f000 f9b6 	bl	37b7c <z_spin_lock_set_owner>
   37810:	4b26      	ldr	r3, [pc, #152]	; (378ac <z_tick_sleep+0x118>)
   37812:	68a8      	ldr	r0, [r5, #8]
   37814:	6018      	str	r0, [r3, #0]
	z_remove_thread_from_ready_q(_current);
   37816:	f7ff fc93 	bl	37140 <z_remove_thread_from_ready_q>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   3781a:	68a8      	ldr	r0, [r5, #8]
   3781c:	4632      	mov	r2, r6
   3781e:	3018      	adds	r0, #24
   37820:	4923      	ldr	r1, [pc, #140]	; (378b0 <z_tick_sleep+0x11c>)
   37822:	f000 fc27 	bl	38074 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   37826:	68aa      	ldr	r2, [r5, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   37828:	a801      	add	r0, sp, #4
	thread->base.thread_state |= _THREAD_SUSPENDED;
   3782a:	7b53      	ldrb	r3, [r2, #13]
   3782c:	f043 0310 	orr.w	r3, r3, #16
   37830:	7353      	strb	r3, [r2, #13]
   37832:	f000 f993 	bl	37b5c <z_spin_unlock_valid>
   37836:	b968      	cbnz	r0, 37854 <z_tick_sleep+0xc0>
   37838:	2374      	movs	r3, #116	; 0x74
   3783a:	4a18      	ldr	r2, [pc, #96]	; (3789c <z_tick_sleep+0x108>)
   3783c:	491d      	ldr	r1, [pc, #116]	; (378b4 <z_tick_sleep+0x120>)
   3783e:	4815      	ldr	r0, [pc, #84]	; (37894 <z_tick_sleep+0x100>)
   37840:	f004 ff74 	bl	3c72c <printk>
   37844:	a901      	add	r1, sp, #4
   37846:	481c      	ldr	r0, [pc, #112]	; (378b8 <z_tick_sleep+0x124>)
   37848:	f004 ff70 	bl	3c72c <printk>
   3784c:	2174      	movs	r1, #116	; 0x74
   3784e:	4813      	ldr	r0, [pc, #76]	; (3789c <z_tick_sleep+0x108>)
   37850:	f004 ffb2 	bl	3c7b8 <assert_post_action>
   37854:	4638      	mov	r0, r7
   37856:	f7f0 fc53 	bl	28100 <arch_swap>
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
   3785a:	68ab      	ldr	r3, [r5, #8]
   3785c:	7b5b      	ldrb	r3, [r3, #13]
   3785e:	06db      	lsls	r3, r3, #27
   37860:	d50e      	bpl.n	37880 <z_tick_sleep+0xec>
   37862:	4916      	ldr	r1, [pc, #88]	; (378bc <z_tick_sleep+0x128>)
   37864:	f44f 6389 	mov.w	r3, #1096	; 0x448
   37868:	4a09      	ldr	r2, [pc, #36]	; (37890 <z_tick_sleep+0xfc>)
   3786a:	480a      	ldr	r0, [pc, #40]	; (37894 <z_tick_sleep+0x100>)
   3786c:	f004 ff5e 	bl	3c72c <printk>
   37870:	4809      	ldr	r0, [pc, #36]	; (37898 <z_tick_sleep+0x104>)
   37872:	f004 ff5b 	bl	3c72c <printk>
   37876:	f44f 6189 	mov.w	r1, #1096	; 0x448
   3787a:	4805      	ldr	r0, [pc, #20]	; (37890 <z_tick_sleep+0xfc>)
   3787c:	f004 ff9c 	bl	3c7b8 <assert_post_action>
	ticks = expected_wakeup_time - z_tick_get_32();
   37880:	f006 ff23 	bl	3e6ca <z_tick_get_32>
   37884:	1a24      	subs	r4, r4, r0
   37886:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
   3788a:	e79a      	b.n	377c2 <z_tick_sleep+0x2e>
   3788c:	00043e0b 	.word	0x00043e0b
   37890:	00043ea3 	.word	0x00043ea3
   37894:	00040606 	.word	0x00040606
   37898:	00042742 	.word	0x00042742
   3789c:	000405cb 	.word	0x000405cb
   378a0:	000405f1 	.word	0x000405f1
   378a4:	00040623 	.word	0x00040623
   378a8:	2002976c 	.word	0x2002976c
   378ac:	200297a0 	.word	0x200297a0
   378b0:	00036d19 	.word	0x00036d19
   378b4:	00040665 	.word	0x00040665
   378b8:	0004067c 	.word	0x0004067c
   378bc:	00043f1c 	.word	0x00043f1c

000378c0 <z_impl_k_sleep>:

s32_t z_impl_k_sleep(int ms)
{
   378c0:	b538      	push	{r3, r4, r5, lr}
   378c2:	4604      	mov	r4, r0
   378c4:	f3ef 8305 	mrs	r3, IPSR
	s32_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
   378c8:	b173      	cbz	r3, 378e8 <z_impl_k_sleep+0x28>
   378ca:	4916      	ldr	r1, [pc, #88]	; (37924 <z_impl_k_sleep+0x64>)
   378cc:	f240 4357 	movw	r3, #1111	; 0x457
   378d0:	4a15      	ldr	r2, [pc, #84]	; (37928 <z_impl_k_sleep+0x68>)
   378d2:	4816      	ldr	r0, [pc, #88]	; (3792c <z_impl_k_sleep+0x6c>)
   378d4:	f004 ff2a 	bl	3c72c <printk>
   378d8:	4815      	ldr	r0, [pc, #84]	; (37930 <z_impl_k_sleep+0x70>)
   378da:	f004 ff27 	bl	3c72c <printk>
   378de:	f240 4157 	movw	r1, #1111	; 0x457
   378e2:	4811      	ldr	r0, [pc, #68]	; (37928 <z_impl_k_sleep+0x68>)
   378e4:	f004 ff68 	bl	3c7b8 <assert_post_action>

	if (ms == K_FOREVER) {
   378e8:	1c63      	adds	r3, r4, #1
   378ea:	d105      	bne.n	378f8 <z_impl_k_sleep+0x38>
		k_thread_suspend(_current);
   378ec:	4b11      	ldr	r3, [pc, #68]	; (37934 <z_impl_k_sleep+0x74>)
   378ee:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   378f0:	f000 fa82 	bl	37df8 <z_impl_k_thread_suspend>
	}

	ticks = k_ms_to_ticks_ceil32(ms);
	ticks = z_tick_sleep(ticks);
	return k_ticks_to_ms_floor64(ticks);
}
   378f4:	4620      	mov	r0, r4
   378f6:	bd38      	pop	{r3, r4, r5, pc}
   378f8:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   378fc:	f240 30e7 	movw	r0, #999	; 0x3e7
   37900:	2100      	movs	r1, #0
   37902:	2300      	movs	r3, #0
   37904:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   37908:	fbe5 0104 	umlal	r0, r1, r5, r4
   3790c:	f7e5 fa5e 	bl	1cdcc <__aeabi_uldivmod>
	ticks = z_tick_sleep(ticks);
   37910:	f7ff ff40 	bl	37794 <z_tick_sleep>
			return (t * to_hz + off) / from_hz;
   37914:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   37918:	fb80 0103 	smull	r0, r1, r0, r3
   3791c:	0bc4      	lsrs	r4, r0, #15
   3791e:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
	return k_ticks_to_ms_floor64(ticks);
   37922:	e7e7      	b.n	378f4 <z_impl_k_sleep+0x34>
   37924:	00043e0b 	.word	0x00043e0b
   37928:	00043ea3 	.word	0x00043ea3
   3792c:	00040606 	.word	0x00040606
   37930:	00042742 	.word	0x00042742
   37934:	2002976c 	.word	0x2002976c

00037938 <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
   37938:	4b01      	ldr	r3, [pc, #4]	; (37940 <z_impl_k_current_get+0x8>)
   3793a:	6898      	ldr	r0, [r3, #8]
   3793c:	4770      	bx	lr
   3793e:	bf00      	nop
   37940:	2002976c 	.word	0x2002976c

00037944 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   37944:	b570      	push	{r4, r5, r6, lr}
   37946:	4604      	mov	r4, r0
   37948:	f04f 0320 	mov.w	r3, #32
   3794c:	f3ef 8611 	mrs	r6, BASEPRI
   37950:	f383 8811 	msr	BASEPRI, r3
   37954:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   37958:	481a      	ldr	r0, [pc, #104]	; (379c4 <z_impl_k_sem_give+0x80>)
   3795a:	f000 f8f1 	bl	37b40 <z_spin_lock_valid>
   3795e:	b968      	cbnz	r0, 3797c <z_impl_k_sem_give+0x38>
   37960:	234a      	movs	r3, #74	; 0x4a
   37962:	4a19      	ldr	r2, [pc, #100]	; (379c8 <z_impl_k_sem_give+0x84>)
   37964:	4919      	ldr	r1, [pc, #100]	; (379cc <z_impl_k_sem_give+0x88>)
   37966:	481a      	ldr	r0, [pc, #104]	; (379d0 <z_impl_k_sem_give+0x8c>)
   37968:	f004 fee0 	bl	3c72c <printk>
   3796c:	4915      	ldr	r1, [pc, #84]	; (379c4 <z_impl_k_sem_give+0x80>)
   3796e:	4819      	ldr	r0, [pc, #100]	; (379d4 <z_impl_k_sem_give+0x90>)
   37970:	f004 fedc 	bl	3c72c <printk>
   37974:	214a      	movs	r1, #74	; 0x4a
   37976:	4814      	ldr	r0, [pc, #80]	; (379c8 <z_impl_k_sem_give+0x84>)
   37978:	f004 ff1e 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   3797c:	4811      	ldr	r0, [pc, #68]	; (379c4 <z_impl_k_sem_give+0x80>)
   3797e:	f000 f8fd 	bl	37b7c <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
   37982:	4620      	mov	r0, r4
   37984:	f7ff fdbe 	bl	37504 <z_unpend_first_thread>

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);

	if (thread != NULL) {
   37988:	4605      	mov	r5, r0
   3798a:	b170      	cbz	r0, 379aa <z_impl_k_sem_give+0x66>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   3798c:	7b43      	ldrb	r3, [r0, #13]
   3798e:	06db      	lsls	r3, r3, #27
   37990:	d103      	bne.n	3799a <z_impl_k_sem_give+0x56>
	if (z_is_thread_ready(thread)) {
   37992:	6983      	ldr	r3, [r0, #24]
   37994:	b90b      	cbnz	r3, 3799a <z_impl_k_sem_give+0x56>
		z_add_thread_to_ready_q(thread);
   37996:	f7ff f93f 	bl	36c18 <z_add_thread_to_ready_q>
   3799a:	2300      	movs	r3, #0
   3799c:	66ab      	str	r3, [r5, #104]	; 0x68
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
   3799e:	4631      	mov	r1, r6
}
   379a0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&lock, key);
   379a4:	4807      	ldr	r0, [pc, #28]	; (379c4 <z_impl_k_sem_give+0x80>)
   379a6:	f7fe bf4d 	b.w	36844 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   379aa:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   379ae:	429a      	cmp	r2, r3
   379b0:	bf18      	it	ne
   379b2:	3301      	addne	r3, #1
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   379b4:	2102      	movs	r1, #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   379b6:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   379b8:	f104 0010 	add.w	r0, r4, #16
   379bc:	f006 ff13 	bl	3e7e6 <z_handle_obj_poll_events>
   379c0:	e7ed      	b.n	3799e <z_impl_k_sem_give+0x5a>
   379c2:	bf00      	nop
   379c4:	200297b0 	.word	0x200297b0
   379c8:	000405cb 	.word	0x000405cb
   379cc:	000405f1 	.word	0x000405f1
   379d0:	00040606 	.word	0x00040606
   379d4:	00040623 	.word	0x00040623

000379d8 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, s32_t timeout)
{
   379d8:	b570      	push	{r4, r5, r6, lr}
   379da:	4605      	mov	r5, r0
   379dc:	460e      	mov	r6, r1
   379de:	f3ef 8305 	mrs	r3, IPSR
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");
   379e2:	b16b      	cbz	r3, 37a00 <z_impl_k_sem_take+0x28>
   379e4:	b161      	cbz	r1, 37a00 <z_impl_k_sem_take+0x28>
   379e6:	4934      	ldr	r1, [pc, #208]	; (37ab8 <z_impl_k_sem_take+0xe0>)
   379e8:	238c      	movs	r3, #140	; 0x8c
   379ea:	4a34      	ldr	r2, [pc, #208]	; (37abc <z_impl_k_sem_take+0xe4>)
   379ec:	4834      	ldr	r0, [pc, #208]	; (37ac0 <z_impl_k_sem_take+0xe8>)
   379ee:	f004 fe9d 	bl	3c72c <printk>
   379f2:	4834      	ldr	r0, [pc, #208]	; (37ac4 <z_impl_k_sem_take+0xec>)
   379f4:	f004 fe9a 	bl	3c72c <printk>
   379f8:	218c      	movs	r1, #140	; 0x8c
   379fa:	4830      	ldr	r0, [pc, #192]	; (37abc <z_impl_k_sem_take+0xe4>)
   379fc:	f004 fedc 	bl	3c7b8 <assert_post_action>
   37a00:	f04f 0320 	mov.w	r3, #32
   37a04:	f3ef 8411 	mrs	r4, BASEPRI
   37a08:	f383 8811 	msr	BASEPRI, r3
   37a0c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   37a10:	482d      	ldr	r0, [pc, #180]	; (37ac8 <z_impl_k_sem_take+0xf0>)
   37a12:	f000 f895 	bl	37b40 <z_spin_lock_valid>
   37a16:	b968      	cbnz	r0, 37a34 <z_impl_k_sem_take+0x5c>
   37a18:	234a      	movs	r3, #74	; 0x4a
   37a1a:	4a2c      	ldr	r2, [pc, #176]	; (37acc <z_impl_k_sem_take+0xf4>)
   37a1c:	492c      	ldr	r1, [pc, #176]	; (37ad0 <z_impl_k_sem_take+0xf8>)
   37a1e:	4828      	ldr	r0, [pc, #160]	; (37ac0 <z_impl_k_sem_take+0xe8>)
   37a20:	f004 fe84 	bl	3c72c <printk>
   37a24:	4928      	ldr	r1, [pc, #160]	; (37ac8 <z_impl_k_sem_take+0xf0>)
   37a26:	482b      	ldr	r0, [pc, #172]	; (37ad4 <z_impl_k_sem_take+0xfc>)
   37a28:	f004 fe80 	bl	3c72c <printk>
   37a2c:	214a      	movs	r1, #74	; 0x4a
   37a2e:	4827      	ldr	r0, [pc, #156]	; (37acc <z_impl_k_sem_take+0xf4>)
   37a30:	f004 fec2 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   37a34:	4824      	ldr	r0, [pc, #144]	; (37ac8 <z_impl_k_sem_take+0xf0>)
   37a36:	f000 f8a1 	bl	37b7c <z_spin_lock_set_owner>

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
   37a3a:	68ab      	ldr	r3, [r5, #8]
   37a3c:	b1cb      	cbz	r3, 37a72 <z_impl_k_sem_take+0x9a>
		sem->count--;
   37a3e:	3b01      	subs	r3, #1
   37a40:	60ab      	str	r3, [r5, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   37a42:	4821      	ldr	r0, [pc, #132]	; (37ac8 <z_impl_k_sem_take+0xf0>)
   37a44:	f000 f88a 	bl	37b5c <z_spin_unlock_valid>
   37a48:	b968      	cbnz	r0, 37a66 <z_impl_k_sem_take+0x8e>
   37a4a:	235d      	movs	r3, #93	; 0x5d
   37a4c:	4a1f      	ldr	r2, [pc, #124]	; (37acc <z_impl_k_sem_take+0xf4>)
   37a4e:	4922      	ldr	r1, [pc, #136]	; (37ad8 <z_impl_k_sem_take+0x100>)
   37a50:	481b      	ldr	r0, [pc, #108]	; (37ac0 <z_impl_k_sem_take+0xe8>)
   37a52:	f004 fe6b 	bl	3c72c <printk>
   37a56:	491c      	ldr	r1, [pc, #112]	; (37ac8 <z_impl_k_sem_take+0xf0>)
   37a58:	4820      	ldr	r0, [pc, #128]	; (37adc <z_impl_k_sem_take+0x104>)
   37a5a:	f004 fe67 	bl	3c72c <printk>
   37a5e:	215d      	movs	r1, #93	; 0x5d
   37a60:	481a      	ldr	r0, [pc, #104]	; (37acc <z_impl_k_sem_take+0xf4>)
   37a62:	f004 fea9 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   37a66:	f384 8811 	msr	BASEPRI, r4
   37a6a:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   37a6e:	2000      	movs	r0, #0
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
   37a70:	bd70      	pop	{r4, r5, r6, pc}
	if (timeout == K_NO_WAIT) {
   37a72:	b9c6      	cbnz	r6, 37aa6 <z_impl_k_sem_take+0xce>
   37a74:	4814      	ldr	r0, [pc, #80]	; (37ac8 <z_impl_k_sem_take+0xf0>)
   37a76:	f000 f871 	bl	37b5c <z_spin_unlock_valid>
   37a7a:	b968      	cbnz	r0, 37a98 <z_impl_k_sem_take+0xc0>
   37a7c:	235d      	movs	r3, #93	; 0x5d
   37a7e:	4a13      	ldr	r2, [pc, #76]	; (37acc <z_impl_k_sem_take+0xf4>)
   37a80:	4915      	ldr	r1, [pc, #84]	; (37ad8 <z_impl_k_sem_take+0x100>)
   37a82:	480f      	ldr	r0, [pc, #60]	; (37ac0 <z_impl_k_sem_take+0xe8>)
   37a84:	f004 fe52 	bl	3c72c <printk>
   37a88:	490f      	ldr	r1, [pc, #60]	; (37ac8 <z_impl_k_sem_take+0xf0>)
   37a8a:	4814      	ldr	r0, [pc, #80]	; (37adc <z_impl_k_sem_take+0x104>)
   37a8c:	f004 fe4e 	bl	3c72c <printk>
   37a90:	215d      	movs	r1, #93	; 0x5d
   37a92:	480e      	ldr	r0, [pc, #56]	; (37acc <z_impl_k_sem_take+0xf4>)
   37a94:	f004 fe90 	bl	3c7b8 <assert_post_action>
   37a98:	f384 8811 	msr	BASEPRI, r4
   37a9c:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   37aa0:	f06f 000f 	mvn.w	r0, #15
		goto out;
   37aa4:	e7e4      	b.n	37a70 <z_impl_k_sem_take+0x98>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   37aa6:	4633      	mov	r3, r6
   37aa8:	462a      	mov	r2, r5
   37aaa:	4621      	mov	r1, r4
}
   37aac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   37ab0:	4805      	ldr	r0, [pc, #20]	; (37ac8 <z_impl_k_sem_take+0xf0>)
   37ab2:	f7ff bc6b 	b.w	3738c <z_pend_curr>
   37ab6:	bf00      	nop
   37ab8:	00043f74 	.word	0x00043f74
   37abc:	00043f54 	.word	0x00043f54
   37ac0:	00040606 	.word	0x00040606
   37ac4:	00042742 	.word	0x00042742
   37ac8:	200297b0 	.word	0x200297b0
   37acc:	000405cb 	.word	0x000405cb
   37ad0:	000405f1 	.word	0x000405f1
   37ad4:	00040623 	.word	0x00040623
   37ad8:	00040665 	.word	0x00040665
   37adc:	0004067c 	.word	0x0004067c

00037ae0 <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
   37ae0:	b510      	push	{r4, lr}
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
   37ae2:	4c08      	ldr	r4, [pc, #32]	; (37b04 <k_sys_work_q_init+0x24>)
   37ae4:	f04f 33ff 	mov.w	r3, #4294967295
   37ae8:	f44f 6200 	mov.w	r2, #2048	; 0x800
   37aec:	4906      	ldr	r1, [pc, #24]	; (37b08 <k_sys_work_q_init+0x28>)
   37aee:	4620      	mov	r0, r4
   37af0:	f000 f9d6 	bl	37ea0 <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
   37af4:	4905      	ldr	r1, [pc, #20]	; (37b0c <k_sys_work_q_init+0x2c>)
   37af6:	f104 0014 	add.w	r0, r4, #20
   37afa:	f006 fd6f 	bl	3e5dc <z_impl_k_thread_name_set>
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
   37afe:	2000      	movs	r0, #0
   37b00:	bd10      	pop	{r4, pc}
   37b02:	bf00      	nop
   37b04:	200297b4 	.word	0x200297b4
   37b08:	20032888 	.word	0x20032888
   37b0c:	00043fa0 	.word	0x00043fa0

00037b10 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
   37b10:	b530      	push	{r4, r5, lr}
   37b12:	b087      	sub	sp, #28
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   37b14:	9d0e      	ldr	r5, [sp, #56]	; 0x38
{
   37b16:	4604      	mov	r4, r0
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   37b18:	9504      	str	r5, [sp, #16]
   37b1a:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   37b1c:	9503      	str	r5, [sp, #12]
   37b1e:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   37b20:	9502      	str	r5, [sp, #8]
   37b22:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   37b24:	9501      	str	r5, [sp, #4]
   37b26:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   37b28:	9500      	str	r5, [sp, #0]
   37b2a:	f7f0 fb53 	bl	281d4 <arch_new_thread>
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
   37b2e:	4b03      	ldr	r3, [pc, #12]	; (37b3c <z_setup_new_thread+0x2c>)
   37b30:	689b      	ldr	r3, [r3, #8]
   37b32:	b103      	cbz	r3, 37b36 <z_setup_new_thread+0x26>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
   37b34:	6e1b      	ldr	r3, [r3, #96]	; 0x60
   37b36:	6623      	str	r3, [r4, #96]	; 0x60
	sys_trace_thread_create(new_thread);
}
   37b38:	b007      	add	sp, #28
   37b3a:	bd30      	pop	{r4, r5, pc}
   37b3c:	2002976c 	.word	0x2002976c

00037b40 <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
   37b40:	6800      	ldr	r0, [r0, #0]

	if (thread_cpu) {
   37b42:	b138      	cbz	r0, 37b54 <z_spin_lock_valid+0x14>
		if ((thread_cpu & 3) == _current_cpu->id) {
   37b44:	4b04      	ldr	r3, [pc, #16]	; (37b58 <z_spin_lock_valid+0x18>)
   37b46:	f000 0003 	and.w	r0, r0, #3
   37b4a:	7d1b      	ldrb	r3, [r3, #20]
   37b4c:	1ac0      	subs	r0, r0, r3
   37b4e:	bf18      	it	ne
   37b50:	2001      	movne	r0, #1
   37b52:	4770      	bx	lr
			return false;
		}
	}
	return true;
   37b54:	2001      	movs	r0, #1
}
   37b56:	4770      	bx	lr
   37b58:	2002976c 	.word	0x2002976c

00037b5c <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
   37b5c:	4a06      	ldr	r2, [pc, #24]	; (37b78 <z_spin_unlock_valid+0x1c>)
   37b5e:	7d11      	ldrb	r1, [r2, #20]
   37b60:	6893      	ldr	r3, [r2, #8]
   37b62:	6802      	ldr	r2, [r0, #0]
   37b64:	430b      	orrs	r3, r1
   37b66:	429a      	cmp	r2, r3
   37b68:	f04f 0300 	mov.w	r3, #0
		return false;
	}
	l->thread_cpu = 0;
   37b6c:	bf06      	itte	eq
   37b6e:	6003      	streq	r3, [r0, #0]
	return true;
   37b70:	2001      	moveq	r0, #1
		return false;
   37b72:	4618      	movne	r0, r3
}
   37b74:	4770      	bx	lr
   37b76:	bf00      	nop
   37b78:	2002976c 	.word	0x2002976c

00037b7c <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
   37b7c:	4a02      	ldr	r2, [pc, #8]	; (37b88 <z_spin_lock_set_owner+0xc>)
   37b7e:	7d11      	ldrb	r1, [r2, #20]
   37b80:	6893      	ldr	r3, [r2, #8]
   37b82:	430b      	orrs	r3, r1
   37b84:	6003      	str	r3, [r0, #0]
}
   37b86:	4770      	bx	lr
   37b88:	2002976c 	.word	0x2002976c

00037b8c <z_impl_k_thread_start>:
{
   37b8c:	b538      	push	{r3, r4, r5, lr}
   37b8e:	4604      	mov	r4, r0
	__asm__ volatile(
   37b90:	f04f 0320 	mov.w	r3, #32
   37b94:	f3ef 8511 	mrs	r5, BASEPRI
   37b98:	f383 8811 	msr	BASEPRI, r3
   37b9c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   37ba0:	481f      	ldr	r0, [pc, #124]	; (37c20 <z_impl_k_thread_start+0x94>)
   37ba2:	f7ff ffcd 	bl	37b40 <z_spin_lock_valid>
   37ba6:	b968      	cbnz	r0, 37bc4 <z_impl_k_thread_start+0x38>
   37ba8:	234a      	movs	r3, #74	; 0x4a
   37baa:	4a1e      	ldr	r2, [pc, #120]	; (37c24 <z_impl_k_thread_start+0x98>)
   37bac:	491e      	ldr	r1, [pc, #120]	; (37c28 <z_impl_k_thread_start+0x9c>)
   37bae:	481f      	ldr	r0, [pc, #124]	; (37c2c <z_impl_k_thread_start+0xa0>)
   37bb0:	f004 fdbc 	bl	3c72c <printk>
   37bb4:	491a      	ldr	r1, [pc, #104]	; (37c20 <z_impl_k_thread_start+0x94>)
   37bb6:	481e      	ldr	r0, [pc, #120]	; (37c30 <z_impl_k_thread_start+0xa4>)
   37bb8:	f004 fdb8 	bl	3c72c <printk>
   37bbc:	214a      	movs	r1, #74	; 0x4a
   37bbe:	4819      	ldr	r0, [pc, #100]	; (37c24 <z_impl_k_thread_start+0x98>)
   37bc0:	f004 fdfa 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   37bc4:	4816      	ldr	r0, [pc, #88]	; (37c20 <z_impl_k_thread_start+0x94>)
   37bc6:	f7ff ffd9 	bl	37b7c <z_spin_lock_set_owner>
	if (z_has_thread_started(thread)) {
   37bca:	7b63      	ldrb	r3, [r4, #13]
   37bcc:	075a      	lsls	r2, r3, #29
   37bce:	d416      	bmi.n	37bfe <z_impl_k_thread_start+0x72>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   37bd0:	4813      	ldr	r0, [pc, #76]	; (37c20 <z_impl_k_thread_start+0x94>)
   37bd2:	f7ff ffc3 	bl	37b5c <z_spin_unlock_valid>
   37bd6:	b968      	cbnz	r0, 37bf4 <z_impl_k_thread_start+0x68>
   37bd8:	235d      	movs	r3, #93	; 0x5d
   37bda:	4a12      	ldr	r2, [pc, #72]	; (37c24 <z_impl_k_thread_start+0x98>)
   37bdc:	4915      	ldr	r1, [pc, #84]	; (37c34 <z_impl_k_thread_start+0xa8>)
   37bde:	4813      	ldr	r0, [pc, #76]	; (37c2c <z_impl_k_thread_start+0xa0>)
   37be0:	f004 fda4 	bl	3c72c <printk>
   37be4:	490e      	ldr	r1, [pc, #56]	; (37c20 <z_impl_k_thread_start+0x94>)
   37be6:	4814      	ldr	r0, [pc, #80]	; (37c38 <z_impl_k_thread_start+0xac>)
   37be8:	f004 fda0 	bl	3c72c <printk>
   37bec:	215d      	movs	r1, #93	; 0x5d
   37bee:	480d      	ldr	r0, [pc, #52]	; (37c24 <z_impl_k_thread_start+0x98>)
   37bf0:	f004 fde2 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   37bf4:	f385 8811 	msr	BASEPRI, r5
   37bf8:	f3bf 8f6f 	isb	sy
}
   37bfc:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   37bfe:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   37c02:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
   37c06:	7362      	strb	r2, [r4, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   37c08:	d104      	bne.n	37c14 <z_impl_k_thread_start+0x88>
	if (z_is_thread_ready(thread)) {
   37c0a:	69a3      	ldr	r3, [r4, #24]
   37c0c:	b913      	cbnz	r3, 37c14 <z_impl_k_thread_start+0x88>
		z_add_thread_to_ready_q(thread);
   37c0e:	4620      	mov	r0, r4
   37c10:	f7ff f802 	bl	36c18 <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
   37c14:	4629      	mov	r1, r5
}
   37c16:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   37c1a:	4801      	ldr	r0, [pc, #4]	; (37c20 <z_impl_k_thread_start+0x94>)
   37c1c:	f7fe be12 	b.w	36844 <z_reschedule>
   37c20:	20029878 	.word	0x20029878
   37c24:	000405cb 	.word	0x000405cb
   37c28:	000405f1 	.word	0x000405f1
   37c2c:	00040606 	.word	0x00040606
   37c30:	00040623 	.word	0x00040623
   37c34:	00040665 	.word	0x00040665
   37c38:	0004067c 	.word	0x0004067c

00037c3c <z_impl_k_thread_create>:
{
   37c3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   37c40:	b086      	sub	sp, #24
   37c42:	4604      	mov	r4, r0
   37c44:	460e      	mov	r6, r1
   37c46:	4617      	mov	r7, r2
   37c48:	4698      	mov	r8, r3
   37c4a:	9d11      	ldr	r5, [sp, #68]	; 0x44
   37c4c:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
   37c50:	b173      	cbz	r3, 37c70 <z_impl_k_thread_create+0x34>
   37c52:	491f      	ldr	r1, [pc, #124]	; (37cd0 <z_impl_k_thread_create+0x94>)
   37c54:	f240 2357 	movw	r3, #599	; 0x257
   37c58:	4a1e      	ldr	r2, [pc, #120]	; (37cd4 <z_impl_k_thread_create+0x98>)
   37c5a:	481f      	ldr	r0, [pc, #124]	; (37cd8 <z_impl_k_thread_create+0x9c>)
   37c5c:	f004 fd66 	bl	3c72c <printk>
   37c60:	481e      	ldr	r0, [pc, #120]	; (37cdc <z_impl_k_thread_create+0xa0>)
   37c62:	f004 fd63 	bl	3c72c <printk>
   37c66:	f240 2157 	movw	r1, #599	; 0x257
   37c6a:	481a      	ldr	r0, [pc, #104]	; (37cd4 <z_impl_k_thread_create+0x98>)
   37c6c:	f004 fda4 	bl	3c7b8 <assert_post_action>
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   37c70:	2300      	movs	r3, #0
   37c72:	9305      	str	r3, [sp, #20]
   37c74:	9b10      	ldr	r3, [sp, #64]	; 0x40
   37c76:	463a      	mov	r2, r7
   37c78:	9304      	str	r3, [sp, #16]
   37c7a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   37c7c:	4631      	mov	r1, r6
   37c7e:	9303      	str	r3, [sp, #12]
   37c80:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   37c82:	4620      	mov	r0, r4
   37c84:	9302      	str	r3, [sp, #8]
   37c86:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   37c88:	9301      	str	r3, [sp, #4]
   37c8a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   37c8c:	9300      	str	r3, [sp, #0]
   37c8e:	4643      	mov	r3, r8
   37c90:	f7ff ff3e 	bl	37b10 <z_setup_new_thread>
	if (delay != K_FOREVER) {
   37c94:	1c6b      	adds	r3, r5, #1
   37c96:	d003      	beq.n	37ca0 <z_impl_k_thread_create+0x64>
	if (delay == 0) {
   37c98:	b935      	cbnz	r5, 37ca8 <z_impl_k_thread_create+0x6c>
	z_impl_k_thread_start(thread);
   37c9a:	4620      	mov	r0, r4
   37c9c:	f7ff ff76 	bl	37b8c <z_impl_k_thread_start>
}
   37ca0:	4620      	mov	r0, r4
   37ca2:	b006      	add	sp, #24
   37ca4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			return (u32_t)((t * to_hz + off) / from_hz);
   37ca8:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   37cac:	f240 30e7 	movw	r0, #999	; 0x3e7
   37cb0:	2100      	movs	r1, #0
   37cb2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   37cb6:	2300      	movs	r3, #0
   37cb8:	fbe6 0105 	umlal	r0, r1, r6, r5
   37cbc:	f7e5 f886 	bl	1cdcc <__aeabi_uldivmod>
   37cc0:	4907      	ldr	r1, [pc, #28]	; (37ce0 <z_impl_k_thread_create+0xa4>)
   37cc2:	1c42      	adds	r2, r0, #1
   37cc4:	f104 0018 	add.w	r0, r4, #24
   37cc8:	f000 f9d4 	bl	38074 <z_add_timeout>
   37ccc:	e7e8      	b.n	37ca0 <z_impl_k_thread_create+0x64>
   37cce:	bf00      	nop
   37cd0:	00043e0b 	.word	0x00043e0b
   37cd4:	00043fa9 	.word	0x00043fa9
   37cd8:	00040606 	.word	0x00040606
   37cdc:	00043fcc 	.word	0x00043fcc
   37ce0:	00036d19 	.word	0x00036d19

00037ce4 <z_init_static_threads>:
{
   37ce4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   37ce8:	4f3c      	ldr	r7, [pc, #240]	; (37ddc <z_init_static_threads+0xf8>)
   37cea:	4d3d      	ldr	r5, [pc, #244]	; (37de0 <z_init_static_threads+0xfc>)
   37cec:	463e      	mov	r6, r7
   37cee:	f8df 8100 	ldr.w	r8, [pc, #256]	; 37df0 <z_init_static_threads+0x10c>
{
   37cf2:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
   37cf4:	42bd      	cmp	r5, r7
   37cf6:	d90e      	bls.n	37d16 <z_init_static_threads+0x32>
   37cf8:	493a      	ldr	r1, [pc, #232]	; (37de4 <z_init_static_threads+0x100>)
   37cfa:	f240 23e7 	movw	r3, #743	; 0x2e7
   37cfe:	4642      	mov	r2, r8
   37d00:	4839      	ldr	r0, [pc, #228]	; (37de8 <z_init_static_threads+0x104>)
   37d02:	f004 fd13 	bl	3c72c <printk>
   37d06:	4839      	ldr	r0, [pc, #228]	; (37dec <z_init_static_threads+0x108>)
   37d08:	f004 fd10 	bl	3c72c <printk>
   37d0c:	f240 21e7 	movw	r1, #743	; 0x2e7
   37d10:	4640      	mov	r0, r8
   37d12:	f004 fd51 	bl	3c7b8 <assert_post_action>
   37d16:	42b5      	cmp	r5, r6
   37d18:	f105 0430 	add.w	r4, r5, #48	; 0x30
   37d1c:	d31f      	bcc.n	37d5e <z_init_static_threads+0x7a>
	k_sched_lock();
   37d1e:	f7fe fdcd 	bl	368bc <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   37d22:	4c2f      	ldr	r4, [pc, #188]	; (37de0 <z_init_static_threads+0xfc>)
   37d24:	4d32      	ldr	r5, [pc, #200]	; (37df0 <z_init_static_threads+0x10c>)
   37d26:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 37de4 <z_init_static_threads+0x100>
   37d2a:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 37de8 <z_init_static_threads+0x104>
   37d2e:	42b4      	cmp	r4, r6
   37d30:	d90e      	bls.n	37d50 <z_init_static_threads+0x6c>
   37d32:	4641      	mov	r1, r8
   37d34:	f240 3306 	movw	r3, #774	; 0x306
   37d38:	462a      	mov	r2, r5
   37d3a:	4648      	mov	r0, r9
   37d3c:	f004 fcf6 	bl	3c72c <printk>
   37d40:	482a      	ldr	r0, [pc, #168]	; (37dec <z_init_static_threads+0x108>)
   37d42:	f004 fcf3 	bl	3c72c <printk>
   37d46:	f240 3106 	movw	r1, #774	; 0x306
   37d4a:	4628      	mov	r0, r5
   37d4c:	f004 fd34 	bl	3c7b8 <assert_post_action>
   37d50:	42b4      	cmp	r4, r6
   37d52:	d321      	bcc.n	37d98 <z_init_static_threads+0xb4>
}
   37d54:	b007      	add	sp, #28
   37d56:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_sched_unlock();
   37d5a:	f7fe bee1 	b.w	36b20 <k_sched_unlock>
		z_setup_new_thread(
   37d5e:	f854 3c04 	ldr.w	r3, [r4, #-4]
   37d62:	9305      	str	r3, [sp, #20]
   37d64:	f854 3c10 	ldr.w	r3, [r4, #-16]
   37d68:	9304      	str	r3, [sp, #16]
   37d6a:	f854 3c14 	ldr.w	r3, [r4, #-20]
   37d6e:	9303      	str	r3, [sp, #12]
   37d70:	f854 3c18 	ldr.w	r3, [r4, #-24]
   37d74:	9302      	str	r3, [sp, #8]
   37d76:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   37d7a:	9301      	str	r3, [sp, #4]
   37d7c:	f854 3c20 	ldr.w	r3, [r4, #-32]
   37d80:	9300      	str	r3, [sp, #0]
   37d82:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   37d86:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   37d8a:	f7ff fec1 	bl	37b10 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   37d8e:	f854 3c30 	ldr.w	r3, [r4, #-48]
   37d92:	64dd      	str	r5, [r3, #76]	; 0x4c
   37d94:	4625      	mov	r5, r4
   37d96:	e7ad      	b.n	37cf4 <z_init_static_threads+0x10>
		if (thread_data->init_delay != K_FOREVER) {
   37d98:	f8d4 c024 	ldr.w	ip, [r4, #36]	; 0x24
   37d9c:	f1bc 3fff 	cmp.w	ip, #4294967295
   37da0:	d006      	beq.n	37db0 <z_init_static_threads+0xcc>
			schedule_new_thread(thread_data->init_thread,
   37da2:	6827      	ldr	r7, [r4, #0]
	if (delay == 0) {
   37da4:	f1bc 0f00 	cmp.w	ip, #0
   37da8:	d104      	bne.n	37db4 <z_init_static_threads+0xd0>
   37daa:	4638      	mov	r0, r7
   37dac:	f7ff feee 	bl	37b8c <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   37db0:	3430      	adds	r4, #48	; 0x30
   37db2:	e7bc      	b.n	37d2e <z_init_static_threads+0x4a>
   37db4:	f44f 4e00 	mov.w	lr, #32768	; 0x8000
   37db8:	f240 30e7 	movw	r0, #999	; 0x3e7
   37dbc:	2100      	movs	r1, #0
   37dbe:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   37dc2:	2300      	movs	r3, #0
   37dc4:	fbee 010c 	umlal	r0, r1, lr, ip
   37dc8:	f7e5 f800 	bl	1cdcc <__aeabi_uldivmod>
   37dcc:	4909      	ldr	r1, [pc, #36]	; (37df4 <z_init_static_threads+0x110>)
   37dce:	1c42      	adds	r2, r0, #1
   37dd0:	f107 0018 	add.w	r0, r7, #24
   37dd4:	f000 f94e 	bl	38074 <z_add_timeout>
   37dd8:	e7ea      	b.n	37db0 <z_init_static_threads+0xcc>
   37dda:	bf00      	nop
   37ddc:	20037a18 	.word	0x20037a18
   37de0:	20037a18 	.word	0x20037a18
   37de4:	00043ff1 	.word	0x00043ff1
   37de8:	00040606 	.word	0x00040606
   37dec:	00043ce2 	.word	0x00043ce2
   37df0:	00043fa9 	.word	0x00043fa9
   37df4:	00036d19 	.word	0x00036d19

00037df8 <z_impl_k_thread_suspend>:
{
   37df8:	b538      	push	{r3, r4, r5, lr}
   37dfa:	4605      	mov	r5, r0
	__asm__ volatile(
   37dfc:	f04f 0320 	mov.w	r3, #32
   37e00:	f3ef 8411 	mrs	r4, BASEPRI
   37e04:	f383 8811 	msr	BASEPRI, r3
   37e08:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   37e0c:	481c      	ldr	r0, [pc, #112]	; (37e80 <z_impl_k_thread_suspend+0x88>)
   37e0e:	f7ff fe97 	bl	37b40 <z_spin_lock_valid>
   37e12:	b968      	cbnz	r0, 37e30 <z_impl_k_thread_suspend+0x38>
   37e14:	234a      	movs	r3, #74	; 0x4a
   37e16:	4a1b      	ldr	r2, [pc, #108]	; (37e84 <z_impl_k_thread_suspend+0x8c>)
   37e18:	491b      	ldr	r1, [pc, #108]	; (37e88 <z_impl_k_thread_suspend+0x90>)
   37e1a:	481c      	ldr	r0, [pc, #112]	; (37e8c <z_impl_k_thread_suspend+0x94>)
   37e1c:	f004 fc86 	bl	3c72c <printk>
   37e20:	4917      	ldr	r1, [pc, #92]	; (37e80 <z_impl_k_thread_suspend+0x88>)
   37e22:	481b      	ldr	r0, [pc, #108]	; (37e90 <z_impl_k_thread_suspend+0x98>)
   37e24:	f004 fc82 	bl	3c72c <printk>
   37e28:	214a      	movs	r1, #74	; 0x4a
   37e2a:	4816      	ldr	r0, [pc, #88]	; (37e84 <z_impl_k_thread_suspend+0x8c>)
   37e2c:	f004 fcc4 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   37e30:	4813      	ldr	r0, [pc, #76]	; (37e80 <z_impl_k_thread_suspend+0x88>)
   37e32:	f7ff fea3 	bl	37b7c <z_spin_lock_set_owner>
	z_thread_single_suspend(thread);
   37e36:	4628      	mov	r0, r5
   37e38:	f7ff f89c 	bl	36f74 <z_thread_single_suspend>
	if (thread == _current) {
   37e3c:	4b15      	ldr	r3, [pc, #84]	; (37e94 <z_impl_k_thread_suspend+0x9c>)
   37e3e:	689b      	ldr	r3, [r3, #8]
   37e40:	42ab      	cmp	r3, r5
   37e42:	d105      	bne.n	37e50 <z_impl_k_thread_suspend+0x58>
		z_reschedule(&lock, key);
   37e44:	4621      	mov	r1, r4
}
   37e46:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&lock, key);
   37e4a:	480d      	ldr	r0, [pc, #52]	; (37e80 <z_impl_k_thread_suspend+0x88>)
   37e4c:	f7fe bcfa 	b.w	36844 <z_reschedule>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   37e50:	480b      	ldr	r0, [pc, #44]	; (37e80 <z_impl_k_thread_suspend+0x88>)
   37e52:	f7ff fe83 	bl	37b5c <z_spin_unlock_valid>
   37e56:	b968      	cbnz	r0, 37e74 <z_impl_k_thread_suspend+0x7c>
   37e58:	235d      	movs	r3, #93	; 0x5d
   37e5a:	4a0a      	ldr	r2, [pc, #40]	; (37e84 <z_impl_k_thread_suspend+0x8c>)
   37e5c:	490e      	ldr	r1, [pc, #56]	; (37e98 <z_impl_k_thread_suspend+0xa0>)
   37e5e:	480b      	ldr	r0, [pc, #44]	; (37e8c <z_impl_k_thread_suspend+0x94>)
   37e60:	f004 fc64 	bl	3c72c <printk>
   37e64:	4906      	ldr	r1, [pc, #24]	; (37e80 <z_impl_k_thread_suspend+0x88>)
   37e66:	480d      	ldr	r0, [pc, #52]	; (37e9c <z_impl_k_thread_suspend+0xa4>)
   37e68:	f004 fc60 	bl	3c72c <printk>
   37e6c:	215d      	movs	r1, #93	; 0x5d
   37e6e:	4805      	ldr	r0, [pc, #20]	; (37e84 <z_impl_k_thread_suspend+0x8c>)
   37e70:	f004 fca2 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   37e74:	f384 8811 	msr	BASEPRI, r4
   37e78:	f3bf 8f6f 	isb	sy
}
   37e7c:	bd38      	pop	{r3, r4, r5, pc}
   37e7e:	bf00      	nop
   37e80:	20029878 	.word	0x20029878
   37e84:	000405cb 	.word	0x000405cb
   37e88:	000405f1 	.word	0x000405f1
   37e8c:	00040606 	.word	0x00040606
   37e90:	00040623 	.word	0x00040623
   37e94:	2002976c 	.word	0x2002976c
   37e98:	00040665 	.word	0x00040665
   37e9c:	0004067c 	.word	0x0004067c

00037ea0 <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
   37ea0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   37ea4:	4605      	mov	r5, r0
   37ea6:	b086      	sub	sp, #24
   37ea8:	460e      	mov	r6, r1
   37eaa:	4617      	mov	r7, r2
   37eac:	4698      	mov	r8, r3
	z_impl_k_queue_init(queue);
   37eae:	f006 fb2b 	bl	3e508 <z_impl_k_queue_init>
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
   37eb2:	f105 0414 	add.w	r4, r5, #20
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   37eb6:	2000      	movs	r0, #0
   37eb8:	4b09      	ldr	r3, [pc, #36]	; (37ee0 <k_work_q_start+0x40>)
   37eba:	e9cd 0004 	strd	r0, r0, [sp, #16]
   37ebe:	e9cd 0802 	strd	r0, r8, [sp, #8]
   37ec2:	e9cd 5000 	strd	r5, r0, [sp]
   37ec6:	463a      	mov	r2, r7
   37ec8:	4631      	mov	r1, r6
   37eca:	4620      	mov	r0, r4
   37ecc:	f7ff feb6 	bl	37c3c <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   37ed0:	4620      	mov	r0, r4
   37ed2:	4904      	ldr	r1, [pc, #16]	; (37ee4 <k_work_q_start+0x44>)
			work_q, NULL, NULL, prio, 0, K_NO_WAIT);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
   37ed4:	b006      	add	sp, #24
   37ed6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   37eda:	f006 bb7f 	b.w	3e5dc <z_impl_k_thread_name_set>
   37ede:	bf00      	nop
   37ee0:	0003c783 	.word	0x0003c783
   37ee4:	000406b9 	.word	0x000406b9

00037ee8 <k_delayed_work_submit_to_queue>:
}

int k_delayed_work_submit_to_queue(struct k_work_q *work_q,
				   struct k_delayed_work *work,
				   s32_t delay)
{
   37ee8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   37eec:	4606      	mov	r6, r0
   37eee:	460d      	mov	r5, r1
   37ef0:	4690      	mov	r8, r2
	__asm__ volatile(
   37ef2:	f04f 0320 	mov.w	r3, #32
   37ef6:	f3ef 8711 	mrs	r7, BASEPRI
   37efa:	f383 8811 	msr	BASEPRI, r3
   37efe:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   37f02:	4837      	ldr	r0, [pc, #220]	; (37fe0 <k_delayed_work_submit_to_queue+0xf8>)
   37f04:	f7ff fe1c 	bl	37b40 <z_spin_lock_valid>
   37f08:	b968      	cbnz	r0, 37f26 <k_delayed_work_submit_to_queue+0x3e>
   37f0a:	234a      	movs	r3, #74	; 0x4a
   37f0c:	4a35      	ldr	r2, [pc, #212]	; (37fe4 <k_delayed_work_submit_to_queue+0xfc>)
   37f0e:	4936      	ldr	r1, [pc, #216]	; (37fe8 <k_delayed_work_submit_to_queue+0x100>)
   37f10:	4836      	ldr	r0, [pc, #216]	; (37fec <k_delayed_work_submit_to_queue+0x104>)
   37f12:	f004 fc0b 	bl	3c72c <printk>
   37f16:	4932      	ldr	r1, [pc, #200]	; (37fe0 <k_delayed_work_submit_to_queue+0xf8>)
   37f18:	4835      	ldr	r0, [pc, #212]	; (37ff0 <k_delayed_work_submit_to_queue+0x108>)
   37f1a:	f004 fc07 	bl	3c72c <printk>
   37f1e:	214a      	movs	r1, #74	; 0x4a
   37f20:	4830      	ldr	r0, [pc, #192]	; (37fe4 <k_delayed_work_submit_to_queue+0xfc>)
   37f22:	f004 fc49 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   37f26:	482e      	ldr	r0, [pc, #184]	; (37fe0 <k_delayed_work_submit_to_queue+0xf8>)
   37f28:	f7ff fe28 	bl	37b7c <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	int err = 0;

	/* Work cannot be active in multiple queues */
	if (work->work_q != NULL && work->work_q != work_q) {
   37f2c:	69ec      	ldr	r4, [r5, #28]
   37f2e:	b1ec      	cbz	r4, 37f6c <k_delayed_work_submit_to_queue+0x84>
   37f30:	42b4      	cmp	r4, r6
   37f32:	d152      	bne.n	37fda <k_delayed_work_submit_to_queue+0xf2>
		goto done;
	}

	/* Cancel if work has been submitted */
	if (work->work_q == work_q) {
		err = work_cancel(work);
   37f34:	4628      	mov	r0, r5
   37f36:	f006 fb7e 	bl	3e636 <work_cancel>
		if (err < 0) {
   37f3a:	1e04      	subs	r4, r0, #0
   37f3c:	da18      	bge.n	37f70 <k_delayed_work_submit_to_queue+0x88>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   37f3e:	4828      	ldr	r0, [pc, #160]	; (37fe0 <k_delayed_work_submit_to_queue+0xf8>)
   37f40:	f7ff fe0c 	bl	37b5c <z_spin_unlock_valid>
   37f44:	b968      	cbnz	r0, 37f62 <k_delayed_work_submit_to_queue+0x7a>
   37f46:	235d      	movs	r3, #93	; 0x5d
   37f48:	4a26      	ldr	r2, [pc, #152]	; (37fe4 <k_delayed_work_submit_to_queue+0xfc>)
   37f4a:	492a      	ldr	r1, [pc, #168]	; (37ff4 <k_delayed_work_submit_to_queue+0x10c>)
   37f4c:	4827      	ldr	r0, [pc, #156]	; (37fec <k_delayed_work_submit_to_queue+0x104>)
   37f4e:	f004 fbed 	bl	3c72c <printk>
   37f52:	4923      	ldr	r1, [pc, #140]	; (37fe0 <k_delayed_work_submit_to_queue+0xf8>)
   37f54:	4828      	ldr	r0, [pc, #160]	; (37ff8 <k_delayed_work_submit_to_queue+0x110>)
   37f56:	f004 fbe9 	bl	3c72c <printk>
   37f5a:	215d      	movs	r1, #93	; 0x5d
   37f5c:	4821      	ldr	r0, [pc, #132]	; (37fe4 <k_delayed_work_submit_to_queue+0xfc>)
   37f5e:	f004 fc2b 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   37f62:	f387 8811 	msr	BASEPRI, r7
   37f66:	f3bf 8f6f 	isb	sy
	z_add_timeout(&work->timeout, work_timeout,
		     _TICK_ALIGN + k_ms_to_ticks_ceil32(delay));

done:
	k_spin_unlock(&lock, key);
	return err;
   37f6a:	e020      	b.n	37fae <k_delayed_work_submit_to_queue+0xc6>
	if (work->work_q == work_q) {
   37f6c:	2e00      	cmp	r6, #0
   37f6e:	d0e1      	beq.n	37f34 <k_delayed_work_submit_to_queue+0x4c>
	work->work_q = work_q;
   37f70:	61ee      	str	r6, [r5, #28]
	if (delay == 0) {
   37f72:	f1b8 0f00 	cmp.w	r8, #0
   37f76:	d11d      	bne.n	37fb4 <k_delayed_work_submit_to_queue+0xcc>
   37f78:	4819      	ldr	r0, [pc, #100]	; (37fe0 <k_delayed_work_submit_to_queue+0xf8>)
   37f7a:	f7ff fdef 	bl	37b5c <z_spin_unlock_valid>
   37f7e:	b968      	cbnz	r0, 37f9c <k_delayed_work_submit_to_queue+0xb4>
   37f80:	235d      	movs	r3, #93	; 0x5d
   37f82:	4a18      	ldr	r2, [pc, #96]	; (37fe4 <k_delayed_work_submit_to_queue+0xfc>)
   37f84:	491b      	ldr	r1, [pc, #108]	; (37ff4 <k_delayed_work_submit_to_queue+0x10c>)
   37f86:	4819      	ldr	r0, [pc, #100]	; (37fec <k_delayed_work_submit_to_queue+0x104>)
   37f88:	f004 fbd0 	bl	3c72c <printk>
   37f8c:	4914      	ldr	r1, [pc, #80]	; (37fe0 <k_delayed_work_submit_to_queue+0xf8>)
   37f8e:	481a      	ldr	r0, [pc, #104]	; (37ff8 <k_delayed_work_submit_to_queue+0x110>)
   37f90:	f004 fbcc 	bl	3c72c <printk>
   37f94:	215d      	movs	r1, #93	; 0x5d
   37f96:	4813      	ldr	r0, [pc, #76]	; (37fe4 <k_delayed_work_submit_to_queue+0xfc>)
   37f98:	f004 fc0e 	bl	3c7b8 <assert_post_action>
   37f9c:	f387 8811 	msr	BASEPRI, r7
   37fa0:	f3bf 8f6f 	isb	sy
		k_work_submit_to_queue(work_q, &work->work);
   37fa4:	4629      	mov	r1, r5
   37fa6:	4630      	mov	r0, r6
   37fa8:	f006 fb2c 	bl	3e604 <k_work_submit_to_queue>
		return 0;
   37fac:	2400      	movs	r4, #0
}
   37fae:	4620      	mov	r0, r4
   37fb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   37fb4:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   37fb8:	f240 30e7 	movw	r0, #999	; 0x3e7
   37fbc:	2100      	movs	r1, #0
   37fbe:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   37fc2:	2300      	movs	r3, #0
   37fc4:	fbe6 0108 	umlal	r0, r1, r6, r8
   37fc8:	f7e4 ff00 	bl	1cdcc <__aeabi_uldivmod>
	z_add_timeout(&work->timeout, work_timeout,
   37fcc:	490b      	ldr	r1, [pc, #44]	; (37ffc <k_delayed_work_submit_to_queue+0x114>)
   37fce:	1c42      	adds	r2, r0, #1
   37fd0:	f105 000c 	add.w	r0, r5, #12
   37fd4:	f000 f84e 	bl	38074 <z_add_timeout>
   37fd8:	e7b1      	b.n	37f3e <k_delayed_work_submit_to_queue+0x56>
		err = -EADDRINUSE;
   37fda:	f06f 046f 	mvn.w	r4, #111	; 0x6f
   37fde:	e7ae      	b.n	37f3e <k_delayed_work_submit_to_queue+0x56>
   37fe0:	2002987c 	.word	0x2002987c
   37fe4:	000405cb 	.word	0x000405cb
   37fe8:	000405f1 	.word	0x000405f1
   37fec:	00040606 	.word	0x00040606
   37ff0:	00040623 	.word	0x00040623
   37ff4:	00040665 	.word	0x00040665
   37ff8:	0004067c 	.word	0x0004067c
   37ffc:	0003e62d 	.word	0x0003e62d

00038000 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
   38000:	4b03      	ldr	r3, [pc, #12]	; (38010 <elapsed+0x10>)
   38002:	681b      	ldr	r3, [r3, #0]
   38004:	b90b      	cbnz	r3, 3800a <elapsed+0xa>
   38006:	f7ef be99 	b.w	27d3c <z_clock_elapsed>
}
   3800a:	2000      	movs	r0, #0
   3800c:	4770      	bx	lr
   3800e:	bf00      	nop
   38010:	20029880 	.word	0x20029880

00038014 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   38014:	6803      	ldr	r3, [r0, #0]
   38016:	b140      	cbz	r0, 3802a <remove_timeout+0x16>
   38018:	4a07      	ldr	r2, [pc, #28]	; (38038 <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
   3801a:	6852      	ldr	r2, [r2, #4]
   3801c:	4290      	cmp	r0, r2
   3801e:	d004      	beq.n	3802a <remove_timeout+0x16>
	if (next(t) != NULL) {
   38020:	b11b      	cbz	r3, 3802a <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
   38022:	689a      	ldr	r2, [r3, #8]
   38024:	6881      	ldr	r1, [r0, #8]
   38026:	440a      	add	r2, r1
   38028:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
   3802a:	6842      	ldr	r2, [r0, #4]
   3802c:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   3802e:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   38030:	2300      	movs	r3, #0
	node->prev = NULL;
   38032:	e9c0 3300 	strd	r3, r3, [r0]
}
   38036:	4770      	bx	lr
   38038:	20034700 	.word	0x20034700

0003803c <next_timeout>:
	return list->head == list;
   3803c:	4b0b      	ldr	r3, [pc, #44]	; (3806c <next_timeout+0x30>)

static s32_t next_timeout(void)
{
   3803e:	b510      	push	{r4, lr}
   38040:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   38042:	429c      	cmp	r4, r3
   38044:	bf08      	it	eq
   38046:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
   38048:	f7ff ffda 	bl	38000 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   3804c:	b154      	cbz	r4, 38064 <next_timeout+0x28>
   3804e:	68a3      	ldr	r3, [r4, #8]
   38050:	1a18      	subs	r0, r3, r0
   38052:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   38056:	4b06      	ldr	r3, [pc, #24]	; (38070 <next_timeout+0x34>)
   38058:	691b      	ldr	r3, [r3, #16]
   3805a:	b113      	cbz	r3, 38062 <next_timeout+0x26>
   3805c:	4298      	cmp	r0, r3
   3805e:	bfa8      	it	ge
   38060:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   38062:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   38064:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   38068:	e7f5      	b.n	38056 <next_timeout+0x1a>
   3806a:	bf00      	nop
   3806c:	20034700 	.word	0x20034700
   38070:	2002976c 	.word	0x2002976c

00038074 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
   38074:	6803      	ldr	r3, [r0, #0]
{
   38076:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   3807a:	4604      	mov	r4, r0
   3807c:	460e      	mov	r6, r1
   3807e:	4615      	mov	r5, r2
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
   38080:	b163      	cbz	r3, 3809c <z_add_timeout+0x28>
   38082:	4943      	ldr	r1, [pc, #268]	; (38190 <z_add_timeout+0x11c>)
   38084:	2358      	movs	r3, #88	; 0x58
   38086:	4a43      	ldr	r2, [pc, #268]	; (38194 <z_add_timeout+0x120>)
   38088:	4843      	ldr	r0, [pc, #268]	; (38198 <z_add_timeout+0x124>)
   3808a:	f004 fb4f 	bl	3c72c <printk>
   3808e:	4843      	ldr	r0, [pc, #268]	; (3819c <z_add_timeout+0x128>)
   38090:	f004 fb4c 	bl	3c72c <printk>
   38094:	2158      	movs	r1, #88	; 0x58
   38096:	483f      	ldr	r0, [pc, #252]	; (38194 <z_add_timeout+0x120>)
   38098:	f004 fb8e 	bl	3c7b8 <assert_post_action>
	to->fn = fn;
	ticks = MAX(1, ticks);
   3809c:	2d01      	cmp	r5, #1
   3809e:	bfb8      	it	lt
   380a0:	2501      	movlt	r5, #1
	to->fn = fn;
   380a2:	60e6      	str	r6, [r4, #12]
	__asm__ volatile(
   380a4:	f04f 0320 	mov.w	r3, #32
   380a8:	f3ef 8811 	mrs	r8, BASEPRI
   380ac:	f383 8811 	msr	BASEPRI, r3
   380b0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   380b4:	483a      	ldr	r0, [pc, #232]	; (381a0 <z_add_timeout+0x12c>)
   380b6:	f7ff fd43 	bl	37b40 <z_spin_lock_valid>
   380ba:	b968      	cbnz	r0, 380d8 <z_add_timeout+0x64>
   380bc:	234a      	movs	r3, #74	; 0x4a
   380be:	4a39      	ldr	r2, [pc, #228]	; (381a4 <z_add_timeout+0x130>)
   380c0:	4939      	ldr	r1, [pc, #228]	; (381a8 <z_add_timeout+0x134>)
   380c2:	4835      	ldr	r0, [pc, #212]	; (38198 <z_add_timeout+0x124>)
   380c4:	f004 fb32 	bl	3c72c <printk>
   380c8:	4935      	ldr	r1, [pc, #212]	; (381a0 <z_add_timeout+0x12c>)
   380ca:	4838      	ldr	r0, [pc, #224]	; (381ac <z_add_timeout+0x138>)
   380cc:	f004 fb2e 	bl	3c72c <printk>
   380d0:	214a      	movs	r1, #74	; 0x4a
   380d2:	4834      	ldr	r0, [pc, #208]	; (381a4 <z_add_timeout+0x130>)
   380d4:	f004 fb70 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   380d8:	4831      	ldr	r0, [pc, #196]	; (381a0 <z_add_timeout+0x12c>)
   380da:	f7ff fd4f 	bl	37b7c <z_spin_lock_set_owner>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
   380de:	f7ff ff8f 	bl	38000 <elapsed>
   380e2:	4428      	add	r0, r5
	return list->head == list;
   380e4:	4d32      	ldr	r5, [pc, #200]	; (381b0 <z_add_timeout+0x13c>)
   380e6:	60a0      	str	r0, [r4, #8]
   380e8:	682e      	ldr	r6, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   380ea:	42ae      	cmp	r6, r5
   380ec:	d005      	beq.n	380fa <z_add_timeout+0x86>
		for (t = first(); t != NULL; t = next(t)) {
			__ASSERT(t->dticks >= 0, "");
   380ee:	4f29      	ldr	r7, [pc, #164]	; (38194 <z_add_timeout+0x120>)
   380f0:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 381bc <z_add_timeout+0x148>
   380f4:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 38198 <z_add_timeout+0x124>
		for (t = first(); t != NULL; t = next(t)) {
   380f8:	b936      	cbnz	r6, 38108 <z_add_timeout+0x94>
	node->prev = list->tail;
   380fa:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   380fc:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
   380fe:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   38100:	686b      	ldr	r3, [r5, #4]
   38102:	601c      	str	r4, [r3, #0]
	list->tail = node;
   38104:	606c      	str	r4, [r5, #4]
   38106:	e01a      	b.n	3813e <z_add_timeout+0xca>
			__ASSERT(t->dticks >= 0, "");
   38108:	68b3      	ldr	r3, [r6, #8]
   3810a:	2b00      	cmp	r3, #0
   3810c:	da0c      	bge.n	38128 <z_add_timeout+0xb4>
   3810e:	4649      	mov	r1, r9
   38110:	2361      	movs	r3, #97	; 0x61
   38112:	463a      	mov	r2, r7
   38114:	4650      	mov	r0, sl
   38116:	f004 fb09 	bl	3c72c <printk>
   3811a:	4820      	ldr	r0, [pc, #128]	; (3819c <z_add_timeout+0x128>)
   3811c:	f004 fb06 	bl	3c72c <printk>
   38120:	2161      	movs	r1, #97	; 0x61
   38122:	4638      	mov	r0, r7
   38124:	f004 fb48 	bl	3c7b8 <assert_post_action>

			if (t->dticks > to->dticks) {
   38128:	68b2      	ldr	r2, [r6, #8]
   3812a:	68a3      	ldr	r3, [r4, #8]
   3812c:	429a      	cmp	r2, r3
   3812e:	dd28      	ble.n	38182 <z_add_timeout+0x10e>
				t->dticks -= to->dticks;
   38130:	1ad3      	subs	r3, r2, r3
   38132:	60b3      	str	r3, [r6, #8]
	node->prev = successor->prev;
   38134:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   38136:	e9c4 6300 	strd	r6, r3, [r4]
	successor->prev->next = node;
   3813a:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   3813c:	6074      	str	r4, [r6, #4]
	return list->head == list;
   3813e:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   38140:	42ab      	cmp	r3, r5
   38142:	d006      	beq.n	38152 <z_add_timeout+0xde>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   38144:	429c      	cmp	r4, r3
   38146:	d104      	bne.n	38152 <z_add_timeout+0xde>
			z_clock_set_timeout(next_timeout(), false);
   38148:	f7ff ff78 	bl	3803c <next_timeout>
   3814c:	2100      	movs	r1, #0
   3814e:	f7ef fd67 	bl	27c20 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   38152:	4813      	ldr	r0, [pc, #76]	; (381a0 <z_add_timeout+0x12c>)
   38154:	f7ff fd02 	bl	37b5c <z_spin_unlock_valid>
   38158:	b968      	cbnz	r0, 38176 <z_add_timeout+0x102>
   3815a:	235d      	movs	r3, #93	; 0x5d
   3815c:	4a11      	ldr	r2, [pc, #68]	; (381a4 <z_add_timeout+0x130>)
   3815e:	4915      	ldr	r1, [pc, #84]	; (381b4 <z_add_timeout+0x140>)
   38160:	480d      	ldr	r0, [pc, #52]	; (38198 <z_add_timeout+0x124>)
   38162:	f004 fae3 	bl	3c72c <printk>
   38166:	490e      	ldr	r1, [pc, #56]	; (381a0 <z_add_timeout+0x12c>)
   38168:	4813      	ldr	r0, [pc, #76]	; (381b8 <z_add_timeout+0x144>)
   3816a:	f004 fadf 	bl	3c72c <printk>
   3816e:	215d      	movs	r1, #93	; 0x5d
   38170:	480c      	ldr	r0, [pc, #48]	; (381a4 <z_add_timeout+0x130>)
   38172:	f004 fb21 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   38176:	f388 8811 	msr	BASEPRI, r8
   3817a:	f3bf 8f6f 	isb	sy
		}
	}
}
   3817e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			to->dticks -= t->dticks;
   38182:	1a9b      	subs	r3, r3, r2
   38184:	60a3      	str	r3, [r4, #8]
	return (node == list->tail) ? NULL : node->next;
   38186:	686b      	ldr	r3, [r5, #4]
   38188:	429e      	cmp	r6, r3
   3818a:	d0b6      	beq.n	380fa <z_add_timeout+0x86>
   3818c:	6836      	ldr	r6, [r6, #0]
   3818e:	e7b3      	b.n	380f8 <z_add_timeout+0x84>
   38190:	00044042 	.word	0x00044042
   38194:	0004401e 	.word	0x0004401e
   38198:	00040606 	.word	0x00040606
   3819c:	00042742 	.word	0x00042742
   381a0:	20029884 	.word	0x20029884
   381a4:	000405cb 	.word	0x000405cb
   381a8:	000405f1 	.word	0x000405f1
   381ac:	00040623 	.word	0x00040623
   381b0:	20034700 	.word	0x20034700
   381b4:	00040665 	.word	0x00040665
   381b8:	0004067c 	.word	0x0004067c
   381bc:	00044062 	.word	0x00044062

000381c0 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
   381c0:	b538      	push	{r3, r4, r5, lr}
   381c2:	4604      	mov	r4, r0
	__asm__ volatile(
   381c4:	f04f 0320 	mov.w	r3, #32
   381c8:	f3ef 8511 	mrs	r5, BASEPRI
   381cc:	f383 8811 	msr	BASEPRI, r3
   381d0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   381d4:	481a      	ldr	r0, [pc, #104]	; (38240 <z_abort_timeout+0x80>)
   381d6:	f7ff fcb3 	bl	37b40 <z_spin_lock_valid>
   381da:	b968      	cbnz	r0, 381f8 <z_abort_timeout+0x38>
   381dc:	234a      	movs	r3, #74	; 0x4a
   381de:	4a19      	ldr	r2, [pc, #100]	; (38244 <z_abort_timeout+0x84>)
   381e0:	4919      	ldr	r1, [pc, #100]	; (38248 <z_abort_timeout+0x88>)
   381e2:	481a      	ldr	r0, [pc, #104]	; (3824c <z_abort_timeout+0x8c>)
   381e4:	f004 faa2 	bl	3c72c <printk>
   381e8:	4915      	ldr	r1, [pc, #84]	; (38240 <z_abort_timeout+0x80>)
   381ea:	4819      	ldr	r0, [pc, #100]	; (38250 <z_abort_timeout+0x90>)
   381ec:	f004 fa9e 	bl	3c72c <printk>
   381f0:	214a      	movs	r1, #74	; 0x4a
   381f2:	4814      	ldr	r0, [pc, #80]	; (38244 <z_abort_timeout+0x84>)
   381f4:	f004 fae0 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   381f8:	4811      	ldr	r0, [pc, #68]	; (38240 <z_abort_timeout+0x80>)
   381fa:	f7ff fcbf 	bl	37b7c <z_spin_lock_set_owner>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
   381fe:	6823      	ldr	r3, [r4, #0]
   38200:	b1db      	cbz	r3, 3823a <z_abort_timeout+0x7a>
			remove_timeout(to);
   38202:	4620      	mov	r0, r4
   38204:	f7ff ff06 	bl	38014 <remove_timeout>
			ret = 0;
   38208:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   3820a:	480d      	ldr	r0, [pc, #52]	; (38240 <z_abort_timeout+0x80>)
   3820c:	f7ff fca6 	bl	37b5c <z_spin_unlock_valid>
   38210:	b968      	cbnz	r0, 3822e <z_abort_timeout+0x6e>
   38212:	235d      	movs	r3, #93	; 0x5d
   38214:	4a0b      	ldr	r2, [pc, #44]	; (38244 <z_abort_timeout+0x84>)
   38216:	490f      	ldr	r1, [pc, #60]	; (38254 <z_abort_timeout+0x94>)
   38218:	480c      	ldr	r0, [pc, #48]	; (3824c <z_abort_timeout+0x8c>)
   3821a:	f004 fa87 	bl	3c72c <printk>
   3821e:	4908      	ldr	r1, [pc, #32]	; (38240 <z_abort_timeout+0x80>)
   38220:	480d      	ldr	r0, [pc, #52]	; (38258 <z_abort_timeout+0x98>)
   38222:	f004 fa83 	bl	3c72c <printk>
   38226:	215d      	movs	r1, #93	; 0x5d
   38228:	4806      	ldr	r0, [pc, #24]	; (38244 <z_abort_timeout+0x84>)
   3822a:	f004 fac5 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   3822e:	f385 8811 	msr	BASEPRI, r5
   38232:	f3bf 8f6f 	isb	sy
		}
	}

	return ret;
}
   38236:	4620      	mov	r0, r4
   38238:	bd38      	pop	{r3, r4, r5, pc}
	int ret = -EINVAL;
   3823a:	f06f 0415 	mvn.w	r4, #21
   3823e:	e7e4      	b.n	3820a <z_abort_timeout+0x4a>
   38240:	20029884 	.word	0x20029884
   38244:	000405cb 	.word	0x000405cb
   38248:	000405f1 	.word	0x000405f1
   3824c:	00040606 	.word	0x00040606
   38250:	00040623 	.word	0x00040623
   38254:	00040665 	.word	0x00040665
   38258:	0004067c 	.word	0x0004067c

0003825c <z_timeout_remaining>:

s32_t z_timeout_remaining(struct _timeout *timeout)
{
   3825c:	b570      	push	{r4, r5, r6, lr}
   3825e:	4605      	mov	r5, r0
	s32_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
   38260:	6800      	ldr	r0, [r0, #0]
   38262:	2800      	cmp	r0, #0
   38264:	d03c      	beq.n	382e0 <z_timeout_remaining+0x84>
	__asm__ volatile(
   38266:	f04f 0320 	mov.w	r3, #32
   3826a:	f3ef 8611 	mrs	r6, BASEPRI
   3826e:	f383 8811 	msr	BASEPRI, r3
   38272:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   38276:	4821      	ldr	r0, [pc, #132]	; (382fc <z_timeout_remaining+0xa0>)
   38278:	f7ff fc62 	bl	37b40 <z_spin_lock_valid>
   3827c:	b968      	cbnz	r0, 3829a <z_timeout_remaining+0x3e>
   3827e:	234a      	movs	r3, #74	; 0x4a
   38280:	4a1f      	ldr	r2, [pc, #124]	; (38300 <z_timeout_remaining+0xa4>)
   38282:	4920      	ldr	r1, [pc, #128]	; (38304 <z_timeout_remaining+0xa8>)
   38284:	4820      	ldr	r0, [pc, #128]	; (38308 <z_timeout_remaining+0xac>)
   38286:	f004 fa51 	bl	3c72c <printk>
   3828a:	491c      	ldr	r1, [pc, #112]	; (382fc <z_timeout_remaining+0xa0>)
   3828c:	481f      	ldr	r0, [pc, #124]	; (3830c <z_timeout_remaining+0xb0>)
   3828e:	f004 fa4d 	bl	3c72c <printk>
   38292:	214a      	movs	r1, #74	; 0x4a
   38294:	481a      	ldr	r0, [pc, #104]	; (38300 <z_timeout_remaining+0xa4>)
   38296:	f004 fa8f 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   3829a:	4818      	ldr	r0, [pc, #96]	; (382fc <z_timeout_remaining+0xa0>)
   3829c:	f7ff fc6e 	bl	37b7c <z_spin_lock_set_owner>
	return list->head == list;
   382a0:	4a1b      	ldr	r2, [pc, #108]	; (38310 <z_timeout_remaining+0xb4>)
   382a2:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   382a4:	4293      	cmp	r3, r2
   382a6:	d026      	beq.n	382f6 <z_timeout_remaining+0x9a>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   382a8:	2400      	movs	r4, #0
   382aa:	6852      	ldr	r2, [r2, #4]
		return 0;
	}

	LOCKED(&timeout_lock) {
		for (struct _timeout *t = first(); t != NULL; t = next(t)) {
   382ac:	b9cb      	cbnz	r3, 382e2 <z_timeout_remaining+0x86>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   382ae:	4813      	ldr	r0, [pc, #76]	; (382fc <z_timeout_remaining+0xa0>)
   382b0:	f7ff fc54 	bl	37b5c <z_spin_unlock_valid>
   382b4:	b968      	cbnz	r0, 382d2 <z_timeout_remaining+0x76>
   382b6:	235d      	movs	r3, #93	; 0x5d
   382b8:	4a11      	ldr	r2, [pc, #68]	; (38300 <z_timeout_remaining+0xa4>)
   382ba:	4916      	ldr	r1, [pc, #88]	; (38314 <z_timeout_remaining+0xb8>)
   382bc:	4812      	ldr	r0, [pc, #72]	; (38308 <z_timeout_remaining+0xac>)
   382be:	f004 fa35 	bl	3c72c <printk>
   382c2:	490e      	ldr	r1, [pc, #56]	; (382fc <z_timeout_remaining+0xa0>)
   382c4:	4814      	ldr	r0, [pc, #80]	; (38318 <z_timeout_remaining+0xbc>)
   382c6:	f004 fa31 	bl	3c72c <printk>
   382ca:	215d      	movs	r1, #93	; 0x5d
   382cc:	480c      	ldr	r0, [pc, #48]	; (38300 <z_timeout_remaining+0xa4>)
   382ce:	f004 fa73 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   382d2:	f386 8811 	msr	BASEPRI, r6
   382d6:	f3bf 8f6f 	isb	sy
				break;
			}
		}
	}

	return ticks - elapsed();
   382da:	f7ff fe91 	bl	38000 <elapsed>
   382de:	1a20      	subs	r0, r4, r0
}
   382e0:	bd70      	pop	{r4, r5, r6, pc}
			ticks += t->dticks;
   382e2:	6899      	ldr	r1, [r3, #8]
			if (timeout == t) {
   382e4:	42ab      	cmp	r3, r5
			ticks += t->dticks;
   382e6:	440c      	add	r4, r1
			if (timeout == t) {
   382e8:	d0e1      	beq.n	382ae <z_timeout_remaining+0x52>
   382ea:	2b00      	cmp	r3, #0
   382ec:	d0df      	beq.n	382ae <z_timeout_remaining+0x52>
	return (node == list->tail) ? NULL : node->next;
   382ee:	4293      	cmp	r3, r2
   382f0:	d0dd      	beq.n	382ae <z_timeout_remaining+0x52>
   382f2:	681b      	ldr	r3, [r3, #0]
   382f4:	e7da      	b.n	382ac <z_timeout_remaining+0x50>
	return sys_dlist_is_empty(list) ? NULL : list->head;
   382f6:	2400      	movs	r4, #0
   382f8:	e7d9      	b.n	382ae <z_timeout_remaining+0x52>
   382fa:	bf00      	nop
   382fc:	20029884 	.word	0x20029884
   38300:	000405cb 	.word	0x000405cb
   38304:	000405f1 	.word	0x000405f1
   38308:	00040606 	.word	0x00040606
   3830c:	00040623 	.word	0x00040623
   38310:	20034700 	.word	0x20034700
   38314:	00040665 	.word	0x00040665
   38318:	0004067c 	.word	0x0004067c

0003831c <z_get_next_timeout_expiry>:

s32_t z_get_next_timeout_expiry(void)
{
   3831c:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   3831e:	f04f 0320 	mov.w	r3, #32
   38322:	f3ef 8511 	mrs	r5, BASEPRI
   38326:	f383 8811 	msr	BASEPRI, r3
   3832a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   3832e:	4818      	ldr	r0, [pc, #96]	; (38390 <z_get_next_timeout_expiry+0x74>)
   38330:	f7ff fc06 	bl	37b40 <z_spin_lock_valid>
   38334:	b968      	cbnz	r0, 38352 <z_get_next_timeout_expiry+0x36>
   38336:	234a      	movs	r3, #74	; 0x4a
   38338:	4a16      	ldr	r2, [pc, #88]	; (38394 <z_get_next_timeout_expiry+0x78>)
   3833a:	4917      	ldr	r1, [pc, #92]	; (38398 <z_get_next_timeout_expiry+0x7c>)
   3833c:	4817      	ldr	r0, [pc, #92]	; (3839c <z_get_next_timeout_expiry+0x80>)
   3833e:	f004 f9f5 	bl	3c72c <printk>
   38342:	4913      	ldr	r1, [pc, #76]	; (38390 <z_get_next_timeout_expiry+0x74>)
   38344:	4816      	ldr	r0, [pc, #88]	; (383a0 <z_get_next_timeout_expiry+0x84>)
   38346:	f004 f9f1 	bl	3c72c <printk>
   3834a:	214a      	movs	r1, #74	; 0x4a
   3834c:	4811      	ldr	r0, [pc, #68]	; (38394 <z_get_next_timeout_expiry+0x78>)
   3834e:	f004 fa33 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   38352:	480f      	ldr	r0, [pc, #60]	; (38390 <z_get_next_timeout_expiry+0x74>)
   38354:	f7ff fc12 	bl	37b7c <z_spin_lock_set_owner>
	s32_t ret = K_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
   38358:	f7ff fe70 	bl	3803c <next_timeout>
   3835c:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   3835e:	480c      	ldr	r0, [pc, #48]	; (38390 <z_get_next_timeout_expiry+0x74>)
   38360:	f7ff fbfc 	bl	37b5c <z_spin_unlock_valid>
   38364:	b968      	cbnz	r0, 38382 <z_get_next_timeout_expiry+0x66>
   38366:	235d      	movs	r3, #93	; 0x5d
   38368:	4a0a      	ldr	r2, [pc, #40]	; (38394 <z_get_next_timeout_expiry+0x78>)
   3836a:	490e      	ldr	r1, [pc, #56]	; (383a4 <z_get_next_timeout_expiry+0x88>)
   3836c:	480b      	ldr	r0, [pc, #44]	; (3839c <z_get_next_timeout_expiry+0x80>)
   3836e:	f004 f9dd 	bl	3c72c <printk>
   38372:	4907      	ldr	r1, [pc, #28]	; (38390 <z_get_next_timeout_expiry+0x74>)
   38374:	480c      	ldr	r0, [pc, #48]	; (383a8 <z_get_next_timeout_expiry+0x8c>)
   38376:	f004 f9d9 	bl	3c72c <printk>
   3837a:	215d      	movs	r1, #93	; 0x5d
   3837c:	4805      	ldr	r0, [pc, #20]	; (38394 <z_get_next_timeout_expiry+0x78>)
   3837e:	f004 fa1b 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   38382:	f385 8811 	msr	BASEPRI, r5
   38386:	f3bf 8f6f 	isb	sy
	}
	return ret;
}
   3838a:	4620      	mov	r0, r4
   3838c:	bd38      	pop	{r3, r4, r5, pc}
   3838e:	bf00      	nop
   38390:	20029884 	.word	0x20029884
   38394:	000405cb 	.word	0x000405cb
   38398:	000405f1 	.word	0x000405f1
   3839c:	00040606 	.word	0x00040606
   383a0:	00040623 	.word	0x00040623
   383a4:	00040665 	.word	0x00040665
   383a8:	0004067c 	.word	0x0004067c

000383ac <z_set_timeout_expiry>:

void z_set_timeout_expiry(s32_t ticks, bool idle)
{
   383ac:	b570      	push	{r4, r5, r6, lr}
   383ae:	4604      	mov	r4, r0
   383b0:	460e      	mov	r6, r1
	__asm__ volatile(
   383b2:	f04f 0320 	mov.w	r3, #32
   383b6:	f3ef 8511 	mrs	r5, BASEPRI
   383ba:	f383 8811 	msr	BASEPRI, r3
   383be:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   383c2:	481b      	ldr	r0, [pc, #108]	; (38430 <z_set_timeout_expiry+0x84>)
   383c4:	f7ff fbbc 	bl	37b40 <z_spin_lock_valid>
   383c8:	b968      	cbnz	r0, 383e6 <z_set_timeout_expiry+0x3a>
   383ca:	234a      	movs	r3, #74	; 0x4a
   383cc:	4a19      	ldr	r2, [pc, #100]	; (38434 <z_set_timeout_expiry+0x88>)
   383ce:	491a      	ldr	r1, [pc, #104]	; (38438 <z_set_timeout_expiry+0x8c>)
   383d0:	481a      	ldr	r0, [pc, #104]	; (3843c <z_set_timeout_expiry+0x90>)
   383d2:	f004 f9ab 	bl	3c72c <printk>
   383d6:	4916      	ldr	r1, [pc, #88]	; (38430 <z_set_timeout_expiry+0x84>)
   383d8:	4819      	ldr	r0, [pc, #100]	; (38440 <z_set_timeout_expiry+0x94>)
   383da:	f004 f9a7 	bl	3c72c <printk>
   383de:	214a      	movs	r1, #74	; 0x4a
   383e0:	4814      	ldr	r0, [pc, #80]	; (38434 <z_set_timeout_expiry+0x88>)
   383e2:	f004 f9e9 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   383e6:	4812      	ldr	r0, [pc, #72]	; (38430 <z_set_timeout_expiry+0x84>)
   383e8:	f7ff fbc8 	bl	37b7c <z_spin_lock_set_owner>
	LOCKED(&timeout_lock) {
		int next = next_timeout();
   383ec:	f7ff fe26 	bl	3803c <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   383f0:	2801      	cmp	r0, #1
   383f2:	dd05      	ble.n	38400 <z_set_timeout_expiry+0x54>
   383f4:	42a0      	cmp	r0, r4
   383f6:	dd03      	ble.n	38400 <z_set_timeout_expiry+0x54>
			z_clock_set_timeout(ticks, idle);
   383f8:	4631      	mov	r1, r6
   383fa:	4620      	mov	r0, r4
   383fc:	f7ef fc10 	bl	27c20 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   38400:	480b      	ldr	r0, [pc, #44]	; (38430 <z_set_timeout_expiry+0x84>)
   38402:	f7ff fbab 	bl	37b5c <z_spin_unlock_valid>
   38406:	b968      	cbnz	r0, 38424 <z_set_timeout_expiry+0x78>
   38408:	235d      	movs	r3, #93	; 0x5d
   3840a:	4a0a      	ldr	r2, [pc, #40]	; (38434 <z_set_timeout_expiry+0x88>)
   3840c:	490d      	ldr	r1, [pc, #52]	; (38444 <z_set_timeout_expiry+0x98>)
   3840e:	480b      	ldr	r0, [pc, #44]	; (3843c <z_set_timeout_expiry+0x90>)
   38410:	f004 f98c 	bl	3c72c <printk>
   38414:	4906      	ldr	r1, [pc, #24]	; (38430 <z_set_timeout_expiry+0x84>)
   38416:	480c      	ldr	r0, [pc, #48]	; (38448 <z_set_timeout_expiry+0x9c>)
   38418:	f004 f988 	bl	3c72c <printk>
   3841c:	215d      	movs	r1, #93	; 0x5d
   3841e:	4805      	ldr	r0, [pc, #20]	; (38434 <z_set_timeout_expiry+0x88>)
   38420:	f004 f9ca 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   38424:	f385 8811 	msr	BASEPRI, r5
   38428:	f3bf 8f6f 	isb	sy
		}
	}
}
   3842c:	bd70      	pop	{r4, r5, r6, pc}
   3842e:	bf00      	nop
   38430:	20029884 	.word	0x20029884
   38434:	000405cb 	.word	0x000405cb
   38438:	000405f1 	.word	0x000405f1
   3843c:	00040606 	.word	0x00040606
   38440:	00040623 	.word	0x00040623
   38444:	00040665 	.word	0x00040665
   38448:	0004067c 	.word	0x0004067c

0003844c <z_clock_announce>:

void z_clock_announce(s32_t ticks)
{
   3844c:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
   38450:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   38452:	f7fe fd59 	bl	36f08 <z_time_slice>
	__asm__ volatile(
   38456:	f04f 0320 	mov.w	r3, #32
   3845a:	f3ef 8511 	mrs	r5, BASEPRI
   3845e:	f383 8811 	msr	BASEPRI, r3
   38462:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   38466:	4848      	ldr	r0, [pc, #288]	; (38588 <z_clock_announce+0x13c>)
   38468:	f7ff fb6a 	bl	37b40 <z_spin_lock_valid>
   3846c:	b968      	cbnz	r0, 3848a <z_clock_announce+0x3e>
   3846e:	234a      	movs	r3, #74	; 0x4a
   38470:	4a46      	ldr	r2, [pc, #280]	; (3858c <z_clock_announce+0x140>)
   38472:	4947      	ldr	r1, [pc, #284]	; (38590 <z_clock_announce+0x144>)
   38474:	4847      	ldr	r0, [pc, #284]	; (38594 <z_clock_announce+0x148>)
   38476:	f004 f959 	bl	3c72c <printk>
   3847a:	4943      	ldr	r1, [pc, #268]	; (38588 <z_clock_announce+0x13c>)
   3847c:	4846      	ldr	r0, [pc, #280]	; (38598 <z_clock_announce+0x14c>)
   3847e:	f004 f955 	bl	3c72c <printk>
   38482:	214a      	movs	r1, #74	; 0x4a
   38484:	4841      	ldr	r0, [pc, #260]	; (3858c <z_clock_announce+0x140>)
   38486:	f004 f997 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   3848a:	4f44      	ldr	r7, [pc, #272]	; (3859c <z_clock_announce+0x150>)
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   3848c:	4e44      	ldr	r6, [pc, #272]	; (385a0 <z_clock_announce+0x154>)
   3848e:	46b9      	mov	r9, r7
   38490:	483d      	ldr	r0, [pc, #244]	; (38588 <z_clock_announce+0x13c>)
	return list->head == list;
   38492:	f8df 8118 	ldr.w	r8, [pc, #280]	; 385ac <z_clock_announce+0x160>
   38496:	f7ff fb71 	bl	37b7c <z_spin_lock_set_owner>
   3849a:	6034      	str	r4, [r6, #0]
   3849c:	f8d8 4000 	ldr.w	r4, [r8]
   384a0:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   384a2:	4544      	cmp	r4, r8
   384a4:	e9d7 bc00 	ldrd	fp, ip, [r7]
   384a8:	d005      	beq.n	384b6 <z_clock_announce+0x6a>

	while (first() != NULL && first()->dticks <= announce_remaining) {
   384aa:	b124      	cbz	r4, 384b6 <z_clock_announce+0x6a>
   384ac:	68a3      	ldr	r3, [r4, #8]
   384ae:	4293      	cmp	r3, r2
   384b0:	dd26      	ble.n	38500 <z_clock_announce+0xb4>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   384b2:	1a9b      	subs	r3, r3, r2
   384b4:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
   384b6:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
   384b8:	eb1b 0002 	adds.w	r0, fp, r2
   384bc:	eb4c 71e2 	adc.w	r1, ip, r2, asr #31
   384c0:	e9c9 0100 	strd	r0, r1, [r9]
	announce_remaining = 0;
   384c4:	6034      	str	r4, [r6, #0]

	z_clock_set_timeout(next_timeout(), false);
   384c6:	f7ff fdb9 	bl	3803c <next_timeout>
   384ca:	4621      	mov	r1, r4
   384cc:	f7ef fba8 	bl	27c20 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   384d0:	482d      	ldr	r0, [pc, #180]	; (38588 <z_clock_announce+0x13c>)
   384d2:	f7ff fb43 	bl	37b5c <z_spin_unlock_valid>
   384d6:	b968      	cbnz	r0, 384f4 <z_clock_announce+0xa8>
   384d8:	235d      	movs	r3, #93	; 0x5d
   384da:	4a2c      	ldr	r2, [pc, #176]	; (3858c <z_clock_announce+0x140>)
   384dc:	4931      	ldr	r1, [pc, #196]	; (385a4 <z_clock_announce+0x158>)
   384de:	482d      	ldr	r0, [pc, #180]	; (38594 <z_clock_announce+0x148>)
   384e0:	f004 f924 	bl	3c72c <printk>
   384e4:	4928      	ldr	r1, [pc, #160]	; (38588 <z_clock_announce+0x13c>)
   384e6:	4830      	ldr	r0, [pc, #192]	; (385a8 <z_clock_announce+0x15c>)
   384e8:	f004 f920 	bl	3c72c <printk>
   384ec:	215d      	movs	r1, #93	; 0x5d
   384ee:	4827      	ldr	r0, [pc, #156]	; (3858c <z_clock_announce+0x140>)
   384f0:	f004 f962 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   384f4:	f385 8811 	msr	BASEPRI, r5
   384f8:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   384fc:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		curr_tick += dt;
   38500:	eb1b 0003 	adds.w	r0, fp, r3
   38504:	eb4c 71e3 	adc.w	r1, ip, r3, asr #31
		announce_remaining -= dt;
   38508:	1ad3      	subs	r3, r2, r3
   3850a:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
   3850c:	2300      	movs	r3, #0
		curr_tick += dt;
   3850e:	e9c7 0100 	strd	r0, r1, [r7]
		t->dticks = 0;
   38512:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
   38514:	4620      	mov	r0, r4
   38516:	f7ff fd7d 	bl	38014 <remove_timeout>
   3851a:	481b      	ldr	r0, [pc, #108]	; (38588 <z_clock_announce+0x13c>)
   3851c:	f7ff fb1e 	bl	37b5c <z_spin_unlock_valid>
   38520:	b968      	cbnz	r0, 3853e <z_clock_announce+0xf2>
   38522:	235d      	movs	r3, #93	; 0x5d
   38524:	4a19      	ldr	r2, [pc, #100]	; (3858c <z_clock_announce+0x140>)
   38526:	491f      	ldr	r1, [pc, #124]	; (385a4 <z_clock_announce+0x158>)
   38528:	481a      	ldr	r0, [pc, #104]	; (38594 <z_clock_announce+0x148>)
   3852a:	f004 f8ff 	bl	3c72c <printk>
   3852e:	4916      	ldr	r1, [pc, #88]	; (38588 <z_clock_announce+0x13c>)
   38530:	481d      	ldr	r0, [pc, #116]	; (385a8 <z_clock_announce+0x15c>)
   38532:	f004 f8fb 	bl	3c72c <printk>
   38536:	215d      	movs	r1, #93	; 0x5d
   38538:	4814      	ldr	r0, [pc, #80]	; (3858c <z_clock_announce+0x140>)
   3853a:	f004 f93d 	bl	3c7b8 <assert_post_action>
   3853e:	f385 8811 	msr	BASEPRI, r5
   38542:	f3bf 8f6f 	isb	sy
		t->fn(t);
   38546:	68e3      	ldr	r3, [r4, #12]
   38548:	4620      	mov	r0, r4
   3854a:	4798      	blx	r3
	__asm__ volatile(
   3854c:	f04f 0320 	mov.w	r3, #32
   38550:	f3ef 8511 	mrs	r5, BASEPRI
   38554:	f383 8811 	msr	BASEPRI, r3
   38558:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   3855c:	480a      	ldr	r0, [pc, #40]	; (38588 <z_clock_announce+0x13c>)
   3855e:	f7ff faef 	bl	37b40 <z_spin_lock_valid>
   38562:	b968      	cbnz	r0, 38580 <z_clock_announce+0x134>
   38564:	234a      	movs	r3, #74	; 0x4a
   38566:	4a09      	ldr	r2, [pc, #36]	; (3858c <z_clock_announce+0x140>)
   38568:	4909      	ldr	r1, [pc, #36]	; (38590 <z_clock_announce+0x144>)
   3856a:	480a      	ldr	r0, [pc, #40]	; (38594 <z_clock_announce+0x148>)
   3856c:	f004 f8de 	bl	3c72c <printk>
   38570:	4905      	ldr	r1, [pc, #20]	; (38588 <z_clock_announce+0x13c>)
   38572:	4809      	ldr	r0, [pc, #36]	; (38598 <z_clock_announce+0x14c>)
   38574:	f004 f8da 	bl	3c72c <printk>
   38578:	214a      	movs	r1, #74	; 0x4a
   3857a:	4804      	ldr	r0, [pc, #16]	; (3858c <z_clock_announce+0x140>)
   3857c:	f004 f91c 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   38580:	4801      	ldr	r0, [pc, #4]	; (38588 <z_clock_announce+0x13c>)
   38582:	f7ff fafb 	bl	37b7c <z_spin_lock_set_owner>
	return k;
   38586:	e789      	b.n	3849c <z_clock_announce+0x50>
   38588:	20029884 	.word	0x20029884
   3858c:	000405cb 	.word	0x000405cb
   38590:	000405f1 	.word	0x000405f1
   38594:	00040606 	.word	0x00040606
   38598:	00040623 	.word	0x00040623
   3859c:	20020958 	.word	0x20020958
   385a0:	20029880 	.word	0x20029880
   385a4:	00040665 	.word	0x00040665
   385a8:	0004067c 	.word	0x0004067c
   385ac:	20034700 	.word	0x20034700

000385b0 <z_tick_get>:

s64_t z_tick_get(void)
{
   385b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   385b4:	f04f 0320 	mov.w	r3, #32
   385b8:	f3ef 8611 	mrs	r6, BASEPRI
   385bc:	f383 8811 	msr	BASEPRI, r3
   385c0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   385c4:	481b      	ldr	r0, [pc, #108]	; (38634 <z_tick_get+0x84>)
   385c6:	f7ff fabb 	bl	37b40 <z_spin_lock_valid>
   385ca:	b968      	cbnz	r0, 385e8 <z_tick_get+0x38>
   385cc:	234a      	movs	r3, #74	; 0x4a
   385ce:	4a1a      	ldr	r2, [pc, #104]	; (38638 <z_tick_get+0x88>)
   385d0:	491a      	ldr	r1, [pc, #104]	; (3863c <z_tick_get+0x8c>)
   385d2:	481b      	ldr	r0, [pc, #108]	; (38640 <z_tick_get+0x90>)
   385d4:	f004 f8aa 	bl	3c72c <printk>
   385d8:	4916      	ldr	r1, [pc, #88]	; (38634 <z_tick_get+0x84>)
   385da:	481a      	ldr	r0, [pc, #104]	; (38644 <z_tick_get+0x94>)
   385dc:	f004 f8a6 	bl	3c72c <printk>
   385e0:	214a      	movs	r1, #74	; 0x4a
   385e2:	4815      	ldr	r0, [pc, #84]	; (38638 <z_tick_get+0x88>)
   385e4:	f004 f8e8 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   385e8:	4812      	ldr	r0, [pc, #72]	; (38634 <z_tick_get+0x84>)
   385ea:	f7ff fac7 	bl	37b7c <z_spin_lock_set_owner>
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
   385ee:	f7ef fba5 	bl	27d3c <z_clock_elapsed>
   385f2:	4b15      	ldr	r3, [pc, #84]	; (38648 <z_tick_get+0x98>)
   385f4:	e9d3 4500 	ldrd	r4, r5, [r3]
   385f8:	1827      	adds	r7, r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   385fa:	480e      	ldr	r0, [pc, #56]	; (38634 <z_tick_get+0x84>)
   385fc:	f145 0800 	adc.w	r8, r5, #0
   38600:	f7ff faac 	bl	37b5c <z_spin_unlock_valid>
   38604:	b968      	cbnz	r0, 38622 <z_tick_get+0x72>
   38606:	235d      	movs	r3, #93	; 0x5d
   38608:	4a0b      	ldr	r2, [pc, #44]	; (38638 <z_tick_get+0x88>)
   3860a:	4910      	ldr	r1, [pc, #64]	; (3864c <z_tick_get+0x9c>)
   3860c:	480c      	ldr	r0, [pc, #48]	; (38640 <z_tick_get+0x90>)
   3860e:	f004 f88d 	bl	3c72c <printk>
   38612:	4908      	ldr	r1, [pc, #32]	; (38634 <z_tick_get+0x84>)
   38614:	480e      	ldr	r0, [pc, #56]	; (38650 <z_tick_get+0xa0>)
   38616:	f004 f889 	bl	3c72c <printk>
   3861a:	215d      	movs	r1, #93	; 0x5d
   3861c:	4806      	ldr	r0, [pc, #24]	; (38638 <z_tick_get+0x88>)
   3861e:	f004 f8cb 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   38622:	f386 8811 	msr	BASEPRI, r6
   38626:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   3862a:	4638      	mov	r0, r7
   3862c:	4641      	mov	r1, r8
   3862e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   38632:	bf00      	nop
   38634:	20029884 	.word	0x20029884
   38638:	000405cb 	.word	0x000405cb
   3863c:	000405f1 	.word	0x000405f1
   38640:	00040606 	.word	0x00040606
   38644:	00040623 	.word	0x00040623
   38648:	20020958 	.word	0x20020958
   3864c:	00040665 	.word	0x00040665
   38650:	0004067c 	.word	0x0004067c

00038654 <z_timer_expiration_handler>:

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
   38654:	6a02      	ldr	r2, [r0, #32]
{
   38656:	b538      	push	{r3, r4, r5, lr}
	if (timer->period > 0) {
   38658:	2a00      	cmp	r2, #0
{
   3865a:	4604      	mov	r4, r0
	if (timer->period > 0) {
   3865c:	dd02      	ble.n	38664 <z_timer_expiration_handler+0x10>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   3865e:	490e      	ldr	r1, [pc, #56]	; (38698 <z_timer_expiration_handler+0x44>)
   38660:	f7ff fd08 	bl	38074 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   38664:	6a63      	ldr	r3, [r4, #36]	; 0x24
   38666:	3301      	adds	r3, #1
   38668:	6263      	str	r3, [r4, #36]	; 0x24

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   3866a:	69a3      	ldr	r3, [r4, #24]
   3866c:	b10b      	cbz	r3, 38672 <z_timer_expiration_handler+0x1e>
		timer->expiry_fn(timer);
   3866e:	4620      	mov	r0, r4
   38670:	4798      	blx	r3
	return list->head == list;
   38672:	f854 5f10 	ldr.w	r5, [r4, #16]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   38676:	42a5      	cmp	r5, r4
   38678:	d00d      	beq.n	38696 <z_timer_expiration_handler+0x42>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   3867a:	b165      	cbz	r5, 38696 <z_timer_expiration_handler+0x42>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
   3867c:	4628      	mov	r0, r5
   3867e:	f7fe f88f 	bl	367a0 <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   38682:	7b6b      	ldrb	r3, [r5, #13]
   38684:	06db      	lsls	r3, r3, #27
   38686:	d104      	bne.n	38692 <z_timer_expiration_handler+0x3e>
	if (z_is_thread_ready(thread)) {
   38688:	69ab      	ldr	r3, [r5, #24]
   3868a:	b913      	cbnz	r3, 38692 <z_timer_expiration_handler+0x3e>
		z_add_thread_to_ready_q(thread);
   3868c:	4628      	mov	r0, r5
   3868e:	f7fe fac3 	bl	36c18 <z_add_thread_to_ready_q>
   38692:	2300      	movs	r3, #0
   38694:	66ab      	str	r3, [r5, #104]	; 0x68

	z_ready_thread(thread);

	arch_thread_return_value_set(thread, 0);
}
   38696:	bd38      	pop	{r3, r4, r5, pc}
   38698:	00038655 	.word	0x00038655

0003869c <z_impl_k_timer_start>:
	z_object_init(timer);
}


void z_impl_k_timer_start(struct k_timer *timer, s32_t duration, s32_t period)
{
   3869c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	__ASSERT(duration >= 0 && period >= 0 &&
   386a0:	f1b1 0900 	subs.w	r9, r1, #0
{
   386a4:	4604      	mov	r4, r0
   386a6:	4615      	mov	r5, r2
	__ASSERT(duration >= 0 && period >= 0 &&
   386a8:	db04      	blt.n	386b4 <z_impl_k_timer_start+0x18>
   386aa:	2a00      	cmp	r2, #0
   386ac:	db02      	blt.n	386b4 <z_impl_k_timer_start+0x18>
   386ae:	ea59 0302 	orrs.w	r3, r9, r2
   386b2:	d10c      	bne.n	386ce <z_impl_k_timer_start+0x32>
   386b4:	491a      	ldr	r1, [pc, #104]	; (38720 <z_impl_k_timer_start+0x84>)
   386b6:	236f      	movs	r3, #111	; 0x6f
   386b8:	4a1a      	ldr	r2, [pc, #104]	; (38724 <z_impl_k_timer_start+0x88>)
   386ba:	481b      	ldr	r0, [pc, #108]	; (38728 <z_impl_k_timer_start+0x8c>)
   386bc:	f004 f836 	bl	3c72c <printk>
   386c0:	481a      	ldr	r0, [pc, #104]	; (3872c <z_impl_k_timer_start+0x90>)
   386c2:	f004 f833 	bl	3c72c <printk>
   386c6:	216f      	movs	r1, #111	; 0x6f
   386c8:	4816      	ldr	r0, [pc, #88]	; (38724 <z_impl_k_timer_start+0x88>)
   386ca:	f004 f875 	bl	3c7b8 <assert_post_action>
   386ce:	f240 36e7 	movw	r6, #999	; 0x3e7
   386d2:	2700      	movs	r7, #0
   386d4:	f44f 4800 	mov.w	r8, #32768	; 0x8000
   386d8:	4630      	mov	r0, r6
   386da:	4639      	mov	r1, r7
   386dc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   386e0:	2300      	movs	r3, #0
   386e2:	fbe8 0105 	umlal	r0, r1, r8, r5
   386e6:	f7e4 fb71 	bl	1cdcc <__aeabi_uldivmod>
   386ea:	4639      	mov	r1, r7
		 (duration != 0 || period != 0), "invalid parameters\n");

	volatile s32_t period_in_ticks, duration_in_ticks;

	period_in_ticks = k_ms_to_ticks_ceil32(period);
   386ec:	9000      	str	r0, [sp, #0]
   386ee:	4630      	mov	r0, r6
   386f0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   386f4:	2300      	movs	r3, #0
   386f6:	fbe8 0109 	umlal	r0, r1, r8, r9
   386fa:	f7e4 fb67 	bl	1cdcc <__aeabi_uldivmod>
	duration_in_ticks = k_ms_to_ticks_ceil32(duration);
   386fe:	9001      	str	r0, [sp, #4]

	(void)z_abort_timeout(&timer->timeout);
   38700:	4620      	mov	r0, r4
   38702:	f7ff fd5d 	bl	381c0 <z_abort_timeout>
	timer->period = period_in_ticks;
   38706:	9b00      	ldr	r3, [sp, #0]
	timer->status = 0U;
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   38708:	4620      	mov	r0, r4
	timer->period = period_in_ticks;
   3870a:	6223      	str	r3, [r4, #32]
	timer->status = 0U;
   3870c:	2300      	movs	r3, #0
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   3870e:	9a01      	ldr	r2, [sp, #4]
   38710:	4907      	ldr	r1, [pc, #28]	; (38730 <z_impl_k_timer_start+0x94>)
	timer->status = 0U;
   38712:	6263      	str	r3, [r4, #36]	; 0x24
		     duration_in_ticks);
}
   38714:	b003      	add	sp, #12
   38716:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   3871a:	f7ff bcab 	b.w	38074 <z_add_timeout>
   3871e:	bf00      	nop
   38720:	00044093 	.word	0x00044093
   38724:	00044071 	.word	0x00044071
   38728:	00040606 	.word	0x00040606
   3872c:	000440d2 	.word	0x000440d2
   38730:	00038655 	.word	0x00038655

00038734 <k_poll_poller_cb>:

	return events_registered;
}

static int k_poll_poller_cb(struct k_poll_event *event, u32_t state)
{
   38734:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = event->poller->thread;
   38736:	6883      	ldr	r3, [r0, #8]
{
   38738:	460d      	mov	r5, r1
	struct k_thread *thread = event->poller->thread;
   3873a:	685c      	ldr	r4, [r3, #4]

	__ASSERT(thread != NULL, "poller should have a thread\n");
   3873c:	b964      	cbnz	r4, 38758 <k_poll_poller_cb+0x24>
   3873e:	4915      	ldr	r1, [pc, #84]	; (38794 <k_poll_poller_cb+0x60>)
   38740:	23e0      	movs	r3, #224	; 0xe0
   38742:	4a15      	ldr	r2, [pc, #84]	; (38798 <k_poll_poller_cb+0x64>)
   38744:	4815      	ldr	r0, [pc, #84]	; (3879c <k_poll_poller_cb+0x68>)
   38746:	f003 fff1 	bl	3c72c <printk>
   3874a:	4815      	ldr	r0, [pc, #84]	; (387a0 <k_poll_poller_cb+0x6c>)
   3874c:	f003 ffee 	bl	3c72c <printk>
   38750:	21e0      	movs	r1, #224	; 0xe0
   38752:	4811      	ldr	r0, [pc, #68]	; (38798 <k_poll_poller_cb+0x64>)
   38754:	f004 f830 	bl	3c7b8 <assert_post_action>

	if (!z_is_thread_pending(thread)) {
   38758:	7b63      	ldrb	r3, [r4, #13]
   3875a:	079a      	lsls	r2, r3, #30
   3875c:	d401      	bmi.n	38762 <k_poll_poller_cb+0x2e>
		return 0;
   3875e:	2000      	movs	r0, #0
	}

	z_ready_thread(thread);

	return 0;
}
   38760:	bd38      	pop	{r3, r4, r5, pc}
	if (z_is_thread_timeout_expired(thread)) {
   38762:	6a23      	ldr	r3, [r4, #32]
   38764:	3302      	adds	r3, #2
   38766:	d012      	beq.n	3878e <k_poll_poller_cb+0x5a>
	z_unpend_thread(thread);
   38768:	4620      	mov	r0, r4
   3876a:	f7fe f94d 	bl	36a08 <z_unpend_thread>
	arch_thread_return_value_set(thread,
   3876e:	2d08      	cmp	r5, #8
   38770:	bf0c      	ite	eq
   38772:	f06f 0303 	mvneq.w	r3, #3
   38776:	2300      	movne	r3, #0
   38778:	66a3      	str	r3, [r4, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   3877a:	7b63      	ldrb	r3, [r4, #13]
   3877c:	06db      	lsls	r3, r3, #27
   3877e:	d1ee      	bne.n	3875e <k_poll_poller_cb+0x2a>
	if (!z_is_thread_ready(thread)) {
   38780:	69a5      	ldr	r5, [r4, #24]
   38782:	2d00      	cmp	r5, #0
   38784:	d1eb      	bne.n	3875e <k_poll_poller_cb+0x2a>
		z_add_thread_to_ready_q(thread);
   38786:	4620      	mov	r0, r4
   38788:	f7fe fa46 	bl	36c18 <z_add_thread_to_ready_q>
	return 0;
   3878c:	e7e7      	b.n	3875e <k_poll_poller_cb+0x2a>
		return -EAGAIN;
   3878e:	f06f 000a 	mvn.w	r0, #10
   38792:	e7e5      	b.n	38760 <k_poll_poller_cb+0x2c>
   38794:	00044256 	.word	0x00044256
   38798:	00044235 	.word	0x00044235
   3879c:	00040606 	.word	0x00040606
   387a0:	0004426c 	.word	0x0004426c

000387a4 <clear_event_registrations>:
{
   387a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   387a8:	2414      	movs	r4, #20
   387aa:	4680      	mov	r8, r0
   387ac:	4617      	mov	r7, r2
	while (num_events--) {
   387ae:	fb04 0401 	mla	r4, r4, r1, r0
		__ASSERT(false, "invalid event type\n");
   387b2:	4d48      	ldr	r5, [pc, #288]	; (388d4 <clear_event_registrations+0x130>)
   387b4:	f8df 9158 	ldr.w	r9, [pc, #344]	; 38910 <clear_event_registrations+0x16c>
   387b8:	4e47      	ldr	r6, [pc, #284]	; (388d8 <clear_event_registrations+0x134>)
	while (num_events--) {
   387ba:	4544      	cmp	r4, r8
   387bc:	d101      	bne.n	387c2 <clear_event_registrations+0x1e>
}
   387be:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	event->poller = NULL;
   387c2:	2300      	movs	r3, #0
   387c4:	f844 3c0c 	str.w	r3, [r4, #-12]
	switch (event->type) {
   387c8:	f814 3c07 	ldrb.w	r3, [r4, #-7]
   387cc:	f003 030f 	and.w	r3, r3, #15
   387d0:	2b04      	cmp	r3, #4
   387d2:	d83d      	bhi.n	38850 <clear_event_registrations+0xac>
   387d4:	e8df f003 	tbb	[pc, r3]
   387d8:	3c032d49 	.word	0x3c032d49
   387dc:	1e          	.byte	0x1e
   387dd:	00          	.byte	0x00
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
   387de:	f854 3c04 	ldr.w	r3, [r4, #-4]
   387e2:	b963      	cbnz	r3, 387fe <clear_event_registrations+0x5a>
   387e4:	493d      	ldr	r1, [pc, #244]	; (388dc <clear_event_registrations+0x138>)
   387e6:	2396      	movs	r3, #150	; 0x96
   387e8:	462a      	mov	r2, r5
   387ea:	4630      	mov	r0, r6
   387ec:	f003 ff9e 	bl	3c72c <printk>
   387f0:	483b      	ldr	r0, [pc, #236]	; (388e0 <clear_event_registrations+0x13c>)
   387f2:	f003 ff9b 	bl	3c72c <printk>
   387f6:	2196      	movs	r1, #150	; 0x96
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   387f8:	4628      	mov	r0, r5
   387fa:	f003 ffdd 	bl	3c7b8 <assert_post_action>
	if (remove && sys_dnode_is_linked(&event->_node)) {
   387fe:	f854 3c14 	ldr.w	r3, [r4, #-20]
   38802:	b393      	cbz	r3, 3886a <clear_event_registrations+0xc6>
	node->prev->next = node->next;
   38804:	f854 2c10 	ldr.w	r2, [r4, #-16]
   38808:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   3880a:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   3880c:	2300      	movs	r3, #0
	node->prev = NULL;
   3880e:	e944 3305 	strd	r3, r3, [r4, #-20]
   38812:	e02a      	b.n	3886a <clear_event_registrations+0xc6>
		__ASSERT(event->queue != NULL, "invalid queue\n");
   38814:	f854 3c04 	ldr.w	r3, [r4, #-4]
   38818:	2b00      	cmp	r3, #0
   3881a:	d1f0      	bne.n	387fe <clear_event_registrations+0x5a>
   3881c:	4931      	ldr	r1, [pc, #196]	; (388e4 <clear_event_registrations+0x140>)
   3881e:	239a      	movs	r3, #154	; 0x9a
   38820:	462a      	mov	r2, r5
   38822:	4630      	mov	r0, r6
   38824:	f003 ff82 	bl	3c72c <printk>
   38828:	482f      	ldr	r0, [pc, #188]	; (388e8 <clear_event_registrations+0x144>)
   3882a:	f003 ff7f 	bl	3c72c <printk>
   3882e:	219a      	movs	r1, #154	; 0x9a
   38830:	e7e2      	b.n	387f8 <clear_event_registrations+0x54>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   38832:	f854 3c04 	ldr.w	r3, [r4, #-4]
   38836:	2b00      	cmp	r3, #0
   38838:	d1e1      	bne.n	387fe <clear_event_registrations+0x5a>
   3883a:	492c      	ldr	r1, [pc, #176]	; (388ec <clear_event_registrations+0x148>)
   3883c:	239e      	movs	r3, #158	; 0x9e
   3883e:	462a      	mov	r2, r5
   38840:	4630      	mov	r0, r6
   38842:	f003 ff73 	bl	3c72c <printk>
   38846:	482a      	ldr	r0, [pc, #168]	; (388f0 <clear_event_registrations+0x14c>)
   38848:	f003 ff70 	bl	3c72c <printk>
   3884c:	219e      	movs	r1, #158	; 0x9e
   3884e:	e7d3      	b.n	387f8 <clear_event_registrations+0x54>
		__ASSERT(false, "invalid event type\n");
   38850:	4649      	mov	r1, r9
   38852:	23a5      	movs	r3, #165	; 0xa5
   38854:	462a      	mov	r2, r5
   38856:	4630      	mov	r0, r6
   38858:	f003 ff68 	bl	3c72c <printk>
   3885c:	4825      	ldr	r0, [pc, #148]	; (388f4 <clear_event_registrations+0x150>)
   3885e:	f003 ff65 	bl	3c72c <printk>
   38862:	21a5      	movs	r1, #165	; 0xa5
   38864:	4628      	mov	r0, r5
   38866:	f003 ffa7 	bl	3c7b8 <assert_post_action>
   3886a:	4823      	ldr	r0, [pc, #140]	; (388f8 <clear_event_registrations+0x154>)
   3886c:	f7ff f976 	bl	37b5c <z_spin_unlock_valid>
   38870:	b968      	cbnz	r0, 3888e <clear_event_registrations+0xea>
   38872:	235d      	movs	r3, #93	; 0x5d
   38874:	4a21      	ldr	r2, [pc, #132]	; (388fc <clear_event_registrations+0x158>)
   38876:	4922      	ldr	r1, [pc, #136]	; (38900 <clear_event_registrations+0x15c>)
   38878:	4630      	mov	r0, r6
   3887a:	f003 ff57 	bl	3c72c <printk>
   3887e:	491e      	ldr	r1, [pc, #120]	; (388f8 <clear_event_registrations+0x154>)
   38880:	4820      	ldr	r0, [pc, #128]	; (38904 <clear_event_registrations+0x160>)
   38882:	f003 ff53 	bl	3c72c <printk>
   38886:	215d      	movs	r1, #93	; 0x5d
   38888:	481c      	ldr	r0, [pc, #112]	; (388fc <clear_event_registrations+0x158>)
   3888a:	f003 ff95 	bl	3c7b8 <assert_post_action>
   3888e:	f387 8811 	msr	BASEPRI, r7
   38892:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   38896:	f04f 0320 	mov.w	r3, #32
   3889a:	f3ef 8711 	mrs	r7, BASEPRI
   3889e:	f383 8811 	msr	BASEPRI, r3
   388a2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   388a6:	4814      	ldr	r0, [pc, #80]	; (388f8 <clear_event_registrations+0x154>)
   388a8:	f7ff f94a 	bl	37b40 <z_spin_lock_valid>
   388ac:	b968      	cbnz	r0, 388ca <clear_event_registrations+0x126>
   388ae:	234a      	movs	r3, #74	; 0x4a
   388b0:	4a12      	ldr	r2, [pc, #72]	; (388fc <clear_event_registrations+0x158>)
   388b2:	4915      	ldr	r1, [pc, #84]	; (38908 <clear_event_registrations+0x164>)
   388b4:	4630      	mov	r0, r6
   388b6:	f003 ff39 	bl	3c72c <printk>
   388ba:	490f      	ldr	r1, [pc, #60]	; (388f8 <clear_event_registrations+0x154>)
   388bc:	4813      	ldr	r0, [pc, #76]	; (3890c <clear_event_registrations+0x168>)
   388be:	f003 ff35 	bl	3c72c <printk>
   388c2:	214a      	movs	r1, #74	; 0x4a
   388c4:	480d      	ldr	r0, [pc, #52]	; (388fc <clear_event_registrations+0x158>)
   388c6:	f003 ff77 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   388ca:	480b      	ldr	r0, [pc, #44]	; (388f8 <clear_event_registrations+0x154>)
   388cc:	f7ff f956 	bl	37b7c <z_spin_lock_set_owner>
	return k;
   388d0:	3c14      	subs	r4, #20
   388d2:	e772      	b.n	387ba <clear_event_registrations+0x16>
   388d4:	00044235 	.word	0x00044235
   388d8:	00040606 	.word	0x00040606
   388dc:	000440e8 	.word	0x000440e8
   388e0:	00044102 	.word	0x00044102
   388e4:	00044117 	.word	0x00044117
   388e8:	00044133 	.word	0x00044133
   388ec:	00044144 	.word	0x00044144
   388f0:	00044161 	.word	0x00044161
   388f4:	00044178 	.word	0x00044178
   388f8:	20029888 	.word	0x20029888
   388fc:	000405cb 	.word	0x000405cb
   38900:	00040665 	.word	0x00040665
   38904:	0004067c 	.word	0x0004067c
   38908:	000405f1 	.word	0x000405f1
   3890c:	00040623 	.word	0x00040623
   38910:	00043e6b 	.word	0x00043e6b

00038914 <register_events>:
{
   38914:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
   38918:	2700      	movs	r7, #0
{
   3891a:	468a      	mov	sl, r1
   3891c:	4615      	mov	r5, r2
   3891e:	4604      	mov	r4, r0
	int events_registered = 0;
   38920:	46b9      	mov	r9, r7
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   38922:	4e69      	ldr	r6, [pc, #420]	; (38ac8 <register_events+0x1b4>)
   38924:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 38b08 <register_events+0x1f4>
{
   38928:	9301      	str	r3, [sp, #4]
	for (int ii = 0; ii < num_events; ii++) {
   3892a:	4557      	cmp	r7, sl
   3892c:	db03      	blt.n	38936 <register_events+0x22>
}
   3892e:	4648      	mov	r0, r9
   38930:	b003      	add	sp, #12
   38932:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   38936:	f04f 0320 	mov.w	r3, #32
   3893a:	f3ef 8b11 	mrs	fp, BASEPRI
   3893e:	f383 8811 	msr	BASEPRI, r3
   38942:	f3bf 8f6f 	isb	sy
   38946:	4630      	mov	r0, r6
   38948:	f7ff f8fa 	bl	37b40 <z_spin_lock_valid>
   3894c:	b968      	cbnz	r0, 3896a <register_events+0x56>
   3894e:	234a      	movs	r3, #74	; 0x4a
   38950:	4642      	mov	r2, r8
   38952:	495e      	ldr	r1, [pc, #376]	; (38acc <register_events+0x1b8>)
   38954:	485e      	ldr	r0, [pc, #376]	; (38ad0 <register_events+0x1bc>)
   38956:	f003 fee9 	bl	3c72c <printk>
   3895a:	4631      	mov	r1, r6
   3895c:	485d      	ldr	r0, [pc, #372]	; (38ad4 <register_events+0x1c0>)
   3895e:	f003 fee5 	bl	3c72c <printk>
   38962:	214a      	movs	r1, #74	; 0x4a
   38964:	4640      	mov	r0, r8
   38966:	f003 ff27 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   3896a:	4630      	mov	r0, r6
   3896c:	f7ff f906 	bl	37b7c <z_spin_lock_set_owner>
	switch (event->type) {
   38970:	7b63      	ldrb	r3, [r4, #13]
   38972:	f003 030f 	and.w	r3, r3, #15
   38976:	2b04      	cmp	r3, #4
   38978:	d844      	bhi.n	38a04 <register_events+0xf0>
   3897a:	e8df f003 	tbb	[pc, r3]
   3897e:	3d2d      	.short	0x3d2d
   38980:	4303      	.short	0x4303
   38982:	2a          	.byte	0x2a
   38983:	00          	.byte	0x00
		if (k_sem_count_get(event->sem) > 0) {
   38984:	6923      	ldr	r3, [r4, #16]
   38986:	689b      	ldr	r3, [r3, #8]
   38988:	b333      	cbz	r3, 389d8 <register_events+0xc4>
			*state = K_POLL_STATE_SEM_AVAILABLE;
   3898a:	2202      	movs	r2, #2
	event->poller = NULL;
   3898c:	2100      	movs	r1, #0
	event->state |= state;
   3898e:	68e3      	ldr	r3, [r4, #12]
	event->poller = NULL;
   38990:	60a1      	str	r1, [r4, #8]
	event->state |= state;
   38992:	f3c3 3004 	ubfx	r0, r3, #12, #5
   38996:	4302      	orrs	r2, r0
   38998:	f362 3310 	bfi	r3, r2, #12, #5
   3899c:	60e3      	str	r3, [r4, #12]
			poller->is_polling = false;
   3899e:	7029      	strb	r1, [r5, #0]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   389a0:	4630      	mov	r0, r6
   389a2:	f7ff f8db 	bl	37b5c <z_spin_unlock_valid>
   389a6:	b968      	cbnz	r0, 389c4 <register_events+0xb0>
   389a8:	235d      	movs	r3, #93	; 0x5d
   389aa:	4642      	mov	r2, r8
   389ac:	494a      	ldr	r1, [pc, #296]	; (38ad8 <register_events+0x1c4>)
   389ae:	4848      	ldr	r0, [pc, #288]	; (38ad0 <register_events+0x1bc>)
   389b0:	f003 febc 	bl	3c72c <printk>
   389b4:	4631      	mov	r1, r6
   389b6:	4849      	ldr	r0, [pc, #292]	; (38adc <register_events+0x1c8>)
   389b8:	f003 feb8 	bl	3c72c <printk>
   389bc:	215d      	movs	r1, #93	; 0x5d
   389be:	4640      	mov	r0, r8
   389c0:	f003 fefa 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   389c4:	f38b 8811 	msr	BASEPRI, fp
   389c8:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   389cc:	3701      	adds	r7, #1
   389ce:	3414      	adds	r4, #20
   389d0:	e7ab      	b.n	3892a <register_events+0x16>
		if (!k_queue_is_empty(event->queue)) {
   389d2:	6923      	ldr	r3, [r4, #16]
   389d4:	681b      	ldr	r3, [r3, #0]
   389d6:	bb33      	cbnz	r3, 38a26 <register_events+0x112>
		} else if (!just_check && poller->is_polling) {
   389d8:	9b01      	ldr	r3, [sp, #4]
   389da:	2b00      	cmp	r3, #0
   389dc:	d1e0      	bne.n	389a0 <register_events+0x8c>
   389de:	782b      	ldrb	r3, [r5, #0]
   389e0:	2b00      	cmp	r3, #0
   389e2:	d0dd      	beq.n	389a0 <register_events+0x8c>
	switch (event->type) {
   389e4:	7b63      	ldrb	r3, [r4, #13]
   389e6:	f003 030f 	and.w	r3, r3, #15
   389ea:	2b04      	cmp	r3, #4
   389ec:	d85d      	bhi.n	38aaa <register_events+0x196>
   389ee:	e8df f003 	tbb	[pc, r3]
   389f2:	4931      	.short	0x4931
   389f4:	5c1c      	.short	0x5c1c
   389f6:	35          	.byte	0x35
   389f7:	00          	.byte	0x00
		if (event->signal->signaled != 0U) {
   389f8:	6923      	ldr	r3, [r4, #16]
   389fa:	689b      	ldr	r3, [r3, #8]
   389fc:	2b00      	cmp	r3, #0
   389fe:	d0eb      	beq.n	389d8 <register_events+0xc4>
			*state = K_POLL_STATE_SIGNALED;
   38a00:	2201      	movs	r2, #1
   38a02:	e7c3      	b.n	3898c <register_events+0x78>
		__ASSERT(false, "invalid event type (0x%x)\n", event->type);
   38a04:	2350      	movs	r3, #80	; 0x50
   38a06:	4a36      	ldr	r2, [pc, #216]	; (38ae0 <register_events+0x1cc>)
   38a08:	4936      	ldr	r1, [pc, #216]	; (38ae4 <register_events+0x1d0>)
   38a0a:	4831      	ldr	r0, [pc, #196]	; (38ad0 <register_events+0x1bc>)
   38a0c:	f003 fe8e 	bl	3c72c <printk>
   38a10:	7b61      	ldrb	r1, [r4, #13]
   38a12:	4835      	ldr	r0, [pc, #212]	; (38ae8 <register_events+0x1d4>)
   38a14:	f001 010f 	and.w	r1, r1, #15
   38a18:	f003 fe88 	bl	3c72c <printk>
   38a1c:	2150      	movs	r1, #80	; 0x50
   38a1e:	4830      	ldr	r0, [pc, #192]	; (38ae0 <register_events+0x1cc>)
   38a20:	f003 feca 	bl	3c7b8 <assert_post_action>
		break;
   38a24:	e7d8      	b.n	389d8 <register_events+0xc4>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
   38a26:	2204      	movs	r2, #4
   38a28:	e7b0      	b.n	3898c <register_events+0x78>
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
   38a2a:	6923      	ldr	r3, [r4, #16]
   38a2c:	b963      	cbnz	r3, 38a48 <register_events+0x134>
   38a2e:	492f      	ldr	r1, [pc, #188]	; (38aec <register_events+0x1d8>)
   38a30:	2375      	movs	r3, #117	; 0x75
   38a32:	4a2b      	ldr	r2, [pc, #172]	; (38ae0 <register_events+0x1cc>)
   38a34:	4826      	ldr	r0, [pc, #152]	; (38ad0 <register_events+0x1bc>)
   38a36:	f003 fe79 	bl	3c72c <printk>
   38a3a:	482d      	ldr	r0, [pc, #180]	; (38af0 <register_events+0x1dc>)
   38a3c:	f003 fe76 	bl	3c72c <printk>
   38a40:	2175      	movs	r1, #117	; 0x75
   38a42:	4827      	ldr	r0, [pc, #156]	; (38ae0 <register_events+0x1cc>)
   38a44:	f003 feb8 	bl	3c7b8 <assert_post_action>
		add_event(&event->sem->poll_events, event, poller);
   38a48:	462a      	mov	r2, r5
   38a4a:	4621      	mov	r1, r4
   38a4c:	6920      	ldr	r0, [r4, #16]
   38a4e:	3010      	adds	r0, #16
		add_event(&event->queue->poll_events, event, poller);
   38a50:	f005 fe9b 	bl	3e78a <add_event>
	event->poller = poller;
   38a54:	60a5      	str	r5, [r4, #8]
				events_registered += 1;
   38a56:	f109 0901 	add.w	r9, r9, #1
   38a5a:	e7a1      	b.n	389a0 <register_events+0x8c>
		__ASSERT(event->queue != NULL, "invalid queue\n");
   38a5c:	6923      	ldr	r3, [r4, #16]
   38a5e:	b963      	cbnz	r3, 38a7a <register_events+0x166>
   38a60:	4924      	ldr	r1, [pc, #144]	; (38af4 <register_events+0x1e0>)
   38a62:	2379      	movs	r3, #121	; 0x79
   38a64:	4a1e      	ldr	r2, [pc, #120]	; (38ae0 <register_events+0x1cc>)
   38a66:	481a      	ldr	r0, [pc, #104]	; (38ad0 <register_events+0x1bc>)
   38a68:	f003 fe60 	bl	3c72c <printk>
   38a6c:	4822      	ldr	r0, [pc, #136]	; (38af8 <register_events+0x1e4>)
   38a6e:	f003 fe5d 	bl	3c72c <printk>
   38a72:	2179      	movs	r1, #121	; 0x79
   38a74:	481a      	ldr	r0, [pc, #104]	; (38ae0 <register_events+0x1cc>)
   38a76:	f003 fe9f 	bl	3c7b8 <assert_post_action>
		add_event(&event->queue->poll_events, event, poller);
   38a7a:	6920      	ldr	r0, [r4, #16]
   38a7c:	462a      	mov	r2, r5
   38a7e:	4621      	mov	r1, r4
   38a80:	300c      	adds	r0, #12
   38a82:	e7e5      	b.n	38a50 <register_events+0x13c>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   38a84:	6923      	ldr	r3, [r4, #16]
   38a86:	b963      	cbnz	r3, 38aa2 <register_events+0x18e>
   38a88:	491c      	ldr	r1, [pc, #112]	; (38afc <register_events+0x1e8>)
   38a8a:	237d      	movs	r3, #125	; 0x7d
   38a8c:	4a14      	ldr	r2, [pc, #80]	; (38ae0 <register_events+0x1cc>)
   38a8e:	4810      	ldr	r0, [pc, #64]	; (38ad0 <register_events+0x1bc>)
   38a90:	f003 fe4c 	bl	3c72c <printk>
   38a94:	481a      	ldr	r0, [pc, #104]	; (38b00 <register_events+0x1ec>)
   38a96:	f003 fe49 	bl	3c72c <printk>
   38a9a:	217d      	movs	r1, #125	; 0x7d
   38a9c:	4810      	ldr	r0, [pc, #64]	; (38ae0 <register_events+0x1cc>)
   38a9e:	f003 fe8b 	bl	3c7b8 <assert_post_action>
		add_event(&event->signal->poll_events, event, poller);
   38aa2:	462a      	mov	r2, r5
   38aa4:	4621      	mov	r1, r4
   38aa6:	6920      	ldr	r0, [r4, #16]
   38aa8:	e7d2      	b.n	38a50 <register_events+0x13c>
		__ASSERT(false, "invalid event type\n");
   38aaa:	2384      	movs	r3, #132	; 0x84
   38aac:	4a0c      	ldr	r2, [pc, #48]	; (38ae0 <register_events+0x1cc>)
   38aae:	490d      	ldr	r1, [pc, #52]	; (38ae4 <register_events+0x1d0>)
   38ab0:	4807      	ldr	r0, [pc, #28]	; (38ad0 <register_events+0x1bc>)
   38ab2:	f003 fe3b 	bl	3c72c <printk>
   38ab6:	4813      	ldr	r0, [pc, #76]	; (38b04 <register_events+0x1f0>)
   38ab8:	f003 fe38 	bl	3c72c <printk>
   38abc:	2184      	movs	r1, #132	; 0x84
   38abe:	4808      	ldr	r0, [pc, #32]	; (38ae0 <register_events+0x1cc>)
   38ac0:	f003 fe7a 	bl	3c7b8 <assert_post_action>
		break;
   38ac4:	e7c6      	b.n	38a54 <register_events+0x140>
   38ac6:	bf00      	nop
   38ac8:	20029888 	.word	0x20029888
   38acc:	000405f1 	.word	0x000405f1
   38ad0:	00040606 	.word	0x00040606
   38ad4:	00040623 	.word	0x00040623
   38ad8:	00040665 	.word	0x00040665
   38adc:	0004067c 	.word	0x0004067c
   38ae0:	00044235 	.word	0x00044235
   38ae4:	00043e6b 	.word	0x00043e6b
   38ae8:	0004428b 	.word	0x0004428b
   38aec:	000440e8 	.word	0x000440e8
   38af0:	00044102 	.word	0x00044102
   38af4:	00044117 	.word	0x00044117
   38af8:	00044133 	.word	0x00044133
   38afc:	00044144 	.word	0x00044144
   38b00:	00044161 	.word	0x00044161
   38b04:	00044178 	.word	0x00044178
   38b08:	000405cb 	.word	0x000405cb

00038b0c <k_poll_event_init>:
{
   38b0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   38b0e:	4604      	mov	r4, r0
   38b10:	460f      	mov	r7, r1
   38b12:	461d      	mov	r5, r3
	__ASSERT(mode == K_POLL_MODE_NOTIFY_ONLY,
   38b14:	4616      	mov	r6, r2
   38b16:	b162      	cbz	r2, 38b32 <k_poll_event_init+0x26>
   38b18:	491c      	ldr	r1, [pc, #112]	; (38b8c <k_poll_event_init+0x80>)
   38b1a:	232a      	movs	r3, #42	; 0x2a
   38b1c:	4a1c      	ldr	r2, [pc, #112]	; (38b90 <k_poll_event_init+0x84>)
   38b1e:	481d      	ldr	r0, [pc, #116]	; (38b94 <k_poll_event_init+0x88>)
   38b20:	f003 fe04 	bl	3c72c <printk>
   38b24:	481c      	ldr	r0, [pc, #112]	; (38b98 <k_poll_event_init+0x8c>)
   38b26:	f003 fe01 	bl	3c72c <printk>
   38b2a:	212a      	movs	r1, #42	; 0x2a
   38b2c:	4818      	ldr	r0, [pc, #96]	; (38b90 <k_poll_event_init+0x84>)
   38b2e:	f003 fe43 	bl	3c7b8 <assert_post_action>
	__ASSERT(type < (BIT(_POLL_NUM_TYPES)), "invalid type\n");
   38b32:	2f0f      	cmp	r7, #15
   38b34:	d90c      	bls.n	38b50 <k_poll_event_init+0x44>
   38b36:	4919      	ldr	r1, [pc, #100]	; (38b9c <k_poll_event_init+0x90>)
   38b38:	232b      	movs	r3, #43	; 0x2b
   38b3a:	4a15      	ldr	r2, [pc, #84]	; (38b90 <k_poll_event_init+0x84>)
   38b3c:	4815      	ldr	r0, [pc, #84]	; (38b94 <k_poll_event_init+0x88>)
   38b3e:	f003 fdf5 	bl	3c72c <printk>
   38b42:	4817      	ldr	r0, [pc, #92]	; (38ba0 <k_poll_event_init+0x94>)
   38b44:	f003 fdf2 	bl	3c72c <printk>
   38b48:	212b      	movs	r1, #43	; 0x2b
   38b4a:	4811      	ldr	r0, [pc, #68]	; (38b90 <k_poll_event_init+0x84>)
   38b4c:	f003 fe34 	bl	3c7b8 <assert_post_action>
	__ASSERT(obj != NULL, "must provide an object\n");
   38b50:	b965      	cbnz	r5, 38b6c <k_poll_event_init+0x60>
   38b52:	4914      	ldr	r1, [pc, #80]	; (38ba4 <k_poll_event_init+0x98>)
   38b54:	232c      	movs	r3, #44	; 0x2c
   38b56:	4a0e      	ldr	r2, [pc, #56]	; (38b90 <k_poll_event_init+0x84>)
   38b58:	480e      	ldr	r0, [pc, #56]	; (38b94 <k_poll_event_init+0x88>)
   38b5a:	f003 fde7 	bl	3c72c <printk>
   38b5e:	4812      	ldr	r0, [pc, #72]	; (38ba8 <k_poll_event_init+0x9c>)
   38b60:	f003 fde4 	bl	3c72c <printk>
   38b64:	212c      	movs	r1, #44	; 0x2c
   38b66:	480a      	ldr	r0, [pc, #40]	; (38b90 <k_poll_event_init+0x84>)
   38b68:	f003 fe26 	bl	3c7b8 <assert_post_action>
	event->type = type;
   38b6c:	7b63      	ldrb	r3, [r4, #13]
   38b6e:	f367 0303 	bfi	r3, r7, #0, #4
   38b72:	7363      	strb	r3, [r4, #13]
	event->mode = mode;
   38b74:	7ba3      	ldrb	r3, [r4, #14]
   38b76:	f366 0341 	bfi	r3, r6, #1, #1
   38b7a:	73a3      	strb	r3, [r4, #14]
	event->poller = NULL;
   38b7c:	2300      	movs	r3, #0
	event->state = K_POLL_STATE_NOT_READY;
   38b7e:	68e2      	ldr	r2, [r4, #12]
	event->poller = NULL;
   38b80:	60a3      	str	r3, [r4, #8]
	event->state = K_POLL_STATE_NOT_READY;
   38b82:	4b0a      	ldr	r3, [pc, #40]	; (38bac <k_poll_event_init+0xa0>)
   38b84:	4013      	ands	r3, r2
	event->obj = obj;
   38b86:	e9c4 3503 	strd	r3, r5, [r4, #12]
}
   38b8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   38b8c:	0004418e 	.word	0x0004418e
   38b90:	00044235 	.word	0x00044235
   38b94:	00040606 	.word	0x00040606
   38b98:	000441ae 	.word	0x000441ae
   38b9c:	000441d4 	.word	0x000441d4
   38ba0:	000441f8 	.word	0x000441f8
   38ba4:	00044208 	.word	0x00044208
   38ba8:	0004421b 	.word	0x0004421b
   38bac:	00020fff 	.word	0x00020fff

00038bb0 <z_impl_k_poll>:

int z_impl_k_poll(struct k_poll_event *events, int num_events, s32_t timeout)
{
	int events_registered;
	k_spinlock_key_t key;
	struct _poller poller = { .is_polling = true,
   38bb0:	2301      	movs	r3, #1
{
   38bb2:	b5f0      	push	{r4, r5, r6, r7, lr}
   38bb4:	b087      	sub	sp, #28
	struct _poller poller = { .is_polling = true,
   38bb6:	f88d 300c 	strb.w	r3, [sp, #12]
				  .thread     = _current,
   38bba:	4b70      	ldr	r3, [pc, #448]	; (38d7c <z_impl_k_poll+0x1cc>)
{
   38bbc:	4604      	mov	r4, r0
	struct _poller poller = { .is_polling = true,
   38bbe:	689b      	ldr	r3, [r3, #8]
{
   38bc0:	460d      	mov	r5, r1
	struct _poller poller = { .is_polling = true,
   38bc2:	9304      	str	r3, [sp, #16]
   38bc4:	4b6e      	ldr	r3, [pc, #440]	; (38d80 <z_impl_k_poll+0x1d0>)
{
   38bc6:	4616      	mov	r6, r2
	struct _poller poller = { .is_polling = true,
   38bc8:	9305      	str	r3, [sp, #20]
   38bca:	f3ef 8305 	mrs	r3, IPSR
				  .cb         = k_poll_poller_cb };

	__ASSERT(!arch_is_in_isr(), "");
   38bce:	b163      	cbz	r3, 38bea <z_impl_k_poll+0x3a>
   38bd0:	496c      	ldr	r1, [pc, #432]	; (38d84 <z_impl_k_poll+0x1d4>)
   38bd2:	23ff      	movs	r3, #255	; 0xff
   38bd4:	4a6c      	ldr	r2, [pc, #432]	; (38d88 <z_impl_k_poll+0x1d8>)
   38bd6:	486d      	ldr	r0, [pc, #436]	; (38d8c <z_impl_k_poll+0x1dc>)
   38bd8:	f003 fda8 	bl	3c72c <printk>
   38bdc:	486c      	ldr	r0, [pc, #432]	; (38d90 <z_impl_k_poll+0x1e0>)
   38bde:	f003 fda5 	bl	3c72c <printk>
   38be2:	21ff      	movs	r1, #255	; 0xff
   38be4:	4868      	ldr	r0, [pc, #416]	; (38d88 <z_impl_k_poll+0x1d8>)
   38be6:	f003 fde7 	bl	3c7b8 <assert_post_action>
	__ASSERT(events != NULL, "NULL events\n");
   38bea:	b974      	cbnz	r4, 38c0a <z_impl_k_poll+0x5a>
   38bec:	4969      	ldr	r1, [pc, #420]	; (38d94 <z_impl_k_poll+0x1e4>)
   38bee:	f44f 7380 	mov.w	r3, #256	; 0x100
   38bf2:	4a65      	ldr	r2, [pc, #404]	; (38d88 <z_impl_k_poll+0x1d8>)
   38bf4:	4865      	ldr	r0, [pc, #404]	; (38d8c <z_impl_k_poll+0x1dc>)
   38bf6:	f003 fd99 	bl	3c72c <printk>
   38bfa:	4867      	ldr	r0, [pc, #412]	; (38d98 <z_impl_k_poll+0x1e8>)
   38bfc:	f003 fd96 	bl	3c72c <printk>
   38c00:	f44f 7180 	mov.w	r1, #256	; 0x100
   38c04:	4860      	ldr	r0, [pc, #384]	; (38d88 <z_impl_k_poll+0x1d8>)
   38c06:	f003 fdd7 	bl	3c7b8 <assert_post_action>
	__ASSERT(num_events >= 0, "<0 events\n");
   38c0a:	2d00      	cmp	r5, #0
   38c0c:	da0e      	bge.n	38c2c <z_impl_k_poll+0x7c>
   38c0e:	4963      	ldr	r1, [pc, #396]	; (38d9c <z_impl_k_poll+0x1ec>)
   38c10:	f240 1301 	movw	r3, #257	; 0x101
   38c14:	4a5c      	ldr	r2, [pc, #368]	; (38d88 <z_impl_k_poll+0x1d8>)
   38c16:	485d      	ldr	r0, [pc, #372]	; (38d8c <z_impl_k_poll+0x1dc>)
   38c18:	f003 fd88 	bl	3c72c <printk>
   38c1c:	4860      	ldr	r0, [pc, #384]	; (38da0 <z_impl_k_poll+0x1f0>)
   38c1e:	f003 fd85 	bl	3c72c <printk>
   38c22:	f240 1101 	movw	r1, #257	; 0x101
   38c26:	4858      	ldr	r0, [pc, #352]	; (38d88 <z_impl_k_poll+0x1d8>)
   38c28:	f003 fdc6 	bl	3c7b8 <assert_post_action>

	events_registered = register_events(events, num_events, &poller,
   38c2c:	fab6 f386 	clz	r3, r6
   38c30:	aa03      	add	r2, sp, #12
   38c32:	095b      	lsrs	r3, r3, #5
   38c34:	4629      	mov	r1, r5
   38c36:	4620      	mov	r0, r4
   38c38:	f7ff fe6c 	bl	38914 <register_events>
   38c3c:	4607      	mov	r7, r0
	__asm__ volatile(
   38c3e:	f04f 0320 	mov.w	r3, #32
   38c42:	f3ef 8511 	mrs	r5, BASEPRI
   38c46:	f383 8811 	msr	BASEPRI, r3
   38c4a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   38c4e:	4855      	ldr	r0, [pc, #340]	; (38da4 <z_impl_k_poll+0x1f4>)
   38c50:	f7fe ff76 	bl	37b40 <z_spin_lock_valid>
   38c54:	b968      	cbnz	r0, 38c72 <z_impl_k_poll+0xc2>
   38c56:	234a      	movs	r3, #74	; 0x4a
   38c58:	4a53      	ldr	r2, [pc, #332]	; (38da8 <z_impl_k_poll+0x1f8>)
   38c5a:	4954      	ldr	r1, [pc, #336]	; (38dac <z_impl_k_poll+0x1fc>)
   38c5c:	484b      	ldr	r0, [pc, #300]	; (38d8c <z_impl_k_poll+0x1dc>)
   38c5e:	f003 fd65 	bl	3c72c <printk>
   38c62:	4950      	ldr	r1, [pc, #320]	; (38da4 <z_impl_k_poll+0x1f4>)
   38c64:	4852      	ldr	r0, [pc, #328]	; (38db0 <z_impl_k_poll+0x200>)
   38c66:	f003 fd61 	bl	3c72c <printk>
   38c6a:	214a      	movs	r1, #74	; 0x4a
   38c6c:	484e      	ldr	r0, [pc, #312]	; (38da8 <z_impl_k_poll+0x1f8>)
   38c6e:	f003 fda3 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   38c72:	484c      	ldr	r0, [pc, #304]	; (38da4 <z_impl_k_poll+0x1f4>)
   38c74:	f7fe ff82 	bl	37b7c <z_spin_lock_set_owner>
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller.is_polling) {
   38c78:	f89d 300c 	ldrb.w	r3, [sp, #12]
   38c7c:	b9f3      	cbnz	r3, 38cbc <z_impl_k_poll+0x10c>
		clear_event_registrations(events, events_registered, key);
   38c7e:	4620      	mov	r0, r4
   38c80:	462a      	mov	r2, r5
   38c82:	4639      	mov	r1, r7
   38c84:	f7ff fd8e 	bl	387a4 <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   38c88:	4846      	ldr	r0, [pc, #280]	; (38da4 <z_impl_k_poll+0x1f4>)
   38c8a:	f7fe ff67 	bl	37b5c <z_spin_unlock_valid>
   38c8e:	b968      	cbnz	r0, 38cac <z_impl_k_poll+0xfc>
   38c90:	235d      	movs	r3, #93	; 0x5d
   38c92:	4a45      	ldr	r2, [pc, #276]	; (38da8 <z_impl_k_poll+0x1f8>)
   38c94:	4947      	ldr	r1, [pc, #284]	; (38db4 <z_impl_k_poll+0x204>)
   38c96:	483d      	ldr	r0, [pc, #244]	; (38d8c <z_impl_k_poll+0x1dc>)
   38c98:	f003 fd48 	bl	3c72c <printk>
   38c9c:	4941      	ldr	r1, [pc, #260]	; (38da4 <z_impl_k_poll+0x1f4>)
   38c9e:	4846      	ldr	r0, [pc, #280]	; (38db8 <z_impl_k_poll+0x208>)
   38ca0:	f003 fd44 	bl	3c72c <printk>
   38ca4:	215d      	movs	r1, #93	; 0x5d
   38ca6:	4840      	ldr	r0, [pc, #256]	; (38da8 <z_impl_k_poll+0x1f8>)
   38ca8:	f003 fd86 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   38cac:	f385 8811 	msr	BASEPRI, r5
   38cb0:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		return 0;
   38cb4:	2500      	movs	r5, #0
	key = k_spin_lock(&lock);
	clear_event_registrations(events, events_registered, key);
	k_spin_unlock(&lock, key);

	return swap_rc;
}
   38cb6:	4628      	mov	r0, r5
   38cb8:	b007      	add	sp, #28
   38cba:	bdf0      	pop	{r4, r5, r6, r7, pc}
	poller.is_polling = false;
   38cbc:	2300      	movs	r3, #0
   38cbe:	f88d 300c 	strb.w	r3, [sp, #12]
	if (timeout == K_NO_WAIT) {
   38cc2:	b9c6      	cbnz	r6, 38cf6 <z_impl_k_poll+0x146>
   38cc4:	4837      	ldr	r0, [pc, #220]	; (38da4 <z_impl_k_poll+0x1f4>)
   38cc6:	f7fe ff49 	bl	37b5c <z_spin_unlock_valid>
   38cca:	b968      	cbnz	r0, 38ce8 <z_impl_k_poll+0x138>
   38ccc:	235d      	movs	r3, #93	; 0x5d
   38cce:	4a36      	ldr	r2, [pc, #216]	; (38da8 <z_impl_k_poll+0x1f8>)
   38cd0:	4938      	ldr	r1, [pc, #224]	; (38db4 <z_impl_k_poll+0x204>)
   38cd2:	482e      	ldr	r0, [pc, #184]	; (38d8c <z_impl_k_poll+0x1dc>)
   38cd4:	f003 fd2a 	bl	3c72c <printk>
   38cd8:	4932      	ldr	r1, [pc, #200]	; (38da4 <z_impl_k_poll+0x1f4>)
   38cda:	4837      	ldr	r0, [pc, #220]	; (38db8 <z_impl_k_poll+0x208>)
   38cdc:	f003 fd26 	bl	3c72c <printk>
   38ce0:	215d      	movs	r1, #93	; 0x5d
   38ce2:	4831      	ldr	r0, [pc, #196]	; (38da8 <z_impl_k_poll+0x1f8>)
   38ce4:	f003 fd68 	bl	3c7b8 <assert_post_action>
   38ce8:	f385 8811 	msr	BASEPRI, r5
   38cec:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
   38cf0:	f06f 050a 	mvn.w	r5, #10
   38cf4:	e7df      	b.n	38cb6 <z_impl_k_poll+0x106>
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   38cf6:	aa01      	add	r2, sp, #4
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   38cf8:	4629      	mov	r1, r5
   38cfa:	4633      	mov	r3, r6
   38cfc:	4829      	ldr	r0, [pc, #164]	; (38da4 <z_impl_k_poll+0x1f4>)
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   38cfe:	e9cd 2201 	strd	r2, r2, [sp, #4]
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   38d02:	f7fe fb43 	bl	3738c <z_pend_curr>
   38d06:	4605      	mov	r5, r0
	__asm__ volatile(
   38d08:	f04f 0320 	mov.w	r3, #32
   38d0c:	f3ef 8611 	mrs	r6, BASEPRI
   38d10:	f383 8811 	msr	BASEPRI, r3
   38d14:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   38d18:	4822      	ldr	r0, [pc, #136]	; (38da4 <z_impl_k_poll+0x1f4>)
   38d1a:	f7fe ff11 	bl	37b40 <z_spin_lock_valid>
   38d1e:	b968      	cbnz	r0, 38d3c <z_impl_k_poll+0x18c>
   38d20:	234a      	movs	r3, #74	; 0x4a
   38d22:	4a21      	ldr	r2, [pc, #132]	; (38da8 <z_impl_k_poll+0x1f8>)
   38d24:	4921      	ldr	r1, [pc, #132]	; (38dac <z_impl_k_poll+0x1fc>)
   38d26:	4819      	ldr	r0, [pc, #100]	; (38d8c <z_impl_k_poll+0x1dc>)
   38d28:	f003 fd00 	bl	3c72c <printk>
   38d2c:	491d      	ldr	r1, [pc, #116]	; (38da4 <z_impl_k_poll+0x1f4>)
   38d2e:	4820      	ldr	r0, [pc, #128]	; (38db0 <z_impl_k_poll+0x200>)
   38d30:	f003 fcfc 	bl	3c72c <printk>
   38d34:	214a      	movs	r1, #74	; 0x4a
   38d36:	481c      	ldr	r0, [pc, #112]	; (38da8 <z_impl_k_poll+0x1f8>)
   38d38:	f003 fd3e 	bl	3c7b8 <assert_post_action>
	z_spin_lock_set_owner(l);
   38d3c:	4819      	ldr	r0, [pc, #100]	; (38da4 <z_impl_k_poll+0x1f4>)
   38d3e:	f7fe ff1d 	bl	37b7c <z_spin_lock_set_owner>
	clear_event_registrations(events, events_registered, key);
   38d42:	4620      	mov	r0, r4
   38d44:	4632      	mov	r2, r6
   38d46:	4639      	mov	r1, r7
   38d48:	f7ff fd2c 	bl	387a4 <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   38d4c:	4815      	ldr	r0, [pc, #84]	; (38da4 <z_impl_k_poll+0x1f4>)
   38d4e:	f7fe ff05 	bl	37b5c <z_spin_unlock_valid>
   38d52:	b968      	cbnz	r0, 38d70 <z_impl_k_poll+0x1c0>
   38d54:	235d      	movs	r3, #93	; 0x5d
   38d56:	4a14      	ldr	r2, [pc, #80]	; (38da8 <z_impl_k_poll+0x1f8>)
   38d58:	4916      	ldr	r1, [pc, #88]	; (38db4 <z_impl_k_poll+0x204>)
   38d5a:	480c      	ldr	r0, [pc, #48]	; (38d8c <z_impl_k_poll+0x1dc>)
   38d5c:	f003 fce6 	bl	3c72c <printk>
   38d60:	4910      	ldr	r1, [pc, #64]	; (38da4 <z_impl_k_poll+0x1f4>)
   38d62:	4815      	ldr	r0, [pc, #84]	; (38db8 <z_impl_k_poll+0x208>)
   38d64:	f003 fce2 	bl	3c72c <printk>
   38d68:	215d      	movs	r1, #93	; 0x5d
   38d6a:	480f      	ldr	r0, [pc, #60]	; (38da8 <z_impl_k_poll+0x1f8>)
   38d6c:	f003 fd24 	bl	3c7b8 <assert_post_action>
	__asm__ volatile(
   38d70:	f386 8811 	msr	BASEPRI, r6
   38d74:	f3bf 8f6f 	isb	sy
	return swap_rc;
   38d78:	e79d      	b.n	38cb6 <z_impl_k_poll+0x106>
   38d7a:	bf00      	nop
   38d7c:	2002976c 	.word	0x2002976c
   38d80:	00038735 	.word	0x00038735
   38d84:	00043e0b 	.word	0x00043e0b
   38d88:	00044235 	.word	0x00044235
   38d8c:	00040606 	.word	0x00040606
   38d90:	00042742 	.word	0x00042742
   38d94:	000442a8 	.word	0x000442a8
   38d98:	000442be 	.word	0x000442be
   38d9c:	000442cd 	.word	0x000442cd
   38da0:	000442dd 	.word	0x000442dd
   38da4:	20029888 	.word	0x20029888
   38da8:	000405cb 	.word	0x000405cb
   38dac:	000405f1 	.word	0x000405f1
   38db0:	00040623 	.word	0x00040623
   38db4:	00040665 	.word	0x00040665
   38db8:	0004067c 	.word	0x0004067c

00038dbc <fabs>:
   38dbc:	ec51 0b10 	vmov	r0, r1, d0
   38dc0:	ee10 2a10 	vmov	r2, s0
   38dc4:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   38dc8:	ec43 2b10 	vmov	d0, r2, r3
   38dcc:	4770      	bx	lr
   38dce:	bf00      	nop

00038dd0 <acos>:
   38dd0:	b538      	push	{r3, r4, r5, lr}
   38dd2:	ed2d 8b02 	vpush	{d8}
   38dd6:	ec55 4b10 	vmov	r4, r5, d0
   38dda:	f7e5 fbf9 	bl	1e5d0 <__ieee754_acos>
   38dde:	4b16      	ldr	r3, [pc, #88]	; (38e38 <acos+0x68>)
   38de0:	eeb0 8a40 	vmov.f32	s16, s0
   38de4:	eef0 8a60 	vmov.f32	s17, s1
   38de8:	f993 3000 	ldrsb.w	r3, [r3]
   38dec:	3301      	adds	r3, #1
   38dee:	d011      	beq.n	38e14 <acos+0x44>
   38df0:	4622      	mov	r2, r4
   38df2:	462b      	mov	r3, r5
   38df4:	4620      	mov	r0, r4
   38df6:	4629      	mov	r1, r5
   38df8:	f7e4 f966 	bl	1d0c8 <__aeabi_dcmpun>
   38dfc:	b950      	cbnz	r0, 38e14 <acos+0x44>
   38dfe:	ec45 4b10 	vmov	d0, r4, r5
   38e02:	f7ff ffdb 	bl	38dbc <fabs>
   38e06:	2200      	movs	r2, #0
   38e08:	4b0c      	ldr	r3, [pc, #48]	; (38e3c <acos+0x6c>)
   38e0a:	ec51 0b10 	vmov	r0, r1, d0
   38e0e:	f7e3 ff63 	bl	1ccd8 <__aeabi_dcmpgt>
   38e12:	b930      	cbnz	r0, 38e22 <acos+0x52>
   38e14:	eeb0 0a48 	vmov.f32	s0, s16
   38e18:	eef0 0a68 	vmov.f32	s1, s17
   38e1c:	ecbd 8b02 	vpop	{d8}
   38e20:	bd38      	pop	{r3, r4, r5, pc}
   38e22:	f003 fe7e 	bl	3cb22 <__errno>
   38e26:	2321      	movs	r3, #33	; 0x21
   38e28:	ecbd 8b02 	vpop	{d8}
   38e2c:	6003      	str	r3, [r0, #0]
   38e2e:	4804      	ldr	r0, [pc, #16]	; (38e40 <acos+0x70>)
   38e30:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   38e34:	f7e6 bbbc 	b.w	1f5b0 <nan>
   38e38:	20037902 	.word	0x20037902
   38e3c:	3ff00000 	.word	0x3ff00000
   38e40:	0004025c 	.word	0x0004025c

00038e44 <sqrt>:
   38e44:	b538      	push	{r3, r4, r5, lr}
   38e46:	ed2d 8b02 	vpush	{d8}
   38e4a:	ec55 4b10 	vmov	r4, r5, d0
   38e4e:	f000 f833 	bl	38eb8 <__ieee754_sqrt>
   38e52:	4b18      	ldr	r3, [pc, #96]	; (38eb4 <sqrt+0x70>)
   38e54:	eeb0 8a40 	vmov.f32	s16, s0
   38e58:	eef0 8a60 	vmov.f32	s17, s1
   38e5c:	f993 3000 	ldrsb.w	r3, [r3]
   38e60:	3301      	adds	r3, #1
   38e62:	d00d      	beq.n	38e80 <sqrt+0x3c>
   38e64:	4622      	mov	r2, r4
   38e66:	462b      	mov	r3, r5
   38e68:	4620      	mov	r0, r4
   38e6a:	4629      	mov	r1, r5
   38e6c:	f7e4 f92c 	bl	1d0c8 <__aeabi_dcmpun>
   38e70:	b930      	cbnz	r0, 38e80 <sqrt+0x3c>
   38e72:	4620      	mov	r0, r4
   38e74:	4629      	mov	r1, r5
   38e76:	2200      	movs	r2, #0
   38e78:	2300      	movs	r3, #0
   38e7a:	f7e3 ff0f 	bl	1cc9c <__aeabi_dcmplt>
   38e7e:	b930      	cbnz	r0, 38e8e <sqrt+0x4a>
   38e80:	eeb0 0a48 	vmov.f32	s0, s16
   38e84:	eef0 0a68 	vmov.f32	s1, s17
   38e88:	ecbd 8b02 	vpop	{d8}
   38e8c:	bd38      	pop	{r3, r4, r5, pc}
   38e8e:	f003 fe48 	bl	3cb22 <__errno>
   38e92:	2121      	movs	r1, #33	; 0x21
   38e94:	2200      	movs	r2, #0
   38e96:	2300      	movs	r3, #0
   38e98:	6001      	str	r1, [r0, #0]
   38e9a:	4610      	mov	r0, r2
   38e9c:	4619      	mov	r1, r3
   38e9e:	f7e3 fdb5 	bl	1ca0c <__aeabi_ddiv>
   38ea2:	ec41 0b18 	vmov	d8, r0, r1
   38ea6:	eeb0 0a48 	vmov.f32	s0, s16
   38eaa:	eef0 0a68 	vmov.f32	s1, s17
   38eae:	ecbd 8b02 	vpop	{d8}
   38eb2:	bd38      	pop	{r3, r4, r5, pc}
   38eb4:	20037902 	.word	0x20037902

00038eb8 <__ieee754_sqrt>:
   38eb8:	4a63      	ldr	r2, [pc, #396]	; (39048 <__ieee754_sqrt+0x190>)
   38eba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   38ebe:	ec55 4b10 	vmov	r4, r5, d0
   38ec2:	43aa      	bics	r2, r5
   38ec4:	f000 8098 	beq.w	38ff8 <__ieee754_sqrt+0x140>
   38ec8:	2d00      	cmp	r5, #0
   38eca:	462b      	mov	r3, r5
   38ecc:	ee10 0a10 	vmov	r0, s0
   38ed0:	dd5a      	ble.n	38f88 <__ieee754_sqrt+0xd0>
   38ed2:	ea5f 5e25 	movs.w	lr, r5, asr #20
   38ed6:	f000 80ab 	beq.w	39030 <__ieee754_sqrt+0x178>
   38eda:	f3c3 0113 	ubfx	r1, r3, #0, #20
   38ede:	f2ae 3eff 	subw	lr, lr, #1023	; 0x3ff
   38ee2:	0fc3      	lsrs	r3, r0, #31
   38ee4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   38ee8:	f01e 0f01 	tst.w	lr, #1
   38eec:	ea4f 0240 	mov.w	r2, r0, lsl #1
   38ef0:	eb03 0341 	add.w	r3, r3, r1, lsl #1
   38ef4:	d003      	beq.n	38efe <__ieee754_sqrt+0x46>
   38ef6:	0fd1      	lsrs	r1, r2, #31
   38ef8:	0082      	lsls	r2, r0, #2
   38efa:	eb01 0343 	add.w	r3, r1, r3, lsl #1
   38efe:	f04f 0c00 	mov.w	ip, #0
   38f02:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   38f06:	2416      	movs	r4, #22
   38f08:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
   38f0c:	4665      	mov	r5, ip
   38f0e:	1868      	adds	r0, r5, r1
   38f10:	4298      	cmp	r0, r3
   38f12:	dc02      	bgt.n	38f1a <__ieee754_sqrt+0x62>
   38f14:	1a1b      	subs	r3, r3, r0
   38f16:	1845      	adds	r5, r0, r1
   38f18:	448c      	add	ip, r1
   38f1a:	005b      	lsls	r3, r3, #1
   38f1c:	3c01      	subs	r4, #1
   38f1e:	ea4f 0151 	mov.w	r1, r1, lsr #1
   38f22:	eb03 73d2 	add.w	r3, r3, r2, lsr #31
   38f26:	ea4f 0242 	mov.w	r2, r2, lsl #1
   38f2a:	d1f0      	bne.n	38f0e <__ieee754_sqrt+0x56>
   38f2c:	4627      	mov	r7, r4
   38f2e:	2620      	movs	r6, #32
   38f30:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   38f34:	e014      	b.n	38f60 <__ieee754_sqrt+0xa8>
   38f36:	d10a      	bne.n	38f4e <__ieee754_sqrt+0x96>
   38f38:	4290      	cmp	r0, r2
   38f3a:	d808      	bhi.n	38f4e <__ieee754_sqrt+0x96>
   38f3c:	2800      	cmp	r0, #0
   38f3e:	eb00 0401 	add.w	r4, r0, r1
   38f42:	db1c      	blt.n	38f7e <__ieee754_sqrt+0xc6>
   38f44:	46a8      	mov	r8, r5
   38f46:	2300      	movs	r3, #0
   38f48:	1a12      	subs	r2, r2, r0
   38f4a:	440f      	add	r7, r1
   38f4c:	4645      	mov	r5, r8
   38f4e:	0fd0      	lsrs	r0, r2, #31
   38f50:	3e01      	subs	r6, #1
   38f52:	ea4f 0151 	mov.w	r1, r1, lsr #1
   38f56:	eb00 0343 	add.w	r3, r0, r3, lsl #1
   38f5a:	ea4f 0242 	mov.w	r2, r2, lsl #1
   38f5e:	d034      	beq.n	38fca <__ieee754_sqrt+0x112>
   38f60:	42ab      	cmp	r3, r5
   38f62:	eb01 0004 	add.w	r0, r1, r4
   38f66:	dde6      	ble.n	38f36 <__ieee754_sqrt+0x7e>
   38f68:	2800      	cmp	r0, #0
   38f6a:	eb00 0401 	add.w	r4, r0, r1
   38f6e:	db06      	blt.n	38f7e <__ieee754_sqrt+0xc6>
   38f70:	46a8      	mov	r8, r5
   38f72:	1b5b      	subs	r3, r3, r5
   38f74:	4290      	cmp	r0, r2
   38f76:	bf88      	it	hi
   38f78:	f103 33ff 	addhi.w	r3, r3, #4294967295
   38f7c:	e7e4      	b.n	38f48 <__ieee754_sqrt+0x90>
   38f7e:	2c00      	cmp	r4, #0
   38f80:	dbf6      	blt.n	38f70 <__ieee754_sqrt+0xb8>
   38f82:	f105 0801 	add.w	r8, r5, #1
   38f86:	e7f4      	b.n	38f72 <__ieee754_sqrt+0xba>
   38f88:	f025 4200 	bic.w	r2, r5, #2147483648	; 0x80000000
   38f8c:	4322      	orrs	r2, r4
   38f8e:	d02c      	beq.n	38fea <__ieee754_sqrt+0x132>
   38f90:	2d00      	cmp	r5, #0
   38f92:	d141      	bne.n	39018 <__ieee754_sqrt+0x160>
   38f94:	0ac4      	lsrs	r4, r0, #11
   38f96:	3b15      	subs	r3, #21
   38f98:	0540      	lsls	r0, r0, #21
   38f9a:	4622      	mov	r2, r4
   38f9c:	2c00      	cmp	r4, #0
   38f9e:	d0f9      	beq.n	38f94 <__ieee754_sqrt+0xdc>
   38fa0:	02e5      	lsls	r5, r4, #11
   38fa2:	d44b      	bmi.n	3903c <__ieee754_sqrt+0x184>
   38fa4:	2100      	movs	r1, #0
   38fa6:	e000      	b.n	38faa <__ieee754_sqrt+0xf2>
   38fa8:	4629      	mov	r1, r5
   38faa:	0052      	lsls	r2, r2, #1
   38fac:	1c4d      	adds	r5, r1, #1
   38fae:	02d4      	lsls	r4, r2, #11
   38fb0:	d5fa      	bpl.n	38fa8 <__ieee754_sqrt+0xf0>
   38fb2:	4614      	mov	r4, r2
   38fb4:	4602      	mov	r2, r0
   38fb6:	40a8      	lsls	r0, r5
   38fb8:	f1c5 0520 	rsb	r5, r5, #32
   38fbc:	fa22 f505 	lsr.w	r5, r2, r5
   38fc0:	eba3 0e01 	sub.w	lr, r3, r1
   38fc4:	ea45 0304 	orr.w	r3, r5, r4
   38fc8:	e787      	b.n	38eda <__ieee754_sqrt+0x22>
   38fca:	4313      	orrs	r3, r2
   38fcc:	d10f      	bne.n	38fee <__ieee754_sqrt+0x136>
   38fce:	087e      	lsrs	r6, r7, #1
   38fd0:	491e      	ldr	r1, [pc, #120]	; (3904c <__ieee754_sqrt+0x194>)
   38fd2:	f01c 0f01 	tst.w	ip, #1
   38fd6:	eb01 016c 	add.w	r1, r1, ip, asr #1
   38fda:	bf18      	it	ne
   38fdc:	f046 4600 	orrne.w	r6, r6, #2147483648	; 0x80000000
   38fe0:	eb01 530e 	add.w	r3, r1, lr, lsl #20
   38fe4:	4632      	mov	r2, r6
   38fe6:	ec43 2b10 	vmov	d0, r2, r3
   38fea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   38fee:	1c7b      	adds	r3, r7, #1
   38ff0:	d021      	beq.n	39036 <__ieee754_sqrt+0x17e>
   38ff2:	1c7e      	adds	r6, r7, #1
   38ff4:	0876      	lsrs	r6, r6, #1
   38ff6:	e7eb      	b.n	38fd0 <__ieee754_sqrt+0x118>
   38ff8:	ee10 2a10 	vmov	r2, s0
   38ffc:	462b      	mov	r3, r5
   38ffe:	ee10 0a10 	vmov	r0, s0
   39002:	4629      	mov	r1, r5
   39004:	f7e3 fbd8 	bl	1c7b8 <__aeabi_dmul>
   39008:	4622      	mov	r2, r4
   3900a:	462b      	mov	r3, r5
   3900c:	f7e3 fa1e 	bl	1c44c <__adddf3>
   39010:	ec41 0b10 	vmov	d0, r0, r1
   39014:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   39018:	ee10 2a10 	vmov	r2, s0
   3901c:	4629      	mov	r1, r5
   3901e:	f7e3 fa13 	bl	1c448 <__aeabi_dsub>
   39022:	4602      	mov	r2, r0
   39024:	460b      	mov	r3, r1
   39026:	f7e3 fcf1 	bl	1ca0c <__aeabi_ddiv>
   3902a:	ec41 0b10 	vmov	d0, r0, r1
   3902e:	e7dc      	b.n	38fea <__ieee754_sqrt+0x132>
   39030:	462a      	mov	r2, r5
   39032:	4673      	mov	r3, lr
   39034:	e7b6      	b.n	38fa4 <__ieee754_sqrt+0xec>
   39036:	f10c 0c01 	add.w	ip, ip, #1
   3903a:	e7c9      	b.n	38fd0 <__ieee754_sqrt+0x118>
   3903c:	4602      	mov	r2, r0
   3903e:	2520      	movs	r5, #32
   39040:	f04f 31ff 	mov.w	r1, #4294967295
   39044:	e7ba      	b.n	38fbc <__ieee754_sqrt+0x104>
   39046:	bf00      	nop
   39048:	7ff00000 	.word	0x7ff00000
   3904c:	3fe00000 	.word	0x3fe00000

00039050 <finite>:
   39050:	ee10 3a90 	vmov	r3, s1
   39054:	4802      	ldr	r0, [pc, #8]	; (39060 <finite+0x10>)
   39056:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   3905a:	4418      	add	r0, r3
   3905c:	0fc0      	lsrs	r0, r0, #31
   3905e:	4770      	bx	lr
   39060:	80100000 	.word	0x80100000

00039064 <rint>:
   39064:	ec53 2b10 	vmov	r2, r3, d0
   39068:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   3906c:	f3c3 560a 	ubfx	r6, r3, #20, #11
   39070:	b083      	sub	sp, #12
   39072:	4619      	mov	r1, r3
   39074:	ee10 5a10 	vmov	r5, s0
   39078:	f2a6 30ff 	subw	r0, r6, #1023	; 0x3ff
   3907c:	0fdc      	lsrs	r4, r3, #31
   3907e:	2813      	cmp	r0, #19
   39080:	dc38      	bgt.n	390f4 <rint+0x90>
   39082:	2800      	cmp	r0, #0
   39084:	db2d      	blt.n	390e2 <rint+0x7e>
   39086:	4e3f      	ldr	r6, [pc, #252]	; (39184 <rint+0x120>)
   39088:	4106      	asrs	r6, r0
   3908a:	ea03 0706 	and.w	r7, r3, r6
   3908e:	4317      	orrs	r7, r2
   39090:	d02b      	beq.n	390ea <rint+0x86>
   39092:	0876      	lsrs	r6, r6, #1
   39094:	4033      	ands	r3, r6
   39096:	431d      	orrs	r5, r3
   39098:	d00b      	beq.n	390b2 <rint+0x4e>
   3909a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   3909e:	2813      	cmp	r0, #19
   390a0:	ea21 0606 	bic.w	r6, r1, r6
   390a4:	fa43 f100 	asr.w	r1, r3, r0
   390a8:	bf0c      	ite	eq
   390aa:	f04f 4500 	moveq.w	r5, #2147483648	; 0x80000000
   390ae:	2500      	movne	r5, #0
   390b0:	4331      	orrs	r1, r6
   390b2:	4835      	ldr	r0, [pc, #212]	; (39188 <rint+0x124>)
   390b4:	462a      	mov	r2, r5
   390b6:	460b      	mov	r3, r1
   390b8:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
   390bc:	e9d4 4500 	ldrd	r4, r5, [r4]
   390c0:	4620      	mov	r0, r4
   390c2:	4629      	mov	r1, r5
   390c4:	f7e3 f9c2 	bl	1c44c <__adddf3>
   390c8:	4622      	mov	r2, r4
   390ca:	462b      	mov	r3, r5
   390cc:	e9cd 0100 	strd	r0, r1, [sp]
   390d0:	e9dd 0100 	ldrd	r0, r1, [sp]
   390d4:	f7e3 f9b8 	bl	1c448 <__aeabi_dsub>
   390d8:	ec41 0b10 	vmov	d0, r0, r1
   390dc:	b003      	add	sp, #12
   390de:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   390e2:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
   390e6:	4310      	orrs	r0, r2
   390e8:	d123      	bne.n	39132 <rint+0xce>
   390ea:	ec43 2b10 	vmov	d0, r2, r3
   390ee:	b003      	add	sp, #12
   390f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   390f4:	2833      	cmp	r0, #51	; 0x33
   390f6:	dd09      	ble.n	3910c <rint+0xa8>
   390f8:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
   390fc:	d1f5      	bne.n	390ea <rint+0x86>
   390fe:	ee10 0a10 	vmov	r0, s0
   39102:	f7e3 f9a3 	bl	1c44c <__adddf3>
   39106:	ec41 0b10 	vmov	d0, r0, r1
   3910a:	e7f0      	b.n	390ee <rint+0x8a>
   3910c:	f2a6 4613 	subw	r6, r6, #1043	; 0x413
   39110:	f04f 30ff 	mov.w	r0, #4294967295
   39114:	40f0      	lsrs	r0, r6
   39116:	4202      	tst	r2, r0
   39118:	d0e7      	beq.n	390ea <rint+0x86>
   3911a:	0840      	lsrs	r0, r0, #1
   3911c:	4202      	tst	r2, r0
   3911e:	d0c8      	beq.n	390b2 <rint+0x4e>
   39120:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   39124:	ea25 0000 	bic.w	r0, r5, r0
   39128:	fa43 f606 	asr.w	r6, r3, r6
   3912c:	ea40 0506 	orr.w	r5, r0, r6
   39130:	e7bf      	b.n	390b2 <rint+0x4e>
   39132:	f3c3 0613 	ubfx	r6, r3, #0, #20
   39136:	4815      	ldr	r0, [pc, #84]	; (3918c <rint+0x128>)
   39138:	4a13      	ldr	r2, [pc, #76]	; (39188 <rint+0x124>)
   3913a:	4335      	orrs	r5, r6
   3913c:	4018      	ands	r0, r3
   3913e:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
   39142:	426b      	negs	r3, r5
   39144:	432b      	orrs	r3, r5
   39146:	0b1b      	lsrs	r3, r3, #12
   39148:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
   3914c:	e9d2 6700 	ldrd	r6, r7, [r2]
   39150:	ea43 0900 	orr.w	r9, r3, r0
   39154:	ee10 2a10 	vmov	r2, s0
   39158:	4630      	mov	r0, r6
   3915a:	4639      	mov	r1, r7
   3915c:	464b      	mov	r3, r9
   3915e:	f7e3 f975 	bl	1c44c <__adddf3>
   39162:	463b      	mov	r3, r7
   39164:	4632      	mov	r2, r6
   39166:	e9cd 0100 	strd	r0, r1, [sp]
   3916a:	e9dd 0100 	ldrd	r0, r1, [sp]
   3916e:	f7e3 f96b 	bl	1c448 <__aeabi_dsub>
   39172:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   39176:	ea43 71c4 	orr.w	r1, r3, r4, lsl #31
   3917a:	ec41 0b10 	vmov	d0, r0, r1
   3917e:	b003      	add	sp, #12
   39180:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   39184:	000fffff 	.word	0x000fffff
   39188:	0003fbe8 	.word	0x0003fbe8
   3918c:	fffe0000 	.word	0xfffe0000

00039190 <__assert_func>:
   39190:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   39192:	461c      	mov	r4, r3
   39194:	4b09      	ldr	r3, [pc, #36]	; (391bc <__assert_func+0x2c>)
   39196:	4605      	mov	r5, r0
   39198:	681b      	ldr	r3, [r3, #0]
   3919a:	68d8      	ldr	r0, [r3, #12]
   3919c:	b152      	cbz	r2, 391b4 <__assert_func+0x24>
   3919e:	4b08      	ldr	r3, [pc, #32]	; (391c0 <__assert_func+0x30>)
   391a0:	9100      	str	r1, [sp, #0]
   391a2:	4908      	ldr	r1, [pc, #32]	; (391c4 <__assert_func+0x34>)
   391a4:	e9cd 3201 	strd	r3, r2, [sp, #4]
   391a8:	462b      	mov	r3, r5
   391aa:	4622      	mov	r2, r4
   391ac:	f000 f80e 	bl	391cc <fiprintf>
   391b0:	f005 fd45 	bl	3ec3e <abort>
   391b4:	4b04      	ldr	r3, [pc, #16]	; (391c8 <__assert_func+0x38>)
   391b6:	461a      	mov	r2, r3
   391b8:	e7f2      	b.n	391a0 <__assert_func+0x10>
   391ba:	bf00      	nop
   391bc:	20034708 	.word	0x20034708
   391c0:	000442ea 	.word	0x000442ea
   391c4:	000442f7 	.word	0x000442f7
   391c8:	00042744 	.word	0x00042744

000391cc <fiprintf>:
   391cc:	b40e      	push	{r1, r2, r3}
   391ce:	b503      	push	{r0, r1, lr}
   391d0:	ab03      	add	r3, sp, #12
   391d2:	4601      	mov	r1, r0
   391d4:	4805      	ldr	r0, [pc, #20]	; (391ec <fiprintf+0x20>)
   391d6:	f853 2b04 	ldr.w	r2, [r3], #4
   391da:	6800      	ldr	r0, [r0, #0]
   391dc:	9301      	str	r3, [sp, #4]
   391de:	f000 f807 	bl	391f0 <_vfiprintf_r>
   391e2:	b002      	add	sp, #8
   391e4:	f85d eb04 	ldr.w	lr, [sp], #4
   391e8:	b003      	add	sp, #12
   391ea:	4770      	bx	lr
   391ec:	20034708 	.word	0x20034708

000391f0 <_vfiprintf_r>:
   391f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   391f4:	460d      	mov	r5, r1
   391f6:	b09d      	sub	sp, #116	; 0x74
   391f8:	4614      	mov	r4, r2
   391fa:	461e      	mov	r6, r3
   391fc:	4607      	mov	r7, r0
   391fe:	b118      	cbz	r0, 39208 <_vfiprintf_r+0x18>
   39200:	6983      	ldr	r3, [r0, #24]
   39202:	b90b      	cbnz	r3, 39208 <_vfiprintf_r+0x18>
   39204:	f000 ffc2 	bl	3a18c <__sinit>
   39208:	4b85      	ldr	r3, [pc, #532]	; (39420 <_vfiprintf_r+0x230>)
   3920a:	429d      	cmp	r5, r3
   3920c:	d11b      	bne.n	39246 <_vfiprintf_r+0x56>
   3920e:	687d      	ldr	r5, [r7, #4]
   39210:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   39212:	07d9      	lsls	r1, r3, #31
   39214:	d405      	bmi.n	39222 <_vfiprintf_r+0x32>
   39216:	89ab      	ldrh	r3, [r5, #12]
   39218:	059a      	lsls	r2, r3, #22
   3921a:	d402      	bmi.n	39222 <_vfiprintf_r+0x32>
   3921c:	6da8      	ldr	r0, [r5, #88]	; 0x58
   3921e:	f005 fdd8 	bl	3edd2 <__retarget_lock_acquire_recursive>
   39222:	89ab      	ldrh	r3, [r5, #12]
   39224:	071b      	lsls	r3, r3, #28
   39226:	d501      	bpl.n	3922c <_vfiprintf_r+0x3c>
   39228:	692b      	ldr	r3, [r5, #16]
   3922a:	b9eb      	cbnz	r3, 39268 <_vfiprintf_r+0x78>
   3922c:	4629      	mov	r1, r5
   3922e:	4638      	mov	r0, r7
   39230:	f000 fe18 	bl	39e64 <__swsetup_r>
   39234:	b1c0      	cbz	r0, 39268 <_vfiprintf_r+0x78>
   39236:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   39238:	07d8      	lsls	r0, r3, #31
   3923a:	d50e      	bpl.n	3925a <_vfiprintf_r+0x6a>
   3923c:	f04f 30ff 	mov.w	r0, #4294967295
   39240:	b01d      	add	sp, #116	; 0x74
   39242:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   39246:	4b77      	ldr	r3, [pc, #476]	; (39424 <_vfiprintf_r+0x234>)
   39248:	429d      	cmp	r5, r3
   3924a:	d101      	bne.n	39250 <_vfiprintf_r+0x60>
   3924c:	68bd      	ldr	r5, [r7, #8]
   3924e:	e7df      	b.n	39210 <_vfiprintf_r+0x20>
   39250:	4b75      	ldr	r3, [pc, #468]	; (39428 <_vfiprintf_r+0x238>)
   39252:	429d      	cmp	r5, r3
   39254:	bf08      	it	eq
   39256:	68fd      	ldreq	r5, [r7, #12]
   39258:	e7da      	b.n	39210 <_vfiprintf_r+0x20>
   3925a:	89ab      	ldrh	r3, [r5, #12]
   3925c:	0599      	lsls	r1, r3, #22
   3925e:	d4ed      	bmi.n	3923c <_vfiprintf_r+0x4c>
   39260:	6da8      	ldr	r0, [r5, #88]	; 0x58
   39262:	f005 fdb7 	bl	3edd4 <__retarget_lock_release_recursive>
   39266:	e7e9      	b.n	3923c <_vfiprintf_r+0x4c>
   39268:	2300      	movs	r3, #0
   3926a:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 3942c <_vfiprintf_r+0x23c>
   3926e:	f04f 0a01 	mov.w	sl, #1
   39272:	9603      	str	r6, [sp, #12]
   39274:	9309      	str	r3, [sp, #36]	; 0x24
   39276:	2320      	movs	r3, #32
   39278:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   3927c:	2330      	movs	r3, #48	; 0x30
   3927e:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   39282:	4623      	mov	r3, r4
   39284:	461e      	mov	r6, r3
   39286:	f813 2b01 	ldrb.w	r2, [r3], #1
   3928a:	b10a      	cbz	r2, 39290 <_vfiprintf_r+0xa0>
   3928c:	2a25      	cmp	r2, #37	; 0x25
   3928e:	d1f9      	bne.n	39284 <_vfiprintf_r+0x94>
   39290:	ebb6 0b04 	subs.w	fp, r6, r4
   39294:	d00b      	beq.n	392ae <_vfiprintf_r+0xbe>
   39296:	465b      	mov	r3, fp
   39298:	4622      	mov	r2, r4
   3929a:	4629      	mov	r1, r5
   3929c:	4638      	mov	r0, r7
   3929e:	f005 fb1d 	bl	3e8dc <__sfputs_r>
   392a2:	3001      	adds	r0, #1
   392a4:	f000 80a3 	beq.w	393ee <_vfiprintf_r+0x1fe>
   392a8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   392aa:	445b      	add	r3, fp
   392ac:	9309      	str	r3, [sp, #36]	; 0x24
   392ae:	7833      	ldrb	r3, [r6, #0]
   392b0:	2b00      	cmp	r3, #0
   392b2:	f000 809c 	beq.w	393ee <_vfiprintf_r+0x1fe>
   392b6:	2300      	movs	r3, #0
   392b8:	f04f 32ff 	mov.w	r2, #4294967295
   392bc:	3601      	adds	r6, #1
   392be:	9304      	str	r3, [sp, #16]
   392c0:	9307      	str	r3, [sp, #28]
   392c2:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   392c6:	931a      	str	r3, [sp, #104]	; 0x68
   392c8:	e9cd 2305 	strd	r2, r3, [sp, #20]
   392cc:	4634      	mov	r4, r6
   392ce:	2205      	movs	r2, #5
   392d0:	4856      	ldr	r0, [pc, #344]	; (3942c <_vfiprintf_r+0x23c>)
   392d2:	f814 1b01 	ldrb.w	r1, [r4], #1
   392d6:	f005 fa9d 	bl	3e814 <memchr>
   392da:	9b04      	ldr	r3, [sp, #16]
   392dc:	b9c0      	cbnz	r0, 39310 <_vfiprintf_r+0x120>
   392de:	06da      	lsls	r2, r3, #27
   392e0:	bf44      	itt	mi
   392e2:	2220      	movmi	r2, #32
   392e4:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   392e8:	0718      	lsls	r0, r3, #28
   392ea:	bf44      	itt	mi
   392ec:	222b      	movmi	r2, #43	; 0x2b
   392ee:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   392f2:	7832      	ldrb	r2, [r6, #0]
   392f4:	2a2a      	cmp	r2, #42	; 0x2a
   392f6:	d013      	beq.n	39320 <_vfiprintf_r+0x130>
   392f8:	4634      	mov	r4, r6
   392fa:	9a07      	ldr	r2, [sp, #28]
   392fc:	2000      	movs	r0, #0
   392fe:	260a      	movs	r6, #10
   39300:	4621      	mov	r1, r4
   39302:	f811 3b01 	ldrb.w	r3, [r1], #1
   39306:	3b30      	subs	r3, #48	; 0x30
   39308:	2b09      	cmp	r3, #9
   3930a:	d94b      	bls.n	393a4 <_vfiprintf_r+0x1b4>
   3930c:	b970      	cbnz	r0, 3932c <_vfiprintf_r+0x13c>
   3930e:	e014      	b.n	3933a <_vfiprintf_r+0x14a>
   39310:	eba0 0009 	sub.w	r0, r0, r9
   39314:	4626      	mov	r6, r4
   39316:	fa0a f000 	lsl.w	r0, sl, r0
   3931a:	4318      	orrs	r0, r3
   3931c:	9004      	str	r0, [sp, #16]
   3931e:	e7d5      	b.n	392cc <_vfiprintf_r+0xdc>
   39320:	9a03      	ldr	r2, [sp, #12]
   39322:	1d11      	adds	r1, r2, #4
   39324:	6812      	ldr	r2, [r2, #0]
   39326:	2a00      	cmp	r2, #0
   39328:	9103      	str	r1, [sp, #12]
   3932a:	db01      	blt.n	39330 <_vfiprintf_r+0x140>
   3932c:	9207      	str	r2, [sp, #28]
   3932e:	e004      	b.n	3933a <_vfiprintf_r+0x14a>
   39330:	4252      	negs	r2, r2
   39332:	f043 0302 	orr.w	r3, r3, #2
   39336:	9207      	str	r2, [sp, #28]
   39338:	9304      	str	r3, [sp, #16]
   3933a:	7823      	ldrb	r3, [r4, #0]
   3933c:	2b2e      	cmp	r3, #46	; 0x2e
   3933e:	d10c      	bne.n	3935a <_vfiprintf_r+0x16a>
   39340:	7863      	ldrb	r3, [r4, #1]
   39342:	2b2a      	cmp	r3, #42	; 0x2a
   39344:	d133      	bne.n	393ae <_vfiprintf_r+0x1be>
   39346:	9b03      	ldr	r3, [sp, #12]
   39348:	3402      	adds	r4, #2
   3934a:	1d1a      	adds	r2, r3, #4
   3934c:	681b      	ldr	r3, [r3, #0]
   3934e:	2b00      	cmp	r3, #0
   39350:	9203      	str	r2, [sp, #12]
   39352:	bfb8      	it	lt
   39354:	f04f 33ff 	movlt.w	r3, #4294967295
   39358:	9305      	str	r3, [sp, #20]
   3935a:	4e35      	ldr	r6, [pc, #212]	; (39430 <_vfiprintf_r+0x240>)
   3935c:	2203      	movs	r2, #3
   3935e:	7821      	ldrb	r1, [r4, #0]
   39360:	4630      	mov	r0, r6
   39362:	f005 fa57 	bl	3e814 <memchr>
   39366:	b138      	cbz	r0, 39378 <_vfiprintf_r+0x188>
   39368:	2340      	movs	r3, #64	; 0x40
   3936a:	1b80      	subs	r0, r0, r6
   3936c:	3401      	adds	r4, #1
   3936e:	fa03 f000 	lsl.w	r0, r3, r0
   39372:	9b04      	ldr	r3, [sp, #16]
   39374:	4303      	orrs	r3, r0
   39376:	9304      	str	r3, [sp, #16]
   39378:	f814 1b01 	ldrb.w	r1, [r4], #1
   3937c:	2206      	movs	r2, #6
   3937e:	482d      	ldr	r0, [pc, #180]	; (39434 <_vfiprintf_r+0x244>)
   39380:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   39384:	f005 fa46 	bl	3e814 <memchr>
   39388:	2800      	cmp	r0, #0
   3938a:	d03f      	beq.n	3940c <_vfiprintf_r+0x21c>
   3938c:	4b2a      	ldr	r3, [pc, #168]	; (39438 <_vfiprintf_r+0x248>)
   3938e:	bb13      	cbnz	r3, 393d6 <_vfiprintf_r+0x1e6>
   39390:	9b03      	ldr	r3, [sp, #12]
   39392:	3307      	adds	r3, #7
   39394:	f023 0307 	bic.w	r3, r3, #7
   39398:	3308      	adds	r3, #8
   3939a:	9303      	str	r3, [sp, #12]
   3939c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   3939e:	4443      	add	r3, r8
   393a0:	9309      	str	r3, [sp, #36]	; 0x24
   393a2:	e76e      	b.n	39282 <_vfiprintf_r+0x92>
   393a4:	fb06 3202 	mla	r2, r6, r2, r3
   393a8:	2001      	movs	r0, #1
   393aa:	460c      	mov	r4, r1
   393ac:	e7a8      	b.n	39300 <_vfiprintf_r+0x110>
   393ae:	2300      	movs	r3, #0
   393b0:	3401      	adds	r4, #1
   393b2:	260a      	movs	r6, #10
   393b4:	4619      	mov	r1, r3
   393b6:	9305      	str	r3, [sp, #20]
   393b8:	4620      	mov	r0, r4
   393ba:	f810 2b01 	ldrb.w	r2, [r0], #1
   393be:	3a30      	subs	r2, #48	; 0x30
   393c0:	2a09      	cmp	r2, #9
   393c2:	d903      	bls.n	393cc <_vfiprintf_r+0x1dc>
   393c4:	2b00      	cmp	r3, #0
   393c6:	d0c8      	beq.n	3935a <_vfiprintf_r+0x16a>
   393c8:	9105      	str	r1, [sp, #20]
   393ca:	e7c6      	b.n	3935a <_vfiprintf_r+0x16a>
   393cc:	fb06 2101 	mla	r1, r6, r1, r2
   393d0:	2301      	movs	r3, #1
   393d2:	4604      	mov	r4, r0
   393d4:	e7f0      	b.n	393b8 <_vfiprintf_r+0x1c8>
   393d6:	ab03      	add	r3, sp, #12
   393d8:	462a      	mov	r2, r5
   393da:	a904      	add	r1, sp, #16
   393dc:	4638      	mov	r0, r7
   393de:	9300      	str	r3, [sp, #0]
   393e0:	4b16      	ldr	r3, [pc, #88]	; (3943c <_vfiprintf_r+0x24c>)
   393e2:	f000 f82d 	bl	39440 <_printf_float>
   393e6:	f1b0 3fff 	cmp.w	r0, #4294967295
   393ea:	4680      	mov	r8, r0
   393ec:	d1d6      	bne.n	3939c <_vfiprintf_r+0x1ac>
   393ee:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   393f0:	07d9      	lsls	r1, r3, #31
   393f2:	d405      	bmi.n	39400 <_vfiprintf_r+0x210>
   393f4:	89ab      	ldrh	r3, [r5, #12]
   393f6:	059a      	lsls	r2, r3, #22
   393f8:	d402      	bmi.n	39400 <_vfiprintf_r+0x210>
   393fa:	6da8      	ldr	r0, [r5, #88]	; 0x58
   393fc:	f005 fcea 	bl	3edd4 <__retarget_lock_release_recursive>
   39400:	89ab      	ldrh	r3, [r5, #12]
   39402:	065b      	lsls	r3, r3, #25
   39404:	f53f af1a 	bmi.w	3923c <_vfiprintf_r+0x4c>
   39408:	9809      	ldr	r0, [sp, #36]	; 0x24
   3940a:	e719      	b.n	39240 <_vfiprintf_r+0x50>
   3940c:	ab03      	add	r3, sp, #12
   3940e:	462a      	mov	r2, r5
   39410:	a904      	add	r1, sp, #16
   39412:	4638      	mov	r0, r7
   39414:	9300      	str	r3, [sp, #0]
   39416:	4b09      	ldr	r3, [pc, #36]	; (3943c <_vfiprintf_r+0x24c>)
   39418:	f000 fa3c 	bl	39894 <_printf_i>
   3941c:	e7e3      	b.n	393e6 <_vfiprintf_r+0x1f6>
   3941e:	bf00      	nop
   39420:	000403a0 	.word	0x000403a0
   39424:	000403c0 	.word	0x000403c0
   39428:	00040380 	.word	0x00040380
   3942c:	00044427 	.word	0x00044427
   39430:	0004442d 	.word	0x0004442d
   39434:	00044431 	.word	0x00044431
   39438:	00039441 	.word	0x00039441
   3943c:	0003e8dd 	.word	0x0003e8dd

00039440 <_printf_float>:
   39440:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   39444:	b08d      	sub	sp, #52	; 0x34
   39446:	460c      	mov	r4, r1
   39448:	4616      	mov	r6, r2
   3944a:	461f      	mov	r7, r3
   3944c:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
   39450:	4605      	mov	r5, r0
   39452:	f000 ff19 	bl	3a288 <_localeconv_r>
   39456:	6803      	ldr	r3, [r0, #0]
   39458:	4618      	mov	r0, r3
   3945a:	9306      	str	r3, [sp, #24]
   3945c:	f7e3 fe7c 	bl	1d158 <strlen>
   39460:	2300      	movs	r3, #0
   39462:	9007      	str	r0, [sp, #28]
   39464:	930a      	str	r3, [sp, #40]	; 0x28
   39466:	f8d8 3000 	ldr.w	r3, [r8]
   3946a:	f894 a018 	ldrb.w	sl, [r4, #24]
   3946e:	3307      	adds	r3, #7
   39470:	f8d4 b000 	ldr.w	fp, [r4]
   39474:	f023 0307 	bic.w	r3, r3, #7
   39478:	f103 0208 	add.w	r2, r3, #8
   3947c:	f8c8 2000 	str.w	r2, [r8]
   39480:	e9d3 2300 	ldrd	r2, r3, [r3]
   39484:	e9c4 2312 	strd	r2, r3, [r4, #72]	; 0x48
   39488:	ed94 7b12 	vldr	d7, [r4, #72]	; 0x48
   3948c:	f04f 32ff 	mov.w	r2, #4294967295
   39490:	ed8d 7b04 	vstr	d7, [sp, #16]
   39494:	e9dd 8304 	ldrd	r8, r3, [sp, #16]
   39498:	f023 4900 	bic.w	r9, r3, #2147483648	; 0x80000000
   3949c:	4640      	mov	r0, r8
   3949e:	4ba6      	ldr	r3, [pc, #664]	; (39738 <_printf_float+0x2f8>)
   394a0:	4649      	mov	r1, r9
   394a2:	f7e3 fe11 	bl	1d0c8 <__aeabi_dcmpun>
   394a6:	bb70      	cbnz	r0, 39506 <_printf_float+0xc6>
   394a8:	f04f 32ff 	mov.w	r2, #4294967295
   394ac:	4ba2      	ldr	r3, [pc, #648]	; (39738 <_printf_float+0x2f8>)
   394ae:	4640      	mov	r0, r8
   394b0:	4649      	mov	r1, r9
   394b2:	f7e3 fbfd 	bl	1ccb0 <__aeabi_dcmple>
   394b6:	bb30      	cbnz	r0, 39506 <_printf_float+0xc6>
   394b8:	2200      	movs	r2, #0
   394ba:	2300      	movs	r3, #0
   394bc:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   394c0:	f7e3 fbec 	bl	1cc9c <__aeabi_dcmplt>
   394c4:	b110      	cbz	r0, 394cc <_printf_float+0x8c>
   394c6:	232d      	movs	r3, #45	; 0x2d
   394c8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   394cc:	4a9b      	ldr	r2, [pc, #620]	; (3973c <_printf_float+0x2fc>)
   394ce:	4b9c      	ldr	r3, [pc, #624]	; (39740 <_printf_float+0x300>)
   394d0:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
   394d4:	bf94      	ite	ls
   394d6:	4690      	movls	r8, r2
   394d8:	4698      	movhi	r8, r3
   394da:	f04f 0900 	mov.w	r9, #0
   394de:	2303      	movs	r3, #3
   394e0:	f02b 0204 	bic.w	r2, fp, #4
   394e4:	6123      	str	r3, [r4, #16]
   394e6:	6022      	str	r2, [r4, #0]
   394e8:	9700      	str	r7, [sp, #0]
   394ea:	4633      	mov	r3, r6
   394ec:	aa0b      	add	r2, sp, #44	; 0x2c
   394ee:	4621      	mov	r1, r4
   394f0:	4628      	mov	r0, r5
   394f2:	f005 fa95 	bl	3ea20 <_printf_common>
   394f6:	3001      	adds	r0, #1
   394f8:	f040 808c 	bne.w	39614 <_printf_float+0x1d4>
   394fc:	f04f 30ff 	mov.w	r0, #4294967295
   39500:	b00d      	add	sp, #52	; 0x34
   39502:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   39506:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   3950a:	4610      	mov	r0, r2
   3950c:	4619      	mov	r1, r3
   3950e:	f7e3 fddb 	bl	1d0c8 <__aeabi_dcmpun>
   39512:	b140      	cbz	r0, 39526 <_printf_float+0xe6>
   39514:	9b05      	ldr	r3, [sp, #20]
   39516:	4a8b      	ldr	r2, [pc, #556]	; (39744 <_printf_float+0x304>)
   39518:	2b00      	cmp	r3, #0
   3951a:	bfbc      	itt	lt
   3951c:	232d      	movlt	r3, #45	; 0x2d
   3951e:	f884 3043 	strblt.w	r3, [r4, #67]	; 0x43
   39522:	4b89      	ldr	r3, [pc, #548]	; (39748 <_printf_float+0x308>)
   39524:	e7d4      	b.n	394d0 <_printf_float+0x90>
   39526:	6863      	ldr	r3, [r4, #4]
   39528:	f00a 09df 	and.w	r9, sl, #223	; 0xdf
   3952c:	1c5a      	adds	r2, r3, #1
   3952e:	d13e      	bne.n	395ae <_printf_float+0x16e>
   39530:	2306      	movs	r3, #6
   39532:	6063      	str	r3, [r4, #4]
   39534:	2300      	movs	r3, #0
   39536:	f44b 6280 	orr.w	r2, fp, #1024	; 0x400
   3953a:	6861      	ldr	r1, [r4, #4]
   3953c:	4628      	mov	r0, r5
   3953e:	9303      	str	r3, [sp, #12]
   39540:	ab0a      	add	r3, sp, #40	; 0x28
   39542:	6022      	str	r2, [r4, #0]
   39544:	e9cd a301 	strd	sl, r3, [sp, #4]
   39548:	ab09      	add	r3, sp, #36	; 0x24
   3954a:	ed9d 0b04 	vldr	d0, [sp, #16]
   3954e:	9300      	str	r3, [sp, #0]
   39550:	f10d 0323 	add.w	r3, sp, #35	; 0x23
   39554:	f005 f9d4 	bl	3e900 <__cvt>
   39558:	f1b9 0f47 	cmp.w	r9, #71	; 0x47
   3955c:	4680      	mov	r8, r0
   3955e:	9909      	ldr	r1, [sp, #36]	; 0x24
   39560:	d108      	bne.n	39574 <_printf_float+0x134>
   39562:	1cc8      	adds	r0, r1, #3
   39564:	db02      	blt.n	3956c <_printf_float+0x12c>
   39566:	6863      	ldr	r3, [r4, #4]
   39568:	4299      	cmp	r1, r3
   3956a:	dd41      	ble.n	395f0 <_printf_float+0x1b0>
   3956c:	f1aa 0a02 	sub.w	sl, sl, #2
   39570:	fa5f fa8a 	uxtb.w	sl, sl
   39574:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
   39578:	d820      	bhi.n	395bc <_printf_float+0x17c>
   3957a:	3901      	subs	r1, #1
   3957c:	4652      	mov	r2, sl
   3957e:	f104 0050 	add.w	r0, r4, #80	; 0x50
   39582:	9109      	str	r1, [sp, #36]	; 0x24
   39584:	f005 fa19 	bl	3e9ba <__exponent>
   39588:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   3958a:	4681      	mov	r9, r0
   3958c:	1813      	adds	r3, r2, r0
   3958e:	2a01      	cmp	r2, #1
   39590:	6123      	str	r3, [r4, #16]
   39592:	dc02      	bgt.n	3959a <_printf_float+0x15a>
   39594:	6822      	ldr	r2, [r4, #0]
   39596:	07d2      	lsls	r2, r2, #31
   39598:	d501      	bpl.n	3959e <_printf_float+0x15e>
   3959a:	3301      	adds	r3, #1
   3959c:	6123      	str	r3, [r4, #16]
   3959e:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
   395a2:	2b00      	cmp	r3, #0
   395a4:	d0a0      	beq.n	394e8 <_printf_float+0xa8>
   395a6:	232d      	movs	r3, #45	; 0x2d
   395a8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   395ac:	e79c      	b.n	394e8 <_printf_float+0xa8>
   395ae:	f1b9 0f47 	cmp.w	r9, #71	; 0x47
   395b2:	d1bf      	bne.n	39534 <_printf_float+0xf4>
   395b4:	2b00      	cmp	r3, #0
   395b6:	d1bd      	bne.n	39534 <_printf_float+0xf4>
   395b8:	2301      	movs	r3, #1
   395ba:	e7ba      	b.n	39532 <_printf_float+0xf2>
   395bc:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
   395c0:	d118      	bne.n	395f4 <_printf_float+0x1b4>
   395c2:	2900      	cmp	r1, #0
   395c4:	6863      	ldr	r3, [r4, #4]
   395c6:	dd0b      	ble.n	395e0 <_printf_float+0x1a0>
   395c8:	6121      	str	r1, [r4, #16]
   395ca:	b913      	cbnz	r3, 395d2 <_printf_float+0x192>
   395cc:	6822      	ldr	r2, [r4, #0]
   395ce:	07d0      	lsls	r0, r2, #31
   395d0:	d502      	bpl.n	395d8 <_printf_float+0x198>
   395d2:	3301      	adds	r3, #1
   395d4:	440b      	add	r3, r1
   395d6:	6123      	str	r3, [r4, #16]
   395d8:	65a1      	str	r1, [r4, #88]	; 0x58
   395da:	f04f 0900 	mov.w	r9, #0
   395de:	e7de      	b.n	3959e <_printf_float+0x15e>
   395e0:	b913      	cbnz	r3, 395e8 <_printf_float+0x1a8>
   395e2:	6822      	ldr	r2, [r4, #0]
   395e4:	07d2      	lsls	r2, r2, #31
   395e6:	d501      	bpl.n	395ec <_printf_float+0x1ac>
   395e8:	3302      	adds	r3, #2
   395ea:	e7f4      	b.n	395d6 <_printf_float+0x196>
   395ec:	2301      	movs	r3, #1
   395ee:	e7f2      	b.n	395d6 <_printf_float+0x196>
   395f0:	f04f 0a67 	mov.w	sl, #103	; 0x67
   395f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   395f6:	4299      	cmp	r1, r3
   395f8:	db05      	blt.n	39606 <_printf_float+0x1c6>
   395fa:	6823      	ldr	r3, [r4, #0]
   395fc:	6121      	str	r1, [r4, #16]
   395fe:	07d8      	lsls	r0, r3, #31
   39600:	d5ea      	bpl.n	395d8 <_printf_float+0x198>
   39602:	1c4b      	adds	r3, r1, #1
   39604:	e7e7      	b.n	395d6 <_printf_float+0x196>
   39606:	2900      	cmp	r1, #0
   39608:	bfd4      	ite	le
   3960a:	f1c1 0202 	rsble	r2, r1, #2
   3960e:	2201      	movgt	r2, #1
   39610:	4413      	add	r3, r2
   39612:	e7e0      	b.n	395d6 <_printf_float+0x196>
   39614:	6823      	ldr	r3, [r4, #0]
   39616:	055a      	lsls	r2, r3, #21
   39618:	d407      	bmi.n	3962a <_printf_float+0x1ea>
   3961a:	6923      	ldr	r3, [r4, #16]
   3961c:	4642      	mov	r2, r8
   3961e:	4631      	mov	r1, r6
   39620:	4628      	mov	r0, r5
   39622:	47b8      	blx	r7
   39624:	3001      	adds	r0, #1
   39626:	d12b      	bne.n	39680 <_printf_float+0x240>
   39628:	e768      	b.n	394fc <_printf_float+0xbc>
   3962a:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
   3962e:	f240 80dc 	bls.w	397ea <_printf_float+0x3aa>
   39632:	2200      	movs	r2, #0
   39634:	2300      	movs	r3, #0
   39636:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
   3963a:	f7e3 fb25 	bl	1cc88 <__aeabi_dcmpeq>
   3963e:	2800      	cmp	r0, #0
   39640:	d033      	beq.n	396aa <_printf_float+0x26a>
   39642:	2301      	movs	r3, #1
   39644:	4a41      	ldr	r2, [pc, #260]	; (3974c <_printf_float+0x30c>)
   39646:	4631      	mov	r1, r6
   39648:	4628      	mov	r0, r5
   3964a:	47b8      	blx	r7
   3964c:	3001      	adds	r0, #1
   3964e:	f43f af55 	beq.w	394fc <_printf_float+0xbc>
   39652:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   39656:	429a      	cmp	r2, r3
   39658:	db02      	blt.n	39660 <_printf_float+0x220>
   3965a:	6823      	ldr	r3, [r4, #0]
   3965c:	07d8      	lsls	r0, r3, #31
   3965e:	d50f      	bpl.n	39680 <_printf_float+0x240>
   39660:	4631      	mov	r1, r6
   39662:	4628      	mov	r0, r5
   39664:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   39668:	47b8      	blx	r7
   3966a:	3001      	adds	r0, #1
   3966c:	f43f af46 	beq.w	394fc <_printf_float+0xbc>
   39670:	f04f 0800 	mov.w	r8, #0
   39674:	f104 091a 	add.w	r9, r4, #26
   39678:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   3967a:	3b01      	subs	r3, #1
   3967c:	4543      	cmp	r3, r8
   3967e:	dc09      	bgt.n	39694 <_printf_float+0x254>
   39680:	6823      	ldr	r3, [r4, #0]
   39682:	079b      	lsls	r3, r3, #30
   39684:	f100 8101 	bmi.w	3988a <_printf_float+0x44a>
   39688:	68e0      	ldr	r0, [r4, #12]
   3968a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   3968c:	4298      	cmp	r0, r3
   3968e:	bfb8      	it	lt
   39690:	4618      	movlt	r0, r3
   39692:	e735      	b.n	39500 <_printf_float+0xc0>
   39694:	2301      	movs	r3, #1
   39696:	464a      	mov	r2, r9
   39698:	4631      	mov	r1, r6
   3969a:	4628      	mov	r0, r5
   3969c:	47b8      	blx	r7
   3969e:	3001      	adds	r0, #1
   396a0:	f43f af2c 	beq.w	394fc <_printf_float+0xbc>
   396a4:	f108 0801 	add.w	r8, r8, #1
   396a8:	e7e6      	b.n	39678 <_printf_float+0x238>
   396aa:	9b09      	ldr	r3, [sp, #36]	; 0x24
   396ac:	2b00      	cmp	r3, #0
   396ae:	dc2b      	bgt.n	39708 <_printf_float+0x2c8>
   396b0:	2301      	movs	r3, #1
   396b2:	4a26      	ldr	r2, [pc, #152]	; (3974c <_printf_float+0x30c>)
   396b4:	4631      	mov	r1, r6
   396b6:	4628      	mov	r0, r5
   396b8:	47b8      	blx	r7
   396ba:	3001      	adds	r0, #1
   396bc:	f43f af1e 	beq.w	394fc <_printf_float+0xbc>
   396c0:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   396c4:	4313      	orrs	r3, r2
   396c6:	d102      	bne.n	396ce <_printf_float+0x28e>
   396c8:	6823      	ldr	r3, [r4, #0]
   396ca:	07d9      	lsls	r1, r3, #31
   396cc:	d5d8      	bpl.n	39680 <_printf_float+0x240>
   396ce:	4631      	mov	r1, r6
   396d0:	4628      	mov	r0, r5
   396d2:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   396d6:	47b8      	blx	r7
   396d8:	3001      	adds	r0, #1
   396da:	f43f af0f 	beq.w	394fc <_printf_float+0xbc>
   396de:	f04f 0900 	mov.w	r9, #0
   396e2:	f104 0a1a 	add.w	sl, r4, #26
   396e6:	9b09      	ldr	r3, [sp, #36]	; 0x24
   396e8:	425b      	negs	r3, r3
   396ea:	454b      	cmp	r3, r9
   396ec:	dc01      	bgt.n	396f2 <_printf_float+0x2b2>
   396ee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   396f0:	e794      	b.n	3961c <_printf_float+0x1dc>
   396f2:	2301      	movs	r3, #1
   396f4:	4652      	mov	r2, sl
   396f6:	4631      	mov	r1, r6
   396f8:	4628      	mov	r0, r5
   396fa:	47b8      	blx	r7
   396fc:	3001      	adds	r0, #1
   396fe:	f43f aefd 	beq.w	394fc <_printf_float+0xbc>
   39702:	f109 0901 	add.w	r9, r9, #1
   39706:	e7ee      	b.n	396e6 <_printf_float+0x2a6>
   39708:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   3970a:	6da3      	ldr	r3, [r4, #88]	; 0x58
   3970c:	429a      	cmp	r2, r3
   3970e:	bfa8      	it	ge
   39710:	461a      	movge	r2, r3
   39712:	2a00      	cmp	r2, #0
   39714:	4691      	mov	r9, r2
   39716:	dd07      	ble.n	39728 <_printf_float+0x2e8>
   39718:	4613      	mov	r3, r2
   3971a:	4631      	mov	r1, r6
   3971c:	4642      	mov	r2, r8
   3971e:	4628      	mov	r0, r5
   39720:	47b8      	blx	r7
   39722:	3001      	adds	r0, #1
   39724:	f43f aeea 	beq.w	394fc <_printf_float+0xbc>
   39728:	f104 031a 	add.w	r3, r4, #26
   3972c:	f04f 0b00 	mov.w	fp, #0
   39730:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
   39734:	9304      	str	r3, [sp, #16]
   39736:	e015      	b.n	39764 <_printf_float+0x324>
   39738:	7fefffff 	.word	0x7fefffff
   3973c:	00044438 	.word	0x00044438
   39740:	00041b3a 	.word	0x00041b3a
   39744:	0004443c 	.word	0x0004443c
   39748:	00044440 	.word	0x00044440
   3974c:	00043e6b 	.word	0x00043e6b
   39750:	2301      	movs	r3, #1
   39752:	9a04      	ldr	r2, [sp, #16]
   39754:	4631      	mov	r1, r6
   39756:	4628      	mov	r0, r5
   39758:	47b8      	blx	r7
   3975a:	3001      	adds	r0, #1
   3975c:	f43f aece 	beq.w	394fc <_printf_float+0xbc>
   39760:	f10b 0b01 	add.w	fp, fp, #1
   39764:	f8d4 a058 	ldr.w	sl, [r4, #88]	; 0x58
   39768:	ebaa 0309 	sub.w	r3, sl, r9
   3976c:	455b      	cmp	r3, fp
   3976e:	dcef      	bgt.n	39750 <_printf_float+0x310>
   39770:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   39774:	429a      	cmp	r2, r3
   39776:	db1b      	blt.n	397b0 <_printf_float+0x370>
   39778:	6823      	ldr	r3, [r4, #0]
   3977a:	07da      	lsls	r2, r3, #31
   3977c:	d418      	bmi.n	397b0 <_printf_float+0x370>
   3977e:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   39782:	4592      	cmp	sl, r2
   39784:	db1c      	blt.n	397c0 <_printf_float+0x380>
   39786:	eba3 090a 	sub.w	r9, r3, sl
   3978a:	f1b9 0f00 	cmp.w	r9, #0
   3978e:	dd08      	ble.n	397a2 <_printf_float+0x362>
   39790:	464b      	mov	r3, r9
   39792:	eb08 020a 	add.w	r2, r8, sl
   39796:	4631      	mov	r1, r6
   39798:	4628      	mov	r0, r5
   3979a:	47b8      	blx	r7
   3979c:	3001      	adds	r0, #1
   3979e:	f43f aead 	beq.w	394fc <_printf_float+0xbc>
   397a2:	f04f 0800 	mov.w	r8, #0
   397a6:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
   397aa:	f104 0a1a 	add.w	sl, r4, #26
   397ae:	e014      	b.n	397da <_printf_float+0x39a>
   397b0:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   397b4:	4631      	mov	r1, r6
   397b6:	4628      	mov	r0, r5
   397b8:	47b8      	blx	r7
   397ba:	3001      	adds	r0, #1
   397bc:	d1df      	bne.n	3977e <_printf_float+0x33e>
   397be:	e69d      	b.n	394fc <_printf_float+0xbc>
   397c0:	eba3 0902 	sub.w	r9, r3, r2
   397c4:	e7e1      	b.n	3978a <_printf_float+0x34a>
   397c6:	2301      	movs	r3, #1
   397c8:	4652      	mov	r2, sl
   397ca:	4631      	mov	r1, r6
   397cc:	4628      	mov	r0, r5
   397ce:	47b8      	blx	r7
   397d0:	3001      	adds	r0, #1
   397d2:	f43f ae93 	beq.w	394fc <_printf_float+0xbc>
   397d6:	f108 0801 	add.w	r8, r8, #1
   397da:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   397de:	1a9b      	subs	r3, r3, r2
   397e0:	eba3 0309 	sub.w	r3, r3, r9
   397e4:	4543      	cmp	r3, r8
   397e6:	dcee      	bgt.n	397c6 <_printf_float+0x386>
   397e8:	e74a      	b.n	39680 <_printf_float+0x240>
   397ea:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   397ec:	2a01      	cmp	r2, #1
   397ee:	dc01      	bgt.n	397f4 <_printf_float+0x3b4>
   397f0:	07db      	lsls	r3, r3, #31
   397f2:	d537      	bpl.n	39864 <_printf_float+0x424>
   397f4:	2301      	movs	r3, #1
   397f6:	4642      	mov	r2, r8
   397f8:	4631      	mov	r1, r6
   397fa:	4628      	mov	r0, r5
   397fc:	47b8      	blx	r7
   397fe:	3001      	adds	r0, #1
   39800:	f43f ae7c 	beq.w	394fc <_printf_float+0xbc>
   39804:	4631      	mov	r1, r6
   39806:	4628      	mov	r0, r5
   39808:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   3980c:	47b8      	blx	r7
   3980e:	3001      	adds	r0, #1
   39810:	f43f ae74 	beq.w	394fc <_printf_float+0xbc>
   39814:	2200      	movs	r2, #0
   39816:	2300      	movs	r3, #0
   39818:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
   3981c:	f7e3 fa34 	bl	1cc88 <__aeabi_dcmpeq>
   39820:	b9d8      	cbnz	r0, 3985a <_printf_float+0x41a>
   39822:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   39824:	f108 0201 	add.w	r2, r8, #1
   39828:	3b01      	subs	r3, #1
   3982a:	4631      	mov	r1, r6
   3982c:	4628      	mov	r0, r5
   3982e:	47b8      	blx	r7
   39830:	3001      	adds	r0, #1
   39832:	d10e      	bne.n	39852 <_printf_float+0x412>
   39834:	e662      	b.n	394fc <_printf_float+0xbc>
   39836:	2301      	movs	r3, #1
   39838:	4652      	mov	r2, sl
   3983a:	4631      	mov	r1, r6
   3983c:	4628      	mov	r0, r5
   3983e:	47b8      	blx	r7
   39840:	3001      	adds	r0, #1
   39842:	f43f ae5b 	beq.w	394fc <_printf_float+0xbc>
   39846:	f108 0801 	add.w	r8, r8, #1
   3984a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   3984c:	3b01      	subs	r3, #1
   3984e:	4543      	cmp	r3, r8
   39850:	dcf1      	bgt.n	39836 <_printf_float+0x3f6>
   39852:	464b      	mov	r3, r9
   39854:	f104 0250 	add.w	r2, r4, #80	; 0x50
   39858:	e6e1      	b.n	3961e <_printf_float+0x1de>
   3985a:	f04f 0800 	mov.w	r8, #0
   3985e:	f104 0a1a 	add.w	sl, r4, #26
   39862:	e7f2      	b.n	3984a <_printf_float+0x40a>
   39864:	2301      	movs	r3, #1
   39866:	4642      	mov	r2, r8
   39868:	e7df      	b.n	3982a <_printf_float+0x3ea>
   3986a:	2301      	movs	r3, #1
   3986c:	464a      	mov	r2, r9
   3986e:	4631      	mov	r1, r6
   39870:	4628      	mov	r0, r5
   39872:	47b8      	blx	r7
   39874:	3001      	adds	r0, #1
   39876:	f43f ae41 	beq.w	394fc <_printf_float+0xbc>
   3987a:	f108 0801 	add.w	r8, r8, #1
   3987e:	68e3      	ldr	r3, [r4, #12]
   39880:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   39882:	1a9b      	subs	r3, r3, r2
   39884:	4543      	cmp	r3, r8
   39886:	dcf0      	bgt.n	3986a <_printf_float+0x42a>
   39888:	e6fe      	b.n	39688 <_printf_float+0x248>
   3988a:	f04f 0800 	mov.w	r8, #0
   3988e:	f104 0919 	add.w	r9, r4, #25
   39892:	e7f4      	b.n	3987e <_printf_float+0x43e>

00039894 <_printf_i>:
   39894:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   39898:	4606      	mov	r6, r0
   3989a:	460c      	mov	r4, r1
   3989c:	f101 0043 	add.w	r0, r1, #67	; 0x43
   398a0:	7e09      	ldrb	r1, [r1, #24]
   398a2:	b085      	sub	sp, #20
   398a4:	4698      	mov	r8, r3
   398a6:	296e      	cmp	r1, #110	; 0x6e
   398a8:	4617      	mov	r7, r2
   398aa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   398ac:	f000 80ba 	beq.w	39a24 <_printf_i+0x190>
   398b0:	d824      	bhi.n	398fc <_printf_i+0x68>
   398b2:	2963      	cmp	r1, #99	; 0x63
   398b4:	d039      	beq.n	3992a <_printf_i+0x96>
   398b6:	d80a      	bhi.n	398ce <_printf_i+0x3a>
   398b8:	2900      	cmp	r1, #0
   398ba:	f000 80c3 	beq.w	39a44 <_printf_i+0x1b0>
   398be:	2958      	cmp	r1, #88	; 0x58
   398c0:	f000 8091 	beq.w	399e6 <_printf_i+0x152>
   398c4:	f104 0542 	add.w	r5, r4, #66	; 0x42
   398c8:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
   398cc:	e035      	b.n	3993a <_printf_i+0xa6>
   398ce:	2964      	cmp	r1, #100	; 0x64
   398d0:	d001      	beq.n	398d6 <_printf_i+0x42>
   398d2:	2969      	cmp	r1, #105	; 0x69
   398d4:	d1f6      	bne.n	398c4 <_printf_i+0x30>
   398d6:	6825      	ldr	r5, [r4, #0]
   398d8:	681a      	ldr	r2, [r3, #0]
   398da:	f015 0f80 	tst.w	r5, #128	; 0x80
   398de:	f102 0104 	add.w	r1, r2, #4
   398e2:	d02c      	beq.n	3993e <_printf_i+0xaa>
   398e4:	6812      	ldr	r2, [r2, #0]
   398e6:	6019      	str	r1, [r3, #0]
   398e8:	2a00      	cmp	r2, #0
   398ea:	da03      	bge.n	398f4 <_printf_i+0x60>
   398ec:	232d      	movs	r3, #45	; 0x2d
   398ee:	4252      	negs	r2, r2
   398f0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   398f4:	f8df c1bc 	ldr.w	ip, [pc, #444]	; 39ab4 <_printf_i+0x220>
   398f8:	230a      	movs	r3, #10
   398fa:	e03f      	b.n	3997c <_printf_i+0xe8>
   398fc:	2973      	cmp	r1, #115	; 0x73
   398fe:	f000 80a5 	beq.w	39a4c <_printf_i+0x1b8>
   39902:	d808      	bhi.n	39916 <_printf_i+0x82>
   39904:	296f      	cmp	r1, #111	; 0x6f
   39906:	d021      	beq.n	3994c <_printf_i+0xb8>
   39908:	2970      	cmp	r1, #112	; 0x70
   3990a:	d1db      	bne.n	398c4 <_printf_i+0x30>
   3990c:	6822      	ldr	r2, [r4, #0]
   3990e:	f042 0220 	orr.w	r2, r2, #32
   39912:	6022      	str	r2, [r4, #0]
   39914:	e003      	b.n	3991e <_printf_i+0x8a>
   39916:	2975      	cmp	r1, #117	; 0x75
   39918:	d018      	beq.n	3994c <_printf_i+0xb8>
   3991a:	2978      	cmp	r1, #120	; 0x78
   3991c:	d1d2      	bne.n	398c4 <_printf_i+0x30>
   3991e:	2278      	movs	r2, #120	; 0x78
   39920:	f8df c194 	ldr.w	ip, [pc, #404]	; 39ab8 <_printf_i+0x224>
   39924:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
   39928:	e061      	b.n	399ee <_printf_i+0x15a>
   3992a:	681a      	ldr	r2, [r3, #0]
   3992c:	f104 0542 	add.w	r5, r4, #66	; 0x42
   39930:	1d11      	adds	r1, r2, #4
   39932:	6019      	str	r1, [r3, #0]
   39934:	6813      	ldr	r3, [r2, #0]
   39936:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
   3993a:	2301      	movs	r3, #1
   3993c:	e093      	b.n	39a66 <_printf_i+0x1d2>
   3993e:	6812      	ldr	r2, [r2, #0]
   39940:	f015 0f40 	tst.w	r5, #64	; 0x40
   39944:	6019      	str	r1, [r3, #0]
   39946:	bf18      	it	ne
   39948:	b212      	sxthne	r2, r2
   3994a:	e7cd      	b.n	398e8 <_printf_i+0x54>
   3994c:	f8d4 c000 	ldr.w	ip, [r4]
   39950:	681a      	ldr	r2, [r3, #0]
   39952:	f01c 0f80 	tst.w	ip, #128	; 0x80
   39956:	f102 0504 	add.w	r5, r2, #4
   3995a:	601d      	str	r5, [r3, #0]
   3995c:	d001      	beq.n	39962 <_printf_i+0xce>
   3995e:	6812      	ldr	r2, [r2, #0]
   39960:	e003      	b.n	3996a <_printf_i+0xd6>
   39962:	f01c 0f40 	tst.w	ip, #64	; 0x40
   39966:	d0fa      	beq.n	3995e <_printf_i+0xca>
   39968:	8812      	ldrh	r2, [r2, #0]
   3996a:	296f      	cmp	r1, #111	; 0x6f
   3996c:	f8df c144 	ldr.w	ip, [pc, #324]	; 39ab4 <_printf_i+0x220>
   39970:	bf0c      	ite	eq
   39972:	2308      	moveq	r3, #8
   39974:	230a      	movne	r3, #10
   39976:	2100      	movs	r1, #0
   39978:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
   3997c:	6865      	ldr	r5, [r4, #4]
   3997e:	2d00      	cmp	r5, #0
   39980:	60a5      	str	r5, [r4, #8]
   39982:	bfa2      	ittt	ge
   39984:	6821      	ldrge	r1, [r4, #0]
   39986:	f021 0104 	bicge.w	r1, r1, #4
   3998a:	6021      	strge	r1, [r4, #0]
   3998c:	b90a      	cbnz	r2, 39992 <_printf_i+0xfe>
   3998e:	2d00      	cmp	r5, #0
   39990:	d046      	beq.n	39a20 <_printf_i+0x18c>
   39992:	4605      	mov	r5, r0
   39994:	4293      	cmp	r3, r2
   39996:	fbb2 f1f3 	udiv	r1, r2, r3
   3999a:	fb03 2e11 	mls	lr, r3, r1, r2
   3999e:	f81c e00e 	ldrb.w	lr, [ip, lr]
   399a2:	f805 ed01 	strb.w	lr, [r5, #-1]!
   399a6:	d939      	bls.n	39a1c <_printf_i+0x188>
   399a8:	2b08      	cmp	r3, #8
   399aa:	d10b      	bne.n	399c4 <_printf_i+0x130>
   399ac:	6823      	ldr	r3, [r4, #0]
   399ae:	07da      	lsls	r2, r3, #31
   399b0:	d508      	bpl.n	399c4 <_printf_i+0x130>
   399b2:	6923      	ldr	r3, [r4, #16]
   399b4:	6862      	ldr	r2, [r4, #4]
   399b6:	429a      	cmp	r2, r3
   399b8:	bfde      	ittt	le
   399ba:	2330      	movle	r3, #48	; 0x30
   399bc:	f805 3c01 	strble.w	r3, [r5, #-1]
   399c0:	f105 35ff 	addle.w	r5, r5, #4294967295
   399c4:	1b40      	subs	r0, r0, r5
   399c6:	6120      	str	r0, [r4, #16]
   399c8:	f8cd 8000 	str.w	r8, [sp]
   399cc:	463b      	mov	r3, r7
   399ce:	aa03      	add	r2, sp, #12
   399d0:	4621      	mov	r1, r4
   399d2:	4630      	mov	r0, r6
   399d4:	f005 f824 	bl	3ea20 <_printf_common>
   399d8:	3001      	adds	r0, #1
   399da:	d149      	bne.n	39a70 <_printf_i+0x1dc>
   399dc:	f04f 30ff 	mov.w	r0, #4294967295
   399e0:	b005      	add	sp, #20
   399e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   399e6:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 39ab4 <_printf_i+0x220>
   399ea:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
   399ee:	681d      	ldr	r5, [r3, #0]
   399f0:	6821      	ldr	r1, [r4, #0]
   399f2:	f855 2b04 	ldr.w	r2, [r5], #4
   399f6:	601d      	str	r5, [r3, #0]
   399f8:	060d      	lsls	r5, r1, #24
   399fa:	d50b      	bpl.n	39a14 <_printf_i+0x180>
   399fc:	07cd      	lsls	r5, r1, #31
   399fe:	bf44      	itt	mi
   39a00:	f041 0120 	orrmi.w	r1, r1, #32
   39a04:	6021      	strmi	r1, [r4, #0]
   39a06:	b91a      	cbnz	r2, 39a10 <_printf_i+0x17c>
   39a08:	6823      	ldr	r3, [r4, #0]
   39a0a:	f023 0320 	bic.w	r3, r3, #32
   39a0e:	6023      	str	r3, [r4, #0]
   39a10:	2310      	movs	r3, #16
   39a12:	e7b0      	b.n	39976 <_printf_i+0xe2>
   39a14:	064b      	lsls	r3, r1, #25
   39a16:	bf48      	it	mi
   39a18:	b292      	uxthmi	r2, r2
   39a1a:	e7ef      	b.n	399fc <_printf_i+0x168>
   39a1c:	460a      	mov	r2, r1
   39a1e:	e7b9      	b.n	39994 <_printf_i+0x100>
   39a20:	4605      	mov	r5, r0
   39a22:	e7c1      	b.n	399a8 <_printf_i+0x114>
   39a24:	681a      	ldr	r2, [r3, #0]
   39a26:	f8d4 c000 	ldr.w	ip, [r4]
   39a2a:	1d15      	adds	r5, r2, #4
   39a2c:	6961      	ldr	r1, [r4, #20]
   39a2e:	f01c 0f80 	tst.w	ip, #128	; 0x80
   39a32:	601d      	str	r5, [r3, #0]
   39a34:	6813      	ldr	r3, [r2, #0]
   39a36:	d001      	beq.n	39a3c <_printf_i+0x1a8>
   39a38:	6019      	str	r1, [r3, #0]
   39a3a:	e003      	b.n	39a44 <_printf_i+0x1b0>
   39a3c:	f01c 0f40 	tst.w	ip, #64	; 0x40
   39a40:	d0fa      	beq.n	39a38 <_printf_i+0x1a4>
   39a42:	8019      	strh	r1, [r3, #0]
   39a44:	2300      	movs	r3, #0
   39a46:	4605      	mov	r5, r0
   39a48:	6123      	str	r3, [r4, #16]
   39a4a:	e7bd      	b.n	399c8 <_printf_i+0x134>
   39a4c:	681a      	ldr	r2, [r3, #0]
   39a4e:	1d11      	adds	r1, r2, #4
   39a50:	6019      	str	r1, [r3, #0]
   39a52:	2100      	movs	r1, #0
   39a54:	6815      	ldr	r5, [r2, #0]
   39a56:	6862      	ldr	r2, [r4, #4]
   39a58:	4628      	mov	r0, r5
   39a5a:	f004 fedb 	bl	3e814 <memchr>
   39a5e:	b108      	cbz	r0, 39a64 <_printf_i+0x1d0>
   39a60:	1b40      	subs	r0, r0, r5
   39a62:	6060      	str	r0, [r4, #4]
   39a64:	6863      	ldr	r3, [r4, #4]
   39a66:	6123      	str	r3, [r4, #16]
   39a68:	2300      	movs	r3, #0
   39a6a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   39a6e:	e7ab      	b.n	399c8 <_printf_i+0x134>
   39a70:	6923      	ldr	r3, [r4, #16]
   39a72:	462a      	mov	r2, r5
   39a74:	4639      	mov	r1, r7
   39a76:	4630      	mov	r0, r6
   39a78:	47c0      	blx	r8
   39a7a:	3001      	adds	r0, #1
   39a7c:	d0ae      	beq.n	399dc <_printf_i+0x148>
   39a7e:	6823      	ldr	r3, [r4, #0]
   39a80:	079b      	lsls	r3, r3, #30
   39a82:	d413      	bmi.n	39aac <_printf_i+0x218>
   39a84:	68e0      	ldr	r0, [r4, #12]
   39a86:	9b03      	ldr	r3, [sp, #12]
   39a88:	4298      	cmp	r0, r3
   39a8a:	bfb8      	it	lt
   39a8c:	4618      	movlt	r0, r3
   39a8e:	e7a7      	b.n	399e0 <_printf_i+0x14c>
   39a90:	2301      	movs	r3, #1
   39a92:	464a      	mov	r2, r9
   39a94:	4639      	mov	r1, r7
   39a96:	4630      	mov	r0, r6
   39a98:	47c0      	blx	r8
   39a9a:	3001      	adds	r0, #1
   39a9c:	d09e      	beq.n	399dc <_printf_i+0x148>
   39a9e:	3501      	adds	r5, #1
   39aa0:	68e3      	ldr	r3, [r4, #12]
   39aa2:	9a03      	ldr	r2, [sp, #12]
   39aa4:	1a9b      	subs	r3, r3, r2
   39aa6:	42ab      	cmp	r3, r5
   39aa8:	dcf2      	bgt.n	39a90 <_printf_i+0x1fc>
   39aaa:	e7eb      	b.n	39a84 <_printf_i+0x1f0>
   39aac:	2500      	movs	r5, #0
   39aae:	f104 0919 	add.w	r9, r4, #25
   39ab2:	e7f5      	b.n	39aa0 <_printf_i+0x20c>
   39ab4:	00044444 	.word	0x00044444
   39ab8:	00044455 	.word	0x00044455

00039abc <sniprintf>:
   39abc:	b40c      	push	{r2, r3}
   39abe:	4b18      	ldr	r3, [pc, #96]	; (39b20 <sniprintf+0x64>)
   39ac0:	b530      	push	{r4, r5, lr}
   39ac2:	1e0c      	subs	r4, r1, #0
   39ac4:	b09d      	sub	sp, #116	; 0x74
   39ac6:	681d      	ldr	r5, [r3, #0]
   39ac8:	da08      	bge.n	39adc <sniprintf+0x20>
   39aca:	238b      	movs	r3, #139	; 0x8b
   39acc:	f04f 30ff 	mov.w	r0, #4294967295
   39ad0:	602b      	str	r3, [r5, #0]
   39ad2:	b01d      	add	sp, #116	; 0x74
   39ad4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   39ad8:	b002      	add	sp, #8
   39ada:	4770      	bx	lr
   39adc:	f44f 7302 	mov.w	r3, #520	; 0x208
   39ae0:	9002      	str	r0, [sp, #8]
   39ae2:	9006      	str	r0, [sp, #24]
   39ae4:	a902      	add	r1, sp, #8
   39ae6:	f8ad 3014 	strh.w	r3, [sp, #20]
   39aea:	bf14      	ite	ne
   39aec:	f104 33ff 	addne.w	r3, r4, #4294967295
   39af0:	4623      	moveq	r3, r4
   39af2:	9a20      	ldr	r2, [sp, #128]	; 0x80
   39af4:	4628      	mov	r0, r5
   39af6:	9304      	str	r3, [sp, #16]
   39af8:	9307      	str	r3, [sp, #28]
   39afa:	f64f 73ff 	movw	r3, #65535	; 0xffff
   39afe:	f8ad 3016 	strh.w	r3, [sp, #22]
   39b02:	ab21      	add	r3, sp, #132	; 0x84
   39b04:	9301      	str	r3, [sp, #4]
   39b06:	f000 fd01 	bl	3a50c <_svfiprintf_r>
   39b0a:	1c43      	adds	r3, r0, #1
   39b0c:	bfbc      	itt	lt
   39b0e:	238b      	movlt	r3, #139	; 0x8b
   39b10:	602b      	strlt	r3, [r5, #0]
   39b12:	2c00      	cmp	r4, #0
   39b14:	d0dd      	beq.n	39ad2 <sniprintf+0x16>
   39b16:	9b02      	ldr	r3, [sp, #8]
   39b18:	2200      	movs	r2, #0
   39b1a:	701a      	strb	r2, [r3, #0]
   39b1c:	e7d9      	b.n	39ad2 <sniprintf+0x16>
   39b1e:	bf00      	nop
   39b20:	20034708 	.word	0x20034708

00039b24 <siprintf>:
   39b24:	b40e      	push	{r1, r2, r3}
   39b26:	b500      	push	{lr}
   39b28:	b09c      	sub	sp, #112	; 0x70
   39b2a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   39b2e:	ab1d      	add	r3, sp, #116	; 0x74
   39b30:	9002      	str	r0, [sp, #8]
   39b32:	9006      	str	r0, [sp, #24]
   39b34:	9107      	str	r1, [sp, #28]
   39b36:	9104      	str	r1, [sp, #16]
   39b38:	4808      	ldr	r0, [pc, #32]	; (39b5c <siprintf+0x38>)
   39b3a:	4909      	ldr	r1, [pc, #36]	; (39b60 <siprintf+0x3c>)
   39b3c:	f853 2b04 	ldr.w	r2, [r3], #4
   39b40:	9105      	str	r1, [sp, #20]
   39b42:	a902      	add	r1, sp, #8
   39b44:	6800      	ldr	r0, [r0, #0]
   39b46:	9301      	str	r3, [sp, #4]
   39b48:	f000 fce0 	bl	3a50c <_svfiprintf_r>
   39b4c:	9b02      	ldr	r3, [sp, #8]
   39b4e:	2200      	movs	r2, #0
   39b50:	701a      	strb	r2, [r3, #0]
   39b52:	b01c      	add	sp, #112	; 0x70
   39b54:	f85d eb04 	ldr.w	lr, [sp], #4
   39b58:	b003      	add	sp, #12
   39b5a:	4770      	bx	lr
   39b5c:	20034708 	.word	0x20034708
   39b60:	ffff0208 	.word	0xffff0208

00039b64 <_strtol_l.isra.0>:
   39b64:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   39b68:	4686      	mov	lr, r0
   39b6a:	4f39      	ldr	r7, [pc, #228]	; (39c50 <_strtol_l.isra.0+0xec>)
   39b6c:	4608      	mov	r0, r1
   39b6e:	4605      	mov	r5, r0
   39b70:	f815 4b01 	ldrb.w	r4, [r5], #1
   39b74:	5de6      	ldrb	r6, [r4, r7]
   39b76:	f016 0608 	ands.w	r6, r6, #8
   39b7a:	d135      	bne.n	39be8 <_strtol_l.isra.0+0x84>
   39b7c:	2c2d      	cmp	r4, #45	; 0x2d
   39b7e:	d135      	bne.n	39bec <_strtol_l.isra.0+0x88>
   39b80:	782c      	ldrb	r4, [r5, #0]
   39b82:	f04f 0801 	mov.w	r8, #1
   39b86:	1c85      	adds	r5, r0, #2
   39b88:	2b00      	cmp	r3, #0
   39b8a:	d05c      	beq.n	39c46 <_strtol_l.isra.0+0xe2>
   39b8c:	2b10      	cmp	r3, #16
   39b8e:	d109      	bne.n	39ba4 <_strtol_l.isra.0+0x40>
   39b90:	2c30      	cmp	r4, #48	; 0x30
   39b92:	d107      	bne.n	39ba4 <_strtol_l.isra.0+0x40>
   39b94:	7828      	ldrb	r0, [r5, #0]
   39b96:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   39b9a:	2858      	cmp	r0, #88	; 0x58
   39b9c:	d14e      	bne.n	39c3c <_strtol_l.isra.0+0xd8>
   39b9e:	786c      	ldrb	r4, [r5, #1]
   39ba0:	2310      	movs	r3, #16
   39ba2:	3502      	adds	r5, #2
   39ba4:	f1b8 0f00 	cmp.w	r8, #0
   39ba8:	f04f 0700 	mov.w	r7, #0
   39bac:	bf14      	ite	ne
   39bae:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
   39bb2:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
   39bb6:	4638      	mov	r0, r7
   39bb8:	fbbc f9f3 	udiv	r9, ip, r3
   39bbc:	fb03 ca19 	mls	sl, r3, r9, ip
   39bc0:	f1a4 0630 	sub.w	r6, r4, #48	; 0x30
   39bc4:	2e09      	cmp	r6, #9
   39bc6:	d817      	bhi.n	39bf8 <_strtol_l.isra.0+0x94>
   39bc8:	4634      	mov	r4, r6
   39bca:	42a3      	cmp	r3, r4
   39bcc:	dd23      	ble.n	39c16 <_strtol_l.isra.0+0xb2>
   39bce:	1c7e      	adds	r6, r7, #1
   39bd0:	d007      	beq.n	39be2 <_strtol_l.isra.0+0x7e>
   39bd2:	4581      	cmp	r9, r0
   39bd4:	d31c      	bcc.n	39c10 <_strtol_l.isra.0+0xac>
   39bd6:	d101      	bne.n	39bdc <_strtol_l.isra.0+0x78>
   39bd8:	45a2      	cmp	sl, r4
   39bda:	db19      	blt.n	39c10 <_strtol_l.isra.0+0xac>
   39bdc:	fb00 4003 	mla	r0, r0, r3, r4
   39be0:	2701      	movs	r7, #1
   39be2:	f815 4b01 	ldrb.w	r4, [r5], #1
   39be6:	e7eb      	b.n	39bc0 <_strtol_l.isra.0+0x5c>
   39be8:	4628      	mov	r0, r5
   39bea:	e7c0      	b.n	39b6e <_strtol_l.isra.0+0xa>
   39bec:	2c2b      	cmp	r4, #43	; 0x2b
   39bee:	46b0      	mov	r8, r6
   39bf0:	bf04      	itt	eq
   39bf2:	782c      	ldrbeq	r4, [r5, #0]
   39bf4:	1c85      	addeq	r5, r0, #2
   39bf6:	e7c7      	b.n	39b88 <_strtol_l.isra.0+0x24>
   39bf8:	f1a4 0641 	sub.w	r6, r4, #65	; 0x41
   39bfc:	2e19      	cmp	r6, #25
   39bfe:	d801      	bhi.n	39c04 <_strtol_l.isra.0+0xa0>
   39c00:	3c37      	subs	r4, #55	; 0x37
   39c02:	e7e2      	b.n	39bca <_strtol_l.isra.0+0x66>
   39c04:	f1a4 0661 	sub.w	r6, r4, #97	; 0x61
   39c08:	2e19      	cmp	r6, #25
   39c0a:	d804      	bhi.n	39c16 <_strtol_l.isra.0+0xb2>
   39c0c:	3c57      	subs	r4, #87	; 0x57
   39c0e:	e7dc      	b.n	39bca <_strtol_l.isra.0+0x66>
   39c10:	f04f 37ff 	mov.w	r7, #4294967295
   39c14:	e7e5      	b.n	39be2 <_strtol_l.isra.0+0x7e>
   39c16:	1c7b      	adds	r3, r7, #1
   39c18:	d106      	bne.n	39c28 <_strtol_l.isra.0+0xc4>
   39c1a:	2322      	movs	r3, #34	; 0x22
   39c1c:	4660      	mov	r0, ip
   39c1e:	f8ce 3000 	str.w	r3, [lr]
   39c22:	b942      	cbnz	r2, 39c36 <_strtol_l.isra.0+0xd2>
   39c24:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   39c28:	f1b8 0f00 	cmp.w	r8, #0
   39c2c:	d000      	beq.n	39c30 <_strtol_l.isra.0+0xcc>
   39c2e:	4240      	negs	r0, r0
   39c30:	2a00      	cmp	r2, #0
   39c32:	d0f7      	beq.n	39c24 <_strtol_l.isra.0+0xc0>
   39c34:	b107      	cbz	r7, 39c38 <_strtol_l.isra.0+0xd4>
   39c36:	1e69      	subs	r1, r5, #1
   39c38:	6011      	str	r1, [r2, #0]
   39c3a:	e7f3      	b.n	39c24 <_strtol_l.isra.0+0xc0>
   39c3c:	2430      	movs	r4, #48	; 0x30
   39c3e:	2b00      	cmp	r3, #0
   39c40:	d1b0      	bne.n	39ba4 <_strtol_l.isra.0+0x40>
   39c42:	2308      	movs	r3, #8
   39c44:	e7ae      	b.n	39ba4 <_strtol_l.isra.0+0x40>
   39c46:	2c30      	cmp	r4, #48	; 0x30
   39c48:	d0a4      	beq.n	39b94 <_strtol_l.isra.0+0x30>
   39c4a:	230a      	movs	r3, #10
   39c4c:	e7aa      	b.n	39ba4 <_strtol_l.isra.0+0x40>
   39c4e:	bf00      	nop
   39c50:	00044327 	.word	0x00044327

00039c54 <strtol>:
   39c54:	4613      	mov	r3, r2
   39c56:	460a      	mov	r2, r1
   39c58:	4601      	mov	r1, r0
   39c5a:	4802      	ldr	r0, [pc, #8]	; (39c64 <strtol+0x10>)
   39c5c:	6800      	ldr	r0, [r0, #0]
   39c5e:	f7ff bf81 	b.w	39b64 <_strtol_l.isra.0>
   39c62:	bf00      	nop
   39c64:	20034708 	.word	0x20034708

00039c68 <_strtoul_l.isra.0>:
   39c68:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   39c6c:	4686      	mov	lr, r0
   39c6e:	4f37      	ldr	r7, [pc, #220]	; (39d4c <_strtoul_l.isra.0+0xe4>)
   39c70:	4608      	mov	r0, r1
   39c72:	4605      	mov	r5, r0
   39c74:	f815 4b01 	ldrb.w	r4, [r5], #1
   39c78:	5de6      	ldrb	r6, [r4, r7]
   39c7a:	f016 0608 	ands.w	r6, r6, #8
   39c7e:	d131      	bne.n	39ce4 <_strtoul_l.isra.0+0x7c>
   39c80:	2c2d      	cmp	r4, #45	; 0x2d
   39c82:	d131      	bne.n	39ce8 <_strtoul_l.isra.0+0x80>
   39c84:	782c      	ldrb	r4, [r5, #0]
   39c86:	f04f 0801 	mov.w	r8, #1
   39c8a:	1c85      	adds	r5, r0, #2
   39c8c:	2b00      	cmp	r3, #0
   39c8e:	d059      	beq.n	39d44 <_strtoul_l.isra.0+0xdc>
   39c90:	2b10      	cmp	r3, #16
   39c92:	d109      	bne.n	39ca8 <_strtoul_l.isra.0+0x40>
   39c94:	2c30      	cmp	r4, #48	; 0x30
   39c96:	d107      	bne.n	39ca8 <_strtoul_l.isra.0+0x40>
   39c98:	7828      	ldrb	r0, [r5, #0]
   39c9a:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   39c9e:	2858      	cmp	r0, #88	; 0x58
   39ca0:	d14b      	bne.n	39d3a <_strtoul_l.isra.0+0xd2>
   39ca2:	786c      	ldrb	r4, [r5, #1]
   39ca4:	2310      	movs	r3, #16
   39ca6:	3502      	adds	r5, #2
   39ca8:	f04f 3cff 	mov.w	ip, #4294967295
   39cac:	2600      	movs	r6, #0
   39cae:	fbbc fcf3 	udiv	ip, ip, r3
   39cb2:	fb03 f90c 	mul.w	r9, r3, ip
   39cb6:	4630      	mov	r0, r6
   39cb8:	ea6f 0909 	mvn.w	r9, r9
   39cbc:	f1a4 0730 	sub.w	r7, r4, #48	; 0x30
   39cc0:	2f09      	cmp	r7, #9
   39cc2:	d817      	bhi.n	39cf4 <_strtoul_l.isra.0+0x8c>
   39cc4:	463c      	mov	r4, r7
   39cc6:	42a3      	cmp	r3, r4
   39cc8:	dd23      	ble.n	39d12 <_strtoul_l.isra.0+0xaa>
   39cca:	2e00      	cmp	r6, #0
   39ccc:	db1e      	blt.n	39d0c <_strtoul_l.isra.0+0xa4>
   39cce:	4584      	cmp	ip, r0
   39cd0:	d31c      	bcc.n	39d0c <_strtoul_l.isra.0+0xa4>
   39cd2:	d101      	bne.n	39cd8 <_strtoul_l.isra.0+0x70>
   39cd4:	45a1      	cmp	r9, r4
   39cd6:	db19      	blt.n	39d0c <_strtoul_l.isra.0+0xa4>
   39cd8:	fb00 4003 	mla	r0, r0, r3, r4
   39cdc:	2601      	movs	r6, #1
   39cde:	f815 4b01 	ldrb.w	r4, [r5], #1
   39ce2:	e7eb      	b.n	39cbc <_strtoul_l.isra.0+0x54>
   39ce4:	4628      	mov	r0, r5
   39ce6:	e7c4      	b.n	39c72 <_strtoul_l.isra.0+0xa>
   39ce8:	2c2b      	cmp	r4, #43	; 0x2b
   39cea:	46b0      	mov	r8, r6
   39cec:	bf04      	itt	eq
   39cee:	782c      	ldrbeq	r4, [r5, #0]
   39cf0:	1c85      	addeq	r5, r0, #2
   39cf2:	e7cb      	b.n	39c8c <_strtoul_l.isra.0+0x24>
   39cf4:	f1a4 0741 	sub.w	r7, r4, #65	; 0x41
   39cf8:	2f19      	cmp	r7, #25
   39cfa:	d801      	bhi.n	39d00 <_strtoul_l.isra.0+0x98>
   39cfc:	3c37      	subs	r4, #55	; 0x37
   39cfe:	e7e2      	b.n	39cc6 <_strtoul_l.isra.0+0x5e>
   39d00:	f1a4 0761 	sub.w	r7, r4, #97	; 0x61
   39d04:	2f19      	cmp	r7, #25
   39d06:	d804      	bhi.n	39d12 <_strtoul_l.isra.0+0xaa>
   39d08:	3c57      	subs	r4, #87	; 0x57
   39d0a:	e7dc      	b.n	39cc6 <_strtoul_l.isra.0+0x5e>
   39d0c:	f04f 36ff 	mov.w	r6, #4294967295
   39d10:	e7e5      	b.n	39cde <_strtoul_l.isra.0+0x76>
   39d12:	2e00      	cmp	r6, #0
   39d14:	da07      	bge.n	39d26 <_strtoul_l.isra.0+0xbe>
   39d16:	2322      	movs	r3, #34	; 0x22
   39d18:	f04f 30ff 	mov.w	r0, #4294967295
   39d1c:	f8ce 3000 	str.w	r3, [lr]
   39d20:	b942      	cbnz	r2, 39d34 <_strtoul_l.isra.0+0xcc>
   39d22:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   39d26:	f1b8 0f00 	cmp.w	r8, #0
   39d2a:	d000      	beq.n	39d2e <_strtoul_l.isra.0+0xc6>
   39d2c:	4240      	negs	r0, r0
   39d2e:	2a00      	cmp	r2, #0
   39d30:	d0f7      	beq.n	39d22 <_strtoul_l.isra.0+0xba>
   39d32:	b106      	cbz	r6, 39d36 <_strtoul_l.isra.0+0xce>
   39d34:	1e69      	subs	r1, r5, #1
   39d36:	6011      	str	r1, [r2, #0]
   39d38:	e7f3      	b.n	39d22 <_strtoul_l.isra.0+0xba>
   39d3a:	2430      	movs	r4, #48	; 0x30
   39d3c:	2b00      	cmp	r3, #0
   39d3e:	d1b3      	bne.n	39ca8 <_strtoul_l.isra.0+0x40>
   39d40:	2308      	movs	r3, #8
   39d42:	e7b1      	b.n	39ca8 <_strtoul_l.isra.0+0x40>
   39d44:	2c30      	cmp	r4, #48	; 0x30
   39d46:	d0a7      	beq.n	39c98 <_strtoul_l.isra.0+0x30>
   39d48:	230a      	movs	r3, #10
   39d4a:	e7ad      	b.n	39ca8 <_strtoul_l.isra.0+0x40>
   39d4c:	00044327 	.word	0x00044327

00039d50 <strtoul>:
   39d50:	4613      	mov	r3, r2
   39d52:	460a      	mov	r2, r1
   39d54:	4601      	mov	r1, r0
   39d56:	4802      	ldr	r0, [pc, #8]	; (39d60 <strtoul+0x10>)
   39d58:	6800      	ldr	r0, [r0, #0]
   39d5a:	f7ff bf85 	b.w	39c68 <_strtoul_l.isra.0>
   39d5e:	bf00      	nop
   39d60:	20034708 	.word	0x20034708

00039d64 <vsniprintf>:
   39d64:	b507      	push	{r0, r1, r2, lr}
   39d66:	9300      	str	r3, [sp, #0]
   39d68:	4613      	mov	r3, r2
   39d6a:	460a      	mov	r2, r1
   39d6c:	4601      	mov	r1, r0
   39d6e:	4803      	ldr	r0, [pc, #12]	; (39d7c <vsniprintf+0x18>)
   39d70:	6800      	ldr	r0, [r0, #0]
   39d72:	f004 ff38 	bl	3ebe6 <_vsniprintf_r>
   39d76:	b003      	add	sp, #12
   39d78:	f85d fb04 	ldr.w	pc, [sp], #4
   39d7c:	20034708 	.word	0x20034708

00039d80 <_vsiprintf_r>:
   39d80:	b500      	push	{lr}
   39d82:	b09b      	sub	sp, #108	; 0x6c
   39d84:	9100      	str	r1, [sp, #0]
   39d86:	9104      	str	r1, [sp, #16]
   39d88:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   39d8c:	9105      	str	r1, [sp, #20]
   39d8e:	9102      	str	r1, [sp, #8]
   39d90:	4905      	ldr	r1, [pc, #20]	; (39da8 <_vsiprintf_r+0x28>)
   39d92:	9103      	str	r1, [sp, #12]
   39d94:	4669      	mov	r1, sp
   39d96:	f000 fbb9 	bl	3a50c <_svfiprintf_r>
   39d9a:	9b00      	ldr	r3, [sp, #0]
   39d9c:	2200      	movs	r2, #0
   39d9e:	701a      	strb	r2, [r3, #0]
   39da0:	b01b      	add	sp, #108	; 0x6c
   39da2:	f85d fb04 	ldr.w	pc, [sp], #4
   39da6:	bf00      	nop
   39da8:	ffff0208 	.word	0xffff0208

00039dac <vsiprintf>:
   39dac:	4613      	mov	r3, r2
   39dae:	460a      	mov	r2, r1
   39db0:	4601      	mov	r1, r0
   39db2:	4802      	ldr	r0, [pc, #8]	; (39dbc <vsiprintf+0x10>)
   39db4:	6800      	ldr	r0, [r0, #0]
   39db6:	f7ff bfe3 	b.w	39d80 <_vsiprintf_r>
   39dba:	bf00      	nop
   39dbc:	20034708 	.word	0x20034708

00039dc0 <__swbuf_r>:
   39dc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   39dc2:	460e      	mov	r6, r1
   39dc4:	4614      	mov	r4, r2
   39dc6:	4605      	mov	r5, r0
   39dc8:	b118      	cbz	r0, 39dd2 <__swbuf_r+0x12>
   39dca:	6983      	ldr	r3, [r0, #24]
   39dcc:	b90b      	cbnz	r3, 39dd2 <__swbuf_r+0x12>
   39dce:	f000 f9dd 	bl	3a18c <__sinit>
   39dd2:	4b21      	ldr	r3, [pc, #132]	; (39e58 <__swbuf_r+0x98>)
   39dd4:	429c      	cmp	r4, r3
   39dd6:	d12b      	bne.n	39e30 <__swbuf_r+0x70>
   39dd8:	686c      	ldr	r4, [r5, #4]
   39dda:	69a3      	ldr	r3, [r4, #24]
   39ddc:	60a3      	str	r3, [r4, #8]
   39dde:	89a3      	ldrh	r3, [r4, #12]
   39de0:	071a      	lsls	r2, r3, #28
   39de2:	d52f      	bpl.n	39e44 <__swbuf_r+0x84>
   39de4:	6923      	ldr	r3, [r4, #16]
   39de6:	b36b      	cbz	r3, 39e44 <__swbuf_r+0x84>
   39de8:	6923      	ldr	r3, [r4, #16]
   39dea:	b2f6      	uxtb	r6, r6
   39dec:	6820      	ldr	r0, [r4, #0]
   39dee:	4637      	mov	r7, r6
   39df0:	1ac0      	subs	r0, r0, r3
   39df2:	6963      	ldr	r3, [r4, #20]
   39df4:	4283      	cmp	r3, r0
   39df6:	dc04      	bgt.n	39e02 <__swbuf_r+0x42>
   39df8:	4621      	mov	r1, r4
   39dfa:	4628      	mov	r0, r5
   39dfc:	f000 f948 	bl	3a090 <_fflush_r>
   39e00:	bb30      	cbnz	r0, 39e50 <__swbuf_r+0x90>
   39e02:	68a3      	ldr	r3, [r4, #8]
   39e04:	3001      	adds	r0, #1
   39e06:	3b01      	subs	r3, #1
   39e08:	60a3      	str	r3, [r4, #8]
   39e0a:	6823      	ldr	r3, [r4, #0]
   39e0c:	1c5a      	adds	r2, r3, #1
   39e0e:	6022      	str	r2, [r4, #0]
   39e10:	701e      	strb	r6, [r3, #0]
   39e12:	6963      	ldr	r3, [r4, #20]
   39e14:	4283      	cmp	r3, r0
   39e16:	d004      	beq.n	39e22 <__swbuf_r+0x62>
   39e18:	89a3      	ldrh	r3, [r4, #12]
   39e1a:	07db      	lsls	r3, r3, #31
   39e1c:	d506      	bpl.n	39e2c <__swbuf_r+0x6c>
   39e1e:	2e0a      	cmp	r6, #10
   39e20:	d104      	bne.n	39e2c <__swbuf_r+0x6c>
   39e22:	4621      	mov	r1, r4
   39e24:	4628      	mov	r0, r5
   39e26:	f000 f933 	bl	3a090 <_fflush_r>
   39e2a:	b988      	cbnz	r0, 39e50 <__swbuf_r+0x90>
   39e2c:	4638      	mov	r0, r7
   39e2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   39e30:	4b0a      	ldr	r3, [pc, #40]	; (39e5c <__swbuf_r+0x9c>)
   39e32:	429c      	cmp	r4, r3
   39e34:	d101      	bne.n	39e3a <__swbuf_r+0x7a>
   39e36:	68ac      	ldr	r4, [r5, #8]
   39e38:	e7cf      	b.n	39dda <__swbuf_r+0x1a>
   39e3a:	4b09      	ldr	r3, [pc, #36]	; (39e60 <__swbuf_r+0xa0>)
   39e3c:	429c      	cmp	r4, r3
   39e3e:	bf08      	it	eq
   39e40:	68ec      	ldreq	r4, [r5, #12]
   39e42:	e7ca      	b.n	39dda <__swbuf_r+0x1a>
   39e44:	4621      	mov	r1, r4
   39e46:	4628      	mov	r0, r5
   39e48:	f000 f80c 	bl	39e64 <__swsetup_r>
   39e4c:	2800      	cmp	r0, #0
   39e4e:	d0cb      	beq.n	39de8 <__swbuf_r+0x28>
   39e50:	f04f 37ff 	mov.w	r7, #4294967295
   39e54:	e7ea      	b.n	39e2c <__swbuf_r+0x6c>
   39e56:	bf00      	nop
   39e58:	000403a0 	.word	0x000403a0
   39e5c:	000403c0 	.word	0x000403c0
   39e60:	00040380 	.word	0x00040380

00039e64 <__swsetup_r>:
   39e64:	4b32      	ldr	r3, [pc, #200]	; (39f30 <__swsetup_r+0xcc>)
   39e66:	b570      	push	{r4, r5, r6, lr}
   39e68:	681d      	ldr	r5, [r3, #0]
   39e6a:	4606      	mov	r6, r0
   39e6c:	460c      	mov	r4, r1
   39e6e:	b125      	cbz	r5, 39e7a <__swsetup_r+0x16>
   39e70:	69ab      	ldr	r3, [r5, #24]
   39e72:	b913      	cbnz	r3, 39e7a <__swsetup_r+0x16>
   39e74:	4628      	mov	r0, r5
   39e76:	f000 f989 	bl	3a18c <__sinit>
   39e7a:	4b2e      	ldr	r3, [pc, #184]	; (39f34 <__swsetup_r+0xd0>)
   39e7c:	429c      	cmp	r4, r3
   39e7e:	d10f      	bne.n	39ea0 <__swsetup_r+0x3c>
   39e80:	686c      	ldr	r4, [r5, #4]
   39e82:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   39e86:	b29a      	uxth	r2, r3
   39e88:	0715      	lsls	r5, r2, #28
   39e8a:	d42c      	bmi.n	39ee6 <__swsetup_r+0x82>
   39e8c:	06d0      	lsls	r0, r2, #27
   39e8e:	d411      	bmi.n	39eb4 <__swsetup_r+0x50>
   39e90:	2209      	movs	r2, #9
   39e92:	6032      	str	r2, [r6, #0]
   39e94:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   39e98:	f04f 30ff 	mov.w	r0, #4294967295
   39e9c:	81a3      	strh	r3, [r4, #12]
   39e9e:	e03e      	b.n	39f1e <__swsetup_r+0xba>
   39ea0:	4b25      	ldr	r3, [pc, #148]	; (39f38 <__swsetup_r+0xd4>)
   39ea2:	429c      	cmp	r4, r3
   39ea4:	d101      	bne.n	39eaa <__swsetup_r+0x46>
   39ea6:	68ac      	ldr	r4, [r5, #8]
   39ea8:	e7eb      	b.n	39e82 <__swsetup_r+0x1e>
   39eaa:	4b24      	ldr	r3, [pc, #144]	; (39f3c <__swsetup_r+0xd8>)
   39eac:	429c      	cmp	r4, r3
   39eae:	bf08      	it	eq
   39eb0:	68ec      	ldreq	r4, [r5, #12]
   39eb2:	e7e6      	b.n	39e82 <__swsetup_r+0x1e>
   39eb4:	0751      	lsls	r1, r2, #29
   39eb6:	d512      	bpl.n	39ede <__swsetup_r+0x7a>
   39eb8:	6b61      	ldr	r1, [r4, #52]	; 0x34
   39eba:	b141      	cbz	r1, 39ece <__swsetup_r+0x6a>
   39ebc:	f104 0344 	add.w	r3, r4, #68	; 0x44
   39ec0:	4299      	cmp	r1, r3
   39ec2:	d002      	beq.n	39eca <__swsetup_r+0x66>
   39ec4:	4630      	mov	r0, r6
   39ec6:	f000 fa79 	bl	3a3bc <_free_r>
   39eca:	2300      	movs	r3, #0
   39ecc:	6363      	str	r3, [r4, #52]	; 0x34
   39ece:	89a3      	ldrh	r3, [r4, #12]
   39ed0:	f023 0324 	bic.w	r3, r3, #36	; 0x24
   39ed4:	81a3      	strh	r3, [r4, #12]
   39ed6:	2300      	movs	r3, #0
   39ed8:	6063      	str	r3, [r4, #4]
   39eda:	6923      	ldr	r3, [r4, #16]
   39edc:	6023      	str	r3, [r4, #0]
   39ede:	89a3      	ldrh	r3, [r4, #12]
   39ee0:	f043 0308 	orr.w	r3, r3, #8
   39ee4:	81a3      	strh	r3, [r4, #12]
   39ee6:	6923      	ldr	r3, [r4, #16]
   39ee8:	b94b      	cbnz	r3, 39efe <__swsetup_r+0x9a>
   39eea:	89a3      	ldrh	r3, [r4, #12]
   39eec:	f403 7320 	and.w	r3, r3, #640	; 0x280
   39ef0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   39ef4:	d003      	beq.n	39efe <__swsetup_r+0x9a>
   39ef6:	4621      	mov	r1, r4
   39ef8:	4630      	mov	r0, r6
   39efa:	f000 f9c9 	bl	3a290 <__smakebuf_r>
   39efe:	89a2      	ldrh	r2, [r4, #12]
   39f00:	f012 0301 	ands.w	r3, r2, #1
   39f04:	d00c      	beq.n	39f20 <__swsetup_r+0xbc>
   39f06:	2300      	movs	r3, #0
   39f08:	60a3      	str	r3, [r4, #8]
   39f0a:	6963      	ldr	r3, [r4, #20]
   39f0c:	425b      	negs	r3, r3
   39f0e:	61a3      	str	r3, [r4, #24]
   39f10:	6923      	ldr	r3, [r4, #16]
   39f12:	b953      	cbnz	r3, 39f2a <__swsetup_r+0xc6>
   39f14:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   39f18:	f013 0080 	ands.w	r0, r3, #128	; 0x80
   39f1c:	d1ba      	bne.n	39e94 <__swsetup_r+0x30>
   39f1e:	bd70      	pop	{r4, r5, r6, pc}
   39f20:	0792      	lsls	r2, r2, #30
   39f22:	bf58      	it	pl
   39f24:	6963      	ldrpl	r3, [r4, #20]
   39f26:	60a3      	str	r3, [r4, #8]
   39f28:	e7f2      	b.n	39f10 <__swsetup_r+0xac>
   39f2a:	2000      	movs	r0, #0
   39f2c:	e7f7      	b.n	39f1e <__swsetup_r+0xba>
   39f2e:	bf00      	nop
   39f30:	20034708 	.word	0x20034708
   39f34:	000403a0 	.word	0x000403a0
   39f38:	000403c0 	.word	0x000403c0
   39f3c:	00040380 	.word	0x00040380

00039f40 <__chk_fail>:
   39f40:	b500      	push	{lr}
   39f42:	b08d      	sub	sp, #52	; 0x34
   39f44:	4b0f      	ldr	r3, [pc, #60]	; (39f84 <__chk_fail+0x44>)
   39f46:	466a      	mov	r2, sp
   39f48:	f103 0628 	add.w	r6, r3, #40	; 0x28
   39f4c:	4615      	mov	r5, r2
   39f4e:	6818      	ldr	r0, [r3, #0]
   39f50:	3308      	adds	r3, #8
   39f52:	f853 1c04 	ldr.w	r1, [r3, #-4]
   39f56:	4614      	mov	r4, r2
   39f58:	42b3      	cmp	r3, r6
   39f5a:	c403      	stmia	r4!, {r0, r1}
   39f5c:	4622      	mov	r2, r4
   39f5e:	d1f6      	bne.n	39f4e <__chk_fail+0xe>
   39f60:	6818      	ldr	r0, [r3, #0]
   39f62:	889b      	ldrh	r3, [r3, #4]
   39f64:	6020      	str	r0, [r4, #0]
   39f66:	4628      	mov	r0, r5
   39f68:	80a3      	strh	r3, [r4, #4]
   39f6a:	f7e3 f8f5 	bl	1d158 <strlen>
   39f6e:	4629      	mov	r1, r5
   39f70:	4602      	mov	r2, r0
   39f72:	2002      	movs	r0, #2
   39f74:	f002 fdc1 	bl	3cafa <_write>
   39f78:	2006      	movs	r0, #6
   39f7a:	f000 fbcf 	bl	3a71c <raise>
   39f7e:	207f      	movs	r0, #127	; 0x7f
   39f80:	f7ef f83e 	bl	29000 <_exit>
   39f84:	00044466 	.word	0x00044466

00039f88 <__sflush_r>:
   39f88:	898a      	ldrh	r2, [r1, #12]
   39f8a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   39f8e:	4605      	mov	r5, r0
   39f90:	0710      	lsls	r0, r2, #28
   39f92:	460c      	mov	r4, r1
   39f94:	d458      	bmi.n	3a048 <__sflush_r+0xc0>
   39f96:	684b      	ldr	r3, [r1, #4]
   39f98:	2b00      	cmp	r3, #0
   39f9a:	dc05      	bgt.n	39fa8 <__sflush_r+0x20>
   39f9c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
   39f9e:	2b00      	cmp	r3, #0
   39fa0:	dc02      	bgt.n	39fa8 <__sflush_r+0x20>
   39fa2:	2000      	movs	r0, #0
   39fa4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   39fa8:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   39faa:	2e00      	cmp	r6, #0
   39fac:	d0f9      	beq.n	39fa2 <__sflush_r+0x1a>
   39fae:	2300      	movs	r3, #0
   39fb0:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
   39fb4:	682f      	ldr	r7, [r5, #0]
   39fb6:	602b      	str	r3, [r5, #0]
   39fb8:	d032      	beq.n	3a020 <__sflush_r+0x98>
   39fba:	6d60      	ldr	r0, [r4, #84]	; 0x54
   39fbc:	89a3      	ldrh	r3, [r4, #12]
   39fbe:	075a      	lsls	r2, r3, #29
   39fc0:	d505      	bpl.n	39fce <__sflush_r+0x46>
   39fc2:	6863      	ldr	r3, [r4, #4]
   39fc4:	1ac0      	subs	r0, r0, r3
   39fc6:	6b63      	ldr	r3, [r4, #52]	; 0x34
   39fc8:	b10b      	cbz	r3, 39fce <__sflush_r+0x46>
   39fca:	6c23      	ldr	r3, [r4, #64]	; 0x40
   39fcc:	1ac0      	subs	r0, r0, r3
   39fce:	2300      	movs	r3, #0
   39fd0:	4602      	mov	r2, r0
   39fd2:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   39fd4:	4628      	mov	r0, r5
   39fd6:	6a21      	ldr	r1, [r4, #32]
   39fd8:	47b0      	blx	r6
   39fda:	1c43      	adds	r3, r0, #1
   39fdc:	89a3      	ldrh	r3, [r4, #12]
   39fde:	d106      	bne.n	39fee <__sflush_r+0x66>
   39fe0:	6829      	ldr	r1, [r5, #0]
   39fe2:	291d      	cmp	r1, #29
   39fe4:	d82c      	bhi.n	3a040 <__sflush_r+0xb8>
   39fe6:	4a29      	ldr	r2, [pc, #164]	; (3a08c <__sflush_r+0x104>)
   39fe8:	40ca      	lsrs	r2, r1
   39fea:	07d6      	lsls	r6, r2, #31
   39fec:	d528      	bpl.n	3a040 <__sflush_r+0xb8>
   39fee:	2200      	movs	r2, #0
   39ff0:	04d9      	lsls	r1, r3, #19
   39ff2:	6062      	str	r2, [r4, #4]
   39ff4:	6922      	ldr	r2, [r4, #16]
   39ff6:	6022      	str	r2, [r4, #0]
   39ff8:	d504      	bpl.n	3a004 <__sflush_r+0x7c>
   39ffa:	1c42      	adds	r2, r0, #1
   39ffc:	d101      	bne.n	3a002 <__sflush_r+0x7a>
   39ffe:	682b      	ldr	r3, [r5, #0]
   3a000:	b903      	cbnz	r3, 3a004 <__sflush_r+0x7c>
   3a002:	6560      	str	r0, [r4, #84]	; 0x54
   3a004:	6b61      	ldr	r1, [r4, #52]	; 0x34
   3a006:	602f      	str	r7, [r5, #0]
   3a008:	2900      	cmp	r1, #0
   3a00a:	d0ca      	beq.n	39fa2 <__sflush_r+0x1a>
   3a00c:	f104 0344 	add.w	r3, r4, #68	; 0x44
   3a010:	4299      	cmp	r1, r3
   3a012:	d002      	beq.n	3a01a <__sflush_r+0x92>
   3a014:	4628      	mov	r0, r5
   3a016:	f000 f9d1 	bl	3a3bc <_free_r>
   3a01a:	2000      	movs	r0, #0
   3a01c:	6360      	str	r0, [r4, #52]	; 0x34
   3a01e:	e7c1      	b.n	39fa4 <__sflush_r+0x1c>
   3a020:	6a21      	ldr	r1, [r4, #32]
   3a022:	2301      	movs	r3, #1
   3a024:	4628      	mov	r0, r5
   3a026:	47b0      	blx	r6
   3a028:	1c41      	adds	r1, r0, #1
   3a02a:	d1c7      	bne.n	39fbc <__sflush_r+0x34>
   3a02c:	682b      	ldr	r3, [r5, #0]
   3a02e:	2b00      	cmp	r3, #0
   3a030:	d0c4      	beq.n	39fbc <__sflush_r+0x34>
   3a032:	2b1d      	cmp	r3, #29
   3a034:	d001      	beq.n	3a03a <__sflush_r+0xb2>
   3a036:	2b16      	cmp	r3, #22
   3a038:	d101      	bne.n	3a03e <__sflush_r+0xb6>
   3a03a:	602f      	str	r7, [r5, #0]
   3a03c:	e7b1      	b.n	39fa2 <__sflush_r+0x1a>
   3a03e:	89a3      	ldrh	r3, [r4, #12]
   3a040:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   3a044:	81a3      	strh	r3, [r4, #12]
   3a046:	e7ad      	b.n	39fa4 <__sflush_r+0x1c>
   3a048:	690f      	ldr	r7, [r1, #16]
   3a04a:	2f00      	cmp	r7, #0
   3a04c:	d0a9      	beq.n	39fa2 <__sflush_r+0x1a>
   3a04e:	0793      	lsls	r3, r2, #30
   3a050:	680e      	ldr	r6, [r1, #0]
   3a052:	600f      	str	r7, [r1, #0]
   3a054:	bf0c      	ite	eq
   3a056:	694b      	ldreq	r3, [r1, #20]
   3a058:	2300      	movne	r3, #0
   3a05a:	eba6 0807 	sub.w	r8, r6, r7
   3a05e:	608b      	str	r3, [r1, #8]
   3a060:	f1b8 0f00 	cmp.w	r8, #0
   3a064:	dd9d      	ble.n	39fa2 <__sflush_r+0x1a>
   3a066:	4643      	mov	r3, r8
   3a068:	463a      	mov	r2, r7
   3a06a:	6a21      	ldr	r1, [r4, #32]
   3a06c:	4628      	mov	r0, r5
   3a06e:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   3a070:	47b0      	blx	r6
   3a072:	2800      	cmp	r0, #0
   3a074:	dc06      	bgt.n	3a084 <__sflush_r+0xfc>
   3a076:	89a3      	ldrh	r3, [r4, #12]
   3a078:	f04f 30ff 	mov.w	r0, #4294967295
   3a07c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   3a080:	81a3      	strh	r3, [r4, #12]
   3a082:	e78f      	b.n	39fa4 <__sflush_r+0x1c>
   3a084:	4407      	add	r7, r0
   3a086:	eba8 0800 	sub.w	r8, r8, r0
   3a08a:	e7e9      	b.n	3a060 <__sflush_r+0xd8>
   3a08c:	20400001 	.word	0x20400001

0003a090 <_fflush_r>:
   3a090:	b538      	push	{r3, r4, r5, lr}
   3a092:	690b      	ldr	r3, [r1, #16]
   3a094:	4605      	mov	r5, r0
   3a096:	460c      	mov	r4, r1
   3a098:	b913      	cbnz	r3, 3a0a0 <_fflush_r+0x10>
   3a09a:	2500      	movs	r5, #0
   3a09c:	4628      	mov	r0, r5
   3a09e:	bd38      	pop	{r3, r4, r5, pc}
   3a0a0:	b118      	cbz	r0, 3a0aa <_fflush_r+0x1a>
   3a0a2:	6983      	ldr	r3, [r0, #24]
   3a0a4:	b90b      	cbnz	r3, 3a0aa <_fflush_r+0x1a>
   3a0a6:	f000 f871 	bl	3a18c <__sinit>
   3a0aa:	4b14      	ldr	r3, [pc, #80]	; (3a0fc <_fflush_r+0x6c>)
   3a0ac:	429c      	cmp	r4, r3
   3a0ae:	d11b      	bne.n	3a0e8 <_fflush_r+0x58>
   3a0b0:	686c      	ldr	r4, [r5, #4]
   3a0b2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   3a0b6:	2b00      	cmp	r3, #0
   3a0b8:	d0ef      	beq.n	3a09a <_fflush_r+0xa>
   3a0ba:	6e62      	ldr	r2, [r4, #100]	; 0x64
   3a0bc:	07d0      	lsls	r0, r2, #31
   3a0be:	d404      	bmi.n	3a0ca <_fflush_r+0x3a>
   3a0c0:	0599      	lsls	r1, r3, #22
   3a0c2:	d402      	bmi.n	3a0ca <_fflush_r+0x3a>
   3a0c4:	6da0      	ldr	r0, [r4, #88]	; 0x58
   3a0c6:	f004 fe84 	bl	3edd2 <__retarget_lock_acquire_recursive>
   3a0ca:	4628      	mov	r0, r5
   3a0cc:	4621      	mov	r1, r4
   3a0ce:	f7ff ff5b 	bl	39f88 <__sflush_r>
   3a0d2:	6e63      	ldr	r3, [r4, #100]	; 0x64
   3a0d4:	4605      	mov	r5, r0
   3a0d6:	07da      	lsls	r2, r3, #31
   3a0d8:	d4e0      	bmi.n	3a09c <_fflush_r+0xc>
   3a0da:	89a3      	ldrh	r3, [r4, #12]
   3a0dc:	059b      	lsls	r3, r3, #22
   3a0de:	d4dd      	bmi.n	3a09c <_fflush_r+0xc>
   3a0e0:	6da0      	ldr	r0, [r4, #88]	; 0x58
   3a0e2:	f004 fe77 	bl	3edd4 <__retarget_lock_release_recursive>
   3a0e6:	e7d9      	b.n	3a09c <_fflush_r+0xc>
   3a0e8:	4b05      	ldr	r3, [pc, #20]	; (3a100 <_fflush_r+0x70>)
   3a0ea:	429c      	cmp	r4, r3
   3a0ec:	d101      	bne.n	3a0f2 <_fflush_r+0x62>
   3a0ee:	68ac      	ldr	r4, [r5, #8]
   3a0f0:	e7df      	b.n	3a0b2 <_fflush_r+0x22>
   3a0f2:	4b04      	ldr	r3, [pc, #16]	; (3a104 <_fflush_r+0x74>)
   3a0f4:	429c      	cmp	r4, r3
   3a0f6:	bf08      	it	eq
   3a0f8:	68ec      	ldreq	r4, [r5, #12]
   3a0fa:	e7da      	b.n	3a0b2 <_fflush_r+0x22>
   3a0fc:	000403a0 	.word	0x000403a0
   3a100:	000403c0 	.word	0x000403c0
   3a104:	00040380 	.word	0x00040380

0003a108 <std>:
   3a108:	2300      	movs	r3, #0
   3a10a:	b510      	push	{r4, lr}
   3a10c:	4604      	mov	r4, r0
   3a10e:	6083      	str	r3, [r0, #8]
   3a110:	8181      	strh	r1, [r0, #12]
   3a112:	4619      	mov	r1, r3
   3a114:	6643      	str	r3, [r0, #100]	; 0x64
   3a116:	81c2      	strh	r2, [r0, #14]
   3a118:	2208      	movs	r2, #8
   3a11a:	6183      	str	r3, [r0, #24]
   3a11c:	e9c0 3300 	strd	r3, r3, [r0]
   3a120:	e9c0 3304 	strd	r3, r3, [r0, #16]
   3a124:	305c      	adds	r0, #92	; 0x5c
   3a126:	f004 fbb1 	bl	3e88c <memset>
   3a12a:	4b05      	ldr	r3, [pc, #20]	; (3a140 <std+0x38>)
   3a12c:	6224      	str	r4, [r4, #32]
   3a12e:	6263      	str	r3, [r4, #36]	; 0x24
   3a130:	4b04      	ldr	r3, [pc, #16]	; (3a144 <std+0x3c>)
   3a132:	62a3      	str	r3, [r4, #40]	; 0x28
   3a134:	4b04      	ldr	r3, [pc, #16]	; (3a148 <std+0x40>)
   3a136:	62e3      	str	r3, [r4, #44]	; 0x2c
   3a138:	4b04      	ldr	r3, [pc, #16]	; (3a14c <std+0x44>)
   3a13a:	6323      	str	r3, [r4, #48]	; 0x30
   3a13c:	bd10      	pop	{r4, pc}
   3a13e:	bf00      	nop
   3a140:	0003f4db 	.word	0x0003f4db
   3a144:	0003f4fd 	.word	0x0003f4fd
   3a148:	0003f535 	.word	0x0003f535
   3a14c:	0003f559 	.word	0x0003f559

0003a150 <_cleanup_r>:
   3a150:	4901      	ldr	r1, [pc, #4]	; (3a158 <_cleanup_r+0x8>)
   3a152:	f004 be1f 	b.w	3ed94 <_fwalk_reent>
   3a156:	bf00      	nop
   3a158:	0003a091 	.word	0x0003a091

0003a15c <__sfp_lock_acquire>:
   3a15c:	4801      	ldr	r0, [pc, #4]	; (3a164 <__sfp_lock_acquire+0x8>)
   3a15e:	f004 be38 	b.w	3edd2 <__retarget_lock_acquire_recursive>
   3a162:	bf00      	nop
   3a164:	2002d944 	.word	0x2002d944

0003a168 <__sfp_lock_release>:
   3a168:	4801      	ldr	r0, [pc, #4]	; (3a170 <__sfp_lock_release+0x8>)
   3a16a:	f004 be33 	b.w	3edd4 <__retarget_lock_release_recursive>
   3a16e:	bf00      	nop
   3a170:	2002d944 	.word	0x2002d944

0003a174 <__sinit_lock_acquire>:
   3a174:	4801      	ldr	r0, [pc, #4]	; (3a17c <__sinit_lock_acquire+0x8>)
   3a176:	f004 be2c 	b.w	3edd2 <__retarget_lock_acquire_recursive>
   3a17a:	bf00      	nop
   3a17c:	2002d93f 	.word	0x2002d93f

0003a180 <__sinit_lock_release>:
   3a180:	4801      	ldr	r0, [pc, #4]	; (3a188 <__sinit_lock_release+0x8>)
   3a182:	f004 be27 	b.w	3edd4 <__retarget_lock_release_recursive>
   3a186:	bf00      	nop
   3a188:	2002d93f 	.word	0x2002d93f

0003a18c <__sinit>:
   3a18c:	b510      	push	{r4, lr}
   3a18e:	4604      	mov	r4, r0
   3a190:	f7ff fff0 	bl	3a174 <__sinit_lock_acquire>
   3a194:	69a3      	ldr	r3, [r4, #24]
   3a196:	b11b      	cbz	r3, 3a1a0 <__sinit+0x14>
   3a198:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   3a19c:	f7ff bff0 	b.w	3a180 <__sinit_lock_release>
   3a1a0:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
   3a1a4:	6523      	str	r3, [r4, #80]	; 0x50
   3a1a6:	4620      	mov	r0, r4
   3a1a8:	4b12      	ldr	r3, [pc, #72]	; (3a1f4 <__sinit+0x68>)
   3a1aa:	4a13      	ldr	r2, [pc, #76]	; (3a1f8 <__sinit+0x6c>)
   3a1ac:	681b      	ldr	r3, [r3, #0]
   3a1ae:	62a2      	str	r2, [r4, #40]	; 0x28
   3a1b0:	42a3      	cmp	r3, r4
   3a1b2:	bf04      	itt	eq
   3a1b4:	2301      	moveq	r3, #1
   3a1b6:	61a3      	streq	r3, [r4, #24]
   3a1b8:	f000 f820 	bl	3a1fc <__sfp>
   3a1bc:	6060      	str	r0, [r4, #4]
   3a1be:	4620      	mov	r0, r4
   3a1c0:	f000 f81c 	bl	3a1fc <__sfp>
   3a1c4:	60a0      	str	r0, [r4, #8]
   3a1c6:	4620      	mov	r0, r4
   3a1c8:	f000 f818 	bl	3a1fc <__sfp>
   3a1cc:	2200      	movs	r2, #0
   3a1ce:	60e0      	str	r0, [r4, #12]
   3a1d0:	2104      	movs	r1, #4
   3a1d2:	6860      	ldr	r0, [r4, #4]
   3a1d4:	f7ff ff98 	bl	3a108 <std>
   3a1d8:	2201      	movs	r2, #1
   3a1da:	2109      	movs	r1, #9
   3a1dc:	68a0      	ldr	r0, [r4, #8]
   3a1de:	f7ff ff93 	bl	3a108 <std>
   3a1e2:	2202      	movs	r2, #2
   3a1e4:	2112      	movs	r1, #18
   3a1e6:	68e0      	ldr	r0, [r4, #12]
   3a1e8:	f7ff ff8e 	bl	3a108 <std>
   3a1ec:	2301      	movs	r3, #1
   3a1ee:	61a3      	str	r3, [r4, #24]
   3a1f0:	e7d2      	b.n	3a198 <__sinit+0xc>
   3a1f2:	bf00      	nop
   3a1f4:	0004037c 	.word	0x0004037c
   3a1f8:	0003a151 	.word	0x0003a151

0003a1fc <__sfp>:
   3a1fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3a1fe:	4607      	mov	r7, r0
   3a200:	f7ff ffac 	bl	3a15c <__sfp_lock_acquire>
   3a204:	4b1e      	ldr	r3, [pc, #120]	; (3a280 <__sfp+0x84>)
   3a206:	681e      	ldr	r6, [r3, #0]
   3a208:	69b3      	ldr	r3, [r6, #24]
   3a20a:	b913      	cbnz	r3, 3a212 <__sfp+0x16>
   3a20c:	4630      	mov	r0, r6
   3a20e:	f7ff ffbd 	bl	3a18c <__sinit>
   3a212:	3648      	adds	r6, #72	; 0x48
   3a214:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
   3a218:	3b01      	subs	r3, #1
   3a21a:	d503      	bpl.n	3a224 <__sfp+0x28>
   3a21c:	6833      	ldr	r3, [r6, #0]
   3a21e:	b30b      	cbz	r3, 3a264 <__sfp+0x68>
   3a220:	6836      	ldr	r6, [r6, #0]
   3a222:	e7f7      	b.n	3a214 <__sfp+0x18>
   3a224:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
   3a228:	b9d5      	cbnz	r5, 3a260 <__sfp+0x64>
   3a22a:	4b16      	ldr	r3, [pc, #88]	; (3a284 <__sfp+0x88>)
   3a22c:	f104 0058 	add.w	r0, r4, #88	; 0x58
   3a230:	6665      	str	r5, [r4, #100]	; 0x64
   3a232:	60e3      	str	r3, [r4, #12]
   3a234:	f004 fdcc 	bl	3edd0 <__retarget_lock_init_recursive>
   3a238:	f7ff ff96 	bl	3a168 <__sfp_lock_release>
   3a23c:	6025      	str	r5, [r4, #0]
   3a23e:	61a5      	str	r5, [r4, #24]
   3a240:	2208      	movs	r2, #8
   3a242:	4629      	mov	r1, r5
   3a244:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   3a248:	e9c4 5501 	strd	r5, r5, [r4, #4]
   3a24c:	e9c4 5504 	strd	r5, r5, [r4, #16]
   3a250:	f004 fb1c 	bl	3e88c <memset>
   3a254:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
   3a258:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
   3a25c:	4620      	mov	r0, r4
   3a25e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   3a260:	3468      	adds	r4, #104	; 0x68
   3a262:	e7d9      	b.n	3a218 <__sfp+0x1c>
   3a264:	2104      	movs	r1, #4
   3a266:	4638      	mov	r0, r7
   3a268:	f004 fd7e 	bl	3ed68 <__sfmoreglue>
   3a26c:	4604      	mov	r4, r0
   3a26e:	6030      	str	r0, [r6, #0]
   3a270:	2800      	cmp	r0, #0
   3a272:	d1d5      	bne.n	3a220 <__sfp+0x24>
   3a274:	f7ff ff78 	bl	3a168 <__sfp_lock_release>
   3a278:	230c      	movs	r3, #12
   3a27a:	603b      	str	r3, [r7, #0]
   3a27c:	e7ee      	b.n	3a25c <__sfp+0x60>
   3a27e:	bf00      	nop
   3a280:	0004037c 	.word	0x0004037c
   3a284:	ffff0001 	.word	0xffff0001

0003a288 <_localeconv_r>:
   3a288:	4800      	ldr	r0, [pc, #0]	; (3a28c <_localeconv_r+0x4>)
   3a28a:	4770      	bx	lr
   3a28c:	2003485c 	.word	0x2003485c

0003a290 <__smakebuf_r>:
   3a290:	898b      	ldrh	r3, [r1, #12]
   3a292:	b573      	push	{r0, r1, r4, r5, r6, lr}
   3a294:	079d      	lsls	r5, r3, #30
   3a296:	4606      	mov	r6, r0
   3a298:	460c      	mov	r4, r1
   3a29a:	d507      	bpl.n	3a2ac <__smakebuf_r+0x1c>
   3a29c:	f104 0347 	add.w	r3, r4, #71	; 0x47
   3a2a0:	6023      	str	r3, [r4, #0]
   3a2a2:	6123      	str	r3, [r4, #16]
   3a2a4:	2301      	movs	r3, #1
   3a2a6:	6163      	str	r3, [r4, #20]
   3a2a8:	b002      	add	sp, #8
   3a2aa:	bd70      	pop	{r4, r5, r6, pc}
   3a2ac:	ab01      	add	r3, sp, #4
   3a2ae:	466a      	mov	r2, sp
   3a2b0:	f004 fd91 	bl	3edd6 <__swhatbuf_r>
   3a2b4:	9900      	ldr	r1, [sp, #0]
   3a2b6:	4605      	mov	r5, r0
   3a2b8:	4630      	mov	r0, r6
   3a2ba:	f000 f8cd 	bl	3a458 <_malloc_r>
   3a2be:	b948      	cbnz	r0, 3a2d4 <__smakebuf_r+0x44>
   3a2c0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   3a2c4:	059a      	lsls	r2, r3, #22
   3a2c6:	d4ef      	bmi.n	3a2a8 <__smakebuf_r+0x18>
   3a2c8:	f023 0303 	bic.w	r3, r3, #3
   3a2cc:	f043 0302 	orr.w	r3, r3, #2
   3a2d0:	81a3      	strh	r3, [r4, #12]
   3a2d2:	e7e3      	b.n	3a29c <__smakebuf_r+0xc>
   3a2d4:	4b0d      	ldr	r3, [pc, #52]	; (3a30c <__smakebuf_r+0x7c>)
   3a2d6:	62b3      	str	r3, [r6, #40]	; 0x28
   3a2d8:	89a3      	ldrh	r3, [r4, #12]
   3a2da:	6020      	str	r0, [r4, #0]
   3a2dc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   3a2e0:	6120      	str	r0, [r4, #16]
   3a2e2:	81a3      	strh	r3, [r4, #12]
   3a2e4:	9b00      	ldr	r3, [sp, #0]
   3a2e6:	6163      	str	r3, [r4, #20]
   3a2e8:	9b01      	ldr	r3, [sp, #4]
   3a2ea:	b15b      	cbz	r3, 3a304 <__smakebuf_r+0x74>
   3a2ec:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   3a2f0:	4630      	mov	r0, r6
   3a2f2:	f000 fa61 	bl	3a7b8 <_isatty_r>
   3a2f6:	b128      	cbz	r0, 3a304 <__smakebuf_r+0x74>
   3a2f8:	89a3      	ldrh	r3, [r4, #12]
   3a2fa:	f023 0303 	bic.w	r3, r3, #3
   3a2fe:	f043 0301 	orr.w	r3, r3, #1
   3a302:	81a3      	strh	r3, [r4, #12]
   3a304:	89a3      	ldrh	r3, [r4, #12]
   3a306:	431d      	orrs	r5, r3
   3a308:	81a5      	strh	r5, [r4, #12]
   3a30a:	e7cd      	b.n	3a2a8 <__smakebuf_r+0x18>
   3a30c:	0003a151 	.word	0x0003a151

0003a310 <malloc>:
   3a310:	4b02      	ldr	r3, [pc, #8]	; (3a31c <malloc+0xc>)
   3a312:	4601      	mov	r1, r0
   3a314:	6818      	ldr	r0, [r3, #0]
   3a316:	f000 b89f 	b.w	3a458 <_malloc_r>
   3a31a:	bf00      	nop
   3a31c:	20034708 	.word	0x20034708

0003a320 <__pow5mult>:
   3a320:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   3a324:	4615      	mov	r5, r2
   3a326:	f012 0203 	ands.w	r2, r2, #3
   3a32a:	4606      	mov	r6, r0
   3a32c:	460f      	mov	r7, r1
   3a32e:	d007      	beq.n	3a340 <__pow5mult+0x20>
   3a330:	3a01      	subs	r2, #1
   3a332:	4c21      	ldr	r4, [pc, #132]	; (3a3b8 <__pow5mult+0x98>)
   3a334:	2300      	movs	r3, #0
   3a336:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
   3a33a:	f004 fdd5 	bl	3eee8 <__multadd>
   3a33e:	4607      	mov	r7, r0
   3a340:	10ad      	asrs	r5, r5, #2
   3a342:	d035      	beq.n	3a3b0 <__pow5mult+0x90>
   3a344:	6a74      	ldr	r4, [r6, #36]	; 0x24
   3a346:	b93c      	cbnz	r4, 3a358 <__pow5mult+0x38>
   3a348:	2010      	movs	r0, #16
   3a34a:	f7ff ffe1 	bl	3a310 <malloc>
   3a34e:	6270      	str	r0, [r6, #36]	; 0x24
   3a350:	6004      	str	r4, [r0, #0]
   3a352:	60c4      	str	r4, [r0, #12]
   3a354:	e9c0 4401 	strd	r4, r4, [r0, #4]
   3a358:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
   3a35c:	f8d8 4008 	ldr.w	r4, [r8, #8]
   3a360:	b94c      	cbnz	r4, 3a376 <__pow5mult+0x56>
   3a362:	f240 2171 	movw	r1, #625	; 0x271
   3a366:	4630      	mov	r0, r6
   3a368:	f004 fe4b 	bl	3f002 <__i2b>
   3a36c:	2300      	movs	r3, #0
   3a36e:	4604      	mov	r4, r0
   3a370:	f8c8 0008 	str.w	r0, [r8, #8]
   3a374:	6003      	str	r3, [r0, #0]
   3a376:	f04f 0800 	mov.w	r8, #0
   3a37a:	07eb      	lsls	r3, r5, #31
   3a37c:	d50a      	bpl.n	3a394 <__pow5mult+0x74>
   3a37e:	4639      	mov	r1, r7
   3a380:	4622      	mov	r2, r4
   3a382:	4630      	mov	r0, r6
   3a384:	f004 fe46 	bl	3f014 <__multiply>
   3a388:	4681      	mov	r9, r0
   3a38a:	4639      	mov	r1, r7
   3a38c:	4630      	mov	r0, r6
   3a38e:	464f      	mov	r7, r9
   3a390:	f004 fd93 	bl	3eeba <_Bfree>
   3a394:	106d      	asrs	r5, r5, #1
   3a396:	d00b      	beq.n	3a3b0 <__pow5mult+0x90>
   3a398:	6820      	ldr	r0, [r4, #0]
   3a39a:	b938      	cbnz	r0, 3a3ac <__pow5mult+0x8c>
   3a39c:	4622      	mov	r2, r4
   3a39e:	4621      	mov	r1, r4
   3a3a0:	4630      	mov	r0, r6
   3a3a2:	f004 fe37 	bl	3f014 <__multiply>
   3a3a6:	6020      	str	r0, [r4, #0]
   3a3a8:	f8c0 8000 	str.w	r8, [r0]
   3a3ac:	4604      	mov	r4, r0
   3a3ae:	e7e4      	b.n	3a37a <__pow5mult+0x5a>
   3a3b0:	4638      	mov	r0, r7
   3a3b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   3a3b6:	bf00      	nop
   3a3b8:	000403e0 	.word	0x000403e0

0003a3bc <_free_r>:
   3a3bc:	b538      	push	{r3, r4, r5, lr}
   3a3be:	4605      	mov	r5, r0
   3a3c0:	2900      	cmp	r1, #0
   3a3c2:	d045      	beq.n	3a450 <_free_r+0x94>
   3a3c4:	f851 3c04 	ldr.w	r3, [r1, #-4]
   3a3c8:	1f0c      	subs	r4, r1, #4
   3a3ca:	2b00      	cmp	r3, #0
   3a3cc:	bfb8      	it	lt
   3a3ce:	18e4      	addlt	r4, r4, r3
   3a3d0:	f000 fa14 	bl	3a7fc <__malloc_lock>
   3a3d4:	4a1f      	ldr	r2, [pc, #124]	; (3a454 <_free_r+0x98>)
   3a3d6:	6813      	ldr	r3, [r2, #0]
   3a3d8:	4610      	mov	r0, r2
   3a3da:	b933      	cbnz	r3, 3a3ea <_free_r+0x2e>
   3a3dc:	6063      	str	r3, [r4, #4]
   3a3de:	6014      	str	r4, [r2, #0]
   3a3e0:	4628      	mov	r0, r5
   3a3e2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   3a3e6:	f000 ba0f 	b.w	3a808 <__malloc_unlock>
   3a3ea:	42a3      	cmp	r3, r4
   3a3ec:	d90c      	bls.n	3a408 <_free_r+0x4c>
   3a3ee:	6821      	ldr	r1, [r4, #0]
   3a3f0:	1862      	adds	r2, r4, r1
   3a3f2:	4293      	cmp	r3, r2
   3a3f4:	bf02      	ittt	eq
   3a3f6:	681a      	ldreq	r2, [r3, #0]
   3a3f8:	685b      	ldreq	r3, [r3, #4]
   3a3fa:	1852      	addeq	r2, r2, r1
   3a3fc:	6063      	str	r3, [r4, #4]
   3a3fe:	bf08      	it	eq
   3a400:	6022      	streq	r2, [r4, #0]
   3a402:	6004      	str	r4, [r0, #0]
   3a404:	e7ec      	b.n	3a3e0 <_free_r+0x24>
   3a406:	4613      	mov	r3, r2
   3a408:	685a      	ldr	r2, [r3, #4]
   3a40a:	b10a      	cbz	r2, 3a410 <_free_r+0x54>
   3a40c:	42a2      	cmp	r2, r4
   3a40e:	d9fa      	bls.n	3a406 <_free_r+0x4a>
   3a410:	6819      	ldr	r1, [r3, #0]
   3a412:	1858      	adds	r0, r3, r1
   3a414:	42a0      	cmp	r0, r4
   3a416:	d10b      	bne.n	3a430 <_free_r+0x74>
   3a418:	6820      	ldr	r0, [r4, #0]
   3a41a:	4401      	add	r1, r0
   3a41c:	1858      	adds	r0, r3, r1
   3a41e:	6019      	str	r1, [r3, #0]
   3a420:	4282      	cmp	r2, r0
   3a422:	d1dd      	bne.n	3a3e0 <_free_r+0x24>
   3a424:	6810      	ldr	r0, [r2, #0]
   3a426:	6852      	ldr	r2, [r2, #4]
   3a428:	4401      	add	r1, r0
   3a42a:	605a      	str	r2, [r3, #4]
   3a42c:	6019      	str	r1, [r3, #0]
   3a42e:	e7d7      	b.n	3a3e0 <_free_r+0x24>
   3a430:	d902      	bls.n	3a438 <_free_r+0x7c>
   3a432:	230c      	movs	r3, #12
   3a434:	602b      	str	r3, [r5, #0]
   3a436:	e7d3      	b.n	3a3e0 <_free_r+0x24>
   3a438:	6820      	ldr	r0, [r4, #0]
   3a43a:	1821      	adds	r1, r4, r0
   3a43c:	428a      	cmp	r2, r1
   3a43e:	bf02      	ittt	eq
   3a440:	6811      	ldreq	r1, [r2, #0]
   3a442:	6852      	ldreq	r2, [r2, #4]
   3a444:	1809      	addeq	r1, r1, r0
   3a446:	6062      	str	r2, [r4, #4]
   3a448:	bf08      	it	eq
   3a44a:	6021      	streq	r1, [r4, #0]
   3a44c:	605c      	str	r4, [r3, #4]
   3a44e:	e7c7      	b.n	3a3e0 <_free_r+0x24>
   3a450:	bd38      	pop	{r3, r4, r5, pc}
   3a452:	bf00      	nop
   3a454:	2002988c 	.word	0x2002988c

0003a458 <_malloc_r>:
   3a458:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3a45a:	1ccd      	adds	r5, r1, #3
   3a45c:	4606      	mov	r6, r0
   3a45e:	f025 0503 	bic.w	r5, r5, #3
   3a462:	3508      	adds	r5, #8
   3a464:	2d0c      	cmp	r5, #12
   3a466:	bf38      	it	cc
   3a468:	250c      	movcc	r5, #12
   3a46a:	2d00      	cmp	r5, #0
   3a46c:	db01      	blt.n	3a472 <_malloc_r+0x1a>
   3a46e:	42a9      	cmp	r1, r5
   3a470:	d903      	bls.n	3a47a <_malloc_r+0x22>
   3a472:	230c      	movs	r3, #12
   3a474:	6033      	str	r3, [r6, #0]
   3a476:	2000      	movs	r0, #0
   3a478:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   3a47a:	f000 f9bf 	bl	3a7fc <__malloc_lock>
   3a47e:	4921      	ldr	r1, [pc, #132]	; (3a504 <_malloc_r+0xac>)
   3a480:	680a      	ldr	r2, [r1, #0]
   3a482:	4614      	mov	r4, r2
   3a484:	b99c      	cbnz	r4, 3a4ae <_malloc_r+0x56>
   3a486:	4f20      	ldr	r7, [pc, #128]	; (3a508 <_malloc_r+0xb0>)
   3a488:	683b      	ldr	r3, [r7, #0]
   3a48a:	b923      	cbnz	r3, 3a496 <_malloc_r+0x3e>
   3a48c:	4621      	mov	r1, r4
   3a48e:	4630      	mov	r0, r6
   3a490:	f000 f934 	bl	3a6fc <_sbrk_r>
   3a494:	6038      	str	r0, [r7, #0]
   3a496:	4629      	mov	r1, r5
   3a498:	4630      	mov	r0, r6
   3a49a:	f000 f92f 	bl	3a6fc <_sbrk_r>
   3a49e:	1c43      	adds	r3, r0, #1
   3a4a0:	d123      	bne.n	3a4ea <_malloc_r+0x92>
   3a4a2:	230c      	movs	r3, #12
   3a4a4:	4630      	mov	r0, r6
   3a4a6:	6033      	str	r3, [r6, #0]
   3a4a8:	f000 f9ae 	bl	3a808 <__malloc_unlock>
   3a4ac:	e7e3      	b.n	3a476 <_malloc_r+0x1e>
   3a4ae:	6823      	ldr	r3, [r4, #0]
   3a4b0:	1b5b      	subs	r3, r3, r5
   3a4b2:	d417      	bmi.n	3a4e4 <_malloc_r+0x8c>
   3a4b4:	2b0b      	cmp	r3, #11
   3a4b6:	d903      	bls.n	3a4c0 <_malloc_r+0x68>
   3a4b8:	6023      	str	r3, [r4, #0]
   3a4ba:	441c      	add	r4, r3
   3a4bc:	6025      	str	r5, [r4, #0]
   3a4be:	e004      	b.n	3a4ca <_malloc_r+0x72>
   3a4c0:	6863      	ldr	r3, [r4, #4]
   3a4c2:	42a2      	cmp	r2, r4
   3a4c4:	bf0c      	ite	eq
   3a4c6:	600b      	streq	r3, [r1, #0]
   3a4c8:	6053      	strne	r3, [r2, #4]
   3a4ca:	4630      	mov	r0, r6
   3a4cc:	f000 f99c 	bl	3a808 <__malloc_unlock>
   3a4d0:	f104 000b 	add.w	r0, r4, #11
   3a4d4:	1d23      	adds	r3, r4, #4
   3a4d6:	f020 0007 	bic.w	r0, r0, #7
   3a4da:	1ac2      	subs	r2, r0, r3
   3a4dc:	d0cc      	beq.n	3a478 <_malloc_r+0x20>
   3a4de:	1a1b      	subs	r3, r3, r0
   3a4e0:	50a3      	str	r3, [r4, r2]
   3a4e2:	e7c9      	b.n	3a478 <_malloc_r+0x20>
   3a4e4:	4622      	mov	r2, r4
   3a4e6:	6864      	ldr	r4, [r4, #4]
   3a4e8:	e7cc      	b.n	3a484 <_malloc_r+0x2c>
   3a4ea:	1cc4      	adds	r4, r0, #3
   3a4ec:	f024 0403 	bic.w	r4, r4, #3
   3a4f0:	42a0      	cmp	r0, r4
   3a4f2:	d0e3      	beq.n	3a4bc <_malloc_r+0x64>
   3a4f4:	1a21      	subs	r1, r4, r0
   3a4f6:	4630      	mov	r0, r6
   3a4f8:	f000 f900 	bl	3a6fc <_sbrk_r>
   3a4fc:	3001      	adds	r0, #1
   3a4fe:	d1dd      	bne.n	3a4bc <_malloc_r+0x64>
   3a500:	e7cf      	b.n	3a4a2 <_malloc_r+0x4a>
   3a502:	bf00      	nop
   3a504:	2002988c 	.word	0x2002988c
   3a508:	20029890 	.word	0x20029890

0003a50c <_svfiprintf_r>:
   3a50c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3a510:	461e      	mov	r6, r3
   3a512:	898b      	ldrh	r3, [r1, #12]
   3a514:	b09d      	sub	sp, #116	; 0x74
   3a516:	4607      	mov	r7, r0
   3a518:	061b      	lsls	r3, r3, #24
   3a51a:	460d      	mov	r5, r1
   3a51c:	4614      	mov	r4, r2
   3a51e:	d50e      	bpl.n	3a53e <_svfiprintf_r+0x32>
   3a520:	690b      	ldr	r3, [r1, #16]
   3a522:	b963      	cbnz	r3, 3a53e <_svfiprintf_r+0x32>
   3a524:	2140      	movs	r1, #64	; 0x40
   3a526:	f7ff ff97 	bl	3a458 <_malloc_r>
   3a52a:	6028      	str	r0, [r5, #0]
   3a52c:	6128      	str	r0, [r5, #16]
   3a52e:	b920      	cbnz	r0, 3a53a <_svfiprintf_r+0x2e>
   3a530:	230c      	movs	r3, #12
   3a532:	603b      	str	r3, [r7, #0]
   3a534:	f04f 30ff 	mov.w	r0, #4294967295
   3a538:	e0c9      	b.n	3a6ce <_svfiprintf_r+0x1c2>
   3a53a:	2340      	movs	r3, #64	; 0x40
   3a53c:	616b      	str	r3, [r5, #20]
   3a53e:	2300      	movs	r3, #0
   3a540:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 3a6e8 <_svfiprintf_r+0x1dc>
   3a544:	f04f 0a01 	mov.w	sl, #1
   3a548:	9603      	str	r6, [sp, #12]
   3a54a:	9309      	str	r3, [sp, #36]	; 0x24
   3a54c:	2320      	movs	r3, #32
   3a54e:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   3a552:	2330      	movs	r3, #48	; 0x30
   3a554:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   3a558:	4623      	mov	r3, r4
   3a55a:	461e      	mov	r6, r3
   3a55c:	f813 2b01 	ldrb.w	r2, [r3], #1
   3a560:	b10a      	cbz	r2, 3a566 <_svfiprintf_r+0x5a>
   3a562:	2a25      	cmp	r2, #37	; 0x25
   3a564:	d1f9      	bne.n	3a55a <_svfiprintf_r+0x4e>
   3a566:	ebb6 0b04 	subs.w	fp, r6, r4
   3a56a:	d00b      	beq.n	3a584 <_svfiprintf_r+0x78>
   3a56c:	465b      	mov	r3, fp
   3a56e:	4622      	mov	r2, r4
   3a570:	4629      	mov	r1, r5
   3a572:	4638      	mov	r0, r7
   3a574:	f004 ff2c 	bl	3f3d0 <__ssputs_r>
   3a578:	3001      	adds	r0, #1
   3a57a:	f000 80a3 	beq.w	3a6c4 <_svfiprintf_r+0x1b8>
   3a57e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   3a580:	445b      	add	r3, fp
   3a582:	9309      	str	r3, [sp, #36]	; 0x24
   3a584:	7833      	ldrb	r3, [r6, #0]
   3a586:	2b00      	cmp	r3, #0
   3a588:	f000 809c 	beq.w	3a6c4 <_svfiprintf_r+0x1b8>
   3a58c:	2300      	movs	r3, #0
   3a58e:	f04f 32ff 	mov.w	r2, #4294967295
   3a592:	3601      	adds	r6, #1
   3a594:	9304      	str	r3, [sp, #16]
   3a596:	9307      	str	r3, [sp, #28]
   3a598:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   3a59c:	931a      	str	r3, [sp, #104]	; 0x68
   3a59e:	e9cd 2305 	strd	r2, r3, [sp, #20]
   3a5a2:	4634      	mov	r4, r6
   3a5a4:	2205      	movs	r2, #5
   3a5a6:	4850      	ldr	r0, [pc, #320]	; (3a6e8 <_svfiprintf_r+0x1dc>)
   3a5a8:	f814 1b01 	ldrb.w	r1, [r4], #1
   3a5ac:	f004 f932 	bl	3e814 <memchr>
   3a5b0:	9b04      	ldr	r3, [sp, #16]
   3a5b2:	b9c0      	cbnz	r0, 3a5e6 <_svfiprintf_r+0xda>
   3a5b4:	06d9      	lsls	r1, r3, #27
   3a5b6:	bf44      	itt	mi
   3a5b8:	2220      	movmi	r2, #32
   3a5ba:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   3a5be:	071a      	lsls	r2, r3, #28
   3a5c0:	bf44      	itt	mi
   3a5c2:	222b      	movmi	r2, #43	; 0x2b
   3a5c4:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   3a5c8:	7832      	ldrb	r2, [r6, #0]
   3a5ca:	2a2a      	cmp	r2, #42	; 0x2a
   3a5cc:	d013      	beq.n	3a5f6 <_svfiprintf_r+0xea>
   3a5ce:	4634      	mov	r4, r6
   3a5d0:	9a07      	ldr	r2, [sp, #28]
   3a5d2:	2000      	movs	r0, #0
   3a5d4:	260a      	movs	r6, #10
   3a5d6:	4621      	mov	r1, r4
   3a5d8:	f811 3b01 	ldrb.w	r3, [r1], #1
   3a5dc:	3b30      	subs	r3, #48	; 0x30
   3a5de:	2b09      	cmp	r3, #9
   3a5e0:	d94b      	bls.n	3a67a <_svfiprintf_r+0x16e>
   3a5e2:	b970      	cbnz	r0, 3a602 <_svfiprintf_r+0xf6>
   3a5e4:	e014      	b.n	3a610 <_svfiprintf_r+0x104>
   3a5e6:	eba0 0009 	sub.w	r0, r0, r9
   3a5ea:	4626      	mov	r6, r4
   3a5ec:	fa0a f000 	lsl.w	r0, sl, r0
   3a5f0:	4318      	orrs	r0, r3
   3a5f2:	9004      	str	r0, [sp, #16]
   3a5f4:	e7d5      	b.n	3a5a2 <_svfiprintf_r+0x96>
   3a5f6:	9a03      	ldr	r2, [sp, #12]
   3a5f8:	1d11      	adds	r1, r2, #4
   3a5fa:	6812      	ldr	r2, [r2, #0]
   3a5fc:	2a00      	cmp	r2, #0
   3a5fe:	9103      	str	r1, [sp, #12]
   3a600:	db01      	blt.n	3a606 <_svfiprintf_r+0xfa>
   3a602:	9207      	str	r2, [sp, #28]
   3a604:	e004      	b.n	3a610 <_svfiprintf_r+0x104>
   3a606:	4252      	negs	r2, r2
   3a608:	f043 0302 	orr.w	r3, r3, #2
   3a60c:	9207      	str	r2, [sp, #28]
   3a60e:	9304      	str	r3, [sp, #16]
   3a610:	7823      	ldrb	r3, [r4, #0]
   3a612:	2b2e      	cmp	r3, #46	; 0x2e
   3a614:	d10c      	bne.n	3a630 <_svfiprintf_r+0x124>
   3a616:	7863      	ldrb	r3, [r4, #1]
   3a618:	2b2a      	cmp	r3, #42	; 0x2a
   3a61a:	d133      	bne.n	3a684 <_svfiprintf_r+0x178>
   3a61c:	9b03      	ldr	r3, [sp, #12]
   3a61e:	3402      	adds	r4, #2
   3a620:	1d1a      	adds	r2, r3, #4
   3a622:	681b      	ldr	r3, [r3, #0]
   3a624:	2b00      	cmp	r3, #0
   3a626:	9203      	str	r2, [sp, #12]
   3a628:	bfb8      	it	lt
   3a62a:	f04f 33ff 	movlt.w	r3, #4294967295
   3a62e:	9305      	str	r3, [sp, #20]
   3a630:	4e2e      	ldr	r6, [pc, #184]	; (3a6ec <_svfiprintf_r+0x1e0>)
   3a632:	2203      	movs	r2, #3
   3a634:	7821      	ldrb	r1, [r4, #0]
   3a636:	4630      	mov	r0, r6
   3a638:	f004 f8ec 	bl	3e814 <memchr>
   3a63c:	b138      	cbz	r0, 3a64e <_svfiprintf_r+0x142>
   3a63e:	2340      	movs	r3, #64	; 0x40
   3a640:	1b80      	subs	r0, r0, r6
   3a642:	3401      	adds	r4, #1
   3a644:	fa03 f000 	lsl.w	r0, r3, r0
   3a648:	9b04      	ldr	r3, [sp, #16]
   3a64a:	4303      	orrs	r3, r0
   3a64c:	9304      	str	r3, [sp, #16]
   3a64e:	f814 1b01 	ldrb.w	r1, [r4], #1
   3a652:	2206      	movs	r2, #6
   3a654:	4826      	ldr	r0, [pc, #152]	; (3a6f0 <_svfiprintf_r+0x1e4>)
   3a656:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   3a65a:	f004 f8db 	bl	3e814 <memchr>
   3a65e:	2800      	cmp	r0, #0
   3a660:	d038      	beq.n	3a6d4 <_svfiprintf_r+0x1c8>
   3a662:	4b24      	ldr	r3, [pc, #144]	; (3a6f4 <_svfiprintf_r+0x1e8>)
   3a664:	bb13      	cbnz	r3, 3a6ac <_svfiprintf_r+0x1a0>
   3a666:	9b03      	ldr	r3, [sp, #12]
   3a668:	3307      	adds	r3, #7
   3a66a:	f023 0307 	bic.w	r3, r3, #7
   3a66e:	3308      	adds	r3, #8
   3a670:	9303      	str	r3, [sp, #12]
   3a672:	9b09      	ldr	r3, [sp, #36]	; 0x24
   3a674:	4443      	add	r3, r8
   3a676:	9309      	str	r3, [sp, #36]	; 0x24
   3a678:	e76e      	b.n	3a558 <_svfiprintf_r+0x4c>
   3a67a:	fb06 3202 	mla	r2, r6, r2, r3
   3a67e:	2001      	movs	r0, #1
   3a680:	460c      	mov	r4, r1
   3a682:	e7a8      	b.n	3a5d6 <_svfiprintf_r+0xca>
   3a684:	2300      	movs	r3, #0
   3a686:	3401      	adds	r4, #1
   3a688:	260a      	movs	r6, #10
   3a68a:	4619      	mov	r1, r3
   3a68c:	9305      	str	r3, [sp, #20]
   3a68e:	4620      	mov	r0, r4
   3a690:	f810 2b01 	ldrb.w	r2, [r0], #1
   3a694:	3a30      	subs	r2, #48	; 0x30
   3a696:	2a09      	cmp	r2, #9
   3a698:	d903      	bls.n	3a6a2 <_svfiprintf_r+0x196>
   3a69a:	2b00      	cmp	r3, #0
   3a69c:	d0c8      	beq.n	3a630 <_svfiprintf_r+0x124>
   3a69e:	9105      	str	r1, [sp, #20]
   3a6a0:	e7c6      	b.n	3a630 <_svfiprintf_r+0x124>
   3a6a2:	fb06 2101 	mla	r1, r6, r1, r2
   3a6a6:	2301      	movs	r3, #1
   3a6a8:	4604      	mov	r4, r0
   3a6aa:	e7f0      	b.n	3a68e <_svfiprintf_r+0x182>
   3a6ac:	ab03      	add	r3, sp, #12
   3a6ae:	462a      	mov	r2, r5
   3a6b0:	a904      	add	r1, sp, #16
   3a6b2:	4638      	mov	r0, r7
   3a6b4:	9300      	str	r3, [sp, #0]
   3a6b6:	4b10      	ldr	r3, [pc, #64]	; (3a6f8 <_svfiprintf_r+0x1ec>)
   3a6b8:	f7fe fec2 	bl	39440 <_printf_float>
   3a6bc:	f1b0 3fff 	cmp.w	r0, #4294967295
   3a6c0:	4680      	mov	r8, r0
   3a6c2:	d1d6      	bne.n	3a672 <_svfiprintf_r+0x166>
   3a6c4:	89ab      	ldrh	r3, [r5, #12]
   3a6c6:	065b      	lsls	r3, r3, #25
   3a6c8:	f53f af34 	bmi.w	3a534 <_svfiprintf_r+0x28>
   3a6cc:	9809      	ldr	r0, [sp, #36]	; 0x24
   3a6ce:	b01d      	add	sp, #116	; 0x74
   3a6d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3a6d4:	ab03      	add	r3, sp, #12
   3a6d6:	462a      	mov	r2, r5
   3a6d8:	a904      	add	r1, sp, #16
   3a6da:	4638      	mov	r0, r7
   3a6dc:	9300      	str	r3, [sp, #0]
   3a6de:	4b06      	ldr	r3, [pc, #24]	; (3a6f8 <_svfiprintf_r+0x1ec>)
   3a6e0:	f7ff f8d8 	bl	39894 <_printf_i>
   3a6e4:	e7ea      	b.n	3a6bc <_svfiprintf_r+0x1b0>
   3a6e6:	bf00      	nop
   3a6e8:	00044427 	.word	0x00044427
   3a6ec:	0004442d 	.word	0x0004442d
   3a6f0:	00044431 	.word	0x00044431
   3a6f4:	00039441 	.word	0x00039441
   3a6f8:	0003f3d1 	.word	0x0003f3d1

0003a6fc <_sbrk_r>:
   3a6fc:	b538      	push	{r3, r4, r5, lr}
   3a6fe:	2300      	movs	r3, #0
   3a700:	4c05      	ldr	r4, [pc, #20]	; (3a718 <_sbrk_r+0x1c>)
   3a702:	4605      	mov	r5, r0
   3a704:	4608      	mov	r0, r1
   3a706:	6023      	str	r3, [r4, #0]
   3a708:	f7ee fc82 	bl	29010 <_sbrk>
   3a70c:	1c43      	adds	r3, r0, #1
   3a70e:	d102      	bne.n	3a716 <_sbrk_r+0x1a>
   3a710:	6823      	ldr	r3, [r4, #0]
   3a712:	b103      	cbz	r3, 3a716 <_sbrk_r+0x1a>
   3a714:	602b      	str	r3, [r5, #0]
   3a716:	bd38      	pop	{r3, r4, r5, pc}
   3a718:	2002d938 	.word	0x2002d938

0003a71c <raise>:
   3a71c:	4b02      	ldr	r3, [pc, #8]	; (3a728 <raise+0xc>)
   3a71e:	4601      	mov	r1, r0
   3a720:	6818      	ldr	r0, [r3, #0]
   3a722:	f004 beb0 	b.w	3f486 <_raise_r>
   3a726:	bf00      	nop
   3a728:	20034708 	.word	0x20034708

0003a72c <_kill_r>:
   3a72c:	b538      	push	{r3, r4, r5, lr}
   3a72e:	2300      	movs	r3, #0
   3a730:	4c06      	ldr	r4, [pc, #24]	; (3a74c <_kill_r+0x20>)
   3a732:	4605      	mov	r5, r0
   3a734:	4608      	mov	r0, r1
   3a736:	4611      	mov	r1, r2
   3a738:	6023      	str	r3, [r4, #0]
   3a73a:	f002 f9e9 	bl	3cb10 <_kill>
   3a73e:	1c43      	adds	r3, r0, #1
   3a740:	d102      	bne.n	3a748 <_kill_r+0x1c>
   3a742:	6823      	ldr	r3, [r4, #0]
   3a744:	b103      	cbz	r3, 3a748 <_kill_r+0x1c>
   3a746:	602b      	str	r3, [r5, #0]
   3a748:	bd38      	pop	{r3, r4, r5, pc}
   3a74a:	bf00      	nop
   3a74c:	2002d938 	.word	0x2002d938

0003a750 <_write_r>:
   3a750:	b538      	push	{r3, r4, r5, lr}
   3a752:	4605      	mov	r5, r0
   3a754:	4c06      	ldr	r4, [pc, #24]	; (3a770 <_write_r+0x20>)
   3a756:	4608      	mov	r0, r1
   3a758:	4611      	mov	r1, r2
   3a75a:	2200      	movs	r2, #0
   3a75c:	6022      	str	r2, [r4, #0]
   3a75e:	461a      	mov	r2, r3
   3a760:	f002 f9cb 	bl	3cafa <_write>
   3a764:	1c43      	adds	r3, r0, #1
   3a766:	d102      	bne.n	3a76e <_write_r+0x1e>
   3a768:	6823      	ldr	r3, [r4, #0]
   3a76a:	b103      	cbz	r3, 3a76e <_write_r+0x1e>
   3a76c:	602b      	str	r3, [r5, #0]
   3a76e:	bd38      	pop	{r3, r4, r5, pc}
   3a770:	2002d938 	.word	0x2002d938

0003a774 <_close_r>:
   3a774:	b538      	push	{r3, r4, r5, lr}
   3a776:	2300      	movs	r3, #0
   3a778:	4c05      	ldr	r4, [pc, #20]	; (3a790 <_close_r+0x1c>)
   3a77a:	4605      	mov	r5, r0
   3a77c:	4608      	mov	r0, r1
   3a77e:	6023      	str	r3, [r4, #0]
   3a780:	f002 f9bf 	bl	3cb02 <_close>
   3a784:	1c43      	adds	r3, r0, #1
   3a786:	d102      	bne.n	3a78e <_close_r+0x1a>
   3a788:	6823      	ldr	r3, [r4, #0]
   3a78a:	b103      	cbz	r3, 3a78e <_close_r+0x1a>
   3a78c:	602b      	str	r3, [r5, #0]
   3a78e:	bd38      	pop	{r3, r4, r5, pc}
   3a790:	2002d938 	.word	0x2002d938

0003a794 <_fstat_r>:
   3a794:	b538      	push	{r3, r4, r5, lr}
   3a796:	2300      	movs	r3, #0
   3a798:	4c06      	ldr	r4, [pc, #24]	; (3a7b4 <_fstat_r+0x20>)
   3a79a:	4605      	mov	r5, r0
   3a79c:	4608      	mov	r0, r1
   3a79e:	4611      	mov	r1, r2
   3a7a0:	6023      	str	r3, [r4, #0]
   3a7a2:	f002 f9b9 	bl	3cb18 <_fstat>
   3a7a6:	1c43      	adds	r3, r0, #1
   3a7a8:	d102      	bne.n	3a7b0 <_fstat_r+0x1c>
   3a7aa:	6823      	ldr	r3, [r4, #0]
   3a7ac:	b103      	cbz	r3, 3a7b0 <_fstat_r+0x1c>
   3a7ae:	602b      	str	r3, [r5, #0]
   3a7b0:	bd38      	pop	{r3, r4, r5, pc}
   3a7b2:	bf00      	nop
   3a7b4:	2002d938 	.word	0x2002d938

0003a7b8 <_isatty_r>:
   3a7b8:	b538      	push	{r3, r4, r5, lr}
   3a7ba:	2300      	movs	r3, #0
   3a7bc:	4c05      	ldr	r4, [pc, #20]	; (3a7d4 <_isatty_r+0x1c>)
   3a7be:	4605      	mov	r5, r0
   3a7c0:	4608      	mov	r0, r1
   3a7c2:	6023      	str	r3, [r4, #0]
   3a7c4:	f002 f9a2 	bl	3cb0c <_isatty>
   3a7c8:	1c43      	adds	r3, r0, #1
   3a7ca:	d102      	bne.n	3a7d2 <_isatty_r+0x1a>
   3a7cc:	6823      	ldr	r3, [r4, #0]
   3a7ce:	b103      	cbz	r3, 3a7d2 <_isatty_r+0x1a>
   3a7d0:	602b      	str	r3, [r5, #0]
   3a7d2:	bd38      	pop	{r3, r4, r5, pc}
   3a7d4:	2002d938 	.word	0x2002d938

0003a7d8 <_lseek_r>:
   3a7d8:	b538      	push	{r3, r4, r5, lr}
   3a7da:	4605      	mov	r5, r0
   3a7dc:	4c06      	ldr	r4, [pc, #24]	; (3a7f8 <_lseek_r+0x20>)
   3a7de:	4608      	mov	r0, r1
   3a7e0:	4611      	mov	r1, r2
   3a7e2:	2200      	movs	r2, #0
   3a7e4:	6022      	str	r2, [r4, #0]
   3a7e6:	461a      	mov	r2, r3
   3a7e8:	f002 f98e 	bl	3cb08 <_lseek>
   3a7ec:	1c43      	adds	r3, r0, #1
   3a7ee:	d102      	bne.n	3a7f6 <_lseek_r+0x1e>
   3a7f0:	6823      	ldr	r3, [r4, #0]
   3a7f2:	b103      	cbz	r3, 3a7f6 <_lseek_r+0x1e>
   3a7f4:	602b      	str	r3, [r5, #0]
   3a7f6:	bd38      	pop	{r3, r4, r5, pc}
   3a7f8:	2002d938 	.word	0x2002d938

0003a7fc <__malloc_lock>:
   3a7fc:	4801      	ldr	r0, [pc, #4]	; (3a804 <__malloc_lock+0x8>)
   3a7fe:	f004 bae8 	b.w	3edd2 <__retarget_lock_acquire_recursive>
   3a802:	bf00      	nop
   3a804:	2002d940 	.word	0x2002d940

0003a808 <__malloc_unlock>:
   3a808:	4801      	ldr	r0, [pc, #4]	; (3a810 <__malloc_unlock+0x8>)
   3a80a:	f004 bae3 	b.w	3edd4 <__retarget_lock_release_recursive>
   3a80e:	bf00      	nop
   3a810:	2002d940 	.word	0x2002d940

0003a814 <_read_r>:
   3a814:	b538      	push	{r3, r4, r5, lr}
   3a816:	4605      	mov	r5, r0
   3a818:	4c06      	ldr	r4, [pc, #24]	; (3a834 <_read_r+0x20>)
   3a81a:	4608      	mov	r0, r1
   3a81c:	4611      	mov	r1, r2
   3a81e:	2200      	movs	r2, #0
   3a820:	6022      	str	r2, [r4, #0]
   3a822:	461a      	mov	r2, r3
   3a824:	f002 f965 	bl	3caf2 <_read>
   3a828:	1c43      	adds	r3, r0, #1
   3a82a:	d102      	bne.n	3a832 <_read_r+0x1e>
   3a82c:	6823      	ldr	r3, [r4, #0]
   3a82e:	b103      	cbz	r3, 3a832 <_read_r+0x1e>
   3a830:	602b      	str	r3, [r5, #0]
   3a832:	bd38      	pop	{r3, r4, r5, pc}
   3a834:	2002d938 	.word	0x2002d938

0003a838 <main>:
*    : main 
*    :  
*  : int 
**************************************************************************/
int main(void)
{
   3a838:	b508      	push	{r3, lr}
	work_init();
   3a83a:	f7e5 fd1d 	bl	20278 <work_init>
	system_init();
   3a83e:	f7e5 fcff 	bl	20240 <system_init>
//	test_i2c();
//	test_bat_soc();

	while(1)
	{
		TimeMsgProcess();
   3a842:	f7e6 f813 	bl	2086c <TimeMsgProcess>
		NBMsgProcess();
   3a846:	f7e9 fa61 	bl	23d0c <NBMsgProcess>
		GPSMsgProcess();
   3a84a:	f7e8 fb93 	bl	22f74 <GPSMsgProcess>
		PMUMsgProcess();
   3a84e:	f7eb fb8d 	bl	25f6c <PMUMsgProcess>
		IMUMsgProcess();
   3a852:	f7ea f879 	bl	24948 <IMUMsgProcess>
		LCDMsgProcess();
   3a856:	f7e6 fb09 	bl	20e6c <LCDMsgProcess>
		//TPMsgProcess();
		AlarmMsgProcess();
   3a85a:	f7e6 f92b 	bl	20ab4 <AlarmMsgProcess>
		SettingsMsgPorcess();
   3a85e:	f7e7 f97f 	bl	21b60 <SettingsMsgPorcess>

		ScreenMsgProcess();
   3a862:	f7ea ff5b 	bl	2571c <ScreenMsgProcess>
   3a866:	f7ed fc17 	bl	28098 <arch_cpu_idle>
   3a86a:	e7ea      	b.n	3a842 <main+0xa>

0003a86c <GetWeekDayByDate>:
{
   3a86c:	b082      	sub	sp, #8
   3a86e:	ab02      	add	r3, sp, #8
   3a870:	e903 0003 	stmdb	r3, {r0, r1}
   3a874:	f8bd 1000 	ldrh.w	r1, [sp]
	if(date.year < SYSTEM_STARTING_YEAR)
   3a878:	f5b1 6ff0 	cmp.w	r1, #1920	; 0x780
   3a87c:	d34c      	bcc.n	3a918 <GetWeekDayByDate+0xac>
	u32_t i,count=0;
   3a87e:	2200      	movs	r2, #0
	for(i=SYSTEM_STARTING_YEAR;i<date.year;i++)
   3a880:	f44f 63f0 	mov.w	r3, #1920	; 0x780
   3a884:	4299      	cmp	r1, r3
   3a886:	d813      	bhi.n	3a8b0 <GetWeekDayByDate+0x44>
	if(date.year%4 == 0)
   3a888:	f011 0f03 	tst.w	r1, #3
	switch(date.month)
   3a88c:	f89d 1002 	ldrb.w	r1, [sp, #2]
	if(date.year%4 == 0)
   3a890:	bf08      	it	eq
   3a892:	2301      	moveq	r3, #1
	switch(date.month)
   3a894:	f1a1 0102 	sub.w	r1, r1, #2
	if(date.year%4 == 0)
   3a898:	bf18      	it	ne
   3a89a:	2300      	movne	r3, #0
	switch(date.month)
   3a89c:	290a      	cmp	r1, #10
   3a89e:	d810      	bhi.n	3a8c2 <GetWeekDayByDate+0x56>
   3a8a0:	e8df f001 	tbb	[pc, r1]
   3a8a4:	2725220e 	.word	0x2725220e
   3a8a8:	2f2d2b29 	.word	0x2f2d2b29
   3a8ac:	3431      	.short	0x3431
   3a8ae:	37          	.byte	0x37
   3a8af:	00          	.byte	0x00
		if(i%4 == 0)	//366
   3a8b0:	0798      	lsls	r0, r3, #30
			count += 366;
   3a8b2:	bf0c      	ite	eq
   3a8b4:	f502 72b7 	addeq.w	r2, r2, #366	; 0x16e
			count += 365;
   3a8b8:	f202 126d 	addwne	r2, r2, #365	; 0x16d
	for(i=SYSTEM_STARTING_YEAR;i<date.year;i++)
   3a8bc:	3301      	adds	r3, #1
   3a8be:	e7e1      	b.n	3a884 <GetWeekDayByDate+0x18>
		count += 31;
   3a8c0:	321f      	adds	r2, #31
	count = count%7;
   3a8c2:	2307      	movs	r3, #7
	count += (date.day-1);
   3a8c4:	f89d 0003 	ldrb.w	r0, [sp, #3]
   3a8c8:	3801      	subs	r0, #1
   3a8ca:	4402      	add	r2, r0
	count = count%7;
   3a8cc:	fbb2 f0f3 	udiv	r0, r2, r3
   3a8d0:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
   3a8d4:	1a12      	subs	r2, r2, r0
	index = (index+count)%7;
   3a8d6:	1d10      	adds	r0, r2, #4
   3a8d8:	fbb0 f3f3 	udiv	r3, r0, r3
   3a8dc:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   3a8e0:	1ac0      	subs	r0, r0, r3
   3a8e2:	b2c0      	uxtb	r0, r0
}
   3a8e4:	b002      	add	sp, #8
   3a8e6:	4770      	bx	lr
		count += (31+(28+flag));
   3a8e8:	333b      	adds	r3, #59	; 0x3b
		count += (6*31+4*30+(28+flag));
   3a8ea:	441a      	add	r2, r3
		break;			
   3a8ec:	e7e9      	b.n	3a8c2 <GetWeekDayByDate+0x56>
		count += (2*31+(28+flag));
   3a8ee:	335a      	adds	r3, #90	; 0x5a
   3a8f0:	e7fb      	b.n	3a8ea <GetWeekDayByDate+0x7e>
		count += (2*31+30+(28+flag));
   3a8f2:	3378      	adds	r3, #120	; 0x78
   3a8f4:	e7f9      	b.n	3a8ea <GetWeekDayByDate+0x7e>
		count += (3*31+30+(28+flag));
   3a8f6:	3397      	adds	r3, #151	; 0x97
   3a8f8:	e7f7      	b.n	3a8ea <GetWeekDayByDate+0x7e>
		count += (3*31+2*30+(28+flag));
   3a8fa:	33b5      	adds	r3, #181	; 0xb5
   3a8fc:	e7f5      	b.n	3a8ea <GetWeekDayByDate+0x7e>
		count += (4*31+2*30+(28+flag));
   3a8fe:	33d4      	adds	r3, #212	; 0xd4
   3a900:	e7f3      	b.n	3a8ea <GetWeekDayByDate+0x7e>
		count += (5*31+2*30+(28+flag));
   3a902:	33f3      	adds	r3, #243	; 0xf3
   3a904:	e7f1      	b.n	3a8ea <GetWeekDayByDate+0x7e>
		count += (5*31+3*30+(28+flag));
   3a906:	f203 1311 	addw	r3, r3, #273	; 0x111
   3a90a:	e7ee      	b.n	3a8ea <GetWeekDayByDate+0x7e>
		count += (6*31+3*30+(28+flag));
   3a90c:	f503 7398 	add.w	r3, r3, #304	; 0x130
   3a910:	e7eb      	b.n	3a8ea <GetWeekDayByDate+0x7e>
		count += (6*31+4*30+(28+flag));
   3a912:	f503 73a7 	add.w	r3, r3, #334	; 0x14e
   3a916:	e7e8      	b.n	3a8ea <GetWeekDayByDate+0x7e>
		return 0xff;
   3a918:	20ff      	movs	r0, #255	; 0xff
   3a91a:	e7e3      	b.n	3a8e4 <GetWeekDayByDate+0x78>

0003a91c <CheckSystemDateTimeIsValid>:
{
   3a91c:	b082      	sub	sp, #8
   3a91e:	ab02      	add	r3, sp, #8
   3a920:	e903 0003 	stmdb	r3, {r0, r1}
	if((systime.year<SYSTEM_STARTING_YEAR || systime.year>9999)
   3a924:	f641 718f 	movw	r1, #8079	; 0x1f8f
   3a928:	f8bd 2000 	ldrh.w	r2, [sp]
   3a92c:	f5a2 63f0 	sub.w	r3, r2, #1920	; 0x780
   3a930:	b29b      	uxth	r3, r3
   3a932:	428b      	cmp	r3, r1
   3a934:	d816      	bhi.n	3a964 <CheckSystemDateTimeIsValid+0x48>
   3a936:	f89d 3002 	ldrb.w	r3, [sp, #2]
		|| ((systime.month==0)||(systime.month>12)) 
   3a93a:	1e59      	subs	r1, r3, #1
   3a93c:	290b      	cmp	r1, #11
   3a93e:	d811      	bhi.n	3a964 <CheckSystemDateTimeIsValid+0x48>
   3a940:	f89d 0003 	ldrb.w	r0, [sp, #3]
		|| (systime.day==0) 
   3a944:	b338      	cbz	r0, 3a996 <CheckSystemDateTimeIsValid+0x7a>
		|| ((systime.day>31)&&((systime.month==1)||(systime.month==3)||(systime.month==5)||(systime.month==7)||(systime.month==8)||(systime.month==10)||(systime.month==12)))
   3a946:	281f      	cmp	r0, #31
   3a948:	d90e      	bls.n	3a968 <CheckSystemDateTimeIsValid+0x4c>
   3a94a:	f241 50aa 	movw	r0, #5546	; 0x15aa
   3a94e:	40d8      	lsrs	r0, r3
   3a950:	43c0      	mvns	r0, r0
   3a952:	f010 0001 	ands.w	r0, r0, #1
   3a956:	d01e      	beq.n	3a996 <CheckSystemDateTimeIsValid+0x7a>
		|| ((systime.day>30)&&((systime.month==4)||(systime.month==6)||(systime.month==9)||(systime.month==11)))
   3a958:	f003 02fd 	and.w	r2, r3, #253	; 0xfd
   3a95c:	2a04      	cmp	r2, #4
   3a95e:	d001      	beq.n	3a964 <CheckSystemDateTimeIsValid+0x48>
   3a960:	2a09      	cmp	r2, #9
   3a962:	d104      	bne.n	3a96e <CheckSystemDateTimeIsValid+0x52>
		ret = false;
   3a964:	2000      	movs	r0, #0
   3a966:	e016      	b.n	3a996 <CheckSystemDateTimeIsValid+0x7a>
		|| ((systime.day>30)&&((systime.month==4)||(systime.month==6)||(systime.month==9)||(systime.month==11)))
   3a968:	d0f6      	beq.n	3a958 <CheckSystemDateTimeIsValid+0x3c>
		|| ((systime.day>29)&&((systime.month==2)&&(systime.year%4==0)))
   3a96a:	281e      	cmp	r0, #30
   3a96c:	d115      	bne.n	3a99a <CheckSystemDateTimeIsValid+0x7e>
   3a96e:	2b02      	cmp	r3, #2
   3a970:	d0f8      	beq.n	3a964 <CheckSystemDateTimeIsValid+0x48>
		|| ((systime.hour>23)||(systime.minute>59)||(systime.second>59))
   3a972:	f89d 3004 	ldrb.w	r3, [sp, #4]
   3a976:	2b17      	cmp	r3, #23
   3a978:	d8f4      	bhi.n	3a964 <CheckSystemDateTimeIsValid+0x48>
   3a97a:	f89d 3005 	ldrb.w	r3, [sp, #5]
   3a97e:	2b3b      	cmp	r3, #59	; 0x3b
   3a980:	d8f0      	bhi.n	3a964 <CheckSystemDateTimeIsValid+0x48>
   3a982:	f89d 3006 	ldrb.w	r3, [sp, #6]
   3a986:	2b3b      	cmp	r3, #59	; 0x3b
   3a988:	d8ec      	bhi.n	3a964 <CheckSystemDateTimeIsValid+0x48>
		|| (systime.week>6))
   3a98a:	f89d 0007 	ldrb.w	r0, [sp, #7]
   3a98e:	2806      	cmp	r0, #6
   3a990:	bf8c      	ite	hi
   3a992:	2000      	movhi	r0, #0
   3a994:	2001      	movls	r0, #1
}
   3a996:	b002      	add	sp, #8
   3a998:	4770      	bx	lr
		|| ((systime.day>28)&&((systime.month==2)&&(systime.year%4!=0)))
   3a99a:	281d      	cmp	r0, #29
   3a99c:	d1e9      	bne.n	3a972 <CheckSystemDateTimeIsValid+0x56>
   3a99e:	2b02      	cmp	r3, #2
   3a9a0:	d1e7      	bne.n	3a972 <CheckSystemDateTimeIsValid+0x56>
   3a9a2:	0793      	lsls	r3, r2, #30
   3a9a4:	d1de      	bne.n	3a964 <CheckSystemDateTimeIsValid+0x48>
   3a9a6:	e7e4      	b.n	3a972 <CheckSystemDateTimeIsValid+0x56>

0003a9a8 <AlarmRemindEntryScreen>:
{
   3a9a8:	b508      	push	{r3, lr}
	EnterAlarmScreen();
   3a9aa:	f7ea fe35 	bl	25618 <EnterAlarmScreen>
}
   3a9ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	AlarmRemindStart();
   3a9b2:	f7e5 bfb3 	b.w	2091c <AlarmRemindStart>

0003a9b6 <FindDeviceEntryScreen>:
{
   3a9b6:	b508      	push	{r3, lr}
	EnterFindDeviceScreen();
   3a9b8:	f7ea fe44 	bl	25644 <EnterFindDeviceScreen>
}
   3a9bc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	FindDeviceStart();
   3a9c0:	f7e6 b844 	b.w	20a4c <FindDeviceStart>

0003a9c4 <k_sleep>:
	return z_impl_k_sleep(ms);
   3a9c4:	f7fc bf7c 	b.w	378c0 <z_impl_k_sleep>

0003a9c8 <gpio_pin_write>:
{
   3a9c8:	b410      	push	{r4}
   3a9ca:	4613      	mov	r3, r2
	return api->write(port, access_op, pin, value);
   3a9cc:	6842      	ldr	r2, [r0, #4]
   3a9ce:	6854      	ldr	r4, [r2, #4]
   3a9d0:	460a      	mov	r2, r1
   3a9d2:	46a4      	mov	ip, r4
   3a9d4:	2100      	movs	r1, #0
}
   3a9d6:	f85d 4b04 	ldr.w	r4, [sp], #4
	return api->write(port, access_op, pin, value);
   3a9da:	4760      	bx	ip

0003a9dc <gpio_pin_configure.constprop.2>:
static inline int gpio_pin_configure(struct device *port, u32_t pin,
   3a9dc:	b410      	push	{r4}
   3a9de:	460a      	mov	r2, r1
	return api->config(port, access_op, pin, flags);
   3a9e0:	6843      	ldr	r3, [r0, #4]
   3a9e2:	2100      	movs	r1, #0
   3a9e4:	681c      	ldr	r4, [r3, #0]
   3a9e6:	2301      	movs	r3, #1
   3a9e8:	46a4      	mov	ip, r4
}
   3a9ea:	f85d 4b04 	ldr.w	r4, [sp], #4
	return api->config(port, access_op, pin, flags);
   3a9ee:	4760      	bx	ip

0003a9f0 <BlockWrite>:
{
   3a9f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3a9f4:	4605      	mov	r5, r0
   3a9f6:	4690      	mov	r8, r2
   3a9f8:	460c      	mov	r4, r1
   3a9fa:	461e      	mov	r6, r3
	WriteComm(0x2A);             
   3a9fc:	202a      	movs	r0, #42	; 0x2a
	WriteData(x);             
   3a9fe:	b2ef      	uxtb	r7, r5
	WriteComm(0x2A);             
   3aa00:	f7e6 fa86 	bl	20f10 <WriteComm>
	WriteData(x>>8);             
   3aa04:	f3c5 2007 	ubfx	r0, r5, #8, #8
   3aa08:	f7e6 fa92 	bl	20f30 <WriteData>
	WriteData((x+w-1)>>8);             
   3aa0c:	f108 38ff 	add.w	r8, r8, #4294967295
	WriteData(x);             
   3aa10:	4638      	mov	r0, r7
   3aa12:	f7e6 fa8d 	bl	20f30 <WriteData>
	WriteData((x+w-1)>>8);             
   3aa16:	eb08 0005 	add.w	r0, r8, r5
   3aa1a:	f3c0 2007 	ubfx	r0, r0, #8, #8
   3aa1e:	f7e6 fa87 	bl	20f30 <WriteData>
	WriteData((x+w-1));             
   3aa22:	eb07 0008 	add.w	r0, r7, r8
   3aa26:	b2c0      	uxtb	r0, r0
   3aa28:	f7e6 fa82 	bl	20f30 <WriteData>
	WriteComm(0x2B);             
   3aa2c:	202b      	movs	r0, #43	; 0x2b
   3aa2e:	f7e6 fa6f 	bl	20f10 <WriteComm>
	WriteData(y);             
   3aa32:	b2e5      	uxtb	r5, r4
	WriteData(y>>8);             
   3aa34:	f3c4 2007 	ubfx	r0, r4, #8, #8
   3aa38:	f7e6 fa7a 	bl	20f30 <WriteData>
	WriteData((y+h-1)>>8);//	WriteData((Yend+1)>>8);             
   3aa3c:	3e01      	subs	r6, #1
	WriteData(y);             
   3aa3e:	4628      	mov	r0, r5
   3aa40:	f7e6 fa76 	bl	20f30 <WriteData>
	WriteData((y+h-1)>>8);//	WriteData((Yend+1)>>8);             
   3aa44:	1930      	adds	r0, r6, r4
   3aa46:	f3c0 2007 	ubfx	r0, r0, #8, #8
   3aa4a:	f7e6 fa71 	bl	20f30 <WriteData>
	WriteData((y+h-1));//	WriteData(Yend+1);   	
   3aa4e:	19a8      	adds	r0, r5, r6
   3aa50:	b2c0      	uxtb	r0, r0
   3aa52:	f7e6 fa6d 	bl	20f30 <WriteData>
}
   3aa56:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	WriteComm(0x2c);
   3aa5a:	202c      	movs	r0, #44	; 0x2c
   3aa5c:	f7e6 ba58 	b.w	20f10 <WriteComm>

0003aa60 <LCD_Clear>:
	BlockWrite(0,0,COL,ROW);//
   3aa60:	2100      	movs	r1, #0
{
   3aa62:	b510      	push	{r4, lr}
   3aa64:	4604      	mov	r4, r0
	BlockWrite(0,0,COL,ROW);//
   3aa66:	23d2      	movs	r3, #210	; 0xd2
   3aa68:	4608      	mov	r0, r1
   3aa6a:	22f0      	movs	r2, #240	; 0xf0
   3aa6c:	f7ff ffc0 	bl	3a9f0 <BlockWrite>
	DispColor(COL*ROW, color);
   3aa70:	4621      	mov	r1, r4
} 
   3aa72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	DispColor(COL*ROW, color);
   3aa76:	f24c 40e0 	movw	r0, #50400	; 0xc4e0
   3aa7a:	f7e6 ba69 	b.w	20f50 <DispColor>

0003aa7e <is_wearing>:
}
   3aa7e:	2001      	movs	r0, #1
   3aa80:	4770      	bx	lr

0003aa82 <uart_fifo_fill>:
	if (api->fifo_fill) {
   3aa82:	6843      	ldr	r3, [r0, #4]
   3aa84:	695b      	ldr	r3, [r3, #20]
   3aa86:	b103      	cbz	r3, 3aa8a <uart_fifo_fill+0x8>
		return api->fifo_fill(dev, tx_data, size);
   3aa88:	4718      	bx	r3
}
   3aa8a:	4618      	mov	r0, r3
   3aa8c:	4770      	bx	lr

0003aa8e <z_impl_uart_irq_tx_enable>:
	if (api->irq_tx_enable) {
   3aa8e:	6843      	ldr	r3, [r0, #4]
   3aa90:	69db      	ldr	r3, [r3, #28]
   3aa92:	b103      	cbz	r3, 3aa96 <z_impl_uart_irq_tx_enable+0x8>
		api->irq_tx_enable(dev);
   3aa94:	4718      	bx	r3
}
   3aa96:	4770      	bx	lr

0003aa98 <uart_irq_tx_disable>:
	if (api->irq_tx_disable) {
   3aa98:	6843      	ldr	r3, [r0, #4]
   3aa9a:	6a1b      	ldr	r3, [r3, #32]
   3aa9c:	b103      	cbz	r3, 3aaa0 <uart_irq_tx_disable+0x8>
		api->irq_tx_disable(dev);
   3aa9e:	4718      	bx	r3
}
   3aaa0:	4770      	bx	lr

0003aaa2 <APP_get_location_data_reply>:
{
   3aaa2:	b510      	push	{r4, lr}
   3aaa4:	b0a0      	sub	sp, #128	; 0x80
   3aaa6:	4604      	mov	r4, r0
	u8_t reply[128] = {0};
   3aaa8:	2100      	movs	r1, #0
   3aaaa:	2280      	movs	r2, #128	; 0x80
   3aaac:	4668      	mov	r0, sp
   3aaae:	f003 feed 	bl	3e88c <memset>
	reply[reply_len++] = PACKET_HEAD;
   3aab2:	23ab      	movs	r3, #171	; 0xab
   3aab4:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x17;
   3aab8:	f64f 7317 	movw	r3, #65303	; 0xff17
   3aabc:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(LOCATION_ID&0x00ff);
   3aac0:	f248 0355 	movw	r3, #32853	; 0x8055
   3aac4:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = buf[0];//h-byte year
   3aac8:	7823      	ldrb	r3, [r4, #0]
   3aaca:	4669      	mov	r1, sp
   3aacc:	f88d 3007 	strb.w	r3, [sp, #7]
	reply[reply_len++] = buf[1];//l-byte year
   3aad0:	7863      	ldrb	r3, [r4, #1]
   3aad2:	f88d 3008 	strb.w	r3, [sp, #8]
	reply[reply_len++] = buf[2];//month
   3aad6:	78a3      	ldrb	r3, [r4, #2]
   3aad8:	f88d 3009 	strb.w	r3, [sp, #9]
	reply[reply_len++] = buf[3];//day
   3aadc:	78e3      	ldrb	r3, [r4, #3]
   3aade:	f88d 300a 	strb.w	r3, [sp, #10]
	reply[reply_len++] = buf[4];//hour
   3aae2:	7923      	ldrb	r3, [r4, #4]
   3aae4:	f88d 300b 	strb.w	r3, [sp, #11]
	reply[reply_len++] = buf[5];//minute
   3aae8:	7963      	ldrb	r3, [r4, #5]
   3aaea:	f88d 300c 	strb.w	r3, [sp, #12]
	reply[reply_len++] = buf[6];//seconds
   3aaee:	79a3      	ldrb	r3, [r4, #6]
   3aaf0:	f88d 300d 	strb.w	r3, [sp, #13]
	reply[reply_len++] = buf[7];//direction	E\W
   3aaf4:	79e3      	ldrb	r3, [r4, #7]
   3aaf6:	f88d 300e 	strb.w	r3, [sp, #14]
	reply[reply_len++] = buf[8];//degree int
   3aafa:	7a23      	ldrb	r3, [r4, #8]
   3aafc:	f88d 300f 	strb.w	r3, [sp, #15]
	reply[reply_len++] = buf[9];//degree dot1~2
   3ab00:	7a63      	ldrb	r3, [r4, #9]
   3ab02:	f88d 3010 	strb.w	r3, [sp, #16]
	reply[reply_len++] = buf[10];//degree dot3~4
   3ab06:	7aa3      	ldrb	r3, [r4, #10]
   3ab08:	f88d 3011 	strb.w	r3, [sp, #17]
	reply[reply_len++] = buf[11];//degree dot5~6
   3ab0c:	7ae3      	ldrb	r3, [r4, #11]
   3ab0e:	f88d 3012 	strb.w	r3, [sp, #18]
	reply[reply_len++] = buf[12];//direction	N\S
   3ab12:	7b23      	ldrb	r3, [r4, #12]
   3ab14:	f88d 3013 	strb.w	r3, [sp, #19]
	reply[reply_len++] = buf[13];//degree int
   3ab18:	7b63      	ldrb	r3, [r4, #13]
   3ab1a:	f88d 3014 	strb.w	r3, [sp, #20]
	reply[reply_len++] = buf[14];//degree dot1~2
   3ab1e:	7ba3      	ldrb	r3, [r4, #14]
   3ab20:	f88d 3015 	strb.w	r3, [sp, #21]
	reply[reply_len++] = buf[15];//degree dot3~4
   3ab24:	7be3      	ldrb	r3, [r4, #15]
   3ab26:	f88d 3016 	strb.w	r3, [sp, #22]
	reply[reply_len++] = buf[16];//degree dot5~6
   3ab2a:	7c23      	ldrb	r3, [r4, #16]
   3ab2c:	f88d 3017 	strb.w	r3, [sp, #23]
	reply[reply_len++] = PACKET_END;
   3ab30:	2388      	movs	r3, #136	; 0x88
   3ab32:	f88d 3019 	strb.w	r3, [sp, #25]
	for(i=0;i<(reply_len-2);i++)
   3ab36:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   3ab38:	f811 2b01 	ldrb.w	r2, [r1], #1
   3ab3c:	f89d 0018 	ldrb.w	r0, [sp, #24]
	for(i=0;i<(reply_len-2);i++)
   3ab40:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   3ab42:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   3ab44:	2b18      	cmp	r3, #24
		reply[reply_len-2] += reply[i];
   3ab46:	f88d 2018 	strb.w	r2, [sp, #24]
	for(i=0;i<(reply_len-2);i++)
   3ab4a:	d1f5      	bne.n	3ab38 <APP_get_location_data_reply+0x96>
	ble_send_date_handle(reply, reply_len);
   3ab4c:	211a      	movs	r1, #26
   3ab4e:	4668      	mov	r0, sp
   3ab50:	f7e7 f9da 	bl	21f08 <ble_send_date_handle>
}
   3ab54:	b020      	add	sp, #128	; 0x80
   3ab56:	bd10      	pop	{r4, pc}

0003ab58 <APP_get_firmware_version>:
{
   3ab58:	b500      	push	{lr}
   3ab5a:	b0a1      	sub	sp, #132	; 0x84
	u8_t reply[128] = {0};
   3ab5c:	2100      	movs	r1, #0
   3ab5e:	2280      	movs	r2, #128	; 0x80
   3ab60:	4668      	mov	r0, sp
   3ab62:	f003 fe93 	bl	3e88c <memset>
	reply[reply_len++] = PACKET_HEAD;
   3ab66:	23ab      	movs	r3, #171	; 0xab
   3ab68:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x07;
   3ab6c:	f64f 7307 	movw	r3, #65287	; 0xff07
   3ab70:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(FIRMWARE_INFOR_ID&0x00ff);
   3ab74:	f248 0352 	movw	r3, #32850	; 0x8052
   3ab78:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = (0x02<<4)+0x00;	//V2.0
   3ab7c:	2320      	movs	r3, #32
   3ab7e:	f88d 3007 	strb.w	r3, [sp, #7]
	reply[reply_len++] = PACKET_END;
   3ab82:	2388      	movs	r3, #136	; 0x88
   3ab84:	4669      	mov	r1, sp
   3ab86:	f88d 3009 	strb.w	r3, [sp, #9]
	for(i=0;i<(reply_len-2);i++)
   3ab8a:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   3ab8c:	f811 2b01 	ldrb.w	r2, [r1], #1
   3ab90:	f89d 0008 	ldrb.w	r0, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   3ab94:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   3ab96:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   3ab98:	2b08      	cmp	r3, #8
		reply[reply_len-2] += reply[i];
   3ab9a:	f88d 2008 	strb.w	r2, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   3ab9e:	d1f5      	bne.n	3ab8c <APP_get_firmware_version+0x34>
	ble_send_date_handle(reply, reply_len);
   3aba0:	210a      	movs	r1, #10
   3aba2:	4668      	mov	r0, sp
   3aba4:	f7e7 f9b0 	bl	21f08 <ble_send_date_handle>
}
   3aba8:	b021      	add	sp, #132	; 0x84
   3abaa:	f85d fb04 	ldr.w	pc, [sp], #4

0003abae <show_infor>:
{
   3abae:	b513      	push	{r0, r1, r4, lr}
   3abb0:	4604      	mov	r4, r0
	LCD_Clear(BLACK);
   3abb2:	2000      	movs	r0, #0
   3abb4:	f7ff ff54 	bl	3aa60 <LCD_Clear>
	LCD_ShowStringInRect(20,90,200,50,strbuf);
   3abb8:	9400      	str	r4, [sp, #0]
   3abba:	2332      	movs	r3, #50	; 0x32
   3abbc:	22c8      	movs	r2, #200	; 0xc8
   3abbe:	215a      	movs	r1, #90	; 0x5a
   3abc0:	2014      	movs	r0, #20
   3abc2:	f7e6 f8b9 	bl	20d38 <LCD_ShowStringInRect>
}
   3abc6:	b002      	add	sp, #8
   3abc8:	bd10      	pop	{r4, pc}

0003abca <gpio_add_callback>:
	if (api->manage_callback == NULL) {
   3abca:	6843      	ldr	r3, [r0, #4]
   3abcc:	68db      	ldr	r3, [r3, #12]
   3abce:	b10b      	cbz	r3, 3abd4 <gpio_add_callback+0xa>
	return api->manage_callback(port, callback, true);
   3abd0:	2201      	movs	r2, #1
   3abd2:	4718      	bx	r3
}
   3abd4:	f06f 0085 	mvn.w	r0, #133	; 0x85
   3abd8:	4770      	bx	lr

0003abda <get_input_degree>:
	if(d == b)                  // Rshoulder
   3abda:	eeb4 2a41 	vcmp.f32	s4, s2
	volatile float re_val=0;
   3abde:	2300      	movs	r3, #0
	if(d == b)                  // Rshoulder
   3abe0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
   3abe4:	b082      	sub	sp, #8
	volatile float re_val=0;
   3abe6:	9301      	str	r3, [sp, #4]
	if(d == b)                  // Rshoulder
   3abe8:	461a      	mov	r2, r3
   3abea:	d124      	bne.n	3ac36 <get_input_degree+0x5c>
		if(x >= b)                     re_val = 1;
   3abec:	eeb4 1ac0 	vcmpe.f32	s2, s0
   3abf0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3abf4:	d802      	bhi.n	3abfc <get_input_degree+0x22>
		if(x <= c)                     re_val = 1;
   3abf6:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   3abfa:	e026      	b.n	3ac4a <get_input_degree+0x70>
		else if(x > a && x < b)        re_val = (x - a) / (b - a);
   3abfc:	eeb4 0ae0 	vcmpe.f32	s0, s1
   3ac00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3ac04:	dd10      	ble.n	3ac28 <get_input_degree+0x4e>
   3ac06:	eeb4 1ac0 	vcmpe.f32	s2, s0
   3ac0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3ac0e:	dd0b      	ble.n	3ac28 <get_input_degree+0x4e>
		else if(x < b)                 re_val = (x - a) / (b - a);
   3ac10:	ee30 0a60 	vsub.f32	s0, s0, s1
   3ac14:	ee31 1a60 	vsub.f32	s2, s2, s1
   3ac18:	eec0 7a01 	vdiv.f32	s15, s0, s2
		else if(x > c && x < d)        re_val = (d - x) / (d - c);
   3ac1c:	edcd 7a01 	vstr	s15, [sp, #4]
	return re_val;
   3ac20:	ed9d 0a01 	vldr	s0, [sp, #4]
}
   3ac24:	b002      	add	sp, #8
   3ac26:	4770      	bx	lr
		else if(x <= a)                re_val = 0;
   3ac28:	eeb4 0ae0 	vcmpe.f32	s0, s1
		else if(x >= d)                re_val = 0;
   3ac2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3ac30:	d8f6      	bhi.n	3ac20 <get_input_degree+0x46>
   3ac32:	9201      	str	r2, [sp, #4]
   3ac34:	e7f4      	b.n	3ac20 <get_input_degree+0x46>
	else if(d == c)             // Triangle
   3ac36:	eeb4 2a61 	vcmp.f32	s4, s3
   3ac3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3ac3e:	d121      	bne.n	3ac84 <get_input_degree+0xaa>
		if(x <= a)                     re_val = 0;
   3ac40:	eeb4 0ae0 	vcmpe.f32	s0, s1
   3ac44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3ac48:	d801      	bhi.n	3ac4e <get_input_degree+0x74>
	else re_val = 0;
   3ac4a:	9301      	str	r3, [sp, #4]
   3ac4c:	e7e8      	b.n	3ac20 <get_input_degree+0x46>
		else if(x == b)                re_val = 1;
   3ac4e:	eeb4 1a40 	vcmp.f32	s2, s0
   3ac52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3ac56:	d0ce      	beq.n	3abf6 <get_input_degree+0x1c>
		else if(x < b)                 re_val = (x - a) / (b - a);
   3ac58:	eeb4 1ac0 	vcmpe.f32	s2, s0
   3ac5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3ac60:	dcd6      	bgt.n	3ac10 <get_input_degree+0x36>
		else if(x >= c)                re_val = 0;
   3ac62:	eeb4 0ae1 	vcmpe.f32	s0, s3
   3ac66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3ac6a:	daee      	bge.n	3ac4a <get_input_degree+0x70>
		else if(x > b)                 re_val = (c - x) / (c - b);
   3ac6c:	eeb4 1ac0 	vcmpe.f32	s2, s0
   3ac70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3ac74:	d5d4      	bpl.n	3ac20 <get_input_degree+0x46>
   3ac76:	ee31 0ac0 	vsub.f32	s0, s3, s0
   3ac7a:	ee31 2ac1 	vsub.f32	s4, s3, s2
		else if(x > c && x < d)        re_val = (d - x) / (d - c);
   3ac7e:	eec0 7a02 	vdiv.f32	s15, s0, s4
   3ac82:	e7cb      	b.n	3ac1c <get_input_degree+0x42>
	else if(d == a)             //Lshoulder
   3ac84:	eeb4 2a60 	vcmp.f32	s4, s1
   3ac88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3ac8c:	d1dd      	bne.n	3ac4a <get_input_degree+0x70>
		if(x <= c)                     re_val = 1;
   3ac8e:	eeb4 0ae1 	vcmpe.f32	s0, s3
   3ac92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3ac96:	d9ae      	bls.n	3abf6 <get_input_degree+0x1c>
		else if(x > c && x < d)        re_val = (d - x) / (d - c);
   3ac98:	dd09      	ble.n	3acae <get_input_degree+0xd4>
   3ac9a:	eeb4 2ac0 	vcmpe.f32	s4, s0
   3ac9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   3aca2:	dd04      	ble.n	3acae <get_input_degree+0xd4>
   3aca4:	ee32 0a40 	vsub.f32	s0, s4, s0
   3aca8:	ee32 2a61 	vsub.f32	s4, s4, s3
   3acac:	e7e7      	b.n	3ac7e <get_input_degree+0xa4>
		else if(x >= d)                re_val = 0;
   3acae:	eeb4 2ac0 	vcmpe.f32	s4, s0
   3acb2:	e7bb      	b.n	3ac2c <get_input_degree+0x52>

0003acb4 <gpio_pin_disable_callback>:
 * @param port Pointer to the device structure for the driver instance.
 * @param pin Pin number where the callback function is disabled.
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_disable_callback(struct device *port, u32_t pin)
{
   3acb4:	460a      	mov	r2, r1
	if (api->disable_callback == NULL) {
   3acb6:	6843      	ldr	r3, [r0, #4]
   3acb8:	695b      	ldr	r3, [r3, #20]
   3acba:	b10b      	cbz	r3, 3acc0 <gpio_pin_disable_callback+0xc>
	return api->disable_callback(port, access_op, pin);
   3acbc:	2100      	movs	r1, #0
   3acbe:	4718      	bx	r3
	return gpio_disable_callback(port, GPIO_ACCESS_BY_PIN, pin);
}
   3acc0:	f06f 0085 	mvn.w	r0, #133	; 0x85
   3acc4:	4770      	bx	lr

0003acc6 <gpio_pin_enable_callback>:
{
   3acc6:	460a      	mov	r2, r1
	if (api->enable_callback == NULL) {
   3acc8:	6843      	ldr	r3, [r0, #4]
   3acca:	691b      	ldr	r3, [r3, #16]
   3accc:	b10b      	cbz	r3, 3acd2 <gpio_pin_enable_callback+0xc>
	return api->enable_callback(port, access_op, pin);
   3acce:	2100      	movs	r1, #0
   3acd0:	4718      	bx	r3
}
   3acd2:	f06f 0085 	mvn.w	r0, #133	; 0x85
   3acd6:	4770      	bx	lr

0003acd8 <gpio_pin_configure>:
{
   3acd8:	b410      	push	{r4}
   3acda:	4613      	mov	r3, r2
	return api->config(port, access_op, pin, flags);
   3acdc:	6842      	ldr	r2, [r0, #4]
   3acde:	6814      	ldr	r4, [r2, #0]
   3ace0:	460a      	mov	r2, r1
   3ace2:	46a4      	mov	ip, r4
   3ace4:	2100      	movs	r1, #0
}
   3ace6:	f85d 4b04 	ldr.w	r4, [sp], #4
	return api->config(port, access_op, pin, flags);
   3acea:	4760      	bx	ip

0003acec <lsm6dso_read_reg>:
{
   3acec:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
   3acee:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
   3acf2:	46a4      	mov	ip, r4
}
   3acf4:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
   3acf8:	4760      	bx	ip

0003acfa <lsm6dso_write_reg>:
{
   3acfa:	b410      	push	{r4}
  ret = ctx->write_reg(ctx->handle, reg, data, len);
   3acfc:	6804      	ldr	r4, [r0, #0]
   3acfe:	6880      	ldr	r0, [r0, #8]
   3ad00:	46a4      	mov	ip, r4
}
   3ad02:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->write_reg(ctx->handle, reg, data, len);
   3ad06:	4760      	bx	ip

0003ad08 <lsm6dso_xl_full_scale_set>:
  * @param  val      change the values of fs_xl in reg CTRL1_XL
  *
  */
int32_t lsm6dso_xl_full_scale_set(stmdev_ctx_t *ctx,
                                  lsm6dso_fs_xl_t val)
{
   3ad08:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_ctrl1_xl_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   3ad0a:	2301      	movs	r3, #1
{
   3ad0c:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   3ad0e:	aa01      	add	r2, sp, #4
   3ad10:	2110      	movs	r1, #16
{
   3ad12:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   3ad14:	f7ff ffea 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3ad18:	b958      	cbnz	r0, 3ad32 <lsm6dso_xl_full_scale_set+0x2a>
    reg.fs_xl = (uint8_t) val;
   3ad1a:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   3ad1e:	aa01      	add	r2, sp, #4
    reg.fs_xl = (uint8_t) val;
   3ad20:	f365 0383 	bfi	r3, r5, #2, #2
   3ad24:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   3ad28:	2110      	movs	r1, #16
   3ad2a:	2301      	movs	r3, #1
   3ad2c:	4620      	mov	r0, r4
   3ad2e:	f7ff ffe4 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3ad32:	b003      	add	sp, #12
   3ad34:	bd30      	pop	{r4, r5, pc}

0003ad36 <lsm6dso_gy_full_scale_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of fs_g in reg CTRL2_G
  *
  */
int32_t lsm6dso_gy_full_scale_set(stmdev_ctx_t *ctx, lsm6dso_fs_g_t val)
{
   3ad36:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_ctrl2_g_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   3ad38:	2301      	movs	r3, #1
{
   3ad3a:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   3ad3c:	aa01      	add	r2, sp, #4
   3ad3e:	2111      	movs	r1, #17
{
   3ad40:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   3ad42:	f7ff ffd3 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3ad46:	b958      	cbnz	r0, 3ad60 <lsm6dso_gy_full_scale_set+0x2a>
    reg.fs_g = (uint8_t) val;
   3ad48:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   3ad4c:	aa01      	add	r2, sp, #4
    reg.fs_g = (uint8_t) val;
   3ad4e:	f365 0343 	bfi	r3, r5, #1, #3
   3ad52:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   3ad56:	2111      	movs	r1, #17
   3ad58:	2301      	movs	r3, #1
   3ad5a:	4620      	mov	r0, r4
   3ad5c:	f7ff ffcd 	bl	3acfa <lsm6dso_write_reg>
  }

  return ret;
}
   3ad60:	b003      	add	sp, #12
   3ad62:	bd30      	pop	{r4, r5, pc}

0003ad64 <lsm6dso_block_data_update_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of bdu in reg CTRL3_C
  *
  */
int32_t lsm6dso_block_data_update_set(stmdev_ctx_t *ctx, uint8_t val)
{
   3ad64:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_ctrl3_c_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   3ad66:	2301      	movs	r3, #1
{
   3ad68:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   3ad6a:	aa01      	add	r2, sp, #4
   3ad6c:	2112      	movs	r1, #18
{
   3ad6e:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   3ad70:	f7ff ffbc 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3ad74:	b958      	cbnz	r0, 3ad8e <lsm6dso_block_data_update_set+0x2a>
    reg.bdu = val;
   3ad76:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   3ad7a:	aa01      	add	r2, sp, #4
    reg.bdu = val;
   3ad7c:	f365 1386 	bfi	r3, r5, #6, #1
   3ad80:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   3ad84:	2112      	movs	r1, #18
   3ad86:	2301      	movs	r3, #1
   3ad88:	4620      	mov	r0, r4
   3ad8a:	f7ff ffb6 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3ad8e:	b003      	add	sp, #12
   3ad90:	bd30      	pop	{r4, r5, pc}

0003ad92 <lsm6dso_xl_power_mode_set>:
  *                               reg CTRL6_C
  *
  */
int32_t lsm6dso_xl_power_mode_set(stmdev_ctx_t *ctx,
                                  lsm6dso_xl_hm_mode_t val)
{
   3ad92:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_ctrl5_c_t ctrl5_c;
  lsm6dso_ctrl6_c_t ctrl6_c;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL5_C, (uint8_t*) &ctrl5_c, 1);
   3ad94:	2301      	movs	r3, #1
{
   3ad96:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL5_C, (uint8_t*) &ctrl5_c, 1);
   3ad98:	466a      	mov	r2, sp
   3ad9a:	2114      	movs	r1, #20
{
   3ad9c:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL5_C, (uint8_t*) &ctrl5_c, 1);
   3ad9e:	f7ff ffa5 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3ada2:	bb00      	cbnz	r0, 3ade6 <lsm6dso_xl_power_mode_set+0x54>
    ctrl5_c.xl_ulp_en = ((uint8_t)val & 0x02U) >> 1;
   3ada4:	f89d 2000 	ldrb.w	r2, [sp]
   3ada8:	086b      	lsrs	r3, r5, #1
   3adaa:	f363 12c7 	bfi	r2, r3, #7, #1
   3adae:	f88d 2000 	strb.w	r2, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL5_C, (uint8_t*) &ctrl5_c, 1);
   3adb2:	2301      	movs	r3, #1
   3adb4:	466a      	mov	r2, sp
   3adb6:	2114      	movs	r1, #20
   3adb8:	4620      	mov	r0, r4
   3adba:	f7ff ff9e 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3adbe:	b990      	cbnz	r0, 3ade6 <lsm6dso_xl_power_mode_set+0x54>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL6_C, (uint8_t*) &ctrl6_c, 1);
   3adc0:	2301      	movs	r3, #1
   3adc2:	aa01      	add	r2, sp, #4
   3adc4:	2115      	movs	r1, #21
   3adc6:	4620      	mov	r0, r4
   3adc8:	f7ff ff90 	bl	3acec <lsm6dso_read_reg>
  }
  if (ret == 0) {
   3adcc:	b958      	cbnz	r0, 3ade6 <lsm6dso_xl_power_mode_set+0x54>
    ctrl6_c.xl_hm_mode = (uint8_t)val & 0x01U;
   3adce:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL6_C, (uint8_t*) &ctrl6_c, 1);
   3add2:	aa01      	add	r2, sp, #4
    ctrl6_c.xl_hm_mode = (uint8_t)val & 0x01U;
   3add4:	f365 1304 	bfi	r3, r5, #4, #1
   3add8:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL6_C, (uint8_t*) &ctrl6_c, 1);
   3addc:	2115      	movs	r1, #21
   3adde:	2301      	movs	r3, #1
   3ade0:	4620      	mov	r0, r4
   3ade2:	f7ff ff8a 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3ade6:	b003      	add	sp, #12
   3ade8:	bd30      	pop	{r4, r5, pc}

0003adea <lsm6dso_xl_flag_data_ready_get>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of xlda in reg STATUS_REG
  *
  */
int32_t lsm6dso_xl_flag_data_ready_get(stmdev_ctx_t *ctx, uint8_t *val)
{
   3adea:	b513      	push	{r0, r1, r4, lr}
  lsm6dso_status_reg_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_STATUS_REG, (uint8_t*)&reg, 1);
   3adec:	2301      	movs	r3, #1
{
   3adee:	460c      	mov	r4, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_STATUS_REG, (uint8_t*)&reg, 1);
   3adf0:	aa01      	add	r2, sp, #4
   3adf2:	211e      	movs	r1, #30
   3adf4:	f7ff ff7a 	bl	3acec <lsm6dso_read_reg>
  *val = reg.xlda;
   3adf8:	f89d 3004 	ldrb.w	r3, [sp, #4]
   3adfc:	f3c3 0300 	ubfx	r3, r3, #0, #1
   3ae00:	7023      	strb	r3, [r4, #0]

  return ret;
}
   3ae02:	b002      	add	sp, #8
   3ae04:	bd10      	pop	{r4, pc}

0003ae06 <lsm6dso_timestamp_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of timestamp_en in reg CTRL10_C
  *
  */
int32_t lsm6dso_timestamp_set(stmdev_ctx_t *ctx, uint8_t val)
{
   3ae06:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_ctrl10_c_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL10_C, (uint8_t*)&reg, 1);
   3ae08:	2301      	movs	r3, #1
{
   3ae0a:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL10_C, (uint8_t*)&reg, 1);
   3ae0c:	aa01      	add	r2, sp, #4
   3ae0e:	2119      	movs	r1, #25
{
   3ae10:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL10_C, (uint8_t*)&reg, 1);
   3ae12:	f7ff ff6b 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3ae16:	b958      	cbnz	r0, 3ae30 <lsm6dso_timestamp_set+0x2a>
    reg.timestamp_en = val;
   3ae18:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL10_C, (uint8_t*)&reg, 1);
   3ae1c:	aa01      	add	r2, sp, #4
    reg.timestamp_en = val;
   3ae1e:	f365 1345 	bfi	r3, r5, #5, #1
   3ae22:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL10_C, (uint8_t*)&reg, 1);
   3ae26:	2119      	movs	r1, #25
   3ae28:	2301      	movs	r3, #1
   3ae2a:	4620      	mov	r0, r4
   3ae2c:	f7ff ff65 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3ae30:	b003      	add	sp, #12
   3ae32:	bd30      	pop	{r4, r5, pc}

0003ae34 <lsm6dso_acceleration_raw_get>:
  *
  */
int32_t lsm6dso_acceleration_raw_get(stmdev_ctx_t *ctx, uint8_t *buff)
{
  int32_t ret;
  ret = lsm6dso_read_reg(ctx, LSM6DSO_OUTX_L_A, buff, 6);
   3ae34:	460a      	mov	r2, r1
   3ae36:	2306      	movs	r3, #6
   3ae38:	2128      	movs	r1, #40	; 0x28
   3ae3a:	f7ff bf57 	b.w	3acec <lsm6dso_read_reg>

0003ae3e <lsm6dso_fifo_out_raw_get>:
  *
  */
int32_t lsm6dso_fifo_out_raw_get(stmdev_ctx_t *ctx, uint8_t *buff)
{
  int32_t ret;
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_DATA_OUT_X_L, buff, 6);
   3ae3e:	460a      	mov	r2, r1
   3ae40:	2306      	movs	r3, #6
   3ae42:	2179      	movs	r1, #121	; 0x79
   3ae44:	f7ff bf52 	b.w	3acec <lsm6dso_read_reg>

0003ae48 <lsm6dso_mem_bank_set>:
int32_t lsm6dso_mem_bank_set(stmdev_ctx_t *ctx, lsm6dso_reg_access_t val)
{
  lsm6dso_func_cfg_access_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t*)&reg, 1);
   3ae48:	2301      	movs	r3, #1
{
   3ae4a:	b537      	push	{r0, r1, r2, r4, r5, lr}
   3ae4c:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t*)&reg, 1);
   3ae4e:	aa01      	add	r2, sp, #4
   3ae50:	4619      	mov	r1, r3
{
   3ae52:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t*)&reg, 1);
   3ae54:	f7ff ff4a 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3ae58:	b958      	cbnz	r0, 3ae72 <lsm6dso_mem_bank_set+0x2a>
    reg.reg_access = (uint8_t)val;
   3ae5a:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t*)&reg, 1);
   3ae5e:	aa01      	add	r2, sp, #4
    reg.reg_access = (uint8_t)val;
   3ae60:	f365 1387 	bfi	r3, r5, #6, #2
   3ae64:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t*)&reg, 1);
   3ae68:	2301      	movs	r3, #1
   3ae6a:	4620      	mov	r0, r4
   3ae6c:	4619      	mov	r1, r3
   3ae6e:	f7ff ff44 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3ae72:	b003      	add	sp, #12
   3ae74:	bd30      	pop	{r4, r5, pc}

0003ae76 <lsm6dso_all_sources_get>:
{
   3ae76:	b538      	push	{r3, r4, r5, lr}
  ret = lsm6dso_read_reg(ctx, LSM6DSO_ALL_INT_SRC,
   3ae78:	460a      	mov	r2, r1
{
   3ae7a:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_ALL_INT_SRC,
   3ae7c:	2301      	movs	r3, #1
   3ae7e:	211a      	movs	r1, #26
{
   3ae80:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_ALL_INT_SRC,
   3ae82:	f7ff ff33 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3ae86:	bbd8      	cbnz	r0, 3af00 <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_WAKE_UP_SRC,
   3ae88:	2301      	movs	r3, #1
   3ae8a:	211b      	movs	r1, #27
   3ae8c:	18ea      	adds	r2, r5, r3
   3ae8e:	4620      	mov	r0, r4
   3ae90:	f7ff ff2c 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3ae94:	bba0      	cbnz	r0, 3af00 <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_SRC,
   3ae96:	2301      	movs	r3, #1
   3ae98:	1caa      	adds	r2, r5, #2
   3ae9a:	211c      	movs	r1, #28
   3ae9c:	4620      	mov	r0, r4
   3ae9e:	f7ff ff25 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3aea2:	bb68      	cbnz	r0, 3af00 <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_D6D_SRC,
   3aea4:	2301      	movs	r3, #1
   3aea6:	1cea      	adds	r2, r5, #3
   3aea8:	211d      	movs	r1, #29
   3aeaa:	4620      	mov	r0, r4
   3aeac:	f7ff ff1e 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3aeb0:	bb30      	cbnz	r0, 3af00 <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_STATUS_REG,
   3aeb2:	2301      	movs	r3, #1
   3aeb4:	1d2a      	adds	r2, r5, #4
   3aeb6:	211e      	movs	r1, #30
   3aeb8:	4620      	mov	r0, r4
   3aeba:	f7ff ff17 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3aebe:	b9f8      	cbnz	r0, 3af00 <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3aec0:	2102      	movs	r1, #2
   3aec2:	4620      	mov	r0, r4
   3aec4:	f7ff ffc0 	bl	3ae48 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   3aec8:	b9d0      	cbnz	r0, 3af00 <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_STATUS,
   3aeca:	2301      	movs	r3, #1
   3aecc:	1d6a      	adds	r2, r5, #5
   3aece:	2112      	movs	r1, #18
   3aed0:	4620      	mov	r0, r4
   3aed2:	f7ff ff0b 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3aed6:	b998      	cbnz	r0, 3af00 <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FSM_STATUS_A,
   3aed8:	2301      	movs	r3, #1
   3aeda:	1daa      	adds	r2, r5, #6
   3aedc:	2113      	movs	r1, #19
   3aede:	4620      	mov	r0, r4
   3aee0:	f7ff ff04 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3aee4:	b960      	cbnz	r0, 3af00 <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FSM_STATUS_B,
   3aee6:	2301      	movs	r3, #1
   3aee8:	1dea      	adds	r2, r5, #7
   3aeea:	2114      	movs	r1, #20
   3aeec:	4620      	mov	r0, r4
   3aeee:	f7ff fefd 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3aef2:	b928      	cbnz	r0, 3af00 <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3aef4:	4601      	mov	r1, r0
   3aef6:	4620      	mov	r0, r4
}
   3aef8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3aefc:	f7ff bfa4 	b.w	3ae48 <lsm6dso_mem_bank_set>
}
   3af00:	bd38      	pop	{r3, r4, r5, pc}

0003af02 <lsm6dso_number_of_steps_get>:
{
   3af02:	b538      	push	{r3, r4, r5, lr}
   3af04:	460d      	mov	r5, r1
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3af06:	2102      	movs	r1, #2
{
   3af08:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3af0a:	f7ff ff9d 	bl	3ae48 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   3af0e:	b960      	cbnz	r0, 3af2a <lsm6dso_number_of_steps_get+0x28>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_STEP_COUNTER_L, buff, 2);
   3af10:	2302      	movs	r3, #2
   3af12:	462a      	mov	r2, r5
   3af14:	2162      	movs	r1, #98	; 0x62
   3af16:	4620      	mov	r0, r4
   3af18:	f7ff fee8 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3af1c:	b928      	cbnz	r0, 3af2a <lsm6dso_number_of_steps_get+0x28>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3af1e:	4601      	mov	r1, r0
   3af20:	4620      	mov	r0, r4
}
   3af22:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3af26:	f7ff bf8f 	b.w	3ae48 <lsm6dso_mem_bank_set>
}
   3af2a:	bd38      	pop	{r3, r4, r5, pc}

0003af2c <lsm6dso_steps_reset>:
{
   3af2c:	b513      	push	{r0, r1, r4, lr}
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3af2e:	2102      	movs	r1, #2
{
   3af30:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3af32:	f7ff ff89 	bl	3ae48 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   3af36:	b9b8      	cbnz	r0, 3af68 <lsm6dso_steps_reset+0x3c>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_SRC, (uint8_t*)&reg, 1);
   3af38:	2301      	movs	r3, #1
   3af3a:	aa01      	add	r2, sp, #4
   3af3c:	2164      	movs	r1, #100	; 0x64
   3af3e:	4620      	mov	r0, r4
   3af40:	f7ff fed4 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3af44:	b980      	cbnz	r0, 3af68 <lsm6dso_steps_reset+0x3c>
    reg.pedo_rst_step = PROPERTY_ENABLE;
   3af46:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_SRC, (uint8_t*)&reg, 1);
   3af4a:	aa01      	add	r2, sp, #4
    reg.pedo_rst_step = PROPERTY_ENABLE;
   3af4c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   3af50:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_SRC, (uint8_t*)&reg, 1);
   3af54:	2164      	movs	r1, #100	; 0x64
   3af56:	2301      	movs	r3, #1
   3af58:	4620      	mov	r0, r4
   3af5a:	f7ff fece 	bl	3acfa <lsm6dso_write_reg>
  if (ret == 0) {
   3af5e:	b918      	cbnz	r0, 3af68 <lsm6dso_steps_reset+0x3c>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3af60:	4601      	mov	r1, r0
   3af62:	4620      	mov	r0, r4
   3af64:	f7ff ff70 	bl	3ae48 <lsm6dso_mem_bank_set>
}
   3af68:	b002      	add	sp, #8
   3af6a:	bd10      	pop	{r4, pc}

0003af6c <lsm6dso_ln_pg_write_byte>:
  * @param  val      value to write
  *
  */
int32_t lsm6dso_ln_pg_write_byte(stmdev_ctx_t *ctx, uint16_t address,
                                 uint8_t *val)
{
   3af6c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   3af70:	460f      	mov	r7, r1
  lsm6dso_page_rw_t page_rw;
  lsm6dso_page_sel_t page_sel;
  lsm6dso_page_address_t page_address;
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3af72:	2102      	movs	r1, #2
{
   3af74:	4604      	mov	r4, r0
   3af76:	4690      	mov	r8, r2
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3af78:	f7ff ff66 	bl	3ae48 <lsm6dso_mem_bank_set>

  if (ret == 0) {
   3af7c:	2800      	cmp	r0, #0
   3af7e:	d156      	bne.n	3b02e <lsm6dso_ln_pg_write_byte+0xc2>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3af80:	2301      	movs	r3, #1
   3af82:	aa01      	add	r2, sp, #4
   3af84:	2117      	movs	r1, #23
   3af86:	4620      	mov	r0, r4
   3af88:	f7ff feb0 	bl	3acec <lsm6dso_read_reg>
  }
  if (ret == 0) {
   3af8c:	2800      	cmp	r0, #0
   3af8e:	d14e      	bne.n	3b02e <lsm6dso_ln_pg_write_byte+0xc2>
    page_rw.page_rw = 0x02; /* page_write enable */
   3af90:	2602      	movs	r6, #2
   3af92:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3af96:	aa01      	add	r2, sp, #4
    page_rw.page_rw = 0x02; /* page_write enable */
   3af98:	f366 1346 	bfi	r3, r6, #5, #2
   3af9c:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3afa0:	2117      	movs	r1, #23
   3afa2:	2301      	movs	r3, #1
   3afa4:	4620      	mov	r0, r4
   3afa6:	f7ff fea8 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3afaa:	2800      	cmp	r0, #0
   3afac:	d13f      	bne.n	3b02e <lsm6dso_ln_pg_write_byte+0xc2>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   3afae:	2301      	movs	r3, #1
   3afb0:	aa02      	add	r2, sp, #8
   3afb2:	4631      	mov	r1, r6
   3afb4:	4620      	mov	r0, r4
   3afb6:	f7ff fe99 	bl	3acec <lsm6dso_read_reg>
  }

  if (ret == 0) {
   3afba:	bbc0      	cbnz	r0, 3b02e <lsm6dso_ln_pg_write_byte+0xc2>
    page_sel.page_sel = ((uint8_t)(address >> 8) & 0x0FU);
    page_sel.not_used_01 = 1;
   3afbc:	2501      	movs	r5, #1
    page_sel.page_sel = ((uint8_t)(address >> 8) & 0x0FU);
   3afbe:	f89d 3008 	ldrb.w	r3, [sp, #8]
   3afc2:	0a3a      	lsrs	r2, r7, #8
   3afc4:	f362 1307 	bfi	r3, r2, #4, #4
    page_sel.not_used_01 = 1;
   3afc8:	f365 0303 	bfi	r3, r5, #0, #4
   3afcc:	f88d 3008 	strb.w	r3, [sp, #8]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   3afd0:	aa02      	add	r2, sp, #8
   3afd2:	462b      	mov	r3, r5
   3afd4:	4631      	mov	r1, r6
   3afd6:	4620      	mov	r0, r4
   3afd8:	f7ff fe8f 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3afdc:	bb38      	cbnz	r0, 3b02e <lsm6dso_ln_pg_write_byte+0xc2>
    page_address.page_addr = (uint8_t)address & 0xFFU;
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_ADDRESS,
   3afde:	462b      	mov	r3, r5
   3afe0:	aa03      	add	r2, sp, #12
   3afe2:	2108      	movs	r1, #8
   3afe4:	4620      	mov	r0, r4
    page_address.page_addr = (uint8_t)address & 0xFFU;
   3afe6:	f88d 700c 	strb.w	r7, [sp, #12]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_ADDRESS,
   3afea:	f7ff fe86 	bl	3acfa <lsm6dso_write_reg>
                            (uint8_t*)&page_address, 1);
  }
  if (ret == 0) {
   3afee:	b9f0      	cbnz	r0, 3b02e <lsm6dso_ln_pg_write_byte+0xc2>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_VALUE, val, 1);
   3aff0:	462b      	mov	r3, r5
   3aff2:	4642      	mov	r2, r8
   3aff4:	2109      	movs	r1, #9
   3aff6:	4620      	mov	r0, r4
   3aff8:	f7ff fe7f 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3affc:	b9b8      	cbnz	r0, 3b02e <lsm6dso_ln_pg_write_byte+0xc2>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3affe:	462b      	mov	r3, r5
   3b000:	aa01      	add	r2, sp, #4
   3b002:	2117      	movs	r1, #23
   3b004:	4620      	mov	r0, r4
   3b006:	f7ff fe71 	bl	3acec <lsm6dso_read_reg>
  }
  if (ret == 0) {
   3b00a:	b980      	cbnz	r0, 3b02e <lsm6dso_ln_pg_write_byte+0xc2>
    page_rw.page_rw = 0x00; /* page_write disable */
   3b00c:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b010:	aa01      	add	r2, sp, #4
    page_rw.page_rw = 0x00; /* page_write disable */
   3b012:	f360 1346 	bfi	r3, r0, #5, #2
   3b016:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b01a:	2117      	movs	r1, #23
   3b01c:	462b      	mov	r3, r5
   3b01e:	4620      	mov	r0, r4
   3b020:	f7ff fe6b 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3b024:	b918      	cbnz	r0, 3b02e <lsm6dso_ln_pg_write_byte+0xc2>

    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3b026:	4601      	mov	r1, r0
   3b028:	4620      	mov	r0, r4
   3b02a:	f7ff ff0d 	bl	3ae48 <lsm6dso_mem_bank_set>
  }
  return ret;
}
   3b02e:	b004      	add	sp, #16
   3b030:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0003b034 <lsm6dso_ln_pg_write>:
  * @param  uint8_t len: buffer len
  *
  */
int32_t lsm6dso_ln_pg_write(stmdev_ctx_t *ctx, uint16_t address,
                            uint8_t *buf, uint8_t len)
{
   3b034:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   3b038:	460d      	mov	r5, r1
   3b03a:	b085      	sub	sp, #20
  int32_t ret;
  uint8_t i ;

  addr_pointed = address;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3b03c:	2102      	movs	r1, #2
{
   3b03e:	4604      	mov	r4, r0
   3b040:	4616      	mov	r6, r2
   3b042:	4698      	mov	r8, r3
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3b044:	f7ff ff00 	bl	3ae48 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   3b048:	2800      	cmp	r0, #0
   3b04a:	d15f      	bne.n	3b10c <lsm6dso_ln_pg_write+0xd8>

    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b04c:	2301      	movs	r3, #1
   3b04e:	aa01      	add	r2, sp, #4
   3b050:	2117      	movs	r1, #23
   3b052:	4620      	mov	r0, r4
   3b054:	f7ff fe4a 	bl	3acec <lsm6dso_read_reg>
  }
  if (ret == 0) {
   3b058:	2800      	cmp	r0, #0
   3b05a:	d157      	bne.n	3b10c <lsm6dso_ln_pg_write+0xd8>
    page_rw.page_rw = 0x02; /* page_write enable*/
   3b05c:	f04f 0902 	mov.w	r9, #2
   3b060:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b064:	aa01      	add	r2, sp, #4
    page_rw.page_rw = 0x02; /* page_write enable*/
   3b066:	f369 1346 	bfi	r3, r9, #5, #2
   3b06a:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b06e:	2117      	movs	r1, #23
   3b070:	2301      	movs	r3, #1
   3b072:	4620      	mov	r0, r4
   3b074:	f7ff fe41 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3b078:	2800      	cmp	r0, #0
   3b07a:	d147      	bne.n	3b10c <lsm6dso_ln_pg_write+0xd8>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   3b07c:	2301      	movs	r3, #1
   3b07e:	aa02      	add	r2, sp, #8
   3b080:	4649      	mov	r1, r9
   3b082:	4620      	mov	r0, r4
   3b084:	f7ff fe32 	bl	3acec <lsm6dso_read_reg>
  }
  if (ret == 0) {
   3b088:	2800      	cmp	r0, #0
   3b08a:	d13f      	bne.n	3b10c <lsm6dso_ln_pg_write+0xd8>
    page_sel.page_sel = ((uint8_t)(addr_pointed >> 8) & 0x0FU);
    page_sel.not_used_01 = 1;
   3b08c:	2701      	movs	r7, #1
    page_sel.page_sel = ((uint8_t)(addr_pointed >> 8) & 0x0FU);
   3b08e:	f89d 3008 	ldrb.w	r3, [sp, #8]
   3b092:	0a2a      	lsrs	r2, r5, #8
   3b094:	f362 1307 	bfi	r3, r2, #4, #4
    page_sel.not_used_01 = 1;
   3b098:	f367 0303 	bfi	r3, r7, #0, #4
   3b09c:	f88d 3008 	strb.w	r3, [sp, #8]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   3b0a0:	aa02      	add	r2, sp, #8
   3b0a2:	463b      	mov	r3, r7
   3b0a4:	4649      	mov	r1, r9
   3b0a6:	4620      	mov	r0, r4
   3b0a8:	f7ff fe27 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3b0ac:	bb70      	cbnz	r0, 3b10c <lsm6dso_ln_pg_write+0xd8>
    page_address.page_addr = (uint8_t)(addr_pointed & 0x00FFU);
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_ADDRESS,
   3b0ae:	463b      	mov	r3, r7
   3b0b0:	aa03      	add	r2, sp, #12
   3b0b2:	2108      	movs	r1, #8
   3b0b4:	4620      	mov	r0, r4
    page_address.page_addr = (uint8_t)(addr_pointed & 0x00FFU);
   3b0b6:	f88d 500c 	strb.w	r5, [sp, #12]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_ADDRESS,
   3b0ba:	f7ff fe1e 	bl	3acfa <lsm6dso_write_reg>
                            (uint8_t*)&page_address, 1);
  }

  if (ret == 0) {
   3b0be:	bb28      	cbnz	r0, 3b10c <lsm6dso_ln_pg_write+0xd8>
   3b0c0:	44b0      	add	r8, r6
    for (i = 0; ( (i < len) && (ret == 0) ); i++) {
   3b0c2:	45b0      	cmp	r8, r6
   3b0c4:	d000      	beq.n	3b0c8 <lsm6dso_ln_pg_write+0x94>
   3b0c6:	b320      	cbz	r0, 3b112 <lsm6dso_ln_pg_write+0xde>
                                  (uint8_t*)&page_sel, 1);
        }
      }
    }
    page_sel.page_sel = 0;
    page_sel.not_used_01 = 1;
   3b0c8:	2501      	movs	r5, #1
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   3b0ca:	aa02      	add	r2, sp, #8
   3b0cc:	462b      	mov	r3, r5
   3b0ce:	2102      	movs	r1, #2
   3b0d0:	4620      	mov	r0, r4
    page_sel.not_used_01 = 1;
   3b0d2:	f88d 5008 	strb.w	r5, [sp, #8]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   3b0d6:	f7ff fe10 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3b0da:	b9b8      	cbnz	r0, 3b10c <lsm6dso_ln_pg_write+0xd8>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b0dc:	462b      	mov	r3, r5
   3b0de:	aa01      	add	r2, sp, #4
   3b0e0:	2117      	movs	r1, #23
   3b0e2:	4620      	mov	r0, r4
   3b0e4:	f7ff fe02 	bl	3acec <lsm6dso_read_reg>
  }
  if (ret == 0) {
   3b0e8:	b980      	cbnz	r0, 3b10c <lsm6dso_ln_pg_write+0xd8>
    page_rw.page_rw = 0x00; /* page_write disable */
   3b0ea:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b0ee:	aa01      	add	r2, sp, #4
    page_rw.page_rw = 0x00; /* page_write disable */
   3b0f0:	f360 1346 	bfi	r3, r0, #5, #2
   3b0f4:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b0f8:	2117      	movs	r1, #23
   3b0fa:	462b      	mov	r3, r5
   3b0fc:	4620      	mov	r0, r4
   3b0fe:	f7ff fdfc 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3b102:	b918      	cbnz	r0, 3b10c <lsm6dso_ln_pg_write+0xd8>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3b104:	4601      	mov	r1, r0
   3b106:	4620      	mov	r0, r4
   3b108:	f7ff fe9e 	bl	3ae48 <lsm6dso_mem_bank_set>
  }
  return ret;
}
   3b10c:	b005      	add	sp, #20
   3b10e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      addr_pointed++;
   3b112:	3501      	adds	r5, #1
      ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_VALUE, &buf[i], 1);
   3b114:	2301      	movs	r3, #1
   3b116:	4632      	mov	r2, r6
   3b118:	2109      	movs	r1, #9
   3b11a:	4620      	mov	r0, r4
      addr_pointed++;
   3b11c:	b2ad      	uxth	r5, r5
      ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_VALUE, &buf[i], 1);
   3b11e:	f7ff fdec 	bl	3acfa <lsm6dso_write_reg>
      if ( ( (addr_pointed % 0x0100U) == 0x00U ) && (ret == 0) ) {
   3b122:	f015 0fff 	tst.w	r5, #255	; 0xff
   3b126:	d116      	bne.n	3b156 <lsm6dso_ln_pg_write+0x122>
   3b128:	b9a8      	cbnz	r0, 3b156 <lsm6dso_ln_pg_write+0x122>
        ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*)&page_sel, 1);
   3b12a:	2301      	movs	r3, #1
   3b12c:	aa02      	add	r2, sp, #8
   3b12e:	2102      	movs	r1, #2
   3b130:	4620      	mov	r0, r4
   3b132:	f7ff fddb 	bl	3acec <lsm6dso_read_reg>
        if (ret == 0) {
   3b136:	b970      	cbnz	r0, 3b156 <lsm6dso_ln_pg_write+0x122>
          page_sel.page_sel = ((uint8_t)(addr_pointed >> 8) & 0x0FU);
   3b138:	f89d 2008 	ldrb.w	r2, [sp, #8]
   3b13c:	0a2b      	lsrs	r3, r5, #8
   3b13e:	f363 1207 	bfi	r2, r3, #4, #4
          page_sel.not_used_01 = 1;
   3b142:	f367 0203 	bfi	r2, r7, #0, #4
   3b146:	f88d 2008 	strb.w	r2, [sp, #8]
          ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_SEL,
   3b14a:	2301      	movs	r3, #1
   3b14c:	aa02      	add	r2, sp, #8
   3b14e:	2102      	movs	r1, #2
   3b150:	4620      	mov	r0, r4
   3b152:	f7ff fdd2 	bl	3acfa <lsm6dso_write_reg>
   3b156:	3601      	adds	r6, #1
   3b158:	e7b3      	b.n	3b0c2 <lsm6dso_ln_pg_write+0x8e>

0003b15a <lsm6dso_ln_pg_read_byte>:
  * @param  val      read value
  *
  */
int32_t lsm6dso_ln_pg_read_byte(stmdev_ctx_t *ctx, uint16_t address,
                                uint8_t *val)
{
   3b15a:	b5f0      	push	{r4, r5, r6, r7, lr}
   3b15c:	460e      	mov	r6, r1
   3b15e:	b085      	sub	sp, #20
  lsm6dso_page_rw_t page_rw;
  lsm6dso_page_sel_t page_sel;
  lsm6dso_page_address_t  page_address;
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3b160:	2102      	movs	r1, #2
{
   3b162:	4604      	mov	r4, r0
   3b164:	4617      	mov	r7, r2
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3b166:	f7ff fe6f 	bl	3ae48 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   3b16a:	2800      	cmp	r0, #0
   3b16c:	d155      	bne.n	3b21a <lsm6dso_ln_pg_read_byte+0xc0>

    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b16e:	2301      	movs	r3, #1
   3b170:	aa01      	add	r2, sp, #4
   3b172:	2117      	movs	r1, #23
   3b174:	4620      	mov	r0, r4
   3b176:	f7ff fdb9 	bl	3acec <lsm6dso_read_reg>
  }
  if (ret == 0) {
   3b17a:	2800      	cmp	r0, #0
   3b17c:	d14d      	bne.n	3b21a <lsm6dso_ln_pg_read_byte+0xc0>
    page_rw.page_rw = 0x01; /* page_read enable*/
   3b17e:	2501      	movs	r5, #1
   3b180:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b184:	aa01      	add	r2, sp, #4
    page_rw.page_rw = 0x01; /* page_read enable*/
   3b186:	f365 1346 	bfi	r3, r5, #5, #2
   3b18a:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b18e:	2117      	movs	r1, #23
   3b190:	462b      	mov	r3, r5
   3b192:	4620      	mov	r0, r4
   3b194:	f7ff fdb1 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3b198:	2800      	cmp	r0, #0
   3b19a:	d13e      	bne.n	3b21a <lsm6dso_ln_pg_read_byte+0xc0>

    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   3b19c:	462b      	mov	r3, r5
   3b19e:	aa02      	add	r2, sp, #8
   3b1a0:	2102      	movs	r1, #2
   3b1a2:	4620      	mov	r0, r4
   3b1a4:	f7ff fda2 	bl	3acec <lsm6dso_read_reg>
  }
  if (ret == 0) {
   3b1a8:	bbb8      	cbnz	r0, 3b21a <lsm6dso_ln_pg_read_byte+0xc0>
    page_sel.page_sel = ((uint8_t)(address >> 8) & 0x0FU);
   3b1aa:	f89d 3008 	ldrb.w	r3, [sp, #8]
   3b1ae:	0a32      	lsrs	r2, r6, #8
   3b1b0:	f362 1307 	bfi	r3, r2, #4, #4
    page_sel.not_used_01 = 1;
   3b1b4:	f365 0303 	bfi	r3, r5, #0, #4
   3b1b8:	f88d 3008 	strb.w	r3, [sp, #8]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   3b1bc:	aa02      	add	r2, sp, #8
   3b1be:	462b      	mov	r3, r5
   3b1c0:	2102      	movs	r1, #2
   3b1c2:	4620      	mov	r0, r4
   3b1c4:	f7ff fd99 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3b1c8:	bb38      	cbnz	r0, 3b21a <lsm6dso_ln_pg_read_byte+0xc0>
    page_address.page_addr = (uint8_t)address & 0x00FFU;
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_ADDRESS,
   3b1ca:	462b      	mov	r3, r5
   3b1cc:	aa03      	add	r2, sp, #12
   3b1ce:	2108      	movs	r1, #8
   3b1d0:	4620      	mov	r0, r4
    page_address.page_addr = (uint8_t)address & 0x00FFU;
   3b1d2:	f88d 600c 	strb.w	r6, [sp, #12]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_ADDRESS,
   3b1d6:	f7ff fd90 	bl	3acfa <lsm6dso_write_reg>
                            (uint8_t*)&page_address, 1);
  }
  if (ret == 0) {
   3b1da:	b9f0      	cbnz	r0, 3b21a <lsm6dso_ln_pg_read_byte+0xc0>

    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_VALUE, val, 1);
   3b1dc:	462b      	mov	r3, r5
   3b1de:	463a      	mov	r2, r7
   3b1e0:	2109      	movs	r1, #9
   3b1e2:	4620      	mov	r0, r4
   3b1e4:	f7ff fd82 	bl	3acec <lsm6dso_read_reg>
  }
  if (ret == 0) {
   3b1e8:	b9b8      	cbnz	r0, 3b21a <lsm6dso_ln_pg_read_byte+0xc0>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b1ea:	462b      	mov	r3, r5
   3b1ec:	aa01      	add	r2, sp, #4
   3b1ee:	2117      	movs	r1, #23
   3b1f0:	4620      	mov	r0, r4
   3b1f2:	f7ff fd7b 	bl	3acec <lsm6dso_read_reg>
  }
  if (ret == 0) {
   3b1f6:	b980      	cbnz	r0, 3b21a <lsm6dso_ln_pg_read_byte+0xc0>
    page_rw.page_rw = 0x00; /* page_read disable */
   3b1f8:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b1fc:	aa01      	add	r2, sp, #4
    page_rw.page_rw = 0x00; /* page_read disable */
   3b1fe:	f360 1346 	bfi	r3, r0, #5, #2
   3b202:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b206:	2117      	movs	r1, #23
   3b208:	462b      	mov	r3, r5
   3b20a:	4620      	mov	r0, r4
   3b20c:	f7ff fd75 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3b210:	b918      	cbnz	r0, 3b21a <lsm6dso_ln_pg_read_byte+0xc0>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3b212:	4601      	mov	r1, r0
   3b214:	4620      	mov	r0, r4
   3b216:	f7ff fe17 	bl	3ae48 <lsm6dso_mem_bank_set>
  }

  return ret;
}
   3b21a:	b005      	add	sp, #20
   3b21c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0003b21e <lsm6dso_data_ready_mode_set>:
  *                                     reg COUNTER_BDR_REG1
  *
  */
int32_t lsm6dso_data_ready_mode_set(stmdev_ctx_t *ctx,
                                    lsm6dso_dataready_pulsed_t val)
{
   3b21e:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_counter_bdr_reg1_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_COUNTER_BDR_REG1, (uint8_t*)&reg, 1);
   3b220:	2301      	movs	r3, #1
{
   3b222:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_COUNTER_BDR_REG1, (uint8_t*)&reg, 1);
   3b224:	aa01      	add	r2, sp, #4
   3b226:	210b      	movs	r1, #11
{
   3b228:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_COUNTER_BDR_REG1, (uint8_t*)&reg, 1);
   3b22a:	f7ff fd5f 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b22e:	b958      	cbnz	r0, 3b248 <lsm6dso_data_ready_mode_set+0x2a>
    reg.dataready_pulsed = (uint8_t)val;
   3b230:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_COUNTER_BDR_REG1, (uint8_t*)&reg, 1);
   3b234:	aa01      	add	r2, sp, #4
    reg.dataready_pulsed = (uint8_t)val;
   3b236:	f365 13c7 	bfi	r3, r5, #7, #1
   3b23a:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_COUNTER_BDR_REG1, (uint8_t*)&reg, 1);
   3b23e:	210b      	movs	r1, #11
   3b240:	2301      	movs	r3, #1
   3b242:	4620      	mov	r0, r4
   3b244:	f7ff fd59 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3b248:	b003      	add	sp, #12
   3b24a:	bd30      	pop	{r4, r5, pc}

0003b24c <lsm6dso_device_id_get>:
  *
  */
int32_t lsm6dso_device_id_get(stmdev_ctx_t *ctx, uint8_t *buff)
{
  int32_t ret;
  ret = lsm6dso_read_reg(ctx, LSM6DSO_WHO_AM_I, buff, 1);
   3b24c:	460a      	mov	r2, r1
   3b24e:	2301      	movs	r3, #1
   3b250:	210f      	movs	r1, #15
   3b252:	f7ff bd4b 	b.w	3acec <lsm6dso_read_reg>

0003b256 <lsm6dso_reset_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of sw_reset in reg CTRL3_C
  *
  */
int32_t lsm6dso_reset_set(stmdev_ctx_t *ctx, uint8_t val)
{
   3b256:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_ctrl3_c_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   3b258:	2301      	movs	r3, #1
{
   3b25a:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   3b25c:	aa01      	add	r2, sp, #4
   3b25e:	2112      	movs	r1, #18
{
   3b260:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   3b262:	f7ff fd43 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b266:	b958      	cbnz	r0, 3b280 <lsm6dso_reset_set+0x2a>
    reg.sw_reset = val;
   3b268:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   3b26c:	aa01      	add	r2, sp, #4
    reg.sw_reset = val;
   3b26e:	f365 0300 	bfi	r3, r5, #0, #1
   3b272:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   3b276:	2112      	movs	r1, #18
   3b278:	2301      	movs	r3, #1
   3b27a:	4620      	mov	r0, r4
   3b27c:	f7ff fd3d 	bl	3acfa <lsm6dso_write_reg>
  }

  return ret;
}
   3b280:	b003      	add	sp, #12
   3b282:	bd30      	pop	{r4, r5, pc}

0003b284 <lsm6dso_reset_get>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of sw_reset in reg CTRL3_C
  *
  */
int32_t lsm6dso_reset_get(stmdev_ctx_t *ctx, uint8_t *val)
{
   3b284:	b513      	push	{r0, r1, r4, lr}
  lsm6dso_ctrl3_c_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   3b286:	2301      	movs	r3, #1
{
   3b288:	460c      	mov	r4, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   3b28a:	aa01      	add	r2, sp, #4
   3b28c:	2112      	movs	r1, #18
   3b28e:	f7ff fd2d 	bl	3acec <lsm6dso_read_reg>
  *val = reg.sw_reset;
   3b292:	f89d 3004 	ldrb.w	r3, [sp, #4]
   3b296:	f3c3 0300 	ubfx	r3, r3, #0, #1
   3b29a:	7023      	strb	r3, [r4, #0]

  return ret;
}
   3b29c:	b002      	add	sp, #8
   3b29e:	bd10      	pop	{r4, pc}

0003b2a0 <lsm6dso_i3c_disable_set>:
  * @param  val      change the values of i3c_disable
  *                                    in reg CTRL9_XL
  *
  */
int32_t lsm6dso_i3c_disable_set(stmdev_ctx_t *ctx, lsm6dso_i3c_disable_t val)
{
   3b2a0:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_i3c_bus_avb_t i3c_bus_avb;
  lsm6dso_ctrl9_xl_t ctrl9_xl;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
   3b2a2:	2301      	movs	r3, #1
{
   3b2a4:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
   3b2a6:	aa01      	add	r2, sp, #4
   3b2a8:	2118      	movs	r1, #24
{
   3b2aa:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
   3b2ac:	f7ff fd1e 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b2b0:	bb00      	cbnz	r0, 3b2f4 <lsm6dso_i3c_disable_set+0x54>
    ctrl9_xl.i3c_disable = ((uint8_t)val & 0x80U) >> 7;
   3b2b2:	f89d 2004 	ldrb.w	r2, [sp, #4]
   3b2b6:	09eb      	lsrs	r3, r5, #7
   3b2b8:	f363 0241 	bfi	r2, r3, #1, #1
   3b2bc:	f88d 2004 	strb.w	r2, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
   3b2c0:	2301      	movs	r3, #1
   3b2c2:	aa01      	add	r2, sp, #4
   3b2c4:	2118      	movs	r1, #24
   3b2c6:	4620      	mov	r0, r4
   3b2c8:	f7ff fd17 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3b2cc:	b990      	cbnz	r0, 3b2f4 <lsm6dso_i3c_disable_set+0x54>

    ret = lsm6dso_read_reg(ctx, LSM6DSO_I3C_BUS_AVB,
   3b2ce:	2301      	movs	r3, #1
   3b2d0:	466a      	mov	r2, sp
   3b2d2:	2162      	movs	r1, #98	; 0x62
   3b2d4:	4620      	mov	r0, r4
   3b2d6:	f7ff fd09 	bl	3acec <lsm6dso_read_reg>
                           (uint8_t*)&i3c_bus_avb, 1);
  }
  if (ret == 0) {
   3b2da:	b958      	cbnz	r0, 3b2f4 <lsm6dso_i3c_disable_set+0x54>
    i3c_bus_avb.i3c_bus_avb_sel = (uint8_t)val & 0x03U;
   3b2dc:	f89d 3000 	ldrb.w	r3, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_I3C_BUS_AVB,
   3b2e0:	466a      	mov	r2, sp
    i3c_bus_avb.i3c_bus_avb_sel = (uint8_t)val & 0x03U;
   3b2e2:	f365 03c4 	bfi	r3, r5, #3, #2
   3b2e6:	f88d 3000 	strb.w	r3, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_I3C_BUS_AVB,
   3b2ea:	2162      	movs	r1, #98	; 0x62
   3b2ec:	2301      	movs	r3, #1
   3b2ee:	4620      	mov	r0, r4
   3b2f0:	f7ff fd03 	bl	3acfa <lsm6dso_write_reg>
                            (uint8_t*)&i3c_bus_avb, 1);
  }

  return ret;
}
   3b2f4:	b003      	add	sp, #12
   3b2f6:	bd30      	pop	{r4, r5, pc}

0003b2f8 <lsm6dso_pin_int1_route_get>:
  *                  EMB_FUNC_INT1, FSM_INT1_A, FSM_INT1_B
  *
  */
int32_t lsm6dso_pin_int1_route_get(stmdev_ctx_t *ctx,
                                   lsm6dso_pin_int1_route_t *val)
{
   3b2f8:	b570      	push	{r4, r5, r6, lr}
   3b2fa:	460d      	mov	r5, r1
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3b2fc:	2102      	movs	r1, #2
{
   3b2fe:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3b300:	f7ff fda2 	bl	3ae48 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   3b304:	bb40      	cbnz	r0, 3b358 <lsm6dso_pin_int1_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_INT1,
   3b306:	2301      	movs	r3, #1
   3b308:	1caa      	adds	r2, r5, #2
   3b30a:	210a      	movs	r1, #10
   3b30c:	4620      	mov	r0, r4
   3b30e:	f7ff fced 	bl	3acec <lsm6dso_read_reg>
                           (uint8_t*)&val->emb_func_int1, 1);
  }
  if (ret == 0) {
   3b312:	bb08      	cbnz	r0, 3b358 <lsm6dso_pin_int1_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FSM_INT1_A,
   3b314:	2301      	movs	r3, #1
   3b316:	1cea      	adds	r2, r5, #3
   3b318:	210b      	movs	r1, #11
   3b31a:	4620      	mov	r0, r4
   3b31c:	f7ff fce6 	bl	3acec <lsm6dso_read_reg>
                           (uint8_t*)&val->fsm_int1_a, 1);
  }
  if (ret == 0) {
   3b320:	b9d0      	cbnz	r0, 3b358 <lsm6dso_pin_int1_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FSM_INT1_B,
   3b322:	2301      	movs	r3, #1
   3b324:	1d2a      	adds	r2, r5, #4
   3b326:	210c      	movs	r1, #12
   3b328:	4620      	mov	r0, r4
   3b32a:	f7ff fcdf 	bl	3acec <lsm6dso_read_reg>
                           (uint8_t*)&val->fsm_int1_b, 1);
  }
  if (ret == 0) {
   3b32e:	b998      	cbnz	r0, 3b358 <lsm6dso_pin_int1_route_get+0x60>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3b330:	4601      	mov	r1, r0
   3b332:	4620      	mov	r0, r4
   3b334:	f7ff fd88 	bl	3ae48 <lsm6dso_mem_bank_set>
  }
  if (ret == 0) {
   3b338:	b970      	cbnz	r0, 3b358 <lsm6dso_pin_int1_route_get+0x60>

    ret = lsm6dso_read_reg(ctx, LSM6DSO_INT1_CTRL,
   3b33a:	2301      	movs	r3, #1
   3b33c:	462a      	mov	r2, r5
   3b33e:	210d      	movs	r1, #13
   3b340:	4620      	mov	r0, r4
   3b342:	f7ff fcd3 	bl	3acec <lsm6dso_read_reg>
                           (uint8_t*)&val->int1_ctrl, 1);
  }
  if (ret == 0) {
   3b346:	b938      	cbnz	r0, 3b358 <lsm6dso_pin_int1_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_MD1_CFG, (uint8_t*)&val->md1_cfg, 1);
   3b348:	2301      	movs	r3, #1
   3b34a:	4620      	mov	r0, r4
   3b34c:	18ea      	adds	r2, r5, r3
   3b34e:	215e      	movs	r1, #94	; 0x5e
  }

  return ret;
}
   3b350:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    ret = lsm6dso_read_reg(ctx, LSM6DSO_MD1_CFG, (uint8_t*)&val->md1_cfg, 1);
   3b354:	f7ff bcca 	b.w	3acec <lsm6dso_read_reg>
}
   3b358:	bd70      	pop	{r4, r5, r6, pc}

0003b35a <lsm6dso_pin_int2_route_set>:
  *                  EMB_FUNC_INT2, FSM_INT2_A, FSM_INT2_B
  *
  */
int32_t lsm6dso_pin_int2_route_set(stmdev_ctx_t *ctx,
                                   lsm6dso_pin_int2_route_t *val)
{
   3b35a:	b530      	push	{r4, r5, lr}
   3b35c:	460d      	mov	r5, r1
   3b35e:	b085      	sub	sp, #20
  lsm6dso_pin_int1_route_t pin_int1_route;
  lsm6dso_tap_cfg2_t tap_cfg2;
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3b360:	2102      	movs	r1, #2
{
   3b362:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3b364:	f7ff fd70 	bl	3ae48 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   3b368:	2800      	cmp	r0, #0
   3b36a:	f040 80de 	bne.w	3b52a <lsm6dso_pin_int2_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_INT2,
   3b36e:	2301      	movs	r3, #1
   3b370:	1caa      	adds	r2, r5, #2
   3b372:	210e      	movs	r1, #14
   3b374:	4620      	mov	r0, r4
   3b376:	f7ff fcc0 	bl	3acfa <lsm6dso_write_reg>
                            (uint8_t*)&val->emb_func_int2, 1);
  }
  if (ret == 0) {
   3b37a:	2800      	cmp	r0, #0
   3b37c:	f040 80d5 	bne.w	3b52a <lsm6dso_pin_int2_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FSM_INT2_A,
   3b380:	2301      	movs	r3, #1
   3b382:	1cea      	adds	r2, r5, #3
   3b384:	210f      	movs	r1, #15
   3b386:	4620      	mov	r0, r4
   3b388:	f7ff fcb7 	bl	3acfa <lsm6dso_write_reg>
                            (uint8_t*)&val->fsm_int2_a, 1);
  }
  if (ret == 0) {
   3b38c:	2800      	cmp	r0, #0
   3b38e:	f040 80cc 	bne.w	3b52a <lsm6dso_pin_int2_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FSM_INT2_B,
   3b392:	2301      	movs	r3, #1
   3b394:	1d2a      	adds	r2, r5, #4
   3b396:	2110      	movs	r1, #16
   3b398:	4620      	mov	r0, r4
   3b39a:	f7ff fcae 	bl	3acfa <lsm6dso_write_reg>
                            (uint8_t*)&val->fsm_int2_b, 1);
  }
  if (ret == 0) {
   3b39e:	2800      	cmp	r0, #0
   3b3a0:	f040 80c3 	bne.w	3b52a <lsm6dso_pin_int2_route_set+0x1d0>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3b3a4:	4601      	mov	r1, r0
   3b3a6:	4620      	mov	r0, r4
   3b3a8:	f7ff fd4e 	bl	3ae48 <lsm6dso_mem_bank_set>
  }

  if (ret == 0) {
   3b3ac:	2800      	cmp	r0, #0
   3b3ae:	f040 80bc 	bne.w	3b52a <lsm6dso_pin_int2_route_set+0x1d0>
    if (( val->emb_func_int2.int2_fsm_lc
   3b3b2:	78aa      	ldrb	r2, [r5, #2]
      val->md2_cfg.int2_emb_func = PROPERTY_ENABLE;
    }
    else{
      val->md2_cfg.int2_emb_func = PROPERTY_DISABLE;
    }
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT2_CTRL,
   3b3b4:	4620      	mov	r0, r4
        | val->emb_func_int2.int2_sig_mot
   3b3b6:	f3c2 1340 	ubfx	r3, r2, #5, #1
        | val->emb_func_int2.int2_step_detector
   3b3ba:	f3c2 01c0 	ubfx	r1, r2, #3, #1
        | val->emb_func_int2.int2_sig_mot
   3b3be:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
        | val->emb_func_int2.int2_step_detector
   3b3c2:	430b      	orrs	r3, r1
        | val->emb_func_int2.int2_tilt
   3b3c4:	f3c2 1200 	ubfx	r2, r2, #4, #1
   3b3c8:	4313      	orrs	r3, r2
        | val->fsm_int2_a.int2_fsm1
   3b3ca:	78ea      	ldrb	r2, [r5, #3]
   3b3cc:	f3c2 0100 	ubfx	r1, r2, #0, #1
   3b3d0:	430b      	orrs	r3, r1
        | val->fsm_int2_a.int2_fsm2
   3b3d2:	f3c2 0140 	ubfx	r1, r2, #1, #1
   3b3d6:	430b      	orrs	r3, r1
        | val->fsm_int2_a.int2_fsm3
   3b3d8:	f3c2 0180 	ubfx	r1, r2, #2, #1
   3b3dc:	430b      	orrs	r3, r1
        | val->fsm_int2_a.int2_fsm4
   3b3de:	f3c2 01c0 	ubfx	r1, r2, #3, #1
   3b3e2:	430b      	orrs	r3, r1
        | val->fsm_int2_a.int2_fsm5
   3b3e4:	f3c2 1100 	ubfx	r1, r2, #4, #1
   3b3e8:	430b      	orrs	r3, r1
        | val->fsm_int2_a.int2_fsm6
   3b3ea:	f3c2 1140 	ubfx	r1, r2, #5, #1
   3b3ee:	430b      	orrs	r3, r1
        | val->fsm_int2_a.int2_fsm7
   3b3f0:	f3c2 1180 	ubfx	r1, r2, #6, #1
   3b3f4:	430b      	orrs	r3, r1
        | val->fsm_int2_a.int2_fsm8
   3b3f6:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
        | val->fsm_int2_b.int2_fsm9
   3b3fa:	792a      	ldrb	r2, [r5, #4]
   3b3fc:	f3c2 0100 	ubfx	r1, r2, #0, #1
   3b400:	430b      	orrs	r3, r1
        | val->fsm_int2_b.int2_fsm10
   3b402:	f3c2 0140 	ubfx	r1, r2, #1, #1
   3b406:	430b      	orrs	r3, r1
        | val->fsm_int2_b.int2_fsm11
   3b408:	f3c2 0180 	ubfx	r1, r2, #2, #1
   3b40c:	430b      	orrs	r3, r1
        | val->fsm_int2_b.int2_fsm12
   3b40e:	f3c2 01c0 	ubfx	r1, r2, #3, #1
   3b412:	430b      	orrs	r3, r1
        | val->fsm_int2_b.int2_fsm13
   3b414:	f3c2 1100 	ubfx	r1, r2, #4, #1
   3b418:	430b      	orrs	r3, r1
        | val->fsm_int2_b.int2_fsm14
   3b41a:	f3c2 1140 	ubfx	r1, r2, #5, #1
   3b41e:	430b      	orrs	r3, r1
        | val->fsm_int2_b.int2_fsm15
   3b420:	f3c2 1180 	ubfx	r1, r2, #6, #1
   3b424:	430b      	orrs	r3, r1
        | val->fsm_int2_b.int2_fsm16 )!= PROPERTY_DISABLE ){
   3b426:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
   3b42a:	786a      	ldrb	r2, [r5, #1]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT2_CTRL,
   3b42c:	210e      	movs	r1, #14
   3b42e:	f363 0241 	bfi	r2, r3, #1, #1
   3b432:	706a      	strb	r2, [r5, #1]
   3b434:	2301      	movs	r3, #1
   3b436:	462a      	mov	r2, r5
   3b438:	f7ff fc5f 	bl	3acfa <lsm6dso_write_reg>
                            (uint8_t*)&val->int2_ctrl, 1);
  }
  if (ret == 0) {
   3b43c:	2800      	cmp	r0, #0
   3b43e:	d174      	bne.n	3b52a <lsm6dso_pin_int2_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_MD2_CFG, (uint8_t*)&val->md2_cfg, 1);
   3b440:	2301      	movs	r3, #1
   3b442:	215f      	movs	r1, #95	; 0x5f
   3b444:	18ea      	adds	r2, r5, r3
   3b446:	4620      	mov	r0, r4
   3b448:	f7ff fc57 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3b44c:	2800      	cmp	r0, #0
   3b44e:	d16c      	bne.n	3b52a <lsm6dso_pin_int2_route_set+0x1d0>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*) &tap_cfg2, 1);
   3b450:	2301      	movs	r3, #1
   3b452:	aa01      	add	r2, sp, #4
   3b454:	2158      	movs	r1, #88	; 0x58
   3b456:	4620      	mov	r0, r4
   3b458:	f7ff fc48 	bl	3acec <lsm6dso_read_reg>
  }

  if (ret == 0) {
   3b45c:	2800      	cmp	r0, #0
   3b45e:	d164      	bne.n	3b52a <lsm6dso_pin_int2_route_set+0x1d0>
    ret = lsm6dso_pin_int1_route_get(ctx, &pin_int1_route);
   3b460:	a902      	add	r1, sp, #8
   3b462:	4620      	mov	r0, r4
   3b464:	f7ff ff48 	bl	3b2f8 <lsm6dso_pin_int1_route_get>
  }

  if (ret == 0) {
   3b468:	2800      	cmp	r0, #0
   3b46a:	d15e      	bne.n	3b52a <lsm6dso_pin_int2_route_set+0x1d0>
         | val->md2_cfg.int2_double_tap
         | val->md2_cfg.int2_ff
         | val->md2_cfg.int2_wu
         | val->md2_cfg.int2_single_tap
         | val->md2_cfg.int2_sleep_change
         | pin_int1_route.int1_ctrl.den_drdy_flag
   3b46c:	f89d 2008 	ldrb.w	r2, [sp, #8]
      tap_cfg2.interrupts_enable = PROPERTY_ENABLE;
    }
    else{
      tap_cfg2.interrupts_enable = PROPERTY_DISABLE;
    }
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*) &tap_cfg2, 1);
   3b470:	4620      	mov	r0, r4
         | pin_int1_route.int1_ctrl.int1_boot
   3b472:	f3c2 0380 	ubfx	r3, r2, #2, #1
         | pin_int1_route.int1_ctrl.int1_cnt_bdr
   3b476:	f3c2 1180 	ubfx	r1, r2, #6, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b47a:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
   3b47e:	430b      	orrs	r3, r1
         | pin_int1_route.int1_ctrl.int1_drdy_g
   3b480:	f3c2 0140 	ubfx	r1, r2, #1, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b484:	430b      	orrs	r3, r1
         | pin_int1_route.int1_ctrl.int1_drdy_xl
   3b486:	f3c2 0100 	ubfx	r1, r2, #0, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b48a:	430b      	orrs	r3, r1
         | pin_int1_route.int1_ctrl.int1_fifo_full
   3b48c:	f3c2 1140 	ubfx	r1, r2, #5, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b490:	430b      	orrs	r3, r1
         | pin_int1_route.int1_ctrl.int1_fifo_ovr
   3b492:	f3c2 1100 	ubfx	r1, r2, #4, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b496:	430b      	orrs	r3, r1
         | pin_int1_route.int1_ctrl.int1_fifo_th
   3b498:	f3c2 02c0 	ubfx	r2, r2, #3, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b49c:	4313      	orrs	r3, r2
         | pin_int1_route.md1_cfg.int1_6d
   3b49e:	f89d 2009 	ldrb.w	r2, [sp, #9]
   3b4a2:	f3c2 0180 	ubfx	r1, r2, #2, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b4a6:	430b      	orrs	r3, r1
         | pin_int1_route.md1_cfg.int1_double_tap
   3b4a8:	f3c2 01c0 	ubfx	r1, r2, #3, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b4ac:	430b      	orrs	r3, r1
         | pin_int1_route.md1_cfg.int1_ff
   3b4ae:	f3c2 1100 	ubfx	r1, r2, #4, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b4b2:	430b      	orrs	r3, r1
         | pin_int1_route.md1_cfg.int1_wu
   3b4b4:	f3c2 1140 	ubfx	r1, r2, #5, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b4b8:	430b      	orrs	r3, r1
         | pin_int1_route.md1_cfg.int1_single_tap
   3b4ba:	f3c2 1180 	ubfx	r1, r2, #6, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b4be:	430b      	orrs	r3, r1
   3b4c0:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
    if ( ( val->int2_ctrl.int2_cnt_bdr
   3b4c4:	782a      	ldrb	r2, [r5, #0]
   3b4c6:	f3c2 1180 	ubfx	r1, r2, #6, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b4ca:	430b      	orrs	r3, r1
         | val->int2_ctrl.int2_drdy_g
   3b4cc:	f3c2 0140 	ubfx	r1, r2, #1, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b4d0:	430b      	orrs	r3, r1
         | val->int2_ctrl.int2_drdy_temp
   3b4d2:	f3c2 0180 	ubfx	r1, r2, #2, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b4d6:	430b      	orrs	r3, r1
         | val->int2_ctrl.int2_drdy_xl
   3b4d8:	f3c2 0100 	ubfx	r1, r2, #0, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b4dc:	430b      	orrs	r3, r1
         | val->int2_ctrl.int2_fifo_full
   3b4de:	f3c2 1140 	ubfx	r1, r2, #5, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b4e2:	430b      	orrs	r3, r1
         | val->int2_ctrl.int2_fifo_ovr
   3b4e4:	f3c2 1100 	ubfx	r1, r2, #4, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b4e8:	430b      	orrs	r3, r1
         | val->int2_ctrl.int2_fifo_th
   3b4ea:	f3c2 02c0 	ubfx	r2, r2, #3, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b4ee:	4313      	orrs	r3, r2
         | val->md2_cfg.int2_6d
   3b4f0:	786a      	ldrb	r2, [r5, #1]
   3b4f2:	f3c2 0180 	ubfx	r1, r2, #2, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b4f6:	430b      	orrs	r3, r1
         | val->md2_cfg.int2_double_tap
   3b4f8:	f3c2 01c0 	ubfx	r1, r2, #3, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b4fc:	430b      	orrs	r3, r1
         | val->md2_cfg.int2_ff
   3b4fe:	f3c2 1100 	ubfx	r1, r2, #4, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b502:	430b      	orrs	r3, r1
         | val->md2_cfg.int2_wu
   3b504:	f3c2 1140 	ubfx	r1, r2, #5, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b508:	430b      	orrs	r3, r1
         | val->md2_cfg.int2_single_tap
   3b50a:	f3c2 1180 	ubfx	r1, r2, #6, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   3b50e:	430b      	orrs	r3, r1
   3b510:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
   3b514:	f89d 2004 	ldrb.w	r2, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*) &tap_cfg2, 1);
   3b518:	2158      	movs	r1, #88	; 0x58
   3b51a:	f363 12c7 	bfi	r2, r3, #7, #1
   3b51e:	f88d 2004 	strb.w	r2, [sp, #4]
   3b522:	2301      	movs	r3, #1
   3b524:	aa01      	add	r2, sp, #4
   3b526:	f7ff fbe8 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3b52a:	b005      	add	sp, #20
   3b52c:	bd30      	pop	{r4, r5, pc}

0003b52e <lsm6dso_pin_int2_route_get>:
  *                  EMB_FUNC_INT2, FSM_INT2_A, FSM_INT2_B
  *
  */
int32_t lsm6dso_pin_int2_route_get(stmdev_ctx_t *ctx,
                                   lsm6dso_pin_int2_route_t *val)
{
   3b52e:	b570      	push	{r4, r5, r6, lr}
   3b530:	460d      	mov	r5, r1
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3b532:	2102      	movs	r1, #2
{
   3b534:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3b536:	f7ff fc87 	bl	3ae48 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   3b53a:	bb40      	cbnz	r0, 3b58e <lsm6dso_pin_int2_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_INT2,
   3b53c:	2301      	movs	r3, #1
   3b53e:	1caa      	adds	r2, r5, #2
   3b540:	210e      	movs	r1, #14
   3b542:	4620      	mov	r0, r4
   3b544:	f7ff fbd2 	bl	3acec <lsm6dso_read_reg>
                           (uint8_t*)&val->emb_func_int2, 1);
  }
  if (ret == 0) {
   3b548:	bb08      	cbnz	r0, 3b58e <lsm6dso_pin_int2_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FSM_INT2_A,
   3b54a:	2301      	movs	r3, #1
   3b54c:	1cea      	adds	r2, r5, #3
   3b54e:	210f      	movs	r1, #15
   3b550:	4620      	mov	r0, r4
   3b552:	f7ff fbcb 	bl	3acec <lsm6dso_read_reg>
                           (uint8_t*)&val->fsm_int2_a, 1);
  }
  if (ret == 0) {
   3b556:	b9d0      	cbnz	r0, 3b58e <lsm6dso_pin_int2_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FSM_INT2_B,
   3b558:	2301      	movs	r3, #1
   3b55a:	1d2a      	adds	r2, r5, #4
   3b55c:	2110      	movs	r1, #16
   3b55e:	4620      	mov	r0, r4
   3b560:	f7ff fbc4 	bl	3acec <lsm6dso_read_reg>
                           (uint8_t*)&val->fsm_int2_b, 1);
  }
  if (ret == 0) {
   3b564:	b998      	cbnz	r0, 3b58e <lsm6dso_pin_int2_route_get+0x60>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3b566:	4601      	mov	r1, r0
   3b568:	4620      	mov	r0, r4
   3b56a:	f7ff fc6d 	bl	3ae48 <lsm6dso_mem_bank_set>
  }
  if (ret == 0) {
   3b56e:	b970      	cbnz	r0, 3b58e <lsm6dso_pin_int2_route_get+0x60>

    ret = lsm6dso_read_reg(ctx, LSM6DSO_INT2_CTRL,
   3b570:	2301      	movs	r3, #1
   3b572:	462a      	mov	r2, r5
   3b574:	210e      	movs	r1, #14
   3b576:	4620      	mov	r0, r4
   3b578:	f7ff fbb8 	bl	3acec <lsm6dso_read_reg>
                           (uint8_t*)&val->int2_ctrl, 1);
  }
  if (ret == 0) {
   3b57c:	b938      	cbnz	r0, 3b58e <lsm6dso_pin_int2_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_MD2_CFG, (uint8_t*)&val->md2_cfg, 1);
   3b57e:	2301      	movs	r3, #1
   3b580:	4620      	mov	r0, r4
   3b582:	18ea      	adds	r2, r5, r3
   3b584:	215f      	movs	r1, #95	; 0x5f
  }
  return ret;
}
   3b586:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    ret = lsm6dso_read_reg(ctx, LSM6DSO_MD2_CFG, (uint8_t*)&val->md2_cfg, 1);
   3b58a:	f7ff bbaf 	b.w	3acec <lsm6dso_read_reg>
}
   3b58e:	bd70      	pop	{r4, r5, r6, pc}

0003b590 <lsm6dso_pin_int1_route_set>:
{
   3b590:	b530      	push	{r4, r5, lr}
   3b592:	460d      	mov	r5, r1
   3b594:	b085      	sub	sp, #20
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3b596:	2102      	movs	r1, #2
{
   3b598:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3b59a:	f7ff fc55 	bl	3ae48 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   3b59e:	2800      	cmp	r0, #0
   3b5a0:	f040 80de 	bne.w	3b760 <lsm6dso_pin_int1_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_INT1,
   3b5a4:	2301      	movs	r3, #1
   3b5a6:	1caa      	adds	r2, r5, #2
   3b5a8:	210a      	movs	r1, #10
   3b5aa:	4620      	mov	r0, r4
   3b5ac:	f7ff fba5 	bl	3acfa <lsm6dso_write_reg>
  if (ret == 0) {
   3b5b0:	2800      	cmp	r0, #0
   3b5b2:	f040 80d5 	bne.w	3b760 <lsm6dso_pin_int1_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FSM_INT1_A,
   3b5b6:	2301      	movs	r3, #1
   3b5b8:	1cea      	adds	r2, r5, #3
   3b5ba:	210b      	movs	r1, #11
   3b5bc:	4620      	mov	r0, r4
   3b5be:	f7ff fb9c 	bl	3acfa <lsm6dso_write_reg>
  if (ret == 0) {
   3b5c2:	2800      	cmp	r0, #0
   3b5c4:	f040 80cc 	bne.w	3b760 <lsm6dso_pin_int1_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FSM_INT1_B,
   3b5c8:	2301      	movs	r3, #1
   3b5ca:	1d2a      	adds	r2, r5, #4
   3b5cc:	210c      	movs	r1, #12
   3b5ce:	4620      	mov	r0, r4
   3b5d0:	f7ff fb93 	bl	3acfa <lsm6dso_write_reg>
  if (ret == 0) {
   3b5d4:	2800      	cmp	r0, #0
   3b5d6:	f040 80c3 	bne.w	3b760 <lsm6dso_pin_int1_route_set+0x1d0>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3b5da:	4601      	mov	r1, r0
   3b5dc:	4620      	mov	r0, r4
   3b5de:	f7ff fc33 	bl	3ae48 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   3b5e2:	2800      	cmp	r0, #0
   3b5e4:	f040 80bc 	bne.w	3b760 <lsm6dso_pin_int1_route_set+0x1d0>
    if ( ( val->emb_func_int1.int1_fsm_lc
   3b5e8:	78aa      	ldrb	r2, [r5, #2]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT1_CTRL,
   3b5ea:	4620      	mov	r0, r4
         | val->emb_func_int1.int1_sig_mot
   3b5ec:	f3c2 1340 	ubfx	r3, r2, #5, #1
         | val->emb_func_int1.int1_step_detector
   3b5f0:	f3c2 01c0 	ubfx	r1, r2, #3, #1
         | val->emb_func_int1.int1_sig_mot
   3b5f4:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
         | val->emb_func_int1.int1_step_detector
   3b5f8:	430b      	orrs	r3, r1
         | val->emb_func_int1.int1_tilt
   3b5fa:	f3c2 1200 	ubfx	r2, r2, #4, #1
   3b5fe:	4313      	orrs	r3, r2
         | val->fsm_int1_a.int1_fsm1
   3b600:	78ea      	ldrb	r2, [r5, #3]
   3b602:	f3c2 0100 	ubfx	r1, r2, #0, #1
   3b606:	430b      	orrs	r3, r1
         | val->fsm_int1_a.int1_fsm2
   3b608:	f3c2 0140 	ubfx	r1, r2, #1, #1
   3b60c:	430b      	orrs	r3, r1
         | val->fsm_int1_a.int1_fsm3
   3b60e:	f3c2 0180 	ubfx	r1, r2, #2, #1
   3b612:	430b      	orrs	r3, r1
         | val->fsm_int1_a.int1_fsm4
   3b614:	f3c2 01c0 	ubfx	r1, r2, #3, #1
   3b618:	430b      	orrs	r3, r1
         | val->fsm_int1_a.int1_fsm5
   3b61a:	f3c2 1100 	ubfx	r1, r2, #4, #1
   3b61e:	430b      	orrs	r3, r1
         | val->fsm_int1_a.int1_fsm6
   3b620:	f3c2 1140 	ubfx	r1, r2, #5, #1
   3b624:	430b      	orrs	r3, r1
         | val->fsm_int1_a.int1_fsm7
   3b626:	f3c2 1180 	ubfx	r1, r2, #6, #1
   3b62a:	430b      	orrs	r3, r1
         | val->fsm_int1_a.int1_fsm8
   3b62c:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
         | val->fsm_int1_b.int1_fsm9
   3b630:	792a      	ldrb	r2, [r5, #4]
   3b632:	f3c2 0100 	ubfx	r1, r2, #0, #1
   3b636:	430b      	orrs	r3, r1
         | val->fsm_int1_b.int1_fsm10
   3b638:	f3c2 0140 	ubfx	r1, r2, #1, #1
   3b63c:	430b      	orrs	r3, r1
         | val->fsm_int1_b.int1_fsm11
   3b63e:	f3c2 0180 	ubfx	r1, r2, #2, #1
   3b642:	430b      	orrs	r3, r1
         | val->fsm_int1_b.int1_fsm12
   3b644:	f3c2 01c0 	ubfx	r1, r2, #3, #1
   3b648:	430b      	orrs	r3, r1
         | val->fsm_int1_b.int1_fsm13
   3b64a:	f3c2 1100 	ubfx	r1, r2, #4, #1
   3b64e:	430b      	orrs	r3, r1
         | val->fsm_int1_b.int1_fsm14
   3b650:	f3c2 1140 	ubfx	r1, r2, #5, #1
   3b654:	430b      	orrs	r3, r1
         | val->fsm_int1_b.int1_fsm15
   3b656:	f3c2 1180 	ubfx	r1, r2, #6, #1
   3b65a:	430b      	orrs	r3, r1
         | val->fsm_int1_b.int1_fsm16) != PROPERTY_DISABLE){
   3b65c:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
   3b660:	786a      	ldrb	r2, [r5, #1]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT1_CTRL,
   3b662:	210d      	movs	r1, #13
   3b664:	f363 0241 	bfi	r2, r3, #1, #1
   3b668:	706a      	strb	r2, [r5, #1]
   3b66a:	2301      	movs	r3, #1
   3b66c:	462a      	mov	r2, r5
   3b66e:	f7ff fb44 	bl	3acfa <lsm6dso_write_reg>
  if (ret == 0) {
   3b672:	2800      	cmp	r0, #0
   3b674:	d174      	bne.n	3b760 <lsm6dso_pin_int1_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_MD1_CFG, (uint8_t*)&val->md1_cfg, 1);
   3b676:	2301      	movs	r3, #1
   3b678:	215e      	movs	r1, #94	; 0x5e
   3b67a:	18ea      	adds	r2, r5, r3
   3b67c:	4620      	mov	r0, r4
   3b67e:	f7ff fb3c 	bl	3acfa <lsm6dso_write_reg>
  if (ret == 0) {
   3b682:	2800      	cmp	r0, #0
   3b684:	d16c      	bne.n	3b760 <lsm6dso_pin_int1_route_set+0x1d0>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*) &tap_cfg2, 1);
   3b686:	2301      	movs	r3, #1
   3b688:	aa01      	add	r2, sp, #4
   3b68a:	2158      	movs	r1, #88	; 0x58
   3b68c:	4620      	mov	r0, r4
   3b68e:	f7ff fb2d 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b692:	2800      	cmp	r0, #0
   3b694:	d164      	bne.n	3b760 <lsm6dso_pin_int1_route_set+0x1d0>
    ret = lsm6dso_pin_int2_route_get(ctx, &pin_int2_route);
   3b696:	a902      	add	r1, sp, #8
   3b698:	4620      	mov	r0, r4
   3b69a:	f7ff ff48 	bl	3b52e <lsm6dso_pin_int2_route_get>
  if (ret == 0) {
   3b69e:	2800      	cmp	r0, #0
   3b6a0:	d15e      	bne.n	3b760 <lsm6dso_pin_int1_route_set+0x1d0>
    if ( ( pin_int2_route.int2_ctrl.int2_cnt_bdr
   3b6a2:	f89d 2008 	ldrb.w	r2, [sp, #8]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*) &tap_cfg2, 1);
   3b6a6:	4620      	mov	r0, r4
         | pin_int2_route.int2_ctrl.int2_drdy_g
   3b6a8:	f3c2 0140 	ubfx	r1, r2, #1, #1
    if ( ( pin_int2_route.int2_ctrl.int2_cnt_bdr
   3b6ac:	f3c2 1380 	ubfx	r3, r2, #6, #1
         | pin_int2_route.int2_ctrl.int2_drdy_g
   3b6b0:	430b      	orrs	r3, r1
         | pin_int2_route.int2_ctrl.int2_drdy_temp
   3b6b2:	f3c2 0180 	ubfx	r1, r2, #2, #1
   3b6b6:	430b      	orrs	r3, r1
         | pin_int2_route.int2_ctrl.int2_drdy_xl
   3b6b8:	f3c2 0100 	ubfx	r1, r2, #0, #1
   3b6bc:	430b      	orrs	r3, r1
         | pin_int2_route.int2_ctrl.int2_fifo_full
   3b6be:	f3c2 1140 	ubfx	r1, r2, #5, #1
   3b6c2:	430b      	orrs	r3, r1
         | pin_int2_route.int2_ctrl.int2_fifo_ovr
   3b6c4:	f3c2 1100 	ubfx	r1, r2, #4, #1
   3b6c8:	430b      	orrs	r3, r1
         | pin_int2_route.int2_ctrl.int2_fifo_th
   3b6ca:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   3b6ce:	4313      	orrs	r3, r2
         | pin_int2_route.md2_cfg.int2_6d
   3b6d0:	f89d 2009 	ldrb.w	r2, [sp, #9]
   3b6d4:	f3c2 0180 	ubfx	r1, r2, #2, #1
   3b6d8:	430b      	orrs	r3, r1
         | pin_int2_route.md2_cfg.int2_double_tap
   3b6da:	f3c2 01c0 	ubfx	r1, r2, #3, #1
   3b6de:	430b      	orrs	r3, r1
         | pin_int2_route.md2_cfg.int2_ff
   3b6e0:	f3c2 1100 	ubfx	r1, r2, #4, #1
   3b6e4:	430b      	orrs	r3, r1
         | pin_int2_route.md2_cfg.int2_wu
   3b6e6:	f3c2 1140 	ubfx	r1, r2, #5, #1
   3b6ea:	430b      	orrs	r3, r1
         | pin_int2_route.md2_cfg.int2_single_tap
   3b6ec:	f3c2 1180 	ubfx	r1, r2, #6, #1
   3b6f0:	430b      	orrs	r3, r1
         | pin_int2_route.md2_cfg.int2_sleep_change
   3b6f2:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
         | val->int1_ctrl.den_drdy_flag
   3b6f6:	782a      	ldrb	r2, [r5, #0]
         | val->int1_ctrl.int1_boot
   3b6f8:	f3c2 0180 	ubfx	r1, r2, #2, #1
         | val->int1_ctrl.den_drdy_flag
   3b6fc:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
         | val->int1_ctrl.int1_boot
   3b700:	430b      	orrs	r3, r1
         | val->int1_ctrl.int1_cnt_bdr
   3b702:	f3c2 1180 	ubfx	r1, r2, #6, #1
   3b706:	430b      	orrs	r3, r1
         | val->int1_ctrl.int1_drdy_g
   3b708:	f3c2 0140 	ubfx	r1, r2, #1, #1
   3b70c:	430b      	orrs	r3, r1
         | val->int1_ctrl.int1_drdy_xl
   3b70e:	f3c2 0100 	ubfx	r1, r2, #0, #1
   3b712:	430b      	orrs	r3, r1
         | val->int1_ctrl.int1_fifo_full
   3b714:	f3c2 1140 	ubfx	r1, r2, #5, #1
   3b718:	430b      	orrs	r3, r1
         | val->int1_ctrl.int1_fifo_ovr
   3b71a:	f3c2 1100 	ubfx	r1, r2, #4, #1
   3b71e:	430b      	orrs	r3, r1
         | val->int1_ctrl.int1_fifo_th
   3b720:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   3b724:	4313      	orrs	r3, r2
         | val->md1_cfg.int1_6d
   3b726:	786a      	ldrb	r2, [r5, #1]
   3b728:	f3c2 0180 	ubfx	r1, r2, #2, #1
   3b72c:	430b      	orrs	r3, r1
         | val->md1_cfg.int1_double_tap
   3b72e:	f3c2 01c0 	ubfx	r1, r2, #3, #1
   3b732:	430b      	orrs	r3, r1
         | val->md1_cfg.int1_ff
   3b734:	f3c2 1100 	ubfx	r1, r2, #4, #1
   3b738:	430b      	orrs	r3, r1
         | val->md1_cfg.int1_wu
   3b73a:	f3c2 1140 	ubfx	r1, r2, #5, #1
   3b73e:	430b      	orrs	r3, r1
         | val->md1_cfg.int1_single_tap
   3b740:	f3c2 1180 	ubfx	r1, r2, #6, #1
   3b744:	430b      	orrs	r3, r1
         | val->md1_cfg.int1_sleep_change) != PROPERTY_DISABLE) {
   3b746:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
   3b74a:	f89d 2004 	ldrb.w	r2, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*) &tap_cfg2, 1);
   3b74e:	2158      	movs	r1, #88	; 0x58
   3b750:	f363 12c7 	bfi	r2, r3, #7, #1
   3b754:	f88d 2004 	strb.w	r2, [sp, #4]
   3b758:	2301      	movs	r3, #1
   3b75a:	aa01      	add	r2, sp, #4
   3b75c:	f7ff facd 	bl	3acfa <lsm6dso_write_reg>
}
   3b760:	b005      	add	sp, #20
   3b762:	bd30      	pop	{r4, r5, pc}

0003b764 <lsm6dso_int_notification_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of lir in reg TAP_CFG0
  *
  */
int32_t lsm6dso_int_notification_set(stmdev_ctx_t *ctx, lsm6dso_lir_t val)
{
   3b764:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_tap_cfg0_t tap_cfg0;
  lsm6dso_page_rw_t page_rw;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*) &tap_cfg0, 1);
   3b766:	2301      	movs	r3, #1
{
   3b768:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*) &tap_cfg0, 1);
   3b76a:	466a      	mov	r2, sp
   3b76c:	2156      	movs	r1, #86	; 0x56
{
   3b76e:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*) &tap_cfg0, 1);
   3b770:	f7ff fabc 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b774:	bb70      	cbnz	r0, 3b7d4 <lsm6dso_int_notification_set+0x70>
    tap_cfg0.lir = (uint8_t)val & 0x01U;
   3b776:	f89d 3000 	ldrb.w	r3, [sp]
   3b77a:	f005 0201 	and.w	r2, r5, #1
   3b77e:	f362 0300 	bfi	r3, r2, #0, #1
    tap_cfg0.int_clr_on_read = (uint8_t)val & 0x01U;
   3b782:	f362 1386 	bfi	r3, r2, #6, #1
   3b786:	f88d 3000 	strb.w	r3, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*) &tap_cfg0, 1);
   3b78a:	466a      	mov	r2, sp
   3b78c:	2301      	movs	r3, #1
   3b78e:	2156      	movs	r1, #86	; 0x56
   3b790:	4620      	mov	r0, r4
   3b792:	f7ff fab2 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3b796:	b9e8      	cbnz	r0, 3b7d4 <lsm6dso_int_notification_set+0x70>

    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3b798:	2102      	movs	r1, #2
   3b79a:	4620      	mov	r0, r4
   3b79c:	f7ff fb54 	bl	3ae48 <lsm6dso_mem_bank_set>
  }
  if (ret == 0) {
   3b7a0:	b9c0      	cbnz	r0, 3b7d4 <lsm6dso_int_notification_set+0x70>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b7a2:	2301      	movs	r3, #1
   3b7a4:	aa01      	add	r2, sp, #4
   3b7a6:	2117      	movs	r1, #23
   3b7a8:	4620      	mov	r0, r4
   3b7aa:	f7ff fa9f 	bl	3acec <lsm6dso_read_reg>
  }
  if (ret == 0) {
   3b7ae:	b988      	cbnz	r0, 3b7d4 <lsm6dso_int_notification_set+0x70>
    page_rw.emb_func_lir = ((uint8_t)val & 0x02U) >> 1;
   3b7b0:	f89d 3004 	ldrb.w	r3, [sp, #4]
   3b7b4:	086d      	lsrs	r5, r5, #1
   3b7b6:	f365 13c7 	bfi	r3, r5, #7, #1
   3b7ba:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   3b7be:	aa01      	add	r2, sp, #4
   3b7c0:	2301      	movs	r3, #1
   3b7c2:	2117      	movs	r1, #23
   3b7c4:	4620      	mov	r0, r4
   3b7c6:	f7ff fa98 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3b7ca:	b918      	cbnz	r0, 3b7d4 <lsm6dso_int_notification_set+0x70>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3b7cc:	4601      	mov	r1, r0
   3b7ce:	4620      	mov	r0, r4
   3b7d0:	f7ff fb3a 	bl	3ae48 <lsm6dso_mem_bank_set>
  }

  return ret;
}
   3b7d4:	b003      	add	sp, #12
   3b7d6:	bd30      	pop	{r4, r5, pc}

0003b7d8 <lsm6dso_tap_detection_on_z_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of tap_z_en in reg TAP_CFG0
  *
  */
int32_t lsm6dso_tap_detection_on_z_set(stmdev_ctx_t *ctx, uint8_t val)
{
   3b7d8:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_tap_cfg0_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   3b7da:	2301      	movs	r3, #1
{
   3b7dc:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   3b7de:	aa01      	add	r2, sp, #4
   3b7e0:	2156      	movs	r1, #86	; 0x56
{
   3b7e2:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   3b7e4:	f7ff fa82 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b7e8:	b958      	cbnz	r0, 3b802 <lsm6dso_tap_detection_on_z_set+0x2a>
    reg.tap_z_en = val;
   3b7ea:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   3b7ee:	aa01      	add	r2, sp, #4
    reg.tap_z_en = val;
   3b7f0:	f365 0341 	bfi	r3, r5, #1, #1
   3b7f4:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   3b7f8:	2156      	movs	r1, #86	; 0x56
   3b7fa:	2301      	movs	r3, #1
   3b7fc:	4620      	mov	r0, r4
   3b7fe:	f7ff fa7c 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3b802:	b003      	add	sp, #12
   3b804:	bd30      	pop	{r4, r5, pc}

0003b806 <lsm6dso_tap_detection_on_y_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of tap_y_en in reg TAP_CFG0
  *
  */
int32_t lsm6dso_tap_detection_on_y_set(stmdev_ctx_t *ctx, uint8_t val)
{
   3b806:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_tap_cfg0_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   3b808:	2301      	movs	r3, #1
{
   3b80a:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   3b80c:	aa01      	add	r2, sp, #4
   3b80e:	2156      	movs	r1, #86	; 0x56
{
   3b810:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   3b812:	f7ff fa6b 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b816:	b958      	cbnz	r0, 3b830 <lsm6dso_tap_detection_on_y_set+0x2a>
    reg.tap_y_en = val;
   3b818:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   3b81c:	aa01      	add	r2, sp, #4
    reg.tap_y_en = val;
   3b81e:	f365 0382 	bfi	r3, r5, #2, #1
   3b822:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   3b826:	2156      	movs	r1, #86	; 0x56
   3b828:	2301      	movs	r3, #1
   3b82a:	4620      	mov	r0, r4
   3b82c:	f7ff fa65 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3b830:	b003      	add	sp, #12
   3b832:	bd30      	pop	{r4, r5, pc}

0003b834 <lsm6dso_tap_detection_on_x_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of tap_x_en in reg TAP_CFG0
  *
  */
int32_t lsm6dso_tap_detection_on_x_set(stmdev_ctx_t *ctx, uint8_t val)
{
   3b834:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_tap_cfg0_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   3b836:	2301      	movs	r3, #1
{
   3b838:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   3b83a:	aa01      	add	r2, sp, #4
   3b83c:	2156      	movs	r1, #86	; 0x56
{
   3b83e:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   3b840:	f7ff fa54 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b844:	b958      	cbnz	r0, 3b85e <lsm6dso_tap_detection_on_x_set+0x2a>
    reg.tap_x_en = val;
   3b846:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   3b84a:	aa01      	add	r2, sp, #4
    reg.tap_x_en = val;
   3b84c:	f365 03c3 	bfi	r3, r5, #3, #1
   3b850:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   3b854:	2156      	movs	r1, #86	; 0x56
   3b856:	2301      	movs	r3, #1
   3b858:	4620      	mov	r0, r4
   3b85a:	f7ff fa4e 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3b85e:	b003      	add	sp, #12
   3b860:	bd30      	pop	{r4, r5, pc}

0003b862 <lsm6dso_tap_threshold_x_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of tap_ths_x in reg TAP_CFG1
  *
  */
int32_t lsm6dso_tap_threshold_x_set(stmdev_ctx_t *ctx, uint8_t val)
{
   3b862:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_tap_cfg1_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG1, (uint8_t*)&reg, 1);
   3b864:	2301      	movs	r3, #1
{
   3b866:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG1, (uint8_t*)&reg, 1);
   3b868:	aa01      	add	r2, sp, #4
   3b86a:	2157      	movs	r1, #87	; 0x57
{
   3b86c:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG1, (uint8_t*)&reg, 1);
   3b86e:	f7ff fa3d 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b872:	b958      	cbnz	r0, 3b88c <lsm6dso_tap_threshold_x_set+0x2a>
    reg.tap_ths_x = val;
   3b874:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG1, (uint8_t*)&reg, 1);
   3b878:	aa01      	add	r2, sp, #4
    reg.tap_ths_x = val;
   3b87a:	f365 0304 	bfi	r3, r5, #0, #5
   3b87e:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG1, (uint8_t*)&reg, 1);
   3b882:	2157      	movs	r1, #87	; 0x57
   3b884:	2301      	movs	r3, #1
   3b886:	4620      	mov	r0, r4
   3b888:	f7ff fa37 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3b88c:	b003      	add	sp, #12
   3b88e:	bd30      	pop	{r4, r5, pc}

0003b890 <lsm6dso_tap_threshold_y_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of tap_ths_y in reg TAP_CFG2
  *
  */
int32_t lsm6dso_tap_threshold_y_set(stmdev_ctx_t *ctx, uint8_t val)
{
   3b890:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_tap_cfg2_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*)&reg, 1);
   3b892:	2301      	movs	r3, #1
{
   3b894:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*)&reg, 1);
   3b896:	aa01      	add	r2, sp, #4
   3b898:	2158      	movs	r1, #88	; 0x58
{
   3b89a:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*)&reg, 1);
   3b89c:	f7ff fa26 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b8a0:	b958      	cbnz	r0, 3b8ba <lsm6dso_tap_threshold_y_set+0x2a>
    reg.tap_ths_y = val;
   3b8a2:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*)&reg, 1);
   3b8a6:	aa01      	add	r2, sp, #4
    reg.tap_ths_y = val;
   3b8a8:	f365 0304 	bfi	r3, r5, #0, #5
   3b8ac:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*)&reg, 1);
   3b8b0:	2158      	movs	r1, #88	; 0x58
   3b8b2:	2301      	movs	r3, #1
   3b8b4:	4620      	mov	r0, r4
   3b8b6:	f7ff fa20 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3b8ba:	b003      	add	sp, #12
   3b8bc:	bd30      	pop	{r4, r5, pc}

0003b8be <lsm6dso_tap_threshold_z_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of tap_ths_z in reg TAP_THS_6D
  *
  */
int32_t lsm6dso_tap_threshold_z_set(stmdev_ctx_t *ctx, uint8_t val)
{
   3b8be:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_tap_ths_6d_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_THS_6D, (uint8_t*)&reg, 1);
   3b8c0:	2301      	movs	r3, #1
{
   3b8c2:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_THS_6D, (uint8_t*)&reg, 1);
   3b8c4:	aa01      	add	r2, sp, #4
   3b8c6:	2159      	movs	r1, #89	; 0x59
{
   3b8c8:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_THS_6D, (uint8_t*)&reg, 1);
   3b8ca:	f7ff fa0f 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b8ce:	b958      	cbnz	r0, 3b8e8 <lsm6dso_tap_threshold_z_set+0x2a>
    reg.tap_ths_z = val;
   3b8d0:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_THS_6D, (uint8_t*)&reg, 1);
   3b8d4:	aa01      	add	r2, sp, #4
    reg.tap_ths_z = val;
   3b8d6:	f365 0304 	bfi	r3, r5, #0, #5
   3b8da:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_THS_6D, (uint8_t*)&reg, 1);
   3b8de:	2159      	movs	r1, #89	; 0x59
   3b8e0:	2301      	movs	r3, #1
   3b8e2:	4620      	mov	r0, r4
   3b8e4:	f7ff fa09 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3b8e8:	b003      	add	sp, #12
   3b8ea:	bd30      	pop	{r4, r5, pc}

0003b8ec <lsm6dso_tap_shock_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of shock in reg INT_DUR2
  *
  */
int32_t lsm6dso_tap_shock_set(stmdev_ctx_t *ctx, uint8_t val)
{
   3b8ec:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_int_dur2_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   3b8ee:	2301      	movs	r3, #1
{
   3b8f0:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   3b8f2:	aa01      	add	r2, sp, #4
   3b8f4:	215a      	movs	r1, #90	; 0x5a
{
   3b8f6:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   3b8f8:	f7ff f9f8 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b8fc:	b958      	cbnz	r0, 3b916 <lsm6dso_tap_shock_set+0x2a>
    reg.shock = val;
   3b8fe:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   3b902:	aa01      	add	r2, sp, #4
    reg.shock = val;
   3b904:	f365 0301 	bfi	r3, r5, #0, #2
   3b908:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   3b90c:	215a      	movs	r1, #90	; 0x5a
   3b90e:	2301      	movs	r3, #1
   3b910:	4620      	mov	r0, r4
   3b912:	f7ff f9f2 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3b916:	b003      	add	sp, #12
   3b918:	bd30      	pop	{r4, r5, pc}

0003b91a <lsm6dso_tap_quiet_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of quiet in reg INT_DUR2
  *
  */
int32_t lsm6dso_tap_quiet_set(stmdev_ctx_t *ctx, uint8_t val)
{
   3b91a:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_int_dur2_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   3b91c:	2301      	movs	r3, #1
{
   3b91e:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   3b920:	aa01      	add	r2, sp, #4
   3b922:	215a      	movs	r1, #90	; 0x5a
{
   3b924:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   3b926:	f7ff f9e1 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b92a:	b958      	cbnz	r0, 3b944 <lsm6dso_tap_quiet_set+0x2a>
    reg.quiet = val;
   3b92c:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   3b930:	aa01      	add	r2, sp, #4
    reg.quiet = val;
   3b932:	f365 0383 	bfi	r3, r5, #2, #2
   3b936:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   3b93a:	215a      	movs	r1, #90	; 0x5a
   3b93c:	2301      	movs	r3, #1
   3b93e:	4620      	mov	r0, r4
   3b940:	f7ff f9db 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3b944:	b003      	add	sp, #12
   3b946:	bd30      	pop	{r4, r5, pc}

0003b948 <lsm6dso_tap_mode_set>:
  * @param  val      change the values of single_double_tap in reg WAKE_UP_THS
  *
  */
int32_t lsm6dso_tap_mode_set(stmdev_ctx_t *ctx,
                             lsm6dso_single_double_tap_t val)
{
   3b948:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_wake_up_ths_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_WAKE_UP_THS, (uint8_t*)&reg, 1);
   3b94a:	2301      	movs	r3, #1
{
   3b94c:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_WAKE_UP_THS, (uint8_t*)&reg, 1);
   3b94e:	aa01      	add	r2, sp, #4
   3b950:	215b      	movs	r1, #91	; 0x5b
{
   3b952:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_WAKE_UP_THS, (uint8_t*)&reg, 1);
   3b954:	f7ff f9ca 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b958:	b958      	cbnz	r0, 3b972 <lsm6dso_tap_mode_set+0x2a>
    reg.single_double_tap = (uint8_t)val;
   3b95a:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_WAKE_UP_THS, (uint8_t*)&reg, 1);
   3b95e:	aa01      	add	r2, sp, #4
    reg.single_double_tap = (uint8_t)val;
   3b960:	f365 13c7 	bfi	r3, r5, #7, #1
   3b964:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_WAKE_UP_THS, (uint8_t*)&reg, 1);
   3b968:	215b      	movs	r1, #91	; 0x5b
   3b96a:	2301      	movs	r3, #1
   3b96c:	4620      	mov	r0, r4
   3b96e:	f7ff f9c4 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3b972:	b003      	add	sp, #12
   3b974:	bd30      	pop	{r4, r5, pc}

0003b976 <lsm6dso_fifo_watermark_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of wtm in reg FIFO_CTRL1
  *
  */
int32_t lsm6dso_fifo_watermark_set(stmdev_ctx_t *ctx, uint16_t val)
{
   3b976:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_fifo_ctrl1_t fifo_ctrl1;
  lsm6dso_fifo_ctrl2_t fifo_ctrl2;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
   3b978:	2301      	movs	r3, #1
{
   3b97a:	460c      	mov	r4, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
   3b97c:	aa01      	add	r2, sp, #4
   3b97e:	2108      	movs	r1, #8
{
   3b980:	4605      	mov	r5, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
   3b982:	f7ff f9b3 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b986:	b9a8      	cbnz	r0, 3b9b4 <lsm6dso_fifo_watermark_set+0x3e>
    fifo_ctrl1.wtm = 0x00FFU & (uint8_t)val;
    fifo_ctrl2.wtm = (uint8_t)(( 0x0100U & val ) >> 8);
   3b988:	f89d 3004 	ldrb.w	r3, [sp, #4]
    fifo_ctrl1.wtm = 0x00FFU & (uint8_t)val;
   3b98c:	f88d 4000 	strb.w	r4, [sp]
    fifo_ctrl2.wtm = (uint8_t)(( 0x0100U & val ) >> 8);
   3b990:	0a24      	lsrs	r4, r4, #8
   3b992:	f364 0300 	bfi	r3, r4, #0, #1
   3b996:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL1, (uint8_t*)&fifo_ctrl1, 1);
   3b99a:	466a      	mov	r2, sp
   3b99c:	2301      	movs	r3, #1
   3b99e:	2107      	movs	r1, #7
   3b9a0:	4628      	mov	r0, r5
   3b9a2:	f7ff f9aa 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3b9a6:	b928      	cbnz	r0, 3b9b4 <lsm6dso_fifo_watermark_set+0x3e>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
   3b9a8:	2301      	movs	r3, #1
   3b9aa:	aa01      	add	r2, sp, #4
   3b9ac:	2108      	movs	r1, #8
   3b9ae:	4628      	mov	r0, r5
   3b9b0:	f7ff f9a3 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3b9b4:	b003      	add	sp, #12
   3b9b6:	bd30      	pop	{r4, r5, pc}

0003b9b8 <lsm6dso_fifo_stop_on_wtm_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of stop_on_wtm in reg FIFO_CTRL2
  *
  */
int32_t lsm6dso_fifo_stop_on_wtm_set(stmdev_ctx_t *ctx, uint8_t val)
{
   3b9b8:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_fifo_ctrl2_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&reg, 1);
   3b9ba:	2301      	movs	r3, #1
{
   3b9bc:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&reg, 1);
   3b9be:	aa01      	add	r2, sp, #4
   3b9c0:	2108      	movs	r1, #8
{
   3b9c2:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&reg, 1);
   3b9c4:	f7ff f992 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b9c8:	b958      	cbnz	r0, 3b9e2 <lsm6dso_fifo_stop_on_wtm_set+0x2a>
    reg.stop_on_wtm = val;
   3b9ca:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&reg, 1);
   3b9ce:	aa01      	add	r2, sp, #4
    reg.stop_on_wtm = val;
   3b9d0:	f365 13c7 	bfi	r3, r5, #7, #1
   3b9d4:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&reg, 1);
   3b9d8:	2108      	movs	r1, #8
   3b9da:	2301      	movs	r3, #1
   3b9dc:	4620      	mov	r0, r4
   3b9de:	f7ff f98c 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3b9e2:	b003      	add	sp, #12
   3b9e4:	bd30      	pop	{r4, r5, pc}

0003b9e6 <lsm6dso_fifo_xl_batch_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of bdr_xl in reg FIFO_CTRL3
  *
  */
int32_t lsm6dso_fifo_xl_batch_set(stmdev_ctx_t *ctx, lsm6dso_bdr_xl_t val)
{
   3b9e6:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_fifo_ctrl3_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   3b9e8:	2301      	movs	r3, #1
{
   3b9ea:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   3b9ec:	aa01      	add	r2, sp, #4
   3b9ee:	2109      	movs	r1, #9
{
   3b9f0:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   3b9f2:	f7ff f97b 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3b9f6:	b958      	cbnz	r0, 3ba10 <lsm6dso_fifo_xl_batch_set+0x2a>
    reg.bdr_xl = (uint8_t)val;
   3b9f8:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   3b9fc:	aa01      	add	r2, sp, #4
    reg.bdr_xl = (uint8_t)val;
   3b9fe:	f365 0303 	bfi	r3, r5, #0, #4
   3ba02:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   3ba06:	2109      	movs	r1, #9
   3ba08:	2301      	movs	r3, #1
   3ba0a:	4620      	mov	r0, r4
   3ba0c:	f7ff f975 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3ba10:	b003      	add	sp, #12
   3ba12:	bd30      	pop	{r4, r5, pc}

0003ba14 <lsm6dso_fifo_gy_batch_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of bdr_gy in reg FIFO_CTRL3
  *
  */
int32_t lsm6dso_fifo_gy_batch_set(stmdev_ctx_t *ctx, lsm6dso_bdr_gy_t val)
{
   3ba14:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_fifo_ctrl3_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   3ba16:	2301      	movs	r3, #1
{
   3ba18:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   3ba1a:	aa01      	add	r2, sp, #4
   3ba1c:	2109      	movs	r1, #9
{
   3ba1e:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   3ba20:	f7ff f964 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3ba24:	b958      	cbnz	r0, 3ba3e <lsm6dso_fifo_gy_batch_set+0x2a>
    reg.bdr_gy = (uint8_t)val;
   3ba26:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   3ba2a:	aa01      	add	r2, sp, #4
    reg.bdr_gy = (uint8_t)val;
   3ba2c:	f365 1307 	bfi	r3, r5, #4, #4
   3ba30:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   3ba34:	2109      	movs	r1, #9
   3ba36:	2301      	movs	r3, #1
   3ba38:	4620      	mov	r0, r4
   3ba3a:	f7ff f95e 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3ba3e:	b003      	add	sp, #12
   3ba40:	bd30      	pop	{r4, r5, pc}

0003ba42 <lsm6dso_fifo_mode_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of fifo_mode in reg FIFO_CTRL4
  *
  */
int32_t lsm6dso_fifo_mode_set(stmdev_ctx_t *ctx, lsm6dso_fifo_mode_t val)
{
   3ba42:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_fifo_ctrl4_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL4, (uint8_t*)&reg, 1);
   3ba44:	2301      	movs	r3, #1
{
   3ba46:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL4, (uint8_t*)&reg, 1);
   3ba48:	aa01      	add	r2, sp, #4
   3ba4a:	210a      	movs	r1, #10
{
   3ba4c:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL4, (uint8_t*)&reg, 1);
   3ba4e:	f7ff f94d 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3ba52:	b958      	cbnz	r0, 3ba6c <lsm6dso_fifo_mode_set+0x2a>
    reg.fifo_mode = (uint8_t)val;
   3ba54:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL4, (uint8_t*)&reg, 1);
   3ba58:	aa01      	add	r2, sp, #4
    reg.fifo_mode = (uint8_t)val;
   3ba5a:	f365 0302 	bfi	r3, r5, #0, #3
   3ba5e:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL4, (uint8_t*)&reg, 1);
   3ba62:	210a      	movs	r1, #10
   3ba64:	2301      	movs	r3, #1
   3ba66:	4620      	mov	r0, r4
   3ba68:	f7ff f947 	bl	3acfa <lsm6dso_write_reg>
  }
  return ret;
}
   3ba6c:	b003      	add	sp, #12
   3ba6e:	bd30      	pop	{r4, r5, pc}

0003ba70 <lsm6dso_fifo_data_level_get>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of diff_fifo in reg FIFO_STATUS1
  *
  */
int32_t lsm6dso_fifo_data_level_get(stmdev_ctx_t *ctx, uint16_t *val)
{
   3ba70:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_fifo_status1_t fifo_status1;
  lsm6dso_fifo_status2_t fifo_status2;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_STATUS1,
   3ba72:	2301      	movs	r3, #1
{
   3ba74:	460c      	mov	r4, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_STATUS1,
   3ba76:	466a      	mov	r2, sp
   3ba78:	213a      	movs	r1, #58	; 0x3a
{
   3ba7a:	4605      	mov	r5, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_STATUS1,
   3ba7c:	f7ff f936 	bl	3acec <lsm6dso_read_reg>
                         (uint8_t*)&fifo_status1, 1);
  if (ret == 0) {
   3ba80:	b970      	cbnz	r0, 3baa0 <lsm6dso_fifo_data_level_get+0x30>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_STATUS2,
   3ba82:	2301      	movs	r3, #1
   3ba84:	aa01      	add	r2, sp, #4
   3ba86:	213b      	movs	r1, #59	; 0x3b
   3ba88:	4628      	mov	r0, r5
   3ba8a:	f7ff f92f 	bl	3acec <lsm6dso_read_reg>
                           (uint8_t*)&fifo_status2, 1);
    *val = ((uint16_t)fifo_status2.diff_fifo << 8) +
   3ba8e:	f89d 3004 	ldrb.w	r3, [sp, #4]
   3ba92:	f003 0203 	and.w	r2, r3, #3
            (uint16_t)fifo_status1.diff_fifo;
   3ba96:	f89d 3000 	ldrb.w	r3, [sp]
    *val = ((uint16_t)fifo_status2.diff_fifo << 8) +
   3ba9a:	eb03 2302 	add.w	r3, r3, r2, lsl #8
   3ba9e:	8023      	strh	r3, [r4, #0]
  }
  return ret;
}
   3baa0:	b003      	add	sp, #12
   3baa2:	bd30      	pop	{r4, r5, pc}

0003baa4 <lsm6dso_fifo_wtm_flag_get>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of fifo_wtm_ia in reg FIFO_STATUS2
  *
  */
int32_t lsm6dso_fifo_wtm_flag_get(stmdev_ctx_t *ctx, uint8_t *val)
{
   3baa4:	b513      	push	{r0, r1, r4, lr}
  lsm6dso_fifo_status2_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_STATUS2, (uint8_t*)&reg, 1);
   3baa6:	2301      	movs	r3, #1
{
   3baa8:	460c      	mov	r4, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_STATUS2, (uint8_t*)&reg, 1);
   3baaa:	aa01      	add	r2, sp, #4
   3baac:	213b      	movs	r1, #59	; 0x3b
   3baae:	f7ff f91d 	bl	3acec <lsm6dso_read_reg>
  *val = reg.fifo_wtm_ia;
   3bab2:	f89d 3004 	ldrb.w	r3, [sp, #4]
   3bab6:	f3c3 13c0 	ubfx	r3, r3, #7, #1
   3baba:	7023      	strb	r3, [r4, #0]

  return ret;
}
   3babc:	b002      	add	sp, #8
   3babe:	bd10      	pop	{r4, pc}

0003bac0 <lsm6dso_fifo_sensor_tag_get>:
  * @param  val      change the values of tag_sensor in reg FIFO_DATA_OUT_TAG
  *
  */
int32_t lsm6dso_fifo_sensor_tag_get(stmdev_ctx_t *ctx,
                                    lsm6dso_fifo_tag_t *val)
{
   3bac0:	b513      	push	{r0, r1, r4, lr}
  lsm6dso_fifo_data_out_tag_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_DATA_OUT_TAG, (uint8_t*)&reg, 1);
   3bac2:	2301      	movs	r3, #1
{
   3bac4:	460c      	mov	r4, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_DATA_OUT_TAG, (uint8_t*)&reg, 1);
   3bac6:	aa01      	add	r2, sp, #4
   3bac8:	2178      	movs	r1, #120	; 0x78
   3baca:	f7ff f90f 	bl	3acec <lsm6dso_read_reg>
  switch (reg.tag_sensor) {
   3bace:	f89d 3004 	ldrb.w	r3, [sp, #4]
   3bad2:	08db      	lsrs	r3, r3, #3
   3bad4:	3b01      	subs	r3, #1
   3bad6:	2b18      	cmp	r3, #24
   3bad8:	d838      	bhi.n	3bb4c <lsm6dso_fifo_sensor_tag_get+0x8c>
   3bada:	e8df f003 	tbb	[pc, r3]
   3bade:	0d37      	.short	0x0d37
   3bae0:	15133711 	.word	0x15133711
   3bae4:	1d1b1917 	.word	0x1d1b1917
   3bae8:	2523211f 	.word	0x2523211f
   3baec:	2d2b2927 	.word	0x2d2b2927
   3baf0:	3733312f 	.word	0x3733312f
   3baf4:	3737      	.short	0x3737
   3baf6:	35          	.byte	0x35
   3baf7:	00          	.byte	0x00
    case LSM6DSO_GYRO_NC_TAG:
      *val = LSM6DSO_GYRO_NC_TAG;
      break;
    case LSM6DSO_XL_NC_TAG:
      *val = LSM6DSO_XL_NC_TAG;
   3baf8:	2302      	movs	r3, #2
      break;
    case LSM6DSO_SENSORHUB_NACK_TAG:
      *val = LSM6DSO_SENSORHUB_NACK_TAG;
      break;
    default:
      *val = LSM6DSO_GYRO_NC_TAG;
   3bafa:	7023      	strb	r3, [r4, #0]
      break;
  }
  return ret;
}
   3bafc:	b002      	add	sp, #8
   3bafe:	bd10      	pop	{r4, pc}
      *val = LSM6DSO_TEMPERATURE_TAG;
   3bb00:	2303      	movs	r3, #3
   3bb02:	e7fa      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_CFG_CHANGE_TAG;
   3bb04:	2305      	movs	r3, #5
   3bb06:	e7f8      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_XL_NC_T_2_TAG;
   3bb08:	2306      	movs	r3, #6
   3bb0a:	e7f6      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_XL_NC_T_1_TAG;
   3bb0c:	2307      	movs	r3, #7
   3bb0e:	e7f4      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_XL_2XC_TAG;
   3bb10:	2308      	movs	r3, #8
   3bb12:	e7f2      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_XL_3XC_TAG;
   3bb14:	2309      	movs	r3, #9
   3bb16:	e7f0      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_GYRO_NC_T_2_TAG;
   3bb18:	230a      	movs	r3, #10
   3bb1a:	e7ee      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_GYRO_NC_T_1_TAG;
   3bb1c:	230b      	movs	r3, #11
   3bb1e:	e7ec      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_GYRO_2XC_TAG;
   3bb20:	230c      	movs	r3, #12
   3bb22:	e7ea      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_GYRO_3XC_TAG;
   3bb24:	230d      	movs	r3, #13
   3bb26:	e7e8      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_SENSORHUB_SLAVE0_TAG;
   3bb28:	230e      	movs	r3, #14
   3bb2a:	e7e6      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_SENSORHUB_SLAVE1_TAG;
   3bb2c:	230f      	movs	r3, #15
   3bb2e:	e7e4      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_SENSORHUB_SLAVE2_TAG;
   3bb30:	2310      	movs	r3, #16
   3bb32:	e7e2      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_SENSORHUB_SLAVE3_TAG;
   3bb34:	2311      	movs	r3, #17
   3bb36:	e7e0      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_STEP_CPUNTER_TAG;
   3bb38:	2312      	movs	r3, #18
   3bb3a:	e7de      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_GAME_ROTATION_TAG;
   3bb3c:	2313      	movs	r3, #19
   3bb3e:	e7dc      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_GEOMAG_ROTATION_TAG;
   3bb40:	2314      	movs	r3, #20
   3bb42:	e7da      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_ROTATION_TAG;
   3bb44:	2315      	movs	r3, #21
   3bb46:	e7d8      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_SENSORHUB_NACK_TAG;
   3bb48:	2319      	movs	r3, #25
   3bb4a:	e7d6      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_GYRO_NC_TAG;
   3bb4c:	2301      	movs	r3, #1
   3bb4e:	e7d4      	b.n	3bafa <lsm6dso_fifo_sensor_tag_get+0x3a>

0003bb50 <lsm6dso_pedo_sens_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      turn on and configure pedometer
  *
  */
int32_t lsm6dso_pedo_sens_set(stmdev_ctx_t *ctx, lsm6dso_pedo_md_t val)
{
   3bb50:	b530      	push	{r4, r5, lr}
   3bb52:	b085      	sub	sp, #20
   3bb54:	460d      	mov	r5, r1
  lsm6dso_emb_func_en_a_t emb_func_en_a;
  lsm6dso_emb_func_en_b_t emb_func_en_b;
  lsm6dso_pedo_cmd_reg_t pedo_cmd_reg;
  int32_t ret;

  ret = lsm6dso_ln_pg_read_byte(ctx, LSM6DSO_PEDO_CMD_REG,
   3bb56:	aa03      	add	r2, sp, #12
   3bb58:	f240 1183 	movw	r1, #387	; 0x183
{
   3bb5c:	4604      	mov	r4, r0
  ret = lsm6dso_ln_pg_read_byte(ctx, LSM6DSO_PEDO_CMD_REG,
   3bb5e:	f7ff fafc 	bl	3b15a <lsm6dso_ln_pg_read_byte>
                                (uint8_t*)&pedo_cmd_reg);
  if (ret == 0) {
   3bb62:	2800      	cmp	r0, #0
   3bb64:	d143      	bne.n	3bbee <lsm6dso_pedo_sens_set+0x9e>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3bb66:	2102      	movs	r1, #2
   3bb68:	4620      	mov	r0, r4
   3bb6a:	f7ff f96d 	bl	3ae48 <lsm6dso_mem_bank_set>
  }
  if (ret == 0) {
   3bb6e:	2800      	cmp	r0, #0
   3bb70:	d13d      	bne.n	3bbee <lsm6dso_pedo_sens_set+0x9e>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_EN_A,
   3bb72:	2301      	movs	r3, #1
   3bb74:	aa01      	add	r2, sp, #4
   3bb76:	2104      	movs	r1, #4
   3bb78:	4620      	mov	r0, r4
   3bb7a:	f7ff f8b7 	bl	3acec <lsm6dso_read_reg>
                           (uint8_t*)&emb_func_en_a, 1);
  }
  if (ret == 0) {
   3bb7e:	bbb0      	cbnz	r0, 3bbee <lsm6dso_pedo_sens_set+0x9e>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_EN_B,
   3bb80:	2301      	movs	r3, #1
   3bb82:	aa02      	add	r2, sp, #8
   3bb84:	2105      	movs	r1, #5
   3bb86:	4620      	mov	r0, r4
   3bb88:	f7ff f8b0 	bl	3acec <lsm6dso_read_reg>
                           (uint8_t*)&emb_func_en_b, 1);

    emb_func_en_a.pedo_en = (uint8_t)val & 0x01U;
   3bb8c:	f89d 3004 	ldrb.w	r3, [sp, #4]
    emb_func_en_b.pedo_adv_en = ((uint8_t)val & 0x02U)>>1;
   3bb90:	086a      	lsrs	r2, r5, #1
    emb_func_en_a.pedo_en = (uint8_t)val & 0x01U;
   3bb92:	f365 03c3 	bfi	r3, r5, #3, #1
   3bb96:	f88d 3004 	strb.w	r3, [sp, #4]
    emb_func_en_b.pedo_adv_en = ((uint8_t)val & 0x02U)>>1;
   3bb9a:	f89d 3008 	ldrb.w	r3, [sp, #8]
   3bb9e:	f362 1304 	bfi	r3, r2, #4, #1
   3bba2:	f88d 3008 	strb.w	r3, [sp, #8]
    pedo_cmd_reg.fp_rejection_en = ((uint8_t)val & 0x10U)>>4;
   3bba6:	f89d 300c 	ldrb.w	r3, [sp, #12]
   3bbaa:	092a      	lsrs	r2, r5, #4
   3bbac:	f362 0382 	bfi	r3, r2, #2, #1
    pedo_cmd_reg.ad_det_en = ((uint8_t)val & 0x20U)>>5;
   3bbb0:	096d      	lsrs	r5, r5, #5
   3bbb2:	f365 0300 	bfi	r3, r5, #0, #1
   3bbb6:	f88d 300c 	strb.w	r3, [sp, #12]
  }
  if (ret == 0) {
   3bbba:	b9c0      	cbnz	r0, 3bbee <lsm6dso_pedo_sens_set+0x9e>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_EN_A,
   3bbbc:	2301      	movs	r3, #1
   3bbbe:	aa01      	add	r2, sp, #4
   3bbc0:	2104      	movs	r1, #4
   3bbc2:	4620      	mov	r0, r4
   3bbc4:	f7ff f899 	bl	3acfa <lsm6dso_write_reg>
                            (uint8_t*)&emb_func_en_a, 1);
  }
  if (ret == 0) {
   3bbc8:	b988      	cbnz	r0, 3bbee <lsm6dso_pedo_sens_set+0x9e>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_EN_B,
   3bbca:	2301      	movs	r3, #1
   3bbcc:	aa02      	add	r2, sp, #8
   3bbce:	2105      	movs	r1, #5
   3bbd0:	4620      	mov	r0, r4
   3bbd2:	f7ff f892 	bl	3acfa <lsm6dso_write_reg>
                            (uint8_t*)&emb_func_en_b, 1);
  }
  if (ret == 0) {
   3bbd6:	b950      	cbnz	r0, 3bbee <lsm6dso_pedo_sens_set+0x9e>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3bbd8:	4601      	mov	r1, r0
   3bbda:	4620      	mov	r0, r4
   3bbdc:	f7ff f934 	bl	3ae48 <lsm6dso_mem_bank_set>
  }
  if (ret == 0) {
   3bbe0:	b928      	cbnz	r0, 3bbee <lsm6dso_pedo_sens_set+0x9e>
    ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_PEDO_CMD_REG,
   3bbe2:	aa03      	add	r2, sp, #12
   3bbe4:	f240 1183 	movw	r1, #387	; 0x183
   3bbe8:	4620      	mov	r0, r4
   3bbea:	f7ff f9bf 	bl	3af6c <lsm6dso_ln_pg_write_byte>
                                   (uint8_t*)&pedo_cmd_reg);
  }
  return ret;
}
   3bbee:	b005      	add	sp, #20
   3bbf0:	bd30      	pop	{r4, r5, pc}

0003bbf2 <lsm6dso_pedo_debounce_steps_set>:
  *
  */
int32_t lsm6dso_pedo_debounce_steps_set(stmdev_ctx_t *ctx, uint8_t *buff)
{
  int32_t ret;
  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_PEDO_DEB_STEPS_CONF, buff);
   3bbf2:	460a      	mov	r2, r1
   3bbf4:	f44f 71c2 	mov.w	r1, #388	; 0x184
   3bbf8:	f7ff b9b8 	b.w	3af6c <lsm6dso_ln_pg_write_byte>

0003bbfc <lsm6dso_pedo_steps_period_set>:
  * @param  ctx      read / write interface definitions
  * @param  buff     buffer that contains data to write
  *
  */
int32_t lsm6dso_pedo_steps_period_set(stmdev_ctx_t *ctx, uint8_t *buff)
{
   3bbfc:	b538      	push	{r3, r4, r5, lr}
  int32_t ret;
  uint8_t index;

  index = 0x00U;
  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_PEDO_SC_DELTAT_L, &buff[index]);
   3bbfe:	460a      	mov	r2, r1
{
   3bc00:	460c      	mov	r4, r1
  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_PEDO_SC_DELTAT_L, &buff[index]);
   3bc02:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
{
   3bc06:	4605      	mov	r5, r0
  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_PEDO_SC_DELTAT_L, &buff[index]);
   3bc08:	f7ff f9b0 	bl	3af6c <lsm6dso_ln_pg_write_byte>
  if (ret == 0) {
   3bc0c:	b938      	cbnz	r0, 3bc1e <lsm6dso_pedo_steps_period_set+0x22>
    index++;
    ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_PEDO_SC_DELTAT_H,
   3bc0e:	1c62      	adds	r2, r4, #1
   3bc10:	4628      	mov	r0, r5
                                   &buff[index]);
  }
  return ret;
}
   3bc12:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_PEDO_SC_DELTAT_H,
   3bc16:	f240 11d1 	movw	r1, #465	; 0x1d1
   3bc1a:	f7ff b9a7 	b.w	3af6c <lsm6dso_ln_pg_write_byte>
}
   3bc1e:	bd38      	pop	{r3, r4, r5, pc}

0003bc20 <lsm6dso_fsm_enable_set>:
  * @param  val      union of registers from FSM_ENABLE_A to FSM_ENABLE_B
  *
  */
int32_t lsm6dso_fsm_enable_set(stmdev_ctx_t *ctx,
                               lsm6dso_emb_fsm_enable_t *val)
{
   3bc20:	b537      	push	{r0, r1, r2, r4, r5, lr}
   3bc22:	460d      	mov	r5, r1
  int32_t ret;
  lsm6dso_emb_func_en_b_t reg;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3bc24:	2102      	movs	r1, #2
{
   3bc26:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3bc28:	f7ff f90e 	bl	3ae48 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   3bc2c:	2800      	cmp	r0, #0
   3bc2e:	d157      	bne.n	3bce0 <lsm6dso_fsm_enable_set+0xc0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FSM_ENABLE_A,
   3bc30:	2301      	movs	r3, #1
   3bc32:	462a      	mov	r2, r5
   3bc34:	2146      	movs	r1, #70	; 0x46
   3bc36:	4620      	mov	r0, r4
   3bc38:	f7ff f85f 	bl	3acfa <lsm6dso_write_reg>
                            (uint8_t*)&val->fsm_enable_a, 1);
  }
  if (ret == 0) {
   3bc3c:	2800      	cmp	r0, #0
   3bc3e:	d14f      	bne.n	3bce0 <lsm6dso_fsm_enable_set+0xc0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FSM_ENABLE_B,
   3bc40:	2301      	movs	r3, #1
   3bc42:	2147      	movs	r1, #71	; 0x47
   3bc44:	18ea      	adds	r2, r5, r3
   3bc46:	4620      	mov	r0, r4
   3bc48:	f7ff f857 	bl	3acfa <lsm6dso_write_reg>
                            (uint8_t*)&val->fsm_enable_b, 1);
  }
  if (ret == 0) {
   3bc4c:	2800      	cmp	r0, #0
   3bc4e:	d147      	bne.n	3bce0 <lsm6dso_fsm_enable_set+0xc0>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_EN_B, (uint8_t*)&reg, 1);
   3bc50:	2301      	movs	r3, #1
   3bc52:	aa01      	add	r2, sp, #4
   3bc54:	2105      	movs	r1, #5
   3bc56:	4620      	mov	r0, r4
   3bc58:	f7ff f848 	bl	3acec <lsm6dso_read_reg>
  }
  if (ret == 0) {
   3bc5c:	2800      	cmp	r0, #0
   3bc5e:	d13f      	bne.n	3bce0 <lsm6dso_fsm_enable_set+0xc0>
    if ( (val->fsm_enable_a.fsm1_en   |
   3bc60:	782a      	ldrb	r2, [r5, #0]
    else
    {
      reg.fsm_en = PROPERTY_DISABLE;
    }

    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_EN_B, (uint8_t*)&reg, 1);
   3bc62:	4620      	mov	r0, r4
          val->fsm_enable_a.fsm2_en   |
   3bc64:	f3c2 0140 	ubfx	r1, r2, #1, #1
    if ( (val->fsm_enable_a.fsm1_en   |
   3bc68:	f3c2 0300 	ubfx	r3, r2, #0, #1
   3bc6c:	430b      	orrs	r3, r1
          val->fsm_enable_a.fsm3_en   |
   3bc6e:	f3c2 0180 	ubfx	r1, r2, #2, #1
          val->fsm_enable_a.fsm2_en   |
   3bc72:	430b      	orrs	r3, r1
          val->fsm_enable_a.fsm4_en   |
   3bc74:	f3c2 01c0 	ubfx	r1, r2, #3, #1
          val->fsm_enable_a.fsm3_en   |
   3bc78:	430b      	orrs	r3, r1
          val->fsm_enable_a.fsm5_en   |
   3bc7a:	f3c2 1100 	ubfx	r1, r2, #4, #1
          val->fsm_enable_a.fsm4_en   |
   3bc7e:	430b      	orrs	r3, r1
          val->fsm_enable_a.fsm6_en   |
   3bc80:	f3c2 1140 	ubfx	r1, r2, #5, #1
          val->fsm_enable_a.fsm5_en   |
   3bc84:	430b      	orrs	r3, r1
          val->fsm_enable_a.fsm7_en   |
   3bc86:	f3c2 1180 	ubfx	r1, r2, #6, #1
          val->fsm_enable_a.fsm6_en   |
   3bc8a:	430b      	orrs	r3, r1
          val->fsm_enable_a.fsm7_en   |
   3bc8c:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
          val->fsm_enable_b.fsm9_en   |
   3bc90:	786a      	ldrb	r2, [r5, #1]
   3bc92:	f3c2 0100 	ubfx	r1, r2, #0, #1
          val->fsm_enable_a.fsm8_en   |
   3bc96:	430b      	orrs	r3, r1
          val->fsm_enable_b.fsm10_en  |
   3bc98:	f3c2 0140 	ubfx	r1, r2, #1, #1
          val->fsm_enable_b.fsm9_en   |
   3bc9c:	430b      	orrs	r3, r1
          val->fsm_enable_b.fsm11_en  |
   3bc9e:	f3c2 0180 	ubfx	r1, r2, #2, #1
          val->fsm_enable_b.fsm10_en  |
   3bca2:	430b      	orrs	r3, r1
          val->fsm_enable_b.fsm12_en  |
   3bca4:	f3c2 01c0 	ubfx	r1, r2, #3, #1
          val->fsm_enable_b.fsm11_en  |
   3bca8:	430b      	orrs	r3, r1
          val->fsm_enable_b.fsm13_en  |
   3bcaa:	f3c2 1100 	ubfx	r1, r2, #4, #1
          val->fsm_enable_b.fsm12_en  |
   3bcae:	430b      	orrs	r3, r1
          val->fsm_enable_b.fsm14_en  |
   3bcb0:	f3c2 1140 	ubfx	r1, r2, #5, #1
          val->fsm_enable_b.fsm13_en  |
   3bcb4:	430b      	orrs	r3, r1
          val->fsm_enable_b.fsm15_en  |
   3bcb6:	f3c2 1180 	ubfx	r1, r2, #6, #1
          val->fsm_enable_b.fsm14_en  |
   3bcba:	430b      	orrs	r3, r1
          val->fsm_enable_b.fsm15_en  |
   3bcbc:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
   3bcc0:	f89d 2004 	ldrb.w	r2, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_EN_B, (uint8_t*)&reg, 1);
   3bcc4:	2105      	movs	r1, #5
   3bcc6:	f363 0200 	bfi	r2, r3, #0, #1
   3bcca:	f88d 2004 	strb.w	r2, [sp, #4]
   3bcce:	2301      	movs	r3, #1
   3bcd0:	aa01      	add	r2, sp, #4
   3bcd2:	f7ff f812 	bl	3acfa <lsm6dso_write_reg>
  }
  if (ret == 0) {
   3bcd6:	b918      	cbnz	r0, 3bce0 <lsm6dso_fsm_enable_set+0xc0>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3bcd8:	4601      	mov	r1, r0
   3bcda:	4620      	mov	r0, r4
   3bcdc:	f7ff f8b4 	bl	3ae48 <lsm6dso_mem_bank_set>
  }

  return ret;
}
   3bce0:	b003      	add	sp, #12
   3bce2:	bd30      	pop	{r4, r5, pc}

0003bce4 <lsm6dso_fsm_enable_get>:
  * @param  val      union of registers from FSM_ENABLE_A to FSM_ENABLE_B
  *
  */
int32_t lsm6dso_fsm_enable_get(stmdev_ctx_t *ctx,
                               lsm6dso_emb_fsm_enable_t *val)
{
   3bce4:	b538      	push	{r3, r4, r5, lr}
   3bce6:	460d      	mov	r5, r1
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3bce8:	2102      	movs	r1, #2
{
   3bcea:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3bcec:	f7ff f8ac 	bl	3ae48 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   3bcf0:	b960      	cbnz	r0, 3bd0c <lsm6dso_fsm_enable_get+0x28>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FSM_ENABLE_A, (uint8_t*) val, 2);
   3bcf2:	2302      	movs	r3, #2
   3bcf4:	462a      	mov	r2, r5
   3bcf6:	2146      	movs	r1, #70	; 0x46
   3bcf8:	4620      	mov	r0, r4
   3bcfa:	f7fe fff7 	bl	3acec <lsm6dso_read_reg>
  }
  if (ret == 0) {
   3bcfe:	b928      	cbnz	r0, 3bd0c <lsm6dso_fsm_enable_get+0x28>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3bd00:	4601      	mov	r1, r0
   3bd02:	4620      	mov	r0, r4
  }
  return ret;
}
   3bd04:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3bd08:	f7ff b89e 	b.w	3ae48 <lsm6dso_mem_bank_set>
}
   3bd0c:	bd38      	pop	{r3, r4, r5, pc}

0003bd0e <lsm6dso_fsm_data_rate_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of fsm_odr in reg EMB_FUNC_ODR_CFG_B
  *
  */
int32_t lsm6dso_fsm_data_rate_set(stmdev_ctx_t *ctx, lsm6dso_fsm_odr_t val)
{
   3bd0e:	b537      	push	{r0, r1, r2, r4, r5, lr}
   3bd10:	460d      	mov	r5, r1
  lsm6dso_emb_func_odr_cfg_b_t reg;
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3bd12:	2102      	movs	r1, #2
{
   3bd14:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3bd16:	f7ff f897 	bl	3ae48 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   3bd1a:	b9d8      	cbnz	r0, 3bd54 <lsm6dso_fsm_data_rate_set+0x46>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_ODR_CFG_B,
   3bd1c:	2301      	movs	r3, #1
   3bd1e:	aa01      	add	r2, sp, #4
   3bd20:	215f      	movs	r1, #95	; 0x5f
   3bd22:	4620      	mov	r0, r4
   3bd24:	f7fe ffe2 	bl	3acec <lsm6dso_read_reg>
                           (uint8_t*)&reg, 1);
  }
  if (ret == 0) {
   3bd28:	b9a0      	cbnz	r0, 3bd54 <lsm6dso_fsm_data_rate_set+0x46>
    reg.not_used_01 = 3; /* set default values */
   3bd2a:	f89d 3004 	ldrb.w	r3, [sp, #4]
    reg.not_used_02 = 2; /* set default values */
    reg.fsm_odr = (uint8_t)val;
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_ODR_CFG_B,
   3bd2e:	aa01      	add	r2, sp, #4
    reg.not_used_01 = 3; /* set default values */
   3bd30:	f003 0318 	and.w	r3, r3, #24
    reg.fsm_odr = (uint8_t)val;
   3bd34:	f043 0343 	orr.w	r3, r3, #67	; 0x43
   3bd38:	f365 03c4 	bfi	r3, r5, #3, #2
   3bd3c:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_ODR_CFG_B,
   3bd40:	215f      	movs	r1, #95	; 0x5f
   3bd42:	2301      	movs	r3, #1
   3bd44:	4620      	mov	r0, r4
   3bd46:	f7fe ffd8 	bl	3acfa <lsm6dso_write_reg>
                            (uint8_t*)&reg, 1);
  }
  if (ret == 0) {
   3bd4a:	b918      	cbnz	r0, 3bd54 <lsm6dso_fsm_data_rate_set+0x46>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3bd4c:	4601      	mov	r1, r0
   3bd4e:	4620      	mov	r0, r4
   3bd50:	f7ff f87a 	bl	3ae48 <lsm6dso_mem_bank_set>
  }
  return ret;
}
   3bd54:	b003      	add	sp, #12
   3bd56:	bd30      	pop	{r4, r5, pc}

0003bd58 <lsm6dso_fsm_data_rate_get>:
  * @param  ctx      read / write interface definitions
  * @param  val      Get the values of fsm_odr in reg EMB_FUNC_ODR_CFG_B
  *
  */
int32_t lsm6dso_fsm_data_rate_get(stmdev_ctx_t *ctx, lsm6dso_fsm_odr_t *val)
{
   3bd58:	b537      	push	{r0, r1, r2, r4, r5, lr}
   3bd5a:	460c      	mov	r4, r1
  lsm6dso_emb_func_odr_cfg_b_t reg;
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3bd5c:	2102      	movs	r1, #2
{
   3bd5e:	4605      	mov	r5, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   3bd60:	f7ff f872 	bl	3ae48 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   3bd64:	b9b8      	cbnz	r0, 3bd96 <lsm6dso_fsm_data_rate_get+0x3e>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_ODR_CFG_B,
   3bd66:	2301      	movs	r3, #1
   3bd68:	aa01      	add	r2, sp, #4
   3bd6a:	215f      	movs	r1, #95	; 0x5f
   3bd6c:	4628      	mov	r0, r5
   3bd6e:	f7fe ffbd 	bl	3acec <lsm6dso_read_reg>
                           (uint8_t*)&reg, 1);
  }
  if (ret == 0) {
   3bd72:	b980      	cbnz	r0, 3bd96 <lsm6dso_fsm_data_rate_get+0x3e>
    switch (reg.fsm_odr) {
   3bd74:	f89d 3004 	ldrb.w	r3, [sp, #4]
   3bd78:	f3c3 03c1 	ubfx	r3, r3, #3, #2
   3bd7c:	3b01      	subs	r3, #1
   3bd7e:	2b02      	cmp	r3, #2
   3bd80:	d803      	bhi.n	3bd8a <lsm6dso_fsm_data_rate_get+0x32>
   3bd82:	e8df f003 	tbb	[pc, r3]
   3bd86:	0c0a      	.short	0x0c0a
   3bd88:	0e          	.byte	0x0e
   3bd89:	00          	.byte	0x00
      case LSM6DSO_ODR_FSM_12Hz5:
        *val = LSM6DSO_ODR_FSM_12Hz5;
   3bd8a:	2300      	movs	r3, #0
        break;
      case LSM6DSO_ODR_FSM_52Hz:
        *val = LSM6DSO_ODR_FSM_52Hz;
        break;
      case LSM6DSO_ODR_FSM_104Hz:
        *val = LSM6DSO_ODR_FSM_104Hz;
   3bd8c:	7023      	strb	r3, [r4, #0]
        break;
      default:
        *val = LSM6DSO_ODR_FSM_12Hz5;
        break;
    }
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   3bd8e:	2100      	movs	r1, #0
   3bd90:	4628      	mov	r0, r5
   3bd92:	f7ff f859 	bl	3ae48 <lsm6dso_mem_bank_set>
  }

  return ret;
}
   3bd96:	b003      	add	sp, #12
   3bd98:	bd30      	pop	{r4, r5, pc}
        *val = LSM6DSO_ODR_FSM_26Hz;
   3bd9a:	2301      	movs	r3, #1
   3bd9c:	e7f6      	b.n	3bd8c <lsm6dso_fsm_data_rate_get+0x34>
        *val = LSM6DSO_ODR_FSM_52Hz;
   3bd9e:	2302      	movs	r3, #2
   3bda0:	e7f4      	b.n	3bd8c <lsm6dso_fsm_data_rate_get+0x34>
        *val = LSM6DSO_ODR_FSM_104Hz;
   3bda2:	2303      	movs	r3, #3
   3bda4:	e7f2      	b.n	3bd8c <lsm6dso_fsm_data_rate_get+0x34>

0003bda6 <lsm6dso_xl_data_rate_set>:
{
   3bda6:	b537      	push	{r0, r1, r2, r4, r5, lr}
   3bda8:	460c      	mov	r4, r1
  ret =  lsm6dso_fsm_enable_get(ctx, &fsm_enable);
   3bdaa:	a901      	add	r1, sp, #4
{
   3bdac:	4605      	mov	r5, r0
  ret =  lsm6dso_fsm_enable_get(ctx, &fsm_enable);
   3bdae:	f7ff ff99 	bl	3bce4 <lsm6dso_fsm_enable_get>
  if (ret == 0) {
   3bdb2:	2800      	cmp	r0, #0
   3bdb4:	d156      	bne.n	3be64 <lsm6dso_xl_data_rate_set+0xbe>
    if ( (fsm_enable.fsm_enable_a.fsm1_en  |
   3bdb6:	f89d 2004 	ldrb.w	r2, [sp, #4]
          fsm_enable.fsm_enable_a.fsm2_en  |
   3bdba:	f3c2 0140 	ubfx	r1, r2, #1, #1
    if ( (fsm_enable.fsm_enable_a.fsm1_en  |
   3bdbe:	f3c2 0300 	ubfx	r3, r2, #0, #1
   3bdc2:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm3_en  |
   3bdc4:	f3c2 0180 	ubfx	r1, r2, #2, #1
          fsm_enable.fsm_enable_a.fsm2_en  |
   3bdc8:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm4_en  |
   3bdca:	f3c2 01c0 	ubfx	r1, r2, #3, #1
          fsm_enable.fsm_enable_a.fsm3_en  |
   3bdce:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm5_en  |
   3bdd0:	f3c2 1100 	ubfx	r1, r2, #4, #1
          fsm_enable.fsm_enable_a.fsm4_en  |
   3bdd4:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm6_en  |
   3bdd6:	f3c2 1140 	ubfx	r1, r2, #5, #1
          fsm_enable.fsm_enable_a.fsm5_en  |
   3bdda:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm7_en  |
   3bddc:	f3c2 1180 	ubfx	r1, r2, #6, #1
          fsm_enable.fsm_enable_a.fsm6_en  |
   3bde0:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm7_en  |
   3bde2:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
          fsm_enable.fsm_enable_b.fsm9_en  |
   3bde6:	f89d 2005 	ldrb.w	r2, [sp, #5]
   3bdea:	f3c2 0100 	ubfx	r1, r2, #0, #1
          fsm_enable.fsm_enable_a.fsm8_en  |
   3bdee:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm10_en |
   3bdf0:	f3c2 0140 	ubfx	r1, r2, #1, #1
          fsm_enable.fsm_enable_b.fsm9_en  |
   3bdf4:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm11_en |
   3bdf6:	f3c2 0180 	ubfx	r1, r2, #2, #1
          fsm_enable.fsm_enable_b.fsm10_en |
   3bdfa:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm12_en |
   3bdfc:	f3c2 01c0 	ubfx	r1, r2, #3, #1
          fsm_enable.fsm_enable_b.fsm11_en |
   3be00:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm13_en |
   3be02:	f3c2 1100 	ubfx	r1, r2, #4, #1
          fsm_enable.fsm_enable_b.fsm12_en |
   3be06:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm14_en |
   3be08:	f3c2 1140 	ubfx	r1, r2, #5, #1
          fsm_enable.fsm_enable_b.fsm13_en |
   3be0c:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm15_en |
   3be0e:	f3c2 1180 	ubfx	r1, r2, #6, #1
          fsm_enable.fsm_enable_b.fsm14_en |
   3be12:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm15_en |
   3be14:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
    if ( (fsm_enable.fsm_enable_a.fsm1_en  |
   3be18:	07db      	lsls	r3, r3, #31
   3be1a:	d510      	bpl.n	3be3e <lsm6dso_xl_data_rate_set+0x98>
      ret =  lsm6dso_fsm_data_rate_get(ctx, &fsm_odr);
   3be1c:	f10d 0103 	add.w	r1, sp, #3
   3be20:	4628      	mov	r0, r5
   3be22:	f7ff ff99 	bl	3bd58 <lsm6dso_fsm_data_rate_get>
      if (ret == 0) {
   3be26:	b9e8      	cbnz	r0, 3be64 <lsm6dso_xl_data_rate_set+0xbe>
        switch (fsm_odr) {
   3be28:	f89d 3003 	ldrb.w	r3, [sp, #3]
   3be2c:	2b03      	cmp	r3, #3
   3be2e:	d806      	bhi.n	3be3e <lsm6dso_xl_data_rate_set+0x98>
   3be30:	e8df f003 	tbb	[pc, r3]
   3be34:	221e1a02 	.word	0x221e1a02
            if (val == LSM6DSO_XL_ODR_OFF){
   3be38:	2c00      	cmp	r4, #0
              odr_xl = LSM6DSO_XL_ODR_12Hz5;
   3be3a:	bf08      	it	eq
   3be3c:	2401      	moveq	r4, #1
    ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   3be3e:	2301      	movs	r3, #1
   3be40:	466a      	mov	r2, sp
   3be42:	2110      	movs	r1, #16
   3be44:	4628      	mov	r0, r5
   3be46:	f7fe ff51 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3be4a:	b958      	cbnz	r0, 3be64 <lsm6dso_xl_data_rate_set+0xbe>
    reg.odr_xl = (uint8_t) odr_xl;
   3be4c:	f89d 3000 	ldrb.w	r3, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   3be50:	466a      	mov	r2, sp
    reg.odr_xl = (uint8_t) odr_xl;
   3be52:	f364 1307 	bfi	r3, r4, #4, #4
   3be56:	f88d 3000 	strb.w	r3, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   3be5a:	2110      	movs	r1, #16
   3be5c:	2301      	movs	r3, #1
   3be5e:	4628      	mov	r0, r5
   3be60:	f7fe ff4b 	bl	3acfa <lsm6dso_write_reg>
}
   3be64:	b003      	add	sp, #12
   3be66:	bd30      	pop	{r4, r5, pc}
            if (val == LSM6DSO_XL_ODR_OFF){
   3be68:	2c02      	cmp	r4, #2
   3be6a:	bf38      	it	cc
   3be6c:	2402      	movcc	r4, #2
   3be6e:	e7e6      	b.n	3be3e <lsm6dso_xl_data_rate_set+0x98>
            if (val == LSM6DSO_XL_ODR_OFF){
   3be70:	2c03      	cmp	r4, #3
   3be72:	bf38      	it	cc
   3be74:	2403      	movcc	r4, #3
   3be76:	e7e2      	b.n	3be3e <lsm6dso_xl_data_rate_set+0x98>
            if (val == LSM6DSO_XL_ODR_OFF){
   3be78:	2c04      	cmp	r4, #4
   3be7a:	bf38      	it	cc
   3be7c:	2404      	movcc	r4, #4
   3be7e:	e7de      	b.n	3be3e <lsm6dso_xl_data_rate_set+0x98>

0003be80 <lsm6dso_gy_data_rate_set>:
{
   3be80:	b537      	push	{r0, r1, r2, r4, r5, lr}
   3be82:	460c      	mov	r4, r1
  ret =  lsm6dso_fsm_enable_get(ctx, &fsm_enable);
   3be84:	a901      	add	r1, sp, #4
{
   3be86:	4605      	mov	r5, r0
  ret =  lsm6dso_fsm_enable_get(ctx, &fsm_enable);
   3be88:	f7ff ff2c 	bl	3bce4 <lsm6dso_fsm_enable_get>
  if (ret == 0) {
   3be8c:	2800      	cmp	r0, #0
   3be8e:	d156      	bne.n	3bf3e <lsm6dso_gy_data_rate_set+0xbe>
    if ( (fsm_enable.fsm_enable_a.fsm1_en  |
   3be90:	f89d 2004 	ldrb.w	r2, [sp, #4]
          fsm_enable.fsm_enable_a.fsm2_en  |
   3be94:	f3c2 0140 	ubfx	r1, r2, #1, #1
    if ( (fsm_enable.fsm_enable_a.fsm1_en  |
   3be98:	f3c2 0300 	ubfx	r3, r2, #0, #1
   3be9c:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm3_en  |
   3be9e:	f3c2 0180 	ubfx	r1, r2, #2, #1
          fsm_enable.fsm_enable_a.fsm2_en  |
   3bea2:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm4_en  |
   3bea4:	f3c2 01c0 	ubfx	r1, r2, #3, #1
          fsm_enable.fsm_enable_a.fsm3_en  |
   3bea8:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm5_en  |
   3beaa:	f3c2 1100 	ubfx	r1, r2, #4, #1
          fsm_enable.fsm_enable_a.fsm4_en  |
   3beae:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm6_en  |
   3beb0:	f3c2 1140 	ubfx	r1, r2, #5, #1
          fsm_enable.fsm_enable_a.fsm5_en  |
   3beb4:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm7_en  |
   3beb6:	f3c2 1180 	ubfx	r1, r2, #6, #1
          fsm_enable.fsm_enable_a.fsm6_en  |
   3beba:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm7_en  |
   3bebc:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
          fsm_enable.fsm_enable_b.fsm9_en  |
   3bec0:	f89d 2005 	ldrb.w	r2, [sp, #5]
   3bec4:	f3c2 0100 	ubfx	r1, r2, #0, #1
          fsm_enable.fsm_enable_a.fsm8_en  |
   3bec8:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm10_en |
   3beca:	f3c2 0140 	ubfx	r1, r2, #1, #1
          fsm_enable.fsm_enable_b.fsm9_en  |
   3bece:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm11_en |
   3bed0:	f3c2 0180 	ubfx	r1, r2, #2, #1
          fsm_enable.fsm_enable_b.fsm10_en |
   3bed4:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm12_en |
   3bed6:	f3c2 01c0 	ubfx	r1, r2, #3, #1
          fsm_enable.fsm_enable_b.fsm11_en |
   3beda:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm13_en |
   3bedc:	f3c2 1100 	ubfx	r1, r2, #4, #1
          fsm_enable.fsm_enable_b.fsm12_en |
   3bee0:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm14_en |
   3bee2:	f3c2 1140 	ubfx	r1, r2, #5, #1
          fsm_enable.fsm_enable_b.fsm13_en |
   3bee6:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm15_en |
   3bee8:	f3c2 1180 	ubfx	r1, r2, #6, #1
          fsm_enable.fsm_enable_b.fsm14_en |
   3beec:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm15_en |
   3beee:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
    if ( (fsm_enable.fsm_enable_a.fsm1_en  |
   3bef2:	07db      	lsls	r3, r3, #31
   3bef4:	d510      	bpl.n	3bf18 <lsm6dso_gy_data_rate_set+0x98>
      ret =  lsm6dso_fsm_data_rate_get(ctx, &fsm_odr);
   3bef6:	f10d 0103 	add.w	r1, sp, #3
   3befa:	4628      	mov	r0, r5
   3befc:	f7ff ff2c 	bl	3bd58 <lsm6dso_fsm_data_rate_get>
      if (ret == 0) {
   3bf00:	b9e8      	cbnz	r0, 3bf3e <lsm6dso_gy_data_rate_set+0xbe>
        switch (fsm_odr) {
   3bf02:	f89d 3003 	ldrb.w	r3, [sp, #3]
   3bf06:	2b03      	cmp	r3, #3
   3bf08:	d806      	bhi.n	3bf18 <lsm6dso_gy_data_rate_set+0x98>
   3bf0a:	e8df f003 	tbb	[pc, r3]
   3bf0e:	1a02      	.short	0x1a02
   3bf10:	221e      	.short	0x221e
            if (val == LSM6DSO_GY_ODR_OFF){
   3bf12:	2c00      	cmp	r4, #0
              odr_gy = LSM6DSO_GY_ODR_12Hz5;
   3bf14:	bf08      	it	eq
   3bf16:	2401      	moveq	r4, #1
    ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   3bf18:	2301      	movs	r3, #1
   3bf1a:	466a      	mov	r2, sp
   3bf1c:	2111      	movs	r1, #17
   3bf1e:	4628      	mov	r0, r5
   3bf20:	f7fe fee4 	bl	3acec <lsm6dso_read_reg>
  if (ret == 0) {
   3bf24:	b958      	cbnz	r0, 3bf3e <lsm6dso_gy_data_rate_set+0xbe>
    reg.odr_g = (uint8_t) odr_gy;
   3bf26:	f89d 3000 	ldrb.w	r3, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   3bf2a:	466a      	mov	r2, sp
    reg.odr_g = (uint8_t) odr_gy;
   3bf2c:	f364 1307 	bfi	r3, r4, #4, #4
   3bf30:	f88d 3000 	strb.w	r3, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   3bf34:	2111      	movs	r1, #17
   3bf36:	2301      	movs	r3, #1
   3bf38:	4628      	mov	r0, r5
   3bf3a:	f7fe fede 	bl	3acfa <lsm6dso_write_reg>
}
   3bf3e:	b003      	add	sp, #12
   3bf40:	bd30      	pop	{r4, r5, pc}
            if (val == LSM6DSO_GY_ODR_OFF){
   3bf42:	2c02      	cmp	r4, #2
   3bf44:	bf38      	it	cc
   3bf46:	2402      	movcc	r4, #2
   3bf48:	e7e6      	b.n	3bf18 <lsm6dso_gy_data_rate_set+0x98>
            if (val == LSM6DSO_GY_ODR_OFF){
   3bf4a:	2c03      	cmp	r4, #3
   3bf4c:	bf38      	it	cc
   3bf4e:	2403      	movcc	r4, #3
   3bf50:	e7e2      	b.n	3bf18 <lsm6dso_gy_data_rate_set+0x98>
            if (val == LSM6DSO_GY_ODR_OFF){
   3bf52:	2c04      	cmp	r4, #4
   3bf54:	bf38      	it	cc
   3bf56:	2404      	movcc	r4, #4
   3bf58:	e7de      	b.n	3bf18 <lsm6dso_gy_data_rate_set+0x98>

0003bf5a <lsm6dso_long_cnt_int_value_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      the value of long counter
  *
  */
int32_t lsm6dso_long_cnt_int_value_set(stmdev_ctx_t *ctx, uint16_t val)
{
   3bf5a:	b513      	push	{r0, r1, r4, lr}
  int32_t ret;
  uint8_t add_l;
  uint8_t add_h;

  add_h = (uint8_t)( ( val & 0xFF00U ) >> 8 );
   3bf5c:	0a0b      	lsrs	r3, r1, #8
  add_l = (uint8_t)( val & 0x00FFU );
   3bf5e:	f88d 1006 	strb.w	r1, [sp, #6]

  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_FSM_LC_TIMEOUT_L, &add_l);
   3bf62:	f10d 0206 	add.w	r2, sp, #6
   3bf66:	f44f 71bd 	mov.w	r1, #378	; 0x17a
{
   3bf6a:	4604      	mov	r4, r0
  add_h = (uint8_t)( ( val & 0xFF00U ) >> 8 );
   3bf6c:	f88d 3007 	strb.w	r3, [sp, #7]
  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_FSM_LC_TIMEOUT_L, &add_l);
   3bf70:	f7fe fffc 	bl	3af6c <lsm6dso_ln_pg_write_byte>
  if (ret == 0) {
   3bf74:	b930      	cbnz	r0, 3bf84 <lsm6dso_long_cnt_int_value_set+0x2a>
    ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_FSM_LC_TIMEOUT_H, &add_h);
   3bf76:	f10d 0207 	add.w	r2, sp, #7
   3bf7a:	f240 117b 	movw	r1, #379	; 0x17b
   3bf7e:	4620      	mov	r0, r4
   3bf80:	f7fe fff4 	bl	3af6c <lsm6dso_ln_pg_write_byte>
  }

  return ret;
}
   3bf84:	b002      	add	sp, #8
   3bf86:	bd10      	pop	{r4, pc}

0003bf88 <lsm6dso_fsm_number_of_programs_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      value to write
  *
  */
int32_t lsm6dso_fsm_number_of_programs_set(stmdev_ctx_t *ctx, uint8_t val)
{
   3bf88:	b507      	push	{r0, r1, r2, lr}
   3bf8a:	f88d 1007 	strb.w	r1, [sp, #7]
  int32_t ret;

  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_FSM_PROGRAMS, &val);
   3bf8e:	f10d 0207 	add.w	r2, sp, #7
   3bf92:	f44f 71be 	mov.w	r1, #380	; 0x17c
   3bf96:	f7fe ffe9 	bl	3af6c <lsm6dso_ln_pg_write_byte>

  return ret;
}
   3bf9a:	b003      	add	sp, #12
   3bf9c:	f85d fb04 	ldr.w	pc, [sp], #4

0003bfa0 <lsm6dso_fsm_start_address_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      the value of start address
  *
  */
int32_t lsm6dso_fsm_start_address_set(stmdev_ctx_t *ctx, uint16_t val)
{
   3bfa0:	b513      	push	{r0, r1, r4, lr}
  int32_t ret;
  uint8_t add_l;
  uint8_t add_h;

  add_h = (uint8_t)( ( val & 0xFF00U ) >> 8 );
   3bfa2:	0a0b      	lsrs	r3, r1, #8
  add_l = (uint8_t)( val & 0x00FFU );
   3bfa4:	f88d 1006 	strb.w	r1, [sp, #6]

  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_FSM_START_ADD_L, &add_l);
   3bfa8:	f10d 0206 	add.w	r2, sp, #6
   3bfac:	f44f 71bf 	mov.w	r1, #382	; 0x17e
{
   3bfb0:	4604      	mov	r4, r0
  add_h = (uint8_t)( ( val & 0xFF00U ) >> 8 );
   3bfb2:	f88d 3007 	strb.w	r3, [sp, #7]
  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_FSM_START_ADD_L, &add_l);
   3bfb6:	f7fe ffd9 	bl	3af6c <lsm6dso_ln_pg_write_byte>
  if (ret == 0) {
   3bfba:	b930      	cbnz	r0, 3bfca <lsm6dso_fsm_start_address_set+0x2a>
    ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_FSM_START_ADD_H, &add_h);
   3bfbc:	f10d 0207 	add.w	r2, sp, #7
   3bfc0:	f240 117f 	movw	r1, #383	; 0x17f
   3bfc4:	4620      	mov	r0, r4
   3bfc6:	f7fe ffd1 	bl	3af6c <lsm6dso_ln_pg_write_byte>
  }
  return ret;
}
   3bfca:	b002      	add	sp, #8
   3bfcc:	bd10      	pop	{r4, pc}

0003bfce <IdleShowDateTime>:
{
   3bfce:	b508      	push	{r3, lr}
	IdleShowSystemTime();
   3bfd0:	f7e8 fea6 	bl	24d20 <IdleShowSystemTime>
	IdleShowSystemDate();
   3bfd4:	f7e8 fe60 	bl	24c98 <IdleShowSystemDate>
}
   3bfd8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	IdleShowSystemWeek();
   3bfdc:	f7e8 bee4 	b.w	24da8 <IdleShowSystemWeek>

0003bfe0 <NotifyTimerOutCallBack>:
	ExitNotifyScreen();
   3bfe0:	f7e9 bb8a 	b.w	256f8 <ExitNotifyScreen>

0003bfe4 <gpio_add_callback>:
	if (api->manage_callback == NULL) {
   3bfe4:	6843      	ldr	r3, [r0, #4]
   3bfe6:	68db      	ldr	r3, [r3, #12]
   3bfe8:	b10b      	cbz	r3, 3bfee <gpio_add_callback+0xa>
	return api->manage_callback(port, callback, true);
   3bfea:	2201      	movs	r2, #1
   3bfec:	4718      	bx	r3
}
   3bfee:	f06f 0085 	mvn.w	r0, #133	; 0x85
   3bff2:	4770      	bx	lr

0003bff4 <gpio_pin_disable_callback>:
{
   3bff4:	460a      	mov	r2, r1
	if (api->disable_callback == NULL) {
   3bff6:	6843      	ldr	r3, [r0, #4]
   3bff8:	695b      	ldr	r3, [r3, #20]
   3bffa:	b10b      	cbz	r3, 3c000 <gpio_pin_disable_callback+0xc>
	return api->disable_callback(port, access_op, pin);
   3bffc:	2100      	movs	r1, #0
   3bffe:	4718      	bx	r3
}
   3c000:	f06f 0085 	mvn.w	r0, #133	; 0x85
   3c004:	4770      	bx	lr

0003c006 <gpio_pin_enable_callback>:
{
   3c006:	460a      	mov	r2, r1
	if (api->enable_callback == NULL) {
   3c008:	6843      	ldr	r3, [r0, #4]
   3c00a:	691b      	ldr	r3, [r3, #16]
   3c00c:	b10b      	cbz	r3, 3c012 <gpio_pin_enable_callback+0xc>
	return api->enable_callback(port, access_op, pin);
   3c00e:	2100      	movs	r1, #0
   3c010:	4718      	bx	r3
}
   3c012:	f06f 0085 	mvn.w	r0, #133	; 0x85
   3c016:	4770      	bx	lr

0003c018 <platform_write>:
{
   3c018:	b5f0      	push	{r4, r5, r6, r7, lr}
   3c01a:	b085      	sub	sp, #20
   3c01c:	4604      	mov	r4, r0
	u8_t data[len+1];
   3c01e:	4668      	mov	r0, sp
{
   3c020:	4616      	mov	r6, r2
	u8_t data[len+1];
   3c022:	f103 0208 	add.w	r2, r3, #8
   3c026:	08d2      	lsrs	r2, r2, #3
   3c028:	eba0 02c2 	sub.w	r2, r0, r2, lsl #3
{
   3c02c:	af00      	add	r7, sp, #0
	u8_t data[len+1];
   3c02e:	4695      	mov	sp, r2
	data[0] = reg;
   3c030:	4668      	mov	r0, sp
   3c032:	461a      	mov	r2, r3
   3c034:	f800 1b01 	strb.w	r1, [r0], #1
   3c038:	4631      	mov	r1, r6
	u8_t data[len+1];
   3c03a:	1c5d      	adds	r5, r3, #1
   3c03c:	f002 fc06 	bl	3e84c <memcpy>
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   3c040:	2302      	movs	r3, #2
	msg.buf = (u8_t *)buf;
   3c042:	f8c7 d004 	str.w	sp, [r7, #4]
	msg.len = num_bytes;
   3c046:	60bd      	str	r5, [r7, #8]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   3c048:	733b      	strb	r3, [r7, #12]
	return api->transfer(dev, msgs, num_msgs, addr);
   3c04a:	6863      	ldr	r3, [r4, #4]
   3c04c:	1d39      	adds	r1, r7, #4
   3c04e:	685d      	ldr	r5, [r3, #4]
   3c050:	2201      	movs	r2, #1
   3c052:	2328      	movs	r3, #40	; 0x28
   3c054:	4620      	mov	r0, r4
   3c056:	47a8      	blx	r5
}
   3c058:	3714      	adds	r7, #20
   3c05a:	46bd      	mov	sp, r7
   3c05c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0003c05e <platform_read>:
{
   3c05e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3c062:	b086      	sub	sp, #24
   3c064:	461e      	mov	r6, r3
	msg.buf = (u8_t *)buf;
   3c066:	f10d 0307 	add.w	r3, sp, #7
   3c06a:	9303      	str	r3, [sp, #12]
	msg.len = num_bytes;
   3c06c:	2501      	movs	r5, #1
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   3c06e:	2302      	movs	r3, #2
   3c070:	4604      	mov	r4, r0
   3c072:	4617      	mov	r7, r2
   3c074:	f88d 1007 	strb.w	r1, [sp, #7]
	msg.len = num_bytes;
   3c078:	9504      	str	r5, [sp, #16]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   3c07a:	f88d 3014 	strb.w	r3, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   3c07e:	6843      	ldr	r3, [r0, #4]
   3c080:	462a      	mov	r2, r5
   3c082:	f8d3 8004 	ldr.w	r8, [r3, #4]
   3c086:	a903      	add	r1, sp, #12
   3c088:	2328      	movs	r3, #40	; 0x28
   3c08a:	47c0      	blx	r8
	if(rslt == 0)
   3c08c:	b958      	cbnz	r0, 3c0a6 <platform_read+0x48>
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
   3c08e:	2303      	movs	r3, #3
		rslt = i2c_read(handle, bufp, len, MAX20353_I2C_ADDR);
   3c090:	e9cd 7603 	strd	r7, r6, [sp, #12]
   3c094:	f88d 3014 	strb.w	r3, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   3c098:	6863      	ldr	r3, [r4, #4]
   3c09a:	462a      	mov	r2, r5
   3c09c:	685e      	ldr	r6, [r3, #4]
   3c09e:	a903      	add	r1, sp, #12
   3c0a0:	2328      	movs	r3, #40	; 0x28
   3c0a2:	4620      	mov	r0, r4
   3c0a4:	47b0      	blx	r6
}
   3c0a6:	b006      	add	sp, #24
   3c0a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0003c0ac <Set_Screen_Backlight_On>:
	ret = MAX20353_LED1(2, 31, true);
   3c0ac:	2201      	movs	r2, #1
   3c0ae:	211f      	movs	r1, #31
   3c0b0:	2002      	movs	r0, #2
   3c0b2:	f000 b81d 	b.w	3c0f0 <MAX20353_LED1>

0003c0b6 <Set_Screen_Backlight_Off>:
	ret = MAX20353_LED1(2, 0, false);
   3c0b6:	2200      	movs	r2, #0
   3c0b8:	2002      	movs	r0, #2
   3c0ba:	4611      	mov	r1, r2
   3c0bc:	f000 b818 	b.w	3c0f0 <MAX20353_LED1>

0003c0c0 <SystemShutDown>:
{
   3c0c0:	b508      	push	{r3, lr}
	SaveSystemDateTime();
   3c0c2:	f7e5 fc73 	bl	219ac <SaveSystemDateTime>
}
   3c0c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	MAX20353_PowerOffConfig();
   3c0ca:	f7ea b8c3 	b.w	26254 <MAX20353_PowerOffConfig>

0003c0ce <k_sleep>:
   3c0ce:	f7fb bbf7 	b.w	378c0 <z_impl_k_sleep>

0003c0d2 <VibrateStart>:
{
   3c0d2:	b508      	push	{r3, lr}
	MAX20353_WriteReg( REG_HPT_RTI2CAMP,  0x3F);	//0x000x7f
   3c0d4:	213f      	movs	r1, #63	; 0x3f
   3c0d6:	2032      	movs	r0, #50	; 0x32
   3c0d8:	f7e9 ffa8 	bl	2602c <MAX20353_WriteReg>
}
   3c0dc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	MAX20353_WriteReg( REG_HPT_DIRECT1,  0x26); //hptExtTrig=1, HptRamEn=1, HptDrvEn=1, HptDrvMode=0x06
   3c0e0:	2126      	movs	r1, #38	; 0x26
   3c0e2:	2031      	movs	r0, #49	; 0x31
   3c0e4:	f7e9 bfa2 	b.w	2602c <MAX20353_WriteReg>

0003c0e8 <VibrateStop>:
	MAX20353_WriteReg( REG_HPT_DIRECT1,  0x00); //hptExtTrig=1, HptRamEn=1, HptDrvEn=1, HptDrvMode=0x12
   3c0e8:	2100      	movs	r1, #0
   3c0ea:	2031      	movs	r0, #49	; 0x31
   3c0ec:	f7e9 bf9e 	b.w	2602c <MAX20353_WriteReg>

0003c0f0 <MAX20353_LED1>:
{ 
   3c0f0:	b538      	push	{r3, r4, r5, lr}
   3c0f2:	4615      	mov	r5, r2
   3c0f4:	460c      	mov	r4, r1
	ret |= MAX20353_WriteReg(REG_LED_STEP_DIRECT,  IStep&0x03);
   3c0f6:	f000 0103 	and.w	r1, r0, #3
   3c0fa:	202c      	movs	r0, #44	; 0x2c
   3c0fc:	f7e9 ff96 	bl	2602c <MAX20353_WriteReg>
	if(flag)
   3c100:	b145      	cbz	r5, 3c114 <MAX20353_LED1+0x24>
		ret |= MAX20353_WriteReg(REG_LED1_DIRECT,  0x20|(Amplitude&0x1F)); 
   3c102:	f004 011f 	and.w	r1, r4, #31
   3c106:	f041 0120 	orr.w	r1, r1, #32
		ret |= MAX20353_WriteReg(REG_LED1_DIRECT,  0x00); 
   3c10a:	202e      	movs	r0, #46	; 0x2e
}
   3c10c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		ret |= MAX20353_WriteReg(REG_LED1_DIRECT,  0x00); 
   3c110:	f7e9 bf8c 	b.w	2602c <MAX20353_WriteReg>
   3c114:	4629      	mov	r1, r5
   3c116:	e7f8      	b.n	3c10a <MAX20353_LED1+0x1a>

0003c118 <MAX20353_EnablePMICIntMaskRegisters>:
{
   3c118:	b538      	push	{r3, r4, r5, lr}
   3c11a:	4605      	mov	r5, r0
	ret  = MAX20353_WriteReg(REG_INT_MASK0, buf_results[0]);
   3c11c:	7801      	ldrb	r1, [r0, #0]
   3c11e:	200c      	movs	r0, #12
   3c120:	f7e9 ff84 	bl	2602c <MAX20353_WriteReg>
	ret |= MAX20353_WriteReg(REG_INT_MASK1, buf_results[1]);
   3c124:	7869      	ldrb	r1, [r5, #1]
	ret  = MAX20353_WriteReg(REG_INT_MASK0, buf_results[0]);
   3c126:	4604      	mov	r4, r0
	ret |= MAX20353_WriteReg(REG_INT_MASK1, buf_results[1]);
   3c128:	200d      	movs	r0, #13
   3c12a:	f7e9 ff7f 	bl	2602c <MAX20353_WriteReg>
	ret |= MAX20353_WriteReg(REG_INT_MASK2, buf_results[2]);
   3c12e:	78a9      	ldrb	r1, [r5, #2]
	ret |= MAX20353_WriteReg(REG_INT_MASK1, buf_results[1]);
   3c130:	4304      	orrs	r4, r0
	ret |= MAX20353_WriteReg(REG_INT_MASK2, buf_results[2]);
   3c132:	200e      	movs	r0, #14
   3c134:	f7e9 ff7a 	bl	2602c <MAX20353_WriteReg>
}
   3c138:	4320      	orrs	r0, r4
   3c13a:	bd38      	pop	{r3, r4, r5, pc}

0003c13c <MAX20353_GetDeviceID>:
	MAX20353_ReadReg(REG_HARDWARE_ID, Device_ID);
   3c13c:	4601      	mov	r1, r0
   3c13e:	2000      	movs	r0, #0
   3c140:	f7e9 bf88 	b.w	26054 <MAX20353_ReadReg>

0003c144 <MAX20353_QuickStart>:
	WriteWord(0x06, 0x40, 0x00);
   3c144:	2200      	movs	r2, #0
   3c146:	2140      	movs	r1, #64	; 0x40
   3c148:	2006      	movs	r0, #6
   3c14a:	f7ea b951 	b.w	263f0 <WriteWord>

0003c14e <handle_model>:
handle_model(LOAD_MODEL);
If you want to verify the model, and correct errors, call:
handle_model(VERIFY_AND_FIX);
*/
void handle_model(int load_or_verify)
{
   3c14e:	b538      	push	{r3, r4, r5, lr}
   3c150:	4605      	mov	r5, r0
   3c152:	2403      	movs	r4, #3
	u8_t retry = 3;
	
	do
	{
		// Steps 1-4
		prepare_to_load_model();
   3c154:	f7ea fa0c 	bl	26570 <prepare_to_load_model>
		if(load_or_verify == LOAD_MODEL)
   3c158:	b90d      	cbnz	r5, 3c15e <handle_model+0x10>
		{
			//Step 5
			load_model();
   3c15a:	f7ea fa21 	bl	265a0 <load_model>
		}
		
		//Steps 6-9
		model_load_ok = verify_model_is_correct();
   3c15e:	f7ea fa43 	bl	265e8 <verify_model_is_correct>
		if(!model_load_ok)
   3c162:	b118      	cbz	r0, 3c16c <handle_model+0x1e>
		retry--;
	}while((!model_load_ok)&&(retry>0));
	
	// Steps 10-11
	cleanup_model_load();
}
   3c164:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	cleanup_model_load();
   3c168:	f7ea ba64 	b.w	26634 <cleanup_model_load>
		retry--;
   3c16c:	3c01      	subs	r4, #1
	}while((!model_load_ok)&&(retry>0));
   3c16e:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
			load_or_verify = LOAD_MODEL;
   3c172:	4605      	mov	r5, r0
	}while((!model_load_ok)&&(retry>0));
   3c174:	d1ee      	bne.n	3c154 <handle_model+0x6>
   3c176:	e7f5      	b.n	3c164 <handle_model+0x16>

0003c178 <MAX20353_SOCReadReg>:
   3c178:	f7ea b902 	b.w	26380 <ReadWord>

0003c17c <MAX20353_SOCWriteReg>:
   3c17c:	f7ea b938 	b.w	263f0 <WriteWord>

0003c180 <MAX20353_SOCInit>:
		return MAX20353_ERROR;
	return MAX20353_NO_ERROR;
}

void MAX20353_SOCInit(void)
{
   3c180:	b507      	push	{r0, r1, r2, lr}
	u8_t MSB,LSB;

	MAX20353_SOCReadReg(0x1A, &MSB, &LSB);
   3c182:	201a      	movs	r0, #26
   3c184:	f10d 0106 	add.w	r1, sp, #6
   3c188:	f10d 0207 	add.w	r2, sp, #7
   3c18c:	f7ea f8f8 	bl	26380 <ReadWord>
	if(MSB&0x01)
   3c190:	f89d 1006 	ldrb.w	r1, [sp, #6]
   3c194:	07cb      	lsls	r3, r1, #31
   3c196:	d510      	bpl.n	3c1ba <MAX20353_SOCInit+0x3a>
	{
		//RI (reset indicator) is set when the device powers up.
		//Any time this bit is set, the IC is not configured, so the
		//model should be loaded and the bit should be cleared
		MSB = MSB&0xFE;
   3c198:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
		MAX20353_SOCWriteReg(0x1A, MSB, LSB);
   3c19c:	f89d 2007 	ldrb.w	r2, [sp, #7]
   3c1a0:	201a      	movs	r0, #26
		MSB = MSB&0xFE;
   3c1a2:	f88d 1006 	strb.w	r1, [sp, #6]
		MAX20353_SOCWriteReg(0x1A, MSB, LSB);
   3c1a6:	f7ea f923 	bl	263f0 <WriteWord>
		MAX20353_QuickStart();
   3c1aa:	f7ff ffcb 	bl	3c144 <MAX20353_QuickStart>
    k_sleep(K_MSEC(period));
   3c1ae:	2096      	movs	r0, #150	; 0x96
   3c1b0:	f7ff ff8d 	bl	3c0ce <k_sleep>
		delay_ms(150);
		
		handle_model(LOAD_MODEL);
   3c1b4:	2000      	movs	r0, #0
   3c1b6:	f7ff ffca 	bl	3c14e <handle_model>
	}
	
	//25SOC1%4%
	WriteWord(0x0C, 0x12, 0x5C);
   3c1ba:	225c      	movs	r2, #92	; 0x5c
   3c1bc:	2112      	movs	r1, #18
   3c1be:	200c      	movs	r0, #12
   3c1c0:	f7ea f916 	bl	263f0 <WriteWord>

#ifdef BATTERT_NTC_CHECK
	MAX20353_StartCheckTemper();
   3c1c4:	f7ea f9b2 	bl	2652c <MAX20353_StartCheckTemper>
#endif
}
   3c1c8:	b003      	add	sp, #12
   3c1ca:	f85d fb04 	ldr.w	pc, [sp], #4

0003c1ce <GetHeartRate>:
	gpio_pin_write(gpio_ppg, 17, 0);
	return 0;
}

void GetHeartRate(u8_t *HR)
{
   3c1ce:	b538      	push	{r3, r4, r5, lr}
   3c1d0:	4605      	mov	r5, r0
	u32_t heart;

	while(1)
	{
		heart = sys_rand32_get();
		if(((heart%200)>=60) && ((heart%200)<=160))
   3c1d2:	24c8      	movs	r4, #200	; 0xc8
		heart = sys_rand32_get();
   3c1d4:	f7ed fcb2 	bl	29b3c <sys_rand32_get>
		if(((heart%200)>=60) && ((heart%200)<=160))
   3c1d8:	fbb0 f3f4 	udiv	r3, r0, r4
   3c1dc:	fb03 0014 	mls	r0, r3, r4, r0
   3c1e0:	f1a0 033c 	sub.w	r3, r0, #60	; 0x3c
   3c1e4:	2b64      	cmp	r3, #100	; 0x64
   3c1e6:	d8f5      	bhi.n	3c1d4 <GetHeartRate+0x6>
		{
			*HR = (heart%200);
   3c1e8:	7028      	strb	r0, [r5, #0]
			break;
		}
	}
}
   3c1ea:	bd38      	pop	{r3, r4, r5, pc}

0003c1ec <mmi_chset_init>:
	}
#endif /* __MMI_CHSET_WESTERN_WIN__ */ 


    g_chset_tbl_is_init = true;
}
   3c1ec:	4770      	bx	lr

0003c1ee <get_bit_ptr>:
{
   3c1ee:	b570      	push	{r4, r5, r6, lr}
   3c1f0:	250c      	movs	r5, #12
   3c1f2:	68c6      	ldr	r6, [r0, #12]
	u32_t *bitarray = level <= p->max_inline_level ?
   3c1f4:	f990 000b 	ldrsb.w	r0, [r0, #11]
   3c1f8:	434d      	muls	r5, r1
		p->levels[level].bits : p->levels[level].bits_p;
   3c1fa:	4288      	cmp	r0, r1
	*word = &bitarray[bn / 32];
   3c1fc:	4610      	mov	r0, r2
   3c1fe:	eb06 0405 	add.w	r4, r6, r5
		p->levels[level].bits : p->levels[level].bits_p;
   3c202:	bfb8      	it	lt
   3c204:	5974      	ldrlt	r4, [r6, r5]
	*word = &bitarray[bn / 32];
   3c206:	2a00      	cmp	r2, #0
   3c208:	bfb8      	it	lt
   3c20a:	f102 001f 	addlt.w	r0, r2, #31
   3c20e:	1140      	asrs	r0, r0, #5
   3c210:	eb04 0180 	add.w	r1, r4, r0, lsl #2
   3c214:	6019      	str	r1, [r3, #0]
}
   3c216:	f002 001f 	and.w	r0, r2, #31
   3c21a:	bd70      	pop	{r4, r5, r6, pc}

0003c21c <pool_irq_lock.isra.2.part.3>:
	__asm__ volatile(
   3c21c:	f04f 0320 	mov.w	r3, #32
   3c220:	f3ef 8011 	mrs	r0, BASEPRI
   3c224:	f383 8811 	msr	BASEPRI, r3
   3c228:	f3bf 8f6f 	isb	sy
}
   3c22c:	4770      	bx	lr

0003c22e <pool_irq_unlock.isra.4>:
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   3c22e:	07c3      	lsls	r3, r0, #31
   3c230:	d503      	bpl.n	3c23a <pool_irq_unlock.isra.4+0xc>
	__asm__ volatile(
   3c232:	f381 8811 	msr	BASEPRI, r1
   3c236:	f3bf 8f6f 	isb	sy
}
   3c23a:	4770      	bx	lr

0003c23c <z_sys_mem_pool_base_init>:
	p->max_inline_level = -1;
   3c23c:	23ff      	movs	r3, #255	; 0xff
{
   3c23e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   3c242:	6846      	ldr	r6, [r0, #4]
	p->max_inline_level = -1;
   3c244:	72c3      	strb	r3, [r0, #11]
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   3c246:	4632      	mov	r2, r6
	for (i = 0; i < p->n_levels; i++) {
   3c248:	2300      	movs	r3, #0
		sys_dlist_init(&p->levels[i].free_list);
   3c24a:	f04f 090c 	mov.w	r9, #12
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   3c24e:	8907      	ldrh	r7, [r0, #8]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   3c250:	6801      	ldr	r1, [r0, #0]
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   3c252:	fb06 fc07 	mul.w	ip, r6, r7
	for (i = 0; i < p->n_levels; i++) {
   3c256:	f890 800a 	ldrb.w	r8, [r0, #10]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   3c25a:	4461      	add	r1, ip
	for (i = 0; i < p->n_levels; i++) {
   3c25c:	4598      	cmp	r8, r3
   3c25e:	dc05      	bgt.n	3c26c <z_sys_mem_pool_base_init+0x30>
   3c260:	2300      	movs	r3, #0
	for (i = 0; i < p->n_max; i++) {
   3c262:	4619      	mov	r1, r3
   3c264:	428f      	cmp	r7, r1
   3c266:	dc20      	bgt.n	3c2aa <z_sys_mem_pool_base_init+0x6e>
}
   3c268:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		int nblocks = buflen / sz;
   3c26c:	fbbc f5f2 	udiv	r5, ip, r2
		sys_dlist_init(&p->levels[i].free_list);
   3c270:	fb09 fe03 	mul.w	lr, r9, r3
   3c274:	f8d0 a00c 	ldr.w	sl, [r0, #12]
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
   3c278:	2d20      	cmp	r5, #32
		sys_dlist_init(&p->levels[i].free_list);
   3c27a:	eb0a 040e 	add.w	r4, sl, lr
   3c27e:	f104 0b04 	add.w	fp, r4, #4
	list->tail = (sys_dnode_t *)list;
   3c282:	e9c4 bb01 	strd	fp, fp, [r4, #4]
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
   3c286:	d805      	bhi.n	3c294 <z_sys_mem_pool_base_init+0x58>
			p->max_inline_level = i;
   3c288:	72c3      	strb	r3, [r0, #11]
		sz = WB_DN(sz / 4);
   3c28a:	0892      	lsrs	r2, r2, #2
   3c28c:	f022 0203 	bic.w	r2, r2, #3
	for (i = 0; i < p->n_levels; i++) {
   3c290:	3301      	adds	r3, #1
   3c292:	e7e3      	b.n	3c25c <z_sys_mem_pool_base_init+0x20>
			bits += (nblocks + 31)/32;
   3c294:	f115 041f 	adds.w	r4, r5, #31
   3c298:	bf48      	it	mi
   3c29a:	f105 043e 	addmi.w	r4, r5, #62	; 0x3e
   3c29e:	1164      	asrs	r4, r4, #5
			p->levels[i].bits_p = bits;
   3c2a0:	f84a 100e 	str.w	r1, [sl, lr]
			bits += (nblocks + 31)/32;
   3c2a4:	eb01 0184 	add.w	r1, r1, r4, lsl #2
   3c2a8:	e7ef      	b.n	3c28a <z_sys_mem_pool_base_init+0x4e>
		sys_dlist_append(&p->levels[0].free_list, block);
   3c2aa:	68c2      	ldr	r2, [r0, #12]
	return (u8_t *)p->buf + lsz * block;
   3c2ac:	6805      	ldr	r5, [r0, #0]
		sys_dlist_append(&p->levels[0].free_list, block);
   3c2ae:	f102 0c04 	add.w	ip, r2, #4
	return (u8_t *)p->buf + lsz * block;
   3c2b2:	18ec      	adds	r4, r5, r3
	node->next = list;
   3c2b4:	f845 c003 	str.w	ip, [r5, r3]
	node->prev = list->tail;
   3c2b8:	6895      	ldr	r5, [r2, #8]
	for (i = 0; i < p->n_max; i++) {
   3c2ba:	3101      	adds	r1, #1
   3c2bc:	6065      	str	r5, [r4, #4]
	list->tail->next = node;
   3c2be:	6895      	ldr	r5, [r2, #8]
   3c2c0:	4433      	add	r3, r6
   3c2c2:	602c      	str	r4, [r5, #0]
	list->tail = node;
   3c2c4:	6094      	str	r4, [r2, #8]
   3c2c6:	e7cd      	b.n	3c264 <z_sys_mem_pool_base_init+0x28>

0003c2c8 <z_sys_mem_pool_block_alloc>:
{
   3c2c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3c2cc:	b087      	sub	sp, #28
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   3c2ce:	7a84      	ldrb	r4, [r0, #10]
{
   3c2d0:	af00      	add	r7, sp, #0
   3c2d2:	e9c7 3201 	strd	r3, r2, [r7, #4]
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   3c2d6:	00a3      	lsls	r3, r4, #2
   3c2d8:	3307      	adds	r3, #7
   3c2da:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
   3c2de:	ebad 0d03 	sub.w	sp, sp, r3
   3c2e2:	46ea      	mov	sl, sp
	lsizes[0] = p->max_sz;
   3c2e4:	4653      	mov	r3, sl
   3c2e6:	6842      	ldr	r2, [r0, #4]
{
   3c2e8:	4605      	mov	r5, r0
	lsizes[0] = p->max_sz;
   3c2ea:	f843 2904 	str.w	r2, [r3], #-4
	for (i = 0; i < p->n_levels; i++) {
   3c2ee:	2200      	movs	r2, #0
   3c2f0:	4294      	cmp	r4, r2
   3c2f2:	f102 39ff 	add.w	r9, r2, #4294967295
   3c2f6:	dd09      	ble.n	3c30c <z_sys_mem_pool_block_alloc+0x44>
		if (i > 0) {
   3c2f8:	b122      	cbz	r2, 3c304 <z_sys_mem_pool_block_alloc+0x3c>
			lsizes[i] = WB_DN(lsizes[i-1] / 4);
   3c2fa:	6818      	ldr	r0, [r3, #0]
   3c2fc:	0880      	lsrs	r0, r0, #2
   3c2fe:	f020 0003 	bic.w	r0, r0, #3
   3c302:	6058      	str	r0, [r3, #4]
		if (lsizes[i] < size) {
   3c304:	f853 0f04 	ldr.w	r0, [r3, #4]!
   3c308:	4288      	cmp	r0, r1
   3c30a:	d208      	bcs.n	3c31e <z_sys_mem_pool_block_alloc+0x56>
	if (alloc_l < 0) {
   3c30c:	f1b9 3fff 	cmp.w	r9, #4294967295
   3c310:	d107      	bne.n	3c322 <z_sys_mem_pool_block_alloc+0x5a>
		*data_p = NULL;
   3c312:	2300      	movs	r3, #0
   3c314:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   3c316:	6013      	str	r3, [r2, #0]
		return -ENOMEM;
   3c318:	f06f 000b 	mvn.w	r0, #11
   3c31c:	e02c      	b.n	3c378 <z_sys_mem_pool_block_alloc+0xb0>
	for (i = 0; i < p->n_levels; i++) {
   3c31e:	3201      	adds	r2, #1
   3c320:	e7e6      	b.n	3c2f0 <z_sys_mem_pool_block_alloc+0x28>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   3c322:	7c28      	ldrb	r0, [r5, #16]
   3c324:	f010 0001 	ands.w	r0, r0, #1
   3c328:	d001      	beq.n	3c32e <z_sys_mem_pool_block_alloc+0x66>
   3c32a:	f7ff ff77 	bl	3c21c <pool_irq_lock.isra.2.part.3>
   3c32e:	230c      	movs	r3, #12
	key = pool_irq_lock(p);
   3c330:	4680      	mov	r8, r0
	block = sys_dlist_get(&p->levels[l].free_list);
   3c332:	464e      	mov	r6, r9
   3c334:	68ea      	ldr	r2, [r5, #12]
   3c336:	fb03 2309 	mla	r3, r3, r9, r2
	return list->head == list;
   3c33a:	461a      	mov	r2, r3
   3c33c:	f852 4f04 	ldr.w	r4, [r2, #4]!

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   3c340:	4294      	cmp	r4, r2
   3c342:	d11d      	bne.n	3c380 <z_sys_mem_pool_block_alloc+0xb8>
	for (i = alloc_l; i >= 0; i--) {
   3c344:	3e01      	subs	r6, #1
   3c346:	1c72      	adds	r2, r6, #1
   3c348:	f1a3 030c 	sub.w	r3, r3, #12
   3c34c:	d1f5      	bne.n	3c33a <z_sys_mem_pool_block_alloc+0x72>
   3c34e:	2400      	movs	r4, #0
	pool_irq_unlock(p, key);
   3c350:	4641      	mov	r1, r8
   3c352:	7c28      	ldrb	r0, [r5, #16]
   3c354:	f7ff ff6b 	bl	3c22e <pool_irq_unlock.isra.4>
	*data_p = data;
   3c358:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   3c35a:	601c      	str	r4, [r3, #0]
	if (data == NULL) {
   3c35c:	2c00      	cmp	r4, #0
   3c35e:	d0db      	beq.n	3c318 <z_sys_mem_pool_block_alloc+0x50>
	*level_p = alloc_l;
   3c360:	68bb      	ldr	r3, [r7, #8]
	return 0;
   3c362:	2000      	movs	r0, #0
	*level_p = alloc_l;
   3c364:	f8c3 9000 	str.w	r9, [r3]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   3c368:	682b      	ldr	r3, [r5, #0]
   3c36a:	1ae4      	subs	r4, r4, r3
   3c36c:	f85a 3029 	ldr.w	r3, [sl, r9, lsl #2]
   3c370:	fb94 f4f3 	sdiv	r4, r4, r3
	*block_p = block_num(p, data, lsizes[alloc_l]);
   3c374:	687b      	ldr	r3, [r7, #4]
   3c376:	601c      	str	r4, [r3, #0]
}
   3c378:	371c      	adds	r7, #28
   3c37a:	46bd      	mov	sp, r7
   3c37c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	node->prev->next = node->next;
   3c380:	e9d4 3200 	ldrd	r3, r2, [r4]
   3c384:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   3c386:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   3c388:	2300      	movs	r3, #0
	node->prev = NULL;
   3c38a:	e9c4 3300 	strd	r3, r3, [r4]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   3c38e:	682b      	ldr	r3, [r5, #0]
		data = block_alloc(p, i, lsizes[i]);
   3c390:	f85a 1026 	ldr.w	r1, [sl, r6, lsl #2]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   3c394:	1ae2      	subs	r2, r4, r3
	int bit = get_bit_ptr(p, level, bn, &word);
   3c396:	f107 0b14 	add.w	fp, r7, #20
   3c39a:	fb92 f2f1 	sdiv	r2, r2, r1
   3c39e:	465b      	mov	r3, fp
   3c3a0:	4631      	mov	r1, r6
   3c3a2:	4628      	mov	r0, r5
   3c3a4:	f7ff ff23 	bl	3c1ee <get_bit_ptr>
	*word |= (1<<bit);
   3c3a8:	2201      	movs	r2, #1
   3c3aa:	6979      	ldr	r1, [r7, #20]
   3c3ac:	fa02 f000 	lsl.w	r0, r2, r0
   3c3b0:	680b      	ldr	r3, [r1, #0]
   3c3b2:	603a      	str	r2, [r7, #0]
   3c3b4:	4303      	orrs	r3, r0
   3c3b6:	600b      	str	r3, [r1, #0]
			for (from_l = i; from_l < alloc_l; from_l++) {
   3c3b8:	454e      	cmp	r6, r9
   3c3ba:	dac9      	bge.n	3c350 <z_sys_mem_pool_block_alloc+0x88>
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   3c3bc:	682a      	ldr	r2, [r5, #0]
   3c3be:	f85a 3026 	ldr.w	r3, [sl, r6, lsl #2]
   3c3c2:	1aa2      	subs	r2, r4, r2
   3c3c4:	fb92 f2f3 	sdiv	r2, r2, r3
	set_alloc_bit(p, l + 1, 4*bn);
   3c3c8:	3601      	adds	r6, #1
	int bit = get_bit_ptr(p, level, bn, &word);
   3c3ca:	465b      	mov	r3, fp
   3c3cc:	0092      	lsls	r2, r2, #2
   3c3ce:	4631      	mov	r1, r6
   3c3d0:	4628      	mov	r0, r5
   3c3d2:	f7ff ff0c 	bl	3c1ee <get_bit_ptr>
	*word |= (1<<bit);
   3c3d6:	697a      	ldr	r2, [r7, #20]
   3c3d8:	683b      	ldr	r3, [r7, #0]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   3c3da:	68e9      	ldr	r1, [r5, #12]
	*word |= (1<<bit);
   3c3dc:	fa03 f000 	lsl.w	r0, r3, r0
   3c3e0:	6813      	ldr	r3, [r2, #0]
   3c3e2:	4303      	orrs	r3, r0
   3c3e4:	6013      	str	r3, [r2, #0]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   3c3e6:	230c      	movs	r3, #12
   3c3e8:	2203      	movs	r2, #3
   3c3ea:	fb03 1106 	mla	r1, r3, r6, r1
		int lsz = lsizes[l + 1];
   3c3ee:	f85a 0026 	ldr.w	r0, [sl, r6, lsl #2]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   3c3f2:	f101 0e04 	add.w	lr, r1, #4
   3c3f6:	1823      	adds	r3, r4, r0
   3c3f8:	60fa      	str	r2, [r7, #12]
	node->prev = list->tail;
   3c3fa:	688a      	ldr	r2, [r1, #8]
	node->next = list;
   3c3fc:	f8c3 e000 	str.w	lr, [r3]
	node->prev = list->tail;
   3c400:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
   3c402:	688a      	ldr	r2, [r1, #8]
   3c404:	6013      	str	r3, [r2, #0]
	for (i = 1; i < 4; i++) {
   3c406:	68fa      	ldr	r2, [r7, #12]
	list->tail = node;
   3c408:	608b      	str	r3, [r1, #8]
   3c40a:	3a01      	subs	r2, #1
   3c40c:	4403      	add	r3, r0
   3c40e:	60fa      	str	r2, [r7, #12]
   3c410:	d1f3      	bne.n	3c3fa <z_sys_mem_pool_block_alloc+0x132>
				pool_irq_unlock(p, key);
   3c412:	4641      	mov	r1, r8
   3c414:	7c28      	ldrb	r0, [r5, #16]
   3c416:	f7ff ff0a 	bl	3c22e <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   3c41a:	7c2b      	ldrb	r3, [r5, #16]
   3c41c:	07db      	lsls	r3, r3, #31
   3c41e:	d503      	bpl.n	3c428 <z_sys_mem_pool_block_alloc+0x160>
   3c420:	f7ff fefc 	bl	3c21c <pool_irq_lock.isra.2.part.3>
				key = pool_irq_lock(p);
   3c424:	4680      	mov	r8, r0
   3c426:	e7c7      	b.n	3c3b8 <z_sys_mem_pool_block_alloc+0xf0>
		return 0;
   3c428:	68f8      	ldr	r0, [r7, #12]
   3c42a:	e7fb      	b.n	3c424 <z_sys_mem_pool_block_alloc+0x15c>

0003c42c <arch_printk_char_out>:
}
   3c42c:	2000      	movs	r0, #0
   3c42e:	4770      	bx	lr

0003c430 <print_err>:
{
   3c430:	b570      	push	{r4, r5, r6, lr}
   3c432:	460d      	mov	r5, r1
   3c434:	4604      	mov	r4, r0
	out('E', ctx);
   3c436:	2045      	movs	r0, #69	; 0x45
   3c438:	47a0      	blx	r4
	out('R', ctx);
   3c43a:	4629      	mov	r1, r5
   3c43c:	2052      	movs	r0, #82	; 0x52
   3c43e:	47a0      	blx	r4
	out('R', ctx);
   3c440:	4629      	mov	r1, r5
   3c442:	4623      	mov	r3, r4
}
   3c444:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
   3c448:	2052      	movs	r0, #82	; 0x52
   3c44a:	4718      	bx	r3

0003c44c <z_vprintk>:
{
   3c44c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char length_mod = 0;
   3c450:	f04f 0800 	mov.w	r8, #0
{
   3c454:	4606      	mov	r6, r0
   3c456:	460f      	mov	r7, r1
   3c458:	461c      	mov	r4, r3
	int min_width = -1;
   3c45a:	f04f 3aff 	mov.w	sl, #4294967295
	enum pad_type padding = PAD_NONE;
   3c45e:	46c1      	mov	r9, r8
	int might_format = 0; /* 1 if encountered a '%' */
   3c460:	4645      	mov	r5, r8
{
   3c462:	b08b      	sub	sp, #44	; 0x2c
   3c464:	9202      	str	r2, [sp, #8]
	while (*fmt) {
   3c466:	9b02      	ldr	r3, [sp, #8]
   3c468:	7818      	ldrb	r0, [r3, #0]
   3c46a:	b910      	cbnz	r0, 3c472 <z_vprintk+0x26>
}
   3c46c:	b00b      	add	sp, #44	; 0x2c
   3c46e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!might_format) {
   3c472:	b945      	cbnz	r5, 3c486 <z_vprintk+0x3a>
			if (*fmt != '%') {
   3c474:	2825      	cmp	r0, #37	; 0x25
   3c476:	f000 814b 	beq.w	3c710 <z_vprintk+0x2c4>
				out((int)*fmt, ctx);
   3c47a:	4639      	mov	r1, r7
   3c47c:	47b0      	blx	r6
		++fmt;
   3c47e:	9b02      	ldr	r3, [sp, #8]
   3c480:	3301      	adds	r3, #1
   3c482:	9302      	str	r3, [sp, #8]
   3c484:	e7ef      	b.n	3c466 <z_vprintk+0x1a>
			switch (*fmt) {
   3c486:	2864      	cmp	r0, #100	; 0x64
   3c488:	d06d      	beq.n	3c566 <z_vprintk+0x11a>
   3c48a:	d819      	bhi.n	3c4c0 <z_vprintk+0x74>
   3c48c:	2839      	cmp	r0, #57	; 0x39
   3c48e:	d80a      	bhi.n	3c4a6 <z_vprintk+0x5a>
   3c490:	2831      	cmp	r0, #49	; 0x31
   3c492:	d25f      	bcs.n	3c554 <z_vprintk+0x108>
   3c494:	282d      	cmp	r0, #45	; 0x2d
   3c496:	f000 8141 	beq.w	3c71c <z_vprintk+0x2d0>
   3c49a:	2830      	cmp	r0, #48	; 0x30
   3c49c:	d04b      	beq.n	3c536 <z_vprintk+0xea>
   3c49e:	2825      	cmp	r0, #37	; 0x25
   3c4a0:	d107      	bne.n	3c4b2 <z_vprintk+0x66>
				out((int)'%', ctx);
   3c4a2:	4639      	mov	r1, r7
   3c4a4:	e132      	b.n	3c70c <z_vprintk+0x2c0>
			switch (*fmt) {
   3c4a6:	2858      	cmp	r0, #88	; 0x58
   3c4a8:	f000 80bb 	beq.w	3c622 <z_vprintk+0x1d6>
   3c4ac:	2863      	cmp	r0, #99	; 0x63
   3c4ae:	f000 812a 	beq.w	3c706 <z_vprintk+0x2ba>
				out((int)'%', ctx);
   3c4b2:	4639      	mov	r1, r7
   3c4b4:	2025      	movs	r0, #37	; 0x25
   3c4b6:	47b0      	blx	r6
				out((int)*fmt, ctx);
   3c4b8:	9b02      	ldr	r3, [sp, #8]
   3c4ba:	4639      	mov	r1, r7
   3c4bc:	7818      	ldrb	r0, [r3, #0]
   3c4be:	e125      	b.n	3c70c <z_vprintk+0x2c0>
			switch (*fmt) {
   3c4c0:	2870      	cmp	r0, #112	; 0x70
   3c4c2:	f000 80a4 	beq.w	3c60e <z_vprintk+0x1c2>
   3c4c6:	d811      	bhi.n	3c4ec <z_vprintk+0xa0>
   3c4c8:	2869      	cmp	r0, #105	; 0x69
   3c4ca:	d04c      	beq.n	3c566 <z_vprintk+0x11a>
   3c4cc:	286c      	cmp	r0, #108	; 0x6c
   3c4ce:	d105      	bne.n	3c4dc <z_vprintk+0x90>
				} else if (*fmt == 'l' && length_mod == 'l') {
   3c4d0:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   3c4d4:	d12a      	bne.n	3c52c <z_vprintk+0xe0>
					length_mod = 'L';
   3c4d6:	f04f 084c 	mov.w	r8, #76	; 0x4c
   3c4da:	e7d0      	b.n	3c47e <z_vprintk+0x32>
			switch (*fmt) {
   3c4dc:	2868      	cmp	r0, #104	; 0x68
   3c4de:	d1e8      	bne.n	3c4b2 <z_vprintk+0x66>
				if (*fmt == 'h' && length_mod == 'h') {
   3c4e0:	f1b8 0f68 	cmp.w	r8, #104	; 0x68
   3c4e4:	d122      	bne.n	3c52c <z_vprintk+0xe0>
					length_mod = 'H';
   3c4e6:	f04f 0848 	mov.w	r8, #72	; 0x48
   3c4ea:	e7c8      	b.n	3c47e <z_vprintk+0x32>
			switch (*fmt) {
   3c4ec:	2875      	cmp	r0, #117	; 0x75
   3c4ee:	d072      	beq.n	3c5d6 <z_vprintk+0x18a>
   3c4f0:	d818      	bhi.n	3c524 <z_vprintk+0xd8>
   3c4f2:	2873      	cmp	r0, #115	; 0x73
   3c4f4:	d1dd      	bne.n	3c4b2 <z_vprintk+0x66>
				char *s = va_arg(ap, char *);
   3c4f6:	f854 5b04 	ldr.w	r5, [r4], #4
				while (*s) {
   3c4fa:	46ab      	mov	fp, r5
   3c4fc:	465b      	mov	r3, fp
   3c4fe:	f81b 0b01 	ldrb.w	r0, [fp], #1
   3c502:	2800      	cmp	r0, #0
   3c504:	f040 80fc 	bne.w	3c700 <z_vprintk+0x2b4>
				if (padding == PAD_SPACE_AFTER) {
   3c508:	f1b9 0f03 	cmp.w	r9, #3
   3c50c:	f040 810c 	bne.w	3c728 <z_vprintk+0x2dc>
					int remaining = min_width - (s - start);
   3c510:	1b5d      	subs	r5, r3, r5
   3c512:	ebaa 0505 	sub.w	r5, sl, r5
					while (remaining-- > 0) {
   3c516:	2d00      	cmp	r5, #0
   3c518:	dd49      	ble.n	3c5ae <z_vprintk+0x162>
						out(' ', ctx);
   3c51a:	4639      	mov	r1, r7
   3c51c:	2020      	movs	r0, #32
   3c51e:	47b0      	blx	r6
   3c520:	3d01      	subs	r5, #1
   3c522:	e7f8      	b.n	3c516 <z_vprintk+0xca>
			switch (*fmt) {
   3c524:	2878      	cmp	r0, #120	; 0x78
   3c526:	d07c      	beq.n	3c622 <z_vprintk+0x1d6>
   3c528:	287a      	cmp	r0, #122	; 0x7a
   3c52a:	d1c2      	bne.n	3c4b2 <z_vprintk+0x66>
				} else if (length_mod == 0) {
   3c52c:	f1b8 0f00 	cmp.w	r8, #0
   3c530:	d1bf      	bne.n	3c4b2 <z_vprintk+0x66>
   3c532:	4680      	mov	r8, r0
   3c534:	e7a3      	b.n	3c47e <z_vprintk+0x32>
				if (min_width < 0 && padding == PAD_NONE) {
   3c536:	f1ba 0f00 	cmp.w	sl, #0
   3c53a:	da0e      	bge.n	3c55a <z_vprintk+0x10e>
   3c53c:	f1b9 0f00 	cmp.w	r9, #0
   3c540:	f000 80ef 	beq.w	3c722 <z_vprintk+0x2d6>
					min_width = *fmt - '0';
   3c544:	f1a0 0a30 	sub.w	sl, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
   3c548:	f1b9 0f00 	cmp.w	r9, #0
   3c54c:	bf08      	it	eq
   3c54e:	f04f 0902 	moveq.w	r9, #2
   3c552:	e794      	b.n	3c47e <z_vprintk+0x32>
				if (min_width < 0) {
   3c554:	f1ba 0f00 	cmp.w	sl, #0
   3c558:	dbf4      	blt.n	3c544 <z_vprintk+0xf8>
					min_width = 10 * min_width + *fmt - '0';
   3c55a:	230a      	movs	r3, #10
   3c55c:	fb03 0a0a 	mla	sl, r3, sl, r0
   3c560:	f1aa 0a30 	sub.w	sl, sl, #48	; 0x30
   3c564:	e7f0      	b.n	3c548 <z_vprintk+0xfc>
				if (length_mod == 'z') {
   3c566:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
   3c56a:	d102      	bne.n	3c572 <z_vprintk+0x126>
					d = va_arg(ap, int);
   3c56c:	f854 5b04 	ldr.w	r5, [r4], #4
   3c570:	e020      	b.n	3c5b4 <z_vprintk+0x168>
				} else if (length_mod == 'l') {
   3c572:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   3c576:	d0f9      	beq.n	3c56c <z_vprintk+0x120>
				} else if (length_mod == 'L') {
   3c578:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   3c57c:	d1f6      	bne.n	3c56c <z_vprintk+0x120>
					long long lld = va_arg(ap, long long);
   3c57e:	3407      	adds	r4, #7
   3c580:	f024 0407 	bic.w	r4, r4, #7
   3c584:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (lld > __LONG_MAX__ ||
   3c588:	f112 4100 	adds.w	r1, r2, #2147483648	; 0x80000000
   3c58c:	9106      	str	r1, [sp, #24]
   3c58e:	f143 0100 	adc.w	r1, r3, #0
   3c592:	9107      	str	r1, [sp, #28]
   3c594:	2100      	movs	r1, #0
   3c596:	e9dd bc06 	ldrd	fp, ip, [sp, #24]
   3c59a:	f04f 30ff 	mov.w	r0, #4294967295
   3c59e:	4561      	cmp	r1, ip
   3c5a0:	bf08      	it	eq
   3c5a2:	4558      	cmpeq	r0, fp
   3c5a4:	d205      	bcs.n	3c5b2 <z_vprintk+0x166>
						print_err(out, ctx);
   3c5a6:	4639      	mov	r1, r7
   3c5a8:	4630      	mov	r0, r6
   3c5aa:	f7ff ff41 	bl	3c430 <print_err>
			might_format = 0;
   3c5ae:	2500      	movs	r5, #0
				break;
   3c5b0:	e765      	b.n	3c47e <z_vprintk+0x32>
					d = lld;
   3c5b2:	4615      	mov	r5, r2
				if (d < 0) {
   3c5b4:	2d00      	cmp	r5, #0
   3c5b6:	da05      	bge.n	3c5c4 <z_vprintk+0x178>
					out((int)'-', ctx);
   3c5b8:	4639      	mov	r1, r7
   3c5ba:	202d      	movs	r0, #45	; 0x2d
   3c5bc:	47b0      	blx	r6
					d = -d;
   3c5be:	426d      	negs	r5, r5
					min_width--;
   3c5c0:	f10a 3aff 	add.w	sl, sl, #4294967295
				_printk_dec_ulong(out, ctx, d, padding,
   3c5c4:	464b      	mov	r3, r9
   3c5c6:	462a      	mov	r2, r5
   3c5c8:	f8cd a000 	str.w	sl, [sp]
				_printk_dec_ulong(out, ctx, u, padding,
   3c5cc:	4639      	mov	r1, r7
   3c5ce:	4630      	mov	r0, r6
   3c5d0:	f7ea f964 	bl	2689c <_printk_dec_ulong>
				break;
   3c5d4:	e7eb      	b.n	3c5ae <z_vprintk+0x162>
				if (length_mod == 'z') {
   3c5d6:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
   3c5da:	d102      	bne.n	3c5e2 <z_vprintk+0x196>
					u = va_arg(ap, unsigned int);
   3c5dc:	f854 2b04 	ldr.w	r2, [r4], #4
   3c5e0:	e011      	b.n	3c606 <z_vprintk+0x1ba>
				} else if (length_mod == 'l') {
   3c5e2:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   3c5e6:	d0f9      	beq.n	3c5dc <z_vprintk+0x190>
				} else if (length_mod == 'L') {
   3c5e8:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   3c5ec:	d1f6      	bne.n	3c5dc <z_vprintk+0x190>
					if (llu > ~0UL) {
   3c5ee:	2100      	movs	r1, #0
   3c5f0:	f04f 30ff 	mov.w	r0, #4294967295
					unsigned long long llu =
   3c5f4:	3407      	adds	r4, #7
   3c5f6:	f024 0407 	bic.w	r4, r4, #7
   3c5fa:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > ~0UL) {
   3c5fe:	4299      	cmp	r1, r3
   3c600:	bf08      	it	eq
   3c602:	4290      	cmpeq	r0, r2
   3c604:	d3cf      	bcc.n	3c5a6 <z_vprintk+0x15a>
				_printk_dec_ulong(out, ctx, u, padding,
   3c606:	f8cd a000 	str.w	sl, [sp]
   3c60a:	464b      	mov	r3, r9
   3c60c:	e7de      	b.n	3c5cc <z_vprintk+0x180>
				out('0', ctx);
   3c60e:	4639      	mov	r1, r7
   3c610:	2030      	movs	r0, #48	; 0x30
   3c612:	47b0      	blx	r6
				out('x', ctx);
   3c614:	4639      	mov	r1, r7
   3c616:	2078      	movs	r0, #120	; 0x78
   3c618:	47b0      	blx	r6
					min_width = 8;
   3c61a:	f04f 0a08 	mov.w	sl, #8
				padding = PAD_ZERO_BEFORE;
   3c61e:	f04f 0901 	mov.w	r9, #1
				if (*fmt == 'p') {
   3c622:	9b02      	ldr	r3, [sp, #8]
   3c624:	781b      	ldrb	r3, [r3, #0]
   3c626:	2b70      	cmp	r3, #112	; 0x70
   3c628:	d104      	bne.n	3c634 <z_vprintk+0x1e8>
					x = va_arg(ap, unsigned int);
   3c62a:	f854 3b04 	ldr.w	r3, [r4], #4
   3c62e:	9304      	str	r3, [sp, #16]
   3c630:	2300      	movs	r3, #0
   3c632:	e00d      	b.n	3c650 <z_vprintk+0x204>
				} else if (length_mod == 'l') {
   3c634:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   3c638:	d0f7      	beq.n	3c62a <z_vprintk+0x1de>
				} else if (length_mod == 'L') {
   3c63a:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   3c63e:	d1f4      	bne.n	3c62a <z_vprintk+0x1de>
					x = va_arg(ap, unsigned long long);
   3c640:	3407      	adds	r4, #7
   3c642:	f024 0307 	bic.w	r3, r4, #7
   3c646:	461c      	mov	r4, r3
   3c648:	f854 2b08 	ldr.w	r2, [r4], #8
   3c64c:	685b      	ldr	r3, [r3, #4]
   3c64e:	9204      	str	r2, [sp, #16]
	int digits = 0;
   3c650:	2100      	movs	r1, #0
	int remaining = 16; /* 16 digits max */
   3c652:	2210      	movs	r2, #16
	int shift = sizeof(num) * 8;
   3c654:	f04f 0b40 	mov.w	fp, #64	; 0x40
	int digits = 0;
   3c658:	9103      	str	r1, [sp, #12]
	int found_largest_digit = 0;
   3c65a:	9105      	str	r1, [sp, #20]
		shift -= 4;
   3c65c:	f1ab 0b04 	sub.w	fp, fp, #4
		nibble = (num >> shift) & 0xf;
   3c660:	9804      	ldr	r0, [sp, #16]
   3c662:	f1cb 0c20 	rsb	ip, fp, #32
   3c666:	f1ab 0120 	sub.w	r1, fp, #32
   3c66a:	fa20 f00b 	lsr.w	r0, r0, fp
   3c66e:	fa03 fc0c 	lsl.w	ip, r3, ip
   3c672:	ea40 000c 	orr.w	r0, r0, ip
   3c676:	fa23 f101 	lsr.w	r1, r3, r1
   3c67a:	4308      	orrs	r0, r1
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
   3c67c:	f010 000f 	ands.w	r0, r0, #15
   3c680:	d106      	bne.n	3c690 <z_vprintk+0x244>
   3c682:	9905      	ldr	r1, [sp, #20]
   3c684:	b911      	cbnz	r1, 3c68c <z_vprintk+0x240>
   3c686:	f1bb 0f00 	cmp.w	fp, #0
   3c68a:	d122      	bne.n	3c6d2 <z_vprintk+0x286>
			nibble += nibble > 9 ? 87 : 48;
   3c68c:	2130      	movs	r1, #48	; 0x30
   3c68e:	e003      	b.n	3c698 <z_vprintk+0x24c>
   3c690:	2809      	cmp	r0, #9
   3c692:	bf8c      	ite	hi
   3c694:	2157      	movhi	r1, #87	; 0x57
   3c696:	2130      	movls	r1, #48	; 0x30
   3c698:	4408      	add	r0, r1
			out((int)nibble, ctx);
   3c69a:	b240      	sxtb	r0, r0
   3c69c:	4639      	mov	r1, r7
   3c69e:	9308      	str	r3, [sp, #32]
   3c6a0:	9205      	str	r2, [sp, #20]
   3c6a2:	47b0      	blx	r6
			digits++;
   3c6a4:	9b03      	ldr	r3, [sp, #12]
	while (shift >= 4) {
   3c6a6:	9a05      	ldr	r2, [sp, #20]
			digits++;
   3c6a8:	3301      	adds	r3, #1
   3c6aa:	9303      	str	r3, [sp, #12]
	while (shift >= 4) {
   3c6ac:	9b08      	ldr	r3, [sp, #32]
   3c6ae:	f1bb 0f00 	cmp.w	fp, #0
   3c6b2:	d123      	bne.n	3c6fc <z_vprintk+0x2b0>
	if (padding == PAD_SPACE_AFTER) {
   3c6b4:	f1b9 0f03 	cmp.w	r9, #3
   3c6b8:	f47f af79 	bne.w	3c5ae <z_vprintk+0x162>
		remaining = min_width * 2 - digits;
   3c6bc:	9b03      	ldr	r3, [sp, #12]
   3c6be:	ebc3 054a 	rsb	r5, r3, sl, lsl #1
		while (remaining-- > 0) {
   3c6c2:	2d00      	cmp	r5, #0
   3c6c4:	f77f af73 	ble.w	3c5ae <z_vprintk+0x162>
			out(' ', ctx);
   3c6c8:	4639      	mov	r1, r7
   3c6ca:	2020      	movs	r0, #32
   3c6cc:	47b0      	blx	r6
   3c6ce:	3d01      	subs	r5, #1
   3c6d0:	e7f7      	b.n	3c6c2 <z_vprintk+0x276>
		if (remaining-- <= min_width) {
   3c6d2:	1e51      	subs	r1, r2, #1
   3c6d4:	4592      	cmp	sl, r2
   3c6d6:	9108      	str	r1, [sp, #32]
   3c6d8:	db07      	blt.n	3c6ea <z_vprintk+0x29e>
			if (padding == PAD_ZERO_BEFORE) {
   3c6da:	f1b9 0f01 	cmp.w	r9, #1
   3c6de:	d106      	bne.n	3c6ee <z_vprintk+0x2a2>
				out('0', ctx);
   3c6e0:	4639      	mov	r1, r7
   3c6e2:	2030      	movs	r0, #48	; 0x30
   3c6e4:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
   3c6e6:	47b0      	blx	r6
   3c6e8:	9b09      	ldr	r3, [sp, #36]	; 0x24
			nibble += nibble > 9 ? 87 : 48;
   3c6ea:	9a08      	ldr	r2, [sp, #32]
   3c6ec:	e7b6      	b.n	3c65c <z_vprintk+0x210>
			} else if (padding == PAD_SPACE_BEFORE) {
   3c6ee:	f1b9 0f02 	cmp.w	r9, #2
   3c6f2:	d1fa      	bne.n	3c6ea <z_vprintk+0x29e>
   3c6f4:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
   3c6f6:	4639      	mov	r1, r7
   3c6f8:	2020      	movs	r0, #32
   3c6fa:	e7f4      	b.n	3c6e6 <z_vprintk+0x29a>
			found_largest_digit = 1;
   3c6fc:	9505      	str	r5, [sp, #20]
   3c6fe:	e7ad      	b.n	3c65c <z_vprintk+0x210>
					out((int)(*s++), ctx);
   3c700:	4639      	mov	r1, r7
   3c702:	47b0      	blx	r6
   3c704:	e6fa      	b.n	3c4fc <z_vprintk+0xb0>
				out(c, ctx);
   3c706:	4639      	mov	r1, r7
   3c708:	f854 0b04 	ldr.w	r0, [r4], #4
				out((int)'%', ctx);
   3c70c:	47b0      	blx	r6
   3c70e:	e74e      	b.n	3c5ae <z_vprintk+0x162>
				length_mod = 0;
   3c710:	46a8      	mov	r8, r5
				padding = PAD_NONE;
   3c712:	46a9      	mov	r9, r5
				min_width = -1;
   3c714:	f04f 3aff 	mov.w	sl, #4294967295
				might_format = 1;
   3c718:	2501      	movs	r5, #1
   3c71a:	e6b0      	b.n	3c47e <z_vprintk+0x32>
				padding = PAD_SPACE_AFTER;
   3c71c:	f04f 0903 	mov.w	r9, #3
   3c720:	e6ad      	b.n	3c47e <z_vprintk+0x32>
					padding = PAD_ZERO_BEFORE;
   3c722:	f04f 0901 	mov.w	r9, #1
   3c726:	e6aa      	b.n	3c47e <z_vprintk+0x32>
			might_format = 0;
   3c728:	4605      	mov	r5, r0
   3c72a:	e6a8      	b.n	3c47e <z_vprintk+0x32>

0003c72c <printk>:
{
   3c72c:	b40f      	push	{r0, r1, r2, r3}
   3c72e:	b507      	push	{r0, r1, r2, lr}
   3c730:	a904      	add	r1, sp, #16
   3c732:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   3c736:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
   3c738:	f7ea f8fc 	bl	26934 <vprintk>
}
   3c73c:	b003      	add	sp, #12
   3c73e:	f85d eb04 	ldr.w	lr, [sp], #4
   3c742:	b004      	add	sp, #16
   3c744:	4770      	bx	lr

0003c746 <sys_sem_give>:

	return 0;
}

int sys_sem_give(struct sys_sem *sem)
{
   3c746:	b508      	push	{r3, lr}
	z_impl_k_sem_give(sem);
   3c748:	f7fb f8fc 	bl	37944 <z_impl_k_sem_give>
	k_sem_give(&sem->kernel_sem);

	return 0;
}
   3c74c:	2000      	movs	r0, #0
   3c74e:	bd08      	pop	{r3, pc}

0003c750 <sys_sem_take>:

int sys_sem_take(struct sys_sem *sem, s32_t timeout)
{
   3c750:	b508      	push	{r3, lr}
	return z_impl_k_sem_take(sem, timeout);
   3c752:	f7fb f941 	bl	379d8 <z_impl_k_sem_take>
	int ret_value = 0;

	ret_value = k_sem_take(&sem->kernel_sem, timeout);
	if (ret_value == -EAGAIN || ret_value == -EBUSY) {
   3c756:	f110 0f0b 	cmn.w	r0, #11
   3c75a:	d005      	beq.n	3c768 <sys_sem_take+0x18>
   3c75c:	f110 0f10 	cmn.w	r0, #16
		ret_value = -ETIMEDOUT;
   3c760:	bf08      	it	eq
   3c762:	f06f 0073 	mvneq.w	r0, #115	; 0x73
	}

	return ret_value;
}
   3c766:	bd08      	pop	{r3, pc}
		ret_value = -ETIMEDOUT;
   3c768:	f06f 0073 	mvn.w	r0, #115	; 0x73
	return ret_value;
   3c76c:	e7fb      	b.n	3c766 <sys_sem_take+0x16>

0003c76e <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   3c76e:	4604      	mov	r4, r0
   3c770:	b508      	push	{r3, lr}
   3c772:	4608      	mov	r0, r1
   3c774:	4611      	mov	r1, r2
	entry(p1, p2, p3);
   3c776:	461a      	mov	r2, r3
   3c778:	47a0      	blx	r4
	return z_impl_k_current_get();
   3c77a:	f7fb f8dd 	bl	37938 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
   3c77e:	f7ec f979 	bl	28a74 <z_impl_k_thread_abort>

0003c782 <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
   3c782:	b510      	push	{r4, lr}
   3c784:	4604      	mov	r4, r0
	return z_impl_k_queue_get(queue, timeout);
   3c786:	f04f 31ff 	mov.w	r1, #4294967295
   3c78a:	4620      	mov	r0, r4
   3c78c:	f7f9 fe50 	bl	36430 <z_impl_k_queue_get>
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
   3c790:	4603      	mov	r3, r0
   3c792:	2800      	cmp	r0, #0
   3c794:	d0f7      	beq.n	3c786 <z_work_q_main+0x4>
			continue;
		}

		handler = work->handler;
   3c796:	6842      	ldr	r2, [r0, #4]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   3c798:	3308      	adds	r3, #8
   3c79a:	e8d3 1fef 	ldaex	r1, [r3]
   3c79e:	f021 0c01 	bic.w	ip, r1, #1
   3c7a2:	e8c3 cfee 	stlex	lr, ip, [r3]
   3c7a6:	f1be 0f00 	cmp.w	lr, #0
   3c7aa:	d1f6      	bne.n	3c79a <z_work_q_main+0x18>

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
   3c7ac:	07cb      	lsls	r3, r1, #31
   3c7ae:	d500      	bpl.n	3c7b2 <z_work_q_main+0x30>
					      K_WORK_STATE_PENDING)) {
			handler(work);
   3c7b0:	4790      	blx	r2
	z_impl_k_yield();
   3c7b2:	f7fa ff43 	bl	3763c <z_impl_k_yield>
   3c7b6:	e7e6      	b.n	3c786 <z_work_q_main+0x4>

0003c7b8 <assert_post_action>:
	if (_is_user_context()) {
		k_oops();
	}
#endif

	k_panic();
   3c7b8:	4040      	eors	r0, r0
   3c7ba:	f380 8811 	msr	BASEPRI, r0
   3c7be:	f04f 0004 	mov.w	r0, #4
   3c7c2:	df02      	svc	2
}
   3c7c4:	4770      	bx	lr

0003c7c6 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_BOOTLOADER_MCUBOOT, 1);
GEN_ABSOLUTE_SYM(CONFIG_REBOOT, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   3c7c6:	4770      	bx	lr

0003c7c8 <z_platform_init>:

void z_platform_init(void)
{
	SystemInit();
   3c7c8:	f7f8 b9a8 	b.w	34b1c <SystemInit>

0003c7cc <log_backend_is_active>:
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
   3c7cc:	6843      	ldr	r3, [r0, #4]
}
   3c7ce:	7958      	ldrb	r0, [r3, #5]
   3c7d0:	4770      	bx	lr

0003c7d2 <k_cycle_get_32_wrapper>:
   3c7d2:	f7eb bb03 	b.w	27ddc <z_timer_cycle_get_32>

0003c7d6 <dummy_timestamp>:
   3c7d6:	2000      	movs	r0, #0
   3c7d8:	4770      	bx	lr

0003c7da <log_string_sync>:
{
   3c7da:	b40e      	push	{r1, r2, r3}
   3c7dc:	b503      	push	{r0, r1, lr}
   3c7de:	aa03      	add	r2, sp, #12
   3c7e0:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(ap, fmt);
   3c7e4:	9201      	str	r2, [sp, #4]
	log_generic(src_level, fmt, ap);
   3c7e6:	f7ea f8d1 	bl	2698c <log_generic>
}
   3c7ea:	b002      	add	sp, #8
   3c7ec:	f85d eb04 	ldr.w	lr, [sp], #4
   3c7f0:	b003      	add	sp, #12
   3c7f2:	4770      	bx	lr

0003c7f4 <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
   3c7f4:	b508      	push	{r3, lr}
				K_THREAD_STACK_SIZEOF(logging_stack),
				log_process_thread_func, NULL, NULL, NULL,
				K_LOWEST_APPLICATION_THREAD_PRIO, 0, K_NO_WAIT);
		k_thread_name_set(&logging_thread, "logging");
	} else {
		log_init();
   3c7f6:	f7ea f93f 	bl	26a78 <log_init>
	}

	return 0;
}
   3c7fa:	2000      	movs	r0, #0
   3c7fc:	bd08      	pop	{r3, pc}

0003c7fe <log_strdup>:
}
   3c7fe:	4770      	bx	lr

0003c800 <out_func>:
{
   3c800:	b507      	push	{r0, r1, r2, lr}
		out_ctx->func((u8_t *)&c, 1, out_ctx->control_block->ctx);
   3c802:	e9d1 3200 	ldrd	r3, r2, [r1]
{
   3c806:	9001      	str	r0, [sp, #4]
		out_ctx->func((u8_t *)&c, 1, out_ctx->control_block->ctx);
   3c808:	6852      	ldr	r2, [r2, #4]
   3c80a:	2101      	movs	r1, #1
   3c80c:	a801      	add	r0, sp, #4
   3c80e:	4798      	blx	r3
}
   3c810:	2000      	movs	r0, #0
   3c812:	b003      	add	sp, #12
   3c814:	f85d fb04 	ldr.w	pc, [sp], #4

0003c818 <buffer_write>:
{
   3c818:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3c81a:	4606      	mov	r6, r0
   3c81c:	460d      	mov	r5, r1
   3c81e:	4614      	mov	r4, r2
   3c820:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
   3c822:	4621      	mov	r1, r4
   3c824:	4628      	mov	r0, r5
   3c826:	463a      	mov	r2, r7
   3c828:	47b0      	blx	r6
	} while (len != 0);
   3c82a:	1a24      	subs	r4, r4, r0
		buf += processed;
   3c82c:	4405      	add	r5, r0
	} while (len != 0);
   3c82e:	d1f8      	bne.n	3c822 <buffer_write+0xa>
}
   3c830:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0003c832 <log_output_flush>:
		     log_output->control_block->offset,
   3c832:	6842      	ldr	r2, [r0, #4]
{
   3c834:	b510      	push	{r4, lr}
	buffer_write(log_output->func, log_output->buf,
   3c836:	e9d2 2300 	ldrd	r2, r3, [r2]
{
   3c83a:	4604      	mov	r4, r0
	buffer_write(log_output->func, log_output->buf,
   3c83c:	6881      	ldr	r1, [r0, #8]
   3c83e:	6800      	ldr	r0, [r0, #0]
   3c840:	f7ff ffea 	bl	3c818 <buffer_write>
	log_output->control_block->offset = 0;
   3c844:	2200      	movs	r2, #0
   3c846:	6863      	ldr	r3, [r4, #4]
   3c848:	601a      	str	r2, [r3, #0]
}
   3c84a:	bd10      	pop	{r4, pc}

0003c84c <flash_write_protection_set>:
	return api->write_protection(dev, enable);
   3c84c:	6843      	ldr	r3, [r0, #4]
   3c84e:	68db      	ldr	r3, [r3, #12]
   3c850:	4718      	bx	r3

0003c852 <nvs_flash_rd>:
{
   3c852:	b470      	push	{r4, r5, r6}
	offset += addr & ADDR_OFFS_MASK;
   3c854:	6806      	ldr	r6, [r0, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   3c856:	8984      	ldrh	r4, [r0, #12]
   3c858:	0c0d      	lsrs	r5, r1, #16
	offset += addr & ADDR_OFFS_MASK;
   3c85a:	fa16 f181 	uxtah	r1, r6, r1
   3c85e:	fb05 1104 	mla	r1, r5, r4, r1
	rc = flash_read(fs->flash_device, offset, data, len);
   3c862:	6a80      	ldr	r0, [r0, #40]	; 0x28
	return api->read(dev, offset, data, len);
   3c864:	6844      	ldr	r4, [r0, #4]
   3c866:	6824      	ldr	r4, [r4, #0]
   3c868:	46a4      	mov	ip, r4
}
   3c86a:	bc70      	pop	{r4, r5, r6}
   3c86c:	4760      	bx	ip

0003c86e <nvs_flash_block_cmp>:
{
   3c86e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   3c872:	4681      	mov	r9, r0
   3c874:	460f      	mov	r7, r1
   3c876:	4690      	mov	r8, r2
   3c878:	461c      	mov	r4, r3
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   3c87a:	7c05      	ldrb	r5, [r0, #16]
{
   3c87c:	b089      	sub	sp, #36	; 0x24
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   3c87e:	426d      	negs	r5, r5
   3c880:	f005 0520 	and.w	r5, r5, #32
	while (len) {
   3c884:	b91c      	cbnz	r4, 3c88e <nvs_flash_block_cmp+0x20>
	return 0;
   3c886:	4620      	mov	r0, r4
}
   3c888:	b009      	add	sp, #36	; 0x24
   3c88a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		bytes_to_cmp = MIN(block_size, len);
   3c88e:	42ac      	cmp	r4, r5
   3c890:	4626      	mov	r6, r4
   3c892:	bf28      	it	cs
   3c894:	462e      	movcs	r6, r5
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_cmp);
   3c896:	466a      	mov	r2, sp
   3c898:	4633      	mov	r3, r6
   3c89a:	4639      	mov	r1, r7
   3c89c:	4648      	mov	r0, r9
   3c89e:	f7ff ffd8 	bl	3c852 <nvs_flash_rd>
		if (rc) {
   3c8a2:	2800      	cmp	r0, #0
   3c8a4:	d1f0      	bne.n	3c888 <nvs_flash_block_cmp+0x1a>
		rc = memcmp(data8, buf, bytes_to_cmp);
   3c8a6:	4632      	mov	r2, r6
   3c8a8:	4669      	mov	r1, sp
   3c8aa:	4640      	mov	r0, r8
   3c8ac:	f001 ffc0 	bl	3e830 <memcmp>
		if (rc) {
   3c8b0:	b918      	cbnz	r0, 3c8ba <nvs_flash_block_cmp+0x4c>
		len -= bytes_to_cmp;
   3c8b2:	1ba4      	subs	r4, r4, r6
		addr += bytes_to_cmp;
   3c8b4:	4437      	add	r7, r6
		data8 += bytes_to_cmp;
   3c8b6:	44b0      	add	r8, r6
   3c8b8:	e7e4      	b.n	3c884 <nvs_flash_block_cmp+0x16>
			return 1;
   3c8ba:	2001      	movs	r0, #1
   3c8bc:	e7e4      	b.n	3c888 <nvs_flash_block_cmp+0x1a>

0003c8be <nvs_ate_crc8_check>:
{
   3c8be:	b510      	push	{r4, lr}
   3c8c0:	4604      	mov	r4, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   3c8c2:	4601      	mov	r1, r0
   3c8c4:	2207      	movs	r2, #7
   3c8c6:	20ff      	movs	r0, #255	; 0xff
   3c8c8:	f7e9 fefc 	bl	266c4 <crc8_ccitt>
	if (crc8 == entry->crc8) {
   3c8cc:	79e3      	ldrb	r3, [r4, #7]
}
   3c8ce:	1a18      	subs	r0, r3, r0
   3c8d0:	bf18      	it	ne
   3c8d2:	2001      	movne	r0, #1
   3c8d4:	bd10      	pop	{r4, pc}

0003c8d6 <nvs_ate_crc8_update>:
{
   3c8d6:	b510      	push	{r4, lr}
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   3c8d8:	4601      	mov	r1, r0
{
   3c8da:	4604      	mov	r4, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   3c8dc:	2207      	movs	r2, #7
   3c8de:	20ff      	movs	r0, #255	; 0xff
   3c8e0:	f7e9 fef0 	bl	266c4 <crc8_ccitt>
	entry->crc8 = crc8;
   3c8e4:	71e0      	strb	r0, [r4, #7]
}
   3c8e6:	bd10      	pop	{r4, pc}

0003c8e8 <nvs_al_size.isra.1>:
	if (fs->write_block_size <= 1U) {
   3c8e8:	2801      	cmp	r0, #1
	return (len + (fs->write_block_size - 1U)) & ~(fs->write_block_size - 1U);
   3c8ea:	bf81      	itttt	hi
   3c8ec:	f100 33ff 	addhi.w	r3, r0, #4294967295
   3c8f0:	18c9      	addhi	r1, r1, r3
   3c8f2:	4240      	neghi	r0, r0
   3c8f4:	4001      	andhi	r1, r0
}
   3c8f6:	4608      	mov	r0, r1
   3c8f8:	4770      	bx	lr

0003c8fa <nvs_sector_advance.isra.2>:
	*addr += (1 << ADDR_SECT_SHIFT);
   3c8fa:	680b      	ldr	r3, [r1, #0]
   3c8fc:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
	if ((*addr >> ADDR_SECT_SHIFT) == fs->sector_count) {
   3c900:	0c1a      	lsrs	r2, r3, #16
   3c902:	4282      	cmp	r2, r0
		*addr -= (fs->sector_count << ADDR_SECT_SHIFT);
   3c904:	bf08      	it	eq
   3c906:	eba3 4302 	subeq.w	r3, r3, r2, lsl #16
   3c90a:	600b      	str	r3, [r1, #0]
}
   3c90c:	4770      	bx	lr

0003c90e <nvs_flash_cmp_const.constprop.5>:
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   3c90e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   3c912:	7c04      	ldrb	r4, [r0, #16]
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   3c914:	b088      	sub	sp, #32
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   3c916:	4264      	negs	r4, r4
   3c918:	f004 0420 	and.w	r4, r4, #32
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   3c91c:	4680      	mov	r8, r0
   3c91e:	460e      	mov	r6, r1
   3c920:	4615      	mov	r5, r2
	(void)memset(cmp, value, block_size);
   3c922:	2320      	movs	r3, #32
   3c924:	4622      	mov	r2, r4
   3c926:	21ff      	movs	r1, #255	; 0xff
   3c928:	4668      	mov	r0, sp
   3c92a:	f001 ffb7 	bl	3e89c <__memset_chk>
	while (len) {
   3c92e:	b91d      	cbnz	r5, 3c938 <nvs_flash_cmp_const.constprop.5+0x2a>
	return 0;
   3c930:	4628      	mov	r0, r5
}
   3c932:	b008      	add	sp, #32
   3c934:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		bytes_to_cmp = MIN(block_size, len);
   3c938:	42ac      	cmp	r4, r5
   3c93a:	4627      	mov	r7, r4
   3c93c:	bf28      	it	cs
   3c93e:	462f      	movcs	r7, r5
		rc = nvs_flash_block_cmp(fs, addr, cmp, bytes_to_cmp);
   3c940:	466a      	mov	r2, sp
   3c942:	463b      	mov	r3, r7
   3c944:	4631      	mov	r1, r6
   3c946:	4640      	mov	r0, r8
   3c948:	f7ff ff91 	bl	3c86e <nvs_flash_block_cmp>
		if (rc) {
   3c94c:	2800      	cmp	r0, #0
   3c94e:	d1f0      	bne.n	3c932 <nvs_flash_cmp_const.constprop.5+0x24>
		len -= bytes_to_cmp;
   3c950:	1bed      	subs	r5, r5, r7
		addr += bytes_to_cmp;
   3c952:	443e      	add	r6, r7
   3c954:	e7eb      	b.n	3c92e <nvs_flash_cmp_const.constprop.5+0x20>

0003c956 <nvs_flash_al_wrt.part.3>:
static int nvs_flash_al_wrt(struct nvs_fs *fs, u32_t addr, const void *data,
   3c956:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   3c95a:	4607      	mov	r7, r0
   3c95c:	b088      	sub	sp, #32
   3c95e:	460d      	mov	r5, r1
	offset = fs->offset;
   3c960:	f8d0 a000 	ldr.w	sl, [r0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   3c964:	8986      	ldrh	r6, [r0, #12]
	rc = flash_write_protection_set(fs->flash_device, 0);
   3c966:	2100      	movs	r1, #0
   3c968:	6a80      	ldr	r0, [r0, #40]	; 0x28
static int nvs_flash_al_wrt(struct nvs_fs *fs, u32_t addr, const void *data,
   3c96a:	4690      	mov	r8, r2
   3c96c:	461c      	mov	r4, r3
	rc = flash_write_protection_set(fs->flash_device, 0);
   3c96e:	f7ff ff6d 	bl	3c84c <flash_write_protection_set>
	if (rc) {
   3c972:	bb88      	cbnz	r0, 3c9d8 <nvs_flash_al_wrt.part.3+0x82>
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   3c974:	ea4f 4915 	mov.w	r9, r5, lsr #16
	offset += addr & ADDR_OFFS_MASK;
   3c978:	fa1a f585 	uxtah	r5, sl, r5
   3c97c:	fb06 5909 	mla	r9, r6, r9, r5
	blen = len & ~(fs->write_block_size - 1U);
   3c980:	7c3d      	ldrb	r5, [r7, #16]
   3c982:	426d      	negs	r5, r5
	if (blen > 0) {
   3c984:	4025      	ands	r5, r4
   3c986:	d00b      	beq.n	3c9a0 <nvs_flash_al_wrt.part.3+0x4a>
   3c988:	6ab8      	ldr	r0, [r7, #40]	; 0x28
	return api->write(dev, offset, data, len);
   3c98a:	6843      	ldr	r3, [r0, #4]
   3c98c:	4642      	mov	r2, r8
   3c98e:	685e      	ldr	r6, [r3, #4]
   3c990:	4649      	mov	r1, r9
   3c992:	462b      	mov	r3, r5
   3c994:	47b0      	blx	r6
		if (rc) {
   3c996:	4606      	mov	r6, r0
   3c998:	b9c8      	cbnz	r0, 3c9ce <nvs_flash_al_wrt.part.3+0x78>
		len -= blen;
   3c99a:	1b64      	subs	r4, r4, r5
		offset += blen;
   3c99c:	44a9      	add	r9, r5
		data8 += blen;
   3c99e:	44a8      	add	r8, r5
	if (len) {
   3c9a0:	b1ec      	cbz	r4, 3c9de <nvs_flash_al_wrt.part.3+0x88>
		memcpy(buf, data8, len);
   3c9a2:	2320      	movs	r3, #32
   3c9a4:	4622      	mov	r2, r4
   3c9a6:	4641      	mov	r1, r8
   3c9a8:	4668      	mov	r0, sp
   3c9aa:	6abd      	ldr	r5, [r7, #40]	; 0x28
   3c9ac:	f001 ff5b 	bl	3e866 <__memcpy_chk>
		(void)memset(buf + len, 0xff, fs->write_block_size - len);
   3c9b0:	7c3e      	ldrb	r6, [r7, #16]
__ssp_bos_icheck3(memset, void *, int)
   3c9b2:	21ff      	movs	r1, #255	; 0xff
   3c9b4:	1b32      	subs	r2, r6, r4
   3c9b6:	eb0d 0004 	add.w	r0, sp, r4
   3c9ba:	f001 ff67 	bl	3e88c <memset>
   3c9be:	686b      	ldr	r3, [r5, #4]
   3c9c0:	466a      	mov	r2, sp
   3c9c2:	685c      	ldr	r4, [r3, #4]
   3c9c4:	4649      	mov	r1, r9
   3c9c6:	4633      	mov	r3, r6
   3c9c8:	4628      	mov	r0, r5
   3c9ca:	47a0      	blx	r4
   3c9cc:	4606      	mov	r6, r0
	(void) flash_write_protection_set(fs->flash_device, 1);
   3c9ce:	2101      	movs	r1, #1
   3c9d0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   3c9d2:	f7ff ff3b 	bl	3c84c <flash_write_protection_set>
	return rc;
   3c9d6:	4630      	mov	r0, r6
}
   3c9d8:	b008      	add	sp, #32
   3c9da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
   3c9de:	4626      	mov	r6, r4
   3c9e0:	e7f5      	b.n	3c9ce <nvs_flash_al_wrt.part.3+0x78>

0003c9e2 <nvs_flash_ate_wrt>:
{
   3c9e2:	b510      	push	{r4, lr}
   3c9e4:	2308      	movs	r3, #8
   3c9e6:	460a      	mov	r2, r1
   3c9e8:	6841      	ldr	r1, [r0, #4]
   3c9ea:	4604      	mov	r4, r0
   3c9ec:	f7ff ffb3 	bl	3c956 <nvs_flash_al_wrt.part.3>
	fs->ate_wra -= nvs_al_size(fs, sizeof(struct nvs_ate));
   3c9f0:	2108      	movs	r1, #8
   3c9f2:	4602      	mov	r2, r0
   3c9f4:	7c20      	ldrb	r0, [r4, #16]
   3c9f6:	f7ff ff77 	bl	3c8e8 <nvs_al_size.isra.1>
   3c9fa:	6863      	ldr	r3, [r4, #4]
   3c9fc:	1a18      	subs	r0, r3, r0
   3c9fe:	6060      	str	r0, [r4, #4]
}
   3ca00:	4610      	mov	r0, r2
   3ca02:	bd10      	pop	{r4, pc}

0003ca04 <nvs_read>:

ssize_t nvs_read(struct nvs_fs *fs, u16_t id, void *data, size_t len)
{
   3ca04:	b513      	push	{r0, r1, r4, lr}
	int rc;

	rc = nvs_read_hist(fs, id, data, len, 0);
   3ca06:	2400      	movs	r4, #0
   3ca08:	9400      	str	r4, [sp, #0]
   3ca0a:	f7ea fe71 	bl	276f0 <nvs_read_hist>
	return rc;
}
   3ca0e:	b002      	add	sp, #8
   3ca10:	bd10      	pop	{r4, pc}

0003ca12 <clkstarted_handle>:
{
   3ca12:	b538      	push	{r3, r4, r5, lr}
	sub_data->started = true;
   3ca14:	240c      	movs	r4, #12
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
   3ca16:	6883      	ldr	r3, [r0, #8]
{
   3ca18:	4605      	mov	r5, r0
	sub_data->started = true;
   3ca1a:	fb04 3401 	mla	r4, r4, r1, r3
   3ca1e:	2301      	movs	r3, #1
   3ca20:	7263      	strb	r3, [r4, #9]
	__asm__ volatile(
   3ca22:	f04f 0320 	mov.w	r3, #32
   3ca26:	f3ef 8111 	mrs	r1, BASEPRI
   3ca2a:	f383 8811 	msr	BASEPRI, r3
   3ca2e:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
   3ca32:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_GET(slist, snode)
   3ca34:	b12b      	cbz	r3, 3ca42 <clkstarted_handle+0x30>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   3ca36:	6860      	ldr	r0, [r4, #4]
   3ca38:	681a      	ldr	r2, [r3, #0]
   3ca3a:	4283      	cmp	r3, r0
	list->head = node;
   3ca3c:	6022      	str	r2, [r4, #0]
	list->tail = node;
   3ca3e:	bf08      	it	eq
   3ca40:	6062      	streq	r2, [r4, #4]
	__asm__ volatile(
   3ca42:	f381 8811 	msr	BASEPRI, r1
   3ca46:	f3bf 8f6f 	isb	sy
	while ((async_data = list_get(&sub_data->list)) != NULL) {
   3ca4a:	b903      	cbnz	r3, 3ca4e <clkstarted_handle+0x3c>
}
   3ca4c:	bd38      	pop	{r3, r4, r5, pc}
		async_data->cb(dev, async_data->user_data);
   3ca4e:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
   3ca52:	4628      	mov	r0, r5
   3ca54:	4790      	blx	r2
   3ca56:	e7e4      	b.n	3ca22 <clkstarted_handle+0x10>

0003ca58 <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
   3ca58:	2200      	movs	r2, #0
   3ca5a:	f7ea bf15 	b.w	27888 <clock_async_start>

0003ca5e <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
   3ca5e:	4770      	bx	lr

0003ca60 <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
   3ca60:	f7eb ba0e 	b.w	27e80 <_DoInit>

0003ca64 <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(struct device *unused)
{
   3ca64:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
   3ca66:	f7ff fffb 	bl	3ca60 <SEGGER_RTT_Init>

	return 0;
}
   3ca6a:	2000      	movs	r0, #0
   3ca6c:	bd08      	pop	{r3, pc}

0003ca6e <z_irq_spurious>:
	z_arm_reserved();
   3ca6e:	f7eb bb19 	b.w	280a4 <z_arm_bus_fault>

0003ca72 <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   3ca72:	6d83      	ldr	r3, [r0, #88]	; 0x58
   3ca74:	f383 880b 	msr	PSPLIM, r3
}
   3ca78:	4770      	bx	lr

0003ca7a <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   3ca7a:	4601      	mov	r1, r0
			reason = K_ERR_KERNEL_OOPS;
		}
	}

#endif /* CONFIG_USERSPACE */
	z_arm_fatal_error(reason, esf);
   3ca7c:	6800      	ldr	r0, [r0, #0]
   3ca7e:	f7eb bc27 	b.w	282d0 <z_arm_fatal_error>

0003ca82 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   3ca82:	b508      	push	{r3, lr}
	handler();
   3ca84:	f7eb fb18 	bl	280b8 <z_SysNmiOnReset>
	z_arm_exc_exit();
}
   3ca88:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_exc_exit();
   3ca8c:	f7eb ba7e 	b.w	27f8c <z_arm_exc_exit>

0003ca90 <z_arm_configure_dynamic_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_dynamic_mpu_regions(struct k_thread *thread)
{
   3ca90:	b507      	push	{r0, r1, r2, lr}

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(
   3ca92:	2100      	movs	r1, #0
   3ca94:	a801      	add	r0, sp, #4
   3ca96:	f7ec fa4b 	bl	28f30 <arm_core_mpu_configure_dynamic_mpu_regions>
		(const struct k_mem_partition **)dynamic_regions,
		region_num);
}
   3ca9a:	b003      	add	sp, #12
   3ca9c:	f85d fb04 	ldr.w	pc, [sp], #4

0003caa0 <mpu_configure_region>:
{
   3caa0:	b530      	push	{r4, r5, lr}
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
   3caa2:	684b      	ldr	r3, [r1, #4]
{
   3caa4:	b085      	sub	sp, #20
	region_conf.base = new_region->start;
   3caa6:	680c      	ldr	r4, [r1, #0]
	p_attr->rbar = attr->rbar &
   3caa8:	f89d 2008 	ldrb.w	r2, [sp, #8]
   3caac:	890d      	ldrh	r5, [r1, #8]
   3caae:	9400      	str	r4, [sp, #0]
	p_attr->mair_idx = attr->mair_idx;
   3cab0:	8949      	ldrh	r1, [r1, #10]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   3cab2:	f024 041f 	bic.w	r4, r4, #31
   3cab6:	3b01      	subs	r3, #1
	p_attr->rbar = attr->rbar &
   3cab8:	f365 0204 	bfi	r2, r5, #0, #5
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   3cabc:	4423      	add	r3, r4
	p_attr->mair_idx = attr->mair_idx;
   3cabe:	f361 1247 	bfi	r2, r1, #5, #3
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   3cac2:	f023 031f 	bic.w	r3, r3, #31
	return region_allocate_and_init(index,
   3cac6:	4669      	mov	r1, sp
	p_attr->mair_idx = attr->mair_idx;
   3cac8:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   3cacc:	9303      	str	r3, [sp, #12]
   3cace:	f7ec f851 	bl	28b74 <region_allocate_and_init>
}
   3cad2:	b005      	add	sp, #20
   3cad4:	bd30      	pop	{r4, r5, pc}

0003cad6 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   3cad6:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(u32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
   3cada:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   3cade:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
   3cae0:	bf08      	it	eq
   3cae2:	f06f 0015 	mvneq.w	r0, #21
   3cae6:	4770      	bx	lr

0003cae8 <_stdout_hook_default>:
}
   3cae8:	f04f 30ff 	mov.w	r0, #4294967295
   3caec:	4770      	bx	lr

0003caee <_stdin_hook_default>:
}
   3caee:	2000      	movs	r0, #0
   3caf0:	4770      	bx	lr

0003caf2 <_read>:
{
   3caf2:	4608      	mov	r0, r1
	return z_impl_zephyr_read_stdin(buf, nbytes);
   3caf4:	4611      	mov	r1, r2
   3caf6:	f7ec ba57 	b.w	28fa8 <z_impl_zephyr_read_stdin>

0003cafa <_write>:
{
   3cafa:	4608      	mov	r0, r1
	return z_impl_zephyr_write_stdout(buf, nbytes);
   3cafc:	4611      	mov	r1, r2
   3cafe:	f7ec ba67 	b.w	28fd0 <z_impl_zephyr_write_stdout>

0003cb02 <_close>:
   3cb02:	f04f 30ff 	mov.w	r0, #4294967295
   3cb06:	4770      	bx	lr

0003cb08 <_lseek>:
}
   3cb08:	2000      	movs	r0, #0
   3cb0a:	4770      	bx	lr

0003cb0c <_isatty>:
}
   3cb0c:	2001      	movs	r0, #1
   3cb0e:	4770      	bx	lr

0003cb10 <_kill>:
}
   3cb10:	2000      	movs	r0, #0
   3cb12:	4770      	bx	lr

0003cb14 <_getpid>:
}
   3cb14:	2000      	movs	r0, #0
   3cb16:	4770      	bx	lr

0003cb18 <_fstat>:
	st->st_mode = S_IFCHR;
   3cb18:	f44f 5300 	mov.w	r3, #8192	; 0x2000
}
   3cb1c:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
   3cb1e:	604b      	str	r3, [r1, #4]
}
   3cb20:	4770      	bx	lr

0003cb22 <__errno>:
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
   3cb22:	f7f8 bda3 	b.w	3566c <z_impl_z_errno>

0003cb26 <net_init>:

	return status;
}

static int net_init(struct device *unused)
{
   3cb26:	b508      	push	{r3, lr}
	net_if_init();
   3cb28:	f7ec fb1a 	bl	29160 <net_if_init>
	net_if_post_init();
   3cb2c:	f7ec fb2c 	bl	29188 <net_if_post_init>
	net_mgmt_event_init();

	init_rx_queues();

	return services_init();
}
   3cb30:	2000      	movs	r0, #0
   3cb32:	bd08      	pop	{r3, pc}

0003cb34 <net_if_l2>:
	if (!iface || !iface->if_dev) {
   3cb34:	b110      	cbz	r0, 3cb3c <net_if_l2+0x8>
   3cb36:	6800      	ldr	r0, [r0, #0]
   3cb38:	b100      	cbz	r0, 3cb3c <net_if_l2+0x8>
	return iface->if_dev->l2;
   3cb3a:	6840      	ldr	r0, [r0, #4]
}
   3cb3c:	4770      	bx	lr

0003cb3e <l2_flags_get>:
{
   3cb3e:	b510      	push	{r4, lr}
   3cb40:	4602      	mov	r2, r0
	if (net_if_l2(iface) && net_if_l2(iface)->get_flags) {
   3cb42:	f7ff fff7 	bl	3cb34 <net_if_l2>
   3cb46:	b128      	cbz	r0, 3cb54 <l2_flags_get+0x16>
   3cb48:	68c3      	ldr	r3, [r0, #12]
   3cb4a:	b11b      	cbz	r3, 3cb54 <l2_flags_get+0x16>
}
   3cb4c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		flags = net_if_l2(iface)->get_flags(iface);
   3cb50:	4610      	mov	r0, r2
   3cb52:	4718      	bx	r3
}
   3cb54:	2000      	movs	r0, #0
   3cb56:	bd10      	pop	{r4, pc}

0003cb58 <net_byte_to_hex>:
{
   3cb58:	b570      	push	{r4, r5, r6, lr}
	for (i = 0, val = (byte & 0xf0) >> 4; i < 2; i++, val = byte & 0x0f) {
   3cb5a:	090e      	lsrs	r6, r1, #4
		if (i == 0 && !pad && !val) {
   3cb5c:	b1b3      	cbz	r3, 3cb8c <net_byte_to_hex+0x34>
		if (val < 10) {
   3cb5e:	2e09      	cmp	r6, #9
			*ptr++ = (char) (val - 10 + base);
   3cb60:	b274      	sxtb	r4, r6
   3cb62:	bf86      	itte	hi
   3cb64:	f1a2 030a 	subhi.w	r3, r2, #10
   3cb68:	18e4      	addhi	r4, r4, r3
			*ptr++ = (char) (val + '0');
   3cb6a:	3430      	addls	r4, #48	; 0x30
   3cb6c:	1c45      	adds	r5, r0, #1
   3cb6e:	7004      	strb	r4, [r0, #0]
   3cb70:	f001 010f 	and.w	r1, r1, #15
		if (val < 10) {
   3cb74:	2909      	cmp	r1, #9
			*ptr++ = (char) (val - 10 + base);
   3cb76:	b24b      	sxtb	r3, r1
   3cb78:	bf83      	ittte	hi
   3cb7a:	3a0a      	subhi	r2, #10
   3cb7c:	189b      	addhi	r3, r3, r2
   3cb7e:	b2db      	uxtbhi	r3, r3
			*ptr++ = (char) (val + '0');
   3cb80:	3330      	addls	r3, #48	; 0x30
   3cb82:	702b      	strb	r3, [r5, #0]
	*ptr = '\0';
   3cb84:	2300      	movs	r3, #0
   3cb86:	706b      	strb	r3, [r5, #1]
   3cb88:	1c68      	adds	r0, r5, #1
}
   3cb8a:	bd70      	pop	{r4, r5, r6, pc}
		if (i == 0 && !pad && !val) {
   3cb8c:	2e00      	cmp	r6, #0
   3cb8e:	d1e6      	bne.n	3cb5e <net_byte_to_hex+0x6>
   3cb90:	4605      	mov	r5, r0
   3cb92:	e7ed      	b.n	3cb70 <net_byte_to_hex+0x18>

0003cb94 <unpack_uint16>:
 */
static int unpack_uint16(struct buf_ctx *buf, u16_t *val)
{
	MQTT_TRC(">> cur:%p, end:%p", buf->cur, buf->end);

	if ((buf->end - buf->cur) < sizeof(u16_t)) {
   3cb94:	e9d0 2300 	ldrd	r2, r3, [r0]
   3cb98:	1a9b      	subs	r3, r3, r2
   3cb9a:	2b01      	cmp	r3, #1
{
   3cb9c:	b510      	push	{r4, lr}
	if ((buf->end - buf->cur) < sizeof(u16_t)) {
   3cb9e:	d90c      	bls.n	3cbba <unpack_uint16+0x26>
		return -EINVAL;
	}

	*val = *(buf->cur++) << 8; /* MSB */
   3cba0:	4614      	mov	r4, r2
   3cba2:	1c53      	adds	r3, r2, #1
   3cba4:	6003      	str	r3, [r0, #0]
   3cba6:	f814 3b02 	ldrb.w	r3, [r4], #2
   3cbaa:	021b      	lsls	r3, r3, #8
   3cbac:	800b      	strh	r3, [r1, #0]
	*val |= *(buf->cur++); /* LSB */
   3cbae:	6004      	str	r4, [r0, #0]

	MQTT_TRC("<< val:%04x", *val);

	return 0;
   3cbb0:	2000      	movs	r0, #0
	*val |= *(buf->cur++); /* LSB */
   3cbb2:	7852      	ldrb	r2, [r2, #1]
   3cbb4:	4313      	orrs	r3, r2
   3cbb6:	800b      	strh	r3, [r1, #0]
}
   3cbb8:	bd10      	pop	{r4, pc}
		return -EINVAL;
   3cbba:	f06f 0015 	mvn.w	r0, #21
   3cbbe:	e7fb      	b.n	3cbb8 <unpack_uint16+0x24>

0003cbc0 <packet_length_decode>:
int packet_length_decode(struct buf_ctx *buf, u32_t *length)
{
	u8_t shift = 0U;
	u8_t bytes = 0U;

	*length = 0U;
   3cbc0:	2300      	movs	r3, #0
{
   3cbc2:	b5f0      	push	{r4, r5, r6, r7, lr}
	do {
		if (bytes > MQTT_MAX_LENGTH_BYTES) {
			return -EINVAL;
		}

		if (buf->cur >= buf->end) {
   3cbc4:	6847      	ldr	r7, [r0, #4]
	*length = 0U;
   3cbc6:	600b      	str	r3, [r1, #0]
		if (buf->cur >= buf->end) {
   3cbc8:	6804      	ldr	r4, [r0, #0]
   3cbca:	42bc      	cmp	r4, r7
   3cbcc:	d215      	bcs.n	3cbfa <packet_length_decode+0x3a>
			return -EAGAIN;
		}

		*length += ((u32_t)*(buf->cur) & MQTT_LENGTH_VALUE_MASK)
   3cbce:	4625      	mov	r5, r4
   3cbd0:	f815 2b01 	ldrb.w	r2, [r5], #1
   3cbd4:	680e      	ldr	r6, [r1, #0]
   3cbd6:	f002 027f 	and.w	r2, r2, #127	; 0x7f
								<< shift;
   3cbda:	409a      	lsls	r2, r3
		*length += ((u32_t)*(buf->cur) & MQTT_LENGTH_VALUE_MASK)
   3cbdc:	4432      	add	r2, r6
   3cbde:	600a      	str	r2, [r1, #0]
		shift += MQTT_LENGTH_SHIFT;
		bytes++;
	} while ((*(buf->cur++) & MQTT_LENGTH_CONTINUATION_BIT) != 0U);
   3cbe0:	6005      	str	r5, [r0, #0]
   3cbe2:	f994 2000 	ldrsb.w	r2, [r4]
   3cbe6:	2a00      	cmp	r2, #0
   3cbe8:	db01      	blt.n	3cbee <packet_length_decode+0x2e>

	MQTT_TRC("length:0x%08x", *length);

	return 0;
   3cbea:	2000      	movs	r0, #0
}
   3cbec:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (bytes > MQTT_MAX_LENGTH_BYTES) {
   3cbee:	3307      	adds	r3, #7
   3cbf0:	2b23      	cmp	r3, #35	; 0x23
   3cbf2:	d1e9      	bne.n	3cbc8 <packet_length_decode+0x8>
			return -EINVAL;
   3cbf4:	f06f 0015 	mvn.w	r0, #21
   3cbf8:	e7f8      	b.n	3cbec <packet_length_decode+0x2c>
			return -EAGAIN;
   3cbfa:	f06f 000a 	mvn.w	r0, #10
   3cbfe:	e7f5      	b.n	3cbec <packet_length_decode+0x2c>

0003cc00 <fixed_header_decode>:

int fixed_header_decode(struct buf_ctx *buf, u8_t *type_and_flags,
			u32_t *length)
{
   3cc00:	b430      	push	{r4, r5}
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   3cc02:	e9d0 3500 	ldrd	r3, r5, [r0]
   3cc06:	429d      	cmp	r5, r3
   3cc08:	d007      	beq.n	3cc1a <fixed_header_decode+0x1a>
	*val = *(buf->cur++);
   3cc0a:	1c5d      	adds	r5, r3, #1
   3cc0c:	6005      	str	r5, [r0, #0]
   3cc0e:	781b      	ldrb	r3, [r3, #0]
   3cc10:	700b      	strb	r3, [r1, #0]
	if (err_code != 0) {
		return err_code;
	}

	return packet_length_decode(buf, length);
}
   3cc12:	bc30      	pop	{r4, r5}
	return packet_length_decode(buf, length);
   3cc14:	4611      	mov	r1, r2
   3cc16:	f7ff bfd3 	b.w	3cbc0 <packet_length_decode>
}
   3cc1a:	f06f 0015 	mvn.w	r0, #21
   3cc1e:	bc30      	pop	{r4, r5}
   3cc20:	4770      	bx	lr

0003cc22 <connect_ack_decode>:

int connect_ack_decode(const struct mqtt_client *client, struct buf_ctx *buf,
		       struct mqtt_connack_param *param)
{
   3cc22:	b530      	push	{r4, r5, lr}
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   3cc24:	e9d1 3500 	ldrd	r3, r5, [r1]
   3cc28:	429d      	cmp	r5, r3
   3cc2a:	d102      	bne.n	3cc32 <connect_ack_decode+0x10>
		return -EINVAL;
   3cc2c:	f06f 0015 	mvn.w	r0, #21
	}

	param->return_code = (enum mqtt_conn_return_code)ret_code;

	return 0;
}
   3cc30:	bd30      	pop	{r4, r5, pc}
	*val = *(buf->cur++);
   3cc32:	1c5c      	adds	r4, r3, #1
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   3cc34:	42a5      	cmp	r5, r4
	*val = *(buf->cur++);
   3cc36:	600c      	str	r4, [r1, #0]
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   3cc38:	d0f8      	beq.n	3cc2c <connect_ack_decode+0xa>
	*val = *(buf->cur++);
   3cc3a:	461d      	mov	r5, r3
   3cc3c:	f815 4b02 	ldrb.w	r4, [r5], #2
   3cc40:	600d      	str	r5, [r1, #0]
	if (client->protocol_version == MQTT_VERSION_3_1_1) {
   3cc42:	f890 1076 	ldrb.w	r1, [r0, #118]	; 0x76
	*val = *(buf->cur++);
   3cc46:	785b      	ldrb	r3, [r3, #1]
	if (client->protocol_version == MQTT_VERSION_3_1_1) {
   3cc48:	2904      	cmp	r1, #4
			flags & MQTT_CONNACK_FLAG_SESSION_PRESENT;
   3cc4a:	bf04      	itt	eq
   3cc4c:	f004 0401 	andeq.w	r4, r4, #1
		param->session_present_flag =
   3cc50:	7014      	strbeq	r4, [r2, #0]
	param->return_code = (enum mqtt_conn_return_code)ret_code;
   3cc52:	7053      	strb	r3, [r2, #1]
	return 0;
   3cc54:	2000      	movs	r0, #0
   3cc56:	e7eb      	b.n	3cc30 <connect_ack_decode+0xe>

0003cc58 <publish_decode>:

int publish_decode(u8_t flags, u32_t var_length, struct buf_ctx *buf,
		   struct mqtt_publish_param *param)
{
   3cc58:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   3cc5c:	461c      	mov	r4, r3
	int err_code;
	u32_t var_header_length;

	param->dup_flag = flags & MQTT_HEADER_DUP_MASK;
   3cc5e:	7d9b      	ldrb	r3, [r3, #22]
{
   3cc60:	4688      	mov	r8, r1
	param->retain_flag = flags & MQTT_HEADER_RETAIN_MASK;
   3cc62:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
   3cc66:	f360 0341 	bfi	r3, r0, #1, #1
	param->message.topic.qos = ((flags & MQTT_HEADER_QOS_MASK) >> 1);
   3cc6a:	f3c0 0041 	ubfx	r0, r0, #1, #2
   3cc6e:	7220      	strb	r0, [r4, #8]
	param->retain_flag = flags & MQTT_HEADER_RETAIN_MASK;
   3cc70:	75a3      	strb	r3, [r4, #22]
	err_code = unpack_uint16(buf, &utf8_strlen);
   3cc72:	f10d 0106 	add.w	r1, sp, #6
   3cc76:	4610      	mov	r0, r2
{
   3cc78:	4616      	mov	r6, r2
	err_code = unpack_uint16(buf, &utf8_strlen);
   3cc7a:	f7ff ff8b 	bl	3cb94 <unpack_uint16>
	if (err_code != 0) {
   3cc7e:	4607      	mov	r7, r0
   3cc80:	b940      	cbnz	r0, 3cc94 <publish_decode+0x3c>
	if ((buf->end - buf->cur) < utf8_strlen) {
   3cc82:	6833      	ldr	r3, [r6, #0]
   3cc84:	6872      	ldr	r2, [r6, #4]
   3cc86:	f8bd 5006 	ldrh.w	r5, [sp, #6]
   3cc8a:	1ad2      	subs	r2, r2, r3
   3cc8c:	42aa      	cmp	r2, r5
   3cc8e:	da05      	bge.n	3cc9c <publish_decode+0x44>
		return -EINVAL;
   3cc90:	f06f 0715 	mvn.w	r7, #21

	param->message.payload.data = NULL;
	param->message.payload.len = var_length - var_header_length;

	return 0;
}
   3cc94:	4638      	mov	r0, r7
   3cc96:	b002      	add	sp, #8
   3cc98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	str->size = utf8_strlen;
   3cc9c:	6065      	str	r5, [r4, #4]
	if (utf8_strlen) {
   3cc9e:	b15d      	cbz	r5, 3ccb8 <publish_decode+0x60>
		str->utf8 = buf->cur;
   3cca0:	6023      	str	r3, [r4, #0]
		buf->cur += utf8_strlen;
   3cca2:	442b      	add	r3, r5
   3cca4:	6033      	str	r3, [r6, #0]
	if (param->message.topic.qos > MQTT_QOS_0_AT_MOST_ONCE) {
   3cca6:	7a23      	ldrb	r3, [r4, #8]
   3cca8:	b943      	cbnz	r3, 3ccbc <publish_decode+0x64>
	var_header_length = param->message.topic.topic.size + sizeof(u16_t);
   3ccaa:	3502      	adds	r5, #2
	param->message.payload.data = NULL;
   3ccac:	2300      	movs	r3, #0
	param->message.payload.len = var_length - var_header_length;
   3ccae:	eba8 0505 	sub.w	r5, r8, r5
	param->message.payload.data = NULL;
   3ccb2:	60e3      	str	r3, [r4, #12]
	param->message.payload.len = var_length - var_header_length;
   3ccb4:	6125      	str	r5, [r4, #16]
	return 0;
   3ccb6:	e7ed      	b.n	3cc94 <publish_decode+0x3c>
		str->utf8 = NULL;
   3ccb8:	6025      	str	r5, [r4, #0]
	if (err_code != 0) {
   3ccba:	e7f4      	b.n	3cca6 <publish_decode+0x4e>
		err_code = unpack_uint16(buf, &param->message_id);
   3ccbc:	f104 0114 	add.w	r1, r4, #20
   3ccc0:	4630      	mov	r0, r6
   3ccc2:	f7ff ff67 	bl	3cb94 <unpack_uint16>
		if (err_code != 0) {
   3ccc6:	b908      	cbnz	r0, 3cccc <publish_decode+0x74>
		var_header_length += sizeof(u16_t);
   3ccc8:	3504      	adds	r5, #4
   3ccca:	e7ef      	b.n	3ccac <publish_decode+0x54>
   3cccc:	4607      	mov	r7, r0
   3ccce:	e7e1      	b.n	3cc94 <publish_decode+0x3c>

0003ccd0 <publish_ack_decode>:

int publish_ack_decode(struct buf_ctx *buf, struct mqtt_puback_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   3ccd0:	f7ff bf60 	b.w	3cb94 <unpack_uint16>

0003ccd4 <publish_receive_decode>:
}

int publish_receive_decode(struct buf_ctx *buf, struct mqtt_pubrec_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   3ccd4:	f7ff bf5e 	b.w	3cb94 <unpack_uint16>

0003ccd8 <publish_release_decode>:
}

int publish_release_decode(struct buf_ctx *buf, struct mqtt_pubrel_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   3ccd8:	f7ff bf5c 	b.w	3cb94 <unpack_uint16>

0003ccdc <publish_complete_decode>:
}

int publish_complete_decode(struct buf_ctx *buf,
			    struct mqtt_pubcomp_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   3ccdc:	f7ff bf5a 	b.w	3cb94 <unpack_uint16>

0003cce0 <subscribe_ack_decode>:
}

int subscribe_ack_decode(struct buf_ctx *buf, struct mqtt_suback_param *param)
{
   3cce0:	b538      	push	{r3, r4, r5, lr}
   3cce2:	4605      	mov	r5, r0
   3cce4:	460c      	mov	r4, r1
	int err_code;

	err_code = unpack_uint16(buf, &param->message_id);
   3cce6:	f7ff ff55 	bl	3cb94 <unpack_uint16>
	if (err_code != 0) {
   3ccea:	b930      	cbnz	r0, 3ccfa <subscribe_ack_decode+0x1a>
		return err_code;
	}

	return unpack_data(buf->end - buf->cur, buf, &param->return_codes);
   3ccec:	e9d5 2300 	ldrd	r2, r3, [r5]
   3ccf0:	1a99      	subs	r1, r3, r2
	str->len = length;
   3ccf2:	60a1      	str	r1, [r4, #8]
	if (length > 0) {
   3ccf4:	b111      	cbz	r1, 3ccfc <subscribe_ack_decode+0x1c>
		str->data = buf->cur;
   3ccf6:	6062      	str	r2, [r4, #4]
		buf->cur += length;
   3ccf8:	602b      	str	r3, [r5, #0]
}
   3ccfa:	bd38      	pop	{r3, r4, r5, pc}
		str->data = NULL;
   3ccfc:	6060      	str	r0, [r4, #4]
   3ccfe:	e7fc      	b.n	3ccfa <subscribe_ack_decode+0x1a>

0003cd00 <unsubscribe_ack_decode>:

int unsubscribe_ack_decode(struct buf_ctx *buf,
			   struct mqtt_unsuback_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   3cd00:	f7ff bf48 	b.w	3cb94 <unpack_uint16>

0003cd04 <pack_uint16>:
	if ((buf->end - buf->cur) < sizeof(u16_t)) {
   3cd04:	e9d1 3200 	ldrd	r3, r2, [r1]
   3cd08:	1ad2      	subs	r2, r2, r3
   3cd0a:	2a01      	cmp	r2, #1
   3cd0c:	d909      	bls.n	3cd22 <pack_uint16+0x1e>
	*(buf->cur++) = (val >> 8) & 0xFF;
   3cd0e:	1c5a      	adds	r2, r3, #1
   3cd10:	600a      	str	r2, [r1, #0]
   3cd12:	0a02      	lsrs	r2, r0, #8
   3cd14:	701a      	strb	r2, [r3, #0]
	*(buf->cur++) = val & 0xFF;
   3cd16:	680b      	ldr	r3, [r1, #0]
   3cd18:	1c5a      	adds	r2, r3, #1
   3cd1a:	600a      	str	r2, [r1, #0]
   3cd1c:	7018      	strb	r0, [r3, #0]
	return 0;
   3cd1e:	2000      	movs	r0, #0
   3cd20:	4770      	bx	lr
		return -ENOMEM;
   3cd22:	f06f 000b 	mvn.w	r0, #11
}
   3cd26:	4770      	bx	lr

0003cd28 <pack_utf8_str>:
{
   3cd28:	b538      	push	{r3, r4, r5, lr}
	if ((buf->end - buf->cur) < GET_UT8STR_BUFFER_SIZE(str)) {
   3cd2a:	e9d1 2300 	ldrd	r2, r3, [r1]
{
   3cd2e:	4605      	mov	r5, r0
	if ((buf->end - buf->cur) < GET_UT8STR_BUFFER_SIZE(str)) {
   3cd30:	6840      	ldr	r0, [r0, #4]
   3cd32:	1a9b      	subs	r3, r3, r2
   3cd34:	1c82      	adds	r2, r0, #2
   3cd36:	4293      	cmp	r3, r2
{
   3cd38:	460c      	mov	r4, r1
	if ((buf->end - buf->cur) < GET_UT8STR_BUFFER_SIZE(str)) {
   3cd3a:	d30d      	bcc.n	3cd58 <pack_utf8_str+0x30>
	(void)pack_uint16(str->size, buf);
   3cd3c:	b280      	uxth	r0, r0
   3cd3e:	f7ff ffe1 	bl	3cd04 <pack_uint16>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   3cd42:	e9d5 1200 	ldrd	r1, r2, [r5]
   3cd46:	6820      	ldr	r0, [r4, #0]
   3cd48:	f001 fd80 	bl	3e84c <memcpy>
	return 0;
   3cd4c:	2000      	movs	r0, #0
	buf->cur += str->size;
   3cd4e:	6823      	ldr	r3, [r4, #0]
   3cd50:	686a      	ldr	r2, [r5, #4]
   3cd52:	4413      	add	r3, r2
   3cd54:	6023      	str	r3, [r4, #0]
}
   3cd56:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOMEM;
   3cd58:	f06f 000b 	mvn.w	r0, #11
   3cd5c:	e7fb      	b.n	3cd56 <pack_utf8_str+0x2e>

0003cd5e <mqtt_encode_fixed_header>:
{
   3cd5e:	b570      	push	{r4, r5, r6, lr}
	u32_t length = buf->cur - start;
   3cd60:	6815      	ldr	r5, [r2, #0]
   3cd62:	1a6d      	subs	r5, r5, r1
	if (length > MQTT_MAX_PAYLOAD_SIZE) {
   3cd64:	f1b5 5f80 	cmp.w	r5, #268435456	; 0x10000000
   3cd68:	d227      	bcs.n	3cdba <mqtt_encode_fixed_header+0x5c>
   3cd6a:	462c      	mov	r4, r5
   3cd6c:	2600      	movs	r6, #0
	} while (length > 0);
   3cd6e:	09e4      	lsrs	r4, r4, #7
   3cd70:	b2f3      	uxtb	r3, r6
		if (buf != NULL) {
   3cd72:	f106 0601 	add.w	r6, r6, #1
	} while (length > 0);
   3cd76:	d1fa      	bne.n	3cd6e <mqtt_encode_fixed_header+0x10>
	fixed_header_length += sizeof(u8_t);
   3cd78:	3302      	adds	r3, #2
	buf->cur = start - fixed_header_length;
   3cd7a:	b2db      	uxtb	r3, r3
   3cd7c:	425b      	negs	r3, r3
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   3cd7e:	6856      	ldr	r6, [r2, #4]
	buf->cur = start - fixed_header_length;
   3cd80:	18cc      	adds	r4, r1, r3
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   3cd82:	42b4      	cmp	r4, r6
	buf->cur = start - fixed_header_length;
   3cd84:	6014      	str	r4, [r2, #0]
	*(buf->cur++) = val;
   3cd86:	bf1e      	ittt	ne
   3cd88:	3401      	addne	r4, #1
   3cd8a:	6014      	strne	r4, [r2, #0]
   3cd8c:	54c8      	strbne	r0, [r1, r3]
	return 0;
   3cd8e:	4628      	mov	r0, r5
			*(buf->cur) = length & MQTT_LENGTH_VALUE_MASK;
   3cd90:	6811      	ldr	r1, [r2, #0]
   3cd92:	f000 047f 	and.w	r4, r0, #127	; 0x7f
   3cd96:	700c      	strb	r4, [r1, #0]
			if (length > 0) {
   3cd98:	09c0      	lsrs	r0, r0, #7
				*(buf->cur) |= MQTT_LENGTH_CONTINUATION_BIT;
   3cd9a:	bf1f      	itttt	ne
   3cd9c:	6814      	ldrne	r4, [r2, #0]
   3cd9e:	7821      	ldrbne	r1, [r4, #0]
   3cda0:	f061 017f 	ornne	r1, r1, #127	; 0x7f
   3cda4:	7021      	strbne	r1, [r4, #0]
			buf->cur++;
   3cda6:	6811      	ldr	r1, [r2, #0]
   3cda8:	3101      	adds	r1, #1
   3cdaa:	6011      	str	r1, [r2, #0]
	} while (length > 0);
   3cdac:	2800      	cmp	r0, #0
   3cdae:	d1ef      	bne.n	3cd90 <mqtt_encode_fixed_header+0x32>
	buf->cur = buf->cur - fixed_header_length;
   3cdb0:	440b      	add	r3, r1
	buf->end = buf->cur + length + fixed_header_length;
   3cdb2:	4429      	add	r1, r5
	buf->cur = buf->cur - fixed_header_length;
   3cdb4:	6013      	str	r3, [r2, #0]
	buf->end = buf->cur + length + fixed_header_length;
   3cdb6:	6051      	str	r1, [r2, #4]
}
   3cdb8:	bd70      	pop	{r4, r5, r6, pc}
		return -EMSGSIZE;
   3cdba:	f06f 0079 	mvn.w	r0, #121	; 0x79
   3cdbe:	e7fb      	b.n	3cdb8 <mqtt_encode_fixed_header+0x5a>

0003cdc0 <publish_encode>:
{
   3cdc0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   3cdc4:	4607      	mov	r7, r0
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   3cdc6:	7d80      	ldrb	r0, [r0, #22]
   3cdc8:	7a3c      	ldrb	r4, [r7, #8]
{
   3cdca:	460d      	mov	r5, r1
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   3cdcc:	f000 0801 	and.w	r8, r0, #1
   3cdd0:	f3c0 0940 	ubfx	r9, r0, #1, #1
	if ((param->message.topic.qos) && (param->message_id == 0U)) {
   3cdd4:	b10c      	cbz	r4, 3cdda <publish_encode+0x1a>
   3cdd6:	8abb      	ldrh	r3, [r7, #20]
   3cdd8:	b35b      	cbz	r3, 3ce32 <publish_encode+0x72>
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   3cdda:	682e      	ldr	r6, [r5, #0]
	err_code = pack_utf8_str(&param->message.topic.topic, buf);
   3cddc:	4629      	mov	r1, r5
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   3cdde:	3605      	adds	r6, #5
   3cde0:	602e      	str	r6, [r5, #0]
	err_code = pack_utf8_str(&param->message.topic.topic, buf);
   3cde2:	4638      	mov	r0, r7
   3cde4:	f7ff ffa0 	bl	3cd28 <pack_utf8_str>
	if (err_code != 0) {
   3cde8:	b9a8      	cbnz	r0, 3ce16 <publish_encode+0x56>
	if (param->message.topic.qos) {
   3cdea:	7a3b      	ldrb	r3, [r7, #8]
   3cdec:	b9ab      	cbnz	r3, 3ce1a <publish_encode+0x5a>
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   3cdee:	0060      	lsls	r0, r4, #1
   3cdf0:	f000 0006 	and.w	r0, r0, #6
	buf->cur += param->message.payload.len;
   3cdf4:	693a      	ldr	r2, [r7, #16]
   3cdf6:	682b      	ldr	r3, [r5, #0]
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   3cdf8:	ea40 0009 	orr.w	r0, r0, r9
   3cdfc:	ea40 00c8 	orr.w	r0, r0, r8, lsl #3
	buf->cur += param->message.payload.len;
   3ce00:	4413      	add	r3, r2
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   3ce02:	f040 0030 	orr.w	r0, r0, #48	; 0x30
	buf->cur += param->message.payload.len;
   3ce06:	602b      	str	r3, [r5, #0]
	err_code = mqtt_encode_fixed_header(message_type, start, buf);
   3ce08:	462a      	mov	r2, r5
   3ce0a:	4631      	mov	r1, r6
   3ce0c:	f000 003f 	and.w	r0, r0, #63	; 0x3f
   3ce10:	f7ff ffa5 	bl	3cd5e <mqtt_encode_fixed_header>
	if (err_code != 0) {
   3ce14:	b140      	cbz	r0, 3ce28 <publish_encode+0x68>
}
   3ce16:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		err_code = pack_uint16(param->message_id, buf);
   3ce1a:	4629      	mov	r1, r5
   3ce1c:	8ab8      	ldrh	r0, [r7, #20]
   3ce1e:	f7ff ff71 	bl	3cd04 <pack_uint16>
		if (err_code != 0) {
   3ce22:	2800      	cmp	r0, #0
   3ce24:	d0e3      	beq.n	3cdee <publish_encode+0x2e>
   3ce26:	e7f6      	b.n	3ce16 <publish_encode+0x56>
	buf->end -= param->message.payload.len;
   3ce28:	686b      	ldr	r3, [r5, #4]
   3ce2a:	693a      	ldr	r2, [r7, #16]
   3ce2c:	1a9b      	subs	r3, r3, r2
   3ce2e:	606b      	str	r3, [r5, #4]
	return 0;
   3ce30:	e7f1      	b.n	3ce16 <publish_encode+0x56>
		return -EINVAL;
   3ce32:	f06f 0015 	mvn.w	r0, #21
   3ce36:	e7ee      	b.n	3ce16 <publish_encode+0x56>

0003ce38 <subscribe_encode>:
{
   3ce38:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   3ce3c:	4607      	mov	r7, r0
	if (param->message_id == 0U) {
   3ce3e:	88c0      	ldrh	r0, [r0, #6]
{
   3ce40:	460d      	mov	r5, r1
	if (param->message_id == 0U) {
   3ce42:	b330      	cbz	r0, 3ce92 <subscribe_encode+0x5a>
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   3ce44:	680e      	ldr	r6, [r1, #0]
   3ce46:	3605      	adds	r6, #5
   3ce48:	600e      	str	r6, [r1, #0]
	err_code = pack_uint16(param->message_id, buf);
   3ce4a:	f7ff ff5b 	bl	3cd04 <pack_uint16>
	if (err_code != 0) {
   3ce4e:	4604      	mov	r4, r0
   3ce50:	bb08      	cbnz	r0, 3ce96 <subscribe_encode+0x5e>
   3ce52:	f04f 090c 	mov.w	r9, #12
	for (i = 0; i < param->list_count; i++) {
   3ce56:	88bb      	ldrh	r3, [r7, #4]
   3ce58:	42a3      	cmp	r3, r4
   3ce5a:	dc06      	bgt.n	3ce6a <subscribe_encode+0x32>
	return mqtt_encode_fixed_header(message_type, start, buf);
   3ce5c:	462a      	mov	r2, r5
   3ce5e:	4631      	mov	r1, r6
}
   3ce60:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return mqtt_encode_fixed_header(message_type, start, buf);
   3ce64:	2082      	movs	r0, #130	; 0x82
   3ce66:	f7ff bf7a 	b.w	3cd5e <mqtt_encode_fixed_header>
		err_code = pack_utf8_str(&param->list[i].topic, buf);
   3ce6a:	fb09 f804 	mul.w	r8, r9, r4
   3ce6e:	6838      	ldr	r0, [r7, #0]
   3ce70:	4629      	mov	r1, r5
   3ce72:	4440      	add	r0, r8
   3ce74:	f7ff ff58 	bl	3cd28 <pack_utf8_str>
		if (err_code != 0) {
   3ce78:	b980      	cbnz	r0, 3ce9c <subscribe_encode+0x64>
		err_code = pack_uint8(param->list[i].qos, buf);
   3ce7a:	683b      	ldr	r3, [r7, #0]
   3ce7c:	4443      	add	r3, r8
   3ce7e:	7a1a      	ldrb	r2, [r3, #8]
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   3ce80:	e9d5 3100 	ldrd	r3, r1, [r5]
   3ce84:	4299      	cmp	r1, r3
   3ce86:	d00b      	beq.n	3cea0 <subscribe_encode+0x68>
	*(buf->cur++) = val;
   3ce88:	1c59      	adds	r1, r3, #1
   3ce8a:	6029      	str	r1, [r5, #0]
	for (i = 0; i < param->list_count; i++) {
   3ce8c:	3401      	adds	r4, #1
	*(buf->cur++) = val;
   3ce8e:	701a      	strb	r2, [r3, #0]
		if (err_code != 0) {
   3ce90:	e7e1      	b.n	3ce56 <subscribe_encode+0x1e>
		return -EINVAL;
   3ce92:	f06f 0415 	mvn.w	r4, #21
}
   3ce96:	4620      	mov	r0, r4
   3ce98:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		err_code = pack_utf8_str(&param->list[i].topic, buf);
   3ce9c:	4604      	mov	r4, r0
   3ce9e:	e7fa      	b.n	3ce96 <subscribe_encode+0x5e>
		return -ENOMEM;
   3cea0:	f06f 040b 	mvn.w	r4, #11
   3cea4:	e7f7      	b.n	3ce96 <subscribe_encode+0x5e>

0003cea6 <mqtt_read_message_chunk>:
	return err_code;
}

static int mqtt_read_message_chunk(struct mqtt_client *client,
				   struct buf_ctx *buf, u32_t length)
{
   3cea6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3cea8:	460d      	mov	r5, r1
	int len;

	/* Calculate how much data we need to read from the transport,
	 * given the already buffered data.
	 */
	remaining = length - (buf->end - buf->cur);
   3ceaa:	e9d1 4100 	ldrd	r4, r1, [r1]
   3ceae:	1b0c      	subs	r4, r1, r4
   3ceb0:	1b14      	subs	r4, r2, r4
	if (remaining <= 0) {
   3ceb2:	2c00      	cmp	r4, #0
{
   3ceb4:	4606      	mov	r6, r0
	if (remaining <= 0) {
   3ceb6:	dd14      	ble.n	3cee2 <mqtt_read_message_chunk+0x3c>
		return 0;
	}

	/* Check if read does not exceed the buffer. */
	if (buf->end + remaining > client->rx_buf + client->rx_buf_size) {
   3ceb8:	e9d0 3719 	ldrd	r3, r7, [r0, #100]	; 0x64
   3cebc:	190a      	adds	r2, r1, r4
   3cebe:	443b      	add	r3, r7
   3cec0:	429a      	cmp	r2, r3
   3cec2:	d810      	bhi.n	3cee6 <mqtt_read_message_chunk+0x40>
		MQTT_ERR("[CID %p]: Buffer too small to receive the message",
			 client);
		return -ENOMEM;
	}

	len = mqtt_transport_read(client, buf->end, remaining, false);
   3cec4:	2300      	movs	r3, #0
   3cec6:	4622      	mov	r2, r4
   3cec8:	f7ec fc24 	bl	29714 <mqtt_transport_read>
	if (len < 0) {
   3cecc:	2800      	cmp	r0, #0
   3cece:	db09      	blt.n	3cee4 <mqtt_read_message_chunk+0x3e>
		MQTT_TRC("[CID %p]: Transport read error: %d", client, len);
		return len;
	}

	if (len == 0) {
   3ced0:	d00c      	beq.n	3ceec <mqtt_read_message_chunk+0x46>
		MQTT_TRC("[CID %p]: Connection closed.", client);
		return -ENOTCONN;
	}

	client->internal.rx_buf_datalen += len;
   3ced2:	69f3      	ldr	r3, [r6, #28]
	buf->end += len;

	if (len < remaining) {
   3ced4:	4284      	cmp	r4, r0
	client->internal.rx_buf_datalen += len;
   3ced6:	4403      	add	r3, r0
   3ced8:	61f3      	str	r3, [r6, #28]
	buf->end += len;
   3ceda:	686b      	ldr	r3, [r5, #4]
   3cedc:	4403      	add	r3, r0
   3cede:	606b      	str	r3, [r5, #4]
	if (len < remaining) {
   3cee0:	dc07      	bgt.n	3cef2 <mqtt_read_message_chunk+0x4c>
		MQTT_TRC("[CID %p]: Message partially received.", client);
		return -EAGAIN;
	}

	return 0;
   3cee2:	2000      	movs	r0, #0
}
   3cee4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ENOMEM;
   3cee6:	f06f 000b 	mvn.w	r0, #11
   3ceea:	e7fb      	b.n	3cee4 <mqtt_read_message_chunk+0x3e>
		return -ENOTCONN;
   3ceec:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   3cef0:	e7f8      	b.n	3cee4 <mqtt_read_message_chunk+0x3e>
		return -EAGAIN;
   3cef2:	f06f 000a 	mvn.w	r0, #10
   3cef6:	e7f5      	b.n	3cee4 <mqtt_read_message_chunk+0x3e>

0003cef8 <mqtt_handle_rx>:

	return err_code;
}

int mqtt_handle_rx(struct mqtt_client *client)
{
   3cef8:	b570      	push	{r4, r5, r6, lr}
	int err_code;
	u8_t type_and_flags;
	u32_t var_length;
	struct buf_ctx buf;

	buf.cur = client->rx_buf;
   3cefa:	6e43      	ldr	r3, [r0, #100]	; 0x64
	buf.end = client->rx_buf + client->internal.rx_buf_datalen;
   3cefc:	69c2      	ldr	r2, [r0, #28]
{
   3cefe:	b08c      	sub	sp, #48	; 0x30
	buf.cur = client->rx_buf;
   3cf00:	9302      	str	r3, [sp, #8]
{
   3cf02:	4605      	mov	r5, r0
	buf.end = client->rx_buf + client->internal.rx_buf_datalen;
   3cf04:	4413      	add	r3, r2
	u8_t chunk_size = MQTT_FIXED_HEADER_MIN_SIZE;
   3cf06:	2202      	movs	r2, #2
	buf.end = client->rx_buf + client->internal.rx_buf_datalen;
   3cf08:	9303      	str	r3, [sp, #12]
		err_code = mqtt_read_message_chunk(client, buf, chunk_size);
   3cf0a:	a902      	add	r1, sp, #8
   3cf0c:	4628      	mov	r0, r5
   3cf0e:	f7ff ffca 	bl	3cea6 <mqtt_read_message_chunk>
		if (err_code < 0) {
   3cf12:	1e04      	subs	r4, r0, #0
   3cf14:	db2b      	blt.n	3cf6e <mqtt_handle_rx+0x76>
		buf->cur = client->rx_buf;
   3cf16:	6e6b      	ldr	r3, [r5, #100]	; 0x64
		err_code = fixed_header_decode(buf, type_and_flags, var_length);
   3cf18:	aa01      	add	r2, sp, #4
   3cf1a:	f10d 0103 	add.w	r1, sp, #3
   3cf1e:	a802      	add	r0, sp, #8
		buf->cur = client->rx_buf;
   3cf20:	9302      	str	r3, [sp, #8]
		err_code = fixed_header_decode(buf, type_and_flags, var_length);
   3cf22:	f7ff fe6d 	bl	3cc00 <fixed_header_decode>
	} while (err_code == -EAGAIN);
   3cf26:	f110 0f0b 	cmn.w	r0, #11
		err_code = fixed_header_decode(buf, type_and_flags, var_length);
   3cf2a:	4604      	mov	r4, r0
		chunk_size = 1U;
   3cf2c:	f04f 0201 	mov.w	r2, #1
	} while (err_code == -EAGAIN);
   3cf30:	d0eb      	beq.n	3cf0a <mqtt_handle_rx+0x12>

	err_code = mqtt_read_and_parse_fixed_header(client, &type_and_flags,
						    &var_length, &buf);
	if (err_code < 0) {
   3cf32:	2800      	cmp	r0, #0
   3cf34:	db1f      	blt.n	3cf76 <mqtt_handle_rx+0x7e>
		return (err_code == -EAGAIN) ? 0 : err_code;
	}

	if ((type_and_flags & 0xF0) == MQTT_PKT_TYPE_PUBLISH) {
   3cf36:	f89d 6003 	ldrb.w	r6, [sp, #3]
   3cf3a:	f006 03f0 	and.w	r3, r6, #240	; 0xf0
   3cf3e:	2b30      	cmp	r3, #48	; 0x30
   3cf40:	d11c      	bne.n	3cf7c <mqtt_handle_rx+0x84>
	err_code = mqtt_read_message_chunk(client, buf, sizeof(u16_t));
   3cf42:	2202      	movs	r2, #2
   3cf44:	a902      	add	r1, sp, #8
   3cf46:	4628      	mov	r0, r5
   3cf48:	f7ff ffad 	bl	3cea6 <mqtt_read_message_chunk>
	if (err_code < 0) {
   3cf4c:	1e04      	subs	r4, r0, #0
   3cf4e:	db0e      	blt.n	3cf6e <mqtt_handle_rx+0x76>
	variable_header_length = *buf->cur << 8; /* MSB */
   3cf50:	9b02      	ldr	r3, [sp, #8]
	if (qos > MQTT_QOS_0_AT_MOST_ONCE) {
   3cf52:	f016 0f06 	tst.w	r6, #6
   3cf56:	881a      	ldrh	r2, [r3, #0]
   3cf58:	ba52      	rev16	r2, r2
   3cf5a:	b292      	uxth	r2, r2
	variable_header_length += sizeof(u16_t);
   3cf5c:	bf0c      	ite	eq
   3cf5e:	3202      	addeq	r2, #2
		variable_header_length += sizeof(u16_t);
   3cf60:	3204      	addne	r2, #4
		err_code = mqtt_read_publish_var_header(client, type_and_flags,
							&buf);
	} else {
		err_code = mqtt_read_message_chunk(client, &buf, var_length);
   3cf62:	a902      	add	r1, sp, #8
   3cf64:	4628      	mov	r0, r5
   3cf66:	f7ff ff9e 	bl	3cea6 <mqtt_read_message_chunk>
	}

	if (err_code < 0) {
   3cf6a:	1e04      	subs	r4, r0, #0
   3cf6c:	da08      	bge.n	3cf80 <mqtt_handle_rx+0x88>
		return (err_code == -EAGAIN) ? 0 : err_code;
   3cf6e:	f114 0f0b 	cmn.w	r4, #11
   3cf72:	d100      	bne.n	3cf76 <mqtt_handle_rx+0x7e>
   3cf74:	2400      	movs	r4, #0
	}

	client->internal.rx_buf_datalen = 0U;

	return 0;
}
   3cf76:	4620      	mov	r0, r4
   3cf78:	b00c      	add	sp, #48	; 0x30
   3cf7a:	bd70      	pop	{r4, r5, r6, pc}
		err_code = mqtt_read_message_chunk(client, &buf, var_length);
   3cf7c:	9a01      	ldr	r2, [sp, #4]
   3cf7e:	e7f0      	b.n	3cf62 <mqtt_handle_rx+0x6a>
	evt.result = 0;
   3cf80:	2200      	movs	r2, #0
	err_code = mqtt_handle_packet(client, type_and_flags, var_length, &buf);
   3cf82:	f89d 0003 	ldrb.w	r0, [sp, #3]
   3cf86:	9901      	ldr	r1, [sp, #4]
	evt.result = 0;
   3cf88:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
	switch (type_and_flags & 0xF0) {
   3cf8c:	2b60      	cmp	r3, #96	; 0x60
	evt.result = 0;
   3cf8e:	920b      	str	r2, [sp, #44]	; 0x2c
	switch (type_and_flags & 0xF0) {
   3cf90:	d05e      	beq.n	3d050 <mqtt_handle_rx+0x158>
   3cf92:	d813      	bhi.n	3cfbc <mqtt_handle_rx+0xc4>
   3cf94:	2b30      	cmp	r3, #48	; 0x30
   3cf96:	d045      	beq.n	3d024 <mqtt_handle_rx+0x12c>
   3cf98:	d804      	bhi.n	3cfa4 <mqtt_handle_rx+0xac>
   3cf9a:	2b20      	cmp	r3, #32
   3cf9c:	d02a      	beq.n	3cff4 <mqtt_handle_rx+0xfc>
	client->internal.rx_buf_datalen = 0U;
   3cf9e:	2400      	movs	r4, #0
   3cfa0:	61ec      	str	r4, [r5, #28]
	return 0;
   3cfa2:	e7e8      	b.n	3cf76 <mqtt_handle_rx+0x7e>
	switch (type_and_flags & 0xF0) {
   3cfa4:	2b40      	cmp	r3, #64	; 0x40
   3cfa6:	d049      	beq.n	3d03c <mqtt_handle_rx+0x144>
   3cfa8:	2b50      	cmp	r3, #80	; 0x50
   3cfaa:	d1f8      	bne.n	3cf9e <mqtt_handle_rx+0xa6>
		evt.type = MQTT_EVT_PUBREC;
   3cfac:	2304      	movs	r3, #4
		err_code = publish_receive_decode(buf, &evt.param.pubrec);
   3cfae:	a905      	add	r1, sp, #20
   3cfb0:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBREC;
   3cfb2:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_receive_decode(buf, &evt.param.pubrec);
   3cfb6:	f7ff fe8d 	bl	3ccd4 <publish_receive_decode>
   3cfba:	e046      	b.n	3d04a <mqtt_handle_rx+0x152>
	switch (type_and_flags & 0xF0) {
   3cfbc:	2b90      	cmp	r3, #144	; 0x90
   3cfbe:	d04f      	beq.n	3d060 <mqtt_handle_rx+0x168>
   3cfc0:	d809      	bhi.n	3cfd6 <mqtt_handle_rx+0xde>
   3cfc2:	2b70      	cmp	r3, #112	; 0x70
   3cfc4:	d1eb      	bne.n	3cf9e <mqtt_handle_rx+0xa6>
		evt.type = MQTT_EVT_PUBCOMP;
   3cfc6:	2306      	movs	r3, #6
		err_code = publish_complete_decode(buf, &evt.param.pubcomp);
   3cfc8:	a905      	add	r1, sp, #20
   3cfca:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBCOMP;
   3cfcc:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_complete_decode(buf, &evt.param.pubcomp);
   3cfd0:	f7ff fe84 	bl	3ccdc <publish_complete_decode>
   3cfd4:	e039      	b.n	3d04a <mqtt_handle_rx+0x152>
	switch (type_and_flags & 0xF0) {
   3cfd6:	2bb0      	cmp	r3, #176	; 0xb0
   3cfd8:	d04a      	beq.n	3d070 <mqtt_handle_rx+0x178>
   3cfda:	2bd0      	cmp	r3, #208	; 0xd0
   3cfdc:	d1df      	bne.n	3cf9e <mqtt_handle_rx+0xa6>
		if (client->unacked_ping <= 0) {
   3cfde:	f995 3077 	ldrsb.w	r3, [r5, #119]	; 0x77
   3cfe2:	2b00      	cmp	r3, #0
			client->unacked_ping--;
   3cfe4:	bfca      	itet	gt
   3cfe6:	f103 33ff 	addgt.w	r3, r3, #4294967295
			client->unacked_ping = 0;
   3cfea:	f885 2077 	strble.w	r2, [r5, #119]	; 0x77
			client->unacked_ping--;
   3cfee:	f885 3077 	strbgt.w	r3, [r5, #119]	; 0x77
	if (err_code < 0) {
   3cff2:	e7d4      	b.n	3cf9e <mqtt_handle_rx+0xa6>
		evt.type = MQTT_EVT_CONNACK;
   3cff4:	f88d 2010 	strb.w	r2, [sp, #16]
		err_code = connect_ack_decode(client, buf, &evt.param.connack);
   3cff8:	a902      	add	r1, sp, #8
   3cffa:	aa05      	add	r2, sp, #20
   3cffc:	4628      	mov	r0, r5
   3cffe:	f7ff fe10 	bl	3cc22 <connect_ack_decode>
		if (err_code == 0) {
   3d002:	4604      	mov	r4, r0
   3d004:	bb10      	cbnz	r0, 3d04c <mqtt_handle_rx+0x154>
			if (evt.param.connack.return_code ==
   3d006:	f89d 2015 	ldrb.w	r2, [sp, #21]
   3d00a:	b91a      	cbnz	r2, 3d014 <mqtt_handle_rx+0x11c>
				MQTT_SET_STATE(client, MQTT_STATE_CONNECTED);
   3d00c:	69ab      	ldr	r3, [r5, #24]
   3d00e:	f043 0304 	orr.w	r3, r3, #4
   3d012:	61ab      	str	r3, [r5, #24]
			evt.result = evt.param.connack.return_code;
   3d014:	920b      	str	r2, [sp, #44]	; 0x2c
		event_notify(client, &evt);
   3d016:	a904      	add	r1, sp, #16
   3d018:	4628      	mov	r0, r5
   3d01a:	f000 f84d 	bl	3d0b8 <event_notify>
	if (err_code < 0) {
   3d01e:	2c00      	cmp	r4, #0
   3d020:	dabd      	bge.n	3cf9e <mqtt_handle_rx+0xa6>
   3d022:	e7a8      	b.n	3cf76 <mqtt_handle_rx+0x7e>
		evt.type = MQTT_EVT_PUBLISH;
   3d024:	2302      	movs	r3, #2
		err_code = publish_decode(type_and_flags, var_length, buf,
   3d026:	aa02      	add	r2, sp, #8
		evt.type = MQTT_EVT_PUBLISH;
   3d028:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_decode(type_and_flags, var_length, buf,
   3d02c:	ab05      	add	r3, sp, #20
   3d02e:	f7ff fe13 	bl	3cc58 <publish_decode>
		client->internal.remaining_payload =
   3d032:	9b09      	ldr	r3, [sp, #36]	; 0x24
		err_code = publish_decode(type_and_flags, var_length, buf,
   3d034:	4604      	mov	r4, r0
		evt.result = err_code;
   3d036:	900b      	str	r0, [sp, #44]	; 0x2c
		client->internal.remaining_payload =
   3d038:	622b      	str	r3, [r5, #32]
	if (notify_event == true) {
   3d03a:	e7ec      	b.n	3d016 <mqtt_handle_rx+0x11e>
		evt.type = MQTT_EVT_PUBACK;
   3d03c:	2303      	movs	r3, #3
		err_code = publish_ack_decode(buf, &evt.param.puback);
   3d03e:	a905      	add	r1, sp, #20
   3d040:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBACK;
   3d042:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_ack_decode(buf, &evt.param.puback);
   3d046:	f7ff fe43 	bl	3ccd0 <publish_ack_decode>
		err_code = unsubscribe_ack_decode(buf, &evt.param.unsuback);
   3d04a:	4604      	mov	r4, r0
		evt.result = err_code;
   3d04c:	940b      	str	r4, [sp, #44]	; 0x2c
	if (notify_event == true) {
   3d04e:	e7e2      	b.n	3d016 <mqtt_handle_rx+0x11e>
		evt.type = MQTT_EVT_PUBREL;
   3d050:	2305      	movs	r3, #5
		err_code = publish_release_decode(buf, &evt.param.pubrel);
   3d052:	a905      	add	r1, sp, #20
   3d054:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBREL;
   3d056:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_release_decode(buf, &evt.param.pubrel);
   3d05a:	f7ff fe3d 	bl	3ccd8 <publish_release_decode>
   3d05e:	e7f4      	b.n	3d04a <mqtt_handle_rx+0x152>
		evt.type = MQTT_EVT_SUBACK;
   3d060:	2307      	movs	r3, #7
		err_code = subscribe_ack_decode(buf, &evt.param.suback);
   3d062:	a905      	add	r1, sp, #20
   3d064:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_SUBACK;
   3d066:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = subscribe_ack_decode(buf, &evt.param.suback);
   3d06a:	f7ff fe39 	bl	3cce0 <subscribe_ack_decode>
   3d06e:	e7ec      	b.n	3d04a <mqtt_handle_rx+0x152>
		evt.type = MQTT_EVT_UNSUBACK;
   3d070:	2308      	movs	r3, #8
		err_code = unsubscribe_ack_decode(buf, &evt.param.unsuback);
   3d072:	a905      	add	r1, sp, #20
   3d074:	eb0d 0003 	add.w	r0, sp, r3
		evt.type = MQTT_EVT_UNSUBACK;
   3d078:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = unsubscribe_ack_decode(buf, &evt.param.unsuback);
   3d07c:	f7ff fe40 	bl	3cd00 <unsubscribe_ack_decode>
   3d080:	e7e3      	b.n	3d04a <mqtt_handle_rx+0x152>

0003d082 <mqtt_client_tcp_disconnect>:

int mqtt_client_tcp_disconnect(struct mqtt_client *client)
{
   3d082:	b508      	push	{r3, lr}
	int ret;

	MQTT_TRC("Closing socket %d", client->transport.tcp.sock);

	ret = close(client->transport.tcp.sock);
   3d084:	6a80      	ldr	r0, [r0, #40]	; 0x28
   3d086:	f7ec fa11 	bl	294ac <close>
	if (ret < 0) {
   3d08a:	2800      	cmp	r0, #0
   3d08c:	da04      	bge.n	3d098 <mqtt_client_tcp_disconnect+0x16>
		return -errno;
   3d08e:	f7ff fd48 	bl	3cb22 <__errno>
   3d092:	6800      	ldr	r0, [r0, #0]
   3d094:	4240      	negs	r0, r0
	}

	return 0;
}
   3d096:	bd08      	pop	{r3, pc}
	return 0;
   3d098:	2000      	movs	r0, #0
   3d09a:	e7fc      	b.n	3d096 <mqtt_client_tcp_disconnect+0x14>

0003d09c <tx_buf_init>:
	client->internal.remaining_payload = 0U;
}

/** @brief Initialize tx buffer. */
static void tx_buf_init(struct mqtt_client *client, struct buf_ctx *buf)
{
   3d09c:	b538      	push	{r3, r4, r5, lr}
   3d09e:	4604      	mov	r4, r0
   3d0a0:	460d      	mov	r5, r1
__ssp_bos_icheck3(memset, void *, int)
   3d0a2:	6f02      	ldr	r2, [r0, #112]	; 0x70
   3d0a4:	2100      	movs	r1, #0
   3d0a6:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
   3d0a8:	f001 fbf0 	bl	3e88c <memset>
	memset(client->tx_buf, 0, client->tx_buf_size);
	buf->cur = client->tx_buf;
   3d0ac:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
	buf->end = client->tx_buf + client->tx_buf_size;
   3d0ae:	6f22      	ldr	r2, [r4, #112]	; 0x70
	buf->cur = client->tx_buf;
   3d0b0:	602b      	str	r3, [r5, #0]
	buf->end = client->tx_buf + client->tx_buf_size;
   3d0b2:	4413      	add	r3, r2
   3d0b4:	606b      	str	r3, [r5, #4]
}
   3d0b6:	bd38      	pop	{r3, r4, r5, pc}

0003d0b8 <event_notify>:
	/* Reset internal state. */
	client_reset(client);
}

void event_notify(struct mqtt_client *client, const struct mqtt_evt *evt)
{
   3d0b8:	b538      	push	{r3, r4, r5, lr}
	if (client->evt_cb != NULL) {
   3d0ba:	6e03      	ldr	r3, [r0, #96]	; 0x60
{
   3d0bc:	4604      	mov	r4, r0
   3d0be:	460d      	mov	r5, r1
	if (client->evt_cb != NULL) {
   3d0c0:	b153      	cbz	r3, 3d0d8 <event_notify+0x20>
		mqtt_mutex_unlock(client);
   3d0c2:	f7ec fb3d 	bl	29740 <mqtt_mutex_unlock>

		client->evt_cb(client, evt);
   3d0c6:	4620      	mov	r0, r4
   3d0c8:	6e23      	ldr	r3, [r4, #96]	; 0x60
   3d0ca:	4629      	mov	r1, r5
   3d0cc:	4798      	blx	r3

		mqtt_mutex_lock(client);
   3d0ce:	4620      	mov	r0, r4
	}
}
   3d0d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		mqtt_mutex_lock(client);
   3d0d4:	f7ec bb60 	b.w	29798 <mqtt_mutex_lock>
}
   3d0d8:	bd38      	pop	{r3, r4, r5, pc}

0003d0da <client_disconnect>:

static void client_disconnect(struct mqtt_client *client, int result)
{
   3d0da:	b530      	push	{r4, r5, lr}
   3d0dc:	4604      	mov	r4, r0
   3d0de:	b089      	sub	sp, #36	; 0x24
   3d0e0:	460d      	mov	r5, r1
	int err_code;

	err_code = mqtt_transport_disconnect(client);
   3d0e2:	f7ec fb23 	bl	2972c <mqtt_transport_disconnect>
	if (MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   3d0e6:	69a3      	ldr	r3, [r4, #24]
	event_notify(client, &evt);
   3d0e8:	4669      	mov	r1, sp
	if (MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   3d0ea:	f013 0304 	ands.w	r3, r3, #4
		evt.type = MQTT_EVT_DISCONNECT;
   3d0ee:	bf12      	itee	ne
   3d0f0:	2301      	movne	r3, #1
		evt.type = MQTT_EVT_CONNACK;
   3d0f2:	f88d 3000 	strbeq.w	r3, [sp]
		evt.result = -ECONNREFUSED;
   3d0f6:	f06f 036e 	mvneq.w	r3, #110	; 0x6e
	event_notify(client, &evt);
   3d0fa:	4620      	mov	r0, r4
		evt.type = MQTT_EVT_DISCONNECT;
   3d0fc:	bf16      	itet	ne
   3d0fe:	f88d 3000 	strbne.w	r3, [sp]
		evt.result = -ECONNREFUSED;
   3d102:	9307      	streq	r3, [sp, #28]
		evt.result = result;
   3d104:	9507      	strne	r5, [sp, #28]
	event_notify(client, &evt);
   3d106:	f7ff ffd7 	bl	3d0b8 <event_notify>
	MQTT_STATE_INIT(client);
   3d10a:	2300      	movs	r3, #0
	client->internal.last_activity = 0U;
   3d10c:	e9c4 3305 	strd	r3, r3, [r4, #20]
	client->internal.remaining_payload = 0U;
   3d110:	e9c4 3307 	strd	r3, r3, [r4, #28]
	if (err_code < 0) {
		MQTT_ERR("Failed to disconnect transport!");
	}

	disconnect_event_notify(client, result);
}
   3d114:	b009      	add	sp, #36	; 0x24
   3d116:	bd30      	pop	{r4, r5, pc}

0003d118 <client_write>:
	return err_code;
}

static int client_write(struct mqtt_client *client, const u8_t *data,
			u32_t datalen)
{
   3d118:	b538      	push	{r3, r4, r5, lr}
   3d11a:	4605      	mov	r5, r0
	int err_code;

	MQTT_TRC("[%p]: Transport writing %d bytes.", client, datalen);

	err_code = mqtt_transport_write(client, data, datalen);
   3d11c:	f7ec faee 	bl	296fc <mqtt_transport_write>
	if (err_code < 0) {
   3d120:	1e04      	subs	r4, r0, #0
   3d122:	da05      	bge.n	3d130 <client_write+0x18>
		MQTT_TRC("TCP write failed, errno = %d, "
			 "closing connection", errno);
		client_disconnect(client, err_code);
   3d124:	4621      	mov	r1, r4
   3d126:	4628      	mov	r0, r5
   3d128:	f7ff ffd7 	bl	3d0da <client_disconnect>

	MQTT_TRC("[%p]: Transport write complete.", client);
	client->internal.last_activity = mqtt_sys_tick_in_ms_get();

	return 0;
}
   3d12c:	4620      	mov	r0, r4
   3d12e:	bd38      	pop	{r3, r4, r5, pc}
	return z_impl_k_uptime_get();
   3d130:	f001 facf 	bl	3e6d2 <z_impl_k_uptime_get>
	return 0;
   3d134:	2400      	movs	r4, #0
	return (u32_t)k_uptime_get();
   3d136:	6168      	str	r0, [r5, #20]
   3d138:	e7f8      	b.n	3d12c <client_write+0x14>

0003d13a <read_publish_payload>:
	return err_code;
}

static int read_publish_payload(struct mqtt_client *client, void *buffer,
				size_t length, bool shall_block)
{
   3d13a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3d13e:	460f      	mov	r7, r1
   3d140:	4690      	mov	r8, r2
   3d142:	461e      	mov	r6, r3
	int ret;

	NULL_PARAM_CHECK(client);
   3d144:	4605      	mov	r5, r0
   3d146:	b320      	cbz	r0, 3d192 <read_publish_payload+0x58>

	mqtt_mutex_lock(client);
   3d148:	f7ec fb26 	bl	29798 <mqtt_mutex_lock>

	if (client->internal.remaining_payload == 0U) {
   3d14c:	6a2c      	ldr	r4, [r5, #32]
   3d14e:	b1b4      	cbz	r4, 3d17e <read_publish_payload+0x44>

	if (client->internal.remaining_payload < length) {
		length = client->internal.remaining_payload;
	}

	ret = mqtt_transport_read(client, buffer, length, shall_block);
   3d150:	4544      	cmp	r4, r8
   3d152:	4622      	mov	r2, r4
   3d154:	4633      	mov	r3, r6
   3d156:	bf28      	it	cs
   3d158:	4642      	movcs	r2, r8
   3d15a:	4639      	mov	r1, r7
   3d15c:	4628      	mov	r0, r5
   3d15e:	f7ec fad9 	bl	29714 <mqtt_transport_read>
   3d162:	4604      	mov	r4, r0
	if (!shall_block && ret == -EAGAIN) {
   3d164:	b916      	cbnz	r6, 3d16c <read_publish_payload+0x32>
   3d166:	f110 0f0b 	cmn.w	r0, #11
   3d16a:	d008      	beq.n	3d17e <read_publish_payload+0x44>
		goto exit;
	}

	if (ret <= 0) {
   3d16c:	2c00      	cmp	r4, #0
   3d16e:	dc0c      	bgt.n	3d18a <read_publish_payload+0x50>
		if (ret == 0) {
			ret = -ENOTCONN;
   3d170:	bf08      	it	eq
   3d172:	f06f 047f 	mvneq.w	r4, #127	; 0x7f
		}

		client_disconnect(client, ret);
   3d176:	4628      	mov	r0, r5
   3d178:	4621      	mov	r1, r4
   3d17a:	f7ff ffae 	bl	3d0da <client_disconnect>
	}

	client->internal.remaining_payload -= ret;

exit:
	mqtt_mutex_unlock(client);
   3d17e:	4628      	mov	r0, r5
   3d180:	f7ec fade 	bl	29740 <mqtt_mutex_unlock>

	return ret;
}
   3d184:	4620      	mov	r0, r4
   3d186:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	client->internal.remaining_payload -= ret;
   3d18a:	6a2b      	ldr	r3, [r5, #32]
   3d18c:	1b1b      	subs	r3, r3, r4
   3d18e:	622b      	str	r3, [r5, #32]
   3d190:	e7f5      	b.n	3d17e <read_publish_payload+0x44>
	NULL_PARAM_CHECK(client);
   3d192:	f06f 0415 	mvn.w	r4, #21
   3d196:	e7f5      	b.n	3d184 <read_publish_payload+0x4a>

0003d198 <mqtt_client_init>:
{
   3d198:	b510      	push	{r4, lr}
	NULL_PARAM_CHECK_VOID(client);
   3d19a:	4604      	mov	r4, r0
   3d19c:	b1a0      	cbz	r0, 3d1c8 <mqtt_client_init+0x30>
   3d19e:	227c      	movs	r2, #124	; 0x7c
   3d1a0:	2100      	movs	r1, #0
   3d1a2:	f001 fb73 	bl	3e88c <memset>
	MQTT_STATE_INIT(client);
   3d1a6:	2300      	movs	r3, #0
   3d1a8:	61a3      	str	r3, [r4, #24]
	return z_impl_k_mutex_init(mutex);
   3d1aa:	4620      	mov	r0, r4
   3d1ac:	f001 f999 	bl	3e4e2 <z_impl_k_mutex_init>
	client->protocol_version = MQTT_VERSION_3_1_1;
   3d1b0:	2304      	movs	r3, #4
   3d1b2:	f884 3076 	strb.w	r3, [r4, #118]	; 0x76
	client->clean_session = 1U;
   3d1b6:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
   3d1ba:	f043 0302 	orr.w	r3, r3, #2
   3d1be:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
	client->keepalive = MQTT_KEEPALIVE;
   3d1c2:	233c      	movs	r3, #60	; 0x3c
   3d1c4:	f8a4 3074 	strh.w	r3, [r4, #116]	; 0x74
}
   3d1c8:	bd10      	pop	{r4, pc}

0003d1ca <mqtt_connect>:
{
   3d1ca:	b537      	push	{r0, r1, r2, r4, r5, lr}
	NULL_PARAM_CHECK(client);
   3d1cc:	4604      	mov	r4, r0
   3d1ce:	2800      	cmp	r0, #0
   3d1d0:	d03c      	beq.n	3d24c <mqtt_connect+0x82>
	NULL_PARAM_CHECK(client->client_id.utf8);
   3d1d2:	6c43      	ldr	r3, [r0, #68]	; 0x44
   3d1d4:	2b00      	cmp	r3, #0
   3d1d6:	d039      	beq.n	3d24c <mqtt_connect+0x82>
	mqtt_mutex_lock(client);
   3d1d8:	f7ec fade 	bl	29798 <mqtt_mutex_lock>
	if ((client->tx_buf == NULL) || (client->rx_buf == NULL)) {
   3d1dc:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   3d1de:	b393      	cbz	r3, 3d246 <mqtt_connect+0x7c>
   3d1e0:	6e63      	ldr	r3, [r4, #100]	; 0x64
   3d1e2:	b383      	cbz	r3, 3d246 <mqtt_connect+0x7c>
	err_code = mqtt_transport_connect(client);
   3d1e4:	4620      	mov	r0, r4
   3d1e6:	f7ec fa81 	bl	296ec <mqtt_transport_connect>
	if (err_code < 0) {
   3d1ea:	1e05      	subs	r5, r0, #0
   3d1ec:	db25      	blt.n	3d23a <mqtt_connect+0x70>
	tx_buf_init(client, &packet);
   3d1ee:	4669      	mov	r1, sp
   3d1f0:	4620      	mov	r0, r4
   3d1f2:	f7ff ff53 	bl	3d09c <tx_buf_init>
	MQTT_SET_STATE(client, MQTT_STATE_TCP_CONNECTED);
   3d1f6:	69a3      	ldr	r3, [r4, #24]
	err_code = connect_request_encode(client, &packet);
   3d1f8:	4669      	mov	r1, sp
	MQTT_SET_STATE(client, MQTT_STATE_TCP_CONNECTED);
   3d1fa:	f043 0302 	orr.w	r3, r3, #2
   3d1fe:	61a3      	str	r3, [r4, #24]
	err_code = connect_request_encode(client, &packet);
   3d200:	4620      	mov	r0, r4
   3d202:	f7ec f8af 	bl	29364 <connect_request_encode>
	if (err_code < 0) {
   3d206:	1e05      	subs	r5, r0, #0
   3d208:	db13      	blt.n	3d232 <mqtt_connect+0x68>
	err_code = mqtt_transport_write(client, packet.cur,
   3d20a:	e9dd 1200 	ldrd	r1, r2, [sp]
   3d20e:	4620      	mov	r0, r4
   3d210:	1a52      	subs	r2, r2, r1
   3d212:	f7ec fa73 	bl	296fc <mqtt_transport_write>
	if (err_code < 0) {
   3d216:	1e05      	subs	r5, r0, #0
   3d218:	db0b      	blt.n	3d232 <mqtt_connect+0x68>
	return z_impl_k_uptime_get();
   3d21a:	f001 fa5a 	bl	3e6d2 <z_impl_k_uptime_get>
	client->unacked_ping = 0;
   3d21e:	2500      	movs	r5, #0
   3d220:	6160      	str	r0, [r4, #20]
   3d222:	f884 5077 	strb.w	r5, [r4, #119]	; 0x77
	mqtt_mutex_unlock(client);
   3d226:	4620      	mov	r0, r4
   3d228:	f7ec fa8a 	bl	29740 <mqtt_mutex_unlock>
}
   3d22c:	4628      	mov	r0, r5
   3d22e:	b003      	add	sp, #12
   3d230:	bd30      	pop	{r4, r5, pc}
	client_disconnect(client, err_code);
   3d232:	4629      	mov	r1, r5
   3d234:	4620      	mov	r0, r4
   3d236:	f7ff ff50 	bl	3d0da <client_disconnect>
	MQTT_STATE_INIT(client);
   3d23a:	2300      	movs	r3, #0
	client->internal.last_activity = 0U;
   3d23c:	e9c4 3305 	strd	r3, r3, [r4, #20]
	client->internal.remaining_payload = 0U;
   3d240:	e9c4 3307 	strd	r3, r3, [r4, #28]
   3d244:	e7ef      	b.n	3d226 <mqtt_connect+0x5c>
		err_code = -ENOMEM;
   3d246:	f06f 050b 	mvn.w	r5, #11
   3d24a:	e7f6      	b.n	3d23a <mqtt_connect+0x70>
	NULL_PARAM_CHECK(client);
   3d24c:	f06f 0515 	mvn.w	r5, #21
   3d250:	e7ec      	b.n	3d22c <mqtt_connect+0x62>

0003d252 <mqtt_publish>:
{
   3d252:	b573      	push	{r0, r1, r4, r5, r6, lr}
   3d254:	460e      	mov	r6, r1
	NULL_PARAM_CHECK(client);
   3d256:	4605      	mov	r5, r0
   3d258:	b330      	cbz	r0, 3d2a8 <mqtt_publish+0x56>
	NULL_PARAM_CHECK(param);
   3d25a:	b329      	cbz	r1, 3d2a8 <mqtt_publish+0x56>
	mqtt_mutex_lock(client);
   3d25c:	f7ec fa9c 	bl	29798 <mqtt_mutex_lock>
	tx_buf_init(client, &packet);
   3d260:	4669      	mov	r1, sp
   3d262:	4628      	mov	r0, r5
   3d264:	f7ff ff1a 	bl	3d09c <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   3d268:	69ab      	ldr	r3, [r5, #24]
   3d26a:	075b      	lsls	r3, r3, #29
   3d26c:	d519      	bpl.n	3d2a2 <mqtt_publish+0x50>
	err_code = publish_encode(param, &packet);
   3d26e:	4669      	mov	r1, sp
   3d270:	4630      	mov	r0, r6
   3d272:	f7ff fda5 	bl	3cdc0 <publish_encode>
	if (err_code < 0) {
   3d276:	1e04      	subs	r4, r0, #0
   3d278:	db0d      	blt.n	3d296 <mqtt_publish+0x44>
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   3d27a:	e9dd 1200 	ldrd	r1, r2, [sp]
   3d27e:	4628      	mov	r0, r5
   3d280:	1a52      	subs	r2, r2, r1
   3d282:	f7ff ff49 	bl	3d118 <client_write>
	if (err_code < 0) {
   3d286:	1e04      	subs	r4, r0, #0
   3d288:	db05      	blt.n	3d296 <mqtt_publish+0x44>
	err_code = client_write(client, param->message.payload.data,
   3d28a:	e9d6 1203 	ldrd	r1, r2, [r6, #12]
   3d28e:	4628      	mov	r0, r5
   3d290:	f7ff ff42 	bl	3d118 <client_write>
   3d294:	4604      	mov	r4, r0
	mqtt_mutex_unlock(client);
   3d296:	4628      	mov	r0, r5
   3d298:	f7ec fa52 	bl	29740 <mqtt_mutex_unlock>
}
   3d29c:	4620      	mov	r0, r4
   3d29e:	b002      	add	sp, #8
   3d2a0:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOTCONN;
   3d2a2:	f06f 047f 	mvn.w	r4, #127	; 0x7f
   3d2a6:	e7f6      	b.n	3d296 <mqtt_publish+0x44>
	NULL_PARAM_CHECK(client);
   3d2a8:	f06f 0415 	mvn.w	r4, #21
   3d2ac:	e7f6      	b.n	3d29c <mqtt_publish+0x4a>

0003d2ae <mqtt_disconnect>:
{
   3d2ae:	b537      	push	{r0, r1, r2, r4, r5, lr}
	NULL_PARAM_CHECK(client);
   3d2b0:	4604      	mov	r4, r0
   3d2b2:	b310      	cbz	r0, 3d2fa <mqtt_disconnect+0x4c>
	mqtt_mutex_lock(client);
   3d2b4:	f7ec fa70 	bl	29798 <mqtt_mutex_lock>
	tx_buf_init(client, &packet);
   3d2b8:	4669      	mov	r1, sp
   3d2ba:	4620      	mov	r0, r4
   3d2bc:	f7ff feee 	bl	3d09c <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   3d2c0:	69a3      	ldr	r3, [r4, #24]
   3d2c2:	075b      	lsls	r3, r3, #29
   3d2c4:	d516      	bpl.n	3d2f4 <mqtt_disconnect+0x46>
	err_code = disconnect_encode(&packet);
   3d2c6:	4668      	mov	r0, sp
   3d2c8:	f7ec f8cc 	bl	29464 <disconnect_encode>
	if (err_code < 0) {
   3d2cc:	1e05      	subs	r5, r0, #0
   3d2ce:	db0b      	blt.n	3d2e8 <mqtt_disconnect+0x3a>
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   3d2d0:	e9dd 1200 	ldrd	r1, r2, [sp]
   3d2d4:	4620      	mov	r0, r4
   3d2d6:	1a52      	subs	r2, r2, r1
   3d2d8:	f7ff ff1e 	bl	3d118 <client_write>
	if (err_code < 0) {
   3d2dc:	1e05      	subs	r5, r0, #0
   3d2de:	db03      	blt.n	3d2e8 <mqtt_disconnect+0x3a>
	client_disconnect(client, 0);
   3d2e0:	2100      	movs	r1, #0
   3d2e2:	4620      	mov	r0, r4
   3d2e4:	f7ff fef9 	bl	3d0da <client_disconnect>
	mqtt_mutex_unlock(client);
   3d2e8:	4620      	mov	r0, r4
   3d2ea:	f7ec fa29 	bl	29740 <mqtt_mutex_unlock>
}
   3d2ee:	4628      	mov	r0, r5
   3d2f0:	b003      	add	sp, #12
   3d2f2:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   3d2f4:	f06f 057f 	mvn.w	r5, #127	; 0x7f
   3d2f8:	e7f6      	b.n	3d2e8 <mqtt_disconnect+0x3a>
	NULL_PARAM_CHECK(client);
   3d2fa:	f06f 0515 	mvn.w	r5, #21
   3d2fe:	e7f6      	b.n	3d2ee <mqtt_disconnect+0x40>

0003d300 <mqtt_subscribe>:
{
   3d300:	b537      	push	{r0, r1, r2, r4, r5, lr}
   3d302:	460c      	mov	r4, r1
	NULL_PARAM_CHECK(client);
   3d304:	4605      	mov	r5, r0
   3d306:	b1f8      	cbz	r0, 3d348 <mqtt_subscribe+0x48>
	NULL_PARAM_CHECK(param);
   3d308:	b1f1      	cbz	r1, 3d348 <mqtt_subscribe+0x48>
	mqtt_mutex_lock(client);
   3d30a:	f7ec fa45 	bl	29798 <mqtt_mutex_lock>
	tx_buf_init(client, &packet);
   3d30e:	4669      	mov	r1, sp
   3d310:	4628      	mov	r0, r5
   3d312:	f7ff fec3 	bl	3d09c <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   3d316:	69ab      	ldr	r3, [r5, #24]
   3d318:	075b      	lsls	r3, r3, #29
   3d31a:	d512      	bpl.n	3d342 <mqtt_subscribe+0x42>
	err_code = subscribe_encode(param, &packet);
   3d31c:	4620      	mov	r0, r4
   3d31e:	4669      	mov	r1, sp
   3d320:	f7ff fd8a 	bl	3ce38 <subscribe_encode>
	if (err_code < 0) {
   3d324:	1e04      	subs	r4, r0, #0
   3d326:	db06      	blt.n	3d336 <mqtt_subscribe+0x36>
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   3d328:	e9dd 1200 	ldrd	r1, r2, [sp]
   3d32c:	4628      	mov	r0, r5
   3d32e:	1a52      	subs	r2, r2, r1
   3d330:	f7ff fef2 	bl	3d118 <client_write>
   3d334:	4604      	mov	r4, r0
	mqtt_mutex_unlock(client);
   3d336:	4628      	mov	r0, r5
   3d338:	f7ec fa02 	bl	29740 <mqtt_mutex_unlock>
}
   3d33c:	4620      	mov	r0, r4
   3d33e:	b003      	add	sp, #12
   3d340:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   3d342:	f06f 047f 	mvn.w	r4, #127	; 0x7f
   3d346:	e7f6      	b.n	3d336 <mqtt_subscribe+0x36>
	NULL_PARAM_CHECK(client);
   3d348:	f06f 0415 	mvn.w	r4, #21
   3d34c:	e7f6      	b.n	3d33c <mqtt_subscribe+0x3c>

0003d34e <mqtt_ping>:
{
   3d34e:	b537      	push	{r0, r1, r2, r4, r5, lr}
	NULL_PARAM_CHECK(client);
   3d350:	4604      	mov	r4, r0
   3d352:	b320      	cbz	r0, 3d39e <mqtt_ping+0x50>
	mqtt_mutex_lock(client);
   3d354:	f7ec fa20 	bl	29798 <mqtt_mutex_lock>
	tx_buf_init(client, &packet);
   3d358:	4669      	mov	r1, sp
   3d35a:	4620      	mov	r0, r4
   3d35c:	f7ff fe9e 	bl	3d09c <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   3d360:	69a3      	ldr	r3, [r4, #24]
   3d362:	075b      	lsls	r3, r3, #29
   3d364:	d518      	bpl.n	3d398 <mqtt_ping+0x4a>
	err_code = ping_request_encode(&packet);
   3d366:	4668      	mov	r0, sp
   3d368:	f7ec f88e 	bl	29488 <ping_request_encode>
	if (err_code < 0) {
   3d36c:	1e05      	subs	r5, r0, #0
   3d36e:	db0d      	blt.n	3d38c <mqtt_ping+0x3e>
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   3d370:	e9dd 1200 	ldrd	r1, r2, [sp]
   3d374:	4620      	mov	r0, r4
   3d376:	1a52      	subs	r2, r2, r1
   3d378:	f7ff fece 	bl	3d118 <client_write>
	if (client->unacked_ping >= INT8_MAX) {
   3d37c:	f994 3077 	ldrsb.w	r3, [r4, #119]	; 0x77
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   3d380:	4605      	mov	r5, r0
	if (client->unacked_ping >= INT8_MAX) {
   3d382:	2b7f      	cmp	r3, #127	; 0x7f
   3d384:	d002      	beq.n	3d38c <mqtt_ping+0x3e>
		client->unacked_ping++;
   3d386:	3301      	adds	r3, #1
   3d388:	f884 3077 	strb.w	r3, [r4, #119]	; 0x77
	mqtt_mutex_unlock(client);
   3d38c:	4620      	mov	r0, r4
   3d38e:	f7ec f9d7 	bl	29740 <mqtt_mutex_unlock>
}
   3d392:	4628      	mov	r0, r5
   3d394:	b003      	add	sp, #12
   3d396:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   3d398:	f06f 057f 	mvn.w	r5, #127	; 0x7f
   3d39c:	e7f6      	b.n	3d38c <mqtt_ping+0x3e>
	NULL_PARAM_CHECK(client);
   3d39e:	f06f 0515 	mvn.w	r5, #21
   3d3a2:	e7f6      	b.n	3d392 <mqtt_ping+0x44>

0003d3a4 <mqtt_live>:
{
   3d3a4:	b570      	push	{r4, r5, r6, lr}
	NULL_PARAM_CHECK(client);
   3d3a6:	4606      	mov	r6, r0
   3d3a8:	b300      	cbz	r0, 3d3ec <mqtt_live+0x48>
	mqtt_mutex_lock(client);
   3d3aa:	f7ec f9f5 	bl	29798 <mqtt_mutex_lock>
	elapsed_time = mqtt_elapsed_time_in_ms_get(
   3d3ae:	6974      	ldr	r4, [r6, #20]
   3d3b0:	f001 f98f 	bl	3e6d2 <z_impl_k_uptime_get>
 *
 * @retval Time elapsed since last_activity time.
 */
static inline u32_t mqtt_elapsed_time_in_ms_get(u32_t last_activity)
{
	s32_t diff = k_uptime_get_32() - last_activity;
   3d3b4:	1b00      	subs	r0, r0, r4
	if ((client->keepalive > 0) &&
   3d3b6:	f8b6 4074 	ldrh.w	r4, [r6, #116]	; 0x74

	if (diff < 0) {
		return 0;
   3d3ba:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   3d3be:	b19c      	cbz	r4, 3d3e8 <mqtt_live+0x44>
	    (elapsed_time >= (client->keepalive * 1000))) {
   3d3c0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   3d3c4:	435c      	muls	r4, r3
	if ((client->keepalive > 0) &&
   3d3c6:	4284      	cmp	r4, r0
   3d3c8:	d80d      	bhi.n	3d3e6 <mqtt_live+0x42>
		err_code = mqtt_ping(client);
   3d3ca:	4630      	mov	r0, r6
   3d3cc:	f7ff ffbf 	bl	3d34e <mqtt_ping>
		ping_sent = true;
   3d3d0:	2401      	movs	r4, #1
		err_code = mqtt_ping(client);
   3d3d2:	4605      	mov	r5, r0
	mqtt_mutex_unlock(client);
   3d3d4:	4630      	mov	r0, r6
   3d3d6:	f7ec f9b3 	bl	29740 <mqtt_mutex_unlock>
		return -EAGAIN;
   3d3da:	2c00      	cmp	r4, #0
   3d3dc:	bf08      	it	eq
   3d3de:	f06f 050a 	mvneq.w	r5, #10
}
   3d3e2:	4628      	mov	r0, r5
   3d3e4:	bd70      	pop	{r4, r5, r6, pc}
	bool ping_sent = false;
   3d3e6:	2400      	movs	r4, #0
	int err_code = 0;
   3d3e8:	4625      	mov	r5, r4
   3d3ea:	e7f3      	b.n	3d3d4 <mqtt_live+0x30>
	NULL_PARAM_CHECK(client);
   3d3ec:	f06f 0515 	mvn.w	r5, #21
   3d3f0:	e7f7      	b.n	3d3e2 <mqtt_live+0x3e>

0003d3f2 <mqtt_keepalive_time_left>:
{
   3d3f2:	b538      	push	{r3, r4, r5, lr}
   3d3f4:	4605      	mov	r5, r0
	u32_t elapsed_time = mqtt_elapsed_time_in_ms_get(
   3d3f6:	6944      	ldr	r4, [r0, #20]
   3d3f8:	f001 f96b 	bl	3e6d2 <z_impl_k_uptime_get>
	s32_t diff = k_uptime_get_32() - last_activity;
   3d3fc:	1b04      	subs	r4, r0, r4
	u32_t keepalive_ms = 1000U * client->keepalive;
   3d3fe:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   3d402:	f8b5 2074 	ldrh.w	r2, [r5, #116]	; 0x74
		return 0;
   3d406:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
   3d40a:	4350      	muls	r0, r2
	if (client->keepalive == 0) {
   3d40c:	b11a      	cbz	r2, 3d416 <mqtt_keepalive_time_left+0x24>
	if (keepalive_ms <= elapsed_time) {
   3d40e:	42a0      	cmp	r0, r4
   3d410:	d904      	bls.n	3d41c <mqtt_keepalive_time_left+0x2a>
	return keepalive_ms - elapsed_time;
   3d412:	1b00      	subs	r0, r0, r4
}
   3d414:	bd38      	pop	{r3, r4, r5, pc}
		return UINT32_MAX;
   3d416:	f04f 30ff 	mov.w	r0, #4294967295
   3d41a:	e7fb      	b.n	3d414 <mqtt_keepalive_time_left+0x22>
		return 0;
   3d41c:	2000      	movs	r0, #0
   3d41e:	e7f9      	b.n	3d414 <mqtt_keepalive_time_left+0x22>

0003d420 <mqtt_input>:
{
   3d420:	b538      	push	{r3, r4, r5, lr}
	NULL_PARAM_CHECK(client);
   3d422:	4605      	mov	r5, r0
   3d424:	b1d0      	cbz	r0, 3d45c <mqtt_input+0x3c>
	mqtt_mutex_lock(client);
   3d426:	f7ec f9b7 	bl	29798 <mqtt_mutex_lock>
	if (MQTT_HAS_STATE(client, MQTT_STATE_TCP_CONNECTED)) {
   3d42a:	69ab      	ldr	r3, [r5, #24]
   3d42c:	079b      	lsls	r3, r3, #30
   3d42e:	d50f      	bpl.n	3d450 <mqtt_input+0x30>
	if (client->internal.remaining_payload > 0) {
   3d430:	6a2b      	ldr	r3, [r5, #32]
   3d432:	b983      	cbnz	r3, 3d456 <mqtt_input+0x36>
	err_code = mqtt_handle_rx(client);
   3d434:	4628      	mov	r0, r5
   3d436:	f7ff fd5f 	bl	3cef8 <mqtt_handle_rx>
	if (err_code < 0) {
   3d43a:	1e04      	subs	r4, r0, #0
   3d43c:	da03      	bge.n	3d446 <mqtt_input+0x26>
		client_disconnect(client, err_code);
   3d43e:	4621      	mov	r1, r4
   3d440:	4628      	mov	r0, r5
   3d442:	f7ff fe4a 	bl	3d0da <client_disconnect>
	mqtt_mutex_unlock(client);
   3d446:	4628      	mov	r0, r5
   3d448:	f7ec f97a 	bl	29740 <mqtt_mutex_unlock>
}
   3d44c:	4620      	mov	r0, r4
   3d44e:	bd38      	pop	{r3, r4, r5, pc}
		err_code = -EACCES;
   3d450:	f06f 040c 	mvn.w	r4, #12
   3d454:	e7f7      	b.n	3d446 <mqtt_input+0x26>
		return -EBUSY;
   3d456:	f06f 040f 	mvn.w	r4, #15
   3d45a:	e7f4      	b.n	3d446 <mqtt_input+0x26>
	NULL_PARAM_CHECK(client);
   3d45c:	f06f 0415 	mvn.w	r4, #21
   3d460:	e7f4      	b.n	3d44c <mqtt_input+0x2c>

0003d462 <mqtt_read_publish_payload>:

int mqtt_read_publish_payload(struct mqtt_client *client, void *buffer,
			      size_t length)
{
	return read_publish_payload(client, buffer, length, false);
   3d462:	2300      	movs	r3, #0
   3d464:	f7ff be69 	b.w	3d13a <read_publish_payload>

0003d468 <mqtt_client_tls_disconnect>:

int mqtt_client_tls_disconnect(struct mqtt_client *client)
{
   3d468:	b508      	push	{r3, lr}
	int ret;

	MQTT_TRC("Closing socket %d", client->transport.tls.sock);
	ret = close(client->transport.tls.sock);
   3d46a:	6a80      	ldr	r0, [r0, #40]	; 0x28
   3d46c:	f7ec f9b4 	bl	297d8 <close>
	if (ret < 0) {
   3d470:	2800      	cmp	r0, #0
   3d472:	da04      	bge.n	3d47e <mqtt_client_tls_disconnect+0x16>
		return -errno;
   3d474:	f7ff fb55 	bl	3cb22 <__errno>
   3d478:	6800      	ldr	r0, [r0, #0]
   3d47a:	4240      	negs	r0, r0
	}

	return 0;
}
   3d47c:	bd08      	pop	{r3, pc}
	return 0;
   3d47e:	2000      	movs	r0, #0
   3d480:	e7fc      	b.n	3d47c <mqtt_client_tls_disconnect+0x14>

0003d482 <gpio_nrfx_write>:
{
   3d482:	b510      	push	{r4, lr}
	return port->config->config_info;
   3d484:	6804      	ldr	r4, [r0, #0]
   3d486:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   3d488:	68a4      	ldr	r4, [r4, #8]
	if (access_op == GPIO_ACCESS_BY_PORT) {
   3d48a:	2901      	cmp	r1, #1
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   3d48c:	6824      	ldr	r4, [r4, #0]
	if (access_op == GPIO_ACCESS_BY_PORT) {
   3d48e:	69c0      	ldr	r0, [r0, #28]
   3d490:	d103      	bne.n	3d49a <gpio_nrfx_write+0x18>
		nrf_gpio_port_out_write(reg, value ^ data->inverted);
   3d492:	4058      	eors	r0, r3
    p_reg->OUT = value;
   3d494:	6060      	str	r0, [r4, #4]
}
   3d496:	2000      	movs	r0, #0
   3d498:	bd10      	pop	{r4, pc}
		if ((value > 0) ^ ((BIT(pin) & data->inverted) != 0)) {
   3d49a:	3300      	adds	r3, #0
   3d49c:	f04f 0101 	mov.w	r1, #1
   3d4a0:	bf18      	it	ne
   3d4a2:	2301      	movne	r3, #1
   3d4a4:	40d0      	lsrs	r0, r2
   3d4a6:	f000 0001 	and.w	r0, r0, #1
   3d4aa:	4091      	lsls	r1, r2
   3d4ac:	4283      	cmp	r3, r0
    p_reg->OUTSET = set_mask;
   3d4ae:	bf14      	ite	ne
   3d4b0:	60a1      	strne	r1, [r4, #8]
    p_reg->OUTCLR = clr_mask;
   3d4b2:	60e1      	streq	r1, [r4, #12]
   3d4b4:	e7ef      	b.n	3d496 <gpio_nrfx_write+0x14>

0003d4b6 <gpio_nrfx_read>:
{
   3d4b6:	b570      	push	{r4, r5, r6, lr}
	return port->config->config_info;
   3d4b8:	6804      	ldr	r4, [r0, #0]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   3d4ba:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   3d4bc:	68a4      	ldr	r4, [r4, #8]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   3d4be:	69c0      	ldr	r0, [r0, #28]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   3d4c0:	6825      	ldr	r5, [r4, #0]
	if (access_op == GPIO_ACCESS_BY_PORT) {
   3d4c2:	2901      	cmp	r1, #1
    return p_reg->DIR;
   3d4c4:	696e      	ldr	r6, [r5, #20]
    return p_reg->IN;
   3d4c6:	692c      	ldr	r4, [r5, #16]
    return p_reg->OUT;
   3d4c8:	686d      	ldr	r5, [r5, #4]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   3d4ca:	ea80 0004 	eor.w	r0, r0, r4
   3d4ce:	ea84 0405 	eor.w	r4, r4, r5
   3d4d2:	ea04 0406 	and.w	r4, r4, r6
   3d4d6:	ea80 0004 	eor.w	r0, r0, r4
		*value = (port_val & BIT(pin)) ? 1 : 0;
   3d4da:	bf1c      	itt	ne
   3d4dc:	40d0      	lsrne	r0, r2
   3d4de:	f000 0001 	andne.w	r0, r0, #1
   3d4e2:	6018      	str	r0, [r3, #0]
}
   3d4e4:	2000      	movs	r0, #0
   3d4e6:	bd70      	pop	{r4, r5, r6, pc}

0003d4e8 <gpio_nrfx_pin_disable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
   3d4e8:	2901      	cmp	r1, #1
{
   3d4ea:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
   3d4ee:	bf18      	it	ne
   3d4f0:	b2d4      	uxtbne	r4, r2
{
   3d4f2:	4606      	mov	r6, r0
		to_pin   = pin;
   3d4f4:	bf12      	itee	ne
   3d4f6:	4625      	movne	r5, r4
		to_pin   = 31U;
   3d4f8:	251f      	moveq	r5, #31
		from_pin = 0U;
   3d4fa:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
   3d4fc:	f04f 0801 	mov.w	r8, #1
	struct gpio_nrfx_data *data = get_port_data(port);
   3d500:	6887      	ldr	r7, [r0, #8]
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   3d502:	42ac      	cmp	r4, r5
   3d504:	d902      	bls.n	3d50c <gpio_nrfx_pin_disable_callback+0x24>
	return res;
   3d506:	2000      	movs	r0, #0
}
   3d508:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
   3d50c:	68fb      	ldr	r3, [r7, #12]
   3d50e:	fa08 f204 	lsl.w	r2, r8, r4
   3d512:	ea23 0302 	bic.w	r3, r3, r2
   3d516:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
   3d518:	4621      	mov	r1, r4
   3d51a:	4630      	mov	r0, r6
   3d51c:	f7ec fbd0 	bl	29cc0 <gpiote_pin_int_cfg>
		if (res != 0) {
   3d520:	2800      	cmp	r0, #0
   3d522:	d1f1      	bne.n	3d508 <gpio_nrfx_pin_disable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   3d524:	3401      	adds	r4, #1
   3d526:	b2e4      	uxtb	r4, r4
   3d528:	e7eb      	b.n	3d502 <gpio_nrfx_pin_disable_callback+0x1a>

0003d52a <gpio_nrfx_pin_enable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
   3d52a:	2901      	cmp	r1, #1
{
   3d52c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
   3d530:	bf18      	it	ne
   3d532:	b2d4      	uxtbne	r4, r2
{
   3d534:	4606      	mov	r6, r0
		to_pin   = pin;
   3d536:	bf12      	itee	ne
   3d538:	4625      	movne	r5, r4
		to_pin   = 31U;
   3d53a:	251f      	moveq	r5, #31
		from_pin = 0U;
   3d53c:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
   3d53e:	f04f 0801 	mov.w	r8, #1
	struct gpio_nrfx_data *data = get_port_data(port);
   3d542:	6887      	ldr	r7, [r0, #8]
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   3d544:	42ac      	cmp	r4, r5
   3d546:	d902      	bls.n	3d54e <gpio_nrfx_pin_enable_callback+0x24>
	return res;
   3d548:	2000      	movs	r0, #0
}
   3d54a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
   3d54e:	68fb      	ldr	r3, [r7, #12]
   3d550:	fa08 f204 	lsl.w	r2, r8, r4
   3d554:	4313      	orrs	r3, r2
   3d556:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
   3d558:	4621      	mov	r1, r4
   3d55a:	4630      	mov	r0, r6
   3d55c:	f7ec fbb0 	bl	29cc0 <gpiote_pin_int_cfg>
		if (res != 0) {
   3d560:	2800      	cmp	r0, #0
   3d562:	d1f2      	bne.n	3d54a <gpio_nrfx_pin_enable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   3d564:	3401      	adds	r4, #1
   3d566:	b2e4      	uxtb	r4, r4
   3d568:	e7ec      	b.n	3d544 <gpio_nrfx_pin_enable_callback+0x1a>

0003d56a <gpio_pin_write>:
{
   3d56a:	b410      	push	{r4}
   3d56c:	4613      	mov	r3, r2
	return api->write(port, access_op, pin, value);
   3d56e:	6842      	ldr	r2, [r0, #4]
   3d570:	6854      	ldr	r4, [r2, #4]
   3d572:	460a      	mov	r2, r1
   3d574:	46a4      	mov	ip, r4
   3d576:	2100      	movs	r1, #0
}
   3d578:	f85d 4b04 	ldr.w	r4, [sp], #4
	return api->write(port, access_op, pin, value);
   3d57c:	4760      	bx	ip

0003d57e <_spi_context_cs_control.isra.7>:
static inline void _spi_context_cs_control(struct spi_context *ctx,
   3d57e:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   3d580:	6804      	ldr	r4, [r0, #0]
static inline void _spi_context_cs_control(struct spi_context *ctx,
   3d582:	4605      	mov	r5, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   3d584:	b324      	cbz	r4, 3d5d0 <_spi_context_cs_control.isra.7+0x52>
   3d586:	68a3      	ldr	r3, [r4, #8]
   3d588:	b313      	cbz	r3, 3d5d0 <_spi_context_cs_control.isra.7+0x52>
   3d58a:	6818      	ldr	r0, [r3, #0]
   3d58c:	b300      	cbz	r0, 3d5d0 <_spi_context_cs_control.isra.7+0x52>
		if (on) {
   3d58e:	b161      	cbz	r1, 3d5aa <_spi_context_cs_control.isra.7+0x2c>
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   3d590:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
			gpio_pin_write(ctx->config->cs->gpio_dev,
   3d594:	6859      	ldr	r1, [r3, #4]
   3d596:	0fd2      	lsrs	r2, r2, #31
   3d598:	f7ff ffe7 	bl	3d56a <gpio_pin_write>
			k_busy_wait(ctx->config->cs->delay);
   3d59c:	682b      	ldr	r3, [r5, #0]
   3d59e:	689b      	ldr	r3, [r3, #8]
   3d5a0:	6898      	ldr	r0, [r3, #8]
}
   3d5a2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_busy_wait(usec_to_wait);
   3d5a6:	f001 b817 	b.w	3e5d8 <z_impl_k_busy_wait>
			if (!force_off &&
   3d5aa:	b912      	cbnz	r2, 3d5b2 <_spi_context_cs_control.isra.7+0x34>
   3d5ac:	88a2      	ldrh	r2, [r4, #4]
   3d5ae:	0492      	lsls	r2, r2, #18
   3d5b0:	d40e      	bmi.n	3d5d0 <_spi_context_cs_control.isra.7+0x52>
			k_busy_wait(ctx->config->cs->delay);
   3d5b2:	6898      	ldr	r0, [r3, #8]
   3d5b4:	f001 f810 	bl	3e5d8 <z_impl_k_busy_wait>
			gpio_pin_write(ctx->config->cs->gpio_dev,
   3d5b8:	682a      	ldr	r2, [r5, #0]
   3d5ba:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   3d5bc:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
			gpio_pin_write(ctx->config->cs->gpio_dev,
   3d5c0:	e9d3 0100 	ldrd	r0, r1, [r3]
   3d5c4:	43d2      	mvns	r2, r2
}
   3d5c6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_write(ctx->config->cs->gpio_dev,
   3d5ca:	0fd2      	lsrs	r2, r2, #31
   3d5cc:	f7ff bfcd 	b.w	3d56a <gpio_pin_write>
}
   3d5d0:	bd38      	pop	{r3, r4, r5, pc}

0003d5d2 <spi_context_unlock_unconditionally>:
{
   3d5d2:	b510      	push	{r4, lr}
	_spi_context_cs_control(ctx, false, true);
   3d5d4:	2201      	movs	r2, #1
   3d5d6:	2100      	movs	r1, #0
{
   3d5d8:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
   3d5da:	f7ff ffd0 	bl	3d57e <_spi_context_cs_control.isra.7>
	if (!k_sem_count_get(&ctx->lock)) {
   3d5de:	68e3      	ldr	r3, [r4, #12]
   3d5e0:	b923      	cbnz	r3, 3d5ec <spi_context_unlock_unconditionally+0x1a>
	z_impl_k_sem_give(sem);
   3d5e2:	1d20      	adds	r0, r4, #4
}
   3d5e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   3d5e8:	f7fa b9ac 	b.w	37944 <z_impl_k_sem_give>
   3d5ec:	bd10      	pop	{r4, pc}

0003d5ee <spi_2_init>:
#ifdef CONFIG_SPI_1_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(1);
#endif

#ifdef CONFIG_SPI_2_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(2);
   3d5ee:	b510      	push	{r4, lr}
   3d5f0:	4604      	mov	r4, r0
   3d5f2:	2200      	movs	r2, #0
   3d5f4:	200a      	movs	r0, #10
   3d5f6:	2101      	movs	r1, #1
   3d5f8:	f7ea fdac 	bl	28154 <z_arm_irq_priority_set>
   3d5fc:	4620      	mov	r0, r4
   3d5fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   3d602:	f7ec be49 	b.w	2a298 <init_spim>

0003d606 <spi_3_init>:
#endif

#ifdef CONFIG_SPI_3_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(3);
   3d606:	b510      	push	{r4, lr}
   3d608:	4604      	mov	r4, r0
   3d60a:	2200      	movs	r2, #0
   3d60c:	200b      	movs	r0, #11
   3d60e:	2101      	movs	r1, #1
   3d610:	f7ea fda0 	bl	28154 <z_arm_irq_priority_set>
   3d614:	4620      	mov	r0, r4
   3d616:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   3d61a:	f7ec be3d 	b.w	2a298 <init_spim>

0003d61e <spi_nrfx_release>:
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   3d61e:	6880      	ldr	r0, [r0, #8]
{
   3d620:	b510      	push	{r4, lr}
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   3d622:	6803      	ldr	r3, [r0, #0]
   3d624:	428b      	cmp	r3, r1
   3d626:	d106      	bne.n	3d636 <spi_nrfx_release+0x18>
	if (dev_data->busy) {
   3d628:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
   3d62c:	b934      	cbnz	r4, 3d63c <spi_nrfx_release+0x1e>
	spi_context_unlock_unconditionally(&dev_data->ctx);
   3d62e:	f7ff ffd0 	bl	3d5d2 <spi_context_unlock_unconditionally>
	return 0;
   3d632:	4620      	mov	r0, r4
}
   3d634:	bd10      	pop	{r4, pc}
		return -EINVAL;
   3d636:	f06f 0015 	mvn.w	r0, #21
   3d63a:	e7fb      	b.n	3d634 <spi_nrfx_release+0x16>
		return -EBUSY;
   3d63c:	f06f 000f 	mvn.w	r0, #15
   3d640:	e7f8      	b.n	3d634 <spi_nrfx_release+0x16>

0003d642 <flash_nrf_write_protection>:
}
   3d642:	2000      	movs	r0, #0
   3d644:	4770      	bx	lr

0003d646 <is_regular_addr_valid>:
{
   3d646:	b538      	push	{r3, r4, r5, lr}
   3d648:	4604      	mov	r4, r0
   3d64a:	460d      	mov	r5, r1
	size_t flash_size = nrfx_nvmc_flash_size_get();
   3d64c:	f000 fecb 	bl	3e3e6 <nrfx_nvmc_flash_size_get>
	if (addr >= flash_size ||
   3d650:	4284      	cmp	r4, r0
   3d652:	d209      	bcs.n	3d668 <is_regular_addr_valid+0x22>
   3d654:	2c00      	cmp	r4, #0
   3d656:	db07      	blt.n	3d668 <is_regular_addr_valid+0x22>
	    addr < 0 ||
   3d658:	42a8      	cmp	r0, r5
   3d65a:	d305      	bcc.n	3d668 <is_regular_addr_valid+0x22>
	    (addr) + len > flash_size) {
   3d65c:	442c      	add	r4, r5
	    len > flash_size ||
   3d65e:	4284      	cmp	r4, r0
   3d660:	bf8c      	ite	hi
   3d662:	2000      	movhi	r0, #0
   3d664:	2001      	movls	r0, #1
}
   3d666:	bd38      	pop	{r3, r4, r5, pc}
		return false;
   3d668:	2000      	movs	r0, #0
   3d66a:	e7fc      	b.n	3d666 <is_regular_addr_valid+0x20>

0003d66c <flash_nrf_read>:
{
   3d66c:	b570      	push	{r4, r5, r6, lr}
   3d66e:	460d      	mov	r5, r1
	if (is_regular_addr_valid(addr, len)) {
   3d670:	4619      	mov	r1, r3
   3d672:	4628      	mov	r0, r5
{
   3d674:	4616      	mov	r6, r2
   3d676:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   3d678:	f7ff ffe5 	bl	3d646 <is_regular_addr_valid>
   3d67c:	b170      	cbz	r0, 3d69c <flash_nrf_read+0x30>
	if (!len) {
   3d67e:	b184      	cbz	r4, 3d6a2 <flash_nrf_read+0x36>
	if (addr < PM_APP_ADDRESS) {
   3d680:	f5b5 3fe1 	cmp.w	r5, #115200	; 0x1c200
		return spm_request_read(data, addr, len);
   3d684:	4622      	mov	r2, r4
   3d686:	4629      	mov	r1, r5
   3d688:	4630      	mov	r0, r6
	if (addr < PM_APP_ADDRESS) {
   3d68a:	da03      	bge.n	3d694 <flash_nrf_read+0x28>
}
   3d68c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return spm_request_read(data, addr, len);
   3d690:	f7da bca6 	b.w	17fe0 <spm_request_read>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   3d694:	f001 f8da 	bl	3e84c <memcpy>
   3d698:	2000      	movs	r0, #0
}
   3d69a:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   3d69c:	f06f 0015 	mvn.w	r0, #21
   3d6a0:	e7fb      	b.n	3d69a <flash_nrf_read+0x2e>
		return 0;
   3d6a2:	4620      	mov	r0, r4
   3d6a4:	e7f9      	b.n	3d69a <flash_nrf_read+0x2e>

0003d6a6 <flash_get_page_info>:

#include <drivers/flash.h>

static int flash_get_page_info(struct device *dev, off_t offs,
				   bool use_addr, struct flash_pages_info *info)
{
   3d6a6:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   3d6aa:	461d      	mov	r5, r3
	off_t group_offs = 0;
	u32_t num_in_group;
	off_t end = 0;
	size_t layout_size;

	api->page_layout(dev, &layout, &layout_size);
   3d6ac:	6843      	ldr	r3, [r0, #4]
{
   3d6ae:	460c      	mov	r4, r1
	api->page_layout(dev, &layout, &layout_size);
   3d6b0:	691b      	ldr	r3, [r3, #16]
   3d6b2:	4669      	mov	r1, sp
{
   3d6b4:	4616      	mov	r6, r2
	api->page_layout(dev, &layout, &layout_size);
   3d6b6:	aa01      	add	r2, sp, #4
   3d6b8:	4798      	blx	r3

	while (layout_size--) {
   3d6ba:	e9dd 1200 	ldrd	r1, r2, [sp]
   3d6be:	2300      	movs	r3, #0
	off_t end = 0;
   3d6c0:	4618      	mov	r0, r3
	off_t group_offs = 0;
   3d6c2:	469e      	mov	lr, r3
	size_t page_count = 0;
   3d6c4:	469c      	mov	ip, r3
   3d6c6:	3a01      	subs	r2, #1
	while (layout_size--) {
   3d6c8:	1c57      	adds	r7, r2, #1
   3d6ca:	d102      	bne.n	3d6d2 <flash_get_page_info+0x2c>
		page_count += layout->pages_count;

		layout++;
	}

	return -EINVAL; /* page of the index doesn't exist */
   3d6cc:	f06f 0015 	mvn.w	r0, #21
   3d6d0:	e01a      	b.n	3d708 <flash_get_page_info+0x62>
		if (use_addr) {
   3d6d2:	f8d1 8000 	ldr.w	r8, [r1]
   3d6d6:	b1d6      	cbz	r6, 3d70e <flash_get_page_info+0x68>
			end += layout->pages_count * layout->pages_size;
   3d6d8:	684f      	ldr	r7, [r1, #4]
   3d6da:	fb07 0008 	mla	r0, r7, r8, r0
		if (offs < end) {
   3d6de:	42a0      	cmp	r0, r4
   3d6e0:	f102 37ff 	add.w	r7, r2, #4294967295
   3d6e4:	dd18      	ble.n	3d718 <flash_get_page_info+0x72>
   3d6e6:	9201      	str	r2, [sp, #4]
   3d6e8:	b103      	cbz	r3, 3d6ec <flash_get_page_info+0x46>
   3d6ea:	9100      	str	r1, [sp, #0]
			info->size = layout->pages_size;
   3d6ec:	9b00      	ldr	r3, [sp, #0]
   3d6ee:	685b      	ldr	r3, [r3, #4]
   3d6f0:	606b      	str	r3, [r5, #4]
			if (use_addr) {
   3d6f2:	b176      	cbz	r6, 3d712 <flash_get_page_info+0x6c>
				num_in_group = (offs - group_offs) /
   3d6f4:	eba4 040e 	sub.w	r4, r4, lr
   3d6f8:	fbb4 f4f3 	udiv	r4, r4, r3
			return 0;
   3d6fc:	2000      	movs	r0, #0
			info->start_offset = group_offs +
   3d6fe:	fb04 e303 	mla	r3, r4, r3, lr
			info->index = page_count + num_in_group;
   3d702:	4464      	add	r4, ip
			info->start_offset = group_offs +
   3d704:	602b      	str	r3, [r5, #0]
			info->index = page_count + num_in_group;
   3d706:	60ac      	str	r4, [r5, #8]
}
   3d708:	b002      	add	sp, #8
   3d70a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			end += layout->pages_count;
   3d70e:	4440      	add	r0, r8
   3d710:	e7e5      	b.n	3d6de <flash_get_page_info+0x38>
				num_in_group = offs - page_count;
   3d712:	eba4 040c 	sub.w	r4, r4, ip
   3d716:	e7f1      	b.n	3d6fc <flash_get_page_info+0x56>
		group_offs += layout->pages_count * layout->pages_size;
   3d718:	684b      	ldr	r3, [r1, #4]
		page_count += layout->pages_count;
   3d71a:	44c4      	add	ip, r8
		group_offs += layout->pages_count * layout->pages_size;
   3d71c:	fb03 ee08 	mla	lr, r3, r8, lr
		layout++;
   3d720:	3108      	adds	r1, #8
   3d722:	2301      	movs	r3, #1
   3d724:	463a      	mov	r2, r7
   3d726:	e7cf      	b.n	3d6c8 <flash_get_page_info+0x22>

0003d728 <z_impl_flash_get_page_info_by_offs>:

int z_impl_flash_get_page_info_by_offs(struct device *dev, off_t offs,
				      struct flash_pages_info *info)
{
	return flash_get_page_info(dev, offs, true, info);
   3d728:	4613      	mov	r3, r2
   3d72a:	2201      	movs	r2, #1
   3d72c:	f7ff bfbb 	b.w	3d6a6 <flash_get_page_info>

0003d730 <uarte_nrfx_isr_int>:
	if (data->int_driven->disable_tx_irq &&
   3d730:	6882      	ldr	r2, [r0, #8]
	return dev->config->config_info;
   3d732:	6803      	ldr	r3, [r0, #0]
	if (data->int_driven->disable_tx_irq &&
   3d734:	6892      	ldr	r2, [r2, #8]
	return config->uarte_regs;
   3d736:	689b      	ldr	r3, [r3, #8]
	if (data->int_driven->disable_tx_irq &&
   3d738:	7b91      	ldrb	r1, [r2, #14]
	return config->uarte_regs;
   3d73a:	681b      	ldr	r3, [r3, #0]
	if (data->int_driven->disable_tx_irq &&
   3d73c:	b159      	cbz	r1, 3d756 <uarte_nrfx_isr_int+0x26>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   3d73e:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
   3d742:	b141      	cbz	r1, 3d756 <uarte_nrfx_isr_int+0x26>
    p_reg->INTENCLR = mask;
   3d744:	f44f 7180 	mov.w	r1, #256	; 0x100
   3d748:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   3d74c:	2101      	movs	r1, #1
   3d74e:	60d9      	str	r1, [r3, #12]
		data->int_driven->disable_tx_irq = false;
   3d750:	2300      	movs	r3, #0
   3d752:	7393      	strb	r3, [r2, #14]
		return;
   3d754:	4770      	bx	lr
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   3d756:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ERROR)) {
   3d75a:	b111      	cbz	r1, 3d762 <uarte_nrfx_isr_int+0x32>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   3d75c:	2100      	movs	r1, #0
   3d75e:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
	if (data->int_driven->cb) {
   3d762:	6813      	ldr	r3, [r2, #0]
   3d764:	b10b      	cbz	r3, 3d76a <uarte_nrfx_isr_int+0x3a>
		data->int_driven->cb(data->int_driven->cb_data);
   3d766:	6850      	ldr	r0, [r2, #4]
   3d768:	4718      	bx	r3
}
   3d76a:	4770      	bx	lr

0003d76c <uarte_nrfx_config_get>:
{
   3d76c:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   3d76e:	6882      	ldr	r2, [r0, #8]
   3d770:	e892 0003 	ldmia.w	r2, {r0, r1}
   3d774:	e883 0003 	stmia.w	r3, {r0, r1}
}
   3d778:	2000      	movs	r0, #0
   3d77a:	4770      	bx	lr

0003d77c <uarte_nrfx_err_check>:
	return dev->config->config_info;
   3d77c:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   3d77e:	689b      	ldr	r3, [r3, #8]
   3d780:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   3d782:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   3d786:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   3d78a:	4770      	bx	lr

0003d78c <uarte_nrfx_poll_in>:
	return dev->config->config_info;
   3d78c:	6803      	ldr	r3, [r0, #0]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   3d78e:	6882      	ldr	r2, [r0, #8]
	return config->uarte_regs;
   3d790:	689b      	ldr	r3, [r3, #8]
   3d792:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   3d794:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   3d798:	b138      	cbz	r0, 3d7aa <uarte_nrfx_poll_in+0x1e>
	*c = data->rx_data;
   3d79a:	7b12      	ldrb	r2, [r2, #12]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   3d79c:	2000      	movs	r0, #0
   3d79e:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   3d7a0:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   3d7a2:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   3d7a6:	601a      	str	r2, [r3, #0]
	return 0;
   3d7a8:	4770      	bx	lr
		return -1;
   3d7aa:	f04f 30ff 	mov.w	r0, #4294967295
}
   3d7ae:	4770      	bx	lr

0003d7b0 <uarte_nrfx_poll_out>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   3d7b0:	2200      	movs	r2, #0
	return dev->config->config_info;
   3d7b2:	6803      	ldr	r3, [r0, #0]
{
   3d7b4:	b082      	sub	sp, #8
	return config->uarte_regs;
   3d7b6:	689b      	ldr	r3, [r3, #8]
{
   3d7b8:	f88d 1007 	strb.w	r1, [sp, #7]
	return config->uarte_regs;
   3d7bc:	681b      	ldr	r3, [r3, #0]
   3d7be:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   3d7c2:	f10d 0207 	add.w	r2, sp, #7
   3d7c6:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   3d7ca:	2201      	movs	r2, #1
   3d7cc:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   3d7d0:	609a      	str	r2, [r3, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   3d7d2:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	while (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   3d7d6:	2900      	cmp	r1, #0
   3d7d8:	d0fb      	beq.n	3d7d2 <uarte_nrfx_poll_out+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   3d7da:	60da      	str	r2, [r3, #12]
}
   3d7dc:	b002      	add	sp, #8
   3d7de:	4770      	bx	lr

0003d7e0 <uarte_nrfx_fifo_fill>:
	return dev->config->config_info;
   3d7e0:	6803      	ldr	r3, [r0, #0]
{
   3d7e2:	b570      	push	{r4, r5, r6, lr}
	return config->uarte_regs;
   3d7e4:	689b      	ldr	r3, [r3, #8]
   3d7e6:	681c      	ldr	r4, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   3d7e8:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   3d7ec:	b1bb      	cbz	r3, 3d81e <uarte_nrfx_fifo_fill+0x3e>
	struct uarte_nrfx_data *data = get_dev_data(dev);
   3d7ee:	6885      	ldr	r5, [r0, #8]
	if (len > data->int_driven->tx_buff_size) {
   3d7f0:	68ab      	ldr	r3, [r5, #8]
   3d7f2:	8998      	ldrh	r0, [r3, #12]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   3d7f4:	2300      	movs	r3, #0
   3d7f6:	4290      	cmp	r0, r2
   3d7f8:	bfa8      	it	ge
   3d7fa:	4610      	movge	r0, r2
   3d7fc:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
	for (int i = 0; i < len; i++) {
   3d800:	68aa      	ldr	r2, [r5, #8]
   3d802:	4283      	cmp	r3, r0
   3d804:	6892      	ldr	r2, [r2, #8]
   3d806:	db06      	blt.n	3d816 <uarte_nrfx_fifo_fill+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   3d808:	2301      	movs	r3, #1
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   3d80a:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   3d80e:	f8c4 0548 	str.w	r0, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   3d812:	60a3      	str	r3, [r4, #8]
}
   3d814:	bd70      	pop	{r4, r5, r6, pc}
		data->int_driven->tx_buffer[i] = tx_data[i];
   3d816:	5cce      	ldrb	r6, [r1, r3]
   3d818:	54d6      	strb	r6, [r2, r3]
	for (int i = 0; i < len; i++) {
   3d81a:	3301      	adds	r3, #1
   3d81c:	e7f0      	b.n	3d800 <uarte_nrfx_fifo_fill+0x20>
		return 0;
   3d81e:	4618      	mov	r0, r3
   3d820:	e7f8      	b.n	3d814 <uarte_nrfx_fifo_fill+0x34>

0003d822 <uarte_nrfx_fifo_read>:
	return dev->config->config_info;
   3d822:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   3d824:	689b      	ldr	r3, [r3, #8]
   3d826:	681a      	ldr	r2, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   3d828:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   3d82c:	b143      	cbz	r3, 3d840 <uarte_nrfx_fifo_read+0x1e>
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   3d82e:	6883      	ldr	r3, [r0, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   3d830:	2000      	movs	r0, #0
   3d832:	f8c2 0110 	str.w	r0, [r2, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   3d836:	2001      	movs	r0, #1
		rx_data[num_rx++] = (u8_t)data->rx_data;
   3d838:	7b1b      	ldrb	r3, [r3, #12]
   3d83a:	700b      	strb	r3, [r1, #0]
   3d83c:	6010      	str	r0, [r2, #0]
   3d83e:	4770      	bx	lr
	int num_rx = 0;
   3d840:	4618      	mov	r0, r3
}
   3d842:	4770      	bx	lr

0003d844 <uarte_nrfx_irq_tx_enable>:
	data->int_driven->disable_tx_irq = false;
   3d844:	2100      	movs	r1, #0
	return dev->config->config_info;
   3d846:	6803      	ldr	r3, [r0, #0]
	data->int_driven->disable_tx_irq = false;
   3d848:	6882      	ldr	r2, [r0, #8]
	return config->uarte_regs;
   3d84a:	689b      	ldr	r3, [r3, #8]
	data->int_driven->disable_tx_irq = false;
   3d84c:	6892      	ldr	r2, [r2, #8]
	return config->uarte_regs;
   3d84e:	681b      	ldr	r3, [r3, #0]
	data->int_driven->disable_tx_irq = false;
   3d850:	7391      	strb	r1, [r2, #14]
    p_reg->INTENSET = mask;
   3d852:	f44f 7280 	mov.w	r2, #256	; 0x100
   3d856:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   3d85a:	4770      	bx	lr

0003d85c <uarte_nrfx_irq_tx_disable>:
	data->int_driven->disable_tx_irq = true;
   3d85c:	2201      	movs	r2, #1
   3d85e:	6883      	ldr	r3, [r0, #8]
   3d860:	689b      	ldr	r3, [r3, #8]
   3d862:	739a      	strb	r2, [r3, #14]
}
   3d864:	4770      	bx	lr

0003d866 <uarte_nrfx_irq_tx_ready_complete>:
	return dev->config->config_info;
   3d866:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   3d868:	689b      	ldr	r3, [r3, #8]
   3d86a:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   3d86c:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX) &&
   3d870:	b118      	cbz	r0, 3d87a <uarte_nrfx_irq_tx_ready_complete+0x14>
    return p_reg->INTENSET & mask;
   3d872:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
   3d876:	f3c0 2000 	ubfx	r0, r0, #8, #1
}
   3d87a:	4770      	bx	lr

0003d87c <uarte_nrfx_irq_rx_ready>:
	return dev->config->config_info;
   3d87c:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   3d87e:	689b      	ldr	r3, [r3, #8]
   3d880:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   3d882:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
}
   3d886:	3000      	adds	r0, #0
   3d888:	bf18      	it	ne
   3d88a:	2001      	movne	r0, #1
   3d88c:	4770      	bx	lr

0003d88e <uarte_nrfx_irq_rx_enable>:
    p_reg->INTENSET = mask;
   3d88e:	2210      	movs	r2, #16
	return dev->config->config_info;
   3d890:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   3d892:	689b      	ldr	r3, [r3, #8]
   3d894:	681b      	ldr	r3, [r3, #0]
   3d896:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   3d89a:	4770      	bx	lr

0003d89c <uarte_nrfx_irq_rx_disable>:
    p_reg->INTENCLR = mask;
   3d89c:	2210      	movs	r2, #16
	return dev->config->config_info;
   3d89e:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   3d8a0:	689b      	ldr	r3, [r3, #8]
   3d8a2:	681b      	ldr	r3, [r3, #0]
   3d8a4:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   3d8a8:	4770      	bx	lr

0003d8aa <uarte_nrfx_irq_err_enable>:
    p_reg->INTENSET = mask;
   3d8aa:	f44f 7200 	mov.w	r2, #512	; 0x200
	return dev->config->config_info;
   3d8ae:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   3d8b0:	689b      	ldr	r3, [r3, #8]
   3d8b2:	681b      	ldr	r3, [r3, #0]
   3d8b4:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   3d8b8:	4770      	bx	lr

0003d8ba <uarte_nrfx_irq_err_disable>:
    p_reg->INTENCLR = mask;
   3d8ba:	f44f 7200 	mov.w	r2, #512	; 0x200
	return dev->config->config_info;
   3d8be:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   3d8c0:	689b      	ldr	r3, [r3, #8]
   3d8c2:	681b      	ldr	r3, [r3, #0]
   3d8c4:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   3d8c8:	4770      	bx	lr

0003d8ca <uarte_nrfx_irq_update>:
}
   3d8ca:	2001      	movs	r0, #1
   3d8cc:	4770      	bx	lr

0003d8ce <uarte_nrfx_irq_callback_set>:
	data->int_driven->cb = cb;
   3d8ce:	6883      	ldr	r3, [r0, #8]
   3d8d0:	689b      	ldr	r3, [r3, #8]
	data->int_driven->cb_data = cb_data;
   3d8d2:	e9c3 1200 	strd	r1, r2, [r3]
}
   3d8d6:	4770      	bx	lr

0003d8d8 <uarte_nrfx_irq_is_pending>:
{
   3d8d8:	b508      	push	{r3, lr}
	return dev->config->config_info;
   3d8da:	6803      	ldr	r3, [r0, #0]
{
   3d8dc:	4602      	mov	r2, r0
	return config->uarte_regs;
   3d8de:	689b      	ldr	r3, [r3, #8]
   3d8e0:	6819      	ldr	r1, [r3, #0]
    return p_reg->INTENSET & mask;
   3d8e2:	f8d1 3304 	ldr.w	r3, [r1, #772]	; 0x304
		||
   3d8e6:	05db      	lsls	r3, r3, #23
   3d8e8:	d405      	bmi.n	3d8f6 <uarte_nrfx_irq_is_pending+0x1e>
   3d8ea:	f8d1 0304 	ldr.w	r0, [r1, #772]	; 0x304
   3d8ee:	f010 0010 	ands.w	r0, r0, #16
   3d8f2:	d106      	bne.n	3d902 <uarte_nrfx_irq_is_pending+0x2a>
}
   3d8f4:	bd08      	pop	{r3, pc}
		 uarte_nrfx_irq_tx_ready_complete(dev))
   3d8f6:	f7ff ffb6 	bl	3d866 <uarte_nrfx_irq_tx_ready_complete>
					    NRF_UARTE_INT_ENDTX_MASK) &&
   3d8fa:	2800      	cmp	r0, #0
   3d8fc:	d0f5      	beq.n	3d8ea <uarte_nrfx_irq_is_pending+0x12>
		||
   3d8fe:	2001      	movs	r0, #1
   3d900:	e7f8      	b.n	3d8f4 <uarte_nrfx_irq_is_pending+0x1c>
		 uarte_nrfx_irq_rx_ready(dev)));
   3d902:	4610      	mov	r0, r2
   3d904:	f7ff ffba 	bl	3d87c <uarte_nrfx_irq_rx_ready>
					    NRF_UARTE_INT_ENDRX_MASK) &&
   3d908:	3000      	adds	r0, #0
   3d90a:	bf18      	it	ne
   3d90c:	2001      	movne	r0, #1
   3d90e:	e7f1      	b.n	3d8f4 <uarte_nrfx_irq_is_pending+0x1c>

0003d910 <entropy_cc310_rng_init>:
{
	/* No initialization is required */
	(void)dev;

	return 0;
}
   3d910:	2000      	movs	r0, #0
   3d912:	4770      	bx	lr

0003d914 <trace_proxy_irq_handler>:
ISR_DIRECT_DECLARE(trace_proxy_irq_handler)
   3d914:	4668      	mov	r0, sp
   3d916:	f020 0107 	bic.w	r1, r0, #7
   3d91a:	468d      	mov	sp, r1
   3d91c:	b501      	push	{r0, lr}
	bsd_os_trace_irq_handler();
   3d91e:	f7f1 f9ab 	bl	2ec78 <bsd_os_trace_irq_handler>
	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   3d922:	f7ea fc49 	bl	281b8 <_arch_isr_direct_pm>
   3d926:	f7ea fb31 	bl	27f8c <z_arm_exc_exit>
ISR_DIRECT_DECLARE(trace_proxy_irq_handler)
   3d92a:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   3d92e:	4685      	mov	sp, r0
   3d930:	4770      	bx	lr

0003d932 <ipc_proxy_irq_handler>:
ISR_DIRECT_DECLARE(ipc_proxy_irq_handler)
   3d932:	4668      	mov	r0, sp
   3d934:	f020 0107 	bic.w	r1, r0, #7
   3d938:	468d      	mov	sp, r1
   3d93a:	b501      	push	{r0, lr}
	IPC_IRQHandler();
   3d93c:	f7f1 fd94 	bl	2f468 <IPC_IRQHandler>
	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   3d940:	f7ea fc3a 	bl	281b8 <_arch_isr_direct_pm>
   3d944:	f7ea fb22 	bl	27f8c <z_arm_exc_exit>
ISR_DIRECT_DECLARE(ipc_proxy_irq_handler)
   3d948:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   3d94c:	4685      	mov	sp, r0
   3d94e:	4770      	bx	lr

0003d950 <trace_task_create>:
{
   3d950:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(TRACE_IRQ, TRACE_IRQ_PRIORITY,
   3d952:	201d      	movs	r0, #29
   3d954:	2200      	movs	r2, #0
   3d956:	2106      	movs	r1, #6
   3d958:	f7ea fbfc 	bl	28154 <z_arm_irq_priority_set>
}
   3d95c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(TRACE_IRQ);
   3d960:	201d      	movs	r0, #29
   3d962:	f7ea bbe7 	b.w	28134 <arch_irq_enable>

0003d966 <read_task_create>:
{
   3d966:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(BSD_APPLICATION_IRQ, BSD_APPLICATION_IRQ_PRIORITY,
   3d968:	201c      	movs	r0, #28
   3d96a:	2200      	movs	r2, #0
   3d96c:	2106      	movs	r1, #6
   3d96e:	f7ea fbf1 	bl	28154 <z_arm_irq_priority_set>
}
   3d972:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(BSD_APPLICATION_IRQ);
   3d976:	201c      	movs	r0, #28
   3d978:	f7ea bbdc 	b.w	28134 <arch_irq_enable>

0003d97c <bsd_os_trace_put>:
		remaining_bytes -= transfer_len;
	}
#endif

	return 0;
}
   3d97c:	2000      	movs	r0, #0
   3d97e:	4770      	bx	lr

0003d980 <z_to_nrf_flags>:
		nrf_flags |= NRF_MSG_DONTWAIT;
   3d980:	f010 0340 	ands.w	r3, r0, #64	; 0x40
   3d984:	bf18      	it	ne
   3d986:	2302      	movne	r3, #2
	if (z_flags & MSG_PEEK) {
   3d988:	0782      	lsls	r2, r0, #30
		nrf_flags |= NRF_MSG_PEEK;
   3d98a:	bf48      	it	mi
   3d98c:	f043 0308 	orrmi.w	r3, r3, #8
}
   3d990:	4618      	mov	r0, r3
   3d992:	4770      	bx	lr

0003d994 <z_to_nrf_family>:
	switch (z_family) {
   3d994:	2803      	cmp	r0, #3
   3d996:	d00f      	beq.n	3d9b8 <z_to_nrf_family+0x24>
   3d998:	d808      	bhi.n	3d9ac <z_to_nrf_family+0x18>
   3d99a:	2801      	cmp	r0, #1
   3d99c:	d00e      	beq.n	3d9bc <z_to_nrf_family+0x28>
   3d99e:	2802      	cmp	r0, #2
		return -EAFNOSUPPORT;
   3d9a0:	bf08      	it	eq
   3d9a2:	200a      	moveq	r0, #10
   3d9a4:	bf18      	it	ne
   3d9a6:	f06f 0069 	mvnne.w	r0, #105	; 0x69
   3d9aa:	4770      	bx	lr
	switch (z_family) {
   3d9ac:	2866      	cmp	r0, #102	; 0x66
   3d9ae:	d006      	beq.n	3d9be <z_to_nrf_family+0x2a>
   3d9b0:	2867      	cmp	r0, #103	; 0x67
		return -EAFNOSUPPORT;
   3d9b2:	bf08      	it	eq
   3d9b4:	2001      	moveq	r0, #1
   3d9b6:	e7f5      	b.n	3d9a4 <z_to_nrf_family+0x10>
		return NRF_AF_PACKET;
   3d9b8:	2005      	movs	r0, #5
   3d9ba:	4770      	bx	lr
		return NRF_AF_INET;
   3d9bc:	2002      	movs	r0, #2
}
   3d9be:	4770      	bx	lr

0003d9c0 <z_to_nrf_protocol>:
	switch (proto) {
   3d9c0:	f5b0 7f81 	cmp.w	r0, #258	; 0x102
   3d9c4:	d01d      	beq.n	3da02 <z_to_nrf_protocol+0x42>
   3d9c6:	dc08      	bgt.n	3d9da <z_to_nrf_protocol+0x1a>
   3d9c8:	2806      	cmp	r0, #6
   3d9ca:	d01d      	beq.n	3da08 <z_to_nrf_protocol+0x48>
   3d9cc:	2811      	cmp	r0, #17
   3d9ce:	d01d      	beq.n	3da0c <z_to_nrf_protocol+0x4c>
   3d9d0:	2800      	cmp	r0, #0
		return -EPROTONOSUPPORT;
   3d9d2:	bf18      	it	ne
   3d9d4:	f06f 007a 	mvnne.w	r0, #122	; 0x7a
   3d9d8:	4770      	bx	lr
	switch (proto) {
   3d9da:	f240 2301 	movw	r3, #513	; 0x201
   3d9de:	4298      	cmp	r0, r3
   3d9e0:	d015      	beq.n	3da0e <z_to_nrf_protocol+0x4e>
   3d9e2:	dc06      	bgt.n	3d9f2 <z_to_nrf_protocol+0x32>
   3d9e4:	f240 1311 	movw	r3, #273	; 0x111
   3d9e8:	4298      	cmp	r0, r3
		return -EPROTONOSUPPORT;
   3d9ea:	bf08      	it	eq
   3d9ec:	f44f 7087 	moveq.w	r0, #270	; 0x10e
   3d9f0:	e7ef      	b.n	3d9d2 <z_to_nrf_protocol+0x12>
	switch (proto) {
   3d9f2:	f240 2302 	movw	r3, #514	; 0x202
   3d9f6:	4298      	cmp	r0, r3
   3d9f8:	d009      	beq.n	3da0e <z_to_nrf_protocol+0x4e>
   3d9fa:	f240 2303 	movw	r3, #515	; 0x203
   3d9fe:	4298      	cmp	r0, r3
   3da00:	e7e7      	b.n	3d9d2 <z_to_nrf_protocol+0x12>
		return NRF_SPROTO_TLS1v2;
   3da02:	f44f 7082 	mov.w	r0, #260	; 0x104
   3da06:	4770      	bx	lr
		return NRF_IPPROTO_TCP;
   3da08:	2001      	movs	r0, #1
   3da0a:	4770      	bx	lr
		return NRF_IPPROTO_UDP;
   3da0c:	2002      	movs	r0, #2
}
   3da0e:	4770      	bx	lr

0003da10 <nrf91_bsdlib_socket_offload_init>:
}
   3da10:	2000      	movs	r0, #0
   3da12:	4770      	bx	lr

0003da14 <nrf91_socket_offload_freeaddrinfo>:
{
   3da14:	b538      	push	{r3, r4, r5, lr}
   3da16:	4604      	mov	r4, r0
	while (next != NULL) {
   3da18:	b904      	cbnz	r4, 3da1c <nrf91_socket_offload_freeaddrinfo+0x8>
}
   3da1a:	bd38      	pop	{r3, r4, r5, pc}
		k_free(this->ai_addr);
   3da1c:	6960      	ldr	r0, [r4, #20]
		next = next->ai_next;
   3da1e:	69e5      	ldr	r5, [r4, #28]
		k_free(this->ai_addr);
   3da20:	f000 fd45 	bl	3e4ae <k_free>
		k_free(this);
   3da24:	4620      	mov	r0, r4
   3da26:	f000 fd42 	bl	3e4ae <k_free>
		next = next->ai_next;
   3da2a:	462c      	mov	r4, r5
   3da2c:	e7f4      	b.n	3da18 <nrf91_socket_offload_freeaddrinfo+0x4>

0003da2e <z_to_nrf_addrinfo_hints>:
{
   3da2e:	b538      	push	{r3, r4, r5, lr}
   3da30:	460c      	mov	r4, r1
   3da32:	4605      	mov	r5, r0
__ssp_bos_icheck3(memset, void *, int)
   3da34:	221c      	movs	r2, #28
   3da36:	2100      	movs	r1, #0
   3da38:	1d20      	adds	r0, r4, #4
   3da3a:	f000 ff27 	bl	3e88c <memset>
	nrf_out->ai_flags = z_to_nrf_addrinfo_flags(z_in->ai_flags);
   3da3e:	2300      	movs	r3, #0
   3da40:	6023      	str	r3, [r4, #0]
	nrf_out->ai_socktype = z_to_nrf_socktype(z_in->ai_socktype);
   3da42:	68ab      	ldr	r3, [r5, #8]
	switch (socktype) {
   3da44:	2b03      	cmp	r3, #3
   3da46:	d003      	beq.n	3da50 <z_to_nrf_addrinfo_hints+0x22>
		return NRF_SOCK_MGMT;
   3da48:	2b04      	cmp	r3, #4
   3da4a:	bf08      	it	eq
   3da4c:	f44f 7300 	moveq.w	r3, #512	; 0x200
	nrf_out->ai_socktype = z_to_nrf_socktype(z_in->ai_socktype);
   3da50:	60a3      	str	r3, [r4, #8]
	family = z_to_nrf_family(z_in->ai_family);
   3da52:	88a8      	ldrh	r0, [r5, #4]
   3da54:	f7ff ff9e 	bl	3d994 <z_to_nrf_family>
	if (family == -EAFNOSUPPORT) {
   3da58:	f110 0f6a 	cmn.w	r0, #106	; 0x6a
   3da5c:	d00b      	beq.n	3da76 <z_to_nrf_addrinfo_hints+0x48>
	nrf_out->ai_family = family;
   3da5e:	6060      	str	r0, [r4, #4]
	nrf_out->ai_protocol = z_to_nrf_protocol(z_in->ai_protocol);
   3da60:	68e8      	ldr	r0, [r5, #12]
   3da62:	f7ff ffad 	bl	3d9c0 <z_to_nrf_protocol>
	if (nrf_out->ai_protocol == -EPROTONOSUPPORT) {
   3da66:	f110 0f7b 	cmn.w	r0, #123	; 0x7b
	nrf_out->ai_protocol = z_to_nrf_protocol(z_in->ai_protocol);
   3da6a:	60e0      	str	r0, [r4, #12]
	if (nrf_out->ai_protocol == -EPROTONOSUPPORT) {
   3da6c:	d003      	beq.n	3da76 <z_to_nrf_addrinfo_hints+0x48>
	if (z_in->ai_canonname != NULL) {
   3da6e:	69a8      	ldr	r0, [r5, #24]
   3da70:	b108      	cbz	r0, 3da76 <z_to_nrf_addrinfo_hints+0x48>
		nrf_out->ai_canonname = z_in->ai_canonname;
   3da72:	61a0      	str	r0, [r4, #24]
	return 0;
   3da74:	2000      	movs	r0, #0
}
   3da76:	bd38      	pop	{r3, r4, r5, pc}

0003da78 <nrf91_socket_offload_send>:
{
   3da78:	b570      	push	{r4, r5, r6, lr}
   3da7a:	4604      	mov	r4, r0
	return nrf_send(sd, buf, len, z_to_nrf_flags(flags));
   3da7c:	4618      	mov	r0, r3
{
   3da7e:	4615      	mov	r5, r2
	return nrf_send(sd, buf, len, z_to_nrf_flags(flags));
   3da80:	f7ff ff7e 	bl	3d980 <z_to_nrf_flags>
   3da84:	462a      	mov	r2, r5
   3da86:	4603      	mov	r3, r0
   3da88:	4620      	mov	r0, r4
}
   3da8a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return nrf_send(sd, buf, len, z_to_nrf_flags(flags));
   3da8e:	f7f3 ba33 	b.w	30ef8 <nrf_send>

0003da92 <nrf91_socket_offload_recv>:
{
   3da92:	b570      	push	{r4, r5, r6, lr}
   3da94:	4604      	mov	r4, r0
	return nrf_recv(sd, buf, max_len, z_to_nrf_flags(flags));
   3da96:	4618      	mov	r0, r3
{
   3da98:	4615      	mov	r5, r2
	return nrf_recv(sd, buf, max_len, z_to_nrf_flags(flags));
   3da9a:	f7ff ff71 	bl	3d980 <z_to_nrf_flags>
   3da9e:	462a      	mov	r2, r5
   3daa0:	4603      	mov	r3, r0
   3daa2:	4620      	mov	r0, r4
}
   3daa4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return nrf_recv(sd, buf, max_len, z_to_nrf_flags(flags));
   3daa8:	f7f3 ba5c 	b.w	30f64 <nrf_recv>

0003daac <nrf91_socket_offload_getsockopt>:
{
   3daac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3dab0:	461d      	mov	r5, r3
	struct nrf_timeval nrf_rcvtimeo = {0, 0};
   3dab2:	2300      	movs	r3, #0
{
   3dab4:	b086      	sub	sp, #24
   3dab6:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
	struct nrf_timeval nrf_rcvtimeo = {0, 0};
   3daba:	e9cd 3304 	strd	r3, r3, [sp, #16]
	nrf_socklen_t nrf_optlen = (nrf_socklen_t)*optlen;
   3dabe:	f8d8 3000 	ldr.w	r3, [r8]
	switch (z_in_level) {
   3dac2:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
{
   3dac6:	4607      	mov	r7, r0
   3dac8:	460c      	mov	r4, r1
   3daca:	4616      	mov	r6, r2
	nrf_socklen_t nrf_optlen = (nrf_socklen_t)*optlen;
   3dacc:	9303      	str	r3, [sp, #12]
	switch (z_in_level) {
   3dace:	d002      	beq.n	3dad6 <nrf91_socket_offload_getsockopt+0x2a>
   3dad0:	dc2b      	bgt.n	3db2a <nrf91_socket_offload_getsockopt+0x7e>
   3dad2:	2901      	cmp	r1, #1
   3dad4:	d13d      	bne.n	3db52 <nrf91_socket_offload_getsockopt+0xa6>
	if (z_to_nrf_optname(level, optname, &nrf_optname) < 0)
   3dad6:	aa02      	add	r2, sp, #8
   3dad8:	4631      	mov	r1, r6
   3dada:	4620      	mov	r0, r4
   3dadc:	f7ed f9a0 	bl	2ae20 <z_to_nrf_optname>
   3dae0:	2800      	cmp	r0, #0
   3dae2:	db36      	blt.n	3db52 <nrf91_socket_offload_getsockopt+0xa6>
	if ((level == SOL_SOCKET) && (optname == SO_RCVTIMEO)) {
   3dae4:	2c01      	cmp	r4, #1
   3dae6:	d128      	bne.n	3db3a <nrf91_socket_offload_getsockopt+0x8e>
   3dae8:	2e14      	cmp	r6, #20
   3daea:	d126      	bne.n	3db3a <nrf91_socket_offload_getsockopt+0x8e>
		nrf_optlen = sizeof(struct nrf_timeval);
   3daec:	2308      	movs	r3, #8
   3daee:	9303      	str	r3, [sp, #12]
		nrf_optval = &nrf_rcvtimeo;
   3daf0:	ab04      	add	r3, sp, #16
	retval = nrf_getsockopt(sd, nrf_level, nrf_optname, nrf_optval,
   3daf2:	aa03      	add	r2, sp, #12
   3daf4:	9200      	str	r2, [sp, #0]
   3daf6:	4638      	mov	r0, r7
   3daf8:	9a02      	ldr	r2, [sp, #8]
   3dafa:	4621      	mov	r1, r4
   3dafc:	f7f3 fab2 	bl	31064 <nrf_getsockopt>
	if ((retval == 0) && (optval != NULL)) {
   3db00:	4607      	mov	r7, r0
   3db02:	b970      	cbnz	r0, 3db22 <nrf91_socket_offload_getsockopt+0x76>
   3db04:	b16d      	cbz	r5, 3db22 <nrf91_socket_offload_getsockopt+0x76>
		*optlen = nrf_optlen;
   3db06:	9b03      	ldr	r3, [sp, #12]
		if (level == SOL_SOCKET) {
   3db08:	2c01      	cmp	r4, #1
		*optlen = nrf_optlen;
   3db0a:	f8c8 3000 	str.w	r3, [r8]
		if (level == SOL_SOCKET) {
   3db0e:	d108      	bne.n	3db22 <nrf91_socket_offload_getsockopt+0x76>
			if (optname == SO_ERROR) {
   3db10:	2e04      	cmp	r6, #4
   3db12:	d114      	bne.n	3db3e <nrf91_socket_offload_getsockopt+0x92>
				bsd_os_errno_set(*(int *)optval);
   3db14:	6828      	ldr	r0, [r5, #0]
   3db16:	f7ed f855 	bl	2abc4 <bsd_os_errno_set>
				*(int *)optval = errno;
   3db1a:	f7ff f802 	bl	3cb22 <__errno>
   3db1e:	6803      	ldr	r3, [r0, #0]
   3db20:	602b      	str	r3, [r5, #0]
}
   3db22:	4638      	mov	r0, r7
   3db24:	b006      	add	sp, #24
   3db26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (z_in_level) {
   3db2a:	f240 2302 	movw	r3, #514	; 0x202
   3db2e:	4299      	cmp	r1, r3
   3db30:	d0d1      	beq.n	3dad6 <nrf91_socket_offload_getsockopt+0x2a>
   3db32:	f240 2303 	movw	r3, #515	; 0x203
   3db36:	4299      	cmp	r1, r3
   3db38:	e7cc      	b.n	3dad4 <nrf91_socket_offload_getsockopt+0x28>
   3db3a:	462b      	mov	r3, r5
   3db3c:	e7d9      	b.n	3daf2 <nrf91_socket_offload_getsockopt+0x46>
			} else if (optname == SO_RCVTIMEO) {
   3db3e:	2e14      	cmp	r6, #20
   3db40:	d1ef      	bne.n	3db22 <nrf91_socket_offload_getsockopt+0x76>
				((struct timeval *)optval)->tv_sec =
   3db42:	9b04      	ldr	r3, [sp, #16]
   3db44:	602b      	str	r3, [r5, #0]
				((struct timeval *)optval)->tv_usec =
   3db46:	9b05      	ldr	r3, [sp, #20]
   3db48:	606b      	str	r3, [r5, #4]
				*optlen = sizeof(struct timeval);
   3db4a:	2308      	movs	r3, #8
   3db4c:	f8c8 3000 	str.w	r3, [r8]
   3db50:	e7e7      	b.n	3db22 <nrf91_socket_offload_getsockopt+0x76>
	errno = ENOPROTOOPT;
   3db52:	f7fe ffe6 	bl	3cb22 <__errno>
   3db56:	236d      	movs	r3, #109	; 0x6d
	return retval;
   3db58:	f04f 37ff 	mov.w	r7, #4294967295
	errno = ENOPROTOOPT;
   3db5c:	6003      	str	r3, [r0, #0]
	return retval;
   3db5e:	e7e0      	b.n	3db22 <nrf91_socket_offload_getsockopt+0x76>

0003db60 <nrf91_socket_offload_poll>:
{
   3db60:	b5f0      	push	{r4, r5, r6, r7, lr}
   3db62:	b091      	sub	sp, #68	; 0x44
   3db64:	4605      	mov	r5, r0
   3db66:	460c      	mov	r4, r1
   3db68:	4616      	mov	r6, r2
	struct nrf_pollfd tmp[BSD_MAX_SOCKET_COUNT] = {0};
   3db6a:	2100      	movs	r1, #0
   3db6c:	2240      	movs	r2, #64	; 0x40
   3db6e:	4668      	mov	r0, sp
   3db70:	f000 fe8c 	bl	3e88c <memset>
	for (int i = 0; i < nfds; i++) {
   3db74:	466a      	mov	r2, sp
   3db76:	2100      	movs	r1, #0
		if (fds[i].events & POLLIN) {
   3db78:	1d2f      	adds	r7, r5, #4
	for (int i = 0; i < nfds; i++) {
   3db7a:	42a1      	cmp	r1, r4
   3db7c:	db0c      	blt.n	3db98 <nrf91_socket_offload_poll+0x38>
	retval = nrf_poll((struct nrf_pollfd *)&tmp, nfds, timeout);
   3db7e:	4632      	mov	r2, r6
   3db80:	4621      	mov	r1, r4
   3db82:	4668      	mov	r0, sp
   3db84:	f7f3 fa8e 	bl	310a4 <nrf_poll>
	for (int i = 0; i < nfds; i++) {
   3db88:	2200      	movs	r2, #0
   3db8a:	462b      	mov	r3, r5
		fds[i].revents = 0;
   3db8c:	4616      	mov	r6, r2
			fds[i].revents |= POLLIN;
   3db8e:	2701      	movs	r7, #1
	for (int i = 0; i < nfds; i++) {
   3db90:	42a2      	cmp	r2, r4
   3db92:	db1a      	blt.n	3dbca <nrf91_socket_offload_poll+0x6a>
}
   3db94:	b011      	add	sp, #68	; 0x44
   3db96:	bdf0      	pop	{r4, r5, r6, r7, pc}
		tmp[i].handle = fds[i].fd;
   3db98:	f855 3031 	ldr.w	r3, [r5, r1, lsl #3]
		if (fds[i].events & POLLIN) {
   3db9c:	f837 0031 	ldrh.w	r0, [r7, r1, lsl #3]
		tmp[i].handle = fds[i].fd;
   3dba0:	6013      	str	r3, [r2, #0]
		if (fds[i].events & POLLIN) {
   3dba2:	07c3      	lsls	r3, r0, #31
			tmp[i].requested |= NRF_POLLIN;
   3dba4:	bf48      	it	mi
   3dba6:	8893      	ldrhmi	r3, [r2, #4]
	for (int i = 0; i < nfds; i++) {
   3dba8:	f101 0101 	add.w	r1, r1, #1
			tmp[i].requested |= NRF_POLLIN;
   3dbac:	bf44      	itt	mi
   3dbae:	f043 0301 	orrmi.w	r3, r3, #1
   3dbb2:	8093      	strhmi	r3, [r2, #4]
		if (fds[i].events & POLLOUT) {
   3dbb4:	0743      	lsls	r3, r0, #29
			tmp[i].requested |= NRF_POLLOUT;
   3dbb6:	bf48      	it	mi
   3dbb8:	8893      	ldrhmi	r3, [r2, #4]
   3dbba:	f102 0208 	add.w	r2, r2, #8
   3dbbe:	bf44      	itt	mi
   3dbc0:	f043 0302 	orrmi.w	r3, r3, #2
   3dbc4:	f822 3c04 	strhmi.w	r3, [r2, #-4]
   3dbc8:	e7d7      	b.n	3db7a <nrf91_socket_offload_poll+0x1a>
		if (tmp[i].returned & NRF_POLLIN) {
   3dbca:	eb0d 01c2 	add.w	r1, sp, r2, lsl #3
   3dbce:	88c9      	ldrh	r1, [r1, #6]
		fds[i].revents = 0;
   3dbd0:	80de      	strh	r6, [r3, #6]
		if (tmp[i].returned & NRF_POLLIN) {
   3dbd2:	07cd      	lsls	r5, r1, #31
			fds[i].revents |= POLLIN;
   3dbd4:	bf48      	it	mi
   3dbd6:	80df      	strhmi	r7, [r3, #6]
		if (tmp[i].returned & NRF_POLLOUT) {
   3dbd8:	078d      	lsls	r5, r1, #30
			fds[i].revents |= POLLOUT;
   3dbda:	bf48      	it	mi
   3dbdc:	88dd      	ldrhmi	r5, [r3, #6]
	for (int i = 0; i < nfds; i++) {
   3dbde:	f102 0201 	add.w	r2, r2, #1
			fds[i].revents |= POLLOUT;
   3dbe2:	bf44      	itt	mi
   3dbe4:	f045 0504 	orrmi.w	r5, r5, #4
   3dbe8:	80dd      	strhmi	r5, [r3, #6]
		if (tmp[i].returned & NRF_POLLERR) {
   3dbea:	074d      	lsls	r5, r1, #29
			fds[i].revents |= POLLERR;
   3dbec:	bf48      	it	mi
   3dbee:	88dd      	ldrhmi	r5, [r3, #6]
   3dbf0:	f103 0308 	add.w	r3, r3, #8
   3dbf4:	bf44      	itt	mi
   3dbf6:	f045 0508 	orrmi.w	r5, r5, #8
   3dbfa:	f823 5c02 	strhmi.w	r5, [r3, #-2]
		if (tmp[i].returned & NRF_POLLNVAL) {
   3dbfe:	06cd      	lsls	r5, r1, #27
			fds[i].revents |= POLLNVAL;
   3dc00:	bf42      	ittt	mi
   3dc02:	f833 5c02 	ldrhmi.w	r5, [r3, #-2]
   3dc06:	f045 0520 	orrmi.w	r5, r5, #32
   3dc0a:	f823 5c02 	strhmi.w	r5, [r3, #-2]
		if (tmp[i].returned & NRF_POLLHUP) {
   3dc0e:	0709      	lsls	r1, r1, #28
			fds[i].revents |= POLLHUP;
   3dc10:	bf42      	ittt	mi
   3dc12:	f833 1c02 	ldrhmi.w	r1, [r3, #-2]
   3dc16:	f041 0110 	orrmi.w	r1, r1, #16
   3dc1a:	f823 1c02 	strhmi.w	r1, [r3, #-2]
   3dc1e:	e7b7      	b.n	3db90 <nrf91_socket_offload_poll+0x30>

0003dc20 <nrf91_socket_offload_listen>:
	return nrf_listen(sd, backlog);
   3dc20:	f7f3 b9cc 	b.w	30fbc <nrf_listen>

0003dc24 <nrf91_socket_offload_close>:
	return nrf_close(sd);
   3dc24:	f7f3 b93e 	b.w	30ea4 <nrf_close>

0003dc28 <nrf91_socket_offload_fcntl>:
	switch (cmd) {
   3dc28:	2903      	cmp	r1, #3
{
   3dc2a:	b508      	push	{r3, lr}
	switch (cmd) {
   3dc2c:	d00b      	beq.n	3dc46 <nrf91_socket_offload_fcntl+0x1e>
   3dc2e:	2904      	cmp	r1, #4
   3dc30:	d111      	bne.n	3dc56 <nrf91_socket_offload_fcntl+0x2e>
		flags = va_arg(args, int);
   3dc32:	6812      	ldr	r2, [r2, #0]
		if (flags != 0 && flags != O_NONBLOCK)
   3dc34:	f432 4380 	bics.w	r3, r2, #16384	; 0x4000
   3dc38:	d10d      	bne.n	3dc56 <nrf91_socket_offload_fcntl+0x2e>
}
   3dc3a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		retval = nrf_fcntl(fd, NRF_F_SETFL, flags);
   3dc3e:	1392      	asrs	r2, r2, #14
   3dc40:	2101      	movs	r1, #1
   3dc42:	f7f3 ba31 	b.w	310a8 <nrf_fcntl>
		flags = nrf_fcntl(fd, NRF_F_GETFL, 0);
   3dc46:	2200      	movs	r2, #0
   3dc48:	2102      	movs	r1, #2
   3dc4a:	f7f3 fa2d 	bl	310a8 <nrf_fcntl>
		retval = (flags & NRF_O_NONBLOCK) ? O_NONBLOCK : 0;
   3dc4e:	0380      	lsls	r0, r0, #14
   3dc50:	f400 4080 	and.w	r0, r0, #16384	; 0x4000
}
   3dc54:	bd08      	pop	{r3, pc}
	errno = EINVAL;
   3dc56:	f7fe ff64 	bl	3cb22 <__errno>
   3dc5a:	2316      	movs	r3, #22
   3dc5c:	6003      	str	r3, [r0, #0]
	return retval;
   3dc5e:	f04f 30ff 	mov.w	r0, #4294967295
   3dc62:	e7f7      	b.n	3dc54 <nrf91_socket_offload_fcntl+0x2c>

0003dc64 <nrf_to_z_ipv6>:
	ptr->sin6_port = nrf_in->sin6_port;
   3dc64:	890b      	ldrh	r3, [r1, #8]
	ptr->sin6_family = AF_INET6;
   3dc66:	2202      	movs	r2, #2
	ptr->sin6_port = nrf_in->sin6_port;
   3dc68:	8043      	strh	r3, [r0, #2]
	ptr->sin6_family = AF_INET6;
   3dc6a:	4603      	mov	r3, r0
{
   3dc6c:	b530      	push	{r4, r5, lr}
	ptr->sin6_family = AF_INET6;
   3dc6e:	f823 2b04 	strh.w	r2, [r3], #4
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   3dc72:	f101 0210 	add.w	r2, r1, #16
   3dc76:	f102 0410 	add.w	r4, r2, #16
   3dc7a:	f852 5b04 	ldr.w	r5, [r2], #4
   3dc7e:	42a2      	cmp	r2, r4
   3dc80:	f843 5b04 	str.w	r5, [r3], #4
   3dc84:	d1f9      	bne.n	3dc7a <nrf_to_z_ipv6+0x16>
	ptr->sin6_scope_id = (u8_t)nrf_in->sin6_scope_id;
   3dc86:	6a0b      	ldr	r3, [r1, #32]
   3dc88:	7503      	strb	r3, [r0, #20]
}
   3dc8a:	bd30      	pop	{r4, r5, pc}

0003dc8c <nrf91_socket_offload_getaddrinfo>:
{
   3dc8c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   3dc90:	4614      	mov	r4, r2
   3dc92:	460e      	mov	r6, r1
	struct nrf_addrinfo *nrf_res = NULL;
   3dc94:	2100      	movs	r1, #0
{
   3dc96:	b093      	sub	sp, #76	; 0x4c
   3dc98:	4605      	mov	r5, r0
	memset(&nrf_hints, 0, sizeof(struct nrf_addrinfo));
   3dc9a:	2220      	movs	r2, #32
   3dc9c:	a802      	add	r0, sp, #8
{
   3dc9e:	461f      	mov	r7, r3
	struct nrf_addrinfo *nrf_res = NULL;
   3dca0:	9101      	str	r1, [sp, #4]
	memset(&nrf_hints, 0, sizeof(struct nrf_addrinfo));
   3dca2:	f000 fdf3 	bl	3e88c <memset>
	if (hints != NULL) {
   3dca6:	b194      	cbz	r4, 3dcce <nrf91_socket_offload_getaddrinfo+0x42>
		error = z_to_nrf_addrinfo_hints(hints, &nrf_hints);
   3dca8:	a902      	add	r1, sp, #8
   3dcaa:	4620      	mov	r0, r4
   3dcac:	f7ff febf 	bl	3da2e <z_to_nrf_addrinfo_hints>
		if (error == -EPROTONOSUPPORT) {
   3dcb0:	f110 0f7b 	cmn.w	r0, #123	; 0x7b
   3dcb4:	f000 80bf 	beq.w	3de36 <nrf91_socket_offload_getaddrinfo+0x1aa>
		} else if (error == -EAFNOSUPPORT) {
   3dcb8:	306a      	adds	r0, #106	; 0x6a
   3dcba:	f000 80bf 	beq.w	3de3c <nrf91_socket_offload_getaddrinfo+0x1b0>
		if (hints->ai_next != NULL) {
   3dcbe:	69e0      	ldr	r0, [r4, #28]
   3dcc0:	b120      	cbz	r0, 3dccc <nrf91_socket_offload_getaddrinfo+0x40>
			z_to_nrf_addrinfo_hints(hints->ai_next, &nrf_hints_pdn);
   3dcc2:	ac0a      	add	r4, sp, #40	; 0x28
   3dcc4:	4621      	mov	r1, r4
   3dcc6:	f7ff feb2 	bl	3da2e <z_to_nrf_addrinfo_hints>
			nrf_hints.ai_next = &nrf_hints_pdn;
   3dcca:	9409      	str	r4, [sp, #36]	; 0x24
		nrf_hints_ptr = &nrf_hints;
   3dccc:	ac02      	add	r4, sp, #8
	int retval = nrf_getaddrinfo(node, service, nrf_hints_ptr, &nrf_res);
   3dcce:	4628      	mov	r0, r5
   3dcd0:	ab01      	add	r3, sp, #4
   3dcd2:	4622      	mov	r2, r4
   3dcd4:	4631      	mov	r1, r6
   3dcd6:	f7f3 f9e1 	bl	3109c <nrf_getaddrinfo>
	if (retval != 0) {
   3dcda:	4605      	mov	r5, r0
   3dcdc:	b1b0      	cbz	r0, 3dd0c <nrf91_socket_offload_getaddrinfo+0x80>
	switch (nrf_error) {
   3dcde:	2823      	cmp	r0, #35	; 0x23
   3dce0:	f000 80af 	beq.w	3de42 <nrf91_socket_offload_getaddrinfo+0x1b6>
   3dce4:	dc0a      	bgt.n	3dcfc <nrf91_socket_offload_getaddrinfo+0x70>
		return DNS_EAI_SYSTEM;
   3dce6:	280c      	cmp	r0, #12
   3dce8:	bf08      	it	eq
   3dcea:	f06f 0509 	mvneq.w	r5, #9
   3dcee:	bf18      	it	ne
   3dcf0:	f06f 050a 	mvnne.w	r5, #10
}
   3dcf4:	4628      	mov	r0, r5
   3dcf6:	b013      	add	sp, #76	; 0x4c
   3dcf8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	switch (nrf_error) {
   3dcfc:	282f      	cmp	r0, #47	; 0x2f
   3dcfe:	f000 80a3 	beq.w	3de48 <nrf91_socket_offload_getaddrinfo+0x1bc>
		return DNS_EAI_SYSTEM;
   3dd02:	2873      	cmp	r0, #115	; 0x73
   3dd04:	bf08      	it	eq
   3dd06:	f06f 0563 	mvneq.w	r5, #99	; 0x63
   3dd0a:	e7f0      	b.n	3dcee <nrf91_socket_offload_getaddrinfo+0x62>
	struct addrinfo *latest_z_res = NULL;
   3dd0c:	4680      	mov	r8, r0
	z_out->ai_next = NULL;
   3dd0e:	4681      	mov	r9, r0
	struct nrf_addrinfo *next_nrf_res = nrf_res;
   3dd10:	9e01      	ldr	r6, [sp, #4]
	*res = NULL;
   3dd12:	6038      	str	r0, [r7, #0]
	while ((retval == 0) && (next_nrf_res != NULL)) {
   3dd14:	b91e      	cbnz	r6, 3dd1e <nrf91_socket_offload_getaddrinfo+0x92>
	nrf_freeaddrinfo(nrf_res);
   3dd16:	9801      	ldr	r0, [sp, #4]
   3dd18:	f7f3 f9c2 	bl	310a0 <nrf_freeaddrinfo>
	return retval;
   3dd1c:	e7ea      	b.n	3dcf4 <nrf91_socket_offload_getaddrinfo+0x68>
		struct addrinfo *next_z_res = k_malloc(sizeof(struct addrinfo));
   3dd1e:	2020      	movs	r0, #32
   3dd20:	f7f7 fffa 	bl	35d18 <k_malloc>
		if (next_z_res == NULL) {
   3dd24:	4604      	mov	r4, r0
   3dd26:	2800      	cmp	r0, #0
   3dd28:	d07a      	beq.n	3de20 <nrf91_socket_offload_getaddrinfo+0x194>
	family = nrf_to_z_family(nrf_in->ai_family);
   3dd2a:	6872      	ldr	r2, [r6, #4]
	z_out->ai_socktype = nrf_in->ai_socktype;
   3dd2c:	68b3      	ldr	r3, [r6, #8]
	switch (nrf_family) {
   3dd2e:	2a05      	cmp	r2, #5
	z_out->ai_canonname = NULL; /* TODO Do proper content copy. */
   3dd30:	e9c0 9906 	strd	r9, r9, [r0, #24]
	z_out->ai_flags = nrf_to_z_addrinfo_flags(nrf_in->ai_flags);
   3dd34:	f8c0 9000 	str.w	r9, [r0]
	z_out->ai_socktype = nrf_in->ai_socktype;
   3dd38:	6083      	str	r3, [r0, #8]
	switch (nrf_family) {
   3dd3a:	d033      	beq.n	3dda4 <nrf91_socket_offload_getaddrinfo+0x118>
   3dd3c:	dc09      	bgt.n	3dd52 <nrf91_socket_offload_getaddrinfo+0xc6>
   3dd3e:	2a01      	cmp	r2, #1
   3dd40:	d032      	beq.n	3dda8 <nrf91_socket_offload_getaddrinfo+0x11c>
   3dd42:	2a02      	cmp	r2, #2
   3dd44:	d032      	beq.n	3ddac <nrf91_socket_offload_getaddrinfo+0x120>
			k_free(next_z_res);
   3dd46:	4620      	mov	r0, r4
   3dd48:	f000 fbb1 	bl	3e4ae <k_free>
			retval = DNS_EAI_ADDRFAMILY;
   3dd4c:	f06f 0508 	mvn.w	r5, #8
   3dd50:	e068      	b.n	3de24 <nrf91_socket_offload_getaddrinfo+0x198>
	switch (nrf_family) {
   3dd52:	2a0a      	cmp	r2, #10
   3dd54:	d02c      	beq.n	3ddb0 <nrf91_socket_offload_getaddrinfo+0x124>
   3dd56:	2a66      	cmp	r2, #102	; 0x66
   3dd58:	d1f5      	bne.n	3dd46 <nrf91_socket_offload_getaddrinfo+0xba>
		return AF_LTE;
   3dd5a:	4613      	mov	r3, r2
	z_out->ai_family = family;
   3dd5c:	6063      	str	r3, [r4, #4]
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   3dd5e:	68f3      	ldr	r3, [r6, #12]
	switch (proto) {
   3dd60:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
   3dd64:	d045      	beq.n	3ddf2 <nrf91_socket_offload_getaddrinfo+0x166>
   3dd66:	dc25      	bgt.n	3ddb4 <nrf91_socket_offload_getaddrinfo+0x128>
   3dd68:	2b01      	cmp	r3, #1
   3dd6a:	d047      	beq.n	3ddfc <nrf91_socket_offload_getaddrinfo+0x170>
   3dd6c:	2b02      	cmp	r3, #2
   3dd6e:	d043      	beq.n	3ddf8 <nrf91_socket_offload_getaddrinfo+0x16c>
   3dd70:	bb43      	cbnz	r3, 3ddc4 <nrf91_socket_offload_getaddrinfo+0x138>
	if (nrf_in->ai_family == NRF_AF_INET) {
   3dd72:	2a02      	cmp	r2, #2
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   3dd74:	60e3      	str	r3, [r4, #12]
	if (nrf_in->ai_family == NRF_AF_INET) {
   3dd76:	d143      	bne.n	3de00 <nrf91_socket_offload_getaddrinfo+0x174>
		z_out->ai_addr = k_malloc(sizeof(struct sockaddr_in));
   3dd78:	2008      	movs	r0, #8
   3dd7a:	f7f7 ffcd 	bl	35d18 <k_malloc>
   3dd7e:	6160      	str	r0, [r4, #20]
		if (z_out->ai_addr == NULL) {
   3dd80:	2800      	cmp	r0, #0
   3dd82:	d04a      	beq.n	3de1a <nrf91_socket_offload_getaddrinfo+0x18e>
		z_out->ai_addrlen  = sizeof(struct sockaddr_in);
   3dd84:	2308      	movs	r3, #8
   3dd86:	6123      	str	r3, [r4, #16]
			(const struct nrf_sockaddr_in *)nrf_in->ai_addr);
   3dd88:	6973      	ldr	r3, [r6, #20]
	ptr->sin_port = nrf_in->sin_port;
   3dd8a:	891a      	ldrh	r2, [r3, #8]
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   3dd8c:	68db      	ldr	r3, [r3, #12]
	ptr->sin_port = nrf_in->sin_port;
   3dd8e:	8042      	strh	r2, [r0, #2]
	ptr->sin_family = AF_INET;
   3dd90:	2201      	movs	r2, #1
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   3dd92:	6043      	str	r3, [r0, #4]
	ptr->sin_family = AF_INET;
   3dd94:	8002      	strh	r2, [r0, #0]
		if (latest_z_res == NULL) {
   3dd96:	f1b8 0f00 	cmp.w	r8, #0
   3dd9a:	d149      	bne.n	3de30 <nrf91_socket_offload_getaddrinfo+0x1a4>
			*res = next_z_res;
   3dd9c:	603c      	str	r4, [r7, #0]
		next_nrf_res = next_nrf_res->ai_next;
   3dd9e:	69f6      	ldr	r6, [r6, #28]
   3dda0:	46a0      	mov	r8, r4
   3dda2:	e7b7      	b.n	3dd14 <nrf91_socket_offload_getaddrinfo+0x88>
		return AF_PACKET;
   3dda4:	2303      	movs	r3, #3
   3dda6:	e7d9      	b.n	3dd5c <nrf91_socket_offload_getaddrinfo+0xd0>
		return AF_LOCAL;
   3dda8:	2367      	movs	r3, #103	; 0x67
   3ddaa:	e7d7      	b.n	3dd5c <nrf91_socket_offload_getaddrinfo+0xd0>
		return AF_INET;
   3ddac:	2301      	movs	r3, #1
   3ddae:	e7d5      	b.n	3dd5c <nrf91_socket_offload_getaddrinfo+0xd0>
		return AF_INET6;
   3ddb0:	2302      	movs	r3, #2
   3ddb2:	e7d3      	b.n	3dd5c <nrf91_socket_offload_getaddrinfo+0xd0>
	switch (proto) {
   3ddb4:	f240 2101 	movw	r1, #513	; 0x201
   3ddb8:	428b      	cmp	r3, r1
   3ddba:	d0da      	beq.n	3dd72 <nrf91_socket_offload_getaddrinfo+0xe6>
   3ddbc:	dc0d      	bgt.n	3ddda <nrf91_socket_offload_getaddrinfo+0x14e>
   3ddbe:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   3ddc2:	d013      	beq.n	3ddec <nrf91_socket_offload_getaddrinfo+0x160>
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   3ddc4:	f06f 037a 	mvn.w	r3, #122	; 0x7a
   3ddc8:	60e3      	str	r3, [r4, #12]
		z_out->ai_addr = NULL;
   3ddca:	2300      	movs	r3, #0
   3ddcc:	6163      	str	r3, [r4, #20]
			k_free(next_z_res);
   3ddce:	4620      	mov	r0, r4
   3ddd0:	f000 fb6d 	bl	3e4ae <k_free>
			retval = DNS_EAI_SOCKTYPE;
   3ddd4:	f06f 0506 	mvn.w	r5, #6
   3ddd8:	e024      	b.n	3de24 <nrf91_socket_offload_getaddrinfo+0x198>
	switch (proto) {
   3ddda:	f240 2102 	movw	r1, #514	; 0x202
   3ddde:	428b      	cmp	r3, r1
   3dde0:	d0c7      	beq.n	3dd72 <nrf91_socket_offload_getaddrinfo+0xe6>
   3dde2:	f240 2103 	movw	r1, #515	; 0x203
   3dde6:	428b      	cmp	r3, r1
   3dde8:	d0c3      	beq.n	3dd72 <nrf91_socket_offload_getaddrinfo+0xe6>
   3ddea:	e7eb      	b.n	3ddc4 <nrf91_socket_offload_getaddrinfo+0x138>
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   3ddec:	f240 1311 	movw	r3, #273	; 0x111
   3ddf0:	e7bf      	b.n	3dd72 <nrf91_socket_offload_getaddrinfo+0xe6>
   3ddf2:	f44f 7381 	mov.w	r3, #258	; 0x102
   3ddf6:	e7bc      	b.n	3dd72 <nrf91_socket_offload_getaddrinfo+0xe6>
   3ddf8:	2311      	movs	r3, #17
   3ddfa:	e7ba      	b.n	3dd72 <nrf91_socket_offload_getaddrinfo+0xe6>
   3ddfc:	2306      	movs	r3, #6
   3ddfe:	e7b8      	b.n	3dd72 <nrf91_socket_offload_getaddrinfo+0xe6>
	} else if (nrf_in->ai_family == NRF_AF_INET6) {
   3de00:	2a0a      	cmp	r2, #10
   3de02:	d1e4      	bne.n	3ddce <nrf91_socket_offload_getaddrinfo+0x142>
		z_out->ai_addr = k_malloc(sizeof(struct sockaddr_in6));
   3de04:	2018      	movs	r0, #24
   3de06:	f7f7 ff87 	bl	35d18 <k_malloc>
   3de0a:	6160      	str	r0, [r4, #20]
		if (z_out->ai_addr == NULL) {
   3de0c:	b128      	cbz	r0, 3de1a <nrf91_socket_offload_getaddrinfo+0x18e>
		z_out->ai_addrlen  = sizeof(struct sockaddr_in6);
   3de0e:	2318      	movs	r3, #24
		nrf_to_z_ipv6(z_out->ai_addr,
   3de10:	6971      	ldr	r1, [r6, #20]
		z_out->ai_addrlen  = sizeof(struct sockaddr_in6);
   3de12:	6123      	str	r3, [r4, #16]
		nrf_to_z_ipv6(z_out->ai_addr,
   3de14:	f7ff ff26 	bl	3dc64 <nrf_to_z_ipv6>
		} else if (error == -EAFNOSUPPORT) {
   3de18:	e7bd      	b.n	3dd96 <nrf91_socket_offload_getaddrinfo+0x10a>
			k_free(next_z_res);
   3de1a:	4620      	mov	r0, r4
   3de1c:	f000 fb47 	bl	3e4ae <k_free>
			retval = DNS_EAI_MEMORY;
   3de20:	f06f 0509 	mvn.w	r5, #9
		nrf91_socket_offload_freeaddrinfo(*res);
   3de24:	6838      	ldr	r0, [r7, #0]
   3de26:	f7ff fdf5 	bl	3da14 <nrf91_socket_offload_freeaddrinfo>
		*res = NULL;
   3de2a:	2300      	movs	r3, #0
   3de2c:	603b      	str	r3, [r7, #0]
   3de2e:	e772      	b.n	3dd16 <nrf91_socket_offload_getaddrinfo+0x8a>
			latest_z_res->ai_next = next_z_res;
   3de30:	f8c8 401c 	str.w	r4, [r8, #28]
   3de34:	e7b3      	b.n	3dd9e <nrf91_socket_offload_getaddrinfo+0x112>
			return DNS_EAI_SOCKTYPE;
   3de36:	f06f 0506 	mvn.w	r5, #6
   3de3a:	e75b      	b.n	3dcf4 <nrf91_socket_offload_getaddrinfo+0x68>
			return DNS_EAI_ADDRFAMILY;
   3de3c:	f06f 0508 	mvn.w	r5, #8
   3de40:	e758      	b.n	3dcf4 <nrf91_socket_offload_getaddrinfo+0x68>
		return DNS_EAI_AGAIN;
   3de42:	f06f 0502 	mvn.w	r5, #2
   3de46:	e755      	b.n	3dcf4 <nrf91_socket_offload_getaddrinfo+0x68>
		return DNS_EAI_NONAME;
   3de48:	f06f 0501 	mvn.w	r5, #1
   3de4c:	e752      	b.n	3dcf4 <nrf91_socket_offload_getaddrinfo+0x68>

0003de4e <z_to_nrf_ipv6>:
	nrf_out->sin6_len = sizeof(struct nrf_sockaddr_in6);
   3de4e:	2224      	movs	r2, #36	; 0x24
{
   3de50:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_out->sin6_len = sizeof(struct nrf_sockaddr_in6);
   3de52:	700a      	strb	r2, [r1, #0]
	nrf_out->sin6_port = ptr->sin6_port;
   3de54:	8842      	ldrh	r2, [r0, #2]
{
   3de56:	4604      	mov	r4, r0
	nrf_out->sin6_port = ptr->sin6_port;
   3de58:	810a      	strh	r2, [r1, #8]
	nrf_out->sin6_family = NRF_AF_INET6;
   3de5a:	220a      	movs	r2, #10
{
   3de5c:	460b      	mov	r3, r1
	nrf_out->sin6_family = NRF_AF_INET6;
   3de5e:	604a      	str	r2, [r1, #4]
   3de60:	f101 0610 	add.w	r6, r1, #16
   3de64:	1d02      	adds	r2, r0, #4
   3de66:	f100 0714 	add.w	r7, r0, #20
   3de6a:	4635      	mov	r5, r6
   3de6c:	6810      	ldr	r0, [r2, #0]
   3de6e:	6851      	ldr	r1, [r2, #4]
   3de70:	3208      	adds	r2, #8
   3de72:	c503      	stmia	r5!, {r0, r1}
   3de74:	42ba      	cmp	r2, r7
   3de76:	462e      	mov	r6, r5
   3de78:	d1f7      	bne.n	3de6a <z_to_nrf_ipv6+0x1c>
	nrf_out->sin6_scope_id = (u32_t)ptr->sin6_scope_id;
   3de7a:	7d22      	ldrb	r2, [r4, #20]
   3de7c:	621a      	str	r2, [r3, #32]
}
   3de7e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0003de80 <nrf91_socket_offload_sendto>:
{
   3de80:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   3de84:	b08d      	sub	sp, #52	; 0x34
   3de86:	9c14      	ldr	r4, [sp, #80]	; 0x50
   3de88:	4605      	mov	r5, r0
   3de8a:	460e      	mov	r6, r1
   3de8c:	4617      	mov	r7, r2
   3de8e:	4698      	mov	r8, r3
	if (to == NULL) {
   3de90:	b96c      	cbnz	r4, 3deae <nrf91_socket_offload_sendto+0x2e>
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), NULL,
   3de92:	4618      	mov	r0, r3
   3de94:	f7ff fd74 	bl	3d980 <z_to_nrf_flags>
   3de98:	e9cd 4400 	strd	r4, r4, [sp]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv6,
   3de9c:	4603      	mov	r3, r0
   3de9e:	463a      	mov	r2, r7
   3dea0:	4631      	mov	r1, r6
   3dea2:	4628      	mov	r0, r5
   3dea4:	f7f3 f80c 	bl	30ec0 <nrf_sendto>
}
   3dea8:	b00d      	add	sp, #52	; 0x34
   3deaa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if (to->sa_family == AF_INET) {
   3deae:	8823      	ldrh	r3, [r4, #0]
   3deb0:	2b01      	cmp	r3, #1
   3deb2:	d110      	bne.n	3ded6 <nrf91_socket_offload_sendto+0x56>
	nrf_out->sin_port = ptr->sin_port;
   3deb4:	8863      	ldrh	r3, [r4, #2]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   3deb6:	2110      	movs	r1, #16
	nrf_out->sin_port = ptr->sin_port;
   3deb8:	f8ad 3014 	strh.w	r3, [sp, #20]
	nrf_out->sin_family = NRF_AF_INET;
   3debc:	2302      	movs	r3, #2
   3debe:	9304      	str	r3, [sp, #16]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   3dec0:	6863      	ldr	r3, [r4, #4]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv4,
   3dec2:	4640      	mov	r0, r8
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   3dec4:	9306      	str	r3, [sp, #24]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   3dec6:	f88d 100c 	strb.w	r1, [sp, #12]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv4,
   3deca:	f7ff fd59 	bl	3d980 <z_to_nrf_flags>
   3dece:	ab03      	add	r3, sp, #12
   3ded0:	9101      	str	r1, [sp, #4]
   3ded2:	9300      	str	r3, [sp, #0]
   3ded4:	e7e2      	b.n	3de9c <nrf91_socket_offload_sendto+0x1c>
	} else if (to->sa_family == AF_INET6) {
   3ded6:	2b02      	cmp	r3, #2
   3ded8:	d10c      	bne.n	3def4 <nrf91_socket_offload_sendto+0x74>
		z_to_nrf_ipv6(to, &ipv6);
   3deda:	f10d 090c 	add.w	r9, sp, #12
   3dede:	4649      	mov	r1, r9
   3dee0:	4620      	mov	r0, r4
   3dee2:	f7ff ffb4 	bl	3de4e <z_to_nrf_ipv6>
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv6,
   3dee6:	4640      	mov	r0, r8
   3dee8:	f7ff fd4a 	bl	3d980 <z_to_nrf_flags>
   3deec:	2324      	movs	r3, #36	; 0x24
   3deee:	e9cd 9300 	strd	r9, r3, [sp]
   3def2:	e7d3      	b.n	3de9c <nrf91_socket_offload_sendto+0x1c>
	errno = ENOTSUP;
   3def4:	f7fe fe15 	bl	3cb22 <__errno>
   3def8:	2386      	movs	r3, #134	; 0x86
   3defa:	6003      	str	r3, [r0, #0]
	return retval;
   3defc:	f04f 30ff 	mov.w	r0, #4294967295
   3df00:	e7d2      	b.n	3dea8 <nrf91_socket_offload_sendto+0x28>

0003df02 <nrf91_socket_offload_recvfrom>:
{
   3df02:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3df06:	4605      	mov	r5, r0
   3df08:	b08c      	sub	sp, #48	; 0x30
   3df0a:	4618      	mov	r0, r3
   3df0c:	e9dd 4612 	ldrd	r4, r6, [sp, #72]	; 0x48
   3df10:	4690      	mov	r8, r2
	if (from == NULL) {
   3df12:	f7ff fd35 	bl	3d980 <z_to_nrf_flags>
   3df16:	4603      	mov	r3, r0
   3df18:	b954      	cbnz	r4, 3df30 <nrf91_socket_offload_recvfrom+0x2e>
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags), NULL,
   3df1a:	4628      	mov	r0, r5
   3df1c:	e9cd 4400 	strd	r4, r4, [sp]
   3df20:	4642      	mov	r2, r8
   3df22:	f7f3 f803 	bl	30f2c <nrf_recvfrom>
   3df26:	4605      	mov	r5, r0
}
   3df28:	4628      	mov	r0, r5
   3df2a:	b00c      	add	sp, #48	; 0x30
   3df2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		nrf_socklen_t sock_len = sizeof(struct nrf_sockaddr_in6);
   3df30:	2224      	movs	r2, #36	; 0x24
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags),
   3df32:	af03      	add	r7, sp, #12
		nrf_socklen_t sock_len = sizeof(struct nrf_sockaddr_in6);
   3df34:	9202      	str	r2, [sp, #8]
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags),
   3df36:	aa02      	add	r2, sp, #8
   3df38:	9201      	str	r2, [sp, #4]
   3df3a:	4628      	mov	r0, r5
   3df3c:	9700      	str	r7, [sp, #0]
   3df3e:	4642      	mov	r2, r8
   3df40:	f7f2 fff4 	bl	30f2c <nrf_recvfrom>
		if (cliaddr->sa_family == NRF_AF_INET) {
   3df44:	9b04      	ldr	r3, [sp, #16]
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags),
   3df46:	4605      	mov	r5, r0
		if (cliaddr->sa_family == NRF_AF_INET) {
   3df48:	2b02      	cmp	r3, #2
   3df4a:	d109      	bne.n	3df60 <nrf91_socket_offload_recvfrom+0x5e>
	ptr->sin_port = nrf_in->sin_port;
   3df4c:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   3df50:	8063      	strh	r3, [r4, #2]
	ptr->sin_family = AF_INET;
   3df52:	2301      	movs	r3, #1
   3df54:	8023      	strh	r3, [r4, #0]
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   3df56:	9b06      	ldr	r3, [sp, #24]
   3df58:	6063      	str	r3, [r4, #4]
			*fromlen = sizeof(struct sockaddr_in);
   3df5a:	2308      	movs	r3, #8
			*fromlen = sizeof(struct sockaddr_in6);
   3df5c:	6033      	str	r3, [r6, #0]
	return retval;
   3df5e:	e7e3      	b.n	3df28 <nrf91_socket_offload_recvfrom+0x26>
		} else if (cliaddr->sa_family == NRF_AF_INET6) {
   3df60:	2b0a      	cmp	r3, #10
   3df62:	d1e1      	bne.n	3df28 <nrf91_socket_offload_recvfrom+0x26>
			nrf_to_z_ipv6(from, (struct nrf_sockaddr_in6 *)
   3df64:	4639      	mov	r1, r7
   3df66:	4620      	mov	r0, r4
   3df68:	f7ff fe7c 	bl	3dc64 <nrf_to_z_ipv6>
			*fromlen = sizeof(struct sockaddr_in6);
   3df6c:	2318      	movs	r3, #24
   3df6e:	e7f5      	b.n	3df5c <nrf91_socket_offload_recvfrom+0x5a>

0003df70 <nrf91_socket_offload_connect>:
{
   3df70:	b530      	push	{r4, r5, lr}
	if (addr->sa_family == AF_INET) {
   3df72:	880c      	ldrh	r4, [r1, #0]
{
   3df74:	b08b      	sub	sp, #44	; 0x2c
	if (addr->sa_family == AF_INET) {
   3df76:	2c01      	cmp	r4, #1
{
   3df78:	4605      	mov	r5, r0
   3df7a:	460b      	mov	r3, r1
	if (addr->sa_family == AF_INET) {
   3df7c:	d10e      	bne.n	3df9c <nrf91_socket_offload_connect+0x2c>
	nrf_out->sin_port = ptr->sin_port;
   3df7e:	8849      	ldrh	r1, [r1, #2]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   3df80:	2210      	movs	r2, #16
	nrf_out->sin_port = ptr->sin_port;
   3df82:	f8ad 100c 	strh.w	r1, [sp, #12]
	nrf_out->sin_family = NRF_AF_INET;
   3df86:	2102      	movs	r1, #2
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   3df88:	685b      	ldr	r3, [r3, #4]
	nrf_out->sin_family = NRF_AF_INET;
   3df8a:	9102      	str	r1, [sp, #8]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   3df8c:	f88d 2004 	strb.w	r2, [sp, #4]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   3df90:	9304      	str	r3, [sp, #16]
		retval = nrf_connect(sd, (const struct nrf_sockaddr_in *)&ipv4,
   3df92:	a901      	add	r1, sp, #4
		retval = nrf_connect(sd, (const struct nrf_sockaddr *)&ipv6,
   3df94:	f7f3 f800 	bl	30f98 <nrf_connect>
}
   3df98:	b00b      	add	sp, #44	; 0x2c
   3df9a:	bd30      	pop	{r4, r5, pc}
	} else if (addr->sa_family == AF_INET6) {
   3df9c:	2c02      	cmp	r4, #2
   3df9e:	d107      	bne.n	3dfb0 <nrf91_socket_offload_connect+0x40>
		z_to_nrf_ipv6(addr, &ipv6);
   3dfa0:	a901      	add	r1, sp, #4
   3dfa2:	4618      	mov	r0, r3
   3dfa4:	f7ff ff53 	bl	3de4e <z_to_nrf_ipv6>
		retval = nrf_connect(sd, (const struct nrf_sockaddr *)&ipv6,
   3dfa8:	2224      	movs	r2, #36	; 0x24
   3dfaa:	a901      	add	r1, sp, #4
   3dfac:	4628      	mov	r0, r5
   3dfae:	e7f1      	b.n	3df94 <nrf91_socket_offload_connect+0x24>
		retval = nrf_connect(sd, (void *)addr, addrlen);
   3dfb0:	f7f2 fff2 	bl	30f98 <nrf_connect>
		if (retval < 0) {
   3dfb4:	2800      	cmp	r0, #0
   3dfb6:	daef      	bge.n	3df98 <nrf91_socket_offload_connect+0x28>
	errno = ENOTSUP;
   3dfb8:	f7fe fdb3 	bl	3cb22 <__errno>
   3dfbc:	2386      	movs	r3, #134	; 0x86
   3dfbe:	6003      	str	r3, [r0, #0]
   3dfc0:	f04f 30ff 	mov.w	r0, #4294967295
   3dfc4:	e7e8      	b.n	3df98 <nrf91_socket_offload_connect+0x28>

0003dfc6 <nrf91_socket_offload_accept>:
{
   3dfc6:	b5f0      	push	{r4, r5, r6, r7, lr}
   3dfc8:	4616      	mov	r6, r2
   3dfca:	b08b      	sub	sp, #44	; 0x2c
	if ((addr != NULL) && (addrlen != NULL)) {
   3dfcc:	460c      	mov	r4, r1
   3dfce:	b1f1      	cbz	r1, 3e00e <nrf91_socket_offload_accept+0x48>
   3dfd0:	b302      	cbz	r2, 3e014 <nrf91_socket_offload_accept+0x4e>
		if (*addrlen == sizeof(struct sockaddr_in)) {
   3dfd2:	6813      	ldr	r3, [r2, #0]
		nrf_addrlen_ptr = &nrf_addrlen;
   3dfd4:	466a      	mov	r2, sp
		if (*addrlen == sizeof(struct sockaddr_in)) {
   3dfd6:	2b08      	cmp	r3, #8
			nrf_addrlen = sizeof(struct nrf_sockaddr_in);
   3dfd8:	bf0c      	ite	eq
   3dfda:	2310      	moveq	r3, #16
			nrf_addrlen = sizeof(struct nrf_sockaddr_in6);
   3dfdc:	2324      	movne	r3, #36	; 0x24
		nrf_addr_ptr = (struct nrf_sockaddr *)&nrf_addr;
   3dfde:	ad01      	add	r5, sp, #4
			nrf_addrlen = sizeof(struct nrf_sockaddr_in6);
   3dfe0:	9300      	str	r3, [sp, #0]
	retval = nrf_accept(sd, nrf_addr_ptr, nrf_addrlen_ptr);
   3dfe2:	4629      	mov	r1, r5
   3dfe4:	f7f2 fffa 	bl	30fdc <nrf_accept>
	if (retval < 0) {
   3dfe8:	1e07      	subs	r7, r0, #0
   3dfea:	db22      	blt.n	3e032 <nrf91_socket_offload_accept+0x6c>
	if ((addr != NULL) && (addrlen != NULL)) {
   3dfec:	b164      	cbz	r4, 3e008 <nrf91_socket_offload_accept+0x42>
   3dfee:	b15e      	cbz	r6, 3e008 <nrf91_socket_offload_accept+0x42>
		if (nrf_addr_ptr->sa_family == NRF_AF_INET) {
   3dff0:	686b      	ldr	r3, [r5, #4]
   3dff2:	2b02      	cmp	r3, #2
   3dff4:	d110      	bne.n	3e018 <nrf91_socket_offload_accept+0x52>
			*addrlen = sizeof(struct sockaddr_in);
   3dff6:	2308      	movs	r3, #8
   3dff8:	6033      	str	r3, [r6, #0]
	ptr->sin_port = nrf_in->sin_port;
   3dffa:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   3dffe:	8063      	strh	r3, [r4, #2]
	ptr->sin_family = AF_INET;
   3e000:	2301      	movs	r3, #1
   3e002:	8023      	strh	r3, [r4, #0]
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   3e004:	9b04      	ldr	r3, [sp, #16]
   3e006:	6063      	str	r3, [r4, #4]
}
   3e008:	4638      	mov	r0, r7
   3e00a:	b00b      	add	sp, #44	; 0x2c
   3e00c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	nrf_socklen_t *nrf_addrlen_ptr = NULL;
   3e00e:	460a      	mov	r2, r1
	struct nrf_sockaddr *nrf_addr_ptr = NULL;
   3e010:	460d      	mov	r5, r1
   3e012:	e7e6      	b.n	3dfe2 <nrf91_socket_offload_accept+0x1c>
   3e014:	4615      	mov	r5, r2
   3e016:	e7e4      	b.n	3dfe2 <nrf91_socket_offload_accept+0x1c>
		} else if (nrf_addr_ptr->sa_family == NRF_AF_INET6) {
   3e018:	2b0a      	cmp	r3, #10
   3e01a:	d106      	bne.n	3e02a <nrf91_socket_offload_accept+0x64>
			*addrlen = sizeof(struct sockaddr_in6);
   3e01c:	2318      	movs	r3, #24
			nrf_to_z_ipv6(
   3e01e:	a901      	add	r1, sp, #4
			*addrlen = sizeof(struct sockaddr_in6);
   3e020:	6033      	str	r3, [r6, #0]
			nrf_to_z_ipv6(
   3e022:	4620      	mov	r0, r4
   3e024:	f7ff fe1e 	bl	3dc64 <nrf_to_z_ipv6>
   3e028:	e7ee      	b.n	3e008 <nrf91_socket_offload_accept+0x42>
	errno = ENOTSUP;
   3e02a:	f7fe fd7a 	bl	3cb22 <__errno>
   3e02e:	2386      	movs	r3, #134	; 0x86
   3e030:	6003      	str	r3, [r0, #0]
		return -1;
   3e032:	f04f 37ff 	mov.w	r7, #4294967295
   3e036:	e7e7      	b.n	3e008 <nrf91_socket_offload_accept+0x42>

0003e038 <nrf91_socket_offload_socket>:
{
   3e038:	b510      	push	{r4, lr}
	family = z_to_nrf_family(family);
   3e03a:	b280      	uxth	r0, r0
   3e03c:	f7ff fcaa 	bl	3d994 <z_to_nrf_family>
	if (family == -EAFNOSUPPORT) {
   3e040:	f110 0f6a 	cmn.w	r0, #106	; 0x6a
	family = z_to_nrf_family(family);
   3e044:	4604      	mov	r4, r0
	if (family == -EAFNOSUPPORT) {
   3e046:	d106      	bne.n	3e056 <nrf91_socket_offload_socket+0x1e>
		errno = EAFNOSUPPORT;
   3e048:	f7fe fd6b 	bl	3cb22 <__errno>
   3e04c:	236a      	movs	r3, #106	; 0x6a
		errno = EPROTONOSUPPORT;
   3e04e:	6003      	str	r3, [r0, #0]
}
   3e050:	f04f 30ff 	mov.w	r0, #4294967295
   3e054:	bd10      	pop	{r4, pc}
	switch (socktype) {
   3e056:	2903      	cmp	r1, #3
   3e058:	d003      	beq.n	3e062 <nrf91_socket_offload_socket+0x2a>
		return NRF_SOCK_MGMT;
   3e05a:	2904      	cmp	r1, #4
   3e05c:	bf08      	it	eq
   3e05e:	f44f 7100 	moveq.w	r1, #512	; 0x200
	proto = z_to_nrf_protocol(proto);
   3e062:	4610      	mov	r0, r2
   3e064:	f7ff fcac 	bl	3d9c0 <z_to_nrf_protocol>
	if (proto == -EPROTONOSUPPORT) {
   3e068:	f110 0f7b 	cmn.w	r0, #123	; 0x7b
	proto = z_to_nrf_protocol(proto);
   3e06c:	4602      	mov	r2, r0
	if (proto == -EPROTONOSUPPORT) {
   3e06e:	d103      	bne.n	3e078 <nrf91_socket_offload_socket+0x40>
		errno = EPROTONOSUPPORT;
   3e070:	f7fe fd57 	bl	3cb22 <__errno>
   3e074:	237b      	movs	r3, #123	; 0x7b
   3e076:	e7ea      	b.n	3e04e <nrf91_socket_offload_socket+0x16>
	retval = nrf_socket(family, type, proto);
   3e078:	4620      	mov	r0, r4
}
   3e07a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	retval = nrf_socket(family, type, proto);
   3e07e:	f7f2 beff 	b.w	30e80 <nrf_socket>

0003e082 <nrf91_socket_offload_setsockopt>:
{
   3e082:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	switch (z_in_level) {
   3e086:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
{
   3e08a:	b086      	sub	sp, #24
   3e08c:	4680      	mov	r8, r0
   3e08e:	460c      	mov	r4, r1
   3e090:	4617      	mov	r7, r2
   3e092:	461d      	mov	r5, r3
   3e094:	9e0c      	ldr	r6, [sp, #48]	; 0x30
	switch (z_in_level) {
   3e096:	d002      	beq.n	3e09e <nrf91_socket_offload_setsockopt+0x1c>
   3e098:	dc1c      	bgt.n	3e0d4 <nrf91_socket_offload_setsockopt+0x52>
   3e09a:	2901      	cmp	r1, #1
   3e09c:	d122      	bne.n	3e0e4 <nrf91_socket_offload_setsockopt+0x62>
	if (z_to_nrf_optname(level, optname, &nrf_optname) < 0)
   3e09e:	aa03      	add	r2, sp, #12
   3e0a0:	4639      	mov	r1, r7
   3e0a2:	4620      	mov	r0, r4
   3e0a4:	f7ec febc 	bl	2ae20 <z_to_nrf_optname>
   3e0a8:	2800      	cmp	r0, #0
   3e0aa:	db1b      	blt.n	3e0e4 <nrf91_socket_offload_setsockopt+0x62>
	if ((level == SOL_SOCKET) && (optname == SO_RCVTIMEO)) {
   3e0ac:	2c01      	cmp	r4, #1
   3e0ae:	d107      	bne.n	3e0c0 <nrf91_socket_offload_setsockopt+0x3e>
   3e0b0:	2f14      	cmp	r7, #20
   3e0b2:	d105      	bne.n	3e0c0 <nrf91_socket_offload_setsockopt+0x3e>
		nrf_optlen = sizeof(struct nrf_timeval);
   3e0b4:	2608      	movs	r6, #8
		nrf_rcvtimeo.tv_sec = ((struct timeval *)optval)->tv_sec;
   3e0b6:	682b      	ldr	r3, [r5, #0]
   3e0b8:	9304      	str	r3, [sp, #16]
		nrf_rcvtimeo.tv_usec = ((struct timeval *)optval)->tv_usec;
   3e0ba:	686b      	ldr	r3, [r5, #4]
		nrf_optval = &nrf_rcvtimeo;
   3e0bc:	ad04      	add	r5, sp, #16
		nrf_rcvtimeo.tv_usec = ((struct timeval *)optval)->tv_usec;
   3e0be:	9305      	str	r3, [sp, #20]
	retval = nrf_setsockopt(sd, nrf_level, nrf_optname, nrf_optval,
   3e0c0:	9600      	str	r6, [sp, #0]
   3e0c2:	462b      	mov	r3, r5
   3e0c4:	9a03      	ldr	r2, [sp, #12]
   3e0c6:	4621      	mov	r1, r4
   3e0c8:	4640      	mov	r0, r8
   3e0ca:	f7f2 ffaf 	bl	3102c <nrf_setsockopt>
}
   3e0ce:	b006      	add	sp, #24
   3e0d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (z_in_level) {
   3e0d4:	f240 2302 	movw	r3, #514	; 0x202
   3e0d8:	4299      	cmp	r1, r3
   3e0da:	d0e0      	beq.n	3e09e <nrf91_socket_offload_setsockopt+0x1c>
   3e0dc:	f240 2303 	movw	r3, #515	; 0x203
   3e0e0:	4299      	cmp	r1, r3
   3e0e2:	e7db      	b.n	3e09c <nrf91_socket_offload_setsockopt+0x1a>
	errno = ENOPROTOOPT;
   3e0e4:	f7fe fd1d 	bl	3cb22 <__errno>
   3e0e8:	236d      	movs	r3, #109	; 0x6d
   3e0ea:	6003      	str	r3, [r0, #0]
   3e0ec:	f04f 30ff 	mov.w	r0, #4294967295
   3e0f0:	e7ed      	b.n	3e0ce <nrf91_socket_offload_setsockopt+0x4c>

0003e0f2 <nrf91_socket_offload_bind>:
{
   3e0f2:	b510      	push	{r4, lr}
	if (addr->sa_family == AF_INET) {
   3e0f4:	880a      	ldrh	r2, [r1, #0]
{
   3e0f6:	b08a      	sub	sp, #40	; 0x28
	if (addr->sa_family == AF_INET) {
   3e0f8:	2a01      	cmp	r2, #1
{
   3e0fa:	4604      	mov	r4, r0
   3e0fc:	460b      	mov	r3, r1
	if (addr->sa_family == AF_INET) {
   3e0fe:	d10e      	bne.n	3e11e <nrf91_socket_offload_bind+0x2c>
	nrf_out->sin_port = ptr->sin_port;
   3e100:	8849      	ldrh	r1, [r1, #2]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   3e102:	2210      	movs	r2, #16
	nrf_out->sin_port = ptr->sin_port;
   3e104:	f8ad 100c 	strh.w	r1, [sp, #12]
	nrf_out->sin_family = NRF_AF_INET;
   3e108:	2102      	movs	r1, #2
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   3e10a:	685b      	ldr	r3, [r3, #4]
	nrf_out->sin_family = NRF_AF_INET;
   3e10c:	9102      	str	r1, [sp, #8]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   3e10e:	f88d 2004 	strb.w	r2, [sp, #4]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   3e112:	9304      	str	r3, [sp, #16]
		retval = nrf_bind(sd, (const struct nrf_sockaddr *)&ipv4,
   3e114:	a901      	add	r1, sp, #4
		retval = nrf_bind(sd, (const struct nrf_sockaddr *)&ipv6,
   3e116:	f7f2 ff77 	bl	31008 <nrf_bind>
}
   3e11a:	b00a      	add	sp, #40	; 0x28
   3e11c:	bd10      	pop	{r4, pc}
	} else if (addr->sa_family == AF_INET6) {
   3e11e:	2a02      	cmp	r2, #2
   3e120:	d107      	bne.n	3e132 <nrf91_socket_offload_bind+0x40>
		z_to_nrf_ipv6(addr, &ipv6);
   3e122:	a901      	add	r1, sp, #4
   3e124:	4618      	mov	r0, r3
   3e126:	f7ff fe92 	bl	3de4e <z_to_nrf_ipv6>
		retval = nrf_bind(sd, (const struct nrf_sockaddr *)&ipv6,
   3e12a:	2224      	movs	r2, #36	; 0x24
   3e12c:	a901      	add	r1, sp, #4
   3e12e:	4620      	mov	r0, r4
   3e130:	e7f1      	b.n	3e116 <nrf91_socket_offload_bind+0x24>
	errno = ENOTSUP;
   3e132:	f7fe fcf6 	bl	3cb22 <__errno>
   3e136:	2386      	movs	r3, #134	; 0x86
   3e138:	6003      	str	r3, [r0, #0]
   3e13a:	f04f 30ff 	mov.w	r0, #4294967295
   3e13e:	e7ec      	b.n	3e11a <nrf91_socket_offload_bind+0x28>

0003e140 <z_impl_uart_irq_rx_enable>:
	if (api->irq_rx_enable) {
   3e140:	6843      	ldr	r3, [r0, #4]
   3e142:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   3e144:	b103      	cbz	r3, 3e148 <z_impl_uart_irq_rx_enable+0x8>
		api->irq_rx_enable(dev);
   3e146:	4718      	bx	r3
}
   3e148:	4770      	bx	lr

0003e14a <response_handler>:
	write_uart_string(response);
   3e14a:	4608      	mov	r0, r1
   3e14c:	f7ed bad4 	b.w	2b6f8 <write_uart_string>

0003e150 <is_lfcr>:
	if ((chr == '\r') || (chr == '\n')) {
   3e150:	280d      	cmp	r0, #13
   3e152:	d004      	beq.n	3e15e <is_lfcr+0xe>
   3e154:	f1a0 030a 	sub.w	r3, r0, #10
   3e158:	4258      	negs	r0, r3
   3e15a:	4158      	adcs	r0, r3
   3e15c:	4770      	bx	lr
		return true;
   3e15e:	2001      	movs	r0, #1
}
   3e160:	4770      	bx	lr

0003e162 <skip_command_prefix>:
{
   3e162:	b510      	push	{r4, lr}
	*cmd += sizeof("AT") - 1;
   3e164:	6802      	ldr	r2, [r0, #0]
{
   3e166:	4601      	mov	r1, r0
	*cmd += sizeof("AT") - 1;
   3e168:	1c93      	adds	r3, r2, #2
   3e16a:	6003      	str	r3, [r0, #0]
	if (is_lfcr(**cmd) || is_terminated(**cmd)) {
   3e16c:	7894      	ldrb	r4, [r2, #2]
   3e16e:	4620      	mov	r0, r4
   3e170:	f7ff ffee 	bl	3e150 <is_lfcr>
   3e174:	b910      	cbnz	r0, 3e17c <skip_command_prefix+0x1a>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   3e176:	b10c      	cbz	r4, 3e17c <skip_command_prefix+0x1a>
	(*cmd)++;
   3e178:	3203      	adds	r2, #3
   3e17a:	600a      	str	r2, [r1, #0]
}
   3e17c:	bd10      	pop	{r4, pc}

0003e17e <at_params_list_init>:
{
   3e17e:	b538      	push	{r3, r4, r5, lr}
   3e180:	460d      	mov	r5, r1
	if (list == NULL) {
   3e182:	4604      	mov	r4, r0
   3e184:	b140      	cbz	r0, 3e198 <at_params_list_init+0x1a>
	list->params = k_calloc(max_params_count, sizeof(struct at_param));
   3e186:	210c      	movs	r1, #12
   3e188:	4628      	mov	r0, r5
   3e18a:	f000 f995 	bl	3e4b8 <k_calloc>
   3e18e:	6060      	str	r0, [r4, #4]
	if (list->params == NULL) {
   3e190:	b128      	cbz	r0, 3e19e <at_params_list_init+0x20>
	return 0;
   3e192:	2000      	movs	r0, #0
	list->param_count = max_params_count;
   3e194:	6025      	str	r5, [r4, #0]
}
   3e196:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   3e198:	f06f 0015 	mvn.w	r0, #21
   3e19c:	e7fb      	b.n	3e196 <at_params_list_init+0x18>
		return -ENOMEM;
   3e19e:	f06f 000b 	mvn.w	r0, #11
   3e1a2:	e7f8      	b.n	3e196 <at_params_list_init+0x18>

0003e1a4 <at_params_list_free>:

void at_params_list_free(struct at_param_list *list)
{
   3e1a4:	b538      	push	{r3, r4, r5, lr}
	if (list == NULL || list->params == NULL) {
   3e1a6:	4604      	mov	r4, r0
   3e1a8:	b148      	cbz	r0, 3e1be <at_params_list_free+0x1a>
   3e1aa:	6843      	ldr	r3, [r0, #4]
   3e1ac:	b13b      	cbz	r3, 3e1be <at_params_list_free+0x1a>
		return;
	}

	at_params_list_clear(list);

	list->param_count = 0;
   3e1ae:	2500      	movs	r5, #0
	at_params_list_clear(list);
   3e1b0:	f7ed fee2 	bl	2bf78 <at_params_list_clear>
	list->param_count = 0;
   3e1b4:	6025      	str	r5, [r4, #0]
	k_free(list->params);
   3e1b6:	6860      	ldr	r0, [r4, #4]
   3e1b8:	f000 f979 	bl	3e4ae <k_free>
	list->params = NULL;
   3e1bc:	6065      	str	r5, [r4, #4]
}
   3e1be:	bd38      	pop	{r3, r4, r5, pc}

0003e1c0 <at_params_short_put>:

int at_params_short_put(const struct at_param_list *list, size_t index,
			u16_t value)
{
   3e1c0:	b538      	push	{r3, r4, r5, lr}
   3e1c2:	4615      	mov	r5, r2
	if (list == NULL || list->params == NULL) {
   3e1c4:	b910      	cbnz	r0, 3e1cc <at_params_short_put+0xc>
		return -EINVAL;
   3e1c6:	f06f 0015 	mvn.w	r0, #21
	at_param_clear(param);

	param->type = AT_PARAM_TYPE_NUM_SHORT;
	param->value.int_val = (u32_t)(value & USHRT_MAX);
	return 0;
}
   3e1ca:	bd38      	pop	{r3, r4, r5, pc}
	if (list == NULL || list->params == NULL) {
   3e1cc:	6843      	ldr	r3, [r0, #4]
   3e1ce:	2b00      	cmp	r3, #0
   3e1d0:	d0f9      	beq.n	3e1c6 <at_params_short_put+0x6>
	struct at_param *param = at_params_get(list, index);
   3e1d2:	f7ed fe65 	bl	2bea0 <at_params_get>
	if (param == NULL) {
   3e1d6:	4604      	mov	r4, r0
   3e1d8:	2800      	cmp	r0, #0
   3e1da:	d0f4      	beq.n	3e1c6 <at_params_short_put+0x6>
	at_param_clear(param);
   3e1dc:	f7ed feaa 	bl	2bf34 <at_param_clear>
	param->type = AT_PARAM_TYPE_NUM_SHORT;
   3e1e0:	2301      	movs	r3, #1
	param->value.int_val = (u32_t)(value & USHRT_MAX);
   3e1e2:	60a5      	str	r5, [r4, #8]
	param->type = AT_PARAM_TYPE_NUM_SHORT;
   3e1e4:	7023      	strb	r3, [r4, #0]
	return 0;
   3e1e6:	2000      	movs	r0, #0
   3e1e8:	e7ef      	b.n	3e1ca <at_params_short_put+0xa>

0003e1ea <at_params_empty_put>:

int at_params_empty_put(const struct at_param_list *list, size_t index)
{
   3e1ea:	b510      	push	{r4, lr}
	if (list == NULL || list->params == NULL) {
   3e1ec:	b910      	cbnz	r0, 3e1f4 <at_params_empty_put+0xa>
		return -EINVAL;
   3e1ee:	f06f 0015 	mvn.w	r0, #21

	param->type = AT_PARAM_TYPE_EMPTY;
	param->value.int_val = 0;

	return 0;
}
   3e1f2:	bd10      	pop	{r4, pc}
	if (list == NULL || list->params == NULL) {
   3e1f4:	6843      	ldr	r3, [r0, #4]
   3e1f6:	2b00      	cmp	r3, #0
   3e1f8:	d0f9      	beq.n	3e1ee <at_params_empty_put+0x4>
	struct at_param *param = at_params_get(list, index);
   3e1fa:	f7ed fe51 	bl	2bea0 <at_params_get>
	if (param == NULL) {
   3e1fe:	4604      	mov	r4, r0
   3e200:	2800      	cmp	r0, #0
   3e202:	d0f4      	beq.n	3e1ee <at_params_empty_put+0x4>
	at_param_clear(param);
   3e204:	f7ed fe96 	bl	2bf34 <at_param_clear>
	param->type = AT_PARAM_TYPE_EMPTY;
   3e208:	2305      	movs	r3, #5
	param->value.int_val = 0;
   3e20a:	2000      	movs	r0, #0
	param->type = AT_PARAM_TYPE_EMPTY;
   3e20c:	7023      	strb	r3, [r4, #0]
	param->value.int_val = 0;
   3e20e:	60a0      	str	r0, [r4, #8]
	return 0;
   3e210:	e7ef      	b.n	3e1f2 <at_params_empty_put+0x8>

0003e212 <at_params_int_put>:

int at_params_int_put(const struct at_param_list *list, size_t index,
		      u32_t value)
{
   3e212:	b538      	push	{r3, r4, r5, lr}
   3e214:	4615      	mov	r5, r2
	if (list == NULL || list->params == NULL) {
   3e216:	b910      	cbnz	r0, 3e21e <at_params_int_put+0xc>
		return -EINVAL;
   3e218:	f06f 0015 	mvn.w	r0, #21
	at_param_clear(param);

	param->type = AT_PARAM_TYPE_NUM_INT;
	param->value.int_val = value;
	return 0;
}
   3e21c:	bd38      	pop	{r3, r4, r5, pc}
	if (list == NULL || list->params == NULL) {
   3e21e:	6843      	ldr	r3, [r0, #4]
   3e220:	2b00      	cmp	r3, #0
   3e222:	d0f9      	beq.n	3e218 <at_params_int_put+0x6>
	struct at_param *param = at_params_get(list, index);
   3e224:	f7ed fe3c 	bl	2bea0 <at_params_get>
	if (param == NULL) {
   3e228:	4604      	mov	r4, r0
   3e22a:	2800      	cmp	r0, #0
   3e22c:	d0f4      	beq.n	3e218 <at_params_int_put+0x6>
	at_param_clear(param);
   3e22e:	f7ed fe81 	bl	2bf34 <at_param_clear>
	param->type = AT_PARAM_TYPE_NUM_INT;
   3e232:	2302      	movs	r3, #2
	param->value.int_val = value;
   3e234:	60a5      	str	r5, [r4, #8]
	param->type = AT_PARAM_TYPE_NUM_INT;
   3e236:	7023      	strb	r3, [r4, #0]
	return 0;
   3e238:	2000      	movs	r0, #0
   3e23a:	e7ef      	b.n	3e21c <at_params_int_put+0xa>

0003e23c <at_params_string_put>:

int at_params_string_put(const struct at_param_list *list, size_t index,
			 const char *str, size_t str_len)
{
   3e23c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3e23e:	4616      	mov	r6, r2
   3e240:	461d      	mov	r5, r3
	if (list == NULL || list->params == NULL || str == NULL) {
   3e242:	b910      	cbnz	r0, 3e24a <at_params_string_put+0xe>
		return -EINVAL;
   3e244:	f06f 0015 	mvn.w	r0, #21
	param->size = str_len;
	param->type = AT_PARAM_TYPE_STRING;
	param->value.str_val = param_value;

	return 0;
}
   3e248:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (list == NULL || list->params == NULL || str == NULL) {
   3e24a:	6843      	ldr	r3, [r0, #4]
   3e24c:	2b00      	cmp	r3, #0
   3e24e:	d0f9      	beq.n	3e244 <at_params_string_put+0x8>
   3e250:	2a00      	cmp	r2, #0
   3e252:	d0f7      	beq.n	3e244 <at_params_string_put+0x8>
	struct at_param *param = at_params_get(list, index);
   3e254:	f7ed fe24 	bl	2bea0 <at_params_get>
	if (param == NULL) {
   3e258:	4604      	mov	r4, r0
   3e25a:	2800      	cmp	r0, #0
   3e25c:	d0f2      	beq.n	3e244 <at_params_string_put+0x8>
	char *param_value = (char *)k_malloc(str_len + 1);
   3e25e:	1c68      	adds	r0, r5, #1
   3e260:	f7f7 fd5a 	bl	35d18 <k_malloc>
	if (param_value == NULL) {
   3e264:	4607      	mov	r7, r0
   3e266:	b160      	cbz	r0, 3e282 <at_params_string_put+0x46>
   3e268:	462a      	mov	r2, r5
   3e26a:	4631      	mov	r1, r6
   3e26c:	f000 faee 	bl	3e84c <memcpy>
	at_param_clear(param);
   3e270:	4620      	mov	r0, r4
   3e272:	f7ed fe5f 	bl	2bf34 <at_param_clear>
	param->type = AT_PARAM_TYPE_STRING;
   3e276:	2303      	movs	r3, #3
	param->size = str_len;
   3e278:	6065      	str	r5, [r4, #4]
	param->type = AT_PARAM_TYPE_STRING;
   3e27a:	7023      	strb	r3, [r4, #0]
	param->value.str_val = param_value;
   3e27c:	60a7      	str	r7, [r4, #8]
	return 0;
   3e27e:	2000      	movs	r0, #0
   3e280:	e7e2      	b.n	3e248 <at_params_string_put+0xc>
		return -ENOMEM;
   3e282:	f06f 000b 	mvn.w	r0, #11
   3e286:	e7df      	b.n	3e248 <at_params_string_put+0xc>

0003e288 <at_params_array_put>:

int at_params_array_put(const struct at_param_list *list, size_t index,
			const u32_t *array, size_t array_len)
{
   3e288:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3e28a:	4616      	mov	r6, r2
   3e28c:	461d      	mov	r5, r3
	if (list == NULL || list->params == NULL || array == NULL) {
   3e28e:	b910      	cbnz	r0, 3e296 <at_params_array_put+0xe>
		return -EINVAL;
   3e290:	f06f 0015 	mvn.w	r0, #21
	param->size = array_len;
	param->type = AT_PARAM_TYPE_ARRAY;
	param->value.array_val = param_value;

	return 0;
}
   3e294:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (list == NULL || list->params == NULL || array == NULL) {
   3e296:	6843      	ldr	r3, [r0, #4]
   3e298:	2b00      	cmp	r3, #0
   3e29a:	d0f9      	beq.n	3e290 <at_params_array_put+0x8>
   3e29c:	2a00      	cmp	r2, #0
   3e29e:	d0f7      	beq.n	3e290 <at_params_array_put+0x8>
	struct at_param *param = at_params_get(list, index);
   3e2a0:	f7ed fdfe 	bl	2bea0 <at_params_get>
	if (param == NULL) {
   3e2a4:	4604      	mov	r4, r0
   3e2a6:	2800      	cmp	r0, #0
   3e2a8:	d0f2      	beq.n	3e290 <at_params_array_put+0x8>
	u32_t *param_value = (u32_t *)k_malloc(array_len);
   3e2aa:	4628      	mov	r0, r5
   3e2ac:	f7f7 fd34 	bl	35d18 <k_malloc>
	if (param_value == NULL) {
   3e2b0:	4607      	mov	r7, r0
   3e2b2:	b160      	cbz	r0, 3e2ce <at_params_array_put+0x46>
   3e2b4:	462a      	mov	r2, r5
   3e2b6:	4631      	mov	r1, r6
   3e2b8:	f000 fac8 	bl	3e84c <memcpy>
	at_param_clear(param);
   3e2bc:	4620      	mov	r0, r4
   3e2be:	f7ed fe39 	bl	2bf34 <at_param_clear>
	param->type = AT_PARAM_TYPE_ARRAY;
   3e2c2:	2304      	movs	r3, #4
	param->size = array_len;
   3e2c4:	6065      	str	r5, [r4, #4]
	param->type = AT_PARAM_TYPE_ARRAY;
   3e2c6:	7023      	strb	r3, [r4, #0]
	param->value.array_val = param_value;
   3e2c8:	60a7      	str	r7, [r4, #8]
	return 0;
   3e2ca:	2000      	movs	r0, #0
   3e2cc:	e7e2      	b.n	3e294 <at_params_array_put+0xc>
		return -ENOMEM;
   3e2ce:	f06f 000b 	mvn.w	r0, #11
   3e2d2:	e7df      	b.n	3e294 <at_params_array_put+0xc>

0003e2d4 <at_params_short_get>:
	return 0;
}

int at_params_short_get(const struct at_param_list *list, size_t index,
			u16_t *value)
{
   3e2d4:	b510      	push	{r4, lr}
   3e2d6:	4614      	mov	r4, r2
	if (list == NULL || list->params == NULL || value == NULL) {
   3e2d8:	b910      	cbnz	r0, 3e2e0 <at_params_short_get+0xc>
		return -EINVAL;
   3e2da:	f06f 0015 	mvn.w	r0, #21
		return -EINVAL;
	}

	*value = (u16_t)param->value.int_val;
	return 0;
}
   3e2de:	bd10      	pop	{r4, pc}
	if (list == NULL || list->params == NULL || value == NULL) {
   3e2e0:	6843      	ldr	r3, [r0, #4]
   3e2e2:	2b00      	cmp	r3, #0
   3e2e4:	d0f9      	beq.n	3e2da <at_params_short_get+0x6>
   3e2e6:	2a00      	cmp	r2, #0
   3e2e8:	d0f7      	beq.n	3e2da <at_params_short_get+0x6>
	struct at_param *param = at_params_get(list, index);
   3e2ea:	f7ed fdd9 	bl	2bea0 <at_params_get>
	if (param == NULL) {
   3e2ee:	2800      	cmp	r0, #0
   3e2f0:	d0f3      	beq.n	3e2da <at_params_short_get+0x6>
	if (param->type != AT_PARAM_TYPE_NUM_SHORT) {
   3e2f2:	7803      	ldrb	r3, [r0, #0]
   3e2f4:	2b01      	cmp	r3, #1
   3e2f6:	d1f0      	bne.n	3e2da <at_params_short_get+0x6>
	*value = (u16_t)param->value.int_val;
   3e2f8:	6883      	ldr	r3, [r0, #8]
	return 0;
   3e2fa:	2000      	movs	r0, #0
	*value = (u16_t)param->value.int_val;
   3e2fc:	8023      	strh	r3, [r4, #0]
	return 0;
   3e2fe:	e7ee      	b.n	3e2de <at_params_short_get+0xa>

0003e300 <at_params_int_get>:

int at_params_int_get(const struct at_param_list *list, size_t index,
		      u32_t *value)
{
   3e300:	b510      	push	{r4, lr}
   3e302:	4614      	mov	r4, r2
	if (list == NULL || list->params == NULL || value == NULL) {
   3e304:	b910      	cbnz	r0, 3e30c <at_params_int_get+0xc>
		return -EINVAL;
   3e306:	f06f 0015 	mvn.w	r0, #21
		return -EINVAL;
	}

	*value = param->value.int_val;
	return 0;
}
   3e30a:	bd10      	pop	{r4, pc}
	if (list == NULL || list->params == NULL || value == NULL) {
   3e30c:	6843      	ldr	r3, [r0, #4]
   3e30e:	2b00      	cmp	r3, #0
   3e310:	d0f9      	beq.n	3e306 <at_params_int_get+0x6>
   3e312:	2a00      	cmp	r2, #0
   3e314:	d0f7      	beq.n	3e306 <at_params_int_get+0x6>
	struct at_param *param = at_params_get(list, index);
   3e316:	f7ed fdc3 	bl	2bea0 <at_params_get>
	if (param == NULL) {
   3e31a:	2800      	cmp	r0, #0
   3e31c:	d0f3      	beq.n	3e306 <at_params_int_get+0x6>
	if ((param->type != AT_PARAM_TYPE_NUM_INT) &&
   3e31e:	7803      	ldrb	r3, [r0, #0]
   3e320:	3b01      	subs	r3, #1
   3e322:	2b01      	cmp	r3, #1
   3e324:	d8ef      	bhi.n	3e306 <at_params_int_get+0x6>
	*value = param->value.int_val;
   3e326:	6883      	ldr	r3, [r0, #8]
	return 0;
   3e328:	2000      	movs	r0, #0
	*value = param->value.int_val;
   3e32a:	6023      	str	r3, [r4, #0]
	return 0;
   3e32c:	e7ed      	b.n	3e30a <at_params_int_get+0xa>

0003e32e <at_params_string_get>:

int at_params_string_get(const struct at_param_list *list, size_t index,
			 char *value, size_t *len)
{
   3e32e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3e330:	4616      	mov	r6, r2
   3e332:	461c      	mov	r4, r3
	if (list == NULL || list->params == NULL || value == NULL ||
   3e334:	b910      	cbnz	r0, 3e33c <at_params_string_get+0xe>
	    value == NULL || len == NULL) {
		return -EINVAL;
   3e336:	f06f 0015 	mvn.w	r0, #21

	memcpy(value, param->value.str_val, param_len);
	*len = param_len;

	return 0;
}
   3e33a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (list == NULL || list->params == NULL || value == NULL ||
   3e33c:	6843      	ldr	r3, [r0, #4]
   3e33e:	2b00      	cmp	r3, #0
   3e340:	d0f9      	beq.n	3e336 <at_params_string_get+0x8>
   3e342:	2a00      	cmp	r2, #0
   3e344:	d0f7      	beq.n	3e336 <at_params_string_get+0x8>
	    value == NULL || len == NULL) {
   3e346:	2c00      	cmp	r4, #0
   3e348:	d0f5      	beq.n	3e336 <at_params_string_get+0x8>
	struct at_param *param = at_params_get(list, index);
   3e34a:	f7ed fda9 	bl	2bea0 <at_params_get>
	if (param == NULL) {
   3e34e:	4607      	mov	r7, r0
   3e350:	2800      	cmp	r0, #0
   3e352:	d0f0      	beq.n	3e336 <at_params_string_get+0x8>
	if (param->type != AT_PARAM_TYPE_STRING) {
   3e354:	7803      	ldrb	r3, [r0, #0]
   3e356:	2b03      	cmp	r3, #3
   3e358:	d1ed      	bne.n	3e336 <at_params_string_get+0x8>
	size_t param_len = at_param_size(param);
   3e35a:	f7ed fdc3 	bl	2bee4 <at_param_size>
	if (*len < param_len) {
   3e35e:	6823      	ldr	r3, [r4, #0]
	size_t param_len = at_param_size(param);
   3e360:	4605      	mov	r5, r0
	if (*len < param_len) {
   3e362:	4283      	cmp	r3, r0
   3e364:	d307      	bcc.n	3e376 <at_params_string_get+0x48>
   3e366:	4602      	mov	r2, r0
   3e368:	68b9      	ldr	r1, [r7, #8]
   3e36a:	4630      	mov	r0, r6
   3e36c:	f000 fa6e 	bl	3e84c <memcpy>
	*len = param_len;
   3e370:	6025      	str	r5, [r4, #0]
	return 0;
   3e372:	2000      	movs	r0, #0
   3e374:	e7e1      	b.n	3e33a <at_params_string_get+0xc>
		return -ENOMEM;
   3e376:	f06f 000b 	mvn.w	r0, #11
   3e37a:	e7de      	b.n	3e33a <at_params_string_get+0xc>

0003e37c <at_params_valid_count_get>:

	return 0;
}

u32_t at_params_valid_count_get(const struct at_param_list *list)
{
   3e37c:	b538      	push	{r3, r4, r5, lr}
	if (list == NULL || list->params == NULL) {
   3e37e:	4605      	mov	r5, r0
   3e380:	b180      	cbz	r0, 3e3a4 <at_params_valid_count_get+0x28>
   3e382:	6843      	ldr	r3, [r0, #4]
   3e384:	b173      	cbz	r3, 3e3a4 <at_params_valid_count_get+0x28>
		return -EINVAL;
	}

	size_t valid_i = 0;
	struct at_param *param = at_params_get(list, valid_i);
   3e386:	2100      	movs	r1, #0
   3e388:	f7ed fd8a 	bl	2bea0 <at_params_get>
	size_t valid_i = 0;
   3e38c:	2400      	movs	r4, #0

	while (param != NULL && param->type != AT_PARAM_TYPE_INVALID) {
   3e38e:	b108      	cbz	r0, 3e394 <at_params_valid_count_get+0x18>
   3e390:	7803      	ldrb	r3, [r0, #0]
   3e392:	b90b      	cbnz	r3, 3e398 <at_params_valid_count_get+0x1c>
		valid_i += 1;
		param = at_params_get(list, valid_i);
	}

	return valid_i;
}
   3e394:	4620      	mov	r0, r4
   3e396:	bd38      	pop	{r3, r4, r5, pc}
		valid_i += 1;
   3e398:	3401      	adds	r4, #1
		param = at_params_get(list, valid_i);
   3e39a:	4621      	mov	r1, r4
   3e39c:	4628      	mov	r0, r5
   3e39e:	f7ed fd7f 	bl	2bea0 <at_params_get>
   3e3a2:	e7f4      	b.n	3e38e <at_params_valid_count_get+0x12>
		return -EINVAL;
   3e3a4:	f06f 0415 	mvn.w	r4, #21
   3e3a8:	e7f4      	b.n	3e394 <at_params_valid_count_get+0x18>

0003e3aa <response_is_valid>:
{
   3e3aa:	b570      	push	{r4, r5, r6, lr}
   3e3ac:	4606      	mov	r6, r0
	if ((response_len < strlen(check)) ||
   3e3ae:	4610      	mov	r0, r2
{
   3e3b0:	460d      	mov	r5, r1
   3e3b2:	4614      	mov	r4, r2
	if ((response_len < strlen(check)) ||
   3e3b4:	f7de fed0 	bl	1d158 <strlen>
   3e3b8:	42a8      	cmp	r0, r5
   3e3ba:	d808      	bhi.n	3e3ce <response_is_valid+0x24>
	    (memcmp(response, check, response_len) != 0)) {
   3e3bc:	462a      	mov	r2, r5
   3e3be:	4621      	mov	r1, r4
   3e3c0:	4630      	mov	r0, r6
   3e3c2:	f000 fa35 	bl	3e830 <memcmp>
	if ((response_len < strlen(check)) ||
   3e3c6:	fab0 f080 	clz	r0, r0
   3e3ca:	0940      	lsrs	r0, r0, #5
}
   3e3cc:	bd70      	pop	{r4, r5, r6, pc}
		return false;
   3e3ce:	2000      	movs	r0, #0
   3e3d0:	e7fc      	b.n	3e3cc <response_is_valid+0x22>

0003e3d2 <lte_lc_init_and_connect>:
{
   3e3d2:	b508      	push	{r3, lr}
	ret = w_lte_lc_init();
   3e3d4:	f7ed fe08 	bl	2bfe8 <w_lte_lc_init>
	if (ret) {
   3e3d8:	b918      	cbnz	r0, 3e3e2 <lte_lc_init_and_connect+0x10>
}
   3e3da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return w_lte_lc_connect();
   3e3de:	f7ed bf1b 	b.w	2c218 <w_lte_lc_connect>
}
   3e3e2:	bd08      	pop	{r3, pc}

0003e3e4 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   3e3e4:	4700      	bx	r0

0003e3e6 <nrfx_nvmc_flash_size_get>:
}

uint32_t nrfx_nvmc_flash_size_get(void)
{
    return flash_total_size_get();
}
   3e3e6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   3e3ea:	4770      	bx	lr

0003e3ec <nrfx_nvmc_flash_page_size_get>:

uint32_t nrfx_nvmc_flash_page_size_get(void)
{
    return flash_page_size_get();
}
   3e3ec:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   3e3f0:	4770      	bx	lr

0003e3f2 <nrfx_nvmc_flash_page_count_get>:

uint32_t nrfx_nvmc_flash_page_count_get(void)
{
    return flash_page_count_get();
}
   3e3f2:	f44f 7080 	mov.w	r0, #256	; 0x100
   3e3f6:	4770      	bx	lr

0003e3f8 <finish_transfer>:
{
   3e3f8:	b510      	push	{r4, lr}
   3e3fa:	4604      	mov	r4, r0
    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   3e3fc:	7fc0      	ldrb	r0, [r0, #31]
   3e3fe:	28ff      	cmp	r0, #255	; 0xff
   3e400:	d003      	beq.n	3e40a <finish_transfer+0x12>
            if (p_cb->ss_active_high)
   3e402:	7fa3      	ldrb	r3, [r4, #30]
   3e404:	b15b      	cbz	r3, 3e41e <finish_transfer+0x26>
                nrf_gpio_pin_clear(p_cb->ss_pin);
   3e406:	f7f6 fc0b 	bl	34c20 <nrf_gpio_pin_clear>
    p_cb->transfer_in_progress = false;
   3e40a:	2300      	movs	r3, #0
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   3e40c:	4620      	mov	r0, r4
    p_cb->transfer_in_progress = false;
   3e40e:	7763      	strb	r3, [r4, #29]
    p_cb->evt.type = NRFX_SPIM_EVENT_DONE;
   3e410:	7223      	strb	r3, [r4, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   3e412:	6861      	ldr	r1, [r4, #4]
   3e414:	f850 3b08 	ldr.w	r3, [r0], #8
}
   3e418:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   3e41c:	4718      	bx	r3
                nrf_gpio_pin_set(p_cb->ss_pin);
   3e41e:	f7f6 fc0b 	bl	34c38 <nrf_gpio_pin_set>
   3e422:	e7f2      	b.n	3e40a <finish_transfer+0x12>

0003e424 <xfer_completeness_check>:
    switch (p_cb->xfer_desc.type)
   3e424:	7b0b      	ldrb	r3, [r1, #12]
   3e426:	2b03      	cmp	r3, #3
   3e428:	d82a      	bhi.n	3e480 <xfer_completeness_check+0x5c>
   3e42a:	e8df f003 	tbb	[pc, r3]
   3e42e:	2622      	.short	0x2622
   3e430:	021a      	.short	0x021a
            if (((p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   3e432:	688b      	ldr	r3, [r1, #8]
   3e434:	035a      	lsls	r2, r3, #13
   3e436:	d504      	bpl.n	3e442 <xfer_completeness_check+0x1e>
    return p_reg->TXD.AMOUNT;
   3e438:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
   3e43c:	690a      	ldr	r2, [r1, #16]
   3e43e:	429a      	cmp	r2, r3
   3e440:	d107      	bne.n	3e452 <xfer_completeness_check+0x2e>
                (!(p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   3e442:	688b      	ldr	r3, [r1, #8]
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)) ||
   3e444:	035b      	lsls	r3, r3, #13
   3e446:	d41b      	bmi.n	3e480 <xfer_completeness_check+0x5c>
   3e448:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   3e44c:	694a      	ldr	r2, [r1, #20]
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   3e44e:	429a      	cmp	r2, r3
   3e450:	d016      	beq.n	3e480 <xfer_completeness_check+0x5c>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   3e452:	2300      	movs	r3, #0
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   3e454:	2206      	movs	r2, #6
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   3e456:	f8c0 3500 	str.w	r3, [r0, #1280]	; 0x500
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   3e45a:	f8c0 2500 	str.w	r2, [r0, #1280]	; 0x500
   3e45e:	4618      	mov	r0, r3
   3e460:	4770      	bx	lr
    return p_reg->TXD.AMOUNT;
   3e462:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   3e466:	690a      	ldr	r2, [r1, #16]
   3e468:	429a      	cmp	r2, r3
   3e46a:	d1f2      	bne.n	3e452 <xfer_completeness_check+0x2e>
    return p_reg->RXD.AMOUNT;
   3e46c:	f8d0 353c 	ldr.w	r3, [r0, #1340]	; 0x53c
   3e470:	e7ec      	b.n	3e44c <xfer_completeness_check+0x28>
    return p_reg->TXD.AMOUNT;
   3e472:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   3e476:	690a      	ldr	r2, [r1, #16]
   3e478:	e7e9      	b.n	3e44e <xfer_completeness_check+0x2a>
    return p_reg->RXD.AMOUNT;
   3e47a:	f8d0 353c 	ldr.w	r3, [r0, #1340]	; 0x53c
   3e47e:	e7fa      	b.n	3e476 <xfer_completeness_check+0x52>
    bool transfer_complete = true;
   3e480:	2001      	movs	r0, #1
}
   3e482:	4770      	bx	lr

0003e484 <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
   3e484:	f7fe baeb 	b.w	3ca5e <z_clock_idle_exit>

0003e488 <k_mem_pool_malloc>:
{
   3e488:	b507      	push	{r0, r1, r2, lr}
   3e48a:	2204      	movs	r2, #4
   3e48c:	188a      	adds	r2, r1, r2
   3e48e:	d204      	bcs.n	3e49a <k_mem_pool_malloc+0x12>
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
   3e490:	2300      	movs	r3, #0
   3e492:	4669      	mov	r1, sp
   3e494:	f7f7 fb7a 	bl	35b8c <k_mem_pool_alloc>
   3e498:	b118      	cbz	r0, 3e4a2 <k_mem_pool_malloc+0x1a>
		return NULL;
   3e49a:	2000      	movs	r0, #0
}
   3e49c:	b003      	add	sp, #12
   3e49e:	f85d fb04 	ldr.w	pc, [sp], #4
   3e4a2:	e9dd 3200 	ldrd	r3, r2, [sp]
   3e4a6:	601a      	str	r2, [r3, #0]
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
   3e4a8:	9800      	ldr	r0, [sp, #0]
   3e4aa:	3004      	adds	r0, #4
   3e4ac:	e7f6      	b.n	3e49c <k_mem_pool_malloc+0x14>

0003e4ae <k_free>:
	if (ptr != NULL) {
   3e4ae:	b110      	cbz	r0, 3e4b6 <k_free+0x8>
		k_mem_pool_free_id(ptr);
   3e4b0:	3804      	subs	r0, #4
   3e4b2:	f7f7 bbd3 	b.w	35c5c <k_mem_pool_free_id>
}
   3e4b6:	4770      	bx	lr

0003e4b8 <k_calloc>:
{
   3e4b8:	b538      	push	{r3, r4, r5, lr}
	return a != 0 && (c / a) != b;
}

static inline bool size_mul_overflow(size_t a, size_t b, size_t *result)
{
	size_t c = a * b;
   3e4ba:	fb01 f400 	mul.w	r4, r1, r0

	*result = c;

	return a != 0 && (c / a) != b;
   3e4be:	b118      	cbz	r0, 3e4c8 <k_calloc+0x10>
   3e4c0:	fbb4 f0f0 	udiv	r0, r4, r0
   3e4c4:	4281      	cmp	r1, r0
   3e4c6:	d10a      	bne.n	3e4de <k_calloc+0x26>
	ret = k_malloc(bounds);
   3e4c8:	4620      	mov	r0, r4
   3e4ca:	f7f7 fc25 	bl	35d18 <k_malloc>
	if (ret != NULL) {
   3e4ce:	4605      	mov	r5, r0
   3e4d0:	b118      	cbz	r0, 3e4da <k_calloc+0x22>
__ssp_bos_icheck3(memset, void *, int)
   3e4d2:	4622      	mov	r2, r4
   3e4d4:	2100      	movs	r1, #0
   3e4d6:	f000 f9d9 	bl	3e88c <memset>
}
   3e4da:	4628      	mov	r0, r5
   3e4dc:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
   3e4de:	2500      	movs	r5, #0
   3e4e0:	e7fb      	b.n	3e4da <k_calloc+0x22>

0003e4e2 <z_impl_k_mutex_init>:
{
   3e4e2:	4603      	mov	r3, r0
	mutex->owner = NULL;
   3e4e4:	2000      	movs	r0, #0
	list->tail = (sys_dnode_t *)list;
   3e4e6:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
   3e4ea:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
   3e4ee:	4770      	bx	lr

0003e4f0 <z_queue_node_peek>:
{
   3e4f0:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
   3e4f2:	4604      	mov	r4, r0
   3e4f4:	b130      	cbz	r0, 3e504 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   3e4f6:	6802      	ldr	r2, [r0, #0]
   3e4f8:	0793      	lsls	r3, r2, #30
   3e4fa:	d003      	beq.n	3e504 <z_queue_node_peek+0x14>
		ret = anode->data;
   3e4fc:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   3e4fe:	b109      	cbz	r1, 3e504 <z_queue_node_peek+0x14>
			k_free(anode);
   3e500:	f7ff ffd5 	bl	3e4ae <k_free>
}
   3e504:	4620      	mov	r0, r4
   3e506:	bd10      	pop	{r4, pc}

0003e508 <z_impl_k_queue_init>:
	list->head = NULL;
   3e508:	2300      	movs	r3, #0
	list->tail = NULL;
   3e50a:	e9c0 3300 	strd	r3, r3, [r0]
	queue->lock = (struct k_spinlock) {};
   3e50e:	6083      	str	r3, [r0, #8]
	sys_dlist_init(&queue->poll_events);
   3e510:	f100 030c 	add.w	r3, r0, #12
   3e514:	e9c0 3303 	strd	r3, r3, [r0, #12]
}
   3e518:	4770      	bx	lr

0003e51a <k_queue_append>:
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
   3e51a:	460a      	mov	r2, r1
   3e51c:	2300      	movs	r3, #0
   3e51e:	6841      	ldr	r1, [r0, #4]
   3e520:	f7f7 befe 	b.w	36320 <queue_insert>

0003e524 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   3e524:	7b43      	ldrb	r3, [r0, #13]
   3e526:	06db      	lsls	r3, r3, #27
   3e528:	bf03      	ittte	eq
   3e52a:	6980      	ldreq	r0, [r0, #24]
   3e52c:	fab0 f080 	clzeq	r0, r0
   3e530:	0940      	lsreq	r0, r0, #5
   3e532:	2000      	movne	r0, #0
}
   3e534:	4770      	bx	lr

0003e536 <z_is_t1_higher_prio_than_t2>:
	if (thread_1->base.prio < thread_2->base.prio) {
   3e536:	f990 000e 	ldrsb.w	r0, [r0, #14]
   3e53a:	f991 300e 	ldrsb.w	r3, [r1, #14]
}
   3e53e:	4298      	cmp	r0, r3
   3e540:	bfac      	ite	ge
   3e542:	2000      	movge	r0, #0
   3e544:	2001      	movlt	r0, #1
   3e546:	4770      	bx	lr

0003e548 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   3e548:	4603      	mov	r3, r0
   3e54a:	b920      	cbnz	r0, 3e556 <z_reschedule_irqlock+0xe>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   3e54c:	f3ef 8205 	mrs	r2, IPSR
   3e550:	b90a      	cbnz	r2, 3e556 <z_reschedule_irqlock+0xe>
   3e552:	f7e9 bdd5 	b.w	28100 <arch_swap>
   3e556:	f383 8811 	msr	BASEPRI, r3
   3e55a:	f3bf 8f6f 	isb	sy
}
   3e55e:	4770      	bx	lr

0003e560 <z_reschedule_unlocked>:
	__asm__ volatile(
   3e560:	f04f 0320 	mov.w	r3, #32
   3e564:	f3ef 8011 	mrs	r0, BASEPRI
   3e568:	f383 8811 	msr	BASEPRI, r3
   3e56c:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   3e570:	f7ff bfea 	b.w	3e548 <z_reschedule_irqlock>

0003e574 <z_priq_dumb_best>:
	return list->head == list;
   3e574:	6803      	ldr	r3, [r0, #0]
}
   3e576:	4298      	cmp	r0, r3
   3e578:	bf14      	ite	ne
   3e57a:	4618      	movne	r0, r3
   3e57c:	2000      	moveq	r0, #0
   3e57e:	4770      	bx	lr

0003e580 <z_unpend_all>:
{
   3e580:	b570      	push	{r4, r5, r6, lr}
   3e582:	4606      	mov	r6, r0
	int need_sched = 0;
   3e584:	2500      	movs	r5, #0
   3e586:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   3e588:	42a6      	cmp	r6, r4
   3e58a:	d000      	beq.n	3e58e <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   3e58c:	b90c      	cbnz	r4, 3e592 <z_unpend_all+0x12>
}
   3e58e:	4628      	mov	r0, r5
   3e590:	bd70      	pop	{r4, r5, r6, pc}
		z_unpend_thread(thread);
   3e592:	4620      	mov	r0, r4
   3e594:	f7f8 fa38 	bl	36a08 <z_unpend_thread>
	if (z_is_thread_ready(thread)) {
   3e598:	4620      	mov	r0, r4
   3e59a:	f7ff ffc3 	bl	3e524 <z_is_thread_ready>
		need_sched = 1;
   3e59e:	2501      	movs	r5, #1
   3e5a0:	2800      	cmp	r0, #0
   3e5a2:	d0f0      	beq.n	3e586 <z_unpend_all+0x6>
		z_add_thread_to_ready_q(thread);
   3e5a4:	4620      	mov	r0, r4
   3e5a6:	f7f8 fb37 	bl	36c18 <z_add_thread_to_ready_q>
   3e5aa:	e7ec      	b.n	3e586 <z_unpend_all+0x6>

0003e5ac <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || initial_count > limit) {
   3e5ac:	b15a      	cbz	r2, 3e5c6 <z_impl_k_sem_init+0x1a>
   3e5ae:	428a      	cmp	r2, r1
   3e5b0:	d309      	bcc.n	3e5c6 <z_impl_k_sem_init+0x1a>
	sys_dlist_init(&sem->poll_events);
   3e5b2:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
   3e5b6:	e9c0 1202 	strd	r1, r2, [r0, #8]
	list->tail = (sys_dnode_t *)list;
   3e5ba:	e9c0 0000 	strd	r0, r0, [r0]
   3e5be:	e9c0 3304 	strd	r3, r3, [r0, #16]
	return 0;
   3e5c2:	2000      	movs	r0, #0
   3e5c4:	4770      	bx	lr
		return -EINVAL;
   3e5c6:	f06f 0015 	mvn.w	r0, #21
}
   3e5ca:	4770      	bx	lr

0003e5cc <k_is_in_isr>:
   3e5cc:	f3ef 8005 	mrs	r0, IPSR
}
   3e5d0:	3000      	adds	r0, #0
   3e5d2:	bf18      	it	ne
   3e5d4:	2001      	movne	r0, #1
   3e5d6:	4770      	bx	lr

0003e5d8 <z_impl_k_busy_wait>:
	arch_busy_wait(usec_to_wait);
   3e5d8:	f7e8 b9ce 	b.w	26978 <arch_busy_wait>

0003e5dc <z_impl_k_thread_name_set>:
}
   3e5dc:	f06f 0057 	mvn.w	r0, #87	; 0x57
   3e5e0:	4770      	bx	lr

0003e5e2 <k_thread_name_get>:
}
   3e5e2:	2000      	movs	r0, #0
   3e5e4:	4770      	bx	lr

0003e5e6 <z_new_thread_init>:
{
   3e5e6:	b510      	push	{r4, lr}
	thread_base->user_options = (u8_t)options;
   3e5e8:	9c02      	ldr	r4, [sp, #8]
	thread_base->prio = priority;
   3e5ea:	7383      	strb	r3, [r0, #14]
	thread_base->user_options = (u8_t)options;
   3e5ec:	7304      	strb	r4, [r0, #12]
	thread_base->sched_locked = 0U;
   3e5ee:	2300      	movs	r3, #0
	thread_base->thread_state = (u8_t)initial_state;
   3e5f0:	2404      	movs	r4, #4
	thread_base->sched_locked = 0U;
   3e5f2:	73c3      	strb	r3, [r0, #15]
	thread_base->thread_state = (u8_t)initial_state;
   3e5f4:	7344      	strb	r4, [r0, #13]
	node->prev = NULL;
   3e5f6:	e9c0 3306 	strd	r3, r3, [r0, #24]
	thread->fn_abort = NULL;
   3e5fa:	e9c0 3313 	strd	r3, r3, [r0, #76]	; 0x4c
	thread->stack_info.size = (u32_t)stackSize;
   3e5fe:	e9c0 1216 	strd	r1, r2, [r0, #88]	; 0x58
}
   3e602:	bd10      	pop	{r4, pc}

0003e604 <k_work_submit_to_queue>:
{
   3e604:	b500      	push	{lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   3e606:	f101 0308 	add.w	r3, r1, #8
   3e60a:	e8d3 2fef 	ldaex	r2, [r3]
   3e60e:	f042 0c01 	orr.w	ip, r2, #1
   3e612:	e8c3 cfee 	stlex	lr, ip, [r3]
   3e616:	f1be 0f00 	cmp.w	lr, #0
   3e61a:	d1f6      	bne.n	3e60a <k_work_submit_to_queue+0x6>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   3e61c:	07d3      	lsls	r3, r2, #31
   3e61e:	d403      	bmi.n	3e628 <k_work_submit_to_queue+0x24>
}
   3e620:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
   3e624:	f7ff bf79 	b.w	3e51a <k_queue_append>
}
   3e628:	f85d fb04 	ldr.w	pc, [sp], #4

0003e62c <work_timeout>:
	k_work_submit_to_queue(w->work_q, &w->work);
   3e62c:	f1a0 010c 	sub.w	r1, r0, #12
   3e630:	6900      	ldr	r0, [r0, #16]
   3e632:	f7ff bfe7 	b.w	3e604 <k_work_submit_to_queue>

0003e636 <work_cancel>:
	CHECKIF(work->work_q == NULL) {
   3e636:	69c3      	ldr	r3, [r0, #28]
{
   3e638:	b570      	push	{r4, r5, r6, lr}
   3e63a:	4604      	mov	r4, r0
	CHECKIF(work->work_q == NULL) {
   3e63c:	2b00      	cmp	r3, #0
   3e63e:	d039      	beq.n	3e6b4 <work_cancel+0x7e>
	return atomic_test_bit(work->flags, K_WORK_STATE_PENDING);
   3e640:	f100 0508 	add.w	r5, r0, #8
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   3e644:	e8d5 3faf 	lda	r3, [r5]
	if (k_work_pending(&work->work)) {
   3e648:	07db      	lsls	r3, r3, #31
   3e64a:	d52f      	bpl.n	3e6ac <work_cancel+0x76>
 * @return true if node was removed
 */
static inline bool sys_sflist_find_and_remove(sys_sflist_t *list,
					      sys_sfnode_t *node);

Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   3e64c:	2100      	movs	r1, #0
		if (!k_queue_remove(&work->work_q->queue, &work->work)) {
   3e64e:	69c2      	ldr	r2, [r0, #28]
   3e650:	6813      	ldr	r3, [r2, #0]
   3e652:	b913      	cbnz	r3, 3e65a <work_cancel+0x24>
			return -EINVAL;
   3e654:	f06f 0015 	mvn.w	r0, #21
}
   3e658:	bd70      	pop	{r4, r5, r6, pc}
   3e65a:	429c      	cmp	r4, r3
   3e65c:	d121      	bne.n	3e6a2 <work_cancel+0x6c>
Z_GENLIST_REMOVE(sflist, sfnode)
   3e65e:	6823      	ldr	r3, [r4, #0]
   3e660:	6856      	ldr	r6, [r2, #4]
   3e662:	f023 0003 	bic.w	r0, r3, #3
   3e666:	b991      	cbnz	r1, 3e68e <work_cancel+0x58>
   3e668:	42b4      	cmp	r4, r6
	list->head = node;
   3e66a:	6010      	str	r0, [r2, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
   3e66c:	d100      	bne.n	3e670 <work_cancel+0x3a>
	list->tail = node;
   3e66e:	6050      	str	r0, [r2, #4]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   3e670:	6823      	ldr	r3, [r4, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   3e672:	f003 0303 	and.w	r3, r3, #3
   3e676:	6023      	str	r3, [r4, #0]
	work->work_q = NULL;
   3e678:	2000      	movs	r0, #0
   3e67a:	61e0      	str	r0, [r4, #28]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   3e67c:	e8d5 3fef 	ldaex	r3, [r5]
   3e680:	f023 0301 	bic.w	r3, r3, #1
   3e684:	e8c5 3fe2 	stlex	r2, r3, [r5]
   3e688:	2a00      	cmp	r2, #0
   3e68a:	d0e5      	beq.n	3e658 <work_cancel+0x22>
   3e68c:	e7f6      	b.n	3e67c <work_cancel+0x46>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   3e68e:	680b      	ldr	r3, [r1, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
   3e690:	42b4      	cmp	r4, r6
	parent->next_and_flags = cur_flags | (unative_t)child;
   3e692:	f003 0303 	and.w	r3, r3, #3
   3e696:	ea43 0300 	orr.w	r3, r3, r0
   3e69a:	600b      	str	r3, [r1, #0]
	list->tail = node;
   3e69c:	bf08      	it	eq
   3e69e:	6051      	streq	r1, [r2, #4]
   3e6a0:	e7e6      	b.n	3e670 <work_cancel+0x3a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   3e6a2:	6818      	ldr	r0, [r3, #0]
Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   3e6a4:	4619      	mov	r1, r3
   3e6a6:	f020 0303 	bic.w	r3, r0, #3
   3e6aa:	e7d2      	b.n	3e652 <work_cancel+0x1c>
		(void)z_abort_timeout(&work->timeout);
   3e6ac:	300c      	adds	r0, #12
   3e6ae:	f7f9 fd87 	bl	381c0 <z_abort_timeout>
   3e6b2:	e7e1      	b.n	3e678 <work_cancel+0x42>
		return -EAGAIN;
   3e6b4:	f06f 000a 	mvn.w	r0, #10
   3e6b8:	e7ce      	b.n	3e658 <work_cancel+0x22>

0003e6ba <k_delayed_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   3e6ba:	2300      	movs	r3, #0
   3e6bc:	e9c0 3100 	strd	r3, r1, [r0]
	node->next = NULL;
   3e6c0:	e9c0 3302 	strd	r3, r3, [r0, #8]
	node->prev = NULL;
   3e6c4:	6103      	str	r3, [r0, #16]
	work->work_q = NULL;
   3e6c6:	61c3      	str	r3, [r0, #28]
}
   3e6c8:	4770      	bx	lr

0003e6ca <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
   3e6ca:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
   3e6cc:	f7f9 ff70 	bl	385b0 <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
   3e6d0:	bd08      	pop	{r3, pc}

0003e6d2 <z_impl_k_uptime_get>:

s64_t z_impl_k_uptime_get(void)
{
   3e6d2:	b510      	push	{r4, lr}
	return k_ticks_to_ms_floor64(z_tick_get());
   3e6d4:	f7f9 ff6c 	bl	385b0 <z_tick_get>
			return (t * to_hz + off) / from_hz;
   3e6d8:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   3e6dc:	fba0 2304 	umull	r2, r3, r0, r4
   3e6e0:	fb04 3301 	mla	r3, r4, r1, r3
   3e6e4:	0bd0      	lsrs	r0, r2, #15
}
   3e6e6:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   3e6ea:	0bd9      	lsrs	r1, r3, #15
   3e6ec:	bd10      	pop	{r4, pc}

0003e6ee <k_timer_init>:
	timer->status = 0U;
   3e6ee:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   3e6f0:	e9c0 1206 	strd	r1, r2, [r0, #24]
   3e6f4:	f100 0210 	add.w	r2, r0, #16
	timer->status = 0U;
   3e6f8:	6243      	str	r3, [r0, #36]	; 0x24
	list->tail = (sys_dnode_t *)list;
   3e6fa:	e9c0 2204 	strd	r2, r2, [r0, #16]
	node->prev = NULL;
   3e6fe:	e9c0 3300 	strd	r3, r3, [r0]
	timer->user_data = NULL;
   3e702:	6283      	str	r3, [r0, #40]	; 0x28
}
   3e704:	4770      	bx	lr

0003e706 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   3e706:	b510      	push	{r4, lr}
   3e708:	4604      	mov	r4, r0
	int inactive = z_abort_timeout(&timer->timeout) != 0;
   3e70a:	f7f9 fd59 	bl	381c0 <z_abort_timeout>

	if (inactive) {
   3e70e:	bb00      	cbnz	r0, 3e752 <z_impl_k_timer_stop+0x4c>
		return;
	}

	if (timer->stop_fn != NULL) {
   3e710:	69e3      	ldr	r3, [r4, #28]
   3e712:	b10b      	cbz	r3, 3e718 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   3e714:	4620      	mov	r0, r4
   3e716:	4798      	blx	r3
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
   3e718:	f104 0010 	add.w	r0, r4, #16
   3e71c:	2100      	movs	r1, #0
   3e71e:	f7f7 fff5 	bl	3670c <z_find_first_thread_to_unpend>
	if (thread != NULL) {
   3e722:	4604      	mov	r4, r0
   3e724:	b1a8      	cbz	r0, 3e752 <z_impl_k_timer_stop+0x4c>
		z_unpend_thread_no_timeout(thread);
   3e726:	f7f8 f83b 	bl	367a0 <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   3e72a:	7b63      	ldrb	r3, [r4, #13]
   3e72c:	06db      	lsls	r3, r3, #27
   3e72e:	d104      	bne.n	3e73a <z_impl_k_timer_stop+0x34>
	if (z_is_thread_ready(thread)) {
   3e730:	69a3      	ldr	r3, [r4, #24]
   3e732:	b913      	cbnz	r3, 3e73a <z_impl_k_timer_stop+0x34>
		z_add_thread_to_ready_q(thread);
   3e734:	4620      	mov	r0, r4
   3e736:	f7f8 fa6f 	bl	36c18 <z_add_thread_to_ready_q>
   3e73a:	f04f 0320 	mov.w	r3, #32
   3e73e:	f3ef 8011 	mrs	r0, BASEPRI
   3e742:	f383 8811 	msr	BASEPRI, r3
   3e746:	f3bf 8f6f 	isb	sy

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
		z_reschedule_unlocked();
	}
}
   3e74a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   3e74e:	f7ff befb 	b.w	3e548 <z_reschedule_irqlock>
   3e752:	bd10      	pop	{r4, pc}

0003e754 <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, u32_t state)
{
   3e754:	b570      	push	{r4, r5, r6, lr}
	struct _poller *poller = event->poller;
   3e756:	6884      	ldr	r4, [r0, #8]
{
   3e758:	4605      	mov	r5, r0
   3e75a:	460e      	mov	r6, r1
	int retcode = 0;

	if (poller) {
   3e75c:	b19c      	cbz	r4, 3e786 <signal_poll_event+0x32>
		if (poller->cb != NULL) {
   3e75e:	68a3      	ldr	r3, [r4, #8]
   3e760:	b95b      	cbnz	r3, 3e77a <signal_poll_event+0x26>
	int retcode = 0;
   3e762:	4618      	mov	r0, r3
			retcode = poller->cb(event, state);
		}

		poller->is_polling = false;
   3e764:	7023      	strb	r3, [r4, #0]
	event->poller = NULL;
   3e766:	2300      	movs	r3, #0
   3e768:	60ab      	str	r3, [r5, #8]
	event->state |= state;
   3e76a:	68eb      	ldr	r3, [r5, #12]
   3e76c:	f3c3 3204 	ubfx	r2, r3, #12, #5
   3e770:	4316      	orrs	r6, r2
   3e772:	f366 3310 	bfi	r3, r6, #12, #5
   3e776:	60eb      	str	r3, [r5, #12]
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
   3e778:	e004      	b.n	3e784 <signal_poll_event+0x30>
			retcode = poller->cb(event, state);
   3e77a:	4798      	blx	r3
		poller->is_polling = false;
   3e77c:	2300      	movs	r3, #0
		if (retcode < 0) {
   3e77e:	2800      	cmp	r0, #0
		poller->is_polling = false;
   3e780:	7023      	strb	r3, [r4, #0]
		if (retcode < 0) {
   3e782:	daf0      	bge.n	3e766 <signal_poll_event+0x12>
}
   3e784:	bd70      	pop	{r4, r5, r6, pc}
	int retcode = 0;
   3e786:	4620      	mov	r0, r4
   3e788:	e7ed      	b.n	3e766 <signal_poll_event+0x12>

0003e78a <add_event>:
{
   3e78a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3e78c:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   3e78e:	e9d0 2300 	ldrd	r2, r3, [r0]
   3e792:	4290      	cmp	r0, r2
   3e794:	4604      	mov	r4, r0
   3e796:	460d      	mov	r5, r1
   3e798:	d106      	bne.n	3e7a8 <add_event+0x1e>
	node->prev = list->tail;
   3e79a:	6863      	ldr	r3, [r4, #4]
	node->next = list;
   3e79c:	602c      	str	r4, [r5, #0]
	node->prev = list->tail;
   3e79e:	606b      	str	r3, [r5, #4]
	list->tail->next = node;
   3e7a0:	6863      	ldr	r3, [r4, #4]
   3e7a2:	601d      	str	r5, [r3, #0]
	list->tail = node;
   3e7a4:	6065      	str	r5, [r4, #4]
}
   3e7a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
   3e7a8:	2b00      	cmp	r3, #0
   3e7aa:	d0f6      	beq.n	3e79a <add_event+0x10>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
   3e7ac:	689b      	ldr	r3, [r3, #8]
   3e7ae:	6879      	ldr	r1, [r7, #4]
   3e7b0:	6858      	ldr	r0, [r3, #4]
   3e7b2:	f7ff fec0 	bl	3e536 <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
   3e7b6:	2800      	cmp	r0, #0
   3e7b8:	d1ef      	bne.n	3e79a <add_event+0x10>
	return list->head == list;
   3e7ba:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   3e7bc:	42b4      	cmp	r4, r6
   3e7be:	d0ec      	beq.n	3e79a <add_event+0x10>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   3e7c0:	2e00      	cmp	r6, #0
   3e7c2:	d0ea      	beq.n	3e79a <add_event+0x10>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
   3e7c4:	68b3      	ldr	r3, [r6, #8]
   3e7c6:	6878      	ldr	r0, [r7, #4]
   3e7c8:	6859      	ldr	r1, [r3, #4]
   3e7ca:	f7ff feb4 	bl	3e536 <z_is_t1_higher_prio_than_t2>
   3e7ce:	b128      	cbz	r0, 3e7dc <add_event+0x52>
	node->prev = successor->prev;
   3e7d0:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   3e7d2:	e9c5 6300 	strd	r6, r3, [r5]
	successor->prev->next = node;
   3e7d6:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   3e7d8:	6075      	str	r5, [r6, #4]
			return;
   3e7da:	e7e4      	b.n	3e7a6 <add_event+0x1c>
	return (node == list->tail) ? NULL : node->next;
   3e7dc:	6863      	ldr	r3, [r4, #4]
   3e7de:	429e      	cmp	r6, r3
   3e7e0:	d0db      	beq.n	3e79a <add_event+0x10>
   3e7e2:	6836      	ldr	r6, [r6, #0]
   3e7e4:	e7ec      	b.n	3e7c0 <add_event+0x36>

0003e7e6 <z_handle_obj_poll_events>:
	return list->head == list;
   3e7e6:	6803      	ldr	r3, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
   3e7e8:	4298      	cmp	r0, r3
   3e7ea:	d009      	beq.n	3e800 <z_handle_obj_poll_events+0x1a>
	node->prev->next = node->next;
   3e7ec:	e9d3 2000 	ldrd	r2, r0, [r3]
   3e7f0:	6002      	str	r2, [r0, #0]
	node->next->prev = node->prev;
   3e7f2:	6050      	str	r0, [r2, #4]
	node->next = NULL;
   3e7f4:	2200      	movs	r2, #0
{
	struct k_poll_event *poll_event;

	poll_event = (struct k_poll_event *)sys_dlist_get(events);
	if (poll_event != NULL) {
		(void) signal_poll_event(poll_event, state);
   3e7f6:	4618      	mov	r0, r3
	node->prev = NULL;
   3e7f8:	e9c3 2200 	strd	r2, r2, [r3]
   3e7fc:	f7ff bfaa 	b.w	3e754 <signal_poll_event>
	}
}
   3e800:	4770      	bx	lr

0003e802 <_OffsetAbsSyms>:
					    sizeof(struct _preempt_float));
#else
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF, sizeof(struct k_thread));
#endif

GEN_ABS_SYM_END
   3e802:	4770      	bx	lr

0003e804 <abs>:
   3e804:	2800      	cmp	r0, #0
   3e806:	bfb8      	it	lt
   3e808:	4240      	neglt	r0, r0
   3e80a:	4770      	bx	lr

0003e80c <atoi>:
   3e80c:	220a      	movs	r2, #10
   3e80e:	2100      	movs	r1, #0
   3e810:	f7fb ba20 	b.w	39c54 <strtol>

0003e814 <memchr>:
   3e814:	b2c9      	uxtb	r1, r1
   3e816:	4402      	add	r2, r0
   3e818:	b510      	push	{r4, lr}
   3e81a:	4290      	cmp	r0, r2
   3e81c:	4603      	mov	r3, r0
   3e81e:	d101      	bne.n	3e824 <memchr+0x10>
   3e820:	2300      	movs	r3, #0
   3e822:	e003      	b.n	3e82c <memchr+0x18>
   3e824:	781c      	ldrb	r4, [r3, #0]
   3e826:	3001      	adds	r0, #1
   3e828:	428c      	cmp	r4, r1
   3e82a:	d1f6      	bne.n	3e81a <memchr+0x6>
   3e82c:	4618      	mov	r0, r3
   3e82e:	bd10      	pop	{r4, pc}

0003e830 <memcmp>:
   3e830:	b530      	push	{r4, r5, lr}
   3e832:	3901      	subs	r1, #1
   3e834:	2400      	movs	r4, #0
   3e836:	42a2      	cmp	r2, r4
   3e838:	d101      	bne.n	3e83e <memcmp+0xe>
   3e83a:	2000      	movs	r0, #0
   3e83c:	e005      	b.n	3e84a <memcmp+0x1a>
   3e83e:	5d03      	ldrb	r3, [r0, r4]
   3e840:	3401      	adds	r4, #1
   3e842:	5d0d      	ldrb	r5, [r1, r4]
   3e844:	42ab      	cmp	r3, r5
   3e846:	d0f6      	beq.n	3e836 <memcmp+0x6>
   3e848:	1b58      	subs	r0, r3, r5
   3e84a:	bd30      	pop	{r4, r5, pc}

0003e84c <memcpy>:
   3e84c:	440a      	add	r2, r1
   3e84e:	1e43      	subs	r3, r0, #1
   3e850:	4291      	cmp	r1, r2
   3e852:	d100      	bne.n	3e856 <memcpy+0xa>
   3e854:	4770      	bx	lr
   3e856:	b510      	push	{r4, lr}
   3e858:	f811 4b01 	ldrb.w	r4, [r1], #1
   3e85c:	4291      	cmp	r1, r2
   3e85e:	f803 4f01 	strb.w	r4, [r3, #1]!
   3e862:	d1f9      	bne.n	3e858 <memcpy+0xc>
   3e864:	bd10      	pop	{r4, pc}

0003e866 <__memcpy_chk>:
   3e866:	429a      	cmp	r2, r3
   3e868:	b508      	push	{r3, lr}
   3e86a:	d901      	bls.n	3e870 <__memcpy_chk+0xa>
   3e86c:	f7fb fb68 	bl	39f40 <__chk_fail>
   3e870:	4281      	cmp	r1, r0
   3e872:	d804      	bhi.n	3e87e <__memcpy_chk+0x18>
   3e874:	188b      	adds	r3, r1, r2
   3e876:	4298      	cmp	r0, r3
   3e878:	d3f8      	bcc.n	3e86c <__memcpy_chk+0x6>
   3e87a:	4281      	cmp	r1, r0
   3e87c:	d102      	bne.n	3e884 <__memcpy_chk+0x1e>
   3e87e:	1883      	adds	r3, r0, r2
   3e880:	4299      	cmp	r1, r3
   3e882:	d3f3      	bcc.n	3e86c <__memcpy_chk+0x6>
   3e884:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   3e888:	f7ff bfe0 	b.w	3e84c <memcpy>

0003e88c <memset>:
   3e88c:	4402      	add	r2, r0
   3e88e:	4603      	mov	r3, r0
   3e890:	4293      	cmp	r3, r2
   3e892:	d100      	bne.n	3e896 <memset+0xa>
   3e894:	4770      	bx	lr
   3e896:	f803 1b01 	strb.w	r1, [r3], #1
   3e89a:	e7f9      	b.n	3e890 <memset+0x4>

0003e89c <__memset_chk>:
   3e89c:	429a      	cmp	r2, r3
   3e89e:	b508      	push	{r3, lr}
   3e8a0:	d901      	bls.n	3e8a6 <__memset_chk+0xa>
   3e8a2:	f7fb fb4d 	bl	39f40 <__chk_fail>
   3e8a6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   3e8aa:	f7ff bfef 	b.w	3e88c <memset>

0003e8ae <__sfputc_r>:
   3e8ae:	6893      	ldr	r3, [r2, #8]
   3e8b0:	3b01      	subs	r3, #1
   3e8b2:	2b00      	cmp	r3, #0
   3e8b4:	6093      	str	r3, [r2, #8]
   3e8b6:	b410      	push	{r4}
   3e8b8:	da08      	bge.n	3e8cc <__sfputc_r+0x1e>
   3e8ba:	6994      	ldr	r4, [r2, #24]
   3e8bc:	42a3      	cmp	r3, r4
   3e8be:	db01      	blt.n	3e8c4 <__sfputc_r+0x16>
   3e8c0:	290a      	cmp	r1, #10
   3e8c2:	d103      	bne.n	3e8cc <__sfputc_r+0x1e>
   3e8c4:	f85d 4b04 	ldr.w	r4, [sp], #4
   3e8c8:	f7fb ba7a 	b.w	39dc0 <__swbuf_r>
   3e8cc:	6813      	ldr	r3, [r2, #0]
   3e8ce:	1c58      	adds	r0, r3, #1
   3e8d0:	6010      	str	r0, [r2, #0]
   3e8d2:	4608      	mov	r0, r1
   3e8d4:	7019      	strb	r1, [r3, #0]
   3e8d6:	f85d 4b04 	ldr.w	r4, [sp], #4
   3e8da:	4770      	bx	lr

0003e8dc <__sfputs_r>:
   3e8dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3e8de:	4606      	mov	r6, r0
   3e8e0:	460f      	mov	r7, r1
   3e8e2:	4614      	mov	r4, r2
   3e8e4:	18d5      	adds	r5, r2, r3
   3e8e6:	42ac      	cmp	r4, r5
   3e8e8:	d101      	bne.n	3e8ee <__sfputs_r+0x12>
   3e8ea:	2000      	movs	r0, #0
   3e8ec:	e007      	b.n	3e8fe <__sfputs_r+0x22>
   3e8ee:	463a      	mov	r2, r7
   3e8f0:	f814 1b01 	ldrb.w	r1, [r4], #1
   3e8f4:	4630      	mov	r0, r6
   3e8f6:	f7ff ffda 	bl	3e8ae <__sfputc_r>
   3e8fa:	1c43      	adds	r3, r0, #1
   3e8fc:	d1f3      	bne.n	3e8e6 <__sfputs_r+0xa>
   3e8fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0003e900 <__cvt>:
   3e900:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   3e904:	ec55 4b10 	vmov	r4, r5, d0
   3e908:	2d00      	cmp	r5, #0
   3e90a:	460e      	mov	r6, r1
   3e90c:	4691      	mov	r9, r2
   3e90e:	4619      	mov	r1, r3
   3e910:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   3e914:	f04f 0200 	mov.w	r2, #0
   3e918:	da03      	bge.n	3e922 <__cvt+0x22>
   3e91a:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
   3e91e:	222d      	movs	r2, #45	; 0x2d
   3e920:	461d      	mov	r5, r3
   3e922:	9f0d      	ldr	r7, [sp, #52]	; 0x34
   3e924:	700a      	strb	r2, [r1, #0]
   3e926:	f027 0720 	bic.w	r7, r7, #32
   3e92a:	2f46      	cmp	r7, #70	; 0x46
   3e92c:	d004      	beq.n	3e938 <__cvt+0x38>
   3e92e:	2f45      	cmp	r7, #69	; 0x45
   3e930:	d100      	bne.n	3e934 <__cvt+0x34>
   3e932:	3601      	adds	r6, #1
   3e934:	2102      	movs	r1, #2
   3e936:	e000      	b.n	3e93a <__cvt+0x3a>
   3e938:	2103      	movs	r1, #3
   3e93a:	ab03      	add	r3, sp, #12
   3e93c:	4632      	mov	r2, r6
   3e93e:	9301      	str	r3, [sp, #4]
   3e940:	ab02      	add	r3, sp, #8
   3e942:	ec45 4b10 	vmov	d0, r4, r5
   3e946:	9300      	str	r3, [sp, #0]
   3e948:	4653      	mov	r3, sl
   3e94a:	f7e0 fec9 	bl	1f6e0 <_dtoa_r>
   3e94e:	2f47      	cmp	r7, #71	; 0x47
   3e950:	4680      	mov	r8, r0
   3e952:	d102      	bne.n	3e95a <__cvt+0x5a>
   3e954:	f019 0f01 	tst.w	r9, #1
   3e958:	d022      	beq.n	3e9a0 <__cvt+0xa0>
   3e95a:	2f46      	cmp	r7, #70	; 0x46
   3e95c:	eb08 0906 	add.w	r9, r8, r6
   3e960:	d111      	bne.n	3e986 <__cvt+0x86>
   3e962:	f898 3000 	ldrb.w	r3, [r8]
   3e966:	2b30      	cmp	r3, #48	; 0x30
   3e968:	d10a      	bne.n	3e980 <__cvt+0x80>
   3e96a:	2200      	movs	r2, #0
   3e96c:	2300      	movs	r3, #0
   3e96e:	4620      	mov	r0, r4
   3e970:	4629      	mov	r1, r5
   3e972:	f7de f989 	bl	1cc88 <__aeabi_dcmpeq>
   3e976:	b918      	cbnz	r0, 3e980 <__cvt+0x80>
   3e978:	f1c6 0601 	rsb	r6, r6, #1
   3e97c:	f8ca 6000 	str.w	r6, [sl]
   3e980:	f8da 3000 	ldr.w	r3, [sl]
   3e984:	4499      	add	r9, r3
   3e986:	2200      	movs	r2, #0
   3e988:	2300      	movs	r3, #0
   3e98a:	4620      	mov	r0, r4
   3e98c:	4629      	mov	r1, r5
   3e98e:	f7de f97b 	bl	1cc88 <__aeabi_dcmpeq>
   3e992:	b108      	cbz	r0, 3e998 <__cvt+0x98>
   3e994:	f8cd 900c 	str.w	r9, [sp, #12]
   3e998:	2230      	movs	r2, #48	; 0x30
   3e99a:	9b03      	ldr	r3, [sp, #12]
   3e99c:	454b      	cmp	r3, r9
   3e99e:	d308      	bcc.n	3e9b2 <__cvt+0xb2>
   3e9a0:	9b03      	ldr	r3, [sp, #12]
   3e9a2:	4640      	mov	r0, r8
   3e9a4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   3e9a6:	eba3 0308 	sub.w	r3, r3, r8
   3e9aa:	6013      	str	r3, [r2, #0]
   3e9ac:	b004      	add	sp, #16
   3e9ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3e9b2:	1c59      	adds	r1, r3, #1
   3e9b4:	9103      	str	r1, [sp, #12]
   3e9b6:	701a      	strb	r2, [r3, #0]
   3e9b8:	e7ef      	b.n	3e99a <__cvt+0x9a>

0003e9ba <__exponent>:
   3e9ba:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   3e9bc:	2900      	cmp	r1, #0
   3e9be:	7002      	strb	r2, [r0, #0]
   3e9c0:	bfba      	itte	lt
   3e9c2:	4249      	neglt	r1, r1
   3e9c4:	232d      	movlt	r3, #45	; 0x2d
   3e9c6:	232b      	movge	r3, #43	; 0x2b
   3e9c8:	2909      	cmp	r1, #9
   3e9ca:	7043      	strb	r3, [r0, #1]
   3e9cc:	dd22      	ble.n	3ea14 <__exponent+0x5a>
   3e9ce:	f10d 0307 	add.w	r3, sp, #7
   3e9d2:	260a      	movs	r6, #10
   3e9d4:	461f      	mov	r7, r3
   3e9d6:	2963      	cmp	r1, #99	; 0x63
   3e9d8:	f103 35ff 	add.w	r5, r3, #4294967295
   3e9dc:	fb91 f2f6 	sdiv	r2, r1, r6
   3e9e0:	fb06 1412 	mls	r4, r6, r2, r1
   3e9e4:	f104 0430 	add.w	r4, r4, #48	; 0x30
   3e9e8:	f803 4c01 	strb.w	r4, [r3, #-1]
   3e9ec:	dc0a      	bgt.n	3ea04 <__exponent+0x4a>
   3e9ee:	3230      	adds	r2, #48	; 0x30
   3e9f0:	3b02      	subs	r3, #2
   3e9f2:	f805 2c01 	strb.w	r2, [r5, #-1]
   3e9f6:	1c82      	adds	r2, r0, #2
   3e9f8:	42bb      	cmp	r3, r7
   3e9fa:	4614      	mov	r4, r2
   3e9fc:	d305      	bcc.n	3ea0a <__exponent+0x50>
   3e9fe:	1a20      	subs	r0, r4, r0
   3ea00:	b003      	add	sp, #12
   3ea02:	bdf0      	pop	{r4, r5, r6, r7, pc}
   3ea04:	462b      	mov	r3, r5
   3ea06:	4611      	mov	r1, r2
   3ea08:	e7e5      	b.n	3e9d6 <__exponent+0x1c>
   3ea0a:	f813 1b01 	ldrb.w	r1, [r3], #1
   3ea0e:	f802 1b01 	strb.w	r1, [r2], #1
   3ea12:	e7f1      	b.n	3e9f8 <__exponent+0x3e>
   3ea14:	2330      	movs	r3, #48	; 0x30
   3ea16:	1d04      	adds	r4, r0, #4
   3ea18:	4419      	add	r1, r3
   3ea1a:	7083      	strb	r3, [r0, #2]
   3ea1c:	70c1      	strb	r1, [r0, #3]
   3ea1e:	e7ee      	b.n	3e9fe <__exponent+0x44>

0003ea20 <_printf_common>:
   3ea20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   3ea24:	4691      	mov	r9, r2
   3ea26:	461f      	mov	r7, r3
   3ea28:	688a      	ldr	r2, [r1, #8]
   3ea2a:	4606      	mov	r6, r0
   3ea2c:	690b      	ldr	r3, [r1, #16]
   3ea2e:	460c      	mov	r4, r1
   3ea30:	f8dd 8020 	ldr.w	r8, [sp, #32]
   3ea34:	4293      	cmp	r3, r2
   3ea36:	bfb8      	it	lt
   3ea38:	4613      	movlt	r3, r2
   3ea3a:	f8c9 3000 	str.w	r3, [r9]
   3ea3e:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
   3ea42:	b112      	cbz	r2, 3ea4a <_printf_common+0x2a>
   3ea44:	3301      	adds	r3, #1
   3ea46:	f8c9 3000 	str.w	r3, [r9]
   3ea4a:	6823      	ldr	r3, [r4, #0]
   3ea4c:	0699      	lsls	r1, r3, #26
   3ea4e:	bf42      	ittt	mi
   3ea50:	f8d9 3000 	ldrmi.w	r3, [r9]
   3ea54:	3302      	addmi	r3, #2
   3ea56:	f8c9 3000 	strmi.w	r3, [r9]
   3ea5a:	6825      	ldr	r5, [r4, #0]
   3ea5c:	f015 0506 	ands.w	r5, r5, #6
   3ea60:	d107      	bne.n	3ea72 <_printf_common+0x52>
   3ea62:	f104 0a19 	add.w	sl, r4, #25
   3ea66:	68e3      	ldr	r3, [r4, #12]
   3ea68:	f8d9 2000 	ldr.w	r2, [r9]
   3ea6c:	1a9b      	subs	r3, r3, r2
   3ea6e:	42ab      	cmp	r3, r5
   3ea70:	dc2b      	bgt.n	3eaca <_printf_common+0xaa>
   3ea72:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   3ea76:	6822      	ldr	r2, [r4, #0]
   3ea78:	3300      	adds	r3, #0
   3ea7a:	bf18      	it	ne
   3ea7c:	2301      	movne	r3, #1
   3ea7e:	0692      	lsls	r2, r2, #26
   3ea80:	d430      	bmi.n	3eae4 <_printf_common+0xc4>
   3ea82:	f104 0243 	add.w	r2, r4, #67	; 0x43
   3ea86:	4639      	mov	r1, r7
   3ea88:	4630      	mov	r0, r6
   3ea8a:	47c0      	blx	r8
   3ea8c:	3001      	adds	r0, #1
   3ea8e:	d023      	beq.n	3ead8 <_printf_common+0xb8>
   3ea90:	6823      	ldr	r3, [r4, #0]
   3ea92:	341a      	adds	r4, #26
   3ea94:	f854 5c0e 	ldr.w	r5, [r4, #-14]
   3ea98:	f003 0306 	and.w	r3, r3, #6
   3ea9c:	f8d9 2000 	ldr.w	r2, [r9]
   3eaa0:	f04f 0900 	mov.w	r9, #0
   3eaa4:	2b04      	cmp	r3, #4
   3eaa6:	f854 3c12 	ldr.w	r3, [r4, #-18]
   3eaaa:	bf08      	it	eq
   3eaac:	1aad      	subeq	r5, r5, r2
   3eaae:	f854 2c0a 	ldr.w	r2, [r4, #-10]
   3eab2:	bf14      	ite	ne
   3eab4:	2500      	movne	r5, #0
   3eab6:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
   3eaba:	4293      	cmp	r3, r2
   3eabc:	bfc4      	itt	gt
   3eabe:	1a9b      	subgt	r3, r3, r2
   3eac0:	18ed      	addgt	r5, r5, r3
   3eac2:	454d      	cmp	r5, r9
   3eac4:	d11a      	bne.n	3eafc <_printf_common+0xdc>
   3eac6:	2000      	movs	r0, #0
   3eac8:	e008      	b.n	3eadc <_printf_common+0xbc>
   3eaca:	2301      	movs	r3, #1
   3eacc:	4652      	mov	r2, sl
   3eace:	4639      	mov	r1, r7
   3ead0:	4630      	mov	r0, r6
   3ead2:	47c0      	blx	r8
   3ead4:	3001      	adds	r0, #1
   3ead6:	d103      	bne.n	3eae0 <_printf_common+0xc0>
   3ead8:	f04f 30ff 	mov.w	r0, #4294967295
   3eadc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3eae0:	3501      	adds	r5, #1
   3eae2:	e7c0      	b.n	3ea66 <_printf_common+0x46>
   3eae4:	18e1      	adds	r1, r4, r3
   3eae6:	1c5a      	adds	r2, r3, #1
   3eae8:	2030      	movs	r0, #48	; 0x30
   3eaea:	3302      	adds	r3, #2
   3eaec:	4422      	add	r2, r4
   3eaee:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
   3eaf2:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
   3eaf6:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
   3eafa:	e7c2      	b.n	3ea82 <_printf_common+0x62>
   3eafc:	2301      	movs	r3, #1
   3eafe:	4622      	mov	r2, r4
   3eb00:	4639      	mov	r1, r7
   3eb02:	4630      	mov	r0, r6
   3eb04:	47c0      	blx	r8
   3eb06:	3001      	adds	r0, #1
   3eb08:	d0e6      	beq.n	3ead8 <_printf_common+0xb8>
   3eb0a:	f109 0901 	add.w	r9, r9, #1
   3eb0e:	e7d8      	b.n	3eac2 <_printf_common+0xa2>

0003eb10 <__sprintf_chk>:
   3eb10:	b408      	push	{r3}
   3eb12:	b517      	push	{r0, r1, r2, r4, lr}
   3eb14:	ab05      	add	r3, sp, #20
   3eb16:	1e14      	subs	r4, r2, #0
   3eb18:	f853 1b04 	ldr.w	r1, [r3], #4
   3eb1c:	9301      	str	r3, [sp, #4]
   3eb1e:	da07      	bge.n	3eb30 <__sprintf_chk+0x20>
   3eb20:	461a      	mov	r2, r3
   3eb22:	f7fb f943 	bl	39dac <vsiprintf>
   3eb26:	b003      	add	sp, #12
   3eb28:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   3eb2c:	b001      	add	sp, #4
   3eb2e:	4770      	bx	lr
   3eb30:	460a      	mov	r2, r1
   3eb32:	4621      	mov	r1, r4
   3eb34:	f7fb f916 	bl	39d64 <vsniprintf>
   3eb38:	2800      	cmp	r0, #0
   3eb3a:	dbf4      	blt.n	3eb26 <__sprintf_chk+0x16>
   3eb3c:	42a0      	cmp	r0, r4
   3eb3e:	d3f2      	bcc.n	3eb26 <__sprintf_chk+0x16>
   3eb40:	f7fb f9fe 	bl	39f40 <__chk_fail>

0003eb44 <strchr>:
   3eb44:	b2c9      	uxtb	r1, r1
   3eb46:	4603      	mov	r3, r0
   3eb48:	f810 2b01 	ldrb.w	r2, [r0], #1
   3eb4c:	b11a      	cbz	r2, 3eb56 <strchr+0x12>
   3eb4e:	428a      	cmp	r2, r1
   3eb50:	d1f9      	bne.n	3eb46 <strchr+0x2>
   3eb52:	4618      	mov	r0, r3
   3eb54:	4770      	bx	lr
   3eb56:	2900      	cmp	r1, #0
   3eb58:	bf18      	it	ne
   3eb5a:	2300      	movne	r3, #0
   3eb5c:	e7f9      	b.n	3eb52 <strchr+0xe>

0003eb5e <strcpy>:
   3eb5e:	4603      	mov	r3, r0
   3eb60:	f811 2b01 	ldrb.w	r2, [r1], #1
   3eb64:	f803 2b01 	strb.w	r2, [r3], #1
   3eb68:	2a00      	cmp	r2, #0
   3eb6a:	d1f9      	bne.n	3eb60 <strcpy+0x2>
   3eb6c:	4770      	bx	lr

0003eb6e <strncmp>:
   3eb6e:	b510      	push	{r4, lr}
   3eb70:	b16a      	cbz	r2, 3eb8e <strncmp+0x20>
   3eb72:	3901      	subs	r1, #1
   3eb74:	1884      	adds	r4, r0, r2
   3eb76:	f810 3b01 	ldrb.w	r3, [r0], #1
   3eb7a:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   3eb7e:	4293      	cmp	r3, r2
   3eb80:	d103      	bne.n	3eb8a <strncmp+0x1c>
   3eb82:	42a0      	cmp	r0, r4
   3eb84:	d001      	beq.n	3eb8a <strncmp+0x1c>
   3eb86:	2b00      	cmp	r3, #0
   3eb88:	d1f5      	bne.n	3eb76 <strncmp+0x8>
   3eb8a:	1a98      	subs	r0, r3, r2
   3eb8c:	bd10      	pop	{r4, pc}
   3eb8e:	4610      	mov	r0, r2
   3eb90:	e7fc      	b.n	3eb8c <strncmp+0x1e>

0003eb92 <strncpy>:
   3eb92:	3901      	subs	r1, #1
   3eb94:	4603      	mov	r3, r0
   3eb96:	b510      	push	{r4, lr}
   3eb98:	b132      	cbz	r2, 3eba8 <strncpy+0x16>
   3eb9a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   3eb9e:	3a01      	subs	r2, #1
   3eba0:	f803 4b01 	strb.w	r4, [r3], #1
   3eba4:	2c00      	cmp	r4, #0
   3eba6:	d1f7      	bne.n	3eb98 <strncpy+0x6>
   3eba8:	441a      	add	r2, r3
   3ebaa:	2100      	movs	r1, #0
   3ebac:	4293      	cmp	r3, r2
   3ebae:	d100      	bne.n	3ebb2 <strncpy+0x20>
   3ebb0:	bd10      	pop	{r4, pc}
   3ebb2:	f803 1b01 	strb.w	r1, [r3], #1
   3ebb6:	e7f9      	b.n	3ebac <strncpy+0x1a>

0003ebb8 <strstr>:
   3ebb8:	b5f0      	push	{r4, r5, r6, r7, lr}
   3ebba:	780c      	ldrb	r4, [r1, #0]
   3ebbc:	b164      	cbz	r4, 3ebd8 <strstr+0x20>
   3ebbe:	4603      	mov	r3, r0
   3ebc0:	781a      	ldrb	r2, [r3, #0]
   3ebc2:	4618      	mov	r0, r3
   3ebc4:	1c5e      	adds	r6, r3, #1
   3ebc6:	b90a      	cbnz	r2, 3ebcc <strstr+0x14>
   3ebc8:	4610      	mov	r0, r2
   3ebca:	e005      	b.n	3ebd8 <strstr+0x20>
   3ebcc:	4294      	cmp	r4, r2
   3ebce:	d108      	bne.n	3ebe2 <strstr+0x2a>
   3ebd0:	460d      	mov	r5, r1
   3ebd2:	f815 2f01 	ldrb.w	r2, [r5, #1]!
   3ebd6:	b902      	cbnz	r2, 3ebda <strstr+0x22>
   3ebd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   3ebda:	f813 7f01 	ldrb.w	r7, [r3, #1]!
   3ebde:	4297      	cmp	r7, r2
   3ebe0:	d0f7      	beq.n	3ebd2 <strstr+0x1a>
   3ebe2:	4633      	mov	r3, r6
   3ebe4:	e7ec      	b.n	3ebc0 <strstr+0x8>

0003ebe6 <_vsniprintf_r>:
   3ebe6:	b530      	push	{r4, r5, lr}
   3ebe8:	1e14      	subs	r4, r2, #0
   3ebea:	4605      	mov	r5, r0
   3ebec:	b09b      	sub	sp, #108	; 0x6c
   3ebee:	4618      	mov	r0, r3
   3ebf0:	da05      	bge.n	3ebfe <_vsniprintf_r+0x18>
   3ebf2:	238b      	movs	r3, #139	; 0x8b
   3ebf4:	f04f 30ff 	mov.w	r0, #4294967295
   3ebf8:	602b      	str	r3, [r5, #0]
   3ebfa:	b01b      	add	sp, #108	; 0x6c
   3ebfc:	bd30      	pop	{r4, r5, pc}
   3ebfe:	f44f 7302 	mov.w	r3, #520	; 0x208
   3ec02:	9100      	str	r1, [sp, #0]
   3ec04:	9104      	str	r1, [sp, #16]
   3ec06:	4602      	mov	r2, r0
   3ec08:	f8ad 300c 	strh.w	r3, [sp, #12]
   3ec0c:	bf14      	ite	ne
   3ec0e:	f104 33ff 	addne.w	r3, r4, #4294967295
   3ec12:	4623      	moveq	r3, r4
   3ec14:	4669      	mov	r1, sp
   3ec16:	4628      	mov	r0, r5
   3ec18:	9302      	str	r3, [sp, #8]
   3ec1a:	9305      	str	r3, [sp, #20]
   3ec1c:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3ec20:	f8ad 300e 	strh.w	r3, [sp, #14]
   3ec24:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   3ec26:	f7fb fc71 	bl	3a50c <_svfiprintf_r>
   3ec2a:	1c43      	adds	r3, r0, #1
   3ec2c:	bfbc      	itt	lt
   3ec2e:	238b      	movlt	r3, #139	; 0x8b
   3ec30:	602b      	strlt	r3, [r5, #0]
   3ec32:	2c00      	cmp	r4, #0
   3ec34:	d0e1      	beq.n	3ebfa <_vsniprintf_r+0x14>
   3ec36:	9b00      	ldr	r3, [sp, #0]
   3ec38:	2200      	movs	r2, #0
   3ec3a:	701a      	strb	r2, [r3, #0]
   3ec3c:	e7dd      	b.n	3ebfa <_vsniprintf_r+0x14>

0003ec3e <abort>:
   3ec3e:	b508      	push	{r3, lr}
   3ec40:	2006      	movs	r0, #6
   3ec42:	f7fb fd6b 	bl	3a71c <raise>
   3ec46:	2001      	movs	r0, #1
   3ec48:	f7ea f9da 	bl	29000 <_exit>

0003ec4c <quorem>:
   3ec4c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3ec50:	6903      	ldr	r3, [r0, #16]
   3ec52:	4680      	mov	r8, r0
   3ec54:	690c      	ldr	r4, [r1, #16]
   3ec56:	42a3      	cmp	r3, r4
   3ec58:	f2c0 8084 	blt.w	3ed64 <quorem+0x118>
   3ec5c:	3c01      	subs	r4, #1
   3ec5e:	f108 0514 	add.w	r5, r8, #20
   3ec62:	f101 0714 	add.w	r7, r1, #20
   3ec66:	00a0      	lsls	r0, r4, #2
   3ec68:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   3ec6c:	182b      	adds	r3, r5, r0
   3ec6e:	eb07 0900 	add.w	r9, r7, r0
   3ec72:	9301      	str	r3, [sp, #4]
   3ec74:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
   3ec78:	3301      	adds	r3, #1
   3ec7a:	429a      	cmp	r2, r3
   3ec7c:	fbb2 f6f3 	udiv	r6, r2, r3
   3ec80:	d333      	bcc.n	3ecea <quorem+0x9e>
   3ec82:	f04f 0a00 	mov.w	sl, #0
   3ec86:	46bc      	mov	ip, r7
   3ec88:	46ae      	mov	lr, r5
   3ec8a:	46d3      	mov	fp, sl
   3ec8c:	f85c 2b04 	ldr.w	r2, [ip], #4
   3ec90:	b293      	uxth	r3, r2
   3ec92:	45e1      	cmp	r9, ip
   3ec94:	ea4f 4212 	mov.w	r2, r2, lsr #16
   3ec98:	fb06 a303 	mla	r3, r6, r3, sl
   3ec9c:	ea4f 4a13 	mov.w	sl, r3, lsr #16
   3eca0:	b29b      	uxth	r3, r3
   3eca2:	fb06 a202 	mla	r2, r6, r2, sl
   3eca6:	ebab 0303 	sub.w	r3, fp, r3
   3ecaa:	f8de b000 	ldr.w	fp, [lr]
   3ecae:	ea4f 4a12 	mov.w	sl, r2, lsr #16
   3ecb2:	fa1f fb8b 	uxth.w	fp, fp
   3ecb6:	445b      	add	r3, fp
   3ecb8:	fa1f fb82 	uxth.w	fp, r2
   3ecbc:	f8de 2000 	ldr.w	r2, [lr]
   3ecc0:	ebcb 4212 	rsb	r2, fp, r2, lsr #16
   3ecc4:	eb02 4223 	add.w	r2, r2, r3, asr #16
   3ecc8:	b29b      	uxth	r3, r3
   3ecca:	ea4f 4b22 	mov.w	fp, r2, asr #16
   3ecce:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   3ecd2:	f84e 3b04 	str.w	r3, [lr], #4
   3ecd6:	d2d9      	bcs.n	3ec8c <quorem+0x40>
   3ecd8:	582b      	ldr	r3, [r5, r0]
   3ecda:	b933      	cbnz	r3, 3ecea <quorem+0x9e>
   3ecdc:	9b01      	ldr	r3, [sp, #4]
   3ecde:	3b04      	subs	r3, #4
   3ece0:	429d      	cmp	r5, r3
   3ece2:	461a      	mov	r2, r3
   3ece4:	d332      	bcc.n	3ed4c <quorem+0x100>
   3ece6:	f8c8 4010 	str.w	r4, [r8, #16]
   3ecea:	4640      	mov	r0, r8
   3ecec:	f000 fa74 	bl	3f1d8 <__mcmp>
   3ecf0:	2800      	cmp	r0, #0
   3ecf2:	db27      	blt.n	3ed44 <quorem+0xf8>
   3ecf4:	3601      	adds	r6, #1
   3ecf6:	4628      	mov	r0, r5
   3ecf8:	f04f 0c00 	mov.w	ip, #0
   3ecfc:	f857 1b04 	ldr.w	r1, [r7], #4
   3ed00:	f8d0 e000 	ldr.w	lr, [r0]
   3ed04:	b28b      	uxth	r3, r1
   3ed06:	45b9      	cmp	r9, r7
   3ed08:	fa1f f28e 	uxth.w	r2, lr
   3ed0c:	ebac 0303 	sub.w	r3, ip, r3
   3ed10:	4413      	add	r3, r2
   3ed12:	ea4f 4211 	mov.w	r2, r1, lsr #16
   3ed16:	ebc2 421e 	rsb	r2, r2, lr, lsr #16
   3ed1a:	eb02 4223 	add.w	r2, r2, r3, asr #16
   3ed1e:	b29b      	uxth	r3, r3
   3ed20:	ea4f 4c22 	mov.w	ip, r2, asr #16
   3ed24:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   3ed28:	f840 3b04 	str.w	r3, [r0], #4
   3ed2c:	d2e6      	bcs.n	3ecfc <quorem+0xb0>
   3ed2e:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   3ed32:	eb05 0384 	add.w	r3, r5, r4, lsl #2
   3ed36:	b92a      	cbnz	r2, 3ed44 <quorem+0xf8>
   3ed38:	3b04      	subs	r3, #4
   3ed3a:	429d      	cmp	r5, r3
   3ed3c:	461a      	mov	r2, r3
   3ed3e:	d30b      	bcc.n	3ed58 <quorem+0x10c>
   3ed40:	f8c8 4010 	str.w	r4, [r8, #16]
   3ed44:	4630      	mov	r0, r6
   3ed46:	b003      	add	sp, #12
   3ed48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3ed4c:	6812      	ldr	r2, [r2, #0]
   3ed4e:	3b04      	subs	r3, #4
   3ed50:	2a00      	cmp	r2, #0
   3ed52:	d1c8      	bne.n	3ece6 <quorem+0x9a>
   3ed54:	3c01      	subs	r4, #1
   3ed56:	e7c3      	b.n	3ece0 <quorem+0x94>
   3ed58:	6812      	ldr	r2, [r2, #0]
   3ed5a:	3b04      	subs	r3, #4
   3ed5c:	2a00      	cmp	r2, #0
   3ed5e:	d1ef      	bne.n	3ed40 <quorem+0xf4>
   3ed60:	3c01      	subs	r4, #1
   3ed62:	e7ea      	b.n	3ed3a <quorem+0xee>
   3ed64:	2000      	movs	r0, #0
   3ed66:	e7ee      	b.n	3ed46 <quorem+0xfa>

0003ed68 <__sfmoreglue>:
   3ed68:	b570      	push	{r4, r5, r6, lr}
   3ed6a:	1e4a      	subs	r2, r1, #1
   3ed6c:	2568      	movs	r5, #104	; 0x68
   3ed6e:	460e      	mov	r6, r1
   3ed70:	4355      	muls	r5, r2
   3ed72:	f105 0174 	add.w	r1, r5, #116	; 0x74
   3ed76:	f7fb fb6f 	bl	3a458 <_malloc_r>
   3ed7a:	4604      	mov	r4, r0
   3ed7c:	b140      	cbz	r0, 3ed90 <__sfmoreglue+0x28>
   3ed7e:	2100      	movs	r1, #0
   3ed80:	f105 0268 	add.w	r2, r5, #104	; 0x68
   3ed84:	e9c0 1600 	strd	r1, r6, [r0]
   3ed88:	300c      	adds	r0, #12
   3ed8a:	60a0      	str	r0, [r4, #8]
   3ed8c:	f7ff fd7e 	bl	3e88c <memset>
   3ed90:	4620      	mov	r0, r4
   3ed92:	bd70      	pop	{r4, r5, r6, pc}

0003ed94 <_fwalk_reent>:
   3ed94:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   3ed98:	4680      	mov	r8, r0
   3ed9a:	4689      	mov	r9, r1
   3ed9c:	f100 0448 	add.w	r4, r0, #72	; 0x48
   3eda0:	2600      	movs	r6, #0
   3eda2:	b914      	cbnz	r4, 3edaa <_fwalk_reent+0x16>
   3eda4:	4630      	mov	r0, r6
   3eda6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   3edaa:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
   3edae:	3f01      	subs	r7, #1
   3edb0:	d501      	bpl.n	3edb6 <_fwalk_reent+0x22>
   3edb2:	6824      	ldr	r4, [r4, #0]
   3edb4:	e7f5      	b.n	3eda2 <_fwalk_reent+0xe>
   3edb6:	89ab      	ldrh	r3, [r5, #12]
   3edb8:	2b01      	cmp	r3, #1
   3edba:	d907      	bls.n	3edcc <_fwalk_reent+0x38>
   3edbc:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
   3edc0:	3301      	adds	r3, #1
   3edc2:	d003      	beq.n	3edcc <_fwalk_reent+0x38>
   3edc4:	4629      	mov	r1, r5
   3edc6:	4640      	mov	r0, r8
   3edc8:	47c8      	blx	r9
   3edca:	4306      	orrs	r6, r0
   3edcc:	3568      	adds	r5, #104	; 0x68
   3edce:	e7ee      	b.n	3edae <_fwalk_reent+0x1a>

0003edd0 <__retarget_lock_init_recursive>:
   3edd0:	4770      	bx	lr

0003edd2 <__retarget_lock_acquire_recursive>:
   3edd2:	4770      	bx	lr

0003edd4 <__retarget_lock_release_recursive>:
   3edd4:	4770      	bx	lr

0003edd6 <__swhatbuf_r>:
   3edd6:	b570      	push	{r4, r5, r6, lr}
   3edd8:	460e      	mov	r6, r1
   3edda:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   3edde:	b096      	sub	sp, #88	; 0x58
   3ede0:	4614      	mov	r4, r2
   3ede2:	2900      	cmp	r1, #0
   3ede4:	461d      	mov	r5, r3
   3ede6:	da07      	bge.n	3edf8 <__swhatbuf_r+0x22>
   3ede8:	2300      	movs	r3, #0
   3edea:	602b      	str	r3, [r5, #0]
   3edec:	89b3      	ldrh	r3, [r6, #12]
   3edee:	061a      	lsls	r2, r3, #24
   3edf0:	d410      	bmi.n	3ee14 <__swhatbuf_r+0x3e>
   3edf2:	f44f 6380 	mov.w	r3, #1024	; 0x400
   3edf6:	e00e      	b.n	3ee16 <__swhatbuf_r+0x40>
   3edf8:	466a      	mov	r2, sp
   3edfa:	f7fb fccb 	bl	3a794 <_fstat_r>
   3edfe:	2800      	cmp	r0, #0
   3ee00:	dbf2      	blt.n	3ede8 <__swhatbuf_r+0x12>
   3ee02:	9a01      	ldr	r2, [sp, #4]
   3ee04:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
   3ee08:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
   3ee0c:	425a      	negs	r2, r3
   3ee0e:	415a      	adcs	r2, r3
   3ee10:	602a      	str	r2, [r5, #0]
   3ee12:	e7ee      	b.n	3edf2 <__swhatbuf_r+0x1c>
   3ee14:	2340      	movs	r3, #64	; 0x40
   3ee16:	2000      	movs	r0, #0
   3ee18:	6023      	str	r3, [r4, #0]
   3ee1a:	b016      	add	sp, #88	; 0x58
   3ee1c:	bd70      	pop	{r4, r5, r6, pc}

0003ee1e <memmove>:
   3ee1e:	4288      	cmp	r0, r1
   3ee20:	eb01 0302 	add.w	r3, r1, r2
   3ee24:	b510      	push	{r4, lr}
   3ee26:	d902      	bls.n	3ee2e <memmove+0x10>
   3ee28:	4283      	cmp	r3, r0
   3ee2a:	461c      	mov	r4, r3
   3ee2c:	d807      	bhi.n	3ee3e <memmove+0x20>
   3ee2e:	1e42      	subs	r2, r0, #1
   3ee30:	4299      	cmp	r1, r3
   3ee32:	d008      	beq.n	3ee46 <memmove+0x28>
   3ee34:	f811 4b01 	ldrb.w	r4, [r1], #1
   3ee38:	f802 4f01 	strb.w	r4, [r2, #1]!
   3ee3c:	e7f8      	b.n	3ee30 <memmove+0x12>
   3ee3e:	1883      	adds	r3, r0, r2
   3ee40:	1a9a      	subs	r2, r3, r2
   3ee42:	429a      	cmp	r2, r3
   3ee44:	d100      	bne.n	3ee48 <memmove+0x2a>
   3ee46:	bd10      	pop	{r4, pc}
   3ee48:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
   3ee4c:	f803 1d01 	strb.w	r1, [r3, #-1]!
   3ee50:	e7f7      	b.n	3ee42 <memmove+0x24>

0003ee52 <_Balloc>:
   3ee52:	b570      	push	{r4, r5, r6, lr}
   3ee54:	6a45      	ldr	r5, [r0, #36]	; 0x24
   3ee56:	4604      	mov	r4, r0
   3ee58:	460e      	mov	r6, r1
   3ee5a:	b93d      	cbnz	r5, 3ee6c <_Balloc+0x1a>
   3ee5c:	2010      	movs	r0, #16
   3ee5e:	f7fb fa57 	bl	3a310 <malloc>
   3ee62:	6260      	str	r0, [r4, #36]	; 0x24
   3ee64:	6005      	str	r5, [r0, #0]
   3ee66:	60c5      	str	r5, [r0, #12]
   3ee68:	e9c0 5501 	strd	r5, r5, [r0, #4]
   3ee6c:	6a65      	ldr	r5, [r4, #36]	; 0x24
   3ee6e:	68eb      	ldr	r3, [r5, #12]
   3ee70:	b183      	cbz	r3, 3ee94 <_Balloc+0x42>
   3ee72:	6a63      	ldr	r3, [r4, #36]	; 0x24
   3ee74:	68db      	ldr	r3, [r3, #12]
   3ee76:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
   3ee7a:	b9b8      	cbnz	r0, 3eeac <_Balloc+0x5a>
   3ee7c:	2101      	movs	r1, #1
   3ee7e:	4620      	mov	r0, r4
   3ee80:	fa01 f506 	lsl.w	r5, r1, r6
   3ee84:	1d6a      	adds	r2, r5, #5
   3ee86:	0092      	lsls	r2, r2, #2
   3ee88:	f000 fa6e 	bl	3f368 <_calloc_r>
   3ee8c:	b160      	cbz	r0, 3eea8 <_Balloc+0x56>
   3ee8e:	e9c0 6501 	strd	r6, r5, [r0, #4]
   3ee92:	e00e      	b.n	3eeb2 <_Balloc+0x60>
   3ee94:	2221      	movs	r2, #33	; 0x21
   3ee96:	2104      	movs	r1, #4
   3ee98:	4620      	mov	r0, r4
   3ee9a:	f000 fa65 	bl	3f368 <_calloc_r>
   3ee9e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   3eea0:	60e8      	str	r0, [r5, #12]
   3eea2:	68db      	ldr	r3, [r3, #12]
   3eea4:	2b00      	cmp	r3, #0
   3eea6:	d1e4      	bne.n	3ee72 <_Balloc+0x20>
   3eea8:	2000      	movs	r0, #0
   3eeaa:	bd70      	pop	{r4, r5, r6, pc}
   3eeac:	6802      	ldr	r2, [r0, #0]
   3eeae:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
   3eeb2:	2300      	movs	r3, #0
   3eeb4:	e9c0 3303 	strd	r3, r3, [r0, #12]
   3eeb8:	e7f7      	b.n	3eeaa <_Balloc+0x58>

0003eeba <_Bfree>:
   3eeba:	b570      	push	{r4, r5, r6, lr}
   3eebc:	6a44      	ldr	r4, [r0, #36]	; 0x24
   3eebe:	4606      	mov	r6, r0
   3eec0:	460d      	mov	r5, r1
   3eec2:	b93c      	cbnz	r4, 3eed4 <_Bfree+0x1a>
   3eec4:	2010      	movs	r0, #16
   3eec6:	f7fb fa23 	bl	3a310 <malloc>
   3eeca:	6270      	str	r0, [r6, #36]	; 0x24
   3eecc:	6004      	str	r4, [r0, #0]
   3eece:	60c4      	str	r4, [r0, #12]
   3eed0:	e9c0 4401 	strd	r4, r4, [r0, #4]
   3eed4:	b13d      	cbz	r5, 3eee6 <_Bfree+0x2c>
   3eed6:	6a73      	ldr	r3, [r6, #36]	; 0x24
   3eed8:	686a      	ldr	r2, [r5, #4]
   3eeda:	68db      	ldr	r3, [r3, #12]
   3eedc:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   3eee0:	6029      	str	r1, [r5, #0]
   3eee2:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
   3eee6:	bd70      	pop	{r4, r5, r6, pc}

0003eee8 <__multadd>:
   3eee8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3eeec:	f101 0c14 	add.w	ip, r1, #20
   3eef0:	461f      	mov	r7, r3
   3eef2:	4606      	mov	r6, r0
   3eef4:	460c      	mov	r4, r1
   3eef6:	690d      	ldr	r5, [r1, #16]
   3eef8:	2300      	movs	r3, #0
   3eefa:	f8dc 0000 	ldr.w	r0, [ip]
   3eefe:	3301      	adds	r3, #1
   3ef00:	b281      	uxth	r1, r0
   3ef02:	429d      	cmp	r5, r3
   3ef04:	ea4f 4010 	mov.w	r0, r0, lsr #16
   3ef08:	fb02 7101 	mla	r1, r2, r1, r7
   3ef0c:	ea4f 4711 	mov.w	r7, r1, lsr #16
   3ef10:	b289      	uxth	r1, r1
   3ef12:	fb02 7000 	mla	r0, r2, r0, r7
   3ef16:	eb01 4100 	add.w	r1, r1, r0, lsl #16
   3ef1a:	ea4f 4710 	mov.w	r7, r0, lsr #16
   3ef1e:	f84c 1b04 	str.w	r1, [ip], #4
   3ef22:	dcea      	bgt.n	3eefa <__multadd+0x12>
   3ef24:	b1d7      	cbz	r7, 3ef5c <__multadd+0x74>
   3ef26:	68a3      	ldr	r3, [r4, #8]
   3ef28:	42ab      	cmp	r3, r5
   3ef2a:	dc12      	bgt.n	3ef52 <__multadd+0x6a>
   3ef2c:	6861      	ldr	r1, [r4, #4]
   3ef2e:	4630      	mov	r0, r6
   3ef30:	3101      	adds	r1, #1
   3ef32:	f7ff ff8e 	bl	3ee52 <_Balloc>
   3ef36:	6922      	ldr	r2, [r4, #16]
   3ef38:	4680      	mov	r8, r0
   3ef3a:	f104 010c 	add.w	r1, r4, #12
   3ef3e:	3202      	adds	r2, #2
   3ef40:	300c      	adds	r0, #12
   3ef42:	0092      	lsls	r2, r2, #2
   3ef44:	f7ff fc82 	bl	3e84c <memcpy>
   3ef48:	4621      	mov	r1, r4
   3ef4a:	4644      	mov	r4, r8
   3ef4c:	4630      	mov	r0, r6
   3ef4e:	f7ff ffb4 	bl	3eeba <_Bfree>
   3ef52:	eb04 0385 	add.w	r3, r4, r5, lsl #2
   3ef56:	3501      	adds	r5, #1
   3ef58:	615f      	str	r7, [r3, #20]
   3ef5a:	6125      	str	r5, [r4, #16]
   3ef5c:	4620      	mov	r0, r4
   3ef5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0003ef62 <__hi0bits>:
   3ef62:	0c02      	lsrs	r2, r0, #16
   3ef64:	4603      	mov	r3, r0
   3ef66:	0412      	lsls	r2, r2, #16
   3ef68:	b9ca      	cbnz	r2, 3ef9e <__hi0bits+0x3c>
   3ef6a:	0403      	lsls	r3, r0, #16
   3ef6c:	2010      	movs	r0, #16
   3ef6e:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
   3ef72:	bf04      	itt	eq
   3ef74:	021b      	lsleq	r3, r3, #8
   3ef76:	3008      	addeq	r0, #8
   3ef78:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
   3ef7c:	bf04      	itt	eq
   3ef7e:	011b      	lsleq	r3, r3, #4
   3ef80:	3004      	addeq	r0, #4
   3ef82:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
   3ef86:	bf04      	itt	eq
   3ef88:	009b      	lsleq	r3, r3, #2
   3ef8a:	3002      	addeq	r0, #2
   3ef8c:	2b00      	cmp	r3, #0
   3ef8e:	db05      	blt.n	3ef9c <__hi0bits+0x3a>
   3ef90:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
   3ef94:	f100 0001 	add.w	r0, r0, #1
   3ef98:	bf08      	it	eq
   3ef9a:	2020      	moveq	r0, #32
   3ef9c:	4770      	bx	lr
   3ef9e:	2000      	movs	r0, #0
   3efa0:	e7e5      	b.n	3ef6e <__hi0bits+0xc>

0003efa2 <__lo0bits>:
   3efa2:	6803      	ldr	r3, [r0, #0]
   3efa4:	4601      	mov	r1, r0
   3efa6:	f013 0207 	ands.w	r2, r3, #7
   3efaa:	d00b      	beq.n	3efc4 <__lo0bits+0x22>
   3efac:	07da      	lsls	r2, r3, #31
   3efae:	d424      	bmi.n	3effa <__lo0bits+0x58>
   3efb0:	0798      	lsls	r0, r3, #30
   3efb2:	bf47      	ittee	mi
   3efb4:	085b      	lsrmi	r3, r3, #1
   3efb6:	2001      	movmi	r0, #1
   3efb8:	089b      	lsrpl	r3, r3, #2
   3efba:	2002      	movpl	r0, #2
   3efbc:	bf4c      	ite	mi
   3efbe:	600b      	strmi	r3, [r1, #0]
   3efc0:	600b      	strpl	r3, [r1, #0]
   3efc2:	4770      	bx	lr
   3efc4:	b298      	uxth	r0, r3
   3efc6:	b9b0      	cbnz	r0, 3eff6 <__lo0bits+0x54>
   3efc8:	0c1b      	lsrs	r3, r3, #16
   3efca:	2010      	movs	r0, #16
   3efcc:	f013 0fff 	tst.w	r3, #255	; 0xff
   3efd0:	bf04      	itt	eq
   3efd2:	0a1b      	lsreq	r3, r3, #8
   3efd4:	3008      	addeq	r0, #8
   3efd6:	071a      	lsls	r2, r3, #28
   3efd8:	bf04      	itt	eq
   3efda:	091b      	lsreq	r3, r3, #4
   3efdc:	3004      	addeq	r0, #4
   3efde:	079a      	lsls	r2, r3, #30
   3efe0:	bf04      	itt	eq
   3efe2:	089b      	lsreq	r3, r3, #2
   3efe4:	3002      	addeq	r0, #2
   3efe6:	07da      	lsls	r2, r3, #31
   3efe8:	d403      	bmi.n	3eff2 <__lo0bits+0x50>
   3efea:	085b      	lsrs	r3, r3, #1
   3efec:	f100 0001 	add.w	r0, r0, #1
   3eff0:	d005      	beq.n	3effe <__lo0bits+0x5c>
   3eff2:	600b      	str	r3, [r1, #0]
   3eff4:	4770      	bx	lr
   3eff6:	4610      	mov	r0, r2
   3eff8:	e7e8      	b.n	3efcc <__lo0bits+0x2a>
   3effa:	2000      	movs	r0, #0
   3effc:	4770      	bx	lr
   3effe:	2020      	movs	r0, #32
   3f000:	4770      	bx	lr

0003f002 <__i2b>:
   3f002:	b510      	push	{r4, lr}
   3f004:	460c      	mov	r4, r1
   3f006:	2101      	movs	r1, #1
   3f008:	f7ff ff23 	bl	3ee52 <_Balloc>
   3f00c:	2201      	movs	r2, #1
   3f00e:	6144      	str	r4, [r0, #20]
   3f010:	6102      	str	r2, [r0, #16]
   3f012:	bd10      	pop	{r4, pc}

0003f014 <__multiply>:
   3f014:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3f018:	4690      	mov	r8, r2
   3f01a:	690a      	ldr	r2, [r1, #16]
   3f01c:	460c      	mov	r4, r1
   3f01e:	f8d8 3010 	ldr.w	r3, [r8, #16]
   3f022:	429a      	cmp	r2, r3
   3f024:	bfbe      	ittt	lt
   3f026:	460b      	movlt	r3, r1
   3f028:	4644      	movlt	r4, r8
   3f02a:	4698      	movlt	r8, r3
   3f02c:	6927      	ldr	r7, [r4, #16]
   3f02e:	68a3      	ldr	r3, [r4, #8]
   3f030:	f8d8 9010 	ldr.w	r9, [r8, #16]
   3f034:	6861      	ldr	r1, [r4, #4]
   3f036:	eb07 0609 	add.w	r6, r7, r9
   3f03a:	42b3      	cmp	r3, r6
   3f03c:	bfb8      	it	lt
   3f03e:	3101      	addlt	r1, #1
   3f040:	f7ff ff07 	bl	3ee52 <_Balloc>
   3f044:	f100 0514 	add.w	r5, r0, #20
   3f048:	2200      	movs	r2, #0
   3f04a:	eb05 0e86 	add.w	lr, r5, r6, lsl #2
   3f04e:	462b      	mov	r3, r5
   3f050:	4573      	cmp	r3, lr
   3f052:	d316      	bcc.n	3f082 <__multiply+0x6e>
   3f054:	f104 0314 	add.w	r3, r4, #20
   3f058:	f108 0214 	add.w	r2, r8, #20
   3f05c:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   3f060:	eb02 0389 	add.w	r3, r2, r9, lsl #2
   3f064:	9300      	str	r3, [sp, #0]
   3f066:	9b00      	ldr	r3, [sp, #0]
   3f068:	9201      	str	r2, [sp, #4]
   3f06a:	4293      	cmp	r3, r2
   3f06c:	d80c      	bhi.n	3f088 <__multiply+0x74>
   3f06e:	2e00      	cmp	r6, #0
   3f070:	dd03      	ble.n	3f07a <__multiply+0x66>
   3f072:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
   3f076:	2b00      	cmp	r3, #0
   3f078:	d059      	beq.n	3f12e <__multiply+0x11a>
   3f07a:	6106      	str	r6, [r0, #16]
   3f07c:	b003      	add	sp, #12
   3f07e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3f082:	f843 2b04 	str.w	r2, [r3], #4
   3f086:	e7e3      	b.n	3f050 <__multiply+0x3c>
   3f088:	f8b2 a000 	ldrh.w	sl, [r2]
   3f08c:	f1ba 0f00 	cmp.w	sl, #0
   3f090:	d023      	beq.n	3f0da <__multiply+0xc6>
   3f092:	f104 0914 	add.w	r9, r4, #20
   3f096:	46ac      	mov	ip, r5
   3f098:	f04f 0800 	mov.w	r8, #0
   3f09c:	f859 1b04 	ldr.w	r1, [r9], #4
   3f0a0:	f8dc b000 	ldr.w	fp, [ip]
   3f0a4:	b28b      	uxth	r3, r1
   3f0a6:	454f      	cmp	r7, r9
   3f0a8:	fa1f fb8b 	uxth.w	fp, fp
   3f0ac:	fb0a b303 	mla	r3, sl, r3, fp
   3f0b0:	ea4f 4b11 	mov.w	fp, r1, lsr #16
   3f0b4:	f8dc 1000 	ldr.w	r1, [ip]
   3f0b8:	4443      	add	r3, r8
   3f0ba:	ea4f 4811 	mov.w	r8, r1, lsr #16
   3f0be:	fb0a 810b 	mla	r1, sl, fp, r8
   3f0c2:	eb01 4113 	add.w	r1, r1, r3, lsr #16
   3f0c6:	b29b      	uxth	r3, r3
   3f0c8:	ea4f 4811 	mov.w	r8, r1, lsr #16
   3f0cc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   3f0d0:	f84c 3b04 	str.w	r3, [ip], #4
   3f0d4:	d8e2      	bhi.n	3f09c <__multiply+0x88>
   3f0d6:	f8cc 8000 	str.w	r8, [ip]
   3f0da:	9b01      	ldr	r3, [sp, #4]
   3f0dc:	3204      	adds	r2, #4
   3f0de:	f8b3 9002 	ldrh.w	r9, [r3, #2]
   3f0e2:	f1b9 0f00 	cmp.w	r9, #0
   3f0e6:	d020      	beq.n	3f12a <__multiply+0x116>
   3f0e8:	682b      	ldr	r3, [r5, #0]
   3f0ea:	f104 0814 	add.w	r8, r4, #20
   3f0ee:	46ac      	mov	ip, r5
   3f0f0:	f04f 0a00 	mov.w	sl, #0
   3f0f4:	f8b8 1000 	ldrh.w	r1, [r8]
   3f0f8:	b29b      	uxth	r3, r3
   3f0fa:	f8bc b002 	ldrh.w	fp, [ip, #2]
   3f0fe:	fb09 b101 	mla	r1, r9, r1, fp
   3f102:	448a      	add	sl, r1
   3f104:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
   3f108:	f84c 3b04 	str.w	r3, [ip], #4
   3f10c:	f858 3b04 	ldr.w	r3, [r8], #4
   3f110:	f8bc 1000 	ldrh.w	r1, [ip]
   3f114:	0c1b      	lsrs	r3, r3, #16
   3f116:	4547      	cmp	r7, r8
   3f118:	fb09 1303 	mla	r3, r9, r3, r1
   3f11c:	eb03 431a 	add.w	r3, r3, sl, lsr #16
   3f120:	ea4f 4a13 	mov.w	sl, r3, lsr #16
   3f124:	d8e6      	bhi.n	3f0f4 <__multiply+0xe0>
   3f126:	f8cc 3000 	str.w	r3, [ip]
   3f12a:	3504      	adds	r5, #4
   3f12c:	e79b      	b.n	3f066 <__multiply+0x52>
   3f12e:	3e01      	subs	r6, #1
   3f130:	e79d      	b.n	3f06e <__multiply+0x5a>

0003f132 <__lshift>:
   3f132:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   3f136:	460c      	mov	r4, r1
   3f138:	ea4f 1a62 	mov.w	sl, r2, asr #5
   3f13c:	4607      	mov	r7, r0
   3f13e:	4616      	mov	r6, r2
   3f140:	6923      	ldr	r3, [r4, #16]
   3f142:	6849      	ldr	r1, [r1, #4]
   3f144:	eb0a 0903 	add.w	r9, sl, r3
   3f148:	68a3      	ldr	r3, [r4, #8]
   3f14a:	f109 0501 	add.w	r5, r9, #1
   3f14e:	42ab      	cmp	r3, r5
   3f150:	db33      	blt.n	3f1ba <__lshift+0x88>
   3f152:	4638      	mov	r0, r7
   3f154:	f7ff fe7d 	bl	3ee52 <_Balloc>
   3f158:	2300      	movs	r3, #0
   3f15a:	4680      	mov	r8, r0
   3f15c:	f100 0114 	add.w	r1, r0, #20
   3f160:	f100 0210 	add.w	r2, r0, #16
   3f164:	4618      	mov	r0, r3
   3f166:	4553      	cmp	r3, sl
   3f168:	db2a      	blt.n	3f1c0 <__lshift+0x8e>
   3f16a:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
   3f16e:	f104 0314 	add.w	r3, r4, #20
   3f172:	6920      	ldr	r0, [r4, #16]
   3f174:	f016 021f 	ands.w	r2, r6, #31
   3f178:	eb01 018a 	add.w	r1, r1, sl, lsl #2
   3f17c:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   3f180:	d022      	beq.n	3f1c8 <__lshift+0x96>
   3f182:	f1c2 0e20 	rsb	lr, r2, #32
   3f186:	2000      	movs	r0, #0
   3f188:	681e      	ldr	r6, [r3, #0]
   3f18a:	4096      	lsls	r6, r2
   3f18c:	4330      	orrs	r0, r6
   3f18e:	f841 0b04 	str.w	r0, [r1], #4
   3f192:	f853 0b04 	ldr.w	r0, [r3], #4
   3f196:	459c      	cmp	ip, r3
   3f198:	fa20 f00e 	lsr.w	r0, r0, lr
   3f19c:	d8f4      	bhi.n	3f188 <__lshift+0x56>
   3f19e:	6008      	str	r0, [r1, #0]
   3f1a0:	b108      	cbz	r0, 3f1a6 <__lshift+0x74>
   3f1a2:	f109 0502 	add.w	r5, r9, #2
   3f1a6:	3d01      	subs	r5, #1
   3f1a8:	4638      	mov	r0, r7
   3f1aa:	4621      	mov	r1, r4
   3f1ac:	f8c8 5010 	str.w	r5, [r8, #16]
   3f1b0:	f7ff fe83 	bl	3eeba <_Bfree>
   3f1b4:	4640      	mov	r0, r8
   3f1b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3f1ba:	3101      	adds	r1, #1
   3f1bc:	005b      	lsls	r3, r3, #1
   3f1be:	e7c6      	b.n	3f14e <__lshift+0x1c>
   3f1c0:	f842 0f04 	str.w	r0, [r2, #4]!
   3f1c4:	3301      	adds	r3, #1
   3f1c6:	e7ce      	b.n	3f166 <__lshift+0x34>
   3f1c8:	3904      	subs	r1, #4
   3f1ca:	f853 2b04 	ldr.w	r2, [r3], #4
   3f1ce:	459c      	cmp	ip, r3
   3f1d0:	f841 2f04 	str.w	r2, [r1, #4]!
   3f1d4:	d8f9      	bhi.n	3f1ca <__lshift+0x98>
   3f1d6:	e7e6      	b.n	3f1a6 <__lshift+0x74>

0003f1d8 <__mcmp>:
   3f1d8:	6903      	ldr	r3, [r0, #16]
   3f1da:	690a      	ldr	r2, [r1, #16]
   3f1dc:	1a9b      	subs	r3, r3, r2
   3f1de:	b530      	push	{r4, r5, lr}
   3f1e0:	d10c      	bne.n	3f1fc <__mcmp+0x24>
   3f1e2:	0092      	lsls	r2, r2, #2
   3f1e4:	3014      	adds	r0, #20
   3f1e6:	3114      	adds	r1, #20
   3f1e8:	1884      	adds	r4, r0, r2
   3f1ea:	4411      	add	r1, r2
   3f1ec:	f854 5d04 	ldr.w	r5, [r4, #-4]!
   3f1f0:	f851 2d04 	ldr.w	r2, [r1, #-4]!
   3f1f4:	4295      	cmp	r5, r2
   3f1f6:	d003      	beq.n	3f200 <__mcmp+0x28>
   3f1f8:	d305      	bcc.n	3f206 <__mcmp+0x2e>
   3f1fa:	2301      	movs	r3, #1
   3f1fc:	4618      	mov	r0, r3
   3f1fe:	bd30      	pop	{r4, r5, pc}
   3f200:	42a0      	cmp	r0, r4
   3f202:	d3f3      	bcc.n	3f1ec <__mcmp+0x14>
   3f204:	e7fa      	b.n	3f1fc <__mcmp+0x24>
   3f206:	f04f 33ff 	mov.w	r3, #4294967295
   3f20a:	e7f7      	b.n	3f1fc <__mcmp+0x24>

0003f20c <__mdiff>:
   3f20c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   3f210:	460d      	mov	r5, r1
   3f212:	4607      	mov	r7, r0
   3f214:	4611      	mov	r1, r2
   3f216:	4614      	mov	r4, r2
   3f218:	4628      	mov	r0, r5
   3f21a:	f7ff ffdd 	bl	3f1d8 <__mcmp>
   3f21e:	1e06      	subs	r6, r0, #0
   3f220:	d108      	bne.n	3f234 <__mdiff+0x28>
   3f222:	4631      	mov	r1, r6
   3f224:	4638      	mov	r0, r7
   3f226:	f7ff fe14 	bl	3ee52 <_Balloc>
   3f22a:	2301      	movs	r3, #1
   3f22c:	e9c0 3604 	strd	r3, r6, [r0, #16]
   3f230:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3f234:	bfa3      	ittte	ge
   3f236:	4623      	movge	r3, r4
   3f238:	462c      	movge	r4, r5
   3f23a:	2600      	movge	r6, #0
   3f23c:	2601      	movlt	r6, #1
   3f23e:	bfa8      	it	ge
   3f240:	461d      	movge	r5, r3
   3f242:	6861      	ldr	r1, [r4, #4]
   3f244:	4638      	mov	r0, r7
   3f246:	f7ff fe04 	bl	3ee52 <_Balloc>
   3f24a:	f105 0914 	add.w	r9, r5, #20
   3f24e:	60c6      	str	r6, [r0, #12]
   3f250:	f104 0214 	add.w	r2, r4, #20
   3f254:	6926      	ldr	r6, [r4, #16]
   3f256:	f100 0114 	add.w	r1, r0, #20
   3f25a:	692b      	ldr	r3, [r5, #16]
   3f25c:	f04f 0e00 	mov.w	lr, #0
   3f260:	eb02 0786 	add.w	r7, r2, r6, lsl #2
   3f264:	eb09 0883 	add.w	r8, r9, r3, lsl #2
   3f268:	f852 ab04 	ldr.w	sl, [r2], #4
   3f26c:	f859 5b04 	ldr.w	r5, [r9], #4
   3f270:	fa1f f38a 	uxth.w	r3, sl
   3f274:	4694      	mov	ip, r2
   3f276:	b2ac      	uxth	r4, r5
   3f278:	45c8      	cmp	r8, r9
   3f27a:	4473      	add	r3, lr
   3f27c:	eba3 0304 	sub.w	r3, r3, r4
   3f280:	ea4f 4415 	mov.w	r4, r5, lsr #16
   3f284:	ebc4 441a 	rsb	r4, r4, sl, lsr #16
   3f288:	eb04 4423 	add.w	r4, r4, r3, asr #16
   3f28c:	b29b      	uxth	r3, r3
   3f28e:	ea4f 4e24 	mov.w	lr, r4, asr #16
   3f292:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
   3f296:	f841 4b04 	str.w	r4, [r1], #4
   3f29a:	d8e5      	bhi.n	3f268 <__mdiff+0x5c>
   3f29c:	45bc      	cmp	ip, r7
   3f29e:	d304      	bcc.n	3f2aa <__mdiff+0x9e>
   3f2a0:	f851 3d04 	ldr.w	r3, [r1, #-4]!
   3f2a4:	b183      	cbz	r3, 3f2c8 <__mdiff+0xbc>
   3f2a6:	6106      	str	r6, [r0, #16]
   3f2a8:	e7c2      	b.n	3f230 <__mdiff+0x24>
   3f2aa:	f85c 4b04 	ldr.w	r4, [ip], #4
   3f2ae:	b2a2      	uxth	r2, r4
   3f2b0:	4472      	add	r2, lr
   3f2b2:	1413      	asrs	r3, r2, #16
   3f2b4:	b292      	uxth	r2, r2
   3f2b6:	eb03 4314 	add.w	r3, r3, r4, lsr #16
   3f2ba:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
   3f2be:	ea4f 4e23 	mov.w	lr, r3, asr #16
   3f2c2:	f841 2b04 	str.w	r2, [r1], #4
   3f2c6:	e7e9      	b.n	3f29c <__mdiff+0x90>
   3f2c8:	3e01      	subs	r6, #1
   3f2ca:	e7e9      	b.n	3f2a0 <__mdiff+0x94>

0003f2cc <__d2b>:
   3f2cc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   3f2d0:	ec59 8b10 	vmov	r8, r9, d0
   3f2d4:	f3c9 540a 	ubfx	r4, r9, #20, #11
   3f2d8:	460e      	mov	r6, r1
   3f2da:	2101      	movs	r1, #1
   3f2dc:	4615      	mov	r5, r2
   3f2de:	f7ff fdb8 	bl	3ee52 <_Balloc>
   3f2e2:	f3c9 0313 	ubfx	r3, r9, #0, #20
   3f2e6:	4607      	mov	r7, r0
   3f2e8:	bb2c      	cbnz	r4, 3f336 <__d2b+0x6a>
   3f2ea:	9301      	str	r3, [sp, #4]
   3f2ec:	f1b8 0300 	subs.w	r3, r8, #0
   3f2f0:	d026      	beq.n	3f340 <__d2b+0x74>
   3f2f2:	4668      	mov	r0, sp
   3f2f4:	9300      	str	r3, [sp, #0]
   3f2f6:	f7ff fe54 	bl	3efa2 <__lo0bits>
   3f2fa:	9900      	ldr	r1, [sp, #0]
   3f2fc:	b1f0      	cbz	r0, 3f33c <__d2b+0x70>
   3f2fe:	9a01      	ldr	r2, [sp, #4]
   3f300:	f1c0 0320 	rsb	r3, r0, #32
   3f304:	fa02 f303 	lsl.w	r3, r2, r3
   3f308:	40c2      	lsrs	r2, r0
   3f30a:	430b      	orrs	r3, r1
   3f30c:	9201      	str	r2, [sp, #4]
   3f30e:	617b      	str	r3, [r7, #20]
   3f310:	9b01      	ldr	r3, [sp, #4]
   3f312:	2b00      	cmp	r3, #0
   3f314:	61bb      	str	r3, [r7, #24]
   3f316:	bf14      	ite	ne
   3f318:	2102      	movne	r1, #2
   3f31a:	2101      	moveq	r1, #1
   3f31c:	6139      	str	r1, [r7, #16]
   3f31e:	b1c4      	cbz	r4, 3f352 <__d2b+0x86>
   3f320:	f2a4 4433 	subw	r4, r4, #1075	; 0x433
   3f324:	4404      	add	r4, r0
   3f326:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
   3f32a:	6034      	str	r4, [r6, #0]
   3f32c:	6028      	str	r0, [r5, #0]
   3f32e:	4638      	mov	r0, r7
   3f330:	b003      	add	sp, #12
   3f332:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   3f336:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   3f33a:	e7d6      	b.n	3f2ea <__d2b+0x1e>
   3f33c:	6179      	str	r1, [r7, #20]
   3f33e:	e7e7      	b.n	3f310 <__d2b+0x44>
   3f340:	a801      	add	r0, sp, #4
   3f342:	f7ff fe2e 	bl	3efa2 <__lo0bits>
   3f346:	9b01      	ldr	r3, [sp, #4]
   3f348:	2101      	movs	r1, #1
   3f34a:	3020      	adds	r0, #32
   3f34c:	617b      	str	r3, [r7, #20]
   3f34e:	6139      	str	r1, [r7, #16]
   3f350:	e7e5      	b.n	3f31e <__d2b+0x52>
   3f352:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
   3f356:	eb07 0381 	add.w	r3, r7, r1, lsl #2
   3f35a:	6030      	str	r0, [r6, #0]
   3f35c:	6918      	ldr	r0, [r3, #16]
   3f35e:	f7ff fe00 	bl	3ef62 <__hi0bits>
   3f362:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
   3f366:	e7e1      	b.n	3f32c <__d2b+0x60>

0003f368 <_calloc_r>:
   3f368:	b538      	push	{r3, r4, r5, lr}
   3f36a:	fb02 f401 	mul.w	r4, r2, r1
   3f36e:	4621      	mov	r1, r4
   3f370:	f7fb f872 	bl	3a458 <_malloc_r>
   3f374:	4605      	mov	r5, r0
   3f376:	b118      	cbz	r0, 3f380 <_calloc_r+0x18>
   3f378:	4622      	mov	r2, r4
   3f37a:	2100      	movs	r1, #0
   3f37c:	f7ff fa86 	bl	3e88c <memset>
   3f380:	4628      	mov	r0, r5
   3f382:	bd38      	pop	{r3, r4, r5, pc}

0003f384 <_realloc_r>:
   3f384:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3f386:	4607      	mov	r7, r0
   3f388:	4614      	mov	r4, r2
   3f38a:	460e      	mov	r6, r1
   3f38c:	b921      	cbnz	r1, 3f398 <_realloc_r+0x14>
   3f38e:	4611      	mov	r1, r2
   3f390:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   3f394:	f7fb b860 	b.w	3a458 <_malloc_r>
   3f398:	b922      	cbnz	r2, 3f3a4 <_realloc_r+0x20>
   3f39a:	4625      	mov	r5, r4
   3f39c:	f7fb f80e 	bl	3a3bc <_free_r>
   3f3a0:	4628      	mov	r0, r5
   3f3a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   3f3a4:	f000 f8ee 	bl	3f584 <_malloc_usable_size_r>
   3f3a8:	42a0      	cmp	r0, r4
   3f3aa:	d20f      	bcs.n	3f3cc <_realloc_r+0x48>
   3f3ac:	4621      	mov	r1, r4
   3f3ae:	4638      	mov	r0, r7
   3f3b0:	f7fb f852 	bl	3a458 <_malloc_r>
   3f3b4:	4605      	mov	r5, r0
   3f3b6:	2800      	cmp	r0, #0
   3f3b8:	d0f2      	beq.n	3f3a0 <_realloc_r+0x1c>
   3f3ba:	4631      	mov	r1, r6
   3f3bc:	4622      	mov	r2, r4
   3f3be:	f7ff fa45 	bl	3e84c <memcpy>
   3f3c2:	4631      	mov	r1, r6
   3f3c4:	4638      	mov	r0, r7
   3f3c6:	f7fa fff9 	bl	3a3bc <_free_r>
   3f3ca:	e7e9      	b.n	3f3a0 <_realloc_r+0x1c>
   3f3cc:	4635      	mov	r5, r6
   3f3ce:	e7e7      	b.n	3f3a0 <_realloc_r+0x1c>

0003f3d0 <__ssputs_r>:
   3f3d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   3f3d4:	688e      	ldr	r6, [r1, #8]
   3f3d6:	4682      	mov	sl, r0
   3f3d8:	460c      	mov	r4, r1
   3f3da:	4691      	mov	r9, r2
   3f3dc:	429e      	cmp	r6, r3
   3f3de:	4698      	mov	r8, r3
   3f3e0:	d838      	bhi.n	3f454 <__ssputs_r+0x84>
   3f3e2:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
   3f3e6:	f41c 6f90 	tst.w	ip, #1152	; 0x480
   3f3ea:	d031      	beq.n	3f450 <__ssputs_r+0x80>
   3f3ec:	6962      	ldr	r2, [r4, #20]
   3f3ee:	3301      	adds	r3, #1
   3f3f0:	6825      	ldr	r5, [r4, #0]
   3f3f2:	6909      	ldr	r1, [r1, #16]
   3f3f4:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   3f3f8:	1a6f      	subs	r7, r5, r1
   3f3fa:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   3f3fe:	443b      	add	r3, r7
   3f400:	1055      	asrs	r5, r2, #1
   3f402:	429d      	cmp	r5, r3
   3f404:	bf38      	it	cc
   3f406:	461d      	movcc	r5, r3
   3f408:	f41c 6f80 	tst.w	ip, #1024	; 0x400
   3f40c:	d030      	beq.n	3f470 <__ssputs_r+0xa0>
   3f40e:	4629      	mov	r1, r5
   3f410:	f7fb f822 	bl	3a458 <_malloc_r>
   3f414:	4606      	mov	r6, r0
   3f416:	b950      	cbnz	r0, 3f42e <__ssputs_r+0x5e>
   3f418:	230c      	movs	r3, #12
   3f41a:	f04f 30ff 	mov.w	r0, #4294967295
   3f41e:	f8ca 3000 	str.w	r3, [sl]
   3f422:	89a3      	ldrh	r3, [r4, #12]
   3f424:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   3f428:	81a3      	strh	r3, [r4, #12]
   3f42a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3f42e:	463a      	mov	r2, r7
   3f430:	6921      	ldr	r1, [r4, #16]
   3f432:	f7ff fa0b 	bl	3e84c <memcpy>
   3f436:	89a3      	ldrh	r3, [r4, #12]
   3f438:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   3f43c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   3f440:	81a3      	strh	r3, [r4, #12]
   3f442:	6126      	str	r6, [r4, #16]
   3f444:	443e      	add	r6, r7
   3f446:	6165      	str	r5, [r4, #20]
   3f448:	1bed      	subs	r5, r5, r7
   3f44a:	6026      	str	r6, [r4, #0]
   3f44c:	4646      	mov	r6, r8
   3f44e:	60a5      	str	r5, [r4, #8]
   3f450:	4546      	cmp	r6, r8
   3f452:	d900      	bls.n	3f456 <__ssputs_r+0x86>
   3f454:	4646      	mov	r6, r8
   3f456:	4632      	mov	r2, r6
   3f458:	4649      	mov	r1, r9
   3f45a:	6820      	ldr	r0, [r4, #0]
   3f45c:	f7ff fcdf 	bl	3ee1e <memmove>
   3f460:	68a3      	ldr	r3, [r4, #8]
   3f462:	2000      	movs	r0, #0
   3f464:	1b9b      	subs	r3, r3, r6
   3f466:	60a3      	str	r3, [r4, #8]
   3f468:	6823      	ldr	r3, [r4, #0]
   3f46a:	441e      	add	r6, r3
   3f46c:	6026      	str	r6, [r4, #0]
   3f46e:	e7dc      	b.n	3f42a <__ssputs_r+0x5a>
   3f470:	462a      	mov	r2, r5
   3f472:	f7ff ff87 	bl	3f384 <_realloc_r>
   3f476:	4606      	mov	r6, r0
   3f478:	2800      	cmp	r0, #0
   3f47a:	d1e2      	bne.n	3f442 <__ssputs_r+0x72>
   3f47c:	6921      	ldr	r1, [r4, #16]
   3f47e:	4650      	mov	r0, sl
   3f480:	f7fa ff9c 	bl	3a3bc <_free_r>
   3f484:	e7c8      	b.n	3f418 <__ssputs_r+0x48>

0003f486 <_raise_r>:
   3f486:	291f      	cmp	r1, #31
   3f488:	b538      	push	{r3, r4, r5, lr}
   3f48a:	4604      	mov	r4, r0
   3f48c:	460d      	mov	r5, r1
   3f48e:	d904      	bls.n	3f49a <_raise_r+0x14>
   3f490:	2316      	movs	r3, #22
   3f492:	6003      	str	r3, [r0, #0]
   3f494:	f04f 30ff 	mov.w	r0, #4294967295
   3f498:	bd38      	pop	{r3, r4, r5, pc}
   3f49a:	6c42      	ldr	r2, [r0, #68]	; 0x44
   3f49c:	b112      	cbz	r2, 3f4a4 <_raise_r+0x1e>
   3f49e:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   3f4a2:	b94b      	cbnz	r3, 3f4b8 <_raise_r+0x32>
   3f4a4:	4620      	mov	r0, r4
   3f4a6:	f000 f816 	bl	3f4d6 <_getpid_r>
   3f4aa:	462a      	mov	r2, r5
   3f4ac:	4601      	mov	r1, r0
   3f4ae:	4620      	mov	r0, r4
   3f4b0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   3f4b4:	f7fb b93a 	b.w	3a72c <_kill_r>
   3f4b8:	2b01      	cmp	r3, #1
   3f4ba:	d00a      	beq.n	3f4d2 <_raise_r+0x4c>
   3f4bc:	1c59      	adds	r1, r3, #1
   3f4be:	d103      	bne.n	3f4c8 <_raise_r+0x42>
   3f4c0:	2316      	movs	r3, #22
   3f4c2:	6003      	str	r3, [r0, #0]
   3f4c4:	2001      	movs	r0, #1
   3f4c6:	e7e7      	b.n	3f498 <_raise_r+0x12>
   3f4c8:	2400      	movs	r4, #0
   3f4ca:	4628      	mov	r0, r5
   3f4cc:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
   3f4d0:	4798      	blx	r3
   3f4d2:	2000      	movs	r0, #0
   3f4d4:	e7e0      	b.n	3f498 <_raise_r+0x12>

0003f4d6 <_getpid_r>:
   3f4d6:	f7fd bb1d 	b.w	3cb14 <_getpid>

0003f4da <__sread>:
   3f4da:	b510      	push	{r4, lr}
   3f4dc:	460c      	mov	r4, r1
   3f4de:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   3f4e2:	f7fb f997 	bl	3a814 <_read_r>
   3f4e6:	2800      	cmp	r0, #0
   3f4e8:	bfab      	itete	ge
   3f4ea:	6d63      	ldrge	r3, [r4, #84]	; 0x54
   3f4ec:	89a3      	ldrhlt	r3, [r4, #12]
   3f4ee:	181b      	addge	r3, r3, r0
   3f4f0:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
   3f4f4:	bfac      	ite	ge
   3f4f6:	6563      	strge	r3, [r4, #84]	; 0x54
   3f4f8:	81a3      	strhlt	r3, [r4, #12]
   3f4fa:	bd10      	pop	{r4, pc}

0003f4fc <__swrite>:
   3f4fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3f500:	461f      	mov	r7, r3
   3f502:	898b      	ldrh	r3, [r1, #12]
   3f504:	4605      	mov	r5, r0
   3f506:	460c      	mov	r4, r1
   3f508:	05db      	lsls	r3, r3, #23
   3f50a:	4616      	mov	r6, r2
   3f50c:	d505      	bpl.n	3f51a <__swrite+0x1e>
   3f50e:	2302      	movs	r3, #2
   3f510:	2200      	movs	r2, #0
   3f512:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   3f516:	f7fb f95f 	bl	3a7d8 <_lseek_r>
   3f51a:	89a3      	ldrh	r3, [r4, #12]
   3f51c:	4632      	mov	r2, r6
   3f51e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   3f522:	4628      	mov	r0, r5
   3f524:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   3f528:	81a3      	strh	r3, [r4, #12]
   3f52a:	463b      	mov	r3, r7
   3f52c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   3f530:	f7fb b90e 	b.w	3a750 <_write_r>

0003f534 <__sseek>:
   3f534:	b510      	push	{r4, lr}
   3f536:	460c      	mov	r4, r1
   3f538:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   3f53c:	f7fb f94c 	bl	3a7d8 <_lseek_r>
   3f540:	1c43      	adds	r3, r0, #1
   3f542:	89a3      	ldrh	r3, [r4, #12]
   3f544:	bf15      	itete	ne
   3f546:	6560      	strne	r0, [r4, #84]	; 0x54
   3f548:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   3f54c:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
   3f550:	81a3      	strheq	r3, [r4, #12]
   3f552:	bf18      	it	ne
   3f554:	81a3      	strhne	r3, [r4, #12]
   3f556:	bd10      	pop	{r4, pc}

0003f558 <__sclose>:
   3f558:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   3f55c:	f7fb b90a 	b.w	3a774 <_close_r>

0003f560 <__ascii_mbtowc>:
   3f560:	b082      	sub	sp, #8
   3f562:	b901      	cbnz	r1, 3f566 <__ascii_mbtowc+0x6>
   3f564:	a901      	add	r1, sp, #4
   3f566:	b142      	cbz	r2, 3f57a <__ascii_mbtowc+0x1a>
   3f568:	b14b      	cbz	r3, 3f57e <__ascii_mbtowc+0x1e>
   3f56a:	7813      	ldrb	r3, [r2, #0]
   3f56c:	600b      	str	r3, [r1, #0]
   3f56e:	7812      	ldrb	r2, [r2, #0]
   3f570:	1c10      	adds	r0, r2, #0
   3f572:	bf18      	it	ne
   3f574:	2001      	movne	r0, #1
   3f576:	b002      	add	sp, #8
   3f578:	4770      	bx	lr
   3f57a:	4610      	mov	r0, r2
   3f57c:	e7fb      	b.n	3f576 <__ascii_mbtowc+0x16>
   3f57e:	f06f 0001 	mvn.w	r0, #1
   3f582:	e7f8      	b.n	3f576 <__ascii_mbtowc+0x16>

0003f584 <_malloc_usable_size_r>:
   3f584:	f851 3c04 	ldr.w	r3, [r1, #-4]
   3f588:	1f18      	subs	r0, r3, #4
   3f58a:	2b00      	cmp	r3, #0
   3f58c:	bfbc      	itt	lt
   3f58e:	580b      	ldrlt	r3, [r1, r0]
   3f590:	18c0      	addlt	r0, r0, r3
   3f592:	4770      	bx	lr

0003f594 <__ascii_wctomb>:
   3f594:	b149      	cbz	r1, 3f5aa <__ascii_wctomb+0x16>
   3f596:	2aff      	cmp	r2, #255	; 0xff
   3f598:	bf8d      	iteet	hi
   3f59a:	238a      	movhi	r3, #138	; 0x8a
   3f59c:	700a      	strbls	r2, [r1, #0]
   3f59e:	2001      	movls	r0, #1
   3f5a0:	6003      	strhi	r3, [r0, #0]
   3f5a2:	bf88      	it	hi
   3f5a4:	f04f 30ff 	movhi.w	r0, #4294967295
   3f5a8:	4770      	bx	lr
   3f5aa:	4608      	mov	r0, r1
   3f5ac:	4770      	bx	lr
