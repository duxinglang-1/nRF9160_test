
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

0000c000 <_vector_table>:
    c000:	20035c18 	.word	0x20035c18
    c004:	00019321 	.word	0x00019321
    c008:	0002d5a1 	.word	0x0002d5a1
    c00c:	00018f7d 	.word	0x00018f7d
    c010:	00018f7d 	.word	0x00018f7d
    c014:	00018f7d 	.word	0x00018f7d
    c018:	00018f7d 	.word	0x00018f7d
    c01c:	00018f7d 	.word	0x00018f7d
    c020:	00018f7d 	.word	0x00018f7d
    c024:	00018f7d 	.word	0x00018f7d
    c028:	00018f7d 	.word	0x00018f7d
    c02c:	00018f45 	.word	0x00018f45
    c030:	00018f7d 	.word	0x00018f7d
    c034:	00018f7d 	.word	0x00018f7d
    c038:	00018e81 	.word	0x00018e81
    c03c:	000189b1 	.word	0x000189b1

0000c040 <_irq_vector_table>:
    c040:	00018f99 00018f99 00018f99 00018f99     ................
    c050:	00018f99 00018f99 00018f99 00018f99     ................
    c060:	00018f99 00018f99 00018f99 00018f99     ................
    c070:	00018f99 00018f99 00018f99 00018f99     ................
    c080:	00018f99 00018f99 00018f99 00018f99     ................
    c090:	00018f99 00018f99 00018f99 00018f99     ................
    c0a0:	00018f99 00018f99 00018f99 00018f99     ................
    c0b0:	0001b5fd 0002e41d 00018f99 00018f99     ................
    c0c0:	00018f99 00018f99 00018f99 00018f99     ................
    c0d0:	00018f99 00018f99 00018f99 00018f99     ................
    c0e0:	00018f99 00018f99 0002e43b 00018f99     ........;.......
    c0f0:	00018f99 00018f99 00018f99 00018f99     ................
    c100:	00018f99 00018f99 00018f99 00018f99     ................
    c110:	00018f99 00018f99 00018f99 00018f99     ................
    c120:	00018f99 00018f99 00018f99 00018f99     ................
    c130:	00018f99 00018f99 00018f99 00018f99     ................
    c140:	00018f99                                ....

0000c144 <_vector_end>:
	...

0000c200 <m_firmware_info>:
    c200:	281ee6de 8fcebb4c 00005b02 0000003c     ...(L....[..<...
    c210:	0002c6c0 00000001 0000c000 0000c000     ................
    c220:	9102ffff 00000000 00000000 00000000     ................
	...

Disassembly of section text:

0000c240 <__aeabi_drsub>:
    c240:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    c244:	e002      	b.n	c24c <__adddf3>
    c246:	bf00      	nop

0000c248 <__aeabi_dsub>:
    c248:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0000c24c <__adddf3>:
    c24c:	b530      	push	{r4, r5, lr}
    c24e:	ea4f 0441 	mov.w	r4, r1, lsl #1
    c252:	ea4f 0543 	mov.w	r5, r3, lsl #1
    c256:	ea94 0f05 	teq	r4, r5
    c25a:	bf08      	it	eq
    c25c:	ea90 0f02 	teqeq	r0, r2
    c260:	bf1f      	itttt	ne
    c262:	ea54 0c00 	orrsne.w	ip, r4, r0
    c266:	ea55 0c02 	orrsne.w	ip, r5, r2
    c26a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    c26e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    c272:	f000 80e2 	beq.w	c43a <__adddf3+0x1ee>
    c276:	ea4f 5454 	mov.w	r4, r4, lsr #21
    c27a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    c27e:	bfb8      	it	lt
    c280:	426d      	neglt	r5, r5
    c282:	dd0c      	ble.n	c29e <__adddf3+0x52>
    c284:	442c      	add	r4, r5
    c286:	ea80 0202 	eor.w	r2, r0, r2
    c28a:	ea81 0303 	eor.w	r3, r1, r3
    c28e:	ea82 0000 	eor.w	r0, r2, r0
    c292:	ea83 0101 	eor.w	r1, r3, r1
    c296:	ea80 0202 	eor.w	r2, r0, r2
    c29a:	ea81 0303 	eor.w	r3, r1, r3
    c29e:	2d36      	cmp	r5, #54	; 0x36
    c2a0:	bf88      	it	hi
    c2a2:	bd30      	pophi	{r4, r5, pc}
    c2a4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    c2a8:	ea4f 3101 	mov.w	r1, r1, lsl #12
    c2ac:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    c2b0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    c2b4:	d002      	beq.n	c2bc <__adddf3+0x70>
    c2b6:	4240      	negs	r0, r0
    c2b8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c2bc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    c2c0:	ea4f 3303 	mov.w	r3, r3, lsl #12
    c2c4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    c2c8:	d002      	beq.n	c2d0 <__adddf3+0x84>
    c2ca:	4252      	negs	r2, r2
    c2cc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c2d0:	ea94 0f05 	teq	r4, r5
    c2d4:	f000 80a7 	beq.w	c426 <__adddf3+0x1da>
    c2d8:	f1a4 0401 	sub.w	r4, r4, #1
    c2dc:	f1d5 0e20 	rsbs	lr, r5, #32
    c2e0:	db0d      	blt.n	c2fe <__adddf3+0xb2>
    c2e2:	fa02 fc0e 	lsl.w	ip, r2, lr
    c2e6:	fa22 f205 	lsr.w	r2, r2, r5
    c2ea:	1880      	adds	r0, r0, r2
    c2ec:	f141 0100 	adc.w	r1, r1, #0
    c2f0:	fa03 f20e 	lsl.w	r2, r3, lr
    c2f4:	1880      	adds	r0, r0, r2
    c2f6:	fa43 f305 	asr.w	r3, r3, r5
    c2fa:	4159      	adcs	r1, r3
    c2fc:	e00e      	b.n	c31c <__adddf3+0xd0>
    c2fe:	f1a5 0520 	sub.w	r5, r5, #32
    c302:	f10e 0e20 	add.w	lr, lr, #32
    c306:	2a01      	cmp	r2, #1
    c308:	fa03 fc0e 	lsl.w	ip, r3, lr
    c30c:	bf28      	it	cs
    c30e:	f04c 0c02 	orrcs.w	ip, ip, #2
    c312:	fa43 f305 	asr.w	r3, r3, r5
    c316:	18c0      	adds	r0, r0, r3
    c318:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    c31c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c320:	d507      	bpl.n	c332 <__adddf3+0xe6>
    c322:	f04f 0e00 	mov.w	lr, #0
    c326:	f1dc 0c00 	rsbs	ip, ip, #0
    c32a:	eb7e 0000 	sbcs.w	r0, lr, r0
    c32e:	eb6e 0101 	sbc.w	r1, lr, r1
    c332:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    c336:	d31b      	bcc.n	c370 <__adddf3+0x124>
    c338:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    c33c:	d30c      	bcc.n	c358 <__adddf3+0x10c>
    c33e:	0849      	lsrs	r1, r1, #1
    c340:	ea5f 0030 	movs.w	r0, r0, rrx
    c344:	ea4f 0c3c 	mov.w	ip, ip, rrx
    c348:	f104 0401 	add.w	r4, r4, #1
    c34c:	ea4f 5244 	mov.w	r2, r4, lsl #21
    c350:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    c354:	f080 809a 	bcs.w	c48c <__adddf3+0x240>
    c358:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    c35c:	bf08      	it	eq
    c35e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    c362:	f150 0000 	adcs.w	r0, r0, #0
    c366:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    c36a:	ea41 0105 	orr.w	r1, r1, r5
    c36e:	bd30      	pop	{r4, r5, pc}
    c370:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    c374:	4140      	adcs	r0, r0
    c376:	eb41 0101 	adc.w	r1, r1, r1
    c37a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c37e:	f1a4 0401 	sub.w	r4, r4, #1
    c382:	d1e9      	bne.n	c358 <__adddf3+0x10c>
    c384:	f091 0f00 	teq	r1, #0
    c388:	bf04      	itt	eq
    c38a:	4601      	moveq	r1, r0
    c38c:	2000      	moveq	r0, #0
    c38e:	fab1 f381 	clz	r3, r1
    c392:	bf08      	it	eq
    c394:	3320      	addeq	r3, #32
    c396:	f1a3 030b 	sub.w	r3, r3, #11
    c39a:	f1b3 0220 	subs.w	r2, r3, #32
    c39e:	da0c      	bge.n	c3ba <__adddf3+0x16e>
    c3a0:	320c      	adds	r2, #12
    c3a2:	dd08      	ble.n	c3b6 <__adddf3+0x16a>
    c3a4:	f102 0c14 	add.w	ip, r2, #20
    c3a8:	f1c2 020c 	rsb	r2, r2, #12
    c3ac:	fa01 f00c 	lsl.w	r0, r1, ip
    c3b0:	fa21 f102 	lsr.w	r1, r1, r2
    c3b4:	e00c      	b.n	c3d0 <__adddf3+0x184>
    c3b6:	f102 0214 	add.w	r2, r2, #20
    c3ba:	bfd8      	it	le
    c3bc:	f1c2 0c20 	rsble	ip, r2, #32
    c3c0:	fa01 f102 	lsl.w	r1, r1, r2
    c3c4:	fa20 fc0c 	lsr.w	ip, r0, ip
    c3c8:	bfdc      	itt	le
    c3ca:	ea41 010c 	orrle.w	r1, r1, ip
    c3ce:	4090      	lslle	r0, r2
    c3d0:	1ae4      	subs	r4, r4, r3
    c3d2:	bfa2      	ittt	ge
    c3d4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    c3d8:	4329      	orrge	r1, r5
    c3da:	bd30      	popge	{r4, r5, pc}
    c3dc:	ea6f 0404 	mvn.w	r4, r4
    c3e0:	3c1f      	subs	r4, #31
    c3e2:	da1c      	bge.n	c41e <__adddf3+0x1d2>
    c3e4:	340c      	adds	r4, #12
    c3e6:	dc0e      	bgt.n	c406 <__adddf3+0x1ba>
    c3e8:	f104 0414 	add.w	r4, r4, #20
    c3ec:	f1c4 0220 	rsb	r2, r4, #32
    c3f0:	fa20 f004 	lsr.w	r0, r0, r4
    c3f4:	fa01 f302 	lsl.w	r3, r1, r2
    c3f8:	ea40 0003 	orr.w	r0, r0, r3
    c3fc:	fa21 f304 	lsr.w	r3, r1, r4
    c400:	ea45 0103 	orr.w	r1, r5, r3
    c404:	bd30      	pop	{r4, r5, pc}
    c406:	f1c4 040c 	rsb	r4, r4, #12
    c40a:	f1c4 0220 	rsb	r2, r4, #32
    c40e:	fa20 f002 	lsr.w	r0, r0, r2
    c412:	fa01 f304 	lsl.w	r3, r1, r4
    c416:	ea40 0003 	orr.w	r0, r0, r3
    c41a:	4629      	mov	r1, r5
    c41c:	bd30      	pop	{r4, r5, pc}
    c41e:	fa21 f004 	lsr.w	r0, r1, r4
    c422:	4629      	mov	r1, r5
    c424:	bd30      	pop	{r4, r5, pc}
    c426:	f094 0f00 	teq	r4, #0
    c42a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    c42e:	bf06      	itte	eq
    c430:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    c434:	3401      	addeq	r4, #1
    c436:	3d01      	subne	r5, #1
    c438:	e74e      	b.n	c2d8 <__adddf3+0x8c>
    c43a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    c43e:	bf18      	it	ne
    c440:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    c444:	d029      	beq.n	c49a <__adddf3+0x24e>
    c446:	ea94 0f05 	teq	r4, r5
    c44a:	bf08      	it	eq
    c44c:	ea90 0f02 	teqeq	r0, r2
    c450:	d005      	beq.n	c45e <__adddf3+0x212>
    c452:	ea54 0c00 	orrs.w	ip, r4, r0
    c456:	bf04      	itt	eq
    c458:	4619      	moveq	r1, r3
    c45a:	4610      	moveq	r0, r2
    c45c:	bd30      	pop	{r4, r5, pc}
    c45e:	ea91 0f03 	teq	r1, r3
    c462:	bf1e      	ittt	ne
    c464:	2100      	movne	r1, #0
    c466:	2000      	movne	r0, #0
    c468:	bd30      	popne	{r4, r5, pc}
    c46a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    c46e:	d105      	bne.n	c47c <__adddf3+0x230>
    c470:	0040      	lsls	r0, r0, #1
    c472:	4149      	adcs	r1, r1
    c474:	bf28      	it	cs
    c476:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    c47a:	bd30      	pop	{r4, r5, pc}
    c47c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    c480:	bf3c      	itt	cc
    c482:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    c486:	bd30      	popcc	{r4, r5, pc}
    c488:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c48c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    c490:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    c494:	f04f 0000 	mov.w	r0, #0
    c498:	bd30      	pop	{r4, r5, pc}
    c49a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    c49e:	bf1a      	itte	ne
    c4a0:	4619      	movne	r1, r3
    c4a2:	4610      	movne	r0, r2
    c4a4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    c4a8:	bf1c      	itt	ne
    c4aa:	460b      	movne	r3, r1
    c4ac:	4602      	movne	r2, r0
    c4ae:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    c4b2:	bf06      	itte	eq
    c4b4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    c4b8:	ea91 0f03 	teqeq	r1, r3
    c4bc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    c4c0:	bd30      	pop	{r4, r5, pc}
    c4c2:	bf00      	nop

0000c4c4 <__aeabi_ui2d>:
    c4c4:	f090 0f00 	teq	r0, #0
    c4c8:	bf04      	itt	eq
    c4ca:	2100      	moveq	r1, #0
    c4cc:	4770      	bxeq	lr
    c4ce:	b530      	push	{r4, r5, lr}
    c4d0:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c4d4:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c4d8:	f04f 0500 	mov.w	r5, #0
    c4dc:	f04f 0100 	mov.w	r1, #0
    c4e0:	e750      	b.n	c384 <__adddf3+0x138>
    c4e2:	bf00      	nop

0000c4e4 <__aeabi_i2d>:
    c4e4:	f090 0f00 	teq	r0, #0
    c4e8:	bf04      	itt	eq
    c4ea:	2100      	moveq	r1, #0
    c4ec:	4770      	bxeq	lr
    c4ee:	b530      	push	{r4, r5, lr}
    c4f0:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c4f4:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c4f8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    c4fc:	bf48      	it	mi
    c4fe:	4240      	negmi	r0, r0
    c500:	f04f 0100 	mov.w	r1, #0
    c504:	e73e      	b.n	c384 <__adddf3+0x138>
    c506:	bf00      	nop

0000c508 <__aeabi_f2d>:
    c508:	0042      	lsls	r2, r0, #1
    c50a:	ea4f 01e2 	mov.w	r1, r2, asr #3
    c50e:	ea4f 0131 	mov.w	r1, r1, rrx
    c512:	ea4f 7002 	mov.w	r0, r2, lsl #28
    c516:	bf1f      	itttt	ne
    c518:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    c51c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    c520:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    c524:	4770      	bxne	lr
    c526:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
    c52a:	bf08      	it	eq
    c52c:	4770      	bxeq	lr
    c52e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
    c532:	bf04      	itt	eq
    c534:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
    c538:	4770      	bxeq	lr
    c53a:	b530      	push	{r4, r5, lr}
    c53c:	f44f 7460 	mov.w	r4, #896	; 0x380
    c540:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c544:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    c548:	e71c      	b.n	c384 <__adddf3+0x138>
    c54a:	bf00      	nop

0000c54c <__aeabi_ul2d>:
    c54c:	ea50 0201 	orrs.w	r2, r0, r1
    c550:	bf08      	it	eq
    c552:	4770      	bxeq	lr
    c554:	b530      	push	{r4, r5, lr}
    c556:	f04f 0500 	mov.w	r5, #0
    c55a:	e00a      	b.n	c572 <__aeabi_l2d+0x16>

0000c55c <__aeabi_l2d>:
    c55c:	ea50 0201 	orrs.w	r2, r0, r1
    c560:	bf08      	it	eq
    c562:	4770      	bxeq	lr
    c564:	b530      	push	{r4, r5, lr}
    c566:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    c56a:	d502      	bpl.n	c572 <__aeabi_l2d+0x16>
    c56c:	4240      	negs	r0, r0
    c56e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c572:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c576:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c57a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    c57e:	f43f aed8 	beq.w	c332 <__adddf3+0xe6>
    c582:	f04f 0203 	mov.w	r2, #3
    c586:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    c58a:	bf18      	it	ne
    c58c:	3203      	addne	r2, #3
    c58e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    c592:	bf18      	it	ne
    c594:	3203      	addne	r2, #3
    c596:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    c59a:	f1c2 0320 	rsb	r3, r2, #32
    c59e:	fa00 fc03 	lsl.w	ip, r0, r3
    c5a2:	fa20 f002 	lsr.w	r0, r0, r2
    c5a6:	fa01 fe03 	lsl.w	lr, r1, r3
    c5aa:	ea40 000e 	orr.w	r0, r0, lr
    c5ae:	fa21 f102 	lsr.w	r1, r1, r2
    c5b2:	4414      	add	r4, r2
    c5b4:	e6bd      	b.n	c332 <__adddf3+0xe6>
    c5b6:	bf00      	nop

0000c5b8 <__aeabi_dmul>:
    c5b8:	b570      	push	{r4, r5, r6, lr}
    c5ba:	f04f 0cff 	mov.w	ip, #255	; 0xff
    c5be:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    c5c2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    c5c6:	bf1d      	ittte	ne
    c5c8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    c5cc:	ea94 0f0c 	teqne	r4, ip
    c5d0:	ea95 0f0c 	teqne	r5, ip
    c5d4:	f000 f8de 	bleq	c794 <__aeabi_dmul+0x1dc>
    c5d8:	442c      	add	r4, r5
    c5da:	ea81 0603 	eor.w	r6, r1, r3
    c5de:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    c5e2:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    c5e6:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    c5ea:	bf18      	it	ne
    c5ec:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    c5f0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c5f4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    c5f8:	d038      	beq.n	c66c <__aeabi_dmul+0xb4>
    c5fa:	fba0 ce02 	umull	ip, lr, r0, r2
    c5fe:	f04f 0500 	mov.w	r5, #0
    c602:	fbe1 e502 	umlal	lr, r5, r1, r2
    c606:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    c60a:	fbe0 e503 	umlal	lr, r5, r0, r3
    c60e:	f04f 0600 	mov.w	r6, #0
    c612:	fbe1 5603 	umlal	r5, r6, r1, r3
    c616:	f09c 0f00 	teq	ip, #0
    c61a:	bf18      	it	ne
    c61c:	f04e 0e01 	orrne.w	lr, lr, #1
    c620:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    c624:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    c628:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    c62c:	d204      	bcs.n	c638 <__aeabi_dmul+0x80>
    c62e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    c632:	416d      	adcs	r5, r5
    c634:	eb46 0606 	adc.w	r6, r6, r6
    c638:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    c63c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    c640:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    c644:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    c648:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    c64c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    c650:	bf88      	it	hi
    c652:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    c656:	d81e      	bhi.n	c696 <__aeabi_dmul+0xde>
    c658:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    c65c:	bf08      	it	eq
    c65e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    c662:	f150 0000 	adcs.w	r0, r0, #0
    c666:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    c66a:	bd70      	pop	{r4, r5, r6, pc}
    c66c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    c670:	ea46 0101 	orr.w	r1, r6, r1
    c674:	ea40 0002 	orr.w	r0, r0, r2
    c678:	ea81 0103 	eor.w	r1, r1, r3
    c67c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    c680:	bfc2      	ittt	gt
    c682:	ebd4 050c 	rsbsgt	r5, r4, ip
    c686:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    c68a:	bd70      	popgt	{r4, r5, r6, pc}
    c68c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c690:	f04f 0e00 	mov.w	lr, #0
    c694:	3c01      	subs	r4, #1
    c696:	f300 80ab 	bgt.w	c7f0 <__aeabi_dmul+0x238>
    c69a:	f114 0f36 	cmn.w	r4, #54	; 0x36
    c69e:	bfde      	ittt	le
    c6a0:	2000      	movle	r0, #0
    c6a2:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    c6a6:	bd70      	pople	{r4, r5, r6, pc}
    c6a8:	f1c4 0400 	rsb	r4, r4, #0
    c6ac:	3c20      	subs	r4, #32
    c6ae:	da35      	bge.n	c71c <__aeabi_dmul+0x164>
    c6b0:	340c      	adds	r4, #12
    c6b2:	dc1b      	bgt.n	c6ec <__aeabi_dmul+0x134>
    c6b4:	f104 0414 	add.w	r4, r4, #20
    c6b8:	f1c4 0520 	rsb	r5, r4, #32
    c6bc:	fa00 f305 	lsl.w	r3, r0, r5
    c6c0:	fa20 f004 	lsr.w	r0, r0, r4
    c6c4:	fa01 f205 	lsl.w	r2, r1, r5
    c6c8:	ea40 0002 	orr.w	r0, r0, r2
    c6cc:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    c6d0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    c6d4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    c6d8:	fa21 f604 	lsr.w	r6, r1, r4
    c6dc:	eb42 0106 	adc.w	r1, r2, r6
    c6e0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    c6e4:	bf08      	it	eq
    c6e6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    c6ea:	bd70      	pop	{r4, r5, r6, pc}
    c6ec:	f1c4 040c 	rsb	r4, r4, #12
    c6f0:	f1c4 0520 	rsb	r5, r4, #32
    c6f4:	fa00 f304 	lsl.w	r3, r0, r4
    c6f8:	fa20 f005 	lsr.w	r0, r0, r5
    c6fc:	fa01 f204 	lsl.w	r2, r1, r4
    c700:	ea40 0002 	orr.w	r0, r0, r2
    c704:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c708:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    c70c:	f141 0100 	adc.w	r1, r1, #0
    c710:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    c714:	bf08      	it	eq
    c716:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    c71a:	bd70      	pop	{r4, r5, r6, pc}
    c71c:	f1c4 0520 	rsb	r5, r4, #32
    c720:	fa00 f205 	lsl.w	r2, r0, r5
    c724:	ea4e 0e02 	orr.w	lr, lr, r2
    c728:	fa20 f304 	lsr.w	r3, r0, r4
    c72c:	fa01 f205 	lsl.w	r2, r1, r5
    c730:	ea43 0302 	orr.w	r3, r3, r2
    c734:	fa21 f004 	lsr.w	r0, r1, r4
    c738:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c73c:	fa21 f204 	lsr.w	r2, r1, r4
    c740:	ea20 0002 	bic.w	r0, r0, r2
    c744:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    c748:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    c74c:	bf08      	it	eq
    c74e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    c752:	bd70      	pop	{r4, r5, r6, pc}
    c754:	f094 0f00 	teq	r4, #0
    c758:	d10f      	bne.n	c77a <__aeabi_dmul+0x1c2>
    c75a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    c75e:	0040      	lsls	r0, r0, #1
    c760:	eb41 0101 	adc.w	r1, r1, r1
    c764:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c768:	bf08      	it	eq
    c76a:	3c01      	subeq	r4, #1
    c76c:	d0f7      	beq.n	c75e <__aeabi_dmul+0x1a6>
    c76e:	ea41 0106 	orr.w	r1, r1, r6
    c772:	f095 0f00 	teq	r5, #0
    c776:	bf18      	it	ne
    c778:	4770      	bxne	lr
    c77a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    c77e:	0052      	lsls	r2, r2, #1
    c780:	eb43 0303 	adc.w	r3, r3, r3
    c784:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    c788:	bf08      	it	eq
    c78a:	3d01      	subeq	r5, #1
    c78c:	d0f7      	beq.n	c77e <__aeabi_dmul+0x1c6>
    c78e:	ea43 0306 	orr.w	r3, r3, r6
    c792:	4770      	bx	lr
    c794:	ea94 0f0c 	teq	r4, ip
    c798:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    c79c:	bf18      	it	ne
    c79e:	ea95 0f0c 	teqne	r5, ip
    c7a2:	d00c      	beq.n	c7be <__aeabi_dmul+0x206>
    c7a4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    c7a8:	bf18      	it	ne
    c7aa:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    c7ae:	d1d1      	bne.n	c754 <__aeabi_dmul+0x19c>
    c7b0:	ea81 0103 	eor.w	r1, r1, r3
    c7b4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c7b8:	f04f 0000 	mov.w	r0, #0
    c7bc:	bd70      	pop	{r4, r5, r6, pc}
    c7be:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    c7c2:	bf06      	itte	eq
    c7c4:	4610      	moveq	r0, r2
    c7c6:	4619      	moveq	r1, r3
    c7c8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    c7cc:	d019      	beq.n	c802 <__aeabi_dmul+0x24a>
    c7ce:	ea94 0f0c 	teq	r4, ip
    c7d2:	d102      	bne.n	c7da <__aeabi_dmul+0x222>
    c7d4:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    c7d8:	d113      	bne.n	c802 <__aeabi_dmul+0x24a>
    c7da:	ea95 0f0c 	teq	r5, ip
    c7de:	d105      	bne.n	c7ec <__aeabi_dmul+0x234>
    c7e0:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    c7e4:	bf1c      	itt	ne
    c7e6:	4610      	movne	r0, r2
    c7e8:	4619      	movne	r1, r3
    c7ea:	d10a      	bne.n	c802 <__aeabi_dmul+0x24a>
    c7ec:	ea81 0103 	eor.w	r1, r1, r3
    c7f0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c7f4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    c7f8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    c7fc:	f04f 0000 	mov.w	r0, #0
    c800:	bd70      	pop	{r4, r5, r6, pc}
    c802:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    c806:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    c80a:	bd70      	pop	{r4, r5, r6, pc}

0000c80c <__aeabi_ddiv>:
    c80c:	b570      	push	{r4, r5, r6, lr}
    c80e:	f04f 0cff 	mov.w	ip, #255	; 0xff
    c812:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    c816:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    c81a:	bf1d      	ittte	ne
    c81c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    c820:	ea94 0f0c 	teqne	r4, ip
    c824:	ea95 0f0c 	teqne	r5, ip
    c828:	f000 f8a7 	bleq	c97a <__aeabi_ddiv+0x16e>
    c82c:	eba4 0405 	sub.w	r4, r4, r5
    c830:	ea81 0e03 	eor.w	lr, r1, r3
    c834:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    c838:	ea4f 3101 	mov.w	r1, r1, lsl #12
    c83c:	f000 8088 	beq.w	c950 <__aeabi_ddiv+0x144>
    c840:	ea4f 3303 	mov.w	r3, r3, lsl #12
    c844:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    c848:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    c84c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    c850:	ea4f 2202 	mov.w	r2, r2, lsl #8
    c854:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    c858:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    c85c:	ea4f 2600 	mov.w	r6, r0, lsl #8
    c860:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    c864:	429d      	cmp	r5, r3
    c866:	bf08      	it	eq
    c868:	4296      	cmpeq	r6, r2
    c86a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    c86e:	f504 7440 	add.w	r4, r4, #768	; 0x300
    c872:	d202      	bcs.n	c87a <__aeabi_ddiv+0x6e>
    c874:	085b      	lsrs	r3, r3, #1
    c876:	ea4f 0232 	mov.w	r2, r2, rrx
    c87a:	1ab6      	subs	r6, r6, r2
    c87c:	eb65 0503 	sbc.w	r5, r5, r3
    c880:	085b      	lsrs	r3, r3, #1
    c882:	ea4f 0232 	mov.w	r2, r2, rrx
    c886:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    c88a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    c88e:	ebb6 0e02 	subs.w	lr, r6, r2
    c892:	eb75 0e03 	sbcs.w	lr, r5, r3
    c896:	bf22      	ittt	cs
    c898:	1ab6      	subcs	r6, r6, r2
    c89a:	4675      	movcs	r5, lr
    c89c:	ea40 000c 	orrcs.w	r0, r0, ip
    c8a0:	085b      	lsrs	r3, r3, #1
    c8a2:	ea4f 0232 	mov.w	r2, r2, rrx
    c8a6:	ebb6 0e02 	subs.w	lr, r6, r2
    c8aa:	eb75 0e03 	sbcs.w	lr, r5, r3
    c8ae:	bf22      	ittt	cs
    c8b0:	1ab6      	subcs	r6, r6, r2
    c8b2:	4675      	movcs	r5, lr
    c8b4:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    c8b8:	085b      	lsrs	r3, r3, #1
    c8ba:	ea4f 0232 	mov.w	r2, r2, rrx
    c8be:	ebb6 0e02 	subs.w	lr, r6, r2
    c8c2:	eb75 0e03 	sbcs.w	lr, r5, r3
    c8c6:	bf22      	ittt	cs
    c8c8:	1ab6      	subcs	r6, r6, r2
    c8ca:	4675      	movcs	r5, lr
    c8cc:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    c8d0:	085b      	lsrs	r3, r3, #1
    c8d2:	ea4f 0232 	mov.w	r2, r2, rrx
    c8d6:	ebb6 0e02 	subs.w	lr, r6, r2
    c8da:	eb75 0e03 	sbcs.w	lr, r5, r3
    c8de:	bf22      	ittt	cs
    c8e0:	1ab6      	subcs	r6, r6, r2
    c8e2:	4675      	movcs	r5, lr
    c8e4:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    c8e8:	ea55 0e06 	orrs.w	lr, r5, r6
    c8ec:	d018      	beq.n	c920 <__aeabi_ddiv+0x114>
    c8ee:	ea4f 1505 	mov.w	r5, r5, lsl #4
    c8f2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    c8f6:	ea4f 1606 	mov.w	r6, r6, lsl #4
    c8fa:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    c8fe:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    c902:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    c906:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    c90a:	d1c0      	bne.n	c88e <__aeabi_ddiv+0x82>
    c90c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c910:	d10b      	bne.n	c92a <__aeabi_ddiv+0x11e>
    c912:	ea41 0100 	orr.w	r1, r1, r0
    c916:	f04f 0000 	mov.w	r0, #0
    c91a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    c91e:	e7b6      	b.n	c88e <__aeabi_ddiv+0x82>
    c920:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c924:	bf04      	itt	eq
    c926:	4301      	orreq	r1, r0
    c928:	2000      	moveq	r0, #0
    c92a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    c92e:	bf88      	it	hi
    c930:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    c934:	f63f aeaf 	bhi.w	c696 <__aeabi_dmul+0xde>
    c938:	ebb5 0c03 	subs.w	ip, r5, r3
    c93c:	bf04      	itt	eq
    c93e:	ebb6 0c02 	subseq.w	ip, r6, r2
    c942:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    c946:	f150 0000 	adcs.w	r0, r0, #0
    c94a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    c94e:	bd70      	pop	{r4, r5, r6, pc}
    c950:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    c954:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    c958:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    c95c:	bfc2      	ittt	gt
    c95e:	ebd4 050c 	rsbsgt	r5, r4, ip
    c962:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    c966:	bd70      	popgt	{r4, r5, r6, pc}
    c968:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c96c:	f04f 0e00 	mov.w	lr, #0
    c970:	3c01      	subs	r4, #1
    c972:	e690      	b.n	c696 <__aeabi_dmul+0xde>
    c974:	ea45 0e06 	orr.w	lr, r5, r6
    c978:	e68d      	b.n	c696 <__aeabi_dmul+0xde>
    c97a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    c97e:	ea94 0f0c 	teq	r4, ip
    c982:	bf08      	it	eq
    c984:	ea95 0f0c 	teqeq	r5, ip
    c988:	f43f af3b 	beq.w	c802 <__aeabi_dmul+0x24a>
    c98c:	ea94 0f0c 	teq	r4, ip
    c990:	d10a      	bne.n	c9a8 <__aeabi_ddiv+0x19c>
    c992:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    c996:	f47f af34 	bne.w	c802 <__aeabi_dmul+0x24a>
    c99a:	ea95 0f0c 	teq	r5, ip
    c99e:	f47f af25 	bne.w	c7ec <__aeabi_dmul+0x234>
    c9a2:	4610      	mov	r0, r2
    c9a4:	4619      	mov	r1, r3
    c9a6:	e72c      	b.n	c802 <__aeabi_dmul+0x24a>
    c9a8:	ea95 0f0c 	teq	r5, ip
    c9ac:	d106      	bne.n	c9bc <__aeabi_ddiv+0x1b0>
    c9ae:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    c9b2:	f43f aefd 	beq.w	c7b0 <__aeabi_dmul+0x1f8>
    c9b6:	4610      	mov	r0, r2
    c9b8:	4619      	mov	r1, r3
    c9ba:	e722      	b.n	c802 <__aeabi_dmul+0x24a>
    c9bc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    c9c0:	bf18      	it	ne
    c9c2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    c9c6:	f47f aec5 	bne.w	c754 <__aeabi_dmul+0x19c>
    c9ca:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    c9ce:	f47f af0d 	bne.w	c7ec <__aeabi_dmul+0x234>
    c9d2:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    c9d6:	f47f aeeb 	bne.w	c7b0 <__aeabi_dmul+0x1f8>
    c9da:	e712      	b.n	c802 <__aeabi_dmul+0x24a>

0000c9dc <__gedf2>:
    c9dc:	f04f 3cff 	mov.w	ip, #4294967295
    c9e0:	e006      	b.n	c9f0 <__cmpdf2+0x4>
    c9e2:	bf00      	nop

0000c9e4 <__ledf2>:
    c9e4:	f04f 0c01 	mov.w	ip, #1
    c9e8:	e002      	b.n	c9f0 <__cmpdf2+0x4>
    c9ea:	bf00      	nop

0000c9ec <__cmpdf2>:
    c9ec:	f04f 0c01 	mov.w	ip, #1
    c9f0:	f84d cd04 	str.w	ip, [sp, #-4]!
    c9f4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    c9f8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    c9fc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    ca00:	bf18      	it	ne
    ca02:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
    ca06:	d01b      	beq.n	ca40 <__cmpdf2+0x54>
    ca08:	b001      	add	sp, #4
    ca0a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
    ca0e:	bf0c      	ite	eq
    ca10:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
    ca14:	ea91 0f03 	teqne	r1, r3
    ca18:	bf02      	ittt	eq
    ca1a:	ea90 0f02 	teqeq	r0, r2
    ca1e:	2000      	moveq	r0, #0
    ca20:	4770      	bxeq	lr
    ca22:	f110 0f00 	cmn.w	r0, #0
    ca26:	ea91 0f03 	teq	r1, r3
    ca2a:	bf58      	it	pl
    ca2c:	4299      	cmppl	r1, r3
    ca2e:	bf08      	it	eq
    ca30:	4290      	cmpeq	r0, r2
    ca32:	bf2c      	ite	cs
    ca34:	17d8      	asrcs	r0, r3, #31
    ca36:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
    ca3a:	f040 0001 	orr.w	r0, r0, #1
    ca3e:	4770      	bx	lr
    ca40:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    ca44:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    ca48:	d102      	bne.n	ca50 <__cmpdf2+0x64>
    ca4a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    ca4e:	d107      	bne.n	ca60 <__cmpdf2+0x74>
    ca50:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    ca54:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    ca58:	d1d6      	bne.n	ca08 <__cmpdf2+0x1c>
    ca5a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    ca5e:	d0d3      	beq.n	ca08 <__cmpdf2+0x1c>
    ca60:	f85d 0b04 	ldr.w	r0, [sp], #4
    ca64:	4770      	bx	lr
    ca66:	bf00      	nop

0000ca68 <__aeabi_cdrcmple>:
    ca68:	4684      	mov	ip, r0
    ca6a:	4610      	mov	r0, r2
    ca6c:	4662      	mov	r2, ip
    ca6e:	468c      	mov	ip, r1
    ca70:	4619      	mov	r1, r3
    ca72:	4663      	mov	r3, ip
    ca74:	e000      	b.n	ca78 <__aeabi_cdcmpeq>
    ca76:	bf00      	nop

0000ca78 <__aeabi_cdcmpeq>:
    ca78:	b501      	push	{r0, lr}
    ca7a:	f7ff ffb7 	bl	c9ec <__cmpdf2>
    ca7e:	2800      	cmp	r0, #0
    ca80:	bf48      	it	mi
    ca82:	f110 0f00 	cmnmi.w	r0, #0
    ca86:	bd01      	pop	{r0, pc}

0000ca88 <__aeabi_dcmpeq>:
    ca88:	f84d ed08 	str.w	lr, [sp, #-8]!
    ca8c:	f7ff fff4 	bl	ca78 <__aeabi_cdcmpeq>
    ca90:	bf0c      	ite	eq
    ca92:	2001      	moveq	r0, #1
    ca94:	2000      	movne	r0, #0
    ca96:	f85d fb08 	ldr.w	pc, [sp], #8
    ca9a:	bf00      	nop

0000ca9c <__aeabi_dcmplt>:
    ca9c:	f84d ed08 	str.w	lr, [sp, #-8]!
    caa0:	f7ff ffea 	bl	ca78 <__aeabi_cdcmpeq>
    caa4:	bf34      	ite	cc
    caa6:	2001      	movcc	r0, #1
    caa8:	2000      	movcs	r0, #0
    caaa:	f85d fb08 	ldr.w	pc, [sp], #8
    caae:	bf00      	nop

0000cab0 <__aeabi_dcmple>:
    cab0:	f84d ed08 	str.w	lr, [sp, #-8]!
    cab4:	f7ff ffe0 	bl	ca78 <__aeabi_cdcmpeq>
    cab8:	bf94      	ite	ls
    caba:	2001      	movls	r0, #1
    cabc:	2000      	movhi	r0, #0
    cabe:	f85d fb08 	ldr.w	pc, [sp], #8
    cac2:	bf00      	nop

0000cac4 <__aeabi_dcmpge>:
    cac4:	f84d ed08 	str.w	lr, [sp, #-8]!
    cac8:	f7ff ffce 	bl	ca68 <__aeabi_cdrcmple>
    cacc:	bf94      	ite	ls
    cace:	2001      	movls	r0, #1
    cad0:	2000      	movhi	r0, #0
    cad2:	f85d fb08 	ldr.w	pc, [sp], #8
    cad6:	bf00      	nop

0000cad8 <__aeabi_dcmpgt>:
    cad8:	f84d ed08 	str.w	lr, [sp, #-8]!
    cadc:	f7ff ffc4 	bl	ca68 <__aeabi_cdrcmple>
    cae0:	bf34      	ite	cc
    cae2:	2001      	movcc	r0, #1
    cae4:	2000      	movcs	r0, #0
    cae6:	f85d fb08 	ldr.w	pc, [sp], #8
    caea:	bf00      	nop

0000caec <__aeabi_d2uiz>:
    caec:	004a      	lsls	r2, r1, #1
    caee:	d211      	bcs.n	cb14 <__aeabi_d2uiz+0x28>
    caf0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    caf4:	d211      	bcs.n	cb1a <__aeabi_d2uiz+0x2e>
    caf6:	d50d      	bpl.n	cb14 <__aeabi_d2uiz+0x28>
    caf8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    cafc:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    cb00:	d40e      	bmi.n	cb20 <__aeabi_d2uiz+0x34>
    cb02:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    cb06:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    cb0a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    cb0e:	fa23 f002 	lsr.w	r0, r3, r2
    cb12:	4770      	bx	lr
    cb14:	f04f 0000 	mov.w	r0, #0
    cb18:	4770      	bx	lr
    cb1a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    cb1e:	d102      	bne.n	cb26 <__aeabi_d2uiz+0x3a>
    cb20:	f04f 30ff 	mov.w	r0, #4294967295
    cb24:	4770      	bx	lr
    cb26:	f04f 0000 	mov.w	r0, #0
    cb2a:	4770      	bx	lr

0000cb2c <__aeabi_d2f>:
    cb2c:	ea4f 0241 	mov.w	r2, r1, lsl #1
    cb30:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    cb34:	bf24      	itt	cs
    cb36:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    cb3a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    cb3e:	d90d      	bls.n	cb5c <__aeabi_d2f+0x30>
    cb40:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    cb44:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    cb48:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    cb4c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    cb50:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    cb54:	bf08      	it	eq
    cb56:	f020 0001 	biceq.w	r0, r0, #1
    cb5a:	4770      	bx	lr
    cb5c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    cb60:	d121      	bne.n	cba6 <__aeabi_d2f+0x7a>
    cb62:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    cb66:	bfbc      	itt	lt
    cb68:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    cb6c:	4770      	bxlt	lr
    cb6e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    cb72:	ea4f 5252 	mov.w	r2, r2, lsr #21
    cb76:	f1c2 0218 	rsb	r2, r2, #24
    cb7a:	f1c2 0c20 	rsb	ip, r2, #32
    cb7e:	fa10 f30c 	lsls.w	r3, r0, ip
    cb82:	fa20 f002 	lsr.w	r0, r0, r2
    cb86:	bf18      	it	ne
    cb88:	f040 0001 	orrne.w	r0, r0, #1
    cb8c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    cb90:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    cb94:	fa03 fc0c 	lsl.w	ip, r3, ip
    cb98:	ea40 000c 	orr.w	r0, r0, ip
    cb9c:	fa23 f302 	lsr.w	r3, r3, r2
    cba0:	ea4f 0343 	mov.w	r3, r3, lsl #1
    cba4:	e7cc      	b.n	cb40 <__aeabi_d2f+0x14>
    cba6:	ea7f 5362 	mvns.w	r3, r2, asr #21
    cbaa:	d107      	bne.n	cbbc <__aeabi_d2f+0x90>
    cbac:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    cbb0:	bf1e      	ittt	ne
    cbb2:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    cbb6:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    cbba:	4770      	bxne	lr
    cbbc:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    cbc0:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    cbc4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    cbc8:	4770      	bx	lr
    cbca:	bf00      	nop

0000cbcc <__aeabi_uldivmod>:
    cbcc:	b953      	cbnz	r3, cbe4 <__aeabi_uldivmod+0x18>
    cbce:	b94a      	cbnz	r2, cbe4 <__aeabi_uldivmod+0x18>
    cbd0:	2900      	cmp	r1, #0
    cbd2:	bf08      	it	eq
    cbd4:	2800      	cmpeq	r0, #0
    cbd6:	bf1c      	itt	ne
    cbd8:	f04f 31ff 	movne.w	r1, #4294967295
    cbdc:	f04f 30ff 	movne.w	r0, #4294967295
    cbe0:	f000 b970 	b.w	cec4 <__aeabi_idiv0>
    cbe4:	f1ad 0c08 	sub.w	ip, sp, #8
    cbe8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    cbec:	f000 f806 	bl	cbfc <__udivmoddi4>
    cbf0:	f8dd e004 	ldr.w	lr, [sp, #4]
    cbf4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    cbf8:	b004      	add	sp, #16
    cbfa:	4770      	bx	lr

0000cbfc <__udivmoddi4>:
    cbfc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cc00:	9e09      	ldr	r6, [sp, #36]	; 0x24
    cc02:	4604      	mov	r4, r0
    cc04:	4689      	mov	r9, r1
    cc06:	2b00      	cmp	r3, #0
    cc08:	f040 8083 	bne.w	cd12 <__udivmoddi4+0x116>
    cc0c:	428a      	cmp	r2, r1
    cc0e:	4615      	mov	r5, r2
    cc10:	d945      	bls.n	cc9e <__udivmoddi4+0xa2>
    cc12:	fab2 f282 	clz	r2, r2
    cc16:	b14a      	cbz	r2, cc2c <__udivmoddi4+0x30>
    cc18:	f1c2 0720 	rsb	r7, r2, #32
    cc1c:	fa01 f302 	lsl.w	r3, r1, r2
    cc20:	4095      	lsls	r5, r2
    cc22:	4094      	lsls	r4, r2
    cc24:	fa20 f707 	lsr.w	r7, r0, r7
    cc28:	ea47 0903 	orr.w	r9, r7, r3
    cc2c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    cc30:	0c23      	lsrs	r3, r4, #16
    cc32:	fa1f f885 	uxth.w	r8, r5
    cc36:	fbb9 fcfe 	udiv	ip, r9, lr
    cc3a:	fb0e 991c 	mls	r9, lr, ip, r9
    cc3e:	fb0c f108 	mul.w	r1, ip, r8
    cc42:	ea43 4309 	orr.w	r3, r3, r9, lsl #16
    cc46:	4299      	cmp	r1, r3
    cc48:	d90a      	bls.n	cc60 <__udivmoddi4+0x64>
    cc4a:	18eb      	adds	r3, r5, r3
    cc4c:	bf2c      	ite	cs
    cc4e:	2001      	movcs	r0, #1
    cc50:	2000      	movcc	r0, #0
    cc52:	4299      	cmp	r1, r3
    cc54:	d902      	bls.n	cc5c <__udivmoddi4+0x60>
    cc56:	2800      	cmp	r0, #0
    cc58:	f000 811d 	beq.w	ce96 <__udivmoddi4+0x29a>
    cc5c:	f10c 3cff 	add.w	ip, ip, #4294967295
    cc60:	1a59      	subs	r1, r3, r1
    cc62:	b2a3      	uxth	r3, r4
    cc64:	fbb1 f0fe 	udiv	r0, r1, lr
    cc68:	fb0e 1110 	mls	r1, lr, r0, r1
    cc6c:	fb00 f808 	mul.w	r8, r0, r8
    cc70:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
    cc74:	45a0      	cmp	r8, r4
    cc76:	d905      	bls.n	cc84 <__udivmoddi4+0x88>
    cc78:	192c      	adds	r4, r5, r4
    cc7a:	d202      	bcs.n	cc82 <__udivmoddi4+0x86>
    cc7c:	45a0      	cmp	r8, r4
    cc7e:	f200 810e 	bhi.w	ce9e <__udivmoddi4+0x2a2>
    cc82:	3801      	subs	r0, #1
    cc84:	eba4 0408 	sub.w	r4, r4, r8
    cc88:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    cc8c:	2700      	movs	r7, #0
    cc8e:	b11e      	cbz	r6, cc98 <__udivmoddi4+0x9c>
    cc90:	40d4      	lsrs	r4, r2
    cc92:	2300      	movs	r3, #0
    cc94:	e9c6 4300 	strd	r4, r3, [r6]
    cc98:	4639      	mov	r1, r7
    cc9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cc9e:	2a00      	cmp	r2, #0
    cca0:	d051      	beq.n	cd46 <__udivmoddi4+0x14a>
    cca2:	fab2 f282 	clz	r2, r2
    cca6:	2a00      	cmp	r2, #0
    cca8:	f040 80af 	bne.w	ce0a <__udivmoddi4+0x20e>
    ccac:	1b49      	subs	r1, r1, r5
    ccae:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    ccb2:	fa1f f885 	uxth.w	r8, r5
    ccb6:	2701      	movs	r7, #1
    ccb8:	0c23      	lsrs	r3, r4, #16
    ccba:	fbb1 fcfe 	udiv	ip, r1, lr
    ccbe:	fb0e 111c 	mls	r1, lr, ip, r1
    ccc2:	fb08 f00c 	mul.w	r0, r8, ip
    ccc6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    ccca:	4298      	cmp	r0, r3
    cccc:	d90a      	bls.n	cce4 <__udivmoddi4+0xe8>
    ccce:	18eb      	adds	r3, r5, r3
    ccd0:	bf2c      	ite	cs
    ccd2:	2101      	movcs	r1, #1
    ccd4:	2100      	movcc	r1, #0
    ccd6:	4298      	cmp	r0, r3
    ccd8:	d902      	bls.n	cce0 <__udivmoddi4+0xe4>
    ccda:	2900      	cmp	r1, #0
    ccdc:	f000 80d7 	beq.w	ce8e <__udivmoddi4+0x292>
    cce0:	f10c 3cff 	add.w	ip, ip, #4294967295
    cce4:	1a19      	subs	r1, r3, r0
    cce6:	b2a3      	uxth	r3, r4
    cce8:	fbb1 f0fe 	udiv	r0, r1, lr
    ccec:	fb0e 1110 	mls	r1, lr, r0, r1
    ccf0:	fb08 f800 	mul.w	r8, r8, r0
    ccf4:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
    ccf8:	45a0      	cmp	r8, r4
    ccfa:	d905      	bls.n	cd08 <__udivmoddi4+0x10c>
    ccfc:	192c      	adds	r4, r5, r4
    ccfe:	d202      	bcs.n	cd06 <__udivmoddi4+0x10a>
    cd00:	45a0      	cmp	r8, r4
    cd02:	f200 80c1 	bhi.w	ce88 <__udivmoddi4+0x28c>
    cd06:	3801      	subs	r0, #1
    cd08:	eba4 0408 	sub.w	r4, r4, r8
    cd0c:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    cd10:	e7bd      	b.n	cc8e <__udivmoddi4+0x92>
    cd12:	428b      	cmp	r3, r1
    cd14:	d908      	bls.n	cd28 <__udivmoddi4+0x12c>
    cd16:	2e00      	cmp	r6, #0
    cd18:	d074      	beq.n	ce04 <__udivmoddi4+0x208>
    cd1a:	2700      	movs	r7, #0
    cd1c:	e9c6 0100 	strd	r0, r1, [r6]
    cd20:	4638      	mov	r0, r7
    cd22:	4639      	mov	r1, r7
    cd24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cd28:	fab3 f783 	clz	r7, r3
    cd2c:	b967      	cbnz	r7, cd48 <__udivmoddi4+0x14c>
    cd2e:	428b      	cmp	r3, r1
    cd30:	f0c0 80a4 	bcc.w	ce7c <__udivmoddi4+0x280>
    cd34:	4282      	cmp	r2, r0
    cd36:	f240 80a1 	bls.w	ce7c <__udivmoddi4+0x280>
    cd3a:	4638      	mov	r0, r7
    cd3c:	2e00      	cmp	r6, #0
    cd3e:	d0ab      	beq.n	cc98 <__udivmoddi4+0x9c>
    cd40:	e9c6 4900 	strd	r4, r9, [r6]
    cd44:	e7a8      	b.n	cc98 <__udivmoddi4+0x9c>
    cd46:	deff      	udf	#255	; 0xff
    cd48:	f1c7 0520 	rsb	r5, r7, #32
    cd4c:	40bb      	lsls	r3, r7
    cd4e:	fa02 fc07 	lsl.w	ip, r2, r7
    cd52:	fa01 f407 	lsl.w	r4, r1, r7
    cd56:	40ea      	lsrs	r2, r5
    cd58:	fa20 f805 	lsr.w	r8, r0, r5
    cd5c:	40e9      	lsrs	r1, r5
    cd5e:	fa00 fe07 	lsl.w	lr, r0, r7
    cd62:	431a      	orrs	r2, r3
    cd64:	ea48 0404 	orr.w	r4, r8, r4
    cd68:	ea4f 4812 	mov.w	r8, r2, lsr #16
    cd6c:	0c20      	lsrs	r0, r4, #16
    cd6e:	fa1f f982 	uxth.w	r9, r2
    cd72:	fbb1 faf8 	udiv	sl, r1, r8
    cd76:	fb08 111a 	mls	r1, r8, sl, r1
    cd7a:	fb0a fb09 	mul.w	fp, sl, r9
    cd7e:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
    cd82:	458b      	cmp	fp, r1
    cd84:	d90a      	bls.n	cd9c <__udivmoddi4+0x1a0>
    cd86:	1851      	adds	r1, r2, r1
    cd88:	bf2c      	ite	cs
    cd8a:	2301      	movcs	r3, #1
    cd8c:	2300      	movcc	r3, #0
    cd8e:	458b      	cmp	fp, r1
    cd90:	d902      	bls.n	cd98 <__udivmoddi4+0x19c>
    cd92:	2b00      	cmp	r3, #0
    cd94:	f000 8088 	beq.w	cea8 <__udivmoddi4+0x2ac>
    cd98:	f10a 3aff 	add.w	sl, sl, #4294967295
    cd9c:	eba1 010b 	sub.w	r1, r1, fp
    cda0:	b2a4      	uxth	r4, r4
    cda2:	fbb1 f0f8 	udiv	r0, r1, r8
    cda6:	fb08 1110 	mls	r1, r8, r0, r1
    cdaa:	fb00 f909 	mul.w	r9, r0, r9
    cdae:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
    cdb2:	4589      	cmp	r9, r1
    cdb4:	d904      	bls.n	cdc0 <__udivmoddi4+0x1c4>
    cdb6:	1851      	adds	r1, r2, r1
    cdb8:	d201      	bcs.n	cdbe <__udivmoddi4+0x1c2>
    cdba:	4589      	cmp	r9, r1
    cdbc:	d87b      	bhi.n	ceb6 <__udivmoddi4+0x2ba>
    cdbe:	3801      	subs	r0, #1
    cdc0:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
    cdc4:	eba1 0109 	sub.w	r1, r1, r9
    cdc8:	fba0 890c 	umull	r8, r9, r0, ip
    cdcc:	4549      	cmp	r1, r9
    cdce:	4644      	mov	r4, r8
    cdd0:	464b      	mov	r3, r9
    cdd2:	d302      	bcc.n	cdda <__udivmoddi4+0x1de>
    cdd4:	d106      	bne.n	cde4 <__udivmoddi4+0x1e8>
    cdd6:	45c6      	cmp	lr, r8
    cdd8:	d204      	bcs.n	cde4 <__udivmoddi4+0x1e8>
    cdda:	3801      	subs	r0, #1
    cddc:	ebb8 040c 	subs.w	r4, r8, ip
    cde0:	eb69 0302 	sbc.w	r3, r9, r2
    cde4:	2e00      	cmp	r6, #0
    cde6:	d05d      	beq.n	cea4 <__udivmoddi4+0x2a8>
    cde8:	ebbe 0204 	subs.w	r2, lr, r4
    cdec:	eb61 0103 	sbc.w	r1, r1, r3
    cdf0:	fa01 f505 	lsl.w	r5, r1, r5
    cdf4:	fa22 f307 	lsr.w	r3, r2, r7
    cdf8:	40f9      	lsrs	r1, r7
    cdfa:	2700      	movs	r7, #0
    cdfc:	431d      	orrs	r5, r3
    cdfe:	e9c6 5100 	strd	r5, r1, [r6]
    ce02:	e749      	b.n	cc98 <__udivmoddi4+0x9c>
    ce04:	4637      	mov	r7, r6
    ce06:	4630      	mov	r0, r6
    ce08:	e746      	b.n	cc98 <__udivmoddi4+0x9c>
    ce0a:	f1c2 0020 	rsb	r0, r2, #32
    ce0e:	4095      	lsls	r5, r2
    ce10:	fa01 f702 	lsl.w	r7, r1, r2
    ce14:	fa21 f300 	lsr.w	r3, r1, r0
    ce18:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    ce1c:	fa24 f100 	lsr.w	r1, r4, r0
    ce20:	fa1f f885 	uxth.w	r8, r5
    ce24:	4094      	lsls	r4, r2
    ce26:	4339      	orrs	r1, r7
    ce28:	fbb3 f0fe 	udiv	r0, r3, lr
    ce2c:	0c0f      	lsrs	r7, r1, #16
    ce2e:	fb0e 3310 	mls	r3, lr, r0, r3
    ce32:	fb00 fc08 	mul.w	ip, r0, r8
    ce36:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
    ce3a:	459c      	cmp	ip, r3
    ce3c:	d907      	bls.n	ce4e <__udivmoddi4+0x252>
    ce3e:	18eb      	adds	r3, r5, r3
    ce40:	bf2c      	ite	cs
    ce42:	2701      	movcs	r7, #1
    ce44:	2700      	movcc	r7, #0
    ce46:	459c      	cmp	ip, r3
    ce48:	d900      	bls.n	ce4c <__udivmoddi4+0x250>
    ce4a:	b38f      	cbz	r7, ceb0 <__udivmoddi4+0x2b4>
    ce4c:	3801      	subs	r0, #1
    ce4e:	eba3 030c 	sub.w	r3, r3, ip
    ce52:	b289      	uxth	r1, r1
    ce54:	fbb3 f7fe 	udiv	r7, r3, lr
    ce58:	fb0e 3317 	mls	r3, lr, r7, r3
    ce5c:	fb07 fc08 	mul.w	ip, r7, r8
    ce60:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    ce64:	458c      	cmp	ip, r1
    ce66:	d904      	bls.n	ce72 <__udivmoddi4+0x276>
    ce68:	1869      	adds	r1, r5, r1
    ce6a:	d201      	bcs.n	ce70 <__udivmoddi4+0x274>
    ce6c:	458c      	cmp	ip, r1
    ce6e:	d825      	bhi.n	cebc <__udivmoddi4+0x2c0>
    ce70:	3f01      	subs	r7, #1
    ce72:	eba1 010c 	sub.w	r1, r1, ip
    ce76:	ea47 4700 	orr.w	r7, r7, r0, lsl #16
    ce7a:	e71d      	b.n	ccb8 <__udivmoddi4+0xbc>
    ce7c:	1a84      	subs	r4, r0, r2
    ce7e:	eb61 0303 	sbc.w	r3, r1, r3
    ce82:	2001      	movs	r0, #1
    ce84:	4699      	mov	r9, r3
    ce86:	e759      	b.n	cd3c <__udivmoddi4+0x140>
    ce88:	3802      	subs	r0, #2
    ce8a:	442c      	add	r4, r5
    ce8c:	e73c      	b.n	cd08 <__udivmoddi4+0x10c>
    ce8e:	f1ac 0c02 	sub.w	ip, ip, #2
    ce92:	442b      	add	r3, r5
    ce94:	e726      	b.n	cce4 <__udivmoddi4+0xe8>
    ce96:	f1ac 0c02 	sub.w	ip, ip, #2
    ce9a:	442b      	add	r3, r5
    ce9c:	e6e0      	b.n	cc60 <__udivmoddi4+0x64>
    ce9e:	3802      	subs	r0, #2
    cea0:	442c      	add	r4, r5
    cea2:	e6ef      	b.n	cc84 <__udivmoddi4+0x88>
    cea4:	4637      	mov	r7, r6
    cea6:	e6f7      	b.n	cc98 <__udivmoddi4+0x9c>
    cea8:	f1aa 0a02 	sub.w	sl, sl, #2
    ceac:	4411      	add	r1, r2
    ceae:	e775      	b.n	cd9c <__udivmoddi4+0x1a0>
    ceb0:	3802      	subs	r0, #2
    ceb2:	442b      	add	r3, r5
    ceb4:	e7cb      	b.n	ce4e <__udivmoddi4+0x252>
    ceb6:	3802      	subs	r0, #2
    ceb8:	4411      	add	r1, r2
    ceba:	e781      	b.n	cdc0 <__udivmoddi4+0x1c4>
    cebc:	3f02      	subs	r7, #2
    cebe:	4429      	add	r1, r5
    cec0:	e7d7      	b.n	ce72 <__udivmoddi4+0x276>
    cec2:	bf00      	nop

0000cec4 <__aeabi_idiv0>:
    cec4:	4770      	bx	lr
    cec6:	bf00      	nop

0000cec8 <__aeabi_dcmpun>:
    cec8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    cecc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    ced0:	d102      	bne.n	ced8 <__aeabi_dcmpun+0x10>
    ced2:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    ced6:	d10a      	bne.n	ceee <__aeabi_dcmpun+0x26>
    ced8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    cedc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    cee0:	d102      	bne.n	cee8 <__aeabi_dcmpun+0x20>
    cee2:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    cee6:	d102      	bne.n	ceee <__aeabi_dcmpun+0x26>
    cee8:	f04f 0000 	mov.w	r0, #0
    ceec:	4770      	bx	lr
    ceee:	f04f 0001 	mov.w	r0, #1
    cef2:	4770      	bx	lr

0000cef4 <__aeabi_d2iz>:
    cef4:	ea4f 0241 	mov.w	r2, r1, lsl #1
    cef8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    cefc:	d215      	bcs.n	cf2a <__aeabi_d2iz+0x36>
    cefe:	d511      	bpl.n	cf24 <__aeabi_d2iz+0x30>
    cf00:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    cf04:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    cf08:	d912      	bls.n	cf30 <__aeabi_d2iz+0x3c>
    cf0a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    cf0e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    cf12:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    cf16:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    cf1a:	fa23 f002 	lsr.w	r0, r3, r2
    cf1e:	bf18      	it	ne
    cf20:	4240      	negne	r0, r0
    cf22:	4770      	bx	lr
    cf24:	f04f 0000 	mov.w	r0, #0
    cf28:	4770      	bx	lr
    cf2a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    cf2e:	d105      	bne.n	cf3c <__aeabi_d2iz+0x48>
    cf30:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
    cf34:	bf08      	it	eq
    cf36:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
    cf3a:	4770      	bx	lr
    cf3c:	f04f 0000 	mov.w	r0, #0
    cf40:	4770      	bx	lr
    cf42:	bf00      	nop

0000cf44 <strcmp>:
    cf44:	f810 2b01 	ldrb.w	r2, [r0], #1
    cf48:	f811 3b01 	ldrb.w	r3, [r1], #1
    cf4c:	2a01      	cmp	r2, #1
    cf4e:	bf28      	it	cs
    cf50:	429a      	cmpcs	r2, r3
    cf52:	d0f7      	beq.n	cf44 <strcmp>
    cf54:	1ad0      	subs	r0, r2, r3
    cf56:	4770      	bx	lr

0000cf58 <strlen>:
    cf58:	4603      	mov	r3, r0
    cf5a:	f813 2b01 	ldrb.w	r2, [r3], #1
    cf5e:	2a00      	cmp	r2, #0
    cf60:	d1fb      	bne.n	cf5a <strlen+0x2>
    cf62:	1a18      	subs	r0, r3, r0
    cf64:	3801      	subs	r0, #1
    cf66:	4770      	bx	lr

0000cf68 <APP_get_location_data_reply>:
	ble_wait_gps = true;
	APP_Ask_GPS_Data();
}

void APP_get_location_data_reply(nrf_gnss_pvt_data_frame_t gps_data)
{
    cf68:	b084      	sub	sp, #16
    cf6a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    cf6e:	b0a0      	sub	sp, #128	; 0x80
    cf70:	ac26      	add	r4, sp, #152	; 0x98
    cf72:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	u8_t tmpgps;
	u8_t reply[128] = {0};
    cf76:	2280      	movs	r2, #128	; 0x80
    cf78:	e9dd 6728 	ldrd	r6, r7, [sp, #160]	; 0xa0
    cf7c:	e9dd 4526 	ldrd	r4, r5, [sp, #152]	; 0x98
    cf80:	2100      	movs	r1, #0
    cf82:	4668      	mov	r0, sp
    cf84:	f8bd 80b8 	ldrh.w	r8, [sp, #184]	; 0xb8
    cf88:	f022 fa04 	bl	2f394 <memset>
	u32_t i,reply_len = 0;
	u32_t tmp1;
	double tmp2;

	//packet head
	reply[reply_len++] = PACKET_HEAD;
    cf8c:	23ab      	movs	r3, #171	; 0xab
    cf8e:	f88d 3000 	strb.w	r3, [sp]
	//data_len
	reply[reply_len++] = 0x00;
	reply[reply_len++] = 0x17;
    cf92:	f64f 7317 	movw	r3, #65303	; 0xff17
    cf96:	f8ad 3002 	strh.w	r3, [sp, #2]
	//data ID
	reply[reply_len++] = (LOCATION_ID>>8);		
	reply[reply_len++] = (u8_t)(LOCATION_ID&0x00ff);
    cf9a:	f248 0355 	movw	r3, #32853	; 0x8055
    cf9e:	f8ad 3004 	strh.w	r3, [sp, #4]
	//control
	reply[reply_len++] = 0x00;
	
	//UTC data&time
	//year
	reply[reply_len++] = gps_data.datetime.year>>8;
    cfa2:	ea4f 2318 	mov.w	r3, r8, lsr #8
    cfa6:	f88d 3007 	strb.w	r3, [sp, #7]
	reply[reply_len++] = (u8_t)(gps_data.datetime.year&0x00FF);
	//month
	reply[reply_len++] = gps_data.datetime.month;
    cfaa:	f89d 30ba 	ldrb.w	r3, [sp, #186]	; 0xba
	//seconds
	reply[reply_len++] = gps_data.datetime.seconds;
	
	//longitude
	tmpgps = 'E';
	if(gps_data.longitude < 0)
    cfae:	2200      	movs	r2, #0
	reply[reply_len++] = gps_data.datetime.month;
    cfb0:	f88d 3009 	strb.w	r3, [sp, #9]
	reply[reply_len++] = gps_data.datetime.day;
    cfb4:	f89d 30bb 	ldrb.w	r3, [sp, #187]	; 0xbb
	if(gps_data.longitude < 0)
    cfb8:	4630      	mov	r0, r6
	reply[reply_len++] = gps_data.datetime.day;
    cfba:	f88d 300a 	strb.w	r3, [sp, #10]
	reply[reply_len++] = gps_data.datetime.hour;
    cfbe:	f89d 30bc 	ldrb.w	r3, [sp, #188]	; 0xbc
	if(gps_data.longitude < 0)
    cfc2:	4639      	mov	r1, r7
	reply[reply_len++] = gps_data.datetime.hour;
    cfc4:	f88d 300b 	strb.w	r3, [sp, #11]
	reply[reply_len++] = gps_data.datetime.minute;
    cfc8:	f89d 30bd 	ldrb.w	r3, [sp, #189]	; 0xbd
	reply[reply_len++] = (u8_t)(gps_data.datetime.year&0x00FF);
    cfcc:	f88d 8008 	strb.w	r8, [sp, #8]
	reply[reply_len++] = gps_data.datetime.minute;
    cfd0:	f88d 300c 	strb.w	r3, [sp, #12]
	reply[reply_len++] = gps_data.datetime.seconds;
    cfd4:	f89d 30be 	ldrb.w	r3, [sp, #190]	; 0xbe
    cfd8:	f88d 300d 	strb.w	r3, [sp, #13]
	if(gps_data.longitude < 0)
    cfdc:	2300      	movs	r3, #0
    cfde:	f7ff fd5d 	bl	ca9c <__aeabi_dcmplt>
    cfe2:	2800      	cmp	r0, #0
    cfe4:	d077      	beq.n	d0d6 <APP_get_location_data_reply+0x16e>
	{
		tmpgps = 'W';
		gps_data.longitude = -gps_data.longitude;
    cfe6:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
    cfea:	461f      	mov	r7, r3
		tmpgps = 'W';
    cfec:	2357      	movs	r3, #87	; 0x57
	}
	//direction	E\W
	reply[reply_len++] = tmpgps;
	tmp1 = (u32_t)(gps_data.longitude); //
    cfee:	4639      	mov	r1, r7
    cff0:	4630      	mov	r0, r6
	reply[reply_len++] = tmpgps;
    cff2:	f88d 300e 	strb.w	r3, [sp, #14]
	tmp1 = (u32_t)(gps_data.longitude); //
    cff6:	f7ff fd79 	bl	caec <__aeabi_d2uiz>
	tmp2 = gps_data.longitude - tmp1;	//
	//degree int
	reply[reply_len++] = tmp1;//
    cffa:	f88d 000f 	strb.w	r0, [sp, #15]
	tmp2 = gps_data.longitude - tmp1;	//
    cffe:	f7ff fa61 	bl	c4c4 <__aeabi_ui2d>
    d002:	4602      	mov	r2, r0
    d004:	460b      	mov	r3, r1
    d006:	4630      	mov	r0, r6
    d008:	4639      	mov	r1, r7
    d00a:	f7ff f91d 	bl	c248 <__aeabi_dsub>
	tmp1 = (u32_t)(tmp2*1000000);
    d00e:	a334      	add	r3, pc, #208	; (adr r3, d0e0 <APP_get_location_data_reply+0x178>)
    d010:	e9d3 2300 	ldrd	r2, r3, [r3]
    d014:	f7ff fad0 	bl	c5b8 <__aeabi_dmul>
    d018:	f7ff fd68 	bl	caec <__aeabi_d2uiz>
	//degree dot1~2
	reply[reply_len++] = (u8_t)(tmp1/10000);
    d01c:	f242 7210 	movw	r2, #10000	; 0x2710
    d020:	fbb0 f3f2 	udiv	r3, r0, r2
    d024:	f88d 3010 	strb.w	r3, [sp, #16]
	tmp1 = tmp1%10000;
    d028:	fb02 0313 	mls	r3, r2, r3, r0
	//degree dot3~4
	reply[reply_len++] = (u8_t)(tmp1/100);
    d02c:	2264      	movs	r2, #100	; 0x64
    d02e:	fbb3 f0f2 	udiv	r0, r3, r2
	tmp1 = tmp1%100;
    d032:	fb02 3310 	mls	r3, r2, r0, r3
	reply[reply_len++] = (u8_t)(tmp1/100);
    d036:	f88d 0011 	strb.w	r0, [sp, #17]
	//degree dot5~6
	reply[reply_len++] = (u8_t)(tmp1);	
    d03a:	f88d 3012 	strb.w	r3, [sp, #18]
	//latitude
	tmpgps = 'N';
	if(gps_data.latitude < 0)
    d03e:	2200      	movs	r2, #0
    d040:	2300      	movs	r3, #0
    d042:	4620      	mov	r0, r4
    d044:	4629      	mov	r1, r5
    d046:	f7ff fd29 	bl	ca9c <__aeabi_dcmplt>
    d04a:	2800      	cmp	r0, #0
    d04c:	d045      	beq.n	d0da <APP_get_location_data_reply+0x172>
	{
		tmpgps = 'S';
		gps_data.latitude = -gps_data.latitude;
    d04e:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
    d052:	461d      	mov	r5, r3
		tmpgps = 'S';
    d054:	2353      	movs	r3, #83	; 0x53
	}
	//direction N\S
	reply[reply_len++] = tmpgps;
	tmp1 = (u32_t)(gps_data.latitude);	//
    d056:	4629      	mov	r1, r5
    d058:	4620      	mov	r0, r4
	reply[reply_len++] = tmpgps;
    d05a:	f88d 3013 	strb.w	r3, [sp, #19]
	tmp1 = (u32_t)(gps_data.latitude);	//
    d05e:	f7ff fd45 	bl	caec <__aeabi_d2uiz>
	tmp2 = gps_data.latitude - tmp1;	//
	//degree int
	reply[reply_len++] = tmp1;//
    d062:	f88d 0014 	strb.w	r0, [sp, #20]
	tmp2 = gps_data.latitude - tmp1;	//
    d066:	f7ff fa2d 	bl	c4c4 <__aeabi_ui2d>
    d06a:	4602      	mov	r2, r0
    d06c:	460b      	mov	r3, r1
    d06e:	4620      	mov	r0, r4
    d070:	4629      	mov	r1, r5
    d072:	f7ff f8e9 	bl	c248 <__aeabi_dsub>
	tmp1 = (u32_t)(tmp2*1000000);
    d076:	a31a      	add	r3, pc, #104	; (adr r3, d0e0 <APP_get_location_data_reply+0x178>)
    d078:	e9d3 2300 	ldrd	r2, r3, [r3]
    d07c:	f7ff fa9c 	bl	c5b8 <__aeabi_dmul>
    d080:	f7ff fd34 	bl	caec <__aeabi_d2uiz>
	//degree dot1~2
	reply[reply_len++] = (u8_t)(tmp1/10000);
    d084:	f242 7210 	movw	r2, #10000	; 0x2710
    d088:	fbb0 f3f2 	udiv	r3, r0, r2
    d08c:	f88d 3015 	strb.w	r3, [sp, #21]
	tmp1 = tmp1%10000;
    d090:	fb02 0313 	mls	r3, r2, r3, r0
	//degree dot3~4
	reply[reply_len++] = (u8_t)(tmp1/100);
    d094:	2264      	movs	r2, #100	; 0x64
    d096:	fbb3 f0f2 	udiv	r0, r3, r2
	tmp1 = tmp1%100;
    d09a:	fb02 3310 	mls	r3, r2, r0, r3
	//degree dot5~6
	reply[reply_len++] = (u8_t)(tmp1);
    d09e:	f88d 3017 	strb.w	r3, [sp, #23]
					
	//CRC
	reply[reply_len++] = 0x00;
	//packet end
	reply[reply_len++] = PACKET_END;
    d0a2:	2388      	movs	r3, #136	; 0x88
    d0a4:	4669      	mov	r1, sp
    d0a6:	f88d 3019 	strb.w	r3, [sp, #25]

	for(i=0;i<(reply_len-2);i++)
    d0aa:	2300      	movs	r3, #0
	reply[reply_len++] = (u8_t)(tmp1/100);
    d0ac:	f88d 0016 	strb.w	r0, [sp, #22]
		reply[reply_len-2] += reply[i];
    d0b0:	f811 2b01 	ldrb.w	r2, [r1], #1
    d0b4:	f89d 0018 	ldrb.w	r0, [sp, #24]
	for(i=0;i<(reply_len-2);i++)
    d0b8:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
    d0ba:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
    d0bc:	2b18      	cmp	r3, #24
		reply[reply_len-2] += reply[i];
    d0be:	f88d 2018 	strb.w	r2, [sp, #24]
	for(i=0;i<(reply_len-2);i++)
    d0c2:	d1f5      	bne.n	d0b0 <APP_get_location_data_reply+0x148>

	ble_send_date_handle(reply, reply_len);
    d0c4:	211a      	movs	r1, #26
    d0c6:	4668      	mov	r0, sp
    d0c8:	f004 ff70 	bl	11fac <ble_send_date_handle>
}
    d0cc:	b020      	add	sp, #128	; 0x80
    d0ce:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    d0d2:	b004      	add	sp, #16
    d0d4:	4770      	bx	lr
	tmpgps = 'E';
    d0d6:	2345      	movs	r3, #69	; 0x45
    d0d8:	e789      	b.n	cfee <APP_get_location_data_reply+0x86>
	tmpgps = 'N';
    d0da:	234e      	movs	r3, #78	; 0x4e
    d0dc:	e7bb      	b.n	d056 <APP_get_location_data_reply+0xee>
    d0de:	bf00      	nop
    d0e0:	00000000 	.word	0x00000000
    d0e4:	412e8480 	.word	0x412e8480

0000d0e8 <APP_Ask_GPS_Data>:
	{
		app_gps_on = true;
		k_timer_start(&app_wait_gps_timer, K_MSEC(3*60*1000), NULL);
	}
#else
	last_fix.pvt.datetime.year = 2020;
    d0e8:	4b11      	ldr	r3, [pc, #68]	; (d130 <APP_Ask_GPS_Data+0x48>)
    d0ea:	4a12      	ldr	r2, [pc, #72]	; (d134 <APP_Ask_GPS_Data+0x4c>)
	last_fix.pvt.datetime.month = 11;
	last_fix.pvt.datetime.day = 4;
	last_fix.pvt.datetime.hour = 2;
	last_fix.pvt.datetime.minute = 20;
	last_fix.pvt.datetime.seconds = 40;
	last_fix.pvt.longitude = 114.025254;
    d0ec:	a10c      	add	r1, pc, #48	; (adr r1, d120 <APP_Ask_GPS_Data+0x38>)
    d0ee:	e9d1 0100 	ldrd	r0, r1, [r1]
	last_fix.pvt.datetime.year = 2020;
    d0f2:	629a      	str	r2, [r3, #40]	; 0x28
	last_fix.pvt.datetime.hour = 2;
    d0f4:	f241 4202 	movw	r2, #5122	; 0x1402
    d0f8:	859a      	strh	r2, [r3, #44]	; 0x2c
	last_fix.pvt.datetime.seconds = 40;
    d0fa:	2228      	movs	r2, #40	; 0x28
	last_fix.pvt.longitude = 114.025254;
    d0fc:	e9c3 0104 	strd	r0, r1, [r3, #16]
	last_fix.pvt.latitude = 22.667808;
    d100:	a109      	add	r1, pc, #36	; (adr r1, d128 <APP_Ask_GPS_Data+0x40>)
    d102:	e9d1 0100 	ldrd	r0, r1, [r1]
	last_fix.pvt.datetime.seconds = 40;
    d106:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
	last_fix.pvt.latitude = 22.667808;
    d10a:	e9c3 0102 	strd	r0, r1, [r3, #8]
		arch_syscall_invoke3(*(uintptr_t *)&timer, *(uintptr_t *)&duration, *(uintptr_t *)&period, K_SYSCALL_K_TIMER_START);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_timer_start(timer, duration, period);
    d10e:	2200      	movs	r2, #0
    d110:	f64e 2160 	movw	r1, #60000	; 0xea60
    d114:	4808      	ldr	r0, [pc, #32]	; (d138 <APP_Ask_GPS_Data+0x50>)
    d116:	f01c b895 	b.w	29244 <z_impl_k_timer_start>
    d11a:	bf00      	nop
    d11c:	f3af 8000 	nop.w
    d120:	c2f405f7 	.word	0xc2f405f7
    d124:	405c819d 	.word	0x405c819d
    d128:	771001d6 	.word	0x771001d6
    d12c:	4036aaf5 	.word	0x4036aaf5
    d130:	20020008 	.word	0x20020008
    d134:	040b07e4 	.word	0x040b07e4
    d138:	2003b6e4 	.word	0x2003b6e4
    d13c:	00000000 	.word	0x00000000

0000d140 <fall_detection>:
/*@brief Fall detection analyse
*
* @return If fall return 1, otherwise return 0
*/
void fall_detection(void)
{
    d140:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    d144:	ed2d 8b06 	vpush	{d8-d10}
    d148:	b0ac      	sub	sp, #176	; 0xb0
	historic_buffer();
    d14a:	f007 fe13 	bl	14d74 <historic_buffer>
	LOG_INF("fall detecting 1");
    d14e:	2303      	movs	r3, #3
    d150:	f04f 0000 	mov.w	r0, #0
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
    d154:	4cdc      	ldr	r4, [pc, #880]	; (d4c8 <fall_detection+0x388>)
    d156:	f363 0007 	bfi	r0, r3, #0, #8
    d15a:	4bdc      	ldr	r3, [pc, #880]	; (d4cc <fall_detection+0x38c>)

	if(hist_buff_flag)
    d15c:	4ddc      	ldr	r5, [pc, #880]	; (d4d0 <fall_detection+0x390>)
	LOG_INF("fall detecting 1");
    d15e:	1ae4      	subs	r4, r4, r3
    d160:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    d164:	f364 108f 	bfi	r0, r4, #6, #10
    d168:	49da      	ldr	r1, [pc, #872]	; (d4d4 <fall_detection+0x394>)
    d16a:	f020 f8c5 	bl	2d2f8 <log_string_sync>
	if(hist_buff_flag)
    d16e:	782b      	ldrb	r3, [r5, #0]
    d170:	b16b      	cbz	r3, d18e <fall_detection+0x4e>
	{
		curr_vrif_buffers();
    d172:	f007 fec5 	bl	14f00 <curr_vrif_buffers>
		hist_buff_flag = false;
    d176:	2300      	movs	r3, #0
		LOG_INF("fall detecting 2");
    d178:	f04f 0000 	mov.w	r0, #0
		hist_buff_flag = false;
    d17c:	702b      	strb	r3, [r5, #0]
		LOG_INF("fall detecting 2");
    d17e:	2303      	movs	r3, #3
    d180:	f363 0007 	bfi	r0, r3, #0, #8
    d184:	f364 108f 	bfi	r0, r4, #6, #10
    d188:	49d3      	ldr	r1, [pc, #844]	; (d4d8 <fall_detection+0x398>)
    d18a:	f020 f8b5 	bl	2d2f8 <log_string_sync>
	}

	if(curr_vrif_buff_flag)
    d18e:	4dd3      	ldr	r5, [pc, #844]	; (d4dc <fall_detection+0x39c>)
    d190:	782b      	ldrb	r3, [r5, #0]
    d192:	2b00      	cmp	r3, #0
    d194:	f000 84fa 	beq.w	db8c <fall_detection+0xa4c>
	volatile float acc_magn_square = 0, max_acc_magn_square = 0;
    d198:	f04f 0a00 	mov.w	sl, #0
	for(i=0;i<ACC_GYRO_FIFO_BUF_LEN*2;i++)
    d19c:	2300      	movs	r3, #0
			acc_magn_square = pow(get_acc_magn(acc_x_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_acc_magn(acc_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_acc_magn(acc_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
    d19e:	ed9f 8bc6 	vldr	d8, [pc, #792]	; d4b8 <fall_detection+0x378>
    d1a2:	4ecf      	ldr	r6, [pc, #828]	; (d4e0 <fall_detection+0x3a0>)
    d1a4:	4fcf      	ldr	r7, [pc, #828]	; (d4e4 <fall_detection+0x3a4>)
	volatile float acc_magn_square = 0, max_acc_magn_square = 0;
    d1a6:	f8cd a078 	str.w	sl, [sp, #120]	; 0x78
    d1aa:	f8cd a07c 	str.w	sl, [sp, #124]	; 0x7c
	for(i=0;i<ACC_GYRO_FIFO_BUF_LEN*2;i++)
    d1ae:	f8ad 3012 	strh.w	r3, [sp, #18]
    d1b2:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    d1b6:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
    d1ba:	f0c0 82c2 	bcc.w	d742 <fall_detection+0x602>
	return max_acc_magn_square;		//do once sqrt() to get acc magnitude
    d1be:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
	{       
		acc_magn_square = acceleration_analyse_fifo();
    d1c0:	4bc9      	ldr	r3, [pc, #804]	; (d4e8 <fall_detection+0x3a8>)
	volatile float angle_degree=0,avg_index=50;
    d1c2:	f8cd a050 	str.w	sl, [sp, #80]	; 0x50
		acc_magn_square = acceleration_analyse_fifo();
    d1c6:	601a      	str	r2, [r3, #0]
	volatile float angle_degree=0,avg_index=50;
    d1c8:	4bc8      	ldr	r3, [pc, #800]	; (d4ec <fall_detection+0x3ac>)
	volatile double angle=0;
    d1ca:	2200      	movs	r2, #0
	volatile float angle_degree=0,avg_index=50;
    d1cc:	9315      	str	r3, [sp, #84]	; 0x54
	volatile double angle=0;
    d1ce:	2300      	movs	r3, #0
	volatile float start_avg_accel_x=0,start_avg_accel_y=0,start_avg_accel_z=0;
    d1d0:	f8cd a058 	str.w	sl, [sp, #88]	; 0x58
    d1d4:	f8cd a05c 	str.w	sl, [sp, #92]	; 0x5c
    d1d8:	f8cd a060 	str.w	sl, [sp, #96]	; 0x60
	volatile float end_avg_accel_x=0, end_avg_accel_y=0, end_avg_accel_z=0;
    d1dc:	f8cd a064 	str.w	sl, [sp, #100]	; 0x64
    d1e0:	f8cd a068 	str.w	sl, [sp, #104]	; 0x68
    d1e4:	f8cd a06c 	str.w	sl, [sp, #108]	; 0x6c
	volatile float num=0,denom=0;
    d1e8:	f8cd a070 	str.w	sl, [sp, #112]	; 0x70
    d1ec:	f8cd a074 	str.w	sl, [sp, #116]	; 0x74
	volatile double angle=0;
    d1f0:	e9cd 2320 	strd	r2, r3, [sp, #128]	; 0x80
	for(i = 0; i < avg_index; i++ )
    d1f4:	2300      	movs	r3, #0
		start_avg_accel_x += acc_x_hist_buffer[i];
    d1f6:	4abe      	ldr	r2, [pc, #760]	; (d4f0 <fall_detection+0x3b0>)
		start_avg_accel_y += acc_y_hist_buffer[i];
    d1f8:	49be      	ldr	r1, [pc, #760]	; (d4f4 <fall_detection+0x3b4>)
		start_avg_accel_z += acc_z_hist_buffer[i];
    d1fa:	48bf      	ldr	r0, [pc, #764]	; (d4f8 <fall_detection+0x3b8>)
	for(i = 0; i < avg_index; i++ )
    d1fc:	f8ad 3010 	strh.w	r3, [sp, #16]
    d200:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    d204:	ed9d 7a15 	vldr	s14, [sp, #84]	; 0x54
    d208:	ee07 3a90 	vmov	s15, r3
    d20c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    d210:	eef4 7ac7 	vcmpe.f32	s15, s14
    d214:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d218:	f100 831c 	bmi.w	d854 <fall_detection+0x714>
	start_avg_accel_x /=avg_index;										//get average for each axis
    d21c:	ed9d 7a15 	vldr	s14, [sp, #84]	; 0x54
    d220:	eddd 6a16 	vldr	s13, [sp, #88]	; 0x58
    d224:	eec6 7a87 	vdiv.f32	s15, s13, s14
    d228:	edcd 7a16 	vstr	s15, [sp, #88]	; 0x58
	start_avg_accel_y /=avg_index;
    d22c:	ed9d 7a15 	vldr	s14, [sp, #84]	; 0x54
    d230:	eddd 6a17 	vldr	s13, [sp, #92]	; 0x5c
    d234:	eec6 7a87 	vdiv.f32	s15, s13, s14
    d238:	edcd 7a17 	vstr	s15, [sp, #92]	; 0x5c
	start_avg_accel_z /=avg_index;
    d23c:	ed9d 7a15 	vldr	s14, [sp, #84]	; 0x54
    d240:	eddd 6a18 	vldr	s13, [sp, #96]	; 0x60
    d244:	eec6 7a87 	vdiv.f32	s15, s13, s14
    d248:	edcd 7a18 	vstr	s15, [sp, #96]	; 0x60
	start_avg_accel_x = get_acc_magn(start_avg_accel_x);			//get acc magnitude
    d24c:	9b16      	ldr	r3, [sp, #88]	; 0x58
	for(i = ACC_GYRO_FIFO_BUF_LEN-avg_index; i < ACC_GYRO_FIFO_BUF_LEN; i++)
    d24e:	ed9f 8aab 	vldr	s16, [pc, #684]	; d4fc <fall_detection+0x3bc>
	start_avg_accel_x = get_acc_magn(start_avg_accel_x);			//get acc magnitude
    d252:	9316      	str	r3, [sp, #88]	; 0x58
	start_avg_accel_y = get_acc_magn(start_avg_accel_y);
    d254:	9b17      	ldr	r3, [sp, #92]	; 0x5c
		end_avg_accel_x += acc_x_cur_buffer[i];
    d256:	4aa2      	ldr	r2, [pc, #648]	; (d4e0 <fall_detection+0x3a0>)
	start_avg_accel_y = get_acc_magn(start_avg_accel_y);
    d258:	9317      	str	r3, [sp, #92]	; 0x5c
	start_avg_accel_z = get_acc_magn(start_avg_accel_z);
    d25a:	9b18      	ldr	r3, [sp, #96]	; 0x60
		end_avg_accel_y += acc_y_cur_buffer[i];
    d25c:	49a1      	ldr	r1, [pc, #644]	; (d4e4 <fall_detection+0x3a4>)
	start_avg_accel_z = get_acc_magn(start_avg_accel_z);
    d25e:	9318      	str	r3, [sp, #96]	; 0x60
	for(i = ACC_GYRO_FIFO_BUF_LEN-avg_index; i < ACC_GYRO_FIFO_BUF_LEN; i++)
    d260:	eddd 7a15 	vldr	s15, [sp, #84]	; 0x54
    d264:	ee78 7a67 	vsub.f32	s15, s16, s15
    d268:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    d26c:	ee17 3a90 	vmov	r3, s15
		end_avg_accel_z += acc_z_cur_buffer[i];
    d270:	48a3      	ldr	r0, [pc, #652]	; (d500 <fall_detection+0x3c0>)
	for(i = ACC_GYRO_FIFO_BUF_LEN-avg_index; i < ACC_GYRO_FIFO_BUF_LEN; i++)
    d272:	b29b      	uxth	r3, r3
    d274:	f8ad 3010 	strh.w	r3, [sp, #16]
    d278:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    d27c:	2bc7      	cmp	r3, #199	; 0xc7
    d27e:	f240 8337 	bls.w	d8f0 <fall_detection+0x7b0>
	end_avg_accel_x /=avg_index;										//get average for each axis
    d282:	ed9d 7a15 	vldr	s14, [sp, #84]	; 0x54
    d286:	eddd 6a19 	vldr	s13, [sp, #100]	; 0x64
    d28a:	eec6 7a87 	vdiv.f32	s15, s13, s14
    d28e:	edcd 7a19 	vstr	s15, [sp, #100]	; 0x64
	end_avg_accel_y /=avg_index;
    d292:	ed9d 7a15 	vldr	s14, [sp, #84]	; 0x54
    d296:	eddd 6a1a 	vldr	s13, [sp, #104]	; 0x68
    d29a:	eec6 7a87 	vdiv.f32	s15, s13, s14
    d29e:	edcd 7a1a 	vstr	s15, [sp, #104]	; 0x68
	end_avg_accel_z /=avg_index;
    d2a2:	ed9d 7a15 	vldr	s14, [sp, #84]	; 0x54
    d2a6:	eddd 6a1b 	vldr	s13, [sp, #108]	; 0x6c
    d2aa:	eec6 7a87 	vdiv.f32	s15, s13, s14
    d2ae:	edcd 7a1b 	vstr	s15, [sp, #108]	; 0x6c
	end_avg_accel_x = get_acc_magn(end_avg_accel_x);			//get acc magnitude
    d2b2:	9b19      	ldr	r3, [sp, #100]	; 0x64
			gyro_magn_square = pow(get_gyro_magn(gyro_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_gyro_magn(gyro_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
    d2b4:	ed9f 9b80 	vldr	d9, [pc, #512]	; d4b8 <fall_detection+0x378>
	end_avg_accel_x = get_acc_magn(end_avg_accel_x);			//get acc magnitude
    d2b8:	9319      	str	r3, [sp, #100]	; 0x64
	end_avg_accel_y = get_acc_magn(end_avg_accel_y);
    d2ba:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    d2bc:	931a      	str	r3, [sp, #104]	; 0x68
	end_avg_accel_z = get_acc_magn(end_avg_accel_z);
    d2be:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    d2c0:	931b      	str	r3, [sp, #108]	; 0x6c
	num= (start_avg_accel_x*end_avg_accel_x) + (start_avg_accel_y*end_avg_accel_y) + (start_avg_accel_z*end_avg_accel_z);
    d2c2:	eddd 5a16 	vldr	s11, [sp, #88]	; 0x58
    d2c6:	ed9d 6a19 	vldr	s12, [sp, #100]	; 0x64
    d2ca:	eddd 7a17 	vldr	s15, [sp, #92]	; 0x5c
    d2ce:	ed9d 5a1a 	vldr	s10, [sp, #104]	; 0x68
    d2d2:	ee67 7a85 	vmul.f32	s15, s15, s10
    d2d6:	eddd 6a18 	vldr	s13, [sp, #96]	; 0x60
    d2da:	ee45 7a86 	vmla.f32	s15, s11, s12
    d2de:	ed9d 7a1b 	vldr	s14, [sp, #108]	; 0x6c
    d2e2:	ee46 7a87 	vmla.f32	s15, s13, s14
    d2e6:	edcd 7a1c 	vstr	s15, [sp, #112]	; 0x70
	denom= (pow(start_avg_accel_x,2) + pow(start_avg_accel_y,2) + pow(start_avg_accel_z,2)) * (pow(end_avg_accel_x,2)+pow(end_avg_accel_y,2)+pow(end_avg_accel_z,2));
    d2ea:	9816      	ldr	r0, [sp, #88]	; 0x58
    d2ec:	f7ff f90c 	bl	c508 <__aeabi_f2d>
    d2f0:	ed9f 1b71 	vldr	d1, [pc, #452]	; d4b8 <fall_detection+0x378>
    d2f4:	ec41 0b10 	vmov	d0, r0, r1
    d2f8:	f001 f826 	bl	e348 <pow>
    d2fc:	9817      	ldr	r0, [sp, #92]	; 0x5c
    d2fe:	ec57 6b10 	vmov	r6, r7, d0
    d302:	f7ff f901 	bl	c508 <__aeabi_f2d>
    d306:	ed9f 1b6c 	vldr	d1, [pc, #432]	; d4b8 <fall_detection+0x378>
    d30a:	ec41 0b10 	vmov	d0, r0, r1
    d30e:	f001 f81b 	bl	e348 <pow>
    d312:	4630      	mov	r0, r6
    d314:	ec53 2b10 	vmov	r2, r3, d0
    d318:	4639      	mov	r1, r7
    d31a:	f7fe ff97 	bl	c24c <__adddf3>
    d31e:	4606      	mov	r6, r0
    d320:	9818      	ldr	r0, [sp, #96]	; 0x60
    d322:	460f      	mov	r7, r1
    d324:	f7ff f8f0 	bl	c508 <__aeabi_f2d>
    d328:	ed9f 1b63 	vldr	d1, [pc, #396]	; d4b8 <fall_detection+0x378>
    d32c:	ec41 0b10 	vmov	d0, r0, r1
    d330:	f001 f80a 	bl	e348 <pow>
    d334:	4630      	mov	r0, r6
    d336:	ec53 2b10 	vmov	r2, r3, d0
    d33a:	4639      	mov	r1, r7
    d33c:	f7fe ff86 	bl	c24c <__adddf3>
    d340:	4606      	mov	r6, r0
    d342:	9819      	ldr	r0, [sp, #100]	; 0x64
    d344:	460f      	mov	r7, r1
    d346:	f7ff f8df 	bl	c508 <__aeabi_f2d>
    d34a:	ed9f 1b5b 	vldr	d1, [pc, #364]	; d4b8 <fall_detection+0x378>
    d34e:	ec41 0b10 	vmov	d0, r0, r1
    d352:	f000 fff9 	bl	e348 <pow>
    d356:	981a      	ldr	r0, [sp, #104]	; 0x68
    d358:	ec59 8b10 	vmov	r8, r9, d0
    d35c:	f7ff f8d4 	bl	c508 <__aeabi_f2d>
    d360:	ed9f 1b55 	vldr	d1, [pc, #340]	; d4b8 <fall_detection+0x378>
    d364:	ec41 0b10 	vmov	d0, r0, r1
    d368:	f000 ffee 	bl	e348 <pow>
    d36c:	4640      	mov	r0, r8
    d36e:	ec53 2b10 	vmov	r2, r3, d0
    d372:	4649      	mov	r1, r9
    d374:	f7fe ff6a 	bl	c24c <__adddf3>
    d378:	4680      	mov	r8, r0
    d37a:	981b      	ldr	r0, [sp, #108]	; 0x6c
    d37c:	4689      	mov	r9, r1
    d37e:	f7ff f8c3 	bl	c508 <__aeabi_f2d>
    d382:	ed9f 1b4d 	vldr	d1, [pc, #308]	; d4b8 <fall_detection+0x378>
    d386:	ec41 0b10 	vmov	d0, r0, r1
    d38a:	f000 ffdd 	bl	e348 <pow>
    d38e:	4640      	mov	r0, r8
    d390:	ec53 2b10 	vmov	r2, r3, d0
    d394:	4649      	mov	r1, r9
    d396:	f7fe ff59 	bl	c24c <__adddf3>
    d39a:	4632      	mov	r2, r6
    d39c:	463b      	mov	r3, r7
    d39e:	f7ff f90b 	bl	c5b8 <__aeabi_dmul>
    d3a2:	f7ff fbc3 	bl	cb2c <__aeabi_d2f>
    d3a6:	901d      	str	r0, [sp, #116]	; 0x74
	angle=acos(num/sqrt(denom));
    d3a8:	9e1c      	ldr	r6, [sp, #112]	; 0x70
    d3aa:	981d      	ldr	r0, [sp, #116]	; 0x74
    d3ac:	f7ff f8ac 	bl	c508 <__aeabi_f2d>
    d3b0:	ec41 0b10 	vmov	d0, r0, r1
    d3b4:	f01c fb1a 	bl	299ec <sqrt>
    d3b8:	ec53 2b10 	vmov	r2, r3, d0
    d3bc:	4630      	mov	r0, r6
    d3be:	e9cd 2300 	strd	r2, r3, [sp]
    d3c2:	f7ff f8a1 	bl	c508 <__aeabi_f2d>
    d3c6:	e9dd 2300 	ldrd	r2, r3, [sp]
    d3ca:	f7ff fa1f 	bl	c80c <__aeabi_ddiv>
    d3ce:	ec41 0b10 	vmov	d0, r0, r1
    d3d2:	f01c fad1 	bl	29978 <acos>
	angle_degree=angle *(180.0f/3.14159265f);						//get angle in degree
    d3d6:	a33a      	add	r3, pc, #232	; (adr r3, d4c0 <fall_detection+0x380>)
    d3d8:	e9d3 2300 	ldrd	r2, r3, [r3]
	angle=acos(num/sqrt(denom));
    d3dc:	ed8d 0b20 	vstr	d0, [sp, #128]	; 0x80
	angle_degree=angle *(180.0f/3.14159265f);						//get angle in degree
    d3e0:	e9dd 0120 	ldrd	r0, r1, [sp, #128]	; 0x80
    d3e4:	f7ff f8e8 	bl	c5b8 <__aeabi_dmul>
    d3e8:	f7ff fba0 	bl	cb2c <__aeabi_d2f>
    d3ec:	9014      	str	r0, [sp, #80]	; 0x50
	return angle_degree;
    d3ee:	9b14      	ldr	r3, [sp, #80]	; 0x50
		cur_angle = angle_analyse_fifo();
    d3f0:	4e44      	ldr	r6, [pc, #272]	; (d504 <fall_detection+0x3c4>)
			gyro_magn_square = pow(get_gyro_magn(gyro_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_gyro_magn(gyro_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
    d3f2:	4f45      	ldr	r7, [pc, #276]	; (d508 <fall_detection+0x3c8>)
		cur_angle = angle_analyse_fifo();
    d3f4:	6033      	str	r3, [r6, #0]
	for(i=0;i<ACC_GYRO_FIFO_BUF_LEN*2;i++)
    d3f6:	2300      	movs	r3, #0
			gyro_magn_square = pow(get_gyro_magn(gyro_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_gyro_magn(gyro_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
    d3f8:	f8df 8118 	ldr.w	r8, [pc, #280]	; d514 <fall_detection+0x3d4>
	volatile float gyro_magn_square = 0, max_gyro_magn_square = 0;
    d3fc:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
    d400:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
	for(i=0;i<ACC_GYRO_FIFO_BUF_LEN*2;i++)
    d404:	f8ad 300e 	strh.w	r3, [sp, #14]
    d408:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    d40c:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
    d410:	f0c0 8299 	bcc.w	d946 <fall_detection+0x806>
	return sqrt(max_gyro_magn_square);		//do once sqrt() to get gyroscope magnitude
    d414:	9813      	ldr	r0, [sp, #76]	; 0x4c
    d416:	f7ff f877 	bl	c508 <__aeabi_f2d>
    d41a:	ec41 0b10 	vmov	d0, r0, r1
    d41e:	f01c fae5 	bl	299ec <sqrt>
    d422:	ec51 0b10 	vmov	r0, r1, d0
    d426:	f7ff fb81 	bl	cb2c <__aeabi_d2f>
	volatile uint8_t i=0;
    d42a:	2200      	movs	r2, #0
	low_angle_degree =    get_input_degree(current_angle, MEDIUM_ANGLE, 0, LOW_ANGLE, MEDIUM_ANGLE);
    d42c:	ed9f 2a37 	vldr	s4, [pc, #220]	; d50c <fall_detection+0x3cc>
		cur_max_gyro_magn = gyroscope_analyse_fifo();
    d430:	4b37      	ldr	r3, [pc, #220]	; (d510 <fall_detection+0x3d0>)
	volatile uint8_t i=0;
    d432:	f88d 200b 	strb.w	r2, [sp, #11]
		cur_max_gyro_magn = gyroscope_analyse_fifo();
    d436:	6018      	str	r0, [r3, #0]
		cur_fuzzy_output = fuzzy_analyse(cur_angle, cur_max_gyro_magn);
    d438:	6833      	ldr	r3, [r6, #0]
	volatile float sum_firestrenths = 0;
    d43a:	f8cd a020 	str.w	sl, [sp, #32]
	volatile float output_value=0;
    d43e:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
	volatile float low_angle_degree=0, medium_angle_degree=0, high_angle_degree=0;
    d442:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
    d446:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
    d44a:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
	volatile float low_gyro_magnitude_degree=0, medium_gyro_magnitude_degree=0, high_gyro_magnitude_degree=0;
    d44e:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
    d452:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
    d456:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
	volatile float current_angle = angle;  // should compute this value continously from sensor
    d45a:	9310      	str	r3, [sp, #64]	; 0x40
	volatile float current_max_gyro_magn = max_gyro_magn;
    d45c:	9011      	str	r0, [sp, #68]	; 0x44
	low_angle_degree =    get_input_degree(current_angle, MEDIUM_ANGLE, 0, LOW_ANGLE, MEDIUM_ANGLE);
    d45e:	eef0 0a42 	vmov.f32	s1, s4
    d462:	eef2 1a0e 	vmov.f32	s3, #46	; 0x41700000  15.0
    d466:	ed9f 1a2e 	vldr	s2, [pc, #184]	; d520 <fall_detection+0x3e0>
    d46a:	ed9d 0a10 	vldr	s0, [sp, #64]	; 0x40
    d46e:	f01e f942 	bl	2b6f6 <get_input_degree>
	medium_angle_degree = get_input_degree(current_angle, LOW_ANGLE, MEDIUM_ANGLE, HIGH_ANGLE, HIGH_ANGLE);
    d472:	ed9f 2a29 	vldr	s4, [pc, #164]	; d518 <fall_detection+0x3d8>
	low_angle_degree =    get_input_degree(current_angle, MEDIUM_ANGLE, 0, LOW_ANGLE, MEDIUM_ANGLE);
    d476:	ed8d 0a0a 	vstr	s0, [sp, #40]	; 0x28
	medium_angle_degree = get_input_degree(current_angle, LOW_ANGLE, MEDIUM_ANGLE, HIGH_ANGLE, HIGH_ANGLE);
    d47a:	eef0 1a42 	vmov.f32	s3, s4
    d47e:	ed9f 1a23 	vldr	s2, [pc, #140]	; d50c <fall_detection+0x3cc>
    d482:	eef2 0a0e 	vmov.f32	s1, #46	; 0x41700000  15.0
    d486:	ed9d 0a10 	vldr	s0, [sp, #64]	; 0x40
    d48a:	f01e f934 	bl	2b6f6 <get_input_degree>
	high_angle_degree =   get_input_degree(current_angle, MEDIUM_ANGLE, HIGH_ANGLE, 0, HIGH_ANGLE);
    d48e:	ed9f 2a22 	vldr	s4, [pc, #136]	; d518 <fall_detection+0x3d8>
	medium_angle_degree = get_input_degree(current_angle, LOW_ANGLE, MEDIUM_ANGLE, HIGH_ANGLE, HIGH_ANGLE);
    d492:	ed8d 0a0b 	vstr	s0, [sp, #44]	; 0x2c
	high_angle_degree =   get_input_degree(current_angle, MEDIUM_ANGLE, HIGH_ANGLE, 0, HIGH_ANGLE);
    d496:	eeb0 1a42 	vmov.f32	s2, s4
    d49a:	eddf 1a21 	vldr	s3, [pc, #132]	; d520 <fall_detection+0x3e0>
    d49e:	eddf 0a1b 	vldr	s1, [pc, #108]	; d50c <fall_detection+0x3cc>
    d4a2:	ed9d 0a10 	vldr	s0, [sp, #64]	; 0x40
    d4a6:	f01e f926 	bl	2b6f6 <get_input_degree>
	low_gyro_magnitude_degree =    get_input_degree(current_max_gyro_magn, MEDIUM_GYRO_MAGNITUDE, 0, LOW_GYRO_MAGNITUDE, MEDIUM_GYRO_MAGNITUDE);
    d4aa:	ed9f 2a1e 	vldr	s4, [pc, #120]	; d524 <fall_detection+0x3e4>
	high_angle_degree =   get_input_degree(current_angle, MEDIUM_ANGLE, HIGH_ANGLE, 0, HIGH_ANGLE);
    d4ae:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
	low_gyro_magnitude_degree =    get_input_degree(current_max_gyro_magn, MEDIUM_GYRO_MAGNITUDE, 0, LOW_GYRO_MAGNITUDE, MEDIUM_GYRO_MAGNITUDE);
    d4b2:	eef0 0a42 	vmov.f32	s1, s4
    d4b6:	e037      	b.n	d528 <fall_detection+0x3e8>
    d4b8:	00000000 	.word	0x00000000
    d4bc:	40000000 	.word	0x40000000
    d4c0:	00000000 	.word	0x00000000
    d4c4:	404ca5dc 	.word	0x404ca5dc
    d4c8:	00030494 	.word	0x00030494
    d4cc:	0003040c 	.word	0x0003040c
    d4d0:	2002ff2d 	.word	0x2002ff2d
    d4d4:	00032076 	.word	0x00032076
    d4d8:	00032087 	.word	0x00032087
    d4dc:	2002ff18 	.word	0x2002ff18
    d4e0:	20020da4 	.word	0x20020da4
    d4e4:	20021d44 	.word	0x20021d44
    d4e8:	20020da0 	.word	0x20020da0
    d4ec:	42480000 	.word	0x42480000
    d4f0:	200210c4 	.word	0x200210c4
    d4f4:	20022064 	.word	0x20022064
    d4f8:	20023004 	.word	0x20023004
    d4fc:	43480000 	.word	0x43480000
    d500:	20022ce4 	.word	0x20022ce4
    d504:	200245fc 	.word	0x200245fc
    d508:	20025f24 	.word	0x20025f24
    d50c:	42200000 	.word	0x42200000
    d510:	20024604 	.word	0x20024604
    d514:	20026ec4 	.word	0x20026ec4
    d518:	42a00000 	.word	0x42a00000
    d51c:	43960000 	.word	0x43960000
    d520:	00000000 	.word	0x00000000
    d524:	43340000 	.word	0x43340000
    d528:	ed5f 1a05 	vldr	s3, [pc, #-20]	; d518 <fall_detection+0x3d8>
    d52c:	ed1f 1a04 	vldr	s2, [pc, #-16]	; d520 <fall_detection+0x3e0>
    d530:	ed9d 0a11 	vldr	s0, [sp, #68]	; 0x44
    d534:	f01e f8df 	bl	2b6f6 <get_input_degree>
	medium_gyro_magnitude_degree = get_input_degree(current_max_gyro_magn, LOW_GYRO_MAGNITUDE, MEDIUM_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE);
    d538:	ed1f 2a08 	vldr	s4, [pc, #-32]	; d51c <fall_detection+0x3dc>
	low_gyro_magnitude_degree =    get_input_degree(current_max_gyro_magn, MEDIUM_GYRO_MAGNITUDE, 0, LOW_GYRO_MAGNITUDE, MEDIUM_GYRO_MAGNITUDE);
    d53c:	ed8d 0a0d 	vstr	s0, [sp, #52]	; 0x34
	medium_gyro_magnitude_degree = get_input_degree(current_max_gyro_magn, LOW_GYRO_MAGNITUDE, MEDIUM_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE);
    d540:	eef0 1a42 	vmov.f32	s3, s4
    d544:	ed1f 1a09 	vldr	s2, [pc, #-36]	; d524 <fall_detection+0x3e4>
    d548:	ed5f 0a0d 	vldr	s1, [pc, #-52]	; d518 <fall_detection+0x3d8>
    d54c:	ed9d 0a11 	vldr	s0, [sp, #68]	; 0x44
    d550:	f01e f8d1 	bl	2b6f6 <get_input_degree>
	high_gyro_magnitude_degree =   get_input_degree(current_max_gyro_magn, MEDIUM_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE, 0, HIGH_GYRO_MAGNITUDE);
    d554:	ed1f 2a0f 	vldr	s4, [pc, #-60]	; d51c <fall_detection+0x3dc>
	medium_gyro_magnitude_degree = get_input_degree(current_max_gyro_magn, LOW_GYRO_MAGNITUDE, MEDIUM_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE);
    d558:	ed8d 0a0e 	vstr	s0, [sp, #56]	; 0x38
	high_gyro_magnitude_degree =   get_input_degree(current_max_gyro_magn, MEDIUM_GYRO_MAGNITUDE, HIGH_GYRO_MAGNITUDE, 0, HIGH_GYRO_MAGNITUDE);
    d55c:	ed9d 0a11 	vldr	s0, [sp, #68]	; 0x44
    d560:	ed5f 1a11 	vldr	s3, [pc, #-68]	; d520 <fall_detection+0x3e0>
    d564:	eeb0 1a42 	vmov.f32	s2, s4
    d568:	ed5f 0a12 	vldr	s1, [pc, #-72]	; d524 <fall_detection+0x3e4>
    d56c:	f01e f8c3 	bl	2b6f6 <get_input_degree>
    d570:	ed8d 0a0f 	vstr	s0, [sp, #60]	; 0x3c
	fire_strength[0] = min(low_angle_degree   , low_gyro_magnitude_degree);
    d574:	ed9d 7a0a 	vldr	s14, [sp, #40]	; 0x28
    d578:	eddd 7a0d 	vldr	s15, [sp, #52]	; 0x34
    d57c:	eeb4 7ae7 	vcmpe.f32	s14, s15
    d580:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d584:	bf4c      	ite	mi
    d586:	9b0a      	ldrmi	r3, [sp, #40]	; 0x28
    d588:	9b0d      	ldrpl	r3, [sp, #52]	; 0x34
		output_value += fire_strength[i] * get_output_from_memship(suspicion_rules[i][2]);
    d58a:	4acb      	ldr	r2, [pc, #812]	; (d8b8 <fall_detection+0x778>)
	fire_strength[0] = min(low_angle_degree   , low_gyro_magnitude_degree);
    d58c:	9323      	str	r3, [sp, #140]	; 0x8c
	fire_strength[1] = min(low_angle_degree   , medium_gyro_magnitude_degree);
    d58e:	ed9d 7a0a 	vldr	s14, [sp, #40]	; 0x28
    d592:	eddd 7a0e 	vldr	s15, [sp, #56]	; 0x38
    d596:	eeb4 7ae7 	vcmpe.f32	s14, s15
    d59a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d59e:	bf4c      	ite	mi
    d5a0:	9b0a      	ldrmi	r3, [sp, #40]	; 0x28
    d5a2:	9b0e      	ldrpl	r3, [sp, #56]	; 0x38
    d5a4:	9324      	str	r3, [sp, #144]	; 0x90
	fire_strength[2] = min(low_angle_degree   , high_gyro_magnitude_degree);
    d5a6:	ed9d 7a0a 	vldr	s14, [sp, #40]	; 0x28
    d5aa:	eddd 7a0f 	vldr	s15, [sp, #60]	; 0x3c
    d5ae:	eeb4 7ae7 	vcmpe.f32	s14, s15
    d5b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d5b6:	bf4c      	ite	mi
    d5b8:	9b0a      	ldrmi	r3, [sp, #40]	; 0x28
    d5ba:	9b0f      	ldrpl	r3, [sp, #60]	; 0x3c
    d5bc:	9325      	str	r3, [sp, #148]	; 0x94
	fire_strength[3] = min(medium_angle_degree, low_gyro_magnitude_degree);
    d5be:	ed9d 7a0b 	vldr	s14, [sp, #44]	; 0x2c
    d5c2:	eddd 7a0d 	vldr	s15, [sp, #52]	; 0x34
    d5c6:	eeb4 7ae7 	vcmpe.f32	s14, s15
    d5ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d5ce:	bf4c      	ite	mi
    d5d0:	9b0b      	ldrmi	r3, [sp, #44]	; 0x2c
    d5d2:	9b0d      	ldrpl	r3, [sp, #52]	; 0x34
    d5d4:	9326      	str	r3, [sp, #152]	; 0x98
	fire_strength[4] = min(medium_angle_degree, medium_gyro_magnitude_degree);
    d5d6:	ed9d 7a0b 	vldr	s14, [sp, #44]	; 0x2c
    d5da:	eddd 7a0e 	vldr	s15, [sp, #56]	; 0x38
    d5de:	eeb4 7ae7 	vcmpe.f32	s14, s15
    d5e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d5e6:	bf4c      	ite	mi
    d5e8:	9b0b      	ldrmi	r3, [sp, #44]	; 0x2c
    d5ea:	9b0e      	ldrpl	r3, [sp, #56]	; 0x38
    d5ec:	9327      	str	r3, [sp, #156]	; 0x9c
	fire_strength[5] = min(medium_angle_degree, high_gyro_magnitude_degree);
    d5ee:	ed9d 7a0b 	vldr	s14, [sp, #44]	; 0x2c
    d5f2:	eddd 7a0f 	vldr	s15, [sp, #60]	; 0x3c
    d5f6:	eeb4 7ae7 	vcmpe.f32	s14, s15
    d5fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d5fe:	bf4c      	ite	mi
    d600:	9b0b      	ldrmi	r3, [sp, #44]	; 0x2c
    d602:	9b0f      	ldrpl	r3, [sp, #60]	; 0x3c
    d604:	9328      	str	r3, [sp, #160]	; 0xa0
	fire_strength[6] = min(high_angle_degree  , low_gyro_magnitude_degree);
    d606:	ed9d 7a0c 	vldr	s14, [sp, #48]	; 0x30
    d60a:	eddd 7a0d 	vldr	s15, [sp, #52]	; 0x34
    d60e:	eeb4 7ae7 	vcmpe.f32	s14, s15
    d612:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d616:	bf4c      	ite	mi
    d618:	9b0c      	ldrmi	r3, [sp, #48]	; 0x30
    d61a:	9b0d      	ldrpl	r3, [sp, #52]	; 0x34
    d61c:	9329      	str	r3, [sp, #164]	; 0xa4
	fire_strength[7] = min(high_angle_degree  , medium_gyro_magnitude_degree);
    d61e:	ed9d 7a0c 	vldr	s14, [sp, #48]	; 0x30
    d622:	eddd 7a0e 	vldr	s15, [sp, #56]	; 0x38
    d626:	eeb4 7ae7 	vcmpe.f32	s14, s15
    d62a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d62e:	bf4c      	ite	mi
    d630:	9b0c      	ldrmi	r3, [sp, #48]	; 0x30
    d632:	9b0e      	ldrpl	r3, [sp, #56]	; 0x38
    d634:	932a      	str	r3, [sp, #168]	; 0xa8
	fire_strength[8] = min(high_angle_degree  , high_gyro_magnitude_degree);
    d636:	ed9d 7a0c 	vldr	s14, [sp, #48]	; 0x30
    d63a:	eddd 7a0f 	vldr	s15, [sp, #60]	; 0x3c
    d63e:	eeb4 7ae7 	vcmpe.f32	s14, s15
    d642:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d646:	bf4c      	ite	mi
    d648:	9b0c      	ldrmi	r3, [sp, #48]	; 0x30
    d64a:	9b0f      	ldrpl	r3, [sp, #60]	; 0x3c
    d64c:	932b      	str	r3, [sp, #172]	; 0xac
	for (i = 0; i < 9; i++)
    d64e:	2300      	movs	r3, #0
    d650:	f88d 300b 	strb.w	r3, [sp, #11]
    d654:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d658:	2b08      	cmp	r3, #8
    d65a:	f240 81d1 	bls.w	da00 <fall_detection+0x8c0>
	output_value /= sum_firestrenths;
    d65e:	ed9d 7a08 	vldr	s14, [sp, #32]
    d662:	eddd 6a09 	vldr	s13, [sp, #36]	; 0x24
    d666:	eec6 7a87 	vdiv.f32	s15, s13, s14
    d66a:	edcd 7a09 	vstr	s15, [sp, #36]	; 0x24
	return output_value;
    d66e:	9b09      	ldr	r3, [sp, #36]	; 0x24
		cur_fuzzy_output = fuzzy_analyse(cur_angle, cur_max_gyro_magn);
    d670:	4e92      	ldr	r6, [pc, #584]	; (d8bc <fall_detection+0x77c>)
	memset(verify_acc_magn,0x00,VERIFY_DATA_BUF_LEN);
    d672:	22c8      	movs	r2, #200	; 0xc8
    d674:	2100      	movs	r1, #0
    d676:	4892      	ldr	r0, [pc, #584]	; (d8c0 <fall_detection+0x780>)
	volatile float std_deviation = 0, variance=0,average = 0;
    d678:	f8cd a014 	str.w	sl, [sp, #20]
		cur_fuzzy_output = fuzzy_analyse(cur_angle, cur_max_gyro_magn);
    d67c:	6033      	str	r3, [r6, #0]
	volatile float std_deviation = 0, variance=0,average = 0;
    d67e:	f8cd a018 	str.w	sl, [sp, #24]
    d682:	f8cd a01c 	str.w	sl, [sp, #28]
	memset(verify_acc_magn,0x00,VERIFY_DATA_BUF_LEN);
    d686:	f021 fe85 	bl	2f394 <memset>
	for(i=0;i<VERIFY_DATA_BUF_LEN;i++)
    d68a:	2300      	movs	r3, #0
		verify_acc_magn[i] = sqrt(pow(get_acc_magn(acc_x_vrif_buffer_1[i]),2)+ pow(get_acc_magn(acc_y_vrif_buffer_1[i]),2) + pow(get_acc_magn(acc_z_vrif_buffer_1[i]),2));
    d68c:	ed9f 9b88 	vldr	d9, [pc, #544]	; d8b0 <fall_detection+0x770>
    d690:	4f8c      	ldr	r7, [pc, #560]	; (d8c4 <fall_detection+0x784>)
    d692:	f8df a258 	ldr.w	sl, [pc, #600]	; d8ec <fall_detection+0x7ac>
	for(i=0;i<VERIFY_DATA_BUF_LEN;i++)
    d696:	f8ad 300c 	strh.w	r3, [sp, #12]
    d69a:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    d69e:	2bc7      	cmp	r3, #199	; 0xc7
    d6a0:	f240 81e6 	bls.w	da70 <fall_detection+0x930>
	average /= (float)VERIFY_DATA_BUF_LEN;
    d6a4:	ed9d 7a07 	vldr	s14, [sp, #28]
	for(i=0;i<VERIFY_DATA_BUF_LEN;i++)
    d6a8:	2300      	movs	r3, #0
	average /= (float)VERIFY_DATA_BUF_LEN;
    d6aa:	eec7 7a08 	vdiv.f32	s15, s14, s16
		variance += pow((verify_acc_magn[i]-average),2);
    d6ae:	ed9f 9b80 	vldr	d9, [pc, #512]	; d8b0 <fall_detection+0x770>
    d6b2:	4f83      	ldr	r7, [pc, #524]	; (d8c0 <fall_detection+0x780>)
	average /= (float)VERIFY_DATA_BUF_LEN;
    d6b4:	edcd 7a07 	vstr	s15, [sp, #28]
	for(i=0;i<VERIFY_DATA_BUF_LEN;i++)
    d6b8:	f8ad 300c 	strh.w	r3, [sp, #12]
    d6bc:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    d6c0:	2bc7      	cmp	r3, #199	; 0xc7
    d6c2:	f240 8236 	bls.w	db32 <fall_detection+0x9f2>
	std_deviation = sqrt(variance/(float)(VERIFY_DATA_BUF_LEN));
    d6c6:	eddd 7a06 	vldr	s15, [sp, #24]
    d6ca:	eec7 7a88 	vdiv.f32	s15, s15, s16
    d6ce:	ee17 0a90 	vmov	r0, s15
    d6d2:	f7fe ff19 	bl	c508 <__aeabi_f2d>
    d6d6:	ec41 0b10 	vmov	d0, r0, r1
    d6da:	f01c f987 	bl	299ec <sqrt>
    d6de:	ec51 0b10 	vmov	r0, r1, d0
    d6e2:	f7ff fa23 	bl	cb2c <__aeabi_d2f>
		LCD_ShowString(20,120,tmpbuf);
		sprintf(tmpbuf, "Fuzzy Output is: %f", cur_fuzzy_output);
		LCD_ShowString(20,140,tmpbuf);
		*/

		if(cur_fuzzy_output > FUZZY_OUT_THRES_DEF)
    d6e6:	edd6 6a00 	vldr	s13, [r6]
    d6ea:	ed9f 7a77 	vldr	s14, [pc, #476]	; d8c8 <fall_detection+0x788>
    d6ee:	eef4 6ac7 	vcmpe.f32	s13, s14
	std_deviation = sqrt(variance/(float)(VERIFY_DATA_BUF_LEN));
    d6f2:	9005      	str	r0, [sp, #20]
	return std_deviation;
    d6f4:	eddd 7a05 	vldr	s15, [sp, #20]
		if(cur_fuzzy_output > FUZZY_OUT_THRES_DEF)
    d6f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		std_devi = fall_verification_fifo_skip();
    d6fc:	4b73      	ldr	r3, [pc, #460]	; (d8cc <fall_detection+0x78c>)
    d6fe:	edc3 7a00 	vstr	s15, [r3]
		if(cur_fuzzy_output > FUZZY_OUT_THRES_DEF)
    d702:	4b73      	ldr	r3, [pc, #460]	; (d8d0 <fall_detection+0x790>)
    d704:	f340 8240 	ble.w	db88 <fall_detection+0xa48>
		{
			if(std_devi < STD_VARIANCE_THRES_DEF)
    d708:	ed9f 7a72 	vldr	s14, [pc, #456]	; d8d4 <fall_detection+0x794>
    d70c:	eef4 7ac7 	vcmpe.f32	s15, s14
    d710:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d714:	f140 8238 	bpl.w	db88 <fall_detection+0xa48>
			{
				fall_result = true;
    d718:	2201      	movs	r2, #1
				fall_result = false; //std not satisfied
			}
		}
		else
		{
			fall_result = false; //fuzzy output not satisfied
    d71a:	701a      	strb	r2, [r3, #0]
		}
		
		curr_vrif_buff_flag = false;
    d71c:	2300      	movs	r3, #0
    d71e:	702b      	strb	r3, [r5, #0]
		sensor_init(); //resets the algorithm, will work continuosly on every tap
    d720:	f007 f9d0 	bl	14ac4 <sensor_init>
		LOG_INF("fall detecting 3");
    d724:	2303      	movs	r3, #3
    d726:	f04f 0000 	mov.w	r0, #0
    d72a:	496b      	ldr	r1, [pc, #428]	; (d8d8 <fall_detection+0x798>)
    d72c:	f363 0007 	bfi	r0, r3, #0, #8
    d730:	f364 108f 	bfi	r0, r4, #6, #10
	} 
}
    d734:	b02c      	add	sp, #176	; 0xb0
    d736:	ecbd 8b06 	vpop	{d8-d10}
    d73a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		LOG_INF("fall detecting 3");
    d73e:	f01f bddb 	b.w	2d2f8 <log_string_sync>
		if(i<ACC_GYRO_FIFO_BUF_LEN)
    d742:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    d746:	2bc7      	cmp	r3, #199	; 0xc7
    d748:	d854      	bhi.n	d7f4 <fall_detection+0x6b4>
			acc_magn_square = pow(get_acc_magn(acc_x_hist_buffer[i]),2)+pow(get_acc_magn(acc_y_hist_buffer[i]),2)+pow(get_acc_magn(acc_z_hist_buffer[i]),2);
    d74a:	f8bd 2012 	ldrh.w	r2, [sp, #18]
    d74e:	4b63      	ldr	r3, [pc, #396]	; (d8dc <fall_detection+0x79c>)
    d750:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    d754:	6818      	ldr	r0, [r3, #0]
    d756:	f7fe fed7 	bl	c508 <__aeabi_f2d>
    d75a:	eeb0 1a48 	vmov.f32	s2, s16
    d75e:	eef0 1a68 	vmov.f32	s3, s17
    d762:	ec41 0b10 	vmov	d0, r0, r1
    d766:	f000 fdef 	bl	e348 <pow>
    d76a:	f8bd 2012 	ldrh.w	r2, [sp, #18]
    d76e:	4b5c      	ldr	r3, [pc, #368]	; (d8e0 <fall_detection+0x7a0>)
    d770:	ec59 8b10 	vmov	r8, r9, d0
    d774:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    d778:	6818      	ldr	r0, [r3, #0]
    d77a:	f7fe fec5 	bl	c508 <__aeabi_f2d>
    d77e:	eeb0 1a48 	vmov.f32	s2, s16
    d782:	eef0 1a68 	vmov.f32	s3, s17
    d786:	ec41 0b10 	vmov	d0, r0, r1
    d78a:	f000 fddd 	bl	e348 <pow>
    d78e:	4640      	mov	r0, r8
    d790:	ec53 2b10 	vmov	r2, r3, d0
    d794:	4649      	mov	r1, r9
    d796:	f7fe fd59 	bl	c24c <__adddf3>
    d79a:	4680      	mov	r8, r0
    d79c:	4689      	mov	r9, r1
    d79e:	f8bd 2012 	ldrh.w	r2, [sp, #18]
    d7a2:	4b50      	ldr	r3, [pc, #320]	; (d8e4 <fall_detection+0x7a4>)
			acc_magn_square = pow(get_acc_magn(acc_x_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_acc_magn(acc_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_acc_magn(acc_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
    d7a4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    d7a8:	6818      	ldr	r0, [r3, #0]
    d7aa:	f7fe fead 	bl	c508 <__aeabi_f2d>
    d7ae:	eeb0 1a48 	vmov.f32	s2, s16
    d7b2:	eef0 1a68 	vmov.f32	s3, s17
    d7b6:	ec41 0b10 	vmov	d0, r0, r1
    d7ba:	f000 fdc5 	bl	e348 <pow>
    d7be:	4640      	mov	r0, r8
    d7c0:	ec53 2b10 	vmov	r2, r3, d0
    d7c4:	4649      	mov	r1, r9
    d7c6:	f7fe fd41 	bl	c24c <__adddf3>
    d7ca:	f7ff f9af 	bl	cb2c <__aeabi_d2f>
    d7ce:	901e      	str	r0, [sp, #120]	; 0x78
		if(acc_magn_square > max_acc_magn_square) max_acc_magn_square = acc_magn_square;	//get the maximum acc magnitude square
    d7d0:	ed9d 7a1e 	vldr	s14, [sp, #120]	; 0x78
    d7d4:	eddd 7a1f 	vldr	s15, [sp, #124]	; 0x7c
    d7d8:	eeb4 7ae7 	vcmpe.f32	s14, s15
    d7dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d7e0:	bfc4      	itt	gt
    d7e2:	9b1e      	ldrgt	r3, [sp, #120]	; 0x78
    d7e4:	931f      	strgt	r3, [sp, #124]	; 0x7c
	for(i=0;i<ACC_GYRO_FIFO_BUF_LEN*2;i++)
    d7e6:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    d7ea:	3301      	adds	r3, #1
    d7ec:	b29b      	uxth	r3, r3
    d7ee:	f8ad 3012 	strh.w	r3, [sp, #18]
    d7f2:	e4de      	b.n	d1b2 <fall_detection+0x72>
			acc_magn_square = pow(get_acc_magn(acc_x_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_acc_magn(acc_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_acc_magn(acc_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
    d7f4:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    d7f8:	3bc8      	subs	r3, #200	; 0xc8
    d7fa:	eb06 0383 	add.w	r3, r6, r3, lsl #2
    d7fe:	6818      	ldr	r0, [r3, #0]
    d800:	f7fe fe82 	bl	c508 <__aeabi_f2d>
    d804:	eeb0 1a48 	vmov.f32	s2, s16
    d808:	eef0 1a68 	vmov.f32	s3, s17
    d80c:	ec41 0b10 	vmov	d0, r0, r1
    d810:	f000 fd9a 	bl	e348 <pow>
    d814:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    d818:	ec59 8b10 	vmov	r8, r9, d0
    d81c:	3bc8      	subs	r3, #200	; 0xc8
    d81e:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    d822:	6818      	ldr	r0, [r3, #0]
    d824:	f7fe fe70 	bl	c508 <__aeabi_f2d>
    d828:	eeb0 1a48 	vmov.f32	s2, s16
    d82c:	eef0 1a68 	vmov.f32	s3, s17
    d830:	ec41 0b10 	vmov	d0, r0, r1
    d834:	f000 fd88 	bl	e348 <pow>
    d838:	4640      	mov	r0, r8
    d83a:	ec53 2b10 	vmov	r2, r3, d0
    d83e:	4649      	mov	r1, r9
    d840:	f7fe fd04 	bl	c24c <__adddf3>
    d844:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    d848:	4680      	mov	r8, r0
    d84a:	f1a3 02c8 	sub.w	r2, r3, #200	; 0xc8
    d84e:	4689      	mov	r9, r1
    d850:	4b25      	ldr	r3, [pc, #148]	; (d8e8 <fall_detection+0x7a8>)
    d852:	e7a7      	b.n	d7a4 <fall_detection+0x664>
		start_avg_accel_x += acc_x_hist_buffer[i];
    d854:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    d858:	eddd 7a16 	vldr	s15, [sp, #88]	; 0x58
    d85c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    d860:	ed93 7a00 	vldr	s14, [r3]
    d864:	ee77 7a87 	vadd.f32	s15, s15, s14
    d868:	edcd 7a16 	vstr	s15, [sp, #88]	; 0x58
		start_avg_accel_y += acc_y_hist_buffer[i];
    d86c:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    d870:	eddd 7a17 	vldr	s15, [sp, #92]	; 0x5c
    d874:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    d878:	ed93 7a00 	vldr	s14, [r3]
    d87c:	ee77 7a87 	vadd.f32	s15, s15, s14
    d880:	edcd 7a17 	vstr	s15, [sp, #92]	; 0x5c
		start_avg_accel_z += acc_z_hist_buffer[i];
    d884:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    d888:	eddd 7a18 	vldr	s15, [sp, #96]	; 0x60
    d88c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    d890:	ed93 7a00 	vldr	s14, [r3]
    d894:	ee77 7a87 	vadd.f32	s15, s15, s14
    d898:	edcd 7a18 	vstr	s15, [sp, #96]	; 0x60
	for(i = 0; i < avg_index; i++ )
    d89c:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    d8a0:	3301      	adds	r3, #1
    d8a2:	b29b      	uxth	r3, r3
    d8a4:	f8ad 3010 	strh.w	r3, [sp, #16]
    d8a8:	e4aa      	b.n	d200 <fall_detection+0xc0>
    d8aa:	bf00      	nop
    d8ac:	f3af 8000 	nop.w
    d8b0:	00000000 	.word	0x00000000
    d8b4:	40000000 	.word	0x40000000
    d8b8:	2003b5b1 	.word	0x2003b5b1
    d8bc:	20024600 	.word	0x20024600
    d8c0:	20027e88 	.word	0x20027e88
    d8c4:	20021a24 	.word	0x20021a24
    d8c8:	42340000 	.word	0x42340000
    d8cc:	20027e84 	.word	0x20027e84
    d8d0:	2002ff19 	.word	0x2002ff19
    d8d4:	3e051eb8 	.word	0x3e051eb8
    d8d8:	00032098 	.word	0x00032098
    d8dc:	200210c4 	.word	0x200210c4
    d8e0:	20022064 	.word	0x20022064
    d8e4:	20023004 	.word	0x20023004
    d8e8:	20022ce4 	.word	0x20022ce4
    d8ec:	200229c4 	.word	0x200229c4
		end_avg_accel_x += acc_x_cur_buffer[i];
    d8f0:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    d8f4:	eddd 7a19 	vldr	s15, [sp, #100]	; 0x64
    d8f8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    d8fc:	ed93 7a00 	vldr	s14, [r3]
    d900:	ee77 7a87 	vadd.f32	s15, s15, s14
    d904:	edcd 7a19 	vstr	s15, [sp, #100]	; 0x64
		end_avg_accel_y += acc_y_cur_buffer[i];
    d908:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    d90c:	eddd 7a1a 	vldr	s15, [sp, #104]	; 0x68
    d910:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    d914:	ed93 7a00 	vldr	s14, [r3]
    d918:	ee77 7a87 	vadd.f32	s15, s15, s14
    d91c:	edcd 7a1a 	vstr	s15, [sp, #104]	; 0x68
		end_avg_accel_z += acc_z_cur_buffer[i];
    d920:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    d924:	eddd 7a1b 	vldr	s15, [sp, #108]	; 0x6c
    d928:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    d92c:	ed93 7a00 	vldr	s14, [r3]
    d930:	ee77 7a87 	vadd.f32	s15, s15, s14
    d934:	edcd 7a1b 	vstr	s15, [sp, #108]	; 0x6c
	for(i = ACC_GYRO_FIFO_BUF_LEN-avg_index; i < ACC_GYRO_FIFO_BUF_LEN; i++)
    d938:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    d93c:	3301      	adds	r3, #1
    d93e:	b29b      	uxth	r3, r3
    d940:	f8ad 3010 	strh.w	r3, [sp, #16]
    d944:	e498      	b.n	d278 <fall_detection+0x138>
		if(i < ACC_GYRO_FIFO_BUF_LEN)
    d946:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    d94a:	2bc7      	cmp	r3, #199	; 0xc7
    d94c:	d83e      	bhi.n	d9cc <fall_detection+0x88c>
			gyro_magn_square = pow(get_gyro_magn(gyro_y_hist_buffer[i]),2)+pow(get_gyro_magn(gyro_z_hist_buffer[i]),2);
    d94e:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    d952:	4b91      	ldr	r3, [pc, #580]	; (db98 <fall_detection+0xa58>)
    d954:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    d958:	6818      	ldr	r0, [r3, #0]
    d95a:	f7fe fdd5 	bl	c508 <__aeabi_f2d>
    d95e:	eeb0 1a49 	vmov.f32	s2, s18
    d962:	eef0 1a69 	vmov.f32	s3, s19
    d966:	ec41 0b10 	vmov	d0, r0, r1
    d96a:	f000 fced 	bl	e348 <pow>
    d96e:	eeb0 aa40 	vmov.f32	s20, s0
    d972:	eef0 aa60 	vmov.f32	s21, s1
    d976:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    d97a:	4b88      	ldr	r3, [pc, #544]	; (db9c <fall_detection+0xa5c>)
    d97c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
			gyro_magn_square = pow(get_gyro_magn(gyro_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_gyro_magn(gyro_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
    d980:	6818      	ldr	r0, [r3, #0]
    d982:	f7fe fdc1 	bl	c508 <__aeabi_f2d>
    d986:	eeb0 1a49 	vmov.f32	s2, s18
    d98a:	eef0 1a69 	vmov.f32	s3, s19
    d98e:	ec41 0b10 	vmov	d0, r0, r1
    d992:	f000 fcd9 	bl	e348 <pow>
    d996:	ec51 0b1a 	vmov	r0, r1, d10
    d99a:	ec53 2b10 	vmov	r2, r3, d0
    d99e:	f7fe fc55 	bl	c24c <__adddf3>
    d9a2:	f7ff f8c3 	bl	cb2c <__aeabi_d2f>
    d9a6:	9012      	str	r0, [sp, #72]	; 0x48
		if(gyro_magn_square > max_gyro_magn_square) max_gyro_magn_square = gyro_magn_square;	//get the maximum gyroscope magnitude square
    d9a8:	ed9d 7a12 	vldr	s14, [sp, #72]	; 0x48
    d9ac:	eddd 7a13 	vldr	s15, [sp, #76]	; 0x4c
    d9b0:	eeb4 7ae7 	vcmpe.f32	s14, s15
    d9b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    d9b8:	bfc4      	itt	gt
    d9ba:	9b12      	ldrgt	r3, [sp, #72]	; 0x48
    d9bc:	9313      	strgt	r3, [sp, #76]	; 0x4c
	for(i=0;i<ACC_GYRO_FIFO_BUF_LEN*2;i++)
    d9be:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    d9c2:	3301      	adds	r3, #1
    d9c4:	b29b      	uxth	r3, r3
    d9c6:	f8ad 300e 	strh.w	r3, [sp, #14]
    d9ca:	e51d      	b.n	d408 <fall_detection+0x2c8>
			gyro_magn_square = pow(get_gyro_magn(gyro_y_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2)+pow(get_gyro_magn(gyro_z_cur_buffer[i-ACC_GYRO_FIFO_BUF_LEN]),2);
    d9cc:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    d9d0:	3bc8      	subs	r3, #200	; 0xc8
    d9d2:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    d9d6:	6818      	ldr	r0, [r3, #0]
    d9d8:	f7fe fd96 	bl	c508 <__aeabi_f2d>
    d9dc:	eeb0 1a49 	vmov.f32	s2, s18
    d9e0:	eef0 1a69 	vmov.f32	s3, s19
    d9e4:	ec41 0b10 	vmov	d0, r0, r1
    d9e8:	f000 fcae 	bl	e348 <pow>
    d9ec:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    d9f0:	eeb0 aa40 	vmov.f32	s20, s0
    d9f4:	eef0 aa60 	vmov.f32	s21, s1
    d9f8:	3bc8      	subs	r3, #200	; 0xc8
    d9fa:	eb08 0383 	add.w	r3, r8, r3, lsl #2
    d9fe:	e7bf      	b.n	d980 <fall_detection+0x840>
		output_value += fire_strength[i] * get_output_from_memship(suspicion_rules[i][2]);
    da00:	f89d 300b 	ldrb.w	r3, [sp, #11]
    da04:	a92c      	add	r1, sp, #176	; 0xb0
    da06:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    da0a:	ed53 6a09 	vldr	s13, [r3, #-36]	; 0xffffffdc
    da0e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    da12:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    da16:	4413      	add	r3, r2
    da18:	789b      	ldrb	r3, [r3, #2]
    da1a:	b2db      	uxtb	r3, r3
	if(memship == LOW_MS)    
    da1c:	2b01      	cmp	r3, #1
    da1e:	d023      	beq.n	da68 <fall_detection+0x928>
	else if(memship == MEDIUM_MS) 
    da20:	2b02      	cmp	r3, #2
    da22:	d023      	beq.n	da6c <fall_detection+0x92c>
		return 0;
    da24:	2b03      	cmp	r3, #3
    da26:	bf0c      	ite	eq
    da28:	2332      	moveq	r3, #50	; 0x32
    da2a:	2300      	movne	r3, #0
		output_value += fire_strength[i] * get_output_from_memship(suspicion_rules[i][2]);
    da2c:	ee07 3a90 	vmov	s15, r3
    da30:	ed9d 7a09 	vldr	s14, [sp, #36]	; 0x24
    da34:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    da38:	ee07 7aa6 	vmla.f32	s14, s15, s13
    da3c:	ed8d 7a09 	vstr	s14, [sp, #36]	; 0x24
		sum_firestrenths += fire_strength[i];
    da40:	f89d 300b 	ldrb.w	r3, [sp, #11]
    da44:	a92c      	add	r1, sp, #176	; 0xb0
    da46:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    da4a:	ed53 7a09 	vldr	s15, [r3, #-36]	; 0xffffffdc
    da4e:	ed9d 7a08 	vldr	s14, [sp, #32]
    da52:	ee77 7a87 	vadd.f32	s15, s15, s14
    da56:	edcd 7a08 	vstr	s15, [sp, #32]
	for (i = 0; i < 9; i++)
    da5a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    da5e:	3301      	adds	r3, #1
    da60:	b2db      	uxtb	r3, r3
    da62:	f88d 300b 	strb.w	r3, [sp, #11]
    da66:	e5f5      	b.n	d654 <fall_detection+0x514>
		return WEIGHT_VALUE_10;
    da68:	230a      	movs	r3, #10
    da6a:	e7df      	b.n	da2c <fall_detection+0x8ec>
		return WEIGHT_VALUE_30;
    da6c:	231e      	movs	r3, #30
    da6e:	e7dd      	b.n	da2c <fall_detection+0x8ec>
		verify_acc_magn[i] = sqrt(pow(get_acc_magn(acc_x_vrif_buffer_1[i]),2)+ pow(get_acc_magn(acc_y_vrif_buffer_1[i]),2) + pow(get_acc_magn(acc_z_vrif_buffer_1[i]),2));
    da70:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    da74:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    da78:	6818      	ldr	r0, [r3, #0]
    da7a:	f7fe fd45 	bl	c508 <__aeabi_f2d>
    da7e:	eeb0 1a49 	vmov.f32	s2, s18
    da82:	eef0 1a69 	vmov.f32	s3, s19
    da86:	ec41 0b10 	vmov	d0, r0, r1
    da8a:	f000 fc5d 	bl	e348 <pow>
    da8e:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    da92:	ec59 8b10 	vmov	r8, r9, d0
    da96:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
    da9a:	6818      	ldr	r0, [r3, #0]
    da9c:	f7fe fd34 	bl	c508 <__aeabi_f2d>
    daa0:	eeb0 1a49 	vmov.f32	s2, s18
    daa4:	eef0 1a69 	vmov.f32	s3, s19
    daa8:	ec41 0b10 	vmov	d0, r0, r1
    daac:	f000 fc4c 	bl	e348 <pow>
    dab0:	4640      	mov	r0, r8
    dab2:	ec53 2b10 	vmov	r2, r3, d0
    dab6:	4649      	mov	r1, r9
    dab8:	f7fe fbc8 	bl	c24c <__adddf3>
    dabc:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    dac0:	4b37      	ldr	r3, [pc, #220]	; (dba0 <fall_detection+0xa60>)
    dac2:	4680      	mov	r8, r0
    dac4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    dac8:	6818      	ldr	r0, [r3, #0]
    daca:	4689      	mov	r9, r1
    dacc:	f7fe fd1c 	bl	c508 <__aeabi_f2d>
    dad0:	eeb0 1a49 	vmov.f32	s2, s18
    dad4:	eef0 1a69 	vmov.f32	s3, s19
    dad8:	ec41 0b10 	vmov	d0, r0, r1
    dadc:	f000 fc34 	bl	e348 <pow>
    dae0:	4640      	mov	r0, r8
    dae2:	ec53 2b10 	vmov	r2, r3, d0
    dae6:	4649      	mov	r1, r9
    dae8:	f7fe fbb0 	bl	c24c <__adddf3>
    daec:	ec41 0b10 	vmov	d0, r0, r1
    daf0:	f01b ff7c 	bl	299ec <sqrt>
    daf4:	ec51 0b10 	vmov	r0, r1, d0
    daf8:	f7ff f818 	bl	cb2c <__aeabi_d2f>
    dafc:	f8bd 900c 	ldrh.w	r9, [sp, #12]
    db00:	f8df 80a0 	ldr.w	r8, [pc, #160]	; dba4 <fall_detection+0xa64>
		average += verify_acc_magn[i];
    db04:	f8bd 300c 	ldrh.w	r3, [sp, #12]
		verify_acc_magn[i] = sqrt(pow(get_acc_magn(acc_x_vrif_buffer_1[i]),2)+ pow(get_acc_magn(acc_y_vrif_buffer_1[i]),2) + pow(get_acc_magn(acc_z_vrif_buffer_1[i]),2));
    db08:	eb08 0989 	add.w	r9, r8, r9, lsl #2
    db0c:	f8c9 0000 	str.w	r0, [r9]
		average += verify_acc_magn[i];
    db10:	eb08 0883 	add.w	r8, r8, r3, lsl #2
    db14:	eddd 7a07 	vldr	s15, [sp, #28]
    db18:	ed98 7a00 	vldr	s14, [r8]
    db1c:	ee77 7a87 	vadd.f32	s15, s15, s14
    db20:	edcd 7a07 	vstr	s15, [sp, #28]
	for(i=0;i<VERIFY_DATA_BUF_LEN;i++)
    db24:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    db28:	3301      	adds	r3, #1
    db2a:	b29b      	uxth	r3, r3
    db2c:	f8ad 300c 	strh.w	r3, [sp, #12]
    db30:	e5b3      	b.n	d69a <fall_detection+0x55a>
		variance += pow((verify_acc_magn[i]-average),2);
    db32:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    db36:	eddd 7a07 	vldr	s15, [sp, #28]
    db3a:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    db3e:	ed93 7a00 	vldr	s14, [r3]
    db42:	ee77 7a67 	vsub.f32	s15, s14, s15
    db46:	ee17 0a90 	vmov	r0, s15
    db4a:	f7fe fcdd 	bl	c508 <__aeabi_f2d>
    db4e:	eeb0 1a49 	vmov.f32	s2, s18
    db52:	eef0 1a69 	vmov.f32	s3, s19
    db56:	ec41 0b10 	vmov	d0, r0, r1
    db5a:	f000 fbf5 	bl	e348 <pow>
    db5e:	ec53 2b10 	vmov	r2, r3, d0
    db62:	9806      	ldr	r0, [sp, #24]
    db64:	e9cd 2300 	strd	r2, r3, [sp]
    db68:	f7fe fcce 	bl	c508 <__aeabi_f2d>
    db6c:	e9dd 2300 	ldrd	r2, r3, [sp]
    db70:	f7fe fb6c 	bl	c24c <__adddf3>
    db74:	f7fe ffda 	bl	cb2c <__aeabi_d2f>
    db78:	9006      	str	r0, [sp, #24]
	for(i=0;i<VERIFY_DATA_BUF_LEN;i++)
    db7a:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    db7e:	3301      	adds	r3, #1
    db80:	b29b      	uxth	r3, r3
    db82:	f8ad 300c 	strh.w	r3, [sp, #12]
    db86:	e599      	b.n	d6bc <fall_detection+0x57c>
			fall_result = false; //fuzzy output not satisfied
    db88:	2200      	movs	r2, #0
    db8a:	e5c6      	b.n	d71a <fall_detection+0x5da>
}
    db8c:	b02c      	add	sp, #176	; 0xb0
    db8e:	ecbd 8b06 	vpop	{d8-d10}
    db92:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    db96:	bf00      	nop
    db98:	20026244 	.word	0x20026244
    db9c:	200271e4 	.word	0x200271e4
    dba0:	20023964 	.word	0x20023964
    dba4:	20027e88 	.word	0x20027e88

0000dba8 <UpdateIMUData>:
{
	lsm6dso_number_of_steps_get(&imu_dev_ctx, steps);
}

void UpdateIMUData(void)
{
    dba8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	GetImuSteps(&g_steps);
    dbaa:	4c1f      	ldr	r4, [pc, #124]	; (dc28 <UpdateIMUData+0x80>)
    dbac:	4620      	mov	r0, r4
    dbae:	f007 fb63 	bl	15278 <GetImuSteps>

	g_distance = 0.7*g_steps;
    dbb2:	8825      	ldrh	r5, [r4, #0]
    dbb4:	4628      	mov	r0, r5
    dbb6:	f7fe fc95 	bl	c4e4 <__aeabi_i2d>
    dbba:	a317      	add	r3, pc, #92	; (adr r3, dc18 <UpdateIMUData+0x70>)
    dbbc:	e9d3 2300 	ldrd	r2, r3, [r3]
    dbc0:	f7fe fcfa 	bl	c5b8 <__aeabi_dmul>
    dbc4:	f7fe ff92 	bl	caec <__aeabi_d2uiz>
    dbc8:	b284      	uxth	r4, r0
	g_calorie = 0.8214*60*(g_distance/1000);
    dbca:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	g_distance = 0.7*g_steps;
    dbce:	4b17      	ldr	r3, [pc, #92]	; (dc2c <UpdateIMUData+0x84>)
	g_calorie = 0.8214*60*(g_distance/1000);
    dbd0:	fbb4 f0f0 	udiv	r0, r4, r0
	g_distance = 0.7*g_steps;
    dbd4:	801c      	strh	r4, [r3, #0]
	g_calorie = 0.8214*60*(g_distance/1000);
    dbd6:	f7fe fc85 	bl	c4e4 <__aeabi_i2d>
    dbda:	a311      	add	r3, pc, #68	; (adr r3, dc20 <UpdateIMUData+0x78>)
    dbdc:	e9d3 2300 	ldrd	r2, r3, [r3]
    dbe0:	f7fe fcea 	bl	c5b8 <__aeabi_dmul>
    dbe4:	f7fe ff82 	bl	caec <__aeabi_d2uiz>
    dbe8:	4b11      	ldr	r3, [pc, #68]	; (dc30 <UpdateIMUData+0x88>)
    dbea:	b282      	uxth	r2, r0
    dbec:	801a      	strh	r2, [r3, #0]

	LOG_INF("g_steps:%d,g_distance:%d,g_calorie:%d\n", g_steps, g_distance, g_calorie);
    dbee:	f04f 0000 	mov.w	r0, #0
    dbf2:	2303      	movs	r3, #3
    dbf4:	490f      	ldr	r1, [pc, #60]	; (dc34 <UpdateIMUData+0x8c>)
    dbf6:	f363 0007 	bfi	r0, r3, #0, #8
    dbfa:	4b0f      	ldr	r3, [pc, #60]	; (dc38 <UpdateIMUData+0x90>)
    dbfc:	9200      	str	r2, [sp, #0]
    dbfe:	1a5b      	subs	r3, r3, r1
    dc00:	08db      	lsrs	r3, r3, #3
    dc02:	f363 108f 	bfi	r0, r3, #6, #10
    dc06:	462a      	mov	r2, r5
    dc08:	4623      	mov	r3, r4
    dc0a:	490c      	ldr	r1, [pc, #48]	; (dc3c <UpdateIMUData+0x94>)
    dc0c:	f01f fb74 	bl	2d2f8 <log_string_sync>
}
    dc10:	b003      	add	sp, #12
    dc12:	bd30      	pop	{r4, r5, pc}
    dc14:	f3af 8000 	nop.w
    dc18:	66666666 	.word	0x66666666
    dc1c:	3fe66666 	.word	0x3fe66666
    dc20:	1cac0831 	.word	0x1cac0831
    dc24:	4048a45a 	.word	0x4048a45a
    dc28:	2002d47c 	.word	0x2002d47c
    dc2c:	2002d47a 	.word	0x2002d47a
    dc30:	2002d478 	.word	0x2002d478
    dc34:	0003040c 	.word	0x0003040c
    dc38:	00030494 	.word	0x00030494
    dc3c:	0003204f 	.word	0x0003204f

0000dc40 <fall_get_location_data_reply>:

	NBSendFallWifiData(reply, strlen(reply));
}

void fall_get_location_data_reply(nrf_gnss_pvt_data_frame_t gps_data)
{
    dc40:	b084      	sub	sp, #16
    dc42:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    dc46:	b0a4      	sub	sp, #144	; 0x90
    dc48:	ac2a      	add	r4, sp, #168	; 0xa8
    dc4a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	u8_t reply[128] = {0};
    dc4e:	2280      	movs	r2, #128	; 0x80
    dc50:	e9dd 672a 	ldrd	r6, r7, [sp, #168]	; 0xa8
    dc54:	e9dd 452c 	ldrd	r4, r5, [sp, #176]	; 0xb0
    dc58:	2100      	movs	r1, #0
    dc5a:	a804      	add	r0, sp, #16
    dc5c:	f021 fb9a 	bl	2f394 <memset>
	u8_t tmpbuf[8] = {0};
    dc60:	2300      	movs	r3, #0
	u32_t tmp1;
	double tmp2;

	//latitude
	if(gps_data.latitude < 0)
    dc62:	2200      	movs	r2, #0
	u8_t tmpbuf[8] = {0};
    dc64:	e9cd 3302 	strd	r3, r3, [sp, #8]
	if(gps_data.latitude < 0)
    dc68:	4630      	mov	r0, r6
    dc6a:	2300      	movs	r3, #0
    dc6c:	4639      	mov	r1, r7
    dc6e:	f7fe ff15 	bl	ca9c <__aeabi_dcmplt>
    dc72:	b138      	cbz	r0, dc84 <fall_get_location_data_reply+0x44>
	{
		strcat(reply, "-");
    dc74:	2280      	movs	r2, #128	; 0x80
    dc76:	4978      	ldr	r1, [pc, #480]	; (de58 <fall_get_location_data_reply+0x218>)
    dc78:	a804      	add	r0, sp, #16
    dc7a:	f021 fce7 	bl	2f64c <__strcat_chk>
		gps_data.latitude = -gps_data.latitude;
    dc7e:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
    dc82:	461f      	mov	r7, r3
	}

	tmp1 = (u32_t)(gps_data.latitude);	//
    dc84:	4639      	mov	r1, r7
    dc86:	4630      	mov	r0, r6
    dc88:	f7fe ff30 	bl	caec <__aeabi_d2uiz>
	tmp2 = gps_data.latitude - tmp1;		//
	//integer
	sprintf(tmpbuf, "%d", tmp1);
    dc8c:	2208      	movs	r2, #8
	tmp1 = (u32_t)(gps_data.latitude);	//
    dc8e:	4680      	mov	r8, r0
	sprintf(tmpbuf, "%d", tmp1);
    dc90:	4b72      	ldr	r3, [pc, #456]	; (de5c <fall_get_location_data_reply+0x21c>)
    dc92:	9000      	str	r0, [sp, #0]
    dc94:	2100      	movs	r1, #0
    dc96:	eb0d 0002 	add.w	r0, sp, r2
    dc9a:	f021 fcbd 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);
    dc9e:	2280      	movs	r2, #128	; 0x80
    dca0:	a902      	add	r1, sp, #8
    dca2:	a804      	add	r0, sp, #16
    dca4:	f021 fcd2 	bl	2f64c <__strcat_chk>
	//dot
	strcat(reply, ".");
    dca8:	2280      	movs	r2, #128	; 0x80
    dcaa:	496d      	ldr	r1, [pc, #436]	; (de60 <fall_get_location_data_reply+0x220>)
    dcac:	a804      	add	r0, sp, #16
    dcae:	f021 fccd 	bl	2f64c <__strcat_chk>
	tmp2 = gps_data.latitude - tmp1;		//
    dcb2:	4640      	mov	r0, r8
    dcb4:	f7fe fc06 	bl	c4c4 <__aeabi_ui2d>
    dcb8:	4602      	mov	r2, r0
    dcba:	460b      	mov	r3, r1
    dcbc:	4630      	mov	r0, r6
    dcbe:	4639      	mov	r1, r7
    dcc0:	f7fe fac2 	bl	c248 <__aeabi_dsub>
	//decimal
	tmp1 = (u32_t)(tmp2*1000000);
    dcc4:	a362      	add	r3, pc, #392	; (adr r3, de50 <fall_get_location_data_reply+0x210>)
    dcc6:	e9d3 2300 	ldrd	r2, r3, [r3]
    dcca:	f7fe fc75 	bl	c5b8 <__aeabi_dmul>
    dcce:	f7fe ff0d 	bl	caec <__aeabi_d2uiz>
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/10000));
    dcd2:	f242 7710 	movw	r7, #10000	; 0x2710
	tmp1 = (u32_t)(tmp2*1000000);
    dcd6:	4680      	mov	r8, r0
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/10000));
    dcd8:	fbb0 f6f7 	udiv	r6, r0, r7
    dcdc:	2208      	movs	r2, #8
    dcde:	b2f3      	uxtb	r3, r6
	strcat(reply, tmpbuf);
	tmp1 = tmp1%10000;
    dce0:	fb07 8616 	mls	r6, r7, r6, r8
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/100));
    dce4:	f04f 0864 	mov.w	r8, #100	; 0x64
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/10000));
    dce8:	9300      	str	r3, [sp, #0]
    dcea:	2100      	movs	r1, #0
    dcec:	4b5d      	ldr	r3, [pc, #372]	; (de64 <fall_get_location_data_reply+0x224>)
    dcee:	eb0d 0002 	add.w	r0, sp, r2
    dcf2:	f021 fc91 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);
    dcf6:	2280      	movs	r2, #128	; 0x80
    dcf8:	a902      	add	r1, sp, #8
    dcfa:	a804      	add	r0, sp, #16
    dcfc:	f021 fca6 	bl	2f64c <__strcat_chk>
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/100));
    dd00:	2208      	movs	r2, #8
    dd02:	fbb6 f7f8 	udiv	r7, r6, r8
    dd06:	4b57      	ldr	r3, [pc, #348]	; (de64 <fall_get_location_data_reply+0x224>)
    dd08:	2100      	movs	r1, #0
    dd0a:	eb0d 0002 	add.w	r0, sp, r2
    dd0e:	9700      	str	r7, [sp, #0]
    dd10:	f021 fc82 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);	
    dd14:	2280      	movs	r2, #128	; 0x80
    dd16:	a902      	add	r1, sp, #8
    dd18:	a804      	add	r0, sp, #16
    dd1a:	f021 fc97 	bl	2f64c <__strcat_chk>
	tmp1 = tmp1%100;
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1));
    dd1e:	2208      	movs	r2, #8
	tmp1 = tmp1%100;
    dd20:	fb08 6617 	mls	r6, r8, r7, r6
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1));
    dd24:	4b4f      	ldr	r3, [pc, #316]	; (de64 <fall_get_location_data_reply+0x224>)
    dd26:	2100      	movs	r1, #0
    dd28:	eb0d 0002 	add.w	r0, sp, r2
    dd2c:	9600      	str	r6, [sp, #0]
    dd2e:	f021 fc73 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);
    dd32:	2280      	movs	r2, #128	; 0x80
    dd34:	a902      	add	r1, sp, #8
    dd36:	a804      	add	r0, sp, #16
    dd38:	f021 fc88 	bl	2f64c <__strcat_chk>

	//semicolon
	strcat(reply, ";");
    dd3c:	2280      	movs	r2, #128	; 0x80
    dd3e:	494a      	ldr	r1, [pc, #296]	; (de68 <fall_get_location_data_reply+0x228>)
    dd40:	a804      	add	r0, sp, #16
    dd42:	f021 fc83 	bl	2f64c <__strcat_chk>
	
	//longitude
	if(gps_data.longitude < 0)
    dd46:	2200      	movs	r2, #0
    dd48:	2300      	movs	r3, #0
    dd4a:	4620      	mov	r0, r4
    dd4c:	4629      	mov	r1, r5
    dd4e:	f7fe fea5 	bl	ca9c <__aeabi_dcmplt>
    dd52:	b138      	cbz	r0, dd64 <fall_get_location_data_reply+0x124>
	{
		strcat(reply, "-");
    dd54:	2280      	movs	r2, #128	; 0x80
    dd56:	4940      	ldr	r1, [pc, #256]	; (de58 <fall_get_location_data_reply+0x218>)
    dd58:	a804      	add	r0, sp, #16
    dd5a:	f021 fc77 	bl	2f64c <__strcat_chk>
		gps_data.longitude = -gps_data.longitude;
    dd5e:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
    dd62:	461d      	mov	r5, r3
	}

	tmp1 = (u32_t)(gps_data.longitude);	//
    dd64:	4629      	mov	r1, r5
    dd66:	4620      	mov	r0, r4
    dd68:	f7fe fec0 	bl	caec <__aeabi_d2uiz>
	tmp2 = gps_data.longitude - tmp1;	//
	//integer
	sprintf(tmpbuf, "%d", tmp1);
    dd6c:	2208      	movs	r2, #8
	tmp1 = (u32_t)(gps_data.longitude);	//
    dd6e:	4606      	mov	r6, r0
	sprintf(tmpbuf, "%d", tmp1);
    dd70:	4b3a      	ldr	r3, [pc, #232]	; (de5c <fall_get_location_data_reply+0x21c>)
    dd72:	9000      	str	r0, [sp, #0]
    dd74:	2100      	movs	r1, #0
    dd76:	eb0d 0002 	add.w	r0, sp, r2
    dd7a:	f021 fc4d 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);
    dd7e:	a902      	add	r1, sp, #8
    dd80:	2280      	movs	r2, #128	; 0x80
    dd82:	a804      	add	r0, sp, #16
    dd84:	f021 fc62 	bl	2f64c <__strcat_chk>
	//dot
	strcat(reply, ".");
    dd88:	2280      	movs	r2, #128	; 0x80
    dd8a:	4935      	ldr	r1, [pc, #212]	; (de60 <fall_get_location_data_reply+0x220>)
    dd8c:	a804      	add	r0, sp, #16
    dd8e:	f021 fc5d 	bl	2f64c <__strcat_chk>
	tmp2 = gps_data.longitude - tmp1;	//
    dd92:	4630      	mov	r0, r6
    dd94:	f7fe fb96 	bl	c4c4 <__aeabi_ui2d>
    dd98:	4602      	mov	r2, r0
    dd9a:	460b      	mov	r3, r1
    dd9c:	4620      	mov	r0, r4
    dd9e:	4629      	mov	r1, r5
    dda0:	f7fe fa52 	bl	c248 <__aeabi_dsub>
	//decimal
	tmp1 = (u32_t)(tmp2*1000000);
    dda4:	a32a      	add	r3, pc, #168	; (adr r3, de50 <fall_get_location_data_reply+0x210>)
    dda6:	e9d3 2300 	ldrd	r2, r3, [r3]
    ddaa:	f7fe fc05 	bl	c5b8 <__aeabi_dmul>
    ddae:	f7fe fe9d 	bl	caec <__aeabi_d2uiz>
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/10000));
    ddb2:	f242 7510 	movw	r5, #10000	; 0x2710
	tmp1 = (u32_t)(tmp2*1000000);
    ddb6:	4606      	mov	r6, r0
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/10000));
    ddb8:	fbb0 f4f5 	udiv	r4, r0, r5
    ddbc:	2208      	movs	r2, #8
    ddbe:	b2e3      	uxtb	r3, r4
	strcat(reply, tmpbuf);	
	tmp1 = tmp1%10000;
    ddc0:	fb05 6414 	mls	r4, r5, r4, r6
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/100));
    ddc4:	2664      	movs	r6, #100	; 0x64
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/10000));
    ddc6:	9300      	str	r3, [sp, #0]
    ddc8:	eb0d 0002 	add.w	r0, sp, r2
    ddcc:	4b25      	ldr	r3, [pc, #148]	; (de64 <fall_get_location_data_reply+0x224>)
    ddce:	2100      	movs	r1, #0
    ddd0:	f021 fc22 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);	
    ddd4:	a902      	add	r1, sp, #8
    ddd6:	2280      	movs	r2, #128	; 0x80
    ddd8:	a804      	add	r0, sp, #16
    ddda:	f021 fc37 	bl	2f64c <__strcat_chk>
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/100));
    ddde:	fbb4 f5f6 	udiv	r5, r4, r6
    dde2:	2208      	movs	r2, #8
    dde4:	4b1f      	ldr	r3, [pc, #124]	; (de64 <fall_get_location_data_reply+0x224>)
    dde6:	eb0d 0002 	add.w	r0, sp, r2
    ddea:	9500      	str	r5, [sp, #0]
    ddec:	2100      	movs	r1, #0
    ddee:	f021 fc13 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);	
    ddf2:	a902      	add	r1, sp, #8
    ddf4:	2280      	movs	r2, #128	; 0x80
    ddf6:	a804      	add	r0, sp, #16
    ddf8:	f021 fc28 	bl	2f64c <__strcat_chk>
	tmp1 = tmp1%100;
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1));
    ddfc:	2208      	movs	r2, #8
	tmp1 = tmp1%100;
    ddfe:	fb06 4415 	mls	r4, r6, r5, r4
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1));
    de02:	4b18      	ldr	r3, [pc, #96]	; (de64 <fall_get_location_data_reply+0x224>)
    de04:	eb0d 0002 	add.w	r0, sp, r2
    de08:	9400      	str	r4, [sp, #0]
    de0a:	2100      	movs	r1, #0
    de0c:	f021 fc04 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);
    de10:	a902      	add	r1, sp, #8
    de12:	2280      	movs	r2, #128	; 0x80
    de14:	a804      	add	r0, sp, #16
    de16:	f021 fc19 	bl	2f64c <__strcat_chk>

	//semicolon
	strcat(reply, ";");
    de1a:	2280      	movs	r2, #128	; 0x80
    de1c:	4912      	ldr	r1, [pc, #72]	; (de68 <fall_get_location_data_reply+0x228>)
    de1e:	a804      	add	r0, sp, #16
    de20:	f021 fc14 	bl	2f64c <__strcat_chk>

	//sos trigger time
	strcat(reply, fall_trigger_time);
    de24:	2280      	movs	r2, #128	; 0x80
    de26:	4911      	ldr	r1, [pc, #68]	; (de6c <fall_get_location_data_reply+0x22c>)
    de28:	a804      	add	r0, sp, #16
    de2a:	f021 fc0f 	bl	2f64c <__strcat_chk>

	//semicolon
	strcat(reply, ";");
    de2e:	2280      	movs	r2, #128	; 0x80
    de30:	490d      	ldr	r1, [pc, #52]	; (de68 <fall_get_location_data_reply+0x228>)
    de32:	a804      	add	r0, sp, #16
    de34:	f021 fc0a 	bl	2f64c <__strcat_chk>
	
	NBSendFallGpsData(reply, strlen(reply));
    de38:	a804      	add	r0, sp, #16
    de3a:	f7ff f88d 	bl	cf58 <strlen>
    de3e:	4601      	mov	r1, r0
    de40:	a804      	add	r0, sp, #16
    de42:	f006 faa5 	bl	14390 <NBSendFallGpsData>
}
    de46:	b024      	add	sp, #144	; 0x90
    de48:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    de4c:	b004      	add	sp, #16
    de4e:	4770      	bx	lr
    de50:	00000000 	.word	0x00000000
    de54:	412e8480 	.word	0x412e8480
    de58:	000316d6 	.word	0x000316d6
    de5c:	00033e5f 	.word	0x00033e5f
    de60:	00033e03 	.word	0x00033e03
    de64:	00030f77 	.word	0x00030f77
    de68:	000320a9 	.word	0x000320a9
    de6c:	2002ff1b 	.word	0x2002ff1b

0000de70 <MAX20353_UpdateTemper>:
	WriteWord(0x0C, RCOMP, 0x5C);
	return RCOMP;
}

void MAX20353_UpdateTemper(void)
{
    de70:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    de74:	ed2d 8b02 	vpush	{d8}
    de78:	b0a5      	sub	sp, #148	; 0x94
	u8_t thm;
	s8_t begin,end,tmp;
	float resistance;
	s16_t temper=25;
	u8_t tmpbuf[128] = {0};
    de7a:	2100      	movs	r1, #0
    de7c:	2280      	movs	r2, #128	; 0x80
    de7e:	a804      	add	r0, sp, #16
    de80:	f021 fa88 	bl	2f394 <memset>
	static u8_t pre_thm=0;
	static u16_t pre_temper=25;	//25
	
	thm = MAX20353_ReadTHM();
    de84:	f009 f916 	bl	170b4 <MAX20353_ReadTHM>
	if(thm == pre_thm)
    de88:	4b95      	ldr	r3, [pc, #596]	; (e0e0 <MAX20353_UpdateTemper+0x270>)
    de8a:	7819      	ldrb	r1, [r3, #0]
    de8c:	4281      	cmp	r1, r0
    de8e:	f000 80bd 	beq.w	e00c <MAX20353_UpdateTemper+0x19c>
		return;

	pre_thm = thm;
    de92:	7018      	strb	r0, [r3, #0]
	resistance = (float)10/(255.00/thm-1);
    de94:	f7fe fb26 	bl	c4e4 <__aeabi_i2d>
    de98:	4602      	mov	r2, r0
    de9a:	460b      	mov	r3, r1
    de9c:	a18e      	add	r1, pc, #568	; (adr r1, e0d8 <MAX20353_UpdateTemper+0x268>)
    de9e:	e9d1 0100 	ldrd	r0, r1, [r1]
    dea2:	f7fe fcb3 	bl	c80c <__aeabi_ddiv>
    dea6:	2200      	movs	r2, #0
    dea8:	4b8e      	ldr	r3, [pc, #568]	; (e0e4 <MAX20353_UpdateTemper+0x274>)
    deaa:	f7fe f9cd 	bl	c248 <__aeabi_dsub>
    deae:	4602      	mov	r2, r0
    deb0:	460b      	mov	r3, r1
    deb2:	2000      	movs	r0, #0
    deb4:	498c      	ldr	r1, [pc, #560]	; (e0e8 <MAX20353_UpdateTemper+0x278>)
    deb6:	f7fe fca9 	bl	c80c <__aeabi_ddiv>
    deba:	f7fe fe37 	bl	cb2c <__aeabi_d2f>
    debe:	ee08 0a10 	vmov	s16, r0

	sprintf(tmpbuf, "resistance:%.4f", resistance);
    dec2:	f7fe fb21 	bl	c508 <__aeabi_f2d>
    dec6:	4b89      	ldr	r3, [pc, #548]	; (e0ec <MAX20353_UpdateTemper+0x27c>)
    dec8:	e9cd 0100 	strd	r0, r1, [sp]
    decc:	2280      	movs	r2, #128	; 0x80
    dece:	2100      	movs	r1, #0
    ded0:	a804      	add	r0, sp, #16
    ded2:	f021 fba1 	bl	2f618 <__sprintf_chk>
	LOG_INF("%s\n", tmpbuf);
    ded6:	2303      	movs	r3, #3
    ded8:	f04f 0000 	mov.w	r0, #0
    dedc:	4c84      	ldr	r4, [pc, #528]	; (e0f0 <MAX20353_UpdateTemper+0x280>)
    dede:	f363 0007 	bfi	r0, r3, #0, #8
    dee2:	4b84      	ldr	r3, [pc, #528]	; (e0f4 <MAX20353_UpdateTemper+0x284>)
	end = TEMPER_NUM_MAX-1;
	while(begin <= end)
	{
		tmp = (begin+end)/2;
		
		if(ntc_table[tmp].impedance == resistance)
    dee4:	f8df 922c 	ldr.w	r9, [pc, #556]	; e114 <MAX20353_UpdateTemper+0x2a4>
	LOG_INF("%s\n", tmpbuf);
    dee8:	1ae4      	subs	r4, r4, r3
    deea:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    deee:	f364 108f 	bfi	r0, r4, #6, #10
    def2:	aa04      	add	r2, sp, #16
    def4:	4980      	ldr	r1, [pc, #512]	; (e0f8 <MAX20353_UpdateTemper+0x288>)
    def6:	f01f f9ff 	bl	2d2f8 <log_string_sync>
	end = TEMPER_NUM_MAX-1;
    defa:	f04f 0821 	mov.w	r8, #33	; 0x21
	begin = 0;
    defe:	2600      	movs	r6, #0
    df00:	464f      	mov	r7, r9
		tmp = (begin+end)/2;
    df02:	eb06 0308 	add.w	r3, r6, r8
    df06:	105b      	asrs	r3, r3, #1
    df08:	b25d      	sxtb	r5, r3
		if(ntc_table[tmp].impedance == resistance)
    df0a:	eb09 03c3 	add.w	r3, r9, r3, lsl #3
    df0e:	edd3 7a01 	vldr	s15, [r3, #4]
    df12:	eef4 7a48 	vcmp.f32	s15, s16
    df16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    df1a:	f000 80cf 	beq.w	e0bc <MAX20353_UpdateTemper+0x24c>
			break;

		if(ntc_table[tmp].impedance > resistance)
    df1e:	eef4 7ac8 	vcmpe.f32	s15, s16
    df22:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		{
			begin = tmp+1;
    df26:	bfcb      	itete	gt
    df28:	1c6e      	addgt	r6, r5, #1
		}
		else
		{
			end = tmp-1;
    df2a:	f105 38ff 	addle.w	r8, r5, #4294967295
			begin = tmp+1;
    df2e:	b276      	sxtbgt	r6, r6
			end = tmp-1;
    df30:	fa4f f888 	sxtble.w	r8, r8
	while(begin <= end)
    df34:	4546      	cmp	r6, r8
    df36:	dde4      	ble.n	df02 <MAX20353_UpdateTemper+0x92>
	}
	else			//select closeet
	{
		float com1,com2;

		LOG_INF("select closeet!\n");
    df38:	2303      	movs	r3, #3
    df3a:	f04f 0000 	mov.w	r0, #0
    df3e:	f363 0007 	bfi	r0, r3, #0, #8
    df42:	f364 108f 	bfi	r0, r4, #6, #10
    df46:	496d      	ldr	r1, [pc, #436]	; (e0fc <MAX20353_UpdateTemper+0x28c>)
    df48:	f01f f9d6 	bl	2d2f8 <log_string_sync>
		
		if(begin == tmp+1)
    df4c:	1c6b      	adds	r3, r5, #1
    df4e:	429e      	cmp	r6, r3
    df50:	d161      	bne.n	e016 <MAX20353_UpdateTemper+0x1a6>
		{
			com1 = fabs(ntc_table[tmp].impedance-resistance);
    df52:	eb07 03c5 	add.w	r3, r7, r5, lsl #3
    df56:	edd3 7a01 	vldr	s15, [r3, #4]
    df5a:	ee77 7ac8 	vsub.f32	s15, s15, s16
    df5e:	ee17 0a90 	vmov	r0, s15
    df62:	f7fe fad1 	bl	c508 <__aeabi_f2d>
    df66:	ec41 0b10 	vmov	d0, r0, r1
    df6a:	f01b fcfb 	bl	29964 <fabs>
    df6e:	ec51 0b10 	vmov	r0, r1, d0
    df72:	f7fe fddb 	bl	cb2c <__aeabi_d2f>
			com2 = fabs(ntc_table[tmp+1].impedance-resistance);
    df76:	eb07 03c6 	add.w	r3, r7, r6, lsl #3
    df7a:	edd3 7a01 	vldr	s15, [r3, #4]
    df7e:	ee77 7ac8 	vsub.f32	s15, s15, s16
			com1 = fabs(ntc_table[tmp].impedance-resistance);
    df82:	ee08 0a90 	vmov	s17, r0
			com2 = fabs(ntc_table[tmp+1].impedance-resistance);
    df86:	ee17 0a90 	vmov	r0, s15
    df8a:	f7fe fabd 	bl	c508 <__aeabi_f2d>
    df8e:	ec41 0b10 	vmov	d0, r0, r1
    df92:	f01b fce7 	bl	29964 <fabs>
    df96:	ec51 0b10 	vmov	r0, r1, d0
    df9a:	f7fe fdc7 	bl	cb2c <__aeabi_d2f>
    df9e:	ee08 0a10 	vmov	s16, r0
			sprintf(tmpbuf, "001 com1:%.4f, com2:%04f", com1, com2);
    dfa2:	f7fe fab1 	bl	c508 <__aeabi_f2d>
    dfa6:	e9cd 0102 	strd	r0, r1, [sp, #8]
    dfaa:	ee18 0a90 	vmov	r0, s17
    dfae:	f7fe faab 	bl	c508 <__aeabi_f2d>
    dfb2:	4b53      	ldr	r3, [pc, #332]	; (e100 <MAX20353_UpdateTemper+0x290>)
    dfb4:	e9cd 0100 	strd	r0, r1, [sp]
    dfb8:	2280      	movs	r2, #128	; 0x80
    dfba:	2100      	movs	r1, #0
    dfbc:	a804      	add	r0, sp, #16
    dfbe:	f021 fb2b 	bl	2f618 <__sprintf_chk>
			LOG_INF("%s\n", tmpbuf);
    dfc2:	2303      	movs	r3, #3
    dfc4:	f04f 0000 	mov.w	r0, #0
    dfc8:	f363 0007 	bfi	r0, r3, #0, #8
    dfcc:	f364 108f 	bfi	r0, r4, #6, #10
    dfd0:	aa04      	add	r2, sp, #16
    dfd2:	4949      	ldr	r1, [pc, #292]	; (e0f8 <MAX20353_UpdateTemper+0x288>)
    dfd4:	f01f f990 	bl	2d2f8 <log_string_sync>
			if(com1 > com2)
    dfd8:	eef4 8ac8 	vcmpe.f32	s17, s16
    dfdc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    dfe0:	dd67      	ble.n	e0b2 <MAX20353_UpdateTemper+0x242>
			{
				temper = ntc_table[tmp+1].temperature;
    dfe2:	f937 5036 	ldrsh.w	r5, [r7, r6, lsl #3]
				temper = ntc_table[tmp].temperature;
			}			
		}
	}

	LOG_INF("temper:%d\n", temper);
    dfe6:	2303      	movs	r3, #3
    dfe8:	f04f 0000 	mov.w	r0, #0
    dfec:	f363 0007 	bfi	r0, r3, #0, #8
    dff0:	462a      	mov	r2, r5
    dff2:	f364 108f 	bfi	r0, r4, #6, #10
    dff6:	4943      	ldr	r1, [pc, #268]	; (e104 <MAX20353_UpdateTemper+0x294>)
    dff8:	f01f f97e 	bl	2d2f8 <log_string_sync>

	if(temper != pre_temper)
    dffc:	4b42      	ldr	r3, [pc, #264]	; (e108 <MAX20353_UpdateTemper+0x298>)
    dffe:	881a      	ldrh	r2, [r3, #0]
    e000:	4295      	cmp	r5, r2
    e002:	d003      	beq.n	e00c <MAX20353_UpdateTemper+0x19c>
	{
		pre_temper = temper;
		MAX20353_UpdateRCOMP(temper);	
    e004:	4628      	mov	r0, r5
		pre_temper = temper;
    e006:	801d      	strh	r5, [r3, #0]
		MAX20353_UpdateRCOMP(temper);	
    e008:	f009 f88a 	bl	17120 <MAX20353_UpdateRCOMP>
	}
}
    e00c:	b025      	add	sp, #148	; 0x94
    e00e:	ecbd 8b02 	vpop	{d8}
    e012:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		else if(end == tmp-1)
    e016:	1e6b      	subs	r3, r5, #1
    e018:	4598      	cmp	r8, r3
    e01a:	d14d      	bne.n	e0b8 <MAX20353_UpdateTemper+0x248>
			com1 = fabs(ntc_table[tmp].impedance-resistance);
    e01c:	eb07 03c5 	add.w	r3, r7, r5, lsl #3
    e020:	edd3 7a01 	vldr	s15, [r3, #4]
    e024:	ee77 7ac8 	vsub.f32	s15, s15, s16
    e028:	ee17 0a90 	vmov	r0, s15
    e02c:	f7fe fa6c 	bl	c508 <__aeabi_f2d>
    e030:	ec41 0b10 	vmov	d0, r0, r1
    e034:	f01b fc96 	bl	29964 <fabs>
    e038:	ec51 0b10 	vmov	r0, r1, d0
    e03c:	f7fe fd76 	bl	cb2c <__aeabi_d2f>
			com2 = fabs(ntc_table[tmp-1].impedance-resistance);
    e040:	eb07 03c8 	add.w	r3, r7, r8, lsl #3
    e044:	edd3 7a01 	vldr	s15, [r3, #4]
    e048:	ee77 7ac8 	vsub.f32	s15, s15, s16
			com1 = fabs(ntc_table[tmp].impedance-resistance);
    e04c:	ee08 0a90 	vmov	s17, r0
			com2 = fabs(ntc_table[tmp-1].impedance-resistance);
    e050:	ee17 0a90 	vmov	r0, s15
    e054:	f7fe fa58 	bl	c508 <__aeabi_f2d>
    e058:	ec41 0b10 	vmov	d0, r0, r1
    e05c:	f01b fc82 	bl	29964 <fabs>
    e060:	ec51 0b10 	vmov	r0, r1, d0
    e064:	f7fe fd62 	bl	cb2c <__aeabi_d2f>
    e068:	ee08 0a10 	vmov	s16, r0
			sprintf(tmpbuf, "002 com1:%.4f, com2:%04f", com1, com2);
    e06c:	f7fe fa4c 	bl	c508 <__aeabi_f2d>
    e070:	e9cd 0102 	strd	r0, r1, [sp, #8]
    e074:	ee18 0a90 	vmov	r0, s17
    e078:	f7fe fa46 	bl	c508 <__aeabi_f2d>
    e07c:	4b23      	ldr	r3, [pc, #140]	; (e10c <MAX20353_UpdateTemper+0x29c>)
    e07e:	e9cd 0100 	strd	r0, r1, [sp]
    e082:	2280      	movs	r2, #128	; 0x80
    e084:	2100      	movs	r1, #0
    e086:	a804      	add	r0, sp, #16
    e088:	f021 fac6 	bl	2f618 <__sprintf_chk>
			LOG_INF("%s\n", tmpbuf);
    e08c:	2303      	movs	r3, #3
    e08e:	f04f 0000 	mov.w	r0, #0
    e092:	f363 0007 	bfi	r0, r3, #0, #8
    e096:	f364 108f 	bfi	r0, r4, #6, #10
    e09a:	aa04      	add	r2, sp, #16
    e09c:	4916      	ldr	r1, [pc, #88]	; (e0f8 <MAX20353_UpdateTemper+0x288>)
    e09e:	f01f f92b 	bl	2d2f8 <log_string_sync>
			if(com1 > com2)
    e0a2:	eef4 8ac8 	vcmpe.f32	s17, s16
    e0a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    e0aa:	dd02      	ble.n	e0b2 <MAX20353_UpdateTemper+0x242>
				temper = ntc_table[tmp-1].temperature;
    e0ac:	f937 5038 	ldrsh.w	r5, [r7, r8, lsl #3]
    e0b0:	e799      	b.n	dfe6 <MAX20353_UpdateTemper+0x176>
				temper = ntc_table[tmp].temperature;
    e0b2:	f937 5035 	ldrsh.w	r5, [r7, r5, lsl #3]
    e0b6:	e796      	b.n	dfe6 <MAX20353_UpdateTemper+0x176>
	s16_t temper=25;
    e0b8:	2519      	movs	r5, #25
    e0ba:	e794      	b.n	dfe6 <MAX20353_UpdateTemper+0x176>
		LOG_INF("find success!\n");
    e0bc:	2303      	movs	r3, #3
    e0be:	f04f 0000 	mov.w	r0, #0
    e0c2:	f363 0007 	bfi	r0, r3, #0, #8
    e0c6:	f364 108f 	bfi	r0, r4, #6, #10
    e0ca:	4911      	ldr	r1, [pc, #68]	; (e110 <MAX20353_UpdateTemper+0x2a0>)
    e0cc:	f01f f914 	bl	2d2f8 <log_string_sync>
		temper = ntc_table[tmp].temperature;
    e0d0:	f939 5035 	ldrsh.w	r5, [r9, r5, lsl #3]
    e0d4:	e787      	b.n	dfe6 <MAX20353_UpdateTemper+0x176>
    e0d6:	bf00      	nop
    e0d8:	00000000 	.word	0x00000000
    e0dc:	406fe000 	.word	0x406fe000
    e0e0:	2002ffbf 	.word	0x2002ffbf
    e0e4:	3ff00000 	.word	0x3ff00000
    e0e8:	40240000 	.word	0x40240000
    e0ec:	00032362 	.word	0x00032362
    e0f0:	000304ac 	.word	0x000304ac
    e0f4:	0003040c 	.word	0x0003040c
    e0f8:	00033a55 	.word	0x00033a55
    e0fc:	000323be 	.word	0x000323be
    e100:	00032372 	.word	0x00032372
    e104:	000323a4 	.word	0x000323a4
    e108:	200385aa 	.word	0x200385aa
    e10c:	0003238b 	.word	0x0003238b
    e110:	000323af 	.word	0x000323af
    e114:	00030848 	.word	0x00030848

0000e118 <sos_get_location_data_reply>:

	NBSendSosWifiData(reply, strlen(reply));
}

void sos_get_location_data_reply(nrf_gnss_pvt_data_frame_t gps_data)
{
    e118:	b084      	sub	sp, #16
    e11a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e11e:	b0a4      	sub	sp, #144	; 0x90
    e120:	ac2a      	add	r4, sp, #168	; 0xa8
    e122:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	u8_t reply[128] = {0};
    e126:	2280      	movs	r2, #128	; 0x80
    e128:	e9dd 672a 	ldrd	r6, r7, [sp, #168]	; 0xa8
    e12c:	e9dd 452c 	ldrd	r4, r5, [sp, #176]	; 0xb0
    e130:	2100      	movs	r1, #0
    e132:	a804      	add	r0, sp, #16
    e134:	f021 f92e 	bl	2f394 <memset>
	u8_t tmpbuf[8] = {0};
    e138:	2300      	movs	r3, #0
	u32_t tmp1;
	double tmp2;

	//latitude
	if(gps_data.latitude < 0)
    e13a:	2200      	movs	r2, #0
	u8_t tmpbuf[8] = {0};
    e13c:	e9cd 3302 	strd	r3, r3, [sp, #8]
	if(gps_data.latitude < 0)
    e140:	4630      	mov	r0, r6
    e142:	2300      	movs	r3, #0
    e144:	4639      	mov	r1, r7
    e146:	f7fe fca9 	bl	ca9c <__aeabi_dcmplt>
    e14a:	b138      	cbz	r0, e15c <sos_get_location_data_reply+0x44>
	{
		strcat(reply, "-");
    e14c:	2280      	movs	r2, #128	; 0x80
    e14e:	4978      	ldr	r1, [pc, #480]	; (e330 <sos_get_location_data_reply+0x218>)
    e150:	a804      	add	r0, sp, #16
    e152:	f021 fa7b 	bl	2f64c <__strcat_chk>
		gps_data.latitude = -gps_data.latitude;
    e156:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
    e15a:	461f      	mov	r7, r3
	}

	tmp1 = (u32_t)(gps_data.latitude);	//
    e15c:	4639      	mov	r1, r7
    e15e:	4630      	mov	r0, r6
    e160:	f7fe fcc4 	bl	caec <__aeabi_d2uiz>
	tmp2 = gps_data.latitude - tmp1;		//
	//integer
	sprintf(tmpbuf, "%d", tmp1);
    e164:	2208      	movs	r2, #8
	tmp1 = (u32_t)(gps_data.latitude);	//
    e166:	4680      	mov	r8, r0
	sprintf(tmpbuf, "%d", tmp1);
    e168:	4b72      	ldr	r3, [pc, #456]	; (e334 <sos_get_location_data_reply+0x21c>)
    e16a:	9000      	str	r0, [sp, #0]
    e16c:	2100      	movs	r1, #0
    e16e:	eb0d 0002 	add.w	r0, sp, r2
    e172:	f021 fa51 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);
    e176:	2280      	movs	r2, #128	; 0x80
    e178:	a902      	add	r1, sp, #8
    e17a:	a804      	add	r0, sp, #16
    e17c:	f021 fa66 	bl	2f64c <__strcat_chk>
	//dot
	strcat(reply, ".");
    e180:	2280      	movs	r2, #128	; 0x80
    e182:	496d      	ldr	r1, [pc, #436]	; (e338 <sos_get_location_data_reply+0x220>)
    e184:	a804      	add	r0, sp, #16
    e186:	f021 fa61 	bl	2f64c <__strcat_chk>
	tmp2 = gps_data.latitude - tmp1;		//
    e18a:	4640      	mov	r0, r8
    e18c:	f7fe f99a 	bl	c4c4 <__aeabi_ui2d>
    e190:	4602      	mov	r2, r0
    e192:	460b      	mov	r3, r1
    e194:	4630      	mov	r0, r6
    e196:	4639      	mov	r1, r7
    e198:	f7fe f856 	bl	c248 <__aeabi_dsub>
	//decimal
	tmp1 = (u32_t)(tmp2*1000000);
    e19c:	a362      	add	r3, pc, #392	; (adr r3, e328 <sos_get_location_data_reply+0x210>)
    e19e:	e9d3 2300 	ldrd	r2, r3, [r3]
    e1a2:	f7fe fa09 	bl	c5b8 <__aeabi_dmul>
    e1a6:	f7fe fca1 	bl	caec <__aeabi_d2uiz>
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/10000));
    e1aa:	f242 7710 	movw	r7, #10000	; 0x2710
	tmp1 = (u32_t)(tmp2*1000000);
    e1ae:	4680      	mov	r8, r0
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/10000));
    e1b0:	fbb0 f6f7 	udiv	r6, r0, r7
    e1b4:	2208      	movs	r2, #8
    e1b6:	b2f3      	uxtb	r3, r6
	strcat(reply, tmpbuf);
	tmp1 = tmp1%10000;
    e1b8:	fb07 8616 	mls	r6, r7, r6, r8
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/100));
    e1bc:	f04f 0864 	mov.w	r8, #100	; 0x64
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/10000));
    e1c0:	9300      	str	r3, [sp, #0]
    e1c2:	2100      	movs	r1, #0
    e1c4:	4b5d      	ldr	r3, [pc, #372]	; (e33c <sos_get_location_data_reply+0x224>)
    e1c6:	eb0d 0002 	add.w	r0, sp, r2
    e1ca:	f021 fa25 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);
    e1ce:	2280      	movs	r2, #128	; 0x80
    e1d0:	a902      	add	r1, sp, #8
    e1d2:	a804      	add	r0, sp, #16
    e1d4:	f021 fa3a 	bl	2f64c <__strcat_chk>
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/100));
    e1d8:	2208      	movs	r2, #8
    e1da:	fbb6 f7f8 	udiv	r7, r6, r8
    e1de:	4b57      	ldr	r3, [pc, #348]	; (e33c <sos_get_location_data_reply+0x224>)
    e1e0:	2100      	movs	r1, #0
    e1e2:	eb0d 0002 	add.w	r0, sp, r2
    e1e6:	9700      	str	r7, [sp, #0]
    e1e8:	f021 fa16 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);	
    e1ec:	2280      	movs	r2, #128	; 0x80
    e1ee:	a902      	add	r1, sp, #8
    e1f0:	a804      	add	r0, sp, #16
    e1f2:	f021 fa2b 	bl	2f64c <__strcat_chk>
	tmp1 = tmp1%100;
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1));
    e1f6:	2208      	movs	r2, #8
	tmp1 = tmp1%100;
    e1f8:	fb08 6617 	mls	r6, r8, r7, r6
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1));
    e1fc:	4b4f      	ldr	r3, [pc, #316]	; (e33c <sos_get_location_data_reply+0x224>)
    e1fe:	2100      	movs	r1, #0
    e200:	eb0d 0002 	add.w	r0, sp, r2
    e204:	9600      	str	r6, [sp, #0]
    e206:	f021 fa07 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);
    e20a:	2280      	movs	r2, #128	; 0x80
    e20c:	a902      	add	r1, sp, #8
    e20e:	a804      	add	r0, sp, #16
    e210:	f021 fa1c 	bl	2f64c <__strcat_chk>

	//semicolon
	strcat(reply, ";");
    e214:	2280      	movs	r2, #128	; 0x80
    e216:	494a      	ldr	r1, [pc, #296]	; (e340 <sos_get_location_data_reply+0x228>)
    e218:	a804      	add	r0, sp, #16
    e21a:	f021 fa17 	bl	2f64c <__strcat_chk>
	
	//longitude
	if(gps_data.longitude < 0)
    e21e:	2200      	movs	r2, #0
    e220:	2300      	movs	r3, #0
    e222:	4620      	mov	r0, r4
    e224:	4629      	mov	r1, r5
    e226:	f7fe fc39 	bl	ca9c <__aeabi_dcmplt>
    e22a:	b138      	cbz	r0, e23c <sos_get_location_data_reply+0x124>
	{
		strcat(reply, "-");
    e22c:	2280      	movs	r2, #128	; 0x80
    e22e:	4940      	ldr	r1, [pc, #256]	; (e330 <sos_get_location_data_reply+0x218>)
    e230:	a804      	add	r0, sp, #16
    e232:	f021 fa0b 	bl	2f64c <__strcat_chk>
		gps_data.longitude = -gps_data.longitude;
    e236:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
    e23a:	461d      	mov	r5, r3
	}

	tmp1 = (u32_t)(gps_data.longitude);	//
    e23c:	4629      	mov	r1, r5
    e23e:	4620      	mov	r0, r4
    e240:	f7fe fc54 	bl	caec <__aeabi_d2uiz>
	tmp2 = gps_data.longitude - tmp1;	//
	//integer
	sprintf(tmpbuf, "%d", tmp1);
    e244:	2208      	movs	r2, #8
	tmp1 = (u32_t)(gps_data.longitude);	//
    e246:	4606      	mov	r6, r0
	sprintf(tmpbuf, "%d", tmp1);
    e248:	4b3a      	ldr	r3, [pc, #232]	; (e334 <sos_get_location_data_reply+0x21c>)
    e24a:	9000      	str	r0, [sp, #0]
    e24c:	2100      	movs	r1, #0
    e24e:	eb0d 0002 	add.w	r0, sp, r2
    e252:	f021 f9e1 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);
    e256:	a902      	add	r1, sp, #8
    e258:	2280      	movs	r2, #128	; 0x80
    e25a:	a804      	add	r0, sp, #16
    e25c:	f021 f9f6 	bl	2f64c <__strcat_chk>
	//dot
	strcat(reply, ".");
    e260:	2280      	movs	r2, #128	; 0x80
    e262:	4935      	ldr	r1, [pc, #212]	; (e338 <sos_get_location_data_reply+0x220>)
    e264:	a804      	add	r0, sp, #16
    e266:	f021 f9f1 	bl	2f64c <__strcat_chk>
	tmp2 = gps_data.longitude - tmp1;	//
    e26a:	4630      	mov	r0, r6
    e26c:	f7fe f92a 	bl	c4c4 <__aeabi_ui2d>
    e270:	4602      	mov	r2, r0
    e272:	460b      	mov	r3, r1
    e274:	4620      	mov	r0, r4
    e276:	4629      	mov	r1, r5
    e278:	f7fd ffe6 	bl	c248 <__aeabi_dsub>
	//decimal
	tmp1 = (u32_t)(tmp2*1000000);
    e27c:	a32a      	add	r3, pc, #168	; (adr r3, e328 <sos_get_location_data_reply+0x210>)
    e27e:	e9d3 2300 	ldrd	r2, r3, [r3]
    e282:	f7fe f999 	bl	c5b8 <__aeabi_dmul>
    e286:	f7fe fc31 	bl	caec <__aeabi_d2uiz>
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/10000));
    e28a:	f242 7510 	movw	r5, #10000	; 0x2710
	tmp1 = (u32_t)(tmp2*1000000);
    e28e:	4606      	mov	r6, r0
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/10000));
    e290:	fbb0 f4f5 	udiv	r4, r0, r5
    e294:	2208      	movs	r2, #8
    e296:	b2e3      	uxtb	r3, r4
	strcat(reply, tmpbuf);	
	tmp1 = tmp1%10000;
    e298:	fb05 6414 	mls	r4, r5, r4, r6
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/100));
    e29c:	2664      	movs	r6, #100	; 0x64
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/10000));
    e29e:	9300      	str	r3, [sp, #0]
    e2a0:	eb0d 0002 	add.w	r0, sp, r2
    e2a4:	4b25      	ldr	r3, [pc, #148]	; (e33c <sos_get_location_data_reply+0x224>)
    e2a6:	2100      	movs	r1, #0
    e2a8:	f021 f9b6 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);	
    e2ac:	a902      	add	r1, sp, #8
    e2ae:	2280      	movs	r2, #128	; 0x80
    e2b0:	a804      	add	r0, sp, #16
    e2b2:	f021 f9cb 	bl	2f64c <__strcat_chk>
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1/100));
    e2b6:	fbb4 f5f6 	udiv	r5, r4, r6
    e2ba:	2208      	movs	r2, #8
    e2bc:	4b1f      	ldr	r3, [pc, #124]	; (e33c <sos_get_location_data_reply+0x224>)
    e2be:	eb0d 0002 	add.w	r0, sp, r2
    e2c2:	9500      	str	r5, [sp, #0]
    e2c4:	2100      	movs	r1, #0
    e2c6:	f021 f9a7 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);	
    e2ca:	a902      	add	r1, sp, #8
    e2cc:	2280      	movs	r2, #128	; 0x80
    e2ce:	a804      	add	r0, sp, #16
    e2d0:	f021 f9bc 	bl	2f64c <__strcat_chk>
	tmp1 = tmp1%100;
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1));
    e2d4:	2208      	movs	r2, #8
	tmp1 = tmp1%100;
    e2d6:	fb06 4415 	mls	r4, r6, r5, r4
	sprintf(tmpbuf, "%02d", (u8_t)(tmp1));
    e2da:	4b18      	ldr	r3, [pc, #96]	; (e33c <sos_get_location_data_reply+0x224>)
    e2dc:	eb0d 0002 	add.w	r0, sp, r2
    e2e0:	9400      	str	r4, [sp, #0]
    e2e2:	2100      	movs	r1, #0
    e2e4:	f021 f998 	bl	2f618 <__sprintf_chk>
	strcat(reply, tmpbuf);
    e2e8:	a902      	add	r1, sp, #8
    e2ea:	2280      	movs	r2, #128	; 0x80
    e2ec:	a804      	add	r0, sp, #16
    e2ee:	f021 f9ad 	bl	2f64c <__strcat_chk>

	//semicolon
	strcat(reply, ";");
    e2f2:	2280      	movs	r2, #128	; 0x80
    e2f4:	4912      	ldr	r1, [pc, #72]	; (e340 <sos_get_location_data_reply+0x228>)
    e2f6:	a804      	add	r0, sp, #16
    e2f8:	f021 f9a8 	bl	2f64c <__strcat_chk>

	//sos trigger time
	strcat(reply, sos_trigger_time);
    e2fc:	2280      	movs	r2, #128	; 0x80
    e2fe:	4911      	ldr	r1, [pc, #68]	; (e344 <sos_get_location_data_reply+0x22c>)
    e300:	a804      	add	r0, sp, #16
    e302:	f021 f9a3 	bl	2f64c <__strcat_chk>

	//semicolon
	strcat(reply, ";");
    e306:	2280      	movs	r2, #128	; 0x80
    e308:	490d      	ldr	r1, [pc, #52]	; (e340 <sos_get_location_data_reply+0x228>)
    e30a:	a804      	add	r0, sp, #16
    e30c:	f021 f99e 	bl	2f64c <__strcat_chk>
	
	NBSendSosGpsData(reply, strlen(reply));
    e310:	a804      	add	r0, sp, #16
    e312:	f7fe fe21 	bl	cf58 <strlen>
    e316:	4601      	mov	r1, r0
    e318:	a804      	add	r0, sp, #16
    e31a:	f005 ff5f 	bl	141dc <NBSendSosGpsData>
}
    e31e:	b024      	add	sp, #144	; 0x90
    e320:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    e324:	b004      	add	sp, #16
    e326:	4770      	bx	lr
    e328:	00000000 	.word	0x00000000
    e32c:	412e8480 	.word	0x412e8480
    e330:	000316d6 	.word	0x000316d6
    e334:	00033e5f 	.word	0x00033e5f
    e338:	00033e03 	.word	0x00033e03
    e33c:	00030f77 	.word	0x00030f77
    e340:	000320a9 	.word	0x000320a9
    e344:	2003006a 	.word	0x2003006a

0000e348 <pow>:
    e348:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e34a:	ed2d 8b02 	vpush	{d8}
    e34e:	ec57 6b10 	vmov	r6, r7, d0
    e352:	ec55 4b11 	vmov	r4, r5, d1
    e356:	f000 fb37 	bl	e9c8 <__ieee754_pow>
    e35a:	4b61      	ldr	r3, [pc, #388]	; (e4e0 <pow+0x198>)
    e35c:	eeb0 8a40 	vmov.f32	s16, s0
    e360:	eef0 8a60 	vmov.f32	s17, s1
    e364:	f993 3000 	ldrsb.w	r3, [r3]
    e368:	3301      	adds	r3, #1
    e36a:	d02a      	beq.n	e3c2 <pow+0x7a>
    e36c:	4622      	mov	r2, r4
    e36e:	462b      	mov	r3, r5
    e370:	4620      	mov	r0, r4
    e372:	4629      	mov	r1, r5
    e374:	f7fe fda8 	bl	cec8 <__aeabi_dcmpun>
    e378:	bb18      	cbnz	r0, e3c2 <pow+0x7a>
    e37a:	4632      	mov	r2, r6
    e37c:	463b      	mov	r3, r7
    e37e:	4630      	mov	r0, r6
    e380:	4639      	mov	r1, r7
    e382:	f7fe fda1 	bl	cec8 <__aeabi_dcmpun>
    e386:	2800      	cmp	r0, #0
    e388:	d144      	bne.n	e414 <pow+0xcc>
    e38a:	2200      	movs	r2, #0
    e38c:	2300      	movs	r3, #0
    e38e:	4630      	mov	r0, r6
    e390:	4639      	mov	r1, r7
    e392:	f7fe fb79 	bl	ca88 <__aeabi_dcmpeq>
    e396:	b1d8      	cbz	r0, e3d0 <pow+0x88>
    e398:	2200      	movs	r2, #0
    e39a:	2300      	movs	r3, #0
    e39c:	4620      	mov	r0, r4
    e39e:	4629      	mov	r1, r5
    e3a0:	f7fe fb72 	bl	ca88 <__aeabi_dcmpeq>
    e3a4:	2800      	cmp	r0, #0
    e3a6:	d13d      	bne.n	e424 <pow+0xdc>
    e3a8:	ec45 4b10 	vmov	d0, r4, r5
    e3ac:	f01b fc24 	bl	29bf8 <finite>
    e3b0:	b138      	cbz	r0, e3c2 <pow+0x7a>
    e3b2:	4620      	mov	r0, r4
    e3b4:	4629      	mov	r1, r5
    e3b6:	2200      	movs	r2, #0
    e3b8:	2300      	movs	r3, #0
    e3ba:	f7fe fb6f 	bl	ca9c <__aeabi_dcmplt>
    e3be:	2800      	cmp	r0, #0
    e3c0:	d15b      	bne.n	e47a <pow+0x132>
    e3c2:	eeb0 0a48 	vmov.f32	s0, s16
    e3c6:	eef0 0a68 	vmov.f32	s1, s17
    e3ca:	ecbd 8b02 	vpop	{d8}
    e3ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e3d0:	eeb0 0a48 	vmov.f32	s0, s16
    e3d4:	eef0 0a68 	vmov.f32	s1, s17
    e3d8:	f01b fc0e 	bl	29bf8 <finite>
    e3dc:	b358      	cbz	r0, e436 <pow+0xee>
    e3de:	2200      	movs	r2, #0
    e3e0:	2300      	movs	r3, #0
    e3e2:	ec51 0b18 	vmov	r0, r1, d8
    e3e6:	f7fe fb4f 	bl	ca88 <__aeabi_dcmpeq>
    e3ea:	2800      	cmp	r0, #0
    e3ec:	d0e9      	beq.n	e3c2 <pow+0x7a>
    e3ee:	ec47 6b10 	vmov	d0, r6, r7
    e3f2:	f01b fc01 	bl	29bf8 <finite>
    e3f6:	2800      	cmp	r0, #0
    e3f8:	d0e3      	beq.n	e3c2 <pow+0x7a>
    e3fa:	ec45 4b10 	vmov	d0, r4, r5
    e3fe:	f01b fbfb 	bl	29bf8 <finite>
    e402:	2800      	cmp	r0, #0
    e404:	d0dd      	beq.n	e3c2 <pow+0x7a>
    e406:	f01f f91b 	bl	2d640 <__errno>
    e40a:	2322      	movs	r3, #34	; 0x22
    e40c:	ed9f 8b2c 	vldr	d8, [pc, #176]	; e4c0 <pow+0x178>
    e410:	6003      	str	r3, [r0, #0]
    e412:	e7d6      	b.n	e3c2 <pow+0x7a>
    e414:	4620      	mov	r0, r4
    e416:	4629      	mov	r1, r5
    e418:	2200      	movs	r2, #0
    e41a:	2300      	movs	r3, #0
    e41c:	f7fe fb34 	bl	ca88 <__aeabi_dcmpeq>
    e420:	2800      	cmp	r0, #0
    e422:	d0ce      	beq.n	e3c2 <pow+0x7a>
    e424:	ed9f 8b28 	vldr	d8, [pc, #160]	; e4c8 <pow+0x180>
    e428:	eeb0 0a48 	vmov.f32	s0, s16
    e42c:	eef0 0a68 	vmov.f32	s1, s17
    e430:	ecbd 8b02 	vpop	{d8}
    e434:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e436:	ec47 6b10 	vmov	d0, r6, r7
    e43a:	f01b fbdd 	bl	29bf8 <finite>
    e43e:	2800      	cmp	r0, #0
    e440:	d0cd      	beq.n	e3de <pow+0x96>
    e442:	ec45 4b10 	vmov	d0, r4, r5
    e446:	f01b fbd7 	bl	29bf8 <finite>
    e44a:	2800      	cmp	r0, #0
    e44c:	d0c7      	beq.n	e3de <pow+0x96>
    e44e:	ee18 0a10 	vmov	r0, s16
    e452:	ec53 2b18 	vmov	r2, r3, d8
    e456:	4619      	mov	r1, r3
    e458:	f7fe fd36 	bl	cec8 <__aeabi_dcmpun>
    e45c:	bb18      	cbnz	r0, e4a6 <pow+0x15e>
    e45e:	f01f f8ef 	bl	2d640 <__errno>
    e462:	2322      	movs	r3, #34	; 0x22
    e464:	2200      	movs	r2, #0
    e466:	4639      	mov	r1, r7
    e468:	6003      	str	r3, [r0, #0]
    e46a:	2300      	movs	r3, #0
    e46c:	4630      	mov	r0, r6
    e46e:	f7fe fb15 	bl	ca9c <__aeabi_dcmplt>
    e472:	b948      	cbnz	r0, e488 <pow+0x140>
    e474:	ed9f 8b16 	vldr	d8, [pc, #88]	; e4d0 <pow+0x188>
    e478:	e7a3      	b.n	e3c2 <pow+0x7a>
    e47a:	f01f f8e1 	bl	2d640 <__errno>
    e47e:	2321      	movs	r3, #33	; 0x21
    e480:	ed9f 8b15 	vldr	d8, [pc, #84]	; e4d8 <pow+0x190>
    e484:	6003      	str	r3, [r0, #0]
    e486:	e79c      	b.n	e3c2 <pow+0x7a>
    e488:	ec45 4b10 	vmov	d0, r4, r5
    e48c:	f01b fbbe 	bl	29c0c <rint>
    e490:	4622      	mov	r2, r4
    e492:	462b      	mov	r3, r5
    e494:	ec51 0b10 	vmov	r0, r1, d0
    e498:	f7fe faf6 	bl	ca88 <__aeabi_dcmpeq>
    e49c:	2800      	cmp	r0, #0
    e49e:	d1e9      	bne.n	e474 <pow+0x12c>
    e4a0:	ed9f 8b0d 	vldr	d8, [pc, #52]	; e4d8 <pow+0x190>
    e4a4:	e78d      	b.n	e3c2 <pow+0x7a>
    e4a6:	f01f f8cb 	bl	2d640 <__errno>
    e4aa:	2121      	movs	r1, #33	; 0x21
    e4ac:	2200      	movs	r2, #0
    e4ae:	2300      	movs	r3, #0
    e4b0:	6001      	str	r1, [r0, #0]
    e4b2:	4610      	mov	r0, r2
    e4b4:	4619      	mov	r1, r3
    e4b6:	f7fe f9a9 	bl	c80c <__aeabi_ddiv>
    e4ba:	ec41 0b18 	vmov	d8, r0, r1
    e4be:	e780      	b.n	e3c2 <pow+0x7a>
	...
    e4cc:	3ff00000 	.word	0x3ff00000
    e4d0:	00000000 	.word	0x00000000
    e4d4:	7ff00000 	.word	0x7ff00000
    e4d8:	00000000 	.word	0x00000000
    e4dc:	fff00000 	.word	0xfff00000
    e4e0:	2003b5ce 	.word	0x2003b5ce
    e4e4:	00000000 	.word	0x00000000

0000e4e8 <__ieee754_acos>:
    e4e8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e4ec:	ec55 4b10 	vmov	r4, r5, d0
    e4f0:	49cd      	ldr	r1, [pc, #820]	; (e828 <__ieee754_acos+0x340>)
    e4f2:	f025 4300 	bic.w	r3, r5, #2147483648	; 0x80000000
    e4f6:	428b      	cmp	r3, r1
    e4f8:	dd0c      	ble.n	e514 <__ieee754_acos+0x2c>
    e4fa:	48cc      	ldr	r0, [pc, #816]	; (e82c <__ieee754_acos+0x344>)
    e4fc:	4418      	add	r0, r3
    e4fe:	4623      	mov	r3, r4
    e500:	4303      	orrs	r3, r0
    e502:	f040 80bd 	bne.w	e680 <__ieee754_acos+0x198>
    e506:	2d00      	cmp	r5, #0
    e508:	f340 80c9 	ble.w	e69e <__ieee754_acos+0x1b6>
    e50c:	ed9f 0baa 	vldr	d0, [pc, #680]	; e7b8 <__ieee754_acos+0x2d0>
    e510:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e514:	49c6      	ldr	r1, [pc, #792]	; (e830 <__ieee754_acos+0x348>)
    e516:	428b      	cmp	r3, r1
    e518:	dc07      	bgt.n	e52a <__ieee754_acos+0x42>
    e51a:	4ac6      	ldr	r2, [pc, #792]	; (e834 <__ieee754_acos+0x34c>)
    e51c:	4293      	cmp	r3, r2
    e51e:	f300 80c2 	bgt.w	e6a6 <__ieee754_acos+0x1be>
    e522:	ed9f 0ba7 	vldr	d0, [pc, #668]	; e7c0 <__ieee754_acos+0x2d8>
    e526:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e52a:	2d00      	cmp	r5, #0
    e52c:	f2c0 8188 	blt.w	e840 <__ieee754_acos+0x358>
    e530:	ee10 2a10 	vmov	r2, s0
    e534:	462b      	mov	r3, r5
    e536:	2000      	movs	r0, #0
    e538:	49bf      	ldr	r1, [pc, #764]	; (e838 <__ieee754_acos+0x350>)
    e53a:	f7fd fe85 	bl	c248 <__aeabi_dsub>
    e53e:	2200      	movs	r2, #0
    e540:	4bbe      	ldr	r3, [pc, #760]	; (e83c <__ieee754_acos+0x354>)
    e542:	2600      	movs	r6, #0
    e544:	f7fe f838 	bl	c5b8 <__aeabi_dmul>
    e548:	4604      	mov	r4, r0
    e54a:	460d      	mov	r5, r1
    e54c:	ec45 4b10 	vmov	d0, r4, r5
    e550:	f01b fa86 	bl	29a60 <__ieee754_sqrt>
    e554:	4620      	mov	r0, r4
    e556:	4629      	mov	r1, r5
    e558:	a39b      	add	r3, pc, #620	; (adr r3, e7c8 <__ieee754_acos+0x2e0>)
    e55a:	e9d3 2300 	ldrd	r2, r3, [r3]
    e55e:	ec59 8b10 	vmov	r8, r9, d0
    e562:	f7fe f829 	bl	c5b8 <__aeabi_dmul>
    e566:	a39a      	add	r3, pc, #616	; (adr r3, e7d0 <__ieee754_acos+0x2e8>)
    e568:	e9d3 2300 	ldrd	r2, r3, [r3]
    e56c:	f7fd fe6e 	bl	c24c <__adddf3>
    e570:	4622      	mov	r2, r4
    e572:	462b      	mov	r3, r5
    e574:	f7fe f820 	bl	c5b8 <__aeabi_dmul>
    e578:	a397      	add	r3, pc, #604	; (adr r3, e7d8 <__ieee754_acos+0x2f0>)
    e57a:	e9d3 2300 	ldrd	r2, r3, [r3]
    e57e:	f7fd fe63 	bl	c248 <__aeabi_dsub>
    e582:	4622      	mov	r2, r4
    e584:	462b      	mov	r3, r5
    e586:	f7fe f817 	bl	c5b8 <__aeabi_dmul>
    e58a:	a395      	add	r3, pc, #596	; (adr r3, e7e0 <__ieee754_acos+0x2f8>)
    e58c:	e9d3 2300 	ldrd	r2, r3, [r3]
    e590:	f7fd fe5c 	bl	c24c <__adddf3>
    e594:	4622      	mov	r2, r4
    e596:	462b      	mov	r3, r5
    e598:	f7fe f80e 	bl	c5b8 <__aeabi_dmul>
    e59c:	a392      	add	r3, pc, #584	; (adr r3, e7e8 <__ieee754_acos+0x300>)
    e59e:	e9d3 2300 	ldrd	r2, r3, [r3]
    e5a2:	f7fd fe51 	bl	c248 <__aeabi_dsub>
    e5a6:	4622      	mov	r2, r4
    e5a8:	462b      	mov	r3, r5
    e5aa:	f7fe f805 	bl	c5b8 <__aeabi_dmul>
    e5ae:	a390      	add	r3, pc, #576	; (adr r3, e7f0 <__ieee754_acos+0x308>)
    e5b0:	e9d3 2300 	ldrd	r2, r3, [r3]
    e5b4:	f7fd fe4a 	bl	c24c <__adddf3>
    e5b8:	4622      	mov	r2, r4
    e5ba:	462b      	mov	r3, r5
    e5bc:	f7fd fffc 	bl	c5b8 <__aeabi_dmul>
    e5c0:	4682      	mov	sl, r0
    e5c2:	468b      	mov	fp, r1
    e5c4:	4620      	mov	r0, r4
    e5c6:	4629      	mov	r1, r5
    e5c8:	a38b      	add	r3, pc, #556	; (adr r3, e7f8 <__ieee754_acos+0x310>)
    e5ca:	e9d3 2300 	ldrd	r2, r3, [r3]
    e5ce:	f7fd fff3 	bl	c5b8 <__aeabi_dmul>
    e5d2:	a38b      	add	r3, pc, #556	; (adr r3, e800 <__ieee754_acos+0x318>)
    e5d4:	e9d3 2300 	ldrd	r2, r3, [r3]
    e5d8:	f7fd fe36 	bl	c248 <__aeabi_dsub>
    e5dc:	4622      	mov	r2, r4
    e5de:	462b      	mov	r3, r5
    e5e0:	f7fd ffea 	bl	c5b8 <__aeabi_dmul>
    e5e4:	a388      	add	r3, pc, #544	; (adr r3, e808 <__ieee754_acos+0x320>)
    e5e6:	e9d3 2300 	ldrd	r2, r3, [r3]
    e5ea:	f7fd fe2f 	bl	c24c <__adddf3>
    e5ee:	4622      	mov	r2, r4
    e5f0:	462b      	mov	r3, r5
    e5f2:	f7fd ffe1 	bl	c5b8 <__aeabi_dmul>
    e5f6:	a386      	add	r3, pc, #536	; (adr r3, e810 <__ieee754_acos+0x328>)
    e5f8:	e9d3 2300 	ldrd	r2, r3, [r3]
    e5fc:	f7fd fe24 	bl	c248 <__aeabi_dsub>
    e600:	4622      	mov	r2, r4
    e602:	462b      	mov	r3, r5
    e604:	f7fd ffd8 	bl	c5b8 <__aeabi_dmul>
    e608:	2200      	movs	r2, #0
    e60a:	4b8b      	ldr	r3, [pc, #556]	; (e838 <__ieee754_acos+0x350>)
    e60c:	f7fd fe1e 	bl	c24c <__adddf3>
    e610:	4602      	mov	r2, r0
    e612:	460b      	mov	r3, r1
    e614:	4650      	mov	r0, sl
    e616:	4659      	mov	r1, fp
    e618:	f7fe f8f8 	bl	c80c <__aeabi_ddiv>
    e61c:	4642      	mov	r2, r8
    e61e:	464b      	mov	r3, r9
    e620:	f7fd ffca 	bl	c5b8 <__aeabi_dmul>
    e624:	4632      	mov	r2, r6
    e626:	4682      	mov	sl, r0
    e628:	468b      	mov	fp, r1
    e62a:	464b      	mov	r3, r9
    e62c:	4630      	mov	r0, r6
    e62e:	4649      	mov	r1, r9
    e630:	f7fd ffc2 	bl	c5b8 <__aeabi_dmul>
    e634:	4602      	mov	r2, r0
    e636:	460b      	mov	r3, r1
    e638:	4620      	mov	r0, r4
    e63a:	4629      	mov	r1, r5
    e63c:	f7fd fe04 	bl	c248 <__aeabi_dsub>
    e640:	4604      	mov	r4, r0
    e642:	460d      	mov	r5, r1
    e644:	4632      	mov	r2, r6
    e646:	464b      	mov	r3, r9
    e648:	4640      	mov	r0, r8
    e64a:	4649      	mov	r1, r9
    e64c:	f7fd fdfe 	bl	c24c <__adddf3>
    e650:	4602      	mov	r2, r0
    e652:	460b      	mov	r3, r1
    e654:	4620      	mov	r0, r4
    e656:	4629      	mov	r1, r5
    e658:	f7fe f8d8 	bl	c80c <__aeabi_ddiv>
    e65c:	4602      	mov	r2, r0
    e65e:	460b      	mov	r3, r1
    e660:	4650      	mov	r0, sl
    e662:	4659      	mov	r1, fp
    e664:	f7fd fdf2 	bl	c24c <__adddf3>
    e668:	4632      	mov	r2, r6
    e66a:	464b      	mov	r3, r9
    e66c:	f7fd fdee 	bl	c24c <__adddf3>
    e670:	4602      	mov	r2, r0
    e672:	460b      	mov	r3, r1
    e674:	f7fd fdea 	bl	c24c <__adddf3>
    e678:	ec41 0b10 	vmov	d0, r0, r1
    e67c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e680:	ee10 2a10 	vmov	r2, s0
    e684:	462b      	mov	r3, r5
    e686:	4620      	mov	r0, r4
    e688:	4629      	mov	r1, r5
    e68a:	f7fd fddd 	bl	c248 <__aeabi_dsub>
    e68e:	4602      	mov	r2, r0
    e690:	460b      	mov	r3, r1
    e692:	f7fe f8bb 	bl	c80c <__aeabi_ddiv>
    e696:	ec41 0b10 	vmov	d0, r0, r1
    e69a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e69e:	ed9f 0b5e 	vldr	d0, [pc, #376]	; e818 <__ieee754_acos+0x330>
    e6a2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e6a6:	ee10 2a10 	vmov	r2, s0
    e6aa:	ee10 0a10 	vmov	r0, s0
    e6ae:	462b      	mov	r3, r5
    e6b0:	4629      	mov	r1, r5
    e6b2:	f7fd ff81 	bl	c5b8 <__aeabi_dmul>
    e6b6:	4606      	mov	r6, r0
    e6b8:	460f      	mov	r7, r1
    e6ba:	a343      	add	r3, pc, #268	; (adr r3, e7c8 <__ieee754_acos+0x2e0>)
    e6bc:	e9d3 2300 	ldrd	r2, r3, [r3]
    e6c0:	f7fd ff7a 	bl	c5b8 <__aeabi_dmul>
    e6c4:	a342      	add	r3, pc, #264	; (adr r3, e7d0 <__ieee754_acos+0x2e8>)
    e6c6:	e9d3 2300 	ldrd	r2, r3, [r3]
    e6ca:	f7fd fdbf 	bl	c24c <__adddf3>
    e6ce:	4632      	mov	r2, r6
    e6d0:	463b      	mov	r3, r7
    e6d2:	f7fd ff71 	bl	c5b8 <__aeabi_dmul>
    e6d6:	a340      	add	r3, pc, #256	; (adr r3, e7d8 <__ieee754_acos+0x2f0>)
    e6d8:	e9d3 2300 	ldrd	r2, r3, [r3]
    e6dc:	f7fd fdb4 	bl	c248 <__aeabi_dsub>
    e6e0:	4632      	mov	r2, r6
    e6e2:	463b      	mov	r3, r7
    e6e4:	f7fd ff68 	bl	c5b8 <__aeabi_dmul>
    e6e8:	a33d      	add	r3, pc, #244	; (adr r3, e7e0 <__ieee754_acos+0x2f8>)
    e6ea:	e9d3 2300 	ldrd	r2, r3, [r3]
    e6ee:	f7fd fdad 	bl	c24c <__adddf3>
    e6f2:	4632      	mov	r2, r6
    e6f4:	463b      	mov	r3, r7
    e6f6:	f7fd ff5f 	bl	c5b8 <__aeabi_dmul>
    e6fa:	a33b      	add	r3, pc, #236	; (adr r3, e7e8 <__ieee754_acos+0x300>)
    e6fc:	e9d3 2300 	ldrd	r2, r3, [r3]
    e700:	f7fd fda2 	bl	c248 <__aeabi_dsub>
    e704:	4632      	mov	r2, r6
    e706:	463b      	mov	r3, r7
    e708:	f7fd ff56 	bl	c5b8 <__aeabi_dmul>
    e70c:	a338      	add	r3, pc, #224	; (adr r3, e7f0 <__ieee754_acos+0x308>)
    e70e:	e9d3 2300 	ldrd	r2, r3, [r3]
    e712:	f7fd fd9b 	bl	c24c <__adddf3>
    e716:	4632      	mov	r2, r6
    e718:	463b      	mov	r3, r7
    e71a:	f7fd ff4d 	bl	c5b8 <__aeabi_dmul>
    e71e:	4680      	mov	r8, r0
    e720:	4689      	mov	r9, r1
    e722:	4630      	mov	r0, r6
    e724:	4639      	mov	r1, r7
    e726:	a334      	add	r3, pc, #208	; (adr r3, e7f8 <__ieee754_acos+0x310>)
    e728:	e9d3 2300 	ldrd	r2, r3, [r3]
    e72c:	f7fd ff44 	bl	c5b8 <__aeabi_dmul>
    e730:	a333      	add	r3, pc, #204	; (adr r3, e800 <__ieee754_acos+0x318>)
    e732:	e9d3 2300 	ldrd	r2, r3, [r3]
    e736:	f7fd fd87 	bl	c248 <__aeabi_dsub>
    e73a:	4632      	mov	r2, r6
    e73c:	463b      	mov	r3, r7
    e73e:	f7fd ff3b 	bl	c5b8 <__aeabi_dmul>
    e742:	a331      	add	r3, pc, #196	; (adr r3, e808 <__ieee754_acos+0x320>)
    e744:	e9d3 2300 	ldrd	r2, r3, [r3]
    e748:	f7fd fd80 	bl	c24c <__adddf3>
    e74c:	4632      	mov	r2, r6
    e74e:	463b      	mov	r3, r7
    e750:	f7fd ff32 	bl	c5b8 <__aeabi_dmul>
    e754:	a32e      	add	r3, pc, #184	; (adr r3, e810 <__ieee754_acos+0x328>)
    e756:	e9d3 2300 	ldrd	r2, r3, [r3]
    e75a:	f7fd fd75 	bl	c248 <__aeabi_dsub>
    e75e:	4632      	mov	r2, r6
    e760:	463b      	mov	r3, r7
    e762:	f7fd ff29 	bl	c5b8 <__aeabi_dmul>
    e766:	2200      	movs	r2, #0
    e768:	4b33      	ldr	r3, [pc, #204]	; (e838 <__ieee754_acos+0x350>)
    e76a:	f7fd fd6f 	bl	c24c <__adddf3>
    e76e:	4602      	mov	r2, r0
    e770:	460b      	mov	r3, r1
    e772:	4640      	mov	r0, r8
    e774:	4649      	mov	r1, r9
    e776:	f7fe f849 	bl	c80c <__aeabi_ddiv>
    e77a:	4622      	mov	r2, r4
    e77c:	462b      	mov	r3, r5
    e77e:	f7fd ff1b 	bl	c5b8 <__aeabi_dmul>
    e782:	4602      	mov	r2, r0
    e784:	460b      	mov	r3, r1
    e786:	a126      	add	r1, pc, #152	; (adr r1, e820 <__ieee754_acos+0x338>)
    e788:	e9d1 0100 	ldrd	r0, r1, [r1]
    e78c:	f7fd fd5c 	bl	c248 <__aeabi_dsub>
    e790:	4602      	mov	r2, r0
    e792:	460b      	mov	r3, r1
    e794:	4620      	mov	r0, r4
    e796:	4629      	mov	r1, r5
    e798:	f7fd fd56 	bl	c248 <__aeabi_dsub>
    e79c:	4602      	mov	r2, r0
    e79e:	460b      	mov	r3, r1
    e7a0:	a107      	add	r1, pc, #28	; (adr r1, e7c0 <__ieee754_acos+0x2d8>)
    e7a2:	e9d1 0100 	ldrd	r0, r1, [r1]
    e7a6:	f7fd fd4f 	bl	c248 <__aeabi_dsub>
    e7aa:	ec41 0b10 	vmov	d0, r0, r1
    e7ae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e7b2:	bf00      	nop
    e7b4:	f3af 8000 	nop.w
	...
    e7c0:	54442d18 	.word	0x54442d18
    e7c4:	3ff921fb 	.word	0x3ff921fb
    e7c8:	0dfdf709 	.word	0x0dfdf709
    e7cc:	3f023de1 	.word	0x3f023de1
    e7d0:	7501b288 	.word	0x7501b288
    e7d4:	3f49efe0 	.word	0x3f49efe0
    e7d8:	b5688f3b 	.word	0xb5688f3b
    e7dc:	3fa48228 	.word	0x3fa48228
    e7e0:	0e884455 	.word	0x0e884455
    e7e4:	3fc9c155 	.word	0x3fc9c155
    e7e8:	03eb6f7d 	.word	0x03eb6f7d
    e7ec:	3fd4d612 	.word	0x3fd4d612
    e7f0:	55555555 	.word	0x55555555
    e7f4:	3fc55555 	.word	0x3fc55555
    e7f8:	b12e9282 	.word	0xb12e9282
    e7fc:	3fb3b8c5 	.word	0x3fb3b8c5
    e800:	1b8d0159 	.word	0x1b8d0159
    e804:	3fe6066c 	.word	0x3fe6066c
    e808:	9c598ac8 	.word	0x9c598ac8
    e80c:	40002ae5 	.word	0x40002ae5
    e810:	1c8a2d4b 	.word	0x1c8a2d4b
    e814:	40033a27 	.word	0x40033a27
    e818:	54442d18 	.word	0x54442d18
    e81c:	400921fb 	.word	0x400921fb
    e820:	33145c07 	.word	0x33145c07
    e824:	3c91a626 	.word	0x3c91a626
    e828:	3fefffff 	.word	0x3fefffff
    e82c:	c0100000 	.word	0xc0100000
    e830:	3fdfffff 	.word	0x3fdfffff
    e834:	3c600000 	.word	0x3c600000
    e838:	3ff00000 	.word	0x3ff00000
    e83c:	3fe00000 	.word	0x3fe00000
    e840:	ee10 0a10 	vmov	r0, s0
    e844:	4629      	mov	r1, r5
    e846:	2200      	movs	r2, #0
    e848:	4b5d      	ldr	r3, [pc, #372]	; (e9c0 <__ieee754_acos+0x4d8>)
    e84a:	f7fd fcff 	bl	c24c <__adddf3>
    e84e:	2200      	movs	r2, #0
    e850:	4b5c      	ldr	r3, [pc, #368]	; (e9c4 <__ieee754_acos+0x4dc>)
    e852:	f7fd feb1 	bl	c5b8 <__aeabi_dmul>
    e856:	4604      	mov	r4, r0
    e858:	460d      	mov	r5, r1
    e85a:	a341      	add	r3, pc, #260	; (adr r3, e960 <__ieee754_acos+0x478>)
    e85c:	e9d3 2300 	ldrd	r2, r3, [r3]
    e860:	f7fd feaa 	bl	c5b8 <__aeabi_dmul>
    e864:	a340      	add	r3, pc, #256	; (adr r3, e968 <__ieee754_acos+0x480>)
    e866:	e9d3 2300 	ldrd	r2, r3, [r3]
    e86a:	f7fd fcef 	bl	c24c <__adddf3>
    e86e:	4622      	mov	r2, r4
    e870:	462b      	mov	r3, r5
    e872:	f7fd fea1 	bl	c5b8 <__aeabi_dmul>
    e876:	a33e      	add	r3, pc, #248	; (adr r3, e970 <__ieee754_acos+0x488>)
    e878:	e9d3 2300 	ldrd	r2, r3, [r3]
    e87c:	f7fd fce4 	bl	c248 <__aeabi_dsub>
    e880:	4622      	mov	r2, r4
    e882:	462b      	mov	r3, r5
    e884:	f7fd fe98 	bl	c5b8 <__aeabi_dmul>
    e888:	a33b      	add	r3, pc, #236	; (adr r3, e978 <__ieee754_acos+0x490>)
    e88a:	e9d3 2300 	ldrd	r2, r3, [r3]
    e88e:	f7fd fcdd 	bl	c24c <__adddf3>
    e892:	4622      	mov	r2, r4
    e894:	462b      	mov	r3, r5
    e896:	f7fd fe8f 	bl	c5b8 <__aeabi_dmul>
    e89a:	a339      	add	r3, pc, #228	; (adr r3, e980 <__ieee754_acos+0x498>)
    e89c:	e9d3 2300 	ldrd	r2, r3, [r3]
    e8a0:	f7fd fcd2 	bl	c248 <__aeabi_dsub>
    e8a4:	4622      	mov	r2, r4
    e8a6:	462b      	mov	r3, r5
    e8a8:	f7fd fe86 	bl	c5b8 <__aeabi_dmul>
    e8ac:	a336      	add	r3, pc, #216	; (adr r3, e988 <__ieee754_acos+0x4a0>)
    e8ae:	e9d3 2300 	ldrd	r2, r3, [r3]
    e8b2:	f7fd fccb 	bl	c24c <__adddf3>
    e8b6:	4622      	mov	r2, r4
    e8b8:	462b      	mov	r3, r5
    e8ba:	f7fd fe7d 	bl	c5b8 <__aeabi_dmul>
    e8be:	4680      	mov	r8, r0
    e8c0:	4689      	mov	r9, r1
    e8c2:	ec45 4b10 	vmov	d0, r4, r5
    e8c6:	f01b f8cb 	bl	29a60 <__ieee754_sqrt>
    e8ca:	4620      	mov	r0, r4
    e8cc:	4629      	mov	r1, r5
    e8ce:	a330      	add	r3, pc, #192	; (adr r3, e990 <__ieee754_acos+0x4a8>)
    e8d0:	e9d3 2300 	ldrd	r2, r3, [r3]
    e8d4:	ec57 6b10 	vmov	r6, r7, d0
    e8d8:	f7fd fe6e 	bl	c5b8 <__aeabi_dmul>
    e8dc:	a32e      	add	r3, pc, #184	; (adr r3, e998 <__ieee754_acos+0x4b0>)
    e8de:	e9d3 2300 	ldrd	r2, r3, [r3]
    e8e2:	f7fd fcb1 	bl	c248 <__aeabi_dsub>
    e8e6:	4622      	mov	r2, r4
    e8e8:	462b      	mov	r3, r5
    e8ea:	f7fd fe65 	bl	c5b8 <__aeabi_dmul>
    e8ee:	a32c      	add	r3, pc, #176	; (adr r3, e9a0 <__ieee754_acos+0x4b8>)
    e8f0:	e9d3 2300 	ldrd	r2, r3, [r3]
    e8f4:	f7fd fcaa 	bl	c24c <__adddf3>
    e8f8:	4622      	mov	r2, r4
    e8fa:	462b      	mov	r3, r5
    e8fc:	f7fd fe5c 	bl	c5b8 <__aeabi_dmul>
    e900:	a329      	add	r3, pc, #164	; (adr r3, e9a8 <__ieee754_acos+0x4c0>)
    e902:	e9d3 2300 	ldrd	r2, r3, [r3]
    e906:	f7fd fc9f 	bl	c248 <__aeabi_dsub>
    e90a:	4622      	mov	r2, r4
    e90c:	462b      	mov	r3, r5
    e90e:	f7fd fe53 	bl	c5b8 <__aeabi_dmul>
    e912:	2200      	movs	r2, #0
    e914:	4b2a      	ldr	r3, [pc, #168]	; (e9c0 <__ieee754_acos+0x4d8>)
    e916:	f7fd fc99 	bl	c24c <__adddf3>
    e91a:	4602      	mov	r2, r0
    e91c:	460b      	mov	r3, r1
    e91e:	4640      	mov	r0, r8
    e920:	4649      	mov	r1, r9
    e922:	f7fd ff73 	bl	c80c <__aeabi_ddiv>
    e926:	4632      	mov	r2, r6
    e928:	463b      	mov	r3, r7
    e92a:	f7fd fe45 	bl	c5b8 <__aeabi_dmul>
    e92e:	a320      	add	r3, pc, #128	; (adr r3, e9b0 <__ieee754_acos+0x4c8>)
    e930:	e9d3 2300 	ldrd	r2, r3, [r3]
    e934:	f7fd fc88 	bl	c248 <__aeabi_dsub>
    e938:	4632      	mov	r2, r6
    e93a:	463b      	mov	r3, r7
    e93c:	f7fd fc86 	bl	c24c <__adddf3>
    e940:	4602      	mov	r2, r0
    e942:	460b      	mov	r3, r1
    e944:	f7fd fc82 	bl	c24c <__adddf3>
    e948:	4602      	mov	r2, r0
    e94a:	460b      	mov	r3, r1
    e94c:	a11a      	add	r1, pc, #104	; (adr r1, e9b8 <__ieee754_acos+0x4d0>)
    e94e:	e9d1 0100 	ldrd	r0, r1, [r1]
    e952:	f7fd fc79 	bl	c248 <__aeabi_dsub>
    e956:	ec41 0b10 	vmov	d0, r0, r1
    e95a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e95e:	bf00      	nop
    e960:	0dfdf709 	.word	0x0dfdf709
    e964:	3f023de1 	.word	0x3f023de1
    e968:	7501b288 	.word	0x7501b288
    e96c:	3f49efe0 	.word	0x3f49efe0
    e970:	b5688f3b 	.word	0xb5688f3b
    e974:	3fa48228 	.word	0x3fa48228
    e978:	0e884455 	.word	0x0e884455
    e97c:	3fc9c155 	.word	0x3fc9c155
    e980:	03eb6f7d 	.word	0x03eb6f7d
    e984:	3fd4d612 	.word	0x3fd4d612
    e988:	55555555 	.word	0x55555555
    e98c:	3fc55555 	.word	0x3fc55555
    e990:	b12e9282 	.word	0xb12e9282
    e994:	3fb3b8c5 	.word	0x3fb3b8c5
    e998:	1b8d0159 	.word	0x1b8d0159
    e99c:	3fe6066c 	.word	0x3fe6066c
    e9a0:	9c598ac8 	.word	0x9c598ac8
    e9a4:	40002ae5 	.word	0x40002ae5
    e9a8:	1c8a2d4b 	.word	0x1c8a2d4b
    e9ac:	40033a27 	.word	0x40033a27
    e9b0:	33145c07 	.word	0x33145c07
    e9b4:	3c91a626 	.word	0x3c91a626
    e9b8:	54442d18 	.word	0x54442d18
    e9bc:	400921fb 	.word	0x400921fb
    e9c0:	3ff00000 	.word	0x3ff00000
    e9c4:	3fe00000 	.word	0x3fe00000

0000e9c8 <__ieee754_pow>:
    e9c8:	ec51 0b11 	vmov	r0, r1, d1
    e9cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e9d0:	f021 4800 	bic.w	r8, r1, #2147483648	; 0x80000000
    e9d4:	b093      	sub	sp, #76	; 0x4c
    e9d6:	ea58 0400 	orrs.w	r4, r8, r0
    e9da:	d020      	beq.n	ea1e <__ieee754_pow+0x56>
    e9dc:	4c5c      	ldr	r4, [pc, #368]	; (eb50 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xf0>)
    e9de:	ee10 aa10 	vmov	sl, s0
    e9e2:	ec53 2b10 	vmov	r2, r3, d0
    e9e6:	f023 4600 	bic.w	r6, r3, #2147483648	; 0x80000000
    e9ea:	461f      	mov	r7, r3
    e9ec:	42a6      	cmp	r6, r4
    e9ee:	dc11      	bgt.n	ea14 <__ieee754_pow+0x4c>
    e9f0:	4689      	mov	r9, r1
    e9f2:	ee11 ca10 	vmov	ip, s2
    e9f6:	d106      	bne.n	ea06 <__ieee754_pow+0x3e>
    e9f8:	b12a      	cbz	r2, ea06 <__ieee754_pow+0x3e>
    e9fa:	4856      	ldr	r0, [pc, #344]	; (eb54 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xf4>)
    e9fc:	b013      	add	sp, #76	; 0x4c
    e9fe:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ea02:	f000 bd61 	b.w	f4c8 <nan>
    ea06:	4c52      	ldr	r4, [pc, #328]	; (eb50 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xf0>)
    ea08:	45a0      	cmp	r8, r4
    ea0a:	dc03      	bgt.n	ea14 <__ieee754_pow+0x4c>
    ea0c:	d10e      	bne.n	ea2c <__ieee754_pow+0x64>
    ea0e:	f1bc 0f00 	cmp.w	ip, #0
    ea12:	d00b      	beq.n	ea2c <__ieee754_pow+0x64>
    ea14:	4b50      	ldr	r3, [pc, #320]	; (eb58 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xf8>)
    ea16:	4433      	add	r3, r6
    ea18:	ea53 030a 	orrs.w	r3, r3, sl
    ea1c:	d1ed      	bne.n	e9fa <__ieee754_pow+0x32>
    ea1e:	2000      	movs	r0, #0
    ea20:	494e      	ldr	r1, [pc, #312]	; (eb5c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xfc>)
    ea22:	ec41 0b10 	vmov	d0, r0, r1
    ea26:	b013      	add	sp, #76	; 0x4c
    ea28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ea2c:	2f00      	cmp	r7, #0
    ea2e:	4614      	mov	r4, r2
    ea30:	461d      	mov	r5, r3
    ea32:	e9cd 0100 	strd	r0, r1, [sp]
    ea36:	db44      	blt.n	eac2 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x62>
    ea38:	f04f 0b00 	mov.w	fp, #0
    ea3c:	f1bc 0f00 	cmp.w	ip, #0
    ea40:	d10f      	bne.n	ea62 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2>
    ea42:	4b43      	ldr	r3, [pc, #268]	; (eb50 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xf0>)
    ea44:	4598      	cmp	r8, r3
    ea46:	d057      	beq.n	eaf8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x98>
    ea48:	4b44      	ldr	r3, [pc, #272]	; (eb5c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xfc>)
    ea4a:	4598      	cmp	r8, r3
    ea4c:	d067      	beq.n	eb1e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xbe>
    ea4e:	f1b9 4f80 	cmp.w	r9, #1073741824	; 0x40000000
    ea52:	f000 84a9 	beq.w	f3a8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x948>
    ea56:	4b42      	ldr	r3, [pc, #264]	; (eb60 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x100>)
    ea58:	4599      	cmp	r9, r3
    ea5a:	d102      	bne.n	ea62 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2>
    ea5c:	2f00      	cmp	r7, #0
    ea5e:	f280 84f1 	bge.w	f444 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x9e4>
    ea62:	ec45 4b10 	vmov	d0, r4, r5
    ea66:	f01a ff7d 	bl	29964 <fabs>
    ea6a:	ec51 0b10 	vmov	r0, r1, d0
    ea6e:	f1ba 0f00 	cmp.w	sl, #0
    ea72:	d108      	bne.n	ea86 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x26>
    ea74:	f027 4340 	bic.w	r3, r7, #3221225472	; 0xc0000000
    ea78:	4a38      	ldr	r2, [pc, #224]	; (eb5c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xfc>)
    ea7a:	4293      	cmp	r3, r2
    ea7c:	f000 8395 	beq.w	f1aa <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x74a>
    ea80:	2e00      	cmp	r6, #0
    ea82:	f000 8392 	beq.w	f1aa <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x74a>
    ea86:	0ffb      	lsrs	r3, r7, #31
    ea88:	f103 3aff 	add.w	sl, r3, #4294967295
    ea8c:	ea5b 030a 	orrs.w	r3, fp, sl
    ea90:	d04c      	beq.n	eb2c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xcc>
    ea92:	4b34      	ldr	r3, [pc, #208]	; (eb64 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x104>)
    ea94:	4598      	cmp	r8, r3
    ea96:	dd6b      	ble.n	eb70 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x110>
    ea98:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
    ea9c:	4598      	cmp	r8, r3
    ea9e:	f340 8411 	ble.w	f2c4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x864>
    eaa2:	4b31      	ldr	r3, [pc, #196]	; (eb68 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x108>)
    eaa4:	429e      	cmp	r6, r3
    eaa6:	f340 8395 	ble.w	f1d4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x774>
    eaaa:	f1b9 0f00 	cmp.w	r9, #0
    eaae:	f340 8395 	ble.w	f1dc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x77c>
    eab2:	a325      	add	r3, pc, #148	; (adr r3, eb48 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xe8>)
    eab4:	e9d3 2300 	ldrd	r2, r3, [r3]
    eab8:	4610      	mov	r0, r2
    eaba:	4619      	mov	r1, r3
    eabc:	f7fd fd7c 	bl	c5b8 <__aeabi_dmul>
    eac0:	e7af      	b.n	ea22 <__ieee754_pow+0x5a>
    eac2:	4b2a      	ldr	r3, [pc, #168]	; (eb6c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x10c>)
    eac4:	4598      	cmp	r8, r3
    eac6:	dc27      	bgt.n	eb18 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xb8>
    eac8:	f1a3 7354 	sub.w	r3, r3, #55574528	; 0x3500000
    eacc:	4598      	cmp	r8, r3
    eace:	ddb3      	ble.n	ea38 <__ieee754_pow+0x70>
    ead0:	ea4f 5328 	mov.w	r3, r8, asr #20
    ead4:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
    ead8:	2b14      	cmp	r3, #20
    eada:	f340 846d 	ble.w	f3b8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x958>
    eade:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
    eae2:	fa2c f203 	lsr.w	r2, ip, r3
    eae6:	fa02 f303 	lsl.w	r3, r2, r3
    eaea:	4563      	cmp	r3, ip
    eaec:	d1a4      	bne.n	ea38 <__ieee754_pow+0x70>
    eaee:	f002 0201 	and.w	r2, r2, #1
    eaf2:	f1c2 0b02 	rsb	fp, r2, #2
    eaf6:	e7a1      	b.n	ea3c <__ieee754_pow+0x74>
    eaf8:	4b17      	ldr	r3, [pc, #92]	; (eb58 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xf8>)
    eafa:	4433      	add	r3, r6
    eafc:	ea53 030a 	orrs.w	r3, r3, sl
    eb00:	d08d      	beq.n	ea1e <__ieee754_pow+0x56>
    eb02:	4b19      	ldr	r3, [pc, #100]	; (eb68 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x108>)
    eb04:	429e      	cmp	r6, r3
    eb06:	f340 8394 	ble.w	f232 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x7d2>
    eb0a:	f1b9 0f00 	cmp.w	r9, #0
    eb0e:	f2c0 8365 	blt.w	f1dc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x77c>
    eb12:	e9dd 0100 	ldrd	r0, r1, [sp]
    eb16:	e784      	b.n	ea22 <__ieee754_pow+0x5a>
    eb18:	f04f 0b02 	mov.w	fp, #2
    eb1c:	e78e      	b.n	ea3c <__ieee754_pow+0x74>
    eb1e:	f1b9 0f00 	cmp.w	r9, #0
    eb22:	f2c0 8439 	blt.w	f398 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x938>
    eb26:	4620      	mov	r0, r4
    eb28:	4629      	mov	r1, r5
    eb2a:	e77a      	b.n	ea22 <__ieee754_pow+0x5a>
    eb2c:	4622      	mov	r2, r4
    eb2e:	462b      	mov	r3, r5
    eb30:	4610      	mov	r0, r2
    eb32:	4619      	mov	r1, r3
    eb34:	f7fd fb88 	bl	c248 <__aeabi_dsub>
    eb38:	4602      	mov	r2, r0
    eb3a:	460b      	mov	r3, r1
    eb3c:	f7fd fe66 	bl	c80c <__aeabi_ddiv>
    eb40:	e76f      	b.n	ea22 <__ieee754_pow+0x5a>
    eb42:	bf00      	nop
    eb44:	f3af 8000 	nop.w
    eb48:	8800759c 	.word	0x8800759c
    eb4c:	7e37e43c 	.word	0x7e37e43c
    eb50:	7ff00000 	.word	0x7ff00000
    eb54:	00030d9c 	.word	0x00030d9c
    eb58:	c0100000 	.word	0xc0100000
    eb5c:	3ff00000 	.word	0x3ff00000
    eb60:	3fe00000 	.word	0x3fe00000
    eb64:	41e00000 	.word	0x41e00000
    eb68:	3fefffff 	.word	0x3fefffff
    eb6c:	433fffff 	.word	0x433fffff
    eb70:	4bd3      	ldr	r3, [pc, #844]	; (eec0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x460>)
    eb72:	403b      	ands	r3, r7
    eb74:	2b00      	cmp	r3, #0
    eb76:	f040 840c 	bne.w	f392 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x932>
    eb7a:	2200      	movs	r2, #0
    eb7c:	4bd1      	ldr	r3, [pc, #836]	; (eec4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x464>)
    eb7e:	f7fd fd1b 	bl	c5b8 <__aeabi_dmul>
    eb82:	f06f 0534 	mvn.w	r5, #52	; 0x34
    eb86:	460e      	mov	r6, r1
    eb88:	1533      	asrs	r3, r6, #20
    eb8a:	4acf      	ldr	r2, [pc, #828]	; (eec8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x468>)
    eb8c:	f3c6 0613 	ubfx	r6, r6, #0, #20
    eb90:	4cce      	ldr	r4, [pc, #824]	; (eecc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x46c>)
    eb92:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
    eb96:	4296      	cmp	r6, r2
    eb98:	ea44 0406 	orr.w	r4, r4, r6
    eb9c:	441d      	add	r5, r3
    eb9e:	950b      	str	r5, [sp, #44]	; 0x2c
    eba0:	f340 83eb 	ble.w	f37a <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x91a>
    eba4:	4bca      	ldr	r3, [pc, #808]	; (eed0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x470>)
    eba6:	429e      	cmp	r6, r3
    eba8:	f340 842b 	ble.w	f402 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x9a2>
    ebac:	3501      	adds	r5, #1
    ebae:	f5a4 1480 	sub.w	r4, r4, #1048576	; 0x100000
    ebb2:	ed9f 7bad 	vldr	d7, [pc, #692]	; ee68 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x408>
    ebb6:	950b      	str	r5, [sp, #44]	; 0x2c
    ebb8:	2500      	movs	r5, #0
    ebba:	ed8d 7b08 	vstr	d7, [sp, #32]
    ebbe:	ed9f 7bac 	vldr	d7, [pc, #688]	; ee70 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x410>
    ebc2:	ed8d 7b06 	vstr	d7, [sp, #24]
    ebc6:	ed9f 7ba8 	vldr	d7, [pc, #672]	; ee68 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x408>
    ebca:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
    ebce:	4680      	mov	r8, r0
    ebd0:	46a1      	mov	r9, r4
    ebd2:	4621      	mov	r1, r4
    ebd4:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    ebd8:	f7fd fb36 	bl	c248 <__aeabi_dsub>
    ebdc:	4606      	mov	r6, r0
    ebde:	460f      	mov	r7, r1
    ebe0:	4640      	mov	r0, r8
    ebe2:	4621      	mov	r1, r4
    ebe4:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    ebe8:	e9cd 890c 	strd	r8, r9, [sp, #48]	; 0x30
    ebec:	f7fd fb2e 	bl	c24c <__adddf3>
    ebf0:	4602      	mov	r2, r0
    ebf2:	460b      	mov	r3, r1
    ebf4:	2000      	movs	r0, #0
    ebf6:	49b5      	ldr	r1, [pc, #724]	; (eecc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x46c>)
    ebf8:	f7fd fe08 	bl	c80c <__aeabi_ddiv>
    ebfc:	460a      	mov	r2, r1
    ebfe:	4601      	mov	r1, r0
    ec00:	4613      	mov	r3, r2
    ec02:	e9cd 120e 	strd	r1, r2, [sp, #56]	; 0x38
    ec06:	4602      	mov	r2, r0
    ec08:	4639      	mov	r1, r7
    ec0a:	4630      	mov	r0, r6
    ec0c:	f7fd fcd4 	bl	c5b8 <__aeabi_dmul>
    ec10:	4680      	mov	r8, r0
    ec12:	1063      	asrs	r3, r4, #1
    ec14:	4689      	mov	r9, r1
    ec16:	2400      	movs	r4, #0
    ec18:	2000      	movs	r0, #0
    ec1a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    ec1e:	4602      	mov	r2, r0
    ec20:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
    ec24:	e9cd 8902 	strd	r8, r9, [sp, #8]
    ec28:	9402      	str	r4, [sp, #8]
    ec2a:	1959      	adds	r1, r3, r5
    ec2c:	4604      	mov	r4, r0
    ec2e:	460d      	mov	r5, r1
    ec30:	460b      	mov	r3, r1
    ec32:	e9cd 8904 	strd	r8, r9, [sp, #16]
    ec36:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
    ec3a:	4640      	mov	r0, r8
    ec3c:	4649      	mov	r1, r9
    ec3e:	f7fd fcbb 	bl	c5b8 <__aeabi_dmul>
    ec42:	4602      	mov	r2, r0
    ec44:	460b      	mov	r3, r1
    ec46:	4630      	mov	r0, r6
    ec48:	4639      	mov	r1, r7
    ec4a:	f7fd fafd 	bl	c248 <__aeabi_dsub>
    ec4e:	4606      	mov	r6, r0
    ec50:	460f      	mov	r7, r1
    ec52:	4620      	mov	r0, r4
    ec54:	4629      	mov	r1, r5
    ec56:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    ec5a:	f7fd faf5 	bl	c248 <__aeabi_dsub>
    ec5e:	4602      	mov	r2, r0
    ec60:	460b      	mov	r3, r1
    ec62:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
    ec66:	f7fd faef 	bl	c248 <__aeabi_dsub>
    ec6a:	4642      	mov	r2, r8
    ec6c:	464b      	mov	r3, r9
    ec6e:	f7fd fca3 	bl	c5b8 <__aeabi_dmul>
    ec72:	4602      	mov	r2, r0
    ec74:	460b      	mov	r3, r1
    ec76:	4630      	mov	r0, r6
    ec78:	4639      	mov	r1, r7
    ec7a:	f7fd fae5 	bl	c248 <__aeabi_dsub>
    ec7e:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
    ec82:	f7fd fc99 	bl	c5b8 <__aeabi_dmul>
    ec86:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
    ec8a:	e9cd 0106 	strd	r0, r1, [sp, #24]
    ec8e:	4622      	mov	r2, r4
    ec90:	462b      	mov	r3, r5
    ec92:	4620      	mov	r0, r4
    ec94:	4629      	mov	r1, r5
    ec96:	f7fd fc8f 	bl	c5b8 <__aeabi_dmul>
    ec9a:	4604      	mov	r4, r0
    ec9c:	460d      	mov	r5, r1
    ec9e:	a376      	add	r3, pc, #472	; (adr r3, ee78 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x418>)
    eca0:	e9d3 2300 	ldrd	r2, r3, [r3]
    eca4:	f7fd fc88 	bl	c5b8 <__aeabi_dmul>
    eca8:	a375      	add	r3, pc, #468	; (adr r3, ee80 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x420>)
    ecaa:	e9d3 2300 	ldrd	r2, r3, [r3]
    ecae:	f7fd facd 	bl	c24c <__adddf3>
    ecb2:	4622      	mov	r2, r4
    ecb4:	462b      	mov	r3, r5
    ecb6:	f7fd fc7f 	bl	c5b8 <__aeabi_dmul>
    ecba:	a373      	add	r3, pc, #460	; (adr r3, ee88 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x428>)
    ecbc:	e9d3 2300 	ldrd	r2, r3, [r3]
    ecc0:	f7fd fac4 	bl	c24c <__adddf3>
    ecc4:	4622      	mov	r2, r4
    ecc6:	462b      	mov	r3, r5
    ecc8:	f7fd fc76 	bl	c5b8 <__aeabi_dmul>
    eccc:	a370      	add	r3, pc, #448	; (adr r3, ee90 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x430>)
    ecce:	e9d3 2300 	ldrd	r2, r3, [r3]
    ecd2:	f7fd fabb 	bl	c24c <__adddf3>
    ecd6:	4622      	mov	r2, r4
    ecd8:	462b      	mov	r3, r5
    ecda:	f7fd fc6d 	bl	c5b8 <__aeabi_dmul>
    ecde:	a36e      	add	r3, pc, #440	; (adr r3, ee98 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x438>)
    ece0:	e9d3 2300 	ldrd	r2, r3, [r3]
    ece4:	f7fd fab2 	bl	c24c <__adddf3>
    ece8:	4622      	mov	r2, r4
    ecea:	462b      	mov	r3, r5
    ecec:	f7fd fc64 	bl	c5b8 <__aeabi_dmul>
    ecf0:	a36b      	add	r3, pc, #428	; (adr r3, eea0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x440>)
    ecf2:	e9d3 2300 	ldrd	r2, r3, [r3]
    ecf6:	f7fd faa9 	bl	c24c <__adddf3>
    ecfa:	4606      	mov	r6, r0
    ecfc:	460f      	mov	r7, r1
    ecfe:	4622      	mov	r2, r4
    ed00:	462b      	mov	r3, r5
    ed02:	4620      	mov	r0, r4
    ed04:	4629      	mov	r1, r5
    ed06:	f7fd fc57 	bl	c5b8 <__aeabi_dmul>
    ed0a:	4602      	mov	r2, r0
    ed0c:	460b      	mov	r3, r1
    ed0e:	4630      	mov	r0, r6
    ed10:	4639      	mov	r1, r7
    ed12:	f7fd fc51 	bl	c5b8 <__aeabi_dmul>
    ed16:	4642      	mov	r2, r8
    ed18:	4604      	mov	r4, r0
    ed1a:	460d      	mov	r5, r1
    ed1c:	464b      	mov	r3, r9
    ed1e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    ed22:	f7fd fa93 	bl	c24c <__adddf3>
    ed26:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    ed2a:	f7fd fc45 	bl	c5b8 <__aeabi_dmul>
    ed2e:	4622      	mov	r2, r4
    ed30:	462b      	mov	r3, r5
    ed32:	f7fd fa8b 	bl	c24c <__adddf3>
    ed36:	4642      	mov	r2, r8
    ed38:	4604      	mov	r4, r0
    ed3a:	460d      	mov	r5, r1
    ed3c:	464b      	mov	r3, r9
    ed3e:	4640      	mov	r0, r8
    ed40:	4649      	mov	r1, r9
    ed42:	f7fd fc39 	bl	c5b8 <__aeabi_dmul>
    ed46:	2200      	movs	r2, #0
    ed48:	4b62      	ldr	r3, [pc, #392]	; (eed4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x474>)
    ed4a:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
    ed4e:	f7fd fa7d 	bl	c24c <__adddf3>
    ed52:	4622      	mov	r2, r4
    ed54:	462b      	mov	r3, r5
    ed56:	f7fd fa79 	bl	c24c <__adddf3>
    ed5a:	9802      	ldr	r0, [sp, #8]
    ed5c:	460f      	mov	r7, r1
    ed5e:	4649      	mov	r1, r9
    ed60:	4606      	mov	r6, r0
    ed62:	4640      	mov	r0, r8
    ed64:	463b      	mov	r3, r7
    ed66:	4632      	mov	r2, r6
    ed68:	f7fd fc26 	bl	c5b8 <__aeabi_dmul>
    ed6c:	2200      	movs	r2, #0
    ed6e:	4680      	mov	r8, r0
    ed70:	4689      	mov	r9, r1
    ed72:	4b58      	ldr	r3, [pc, #352]	; (eed4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x474>)
    ed74:	4630      	mov	r0, r6
    ed76:	4639      	mov	r1, r7
    ed78:	f7fd fa66 	bl	c248 <__aeabi_dsub>
    ed7c:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
    ed80:	f7fd fa62 	bl	c248 <__aeabi_dsub>
    ed84:	4602      	mov	r2, r0
    ed86:	460b      	mov	r3, r1
    ed88:	4620      	mov	r0, r4
    ed8a:	4629      	mov	r1, r5
    ed8c:	f7fd fa5c 	bl	c248 <__aeabi_dsub>
    ed90:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    ed94:	f7fd fc10 	bl	c5b8 <__aeabi_dmul>
    ed98:	4604      	mov	r4, r0
    ed9a:	460d      	mov	r5, r1
    ed9c:	4632      	mov	r2, r6
    ed9e:	463b      	mov	r3, r7
    eda0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    eda4:	f7fd fc08 	bl	c5b8 <__aeabi_dmul>
    eda8:	4602      	mov	r2, r0
    edaa:	460b      	mov	r3, r1
    edac:	4620      	mov	r0, r4
    edae:	4629      	mov	r1, r5
    edb0:	f7fd fa4c 	bl	c24c <__adddf3>
    edb4:	4604      	mov	r4, r0
    edb6:	460d      	mov	r5, r1
    edb8:	4602      	mov	r2, r0
    edba:	460b      	mov	r3, r1
    edbc:	4640      	mov	r0, r8
    edbe:	4649      	mov	r1, r9
    edc0:	f7fd fa44 	bl	c24c <__adddf3>
    edc4:	9802      	ldr	r0, [sp, #8]
    edc6:	460f      	mov	r7, r1
    edc8:	4606      	mov	r6, r0
    edca:	a337      	add	r3, pc, #220	; (adr r3, eea8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x448>)
    edcc:	e9d3 2300 	ldrd	r2, r3, [r3]
    edd0:	f7fd fbf2 	bl	c5b8 <__aeabi_dmul>
    edd4:	4642      	mov	r2, r8
    edd6:	464b      	mov	r3, r9
    edd8:	e9cd 0104 	strd	r0, r1, [sp, #16]
    eddc:	4630      	mov	r0, r6
    edde:	4639      	mov	r1, r7
    ede0:	f7fd fa32 	bl	c248 <__aeabi_dsub>
    ede4:	4602      	mov	r2, r0
    ede6:	460b      	mov	r3, r1
    ede8:	4620      	mov	r0, r4
    edea:	4629      	mov	r1, r5
    edec:	f7fd fa2c 	bl	c248 <__aeabi_dsub>
    edf0:	a32f      	add	r3, pc, #188	; (adr r3, eeb0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x450>)
    edf2:	e9d3 2300 	ldrd	r2, r3, [r3]
    edf6:	f7fd fbdf 	bl	c5b8 <__aeabi_dmul>
    edfa:	4604      	mov	r4, r0
    edfc:	460d      	mov	r5, r1
    edfe:	4630      	mov	r0, r6
    ee00:	4639      	mov	r1, r7
    ee02:	a32d      	add	r3, pc, #180	; (adr r3, eeb8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x458>)
    ee04:	e9d3 2300 	ldrd	r2, r3, [r3]
    ee08:	f7fd fbd6 	bl	c5b8 <__aeabi_dmul>
    ee0c:	4602      	mov	r2, r0
    ee0e:	460b      	mov	r3, r1
    ee10:	4620      	mov	r0, r4
    ee12:	4629      	mov	r1, r5
    ee14:	f7fd fa1a 	bl	c24c <__adddf3>
    ee18:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
    ee1c:	f7fd fa16 	bl	c24c <__adddf3>
    ee20:	4606      	mov	r6, r0
    ee22:	460f      	mov	r7, r1
    ee24:	980b      	ldr	r0, [sp, #44]	; 0x2c
    ee26:	f7fd fb5d 	bl	c4e4 <__aeabi_i2d>
    ee2a:	4632      	mov	r2, r6
    ee2c:	4680      	mov	r8, r0
    ee2e:	4689      	mov	r9, r1
    ee30:	463b      	mov	r3, r7
    ee32:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    ee36:	f7fd fa09 	bl	c24c <__adddf3>
    ee3a:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    ee3e:	f7fd fa05 	bl	c24c <__adddf3>
    ee42:	4642      	mov	r2, r8
    ee44:	464b      	mov	r3, r9
    ee46:	f7fd fa01 	bl	c24c <__adddf3>
    ee4a:	9802      	ldr	r0, [sp, #8]
    ee4c:	4642      	mov	r2, r8
    ee4e:	464b      	mov	r3, r9
    ee50:	4604      	mov	r4, r0
    ee52:	460d      	mov	r5, r1
    ee54:	f7fd f9f8 	bl	c248 <__aeabi_dsub>
    ee58:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    ee5c:	f7fd f9f4 	bl	c248 <__aeabi_dsub>
    ee60:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    ee64:	e038      	b.n	eed8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x478>
    ee66:	bf00      	nop
	...
    ee74:	3ff00000 	.word	0x3ff00000
    ee78:	4a454eef 	.word	0x4a454eef
    ee7c:	3fca7e28 	.word	0x3fca7e28
    ee80:	93c9db65 	.word	0x93c9db65
    ee84:	3fcd864a 	.word	0x3fcd864a
    ee88:	a91d4101 	.word	0xa91d4101
    ee8c:	3fd17460 	.word	0x3fd17460
    ee90:	518f264d 	.word	0x518f264d
    ee94:	3fd55555 	.word	0x3fd55555
    ee98:	db6fabff 	.word	0xdb6fabff
    ee9c:	3fdb6db6 	.word	0x3fdb6db6
    eea0:	33333303 	.word	0x33333303
    eea4:	3fe33333 	.word	0x3fe33333
    eea8:	e0000000 	.word	0xe0000000
    eeac:	3feec709 	.word	0x3feec709
    eeb0:	dc3a03fd 	.word	0xdc3a03fd
    eeb4:	3feec709 	.word	0x3feec709
    eeb8:	145b01f5 	.word	0x145b01f5
    eebc:	be3e2fe0 	.word	0xbe3e2fe0
    eec0:	7ff00000 	.word	0x7ff00000
    eec4:	43400000 	.word	0x43400000
    eec8:	0003988e 	.word	0x0003988e
    eecc:	3ff00000 	.word	0x3ff00000
    eed0:	000bb679 	.word	0x000bb679
    eed4:	40080000 	.word	0x40080000
    eed8:	f7fd f9b6 	bl	c248 <__aeabi_dsub>
    eedc:	460b      	mov	r3, r1
    eede:	4602      	mov	r2, r0
    eee0:	4639      	mov	r1, r7
    eee2:	4630      	mov	r0, r6
    eee4:	f7fd f9b0 	bl	c248 <__aeabi_dsub>
    eee8:	f10b 33ff 	add.w	r3, fp, #4294967295
    eeec:	ea53 030a 	orrs.w	r3, r3, sl
    eef0:	e9cd 0102 	strd	r0, r1, [sp, #8]
    eef4:	f040 8175 	bne.w	f1e2 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x782>
    eef8:	ed9f 7bd3 	vldr	d7, [pc, #844]	; f248 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x7e8>
    eefc:	ed8d 7b04 	vstr	d7, [sp, #16]
    ef00:	e9dd ab00 	ldrd	sl, fp, [sp]
    ef04:	4652      	mov	r2, sl
    ef06:	465b      	mov	r3, fp
    ef08:	4650      	mov	r0, sl
    ef0a:	4659      	mov	r1, fp
    ef0c:	e9cd 2300 	strd	r2, r3, [sp]
    ef10:	2300      	movs	r3, #0
    ef12:	9300      	str	r3, [sp, #0]
    ef14:	e9dd 6700 	ldrd	r6, r7, [sp]
    ef18:	4632      	mov	r2, r6
    ef1a:	463b      	mov	r3, r7
    ef1c:	f7fd f994 	bl	c248 <__aeabi_dsub>
    ef20:	4622      	mov	r2, r4
    ef22:	462b      	mov	r3, r5
    ef24:	f7fd fb48 	bl	c5b8 <__aeabi_dmul>
    ef28:	4680      	mov	r8, r0
    ef2a:	4689      	mov	r9, r1
    ef2c:	4652      	mov	r2, sl
    ef2e:	465b      	mov	r3, fp
    ef30:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    ef34:	f7fd fb40 	bl	c5b8 <__aeabi_dmul>
    ef38:	4602      	mov	r2, r0
    ef3a:	460b      	mov	r3, r1
    ef3c:	4640      	mov	r0, r8
    ef3e:	4649      	mov	r1, r9
    ef40:	f7fd f984 	bl	c24c <__adddf3>
    ef44:	468b      	mov	fp, r1
    ef46:	4682      	mov	sl, r0
    ef48:	4632      	mov	r2, r6
    ef4a:	463b      	mov	r3, r7
    ef4c:	4620      	mov	r0, r4
    ef4e:	4629      	mov	r1, r5
    ef50:	e9cd ab02 	strd	sl, fp, [sp, #8]
    ef54:	f7fd fb30 	bl	c5b8 <__aeabi_dmul>
    ef58:	460b      	mov	r3, r1
    ef5a:	4602      	mov	r2, r0
    ef5c:	4680      	mov	r8, r0
    ef5e:	4689      	mov	r9, r1
    ef60:	4650      	mov	r0, sl
    ef62:	4659      	mov	r1, fp
    ef64:	f7fd f972 	bl	c24c <__adddf3>
    ef68:	4bcf      	ldr	r3, [pc, #828]	; (f2a8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x848>)
    ef6a:	4604      	mov	r4, r0
    ef6c:	460d      	mov	r5, r1
    ef6e:	4299      	cmp	r1, r3
    ef70:	468b      	mov	fp, r1
    ef72:	f340 813b 	ble.w	f1ec <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x78c>
    ef76:	4bcd      	ldr	r3, [pc, #820]	; (f2ac <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x84c>)
    ef78:	440b      	add	r3, r1
    ef7a:	4303      	orrs	r3, r0
    ef7c:	f040 8233 	bne.w	f3e6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x986>
    ef80:	a3b3      	add	r3, pc, #716	; (adr r3, f250 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x7f0>)
    ef82:	e9d3 2300 	ldrd	r2, r3, [r3]
    ef86:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    ef8a:	f7fd f95f 	bl	c24c <__adddf3>
    ef8e:	4606      	mov	r6, r0
    ef90:	460f      	mov	r7, r1
    ef92:	4642      	mov	r2, r8
    ef94:	464b      	mov	r3, r9
    ef96:	4620      	mov	r0, r4
    ef98:	4629      	mov	r1, r5
    ef9a:	f7fd f955 	bl	c248 <__aeabi_dsub>
    ef9e:	4602      	mov	r2, r0
    efa0:	460b      	mov	r3, r1
    efa2:	4630      	mov	r0, r6
    efa4:	4639      	mov	r1, r7
    efa6:	f7fd fd97 	bl	cad8 <__aeabi_dcmpgt>
    efaa:	2800      	cmp	r0, #0
    efac:	f040 821b 	bne.w	f3e6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x986>
    efb0:	f3cb 530a 	ubfx	r3, fp, #20, #11
    efb4:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    efb8:	f2a3 33fe 	subw	r3, r3, #1022	; 0x3fe
    efbc:	4cbc      	ldr	r4, [pc, #752]	; (f2b0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x850>)
    efbe:	f1bb 0f00 	cmp.w	fp, #0
    efc2:	fa42 f303 	asr.w	r3, r2, r3
    efc6:	f04f 0000 	mov.w	r0, #0
    efca:	445b      	add	r3, fp
    efcc:	f3c3 520a 	ubfx	r2, r3, #20, #11
    efd0:	f3c3 0a13 	ubfx	sl, r3, #0, #20
    efd4:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
    efd8:	f44a 1a80 	orr.w	sl, sl, #1048576	; 0x100000
    efdc:	fa44 f402 	asr.w	r4, r4, r2
    efe0:	f1c2 0214 	rsb	r2, r2, #20
    efe4:	ea23 0104 	bic.w	r1, r3, r4
    efe8:	fa4a fa02 	asr.w	sl, sl, r2
    efec:	4602      	mov	r2, r0
    efee:	4640      	mov	r0, r8
    eff0:	460b      	mov	r3, r1
    eff2:	bfb8      	it	lt
    eff4:	f1ca 0a00 	rsblt	sl, sl, #0
    eff8:	4649      	mov	r1, r9
    effa:	f7fd f925 	bl	c248 <__aeabi_dsub>
    effe:	4602      	mov	r2, r0
    f000:	460b      	mov	r3, r1
    f002:	4680      	mov	r8, r0
    f004:	4689      	mov	r9, r1
    f006:	ea4f 5b0a 	mov.w	fp, sl, lsl #20
    f00a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    f00e:	f7fd f91d 	bl	c24c <__adddf3>
    f012:	460d      	mov	r5, r1
    f014:	2400      	movs	r4, #0
    f016:	4629      	mov	r1, r5
    f018:	a38f      	add	r3, pc, #572	; (adr r3, f258 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x7f8>)
    f01a:	e9d3 2300 	ldrd	r2, r3, [r3]
    f01e:	4620      	mov	r0, r4
    f020:	f7fd faca 	bl	c5b8 <__aeabi_dmul>
    f024:	4642      	mov	r2, r8
    f026:	4606      	mov	r6, r0
    f028:	460f      	mov	r7, r1
    f02a:	464b      	mov	r3, r9
    f02c:	4620      	mov	r0, r4
    f02e:	4629      	mov	r1, r5
    f030:	f7fd f90a 	bl	c248 <__aeabi_dsub>
    f034:	4602      	mov	r2, r0
    f036:	460b      	mov	r3, r1
    f038:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    f03c:	f7fd f904 	bl	c248 <__aeabi_dsub>
    f040:	a387      	add	r3, pc, #540	; (adr r3, f260 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x800>)
    f042:	e9d3 2300 	ldrd	r2, r3, [r3]
    f046:	f7fd fab7 	bl	c5b8 <__aeabi_dmul>
    f04a:	4680      	mov	r8, r0
    f04c:	4689      	mov	r9, r1
    f04e:	4620      	mov	r0, r4
    f050:	4629      	mov	r1, r5
    f052:	a385      	add	r3, pc, #532	; (adr r3, f268 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x808>)
    f054:	e9d3 2300 	ldrd	r2, r3, [r3]
    f058:	f7fd faae 	bl	c5b8 <__aeabi_dmul>
    f05c:	4602      	mov	r2, r0
    f05e:	460b      	mov	r3, r1
    f060:	4640      	mov	r0, r8
    f062:	4649      	mov	r1, r9
    f064:	f7fd f8f2 	bl	c24c <__adddf3>
    f068:	4604      	mov	r4, r0
    f06a:	460d      	mov	r5, r1
    f06c:	4602      	mov	r2, r0
    f06e:	460b      	mov	r3, r1
    f070:	4630      	mov	r0, r6
    f072:	4639      	mov	r1, r7
    f074:	f7fd f8ea 	bl	c24c <__adddf3>
    f078:	4632      	mov	r2, r6
    f07a:	4680      	mov	r8, r0
    f07c:	4689      	mov	r9, r1
    f07e:	463b      	mov	r3, r7
    f080:	f7fd f8e2 	bl	c248 <__aeabi_dsub>
    f084:	4602      	mov	r2, r0
    f086:	460b      	mov	r3, r1
    f088:	4620      	mov	r0, r4
    f08a:	4629      	mov	r1, r5
    f08c:	f7fd f8dc 	bl	c248 <__aeabi_dsub>
    f090:	4642      	mov	r2, r8
    f092:	4606      	mov	r6, r0
    f094:	460f      	mov	r7, r1
    f096:	464b      	mov	r3, r9
    f098:	4640      	mov	r0, r8
    f09a:	4649      	mov	r1, r9
    f09c:	f7fd fa8c 	bl	c5b8 <__aeabi_dmul>
    f0a0:	4604      	mov	r4, r0
    f0a2:	460d      	mov	r5, r1
    f0a4:	a372      	add	r3, pc, #456	; (adr r3, f270 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x810>)
    f0a6:	e9d3 2300 	ldrd	r2, r3, [r3]
    f0aa:	f7fd fa85 	bl	c5b8 <__aeabi_dmul>
    f0ae:	a372      	add	r3, pc, #456	; (adr r3, f278 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x818>)
    f0b0:	e9d3 2300 	ldrd	r2, r3, [r3]
    f0b4:	f7fd f8c8 	bl	c248 <__aeabi_dsub>
    f0b8:	4622      	mov	r2, r4
    f0ba:	462b      	mov	r3, r5
    f0bc:	f7fd fa7c 	bl	c5b8 <__aeabi_dmul>
    f0c0:	a36f      	add	r3, pc, #444	; (adr r3, f280 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x820>)
    f0c2:	e9d3 2300 	ldrd	r2, r3, [r3]
    f0c6:	f7fd f8c1 	bl	c24c <__adddf3>
    f0ca:	4622      	mov	r2, r4
    f0cc:	462b      	mov	r3, r5
    f0ce:	f7fd fa73 	bl	c5b8 <__aeabi_dmul>
    f0d2:	a36d      	add	r3, pc, #436	; (adr r3, f288 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x828>)
    f0d4:	e9d3 2300 	ldrd	r2, r3, [r3]
    f0d8:	f7fd f8b6 	bl	c248 <__aeabi_dsub>
    f0dc:	4622      	mov	r2, r4
    f0de:	462b      	mov	r3, r5
    f0e0:	f7fd fa6a 	bl	c5b8 <__aeabi_dmul>
    f0e4:	a36a      	add	r3, pc, #424	; (adr r3, f290 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x830>)
    f0e6:	e9d3 2300 	ldrd	r2, r3, [r3]
    f0ea:	f7fd f8af 	bl	c24c <__adddf3>
    f0ee:	4622      	mov	r2, r4
    f0f0:	462b      	mov	r3, r5
    f0f2:	f7fd fa61 	bl	c5b8 <__aeabi_dmul>
    f0f6:	4602      	mov	r2, r0
    f0f8:	460b      	mov	r3, r1
    f0fa:	4640      	mov	r0, r8
    f0fc:	4649      	mov	r1, r9
    f0fe:	f7fd f8a3 	bl	c248 <__aeabi_dsub>
    f102:	4604      	mov	r4, r0
    f104:	460d      	mov	r5, r1
    f106:	4602      	mov	r2, r0
    f108:	460b      	mov	r3, r1
    f10a:	4640      	mov	r0, r8
    f10c:	4649      	mov	r1, r9
    f10e:	f7fd fa53 	bl	c5b8 <__aeabi_dmul>
    f112:	2200      	movs	r2, #0
    f114:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    f118:	e9cd 0100 	strd	r0, r1, [sp]
    f11c:	4620      	mov	r0, r4
    f11e:	4629      	mov	r1, r5
    f120:	f7fd f892 	bl	c248 <__aeabi_dsub>
    f124:	4602      	mov	r2, r0
    f126:	460b      	mov	r3, r1
    f128:	e9dd 0100 	ldrd	r0, r1, [sp]
    f12c:	f7fd fb6e 	bl	c80c <__aeabi_ddiv>
    f130:	4632      	mov	r2, r6
    f132:	4604      	mov	r4, r0
    f134:	460d      	mov	r5, r1
    f136:	463b      	mov	r3, r7
    f138:	4640      	mov	r0, r8
    f13a:	4649      	mov	r1, r9
    f13c:	f7fd fa3c 	bl	c5b8 <__aeabi_dmul>
    f140:	4632      	mov	r2, r6
    f142:	463b      	mov	r3, r7
    f144:	f7fd f882 	bl	c24c <__adddf3>
    f148:	4602      	mov	r2, r0
    f14a:	460b      	mov	r3, r1
    f14c:	4620      	mov	r0, r4
    f14e:	4629      	mov	r1, r5
    f150:	f7fd f87a 	bl	c248 <__aeabi_dsub>
    f154:	4642      	mov	r2, r8
    f156:	464b      	mov	r3, r9
    f158:	f7fd f876 	bl	c248 <__aeabi_dsub>
    f15c:	4602      	mov	r2, r0
    f15e:	460b      	mov	r3, r1
    f160:	2000      	movs	r0, #0
    f162:	4954      	ldr	r1, [pc, #336]	; (f2b4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x854>)
    f164:	f7fd f870 	bl	c248 <__aeabi_dsub>
    f168:	448b      	add	fp, r1
    f16a:	4602      	mov	r2, r0
    f16c:	460b      	mov	r3, r1
    f16e:	f5bb 1f80 	cmp.w	fp, #1048576	; 0x100000
    f172:	f2c0 815f 	blt.w	f434 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x9d4>
    f176:	4659      	mov	r1, fp
    f178:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    f17c:	f7fd fa1c 	bl	c5b8 <__aeabi_dmul>
    f180:	e44f      	b.n	ea22 <__ieee754_pow+0x5a>
    f182:	ec45 4b10 	vmov	d0, r4, r5
    f186:	f01a fbed 	bl	29964 <fabs>
    f18a:	ec51 0b10 	vmov	r0, r1, d0
    f18e:	f1ba 0f00 	cmp.w	sl, #0
    f192:	f47f accb 	bne.w	eb2c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xcc>
    f196:	f027 4340 	bic.w	r3, r7, #3221225472	; 0xc0000000
    f19a:	4a46      	ldr	r2, [pc, #280]	; (f2b4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x854>)
    f19c:	4293      	cmp	r3, r2
    f19e:	d002      	beq.n	f1a6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x746>
    f1a0:	2e00      	cmp	r6, #0
    f1a2:	f47f acc3 	bne.w	eb2c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xcc>
    f1a6:	f04f 0b00 	mov.w	fp, #0
    f1aa:	f1b9 0f00 	cmp.w	r9, #0
    f1ae:	da05      	bge.n	f1bc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x75c>
    f1b0:	4602      	mov	r2, r0
    f1b2:	460b      	mov	r3, r1
    f1b4:	2000      	movs	r0, #0
    f1b6:	493f      	ldr	r1, [pc, #252]	; (f2b4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x854>)
    f1b8:	f7fd fb28 	bl	c80c <__aeabi_ddiv>
    f1bc:	2f00      	cmp	r7, #0
    f1be:	f6bf ac30 	bge.w	ea22 <__ieee754_pow+0x5a>
    f1c2:	4b3d      	ldr	r3, [pc, #244]	; (f2b8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x858>)
    f1c4:	4433      	add	r3, r6
    f1c6:	ea53 030b 	orrs.w	r3, r3, fp
    f1ca:	f040 812a 	bne.w	f422 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x9c2>
    f1ce:	4602      	mov	r2, r0
    f1d0:	460b      	mov	r3, r1
    f1d2:	e4ad      	b.n	eb30 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xd0>
    f1d4:	f1b9 0f00 	cmp.w	r9, #0
    f1d8:	f6ff ac6b 	blt.w	eab2 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x52>
    f1dc:	2000      	movs	r0, #0
    f1de:	2100      	movs	r1, #0
    f1e0:	e41f      	b.n	ea22 <__ieee754_pow+0x5a>
    f1e2:	ed9f 7b2d 	vldr	d7, [pc, #180]	; f298 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x838>
    f1e6:	ed8d 7b04 	vstr	d7, [sp, #16]
    f1ea:	e689      	b.n	ef00 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x4a0>
    f1ec:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
    f1f0:	4e32      	ldr	r6, [pc, #200]	; (f2bc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x85c>)
    f1f2:	42b3      	cmp	r3, r6
    f1f4:	f340 80ef 	ble.w	f3d6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x976>
    f1f8:	4b31      	ldr	r3, [pc, #196]	; (f2c0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x860>)
    f1fa:	440b      	add	r3, r1
    f1fc:	4303      	orrs	r3, r0
    f1fe:	d10a      	bne.n	f216 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x7b6>
    f200:	4642      	mov	r2, r8
    f202:	464b      	mov	r3, r9
    f204:	f7fd f820 	bl	c248 <__aeabi_dsub>
    f208:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    f20c:	f7fd fc5a 	bl	cac4 <__aeabi_dcmpge>
    f210:	2800      	cmp	r0, #0
    f212:	f43f aecd 	beq.w	efb0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x550>
    f216:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    f21a:	a321      	add	r3, pc, #132	; (adr r3, f2a0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x840>)
    f21c:	e9d3 2300 	ldrd	r2, r3, [r3]
    f220:	f7fd f9ca 	bl	c5b8 <__aeabi_dmul>
    f224:	a31e      	add	r3, pc, #120	; (adr r3, f2a0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x840>)
    f226:	e9d3 2300 	ldrd	r2, r3, [r3]
    f22a:	f7fd f9c5 	bl	c5b8 <__aeabi_dmul>
    f22e:	f7ff bbf8 	b.w	ea22 <__ieee754_pow+0x5a>
    f232:	f1b9 0f00 	cmp.w	r9, #0
    f236:	dad1      	bge.n	f1dc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x77c>
    f238:	e9dd 3400 	ldrd	r3, r4, [sp]
    f23c:	4618      	mov	r0, r3
    f23e:	f104 4100 	add.w	r1, r4, #2147483648	; 0x80000000
    f242:	f7ff bbee 	b.w	ea22 <__ieee754_pow+0x5a>
    f246:	bf00      	nop
    f248:	00000000 	.word	0x00000000
    f24c:	bff00000 	.word	0xbff00000
    f250:	652b82fe 	.word	0x652b82fe
    f254:	3c971547 	.word	0x3c971547
    f258:	00000000 	.word	0x00000000
    f25c:	3fe62e43 	.word	0x3fe62e43
    f260:	fefa39ef 	.word	0xfefa39ef
    f264:	3fe62e42 	.word	0x3fe62e42
    f268:	0ca86c39 	.word	0x0ca86c39
    f26c:	be205c61 	.word	0xbe205c61
    f270:	72bea4d0 	.word	0x72bea4d0
    f274:	3e663769 	.word	0x3e663769
    f278:	c5d26bf1 	.word	0xc5d26bf1
    f27c:	3ebbbd41 	.word	0x3ebbbd41
    f280:	af25de2c 	.word	0xaf25de2c
    f284:	3f11566a 	.word	0x3f11566a
    f288:	16bebd93 	.word	0x16bebd93
    f28c:	3f66c16c 	.word	0x3f66c16c
    f290:	5555553e 	.word	0x5555553e
    f294:	3fc55555 	.word	0x3fc55555
    f298:	00000000 	.word	0x00000000
    f29c:	3ff00000 	.word	0x3ff00000
    f2a0:	c2f8f359 	.word	0xc2f8f359
    f2a4:	01a56e1f 	.word	0x01a56e1f
    f2a8:	408fffff 	.word	0x408fffff
    f2ac:	bf700000 	.word	0xbf700000
    f2b0:	000fffff 	.word	0x000fffff
    f2b4:	3ff00000 	.word	0x3ff00000
    f2b8:	c0100000 	.word	0xc0100000
    f2bc:	4090cbff 	.word	0x4090cbff
    f2c0:	3f6f3400 	.word	0x3f6f3400
    f2c4:	4b7c      	ldr	r3, [pc, #496]	; (f4b8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa58>)
    f2c6:	429e      	cmp	r6, r3
    f2c8:	dd84      	ble.n	f1d4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x774>
    f2ca:	4b7c      	ldr	r3, [pc, #496]	; (f4bc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa5c>)
    f2cc:	429e      	cmp	r6, r3
    f2ce:	f73f abec 	bgt.w	eaaa <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x4a>
    f2d2:	2200      	movs	r2, #0
    f2d4:	4b79      	ldr	r3, [pc, #484]	; (f4bc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa5c>)
    f2d6:	f7fc ffb7 	bl	c248 <__aeabi_dsub>
    f2da:	4604      	mov	r4, r0
    f2dc:	460d      	mov	r5, r1
    f2de:	a362      	add	r3, pc, #392	; (adr r3, f468 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa08>)
    f2e0:	e9d3 2300 	ldrd	r2, r3, [r3]
    f2e4:	f7fd f968 	bl	c5b8 <__aeabi_dmul>
    f2e8:	4680      	mov	r8, r0
    f2ea:	4689      	mov	r9, r1
    f2ec:	4620      	mov	r0, r4
    f2ee:	4629      	mov	r1, r5
    f2f0:	a35f      	add	r3, pc, #380	; (adr r3, f470 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa10>)
    f2f2:	e9d3 2300 	ldrd	r2, r3, [r3]
    f2f6:	f7fd f95f 	bl	c5b8 <__aeabi_dmul>
    f2fa:	2200      	movs	r2, #0
    f2fc:	4b70      	ldr	r3, [pc, #448]	; (f4c0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa60>)
    f2fe:	e9cd 0102 	strd	r0, r1, [sp, #8]
    f302:	4620      	mov	r0, r4
    f304:	4629      	mov	r1, r5
    f306:	f7fd f957 	bl	c5b8 <__aeabi_dmul>
    f30a:	4602      	mov	r2, r0
    f30c:	460b      	mov	r3, r1
    f30e:	a15a      	add	r1, pc, #360	; (adr r1, f478 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa18>)
    f310:	e9d1 0100 	ldrd	r0, r1, [r1]
    f314:	f7fc ff98 	bl	c248 <__aeabi_dsub>
    f318:	4622      	mov	r2, r4
    f31a:	462b      	mov	r3, r5
    f31c:	f7fd f94c 	bl	c5b8 <__aeabi_dmul>
    f320:	4602      	mov	r2, r0
    f322:	460b      	mov	r3, r1
    f324:	2000      	movs	r0, #0
    f326:	4967      	ldr	r1, [pc, #412]	; (f4c4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa64>)
    f328:	f7fc ff8e 	bl	c248 <__aeabi_dsub>
    f32c:	4606      	mov	r6, r0
    f32e:	460f      	mov	r7, r1
    f330:	4622      	mov	r2, r4
    f332:	462b      	mov	r3, r5
    f334:	4620      	mov	r0, r4
    f336:	4629      	mov	r1, r5
    f338:	f7fd f93e 	bl	c5b8 <__aeabi_dmul>
    f33c:	4602      	mov	r2, r0
    f33e:	460b      	mov	r3, r1
    f340:	4630      	mov	r0, r6
    f342:	4639      	mov	r1, r7
    f344:	f7fd f938 	bl	c5b8 <__aeabi_dmul>
    f348:	a34d      	add	r3, pc, #308	; (adr r3, f480 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa20>)
    f34a:	e9d3 2300 	ldrd	r2, r3, [r3]
    f34e:	f7fd f933 	bl	c5b8 <__aeabi_dmul>
    f352:	4602      	mov	r2, r0
    f354:	460b      	mov	r3, r1
    f356:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    f35a:	f7fc ff75 	bl	c248 <__aeabi_dsub>
    f35e:	4602      	mov	r2, r0
    f360:	460b      	mov	r3, r1
    f362:	4606      	mov	r6, r0
    f364:	460f      	mov	r7, r1
    f366:	4640      	mov	r0, r8
    f368:	4649      	mov	r1, r9
    f36a:	f7fc ff6f 	bl	c24c <__adddf3>
    f36e:	2000      	movs	r0, #0
    f370:	460d      	mov	r5, r1
    f372:	4642      	mov	r2, r8
    f374:	4604      	mov	r4, r0
    f376:	464b      	mov	r3, r9
    f378:	e5ae      	b.n	eed8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x478>
    f37a:	ed9f 7b43 	vldr	d7, [pc, #268]	; f488 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa28>
    f37e:	2500      	movs	r5, #0
    f380:	ed8d 7b08 	vstr	d7, [sp, #32]
    f384:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
    f388:	ed9f 7b41 	vldr	d7, [pc, #260]	; f490 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa30>
    f38c:	ed8d 7b06 	vstr	d7, [sp, #24]
    f390:	e41d      	b.n	ebce <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x16e>
    f392:	2500      	movs	r5, #0
    f394:	f7ff bbf8 	b.w	eb88 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x128>
    f398:	4622      	mov	r2, r4
    f39a:	462b      	mov	r3, r5
    f39c:	2000      	movs	r0, #0
    f39e:	4947      	ldr	r1, [pc, #284]	; (f4bc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa5c>)
    f3a0:	f7fd fa34 	bl	c80c <__aeabi_ddiv>
    f3a4:	f7ff bb3d 	b.w	ea22 <__ieee754_pow+0x5a>
    f3a8:	4622      	mov	r2, r4
    f3aa:	462b      	mov	r3, r5
    f3ac:	4620      	mov	r0, r4
    f3ae:	4629      	mov	r1, r5
    f3b0:	f7fd f902 	bl	c5b8 <__aeabi_dmul>
    f3b4:	f7ff bb35 	b.w	ea22 <__ieee754_pow+0x5a>
    f3b8:	f1bc 0f00 	cmp.w	ip, #0
    f3bc:	f47f aee1 	bne.w	f182 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x722>
    f3c0:	f1c3 0314 	rsb	r3, r3, #20
    f3c4:	fa48 f203 	asr.w	r2, r8, r3
    f3c8:	fa02 f303 	lsl.w	r3, r2, r3
    f3cc:	4543      	cmp	r3, r8
    f3ce:	d040      	beq.n	f452 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x9f2>
    f3d0:	46e3      	mov	fp, ip
    f3d2:	f7ff bb39 	b.w	ea48 <__ieee754_pow+0x80>
    f3d6:	4a3b      	ldr	r2, [pc, #236]	; (f4c4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa64>)
    f3d8:	4293      	cmp	r3, r2
    f3da:	dc40      	bgt.n	f45e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x9fe>
    f3dc:	e9dd 2300 	ldrd	r2, r3, [sp]
    f3e0:	4693      	mov	fp, r2
    f3e2:	4692      	mov	sl, r2
    f3e4:	e616      	b.n	f014 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x5b4>
    f3e6:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    f3ea:	a32b      	add	r3, pc, #172	; (adr r3, f498 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa38>)
    f3ec:	e9d3 2300 	ldrd	r2, r3, [r3]
    f3f0:	f7fd f8e2 	bl	c5b8 <__aeabi_dmul>
    f3f4:	a328      	add	r3, pc, #160	; (adr r3, f498 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa38>)
    f3f6:	e9d3 2300 	ldrd	r2, r3, [r3]
    f3fa:	f7fd f8dd 	bl	c5b8 <__aeabi_dmul>
    f3fe:	f7ff bb10 	b.w	ea22 <__ieee754_pow+0x5a>
    f402:	ed9f 7b27 	vldr	d7, [pc, #156]	; f4a0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa40>
    f406:	f44f 2580 	mov.w	r5, #262144	; 0x40000
    f40a:	ed8d 7b08 	vstr	d7, [sp, #32]
    f40e:	ed9f 7b26 	vldr	d7, [pc, #152]	; f4a8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa48>
    f412:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
    f416:	ed9f 7b26 	vldr	d7, [pc, #152]	; f4b0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa50>
    f41a:	ed8d 7b06 	vstr	d7, [sp, #24]
    f41e:	f7ff bbd6 	b.w	ebce <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x16e>
    f422:	f1bb 0f01 	cmp.w	fp, #1
    f426:	f47f aafc 	bne.w	ea22 <__ieee754_pow+0x5a>
    f42a:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
    f42e:	4619      	mov	r1, r3
    f430:	f7ff baf7 	b.w	ea22 <__ieee754_pow+0x5a>
    f434:	4650      	mov	r0, sl
    f436:	ec43 2b10 	vmov	d0, r2, r3
    f43a:	f000 f84d 	bl	f4d8 <scalbn>
    f43e:	ec51 0b10 	vmov	r0, r1, d0
    f442:	e699      	b.n	f178 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x718>
    f444:	ec45 4b10 	vmov	d0, r4, r5
    f448:	b013      	add	sp, #76	; 0x4c
    f44a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f44e:	f01a bb07 	b.w	29a60 <__ieee754_sqrt>
    f452:	f002 0201 	and.w	r2, r2, #1
    f456:	f1c2 0b02 	rsb	fp, r2, #2
    f45a:	f7ff baf5 	b.w	ea48 <__ieee754_pow+0x80>
    f45e:	151b      	asrs	r3, r3, #20
    f460:	e5a8      	b.n	efb4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x554>
    f462:	bf00      	nop
    f464:	f3af 8000 	nop.w
    f468:	60000000 	.word	0x60000000
    f46c:	3ff71547 	.word	0x3ff71547
    f470:	f85ddf44 	.word	0xf85ddf44
    f474:	3e54ae0b 	.word	0x3e54ae0b
    f478:	55555555 	.word	0x55555555
    f47c:	3fd55555 	.word	0x3fd55555
    f480:	652b82fe 	.word	0x652b82fe
    f484:	3ff71547 	.word	0x3ff71547
	...
    f494:	3ff00000 	.word	0x3ff00000
    f498:	8800759c 	.word	0x8800759c
    f49c:	7e37e43c 	.word	0x7e37e43c
    f4a0:	40000000 	.word	0x40000000
    f4a4:	3fe2b803 	.word	0x3fe2b803
    f4a8:	43cfd006 	.word	0x43cfd006
    f4ac:	3e4cfdeb 	.word	0x3e4cfdeb
    f4b0:	00000000 	.word	0x00000000
    f4b4:	3ff80000 	.word	0x3ff80000
    f4b8:	3feffffe 	.word	0x3feffffe
    f4bc:	3ff00000 	.word	0x3ff00000
    f4c0:	3fd00000 	.word	0x3fd00000
    f4c4:	3fe00000 	.word	0x3fe00000

0000f4c8 <nan>:
    f4c8:	ed9f 0b01 	vldr	d0, [pc, #4]	; f4d0 <nan+0x8>
    f4cc:	4770      	bx	lr
    f4ce:	bf00      	nop
    f4d0:	00000000 	.word	0x00000000
    f4d4:	7ff80000 	.word	0x7ff80000

0000f4d8 <scalbn>:
    f4d8:	b538      	push	{r3, r4, r5, lr}
    f4da:	ec53 2b10 	vmov	r2, r3, d0
    f4de:	f3c3 510a 	ubfx	r1, r3, #20, #11
    f4e2:	461c      	mov	r4, r3
    f4e4:	4605      	mov	r5, r0
    f4e6:	bb81      	cbnz	r1, f54a <scalbn+0x72>
    f4e8:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
    f4ec:	ee10 1a10 	vmov	r1, s0
    f4f0:	4321      	orrs	r1, r4
    f4f2:	d029      	beq.n	f548 <scalbn+0x70>
    f4f4:	4c3c      	ldr	r4, [pc, #240]	; (f5e8 <scalbn+0x110>)
    f4f6:	4619      	mov	r1, r3
    f4f8:	2200      	movs	r2, #0
    f4fa:	4b3c      	ldr	r3, [pc, #240]	; (f5ec <scalbn+0x114>)
    f4fc:	ee10 0a10 	vmov	r0, s0
    f500:	f7fd f85a 	bl	c5b8 <__aeabi_dmul>
    f504:	42a5      	cmp	r5, r4
    f506:	4602      	mov	r2, r0
    f508:	460b      	mov	r3, r1
    f50a:	db16      	blt.n	f53a <scalbn+0x62>
    f50c:	460c      	mov	r4, r1
    f50e:	f3c1 510a 	ubfx	r1, r1, #20, #11
    f512:	3936      	subs	r1, #54	; 0x36
    f514:	4429      	add	r1, r5
    f516:	f240 70fe 	movw	r0, #2046	; 0x7fe
    f51a:	4281      	cmp	r1, r0
    f51c:	dc21      	bgt.n	f562 <scalbn+0x8a>
    f51e:	2900      	cmp	r1, #0
    f520:	dc45      	bgt.n	f5ae <scalbn+0xd6>
    f522:	f111 0f35 	cmn.w	r1, #53	; 0x35
    f526:	da34      	bge.n	f592 <scalbn+0xba>
    f528:	f24c 3150 	movw	r1, #50000	; 0xc350
    f52c:	428d      	cmp	r5, r1
    f52e:	dc18      	bgt.n	f562 <scalbn+0x8a>
    f530:	2b00      	cmp	r3, #0
    f532:	a125      	add	r1, pc, #148	; (adr r1, f5c8 <scalbn+0xf0>)
    f534:	e9d1 0100 	ldrd	r0, r1, [r1]
    f538:	db40      	blt.n	f5bc <scalbn+0xe4>
    f53a:	a323      	add	r3, pc, #140	; (adr r3, f5c8 <scalbn+0xf0>)
    f53c:	e9d3 2300 	ldrd	r2, r3, [r3]
    f540:	f7fd f83a 	bl	c5b8 <__aeabi_dmul>
    f544:	ec41 0b10 	vmov	d0, r0, r1
    f548:	bd38      	pop	{r3, r4, r5, pc}
    f54a:	f240 70ff 	movw	r0, #2047	; 0x7ff
    f54e:	4281      	cmp	r1, r0
    f550:	d1e0      	bne.n	f514 <scalbn+0x3c>
    f552:	ee10 0a10 	vmov	r0, s0
    f556:	4619      	mov	r1, r3
    f558:	f7fc fe78 	bl	c24c <__adddf3>
    f55c:	ec41 0b10 	vmov	d0, r0, r1
    f560:	bd38      	pop	{r3, r4, r5, pc}
    f562:	2b00      	cmp	r3, #0
    f564:	a11a      	add	r1, pc, #104	; (adr r1, f5d0 <scalbn+0xf8>)
    f566:	e9d1 0100 	ldrd	r0, r1, [r1]
    f56a:	db07      	blt.n	f57c <scalbn+0xa4>
    f56c:	a318      	add	r3, pc, #96	; (adr r3, f5d0 <scalbn+0xf8>)
    f56e:	e9d3 2300 	ldrd	r2, r3, [r3]
    f572:	f7fd f821 	bl	c5b8 <__aeabi_dmul>
    f576:	ec41 0b10 	vmov	d0, r0, r1
    f57a:	bd38      	pop	{r3, r4, r5, pc}
    f57c:	a116      	add	r1, pc, #88	; (adr r1, f5d8 <scalbn+0x100>)
    f57e:	e9d1 0100 	ldrd	r0, r1, [r1]
    f582:	a313      	add	r3, pc, #76	; (adr r3, f5d0 <scalbn+0xf8>)
    f584:	e9d3 2300 	ldrd	r2, r3, [r3]
    f588:	f7fd f816 	bl	c5b8 <__aeabi_dmul>
    f58c:	ec41 0b10 	vmov	d0, r0, r1
    f590:	e7f3      	b.n	f57a <scalbn+0xa2>
    f592:	4817      	ldr	r0, [pc, #92]	; (f5f0 <scalbn+0x118>)
    f594:	3136      	adds	r1, #54	; 0x36
    f596:	4020      	ands	r0, r4
    f598:	ea40 5301 	orr.w	r3, r0, r1, lsl #20
    f59c:	4610      	mov	r0, r2
    f59e:	2200      	movs	r2, #0
    f5a0:	4619      	mov	r1, r3
    f5a2:	4b14      	ldr	r3, [pc, #80]	; (f5f4 <scalbn+0x11c>)
    f5a4:	f7fd f808 	bl	c5b8 <__aeabi_dmul>
    f5a8:	ec41 0b10 	vmov	d0, r0, r1
    f5ac:	bd38      	pop	{r3, r4, r5, pc}
    f5ae:	4810      	ldr	r0, [pc, #64]	; (f5f0 <scalbn+0x118>)
    f5b0:	4020      	ands	r0, r4
    f5b2:	ea40 5301 	orr.w	r3, r0, r1, lsl #20
    f5b6:	ec43 2b10 	vmov	d0, r2, r3
    f5ba:	bd38      	pop	{r3, r4, r5, pc}
    f5bc:	a108      	add	r1, pc, #32	; (adr r1, f5e0 <scalbn+0x108>)
    f5be:	e9d1 0100 	ldrd	r0, r1, [r1]
    f5c2:	e7ba      	b.n	f53a <scalbn+0x62>
    f5c4:	f3af 8000 	nop.w
    f5c8:	c2f8f359 	.word	0xc2f8f359
    f5cc:	01a56e1f 	.word	0x01a56e1f
    f5d0:	8800759c 	.word	0x8800759c
    f5d4:	7e37e43c 	.word	0x7e37e43c
    f5d8:	8800759c 	.word	0x8800759c
    f5dc:	fe37e43c 	.word	0xfe37e43c
    f5e0:	c2f8f359 	.word	0xc2f8f359
    f5e4:	81a56e1f 	.word	0x81a56e1f
    f5e8:	ffff3cb0 	.word	0xffff3cb0
    f5ec:	43500000 	.word	0x43500000
    f5f0:	800fffff 	.word	0x800fffff
    f5f4:	3c900000 	.word	0x3c900000

0000f5f8 <_dtoa_r>:
    f5f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f5fc:	6a47      	ldr	r7, [r0, #36]	; 0x24
    f5fe:	b099      	sub	sp, #100	; 0x64
    f600:	4683      	mov	fp, r0
    f602:	9108      	str	r1, [sp, #32]
    f604:	920d      	str	r2, [sp, #52]	; 0x34
    f606:	9314      	str	r3, [sp, #80]	; 0x50
    f608:	9e22      	ldr	r6, [sp, #136]	; 0x88
    f60a:	ec55 4b10 	vmov	r4, r5, d0
    f60e:	e9cd 4500 	strd	r4, r5, [sp]
    f612:	b947      	cbnz	r7, f626 <_dtoa_r+0x2e>
    f614:	2010      	movs	r0, #16
    f616:	f01b fc4f 	bl	2aeb8 <malloc>
    f61a:	f8cb 0024 	str.w	r0, [fp, #36]	; 0x24
    f61e:	6007      	str	r7, [r0, #0]
    f620:	60c7      	str	r7, [r0, #12]
    f622:	e9c0 7701 	strd	r7, r7, [r0, #4]
    f626:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
    f62a:	6819      	ldr	r1, [r3, #0]
    f62c:	b159      	cbz	r1, f646 <_dtoa_r+0x4e>
    f62e:	685a      	ldr	r2, [r3, #4]
    f630:	2301      	movs	r3, #1
    f632:	4658      	mov	r0, fp
    f634:	4093      	lsls	r3, r2
    f636:	604a      	str	r2, [r1, #4]
    f638:	608b      	str	r3, [r1, #8]
    f63a:	f020 f9da 	bl	2f9f2 <_Bfree>
    f63e:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
    f642:	2200      	movs	r2, #0
    f644:	601a      	str	r2, [r3, #0]
    f646:	1e2b      	subs	r3, r5, #0
    f648:	bfb7      	itett	lt
    f64a:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
    f64e:	2300      	movge	r3, #0
    f650:	2201      	movlt	r2, #1
    f652:	9301      	strlt	r3, [sp, #4]
    f654:	bfa8      	it	ge
    f656:	6033      	strge	r3, [r6, #0]
    f658:	9c01      	ldr	r4, [sp, #4]
    f65a:	4bb1      	ldr	r3, [pc, #708]	; (f920 <_dtoa_r+0x328>)
    f65c:	bfb8      	it	lt
    f65e:	6032      	strlt	r2, [r6, #0]
    f660:	43a3      	bics	r3, r4
    f662:	d11a      	bne.n	f69a <_dtoa_r+0xa2>
    f664:	f242 730f 	movw	r3, #9999	; 0x270f
    f668:	9a14      	ldr	r2, [sp, #80]	; 0x50
    f66a:	6013      	str	r3, [r2, #0]
    f66c:	f3c4 0313 	ubfx	r3, r4, #0, #20
    f670:	9a00      	ldr	r2, [sp, #0]
    f672:	4313      	orrs	r3, r2
    f674:	f000 8547 	beq.w	10106 <_dtoa_r+0xb0e>
    f678:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    f67a:	b953      	cbnz	r3, f692 <_dtoa_r+0x9a>
    f67c:	4ba9      	ldr	r3, [pc, #676]	; (f924 <_dtoa_r+0x32c>)
    f67e:	e023      	b.n	f6c8 <_dtoa_r+0xd0>
    f680:	4ba9      	ldr	r3, [pc, #676]	; (f928 <_dtoa_r+0x330>)
    f682:	9303      	str	r3, [sp, #12]
    f684:	3308      	adds	r3, #8
    f686:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    f688:	6013      	str	r3, [r2, #0]
    f68a:	9803      	ldr	r0, [sp, #12]
    f68c:	b019      	add	sp, #100	; 0x64
    f68e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f692:	4ba4      	ldr	r3, [pc, #656]	; (f924 <_dtoa_r+0x32c>)
    f694:	9303      	str	r3, [sp, #12]
    f696:	3303      	adds	r3, #3
    f698:	e7f5      	b.n	f686 <_dtoa_r+0x8e>
    f69a:	ed9d 7b00 	vldr	d7, [sp]
    f69e:	2200      	movs	r2, #0
    f6a0:	2300      	movs	r3, #0
    f6a2:	ec51 0b17 	vmov	r0, r1, d7
    f6a6:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    f6aa:	f7fd f9ed 	bl	ca88 <__aeabi_dcmpeq>
    f6ae:	4607      	mov	r7, r0
    f6b0:	b160      	cbz	r0, f6cc <_dtoa_r+0xd4>
    f6b2:	2301      	movs	r3, #1
    f6b4:	9a14      	ldr	r2, [sp, #80]	; 0x50
    f6b6:	6013      	str	r3, [r2, #0]
    f6b8:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    f6ba:	2b00      	cmp	r3, #0
    f6bc:	f000 8520 	beq.w	10100 <_dtoa_r+0xb08>
    f6c0:	4b9a      	ldr	r3, [pc, #616]	; (f92c <_dtoa_r+0x334>)
    f6c2:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    f6c4:	6013      	str	r3, [r2, #0]
    f6c6:	3b01      	subs	r3, #1
    f6c8:	9303      	str	r3, [sp, #12]
    f6ca:	e7de      	b.n	f68a <_dtoa_r+0x92>
    f6cc:	f3c4 560a 	ubfx	r6, r4, #20, #11
    f6d0:	aa16      	add	r2, sp, #88	; 0x58
    f6d2:	a917      	add	r1, sp, #92	; 0x5c
    f6d4:	4658      	mov	r0, fp
    f6d6:	ed9d 0b0e 	vldr	d0, [sp, #56]	; 0x38
    f6da:	f020 fb93 	bl	2fe04 <__d2b>
    f6de:	4680      	mov	r8, r0
    f6e0:	2e00      	cmp	r6, #0
    f6e2:	d07d      	beq.n	f7e0 <_dtoa_r+0x1e8>
    f6e4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    f6e6:	f2a6 36ff 	subw	r6, r6, #1023	; 0x3ff
    f6ea:	9715      	str	r7, [sp, #84]	; 0x54
    f6ec:	f3c3 0313 	ubfx	r3, r3, #0, #20
    f6f0:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
    f6f4:	f043 557f 	orr.w	r5, r3, #1069547520	; 0x3fc00000
    f6f8:	f445 1540 	orr.w	r5, r5, #3145728	; 0x300000
    f6fc:	2200      	movs	r2, #0
    f6fe:	4b8c      	ldr	r3, [pc, #560]	; (f930 <_dtoa_r+0x338>)
    f700:	4620      	mov	r0, r4
    f702:	4629      	mov	r1, r5
    f704:	f7fc fda0 	bl	c248 <__aeabi_dsub>
    f708:	a37f      	add	r3, pc, #508	; (adr r3, f908 <_dtoa_r+0x310>)
    f70a:	e9d3 2300 	ldrd	r2, r3, [r3]
    f70e:	f7fc ff53 	bl	c5b8 <__aeabi_dmul>
    f712:	a37f      	add	r3, pc, #508	; (adr r3, f910 <_dtoa_r+0x318>)
    f714:	e9d3 2300 	ldrd	r2, r3, [r3]
    f718:	f7fc fd98 	bl	c24c <__adddf3>
    f71c:	4604      	mov	r4, r0
    f71e:	460d      	mov	r5, r1
    f720:	4630      	mov	r0, r6
    f722:	f7fc fedf 	bl	c4e4 <__aeabi_i2d>
    f726:	a37c      	add	r3, pc, #496	; (adr r3, f918 <_dtoa_r+0x320>)
    f728:	e9d3 2300 	ldrd	r2, r3, [r3]
    f72c:	f7fc ff44 	bl	c5b8 <__aeabi_dmul>
    f730:	4602      	mov	r2, r0
    f732:	460b      	mov	r3, r1
    f734:	4620      	mov	r0, r4
    f736:	4629      	mov	r1, r5
    f738:	f7fc fd88 	bl	c24c <__adddf3>
    f73c:	4604      	mov	r4, r0
    f73e:	460d      	mov	r5, r1
    f740:	f7fd fbd8 	bl	cef4 <__aeabi_d2iz>
    f744:	2200      	movs	r2, #0
    f746:	4682      	mov	sl, r0
    f748:	2300      	movs	r3, #0
    f74a:	4620      	mov	r0, r4
    f74c:	4629      	mov	r1, r5
    f74e:	f7fd f9a5 	bl	ca9c <__aeabi_dcmplt>
    f752:	b148      	cbz	r0, f768 <_dtoa_r+0x170>
    f754:	4650      	mov	r0, sl
    f756:	f7fc fec5 	bl	c4e4 <__aeabi_i2d>
    f75a:	4622      	mov	r2, r4
    f75c:	462b      	mov	r3, r5
    f75e:	f7fd f993 	bl	ca88 <__aeabi_dcmpeq>
    f762:	b908      	cbnz	r0, f768 <_dtoa_r+0x170>
    f764:	f10a 3aff 	add.w	sl, sl, #4294967295
    f768:	f1ba 0f16 	cmp.w	sl, #22
    f76c:	d857      	bhi.n	f81e <_dtoa_r+0x226>
    f76e:	4b71      	ldr	r3, [pc, #452]	; (f934 <_dtoa_r+0x33c>)
    f770:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
    f774:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
    f778:	e9d3 2300 	ldrd	r2, r3, [r3]
    f77c:	f7fd f98e 	bl	ca9c <__aeabi_dcmplt>
    f780:	2800      	cmp	r0, #0
    f782:	d04e      	beq.n	f822 <_dtoa_r+0x22a>
    f784:	f10a 3aff 	add.w	sl, sl, #4294967295
    f788:	2300      	movs	r3, #0
    f78a:	9311      	str	r3, [sp, #68]	; 0x44
    f78c:	9b16      	ldr	r3, [sp, #88]	; 0x58
    f78e:	1b9e      	subs	r6, r3, r6
    f790:	1e73      	subs	r3, r6, #1
    f792:	9307      	str	r3, [sp, #28]
    f794:	bf49      	itett	mi
    f796:	f1c6 0301 	rsbmi	r3, r6, #1
    f79a:	2300      	movpl	r3, #0
    f79c:	9306      	strmi	r3, [sp, #24]
    f79e:	2300      	movmi	r3, #0
    f7a0:	bf54      	ite	pl
    f7a2:	9306      	strpl	r3, [sp, #24]
    f7a4:	9307      	strmi	r3, [sp, #28]
    f7a6:	f1ba 0f00 	cmp.w	sl, #0
    f7aa:	db3c      	blt.n	f826 <_dtoa_r+0x22e>
    f7ac:	9b07      	ldr	r3, [sp, #28]
    f7ae:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
    f7b2:	4453      	add	r3, sl
    f7b4:	9307      	str	r3, [sp, #28]
    f7b6:	2300      	movs	r3, #0
    f7b8:	9309      	str	r3, [sp, #36]	; 0x24
    f7ba:	9b08      	ldr	r3, [sp, #32]
    f7bc:	2b09      	cmp	r3, #9
    f7be:	f200 808d 	bhi.w	f8dc <_dtoa_r+0x2e4>
    f7c2:	2b05      	cmp	r3, #5
    f7c4:	bfc5      	ittet	gt
    f7c6:	3b04      	subgt	r3, #4
    f7c8:	2400      	movgt	r4, #0
    f7ca:	2401      	movle	r4, #1
    f7cc:	9308      	strgt	r3, [sp, #32]
    f7ce:	9b08      	ldr	r3, [sp, #32]
    f7d0:	3b02      	subs	r3, #2
    f7d2:	2b03      	cmp	r3, #3
    f7d4:	f200 808d 	bhi.w	f8f2 <_dtoa_r+0x2fa>
    f7d8:	e8df f003 	tbb	[pc, r3]
    f7dc:	7e3a3c2f 	.word	0x7e3a3c2f
    f7e0:	e9dd 6316 	ldrd	r6, r3, [sp, #88]	; 0x58
    f7e4:	441e      	add	r6, r3
    f7e6:	f206 4032 	addw	r0, r6, #1074	; 0x432
    f7ea:	2820      	cmp	r0, #32
    f7ec:	dd11      	ble.n	f812 <_dtoa_r+0x21a>
    f7ee:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
    f7f2:	9b00      	ldr	r3, [sp, #0]
    f7f4:	4084      	lsls	r4, r0
    f7f6:	f206 4012 	addw	r0, r6, #1042	; 0x412
    f7fa:	fa23 f000 	lsr.w	r0, r3, r0
    f7fe:	4320      	orrs	r0, r4
    f800:	f7fc fe60 	bl	c4c4 <__aeabi_ui2d>
    f804:	2301      	movs	r3, #1
    f806:	4604      	mov	r4, r0
    f808:	f1a1 75f8 	sub.w	r5, r1, #32505856	; 0x1f00000
    f80c:	3e01      	subs	r6, #1
    f80e:	9315      	str	r3, [sp, #84]	; 0x54
    f810:	e774      	b.n	f6fc <_dtoa_r+0x104>
    f812:	f1c0 0020 	rsb	r0, r0, #32
    f816:	9b00      	ldr	r3, [sp, #0]
    f818:	fa03 f000 	lsl.w	r0, r3, r0
    f81c:	e7f0      	b.n	f800 <_dtoa_r+0x208>
    f81e:	2301      	movs	r3, #1
    f820:	e7b3      	b.n	f78a <_dtoa_r+0x192>
    f822:	9011      	str	r0, [sp, #68]	; 0x44
    f824:	e7b2      	b.n	f78c <_dtoa_r+0x194>
    f826:	9b06      	ldr	r3, [sp, #24]
    f828:	eba3 030a 	sub.w	r3, r3, sl
    f82c:	9306      	str	r3, [sp, #24]
    f82e:	f1ca 0300 	rsb	r3, sl, #0
    f832:	9309      	str	r3, [sp, #36]	; 0x24
    f834:	2300      	movs	r3, #0
    f836:	9310      	str	r3, [sp, #64]	; 0x40
    f838:	e7bf      	b.n	f7ba <_dtoa_r+0x1c2>
    f83a:	2300      	movs	r3, #0
    f83c:	930c      	str	r3, [sp, #48]	; 0x30
    f83e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    f840:	2b00      	cmp	r3, #0
    f842:	dc59      	bgt.n	f8f8 <_dtoa_r+0x300>
    f844:	2301      	movs	r3, #1
    f846:	4699      	mov	r9, r3
    f848:	461a      	mov	r2, r3
    f84a:	9304      	str	r3, [sp, #16]
    f84c:	920d      	str	r2, [sp, #52]	; 0x34
    f84e:	e00c      	b.n	f86a <_dtoa_r+0x272>
    f850:	2301      	movs	r3, #1
    f852:	e7f3      	b.n	f83c <_dtoa_r+0x244>
    f854:	2300      	movs	r3, #0
    f856:	930c      	str	r3, [sp, #48]	; 0x30
    f858:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    f85a:	4453      	add	r3, sl
    f85c:	f103 0901 	add.w	r9, r3, #1
    f860:	9304      	str	r3, [sp, #16]
    f862:	464b      	mov	r3, r9
    f864:	2b01      	cmp	r3, #1
    f866:	bfb8      	it	lt
    f868:	2301      	movlt	r3, #1
    f86a:	2200      	movs	r2, #0
    f86c:	f8db 5024 	ldr.w	r5, [fp, #36]	; 0x24
    f870:	606a      	str	r2, [r5, #4]
    f872:	2204      	movs	r2, #4
    f874:	f102 0014 	add.w	r0, r2, #20
    f878:	6869      	ldr	r1, [r5, #4]
    f87a:	4298      	cmp	r0, r3
    f87c:	d940      	bls.n	f900 <_dtoa_r+0x308>
    f87e:	4658      	mov	r0, fp
    f880:	f020 f883 	bl	2f98a <_Balloc>
    f884:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
    f888:	6028      	str	r0, [r5, #0]
    f88a:	f1b9 0f0e 	cmp.w	r9, #14
    f88e:	681b      	ldr	r3, [r3, #0]
    f890:	9303      	str	r3, [sp, #12]
    f892:	f200 80d4 	bhi.w	fa3e <_dtoa_r+0x446>
    f896:	2c00      	cmp	r4, #0
    f898:	f000 80d1 	beq.w	fa3e <_dtoa_r+0x446>
    f89c:	f1ba 0f00 	cmp.w	sl, #0
    f8a0:	dd66      	ble.n	f970 <_dtoa_r+0x378>
    f8a2:	4a24      	ldr	r2, [pc, #144]	; (f934 <_dtoa_r+0x33c>)
    f8a4:	f00a 030f 	and.w	r3, sl, #15
    f8a8:	ea4f 142a 	mov.w	r4, sl, asr #4
    f8ac:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    f8b0:	06e2      	lsls	r2, r4, #27
    f8b2:	ed93 7b00 	vldr	d7, [r3]
    f8b6:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
    f8ba:	d557      	bpl.n	f96c <_dtoa_r+0x374>
    f8bc:	4b1e      	ldr	r3, [pc, #120]	; (f938 <_dtoa_r+0x340>)
    f8be:	f004 040f 	and.w	r4, r4, #15
    f8c2:	2603      	movs	r6, #3
    f8c4:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
    f8c8:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
    f8cc:	f7fc ff9e 	bl	c80c <__aeabi_ddiv>
    f8d0:	e9cd 0100 	strd	r0, r1, [sp]
    f8d4:	4d18      	ldr	r5, [pc, #96]	; (f938 <_dtoa_r+0x340>)
    f8d6:	e03e      	b.n	f956 <_dtoa_r+0x35e>
    f8d8:	2301      	movs	r3, #1
    f8da:	e7bc      	b.n	f856 <_dtoa_r+0x25e>
    f8dc:	2401      	movs	r4, #1
    f8de:	2300      	movs	r3, #0
    f8e0:	940c      	str	r4, [sp, #48]	; 0x30
    f8e2:	9308      	str	r3, [sp, #32]
    f8e4:	f04f 33ff 	mov.w	r3, #4294967295
    f8e8:	2200      	movs	r2, #0
    f8ea:	9304      	str	r3, [sp, #16]
    f8ec:	4699      	mov	r9, r3
    f8ee:	2312      	movs	r3, #18
    f8f0:	e7ac      	b.n	f84c <_dtoa_r+0x254>
    f8f2:	2301      	movs	r3, #1
    f8f4:	930c      	str	r3, [sp, #48]	; 0x30
    f8f6:	e7f5      	b.n	f8e4 <_dtoa_r+0x2ec>
    f8f8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    f8fa:	9304      	str	r3, [sp, #16]
    f8fc:	4699      	mov	r9, r3
    f8fe:	e7b4      	b.n	f86a <_dtoa_r+0x272>
    f900:	3101      	adds	r1, #1
    f902:	0052      	lsls	r2, r2, #1
    f904:	6069      	str	r1, [r5, #4]
    f906:	e7b5      	b.n	f874 <_dtoa_r+0x27c>
    f908:	636f4361 	.word	0x636f4361
    f90c:	3fd287a7 	.word	0x3fd287a7
    f910:	8b60c8b3 	.word	0x8b60c8b3
    f914:	3fc68a28 	.word	0x3fc68a28
    f918:	509f79fb 	.word	0x509f79fb
    f91c:	3fd34413 	.word	0x3fd34413
    f920:	7ff00000 	.word	0x7ff00000
    f924:	00034f8c 	.word	0x00034f8c
    f928:	00034f83 	.word	0x00034f83
    f92c:	0003495b 	.word	0x0003495b
    f930:	3ff80000 	.word	0x3ff80000
    f934:	00030770 	.word	0x00030770
    f938:	00030748 	.word	0x00030748
    f93c:	07e3      	lsls	r3, r4, #31
    f93e:	d508      	bpl.n	f952 <_dtoa_r+0x35a>
    f940:	3601      	adds	r6, #1
    f942:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    f946:	e9d5 2300 	ldrd	r2, r3, [r5]
    f94a:	f7fc fe35 	bl	c5b8 <__aeabi_dmul>
    f94e:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
    f952:	1064      	asrs	r4, r4, #1
    f954:	3508      	adds	r5, #8
    f956:	2c00      	cmp	r4, #0
    f958:	d1f0      	bne.n	f93c <_dtoa_r+0x344>
    f95a:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
    f95e:	e9dd 0100 	ldrd	r0, r1, [sp]
    f962:	f7fc ff53 	bl	c80c <__aeabi_ddiv>
    f966:	e9cd 0100 	strd	r0, r1, [sp]
    f96a:	e01a      	b.n	f9a2 <_dtoa_r+0x3aa>
    f96c:	2602      	movs	r6, #2
    f96e:	e7b1      	b.n	f8d4 <_dtoa_r+0x2dc>
    f970:	f000 809f 	beq.w	fab2 <_dtoa_r+0x4ba>
    f974:	f1ca 0400 	rsb	r4, sl, #0
    f978:	4b9e      	ldr	r3, [pc, #632]	; (fbf4 <_dtoa_r+0x5fc>)
    f97a:	4d9f      	ldr	r5, [pc, #636]	; (fbf8 <_dtoa_r+0x600>)
    f97c:	2602      	movs	r6, #2
    f97e:	f004 020f 	and.w	r2, r4, #15
    f982:	1124      	asrs	r4, r4, #4
    f984:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    f988:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
    f98c:	e9d3 2300 	ldrd	r2, r3, [r3]
    f990:	f7fc fe12 	bl	c5b8 <__aeabi_dmul>
    f994:	2300      	movs	r3, #0
    f996:	e9cd 0100 	strd	r0, r1, [sp]
    f99a:	2c00      	cmp	r4, #0
    f99c:	d17e      	bne.n	fa9c <_dtoa_r+0x4a4>
    f99e:	2b00      	cmp	r3, #0
    f9a0:	d1e1      	bne.n	f966 <_dtoa_r+0x36e>
    f9a2:	9b11      	ldr	r3, [sp, #68]	; 0x44
    f9a4:	2b00      	cmp	r3, #0
    f9a6:	f000 8086 	beq.w	fab6 <_dtoa_r+0x4be>
    f9aa:	2200      	movs	r2, #0
    f9ac:	4b93      	ldr	r3, [pc, #588]	; (fbfc <_dtoa_r+0x604>)
    f9ae:	e9dd 4500 	ldrd	r4, r5, [sp]
    f9b2:	4620      	mov	r0, r4
    f9b4:	4629      	mov	r1, r5
    f9b6:	f7fd f871 	bl	ca9c <__aeabi_dcmplt>
    f9ba:	2800      	cmp	r0, #0
    f9bc:	d07b      	beq.n	fab6 <_dtoa_r+0x4be>
    f9be:	f1b9 0f00 	cmp.w	r9, #0
    f9c2:	d078      	beq.n	fab6 <_dtoa_r+0x4be>
    f9c4:	9b04      	ldr	r3, [sp, #16]
    f9c6:	2b00      	cmp	r3, #0
    f9c8:	dd35      	ble.n	fa36 <_dtoa_r+0x43e>
    f9ca:	f10a 33ff 	add.w	r3, sl, #4294967295
    f9ce:	4620      	mov	r0, r4
    f9d0:	2200      	movs	r2, #0
    f9d2:	4629      	mov	r1, r5
    f9d4:	930a      	str	r3, [sp, #40]	; 0x28
    f9d6:	3601      	adds	r6, #1
    f9d8:	4b89      	ldr	r3, [pc, #548]	; (fc00 <_dtoa_r+0x608>)
    f9da:	f7fc fded 	bl	c5b8 <__aeabi_dmul>
    f9de:	9c04      	ldr	r4, [sp, #16]
    f9e0:	e9cd 0100 	strd	r0, r1, [sp]
    f9e4:	4630      	mov	r0, r6
    f9e6:	f7fc fd7d 	bl	c4e4 <__aeabi_i2d>
    f9ea:	e9dd 2300 	ldrd	r2, r3, [sp]
    f9ee:	f7fc fde3 	bl	c5b8 <__aeabi_dmul>
    f9f2:	2200      	movs	r2, #0
    f9f4:	4b83      	ldr	r3, [pc, #524]	; (fc04 <_dtoa_r+0x60c>)
    f9f6:	f7fc fc29 	bl	c24c <__adddf3>
    f9fa:	4606      	mov	r6, r0
    f9fc:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
    fa00:	2c00      	cmp	r4, #0
    fa02:	d15c      	bne.n	fabe <_dtoa_r+0x4c6>
    fa04:	2200      	movs	r2, #0
    fa06:	4b80      	ldr	r3, [pc, #512]	; (fc08 <_dtoa_r+0x610>)
    fa08:	e9dd 0100 	ldrd	r0, r1, [sp]
    fa0c:	f7fc fc1c 	bl	c248 <__aeabi_dsub>
    fa10:	4632      	mov	r2, r6
    fa12:	463b      	mov	r3, r7
    fa14:	e9cd 0100 	strd	r0, r1, [sp]
    fa18:	f7fd f85e 	bl	cad8 <__aeabi_dcmpgt>
    fa1c:	2800      	cmp	r0, #0
    fa1e:	f040 8289 	bne.w	ff34 <_dtoa_r+0x93c>
    fa22:	4632      	mov	r2, r6
    fa24:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
    fa28:	e9dd 0100 	ldrd	r0, r1, [sp]
    fa2c:	f7fd f836 	bl	ca9c <__aeabi_dcmplt>
    fa30:	2800      	cmp	r0, #0
    fa32:	f040 827d 	bne.w	ff30 <_dtoa_r+0x938>
    fa36:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
    fa3a:	e9cd 3400 	strd	r3, r4, [sp]
    fa3e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    fa40:	2b00      	cmp	r3, #0
    fa42:	f2c0 814c 	blt.w	fcde <_dtoa_r+0x6e6>
    fa46:	f1ba 0f0e 	cmp.w	sl, #14
    fa4a:	f300 8148 	bgt.w	fcde <_dtoa_r+0x6e6>
    fa4e:	4b69      	ldr	r3, [pc, #420]	; (fbf4 <_dtoa_r+0x5fc>)
    fa50:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
    fa54:	ed93 7b00 	vldr	d7, [r3]
    fa58:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    fa5a:	2b00      	cmp	r3, #0
    fa5c:	ed8d 7b04 	vstr	d7, [sp, #16]
    fa60:	f280 80d6 	bge.w	fc10 <_dtoa_r+0x618>
    fa64:	f1b9 0f00 	cmp.w	r9, #0
    fa68:	f300 80d2 	bgt.w	fc10 <_dtoa_r+0x618>
    fa6c:	f040 825f 	bne.w	ff2e <_dtoa_r+0x936>
    fa70:	2200      	movs	r2, #0
    fa72:	4b65      	ldr	r3, [pc, #404]	; (fc08 <_dtoa_r+0x610>)
    fa74:	464c      	mov	r4, r9
    fa76:	464e      	mov	r6, r9
    fa78:	ec51 0b17 	vmov	r0, r1, d7
    fa7c:	f7fc fd9c 	bl	c5b8 <__aeabi_dmul>
    fa80:	e9dd 2300 	ldrd	r2, r3, [sp]
    fa84:	f7fd f81e 	bl	cac4 <__aeabi_dcmpge>
    fa88:	2800      	cmp	r0, #0
    fa8a:	f040 8238 	bne.w	fefe <_dtoa_r+0x906>
    fa8e:	9d03      	ldr	r5, [sp, #12]
    fa90:	2331      	movs	r3, #49	; 0x31
    fa92:	f10a 0a01 	add.w	sl, sl, #1
    fa96:	f805 3b01 	strb.w	r3, [r5], #1
    fa9a:	e234      	b.n	ff06 <_dtoa_r+0x90e>
    fa9c:	07e7      	lsls	r7, r4, #31
    fa9e:	d505      	bpl.n	faac <_dtoa_r+0x4b4>
    faa0:	3601      	adds	r6, #1
    faa2:	e9d5 2300 	ldrd	r2, r3, [r5]
    faa6:	f7fc fd87 	bl	c5b8 <__aeabi_dmul>
    faaa:	2301      	movs	r3, #1
    faac:	1064      	asrs	r4, r4, #1
    faae:	3508      	adds	r5, #8
    fab0:	e773      	b.n	f99a <_dtoa_r+0x3a2>
    fab2:	2602      	movs	r6, #2
    fab4:	e775      	b.n	f9a2 <_dtoa_r+0x3aa>
    fab6:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
    faba:	464c      	mov	r4, r9
    fabc:	e792      	b.n	f9e4 <_dtoa_r+0x3ec>
    fabe:	4b4d      	ldr	r3, [pc, #308]	; (fbf4 <_dtoa_r+0x5fc>)
    fac0:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
    fac4:	e953 0102 	ldrd	r0, r1, [r3, #-8]
    fac8:	9b03      	ldr	r3, [sp, #12]
    faca:	441c      	add	r4, r3
    facc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    face:	2b00      	cmp	r3, #0
    fad0:	d046      	beq.n	fb60 <_dtoa_r+0x568>
    fad2:	4602      	mov	r2, r0
    fad4:	460b      	mov	r3, r1
    fad6:	2000      	movs	r0, #0
    fad8:	494c      	ldr	r1, [pc, #304]	; (fc0c <_dtoa_r+0x614>)
    fada:	f7fc fe97 	bl	c80c <__aeabi_ddiv>
    fade:	4632      	mov	r2, r6
    fae0:	463b      	mov	r3, r7
    fae2:	f7fc fbb1 	bl	c248 <__aeabi_dsub>
    fae6:	9d03      	ldr	r5, [sp, #12]
    fae8:	4606      	mov	r6, r0
    faea:	460f      	mov	r7, r1
    faec:	e9dd 0100 	ldrd	r0, r1, [sp]
    faf0:	f7fd fa00 	bl	cef4 <__aeabi_d2iz>
    faf4:	9012      	str	r0, [sp, #72]	; 0x48
    faf6:	f7fc fcf5 	bl	c4e4 <__aeabi_i2d>
    fafa:	4602      	mov	r2, r0
    fafc:	460b      	mov	r3, r1
    fafe:	e9dd 0100 	ldrd	r0, r1, [sp]
    fb02:	f7fc fba1 	bl	c248 <__aeabi_dsub>
    fb06:	9b12      	ldr	r3, [sp, #72]	; 0x48
    fb08:	4632      	mov	r2, r6
    fb0a:	3330      	adds	r3, #48	; 0x30
    fb0c:	f805 3b01 	strb.w	r3, [r5], #1
    fb10:	463b      	mov	r3, r7
    fb12:	e9cd 0100 	strd	r0, r1, [sp]
    fb16:	f7fc ffc1 	bl	ca9c <__aeabi_dcmplt>
    fb1a:	2800      	cmp	r0, #0
    fb1c:	d15f      	bne.n	fbde <_dtoa_r+0x5e6>
    fb1e:	2000      	movs	r0, #0
    fb20:	4936      	ldr	r1, [pc, #216]	; (fbfc <_dtoa_r+0x604>)
    fb22:	e9dd 2300 	ldrd	r2, r3, [sp]
    fb26:	f7fc fb8f 	bl	c248 <__aeabi_dsub>
    fb2a:	4632      	mov	r2, r6
    fb2c:	463b      	mov	r3, r7
    fb2e:	f7fc ffb5 	bl	ca9c <__aeabi_dcmplt>
    fb32:	2800      	cmp	r0, #0
    fb34:	f040 80b2 	bne.w	fc9c <_dtoa_r+0x6a4>
    fb38:	42a5      	cmp	r5, r4
    fb3a:	f43f af7c 	beq.w	fa36 <_dtoa_r+0x43e>
    fb3e:	2200      	movs	r2, #0
    fb40:	4b2f      	ldr	r3, [pc, #188]	; (fc00 <_dtoa_r+0x608>)
    fb42:	4630      	mov	r0, r6
    fb44:	4639      	mov	r1, r7
    fb46:	f7fc fd37 	bl	c5b8 <__aeabi_dmul>
    fb4a:	2200      	movs	r2, #0
    fb4c:	4606      	mov	r6, r0
    fb4e:	460f      	mov	r7, r1
    fb50:	4b2b      	ldr	r3, [pc, #172]	; (fc00 <_dtoa_r+0x608>)
    fb52:	e9dd 0100 	ldrd	r0, r1, [sp]
    fb56:	f7fc fd2f 	bl	c5b8 <__aeabi_dmul>
    fb5a:	e9cd 0100 	strd	r0, r1, [sp]
    fb5e:	e7c5      	b.n	faec <_dtoa_r+0x4f4>
    fb60:	4632      	mov	r2, r6
    fb62:	463b      	mov	r3, r7
    fb64:	f7fc fd28 	bl	c5b8 <__aeabi_dmul>
    fb68:	4625      	mov	r5, r4
    fb6a:	9e03      	ldr	r6, [sp, #12]
    fb6c:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
    fb70:	e9dd 0100 	ldrd	r0, r1, [sp]
    fb74:	f7fd f9be 	bl	cef4 <__aeabi_d2iz>
    fb78:	4607      	mov	r7, r0
    fb7a:	f7fc fcb3 	bl	c4e4 <__aeabi_i2d>
    fb7e:	4602      	mov	r2, r0
    fb80:	3730      	adds	r7, #48	; 0x30
    fb82:	460b      	mov	r3, r1
    fb84:	e9dd 0100 	ldrd	r0, r1, [sp]
    fb88:	f7fc fb5e 	bl	c248 <__aeabi_dsub>
    fb8c:	f806 7b01 	strb.w	r7, [r6], #1
    fb90:	42a6      	cmp	r6, r4
    fb92:	f04f 0200 	mov.w	r2, #0
    fb96:	e9cd 0100 	strd	r0, r1, [sp]
    fb9a:	d125      	bne.n	fbe8 <_dtoa_r+0x5f0>
    fb9c:	4b1b      	ldr	r3, [pc, #108]	; (fc0c <_dtoa_r+0x614>)
    fb9e:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    fba2:	f7fc fb53 	bl	c24c <__adddf3>
    fba6:	4602      	mov	r2, r0
    fba8:	460b      	mov	r3, r1
    fbaa:	e9dd 0100 	ldrd	r0, r1, [sp]
    fbae:	f7fc ff93 	bl	cad8 <__aeabi_dcmpgt>
    fbb2:	2800      	cmp	r0, #0
    fbb4:	d172      	bne.n	fc9c <_dtoa_r+0x6a4>
    fbb6:	2000      	movs	r0, #0
    fbb8:	4914      	ldr	r1, [pc, #80]	; (fc0c <_dtoa_r+0x614>)
    fbba:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
    fbbe:	f7fc fb43 	bl	c248 <__aeabi_dsub>
    fbc2:	4602      	mov	r2, r0
    fbc4:	460b      	mov	r3, r1
    fbc6:	e9dd 0100 	ldrd	r0, r1, [sp]
    fbca:	f7fc ff67 	bl	ca9c <__aeabi_dcmplt>
    fbce:	2800      	cmp	r0, #0
    fbd0:	f43f af31 	beq.w	fa36 <_dtoa_r+0x43e>
    fbd4:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    fbd8:	1e6a      	subs	r2, r5, #1
    fbda:	2b30      	cmp	r3, #48	; 0x30
    fbdc:	d002      	beq.n	fbe4 <_dtoa_r+0x5ec>
    fbde:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    fbe2:	e049      	b.n	fc78 <_dtoa_r+0x680>
    fbe4:	4615      	mov	r5, r2
    fbe6:	e7f5      	b.n	fbd4 <_dtoa_r+0x5dc>
    fbe8:	4b05      	ldr	r3, [pc, #20]	; (fc00 <_dtoa_r+0x608>)
    fbea:	f7fc fce5 	bl	c5b8 <__aeabi_dmul>
    fbee:	e9cd 0100 	strd	r0, r1, [sp]
    fbf2:	e7bd      	b.n	fb70 <_dtoa_r+0x578>
    fbf4:	00030770 	.word	0x00030770
    fbf8:	00030748 	.word	0x00030748
    fbfc:	3ff00000 	.word	0x3ff00000
    fc00:	40240000 	.word	0x40240000
    fc04:	401c0000 	.word	0x401c0000
    fc08:	40140000 	.word	0x40140000
    fc0c:	3fe00000 	.word	0x3fe00000
    fc10:	e9dd 6700 	ldrd	r6, r7, [sp]
    fc14:	9d03      	ldr	r5, [sp, #12]
    fc16:	4630      	mov	r0, r6
    fc18:	4639      	mov	r1, r7
    fc1a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    fc1e:	f7fc fdf5 	bl	c80c <__aeabi_ddiv>
    fc22:	f7fd f967 	bl	cef4 <__aeabi_d2iz>
    fc26:	4604      	mov	r4, r0
    fc28:	f7fc fc5c 	bl	c4e4 <__aeabi_i2d>
    fc2c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    fc30:	f7fc fcc2 	bl	c5b8 <__aeabi_dmul>
    fc34:	4602      	mov	r2, r0
    fc36:	4630      	mov	r0, r6
    fc38:	f104 0630 	add.w	r6, r4, #48	; 0x30
    fc3c:	460b      	mov	r3, r1
    fc3e:	4639      	mov	r1, r7
    fc40:	f7fc fb02 	bl	c248 <__aeabi_dsub>
    fc44:	f805 6b01 	strb.w	r6, [r5], #1
    fc48:	9e03      	ldr	r6, [sp, #12]
    fc4a:	4602      	mov	r2, r0
    fc4c:	460b      	mov	r3, r1
    fc4e:	1bae      	subs	r6, r5, r6
    fc50:	45b1      	cmp	r9, r6
    fc52:	d137      	bne.n	fcc4 <_dtoa_r+0x6cc>
    fc54:	f7fc fafa 	bl	c24c <__adddf3>
    fc58:	4606      	mov	r6, r0
    fc5a:	460f      	mov	r7, r1
    fc5c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    fc60:	f7fc ff3a 	bl	cad8 <__aeabi_dcmpgt>
    fc64:	b9c0      	cbnz	r0, fc98 <_dtoa_r+0x6a0>
    fc66:	4630      	mov	r0, r6
    fc68:	4639      	mov	r1, r7
    fc6a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    fc6e:	f7fc ff0b 	bl	ca88 <__aeabi_dcmpeq>
    fc72:	b108      	cbz	r0, fc78 <_dtoa_r+0x680>
    fc74:	07e1      	lsls	r1, r4, #31
    fc76:	d40f      	bmi.n	fc98 <_dtoa_r+0x6a0>
    fc78:	4641      	mov	r1, r8
    fc7a:	4658      	mov	r0, fp
    fc7c:	f01f feb9 	bl	2f9f2 <_Bfree>
    fc80:	2300      	movs	r3, #0
    fc82:	9a14      	ldr	r2, [sp, #80]	; 0x50
    fc84:	702b      	strb	r3, [r5, #0]
    fc86:	f10a 0301 	add.w	r3, sl, #1
    fc8a:	6013      	str	r3, [r2, #0]
    fc8c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    fc8e:	2b00      	cmp	r3, #0
    fc90:	f43f acfb 	beq.w	f68a <_dtoa_r+0x92>
    fc94:	601d      	str	r5, [r3, #0]
    fc96:	e4f8      	b.n	f68a <_dtoa_r+0x92>
    fc98:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
    fc9c:	f815 2c01 	ldrb.w	r2, [r5, #-1]
    fca0:	1e6b      	subs	r3, r5, #1
    fca2:	2a39      	cmp	r2, #57	; 0x39
    fca4:	d108      	bne.n	fcb8 <_dtoa_r+0x6c0>
    fca6:	9a03      	ldr	r2, [sp, #12]
    fca8:	429a      	cmp	r2, r3
    fcaa:	d109      	bne.n	fcc0 <_dtoa_r+0x6c8>
    fcac:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    fcae:	9903      	ldr	r1, [sp, #12]
    fcb0:	3201      	adds	r2, #1
    fcb2:	920a      	str	r2, [sp, #40]	; 0x28
    fcb4:	2230      	movs	r2, #48	; 0x30
    fcb6:	700a      	strb	r2, [r1, #0]
    fcb8:	781a      	ldrb	r2, [r3, #0]
    fcba:	3201      	adds	r2, #1
    fcbc:	701a      	strb	r2, [r3, #0]
    fcbe:	e78e      	b.n	fbde <_dtoa_r+0x5e6>
    fcc0:	461d      	mov	r5, r3
    fcc2:	e7eb      	b.n	fc9c <_dtoa_r+0x6a4>
    fcc4:	2200      	movs	r2, #0
    fcc6:	4b9d      	ldr	r3, [pc, #628]	; (ff3c <_dtoa_r+0x944>)
    fcc8:	f7fc fc76 	bl	c5b8 <__aeabi_dmul>
    fccc:	2200      	movs	r2, #0
    fcce:	2300      	movs	r3, #0
    fcd0:	4606      	mov	r6, r0
    fcd2:	460f      	mov	r7, r1
    fcd4:	f7fc fed8 	bl	ca88 <__aeabi_dcmpeq>
    fcd8:	2800      	cmp	r0, #0
    fcda:	d09c      	beq.n	fc16 <_dtoa_r+0x61e>
    fcdc:	e7cc      	b.n	fc78 <_dtoa_r+0x680>
    fcde:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    fce0:	2a00      	cmp	r2, #0
    fce2:	f000 80cb 	beq.w	fe7c <_dtoa_r+0x884>
    fce6:	9a08      	ldr	r2, [sp, #32]
    fce8:	2a01      	cmp	r2, #1
    fcea:	f300 80ae 	bgt.w	fe4a <_dtoa_r+0x852>
    fcee:	9a15      	ldr	r2, [sp, #84]	; 0x54
    fcf0:	2a00      	cmp	r2, #0
    fcf2:	f000 80a6 	beq.w	fe42 <_dtoa_r+0x84a>
    fcf6:	f203 4333 	addw	r3, r3, #1075	; 0x433
    fcfa:	9c09      	ldr	r4, [sp, #36]	; 0x24
    fcfc:	9d06      	ldr	r5, [sp, #24]
    fcfe:	9a06      	ldr	r2, [sp, #24]
    fd00:	2101      	movs	r1, #1
    fd02:	4658      	mov	r0, fp
    fd04:	441a      	add	r2, r3
    fd06:	9206      	str	r2, [sp, #24]
    fd08:	9a07      	ldr	r2, [sp, #28]
    fd0a:	441a      	add	r2, r3
    fd0c:	9207      	str	r2, [sp, #28]
    fd0e:	f01f ff14 	bl	2fb3a <__i2b>
    fd12:	4606      	mov	r6, r0
    fd14:	2d00      	cmp	r5, #0
    fd16:	dd0c      	ble.n	fd32 <_dtoa_r+0x73a>
    fd18:	9b07      	ldr	r3, [sp, #28]
    fd1a:	2b00      	cmp	r3, #0
    fd1c:	dd09      	ble.n	fd32 <_dtoa_r+0x73a>
    fd1e:	42ab      	cmp	r3, r5
    fd20:	9a06      	ldr	r2, [sp, #24]
    fd22:	bfa8      	it	ge
    fd24:	462b      	movge	r3, r5
    fd26:	1ad2      	subs	r2, r2, r3
    fd28:	1aed      	subs	r5, r5, r3
    fd2a:	9206      	str	r2, [sp, #24]
    fd2c:	9a07      	ldr	r2, [sp, #28]
    fd2e:	1ad3      	subs	r3, r2, r3
    fd30:	9307      	str	r3, [sp, #28]
    fd32:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fd34:	b1f3      	cbz	r3, fd74 <_dtoa_r+0x77c>
    fd36:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    fd38:	2b00      	cmp	r3, #0
    fd3a:	f000 80a3 	beq.w	fe84 <_dtoa_r+0x88c>
    fd3e:	2c00      	cmp	r4, #0
    fd40:	dd10      	ble.n	fd64 <_dtoa_r+0x76c>
    fd42:	4631      	mov	r1, r6
    fd44:	4622      	mov	r2, r4
    fd46:	4658      	mov	r0, fp
    fd48:	f01b f8be 	bl	2aec8 <__pow5mult>
    fd4c:	4642      	mov	r2, r8
    fd4e:	4601      	mov	r1, r0
    fd50:	4606      	mov	r6, r0
    fd52:	4658      	mov	r0, fp
    fd54:	f01f fefa 	bl	2fb4c <__multiply>
    fd58:	4607      	mov	r7, r0
    fd5a:	4641      	mov	r1, r8
    fd5c:	4658      	mov	r0, fp
    fd5e:	46b8      	mov	r8, r7
    fd60:	f01f fe47 	bl	2f9f2 <_Bfree>
    fd64:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fd66:	1b1a      	subs	r2, r3, r4
    fd68:	d004      	beq.n	fd74 <_dtoa_r+0x77c>
    fd6a:	4641      	mov	r1, r8
    fd6c:	4658      	mov	r0, fp
    fd6e:	f01b f8ab 	bl	2aec8 <__pow5mult>
    fd72:	4680      	mov	r8, r0
    fd74:	2101      	movs	r1, #1
    fd76:	4658      	mov	r0, fp
    fd78:	f01f fedf 	bl	2fb3a <__i2b>
    fd7c:	9b10      	ldr	r3, [sp, #64]	; 0x40
    fd7e:	4604      	mov	r4, r0
    fd80:	2b00      	cmp	r3, #0
    fd82:	f340 8081 	ble.w	fe88 <_dtoa_r+0x890>
    fd86:	461a      	mov	r2, r3
    fd88:	4601      	mov	r1, r0
    fd8a:	4658      	mov	r0, fp
    fd8c:	f01b f89c 	bl	2aec8 <__pow5mult>
    fd90:	9b08      	ldr	r3, [sp, #32]
    fd92:	4604      	mov	r4, r0
    fd94:	2b01      	cmp	r3, #1
    fd96:	dd7a      	ble.n	fe8e <_dtoa_r+0x896>
    fd98:	2700      	movs	r7, #0
    fd9a:	6923      	ldr	r3, [r4, #16]
    fd9c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    fda0:	6918      	ldr	r0, [r3, #16]
    fda2:	f01f fe7a 	bl	2fa9a <__hi0bits>
    fda6:	f1c0 0020 	rsb	r0, r0, #32
    fdaa:	9b07      	ldr	r3, [sp, #28]
    fdac:	4418      	add	r0, r3
    fdae:	f010 001f 	ands.w	r0, r0, #31
    fdb2:	f000 808b 	beq.w	fecc <_dtoa_r+0x8d4>
    fdb6:	f1c0 0320 	rsb	r3, r0, #32
    fdba:	2b04      	cmp	r3, #4
    fdbc:	f340 8084 	ble.w	fec8 <_dtoa_r+0x8d0>
    fdc0:	f1c0 001c 	rsb	r0, r0, #28
    fdc4:	9b06      	ldr	r3, [sp, #24]
    fdc6:	4405      	add	r5, r0
    fdc8:	4403      	add	r3, r0
    fdca:	9306      	str	r3, [sp, #24]
    fdcc:	9b07      	ldr	r3, [sp, #28]
    fdce:	4403      	add	r3, r0
    fdd0:	9307      	str	r3, [sp, #28]
    fdd2:	9b06      	ldr	r3, [sp, #24]
    fdd4:	2b00      	cmp	r3, #0
    fdd6:	dd05      	ble.n	fde4 <_dtoa_r+0x7ec>
    fdd8:	4641      	mov	r1, r8
    fdda:	461a      	mov	r2, r3
    fddc:	4658      	mov	r0, fp
    fdde:	f01f ff44 	bl	2fc6a <__lshift>
    fde2:	4680      	mov	r8, r0
    fde4:	9b07      	ldr	r3, [sp, #28]
    fde6:	2b00      	cmp	r3, #0
    fde8:	dd05      	ble.n	fdf6 <_dtoa_r+0x7fe>
    fdea:	4621      	mov	r1, r4
    fdec:	461a      	mov	r2, r3
    fdee:	4658      	mov	r0, fp
    fdf0:	f01f ff3b 	bl	2fc6a <__lshift>
    fdf4:	4604      	mov	r4, r0
    fdf6:	9b11      	ldr	r3, [sp, #68]	; 0x44
    fdf8:	2b00      	cmp	r3, #0
    fdfa:	d069      	beq.n	fed0 <_dtoa_r+0x8d8>
    fdfc:	4621      	mov	r1, r4
    fdfe:	4640      	mov	r0, r8
    fe00:	f01f ff86 	bl	2fd10 <__mcmp>
    fe04:	2800      	cmp	r0, #0
    fe06:	da63      	bge.n	fed0 <_dtoa_r+0x8d8>
    fe08:	2300      	movs	r3, #0
    fe0a:	4641      	mov	r1, r8
    fe0c:	220a      	movs	r2, #10
    fe0e:	4658      	mov	r0, fp
    fe10:	f01f fe06 	bl	2fa20 <__multadd>
    fe14:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    fe16:	f10a 3aff 	add.w	sl, sl, #4294967295
    fe1a:	4680      	mov	r8, r0
    fe1c:	2b00      	cmp	r3, #0
    fe1e:	f000 8179 	beq.w	10114 <_dtoa_r+0xb1c>
    fe22:	2300      	movs	r3, #0
    fe24:	4631      	mov	r1, r6
    fe26:	220a      	movs	r2, #10
    fe28:	4658      	mov	r0, fp
    fe2a:	f01f fdf9 	bl	2fa20 <__multadd>
    fe2e:	9b04      	ldr	r3, [sp, #16]
    fe30:	4606      	mov	r6, r0
    fe32:	2b00      	cmp	r3, #0
    fe34:	f300 808a 	bgt.w	ff4c <_dtoa_r+0x954>
    fe38:	9b08      	ldr	r3, [sp, #32]
    fe3a:	2b02      	cmp	r3, #2
    fe3c:	f340 8086 	ble.w	ff4c <_dtoa_r+0x954>
    fe40:	e04e      	b.n	fee0 <_dtoa_r+0x8e8>
    fe42:	9b16      	ldr	r3, [sp, #88]	; 0x58
    fe44:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
    fe48:	e757      	b.n	fcfa <_dtoa_r+0x702>
    fe4a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fe4c:	f109 34ff 	add.w	r4, r9, #4294967295
    fe50:	42a3      	cmp	r3, r4
    fe52:	bfb7      	itett	lt
    fe54:	9b09      	ldrlt	r3, [sp, #36]	; 0x24
    fe56:	1b1c      	subge	r4, r3, r4
    fe58:	9409      	strlt	r4, [sp, #36]	; 0x24
    fe5a:	1ae2      	sublt	r2, r4, r3
    fe5c:	bfbf      	itttt	lt
    fe5e:	9b10      	ldrlt	r3, [sp, #64]	; 0x40
    fe60:	2400      	movlt	r4, #0
    fe62:	189b      	addlt	r3, r3, r2
    fe64:	9310      	strlt	r3, [sp, #64]	; 0x40
    fe66:	f1b9 0f00 	cmp.w	r9, #0
    fe6a:	bfb3      	iteet	lt
    fe6c:	9b06      	ldrlt	r3, [sp, #24]
    fe6e:	464b      	movge	r3, r9
    fe70:	9d06      	ldrge	r5, [sp, #24]
    fe72:	eba3 0509 	sublt.w	r5, r3, r9
    fe76:	bfb8      	it	lt
    fe78:	2300      	movlt	r3, #0
    fe7a:	e740      	b.n	fcfe <_dtoa_r+0x706>
    fe7c:	9c09      	ldr	r4, [sp, #36]	; 0x24
    fe7e:	9d06      	ldr	r5, [sp, #24]
    fe80:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    fe82:	e747      	b.n	fd14 <_dtoa_r+0x71c>
    fe84:	9a09      	ldr	r2, [sp, #36]	; 0x24
    fe86:	e770      	b.n	fd6a <_dtoa_r+0x772>
    fe88:	9b08      	ldr	r3, [sp, #32]
    fe8a:	2b01      	cmp	r3, #1
    fe8c:	dc18      	bgt.n	fec0 <_dtoa_r+0x8c8>
    fe8e:	9b00      	ldr	r3, [sp, #0]
    fe90:	b9b3      	cbnz	r3, fec0 <_dtoa_r+0x8c8>
    fe92:	9b01      	ldr	r3, [sp, #4]
    fe94:	f3c3 0313 	ubfx	r3, r3, #0, #20
    fe98:	b9a3      	cbnz	r3, fec4 <_dtoa_r+0x8cc>
    fe9a:	9b01      	ldr	r3, [sp, #4]
    fe9c:	f023 4700 	bic.w	r7, r3, #2147483648	; 0x80000000
    fea0:	0d3f      	lsrs	r7, r7, #20
    fea2:	053f      	lsls	r7, r7, #20
    fea4:	b137      	cbz	r7, feb4 <_dtoa_r+0x8bc>
    fea6:	9b06      	ldr	r3, [sp, #24]
    fea8:	2701      	movs	r7, #1
    feaa:	3301      	adds	r3, #1
    feac:	9306      	str	r3, [sp, #24]
    feae:	9b07      	ldr	r3, [sp, #28]
    feb0:	3301      	adds	r3, #1
    feb2:	9307      	str	r3, [sp, #28]
    feb4:	9b10      	ldr	r3, [sp, #64]	; 0x40
    feb6:	2b00      	cmp	r3, #0
    feb8:	f47f af6f 	bne.w	fd9a <_dtoa_r+0x7a2>
    febc:	2001      	movs	r0, #1
    febe:	e774      	b.n	fdaa <_dtoa_r+0x7b2>
    fec0:	2700      	movs	r7, #0
    fec2:	e7f7      	b.n	feb4 <_dtoa_r+0x8bc>
    fec4:	9f00      	ldr	r7, [sp, #0]
    fec6:	e7f5      	b.n	feb4 <_dtoa_r+0x8bc>
    fec8:	d083      	beq.n	fdd2 <_dtoa_r+0x7da>
    feca:	4618      	mov	r0, r3
    fecc:	301c      	adds	r0, #28
    fece:	e779      	b.n	fdc4 <_dtoa_r+0x7cc>
    fed0:	f1b9 0f00 	cmp.w	r9, #0
    fed4:	dc34      	bgt.n	ff40 <_dtoa_r+0x948>
    fed6:	9b08      	ldr	r3, [sp, #32]
    fed8:	2b02      	cmp	r3, #2
    feda:	dd31      	ble.n	ff40 <_dtoa_r+0x948>
    fedc:	f8cd 9010 	str.w	r9, [sp, #16]
    fee0:	9b04      	ldr	r3, [sp, #16]
    fee2:	b963      	cbnz	r3, fefe <_dtoa_r+0x906>
    fee4:	4621      	mov	r1, r4
    fee6:	2205      	movs	r2, #5
    fee8:	4658      	mov	r0, fp
    feea:	f01f fd99 	bl	2fa20 <__multadd>
    feee:	4601      	mov	r1, r0
    fef0:	4604      	mov	r4, r0
    fef2:	4640      	mov	r0, r8
    fef4:	f01f ff0c 	bl	2fd10 <__mcmp>
    fef8:	2800      	cmp	r0, #0
    fefa:	f73f adc8 	bgt.w	fa8e <_dtoa_r+0x496>
    fefe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    ff00:	9d03      	ldr	r5, [sp, #12]
    ff02:	ea6f 0a03 	mvn.w	sl, r3
    ff06:	2700      	movs	r7, #0
    ff08:	4621      	mov	r1, r4
    ff0a:	4658      	mov	r0, fp
    ff0c:	f01f fd71 	bl	2f9f2 <_Bfree>
    ff10:	2e00      	cmp	r6, #0
    ff12:	f43f aeb1 	beq.w	fc78 <_dtoa_r+0x680>
    ff16:	b12f      	cbz	r7, ff24 <_dtoa_r+0x92c>
    ff18:	42b7      	cmp	r7, r6
    ff1a:	d003      	beq.n	ff24 <_dtoa_r+0x92c>
    ff1c:	4639      	mov	r1, r7
    ff1e:	4658      	mov	r0, fp
    ff20:	f01f fd67 	bl	2f9f2 <_Bfree>
    ff24:	4631      	mov	r1, r6
    ff26:	4658      	mov	r0, fp
    ff28:	f01f fd63 	bl	2f9f2 <_Bfree>
    ff2c:	e6a4      	b.n	fc78 <_dtoa_r+0x680>
    ff2e:	2400      	movs	r4, #0
    ff30:	4626      	mov	r6, r4
    ff32:	e7e4      	b.n	fefe <_dtoa_r+0x906>
    ff34:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    ff38:	4626      	mov	r6, r4
    ff3a:	e5a8      	b.n	fa8e <_dtoa_r+0x496>
    ff3c:	40240000 	.word	0x40240000
    ff40:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    ff42:	f8cd 9010 	str.w	r9, [sp, #16]
    ff46:	2b00      	cmp	r3, #0
    ff48:	f000 80eb 	beq.w	10122 <_dtoa_r+0xb2a>
    ff4c:	2d00      	cmp	r5, #0
    ff4e:	dd05      	ble.n	ff5c <_dtoa_r+0x964>
    ff50:	4631      	mov	r1, r6
    ff52:	462a      	mov	r2, r5
    ff54:	4658      	mov	r0, fp
    ff56:	f01f fe88 	bl	2fc6a <__lshift>
    ff5a:	4606      	mov	r6, r0
    ff5c:	2f00      	cmp	r7, #0
    ff5e:	d056      	beq.n	1000e <_dtoa_r+0xa16>
    ff60:	6871      	ldr	r1, [r6, #4]
    ff62:	4658      	mov	r0, fp
    ff64:	f01f fd11 	bl	2f98a <_Balloc>
    ff68:	6932      	ldr	r2, [r6, #16]
    ff6a:	4605      	mov	r5, r0
    ff6c:	f106 010c 	add.w	r1, r6, #12
    ff70:	3202      	adds	r2, #2
    ff72:	300c      	adds	r0, #12
    ff74:	0092      	lsls	r2, r2, #2
    ff76:	f01f f9ed 	bl	2f354 <memcpy>
    ff7a:	2201      	movs	r2, #1
    ff7c:	4629      	mov	r1, r5
    ff7e:	4658      	mov	r0, fp
    ff80:	f01f fe73 	bl	2fc6a <__lshift>
    ff84:	9b03      	ldr	r3, [sp, #12]
    ff86:	4637      	mov	r7, r6
    ff88:	4606      	mov	r6, r0
    ff8a:	f103 0901 	add.w	r9, r3, #1
    ff8e:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
    ff92:	4413      	add	r3, r2
    ff94:	9309      	str	r3, [sp, #36]	; 0x24
    ff96:	9b00      	ldr	r3, [sp, #0]
    ff98:	f003 0301 	and.w	r3, r3, #1
    ff9c:	9307      	str	r3, [sp, #28]
    ff9e:	f109 33ff 	add.w	r3, r9, #4294967295
    ffa2:	4621      	mov	r1, r4
    ffa4:	4640      	mov	r0, r8
    ffa6:	9300      	str	r3, [sp, #0]
    ffa8:	f01f fbec 	bl	2f784 <quorem>
    ffac:	4603      	mov	r3, r0
    ffae:	9004      	str	r0, [sp, #16]
    ffb0:	4639      	mov	r1, r7
    ffb2:	4640      	mov	r0, r8
    ffb4:	3330      	adds	r3, #48	; 0x30
    ffb6:	930a      	str	r3, [sp, #40]	; 0x28
    ffb8:	f01f feaa 	bl	2fd10 <__mcmp>
    ffbc:	4632      	mov	r2, r6
    ffbe:	9006      	str	r0, [sp, #24]
    ffc0:	4621      	mov	r1, r4
    ffc2:	4658      	mov	r0, fp
    ffc4:	f01f febe 	bl	2fd44 <__mdiff>
    ffc8:	68c2      	ldr	r2, [r0, #12]
    ffca:	4605      	mov	r5, r0
    ffcc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ffce:	bb02      	cbnz	r2, 10012 <_dtoa_r+0xa1a>
    ffd0:	4601      	mov	r1, r0
    ffd2:	4640      	mov	r0, r8
    ffd4:	f01f fe9c 	bl	2fd10 <__mcmp>
    ffd8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    ffda:	4602      	mov	r2, r0
    ffdc:	4629      	mov	r1, r5
    ffde:	4658      	mov	r0, fp
    ffe0:	920c      	str	r2, [sp, #48]	; 0x30
    ffe2:	464d      	mov	r5, r9
    ffe4:	930a      	str	r3, [sp, #40]	; 0x28
    ffe6:	f01f fd04 	bl	2f9f2 <_Bfree>
    ffea:	9b08      	ldr	r3, [sp, #32]
    ffec:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    ffee:	ea43 0102 	orr.w	r1, r3, r2
    fff2:	9b07      	ldr	r3, [sp, #28]
    fff4:	430b      	orrs	r3, r1
    fff6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fff8:	d10d      	bne.n	10016 <_dtoa_r+0xa1e>
    fffa:	2b39      	cmp	r3, #57	; 0x39
    fffc:	d027      	beq.n	1004e <_dtoa_r+0xa56>
    fffe:	9a06      	ldr	r2, [sp, #24]
   10000:	2a00      	cmp	r2, #0
   10002:	dd01      	ble.n	10008 <_dtoa_r+0xa10>
   10004:	9b04      	ldr	r3, [sp, #16]
   10006:	3331      	adds	r3, #49	; 0x31
   10008:	9a00      	ldr	r2, [sp, #0]
   1000a:	7013      	strb	r3, [r2, #0]
   1000c:	e77c      	b.n	ff08 <_dtoa_r+0x910>
   1000e:	4630      	mov	r0, r6
   10010:	e7b8      	b.n	ff84 <_dtoa_r+0x98c>
   10012:	2201      	movs	r2, #1
   10014:	e7e2      	b.n	ffdc <_dtoa_r+0x9e4>
   10016:	9906      	ldr	r1, [sp, #24]
   10018:	2900      	cmp	r1, #0
   1001a:	db04      	blt.n	10026 <_dtoa_r+0xa2e>
   1001c:	9808      	ldr	r0, [sp, #32]
   1001e:	4301      	orrs	r1, r0
   10020:	9807      	ldr	r0, [sp, #28]
   10022:	4301      	orrs	r1, r0
   10024:	d11d      	bne.n	10062 <_dtoa_r+0xa6a>
   10026:	2a00      	cmp	r2, #0
   10028:	ddee      	ble.n	10008 <_dtoa_r+0xa10>
   1002a:	4641      	mov	r1, r8
   1002c:	2201      	movs	r2, #1
   1002e:	4658      	mov	r0, fp
   10030:	9306      	str	r3, [sp, #24]
   10032:	f01f fe1a 	bl	2fc6a <__lshift>
   10036:	4621      	mov	r1, r4
   10038:	4680      	mov	r8, r0
   1003a:	f01f fe69 	bl	2fd10 <__mcmp>
   1003e:	2800      	cmp	r0, #0
   10040:	9b06      	ldr	r3, [sp, #24]
   10042:	dc02      	bgt.n	1004a <_dtoa_r+0xa52>
   10044:	d1e0      	bne.n	10008 <_dtoa_r+0xa10>
   10046:	07da      	lsls	r2, r3, #31
   10048:	d5de      	bpl.n	10008 <_dtoa_r+0xa10>
   1004a:	2b39      	cmp	r3, #57	; 0x39
   1004c:	d1da      	bne.n	10004 <_dtoa_r+0xa0c>
   1004e:	2339      	movs	r3, #57	; 0x39
   10050:	9a00      	ldr	r2, [sp, #0]
   10052:	7013      	strb	r3, [r2, #0]
   10054:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   10058:	1e6a      	subs	r2, r5, #1
   1005a:	2b39      	cmp	r3, #57	; 0x39
   1005c:	d046      	beq.n	100ec <_dtoa_r+0xaf4>
   1005e:	3301      	adds	r3, #1
   10060:	e7d3      	b.n	1000a <_dtoa_r+0xa12>
   10062:	2a00      	cmp	r2, #0
   10064:	dd03      	ble.n	1006e <_dtoa_r+0xa76>
   10066:	2b39      	cmp	r3, #57	; 0x39
   10068:	d0f1      	beq.n	1004e <_dtoa_r+0xa56>
   1006a:	3301      	adds	r3, #1
   1006c:	e7cc      	b.n	10008 <_dtoa_r+0xa10>
   1006e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   10070:	f809 3c01 	strb.w	r3, [r9, #-1]
   10074:	4591      	cmp	r9, r2
   10076:	d021      	beq.n	100bc <_dtoa_r+0xac4>
   10078:	4641      	mov	r1, r8
   1007a:	2300      	movs	r3, #0
   1007c:	220a      	movs	r2, #10
   1007e:	4658      	mov	r0, fp
   10080:	f01f fcce 	bl	2fa20 <__multadd>
   10084:	42b7      	cmp	r7, r6
   10086:	4680      	mov	r8, r0
   10088:	f04f 0300 	mov.w	r3, #0
   1008c:	f04f 020a 	mov.w	r2, #10
   10090:	4639      	mov	r1, r7
   10092:	4658      	mov	r0, fp
   10094:	d106      	bne.n	100a4 <_dtoa_r+0xaac>
   10096:	f01f fcc3 	bl	2fa20 <__multadd>
   1009a:	4607      	mov	r7, r0
   1009c:	4606      	mov	r6, r0
   1009e:	f109 0901 	add.w	r9, r9, #1
   100a2:	e77c      	b.n	ff9e <_dtoa_r+0x9a6>
   100a4:	f01f fcbc 	bl	2fa20 <__multadd>
   100a8:	4631      	mov	r1, r6
   100aa:	4607      	mov	r7, r0
   100ac:	2300      	movs	r3, #0
   100ae:	220a      	movs	r2, #10
   100b0:	4658      	mov	r0, fp
   100b2:	f01f fcb5 	bl	2fa20 <__multadd>
   100b6:	4606      	mov	r6, r0
   100b8:	e7f1      	b.n	1009e <_dtoa_r+0xaa6>
   100ba:	2700      	movs	r7, #0
   100bc:	4641      	mov	r1, r8
   100be:	2201      	movs	r2, #1
   100c0:	4658      	mov	r0, fp
   100c2:	9300      	str	r3, [sp, #0]
   100c4:	f01f fdd1 	bl	2fc6a <__lshift>
   100c8:	4621      	mov	r1, r4
   100ca:	4680      	mov	r8, r0
   100cc:	f01f fe20 	bl	2fd10 <__mcmp>
   100d0:	2800      	cmp	r0, #0
   100d2:	dcbf      	bgt.n	10054 <_dtoa_r+0xa5c>
   100d4:	d102      	bne.n	100dc <_dtoa_r+0xae4>
   100d6:	9b00      	ldr	r3, [sp, #0]
   100d8:	07db      	lsls	r3, r3, #31
   100da:	d4bb      	bmi.n	10054 <_dtoa_r+0xa5c>
   100dc:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   100e0:	1e6a      	subs	r2, r5, #1
   100e2:	2b30      	cmp	r3, #48	; 0x30
   100e4:	f47f af10 	bne.w	ff08 <_dtoa_r+0x910>
   100e8:	4615      	mov	r5, r2
   100ea:	e7f7      	b.n	100dc <_dtoa_r+0xae4>
   100ec:	9b03      	ldr	r3, [sp, #12]
   100ee:	4293      	cmp	r3, r2
   100f0:	d104      	bne.n	100fc <_dtoa_r+0xb04>
   100f2:	f10a 0a01 	add.w	sl, sl, #1
   100f6:	2331      	movs	r3, #49	; 0x31
   100f8:	9a03      	ldr	r2, [sp, #12]
   100fa:	e786      	b.n	1000a <_dtoa_r+0xa12>
   100fc:	4615      	mov	r5, r2
   100fe:	e7a9      	b.n	10054 <_dtoa_r+0xa5c>
   10100:	4b13      	ldr	r3, [pc, #76]	; (10150 <_dtoa_r+0xb58>)
   10102:	f7ff bae1 	b.w	f6c8 <_dtoa_r+0xd0>
   10106:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   10108:	2b00      	cmp	r3, #0
   1010a:	f47f aab9 	bne.w	f680 <_dtoa_r+0x88>
   1010e:	4b11      	ldr	r3, [pc, #68]	; (10154 <_dtoa_r+0xb5c>)
   10110:	f7ff bada 	b.w	f6c8 <_dtoa_r+0xd0>
   10114:	9b04      	ldr	r3, [sp, #16]
   10116:	2b00      	cmp	r3, #0
   10118:	dc03      	bgt.n	10122 <_dtoa_r+0xb2a>
   1011a:	9b08      	ldr	r3, [sp, #32]
   1011c:	2b02      	cmp	r3, #2
   1011e:	f73f aedf 	bgt.w	fee0 <_dtoa_r+0x8e8>
   10122:	9d03      	ldr	r5, [sp, #12]
   10124:	4621      	mov	r1, r4
   10126:	4640      	mov	r0, r8
   10128:	f01f fb2c 	bl	2f784 <quorem>
   1012c:	9a03      	ldr	r2, [sp, #12]
   1012e:	f100 0330 	add.w	r3, r0, #48	; 0x30
   10132:	9904      	ldr	r1, [sp, #16]
   10134:	f805 3b01 	strb.w	r3, [r5], #1
   10138:	1aaa      	subs	r2, r5, r2
   1013a:	4291      	cmp	r1, r2
   1013c:	ddbd      	ble.n	100ba <_dtoa_r+0xac2>
   1013e:	4641      	mov	r1, r8
   10140:	2300      	movs	r3, #0
   10142:	220a      	movs	r2, #10
   10144:	4658      	mov	r0, fp
   10146:	f01f fc6b 	bl	2fa20 <__multadd>
   1014a:	4680      	mov	r8, r0
   1014c:	e7ea      	b.n	10124 <_dtoa_r+0xb2c>
   1014e:	bf00      	nop
   10150:	0003495a 	.word	0x0003495a
   10154:	00034f83 	.word	0x00034f83

00010158 <system_init>:
#endif
#endif
}

void system_init(void)
{
   10158:	b508      	push	{r3, lr}
	InitSystemSettings();
   1015a:	f001 fcc1 	bl	11ae0 <InitSystemSettings>
	
	pmu_init();
   1015e:	f006 fb45 	bl	167ec <pmu_init>
	flash_init();
   10162:	f001 fd7f 	bl	11c64 <flash_init>
	LCD_Init();
   10166:	f000 ffb9 	bl	110dc <LCD_Init>
	
	ShowBootUpLogo();
   1016a:	f01c fcbe 	bl	2caea <ShowBootUpLogo>

	key_init();
   1016e:	f001 fb3d 	bl	117ec <key_init>
	IMU_init(&imu_work_q);
   10172:	4806      	ldr	r0, [pc, #24]	; (1018c <system_init+0x34>)
   10174:	f005 f912 	bl	1539c <IMU_init>
	ble_init();//UART_0ATAT
   10178:	f002 fc8a 	bl	12a90 <ble_init>
	NB_init(&nb_work_q);
   1017c:	4804      	ldr	r0, [pc, #16]	; (10190 <system_init+0x38>)
   1017e:	f004 faa7 	bl	146d0 <NB_init>
	
	EnterIdleScreen();
}
   10182:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	EnterIdleScreen();
   10186:	f006 b873 	b.w	16270 <EnterIdleScreen>
   1018a:	bf00      	nop
   1018c:	20020960 	.word	0x20020960
   10190:	20020a24 	.word	0x20020a24

00010194 <work_init>:

void work_init(void)
{
   10194:	b510      	push	{r4, lr}
	k_work_q_start(&nb_work_q, nb_stack_area,
   10196:	f04f 33ff 	mov.w	r3, #4294967295
   1019a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   1019e:	4907      	ldr	r1, [pc, #28]	; (101bc <work_init+0x28>)
   101a0:	4807      	ldr	r0, [pc, #28]	; (101c0 <work_init+0x2c>)
   101a2:	f018 fc51 	bl	28a48 <k_work_q_start>
		       		K_THREAD_STACK_SIZEOF(nb_stack_area),
		       		CONFIG_APPLICATION_WORKQUEUE_PRIORITY);
    k_work_q_start(&imu_work_q, imu_stack_area,
					K_THREAD_STACK_SIZEOF(imu_stack_area),
					CONFIG_APPLICATION_WORKQUEUE_PRIORITY);
}
   101a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    k_work_q_start(&imu_work_q, imu_stack_area,
   101aa:	f04f 33ff 	mov.w	r3, #4294967295
   101ae:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   101b2:	4904      	ldr	r1, [pc, #16]	; (101c4 <work_init+0x30>)
   101b4:	4804      	ldr	r0, [pc, #16]	; (101c8 <work_init+0x34>)
   101b6:	f018 bc47 	b.w	28a48 <k_work_q_start>
   101ba:	bf00      	nop
   101bc:	20031618 	.word	0x20031618
   101c0:	20020a24 	.word	0x20020a24
   101c4:	20032618 	.word	0x20032618
   101c8:	20020960 	.word	0x20020960

000101cc <clock_timer_handler>:
	}
}

static void clock_timer_handler(struct k_timer *timer)
{
	sys_time_count = true;
   101cc:	2201      	movs	r2, #1
   101ce:	4b01      	ldr	r3, [pc, #4]	; (101d4 <clock_timer_handler+0x8>)
   101d0:	701a      	strb	r2, [r3, #0]
}
   101d2:	4770      	bx	lr
   101d4:	2002d493 	.word	0x2002d493

000101d8 <DateIncreaseOne>:
{
   101d8:	b570      	push	{r4, r5, r6, lr}
	(*date).day++;
   101da:	78c5      	ldrb	r5, [r0, #3]
	if((*date).month == 1 \
   101dc:	7881      	ldrb	r1, [r0, #2]
	(*date).day++;
   101de:	3501      	adds	r5, #1
   101e0:	b2ed      	uxtb	r5, r5
	if((*date).month == 1 \
   101e2:	290c      	cmp	r1, #12
{
   101e4:	4604      	mov	r4, r0
	(*date).day++;
   101e6:	70c5      	strb	r5, [r0, #3]
	if((*date).month == 1 \
   101e8:	d804      	bhi.n	101f4 <DateIncreaseOne+0x1c>
   101ea:	f241 53aa 	movw	r3, #5546	; 0x15aa
   101ee:	40cb      	lsrs	r3, r1
   101f0:	07db      	lsls	r3, r3, #31
   101f2:	d41e      	bmi.n	10232 <DateIncreaseOne+0x5a>
	else if((*date).month == 4 \
   101f4:	f001 03fd 	and.w	r3, r1, #253	; 0xfd
   101f8:	2b04      	cmp	r3, #4
   101fa:	d124      	bne.n	10246 <DateIncreaseOne+0x6e>
		if((*date).day > 30)
   101fc:	2d1e      	cmp	r5, #30
   101fe:	d909      	bls.n	10214 <DateIncreaseOne+0x3c>
			(*date).day = 1;
   10200:	2301      	movs	r3, #1
			(*date).month++;
   10202:	4419      	add	r1, r3
   10204:	b2c9      	uxtb	r1, r1
			if((*date).month > 12)
   10206:	290c      	cmp	r1, #12
			(*date).day = 1;
   10208:	70e3      	strb	r3, [r4, #3]
			if((*date).month > 12)
   1020a:	d91a      	bls.n	10242 <DateIncreaseOne+0x6a>
				(*date).month = 1;
   1020c:	70a3      	strb	r3, [r4, #2]
				(*date).year++;
   1020e:	8823      	ldrh	r3, [r4, #0]
   10210:	3301      	adds	r3, #1
   10212:	8023      	strh	r3, [r4, #0]
	(*date).week = GetWeekDayByDate((*date));
   10214:	6861      	ldr	r1, [r4, #4]
   10216:	6820      	ldr	r0, [r4, #0]
   10218:	f01b f912 	bl	2b440 <GetWeekDayByDate>
	if(screen_id == SCREEN_ID_IDLE)
   1021c:	4b15      	ldr	r3, [pc, #84]	; (10274 <DateIncreaseOne+0x9c>)
	(*date).week = GetWeekDayByDate((*date));
   1021e:	71e0      	strb	r0, [r4, #7]
	if(screen_id == SCREEN_ID_IDLE)
   10220:	781b      	ldrb	r3, [r3, #0]
   10222:	2b01      	cmp	r3, #1
		scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);
   10224:	bf01      	itttt	eq
   10226:	4a14      	ldreq	r2, [pc, #80]	; (10278 <DateIncreaseOne+0xa0>)
   10228:	68d3      	ldreq	r3, [r2, #12]
   1022a:	f043 0318 	orreq.w	r3, r3, #24
   1022e:	60d3      	streq	r3, [r2, #12]
}
   10230:	bd70      	pop	{r4, r5, r6, pc}
		if((*date).day > 31)
   10232:	2d1f      	cmp	r5, #31
   10234:	d9ee      	bls.n	10214 <DateIncreaseOne+0x3c>
			(*date).day = 1;
   10236:	2301      	movs	r3, #1
			(*date).month++;
   10238:	4419      	add	r1, r3
   1023a:	b2c9      	uxtb	r1, r1
			if((*date).month > 12)
   1023c:	290d      	cmp	r1, #13
			(*date).day = 1;
   1023e:	70c3      	strb	r3, [r0, #3]
			if((*date).month > 12)
   10240:	d0e4      	beq.n	1020c <DateIncreaseOne+0x34>
			(*date).month++;
   10242:	70a1      	strb	r1, [r4, #2]
   10244:	e7e6      	b.n	10214 <DateIncreaseOne+0x3c>
		|| (*date).month == 9 \
   10246:	2b09      	cmp	r3, #9
   10248:	d0d8      	beq.n	101fc <DateIncreaseOne+0x24>
		if(CheckYearIsLeap((*date).year))
   1024a:	8826      	ldrh	r6, [r4, #0]
   1024c:	4630      	mov	r0, r6
   1024e:	f01b f8e3 	bl	2b418 <CheckYearIsLeap>
		if((*date).day > (28+Leap))
   10252:	2800      	cmp	r0, #0
   10254:	bf14      	ite	ne
   10256:	231d      	movne	r3, #29
   10258:	231c      	moveq	r3, #28
   1025a:	429d      	cmp	r5, r3
   1025c:	ddda      	ble.n	10214 <DateIncreaseOne+0x3c>
			(*date).day = 1;
   1025e:	2301      	movs	r3, #1
			(*date).month++;
   10260:	4419      	add	r1, r3
   10262:	b2c9      	uxtb	r1, r1
			if((*date).month > 12)
   10264:	290c      	cmp	r1, #12
			(*date).day = 1;
   10266:	70e3      	strb	r3, [r4, #3]
			if((*date).month > 12)
   10268:	d9eb      	bls.n	10242 <DateIncreaseOne+0x6a>
				(*date).year++;
   1026a:	3601      	adds	r6, #1
				(*date).month = 1;
   1026c:	70a3      	strb	r3, [r4, #2]
				(*date).year++;
   1026e:	8026      	strh	r6, [r4, #0]
   10270:	e7d0      	b.n	10214 <DateIncreaseOne+0x3c>
   10272:	bf00      	nop
   10274:	2002ff93 	.word	0x2002ff93
   10278:	20028540 	.word	0x20028540

0001027c <DateDecreaseOne>:
{
   1027c:	b510      	push	{r4, lr}
	if((*date).day > 1)
   1027e:	78c3      	ldrb	r3, [r0, #3]
{
   10280:	4604      	mov	r4, r0
	if((*date).day > 1)
   10282:	2b01      	cmp	r3, #1
   10284:	d910      	bls.n	102a8 <DateDecreaseOne+0x2c>
		(*date).day--;
   10286:	3b01      	subs	r3, #1
   10288:	70c3      	strb	r3, [r0, #3]
	(*date).week = GetWeekDayByDate((*date));
   1028a:	6861      	ldr	r1, [r4, #4]
   1028c:	6820      	ldr	r0, [r4, #0]
   1028e:	f01b f8d7 	bl	2b440 <GetWeekDayByDate>
	if(screen_id == SCREEN_ID_IDLE)
   10292:	4b1a      	ldr	r3, [pc, #104]	; (102fc <DateDecreaseOne+0x80>)
	(*date).week = GetWeekDayByDate((*date));
   10294:	71e0      	strb	r0, [r4, #7]
	if(screen_id == SCREEN_ID_IDLE)
   10296:	781b      	ldrb	r3, [r3, #0]
   10298:	2b01      	cmp	r3, #1
		scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);
   1029a:	bf01      	itttt	eq
   1029c:	4a18      	ldreq	r2, [pc, #96]	; (10300 <DateDecreaseOne+0x84>)
   1029e:	68d3      	ldreq	r3, [r2, #12]
   102a0:	f043 0318 	orreq.w	r3, r3, #24
   102a4:	60d3      	streq	r3, [r2, #12]
}
   102a6:	bd10      	pop	{r4, pc}
		if((*date).month == 1 \
   102a8:	7883      	ldrb	r3, [r0, #2]
		|| (*date).month == 2 \
   102aa:	1e59      	subs	r1, r3, #1
   102ac:	b2c9      	uxtb	r1, r1
		if((*date).month == 1 \
   102ae:	290a      	cmp	r1, #10
   102b0:	d90b      	bls.n	102ca <DateDecreaseOne+0x4e>
		else if((*date).month == 5 \
   102b2:	2b0c      	cmp	r3, #12
   102b4:	d818      	bhi.n	102e8 <DateDecreaseOne+0x6c>
   102b6:	f44f 52a5 	mov.w	r2, #5280	; 0x14a0
   102ba:	fa22 f303 	lsr.w	r3, r2, r3
   102be:	07db      	lsls	r3, r3, #31
   102c0:	d512      	bpl.n	102e8 <DateDecreaseOne+0x6c>
			(*date).day = 30;
   102c2:	231e      	movs	r3, #30
   102c4:	70e3      	strb	r3, [r4, #3]
			(*date).month--;
   102c6:	70a1      	strb	r1, [r4, #2]
   102c8:	e7df      	b.n	1028a <DateDecreaseOne+0xe>
		if((*date).month == 1 \
   102ca:	f240 52ab 	movw	r2, #1451	; 0x5ab
   102ce:	40ca      	lsrs	r2, r1
   102d0:	07d2      	lsls	r2, r2, #31
   102d2:	d5f0      	bpl.n	102b6 <DateDecreaseOne+0x3a>
			(*date).day = 31;
   102d4:	221f      	movs	r2, #31
			if((*date).month == 1)
   102d6:	2b01      	cmp	r3, #1
			(*date).day = 31;
   102d8:	70c2      	strb	r2, [r0, #3]
			if((*date).month == 1)
   102da:	d1f4      	bne.n	102c6 <DateDecreaseOne+0x4a>
				(*date).year--;
   102dc:	8803      	ldrh	r3, [r0, #0]
   102de:	3b01      	subs	r3, #1
   102e0:	8003      	strh	r3, [r0, #0]
				(*date).month = 12;
   102e2:	230c      	movs	r3, #12
   102e4:	7083      	strb	r3, [r0, #2]
   102e6:	e7d0      	b.n	1028a <DateDecreaseOne+0xe>
			if(CheckYearIsLeap((*date).year))
   102e8:	8820      	ldrh	r0, [r4, #0]
   102ea:	f01b f895 	bl	2b418 <CheckYearIsLeap>
   102ee:	3000      	adds	r0, #0
   102f0:	bf18      	it	ne
   102f2:	2001      	movne	r0, #1
			(*date).day = (28+Leap);
   102f4:	301c      	adds	r0, #28
   102f6:	70e0      	strb	r0, [r4, #3]
   102f8:	e7e5      	b.n	102c6 <DateDecreaseOne+0x4a>
   102fa:	bf00      	nop
   102fc:	2002ff93 	.word	0x2002ff93
   10300:	20028540 	.word	0x20028540

00010304 <TimeIncrease>:
{
   10304:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	m_add = minutes%60;
   10308:	f04f 083c 	mov.w	r8, #60	; 0x3c
{
   1030c:	4606      	mov	r6, r0
	m_add = minutes%60;
   1030e:	fbb1 f4f8 	udiv	r4, r1, r8
	LOG_INF("m_add:%d, h_add:%d\n", m_add, h_add);
   10312:	2303      	movs	r3, #3
   10314:	f04f 0000 	mov.w	r0, #0
	m_add = minutes%60;
   10318:	fb08 1714 	mls	r7, r8, r4, r1
	LOG_INF("m_add:%d, h_add:%d\n", m_add, h_add);
   1031c:	f363 0007 	bfi	r0, r3, #0, #8
   10320:	4a21      	ldr	r2, [pc, #132]	; (103a8 <TimeIncrease+0xa4>)
   10322:	4b22      	ldr	r3, [pc, #136]	; (103ac <TimeIncrease+0xa8>)
	h_add = minutes/60;
   10324:	b2e4      	uxtb	r4, r4
   10326:	1a9b      	subs	r3, r3, r2
   10328:	08db      	lsrs	r3, r3, #3
	LOG_INF("m_add:%d, h_add:%d\n", m_add, h_add);
   1032a:	f363 108f 	bfi	r0, r3, #6, #10
   1032e:	4920      	ldr	r1, [pc, #128]	; (103b0 <TimeIncrease+0xac>)
   10330:	4623      	mov	r3, r4
   10332:	463a      	mov	r2, r7
   10334:	f01c ffe0 	bl	2d2f8 <log_string_sync>
	(*date).minute += m_add;
   10338:	7971      	ldrb	r1, [r6, #5]
	day_add = h_add/24;
   1033a:	2518      	movs	r5, #24
	(*date).minute += m_add;
   1033c:	4439      	add	r1, r7
   1033e:	b2c9      	uxtb	r1, r1
	if((*date).minute > 59)
   10340:	293b      	cmp	r1, #59	; 0x3b
		(*date).minute = (*date).minute%60;
   10342:	bf88      	it	hi
   10344:	fbb1 f3f8 	udivhi	r3, r1, r8
	day_add = h_add/24;
   10348:	fbb4 f5f5 	udiv	r5, r4, r5
		(*date).minute = (*date).minute%60;
   1034c:	bf84      	itt	hi
   1034e:	fb08 1113 	mlshi	r1, r8, r3, r1
		h_add++;
   10352:	3401      	addhi	r4, #1
	(*date).hour += h_add;
   10354:	7933      	ldrb	r3, [r6, #4]
		h_add++;
   10356:	bf88      	it	hi
   10358:	b2e4      	uxtbhi	r4, r4
	(*date).hour += h_add;
   1035a:	441c      	add	r4, r3
   1035c:	b2e4      	uxtb	r4, r4
	(*date).minute += m_add;
   1035e:	bf94      	ite	ls
   10360:	7171      	strbls	r1, [r6, #5]
		(*date).minute = (*date).minute%60;
   10362:	7171      	strbhi	r1, [r6, #5]
	if((*date).hour > 23)
   10364:	2c17      	cmp	r4, #23
   10366:	d811      	bhi.n	1038c <TimeIncrease+0x88>
	(*date).hour += h_add;
   10368:	7134      	strb	r4, [r6, #4]
	while(day_add>0)
   1036a:	b9c5      	cbnz	r5, 1039e <TimeIncrease+0x9a>
	(*date).week = GetWeekDayByDate((*date));
   1036c:	6871      	ldr	r1, [r6, #4]
   1036e:	6830      	ldr	r0, [r6, #0]
   10370:	f01b f866 	bl	2b440 <GetWeekDayByDate>
	if(screen_id == SCREEN_ID_IDLE)
   10374:	4b0f      	ldr	r3, [pc, #60]	; (103b4 <TimeIncrease+0xb0>)
	(*date).week = GetWeekDayByDate((*date));
   10376:	71f0      	strb	r0, [r6, #7]
	if(screen_id == SCREEN_ID_IDLE)
   10378:	781b      	ldrb	r3, [r3, #0]
   1037a:	2b01      	cmp	r3, #1
		scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);	
   1037c:	bf01      	itttt	eq
   1037e:	4a0e      	ldreq	r2, [pc, #56]	; (103b8 <TimeIncrease+0xb4>)
   10380:	68d3      	ldreq	r3, [r2, #12]
   10382:	f043 0318 	orreq.w	r3, r3, #24
   10386:	60d3      	streq	r3, [r2, #12]
}
   10388:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		(*date).hour = (*date).hour%24;
   1038c:	2218      	movs	r2, #24
   1038e:	fbb4 f3f2 	udiv	r3, r4, r2
   10392:	fb02 4413 	mls	r4, r2, r3, r4
		day_add++;
   10396:	3501      	adds	r5, #1
		(*date).hour = (*date).hour%24;
   10398:	7134      	strb	r4, [r6, #4]
		day_add--;
   1039a:	b2ed      	uxtb	r5, r5
   1039c:	e7e5      	b.n	1036a <TimeIncrease+0x66>
		DateIncreaseOne(date);
   1039e:	4630      	mov	r0, r6
   103a0:	f7ff ff1a 	bl	101d8 <DateIncreaseOne>
		day_add--;
   103a4:	3d01      	subs	r5, #1
   103a6:	e7f8      	b.n	1039a <TimeIncrease+0x96>
   103a8:	0003040c 	.word	0x0003040c
   103ac:	0003044c 	.word	0x0003044c
   103b0:	00031028 	.word	0x00031028
   103b4:	2002ff93 	.word	0x2002ff93
   103b8:	20028540 	.word	0x20028540

000103bc <TimeDecrease>:
	m_dec = minutes%60;
   103bc:	223c      	movs	r2, #60	; 0x3c
{
   103be:	b538      	push	{r3, r4, r5, lr}
	m_dec = minutes%60;
   103c0:	fbb1 f3f2 	udiv	r3, r1, r2
{
   103c4:	4605      	mov	r5, r0
	day_dec = h_dec/24;
   103c6:	2418      	movs	r4, #24
	m_dec = minutes%60;
   103c8:	fb02 1113 	mls	r1, r2, r3, r1
	if((*date).minute >= m_dec)
   103cc:	7940      	ldrb	r0, [r0, #5]
	m_dec = minutes%60;
   103ce:	b2c9      	uxtb	r1, r1
	h_dec = minutes/60;
   103d0:	1a42      	subs	r2, r0, r1
	if((*date).minute >= m_dec)
   103d2:	4288      	cmp	r0, r1
	h_dec = minutes/60;
   103d4:	b2db      	uxtb	r3, r3
	day_dec = h_dec/24;
   103d6:	b2d2      	uxtb	r2, r2
		(*date).minute = ((*date).minute+60)-m_dec;
   103d8:	bf38      	it	cc
   103da:	323c      	addcc	r2, #60	; 0x3c
	day_dec = h_dec/24;
   103dc:	fbb3 f4f4 	udiv	r4, r3, r4
	if((*date).hour >= h_dec)
   103e0:	7929      	ldrb	r1, [r5, #4]
		h_dec++;
   103e2:	bf3e      	ittt	cc
   103e4:	3301      	addcc	r3, #1
		(*date).minute = ((*date).minute+60)-m_dec;
   103e6:	b2d2      	uxtbcc	r2, r2
		h_dec++;
   103e8:	b2db      	uxtbcc	r3, r3
   103ea:	716a      	strb	r2, [r5, #5]
	if((*date).hour >= h_dec)
   103ec:	4299      	cmp	r1, r3
   103ee:	eba1 0203 	sub.w	r2, r1, r3
   103f2:	b2d2      	uxtb	r2, r2
   103f4:	d310      	bcc.n	10418 <TimeDecrease+0x5c>
   103f6:	712a      	strb	r2, [r5, #4]
	while(day_dec>0)
   103f8:	b99c      	cbnz	r4, 10422 <TimeDecrease+0x66>
	(*date).week = GetWeekDayByDate((*date));
   103fa:	6869      	ldr	r1, [r5, #4]
   103fc:	6828      	ldr	r0, [r5, #0]
   103fe:	f01b f81f 	bl	2b440 <GetWeekDayByDate>
	if(screen_id == SCREEN_ID_IDLE)
   10402:	4b0b      	ldr	r3, [pc, #44]	; (10430 <TimeDecrease+0x74>)
	(*date).week = GetWeekDayByDate((*date));
   10404:	71e8      	strb	r0, [r5, #7]
	if(screen_id == SCREEN_ID_IDLE)
   10406:	781b      	ldrb	r3, [r3, #0]
   10408:	2b01      	cmp	r3, #1
		scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);	
   1040a:	bf01      	itttt	eq
   1040c:	4a09      	ldreq	r2, [pc, #36]	; (10434 <TimeDecrease+0x78>)
   1040e:	68d3      	ldreq	r3, [r2, #12]
   10410:	f043 0318 	orreq.w	r3, r3, #24
   10414:	60d3      	streq	r3, [r2, #12]
}
   10416:	bd38      	pop	{r3, r4, r5, pc}
		(*date).hour = ((*date).hour+24)-h_dec;
   10418:	3218      	adds	r2, #24
		day_dec++;
   1041a:	3401      	adds	r4, #1
		(*date).hour = ((*date).hour+24)-h_dec;
   1041c:	b2d2      	uxtb	r2, r2
		day_dec++;
   1041e:	b2e4      	uxtb	r4, r4
   10420:	e7e9      	b.n	103f6 <TimeDecrease+0x3a>
		DateDecreaseOne(date);
   10422:	4628      	mov	r0, r5
		day_dec--;
   10424:	3c01      	subs	r4, #1
		DateDecreaseOne(date);
   10426:	f7ff ff29 	bl	1027c <DateDecreaseOne>
		day_dec--;
   1042a:	b2e4      	uxtb	r4, r4
   1042c:	e7e4      	b.n	103f8 <TimeDecrease+0x3c>
   1042e:	bf00      	nop
   10430:	2002ff93 	.word	0x2002ff93
   10434:	20028540 	.word	0x20028540

00010438 <RedrawSystemTime>:
	if(screen_id == SCREEN_ID_IDLE)
   10438:	4b04      	ldr	r3, [pc, #16]	; (1044c <RedrawSystemTime+0x14>)
   1043a:	781b      	ldrb	r3, [r3, #0]
   1043c:	2b01      	cmp	r3, #1
		scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_TIME|SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);
   1043e:	bf01      	itttt	eq
   10440:	4a03      	ldreq	r2, [pc, #12]	; (10450 <RedrawSystemTime+0x18>)
   10442:	68d3      	ldreq	r3, [r2, #12]
   10444:	f043 031c 	orreq.w	r3, r3, #28
   10448:	60d3      	streq	r3, [r2, #12]
}
   1044a:	4770      	bx	lr
   1044c:	2002ff93 	.word	0x2002ff93
   10450:	20028540 	.word	0x20028540

00010454 <UpdateSystemTime>:
{
   10454:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   	memcpy(&last_date_time, &date_time, sizeof(sys_date_timer_t));
   10458:	4959      	ldr	r1, [pc, #356]	; (105c0 <UpdateSystemTime+0x16c>)
   1045a:	4a5a      	ldr	r2, [pc, #360]	; (105c4 <UpdateSystemTime+0x170>)
   1045c:	680b      	ldr	r3, [r1, #0]
   1045e:	4d5a      	ldr	r5, [pc, #360]	; (105c8 <UpdateSystemTime+0x174>)
   10460:	6013      	str	r3, [r2, #0]
   10462:	684b      	ldr	r3, [r1, #4]
   10464:	6053      	str	r3, [r2, #4]
	if(screen_id == SCREEN_ID_IDLE)
   10466:	4b59      	ldr	r3, [pc, #356]	; (105cc <UpdateSystemTime+0x178>)
   10468:	781f      	ldrb	r7, [r3, #0]
   1046a:	2f01      	cmp	r7, #1
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_TIME;
   1046c:	bf01      	itttt	eq
   1046e:	4a58      	ldreq	r2, [pc, #352]	; (105d0 <UpdateSystemTime+0x17c>)
   10470:	68d3      	ldreq	r3, [r2, #12]
   10472:	f043 0304 	orreq.w	r3, r3, #4
   10476:	60d3      	streq	r3, [r2, #12]
	date_time.second++;	// += (timeskip/1000);
   10478:	798b      	ldrb	r3, [r1, #6]
   1047a:	3301      	adds	r3, #1
   1047c:	b2db      	uxtb	r3, r3
	if(date_time.second > 59)
   1047e:	2b3b      	cmp	r3, #59	; 0x3b
	date_time.second++;	// += (timeskip/1000);
   10480:	718b      	strb	r3, [r1, #6]
	if(date_time.second > 59)
   10482:	d951      	bls.n	10528 <UpdateSystemTime+0xd4>
		date_time.second = date_time.second%60;
   10484:	203c      	movs	r0, #60	; 0x3c
   10486:	fbb3 f2f0 	udiv	r2, r3, r0
   1048a:	fb00 3312 	mls	r3, r0, r2, r3
   1048e:	718b      	strb	r3, [r1, #6]
		date_time.minute++;
   10490:	794b      	ldrb	r3, [r1, #5]
   10492:	782e      	ldrb	r6, [r5, #0]
   10494:	3301      	adds	r3, #1
   10496:	b2db      	uxtb	r3, r3
		date_time_changed = date_time_changed|0x02;
   10498:	f046 0202 	orr.w	r2, r6, #2
		if(date_time.minute > 59)
   1049c:	2b3b      	cmp	r3, #59	; 0x3b
		date_time.minute++;
   1049e:	714b      	strb	r3, [r1, #5]
		date_time_changed = date_time_changed|0x02;
   104a0:	702a      	strb	r2, [r5, #0]
		if(date_time.minute > 59)
   104a2:	d941      	bls.n	10528 <UpdateSystemTime+0xd4>
			date_time.minute = 0;
   104a4:	2200      	movs	r2, #0
			date_time.hour++;
   104a6:	790b      	ldrb	r3, [r1, #4]
			date_time_changed = date_time_changed|0x04;
   104a8:	f046 0006 	orr.w	r0, r6, #6
			date_time.hour++;
   104ac:	3301      	adds	r3, #1
   104ae:	b2db      	uxtb	r3, r3
			if(date_time.hour > 23)
   104b0:	2b17      	cmp	r3, #23
			date_time.minute = 0;
   104b2:	714a      	strb	r2, [r1, #5]
			date_time.hour++;
   104b4:	710b      	strb	r3, [r1, #4]
			date_time_changed = date_time_changed|0x04;
   104b6:	7028      	strb	r0, [r5, #0]
			if(date_time.hour > 23)
   104b8:	d936      	bls.n	10528 <UpdateSystemTime+0xd4>
				date_time.week++;
   104ba:	79cb      	ldrb	r3, [r1, #7]
				date_time.day++;
   104bc:	f891 9003 	ldrb.w	r9, [r1, #3]
				date_time.week++;
   104c0:	3301      	adds	r3, #1
   104c2:	b2db      	uxtb	r3, r3
				if(date_time.month == 1 \
   104c4:	788c      	ldrb	r4, [r1, #2]
				if(date_time.week > 6)
   104c6:	2b06      	cmp	r3, #6
				date_time.day++;
   104c8:	f109 0901 	add.w	r9, r9, #1
				date_time.week++;
   104cc:	bf98      	it	ls
   104ce:	71cb      	strbls	r3, [r1, #7]
				date_time.day++;
   104d0:	fa5f f989 	uxtb.w	r9, r9
					date_time.week = 0;
   104d4:	bf88      	it	hi
   104d6:	71ca      	strbhi	r2, [r1, #7]
				date_time_changed = date_time_changed|0x08;
   104d8:	f046 030e 	orr.w	r3, r6, #14
				if(date_time.month == 1 \
   104dc:	2c0c      	cmp	r4, #12
				date_time.hour = 0;
   104de:	710a      	strb	r2, [r1, #4]
				date_time.day++;
   104e0:	f881 9003 	strb.w	r9, [r1, #3]
				date_time_changed = date_time_changed|0x08;
   104e4:	702b      	strb	r3, [r5, #0]
				if(date_time.month == 1 \
   104e6:	d804      	bhi.n	104f2 <UpdateSystemTime+0x9e>
   104e8:	f241 53aa 	movw	r3, #5546	; 0x15aa
   104ec:	40e3      	lsrs	r3, r4
   104ee:	07db      	lsls	r3, r3, #31
   104f0:	d42b      	bmi.n	1054a <UpdateSystemTime+0xf6>
				else if(date_time.month == 4 \
   104f2:	f004 03fd 	and.w	r3, r4, #253	; 0xfd
   104f6:	2b04      	cmp	r3, #4
   104f8:	d13c      	bne.n	10574 <UpdateSystemTime+0x120>
					if(date_time.day > 30)
   104fa:	f1b9 0f1e 	cmp.w	r9, #30
   104fe:	d909      	bls.n	10514 <UpdateSystemTime+0xc0>
						date_time.day = 1;
   10500:	2301      	movs	r3, #1
						date_time.month++;
   10502:	441c      	add	r4, r3
   10504:	b2e4      	uxtb	r4, r4
						date_time_changed = date_time_changed|0x10;
   10506:	f046 021e 	orr.w	r2, r6, #30
						if(date_time.month > 12)
   1050a:	2c0c      	cmp	r4, #12
						date_time.day = 1;
   1050c:	70cb      	strb	r3, [r1, #3]
						date_time.month++;
   1050e:	708c      	strb	r4, [r1, #2]
						date_time_changed = date_time_changed|0x10;
   10510:	702a      	strb	r2, [r5, #0]
						if(date_time.month > 12)
   10512:	d827      	bhi.n	10564 <UpdateSystemTime+0x110>
				update_date_time = true;
   10514:	2201      	movs	r2, #1
   10516:	4b2f      	ldr	r3, [pc, #188]	; (105d4 <UpdateSystemTime+0x180>)
				if(screen_id == SCREEN_ID_IDLE)
   10518:	4297      	cmp	r7, r2
				update_date_time = true;
   1051a:	701a      	strb	r2, [r3, #0]
					scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);
   1051c:	bf01      	itttt	eq
   1051e:	4a2c      	ldreq	r2, [pc, #176]	; (105d0 <UpdateSystemTime+0x17c>)
   10520:	68d3      	ldreq	r3, [r2, #12]
   10522:	f043 0318 	orreq.w	r3, r3, #24
   10526:	60d3      	streq	r3, [r2, #12]
	date_time_changed = date_time_changed|0x01;
   10528:	782b      	ldrb	r3, [r5, #0]
	if((date_time_changed&0x02) != 0)
   1052a:	0798      	lsls	r0, r3, #30
   1052c:	d43e      	bmi.n	105ac <UpdateSystemTime+0x158>
	date_time_changed = date_time_changed|0x01;
   1052e:	f043 0301 	orr.w	r3, r3, #1
   10532:	702b      	strb	r3, [r5, #0]
	if((date_time_changed&0x08) != 0)
   10534:	782b      	ldrb	r3, [r5, #0]
   10536:	071a      	lsls	r2, r3, #28
   10538:	d505      	bpl.n	10546 <UpdateSystemTime+0xf2>
		reset_steps = true;
   1053a:	2201      	movs	r2, #1
		date_time_changed = date_time_changed&0xF7;
   1053c:	f023 0308 	bic.w	r3, r3, #8
   10540:	702b      	strb	r3, [r5, #0]
		reset_steps = true;
   10542:	4b25      	ldr	r3, [pc, #148]	; (105d8 <UpdateSystemTime+0x184>)
   10544:	701a      	strb	r2, [r3, #0]
}
   10546:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					if(date_time.day > 31)
   1054a:	f1b9 0f1f 	cmp.w	r9, #31
   1054e:	d9e1      	bls.n	10514 <UpdateSystemTime+0xc0>
						date_time.day = 1;
   10550:	2301      	movs	r3, #1
						date_time.month++;
   10552:	441c      	add	r4, r3
   10554:	b2e4      	uxtb	r4, r4
						date_time_changed = date_time_changed|0x10;
   10556:	f046 021e 	orr.w	r2, r6, #30
						if(date_time.month > 12)
   1055a:	2c0d      	cmp	r4, #13
						date_time.day = 1;
   1055c:	70cb      	strb	r3, [r1, #3]
						date_time.month++;
   1055e:	708c      	strb	r4, [r1, #2]
						date_time_changed = date_time_changed|0x10;
   10560:	702a      	strb	r2, [r5, #0]
						if(date_time.month > 12)
   10562:	d1d7      	bne.n	10514 <UpdateSystemTime+0xc0>
							date_time.month = 1;
   10564:	708b      	strb	r3, [r1, #2]
							date_time.year++;
   10566:	880b      	ldrh	r3, [r1, #0]
   10568:	3301      	adds	r3, #1
   1056a:	800b      	strh	r3, [r1, #0]
							date_time_changed = date_time_changed|0x20;
   1056c:	f046 033e 	orr.w	r3, r6, #62	; 0x3e
   10570:	702b      	strb	r3, [r5, #0]
   10572:	e7cf      	b.n	10514 <UpdateSystemTime+0xc0>
					|| date_time.month == 9 \
   10574:	2b09      	cmp	r3, #9
   10576:	d0c0      	beq.n	104fa <UpdateSystemTime+0xa6>
					if(CheckYearIsLeap(date_time.year))
   10578:	f8b1 8000 	ldrh.w	r8, [r1]
   1057c:	4640      	mov	r0, r8
   1057e:	f01a ff4b 	bl	2b418 <CheckYearIsLeap>
					if(date_time.day > (28+Leap))
   10582:	2800      	cmp	r0, #0
   10584:	bf14      	ite	ne
   10586:	231d      	movne	r3, #29
   10588:	231c      	moveq	r3, #28
   1058a:	4599      	cmp	r9, r3
   1058c:	ddc2      	ble.n	10514 <UpdateSystemTime+0xc0>
						date_time.day = 1;
   1058e:	2301      	movs	r3, #1
						date_time.month++;
   10590:	441c      	add	r4, r3
   10592:	b2e4      	uxtb	r4, r4
						date_time_changed = date_time_changed|0x10;
   10594:	f046 021e 	orr.w	r2, r6, #30
						if(date_time.month > 12)
   10598:	2c0c      	cmp	r4, #12
						date_time.day = 1;
   1059a:	70cb      	strb	r3, [r1, #3]
						date_time.month++;
   1059c:	708c      	strb	r4, [r1, #2]
						date_time_changed = date_time_changed|0x10;
   1059e:	702a      	strb	r2, [r5, #0]
						if(date_time.month > 12)
   105a0:	d9b8      	bls.n	10514 <UpdateSystemTime+0xc0>
							date_time.year++;
   105a2:	4498      	add	r8, r3
							date_time.month = 1;
   105a4:	708b      	strb	r3, [r1, #2]
							date_time.year++;
   105a6:	f8a1 8000 	strh.w	r8, [r1]
   105aa:	e7df      	b.n	1056c <UpdateSystemTime+0x118>
		date_time_changed = date_time_changed&0xFD;
   105ac:	f023 0302 	bic.w	r3, r3, #2
   105b0:	f043 0301 	orr.w	r3, r3, #1
		AlarmRemindCheck(date_time);
   105b4:	6808      	ldr	r0, [r1, #0]
   105b6:	6849      	ldr	r1, [r1, #4]
		date_time_changed = date_time_changed&0xFD;
   105b8:	702b      	strb	r3, [r5, #0]
		AlarmRemindCheck(date_time);
   105ba:	f000 f9f5 	bl	109a8 <AlarmRemindCheck>
   105be:	e7b9      	b.n	10534 <UpdateSystemTime+0xe0>
   105c0:	2002d410 	.word	0x2002d410
   105c4:	2002d418 	.word	0x2002d418
   105c8:	2002d492 	.word	0x2002d492
   105cc:	2002ff93 	.word	0x2002ff93
   105d0:	20028540 	.word	0x20028540
   105d4:	2002d494 	.word	0x2002d494
   105d8:	2002ff3a 	.word	0x2002ff3a

000105dc <StartSystemDateTime>:

void StartSystemDateTime(void)
{
   105dc:	b510      	push	{r4, lr}
	k_timer_init(&clock_timer, clock_timer_handler, NULL);
   105de:	4c07      	ldr	r4, [pc, #28]	; (105fc <StartSystemDateTime+0x20>)
   105e0:	2200      	movs	r2, #0
   105e2:	4907      	ldr	r1, [pc, #28]	; (10600 <StartSystemDateTime+0x24>)
   105e4:	4620      	mov	r0, r4
   105e6:	f01e fe06 	bl	2f1f6 <k_timer_init>
   105ea:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   105ee:	4620      	mov	r0, r4
	k_timer_start(&clock_timer, K_MSEC(1000), K_MSEC(1000));
}
   105f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   105f4:	4611      	mov	r1, r2
   105f6:	f018 be25 	b.w	29244 <z_impl_k_timer_start>
   105fa:	bf00      	nop
   105fc:	20020ae8 	.word	0x20020ae8
   10600:	000101cd 	.word	0x000101cd

00010604 <GetSystemTimeSecStrings>:
	
	return ret;
}

void GetSystemTimeSecStrings(u8_t *str_utc)
{
   10604:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u32_t i;
	u32_t total_sec,total_day=0;

	LOG_INF("[%s] %04d/%02d/%02d %02d:%02d:%02d\n", __func__, date_time.year,date_time.month,date_time.day,date_time.hour,date_time.minute,date_time.second);
   10608:	2303      	movs	r3, #3
{
   1060a:	4606      	mov	r6, r0
	LOG_INF("[%s] %04d/%02d/%02d %02d:%02d:%02d\n", __func__, date_time.year,date_time.month,date_time.day,date_time.hour,date_time.minute,date_time.second);
   1060c:	f04f 0000 	mov.w	r0, #0
   10610:	4c39      	ldr	r4, [pc, #228]	; (106f8 <GetSystemTimeSecStrings+0xf4>)
   10612:	f363 0007 	bfi	r0, r3, #0, #8
   10616:	4d39      	ldr	r5, [pc, #228]	; (106fc <GetSystemTimeSecStrings+0xf8>)
   10618:	4b39      	ldr	r3, [pc, #228]	; (10700 <GetSystemTimeSecStrings+0xfc>)
{
   1061a:	b087      	sub	sp, #28
	LOG_INF("[%s] %04d/%02d/%02d %02d:%02d:%02d\n", __func__, date_time.year,date_time.month,date_time.day,date_time.hour,date_time.minute,date_time.second);
   1061c:	1aed      	subs	r5, r5, r3
   1061e:	79a3      	ldrb	r3, [r4, #6]
   10620:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   10624:	9304      	str	r3, [sp, #16]
   10626:	7963      	ldrb	r3, [r4, #5]
   10628:	f365 108f 	bfi	r0, r5, #6, #10
   1062c:	9303      	str	r3, [sp, #12]
   1062e:	7923      	ldrb	r3, [r4, #4]
   10630:	4a34      	ldr	r2, [pc, #208]	; (10704 <GetSystemTimeSecStrings+0x100>)
   10632:	9302      	str	r3, [sp, #8]
   10634:	78e3      	ldrb	r3, [r4, #3]
   10636:	4934      	ldr	r1, [pc, #208]	; (10708 <GetSystemTimeSecStrings+0x104>)
   10638:	9301      	str	r3, [sp, #4]
   1063a:	78a3      	ldrb	r3, [r4, #2]
   1063c:	9300      	str	r3, [sp, #0]
   1063e:	8823      	ldrh	r3, [r4, #0]
   10640:	f01c fe5a 	bl	2d2f8 <log_string_sync>

	if(date_time.year >= SEC_START_YEAR)
   10644:	f240 73b1 	movw	r3, #1969	; 0x7b1
   10648:	f8b4 8000 	ldrh.w	r8, [r4]
   1064c:	4598      	cmp	r8, r3
   1064e:	d950      	bls.n	106f2 <GetSystemTimeSecStrings+0xee>
	{
		total_day += (date_time.day-1);

		for(i=1;i<date_time.month;i++)
   10650:	2701      	movs	r7, #1
   10652:	f241 5baa 	movw	fp, #5546	; 0x15aa
   10656:	46ba      	mov	sl, r7
		total_day += (date_time.day-1);
   10658:	78e1      	ldrb	r1, [r4, #3]
		for(i=1;i<date_time.month;i++)
   1065a:	f894 9002 	ldrb.w	r9, [r4, #2]
		total_day += (date_time.day-1);
   1065e:	3901      	subs	r1, #1
		for(i=1;i<date_time.month;i++)
   10660:	454f      	cmp	r7, r9
   10662:	d326      	bcc.n	106b2 <GetSystemTimeSecStrings+0xae>
				total_day += 30;
				break;
			}
		}
		
		for(i=SEC_START_YEAR;i<date_time.year;i++)
   10664:	f240 77b2 	movw	r7, #1970	; 0x7b2
   10668:	45b8      	cmp	r8, r7
   1066a:	d83a      	bhi.n	106e2 <GetSystemTimeSecStrings+0xde>
		{
			total_day += (365+(CheckYearIsLeap(i)));
		}

		total_sec = total_day*SEC_PER_DAY+date_time.hour*SEC_PER_HOUR+date_time.minute*SEC_PER_MINUTE+date_time.second;
   1066c:	f44f 6061 	mov.w	r0, #3600	; 0xe10
   10670:	7963      	ldrb	r3, [r4, #5]
   10672:	7922      	ldrb	r2, [r4, #4]
   10674:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
   10678:	009b      	lsls	r3, r3, #2
   1067a:	fb00 3302 	mla	r3, r0, r2, r3
   1067e:	79a2      	ldrb	r2, [r4, #6]
   10680:	4c22      	ldr	r4, [pc, #136]	; (1070c <GetSystemTimeSecStrings+0x108>)
   10682:	4413      	add	r3, r2
   10684:	fb04 3401 	mla	r4, r4, r1, r3
		LOG_INF("[%s] total_day:%d, total_sec:%d\n", __func__, total_day, total_sec);
   10688:	f04f 0000 	mov.w	r0, #0
   1068c:	2303      	movs	r3, #3
   1068e:	f363 0007 	bfi	r0, r3, #0, #8
   10692:	f365 108f 	bfi	r0, r5, #6, #10
   10696:	460b      	mov	r3, r1
   10698:	9400      	str	r4, [sp, #0]
   1069a:	4a1a      	ldr	r2, [pc, #104]	; (10704 <GetSystemTimeSecStrings+0x100>)
   1069c:	491c      	ldr	r1, [pc, #112]	; (10710 <GetSystemTimeSecStrings+0x10c>)
   1069e:	f01c fe2b 	bl	2d2f8 <log_string_sync>

		sprintf(str_utc, "%d", total_sec);
   106a2:	4622      	mov	r2, r4
   106a4:	4630      	mov	r0, r6
   106a6:	491b      	ldr	r1, [pc, #108]	; (10714 <GetSystemTimeSecStrings+0x110>)
	}
}
   106a8:	b007      	add	sp, #28
   106aa:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		sprintf(str_utc, "%d", total_sec);
   106ae:	f01a b80d 	b.w	2a6cc <siprintf>
			switch(i)
   106b2:	2f0c      	cmp	r7, #12
   106b4:	d809      	bhi.n	106ca <GetSystemTimeSecStrings+0xc6>
   106b6:	fa0a f307 	lsl.w	r3, sl, r7
   106ba:	ea13 0f0b 	tst.w	r3, fp
   106be:	d106      	bne.n	106ce <GetSystemTimeSecStrings+0xca>
   106c0:	f413 6f25 	tst.w	r3, #2640	; 0xa50
   106c4:	d10b      	bne.n	106de <GetSystemTimeSecStrings+0xda>
   106c6:	075b      	lsls	r3, r3, #29
   106c8:	d403      	bmi.n	106d2 <GetSystemTimeSecStrings+0xce>
		for(i=1;i<date_time.month;i++)
   106ca:	3701      	adds	r7, #1
   106cc:	e7c8      	b.n	10660 <GetSystemTimeSecStrings+0x5c>
				total_day += 31;
   106ce:	311f      	adds	r1, #31
				break;
   106d0:	e7fb      	b.n	106ca <GetSystemTimeSecStrings+0xc6>
				total_day += (28+(CheckYearIsLeap(date_time.year)));
   106d2:	4640      	mov	r0, r8
   106d4:	f01a fea0 	bl	2b418 <CheckYearIsLeap>
   106d8:	301c      	adds	r0, #28
   106da:	4401      	add	r1, r0
				break;
   106dc:	e7f5      	b.n	106ca <GetSystemTimeSecStrings+0xc6>
				total_day += 30;
   106de:	311e      	adds	r1, #30
				break;
   106e0:	e7f3      	b.n	106ca <GetSystemTimeSecStrings+0xc6>
			total_day += (365+(CheckYearIsLeap(i)));
   106e2:	4638      	mov	r0, r7
   106e4:	f01a fe98 	bl	2b418 <CheckYearIsLeap>
   106e8:	f200 106d 	addw	r0, r0, #365	; 0x16d
   106ec:	4401      	add	r1, r0
		for(i=SEC_START_YEAR;i<date_time.year;i++)
   106ee:	3701      	adds	r7, #1
   106f0:	e7ba      	b.n	10668 <GetSystemTimeSecStrings+0x64>
}
   106f2:	b007      	add	sp, #28
   106f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   106f8:	2002d410 	.word	0x2002d410
   106fc:	0003044c 	.word	0x0003044c
   10700:	0003040c 	.word	0x0003040c
   10704:	0003103c 	.word	0x0003103c
   10708:	00030f8b 	.word	0x00030f8b
   1070c:	00015180 	.word	0x00015180
   10710:	00030faf 	.word	0x00030faf
   10714:	00033e5f 	.word	0x00033e5f

00010718 <GetSystemDateStrings>:

void GetSystemDateStrings(u8_t *str_date)
{
	u8_t tmpbuf[128] = {0};
	
	switch(global_settings.date_format)
   10718:	4b10      	ldr	r3, [pc, #64]	; (1075c <GetSystemDateStrings+0x44>)
{
   1071a:	b507      	push	{r0, r1, r2, lr}
	switch(global_settings.date_format)
   1071c:	7a9b      	ldrb	r3, [r3, #10]
   1071e:	2b01      	cmp	r3, #1
   10720:	d00e      	beq.n	10740 <GetSystemDateStrings+0x28>
   10722:	b123      	cbz	r3, 1072e <GetSystemDateStrings+0x16>
   10724:	2b02      	cmp	r3, #2
   10726:	d012      	beq.n	1074e <GetSystemDateStrings+0x36>

#ifdef FONTMAKER_UNICODE_FONT
	strcpy(tmpbuf, str_date);
	mmi_asc_to_ucs2(str_date, tmpbuf);
#endif
}
   10728:	b003      	add	sp, #12
   1072a:	f85d fb04 	ldr.w	pc, [sp], #4
		sprintf((char*)str_date, "%04d/%02d/%02d", date_time.year, date_time.month, date_time.day);
   1072e:	4a0c      	ldr	r2, [pc, #48]	; (10760 <GetSystemDateStrings+0x48>)
   10730:	490c      	ldr	r1, [pc, #48]	; (10764 <GetSystemDateStrings+0x4c>)
   10732:	78d3      	ldrb	r3, [r2, #3]
   10734:	9300      	str	r3, [sp, #0]
   10736:	7893      	ldrb	r3, [r2, #2]
   10738:	8812      	ldrh	r2, [r2, #0]
		sprintf((char*)str_date, "%02d/%02d/%04d", date_time.day, date_time.month, date_time.year);
   1073a:	f019 ffc7 	bl	2a6cc <siprintf>
}
   1073e:	e7f3      	b.n	10728 <GetSystemDateStrings+0x10>
		sprintf((char*)str_date, "%02d/%02d/%04d", date_time.month, date_time.day, date_time.year);
   10740:	4a07      	ldr	r2, [pc, #28]	; (10760 <GetSystemDateStrings+0x48>)
   10742:	8813      	ldrh	r3, [r2, #0]
   10744:	9300      	str	r3, [sp, #0]
   10746:	78d3      	ldrb	r3, [r2, #3]
   10748:	7892      	ldrb	r2, [r2, #2]
		sprintf((char*)str_date, "%02d/%02d/%04d", date_time.day, date_time.month, date_time.year);
   1074a:	4907      	ldr	r1, [pc, #28]	; (10768 <GetSystemDateStrings+0x50>)
   1074c:	e7f5      	b.n	1073a <GetSystemDateStrings+0x22>
   1074e:	4a04      	ldr	r2, [pc, #16]	; (10760 <GetSystemDateStrings+0x48>)
   10750:	8813      	ldrh	r3, [r2, #0]
   10752:	9300      	str	r3, [sp, #0]
   10754:	7893      	ldrb	r3, [r2, #2]
   10756:	78d2      	ldrb	r2, [r2, #3]
   10758:	e7f7      	b.n	1074a <GetSystemDateStrings+0x32>
   1075a:	bf00      	nop
   1075c:	2002d422 	.word	0x2002d422
   10760:	2002d410 	.word	0x2002d410
   10764:	00030f6d 	.word	0x00030f6d
   10768:	00030f7c 	.word	0x00030f7c

0001076c <GetSysteAmPmStrings>:

void GetSysteAmPmStrings(u8_t *str_ampm)
{
	u8_t flag = 0;
	u8_t *am_pm[2] = {"am", "pm"};
   1076c:	4b0d      	ldr	r3, [pc, #52]	; (107a4 <GetSysteAmPmStrings+0x38>)
{
   1076e:	b082      	sub	sp, #8
	u8_t *am_pm[2] = {"am", "pm"};
   10770:	9300      	str	r3, [sp, #0]
   10772:	4b0d      	ldr	r3, [pc, #52]	; (107a8 <GetSysteAmPmStrings+0x3c>)
   10774:	9301      	str	r3, [sp, #4]
	u8_t tmpbuf[128] = {0};

	if(date_time.hour > 12)
		flag = 1;
	
	switch(global_settings.time_format)
   10776:	4b0d      	ldr	r3, [pc, #52]	; (107ac <GetSysteAmPmStrings+0x40>)
   10778:	7a1b      	ldrb	r3, [r3, #8]
   1077a:	b11b      	cbz	r3, 10784 <GetSysteAmPmStrings+0x18>
   1077c:	2b01      	cmp	r3, #1
   1077e:	d005      	beq.n	1078c <GetSysteAmPmStrings+0x20>
#ifdef FONTMAKER_UNICODE_FONT
	strcpy(tmpbuf, str_ampm);
	mmi_asc_to_ucs2(str_ampm, tmpbuf);
#endif

}
   10780:	b002      	add	sp, #8
   10782:	4770      	bx	lr
		sprintf((char*)str_ampm, "  ");
   10784:	490a      	ldr	r1, [pc, #40]	; (107b0 <GetSysteAmPmStrings+0x44>)
}
   10786:	b002      	add	sp, #8
		sprintf((char*)str_ampm, "%s", am_pm[flag]);
   10788:	f01e bf85 	b.w	2f696 <strcpy>
	if(date_time.hour > 12)
   1078c:	4b09      	ldr	r3, [pc, #36]	; (107b4 <GetSysteAmPmStrings+0x48>)
		sprintf((char*)str_ampm, "%s", am_pm[flag]);
   1078e:	aa02      	add	r2, sp, #8
	if(date_time.hour > 12)
   10790:	791b      	ldrb	r3, [r3, #4]
   10792:	2b0c      	cmp	r3, #12
   10794:	bf94      	ite	ls
   10796:	2300      	movls	r3, #0
   10798:	2301      	movhi	r3, #1
		sprintf((char*)str_ampm, "%s", am_pm[flag]);
   1079a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   1079e:	f853 1c08 	ldr.w	r1, [r3, #-8]
   107a2:	e7f0      	b.n	10786 <GetSysteAmPmStrings+0x1a>
   107a4:	00031054 	.word	0x00031054
   107a8:	00031057 	.word	0x00031057
   107ac:	2002d422 	.word	0x2002d422
   107b0:	0003141f 	.word	0x0003141f
   107b4:	2002d410 	.word	0x2002d410

000107b8 <GetSystemTimeStrings>:

void GetSystemTimeStrings(u8_t *str_time)
{
	u8_t tmpbuf[128] = {0};
	
	switch(global_settings.time_format)
   107b8:	4b0d      	ldr	r3, [pc, #52]	; (107f0 <GetSystemTimeStrings+0x38>)
{
   107ba:	b513      	push	{r0, r1, r4, lr}
	switch(global_settings.time_format)
   107bc:	7a1b      	ldrb	r3, [r3, #8]
   107be:	b11b      	cbz	r3, 107c8 <GetSystemTimeStrings+0x10>
   107c0:	2b01      	cmp	r3, #1
   107c2:	d00a      	beq.n	107da <GetSystemTimeStrings+0x22>

#ifdef FONTMAKER_UNICODE_FONT
	strcpy(tmpbuf, str_time);
	mmi_asc_to_ucs2(str_time, tmpbuf);
#endif
}
   107c4:	b002      	add	sp, #8
   107c6:	bd10      	pop	{r4, pc}
		sprintf((char*)str_time, "%02d:%02d:%02d", date_time.hour, date_time.minute, date_time.second);
   107c8:	4a0a      	ldr	r2, [pc, #40]	; (107f4 <GetSystemTimeStrings+0x3c>)
   107ca:	490b      	ldr	r1, [pc, #44]	; (107f8 <GetSystemTimeStrings+0x40>)
   107cc:	7993      	ldrb	r3, [r2, #6]
   107ce:	9300      	str	r3, [sp, #0]
   107d0:	7953      	ldrb	r3, [r2, #5]
   107d2:	7912      	ldrb	r2, [r2, #4]
		sprintf((char*)str_time, "%02d:%02d:%02d", (date_time.hour>12 ? (date_time.hour-12):date_time.hour), date_time.minute, date_time.second);
   107d4:	f019 ff7a 	bl	2a6cc <siprintf>
}
   107d8:	e7f4      	b.n	107c4 <GetSystemTimeStrings+0xc>
		sprintf((char*)str_time, "%02d:%02d:%02d", (date_time.hour>12 ? (date_time.hour-12):date_time.hour), date_time.minute, date_time.second);
   107da:	4b06      	ldr	r3, [pc, #24]	; (107f4 <GetSystemTimeStrings+0x3c>)
   107dc:	791a      	ldrb	r2, [r3, #4]
   107de:	7999      	ldrb	r1, [r3, #6]
   107e0:	2a0c      	cmp	r2, #12
   107e2:	9100      	str	r1, [sp, #0]
   107e4:	bf88      	it	hi
   107e6:	3a0c      	subhi	r2, #12
   107e8:	795b      	ldrb	r3, [r3, #5]
   107ea:	4903      	ldr	r1, [pc, #12]	; (107f8 <GetSystemTimeStrings+0x40>)
   107ec:	e7f2      	b.n	107d4 <GetSystemTimeStrings+0x1c>
   107ee:	bf00      	nop
   107f0:	2002d422 	.word	0x2002d422
   107f4:	2002d410 	.word	0x2002d410
   107f8:	00030fd0 	.word	0x00030fd0

000107fc <GetSystemWeekStrings>:

void GetSystemWeekStrings(u8_t *str_week)
{
   107fc:	b570      	push	{r4, r5, r6, lr}
	u8_t *week_en[7] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
   107fe:	4c25      	ldr	r4, [pc, #148]	; (10894 <GetSystemWeekStrings+0x98>)
{
   10800:	b09e      	sub	sp, #120	; 0x78
	u8_t *week_en[7] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
   10802:	ad01      	add	r5, sp, #4
{
   10804:	4606      	mov	r6, r0
	u8_t *week_en[7] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
   10806:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   10808:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   1080a:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
	u8_t *week_chn[7] = {"", "", "", "", "", "", ""};
   1080e:	340c      	adds	r4, #12
	u8_t *week_en[7] = {"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
   10810:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	u8_t *week_chn[7] = {"", "", "", "", "", "", ""};
   10814:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   10816:	ad08      	add	r5, sp, #32
   10818:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   1081a:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
   1081e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	u8_t *week_jpn[15] = {"", "", "", "", "", "", ""};
   10822:	2220      	movs	r2, #32
   10824:	2100      	movs	r1, #0
   10826:	a816      	add	r0, sp, #88	; 0x58
   10828:	f01e fdb4 	bl	2f394 <memset>
   1082c:	4b1a      	ldr	r3, [pc, #104]	; (10898 <GetSystemWeekStrings+0x9c>)
   1082e:	930f      	str	r3, [sp, #60]	; 0x3c
   10830:	4b1a      	ldr	r3, [pc, #104]	; (1089c <GetSystemWeekStrings+0xa0>)
   10832:	9310      	str	r3, [sp, #64]	; 0x40
   10834:	4b1a      	ldr	r3, [pc, #104]	; (108a0 <GetSystemWeekStrings+0xa4>)
   10836:	9311      	str	r3, [sp, #68]	; 0x44
   10838:	4b1a      	ldr	r3, [pc, #104]	; (108a4 <GetSystemWeekStrings+0xa8>)
   1083a:	9312      	str	r3, [sp, #72]	; 0x48
   1083c:	4b1a      	ldr	r3, [pc, #104]	; (108a8 <GetSystemWeekStrings+0xac>)
   1083e:	9313      	str	r3, [sp, #76]	; 0x4c
   10840:	4b1a      	ldr	r3, [pc, #104]	; (108ac <GetSystemWeekStrings+0xb0>)
   10842:	9314      	str	r3, [sp, #80]	; 0x50
   10844:	4b1a      	ldr	r3, [pc, #104]	; (108b0 <GetSystemWeekStrings+0xb4>)
   10846:	9315      	str	r3, [sp, #84]	; 0x54
								{0x304D,0x3093,0x3088,0x3046,0x3073,0x0000},
								{0x3069,0x3088,0x3046,0x3073,0x0000}
							};
#endif

	switch(global_settings.language)
   10848:	4b1a      	ldr	r3, [pc, #104]	; (108b4 <GetSystemWeekStrings+0xb8>)
   1084a:	7a5b      	ldrb	r3, [r3, #9]
   1084c:	2b01      	cmp	r3, #1
   1084e:	d004      	beq.n	1085a <GetSystemWeekStrings+0x5e>
   10850:	b183      	cbz	r3, 10874 <GetSystemWeekStrings+0x78>
   10852:	2b02      	cmp	r3, #2
   10854:	d016      	beq.n	10884 <GetSystemWeekStrings+0x88>
	#else
		strcpy((char*)str_week, (const char*)week_jpn[date_time.week]);
	#endif
		break;
	}
}
   10856:	b01e      	add	sp, #120	; 0x78
   10858:	bd70      	pop	{r4, r5, r6, pc}
		strcpy((char*)str_week, (const char*)week_chn[date_time.week]);
   1085a:	4b17      	ldr	r3, [pc, #92]	; (108b8 <GetSystemWeekStrings+0xbc>)
   1085c:	aa1e      	add	r2, sp, #120	; 0x78
   1085e:	79db      	ldrb	r3, [r3, #7]
   10860:	eb02 0383 	add.w	r3, r2, r3, lsl #2
__ssp_bos_icheck3(memset, void *, int)
__ssp_bos_icheck2_restrict(stpcpy, char *, const char *)
#if __GNUC_PREREQ__(4,8) || defined(__clang__)
__ssp_bos_icheck3_restrict(stpncpy, char *, const char *)
#endif
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
   10864:	f853 1c58 	ldr.w	r1, [r3, #-88]
   10868:	4630      	mov	r0, r6
}
   1086a:	b01e      	add	sp, #120	; 0x78
   1086c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   10870:	f01e bf11 	b.w	2f696 <strcpy>
		strcpy((char*)str_week, (const char*)week_en[date_time.week]);
   10874:	4b10      	ldr	r3, [pc, #64]	; (108b8 <GetSystemWeekStrings+0xbc>)
   10876:	aa1e      	add	r2, sp, #120	; 0x78
   10878:	79db      	ldrb	r3, [r3, #7]
   1087a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   1087e:	f853 1c74 	ldr.w	r1, [r3, #-116]
   10882:	e7f1      	b.n	10868 <GetSystemWeekStrings+0x6c>
		strcpy((char*)str_week, (const char*)week_jpn[date_time.week]);
   10884:	4b0c      	ldr	r3, [pc, #48]	; (108b8 <GetSystemWeekStrings+0xbc>)
   10886:	aa1e      	add	r2, sp, #120	; 0x78
   10888:	79db      	ldrb	r3, [r3, #7]
   1088a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   1088e:	f853 1c3c 	ldr.w	r1, [r3, #-60]
   10892:	e7e9      	b.n	10868 <GetSystemWeekStrings+0x6c>
   10894:	00030560 	.word	0x00030560
   10898:	00030fdf 	.word	0x00030fdf
   1089c:	00030fea 	.word	0x00030fea
   108a0:	00030ff5 	.word	0x00030ff5
   108a4:	00030ffe 	.word	0x00030ffe
   108a8:	00031009 	.word	0x00031009
   108ac:	00031014 	.word	0x00031014
   108b0:	0003101f 	.word	0x0003101f
   108b4:	2002d422 	.word	0x2002d422
   108b8:	2002d410 	.word	0x2002d410

000108bc <TimeMsgProcess>:

void TimeMsgProcess(void)
{
   108bc:	b508      	push	{r3, lr}
	if(sys_time_count)
   108be:	4b07      	ldr	r3, [pc, #28]	; (108dc <TimeMsgProcess+0x20>)
   108c0:	781a      	ldrb	r2, [r3, #0]
   108c2:	b152      	cbz	r2, 108da <TimeMsgProcess+0x1e>
	{
		sys_time_count = false;
   108c4:	2200      	movs	r2, #0
   108c6:	701a      	strb	r2, [r3, #0]
		UpdateSystemTime();
   108c8:	f7ff fdc4 	bl	10454 <UpdateSystemTime>

		if(screen_id == SCREEN_ID_IDLE)
   108cc:	4b04      	ldr	r3, [pc, #16]	; (108e0 <TimeMsgProcess+0x24>)
   108ce:	781b      	ldrb	r3, [r3, #0]
   108d0:	2b01      	cmp	r3, #1
			scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   108d2:	bf02      	ittt	eq
   108d4:	2202      	moveq	r2, #2
   108d6:	4b03      	ldreq	r3, [pc, #12]	; (108e4 <TimeMsgProcess+0x28>)
   108d8:	725a      	strbeq	r2, [r3, #9]
	}
}
   108da:	bd08      	pop	{r3, pc}
   108dc:	2002d493 	.word	0x2002d493
   108e0:	2002ff93 	.word	0x2002ff93
   108e4:	20028540 	.word	0x20028540

000108e8 <AlarmRemindStop>:
extern void VibrateStart(void);
extern void VibrateStop(void);

void AlarmRemindStop(void)
{
	vibrate_stop_flag = true;
   108e8:	2201      	movs	r2, #1
{
   108ea:	b508      	push	{r3, lr}
	vibrate_stop_flag = true;
   108ec:	4b07      	ldr	r3, [pc, #28]	; (1090c <AlarmRemindStop+0x24>)
   108ee:	701a      	strb	r2, [r3, #0]

	alarm_is_running = false;
   108f0:	2300      	movs	r3, #0
   108f2:	4a07      	ldr	r2, [pc, #28]	; (10910 <AlarmRemindStop+0x28>)
   108f4:	7013      	strb	r3, [r2, #0]
	vibrating = false;
   108f6:	4a07      	ldr	r2, [pc, #28]	; (10914 <AlarmRemindStop+0x2c>)
   108f8:	7013      	strb	r3, [r2, #0]
	count = 0;
   108fa:	4a07      	ldr	r2, [pc, #28]	; (10918 <AlarmRemindStop+0x30>)
   108fc:	7013      	strb	r3, [r2, #0]
		arch_syscall_invoke1(*(uintptr_t *)&timer, K_SYSCALL_K_TIMER_STOP);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_timer_stop(timer);
   108fe:	4807      	ldr	r0, [pc, #28]	; (1091c <AlarmRemindStop+0x34>)
   10900:	f01e fc85 	bl	2f20e <z_impl_k_timer_stop>

	k_timer_stop(&alarm_timer);

	GoBackHistoryScreen();
}
   10904:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	GoBackHistoryScreen();
   10908:	f005 bd0c 	b.w	16324 <GoBackHistoryScreen>
   1090c:	2002ff9d 	.word	0x2002ff9d
   10910:	2002d495 	.word	0x2002d495
   10914:	2002d499 	.word	0x2002d499
   10918:	2002d497 	.word	0x2002d497
   1091c:	20020b14 	.word	0x20020b14

00010920 <AlarmRemindTimeout>:

void AlarmRemindTimeout(struct k_timer *timer)
{
	if(vibrating)
   10920:	4b0d      	ldr	r3, [pc, #52]	; (10958 <AlarmRemindTimeout+0x38>)
   10922:	2101      	movs	r1, #1
   10924:	781a      	ldrb	r2, [r3, #0]
   10926:	b182      	cbz	r2, 1094a <AlarmRemindTimeout+0x2a>
	{
		vibrate_stop_flag = true;
   10928:	4a0c      	ldr	r2, [pc, #48]	; (1095c <AlarmRemindTimeout+0x3c>)
   1092a:	7011      	strb	r1, [r2, #0]
		vibrating = false;
   1092c:	2200      	movs	r2, #0

		count--;
   1092e:	490c      	ldr	r1, [pc, #48]	; (10960 <AlarmRemindTimeout+0x40>)
		vibrating = false;
   10930:	701a      	strb	r2, [r3, #0]
		count--;
   10932:	780b      	ldrb	r3, [r1, #0]
   10934:	3b01      	subs	r3, #1
   10936:	b2db      	uxtb	r3, r3
   10938:	700b      	strb	r3, [r1, #0]
		if(count>0)
   1093a:	b123      	cbz	r3, 10946 <AlarmRemindTimeout+0x26>
	z_impl_k_timer_start(timer, duration, period);
   1093c:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
   10940:	4808      	ldr	r0, [pc, #32]	; (10964 <AlarmRemindTimeout+0x44>)
   10942:	f018 bc7f 	b.w	29244 <z_impl_k_timer_start>
		{
			k_timer_start(&alarm_timer, K_MSEC(ALARM_VIB_OFF_SEC), NULL);
		}
		else
		{
			AlarmRemindStop();
   10946:	f7ff bfcf 	b.w	108e8 <AlarmRemindStop>
		}
	}
	else
	{
		vibrate_start_flag = true;
   1094a:	4807      	ldr	r0, [pc, #28]	; (10968 <AlarmRemindTimeout+0x48>)
		vibrating = true;
   1094c:	7019      	strb	r1, [r3, #0]
		vibrate_start_flag = true;
   1094e:	7001      	strb	r1, [r0, #0]
   10950:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   10954:	e7f4      	b.n	10940 <AlarmRemindTimeout+0x20>
   10956:	bf00      	nop
   10958:	2002d499 	.word	0x2002d499
   1095c:	2002ff9d 	.word	0x2002ff9d
   10960:	2002d497 	.word	0x2002d497
   10964:	20020b14 	.word	0x20020b14
   10968:	2002ff9c 	.word	0x2002ff9c

0001096c <AlarmRemindStart>:
	}
}

void AlarmRemindStart(void)
{
	lcd_sleep_out = true;
   1096c:	2301      	movs	r3, #1
	alarm_is_running = true;
	
	count = ALARM_VIB_REPEAT_MAX;
   1096e:	2105      	movs	r1, #5
	lcd_sleep_out = true;
   10970:	4a07      	ldr	r2, [pc, #28]	; (10990 <AlarmRemindStart+0x24>)
   10972:	7013      	strb	r3, [r2, #0]
	alarm_is_running = true;
   10974:	4a07      	ldr	r2, [pc, #28]	; (10994 <AlarmRemindStart+0x28>)
   10976:	7013      	strb	r3, [r2, #0]
	count = ALARM_VIB_REPEAT_MAX;
   10978:	4a07      	ldr	r2, [pc, #28]	; (10998 <AlarmRemindStart+0x2c>)
   1097a:	7011      	strb	r1, [r2, #0]
	vibrating = true;
   1097c:	4a07      	ldr	r2, [pc, #28]	; (1099c <AlarmRemindStart+0x30>)
   1097e:	7013      	strb	r3, [r2, #0]

	vibrate_start_flag = true;
   10980:	4a07      	ldr	r2, [pc, #28]	; (109a0 <AlarmRemindStart+0x34>)
   10982:	7013      	strb	r3, [r2, #0]
   10984:	2200      	movs	r2, #0
   10986:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   1098a:	4806      	ldr	r0, [pc, #24]	; (109a4 <AlarmRemindStart+0x38>)
   1098c:	f018 bc5a 	b.w	29244 <z_impl_k_timer_start>
   10990:	2002d49b 	.word	0x2002d49b
   10994:	2002d495 	.word	0x2002d495
   10998:	2002d497 	.word	0x2002d497
   1099c:	2002d499 	.word	0x2002d499
   109a0:	2002ff9c 	.word	0x2002ff9c
   109a4:	20020b14 	.word	0x20020b14

000109a8 <AlarmRemindCheck>:

	k_timer_start(&alarm_timer, K_MSEC(ALARM_VIB_ON_SEC), NULL);
}

void AlarmRemindCheck(sys_date_timer_t time)
{
   109a8:	b4f3      	push	{r0, r1, r4, r5, r6, r7}
   109aa:	ab02      	add	r3, sp, #8
   109ac:	e903 0003 	stmdb	r3, {r0, r1}
   109b0:	4b17      	ldr	r3, [pc, #92]	; (10a10 <AlarmRemindCheck+0x68>)
	{
		if((global_settings.alarm[i].is_on)
			&&(global_settings.alarm[i].hour == time.hour)
			&&(global_settings.alarm[i].minute == time.minute))
		{
			switch(time.week)
   109b2:	2200      	movs	r2, #0
   109b4:	4618      	mov	r0, r3
			&&(global_settings.alarm[i].hour == time.hour)
   109b6:	f89d 4004 	ldrb.w	r4, [sp, #4]
			&&(global_settings.alarm[i].minute == time.minute))
   109ba:	f89d 5005 	ldrb.w	r5, [sp, #5]
			switch(time.week)
   109be:	f89d 6007 	ldrb.w	r6, [sp, #7]
		if((global_settings.alarm[i].is_on)
   109c2:	7c19      	ldrb	r1, [r3, #16]
   109c4:	b1c1      	cbz	r1, 109f8 <AlarmRemindCheck+0x50>
			&&(global_settings.alarm[i].hour == time.hour)
   109c6:	7c59      	ldrb	r1, [r3, #17]
   109c8:	42a1      	cmp	r1, r4
   109ca:	d115      	bne.n	109f8 <AlarmRemindCheck+0x50>
			&&(global_settings.alarm[i].minute == time.minute))
   109cc:	7c99      	ldrb	r1, [r3, #18]
   109ce:	42a9      	cmp	r1, r5
   109d0:	d112      	bne.n	109f8 <AlarmRemindCheck+0x50>
			switch(time.week)
   109d2:	2e06      	cmp	r6, #6
   109d4:	7cd9      	ldrb	r1, [r3, #19]
   109d6:	d817      	bhi.n	10a08 <AlarmRemindCheck+0x60>
				{
					flag = true;
				}
				break;
			case 6://Saturday
				if(global_settings.alarm[i].repeat&0x02 != 0)
   109d8:	f001 0701 	and.w	r7, r1, #1
				break;
			default:
				break;
			}
			
			if(global_settings.alarm[i].repeat == 0)
   109dc:	b951      	cbnz	r1, 109f4 <AlarmRemindCheck+0x4c>
			{
				flag = true;
				global_settings.alarm[i].is_on = false;
   109de:	2300      	movs	r3, #0
   109e0:	3204      	adds	r2, #4
   109e2:	f800 3022 	strb.w	r3, [r0, r2, lsl #2]
				need_save_settings = true;
   109e6:	2201      	movs	r2, #1
   109e8:	4b0a      	ldr	r3, [pc, #40]	; (10a14 <AlarmRemindCheck+0x6c>)
   109ea:	701a      	strb	r2, [r3, #0]
				AlarmRemindEntryScreen();
				break;
			}
		}
	}
}
   109ec:	b002      	add	sp, #8
   109ee:	bcf0      	pop	{r4, r5, r6, r7}
				AlarmRemindEntryScreen();
   109f0:	f01a bdd1 	b.w	2b596 <AlarmRemindEntryScreen>
			if(flag)
   109f4:	2f00      	cmp	r7, #0
   109f6:	d1f9      	bne.n	109ec <AlarmRemindCheck+0x44>
   109f8:	3201      	adds	r2, #1
	for(i=0;i<ALARM_MAX;i++)
   109fa:	2a08      	cmp	r2, #8
   109fc:	f103 0304 	add.w	r3, r3, #4
   10a00:	d1df      	bne.n	109c2 <AlarmRemindCheck+0x1a>
}
   10a02:	b002      	add	sp, #8
   10a04:	bcf0      	pop	{r4, r5, r6, r7}
   10a06:	4770      	bx	lr
			if(global_settings.alarm[i].repeat == 0)
   10a08:	2900      	cmp	r1, #0
   10a0a:	d1f5      	bne.n	109f8 <AlarmRemindCheck+0x50>
   10a0c:	e7e7      	b.n	109de <AlarmRemindCheck+0x36>
   10a0e:	bf00      	nop
   10a10:	2002d422 	.word	0x2002d422
   10a14:	2002f49f 	.word	0x2002f49f

00010a18 <FindDeviceStop>:
	AlarmRemindStart();
}

void FindDeviceStop(void)
{
	vibrate_stop_flag = true;
   10a18:	2201      	movs	r2, #1
{
   10a1a:	b508      	push	{r3, lr}
	vibrate_stop_flag = true;
   10a1c:	4b07      	ldr	r3, [pc, #28]	; (10a3c <FindDeviceStop+0x24>)
   10a1e:	701a      	strb	r2, [r3, #0]

	find_is_running = false;
   10a20:	2300      	movs	r3, #0
   10a22:	4a07      	ldr	r2, [pc, #28]	; (10a40 <FindDeviceStop+0x28>)
   10a24:	7013      	strb	r3, [r2, #0]
	vibrating = false;
   10a26:	4a07      	ldr	r2, [pc, #28]	; (10a44 <FindDeviceStop+0x2c>)
   10a28:	7013      	strb	r3, [r2, #0]
	count = 0;
   10a2a:	4a07      	ldr	r2, [pc, #28]	; (10a48 <FindDeviceStop+0x30>)
   10a2c:	7013      	strb	r3, [r2, #0]
	z_impl_k_timer_stop(timer);
   10a2e:	4807      	ldr	r0, [pc, #28]	; (10a4c <FindDeviceStop+0x34>)
   10a30:	f01e fbed 	bl	2f20e <z_impl_k_timer_stop>

	k_timer_stop(&find_timer);

	GoBackHistoryScreen();
}
   10a34:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	GoBackHistoryScreen();
   10a38:	f005 bc74 	b.w	16324 <GoBackHistoryScreen>
   10a3c:	2002ff9d 	.word	0x2002ff9d
   10a40:	2002d498 	.word	0x2002d498
   10a44:	2002d499 	.word	0x2002d499
   10a48:	2002d497 	.word	0x2002d497
   10a4c:	20020b40 	.word	0x20020b40

00010a50 <FindDeviceTimeout>:

void FindDeviceTimeout(struct k_timer *timer)
{
	if(vibrating)
   10a50:	4b0d      	ldr	r3, [pc, #52]	; (10a88 <FindDeviceTimeout+0x38>)
   10a52:	2101      	movs	r1, #1
   10a54:	781a      	ldrb	r2, [r3, #0]
   10a56:	b182      	cbz	r2, 10a7a <FindDeviceTimeout+0x2a>
	{
		vibrate_stop_flag = true;
   10a58:	4a0c      	ldr	r2, [pc, #48]	; (10a8c <FindDeviceTimeout+0x3c>)
   10a5a:	7011      	strb	r1, [r2, #0]
		vibrating = false;
   10a5c:	2200      	movs	r2, #0

		count--;
   10a5e:	490c      	ldr	r1, [pc, #48]	; (10a90 <FindDeviceTimeout+0x40>)
		vibrating = false;
   10a60:	701a      	strb	r2, [r3, #0]
		count--;
   10a62:	780b      	ldrb	r3, [r1, #0]
   10a64:	3b01      	subs	r3, #1
   10a66:	b2db      	uxtb	r3, r3
   10a68:	700b      	strb	r3, [r1, #0]
		if(count>0)
   10a6a:	b123      	cbz	r3, 10a76 <FindDeviceTimeout+0x26>
	z_impl_k_timer_start(timer, duration, period);
   10a6c:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
   10a70:	4808      	ldr	r0, [pc, #32]	; (10a94 <FindDeviceTimeout+0x44>)
   10a72:	f018 bbe7 	b.w	29244 <z_impl_k_timer_start>
		{
			k_timer_start(&find_timer, K_MSEC(FIND_VIB_OFF_SEC), NULL);
		}
		else
		{
			FindDeviceStop();
   10a76:	f7ff bfcf 	b.w	10a18 <FindDeviceStop>
		}
	}
	else
	{
		vibrate_start_flag = true;
   10a7a:	4807      	ldr	r0, [pc, #28]	; (10a98 <FindDeviceTimeout+0x48>)
		vibrating = true;
   10a7c:	7019      	strb	r1, [r3, #0]
		vibrate_start_flag = true;
   10a7e:	7001      	strb	r1, [r0, #0]
   10a80:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   10a84:	e7f4      	b.n	10a70 <FindDeviceTimeout+0x20>
   10a86:	bf00      	nop
   10a88:	2002d499 	.word	0x2002d499
   10a8c:	2002ff9d 	.word	0x2002ff9d
   10a90:	2002d497 	.word	0x2002d497
   10a94:	20020b40 	.word	0x20020b40
   10a98:	2002ff9c 	.word	0x2002ff9c

00010a9c <FindDeviceStart>:
	}
}

void FindDeviceStart(void)
{
	lcd_sleep_out = true;
   10a9c:	2301      	movs	r3, #1
	find_is_running = true;
	
	count = FIND_VIN_REPEAT_MAX;
   10a9e:	210a      	movs	r1, #10
	lcd_sleep_out = true;
   10aa0:	4a07      	ldr	r2, [pc, #28]	; (10ac0 <FindDeviceStart+0x24>)
   10aa2:	7013      	strb	r3, [r2, #0]
	find_is_running = true;
   10aa4:	4a07      	ldr	r2, [pc, #28]	; (10ac4 <FindDeviceStart+0x28>)
   10aa6:	7013      	strb	r3, [r2, #0]
	count = FIND_VIN_REPEAT_MAX;
   10aa8:	4a07      	ldr	r2, [pc, #28]	; (10ac8 <FindDeviceStart+0x2c>)
   10aaa:	7011      	strb	r1, [r2, #0]
	vibrating = true;
   10aac:	4a07      	ldr	r2, [pc, #28]	; (10acc <FindDeviceStart+0x30>)
   10aae:	7013      	strb	r3, [r2, #0]

	vibrate_start_flag = true;
   10ab0:	4a07      	ldr	r2, [pc, #28]	; (10ad0 <FindDeviceStart+0x34>)
   10ab2:	7013      	strb	r3, [r2, #0]
   10ab4:	2200      	movs	r2, #0
   10ab6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   10aba:	4806      	ldr	r0, [pc, #24]	; (10ad4 <FindDeviceStart+0x38>)
   10abc:	f018 bbc2 	b.w	29244 <z_impl_k_timer_start>
   10ac0:	2002d49b 	.word	0x2002d49b
   10ac4:	2002d498 	.word	0x2002d498
   10ac8:	2002d497 	.word	0x2002d497
   10acc:	2002d499 	.word	0x2002d499
   10ad0:	2002ff9c 	.word	0x2002ff9c
   10ad4:	20020b40 	.word	0x20020b40

00010ad8 <AlarmRemindInit>:
	EnterFindDeviceScreen();
	FindDeviceStart();
}

void AlarmRemindInit(void)
{
   10ad8:	b508      	push	{r3, lr}
	k_timer_init(&alarm_timer, AlarmRemindTimeout, NULL);
   10ada:	2200      	movs	r2, #0
   10adc:	4905      	ldr	r1, [pc, #20]	; (10af4 <AlarmRemindInit+0x1c>)
   10ade:	4806      	ldr	r0, [pc, #24]	; (10af8 <AlarmRemindInit+0x20>)
   10ae0:	f01e fb89 	bl	2f1f6 <k_timer_init>
	k_timer_init(&find_timer, FindDeviceTimeout, NULL);
}
   10ae4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	k_timer_init(&find_timer, FindDeviceTimeout, NULL);
   10ae8:	2200      	movs	r2, #0
   10aea:	4904      	ldr	r1, [pc, #16]	; (10afc <AlarmRemindInit+0x24>)
   10aec:	4804      	ldr	r0, [pc, #16]	; (10b00 <AlarmRemindInit+0x28>)
   10aee:	f01e bb82 	b.w	2f1f6 <k_timer_init>
   10af2:	bf00      	nop
   10af4:	00010921 	.word	0x00010921
   10af8:	20020b14 	.word	0x20020b14
   10afc:	00010a51 	.word	0x00010a51
   10b00:	20020b40 	.word	0x20020b40

00010b04 <AlarmMsgProcess>:

void AlarmMsgProcess(void)
{
	if(app_find_device)
   10b04:	4b03      	ldr	r3, [pc, #12]	; (10b14 <AlarmMsgProcess+0x10>)
   10b06:	781a      	ldrb	r2, [r3, #0]
   10b08:	b11a      	cbz	r2, 10b12 <AlarmMsgProcess+0xe>
	{
		app_find_device = false;
   10b0a:	2200      	movs	r2, #0
   10b0c:	701a      	strb	r2, [r3, #0]
		FindDeviceEntryScreen();
   10b0e:	f01a bd49 	b.w	2b5a4 <FindDeviceEntryScreen>
	}
}
   10b12:	4770      	bx	lr
   10b14:	2002d496 	.word	0x2002d496

00010b18 <LCD_Fill>:

//
//(x,y),(w,h):,:w*h   
//color:
void LCD_Fill(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color)
{          
   10b18:	b570      	push	{r4, r5, r6, lr}
   10b1a:	461d      	mov	r5, r3
   10b1c:	4614      	mov	r4, r2
	u32_t i;

	if((x+w)>LCD_WIDTH)
   10b1e:	4b0e      	ldr	r3, [pc, #56]	; (10b58 <LCD_Fill+0x40>)
   10b20:	1882      	adds	r2, r0, r2
   10b22:	881b      	ldrh	r3, [r3, #0]
{          
   10b24:	f8bd 6010 	ldrh.w	r6, [sp, #16]
	if((x+w)>LCD_WIDTH)
   10b28:	429a      	cmp	r2, r3
		w = LCD_WIDTH - x;
   10b2a:	bfc8      	it	gt
   10b2c:	1a1c      	subgt	r4, r3, r0
	if((y+h)>LCD_HEIGHT)
   10b2e:	4b0b      	ldr	r3, [pc, #44]	; (10b5c <LCD_Fill+0x44>)
   10b30:	eb01 0205 	add.w	r2, r1, r5
   10b34:	881b      	ldrh	r3, [r3, #0]
		w = LCD_WIDTH - x;
   10b36:	bfc8      	it	gt
   10b38:	b2a4      	uxthgt	r4, r4
	if((y+h)>LCD_HEIGHT)
   10b3a:	429a      	cmp	r2, r3
		h = LCD_HEIGHT - y;
   10b3c:	bfc4      	itt	gt
   10b3e:	1a5d      	subgt	r5, r3, r1
   10b40:	b2ad      	uxthgt	r5, r5
	
	BlockWrite(x,y,w,h);
   10b42:	462b      	mov	r3, r5
   10b44:	4622      	mov	r2, r4
   10b46:	f01a fd4a 	bl	2b5de <BlockWrite>

#ifdef LCD_TYPE_SPI
	DispColor((w*h), color);
   10b4a:	4631      	mov	r1, r6
   10b4c:	fb05 f004 	mul.w	r0, r5, r4
#else
	for(i=0;i<(w*h);i++)
		WriteOneDot(color); // 
#endif
}
   10b50:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	DispColor((w*h), color);
   10b54:	f000 ba24 	b.w	10fa0 <DispColor>
   10b58:	200385a6 	.word	0x200385a6
   10b5c:	200385a4 	.word	0x200385a4

00010b60 <LCD_DrawRectangle>:
}    

//	  
//(x1,y1),(x2,y2):
void LCD_DrawRectangle(uint16_t x, uint16_t y, uint16_t w, uint16_t h)
{
   10b60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10b64:	4616      	mov	r6, r2
   10b66:	461c      	mov	r4, r3
   10b68:	4607      	mov	r7, r0
   10b6a:	4688      	mov	r8, r1
#ifdef LCD_TYPE_SPI
	BlockWrite(x,y,w,1);
	DispColor(w, POINT_COLOR);
   10b6c:	4d14      	ldr	r5, [pc, #80]	; (10bc0 <LCD_DrawRectangle+0x60>)
	BlockWrite(x,y,w,1);
   10b6e:	2301      	movs	r3, #1
   10b70:	f01a fd35 	bl	2b5de <BlockWrite>
	DispColor(w, POINT_COLOR);
   10b74:	8829      	ldrh	r1, [r5, #0]
   10b76:	4630      	mov	r0, r6
   10b78:	f000 fa12 	bl	10fa0 <DispColor>
	BlockWrite(x,y,1,h);
   10b7c:	4623      	mov	r3, r4
   10b7e:	2201      	movs	r2, #1
   10b80:	4641      	mov	r1, r8
   10b82:	4638      	mov	r0, r7
   10b84:	f01a fd2b 	bl	2b5de <BlockWrite>
	DispColor(h, POINT_COLOR);
   10b88:	8829      	ldrh	r1, [r5, #0]
   10b8a:	4620      	mov	r0, r4
   10b8c:	f000 fa08 	bl	10fa0 <DispColor>
	BlockWrite(x,y+h,w,1);
   10b90:	4632      	mov	r2, r6
   10b92:	2301      	movs	r3, #1
   10b94:	eb08 0104 	add.w	r1, r8, r4
   10b98:	4638      	mov	r0, r7
   10b9a:	f01a fd20 	bl	2b5de <BlockWrite>
	DispColor(w, POINT_COLOR);
   10b9e:	8829      	ldrh	r1, [r5, #0]
   10ba0:	4630      	mov	r0, r6
   10ba2:	f000 f9fd 	bl	10fa0 <DispColor>
	BlockWrite(x+w,y,1,h);
   10ba6:	4641      	mov	r1, r8
   10ba8:	19b8      	adds	r0, r7, r6
   10baa:	4623      	mov	r3, r4
   10bac:	2201      	movs	r2, #1
   10bae:	f01a fd16 	bl	2b5de <BlockWrite>
	DispColor(h, POINT_COLOR);	
   10bb2:	8829      	ldrh	r1, [r5, #0]
   10bb4:	4620      	mov	r0, r4
	LCD_DrawLine(x,y,x+w,y);
	LCD_DrawLine(x,y,x,y+h);
	LCD_DrawLine(x,y+h,x+w,y+h);
	LCD_DrawLine(x+w,y,x+w,y+h);
#endif
}
   10bb6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	DispColor(h, POINT_COLOR);	
   10bba:	f000 b9f1 	b.w	10fa0 <DispColor>
   10bbe:	bf00      	nop
   10bc0:	200385a8 	.word	0x200385a8

00010bc4 <LCD_ShowChar>:
//
//x,y:
//num::" "--->"~"
//mode:(1)(0)
void LCD_ShowChar(uint16_t x,uint16_t y,uint8_t num,uint8_t mode)
{
   10bc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10bc8:	f5ad 7d3f 	sub.w	sp, sp, #764	; 0x2fc
   10bcc:	9305      	str	r3, [sp, #20]
    u8_t temp,t1,t,i=0;
	u16_t y0=y,x0=x,w=(system_font/2),h=system_font;
   10bce:	4b66      	ldr	r3, [pc, #408]	; (10d68 <LCD_ShowChar+0x1a4>)
{
   10bd0:	4615      	mov	r5, r2
	u16_t y0=y,x0=x,w=(system_font/2),h=system_font;
   10bd2:	f893 b000 	ldrb.w	fp, [r3]
	u8_t cbyte=(system_font/2)/8+(((system_font/2)%8)?1:0);		//()
	u8_t csize=cbyte*system_font;		//	
	u8_t fontbuf[256] = {0};	
   10bd6:	f44f 7280 	mov.w	r2, #256	; 0x100
	u16_t y0=y,x0=x,w=(system_font/2),h=system_font;
   10bda:	ea4f 0a5b 	mov.w	sl, fp, lsr #1
	u8_t cbyte=(system_font/2)/8+(((system_font/2)%8)?1:0);		//()
   10bde:	f01a 0607 	ands.w	r6, sl, #7
   10be2:	bf18      	it	ne
   10be4:	2601      	movne	r6, #1
   10be6:	eb06 161b 	add.w	r6, r6, fp, lsr #4
	u8_t csize=cbyte*system_font;		//	
   10bea:	fb1b f806 	smulbb	r8, fp, r6
{
   10bee:	4607      	mov	r7, r0
   10bf0:	460c      	mov	r4, r1
	u8_t fontbuf[256] = {0};	
   10bf2:	a806      	add	r0, sp, #24
   10bf4:	2100      	movs	r1, #0
   10bf6:	f01e fbcd 	bl	2f394 <memset>
 	u8_t databuf[2*COL] = {0};
   10bfa:	2100      	movs	r1, #0
   10bfc:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
   10c00:	a846      	add	r0, sp, #280	; 0x118
   10c02:	f01e fbc7 	bl	2f394 <memset>

	num=num-' ';//ASCII-' '
   10c06:	f1a5 0120 	sub.w	r1, r5, #32
	switch(system_font)
   10c0a:	f1bb 0f18 	cmp.w	fp, #24
	u8_t csize=cbyte*system_font;		//	
   10c0e:	fa5f f888 	uxtb.w	r8, r8
	num=num-' ';//ASCII-' '
   10c12:	b2c9      	uxtb	r1, r1
	switch(system_font)
   10c14:	d078      	beq.n	10d08 <LCD_ShowChar+0x144>
   10c16:	f1bb 0f20 	cmp.w	fp, #32
   10c1a:	d07a      	beq.n	10d12 <LCD_ShowChar+0x14e>
   10c1c:	f1bb 0f10 	cmp.w	fp, #16
   10c20:	f040 8097 	bne.w	10d52 <LCD_ShowChar+0x18e>
	{
	#ifdef FONT_16
		case FONT_SIZE_16:
			memcpy(fontbuf, asc2_1608[num], csize);	//1608
   10c24:	4642      	mov	r2, r8
   10c26:	4b51      	ldr	r3, [pc, #324]	; (10d6c <LCD_ShowChar+0x1a8>)
			break;
	#endif
	#ifdef FONT_24
		case FONT_SIZE_24:
			memcpy(fontbuf, asc2_2412[num], csize);	//1608
   10c28:	eb03 1101 	add.w	r1, r3, r1, lsl #4
			break;
	#endif
	#ifdef FONT_32
		case FONT_SIZE_32:
			memcpy(fontbuf, asc2_3216[num], csize);	//1608
   10c2c:	a806      	add	r0, sp, #24
   10c2e:	f01e fb91 	bl	2f354 <memcpy>
		default:
			return;							//
	}

#ifdef LCD_TYPE_SPI
	if((x+w)>=LCD_WIDTH)
   10c32:	4b4f      	ldr	r3, [pc, #316]	; (10d70 <LCD_ShowChar+0x1ac>)
		w = LCD_WIDTH - x;
	if((y+h)>=LCD_HEIGHT)
   10c34:	eb0b 0104 	add.w	r1, fp, r4
	if((x+w)>=LCD_WIDTH)
   10c38:	881a      	ldrh	r2, [r3, #0]
   10c3a:	eb0a 0307 	add.w	r3, sl, r7
   10c3e:	4293      	cmp	r3, r2
	if((y+h)>=LCD_HEIGHT)
   10c40:	4b4c      	ldr	r3, [pc, #304]	; (10d74 <LCD_ShowChar+0x1b0>)
		w = LCD_WIDTH - x;
   10c42:	bfa8      	it	ge
   10c44:	1bd2      	subge	r2, r2, r7
	if((y+h)>=LCD_HEIGHT)
   10c46:	881b      	ldrh	r3, [r3, #0]
	u16_t y0=y,x0=x,w=(system_font/2),h=system_font;
   10c48:	bfb4      	ite	lt
   10c4a:	fa1f f28a 	uxthlt.w	r2, sl
		w = LCD_WIDTH - x;
   10c4e:	b292      	uxthge	r2, r2
	if((y+h)>=LCD_HEIGHT)
   10c50:	4299      	cmp	r1, r3
		h = LCD_HEIGHT - y;
   10c52:	bfa8      	it	ge
   10c54:	1b1b      	subge	r3, r3, r4
	BlockWrite(x,y,w,h);	//
   10c56:	4621      	mov	r1, r4
   10c58:	4638      	mov	r0, r7
	u16_t y0=y,x0=x,w=(system_font/2),h=system_font;
   10c5a:	bfb4      	ite	lt
   10c5c:	fa1f f38b 	uxthlt.w	r3, fp
		h = LCD_HEIGHT - y;
   10c60:	b29b      	uxthge	r3, r3
	BlockWrite(x,y,w,h);	//
   10c62:	f01a fcbc 	bl	2b5de <BlockWrite>
    u8_t temp,t1,t,i=0;
   10c66:	2000      	movs	r0, #0
#endif
		
	for(t=0;t<csize;t++)
   10c68:	4639      	mov	r1, r7
   10c6a:	4605      	mov	r5, r0
   10c6c:	4545      	cmp	r5, r8
   10c6e:	d270      	bcs.n	10d52 <LCD_ShowChar+0x18e>
	{
		temp = fontbuf[t];
   10c70:	ab06      	add	r3, sp, #24
   10c72:	f813 c005 	ldrb.w	ip, [r3, r5]
				databuf[2*i] = POINT_COLOR>>8;
				databuf[2*i+1] = POINT_COLOR;
			}
			else if(mode==0)
			{
				databuf[2*i] = BACK_COLOR>>8;
   10c76:	4b40      	ldr	r3, [pc, #256]	; (10d78 <LCD_ShowChar+0x1b4>)
   10c78:	f50d 7e8c 	add.w	lr, sp, #280	; 0x118
   10c7c:	881b      	ldrh	r3, [r3, #0]
   10c7e:	0a1a      	lsrs	r2, r3, #8
				databuf[2*i+1] = BACK_COLOR;
   10c80:	b2db      	uxtb	r3, r3
   10c82:	9303      	str	r3, [sp, #12]
				databuf[2*i] = POINT_COLOR>>8;
   10c84:	4b3d      	ldr	r3, [pc, #244]	; (10d7c <LCD_ShowChar+0x1b8>)
				databuf[2*i] = BACK_COLOR>>8;
   10c86:	9202      	str	r2, [sp, #8]
				databuf[2*i] = POINT_COLOR>>8;
   10c88:	881b      	ldrh	r3, [r3, #0]
   10c8a:	1c4a      	adds	r2, r1, #1
   10c8c:	ea4f 2913 	mov.w	r9, r3, lsr #8
				databuf[2*i+1] = POINT_COLOR;
   10c90:	b2db      	uxtb	r3, r3
   10c92:	9301      	str	r3, [sp, #4]
			}
			
			temp<<=1;
			i++;
			x++;
			if(x>=LCD_WIDTH)				//
   10c94:	4b36      	ldr	r3, [pc, #216]	; (10d70 <LCD_ShowChar+0x1ac>)
   10c96:	881b      	ldrh	r3, [r3, #0]
   10c98:	9304      	str	r3, [sp, #16]
				if(y>=LCD_HEIGHT)return;	//
				t=t+(cbyte-(t%cbyte))-1;	//for11
				break;

			}
			if((x-x0)==(system_font/2))
   10c9a:	4b33      	ldr	r3, [pc, #204]	; (10d68 <LCD_ShowChar+0x1a4>)
   10c9c:	f893 a000 	ldrb.w	sl, [r3]
   10ca0:	b293      	uxth	r3, r2
   10ca2:	9300      	str	r3, [sp, #0]
   10ca4:	f100 0308 	add.w	r3, r0, #8
   10ca8:	ea4f 0a5a 	mov.w	sl, sl, lsr #1
   10cac:	b2db      	uxtb	r3, r3
			if(temp&0x80)
   10cae:	f01c 0f80 	tst.w	ip, #128	; 0x80
   10cb2:	d033      	beq.n	10d1c <LCD_ShowChar+0x158>
				databuf[2*i] = POINT_COLOR>>8;
   10cb4:	b201      	sxth	r1, r0
				databuf[2*i+1] = POINT_COLOR;
   10cb6:	9a01      	ldr	r2, [sp, #4]
				databuf[2*i] = POINT_COLOR>>8;
   10cb8:	f80e 9011 	strb.w	r9, [lr, r1, lsl #1]
				databuf[2*i+1] = POINT_COLOR;
   10cbc:	eb0e 0141 	add.w	r1, lr, r1, lsl #1
				databuf[2*i+1] = BACK_COLOR;
   10cc0:	704a      	strb	r2, [r1, #1]
			temp<<=1;
   10cc2:	f8bd 1000 	ldrh.w	r1, [sp]
			if(x>=LCD_WIDTH)				//
   10cc6:	9a04      	ldr	r2, [sp, #16]
			temp<<=1;
   10cc8:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
			i++;
   10ccc:	3001      	adds	r0, #1
			if(x>=LCD_WIDTH)				//
   10cce:	428a      	cmp	r2, r1
			temp<<=1;
   10cd0:	fa5f fc8c 	uxtb.w	ip, ip
			i++;
   10cd4:	b2c0      	uxtb	r0, r0
			if(x>=LCD_WIDTH)				//
   10cd6:	d82c      	bhi.n	10d32 <LCD_ShowChar+0x16e>
				DispDate(2*i, databuf);
   10cd8:	a946      	add	r1, sp, #280	; 0x118
   10cda:	0040      	lsls	r0, r0, #1
   10cdc:	f000 f98a 	bl	10ff4 <DispDate>
				if(y>=LCD_HEIGHT)return;	//
   10ce0:	4b24      	ldr	r3, [pc, #144]	; (10d74 <LCD_ShowChar+0x1b0>)
				y++;
   10ce2:	3401      	adds	r4, #1
				if(y>=LCD_HEIGHT)return;	//
   10ce4:	881b      	ldrh	r3, [r3, #0]
				y++;
   10ce6:	b2a4      	uxth	r4, r4
				if(y>=LCD_HEIGHT)return;	//
   10ce8:	42a3      	cmp	r3, r4
   10cea:	d932      	bls.n	10d52 <LCD_ShowChar+0x18e>
				t=t+(cbyte-(t%cbyte))-1;	//for11
   10cec:	fbb5 f3f6 	udiv	r3, r5, r6
   10cf0:	fb06 5313 	mls	r3, r6, r3, r5
   10cf4:	3d01      	subs	r5, #1
   10cf6:	1af3      	subs	r3, r6, r3
   10cf8:	441d      	add	r5, r3
   10cfa:	b2ed      	uxtb	r5, r5
			{
				DispDate(2*i, databuf);
				i=0;
				
				x=x0;
   10cfc:	4639      	mov	r1, r7
				i=0;
   10cfe:	2300      	movs	r3, #0
	for(t=0;t<csize;t++)
   10d00:	3501      	adds	r5, #1
   10d02:	b2ed      	uxtb	r5, r5
   10d04:	4618      	mov	r0, r3
   10d06:	e7b1      	b.n	10c6c <LCD_ShowChar+0xa8>
			memcpy(fontbuf, asc2_2412[num], csize);	//1608
   10d08:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   10d0c:	4642      	mov	r2, r8
   10d0e:	4b1c      	ldr	r3, [pc, #112]	; (10d80 <LCD_ShowChar+0x1bc>)
   10d10:	e78a      	b.n	10c28 <LCD_ShowChar+0x64>
			memcpy(fontbuf, asc2_3216[num], csize);	//1608
   10d12:	4b1c      	ldr	r3, [pc, #112]	; (10d84 <LCD_ShowChar+0x1c0>)
   10d14:	4642      	mov	r2, r8
   10d16:	eb03 1181 	add.w	r1, r3, r1, lsl #6
   10d1a:	e787      	b.n	10c2c <LCD_ShowChar+0x68>
			else if(mode==0)
   10d1c:	9a05      	ldr	r2, [sp, #20]
   10d1e:	2a00      	cmp	r2, #0
   10d20:	d1cf      	bne.n	10cc2 <LCD_ShowChar+0xfe>
				databuf[2*i] = BACK_COLOR>>8;
   10d22:	9a02      	ldr	r2, [sp, #8]
   10d24:	b201      	sxth	r1, r0
   10d26:	f80e 2011 	strb.w	r2, [lr, r1, lsl #1]
				databuf[2*i+1] = BACK_COLOR;
   10d2a:	eb0e 0141 	add.w	r1, lr, r1, lsl #1
   10d2e:	9a03      	ldr	r2, [sp, #12]
   10d30:	e7c6      	b.n	10cc0 <LCD_ShowChar+0xfc>
			if((x-x0)==(system_font/2))
   10d32:	9a00      	ldr	r2, [sp, #0]
   10d34:	eba2 0b07 	sub.w	fp, r2, r7
   10d38:	45d3      	cmp	fp, sl
   10d3a:	d10e      	bne.n	10d5a <LCD_ShowChar+0x196>
				DispDate(2*i, databuf);
   10d3c:	b200      	sxth	r0, r0
   10d3e:	a946      	add	r1, sp, #280	; 0x118
   10d40:	0040      	lsls	r0, r0, #1
   10d42:	f000 f957 	bl	10ff4 <DispDate>
				y++;
				if(y>=LCD_HEIGHT)return;	//
   10d46:	4b0b      	ldr	r3, [pc, #44]	; (10d74 <LCD_ShowChar+0x1b0>)
				y++;
   10d48:	3401      	adds	r4, #1
				if(y>=LCD_HEIGHT)return;	//
   10d4a:	881b      	ldrh	r3, [r3, #0]
				y++;
   10d4c:	b2a4      	uxth	r4, r4
				if(y>=LCD_HEIGHT)return;	//
   10d4e:	42a3      	cmp	r3, r4
   10d50:	d8d4      	bhi.n	10cfc <LCD_ShowChar+0x138>
				break;
			}
		#endif
		}	
	}  	    	   	 	  
}
   10d52:	f50d 7d3f 	add.w	sp, sp, #764	; 0x2fc
   10d56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10d5a:	9a00      	ldr	r2, [sp, #0]
		for(t1=0;t1<8;t1++)
   10d5c:	4298      	cmp	r0, r3
   10d5e:	f102 0201 	add.w	r2, r2, #1
   10d62:	9200      	str	r2, [sp, #0]
   10d64:	d1a3      	bne.n	10cae <LCD_ShowChar+0xea>
   10d66:	e7cb      	b.n	10d00 <LCD_ShowChar+0x13c>
   10d68:	2003b5ad 	.word	0x2003b5ad
   10d6c:	200385ac 	.word	0x200385ac
   10d70:	200385a6 	.word	0x200385a6
   10d74:	200385a4 	.word	0x200385a4
   10d78:	2002d420 	.word	0x2002d420
   10d7c:	200385a8 	.word	0x200385a8
   10d80:	20038bac 	.word	0x20038bac
   10d84:	20039dac 	.word	0x20039dac

00010d88 <LCD_ShowStringInRect>:
//
//x,y:
//width,height:  
//*p:	
void LCD_ShowStringInRect(uint16_t x,uint16_t y,uint16_t width,uint16_t height,uint8_t *p)
{
   10d88:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   10d8c:	460e      	mov	r6, r1
	uint8_t x0=x;
	uint16_t phz=0;

	width+=x;
	height+=y;
	while(*p)
   10d8e:	4604      	mov	r4, r0
	width+=x;
   10d90:	4402      	add	r2, r0
	height+=y;
   10d92:	440b      	add	r3, r1
{
   10d94:	9d08      	ldr	r5, [sp, #32]
	{       
		if(x>=width){x=x0;y+=system_font;}
   10d96:	4f19      	ldr	r7, [pc, #100]	; (10dfc <LCD_ShowStringInRect+0x74>)
	width+=x;
   10d98:	fa1f f882 	uxth.w	r8, r2
	height+=y;
   10d9c:	fa1f f983 	uxth.w	r9, r3
	while(*p)
   10da0:	fa5f fa80 	uxtb.w	sl, r0
   10da4:	782a      	ldrb	r2, [r5, #0]
   10da6:	b90a      	cbnz	r2, 10dac <LCD_ShowStringInRect+0x24>
		#endif
			x+=system_font;
			p+=2;
		}        
	}
}
   10da8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if(x>=width){x=x0;y+=system_font;}
   10dac:	4544      	cmp	r4, r8
   10dae:	bf21      	itttt	cs
   10db0:	783b      	ldrbcs	r3, [r7, #0]
   10db2:	4654      	movcs	r4, sl
   10db4:	18f6      	addcs	r6, r6, r3
   10db6:	b2b6      	uxthcs	r6, r6
		if(*p=='\n'){x=x0;y+=system_font;p++;}
   10db8:	2a0a      	cmp	r2, #10
   10dba:	d104      	bne.n	10dc6 <LCD_ShowStringInRect+0x3e>
   10dbc:	4654      	mov	r4, sl
   10dbe:	783b      	ldrb	r3, [r7, #0]
   10dc0:	3501      	adds	r5, #1
   10dc2:	441e      	add	r6, r3
   10dc4:	b2b6      	uxth	r6, r6
		if(y>=height)break;//
   10dc6:	454e      	cmp	r6, r9
   10dc8:	d2ee      	bcs.n	10da8 <LCD_ShowStringInRect+0x20>
		if(*p==0x00)break;//
   10dca:	782a      	ldrb	r2, [r5, #0]
   10dcc:	2a00      	cmp	r2, #0
   10dce:	d0eb      	beq.n	10da8 <LCD_ShowStringInRect+0x20>
		if(*p<0x80)
   10dd0:	0613      	lsls	r3, r2, #24
   10dd2:	d40a      	bmi.n	10dea <LCD_ShowStringInRect+0x62>
			LCD_ShowChar(x,y,*p,0);
   10dd4:	4620      	mov	r0, r4
   10dd6:	2300      	movs	r3, #0
   10dd8:	4631      	mov	r1, r6
   10dda:	f7ff fef3 	bl	10bc4 <LCD_ShowChar>
			x+=system_font/2;
   10dde:	7838      	ldrb	r0, [r7, #0]
			p++;
   10de0:	3501      	adds	r5, #1
			x+=system_font/2;
   10de2:	eb04 0450 	add.w	r4, r4, r0, lsr #1
   10de6:	b2a4      	uxth	r4, r4
			p++;
   10de8:	e7dc      	b.n	10da4 <LCD_ShowStringInRect+0x1c>
		else if(*(p+1))
   10dea:	786b      	ldrb	r3, [r5, #1]
   10dec:	2b00      	cmp	r3, #0
   10dee:	d0d9      	beq.n	10da4 <LCD_ShowStringInRect+0x1c>
			x+=system_font;
   10df0:	7838      	ldrb	r0, [r7, #0]
			p+=2;
   10df2:	3502      	adds	r5, #2
			x+=system_font;
   10df4:	4404      	add	r4, r0
   10df6:	b2a4      	uxth	r4, r4
			p+=2;
   10df8:	e7d4      	b.n	10da4 <LCD_ShowStringInRect+0x1c>
   10dfa:	bf00      	nop
   10dfc:	2003b5ad 	.word	0x2003b5ad

00010e00 <LCD_ShowString>:

//
//x,y:
//*p:	
void LCD_ShowString(uint16_t x,uint16_t y,uint8_t *p)
{
   10e00:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10e04:	4605      	mov	r5, r0
   10e06:	460e      	mov	r6, r1
   10e08:	4614      	mov	r4, r2
	uint8_t width;
	uint16_t phz=0;

	while(*p)
	{       
		if(x>=LCD_WIDTH)break;//
   10e0a:	f8df 8050 	ldr.w	r8, [pc, #80]	; 10e5c <LCD_ShowString+0x5c>
		if(y>=LCD_HEIGHT)break;//
   10e0e:	f8df 9050 	ldr.w	r9, [pc, #80]	; 10e60 <LCD_ShowString+0x60>
			LCD_ShowChineseChar_from_flash(x,y,phz,0);
		  #endif
		#else
			LCD_ShowChineseChar(x,y,phz,0);
		#endif
			x+=system_font;
   10e12:	4f11      	ldr	r7, [pc, #68]	; (10e58 <LCD_ShowString+0x58>)
	while(*p)
   10e14:	7822      	ldrb	r2, [r4, #0]
   10e16:	b90a      	cbnz	r2, 10e1c <LCD_ShowString+0x1c>
			p+=2;
		}        
	}
}
   10e18:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if(x>=LCD_WIDTH)break;//
   10e1c:	f8b8 3000 	ldrh.w	r3, [r8]
   10e20:	42ab      	cmp	r3, r5
   10e22:	d9f9      	bls.n	10e18 <LCD_ShowString+0x18>
		if(y>=LCD_HEIGHT)break;//
   10e24:	f8b9 3000 	ldrh.w	r3, [r9]
   10e28:	42b3      	cmp	r3, r6
   10e2a:	d9f5      	bls.n	10e18 <LCD_ShowString+0x18>
		if(*p<0x80)
   10e2c:	0613      	lsls	r3, r2, #24
   10e2e:	d40a      	bmi.n	10e46 <LCD_ShowString+0x46>
			LCD_ShowChar(x,y,*p,0);
   10e30:	2300      	movs	r3, #0
   10e32:	4628      	mov	r0, r5
   10e34:	4631      	mov	r1, r6
   10e36:	f7ff fec5 	bl	10bc4 <LCD_ShowChar>
		  	x += system_font/2;
   10e3a:	783b      	ldrb	r3, [r7, #0]
			p++;
   10e3c:	3401      	adds	r4, #1
		  	x += system_font/2;
   10e3e:	eb05 0553 	add.w	r5, r5, r3, lsr #1
   10e42:	b2ad      	uxth	r5, r5
			p++;
   10e44:	e7e6      	b.n	10e14 <LCD_ShowString+0x14>
		else if(*(p+1))
   10e46:	7863      	ldrb	r3, [r4, #1]
   10e48:	2b00      	cmp	r3, #0
   10e4a:	d0e3      	beq.n	10e14 <LCD_ShowString+0x14>
			x+=system_font;
   10e4c:	783b      	ldrb	r3, [r7, #0]
			p+=2;
   10e4e:	3402      	adds	r4, #2
			x+=system_font;
   10e50:	441d      	add	r5, r3
   10e52:	b2ad      	uxth	r5, r5
			p+=2;
   10e54:	e7de      	b.n	10e14 <LCD_ShowString+0x14>
   10e56:	bf00      	nop
   10e58:	2003b5ad 	.word	0x2003b5ad
   10e5c:	200385a6 	.word	0x200385a6
   10e60:	200385a4 	.word	0x200385a4

00010e64 <LCD_MeasureString>:
//width,height:
void LCD_MeasureString(uint8_t *p, uint16_t *width,uint16_t *height)
{
	uint8_t font_size;

	*width = 0;
   10e64:	2300      	movs	r3, #0
{
   10e66:	b570      	push	{r4, r5, r6, lr}
	*width = 0;
   10e68:	800b      	strh	r3, [r1, #0]
{
   10e6a:	460d      	mov	r5, r1
   10e6c:	4616      	mov	r6, r2
	*height = 0;
   10e6e:	8013      	strh	r3, [r2, #0]

	if(p == NULL || strlen((const char *)p) == 0)
   10e70:	4604      	mov	r4, r0
   10e72:	b148      	cbz	r0, 10e88 <LCD_MeasureString+0x24>
   10e74:	f7fc f870 	bl	cf58 <strlen>
   10e78:	b130      	cbz	r0, 10e88 <LCD_MeasureString+0x24>
		return;

	(*height) = system_font;
   10e7a:	4b0b      	ldr	r3, [pc, #44]	; (10ea8 <LCD_MeasureString+0x44>)
   10e7c:	781b      	ldrb	r3, [r3, #0]
   10e7e:	b299      	uxth	r1, r3
   10e80:	8031      	strh	r1, [r6, #0]
		if(*p<0x80)
		{
		#ifdef FONTMAKER_MBCS_FONT
			(*width) += LCD_Measure_Mbcs_Byte(*p);
		#else
			(*width) += system_font/2;
   10e82:	085b      	lsrs	r3, r3, #1
	while(*p)
   10e84:	7822      	ldrb	r2, [r4, #0]
   10e86:	b902      	cbnz	r2, 10e8a <LCD_MeasureString+0x26>
		{
			(*width) += system_font;
			p += 2;
		}        
	}  
}
   10e88:	bd70      	pop	{r4, r5, r6, pc}
		if(*p<0x80)
   10e8a:	0612      	lsls	r2, r2, #24
   10e8c:	d404      	bmi.n	10e98 <LCD_MeasureString+0x34>
			(*width) += system_font/2;
   10e8e:	882a      	ldrh	r2, [r5, #0]
			p++;
   10e90:	3401      	adds	r4, #1
			(*width) += system_font/2;
   10e92:	441a      	add	r2, r3
   10e94:	802a      	strh	r2, [r5, #0]
			p++;
   10e96:	e7f5      	b.n	10e84 <LCD_MeasureString+0x20>
		else if(*(p+1))
   10e98:	7862      	ldrb	r2, [r4, #1]
   10e9a:	2a00      	cmp	r2, #0
   10e9c:	d0f2      	beq.n	10e84 <LCD_MeasureString+0x20>
			(*width) += system_font;
   10e9e:	882a      	ldrh	r2, [r5, #0]
			p += 2;
   10ea0:	3402      	adds	r4, #2
			(*width) += system_font;
   10ea2:	440a      	add	r2, r1
   10ea4:	802a      	strh	r2, [r5, #0]
			p += 2;
   10ea6:	e7ed      	b.n	10e84 <LCD_MeasureString+0x20>
   10ea8:	2003b5ad 	.word	0x2003b5ad

00010eac <LCD_SetFontSize>:

//
//font_size:
void LCD_SetFontSize(uint8_t font_size)
{
	if(font_size > FONT_SIZE_MIN && font_size < FONT_SIZE_MAX)
   10eac:	1e43      	subs	r3, r0, #1
   10eae:	2b1f      	cmp	r3, #31
		system_font = font_size;
   10eb0:	bf9c      	itt	ls
   10eb2:	4b01      	ldrls	r3, [pc, #4]	; (10eb8 <LCD_SetFontSize+0xc>)
   10eb4:	7018      	strbls	r0, [r3, #0]
}
   10eb6:	4770      	bx	lr
   10eb8:	2003b5ad 	.word	0x2003b5ad

00010ebc <LCDMsgProcess>:

void LCDMsgProcess(void)
{
   10ebc:	b508      	push	{r3, lr}
	if(lcd_sleep_in)
   10ebe:	4b08      	ldr	r3, [pc, #32]	; (10ee0 <LCDMsgProcess+0x24>)
   10ec0:	781a      	ldrb	r2, [r3, #0]
   10ec2:	b11a      	cbz	r2, 10ecc <LCDMsgProcess+0x10>
	{
		lcd_sleep_in = false;
   10ec4:	2200      	movs	r2, #0
   10ec6:	701a      	strb	r2, [r3, #0]
		LCD_SleepIn();
   10ec8:	f000 f8ba 	bl	11040 <LCD_SleepIn>
	}

	if(lcd_sleep_out)
   10ecc:	4b05      	ldr	r3, [pc, #20]	; (10ee4 <LCDMsgProcess+0x28>)
   10ece:	781a      	ldrb	r2, [r3, #0]
   10ed0:	b12a      	cbz	r2, 10ede <LCDMsgProcess+0x22>
	{
		lcd_sleep_out = false;
   10ed2:	2200      	movs	r2, #0
   10ed4:	701a      	strb	r2, [r3, #0]
		LCD_SleepOut();
	}
}
   10ed6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		LCD_SleepOut();
   10eda:	f000 b8c5 	b.w	11068 <LCD_SleepOut>
}
   10ede:	bd08      	pop	{r3, pc}
   10ee0:	2002d49a 	.word	0x2002d49a
   10ee4:	2002d49b 	.word	0x2002d49b

00010ee8 <backlight_timer_handler>:
	k_sleep(K_MSEC(dly));
}

static void backlight_timer_handler(struct k_timer *timer)
{
	lcd_sleep_in = true;
   10ee8:	2201      	movs	r2, #1
   10eea:	4b01      	ldr	r3, [pc, #4]	; (10ef0 <backlight_timer_handler+0x8>)
   10eec:	701a      	strb	r2, [r3, #0]
}
   10eee:	4770      	bx	lr
   10ef0:	2002d49a 	.word	0x2002d49a

00010ef4 <LCD_SPI_Transceive.constprop.0>:
	tx_buff.buf = txbuf;
   10ef4:	4b0e      	ldr	r3, [pc, #56]	; (10f30 <LCD_SPI_Transceive.constprop.0+0x3c>)
   10ef6:	4a0f      	ldr	r2, [pc, #60]	; (10f34 <LCD_SPI_Transceive.constprop.0+0x40>)
static void LCD_SPI_Transceive(u8_t *txbuf, u32_t txbuflen, u8_t *rxbuf, u32_t rxbuflen)
   10ef8:	b510      	push	{r4, lr}
	tx_buff.len = txbuflen;
   10efa:	e9c3 2000 	strd	r2, r0, [r3]
	tx_bufs.buffers = &tx_buff;
   10efe:	4a0e      	ldr	r2, [pc, #56]	; (10f38 <LCD_SPI_Transceive.constprop.0+0x44>)
	tx_bufs.count = 1;
   10f00:	2001      	movs	r0, #1
	tx_bufs.buffers = &tx_buff;
   10f02:	6013      	str	r3, [r2, #0]
	rx_buff.buf = rxbuf;
   10f04:	2300      	movs	r3, #0
   10f06:	490d      	ldr	r1, [pc, #52]	; (10f3c <LCD_SPI_Transceive.constprop.0+0x48>)
	tx_bufs.count = 1;
   10f08:	6050      	str	r0, [r2, #4]
	rx_buff.len = rxbuflen;
   10f0a:	e9c1 3300 	strd	r3, r3, [r1]
	rx_bufs.buffers = &rx_buff;
   10f0e:	4b0c      	ldr	r3, [pc, #48]	; (10f40 <LCD_SPI_Transceive.constprop.0+0x4c>)
	rx_bufs.count = 1;
   10f10:	e9c3 1000 	strd	r1, r0, [r3]
	err = spi_transceive(spi_lcd, &spi_cfg, &tx_bufs, &rx_bufs);
   10f14:	490b      	ldr	r1, [pc, #44]	; (10f44 <LCD_SPI_Transceive.constprop.0+0x50>)
   10f16:	6808      	ldr	r0, [r1, #0]
				       const struct spi_buf_set *rx_bufs)
{
	const struct spi_driver_api *api =
		(const struct spi_driver_api *)dev->driver_api;

	return api->transceive(dev, config, tx_bufs, rx_bufs);
   10f18:	6841      	ldr	r1, [r0, #4]
   10f1a:	680c      	ldr	r4, [r1, #0]
   10f1c:	490a      	ldr	r1, [pc, #40]	; (10f48 <LCD_SPI_Transceive.constprop.0+0x54>)
   10f1e:	47a0      	blx	r4
	if(err)
   10f20:	4601      	mov	r1, r0
   10f22:	b120      	cbz	r0, 10f2e <LCD_SPI_Transceive.constprop.0+0x3a>
}
   10f24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		printk("SPI error: %d\n", err);
   10f28:	4808      	ldr	r0, [pc, #32]	; (10f4c <LCD_SPI_Transceive.constprop.0+0x58>)
   10f2a:	f01c b98e 	b.w	2d24a <printk>
}
   10f2e:	bd10      	pop	{r4, pc}
   10f30:	20020bc8 	.word	0x20020bc8
   10f34:	2002d49d 	.word	0x2002d49d
   10f38:	20020bd0 	.word	0x20020bd0
   10f3c:	20020b9c 	.word	0x20020b9c
   10f40:	20020ba4 	.word	0x20020ba4
   10f44:	20020bc4 	.word	0x20020bc4
   10f48:	20020bac 	.word	0x20020bac
   10f4c:	00031138 	.word	0x00031138

00010f50 <Write_Data>:

//
//i:8
void Write_Data(uint8_t i) 
{	
	lcd_data_buffer[0] = i;
   10f50:	4b02      	ldr	r3, [pc, #8]	; (10f5c <Write_Data+0xc>)
   10f52:	7018      	strb	r0, [r3, #0]
	
	LCD_SPI_Transceive(lcd_data_buffer, 1, NULL, 0);
   10f54:	2001      	movs	r0, #1
   10f56:	f7ff bfcd 	b.w	10ef4 <LCD_SPI_Transceive.constprop.0>
   10f5a:	bf00      	nop
   10f5c:	2002d49d 	.word	0x2002d49d

00010f60 <WriteComm>:

//----------------------------------------------------------------------
//
//i:
void WriteComm(u8_t i)
{
   10f60:	b510      	push	{r4, lr}
   10f62:	4604      	mov	r4, r0
	gpio_pin_write(gpio_lcd, RS, 0);
   10f64:	4b05      	ldr	r3, [pc, #20]	; (10f7c <WriteComm+0x1c>)
   10f66:	2200      	movs	r2, #0
   10f68:	2115      	movs	r1, #21
   10f6a:	6818      	ldr	r0, [r3, #0]
   10f6c:	f01a fb23 	bl	2b5b6 <gpio_pin_write>
	Write_Data(i);
   10f70:	4620      	mov	r0, r4
}
   10f72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	Write_Data(i);
   10f76:	f7ff bfeb 	b.w	10f50 <Write_Data>
   10f7a:	bf00      	nop
   10f7c:	20020b98 	.word	0x20020b98

00010f80 <WriteData>:

//LCD
//i:
void WriteData(u8_t i)
{
   10f80:	b510      	push	{r4, lr}
   10f82:	4604      	mov	r4, r0
	gpio_pin_write(gpio_lcd, RS, 1);
   10f84:	4b05      	ldr	r3, [pc, #20]	; (10f9c <WriteData+0x1c>)
   10f86:	2201      	movs	r2, #1
   10f88:	2115      	movs	r1, #21
   10f8a:	6818      	ldr	r0, [r3, #0]
   10f8c:	f01a fb13 	bl	2b5b6 <gpio_pin_write>
	Write_Data(i);  
   10f90:	4620      	mov	r0, r4
}
   10f92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	Write_Data(i);  
   10f96:	f7ff bfdb 	b.w	10f50 <Write_Data>
   10f9a:	bf00      	nop
   10f9c:	20020b98 	.word	0x20020b98

00010fa0 <DispColor>:

	WriteComm(0x2c);
}

void DispColor(u32_t total, u16_t color)
{
   10fa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t i,remain;      

	gpio_pin_write(gpio_lcd, RS, 1);
   10fa2:	4b12      	ldr	r3, [pc, #72]	; (10fec <DispColor+0x4c>)
{
   10fa4:	460e      	mov	r6, r1
   10fa6:	4605      	mov	r5, r0
	gpio_pin_write(gpio_lcd, RS, 1);
   10fa8:	2201      	movs	r2, #1
   10faa:	2115      	movs	r1, #21
   10fac:	6818      	ldr	r0, [r3, #0]
   10fae:	f01a fb02 	bl	2b5b6 <gpio_pin_write>
		else
			remain = LCD_DATA_LEN;
		
		for(i=0;i<remain;i++)
		{
			lcd_data_buffer[2*i] = color>>8;
   10fb2:	0a37      	lsrs	r7, r6, #8
		if(total <= LCD_DATA_LEN)
   10fb4:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
   10fb8:	462a      	mov	r2, r5
		for(i=0;i<remain;i++)
   10fba:	f04f 0400 	mov.w	r4, #0
   10fbe:	bf28      	it	cs
   10fc0:	f44f 5280 	movcs.w	r2, #4096	; 0x1000
   10fc4:	4b0a      	ldr	r3, [pc, #40]	; (10ff0 <DispColor+0x50>)
   10fc6:	4294      	cmp	r4, r2
   10fc8:	f103 0302 	add.w	r3, r3, #2
   10fcc:	d107      	bne.n	10fde <DispColor+0x3e>
			lcd_data_buffer[2*i+1] = color;
		}
		
		LCD_SPI_Transceive(lcd_data_buffer, 2*remain, NULL, 0);
   10fce:	0060      	lsls	r0, r4, #1
   10fd0:	f7ff ff90 	bl	10ef4 <LCD_SPI_Transceive.constprop.0>

		if(remain == total)
   10fd4:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
   10fd8:	d907      	bls.n	10fea <DispColor+0x4a>
			break;

		total -= remain;
   10fda:	1b2d      	subs	r5, r5, r4
		if(total <= LCD_DATA_LEN)
   10fdc:	e7ea      	b.n	10fb4 <DispColor+0x14>
			lcd_data_buffer[2*i] = color>>8;
   10fde:	f803 7c02 	strb.w	r7, [r3, #-2]
			lcd_data_buffer[2*i+1] = color;
   10fe2:	f803 6c01 	strb.w	r6, [r3, #-1]
		for(i=0;i<remain;i++)
   10fe6:	3401      	adds	r4, #1
   10fe8:	e7ed      	b.n	10fc6 <DispColor+0x26>
	}
}
   10fea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   10fec:	20020b98 	.word	0x20020b98
   10ff0:	2002d49d 	.word	0x2002d49d

00010ff4 <DispDate>:

void DispDate(u32_t total, u8_t *data)
{
	u32_t i,remain;      

	gpio_pin_write(gpio_lcd, RS, 1);
   10ff4:	4b10      	ldr	r3, [pc, #64]	; (11038 <DispDate+0x44>)
{
   10ff6:	b570      	push	{r4, r5, r6, lr}
	gpio_pin_write(gpio_lcd, RS, 1);
   10ff8:	2201      	movs	r2, #1
{
   10ffa:	4604      	mov	r4, r0
   10ffc:	460e      	mov	r6, r1
	gpio_pin_write(gpio_lcd, RS, 1);
   10ffe:	6818      	ldr	r0, [r3, #0]
   11000:	2115      	movs	r1, #21
   11002:	f01a fad8 	bl	2b5b6 <gpio_pin_write>
	
	while(1)
	{
		if(total <= 2*LCD_DATA_LEN)
   11006:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
   1100a:	4625      	mov	r5, r4
   1100c:	bf28      	it	cs
   1100e:	f44f 5500 	movcs.w	r5, #8192	; 0x2000
			remain = total;
		else
			remain = 2*LCD_DATA_LEN;
		
		for(i=0;i<remain;i++)
   11012:	4633      	mov	r3, r6
   11014:	4a09      	ldr	r2, [pc, #36]	; (1103c <DispDate+0x48>)
   11016:	1971      	adds	r1, r6, r5
   11018:	428b      	cmp	r3, r1
   1101a:	d107      	bne.n	1102c <DispDate+0x38>
		{
			lcd_data_buffer[i] = data[i];
		}
		
		LCD_SPI_Transceive(lcd_data_buffer, remain, NULL, 0);
   1101c:	4628      	mov	r0, r5
   1101e:	f7ff ff69 	bl	10ef4 <LCD_SPI_Transceive.constprop.0>

		if(remain == total)
   11022:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
   11026:	d906      	bls.n	11036 <DispDate+0x42>
			break;

		total -= remain;
   11028:	1b64      	subs	r4, r4, r5
		if(total <= 2*LCD_DATA_LEN)
   1102a:	e7ec      	b.n	11006 <DispDate+0x12>
			lcd_data_buffer[i] = data[i];
   1102c:	f813 0b01 	ldrb.w	r0, [r3], #1
   11030:	f802 0b01 	strb.w	r0, [r2], #1
   11034:	e7f0      	b.n	11018 <DispDate+0x24>
	}
}
   11036:	bd70      	pop	{r4, r5, r6, pc}
   11038:	20020b98 	.word	0x20020b98
   1103c:	2002d49d 	.word	0x2002d49d

00011040 <LCD_SleepIn>:
	DispColor(COL*ROW, color);
} 

//
void LCD_SleepIn(void)
{
   11040:	b510      	push	{r4, lr}
	if(lcd_is_sleeping)
   11042:	4c08      	ldr	r4, [pc, #32]	; (11064 <LCD_SleepIn+0x24>)
   11044:	7823      	ldrb	r3, [r4, #0]
   11046:	b963      	cbnz	r3, 11062 <LCD_SleepIn+0x22>
		return;

	//
#ifdef LCD_BACKLIGHT_CONTROLED_BY_PMU
	Set_Screen_Backlight_Off();
   11048:	f01b fdc4 	bl	2cbd4 <Set_Screen_Backlight_Off>
#else
	//gpio_pin_write(gpio_lcd, LEDK, 1);
	gpio_pin_write(gpio_lcd, LEDA, 0);
#endif

	WriteComm(0x28);	
   1104c:	2028      	movs	r0, #40	; 0x28
   1104e:	f7ff ff87 	bl	10f60 <WriteComm>
	WriteComm(0x10);  		//Sleep in	
   11052:	2010      	movs	r0, #16
   11054:	f7ff ff84 	bl	10f60 <WriteComm>
	k_sleep(K_MSEC(dly));
   11058:	2078      	movs	r0, #120	; 0x78
   1105a:	f01a faaa 	bl	2b5b2 <k_sleep>
	Delay(120);             //120ms

	lcd_is_sleeping = true;
   1105e:	2301      	movs	r3, #1
   11060:	7023      	strb	r3, [r4, #0]
}
   11062:	bd10      	pop	{r4, pc}
   11064:	2003b5ac 	.word	0x2003b5ac

00011068 <LCD_SleepOut>:

//
void LCD_SleepOut(void)
{
   11068:	b510      	push	{r4, lr}
 */
__syscall u32_t k_timer_remaining_get(struct k_timer *timer);

static inline u32_t z_impl_k_timer_remaining_get(struct k_timer *timer)
{
	const s32_t ticks = z_timeout_remaining(&timer->timeout);
   1106a:	4818      	ldr	r0, [pc, #96]	; (110cc <LCD_SleepOut+0x64>)
   1106c:	f017 feca 	bl	28e04 <z_timeout_remaining>
	return (ticks > 0) ? (u32_t)k_ticks_to_ms_floor64(ticks) : 0U;
   11070:	2800      	cmp	r0, #0
   11072:	dd0a      	ble.n	1108a <LCD_SleepOut+0x22>
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
   11074:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   11078:	fb80 0103 	smull	r0, r1, r0, r3
   1107c:	0bc3      	lsrs	r3, r0, #15
	u16_t bk_time;
	
	if(k_timer_remaining_get(&backlight_timer) > 0)
   1107e:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
   11082:	d002      	beq.n	1108a <LCD_SleepOut+0x22>
	z_impl_k_timer_stop(timer);
   11084:	4811      	ldr	r0, [pc, #68]	; (110cc <LCD_SleepOut+0x64>)
   11086:	f01e f8c2 	bl	2f20e <z_impl_k_timer_stop>
		k_timer_stop(&backlight_timer);

	if(global_settings.backlight_time != 0)
   1108a:	4b11      	ldr	r3, [pc, #68]	; (110d0 <LCD_SleepOut+0x68>)
   1108c:	899b      	ldrh	r3, [r3, #12]
   1108e:	b163      	cbz	r3, 110aa <LCD_SleepOut+0x42>
	{
		bk_time = global_settings.backlight_time;
		//xb add 2020-12-31 5
		if(sleep_out_by_wrist)
   11090:	4a10      	ldr	r2, [pc, #64]	; (110d4 <LCD_SleepOut+0x6c>)
   11092:	7811      	ldrb	r1, [r2, #0]
   11094:	b111      	cbz	r1, 1109c <LCD_SleepOut+0x34>
		{
			sleep_out_by_wrist = false;
   11096:	2300      	movs	r3, #0
   11098:	7013      	strb	r3, [r2, #0]
			bk_time = 5;
   1109a:	2305      	movs	r3, #5
	z_impl_k_timer_start(timer, duration, period);
   1109c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   110a0:	2200      	movs	r2, #0
   110a2:	4359      	muls	r1, r3
   110a4:	4809      	ldr	r0, [pc, #36]	; (110cc <LCD_SleepOut+0x64>)
   110a6:	f018 f8cd 	bl	29244 <z_impl_k_timer_start>
		}

		k_timer_start(&backlight_timer, K_SECONDS(bk_time), NULL);
	}

	if(!lcd_is_sleeping)
   110aa:	4c0b      	ldr	r4, [pc, #44]	; (110d8 <LCD_SleepOut+0x70>)
   110ac:	7823      	ldrb	r3, [r4, #0]
   110ae:	b163      	cbz	r3, 110ca <LCD_SleepOut+0x62>
		return;
	
	WriteComm(0x11);  		//Sleep out	
   110b0:	2011      	movs	r0, #17
   110b2:	f7ff ff55 	bl	10f60 <WriteComm>
	k_sleep(K_MSEC(dly));
   110b6:	2078      	movs	r0, #120	; 0x78
   110b8:	f01a fa7b 	bl	2b5b2 <k_sleep>
	Delay(120);             //120ms
	WriteComm(0x29);
   110bc:	2029      	movs	r0, #41	; 0x29
   110be:	f7ff ff4f 	bl	10f60 <WriteComm>

	//
#ifdef LCD_BACKLIGHT_CONTROLED_BY_PMU
	Set_Screen_Backlight_On();
   110c2:	f01b fd82 	bl	2cbca <Set_Screen_Backlight_On>
#else
	//gpio_pin_write(gpio_lcd, LEDK, 0);
	gpio_pin_write(gpio_lcd, LEDA, 1);                                                                                                         
#endif

	lcd_is_sleeping = false;
   110c6:	2300      	movs	r3, #0
   110c8:	7023      	strb	r3, [r4, #0]
}
   110ca:	bd10      	pop	{r4, pc}
   110cc:	20020b6c 	.word	0x20020b6c
   110d0:	2002d422 	.word	0x2002d422
   110d4:	2002d49c 	.word	0x2002d49c
   110d8:	2003b5ac 	.word	0x2003b5ac

000110dc <LCD_Init>:

//LCD
void LCD_Init(void)
{
   110dc:	b538      	push	{r3, r4, r5, lr}
	int err;
	
	printk("LCD_Init\n");
   110de:	48a6      	ldr	r0, [pc, #664]	; (11378 <LCD_Init+0x29c>)
   110e0:	f01c f8b3 	bl	2d24a <printk>
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
   110e4:	48a5      	ldr	r0, [pc, #660]	; (1137c <LCD_Init+0x2a0>)
   110e6:	f015 f86f 	bl	261c8 <z_impl_device_get_binding>
	
  	//
  	gpio_lcd = device_get_binding(LCD_PORT);
   110ea:	4ca5      	ldr	r4, [pc, #660]	; (11380 <LCD_Init+0x2a4>)
   110ec:	6020      	str	r0, [r4, #0]
	if(!gpio_lcd)
   110ee:	b920      	cbnz	r0, 110fa <LCD_Init+0x1e>

	k_timer_init(&backlight_timer, backlight_timer_handler, NULL);

	if(global_settings.backlight_time != 0)
		k_timer_start(&backlight_timer, K_SECONDS(global_settings.backlight_time), NULL);	
}
   110f0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		printk("Cannot bind gpio device\n");
   110f4:	48a3      	ldr	r0, [pc, #652]	; (11384 <LCD_Init+0x2a8>)
   110f6:	f01c b8a8 	b.w	2d24a <printk>
	gpio_pin_configure(gpio_lcd, LEDA, GPIO_DIR_OUT);
   110fa:	210e      	movs	r1, #14
   110fc:	f01a fa65 	bl	2b5ca <gpio_pin_configure.constprop.2>
	gpio_pin_configure(gpio_lcd, CS, GPIO_DIR_OUT);
   11100:	2117      	movs	r1, #23
   11102:	6820      	ldr	r0, [r4, #0]
   11104:	f01a fa61 	bl	2b5ca <gpio_pin_configure.constprop.2>
	gpio_pin_configure(gpio_lcd, RST, GPIO_DIR_OUT);
   11108:	2118      	movs	r1, #24
   1110a:	6820      	ldr	r0, [r4, #0]
   1110c:	f01a fa5d 	bl	2b5ca <gpio_pin_configure.constprop.2>
	gpio_pin_configure(gpio_lcd, RS, GPIO_DIR_OUT);
   11110:	2115      	movs	r1, #21
   11112:	6820      	ldr	r0, [r4, #0]
   11114:	f01a fa59 	bl	2b5ca <gpio_pin_configure.constprop.2>
	gpio_pin_configure(gpio_lcd, VDD, GPIO_DIR_OUT);
   11118:	2112      	movs	r1, #18
   1111a:	6820      	ldr	r0, [r4, #0]
   1111c:	f01a fa55 	bl	2b5ca <gpio_pin_configure.constprop.2>
	gpio_pin_write(gpio_lcd, VDD, 1);
   11120:	2201      	movs	r2, #1
   11122:	2112      	movs	r1, #18
   11124:	6820      	ldr	r0, [r4, #0]
   11126:	f01a fa46 	bl	2b5b6 <gpio_pin_write>
   1112a:	4897      	ldr	r0, [pc, #604]	; (11388 <LCD_Init+0x2ac>)
   1112c:	f015 f84c 	bl	261c8 <z_impl_device_get_binding>
	spi_lcd = device_get_binding(LCD_DEV);
   11130:	4b96      	ldr	r3, [pc, #600]	; (1138c <LCD_Init+0x2b0>)
   11132:	6018      	str	r0, [r3, #0]
	if(!spi_lcd) 
   11134:	2800      	cmp	r0, #0
   11136:	f040 8107 	bne.w	11348 <LCD_Init+0x26c>
		printk("Could not get %s device\n", LCD_DEV);
   1113a:	4993      	ldr	r1, [pc, #588]	; (11388 <LCD_Init+0x2ac>)
   1113c:	4894      	ldr	r0, [pc, #592]	; (11390 <LCD_Init+0x2b4>)
   1113e:	f01c f884 	bl	2d24a <printk>
	gpio_pin_write(gpio_lcd, RST, 1);
   11142:	2201      	movs	r2, #1
   11144:	2118      	movs	r1, #24
   11146:	6820      	ldr	r0, [r4, #0]
   11148:	f01a fa35 	bl	2b5b6 <gpio_pin_write>
	k_sleep(K_MSEC(dly));
   1114c:	200a      	movs	r0, #10
   1114e:	f01a fa30 	bl	2b5b2 <k_sleep>
	gpio_pin_write(gpio_lcd, RST, 0);
   11152:	2200      	movs	r2, #0
   11154:	2118      	movs	r1, #24
   11156:	6820      	ldr	r0, [r4, #0]
   11158:	f01a fa2d 	bl	2b5b6 <gpio_pin_write>
	k_sleep(K_MSEC(dly));
   1115c:	200a      	movs	r0, #10
   1115e:	f01a fa28 	bl	2b5b2 <k_sleep>
	gpio_pin_write(gpio_lcd, RST, 1);
   11162:	2201      	movs	r2, #1
   11164:	2118      	movs	r1, #24
   11166:	6820      	ldr	r0, [r4, #0]
   11168:	f01a fa25 	bl	2b5b6 <gpio_pin_write>
	k_sleep(K_MSEC(dly));
   1116c:	2078      	movs	r0, #120	; 0x78
   1116e:	f01a fa20 	bl	2b5b2 <k_sleep>
	WriteComm(0x11);     //Sleep out
   11172:	2011      	movs	r0, #17
   11174:	f7ff fef4 	bl	10f60 <WriteComm>
	k_sleep(K_MSEC(dly));
   11178:	2078      	movs	r0, #120	; 0x78
   1117a:	f01a fa1a 	bl	2b5b2 <k_sleep>
	WriteComm(0xfe);
   1117e:	20fe      	movs	r0, #254	; 0xfe
   11180:	f7ff feee 	bl	10f60 <WriteComm>
	WriteComm(0xef);	
   11184:	20ef      	movs	r0, #239	; 0xef
   11186:	f7ff feeb 	bl	10f60 <WriteComm>
	WriteComm(0x36);	
   1118a:	2036      	movs	r0, #54	; 0x36
   1118c:	f7ff fee8 	bl	10f60 <WriteComm>
	WriteData(0x48);	
   11190:	2048      	movs	r0, #72	; 0x48
   11192:	f7ff fef5 	bl	10f80 <WriteData>
	WriteComm(0x3a);	
   11196:	203a      	movs	r0, #58	; 0x3a
   11198:	f7ff fee2 	bl	10f60 <WriteComm>
	WriteData(0x05);	
   1119c:	2005      	movs	r0, #5
   1119e:	f7ff feef 	bl	10f80 <WriteData>
	WriteComm(0x86);	
   111a2:	2086      	movs	r0, #134	; 0x86
   111a4:	f7ff fedc 	bl	10f60 <WriteComm>
	WriteData(0x98);	
   111a8:	2098      	movs	r0, #152	; 0x98
   111aa:	f7ff fee9 	bl	10f80 <WriteData>
	WriteComm(0x89);	
   111ae:	2089      	movs	r0, #137	; 0x89
   111b0:	f7ff fed6 	bl	10f60 <WriteComm>
	WriteData(0x03);
   111b4:	2003      	movs	r0, #3
   111b6:	f7ff fee3 	bl	10f80 <WriteData>
	WriteComm(0x8b);	
   111ba:	208b      	movs	r0, #139	; 0x8b
   111bc:	f7ff fed0 	bl	10f60 <WriteComm>
	WriteData(0x80);	
   111c0:	2080      	movs	r0, #128	; 0x80
   111c2:	f7ff fedd 	bl	10f80 <WriteData>
	WriteComm(0x8d);	
   111c6:	208d      	movs	r0, #141	; 0x8d
   111c8:	f7ff feca 	bl	10f60 <WriteComm>
	WriteData(0x33);	
   111cc:	2033      	movs	r0, #51	; 0x33
   111ce:	f7ff fed7 	bl	10f80 <WriteData>
	WriteComm(0x8e);	
   111d2:	208e      	movs	r0, #142	; 0x8e
   111d4:	f7ff fec4 	bl	10f60 <WriteComm>
	WriteData(0x8f);	
   111d8:	208f      	movs	r0, #143	; 0x8f
   111da:	f7ff fed1 	bl	10f80 <WriteData>
	WriteComm(0xe8);
   111de:	20e8      	movs	r0, #232	; 0xe8
   111e0:	f7ff febe 	bl	10f60 <WriteComm>
	WriteData(0x12);
   111e4:	2012      	movs	r0, #18
   111e6:	f7ff fecb 	bl	10f80 <WriteData>
	WriteData(0x00);	
   111ea:	2000      	movs	r0, #0
   111ec:	f7ff fec8 	bl	10f80 <WriteData>
	WriteComm(0xc3);	
   111f0:	20c3      	movs	r0, #195	; 0xc3
   111f2:	f7ff feb5 	bl	10f60 <WriteComm>
	WriteData(0x20);
   111f6:	2020      	movs	r0, #32
   111f8:	f7ff fec2 	bl	10f80 <WriteData>
	WriteComm(0xc4);	
   111fc:	20c4      	movs	r0, #196	; 0xc4
   111fe:	f7ff feaf 	bl	10f60 <WriteComm>
	WriteData(0x30);
   11202:	2030      	movs	r0, #48	; 0x30
   11204:	f7ff febc 	bl	10f80 <WriteData>
	WriteComm(0xc9);	
   11208:	20c9      	movs	r0, #201	; 0xc9
   1120a:	f7ff fea9 	bl	10f60 <WriteComm>
	WriteData(0x08);
   1120e:	2008      	movs	r0, #8
   11210:	f7ff feb6 	bl	10f80 <WriteData>
	WriteComm(0xff);
   11214:	20ff      	movs	r0, #255	; 0xff
   11216:	f7ff fea3 	bl	10f60 <WriteComm>
	WriteData(0x62);
   1121a:	2062      	movs	r0, #98	; 0x62
   1121c:	f7ff feb0 	bl	10f80 <WriteData>
	WriteComm(0x99);	
   11220:	2099      	movs	r0, #153	; 0x99
   11222:	f7ff fe9d 	bl	10f60 <WriteComm>
	WriteData(0x3e);
   11226:	203e      	movs	r0, #62	; 0x3e
   11228:	f7ff feaa 	bl	10f80 <WriteData>
	WriteComm(0x9d);	
   1122c:	209d      	movs	r0, #157	; 0x9d
   1122e:	f7ff fe97 	bl	10f60 <WriteComm>
	WriteData(0x4b);
   11232:	204b      	movs	r0, #75	; 0x4b
   11234:	f7ff fea4 	bl	10f80 <WriteData>
	WriteComm(0x98);	
   11238:	2098      	movs	r0, #152	; 0x98
   1123a:	f7ff fe91 	bl	10f60 <WriteComm>
	WriteData(0x3e);
   1123e:	203e      	movs	r0, #62	; 0x3e
   11240:	f7ff fe9e 	bl	10f80 <WriteData>
	WriteComm(0x9c);	
   11244:	209c      	movs	r0, #156	; 0x9c
   11246:	f7ff fe8b 	bl	10f60 <WriteComm>
	WriteData(0x4b);
   1124a:	204b      	movs	r0, #75	; 0x4b
   1124c:	f7ff fe98 	bl	10f80 <WriteData>
	WriteComm(0xf0);
   11250:	20f0      	movs	r0, #240	; 0xf0
   11252:	f7ff fe85 	bl	10f60 <WriteComm>
	WriteData(0x13);
   11256:	2013      	movs	r0, #19
   11258:	f7ff fe92 	bl	10f80 <WriteData>
	WriteData(0x14);
   1125c:	2014      	movs	r0, #20
   1125e:	f7ff fe8f 	bl	10f80 <WriteData>
	lcd_is_sleeping = false;
   11262:	2400      	movs	r4, #0
	WriteData(0x07);
   11264:	2007      	movs	r0, #7
   11266:	f7ff fe8b 	bl	10f80 <WriteData>
	WriteData(0x05);
   1126a:	2005      	movs	r0, #5
   1126c:	f7ff fe88 	bl	10f80 <WriteData>
	WriteData(0xf0);
   11270:	20f0      	movs	r0, #240	; 0xf0
   11272:	f7ff fe85 	bl	10f80 <WriteData>
	WriteData(0x29);
   11276:	2029      	movs	r0, #41	; 0x29
   11278:	f7ff fe82 	bl	10f80 <WriteData>
	WriteComm(0xf1);
   1127c:	20f1      	movs	r0, #241	; 0xf1
   1127e:	f7ff fe6f 	bl	10f60 <WriteComm>
	WriteData(0x3e);
   11282:	203e      	movs	r0, #62	; 0x3e
   11284:	f7ff fe7c 	bl	10f80 <WriteData>
	WriteData(0x92);
   11288:	2092      	movs	r0, #146	; 0x92
   1128a:	f7ff fe79 	bl	10f80 <WriteData>
	WriteData(0x90);
   1128e:	2090      	movs	r0, #144	; 0x90
   11290:	f7ff fe76 	bl	10f80 <WriteData>
	WriteData(0x21);
   11294:	2021      	movs	r0, #33	; 0x21
   11296:	f7ff fe73 	bl	10f80 <WriteData>
	WriteData(0x23);
   1129a:	2023      	movs	r0, #35	; 0x23
   1129c:	f7ff fe70 	bl	10f80 <WriteData>
	WriteData(0x9f);
   112a0:	209f      	movs	r0, #159	; 0x9f
   112a2:	f7ff fe6d 	bl	10f80 <WriteData>
	WriteComm(0xf2);
   112a6:	20f2      	movs	r0, #242	; 0xf2
   112a8:	f7ff fe5a 	bl	10f60 <WriteComm>
	WriteData(0x13);
   112ac:	2013      	movs	r0, #19
   112ae:	f7ff fe67 	bl	10f80 <WriteData>
	WriteData(0x14);
   112b2:	2014      	movs	r0, #20
   112b4:	f7ff fe64 	bl	10f80 <WriteData>
	WriteData(0x07);
   112b8:	2007      	movs	r0, #7
   112ba:	f7ff fe61 	bl	10f80 <WriteData>
	WriteData(0x05);
   112be:	2005      	movs	r0, #5
   112c0:	f7ff fe5e 	bl	10f80 <WriteData>
	WriteData(0xf0);
   112c4:	20f0      	movs	r0, #240	; 0xf0
   112c6:	f7ff fe5b 	bl	10f80 <WriteData>
	WriteData(0x29);
   112ca:	2029      	movs	r0, #41	; 0x29
   112cc:	f7ff fe58 	bl	10f80 <WriteData>
	WriteComm(0xf3);
   112d0:	20f3      	movs	r0, #243	; 0xf3
   112d2:	f7ff fe45 	bl	10f60 <WriteComm>
	WriteData(0x3e);
   112d6:	203e      	movs	r0, #62	; 0x3e
   112d8:	f7ff fe52 	bl	10f80 <WriteData>
	WriteData(0x92);
   112dc:	2092      	movs	r0, #146	; 0x92
   112de:	f7ff fe4f 	bl	10f80 <WriteData>
	WriteData(0x90);
   112e2:	2090      	movs	r0, #144	; 0x90
   112e4:	f7ff fe4c 	bl	10f80 <WriteData>
	WriteData(0x21);
   112e8:	2021      	movs	r0, #33	; 0x21
   112ea:	f7ff fe49 	bl	10f80 <WriteData>
	WriteData(0x23);
   112ee:	2023      	movs	r0, #35	; 0x23
   112f0:	f7ff fe46 	bl	10f80 <WriteData>
	WriteData(0x9f);
   112f4:	209f      	movs	r0, #159	; 0x9f
   112f6:	f7ff fe43 	bl	10f80 <WriteData>
	WriteComm(0x11);
   112fa:	2011      	movs	r0, #17
   112fc:	f7ff fe30 	bl	10f60 <WriteComm>
	k_sleep(K_MSEC(dly));
   11300:	2078      	movs	r0, #120	; 0x78
   11302:	f01a f956 	bl	2b5b2 <k_sleep>
	WriteComm(0x29);
   11306:	2029      	movs	r0, #41	; 0x29
   11308:	f7ff fe2a 	bl	10f60 <WriteComm>
	WriteComm(0x2c);
   1130c:	202c      	movs	r0, #44	; 0x2c
   1130e:	f7ff fe27 	bl	10f60 <WriteComm>
	LCD_Clear(BLACK);		//
   11312:	2000      	movs	r0, #0
   11314:	f01a f99b 	bl	2b64e <LCD_Clear>
	k_sleep(K_MSEC(dly));
   11318:	2014      	movs	r0, #20
   1131a:	f01a f94a 	bl	2b5b2 <k_sleep>
	Set_Screen_Backlight_On();
   1131e:	f01b fc54 	bl	2cbca <Set_Screen_Backlight_On>
	lcd_is_sleeping = false;
   11322:	4b1c      	ldr	r3, [pc, #112]	; (11394 <LCD_Init+0x2b8>)
	k_timer_init(&backlight_timer, backlight_timer_handler, NULL);
   11324:	4622      	mov	r2, r4
   11326:	491c      	ldr	r1, [pc, #112]	; (11398 <LCD_Init+0x2bc>)
   11328:	481c      	ldr	r0, [pc, #112]	; (1139c <LCD_Init+0x2c0>)
	lcd_is_sleeping = false;
   1132a:	701c      	strb	r4, [r3, #0]
	k_timer_init(&backlight_timer, backlight_timer_handler, NULL);
   1132c:	f01d ff63 	bl	2f1f6 <k_timer_init>
	if(global_settings.backlight_time != 0)
   11330:	4b1b      	ldr	r3, [pc, #108]	; (113a0 <LCD_Init+0x2c4>)
   11332:	899b      	ldrh	r3, [r3, #12]
   11334:	b1f3      	cbz	r3, 11374 <LCD_Init+0x298>
   11336:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   1133a:	4622      	mov	r2, r4
   1133c:	4359      	muls	r1, r3
}
   1133e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   11342:	4816      	ldr	r0, [pc, #88]	; (1139c <LCD_Init+0x2c0>)
   11344:	f017 bf7e 	b.w	29244 <z_impl_k_timer_start>
	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
   11348:	f44f 7380 	mov.w	r3, #256	; 0x100
	spi_cfg.frequency = 4000000;
   1134c:	4d15      	ldr	r5, [pc, #84]	; (113a4 <LCD_Init+0x2c8>)
	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
   1134e:	4816      	ldr	r0, [pc, #88]	; (113a8 <LCD_Init+0x2cc>)
   11350:	e9c5 0300 	strd	r0, r3, [r5]
   11354:	4809      	ldr	r0, [pc, #36]	; (1137c <LCD_Init+0x2a0>)
   11356:	f014 ff37 	bl	261c8 <z_impl_device_get_binding>
	spi_cs_ctr.gpio_dev = device_get_binding(LCD_PORT);
   1135a:	4b14      	ldr	r3, [pc, #80]	; (113ac <LCD_Init+0x2d0>)
   1135c:	6018      	str	r0, [r3, #0]
	if (!spi_cs_ctr.gpio_dev)
   1135e:	b918      	cbnz	r0, 11368 <LCD_Init+0x28c>
		printk("Unable to get GPIO SPI CS device\n");
   11360:	4813      	ldr	r0, [pc, #76]	; (113b0 <LCD_Init+0x2d4>)
   11362:	f01b ff72 	bl	2d24a <printk>
		return;
   11366:	e6ec      	b.n	11142 <LCD_Init+0x66>
	spi_cs_ctr.delay = 0U;
   11368:	2117      	movs	r1, #23
   1136a:	2200      	movs	r2, #0
	spi_cfg.cs = &spi_cs_ctr;
   1136c:	60ab      	str	r3, [r5, #8]
	spi_cs_ctr.delay = 0U;
   1136e:	e9c3 1201 	strd	r1, r2, [r3, #4]
	spi_cfg.cs = &spi_cs_ctr;
   11372:	e6e6      	b.n	11142 <LCD_Init+0x66>
}
   11374:	bd38      	pop	{r3, r4, r5, pc}
   11376:	bf00      	nop
   11378:	000310cd 	.word	0x000310cd
   1137c:	000310d7 	.word	0x000310d7
   11380:	20020b98 	.word	0x20020b98
   11384:	000310de 	.word	0x000310de
   11388:	000310f7 	.word	0x000310f7
   1138c:	20020bc4 	.word	0x20020bc4
   11390:	000310fd 	.word	0x000310fd
   11394:	2003b5ac 	.word	0x2003b5ac
   11398:	00010ee9 	.word	0x00010ee9
   1139c:	20020b6c 	.word	0x20020b6c
   113a0:	2002d422 	.word	0x2002d422
   113a4:	20020bac 	.word	0x20020bac
   113a8:	003d0900 	.word	0x003d0900
   113ac:	20020bb8 	.word	0x20020bb8
   113b0:	00031116 	.word	0x00031116

000113b4 <key_event_handler>:

static void key_event_handler(u8_t key_code, u8_t key_type)
{
	//LOG_INF("key_code:%d, key_type:%d, KEY_SOS:%d,KEY_PWR:%d\n", key_code, key_type,	KEY_SOS, KEY_PWR);

	switch(key_code)
   113b4:	2801      	cmp	r0, #1
{
   113b6:	b508      	push	{r3, lr}
	switch(key_code)
   113b8:	d003      	beq.n	113c2 <key_event_handler+0xe>
   113ba:	2802      	cmp	r0, #2
   113bc:	d00e      	beq.n	113dc <key_event_handler+0x28>
		}
		break;	
	}

	//power key will wakeup lcd
	if(key_type == KEY_UP)
   113be:	b119      	cbz	r1, 113c8 <key_event_handler+0x14>
   113c0:	e011      	b.n	113e6 <key_event_handler+0x32>
		switch(key_type)
   113c2:	b981      	cbnz	r1, 113e6 <key_event_handler+0x32>
			SOSStart();
   113c4:	f006 f8aa 	bl	1751c <SOSStart>
	{
		sleep_out_by_wrist = false;
   113c8:	2200      	movs	r2, #0
   113ca:	4b0f      	ldr	r3, [pc, #60]	; (11408 <key_event_handler+0x54>)
   113cc:	701a      	strb	r2, [r3, #0]
		
		if(lcd_is_sleeping)
   113ce:	4b0f      	ldr	r3, [pc, #60]	; (1140c <key_event_handler+0x58>)
   113d0:	781a      	ldrb	r2, [r3, #0]
   113d2:	2301      	movs	r3, #1
   113d4:	b1aa      	cbz	r2, 11402 <key_event_handler+0x4e>
			lcd_sleep_out = true;
   113d6:	4a0e      	ldr	r2, [pc, #56]	; (11410 <key_event_handler+0x5c>)
		else
			lcd_sleep_in = true;
   113d8:	7013      	strb	r3, [r2, #0]
   113da:	e004      	b.n	113e6 <key_event_handler+0x32>
		switch(key_type)
   113dc:	2902      	cmp	r1, #2
   113de:	d1ee      	bne.n	113be <key_event_handler+0xa>
			sys_pwr_off = true;
   113e0:	2201      	movs	r2, #1
   113e2:	4b0c      	ldr	r3, [pc, #48]	; (11414 <key_event_handler+0x60>)
   113e4:	701a      	strb	r2, [r3, #0]
	}

	if(alarm_is_running)
   113e6:	4b0c      	ldr	r3, [pc, #48]	; (11418 <key_event_handler+0x64>)
   113e8:	781b      	ldrb	r3, [r3, #0]
   113ea:	b10b      	cbz	r3, 113f0 <key_event_handler+0x3c>
	{
		AlarmRemindStop();
   113ec:	f7ff fa7c 	bl	108e8 <AlarmRemindStop>
	}

	if(find_is_running)
   113f0:	4b0a      	ldr	r3, [pc, #40]	; (1141c <key_event_handler+0x68>)
   113f2:	781b      	ldrb	r3, [r3, #0]
   113f4:	b10b      	cbz	r3, 113fa <key_event_handler+0x46>
	{
		FindDeviceStop();
   113f6:	f7ff fb0f 	bl	10a18 <FindDeviceStop>
	}

	ExitNotifyScreen();
}
   113fa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	ExitNotifyScreen();
   113fe:	f004 bfa5 	b.w	1634c <ExitNotifyScreen>
			lcd_sleep_in = true;
   11402:	4a07      	ldr	r2, [pc, #28]	; (11420 <key_event_handler+0x6c>)
   11404:	e7e8      	b.n	113d8 <key_event_handler+0x24>
   11406:	bf00      	nop
   11408:	2002d49c 	.word	0x2002d49c
   1140c:	2003b5ac 	.word	0x2003b5ac
   11410:	2002d49b 	.word	0x2002d49b
   11414:	2002ff9b 	.word	0x2002ff9b
   11418:	2002d495 	.word	0x2002d495
   1141c:	2002d498 	.word	0x2002d498
   11420:	2002d49a 	.word	0x2002d49a

00011424 <long_press_timer_handler>:
	key_event_handler(keycode, keytype);
}

static void long_press_timer_handler(struct k_timer *timer)
{
    key_event_handler(keycode, KEY_LONG_PRESS);
   11424:	4b02      	ldr	r3, [pc, #8]	; (11430 <long_press_timer_handler+0xc>)
   11426:	2102      	movs	r1, #2
   11428:	7818      	ldrb	r0, [r3, #0]
   1142a:	f7ff bfc3 	b.w	113b4 <key_event_handler>
   1142e:	bf00      	nop
   11430:	20020c50 	.word	0x20020c50

00011434 <button_handler>:
{
   11434:	b538      	push	{r3, r4, r5, lr}
   11436:	4602      	mov	r2, r0
	u32_t buttons = (button_state & has_changed);
   11438:	ea00 0501 	and.w	r5, r0, r1
	LOG_INF("button_state:%d, has_changed:%d\n", button_state, has_changed);
   1143c:	2303      	movs	r3, #3
   1143e:	f04f 0000 	mov.w	r0, #0
{
   11442:	460c      	mov	r4, r1
	LOG_INF("button_state:%d, has_changed:%d\n", button_state, has_changed);
   11444:	f363 0007 	bfi	r0, r3, #0, #8
   11448:	4912      	ldr	r1, [pc, #72]	; (11494 <button_handler+0x60>)
   1144a:	4b13      	ldr	r3, [pc, #76]	; (11498 <button_handler+0x64>)
   1144c:	1a5b      	subs	r3, r3, r1
   1144e:	08db      	lsrs	r3, r3, #3
   11450:	4912      	ldr	r1, [pc, #72]	; (1149c <button_handler+0x68>)
   11452:	f363 108f 	bfi	r0, r3, #6, #10
   11456:	4623      	mov	r3, r4
   11458:	f01b ff4e 	bl	2d2f8 <log_string_sync>
	keytype = (buttons>0 ? KEY_DOWN:KEY_UP);
   1145c:	2d00      	cmp	r5, #0
   1145e:	bf14      	ite	ne
   11460:	2101      	movne	r1, #1
   11462:	2100      	moveq	r1, #0
	keycode = has_changed;
   11464:	4b0e      	ldr	r3, [pc, #56]	; (114a0 <button_handler+0x6c>)
	keytype = (buttons>0 ? KEY_DOWN:KEY_UP);
   11466:	4a0f      	ldr	r2, [pc, #60]	; (114a4 <button_handler+0x70>)
	keycode = has_changed;
   11468:	601c      	str	r4, [r3, #0]
	keytype = (buttons>0 ? KEY_DOWN:KEY_UP);
   1146a:	6011      	str	r1, [r2, #0]
	switch(keytype)
   1146c:	461c      	mov	r4, r3
   1146e:	4615      	mov	r5, r2
   11470:	d00b      	beq.n	1148a <button_handler+0x56>
   11472:	2200      	movs	r2, #0
   11474:	f241 3188 	movw	r1, #5000	; 0x1388
   11478:	480b      	ldr	r0, [pc, #44]	; (114a8 <button_handler+0x74>)
   1147a:	f017 fee3 	bl	29244 <z_impl_k_timer_start>
	key_event_handler(keycode, keytype);
   1147e:	7829      	ldrb	r1, [r5, #0]
   11480:	7820      	ldrb	r0, [r4, #0]
}
   11482:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	key_event_handler(keycode, keytype);
   11486:	f7ff bf95 	b.w	113b4 <key_event_handler>
	z_impl_k_timer_stop(timer);
   1148a:	4807      	ldr	r0, [pc, #28]	; (114a8 <button_handler+0x74>)
   1148c:	f01d febf 	bl	2f20e <z_impl_k_timer_stop>
   11490:	e7f5      	b.n	1147e <button_handler+0x4a>
   11492:	bf00      	nop
   11494:	0003040c 	.word	0x0003040c
   11498:	00030484 	.word	0x00030484
   1149c:	00031147 	.word	0x00031147
   114a0:	20020c50 	.word	0x20020c50
   114a4:	20020c54 	.word	0x20020c54
   114a8:	20020c18 	.word	0x20020c18

000114ac <button_pressed>:

	last_state = current_state;
}

static void button_pressed(struct device *gpio_dev, struct gpio_callback *cb, u32_t pins)
{
   114ac:	b538      	push	{r3, r4, r5, lr}
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
   114ae:	f04f 0320 	mov.w	r3, #32
   114b2:	f3ef 8411 	mrs	r4, BASEPRI
   114b6:	f383 8811 	msr	BASEPRI, r3
   114ba:	f3bf 8f6f 	isb	sy
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   114be:	4833      	ldr	r0, [pc, #204]	; (1158c <button_pressed+0xe0>)
   114c0:	f017 f912 	bl	286e8 <z_spin_lock_valid>
   114c4:	b968      	cbnz	r0, 114e2 <button_pressed+0x36>
   114c6:	234a      	movs	r3, #74	; 0x4a
   114c8:	4a31      	ldr	r2, [pc, #196]	; (11590 <button_pressed+0xe4>)
   114ca:	4932      	ldr	r1, [pc, #200]	; (11594 <button_pressed+0xe8>)
   114cc:	4832      	ldr	r0, [pc, #200]	; (11598 <button_pressed+0xec>)
   114ce:	f01b febc 	bl	2d24a <printk>
   114d2:	492e      	ldr	r1, [pc, #184]	; (1158c <button_pressed+0xe0>)
   114d4:	4831      	ldr	r0, [pc, #196]	; (1159c <button_pressed+0xf0>)
   114d6:	f01b feb8 	bl	2d24a <printk>
   114da:	214a      	movs	r1, #74	; 0x4a
   114dc:	482c      	ldr	r0, [pc, #176]	; (11590 <button_pressed+0xe4>)
   114de:	f01b fefa 	bl	2d2d6 <assert_post_action>
			err = gpio_pin_disable_callback(button_devs[i], button_pins[i].number);
   114e2:	4d2f      	ldr	r5, [pc, #188]	; (115a0 <button_pressed+0xf4>)
	while (!atomic_cas(&l->locked, 0, 1)) {
	}
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
   114e4:	4829      	ldr	r0, [pc, #164]	; (1158c <button_pressed+0xe0>)
   114e6:	f017 f91d 	bl	28724 <z_spin_lock_set_owner>
   114ea:	6828      	ldr	r0, [r5, #0]
					      int access_op, u32_t pin)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	if (api->disable_callback == NULL) {
   114ec:	6843      	ldr	r3, [r0, #4]
   114ee:	695b      	ldr	r3, [r3, #20]
   114f0:	2b00      	cmp	r3, #0
   114f2:	d12e      	bne.n	11552 <button_pressed+0xa6>
	/* Disable GPIO interrupt */
	int err = callback_ctrl(false);

	if(err)
	{
		LOG_INF("Cannot disable callbacks");
   114f4:	2303      	movs	r3, #3
   114f6:	f04f 0000 	mov.w	r0, #0
   114fa:	4a2a      	ldr	r2, [pc, #168]	; (115a4 <button_pressed+0xf8>)
   114fc:	f363 0007 	bfi	r0, r3, #0, #8
   11500:	4b29      	ldr	r3, [pc, #164]	; (115a8 <button_pressed+0xfc>)
   11502:	492a      	ldr	r1, [pc, #168]	; (115ac <button_pressed+0x100>)
   11504:	1a9b      	subs	r3, r3, r2
   11506:	08db      	lsrs	r3, r3, #3
   11508:	f363 108f 	bfi	r0, r3, #6, #10
   1150c:	f01b fef4 	bl	2d2f8 <log_string_sync>
	}

	switch (state)
   11510:	4b27      	ldr	r3, [pc, #156]	; (115b0 <button_pressed+0x104>)
   11512:	781a      	ldrb	r2, [r3, #0]
   11514:	2a00      	cmp	r2, #0
   11516:	d12c      	bne.n	11572 <button_pressed+0xc6>
	{
	case STATE_WAITING:
		state = STATE_SCANNING;
   11518:	2201      	movs	r2, #1
 * @req K-DWORK-001
 */
static inline int k_delayed_work_submit(struct k_delayed_work *work,
					s32_t delay)
{
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   1151a:	4926      	ldr	r1, [pc, #152]	; (115b4 <button_pressed+0x108>)
   1151c:	4826      	ldr	r0, [pc, #152]	; (115b8 <button_pressed+0x10c>)
   1151e:	701a      	strb	r2, [r3, #0]
   11520:	f017 fab6 	bl	28a90 <k_delayed_work_submit_to_queue>
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   11524:	4819      	ldr	r0, [pc, #100]	; (1158c <button_pressed+0xe0>)
   11526:	f017 f8ed 	bl	28704 <z_spin_unlock_valid>
   1152a:	b968      	cbnz	r0, 11548 <button_pressed+0x9c>
   1152c:	235d      	movs	r3, #93	; 0x5d
   1152e:	4a18      	ldr	r2, [pc, #96]	; (11590 <button_pressed+0xe4>)
   11530:	4922      	ldr	r1, [pc, #136]	; (115bc <button_pressed+0x110>)
   11532:	4819      	ldr	r0, [pc, #100]	; (11598 <button_pressed+0xec>)
   11534:	f01b fe89 	bl	2d24a <printk>
   11538:	4914      	ldr	r1, [pc, #80]	; (1158c <button_pressed+0xe0>)
   1153a:	4821      	ldr	r0, [pc, #132]	; (115c0 <button_pressed+0x114>)
   1153c:	f01b fe85 	bl	2d24a <printk>
   11540:	215d      	movs	r1, #93	; 0x5d
   11542:	4813      	ldr	r0, [pc, #76]	; (11590 <button_pressed+0xe4>)
   11544:	f01b fec7 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   11548:	f384 8811 	msr	BASEPRI, r4
   1154c:	f3bf 8f6f 	isb	sy
		__ASSERT_NO_MSG(false);
		break;
	}

	k_spin_unlock(&lock, key);
}
   11550:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOTSUP;
	}

	return api->disable_callback(port, access_op, pin);
   11552:	2100      	movs	r1, #0
   11554:	221a      	movs	r2, #26
   11556:	4798      	blx	r3
	for(size_t i = 0; (i < ARRAY_SIZE(button_pins)) && !err; i++)
   11558:	4601      	mov	r1, r0
   1155a:	2800      	cmp	r0, #0
   1155c:	d1ca      	bne.n	114f4 <button_pressed+0x48>
			err = gpio_pin_disable_callback(button_devs[i], button_pins[i].number);
   1155e:	6868      	ldr	r0, [r5, #4]
	if (api->disable_callback == NULL) {
   11560:	6843      	ldr	r3, [r0, #4]
   11562:	695b      	ldr	r3, [r3, #20]
   11564:	2b00      	cmp	r3, #0
   11566:	d0c5      	beq.n	114f4 <button_pressed+0x48>
	return api->disable_callback(port, access_op, pin);
   11568:	220f      	movs	r2, #15
   1156a:	4798      	blx	r3
	if(err)
   1156c:	2800      	cmp	r0, #0
   1156e:	d0cf      	beq.n	11510 <button_pressed+0x64>
   11570:	e7c0      	b.n	114f4 <button_pressed+0x48>
		__ASSERT_NO_MSG(false);
   11572:	f44f 73ac 	mov.w	r3, #344	; 0x158
   11576:	4a13      	ldr	r2, [pc, #76]	; (115c4 <button_pressed+0x118>)
   11578:	4913      	ldr	r1, [pc, #76]	; (115c8 <button_pressed+0x11c>)
   1157a:	4807      	ldr	r0, [pc, #28]	; (11598 <button_pressed+0xec>)
   1157c:	f01b fe65 	bl	2d24a <printk>
   11580:	f44f 71ac 	mov.w	r1, #344	; 0x158
   11584:	480f      	ldr	r0, [pc, #60]	; (115c4 <button_pressed+0x118>)
   11586:	f01b fea6 	bl	2d2d6 <assert_post_action>
		break;
   1158a:	e7cb      	b.n	11524 <button_pressed+0x78>
   1158c:	20020c60 	.word	0x20020c60
   11590:	00031168 	.word	0x00031168
   11594:	0003118e 	.word	0x0003118e
   11598:	000311a3 	.word	0x000311a3
   1159c:	000311c0 	.word	0x000311c0
   115a0:	20020bd8 	.word	0x20020bd8
   115a4:	0003040c 	.word	0x0003040c
   115a8:	00030484 	.word	0x00030484
   115ac:	000311d8 	.word	0x000311d8
   115b0:	2002f49d 	.word	0x2002f49d
   115b4:	20020bf8 	.word	0x20020bf8
   115b8:	2002d330 	.word	0x2002d330
   115bc:	00031202 	.word	0x00031202
   115c0:	00031219 	.word	0x00031219
   115c4:	000311f1 	.word	0x000311f1
   115c8:	0003495a 	.word	0x0003495a

000115cc <buttons_scan_fn>:
{
   115cc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   115d0:	2500      	movs	r5, #0
   115d2:	f8df 9214 	ldr.w	r9, [pc, #532]	; 117e8 <buttons_scan_fn+0x21c>
	u32_t ret = 0;
   115d6:	462c      	mov	r4, r5
	for(size_t i = 0; i < ARRAY_SIZE(button_pins); i++)
   115d8:	46a8      	mov	r8, r5
   115da:	464f      	mov	r7, r9
			ret |= 1U << i;
   115dc:	f04f 0a01 	mov.w	sl, #1
   115e0:	4e6a      	ldr	r6, [pc, #424]	; (1178c <buttons_scan_fn+0x1c0>)
		if(gpio_pin_read(button_devs[i], button_pins[i].number, &val))
   115e2:	f859 0b04 	ldr.w	r0, [r9], #4
   115e6:	7932      	ldrb	r2, [r6, #4]
	return api->read(port, access_op, pin, value);
   115e8:	6843      	ldr	r3, [r0, #4]
   115ea:	2100      	movs	r1, #0
   115ec:	f8d3 b008 	ldr.w	fp, [r3, #8]
   115f0:	ab01      	add	r3, sp, #4
   115f2:	47d8      	blx	fp
   115f4:	2800      	cmp	r0, #0
   115f6:	d044      	beq.n	11682 <buttons_scan_fn+0xb6>
			LOG_INF("Cannot read gpio pin");
   115f8:	2303      	movs	r3, #3
   115fa:	f04f 0000 	mov.w	r0, #0
   115fe:	4a64      	ldr	r2, [pc, #400]	; (11790 <buttons_scan_fn+0x1c4>)
   11600:	f363 0007 	bfi	r0, r3, #0, #8
   11604:	4b63      	ldr	r3, [pc, #396]	; (11794 <buttons_scan_fn+0x1c8>)
   11606:	4964      	ldr	r1, [pc, #400]	; (11798 <buttons_scan_fn+0x1cc>)
   11608:	1a9b      	subs	r3, r3, r2
   1160a:	08db      	lsrs	r3, r3, #3
   1160c:	f363 108f 	bfi	r0, r3, #6, #10
   11610:	f01b fe72 	bl	2d2f8 <log_string_sync>
			return 0;
   11614:	2400      	movs	r4, #0
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   11616:	4b61      	ldr	r3, [pc, #388]	; (1179c <buttons_scan_fn+0x1d0>)
   11618:	e8d3 2fef 	ldaex	r2, [r3]
   1161c:	e8c3 4fe1 	stlex	r1, r4, [r3]
   11620:	2900      	cmp	r1, #0
   11622:	d1f9      	bne.n	11618 <buttons_scan_fn+0x4c>
	if(!initial_run)
   11624:	4b5e      	ldr	r3, [pc, #376]	; (117a0 <buttons_scan_fn+0x1d4>)
   11626:	4d5f      	ldr	r5, [pc, #380]	; (117a4 <buttons_scan_fn+0x1d8>)
   11628:	781a      	ldrb	r2, [r3, #0]
   1162a:	2a00      	cmp	r2, #0
   1162c:	d140      	bne.n	116b0 <buttons_scan_fn+0xe4>
		if(button_scan != last_button_scan)
   1162e:	6829      	ldr	r1, [r5, #0]
   11630:	42a1      	cmp	r1, r4
   11632:	d00d      	beq.n	11650 <buttons_scan_fn+0x84>
	if(button_handler_cb != NULL)
   11634:	4b5c      	ldr	r3, [pc, #368]	; (117a8 <buttons_scan_fn+0x1dc>)
   11636:	681b      	ldr	r3, [r3, #0]
   11638:	b113      	cbz	r3, 11640 <buttons_scan_fn+0x74>
		button_handler_cb(button_state, has_changed);
   1163a:	4061      	eors	r1, r4
   1163c:	4620      	mov	r0, r4
   1163e:	4798      	blx	r3
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&mutex, *(uintptr_t *)&timeout, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
   11640:	f04f 31ff 	mov.w	r1, #4294967295
   11644:	4859      	ldr	r0, [pc, #356]	; (117ac <buttons_scan_fn+0x1e0>)
   11646:	f015 faa3 	bl	26b90 <z_impl_k_mutex_lock>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke1(*(uintptr_t *)&mutex, K_SYSCALL_K_MUTEX_UNLOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_unlock(mutex);
   1164a:	4858      	ldr	r0, [pc, #352]	; (117ac <buttons_scan_fn+0x1e0>)
   1164c:	f015 fb7e 	bl	26d4c <z_impl_k_mutex_unlock>
	last_button_scan = button_scan;
   11650:	602c      	str	r4, [r5, #0]
	if (button_scan != 0)
   11652:	b384      	cbz	r4, 116b6 <buttons_scan_fn+0xea>
   11654:	220a      	movs	r2, #10
   11656:	4956      	ldr	r1, [pc, #344]	; (117b0 <buttons_scan_fn+0x1e4>)
   11658:	4856      	ldr	r0, [pc, #344]	; (117b4 <buttons_scan_fn+0x1e8>)
   1165a:	f017 fa19 	bl	28a90 <k_delayed_work_submit_to_queue>
		if(err)
   1165e:	b168      	cbz	r0, 1167c <buttons_scan_fn+0xb0>
			LOG_INF("Cannot add work to workqueue");
   11660:	2303      	movs	r3, #3
   11662:	f04f 0000 	mov.w	r0, #0
   11666:	4a4a      	ldr	r2, [pc, #296]	; (11790 <buttons_scan_fn+0x1c4>)
   11668:	f363 0007 	bfi	r0, r3, #0, #8
   1166c:	4b49      	ldr	r3, [pc, #292]	; (11794 <buttons_scan_fn+0x1c8>)
   1166e:	4952      	ldr	r1, [pc, #328]	; (117b8 <buttons_scan_fn+0x1ec>)
   11670:	1a9b      	subs	r3, r3, r2
   11672:	08db      	lsrs	r3, r3, #3
   11674:	f363 108f 	bfi	r0, r3, #6, #10
			LOG_INF("Cannot enable callbacks");
   11678:	f01b fe3e 	bl	2d2f8 <log_string_sync>
}
   1167c:	b003      	add	sp, #12
   1167e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		switch(button_pins[i].active_flag)
   11682:	7973      	ldrb	r3, [r6, #5]
   11684:	b163      	cbz	r3, 116a0 <buttons_scan_fn+0xd4>
			actived_low = false;
   11686:	2b01      	cmp	r3, #1
   11688:	bf08      	it	eq
   1168a:	2500      	moveq	r5, #0
		if((!val && actived_low)||
   1168c:	9b01      	ldr	r3, [sp, #4]
   1168e:	b94b      	cbnz	r3, 116a4 <buttons_scan_fn+0xd8>
   11690:	b955      	cbnz	r5, 116a8 <buttons_scan_fn+0xdc>
   11692:	3608      	adds	r6, #8
	for(size_t i = 0; i < ARRAY_SIZE(button_pins); i++)
   11694:	f1b8 0f00 	cmp.w	r8, #0
   11698:	d1bd      	bne.n	11616 <buttons_scan_fn+0x4a>
   1169a:	f04f 0801 	mov.w	r8, #1
   1169e:	e7a0      	b.n	115e2 <buttons_scan_fn+0x16>
			actived_low = true;
   116a0:	2501      	movs	r5, #1
   116a2:	e7f3      	b.n	1168c <buttons_scan_fn+0xc0>
			(val && !actived_low))
   116a4:	2d00      	cmp	r5, #0
   116a6:	d1f4      	bne.n	11692 <buttons_scan_fn+0xc6>
			ret |= 1U << i;
   116a8:	fa0a f308 	lsl.w	r3, sl, r8
   116ac:	431c      	orrs	r4, r3
   116ae:	e7f0      	b.n	11692 <buttons_scan_fn+0xc6>
		initial_run = false;
   116b0:	2200      	movs	r2, #0
   116b2:	701a      	strb	r2, [r3, #0]
   116b4:	e7cc      	b.n	11650 <buttons_scan_fn+0x84>
	__asm__ volatile(
   116b6:	f04f 0320 	mov.w	r3, #32
   116ba:	f3ef 8511 	mrs	r5, BASEPRI
   116be:	f383 8811 	msr	BASEPRI, r3
   116c2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   116c6:	483d      	ldr	r0, [pc, #244]	; (117bc <buttons_scan_fn+0x1f0>)
   116c8:	f017 f80e 	bl	286e8 <z_spin_lock_valid>
   116cc:	b968      	cbnz	r0, 116ea <buttons_scan_fn+0x11e>
   116ce:	234a      	movs	r3, #74	; 0x4a
   116d0:	4a3b      	ldr	r2, [pc, #236]	; (117c0 <buttons_scan_fn+0x1f4>)
   116d2:	493c      	ldr	r1, [pc, #240]	; (117c4 <buttons_scan_fn+0x1f8>)
   116d4:	483c      	ldr	r0, [pc, #240]	; (117c8 <buttons_scan_fn+0x1fc>)
   116d6:	f01b fdb8 	bl	2d24a <printk>
   116da:	4938      	ldr	r1, [pc, #224]	; (117bc <buttons_scan_fn+0x1f0>)
   116dc:	483b      	ldr	r0, [pc, #236]	; (117cc <buttons_scan_fn+0x200>)
   116de:	f01b fdb4 	bl	2d24a <printk>
   116e2:	214a      	movs	r1, #74	; 0x4a
   116e4:	4836      	ldr	r0, [pc, #216]	; (117c0 <buttons_scan_fn+0x1f4>)
   116e6:	f01b fdf6 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   116ea:	4834      	ldr	r0, [pc, #208]	; (117bc <buttons_scan_fn+0x1f0>)
   116ec:	f017 f81a 	bl	28724 <z_spin_lock_set_owner>
		switch (state)
   116f0:	4b37      	ldr	r3, [pc, #220]	; (117d0 <buttons_scan_fn+0x204>)
   116f2:	781a      	ldrb	r2, [r3, #0]
   116f4:	2a01      	cmp	r2, #1
   116f6:	d13b      	bne.n	11770 <buttons_scan_fn+0x1a4>
			state = STATE_WAITING;
   116f8:	2100      	movs	r1, #0
			err = gpio_pin_enable_callback(button_devs[i], button_pins[i].number);
   116fa:	6838      	ldr	r0, [r7, #0]
			state = STATE_WAITING;
   116fc:	7019      	strb	r1, [r3, #0]
	if (api->enable_callback == NULL) {
   116fe:	6843      	ldr	r3, [r0, #4]
   11700:	691b      	ldr	r3, [r3, #16]
   11702:	bb33      	cbnz	r3, 11752 <buttons_scan_fn+0x186>
		return -ENOTSUP;
   11704:	f06f 0485 	mvn.w	r4, #133	; 0x85
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   11708:	482c      	ldr	r0, [pc, #176]	; (117bc <buttons_scan_fn+0x1f0>)
   1170a:	f016 fffb 	bl	28704 <z_spin_unlock_valid>
   1170e:	b968      	cbnz	r0, 1172c <buttons_scan_fn+0x160>
   11710:	235d      	movs	r3, #93	; 0x5d
   11712:	4a2b      	ldr	r2, [pc, #172]	; (117c0 <buttons_scan_fn+0x1f4>)
   11714:	492f      	ldr	r1, [pc, #188]	; (117d4 <buttons_scan_fn+0x208>)
   11716:	482c      	ldr	r0, [pc, #176]	; (117c8 <buttons_scan_fn+0x1fc>)
   11718:	f01b fd97 	bl	2d24a <printk>
   1171c:	4927      	ldr	r1, [pc, #156]	; (117bc <buttons_scan_fn+0x1f0>)
   1171e:	482e      	ldr	r0, [pc, #184]	; (117d8 <buttons_scan_fn+0x20c>)
   11720:	f01b fd93 	bl	2d24a <printk>
   11724:	215d      	movs	r1, #93	; 0x5d
   11726:	4826      	ldr	r0, [pc, #152]	; (117c0 <buttons_scan_fn+0x1f4>)
   11728:	f01b fdd5 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   1172c:	f385 8811 	msr	BASEPRI, r5
   11730:	f3bf 8f6f 	isb	sy
		if(err)
   11734:	2c00      	cmp	r4, #0
   11736:	d0a1      	beq.n	1167c <buttons_scan_fn+0xb0>
			LOG_INF("Cannot enable callbacks");
   11738:	2303      	movs	r3, #3
   1173a:	f04f 0000 	mov.w	r0, #0
   1173e:	4a14      	ldr	r2, [pc, #80]	; (11790 <buttons_scan_fn+0x1c4>)
   11740:	f363 0007 	bfi	r0, r3, #0, #8
   11744:	4b13      	ldr	r3, [pc, #76]	; (11794 <buttons_scan_fn+0x1c8>)
   11746:	4925      	ldr	r1, [pc, #148]	; (117dc <buttons_scan_fn+0x210>)
   11748:	1a9b      	subs	r3, r3, r2
   1174a:	08db      	lsrs	r3, r3, #3
   1174c:	f363 108f 	bfi	r0, r3, #6, #10
   11750:	e792      	b.n	11678 <buttons_scan_fn+0xac>
	return api->enable_callback(port, access_op, pin);
   11752:	221a      	movs	r2, #26
   11754:	4798      	blx	r3
	for(size_t i = 0; (i < ARRAY_SIZE(button_pins)) && !err; i++)
   11756:	4604      	mov	r4, r0
   11758:	2800      	cmp	r0, #0
   1175a:	d1d5      	bne.n	11708 <buttons_scan_fn+0x13c>
			err = gpio_pin_enable_callback(button_devs[i], button_pins[i].number);
   1175c:	6878      	ldr	r0, [r7, #4]
	if (api->enable_callback == NULL) {
   1175e:	6843      	ldr	r3, [r0, #4]
   11760:	691b      	ldr	r3, [r3, #16]
   11762:	2b00      	cmp	r3, #0
   11764:	d0ce      	beq.n	11704 <buttons_scan_fn+0x138>
	return api->enable_callback(port, access_op, pin);
   11766:	4621      	mov	r1, r4
   11768:	220f      	movs	r2, #15
   1176a:	4798      	blx	r3
   1176c:	4604      	mov	r4, r0
   1176e:	e7cb      	b.n	11708 <buttons_scan_fn+0x13c>
			__ASSERT_NO_MSG(false);
   11770:	f240 1313 	movw	r3, #275	; 0x113
   11774:	4a1a      	ldr	r2, [pc, #104]	; (117e0 <buttons_scan_fn+0x214>)
   11776:	491b      	ldr	r1, [pc, #108]	; (117e4 <buttons_scan_fn+0x218>)
   11778:	4813      	ldr	r0, [pc, #76]	; (117c8 <buttons_scan_fn+0x1fc>)
   1177a:	f01b fd66 	bl	2d24a <printk>
   1177e:	f240 1113 	movw	r1, #275	; 0x113
   11782:	4817      	ldr	r0, [pc, #92]	; (117e0 <buttons_scan_fn+0x214>)
   11784:	f01b fda7 	bl	2d2d6 <assert_post_action>
		int err = 0;
   11788:	2400      	movs	r4, #0
   1178a:	e7bd      	b.n	11708 <buttons_scan_fn+0x13c>
   1178c:	00030838 	.word	0x00030838
   11790:	0003040c 	.word	0x0003040c
   11794:	00030484 	.word	0x00030484
   11798:	0003122e 	.word	0x0003122e
   1179c:	20020c64 	.word	0x20020c64
   117a0:	2003b5ae 	.word	0x2003b5ae
   117a4:	20020c58 	.word	0x20020c58
   117a8:	20020be0 	.word	0x20020be0
   117ac:	20020be4 	.word	0x20020be4
   117b0:	20020bf8 	.word	0x20020bf8
   117b4:	2002d330 	.word	0x2002d330
   117b8:	00031243 	.word	0x00031243
   117bc:	20020c60 	.word	0x20020c60
   117c0:	00031168 	.word	0x00031168
   117c4:	0003118e 	.word	0x0003118e
   117c8:	000311a3 	.word	0x000311a3
   117cc:	000311c0 	.word	0x000311c0
   117d0:	2002f49d 	.word	0x2002f49d
   117d4:	00031202 	.word	0x00031202
   117d8:	00031219 	.word	0x00031219
   117dc:	00031260 	.word	0x00031260
   117e0:	000311f1 	.word	0x000311f1
   117e4:	0003495a 	.word	0x0003495a
   117e8:	20020bd8 	.word	0x20020bd8

000117ec <key_init>:

	return 0;
}

void key_init(void)
{
   117ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int err;

	LOG_INF("key_init\n");
   117ee:	f04f 0000 	mov.w	r0, #0
   117f2:	2303      	movs	r3, #3
   117f4:	4d6a      	ldr	r5, [pc, #424]	; (119a0 <key_init+0x1b4>)
   117f6:	f363 0007 	bfi	r0, r3, #0, #8
   117fa:	4b6a      	ldr	r3, [pc, #424]	; (119a4 <key_init+0x1b8>)
   117fc:	496a      	ldr	r1, [pc, #424]	; (119a8 <key_init+0x1bc>)
   117fe:	1aed      	subs	r5, r5, r3
   11800:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   11804:	f365 108f 	bfi	r0, r5, #6, #10
   11808:	f01b fd76 	bl	2d2f8 <log_string_sync>
	button_handler_cb = button_handler;
   1180c:	4b67      	ldr	r3, [pc, #412]	; (119ac <key_init+0x1c0>)
   1180e:	4a68      	ldr	r2, [pc, #416]	; (119b0 <key_init+0x1c4>)
   11810:	601a      	str	r2, [r3, #0]
	return z_impl_k_mutex_init(mutex);
   11812:	4868      	ldr	r0, [pc, #416]	; (119b4 <key_init+0x1c8>)
   11814:	f01d fbe9 	bl	2efea <z_impl_k_mutex_init>
   11818:	4867      	ldr	r0, [pc, #412]	; (119b8 <key_init+0x1cc>)
   1181a:	f014 fcd5 	bl	261c8 <z_impl_device_get_binding>
		button_devs[i] = device_get_binding(button_pins[i].port);
   1181e:	4e67      	ldr	r6, [pc, #412]	; (119bc <key_init+0x1d0>)
   11820:	6030      	str	r0, [r6, #0]
		if (!button_devs[i])
   11822:	b350      	cbz	r0, 1187a <key_init+0x8e>
	return api->config(port, access_op, pin, flags);
   11824:	6843      	ldr	r3, [r0, #4]
   11826:	221a      	movs	r2, #26
   11828:	681c      	ldr	r4, [r3, #0]
   1182a:	2100      	movs	r1, #0
   1182c:	f44f 7380 	mov.w	r3, #256	; 0x100
   11830:	47a0      	blx	r4
		if(err)
   11832:	4604      	mov	r4, r0
   11834:	2800      	cmp	r0, #0
   11836:	d139      	bne.n	118ac <key_init+0xc0>
   11838:	485f      	ldr	r0, [pc, #380]	; (119b8 <key_init+0x1cc>)
   1183a:	f014 fcc5 	bl	261c8 <z_impl_device_get_binding>
		button_devs[i] = device_get_binding(button_pins[i].port);
   1183e:	6070      	str	r0, [r6, #4]
		if (!button_devs[i])
   11840:	b1d8      	cbz	r0, 1187a <key_init+0x8e>
   11842:	6843      	ldr	r3, [r0, #4]
   11844:	4621      	mov	r1, r4
   11846:	681f      	ldr	r7, [r3, #0]
   11848:	220f      	movs	r2, #15
   1184a:	f44f 7380 	mov.w	r3, #256	; 0x100
   1184e:	47b8      	blx	r7
		if(err)
   11850:	4604      	mov	r4, r0
   11852:	bb58      	cbnz	r0, 118ac <key_init+0xc0>
		err = gpio_pin_configure(button_devs[i], button_pins[i].number, flags);
   11854:	6830      	ldr	r0, [r6, #0]
   11856:	6843      	ldr	r3, [r0, #4]
   11858:	4621      	mov	r1, r4
   1185a:	681f      	ldr	r7, [r3, #0]
   1185c:	221a      	movs	r2, #26
   1185e:	f44f 7381 	mov.w	r3, #258	; 0x102
   11862:	47b8      	blx	r7
	for(size_t i = 0; (i < ARRAY_SIZE(button_pins)) && !err; i++)
   11864:	4604      	mov	r4, r0
   11866:	b360      	cbz	r0, 118c2 <key_init+0xd6>
		LOG_INF("Cannot set interrupt mode");
   11868:	f04f 0000 	mov.w	r0, #0
   1186c:	2303      	movs	r3, #3
   1186e:	f363 0007 	bfi	r0, r3, #0, #8
   11872:	f365 108f 	bfi	r0, r5, #6, #10
   11876:	4952      	ldr	r1, [pc, #328]	; (119c0 <key_init+0x1d4>)
   11878:	e020      	b.n	118bc <key_init+0xd0>
			LOG_INF("Cannot bind gpio device");
   1187a:	2303      	movs	r3, #3
   1187c:	f04f 0000 	mov.w	r0, #0
   11880:	f363 0007 	bfi	r0, r3, #0, #8
   11884:	f365 108f 	bfi	r0, r5, #6, #10
   11888:	494e      	ldr	r1, [pc, #312]	; (119c4 <key_init+0x1d8>)
   1188a:	f01b fd35 	bl	2d2f8 <log_string_sync>
			return -ENODEV;
   1188e:	f06f 0412 	mvn.w	r4, #18
	
	err = buttons_init(button_handler);
	if (err)
	{
		LOG_INF("Could not initialize buttons, err code: %d\n", err);
   11892:	2303      	movs	r3, #3
   11894:	f04f 0000 	mov.w	r0, #0
   11898:	f363 0007 	bfi	r0, r3, #0, #8
   1189c:	f365 108f 	bfi	r0, r5, #6, #10
   118a0:	4622      	mov	r2, r4
		return;
	}

	k_timer_init(&g_long_press_timer_id, long_press_timer_handler, NULL);
}
   118a2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		LOG_INF("Could not initialize buttons, err code: %d\n", err);
   118a6:	4948      	ldr	r1, [pc, #288]	; (119c8 <key_init+0x1dc>)
   118a8:	f01b bd26 	b.w	2d2f8 <log_string_sync>
			LOG_INF("Cannot configure button gpio");
   118ac:	f04f 0000 	mov.w	r0, #0
   118b0:	2303      	movs	r3, #3
   118b2:	4946      	ldr	r1, [pc, #280]	; (119cc <key_init+0x1e0>)
   118b4:	f363 0007 	bfi	r0, r3, #0, #8
   118b8:	f365 108f 	bfi	r0, r5, #6, #10
		LOG_INF("Cannot set interrupt mode");
   118bc:	f01b fd1c 	bl	2d2f8 <log_string_sync>
		return err;
   118c0:	e7e7      	b.n	11892 <key_init+0xa6>
		err = gpio_pin_configure(button_devs[i], button_pins[i].number, flags);
   118c2:	6870      	ldr	r0, [r6, #4]
   118c4:	6843      	ldr	r3, [r0, #4]
   118c6:	4621      	mov	r1, r4
   118c8:	681f      	ldr	r7, [r3, #0]
   118ca:	220f      	movs	r2, #15
   118cc:	f44f 7381 	mov.w	r3, #258	; 0x102
   118d0:	47b8      	blx	r7
	if(err)
   118d2:	4604      	mov	r4, r0
   118d4:	2800      	cmp	r0, #0
   118d6:	d1c7      	bne.n	11868 <key_init+0x7c>
		err = gpio_pin_disable_callback(button_devs[i], button_pins[i].number);
   118d8:	6830      	ldr	r0, [r6, #0]
	if (api->disable_callback == NULL) {
   118da:	6843      	ldr	r3, [r0, #4]
   118dc:	695b      	ldr	r3, [r3, #20]
   118de:	b313      	cbz	r3, 11926 <key_init+0x13a>
	return api->disable_callback(port, access_op, pin);
   118e0:	4621      	mov	r1, r4
   118e2:	221a      	movs	r2, #26
   118e4:	4798      	blx	r3
		if(err)
   118e6:	4604      	mov	r4, r0
   118e8:	b9f8      	cbnz	r0, 1192a <key_init+0x13e>
		err = gpio_pin_disable_callback(button_devs[i], button_pins[i].number);
   118ea:	6870      	ldr	r0, [r6, #4]
	if (api->disable_callback == NULL) {
   118ec:	6843      	ldr	r3, [r0, #4]
   118ee:	695b      	ldr	r3, [r3, #20]
   118f0:	b1cb      	cbz	r3, 11926 <key_init+0x13a>
	return api->disable_callback(port, access_op, pin);
   118f2:	4621      	mov	r1, r4
   118f4:	220f      	movs	r2, #15
   118f6:	4798      	blx	r3
		if(err)
   118f8:	4604      	mov	r4, r0
   118fa:	b9b0      	cbnz	r0, 1192a <key_init+0x13e>
				      u32_t pin_mask)
{
	__ASSERT(callback, "Callback pointer should not be NULL");
	__ASSERT(handler, "Callback handler pointer should not be NULL");

	callback->handler = handler;
   118fc:	4f34      	ldr	r7, [pc, #208]	; (119d0 <key_init+0x1e4>)
   118fe:	4b35      	ldr	r3, [pc, #212]	; (119d4 <key_init+0x1e8>)
		err = gpio_add_callback(button_devs[i], &gpio_cb);
   11900:	6830      	ldr	r0, [r6, #0]
   11902:	607b      	str	r3, [r7, #4]
	callback->pin_mask = pin_mask;
   11904:	4b34      	ldr	r3, [pc, #208]	; (119d8 <key_init+0x1ec>)
   11906:	60bb      	str	r3, [r7, #8]
				    struct gpio_callback *callback)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;

	if (api->manage_callback == NULL) {
   11908:	6843      	ldr	r3, [r0, #4]
   1190a:	68db      	ldr	r3, [r3, #12]
   1190c:	b143      	cbz	r3, 11920 <key_init+0x134>
		return -ENOTSUP;
	}

	return api->manage_callback(port, callback, true);
   1190e:	2201      	movs	r2, #1
   11910:	4639      	mov	r1, r7
   11912:	4798      	blx	r3
		if(err)
   11914:	4604      	mov	r4, r0
   11916:	b9b0      	cbnz	r0, 11946 <key_init+0x15a>
		err = gpio_add_callback(button_devs[i], &gpio_cb);
   11918:	6870      	ldr	r0, [r6, #4]
	if (api->manage_callback == NULL) {
   1191a:	6843      	ldr	r3, [r0, #4]
   1191c:	68db      	ldr	r3, [r3, #12]
   1191e:	b96b      	cbnz	r3, 1193c <key_init+0x150>
		return -ENOTSUP;
   11920:	f06f 0485 	mvn.w	r4, #133	; 0x85
   11924:	e00f      	b.n	11946 <key_init+0x15a>
		return -ENOTSUP;
   11926:	f06f 0485 	mvn.w	r4, #133	; 0x85
			LOG_INF("Cannot disable callbacks()");
   1192a:	f04f 0000 	mov.w	r0, #0
   1192e:	2303      	movs	r3, #3
   11930:	f363 0007 	bfi	r0, r3, #0, #8
   11934:	f365 108f 	bfi	r0, r5, #6, #10
   11938:	4928      	ldr	r1, [pc, #160]	; (119dc <key_init+0x1f0>)
   1193a:	e7bf      	b.n	118bc <key_init+0xd0>
	return api->manage_callback(port, callback, true);
   1193c:	2201      	movs	r2, #1
   1193e:	4639      	mov	r1, r7
   11940:	4798      	blx	r3
		if(err)
   11942:	4604      	mov	r4, r0
   11944:	b140      	cbz	r0, 11958 <key_init+0x16c>
			LOG_INF("Cannot add callback");
   11946:	f04f 0000 	mov.w	r0, #0
   1194a:	2303      	movs	r3, #3
   1194c:	f363 0007 	bfi	r0, r3, #0, #8
   11950:	f365 108f 	bfi	r0, r5, #6, #10
   11954:	4922      	ldr	r1, [pc, #136]	; (119e0 <key_init+0x1f4>)
   11956:	e7b1      	b.n	118bc <key_init+0xd0>
	k_delayed_work_init(&buttons_scan, buttons_scan_fn);
   11958:	4922      	ldr	r1, [pc, #136]	; (119e4 <key_init+0x1f8>)
   1195a:	4823      	ldr	r0, [pc, #140]	; (119e8 <key_init+0x1fc>)
   1195c:	f01d fc31 	bl	2f1c2 <k_delayed_work_init>
	state = STATE_SCANNING;
   11960:	2201      	movs	r2, #1
   11962:	4b22      	ldr	r3, [pc, #136]	; (119ec <key_init+0x200>)
   11964:	4920      	ldr	r1, [pc, #128]	; (119e8 <key_init+0x1fc>)
   11966:	701a      	strb	r2, [r3, #0]
   11968:	4821      	ldr	r0, [pc, #132]	; (119f0 <key_init+0x204>)
   1196a:	4622      	mov	r2, r4
   1196c:	f017 f890 	bl	28a90 <k_delayed_work_submit_to_queue>
	if(err)
   11970:	4604      	mov	r4, r0
   11972:	b140      	cbz	r0, 11986 <key_init+0x19a>
		LOG_INF("Cannot add work to workqueue");
   11974:	f04f 0000 	mov.w	r0, #0
   11978:	2303      	movs	r3, #3
   1197a:	f363 0007 	bfi	r0, r3, #0, #8
   1197e:	f365 108f 	bfi	r0, r5, #6, #10
   11982:	491c      	ldr	r1, [pc, #112]	; (119f4 <key_init+0x208>)
   11984:	e79a      	b.n	118bc <key_init+0xd0>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   11986:	4b1c      	ldr	r3, [pc, #112]	; (119f8 <key_init+0x20c>)
   11988:	e8d3 2faf 	lda	r2, [r3]
	last_state = current_state;
   1198c:	4b1b      	ldr	r3, [pc, #108]	; (119fc <key_init+0x210>)
	k_timer_init(&g_long_press_timer_id, long_press_timer_handler, NULL);
   1198e:	491c      	ldr	r1, [pc, #112]	; (11a00 <key_init+0x214>)
	last_state = current_state;
   11990:	601a      	str	r2, [r3, #0]
	k_timer_init(&g_long_press_timer_id, long_press_timer_handler, NULL);
   11992:	4602      	mov	r2, r0
}
   11994:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	k_timer_init(&g_long_press_timer_id, long_press_timer_handler, NULL);
   11998:	481a      	ldr	r0, [pc, #104]	; (11a04 <key_init+0x218>)
   1199a:	f01d bc2c 	b.w	2f1f6 <k_timer_init>
   1199e:	bf00      	nop
   119a0:	00030484 	.word	0x00030484
   119a4:	0003040c 	.word	0x0003040c
   119a8:	00031278 	.word	0x00031278
   119ac:	20020be0 	.word	0x20020be0
   119b0:	00011435 	.word	0x00011435
   119b4:	20020be4 	.word	0x20020be4
   119b8:	000310d7 	.word	0x000310d7
   119bc:	20020bd8 	.word	0x20020bd8
   119c0:	000312b7 	.word	0x000312b7
   119c4:	00031282 	.word	0x00031282
   119c8:	00031300 	.word	0x00031300
   119cc:	0003129a 	.word	0x0003129a
   119d0:	20020c44 	.word	0x20020c44
   119d4:	000114ad 	.word	0x000114ad
   119d8:	04008000 	.word	0x04008000
   119dc:	000312d1 	.word	0x000312d1
   119e0:	000312ec 	.word	0x000312ec
   119e4:	000115cd 	.word	0x000115cd
   119e8:	20020bf8 	.word	0x20020bf8
   119ec:	2002f49d 	.word	0x2002f49d
   119f0:	2002d330 	.word	0x2002d330
   119f4:	00031243 	.word	0x00031243
   119f8:	20020c64 	.word	0x20020c64
   119fc:	20020c5c 	.word	0x20020c5c
   11a00:	00011425 	.word	0x00011425
   11a04:	20020c18 	.word	0x20020c18

00011a08 <SaveSystemDateTime>:
	return err;
}

void SaveSystemDateTime(void)
{
	nvs_write(&fs, DATETIME_ID, &date_time, sizeof(sys_date_timer_t));
   11a08:	2308      	movs	r3, #8
   11a0a:	4a02      	ldr	r2, [pc, #8]	; (11a14 <SaveSystemDateTime+0xc>)
   11a0c:	2101      	movs	r1, #1
   11a0e:	4802      	ldr	r0, [pc, #8]	; (11a18 <SaveSystemDateTime+0x10>)
   11a10:	f006 bcf4 	b.w	183fc <nvs_write>
   11a14:	2002d410 	.word	0x2002d410
   11a18:	20020c68 	.word	0x20020c68

00011a1c <ResetSystemTime>:
}

void ResetSystemTime(void)
{
	memcpy(&date_time, &FACTORY_DEFAULT_TIME, sizeof(sys_date_timer_t));
   11a1c:	4903      	ldr	r1, [pc, #12]	; (11a2c <ResetSystemTime+0x10>)
   11a1e:	4a04      	ldr	r2, [pc, #16]	; (11a30 <ResetSystemTime+0x14>)
   11a20:	680b      	ldr	r3, [r1, #0]
   11a22:	6013      	str	r3, [r2, #0]
   11a24:	684b      	ldr	r3, [r1, #4]
   11a26:	6053      	str	r3, [r2, #4]
	SaveSystemDateTime();
   11a28:	f7ff bfee 	b.w	11a08 <SaveSystemDateTime>
   11a2c:	00030f5c 	.word	0x00030f5c
   11a30:	2002d410 	.word	0x2002d410

00011a34 <InitSystemDateTime>:
}

void InitSystemDateTime(void)
{
   11a34:	b513      	push	{r0, r1, r4, lr}
	int err = 0;
	sys_date_timer_t mytime = {0};
   11a36:	2300      	movs	r3, #0
   11a38:	466c      	mov	r4, sp
   11a3a:	9300      	str	r3, [sp, #0]
   11a3c:	6063      	str	r3, [r4, #4]

	err = nvs_read(&fs, DATETIME_ID, &date_time, sizeof(sys_date_timer_t));
   11a3e:	4a15      	ldr	r2, [pc, #84]	; (11a94 <InitSystemDateTime+0x60>)
   11a40:	2308      	movs	r3, #8
   11a42:	2101      	movs	r1, #1
   11a44:	4814      	ldr	r0, [pc, #80]	; (11a98 <InitSystemDateTime+0x64>)
   11a46:	f01b fd6c 	bl	2d522 <nvs_read>
	if(err < 0)
   11a4a:	1e02      	subs	r2, r0, #0
   11a4c:	da0d      	bge.n	11a6a <InitSystemDateTime+0x36>
	{
		LOG_INF("get datetime err:%d\n", err);
   11a4e:	2303      	movs	r3, #3
   11a50:	f04f 0000 	mov.w	r0, #0
   11a54:	4911      	ldr	r1, [pc, #68]	; (11a9c <InitSystemDateTime+0x68>)
   11a56:	f363 0007 	bfi	r0, r3, #0, #8
   11a5a:	4b11      	ldr	r3, [pc, #68]	; (11aa0 <InitSystemDateTime+0x6c>)
   11a5c:	1a5b      	subs	r3, r3, r1
   11a5e:	08db      	lsrs	r3, r3, #3
   11a60:	f363 108f 	bfi	r0, r3, #6, #10
   11a64:	490f      	ldr	r1, [pc, #60]	; (11aa4 <InitSystemDateTime+0x70>)
   11a66:	f01b fc47 	bl	2d2f8 <log_string_sync>
	}
	
	if(!CheckSystemDateTimeIsValid(mytime))
   11a6a:	e894 0003 	ldmia.w	r4, {r0, r1}
   11a6e:	f019 fd4c 	bl	2b50a <CheckSystemDateTimeIsValid>
   11a72:	b920      	cbnz	r0, 11a7e <InitSystemDateTime+0x4a>
	{
		memcpy(&mytime, &FACTORY_DEFAULT_TIME, sizeof(sys_date_timer_t));
   11a74:	4623      	mov	r3, r4
   11a76:	4a0c      	ldr	r2, [pc, #48]	; (11aa8 <InitSystemDateTime+0x74>)
   11a78:	6810      	ldr	r0, [r2, #0]
   11a7a:	6851      	ldr	r1, [r2, #4]
   11a7c:	c303      	stmia	r3!, {r0, r1}
	}
	memcpy(&date_time, &mytime, sizeof(sys_date_timer_t));
   11a7e:	cc03      	ldmia	r4!, {r0, r1}
   11a80:	4b04      	ldr	r3, [pc, #16]	; (11a94 <InitSystemDateTime+0x60>)
   11a82:	6018      	str	r0, [r3, #0]
   11a84:	6059      	str	r1, [r3, #4]

	SaveSystemDateTime();
   11a86:	f7ff ffbf 	bl	11a08 <SaveSystemDateTime>
	StartSystemDateTime();
}
   11a8a:	b002      	add	sp, #8
   11a8c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	StartSystemDateTime();
   11a90:	f7fe bda4 	b.w	105dc <StartSystemDateTime>
   11a94:	2002d410 	.word	0x2002d410
   11a98:	20020c68 	.word	0x20020c68
   11a9c:	0003040c 	.word	0x0003040c
   11aa0:	000304f4 	.word	0x000304f4
   11aa4:	00031330 	.word	0x00031330
   11aa8:	00030f5c 	.word	0x00030f5c

00011aac <SaveSystemSettings>:

void SaveSystemSettings(void)
{
	nvs_write(&fs, SETTINGS_ID, &global_settings, sizeof(global_settings_t));
   11aac:	2330      	movs	r3, #48	; 0x30
   11aae:	4a02      	ldr	r2, [pc, #8]	; (11ab8 <SaveSystemSettings+0xc>)
   11ab0:	2102      	movs	r1, #2
   11ab2:	4802      	ldr	r0, [pc, #8]	; (11abc <SaveSystemSettings+0x10>)
   11ab4:	f006 bca2 	b.w	183fc <nvs_write>
   11ab8:	2002d422 	.word	0x2002d422
   11abc:	20020c68 	.word	0x20020c68

00011ac0 <ResetSystemSettings>:
}

void ResetSystemSettings(void)
{
	memcpy(&global_settings, &FACTORY_DEFAULT_SETTINGS, sizeof(global_settings_t));
   11ac0:	4b05      	ldr	r3, [pc, #20]	; (11ad8 <ResetSystemSettings+0x18>)
   11ac2:	4a06      	ldr	r2, [pc, #24]	; (11adc <ResetSystemSettings+0x1c>)
   11ac4:	f103 0130 	add.w	r1, r3, #48	; 0x30
   11ac8:	f853 0b04 	ldr.w	r0, [r3], #4
   11acc:	428b      	cmp	r3, r1
   11ace:	f842 0b04 	str.w	r0, [r2], #4
   11ad2:	d1f9      	bne.n	11ac8 <ResetSystemSettings+0x8>
	SaveSystemSettings();
   11ad4:	f7ff bfea 	b.w	11aac <SaveSystemSettings>
   11ad8:	00030f2c 	.word	0x00030f2c
   11adc:	2002d422 	.word	0x2002d422

00011ae0 <InitSystemSettings>:
}

void InitSystemSettings(void)
{
   11ae0:	b570      	push	{r4, r5, r6, lr}
	int err;

	if(!nvs_init_flag)
   11ae2:	4d2c      	ldr	r5, [pc, #176]	; (11b94 <InitSystemSettings+0xb4>)
   11ae4:	782b      	ldrb	r3, [r5, #0]
   11ae6:	b9c3      	cbnz	r3, 11b1a <InitSystemSettings+0x3a>
	fs.offset = DT_FLASH_AREA_STORAGE_OFFSET;	
   11ae8:	f44f 237a 	mov.w	r3, #1024000	; 0xfa000
   11aec:	4c2a      	ldr	r4, [pc, #168]	; (11b98 <InitSystemSettings+0xb8>)
   11aee:	6023      	str	r3, [r4, #0]
   11af0:	482a      	ldr	r0, [pc, #168]	; (11b9c <InitSystemSettings+0xbc>)
   11af2:	f014 fb69 	bl	261c8 <z_impl_device_get_binding>
	err = flash_get_page_info_by_offs(device_get_binding(DT_FLASH_DEV_NAME), fs.offset, &info);	
   11af6:	6821      	ldr	r1, [r4, #0]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&offset, *(uintptr_t *)&info, K_SYSCALL_FLASH_GET_PAGE_INFO_BY_OFFS);
	}
#endif
	compiler_barrier();
	return z_impl_flash_get_page_info_by_offs(dev, offset, info);
   11af8:	4e29      	ldr	r6, [pc, #164]	; (11ba0 <InitSystemSettings+0xc0>)
   11afa:	4632      	mov	r2, r6
   11afc:	f01c fb98 	bl	2e230 <z_impl_flash_get_page_info_by_offs>
	if(err)
   11b00:	2800      	cmp	r0, #0
   11b02:	d136      	bne.n	11b72 <InitSystemSettings+0x92>
	fs.sector_size = info.size;
   11b04:	6873      	ldr	r3, [r6, #4]
	err = nvs_init(&fs, DT_FLASH_DEV_NAME);
   11b06:	4925      	ldr	r1, [pc, #148]	; (11b9c <InitSystemSettings+0xbc>)
	fs.sector_size = info.size;
   11b08:	81a3      	strh	r3, [r4, #12]
	fs.sector_count = 6U;
   11b0a:	2306      	movs	r3, #6
	err = nvs_init(&fs, DT_FLASH_DEV_NAME);
   11b0c:	4620      	mov	r0, r4
	fs.sector_count = 6U;
   11b0e:	81e3      	strh	r3, [r4, #14]
	err = nvs_init(&fs, DT_FLASH_DEV_NAME);
   11b10:	f006 fb0a 	bl	18128 <nvs_init>
	if(err)
   11b14:	bb68      	cbnz	r0, 11b72 <InitSystemSettings+0x92>
	nvs_init_flag = true;
   11b16:	2301      	movs	r3, #1
   11b18:	702b      	strb	r3, [r5, #0]
			LOG_INF("Flash Init failed, return!\n");
			return;
		}
	}
	
	err = nvs_read(&fs, SETTINGS_ID, &global_settings, sizeof(global_settings_t));
   11b1a:	4a22      	ldr	r2, [pc, #136]	; (11ba4 <InitSystemSettings+0xc4>)
   11b1c:	2330      	movs	r3, #48	; 0x30
   11b1e:	2102      	movs	r1, #2
   11b20:	481d      	ldr	r0, [pc, #116]	; (11b98 <InitSystemSettings+0xb8>)
   11b22:	f01b fcfe 	bl	2d522 <nvs_read>
	if(err < 0)
   11b26:	1e02      	subs	r2, r0, #0
   11b28:	da0d      	bge.n	11b46 <InitSystemSettings+0x66>
	{
		LOG_INF("get settins err:%d\n", err);
   11b2a:	2303      	movs	r3, #3
   11b2c:	f04f 0000 	mov.w	r0, #0
   11b30:	491d      	ldr	r1, [pc, #116]	; (11ba8 <InitSystemSettings+0xc8>)
   11b32:	f363 0007 	bfi	r0, r3, #0, #8
   11b36:	4b1d      	ldr	r3, [pc, #116]	; (11bac <InitSystemSettings+0xcc>)
   11b38:	1a5b      	subs	r3, r3, r1
   11b3a:	08db      	lsrs	r3, r3, #3
   11b3c:	f363 108f 	bfi	r0, r3, #6, #10
   11b40:	491b      	ldr	r1, [pc, #108]	; (11bb0 <InitSystemSettings+0xd0>)
   11b42:	f01b fbd9 	bl	2d2f8 <log_string_sync>
	}

	if(!global_settings.init)
   11b46:	4b17      	ldr	r3, [pc, #92]	; (11ba4 <InitSystemSettings+0xc4>)
   11b48:	781a      	ldrb	r2, [r3, #0]
   11b4a:	b952      	cbnz	r2, 11b62 <InitSystemSettings+0x82>
	{
		memcpy(&global_settings, &FACTORY_DEFAULT_SETTINGS, sizeof(global_settings_t));
   11b4c:	4a19      	ldr	r2, [pc, #100]	; (11bb4 <InitSystemSettings+0xd4>)
   11b4e:	f102 0130 	add.w	r1, r2, #48	; 0x30
   11b52:	f852 0b04 	ldr.w	r0, [r2], #4
   11b56:	428a      	cmp	r2, r1
   11b58:	f843 0b04 	str.w	r0, [r3], #4
   11b5c:	d1f9      	bne.n	11b52 <InitSystemSettings+0x72>
		SaveSystemSettings();
   11b5e:	f7ff ffa5 	bl	11aac <SaveSystemSettings>
	}

	InitSystemDateTime();
   11b62:	f7ff ff67 	bl	11a34 <InitSystemDateTime>
	AlarmRemindInit();
   11b66:	f7fe ffb7 	bl	10ad8 <AlarmRemindInit>

	mmi_chset_init();
}
   11b6a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	mmi_chset_init();
   11b6e:	f01b b8cc 	b.w	2cd0a <mmi_chset_init>
			LOG_INF("Flash Init failed, return!\n");
   11b72:	2303      	movs	r3, #3
}
   11b74:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			LOG_INF("Flash Init failed, return!\n");
   11b78:	f04f 0000 	mov.w	r0, #0
   11b7c:	4a0a      	ldr	r2, [pc, #40]	; (11ba8 <InitSystemSettings+0xc8>)
   11b7e:	f363 0007 	bfi	r0, r3, #0, #8
   11b82:	4b0a      	ldr	r3, [pc, #40]	; (11bac <InitSystemSettings+0xcc>)
   11b84:	490c      	ldr	r1, [pc, #48]	; (11bb8 <InitSystemSettings+0xd8>)
   11b86:	1a9b      	subs	r3, r3, r2
   11b88:	08db      	lsrs	r3, r3, #3
   11b8a:	f363 108f 	bfi	r0, r3, #6, #10
   11b8e:	f01b bbb3 	b.w	2d2f8 <log_string_sync>
   11b92:	bf00      	nop
   11b94:	2002f4a1 	.word	0x2002f4a1
   11b98:	20020c68 	.word	0x20020c68
   11b9c:	00031345 	.word	0x00031345
   11ba0:	20020c94 	.word	0x20020c94
   11ba4:	2002d422 	.word	0x2002d422
   11ba8:	0003040c 	.word	0x0003040c
   11bac:	000304f4 	.word	0x000304f4
   11bb0:	00031358 	.word	0x00031358
   11bb4:	00030f2c 	.word	0x00030f2c
   11bb8:	0003136c 	.word	0x0003136c

00011bbc <SettingsMsgPorcess>:

void SettingsMsgPorcess(void)
{
   11bbc:	b510      	push	{r4, lr}
	if(need_save_time)
   11bbe:	4c0e      	ldr	r4, [pc, #56]	; (11bf8 <SettingsMsgPorcess+0x3c>)
   11bc0:	7823      	ldrb	r3, [r4, #0]
   11bc2:	b11b      	cbz	r3, 11bcc <SettingsMsgPorcess+0x10>
	{
		SaveSystemDateTime();
   11bc4:	f7ff ff20 	bl	11a08 <SaveSystemDateTime>
		need_save_time = false;
   11bc8:	2300      	movs	r3, #0
   11bca:	7023      	strb	r3, [r4, #0]
	}
	
	if(need_save_settings)
   11bcc:	4b0b      	ldr	r3, [pc, #44]	; (11bfc <SettingsMsgPorcess+0x40>)
   11bce:	781a      	ldrb	r2, [r3, #0]
   11bd0:	b11a      	cbz	r2, 11bda <SettingsMsgPorcess+0x1e>
	{
		need_save_settings = false;
   11bd2:	2200      	movs	r2, #0
   11bd4:	701a      	strb	r2, [r3, #0]
		SaveSystemSettings();
   11bd6:	f7ff ff69 	bl	11aac <SaveSystemSettings>
	}

	if(need_reset_settings)
   11bda:	4b09      	ldr	r3, [pc, #36]	; (11c00 <SettingsMsgPorcess+0x44>)
   11bdc:	781a      	ldrb	r2, [r3, #0]
   11bde:	b152      	cbz	r2, 11bf6 <SettingsMsgPorcess+0x3a>
	{
		need_reset_settings = false;
   11be0:	2200      	movs	r2, #0
   11be2:	701a      	strb	r2, [r3, #0]
		ResetSystemSettings();
   11be4:	f7ff ff6c 	bl	11ac0 <ResetSystemSettings>
		ResetSystemTime();
   11be8:	f7ff ff18 	bl	11a1c <ResetSystemTime>

		lcd_sleep_out = true;
   11bec:	2301      	movs	r3, #1
   11bee:	4a05      	ldr	r2, [pc, #20]	; (11c04 <SettingsMsgPorcess+0x48>)
   11bf0:	7013      	strb	r3, [r2, #0]
		update_date_time = true;
   11bf2:	4a05      	ldr	r2, [pc, #20]	; (11c08 <SettingsMsgPorcess+0x4c>)
   11bf4:	7013      	strb	r3, [r2, #0]
	}
}
   11bf6:	bd10      	pop	{r4, pc}
   11bf8:	2002f4a0 	.word	0x2002f4a0
   11bfc:	2002f49f 	.word	0x2002f49f
   11c00:	2002f49e 	.word	0x2002f49e
   11c04:	2002d49b 	.word	0x2002d49b
   11c08:	2002d494 	.word	0x2002d494

00011c0c <SPI_Flash_Init>:
**   W25Q64FW,CSSPI
**   
** 
******************************************************************************/
void SPI_Flash_Init(void)
{
   11c0c:	b508      	push	{r3, lr}
   11c0e:	480e      	ldr	r0, [pc, #56]	; (11c48 <SPI_Flash_Init+0x3c>)
   11c10:	f014 fada 	bl	261c8 <z_impl_device_get_binding>
	spi_flash = device_get_binding(FLASH_DEVICE);
   11c14:	4b0d      	ldr	r3, [pc, #52]	; (11c4c <SPI_Flash_Init+0x40>)
   11c16:	6018      	str	r0, [r3, #0]
	if (!spi_flash) 
   11c18:	b970      	cbnz	r0, 11c38 <SPI_Flash_Init+0x2c>
	{
		LOG_INF("Could not get %s device\n", FLASH_DEVICE);
   11c1a:	2303      	movs	r3, #3
   11c1c:	4a0c      	ldr	r2, [pc, #48]	; (11c50 <SPI_Flash_Init+0x44>)
   11c1e:	f363 0007 	bfi	r0, r3, #0, #8
   11c22:	4b0c      	ldr	r3, [pc, #48]	; (11c54 <SPI_Flash_Init+0x48>)
   11c24:	490c      	ldr	r1, [pc, #48]	; (11c58 <SPI_Flash_Init+0x4c>)
   11c26:	1a9b      	subs	r3, r3, r2
   11c28:	08db      	lsrs	r3, r3, #3
   11c2a:	f363 108f 	bfi	r0, r3, #6, #10
   11c2e:	4a06      	ldr	r2, [pc, #24]	; (11c48 <SPI_Flash_Init+0x3c>)
	}

	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
	spi_cfg.frequency = 4000000;
	spi_cfg.slave = 0;
}
   11c30:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		LOG_INF("Could not get %s device\n", FLASH_DEVICE);
   11c34:	f01b bb60 	b.w	2d2f8 <log_string_sync>
	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
   11c38:	f44f 7280 	mov.w	r2, #256	; 0x100
	spi_cfg.frequency = 4000000;
   11c3c:	4b07      	ldr	r3, [pc, #28]	; (11c5c <SPI_Flash_Init+0x50>)
	spi_cfg.operation = SPI_OP_MODE_MASTER | SPI_WORD_SET(8);
   11c3e:	4908      	ldr	r1, [pc, #32]	; (11c60 <SPI_Flash_Init+0x54>)
   11c40:	e9c3 1200 	strd	r1, r2, [r3]
}
   11c44:	bd08      	pop	{r3, pc}
   11c46:	bf00      	nop
   11c48:	00031391 	.word	0x00031391
   11c4c:	20020cb0 	.word	0x20020cb0
   11c50:	0003040c 	.word	0x0003040c
   11c54:	0003045c 	.word	0x0003045c
   11c58:	000310fd 	.word	0x000310fd
   11c5c:	20020ca4 	.word	0x20020ca4
   11c60:	003d0900 	.word	0x003d0900

00011c64 <flash_init>:

void flash_init(void)
{
   11c64:	b538      	push	{r3, r4, r5, lr}
	LOG_INF("flash_init\n");
   11c66:	f04f 0000 	mov.w	r0, #0
   11c6a:	2303      	movs	r3, #3
   11c6c:	4c17      	ldr	r4, [pc, #92]	; (11ccc <flash_init+0x68>)
   11c6e:	f363 0007 	bfi	r0, r3, #0, #8
   11c72:	4b17      	ldr	r3, [pc, #92]	; (11cd0 <flash_init+0x6c>)
   11c74:	4917      	ldr	r1, [pc, #92]	; (11cd4 <flash_init+0x70>)
   11c76:	1ae4      	subs	r4, r4, r3
   11c78:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   11c7c:	f364 108f 	bfi	r0, r4, #6, #10
   11c80:	f01b fb3a 	bl	2d2f8 <log_string_sync>
   11c84:	4814      	ldr	r0, [pc, #80]	; (11cd8 <flash_init+0x74>)
   11c86:	f014 fa9f 	bl	261c8 <z_impl_device_get_binding>
		
	gpio_flash = device_get_binding(FLASH_PORT);
   11c8a:	4d14      	ldr	r5, [pc, #80]	; (11cdc <flash_init+0x78>)
   11c8c:	6028      	str	r0, [r5, #0]
	if(!gpio_flash)
   11c8e:	b958      	cbnz	r0, 11ca8 <flash_init+0x44>
	{
		LOG_INF("Cannot bind gpio device\n");
   11c90:	2303      	movs	r3, #3
   11c92:	f04f 0000 	mov.w	r0, #0
   11c96:	f363 0007 	bfi	r0, r3, #0, #8
   11c9a:	f364 108f 	bfi	r0, r4, #6, #10
   11c9e:	4910      	ldr	r1, [pc, #64]	; (11ce0 <flash_init+0x7c>)

	gpio_pin_configure(gpio_flash, CS, GPIO_DIR_OUT);
	gpio_pin_write(gpio_flash, CS, 1);

	SPI_Flash_Init();
}
   11ca0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		LOG_INF("Cannot bind gpio device\n");
   11ca4:	f01b bb28 	b.w	2d2f8 <log_string_sync>
	return api->config(port, access_op, pin, flags);
   11ca8:	6843      	ldr	r3, [r0, #4]
   11caa:	2202      	movs	r2, #2
   11cac:	681c      	ldr	r4, [r3, #0]
   11cae:	2100      	movs	r1, #0
   11cb0:	2301      	movs	r3, #1
   11cb2:	47a0      	blx	r4
	gpio_pin_write(gpio_flash, CS, 1);
   11cb4:	6828      	ldr	r0, [r5, #0]
	return api->write(port, access_op, pin, value);
   11cb6:	6843      	ldr	r3, [r0, #4]
   11cb8:	2202      	movs	r2, #2
   11cba:	685c      	ldr	r4, [r3, #4]
   11cbc:	2100      	movs	r1, #0
   11cbe:	2301      	movs	r3, #1
   11cc0:	47a0      	blx	r4
}
   11cc2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	SPI_Flash_Init();
   11cc6:	f7ff bfa1 	b.w	11c0c <SPI_Flash_Init>
   11cca:	bf00      	nop
   11ccc:	0003045c 	.word	0x0003045c
   11cd0:	0003040c 	.word	0x0003040c
   11cd4:	00031397 	.word	0x00031397
   11cd8:	000310d7 	.word	0x000310d7
   11cdc:	20020ca0 	.word	0x20020ca0
   11ce0:	000310de 	.word	0x000310de

00011ce4 <ble_connect_or_disconnect_handle>:
{
   11ce4:	b510      	push	{r4, lr}
	LOG_INF("BLE status:%x\n", buf[6]);
   11ce6:	2303      	movs	r3, #3
{
   11ce8:	4604      	mov	r4, r0
	LOG_INF("BLE status:%x\n", buf[6]);
   11cea:	f04f 0000 	mov.w	r0, #0
   11cee:	4a09      	ldr	r2, [pc, #36]	; (11d14 <ble_connect_or_disconnect_handle+0x30>)
   11cf0:	f363 0007 	bfi	r0, r3, #0, #8
   11cf4:	4b08      	ldr	r3, [pc, #32]	; (11d18 <ble_connect_or_disconnect_handle+0x34>)
   11cf6:	4909      	ldr	r1, [pc, #36]	; (11d1c <ble_connect_or_disconnect_handle+0x38>)
   11cf8:	1a9b      	subs	r3, r3, r2
   11cfa:	08db      	lsrs	r3, r3, #3
   11cfc:	f363 108f 	bfi	r0, r3, #6, #10
   11d00:	79a2      	ldrb	r2, [r4, #6]
   11d02:	f01b faf9 	bl	2d2f8 <log_string_sync>
	if(buf[6] == 0x01)				//control
   11d06:	79a2      	ldrb	r2, [r4, #6]
   11d08:	4b05      	ldr	r3, [pc, #20]	; (11d20 <ble_connect_or_disconnect_handle+0x3c>)
   11d0a:	2a01      	cmp	r2, #1
		BLE_is_connected = false;
   11d0c:	bf18      	it	ne
   11d0e:	2200      	movne	r2, #0
   11d10:	701a      	strb	r2, [r3, #0]
}
   11d12:	bd10      	pop	{r4, pc}
   11d14:	0003040c 	.word	0x0003040c
   11d18:	00030524 	.word	0x00030524
   11d1c:	0003147d 	.word	0x0003147d
   11d20:	2002f4a2 	.word	0x2002f4a2

00011d24 <CTP_notify_handle>:
{
   11d24:	b530      	push	{r4, r5, lr}
   11d26:	b0a5      	sub	sp, #148	; 0x94
   11d28:	4604      	mov	r4, r0
	u8_t tmpbuf[128] = {0};
   11d2a:	2280      	movs	r2, #128	; 0x80
   11d2c:	2100      	movs	r1, #0
   11d2e:	a804      	add	r0, sp, #16
   11d30:	f01d fb30 	bl	2f394 <memset>
	LOG_INF("%x,%x,%x,%x,%x,%x\n",buf[5],buf[6],buf[7],buf[8],buf[9],buf[10]);
   11d34:	2303      	movs	r3, #3
   11d36:	f04f 0000 	mov.w	r0, #0
   11d3a:	4a2e      	ldr	r2, [pc, #184]	; (11df4 <CTP_notify_handle+0xd0>)
   11d3c:	f363 0007 	bfi	r0, r3, #0, #8
   11d40:	4b2d      	ldr	r3, [pc, #180]	; (11df8 <CTP_notify_handle+0xd4>)
   11d42:	492e      	ldr	r1, [pc, #184]	; (11dfc <CTP_notify_handle+0xd8>)
   11d44:	1a9b      	subs	r3, r3, r2
   11d46:	08db      	lsrs	r3, r3, #3
   11d48:	f363 108f 	bfi	r0, r3, #6, #10
   11d4c:	7aa3      	ldrb	r3, [r4, #10]
   11d4e:	7962      	ldrb	r2, [r4, #5]
   11d50:	9303      	str	r3, [sp, #12]
   11d52:	7a63      	ldrb	r3, [r4, #9]
   11d54:	9302      	str	r3, [sp, #8]
   11d56:	7a23      	ldrb	r3, [r4, #8]
   11d58:	9301      	str	r3, [sp, #4]
   11d5a:	79e3      	ldrb	r3, [r4, #7]
   11d5c:	9300      	str	r3, [sp, #0]
   11d5e:	79a3      	ldrb	r3, [r4, #6]
   11d60:	f01b faca 	bl	2d2f8 <log_string_sync>
	switch(buf[5])
   11d64:	7965      	ldrb	r5, [r4, #5]
   11d66:	2d0c      	cmp	r5, #12
   11d68:	d80c      	bhi.n	11d84 <CTP_notify_handle+0x60>
   11d6a:	e8df f005 	tbb	[pc, r5]
   11d6e:	2007      	.short	0x2007
   11d70:	312b250d 	.word	0x312b250d
   11d74:	0b0b0b0b 	.word	0x0b0b0b0b
   11d78:	370b      	.short	0x370b
   11d7a:	3d          	.byte	0x3d
   11d7b:	00          	.byte	0x00
		sprintf(tmpbuf, "GESTURE_NONE        ");
   11d7c:	4920      	ldr	r1, [pc, #128]	; (11e00 <CTP_notify_handle+0xdc>)
   11d7e:	a804      	add	r0, sp, #16
   11d80:	f01d fc89 	bl	2f696 <strcpy>
}
   11d84:	b025      	add	sp, #148	; 0x94
   11d86:	bd30      	pop	{r4, r5, pc}
		sprintf(tmpbuf, "MOVING_UP   ");
   11d88:	491e      	ldr	r1, [pc, #120]	; (11e04 <CTP_notify_handle+0xe0>)
   11d8a:	a804      	add	r0, sp, #16
   11d8c:	f01d fc83 	bl	2f696 <strcpy>
		tp_type = TP_EVENT_MOVING_UP;
   11d90:	2500      	movs	r5, #0
		tp_y = buf[9]*0x100+buf[10];
   11d92:	7a63      	ldrb	r3, [r4, #9]
   11d94:	7aa2      	ldrb	r2, [r4, #10]
		tp_x = buf[7]*0x100+buf[8];
   11d96:	7a21      	ldrb	r1, [r4, #8]
		tp_y = buf[9]*0x100+buf[10];
   11d98:	eb02 2203 	add.w	r2, r2, r3, lsl #8
		tp_x = buf[7]*0x100+buf[8];
   11d9c:	79e3      	ldrb	r3, [r4, #7]
		touch_panel_event_handle(tp_type, tp_x, tp_y);
   11d9e:	b292      	uxth	r2, r2
		tp_x = buf[7]*0x100+buf[8];
   11da0:	eb01 2103 	add.w	r1, r1, r3, lsl #8
		touch_panel_event_handle(tp_type, tp_x, tp_y);
   11da4:	b289      	uxth	r1, r1
   11da6:	4628      	mov	r0, r5
   11da8:	f002 fdba 	bl	14920 <touch_panel_event_handle>
}
   11dac:	e7ea      	b.n	11d84 <CTP_notify_handle+0x60>
		sprintf(tmpbuf, "MOVING_DOWN ");
   11dae:	4916      	ldr	r1, [pc, #88]	; (11e08 <CTP_notify_handle+0xe4>)
   11db0:	a804      	add	r0, sp, #16
   11db2:	f01d fc70 	bl	2f696 <strcpy>
	if(tp_type != TP_EVENT_MAX)
   11db6:	e7ec      	b.n	11d92 <CTP_notify_handle+0x6e>
		sprintf(tmpbuf, "MOVING_LEFT ");
   11db8:	4914      	ldr	r1, [pc, #80]	; (11e0c <CTP_notify_handle+0xe8>)
   11dba:	a804      	add	r0, sp, #16
   11dbc:	f01d fc6b 	bl	2f696 <strcpy>
		tp_type = TP_EVENT_MOVING_LEFT;
   11dc0:	2502      	movs	r5, #2
   11dc2:	e7e6      	b.n	11d92 <CTP_notify_handle+0x6e>
		sprintf(tmpbuf, "MOVING_RIGHT");
   11dc4:	4912      	ldr	r1, [pc, #72]	; (11e10 <CTP_notify_handle+0xec>)
   11dc6:	a804      	add	r0, sp, #16
   11dc8:	f01d fc65 	bl	2f696 <strcpy>
		tp_type = TP_EVENT_MOVING_RIGHT;
   11dcc:	2503      	movs	r5, #3
   11dce:	e7e0      	b.n	11d92 <CTP_notify_handle+0x6e>
		sprintf(tmpbuf, "SINGLE_CLICK");
   11dd0:	4910      	ldr	r1, [pc, #64]	; (11e14 <CTP_notify_handle+0xf0>)
   11dd2:	a804      	add	r0, sp, #16
   11dd4:	f01d fc5f 	bl	2f696 <strcpy>
		tp_type = TP_EVENT_SINGLE_CLICK;
   11dd8:	2504      	movs	r5, #4
   11dda:	e7da      	b.n	11d92 <CTP_notify_handle+0x6e>
		sprintf(tmpbuf, "DOUBLE_CLICK");
   11ddc:	490e      	ldr	r1, [pc, #56]	; (11e18 <CTP_notify_handle+0xf4>)
   11dde:	a804      	add	r0, sp, #16
   11de0:	f01d fc59 	bl	2f696 <strcpy>
		tp_type = TP_EVENT_DOUBLE_CLICK;
   11de4:	2505      	movs	r5, #5
   11de6:	e7d4      	b.n	11d92 <CTP_notify_handle+0x6e>
		sprintf(tmpbuf, "LONG_PRESS  ");
   11de8:	490c      	ldr	r1, [pc, #48]	; (11e1c <CTP_notify_handle+0xf8>)
   11dea:	a804      	add	r0, sp, #16
   11dec:	f01d fc53 	bl	2f696 <strcpy>
		tp_type = TP_EVENT_LONG_PRESS;
   11df0:	2506      	movs	r5, #6
   11df2:	e7ce      	b.n	11d92 <CTP_notify_handle+0x6e>
   11df4:	0003040c 	.word	0x0003040c
   11df8:	00030524 	.word	0x00030524
   11dfc:	000313fa 	.word	0x000313fa
   11e00:	0003140d 	.word	0x0003140d
   11e04:	00031422 	.word	0x00031422
   11e08:	0003142f 	.word	0x0003142f
   11e0c:	0003143c 	.word	0x0003143c
   11e10:	00031449 	.word	0x00031449
   11e14:	00031456 	.word	0x00031456
   11e18:	00031463 	.word	0x00031463
   11e1c:	00031470 	.word	0x00031470

00011e20 <wifi_sacn_notify_handle>:
{
   11e20:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   11e22:	4602      	mov	r2, r0
	LOG_INF("%x,%x,%x,%x,%x,%x\n",buf[5],buf[6],buf[7],buf[8],buf[9],buf[10]);
   11e24:	2303      	movs	r3, #3
   11e26:	f04f 0000 	mov.w	r0, #0
   11e2a:	490c      	ldr	r1, [pc, #48]	; (11e5c <wifi_sacn_notify_handle+0x3c>)
   11e2c:	f363 0007 	bfi	r0, r3, #0, #8
   11e30:	4b0b      	ldr	r3, [pc, #44]	; (11e60 <wifi_sacn_notify_handle+0x40>)
   11e32:	1a5b      	subs	r3, r3, r1
   11e34:	08db      	lsrs	r3, r3, #3
   11e36:	f363 108f 	bfi	r0, r3, #6, #10
   11e3a:	7a93      	ldrb	r3, [r2, #10]
   11e3c:	4909      	ldr	r1, [pc, #36]	; (11e64 <wifi_sacn_notify_handle+0x44>)
   11e3e:	9303      	str	r3, [sp, #12]
   11e40:	7a53      	ldrb	r3, [r2, #9]
   11e42:	9302      	str	r3, [sp, #8]
   11e44:	7a13      	ldrb	r3, [r2, #8]
   11e46:	9301      	str	r3, [sp, #4]
   11e48:	79d3      	ldrb	r3, [r2, #7]
   11e4a:	9300      	str	r3, [sp, #0]
   11e4c:	7993      	ldrb	r3, [r2, #6]
   11e4e:	7952      	ldrb	r2, [r2, #5]
   11e50:	f01b fa52 	bl	2d2f8 <log_string_sync>
}
   11e54:	b005      	add	sp, #20
   11e56:	f85d fb04 	ldr.w	pc, [sp], #4
   11e5a:	bf00      	nop
   11e5c:	0003040c 	.word	0x0003040c
   11e60:	00030524 	.word	0x00030524
   11e64:	000313fa 	.word	0x000313fa

00011e68 <APP_reply_find_phone>:
	ble_send_date_handle(reply, reply_len);
}

//APP
void APP_reply_find_phone(u8_t *buf, u32_t len)
{
   11e68:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	u32_t i;

	LOG_INF("APP_reply_find_phone\n");
   11e6c:	2303      	movs	r3, #3
{
   11e6e:	4680      	mov	r8, r0
	LOG_INF("APP_reply_find_phone\n");
   11e70:	f04f 0000 	mov.w	r0, #0
   11e74:	4c12      	ldr	r4, [pc, #72]	; (11ec0 <APP_reply_find_phone+0x58>)
   11e76:	f363 0007 	bfi	r0, r3, #0, #8
   11e7a:	4b12      	ldr	r3, [pc, #72]	; (11ec4 <APP_reply_find_phone+0x5c>)
{
   11e7c:	460f      	mov	r7, r1
	LOG_INF("APP_reply_find_phone\n");
   11e7e:	1ae4      	subs	r4, r4, r3
   11e80:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   11e84:	f364 108f 	bfi	r0, r4, #6, #10
   11e88:	490f      	ldr	r1, [pc, #60]	; (11ec8 <APP_reply_find_phone+0x60>)
   11e8a:	f01b fa35 	bl	2d2f8 <log_string_sync>
	
	for(i=0;i<len;i++)
   11e8e:	2500      	movs	r5, #0
	{
		LOG_INF("i:%d, data:%02X\n", i, buf[i]);
   11e90:	f8df 9038 	ldr.w	r9, [pc, #56]	; 11ecc <APP_reply_find_phone+0x64>
	for(i=0;i<len;i++)
   11e94:	42af      	cmp	r7, r5
   11e96:	d101      	bne.n	11e9c <APP_reply_find_phone+0x34>
	}
}
   11e98:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		LOG_INF("i:%d, data:%02X\n", i, buf[i]);
   11e9c:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   11ea0:	f043 0303 	orr.w	r3, r3, #3
   11ea4:	f363 0607 	bfi	r6, r3, #0, #8
   11ea8:	f364 168f 	bfi	r6, r4, #6, #10
   11eac:	f818 3005 	ldrb.w	r3, [r8, r5]
   11eb0:	462a      	mov	r2, r5
   11eb2:	4649      	mov	r1, r9
   11eb4:	4630      	mov	r0, r6
   11eb6:	f01b fa1f 	bl	2d2f8 <log_string_sync>
	for(i=0;i<len;i++)
   11eba:	3501      	adds	r5, #1
   11ebc:	e7ea      	b.n	11e94 <APP_reply_find_phone+0x2c>
   11ebe:	bf00      	nop
   11ec0:	00030524 	.word	0x00030524
   11ec4:	0003040c 	.word	0x0003040c
   11ec8:	000313b2 	.word	0x000313b2
   11ecc:	000313c8 	.word	0x000313c8

00011ed0 <get_nrf52810_ver_response>:

void get_nrf52810_ver_response(u8_t *buf, u32_t len)
{
	u32_t i;

	for(i=0;i<len-9;i++)
   11ed0:	4401      	add	r1, r0
   11ed2:	4a0c      	ldr	r2, [pc, #48]	; (11f04 <get_nrf52810_ver_response+0x34>)
   11ed4:	1d83      	adds	r3, r0, #6
   11ed6:	3903      	subs	r1, #3
   11ed8:	428b      	cmp	r3, r1
   11eda:	d10e      	bne.n	11efa <get_nrf52810_ver_response+0x2a>
	{
		str_nrf52810_ver[i] = buf[7+i];
	}

	LOG_INF("str_nrf52810_ver:%s\n", str_nrf52810_ver);
   11edc:	2303      	movs	r3, #3
   11ede:	f04f 0000 	mov.w	r0, #0
   11ee2:	4a09      	ldr	r2, [pc, #36]	; (11f08 <get_nrf52810_ver_response+0x38>)
   11ee4:	f363 0007 	bfi	r0, r3, #0, #8
   11ee8:	4b08      	ldr	r3, [pc, #32]	; (11f0c <get_nrf52810_ver_response+0x3c>)
   11eea:	4909      	ldr	r1, [pc, #36]	; (11f10 <get_nrf52810_ver_response+0x40>)
   11eec:	1a9b      	subs	r3, r3, r2
   11eee:	08db      	lsrs	r3, r3, #3
   11ef0:	f363 108f 	bfi	r0, r3, #6, #10
   11ef4:	4a03      	ldr	r2, [pc, #12]	; (11f04 <get_nrf52810_ver_response+0x34>)
   11ef6:	f01b b9ff 	b.w	2d2f8 <log_string_sync>
		str_nrf52810_ver[i] = buf[7+i];
   11efa:	f813 0f01 	ldrb.w	r0, [r3, #1]!
   11efe:	f802 0b01 	strb.w	r0, [r2], #1
   11f02:	e7e9      	b.n	11ed8 <get_nrf52810_ver_response+0x8>
   11f04:	2002f8a9 	.word	0x2002f8a9
   11f08:	0003040c 	.word	0x0003040c
   11f0c:	00030524 	.word	0x00030524
   11f10:	00031545 	.word	0x00031545

00011f14 <get_ble_mac_address_response>:
}

void get_ble_mac_address_response(u8_t *buf, u32_t len)
{
   11f14:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   11f16:	4912      	ldr	r1, [pc, #72]	; (11f60 <get_ble_mac_address_response+0x4c>)
   11f18:	1d83      	adds	r3, r0, #6
   11f1a:	460a      	mov	r2, r1
   11f1c:	300c      	adds	r0, #12
	u32_t i;

	for(i=0;i<6;i++)
	{
		ble_mac_addr[i] = buf[7+i];
   11f1e:	f813 4f01 	ldrb.w	r4, [r3, #1]!
	for(i=0;i<6;i++)
   11f22:	4283      	cmp	r3, r0
		ble_mac_addr[i] = buf[7+i];
   11f24:	f801 4b01 	strb.w	r4, [r1], #1
	for(i=0;i<6;i++)
   11f28:	d1f9      	bne.n	11f1e <get_ble_mac_address_response+0xa>
	}

	LOG_INF("ble_mac_addr %02X:%02X:%02X:%02X:%02X:%02X\n",
   11f2a:	2303      	movs	r3, #3
   11f2c:	f04f 0000 	mov.w	r0, #0
   11f30:	490c      	ldr	r1, [pc, #48]	; (11f64 <get_ble_mac_address_response+0x50>)
   11f32:	f363 0007 	bfi	r0, r3, #0, #8
   11f36:	4b0c      	ldr	r3, [pc, #48]	; (11f68 <get_ble_mac_address_response+0x54>)
   11f38:	1a5b      	subs	r3, r3, r1
   11f3a:	08db      	lsrs	r3, r3, #3
   11f3c:	f363 108f 	bfi	r0, r3, #6, #10
   11f40:	7953      	ldrb	r3, [r2, #5]
   11f42:	490a      	ldr	r1, [pc, #40]	; (11f6c <get_ble_mac_address_response+0x58>)
   11f44:	9303      	str	r3, [sp, #12]
   11f46:	7913      	ldrb	r3, [r2, #4]
   11f48:	9302      	str	r3, [sp, #8]
   11f4a:	78d3      	ldrb	r3, [r2, #3]
   11f4c:	9301      	str	r3, [sp, #4]
   11f4e:	7893      	ldrb	r3, [r2, #2]
   11f50:	9300      	str	r3, [sp, #0]
   11f52:	7853      	ldrb	r3, [r2, #1]
   11f54:	7812      	ldrb	r2, [r2, #0]
   11f56:	f01b f9cf 	bl	2d2f8 <log_string_sync>
							ble_mac_addr[2],
							ble_mac_addr[3],
							ble_mac_addr[4],
							ble_mac_addr[5]
							);
}
   11f5a:	b004      	add	sp, #16
   11f5c:	bd10      	pop	{r4, pc}
   11f5e:	bf00      	nop
   11f60:	2002f4a3 	.word	0x2002f4a3
   11f64:	0003040c 	.word	0x0003040c
   11f68:	00030524 	.word	0x00030524
   11f6c:	0003150a 	.word	0x0003150a

00011f70 <get_ble_status_response>:

void get_ble_status_response(u8_t *buf, u32_t len)
{
   11f70:	b510      	push	{r4, lr}
	LOG_INF("BLE_status:%d\n", buf[6]);
   11f72:	2303      	movs	r3, #3
{
   11f74:	4604      	mov	r4, r0
	LOG_INF("BLE_status:%d\n", buf[6]);
   11f76:	f04f 0000 	mov.w	r0, #0
   11f7a:	4a08      	ldr	r2, [pc, #32]	; (11f9c <get_ble_status_response+0x2c>)
   11f7c:	f363 0007 	bfi	r0, r3, #0, #8
   11f80:	4b07      	ldr	r3, [pc, #28]	; (11fa0 <get_ble_status_response+0x30>)
   11f82:	4908      	ldr	r1, [pc, #32]	; (11fa4 <get_ble_status_response+0x34>)
   11f84:	1a9b      	subs	r3, r3, r2
   11f86:	08db      	lsrs	r3, r3, #3
   11f88:	f363 108f 	bfi	r0, r3, #6, #10
   11f8c:	79a2      	ldrb	r2, [r4, #6]
   11f8e:	f01b f9b3 	bl	2d2f8 <log_string_sync>

	g_ble_status = buf[6];
   11f92:	79a2      	ldrb	r2, [r4, #6]
   11f94:	4b04      	ldr	r3, [pc, #16]	; (11fa8 <get_ble_status_response+0x38>)
   11f96:	701a      	strb	r2, [r3, #0]
}
   11f98:	bd10      	pop	{r4, pc}
   11f9a:	bf00      	nop
   11f9c:	0003040c 	.word	0x0003040c
   11fa0:	00030524 	.word	0x00030524
   11fa4:	00031536 	.word	0x00031536
   11fa8:	2003b5af 	.word	0x2003b5af

00011fac <ble_send_date_handle>:
		break;
	}
}

void ble_send_date_handle(u8_t *buf, u32_t len)
{
   11fac:	b570      	push	{r4, r5, r6, lr}
	LOG_INF("ble_send_date_handle\n");
   11fae:	2303      	movs	r3, #3
{
   11fb0:	4605      	mov	r5, r0
	LOG_INF("ble_send_date_handle\n");
   11fb2:	f04f 0000 	mov.w	r0, #0
{
   11fb6:	460e      	mov	r6, r1
   11fb8:	4a0a      	ldr	r2, [pc, #40]	; (11fe4 <ble_send_date_handle+0x38>)
	LOG_INF("ble_send_date_handle\n");
   11fba:	f363 0007 	bfi	r0, r3, #0, #8
   11fbe:	4b0a      	ldr	r3, [pc, #40]	; (11fe8 <ble_send_date_handle+0x3c>)

	uart_fifo_fill(uart_ble, buf, len);
   11fc0:	4c0a      	ldr	r4, [pc, #40]	; (11fec <ble_send_date_handle+0x40>)
   11fc2:	1a9b      	subs	r3, r3, r2
   11fc4:	08db      	lsrs	r3, r3, #3
	LOG_INF("ble_send_date_handle\n");
   11fc6:	f363 108f 	bfi	r0, r3, #6, #10
   11fca:	4909      	ldr	r1, [pc, #36]	; (11ff0 <ble_send_date_handle+0x44>)
   11fcc:	f01b f994 	bl	2d2f8 <log_string_sync>
	uart_fifo_fill(uart_ble, buf, len);
   11fd0:	4632      	mov	r2, r6
   11fd2:	4629      	mov	r1, r5
   11fd4:	6820      	ldr	r0, [r4, #0]
   11fd6:	f019 fb4b 	bl	2b670 <uart_fifo_fill>
	uart_irq_tx_enable(uart_ble); 
   11fda:	6820      	ldr	r0, [r4, #0]
}
   11fdc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		arch_syscall_invoke1(*(uintptr_t *)&dev, K_SYSCALL_UART_IRQ_TX_ENABLE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_tx_enable(dev);
   11fe0:	f019 bb4c 	b.w	2b67c <z_impl_uart_irq_tx_enable>
   11fe4:	0003040c 	.word	0x0003040c
   11fe8:	00030524 	.word	0x00030524
   11fec:	20020cb8 	.word	0x20020cb8
   11ff0:	000314f4 	.word	0x000314f4

00011ff4 <APP_set_find_device>:
{
   11ff4:	b500      	push	{lr}
   11ff6:	b0a1      	sub	sp, #132	; 0x84
	u8_t reply[128] = {0};
   11ff8:	2100      	movs	r1, #0
   11ffa:	2280      	movs	r2, #128	; 0x80
   11ffc:	4668      	mov	r0, sp
   11ffe:	f01d f9c9 	bl	2f394 <memset>
	reply[reply_len++] = PACKET_HEAD;
   12002:	23ab      	movs	r3, #171	; 0xab
   12004:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   12008:	f64f 7306 	movw	r3, #65286	; 0xff06
   1200c:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(FIND_DEVICE_ID&0x00ff);
   12010:	f248 0337 	movw	r3, #32823	; 0x8037
   12014:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   12018:	2388      	movs	r3, #136	; 0x88
   1201a:	4669      	mov	r1, sp
   1201c:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   12020:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   12022:	f811 2b01 	ldrb.w	r2, [r1], #1
   12026:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   1202a:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   1202c:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   1202e:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   12030:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   12034:	d1f5      	bne.n	12022 <APP_set_find_device+0x2e>
	ble_send_date_handle(reply, reply_len);
   12036:	2109      	movs	r1, #9
   12038:	4668      	mov	r0, sp
   1203a:	f7ff ffb7 	bl	11fac <ble_send_date_handle>
	app_find_device = true;	
   1203e:	2201      	movs	r2, #1
   12040:	4b02      	ldr	r3, [pc, #8]	; (1204c <APP_set_find_device+0x58>)
   12042:	701a      	strb	r2, [r3, #0]
}
   12044:	b021      	add	sp, #132	; 0x84
   12046:	f85d fb04 	ldr.w	pc, [sp], #4
   1204a:	bf00      	nop
   1204c:	2002d496 	.word	0x2002d496

00012050 <APP_set_language>:
{
   12050:	b510      	push	{r4, lr}
   12052:	4604      	mov	r4, r0
   12054:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   12056:	2280      	movs	r2, #128	; 0x80
   12058:	2100      	movs	r1, #0
   1205a:	4668      	mov	r0, sp
   1205c:	f01d f99a 	bl	2f394 <memset>
	if(buf[7] == 0x00)
   12060:	79e2      	ldrb	r2, [r4, #7]
   12062:	4b1b      	ldr	r3, [pc, #108]	; (120d0 <APP_set_language+0x80>)
   12064:	bb7a      	cbnz	r2, 120c6 <APP_set_language+0x76>
		global_settings.language = LANGUAGE_CHN;
   12066:	2201      	movs	r2, #1
		global_settings.language = LANGUAGE_JPN;
   12068:	725a      	strb	r2, [r3, #9]
	reply[reply_len++] = PACKET_HEAD;
   1206a:	23ab      	movs	r3, #171	; 0xab
   1206c:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   12070:	f64f 7306 	movw	r3, #65286	; 0xff06
   12074:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(LANGUAGE_SETTING_ID&0x00ff);
   12078:	f248 0345 	movw	r3, #32837	; 0x8045
   1207c:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   12080:	2388      	movs	r3, #136	; 0x88
   12082:	4669      	mov	r1, sp
   12084:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   12088:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   1208a:	f811 2b01 	ldrb.w	r2, [r1], #1
   1208e:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   12092:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   12094:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   12096:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   12098:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   1209c:	d1f5      	bne.n	1208a <APP_set_language+0x3a>
	ble_send_date_handle(reply, reply_len);
   1209e:	2109      	movs	r1, #9
   120a0:	4668      	mov	r0, sp
   120a2:	f7ff ff83 	bl	11fac <ble_send_date_handle>
	if(screen_id == SCREEN_ID_IDLE)
   120a6:	4b0b      	ldr	r3, [pc, #44]	; (120d4 <APP_set_language+0x84>)
   120a8:	781b      	ldrb	r3, [r3, #0]
   120aa:	2b01      	cmp	r3, #1
   120ac:	d106      	bne.n	120bc <APP_set_language+0x6c>
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_WEEK;
   120ae:	4b0a      	ldr	r3, [pc, #40]	; (120d8 <APP_set_language+0x88>)
   120b0:	68da      	ldr	r2, [r3, #12]
   120b2:	f042 0210 	orr.w	r2, r2, #16
   120b6:	60da      	str	r2, [r3, #12]
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   120b8:	2202      	movs	r2, #2
   120ba:	725a      	strb	r2, [r3, #9]
	need_save_settings = true;
   120bc:	2201      	movs	r2, #1
   120be:	4b07      	ldr	r3, [pc, #28]	; (120dc <APP_set_language+0x8c>)
   120c0:	701a      	strb	r2, [r3, #0]
}
   120c2:	b020      	add	sp, #128	; 0x80
   120c4:	bd10      	pop	{r4, pc}
	else if(buf[7] == 0x01)
   120c6:	2a02      	cmp	r2, #2
		global_settings.language = LANGUAGE_EN;
   120c8:	bf18      	it	ne
   120ca:	2200      	movne	r2, #0
   120cc:	e7cc      	b.n	12068 <APP_set_language+0x18>
   120ce:	bf00      	nop
   120d0:	2002d422 	.word	0x2002d422
   120d4:	2002ff93 	.word	0x2002ff93
   120d8:	20028540 	.word	0x20028540
   120dc:	2002f49f 	.word	0x2002f49f

000120e0 <APP_set_time_24_format>:
{
   120e0:	b510      	push	{r4, lr}
   120e2:	4604      	mov	r4, r0
   120e4:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   120e6:	2280      	movs	r2, #128	; 0x80
   120e8:	2100      	movs	r1, #0
   120ea:	4668      	mov	r0, sp
   120ec:	f01d f952 	bl	2f394 <memset>
	if(buf[7] == 0x00)
   120f0:	79e2      	ldrb	r2, [r4, #7]
   120f2:	4b19      	ldr	r3, [pc, #100]	; (12158 <APP_set_time_24_format+0x78>)
   120f4:	2a01      	cmp	r2, #1
		global_settings.time_format = TIME_FORMAT_24;//24 format
   120f6:	bf18      	it	ne
   120f8:	2200      	movne	r2, #0
		global_settings.time_format = TIME_FORMAT_12;//12 format
   120fa:	721a      	strb	r2, [r3, #8]
	reply[reply_len++] = PACKET_HEAD;
   120fc:	23ab      	movs	r3, #171	; 0xab
   120fe:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   12102:	f64f 7306 	movw	r3, #65286	; 0xff06
   12106:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(TIME_24_SETTING_ID&0x00ff);
   1210a:	f248 0346 	movw	r3, #32838	; 0x8046
   1210e:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   12112:	2388      	movs	r3, #136	; 0x88
   12114:	4669      	mov	r1, sp
   12116:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   1211a:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   1211c:	f811 2b01 	ldrb.w	r2, [r1], #1
   12120:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   12124:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   12126:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   12128:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   1212a:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   1212e:	d1f5      	bne.n	1211c <APP_set_time_24_format+0x3c>
	ble_send_date_handle(reply, reply_len);
   12130:	2109      	movs	r1, #9
   12132:	4668      	mov	r0, sp
   12134:	f7ff ff3a 	bl	11fac <ble_send_date_handle>
	if(screen_id == SCREEN_ID_IDLE)
   12138:	4b08      	ldr	r3, [pc, #32]	; (1215c <APP_set_time_24_format+0x7c>)
   1213a:	781b      	ldrb	r3, [r3, #0]
   1213c:	2b01      	cmp	r3, #1
   1213e:	d106      	bne.n	1214e <APP_set_time_24_format+0x6e>
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_TIME;
   12140:	4b07      	ldr	r3, [pc, #28]	; (12160 <APP_set_time_24_format+0x80>)
   12142:	68da      	ldr	r2, [r3, #12]
   12144:	f042 0204 	orr.w	r2, r2, #4
   12148:	60da      	str	r2, [r3, #12]
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   1214a:	2202      	movs	r2, #2
   1214c:	725a      	strb	r2, [r3, #9]
	need_save_settings = true;	
   1214e:	2201      	movs	r2, #1
   12150:	4b04      	ldr	r3, [pc, #16]	; (12164 <APP_set_time_24_format+0x84>)
   12152:	701a      	strb	r2, [r3, #0]
}
   12154:	b020      	add	sp, #128	; 0x80
   12156:	bd10      	pop	{r4, pc}
   12158:	2002d422 	.word	0x2002d422
   1215c:	2002ff93 	.word	0x2002ff93
   12160:	20028540 	.word	0x20028540
   12164:	2002f49f 	.word	0x2002f49f

00012168 <APP_set_date_format>:
{
   12168:	b510      	push	{r4, lr}
   1216a:	4604      	mov	r4, r0
   1216c:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   1216e:	2280      	movs	r2, #128	; 0x80
   12170:	2100      	movs	r1, #0
   12172:	4668      	mov	r0, sp
   12174:	f01d f90e 	bl	2f394 <memset>
	if(buf[7] == 0x00)
   12178:	79e3      	ldrb	r3, [r4, #7]
   1217a:	4a1b      	ldr	r2, [pc, #108]	; (121e8 <APP_set_date_format+0x80>)
   1217c:	bb7b      	cbnz	r3, 121de <APP_set_date_format+0x76>
		global_settings.date_format = DATE_FORMAT_YYYYMMDD;
   1217e:	2300      	movs	r3, #0
		global_settings.date_format = DATE_FORMAT_DDMMYYYY;
   12180:	7293      	strb	r3, [r2, #10]
	reply[reply_len++] = PACKET_HEAD;
   12182:	23ab      	movs	r3, #171	; 0xab
   12184:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   12188:	f64f 7306 	movw	r3, #65286	; 0xff06
   1218c:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(DATE_FORMAT_ID&0x00ff);
   12190:	f248 0356 	movw	r3, #32854	; 0x8056
   12194:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   12198:	2388      	movs	r3, #136	; 0x88
   1219a:	4669      	mov	r1, sp
   1219c:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   121a0:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   121a2:	f811 2b01 	ldrb.w	r2, [r1], #1
   121a6:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   121aa:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   121ac:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   121ae:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   121b0:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   121b4:	d1f5      	bne.n	121a2 <APP_set_date_format+0x3a>
	ble_send_date_handle(reply, reply_len);
   121b6:	2109      	movs	r1, #9
   121b8:	4668      	mov	r0, sp
   121ba:	f7ff fef7 	bl	11fac <ble_send_date_handle>
	if(screen_id == SCREEN_ID_IDLE)
   121be:	4b0b      	ldr	r3, [pc, #44]	; (121ec <APP_set_date_format+0x84>)
   121c0:	781b      	ldrb	r3, [r3, #0]
   121c2:	2b01      	cmp	r3, #1
   121c4:	d106      	bne.n	121d4 <APP_set_date_format+0x6c>
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_DATE;
   121c6:	4b0a      	ldr	r3, [pc, #40]	; (121f0 <APP_set_date_format+0x88>)
   121c8:	68da      	ldr	r2, [r3, #12]
   121ca:	f042 0208 	orr.w	r2, r2, #8
   121ce:	60da      	str	r2, [r3, #12]
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   121d0:	2202      	movs	r2, #2
   121d2:	725a      	strb	r2, [r3, #9]
	need_save_settings = true;
   121d4:	2201      	movs	r2, #1
   121d6:	4b07      	ldr	r3, [pc, #28]	; (121f4 <APP_set_date_format+0x8c>)
   121d8:	701a      	strb	r2, [r3, #0]
}
   121da:	b020      	add	sp, #128	; 0x80
   121dc:	bd10      	pop	{r4, pc}
	else if(buf[7] == 0x01)
   121de:	2b01      	cmp	r3, #1
   121e0:	d0ce      	beq.n	12180 <APP_set_date_format+0x18>
	else if(buf[7] == 0x02)
   121e2:	2b02      	cmp	r3, #2
   121e4:	d1cb      	bne.n	1217e <APP_set_date_format+0x16>
   121e6:	e7cb      	b.n	12180 <APP_set_date_format+0x18>
   121e8:	2002d422 	.word	0x2002d422
   121ec:	2002ff93 	.word	0x2002ff93
   121f0:	20028540 	.word	0x20028540
   121f4:	2002f49f 	.word	0x2002f49f

000121f8 <APP_set_date_time>:
{
   121f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   121fc:	4604      	mov	r4, r0
   121fe:	b0a2      	sub	sp, #136	; 0x88
	u8_t reply[128] = {0};
   12200:	2100      	movs	r1, #0
   12202:	2280      	movs	r2, #128	; 0x80
   12204:	a802      	add	r0, sp, #8
   12206:	f01d f8c5 	bl	2f394 <memset>
	datetime.year = 256*buf[7]+buf[8];
   1220a:	79e3      	ldrb	r3, [r4, #7]
   1220c:	7a25      	ldrb	r5, [r4, #8]
	datetime.month = buf[9];
   1220e:	f894 9009 	ldrb.w	r9, [r4, #9]
	datetime.year = 256*buf[7]+buf[8];
   12212:	eb05 2503 	add.w	r5, r5, r3, lsl #8
	if(CheckSystemDateTimeIsValid(datetime))
   12216:	2300      	movs	r3, #0
	datetime.day = buf[10];
   12218:	f894 800a 	ldrb.w	r8, [r4, #10]
	datetime.hour = buf[11];
   1221c:	7ae7      	ldrb	r7, [r4, #11]
	datetime.minute = buf[12];
   1221e:	7b26      	ldrb	r6, [r4, #12]
	datetime.second = buf[13];
   12220:	f894 a00d 	ldrb.w	sl, [r4, #13]
	if(CheckSystemDateTimeIsValid(datetime))
   12224:	466c      	mov	r4, sp
	datetime.year = 256*buf[7]+buf[8];
   12226:	b2ad      	uxth	r5, r5
	if(CheckSystemDateTimeIsValid(datetime))
   12228:	f8ad 5000 	strh.w	r5, [sp]
   1222c:	f88d 9002 	strb.w	r9, [sp, #2]
   12230:	f88d 8003 	strb.w	r8, [sp, #3]
   12234:	f88d 7004 	strb.w	r7, [sp, #4]
   12238:	f88d 6005 	strb.w	r6, [sp, #5]
   1223c:	f88d a006 	strb.w	sl, [sp, #6]
   12240:	f88d 3007 	strb.w	r3, [sp, #7]
   12244:	e894 0003 	ldmia.w	r4, {r0, r1}
   12248:	f019 f95f 	bl	2b50a <CheckSystemDateTimeIsValid>
   1224c:	b1e0      	cbz	r0, 12288 <APP_set_date_time+0x90>
		datetime.week = GetWeekDayByDate(datetime);
   1224e:	e894 0003 	ldmia.w	r4, {r0, r1}
   12252:	f019 f8f5 	bl	2b440 <GetWeekDayByDate>
		memcpy(&date_time, &datetime, sizeof(sys_date_timer_t));
   12256:	4b1a      	ldr	r3, [pc, #104]	; (122c0 <APP_set_date_time+0xc8>)
   12258:	801d      	strh	r5, [r3, #0]
   1225a:	f883 9002 	strb.w	r9, [r3, #2]
   1225e:	f883 8003 	strb.w	r8, [r3, #3]
   12262:	711f      	strb	r7, [r3, #4]
   12264:	715e      	strb	r6, [r3, #5]
   12266:	f883 a006 	strb.w	sl, [r3, #6]
		datetime.week = GetWeekDayByDate(datetime);
   1226a:	71d8      	strb	r0, [r3, #7]
		if(screen_id == SCREEN_ID_IDLE)
   1226c:	4b15      	ldr	r3, [pc, #84]	; (122c4 <APP_set_date_time+0xcc>)
   1226e:	781b      	ldrb	r3, [r3, #0]
   12270:	2b01      	cmp	r3, #1
   12272:	d106      	bne.n	12282 <APP_set_date_time+0x8a>
			scr_msg[screen_id].para |= (SCREEN_EVENT_UPDATE_TIME|SCREEN_EVENT_UPDATE_DATE|SCREEN_EVENT_UPDATE_WEEK);
   12274:	4b14      	ldr	r3, [pc, #80]	; (122c8 <APP_set_date_time+0xd0>)
   12276:	68da      	ldr	r2, [r3, #12]
   12278:	f042 021c 	orr.w	r2, r2, #28
   1227c:	60da      	str	r2, [r3, #12]
			scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   1227e:	2202      	movs	r2, #2
   12280:	725a      	strb	r2, [r3, #9]
		need_save_time = true;
   12282:	2201      	movs	r2, #1
   12284:	4b11      	ldr	r3, [pc, #68]	; (122cc <APP_set_date_time+0xd4>)
   12286:	701a      	strb	r2, [r3, #0]
	reply[reply_len++] = (u8_t)(TIME_SYNC_ID&0x00ff);
   12288:	f248 0349 	movw	r3, #32841	; 0x8049
   1228c:	4a10      	ldr	r2, [pc, #64]	; (122d0 <APP_set_date_time+0xd8>)
   1228e:	a902      	add	r1, sp, #8
   12290:	e9cd 2302 	strd	r2, r3, [sp, #8]
	reply[reply_len++] = PACKET_END;
   12294:	2388      	movs	r3, #136	; 0x88
   12296:	f88d 3010 	strb.w	r3, [sp, #16]
	for(i=0;i<(reply_len-2);i++)
   1229a:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   1229c:	f811 2b01 	ldrb.w	r2, [r1], #1
   122a0:	f89d 000f 	ldrb.w	r0, [sp, #15]
	for(i=0;i<(reply_len-2);i++)
   122a4:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   122a6:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   122a8:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   122aa:	f88d 200f 	strb.w	r2, [sp, #15]
	for(i=0;i<(reply_len-2);i++)
   122ae:	d1f5      	bne.n	1229c <APP_set_date_time+0xa4>
	ble_send_date_handle(reply, reply_len);	
   122b0:	2109      	movs	r1, #9
   122b2:	a802      	add	r0, sp, #8
   122b4:	f7ff fe7a 	bl	11fac <ble_send_date_handle>
}
   122b8:	b022      	add	sp, #136	; 0x88
   122ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   122be:	bf00      	nop
   122c0:	2002d410 	.word	0x2002d410
   122c4:	2002ff93 	.word	0x2002ff93
   122c8:	20028540 	.word	0x20028540
   122cc:	2002f4a0 	.word	0x2002f4a0
   122d0:	ff0600ab 	.word	0xff0600ab

000122d4 <APP_set_alarm>:
{
   122d4:	b510      	push	{r4, lr}
   122d6:	b0a2      	sub	sp, #136	; 0x88
   122d8:	4604      	mov	r4, r0
	u8_t result=0,reply[128] = {0};
   122da:	2280      	movs	r2, #128	; 0x80
   122dc:	2100      	movs	r1, #0
   122de:	a802      	add	r0, sp, #8
   122e0:	f01d f858 	bl	2f394 <memset>
	alarm_infor_t infor = {0};
   122e4:	2300      	movs	r3, #0
   122e6:	9301      	str	r3, [sp, #4]
	index = buf[7];
   122e8:	79e3      	ldrb	r3, [r4, #7]
	if(index <= 7)
   122ea:	2b07      	cmp	r3, #7
   122ec:	d921      	bls.n	12332 <APP_set_alarm+0x5e>
	u8_t result=0,reply[128] = {0};
   122ee:	2300      	movs	r3, #0
	reply[reply_len++] = PACKET_HEAD;
   122f0:	22ab      	movs	r2, #171	; 0xab
   122f2:	f88d 2008 	strb.w	r2, [sp, #8]
	reply[reply_len++] = 0x06;
   122f6:	f64f 7206 	movw	r2, #65286	; 0xff06
	reply[reply_len++] = result;
   122fa:	f88d 300d 	strb.w	r3, [sp, #13]
	reply[reply_len++] = PACKET_END;
   122fe:	2388      	movs	r3, #136	; 0x88
	reply[reply_len++] = 0x06;
   12300:	f8ad 200a 	strh.w	r2, [sp, #10]
	reply[reply_len++] = (u8_t)(ALARM_SETTING_ID&0x00ff);
   12304:	2239      	movs	r2, #57	; 0x39
	reply[reply_len++] = PACKET_END;
   12306:	f88d 3010 	strb.w	r3, [sp, #16]
	for(i=0;i<(reply_len-2);i++)
   1230a:	2300      	movs	r3, #0
	reply[reply_len++] = (u8_t)(ALARM_SETTING_ID&0x00ff);
   1230c:	f88d 200c 	strb.w	r2, [sp, #12]
	for(i=0;i<(reply_len-2);i++)
   12310:	a902      	add	r1, sp, #8
		reply[reply_len-2] += reply[i];
   12312:	f811 2b01 	ldrb.w	r2, [r1], #1
   12316:	f89d 000f 	ldrb.w	r0, [sp, #15]
	for(i=0;i<(reply_len-2);i++)
   1231a:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   1231c:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   1231e:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   12320:	f88d 200f 	strb.w	r2, [sp, #15]
	for(i=0;i<(reply_len-2);i++)
   12324:	d1f5      	bne.n	12312 <APP_set_alarm+0x3e>
	ble_send_date_handle(reply, reply_len);	
   12326:	2109      	movs	r1, #9
   12328:	a802      	add	r0, sp, #8
   1232a:	f7ff fe3f 	bl	11fac <ble_send_date_handle>
}
   1232e:	b022      	add	sp, #136	; 0x88
   12330:	bd10      	pop	{r4, pc}
		infor.is_on = buf[8];	//on\off
   12332:	7a22      	ldrb	r2, [r4, #8]
		infor.hour = buf[9];	//hour
   12334:	7a60      	ldrb	r0, [r4, #9]
		infor.is_on = buf[8];	//on\off
   12336:	3200      	adds	r2, #0
   12338:	bf18      	it	ne
   1233a:	2201      	movne	r2, #1
		infor.minute = buf[10];//minute
   1233c:	7aa1      	ldrb	r1, [r4, #10]
		infor.is_on = buf[8];	//on\off
   1233e:	f88d 2004 	strb.w	r2, [sp, #4]
		infor.repeat = buf[11];//repeat from monday to sunday, for example:0x1111100 means repeat in workday
   12342:	7ae2      	ldrb	r2, [r4, #11]
		if((buf[9]<=23)&&(buf[10]<=59)&&(buf[11]<=0x7f))
   12344:	2817      	cmp	r0, #23
		infor.hour = buf[9];	//hour
   12346:	f88d 0005 	strb.w	r0, [sp, #5]
		infor.minute = buf[10];//minute
   1234a:	f88d 1006 	strb.w	r1, [sp, #6]
		infor.repeat = buf[11];//repeat from monday to sunday, for example:0x1111100 means repeat in workday
   1234e:	f88d 2007 	strb.w	r2, [sp, #7]
		if((buf[9]<=23)&&(buf[10]<=59)&&(buf[11]<=0x7f))
   12352:	d8cc      	bhi.n	122ee <APP_set_alarm+0x1a>
   12354:	293b      	cmp	r1, #59	; 0x3b
   12356:	d8ca      	bhi.n	122ee <APP_set_alarm+0x1a>
   12358:	0612      	lsls	r2, r2, #24
   1235a:	d4c8      	bmi.n	122ee <APP_set_alarm+0x1a>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1235c:	4a04      	ldr	r2, [pc, #16]	; (12370 <APP_set_alarm+0x9c>)
   1235e:	9901      	ldr	r1, [sp, #4]
			memcpy((alarm_infor_t*)&global_settings.alarm[index], (alarm_infor_t*)&infor, sizeof(alarm_infor_t));
   12360:	3304      	adds	r3, #4
   12362:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
			need_save_settings = true;
   12366:	2201      	movs	r2, #1
   12368:	4b02      	ldr	r3, [pc, #8]	; (12374 <APP_set_alarm+0xa0>)
   1236a:	701a      	strb	r2, [r3, #0]
			result = 0x80;
   1236c:	2380      	movs	r3, #128	; 0x80
   1236e:	e7bf      	b.n	122f0 <APP_set_alarm+0x1c>
   12370:	2002d422 	.word	0x2002d422
   12374:	2002f49f 	.word	0x2002f49f

00012378 <APP_set_PHD_interval>:
{
   12378:	b510      	push	{r4, lr}
   1237a:	4604      	mov	r4, r0
   1237c:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   1237e:	2280      	movs	r2, #128	; 0x80
   12380:	2100      	movs	r1, #0
   12382:	4668      	mov	r0, sp
   12384:	f01d f806 	bl	2f394 <memset>
	if(buf[6] == 1)
   12388:	79a3      	ldrb	r3, [r4, #6]
   1238a:	4a16      	ldr	r2, [pc, #88]	; (123e4 <APP_set_PHD_interval+0x6c>)
   1238c:	1e59      	subs	r1, r3, #1
   1238e:	424b      	negs	r3, r1
   12390:	414b      	adcs	r3, r1
   12392:	7393      	strb	r3, [r2, #14]
	global_settings.phd_infor.interval = buf[7];
   12394:	79e3      	ldrb	r3, [r4, #7]
	need_save_settings = true;
   12396:	4c14      	ldr	r4, [pc, #80]	; (123e8 <APP_set_PHD_interval+0x70>)
	global_settings.phd_infor.interval = buf[7];
   12398:	73d3      	strb	r3, [r2, #15]
	need_save_settings = true;
   1239a:	2201      	movs	r2, #1
   1239c:	7022      	strb	r2, [r4, #0]
	reply[reply_len++] = PACKET_HEAD;
   1239e:	22ab      	movs	r2, #171	; 0xab
   123a0:	f88d 2000 	strb.w	r2, [sp]
	reply[reply_len++] = 0x06;
   123a4:	f64f 7206 	movw	r2, #65286	; 0xff06
   123a8:	f8ad 2002 	strh.w	r2, [sp, #2]
	reply[reply_len++] = (u8_t)(MEASURE_HOURLY_ID&0x00ff);
   123ac:	f248 0243 	movw	r2, #32835	; 0x8043
   123b0:	f8ad 2004 	strh.w	r2, [sp, #4]
	reply[reply_len++] = PACKET_END;
   123b4:	2288      	movs	r2, #136	; 0x88
   123b6:	4669      	mov	r1, sp
   123b8:	f88d 2008 	strb.w	r2, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   123bc:	2200      	movs	r2, #0
		reply[reply_len-2] += reply[i];
   123be:	f811 3b01 	ldrb.w	r3, [r1], #1
   123c2:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   123c6:	3201      	adds	r2, #1
		reply[reply_len-2] += reply[i];
   123c8:	4403      	add	r3, r0
	for(i=0;i<(reply_len-2);i++)
   123ca:	2a07      	cmp	r2, #7
		reply[reply_len-2] += reply[i];
   123cc:	f88d 3007 	strb.w	r3, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   123d0:	d1f5      	bne.n	123be <APP_set_PHD_interval+0x46>
	ble_send_date_handle(reply, reply_len);
   123d2:	2109      	movs	r1, #9
   123d4:	4668      	mov	r0, sp
   123d6:	f7ff fde9 	bl	11fac <ble_send_date_handle>
	need_save_settings = true;	
   123da:	2301      	movs	r3, #1
   123dc:	7023      	strb	r3, [r4, #0]
}
   123de:	b020      	add	sp, #128	; 0x80
   123e0:	bd10      	pop	{r4, pc}
   123e2:	bf00      	nop
   123e4:	2002d422 	.word	0x2002d422
   123e8:	2002f49f 	.word	0x2002f49f

000123ec <APP_set_wake_screen_by_wrist>:
{
   123ec:	b510      	push	{r4, lr}
   123ee:	4604      	mov	r4, r0
   123f0:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   123f2:	2280      	movs	r2, #128	; 0x80
   123f4:	2100      	movs	r1, #0
   123f6:	4668      	mov	r0, sp
   123f8:	f01c ffcc 	bl	2f394 <memset>
	if(buf[6] == 1)
   123fc:	79a3      	ldrb	r3, [r4, #6]
   123fe:	4669      	mov	r1, sp
   12400:	1e5a      	subs	r2, r3, #1
   12402:	4253      	negs	r3, r2
   12404:	4153      	adcs	r3, r2
   12406:	4a12      	ldr	r2, [pc, #72]	; (12450 <APP_set_wake_screen_by_wrist+0x64>)
   12408:	7113      	strb	r3, [r2, #4]
	reply[reply_len++] = PACKET_HEAD;
   1240a:	23ab      	movs	r3, #171	; 0xab
   1240c:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   12410:	f64f 7306 	movw	r3, #65286	; 0xff06
   12414:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(SHAKE_SCREEN_ID&0x00ff);
   12418:	f248 0342 	movw	r3, #32834	; 0x8042
   1241c:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   12420:	2388      	movs	r3, #136	; 0x88
   12422:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   12426:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   12428:	f811 2b01 	ldrb.w	r2, [r1], #1
   1242c:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   12430:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   12432:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   12434:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   12436:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   1243a:	d1f5      	bne.n	12428 <APP_set_wake_screen_by_wrist+0x3c>
	ble_send_date_handle(reply, reply_len);
   1243c:	2109      	movs	r1, #9
   1243e:	4668      	mov	r0, sp
   12440:	f7ff fdb4 	bl	11fac <ble_send_date_handle>
	need_save_settings = true;
   12444:	2201      	movs	r2, #1
   12446:	4b03      	ldr	r3, [pc, #12]	; (12454 <APP_set_wake_screen_by_wrist+0x68>)
   12448:	701a      	strb	r2, [r3, #0]
}
   1244a:	b020      	add	sp, #128	; 0x80
   1244c:	bd10      	pop	{r4, pc}
   1244e:	bf00      	nop
   12450:	2002d422 	.word	0x2002d422
   12454:	2002f49f 	.word	0x2002f49f

00012458 <APP_set_factory_reset>:
{
   12458:	b500      	push	{lr}
   1245a:	b0a1      	sub	sp, #132	; 0x84
	u8_t reply[128] = {0};
   1245c:	2100      	movs	r1, #0
   1245e:	2280      	movs	r2, #128	; 0x80
   12460:	4668      	mov	r0, sp
   12462:	f01c ff97 	bl	2f394 <memset>
	reply[reply_len++] = PACKET_HEAD;
   12466:	23ab      	movs	r3, #171	; 0xab
   12468:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x06;
   1246c:	f64f 7306 	movw	r3, #65286	; 0xff06
   12470:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(FACTORY_RESET_ID&0x00ff);
   12474:	f248 0353 	movw	r3, #32851	; 0x8053
   12478:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = PACKET_END;
   1247c:	2388      	movs	r3, #136	; 0x88
   1247e:	4669      	mov	r1, sp
   12480:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   12484:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   12486:	f811 2b01 	ldrb.w	r2, [r1], #1
   1248a:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   1248e:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   12490:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   12492:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   12494:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   12498:	d1f5      	bne.n	12486 <APP_set_factory_reset+0x2e>
	ble_send_date_handle(reply, reply_len);
   1249a:	2109      	movs	r1, #9
   1249c:	4668      	mov	r0, sp
   1249e:	f7ff fd85 	bl	11fac <ble_send_date_handle>
	need_reset_settings = true;
   124a2:	2201      	movs	r2, #1
   124a4:	4b02      	ldr	r3, [pc, #8]	; (124b0 <APP_set_factory_reset+0x58>)
   124a6:	701a      	strb	r2, [r3, #0]
}
   124a8:	b021      	add	sp, #132	; 0x84
   124aa:	f85d fb04 	ldr.w	pc, [sp], #4
   124ae:	bf00      	nop
   124b0:	2002f49e 	.word	0x2002f49e

000124b4 <APP_set_target_steps>:
{
   124b4:	b510      	push	{r4, lr}
   124b6:	b0a0      	sub	sp, #128	; 0x80
   124b8:	4604      	mov	r4, r0
	u8_t reply[128] = {0};
   124ba:	2280      	movs	r2, #128	; 0x80
   124bc:	2100      	movs	r1, #0
   124be:	4668      	mov	r0, sp
   124c0:	f01c ff68 	bl	2f394 <memset>
	LOG_INF("APP_set_target_steps: %02X,%02X\n", buf[7], buf[8]);
   124c4:	2303      	movs	r3, #3
   124c6:	f04f 0000 	mov.w	r0, #0
   124ca:	4a1a      	ldr	r2, [pc, #104]	; (12534 <APP_set_target_steps+0x80>)
   124cc:	f363 0007 	bfi	r0, r3, #0, #8
   124d0:	4b19      	ldr	r3, [pc, #100]	; (12538 <APP_set_target_steps+0x84>)
   124d2:	491a      	ldr	r1, [pc, #104]	; (1253c <APP_set_target_steps+0x88>)
   124d4:	1a9b      	subs	r3, r3, r2
   124d6:	08db      	lsrs	r3, r3, #3
   124d8:	f363 108f 	bfi	r0, r3, #6, #10
   124dc:	79e2      	ldrb	r2, [r4, #7]
   124de:	7a23      	ldrb	r3, [r4, #8]
   124e0:	f01a ff0a 	bl	2d2f8 <log_string_sync>
	global_settings.target_steps = buf[7]*100+buf[8];
   124e4:	79e3      	ldrb	r3, [r4, #7]
   124e6:	7a22      	ldrb	r2, [r4, #8]
   124e8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   124ec:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   124f0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   124f4:	4a12      	ldr	r2, [pc, #72]	; (12540 <APP_set_target_steps+0x8c>)
   124f6:	4669      	mov	r1, sp
   124f8:	80d3      	strh	r3, [r2, #6]
	reply[reply_len++] = (u8_t)(TARGET_STEPS_ID&0x00ff);
   124fa:	f248 0350 	movw	r3, #32848	; 0x8050
   124fe:	4a11      	ldr	r2, [pc, #68]	; (12544 <APP_set_target_steps+0x90>)
   12500:	e9cd 2300 	strd	r2, r3, [sp]
	reply[reply_len++] = PACKET_END;
   12504:	2388      	movs	r3, #136	; 0x88
   12506:	f88d 3008 	strb.w	r3, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   1250a:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   1250c:	f811 2b01 	ldrb.w	r2, [r1], #1
   12510:	f89d 0007 	ldrb.w	r0, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   12514:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   12516:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   12518:	2b07      	cmp	r3, #7
		reply[reply_len-2] += reply[i];
   1251a:	f88d 2007 	strb.w	r2, [sp, #7]
	for(i=0;i<(reply_len-2);i++)
   1251e:	d1f5      	bne.n	1250c <APP_set_target_steps+0x58>
	ble_send_date_handle(reply, reply_len);
   12520:	2109      	movs	r1, #9
   12522:	4668      	mov	r0, sp
   12524:	f7ff fd42 	bl	11fac <ble_send_date_handle>
	need_save_settings = true;
   12528:	2201      	movs	r2, #1
   1252a:	4b07      	ldr	r3, [pc, #28]	; (12548 <APP_set_target_steps+0x94>)
   1252c:	701a      	strb	r2, [r3, #0]
}
   1252e:	b020      	add	sp, #128	; 0x80
   12530:	bd10      	pop	{r4, pc}
   12532:	bf00      	nop
   12534:	0003040c 	.word	0x0003040c
   12538:	00030524 	.word	0x00030524
   1253c:	000313d9 	.word	0x000313d9
   12540:	2002d422 	.word	0x2002d422
   12544:	ff0600ab 	.word	0xff0600ab
   12548:	2002f49f 	.word	0x2002f49f

0001254c <APP_get_current_data>:
{
   1254c:	b500      	push	{lr}
   1254e:	b0c5      	sub	sp, #276	; 0x114
	u8_t wake,reply[128] = {0};
   12550:	2280      	movs	r2, #128	; 0x80
   12552:	2100      	movs	r1, #0
   12554:	a804      	add	r0, sp, #16
   12556:	f01c ff1d 	bl	2f394 <memset>
	GetSportData(&steps, &calorie, &distance);
   1255a:	f10d 020a 	add.w	r2, sp, #10
   1255e:	a902      	add	r1, sp, #8
   12560:	f10d 0006 	add.w	r0, sp, #6
   12564:	f002 fe8e 	bl	15284 <GetSportData>
	GetSleepTimeData(&deep_sleep, &light_sleep);
   12568:	a903      	add	r1, sp, #12
   1256a:	f10d 000e 	add.w	r0, sp, #14
   1256e:	f003 f95f 	bl	15830 <GetSleepTimeData>
	reply[reply_len++] = (steps>>8);
   12572:	f8bd 2006 	ldrh.w	r2, [sp, #6]
	reply[reply_len++] = PACKET_HEAD;
   12576:	4b3f      	ldr	r3, [pc, #252]	; (12674 <APP_get_current_data+0x128>)
	reply[reply_len++] = (steps>>8);
   12578:	0a11      	lsrs	r1, r2, #8
	reply[reply_len++] = (u8_t)(steps&0x00ff);
   1257a:	f88d 2018 	strb.w	r2, [sp, #24]
	reply[reply_len++] = (calorie>>8);
   1257e:	f8bd 2008 	ldrh.w	r2, [sp, #8]
	reply[reply_len++] = (steps>>8);
   12582:	f88d 1017 	strb.w	r1, [sp, #23]
	reply[reply_len++] = (u8_t)(calorie&0x00ff);
   12586:	f88d 201a 	strb.w	r2, [sp, #26]
	reply[reply_len++] = (calorie>>8);
   1258a:	0a11      	lsrs	r1, r2, #8
	reply[reply_len++] = (distance>>8);
   1258c:	f8bd 200a 	ldrh.w	r2, [sp, #10]
	reply[reply_len++] = (calorie>>8);
   12590:	f88d 1019 	strb.w	r1, [sp, #25]
	reply[reply_len++] = (u8_t)(distance&0x00ff);
   12594:	f88d 201c 	strb.w	r2, [sp, #28]
	reply[reply_len++] = (distance>>8);
   12598:	0a11      	lsrs	r1, r2, #8
	reply[reply_len++] = (light_sleep>>8);
   1259a:	f8bd 200c 	ldrh.w	r2, [sp, #12]
	reply[reply_len++] = (distance>>8);
   1259e:	f88d 101b 	strb.w	r1, [sp, #27]
	reply[reply_len++] = (u8_t)(light_sleep&0x00ff);
   125a2:	f88d 201e 	strb.w	r2, [sp, #30]
	reply[reply_len++] = (light_sleep>>8);
   125a6:	0a11      	lsrs	r1, r2, #8
	reply[reply_len++] = (deep_sleep>>8);
   125a8:	f8bd 200e 	ldrh.w	r2, [sp, #14]
	reply[reply_len++] = PACKET_HEAD;
   125ac:	9304      	str	r3, [sp, #16]
	reply[reply_len++] = (light_sleep>>8);
   125ae:	f88d 101d 	strb.w	r1, [sp, #29]
	reply[reply_len++] = (u8_t)(PULL_REFRESH_ID&0x00ff);
   125b2:	f248 0335 	movw	r3, #32821	; 0x8035
	reply[reply_len++] = (deep_sleep>>8);
   125b6:	0a11      	lsrs	r1, r2, #8
	reply[reply_len++] = (u8_t)(deep_sleep&0x00ff);
   125b8:	f88d 2020 	strb.w	r2, [sp, #32]
	reply[reply_len++] = wake;
   125bc:	2208      	movs	r2, #8
	reply[reply_len++] = (u8_t)(PULL_REFRESH_ID&0x00ff);
   125be:	f8ad 3014 	strh.w	r3, [sp, #20]
	reply[reply_len++] = wake;
   125c2:	f88d 2021 	strb.w	r2, [sp, #33]	; 0x21
	reply[reply_len++] = 0x00;
   125c6:	2300      	movs	r3, #0
	reply[reply_len++] = 0x00;
   125c8:	f44f 4208 	mov.w	r2, #34816	; 0x8800
	reply[reply_len++] = (deep_sleep>>8);
   125cc:	f88d 101f 	strb.w	r1, [sp, #31]
	reply[reply_len++] = 0x00;
   125d0:	f88d 3016 	strb.w	r3, [sp, #22]
	reply[reply_len++] = 0x00;
   125d4:	f8ad 2022 	strh.w	r2, [sp, #34]	; 0x22
	for(i=0;i<(reply_len-2);i++)
   125d8:	a904      	add	r1, sp, #16
		reply[reply_len-2] += reply[i];
   125da:	f811 2b01 	ldrb.w	r2, [r1], #1
   125de:	f89d 0022 	ldrb.w	r0, [sp, #34]	; 0x22
	for(i=0;i<(reply_len-2);i++)
   125e2:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   125e4:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   125e6:	2b12      	cmp	r3, #18
		reply[reply_len-2] += reply[i];
   125e8:	f88d 2022 	strb.w	r2, [sp, #34]	; 0x22
	for(i=0;i<(reply_len-2);i++)
   125ec:	d1f5      	bne.n	125da <APP_get_current_data+0x8e>
	ble_send_date_handle(reply, reply_len);
   125ee:	2114      	movs	r1, #20
   125f0:	a804      	add	r0, sp, #16
   125f2:	f7ff fcdb 	bl	11fac <ble_send_date_handle>
	u8_t heart_rate,reply[128] = {0};
   125f6:	2280      	movs	r2, #128	; 0x80
   125f8:	2100      	movs	r1, #0
   125fa:	a824      	add	r0, sp, #144	; 0x90
   125fc:	f01c feca 	bl	2f394 <memset>
	GetHeartRate(&heart_rate);
   12600:	f10d 0005 	add.w	r0, sp, #5
   12604:	f01a fb72 	bl	2ccec <GetHeartRate>
	reply[reply_len++] = PACKET_HEAD;
   12608:	4b1b      	ldr	r3, [pc, #108]	; (12678 <APP_get_current_data+0x12c>)
	reply[reply_len++] = (u8_t)(date_time.year>>8);
   1260a:	4a1c      	ldr	r2, [pc, #112]	; (1267c <APP_get_current_data+0x130>)
	reply[reply_len++] = PACKET_HEAD;
   1260c:	9324      	str	r3, [sp, #144]	; 0x90
	reply[reply_len++] = (u8_t)(PULL_REFRESH_ID&0x00ff);
   1260e:	f248 1335 	movw	r3, #33077	; 0x8135
	reply[reply_len++] = (u8_t)(date_time.year>>8);
   12612:	8811      	ldrh	r1, [r2, #0]
	reply[reply_len++] = (u8_t)(PULL_REFRESH_ID&0x00ff);
   12614:	f8ad 3094 	strh.w	r3, [sp, #148]	; 0x94
	reply[reply_len++] = (u8_t)(date_time.year>>8);
   12618:	0a08      	lsrs	r0, r1, #8
	reply[reply_len++] = (u8_t)(date_time.year&0x00ff);
   1261a:	f88d 1098 	strb.w	r1, [sp, #152]	; 0x98
	reply[reply_len++] = date_time.month;
   1261e:	7891      	ldrb	r1, [r2, #2]
	reply[reply_len++] = 0x00;
   12620:	2300      	movs	r3, #0
	reply[reply_len++] = date_time.month;
   12622:	f88d 1099 	strb.w	r1, [sp, #153]	; 0x99
	reply[reply_len++] = date_time.day;
   12626:	78d1      	ldrb	r1, [r2, #3]
	reply[reply_len++] = 0x00;
   12628:	f88d 3096 	strb.w	r3, [sp, #150]	; 0x96
	reply[reply_len++] = date_time.day;
   1262c:	f88d 109a 	strb.w	r1, [sp, #154]	; 0x9a
	reply[reply_len++] = date_time.hour;
   12630:	7911      	ldrb	r1, [r2, #4]
	reply[reply_len++] = date_time.minute;
   12632:	7952      	ldrb	r2, [r2, #5]
	reply[reply_len++] = date_time.hour;
   12634:	f88d 109b 	strb.w	r1, [sp, #155]	; 0x9b
	reply[reply_len++] = date_time.minute;
   12638:	f88d 209c 	strb.w	r2, [sp, #156]	; 0x9c
	reply[reply_len++] = heart_rate;
   1263c:	f89d 2005 	ldrb.w	r2, [sp, #5]
	reply[reply_len++] = (u8_t)(date_time.year>>8);
   12640:	f88d 0097 	strb.w	r0, [sp, #151]	; 0x97
	reply[reply_len++] = heart_rate;
   12644:	f88d 209d 	strb.w	r2, [sp, #157]	; 0x9d
	reply[reply_len++] = 0x00;
   12648:	f44f 4208 	mov.w	r2, #34816	; 0x8800
   1264c:	a924      	add	r1, sp, #144	; 0x90
   1264e:	f8ad 209e 	strh.w	r2, [sp, #158]	; 0x9e
		reply[reply_len-2] += reply[i];
   12652:	f811 2b01 	ldrb.w	r2, [r1], #1
   12656:	f89d 009e 	ldrb.w	r0, [sp, #158]	; 0x9e
	for(i=0;i<(reply_len-2);i++)
   1265a:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   1265c:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   1265e:	2b0e      	cmp	r3, #14
		reply[reply_len-2] += reply[i];
   12660:	f88d 209e 	strb.w	r2, [sp, #158]	; 0x9e
	for(i=0;i<(reply_len-2);i++)
   12664:	d1f5      	bne.n	12652 <APP_get_current_data+0x106>
	ble_send_date_handle(reply, reply_len);	
   12666:	2110      	movs	r1, #16
   12668:	a824      	add	r0, sp, #144	; 0x90
   1266a:	f7ff fc9f 	bl	11fac <ble_send_date_handle>
}
   1266e:	b045      	add	sp, #276	; 0x114
   12670:	f85d fb04 	ldr.w	pc, [sp], #4
   12674:	ff1100ab 	.word	0xff1100ab
   12678:	ff0d00ab 	.word	0xff0d00ab
   1267c:	2002d410 	.word	0x2002d410

00012680 <APP_get_battery_level>:
{
   12680:	b570      	push	{r4, r5, r6, lr}
   12682:	b0a0      	sub	sp, #128	; 0x80
	u8_t reply[128] = {0};
   12684:	2280      	movs	r2, #128	; 0x80
   12686:	2100      	movs	r1, #0
   12688:	4668      	mov	r0, sp
   1268a:	f01c fe83 	bl	2f394 <memset>
	reply[reply_len++] = PACKET_HEAD;
   1268e:	23ab      	movs	r3, #171	; 0xab
   12690:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x07;
   12694:	f64f 7307 	movw	r3, #65287	; 0xff07
   12698:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(BATTERY_LEVEL_ID&0x00ff);
   1269c:	2351      	movs	r3, #81	; 0x51
   1269e:	f88d 3004 	strb.w	r3, [sp, #4]
	switch(g_chg_status)
   126a2:	4b16      	ldr	r3, [pc, #88]	; (126fc <APP_get_battery_level+0x7c>)
   126a4:	781b      	ldrb	r3, [r3, #0]
   126a6:	b123      	cbz	r3, 126b2 <APP_get_battery_level+0x32>
   126a8:	2b02      	cmp	r3, #2
   126aa:	d825      	bhi.n	126f8 <APP_get_battery_level+0x78>
		reply[reply_len++] = 0x01;
   126ac:	2301      	movs	r3, #1
   126ae:	f88d 3005 	strb.w	r3, [sp, #5]
		reply[reply_len++] = 0x00;
   126b2:	2106      	movs	r1, #6
	reply[reply_len++] = 0x00;
   126b4:	ab20      	add	r3, sp, #128	; 0x80
   126b6:	1858      	adds	r0, r3, r1
	reply[reply_len++] = PACKET_END;
   126b8:	2588      	movs	r5, #136	; 0x88
	reply[reply_len++] = 0x00;
   126ba:	2300      	movs	r3, #0
	reply[reply_len++] = g_bat_soc;
   126bc:	4a10      	ldr	r2, [pc, #64]	; (12700 <APP_get_battery_level+0x80>)
   126be:	1c8c      	adds	r4, r1, #2
   126c0:	7812      	ldrb	r2, [r2, #0]
	reply[reply_len++] = 0x00;
   126c2:	f800 3c80 	strb.w	r3, [r0, #-128]
	reply[reply_len++] = g_bat_soc;
   126c6:	f800 2c7f 	strb.w	r2, [r0, #-127]
	reply[reply_len++] = 0x00;
   126ca:	aa20      	add	r2, sp, #128	; 0x80
   126cc:	4422      	add	r2, r4
   126ce:	f802 3c80 	strb.w	r3, [r2, #-128]
	reply[reply_len++] = PACKET_END;
   126d2:	f800 5c7d 	strb.w	r5, [r0, #-125]
   126d6:	466d      	mov	r5, sp
   126d8:	3104      	adds	r1, #4
		reply[reply_len-2] += reply[i];
   126da:	f815 0b01 	ldrb.w	r0, [r5], #1
   126de:	f812 6c80 	ldrb.w	r6, [r2, #-128]
	for(i=0;i<(reply_len-2);i++)
   126e2:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   126e4:	4430      	add	r0, r6
	for(i=0;i<(reply_len-2);i++)
   126e6:	429c      	cmp	r4, r3
		reply[reply_len-2] += reply[i];
   126e8:	f802 0c80 	strb.w	r0, [r2, #-128]
	for(i=0;i<(reply_len-2);i++)
   126ec:	d8f5      	bhi.n	126da <APP_get_battery_level+0x5a>
	ble_send_date_handle(reply, reply_len);
   126ee:	4668      	mov	r0, sp
   126f0:	f7ff fc5c 	bl	11fac <ble_send_date_handle>
}
   126f4:	b020      	add	sp, #128	; 0x80
   126f6:	bd70      	pop	{r4, r5, r6, pc}
	reply[reply_len++] = (u8_t)(BATTERY_LEVEL_ID&0x00ff);
   126f8:	2105      	movs	r1, #5
   126fa:	e7db      	b.n	126b4 <APP_get_battery_level+0x34>
   126fc:	2002ff96 	.word	0x2002ff96
   12700:	2002ff95 	.word	0x2002ff95

00012704 <APP_get_heart_rate>:
{
   12704:	b500      	push	{lr}
   12706:	b0a3      	sub	sp, #140	; 0x8c
	u8_t heart_rate,reply[128] = {0};
   12708:	2100      	movs	r1, #0
   1270a:	2280      	movs	r2, #128	; 0x80
   1270c:	a802      	add	r0, sp, #8
   1270e:	f01c fe41 	bl	2f394 <memset>
	GetHeartRate(&heart_rate);
   12712:	f10d 0007 	add.w	r0, sp, #7
   12716:	f01a fae9 	bl	2ccec <GetHeartRate>
	reply[reply_len++] = PACKET_HEAD;
   1271a:	4b12      	ldr	r3, [pc, #72]	; (12764 <APP_get_heart_rate+0x60>)
   1271c:	a902      	add	r1, sp, #8
   1271e:	9302      	str	r3, [sp, #8]
	reply[reply_len++] = (u8_t)(HEART_RATE_ID&0x00ff);
   12720:	f240 2331 	movw	r3, #561	; 0x231
   12724:	f8ad 300c 	strh.w	r3, [sp, #12]
	reply[reply_len++] = 0x01;
   12728:	2301      	movs	r3, #1
   1272a:	f88d 300e 	strb.w	r3, [sp, #14]
	reply[reply_len++] = heart_rate;	//V2.0
   1272e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   12732:	f88d 300f 	strb.w	r3, [sp, #15]
	reply[reply_len++] = 0x00;
   12736:	f44f 4308 	mov.w	r3, #34816	; 0x8800
   1273a:	f8ad 3010 	strh.w	r3, [sp, #16]
	for(i=0;i<(reply_len-2);i++)
   1273e:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   12740:	f811 2b01 	ldrb.w	r2, [r1], #1
   12744:	f89d 0010 	ldrb.w	r0, [sp, #16]
	for(i=0;i<(reply_len-2);i++)
   12748:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   1274a:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   1274c:	2b08      	cmp	r3, #8
		reply[reply_len-2] += reply[i];
   1274e:	f88d 2010 	strb.w	r2, [sp, #16]
	for(i=0;i<(reply_len-2);i++)
   12752:	d1f5      	bne.n	12740 <APP_get_heart_rate+0x3c>
	ble_send_date_handle(reply, reply_len);
   12754:	210a      	movs	r1, #10
   12756:	a802      	add	r0, sp, #8
   12758:	f7ff fc28 	bl	11fac <ble_send_date_handle>
}
   1275c:	b023      	add	sp, #140	; 0x8c
   1275e:	f85d fb04 	ldr.w	pc, [sp], #4
   12762:	bf00      	nop
   12764:	ff0700ab 	.word	0xff0700ab

00012768 <ble_receive_date_handle>:
{
   12768:	b430      	push	{r4, r5}
	if((buf[0] != PACKET_HEAD) || (buf[len-1] != PACKET_END))	//format is error
   1276a:	7802      	ldrb	r2, [r0, #0]
   1276c:	1843      	adds	r3, r0, r1
   1276e:	2aab      	cmp	r2, #171	; 0xab
   12770:	f813 3c01 	ldrb.w	r3, [r3, #-1]
   12774:	d101      	bne.n	1277a <ble_receive_date_handle+0x12>
   12776:	2b88      	cmp	r3, #136	; 0x88
   12778:	d024      	beq.n	127c4 <ble_receive_date_handle+0x5c>
		LOG_INF("format is error! HEAD:%x, END:%x\n", buf[0], buf[len-1]);
   1277a:	2103      	movs	r1, #3
   1277c:	f04f 0000 	mov.w	r0, #0
   12780:	4c71      	ldr	r4, [pc, #452]	; (12948 <ble_receive_date_handle+0x1e0>)
   12782:	f361 0007 	bfi	r0, r1, #0, #8
   12786:	4971      	ldr	r1, [pc, #452]	; (1294c <ble_receive_date_handle+0x1e4>)
   12788:	1b09      	subs	r1, r1, r4
   1278a:	08c9      	lsrs	r1, r1, #3
   1278c:	f361 108f 	bfi	r0, r1, #6, #10
   12790:	496f      	ldr	r1, [pc, #444]	; (12950 <ble_receive_date_handle+0x1e8>)
}
   12792:	bc30      	pop	{r4, r5}
		LOG_INF("CRC is error! data:%x, CRC:%x\n", buf[len-2], CRC_data);
   12794:	f01a bdb0 	b.w	2d2f8 <log_string_sync>
		CRC_data = CRC_data+buf[i];
   12798:	5c85      	ldrb	r5, [r0, r2]
	for(i=0;i<len-2;i++)
   1279a:	3201      	adds	r2, #1
		CRC_data = CRC_data+buf[i];
   1279c:	442b      	add	r3, r5
   1279e:	b2db      	uxtb	r3, r3
	for(i=0;i<len-2;i++)
   127a0:	42a2      	cmp	r2, r4
   127a2:	d3f9      	bcc.n	12798 <ble_receive_date_handle+0x30>
	if(CRC_data != buf[len-2])									//crc is error
   127a4:	5d02      	ldrb	r2, [r0, r4]
   127a6:	4293      	cmp	r3, r2
   127a8:	d010      	beq.n	127cc <ble_receive_date_handle+0x64>
		LOG_INF("CRC is error! data:%x, CRC:%x\n", buf[len-2], CRC_data);
   127aa:	2103      	movs	r1, #3
   127ac:	f04f 0000 	mov.w	r0, #0
   127b0:	4c65      	ldr	r4, [pc, #404]	; (12948 <ble_receive_date_handle+0x1e0>)
   127b2:	f361 0007 	bfi	r0, r1, #0, #8
   127b6:	4965      	ldr	r1, [pc, #404]	; (1294c <ble_receive_date_handle+0x1e4>)
   127b8:	1b09      	subs	r1, r1, r4
   127ba:	08c9      	lsrs	r1, r1, #3
   127bc:	f361 108f 	bfi	r0, r1, #6, #10
   127c0:	4964      	ldr	r1, [pc, #400]	; (12954 <ble_receive_date_handle+0x1ec>)
   127c2:	e7e6      	b.n	12792 <ble_receive_date_handle+0x2a>
	for(i=0;i<len-2;i++)
   127c4:	2200      	movs	r2, #0
   127c6:	1e8c      	subs	r4, r1, #2
	u8_t CRC_data=0,data_status;
   127c8:	4613      	mov	r3, r2
   127ca:	e7e9      	b.n	127a0 <ble_receive_date_handle+0x38>
	data_ID = buf[3]*256+buf[4];
   127cc:	78c2      	ldrb	r2, [r0, #3]
   127ce:	7903      	ldrb	r3, [r0, #4]
   127d0:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	switch(data_ID)
   127d4:	f64f 7247 	movw	r2, #65351	; 0xff47
	data_ID = buf[3]*256+buf[4];
   127d8:	b29b      	uxth	r3, r3
	switch(data_ID)
   127da:	4293      	cmp	r3, r2
   127dc:	f000 8090 	beq.w	12900 <ble_receive_date_handle+0x198>
   127e0:	d83c      	bhi.n	1285c <ble_receive_date_handle+0xf4>
   127e2:	f64f 7239 	movw	r2, #65337	; 0xff39
   127e6:	4293      	cmp	r3, r2
   127e8:	f000 8081 	beq.w	128ee <ble_receive_date_handle+0x186>
   127ec:	d81e      	bhi.n	1282c <ble_receive_date_handle+0xc4>
   127ee:	f64f 7235 	movw	r2, #65333	; 0xff35
   127f2:	4293      	cmp	r3, r2
   127f4:	d075      	beq.n	128e2 <ble_receive_date_handle+0x17a>
   127f6:	d813      	bhi.n	12820 <ble_receive_date_handle+0xb8>
   127f8:	f64f 7231 	movw	r2, #65329	; 0xff31
   127fc:	4293      	cmp	r3, r2
   127fe:	d06d      	beq.n	128dc <ble_receive_date_handle+0x174>
   12800:	d212      	bcs.n	12828 <ble_receive_date_handle+0xc0>
}
   12802:	bc30      	pop	{r4, r5}
		LOG_INF("data_id is unknown! \n");
   12804:	2303      	movs	r3, #3
   12806:	f04f 0000 	mov.w	r0, #0
   1280a:	4a4f      	ldr	r2, [pc, #316]	; (12948 <ble_receive_date_handle+0x1e0>)
   1280c:	f363 0007 	bfi	r0, r3, #0, #8
   12810:	4b4e      	ldr	r3, [pc, #312]	; (1294c <ble_receive_date_handle+0x1e4>)
   12812:	4951      	ldr	r1, [pc, #324]	; (12958 <ble_receive_date_handle+0x1f0>)
   12814:	1a9b      	subs	r3, r3, r2
   12816:	08db      	lsrs	r3, r3, #3
   12818:	f363 108f 	bfi	r0, r3, #6, #10
   1281c:	f01a bd6c 	b.w	2d2f8 <log_string_sync>
	switch(data_ID)
   12820:	f64f 7237 	movw	r2, #65335	; 0xff37
   12824:	4293      	cmp	r3, r2
   12826:	d05f      	beq.n	128e8 <ble_receive_date_handle+0x180>
}
   12828:	bc30      	pop	{r4, r5}
   1282a:	4770      	bx	lr
	switch(data_ID)
   1282c:	f64f 7243 	movw	r2, #65347	; 0xff43
   12830:	4293      	cmp	r3, r2
   12832:	d05f      	beq.n	128f4 <ble_receive_date_handle+0x18c>
   12834:	d80a      	bhi.n	1284c <ble_receive_date_handle+0xe4>
   12836:	f64f 7240 	movw	r2, #65344	; 0xff40
   1283a:	4293      	cmp	r3, r2
   1283c:	d3e1      	bcc.n	12802 <ble_receive_date_handle+0x9a>
   1283e:	f64f 7241 	movw	r2, #65345	; 0xff41
   12842:	4293      	cmp	r3, r2
   12844:	d9f0      	bls.n	12828 <ble_receive_date_handle+0xc0>
}
   12846:	bc30      	pop	{r4, r5}
		APP_set_wake_screen_by_wrist(buf, len);
   12848:	f7ff bdd0 	b.w	123ec <APP_set_wake_screen_by_wrist>
	switch(data_ID)
   1284c:	f64f 7245 	movw	r2, #65349	; 0xff45
   12850:	4293      	cmp	r3, r2
   12852:	d052      	beq.n	128fa <ble_receive_date_handle+0x192>
   12854:	d9e8      	bls.n	12828 <ble_receive_date_handle+0xc0>
}
   12856:	bc30      	pop	{r4, r5}
		APP_set_time_24_format(buf, len);
   12858:	f7ff bc42 	b.w	120e0 <APP_set_time_24_format>
	switch(data_ID)
   1285c:	f64f 7255 	movw	r2, #65365	; 0xff55
   12860:	4293      	cmp	r3, r2
   12862:	d059      	beq.n	12918 <ble_receive_date_handle+0x1b0>
   12864:	d818      	bhi.n	12898 <ble_receive_date_handle+0x130>
   12866:	f64f 7251 	movw	r2, #65361	; 0xff51
   1286a:	4293      	cmp	r3, r2
   1286c:	d04e      	beq.n	1290c <ble_receive_date_handle+0x1a4>
   1286e:	d80b      	bhi.n	12888 <ble_receive_date_handle+0x120>
   12870:	f64f 7249 	movw	r2, #65353	; 0xff49
   12874:	4293      	cmp	r3, r2
   12876:	d046      	beq.n	12906 <ble_receive_date_handle+0x19e>
   12878:	d3d6      	bcc.n	12828 <ble_receive_date_handle+0xc0>
   1287a:	f64f 7250 	movw	r2, #65360	; 0xff50
   1287e:	4293      	cmp	r3, r2
   12880:	d1bf      	bne.n	12802 <ble_receive_date_handle+0x9a>
}
   12882:	bc30      	pop	{r4, r5}
		APP_set_target_steps(buf, len);
   12884:	f7ff be16 	b.w	124b4 <APP_set_target_steps>
	switch(data_ID)
   12888:	f64f 7253 	movw	r2, #65363	; 0xff53
   1288c:	4293      	cmp	r3, r2
   1288e:	d040      	beq.n	12912 <ble_receive_date_handle+0x1aa>
   12890:	d8ca      	bhi.n	12828 <ble_receive_date_handle+0xc0>
}
   12892:	bc30      	pop	{r4, r5}
		APP_get_firmware_version(buf, len);
   12894:	f018 befc 	b.w	2b690 <APP_get_firmware_version>
	switch(data_ID)
   12898:	f64f 72b1 	movw	r2, #65457	; 0xffb1
   1289c:	4293      	cmp	r3, r2
   1289e:	d044      	beq.n	1292a <ble_receive_date_handle+0x1c2>
   128a0:	d80e      	bhi.n	128c0 <ble_receive_date_handle+0x158>
   128a2:	f64f 7262 	movw	r2, #65378	; 0xff62
   128a6:	4293      	cmp	r3, r2
   128a8:	d042      	beq.n	12930 <ble_receive_date_handle+0x1c8>
   128aa:	f64f 72b0 	movw	r2, #65456	; 0xffb0
   128ae:	4293      	cmp	r3, r2
   128b0:	d038      	beq.n	12924 <ble_receive_date_handle+0x1bc>
   128b2:	f64f 7256 	movw	r2, #65366	; 0xff56
   128b6:	4293      	cmp	r3, r2
   128b8:	d1a3      	bne.n	12802 <ble_receive_date_handle+0x9a>
}
   128ba:	bc30      	pop	{r4, r5}
		APP_set_date_format(buf, len);
   128bc:	f7ff bc54 	b.w	12168 <APP_set_date_format>
	switch(data_ID)
   128c0:	f64f 72b3 	movw	r2, #65459	; 0xffb3
   128c4:	4293      	cmp	r3, r2
   128c6:	d039      	beq.n	1293c <ble_receive_date_handle+0x1d4>
   128c8:	d335      	bcc.n	12936 <ble_receive_date_handle+0x1ce>
   128ca:	f64f 72b4 	movw	r2, #65460	; 0xffb4
   128ce:	4293      	cmp	r3, r2
   128d0:	d037      	beq.n	12942 <ble_receive_date_handle+0x1da>
   128d2:	f64f 72b5 	movw	r2, #65461	; 0xffb5
   128d6:	4293      	cmp	r3, r2
   128d8:	d0a6      	beq.n	12828 <ble_receive_date_handle+0xc0>
   128da:	e792      	b.n	12802 <ble_receive_date_handle+0x9a>
}
   128dc:	bc30      	pop	{r4, r5}
		APP_get_heart_rate(buf, len);
   128de:	f7ff bf11 	b.w	12704 <APP_get_heart_rate>
}
   128e2:	bc30      	pop	{r4, r5}
		APP_get_current_data(buf, len);
   128e4:	f7ff be32 	b.w	1254c <APP_get_current_data>
}
   128e8:	bc30      	pop	{r4, r5}
		APP_set_find_device(buf, len);
   128ea:	f7ff bb83 	b.w	11ff4 <APP_set_find_device>
}
   128ee:	bc30      	pop	{r4, r5}
		APP_set_alarm(buf, len);
   128f0:	f7ff bcf0 	b.w	122d4 <APP_set_alarm>
}
   128f4:	bc30      	pop	{r4, r5}
		APP_set_PHD_interval(buf, len);
   128f6:	f7ff bd3f 	b.w	12378 <APP_set_PHD_interval>
}
   128fa:	bc30      	pop	{r4, r5}
		APP_set_language(buf, len);
   128fc:	f7ff bba8 	b.w	12050 <APP_set_language>
}
   12900:	bc30      	pop	{r4, r5}
		APP_reply_find_phone(buf, len);
   12902:	f7ff bab1 	b.w	11e68 <APP_reply_find_phone>
}
   12906:	bc30      	pop	{r4, r5}
		APP_set_date_time(buf, len);
   12908:	f7ff bc76 	b.w	121f8 <APP_set_date_time>
}
   1290c:	bc30      	pop	{r4, r5}
		APP_get_battery_level(buf, len);
   1290e:	f7ff beb7 	b.w	12680 <APP_get_battery_level>
}
   12912:	bc30      	pop	{r4, r5}
		APP_set_factory_reset(buf, len);
   12914:	f7ff bda0 	b.w	12458 <APP_set_factory_reset>
	ble_wait_gps = true;
   12918:	2201      	movs	r2, #1
}
   1291a:	bc30      	pop	{r4, r5}
	ble_wait_gps = true;
   1291c:	4b0f      	ldr	r3, [pc, #60]	; (1295c <ble_receive_date_handle+0x1f4>)
   1291e:	701a      	strb	r2, [r3, #0]
	APP_Ask_GPS_Data();
   12920:	f7fa bbe2 	b.w	d0e8 <APP_Ask_GPS_Data>
}
   12924:	bc30      	pop	{r4, r5}
		ble_connect_or_disconnect_handle(buf, len);
   12926:	f7ff b9dd 	b.w	11ce4 <ble_connect_or_disconnect_handle>
}
   1292a:	bc30      	pop	{r4, r5}
		CTP_notify_handle(buf, len);
   1292c:	f7ff b9fa 	b.w	11d24 <CTP_notify_handle>
}
   12930:	bc30      	pop	{r4, r5}
		wifi_sacn_notify_handle(buf, len);
   12932:	f7ff ba75 	b.w	11e20 <wifi_sacn_notify_handle>
}
   12936:	bc30      	pop	{r4, r5}
		get_nrf52810_ver_response(buf, len);
   12938:	f7ff baca 	b.w	11ed0 <get_nrf52810_ver_response>
}
   1293c:	bc30      	pop	{r4, r5}
		get_ble_mac_address_response(buf, len);
   1293e:	f7ff bae9 	b.w	11f14 <get_ble_mac_address_response>
}
   12942:	bc30      	pop	{r4, r5}
		get_ble_status_response(buf, len);
   12944:	f7ff bb14 	b.w	11f70 <get_ble_status_response>
   12948:	0003040c 	.word	0x0003040c
   1294c:	00030524 	.word	0x00030524
   12950:	0003149d 	.word	0x0003149d
   12954:	000314bf 	.word	0x000314bf
   12958:	000314de 	.word	0x000314de
   1295c:	2002f92c 	.word	0x2002f92c

00012960 <uart_cb>:
	uart_irq_tx_enable(uart_ble); 
}

static void uart_cb(struct device *x)
{
	u8_t tmpbyte = 0;
   12960:	2300      	movs	r3, #0
{
   12962:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   12966:	4604      	mov	r4, r0
	u8_t tmpbyte = 0;
   12968:	f88d 3007 	strb.w	r3, [sp, #7]
static inline int z_impl_uart_irq_update(struct device *dev)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	if (api->irq_update) {
   1296c:	6843      	ldr	r3, [r0, #4]
   1296e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   12970:	b103      	cbz	r3, 12974 <uart_cb+0x14>
		return api->irq_update(dev);
   12972:	4798      	blx	r3
	if (api->irq_rx_ready) {
   12974:	6863      	ldr	r3, [r4, #4]
   12976:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   12978:	b933      	cbnz	r3, 12988 <uart_cb+0x28>
	if (api->irq_tx_ready) {
   1297a:	6863      	ldr	r3, [r4, #4]
   1297c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1297e:	2b00      	cmp	r3, #0
   12980:	d14c      	bne.n	12a1c <uart_cb+0xbc>
			uart_irq_tx_disable(x);
		}

		k_free(buf);
	}
}
   12982:	b002      	add	sp, #8
   12984:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return api->irq_rx_ready(dev);
   12988:	4620      	mov	r0, r4
   1298a:	4798      	blx	r3
	if(uart_irq_rx_ready(x)) 
   1298c:	2800      	cmp	r0, #0
   1298e:	d0f4      	beq.n	1297a <uart_cb+0x1a>
   12990:	4d39      	ldr	r5, [pc, #228]	; (12a78 <uart_cb+0x118>)
	LOG_INF("uart_rece:%02X\n", data);
   12992:	4b3a      	ldr	r3, [pc, #232]	; (12a7c <uart_cb+0x11c>)
   12994:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 12a8c <uart_cb+0x12c>
   12998:	1aed      	subs	r5, r5, r3
   1299a:	4e39      	ldr	r6, [pc, #228]	; (12a80 <uart_cb+0x120>)
   1299c:	f3c5 05c9 	ubfx	r5, r5, #3, #10
		memset(rx_buf, 0, sizeof(rx_buf));
   129a0:	4f38      	ldr	r7, [pc, #224]	; (12a84 <uart_cb+0x124>)
	if (api->fifo_read) {
   129a2:	6863      	ldr	r3, [r4, #4]
   129a4:	699b      	ldr	r3, [r3, #24]
   129a6:	2b00      	cmp	r3, #0
   129a8:	d0e7      	beq.n	1297a <uart_cb+0x1a>
		return api->fifo_read(dev, rx_data, size);
   129aa:	2201      	movs	r2, #1
   129ac:	f10d 0107 	add.w	r1, sp, #7
   129b0:	4620      	mov	r0, r4
   129b2:	4798      	blx	r3
		while((len = uart_fifo_read(x, &tmpbyte, 1)) > 0)
   129b4:	2800      	cmp	r0, #0
   129b6:	d0e0      	beq.n	1297a <uart_cb+0x1a>
	LOG_INF("uart_rece:%02X\n", data);
   129b8:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   129bc:	f043 0303 	orr.w	r3, r3, #3
			uart_receive_data(tmpbyte, 1);
   129c0:	f89d a007 	ldrb.w	sl, [sp, #7]
	LOG_INF("uart_rece:%02X\n", data);
   129c4:	f363 0807 	bfi	r8, r3, #0, #8
   129c8:	f365 188f 	bfi	r8, r5, #6, #10
   129cc:	4652      	mov	r2, sl
   129ce:	4649      	mov	r1, r9
   129d0:	4640      	mov	r0, r8
   129d2:	f01a fc91 	bl	2d2f8 <log_string_sync>
	if(data == 0xAB)
   129d6:	f1ba 0fab 	cmp.w	sl, #171	; 0xab
   129da:	d107      	bne.n	129ec <uart_cb+0x8c>
		memset(rx_buf, 0, sizeof(rx_buf));
   129dc:	f44f 6280 	mov.w	r2, #1024	; 0x400
   129e0:	2100      	movs	r1, #0
   129e2:	4638      	mov	r0, r7
   129e4:	f01c fcd6 	bl	2f394 <memset>
		rece_len = 0;
   129e8:	2300      	movs	r3, #0
   129ea:	6033      	str	r3, [r6, #0]
	rx_buf[rece_len++] = data;
   129ec:	6833      	ldr	r3, [r6, #0]
   129ee:	f807 a003 	strb.w	sl, [r7, r3]
   129f2:	1c59      	adds	r1, r3, #1
	if(rece_len == (256*rx_buf[1]+rx_buf[2]+3))	//receivive complete
   129f4:	78bb      	ldrb	r3, [r7, #2]
   129f6:	787a      	ldrb	r2, [r7, #1]
   129f8:	3303      	adds	r3, #3
   129fa:	eb03 2302 	add.w	r3, r3, r2, lsl #8
   129fe:	4299      	cmp	r1, r3
	rx_buf[rece_len++] = data;
   12a00:	6031      	str	r1, [r6, #0]
	if(rece_len == (256*rx_buf[1]+rx_buf[2]+3))	//receivive complete
   12a02:	d1ce      	bne.n	129a2 <uart_cb+0x42>
		ble_receive_date_handle(rx_buf, rece_len);
   12a04:	481f      	ldr	r0, [pc, #124]	; (12a84 <uart_cb+0x124>)
   12a06:	f7ff feaf 	bl	12768 <ble_receive_date_handle>
		memset(rx_buf, 0, sizeof(rx_buf));
   12a0a:	f44f 6280 	mov.w	r2, #1024	; 0x400
   12a0e:	2100      	movs	r1, #0
   12a10:	481c      	ldr	r0, [pc, #112]	; (12a84 <uart_cb+0x124>)
   12a12:	f01c fcbf 	bl	2f394 <memset>
		rece_len = 0;
   12a16:	2300      	movs	r3, #0
   12a18:	6033      	str	r3, [r6, #0]
   12a1a:	e7c1      	b.n	129a0 <uart_cb+0x40>
		return api->irq_tx_ready(dev);
   12a1c:	4620      	mov	r0, r4
   12a1e:	4798      	blx	r3
	if(uart_irq_tx_ready(x))
   12a20:	2800      	cmp	r0, #0
   12a22:	d0ae      	beq.n	12982 <uart_cb+0x22>
	return z_impl_k_queue_get(queue, timeout);
   12a24:	2100      	movs	r1, #0
   12a26:	4818      	ldr	r0, [pc, #96]	; (12a88 <uart_cb+0x128>)
   12a28:	f014 fad6 	bl	26fd8 <z_impl_k_queue_get>
		if(!buf)
   12a2c:	4606      	mov	r6, r0
   12a2e:	bb00      	cbnz	r0, 12a72 <uart_cb+0x112>
			uart_irq_tx_disable(x);
   12a30:	4620      	mov	r0, r4
   12a32:	f018 fe28 	bl	2b686 <uart_irq_tx_disable>
			return;
   12a36:	e7a4      	b.n	12982 <uart_cb+0x22>
			written += uart_fifo_fill(x, &buf->data[written], buf->len - written);
   12a38:	1d29      	adds	r1, r5, #4
   12a3a:	1b52      	subs	r2, r2, r5
   12a3c:	4431      	add	r1, r6
   12a3e:	4620      	mov	r0, r4
   12a40:	f018 fe16 	bl	2b670 <uart_fifo_fill>
   12a44:	4405      	add	r5, r0
   12a46:	b2ad      	uxth	r5, r5
		while(buf->len > written)
   12a48:	f8b6 2404 	ldrh.w	r2, [r6, #1028]	; 0x404
   12a4c:	42aa      	cmp	r2, r5
   12a4e:	d8f3      	bhi.n	12a38 <uart_cb+0xd8>
	if (api->irq_tx_complete) {
   12a50:	6863      	ldr	r3, [r4, #4]
   12a52:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   12a54:	b11b      	cbz	r3, 12a5e <uart_cb+0xfe>
		return api->irq_tx_complete(dev);
   12a56:	4620      	mov	r0, r4
   12a58:	4798      	blx	r3
		while (!uart_irq_tx_complete(x))
   12a5a:	2800      	cmp	r0, #0
   12a5c:	d0f8      	beq.n	12a50 <uart_cb+0xf0>
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_sflist_is_empty(sys_sflist_t *list);

Z_GENLIST_IS_EMPTY(sflist)
   12a5e:	4b0a      	ldr	r3, [pc, #40]	; (12a88 <uart_cb+0x128>)
		if (k_fifo_is_empty(&fifo_uart_tx_data))
   12a60:	681b      	ldr	r3, [r3, #0]
   12a62:	b913      	cbnz	r3, 12a6a <uart_cb+0x10a>
			uart_irq_tx_disable(x);
   12a64:	4620      	mov	r0, r4
   12a66:	f018 fe0e 	bl	2b686 <uart_irq_tx_disable>
		k_free(buf);
   12a6a:	4630      	mov	r0, r6
   12a6c:	f01c faa3 	bl	2efb6 <k_free>
   12a70:	e787      	b.n	12982 <uart_cb+0x22>
		u16_t written = 0;
   12a72:	2500      	movs	r5, #0
   12a74:	e7e8      	b.n	12a48 <uart_cb+0xe8>
   12a76:	bf00      	nop
   12a78:	00030524 	.word	0x00030524
   12a7c:	0003040c 	.word	0x0003040c
   12a80:	20020cb4 	.word	0x20020cb4
   12a84:	2002f4a9 	.word	0x2002f4a9
   12a88:	2003b900 	.word	0x2003b900
   12a8c:	00031565 	.word	0x00031565

00012a90 <ble_init>:

void ble_init(void)
{
	LOG_INF("ble_init\n");
   12a90:	2303      	movs	r3, #3
   12a92:	f04f 0000 	mov.w	r0, #0
{
   12a96:	b570      	push	{r4, r5, r6, lr}
	LOG_INF("ble_init\n");
   12a98:	f363 0007 	bfi	r0, r3, #0, #8
   12a9c:	4c15      	ldr	r4, [pc, #84]	; (12af4 <ble_init+0x64>)
   12a9e:	4b16      	ldr	r3, [pc, #88]	; (12af8 <ble_init+0x68>)
   12aa0:	4916      	ldr	r1, [pc, #88]	; (12afc <ble_init+0x6c>)
   12aa2:	1ae4      	subs	r4, r4, r3
   12aa4:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   12aa8:	f364 108f 	bfi	r0, r4, #6, #10
   12aac:	f01a fc24 	bl	2d2f8 <log_string_sync>
   12ab0:	4813      	ldr	r0, [pc, #76]	; (12b00 <ble_init+0x70>)
   12ab2:	f013 fb89 	bl	261c8 <z_impl_device_get_binding>
	
	uart_ble = device_get_binding(BLE_DEV);
   12ab6:	4d13      	ldr	r5, [pc, #76]	; (12b04 <ble_init+0x74>)
   12ab8:	4602      	mov	r2, r0
   12aba:	6028      	str	r0, [r5, #0]
	if(!uart_ble)
   12abc:	b960      	cbnz	r0, 12ad8 <ble_init+0x48>
	{
		LOG_INF("Could not get %s device\n", BLE_DEV);
   12abe:	f04f 0000 	mov.w	r0, #0
   12ac2:	2303      	movs	r3, #3
   12ac4:	f363 0007 	bfi	r0, r3, #0, #8
   12ac8:	f364 108f 	bfi	r0, r4, #6, #10
   12acc:	4a0c      	ldr	r2, [pc, #48]	; (12b00 <ble_init+0x70>)
   12ace:	490e      	ldr	r1, [pc, #56]	; (12b08 <ble_init+0x78>)
		return;
	}

	uart_irq_callback_set(uart_ble, uart_cb);
	uart_irq_rx_enable(uart_ble);
}
   12ad0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LOG_INF("Could not get %s device\n", BLE_DEV);
   12ad4:	f01a bc10 	b.w	2d2f8 <log_string_sync>
static inline void uart_irq_callback_user_data_set(
					struct device *dev,
					uart_irq_callback_user_data_t cb,
					void *user_data)
{
	const struct uart_driver_api *api =
   12ad8:	6843      	ldr	r3, [r0, #4]
		(const struct uart_driver_api *)dev->driver_api;

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
   12ada:	b11b      	cbz	r3, 12ae4 <ble_init+0x54>
   12adc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   12ade:	b10b      	cbz	r3, 12ae4 <ble_init+0x54>
		api->irq_callback_set(dev, cb, user_data);
   12ae0:	490a      	ldr	r1, [pc, #40]	; (12b0c <ble_init+0x7c>)
   12ae2:	4798      	blx	r3
	uart_irq_rx_enable(uart_ble);
   12ae4:	6828      	ldr	r0, [r5, #0]
	if (api->irq_rx_enable) {
   12ae6:	6843      	ldr	r3, [r0, #4]
   12ae8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   12aea:	b113      	cbz	r3, 12af2 <ble_init+0x62>
}
   12aec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		api->irq_rx_enable(dev);
   12af0:	4718      	bx	r3
   12af2:	bd70      	pop	{r4, r5, r6, pc}
   12af4:	00030524 	.word	0x00030524
   12af8:	0003040c 	.word	0x0003040c
   12afc:	0003148c 	.word	0x0003148c
   12b00:	00031496 	.word	0x00031496
   12b04:	20020cb8 	.word	0x20020cb8
   12b08:	000310fd 	.word	0x000310fd
   12b0c:	00012961 	.word	0x00012961

00012b10 <APP_Ask_GPS_Data_timerout>:
	app_gps_off = true;
   12b10:	2301      	movs	r3, #1
   12b12:	4a02      	ldr	r2, [pc, #8]	; (12b1c <APP_Ask_GPS_Data_timerout+0xc>)
   12b14:	7013      	strb	r3, [r2, #0]
	app_gps_send = true;
   12b16:	4a02      	ldr	r2, [pc, #8]	; (12b20 <APP_Ask_GPS_Data_timerout+0x10>)
   12b18:	7013      	strb	r3, [r2, #0]
}
   12b1a:	4770      	bx	lr
   12b1c:	2002f929 	.word	0x2002f929
   12b20:	2002f92b 	.word	0x2002f92b

00012b24 <gps_data_wait_timerout>:
	print_nmea_data();
}

void gps_data_wait_timerout(struct k_timer *timer)
{
	gps_data_incoming = true;
   12b24:	2201      	movs	r2, #1
   12b26:	4b01      	ldr	r3, [pc, #4]	; (12b2c <gps_data_wait_timerout+0x8>)
   12b28:	701a      	strb	r2, [r3, #0]
}
   12b2a:	4770      	bx	lr
   12b2c:	2002f930 	.word	0x2002f930

00012b30 <print_nmea_data>:
{
   12b30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	LOG_INF("\n");
   12b34:	f04f 0000 	mov.w	r0, #0
   12b38:	2303      	movs	r3, #3
   12b3a:	4c14      	ldr	r4, [pc, #80]	; (12b8c <print_nmea_data+0x5c>)
   12b3c:	f363 0007 	bfi	r0, r3, #0, #8
   12b40:	4b13      	ldr	r3, [pc, #76]	; (12b90 <print_nmea_data+0x60>)
   12b42:	4914      	ldr	r1, [pc, #80]	; (12b94 <print_nmea_data+0x64>)
   12b44:	1ae4      	subs	r4, r4, r3
   12b46:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   12b4a:	f364 108f 	bfi	r0, r4, #6, #10
   12b4e:	f01a fbd3 	bl	2d2f8 <log_string_sync>
	for(i = 0; i < nmea_string_cnt; ++i)
   12b52:	2500      	movs	r5, #0
   12b54:	4f10      	ldr	r7, [pc, #64]	; (12b98 <print_nmea_data+0x68>)
		LOG_INF("%s", nmea_strings[i]);
   12b56:	f8df 8044 	ldr.w	r8, [pc, #68]	; 12b9c <print_nmea_data+0x6c>
   12b5a:	f8df 9044 	ldr.w	r9, [pc, #68]	; 12ba0 <print_nmea_data+0x70>
	for(i = 0; i < nmea_string_cnt; ++i)
   12b5e:	683b      	ldr	r3, [r7, #0]
   12b60:	429d      	cmp	r5, r3
   12b62:	d301      	bcc.n	12b68 <print_nmea_data+0x38>
}
   12b64:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		LOG_INF("%s", nmea_strings[i]);
   12b68:	2253      	movs	r2, #83	; 0x53
   12b6a:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   12b6e:	f043 0303 	orr.w	r3, r3, #3
   12b72:	f363 0607 	bfi	r6, r3, #0, #8
   12b76:	f364 168f 	bfi	r6, r4, #6, #10
   12b7a:	fb02 8205 	mla	r2, r2, r5, r8
   12b7e:	4649      	mov	r1, r9
   12b80:	4630      	mov	r0, r6
   12b82:	f01a fbb9 	bl	2d2f8 <log_string_sync>
	for(i = 0; i < nmea_string_cnt; ++i)
   12b86:	3501      	adds	r5, #1
   12b88:	e7e9      	b.n	12b5e <print_nmea_data+0x2e>
   12b8a:	bf00      	nop
   12b8c:	00030474 	.word	0x00030474
   12b90:	0003040c 	.word	0x0003040c
   12b94:	00033243 	.word	0x00033243
   12b98:	20020cc0 	.word	0x20020cc0
   12b9c:	2002f933 	.word	0x2002f933
   12ba0:	000335f1 	.word	0x000335f1

00012ba4 <print_satellite_stats>:
{
   12ba4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	u8_t unhealthy = 0;
   12ba6:	2100      	movs	r1, #0
	u8_t in_fix = 0;
   12ba8:	460b      	mov	r3, r1
	u8_t tracked = 0;
   12baa:	460a      	mov	r2, r1
   12bac:	f100 0590 	add.w	r5, r0, #144	; 0x90
		if ((pvt_data->pvt.sv[i].sv > 0) && (pvt_data->pvt.sv[i].sv < 33))
   12bb0:	f8b0 4046 	ldrh.w	r4, [r0, #70]	; 0x46
   12bb4:	3c01      	subs	r4, #1
   12bb6:	2c1f      	cmp	r4, #31
   12bb8:	d80c      	bhi.n	12bd4 <print_satellite_stats+0x30>
			if (pvt_data->pvt.sv[i].flags & NRF_GNSS_SV_FLAG_USED_IN_FIX)
   12bba:	f890 4050 	ldrb.w	r4, [r0, #80]	; 0x50
			tracked++;
   12bbe:	3201      	adds	r2, #1
			if (pvt_data->pvt.sv[i].flags & NRF_GNSS_SV_FLAG_USED_IN_FIX)
   12bc0:	07a6      	lsls	r6, r4, #30
				in_fix++;
   12bc2:	bf44      	itt	mi
   12bc4:	3301      	addmi	r3, #1
   12bc6:	b2db      	uxtbmi	r3, r3
			if (pvt_data->pvt.sv[i].flags & NRF_GNSS_SV_FLAG_UNHEALTHY)
   12bc8:	0724      	lsls	r4, r4, #28
				unhealthy++;
   12bca:	bf48      	it	mi
   12bcc:	3101      	addmi	r1, #1
			tracked++;
   12bce:	b2d2      	uxtb	r2, r2
				unhealthy++;
   12bd0:	bf48      	it	mi
   12bd2:	b2c9      	uxtbmi	r1, r1
   12bd4:	300c      	adds	r0, #12
	for(i = 0; i < NRF_GNSS_MAX_SATELLITES; ++i)
   12bd6:	42a8      	cmp	r0, r5
   12bd8:	d1ea      	bne.n	12bb0 <print_satellite_stats+0xc>
	LOG_INF("Tracking: %d Using: %d Unhealthy: %d", tracked, in_fix, unhealthy);
   12bda:	2403      	movs	r4, #3
   12bdc:	f04f 0000 	mov.w	r0, #0
   12be0:	4d15      	ldr	r5, [pc, #84]	; (12c38 <print_satellite_stats+0x94>)
   12be2:	f364 0007 	bfi	r0, r4, #0, #8
   12be6:	4c15      	ldr	r4, [pc, #84]	; (12c3c <print_satellite_stats+0x98>)
   12be8:	9100      	str	r1, [sp, #0]
   12bea:	1b64      	subs	r4, r4, r5
   12bec:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   12bf0:	f364 108f 	bfi	r0, r4, #6, #10
   12bf4:	4912      	ldr	r1, [pc, #72]	; (12c40 <print_satellite_stats+0x9c>)
   12bf6:	f01a fb7f 	bl	2d2f8 <log_string_sync>
	LOG_INF("\nSeconds since last fix %lld\n", (k_uptime_get() - fix_timestamp) / 1000);
   12bfa:	f04f 0500 	mov.w	r5, #0
   12bfe:	2303      	movs	r3, #3
   12c00:	f363 0507 	bfi	r5, r3, #0, #8
   12c04:	f364 158f 	bfi	r5, r4, #6, #10
	return z_impl_k_uptime_get();
   12c08:	f01c fae7 	bl	2f1da <z_impl_k_uptime_get>
   12c0c:	4b0d      	ldr	r3, [pc, #52]	; (12c44 <print_satellite_stats+0xa0>)
   12c0e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   12c12:	e9d3 4600 	ldrd	r4, r6, [r3]
   12c16:	1b00      	subs	r0, r0, r4
   12c18:	f04f 0300 	mov.w	r3, #0
   12c1c:	eb61 0106 	sbc.w	r1, r1, r6
   12c20:	f7f9 ffd4 	bl	cbcc <__aeabi_uldivmod>
   12c24:	4602      	mov	r2, r0
   12c26:	460b      	mov	r3, r1
   12c28:	4628      	mov	r0, r5
   12c2a:	4907      	ldr	r1, [pc, #28]	; (12c48 <print_satellite_stats+0xa4>)
}
   12c2c:	b002      	add	sp, #8
   12c2e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	LOG_INF("\nSeconds since last fix %lld\n", (k_uptime_get() - fix_timestamp) / 1000);
   12c32:	f01a bb61 	b.w	2d2f8 <log_string_sync>
   12c36:	bf00      	nop
   12c38:	0003040c 	.word	0x0003040c
   12c3c:	00030474 	.word	0x00030474
   12c40:	00031809 	.word	0x00031809
   12c44:	20020000 	.word	0x20020000
   12c48:	0003182e 	.word	0x0003182e

00012c4c <process_gps_data>:
{
   12c4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	retval = nrf_recv(gnss_fd,
   12c4e:	4601      	mov	r1, r0
{
   12c50:	4604      	mov	r4, r0
	retval = nrf_recv(gnss_fd,
   12c52:	481f      	ldr	r0, [pc, #124]	; (12cd0 <process_gps_data+0x84>)
   12c54:	2302      	movs	r3, #2
   12c56:	22d8      	movs	r2, #216	; 0xd8
   12c58:	6800      	ldr	r0, [r0, #0]
   12c5a:	f00e ff57 	bl	21b0c <nrf_recv>
	if(retval > 0) 
   12c5e:	1e06      	subs	r6, r0, #0
   12c60:	dd04      	ble.n	12c6c <process_gps_data+0x20>
		switch (gps_data->data_id)
   12c62:	7823      	ldrb	r3, [r4, #0]
   12c64:	2b01      	cmp	r3, #1
   12c66:	d003      	beq.n	12c70 <process_gps_data+0x24>
   12c68:	2b02      	cmp	r3, #2
   12c6a:	d01c      	beq.n	12ca6 <process_gps_data+0x5a>
}
   12c6c:	4630      	mov	r0, r6
   12c6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if((gps_data->pvt.flags & NRF_GNSS_PVT_FLAG_FIX_VALID_BIT)	== NRF_GNSS_PVT_FLAG_FIX_VALID_BIT)
   12c70:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
   12c74:	4d17      	ldr	r5, [pc, #92]	; (12cd4 <process_gps_data+0x88>)
   12c76:	f012 0f01 	tst.w	r2, #1
   12c7a:	d00f      	beq.n	12c9c <process_gps_data+0x50>
				if (!got_first_fix)
   12c7c:	4a16      	ldr	r2, [pc, #88]	; (12cd8 <process_gps_data+0x8c>)
   12c7e:	7811      	ldrb	r1, [r2, #0]
   12c80:	b901      	cbnz	r1, 12c84 <process_gps_data+0x38>
					got_first_fix = true;
   12c82:	7013      	strb	r3, [r2, #0]
   12c84:	f01c faa9 	bl	2f1da <z_impl_k_uptime_get>
				fix_timestamp = k_uptime_get();
   12c88:	4b14      	ldr	r3, [pc, #80]	; (12cdc <process_gps_data+0x90>)
				memcpy(&last_fix,
   12c8a:	22d8      	movs	r2, #216	; 0xd8
				fix_timestamp = k_uptime_get();
   12c8c:	e9c3 0100 	strd	r0, r1, [r3]
				memcpy(&last_fix,
   12c90:	4621      	mov	r1, r4
   12c92:	4813      	ldr	r0, [pc, #76]	; (12ce0 <process_gps_data+0x94>)
   12c94:	f01c fb5e 	bl	2f354 <memcpy>
				nmea_string_cnt = 0;
   12c98:	2300      	movs	r3, #0
   12c9a:	602b      	str	r3, [r5, #0]
			print_nmea_data();
   12c9c:	f7ff ff48 	bl	12b30 <print_nmea_data>
			nmea_string_cnt = 0;
   12ca0:	2300      	movs	r3, #0
   12ca2:	602b      	str	r3, [r5, #0]
			break;
   12ca4:	e7e2      	b.n	12c6c <process_gps_data+0x20>
			if (nmea_string_cnt < 10) 
   12ca6:	4f0b      	ldr	r7, [pc, #44]	; (12cd4 <process_gps_data+0x88>)
   12ca8:	683d      	ldr	r5, [r7, #0]
   12caa:	2d09      	cmp	r5, #9
   12cac:	d8de      	bhi.n	12c6c <process_gps_data+0x20>
				memset(nmea_strings[nmea_string_cnt],
   12cae:	2253      	movs	r2, #83	; 0x53
   12cb0:	4b0c      	ldr	r3, [pc, #48]	; (12ce4 <process_gps_data+0x98>)
__ssp_bos_icheck3(memset, void *, int)
   12cb2:	2100      	movs	r1, #0
   12cb4:	fb02 3305 	mla	r3, r2, r5, r3
   12cb8:	4618      	mov	r0, r3
   12cba:	f01c fb6b 	bl	2f394 <memset>
				memcpy(nmea_strings[nmea_string_cnt++],
   12cbe:	3501      	adds	r5, #1
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   12cc0:	4632      	mov	r2, r6
   12cc2:	f104 0108 	add.w	r1, r4, #8
   12cc6:	603d      	str	r5, [r7, #0]
   12cc8:	f01c fb44 	bl	2f354 <memcpy>
	return retval;
   12ccc:	e7ce      	b.n	12c6c <process_gps_data+0x20>
   12cce:	bf00      	nop
   12cd0:	20020cbc 	.word	0x20020cbc
   12cd4:	20020cc0 	.word	0x20020cc0
   12cd8:	2002f92f 	.word	0x2002f92f
   12cdc:	20020000 	.word	0x20020000
   12ce0:	20020008 	.word	0x20020008
   12ce4:	2002f933 	.word	0x2002f933

00012ce8 <APP_GPS_data_send>:
{
   12ce8:	b510      	push	{r4, lr}
	if(ble_wait_gps)
   12cea:	4c16      	ldr	r4, [pc, #88]	; (12d44 <APP_GPS_data_send+0x5c>)
{
   12cec:	b0b0      	sub	sp, #192	; 0xc0
	if(ble_wait_gps)
   12cee:	7823      	ldrb	r3, [r4, #0]
   12cf0:	b153      	cbz	r3, 12d08 <APP_GPS_data_send+0x20>
		APP_get_location_data_reply(last_fix.pvt);
   12cf2:	22c0      	movs	r2, #192	; 0xc0
   12cf4:	4914      	ldr	r1, [pc, #80]	; (12d48 <APP_GPS_data_send+0x60>)
   12cf6:	4668      	mov	r0, sp
   12cf8:	f01c fb2c 	bl	2f354 <memcpy>
   12cfc:	4b13      	ldr	r3, [pc, #76]	; (12d4c <APP_GPS_data_send+0x64>)
   12cfe:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   12d00:	f7fa f932 	bl	cf68 <APP_get_location_data_reply>
		ble_wait_gps = false;
   12d04:	2300      	movs	r3, #0
   12d06:	7023      	strb	r3, [r4, #0]
	if(sos_wait_gps)
   12d08:	4c11      	ldr	r4, [pc, #68]	; (12d50 <APP_GPS_data_send+0x68>)
   12d0a:	7823      	ldrb	r3, [r4, #0]
   12d0c:	b153      	cbz	r3, 12d24 <APP_GPS_data_send+0x3c>
		sos_get_location_data_reply(last_fix.pvt);
   12d0e:	22c0      	movs	r2, #192	; 0xc0
   12d10:	490d      	ldr	r1, [pc, #52]	; (12d48 <APP_GPS_data_send+0x60>)
   12d12:	4668      	mov	r0, sp
   12d14:	f01c fb1e 	bl	2f354 <memcpy>
   12d18:	4b0c      	ldr	r3, [pc, #48]	; (12d4c <APP_GPS_data_send+0x64>)
   12d1a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   12d1c:	f7fb f9fc 	bl	e118 <sos_get_location_data_reply>
		sos_wait_gps = false;
   12d20:	2300      	movs	r3, #0
   12d22:	7023      	strb	r3, [r4, #0]
	if(fall_wait_gps)
   12d24:	4c0b      	ldr	r4, [pc, #44]	; (12d54 <APP_GPS_data_send+0x6c>)
   12d26:	7823      	ldrb	r3, [r4, #0]
   12d28:	b153      	cbz	r3, 12d40 <APP_GPS_data_send+0x58>
		fall_get_location_data_reply(last_fix.pvt);
   12d2a:	22c0      	movs	r2, #192	; 0xc0
   12d2c:	4906      	ldr	r1, [pc, #24]	; (12d48 <APP_GPS_data_send+0x60>)
   12d2e:	4668      	mov	r0, sp
   12d30:	f01c fb10 	bl	2f354 <memcpy>
   12d34:	4b05      	ldr	r3, [pc, #20]	; (12d4c <APP_GPS_data_send+0x64>)
   12d36:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   12d38:	f7fa ff82 	bl	dc40 <fall_get_location_data_reply>
		fall_wait_gps = false;
   12d3c:	2300      	movs	r3, #0
   12d3e:	7023      	strb	r3, [r4, #0]
}
   12d40:	b030      	add	sp, #192	; 0xc0
   12d42:	bd10      	pop	{r4, pc}
   12d44:	2002f92c 	.word	0x2002f92c
   12d48:	20020020 	.word	0x20020020
   12d4c:	20020010 	.word	0x20020010
   12d50:	2002fc71 	.word	0x2002fc71
   12d54:	2002f92e 	.word	0x2002f92e

00012d58 <gps_data_receive>:
{
   12d58:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   12d5c:	b0e7      	sub	sp, #412	; 0x19c
	}while(process_gps_data(&gps_data) > 0);
   12d5e:	a830      	add	r0, sp, #192	; 0xc0
   12d60:	f7ff ff74 	bl	12c4c <process_gps_data>
   12d64:	2800      	cmp	r0, #0
   12d66:	dcfa      	bgt.n	12d5e <gps_data_receive+0x6>
	if(!got_first_fix)
   12d68:	4da4      	ldr	r5, [pc, #656]	; (12ffc <gps_data_receive+0x2a4>)
   12d6a:	782b      	ldrb	r3, [r5, #0]
   12d6c:	bb93      	cbnz	r3, 12dd4 <gps_data_receive+0x7c>
		cnt++;
   12d6e:	f8df 82f0 	ldr.w	r8, [pc, #752]	; 13060 <gps_data_receive+0x308>
		LOG_INF("\033[1;1H");
   12d72:	f04f 0000 	mov.w	r0, #0
		cnt++;
   12d76:	f898 3000 	ldrb.w	r3, [r8]
   12d7a:	4ca1      	ldr	r4, [pc, #644]	; (13000 <gps_data_receive+0x2a8>)
   12d7c:	3301      	adds	r3, #1
   12d7e:	f888 3000 	strb.w	r3, [r8]
		LOG_INF("\033[1;1H");
   12d82:	2303      	movs	r3, #3
   12d84:	f363 0007 	bfi	r0, r3, #0, #8
   12d88:	4b9e      	ldr	r3, [pc, #632]	; (13004 <gps_data_receive+0x2ac>)
   12d8a:	499f      	ldr	r1, [pc, #636]	; (13008 <gps_data_receive+0x2b0>)
   12d8c:	1ae4      	subs	r4, r4, r3
   12d8e:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   12d92:	f364 108f 	bfi	r0, r4, #6, #10
   12d96:	f01a faaf 	bl	2d2f8 <log_string_sync>
		LOG_INF("\033[2J");
   12d9a:	2303      	movs	r3, #3
   12d9c:	f04f 0000 	mov.w	r0, #0
   12da0:	f363 0007 	bfi	r0, r3, #0, #8
   12da4:	4999      	ldr	r1, [pc, #612]	; (1300c <gps_data_receive+0x2b4>)
   12da6:	f364 108f 	bfi	r0, r4, #6, #10
   12daa:	f01a faa5 	bl	2d2f8 <log_string_sync>
		print_satellite_stats(&gps_data);
   12dae:	a830      	add	r0, sp, #192	; 0xc0
   12db0:	f7ff fef8 	bl	12ba4 <print_satellite_stats>
		LOG_INF("\nScanning [%c] ",
   12db4:	2303      	movs	r3, #3
   12db6:	f04f 0000 	mov.w	r0, #0
   12dba:	f363 0007 	bfi	r0, r3, #0, #8
   12dbe:	f898 3000 	ldrb.w	r3, [r8]
   12dc2:	4a93      	ldr	r2, [pc, #588]	; (13010 <gps_data_receive+0x2b8>)
   12dc4:	f003 0303 	and.w	r3, r3, #3
   12dc8:	f364 108f 	bfi	r0, r4, #6, #10
   12dcc:	5cd2      	ldrb	r2, [r2, r3]
   12dce:	4991      	ldr	r1, [pc, #580]	; (13014 <gps_data_receive+0x2bc>)
   12dd0:	f01a fa92 	bl	2d2f8 <log_string_sync>
   12dd4:	f01c fa01 	bl	2f1da <z_impl_k_uptime_get>
	if(((k_uptime_get() - fix_timestamp) >= 1) && (got_first_fix))
   12dd8:	f8df 8288 	ldr.w	r8, [pc, #648]	; 13064 <gps_data_receive+0x30c>
   12ddc:	e9d8 2300 	ldrd	r2, r3, [r8]
   12de0:	428b      	cmp	r3, r1
   12de2:	bf08      	it	eq
   12de4:	4282      	cmpeq	r2, r0
   12de6:	f000 8102 	beq.w	12fee <gps_data_receive+0x296>
   12dea:	782b      	ldrb	r3, [r5, #0]
   12dec:	2b00      	cmp	r3, #0
   12dee:	f000 80fe 	beq.w	12fee <gps_data_receive+0x296>
		LOG_INF("\033[1;1H");
   12df2:	2303      	movs	r3, #3
   12df4:	f04f 0000 	mov.w	r0, #0
   12df8:	4c81      	ldr	r4, [pc, #516]	; (13000 <gps_data_receive+0x2a8>)
   12dfa:	f363 0007 	bfi	r0, r3, #0, #8
   12dfe:	4b81      	ldr	r3, [pc, #516]	; (13004 <gps_data_receive+0x2ac>)
   12e00:	4981      	ldr	r1, [pc, #516]	; (13008 <gps_data_receive+0x2b0>)
   12e02:	1ae4      	subs	r4, r4, r3
   12e04:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   12e08:	f364 108f 	bfi	r0, r4, #6, #10
   12e0c:	f01a fa74 	bl	2d2f8 <log_string_sync>
		LOG_INF("\033[2J");
   12e10:	2303      	movs	r3, #3
   12e12:	f04f 0000 	mov.w	r0, #0
   12e16:	f363 0007 	bfi	r0, r3, #0, #8
   12e1a:	f364 108f 	bfi	r0, r4, #6, #10
   12e1e:	497b      	ldr	r1, [pc, #492]	; (1300c <gps_data_receive+0x2b4>)
   12e20:	f01a fa6a 	bl	2d2f8 <log_string_sync>
		print_satellite_stats(&gps_data);
   12e24:	a830      	add	r0, sp, #192	; 0xc0
   12e26:	f7ff febd 	bl	12ba4 <print_satellite_stats>
		LOG_INF("---------------------------------\n");
   12e2a:	2303      	movs	r3, #3
   12e2c:	f04f 0000 	mov.w	r0, #0
   12e30:	f363 0007 	bfi	r0, r3, #0, #8
   12e34:	f364 108f 	bfi	r0, r4, #6, #10
   12e38:	4977      	ldr	r1, [pc, #476]	; (13018 <gps_data_receive+0x2c0>)
   12e3a:	f01a fa5d 	bl	2d2f8 <log_string_sync>
	LCD_Fill(0,20,240,200,BLACK);
   12e3e:	2000      	movs	r0, #0
   12e40:	23c8      	movs	r3, #200	; 0xc8
   12e42:	9000      	str	r0, [sp, #0]
   12e44:	22f0      	movs	r2, #240	; 0xf0
   12e46:	2114      	movs	r1, #20
   12e48:	f7fd fe66 	bl	10b18 <LCD_Fill>
	LOG_INF("Longitude:  %f\n", pvt_data->pvt.longitude);
   12e4c:	2303      	movs	r3, #3
   12e4e:	f04f 0000 	mov.w	r0, #0
   12e52:	4d72      	ldr	r5, [pc, #456]	; (1301c <gps_data_receive+0x2c4>)
   12e54:	f363 0007 	bfi	r0, r3, #0, #8
   12e58:	f364 108f 	bfi	r0, r4, #6, #10
   12e5c:	e9d5 2304 	ldrd	r2, r3, [r5, #16]
   12e60:	496f      	ldr	r1, [pc, #444]	; (13020 <gps_data_receive+0x2c8>)
   12e62:	f01a fa49 	bl	2d2f8 <log_string_sync>
	LOG_INF("Latitude:   %f\n", pvt_data->pvt.latitude);
   12e66:	2303      	movs	r3, #3
   12e68:	f04f 0000 	mov.w	r0, #0
   12e6c:	f363 0007 	bfi	r0, r3, #0, #8
   12e70:	f364 108f 	bfi	r0, r4, #6, #10
   12e74:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
   12e78:	496a      	ldr	r1, [pc, #424]	; (13024 <gps_data_receive+0x2cc>)
   12e7a:	f01a fa3d 	bl	2d2f8 <log_string_sync>
	LOG_INF("Altitude:   %f\n", pvt_data->pvt.altitude);
   12e7e:	f04f 0900 	mov.w	r9, #0
   12e82:	2303      	movs	r3, #3
   12e84:	69a8      	ldr	r0, [r5, #24]
   12e86:	f363 0907 	bfi	r9, r3, #0, #8
   12e8a:	f7f9 fb3d 	bl	c508 <__aeabi_f2d>
   12e8e:	f364 198f 	bfi	r9, r4, #6, #10
   12e92:	4602      	mov	r2, r0
   12e94:	460b      	mov	r3, r1
   12e96:	4648      	mov	r0, r9
   12e98:	4963      	ldr	r1, [pc, #396]	; (13028 <gps_data_receive+0x2d0>)
   12e9a:	f01a fa2d 	bl	2d2f8 <log_string_sync>
	LOG_INF("Speed:      %f\n", pvt_data->pvt.speed);
   12e9e:	f04f 0900 	mov.w	r9, #0
   12ea2:	2303      	movs	r3, #3
   12ea4:	6a28      	ldr	r0, [r5, #32]
   12ea6:	f363 0907 	bfi	r9, r3, #0, #8
   12eaa:	f7f9 fb2d 	bl	c508 <__aeabi_f2d>
   12eae:	f364 198f 	bfi	r9, r4, #6, #10
   12eb2:	4602      	mov	r2, r0
   12eb4:	460b      	mov	r3, r1
   12eb6:	4648      	mov	r0, r9
   12eb8:	495c      	ldr	r1, [pc, #368]	; (1302c <gps_data_receive+0x2d4>)
   12eba:	f01a fa1d 	bl	2d2f8 <log_string_sync>
	LOG_INF("Heading:    %f\n", pvt_data->pvt.heading);
   12ebe:	f04f 0900 	mov.w	r9, #0
   12ec2:	2303      	movs	r3, #3
   12ec4:	6a68      	ldr	r0, [r5, #36]	; 0x24
   12ec6:	f363 0907 	bfi	r9, r3, #0, #8
   12eca:	f7f9 fb1d 	bl	c508 <__aeabi_f2d>
   12ece:	f364 198f 	bfi	r9, r4, #6, #10
   12ed2:	4602      	mov	r2, r0
   12ed4:	460b      	mov	r3, r1
   12ed6:	4648      	mov	r0, r9
   12ed8:	4955      	ldr	r1, [pc, #340]	; (13030 <gps_data_receive+0x2d8>)
   12eda:	f01a fa0d 	bl	2d2f8 <log_string_sync>
	LOG_INF("Date:       %02u-%02u-%02u", pvt_data->pvt.datetime.year,
   12ede:	2303      	movs	r3, #3
   12ee0:	f04f 0000 	mov.w	r0, #0
   12ee4:	f363 0007 	bfi	r0, r3, #0, #8
   12ee8:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
   12eec:	f364 108f 	bfi	r0, r4, #6, #10
   12ef0:	9300      	str	r3, [sp, #0]
   12ef2:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
   12ef6:	8d2a      	ldrh	r2, [r5, #40]	; 0x28
   12ef8:	494e      	ldr	r1, [pc, #312]	; (13034 <gps_data_receive+0x2dc>)
   12efa:	f01a f9fd 	bl	2d2f8 <log_string_sync>
	LOG_INF("Time (UTC): %02u:%02u:%02u", pvt_data->pvt.datetime.hour,
   12efe:	2303      	movs	r3, #3
   12f00:	f04f 0000 	mov.w	r0, #0
   12f04:	f363 0007 	bfi	r0, r3, #0, #8
   12f08:	f895 302e 	ldrb.w	r3, [r5, #46]	; 0x2e
   12f0c:	f364 108f 	bfi	r0, r4, #6, #10
   12f10:	9300      	str	r3, [sp, #0]
   12f12:	f895 202c 	ldrb.w	r2, [r5, #44]	; 0x2c
   12f16:	f895 302d 	ldrb.w	r3, [r5, #45]	; 0x2d
   12f1a:	4947      	ldr	r1, [pc, #284]	; (13038 <gps_data_receive+0x2e0>)
   12f1c:	f01a f9ec 	bl	2d2f8 <log_string_sync>
		LOG_INF("\n");
   12f20:	2303      	movs	r3, #3
   12f22:	f04f 0000 	mov.w	r0, #0
   12f26:	f363 0007 	bfi	r0, r3, #0, #8
   12f2a:	f364 108f 	bfi	r0, r4, #6, #10
   12f2e:	4943      	ldr	r1, [pc, #268]	; (1303c <gps_data_receive+0x2e4>)
   12f30:	f01a f9e2 	bl	2d2f8 <log_string_sync>
		print_nmea_data();
   12f34:	f7ff fdfc 	bl	12b30 <print_nmea_data>
		LOG_INF("---------------------------------");
   12f38:	2303      	movs	r3, #3
   12f3a:	f04f 0000 	mov.w	r0, #0
   12f3e:	f363 0007 	bfi	r0, r3, #0, #8
   12f42:	f364 108f 	bfi	r0, r4, #6, #10
   12f46:	493e      	ldr	r1, [pc, #248]	; (13040 <gps_data_receive+0x2e8>)
   12f48:	f01a f9d6 	bl	2d2f8 <log_string_sync>
   12f4c:	f01c f945 	bl	2f1da <z_impl_k_uptime_get>
		if(((k_uptime_get() - fix_timestamp) >= 5))
   12f50:	e9d8 3200 	ldrd	r3, r2, [r8]
   12f54:	1ac6      	subs	r6, r0, r3
   12f56:	eb61 0702 	sbc.w	r7, r1, r2
   12f5a:	2f00      	cmp	r7, #0
   12f5c:	bf08      	it	eq
   12f5e:	2e05      	cmpeq	r6, #5
   12f60:	d345      	bcc.n	12fee <gps_data_receive+0x296>
	const s32_t ticks = z_timeout_remaining(&timer->timeout);
   12f62:	4838      	ldr	r0, [pc, #224]	; (13044 <gps_data_receive+0x2ec>)
   12f64:	f015 ff4e 	bl	28e04 <z_timeout_remaining>
	return (ticks > 0) ? (u32_t)k_ticks_to_ms_floor64(ticks) : 0U;
   12f68:	2800      	cmp	r0, #0
   12f6a:	dd0a      	ble.n	12f82 <gps_data_receive+0x22a>
   12f6c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   12f70:	fb80 0103 	smull	r0, r1, r0, r3
   12f74:	0bc3      	lsrs	r3, r0, #15
			if(k_timer_remaining_get(&app_wait_gps_timer) > 0)
   12f76:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
   12f7a:	d002      	beq.n	12f82 <gps_data_receive+0x22a>
	z_impl_k_timer_stop(timer);
   12f7c:	4831      	ldr	r0, [pc, #196]	; (13044 <gps_data_receive+0x2ec>)
   12f7e:	f01c f946 	bl	2f20e <z_impl_k_timer_stop>
	const s32_t ticks = z_timeout_remaining(&timer->timeout);
   12f82:	4830      	ldr	r0, [pc, #192]	; (13044 <gps_data_receive+0x2ec>)
   12f84:	f015 ff3e 	bl	28e04 <z_timeout_remaining>
	return (ticks > 0) ? (u32_t)k_ticks_to_ms_floor64(ticks) : 0U;
   12f88:	2800      	cmp	r0, #0
   12f8a:	dd0a      	ble.n	12fa2 <gps_data_receive+0x24a>
   12f8c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   12f90:	fb80 0103 	smull	r0, r1, r0, r3
   12f94:	0bc3      	lsrs	r3, r0, #15
			if(k_timer_remaining_get(&app_wait_gps_timer) > 0)
   12f96:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
   12f9a:	d002      	beq.n	12fa2 <gps_data_receive+0x24a>
   12f9c:	4829      	ldr	r0, [pc, #164]	; (13044 <gps_data_receive+0x2ec>)
   12f9e:	f01c f936 	bl	2f20e <z_impl_k_timer_stop>
			if(ble_wait_gps || sos_wait_gps)
   12fa2:	4d29      	ldr	r5, [pc, #164]	; (13048 <gps_data_receive+0x2f0>)
   12fa4:	4c29      	ldr	r4, [pc, #164]	; (1304c <gps_data_receive+0x2f4>)
   12fa6:	782b      	ldrb	r3, [r5, #0]
   12fa8:	b993      	cbnz	r3, 12fd0 <gps_data_receive+0x278>
   12faa:	7823      	ldrb	r3, [r4, #0]
   12fac:	b1fb      	cbz	r3, 12fee <gps_data_receive+0x296>
					sos_get_location_data_reply(last_fix.pvt);
   12fae:	22c0      	movs	r2, #192	; 0xc0
   12fb0:	4927      	ldr	r1, [pc, #156]	; (13050 <gps_data_receive+0x2f8>)
   12fb2:	4668      	mov	r0, sp
   12fb4:	f01c f9ce 	bl	2f354 <memcpy>
   12fb8:	4b26      	ldr	r3, [pc, #152]	; (13054 <gps_data_receive+0x2fc>)
   12fba:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   12fbc:	f7fb f8ac 	bl	e118 <sos_get_location_data_reply>
					sos_wait_gps = false;
   12fc0:	2300      	movs	r3, #0
   12fc2:	7023      	strb	r3, [r4, #0]
	app_gps_off = true;
   12fc4:	2201      	movs	r2, #1
   12fc6:	4b24      	ldr	r3, [pc, #144]	; (13058 <gps_data_receive+0x300>)
   12fc8:	701a      	strb	r2, [r3, #0]
}
   12fca:	b067      	add	sp, #412	; 0x19c
   12fcc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					APP_get_location_data_reply(last_fix.pvt);
   12fd0:	22c0      	movs	r2, #192	; 0xc0
   12fd2:	491f      	ldr	r1, [pc, #124]	; (13050 <gps_data_receive+0x2f8>)
   12fd4:	4668      	mov	r0, sp
   12fd6:	f01c f9bd 	bl	2f354 <memcpy>
   12fda:	4b1e      	ldr	r3, [pc, #120]	; (13054 <gps_data_receive+0x2fc>)
   12fdc:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   12fde:	f7f9 ffc3 	bl	cf68 <APP_get_location_data_reply>
					ble_wait_gps = false;
   12fe2:	2300      	movs	r3, #0
   12fe4:	702b      	strb	r3, [r5, #0]
				if(sos_wait_gps)
   12fe6:	7823      	ldrb	r3, [r4, #0]
   12fe8:	2b00      	cmp	r3, #0
   12fea:	d0eb      	beq.n	12fc4 <gps_data_receive+0x26c>
   12fec:	e7df      	b.n	12fae <gps_data_receive+0x256>
	if(!gps_is_on)
   12fee:	4b1b      	ldr	r3, [pc, #108]	; (1305c <gps_data_receive+0x304>)
   12ff0:	781b      	ldrb	r3, [r3, #0]
   12ff2:	2b00      	cmp	r3, #0
   12ff4:	d0e9      	beq.n	12fca <gps_data_receive+0x272>
	print_nmea_data();
   12ff6:	f7ff fd9b 	bl	12b30 <print_nmea_data>
   12ffa:	e7e6      	b.n	12fca <gps_data_receive+0x272>
   12ffc:	2002f92f 	.word	0x2002f92f
   13000:	00030474 	.word	0x00030474
   13004:	0003040c 	.word	0x0003040c
   13008:	000315f1 	.word	0x000315f1
   1300c:	000315f8 	.word	0x000315f8
   13010:	00031850 	.word	0x00031850
   13014:	000315fd 	.word	0x000315fd
   13018:	0003160d 	.word	0x0003160d
   1301c:	20020008 	.word	0x20020008
   13020:	00031630 	.word	0x00031630
   13024:	00031640 	.word	0x00031640
   13028:	00031650 	.word	0x00031650
   1302c:	00031660 	.word	0x00031660
   13030:	00031670 	.word	0x00031670
   13034:	00031680 	.word	0x00031680
   13038:	0003169b 	.word	0x0003169b
   1303c:	00033243 	.word	0x00033243
   13040:	000316b6 	.word	0x000316b6
   13044:	2003b6e4 	.word	0x2003b6e4
   13048:	2002f92c 	.word	0x2002f92c
   1304c:	2002fc71 	.word	0x2002fc71
   13050:	20020020 	.word	0x20020020
   13054:	20020010 	.word	0x20020010
   13058:	2002f929 	.word	0x2002f929
   1305c:	2002f932 	.word	0x2002f932
   13060:	2002f92d 	.word	0x2002f92d
   13064:	20020000 	.word	0x20020000

00013068 <gps_init>:

void gps_init(void)
{
   13068:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	for(i = 0; i < ARRAY_SIZE(at_commands_activate_gps); i++)
   1306c:	2700      	movs	r7, #0
   1306e:	4c4f      	ldr	r4, [pc, #316]	; (131ac <gps_init+0x144>)
{
   13070:	b086      	sub	sp, #24
		if(at_cmd_write(at_commands_activate_gps[i], NULL, 0, NULL) != 0)
   13072:	2300      	movs	r3, #0
   13074:	4620      	mov	r0, r4
   13076:	461a      	mov	r2, r3
   13078:	4619      	mov	r1, r3
   1307a:	f008 ffbd 	bl	1bff8 <at_cmd_write>
   1307e:	2800      	cmp	r0, #0
   13080:	f040 8087 	bne.w	13192 <gps_init+0x12a>
	for(i = 0; i < ARRAY_SIZE(at_commands_activate_gps); i++)
   13084:	3701      	adds	r7, #1
   13086:	2f04      	cmp	r7, #4
   13088:	f104 041f 	add.w	r4, r4, #31
   1308c:	d1f1      	bne.n	13072 <gps_init+0xa>
	nrf_gnss_fix_interval_t fix_interval = 1;
   1308e:	f04f 0801 	mov.w	r8, #1
	nrf_gnss_nmea_mask_t nmea_mask = NRF_GNSS_NMEA_GSV_MASK |
   13092:	231f      	movs	r3, #31
	nrf_gnss_fix_retry_t fix_retry    = 0;
   13094:	f8ad 000e 	strh.w	r0, [sp, #14]
	nrf_gnss_delete_mask_t delete_mask  = 0;
   13098:	9005      	str	r0, [sp, #20]
		gnss_fd = nrf_socket(NRF_AF_LOCAL,
   1309a:	f44f 7201 	mov.w	r2, #516	; 0x204
   1309e:	2102      	movs	r1, #2
   130a0:	4640      	mov	r0, r8
	nrf_gnss_nmea_mask_t nmea_mask = NRF_GNSS_NMEA_GSV_MASK |
   130a2:	f8ad 3012 	strh.w	r3, [sp, #18]
	nrf_gnss_fix_interval_t fix_interval = 1;
   130a6:	f8ad 8010 	strh.w	r8, [sp, #16]
		gnss_fd = nrf_socket(NRF_AF_LOCAL,
   130aa:	f00e fcbd 	bl	21a28 <nrf_socket>
   130ae:	4c40      	ldr	r4, [pc, #256]	; (131b0 <gps_init+0x148>)
   130b0:	4b40      	ldr	r3, [pc, #256]	; (131b4 <gps_init+0x14c>)
   130b2:	4d41      	ldr	r5, [pc, #260]	; (131b8 <gps_init+0x150>)
   130b4:	1ae4      	subs	r4, r4, r3
		if(gnss_fd >= 0)
   130b6:	2800      	cmp	r0, #0
		gnss_fd = nrf_socket(NRF_AF_LOCAL,
   130b8:	4602      	mov	r2, r0
   130ba:	6028      	str	r0, [r5, #0]
		if(gnss_fd >= 0)
   130bc:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   130c0:	da0c      	bge.n	130dc <gps_init+0x74>
			LOG_INF("Could not init socket (err: %d)\n", gnss_fd);
   130c2:	f04f 0000 	mov.w	r0, #0
   130c6:	2303      	movs	r3, #3
   130c8:	f363 0007 	bfi	r0, r3, #0, #8
   130cc:	f364 108f 	bfi	r0, r4, #6, #10
   130d0:	493a      	ldr	r1, [pc, #232]	; (131bc <gps_init+0x154>)
   130d2:	f01a f911 	bl	2d2f8 <log_string_sync>
	{
		return;
	}

	gps_is_inited = true;
}
   130d6:	b006      	add	sp, #24
   130d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			LOG_INF("GPS Socket created\n");
   130dc:	2303      	movs	r3, #3
   130de:	f04f 0000 	mov.w	r0, #0
		retval = nrf_setsockopt(gnss_fd,
   130e2:	2602      	movs	r6, #2
			LOG_INF("GPS Socket created\n");
   130e4:	f363 0007 	bfi	r0, r3, #0, #8
   130e8:	f364 108f 	bfi	r0, r4, #6, #10
   130ec:	4934      	ldr	r1, [pc, #208]	; (131c0 <gps_init+0x158>)
   130ee:	f01a f903 	bl	2d2f8 <log_string_sync>
		retval = nrf_setsockopt(gnss_fd,
   130f2:	9600      	str	r6, [sp, #0]
   130f4:	f10d 030e 	add.w	r3, sp, #14
   130f8:	4632      	mov	r2, r6
   130fa:	f44f 7101 	mov.w	r1, #516	; 0x204
   130fe:	6828      	ldr	r0, [r5, #0]
   13100:	f00e fd68 	bl	21bd4 <nrf_setsockopt>
		if(retval != 0)
   13104:	b150      	cbz	r0, 1311c <gps_init+0xb4>
			LOG_INF("Failed to set fix retry value\n");
   13106:	f04f 0000 	mov.w	r0, #0
   1310a:	2303      	movs	r3, #3
   1310c:	492d      	ldr	r1, [pc, #180]	; (131c4 <gps_init+0x15c>)
   1310e:	f363 0007 	bfi	r0, r3, #0, #8
   13112:	f364 108f 	bfi	r0, r4, #6, #10
		LOG_INF("Failed to initialize modem\n");
   13116:	f01a f8ef 	bl	2d2f8 <log_string_sync>
		return -1;
   1311a:	e7dc      	b.n	130d6 <gps_init+0x6e>
		retval = nrf_setsockopt(gnss_fd,
   1311c:	9600      	str	r6, [sp, #0]
   1311e:	ab04      	add	r3, sp, #16
   13120:	4642      	mov	r2, r8
   13122:	f44f 7101 	mov.w	r1, #516	; 0x204
   13126:	6828      	ldr	r0, [r5, #0]
   13128:	f00e fd54 	bl	21bd4 <nrf_setsockopt>
		if(retval != 0)
   1312c:	b140      	cbz	r0, 13140 <gps_init+0xd8>
			LOG_INF("Failed to set fix interval value\n");
   1312e:	f04f 0000 	mov.w	r0, #0
   13132:	2303      	movs	r3, #3
   13134:	f363 0007 	bfi	r0, r3, #0, #8
   13138:	f364 108f 	bfi	r0, r4, #6, #10
   1313c:	4922      	ldr	r1, [pc, #136]	; (131c8 <gps_init+0x160>)
   1313e:	e7ea      	b.n	13116 <gps_init+0xae>
		retval = nrf_setsockopt(gnss_fd,
   13140:	9600      	str	r6, [sp, #0]
   13142:	f10d 0312 	add.w	r3, sp, #18
   13146:	463a      	mov	r2, r7
   13148:	f44f 7101 	mov.w	r1, #516	; 0x204
   1314c:	6828      	ldr	r0, [r5, #0]
   1314e:	f00e fd41 	bl	21bd4 <nrf_setsockopt>
		if(retval != 0)
   13152:	b140      	cbz	r0, 13166 <gps_init+0xfe>
			LOG_INF("Failed to set nmea mask\n");
   13154:	f04f 0000 	mov.w	r0, #0
   13158:	2303      	movs	r3, #3
   1315a:	f363 0007 	bfi	r0, r3, #0, #8
   1315e:	f364 108f 	bfi	r0, r4, #6, #10
   13162:	491a      	ldr	r1, [pc, #104]	; (131cc <gps_init+0x164>)
   13164:	e7d7      	b.n	13116 <gps_init+0xae>
		retval = nrf_setsockopt(gnss_fd,
   13166:	9700      	str	r7, [sp, #0]
   13168:	ab05      	add	r3, sp, #20
   1316a:	2207      	movs	r2, #7
   1316c:	f44f 7101 	mov.w	r1, #516	; 0x204
   13170:	6828      	ldr	r0, [r5, #0]
   13172:	f00e fd2f 	bl	21bd4 <nrf_setsockopt>
		if(retval != 0)
   13176:	b918      	cbnz	r0, 13180 <gps_init+0x118>
	gps_is_inited = true;
   13178:	4b15      	ldr	r3, [pc, #84]	; (131d0 <gps_init+0x168>)
   1317a:	f883 8000 	strb.w	r8, [r3]
   1317e:	e7aa      	b.n	130d6 <gps_init+0x6e>
			LOG_INF("Failed to start GPS\n");
   13180:	f04f 0000 	mov.w	r0, #0
   13184:	2303      	movs	r3, #3
   13186:	f363 0007 	bfi	r0, r3, #0, #8
   1318a:	f364 108f 	bfi	r0, r4, #6, #10
   1318e:	4911      	ldr	r1, [pc, #68]	; (131d4 <gps_init+0x16c>)
   13190:	e7c1      	b.n	13116 <gps_init+0xae>
		LOG_INF("Failed to initialize modem\n");
   13192:	2303      	movs	r3, #3
   13194:	f04f 0000 	mov.w	r0, #0
   13198:	4a06      	ldr	r2, [pc, #24]	; (131b4 <gps_init+0x14c>)
   1319a:	f363 0007 	bfi	r0, r3, #0, #8
   1319e:	4b04      	ldr	r3, [pc, #16]	; (131b0 <gps_init+0x148>)
   131a0:	490d      	ldr	r1, [pc, #52]	; (131d8 <gps_init+0x170>)
   131a2:	1a9b      	subs	r3, r3, r2
   131a4:	08db      	lsrs	r3, r3, #3
   131a6:	f363 108f 	bfi	r0, r3, #6, #10
   131aa:	e7b4      	b.n	13116 <gps_init+0xae>
   131ac:	00031575 	.word	0x00031575
   131b0:	00030474 	.word	0x00030474
   131b4:	0003040c 	.word	0x0003040c
   131b8:	20020cbc 	.word	0x20020cbc
   131bc:	000316ec 	.word	0x000316ec
   131c0:	000316d8 	.word	0x000316d8
   131c4:	0003170d 	.word	0x0003170d
   131c8:	0003172c 	.word	0x0003172c
   131cc:	0003174e 	.word	0x0003174e
   131d0:	2002f931 	.word	0x2002f931
   131d4:	00031767 	.word	0x00031767
   131d8:	0003177c 	.word	0x0003177c

000131dc <gps_restart>:

void gps_restart(void)
{
   131dc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	nrf_gnss_delete_mask_t delete_mask  = 0;
   131de:	2300      	movs	r3, #0
   131e0:	9303      	str	r3, [sp, #12]
		retval = nrf_setsockopt(gnss_fd,
   131e2:	2304      	movs	r3, #4
   131e4:	480d      	ldr	r0, [pc, #52]	; (1321c <gps_restart+0x40>)
   131e6:	9300      	str	r3, [sp, #0]
   131e8:	2207      	movs	r2, #7
   131ea:	ab03      	add	r3, sp, #12
   131ec:	f44f 7101 	mov.w	r1, #516	; 0x204
   131f0:	6800      	ldr	r0, [r0, #0]
   131f2:	f00e fcef 	bl	21bd4 <nrf_setsockopt>
		if(retval != 0)
   131f6:	b168      	cbz	r0, 13214 <gps_restart+0x38>
			LOG_INF("Failed to start GPS\n");
   131f8:	2303      	movs	r3, #3
   131fa:	f04f 0000 	mov.w	r0, #0
   131fe:	4a08      	ldr	r2, [pc, #32]	; (13220 <gps_restart+0x44>)
   13200:	f363 0007 	bfi	r0, r3, #0, #8
   13204:	4b07      	ldr	r3, [pc, #28]	; (13224 <gps_restart+0x48>)
   13206:	4908      	ldr	r1, [pc, #32]	; (13228 <gps_restart+0x4c>)
   13208:	1a9b      	subs	r3, r3, r2
   1320a:	08db      	lsrs	r3, r3, #3
   1320c:	f363 108f 	bfi	r0, r3, #6, #10
   13210:	f01a f872 	bl	2d2f8 <log_string_sync>
	gnss_ctrl(GNSS_RESTART);
}
   13214:	b005      	add	sp, #20
   13216:	f85d fb04 	ldr.w	pc, [sp], #4
   1321a:	bf00      	nop
   1321c:	20020cbc 	.word	0x20020cbc
   13220:	0003040c 	.word	0x0003040c
   13224:	00030474 	.word	0x00030474
   13228:	00031767 	.word	0x00031767

0001322c <gps_off>:

void gps_off(void)
{
   1322c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	if(!gps_is_on)
   1322e:	4b1d      	ldr	r3, [pc, #116]	; (132a4 <gps_off+0x78>)
   13230:	781a      	ldrb	r2, [r3, #0]
   13232:	b98a      	cbnz	r2, 13258 <gps_off+0x2c>
	{
		LOG_INF("gps is been truned off\n");
   13234:	2303      	movs	r3, #3
   13236:	f04f 0000 	mov.w	r0, #0
   1323a:	4a1b      	ldr	r2, [pc, #108]	; (132a8 <gps_off+0x7c>)
   1323c:	f363 0007 	bfi	r0, r3, #0, #8
   13240:	4b1a      	ldr	r3, [pc, #104]	; (132ac <gps_off+0x80>)
   13242:	491b      	ldr	r1, [pc, #108]	; (132b0 <gps_off+0x84>)
   13244:	1a9b      	subs	r3, r3, r2
   13246:	08db      	lsrs	r3, r3, #3
   13248:	f363 108f 	bfi	r0, r3, #6, #10
			LOG_INF("Failed to stop GPS\n");
   1324c:	f01a f854 	bl	2d2f8 <log_string_sync>
	//#ifdef SHOW_LOG_IN_SCREEN	
	//	show_infor("Failed to reset modem");
	//#endif	
	//}

	GoBackHistoryScreen();
   13250:	f003 f868 	bl	16324 <GoBackHistoryScreen>
}
   13254:	b004      	add	sp, #16
   13256:	bd10      	pop	{r4, pc}
	gps_is_on = false;
   13258:	2400      	movs	r4, #0
   1325a:	701c      	strb	r4, [r3, #0]
	got_first_fix = false;
   1325c:	4b15      	ldr	r3, [pc, #84]	; (132b4 <gps_off+0x88>)
   1325e:	701c      	strb	r4, [r3, #0]
	gps_data_incoming = false;
   13260:	4b15      	ldr	r3, [pc, #84]	; (132b8 <gps_off+0x8c>)
   13262:	701c      	strb	r4, [r3, #0]
   13264:	4815      	ldr	r0, [pc, #84]	; (132bc <gps_off+0x90>)
   13266:	f01b ffd2 	bl	2f20e <z_impl_k_timer_stop>
   1326a:	4815      	ldr	r0, [pc, #84]	; (132c0 <gps_off+0x94>)
   1326c:	f01b ffcf 	bl	2f20e <z_impl_k_timer_stop>
		retval = nrf_setsockopt(gnss_fd,
   13270:	2304      	movs	r3, #4
   13272:	4814      	ldr	r0, [pc, #80]	; (132c4 <gps_off+0x98>)
   13274:	9300      	str	r3, [sp, #0]
   13276:	2208      	movs	r2, #8
   13278:	ab03      	add	r3, sp, #12
   1327a:	f44f 7101 	mov.w	r1, #516	; 0x204
   1327e:	6800      	ldr	r0, [r0, #0]
	nrf_gnss_delete_mask_t delete_mask  = 0;
   13280:	9403      	str	r4, [sp, #12]
		retval = nrf_setsockopt(gnss_fd,
   13282:	f00e fca7 	bl	21bd4 <nrf_setsockopt>
		if(retval != 0)
   13286:	2800      	cmp	r0, #0
   13288:	d0e2      	beq.n	13250 <gps_off+0x24>
			LOG_INF("Failed to stop GPS\n");
   1328a:	2303      	movs	r3, #3
   1328c:	f04f 0000 	mov.w	r0, #0
   13290:	4a05      	ldr	r2, [pc, #20]	; (132a8 <gps_off+0x7c>)
   13292:	f363 0007 	bfi	r0, r3, #0, #8
   13296:	4b05      	ldr	r3, [pc, #20]	; (132ac <gps_off+0x80>)
   13298:	490b      	ldr	r1, [pc, #44]	; (132c8 <gps_off+0x9c>)
   1329a:	1a9b      	subs	r3, r3, r2
   1329c:	08db      	lsrs	r3, r3, #3
   1329e:	f363 108f 	bfi	r0, r3, #6, #10
   132a2:	e7d3      	b.n	1324c <gps_off+0x20>
   132a4:	2002f932 	.word	0x2002f932
   132a8:	0003040c 	.word	0x0003040c
   132ac:	00030474 	.word	0x00030474
   132b0:	00031798 	.word	0x00031798
   132b4:	2002f92f 	.word	0x2002f92f
   132b8:	2002f930 	.word	0x2002f930
   132bc:	2003b710 	.word	0x2003b710
   132c0:	2003b6e4 	.word	0x2003b6e4
   132c4:	20020cbc 	.word	0x20020cbc
   132c8:	000317b0 	.word	0x000317b0

000132cc <gps_on>:

void gps_on(void)
{
   132cc:	b538      	push	{r3, r4, r5, lr}
		.logger     = supl_logger,
		.counter_ms = k_uptime_get
	};
#endif

	if(gps_is_on)
   132ce:	4d20      	ldr	r5, [pc, #128]	; (13350 <gps_on+0x84>)
   132d0:	4c20      	ldr	r4, [pc, #128]	; (13354 <gps_on+0x88>)
   132d2:	4b21      	ldr	r3, [pc, #132]	; (13358 <gps_on+0x8c>)
   132d4:	782a      	ldrb	r2, [r5, #0]
   132d6:	1ae4      	subs	r4, r4, r3
   132d8:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   132dc:	b15a      	cbz	r2, 132f6 <gps_on+0x2a>
	{
		LOG_INF("gps is been truned on\n");
   132de:	2303      	movs	r3, #3
   132e0:	f04f 0000 	mov.w	r0, #0
   132e4:	f363 0007 	bfi	r0, r3, #0, #8
   132e8:	f364 108f 	bfi	r0, r4, #6, #10
   132ec:	491b      	ldr	r1, [pc, #108]	; (1335c <gps_on+0x90>)
#ifdef SHOW_LOG_IN_SCREEN
	show_infor("Getting GPS data...");
#endif

	k_timer_start(&gps_data_timer, K_MSEC(500), K_MSEC(1000));
}
   132ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		LOG_INF("gps is been truned on\n");
   132f2:	f01a b801 	b.w	2d2f8 <log_string_sync>
	EnterGPSTestScreen();
   132f6:	f002 fffd 	bl	162f4 <EnterGPSTestScreen>
	LOG_INF("Staring GPS application\n");
   132fa:	2303      	movs	r3, #3
   132fc:	f04f 0000 	mov.w	r0, #0
   13300:	f363 0007 	bfi	r0, r3, #0, #8
   13304:	f364 108f 	bfi	r0, r4, #6, #10
   13308:	4915      	ldr	r1, [pc, #84]	; (13360 <gps_on+0x94>)
   1330a:	f019 fff5 	bl	2d2f8 <log_string_sync>
	if(gps_is_inited == false)
   1330e:	4b15      	ldr	r3, [pc, #84]	; (13364 <gps_on+0x98>)
   13310:	781b      	ldrb	r3, [r3, #0]
   13312:	b9cb      	cbnz	r3, 13348 <gps_on+0x7c>
		gps_init();
   13314:	f7ff fea8 	bl	13068 <gps_init>
	cnt = 0;
   13318:	2200      	movs	r2, #0
   1331a:	4b13      	ldr	r3, [pc, #76]	; (13368 <gps_on+0x9c>)
	LOG_INF("Getting GPS data...\n");
   1331c:	f04f 0000 	mov.w	r0, #0
	cnt = 0;
   13320:	701a      	strb	r2, [r3, #0]
	gps_is_on = true;
   13322:	2301      	movs	r3, #1
   13324:	702b      	strb	r3, [r5, #0]
	LOG_INF("Getting GPS data...\n");
   13326:	2303      	movs	r3, #3
   13328:	f363 0007 	bfi	r0, r3, #0, #8
   1332c:	f364 108f 	bfi	r0, r4, #6, #10
   13330:	490e      	ldr	r1, [pc, #56]	; (1336c <gps_on+0xa0>)
   13332:	f019 ffe1 	bl	2d2f8 <log_string_sync>
}
   13336:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_timer_start(timer, duration, period);
   1333a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1333e:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
   13342:	480b      	ldr	r0, [pc, #44]	; (13370 <gps_on+0xa4>)
   13344:	f015 bf7e 	b.w	29244 <z_impl_k_timer_start>
		gps_restart();
   13348:	f7ff ff48 	bl	131dc <gps_restart>
   1334c:	e7e4      	b.n	13318 <gps_on+0x4c>
   1334e:	bf00      	nop
   13350:	2002f932 	.word	0x2002f932
   13354:	00030474 	.word	0x00030474
   13358:	0003040c 	.word	0x0003040c
   1335c:	000317c4 	.word	0x000317c4
   13360:	000317db 	.word	0x000317db
   13364:	2002f931 	.word	0x2002f931
   13368:	2002f92d 	.word	0x2002f92d
   1336c:	000317f4 	.word	0x000317f4
   13370:	2003b710 	.word	0x2003b710

00013374 <GPSMsgProcess>:

void GPSMsgProcess(void)
{
   13374:	b508      	push	{r3, lr}
	if(app_gps_on)
   13376:	4b0f      	ldr	r3, [pc, #60]	; (133b4 <GPSMsgProcess+0x40>)
   13378:	781a      	ldrb	r2, [r3, #0]
   1337a:	b11a      	cbz	r2, 13384 <GPSMsgProcess+0x10>
	{
		app_gps_on = false;
   1337c:	2200      	movs	r2, #0
   1337e:	701a      	strb	r2, [r3, #0]
		gps_on();
   13380:	f7ff ffa4 	bl	132cc <gps_on>
	}
	if(app_gps_off)
   13384:	4b0c      	ldr	r3, [pc, #48]	; (133b8 <GPSMsgProcess+0x44>)
   13386:	781a      	ldrb	r2, [r3, #0]
   13388:	b11a      	cbz	r2, 13392 <GPSMsgProcess+0x1e>
	{
		app_gps_off = false;
   1338a:	2200      	movs	r2, #0
   1338c:	701a      	strb	r2, [r3, #0]
		gps_off();
   1338e:	f7ff ff4d 	bl	1322c <gps_off>
	}
	if(gps_data_incoming)
   13392:	4b0a      	ldr	r3, [pc, #40]	; (133bc <GPSMsgProcess+0x48>)
   13394:	781a      	ldrb	r2, [r3, #0]
   13396:	b11a      	cbz	r2, 133a0 <GPSMsgProcess+0x2c>
	{
		gps_data_incoming = false;
   13398:	2200      	movs	r2, #0
   1339a:	701a      	strb	r2, [r3, #0]
		gps_data_receive();
   1339c:	f7ff fcdc 	bl	12d58 <gps_data_receive>
	}
	if(app_gps_send)
   133a0:	4b07      	ldr	r3, [pc, #28]	; (133c0 <GPSMsgProcess+0x4c>)
   133a2:	781a      	ldrb	r2, [r3, #0]
   133a4:	b12a      	cbz	r2, 133b2 <GPSMsgProcess+0x3e>
	{
		app_gps_send = false;
   133a6:	2200      	movs	r2, #0
   133a8:	701a      	strb	r2, [r3, #0]
		APP_GPS_data_send();
	}
}
   133aa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		APP_GPS_data_send();
   133ae:	f7ff bc9b 	b.w	12ce8 <APP_GPS_data_send>
}
   133b2:	bd08      	pop	{r3, pc}
   133b4:	2002f92a 	.word	0x2002f92a
   133b8:	2002f929 	.word	0x2002f929
   133bc:	2002f930 	.word	0x2002f930
   133c0:	2002f92b 	.word	0x2002f92b

000133c4 <SendDataCallBack>:
	}
}

static void SendDataCallBack(struct k_timer *timer)
{
	send_data_flag = true;
   133c4:	2201      	movs	r2, #1
   133c6:	4b01      	ldr	r3, [pc, #4]	; (133cc <SendDataCallBack+0x8>)
   133c8:	701a      	strb	r2, [r3, #0]
}
   133ca:	4770      	bx	lr
   133cc:	2002fd97 	.word	0x2002fd97

000133d0 <MqttDisConnectCallBack>:
		LOG_INF("%s: Could not disconnect MQTT client. Error: %d\n", __func__, err);
	}
}

static void MqttDisConnectCallBack(struct k_timer *timer_id)
{
   133d0:	b508      	push	{r3, lr}
	LOG_INF("%s: begin\n", __func__);
   133d2:	f04f 0000 	mov.w	r0, #0
   133d6:	2303      	movs	r3, #3
   133d8:	4a07      	ldr	r2, [pc, #28]	; (133f8 <MqttDisConnectCallBack+0x28>)
   133da:	f363 0007 	bfi	r0, r3, #0, #8
   133de:	4b07      	ldr	r3, [pc, #28]	; (133fc <MqttDisConnectCallBack+0x2c>)
   133e0:	4907      	ldr	r1, [pc, #28]	; (13400 <MqttDisConnectCallBack+0x30>)
   133e2:	1a9b      	subs	r3, r3, r2
   133e4:	08db      	lsrs	r3, r3, #3
   133e6:	f363 108f 	bfi	r0, r3, #6, #10
   133ea:	4a06      	ldr	r2, [pc, #24]	; (13404 <MqttDisConnectCallBack+0x34>)
   133ec:	f019 ff84 	bl	2d2f8 <log_string_sync>
	mqtt_disconnect_flag = true;
   133f0:	2201      	movs	r2, #1
   133f2:	4b05      	ldr	r3, [pc, #20]	; (13408 <MqttDisConnectCallBack+0x38>)
   133f4:	701a      	strb	r2, [r3, #0]
}
   133f6:	bd08      	pop	{r3, pc}
   133f8:	0003040c 	.word	0x0003040c
   133fc:	000304cc 	.word	0x000304cc
   13400:	00031900 	.word	0x00031900
   13404:	00031a25 	.word	0x00031a25
   13408:	2002fc95 	.word	0x2002fc95

0001340c <modem_rsrp_handler>:


#if CONFIG_MODEM_INFO
/**@brief Callback handler for LTE RSRP data. */
static void modem_rsrp_handler(char rsrp_value)
{
   1340c:	b510      	push	{r4, lr}
	/* RSRP raw values that represent actual signal strength are
	 * 0 through 97 (per "nRF91 AT Commands" v1.1). If the received value
	 * falls outside this range, we should not send the value.
	 */
	LOG_INF("rsrp_value:%d\n", rsrp_value);
   1340e:	2303      	movs	r3, #3
{
   13410:	4604      	mov	r4, r0
	LOG_INF("rsrp_value:%d\n", rsrp_value);
   13412:	f04f 0000 	mov.w	r0, #0
   13416:	4a11      	ldr	r2, [pc, #68]	; (1345c <modem_rsrp_handler+0x50>)
   13418:	f363 0007 	bfi	r0, r3, #0, #8
   1341c:	4b10      	ldr	r3, [pc, #64]	; (13460 <modem_rsrp_handler+0x54>)
   1341e:	4911      	ldr	r1, [pc, #68]	; (13464 <modem_rsrp_handler+0x58>)
   13420:	1a9b      	subs	r3, r3, r2
   13422:	08db      	lsrs	r3, r3, #3
   13424:	f363 108f 	bfi	r0, r3, #6, #10
   13428:	4622      	mov	r2, r4
   1342a:	f019 ff65 	bl	2d2f8 <log_string_sync>

	if(rsrp_value > 97)
   1342e:	2c61      	cmp	r4, #97	; 0x61
   13430:	4b0d      	ldr	r3, [pc, #52]	; (13468 <modem_rsrp_handler+0x5c>)
   13432:	d902      	bls.n	1343a <modem_rsrp_handler+0x2e>
	{
		g_nb_sig = NB_SIG_LEVEL_NO;
   13434:	2200      	movs	r2, #0
	{
		g_nb_sig = NB_SIG_LEVEL_2;
	}
	else if(rsrp_value >= 20)
	{
		g_nb_sig = NB_SIG_LEVEL_1;
   13436:	701a      	strb	r2, [r3, #0]
	{
		g_nb_sig = NB_SIG_LEVEL_0;
	}

	nb_redraw_sig_flag = true;
}
   13438:	bd10      	pop	{r4, pc}
	else if(rsrp_value >= 80)
   1343a:	2c4f      	cmp	r4, #79	; 0x4f
   1343c:	d901      	bls.n	13442 <modem_rsrp_handler+0x36>
		g_nb_sig = NB_SIG_LEVEL_4;
   1343e:	2204      	movs	r2, #4
   13440:	e7f9      	b.n	13436 <modem_rsrp_handler+0x2a>
	else if(rsrp_value >= 60)
   13442:	2c3b      	cmp	r4, #59	; 0x3b
   13444:	d901      	bls.n	1344a <modem_rsrp_handler+0x3e>
		g_nb_sig = NB_SIG_LEVEL_3;
   13446:	2203      	movs	r2, #3
   13448:	e7f5      	b.n	13436 <modem_rsrp_handler+0x2a>
	else if(rsrp_value >= 40)
   1344a:	2c27      	cmp	r4, #39	; 0x27
   1344c:	d901      	bls.n	13452 <modem_rsrp_handler+0x46>
		g_nb_sig = NB_SIG_LEVEL_2;
   1344e:	2202      	movs	r2, #2
   13450:	e7f1      	b.n	13436 <modem_rsrp_handler+0x2a>
	else if(rsrp_value >= 20)
   13452:	2c13      	cmp	r4, #19
   13454:	d9ee      	bls.n	13434 <modem_rsrp_handler+0x28>
		g_nb_sig = NB_SIG_LEVEL_1;
   13456:	2201      	movs	r2, #1
   13458:	e7ed      	b.n	13436 <modem_rsrp_handler+0x2a>
   1345a:	bf00      	nop
   1345c:	0003040c 	.word	0x0003040c
   13460:	000304cc 	.word	0x000304cc
   13464:	00031be0 	.word	0x00031be0
   13468:	2002fc93 	.word	0x2002fc93

0001346c <data_print>:
{
   1346c:	b5b0      	push	{r4, r5, r7, lr}
	char buf[len + 1];
   1346e:	f102 0308 	add.w	r3, r2, #8
   13472:	f023 0307 	bic.w	r3, r3, #7
{
   13476:	af00      	add	r7, sp, #0
	char buf[len + 1];
   13478:	ebad 0d03 	sub.w	sp, sp, r3
{
   1347c:	4604      	mov	r4, r0
   1347e:	4668      	mov	r0, sp
   13480:	4615      	mov	r5, r2
   13482:	f01b ff67 	bl	2f354 <memcpy>
	buf[len] = 0;
   13486:	2300      	movs	r3, #0
	LOG_INF("%s%s\n", prefix, buf);
   13488:	f04f 0000 	mov.w	r0, #0
	buf[len] = 0;
   1348c:	f80d 3005 	strb.w	r3, [sp, r5]
	LOG_INF("%s%s\n", prefix, buf);
   13490:	2303      	movs	r3, #3
   13492:	4a07      	ldr	r2, [pc, #28]	; (134b0 <data_print+0x44>)
   13494:	f363 0007 	bfi	r0, r3, #0, #8
   13498:	4b06      	ldr	r3, [pc, #24]	; (134b4 <data_print+0x48>)
   1349a:	4907      	ldr	r1, [pc, #28]	; (134b8 <data_print+0x4c>)
   1349c:	1a9b      	subs	r3, r3, r2
   1349e:	08db      	lsrs	r3, r3, #3
   134a0:	f363 108f 	bfi	r0, r3, #6, #10
   134a4:	4622      	mov	r2, r4
   134a6:	466b      	mov	r3, sp
   134a8:	f019 ff26 	bl	2d2f8 <log_string_sync>
}
   134ac:	46bd      	mov	sp, r7
   134ae:	bdb0      	pop	{r4, r5, r7, pc}
   134b0:	0003040c 	.word	0x0003040c
   134b4:	000304cc 	.word	0x000304cc
   134b8:	00034e0f 	.word	0x00034e0f

000134bc <data_publish.constprop.6>:
	param.message.topic.qos = qos;
   134bc:	2301      	movs	r3, #1
static int data_publish(struct mqtt_client *c, enum mqtt_qos qos,
   134be:	b570      	push	{r4, r5, r6, lr}
	param.message.topic.topic.utf8 = CONFIG_MQTT_PUB_TOPIC;
   134c0:	4c1a      	ldr	r4, [pc, #104]	; (1352c <data_publish.constprop.6+0x70>)
static int data_publish(struct mqtt_client *c, enum mqtt_qos qos,
   134c2:	b086      	sub	sp, #24
   134c4:	4605      	mov	r5, r0
	param.message.topic.topic.size = strlen(CONFIG_MQTT_PUB_TOPIC);
   134c6:	4620      	mov	r0, r4
static int data_publish(struct mqtt_client *c, enum mqtt_qos qos,
   134c8:	460e      	mov	r6, r1
	param.message.topic.qos = qos;
   134ca:	f88d 3008 	strb.w	r3, [sp, #8]
	param.message.topic.topic.utf8 = CONFIG_MQTT_PUB_TOPIC;
   134ce:	9400      	str	r4, [sp, #0]
	param.message.topic.topic.size = strlen(CONFIG_MQTT_PUB_TOPIC);
   134d0:	f7f9 fd42 	bl	cf58 <strlen>
	param.message.payload.len = len;
   134d4:	e9cd 5603 	strd	r5, r6, [sp, #12]
	param.message.topic.topic.size = strlen(CONFIG_MQTT_PUB_TOPIC);
   134d8:	9001      	str	r0, [sp, #4]
	param.message_id = sys_rand32_get();
   134da:	f007 f903 	bl	1a6e4 <sys_rand32_get>
	param.dup_flag = 0;
   134de:	f89d 3016 	ldrb.w	r3, [sp, #22]
	data_print("Publishing: ", data, len);
   134e2:	4629      	mov	r1, r5
	param.message_id = sys_rand32_get();
   134e4:	f8ad 0014 	strh.w	r0, [sp, #20]
	param.dup_flag = 0;
   134e8:	f023 0303 	bic.w	r3, r3, #3
	data_print("Publishing: ", data, len);
   134ec:	4632      	mov	r2, r6
   134ee:	4810      	ldr	r0, [pc, #64]	; (13530 <data_publish.constprop.6+0x74>)
	param.dup_flag = 0;
   134f0:	f88d 3016 	strb.w	r3, [sp, #22]
	LOG_INF("to topic: %s len: %u\n",
   134f4:	f04f 0500 	mov.w	r5, #0
	data_print("Publishing: ", data, len);
   134f8:	f7ff ffb8 	bl	1346c <data_print>
	LOG_INF("to topic: %s len: %u\n",
   134fc:	2303      	movs	r3, #3
   134fe:	4a0d      	ldr	r2, [pc, #52]	; (13534 <data_publish.constprop.6+0x78>)
   13500:	f363 0507 	bfi	r5, r3, #0, #8
   13504:	4b0c      	ldr	r3, [pc, #48]	; (13538 <data_publish.constprop.6+0x7c>)
   13506:	4620      	mov	r0, r4
   13508:	1a9b      	subs	r3, r3, r2
   1350a:	08db      	lsrs	r3, r3, #3
   1350c:	f363 158f 	bfi	r5, r3, #6, #10
   13510:	f7f9 fd22 	bl	cf58 <strlen>
   13514:	4622      	mov	r2, r4
   13516:	4603      	mov	r3, r0
   13518:	4908      	ldr	r1, [pc, #32]	; (1353c <data_publish.constprop.6+0x80>)
   1351a:	4628      	mov	r0, r5
   1351c:	f019 feec 	bl	2d2f8 <log_string_sync>
	return mqtt_publish(c, &param);
   13520:	4669      	mov	r1, sp
   13522:	4807      	ldr	r0, [pc, #28]	; (13540 <data_publish.constprop.6+0x84>)
   13524:	f01a fc26 	bl	2dd74 <mqtt_publish>
}
   13528:	b006      	add	sp, #24
   1352a:	bd70      	pop	{r4, r5, r6, pc}
   1352c:	00031b80 	.word	0x00031b80
   13530:	00031b95 	.word	0x00031b95
   13534:	0003040c 	.word	0x0003040c
   13538:	000304cc 	.word	0x000304cc
   1353c:	00031ba2 	.word	0x00031ba2
   13540:	20020cc8 	.word	0x20020cc8

00013544 <client_init.constprop.5>:
static void client_init(struct mqtt_client *client)
   13544:	b570      	push	{r4, r5, r6, lr}
	mqtt_client_init(client);
   13546:	485c      	ldr	r0, [pc, #368]	; (136b8 <client_init.constprop.5+0x174>)
static void client_init(struct mqtt_client *client)
   13548:	b090      	sub	sp, #64	; 0x40
	mqtt_client_init(client);
   1354a:	f01a fbb6 	bl	2dcba <mqtt_client_init>
	struct addrinfo hints = {
   1354e:	2220      	movs	r2, #32
   13550:	2100      	movs	r1, #0
   13552:	eb0d 0002 	add.w	r0, sp, r2
   13556:	f01b ff1d 	bl	2f394 <memset>
   1355a:	2301      	movs	r3, #1

static inline int getaddrinfo(const char *node, const char *service,
			      const struct addrinfo *hints,
			      struct addrinfo **res)
{
	__ASSERT_NO_MSG(socket_ops);
   1355c:	4c57      	ldr	r4, [pc, #348]	; (136bc <client_init.constprop.5+0x178>)
   1355e:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
   13562:	6823      	ldr	r3, [r4, #0]
   13564:	b94b      	cbnz	r3, 1357a <client_init.constprop.5+0x36>
   13566:	4956      	ldr	r1, [pc, #344]	; (136c0 <client_init.constprop.5+0x17c>)
   13568:	4856      	ldr	r0, [pc, #344]	; (136c4 <client_init.constprop.5+0x180>)
   1356a:	2393      	movs	r3, #147	; 0x93
   1356c:	4a56      	ldr	r2, [pc, #344]	; (136c8 <client_init.constprop.5+0x184>)
   1356e:	f019 fe6c 	bl	2d24a <printk>
   13572:	2193      	movs	r1, #147	; 0x93
   13574:	4854      	ldr	r0, [pc, #336]	; (136c8 <client_init.constprop.5+0x184>)
   13576:	f019 feae 	bl	2d2d6 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->getaddrinfo);
   1357a:	6823      	ldr	r3, [r4, #0]
   1357c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   1357e:	b94b      	cbnz	r3, 13594 <client_init.constprop.5+0x50>
   13580:	4952      	ldr	r1, [pc, #328]	; (136cc <client_init.constprop.5+0x188>)
   13582:	4850      	ldr	r0, [pc, #320]	; (136c4 <client_init.constprop.5+0x180>)
   13584:	2394      	movs	r3, #148	; 0x94
   13586:	4a50      	ldr	r2, [pc, #320]	; (136c8 <client_init.constprop.5+0x184>)
   13588:	f019 fe5f 	bl	2d24a <printk>
   1358c:	2194      	movs	r1, #148	; 0x94
   1358e:	484e      	ldr	r0, [pc, #312]	; (136c8 <client_init.constprop.5+0x184>)
   13590:	f019 fea1 	bl	2d2d6 <assert_post_action>

	return socket_ops->getaddrinfo(node, service, hints, res);
   13594:	6823      	ldr	r3, [r4, #0]
   13596:	aa08      	add	r2, sp, #32
   13598:	6b5d      	ldr	r5, [r3, #52]	; 0x34
   1359a:	2100      	movs	r1, #0
   1359c:	ab03      	add	r3, sp, #12
   1359e:	484c      	ldr	r0, [pc, #304]	; (136d0 <client_init.constprop.5+0x18c>)
   135a0:	47a8      	blx	r5
	if(err)
   135a2:	4e4c      	ldr	r6, [pc, #304]	; (136d4 <client_init.constprop.5+0x190>)
   135a4:	4602      	mov	r2, r0
   135a6:	2800      	cmp	r0, #0
   135a8:	d034      	beq.n	13614 <client_init.constprop.5+0xd0>
		LOG_INF("ERROR: getaddrinfo failed %d\n", err);
   135aa:	2303      	movs	r3, #3
   135ac:	f04f 0000 	mov.w	r0, #0
   135b0:	4949      	ldr	r1, [pc, #292]	; (136d8 <client_init.constprop.5+0x194>)
   135b2:	f363 0007 	bfi	r0, r3, #0, #8
   135b6:	4b49      	ldr	r3, [pc, #292]	; (136dc <client_init.constprop.5+0x198>)
   135b8:	1a5b      	subs	r3, r3, r1
   135ba:	08db      	lsrs	r3, r3, #3
   135bc:	f363 108f 	bfi	r0, r3, #6, #10
   135c0:	4947      	ldr	r1, [pc, #284]	; (136e0 <client_init.constprop.5+0x19c>)
   135c2:	f019 fe99 	bl	2d2f8 <log_string_sync>
	client->broker = &broker;
   135c6:	4c3c      	ldr	r4, [pc, #240]	; (136b8 <client_init.constprop.5+0x174>)
	client->evt_cb = mqtt_evt_handler;
   135c8:	4b46      	ldr	r3, [pc, #280]	; (136e4 <client_init.constprop.5+0x1a0>)
	client->client_id.utf8 = (u8_t *)g_imei;	//xb add 2021-03-24 CONFIG_MQTT_CLIENT_ID;
   135ca:	4847      	ldr	r0, [pc, #284]	; (136e8 <client_init.constprop.5+0x1a4>)
	client->evt_cb = mqtt_evt_handler;
   135cc:	64a3      	str	r3, [r4, #72]	; 0x48
	client->broker = &broker;
   135ce:	6366      	str	r6, [r4, #52]	; 0x34
	client->client_id.utf8 = (u8_t *)g_imei;	//xb add 2021-03-24 CONFIG_MQTT_CLIENT_ID;
   135d0:	62e0      	str	r0, [r4, #44]	; 0x2c
	client->client_id.size = strlen(g_imei);
   135d2:	f7f9 fcc1 	bl	cf58 <strlen>
	password.utf8 = (u8_t *)CONFIG_MQTT_PASSWORD;
   135d6:	4d45      	ldr	r5, [pc, #276]	; (136ec <client_init.constprop.5+0x1a8>)
   135d8:	4e45      	ldr	r6, [pc, #276]	; (136f0 <client_init.constprop.5+0x1ac>)
	client->client_id.size = strlen(g_imei);
   135da:	6320      	str	r0, [r4, #48]	; 0x30
	password.size = strlen(CONFIG_MQTT_PASSWORD);
   135dc:	4628      	mov	r0, r5
	password.utf8 = (u8_t *)CONFIG_MQTT_PASSWORD;
   135de:	6035      	str	r5, [r6, #0]
	password.size = strlen(CONFIG_MQTT_PASSWORD);
   135e0:	f7f9 fcba 	bl	cf58 <strlen>
	client->password = &password;
   135e4:	63e6      	str	r6, [r4, #60]	; 0x3c
	password.size = strlen(CONFIG_MQTT_PASSWORD);
   135e6:	6070      	str	r0, [r6, #4]
	username.utf8 = (u8_t *)CONFIG_MQTT_USER_NAME;
   135e8:	4e42      	ldr	r6, [pc, #264]	; (136f4 <client_init.constprop.5+0x1b0>)
	username.size = strlen(CONFIG_MQTT_USER_NAME);
   135ea:	4628      	mov	r0, r5
	username.utf8 = (u8_t *)CONFIG_MQTT_USER_NAME;
   135ec:	6035      	str	r5, [r6, #0]
	username.size = strlen(CONFIG_MQTT_USER_NAME);
   135ee:	f7f9 fcb3 	bl	cf58 <strlen>
	client->protocol_version = MQTT_VERSION_3_1_1;
   135f2:	2304      	movs	r3, #4
   135f4:	f884 305e 	strb.w	r3, [r4, #94]	; 0x5e
	client->rx_buf = rx_buffer;
   135f8:	4b3f      	ldr	r3, [pc, #252]	; (136f8 <client_init.constprop.5+0x1b4>)
	client->tx_buf = tx_buffer;
   135fa:	4a40      	ldr	r2, [pc, #256]	; (136fc <client_init.constprop.5+0x1b8>)
	client->rx_buf = rx_buffer;
   135fc:	64e3      	str	r3, [r4, #76]	; 0x4c
	client->rx_buf_size = sizeof(rx_buffer);
   135fe:	2380      	movs	r3, #128	; 0x80
   13600:	6523      	str	r3, [r4, #80]	; 0x50
	client->tx_buf_size = sizeof(tx_buffer);
   13602:	e9c4 2315 	strd	r2, r3, [r4, #84]	; 0x54
    client->transport.type = MQTT_TRANSPORT_NON_SECURE;
   13606:	2300      	movs	r3, #0
	username.size = strlen(CONFIG_MQTT_USER_NAME);
   13608:	6070      	str	r0, [r6, #4]
	client->user_name = &username;
   1360a:	63a6      	str	r6, [r4, #56]	; 0x38
    client->transport.type = MQTT_TRANSPORT_NON_SECURE;
   1360c:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
}
   13610:	b010      	add	sp, #64	; 0x40
   13612:	bd70      	pop	{r4, r5, r6, pc}
	addr = result;
   13614:	9b03      	ldr	r3, [sp, #12]
	while(addr != NULL)
   13616:	b30b      	cbz	r3, 1365c <client_init.constprop.5+0x118>
		if (addr->ai_addrlen == sizeof(struct sockaddr_in))
   13618:	691a      	ldr	r2, [r3, #16]
   1361a:	4d30      	ldr	r5, [pc, #192]	; (136dc <client_init.constprop.5+0x198>)
   1361c:	492e      	ldr	r1, [pc, #184]	; (136d8 <client_init.constprop.5+0x194>)
   1361e:	2a08      	cmp	r2, #8
   13620:	eba5 0501 	sub.w	r5, r5, r1
   13624:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   13628:	d137      	bne.n	1369a <client_init.constprop.5+0x156>
				->sin_addr.s_addr;
   1362a:	695b      	ldr	r3, [r3, #20]
			broker4->sin_family = AF_INET;
   1362c:	2001      	movs	r0, #1
				->sin_addr.s_addr;
   1362e:	685b      	ldr	r3, [r3, #4]
			broker4->sin_family = AF_INET;
   13630:	8030      	strh	r0, [r6, #0]
			broker4->sin_addr.s_addr =
   13632:	6073      	str	r3, [r6, #4]
			broker4->sin_port = htons(CONFIG_MQTT_BROKER_PORT);
   13634:	f645 3307 	movw	r3, #23303	; 0x5b07
   13638:	8073      	strh	r3, [r6, #2]
	if (z_syscall_trap()) {
		return (char *) arch_syscall_invoke4(*(uintptr_t *)&family, *(uintptr_t *)&src, *(uintptr_t *)&dst, *(uintptr_t *)&size, K_SYSCALL_NET_ADDR_NTOP);
	}
#endif
	compiler_barrier();
	return z_impl_net_addr_ntop(family, src, dst, size);
   1363a:	2310      	movs	r3, #16
   1363c:	1d31      	adds	r1, r6, #4
   1363e:	eb0d 0203 	add.w	r2, sp, r3
   13642:	f006 fd21 	bl	1a088 <z_impl_net_addr_ntop>
			LOG_INF("IPv4 Address found %s\n", ipv4_addr);
   13646:	f04f 0000 	mov.w	r0, #0
   1364a:	2303      	movs	r3, #3
   1364c:	f363 0007 	bfi	r0, r3, #0, #8
   13650:	f365 108f 	bfi	r0, r5, #6, #10
   13654:	aa04      	add	r2, sp, #16
   13656:	492a      	ldr	r1, [pc, #168]	; (13700 <client_init.constprop.5+0x1bc>)
   13658:	f019 fe4e 	bl	2d2f8 <log_string_sync>
}

static inline void freeaddrinfo(struct addrinfo *res)
{
	__ASSERT_NO_MSG(socket_ops);
   1365c:	6823      	ldr	r3, [r4, #0]
	freeaddrinfo(result);
   1365e:	9d03      	ldr	r5, [sp, #12]
   13660:	b94b      	cbnz	r3, 13676 <client_init.constprop.5+0x132>
   13662:	4917      	ldr	r1, [pc, #92]	; (136c0 <client_init.constprop.5+0x17c>)
   13664:	4817      	ldr	r0, [pc, #92]	; (136c4 <client_init.constprop.5+0x180>)
   13666:	239b      	movs	r3, #155	; 0x9b
   13668:	4a17      	ldr	r2, [pc, #92]	; (136c8 <client_init.constprop.5+0x184>)
   1366a:	f019 fdee 	bl	2d24a <printk>
   1366e:	219b      	movs	r1, #155	; 0x9b
   13670:	4815      	ldr	r0, [pc, #84]	; (136c8 <client_init.constprop.5+0x184>)
   13672:	f019 fe30 	bl	2d2d6 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->freeaddrinfo);
   13676:	6823      	ldr	r3, [r4, #0]
   13678:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1367a:	b94b      	cbnz	r3, 13690 <client_init.constprop.5+0x14c>
   1367c:	4921      	ldr	r1, [pc, #132]	; (13704 <client_init.constprop.5+0x1c0>)
   1367e:	4811      	ldr	r0, [pc, #68]	; (136c4 <client_init.constprop.5+0x180>)
   13680:	239c      	movs	r3, #156	; 0x9c
   13682:	4a11      	ldr	r2, [pc, #68]	; (136c8 <client_init.constprop.5+0x184>)
   13684:	f019 fde1 	bl	2d24a <printk>
   13688:	219c      	movs	r1, #156	; 0x9c
   1368a:	480f      	ldr	r0, [pc, #60]	; (136c8 <client_init.constprop.5+0x184>)
   1368c:	f019 fe23 	bl	2d2d6 <assert_post_action>

	return socket_ops->freeaddrinfo(res);
   13690:	6823      	ldr	r3, [r4, #0]
   13692:	4628      	mov	r0, r5
   13694:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   13696:	4798      	blx	r3
   13698:	e795      	b.n	135c6 <client_init.constprop.5+0x82>
			LOG_INF("ai_addrlen = %u should be %u or %u\n",
   1369a:	2303      	movs	r3, #3
   1369c:	f04f 0000 	mov.w	r0, #0
   136a0:	f363 0007 	bfi	r0, r3, #0, #8
   136a4:	2318      	movs	r3, #24
   136a6:	f365 108f 	bfi	r0, r5, #6, #10
   136aa:	9300      	str	r3, [sp, #0]
   136ac:	4916      	ldr	r1, [pc, #88]	; (13708 <client_init.constprop.5+0x1c4>)
   136ae:	2308      	movs	r3, #8
   136b0:	f019 fe22 	bl	2d2f8 <log_string_sync>
		break;
   136b4:	e7d2      	b.n	1365c <client_init.constprop.5+0x118>
   136b6:	bf00      	nop
   136b8:	20020cc8 	.word	0x20020cc8
   136bc:	20028668 	.word	0x20028668
   136c0:	00031ad5 	.word	0x00031ad5
   136c4:	000311a3 	.word	0x000311a3
   136c8:	00031aa5 	.word	0x00031aa5
   136cc:	00031ae0 	.word	0x00031ae0
   136d0:	00031af8 	.word	0x00031af8
   136d4:	2002d452 	.word	0x2002d452
   136d8:	0003040c 	.word	0x0003040c
   136dc:	000304cc 	.word	0x000304cc
   136e0:	00031b05 	.word	0x00031b05
   136e4:	000137fd 	.word	0x000137fd
   136e8:	2002fc73 	.word	0x2002fc73
   136ec:	00031b77 	.word	0x00031b77
   136f0:	20020d80 	.word	0x20020d80
   136f4:	20020d88 	.word	0x20020d88
   136f8:	2002fd17 	.word	0x2002fd17
   136fc:	2002fe98 	.word	0x2002fe98
   13700:	00031b23 	.word	0x00031b23
   13704:	00031b5e 	.word	0x00031b5e
   13708:	00031b3a 	.word	0x00031b3a

0001370c <mqtt_send>:
	LOG_INF("%s: begin\n", __func__);
   1370c:	2303      	movs	r3, #3
   1370e:	f04f 0000 	mov.w	r0, #0
{
   13712:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	LOG_INF("%s: begin\n", __func__);
   13716:	f363 0007 	bfi	r0, r3, #0, #8
   1371a:	4c1b      	ldr	r4, [pc, #108]	; (13788 <mqtt_send+0x7c>)
   1371c:	4b1b      	ldr	r3, [pc, #108]	; (1378c <mqtt_send+0x80>)
{
   1371e:	b085      	sub	sp, #20
	LOG_INF("%s: begin\n", __func__);
   13720:	1ae4      	subs	r4, r4, r3
   13722:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   13726:	f364 108f 	bfi	r0, r4, #6, #10
   1372a:	4a19      	ldr	r2, [pc, #100]	; (13790 <mqtt_send+0x84>)
   1372c:	4919      	ldr	r1, [pc, #100]	; (13794 <mqtt_send+0x88>)
   1372e:	f019 fde3 	bl	2d2f8 <log_string_sync>
	u32_t data_len,i=0;
   13732:	2500      	movs	r5, #0
		LOG_INF("%s: ret:%d, loop:%d\n", __func__, ret, ++i);
   13734:	f8df 8058 	ldr.w	r8, [pc, #88]	; 13790 <mqtt_send+0x84>
   13738:	f8df 905c 	ldr.w	r9, [pc, #92]	; 13798 <mqtt_send+0x8c>
		ret = get_data_from_cache(p_data, &data_len);
   1373c:	a903      	add	r1, sp, #12
   1373e:	2000      	movs	r0, #0
   13740:	f001 f88e 	bl	14860 <get_data_from_cache>
   13744:	4607      	mov	r7, r0
		LOG_INF("%s: ret:%d, loop:%d\n", __func__, ret, ++i);
   13746:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   1374a:	f043 0303 	orr.w	r3, r3, #3
   1374e:	f363 0607 	bfi	r6, r3, #0, #8
   13752:	f364 168f 	bfi	r6, r4, #6, #10
   13756:	3501      	adds	r5, #1
   13758:	4603      	mov	r3, r0
   1375a:	9500      	str	r5, [sp, #0]
   1375c:	4642      	mov	r2, r8
   1375e:	4649      	mov	r1, r9
   13760:	4630      	mov	r0, r6
   13762:	f019 fdc9 	bl	2d2f8 <log_string_sync>
		if(ret)
   13766:	b15f      	cbz	r7, 13780 <mqtt_send+0x74>
			ret = data_publish(&client, MQTT_QOS_1_AT_LEAST_ONCE, p_data, data_len);
   13768:	9903      	ldr	r1, [sp, #12]
   1376a:	2000      	movs	r0, #0
   1376c:	f7ff fea6 	bl	134bc <data_publish.constprop.6>
			if(!ret)
   13770:	b908      	cbnz	r0, 13776 <mqtt_send+0x6a>
				delete_data_from_cache();
   13772:	f001 f8b5 	bl	148e0 <delete_data_from_cache>
	return z_impl_k_sleep(ms);
   13776:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
   1377a:	f014 fe75 	bl	28468 <z_impl_k_sleep>
   1377e:	e7dd      	b.n	1373c <mqtt_send+0x30>
}
   13780:	b005      	add	sp, #20
   13782:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   13786:	bf00      	nop
   13788:	000304cc 	.word	0x000304cc
   1378c:	0003040c 	.word	0x0003040c
   13790:	00031a0c 	.word	0x00031a0c
   13794:	00031900 	.word	0x00031900
   13798:	00031e55 	.word	0x00031e55

0001379c <poll.constprop.14>:
static inline int poll(struct pollfd *fds, int nfds, int timeout)
   1379c:	b570      	push	{r4, r5, r6, lr}
	__ASSERT_NO_MSG(socket_ops);
   1379e:	4c11      	ldr	r4, [pc, #68]	; (137e4 <poll.constprop.14+0x48>)
static inline int poll(struct pollfd *fds, int nfds, int timeout)
   137a0:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(socket_ops);
   137a2:	6823      	ldr	r3, [r4, #0]
   137a4:	b94b      	cbnz	r3, 137ba <poll.constprop.14+0x1e>
   137a6:	4910      	ldr	r1, [pc, #64]	; (137e8 <poll.constprop.14+0x4c>)
   137a8:	4810      	ldr	r0, [pc, #64]	; (137ec <poll.constprop.14+0x50>)
   137aa:	234d      	movs	r3, #77	; 0x4d
   137ac:	4a10      	ldr	r2, [pc, #64]	; (137f0 <poll.constprop.14+0x54>)
   137ae:	f019 fd4c 	bl	2d24a <printk>
   137b2:	214d      	movs	r1, #77	; 0x4d
   137b4:	480e      	ldr	r0, [pc, #56]	; (137f0 <poll.constprop.14+0x54>)
   137b6:	f019 fd8e 	bl	2d2d6 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->poll);
   137ba:	6823      	ldr	r3, [r4, #0]
   137bc:	699b      	ldr	r3, [r3, #24]
   137be:	b94b      	cbnz	r3, 137d4 <poll.constprop.14+0x38>
   137c0:	490c      	ldr	r1, [pc, #48]	; (137f4 <poll.constprop.14+0x58>)
   137c2:	480a      	ldr	r0, [pc, #40]	; (137ec <poll.constprop.14+0x50>)
   137c4:	234e      	movs	r3, #78	; 0x4e
   137c6:	4a0a      	ldr	r2, [pc, #40]	; (137f0 <poll.constprop.14+0x54>)
   137c8:	f019 fd3f 	bl	2d24a <printk>
   137cc:	214e      	movs	r1, #78	; 0x4e
   137ce:	4808      	ldr	r0, [pc, #32]	; (137f0 <poll.constprop.14+0x54>)
   137d0:	f019 fd81 	bl	2d2d6 <assert_post_action>
	return socket_ops->poll(fds, nfds, timeout);
   137d4:	6823      	ldr	r3, [r4, #0]
   137d6:	462a      	mov	r2, r5
}
   137d8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return socket_ops->poll(fds, nfds, timeout);
   137dc:	699b      	ldr	r3, [r3, #24]
   137de:	2101      	movs	r1, #1
   137e0:	4805      	ldr	r0, [pc, #20]	; (137f8 <poll.constprop.14+0x5c>)
   137e2:	4718      	bx	r3
   137e4:	20028668 	.word	0x20028668
   137e8:	00031ad5 	.word	0x00031ad5
   137ec:	000311a3 	.word	0x000311a3
   137f0:	00031aa5 	.word	0x00031aa5
   137f4:	00031ea2 	.word	0x00031ea2
   137f8:	20020d2c 	.word	0x20020d2c

000137fc <mqtt_evt_handler>:
{
   137fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13800:	4a99      	ldr	r2, [pc, #612]	; (13a68 <mqtt_evt_handler+0x26c>)
   13802:	4c9a      	ldr	r4, [pc, #616]	; (13a6c <mqtt_evt_handler+0x270>)
	switch(evt->type)
   13804:	780b      	ldrb	r3, [r1, #0]
   13806:	1aa4      	subs	r4, r4, r2
{
   13808:	b089      	sub	sp, #36	; 0x24
   1380a:	4680      	mov	r8, r0
   1380c:	460d      	mov	r5, r1
   1380e:	f3c4 04c9 	ubfx	r4, r4, #3, #10
	switch(evt->type)
   13812:	2b07      	cmp	r3, #7
   13814:	f200 811b 	bhi.w	13a4e <mqtt_evt_handler+0x252>
   13818:	e8df f013 	tbh	[pc, r3, lsl #1]
   1381c:	00660008 	.word	0x00660008
   13820:	00f3007f 	.word	0x00f3007f
   13824:	01190119 	.word	0x01190119
   13828:	01070119 	.word	0x01070119
		if(evt->result != 0)
   1382c:	69cd      	ldr	r5, [r1, #28]
   1382e:	b15d      	cbz	r5, 13848 <mqtt_evt_handler+0x4c>
			LOG_INF("MQTT connect failed %d\n", evt->result);
   13830:	f04f 0000 	mov.w	r0, #0
   13834:	2303      	movs	r3, #3
   13836:	462a      	mov	r2, r5
   13838:	f363 0007 	bfi	r0, r3, #0, #8
   1383c:	498c      	ldr	r1, [pc, #560]	; (13a70 <mqtt_evt_handler+0x274>)
   1383e:	f364 108f 	bfi	r0, r4, #6, #10
					LOG_INF("Could not disconnect: %d\n", err);
   13842:	f019 fd59 	bl	2d2f8 <log_string_sync>
   13846:	e04c      	b.n	138e2 <mqtt_evt_handler+0xe6>
		mqtt_connected = true;
   13848:	2701      	movs	r7, #1
   1384a:	4b8a      	ldr	r3, [pc, #552]	; (13a74 <mqtt_evt_handler+0x278>)
		LOG_INF("[%s:%d] MQTT client connected!\n", __func__, __LINE__);
   1384c:	f04f 0000 	mov.w	r0, #0
		mqtt_connected = true;
   13850:	701f      	strb	r7, [r3, #0]
		LOG_INF("[%s:%d] MQTT client connected!\n", __func__, __LINE__);
   13852:	2303      	movs	r3, #3
   13854:	f363 0007 	bfi	r0, r3, #0, #8
   13858:	f364 108f 	bfi	r0, r4, #6, #10
   1385c:	f44f 738c 	mov.w	r3, #280	; 0x118
   13860:	4a85      	ldr	r2, [pc, #532]	; (13a78 <mqtt_evt_handler+0x27c>)
   13862:	4986      	ldr	r1, [pc, #536]	; (13a7c <mqtt_evt_handler+0x280>)
   13864:	f019 fd48 	bl	2d2f8 <log_string_sync>
	sprintf(str_sub_topic, "%s%s", CONFIG_MQTT_SUB_TOPIC, g_imei);
   13868:	4b85      	ldr	r3, [pc, #532]	; (13a80 <mqtt_evt_handler+0x284>)
   1386a:	4e86      	ldr	r6, [pc, #536]	; (13a84 <mqtt_evt_handler+0x288>)
   1386c:	9301      	str	r3, [sp, #4]
   1386e:	4b86      	ldr	r3, [pc, #536]	; (13a88 <mqtt_evt_handler+0x28c>)
   13870:	4629      	mov	r1, r5
   13872:	9300      	str	r3, [sp, #0]
   13874:	f44f 7280 	mov.w	r2, #256	; 0x100
   13878:	4b84      	ldr	r3, [pc, #528]	; (13a8c <mqtt_evt_handler+0x290>)
   1387a:	4630      	mov	r0, r6
   1387c:	f01b fecc 	bl	2f618 <__sprintf_chk>
			.size = strlen(subscribe_topic.topic.utf8)
   13880:	4630      	mov	r0, r6
	struct mqtt_topic subscribe_topic = {
   13882:	9605      	str	r6, [sp, #20]
			.size = strlen(subscribe_topic.topic.utf8)
   13884:	f7f9 fb68 	bl	cf58 <strlen>
	const struct mqtt_subscription_list subscription_list = {
   13888:	aa05      	add	r2, sp, #20
   1388a:	9203      	str	r2, [sp, #12]
   1388c:	4a80      	ldr	r2, [pc, #512]	; (13a90 <mqtt_evt_handler+0x294>)
			.size = strlen(subscribe_topic.topic.utf8)
   1388e:	4603      	mov	r3, r0
	struct mqtt_topic subscribe_topic = {
   13890:	9006      	str	r0, [sp, #24]
	const struct mqtt_subscription_list subscription_list = {
   13892:	9204      	str	r2, [sp, #16]
	LOG_INF("Subscribing to:%s, len:%d\n", subscribe_topic.topic.utf8,
   13894:	f04f 0000 	mov.w	r0, #0
   13898:	2203      	movs	r2, #3
   1389a:	f362 0007 	bfi	r0, r2, #0, #8
   1389e:	f364 108f 	bfi	r0, r4, #6, #10
   138a2:	9a05      	ldr	r2, [sp, #20]
   138a4:	497b      	ldr	r1, [pc, #492]	; (13a94 <mqtt_evt_handler+0x298>)
	struct mqtt_topic subscribe_topic = {
   138a6:	f88d 701c 	strb.w	r7, [sp, #28]
	LOG_INF("Subscribing to:%s, len:%d\n", subscribe_topic.topic.utf8,
   138aa:	f019 fd25 	bl	2d2f8 <log_string_sync>
	return mqtt_subscribe(&client, &subscription_list);
   138ae:	a903      	add	r1, sp, #12
   138b0:	4879      	ldr	r0, [pc, #484]	; (13a98 <mqtt_evt_handler+0x29c>)
   138b2:	f01a fab6 	bl	2de22 <mqtt_subscribe>
	z_impl_k_timer_start(timer, duration, period);
   138b6:	f241 3188 	movw	r1, #5000	; 0x1388
   138ba:	462a      	mov	r2, r5
   138bc:	4877      	ldr	r0, [pc, #476]	; (13a9c <mqtt_evt_handler+0x2a0>)
   138be:	f015 fcc1 	bl	29244 <z_impl_k_timer_start>
	LOG_INF("%s: begin\n", __func__);
   138c2:	2303      	movs	r3, #3
   138c4:	f04f 0000 	mov.w	r0, #0
   138c8:	f363 0007 	bfi	r0, r3, #0, #8
   138cc:	f364 108f 	bfi	r0, r4, #6, #10
   138d0:	4a73      	ldr	r2, [pc, #460]	; (13aa0 <mqtt_evt_handler+0x2a4>)
   138d2:	4974      	ldr	r1, [pc, #464]	; (13aa4 <mqtt_evt_handler+0x2a8>)
   138d4:	f019 fd10 	bl	2d2f8 <log_string_sync>
   138d8:	4973      	ldr	r1, [pc, #460]	; (13aa8 <mqtt_evt_handler+0x2ac>)
   138da:	462a      	mov	r2, r5
   138dc:	4873      	ldr	r0, [pc, #460]	; (13aac <mqtt_evt_handler+0x2b0>)
   138de:	f015 fcb1 	bl	29244 <z_impl_k_timer_start>
}
   138e2:	b009      	add	sp, #36	; 0x24
   138e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		LOG_INF("[%s:%d] MQTT client disconnected %d\n", __func__, __LINE__, evt->result);
   138e8:	2303      	movs	r3, #3
   138ea:	f04f 0000 	mov.w	r0, #0
   138ee:	f363 0007 	bfi	r0, r3, #0, #8
   138f2:	69cb      	ldr	r3, [r1, #28]
   138f4:	f364 108f 	bfi	r0, r4, #6, #10
   138f8:	9300      	str	r3, [sp, #0]
   138fa:	4a5f      	ldr	r2, [pc, #380]	; (13a78 <mqtt_evt_handler+0x27c>)
   138fc:	f240 1321 	movw	r3, #289	; 0x121
   13900:	496b      	ldr	r1, [pc, #428]	; (13ab0 <mqtt_evt_handler+0x2b4>)
   13902:	f019 fcf9 	bl	2d2f8 <log_string_sync>
		mqtt_connected = false;
   13906:	2200      	movs	r2, #0
   13908:	4b5a      	ldr	r3, [pc, #360]	; (13a74 <mqtt_evt_handler+0x278>)
   1390a:	701a      	strb	r2, [r3, #0]
	z_impl_k_timer_stop(timer);
   1390c:	4863      	ldr	r0, [pc, #396]	; (13a9c <mqtt_evt_handler+0x2a0>)
   1390e:	f01b fc7e 	bl	2f20e <z_impl_k_timer_stop>
   13912:	4866      	ldr	r0, [pc, #408]	; (13aac <mqtt_evt_handler+0x2b0>)
   13914:	f01b fc7b 	bl	2f20e <z_impl_k_timer_stop>
   13918:	e7e3      	b.n	138e2 <mqtt_evt_handler+0xe6>
			LOG_INF("[%s:%d] MQTT PUBLISH result=%d len=%d\n", __func__, __LINE__, evt->result, p->message.payload.len);
   1391a:	2303      	movs	r3, #3
   1391c:	f04f 0000 	mov.w	r0, #0
   13920:	f363 0007 	bfi	r0, r3, #0, #8
   13924:	694b      	ldr	r3, [r1, #20]
   13926:	f364 108f 	bfi	r0, r4, #6, #10
   1392a:	9301      	str	r3, [sp, #4]
   1392c:	69cb      	ldr	r3, [r1, #28]
   1392e:	4a52      	ldr	r2, [pc, #328]	; (13a78 <mqtt_evt_handler+0x27c>)
   13930:	9300      	str	r3, [sp, #0]
   13932:	4960      	ldr	r1, [pc, #384]	; (13ab4 <mqtt_evt_handler+0x2b8>)
   13934:	f44f 7396 	mov.w	r3, #300	; 0x12c
   13938:	f019 fcde 	bl	2d2f8 <log_string_sync>
			err = publish_get_payload(c, p->message.payload.len);
   1393c:	696b      	ldr	r3, [r5, #20]
	u8_t *end = buf + length;
   1393e:	4e5e      	ldr	r6, [pc, #376]	; (13ab8 <mqtt_evt_handler+0x2bc>)
	if(length > sizeof(payload_buf))
   13940:	2b80      	cmp	r3, #128	; 0x80
	u8_t *end = buf + length;
   13942:	eb06 0903 	add.w	r9, r6, r3
	if(length > sizeof(payload_buf))
   13946:	d859      	bhi.n	139fc <mqtt_evt_handler+0x200>
			LOG_INF("mqtt_read_publish_payload: EAGAIN\n");
   13948:	f8df a194 	ldr.w	sl, [pc, #404]	; 13ae0 <mqtt_evt_handler+0x2e4>
			if(err > 0 && (fds.revents & POLLIN) == POLLIN)
   1394c:	f8df b194 	ldr.w	fp, [pc, #404]	; 13ae4 <mqtt_evt_handler+0x2e8>
	while(buf < end)
   13950:	45b1      	cmp	r9, r6
   13952:	d809      	bhi.n	13968 <mqtt_evt_handler+0x16c>
				data_print("Received: ", payload_buf,
   13954:	696a      	ldr	r2, [r5, #20]
   13956:	4958      	ldr	r1, [pc, #352]	; (13ab8 <mqtt_evt_handler+0x2bc>)
   13958:	4858      	ldr	r0, [pc, #352]	; (13abc <mqtt_evt_handler+0x2c0>)
   1395a:	f7ff fd87 	bl	1346c <data_print>
				data_publish(&client, MQTT_QOS_1_AT_LEAST_ONCE,
   1395e:	6969      	ldr	r1, [r5, #20]
   13960:	4855      	ldr	r0, [pc, #340]	; (13ab8 <mqtt_evt_handler+0x2bc>)
   13962:	f7ff fdab 	bl	134bc <data_publish.constprop.6>
   13966:	e7bc      	b.n	138e2 <mqtt_evt_handler+0xe6>
		int ret = mqtt_read_publish_payload(c, buf, end - buf);
   13968:	eba9 0206 	sub.w	r2, r9, r6
   1396c:	4631      	mov	r1, r6
   1396e:	4640      	mov	r0, r8
   13970:	f01a fb08 	bl	2df84 <mqtt_read_publish_payload>
		if(ret < 0)
   13974:	1e02      	subs	r2, r0, #0
   13976:	da3e      	bge.n	139f6 <mqtt_evt_handler+0x1fa>
			if(ret != -EAGAIN)
   13978:	f112 0f0b 	cmn.w	r2, #11
   1397c:	d113      	bne.n	139a6 <mqtt_evt_handler+0x1aa>
			LOG_INF("mqtt_read_publish_payload: EAGAIN\n");
   1397e:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
   13982:	f043 0303 	orr.w	r3, r3, #3
   13986:	f363 0707 	bfi	r7, r3, #0, #8
   1398a:	f364 178f 	bfi	r7, r4, #6, #10
   1398e:	4651      	mov	r1, sl
   13990:	4638      	mov	r0, r7
   13992:	f019 fcb1 	bl	2d2f8 <log_string_sync>
			err = poll(&fds, 1,
   13996:	f64e 2060 	movw	r0, #60000	; 0xea60
   1399a:	f7ff feff 	bl	1379c <poll.constprop.14>
			if(err > 0 && (fds.revents & POLLIN) == POLLIN)
   1399e:	2800      	cmp	r0, #0
   139a0:	dc24      	bgt.n	139ec <mqtt_evt_handler+0x1f0>
				return -EIO;
   139a2:	f06f 0204 	mvn.w	r2, #4
				LOG_INF("mqtt_read_publish_payload: Failed! %d\n", err);
   139a6:	2303      	movs	r3, #3
   139a8:	f04f 0000 	mov.w	r0, #0
   139ac:	f363 0007 	bfi	r0, r3, #0, #8
   139b0:	f364 108f 	bfi	r0, r4, #6, #10
   139b4:	4942      	ldr	r1, [pc, #264]	; (13ac0 <mqtt_evt_handler+0x2c4>)
   139b6:	f019 fc9f 	bl	2d2f8 <log_string_sync>
				LOG_INF("Disconnecting MQTT client...\n");
   139ba:	2303      	movs	r3, #3
   139bc:	f04f 0000 	mov.w	r0, #0
   139c0:	f363 0007 	bfi	r0, r3, #0, #8
   139c4:	f364 108f 	bfi	r0, r4, #6, #10
   139c8:	493e      	ldr	r1, [pc, #248]	; (13ac4 <mqtt_evt_handler+0x2c8>)
   139ca:	f019 fc95 	bl	2d2f8 <log_string_sync>
				err = mqtt_disconnect(c);
   139ce:	4640      	mov	r0, r8
   139d0:	f01a f9fe 	bl	2ddd0 <mqtt_disconnect>
				if(err)
   139d4:	4602      	mov	r2, r0
   139d6:	2800      	cmp	r0, #0
   139d8:	d083      	beq.n	138e2 <mqtt_evt_handler+0xe6>
					LOG_INF("Could not disconnect: %d\n", err);
   139da:	2103      	movs	r1, #3
   139dc:	f04f 0000 	mov.w	r0, #0
   139e0:	f361 0007 	bfi	r0, r1, #0, #8
   139e4:	f364 108f 	bfi	r0, r4, #6, #10
   139e8:	4937      	ldr	r1, [pc, #220]	; (13ac8 <mqtt_evt_handler+0x2cc>)
   139ea:	e72a      	b.n	13842 <mqtt_evt_handler+0x46>
			if(err > 0 && (fds.revents & POLLIN) == POLLIN)
   139ec:	f8bb 3006 	ldrh.w	r3, [fp, #6]
   139f0:	07db      	lsls	r3, r3, #31
   139f2:	d4ad      	bmi.n	13950 <mqtt_evt_handler+0x154>
   139f4:	e7d5      	b.n	139a2 <mqtt_evt_handler+0x1a6>
		if(ret == 0)
   139f6:	d0d4      	beq.n	139a2 <mqtt_evt_handler+0x1a6>
		buf += ret;
   139f8:	4416      	add	r6, r2
   139fa:	e7a9      	b.n	13950 <mqtt_evt_handler+0x154>
		return -EMSGSIZE;
   139fc:	f06f 0279 	mvn.w	r2, #121	; 0x79
   13a00:	e7d1      	b.n	139a6 <mqtt_evt_handler+0x1aa>
			LOG_INF("MQTT PUBACK error %d\n", evt->result);
   13a02:	f04f 0000 	mov.w	r0, #0
   13a06:	2303      	movs	r3, #3
		if(evt->result != 0)
   13a08:	69ca      	ldr	r2, [r1, #28]
			LOG_INF("MQTT PUBACK error %d\n", evt->result);
   13a0a:	f363 0007 	bfi	r0, r3, #0, #8
   13a0e:	f364 108f 	bfi	r0, r4, #6, #10
		if(evt->result != 0)
   13a12:	b10a      	cbz	r2, 13a18 <mqtt_evt_handler+0x21c>
			LOG_INF("MQTT PUBACK error %d\n", evt->result);
   13a14:	492d      	ldr	r1, [pc, #180]	; (13acc <mqtt_evt_handler+0x2d0>)
   13a16:	e714      	b.n	13842 <mqtt_evt_handler+0x46>
		LOG_INF("[%s:%d] PUBACK packet id: %u\n", __func__, __LINE__,
   13a18:	888b      	ldrh	r3, [r1, #4]
   13a1a:	4a17      	ldr	r2, [pc, #92]	; (13a78 <mqtt_evt_handler+0x27c>)
   13a1c:	9300      	str	r3, [sp, #0]
   13a1e:	f240 1351 	movw	r3, #337	; 0x151
   13a22:	492b      	ldr	r1, [pc, #172]	; (13ad0 <mqtt_evt_handler+0x2d4>)
		LOG_INF("[%s:%d] default: %d\n", __func__, __LINE__,
   13a24:	f019 fc68 	bl	2d2f8 <log_string_sync>
}
   13a28:	e75b      	b.n	138e2 <mqtt_evt_handler+0xe6>
			LOG_INF("MQTT SUBACK error %d\n", evt->result);
   13a2a:	f04f 0000 	mov.w	r0, #0
   13a2e:	2303      	movs	r3, #3
		if(evt->result != 0)
   13a30:	69ca      	ldr	r2, [r1, #28]
			LOG_INF("MQTT SUBACK error %d\n", evt->result);
   13a32:	f363 0007 	bfi	r0, r3, #0, #8
   13a36:	f364 108f 	bfi	r0, r4, #6, #10
		if(evt->result != 0)
   13a3a:	b10a      	cbz	r2, 13a40 <mqtt_evt_handler+0x244>
			LOG_INF("MQTT SUBACK error %d\n", evt->result);
   13a3c:	4925      	ldr	r1, [pc, #148]	; (13ad4 <mqtt_evt_handler+0x2d8>)
   13a3e:	e700      	b.n	13842 <mqtt_evt_handler+0x46>
		LOG_INF("[%s:%d] SUBACK packet id: %u\n", __func__, __LINE__,
   13a40:	888b      	ldrh	r3, [r1, #4]
   13a42:	4a0d      	ldr	r2, [pc, #52]	; (13a78 <mqtt_evt_handler+0x27c>)
   13a44:	9300      	str	r3, [sp, #0]
   13a46:	4924      	ldr	r1, [pc, #144]	; (13ad8 <mqtt_evt_handler+0x2dc>)
   13a48:	f44f 73ae 	mov.w	r3, #348	; 0x15c
   13a4c:	e7ea      	b.n	13a24 <mqtt_evt_handler+0x228>
		LOG_INF("[%s:%d] default: %d\n", __func__, __LINE__,
   13a4e:	2203      	movs	r2, #3
   13a50:	f04f 0000 	mov.w	r0, #0
   13a54:	f362 0007 	bfi	r0, r2, #0, #8
	switch(evt->type)
   13a58:	9300      	str	r3, [sp, #0]
		LOG_INF("[%s:%d] default: %d\n", __func__, __LINE__,
   13a5a:	f364 108f 	bfi	r0, r4, #6, #10
   13a5e:	f240 1361 	movw	r3, #353	; 0x161
   13a62:	4a05      	ldr	r2, [pc, #20]	; (13a78 <mqtt_evt_handler+0x27c>)
   13a64:	491d      	ldr	r1, [pc, #116]	; (13adc <mqtt_evt_handler+0x2e0>)
   13a66:	e7dd      	b.n	13a24 <mqtt_evt_handler+0x228>
   13a68:	0003040c 	.word	0x0003040c
   13a6c:	000304cc 	.word	0x000304cc
   13a70:	00031bef 	.word	0x00031bef
   13a74:	2002fc94 	.word	0x2002fc94
   13a78:	000319f1 	.word	0x000319f1
   13a7c:	00031c07 	.word	0x00031c07
   13a80:	2002fc73 	.word	0x2002fc73
   13a84:	2002fd98 	.word	0x2002fd98
   13a88:	00031c2c 	.word	0x00031c2c
   13a8c:	00031c27 	.word	0x00031c27
   13a90:	04d20001 	.word	0x04d20001
   13a94:	00031c39 	.word	0x00031c39
   13a98:	20020cc8 	.word	0x20020cc8
   13a9c:	2003b768 	.word	0x2003b768
   13aa0:	00031a3c 	.word	0x00031a3c
   13aa4:	00031900 	.word	0x00031900
   13aa8:	000493e0 	.word	0x000493e0
   13aac:	2003b73c 	.word	0x2003b73c
   13ab0:	00031c54 	.word	0x00031c54
   13ab4:	00031c79 	.word	0x00031c79
   13ab8:	2002fc97 	.word	0x2002fc97
   13abc:	00031d9f 	.word	0x00031d9f
   13ac0:	00031cc3 	.word	0x00031cc3
   13ac4:	00031cea 	.word	0x00031cea
   13ac8:	00031d08 	.word	0x00031d08
   13acc:	00031d22 	.word	0x00031d22
   13ad0:	00031d38 	.word	0x00031d38
   13ad4:	00031d56 	.word	0x00031d56
   13ad8:	00031d6c 	.word	0x00031d6c
   13adc:	00031d8a 	.word	0x00031d8a
   13ae0:	00031ca0 	.word	0x00031ca0
   13ae4:	20020d2c 	.word	0x20020d2c

00013ae8 <mqtt_link>:
{
   13ae8:	b570      	push	{r4, r5, r6, lr}
	err = mqtt_connect(&client);
   13aea:	4d4d      	ldr	r5, [pc, #308]	; (13c20 <mqtt_link+0x138>)
	client_init(&client);
   13aec:	f7ff fd2a 	bl	13544 <client_init.constprop.5>
	err = mqtt_connect(&client);
   13af0:	4628      	mov	r0, r5
   13af2:	f01a f8fb 	bl	2dcec <mqtt_connect>
	if(err != 0)
   13af6:	4c4b      	ldr	r4, [pc, #300]	; (13c24 <mqtt_link+0x13c>)
   13af8:	4b4b      	ldr	r3, [pc, #300]	; (13c28 <mqtt_link+0x140>)
   13afa:	4602      	mov	r2, r0
   13afc:	1ae4      	subs	r4, r4, r3
   13afe:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   13b02:	b158      	cbz	r0, 13b1c <mqtt_link+0x34>
		LOG_INF("ERROR: mqtt_connect %d\n", err);
   13b04:	2103      	movs	r1, #3
   13b06:	f04f 0000 	mov.w	r0, #0
   13b0a:	f361 0007 	bfi	r0, r1, #0, #8
   13b0e:	4947      	ldr	r1, [pc, #284]	; (13c2c <mqtt_link+0x144>)
   13b10:	f364 108f 	bfi	r0, r4, #6, #10
}
   13b14:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LOG_INF("ERROR: fds_init %d\n", err);
   13b18:	f019 bbee 	b.w	2d2f8 <log_string_sync>
	if(c->transport.type == MQTT_TRANSPORT_NON_SECURE)
   13b1c:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   13b20:	b153      	cbz	r3, 13b38 <mqtt_link+0x50>
		LOG_INF("ERROR: fds_init %d\n", err);
   13b22:	f04f 0000 	mov.w	r0, #0
   13b26:	2303      	movs	r3, #3
   13b28:	f363 0007 	bfi	r0, r3, #0, #8
   13b2c:	f364 108f 	bfi	r0, r4, #6, #10
   13b30:	f06f 0285 	mvn.w	r2, #133	; 0x85
   13b34:	493e      	ldr	r1, [pc, #248]	; (13c30 <mqtt_link+0x148>)
   13b36:	e7ed      	b.n	13b14 <mqtt_link+0x2c>
		fds.fd = c->transport.tcp.sock;
   13b38:	4e3e      	ldr	r6, [pc, #248]	; (13c34 <mqtt_link+0x14c>)
   13b3a:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   13b3c:	6032      	str	r2, [r6, #0]
	fds.events = POLLIN;
   13b3e:	2201      	movs	r2, #1
   13b40:	80b2      	strh	r2, [r6, #4]
		err = poll(&fds, 1, mqtt_keepalive_time_left(&client));
   13b42:	4628      	mov	r0, r5
   13b44:	f01a f9e6 	bl	2df14 <mqtt_keepalive_time_left>
   13b48:	f7ff fe28 	bl	1379c <poll.constprop.14>
		if(err < 0)
   13b4c:	2800      	cmp	r0, #0
   13b4e:	da2a      	bge.n	13ba6 <mqtt_link+0xbe>
			LOG_INF("ERROR: poll %d\n", errno);
   13b50:	2303      	movs	r3, #3
   13b52:	f04f 0500 	mov.w	r5, #0
   13b56:	f363 0507 	bfi	r5, r3, #0, #8
   13b5a:	f019 fd71 	bl	2d640 <__errno>
   13b5e:	f364 158f 	bfi	r5, r4, #6, #10
   13b62:	6802      	ldr	r2, [r0, #0]
   13b64:	4628      	mov	r0, r5
   13b66:	4934      	ldr	r1, [pc, #208]	; (13c38 <mqtt_link+0x150>)
			LOG_INF("ERROR: mqtt_live %d\n", err);
   13b68:	f019 fbc6 	bl	2d2f8 <log_string_sync>
	LOG_INF("Disconnecting MQTT client...\n");
   13b6c:	2303      	movs	r3, #3
   13b6e:	f04f 0000 	mov.w	r0, #0
   13b72:	f363 0007 	bfi	r0, r3, #0, #8
   13b76:	f364 108f 	bfi	r0, r4, #6, #10
   13b7a:	4930      	ldr	r1, [pc, #192]	; (13c3c <mqtt_link+0x154>)
   13b7c:	f019 fbbc 	bl	2d2f8 <log_string_sync>
	err = mqtt_disconnect(&client);
   13b80:	4827      	ldr	r0, [pc, #156]	; (13c20 <mqtt_link+0x138>)
   13b82:	f01a f925 	bl	2ddd0 <mqtt_disconnect>
	if(err)
   13b86:	4603      	mov	r3, r0
   13b88:	2800      	cmp	r0, #0
   13b8a:	d047      	beq.n	13c1c <mqtt_link+0x134>
		LOG_INF("%s: Could not disconnect MQTT client. Error: %d\n", __func__, err);
   13b8c:	2203      	movs	r2, #3
   13b8e:	f04f 0000 	mov.w	r0, #0
   13b92:	f362 0007 	bfi	r0, r2, #0, #8
   13b96:	f364 108f 	bfi	r0, r4, #6, #10
   13b9a:	4a29      	ldr	r2, [pc, #164]	; (13c40 <mqtt_link+0x158>)
   13b9c:	4929      	ldr	r1, [pc, #164]	; (13c44 <mqtt_link+0x15c>)
}
   13b9e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LOG_INF("%s: Could not disconnect MQTT client. Error: %d\n", __func__, err);
   13ba2:	f019 bba9 	b.w	2d2f8 <log_string_sync>
		err = mqtt_live(&client);
   13ba6:	4628      	mov	r0, r5
   13ba8:	f01a f98d 	bl	2dec6 <mqtt_live>
		if((err != 0) && (err != -EAGAIN))
   13bac:	4602      	mov	r2, r0
   13bae:	b158      	cbz	r0, 13bc8 <mqtt_link+0xe0>
   13bb0:	f110 0f0b 	cmn.w	r0, #11
   13bb4:	d008      	beq.n	13bc8 <mqtt_link+0xe0>
			LOG_INF("ERROR: mqtt_live %d\n", err);
   13bb6:	2103      	movs	r1, #3
   13bb8:	f04f 0000 	mov.w	r0, #0
   13bbc:	f361 0007 	bfi	r0, r1, #0, #8
   13bc0:	f364 108f 	bfi	r0, r4, #6, #10
   13bc4:	4920      	ldr	r1, [pc, #128]	; (13c48 <mqtt_link+0x160>)
   13bc6:	e7cf      	b.n	13b68 <mqtt_link+0x80>
		if((fds.revents & POLLIN) == POLLIN)
   13bc8:	88f3      	ldrh	r3, [r6, #6]
   13bca:	07d9      	lsls	r1, r3, #31
   13bcc:	d50d      	bpl.n	13bea <mqtt_link+0x102>
			err = mqtt_input(&client);
   13bce:	4628      	mov	r0, r5
   13bd0:	f01a f9b7 	bl	2df42 <mqtt_input>
			if(err != 0)
   13bd4:	4602      	mov	r2, r0
   13bd6:	b140      	cbz	r0, 13bea <mqtt_link+0x102>
				LOG_INF("ERROR: mqtt_input %d\n", err);
   13bd8:	2103      	movs	r1, #3
   13bda:	f04f 0000 	mov.w	r0, #0
   13bde:	f361 0007 	bfi	r0, r1, #0, #8
   13be2:	f364 108f 	bfi	r0, r4, #6, #10
   13be6:	4919      	ldr	r1, [pc, #100]	; (13c4c <mqtt_link+0x164>)
   13be8:	e7be      	b.n	13b68 <mqtt_link+0x80>
		if((fds.revents & POLLERR) == POLLERR)
   13bea:	88f3      	ldrh	r3, [r6, #6]
   13bec:	071a      	lsls	r2, r3, #28
   13bee:	d50a      	bpl.n	13c06 <mqtt_link+0x11e>
			LOG_INF("POLLERR\n");
   13bf0:	f04f 0000 	mov.w	r0, #0
   13bf4:	2303      	movs	r3, #3
   13bf6:	4916      	ldr	r1, [pc, #88]	; (13c50 <mqtt_link+0x168>)
   13bf8:	f363 0007 	bfi	r0, r3, #0, #8
   13bfc:	f364 108f 	bfi	r0, r4, #6, #10
			LOG_INF("POLLNVAL\n");
   13c00:	f019 fb7a 	bl	2d2f8 <log_string_sync>
   13c04:	e7b2      	b.n	13b6c <mqtt_link+0x84>
		if((fds.revents & POLLNVAL) == POLLNVAL)
   13c06:	069b      	lsls	r3, r3, #26
   13c08:	d59b      	bpl.n	13b42 <mqtt_link+0x5a>
			LOG_INF("POLLNVAL\n");
   13c0a:	f04f 0000 	mov.w	r0, #0
   13c0e:	2303      	movs	r3, #3
   13c10:	f363 0007 	bfi	r0, r3, #0, #8
   13c14:	f364 108f 	bfi	r0, r4, #6, #10
   13c18:	490e      	ldr	r1, [pc, #56]	; (13c54 <mqtt_link+0x16c>)
   13c1a:	e7f1      	b.n	13c00 <mqtt_link+0x118>
}
   13c1c:	bd70      	pop	{r4, r5, r6, pc}
   13c1e:	bf00      	nop
   13c20:	20020cc8 	.word	0x20020cc8
   13c24:	000304cc 	.word	0x000304cc
   13c28:	0003040c 	.word	0x0003040c
   13c2c:	00031daa 	.word	0x00031daa
   13c30:	00031dc2 	.word	0x00031dc2
   13c34:	20020d2c 	.word	0x20020d2c
   13c38:	00031dd6 	.word	0x00031dd6
   13c3c:	00031cea 	.word	0x00031cea
   13c40:	00031a02 	.word	0x00031a02
   13c44:	00031e24 	.word	0x00031e24
   13c48:	00031de6 	.word	0x00031de6
   13c4c:	00031dfb 	.word	0x00031dfb
   13c50:	00031e11 	.word	0x00031e11
   13c54:	00031e1a 	.word	0x00031e1a

00013c58 <modem_data_init>:

/**brief Initialize LTE status containers. */
void modem_data_init(void)
{
   13c58:	b508      	push	{r3, lr}
	int err;

	err = modem_info_init();
   13c5a:	f009 f9b3 	bl	1cfc4 <modem_info_init>
	if(err)
   13c5e:	4602      	mov	r2, r0
   13c60:	b178      	cbz	r0, 13c82 <modem_data_init+0x2a>
	{
		LOG_INF("Modem info could not be established: %d", err);
   13c62:	2303      	movs	r3, #3
   13c64:	f04f 0000 	mov.w	r0, #0
   13c68:	490a      	ldr	r1, [pc, #40]	; (13c94 <modem_data_init+0x3c>)
   13c6a:	f363 0007 	bfi	r0, r3, #0, #8
   13c6e:	4b0a      	ldr	r3, [pc, #40]	; (13c98 <modem_data_init+0x40>)
   13c70:	1a5b      	subs	r3, r3, r1
   13c72:	08db      	lsrs	r3, r3, #3
   13c74:	f363 108f 	bfi	r0, r3, #6, #10
   13c78:	4908      	ldr	r1, [pc, #32]	; (13c9c <modem_data_init+0x44>)
		return;
	}

	modem_info_params_init(&modem_param);
	modem_info_rsrp_register(modem_rsrp_handler);
}
   13c7a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		LOG_INF("Modem info could not be established: %d", err);
   13c7e:	f019 bb3b 	b.w	2d2f8 <log_string_sync>
	modem_info_params_init(&modem_param);
   13c82:	4807      	ldr	r0, [pc, #28]	; (13ca0 <modem_data_init+0x48>)
   13c84:	f009 f9a4 	bl	1cfd0 <modem_info_params_init>
}
   13c88:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	modem_info_rsrp_register(modem_rsrp_handler);
   13c8c:	4805      	ldr	r0, [pc, #20]	; (13ca4 <modem_data_init+0x4c>)
   13c8e:	f009 b967 	b.w	1cf60 <modem_info_rsrp_register>
   13c92:	bf00      	nop
   13c94:	0003040c 	.word	0x0003040c
   13c98:	000304cc 	.word	0x000304cc
   13c9c:	00031bb8 	.word	0x00031bb8
   13ca0:	200200e0 	.word	0x200200e0
   13ca4:	0001340d 	.word	0x0001340d

00013ca8 <test_nb>:

void test_nb(void)
{
	int err;

	nb_is_running = true;
   13ca8:	2201      	movs	r2, #1
   13caa:	4b6c      	ldr	r3, [pc, #432]	; (13e5c <test_nb+0x1b4>)
{
   13cac:	b570      	push	{r4, r5, r6, lr}
	
	LOG_INF("Start NB-IoT test!\n");
   13cae:	f04f 0000 	mov.w	r0, #0
	nb_is_running = true;
   13cb2:	701a      	strb	r2, [r3, #0]
	LOG_INF("Start NB-IoT test!\n");
   13cb4:	2303      	movs	r3, #3
   13cb6:	4c6a      	ldr	r4, [pc, #424]	; (13e60 <test_nb+0x1b8>)
   13cb8:	f363 0007 	bfi	r0, r3, #0, #8
   13cbc:	4b69      	ldr	r3, [pc, #420]	; (13e64 <test_nb+0x1bc>)
   13cbe:	496a      	ldr	r1, [pc, #424]	; (13e68 <test_nb+0x1c0>)
   13cc0:	1ae4      	subs	r4, r4, r3
   13cc2:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   13cc6:	f364 108f 	bfi	r0, r4, #6, #10
   13cca:	f019 fb15 	bl	2d2f8 <log_string_sync>
	if(at_cmd_write("AT%CESQ=1", NULL, 0, NULL) != 0)
   13cce:	2300      	movs	r3, #0
   13cd0:	4866      	ldr	r0, [pc, #408]	; (13e6c <test_nb+0x1c4>)
   13cd2:	461a      	mov	r2, r3
   13cd4:	4619      	mov	r1, r3
   13cd6:	f008 f98f 	bl	1bff8 <at_cmd_write>
   13cda:	b1e8      	cbz	r0, 13d18 <test_nb+0x70>
		LOG_INF("AT_CMD write fail!\n");
   13cdc:	f04f 0000 	mov.w	r0, #0
   13ce0:	2303      	movs	r3, #3
   13ce2:	4963      	ldr	r1, [pc, #396]	; (13e70 <test_nb+0x1c8>)
   13ce4:	f363 0007 	bfi	r0, r3, #0, #8
   13ce8:	f364 108f 	bfi	r0, r4, #6, #10

	modem_configure();

	client_init(&client);

	err = mqtt_connect(&client);
   13cec:	4d61      	ldr	r5, [pc, #388]	; (13e74 <test_nb+0x1cc>)
		LOG_INF("LTE Link Connected!\n");
   13cee:	f019 fb03 	bl	2d2f8 <log_string_sync>
	client_init(&client);
   13cf2:	f7ff fc27 	bl	13544 <client_init.constprop.5>
	err = mqtt_connect(&client);
   13cf6:	4628      	mov	r0, r5
   13cf8:	f019 fff8 	bl	2dcec <mqtt_connect>
	if(err != 0)
   13cfc:	4602      	mov	r2, r0
   13cfe:	b380      	cbz	r0, 13d62 <test_nb+0xba>
	{
		LOG_INF("ERROR: mqtt_connect %d\n", err);
   13d00:	2103      	movs	r1, #3
   13d02:	f04f 0000 	mov.w	r0, #0
   13d06:	f361 0007 	bfi	r0, r1, #0, #8
   13d0a:	495b      	ldr	r1, [pc, #364]	; (13e78 <test_nb+0x1d0>)
   13d0c:	f364 108f 	bfi	r0, r4, #6, #10
	#ifdef SHOW_LOG_IN_SCREEN	
		sprintf(tmpbuf, "Could not disconnect MQTT client. Error: %d", err);
		show_infor(tmpbuf);
	#endif
	}
}
   13d10:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LOG_INF("Could not disconnect MQTT client. Error: %d\n", err);
   13d14:	f019 baf0 	b.w	2d2f8 <log_string_sync>
		LOG_INF("LTE Link Connecting ...\n");
   13d18:	2303      	movs	r3, #3
   13d1a:	f04f 0000 	mov.w	r0, #0
   13d1e:	f363 0007 	bfi	r0, r3, #0, #8
   13d22:	f364 108f 	bfi	r0, r4, #6, #10
   13d26:	4955      	ldr	r1, [pc, #340]	; (13e7c <test_nb+0x1d4>)
   13d28:	f019 fae6 	bl	2d2f8 <log_string_sync>
		err = lte_lc_init_and_connect();
   13d2c:	f01b f8d5 	bl	2eeda <lte_lc_init_and_connect>
		__ASSERT(err == 0, "LTE link could not be established.");
   13d30:	b170      	cbz	r0, 13d50 <test_nb+0xa8>
   13d32:	4953      	ldr	r1, [pc, #332]	; (13e80 <test_nb+0x1d8>)
   13d34:	f240 23f3 	movw	r3, #755	; 0x2f3
   13d38:	4a52      	ldr	r2, [pc, #328]	; (13e84 <test_nb+0x1dc>)
   13d3a:	4853      	ldr	r0, [pc, #332]	; (13e88 <test_nb+0x1e0>)
   13d3c:	f019 fa85 	bl	2d24a <printk>
   13d40:	4852      	ldr	r0, [pc, #328]	; (13e8c <test_nb+0x1e4>)
   13d42:	f019 fa82 	bl	2d24a <printk>
   13d46:	f240 21f3 	movw	r1, #755	; 0x2f3
   13d4a:	484e      	ldr	r0, [pc, #312]	; (13e84 <test_nb+0x1dc>)
   13d4c:	f019 fac3 	bl	2d2d6 <assert_post_action>
		LOG_INF("LTE Link Connected!\n");
   13d50:	f04f 0000 	mov.w	r0, #0
   13d54:	2303      	movs	r3, #3
   13d56:	f363 0007 	bfi	r0, r3, #0, #8
   13d5a:	f364 108f 	bfi	r0, r4, #6, #10
   13d5e:	494c      	ldr	r1, [pc, #304]	; (13e90 <test_nb+0x1e8>)
   13d60:	e7c4      	b.n	13cec <test_nb+0x44>
	if(c->transport.type == MQTT_TRANSPORT_NON_SECURE)
   13d62:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   13d66:	b153      	cbz	r3, 13d7e <test_nb+0xd6>
		LOG_INF("ERROR: fds_init %d\n", err);
   13d68:	f04f 0000 	mov.w	r0, #0
   13d6c:	2303      	movs	r3, #3
   13d6e:	f363 0007 	bfi	r0, r3, #0, #8
   13d72:	f364 108f 	bfi	r0, r4, #6, #10
   13d76:	f06f 0285 	mvn.w	r2, #133	; 0x85
   13d7a:	4946      	ldr	r1, [pc, #280]	; (13e94 <test_nb+0x1ec>)
   13d7c:	e7c8      	b.n	13d10 <test_nb+0x68>
		fds.fd = c->transport.tcp.sock;
   13d7e:	4e46      	ldr	r6, [pc, #280]	; (13e98 <test_nb+0x1f0>)
   13d80:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   13d82:	6032      	str	r2, [r6, #0]
	fds.events = POLLIN;
   13d84:	2201      	movs	r2, #1
   13d86:	80b2      	strh	r2, [r6, #4]
		err = poll(&fds, 1, mqtt_keepalive_time_left(&client));
   13d88:	4628      	mov	r0, r5
   13d8a:	f01a f8c3 	bl	2df14 <mqtt_keepalive_time_left>
   13d8e:	f7ff fd05 	bl	1379c <poll.constprop.14>
		if(err < 0)
   13d92:	2800      	cmp	r0, #0
   13d94:	da26      	bge.n	13de4 <test_nb+0x13c>
			LOG_INF("ERROR: poll %d\n", errno);
   13d96:	2303      	movs	r3, #3
   13d98:	f04f 0500 	mov.w	r5, #0
   13d9c:	f363 0507 	bfi	r5, r3, #0, #8
   13da0:	f019 fc4e 	bl	2d640 <__errno>
   13da4:	f364 158f 	bfi	r5, r4, #6, #10
   13da8:	6802      	ldr	r2, [r0, #0]
   13daa:	4628      	mov	r0, r5
   13dac:	493b      	ldr	r1, [pc, #236]	; (13e9c <test_nb+0x1f4>)
			LOG_INF("ERROR: mqtt_live %d\n", err);
   13dae:	f019 faa3 	bl	2d2f8 <log_string_sync>
	LOG_INF("Disconnecting MQTT client...\n");
   13db2:	2303      	movs	r3, #3
   13db4:	f04f 0000 	mov.w	r0, #0
   13db8:	f363 0007 	bfi	r0, r3, #0, #8
   13dbc:	f364 108f 	bfi	r0, r4, #6, #10
   13dc0:	4937      	ldr	r1, [pc, #220]	; (13ea0 <test_nb+0x1f8>)
   13dc2:	f019 fa99 	bl	2d2f8 <log_string_sync>
	err = mqtt_disconnect(&client);
   13dc6:	482b      	ldr	r0, [pc, #172]	; (13e74 <test_nb+0x1cc>)
   13dc8:	f01a f802 	bl	2ddd0 <mqtt_disconnect>
	if(err)
   13dcc:	4602      	mov	r2, r0
   13dce:	2800      	cmp	r0, #0
   13dd0:	d043      	beq.n	13e5a <test_nb+0x1b2>
		LOG_INF("Could not disconnect MQTT client. Error: %d\n", err);
   13dd2:	2103      	movs	r1, #3
   13dd4:	f04f 0000 	mov.w	r0, #0
   13dd8:	f361 0007 	bfi	r0, r1, #0, #8
   13ddc:	f364 108f 	bfi	r0, r4, #6, #10
   13de0:	4930      	ldr	r1, [pc, #192]	; (13ea4 <test_nb+0x1fc>)
   13de2:	e795      	b.n	13d10 <test_nb+0x68>
		err = mqtt_live(&client);
   13de4:	4628      	mov	r0, r5
   13de6:	f01a f86e 	bl	2dec6 <mqtt_live>
		if((err != 0) && (err != -EAGAIN))
   13dea:	4602      	mov	r2, r0
   13dec:	b158      	cbz	r0, 13e06 <test_nb+0x15e>
   13dee:	f110 0f0b 	cmn.w	r0, #11
   13df2:	d008      	beq.n	13e06 <test_nb+0x15e>
			LOG_INF("ERROR: mqtt_live %d\n", err);
   13df4:	2103      	movs	r1, #3
   13df6:	f04f 0000 	mov.w	r0, #0
   13dfa:	f361 0007 	bfi	r0, r1, #0, #8
   13dfe:	f364 108f 	bfi	r0, r4, #6, #10
   13e02:	4929      	ldr	r1, [pc, #164]	; (13ea8 <test_nb+0x200>)
   13e04:	e7d3      	b.n	13dae <test_nb+0x106>
		if((fds.revents & POLLIN) == POLLIN)
   13e06:	88f3      	ldrh	r3, [r6, #6]
   13e08:	07d9      	lsls	r1, r3, #31
   13e0a:	d50d      	bpl.n	13e28 <test_nb+0x180>
			err = mqtt_input(&client);
   13e0c:	4628      	mov	r0, r5
   13e0e:	f01a f898 	bl	2df42 <mqtt_input>
			if(err != 0)
   13e12:	4602      	mov	r2, r0
   13e14:	b140      	cbz	r0, 13e28 <test_nb+0x180>
				LOG_INF("ERROR: mqtt_input %d\n", err);
   13e16:	2103      	movs	r1, #3
   13e18:	f04f 0000 	mov.w	r0, #0
   13e1c:	f361 0007 	bfi	r0, r1, #0, #8
   13e20:	f364 108f 	bfi	r0, r4, #6, #10
   13e24:	4921      	ldr	r1, [pc, #132]	; (13eac <test_nb+0x204>)
   13e26:	e7c2      	b.n	13dae <test_nb+0x106>
		if((fds.revents & POLLERR) == POLLERR)
   13e28:	88f3      	ldrh	r3, [r6, #6]
   13e2a:	071a      	lsls	r2, r3, #28
   13e2c:	d50a      	bpl.n	13e44 <test_nb+0x19c>
			LOG_INF("POLLERR\n");
   13e2e:	f04f 0000 	mov.w	r0, #0
   13e32:	2303      	movs	r3, #3
   13e34:	491e      	ldr	r1, [pc, #120]	; (13eb0 <test_nb+0x208>)
   13e36:	f363 0007 	bfi	r0, r3, #0, #8
   13e3a:	f364 108f 	bfi	r0, r4, #6, #10
			LOG_INF("POLLNVAL\n");
   13e3e:	f019 fa5b 	bl	2d2f8 <log_string_sync>
   13e42:	e7b6      	b.n	13db2 <test_nb+0x10a>
		if((fds.revents & POLLNVAL) == POLLNVAL)
   13e44:	069b      	lsls	r3, r3, #26
   13e46:	d59f      	bpl.n	13d88 <test_nb+0xe0>
			LOG_INF("POLLNVAL\n");
   13e48:	f04f 0000 	mov.w	r0, #0
   13e4c:	2303      	movs	r3, #3
   13e4e:	f363 0007 	bfi	r0, r3, #0, #8
   13e52:	f364 108f 	bfi	r0, r4, #6, #10
   13e56:	4917      	ldr	r1, [pc, #92]	; (13eb4 <test_nb+0x20c>)
   13e58:	e7f1      	b.n	13e3e <test_nb+0x196>
}
   13e5a:	bd70      	pop	{r4, r5, r6, pc}
   13e5c:	2002fc96 	.word	0x2002fc96
   13e60:	000304cc 	.word	0x000304cc
   13e64:	0003040c 	.word	0x0003040c
   13e68:	00031eb6 	.word	0x00031eb6
   13e6c:	00031eca 	.word	0x00031eca
   13e70:	00031ed4 	.word	0x00031ed4
   13e74:	20020cc8 	.word	0x20020cc8
   13e78:	00031daa 	.word	0x00031daa
   13e7c:	00031ee8 	.word	0x00031ee8
   13e80:	00031f10 	.word	0x00031f10
   13e84:	00031f01 	.word	0x00031f01
   13e88:	000311a3 	.word	0x000311a3
   13e8c:	00031f19 	.word	0x00031f19
   13e90:	00031f3e 	.word	0x00031f3e
   13e94:	00031dc2 	.word	0x00031dc2
   13e98:	20020d2c 	.word	0x20020d2c
   13e9c:	00031dd6 	.word	0x00031dd6
   13ea0:	00031cea 	.word	0x00031cea
   13ea4:	00031e28 	.word	0x00031e28
   13ea8:	00031de6 	.word	0x00031de6
   13eac:	00031dfb 	.word	0x00031dfb
   13eb0:	00031e11 	.word	0x00031e11
   13eb4:	00031e1a 	.word	0x00031e1a

00013eb8 <GetModemDateTime>:
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
	}
}

void GetModemDateTime(void)
{
   13eb8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13ebc:	b0aa      	sub	sp, #168	; 0xa8
	char *ptr;
	u8_t timebuf[128] = {0};
   13ebe:	2280      	movs	r2, #128	; 0x80
   13ec0:	2100      	movs	r1, #0
   13ec2:	a80a      	add	r0, sp, #40	; 0x28
   13ec4:	f01b fa66 	bl	2f394 <memset>
	u8_t tmpbuf[10] = {0};
   13ec8:	2300      	movs	r3, #0
	u8_t tz_dir[2],tz_count,daylight;

	if(at_cmd_write("AT%CCLK?", timebuf, sizeof(timebuf), NULL) != 0)
   13eca:	2280      	movs	r2, #128	; 0x80
   13ecc:	a90a      	add	r1, sp, #40	; 0x28
   13ece:	485e      	ldr	r0, [pc, #376]	; (14048 <GetModemDateTime+0x190>)
	u8_t tmpbuf[10] = {0};
   13ed0:	e9cd 3307 	strd	r3, r3, [sp, #28]
   13ed4:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	if(at_cmd_write("AT%CCLK?", timebuf, sizeof(timebuf), NULL) != 0)
   13ed8:	f008 f88e 	bl	1bff8 <at_cmd_write>
   13edc:	4f5b      	ldr	r7, [pc, #364]	; (1404c <GetModemDateTime+0x194>)
   13ede:	4b5c      	ldr	r3, [pc, #368]	; (14050 <GetModemDateTime+0x198>)
   13ee0:	4605      	mov	r5, r0
   13ee2:	1aff      	subs	r7, r7, r3
	{
		LOG_INF("Get CCLK fail!\n");
   13ee4:	f04f 0000 	mov.w	r0, #0
   13ee8:	2303      	movs	r3, #3
   13eea:	f3c7 07c9 	ubfx	r7, r7, #3, #10
   13eee:	f363 0007 	bfi	r0, r3, #0, #8
   13ef2:	f367 108f 	bfi	r0, r7, #6, #10
	if(at_cmd_write("AT%CCLK?", timebuf, sizeof(timebuf), NULL) != 0)
   13ef6:	b12d      	cbz	r5, 13f04 <GetModemDateTime+0x4c>
		LOG_INF("Get CCLK fail!\n");
   13ef8:	4956      	ldr	r1, [pc, #344]	; (14054 <GetModemDateTime+0x19c>)
   13efa:	f019 f9fd 	bl	2d2f8 <log_string_sync>
					date_time.hour,date_time.minute,date_time.second,
					date_time.week);

	RedrawSystemTime();
	SaveSystemDateTime();
}
   13efe:	b02a      	add	sp, #168	; 0xa8
   13f00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	LOG_INF("%s\n", timebuf);
   13f04:	aa0a      	add	r2, sp, #40	; 0x28
   13f06:	4954      	ldr	r1, [pc, #336]	; (14058 <GetModemDateTime+0x1a0>)
   13f08:	f019 f9f6 	bl	2d2f8 <log_string_sync>
	ptr = strstr(timebuf, "\"");
   13f0c:	4953      	ldr	r1, [pc, #332]	; (1405c <GetModemDateTime+0x1a4>)
   13f0e:	a80a      	add	r0, sp, #40	; 0x28
   13f10:	f01b fbee 	bl	2f6f0 <strstr>
	if(ptr)
   13f14:	4c52      	ldr	r4, [pc, #328]	; (14060 <GetModemDateTime+0x1a8>)
   13f16:	4606      	mov	r6, r0
   13f18:	2800      	cmp	r0, #0
   13f1a:	d06f      	beq.n	13ffc <GetModemDateTime+0x144>
		memcpy(tmpbuf, ptr, 2);
   13f1c:	f8b0 3001 	ldrh.w	r3, [r0, #1]
		date_time.year = 2000+atoi(tmpbuf);
   13f20:	a807      	add	r0, sp, #28
		memcpy(tmpbuf, ptr, 2);
   13f22:	f8ad 301c 	strh.w	r3, [sp, #28]
		date_time.year = 2000+atoi(tmpbuf);
   13f26:	f01b f9f5 	bl	2f314 <atoi>
		memset(tmpbuf, 0, sizeof(tmpbuf));
   13f2a:	e9cd 5507 	strd	r5, r5, [sp, #28]
   13f2e:	f8ad 5024 	strh.w	r5, [sp, #36]	; 0x24
		memcpy(tmpbuf, ptr, 2);
   13f32:	88b3      	ldrh	r3, [r6, #4]
		date_time.year = 2000+atoi(tmpbuf);
   13f34:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
   13f38:	8020      	strh	r0, [r4, #0]
		date_time.month= atoi(tmpbuf);
   13f3a:	a807      	add	r0, sp, #28
		memcpy(tmpbuf, ptr, 2);
   13f3c:	f8ad 301c 	strh.w	r3, [sp, #28]
		date_time.month= atoi(tmpbuf);
   13f40:	f01b f9e8 	bl	2f314 <atoi>
		memset(tmpbuf, 0, sizeof(tmpbuf));
   13f44:	e9cd 5507 	strd	r5, r5, [sp, #28]
   13f48:	f8ad 5024 	strh.w	r5, [sp, #36]	; 0x24
		memcpy(tmpbuf, ptr, 2);
   13f4c:	f8b6 3007 	ldrh.w	r3, [r6, #7]
		date_time.month= atoi(tmpbuf);
   13f50:	70a0      	strb	r0, [r4, #2]
		date_time.day = atoi(tmpbuf);
   13f52:	a807      	add	r0, sp, #28
		memcpy(tmpbuf, ptr, 2);
   13f54:	f8ad 301c 	strh.w	r3, [sp, #28]
		date_time.day = atoi(tmpbuf);
   13f58:	f01b f9dc 	bl	2f314 <atoi>
		memset(tmpbuf, 0, sizeof(tmpbuf));
   13f5c:	f8cd 5022 	str.w	r5, [sp, #34]	; 0x22
		memcpy(tmpbuf, ptr, 2);
   13f60:	8973      	ldrh	r3, [r6, #10]
		date_time.day = atoi(tmpbuf);
   13f62:	70e0      	strb	r0, [r4, #3]
		date_time.hour = atoi(tmpbuf);
   13f64:	a807      	add	r0, sp, #28
		memcpy(tmpbuf, ptr, 2);
   13f66:	f8ad 301c 	strh.w	r3, [sp, #28]
		memset(tmpbuf, 0, sizeof(tmpbuf));
   13f6a:	f8cd 501e 	str.w	r5, [sp, #30]
		date_time.hour = atoi(tmpbuf);
   13f6e:	f01b f9d1 	bl	2f314 <atoi>
		memset(tmpbuf, 0, sizeof(tmpbuf));
   13f72:	f8cd 5022 	str.w	r5, [sp, #34]	; 0x22
		memcpy(tmpbuf, ptr, 2);
   13f76:	f8b6 300d 	ldrh.w	r3, [r6, #13]
		date_time.hour = atoi(tmpbuf);
   13f7a:	7120      	strb	r0, [r4, #4]
		date_time.minute = atoi(tmpbuf);
   13f7c:	a807      	add	r0, sp, #28
		memcpy(tmpbuf, ptr, 2);
   13f7e:	f8ad 301c 	strh.w	r3, [sp, #28]
		memset(tmpbuf, 0, sizeof(tmpbuf));
   13f82:	f8cd 501e 	str.w	r5, [sp, #30]
		date_time.minute = atoi(tmpbuf);
   13f86:	f01b f9c5 	bl	2f314 <atoi>
		memcpy(tmpbuf, ptr, 2);
   13f8a:	8a33      	ldrh	r3, [r6, #16]
		date_time.minute = atoi(tmpbuf);
   13f8c:	7160      	strb	r0, [r4, #5]
		date_time.second = atoi(tmpbuf);
   13f8e:	a807      	add	r0, sp, #28
		memcpy(tmpbuf, ptr, 2);
   13f90:	f8ad 301c 	strh.w	r3, [sp, #28]
		memset(tmpbuf, 0, sizeof(tmpbuf));
   13f94:	f8cd 501e 	str.w	r5, [sp, #30]
   13f98:	f8cd 5022 	str.w	r5, [sp, #34]	; 0x22
		date_time.second = atoi(tmpbuf);
   13f9c:	f01b f9ba 	bl	2f314 <atoi>
		memcpy(tz_dir, ptr, 1);
   13fa0:	f896 8012 	ldrb.w	r8, [r6, #18]
		memcpy(tmpbuf, ptr, 2);
   13fa4:	f8b6 3013 	ldrh.w	r3, [r6, #19]
		date_time.second = atoi(tmpbuf);
   13fa8:	71a0      	strb	r0, [r4, #6]
		tz_count = atoi(tmpbuf);
   13faa:	a807      	add	r0, sp, #28
		memset(tmpbuf, 0, sizeof(tmpbuf));
   13fac:	f8cd 501e 	str.w	r5, [sp, #30]
   13fb0:	f8cd 5022 	str.w	r5, [sp, #34]	; 0x22
		memcpy(tmpbuf, ptr, 2);
   13fb4:	f8ad 301c 	strh.w	r3, [sp, #28]
		tz_count = atoi(tmpbuf);
   13fb8:	f01b f9ac 	bl	2f314 <atoi>
		if(tz_dir[0] == '+')
   13fbc:	f1b8 0f2b 	cmp.w	r8, #43	; 0x2b
   13fc0:	d137      	bne.n	14032 <GetModemDateTime+0x17a>
			TimeIncrease(&date_time, tz_count*15);
   13fc2:	b2c1      	uxtb	r1, r0
   13fc4:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
   13fc8:	4620      	mov	r0, r4
   13fca:	f7fc f99b 	bl	10304 <TimeIncrease>
		ptr = strstr(ptr, ",");
   13fce:	4925      	ldr	r1, [pc, #148]	; (14064 <GetModemDateTime+0x1ac>)
   13fd0:	f106 0016 	add.w	r0, r6, #22
   13fd4:	f01b fb8c 	bl	2f6f0 <strstr>
		if(ptr)
   13fd8:	b180      	cbz	r0, 13ffc <GetModemDateTime+0x144>
			memset(tmpbuf, 0, sizeof(tmpbuf));
   13fda:	2300      	movs	r3, #0
   13fdc:	e9cd 3307 	strd	r3, r3, [sp, #28]
   13fe0:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
			memcpy(tmpbuf, ptr, 1);
   13fe4:	7843      	ldrb	r3, [r0, #1]
			daylight = atoi(tmpbuf);
   13fe6:	a807      	add	r0, sp, #28
			memcpy(tmpbuf, ptr, 1);
   13fe8:	f88d 301c 	strb.w	r3, [sp, #28]
			daylight = atoi(tmpbuf);
   13fec:	f01b f992 	bl	2f314 <atoi>
			TimeDecrease(&date_time, daylight*60);
   13ff0:	213c      	movs	r1, #60	; 0x3c
   13ff2:	b2c0      	uxtb	r0, r0
   13ff4:	4341      	muls	r1, r0
   13ff6:	481a      	ldr	r0, [pc, #104]	; (14060 <GetModemDateTime+0x1a8>)
   13ff8:	f7fc f9e0 	bl	103bc <TimeDecrease>
	LOG_INF("real time:%04d/%02d/%02d,%02d:%02d:%02d,%02d\n", 
   13ffc:	2303      	movs	r3, #3
   13ffe:	f04f 0000 	mov.w	r0, #0
   14002:	f363 0007 	bfi	r0, r3, #0, #8
   14006:	79e3      	ldrb	r3, [r4, #7]
   14008:	f367 108f 	bfi	r0, r7, #6, #10
   1400c:	9304      	str	r3, [sp, #16]
   1400e:	79a3      	ldrb	r3, [r4, #6]
   14010:	8822      	ldrh	r2, [r4, #0]
   14012:	9303      	str	r3, [sp, #12]
   14014:	7963      	ldrb	r3, [r4, #5]
   14016:	4914      	ldr	r1, [pc, #80]	; (14068 <GetModemDateTime+0x1b0>)
   14018:	9302      	str	r3, [sp, #8]
   1401a:	7923      	ldrb	r3, [r4, #4]
   1401c:	9301      	str	r3, [sp, #4]
   1401e:	78e3      	ldrb	r3, [r4, #3]
   14020:	9300      	str	r3, [sp, #0]
   14022:	78a3      	ldrb	r3, [r4, #2]
   14024:	f019 f968 	bl	2d2f8 <log_string_sync>
	RedrawSystemTime();
   14028:	f7fc fa06 	bl	10438 <RedrawSystemTime>
	SaveSystemDateTime();
   1402c:	f7fd fcec 	bl	11a08 <SaveSystemDateTime>
   14030:	e765      	b.n	13efe <GetModemDateTime+0x46>
		else if(tz_dir[0] == '-')
   14032:	f1b8 0f2d 	cmp.w	r8, #45	; 0x2d
   14036:	d1ca      	bne.n	13fce <GetModemDateTime+0x116>
			TimeDecrease(&date_time, tz_count*15);
   14038:	b2c1      	uxtb	r1, r0
   1403a:	ebc1 1101 	rsb	r1, r1, r1, lsl #4
   1403e:	4620      	mov	r0, r4
   14040:	f7fc f9bc 	bl	103bc <TimeDecrease>
   14044:	e7c3      	b.n	13fce <GetModemDateTime+0x116>
   14046:	bf00      	nop
   14048:	00031854 	.word	0x00031854
   1404c:	000304cc 	.word	0x000304cc
   14050:	0003040c 	.word	0x0003040c
   14054:	0003185d 	.word	0x0003185d
   14058:	00033a55 	.word	0x00033a55
   1405c:	0003186d 	.word	0x0003186d
   14060:	2002d410 	.word	0x2002d410
   14064:	00031993 	.word	0x00031993
   14068:	0003186f 	.word	0x0003186f

0001406c <MqttSendData>:

void MqttSendData(u8_t *data, u32_t datalen)
{
   1406c:	b538      	push	{r3, r4, r5, lr}
	int ret;

	ret = add_data_into_cache(data, datalen);
   1406e:	f000 fb61 	bl	14734 <add_data_into_cache>
	LOG_INF("%s: data add ret:%d\n", __func__, ret);
   14072:	f04f 0500 	mov.w	r5, #0
   14076:	2303      	movs	r3, #3
   14078:	4c17      	ldr	r4, [pc, #92]	; (140d8 <MqttSendData+0x6c>)
   1407a:	f363 0507 	bfi	r5, r3, #0, #8
   1407e:	4b17      	ldr	r3, [pc, #92]	; (140dc <MqttSendData+0x70>)
   14080:	4a17      	ldr	r2, [pc, #92]	; (140e0 <MqttSendData+0x74>)
   14082:	1ae4      	subs	r4, r4, r3
   14084:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   14088:	f364 158f 	bfi	r5, r4, #6, #10
   1408c:	4603      	mov	r3, r0
   1408e:	4915      	ldr	r1, [pc, #84]	; (140e4 <MqttSendData+0x78>)
   14090:	4628      	mov	r0, r5
   14092:	f019 f931 	bl	2d2f8 <log_string_sync>
	
	if(mqtt_connected)
   14096:	4b14      	ldr	r3, [pc, #80]	; (140e8 <MqttSendData+0x7c>)
	{
		LOG_INF("%s: begin 001\n", __func__);
   14098:	f04f 0000 	mov.w	r0, #0
	if(mqtt_connected)
   1409c:	781d      	ldrb	r5, [r3, #0]
		LOG_INF("%s: begin 001\n", __func__);
   1409e:	2303      	movs	r3, #3
   140a0:	f363 0007 	bfi	r0, r3, #0, #8
   140a4:	f364 108f 	bfi	r0, r4, #6, #10
   140a8:	4a0d      	ldr	r2, [pc, #52]	; (140e0 <MqttSendData+0x74>)
	if(mqtt_connected)
   140aa:	b155      	cbz	r5, 140c2 <MqttSendData+0x56>
		LOG_INF("%s: begin 001\n", __func__);
   140ac:	490f      	ldr	r1, [pc, #60]	; (140ec <MqttSendData+0x80>)
   140ae:	f019 f923 	bl	2d2f8 <log_string_sync>
	{
		LOG_INF("%s: begin 002\n", __func__);

		k_delayed_work_submit_to_queue(app_work_q, &mqtt_link_work, K_NO_WAIT);
	}
}
   140b2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_timer_start(timer, duration, period);
   140b6:	2200      	movs	r2, #0
   140b8:	f241 3188 	movw	r1, #5000	; 0x1388
   140bc:	480c      	ldr	r0, [pc, #48]	; (140f0 <MqttSendData+0x84>)
   140be:	f015 b8c1 	b.w	29244 <z_impl_k_timer_start>
		LOG_INF("%s: begin 002\n", __func__);
   140c2:	490c      	ldr	r1, [pc, #48]	; (140f4 <MqttSendData+0x88>)
   140c4:	f019 f918 	bl	2d2f8 <log_string_sync>
		k_delayed_work_submit_to_queue(app_work_q, &mqtt_link_work, K_NO_WAIT);
   140c8:	4b0b      	ldr	r3, [pc, #44]	; (140f8 <MqttSendData+0x8c>)
   140ca:	462a      	mov	r2, r5
   140cc:	6818      	ldr	r0, [r3, #0]
   140ce:	490b      	ldr	r1, [pc, #44]	; (140fc <MqttSendData+0x90>)
}
   140d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		k_delayed_work_submit_to_queue(app_work_q, &mqtt_link_work, K_NO_WAIT);
   140d4:	f014 bcdc 	b.w	28a90 <k_delayed_work_submit_to_queue>
   140d8:	000304cc 	.word	0x000304cc
   140dc:	0003040c 	.word	0x0003040c
   140e0:	00031a50 	.word	0x00031a50
   140e4:	0003190b 	.word	0x0003190b
   140e8:	2002fc94 	.word	0x2002fc94
   140ec:	00031920 	.word	0x00031920
   140f0:	2003b768 	.word	0x2003b768
   140f4:	0003192f 	.word	0x0003192f
   140f8:	20020cc4 	.word	0x20020cc4
   140fc:	20020d34 	.word	0x20020d34

00014100 <NBSendSosWifiData>:

void NBSendSosWifiData(u8_t *data, u32_t datalen)
{
   14100:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u8_t buf[128] = {0};
   14104:	2480      	movs	r4, #128	; 0x80
{
   14106:	b0a2      	sub	sp, #136	; 0x88
   14108:	4607      	mov	r7, r0
   1410a:	4688      	mov	r8, r1
	u8_t buf[128] = {0};
   1410c:	4622      	mov	r2, r4
   1410e:	2100      	movs	r1, #0
   14110:	a802      	add	r0, sp, #8
   14112:	f01b f93f 	bl	2f394 <memset>
	u8_t tmpbuf[128] = {0};
	
	LOG_INF("[%s] wifi data:%s len:%d\n", __func__, data, datalen);
   14116:	2303      	movs	r3, #3
   14118:	f04f 0000 	mov.w	r0, #0
   1411c:	4d24      	ldr	r5, [pc, #144]	; (141b0 <NBSendSosWifiData+0xb0>)
   1411e:	f363 0007 	bfi	r0, r3, #0, #8
   14122:	4b24      	ldr	r3, [pc, #144]	; (141b4 <NBSendSosWifiData+0xb4>)
   14124:	4e24      	ldr	r6, [pc, #144]	; (141b8 <NBSendSosWifiData+0xb8>)
   14126:	1aed      	subs	r5, r5, r3
   14128:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   1412c:	463b      	mov	r3, r7
   1412e:	4632      	mov	r2, r6
   14130:	f365 108f 	bfi	r0, r5, #6, #10
   14134:	f8cd 8000 	str.w	r8, [sp]
   14138:	4920      	ldr	r1, [pc, #128]	; (141bc <NBSendSosWifiData+0xbc>)
   1413a:	f019 f8dd 	bl	2d2f8 <log_string_sync>

	strcpy(buf, "{1:1:0:0:");
   1413e:	4920      	ldr	r1, [pc, #128]	; (141c0 <NBSendSosWifiData+0xc0>)
   14140:	a802      	add	r0, sp, #8
   14142:	f01b faa8 	bl	2f696 <strcpy>
	strcat(buf, g_imei);
   14146:	4622      	mov	r2, r4
   14148:	491e      	ldr	r1, [pc, #120]	; (141c4 <NBSendSosWifiData+0xc4>)
   1414a:	a802      	add	r0, sp, #8
   1414c:	f01b fa7e 	bl	2f64c <__strcat_chk>
	strcat(buf, ":T1:");
   14150:	4622      	mov	r2, r4
   14152:	491d      	ldr	r1, [pc, #116]	; (141c8 <NBSendSosWifiData+0xc8>)
   14154:	a802      	add	r0, sp, #8
   14156:	f01b fa79 	bl	2f64c <__strcat_chk>
	strcat(buf, data);
   1415a:	4622      	mov	r2, r4
   1415c:	4639      	mov	r1, r7
   1415e:	a802      	add	r0, sp, #8
   14160:	f01b fa74 	bl	2f64c <__strcat_chk>
	strcat(buf, ",");
   14164:	4622      	mov	r2, r4
   14166:	4919      	ldr	r1, [pc, #100]	; (141cc <NBSendSosWifiData+0xcc>)
   14168:	a802      	add	r0, sp, #8
   1416a:	f01b fa6f 	bl	2f64c <__strcat_chk>
	strcat(buf, sos_trigger_time);
   1416e:	4622      	mov	r2, r4
   14170:	4917      	ldr	r1, [pc, #92]	; (141d0 <NBSendSosWifiData+0xd0>)
   14172:	a802      	add	r0, sp, #8
   14174:	f01b fa6a 	bl	2f64c <__strcat_chk>
	strcat(buf, "}");
   14178:	4622      	mov	r2, r4
   1417a:	4916      	ldr	r1, [pc, #88]	; (141d4 <NBSendSosWifiData+0xd4>)
   1417c:	a802      	add	r0, sp, #8
   1417e:	f01b fa65 	bl	2f64c <__strcat_chk>

	LOG_INF("[%s] sos wifi data:%s\n", __func__, buf);
   14182:	2303      	movs	r3, #3
   14184:	f04f 0000 	mov.w	r0, #0
   14188:	f363 0007 	bfi	r0, r3, #0, #8
   1418c:	4632      	mov	r2, r6
   1418e:	ab02      	add	r3, sp, #8
   14190:	f365 108f 	bfi	r0, r5, #6, #10
   14194:	4910      	ldr	r1, [pc, #64]	; (141d8 <NBSendSosWifiData+0xd8>)
   14196:	f019 f8af 	bl	2d2f8 <log_string_sync>
	MqttSendData(buf, strlen(buf));
   1419a:	a802      	add	r0, sp, #8
   1419c:	f7f8 fedc 	bl	cf58 <strlen>
   141a0:	4601      	mov	r1, r0
   141a2:	a802      	add	r0, sp, #8
   141a4:	f7ff ff62 	bl	1406c <MqttSendData>
}
   141a8:	b022      	add	sp, #136	; 0x88
   141aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   141ae:	bf00      	nop
   141b0:	000304cc 	.word	0x000304cc
   141b4:	0003040c 	.word	0x0003040c
   141b8:	00031a5d 	.word	0x00031a5d
   141bc:	000319b1 	.word	0x000319b1
   141c0:	000319cb 	.word	0x000319cb
   141c4:	2002fc73 	.word	0x2002fc73
   141c8:	000319d5 	.word	0x000319d5
   141cc:	00031993 	.word	0x00031993
   141d0:	2003006a 	.word	0x2003006a
   141d4:	00031999 	.word	0x00031999
   141d8:	000319da 	.word	0x000319da

000141dc <NBSendSosGpsData>:

void NBSendSosGpsData(u8_t *data, u32_t datalen)
{
   141dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u8_t buf[128] = {0};
   141e0:	2480      	movs	r4, #128	; 0x80
{
   141e2:	b0c2      	sub	sp, #264	; 0x108
   141e4:	4607      	mov	r7, r0
   141e6:	4688      	mov	r8, r1
	u8_t buf[128] = {0};
   141e8:	4622      	mov	r2, r4
   141ea:	2100      	movs	r1, #0
   141ec:	a802      	add	r0, sp, #8
   141ee:	f01b f8d1 	bl	2f394 <memset>
	u8_t tmpbuf[128] = {0};
   141f2:	4622      	mov	r2, r4
   141f4:	2100      	movs	r1, #0
   141f6:	a822      	add	r0, sp, #136	; 0x88
   141f8:	f01b f8cc 	bl	2f394 <memset>
	
	LOG_INF("[%s] gps data:%s len:%d\n", __func__, data, datalen);
   141fc:	2303      	movs	r3, #3
   141fe:	f04f 0000 	mov.w	r0, #0
   14202:	4d23      	ldr	r5, [pc, #140]	; (14290 <NBSendSosGpsData+0xb4>)
   14204:	f363 0007 	bfi	r0, r3, #0, #8
   14208:	4b22      	ldr	r3, [pc, #136]	; (14294 <NBSendSosGpsData+0xb8>)
   1420a:	4e23      	ldr	r6, [pc, #140]	; (14298 <NBSendSosGpsData+0xbc>)
   1420c:	1aed      	subs	r5, r5, r3
   1420e:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   14212:	463b      	mov	r3, r7
   14214:	4632      	mov	r2, r6
   14216:	f365 108f 	bfi	r0, r5, #6, #10
   1421a:	f8cd 8000 	str.w	r8, [sp]
   1421e:	491f      	ldr	r1, [pc, #124]	; (1429c <NBSendSosGpsData+0xc0>)
   14220:	f019 f86a 	bl	2d2f8 <log_string_sync>

	strcpy(buf, "{T2,");
   14224:	491e      	ldr	r1, [pc, #120]	; (142a0 <NBSendSosGpsData+0xc4>)
   14226:	a802      	add	r0, sp, #8
   14228:	f01b fa35 	bl	2f696 <strcpy>
	strcat(buf, g_imei);
   1422c:	4622      	mov	r2, r4
   1422e:	491d      	ldr	r1, [pc, #116]	; (142a4 <NBSendSosGpsData+0xc8>)
   14230:	a802      	add	r0, sp, #8
   14232:	f01b fa0b 	bl	2f64c <__strcat_chk>
	strcat(buf, ",[");
   14236:	4622      	mov	r2, r4
   14238:	491b      	ldr	r1, [pc, #108]	; (142a8 <NBSendSosGpsData+0xcc>)
   1423a:	a802      	add	r0, sp, #8
   1423c:	f01b fa06 	bl	2f64c <__strcat_chk>
	strcat(buf, data);
   14240:	4622      	mov	r2, r4
   14242:	4639      	mov	r1, r7
   14244:	a802      	add	r0, sp, #8
   14246:	f01b fa01 	bl	2f64c <__strcat_chk>
	GetSystemTimeSecStrings(tmpbuf);
   1424a:	a822      	add	r0, sp, #136	; 0x88
   1424c:	f7fc f9da 	bl	10604 <GetSystemTimeSecStrings>
	strcat(buf, tmpbuf);
   14250:	4622      	mov	r2, r4
   14252:	a922      	add	r1, sp, #136	; 0x88
   14254:	a802      	add	r0, sp, #8
   14256:	f01b f9f9 	bl	2f64c <__strcat_chk>
	strcat(buf, "]}");
   1425a:	4622      	mov	r2, r4
   1425c:	4913      	ldr	r1, [pc, #76]	; (142ac <NBSendSosGpsData+0xd0>)
   1425e:	a802      	add	r0, sp, #8
   14260:	f01b f9f4 	bl	2f64c <__strcat_chk>

	LOG_INF("[%s] sos gps data:%s\n", __func__, buf);
   14264:	2303      	movs	r3, #3
   14266:	f04f 0000 	mov.w	r0, #0
   1426a:	f363 0007 	bfi	r0, r3, #0, #8
   1426e:	4632      	mov	r2, r6
   14270:	ab02      	add	r3, sp, #8
   14272:	f365 108f 	bfi	r0, r5, #6, #10
   14276:	490e      	ldr	r1, [pc, #56]	; (142b0 <NBSendSosGpsData+0xd4>)
   14278:	f019 f83e 	bl	2d2f8 <log_string_sync>
	MqttSendData(buf, strlen(buf));
   1427c:	a802      	add	r0, sp, #8
   1427e:	f7f8 fe6b 	bl	cf58 <strlen>
   14282:	4601      	mov	r1, r0
   14284:	a802      	add	r0, sp, #8
   14286:	f7ff fef1 	bl	1406c <MqttSendData>
}
   1428a:	b042      	add	sp, #264	; 0x108
   1428c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14290:	000304cc 	.word	0x000304cc
   14294:	0003040c 	.word	0x0003040c
   14298:	00031a6f 	.word	0x00031a6f
   1429c:	00031977 	.word	0x00031977
   142a0:	00031990 	.word	0x00031990
   142a4:	2002fc73 	.word	0x2002fc73
   142a8:	00031995 	.word	0x00031995
   142ac:	00031998 	.word	0x00031998
   142b0:	0003199b 	.word	0x0003199b

000142b4 <NBSendFallWifiData>:

void NBSendFallWifiData(u8_t *data, u32_t datalen)
{
   142b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u8_t buf[128] = {0};
   142b8:	2480      	movs	r4, #128	; 0x80
{
   142ba:	b0a2      	sub	sp, #136	; 0x88
   142bc:	4607      	mov	r7, r0
   142be:	4688      	mov	r8, r1
	u8_t buf[128] = {0};
   142c0:	4622      	mov	r2, r4
   142c2:	2100      	movs	r1, #0
   142c4:	a802      	add	r0, sp, #8
   142c6:	f01b f865 	bl	2f394 <memset>
	u8_t tmpbuf[128] = {0};
	
	LOG_INF("[%s] wifi data:%s len:%d\n", __func__, data, datalen);
   142ca:	2303      	movs	r3, #3
   142cc:	f04f 0000 	mov.w	r0, #0
   142d0:	4d24      	ldr	r5, [pc, #144]	; (14364 <NBSendFallWifiData+0xb0>)
   142d2:	f363 0007 	bfi	r0, r3, #0, #8
   142d6:	4b24      	ldr	r3, [pc, #144]	; (14368 <NBSendFallWifiData+0xb4>)
   142d8:	4e24      	ldr	r6, [pc, #144]	; (1436c <NBSendFallWifiData+0xb8>)
   142da:	1aed      	subs	r5, r5, r3
   142dc:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   142e0:	463b      	mov	r3, r7
   142e2:	4632      	mov	r2, r6
   142e4:	f365 108f 	bfi	r0, r5, #6, #10
   142e8:	f8cd 8000 	str.w	r8, [sp]
   142ec:	4920      	ldr	r1, [pc, #128]	; (14370 <NBSendFallWifiData+0xbc>)
   142ee:	f019 f803 	bl	2d2f8 <log_string_sync>

	strcpy(buf, "{1:1:0:0:");
   142f2:	4920      	ldr	r1, [pc, #128]	; (14374 <NBSendFallWifiData+0xc0>)
   142f4:	a802      	add	r0, sp, #8
   142f6:	f01b f9ce 	bl	2f696 <strcpy>
	strcat(buf, g_imei);
   142fa:	4622      	mov	r2, r4
   142fc:	491e      	ldr	r1, [pc, #120]	; (14378 <NBSendFallWifiData+0xc4>)
   142fe:	a802      	add	r0, sp, #8
   14300:	f01b f9a4 	bl	2f64c <__strcat_chk>
	strcat(buf, ":T3:");
   14304:	4622      	mov	r2, r4
   14306:	491d      	ldr	r1, [pc, #116]	; (1437c <NBSendFallWifiData+0xc8>)
   14308:	a802      	add	r0, sp, #8
   1430a:	f01b f99f 	bl	2f64c <__strcat_chk>
	strcat(buf, data);
   1430e:	4622      	mov	r2, r4
   14310:	4639      	mov	r1, r7
   14312:	a802      	add	r0, sp, #8
   14314:	f01b f99a 	bl	2f64c <__strcat_chk>
	strcat(buf, ",");
   14318:	4622      	mov	r2, r4
   1431a:	4919      	ldr	r1, [pc, #100]	; (14380 <NBSendFallWifiData+0xcc>)
   1431c:	a802      	add	r0, sp, #8
   1431e:	f01b f995 	bl	2f64c <__strcat_chk>
	strcat(buf, fall_trigger_time);
   14322:	4622      	mov	r2, r4
   14324:	4917      	ldr	r1, [pc, #92]	; (14384 <NBSendFallWifiData+0xd0>)
   14326:	a802      	add	r0, sp, #8
   14328:	f01b f990 	bl	2f64c <__strcat_chk>
	strcat(buf, "}");
   1432c:	4622      	mov	r2, r4
   1432e:	4916      	ldr	r1, [pc, #88]	; (14388 <NBSendFallWifiData+0xd4>)
   14330:	a802      	add	r0, sp, #8
   14332:	f01b f98b 	bl	2f64c <__strcat_chk>

	LOG_INF("[%s] fall wifi data:%s\n", __func__, buf);
   14336:	2303      	movs	r3, #3
   14338:	f04f 0000 	mov.w	r0, #0
   1433c:	f363 0007 	bfi	r0, r3, #0, #8
   14340:	4632      	mov	r2, r6
   14342:	ab02      	add	r3, sp, #8
   14344:	f365 108f 	bfi	r0, r5, #6, #10
   14348:	4910      	ldr	r1, [pc, #64]	; (1438c <NBSendFallWifiData+0xd8>)
   1434a:	f018 ffd5 	bl	2d2f8 <log_string_sync>
	MqttSendData(buf, strlen(buf));
   1434e:	a802      	add	r0, sp, #8
   14350:	f7f8 fe02 	bl	cf58 <strlen>
   14354:	4601      	mov	r1, r0
   14356:	a802      	add	r0, sp, #8
   14358:	f7ff fe88 	bl	1406c <MqttSendData>
}
   1435c:	b022      	add	sp, #136	; 0x88
   1435e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14362:	bf00      	nop
   14364:	000304cc 	.word	0x000304cc
   14368:	0003040c 	.word	0x0003040c
   1436c:	00031a80 	.word	0x00031a80
   14370:	000319b1 	.word	0x000319b1
   14374:	000319cb 	.word	0x000319cb
   14378:	2002fc73 	.word	0x2002fc73
   1437c:	0003195a 	.word	0x0003195a
   14380:	00031993 	.word	0x00031993
   14384:	2002ff1b 	.word	0x2002ff1b
   14388:	00031999 	.word	0x00031999
   1438c:	0003195f 	.word	0x0003195f

00014390 <NBSendFallGpsData>:

void NBSendFallGpsData(u8_t *data, u32_t datalen)
{
   14390:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u8_t buf[128] = {0};
   14394:	2480      	movs	r4, #128	; 0x80
{
   14396:	b0c2      	sub	sp, #264	; 0x108
   14398:	4607      	mov	r7, r0
   1439a:	4688      	mov	r8, r1
	u8_t buf[128] = {0};
   1439c:	4622      	mov	r2, r4
   1439e:	2100      	movs	r1, #0
   143a0:	a802      	add	r0, sp, #8
   143a2:	f01a fff7 	bl	2f394 <memset>
	u8_t tmpbuf[128] = {0};
   143a6:	4622      	mov	r2, r4
   143a8:	2100      	movs	r1, #0
   143aa:	a822      	add	r0, sp, #136	; 0x88
   143ac:	f01a fff2 	bl	2f394 <memset>
	
	LOG_INF("[%s] gps data:%s len:%d\n", __func__, data, datalen);
   143b0:	2303      	movs	r3, #3
   143b2:	f04f 0000 	mov.w	r0, #0
   143b6:	4d23      	ldr	r5, [pc, #140]	; (14444 <NBSendFallGpsData+0xb4>)
   143b8:	f363 0007 	bfi	r0, r3, #0, #8
   143bc:	4b22      	ldr	r3, [pc, #136]	; (14448 <NBSendFallGpsData+0xb8>)
   143be:	4e23      	ldr	r6, [pc, #140]	; (1444c <NBSendFallGpsData+0xbc>)
   143c0:	1aed      	subs	r5, r5, r3
   143c2:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   143c6:	463b      	mov	r3, r7
   143c8:	4632      	mov	r2, r6
   143ca:	f365 108f 	bfi	r0, r5, #6, #10
   143ce:	f8cd 8000 	str.w	r8, [sp]
   143d2:	491f      	ldr	r1, [pc, #124]	; (14450 <NBSendFallGpsData+0xc0>)
   143d4:	f018 ff90 	bl	2d2f8 <log_string_sync>

	strcpy(buf, "{T4,");
   143d8:	491e      	ldr	r1, [pc, #120]	; (14454 <NBSendFallGpsData+0xc4>)
   143da:	a802      	add	r0, sp, #8
   143dc:	f01b f95b 	bl	2f696 <strcpy>
	strcat(buf, g_imei);
   143e0:	4622      	mov	r2, r4
   143e2:	491d      	ldr	r1, [pc, #116]	; (14458 <NBSendFallGpsData+0xc8>)
   143e4:	a802      	add	r0, sp, #8
   143e6:	f01b f931 	bl	2f64c <__strcat_chk>
	strcat(buf, ",[");
   143ea:	4622      	mov	r2, r4
   143ec:	491b      	ldr	r1, [pc, #108]	; (1445c <NBSendFallGpsData+0xcc>)
   143ee:	a802      	add	r0, sp, #8
   143f0:	f01b f92c 	bl	2f64c <__strcat_chk>
	strcat(buf, data);
   143f4:	4622      	mov	r2, r4
   143f6:	4639      	mov	r1, r7
   143f8:	a802      	add	r0, sp, #8
   143fa:	f01b f927 	bl	2f64c <__strcat_chk>
	GetSystemTimeSecStrings(tmpbuf);
   143fe:	a822      	add	r0, sp, #136	; 0x88
   14400:	f7fc f900 	bl	10604 <GetSystemTimeSecStrings>
	strcat(buf, tmpbuf);
   14404:	4622      	mov	r2, r4
   14406:	a922      	add	r1, sp, #136	; 0x88
   14408:	a802      	add	r0, sp, #8
   1440a:	f01b f91f 	bl	2f64c <__strcat_chk>
	strcat(buf, "]}");
   1440e:	4622      	mov	r2, r4
   14410:	4913      	ldr	r1, [pc, #76]	; (14460 <NBSendFallGpsData+0xd0>)
   14412:	a802      	add	r0, sp, #8
   14414:	f01b f91a 	bl	2f64c <__strcat_chk>

	LOG_INF("[%s] fall gps data:%s\n", __func__, buf);
   14418:	2303      	movs	r3, #3
   1441a:	f04f 0000 	mov.w	r0, #0
   1441e:	f363 0007 	bfi	r0, r3, #0, #8
   14422:	4632      	mov	r2, r6
   14424:	ab02      	add	r3, sp, #8
   14426:	f365 108f 	bfi	r0, r5, #6, #10
   1442a:	490e      	ldr	r1, [pc, #56]	; (14464 <NBSendFallGpsData+0xd4>)
   1442c:	f018 ff64 	bl	2d2f8 <log_string_sync>
	MqttSendData(buf, strlen(buf));
   14430:	a802      	add	r0, sp, #8
   14432:	f7f8 fd91 	bl	cf58 <strlen>
   14436:	4601      	mov	r1, r0
   14438:	a802      	add	r0, sp, #8
   1443a:	f7ff fe17 	bl	1406c <MqttSendData>
}
   1443e:	b042      	add	sp, #264	; 0x108
   14440:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14444:	000304cc 	.word	0x000304cc
   14448:	0003040c 	.word	0x0003040c
   1444c:	00031a93 	.word	0x00031a93
   14450:	00031977 	.word	0x00031977
   14454:	0003193e 	.word	0x0003193e
   14458:	2002fc73 	.word	0x2002fc73
   1445c:	00031995 	.word	0x00031995
   14460:	00031998 	.word	0x00031998
   14464:	00031943 	.word	0x00031943

00014468 <GetModemInfor>:

void GetModemInfor(void)
{
   14468:	b5f0      	push	{r4, r5, r6, r7, lr}
   1446a:	b0c1      	sub	sp, #260	; 0x104
	char *ptr;
	int i=0,len,err;
	u8_t tmpbuf[128] = {0};
   1446c:	466c      	mov	r4, sp
   1446e:	2280      	movs	r2, #128	; 0x80
   14470:	2100      	movs	r1, #0
   14472:	4620      	mov	r0, r4
   14474:	f01a ff8e 	bl	2f394 <memset>
	u8_t strbuf[128] = {0};
   14478:	2280      	movs	r2, #128	; 0x80
   1447a:	2100      	movs	r1, #0
   1447c:	eb0d 0002 	add.w	r0, sp, r2
   14480:	f01a ff88 	bl	2f394 <memset>

	if(at_cmd_write(CMD_GET_IMEI, tmpbuf, sizeof(tmpbuf), NULL) != 0)
   14484:	2300      	movs	r3, #0
   14486:	2280      	movs	r2, #128	; 0x80
   14488:	4621      	mov	r1, r4
   1448a:	4838      	ldr	r0, [pc, #224]	; (1456c <GetModemInfor+0x104>)
   1448c:	f007 fdb4 	bl	1bff8 <at_cmd_write>
   14490:	4d37      	ldr	r5, [pc, #220]	; (14570 <GetModemInfor+0x108>)
   14492:	4b38      	ldr	r3, [pc, #224]	; (14574 <GetModemInfor+0x10c>)
   14494:	4606      	mov	r6, r0
   14496:	1aed      	subs	r5, r5, r3
	{
		LOG_INF("Get imei fail!\n");
   14498:	f04f 0000 	mov.w	r0, #0
   1449c:	2303      	movs	r3, #3
   1449e:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   144a2:	f363 0007 	bfi	r0, r3, #0, #8
   144a6:	f365 108f 	bfi	r0, r5, #6, #10
	if(at_cmd_write(CMD_GET_IMEI, tmpbuf, sizeof(tmpbuf), NULL) != 0)
   144aa:	b126      	cbz	r6, 144b6 <GetModemInfor+0x4e>
		LOG_INF("Get imei fail!\n");
   144ac:	4932      	ldr	r1, [pc, #200]	; (14578 <GetModemInfor+0x110>)
	LOG_INF("imsi:%s\n", tmpbuf);
	strncpy(g_imsi, tmpbuf, IMSI_MAX_LEN);

	if(at_cmd_write(CMD_GET_RSRP, tmpbuf, sizeof(tmpbuf), NULL) != 0)
	{
		LOG_INF("Get rsrp fail!\n");
   144ae:	f018 ff23 	bl	2d2f8 <log_string_sync>
		i++;
	}

	memcpy((char*)strbuf, ptr, len-(ptr-(char*)tmpbuf));
	modem_rsrp_handler(atoi(strbuf));
}
   144b2:	b041      	add	sp, #260	; 0x104
   144b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	LOG_INF("imei:%s\n", tmpbuf);
   144b6:	4622      	mov	r2, r4
   144b8:	4930      	ldr	r1, [pc, #192]	; (1457c <GetModemInfor+0x114>)
   144ba:	f018 ff1d 	bl	2d2f8 <log_string_sync>
	strncpy(g_imei, tmpbuf, IMEI_MAX_LEN);
   144be:	220f      	movs	r2, #15
   144c0:	4621      	mov	r1, r4
   144c2:	482f      	ldr	r0, [pc, #188]	; (14580 <GetModemInfor+0x118>)
   144c4:	f01b f901 	bl	2f6ca <strncpy>
	if(at_cmd_write(CMD_GET_IMSI, tmpbuf, sizeof(tmpbuf), NULL) != 0)
   144c8:	4633      	mov	r3, r6
   144ca:	2280      	movs	r2, #128	; 0x80
   144cc:	4621      	mov	r1, r4
   144ce:	482d      	ldr	r0, [pc, #180]	; (14584 <GetModemInfor+0x11c>)
   144d0:	f007 fd92 	bl	1bff8 <at_cmd_write>
		LOG_INF("Get imsi fail!\n");
   144d4:	2303      	movs	r3, #3
	if(at_cmd_write(CMD_GET_IMSI, tmpbuf, sizeof(tmpbuf), NULL) != 0)
   144d6:	4606      	mov	r6, r0
		LOG_INF("Get imsi fail!\n");
   144d8:	f04f 0000 	mov.w	r0, #0
   144dc:	f363 0007 	bfi	r0, r3, #0, #8
   144e0:	f365 108f 	bfi	r0, r5, #6, #10
	if(at_cmd_write(CMD_GET_IMSI, tmpbuf, sizeof(tmpbuf), NULL) != 0)
   144e4:	b10e      	cbz	r6, 144ea <GetModemInfor+0x82>
		LOG_INF("Get imsi fail!\n");
   144e6:	4928      	ldr	r1, [pc, #160]	; (14588 <GetModemInfor+0x120>)
   144e8:	e7e1      	b.n	144ae <GetModemInfor+0x46>
	LOG_INF("imsi:%s\n", tmpbuf);
   144ea:	4622      	mov	r2, r4
   144ec:	4927      	ldr	r1, [pc, #156]	; (1458c <GetModemInfor+0x124>)
   144ee:	f018 ff03 	bl	2d2f8 <log_string_sync>
	strncpy(g_imsi, tmpbuf, IMSI_MAX_LEN);
   144f2:	220f      	movs	r2, #15
   144f4:	4621      	mov	r1, r4
   144f6:	4826      	ldr	r0, [pc, #152]	; (14590 <GetModemInfor+0x128>)
   144f8:	f01b f8e7 	bl	2f6ca <strncpy>
	if(at_cmd_write(CMD_GET_RSRP, tmpbuf, sizeof(tmpbuf), NULL) != 0)
   144fc:	4633      	mov	r3, r6
   144fe:	2280      	movs	r2, #128	; 0x80
   14500:	4621      	mov	r1, r4
   14502:	4824      	ldr	r0, [pc, #144]	; (14594 <GetModemInfor+0x12c>)
   14504:	f007 fd78 	bl	1bff8 <at_cmd_write>
   14508:	b140      	cbz	r0, 1451c <GetModemInfor+0xb4>
		LOG_INF("Get rsrp fail!\n");
   1450a:	f04f 0000 	mov.w	r0, #0
   1450e:	2303      	movs	r3, #3
   14510:	f363 0007 	bfi	r0, r3, #0, #8
   14514:	f365 108f 	bfi	r0, r5, #6, #10
   14518:	491f      	ldr	r1, [pc, #124]	; (14598 <GetModemInfor+0x130>)
   1451a:	e7c8      	b.n	144ae <GetModemInfor+0x46>
	LOG_INF("rsrp:%s\n", tmpbuf);
   1451c:	2303      	movs	r3, #3
   1451e:	f04f 0000 	mov.w	r0, #0
   14522:	f363 0007 	bfi	r0, r3, #0, #8
   14526:	f365 108f 	bfi	r0, r5, #6, #10
   1452a:	4622      	mov	r2, r4
   1452c:	491b      	ldr	r1, [pc, #108]	; (1459c <GetModemInfor+0x134>)
   1452e:	f018 fee3 	bl	2d2f8 <log_string_sync>
	len = strlen(tmpbuf);
   14532:	4620      	mov	r0, r4
   14534:	f7f8 fd10 	bl	cf58 <strlen>
   14538:	2505      	movs	r5, #5
   1453a:	4606      	mov	r6, r0
	ptr = tmpbuf;
   1453c:	4620      	mov	r0, r4
		ptr = strstr(ptr, ",");
   1453e:	4f18      	ldr	r7, [pc, #96]	; (145a0 <GetModemInfor+0x138>)
   14540:	4639      	mov	r1, r7
   14542:	f01b f8d5 	bl	2f6f0 <strstr>
	while(i<5)
   14546:	3d01      	subs	r5, #1
		ptr++;
   14548:	f100 0001 	add.w	r0, r0, #1
	while(i<5)
   1454c:	d1f8      	bne.n	14540 <GetModemInfor+0xd8>
	memcpy((char*)strbuf, ptr, len-(ptr-(char*)tmpbuf));
   1454e:	2380      	movs	r3, #128	; 0x80
   14550:	1b04      	subs	r4, r0, r4
   14552:	4601      	mov	r1, r0
   14554:	1b32      	subs	r2, r6, r4
   14556:	eb0d 0003 	add.w	r0, sp, r3
   1455a:	f01a ff08 	bl	2f36e <__memcpy_chk>
	modem_rsrp_handler(atoi(strbuf));
   1455e:	a820      	add	r0, sp, #128	; 0x80
   14560:	f01a fed8 	bl	2f314 <atoi>
   14564:	b2c0      	uxtb	r0, r0
   14566:	f7fe ff51 	bl	1340c <modem_rsrp_handler>
   1456a:	e7a2      	b.n	144b2 <GetModemInfor+0x4a>
   1456c:	0003189d 	.word	0x0003189d
   14570:	000304cc 	.word	0x000304cc
   14574:	0003040c 	.word	0x0003040c
   14578:	000318a5 	.word	0x000318a5
   1457c:	000318b5 	.word	0x000318b5
   14580:	2002fc73 	.word	0x2002fc73
   14584:	000318be 	.word	0x000318be
   14588:	000318c6 	.word	0x000318c6
   1458c:	000318d6 	.word	0x000318d6
   14590:	2002fc83 	.word	0x2002fc83
   14594:	000318df 	.word	0x000318df
   14598:	000318e7 	.word	0x000318e7
   1459c:	000318f7 	.word	0x000318f7
   145a0:	00031993 	.word	0x00031993

000145a4 <nb_link>:

static void nb_link(struct k_work *work)
{
   145a4:	b510      	push	{r4, lr}
	int err;

	err = lte_lc_init_and_connect();
   145a6:	f01a fc98 	bl	2eeda <lte_lc_init_and_connect>
	if(err)
   145aa:	4a13      	ldr	r2, [pc, #76]	; (145f8 <nb_link+0x54>)
   145ac:	4b13      	ldr	r3, [pc, #76]	; (145fc <nb_link+0x58>)
   145ae:	4604      	mov	r4, r0
   145b0:	1a9b      	subs	r3, r3, r2
	{
		LOG_INF("Can't connected to LTE network");
   145b2:	f04f 0000 	mov.w	r0, #0
   145b6:	2203      	movs	r2, #3
   145b8:	f3c3 03c9 	ubfx	r3, r3, #3, #10
   145bc:	f362 0007 	bfi	r0, r2, #0, #8
   145c0:	f363 108f 	bfi	r0, r3, #6, #10
	if(err)
   145c4:	b174      	cbz	r4, 145e4 <nb_link+0x40>
		LOG_INF("Can't connected to LTE network");
   145c6:	490e      	ldr	r1, [pc, #56]	; (14600 <nb_link+0x5c>)
   145c8:	f018 fe96 	bl	2d2f8 <log_string_sync>
		LOG_INF("Connected to LTE network");
		GetModemDateTime();
		modem_data_init();
	}

	GetModemInfor();
   145cc:	f7ff ff4c 	bl	14468 <GetModemInfor>
	
	if(!err)
   145d0:	b984      	cbnz	r4, 145f4 <nb_link+0x50>
	{
		k_delayed_work_submit_to_queue(app_work_q, &mqtt_link_work, K_SECONDS(2));
	}
}
   145d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		k_delayed_work_submit_to_queue(app_work_q, &mqtt_link_work, K_SECONDS(2));
   145d6:	4b0b      	ldr	r3, [pc, #44]	; (14604 <nb_link+0x60>)
   145d8:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
   145dc:	490a      	ldr	r1, [pc, #40]	; (14608 <nb_link+0x64>)
   145de:	6818      	ldr	r0, [r3, #0]
   145e0:	f014 ba56 	b.w	28a90 <k_delayed_work_submit_to_queue>
		LOG_INF("Connected to LTE network");
   145e4:	4909      	ldr	r1, [pc, #36]	; (1460c <nb_link+0x68>)
   145e6:	f018 fe87 	bl	2d2f8 <log_string_sync>
		GetModemDateTime();
   145ea:	f7ff fc65 	bl	13eb8 <GetModemDateTime>
		modem_data_init();
   145ee:	f7ff fb33 	bl	13c58 <modem_data_init>
   145f2:	e7eb      	b.n	145cc <nb_link+0x28>
}
   145f4:	bd10      	pop	{r4, pc}
   145f6:	bf00      	nop
   145f8:	0003040c 	.word	0x0003040c
   145fc:	000304cc 	.word	0x000304cc
   14600:	00031e6a 	.word	0x00031e6a
   14604:	20020cc4 	.word	0x20020cc4
   14608:	20020d34 	.word	0x20020d34
   1460c:	00031e89 	.word	0x00031e89

00014610 <NBMsgProcess>:
	LOG_INF("rsrp:%s\n", str_rsrp);
}

void NBMsgProcess(void)
{
	if(app_nb_on)
   14610:	4b24      	ldr	r3, [pc, #144]	; (146a4 <NBMsgProcess+0x94>)
{
   14612:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if(app_nb_on)
   14614:	781a      	ldrb	r2, [r3, #0]
   14616:	b13a      	cbz	r2, 14628 <NBMsgProcess+0x18>
	{
		app_nb_on = false;
   14618:	2200      	movs	r2, #0
   1461a:	701a      	strb	r2, [r3, #0]
		if(nb_is_running)
   1461c:	4b22      	ldr	r3, [pc, #136]	; (146a8 <NBMsgProcess+0x98>)
   1461e:	781b      	ldrb	r3, [r3, #0]
   14620:	2b00      	cmp	r3, #0
   14622:	d13d      	bne.n	146a0 <NBMsgProcess+0x90>
			return;
		
		test_nb();
   14624:	f7ff fb40 	bl	13ca8 <test_nb>
	}

	if(send_data_flag)
   14628:	4c20      	ldr	r4, [pc, #128]	; (146ac <NBMsgProcess+0x9c>)
   1462a:	7822      	ldrb	r2, [r4, #0]
   1462c:	b19a      	cbz	r2, 14656 <NBMsgProcess+0x46>
	ret = get_data_from_cache(&p_data, &data_len);
   1462e:	a901      	add	r1, sp, #4
   14630:	4668      	mov	r0, sp
   14632:	f000 f915 	bl	14860 <get_data_from_cache>
	if(ret)
   14636:	b160      	cbz	r0, 14652 <NBMsgProcess+0x42>
		ret = data_publish(&client, MQTT_QOS_1_AT_LEAST_ONCE, p_data, data_len);
   14638:	e9dd 0100 	ldrd	r0, r1, [sp]
   1463c:	f7fe ff3e 	bl	134bc <data_publish.constprop.6>
		if(!ret)
   14640:	b908      	cbnz	r0, 14646 <NBMsgProcess+0x36>
			delete_data_from_cache();
   14642:	f000 f94d 	bl	148e0 <delete_data_from_cache>
   14646:	2200      	movs	r2, #0
   14648:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   1464c:	4818      	ldr	r0, [pc, #96]	; (146b0 <NBMsgProcess+0xa0>)
   1464e:	f014 fdf9 	bl	29244 <z_impl_k_timer_start>
	{
		NbSendData();
		send_data_flag = false;
   14652:	2300      	movs	r3, #0
   14654:	7023      	strb	r3, [r4, #0]
	}

	if(mqtt_disconnect_flag)
   14656:	4d17      	ldr	r5, [pc, #92]	; (146b4 <NBMsgProcess+0xa4>)
   14658:	782a      	ldrb	r2, [r5, #0]
   1465a:	b30a      	cbz	r2, 146a0 <NBMsgProcess+0x90>
	LOG_INF("%s: begin\n", __func__);
   1465c:	2303      	movs	r3, #3
   1465e:	f04f 0000 	mov.w	r0, #0
   14662:	4c15      	ldr	r4, [pc, #84]	; (146b8 <NBMsgProcess+0xa8>)
   14664:	f363 0007 	bfi	r0, r3, #0, #8
   14668:	4b14      	ldr	r3, [pc, #80]	; (146bc <NBMsgProcess+0xac>)
   1466a:	4a15      	ldr	r2, [pc, #84]	; (146c0 <NBMsgProcess+0xb0>)
   1466c:	1ae4      	subs	r4, r4, r3
   1466e:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   14672:	f364 108f 	bfi	r0, r4, #6, #10
   14676:	4913      	ldr	r1, [pc, #76]	; (146c4 <NBMsgProcess+0xb4>)
   14678:	f018 fe3e 	bl	2d2f8 <log_string_sync>
	err = mqtt_disconnect(&client);
   1467c:	4812      	ldr	r0, [pc, #72]	; (146c8 <NBMsgProcess+0xb8>)
   1467e:	f019 fba7 	bl	2ddd0 <mqtt_disconnect>
	if(err)
   14682:	4603      	mov	r3, r0
   14684:	b150      	cbz	r0, 1469c <NBMsgProcess+0x8c>
		LOG_INF("%s: Could not disconnect MQTT client. Error: %d\n", __func__, err);
   14686:	2203      	movs	r2, #3
   14688:	f04f 0000 	mov.w	r0, #0
   1468c:	f362 0007 	bfi	r0, r2, #0, #8
   14690:	f364 108f 	bfi	r0, r4, #6, #10
   14694:	4a0a      	ldr	r2, [pc, #40]	; (146c0 <NBMsgProcess+0xb0>)
   14696:	490d      	ldr	r1, [pc, #52]	; (146cc <NBMsgProcess+0xbc>)
   14698:	f018 fe2e 	bl	2d2f8 <log_string_sync>
	{
		MqttDisConnect();
		mqtt_disconnect_flag = false;
   1469c:	2300      	movs	r3, #0
   1469e:	702b      	strb	r3, [r5, #0]
	}
}
   146a0:	b003      	add	sp, #12
   146a2:	bd30      	pop	{r4, r5, pc}
   146a4:	2002fc72 	.word	0x2002fc72
   146a8:	2002fc96 	.word	0x2002fc96
   146ac:	2002fd97 	.word	0x2002fd97
   146b0:	2003b768 	.word	0x2003b768
   146b4:	2002fc95 	.word	0x2002fc95
   146b8:	000304cc 	.word	0x000304cc
   146bc:	0003040c 	.word	0x0003040c
   146c0:	00031a16 	.word	0x00031a16
   146c4:	00031900 	.word	0x00031900
   146c8:	20020cc8 	.word	0x20020cc8
   146cc:	00031e24 	.word	0x00031e24

000146d0 <NB_init>:

void NB_init(struct k_work_q *work_q)
{
   146d0:	b570      	push	{r4, r5, r6, lr}
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   146d2:	4d11      	ldr	r5, [pc, #68]	; (14718 <NB_init+0x48>)
   146d4:	2300      	movs	r3, #0
   146d6:	462c      	mov	r4, r5
	int err;

	app_work_q = work_q;
   146d8:	4e10      	ldr	r6, [pc, #64]	; (1471c <NB_init+0x4c>)
   146da:	4a11      	ldr	r2, [pc, #68]	; (14720 <NB_init+0x50>)
   146dc:	6030      	str	r0, [r6, #0]

	k_work_init(&nb_link_work, nb_link);
	k_delayed_work_init(&mqtt_link_work, mqtt_link);
   146de:	4911      	ldr	r1, [pc, #68]	; (14724 <NB_init+0x54>)
   146e0:	4811      	ldr	r0, [pc, #68]	; (14728 <NB_init+0x58>)
   146e2:	602b      	str	r3, [r5, #0]
   146e4:	606a      	str	r2, [r5, #4]
   146e6:	f844 3f08 	str.w	r3, [r4, #8]!
   146ea:	f01a fd6a 	bl	2f1c2 <k_delayed_work_init>
	k_delayed_work_init(&mqtt_send_work, mqtt_send);
   146ee:	480f      	ldr	r0, [pc, #60]	; (1472c <NB_init+0x5c>)
   146f0:	490f      	ldr	r1, [pc, #60]	; (14730 <NB_init+0x60>)
   146f2:	f01a fd66 	bl	2f1c2 <k_delayed_work_init>
	
	k_work_submit_to_queue(app_work_q, &nb_link_work);
   146f6:	6830      	ldr	r0, [r6, #0]
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   146f8:	e8d4 3fef 	ldaex	r3, [r4]
   146fc:	f043 0201 	orr.w	r2, r3, #1
   14700:	e8c4 2fe1 	stlex	r1, r2, [r4]
   14704:	2900      	cmp	r1, #0
   14706:	d1f7      	bne.n	146f8 <NB_init+0x28>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   14708:	07db      	lsls	r3, r3, #31
   1470a:	d404      	bmi.n	14716 <NB_init+0x46>
		k_queue_append(&work_q->queue, work);
   1470c:	4629      	mov	r1, r5
}
   1470e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   14712:	f01a bc86 	b.w	2f022 <k_queue_append>
   14716:	bd70      	pop	{r4, r5, r6, pc}
   14718:	20020d74 	.word	0x20020d74
   1471c:	20020cc4 	.word	0x20020cc4
   14720:	000145a5 	.word	0x000145a5
   14724:	00013ae9 	.word	0x00013ae9
   14728:	20020d34 	.word	0x20020d34
   1472c:	20020d54 	.word	0x20020d54
   14730:	0001370d 	.word	0x0001370d

00014734 <add_data_into_cache>:

static DataNode *head = NULL;
static DataNode *tail = NULL;

bool add_data_into_cache(u8_t *data, u32_t len)
{
   14734:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14738:	4a42      	ldr	r2, [pc, #264]	; (14844 <add_data_into_cache+0x110>)
   1473a:	4b43      	ldr	r3, [pc, #268]	; (14848 <add_data_into_cache+0x114>)
   1473c:	4681      	mov	r9, r0
   1473e:	1a9b      	subs	r3, r3, r2
	DataNode *pnew;

	if(g_nb_cache.cache == NULL)
	{
		LOG_INF("%s: begin 001\n", __func__);
   14740:	f04f 0000 	mov.w	r0, #0
   14744:	2203      	movs	r2, #3
	if(g_nb_cache.cache == NULL)
   14746:	f8df 8114 	ldr.w	r8, [pc, #276]	; 1485c <add_data_into_cache+0x128>
		LOG_INF("%s: begin 001\n", __func__);
   1474a:	f362 0007 	bfi	r0, r2, #0, #8
	if(g_nb_cache.cache == NULL)
   1474e:	f8d8 5004 	ldr.w	r5, [r8, #4]
   14752:	f3c3 03c9 	ubfx	r3, r3, #3, #10
{
   14756:	460f      	mov	r7, r1
   14758:	46c2      	mov	sl, r8
   1475a:	4e3c      	ldr	r6, [pc, #240]	; (1484c <add_data_into_cache+0x118>)
		LOG_INF("%s: begin 001\n", __func__);
   1475c:	f363 108f 	bfi	r0, r3, #6, #10
   14760:	4a3b      	ldr	r2, [pc, #236]	; (14850 <add_data_into_cache+0x11c>)
	if(g_nb_cache.cache == NULL)
   14762:	bb9d      	cbnz	r5, 147cc <add_data_into_cache+0x98>
		LOG_INF("%s: begin 001\n", __func__);
   14764:	493b      	ldr	r1, [pc, #236]	; (14854 <add_data_into_cache+0x120>)
   14766:	f018 fdc7 	bl	2d2f8 <log_string_sync>
		
		g_nb_cache.count = 0;
		g_nb_cache.cache = NULL;

		tail = k_malloc(sizeof(DataNode));
   1476a:	200c      	movs	r0, #12
		g_nb_cache.cache = NULL;
   1476c:	e9c8 5500 	strd	r5, r5, [r8]
		tail = k_malloc(sizeof(DataNode));
   14770:	f012 f8a6 	bl	268c0 <k_malloc>
   14774:	4604      	mov	r4, r0
   14776:	6030      	str	r0, [r6, #0]
		if(tail == NULL) 
   14778:	b910      	cbnz	r0, 14780 <add_data_into_cache+0x4c>
			return false;
   1477a:	2000      	movs	r0, #0

		g_nb_cache.count++;
		
		return true;
	}
}
   1477c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		tail->data = k_malloc(len+1);
   14780:	f107 0b01 	add.w	fp, r7, #1
__ssp_bos_icheck3(memset, void *, int)
   14784:	6005      	str	r5, [r0, #0]
   14786:	6045      	str	r5, [r0, #4]
   14788:	6085      	str	r5, [r0, #8]
   1478a:	4658      	mov	r0, fp
   1478c:	f012 f898 	bl	268c0 <k_malloc>
		if(tail->data == NULL) 
   14790:	f8d6 a000 	ldr.w	sl, [r6]
		tail->data = k_malloc(len+1);
   14794:	6060      	str	r0, [r4, #4]
		if(tail->data == NULL) 
   14796:	f8da 4004 	ldr.w	r4, [sl, #4]
   1479a:	b924      	cbnz	r4, 147a6 <add_data_into_cache+0x72>
			k_free(tail);
   1479c:	4650      	mov	r0, sl
   1479e:	f01a fc0a 	bl	2efb6 <k_free>
			tail = NULL;
   147a2:	6034      	str	r4, [r6, #0]
			return false;
   147a4:	e7e9      	b.n	1477a <add_data_into_cache+0x46>
   147a6:	465a      	mov	r2, fp
   147a8:	4629      	mov	r1, r5
		tail->len = len;
   147aa:	f8ca 7000 	str.w	r7, [sl]
   147ae:	4620      	mov	r0, r4
   147b0:	f01a fdf0 	bl	2f394 <memset>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   147b4:	463a      	mov	r2, r7
   147b6:	4649      	mov	r1, r9
   147b8:	f8da 0004 	ldr.w	r0, [sl, #4]
   147bc:	f01a fdca 	bl	2f354 <memcpy>
		g_nb_cache.count = 1;
   147c0:	2001      	movs	r0, #1
		g_nb_cache.cache = tail;
   147c2:	f8c8 a004 	str.w	sl, [r8, #4]
		g_nb_cache.count = 1;
   147c6:	f8c8 0000 	str.w	r0, [r8]
		return true;
   147ca:	e7d7      	b.n	1477c <add_data_into_cache+0x48>
		LOG_INF("%s: begin 002\n", __func__);
   147cc:	4922      	ldr	r1, [pc, #136]	; (14858 <add_data_into_cache+0x124>)
   147ce:	f018 fd93 	bl	2d2f8 <log_string_sync>
		if(tail == NULL)
   147d2:	6833      	ldr	r3, [r6, #0]
   147d4:	b933      	cbnz	r3, 147e4 <add_data_into_cache+0xb0>
			tail = g_nb_cache.cache;
   147d6:	f8d8 2004 	ldr.w	r2, [r8, #4]
   147da:	6032      	str	r2, [r6, #0]
				if(tail->next == NULL)
   147dc:	6891      	ldr	r1, [r2, #8]
   147de:	b9d1      	cbnz	r1, 14816 <add_data_into_cache+0xe2>
   147e0:	b103      	cbz	r3, 147e4 <add_data_into_cache+0xb0>
   147e2:	6032      	str	r2, [r6, #0]
		pnew = k_malloc(sizeof(DataNode));
   147e4:	200c      	movs	r0, #12
   147e6:	f012 f86b 	bl	268c0 <k_malloc>
		if(pnew == NULL) 
   147ea:	4605      	mov	r5, r0
   147ec:	2800      	cmp	r0, #0
   147ee:	d0c4      	beq.n	1477a <add_data_into_cache+0x46>
__ssp_bos_icheck3(memset, void *, int)
   147f0:	f04f 0800 	mov.w	r8, #0
		pnew->data = k_malloc(len+1);
   147f4:	f107 0b01 	add.w	fp, r7, #1
   147f8:	f8c0 8000 	str.w	r8, [r0]
   147fc:	f8c0 8004 	str.w	r8, [r0, #4]
   14800:	f8c0 8008 	str.w	r8, [r0, #8]
   14804:	4658      	mov	r0, fp
   14806:	f012 f85b 	bl	268c0 <k_malloc>
   1480a:	6068      	str	r0, [r5, #4]
		if(pnew->data == NULL) 
   1480c:	b930      	cbnz	r0, 1481c <add_data_into_cache+0xe8>
			k_free(pnew);
   1480e:	4628      	mov	r0, r5
   14810:	f01a fbd1 	bl	2efb6 <k_free>
			return false;
   14814:	e7b1      	b.n	1477a <add_data_into_cache+0x46>
   14816:	2301      	movs	r3, #1
   14818:	460a      	mov	r2, r1
   1481a:	e7df      	b.n	147dc <add_data_into_cache+0xa8>
   1481c:	465a      	mov	r2, fp
   1481e:	4641      	mov	r1, r8
		pnew->len = len;
   14820:	602f      	str	r7, [r5, #0]
   14822:	f01a fdb7 	bl	2f394 <memset>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   14826:	463a      	mov	r2, r7
   14828:	4649      	mov	r1, r9
   1482a:	6868      	ldr	r0, [r5, #4]
   1482c:	f01a fd92 	bl	2f354 <memcpy>
		tail->next = pnew;
   14830:	6833      	ldr	r3, [r6, #0]
		return true;
   14832:	2001      	movs	r0, #1
		tail->next = pnew;
   14834:	609d      	str	r5, [r3, #8]
		g_nb_cache.count++;
   14836:	f8da 3000 	ldr.w	r3, [sl]
		tail = pnew;
   1483a:	6035      	str	r5, [r6, #0]
		g_nb_cache.count++;
   1483c:	3301      	adds	r3, #1
   1483e:	f8ca 3000 	str.w	r3, [sl]
		return true;
   14842:	e79b      	b.n	1477c <add_data_into_cache+0x48>
   14844:	0003040c 	.word	0x0003040c
   14848:	0003051c 	.word	0x0003051c
   1484c:	20020d9c 	.word	0x20020d9c
   14850:	00031f53 	.word	0x00031f53
   14854:	00031920 	.word	0x00031920
   14858:	0003192f 	.word	0x0003192f
   1485c:	20020d90 	.word	0x20020d90

00014860 <get_data_from_cache>:

bool get_data_from_cache(u8_t **buf, u32_t *len)
{
   14860:	b570      	push	{r4, r5, r6, lr}
   14862:	4a18      	ldr	r2, [pc, #96]	; (148c4 <get_data_from_cache+0x64>)
   14864:	4b18      	ldr	r3, [pc, #96]	; (148c8 <get_data_from_cache+0x68>)
	if(g_nb_cache.cache == NULL || g_nb_cache.count == 0)
   14866:	4c19      	ldr	r4, [pc, #100]	; (148cc <get_data_from_cache+0x6c>)
   14868:	1a9b      	subs	r3, r3, r2
   1486a:	6862      	ldr	r2, [r4, #4]
{
   1486c:	4606      	mov	r6, r0
   1486e:	460d      	mov	r5, r1
   14870:	f3c3 03c9 	ubfx	r3, r3, #3, #10
	if(g_nb_cache.cache == NULL || g_nb_cache.count == 0)
   14874:	b10a      	cbz	r2, 1487a <get_data_from_cache+0x1a>
   14876:	6822      	ldr	r2, [r4, #0]
   14878:	b96a      	cbnz	r2, 14896 <get_data_from_cache+0x36>
	{
		LOG_INF("%s: begin 001\n", __func__);
   1487a:	2203      	movs	r2, #3
   1487c:	f04f 0000 	mov.w	r0, #0
   14880:	f362 0007 	bfi	r0, r2, #0, #8
   14884:	f363 108f 	bfi	r0, r3, #6, #10
   14888:	4a11      	ldr	r2, [pc, #68]	; (148d0 <get_data_from_cache+0x70>)
   1488a:	4912      	ldr	r1, [pc, #72]	; (148d4 <get_data_from_cache+0x74>)
   1488c:	f018 fd34 	bl	2d2f8 <log_string_sync>
		
		buf = NULL;
		*len = 0;
   14890:	2000      	movs	r0, #0
   14892:	6028      	str	r0, [r5, #0]
			g_nb_cache.count = 0;
	#endif
	
		return true;
	}
}
   14894:	bd70      	pop	{r4, r5, r6, pc}
		LOG_INF("%s: begin 002\n", __func__);
   14896:	2203      	movs	r2, #3
   14898:	f04f 0000 	mov.w	r0, #0
   1489c:	f362 0007 	bfi	r0, r2, #0, #8
   148a0:	f363 108f 	bfi	r0, r3, #6, #10
   148a4:	4a0a      	ldr	r2, [pc, #40]	; (148d0 <get_data_from_cache+0x70>)
   148a6:	490c      	ldr	r1, [pc, #48]	; (148d8 <get_data_from_cache+0x78>)
   148a8:	f018 fd26 	bl	2d2f8 <log_string_sync>
		if(head == NULL)
   148ac:	4b0b      	ldr	r3, [pc, #44]	; (148dc <get_data_from_cache+0x7c>)
   148ae:	681a      	ldr	r2, [r3, #0]
   148b0:	b90a      	cbnz	r2, 148b6 <get_data_from_cache+0x56>
			head = g_nb_cache.cache;
   148b2:	6862      	ldr	r2, [r4, #4]
   148b4:	601a      	str	r2, [r3, #0]
		*buf = head->data;
   148b6:	681b      	ldr	r3, [r3, #0]
		return true;
   148b8:	2001      	movs	r0, #1
		*buf = head->data;
   148ba:	685a      	ldr	r2, [r3, #4]
		*len = head->len;
   148bc:	681b      	ldr	r3, [r3, #0]
		*buf = head->data;
   148be:	6032      	str	r2, [r6, #0]
		*len = head->len;
   148c0:	602b      	str	r3, [r5, #0]
		return true;
   148c2:	e7e7      	b.n	14894 <get_data_from_cache+0x34>
   148c4:	0003040c 	.word	0x0003040c
   148c8:	0003051c 	.word	0x0003051c
   148cc:	20020d90 	.word	0x20020d90
   148d0:	00031f67 	.word	0x00031f67
   148d4:	00031920 	.word	0x00031920
   148d8:	0003192f 	.word	0x0003192f
   148dc:	20020d98 	.word	0x20020d98

000148e0 <delete_data_from_cache>:

bool delete_data_from_cache(void)
{
   148e0:	b538      	push	{r3, r4, r5, lr}
	if(g_nb_cache.cache == NULL || g_nb_cache.count == 0)
   148e2:	4c0d      	ldr	r4, [pc, #52]	; (14918 <delete_data_from_cache+0x38>)
   148e4:	6863      	ldr	r3, [r4, #4]
   148e6:	b1a3      	cbz	r3, 14912 <delete_data_from_cache+0x32>
   148e8:	6820      	ldr	r0, [r4, #0]
   148ea:	b188      	cbz	r0, 14910 <delete_data_from_cache+0x30>
	{
		return false;
	}
	else
	{
		head = g_nb_cache.cache->next;
   148ec:	689a      	ldr	r2, [r3, #8]
   148ee:	4d0b      	ldr	r5, [pc, #44]	; (1491c <delete_data_from_cache+0x3c>)
		
		k_free(g_nb_cache.cache->data);
   148f0:	6858      	ldr	r0, [r3, #4]
		head = g_nb_cache.cache->next;
   148f2:	602a      	str	r2, [r5, #0]
		k_free(g_nb_cache.cache->data);
   148f4:	f01a fb5f 	bl	2efb6 <k_free>
		g_nb_cache.cache->data = NULL;
   148f8:	2300      	movs	r3, #0
   148fa:	6860      	ldr	r0, [r4, #4]
		g_nb_cache.cache->len = 0;
   148fc:	e9c0 3300 	strd	r3, r3, [r0]
		k_free(g_nb_cache.cache);
   14900:	f01a fb59 	bl	2efb6 <k_free>
		g_nb_cache.cache = NULL;

		g_nb_cache.count--;
		g_nb_cache.cache = head;
		
		return true;
   14904:	2001      	movs	r0, #1
		g_nb_cache.count--;
   14906:	6823      	ldr	r3, [r4, #0]
   14908:	3b01      	subs	r3, #1
   1490a:	6023      	str	r3, [r4, #0]
		g_nb_cache.cache = head;
   1490c:	682b      	ldr	r3, [r5, #0]
   1490e:	6063      	str	r3, [r4, #4]
	}
}
   14910:	bd38      	pop	{r3, r4, r5, pc}
		return false;
   14912:	4618      	mov	r0, r3
   14914:	e7fc      	b.n	14910 <delete_data_from_cache+0x30>
   14916:	bf00      	nop
   14918:	20020d90 	.word	0x20020d90
   1491c:	20020d98 	.word	0x20020d98

00014920 <touch_panel_event_handle>:
	return false;
}

void touch_panel_event_handle(tp_event tp_type, u16_t x_pos, u16_t y_pos)
{
	switch(tp_type)
   14920:	2806      	cmp	r0, #6
   14922:	d815      	bhi.n	14950 <touch_panel_event_handle+0x30>
   14924:	e8df f000 	tbb	[pc, r0]
   14928:	0b090704 	.word	0x0b090704
   1492c:	100d      	.short	0x100d
   1492e:	12          	.byte	0x12
   1492f:	00          	.byte	0x00
	{
	case TP_EVENT_MOVING_UP:
		printk("tp moving up!\n");
   14930:	4808      	ldr	r0, [pc, #32]	; (14954 <touch_panel_event_handle+0x34>)
		break;
	case TP_EVENT_MOVING_DOWN:
		printk("tp moving down!\n");
   14932:	f018 bc8a 	b.w	2d24a <printk>
   14936:	4808      	ldr	r0, [pc, #32]	; (14958 <touch_panel_event_handle+0x38>)
   14938:	e7fb      	b.n	14932 <touch_panel_event_handle+0x12>
		break;
	case TP_EVENT_MOVING_LEFT:
		printk("tp moving left!\n");
   1493a:	4808      	ldr	r0, [pc, #32]	; (1495c <touch_panel_event_handle+0x3c>)
   1493c:	e7f9      	b.n	14932 <touch_panel_event_handle+0x12>
		break;
	case TP_EVENT_MOVING_RIGHT:
		printk("tp moving right!\n");
   1493e:	4808      	ldr	r0, [pc, #32]	; (14960 <touch_panel_event_handle+0x40>)
   14940:	e7f7      	b.n	14932 <touch_panel_event_handle+0x12>
		break;
	case TP_EVENT_SINGLE_CLICK:
		printk("tp single click! x:%d, y:%d\n", x_pos,y_pos);
   14942:	4808      	ldr	r0, [pc, #32]	; (14964 <touch_panel_event_handle+0x44>)
		break;
	case TP_EVENT_DOUBLE_CLICK:
		printk("tp double click! x:%d, y:%d\n", x_pos,y_pos);
		break;
	case TP_EVENT_LONG_PRESS:
		printk("tp long press! x:%d, y:%d\n", x_pos,y_pos);
   14944:	f018 bc81 	b.w	2d24a <printk>
		printk("tp double click! x:%d, y:%d\n", x_pos,y_pos);
   14948:	4807      	ldr	r0, [pc, #28]	; (14968 <touch_panel_event_handle+0x48>)
   1494a:	e7fb      	b.n	14944 <touch_panel_event_handle+0x24>
		printk("tp long press! x:%d, y:%d\n", x_pos,y_pos);
   1494c:	4807      	ldr	r0, [pc, #28]	; (1496c <touch_panel_event_handle+0x4c>)
   1494e:	e7f9      	b.n	14944 <touch_panel_event_handle+0x24>
		break;
	case TP_EVENT_MAX:
		break;
	}
}
   14950:	4770      	bx	lr
   14952:	bf00      	nop
   14954:	00031f8a 	.word	0x00031f8a
   14958:	00031f99 	.word	0x00031f99
   1495c:	00031faa 	.word	0x00031faa
   14960:	00031fbb 	.word	0x00031fbb
   14964:	00031fcd 	.word	0x00031fcd
   14968:	00031fea 	.word	0x00031fea
   1496c:	00032007 	.word	0x00032007

00014970 <interrupt_event>:
	int2_event = true;
   14970:	2201      	movs	r2, #1
   14972:	4b01      	ldr	r3, [pc, #4]	; (14978 <interrupt_event+0x8>)
   14974:	701a      	strb	r2, [r3, #0]
}
   14976:	4770      	bx	lr
   14978:	2002ff34 	.word	0x2002ff34

0001497c <step_event>:
	int1_event = true;
   1497c:	2201      	movs	r2, #1
   1497e:	4b01      	ldr	r3, [pc, #4]	; (14984 <step_event+0x8>)
   14980:	701a      	strb	r2, [r3, #0]
}
   14982:	4770      	bx	lr
   14984:	2002ff2e 	.word	0x2002ff2e

00014988 <platform_write>:
{
   14988:	b5b0      	push	{r4, r5, r7, lr}
   1498a:	b084      	sub	sp, #16
	uint8_t data[len+1];
   1498c:	4668      	mov	r0, sp
{
   1498e:	4615      	mov	r5, r2
	uint8_t data[len+1];
   14990:	f103 0208 	add.w	r2, r3, #8
   14994:	08d2      	lsrs	r2, r2, #3
   14996:	eba0 02c2 	sub.w	r2, r0, r2, lsl #3
{
   1499a:	af00      	add	r7, sp, #0
	uint8_t data[len+1];
   1499c:	4695      	mov	sp, r2
	data[0] = reg;
   1499e:	4668      	mov	r0, sp
   149a0:	461a      	mov	r2, r3
   149a2:	f800 1b01 	strb.w	r1, [r0], #1
   149a6:	4629      	mov	r1, r5
	uint8_t data[len+1];
   149a8:	1c5c      	adds	r4, r3, #1
   149aa:	f01a fcd3 	bl	2f354 <memcpy>
	rslt = i2c_write(i2c_imu, data, len+1, LSM6DSO_I2C_ADD);
   149ae:	4b08      	ldr	r3, [pc, #32]	; (149d0 <platform_write+0x48>)
static inline int i2c_write(struct device *dev, const u8_t *buf,
			    u32_t num_bytes, u16_t addr)
{
	struct i2c_msg msg;

	msg.buf = (u8_t *)buf;
   149b0:	f8c7 d004 	str.w	sp, [r7, #4]
   149b4:	6818      	ldr	r0, [r3, #0]
	msg.len = num_bytes;
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   149b6:	2302      	movs	r3, #2
	msg.len = num_bytes;
   149b8:	60bc      	str	r4, [r7, #8]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   149ba:	733b      	strb	r3, [r7, #12]
	return api->transfer(dev, msgs, num_msgs, addr);
   149bc:	6843      	ldr	r3, [r0, #4]
   149be:	1d39      	adds	r1, r7, #4
   149c0:	685c      	ldr	r4, [r3, #4]
   149c2:	2201      	movs	r2, #1
   149c4:	236a      	movs	r3, #106	; 0x6a
   149c6:	47a0      	blx	r4
}
   149c8:	3710      	adds	r7, #16
   149ca:	46bd      	mov	sp, r7
   149cc:	bdb0      	pop	{r4, r5, r7, pc}
   149ce:	bf00      	nop
   149d0:	20027e64 	.word	0x20027e64

000149d4 <platform_read>:
{
   149d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   149d8:	b086      	sub	sp, #24
   149da:	461e      	mov	r6, r3
	msg.buf = (u8_t *)buf;
   149dc:	f10d 0307 	add.w	r3, sp, #7
   149e0:	9303      	str	r3, [sp, #12]
	msg.len = num_bytes;
   149e2:	2401      	movs	r4, #1
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   149e4:	2302      	movs	r3, #2
	rslt = i2c_write(i2c_imu, &reg, 1, LSM6DSO_I2C_ADD);
   149e6:	4d0f      	ldr	r5, [pc, #60]	; (14a24 <platform_read+0x50>)
{
   149e8:	4617      	mov	r7, r2
   149ea:	f88d 1007 	strb.w	r1, [sp, #7]
	rslt = i2c_write(i2c_imu, &reg, 1, LSM6DSO_I2C_ADD);
   149ee:	6828      	ldr	r0, [r5, #0]
	msg.len = num_bytes;
   149f0:	9404      	str	r4, [sp, #16]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   149f2:	f88d 3014 	strb.w	r3, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   149f6:	6843      	ldr	r3, [r0, #4]
   149f8:	4622      	mov	r2, r4
   149fa:	f8d3 8004 	ldr.w	r8, [r3, #4]
   149fe:	a903      	add	r1, sp, #12
   14a00:	236a      	movs	r3, #106	; 0x6a
   14a02:	47c0      	blx	r8
	if(rslt == 0)
   14a04:	b958      	cbnz	r0, 14a1e <platform_read+0x4a>
{
	struct i2c_msg msg;

	msg.buf = buf;
	msg.len = num_bytes;
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
   14a06:	2303      	movs	r3, #3
		rslt = i2c_read(i2c_imu, bufp, len, LSM6DSO_I2C_ADD);
   14a08:	6828      	ldr	r0, [r5, #0]
   14a0a:	e9cd 7603 	strd	r7, r6, [sp, #12]
   14a0e:	f88d 3014 	strb.w	r3, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   14a12:	6843      	ldr	r3, [r0, #4]
   14a14:	4622      	mov	r2, r4
   14a16:	685d      	ldr	r5, [r3, #4]
   14a18:	a903      	add	r1, sp, #12
   14a1a:	236a      	movs	r3, #106	; 0x6a
   14a1c:	47a8      	blx	r5
}
   14a1e:	b006      	add	sp, #24
   14a20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14a24:	20027e64 	.word	0x20027e64

00014a28 <init_gpio>:
{
   14a28:	b510      	push	{r4, lr}
   14a2a:	4820      	ldr	r0, [pc, #128]	; (14aac <init_gpio+0x84>)
   14a2c:	f011 fbcc 	bl	261c8 <z_impl_device_get_binding>
	gpio_imu = device_get_binding(IMU_PORT);
   14a30:	4c1f      	ldr	r4, [pc, #124]	; (14ab0 <init_gpio+0x88>)
	gpio_pin_configure(gpio_imu, LSM6DSO_INT1_PIN, flag);
   14a32:	f240 2236 	movw	r2, #566	; 0x236
   14a36:	2109      	movs	r1, #9
	gpio_imu = device_get_binding(IMU_PORT);
   14a38:	6020      	str	r0, [r4, #0]
	gpio_pin_configure(gpio_imu, LSM6DSO_INT1_PIN, flag);
   14a3a:	f016 fedb 	bl	2b7f4 <gpio_pin_configure>
	gpio_pin_disable_callback(gpio_imu, LSM6DSO_INT1_PIN);
   14a3e:	2109      	movs	r1, #9
   14a40:	6820      	ldr	r0, [r4, #0]
   14a42:	f016 fec5 	bl	2b7d0 <gpio_pin_disable_callback>
	callback->handler = handler;
   14a46:	491b      	ldr	r1, [pc, #108]	; (14ab4 <init_gpio+0x8c>)
   14a48:	4b1b      	ldr	r3, [pc, #108]	; (14ab8 <init_gpio+0x90>)
	gpio_add_callback(gpio_imu, &gpio_cb1);
   14a4a:	6820      	ldr	r0, [r4, #0]
   14a4c:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
   14a4e:	f44f 7300 	mov.w	r3, #512	; 0x200
   14a52:	608b      	str	r3, [r1, #8]
   14a54:	f016 fe47 	bl	2b6e6 <gpio_add_callback>
	gpio_pin_enable_callback(gpio_imu, LSM6DSO_INT1_PIN);
   14a58:	2109      	movs	r1, #9
   14a5a:	6820      	ldr	r0, [r4, #0]
   14a5c:	f016 fec1 	bl	2b7e2 <gpio_pin_enable_callback>
	gpio_pin_configure(gpio_imu, LSM6DSO_INT2_PIN, flag);
   14a60:	f240 2236 	movw	r2, #566	; 0x236
   14a64:	210a      	movs	r1, #10
   14a66:	6820      	ldr	r0, [r4, #0]
   14a68:	f016 fec4 	bl	2b7f4 <gpio_pin_configure>
	gpio_pin_disable_callback(gpio_imu, LSM6DSO_INT2_PIN);
   14a6c:	210a      	movs	r1, #10
   14a6e:	6820      	ldr	r0, [r4, #0]
   14a70:	f016 feae 	bl	2b7d0 <gpio_pin_disable_callback>
	callback->handler = handler;
   14a74:	4911      	ldr	r1, [pc, #68]	; (14abc <init_gpio+0x94>)
   14a76:	4b12      	ldr	r3, [pc, #72]	; (14ac0 <init_gpio+0x98>)
	gpio_add_callback(gpio_imu, &gpio_cb2);
   14a78:	6820      	ldr	r0, [r4, #0]
   14a7a:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
   14a7c:	f44f 6380 	mov.w	r3, #1024	; 0x400
   14a80:	608b      	str	r3, [r1, #8]
   14a82:	f016 fe30 	bl	2b6e6 <gpio_add_callback>
	gpio_pin_enable_callback(gpio_imu, LSM6DSO_INT2_PIN);
   14a86:	210a      	movs	r1, #10
   14a88:	6820      	ldr	r0, [r4, #0]
   14a8a:	f016 feaa 	bl	2b7e2 <gpio_pin_enable_callback>
	gpio_pin_configure(gpio_imu, 17, GPIO_DIR_OUT);
   14a8e:	2201      	movs	r2, #1
   14a90:	2111      	movs	r1, #17
   14a92:	6820      	ldr	r0, [r4, #0]
   14a94:	f016 feae 	bl	2b7f4 <gpio_pin_configure>
	gpio_pin_write(gpio_imu, 17, 0);
   14a98:	6820      	ldr	r0, [r4, #0]
	return api->write(port, access_op, pin, value);
   14a9a:	6843      	ldr	r3, [r0, #4]
   14a9c:	2211      	movs	r2, #17
   14a9e:	685c      	ldr	r4, [r3, #4]
   14aa0:	2300      	movs	r3, #0
   14aa2:	4619      	mov	r1, r3
   14aa4:	47a0      	blx	r4
}
   14aa6:	2000      	movs	r0, #0
   14aa8:	bd10      	pop	{r4, pc}
   14aaa:	bf00      	nop
   14aac:	000310d7 	.word	0x000310d7
   14ab0:	20024620 	.word	0x20024620
   14ab4:	20024608 	.word	0x20024608
   14ab8:	0001497d 	.word	0x0001497d
   14abc:	20024614 	.word	0x20024614
   14ac0:	00014971 	.word	0x00014971

00014ac4 <sensor_init>:
{
   14ac4:	b570      	push	{r4, r5, r6, lr}
	lsm6dso_device_id_get(&imu_dev_ctx, &whoamI);
   14ac6:	4c64      	ldr	r4, [pc, #400]	; (14c58 <sensor_init+0x194>)
   14ac8:	4864      	ldr	r0, [pc, #400]	; (14c5c <sensor_init+0x198>)
   14aca:	4621      	mov	r1, r4
   14acc:	f017 f94c 	bl	2bd68 <lsm6dso_device_id_get>
	if(whoamI != LSM6DSO_ID)
   14ad0:	7823      	ldrb	r3, [r4, #0]
   14ad2:	2b6c      	cmp	r3, #108	; 0x6c
   14ad4:	d000      	beq.n	14ad8 <sensor_init+0x14>
		while(1);
   14ad6:	e7fe      	b.n	14ad6 <sensor_init+0x12>
	lsm6dso_reset_set(&imu_dev_ctx, PROPERTY_ENABLE);
   14ad8:	2101      	movs	r1, #1
   14ada:	4860      	ldr	r0, [pc, #384]	; (14c5c <sensor_init+0x198>)
   14adc:	f017 f949 	bl	2bd72 <lsm6dso_reset_set>
		lsm6dso_reset_get(&imu_dev_ctx, &rst);
   14ae0:	4d5f      	ldr	r5, [pc, #380]	; (14c60 <sensor_init+0x19c>)
   14ae2:	4e5e      	ldr	r6, [pc, #376]	; (14c5c <sensor_init+0x198>)
   14ae4:	495e      	ldr	r1, [pc, #376]	; (14c60 <sensor_init+0x19c>)
   14ae6:	4630      	mov	r0, r6
   14ae8:	f017 f95a 	bl	2bda0 <lsm6dso_reset_get>
	}while(rst);
   14aec:	782c      	ldrb	r4, [r5, #0]
   14aee:	2c00      	cmp	r4, #0
   14af0:	d1f8      	bne.n	14ae4 <sensor_init+0x20>
	lsm6dso_i3c_disable_set(&imu_dev_ctx, LSM6DSO_I3C_DISABLE);
   14af2:	2180      	movs	r1, #128	; 0x80
   14af4:	4859      	ldr	r0, [pc, #356]	; (14c5c <sensor_init+0x198>)
   14af6:	f017 f961 	bl	2bdbc <lsm6dso_i3c_disable_set>
	lsm6dso_xl_full_scale_set(&imu_dev_ctx, LSM6DSO_2g);
   14afa:	4621      	mov	r1, r4
   14afc:	4857      	ldr	r0, [pc, #348]	; (14c5c <sensor_init+0x198>)
   14afe:	f016 fe91 	bl	2b824 <lsm6dso_xl_full_scale_set>
	lsm6dso_gy_full_scale_set(&imu_dev_ctx, LSM6DSO_250dps);
   14b02:	4621      	mov	r1, r4
   14b04:	4855      	ldr	r0, [pc, #340]	; (14c5c <sensor_init+0x198>)
   14b06:	f016 fea4 	bl	2b852 <lsm6dso_gy_full_scale_set>
	lsm6dso_block_data_update_set(&imu_dev_ctx, PROPERTY_ENABLE);
   14b0a:	2101      	movs	r1, #1
   14b0c:	4853      	ldr	r0, [pc, #332]	; (14c5c <sensor_init+0x198>)
   14b0e:	f016 feb7 	bl	2b880 <lsm6dso_block_data_update_set>
	lsm6dso_fifo_watermark_set(&imu_dev_ctx, PATTERN_LEN);
   14b12:	f44f 71c8 	mov.w	r1, #400	; 0x190
   14b16:	4851      	ldr	r0, [pc, #324]	; (14c5c <sensor_init+0x198>)
   14b18:	f017 fcbb 	bl	2c492 <lsm6dso_fifo_watermark_set>
	lsm6dso_fifo_stop_on_wtm_set(&imu_dev_ctx, PROPERTY_ENABLE);
   14b1c:	2101      	movs	r1, #1
   14b1e:	484f      	ldr	r0, [pc, #316]	; (14c5c <sensor_init+0x198>)
   14b20:	f017 fcd8 	bl	2c4d4 <lsm6dso_fifo_stop_on_wtm_set>
	lsm6dso_fifo_mode_set(&imu_dev_ctx, LSM6DSO_STREAM_TO_FIFO_MODE);
   14b24:	2103      	movs	r1, #3
   14b26:	484d      	ldr	r0, [pc, #308]	; (14c5c <sensor_init+0x198>)
   14b28:	f017 fd19 	bl	2c55e <lsm6dso_fifo_mode_set>
	lsm6dso_fifo_xl_batch_set(&imu_dev_ctx, LSM6DSO_XL_BATCHED_AT_104Hz);
   14b2c:	2104      	movs	r1, #4
   14b2e:	484b      	ldr	r0, [pc, #300]	; (14c5c <sensor_init+0x198>)
   14b30:	f017 fce7 	bl	2c502 <lsm6dso_fifo_xl_batch_set>
	lsm6dso_fifo_gy_batch_set(&imu_dev_ctx, LSM6DSO_GY_BATCHED_AT_104Hz);
   14b34:	2104      	movs	r1, #4
   14b36:	4849      	ldr	r0, [pc, #292]	; (14c5c <sensor_init+0x198>)
   14b38:	f017 fcfa 	bl	2c530 <lsm6dso_fifo_gy_batch_set>
	lsm6dso_xl_data_rate_set(&imu_dev_ctx, LSM6DSO_XL_ODR_104Hz);
   14b3c:	2104      	movs	r1, #4
   14b3e:	4847      	ldr	r0, [pc, #284]	; (14c5c <sensor_init+0x198>)
   14b40:	f017 febf 	bl	2c8c2 <lsm6dso_xl_data_rate_set>
	lsm6dso_gy_data_rate_set(&imu_dev_ctx, LSM6DSO_GY_ODR_104Hz);
   14b44:	2104      	movs	r1, #4
   14b46:	4845      	ldr	r0, [pc, #276]	; (14c5c <sensor_init+0x198>)
   14b48:	f017 ff28 	bl	2c99c <lsm6dso_gy_data_rate_set>
	lsm6dso_xl_power_mode_set(&imu_dev_ctx, LSM6DSO_LOW_NORMAL_POWER_MD);
   14b4c:	2101      	movs	r1, #1
   14b4e:	4843      	ldr	r0, [pc, #268]	; (14c5c <sensor_init+0x198>)
   14b50:	f016 fead 	bl	2b8ae <lsm6dso_xl_power_mode_set>
	lsm6dso_tap_detection_on_z_set(&imu_dev_ctx, PROPERTY_ENABLE);
   14b54:	2101      	movs	r1, #1
   14b56:	4841      	ldr	r0, [pc, #260]	; (14c5c <sensor_init+0x198>)
   14b58:	f017 fbcc 	bl	2c2f4 <lsm6dso_tap_detection_on_z_set>
	lsm6dso_tap_detection_on_y_set(&imu_dev_ctx, PROPERTY_ENABLE);
   14b5c:	2101      	movs	r1, #1
   14b5e:	483f      	ldr	r0, [pc, #252]	; (14c5c <sensor_init+0x198>)
   14b60:	f017 fbdf 	bl	2c322 <lsm6dso_tap_detection_on_y_set>
	lsm6dso_tap_detection_on_x_set(&imu_dev_ctx, PROPERTY_ENABLE);
   14b64:	2101      	movs	r1, #1
   14b66:	483d      	ldr	r0, [pc, #244]	; (14c5c <sensor_init+0x198>)
   14b68:	f017 fbf2 	bl	2c350 <lsm6dso_tap_detection_on_x_set>
	lsm6dso_tap_threshold_x_set(&imu_dev_ctx, 0x12);
   14b6c:	2112      	movs	r1, #18
   14b6e:	483b      	ldr	r0, [pc, #236]	; (14c5c <sensor_init+0x198>)
   14b70:	f017 fc05 	bl	2c37e <lsm6dso_tap_threshold_x_set>
	lsm6dso_tap_threshold_y_set(&imu_dev_ctx, 0x12);
   14b74:	2112      	movs	r1, #18
   14b76:	4839      	ldr	r0, [pc, #228]	; (14c5c <sensor_init+0x198>)
   14b78:	f017 fc18 	bl	2c3ac <lsm6dso_tap_threshold_y_set>
	lsm6dso_tap_threshold_z_set(&imu_dev_ctx, 0x12);
   14b7c:	2112      	movs	r1, #18
   14b7e:	4837      	ldr	r0, [pc, #220]	; (14c5c <sensor_init+0x198>)
   14b80:	f017 fc2b 	bl	2c3da <lsm6dso_tap_threshold_z_set>
	lsm6dso_tap_quiet_set(&imu_dev_ctx, 0x03);
   14b84:	2103      	movs	r1, #3
   14b86:	4835      	ldr	r0, [pc, #212]	; (14c5c <sensor_init+0x198>)
   14b88:	f017 fc55 	bl	2c436 <lsm6dso_tap_quiet_set>
	lsm6dso_tap_shock_set(&imu_dev_ctx, 0x03);
   14b8c:	2103      	movs	r1, #3
   14b8e:	4833      	ldr	r0, [pc, #204]	; (14c5c <sensor_init+0x198>)
   14b90:	f017 fc3a 	bl	2c408 <lsm6dso_tap_shock_set>
	lsm6dso_tap_mode_set(&imu_dev_ctx, LSM6DSO_ONLY_SINGLE);
   14b94:	4621      	mov	r1, r4
   14b96:	4831      	ldr	r0, [pc, #196]	; (14c5c <sensor_init+0x198>)
   14b98:	f017 fc64 	bl	2c464 <lsm6dso_tap_mode_set>
	lsm6dso_pedo_sens_set(&imu_dev_ctx, LSM6DSO_PEDO_BASE_MODE);
   14b9c:	2101      	movs	r1, #1
   14b9e:	482f      	ldr	r0, [pc, #188]	; (14c5c <sensor_init+0x198>)
   14ba0:	f017 fd64 	bl	2c66c <lsm6dso_pedo_sens_set>
	lsm6dso_int_notification_set(&imu_dev_ctx, LSM6DSO_BASE_PULSED_EMB_LATCHED);
   14ba4:	2102      	movs	r1, #2
   14ba6:	482d      	ldr	r0, [pc, #180]	; (14c5c <sensor_init+0x198>)
   14ba8:	f017 fb6a 	bl	2c280 <lsm6dso_int_notification_set>
	lsm6dso_long_cnt_int_value_set(&imu_dev_ctx, 0x0000U);
   14bac:	4621      	mov	r1, r4
   14bae:	482b      	ldr	r0, [pc, #172]	; (14c5c <sensor_init+0x198>)
   14bb0:	f017 ff61 	bl	2ca76 <lsm6dso_long_cnt_int_value_set>
	lsm6dso_fsm_enable_get(&imu_dev_ctx, &fsm_enable);
   14bb4:	4c2b      	ldr	r4, [pc, #172]	; (14c64 <sensor_init+0x1a0>)
	lsm6dso_fsm_start_address_set(&imu_dev_ctx, LSM6DSO_START_FSM_ADD);
   14bb6:	f44f 6180 	mov.w	r1, #1024	; 0x400
   14bba:	4828      	ldr	r0, [pc, #160]	; (14c5c <sensor_init+0x198>)
   14bbc:	f017 ff7e 	bl	2cabc <lsm6dso_fsm_start_address_set>
	lsm6dso_fsm_number_of_programs_set(&imu_dev_ctx, 2);
   14bc0:	2102      	movs	r1, #2
   14bc2:	4826      	ldr	r0, [pc, #152]	; (14c5c <sensor_init+0x198>)
   14bc4:	f017 ff6e 	bl	2caa4 <lsm6dso_fsm_number_of_programs_set>
	lsm6dso_fsm_enable_get(&imu_dev_ctx, &fsm_enable);
   14bc8:	4621      	mov	r1, r4
   14bca:	4824      	ldr	r0, [pc, #144]	; (14c5c <sensor_init+0x198>)
   14bcc:	f017 fe18 	bl	2c800 <lsm6dso_fsm_enable_get>
	fsm_enable.fsm_enable_a.fsm1_en = PROPERTY_ENABLE;
   14bd0:	7823      	ldrb	r3, [r4, #0]
	lsm6dso_fsm_enable_set(&imu_dev_ctx, &fsm_enable);
   14bd2:	4621      	mov	r1, r4
	fsm_enable.fsm_enable_a.fsm1_en = PROPERTY_ENABLE;
   14bd4:	f023 0303 	bic.w	r3, r3, #3
   14bd8:	f043 0303 	orr.w	r3, r3, #3
   14bdc:	7023      	strb	r3, [r4, #0]
	lsm6dso_fsm_enable_set(&imu_dev_ctx, &fsm_enable);
   14bde:	481f      	ldr	r0, [pc, #124]	; (14c5c <sensor_init+0x198>)
   14be0:	f017 fdac 	bl	2c73c <lsm6dso_fsm_enable_set>
	lsm6dso_fsm_data_rate_set(&imu_dev_ctx, LSM6DSO_ODR_FSM_26Hz);
   14be4:	2101      	movs	r1, #1
   14be6:	481d      	ldr	r0, [pc, #116]	; (14c5c <sensor_init+0x198>)
   14be8:	f017 fe1f 	bl	2c82a <lsm6dso_fsm_data_rate_set>
	fsm_addr = LSM6DSO_START_FSM_ADD;
   14bec:	f44f 6180 	mov.w	r1, #1024	; 0x400
   14bf0:	4c1d      	ldr	r4, [pc, #116]	; (14c68 <sensor_init+0x1a4>)
	lsm6dso_ln_pg_write(&imu_dev_ctx, fsm_addr, (uint8_t*)lsm6so_prg_wrist_tilt,
   14bf2:	2314      	movs	r3, #20
   14bf4:	4a1d      	ldr	r2, [pc, #116]	; (14c6c <sensor_init+0x1a8>)
   14bf6:	4819      	ldr	r0, [pc, #100]	; (14c5c <sensor_init+0x198>)
	fsm_addr = LSM6DSO_START_FSM_ADD;
   14bf8:	8021      	strh	r1, [r4, #0]
	lsm6dso_ln_pg_write(&imu_dev_ctx, fsm_addr, (uint8_t*)lsm6so_prg_wrist_tilt,
   14bfa:	f016 ffa9 	bl	2bb50 <lsm6dso_ln_pg_write>
	fsm_addr += sizeof(lsm6so_prg_wrist_tilt);
   14bfe:	8821      	ldrh	r1, [r4, #0]
	lsm6dso_ln_pg_write(&imu_dev_ctx, fsm_addr, (uint8_t*)falltrigger,
   14c00:	4a1b      	ldr	r2, [pc, #108]	; (14c70 <sensor_init+0x1ac>)
	fsm_addr += sizeof(lsm6so_prg_wrist_tilt);
   14c02:	3114      	adds	r1, #20
   14c04:	b289      	uxth	r1, r1
   14c06:	8021      	strh	r1, [r4, #0]
	lsm6dso_pin_int2_route_get(&imu_dev_ctx, &int2_route);
   14c08:	4c1a      	ldr	r4, [pc, #104]	; (14c74 <sensor_init+0x1b0>)
	lsm6dso_ln_pg_write(&imu_dev_ctx, fsm_addr, (uint8_t*)falltrigger,
   14c0a:	2318      	movs	r3, #24
   14c0c:	4813      	ldr	r0, [pc, #76]	; (14c5c <sensor_init+0x198>)
   14c0e:	f016 ff9f 	bl	2bb50 <lsm6dso_ln_pg_write>
	lsm6dso_pin_int2_route_get(&imu_dev_ctx, &int2_route);
   14c12:	4621      	mov	r1, r4
   14c14:	4811      	ldr	r0, [pc, #68]	; (14c5c <sensor_init+0x198>)
   14c16:	f017 fa18 	bl	2c04a <lsm6dso_pin_int2_route_get>
	int2_route.md2_cfg.int2_single_tap = PROPERTY_ENABLE;
   14c1a:	7863      	ldrb	r3, [r4, #1]
	lsm6dso_pin_int2_route_set(&imu_dev_ctx, &int2_route);
   14c1c:	4621      	mov	r1, r4
	int2_route.md2_cfg.int2_single_tap = PROPERTY_ENABLE;
   14c1e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   14c22:	7063      	strb	r3, [r4, #1]
	lsm6dso_pin_int1_route_get(&imu_dev_ctx, &int1_route);
   14c24:	4c14      	ldr	r4, [pc, #80]	; (14c78 <sensor_init+0x1b4>)
	lsm6dso_pin_int2_route_set(&imu_dev_ctx, &int2_route);
   14c26:	480d      	ldr	r0, [pc, #52]	; (14c5c <sensor_init+0x198>)
   14c28:	f017 f925 	bl	2be76 <lsm6dso_pin_int2_route_set>
	lsm6dso_pin_int1_route_get(&imu_dev_ctx, &int1_route);
   14c2c:	4621      	mov	r1, r4
   14c2e:	480b      	ldr	r0, [pc, #44]	; (14c5c <sensor_init+0x198>)
   14c30:	f017 f8f0 	bl	2be14 <lsm6dso_pin_int1_route_get>
	int1_route.emb_func_int1.int1_step_detector = PROPERTY_ENABLE;
   14c34:	78a3      	ldrb	r3, [r4, #2]
	lsm6dso_pin_int1_route_set(&imu_dev_ctx, &int1_route);
   14c36:	4621      	mov	r1, r4
	int1_route.emb_func_int1.int1_step_detector = PROPERTY_ENABLE;
   14c38:	f043 0308 	orr.w	r3, r3, #8
   14c3c:	70a3      	strb	r3, [r4, #2]
	int1_route.fsm_int1_a.int1_fsm1 = PROPERTY_ENABLE;
   14c3e:	78e3      	ldrb	r3, [r4, #3]
	lsm6dso_pin_int1_route_set(&imu_dev_ctx, &int1_route);
   14c40:	4806      	ldr	r0, [pc, #24]	; (14c5c <sensor_init+0x198>)
	int1_route.fsm_int1_a.int1_fsm1 = PROPERTY_ENABLE;
   14c42:	f043 0301 	orr.w	r3, r3, #1
   14c46:	70e3      	strb	r3, [r4, #3]
	lsm6dso_pin_int1_route_set(&imu_dev_ctx, &int1_route);
   14c48:	f017 fa30 	bl	2c0ac <lsm6dso_pin_int1_route_set>
}
   14c4c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	lsm6dso_timestamp_set(&imu_dev_ctx, 1);
   14c50:	2101      	movs	r1, #1
   14c52:	4802      	ldr	r0, [pc, #8]	; (14c5c <sensor_init+0x198>)
   14c54:	f016 be65 	b.w	2b922 <lsm6dso_timestamp_set>
   14c58:	2002ff3c 	.word	0x2002ff3c
   14c5c:	20027e68 	.word	0x20027e68
   14c60:	2002ff3b 	.word	0x2002ff3b
   14c64:	2002ff2b 	.word	0x2002ff2b
   14c68:	2002d476 	.word	0x2002d476
   14c6c:	000320ca 	.word	0x000320ca
   14c70:	000320b2 	.word	0x000320b2
   14c74:	2002ff35 	.word	0x2002ff35
   14c78:	2002ff2f 	.word	0x2002ff2f

00014c7c <sensor_reset>:
{  
   14c7c:	b538      	push	{r3, r4, r5, lr}
	lsm6dso_reset_set(&imu_dev_ctx, PROPERTY_ENABLE);
   14c7e:	2101      	movs	r1, #1
   14c80:	481e      	ldr	r0, [pc, #120]	; (14cfc <sensor_reset+0x80>)
   14c82:	f017 f876 	bl	2bd72 <lsm6dso_reset_set>
		lsm6dso_reset_get(&imu_dev_ctx, &rst);
   14c86:	4d1e      	ldr	r5, [pc, #120]	; (14d00 <sensor_reset+0x84>)
   14c88:	491d      	ldr	r1, [pc, #116]	; (14d00 <sensor_reset+0x84>)
   14c8a:	481c      	ldr	r0, [pc, #112]	; (14cfc <sensor_reset+0x80>)
   14c8c:	f017 f888 	bl	2bda0 <lsm6dso_reset_get>
	}while(rst);
   14c90:	782c      	ldrb	r4, [r5, #0]
   14c92:	2c00      	cmp	r4, #0
   14c94:	d1f8      	bne.n	14c88 <sensor_reset+0xc>
	lsm6dso_i3c_disable_set(&imu_dev_ctx, LSM6DSO_I3C_DISABLE);
   14c96:	2180      	movs	r1, #128	; 0x80
   14c98:	4818      	ldr	r0, [pc, #96]	; (14cfc <sensor_reset+0x80>)
   14c9a:	f017 f88f 	bl	2bdbc <lsm6dso_i3c_disable_set>
	lsm6dso_fifo_watermark_set(&imu_dev_ctx, ACC_GYRO_FIFO_BUF_LEN);
   14c9e:	21c8      	movs	r1, #200	; 0xc8
   14ca0:	4816      	ldr	r0, [pc, #88]	; (14cfc <sensor_reset+0x80>)
   14ca2:	f017 fbf6 	bl	2c492 <lsm6dso_fifo_watermark_set>
	lsm6dso_fifo_stop_on_wtm_set(&imu_dev_ctx, PROPERTY_ENABLE);
   14ca6:	2101      	movs	r1, #1
   14ca8:	4814      	ldr	r0, [pc, #80]	; (14cfc <sensor_reset+0x80>)
   14caa:	f017 fc13 	bl	2c4d4 <lsm6dso_fifo_stop_on_wtm_set>
	lsm6dso_fifo_mode_set(&imu_dev_ctx, LSM6DSO_STREAM_MODE);
   14cae:	2106      	movs	r1, #6
   14cb0:	4812      	ldr	r0, [pc, #72]	; (14cfc <sensor_reset+0x80>)
   14cb2:	f017 fc54 	bl	2c55e <lsm6dso_fifo_mode_set>
	lsm6dso_data_ready_mode_set(&imu_dev_ctx, LSM6DSO_DRDY_PULSED);
   14cb6:	2101      	movs	r1, #1
   14cb8:	4810      	ldr	r0, [pc, #64]	; (14cfc <sensor_reset+0x80>)
   14cba:	f017 f83e 	bl	2bd3a <lsm6dso_data_ready_mode_set>
	lsm6dso_fifo_xl_batch_set(&imu_dev_ctx, LSM6DSO_XL_BATCHED_AT_104Hz);
   14cbe:	2104      	movs	r1, #4
   14cc0:	480e      	ldr	r0, [pc, #56]	; (14cfc <sensor_reset+0x80>)
   14cc2:	f017 fc1e 	bl	2c502 <lsm6dso_fifo_xl_batch_set>
	lsm6dso_fifo_gy_batch_set(&imu_dev_ctx, LSM6DSO_GY_BATCHED_AT_104Hz);
   14cc6:	2104      	movs	r1, #4
   14cc8:	480c      	ldr	r0, [pc, #48]	; (14cfc <sensor_reset+0x80>)
   14cca:	f017 fc31 	bl	2c530 <lsm6dso_fifo_gy_batch_set>
	lsm6dso_xl_full_scale_set(&imu_dev_ctx, LSM6DSO_2g);
   14cce:	4621      	mov	r1, r4
   14cd0:	480a      	ldr	r0, [pc, #40]	; (14cfc <sensor_reset+0x80>)
   14cd2:	f016 fda7 	bl	2b824 <lsm6dso_xl_full_scale_set>
	lsm6dso_gy_full_scale_set(&imu_dev_ctx, LSM6DSO_250dps);
   14cd6:	4621      	mov	r1, r4
   14cd8:	4808      	ldr	r0, [pc, #32]	; (14cfc <sensor_reset+0x80>)
   14cda:	f016 fdba 	bl	2b852 <lsm6dso_gy_full_scale_set>
	lsm6dso_block_data_update_set(&imu_dev_ctx, PROPERTY_ENABLE);
   14cde:	2101      	movs	r1, #1
   14ce0:	4806      	ldr	r0, [pc, #24]	; (14cfc <sensor_reset+0x80>)
   14ce2:	f016 fdcd 	bl	2b880 <lsm6dso_block_data_update_set>
	lsm6dso_xl_data_rate_set(&imu_dev_ctx, LSM6DSO_XL_ODR_104Hz);
   14ce6:	2104      	movs	r1, #4
   14ce8:	4804      	ldr	r0, [pc, #16]	; (14cfc <sensor_reset+0x80>)
   14cea:	f017 fdea 	bl	2c8c2 <lsm6dso_xl_data_rate_set>
}
   14cee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	lsm6dso_gy_data_rate_set(&imu_dev_ctx, LSM6DSO_GY_ODR_104Hz);
   14cf2:	2104      	movs	r1, #4
   14cf4:	4801      	ldr	r0, [pc, #4]	; (14cfc <sensor_reset+0x80>)
   14cf6:	f017 be51 	b.w	2c99c <lsm6dso_gy_data_rate_set>
   14cfa:	bf00      	nop
   14cfc:	20027e68 	.word	0x20027e68
   14d00:	2002ff3b 	.word	0x2002ff3b

00014d04 <get_sensor_reading>:
{
   14d04:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   14d08:	4680      	mov	r8, r0
   14d0a:	460f      	mov	r7, r1
	lsm6dso_xl_flag_data_ready_get(&imu_dev_ctx, &reg);
   14d0c:	4816      	ldr	r0, [pc, #88]	; (14d68 <get_sensor_reading+0x64>)
   14d0e:	f10d 0107 	add.w	r1, sp, #7
{
   14d12:	4616      	mov	r6, r2
	lsm6dso_xl_flag_data_ready_get(&imu_dev_ctx, &reg);
   14d14:	f016 fdf7 	bl	2b906 <lsm6dso_xl_flag_data_ready_get>
	if(reg)
   14d18:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14d1c:	4c13      	ldr	r4, [pc, #76]	; (14d6c <get_sensor_reading+0x68>)
   14d1e:	b1cb      	cbz	r3, 14d54 <get_sensor_reading+0x50>
		memset(data_raw_acceleration.u8bit, 0x00, 3*sizeof(int16_t));
   14d20:	2300      	movs	r3, #0
   14d22:	4d13      	ldr	r5, [pc, #76]	; (14d70 <get_sensor_reading+0x6c>)
		lsm6dso_acceleration_raw_get(&imu_dev_ctx, data_raw_acceleration.u8bit);
   14d24:	4810      	ldr	r0, [pc, #64]	; (14d68 <get_sensor_reading+0x64>)
   14d26:	4629      	mov	r1, r5
		memset(data_raw_acceleration.u8bit, 0x00, 3*sizeof(int16_t));
   14d28:	602b      	str	r3, [r5, #0]
   14d2a:	80ab      	strh	r3, [r5, #4]
		lsm6dso_acceleration_raw_get(&imu_dev_ctx, data_raw_acceleration.u8bit);
   14d2c:	f016 fe10 	bl	2b950 <lsm6dso_acceleration_raw_get>
		acceleration_mg[0] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[0]);
   14d30:	f9b5 0000 	ldrsh.w	r0, [r5]
   14d34:	f000 fc60 	bl	155f8 <lsm6dso_from_fs2_to_mg>
		acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   14d38:	f9b5 0002 	ldrsh.w	r0, [r5, #2]
		acceleration_mg[0] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[0]);
   14d3c:	ed84 0a00 	vstr	s0, [r4]
		acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   14d40:	f000 fc5a 	bl	155f8 <lsm6dso_from_fs2_to_mg>
		acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   14d44:	f9b5 0004 	ldrsh.w	r0, [r5, #4]
		acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   14d48:	ed84 0a01 	vstr	s0, [r4, #4]
		acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   14d4c:	f000 fc54 	bl	155f8 <lsm6dso_from_fs2_to_mg>
   14d50:	ed84 0a02 	vstr	s0, [r4, #8]
	*sensor_x = acceleration_mg[0];
   14d54:	6823      	ldr	r3, [r4, #0]
   14d56:	f8c8 3000 	str.w	r3, [r8]
	*sensor_y = acceleration_mg[1];
   14d5a:	6863      	ldr	r3, [r4, #4]
   14d5c:	603b      	str	r3, [r7, #0]
	*sensor_z = acceleration_mg[2];
   14d5e:	68a3      	ldr	r3, [r4, #8]
   14d60:	6033      	str	r3, [r6, #0]
}
   14d62:	b002      	add	sp, #8
   14d64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14d68:	20027e68 	.word	0x20027e68
   14d6c:	200245e4 	.word	0x200245e4
   14d70:	2002d46a 	.word	0x2002d46a

00014d74 <historic_buffer>:
{
   14d74:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
	uint16_t i = 0;
   14d78:	2500      	movs	r5, #0
	uint16_t histBuff_counter = 0;
   14d7a:	462c      	mov	r4, r5
		lsm6dso_fifo_wtm_flag_get(&imu_dev_ctx, &waterm);
   14d7c:	4e53      	ldr	r6, [pc, #332]	; (14ecc <historic_buffer+0x158>)
					memset(data_raw_angular_rate.u8bit, 0x00, 3*sizeof(int16_t));
   14d7e:	4f54      	ldr	r7, [pc, #336]	; (14ed0 <historic_buffer+0x15c>)
		uint16_t num = 0;
   14d80:	2300      	movs	r3, #0
		lsm6dso_fifo_wtm_flag_get(&imu_dev_ctx, &waterm);
   14d82:	a901      	add	r1, sp, #4
   14d84:	4630      	mov	r0, r6
		uint16_t num = 0;
   14d86:	f8ad 3006 	strh.w	r3, [sp, #6]
		uint8_t waterm = 0;
   14d8a:	f88d 3004 	strb.w	r3, [sp, #4]
		lsm6dso_fifo_wtm_flag_get(&imu_dev_ctx, &waterm);
   14d8e:	f017 fc17 	bl	2c5c0 <lsm6dso_fifo_wtm_flag_get>
		if(waterm>0)
   14d92:	f89d 3004 	ldrb.w	r3, [sp, #4]
   14d96:	b193      	cbz	r3, 14dbe <historic_buffer+0x4a>
			lsm6dso_fifo_data_level_get(&imu_dev_ctx, &num);
   14d98:	f10d 0106 	add.w	r1, sp, #6
   14d9c:	4630      	mov	r0, r6
   14d9e:	f017 fbf5 	bl	2c58c <lsm6dso_fifo_data_level_get>
					angular_rate_mdps[0] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[0]);
   14da2:	f8df 9150 	ldr.w	r9, [pc, #336]	; 14ef4 <historic_buffer+0x180>
			while(num--)
   14da6:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   14daa:	1e5a      	subs	r2, r3, #1
   14dac:	f8ad 2006 	strh.w	r2, [sp, #6]
   14db0:	b943      	cbnz	r3, 14dc4 <historic_buffer+0x50>
			if(histBuff_counter == PATTERN_LEN)
   14db2:	f5b4 7fc8 	cmp.w	r4, #400	; 0x190
   14db6:	d1e3      	bne.n	14d80 <historic_buffer+0xc>
				hist_buff_flag = true;
   14db8:	2201      	movs	r2, #1
   14dba:	4b46      	ldr	r3, [pc, #280]	; (14ed4 <historic_buffer+0x160>)
   14dbc:	701a      	strb	r2, [r3, #0]
}
   14dbe:	b004      	add	sp, #16
   14dc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				lsm6dso_fifo_sensor_tag_get(&imu_dev_ctx, &reg_tag);
   14dc4:	f10d 0105 	add.w	r1, sp, #5
   14dc8:	4630      	mov	r0, r6
   14dca:	f017 fc07 	bl	2c5dc <lsm6dso_fifo_sensor_tag_get>
				switch (reg_tag)
   14dce:	f89d 2005 	ldrb.w	r2, [sp, #5]
   14dd2:	2300      	movs	r3, #0
   14dd4:	2a01      	cmp	r2, #1
   14dd6:	d03b      	beq.n	14e50 <historic_buffer+0xdc>
   14dd8:	2a02      	cmp	r2, #2
   14dda:	d16f      	bne.n	14ebc <historic_buffer+0x148>
					memset(data_raw_acceleration.u8bit, 0x00, 3*sizeof(int16_t));
   14ddc:	f8df 8118 	ldr.w	r8, [pc, #280]	; 14ef8 <historic_buffer+0x184>
					lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_acceleration.u8bit);
   14de0:	4630      	mov	r0, r6
   14de2:	4641      	mov	r1, r8
					memset(data_raw_acceleration.u8bit, 0x00, 3*sizeof(int16_t));
   14de4:	f8c8 3000 	str.w	r3, [r8]
   14de8:	f8a8 3004 	strh.w	r3, [r8, #4]
					lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_acceleration.u8bit);
   14dec:	f016 fdb5 	bl	2b95a <lsm6dso_fifo_out_raw_get>
					acceleration_mg[0] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[0]);
   14df0:	f9b8 0000 	ldrsh.w	r0, [r8]
   14df4:	f000 fc00 	bl	155f8 <lsm6dso_from_fs2_to_mg>
   14df8:	f8df a100 	ldr.w	sl, [pc, #256]	; 14efc <historic_buffer+0x188>
					acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   14dfc:	f9b8 0002 	ldrsh.w	r0, [r8, #2]
					acceleration_mg[0] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[0]);
   14e00:	ed8a 0a00 	vstr	s0, [sl]
					acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   14e04:	f000 fbf8 	bl	155f8 <lsm6dso_from_fs2_to_mg>
					acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   14e08:	f9b8 0004 	ldrsh.w	r0, [r8, #4]
					acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   14e0c:	ed8a 0a01 	vstr	s0, [sl, #4]
					acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   14e10:	f000 fbf2 	bl	155f8 <lsm6dso_from_fs2_to_mg>
					acceleration_g[1]   = acceleration_mg[1]/1000;
   14e14:	eddf 7a30 	vldr	s15, [pc, #192]	; 14ed8 <historic_buffer+0x164>
   14e18:	edda 6a01 	vldr	s13, [sl, #4]
					acceleration_g[0]   = acceleration_mg[0]/1000;
   14e1c:	ed9a 6a00 	vldr	s12, [sl]
					acceleration_g[1]   = acceleration_mg[1]/1000;
   14e20:	ee86 7aa7 	vdiv.f32	s14, s13, s15
					acceleration_g[0]   = acceleration_mg[0]/1000;
   14e24:	eec6 6a27 	vdiv.f32	s13, s12, s15
					acc_x_hist_buffer[i] = acceleration_g[0]; //[i]
   14e28:	4b2c      	ldr	r3, [pc, #176]	; (14edc <historic_buffer+0x168>)
   14e2a:	00aa      	lsls	r2, r5, #2
   14e2c:	4413      	add	r3, r2
   14e2e:	edc3 6a00 	vstr	s13, [r3]
					acc_y_hist_buffer[i] = acceleration_g[1];
   14e32:	4b2b      	ldr	r3, [pc, #172]	; (14ee0 <historic_buffer+0x16c>)
					histBuff_counter++;
   14e34:	3401      	adds	r4, #1
					acc_y_hist_buffer[i] = acceleration_g[1];
   14e36:	4413      	add	r3, r2
   14e38:	ed83 7a00 	vstr	s14, [r3]
					acceleration_g[2]   = acceleration_mg[2]/1000;
   14e3c:	ee80 7a27 	vdiv.f32	s14, s0, s15
					acc_z_hist_buffer[i] = acceleration_g[2];   
   14e40:	4b28      	ldr	r3, [pc, #160]	; (14ee4 <historic_buffer+0x170>)
					acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   14e42:	ed8a 0a02 	vstr	s0, [sl, #8]
					acc_z_hist_buffer[i] = acceleration_g[2];   
   14e46:	4413      	add	r3, r2
   14e48:	ed83 7a00 	vstr	s14, [r3]
					histBuff_counter++;
   14e4c:	b2a4      	uxth	r4, r4
					break;
   14e4e:	e7aa      	b.n	14da6 <historic_buffer+0x32>
					lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_angular_rate.u8bit);
   14e50:	4639      	mov	r1, r7
   14e52:	4630      	mov	r0, r6
					memset(data_raw_angular_rate.u8bit, 0x00, 3*sizeof(int16_t));
   14e54:	603b      	str	r3, [r7, #0]
   14e56:	80bb      	strh	r3, [r7, #4]
					lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_angular_rate.u8bit);
   14e58:	f016 fd7f 	bl	2b95a <lsm6dso_fifo_out_raw_get>
					angular_rate_mdps[0] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[0]);
   14e5c:	f9b7 0000 	ldrsh.w	r0, [r7]
   14e60:	f000 fbd6 	bl	15610 <lsm6dso_from_fs250_to_mdps>
					angular_rate_mdps[1] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[1]);
   14e64:	f9b7 0002 	ldrsh.w	r0, [r7, #2]
					angular_rate_mdps[0] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[0]);
   14e68:	ed89 0a00 	vstr	s0, [r9]
					angular_rate_mdps[1] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[1]);
   14e6c:	f000 fbd0 	bl	15610 <lsm6dso_from_fs250_to_mdps>
					angular_rate_mdps[2] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[2]);
   14e70:	f9b7 0004 	ldrsh.w	r0, [r7, #4]
					angular_rate_mdps[1] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[1]);
   14e74:	ed89 0a01 	vstr	s0, [r9, #4]
					angular_rate_mdps[2] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[2]);
   14e78:	f000 fbca 	bl	15610 <lsm6dso_from_fs250_to_mdps>
					angular_rate_dps[1] = angular_rate_mdps[1]/1000;
   14e7c:	eddf 7a16 	vldr	s15, [pc, #88]	; 14ed8 <historic_buffer+0x164>
   14e80:	edd9 6a01 	vldr	s13, [r9, #4]
					angular_rate_dps[0] = angular_rate_mdps[0]/1000;
   14e84:	ed99 6a00 	vldr	s12, [r9]
					angular_rate_dps[1] = angular_rate_mdps[1]/1000;
   14e88:	ee86 7aa7 	vdiv.f32	s14, s13, s15
					angular_rate_dps[0] = angular_rate_mdps[0]/1000;
   14e8c:	eec6 6a27 	vdiv.f32	s13, s12, s15
					gyro_x_hist_buffer[i] = angular_rate_dps[0];
   14e90:	4b15      	ldr	r3, [pc, #84]	; (14ee8 <historic_buffer+0x174>)
   14e92:	00aa      	lsls	r2, r5, #2
   14e94:	4413      	add	r3, r2
   14e96:	edc3 6a00 	vstr	s13, [r3]
					gyro_y_hist_buffer[i] = angular_rate_dps[1];
   14e9a:	4b14      	ldr	r3, [pc, #80]	; (14eec <historic_buffer+0x178>)
					histBuff_counter++;
   14e9c:	3401      	adds	r4, #1
					gyro_y_hist_buffer[i] = angular_rate_dps[1];
   14e9e:	4413      	add	r3, r2
   14ea0:	ed83 7a00 	vstr	s14, [r3]
					angular_rate_dps[2] = angular_rate_mdps[2]/1000;
   14ea4:	ee80 7a27 	vdiv.f32	s14, s0, s15
					gyro_z_hist_buffer[i] = angular_rate_dps[2];
   14ea8:	4b11      	ldr	r3, [pc, #68]	; (14ef0 <historic_buffer+0x17c>)
					i++;
   14eaa:	3501      	adds	r5, #1
					gyro_z_hist_buffer[i] = angular_rate_dps[2];
   14eac:	4413      	add	r3, r2
					angular_rate_mdps[2] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[2]);
   14eae:	ed89 0a02 	vstr	s0, [r9, #8]
					gyro_z_hist_buffer[i] = angular_rate_dps[2];
   14eb2:	ed83 7a00 	vstr	s14, [r3]
					histBuff_counter++;
   14eb6:	b2a4      	uxth	r4, r4
					i++;
   14eb8:	b2ad      	uxth	r5, r5
					break;
   14eba:	e774      	b.n	14da6 <historic_buffer+0x32>
					lsm6dso_fifo_out_raw_get(&imu_dev_ctx, dummy.u8bit);
   14ebc:	a902      	add	r1, sp, #8
   14ebe:	4630      	mov	r0, r6
					memset(dummy.u8bit, 0x00, 3 * sizeof(int16_t));
   14ec0:	9302      	str	r3, [sp, #8]
   14ec2:	f8ad 300c 	strh.w	r3, [sp, #12]
					lsm6dso_fifo_out_raw_get(&imu_dev_ctx, dummy.u8bit);
   14ec6:	f016 fd48 	bl	2b95a <lsm6dso_fifo_out_raw_get>
					break;
   14eca:	e76c      	b.n	14da6 <historic_buffer+0x32>
   14ecc:	20027e68 	.word	0x20027e68
   14ed0:	2002d470 	.word	0x2002d470
   14ed4:	2002ff2d 	.word	0x2002ff2d
   14ed8:	447a0000 	.word	0x447a0000
   14edc:	200210c4 	.word	0x200210c4
   14ee0:	20022064 	.word	0x20022064
   14ee4:	20023004 	.word	0x20023004
   14ee8:	200252a4 	.word	0x200252a4
   14eec:	20026244 	.word	0x20026244
   14ef0:	200271e4 	.word	0x200271e4
   14ef4:	200245f0 	.word	0x200245f0
   14ef8:	2002d46a 	.word	0x2002d46a
   14efc:	200245e4 	.word	0x200245e4

00014f00 <curr_vrif_buffers>:
{
   14f00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14f04:	ed2d 8b02 	vpush	{d8}
   14f08:	b089      	sub	sp, #36	; 0x24
	sensor_reset();
   14f0a:	f7ff feb7 	bl	14c7c <sensor_reset>
	uint16_t buff_counter = 0;
   14f0e:	2500      	movs	r5, #0
		uint16_t num = 0;
   14f10:	2300      	movs	r3, #0
		lsm6dso_fifo_wtm_flag_get(&imu_dev_ctx, &waterm);
   14f12:	f10d 011d 	add.w	r1, sp, #29
   14f16:	48b6      	ldr	r0, [pc, #728]	; (151f0 <curr_vrif_buffers+0x2f0>)
		uint16_t num = 0;
   14f18:	f8ad 301e 	strh.w	r3, [sp, #30]
		uint8_t waterm = 0;
   14f1c:	f88d 301d 	strb.w	r3, [sp, #29]
		lsm6dso_fifo_wtm_flag_get(&imu_dev_ctx, &waterm);
   14f20:	f017 fb4e 	bl	2c5c0 <lsm6dso_fifo_wtm_flag_get>
		if(waterm>0)
   14f24:	f89d 301d 	ldrb.w	r3, [sp, #29]
   14f28:	2b00      	cmp	r3, #0
   14f2a:	d0f1      	beq.n	14f10 <curr_vrif_buffers+0x10>
			lsm6dso_fifo_data_level_get(&imu_dev_ctx, &num);
   14f2c:	f10d 011e 	add.w	r1, sp, #30
   14f30:	48af      	ldr	r0, [pc, #700]	; (151f0 <curr_vrif_buffers+0x2f0>)
   14f32:	f017 fb2b 	bl	2c58c <lsm6dso_fifo_data_level_get>
		uint8_t k_rev = ACC_GYRO_FIFO_BUF_LEN-1;
   14f36:	23c7      	movs	r3, #199	; 0xc7
		uint8_t j_rev = ACC_GYRO_FIFO_BUF_LEN-1;
   14f38:	e9cd 3301 	strd	r3, r3, [sp, #4]
		uint8_t i_rev = ACC_GYRO_FIFO_BUF_LEN-1;
   14f3c:	9303      	str	r3, [sp, #12]
			while(num--)
   14f3e:	f8bd 301e 	ldrh.w	r3, [sp, #30]
   14f42:	1e5a      	subs	r2, r3, #1
   14f44:	f8ad 201e 	strh.w	r2, [sp, #30]
   14f48:	b953      	cbnz	r3, 14f60 <curr_vrif_buffers+0x60>
			if(buff_counter == 6*ACC_GYRO_FIFO_BUF_LEN)
   14f4a:	f5b5 6f96 	cmp.w	r5, #1200	; 0x4b0
   14f4e:	d1df      	bne.n	14f10 <curr_vrif_buffers+0x10>
				curr_vrif_buff_flag = true;
   14f50:	2201      	movs	r2, #1
   14f52:	4ba8      	ldr	r3, [pc, #672]	; (151f4 <curr_vrif_buffers+0x2f4>)
   14f54:	701a      	strb	r2, [r3, #0]
}
   14f56:	b009      	add	sp, #36	; 0x24
   14f58:	ecbd 8b02 	vpop	{d8}
   14f5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				memset(data_raw_angular_rate.u8bit, 0x00, 3*sizeof(int16_t));
   14f60:	f04f 0800 	mov.w	r8, #0
   14f64:	4fa4      	ldr	r7, [pc, #656]	; (151f8 <curr_vrif_buffers+0x2f8>)
				lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_angular_rate.u8bit);
   14f66:	48a2      	ldr	r0, [pc, #648]	; (151f0 <curr_vrif_buffers+0x2f0>)
   14f68:	4639      	mov	r1, r7
				memset(data_raw_angular_rate.u8bit, 0x00, 3*sizeof(int16_t));
   14f6a:	f8c7 8000 	str.w	r8, [r7]
   14f6e:	f8a7 8004 	strh.w	r8, [r7, #4]
				lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_angular_rate.u8bit);
   14f72:	f016 fcf2 	bl	2b95a <lsm6dso_fifo_out_raw_get>
				angular_rate_mdps[0] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[0]);
   14f76:	f9b7 0000 	ldrsh.w	r0, [r7]
   14f7a:	f000 fb49 	bl	15610 <lsm6dso_from_fs250_to_mdps>
   14f7e:	4e9f      	ldr	r6, [pc, #636]	; (151fc <curr_vrif_buffers+0x2fc>)
				angular_rate_mdps[1] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[1]);
   14f80:	f9b7 0002 	ldrsh.w	r0, [r7, #2]
				angular_rate_mdps[0] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[0]);
   14f84:	ed86 0a00 	vstr	s0, [r6]
				angular_rate_mdps[1] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[1]);
   14f88:	f000 fb42 	bl	15610 <lsm6dso_from_fs250_to_mdps>
				angular_rate_mdps[2] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[2]);
   14f8c:	f9b7 0004 	ldrsh.w	r0, [r7, #4]
				angular_rate_dps[1]  = angular_rate_mdps[1]/1000;
   14f90:	ed9f 8a9b 	vldr	s16, [pc, #620]	; 15200 <curr_vrif_buffers+0x300>
				angular_rate_mdps[1] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[1]);
   14f94:	ed86 0a01 	vstr	s0, [r6, #4]
				angular_rate_mdps[2] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[2]);
   14f98:	f000 fb3a 	bl	15610 <lsm6dso_from_fs250_to_mdps>
				angular_rate_dps[0]  = angular_rate_mdps[0]/1000;
   14f9c:	edd6 6a00 	vldr	s13, [r6]
				angular_rate_dps[1]  = angular_rate_mdps[1]/1000;
   14fa0:	ed96 7a01 	vldr	s14, [r6, #4]
   14fa4:	eec7 7a08 	vdiv.f32	s15, s14, s16
				angular_rate_dps[0]  = angular_rate_mdps[0]/1000;
   14fa8:	ee86 7a88 	vdiv.f32	s14, s13, s16
				gyro_tempX[num]      = angular_rate_dps[0];
   14fac:	f8bd 301e 	ldrh.w	r3, [sp, #30]
   14fb0:	4a94      	ldr	r2, [pc, #592]	; (15204 <curr_vrif_buffers+0x304>)
   14fb2:	009b      	lsls	r3, r3, #2
				gyro_tempY[num]      = angular_rate_dps[1];
   14fb4:	4f94      	ldr	r7, [pc, #592]	; (15208 <curr_vrif_buffers+0x308>)
				gyro_tempX[num]      = angular_rate_dps[0];
   14fb6:	441a      	add	r2, r3
   14fb8:	ed82 7a00 	vstr	s14, [r2]
				gyro_tempY[num]      = angular_rate_dps[1];
   14fbc:	18fa      	adds	r2, r7, r3
   14fbe:	edc2 7a00 	vstr	s15, [r2]
				angular_rate_dps[2]  = angular_rate_mdps[2]/1000;
   14fc2:	eec0 7a08 	vdiv.f32	s15, s0, s16
				memset(data_raw_acceleration.u8bit, 0x00, 3*sizeof(int16_t));
   14fc6:	f8df 927c 	ldr.w	r9, [pc, #636]	; 15244 <curr_vrif_buffers+0x344>
				angular_rate_mdps[2] = lsm6dso_from_fs250_to_mdps(data_raw_angular_rate.i16bit[2]);
   14fca:	ed86 0a02 	vstr	s0, [r6, #8]
				gyro_tempZ[num]      = angular_rate_dps[2];
   14fce:	4e8f      	ldr	r6, [pc, #572]	; (1520c <curr_vrif_buffers+0x30c>)
				lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_acceleration.u8bit);
   14fd0:	4649      	mov	r1, r9
				gyro_tempZ[num]      = angular_rate_dps[2];
   14fd2:	4433      	add	r3, r6
				memset(data_raw_acceleration.u8bit, 0x00, 3*sizeof(int16_t));
   14fd4:	f8c9 8000 	str.w	r8, [r9]
   14fd8:	f8a9 8004 	strh.w	r8, [r9, #4]
				lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_acceleration.u8bit);
   14fdc:	4884      	ldr	r0, [pc, #528]	; (151f0 <curr_vrif_buffers+0x2f0>)
				gyro_tempZ[num]      = angular_rate_dps[2];
   14fde:	edc3 7a00 	vstr	s15, [r3]
				lsm6dso_fifo_out_raw_get(&imu_dev_ctx, data_raw_acceleration.u8bit);
   14fe2:	f016 fcba 	bl	2b95a <lsm6dso_fifo_out_raw_get>
				acceleration_mg[0] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[0]);
   14fe6:	f9b9 0000 	ldrsh.w	r0, [r9]
   14fea:	f000 fb05 	bl	155f8 <lsm6dso_from_fs2_to_mg>
   14fee:	f8df 8258 	ldr.w	r8, [pc, #600]	; 15248 <curr_vrif_buffers+0x348>
				acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   14ff2:	f9b9 0002 	ldrsh.w	r0, [r9, #2]
				acceleration_mg[0] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[0]);
   14ff6:	ed88 0a00 	vstr	s0, [r8]
				acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   14ffa:	f000 fafd 	bl	155f8 <lsm6dso_from_fs2_to_mg>
				acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   14ffe:	f9b9 0004 	ldrsh.w	r0, [r9, #4]
				acceleration_mg[1] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
   15002:	ed88 0a01 	vstr	s0, [r8, #4]
				acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   15006:	f000 faf7 	bl	155f8 <lsm6dso_from_fs2_to_mg>
				acceleration_g[1]  = acceleration_mg[1]/1000;
   1500a:	ed98 7a01 	vldr	s14, [r8, #4]
				acceleration_g[0]  = acceleration_mg[0]/1000;
   1500e:	edd8 6a00 	vldr	s13, [r8]
				acceleration_g[1]  = acceleration_mg[1]/1000;
   15012:	eec7 7a08 	vdiv.f32	s15, s14, s16
				acceleration_g[0]  = acceleration_mg[0]/1000;
   15016:	ee86 7a88 	vdiv.f32	s14, s13, s16
				accel_tempX[num]   = acceleration_g[0];
   1501a:	f8bd 301e 	ldrh.w	r3, [sp, #30]
   1501e:	487c      	ldr	r0, [pc, #496]	; (15210 <curr_vrif_buffers+0x310>)
   15020:	009b      	lsls	r3, r3, #2
				accel_tempY[num]   = acceleration_g[1];
   15022:	497c      	ldr	r1, [pc, #496]	; (15214 <curr_vrif_buffers+0x314>)
				accel_tempX[num]   = acceleration_g[0];
   15024:	18c2      	adds	r2, r0, r3
   15026:	ed82 7a00 	vstr	s14, [r2]
				accel_tempY[num]   = acceleration_g[1];
   1502a:	18ca      	adds	r2, r1, r3
   1502c:	edc2 7a00 	vstr	s15, [r2]
				acceleration_g[2]  = acceleration_mg[2]/1000;
   15030:	eec0 7a08 	vdiv.f32	s15, s0, s16
				accel_tempZ[num]   = acceleration_g[2];
   15034:	4a78      	ldr	r2, [pc, #480]	; (15218 <curr_vrif_buffers+0x318>)
				if(buff_counter >= ACC_GYRO_FIFO_BUF_LEN && buff_counter < 2*ACC_GYRO_FIFO_BUF_LEN)
   15036:	f1a5 0cc7 	sub.w	ip, r5, #199	; 0xc7
				accel_tempZ[num]   = acceleration_g[2];
   1503a:	4413      	add	r3, r2
				if(buff_counter >= ACC_GYRO_FIFO_BUF_LEN && buff_counter < 2*ACC_GYRO_FIFO_BUF_LEN)
   1503c:	fa1f fc8c 	uxth.w	ip, ip
				accel_tempZ[num]   = acceleration_g[2];
   15040:	edc3 7a00 	vstr	s15, [r3]
				if(buff_counter >= ACC_GYRO_FIFO_BUF_LEN && buff_counter < 2*ACC_GYRO_FIFO_BUF_LEN)
   15044:	f1bc 0fc7 	cmp.w	ip, #199	; 0xc7
				buff_counter++;
   15048:	f105 0301 	add.w	r3, r5, #1
				acceleration_mg[2] = lsm6dso_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
   1504c:	ed88 0a02 	vstr	s0, [r8, #8]
				buff_counter++;
   15050:	b29b      	uxth	r3, r3
				if(buff_counter >= ACC_GYRO_FIFO_BUF_LEN && buff_counter < 2*ACC_GYRO_FIFO_BUF_LEN)
   15052:	d841      	bhi.n	150d8 <curr_vrif_buffers+0x1d8>
   15054:	4b71      	ldr	r3, [pc, #452]	; (1521c <curr_vrif_buffers+0x31c>)
   15056:	9c03      	ldr	r4, [sp, #12]
   15058:	9304      	str	r3, [sp, #16]
   1505a:	f104 0a38 	add.w	sl, r4, #56	; 0x38
   1505e:	4b70      	ldr	r3, [pc, #448]	; (15220 <curr_vrif_buffers+0x320>)
   15060:	f8df b1e8 	ldr.w	fp, [pc, #488]	; 1524c <curr_vrif_buffers+0x34c>
   15064:	f8df 91e8 	ldr.w	r9, [pc, #488]	; 15250 <curr_vrif_buffers+0x350>
   15068:	f8df e1e8 	ldr.w	lr, [pc, #488]	; 15254 <curr_vrif_buffers+0x354>
   1506c:	f8df c1e8 	ldr.w	ip, [pc, #488]	; 15258 <curr_vrif_buffers+0x358>
   15070:	fa5f fa8a 	uxtb.w	sl, sl
						acc_z_cur_buffer[i]  = accel_tempZ[i_rev];
   15074:	9205      	str	r2, [sp, #20]
						acc_x_cur_buffer[i]  = accel_tempX[i_rev];
   15076:	9a03      	ldr	r2, [sp, #12]
   15078:	9c04      	ldr	r4, [sp, #16]
   1507a:	0092      	lsls	r2, r2, #2
   1507c:	eb00 0802 	add.w	r8, r0, r2
   15080:	f8d8 8000 	ldr.w	r8, [r8]
   15084:	f844 8b04 	str.w	r8, [r4], #4
						acc_y_cur_buffer[i]  = accel_tempY[i_rev];
   15088:	eb01 0802 	add.w	r8, r1, r2
   1508c:	f8d8 8000 	ldr.w	r8, [r8]
						acc_x_cur_buffer[i]  = accel_tempX[i_rev];
   15090:	9404      	str	r4, [sp, #16]
						acc_z_cur_buffer[i]  = accel_tempZ[i_rev];
   15092:	9c05      	ldr	r4, [sp, #20]
						acc_y_cur_buffer[i]  = accel_tempY[i_rev];
   15094:	f843 8b04 	str.w	r8, [r3], #4
						acc_z_cur_buffer[i]  = accel_tempZ[i_rev];
   15098:	eb04 0802 	add.w	r8, r4, r2
   1509c:	f8d8 8000 	ldr.w	r8, [r8]
						gyro_x_cur_buffer[i] = gyro_tempX[i_rev];
   150a0:	4c58      	ldr	r4, [pc, #352]	; (15204 <curr_vrif_buffers+0x304>)
						acc_z_cur_buffer[i]  = accel_tempZ[i_rev];
   150a2:	f84b 8b04 	str.w	r8, [fp], #4
						gyro_x_cur_buffer[i] = gyro_tempX[i_rev];
   150a6:	eb04 0802 	add.w	r8, r4, r2
   150aa:	f8d8 8000 	ldr.w	r8, [r8]
   150ae:	f849 8b04 	str.w	r8, [r9], #4
						gyro_y_cur_buffer[i] = gyro_tempY[i_rev];
   150b2:	eb07 0802 	add.w	r8, r7, r2
						gyro_z_cur_buffer[i] = gyro_tempZ[i_rev];
   150b6:	4432      	add	r2, r6
   150b8:	6812      	ldr	r2, [r2, #0]
						gyro_y_cur_buffer[i] = gyro_tempY[i_rev];
   150ba:	f8d8 8000 	ldr.w	r8, [r8]
						gyro_z_cur_buffer[i] = gyro_tempZ[i_rev];
   150be:	f84c 2b04 	str.w	r2, [ip], #4
						i_rev--;
   150c2:	9a03      	ldr	r2, [sp, #12]
						gyro_y_cur_buffer[i] = gyro_tempY[i_rev];
   150c4:	f84e 8b04 	str.w	r8, [lr], #4
						i_rev--;
   150c8:	3a01      	subs	r2, #1
   150ca:	b2d2      	uxtb	r2, r2
					for (uint8_t i = 0; i < ACC_GYRO_FIFO_BUF_LEN; i++)
   150cc:	4552      	cmp	r2, sl
						i_rev--;
   150ce:	9203      	str	r2, [sp, #12]
					for (uint8_t i = 0; i < ACC_GYRO_FIFO_BUF_LEN; i++)
   150d0:	d1d1      	bne.n	15076 <curr_vrif_buffers+0x176>
   150d2:	f105 03c9 	add.w	r3, r5, #201	; 0xc9
   150d6:	b29b      	uxth	r3, r3
				if(buff_counter >= 3*ACC_GYRO_FIFO_BUF_LEN && buff_counter < 4*ACC_GYRO_FIFO_BUF_LEN)
   150d8:	f5a3 7216 	sub.w	r2, r3, #600	; 0x258
   150dc:	2ac7      	cmp	r2, #199	; 0xc7
   150de:	d842      	bhi.n	15166 <curr_vrif_buffers+0x266>
   150e0:	9a02      	ldr	r2, [sp, #8]
   150e2:	f8df 8178 	ldr.w	r8, [pc, #376]	; 1525c <curr_vrif_buffers+0x35c>
   150e6:	f102 0138 	add.w	r1, r2, #56	; 0x38
   150ea:	f8df c174 	ldr.w	ip, [pc, #372]	; 15260 <curr_vrif_buffers+0x360>
   150ee:	4f4d      	ldr	r7, [pc, #308]	; (15224 <curr_vrif_buffers+0x324>)
   150f0:	4e4d      	ldr	r6, [pc, #308]	; (15228 <curr_vrif_buffers+0x328>)
   150f2:	4d4e      	ldr	r5, [pc, #312]	; (1522c <curr_vrif_buffers+0x32c>)
   150f4:	484e      	ldr	r0, [pc, #312]	; (15230 <curr_vrif_buffers+0x330>)
						acc_x_vrif_buffer[j]  = accel_tempX[j_rev];
   150f6:	f8df b118 	ldr.w	fp, [pc, #280]	; 15210 <curr_vrif_buffers+0x310>
						acc_y_vrif_buffer[j]  = accel_tempY[j_rev];
   150fa:	f8df a118 	ldr.w	sl, [pc, #280]	; 15214 <curr_vrif_buffers+0x314>
						acc_z_vrif_buffer[j]  = accel_tempZ[j_rev];
   150fe:	f8df 9118 	ldr.w	r9, [pc, #280]	; 15218 <curr_vrif_buffers+0x318>
   15102:	b2c9      	uxtb	r1, r1
						acc_x_vrif_buffer[j]  = accel_tempX[j_rev];
   15104:	9a02      	ldr	r2, [sp, #8]
						gyro_x_vrif_buffer[j] = gyro_tempX[j_rev];
   15106:	4c3f      	ldr	r4, [pc, #252]	; (15204 <curr_vrif_buffers+0x304>)
						acc_x_vrif_buffer[j]  = accel_tempX[j_rev];
   15108:	0092      	lsls	r2, r2, #2
   1510a:	eb0b 0e02 	add.w	lr, fp, r2
   1510e:	f8de e000 	ldr.w	lr, [lr]
   15112:	f848 eb04 	str.w	lr, [r8], #4
						acc_y_vrif_buffer[j]  = accel_tempY[j_rev];
   15116:	eb0a 0e02 	add.w	lr, sl, r2
   1511a:	f8de e000 	ldr.w	lr, [lr]
   1511e:	f84c eb04 	str.w	lr, [ip], #4
						acc_z_vrif_buffer[j]  = accel_tempZ[j_rev];
   15122:	eb09 0e02 	add.w	lr, r9, r2
   15126:	f8de e000 	ldr.w	lr, [lr]
   1512a:	f847 eb04 	str.w	lr, [r7], #4
						gyro_x_vrif_buffer[j] = gyro_tempX[j_rev];
   1512e:	eb04 0e02 	add.w	lr, r4, r2
   15132:	f8de e000 	ldr.w	lr, [lr]
						gyro_y_vrif_buffer[j] = gyro_tempY[j_rev];
   15136:	4c34      	ldr	r4, [pc, #208]	; (15208 <curr_vrif_buffers+0x308>)
						gyro_x_vrif_buffer[j] = gyro_tempX[j_rev];
   15138:	f846 eb04 	str.w	lr, [r6], #4
						gyro_y_vrif_buffer[j] = gyro_tempY[j_rev];
   1513c:	eb04 0e02 	add.w	lr, r4, r2
						gyro_z_vrif_buffer[j] = gyro_tempZ[j_rev];
   15140:	4c32      	ldr	r4, [pc, #200]	; (1520c <curr_vrif_buffers+0x30c>)
						gyro_y_vrif_buffer[j] = gyro_tempY[j_rev];
   15142:	f8de e000 	ldr.w	lr, [lr]
						gyro_z_vrif_buffer[j] = gyro_tempZ[j_rev];
   15146:	4422      	add	r2, r4
   15148:	6812      	ldr	r2, [r2, #0]
						gyro_y_vrif_buffer[j] = gyro_tempY[j_rev];
   1514a:	f845 eb04 	str.w	lr, [r5], #4
						gyro_z_vrif_buffer[j] = gyro_tempZ[j_rev];
   1514e:	f840 2b04 	str.w	r2, [r0], #4
						j_rev--;
   15152:	9a02      	ldr	r2, [sp, #8]
   15154:	3a01      	subs	r2, #1
   15156:	b2d2      	uxtb	r2, r2
					for (uint8_t j = 0; j < ACC_GYRO_FIFO_BUF_LEN; j++)
   15158:	428a      	cmp	r2, r1
						j_rev--;
   1515a:	9202      	str	r2, [sp, #8]
					for (uint8_t j = 0; j < ACC_GYRO_FIFO_BUF_LEN; j++)
   1515c:	d1d2      	bne.n	15104 <curr_vrif_buffers+0x204>
   1515e:	33c8      	adds	r3, #200	; 0xc8
   15160:	b29b      	uxth	r3, r3
					for (uint8_t k = 0; k < ACC_GYRO_FIFO_BUF_LEN; k++)
   15162:	461d      	mov	r5, r3
   15164:	e6eb      	b.n	14f3e <curr_vrif_buffers+0x3e>
				if(buff_counter >= 5*ACC_GYRO_FIFO_BUF_LEN && buff_counter < 6*ACC_GYRO_FIFO_BUF_LEN)
   15166:	f5a3 727a 	sub.w	r2, r3, #1000	; 0x3e8
   1516a:	2ac7      	cmp	r2, #199	; 0xc7
   1516c:	d8f9      	bhi.n	15162 <curr_vrif_buffers+0x262>
   1516e:	9a01      	ldr	r2, [sp, #4]
   15170:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 15264 <curr_vrif_buffers+0x364>
   15174:	f102 0138 	add.w	r1, r2, #56	; 0x38
   15178:	f8df c0ec 	ldr.w	ip, [pc, #236]	; 15268 <curr_vrif_buffers+0x368>
   1517c:	4f2d      	ldr	r7, [pc, #180]	; (15234 <curr_vrif_buffers+0x334>)
   1517e:	4e2e      	ldr	r6, [pc, #184]	; (15238 <curr_vrif_buffers+0x338>)
   15180:	4d2e      	ldr	r5, [pc, #184]	; (1523c <curr_vrif_buffers+0x33c>)
   15182:	482f      	ldr	r0, [pc, #188]	; (15240 <curr_vrif_buffers+0x340>)
						acc_x_vrif_buffer_1[k]  = accel_tempX[k_rev];
   15184:	f8df b088 	ldr.w	fp, [pc, #136]	; 15210 <curr_vrif_buffers+0x310>
						acc_y_vrif_buffer_1[k]  = accel_tempY[k_rev];
   15188:	f8df a088 	ldr.w	sl, [pc, #136]	; 15214 <curr_vrif_buffers+0x314>
						acc_z_vrif_buffer_1[k]  = accel_tempZ[k_rev];
   1518c:	f8df 9088 	ldr.w	r9, [pc, #136]	; 15218 <curr_vrif_buffers+0x318>
   15190:	b2c9      	uxtb	r1, r1
						acc_x_vrif_buffer_1[k]  = accel_tempX[k_rev];
   15192:	9a01      	ldr	r2, [sp, #4]
						gyro_x_vrif_buffer_1[k] = gyro_tempX[k_rev];
   15194:	4c1b      	ldr	r4, [pc, #108]	; (15204 <curr_vrif_buffers+0x304>)
						acc_x_vrif_buffer_1[k]  = accel_tempX[k_rev];
   15196:	0092      	lsls	r2, r2, #2
   15198:	eb0b 0e02 	add.w	lr, fp, r2
   1519c:	f8de e000 	ldr.w	lr, [lr]
   151a0:	f848 eb04 	str.w	lr, [r8], #4
						acc_y_vrif_buffer_1[k]  = accel_tempY[k_rev];
   151a4:	eb0a 0e02 	add.w	lr, sl, r2
   151a8:	f8de e000 	ldr.w	lr, [lr]
   151ac:	f84c eb04 	str.w	lr, [ip], #4
						acc_z_vrif_buffer_1[k]  = accel_tempZ[k_rev];
   151b0:	eb09 0e02 	add.w	lr, r9, r2
   151b4:	f8de e000 	ldr.w	lr, [lr]
   151b8:	f847 eb04 	str.w	lr, [r7], #4
						gyro_x_vrif_buffer_1[k] = gyro_tempX[k_rev];
   151bc:	eb04 0e02 	add.w	lr, r4, r2
   151c0:	f8de e000 	ldr.w	lr, [lr]
						gyro_y_vrif_buffer_1[k] = gyro_tempY[k_rev];
   151c4:	4c10      	ldr	r4, [pc, #64]	; (15208 <curr_vrif_buffers+0x308>)
						gyro_x_vrif_buffer_1[k] = gyro_tempX[k_rev];
   151c6:	f846 eb04 	str.w	lr, [r6], #4
						gyro_y_vrif_buffer_1[k] = gyro_tempY[k_rev];
   151ca:	eb04 0e02 	add.w	lr, r4, r2
						gyro_z_vrif_buffer_1[k] = gyro_tempZ[k_rev];
   151ce:	4c0f      	ldr	r4, [pc, #60]	; (1520c <curr_vrif_buffers+0x30c>)
						gyro_y_vrif_buffer_1[k] = gyro_tempY[k_rev];
   151d0:	f8de e000 	ldr.w	lr, [lr]
						gyro_z_vrif_buffer_1[k] = gyro_tempZ[k_rev];
   151d4:	4422      	add	r2, r4
   151d6:	6812      	ldr	r2, [r2, #0]
						gyro_y_vrif_buffer_1[k] = gyro_tempY[k_rev];
   151d8:	f845 eb04 	str.w	lr, [r5], #4
						gyro_z_vrif_buffer_1[k] = gyro_tempZ[k_rev];
   151dc:	f840 2b04 	str.w	r2, [r0], #4
						k_rev--;
   151e0:	9a01      	ldr	r2, [sp, #4]
   151e2:	1e54      	subs	r4, r2, #1
   151e4:	b2e2      	uxtb	r2, r4
					for (uint8_t k = 0; k < ACC_GYRO_FIFO_BUF_LEN; k++)
   151e6:	428a      	cmp	r2, r1
						k_rev--;
   151e8:	9201      	str	r2, [sp, #4]
					for (uint8_t k = 0; k < ACC_GYRO_FIFO_BUF_LEN; k++)
   151ea:	d1d2      	bne.n	15192 <curr_vrif_buffers+0x292>
   151ec:	e7b7      	b.n	1515e <curr_vrif_buffers+0x25e>
   151ee:	bf00      	nop
   151f0:	20027e68 	.word	0x20027e68
   151f4:	2002ff18 	.word	0x2002ff18
   151f8:	2002d470 	.word	0x2002d470
   151fc:	200245f0 	.word	0x200245f0
   15200:	447a0000 	.word	0x447a0000
   15204:	20024624 	.word	0x20024624
   15208:	20024944 	.word	0x20024944
   1520c:	20024c64 	.word	0x20024c64
   15210:	20023c84 	.word	0x20023c84
   15214:	20023fa4 	.word	0x20023fa4
   15218:	200242c4 	.word	0x200242c4
   1521c:	20020da4 	.word	0x20020da4
   15220:	20021d44 	.word	0x20021d44
   15224:	20023644 	.word	0x20023644
   15228:	200258e4 	.word	0x200258e4
   1522c:	20026884 	.word	0x20026884
   15230:	20027824 	.word	0x20027824
   15234:	20023964 	.word	0x20023964
   15238:	20025c04 	.word	0x20025c04
   1523c:	20026ba4 	.word	0x20026ba4
   15240:	20027b44 	.word	0x20027b44
   15244:	2002d46a 	.word	0x2002d46a
   15248:	200245e4 	.word	0x200245e4
   1524c:	20022ce4 	.word	0x20022ce4
   15250:	20024f84 	.word	0x20024f84
   15254:	20025f24 	.word	0x20025f24
   15258:	20026ec4 	.word	0x20026ec4
   1525c:	20021704 	.word	0x20021704
   15260:	200226a4 	.word	0x200226a4
   15264:	20021a24 	.word	0x20021a24
   15268:	200229c4 	.word	0x200229c4

0001526c <ReSetImuSteps>:
	lsm6dso_steps_reset(&imu_dev_ctx);
   1526c:	4801      	ldr	r0, [pc, #4]	; (15274 <ReSetImuSteps+0x8>)
   1526e:	f016 bbeb 	b.w	2ba48 <lsm6dso_steps_reset>
   15272:	bf00      	nop
   15274:	20027e68 	.word	0x20027e68

00015278 <GetImuSteps>:
	lsm6dso_number_of_steps_get(&imu_dev_ctx, steps);
   15278:	4601      	mov	r1, r0
   1527a:	4801      	ldr	r0, [pc, #4]	; (15280 <GetImuSteps+0x8>)
   1527c:	f016 bbcf 	b.w	2ba1e <lsm6dso_number_of_steps_get>
   15280:	20027e68 	.word	0x20027e68

00015284 <GetSportData>:
	*steps = g_steps;
   15284:	4b04      	ldr	r3, [pc, #16]	; (15298 <GetSportData+0x14>)
   15286:	881b      	ldrh	r3, [r3, #0]
   15288:	8003      	strh	r3, [r0, #0]
	*calorie = g_calorie;
   1528a:	4b04      	ldr	r3, [pc, #16]	; (1529c <GetSportData+0x18>)
   1528c:	881b      	ldrh	r3, [r3, #0]
   1528e:	800b      	strh	r3, [r1, #0]
	*distance = g_distance;
   15290:	4b03      	ldr	r3, [pc, #12]	; (152a0 <GetSportData+0x1c>)
   15292:	881b      	ldrh	r3, [r3, #0]
   15294:	8013      	strh	r3, [r2, #0]
}
   15296:	4770      	bx	lr
   15298:	2002d47c 	.word	0x2002d47c
   1529c:	2002d478 	.word	0x2002d478
   152a0:	2002d47a 	.word	0x2002d47a

000152a4 <lsm6dso_sensitivity>:
	uint8_t deb_step = 5;
   152a4:	2305      	movs	r3, #5
{
   152a6:	b513      	push	{r0, r1, r4, lr}
	lsm6dso_pedo_debounce_steps_set(&imu_dev_ctx, &deb_step);
   152a8:	4c08      	ldr	r4, [pc, #32]	; (152cc <lsm6dso_sensitivity+0x28>)
   152aa:	f10d 0103 	add.w	r1, sp, #3
   152ae:	4620      	mov	r0, r4
	uint8_t deb_step = 5;
   152b0:	f88d 3003 	strb.w	r3, [sp, #3]
	lsm6dso_pedo_debounce_steps_set(&imu_dev_ctx, &deb_step);
   152b4:	f017 fa2b 	bl	2c70e <lsm6dso_pedo_debounce_steps_set>
	uint8_t delay_time[2] = {0x00U, 0x32U};
   152b8:	f44f 5348 	mov.w	r3, #12800	; 0x3200
	lsm6dso_pedo_steps_period_set(&imu_dev_ctx, &delay_time);
   152bc:	a901      	add	r1, sp, #4
   152be:	4620      	mov	r0, r4
	uint8_t delay_time[2] = {0x00U, 0x32U};
   152c0:	f8ad 3004 	strh.w	r3, [sp, #4]
	lsm6dso_pedo_steps_period_set(&imu_dev_ctx, &delay_time);
   152c4:	f017 fa28 	bl	2c718 <lsm6dso_pedo_steps_period_set>
}
   152c8:	b002      	add	sp, #8
   152ca:	bd10      	pop	{r4, pc}
   152cc:	20027e68 	.word	0x20027e68

000152d0 <fall_get_wifi_data_reply>:
{
   152d0:	b084      	sub	sp, #16
   152d2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   152d6:	b0e2      	sub	sp, #392	; 0x188
   152d8:	ac68      	add	r4, sp, #416	; 0x1a0
   152da:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	u8_t reply[256] = {0};
   152de:	f44f 7280 	mov.w	r2, #256	; 0x100
   152e2:	2100      	movs	r1, #0
   152e4:	a822      	add	r0, sp, #136	; 0x88
   152e6:	f01a f855 	bl	2f394 <memset>
	u8_t tmpbuf[128] = {0};
   152ea:	2280      	movs	r2, #128	; 0x80
   152ec:	2100      	movs	r1, #0
   152ee:	a802      	add	r0, sp, #8
   152f0:	f01a f850 	bl	2f394 <memset>
	if(wifi_data.count > 0)
   152f4:	f89d 61a0 	ldrb.w	r6, [sp, #416]	; 0x1a0
   152f8:	2e00      	cmp	r6, #0
   152fa:	d03a      	beq.n	15372 <fall_get_wifi_data_reply+0xa2>
		strcat(reply, "3,");
   152fc:	f44f 7280 	mov.w	r2, #256	; 0x100
   15300:	4922      	ldr	r1, [pc, #136]	; (1538c <fall_get_wifi_data_reply+0xbc>)
   15302:	a822      	add	r0, sp, #136	; 0x88
   15304:	f01a f9a2 	bl	2f64c <__strcat_chk>
		for(i=0;i<wifi_data.count;i++)
   15308:	2400      	movs	r4, #0
			strcat(reply, "&");
   1530a:	4f21      	ldr	r7, [pc, #132]	; (15390 <fall_get_wifi_data_reply+0xc0>)
			sprintf(tmpbuf, "%d", wifi_data.node[i].rssi);
   1530c:	f8df 8088 	ldr.w	r8, [pc, #136]	; 15398 <fall_get_wifi_data_reply+0xc8>
   15310:	f50d 75d1 	add.w	r5, sp, #418	; 0x1a2
			strcat(reply, wifi_data.node[i].mac);
   15314:	f44f 7280 	mov.w	r2, #256	; 0x100
   15318:	4629      	mov	r1, r5
   1531a:	a822      	add	r0, sp, #136	; 0x88
   1531c:	f01a f996 	bl	2f64c <__strcat_chk>
			strcat(reply, "&");
   15320:	f44f 7280 	mov.w	r2, #256	; 0x100
   15324:	4639      	mov	r1, r7
   15326:	a822      	add	r0, sp, #136	; 0x88
   15328:	f01a f990 	bl	2f64c <__strcat_chk>
			sprintf(tmpbuf, "%d", wifi_data.node[i].rssi);
   1532c:	f915 3c01 	ldrsb.w	r3, [r5, #-1]
   15330:	2280      	movs	r2, #128	; 0x80
   15332:	9300      	str	r3, [sp, #0]
   15334:	2100      	movs	r1, #0
   15336:	4643      	mov	r3, r8
   15338:	a802      	add	r0, sp, #8
   1533a:	f01a f96d 	bl	2f618 <__sprintf_chk>
			strcat(reply, tmpbuf);
   1533e:	f44f 7280 	mov.w	r2, #256	; 0x100
   15342:	a902      	add	r1, sp, #8
   15344:	a822      	add	r0, sp, #136	; 0x88
   15346:	f01a f981 	bl	2f64c <__strcat_chk>
			strcat(reply, "&");
   1534a:	f44f 7280 	mov.w	r2, #256	; 0x100
   1534e:	4639      	mov	r1, r7
   15350:	a822      	add	r0, sp, #136	; 0x88
   15352:	f01a f97b 	bl	2f64c <__strcat_chk>
			if(i < (wifi_data.count-1))
   15356:	1e73      	subs	r3, r6, #1
   15358:	42a3      	cmp	r3, r4
   1535a:	d905      	bls.n	15368 <fall_get_wifi_data_reply+0x98>
				strcat(reply, "|");
   1535c:	f44f 7280 	mov.w	r2, #256	; 0x100
   15360:	490c      	ldr	r1, [pc, #48]	; (15394 <fall_get_wifi_data_reply+0xc4>)
   15362:	a822      	add	r0, sp, #136	; 0x88
   15364:	f01a f972 	bl	2f64c <__strcat_chk>
		for(i=0;i<wifi_data.count;i++)
   15368:	3401      	adds	r4, #1
   1536a:	42a6      	cmp	r6, r4
   1536c:	f105 0521 	add.w	r5, r5, #33	; 0x21
   15370:	d8d0      	bhi.n	15314 <fall_get_wifi_data_reply+0x44>
	NBSendFallWifiData(reply, strlen(reply));
   15372:	a822      	add	r0, sp, #136	; 0x88
   15374:	f7f7 fdf0 	bl	cf58 <strlen>
   15378:	4601      	mov	r1, r0
   1537a:	a822      	add	r0, sp, #136	; 0x88
   1537c:	f7fe ff9a 	bl	142b4 <NBSendFallWifiData>
}
   15380:	b062      	add	sp, #392	; 0x188
   15382:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   15386:	b004      	add	sp, #16
   15388:	4770      	bx	lr
   1538a:	bf00      	nop
   1538c:	000320ab 	.word	0x000320ab
   15390:	000320ae 	.word	0x000320ae
   15394:	000320b0 	.word	0x000320b0
   15398:	00033e5f 	.word	0x00033e5f

0001539c <IMU_init>:
		UpdateSleepPara();
	}
}

void IMU_init(struct k_work_q *work_q)
{
   1539c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1539e:	4607      	mov	r7, r0
   153a0:	481e      	ldr	r0, [pc, #120]	; (1541c <IMU_init+0x80>)
   153a2:	f010 ff11 	bl	261c8 <z_impl_device_get_binding>
   153a6:	4c1e      	ldr	r4, [pc, #120]	; (15420 <IMU_init+0x84>)
   153a8:	4a1e      	ldr	r2, [pc, #120]	; (15424 <IMU_init+0x88>)
	i2c_imu = device_get_binding(IMU_DEV);
   153aa:	4e1f      	ldr	r6, [pc, #124]	; (15428 <IMU_init+0x8c>)
   153ac:	1aa4      	subs	r4, r4, r2
   153ae:	6030      	str	r0, [r6, #0]
	if(!i2c_imu)
   153b0:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   153b4:	b958      	cbnz	r0, 153ce <IMU_init+0x32>
		LOG_INF("ERROR SETTING UP I2C\r\n");
   153b6:	f04f 0000 	mov.w	r0, #0
   153ba:	2303      	movs	r3, #3
   153bc:	491b      	ldr	r1, [pc, #108]	; (1542c <IMU_init+0x90>)
   153be:	f363 0007 	bfi	r0, r3, #0, #8
   153c2:	f364 108f 	bfi	r0, r4, #6, #10

	imu_work_q = work_q;
	k_work_init(&imu_work, mt_fall_detection);
	
	LOG_INF("IMU_init done!\n");
}
   153c6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	LOG_INF("IMU_init done!\n");
   153ca:	f017 bf95 	b.w	2d2f8 <log_string_sync>
	return api->configure(dev, dev_config);
   153ce:	6843      	ldr	r3, [r0, #4]
   153d0:	2104      	movs	r1, #4
   153d2:	681b      	ldr	r3, [r3, #0]
   153d4:	4798      	blx	r3
	imu_dev_ctx.write_reg = platform_write;
   153d6:	4d16      	ldr	r5, [pc, #88]	; (15430 <IMU_init+0x94>)
	init_gpio();
   153d8:	f7ff fb26 	bl	14a28 <init_gpio>
	imu_dev_ctx.write_reg = platform_write;
   153dc:	4b15      	ldr	r3, [pc, #84]	; (15434 <IMU_init+0x98>)
   153de:	602b      	str	r3, [r5, #0]
	imu_dev_ctx.read_reg = platform_read;
   153e0:	4b15      	ldr	r3, [pc, #84]	; (15438 <IMU_init+0x9c>)
   153e2:	606b      	str	r3, [r5, #4]
	imu_dev_ctx.handle = i2c_imu;
   153e4:	6833      	ldr	r3, [r6, #0]
   153e6:	60ab      	str	r3, [r5, #8]
	sensor_init();
   153e8:	f7ff fb6c 	bl	14ac4 <sensor_init>
	lsm6dso_steps_reset(&imu_dev_ctx); //reset step counter
   153ec:	4628      	mov	r0, r5
   153ee:	f016 fb2b 	bl	2ba48 <lsm6dso_steps_reset>
	lsm6dso_sensitivity();
   153f2:	f7ff ff57 	bl	152a4 <lsm6dso_sensitivity>
	StartSleepTimeMonitor();
   153f6:	f000 fa07 	bl	15808 <StartSleepTimeMonitor>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   153fa:	2200      	movs	r2, #0
	imu_work_q = work_q;
   153fc:	4b0f      	ldr	r3, [pc, #60]	; (1543c <IMU_init+0xa0>)
   153fe:	4910      	ldr	r1, [pc, #64]	; (15440 <IMU_init+0xa4>)
   15400:	601f      	str	r7, [r3, #0]
   15402:	4b10      	ldr	r3, [pc, #64]	; (15444 <IMU_init+0xa8>)
	LOG_INF("IMU_init done!\n");
   15404:	f04f 0000 	mov.w	r0, #0
   15408:	e9c3 1201 	strd	r1, r2, [r3, #4]
   1540c:	601a      	str	r2, [r3, #0]
   1540e:	2303      	movs	r3, #3
   15410:	f363 0007 	bfi	r0, r3, #0, #8
   15414:	f364 108f 	bfi	r0, r4, #6, #10
   15418:	490b      	ldr	r1, [pc, #44]	; (15448 <IMU_init+0xac>)
   1541a:	e7d4      	b.n	153c6 <IMU_init+0x2a>
   1541c:	00032022 	.word	0x00032022
   15420:	00030494 	.word	0x00030494
   15424:	0003040c 	.word	0x0003040c
   15428:	20027e64 	.word	0x20027e64
   1542c:	00032028 	.word	0x00032028
   15430:	20027e68 	.word	0x20027e68
   15434:	00014989 	.word	0x00014989
   15438:	000149d5 	.word	0x000149d5
   1543c:	20027e80 	.word	0x20027e80
   15440:	00015495 	.word	0x00015495
   15444:	20027e74 	.word	0x20027e74
   15448:	0003203f 	.word	0x0003203f

0001544c <is_tilt>:
/*@brief Check if a wrist tilt happend
*
* @return If tilt detected, wrist_tilt=true, otherwise false
*/
void is_tilt(void)
{
   1544c:	b507      	push	{r0, r1, r2, lr}
	lsm6dso_all_sources_t status;

	lsm6dso_all_sources_get(&imu_dev_ctx, &status);
   1544e:	4807      	ldr	r0, [pc, #28]	; (1546c <is_tilt+0x20>)
   15450:	4669      	mov	r1, sp
   15452:	f016 fa9e 	bl	2b992 <lsm6dso_all_sources_get>
	if(status.fsm_status_a.is_fsm1)
   15456:	f89d 3006 	ldrb.w	r3, [sp, #6]
   1545a:	07db      	lsls	r3, r3, #31
	{ 
		//tilt detected
		wrist_tilt = true;
   1545c:	bf42      	ittt	mi
   1545e:	2201      	movmi	r2, #1
   15460:	4b03      	ldrmi	r3, [pc, #12]	; (15470 <is_tilt+0x24>)
   15462:	701a      	strbmi	r2, [r3, #0]
	}
}
   15464:	b003      	add	sp, #12
   15466:	f85d fb04 	ldr.w	pc, [sp], #4
   1546a:	bf00      	nop
   1546c:	20027e68 	.word	0x20027e68
   15470:	2002ff3d 	.word	0x2002ff3d

00015474 <IMURedrawSteps>:
	}
}

void IMURedrawSteps(void)
{
	if(screen_id == SCREEN_ID_IDLE)
   15474:	4b05      	ldr	r3, [pc, #20]	; (1548c <IMURedrawSteps+0x18>)
   15476:	781b      	ldrb	r3, [r3, #0]
   15478:	2b01      	cmp	r3, #1
   1547a:	d106      	bne.n	1548a <IMURedrawSteps+0x16>
	{
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_SPORT;
   1547c:	4b04      	ldr	r3, [pc, #16]	; (15490 <IMURedrawSteps+0x1c>)
   1547e:	68da      	ldr	r2, [r3, #12]
   15480:	f042 0220 	orr.w	r2, r2, #32
   15484:	60da      	str	r2, [r3, #12]
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   15486:	2202      	movs	r2, #2
   15488:	725a      	strb	r2, [r3, #9]
	}
}
   1548a:	4770      	bx	lr
   1548c:	2002ff93 	.word	0x2002ff93
   15490:	20028540 	.word	0x20028540

00015494 <mt_fall_detection>:
	if(int1_event)	//steps or tilt
   15494:	4b3c      	ldr	r3, [pc, #240]	; (15588 <mt_fall_detection+0xf4>)
{
   15496:	b570      	push	{r4, r5, r6, lr}
	if(int1_event)	//steps or tilt
   15498:	781a      	ldrb	r2, [r3, #0]
   1549a:	b332      	cbz	r2, 154ea <mt_fall_detection+0x56>
		int1_event = false;
   1549c:	2500      	movs	r5, #0
   1549e:	701d      	strb	r5, [r3, #0]
		if(!is_wearing())
   154a0:	f016 f8e4 	bl	2b66c <is_wearing>
   154a4:	2800      	cmp	r0, #0
   154a6:	d06d      	beq.n	15584 <mt_fall_detection+0xf0>
		if(wrist_tilt)
   154a8:	4c38      	ldr	r4, [pc, #224]	; (1558c <mt_fall_detection+0xf8>)
		is_tilt();
   154aa:	f7ff ffcf 	bl	1544c <is_tilt>
		if(wrist_tilt)
   154ae:	4b38      	ldr	r3, [pc, #224]	; (15590 <mt_fall_detection+0xfc>)
   154b0:	4938      	ldr	r1, [pc, #224]	; (15594 <mt_fall_detection+0x100>)
   154b2:	7822      	ldrb	r2, [r4, #0]
   154b4:	1a5b      	subs	r3, r3, r1
   154b6:	f3c3 03c9 	ubfx	r3, r3, #3, #10
			LOG_INF("tilt trigger!\n");
   154ba:	f04f 0000 	mov.w	r0, #0
		if(wrist_tilt)
   154be:	2a00      	cmp	r2, #0
   154c0:	d046      	beq.n	15550 <mt_fall_detection+0xbc>
			LOG_INF("tilt trigger!\n");
   154c2:	2203      	movs	r2, #3
   154c4:	f362 0007 	bfi	r0, r2, #0, #8
   154c8:	f363 108f 	bfi	r0, r3, #6, #10
   154cc:	4932      	ldr	r1, [pc, #200]	; (15598 <mt_fall_detection+0x104>)
   154ce:	f017 ff13 	bl	2d2f8 <log_string_sync>
			if(lcd_is_sleeping && global_settings.wake_screen_by_wrist)
   154d2:	4b32      	ldr	r3, [pc, #200]	; (1559c <mt_fall_detection+0x108>)
			wrist_tilt = false;
   154d4:	7025      	strb	r5, [r4, #0]
			if(lcd_is_sleeping && global_settings.wake_screen_by_wrist)
   154d6:	781b      	ldrb	r3, [r3, #0]
   154d8:	b13b      	cbz	r3, 154ea <mt_fall_detection+0x56>
   154da:	4b31      	ldr	r3, [pc, #196]	; (155a0 <mt_fall_detection+0x10c>)
   154dc:	791b      	ldrb	r3, [r3, #4]
   154de:	b123      	cbz	r3, 154ea <mt_fall_detection+0x56>
				sleep_out_by_wrist = true;
   154e0:	2301      	movs	r3, #1
   154e2:	4a30      	ldr	r2, [pc, #192]	; (155a4 <mt_fall_detection+0x110>)
   154e4:	7013      	strb	r3, [r2, #0]
				lcd_sleep_out = true;
   154e6:	4a30      	ldr	r2, [pc, #192]	; (155a8 <mt_fall_detection+0x114>)
   154e8:	7013      	strb	r3, [r2, #0]
	if(int2_event) //fall
   154ea:	4b30      	ldr	r3, [pc, #192]	; (155ac <mt_fall_detection+0x118>)
   154ec:	781a      	ldrb	r2, [r3, #0]
   154ee:	b312      	cbz	r2, 15536 <mt_fall_detection+0xa2>
		int2_event = false;
   154f0:	2200      	movs	r2, #0
   154f2:	701a      	strb	r2, [r3, #0]
		if(!is_wearing()||fall_testing)
   154f4:	f016 f8ba 	bl	2b66c <is_wearing>
   154f8:	2800      	cmp	r0, #0
   154fa:	d043      	beq.n	15584 <mt_fall_detection+0xf0>
   154fc:	4e2c      	ldr	r6, [pc, #176]	; (155b0 <mt_fall_detection+0x11c>)
   154fe:	7835      	ldrb	r5, [r6, #0]
   15500:	2d00      	cmp	r5, #0
   15502:	d13f      	bne.n	15584 <mt_fall_detection+0xf0>
		if(fall_result)
   15504:	4c2b      	ldr	r4, [pc, #172]	; (155b4 <mt_fall_detection+0x120>)
		fall_detection();
   15506:	f7f7 fe1b 	bl	d140 <fall_detection>
		if(fall_result)
   1550a:	7823      	ldrb	r3, [r4, #0]
   1550c:	b18b      	cbz	r3, 15532 <mt_fall_detection+0x9e>
			LOG_INF("Fall trigger!\n");
   1550e:	2303      	movs	r3, #3
   15510:	f04f 0000 	mov.w	r0, #0
   15514:	4a1f      	ldr	r2, [pc, #124]	; (15594 <mt_fall_detection+0x100>)
   15516:	f363 0007 	bfi	r0, r3, #0, #8
   1551a:	4b1d      	ldr	r3, [pc, #116]	; (15590 <mt_fall_detection+0xfc>)
   1551c:	4926      	ldr	r1, [pc, #152]	; (155b8 <mt_fall_detection+0x124>)
   1551e:	1a9b      	subs	r3, r3, r2
   15520:	08db      	lsrs	r3, r3, #3
   15522:	f363 108f 	bfi	r0, r3, #6, #10
   15526:	f017 fee7 	bl	2d2f8 <log_string_sync>
			lcd_sleep_out = true;
   1552a:	2201      	movs	r2, #1
   1552c:	4b1e      	ldr	r3, [pc, #120]	; (155a8 <mt_fall_detection+0x114>)
			fall_result = false;
   1552e:	7025      	strb	r5, [r4, #0]
			lcd_sleep_out = true;
   15530:	701a      	strb	r2, [r3, #0]
		fall_testing = false;
   15532:	2300      	movs	r3, #0
   15534:	7033      	strb	r3, [r6, #0]
	if(reset_steps)
   15536:	4b21      	ldr	r3, [pc, #132]	; (155bc <mt_fall_detection+0x128>)
   15538:	4c21      	ldr	r4, [pc, #132]	; (155c0 <mt_fall_detection+0x12c>)
   1553a:	781a      	ldrb	r2, [r3, #0]
   1553c:	b1b2      	cbz	r2, 1556c <mt_fall_detection+0xd8>
		reset_steps = false;
   1553e:	2200      	movs	r2, #0
   15540:	701a      	strb	r2, [r3, #0]
		ReSetImuSteps();
   15542:	f7ff fe93 	bl	1526c <ReSetImuSteps>
		imu_redraw_steps_flag = false;
   15546:	2300      	movs	r3, #0
   15548:	7023      	strb	r3, [r4, #0]
		IMURedrawSteps();
   1554a:	f7ff ff93 	bl	15474 <IMURedrawSteps>
   1554e:	e010      	b.n	15572 <mt_fall_detection+0xde>
			LOG_INF("steps trigger!\n");
   15550:	2203      	movs	r2, #3
   15552:	f362 0007 	bfi	r0, r2, #0, #8
   15556:	f363 108f 	bfi	r0, r3, #6, #10
   1555a:	491a      	ldr	r1, [pc, #104]	; (155c4 <mt_fall_detection+0x130>)
   1555c:	f017 fecc 	bl	2d2f8 <log_string_sync>
			UpdateIMUData();
   15560:	f7f8 fb22 	bl	dba8 <UpdateIMUData>
			imu_redraw_steps_flag = true;	
   15564:	2201      	movs	r2, #1
   15566:	4b16      	ldr	r3, [pc, #88]	; (155c0 <mt_fall_detection+0x12c>)
   15568:	701a      	strb	r2, [r3, #0]
   1556a:	e7be      	b.n	154ea <mt_fall_detection+0x56>
	if(imu_redraw_steps_flag)
   1556c:	7823      	ldrb	r3, [r4, #0]
   1556e:	2b00      	cmp	r3, #0
   15570:	d1e9      	bne.n	15546 <mt_fall_detection+0xb2>
	if(update_sleep_parameter)
   15572:	4b15      	ldr	r3, [pc, #84]	; (155c8 <mt_fall_detection+0x134>)
   15574:	781a      	ldrb	r2, [r3, #0]
   15576:	b12a      	cbz	r2, 15584 <mt_fall_detection+0xf0>
}
   15578:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		update_sleep_parameter = false;
   1557c:	2200      	movs	r2, #0
   1557e:	701a      	strb	r2, [r3, #0]
		UpdateSleepPara();
   15580:	f000 b962 	b.w	15848 <UpdateSleepPara>
}
   15584:	bd70      	pop	{r4, r5, r6, pc}
   15586:	bf00      	nop
   15588:	2002ff2e 	.word	0x2002ff2e
   1558c:	2002ff3d 	.word	0x2002ff3d
   15590:	00030494 	.word	0x00030494
   15594:	0003040c 	.word	0x0003040c
   15598:	000320de 	.word	0x000320de
   1559c:	2003b5ac 	.word	0x2003b5ac
   155a0:	2002d422 	.word	0x2002d422
   155a4:	2002d49c 	.word	0x2002d49c
   155a8:	2002d49b 	.word	0x2002d49b
   155ac:	2002ff34 	.word	0x2002ff34
   155b0:	2002ff1a 	.word	0x2002ff1a
   155b4:	2002ff19 	.word	0x2002ff19
   155b8:	000320fd 	.word	0x000320fd
   155bc:	2002ff3a 	.word	0x2002ff3a
   155c0:	2003b5b0 	.word	0x2003b5b0
   155c4:	000320ed 	.word	0x000320ed
   155c8:	2002ff3e 	.word	0x2002ff3e

000155cc <IMUMsgProcess>:

void IMUMsgProcess(void)
{
	k_work_submit_to_queue(imu_work_q, &imu_work);
   155cc:	4b08      	ldr	r3, [pc, #32]	; (155f0 <IMUMsgProcess+0x24>)
   155ce:	4909      	ldr	r1, [pc, #36]	; (155f4 <IMUMsgProcess+0x28>)
   155d0:	6818      	ldr	r0, [r3, #0]
   155d2:	e8d1 3fef 	ldaex	r3, [r1]
   155d6:	f043 0201 	orr.w	r2, r3, #1
   155da:	e8c1 2fec 	stlex	ip, r2, [r1]
   155de:	f1bc 0f00 	cmp.w	ip, #0
   155e2:	d1f6      	bne.n	155d2 <IMUMsgProcess+0x6>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   155e4:	07db      	lsls	r3, r3, #31
   155e6:	d402      	bmi.n	155ee <IMUMsgProcess+0x22>
		k_queue_append(&work_q->queue, work);
   155e8:	3908      	subs	r1, #8
   155ea:	f019 bd1a 	b.w	2f022 <k_queue_append>
}
   155ee:	4770      	bx	lr
   155f0:	20027e80 	.word	0x20027e80
   155f4:	20027e7c 	.word	0x20027e7c

000155f8 <lsm6dso_from_fs2_to_mg>:
  * @{
  *
*/
float_t lsm6dso_from_fs2_to_mg(int16_t lsb)
{
  return ((float_t)lsb) * 0.061f;
   155f8:	ee07 0a90 	vmov	s15, r0
   155fc:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
}
   15600:	eddf 7a02 	vldr	s15, [pc, #8]	; 1560c <lsm6dso_from_fs2_to_mg+0x14>
   15604:	ee20 0a27 	vmul.f32	s0, s0, s15
   15608:	4770      	bx	lr
   1560a:	bf00      	nop
   1560c:	3d79db23 	.word	0x3d79db23

00015610 <lsm6dso_from_fs250_to_mdps>:
  return ((float_t)lsb) *17.50f;
}

float_t lsm6dso_from_fs250_to_mdps(int16_t lsb)
{
  return ((float_t)lsb) *8.750f;
   15610:	ee07 0a90 	vmov	s15, r0
   15614:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
}
   15618:	eddf 7a02 	vldr	s15, [pc, #8]	; 15624 <lsm6dso_from_fs250_to_mdps+0x14>
   1561c:	ee20 0a27 	vmul.f32	s0, s0, s15
   15620:	4770      	bx	lr
   15622:	bf00      	nop
   15624:	410c0000 	.word	0x410c0000

00015628 <sleep_timer_handler>:
	return deep_sleep_time*1.0;
}

static void sleep_timer_handler(struct k_timer *timer)
{
	update_sleep_parameter = true;
   15628:	2201      	movs	r2, #1
   1562a:	4b01      	ldr	r3, [pc, #4]	; (15630 <sleep_timer_handler+0x8>)
   1562c:	701a      	strb	r2, [r3, #0]
}
   1562e:	4770      	bx	lr
   15630:	2002ff3e 	.word	0x2002ff3e

00015634 <Set_Gsensor_data>:
{	
   15634:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   15638:	461f      	mov	r7, r3
   1563a:	e9dd 4509 	ldrd	r4, r5, [sp, #36]	; 0x24
	if(charging)
   1563e:	2d00      	cmp	r5, #0
   15640:	f040 8084 	bne.w	1574c <Set_Gsensor_data+0x118>
	test = abs(x+y+z);
   15644:	4411      	add	r1, r2
   15646:	4408      	add	r0, r1
   15648:	f019 fe60 	bl	2f30c <abs>
   1564c:	4606      	mov	r6, r0
	if((abs(gsensor-test)) >= 120)  /* gsensor */
   1564e:	f8df 91b0 	ldr.w	r9, [pc, #432]	; 15800 <Set_Gsensor_data+0x1cc>
	hour_time = hour;
   15652:	4b60      	ldr	r3, [pc, #384]	; (157d4 <Set_Gsensor_data+0x1a0>)
	if((abs(gsensor-test)) >= 120)  /* gsensor */
   15654:	f8d9 0000 	ldr.w	r0, [r9]
	hour_time = hour;
   15658:	601c      	str	r4, [r3, #0]
	if((abs(gsensor-test)) >= 120)  /* gsensor */
   1565a:	1b80      	subs	r0, r0, r6
   1565c:	f019 fe56 	bl	2f30c <abs>
   15660:	f8df 81a0 	ldr.w	r8, [pc, #416]	; 15804 <Set_Gsensor_data+0x1d0>
   15664:	2877      	cmp	r0, #119	; 0x77
		watch_state++;
   15666:	bfd8      	it	le
   15668:	f8b8 5000 	ldrhle.w	r5, [r8]
	if(((abs(gsensor-test)) >= 200)||(hr != 0))
   1566c:	f8d9 0000 	ldr.w	r0, [r9]
		watch_state++;
   15670:	bfdc      	itt	le
   15672:	3501      	addle	r5, #1
   15674:	b2ad      	uxthle	r5, r5
	if(((abs(gsensor-test)) >= 200)||(hr != 0))
   15676:	1b80      	subs	r0, r0, r6
   15678:	f8a8 5000 	strh.w	r5, [r8]
   1567c:	f019 fe46 	bl	2f30c <abs>
   15680:	28c7      	cmp	r0, #199	; 0xc7
   15682:	dc01      	bgt.n	15688 <Set_Gsensor_data+0x54>
   15684:	9b08      	ldr	r3, [sp, #32]
   15686:	b13b      	cbz	r3, 15698 <Set_Gsensor_data+0x64>
		if(hour < 6)
   15688:	2c05      	cmp	r4, #5
			waggle_level[hour]++;  /* 06gsensor 00*/
   1568a:	bfdf      	itttt	le
   1568c:	4a52      	ldrle	r2, [pc, #328]	; (157d8 <Set_Gsensor_data+0x1a4>)
   1568e:	f852 3024 	ldrle.w	r3, [r2, r4, lsl #2]
   15692:	3301      	addle	r3, #1
   15694:	f842 3024 	strle.w	r3, [r2, r4, lsl #2]
	if((rtc_sec % 60) == 0)  /* */
   15698:	223c      	movs	r2, #60	; 0x3c
   1569a:	4d50      	ldr	r5, [pc, #320]	; (157dc <Set_Gsensor_data+0x1a8>)
	gsensor = test;
   1569c:	f8c9 6000 	str.w	r6, [r9]
	if((rtc_sec % 60) == 0)  /* */
   156a0:	6829      	ldr	r1, [r5, #0]
   156a2:	4e4f      	ldr	r6, [pc, #316]	; (157e0 <Set_Gsensor_data+0x1ac>)
   156a4:	fb91 f3f2 	sdiv	r3, r1, r2
   156a8:	fb02 1313 	mls	r3, r2, r3, r1
   156ac:	2b00      	cmp	r3, #0
   156ae:	d149      	bne.n	15744 <Set_Gsensor_data+0x110>
		if(((move <step)&&(move>0))||(move_flag > 0))  /*  move_flag  */
   156b0:	6832      	ldr	r2, [r6, #0]
   156b2:	4b4c      	ldr	r3, [pc, #304]	; (157e4 <Set_Gsensor_data+0x1b0>)
   156b4:	4297      	cmp	r7, r2
   156b6:	dd01      	ble.n	156bc <Set_Gsensor_data+0x88>
   156b8:	2a00      	cmp	r2, #0
   156ba:	dc02      	bgt.n	156c2 <Set_Gsensor_data+0x8e>
   156bc:	6818      	ldr	r0, [r3, #0]
   156be:	2800      	cmp	r0, #0
   156c0:	dd4a      	ble.n	15758 <Set_Gsensor_data+0x124>
			if((move_flag == 0)||((move <step)&&(move>0)))
   156c2:	6819      	ldr	r1, [r3, #0]
   156c4:	b119      	cbz	r1, 156ce <Set_Gsensor_data+0x9a>
   156c6:	4297      	cmp	r7, r2
   156c8:	dd42      	ble.n	15750 <Set_Gsensor_data+0x11c>
   156ca:	2a00      	cmp	r2, #0
   156cc:	dd40      	ble.n	15750 <Set_Gsensor_data+0x11c>
				move_flag = 1;
   156ce:	2101      	movs	r1, #1
				move_flag--;
   156d0:	6019      	str	r1, [r3, #0]
			if(hour<8)
   156d2:	2c07      	cmp	r4, #7
   156d4:	dc49      	bgt.n	1576a <Set_Gsensor_data+0x136>
				sedentary_time_temp++;
   156d6:	4944      	ldr	r1, [pc, #272]	; (157e8 <Set_Gsensor_data+0x1b4>)
				sedentary_time_temp++;   /*  */
   156d8:	680b      	ldr	r3, [r1, #0]
   156da:	3301      	adds	r3, #1
   156dc:	600b      	str	r3, [r1, #0]
			if((hour>=6)&&(hour<=8)&&(waggle_flag==0))
   156de:	1fa3      	subs	r3, r4, #6
   156e0:	2b02      	cmp	r3, #2
   156e2:	d815      	bhi.n	15710 <Set_Gsensor_data+0xdc>
   156e4:	4941      	ldr	r1, [pc, #260]	; (157ec <Set_Gsensor_data+0x1b8>)
   156e6:	680b      	ldr	r3, [r1, #0]
   156e8:	b993      	cbnz	r3, 15710 <Set_Gsensor_data+0xdc>
				for(i=0;i<6;i++)	
   156ea:	4618      	mov	r0, r3
			if((hour>=6)&&(hour<=8)&&(waggle_flag==0))
   156ec:	469c      	mov	ip, r3
   156ee:	f8df e0e8 	ldr.w	lr, [pc, #232]	; 157d8 <Set_Gsensor_data+0x1a4>
					if(waggle_level[i]==0)
   156f2:	f85e 9b04 	ldr.w	r9, [lr], #4
   156f6:	f1b9 0f00 	cmp.w	r9, #0
   156fa:	d102      	bne.n	15702 <Set_Gsensor_data+0xce>
						waggle_flag++; /* 06 */
   156fc:	f04f 0c01 	mov.w	ip, #1
   15700:	3301      	adds	r3, #1
				for(i=0;i<6;i++)	
   15702:	3001      	adds	r0, #1
   15704:	2806      	cmp	r0, #6
   15706:	d1f4      	bne.n	156f2 <Set_Gsensor_data+0xbe>
   15708:	f1bc 0f00 	cmp.w	ip, #0
   1570c:	d000      	beq.n	15710 <Set_Gsensor_data+0xdc>
   1570e:	600b      	str	r3, [r1, #0]
			if((watch_state >= (3600*2))||(waggle_flag >= 7)||/* (3)23*/
   15710:	f8b8 3000 	ldrh.w	r3, [r8]
   15714:	f5b3 5fe1 	cmp.w	r3, #7200	; 0x1c20
   15718:	d209      	bcs.n	1572e <Set_Gsensor_data+0xfa>
   1571a:	4934      	ldr	r1, [pc, #208]	; (157ec <Set_Gsensor_data+0x1b8>)
   1571c:	6809      	ldr	r1, [r1, #0]
   1571e:	2906      	cmp	r1, #6
   15720:	dc05      	bgt.n	1572e <Set_Gsensor_data+0xfa>
   15722:	2c07      	cmp	r4, #7
   15724:	dc39      	bgt.n	1579a <Set_Gsensor_data+0x166>
				((hour<8)&&(sedentary_time_temp > 180)))  /* 1500*/
   15726:	4930      	ldr	r1, [pc, #192]	; (157e8 <Set_Gsensor_data+0x1b4>)
   15728:	6809      	ldr	r1, [r1, #0]
   1572a:	29b4      	cmp	r1, #180	; 0xb4
   1572c:	dd35      	ble.n	1579a <Set_Gsensor_data+0x166>
				sedentary_time_temp = 0;
   1572e:	2300      	movs	r3, #0
   15730:	4a2d      	ldr	r2, [pc, #180]	; (157e8 <Set_Gsensor_data+0x1b4>)
   15732:	6013      	str	r3, [r2, #0]
				light_sleep_time = 0;				 
   15734:	4a2e      	ldr	r2, [pc, #184]	; (157f0 <Set_Gsensor_data+0x1bc>)
   15736:	8013      	strh	r3, [r2, #0]
				deep_sleep_time = 0;
   15738:	4a2e      	ldr	r2, [pc, #184]	; (157f4 <Set_Gsensor_data+0x1c0>)
   1573a:	8013      	strh	r3, [r2, #0]
				g_light_sleep = 0;
   1573c:	4a2e      	ldr	r2, [pc, #184]	; (157f8 <Set_Gsensor_data+0x1c4>)
   1573e:	8013      	strh	r3, [r2, #0]
				g_deep_sleep = 0;
   15740:	4a2e      	ldr	r2, [pc, #184]	; (157fc <Set_Gsensor_data+0x1c8>)
   15742:	8013      	strh	r3, [r2, #0]
	rtc_sec++;
   15744:	682b      	ldr	r3, [r5, #0]
	move = step;
   15746:	6037      	str	r7, [r6, #0]
	rtc_sec++;
   15748:	3301      	adds	r3, #1
   1574a:	602b      	str	r3, [r5, #0]
}
   1574c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			else if(move_flag > 0)
   15750:	2900      	cmp	r1, #0
   15752:	ddbe      	ble.n	156d2 <Set_Gsensor_data+0x9e>
				move_flag--;
   15754:	3901      	subs	r1, #1
   15756:	e7bb      	b.n	156d0 <Set_Gsensor_data+0x9c>
		else if((watch_state <= 60)&&(move_flag == 0))
   15758:	f8b8 1000 	ldrh.w	r1, [r8]
   1575c:	293c      	cmp	r1, #60	; 0x3c
   1575e:	d804      	bhi.n	1576a <Set_Gsensor_data+0x136>
   15760:	b918      	cbnz	r0, 1576a <Set_Gsensor_data+0x136>
			if(hour<8)
   15762:	2c07      	cmp	r4, #7
   15764:	4920      	ldr	r1, [pc, #128]	; (157e8 <Set_Gsensor_data+0x1b4>)
   15766:	ddb7      	ble.n	156d8 <Set_Gsensor_data+0xa4>
				sedentary_time_temp = 0;
   15768:	6008      	str	r0, [r1, #0]
		if((hour>=20)||(hour<8))  /* 24 88 */
   1576a:	f1a4 0108 	sub.w	r1, r4, #8
   1576e:	290b      	cmp	r1, #11
   15770:	d8b5      	bhi.n	156de <Set_Gsensor_data+0xaa>
			gsensor = 0;
   15772:	2100      	movs	r1, #0
			move_flag = 0;
   15774:	6019      	str	r1, [r3, #0]
			waggle_flag = 0;
   15776:	4b1d      	ldr	r3, [pc, #116]	; (157ec <Set_Gsensor_data+0x1b8>)
			memset(waggle_level,0,sizeof(waggle_level)); /*  */
   15778:	2230      	movs	r2, #48	; 0x30
			waggle_flag = 0;
   1577a:	6019      	str	r1, [r3, #0]
			deep_sleep_time = 0; 
   1577c:	4b1d      	ldr	r3, [pc, #116]	; (157f4 <Set_Gsensor_data+0x1c0>)
			memset(waggle_level,0,sizeof(waggle_level)); /*  */
   1577e:	4816      	ldr	r0, [pc, #88]	; (157d8 <Set_Gsensor_data+0x1a4>)
			deep_sleep_time = 0; 
   15780:	8019      	strh	r1, [r3, #0]
			light_sleep_time = 0;
   15782:	4b1b      	ldr	r3, [pc, #108]	; (157f0 <Set_Gsensor_data+0x1bc>)
			gsensor = 0;
   15784:	f8c9 1000 	str.w	r1, [r9]
			light_sleep_time = 0;
   15788:	8019      	strh	r1, [r3, #0]
			sedentary_time_temp = 0;			
   1578a:	4b17      	ldr	r3, [pc, #92]	; (157e8 <Set_Gsensor_data+0x1b4>)
			rtc_sec = 0;
   1578c:	6029      	str	r1, [r5, #0]
			watch_state = 0;
   1578e:	f8a8 1000 	strh.w	r1, [r8]
			sedentary_time_temp = 0;			
   15792:	6019      	str	r1, [r3, #0]
			memset(waggle_level,0,sizeof(waggle_level)); /*  */
   15794:	f019 fdfe 	bl	2f394 <memset>
   15798:	e7d4      	b.n	15744 <Set_Gsensor_data+0x110>
			else if((move == step)&&(watch_state >= 60)) /*  */
   1579a:	4297      	cmp	r7, r2
   1579c:	d1d2      	bne.n	15744 <Set_Gsensor_data+0x110>
   1579e:	2b3b      	cmp	r3, #59	; 0x3b
   157a0:	d9d0      	bls.n	15744 <Set_Gsensor_data+0x110>
				if(is_wearing())	//xb add 2021-03-02 
   157a2:	f015 ff63 	bl	2b66c <is_wearing>
   157a6:	4a12      	ldr	r2, [pc, #72]	; (157f0 <Set_Gsensor_data+0x1bc>)
   157a8:	4b12      	ldr	r3, [pc, #72]	; (157f4 <Set_Gsensor_data+0x1c0>)
   157aa:	b158      	cbz	r0, 157c4 <Set_Gsensor_data+0x190>
					if(watch_state >= (60*10))/* 15*/
   157ac:	f8b8 1000 	ldrh.w	r1, [r8]
   157b0:	f5b1 7f16 	cmp.w	r1, #600	; 0x258
						deep_sleep_time++; 
   157b4:	bf2b      	itete	cs
   157b6:	8819      	ldrhcs	r1, [r3, #0]
						light_sleep_time++;
   157b8:	8811      	ldrhcc	r1, [r2, #0]
						deep_sleep_time++; 
   157ba:	3101      	addcs	r1, #1
						light_sleep_time++;
   157bc:	3101      	addcc	r1, #1
						deep_sleep_time++; 
   157be:	bf2c      	ite	cs
   157c0:	8019      	strhcs	r1, [r3, #0]
						light_sleep_time++;
   157c2:	8011      	strhcc	r1, [r2, #0]
				g_light_sleep = light_sleep_time;
   157c4:	8811      	ldrh	r1, [r2, #0]
   157c6:	4a0c      	ldr	r2, [pc, #48]	; (157f8 <Set_Gsensor_data+0x1c4>)
   157c8:	8011      	strh	r1, [r2, #0]
				g_deep_sleep = deep_sleep_time;
   157ca:	881a      	ldrh	r2, [r3, #0]
   157cc:	4b0b      	ldr	r3, [pc, #44]	; (157fc <Set_Gsensor_data+0x1c8>)
   157ce:	801a      	strh	r2, [r3, #0]
   157d0:	e7b8      	b.n	15744 <Set_Gsensor_data+0x110>
   157d2:	bf00      	nop
   157d4:	200284cc 	.word	0x200284cc
   157d8:	20028510 	.word	0x20028510
   157dc:	200284d8 	.word	0x200284d8
   157e0:	200284d0 	.word	0x200284d0
   157e4:	200284d4 	.word	0x200284d4
   157e8:	200284dc 	.word	0x200284dc
   157ec:	2002850c 	.word	0x2002850c
   157f0:	2002d484 	.word	0x2002d484
   157f4:	2002d47e 	.word	0x2002d47e
   157f8:	2002d482 	.word	0x2002d482
   157fc:	2002d480 	.word	0x2002d480
   15800:	200284c8 	.word	0x200284c8
   15804:	2002d486 	.word	0x2002d486

00015808 <StartSleepTimeMonitor>:

void StartSleepTimeMonitor(void)
{
   15808:	b510      	push	{r4, lr}
	k_timer_init(&sleep_timer, sleep_timer_handler, NULL);
   1580a:	4c07      	ldr	r4, [pc, #28]	; (15828 <StartSleepTimeMonitor+0x20>)
   1580c:	2200      	movs	r2, #0
   1580e:	4907      	ldr	r1, [pc, #28]	; (1582c <StartSleepTimeMonitor+0x24>)
   15810:	4620      	mov	r0, r4
   15812:	f019 fcf0 	bl	2f1f6 <k_timer_init>
   15816:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1581a:	4620      	mov	r0, r4
	k_timer_start(&sleep_timer, K_MSEC(1000), K_MSEC(1000));
}
   1581c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   15820:	4611      	mov	r1, r2
   15822:	f013 bd0f 	b.w	29244 <z_impl_k_timer_start>
   15826:	bf00      	nop
   15828:	200284e0 	.word	0x200284e0
   1582c:	00015629 	.word	0x00015629

00015830 <GetSleepTimeData>:

void GetSleepTimeData(u16_t *deep_sleep, u16_t *light_sleep)
{
	*deep_sleep = g_deep_sleep;
   15830:	4b03      	ldr	r3, [pc, #12]	; (15840 <GetSleepTimeData+0x10>)
   15832:	881b      	ldrh	r3, [r3, #0]
   15834:	8003      	strh	r3, [r0, #0]
	*light_sleep = g_light_sleep;
   15836:	4b03      	ldr	r3, [pc, #12]	; (15844 <GetSleepTimeData+0x14>)
   15838:	881b      	ldrh	r3, [r3, #0]
   1583a:	800b      	strh	r3, [r1, #0]
}
   1583c:	4770      	bx	lr
   1583e:	bf00      	nop
   15840:	2002d480 	.word	0x2002d480
   15844:	2002d482 	.word	0x2002d482

00015848 <UpdateSleepPara>:

	LOG_INF("deep_sleep:%d, light_sleep:%d\n", deep_sleep, light_sleep);
}

void UpdateSleepPara(void)
{
   15848:	b510      	push	{r4, lr}
	u16_t steps;
	float sensor_x,sensor_y,sensor_z;
	int chg = 0;

	if(g_chg_status != BAT_CHARGING_NO)
   1584a:	4b12      	ldr	r3, [pc, #72]	; (15894 <UpdateSleepPara+0x4c>)
{
   1584c:	b088      	sub	sp, #32
	if(g_chg_status != BAT_CHARGING_NO)
   1584e:	781c      	ldrb	r4, [r3, #0]
		chg = 1;
	
	get_sensor_reading(&sensor_x, &sensor_y, &sensor_z);
   15850:	aa07      	add	r2, sp, #28
	if(g_chg_status != BAT_CHARGING_NO)
   15852:	3400      	adds	r4, #0
	get_sensor_reading(&sensor_x, &sensor_y, &sensor_z);
   15854:	a906      	add	r1, sp, #24
   15856:	a805      	add	r0, sp, #20
	if(g_chg_status != BAT_CHARGING_NO)
   15858:	bf18      	it	ne
   1585a:	2401      	movne	r4, #1
	get_sensor_reading(&sensor_x, &sensor_y, &sensor_z);
   1585c:	f7ff fa52 	bl	14d04 <get_sensor_reading>
	GetImuSteps(&steps);
   15860:	f10d 0012 	add.w	r0, sp, #18
   15864:	f7ff fd08 	bl	15278 <GetImuSteps>
	Set_Gsensor_data((signed short)sensor_x, (signed short)sensor_x, (signed short)sensor_x, steps, 80, date_time.hour, chg);
   15868:	eddd 7a05 	vldr	s15, [sp, #20]
   1586c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   15870:	ee17 3a90 	vmov	r3, s15
   15874:	b21a      	sxth	r2, r3
   15876:	4b08      	ldr	r3, [pc, #32]	; (15898 <UpdateSleepPara+0x50>)
   15878:	9402      	str	r4, [sp, #8]
   1587a:	791b      	ldrb	r3, [r3, #4]
   1587c:	4611      	mov	r1, r2
   1587e:	9301      	str	r3, [sp, #4]
   15880:	2350      	movs	r3, #80	; 0x50
   15882:	4610      	mov	r0, r2
   15884:	9300      	str	r3, [sp, #0]
   15886:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   1588a:	f7ff fed3 	bl	15634 <Set_Gsensor_data>
}
   1588e:	b008      	add	sp, #32
   15890:	bd10      	pop	{r4, pc}
   15892:	bf00      	nop
   15894:	2002ff96 	.word	0x2002ff96
   15898:	2002d410 	.word	0x2002d410

0001589c <EnterNotifyScreen>:
	ExitNotifyScreen();
}

void EnterNotifyScreen(void)
{
	if(screen_id == SCREEN_ID_NOTIFY)
   1589c:	4908      	ldr	r1, [pc, #32]	; (158c0 <EnterNotifyScreen+0x24>)
   1589e:	780b      	ldrb	r3, [r1, #0]
   158a0:	2b0f      	cmp	r3, #15
   158a2:	d00b      	beq.n	158bc <EnterNotifyScreen+0x20>
		return;

	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   158a4:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   158a6:	4a07      	ldr	r2, [pc, #28]	; (158c4 <EnterNotifyScreen+0x28>)
   158a8:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   158aa:	4a07      	ldr	r2, [pc, #28]	; (158c8 <EnterNotifyScreen+0x2c>)
   158ac:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_NOTIFY;	
   158b0:	230f      	movs	r3, #15
   158b2:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_NOTIFY].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_NOTIFY].status = SCREEN_STATUS_CREATING;	
   158b4:	f240 1301 	movw	r3, #257	; 0x101
   158b8:	f8a2 3078 	strh.w	r3, [r2, #120]	; 0x78
}
   158bc:	4770      	bx	lr
   158be:	bf00      	nop
   158c0:	2002ff93 	.word	0x2002ff93
   158c4:	2002ff3f 	.word	0x2002ff3f
   158c8:	20028540 	.word	0x20028540

000158cc <DisplayPopUp>:

void DisplayPopUp(u8_t *message)
{
   158cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t len;
	
	notify_msg.type = NOTIFY_TYPE_POPUP;
   158ce:	2500      	movs	r5, #0
   158d0:	4c10      	ldr	r4, [pc, #64]	; (15914 <DisplayPopUp+0x48>)
{
   158d2:	4606      	mov	r6, r0
	notify_msg.type = NOTIFY_TYPE_POPUP;
   158d4:	7025      	strb	r5, [r4, #0]
	notify_msg.align = NOTIFY_ALIGN_CENTER;
   158d6:	7065      	strb	r5, [r4, #1]
	
	len = strlen(message);
   158d8:	f7f7 fb3e 	bl	cf58 <strlen>
   158dc:	4607      	mov	r7, r0
	if(len > NOTIFY_TEXT_MAX_LEN)
		len = NOTIFY_TEXT_MAX_LEN;
	memset(notify_msg.text, 0x00, sizeof(notify_msg.text));
   158de:	2251      	movs	r2, #81	; 0x51
   158e0:	4629      	mov	r1, r5
   158e2:	1ca0      	adds	r0, r4, #2
   158e4:	f019 fd56 	bl	2f394 <memset>
	memcpy(notify_msg.text, message, len);
   158e8:	2f50      	cmp	r7, #80	; 0x50
   158ea:	463a      	mov	r2, r7
   158ec:	f04f 0351 	mov.w	r3, #81	; 0x51
   158f0:	bf28      	it	cs
   158f2:	2250      	movcs	r2, #80	; 0x50
   158f4:	4631      	mov	r1, r6
   158f6:	1ca0      	adds	r0, r4, #2
   158f8:	f019 fd39 	bl	2f36e <__memcpy_chk>

	if(notify_msg.type == NOTIFY_TYPE_POPUP)
   158fc:	7822      	ldrb	r2, [r4, #0]
   158fe:	b922      	cbnz	r2, 1590a <DisplayPopUp+0x3e>
   15900:	f241 3188 	movw	r1, #5000	; 0x1388
   15904:	4804      	ldr	r0, [pc, #16]	; (15918 <DisplayPopUp+0x4c>)
   15906:	f013 fc9d 	bl	29244 <z_impl_k_timer_start>
	{
		k_timer_start(&notify_timer, K_SECONDS(NOTIFY_TIMER_INTERVAL), NULL);
	}
	
	EnterNotifyScreen();
}
   1590a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	EnterNotifyScreen();
   1590e:	f7ff bfc5 	b.w	1589c <EnterNotifyScreen>
   15912:	bf00      	nop
   15914:	2002ff40 	.word	0x2002ff40
   15918:	2003b794 	.word	0x2003b794

0001591c <IdleShowSystemDate>:
void IdleShowSystemDate(void)
{
   1591c:	b530      	push	{r4, r5, lr}
   1591e:	b089      	sub	sp, #36	; 0x24
	u16_t x,y,w,h;
	u8_t str_date[20] = {0};
   15920:	2100      	movs	r1, #0
   15922:	2214      	movs	r2, #20
   15924:	a803      	add	r0, sp, #12
   15926:	f019 fd35 	bl	2f394 <memset>

	POINT_COLOR=WHITE;
	BACK_COLOR=BLACK;
   1592a:	2400      	movs	r4, #0
	POINT_COLOR=WHITE;
   1592c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   15930:	4b18      	ldr	r3, [pc, #96]	; (15994 <IdleShowSystemDate+0x78>)
	BACK_COLOR=BLACK;
   15932:	4d19      	ldr	r5, [pc, #100]	; (15998 <IdleShowSystemDate+0x7c>)

#ifdef FONT_32
	LCD_SetFontSize(FONT_SIZE_32);
   15934:	2020      	movs	r0, #32
	POINT_COLOR=WHITE;
   15936:	801a      	strh	r2, [r3, #0]
	BACK_COLOR=BLACK;
   15938:	802c      	strh	r4, [r5, #0]
	LCD_SetFontSize(FONT_SIZE_32);
   1593a:	f7fb fab7 	bl	10eac <LCD_SetFontSize>
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);	
	LCD_ShowUniString(x,y,str_date);
	
#else

	GetSystemDateStrings(str_date);
   1593e:	a803      	add	r0, sp, #12
   15940:	f7fa feea 	bl	10718 <GetSystemDateStrings>
	LCD_MeasureString(str_date,&w,&h);
   15944:	a803      	add	r0, sp, #12
   15946:	f10d 020a 	add.w	r2, sp, #10
   1594a:	a902      	add	r1, sp, #8
   1594c:	f7fb fa8a 	bl	10e64 <LCD_MeasureString>
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   15950:	4629      	mov	r1, r5
   15952:	4b12      	ldr	r3, [pc, #72]	; (1599c <IdleShowSystemDate+0x80>)
   15954:	881a      	ldrh	r2, [r3, #0]
   15956:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   1595a:	429a      	cmp	r2, r3
   1595c:	bf88      	it	hi
   1595e:	1ad0      	subhi	r0, r2, r3
	y = IDLE_DATE_SHOW_Y;
   15960:	4b0f      	ldr	r3, [pc, #60]	; (159a0 <IdleShowSystemDate+0x84>)
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   15962:	bf88      	it	hi
   15964:	eb00 70d0 	addhi.w	r0, r0, r0, lsr #31
	y = IDLE_DATE_SHOW_Y;
   15968:	781d      	ldrb	r5, [r3, #0]
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);	
   1596a:	880b      	ldrh	r3, [r1, #0]
	y = IDLE_DATE_SHOW_Y;
   1596c:	f105 0536 	add.w	r5, r5, #54	; 0x36
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   15970:	bf88      	it	hi
   15972:	f3c0 044f 	ubfxhi	r4, r0, #1, #16
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);	
   15976:	9300      	str	r3, [sp, #0]
   15978:	4629      	mov	r1, r5
   1597a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
   1597e:	2000      	movs	r0, #0
   15980:	f7fb f8ca 	bl	10b18 <LCD_Fill>
	LCD_ShowString(x,y,str_date);
   15984:	aa03      	add	r2, sp, #12
   15986:	4629      	mov	r1, r5
   15988:	4620      	mov	r0, r4
   1598a:	f7fb fa39 	bl	10e00 <LCD_ShowString>
#endif
}
   1598e:	b009      	add	sp, #36	; 0x24
   15990:	bd30      	pop	{r4, r5, pc}
   15992:	bf00      	nop
   15994:	200385a8 	.word	0x200385a8
   15998:	2002d420 	.word	0x2002d420
   1599c:	200385a6 	.word	0x200385a6
   159a0:	2003b5ad 	.word	0x2003b5ad

000159a4 <IdleShowSystemTime>:

void IdleShowSystemTime(void)
{
   159a4:	b510      	push	{r4, lr}
   159a6:	b088      	sub	sp, #32
	u16_t x,y,w,h,offset;
	u8_t str_time[20] = {0};
   159a8:	2100      	movs	r1, #0
   159aa:	2214      	movs	r2, #20
   159ac:	a803      	add	r0, sp, #12
   159ae:	f019 fcf1 	bl	2f394 <memset>
	u8_t str_ampm[5] = {0};

	POINT_COLOR=WHITE;
   159b2:	f64f 72ff 	movw	r2, #65535	; 0xffff
	u8_t str_ampm[5] = {0};
   159b6:	2400      	movs	r4, #0
	POINT_COLOR=WHITE;
   159b8:	4b19      	ldr	r3, [pc, #100]	; (15a20 <IdleShowSystemTime+0x7c>)
	BACK_COLOR=BLACK;
	
#ifdef FONT_32
	LCD_SetFontSize(FONT_SIZE_32);
   159ba:	2020      	movs	r0, #32
	POINT_COLOR=WHITE;
   159bc:	801a      	strh	r2, [r3, #0]
	BACK_COLOR=BLACK;
   159be:	4b19      	ldr	r3, [pc, #100]	; (15a24 <IdleShowSystemTime+0x80>)
	u8_t str_ampm[5] = {0};
   159c0:	9401      	str	r4, [sp, #4]
	BACK_COLOR=BLACK;
   159c2:	801c      	strh	r4, [r3, #0]
	u8_t str_ampm[5] = {0};
   159c4:	f88d 4008 	strb.w	r4, [sp, #8]
	LCD_SetFontSize(FONT_SIZE_32);
   159c8:	f7fb fa70 	bl	10eac <LCD_SetFontSize>
	y = IDLE_TIME_SHOW_Y+offset;
	LCD_ShowUniString(x,y,str_ampm);

#else

	GetSystemTimeStrings(str_time);
   159cc:	a803      	add	r0, sp, #12
   159ce:	f7fa fef3 	bl	107b8 <GetSystemTimeStrings>
	LCD_MeasureString(str_time,&w,&h);
   159d2:	f10d 0202 	add.w	r2, sp, #2
   159d6:	4669      	mov	r1, sp
   159d8:	a803      	add	r0, sp, #12
   159da:	f7fb fa43 	bl	10e64 <LCD_MeasureString>
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   159de:	4b12      	ldr	r3, [pc, #72]	; (15a28 <IdleShowSystemTime+0x84>)
   159e0:	f8bd 2000 	ldrh.w	r2, [sp]
   159e4:	881b      	ldrh	r3, [r3, #0]
	y = IDLE_TIME_SHOW_Y;
	LCD_ShowString(x,y,str_time);
   159e6:	2136      	movs	r1, #54	; 0x36
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   159e8:	4293      	cmp	r3, r2
   159ea:	bf82      	ittt	hi
   159ec:	1a9c      	subhi	r4, r3, r2
   159ee:	eb04 74d4 	addhi.w	r4, r4, r4, lsr #31
   159f2:	f3c4 044f 	ubfxhi	r4, r4, #1, #16
	LCD_ShowString(x,y,str_time);
   159f6:	aa03      	add	r2, sp, #12
   159f8:	4620      	mov	r0, r4
   159fa:	f7fb fa01 	bl	10e00 <LCD_ShowString>

	LCD_SetFontSize(FONT_SIZE_16);
   159fe:	2010      	movs	r0, #16
   15a00:	f7fb fa54 	bl	10eac <LCD_SetFontSize>
	GetSysteAmPmStrings(str_ampm);
   15a04:	a801      	add	r0, sp, #4
   15a06:	f7fa feb1 	bl	1076c <GetSysteAmPmStrings>
	x = x+w+5;
   15a0a:	f8bd 0000 	ldrh.w	r0, [sp]
	y = IDLE_TIME_SHOW_Y+offset;
	LCD_ShowString(x,y,str_ampm);
   15a0e:	aa01      	add	r2, sp, #4
	x = x+w+5;
   15a10:	4404      	add	r4, r0
   15a12:	1d60      	adds	r0, r4, #5
	LCD_ShowString(x,y,str_ampm);
   15a14:	2146      	movs	r1, #70	; 0x46
   15a16:	b280      	uxth	r0, r0
   15a18:	f7fb f9f2 	bl	10e00 <LCD_ShowString>
#endif
}
   15a1c:	b008      	add	sp, #32
   15a1e:	bd10      	pop	{r4, pc}
   15a20:	200385a8 	.word	0x200385a8
   15a24:	2002d420 	.word	0x2002d420
   15a28:	200385a6 	.word	0x200385a6

00015a2c <IdleShowSystemWeek>:

void IdleShowSystemWeek(void)
{
   15a2c:	b570      	push	{r4, r5, r6, lr}
   15a2e:	b0a4      	sub	sp, #144	; 0x90
	u16_t x,y,w,h;
	u8_t str_week[128] = {0};
   15a30:	2100      	movs	r1, #0
   15a32:	2280      	movs	r2, #128	; 0x80
   15a34:	a804      	add	r0, sp, #16
   15a36:	f019 fcad 	bl	2f394 <memset>

	POINT_COLOR=WHITE;
   15a3a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   15a3e:	4b20      	ldr	r3, [pc, #128]	; (15ac0 <IdleShowSystemWeek+0x94>)
	BACK_COLOR=BLACK;
   15a40:	4e20      	ldr	r6, [pc, #128]	; (15ac4 <IdleShowSystemWeek+0x98>)
	POINT_COLOR=WHITE;
   15a42:	801a      	strh	r2, [r3, #0]
	BACK_COLOR=BLACK;
   15a44:	2300      	movs	r3, #0

#ifdef FONT_32
	LCD_SetFontSize(FONT_SIZE_32);
   15a46:	2020      	movs	r0, #32
	BACK_COLOR=BLACK;
   15a48:	8033      	strh	r3, [r6, #0]
	LCD_SetFontSize(FONT_SIZE_32);
   15a4a:	f7fb fa2f 	bl	10eac <LCD_SetFontSize>
	LCD_SetFontSize(FONT_SIZE_24);
#else
	LCD_SetFontSize(FONT_SIZE_16);
#endif

	GetSystemWeekStrings(str_week);
   15a4e:	a804      	add	r0, sp, #16
   15a50:	f7fa fed4 	bl	107fc <GetSystemWeekStrings>
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);
	LCD_ShowUniString(x,y,str_week);

#else
	//xb add 2020-11-06
	if(global_settings.language == LANGUAGE_CHN)
   15a54:	4b1c      	ldr	r3, [pc, #112]	; (15ac8 <IdleShowSystemWeek+0x9c>)
   15a56:	7a5b      	ldrb	r3, [r3, #9]
   15a58:	2b01      	cmp	r3, #1
   15a5a:	d12d      	bne.n	15ab8 <IdleShowSystemWeek+0x8c>
		strcpy(str_week,"It has no chinese font!");
   15a5c:	491b      	ldr	r1, [pc, #108]	; (15acc <IdleShowSystemWeek+0xa0>)
	else if(global_settings.language == LANGUAGE_JPN)
		strcpy(str_week,"It has no japanese font!");
   15a5e:	a804      	add	r0, sp, #16
   15a60:	f019 fe19 	bl	2f696 <strcpy>
	//xb end

	LCD_MeasureString(str_week,&w,&h);
   15a64:	f10d 020e 	add.w	r2, sp, #14
   15a68:	a903      	add	r1, sp, #12
   15a6a:	a804      	add	r0, sp, #16
   15a6c:	f7fb f9fa 	bl	10e64 <LCD_MeasureString>
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   15a70:	4b17      	ldr	r3, [pc, #92]	; (15ad0 <IdleShowSystemWeek+0xa4>)
   15a72:	f8bd 400c 	ldrh.w	r4, [sp, #12]
   15a76:	881a      	ldrh	r2, [r3, #0]
	y = IDLE_WEEK_SHOW_Y;
   15a78:	4b16      	ldr	r3, [pc, #88]	; (15ad4 <IdleShowSystemWeek+0xa8>)
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   15a7a:	42a2      	cmp	r2, r4
   15a7c:	bf98      	it	ls
   15a7e:	2400      	movls	r4, #0
	y = IDLE_WEEK_SHOW_Y;
   15a80:	781d      	ldrb	r5, [r3, #0]
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   15a82:	bf88      	it	hi
   15a84:	1b14      	subhi	r4, r2, r4
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);
   15a86:	8833      	ldrh	r3, [r6, #0]
	y = IDLE_WEEK_SHOW_Y;
   15a88:	f105 051b 	add.w	r5, r5, #27
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   15a8c:	bf88      	it	hi
   15a8e:	eb04 74d4 	addhi.w	r4, r4, r4, lsr #31
	y = IDLE_WEEK_SHOW_Y;
   15a92:	ea4f 0545 	mov.w	r5, r5, lsl #1
	x = (LCD_WIDTH > w) ? (LCD_WIDTH-w)/2 : 0;
   15a96:	bf88      	it	hi
   15a98:	f3c4 044f 	ubfxhi	r4, r4, #1, #16
	LCD_Fill(0, y, LCD_WIDTH, h, BACK_COLOR);
   15a9c:	9300      	str	r3, [sp, #0]
   15a9e:	4629      	mov	r1, r5
   15aa0:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   15aa4:	2000      	movs	r0, #0
   15aa6:	f7fb f837 	bl	10b18 <LCD_Fill>
	LCD_ShowString(x,y,str_week);
   15aaa:	aa04      	add	r2, sp, #16
   15aac:	4629      	mov	r1, r5
   15aae:	4620      	mov	r0, r4
   15ab0:	f7fb f9a6 	bl	10e00 <LCD_ShowString>
#endif
}
   15ab4:	b024      	add	sp, #144	; 0x90
   15ab6:	bd70      	pop	{r4, r5, r6, pc}
	else if(global_settings.language == LANGUAGE_JPN)
   15ab8:	2b02      	cmp	r3, #2
   15aba:	d1d3      	bne.n	15a64 <IdleShowSystemWeek+0x38>
		strcpy(str_week,"It has no japanese font!");
   15abc:	4906      	ldr	r1, [pc, #24]	; (15ad8 <IdleShowSystemWeek+0xac>)
   15abe:	e7ce      	b.n	15a5e <IdleShowSystemWeek+0x32>
   15ac0:	200385a8 	.word	0x200385a8
   15ac4:	2002d420 	.word	0x2002d420
   15ac8:	2002d422 	.word	0x2002d422
   15acc:	00032129 	.word	0x00032129
   15ad0:	200385a6 	.word	0x200385a6
   15ad4:	2003b5ad 	.word	0x2003b5ad
   15ad8:	00032141 	.word	0x00032141

00015adc <IdleUpdateBatSoc>:
	IdleShowSystemDate();
	IdleShowSystemWeek();
}

void IdleUpdateBatSoc(void)
{
   15adc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	u16_t x,y,w,h;
	u8_t strbuf[10] = {0};
   15ade:	2300      	movs	r3, #0
	u8_t tmpbuf[128] = {0};
	
	LCD_Fill(BAT_SUBJECT_X+1,BAT_SUBJECT_Y+1,BAT_SUBJECT_W-2,BAT_SUBJECT_H-2,BLACK);
   15ae0:	223a      	movs	r2, #58	; 0x3a
	u8_t strbuf[10] = {0};
   15ae2:	e9cd 3303 	strd	r3, r3, [sp, #12]
   15ae6:	f8ad 3014 	strh.w	r3, [sp, #20]
	LCD_Fill(BAT_SUBJECT_X+1,BAT_SUBJECT_Y+1,BAT_SUBJECT_W-2,BAT_SUBJECT_H-2,BLACK);
   15aea:	9300      	str	r3, [sp, #0]
   15aec:	2110      	movs	r1, #16
   15aee:	2312      	movs	r3, #18
   15af0:	2060      	movs	r0, #96	; 0x60
   15af2:	f7fb f811 	bl	10b18 <LCD_Fill>
	
	switch(g_chg_status)
   15af6:	4b1e      	ldr	r3, [pc, #120]	; (15b70 <IdleUpdateBatSoc+0x94>)
   15af8:	781b      	ldrb	r3, [r3, #0]
   15afa:	2b01      	cmp	r3, #1
   15afc:	d031      	beq.n	15b62 <IdleUpdateBatSoc+0x86>
   15afe:	b259      	sxtb	r1, r3
   15b00:	b331      	cbz	r1, 15b50 <IdleUpdateBatSoc+0x74>
   15b02:	2b02      	cmp	r3, #2
   15b04:	d032      	beq.n	15b6c <IdleUpdateBatSoc+0x90>
	case BAT_CHARGING_FINISHED:
		strcpy(strbuf, "OK");
		break;
	}

	LCD_SetFontSize(FONT_SIZE_16);
   15b06:	2010      	movs	r0, #16
   15b08:	f7fb f9d0 	bl	10eac <LCD_SetFontSize>
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
	LCD_ShowUniString(BAT_SUBJECT_X+x, BAT_SUBJECT_Y+y, tmpbuf);
	
#else

	LCD_MeasureString(strbuf, &w, &h);
   15b0c:	f10d 020a 	add.w	r2, sp, #10
   15b10:	a902      	add	r1, sp, #8
   15b12:	a803      	add	r0, sp, #12
   15b14:	f7fb f9a6 	bl	10e64 <LCD_MeasureString>
	x = (w > BAT_SUBJECT_W ? BAT_SUBJECT_X : (BAT_SUBJECT_W-w)/2);
   15b18:	f8bd 0008 	ldrh.w	r0, [sp, #8]
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
   15b1c:	f8bd 100a 	ldrh.w	r1, [sp, #10]
	x = (w > BAT_SUBJECT_W ? BAT_SUBJECT_X : (BAT_SUBJECT_W-w)/2);
   15b20:	283c      	cmp	r0, #60	; 0x3c
   15b22:	bf9a      	itte	ls
   15b24:	f1c0 003c 	rsbls	r0, r0, #60	; 0x3c
   15b28:	f3c0 004f 	ubfxls	r0, r0, #1, #16
   15b2c:	205f      	movhi	r0, #95	; 0x5f
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
   15b2e:	2914      	cmp	r1, #20
   15b30:	bf8e      	itee	hi
   15b32:	210f      	movhi	r1, #15
   15b34:	f1c1 0114 	rsbls	r1, r1, #20
   15b38:	f3c1 014f 	ubfxls	r1, r1, #1, #16
	LCD_ShowString(BAT_SUBJECT_X+x, BAT_SUBJECT_Y+y, strbuf);
   15b3c:	310f      	adds	r1, #15
   15b3e:	305f      	adds	r0, #95	; 0x5f
   15b40:	aa03      	add	r2, sp, #12
   15b42:	b289      	uxth	r1, r1
   15b44:	b280      	uxth	r0, r0
   15b46:	f7fb f95b 	bl	10e00 <LCD_ShowString>
#endif
}
   15b4a:	b007      	add	sp, #28
   15b4c:	f85d fb04 	ldr.w	pc, [sp], #4
		sprintf(strbuf, "%02d", g_bat_soc);
   15b50:	4b08      	ldr	r3, [pc, #32]	; (15b74 <IdleUpdateBatSoc+0x98>)
   15b52:	220a      	movs	r2, #10
   15b54:	781b      	ldrb	r3, [r3, #0]
   15b56:	a803      	add	r0, sp, #12
   15b58:	9300      	str	r3, [sp, #0]
   15b5a:	4b07      	ldr	r3, [pc, #28]	; (15b78 <IdleUpdateBatSoc+0x9c>)
   15b5c:	f019 fd5c 	bl	2f618 <__sprintf_chk>
		break;
   15b60:	e7d1      	b.n	15b06 <IdleUpdateBatSoc+0x2a>
		strcpy(strbuf, "CHG");
   15b62:	4906      	ldr	r1, [pc, #24]	; (15b7c <IdleUpdateBatSoc+0xa0>)
		strcpy(strbuf, "OK");
   15b64:	a803      	add	r0, sp, #12
   15b66:	f019 fd96 	bl	2f696 <strcpy>
		break;
   15b6a:	e7cc      	b.n	15b06 <IdleUpdateBatSoc+0x2a>
		strcpy(strbuf, "OK");
   15b6c:	4904      	ldr	r1, [pc, #16]	; (15b80 <IdleUpdateBatSoc+0xa4>)
   15b6e:	e7f9      	b.n	15b64 <IdleUpdateBatSoc+0x88>
   15b70:	2002ff96 	.word	0x2002ff96
   15b74:	2002ff95 	.word	0x2002ff95
   15b78:	00030f77 	.word	0x00030f77
   15b7c:	0003215a 	.word	0x0003215a
   15b80:	0003215e 	.word	0x0003215e

00015b84 <IdleShowBatSoc>:
{
	u16_t x,y,w,h;
	u8_t strbuf[10] = {0};
	u8_t tmpbuf[128] = {0};
	
	LCD_DrawRectangle(BAT_POSITIVE_X,BAT_POSITIVE_Y,BAT_POSITIVE_W,BAT_POSITIVE_H);
   15b84:	230a      	movs	r3, #10
{
   15b86:	b510      	push	{r4, lr}
	u8_t strbuf[10] = {0};
   15b88:	2400      	movs	r4, #0
{
   15b8a:	b086      	sub	sp, #24
	LCD_DrawRectangle(BAT_POSITIVE_X,BAT_POSITIVE_Y,BAT_POSITIVE_W,BAT_POSITIVE_H);
   15b8c:	461a      	mov	r2, r3
   15b8e:	2114      	movs	r1, #20
   15b90:	2055      	movs	r0, #85	; 0x55
	u8_t strbuf[10] = {0};
   15b92:	e9cd 4403 	strd	r4, r4, [sp, #12]
   15b96:	f8ad 4014 	strh.w	r4, [sp, #20]
	LCD_DrawRectangle(BAT_POSITIVE_X,BAT_POSITIVE_Y,BAT_POSITIVE_W,BAT_POSITIVE_H);
   15b9a:	f7fa ffe1 	bl	10b60 <LCD_DrawRectangle>
	LCD_DrawRectangle(BAT_SUBJECT_X,BAT_SUBJECT_Y,BAT_SUBJECT_W,BAT_SUBJECT_H);
   15b9e:	2314      	movs	r3, #20
   15ba0:	223c      	movs	r2, #60	; 0x3c
   15ba2:	210f      	movs	r1, #15
   15ba4:	205f      	movs	r0, #95	; 0x5f
   15ba6:	f7fa ffdb 	bl	10b60 <LCD_DrawRectangle>
	LCD_Fill(BAT_SUBJECT_X+1,BAT_SUBJECT_Y+1,BAT_SUBJECT_W-2,BAT_SUBJECT_H-2,BLACK);
   15baa:	2312      	movs	r3, #18
   15bac:	9400      	str	r4, [sp, #0]
   15bae:	223a      	movs	r2, #58	; 0x3a
   15bb0:	2110      	movs	r1, #16
   15bb2:	2060      	movs	r0, #96	; 0x60
   15bb4:	f7fa ffb0 	bl	10b18 <LCD_Fill>
	
	switch(g_chg_status)
   15bb8:	4b1d      	ldr	r3, [pc, #116]	; (15c30 <IdleShowBatSoc+0xac>)
   15bba:	781b      	ldrb	r3, [r3, #0]
   15bbc:	2b01      	cmp	r3, #1
   15bbe:	d030      	beq.n	15c22 <IdleShowBatSoc+0x9e>
   15bc0:	b259      	sxtb	r1, r3
   15bc2:	b329      	cbz	r1, 15c10 <IdleShowBatSoc+0x8c>
   15bc4:	2b02      	cmp	r3, #2
   15bc6:	d031      	beq.n	15c2c <IdleShowBatSoc+0xa8>
	case BAT_CHARGING_FINISHED:
		strcpy(strbuf, "OK");
		break;
	}

	LCD_SetFontSize(FONT_SIZE_16);
   15bc8:	2010      	movs	r0, #16
   15bca:	f7fb f96f 	bl	10eac <LCD_SetFontSize>
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
	LCD_ShowUniString(BAT_SUBJECT_X+x, BAT_SUBJECT_Y+y, tmpbuf);
	
#else
	
	LCD_MeasureString(strbuf, &w, &h);
   15bce:	f10d 020a 	add.w	r2, sp, #10
   15bd2:	a902      	add	r1, sp, #8
   15bd4:	a803      	add	r0, sp, #12
   15bd6:	f7fb f945 	bl	10e64 <LCD_MeasureString>
	x = (w > BAT_SUBJECT_W ? BAT_SUBJECT_X : (BAT_SUBJECT_W-w)/2);
   15bda:	f8bd 0008 	ldrh.w	r0, [sp, #8]
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
   15bde:	f8bd 100a 	ldrh.w	r1, [sp, #10]
	x = (w > BAT_SUBJECT_W ? BAT_SUBJECT_X : (BAT_SUBJECT_W-w)/2);
   15be2:	283c      	cmp	r0, #60	; 0x3c
   15be4:	bf9a      	itte	ls
   15be6:	f1c0 003c 	rsbls	r0, r0, #60	; 0x3c
   15bea:	f3c0 004f 	ubfxls	r0, r0, #1, #16
   15bee:	205f      	movhi	r0, #95	; 0x5f
	y = (h > BAT_SUBJECT_H ? BAT_SUBJECT_Y : (BAT_SUBJECT_H-h)/2);
   15bf0:	2914      	cmp	r1, #20
   15bf2:	bf8e      	itee	hi
   15bf4:	210f      	movhi	r1, #15
   15bf6:	f1c1 0114 	rsbls	r1, r1, #20
   15bfa:	f3c1 014f 	ubfxls	r1, r1, #1, #16
	LCD_ShowString(BAT_SUBJECT_X+x, BAT_SUBJECT_Y+y, strbuf);
   15bfe:	310f      	adds	r1, #15
   15c00:	305f      	adds	r0, #95	; 0x5f
   15c02:	aa03      	add	r2, sp, #12
   15c04:	b289      	uxth	r1, r1
   15c06:	b280      	uxth	r0, r0
   15c08:	f7fb f8fa 	bl	10e00 <LCD_ShowString>
#endif
}
   15c0c:	b006      	add	sp, #24
   15c0e:	bd10      	pop	{r4, pc}
		sprintf(strbuf, "%02d", g_bat_soc);
   15c10:	4b08      	ldr	r3, [pc, #32]	; (15c34 <IdleShowBatSoc+0xb0>)
   15c12:	220a      	movs	r2, #10
   15c14:	781b      	ldrb	r3, [r3, #0]
   15c16:	a803      	add	r0, sp, #12
   15c18:	9300      	str	r3, [sp, #0]
   15c1a:	4b07      	ldr	r3, [pc, #28]	; (15c38 <IdleShowBatSoc+0xb4>)
   15c1c:	f019 fcfc 	bl	2f618 <__sprintf_chk>
		break;
   15c20:	e7d2      	b.n	15bc8 <IdleShowBatSoc+0x44>
		strcpy(strbuf, "CHG");
   15c22:	4906      	ldr	r1, [pc, #24]	; (15c3c <IdleShowBatSoc+0xb8>)
		strcpy(strbuf, "OK");
   15c24:	a803      	add	r0, sp, #12
   15c26:	f019 fd36 	bl	2f696 <strcpy>
		break;
   15c2a:	e7cd      	b.n	15bc8 <IdleShowBatSoc+0x44>
		strcpy(strbuf, "OK");
   15c2c:	4904      	ldr	r1, [pc, #16]	; (15c40 <IdleShowBatSoc+0xbc>)
   15c2e:	e7f9      	b.n	15c24 <IdleShowBatSoc+0xa0>
   15c30:	2002ff96 	.word	0x2002ff96
   15c34:	2002ff95 	.word	0x2002ff95
   15c38:	00030f77 	.word	0x00030f77
   15c3c:	0003215a 	.word	0x0003215a
   15c40:	0003215e 	.word	0x0003215e

00015c44 <IdleUpdateSportData>:

void IdleUpdateSportData(void)
{
   15c44:	b570      	push	{r4, r5, r6, lr}
	u16_t x,y,w,h;
	u8_t strbuf[128] = {0};
   15c46:	2580      	movs	r5, #128	; 0x80
	LCD_ShowUniString(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3+w, IMU_STEPS_SHOW_Y, tmpbuf);

#else

	LCD_MeasureString("S:", &w, &h);		
	LCD_Fill(IMU_STEPS_SHOW_X+w, IMU_STEPS_SHOW_Y, 50, IMU_STEPS_SHOW_H, BLACK);
   15c48:	2400      	movs	r4, #0
{
   15c4a:	b0a4      	sub	sp, #144	; 0x90
	u8_t strbuf[128] = {0};
   15c4c:	462a      	mov	r2, r5
   15c4e:	2100      	movs	r1, #0
   15c50:	a804      	add	r0, sp, #16
   15c52:	f019 fb9f 	bl	2f394 <memset>
	LCD_SetFontSize(FONT_SIZE_16);
   15c56:	2010      	movs	r0, #16
   15c58:	f7fb f928 	bl	10eac <LCD_SetFontSize>
	LCD_MeasureString("S:", &w, &h);		
   15c5c:	f10d 020e 	add.w	r2, sp, #14
   15c60:	a903      	add	r1, sp, #12
   15c62:	4831      	ldr	r0, [pc, #196]	; (15d28 <IdleUpdateSportData+0xe4>)
   15c64:	f7fb f8fe 	bl	10e64 <LCD_MeasureString>
	LCD_Fill(IMU_STEPS_SHOW_X+w, IMU_STEPS_SHOW_Y, 50, IMU_STEPS_SHOW_H, BLACK);
   15c68:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   15c6c:	9400      	str	r4, [sp, #0]
   15c6e:	300f      	adds	r0, #15
   15c70:	2314      	movs	r3, #20
   15c72:	2232      	movs	r2, #50	; 0x32
   15c74:	21a0      	movs	r1, #160	; 0xa0
   15c76:	b280      	uxth	r0, r0
   15c78:	f7fa ff4e 	bl	10b18 <LCD_Fill>
	sprintf(strbuf, "%d", g_steps);
   15c7c:	4b2b      	ldr	r3, [pc, #172]	; (15d2c <IdleUpdateSportData+0xe8>)
   15c7e:	4e2c      	ldr	r6, [pc, #176]	; (15d30 <IdleUpdateSportData+0xec>)
   15c80:	881b      	ldrh	r3, [r3, #0]
   15c82:	462a      	mov	r2, r5
   15c84:	9300      	str	r3, [sp, #0]
   15c86:	4621      	mov	r1, r4
   15c88:	4633      	mov	r3, r6
   15c8a:	a804      	add	r0, sp, #16
   15c8c:	f019 fcc4 	bl	2f618 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X+w, IMU_STEPS_SHOW_Y, strbuf);
   15c90:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   15c94:	aa04      	add	r2, sp, #16
   15c96:	300f      	adds	r0, #15
   15c98:	21a0      	movs	r1, #160	; 0xa0
   15c9a:	b280      	uxth	r0, r0
   15c9c:	f7fb f8b0 	bl	10e00 <LCD_ShowString>

	LCD_MeasureString("D:", &w, &h);
   15ca0:	f10d 020e 	add.w	r2, sp, #14
   15ca4:	a903      	add	r1, sp, #12
   15ca6:	4823      	ldr	r0, [pc, #140]	; (15d34 <IdleUpdateSportData+0xf0>)
   15ca8:	f7fb f8dc 	bl	10e64 <LCD_MeasureString>
	LCD_Fill(IMU_STEPS_SHOW_X+IMU_STEPS_SHOW_W/3+w, IMU_STEPS_SHOW_Y, 50, IMU_STEPS_SHOW_H, BLACK);
   15cac:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   15cb0:	9400      	str	r4, [sp, #0]
   15cb2:	3055      	adds	r0, #85	; 0x55
   15cb4:	2314      	movs	r3, #20
   15cb6:	2232      	movs	r2, #50	; 0x32
   15cb8:	21a0      	movs	r1, #160	; 0xa0
   15cba:	b280      	uxth	r0, r0
   15cbc:	f7fa ff2c 	bl	10b18 <LCD_Fill>
	sprintf(strbuf, "%d", g_distance);
   15cc0:	4b1d      	ldr	r3, [pc, #116]	; (15d38 <IdleUpdateSportData+0xf4>)
   15cc2:	462a      	mov	r2, r5
   15cc4:	881b      	ldrh	r3, [r3, #0]
   15cc6:	4621      	mov	r1, r4
   15cc8:	9300      	str	r3, [sp, #0]
   15cca:	a804      	add	r0, sp, #16
   15ccc:	4633      	mov	r3, r6
   15cce:	f019 fca3 	bl	2f618 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X+IMU_STEPS_SHOW_W/3+w, IMU_STEPS_SHOW_Y, strbuf);
   15cd2:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   15cd6:	aa04      	add	r2, sp, #16
   15cd8:	3055      	adds	r0, #85	; 0x55
   15cda:	21a0      	movs	r1, #160	; 0xa0
   15cdc:	b280      	uxth	r0, r0
   15cde:	f7fb f88f 	bl	10e00 <LCD_ShowString>

	LCD_MeasureString("C:", &w, &h);
   15ce2:	f10d 020e 	add.w	r2, sp, #14
   15ce6:	a903      	add	r1, sp, #12
   15ce8:	4814      	ldr	r0, [pc, #80]	; (15d3c <IdleUpdateSportData+0xf8>)
   15cea:	f7fb f8bb 	bl	10e64 <LCD_MeasureString>
	LCD_Fill(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3+w, IMU_STEPS_SHOW_Y, 50, IMU_STEPS_SHOW_H, BLACK);
   15cee:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   15cf2:	9400      	str	r4, [sp, #0]
   15cf4:	309b      	adds	r0, #155	; 0x9b
   15cf6:	2314      	movs	r3, #20
   15cf8:	2232      	movs	r2, #50	; 0x32
   15cfa:	21a0      	movs	r1, #160	; 0xa0
   15cfc:	b280      	uxth	r0, r0
   15cfe:	f7fa ff0b 	bl	10b18 <LCD_Fill>
	sprintf(strbuf, "%d", g_calorie);
   15d02:	4b0f      	ldr	r3, [pc, #60]	; (15d40 <IdleUpdateSportData+0xfc>)
   15d04:	462a      	mov	r2, r5
   15d06:	881b      	ldrh	r3, [r3, #0]
   15d08:	4621      	mov	r1, r4
   15d0a:	9300      	str	r3, [sp, #0]
   15d0c:	a804      	add	r0, sp, #16
   15d0e:	4633      	mov	r3, r6
   15d10:	f019 fc82 	bl	2f618 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3+w, IMU_STEPS_SHOW_Y, strbuf);
   15d14:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   15d18:	aa04      	add	r2, sp, #16
   15d1a:	309b      	adds	r0, #155	; 0x9b
   15d1c:	21a0      	movs	r1, #160	; 0xa0
   15d1e:	b280      	uxth	r0, r0
   15d20:	f7fb f86e 	bl	10e00 <LCD_ShowString>
#endif
}
   15d24:	b024      	add	sp, #144	; 0x90
   15d26:	bd70      	pop	{r4, r5, r6, pc}
   15d28:	00032161 	.word	0x00032161
   15d2c:	2002d47c 	.word	0x2002d47c
   15d30:	00033e5f 	.word	0x00033e5f
   15d34:	00032164 	.word	0x00032164
   15d38:	2002d47a 	.word	0x2002d47a
   15d3c:	00032167 	.word	0x00032167
   15d40:	2002d478 	.word	0x2002d478

00015d44 <IdleShowSportData>:

void IdleShowSportData(void)
{
   15d44:	b530      	push	{r4, r5, lr}
	u16_t x,y,w,h;
	u8_t strbuf[128] = {0};
   15d46:	2580      	movs	r5, #128	; 0x80
	sprintf(strbuf, "C:%d", g_calorie);
	mmi_asc_to_ucs2(tmpbuf,strbuf);
	LCD_ShowUniString(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3, IMU_STEPS_SHOW_Y, tmpbuf);

#else
	LCD_Fill(IMU_STEPS_SHOW_X,IMU_STEPS_SHOW_Y,IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_H,BLACK);
   15d48:	2400      	movs	r4, #0
{
   15d4a:	b0a3      	sub	sp, #140	; 0x8c
	u8_t strbuf[128] = {0};
   15d4c:	462a      	mov	r2, r5
   15d4e:	2100      	movs	r1, #0
   15d50:	a802      	add	r0, sp, #8
   15d52:	f019 fb1f 	bl	2f394 <memset>
	LCD_SetFontSize(FONT_SIZE_16);
   15d56:	2010      	movs	r0, #16
   15d58:	f7fb f8a8 	bl	10eac <LCD_SetFontSize>
	LCD_Fill(IMU_STEPS_SHOW_X,IMU_STEPS_SHOW_Y,IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_H,BLACK);
   15d5c:	9400      	str	r4, [sp, #0]
   15d5e:	2314      	movs	r3, #20
   15d60:	2246      	movs	r2, #70	; 0x46
   15d62:	21a0      	movs	r1, #160	; 0xa0
   15d64:	200f      	movs	r0, #15
   15d66:	f7fa fed7 	bl	10b18 <LCD_Fill>
	sprintf(strbuf, "S:%d", g_steps);
   15d6a:	4b1d      	ldr	r3, [pc, #116]	; (15de0 <IdleShowSportData+0x9c>)
   15d6c:	462a      	mov	r2, r5
   15d6e:	881b      	ldrh	r3, [r3, #0]
   15d70:	4621      	mov	r1, r4
   15d72:	9300      	str	r3, [sp, #0]
   15d74:	a802      	add	r0, sp, #8
   15d76:	4b1b      	ldr	r3, [pc, #108]	; (15de4 <IdleShowSportData+0xa0>)
   15d78:	f019 fc4e 	bl	2f618 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X, IMU_STEPS_SHOW_Y, strbuf);
   15d7c:	aa02      	add	r2, sp, #8
   15d7e:	21a0      	movs	r1, #160	; 0xa0
   15d80:	200f      	movs	r0, #15
   15d82:	f7fb f83d 	bl	10e00 <LCD_ShowString>

	LCD_Fill(IMU_STEPS_SHOW_X+IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_Y,IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_H,BLACK);
   15d86:	9400      	str	r4, [sp, #0]
   15d88:	2314      	movs	r3, #20
   15d8a:	2246      	movs	r2, #70	; 0x46
   15d8c:	21a0      	movs	r1, #160	; 0xa0
   15d8e:	2055      	movs	r0, #85	; 0x55
   15d90:	f7fa fec2 	bl	10b18 <LCD_Fill>
	sprintf(strbuf, "D:%d", g_distance);
   15d94:	4b14      	ldr	r3, [pc, #80]	; (15de8 <IdleShowSportData+0xa4>)
   15d96:	462a      	mov	r2, r5
   15d98:	881b      	ldrh	r3, [r3, #0]
   15d9a:	4621      	mov	r1, r4
   15d9c:	9300      	str	r3, [sp, #0]
   15d9e:	a802      	add	r0, sp, #8
   15da0:	4b12      	ldr	r3, [pc, #72]	; (15dec <IdleShowSportData+0xa8>)
   15da2:	f019 fc39 	bl	2f618 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X+IMU_STEPS_SHOW_W/3, IMU_STEPS_SHOW_Y, strbuf);
   15da6:	aa02      	add	r2, sp, #8
   15da8:	21a0      	movs	r1, #160	; 0xa0
   15daa:	2055      	movs	r0, #85	; 0x55
   15dac:	f7fb f828 	bl	10e00 <LCD_ShowString>

	LCD_Fill(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_Y,IMU_STEPS_SHOW_W/3,IMU_STEPS_SHOW_H,BLACK);
   15db0:	9400      	str	r4, [sp, #0]
   15db2:	2314      	movs	r3, #20
   15db4:	2246      	movs	r2, #70	; 0x46
   15db6:	21a0      	movs	r1, #160	; 0xa0
   15db8:	209b      	movs	r0, #155	; 0x9b
   15dba:	f7fa fead 	bl	10b18 <LCD_Fill>
	sprintf(strbuf, "C:%d", g_calorie);
   15dbe:	4b0c      	ldr	r3, [pc, #48]	; (15df0 <IdleShowSportData+0xac>)
   15dc0:	462a      	mov	r2, r5
   15dc2:	881b      	ldrh	r3, [r3, #0]
   15dc4:	4621      	mov	r1, r4
   15dc6:	9300      	str	r3, [sp, #0]
   15dc8:	a802      	add	r0, sp, #8
   15dca:	4b0a      	ldr	r3, [pc, #40]	; (15df4 <IdleShowSportData+0xb0>)
   15dcc:	f019 fc24 	bl	2f618 <__sprintf_chk>
	LCD_ShowString(IMU_STEPS_SHOW_X+2*IMU_STEPS_SHOW_W/3, IMU_STEPS_SHOW_Y, strbuf);
   15dd0:	aa02      	add	r2, sp, #8
   15dd2:	21a0      	movs	r1, #160	; 0xa0
   15dd4:	209b      	movs	r0, #155	; 0x9b
   15dd6:	f7fb f813 	bl	10e00 <LCD_ShowString>
#endif
}
   15dda:	b023      	add	sp, #140	; 0x8c
   15ddc:	bd30      	pop	{r4, r5, pc}
   15dde:	bf00      	nop
   15de0:	2002d47c 	.word	0x2002d47c
   15de4:	0003211a 	.word	0x0003211a
   15de8:	2002d47a 	.word	0x2002d47a
   15dec:	0003211f 	.word	0x0003211f
   15df0:	2002d478 	.word	0x2002d478
   15df4:	00032124 	.word	0x00032124

00015df8 <IdleScreenProcess>:

void IdleScreenProcess(void)
{
	switch(scr_msg[SCREEN_ID_IDLE].act)
   15df8:	4b24      	ldr	r3, [pc, #144]	; (15e8c <IdleScreenProcess+0x94>)
{
   15dfa:	b510      	push	{r4, lr}
	switch(scr_msg[SCREEN_ID_IDLE].act)
   15dfc:	7a5a      	ldrb	r2, [r3, #9]
   15dfe:	461c      	mov	r4, r3
   15e00:	2a01      	cmp	r2, #1
   15e02:	d002      	beq.n	15e0a <IdleScreenProcess+0x12>
   15e04:	2a02      	cmp	r2, #2
   15e06:	d00d      	beq.n	15e24 <IdleScreenProcess+0x2c>
		}

		if(scr_msg[SCREEN_ID_IDLE].para == SCREEN_EVENT_UPDATE_NO)
			scr_msg[SCREEN_ID_IDLE].act = SCREEN_ACTION_NO;
	}
}
   15e08:	bd10      	pop	{r4, pc}
		scr_msg[SCREEN_ID_IDLE].status = SCREEN_STATUS_CREATED;
   15e0a:	2202      	movs	r2, #2
		LCD_Clear(BLACK);
   15e0c:	2000      	movs	r0, #0
		scr_msg[SCREEN_ID_IDLE].status = SCREEN_STATUS_CREATED;
   15e0e:	811a      	strh	r2, [r3, #8]
		LCD_Clear(BLACK);
   15e10:	f015 fc1d 	bl	2b64e <LCD_Clear>
		IdleShowBatSoc();
   15e14:	f7ff feb6 	bl	15b84 <IdleShowBatSoc>
		IdleShowDateTime();
   15e18:	f016 fe68 	bl	2caec <IdleShowDateTime>
}
   15e1c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		IdleShowSportData();
   15e20:	f7ff bf90 	b.w	15d44 <IdleShowSportData>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_BAT)
   15e24:	68db      	ldr	r3, [r3, #12]
   15e26:	0798      	lsls	r0, r3, #30
   15e28:	d504      	bpl.n	15e34 <IdleScreenProcess+0x3c>
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_BAT);
   15e2a:	f023 0302 	bic.w	r3, r3, #2
   15e2e:	60e3      	str	r3, [r4, #12]
			IdleUpdateBatSoc();
   15e30:	f7ff fe54 	bl	15adc <IdleUpdateBatSoc>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_TIME)
   15e34:	68e3      	ldr	r3, [r4, #12]
   15e36:	0759      	lsls	r1, r3, #29
   15e38:	d504      	bpl.n	15e44 <IdleScreenProcess+0x4c>
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_TIME);
   15e3a:	f023 0304 	bic.w	r3, r3, #4
   15e3e:	60e3      	str	r3, [r4, #12]
			IdleShowSystemTime();
   15e40:	f7ff fdb0 	bl	159a4 <IdleShowSystemTime>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_DATE)
   15e44:	68e3      	ldr	r3, [r4, #12]
   15e46:	071a      	lsls	r2, r3, #28
   15e48:	d504      	bpl.n	15e54 <IdleScreenProcess+0x5c>
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_DATE);
   15e4a:	f023 0308 	bic.w	r3, r3, #8
   15e4e:	60e3      	str	r3, [r4, #12]
			IdleShowSystemDate();
   15e50:	f7ff fd64 	bl	1591c <IdleShowSystemDate>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_WEEK)
   15e54:	68e3      	ldr	r3, [r4, #12]
   15e56:	06d8      	lsls	r0, r3, #27
   15e58:	d504      	bpl.n	15e64 <IdleScreenProcess+0x6c>
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_WEEK);
   15e5a:	f023 0310 	bic.w	r3, r3, #16
   15e5e:	60e3      	str	r3, [r4, #12]
			IdleShowSystemWeek();
   15e60:	f7ff fde4 	bl	15a2c <IdleShowSystemWeek>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_SPORT)
   15e64:	68e3      	ldr	r3, [r4, #12]
   15e66:	0699      	lsls	r1, r3, #26
   15e68:	d504      	bpl.n	15e74 <IdleScreenProcess+0x7c>
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_SPORT);
   15e6a:	f023 0320 	bic.w	r3, r3, #32
   15e6e:	60e3      	str	r3, [r4, #12]
			IdleUpdateSportData();
   15e70:	f7ff fee8 	bl	15c44 <IdleUpdateSportData>
		if(scr_msg[SCREEN_ID_IDLE].para&SCREEN_EVENT_UPDATE_SLEEP)
   15e74:	68e3      	ldr	r3, [r4, #12]
   15e76:	065a      	lsls	r2, r3, #25
			scr_msg[SCREEN_ID_IDLE].para &= (~SCREEN_EVENT_UPDATE_SLEEP);
   15e78:	bf44      	itt	mi
   15e7a:	f023 0340 	bicmi.w	r3, r3, #64	; 0x40
   15e7e:	60e3      	strmi	r3, [r4, #12]
		if(scr_msg[SCREEN_ID_IDLE].para == SCREEN_EVENT_UPDATE_NO)
   15e80:	68e3      	ldr	r3, [r4, #12]
   15e82:	2b00      	cmp	r3, #0
   15e84:	d1c0      	bne.n	15e08 <IdleScreenProcess+0x10>
			scr_msg[SCREEN_ID_IDLE].act = SCREEN_ACTION_NO;
   15e86:	7263      	strb	r3, [r4, #9]
}
   15e88:	e7be      	b.n	15e08 <IdleScreenProcess+0x10>
   15e8a:	bf00      	nop
   15e8c:	20028540 	.word	0x20028540

00015e90 <AlarmScreenProcess>:

void AlarmScreenProcess(void)
{
   15e90:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   15e94:	b0a5      	sub	sp, #148	; 0x94
	u16_t rect_x,rect_y,rect_w=180,rect_h=80;
	u16_t x,y,w,h;
	u8_t notify[128] = "Alarm Notify!";
   15e96:	aa04      	add	r2, sp, #16
   15e98:	4617      	mov	r7, r2
   15e9a:	4b30      	ldr	r3, [pc, #192]	; (15f5c <AlarmScreenProcess+0xcc>)
   15e9c:	f103 0508 	add.w	r5, r3, #8
   15ea0:	4614      	mov	r4, r2
   15ea2:	6818      	ldr	r0, [r3, #0]
   15ea4:	6859      	ldr	r1, [r3, #4]
   15ea6:	3308      	adds	r3, #8
   15ea8:	c403      	stmia	r4!, {r0, r1}
   15eaa:	42ab      	cmp	r3, r5
   15eac:	4622      	mov	r2, r4
   15eae:	d1f7      	bne.n	15ea0 <AlarmScreenProcess+0x10>
   15eb0:	6818      	ldr	r0, [r3, #0]
   15eb2:	889b      	ldrh	r3, [r3, #4]

	switch(scr_msg[SCREEN_ID_ALARM].act)
   15eb4:	4e2a      	ldr	r6, [pc, #168]	; (15f60 <AlarmScreenProcess+0xd0>)
	u8_t notify[128] = "Alarm Notify!";
   15eb6:	6020      	str	r0, [r4, #0]
   15eb8:	80a3      	strh	r3, [r4, #4]
   15eba:	2272      	movs	r2, #114	; 0x72
   15ebc:	2100      	movs	r1, #0
   15ebe:	f10d 001e 	add.w	r0, sp, #30
   15ec2:	f019 fa67 	bl	2f394 <memset>
	switch(scr_msg[SCREEN_ID_ALARM].act)
   15ec6:	7c73      	ldrb	r3, [r6, #17]
   15ec8:	2b01      	cmp	r3, #1
   15eca:	d142      	bne.n	15f52 <AlarmScreenProcess+0xc2>
	{
	case SCREEN_ACTION_ENTER:
		scr_msg[SCREEN_ID_ALARM].act = SCREEN_ACTION_NO;
		scr_msg[SCREEN_ID_ALARM].status = SCREEN_STATUS_CREATED;
   15ecc:	2302      	movs	r3, #2
   15ece:	8233      	strh	r3, [r6, #16]
				
		rect_x = (LCD_WIDTH-rect_w)/2;
   15ed0:	4b24      	ldr	r3, [pc, #144]	; (15f64 <AlarmScreenProcess+0xd4>)
		rect_y = (LCD_HEIGHT-rect_h)/2;
		
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   15ed2:	22b4      	movs	r2, #180	; 0xb4
		rect_x = (LCD_WIDTH-rect_w)/2;
   15ed4:	881c      	ldrh	r4, [r3, #0]
		rect_y = (LCD_HEIGHT-rect_h)/2;
   15ed6:	4b24      	ldr	r3, [pc, #144]	; (15f68 <AlarmScreenProcess+0xd8>)
		rect_x = (LCD_WIDTH-rect_w)/2;
   15ed8:	3cb4      	subs	r4, #180	; 0xb4
		rect_y = (LCD_HEIGHT-rect_h)/2;
   15eda:	881d      	ldrh	r5, [r3, #0]
		rect_x = (LCD_WIDTH-rect_w)/2;
   15edc:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
		rect_y = (LCD_HEIGHT-rect_h)/2;
   15ee0:	3d50      	subs	r5, #80	; 0x50
   15ee2:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   15ee6:	106d      	asrs	r5, r5, #1
		rect_x = (LCD_WIDTH-rect_w)/2;
   15ee8:	1064      	asrs	r4, r4, #1
		rect_y = (LCD_HEIGHT-rect_h)/2;
   15eea:	fa1f f985 	uxth.w	r9, r5
		rect_x = (LCD_WIDTH-rect_w)/2;
   15eee:	fa1f f884 	uxth.w	r8, r4
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   15ef2:	2350      	movs	r3, #80	; 0x50
   15ef4:	4649      	mov	r1, r9
   15ef6:	4640      	mov	r0, r8
   15ef8:	f7fa fe32 	bl	10b60 <LCD_DrawRectangle>
		LCD_Fill(rect_x+1, rect_y+1, rect_w-2, rect_h-2, BLACK);
   15efc:	1c69      	adds	r1, r5, #1
   15efe:	2500      	movs	r5, #0
   15f00:	1c60      	adds	r0, r4, #1
   15f02:	9500      	str	r5, [sp, #0]
   15f04:	234e      	movs	r3, #78	; 0x4e
   15f06:	22b2      	movs	r2, #178	; 0xb2
   15f08:	b289      	uxth	r1, r1
   15f0a:	b280      	uxth	r0, r0
   15f0c:	f7fa fe04 	bl	10b18 <LCD_Fill>

	#ifdef FONT_24
		LCD_SetFontSize(FONT_SIZE_24);
   15f10:	2018      	movs	r0, #24
   15f12:	f7fa ffcb 	bl	10eac <LCD_SetFontSize>
	#else
		LCD_SetFontSize(FONT_SIZE_16);
	#endif
		LCD_MeasureString(notify,&w,&h);
   15f16:	f10d 020e 	add.w	r2, sp, #14
   15f1a:	a903      	add	r1, sp, #12
   15f1c:	4638      	mov	r0, r7
   15f1e:	f7fa ffa1 	bl	10e64 <LCD_MeasureString>
		x = (w > rect_w)? 0 : (rect_w-w)/2;
   15f22:	f8bd 000c 	ldrh.w	r0, [sp, #12]
		y = (h > rect_h)? 0 : (rect_h-h)/2;
   15f26:	f8bd 100e 	ldrh.w	r1, [sp, #14]
		x = (w > rect_w)? 0 : (rect_w-w)/2;
   15f2a:	28b4      	cmp	r0, #180	; 0xb4
   15f2c:	bf9c      	itt	ls
   15f2e:	f1c0 05b4 	rsbls	r5, r0, #180	; 0xb4
   15f32:	f3c5 054f 	ubfxls	r5, r5, #1, #16
		y = (h > rect_h)? 0 : (rect_h-h)/2;
   15f36:	2950      	cmp	r1, #80	; 0x50
   15f38:	bf8e      	itee	hi
   15f3a:	2100      	movhi	r1, #0
   15f3c:	f1c1 0150 	rsbls	r1, r1, #80	; 0x50
   15f40:	f3c1 014f 	ubfxls	r1, r1, #1, #16
		x += rect_x;
		y += rect_y;
   15f44:	4449      	add	r1, r9
		x += rect_x;
   15f46:	4445      	add	r5, r8
		LCD_ShowString(x,y,notify);
   15f48:	463a      	mov	r2, r7
   15f4a:	b289      	uxth	r1, r1
   15f4c:	b2a8      	uxth	r0, r5
   15f4e:	f7fa ff57 	bl	10e00 <LCD_ShowString>
		
	case SCREEN_ACTION_UPDATE:
		break;
	}
	
	scr_msg[SCREEN_ID_ALARM].act = SCREEN_ACTION_NO;
   15f52:	2300      	movs	r3, #0
   15f54:	7473      	strb	r3, [r6, #17]
}
   15f56:	b025      	add	sp, #148	; 0x94
   15f58:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   15f5c:	000305c8 	.word	0x000305c8
   15f60:	20028540 	.word	0x20028540
   15f64:	200385a6 	.word	0x200385a6
   15f68:	200385a4 	.word	0x200385a4

00015f6c <FindDeviceScreenProcess>:

void FindDeviceScreenProcess(void)
{
   15f6c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   15f70:	b0a5      	sub	sp, #148	; 0x94
	u16_t rect_x,rect_y,rect_w=180,rect_h=80;
	u16_t x,y,w,h;
	u8_t notify[128] = "Find Device!";
   15f72:	aa04      	add	r2, sp, #16
   15f74:	4617      	mov	r7, r2
   15f76:	4b30      	ldr	r3, [pc, #192]	; (16038 <FindDeviceScreenProcess+0xcc>)
   15f78:	f103 0508 	add.w	r5, r3, #8
   15f7c:	4614      	mov	r4, r2
   15f7e:	6818      	ldr	r0, [r3, #0]
   15f80:	6859      	ldr	r1, [r3, #4]
   15f82:	3308      	adds	r3, #8
   15f84:	c403      	stmia	r4!, {r0, r1}
   15f86:	42ab      	cmp	r3, r5
   15f88:	4622      	mov	r2, r4
   15f8a:	d1f7      	bne.n	15f7c <FindDeviceScreenProcess+0x10>
   15f8c:	6818      	ldr	r0, [r3, #0]
   15f8e:	791b      	ldrb	r3, [r3, #4]

	switch(scr_msg[SCREEN_ID_FIND_DEVICE].act)
   15f90:	4e2a      	ldr	r6, [pc, #168]	; (1603c <FindDeviceScreenProcess+0xd0>)
	u8_t notify[128] = "Find Device!";
   15f92:	6020      	str	r0, [r4, #0]
   15f94:	7123      	strb	r3, [r4, #4]
   15f96:	2273      	movs	r2, #115	; 0x73
   15f98:	2100      	movs	r1, #0
   15f9a:	f10d 001d 	add.w	r0, sp, #29
   15f9e:	f019 f9f9 	bl	2f394 <memset>
	switch(scr_msg[SCREEN_ID_FIND_DEVICE].act)
   15fa2:	7e73      	ldrb	r3, [r6, #25]
   15fa4:	2b01      	cmp	r3, #1
   15fa6:	d142      	bne.n	1602e <FindDeviceScreenProcess+0xc2>
	{
	case SCREEN_ACTION_ENTER:
		scr_msg[SCREEN_ID_FIND_DEVICE].act = SCREEN_ACTION_NO;
		scr_msg[SCREEN_ID_FIND_DEVICE].status = SCREEN_STATUS_CREATED;
   15fa8:	2302      	movs	r3, #2
   15faa:	8333      	strh	r3, [r6, #24]
				
		rect_x = (LCD_WIDTH-rect_w)/2;
   15fac:	4b24      	ldr	r3, [pc, #144]	; (16040 <FindDeviceScreenProcess+0xd4>)
		rect_y = (LCD_HEIGHT-rect_h)/2;
		
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   15fae:	22b4      	movs	r2, #180	; 0xb4
		rect_x = (LCD_WIDTH-rect_w)/2;
   15fb0:	881c      	ldrh	r4, [r3, #0]
		rect_y = (LCD_HEIGHT-rect_h)/2;
   15fb2:	4b24      	ldr	r3, [pc, #144]	; (16044 <FindDeviceScreenProcess+0xd8>)
		rect_x = (LCD_WIDTH-rect_w)/2;
   15fb4:	3cb4      	subs	r4, #180	; 0xb4
		rect_y = (LCD_HEIGHT-rect_h)/2;
   15fb6:	881d      	ldrh	r5, [r3, #0]
		rect_x = (LCD_WIDTH-rect_w)/2;
   15fb8:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
		rect_y = (LCD_HEIGHT-rect_h)/2;
   15fbc:	3d50      	subs	r5, #80	; 0x50
   15fbe:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   15fc2:	106d      	asrs	r5, r5, #1
		rect_x = (LCD_WIDTH-rect_w)/2;
   15fc4:	1064      	asrs	r4, r4, #1
		rect_y = (LCD_HEIGHT-rect_h)/2;
   15fc6:	fa1f f985 	uxth.w	r9, r5
		rect_x = (LCD_WIDTH-rect_w)/2;
   15fca:	fa1f f884 	uxth.w	r8, r4
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   15fce:	2350      	movs	r3, #80	; 0x50
   15fd0:	4649      	mov	r1, r9
   15fd2:	4640      	mov	r0, r8
   15fd4:	f7fa fdc4 	bl	10b60 <LCD_DrawRectangle>
		LCD_Fill(rect_x+1, rect_y+1, rect_w-2, rect_h-2, BLACK);
   15fd8:	1c69      	adds	r1, r5, #1
   15fda:	2500      	movs	r5, #0
   15fdc:	1c60      	adds	r0, r4, #1
   15fde:	9500      	str	r5, [sp, #0]
   15fe0:	234e      	movs	r3, #78	; 0x4e
   15fe2:	22b2      	movs	r2, #178	; 0xb2
   15fe4:	b289      	uxth	r1, r1
   15fe6:	b280      	uxth	r0, r0
   15fe8:	f7fa fd96 	bl	10b18 <LCD_Fill>
		
	#ifdef FONT_24
		LCD_SetFontSize(FONT_SIZE_24);
   15fec:	2018      	movs	r0, #24
   15fee:	f7fa ff5d 	bl	10eac <LCD_SetFontSize>
	#else
		LCD_SetFontSize(FONT_SIZE_16);
	#endif
		LCD_MeasureString(notify,&w,&h);
   15ff2:	f10d 020e 	add.w	r2, sp, #14
   15ff6:	a903      	add	r1, sp, #12
   15ff8:	4638      	mov	r0, r7
   15ffa:	f7fa ff33 	bl	10e64 <LCD_MeasureString>
		x = (w > rect_w)? 0 : (rect_w-w)/2;
   15ffe:	f8bd 000c 	ldrh.w	r0, [sp, #12]
		y = (h > rect_h)? 0 : (rect_h-h)/2;
   16002:	f8bd 100e 	ldrh.w	r1, [sp, #14]
		x = (w > rect_w)? 0 : (rect_w-w)/2;
   16006:	28b4      	cmp	r0, #180	; 0xb4
   16008:	bf9c      	itt	ls
   1600a:	f1c0 05b4 	rsbls	r5, r0, #180	; 0xb4
   1600e:	f3c5 054f 	ubfxls	r5, r5, #1, #16
		y = (h > rect_h)? 0 : (rect_h-h)/2;
   16012:	2950      	cmp	r1, #80	; 0x50
   16014:	bf8e      	itee	hi
   16016:	2100      	movhi	r1, #0
   16018:	f1c1 0150 	rsbls	r1, r1, #80	; 0x50
   1601c:	f3c1 014f 	ubfxls	r1, r1, #1, #16
		x += rect_x;
		y += rect_y;
   16020:	4449      	add	r1, r9
		x += rect_x;
   16022:	4445      	add	r5, r8
		LCD_ShowString(x,y,notify);
   16024:	463a      	mov	r2, r7
   16026:	b289      	uxth	r1, r1
   16028:	b2a8      	uxth	r0, r5
   1602a:	f7fa fee9 	bl	10e00 <LCD_ShowString>
		
	case SCREEN_ACTION_UPDATE:
		break;
	}
	
	scr_msg[SCREEN_ID_FIND_DEVICE].act = SCREEN_ACTION_NO;
   1602e:	2300      	movs	r3, #0
   16030:	7673      	strb	r3, [r6, #25]
}
   16032:	b025      	add	sp, #148	; 0x94
   16034:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   16038:	00030648 	.word	0x00030648
   1603c:	20028540 	.word	0x20028540
   16040:	200385a6 	.word	0x200385a6
   16044:	200385a4 	.word	0x200385a4

00016048 <NotifyScreenProcess>:

void NotifyScreenProcess(void)
{
   16048:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u16_t rect_x,rect_y,rect_w=180,rect_h=120;
	u16_t x,y,w,h;
	u16_t offset_w=4,offset_h=4;

	switch(scr_msg[SCREEN_ID_NOTIFY].act)
   1604c:	4b83      	ldr	r3, [pc, #524]	; (1625c <NotifyScreenProcess+0x214>)
{
   1604e:	b0a9      	sub	sp, #164	; 0xa4
	switch(scr_msg[SCREEN_ID_NOTIFY].act)
   16050:	f893 2079 	ldrb.w	r2, [r3, #121]	; 0x79
   16054:	9303      	str	r3, [sp, #12]
   16056:	2a01      	cmp	r2, #1
   16058:	d135      	bne.n	160c6 <NotifyScreenProcess+0x7e>
	{
	case SCREEN_ACTION_ENTER:
		scr_msg[SCREEN_ID_NOTIFY].act = SCREEN_ACTION_NO;
		scr_msg[SCREEN_ID_NOTIFY].status = SCREEN_STATUS_CREATED;
   1605a:	2302      	movs	r3, #2
   1605c:	4a7f      	ldr	r2, [pc, #508]	; (1625c <NotifyScreenProcess+0x214>)
		
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
		LCD_Fill(rect_x+1, rect_y+1, rect_w-2, rect_h-2, BLACK);
		
		LCD_SetFontSize(FONT_SIZE_16);
		LCD_MeasureString(notify_msg.text, &w, &h);
   1605e:	f8df 920c 	ldr.w	r9, [pc, #524]	; 1626c <NotifyScreenProcess+0x224>
		scr_msg[SCREEN_ID_NOTIFY].status = SCREEN_STATUS_CREATED;
   16062:	f8a2 3078 	strh.w	r3, [r2, #120]	; 0x78
		rect_x = (LCD_WIDTH-rect_w)/2;
   16066:	4b7e      	ldr	r3, [pc, #504]	; (16260 <NotifyScreenProcess+0x218>)
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   16068:	22b4      	movs	r2, #180	; 0xb4
		rect_x = (LCD_WIDTH-rect_w)/2;
   1606a:	881e      	ldrh	r6, [r3, #0]
		rect_y = (LCD_HEIGHT-rect_h)/2;
   1606c:	4b7d      	ldr	r3, [pc, #500]	; (16264 <NotifyScreenProcess+0x21c>)
		rect_x = (LCD_WIDTH-rect_w)/2;
   1606e:	3eb4      	subs	r6, #180	; 0xb4
		rect_y = (LCD_HEIGHT-rect_h)/2;
   16070:	881d      	ldrh	r5, [r3, #0]
		rect_x = (LCD_WIDTH-rect_w)/2;
   16072:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
		rect_y = (LCD_HEIGHT-rect_h)/2;
   16076:	3d78      	subs	r5, #120	; 0x78
   16078:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
		rect_x = (LCD_WIDTH-rect_w)/2;
   1607c:	1076      	asrs	r6, r6, #1
		rect_y = (LCD_HEIGHT-rect_h)/2;
   1607e:	106d      	asrs	r5, r5, #1
		rect_x = (LCD_WIDTH-rect_w)/2;
   16080:	b2b4      	uxth	r4, r6
		rect_y = (LCD_HEIGHT-rect_h)/2;
   16082:	fa1f f885 	uxth.w	r8, r5
		LCD_DrawRectangle(rect_x, rect_y, rect_w, rect_h);
   16086:	2378      	movs	r3, #120	; 0x78
   16088:	4641      	mov	r1, r8
   1608a:	4620      	mov	r0, r4
   1608c:	f7fa fd68 	bl	10b60 <LCD_DrawRectangle>
		LCD_Fill(rect_x+1, rect_y+1, rect_w-2, rect_h-2, BLACK);
   16090:	2300      	movs	r3, #0
   16092:	1c69      	adds	r1, r5, #1
   16094:	1c70      	adds	r0, r6, #1
   16096:	22b2      	movs	r2, #178	; 0xb2
   16098:	b289      	uxth	r1, r1
   1609a:	9300      	str	r3, [sp, #0]
   1609c:	b280      	uxth	r0, r0
   1609e:	2376      	movs	r3, #118	; 0x76
   160a0:	f7fa fd3a 	bl	10b18 <LCD_Fill>
		LCD_MeasureString(notify_msg.text, &w, &h);
   160a4:	f109 0502 	add.w	r5, r9, #2
		LCD_SetFontSize(FONT_SIZE_16);
   160a8:	2010      	movs	r0, #16
   160aa:	f7fa feff 	bl	10eac <LCD_SetFontSize>
		LCD_MeasureString(notify_msg.text, &w, &h);
   160ae:	f10d 021e 	add.w	r2, sp, #30
   160b2:	a907      	add	r1, sp, #28
   160b4:	4628      	mov	r0, r5
   160b6:	f7fa fed5 	bl	10e64 <LCD_MeasureString>
		switch(notify_msg.align)
   160ba:	f899 6001 	ldrb.w	r6, [r9, #1]
   160be:	b14e      	cbz	r6, 160d4 <NotifyScreenProcess+0x8c>
   160c0:	2e01      	cmp	r6, #1
   160c2:	f000 80be 	beq.w	16242 <NotifyScreenProcess+0x1fa>
		
	case SCREEN_ACTION_UPDATE:
		break;
	}
	
	scr_msg[SCREEN_ID_NOTIFY].act = SCREEN_ACTION_NO;
   160c6:	2300      	movs	r3, #0
   160c8:	9a03      	ldr	r2, [sp, #12]
   160ca:	f882 3079 	strb.w	r3, [r2, #121]	; 0x79

}
   160ce:	b029      	add	sp, #164	; 0xa4
   160d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if(w > (rect_w-2*offset_w))
   160d4:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   160d8:	f108 0804 	add.w	r8, r8, #4
   160dc:	2bac      	cmp	r3, #172	; 0xac
   160de:	f8bd 701e 	ldrh.w	r7, [sp, #30]
   160e2:	fa0f f888 	sxth.w	r8, r8
   160e6:	f240 8098 	bls.w	1621a <NotifyScreenProcess+0x1d2>
				line_count = w/(rect_w-2*offset_w) + ((w%(rect_w-offset_w) != 0)? 1 : 0);
   160ea:	22b0      	movs	r2, #176	; 0xb0
   160ec:	fbb3 f1f2 	udiv	r1, r3, r2
   160f0:	fb02 3111 	mls	r1, r2, r1, r3
   160f4:	22ac      	movs	r2, #172	; 0xac
   160f6:	fbb3 f3f2 	udiv	r3, r3, r2
   160fa:	2270      	movs	r2, #112	; 0x70
				u16_t line_h=(h+offset_h);
   160fc:	3704      	adds	r7, #4
				line_count = w/(rect_w-2*offset_w) + ((w%(rect_w-offset_w) != 0)? 1 : 0);
   160fe:	2900      	cmp	r1, #0
   16100:	bf18      	it	ne
   16102:	3301      	addne	r3, #1
				u16_t line_h=(h+offset_h);
   16104:	b2bf      	uxth	r7, r7
				line_count = w/(rect_w-2*offset_w) + ((w%(rect_w-offset_w) != 0)? 1 : 0);
   16106:	fbb2 f2f7 	udiv	r2, r2, r7
   1610a:	b2db      	uxtb	r3, r3
				if(line_count > line_max)
   1610c:	429a      	cmp	r2, r3
   1610e:	bf28      	it	cs
   16110:	461a      	movcs	r2, r3
				text_len = strlen(notify_msg.text);
   16112:	4628      	mov	r0, r5
   16114:	9202      	str	r2, [sp, #8]
   16116:	f7f6 ff1f 	bl	cf58 <strlen>
				y = ((rect_h-2*offset_h)-line_count*line_h)/2;
   1611a:	9b02      	ldr	r3, [sp, #8]
				text_len = strlen(notify_msg.text);
   1611c:	fa1f fb80 	uxth.w	fp, r0
				y = ((rect_h-2*offset_h)-line_count*line_h)/2;
   16120:	fb07 f503 	mul.w	r5, r7, r3
   16124:	f1c5 0570 	rsb	r5, r5, #112	; 0x70
   16128:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   1612c:	1d23      	adds	r3, r4, #4
				y += (rect_y+offset_h);
   1612e:	eb08 0565 	add.w	r5, r8, r5, asr #1
   16132:	b21b      	sxth	r3, r3
   16134:	b2ad      	uxth	r5, r5
					tmpbuf[i++] = notify_msg.text[byte_no++];
   16136:	f8cd 9010 	str.w	r9, [sp, #16]
   1613a:	9305      	str	r3, [sp, #20]
				while(line_no<line_count)
   1613c:	9b02      	ldr	r3, [sp, #8]
   1613e:	2b00      	cmp	r3, #0
   16140:	d0c1      	beq.n	160c6 <NotifyScreenProcess+0x7e>
					u8_t tmpbuf[128] = {0};
   16142:	f10d 0a20 	add.w	sl, sp, #32
   16146:	2280      	movs	r2, #128	; 0x80
   16148:	2100      	movs	r1, #0
   1614a:	4650      	mov	r0, sl
   1614c:	f019 f922 	bl	2f394 <memset>
					tmpbuf[i++] = notify_msg.text[byte_no++];
   16150:	9b04      	ldr	r3, [sp, #16]
					LCD_MeasureString(tmpbuf, &w, &h);
   16152:	f10d 021e 	add.w	r2, sp, #30
					tmpbuf[i++] = notify_msg.text[byte_no++];
   16156:	4433      	add	r3, r6
   16158:	789b      	ldrb	r3, [r3, #2]
					LCD_MeasureString(tmpbuf, &w, &h);
   1615a:	a907      	add	r1, sp, #28
   1615c:	4650      	mov	r0, sl
					tmpbuf[i++] = notify_msg.text[byte_no++];
   1615e:	f106 0901 	add.w	r9, r6, #1
   16162:	f88d 3020 	strb.w	r3, [sp, #32]
					LCD_MeasureString(tmpbuf, &w, &h);
   16166:	fa1f f989 	uxth.w	r9, r9
   1616a:	f7fa fe7b 	bl	10e64 <LCD_MeasureString>
					while(w < (rect_w-2*offset_w))
   1616e:	9b04      	ldr	r3, [sp, #16]
   16170:	f109 0902 	add.w	r9, r9, #2
   16174:	4499      	add	r9, r3
   16176:	f04f 0801 	mov.w	r8, #1
							tmpbuf[i++] = notify_msg.text[byte_no++];
   1617a:	4653      	mov	r3, sl
					while(w < (rect_w-2*offset_w))
   1617c:	f8bd 101c 	ldrh.w	r1, [sp, #28]
   16180:	eb06 0208 	add.w	r2, r6, r8
   16184:	29ab      	cmp	r1, #171	; 0xab
   16186:	b292      	uxth	r2, r2
   16188:	d922      	bls.n	161d0 <NotifyScreenProcess+0x188>
					if(byte_no < text_len)
   1618a:	4593      	cmp	fp, r2
   1618c:	d930      	bls.n	161f0 <NotifyScreenProcess+0x1a8>
						tmpbuf[i] = 0x00;
   1618e:	ab28      	add	r3, sp, #160	; 0xa0
						i -= 2;
   16190:	f1a8 0802 	sub.w	r8, r8, #2
						tmpbuf[i] = 0x00;
   16194:	fa53 f888 	uxtab	r8, r3, r8
   16198:	2300      	movs	r3, #0
						byte_no -= 2;
   1619a:	1e96      	subs	r6, r2, #2
						LCD_MeasureString(tmpbuf, &w, &h);
   1619c:	a907      	add	r1, sp, #28
   1619e:	f10d 021e 	add.w	r2, sp, #30
   161a2:	a808      	add	r0, sp, #32
						tmpbuf[i] = 0x00;
   161a4:	f808 3c80 	strb.w	r3, [r8, #-128]
						LCD_MeasureString(tmpbuf, &w, &h);
   161a8:	f7fa fe5c 	bl	10e64 <LCD_MeasureString>
						x = ((rect_w-2*offset_w)-w)/2;
   161ac:	f8bd 001c 	ldrh.w	r0, [sp, #28]
						x += (rect_x+offset_w);
   161b0:	9b05      	ldr	r3, [sp, #20]
						x = ((rect_w-2*offset_w)-w)/2;
   161b2:	f1c0 00ac 	rsb	r0, r0, #172	; 0xac
   161b6:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
						x += (rect_x+offset_w);
   161ba:	eb03 0060 	add.w	r0, r3, r0, asr #1
						LCD_ShowString(x,y,tmpbuf);
   161be:	4629      	mov	r1, r5
   161c0:	aa08      	add	r2, sp, #32
   161c2:	b280      	uxth	r0, r0
						y += line_h;
   161c4:	443d      	add	r5, r7
						byte_no -= 2;
   161c6:	b2b6      	uxth	r6, r6
						LCD_ShowString(x,y,tmpbuf);
   161c8:	f7fa fe1a 	bl	10e00 <LCD_ShowString>
						y += line_h;
   161cc:	b2ad      	uxth	r5, r5
   161ce:	e7b5      	b.n	1613c <NotifyScreenProcess+0xf4>
						if(byte_no < text_len)
   161d0:	4593      	cmp	fp, r2
   161d2:	d90d      	bls.n	161f0 <NotifyScreenProcess+0x1a8>
							tmpbuf[i++] = notify_msg.text[byte_no++];
   161d4:	f819 2b01 	ldrb.w	r2, [r9], #1
							LCD_MeasureString(tmpbuf, &w, &h);
   161d8:	4618      	mov	r0, r3
							tmpbuf[i++] = notify_msg.text[byte_no++];
   161da:	f808 2003 	strb.w	r2, [r8, r3]
							LCD_MeasureString(tmpbuf, &w, &h);
   161de:	a907      	add	r1, sp, #28
   161e0:	f10d 021e 	add.w	r2, sp, #30
   161e4:	f7fa fe3e 	bl	10e64 <LCD_MeasureString>
   161e8:	f108 0801 	add.w	r8, r8, #1
   161ec:	ab08      	add	r3, sp, #32
   161ee:	e7c5      	b.n	1617c <NotifyScreenProcess+0x134>
						LCD_MeasureString(tmpbuf, &w, &h);
   161f0:	f10d 021e 	add.w	r2, sp, #30
   161f4:	a907      	add	r1, sp, #28
   161f6:	4650      	mov	r0, sl
   161f8:	f7fa fe34 	bl	10e64 <LCD_MeasureString>
						LCD_ShowString(x,y,tmpbuf);
   161fc:	4652      	mov	r2, sl
   161fe:	4629      	mov	r1, r5
						x = ((rect_w-2*offset_w)-w)/2;
   16200:	f8bd 001c 	ldrh.w	r0, [sp, #28]
						x += (rect_x+offset_w);
   16204:	3404      	adds	r4, #4
						x = ((rect_w-2*offset_w)-w)/2;
   16206:	f1c0 00ac 	rsb	r0, r0, #172	; 0xac
   1620a:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
						x += (rect_x+offset_w);
   1620e:	eb04 0060 	add.w	r0, r4, r0, asr #1
						LCD_ShowString(x,y,tmpbuf);
   16212:	b280      	uxth	r0, r0
				LCD_ShowString(x,y,notify_msg.text);				
   16214:	f7fa fdf4 	bl	10e00 <LCD_ShowString>
   16218:	e755      	b.n	160c6 <NotifyScreenProcess+0x7e>
				y = (h > (rect_h-2*offset_h))? 0 : ((rect_h-2*offset_h)-h)/2;
   1621a:	2f70      	cmp	r7, #112	; 0x70
				x = (w > (rect_w-2*offset_w))? 0 : ((rect_w-2*offset_w)-w)/2;
   1621c:	f1c3 03ac 	rsb	r3, r3, #172	; 0xac
				y = (h > (rect_h-2*offset_h))? 0 : ((rect_h-2*offset_h)-h)/2;
   16220:	bf98      	it	ls
   16222:	f1c7 0670 	rsbls	r6, r7, #112	; 0x70
				x = (w > (rect_w-2*offset_w))? 0 : ((rect_w-2*offset_w)-w)/2;
   16226:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
   1622a:	ea4f 0363 	mov.w	r3, r3, asr #1
				y = (h > (rect_h-2*offset_h))? 0 : ((rect_h-2*offset_h)-h)/2;
   1622e:	bf98      	it	ls
   16230:	f3c6 064f 	ubfxls	r6, r6, #1, #16
				x += (rect_x+offset_w);
   16234:	3404      	adds	r4, #4
				y += (rect_y+offset_h);
   16236:	4446      	add	r6, r8
				x += (rect_x+offset_w);
   16238:	4423      	add	r3, r4
				LCD_ShowString(x,y,notify_msg.text);				
   1623a:	4a0b      	ldr	r2, [pc, #44]	; (16268 <NotifyScreenProcess+0x220>)
   1623c:	b2b1      	uxth	r1, r6
   1623e:	b298      	uxth	r0, r3
   16240:	e7e8      	b.n	16214 <NotifyScreenProcess+0x1cc>
			y = (rect_y+offset_h);
   16242:	f108 0804 	add.w	r8, r8, #4
			x = (rect_x+offset_w);
   16246:	1d20      	adds	r0, r4, #4
			LCD_ShowStringInRect(x, y, (rect_w-2*offset_w), (rect_h-2*offset_h), notify_msg.text);
   16248:	9500      	str	r5, [sp, #0]
   1624a:	2370      	movs	r3, #112	; 0x70
   1624c:	22ac      	movs	r2, #172	; 0xac
   1624e:	fa1f f188 	uxth.w	r1, r8
   16252:	b280      	uxth	r0, r0
   16254:	f7fa fd98 	bl	10d88 <LCD_ShowStringInRect>
			break;
   16258:	e735      	b.n	160c6 <NotifyScreenProcess+0x7e>
   1625a:	bf00      	nop
   1625c:	20028540 	.word	0x20028540
   16260:	200385a6 	.word	0x200385a6
   16264:	200385a4 	.word	0x200385a4
   16268:	2002ff42 	.word	0x2002ff42
   1626c:	2002ff40 	.word	0x2002ff40

00016270 <EnterIdleScreen>:

void EnterIdleScreen(void)
{
	if(screen_id == SCREEN_ID_IDLE)
   16270:	4907      	ldr	r1, [pc, #28]	; (16290 <EnterIdleScreen+0x20>)
   16272:	780b      	ldrb	r3, [r1, #0]
   16274:	2b01      	cmp	r3, #1
   16276:	d00a      	beq.n	1628e <EnterIdleScreen+0x1e>
		return;
	
	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   16278:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   1627a:	4a06      	ldr	r2, [pc, #24]	; (16294 <EnterIdleScreen+0x24>)
   1627c:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   1627e:	4a06      	ldr	r2, [pc, #24]	; (16298 <EnterIdleScreen+0x28>)
   16280:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_IDLE;
   16284:	2301      	movs	r3, #1
   16286:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_IDLE].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_IDLE].status = SCREEN_STATUS_CREATING;
   16288:	f240 1301 	movw	r3, #257	; 0x101
   1628c:	8113      	strh	r3, [r2, #8]
}
   1628e:	4770      	bx	lr
   16290:	2002ff93 	.word	0x2002ff93
   16294:	2002ff3f 	.word	0x2002ff3f
   16298:	20028540 	.word	0x20028540

0001629c <EnterAlarmScreen>:

void EnterAlarmScreen(void)
{
	if(screen_id == SCREEN_ID_ALARM)
   1629c:	4907      	ldr	r1, [pc, #28]	; (162bc <EnterAlarmScreen+0x20>)
   1629e:	780b      	ldrb	r3, [r1, #0]
   162a0:	2b02      	cmp	r3, #2
   162a2:	d00a      	beq.n	162ba <EnterAlarmScreen+0x1e>
		return;

	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   162a4:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   162a6:	4a06      	ldr	r2, [pc, #24]	; (162c0 <EnterAlarmScreen+0x24>)
   162a8:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   162aa:	4a06      	ldr	r2, [pc, #24]	; (162c4 <EnterAlarmScreen+0x28>)
   162ac:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_ALARM;	
   162b0:	2302      	movs	r3, #2
   162b2:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_ALARM].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_ALARM].status = SCREEN_STATUS_CREATING;	
   162b4:	f240 1301 	movw	r3, #257	; 0x101
   162b8:	8213      	strh	r3, [r2, #16]
}
   162ba:	4770      	bx	lr
   162bc:	2002ff93 	.word	0x2002ff93
   162c0:	2002ff3f 	.word	0x2002ff3f
   162c4:	20028540 	.word	0x20028540

000162c8 <EnterFindDeviceScreen>:

void EnterFindDeviceScreen(void)
{
	if(screen_id == SCREEN_ID_FIND_DEVICE)
   162c8:	4907      	ldr	r1, [pc, #28]	; (162e8 <EnterFindDeviceScreen+0x20>)
   162ca:	780b      	ldrb	r3, [r1, #0]
   162cc:	2b03      	cmp	r3, #3
   162ce:	d00a      	beq.n	162e6 <EnterFindDeviceScreen+0x1e>
		return;

	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   162d0:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   162d2:	4a06      	ldr	r2, [pc, #24]	; (162ec <EnterFindDeviceScreen+0x24>)
   162d4:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   162d6:	4a06      	ldr	r2, [pc, #24]	; (162f0 <EnterFindDeviceScreen+0x28>)
   162d8:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_FIND_DEVICE;	
   162dc:	2303      	movs	r3, #3
   162de:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_FIND_DEVICE].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_FIND_DEVICE].status = SCREEN_STATUS_CREATING;
   162e0:	f240 1301 	movw	r3, #257	; 0x101
   162e4:	8313      	strh	r3, [r2, #24]
}
   162e6:	4770      	bx	lr
   162e8:	2002ff93 	.word	0x2002ff93
   162ec:	2002ff3f 	.word	0x2002ff3f
   162f0:	20028540 	.word	0x20028540

000162f4 <EnterGPSTestScreen>:

void EnterGPSTestScreen(void)
{
	if(screen_id == SCREEN_ID_GPS_TEST)
   162f4:	4908      	ldr	r1, [pc, #32]	; (16318 <EnterGPSTestScreen+0x24>)
   162f6:	780b      	ldrb	r3, [r1, #0]
   162f8:	2b0d      	cmp	r3, #13
   162fa:	d00b      	beq.n	16314 <EnterGPSTestScreen+0x20>
		return;

	history_screen_id = screen_id;
	scr_msg[history_screen_id].act = SCREEN_ACTION_NO;
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   162fc:	2000      	movs	r0, #0
	history_screen_id = screen_id;
   162fe:	4a07      	ldr	r2, [pc, #28]	; (1631c <EnterGPSTestScreen+0x28>)
   16300:	7013      	strb	r3, [r2, #0]
	scr_msg[history_screen_id].status = SCREEN_STATUS_NO;
   16302:	4a07      	ldr	r2, [pc, #28]	; (16320 <EnterGPSTestScreen+0x2c>)
   16304:	f822 0033 	strh.w	r0, [r2, r3, lsl #3]

	screen_id = SCREEN_ID_GPS_TEST;	
   16308:	230d      	movs	r3, #13
   1630a:	700b      	strb	r3, [r1, #0]
	scr_msg[SCREEN_ID_GPS_TEST].act = SCREEN_ACTION_ENTER;
	scr_msg[SCREEN_ID_GPS_TEST].status = SCREEN_STATUS_CREATING;	
   1630c:	f240 1301 	movw	r3, #257	; 0x101
   16310:	f8a2 3068 	strh.w	r3, [r2, #104]	; 0x68
}
   16314:	4770      	bx	lr
   16316:	bf00      	nop
   16318:	2002ff93 	.word	0x2002ff93
   1631c:	2002ff3f 	.word	0x2002ff3f
   16320:	20028540 	.word	0x20028540

00016324 <GoBackHistoryScreen>:
{
	SCREEN_ID_ENUM scr_id;
	
	scr_id = screen_id;
	scr_msg[scr_id].act = SCREEN_ACTION_NO;
	scr_msg[scr_id].status = SCREEN_STATUS_NO;
   16324:	2000      	movs	r0, #0
	scr_id = screen_id;
   16326:	4906      	ldr	r1, [pc, #24]	; (16340 <GoBackHistoryScreen+0x1c>)
	scr_msg[scr_id].status = SCREEN_STATUS_NO;
   16328:	4b06      	ldr	r3, [pc, #24]	; (16344 <GoBackHistoryScreen+0x20>)
	scr_msg[scr_id].act = SCREEN_ACTION_NO;
   1632a:	780a      	ldrb	r2, [r1, #0]
	scr_msg[scr_id].status = SCREEN_STATUS_NO;
   1632c:	f823 0032 	strh.w	r0, [r3, r2, lsl #3]

	screen_id = history_screen_id;
   16330:	4a05      	ldr	r2, [pc, #20]	; (16348 <GoBackHistoryScreen+0x24>)
   16332:	7812      	ldrb	r2, [r2, #0]
   16334:	700a      	strb	r2, [r1, #0]
	scr_msg[history_screen_id].act = SCREEN_ACTION_ENTER;
	scr_msg[history_screen_id].status = SCREEN_STATUS_CREATING;	
   16336:	f240 1101 	movw	r1, #257	; 0x101
   1633a:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
}
   1633e:	4770      	bx	lr
   16340:	2002ff93 	.word	0x2002ff93
   16344:	20028540 	.word	0x20028540
   16348:	2002ff3f 	.word	0x2002ff3f

0001634c <ExitNotifyScreen>:
{
   1634c:	b508      	push	{r3, lr}
	if(screen_id == SCREEN_ID_NOTIFY)
   1634e:	4b06      	ldr	r3, [pc, #24]	; (16368 <ExitNotifyScreen+0x1c>)
   16350:	781b      	ldrb	r3, [r3, #0]
   16352:	2b0f      	cmp	r3, #15
   16354:	d106      	bne.n	16364 <ExitNotifyScreen+0x18>
	z_impl_k_timer_stop(timer);
   16356:	4805      	ldr	r0, [pc, #20]	; (1636c <ExitNotifyScreen+0x20>)
   16358:	f018 ff59 	bl	2f20e <z_impl_k_timer_stop>
}
   1635c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		GoBackHistoryScreen();
   16360:	f7ff bfe0 	b.w	16324 <GoBackHistoryScreen>
}
   16364:	bd08      	pop	{r3, pc}
   16366:	bf00      	nop
   16368:	2002ff93 	.word	0x2002ff93
   1636c:	2003b794 	.word	0x2003b794

00016370 <ScreenMsgProcess>:

void ScreenMsgProcess(void)
{
	if(scr_msg[screen_id].act != SCREEN_ACTION_NO)
   16370:	4b10      	ldr	r3, [pc, #64]	; (163b4 <ScreenMsgProcess+0x44>)
   16372:	4911      	ldr	r1, [pc, #68]	; (163b8 <ScreenMsgProcess+0x48>)
   16374:	781b      	ldrb	r3, [r3, #0]
   16376:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
   1637a:	7850      	ldrb	r0, [r2, #1]
   1637c:	b1c0      	cbz	r0, 163b0 <ScreenMsgProcess+0x40>
	{
		if(scr_msg[screen_id].status != SCREEN_STATUS_CREATED)
   1637e:	f811 1033 	ldrb.w	r1, [r1, r3, lsl #3]
   16382:	2902      	cmp	r1, #2
			scr_msg[screen_id].act = SCREEN_ACTION_ENTER;
   16384:	bf1c      	itt	ne
   16386:	2101      	movne	r1, #1
   16388:	7051      	strbne	r1, [r2, #1]

		switch(screen_id)
   1638a:	2b02      	cmp	r3, #2
   1638c:	d00a      	beq.n	163a4 <ScreenMsgProcess+0x34>
   1638e:	d802      	bhi.n	16396 <ScreenMsgProcess+0x26>
   16390:	2b01      	cmp	r3, #1
   16392:	d005      	beq.n	163a0 <ScreenMsgProcess+0x30>
   16394:	4770      	bx	lr
   16396:	2b03      	cmp	r3, #3
   16398:	d006      	beq.n	163a8 <ScreenMsgProcess+0x38>
   1639a:	2b0f      	cmp	r3, #15
   1639c:	d006      	beq.n	163ac <ScreenMsgProcess+0x3c>
   1639e:	4770      	bx	lr
		{
		case SCREEN_ID_IDLE:
			IdleScreenProcess();
   163a0:	f7ff bd2a 	b.w	15df8 <IdleScreenProcess>
			break;
		case SCREEN_ID_ALARM:
			AlarmScreenProcess();
   163a4:	f7ff bd74 	b.w	15e90 <AlarmScreenProcess>
			break;
		case SCREEN_ID_FIND_DEVICE:
			FindDeviceScreenProcess();
   163a8:	f7ff bde0 	b.w	15f6c <FindDeviceScreenProcess>
		case SCREEN_ID_GPS_TEST:
			break;
		case SCREEN_ID_NB_TEST:
			break;
		case SCREEN_ID_NOTIFY:
			NotifyScreenProcess();
   163ac:	f7ff be4c 	b.w	16048 <NotifyScreenProcess>
			break;
		}
	}
}
   163b0:	4770      	bx	lr
   163b2:	bf00      	nop
   163b4:	2002ff93 	.word	0x2002ff93
   163b8:	20028540 	.word	0x20028540

000163bc <pmu_battery_low_shutdown_timerout>:
	MAX20353_PowerOffConfig();
}

void pmu_battery_low_shutdown_timerout(void)
{
	sys_pwr_off = true;
   163bc:	2201      	movs	r2, #1
   163be:	4b01      	ldr	r3, [pc, #4]	; (163c4 <pmu_battery_low_shutdown_timerout+0x8>)
   163c0:	701a      	strb	r2, [r3, #0]
}
   163c2:	4770      	bx	lr
   163c4:	2002ff9b 	.word	0x2002ff9b

000163c8 <PmuInterruptHandle>:
	}while(!val);
}

void PmuInterruptHandle(void)
{
	pmu_trige_flag = true;
   163c8:	2201      	movs	r2, #1
   163ca:	4b01      	ldr	r3, [pc, #4]	; (163d0 <PmuInterruptHandle+0x8>)
   163cc:	701a      	strb	r2, [r3, #0]
}
   163ce:	4770      	bx	lr
   163d0:	2002ff99 	.word	0x2002ff99

000163d4 <PmuAlertHandle>:
	MAX20353_SOCWriteReg(0x0C, 0x12, 0x5C);
}

void PmuAlertHandle(void)
{
	pmu_alert_flag = true;
   163d4:	2201      	movs	r2, #1
   163d6:	4b01      	ldr	r3, [pc, #4]	; (163dc <PmuAlertHandle+0x8>)
   163d8:	701a      	strb	r2, [r3, #0]
}
   163da:	4770      	bx	lr
   163dc:	2002ff97 	.word	0x2002ff97

000163e0 <pmu_battery_stop_shutdown>:
{
   163e0:	b508      	push	{r3, lr}
	const s32_t ticks = z_timeout_remaining(&timer->timeout);
   163e2:	4809      	ldr	r0, [pc, #36]	; (16408 <pmu_battery_stop_shutdown+0x28>)
   163e4:	f012 fd0e 	bl	28e04 <z_timeout_remaining>
	return (ticks > 0) ? (u32_t)k_ticks_to_ms_floor64(ticks) : 0U;
   163e8:	2800      	cmp	r0, #0
   163ea:	dd0c      	ble.n	16406 <pmu_battery_stop_shutdown+0x26>
   163ec:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   163f0:	fb80 0103 	smull	r0, r1, r0, r3
   163f4:	0bc3      	lsrs	r3, r0, #15
	if(k_timer_remaining_get(&soc_pwroff) > 0)
   163f6:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
   163fa:	d004      	beq.n	16406 <pmu_battery_stop_shutdown+0x26>
}
   163fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   16400:	4801      	ldr	r0, [pc, #4]	; (16408 <pmu_battery_stop_shutdown+0x28>)
   16402:	f018 bf04 	b.w	2f20e <z_impl_k_timer_stop>
   16406:	bd08      	pop	{r3, pc}
   16408:	200285ec 	.word	0x200285ec

0001640c <pmu_battery_low_shutdown>:
{
   1640c:	b510      	push	{r4, lr}
	k_timer_init(&soc_pwroff, pmu_battery_low_shutdown_timerout, NULL);
   1640e:	4c07      	ldr	r4, [pc, #28]	; (1642c <pmu_battery_low_shutdown+0x20>)
   16410:	2200      	movs	r2, #0
   16412:	4907      	ldr	r1, [pc, #28]	; (16430 <pmu_battery_low_shutdown+0x24>)
   16414:	4620      	mov	r0, r4
   16416:	f018 feee 	bl	2f1f6 <k_timer_init>
	z_impl_k_timer_start(timer, duration, period);
   1641a:	2200      	movs	r2, #0
   1641c:	4620      	mov	r0, r4
}
   1641e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   16422:	f242 7110 	movw	r1, #10000	; 0x2710
   16426:	f012 bf0d 	b.w	29244 <z_impl_k_timer_start>
   1642a:	bf00      	nop
   1642c:	200285ec 	.word	0x200285ec
   16430:	000163bd 	.word	0x000163bd

00016434 <pmu_interrupt_proc>:
{
   16434:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		LOG_INF("pmu_interrupt_proc REG_INT0:%02X\n", int0);
   16438:	4b59      	ldr	r3, [pc, #356]	; (165a0 <pmu_interrupt_proc+0x16c>)
   1643a:	4c5a      	ldr	r4, [pc, #360]	; (165a4 <pmu_interrupt_proc+0x170>)
   1643c:	f8df 8184 	ldr.w	r8, [pc, #388]	; 165c4 <pmu_interrupt_proc+0x190>
   16440:	1ae4      	subs	r4, r4, r3
			LOG_INF("REG_STATUS0:%02X\n", status0);
   16442:	f8df 9184 	ldr.w	r9, [pc, #388]	; 165c8 <pmu_interrupt_proc+0x194>
			pmu_redraw_bat_flag = true;
   16446:	4f58      	ldr	r7, [pc, #352]	; (165a8 <pmu_interrupt_proc+0x174>)
		LOG_INF("pmu_interrupt_proc REG_INT0:%02X\n", int0);
   16448:	f3c4 04c9 	ubfx	r4, r4, #3, #10
		MAX20353_ReadReg(REG_INT0, &int0);
   1644c:	a901      	add	r1, sp, #4
   1644e:	2003      	movs	r0, #3
   16450:	f000 fc2c 	bl	16cac <MAX20353_ReadReg>
		LOG_INF("pmu_interrupt_proc REG_INT0:%02X\n", int0);
   16454:	f025 033f 	bic.w	r3, r5, #63	; 0x3f
   16458:	f043 0303 	orr.w	r3, r3, #3
   1645c:	f363 0507 	bfi	r5, r3, #0, #8
   16460:	f364 158f 	bfi	r5, r4, #6, #10
   16464:	4628      	mov	r0, r5
   16466:	f89d 2004 	ldrb.w	r2, [sp, #4]
   1646a:	4641      	mov	r1, r8
   1646c:	f016 ff44 	bl	2d2f8 <log_string_sync>
		if((int0&0x40) == 0x40) //Charger status change INT  
   16470:	f89d 3004 	ldrb.w	r3, [sp, #4]
   16474:	0658      	lsls	r0, r3, #25
   16476:	d523      	bpl.n	164c0 <pmu_interrupt_proc+0x8c>
			MAX20353_ReadReg(REG_STATUS0, &status0);
   16478:	f10d 0105 	add.w	r1, sp, #5
   1647c:	2006      	movs	r0, #6
   1647e:	f000 fc15 	bl	16cac <MAX20353_ReadReg>
			LOG_INF("REG_STATUS0:%02X\n", status0);
   16482:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   16486:	f043 0303 	orr.w	r3, r3, #3
   1648a:	f363 0607 	bfi	r6, r3, #0, #8
   1648e:	f364 168f 	bfi	r6, r4, #6, #10
   16492:	f89d 2005 	ldrb.w	r2, [sp, #5]
   16496:	4649      	mov	r1, r9
   16498:	4630      	mov	r0, r6
   1649a:	f016 ff2d 	bl	2d2f8 <log_string_sync>
			switch((status0&0x07))
   1649e:	2201      	movs	r2, #1
   164a0:	f89d 3005 	ldrb.w	r3, [sp, #5]
   164a4:	f003 0307 	and.w	r3, r3, #7
   164a8:	fa02 f303 	lsl.w	r3, r2, r3
   164ac:	f013 0f83 	tst.w	r3, #131	; 0x83
   164b0:	d143      	bne.n	1653a <pmu_interrupt_proc+0x106>
   164b2:	0659      	lsls	r1, r3, #25
   164b4:	d447      	bmi.n	16546 <pmu_interrupt_proc+0x112>
   164b6:	f013 0f3c 	tst.w	r3, #60	; 0x3c
   164ba:	d142      	bne.n	16542 <pmu_interrupt_proc+0x10e>
			pmu_redraw_bat_flag = true;
   164bc:	2301      	movs	r3, #1
   164be:	703b      	strb	r3, [r7, #0]
		if((int0&0x08) == 0x08) //USB OK Int
   164c0:	f89d 3004 	ldrb.w	r3, [sp, #4]
   164c4:	071b      	lsls	r3, r3, #28
   164c6:	d51f      	bpl.n	16508 <pmu_interrupt_proc+0xd4>
			MAX20353_ReadReg(REG_STATUS1, &status1);
   164c8:	f10d 0106 	add.w	r1, sp, #6
   164cc:	2007      	movs	r0, #7
   164ce:	f000 fbed 	bl	16cac <MAX20353_ReadReg>
			if((status1&0x08) == 0x08) //USB OK   
   164d2:	f89d 3006 	ldrb.w	r3, [sp, #6]
   164d6:	4a35      	ldr	r2, [pc, #212]	; (165ac <pmu_interrupt_proc+0x178>)
   164d8:	f013 0308 	ands.w	r3, r3, #8
   164dc:	f8df b0dc 	ldr.w	fp, [pc, #220]	; 165bc <pmu_interrupt_proc+0x188>
   164e0:	4933      	ldr	r1, [pc, #204]	; (165b0 <pmu_interrupt_proc+0x17c>)
   164e2:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 165cc <pmu_interrupt_proc+0x198>
   164e6:	d033      	beq.n	16550 <pmu_interrupt_proc+0x11c>
				pmu_battery_stop_shutdown();
   164e8:	f7ff ff7a 	bl	163e0 <pmu_battery_stop_shutdown>
				InitCharger();
   164ec:	f000 fd58 	bl	16fa0 <InitCharger>
				charger_is_connected = true;
   164f0:	2301      	movs	r3, #1
				g_chg_status = BAT_CHARGING_PROGRESS;
   164f2:	4a2e      	ldr	r2, [pc, #184]	; (165ac <pmu_interrupt_proc+0x178>)
				charger_is_connected = true;
   164f4:	492e      	ldr	r1, [pc, #184]	; (165b0 <pmu_interrupt_proc+0x17c>)
				g_chg_status = BAT_CHARGING_PROGRESS;
   164f6:	7013      	strb	r3, [r2, #0]
				g_bat_level = BAT_LEVEL_NORMAL;
   164f8:	2202      	movs	r2, #2
				charger_is_connected = true;
   164fa:	700b      	strb	r3, [r1, #0]
				g_bat_level = BAT_LEVEL_NORMAL;
   164fc:	f88a 2000 	strb.w	r2, [sl]
				lcd_sleep_out = true;
   16500:	f88b 3000 	strb.w	r3, [fp]
			pmu_redraw_bat_flag = true;
   16504:	2301      	movs	r3, #1
   16506:	703b      	strb	r3, [r7, #0]
		if(gpio_pin_read(gpio_pmu, PMU_EINT, &val))	//xb add 20201202 MCUPMU
   16508:	4b2a      	ldr	r3, [pc, #168]	; (165b4 <pmu_interrupt_proc+0x180>)
   1650a:	6818      	ldr	r0, [r3, #0]
	return api->read(port, access_op, pin, value);
   1650c:	6843      	ldr	r3, [r0, #4]
   1650e:	2208      	movs	r2, #8
   16510:	f8d3 a008 	ldr.w	sl, [r3, #8]
   16514:	2100      	movs	r1, #0
   16516:	f10d 0307 	add.w	r3, sp, #7
   1651a:	47d0      	blx	sl
   1651c:	2800      	cmp	r0, #0
   1651e:	d038      	beq.n	16592 <pmu_interrupt_proc+0x15e>
			LOG_INF("Cannot get pin");
   16520:	f04f 0000 	mov.w	r0, #0
   16524:	2303      	movs	r3, #3
   16526:	f363 0007 	bfi	r0, r3, #0, #8
   1652a:	f364 108f 	bfi	r0, r4, #6, #10
   1652e:	4922      	ldr	r1, [pc, #136]	; (165b8 <pmu_interrupt_proc+0x184>)
   16530:	f016 fee2 	bl	2d2f8 <log_string_sync>
}
   16534:	b003      	add	sp, #12
   16536:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				g_chg_status = BAT_CHARGING_NO;
   1653a:	2200      	movs	r2, #0
   1653c:	4b1b      	ldr	r3, [pc, #108]	; (165ac <pmu_interrupt_proc+0x178>)
				lcd_sleep_out = true;
   1653e:	701a      	strb	r2, [r3, #0]
				break;
   16540:	e7bc      	b.n	164bc <pmu_interrupt_proc+0x88>
				g_chg_status = BAT_CHARGING_PROGRESS;
   16542:	4b1a      	ldr	r3, [pc, #104]	; (165ac <pmu_interrupt_proc+0x178>)
   16544:	e7fb      	b.n	1653e <pmu_interrupt_proc+0x10a>
				g_chg_status = BAT_CHARGING_FINISHED;
   16546:	2102      	movs	r1, #2
   16548:	4b18      	ldr	r3, [pc, #96]	; (165ac <pmu_interrupt_proc+0x178>)
   1654a:	7019      	strb	r1, [r3, #0]
				lcd_sleep_out = true;
   1654c:	4b1b      	ldr	r3, [pc, #108]	; (165bc <pmu_interrupt_proc+0x188>)
   1654e:	e7f6      	b.n	1653e <pmu_interrupt_proc+0x10a>
				g_chg_status = BAT_CHARGING_NO;
   16550:	7013      	strb	r3, [r2, #0]
				charger_is_connected = false;
   16552:	700b      	strb	r3, [r1, #0]
				g_bat_soc = MAX20353_CalculateSOC();
   16554:	f000 fe2a 	bl	171ac <MAX20353_CalculateSOC>
   16558:	b2c0      	uxtb	r0, r0
				if(g_bat_soc>100)
   1655a:	2864      	cmp	r0, #100	; 0x64
					g_bat_soc = 100;
   1655c:	bf88      	it	hi
   1655e:	2264      	movhi	r2, #100	; 0x64
   16560:	4b17      	ldr	r3, [pc, #92]	; (165c0 <pmu_interrupt_proc+0x18c>)
				g_bat_soc = MAX20353_CalculateSOC();
   16562:	bf94      	ite	ls
   16564:	7018      	strbls	r0, [r3, #0]
					g_bat_soc = 100;
   16566:	701a      	strbhi	r2, [r3, #0]
				if(g_bat_soc < 5)
   16568:	781b      	ldrb	r3, [r3, #0]
   1656a:	2b04      	cmp	r3, #4
   1656c:	d806      	bhi.n	1657c <pmu_interrupt_proc+0x148>
					g_bat_level = BAT_LEVEL_VERY_LOW;
   1656e:	2300      	movs	r3, #0
   16570:	f88a 3000 	strb.w	r3, [sl]
					pmu_battery_low_shutdown();
   16574:	f7ff ff4a 	bl	1640c <pmu_battery_low_shutdown>
				lcd_sleep_out = true;
   16578:	2301      	movs	r3, #1
   1657a:	e7c1      	b.n	16500 <pmu_interrupt_proc+0xcc>
				else if(g_bat_soc < 20)
   1657c:	2b13      	cmp	r3, #19
   1657e:	d803      	bhi.n	16588 <pmu_interrupt_proc+0x154>
					g_bat_level = BAT_LEVEL_LOW;
   16580:	2301      	movs	r3, #1
					g_bat_level = BAT_LEVEL_GOOD;
   16582:	f88a 3000 	strb.w	r3, [sl]
   16586:	e7f7      	b.n	16578 <pmu_interrupt_proc+0x144>
				else if(g_bat_soc < 80)
   16588:	2b4f      	cmp	r3, #79	; 0x4f
					g_bat_level = BAT_LEVEL_NORMAL;
   1658a:	bf94      	ite	ls
   1658c:	2302      	movls	r3, #2
					g_bat_level = BAT_LEVEL_GOOD;
   1658e:	2303      	movhi	r3, #3
   16590:	e7f7      	b.n	16582 <pmu_interrupt_proc+0x14e>
	}while(!val);
   16592:	f89d 3007 	ldrb.w	r3, [sp, #7]
   16596:	2b00      	cmp	r3, #0
   16598:	f43f af58 	beq.w	1644c <pmu_interrupt_proc+0x18>
   1659c:	e7ca      	b.n	16534 <pmu_interrupt_proc+0x100>
   1659e:	bf00      	nop
   165a0:	0003040c 	.word	0x0003040c
   165a4:	000304a4 	.word	0x000304a4
   165a8:	2003b5cd 	.word	0x2003b5cd
   165ac:	2002ff96 	.word	0x2002ff96
   165b0:	2002ff94 	.word	0x2002ff94
   165b4:	200285d8 	.word	0x200285d8
   165b8:	000322b2 	.word	0x000322b2
   165bc:	2002d49b 	.word	0x2002d49b
   165c0:	2002ff95 	.word	0x2002ff95
   165c4:	0003227e 	.word	0x0003227e
   165c8:	000322a0 	.word	0x000322a0
   165cc:	2003b5cc 	.word	0x2003b5cc

000165d0 <pmu_alert_proc>:
{
   165d0:	b573      	push	{r0, r1, r4, r5, r6, lr}
	MAX20353_SOCReadReg(0x1A, &MSB, &LSB);
   165d2:	201a      	movs	r0, #26
   165d4:	f10d 0207 	add.w	r2, sp, #7
   165d8:	f10d 0106 	add.w	r1, sp, #6
   165dc:	f016 fb5b 	bl	2cc96 <MAX20353_SOCReadReg>
	LOG_INF("pmu_alert_proc status:%02X\n", MSB);
   165e0:	2303      	movs	r3, #3
   165e2:	f04f 0000 	mov.w	r0, #0
   165e6:	4c69      	ldr	r4, [pc, #420]	; (1678c <pmu_alert_proc+0x1bc>)
   165e8:	f363 0007 	bfi	r0, r3, #0, #8
   165ec:	4b68      	ldr	r3, [pc, #416]	; (16790 <pmu_alert_proc+0x1c0>)
   165ee:	4969      	ldr	r1, [pc, #420]	; (16794 <pmu_alert_proc+0x1c4>)
   165f0:	1ae4      	subs	r4, r4, r3
   165f2:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   165f6:	f364 108f 	bfi	r0, r4, #6, #10
   165fa:	f89d 2006 	ldrb.w	r2, [sp, #6]
   165fe:	f016 fe7b 	bl	2d2f8 <log_string_sync>
	if(MSB&0x40)
   16602:	f89d 3006 	ldrb.w	r3, [sp, #6]
   16606:	0659      	lsls	r1, r3, #25
   16608:	d50d      	bpl.n	16626 <pmu_alert_proc+0x56>
		MSB = MSB&0xBF;
   1660a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   1660e:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("voltage reset alert!\n");
   16612:	f04f 0000 	mov.w	r0, #0
   16616:	2303      	movs	r3, #3
   16618:	f363 0007 	bfi	r0, r3, #0, #8
   1661c:	f364 108f 	bfi	r0, r4, #6, #10
   16620:	495d      	ldr	r1, [pc, #372]	; (16798 <pmu_alert_proc+0x1c8>)
   16622:	f016 fe69 	bl	2d2f8 <log_string_sync>
	if(MSB&0x20)
   16626:	f89d 3006 	ldrb.w	r3, [sp, #6]
   1662a:	069a      	lsls	r2, r3, #26
   1662c:	d531      	bpl.n	16692 <pmu_alert_proc+0xc2>
		MSB = MSB&0xDF;
   1662e:	f023 0320 	bic.w	r3, r3, #32
   16632:	f88d 3006 	strb.w	r3, [sp, #6]
		g_bat_soc = MAX20353_CalculateSOC();
   16636:	f000 fdb9 	bl	171ac <MAX20353_CalculateSOC>
   1663a:	b2c0      	uxtb	r0, r0
		if(g_bat_soc>100)
   1663c:	2864      	cmp	r0, #100	; 0x64
			g_bat_soc = 100;
   1663e:	bf88      	it	hi
   16640:	2364      	movhi	r3, #100	; 0x64
   16642:	4d56      	ldr	r5, [pc, #344]	; (1679c <pmu_alert_proc+0x1cc>)
		LOG_INF("SOC:%d\n", g_bat_soc);
   16644:	4956      	ldr	r1, [pc, #344]	; (167a0 <pmu_alert_proc+0x1d0>)
		g_bat_soc = MAX20353_CalculateSOC();
   16646:	bf94      	ite	ls
   16648:	7028      	strbls	r0, [r5, #0]
			g_bat_soc = 100;
   1664a:	702b      	strbhi	r3, [r5, #0]
		LOG_INF("SOC:%d\n", g_bat_soc);
   1664c:	f04f 0000 	mov.w	r0, #0
   16650:	2303      	movs	r3, #3
   16652:	f363 0007 	bfi	r0, r3, #0, #8
   16656:	782a      	ldrb	r2, [r5, #0]
   16658:	f364 108f 	bfi	r0, r4, #6, #10
   1665c:	f016 fe4c 	bl	2d2f8 <log_string_sync>
		if(g_bat_soc < 5)
   16660:	782b      	ldrb	r3, [r5, #0]
   16662:	4e50      	ldr	r6, [pc, #320]	; (167a4 <pmu_alert_proc+0x1d4>)
   16664:	2b04      	cmp	r3, #4
   16666:	4d50      	ldr	r5, [pc, #320]	; (167a8 <pmu_alert_proc+0x1d8>)
   16668:	d87d      	bhi.n	16766 <pmu_alert_proc+0x196>
			g_bat_level = BAT_LEVEL_VERY_LOW;
   1666a:	2300      	movs	r3, #0
   1666c:	702b      	strb	r3, [r5, #0]
			if(!charger_is_connected)
   1666e:	7833      	ldrb	r3, [r6, #0]
   16670:	2b00      	cmp	r3, #0
   16672:	f040 8088 	bne.w	16786 <pmu_alert_proc+0x1b6>
				DisplayPopUp("Battery voltage is very low, the system will shut down in a few seconds!");
   16676:	484d      	ldr	r0, [pc, #308]	; (167ac <pmu_alert_proc+0x1dc>)
   16678:	f7ff f928 	bl	158cc <DisplayPopUp>
				pmu_battery_low_shutdown();
   1667c:	f7ff fec6 	bl	1640c <pmu_battery_low_shutdown>
		if(charger_is_connected)
   16680:	7833      	ldrb	r3, [r6, #0]
   16682:	2b00      	cmp	r3, #0
   16684:	d17f      	bne.n	16786 <pmu_alert_proc+0x1b6>
		if(g_chg_status == BAT_CHARGING_NO)
   16686:	4b4a      	ldr	r3, [pc, #296]	; (167b0 <pmu_alert_proc+0x1e0>)
   16688:	781b      	ldrb	r3, [r3, #0]
   1668a:	b913      	cbnz	r3, 16692 <pmu_alert_proc+0xc2>
			pmu_redraw_bat_flag = true;
   1668c:	2201      	movs	r2, #1
   1668e:	4b49      	ldr	r3, [pc, #292]	; (167b4 <pmu_alert_proc+0x1e4>)
   16690:	701a      	strb	r2, [r3, #0]
	if(MSB&0x10)
   16692:	f89d 3006 	ldrb.w	r3, [sp, #6]
   16696:	06de      	lsls	r6, r3, #27
   16698:	d50d      	bpl.n	166b6 <pmu_alert_proc+0xe6>
		MSB = MSB&0xEF;
   1669a:	f023 0310 	bic.w	r3, r3, #16
   1669e:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("SOC low alert!\n");
   166a2:	f04f 0000 	mov.w	r0, #0
   166a6:	2303      	movs	r3, #3
   166a8:	f363 0007 	bfi	r0, r3, #0, #8
   166ac:	f364 108f 	bfi	r0, r4, #6, #10
   166b0:	4941      	ldr	r1, [pc, #260]	; (167b8 <pmu_alert_proc+0x1e8>)
   166b2:	f016 fe21 	bl	2d2f8 <log_string_sync>
	if(MSB&0x08)
   166b6:	f89d 3006 	ldrb.w	r3, [sp, #6]
   166ba:	071d      	lsls	r5, r3, #28
   166bc:	d50d      	bpl.n	166da <pmu_alert_proc+0x10a>
		MSB = MSB&0xF7;
   166be:	f023 0308 	bic.w	r3, r3, #8
   166c2:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("voltage reset alert!\n");
   166c6:	f04f 0000 	mov.w	r0, #0
   166ca:	2303      	movs	r3, #3
   166cc:	f363 0007 	bfi	r0, r3, #0, #8
   166d0:	f364 108f 	bfi	r0, r4, #6, #10
   166d4:	4930      	ldr	r1, [pc, #192]	; (16798 <pmu_alert_proc+0x1c8>)
   166d6:	f016 fe0f 	bl	2d2f8 <log_string_sync>
	if(MSB&0x04)
   166da:	f89d 3006 	ldrb.w	r3, [sp, #6]
   166de:	0758      	lsls	r0, r3, #29
   166e0:	d50d      	bpl.n	166fe <pmu_alert_proc+0x12e>
		MSB = MSB&0xFB;
   166e2:	f023 0304 	bic.w	r3, r3, #4
   166e6:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("voltage low alert!\n");
   166ea:	f04f 0000 	mov.w	r0, #0
   166ee:	2303      	movs	r3, #3
   166f0:	f363 0007 	bfi	r0, r3, #0, #8
   166f4:	f364 108f 	bfi	r0, r4, #6, #10
   166f8:	4930      	ldr	r1, [pc, #192]	; (167bc <pmu_alert_proc+0x1ec>)
   166fa:	f016 fdfd 	bl	2d2f8 <log_string_sync>
	if(MSB&0x02)
   166fe:	f89d 3006 	ldrb.w	r3, [sp, #6]
   16702:	0799      	lsls	r1, r3, #30
   16704:	d50d      	bpl.n	16722 <pmu_alert_proc+0x152>
		MSB = MSB&0xFD;
   16706:	f023 0302 	bic.w	r3, r3, #2
   1670a:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("voltage high alert!\n");
   1670e:	f04f 0000 	mov.w	r0, #0
   16712:	2303      	movs	r3, #3
   16714:	f363 0007 	bfi	r0, r3, #0, #8
   16718:	f364 108f 	bfi	r0, r4, #6, #10
   1671c:	4928      	ldr	r1, [pc, #160]	; (167c0 <pmu_alert_proc+0x1f0>)
   1671e:	f016 fdeb 	bl	2d2f8 <log_string_sync>
	if(MSB&0x01)
   16722:	f89d 3006 	ldrb.w	r3, [sp, #6]
   16726:	07da      	lsls	r2, r3, #31
   16728:	d50f      	bpl.n	1674a <pmu_alert_proc+0x17a>
		MSB = MSB&0xFE;
   1672a:	f023 0301 	bic.w	r3, r3, #1
   1672e:	f88d 3006 	strb.w	r3, [sp, #6]
		LOG_INF("reset indicator alert!\n");
   16732:	f04f 0000 	mov.w	r0, #0
   16736:	2303      	movs	r3, #3
   16738:	f363 0007 	bfi	r0, r3, #0, #8
   1673c:	f364 108f 	bfi	r0, r4, #6, #10
   16740:	4920      	ldr	r1, [pc, #128]	; (167c4 <pmu_alert_proc+0x1f4>)
   16742:	f016 fdd9 	bl	2d2f8 <log_string_sync>
		MAX20353_QuickStart();
   16746:	f016 fa8c 	bl	2cc62 <MAX20353_QuickStart>
	MAX20353_SOCWriteReg(0x1A, MSB, LSB);
   1674a:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1674e:	f89d 1006 	ldrb.w	r1, [sp, #6]
   16752:	201a      	movs	r0, #26
   16754:	f016 faa1 	bl	2cc9a <MAX20353_SOCWriteReg>
	MAX20353_SOCWriteReg(0x0C, 0x12, 0x5C);
   16758:	225c      	movs	r2, #92	; 0x5c
   1675a:	2112      	movs	r1, #18
   1675c:	200c      	movs	r0, #12
   1675e:	f016 fa9c 	bl	2cc9a <MAX20353_SOCWriteReg>
}
   16762:	b002      	add	sp, #8
   16764:	bd70      	pop	{r4, r5, r6, pc}
		else if(g_bat_soc < 20)
   16766:	2b13      	cmp	r3, #19
   16768:	d807      	bhi.n	1677a <pmu_alert_proc+0x1aa>
			g_bat_level = BAT_LEVEL_LOW;
   1676a:	2201      	movs	r2, #1
   1676c:	7833      	ldrb	r3, [r6, #0]
   1676e:	702a      	strb	r2, [r5, #0]
			if(!charger_is_connected)
   16770:	b94b      	cbnz	r3, 16786 <pmu_alert_proc+0x1b6>
				DisplayPopUp("Battery voltage is low, please charge in time!");
   16772:	4815      	ldr	r0, [pc, #84]	; (167c8 <pmu_alert_proc+0x1f8>)
   16774:	f7ff f8aa 	bl	158cc <DisplayPopUp>
   16778:	e782      	b.n	16680 <pmu_alert_proc+0xb0>
		else if(g_bat_soc < 80)
   1677a:	2b4f      	cmp	r3, #79	; 0x4f
			g_bat_level = BAT_LEVEL_NORMAL;
   1677c:	bf94      	ite	ls
   1677e:	2302      	movls	r3, #2
			g_bat_level = BAT_LEVEL_GOOD;
   16780:	2303      	movhi	r3, #3
   16782:	702b      	strb	r3, [r5, #0]
   16784:	e77c      	b.n	16680 <pmu_alert_proc+0xb0>
			g_bat_level = BAT_LEVEL_NORMAL;
   16786:	2302      	movs	r3, #2
   16788:	702b      	strb	r3, [r5, #0]
   1678a:	e77c      	b.n	16686 <pmu_alert_proc+0xb6>
   1678c:	000304a4 	.word	0x000304a4
   16790:	0003040c 	.word	0x0003040c
   16794:	00032171 	.word	0x00032171
   16798:	0003218d 	.word	0x0003218d
   1679c:	2002ff95 	.word	0x2002ff95
   167a0:	000321a3 	.word	0x000321a3
   167a4:	2002ff94 	.word	0x2002ff94
   167a8:	2003b5cc 	.word	0x2003b5cc
   167ac:	000321ab 	.word	0x000321ab
   167b0:	2002ff96 	.word	0x2002ff96
   167b4:	2003b5cd 	.word	0x2003b5cd
   167b8:	00032223 	.word	0x00032223
   167bc:	00032233 	.word	0x00032233
   167c0:	00032247 	.word	0x00032247
   167c4:	0003225c 	.word	0x0003225c
   167c8:	000321f4 	.word	0x000321f4

000167cc <MAX20353_InitData>:

void MAX20353_InitData(void)
{
   167cc:	b508      	push	{r3, lr}
	pmu_interrupt_proc();
   167ce:	f7ff fe31 	bl	16434 <pmu_interrupt_proc>
	
	g_bat_soc = MAX20353_CalculateSOC();
   167d2:	f000 fceb 	bl	171ac <MAX20353_CalculateSOC>
   167d6:	b2c0      	uxtb	r0, r0
	if(g_bat_soc>100)
   167d8:	2864      	cmp	r0, #100	; 0x64
		g_bat_soc = 100;
   167da:	bf88      	it	hi
   167dc:	2264      	movhi	r2, #100	; 0x64
   167de:	4b02      	ldr	r3, [pc, #8]	; (167e8 <MAX20353_InitData+0x1c>)
	g_bat_soc = MAX20353_CalculateSOC();
   167e0:	bf94      	ite	ls
   167e2:	7018      	strbls	r0, [r3, #0]
		g_bat_soc = 100;
   167e4:	701a      	strbhi	r2, [r3, #0]

	//test_soc();
}
   167e6:	bd08      	pop	{r3, pc}
   167e8:	2002ff95 	.word	0x2002ff95

000167ec <pmu_init>:
void pmu_init(void)
{
	bool rst;
	int flag = GPIO_DIR_IN|GPIO_INT|GPIO_INT_EDGE|GPIO_PUD_PULL_UP|GPIO_INT_ACTIVE_LOW|GPIO_INT_DEBOUNCE;

	LOG_INF("pmu_init\n");
   167ec:	2303      	movs	r3, #3
   167ee:	f04f 0000 	mov.w	r0, #0
{
   167f2:	b570      	push	{r4, r5, r6, lr}
	LOG_INF("pmu_init\n");
   167f4:	f363 0007 	bfi	r0, r3, #0, #8
   167f8:	4d35      	ldr	r5, [pc, #212]	; (168d0 <pmu_init+0xe4>)
   167fa:	4b36      	ldr	r3, [pc, #216]	; (168d4 <pmu_init+0xe8>)
   167fc:	4936      	ldr	r1, [pc, #216]	; (168d8 <pmu_init+0xec>)
   167fe:	1aed      	subs	r5, r5, r3
   16800:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   16804:	f365 108f 	bfi	r0, r5, #6, #10
   16808:	f016 fd76 	bl	2d2f8 <log_string_sync>
   1680c:	4833      	ldr	r0, [pc, #204]	; (168dc <pmu_init+0xf0>)
   1680e:	f00f fcdb 	bl	261c8 <z_impl_device_get_binding>

  	//
  	gpio_pmu = device_get_binding(PMU_PORT);
   16812:	4c33      	ldr	r4, [pc, #204]	; (168e0 <pmu_init+0xf4>)
   16814:	6020      	str	r0, [r4, #0]
	if(!gpio_pmu)
   16816:	b958      	cbnz	r0, 16830 <pmu_init+0x44>
	{
		LOG_INF("Cannot bind gpio device\n");
   16818:	f04f 0000 	mov.w	r0, #0
   1681c:	2303      	movs	r3, #3
   1681e:	4931      	ldr	r1, [pc, #196]	; (168e4 <pmu_init+0xf8>)
   16820:	f363 0007 	bfi	r0, r3, #0, #8
   16824:	f365 108f 	bfi	r0, r5, #6, #10
	pmu_dev_ctx.read_reg  = platform_read;
	pmu_dev_ctx.handle    = i2c_pmu;

	MAX20353_Init();
	MAX20353_InitData();
}
   16828:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LOG_INF("ERROR SETTING UP I2C\r\n");
   1682c:	f016 bd64 	b.w	2d2f8 <log_string_sync>
	return api->config(port, access_op, pin, flags);
   16830:	6843      	ldr	r3, [r0, #4]
   16832:	2208      	movs	r2, #8
   16834:	681e      	ldr	r6, [r3, #0]
   16836:	2100      	movs	r1, #0
   16838:	f44f 7399 	mov.w	r3, #306	; 0x132
   1683c:	47b0      	blx	r6
	gpio_pin_disable_callback(gpio_pmu, PMU_EINT);
   1683e:	2108      	movs	r1, #8
   16840:	6820      	ldr	r0, [r4, #0]
   16842:	f016 f966 	bl	2cb12 <gpio_pin_disable_callback>
	callback->handler = handler;
   16846:	4928      	ldr	r1, [pc, #160]	; (168e8 <pmu_init+0xfc>)
   16848:	4b28      	ldr	r3, [pc, #160]	; (168ec <pmu_init+0x100>)
	gpio_add_callback(gpio_pmu, &gpio_cb1);
   1684a:	6820      	ldr	r0, [r4, #0]
   1684c:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
   1684e:	f44f 7380 	mov.w	r3, #256	; 0x100
   16852:	608b      	str	r3, [r1, #8]
   16854:	f016 f955 	bl	2cb02 <gpio_add_callback>
	gpio_pin_enable_callback(gpio_pmu, PMU_EINT);
   16858:	2108      	movs	r1, #8
   1685a:	6820      	ldr	r0, [r4, #0]
   1685c:	f016 f962 	bl	2cb24 <gpio_pin_enable_callback>
	gpio_pin_configure(gpio_pmu, PMU_ALRTB, flag);
   16860:	6820      	ldr	r0, [r4, #0]
	return api->config(port, access_op, pin, flags);
   16862:	6843      	ldr	r3, [r0, #4]
   16864:	2207      	movs	r2, #7
   16866:	681e      	ldr	r6, [r3, #0]
   16868:	2100      	movs	r1, #0
   1686a:	f44f 7399 	mov.w	r3, #306	; 0x132
   1686e:	47b0      	blx	r6
	gpio_pin_disable_callback(gpio_pmu, PMU_ALRTB);
   16870:	2107      	movs	r1, #7
   16872:	6820      	ldr	r0, [r4, #0]
   16874:	f016 f94d 	bl	2cb12 <gpio_pin_disable_callback>
	callback->handler = handler;
   16878:	491d      	ldr	r1, [pc, #116]	; (168f0 <pmu_init+0x104>)
   1687a:	4b1e      	ldr	r3, [pc, #120]	; (168f4 <pmu_init+0x108>)
	gpio_add_callback(gpio_pmu, &gpio_cb2);
   1687c:	6820      	ldr	r0, [r4, #0]
   1687e:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
   16880:	2380      	movs	r3, #128	; 0x80
   16882:	608b      	str	r3, [r1, #8]
   16884:	f016 f93d 	bl	2cb02 <gpio_add_callback>
	gpio_pin_enable_callback(gpio_pmu, PMU_ALRTB);
   16888:	2107      	movs	r1, #7
   1688a:	6820      	ldr	r0, [r4, #0]
   1688c:	f016 f94a 	bl	2cb24 <gpio_pin_enable_callback>
   16890:	4819      	ldr	r0, [pc, #100]	; (168f8 <pmu_init+0x10c>)
   16892:	f00f fc99 	bl	261c8 <z_impl_device_get_binding>
	i2c_pmu = device_get_binding(PMU_DEV);
   16896:	4c19      	ldr	r4, [pc, #100]	; (168fc <pmu_init+0x110>)
   16898:	6020      	str	r0, [r4, #0]
	if(!i2c_pmu)
   1689a:	b940      	cbnz	r0, 168ae <pmu_init+0xc2>
		LOG_INF("ERROR SETTING UP I2C\r\n");
   1689c:	f04f 0000 	mov.w	r0, #0
   168a0:	2303      	movs	r3, #3
   168a2:	f363 0007 	bfi	r0, r3, #0, #8
   168a6:	f365 108f 	bfi	r0, r5, #6, #10
   168aa:	4915      	ldr	r1, [pc, #84]	; (16900 <pmu_init+0x114>)
   168ac:	e7bc      	b.n	16828 <pmu_init+0x3c>
   168ae:	6843      	ldr	r3, [r0, #4]
   168b0:	2104      	movs	r1, #4
   168b2:	681b      	ldr	r3, [r3, #0]
   168b4:	4798      	blx	r3
	pmu_dev_ctx.write_reg = platform_write;
   168b6:	4b13      	ldr	r3, [pc, #76]	; (16904 <pmu_init+0x118>)
   168b8:	4a13      	ldr	r2, [pc, #76]	; (16908 <pmu_init+0x11c>)
   168ba:	601a      	str	r2, [r3, #0]
	pmu_dev_ctx.read_reg  = platform_read;
   168bc:	4a13      	ldr	r2, [pc, #76]	; (1690c <pmu_init+0x120>)
   168be:	605a      	str	r2, [r3, #4]
	pmu_dev_ctx.handle    = i2c_pmu;
   168c0:	6822      	ldr	r2, [r4, #0]
   168c2:	609a      	str	r2, [r3, #8]
	MAX20353_Init();
   168c4:	f000 fd08 	bl	172d8 <MAX20353_Init>
}
   168c8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	MAX20353_InitData();
   168cc:	f7ff bf7e 	b.w	167cc <MAX20353_InitData>
   168d0:	000304a4 	.word	0x000304a4
   168d4:	0003040c 	.word	0x0003040c
   168d8:	00032274 	.word	0x00032274
   168dc:	000310d7 	.word	0x000310d7
   168e0:	200285d8 	.word	0x200285d8
   168e4:	000310de 	.word	0x000310de
   168e8:	200285c0 	.word	0x200285c0
   168ec:	000163c9 	.word	0x000163c9
   168f0:	200285cc 	.word	0x200285cc
   168f4:	000163d5 	.word	0x000163d5
   168f8:	00032022 	.word	0x00032022
   168fc:	200285dc 	.word	0x200285dc
   16900:	00032028 	.word	0x00032028
   16904:	200285e0 	.word	0x200285e0
   16908:	0002cb37 	.word	0x0002cb37
   1690c:	0002cb7d 	.word	0x0002cb7d

00016910 <test_soc_status>:
	ret |= MAX20353_ReadReg(REG_SYSTEM_ERROR, &buf_results[4]);
	return ret;
}

void test_soc_status(void)
{
   16910:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16914:	ed2d 8b02 	vpush	{d8}
	u8_t MSB,LSB;
	u8_t RCOMP,Status0,Status1,Status2,Status3;
	u16_t VCell,SOC,CRate,MODE,Version,HIBRT,Config,Status,VALRT,VReset,CMD,OCV;
	u8_t strbuf[512] = {0};
   16918:	f44f 7b00 	mov.w	fp, #512	; 0x200
{
   1691c:	f5ad 7d21 	sub.w	sp, sp, #644	; 0x284
	u8_t strbuf[512] = {0};
   16920:	465a      	mov	r2, fp
   16922:	2100      	movs	r1, #0
   16924:	a820      	add	r0, sp, #128	; 0x80
   16926:	f018 fd35 	bl	2f394 <memset>
	
	MAX20353_SOCReadReg(0x02, &MSB, &LSB);//vcell
   1692a:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   1692e:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
   16932:	2002      	movs	r0, #2
   16934:	f016 f9af 	bl	2cc96 <MAX20353_SOCReadReg>
	VCell = ((MSB<<8)+LSB);
   16938:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   1693c:	f89d 307e 	ldrb.w	r3, [sp, #126]	; 0x7e
	VCell = VCell*625/8/1000;
	
	MAX20353_SOCReadReg(0x04, &MSB, &LSB);//soc
   16940:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	VCell = ((MSB<<8)+LSB);
   16944:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	VCell = VCell*625/8/1000;
   16948:	f240 2271 	movw	r2, #625	; 0x271
   1694c:	b29b      	uxth	r3, r3
   1694e:	4353      	muls	r3, r2
   16950:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
   16954:	fbb3 f3f2 	udiv	r3, r3, r2
	MAX20353_SOCReadReg(0x04, &MSB, &LSB);//soc
   16958:	2004      	movs	r0, #4
   1695a:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
	VCell = VCell*625/8/1000;
   1695e:	9319      	str	r3, [sp, #100]	; 0x64
	MAX20353_SOCReadReg(0x04, &MSB, &LSB);//soc
   16960:	f016 f999 	bl	2cc96 <MAX20353_SOCReadReg>
	SOC = ((MSB<<8)+LSB);
   16964:	f89d 307d 	ldrb.w	r3, [sp, #125]	; 0x7d
   16968:	f89d 007e 	ldrb.w	r0, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x0C, &MSB, &LSB);//Config RCOMP(MSB)
   1696c:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
	SOC = ((MSB<<8)+LSB);
   16970:	eb00 2003 	add.w	r0, r0, r3, lsl #8
   16974:	b283      	uxth	r3, r0
	MAX20353_SOCReadReg(0x0C, &MSB, &LSB);//Config RCOMP(MSB)
   16976:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
   1697a:	200c      	movs	r0, #12
	SOC = ((MSB<<8)+LSB);
   1697c:	ee08 3a10 	vmov	s16, r3
	MAX20353_SOCReadReg(0x0C, &MSB, &LSB);//Config RCOMP(MSB)
   16980:	f016 f989 	bl	2cc96 <MAX20353_SOCReadReg>
	RCOMP = MSB;
	Config = ((MSB<<8)+LSB);
   16984:	f89d 307d 	ldrb.w	r3, [sp, #125]	; 0x7d
   16988:	f89d 607e 	ldrb.w	r6, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x16, &MSB, &LSB);//CRate
   1698c:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   16990:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
   16994:	2016      	movs	r0, #22
	Config = ((MSB<<8)+LSB);
   16996:	eb06 2603 	add.w	r6, r6, r3, lsl #8
   1699a:	931d      	str	r3, [sp, #116]	; 0x74
	MAX20353_SOCReadReg(0x16, &MSB, &LSB);//CRate
   1699c:	f016 f97b 	bl	2cc96 <MAX20353_SOCReadReg>
	CRate = ((MSB<<8)+LSB);
   169a0:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   169a4:	f89d 407e 	ldrb.w	r4, [sp, #126]	; 0x7e
	if(CRate&0x8000==0x8000)
		CRate |= 0xFFFF0000;
	CRate = CRate*208;
	
	MAX20353_SOCReadReg(0x06, &MSB, &LSB);//MODE
   169a8:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	CRate = ((MSB<<8)+LSB);
   169ac:	eb04 2402 	add.w	r4, r4, r2, lsl #8
	MAX20353_SOCReadReg(0x06, &MSB, &LSB);//MODE
   169b0:	2006      	movs	r0, #6
   169b2:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   169b6:	f016 f96e 	bl	2cc96 <MAX20353_SOCReadReg>
	MODE = ((MSB<<8)+LSB);
   169ba:	f89d 107d 	ldrb.w	r1, [sp, #125]	; 0x7d
   169be:	f89d 207e 	ldrb.w	r2, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x08, &MSB, &LSB);//Version
   169c2:	2008      	movs	r0, #8
	MODE = ((MSB<<8)+LSB);
   169c4:	eb02 2201 	add.w	r2, r2, r1, lsl #8
   169c8:	b293      	uxth	r3, r2
	MAX20353_SOCReadReg(0x08, &MSB, &LSB);//Version
   169ca:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
   169ce:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
	MODE = ((MSB<<8)+LSB);
   169d2:	931a      	str	r3, [sp, #104]	; 0x68
	MAX20353_SOCReadReg(0x08, &MSB, &LSB);//Version
   169d4:	f016 f95f 	bl	2cc96 <MAX20353_SOCReadReg>
	Version = ((MSB<<8)+LSB);
   169d8:	f89d 107d 	ldrb.w	r1, [sp, #125]	; 0x7d
   169dc:	f89d 207e 	ldrb.w	r2, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x0A, &MSB, &LSB);//HIBRT
   169e0:	200a      	movs	r0, #10
	Version = ((MSB<<8)+LSB);
   169e2:	eb02 2201 	add.w	r2, r2, r1, lsl #8
   169e6:	b293      	uxth	r3, r2
	MAX20353_SOCReadReg(0x0A, &MSB, &LSB);//HIBRT
   169e8:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
   169ec:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
	Version = ((MSB<<8)+LSB);
   169f0:	931b      	str	r3, [sp, #108]	; 0x6c
	MAX20353_SOCReadReg(0x0A, &MSB, &LSB);//HIBRT
   169f2:	f016 f950 	bl	2cc96 <MAX20353_SOCReadReg>
	HIBRT = ((MSB<<8)+LSB);
   169f6:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   169fa:	f89d 507e 	ldrb.w	r5, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x1A, &MSB, &LSB);//Status
   169fe:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	HIBRT = ((MSB<<8)+LSB);
   16a02:	eb05 2502 	add.w	r5, r5, r2, lsl #8
	MAX20353_SOCReadReg(0x1A, &MSB, &LSB);//Status
   16a06:	201a      	movs	r0, #26
   16a08:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   16a0c:	f016 f943 	bl	2cc96 <MAX20353_SOCReadReg>
	Status = ((MSB<<8)+LSB);
   16a10:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   16a14:	f89d 707e 	ldrb.w	r7, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x14, &MSB, &LSB);//VALRT
   16a18:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	Status = ((MSB<<8)+LSB);
   16a1c:	eb07 2702 	add.w	r7, r7, r2, lsl #8
	MAX20353_SOCReadReg(0x14, &MSB, &LSB);//VALRT
   16a20:	2014      	movs	r0, #20
   16a22:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   16a26:	f016 f936 	bl	2cc96 <MAX20353_SOCReadReg>
	VALRT = ((MSB<<8)+LSB);
   16a2a:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   16a2e:	f89d 807e 	ldrb.w	r8, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x18, &MSB, &LSB);//VReset
   16a32:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	VALRT = ((MSB<<8)+LSB);
   16a36:	eb08 2802 	add.w	r8, r8, r2, lsl #8
	MAX20353_SOCReadReg(0x18, &MSB, &LSB);//VReset
   16a3a:	2018      	movs	r0, #24
   16a3c:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   16a40:	f016 f929 	bl	2cc96 <MAX20353_SOCReadReg>
	VReset = ((MSB<<8)+LSB);
   16a44:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   16a48:	f89d 907e 	ldrb.w	r9, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0xFE, &MSB, &LSB);//CMD
   16a4c:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	VReset = ((MSB<<8)+LSB);
   16a50:	eb09 2902 	add.w	r9, r9, r2, lsl #8
	MAX20353_SOCReadReg(0xFE, &MSB, &LSB);//CMD
   16a54:	20fe      	movs	r0, #254	; 0xfe
   16a56:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   16a5a:	f016 f91c 	bl	2cc96 <MAX20353_SOCReadReg>
	CMD = ((MSB<<8)+LSB);
   16a5e:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   16a62:	f89d a07e 	ldrb.w	sl, [sp, #126]	; 0x7e
	
	MAX20353_SOCReadReg(0x0E, &MSB, &LSB);//OCV
   16a66:	f10d 017d 	add.w	r1, sp, #125	; 0x7d
	CMD = ((MSB<<8)+LSB);
   16a6a:	eb0a 2a02 	add.w	sl, sl, r2, lsl #8
	MAX20353_SOCReadReg(0x0E, &MSB, &LSB);//OCV
   16a6e:	200e      	movs	r0, #14
   16a70:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   16a74:	f016 f90f 	bl	2cc96 <MAX20353_SOCReadReg>
	OCV = ((MSB<<8)+LSB);
   16a78:	f89d 107d 	ldrb.w	r1, [sp, #125]	; 0x7d
   16a7c:	f89d 207e 	ldrb.w	r2, [sp, #126]	; 0x7e

	MAX20353_ReadReg(REG_STATUS0, &Status0);
   16a80:	2006      	movs	r0, #6
	OCV = ((MSB<<8)+LSB);
   16a82:	eb02 2201 	add.w	r2, r2, r1, lsl #8
   16a86:	b292      	uxth	r2, r2
	MAX20353_ReadReg(REG_STATUS0, &Status0);
   16a88:	f10d 017f 	add.w	r1, sp, #127	; 0x7f
	OCV = ((MSB<<8)+LSB);
   16a8c:	921c      	str	r2, [sp, #112]	; 0x70
	MAX20353_ReadReg(REG_STATUS0, &Status0);
   16a8e:	f000 f90d 	bl	16cac <MAX20353_ReadReg>
	Status0 = Status0&0x07;
	
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   16a92:	9a1c      	ldr	r2, [sp, #112]	; 0x70
	CRate = ((MSB<<8)+LSB);
   16a94:	b2a4      	uxth	r4, r4
	CMD = ((MSB<<8)+LSB);
   16a96:	fa1f fa8a 	uxth.w	sl, sl
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   16a9a:	e9cd a215 	strd	sl, r2, [sp, #84]	; 0x54
	CRate = CRate*208;
   16a9e:	eb04 0244 	add.w	r2, r4, r4, lsl #1
   16aa2:	eb04 0482 	add.w	r4, r4, r2, lsl #2
   16aa6:	0124      	lsls	r4, r4, #4
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   16aa8:	b2a4      	uxth	r4, r4
   16aaa:	ee07 4a90 	vmov	s15, r4
   16aae:	eddf 8a35 	vldr	s17, [pc, #212]	; 16b84 <test_soc_status+0x274>
   16ab2:	eef8 7a67 	vcvt.f32.u32	s15, s15
   16ab6:	ee87 7aa8 	vdiv.f32	s14, s15, s17
   16aba:	eddf 7a33 	vldr	s15, [pc, #204]	; 16b88 <test_soc_status+0x278>
   16abe:	eec7 7a27 	vdiv.f32	s15, s14, s15
   16ac2:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
	Status0 = Status0&0x07;
   16ac4:	f89d 107f 	ldrb.w	r1, [sp, #127]	; 0x7f
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   16ac8:	930f      	str	r3, [sp, #60]	; 0x3c
   16aca:	9b1a      	ldr	r3, [sp, #104]	; 0x68
	Status0 = Status0&0x07;
   16acc:	f001 0107 	and.w	r1, r1, #7
	Config = ((MSB<<8)+LSB);
   16ad0:	b2b6      	uxth	r6, r6
	HIBRT = ((MSB<<8)+LSB);
   16ad2:	b2ad      	uxth	r5, r5
	Status = ((MSB<<8)+LSB);
   16ad4:	b2bf      	uxth	r7, r7
	VALRT = ((MSB<<8)+LSB);
   16ad6:	fa1f f888 	uxth.w	r8, r8
	VReset = ((MSB<<8)+LSB);
   16ada:	fa1f f989 	uxth.w	r9, r9
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   16ade:	ee17 0a90 	vmov	r0, s15
   16ae2:	930e      	str	r3, [sp, #56]	; 0x38
	Status0 = Status0&0x07;
   16ae4:	f88d 107f 	strb.w	r1, [sp, #127]	; 0x7f
	sprintf(strbuf, "%02d/%02d/%04d-%02d:%02d:%02d %2.3f,%3.8f,0x%02X,%1.5f,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,0x%04X,%d\n", 
   16ae8:	9117      	str	r1, [sp, #92]	; 0x5c
   16aea:	e9cd 8913 	strd	r8, r9, [sp, #76]	; 0x4c
   16aee:	e9cd 6711 	strd	r6, r7, [sp, #68]	; 0x44
   16af2:	9510      	str	r5, [sp, #64]	; 0x40
   16af4:	f7f5 fd08 	bl	c508 <__aeabi_f2d>
   16af8:	eef8 7a48 	vcvt.f32.u32	s15, s16
   16afc:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   16afe:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   16b02:	ee17 0a90 	vmov	r0, s15
   16b06:	930a      	str	r3, [sp, #40]	; 0x28
   16b08:	f7f5 fcfe 	bl	c508 <__aeabi_f2d>
   16b0c:	2200      	movs	r2, #0
   16b0e:	4b1f      	ldr	r3, [pc, #124]	; (16b8c <test_soc_status+0x27c>)
   16b10:	f7f5 fd52 	bl	c5b8 <__aeabi_dmul>
   16b14:	f8bd 3064 	ldrh.w	r3, [sp, #100]	; 0x64
   16b18:	e9cd 0108 	strd	r0, r1, [sp, #32]
   16b1c:	ee07 3a90 	vmov	s15, r3
   16b20:	eef8 7a67 	vcvt.f32.u32	s15, s15
   16b24:	eec7 7aa8 	vdiv.f32	s15, s15, s17
   16b28:	ee17 0a90 	vmov	r0, s15
   16b2c:	f7f5 fcec 	bl	c508 <__aeabi_f2d>
   16b30:	e9cd 0106 	strd	r0, r1, [sp, #24]
   16b34:	4b16      	ldr	r3, [pc, #88]	; (16b90 <test_soc_status+0x280>)
   16b36:	2100      	movs	r1, #0
   16b38:	799a      	ldrb	r2, [r3, #6]
   16b3a:	a820      	add	r0, sp, #128	; 0x80
   16b3c:	9205      	str	r2, [sp, #20]
   16b3e:	795a      	ldrb	r2, [r3, #5]
   16b40:	9204      	str	r2, [sp, #16]
   16b42:	791a      	ldrb	r2, [r3, #4]
   16b44:	9203      	str	r2, [sp, #12]
   16b46:	881a      	ldrh	r2, [r3, #0]
   16b48:	9202      	str	r2, [sp, #8]
   16b4a:	789a      	ldrb	r2, [r3, #2]
   16b4c:	9201      	str	r2, [sp, #4]
   16b4e:	78db      	ldrb	r3, [r3, #3]
   16b50:	465a      	mov	r2, fp
   16b52:	9300      	str	r3, [sp, #0]
   16b54:	4b0f      	ldr	r3, [pc, #60]	; (16b94 <test_soc_status+0x284>)
   16b56:	f018 fd5f 	bl	2f618 <__sprintf_chk>
				(float)VCell/1000, (float)SOC/256.0,
				RCOMP,
				(float)CRate/1000/100,
				MODE, Version, HIBRT, Config, Status, VALRT, VReset, CMD, OCV, Status0);

	LOG_INF("%s", strbuf);
   16b5a:	2303      	movs	r3, #3
   16b5c:	f04f 0000 	mov.w	r0, #0
   16b60:	4a0d      	ldr	r2, [pc, #52]	; (16b98 <test_soc_status+0x288>)
   16b62:	f363 0007 	bfi	r0, r3, #0, #8
   16b66:	4b0d      	ldr	r3, [pc, #52]	; (16b9c <test_soc_status+0x28c>)
   16b68:	490d      	ldr	r1, [pc, #52]	; (16ba0 <test_soc_status+0x290>)
   16b6a:	1a9b      	subs	r3, r3, r2
   16b6c:	08db      	lsrs	r3, r3, #3
   16b6e:	f363 108f 	bfi	r0, r3, #6, #10
   16b72:	aa20      	add	r2, sp, #128	; 0x80
   16b74:	f016 fbc0 	bl	2d2f8 <log_string_sync>
}
   16b78:	f50d 7d21 	add.w	sp, sp, #644	; 0x284
   16b7c:	ecbd 8b02 	vpop	{d8}
   16b80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   16b84:	447a0000 	.word	0x447a0000
   16b88:	42c80000 	.word	0x42c80000
   16b8c:	3f700000 	.word	0x3f700000
   16b90:	2002d410 	.word	0x2002d410
   16b94:	000322ca 	.word	0x000322ca
   16b98:	0003040c 	.word	0x0003040c
   16b9c:	000304a4 	.word	0x000304a4
   16ba0:	000335f1 	.word	0x000335f1

00016ba4 <PMURedrawBatStatus>:
	k_timer_start(&soc_timer, K_MSEC(10*1000), K_MSEC(15*1000));
}

void PMURedrawBatStatus(void)
{
	if(screen_id == SCREEN_ID_IDLE)
   16ba4:	4b05      	ldr	r3, [pc, #20]	; (16bbc <PMURedrawBatStatus+0x18>)
   16ba6:	781b      	ldrb	r3, [r3, #0]
   16ba8:	2b01      	cmp	r3, #1
   16baa:	d106      	bne.n	16bba <PMURedrawBatStatus+0x16>
	{
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_BAT;
   16bac:	4b04      	ldr	r3, [pc, #16]	; (16bc0 <PMURedrawBatStatus+0x1c>)
   16bae:	68da      	ldr	r2, [r3, #12]
   16bb0:	f042 0202 	orr.w	r2, r2, #2
   16bb4:	60da      	str	r2, [r3, #12]
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   16bb6:	2202      	movs	r2, #2
   16bb8:	725a      	strb	r2, [r3, #9]
	}
}
   16bba:	4770      	bx	lr
   16bbc:	2002ff93 	.word	0x2002ff93
   16bc0:	20028540 	.word	0x20028540

00016bc4 <PMUMsgProcess>:
	MAX20353_UpdateTemper();
}
#endif

void PMUMsgProcess(void)
{
   16bc4:	b510      	push	{r4, lr}
	if(pmu_trige_flag)
   16bc6:	4c1c      	ldr	r4, [pc, #112]	; (16c38 <PMUMsgProcess+0x74>)
   16bc8:	7823      	ldrb	r3, [r4, #0]
   16bca:	b11b      	cbz	r3, 16bd4 <PMUMsgProcess+0x10>
	{
		pmu_interrupt_proc();
   16bcc:	f7ff fc32 	bl	16434 <pmu_interrupt_proc>
		pmu_trige_flag = false;
   16bd0:	2300      	movs	r3, #0
   16bd2:	7023      	strb	r3, [r4, #0]
	}
	
	if(pmu_alert_flag)
   16bd4:	4c19      	ldr	r4, [pc, #100]	; (16c3c <PMUMsgProcess+0x78>)
   16bd6:	7823      	ldrb	r3, [r4, #0]
   16bd8:	b11b      	cbz	r3, 16be2 <PMUMsgProcess+0x1e>
	{
		pmu_alert_proc();
   16bda:	f7ff fcf9 	bl	165d0 <pmu_alert_proc>
		pmu_alert_flag = false;
   16bde:	2300      	movs	r3, #0
   16be0:	7023      	strb	r3, [r4, #0]
	}
	
	if(sys_pwr_off)
   16be2:	4c17      	ldr	r4, [pc, #92]	; (16c40 <PMUMsgProcess+0x7c>)
   16be4:	7823      	ldrb	r3, [r4, #0]
   16be6:	b11b      	cbz	r3, 16bf0 <PMUMsgProcess+0x2c>
	{
		SystemShutDown();
   16be8:	f015 fff9 	bl	2cbde <SystemShutDown>
		sys_pwr_off = false;		
   16bec:	2300      	movs	r3, #0
   16bee:	7023      	strb	r3, [r4, #0]
	}
	
	if(vibrate_start_flag)
   16bf0:	4c14      	ldr	r4, [pc, #80]	; (16c44 <PMUMsgProcess+0x80>)
   16bf2:	7823      	ldrb	r3, [r4, #0]
   16bf4:	b11b      	cbz	r3, 16bfe <PMUMsgProcess+0x3a>
	{
		VibrateStart();
   16bf6:	f015 fffb 	bl	2cbf0 <VibrateStart>
		vibrate_start_flag = false;
   16bfa:	2300      	movs	r3, #0
   16bfc:	7023      	strb	r3, [r4, #0]
	}
	
	if(vibrate_stop_flag)
   16bfe:	4c12      	ldr	r4, [pc, #72]	; (16c48 <PMUMsgProcess+0x84>)
   16c00:	7823      	ldrb	r3, [r4, #0]
   16c02:	b11b      	cbz	r3, 16c0c <PMUMsgProcess+0x48>
	{
		VibrateStop();
   16c04:	f015 ffff 	bl	2cc06 <VibrateStop>
		vibrate_stop_flag = false;
   16c08:	2300      	movs	r3, #0
   16c0a:	7023      	strb	r3, [r4, #0]
	}

	if(read_soc_status)
   16c0c:	4c0f      	ldr	r4, [pc, #60]	; (16c4c <PMUMsgProcess+0x88>)
   16c0e:	7823      	ldrb	r3, [r4, #0]
   16c10:	b11b      	cbz	r3, 16c1a <PMUMsgProcess+0x56>
	{
		test_soc_status();
   16c12:	f7ff fe7d 	bl	16910 <test_soc_status>
		read_soc_status = false;
   16c16:	2300      	movs	r3, #0
   16c18:	7023      	strb	r3, [r4, #0]
	}

	if(pmu_redraw_bat_flag)
   16c1a:	490d      	ldr	r1, [pc, #52]	; (16c50 <PMUMsgProcess+0x8c>)
   16c1c:	780b      	ldrb	r3, [r1, #0]
   16c1e:	b11b      	cbz	r3, 16c28 <PMUMsgProcess+0x64>
	{
		PMURedrawBatStatus();
   16c20:	f7ff ffc0 	bl	16ba4 <PMURedrawBatStatus>
		pmu_redraw_bat_flag = false;
   16c24:	2300      	movs	r3, #0
   16c26:	700b      	strb	r3, [r1, #0]
	}

#ifdef BATTERT_NTC_CHECK
	if(pmu_check_temp_flag)
   16c28:	4c0a      	ldr	r4, [pc, #40]	; (16c54 <PMUMsgProcess+0x90>)
   16c2a:	7823      	ldrb	r3, [r4, #0]
   16c2c:	b11b      	cbz	r3, 16c36 <PMUMsgProcess+0x72>
	MAX20353_UpdateTemper();
   16c2e:	f7f7 f91f 	bl	de70 <MAX20353_UpdateTemper>
	{
		PMUUpdateTempForSOC();
		pmu_check_temp_flag = false;
   16c32:	2300      	movs	r3, #0
   16c34:	7023      	strb	r3, [r4, #0]
	}
#endif
}
   16c36:	bd10      	pop	{r4, pc}
   16c38:	2002ff99 	.word	0x2002ff99
   16c3c:	2002ff97 	.word	0x2002ff97
   16c40:	2002ff9b 	.word	0x2002ff9b
   16c44:	2002ff9c 	.word	0x2002ff9c
   16c48:	2002ff9d 	.word	0x2002ff9d
   16c4c:	2002ff9a 	.word	0x2002ff9a
   16c50:	2003b5cd 	.word	0x2003b5cd
   16c54:	2002ff98 	.word	0x2002ff98

00016c58 <MAX20353_CheckTemper>:

void MAX20353_CheckTemper(void)
{
	pmu_check_temp_flag = true;
   16c58:	2201      	movs	r2, #1
   16c5a:	4b01      	ldr	r3, [pc, #4]	; (16c60 <MAX20353_CheckTemper+0x8>)
   16c5c:	701a      	strb	r2, [r3, #0]
}
   16c5e:	4770      	bx	lr
   16c60:	2002ff98 	.word	0x2002ff98

00016c64 <MAX20353_WriteRegMulti>:
{
   16c64:	b538      	push	{r3, r4, r5, lr}
	ret = pmu_dev_ctx.write_reg(pmu_dev_ctx.handle, reg, value, len);
   16c66:	4c06      	ldr	r4, [pc, #24]	; (16c80 <MAX20353_WriteRegMulti+0x1c>)
   16c68:	4613      	mov	r3, r2
   16c6a:	6825      	ldr	r5, [r4, #0]
   16c6c:	460a      	mov	r2, r1
   16c6e:	4601      	mov	r1, r0
   16c70:	68a0      	ldr	r0, [r4, #8]
   16c72:	47a8      	blx	r5
	if(ret != 0)
   16c74:	3000      	adds	r0, #0
   16c76:	bf18      	it	ne
   16c78:	2001      	movne	r0, #1
}
   16c7a:	4240      	negs	r0, r0
   16c7c:	bd38      	pop	{r3, r4, r5, pc}
   16c7e:	bf00      	nop
   16c80:	200285e0 	.word	0x200285e0

00016c84 <MAX20353_WriteReg>:
{ 
   16c84:	b537      	push	{r0, r1, r2, r4, r5, lr}
	ret = pmu_dev_ctx.write_reg(pmu_dev_ctx.handle, reg, &value, 1);
   16c86:	4c08      	ldr	r4, [pc, #32]	; (16ca8 <MAX20353_WriteReg+0x24>)
{ 
   16c88:	f88d 1007 	strb.w	r1, [sp, #7]
	ret = pmu_dev_ctx.write_reg(pmu_dev_ctx.handle, reg, &value, 1);
   16c8c:	6825      	ldr	r5, [r4, #0]
   16c8e:	4601      	mov	r1, r0
   16c90:	2301      	movs	r3, #1
   16c92:	f10d 0207 	add.w	r2, sp, #7
   16c96:	68a0      	ldr	r0, [r4, #8]
   16c98:	47a8      	blx	r5
	if(ret != 0)
   16c9a:	3000      	adds	r0, #0
   16c9c:	bf18      	it	ne
   16c9e:	2001      	movne	r0, #1
}
   16ca0:	4240      	negs	r0, r0
   16ca2:	b003      	add	sp, #12
   16ca4:	bd30      	pop	{r4, r5, pc}
   16ca6:	bf00      	nop
   16ca8:	200285e0 	.word	0x200285e0

00016cac <MAX20353_ReadReg>:
{
   16cac:	b538      	push	{r3, r4, r5, lr}
	ret = pmu_dev_ctx.read_reg(pmu_dev_ctx.handle, reg, value, 1);
   16cae:	4c06      	ldr	r4, [pc, #24]	; (16cc8 <MAX20353_ReadReg+0x1c>)
   16cb0:	460a      	mov	r2, r1
   16cb2:	6865      	ldr	r5, [r4, #4]
   16cb4:	4601      	mov	r1, r0
   16cb6:	2301      	movs	r3, #1
   16cb8:	68a0      	ldr	r0, [r4, #8]
   16cba:	47a8      	blx	r5
    if(ret != 0)
   16cbc:	3000      	adds	r0, #0
   16cbe:	bf18      	it	ne
   16cc0:	2001      	movne	r0, #1
}
   16cc2:	4240      	negs	r0, r0
   16cc4:	bd38      	pop	{r3, r4, r5, pc}
   16cc6:	bf00      	nop
   16cc8:	200285e0 	.word	0x200285e0

00016ccc <MAX20353_AppWrite>:
{
   16ccc:	b538      	push	{r3, r4, r5, lr}
	ret  = MAX20353_WriteRegMulti(REG_AP_DATOUT0, appdatainoutbuffer_, dataoutlen); ///0x0F
   16cce:	4602      	mov	r2, r0
   16cd0:	490e      	ldr	r1, [pc, #56]	; (16d0c <MAX20353_AppWrite+0x40>)
   16cd2:	200f      	movs	r0, #15
   16cd4:	f7ff ffc6 	bl	16c64 <MAX20353_WriteRegMulti>
   16cd8:	4c0d      	ldr	r4, [pc, #52]	; (16d10 <MAX20353_AppWrite+0x44>)
	ret |= MAX20353_WriteReg(REG_AP_CMDOUT, appcmdoutvalue_); //0x17	
   16cda:	4d0e      	ldr	r5, [pc, #56]	; (16d14 <MAX20353_AppWrite+0x48>)
	ret  = MAX20353_WriteRegMulti(REG_AP_DATOUT0, appdatainoutbuffer_, dataoutlen); ///0x0F
   16cdc:	6020      	str	r0, [r4, #0]
	ret |= MAX20353_WriteReg(REG_AP_CMDOUT, appcmdoutvalue_); //0x17	
   16cde:	7829      	ldrb	r1, [r5, #0]
   16ce0:	2017      	movs	r0, #23
   16ce2:	f7ff ffcf 	bl	16c84 <MAX20353_WriteReg>
   16ce6:	6823      	ldr	r3, [r4, #0]
   16ce8:	4318      	orrs	r0, r3
   16cea:	6020      	str	r0, [r4, #0]
	k_sleep(K_MSEC(10));
   16cec:	200a      	movs	r0, #10
   16cee:	f015 ff7d 	bl	2cbec <k_sleep>
	ret |= MAX20353_ReadReg(REG_AP_RESPONSE, &appcmdoutvalue_);//0x18
   16cf2:	4629      	mov	r1, r5
   16cf4:	2018      	movs	r0, #24
   16cf6:	f7ff ffd9 	bl	16cac <MAX20353_ReadReg>
   16cfa:	6823      	ldr	r3, [r4, #0]
	if(ret != 0)
   16cfc:	4303      	orrs	r3, r0
   16cfe:	bf14      	ite	ne
   16d00:	f04f 30ff 	movne.w	r0, #4294967295
   16d04:	2000      	moveq	r0, #0
   16d06:	6020      	str	r0, [r4, #0]
}
   16d08:	bd38      	pop	{r3, r4, r5, pc}
   16d0a:	bf00      	nop
   16d0c:	2002ffa5 	.word	0x2002ffa5
   16d10:	20028644 	.word	0x20028644
   16d14:	2002ffa4 	.word	0x2002ffa4

00016d18 <MAX20303_HapticConfigDCMotor>:
{
   16d18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	appcmdoutvalue_ = 0xA0;
   16d1a:	23a0      	movs	r3, #160	; 0xa0
   16d1c:	4e24      	ldr	r6, [pc, #144]	; (16db0 <MAX20303_HapticConfigDCMotor+0x98>)
	appdatainoutbuffer_[0] = 0x0A; //0x0F; // EmfEn(resonance detection)/HptSel(ERM)/ALC/ZeroCrossHysteresis
   16d1e:	4c25      	ldr	r4, [pc, #148]	; (16db4 <MAX20303_HapticConfigDCMotor+0x9c>)
	appcmdoutvalue_ = 0xA0;
   16d20:	7033      	strb	r3, [r6, #0]
	appdatainoutbuffer_[0] = 0x0A; //0x0F; // EmfEn(resonance detection)/HptSel(ERM)/ALC/ZeroCrossHysteresis
   16d22:	230a      	movs	r3, #10
   16d24:	7023      	strb	r3, [r4, #0]
	appdatainoutbuffer_[1] = 0xDA; //0x9F; // Initial guess of Back EMF frequency = 25.6M/64/IniGss =235/205; IniGss = 0x6A6/0x79F
   16d26:	23da      	movs	r3, #218	; 0xda
   16d28:	7063      	strb	r3, [r4, #1]
	appdatainoutbuffer_[2] = 0x16; //0x87; // ZccSlowEn=0/FltrCntrEn=0
   16d2a:	2316      	movs	r3, #22
   16d2c:	70a3      	strb	r3, [r4, #2]
	appdatainoutbuffer_[4] = 0x07; //0x05; // Wide Window for BEMF zero crossing
   16d2e:	2307      	movs	r3, #7
	appdatainoutbuffer_[3] = 0x00; //0x00; // Skip periods before BEMF measuring
   16d30:	2700      	movs	r7, #0
	appdatainoutbuffer_[4] = 0x07; //0x05; // Wide Window for BEMF zero crossing
   16d32:	7123      	strb	r3, [r4, #4]
	appdatainoutbuffer_[5] = 0x02; //0x01; // Narrow Window for BEMF zero crossing
   16d34:	2302      	movs	r3, #2
	ret |= MAX20353_AppWrite(6);
   16d36:	2006      	movs	r0, #6
	appdatainoutbuffer_[3] = 0x00; //0x00; // Skip periods before BEMF measuring
   16d38:	70e7      	strb	r7, [r4, #3]
	appdatainoutbuffer_[5] = 0x02; //0x01; // Narrow Window for BEMF zero crossing
   16d3a:	7163      	strb	r3, [r4, #5]
	ret |= MAX20353_AppWrite(6);
   16d3c:	f7ff ffc6 	bl	16ccc <MAX20353_AppWrite>
	appcmdoutvalue_ = 0xA2;
   16d40:	23a2      	movs	r3, #162	; 0xa2
   16d42:	7033      	strb	r3, [r6, #0]
	appdatainoutbuffer_[0] = 0xF0; //0x01; // EmfSkipCyc
   16d44:	23f0      	movs	r3, #240	; 0xf0
   16d46:	7023      	strb	r3, [r4, #0]
	appdatainoutbuffer_[1] = 0x88; //0x00; // BlankWdw, zero corssing comparator blanking time after enable(1/25.6MHz)
   16d48:	2388      	movs	r3, #136	; 0x88
   16d4a:	7063      	strb	r3, [r4, #1]
	appdatainoutbuffer_[4] = 0xE6; //0xE6; // ETRGOdAmp, Overdrive amplitude, LSB = 0.78%VFS, 98%
   16d4c:	23e6      	movs	r3, #230	; 0xe6
	appdatainoutbuffer_[2] = 0x00; //0x02; // BlankWdw, zero corssing comparator blanking time after enable(1/25.6MHz)
   16d4e:	70a7      	strb	r7, [r4, #2]
	appdatainoutbuffer_[4] = 0xE6; //0xE6; // ETRGOdAmp, Overdrive amplitude, LSB = 0.78%VFS, 98%
   16d50:	7123      	strb	r3, [r4, #4]
	appdatainoutbuffer_[3] = 0xFF; //0x5D; // Vpp_Sine_max = 5.65V, Vpp_Square_max = 4V, VFS= Vpp/2 = 2V, Max_VFS = 5.5V, set VFS = 2/5.5*255 = 92 = 0x5C(square), Sine: VFS=2.8/5.5*255=0x82
   16d52:	27ff      	movs	r7, #255	; 0xff
	appdatainoutbuffer_[5] = 0x10; //0x10; // ETRGOdDur, Overdrive period, LSB = 5ms, 80ms
   16d54:	2310      	movs	r3, #16
	ret |= MAX20353_AppWrite(6);
   16d56:	4605      	mov	r5, r0
	ret |= MAX20353_AppWrite(6);
   16d58:	2006      	movs	r0, #6
	appdatainoutbuffer_[5] = 0x10; //0x10; // ETRGOdDur, Overdrive period, LSB = 5ms, 80ms
   16d5a:	7163      	strb	r3, [r4, #5]
	appdatainoutbuffer_[3] = 0xFF; //0x5D; // Vpp_Sine_max = 5.65V, Vpp_Square_max = 4V, VFS= Vpp/2 = 2V, Max_VFS = 5.5V, set VFS = 2/5.5*255 = 92 = 0x5C(square), Sine: VFS=2.8/5.5*255=0x82
   16d5c:	70e7      	strb	r7, [r4, #3]
	ret |= MAX20353_AppWrite(6);
   16d5e:	f7ff ffb5 	bl	16ccc <MAX20353_AppWrite>
	appcmdoutvalue_ = 0xA4;
   16d62:	23a4      	movs	r3, #164	; 0xa4
   16d64:	7033      	strb	r3, [r6, #0]
	appdatainoutbuffer_[0] = 0xC0; //0xC0; // ETRGActAmp, normal amplitude, , LSB = 0.78%VFS, don't care
   16d66:	23c0      	movs	r3, #192	; 0xc0
   16d68:	7023      	strb	r3, [r4, #0]
	appdatainoutbuffer_[2] = 0xCD; //0xCD; // ETRGActAmp, braking amplitude, , LSB = 0.78%VFS, 80*VFS
   16d6a:	23cd      	movs	r3, #205	; 0xcd
   16d6c:	70a3      	strb	r3, [r4, #2]
	appdatainoutbuffer_[3] = 0x14; //0x14; // ETRGActDur, breaking period, LSB = 5ms, 60ms
   16d6e:	2314      	movs	r3, #20
	ret |= MAX20353_AppWrite(6);
   16d70:	4305      	orrs	r5, r0
	appdatainoutbuffer_[3] = 0x14; //0x14; // ETRGActDur, breaking period, LSB = 5ms, 60ms
   16d72:	70e3      	strb	r3, [r4, #3]
	appdatainoutbuffer_[5] = 0x06; //0x00; // periods from wide to narrow
   16d74:	2006      	movs	r0, #6
	appdatainoutbuffer_[4] = 0x23; //0x15; // narrow window gain, wide window gain = 1
   16d76:	2323      	movs	r3, #35	; 0x23
	appdatainoutbuffer_[1] = 0xFF; //0xFF; // ETRGActDur, normal period, LSB = 10ms, don't care
   16d78:	7067      	strb	r7, [r4, #1]
	appdatainoutbuffer_[4] = 0x23; //0x15; // narrow window gain, wide window gain = 1
   16d7a:	7123      	strb	r3, [r4, #4]
	appdatainoutbuffer_[5] = 0x06; //0x00; // periods from wide to narrow
   16d7c:	7160      	strb	r0, [r4, #5]
	ret |= MAX20353_AppWrite(6);
   16d7e:	f7ff ffa5 	bl	16ccc <MAX20353_AppWrite>
	appcmdoutvalue_ = 0xA6;
   16d82:	23a6      	movs	r3, #166	; 0xa6
   16d84:	7033      	strb	r3, [r6, #0]
	appdatainoutbuffer_[0] = 0x4A; //Sys UVLO threshold = 1.6V
   16d86:	234a      	movs	r3, #74	; 0x4a
	ret |= MAX20353_AppWrite(6);
   16d88:	4305      	orrs	r5, r0
	ret |= MAX20353_AppWrite(1);
   16d8a:	2001      	movs	r0, #1
	appdatainoutbuffer_[0] = 0x4A; //Sys UVLO threshold = 1.6V
   16d8c:	7023      	strb	r3, [r4, #0]
	ret |= MAX20353_AppWrite(1);
   16d8e:	f7ff ff9d 	bl	16ccc <MAX20353_AppWrite>
	if(ret != 0)
   16d92:	ea55 0100 	orrs.w	r1, r5, r0
   16d96:	d107      	bne.n	16da8 <MAX20303_HapticConfigDCMotor+0x90>
	ret |= MAX20353_WriteReg( REG_HPT_DIRECT1,  0x00); //hptExtTrig=1, HptRamEn=1, HptDrvEn=1, HptDrvMode=0x12, disable HptDrvEn
   16d98:	2031      	movs	r0, #49	; 0x31
   16d9a:	f7ff ff73 	bl	16c84 <MAX20353_WriteReg>
	if(ret != 0)
   16d9e:	3000      	adds	r0, #0
   16da0:	bf18      	it	ne
   16da2:	2001      	movne	r0, #1
   16da4:	4240      	negs	r0, r0
}
   16da6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return MAX20353_ERROR;
   16da8:	f04f 30ff 	mov.w	r0, #4294967295
   16dac:	e7fb      	b.n	16da6 <MAX20303_HapticConfigDCMotor+0x8e>
   16dae:	bf00      	nop
   16db0:	2002ffa4 	.word	0x2002ffa4
   16db4:	2002ffa5 	.word	0x2002ffa5

00016db8 <MAX20353_Buck1Config>:
    appcmdoutvalue_ = 0x35;
   16db8:	2235      	movs	r2, #53	; 0x35
   16dba:	4b07      	ldr	r3, [pc, #28]	; (16dd8 <MAX20353_Buck1Config+0x20>)
    ret = MAX20353_AppWrite(4);
   16dbc:	2004      	movs	r0, #4
    appcmdoutvalue_ = 0x35;
   16dbe:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x00;  	//
   16dc0:	2200      	movs	r2, #0
   16dc2:	4b06      	ldr	r3, [pc, #24]	; (16ddc <MAX20353_Buck1Config+0x24>)
   16dc4:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[1] = 0x2C;  	//0x28    0.7+(0.025V * number)    0x48*0.025 =1.8v     //0.7V to 2.275V, Linear Scale, 25mV increments
   16dc6:	222c      	movs	r2, #44	; 0x2c
   16dc8:	705a      	strb	r2, [r3, #1]
    appdatainoutbuffer_[2] = 0x1F;  	//0x2F  	01 = 20mA, Use for 1V < Buck1VSet < 1.8V
   16dca:	221f      	movs	r2, #31
   16dcc:	709a      	strb	r2, [r3, #2]
    appdatainoutbuffer_[3] = 0x01;  	// Enable
   16dce:	2201      	movs	r2, #1
   16dd0:	70da      	strb	r2, [r3, #3]
    ret = MAX20353_AppWrite(4);
   16dd2:	f7ff bf7b 	b.w	16ccc <MAX20353_AppWrite>
   16dd6:	bf00      	nop
   16dd8:	2002ffa4 	.word	0x2002ffa4
   16ddc:	2002ffa5 	.word	0x2002ffa5

00016de0 <MAX20353_Buck2Config>:
    appcmdoutvalue_ = 0x3A;
   16de0:	223a      	movs	r2, #58	; 0x3a
    appdatainoutbuffer_[1] = 0x32;     	//0x32    0.7V + (0.05V * number) = 3.3V;
   16de2:	2132      	movs	r1, #50	; 0x32
    appcmdoutvalue_ = 0x3A;
   16de4:	4b05      	ldr	r3, [pc, #20]	; (16dfc <MAX20353_Buck2Config+0x1c>)
    ret = MAX20353_AppWrite(4);
   16de6:	2004      	movs	r0, #4
    appcmdoutvalue_ = 0x3A;
   16de8:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x01;      //
   16dea:	4b05      	ldr	r3, [pc, #20]	; (16e00 <MAX20353_Buck2Config+0x20>)
   16dec:	2201      	movs	r2, #1
    appdatainoutbuffer_[1] = 0x32;     	//0x32    0.7V + (0.05V * number) = 3.3V;
   16dee:	7059      	strb	r1, [r3, #1]
    appdatainoutbuffer_[2] = 0x3F;		//  0x3F 375mA  01 = 20mA, Use for 1V < Buck2VSet < 1.8V
   16df0:	213f      	movs	r1, #63	; 0x3f
    appdatainoutbuffer_[0] = 0x01;      //
   16df2:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[2] = 0x3F;		//  0x3F 375mA  01 = 20mA, Use for 1V < Buck2VSet < 1.8V
   16df4:	7099      	strb	r1, [r3, #2]
    appdatainoutbuffer_[3] = 0x01;		// Enable
   16df6:	70da      	strb	r2, [r3, #3]
    ret = MAX20353_AppWrite(4);
   16df8:	f7ff bf68 	b.w	16ccc <MAX20353_AppWrite>
   16dfc:	2002ffa4 	.word	0x2002ffa4
   16e00:	2002ffa5 	.word	0x2002ffa5

00016e04 <MAX20353_LDO1Config>:
    appcmdoutvalue_ = 0x40;
   16e04:	2240      	movs	r2, #64	; 0x40
   16e06:	4b05      	ldr	r3, [pc, #20]	; (16e1c <MAX20353_LDO1Config+0x18>)
    ret = MAX20353_AppWrite(2);
   16e08:	2002      	movs	r0, #2
    appcmdoutvalue_ = 0x40;
   16e0a:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x01;     //0x01  0.5V to 1.95V, Linear Scale, 25mV increments,   LDO1  
   16e0c:	2201      	movs	r2, #1
   16e0e:	4b04      	ldr	r3, [pc, #16]	; (16e20 <MAX20353_LDO1Config+0x1c>)
   16e10:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[1] = 0x34;     //0x28  0.5V + (0.025V * number)   =  1.95V   1.8
   16e12:	2234      	movs	r2, #52	; 0x34
   16e14:	705a      	strb	r2, [r3, #1]
    ret = MAX20353_AppWrite(2);
   16e16:	f7ff bf59 	b.w	16ccc <MAX20353_AppWrite>
   16e1a:	bf00      	nop
   16e1c:	2002ffa4 	.word	0x2002ffa4
   16e20:	2002ffa5 	.word	0x2002ffa5

00016e24 <MAX20353_LDO2Config>:
    appcmdoutvalue_ = 0x42;
   16e24:	2242      	movs	r2, #66	; 0x42
   16e26:	4b05      	ldr	r3, [pc, #20]	; (16e3c <MAX20353_LDO2Config+0x18>)
    ret = MAX20353_AppWrite(2);
   16e28:	2002      	movs	r0, #2
    appcmdoutvalue_ = 0x42;
   16e2a:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x01;
   16e2c:	2201      	movs	r2, #1
   16e2e:	4b04      	ldr	r3, [pc, #16]	; (16e40 <MAX20353_LDO2Config+0x1c>)
   16e30:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[1] = 0x13;     // 0.9V + (0.1V * number)   =  2.8V 
   16e32:	2213      	movs	r2, #19
   16e34:	705a      	strb	r2, [r3, #1]
    ret = MAX20353_AppWrite(2);
   16e36:	f7ff bf49 	b.w	16ccc <MAX20353_AppWrite>
   16e3a:	bf00      	nop
   16e3c:	2002ffa4 	.word	0x2002ffa4
   16e40:	2002ffa5 	.word	0x2002ffa5

00016e44 <MAX20353_BoostConfig>:
	appcmdoutvalue_ = 0x30;
   16e44:	2230      	movs	r2, #48	; 0x30
   16e46:	4b06      	ldr	r3, [pc, #24]	; (16e60 <MAX20353_BoostConfig+0x1c>)
	ret = MAX20353_AppWrite(4);
   16e48:	2004      	movs	r0, #4
	appcmdoutvalue_ = 0x30;
   16e4a:	701a      	strb	r2, [r3, #0]
	appdatainoutbuffer_[0] = 0x01;
   16e4c:	2201      	movs	r2, #1
   16e4e:	4b05      	ldr	r3, [pc, #20]	; (16e64 <MAX20353_BoostConfig+0x20>)
   16e50:	701a      	strb	r2, [r3, #0]
	appdatainoutbuffer_[1] = 0x00;
   16e52:	2200      	movs	r2, #0
   16e54:	705a      	strb	r2, [r3, #1]
	appdatainoutbuffer_[2] = 0x00;
   16e56:	709a      	strb	r2, [r3, #2]
	appdatainoutbuffer_[3] = 0x00;     // 5V + (0.25V * number); 0x00:5V, 0x3B:20V; EVKIT's cap can only be upto 6.3V
   16e58:	70da      	strb	r2, [r3, #3]
	ret = MAX20353_AppWrite(4);
   16e5a:	f7ff bf37 	b.w	16ccc <MAX20353_AppWrite>
   16e5e:	bf00      	nop
   16e60:	2002ffa4 	.word	0x2002ffa4
   16e64:	2002ffa5 	.word	0x2002ffa5

00016e68 <MAX20353_ChargePumpConfig>:
    appcmdoutvalue_ = 0x46;
   16e68:	2246      	movs	r2, #70	; 0x46
   16e6a:	4b05      	ldr	r3, [pc, #20]	; (16e80 <MAX20353_ChargePumpConfig+0x18>)
    ret = MAX20353_AppWrite(2);
   16e6c:	2002      	movs	r0, #2
    appcmdoutvalue_ = 0x46;
   16e6e:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x01;	// Boost Enabled
   16e70:	2201      	movs	r2, #1
   16e72:	4b04      	ldr	r3, [pc, #16]	; (16e84 <MAX20353_ChargePumpConfig+0x1c>)
   16e74:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[1] = 0x03;	// 00 : 6.5V, 01: 5V
   16e76:	2203      	movs	r2, #3
   16e78:	705a      	strb	r2, [r3, #1]
    ret = MAX20353_AppWrite(2);
   16e7a:	f7ff bf27 	b.w	16ccc <MAX20353_AppWrite>
   16e7e:	bf00      	nop
   16e80:	2002ffa4 	.word	0x2002ffa4
   16e84:	2002ffa5 	.word	0x2002ffa5

00016e88 <MAX20353_BuckBoostConfig>:
    appcmdoutvalue_ = 0x70;
   16e88:	2270      	movs	r2, #112	; 0x70
   16e8a:	4b06      	ldr	r3, [pc, #24]	; (16ea4 <MAX20353_BuckBoostConfig+0x1c>)
    appdatainoutbuffer_[1] = 0x04;
   16e8c:	2004      	movs	r0, #4
    appcmdoutvalue_ = 0x70;
   16e8e:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0x00;
   16e90:	2200      	movs	r2, #0
   16e92:	4b05      	ldr	r3, [pc, #20]	; (16ea8 <MAX20353_BuckBoostConfig+0x20>)
   16e94:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[2] = 0x19;		// 2.5V + (0.1V * number) = 5.0V
   16e96:	2219      	movs	r2, #25
   16e98:	709a      	strb	r2, [r3, #2]
    appdatainoutbuffer_[3] = 0x41;     
   16e9a:	2241      	movs	r2, #65	; 0x41
    appdatainoutbuffer_[1] = 0x04;
   16e9c:	7058      	strb	r0, [r3, #1]
    appdatainoutbuffer_[3] = 0x41;     
   16e9e:	70da      	strb	r2, [r3, #3]
    ret = MAX20353_AppWrite(4);
   16ea0:	f7ff bf14 	b.w	16ccc <MAX20353_AppWrite>
   16ea4:	2002ffa4 	.word	0x2002ffa4
   16ea8:	2002ffa5 	.word	0x2002ffa5

00016eac <MAX20353_PowerOffConfig>:
    appcmdoutvalue_ = 0x80;
   16eac:	2280      	movs	r2, #128	; 0x80
   16eae:	4b04      	ldr	r3, [pc, #16]	; (16ec0 <MAX20353_PowerOffConfig+0x14>)
    ret = MAX20353_AppWrite(1);
   16eb0:	2001      	movs	r0, #1
    appcmdoutvalue_ = 0x80;
   16eb2:	701a      	strb	r2, [r3, #0]
    appdatainoutbuffer_[0] = 0xB2;
   16eb4:	22b2      	movs	r2, #178	; 0xb2
   16eb6:	4b03      	ldr	r3, [pc, #12]	; (16ec4 <MAX20353_PowerOffConfig+0x18>)
   16eb8:	701a      	strb	r2, [r3, #0]
    ret = MAX20353_AppWrite(1);
   16eba:	f7ff bf07 	b.w	16ccc <MAX20353_AppWrite>
   16ebe:	bf00      	nop
   16ec0:	2002ffa4 	.word	0x2002ffa4
   16ec4:	2002ffa5 	.word	0x2002ffa5

00016ec8 <MAX20353_ReadRegMulti>:
{
   16ec8:	b538      	push	{r3, r4, r5, lr}
	ret = pmu_dev_ctx.read_reg(pmu_dev_ctx.handle, reg, value, len);
   16eca:	4c06      	ldr	r4, [pc, #24]	; (16ee4 <MAX20353_ReadRegMulti+0x1c>)
   16ecc:	4613      	mov	r3, r2
   16ece:	6865      	ldr	r5, [r4, #4]
   16ed0:	460a      	mov	r2, r1
   16ed2:	4601      	mov	r1, r0
   16ed4:	68a0      	ldr	r0, [r4, #8]
   16ed6:	47a8      	blx	r5
    if(ret != 0)
   16ed8:	3000      	adds	r0, #0
   16eda:	bf18      	it	ne
   16edc:	2001      	movne	r0, #1
}
   16ede:	4240      	negs	r0, r0
   16ee0:	bd38      	pop	{r3, r4, r5, pc}
   16ee2:	bf00      	nop
   16ee4:	200285e0 	.word	0x200285e0

00016ee8 <MAX20353_AppRead>:
{
   16ee8:	b538      	push	{r3, r4, r5, lr}
	ret = MAX20353_WriteReg(REG_AP_CMDOUT, appcmdoutvalue_);
   16eea:	4b0b      	ldr	r3, [pc, #44]	; (16f18 <MAX20353_AppRead+0x30>)
{
   16eec:	4605      	mov	r5, r0
	ret = MAX20353_WriteReg(REG_AP_CMDOUT, appcmdoutvalue_);
   16eee:	7819      	ldrb	r1, [r3, #0]
   16ef0:	2017      	movs	r0, #23
   16ef2:	f7ff fec7 	bl	16c84 <MAX20353_WriteReg>
   16ef6:	4604      	mov	r4, r0
	k_sleep(K_MSEC(10));
   16ef8:	200a      	movs	r0, #10
   16efa:	f015 fe77 	bl	2cbec <k_sleep>
	ret |= MAX20353_ReadRegMulti(REG_AP_RESPONSE, i2cbuffer_, datainlen);
   16efe:	462a      	mov	r2, r5
   16f00:	4906      	ldr	r1, [pc, #24]	; (16f1c <MAX20353_AppRead+0x34>)
   16f02:	2018      	movs	r0, #24
   16f04:	f7ff ffe0 	bl	16ec8 <MAX20353_ReadRegMulti>
	if(ret != 0)
   16f08:	ea54 0300 	orrs.w	r3, r4, r0
}
   16f0c:	bf14      	ite	ne
   16f0e:	f04f 30ff 	movne.w	r0, #4294967295
   16f12:	2000      	moveq	r0, #0
   16f14:	bd38      	pop	{r3, r4, r5, pc}
   16f16:	bf00      	nop
   16f18:	2002ffa4 	.word	0x2002ffa4
   16f1c:	2002ffad 	.word	0x2002ffad

00016f20 <MAX20353_ChargerCfg>:
	appcmdoutvalue_ = 0x14; 
   16f20:	2214      	movs	r2, #20
   16f22:	4b06      	ldr	r3, [pc, #24]	; (16f3c <MAX20353_ChargerCfg+0x1c>)
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   16f24:	2004      	movs	r0, #4
	appcmdoutvalue_ = 0x14; 
   16f26:	701a      	strb	r2, [r3, #0]
	appdatainoutbuffer_[1] = 0x61; // Precharge to b110:3.0V, b00:0.05IFChg for dead battery, ChgDone b01: 0.1IFChg 
   16f28:	2261      	movs	r2, #97	; 0x61
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   16f2a:	4b05      	ldr	r3, [pc, #20]	; (16f40 <MAX20353_ChargerCfg+0x20>)
	appdatainoutbuffer_[1] = 0x61; // Precharge to b110:3.0V, b00:0.05IFChg for dead battery, ChgDone b01: 0.1IFChg 
   16f2c:	705a      	strb	r2, [r3, #1]
	appdatainoutbuffer_[2] = 0xD6; // Auto Stop, Auto ReStart, ReChg Threshold b01:120mV, Bat Volt b0011: 4.2V, b0110:4.35 
   16f2e:	22d6      	movs	r2, #214	; 0xd6
   16f30:	709a      	strb	r2, [r3, #2]
	appdatainoutbuffer_[3] = 0x07; // System min volt = 4.3V 
   16f32:	2207      	movs	r2, #7
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   16f34:	7018      	strb	r0, [r3, #0]
	appdatainoutbuffer_[3] = 0x07; // System min volt = 4.3V 
   16f36:	70da      	strb	r2, [r3, #3]
	ret |= MAX20353_AppWrite(4);
   16f38:	f7ff bec8 	b.w	16ccc <MAX20353_AppWrite>
   16f3c:	2002ffa4 	.word	0x2002ffa4
   16f40:	2002ffa5 	.word	0x2002ffa5

00016f44 <MAX20353_ChargerCtrl>:
	appcmdoutvalue_ = 0x1A; 
   16f44:	221a      	movs	r2, #26
	appdatainoutbuffer_[0] = 0x01; // Thermal EN, Charger EN 
   16f46:	2001      	movs	r0, #1
	appcmdoutvalue_ = 0x1A; 
   16f48:	4b02      	ldr	r3, [pc, #8]	; (16f54 <MAX20353_ChargerCtrl+0x10>)
   16f4a:	701a      	strb	r2, [r3, #0]
	appdatainoutbuffer_[0] = 0x01; // Thermal EN, Charger EN 
   16f4c:	4b02      	ldr	r3, [pc, #8]	; (16f58 <MAX20353_ChargerCtrl+0x14>)
   16f4e:	7018      	strb	r0, [r3, #0]
	ret |= MAX20353_AppWrite(1); 
   16f50:	f7ff bebc 	b.w	16ccc <MAX20353_AppWrite>
   16f54:	2002ffa4 	.word	0x2002ffa4
   16f58:	2002ffa5 	.word	0x2002ffa5

00016f5c <MAX20353_InputCurCfg>:
	appcmdoutvalue_ = 0x10;
   16f5c:	2210      	movs	r2, #16
   16f5e:	4b04      	ldr	r3, [pc, #16]	; (16f70 <MAX20353_InputCurCfg+0x14>)
	ret = MAX20353_AppWrite(1);
   16f60:	2001      	movs	r0, #1
	appcmdoutvalue_ = 0x10;
   16f62:	701a      	strb	r2, [r3, #0]
	appdatainoutbuffer_[0] = 0x1E;  //500ma(+,F3160ma),10ms
   16f64:	221e      	movs	r2, #30
   16f66:	4b03      	ldr	r3, [pc, #12]	; (16f74 <MAX20353_InputCurCfg+0x18>)
   16f68:	701a      	strb	r2, [r3, #0]
	ret = MAX20353_AppWrite(1);
   16f6a:	f7ff beaf 	b.w	16ccc <MAX20353_AppWrite>
   16f6e:	bf00      	nop
   16f70:	2002ffa4 	.word	0x2002ffa4
   16f74:	2002ffa5 	.word	0x2002ffa5

00016f78 <MAX20353_ChargerInit>:
{
   16f78:	b508      	push	{r3, lr}
	MAX20353_ChargerCfg();
   16f7a:	f7ff ffd1 	bl	16f20 <MAX20353_ChargerCfg>
	MAX20353_ChargerCtrl();
   16f7e:	f7ff ffe1 	bl	16f44 <MAX20353_ChargerCtrl>
	MAX20353_InputCurCfg();
   16f82:	f7ff ffeb 	bl	16f5c <MAX20353_InputCurCfg>
	PMICIntMasks[0] = 0x48;
   16f86:	2348      	movs	r3, #72	; 0x48
   16f88:	4804      	ldr	r0, [pc, #16]	; (16f9c <MAX20353_ChargerInit+0x24>)
   16f8a:	7003      	strb	r3, [r0, #0]
	PMICIntMasks[1] = 0x00;
   16f8c:	2300      	movs	r3, #0
   16f8e:	7043      	strb	r3, [r0, #1]
	PMICIntMasks[2] = 0x00;
   16f90:	7083      	strb	r3, [r0, #2]
}
   16f92:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	MAX20353_EnablePMICIntMaskRegisters(PMICIntMasks);
   16f96:	f015 be4e 	b.w	2cc36 <MAX20353_EnablePMICIntMaskRegisters>
   16f9a:	bf00      	nop
   16f9c:	2002ff9f 	.word	0x2002ff9f

00016fa0 <InitCharger>:
	appcmdoutvalue_ = 0x14; 
   16fa0:	2314      	movs	r3, #20
{ 
   16fa2:	b570      	push	{r4, r5, r6, lr}
	appcmdoutvalue_ = 0x14; 
   16fa4:	4d0a      	ldr	r5, [pc, #40]	; (16fd0 <InitCharger+0x30>)
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   16fa6:	4c0b      	ldr	r4, [pc, #44]	; (16fd4 <InitCharger+0x34>)
	appcmdoutvalue_ = 0x14; 
   16fa8:	702b      	strb	r3, [r5, #0]
	appdatainoutbuffer_[1] = 0x61; // Precharge to b110:3.0V, b00:0.05IFChg for dead battery, ChgDone b01: 0.1IFChg 
   16faa:	2361      	movs	r3, #97	; 0x61
   16fac:	7063      	strb	r3, [r4, #1]
	appdatainoutbuffer_[2] = 0xD6; // Auto Stop, Auto ReStart, ReChg Threshold b01:120mV, Bat Volt b0011: 4.2V, b0110:4.35 
   16fae:	23d6      	movs	r3, #214	; 0xd6
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   16fb0:	2004      	movs	r0, #4
	appdatainoutbuffer_[2] = 0xD6; // Auto Stop, Auto ReStart, ReChg Threshold b01:120mV, Bat Volt b0011: 4.2V, b0110:4.35 
   16fb2:	70a3      	strb	r3, [r4, #2]
	appdatainoutbuffer_[3] = 0x07; // System min volt = 4.3V 
   16fb4:	2307      	movs	r3, #7
	appdatainoutbuffer_[0] = 0x04; // Maintain charge b00:0min, FastCharge b00:150min, for 1C charging, PreCharge b00: 30min for dead battery 
   16fb6:	7020      	strb	r0, [r4, #0]
	appdatainoutbuffer_[3] = 0x07; // System min volt = 4.3V 
   16fb8:	70e3      	strb	r3, [r4, #3]
	ret |= MAX20353_AppWrite(4);
   16fba:	f7ff fe87 	bl	16ccc <MAX20353_AppWrite>
	appcmdoutvalue_ = 0x1A; 
   16fbe:	231a      	movs	r3, #26
	ret |= MAX20353_AppWrite(4);
   16fc0:	4606      	mov	r6, r0
	appdatainoutbuffer_[0] = 0x01; // Thermal EN, Charger EN 
   16fc2:	2001      	movs	r0, #1
	appcmdoutvalue_ = 0x1A; 
   16fc4:	702b      	strb	r3, [r5, #0]
	appdatainoutbuffer_[0] = 0x01; // Thermal EN, Charger EN 
   16fc6:	7020      	strb	r0, [r4, #0]
	ret |= MAX20353_AppWrite(1); 
   16fc8:	f7ff fe80 	bl	16ccc <MAX20353_AppWrite>
}
   16fcc:	4330      	orrs	r0, r6
   16fce:	bd70      	pop	{r4, r5, r6, pc}
   16fd0:	2002ffa4 	.word	0x2002ffa4
   16fd4:	2002ffa5 	.word	0x2002ffa5

00016fd8 <ReadWord>:
{
   16fd8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	msg.len = num_bytes;
   16fdc:	2401      	movs	r4, #1
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   16fde:	2502      	movs	r5, #2
   16fe0:	b087      	sub	sp, #28
	ret = i2c_write(pmu_dev_ctx.handle, &data, sizeof(data), MAX20353_I2C_ADDR_FUEL_GAUGE);
   16fe2:	4e18      	ldr	r6, [pc, #96]	; (17044 <ReadWord+0x6c>)
	msg.buf = (u8_t *)buf;
   16fe4:	f10d 0307 	add.w	r3, sp, #7
	u8_t data = reg;
   16fe8:	f88d 0007 	strb.w	r0, [sp, #7]
{
   16fec:	4688      	mov	r8, r1
   16fee:	4617      	mov	r7, r2
	ret = i2c_write(pmu_dev_ctx.handle, &data, sizeof(data), MAX20353_I2C_ADDR_FUEL_GAUGE);
   16ff0:	68b0      	ldr	r0, [r6, #8]
   16ff2:	9303      	str	r3, [sp, #12]
	msg.len = num_bytes;
   16ff4:	9404      	str	r4, [sp, #16]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   16ff6:	f88d 5014 	strb.w	r5, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   16ffa:	6843      	ldr	r3, [r0, #4]
   16ffc:	4622      	mov	r2, r4
   16ffe:	f8d3 9004 	ldr.w	r9, [r3, #4]
   17002:	a903      	add	r1, sp, #12
   17004:	2336      	movs	r3, #54	; 0x36
   17006:	47c8      	blx	r9
	if(ret != 0)
   17008:	b120      	cbz	r0, 17014 <ReadWord+0x3c>
		return MAX20353_ERROR;
   1700a:	f04f 30ff 	mov.w	r0, #4294967295
}
   1700e:	b007      	add	sp, #28
   17010:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	msg.buf = buf;
   17014:	ab02      	add	r3, sp, #8
	msg.len = num_bytes;
   17016:	e9cd 3503 	strd	r3, r5, [sp, #12]
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
   1701a:	2303      	movs	r3, #3
	ret = i2c_read(pmu_dev_ctx.handle, value, sizeof(value), MAX20353_I2C_ADDR_FUEL_GAUGE);
   1701c:	68b0      	ldr	r0, [r6, #8]
   1701e:	f88d 3014 	strb.w	r3, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   17022:	6843      	ldr	r3, [r0, #4]
   17024:	4622      	mov	r2, r4
   17026:	685d      	ldr	r5, [r3, #4]
   17028:	a903      	add	r1, sp, #12
   1702a:	2336      	movs	r3, #54	; 0x36
   1702c:	47a8      	blx	r5
	if (ret != 0)
   1702e:	2800      	cmp	r0, #0
   17030:	d1eb      	bne.n	1700a <ReadWord+0x32>
	*MSB = value[0];
   17032:	f89d 3008 	ldrb.w	r3, [sp, #8]
   17036:	f888 3000 	strb.w	r3, [r8]
	*LSB = value[1];
   1703a:	f89d 3009 	ldrb.w	r3, [sp, #9]
   1703e:	703b      	strb	r3, [r7, #0]
	return MAX20353_NO_ERROR;
   17040:	e7e5      	b.n	1700e <ReadWord+0x36>
   17042:	bf00      	nop
   17044:	200285e0 	.word	0x200285e0

00017048 <WriteWord>:
{
   17048:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	rslt = i2c_write(pmu_dev_ctx.handle, cmdData, sizeof(cmdData), MAX20353_I2C_ADDR_FUEL_GAUGE);
   1704a:	4b0d      	ldr	r3, [pc, #52]	; (17080 <WriteWord+0x38>)
	u8_t cmdData[3] = {reg, MSB, LSB};
   1704c:	f88d 0000 	strb.w	r0, [sp]
	rslt = i2c_write(pmu_dev_ctx.handle, cmdData, sizeof(cmdData), MAX20353_I2C_ADDR_FUEL_GAUGE);
   17050:	6898      	ldr	r0, [r3, #8]
	msg.len = num_bytes;
   17052:	2303      	movs	r3, #3
   17054:	9302      	str	r3, [sp, #8]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   17056:	2302      	movs	r3, #2
	u8_t cmdData[3] = {reg, MSB, LSB};
   17058:	f88d 1001 	strb.w	r1, [sp, #1]
   1705c:	f88d 2002 	strb.w	r2, [sp, #2]
	msg.buf = (u8_t *)buf;
   17060:	f8cd d004 	str.w	sp, [sp, #4]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   17064:	f88d 300c 	strb.w	r3, [sp, #12]
	return api->transfer(dev, msgs, num_msgs, addr);
   17068:	6843      	ldr	r3, [r0, #4]
   1706a:	2201      	movs	r2, #1
   1706c:	685c      	ldr	r4, [r3, #4]
   1706e:	a901      	add	r1, sp, #4
   17070:	2336      	movs	r3, #54	; 0x36
   17072:	47a0      	blx	r4
	if (rslt != 0)
   17074:	3000      	adds	r0, #0
   17076:	bf18      	it	ne
   17078:	2001      	movne	r0, #1
}
   1707a:	4240      	negs	r0, r0
   1707c:	b004      	add	sp, #16
   1707e:	bd10      	pop	{r4, pc}
   17080:	200285e0 	.word	0x200285e0

00017084 <WriteMulti>:
	ret = i2c_write(pmu_dev_ctx.handle, data, len, MAX20353_I2C_ADDR_FUEL_GAUGE);
   17084:	4b0a      	ldr	r3, [pc, #40]	; (170b0 <WriteMulti+0x2c>)
{
   17086:	b530      	push	{r4, r5, lr}
	ret = i2c_write(pmu_dev_ctx.handle, data, len, MAX20353_I2C_ADDR_FUEL_GAUGE);
   17088:	689c      	ldr	r4, [r3, #8]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   1708a:	2302      	movs	r3, #2
{
   1708c:	b085      	sub	sp, #20
	ret = i2c_write(pmu_dev_ctx.handle, data, len, MAX20353_I2C_ADDR_FUEL_GAUGE);
   1708e:	e9cd 0101 	strd	r0, r1, [sp, #4]
   17092:	f88d 300c 	strb.w	r3, [sp, #12]
	return api->transfer(dev, msgs, num_msgs, addr);
   17096:	6863      	ldr	r3, [r4, #4]
   17098:	2201      	movs	r2, #1
   1709a:	685d      	ldr	r5, [r3, #4]
   1709c:	a901      	add	r1, sp, #4
   1709e:	2336      	movs	r3, #54	; 0x36
   170a0:	4620      	mov	r0, r4
   170a2:	47a8      	blx	r5
	if (ret != 0)
   170a4:	3000      	adds	r0, #0
   170a6:	bf18      	it	ne
   170a8:	2001      	movne	r0, #1
}
   170aa:	4240      	negs	r0, r0
   170ac:	b005      	add	sp, #20
   170ae:	bd30      	pop	{r4, r5, pc}
   170b0:	200285e0 	.word	0x200285e0

000170b4 <MAX20353_ReadTHM>:
{
   170b4:	b530      	push	{r4, r5, lr}
	appdatainoutbuffer_[0] = 0x22; ////4 average, THM
   170b6:	2222      	movs	r2, #34	; 0x22
	appcmdoutvalue_ = 0x53;
   170b8:	2553      	movs	r5, #83	; 0x53
	appdatainoutbuffer_[0] = 0x22; ////4 average, THM
   170ba:	4b13      	ldr	r3, [pc, #76]	; (17108 <MAX20353_ReadTHM+0x54>)
	appcmdoutvalue_ = 0x53;
   170bc:	4c13      	ldr	r4, [pc, #76]	; (1710c <MAX20353_ReadTHM+0x58>)
{
   170be:	b085      	sub	sp, #20
	ret |= MAX20353_AppWrite(1);
   170c0:	2001      	movs	r0, #1
	appdatainoutbuffer_[0] = 0x22; ////4 average, THM
   170c2:	701a      	strb	r2, [r3, #0]
	appcmdoutvalue_ = 0x53;
   170c4:	7025      	strb	r5, [r4, #0]
	ret |= MAX20353_AppWrite(1);
   170c6:	f7ff fe01 	bl	16ccc <MAX20353_AppWrite>
	ret |= MAX20353_AppRead(5);
   170ca:	2005      	movs	r0, #5
	appcmdoutvalue_ = 0x53;
   170cc:	7025      	strb	r5, [r4, #0]
	ret |= MAX20353_AppRead(5);
   170ce:	f7ff ff0b 	bl	16ee8 <MAX20353_AppRead>
	LOG_INF("%02X, %02X, %02X, %02X, %02X\n", i2cbuffer_[0], i2cbuffer_[1], i2cbuffer_[2], i2cbuffer_[3], i2cbuffer_[4]);
   170d2:	2303      	movs	r3, #3
   170d4:	f04f 0000 	mov.w	r0, #0
   170d8:	4a0d      	ldr	r2, [pc, #52]	; (17110 <MAX20353_ReadTHM+0x5c>)
   170da:	f363 0007 	bfi	r0, r3, #0, #8
   170de:	4b0d      	ldr	r3, [pc, #52]	; (17114 <MAX20353_ReadTHM+0x60>)
   170e0:	4c0d      	ldr	r4, [pc, #52]	; (17118 <MAX20353_ReadTHM+0x64>)
   170e2:	1a9b      	subs	r3, r3, r2
   170e4:	08db      	lsrs	r3, r3, #3
   170e6:	f363 108f 	bfi	r0, r3, #6, #10
   170ea:	7923      	ldrb	r3, [r4, #4]
   170ec:	490b      	ldr	r1, [pc, #44]	; (1711c <MAX20353_ReadTHM+0x68>)
   170ee:	9302      	str	r3, [sp, #8]
   170f0:	78e3      	ldrb	r3, [r4, #3]
   170f2:	9301      	str	r3, [sp, #4]
   170f4:	78a3      	ldrb	r3, [r4, #2]
   170f6:	9300      	str	r3, [sp, #0]
   170f8:	7863      	ldrb	r3, [r4, #1]
   170fa:	7822      	ldrb	r2, [r4, #0]
   170fc:	f016 f8fc 	bl	2d2f8 <log_string_sync>
}
   17100:	7920      	ldrb	r0, [r4, #4]
   17102:	b005      	add	sp, #20
   17104:	bd30      	pop	{r4, r5, pc}
   17106:	bf00      	nop
   17108:	2002ffa5 	.word	0x2002ffa5
   1710c:	2002ffa4 	.word	0x2002ffa4
   17110:	0003040c 	.word	0x0003040c
   17114:	000304ac 	.word	0x000304ac
   17118:	2002ffad 	.word	0x2002ffad
   1711c:	00032344 	.word	0x00032344

00017120 <MAX20353_UpdateRCOMP>:
	if(temp>20) // (20, ...) 
   17120:	2814      	cmp	r0, #20
{
   17122:	b510      	push	{r4, lr}
	if(temp>20) // (20, ...) 
   17124:	dd17      	ble.n	17156 <MAX20353_UpdateRCOMP+0x36>
		result = INI_RCOMP + (temp - 20) * used_tempco;
   17126:	3814      	subs	r0, #20
   17128:	ee07 0a90 	vmov	s15, r0
   1712c:	eefe 6a07 	vmov.f32	s13, #231	; 0xbf380000 -0.7187500
   17130:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
		result = INI_RCOMP + (temp - 20) * used_tempco;
   17134:	eef3 7a06 	vmov.f32	s15, #54	; 0x41b00000  22.0
		result = result_0 + (temp - 0) * used_tempco;
   17138:	ee47 7a26 	vmla.f32	s15, s14, s13
   1713c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	RCOMP = (result >= 0xff ? 0xff : (result <= 0 ?  0 : result));
   17140:	ee17 3a90 	vmov	r3, s15
   17144:	f383 0408 	usat	r4, #8, r3
	WriteWord(0x0C, RCOMP, 0x5C);
   17148:	225c      	movs	r2, #92	; 0x5c
   1714a:	b2e1      	uxtb	r1, r4
   1714c:	200c      	movs	r0, #12
   1714e:	f7ff ff7b 	bl	17048 <WriteWord>
}
   17152:	4620      	mov	r0, r4
   17154:	bd10      	pop	{r4, pc}
	else if(temp>0) // {0, 20)
   17156:	2800      	cmp	r0, #0
   17158:	dd07      	ble.n	1716a <MAX20353_UpdateRCOMP+0x4a>
		result = INI_RCOMP + (temp - 20) * used_tempco;
   1715a:	3814      	subs	r0, #20
   1715c:	ee07 0a90 	vmov	s15, r0
   17160:	eef8 6a0f 	vmov.f32	s13, #143	; 0xc0780000 -3.875
   17164:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   17168:	e7e4      	b.n	17134 <MAX20353_UpdateRCOMP+0x14>
		result = result_0 + (temp - 0) * used_tempco;
   1716a:	ee07 0a90 	vmov	s15, r0
   1716e:	eddf 6a03 	vldr	s13, [pc, #12]	; 1717c <MAX20353_UpdateRCOMP+0x5c>
   17172:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
   17176:	eddf 7a02 	vldr	s15, [pc, #8]	; 17180 <MAX20353_UpdateRCOMP+0x60>
   1717a:	e7dd      	b.n	17138 <MAX20353_UpdateRCOMP+0x18>
   1717c:	c07a0000 	.word	0xc07a0000
   17180:	42c60000 	.word	0x42c60000

00017184 <MAX20353_StartCheckTemper>:

void MAX20353_StartCheckTemper(void)
{
   17184:	b510      	push	{r4, lr}
	k_timer_init(&ntc_check_timer, MAX20353_CheckTemper, NULL);
   17186:	4c07      	ldr	r4, [pc, #28]	; (171a4 <MAX20353_StartCheckTemper+0x20>)
   17188:	2200      	movs	r2, #0
   1718a:	4907      	ldr	r1, [pc, #28]	; (171a8 <MAX20353_StartCheckTemper+0x24>)
   1718c:	4620      	mov	r0, r4
   1718e:	f018 f832 	bl	2f1f6 <k_timer_init>
   17192:	f64e 2260 	movw	r2, #60000	; 0xea60
   17196:	4620      	mov	r0, r4
	k_timer_start(&ntc_check_timer, K_MSEC(30*1000), K_MSEC(60*1000));
}
   17198:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1719c:	f247 5130 	movw	r1, #30000	; 0x7530
   171a0:	f012 b850 	b.w	29244 <z_impl_k_timer_start>
   171a4:	20028618 	.word	0x20028618
   171a8:	00016c59 	.word	0x00016c59

000171ac <MAX20353_CalculateSOC>:

#endif/*BATTERT_NTC_CHECK*/

u8_t MAX20353_CalculateSOC(void)
{
   171ac:	b510      	push	{r4, lr}
	u16_t tmp;
	
	ReadWord(0x04, &SOC_1, &SOC_2);
   171ae:	4c04      	ldr	r4, [pc, #16]	; (171c0 <MAX20353_CalculateSOC+0x14>)
   171b0:	4a04      	ldr	r2, [pc, #16]	; (171c4 <MAX20353_CalculateSOC+0x18>)
   171b2:	4621      	mov	r1, r4
   171b4:	2004      	movs	r0, #4
   171b6:	f7ff ff0f 	bl	16fd8 <ReadWord>
		SOC_percent = SOC/512;

	//SOC_percent = 26.5;
	
	return SOC_percent;
}
   171ba:	7820      	ldrb	r0, [r4, #0]
   171bc:	bd10      	pop	{r4, pc}
   171be:	bf00      	nop
   171c0:	2002ffa2 	.word	0x2002ffa2
   171c4:	2002ffa3 	.word	0x2002ffa3

000171c8 <prepare_to_load_model>:
	*/
	delay_ms(250);
}

void prepare_to_load_model(void)
{
   171c8:	b538      	push	{r3, r4, r5, lr}
	Step 2. Read OCV
	The OCV Register will be modified during the process of loading the custom
	model. Read and store this value so that it can be written back to the
	device after the model has been loaded.
	*/
	ReadWord(0x0E, &original_OCV_1, &original_OCV_2);
   171ca:	4c09      	ldr	r4, [pc, #36]	; (171f0 <prepare_to_load_model+0x28>)
   171cc:	4d09      	ldr	r5, [pc, #36]	; (171f4 <prepare_to_load_model+0x2c>)
	WriteWord(0x3E, 0x4A, 0x57);
   171ce:	2257      	movs	r2, #87	; 0x57
   171d0:	214a      	movs	r1, #74	; 0x4a
   171d2:	203e      	movs	r0, #62	; 0x3e
   171d4:	f7ff ff38 	bl	17048 <WriteWord>
	ReadWord(0x0E, &original_OCV_1, &original_OCV_2);
   171d8:	4a05      	ldr	r2, [pc, #20]	; (171f0 <prepare_to_load_model+0x28>)
   171da:	4906      	ldr	r1, [pc, #24]	; (171f4 <prepare_to_load_model+0x2c>)
   171dc:	200e      	movs	r0, #14
   171de:	f7ff fefb 	bl	16fd8 <ReadWord>
	If Model Access was correctly unlocked in Step 1, then the OCV bytes read
	in Step 2 will not be 0xFF. If the values of both bytes are 0xFF,
	that indicates that Model Access was not correctly unlocked and the
	sequence should be repeated from Step 1.
	*/
	if((original_OCV_1 == 0xFF) && (original_OCV_2 == 0xFF))
   171e2:	782b      	ldrb	r3, [r5, #0]
   171e4:	7822      	ldrb	r2, [r4, #0]
   171e6:	4013      	ands	r3, r2
   171e8:	2bff      	cmp	r3, #255	; 0xff
   171ea:	d0f0      	beq.n	171ce <prepare_to_load_model+0x6>
	Step 4. Write RCOMP to its Maximum Value (MAX17040/1/3/4 only)
	Make the fuel-gauge respond as slowly as possible (MSB = 0xFF), and disable
	alerts during model loading (LSB = 0x00)
	*/
	//WriteWord(0x0C, 0xFF, 0x00);
}
   171ec:	bd38      	pop	{r3, r4, r5, pc}
   171ee:	bf00      	nop
   171f0:	2002ffbe 	.word	0x2002ffbe
   171f4:	2002ffbd 	.word	0x2002ffbd

000171f8 <load_model>:

void load_model(void)
{
   171f8:	b570      	push	{r4, r5, r6, lr}
   171fa:	b09a      	sub	sp, #104	; 0x68
	u8_t databuf[10] = {0};
	u8_t addr_mem;
	u32_t RCOMPSeg = RCOMPSEG;
	unsigned char RCOMPSeg_MSB = (RCOMPSeg >> 8) & 0xFF;
	unsigned char RCOMPSeg_LSB = RCOMPSeg & 0xFF;	
	u8_t model_data[65] = 
   171fc:	2241      	movs	r2, #65	; 0x41
   171fe:	490e      	ldr	r1, [pc, #56]	; (17238 <load_model+0x40>)
   17200:	a809      	add	r0, sp, #36	; 0x24
   17202:	f018 f8a7 	bl	2f354 <memcpy>
		0xD7,0x50,0x00,0x80,0x08,0xE0,0x12,0x80,0x0F,0xE0,
		0x15,0xC0,0x12,0xC0,0x19,0xE0,0x12,0xF0,0x0C,0xF0,
		0x09,0xE0,0x09,0x30,0x08,0x80,0x07,0xE0,0x09,0x00,
		0x06,0x10,0x06,0x10
	};
	u8_t RCOMP_data[33] = // 1+16*2, first byte is the memory address
   17206:	466a      	mov	r2, sp
   17208:	4615      	mov	r5, r2
   1720a:	4b0c      	ldr	r3, [pc, #48]	; (1723c <load_model+0x44>)
   1720c:	f103 0620 	add.w	r6, r3, #32
   17210:	4614      	mov	r4, r2
   17212:	6818      	ldr	r0, [r3, #0]
   17214:	6859      	ldr	r1, [r3, #4]
   17216:	3308      	adds	r3, #8
   17218:	c403      	stmia	r4!, {r0, r1}
   1721a:	42b3      	cmp	r3, r6
   1721c:	4622      	mov	r2, r4
   1721e:	d1f7      	bne.n	17210 <load_model+0x18>
   17220:	781b      	ldrb	r3, [r3, #0]
	{
		pmu_dev_ctx.write_reg(pmu_dev_ctx.handle, addr_mem, &model_data[k], 1);
		addr_mem++;
	}
	*/
	WriteMulti(model_data, sizeof(model_data));
   17222:	2141      	movs	r1, #65	; 0x41
	u8_t RCOMP_data[33] = // 1+16*2, first byte is the memory address
   17224:	7023      	strb	r3, [r4, #0]
	WriteMulti(model_data, sizeof(model_data));
   17226:	a809      	add	r0, sp, #36	; 0x24
   17228:	f7ff ff2c 	bl	17084 <WriteMulti>
		pmu_dev_ctx.write_reg(pmu_dev_ctx.handle, addr_mem, databuf, 2);
		addr_mem+2;
	}
	*/
	/* I2C STOP */
	WriteMulti(RCOMP_data, sizeof(RCOMP_data));
   1722c:	2121      	movs	r1, #33	; 0x21
   1722e:	4628      	mov	r0, r5
   17230:	f7ff ff28 	bl	17084 <WriteMulti>
}
   17234:	b01a      	add	sp, #104	; 0x68
   17236:	bd70      	pop	{r4, r5, r6, pc}
   17238:	000306c8 	.word	0x000306c8
   1723c:	00030709 	.word	0x00030709

00017240 <verify_model_is_correct>:

bool verify_model_is_correct(void)
{
   17240:	b510      	push	{r4, lr}
	
	/******************************************************************************
	Step 7. Write OCV
	This OCV should produce the SOC_Check values in Step 9
	*/
	WriteWord(0x0E, INI_OCVTEST_HIGH_BYTE, INI_OCVTEST_LOW_BYTE);
   17242:	2250      	movs	r2, #80	; 0x50
   17244:	21e1      	movs	r1, #225	; 0xe1
   17246:	200e      	movs	r0, #14
   17248:	f7ff fefe 	bl	17048 <WriteWord>
	/******************************************************************************
	Step 7.1 Disable Hibernate (MAX17048/49 only)
	The IC updates SOC less frequently in hibernate mode, so make sure it
	is not hibernating
	*/
	WriteWord(0x0A, 0, 0);
   1724c:	2200      	movs	r2, #0
   1724e:	200a      	movs	r0, #10
   17250:	4611      	mov	r1, r2
   17252:	f7ff fef9 	bl	17048 <WriteWord>
	Step 7.2. Lock Model Access (MAX17048/49/58/59 only)
	To allow the ModelGauge algorithm to run in MAX17048/49/58/59 only, the model
	must
	be locked. This is harmless but unnecessary for MAX17040/1/3/4
	*/
	WriteWord(0x3E, 0, 0);
   17256:	2200      	movs	r2, #0
	register is verified to be within a specified range to verify that the
	model was loaded correctly. This value is not an indication of the state of
	the actual battery. Please note that INI_SOCCheckA and INI_SOCCheckB has a
	fixed LSB of 1/256% for both 18 and 19 bit models.
	*/
	ReadWord(0x04, &SOC_1, &SOC_2);
   17258:	4c0a      	ldr	r4, [pc, #40]	; (17284 <verify_model_is_correct+0x44>)
	WriteWord(0x3E, 0, 0);
   1725a:	4611      	mov	r1, r2
   1725c:	203e      	movs	r0, #62	; 0x3e
   1725e:	f7ff fef3 	bl	17048 <WriteWord>
    k_sleep(K_MSEC(period));
   17262:	f44f 7096 	mov.w	r0, #300	; 0x12c
   17266:	f015 fcc1 	bl	2cbec <k_sleep>
	ReadWord(0x04, &SOC_1, &SOC_2);
   1726a:	4a07      	ldr	r2, [pc, #28]	; (17288 <verify_model_is_correct+0x48>)
   1726c:	4621      	mov	r1, r4
   1726e:	2004      	movs	r0, #4
   17270:	f7ff feb2 	bl	16fd8 <ReadWord>
	if(SOC_1 >= SOCCHECKA && SOC_1 <= SOCCHECKB)
   17274:	7820      	ldrb	r0, [r4, #0]
   17276:	3872      	subs	r0, #114	; 0x72
	else
	{
		// model was NOT loaded successfully
		return false;
	}
}
   17278:	2802      	cmp	r0, #2
   1727a:	bf8c      	ite	hi
   1727c:	2000      	movhi	r0, #0
   1727e:	2001      	movls	r0, #1
   17280:	bd10      	pop	{r4, pc}
   17282:	bf00      	nop
   17284:	2002ffa2 	.word	0x2002ffa2
   17288:	2002ffa3 	.word	0x2002ffa3

0001728c <cleanup_model_load>:

void cleanup_model_load(void)
{
   1728c:	b508      	push	{r3, lr}
	/******************************************************************************
	Step 9.1. Unlock Model Access (MAX17048/49/58/59 only)
	To write OCV, MAX17048/49/58/59 requires model access to be unlocked.
	*/
	WriteWord(0x3E, 0x4A, 0x57);
   1728e:	2257      	movs	r2, #87	; 0x57
   17290:	214a      	movs	r1, #74	; 0x4a
   17292:	203e      	movs	r0, #62	; 0x3e
   17294:	f7ff fed8 	bl	17048 <WriteWord>
	/******************************************************************************
	Step 10. Restore CONFIG and OCV
	It is up to the application how to configure the LSB of the CONFIG
	register; any byte value is valid.
	*/
	WriteWord(0x0C, RCOMP0, 0x5C);
   17298:	225c      	movs	r2, #92	; 0x5c
   1729a:	2116      	movs	r1, #22
   1729c:	200c      	movs	r0, #12
   1729e:	f7ff fed3 	bl	17048 <WriteWord>
	WriteWord(0x0E, original_OCV_1, original_OCV_2);
   172a2:	4b0b      	ldr	r3, [pc, #44]	; (172d0 <cleanup_model_load+0x44>)
   172a4:	200e      	movs	r0, #14
   172a6:	781a      	ldrb	r2, [r3, #0]
   172a8:	4b0a      	ldr	r3, [pc, #40]	; (172d4 <cleanup_model_load+0x48>)
   172aa:	7819      	ldrb	r1, [r3, #0]
   172ac:	f7ff fecc 	bl	17048 <WriteWord>
	Step 10.1 Restore Hibernate (MAX17048/49 only)
	Remember to restore your desired Hibernate configuration after the
	model was verified.
	*/
	// Restore your desired value of HIBRT
	WriteWord(0x0A, 0x80, 0x30);
   172b0:	2230      	movs	r2, #48	; 0x30
   172b2:	2180      	movs	r1, #128	; 0x80
   172b4:	200a      	movs	r0, #10
   172b6:	f7ff fec7 	bl	17048 <WriteWord>
	
	/******************************************************************************
	Step 11. Lock Model Access
	*/
	WriteWord(0x3E, 0x00, 0x00);
   172ba:	2200      	movs	r2, #0
   172bc:	203e      	movs	r0, #62	; 0x3e
   172be:	4611      	mov	r1, r2
   172c0:	f7ff fec2 	bl	17048 <WriteWord>
	*/
	//if(SOC < SOCCHECKA)
	//	model was loaded successfully
	//else
	//	goto step C1 and reload model
}
   172c4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    k_sleep(K_MSEC(period));
   172c8:	f44f 7096 	mov.w	r0, #300	; 0x12c
   172cc:	f015 bc8e 	b.w	2cbec <k_sleep>
   172d0:	2002ffbe 	.word	0x2002ffbe
   172d4:	2002ffbd 	.word	0x2002ffbd

000172d8 <MAX20353_Init>:
{
   172d8:	b510      	push	{r4, lr}
	MAX20353_GetDeviceID(&HardwareID);
   172da:	4c0f      	ldr	r4, [pc, #60]	; (17318 <MAX20353_Init+0x40>)
   172dc:	4620      	mov	r0, r4
   172de:	f015 fcbc 	bl	2cc5a <MAX20353_GetDeviceID>
	if(HardwareID != MAX20353_HARDWARE_ID)
   172e2:	7823      	ldrb	r3, [r4, #0]
   172e4:	2b03      	cmp	r3, #3
   172e6:	d115      	bne.n	17314 <MAX20353_Init+0x3c>
	MAX20353_Buck1Config();	//1.8v  350mA
   172e8:	f7ff fd66 	bl	16db8 <MAX20353_Buck1Config>
	MAX20353_Buck2Config(); //3.3V  350mA
   172ec:	f7ff fd78 	bl	16de0 <MAX20353_Buck2Config>
	MAX20353_LDO1Config();	//1.8v 50mA
   172f0:	f7ff fd88 	bl	16e04 <MAX20353_LDO1Config>
	MAX20353_LDO2Config();	//2.8V 100mA
   172f4:	f7ff fd96 	bl	16e24 <MAX20353_LDO2Config>
	MAX20353_BoostConfig(); //5V buck23.3VPPG
   172f8:	f7ff fda4 	bl	16e44 <MAX20353_BoostConfig>
	MAX20353_ChargePumpConfig();
   172fc:	f7ff fdb4 	bl	16e68 <MAX20353_ChargePumpConfig>
	MAX20353_BuckBoostConfig();
   17300:	f7ff fdc2 	bl	16e88 <MAX20353_BuckBoostConfig>
	MAX20303_HapticConfigDCMotor();
   17304:	f7ff fd08 	bl	16d18 <MAX20303_HapticConfigDCMotor>
	MAX20353_SOCInit();
   17308:	f015 fcc9 	bl	2cc9e <MAX20353_SOCInit>
}
   1730c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	MAX20353_ChargerInit();
   17310:	f7ff be32 	b.w	16f78 <MAX20353_ChargerInit>
}
   17314:	bd10      	pop	{r4, pc}
   17316:	bf00      	nop
   17318:	2002ff9e 	.word	0x2002ff9e

0001731c <APP_Ask_wifi_Data_timerout>:

static void APP_Ask_wifi_Data_timerout(struct k_timer *timer_id);
K_TIMER_DEFINE(wifi_scan_timer, APP_Ask_wifi_Data_timerout, NULL);

static void APP_Ask_wifi_Data_timerout(struct k_timer *timer_id)
{
   1731c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if(sos_wait_wifi)
   17320:	4c17      	ldr	r4, [pc, #92]	; (17380 <APP_Ask_wifi_Data_timerout+0x64>)
{
   17322:	b0a6      	sub	sp, #152	; 0x98
	if(sos_wait_wifi)
   17324:	7823      	ldrb	r3, [r4, #0]
   17326:	b193      	cbz	r3, 1734e <APP_Ask_wifi_Data_timerout+0x32>
	{
		sos_get_wifi_data_reply(wifi_data);	
   17328:	4916      	ldr	r1, [pc, #88]	; (17384 <APP_Ask_wifi_Data_timerout+0x68>)
   1732a:	2296      	movs	r2, #150	; 0x96
   1732c:	f8d1 8000 	ldr.w	r8, [r1]
   17330:	688e      	ldr	r6, [r1, #8]
   17332:	68cd      	ldr	r5, [r1, #12]
   17334:	684f      	ldr	r7, [r1, #4]
   17336:	4668      	mov	r0, sp
   17338:	3110      	adds	r1, #16
   1733a:	f018 f80b 	bl	2f354 <memcpy>
   1733e:	462b      	mov	r3, r5
   17340:	4640      	mov	r0, r8
   17342:	4639      	mov	r1, r7
   17344:	4632      	mov	r2, r6
   17346:	f000 f883 	bl	17450 <sos_get_wifi_data_reply>
		sos_wait_wifi = false;
   1734a:	2300      	movs	r3, #0
   1734c:	7023      	strb	r3, [r4, #0]
	}

	if(fall_wait_wifi)
   1734e:	4c0e      	ldr	r4, [pc, #56]	; (17388 <APP_Ask_wifi_Data_timerout+0x6c>)
   17350:	7823      	ldrb	r3, [r4, #0]
   17352:	b193      	cbz	r3, 1737a <APP_Ask_wifi_Data_timerout+0x5e>
	{
		fall_get_wifi_data_reply(wifi_data);	
   17354:	490b      	ldr	r1, [pc, #44]	; (17384 <APP_Ask_wifi_Data_timerout+0x68>)
   17356:	2296      	movs	r2, #150	; 0x96
   17358:	f8d1 8000 	ldr.w	r8, [r1]
   1735c:	688e      	ldr	r6, [r1, #8]
   1735e:	68cd      	ldr	r5, [r1, #12]
   17360:	684f      	ldr	r7, [r1, #4]
   17362:	4668      	mov	r0, sp
   17364:	3110      	adds	r1, #16
   17366:	f017 fff5 	bl	2f354 <memcpy>
   1736a:	462b      	mov	r3, r5
   1736c:	4640      	mov	r0, r8
   1736e:	4639      	mov	r1, r7
   17370:	4632      	mov	r2, r6
   17372:	f7fd ffad 	bl	152d0 <fall_get_wifi_data_reply>
		fall_wait_wifi = false;
   17376:	2300      	movs	r3, #0
   17378:	7023      	strb	r3, [r4, #0]
	}
}
   1737a:	b026      	add	sp, #152	; 0x98
   1737c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   17380:	2002ffc1 	.word	0x2002ffc1
   17384:	2002ffc2 	.word	0x2002ffc2
   17388:	2002ffc0 	.word	0x2002ffc0

0001738c <APP_Ask_wifi_data>:
{

}

void APP_Ask_wifi_data(void)
{
   1738c:	b530      	push	{r4, r5, lr}
   1738e:	b087      	sub	sp, #28
	u8_t i;
	u8_t *str_mac[6] = {"94:77:2b:24:22:6c","7c:94:2a:39:9f:50","7c:94:2a:39:9f:54","","",""};
   17390:	466c      	mov	r4, sp
   17392:	4d13      	ldr	r5, [pc, #76]	; (173e0 <APP_Ask_wifi_data+0x54>)
   17394:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   17396:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   17398:	e895 0003 	ldmia.w	r5, {r0, r1}
	{
		app_wifi_on = true;
		k_timer_start(&wifi_scan_timer, K_MSEC(1*60*1000), NULL);	
	}
#else
	wifi_data.count = 3;
   1739c:	2303      	movs	r3, #3
   1739e:	2500      	movs	r5, #0
	u8_t *str_mac[6] = {"94:77:2b:24:22:6c","7c:94:2a:39:9f:50","7c:94:2a:39:9f:54","","",""};
   173a0:	e884 0003 	stmia.w	r4, {r0, r1}
	wifi_data.count = 3;
   173a4:	4c0f      	ldr	r4, [pc, #60]	; (173e4 <APP_Ask_wifi_data+0x58>)
   173a6:	7023      	strb	r3, [r4, #0]
	for(i=0;i<wifi_data.count;i++)
	{
		wifi_data.node[i].rssi = -(50+i);
   173a8:	b2eb      	uxtb	r3, r5
   173aa:	eb03 1043 	add.w	r0, r3, r3, lsl #5
   173ae:	1822      	adds	r2, r4, r0
   173b0:	f1c5 01ce 	rsb	r1, r5, #206	; 0xce
   173b4:	7051      	strb	r1, [r2, #1]
		strcpy(wifi_data.node[i].mac, str_mac[i]);
   173b6:	aa06      	add	r2, sp, #24
   173b8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   173bc:	3002      	adds	r0, #2
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
   173be:	f853 1c18 	ldr.w	r1, [r3, #-24]
   173c2:	4420      	add	r0, r4
   173c4:	f018 f967 	bl	2f696 <strcpy>
   173c8:	3501      	adds	r5, #1
	for(i=0;i<wifi_data.count;i++)
   173ca:	7822      	ldrb	r2, [r4, #0]
   173cc:	b2eb      	uxtb	r3, r5
   173ce:	429a      	cmp	r2, r3
   173d0:	d8ea      	bhi.n	173a8 <APP_Ask_wifi_data+0x1c>
	}

	APP_Ask_wifi_Data_timerout(NULL);
   173d2:	2000      	movs	r0, #0
#endif	
}
   173d4:	b007      	add	sp, #28
   173d6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	APP_Ask_wifi_Data_timerout(NULL);
   173da:	f7ff bf9f 	b.w	1731c <APP_Ask_wifi_Data_timerout>
   173de:	bf00      	nop
   173e0:	00030598 	.word	0x00030598
   173e4:	2002ffc2 	.word	0x2002ffc2

000173e8 <SOSTimerOutCallBack>:
{
   173e8:	b538      	push	{r3, r4, r5, lr}
	if(screen_id == SCREEN_ID_SOS)
   173ea:	4d15      	ldr	r5, [pc, #84]	; (17440 <SOSTimerOutCallBack+0x58>)
   173ec:	782a      	ldrb	r2, [r5, #0]
   173ee:	2a07      	cmp	r2, #7
   173f0:	d125      	bne.n	1743e <SOSTimerOutCallBack+0x56>
		switch(sos_state)
   173f2:	4c14      	ldr	r4, [pc, #80]	; (17444 <SOSTimerOutCallBack+0x5c>)
   173f4:	7823      	ldrb	r3, [r4, #0]
   173f6:	3b01      	subs	r3, #1
   173f8:	2b03      	cmp	r3, #3
   173fa:	d805      	bhi.n	17408 <SOSTimerOutCallBack+0x20>
   173fc:	e8df f003 	tbb	[pc, r3]
   17400:	1a1a1802 	.word	0x1a1a1802
			sos_state = SOS_STATUS_SENT;
   17404:	2302      	movs	r3, #2
			sos_state = SOS_STATUS_RECEIVED;
   17406:	7023      	strb	r3, [r4, #0]
		scr_msg[screen_id].para |= SCREEN_EVENT_UPDATE_SOS;
   17408:	782a      	ldrb	r2, [r5, #0]
   1740a:	4b0f      	ldr	r3, [pc, #60]	; (17448 <SOSTimerOutCallBack+0x60>)
   1740c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   17410:	685a      	ldr	r2, [r3, #4]
   17412:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   17416:	605a      	str	r2, [r3, #4]
		scr_msg[screen_id].act = SCREEN_ACTION_UPDATE;
   17418:	2202      	movs	r2, #2
   1741a:	705a      	strb	r2, [r3, #1]
		if(sos_state != SOS_STATUS_IDLE)
   1741c:	7823      	ldrb	r3, [r4, #0]
   1741e:	b173      	cbz	r3, 1743e <SOSTimerOutCallBack+0x56>
}
   17420:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   17424:	2200      	movs	r2, #0
   17426:	f241 3188 	movw	r1, #5000	; 0x1388
   1742a:	4808      	ldr	r0, [pc, #32]	; (1744c <SOSTimerOutCallBack+0x64>)
   1742c:	f011 bf0a 	b.w	29244 <z_impl_k_timer_start>
			sos_state = SOS_STATUS_RECEIVED;
   17430:	2303      	movs	r3, #3
   17432:	e7e8      	b.n	17406 <SOSTimerOutCallBack+0x1e>
			sos_state = SOS_STATUS_IDLE;
   17434:	2300      	movs	r3, #0
   17436:	7023      	strb	r3, [r4, #0]
			ExitNotifyScreen();
   17438:	f7fe ff88 	bl	1634c <ExitNotifyScreen>
			break;
   1743c:	e7e4      	b.n	17408 <SOSTimerOutCallBack+0x20>
}
   1743e:	bd38      	pop	{r3, r4, r5, pc}
   17440:	2002ff93 	.word	0x2002ff93
   17444:	20030068 	.word	0x20030068
   17448:	20028540 	.word	0x20028540
   1744c:	2003b7ec 	.word	0x2003b7ec

00017450 <sos_get_wifi_data_reply>:
{
   17450:	b084      	sub	sp, #16
   17452:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17456:	b0e2      	sub	sp, #392	; 0x188
   17458:	ac68      	add	r4, sp, #416	; 0x1a0
   1745a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	u8_t reply[256] = {0};
   1745e:	f44f 7280 	mov.w	r2, #256	; 0x100
   17462:	2100      	movs	r1, #0
   17464:	a822      	add	r0, sp, #136	; 0x88
   17466:	f017 ff95 	bl	2f394 <memset>
	u8_t tmpbuf[128] = {0};
   1746a:	2280      	movs	r2, #128	; 0x80
   1746c:	2100      	movs	r1, #0
   1746e:	a802      	add	r0, sp, #8
   17470:	f017 ff90 	bl	2f394 <memset>
	if(wifi_data.count > 0)
   17474:	f89d 61a0 	ldrb.w	r6, [sp, #416]	; 0x1a0
   17478:	2e00      	cmp	r6, #0
   1747a:	d03a      	beq.n	174f2 <sos_get_wifi_data_reply+0xa2>
		strcat(reply, "3,");
   1747c:	f44f 7280 	mov.w	r2, #256	; 0x100
   17480:	4922      	ldr	r1, [pc, #136]	; (1750c <sos_get_wifi_data_reply+0xbc>)
   17482:	a822      	add	r0, sp, #136	; 0x88
   17484:	f018 f8e2 	bl	2f64c <__strcat_chk>
		for(i=0;i<wifi_data.count;i++)
   17488:	2400      	movs	r4, #0
			strcat(reply, "&");
   1748a:	4f21      	ldr	r7, [pc, #132]	; (17510 <sos_get_wifi_data_reply+0xc0>)
			sprintf(tmpbuf, "%d", wifi_data.node[i].rssi);
   1748c:	f8df 8088 	ldr.w	r8, [pc, #136]	; 17518 <sos_get_wifi_data_reply+0xc8>
   17490:	f50d 75d1 	add.w	r5, sp, #418	; 0x1a2
			strcat(reply, wifi_data.node[i].mac);
   17494:	f44f 7280 	mov.w	r2, #256	; 0x100
   17498:	4629      	mov	r1, r5
   1749a:	a822      	add	r0, sp, #136	; 0x88
   1749c:	f018 f8d6 	bl	2f64c <__strcat_chk>
			strcat(reply, "&");
   174a0:	f44f 7280 	mov.w	r2, #256	; 0x100
   174a4:	4639      	mov	r1, r7
   174a6:	a822      	add	r0, sp, #136	; 0x88
   174a8:	f018 f8d0 	bl	2f64c <__strcat_chk>
			sprintf(tmpbuf, "%d", wifi_data.node[i].rssi);
   174ac:	f915 3c01 	ldrsb.w	r3, [r5, #-1]
   174b0:	2280      	movs	r2, #128	; 0x80
   174b2:	9300      	str	r3, [sp, #0]
   174b4:	2100      	movs	r1, #0
   174b6:	4643      	mov	r3, r8
   174b8:	a802      	add	r0, sp, #8
   174ba:	f018 f8ad 	bl	2f618 <__sprintf_chk>
			strcat(reply, tmpbuf);
   174be:	f44f 7280 	mov.w	r2, #256	; 0x100
   174c2:	a902      	add	r1, sp, #8
   174c4:	a822      	add	r0, sp, #136	; 0x88
   174c6:	f018 f8c1 	bl	2f64c <__strcat_chk>
			strcat(reply, "&");
   174ca:	f44f 7280 	mov.w	r2, #256	; 0x100
   174ce:	4639      	mov	r1, r7
   174d0:	a822      	add	r0, sp, #136	; 0x88
   174d2:	f018 f8bb 	bl	2f64c <__strcat_chk>
			if(i < (wifi_data.count-1))
   174d6:	1e73      	subs	r3, r6, #1
   174d8:	42a3      	cmp	r3, r4
   174da:	d905      	bls.n	174e8 <sos_get_wifi_data_reply+0x98>
				strcat(reply, "|");
   174dc:	f44f 7280 	mov.w	r2, #256	; 0x100
   174e0:	490c      	ldr	r1, [pc, #48]	; (17514 <sos_get_wifi_data_reply+0xc4>)
   174e2:	a822      	add	r0, sp, #136	; 0x88
   174e4:	f018 f8b2 	bl	2f64c <__strcat_chk>
		for(i=0;i<wifi_data.count;i++)
   174e8:	3401      	adds	r4, #1
   174ea:	42a6      	cmp	r6, r4
   174ec:	f105 0521 	add.w	r5, r5, #33	; 0x21
   174f0:	d8d0      	bhi.n	17494 <sos_get_wifi_data_reply+0x44>
	NBSendSosWifiData(reply, strlen(reply));
   174f2:	a822      	add	r0, sp, #136	; 0x88
   174f4:	f7f5 fd30 	bl	cf58 <strlen>
   174f8:	4601      	mov	r1, r0
   174fa:	a822      	add	r0, sp, #136	; 0x88
   174fc:	f7fc fe00 	bl	14100 <NBSendSosWifiData>
}
   17500:	b062      	add	sp, #392	; 0x188
   17502:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   17506:	b004      	add	sp, #16
   17508:	4770      	bx	lr
   1750a:	bf00      	nop
   1750c:	000320ab 	.word	0x000320ab
   17510:	000320ae 	.word	0x000320ae
   17514:	000320b0 	.word	0x000320b0
   17518:	00033e5f 	.word	0x00033e5f

0001751c <SOSStart>:
	sos_trigger_flag = true;
}

void SOSStart(void)
{
	LOG_INF("[%s]\n", __func__);
   1751c:	2303      	movs	r3, #3
   1751e:	f04f 0000 	mov.w	r0, #0
{
   17522:	b510      	push	{r4, lr}
	//sos_state = SOS_STATUS_SENDING;
	//EnterSOSScreen();

	GetSystemTimeSecStrings(sos_trigger_time);

	sos_wait_wifi = true;
   17524:	2401      	movs	r4, #1
	LOG_INF("[%s]\n", __func__);
   17526:	f363 0007 	bfi	r0, r3, #0, #8
   1752a:	4a0e      	ldr	r2, [pc, #56]	; (17564 <SOSStart+0x48>)
   1752c:	4b0e      	ldr	r3, [pc, #56]	; (17568 <SOSStart+0x4c>)
   1752e:	490f      	ldr	r1, [pc, #60]	; (1756c <SOSStart+0x50>)
   17530:	1a9b      	subs	r3, r3, r2
   17532:	08db      	lsrs	r3, r3, #3
   17534:	4a0e      	ldr	r2, [pc, #56]	; (17570 <SOSStart+0x54>)
   17536:	f363 108f 	bfi	r0, r3, #6, #10
   1753a:	f015 fedd 	bl	2d2f8 <log_string_sync>
	GetSystemTimeSecStrings(sos_trigger_time);
   1753e:	480d      	ldr	r0, [pc, #52]	; (17574 <SOSStart+0x58>)
   17540:	f7f9 f860 	bl	10604 <GetSystemTimeSecStrings>
	sos_wait_wifi = true;
   17544:	4b0c      	ldr	r3, [pc, #48]	; (17578 <SOSStart+0x5c>)
   17546:	701c      	strb	r4, [r3, #0]
	APP_Ask_wifi_data();
   17548:	f7ff ff20 	bl	1738c <APP_Ask_wifi_data>
	sos_wait_gps = true;
   1754c:	4b0b      	ldr	r3, [pc, #44]	; (1757c <SOSStart+0x60>)
   1754e:	701c      	strb	r4, [r3, #0]
	APP_Ask_GPS_Data();
   17550:	f7f5 fdca 	bl	d0e8 <APP_Ask_GPS_Data>

	k_timer_start(&sos_timer, K_SECONDS(SOS_SENDING_TIMEOUT), NULL);
}
   17554:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   17558:	2200      	movs	r2, #0
   1755a:	f241 3188 	movw	r1, #5000	; 0x1388
   1755e:	4808      	ldr	r0, [pc, #32]	; (17580 <SOSStart+0x64>)
   17560:	f011 be70 	b.w	29244 <z_impl_k_timer_start>
   17564:	0003040c 	.word	0x0003040c
   17568:	0003050c 	.word	0x0003050c
   1756c:	00032427 	.word	0x00032427
   17570:	0003242d 	.word	0x0003242d
   17574:	2003006a 	.word	0x2003006a
   17578:	2002ffc1 	.word	0x2002ffc1
   1757c:	2002fc71 	.word	0x2002fc71
   17580:	2003b7ec 	.word	0x2003b7ec

00017584 <SOSMsgProc>:

void SOSMsgProc(void)
{
   17584:	b510      	push	{r4, lr}
	if(sos_trigger_flag)
   17586:	4c04      	ldr	r4, [pc, #16]	; (17598 <SOSMsgProc+0x14>)
   17588:	7823      	ldrb	r3, [r4, #0]
   1758a:	b11b      	cbz	r3, 17594 <SOSMsgProc+0x10>
	{
		SOSStart();
   1758c:	f7ff ffc6 	bl	1751c <SOSStart>
		sos_trigger_flag = false;
   17590:	2300      	movs	r3, #0
   17592:	7023      	strb	r3, [r4, #0]
	}
}
   17594:	bd10      	pop	{r4, pc}
   17596:	bf00      	nop
   17598:	20030069 	.word	0x20030069

0001759c <crc8_ccitt>:
	0x00, 0x07, 0x0e, 0x09, 0x1c, 0x1b, 0x12, 0x15,
	0x38, 0x3f, 0x36, 0x31, 0x24, 0x23, 0x2a, 0x2d
};

u8_t crc8_ccitt(u8_t val, const void *buf, size_t cnt)
{
   1759c:	b510      	push	{r4, lr}
	int i;
	const u8_t *p = buf;

	for (i = 0; i < cnt; i++) {
		val ^= p[i];
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
   1759e:	4c09      	ldr	r4, [pc, #36]	; (175c4 <crc8_ccitt+0x28>)
   175a0:	440a      	add	r2, r1
	for (i = 0; i < cnt; i++) {
   175a2:	4291      	cmp	r1, r2
   175a4:	d100      	bne.n	175a8 <crc8_ccitt+0xc>
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
	}
	return val;
}
   175a6:	bd10      	pop	{r4, pc}
		val ^= p[i];
   175a8:	f811 3b01 	ldrb.w	r3, [r1], #1
   175ac:	4043      	eors	r3, r0
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
   175ae:	0918      	lsrs	r0, r3, #4
   175b0:	5c20      	ldrb	r0, [r4, r0]
   175b2:	ea80 1003 	eor.w	r0, r0, r3, lsl #4
   175b6:	b2c3      	uxtb	r3, r0
		val = (val << 4) ^ crc8_ccitt_small_table[val >> 4];
   175b8:	0918      	lsrs	r0, r3, #4
   175ba:	5c20      	ldrb	r0, [r4, r0]
   175bc:	ea80 1003 	eor.w	r0, r0, r3, lsl #4
   175c0:	b2c0      	uxtb	r0, r0
   175c2:	e7ee      	b.n	175a2 <crc8_ccitt+0x6>
   175c4:	00032456 	.word	0x00032456

000175c8 <z_sys_mem_pool_block_free>:
	return 0;
}

void z_sys_mem_pool_block_free(struct sys_mem_pool_base *p, u32_t level,
			      u32_t block)
{
   175c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   175cc:	b085      	sub	sp, #20
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   175ce:	7a83      	ldrb	r3, [r0, #10]
{
   175d0:	af00      	add	r7, sp, #0
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   175d2:	009b      	lsls	r3, r3, #2
   175d4:	3307      	adds	r3, #7
   175d6:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
   175da:	ebad 0d03 	sub.w	sp, sp, r3
   175de:	46eb      	mov	fp, sp
	 * to avoid having to store it in precious RAM bytes.
	 * Overhead here is somewhat higher because block_free()
	 * doesn't inherently need to traverse all the larger
	 * sublevels.
	 */
	lsizes[0] = p->max_sz;
   175e0:	6843      	ldr	r3, [r0, #4]
{
   175e2:	4606      	mov	r6, r0
	lsizes[0] = p->max_sz;
   175e4:	465c      	mov	r4, fp
	for (i = 1; i <= level; i++) {
   175e6:	2001      	movs	r0, #1
	lsizes[0] = p->max_sz;
   175e8:	f8cb 3000 	str.w	r3, [fp]
	for (i = 1; i <= level; i++) {
   175ec:	4281      	cmp	r1, r0
   175ee:	d222      	bcs.n	17636 <z_sys_mem_pool_block_free+0x6e>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   175f0:	7c30      	ldrb	r0, [r6, #16]
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
	}

	block_free(p, level, lsizes, block);
   175f2:	4688      	mov	r8, r1
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   175f4:	f010 0001 	ands.w	r0, r0, #1
	block_free(p, level, lsizes, block);
   175f8:	4615      	mov	r5, r2
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   175fa:	d001      	beq.n	17600 <z_sys_mem_pool_block_free+0x38>
   175fc:	f015 fb9d 	bl	2cd3a <pool_irq_lock.isra.2.part.3>
	unsigned int key = pool_irq_lock(p);
   17600:	4604      	mov	r4, r0
	while (level >= 0) {
   17602:	f1b8 0f00 	cmp.w	r8, #0
   17606:	da1e      	bge.n	17646 <z_sys_mem_pool_block_free+0x7e>
	__ASSERT(0, "out of levels");
   17608:	23bc      	movs	r3, #188	; 0xbc
   1760a:	4a50      	ldr	r2, [pc, #320]	; (1774c <z_sys_mem_pool_block_free+0x184>)
   1760c:	4950      	ldr	r1, [pc, #320]	; (17750 <z_sys_mem_pool_block_free+0x188>)
   1760e:	4851      	ldr	r0, [pc, #324]	; (17754 <z_sys_mem_pool_block_free+0x18c>)
   17610:	f015 fe1b 	bl	2d24a <printk>
   17614:	4850      	ldr	r0, [pc, #320]	; (17758 <z_sys_mem_pool_block_free+0x190>)
   17616:	f015 fe18 	bl	2d24a <printk>
   1761a:	21bc      	movs	r1, #188	; 0xbc
   1761c:	484b      	ldr	r0, [pc, #300]	; (1774c <z_sys_mem_pool_block_free+0x184>)
   1761e:	f015 fe5a 	bl	2d2d6 <assert_post_action>
	return -1;
   17622:	f04f 34ff 	mov.w	r4, #4294967295
	pool_irq_unlock(p, key);
   17626:	4621      	mov	r1, r4
   17628:	7c30      	ldrb	r0, [r6, #16]
   1762a:	f015 fb8f 	bl	2cd4c <pool_irq_unlock.isra.4>
}
   1762e:	3714      	adds	r7, #20
   17630:	46bd      	mov	sp, r7
   17632:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
   17636:	6823      	ldr	r3, [r4, #0]
	for (i = 1; i <= level; i++) {
   17638:	3001      	adds	r0, #1
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
   1763a:	089b      	lsrs	r3, r3, #2
   1763c:	f023 0303 	bic.w	r3, r3, #3
   17640:	f844 3f04 	str.w	r3, [r4, #4]!
   17644:	e7d2      	b.n	175ec <z_sys_mem_pool_block_free+0x24>
		int i, lsz = lsizes[level];
   17646:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
	int bit = get_bit_ptr(p, level, bn, &word);
   1764a:	462a      	mov	r2, r5
	return (u8_t *)p->buf + lsz * block;
   1764c:	fb03 fa05 	mul.w	sl, r3, r5
		int i, lsz = lsizes[level];
   17650:	607b      	str	r3, [r7, #4]
	return (u8_t *)p->buf + lsz * block;
   17652:	6833      	ldr	r3, [r6, #0]
	int bit = get_bit_ptr(p, level, bn, &word);
   17654:	4641      	mov	r1, r8
	return (u8_t *)p->buf + lsz * block;
   17656:	603b      	str	r3, [r7, #0]
   17658:	eb03 090a 	add.w	r9, r3, sl
	int bit = get_bit_ptr(p, level, bn, &word);
   1765c:	4630      	mov	r0, r6
   1765e:	f107 030c 	add.w	r3, r7, #12
   17662:	f015 fb53 	bl	2cd0c <get_bit_ptr>
	return (*word >> bit) & 1;
   17666:	68fb      	ldr	r3, [r7, #12]
   17668:	681b      	ldr	r3, [r3, #0]
   1766a:	fa23 f000 	lsr.w	r0, r3, r0
		__ASSERT(alloc_bit_is_set(p, level, bn),
   1766e:	07c3      	lsls	r3, r0, #31
   17670:	d40d      	bmi.n	1768e <z_sys_mem_pool_block_free+0xc6>
   17672:	23a3      	movs	r3, #163	; 0xa3
   17674:	4a35      	ldr	r2, [pc, #212]	; (1774c <z_sys_mem_pool_block_free+0x184>)
   17676:	4939      	ldr	r1, [pc, #228]	; (1775c <z_sys_mem_pool_block_free+0x194>)
   17678:	4836      	ldr	r0, [pc, #216]	; (17754 <z_sys_mem_pool_block_free+0x18c>)
   1767a:	f015 fde6 	bl	2d24a <printk>
   1767e:	4649      	mov	r1, r9
   17680:	4837      	ldr	r0, [pc, #220]	; (17760 <z_sys_mem_pool_block_free+0x198>)
   17682:	f015 fde2 	bl	2d24a <printk>
   17686:	21a3      	movs	r1, #163	; 0xa3
   17688:	4830      	ldr	r0, [pc, #192]	; (1774c <z_sys_mem_pool_block_free+0x184>)
   1768a:	f015 fe24 	bl	2d2d6 <assert_post_action>
	int bit = get_bit_ptr(p, level, bn, &word);
   1768e:	f107 030c 	add.w	r3, r7, #12
   17692:	462a      	mov	r2, r5
   17694:	4641      	mov	r1, r8
   17696:	4630      	mov	r0, r6
   17698:	f015 fb38 	bl	2cd0c <get_bit_ptr>
	*word &= ~(1<<bit);
   1769c:	2301      	movs	r3, #1
   1769e:	68fa      	ldr	r2, [r7, #12]
   176a0:	fa03 f000 	lsl.w	r0, r3, r0
   176a4:	6813      	ldr	r3, [r2, #0]
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
   176a6:	6839      	ldr	r1, [r7, #0]
   176a8:	ea23 0300 	bic.w	r3, r3, r0
   176ac:	6013      	str	r3, [r2, #0]
		sys_dlist_append(&p->levels[level].free_list, block);
   176ae:	230c      	movs	r3, #12
   176b0:	68f2      	ldr	r2, [r6, #12]
   176b2:	fb03 2308 	mla	r3, r3, r8, r2
   176b6:	1d1a      	adds	r2, r3, #4
   176b8:	f841 200a 	str.w	r2, [r1, sl]
	node->prev = list->tail;
   176bc:	689a      	ldr	r2, [r3, #8]
		pool_irq_unlock(p, key);
   176be:	4621      	mov	r1, r4
   176c0:	f8c9 2004 	str.w	r2, [r9, #4]

	list->tail->next = node;
   176c4:	689a      	ldr	r2, [r3, #8]
   176c6:	f8c2 9000 	str.w	r9, [r2]
	list->tail = node;
   176ca:	f8c3 9008 	str.w	r9, [r3, #8]
   176ce:	7c30      	ldrb	r0, [r6, #16]
   176d0:	f015 fb3c 	bl	2cd4c <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   176d4:	7c30      	ldrb	r0, [r6, #16]
   176d6:	f010 0001 	ands.w	r0, r0, #1
   176da:	d001      	beq.n	176e0 <z_sys_mem_pool_block_free+0x118>
   176dc:	f015 fb2d 	bl	2cd3a <pool_irq_lock.isra.2.part.3>
		key = pool_irq_lock(p);
   176e0:	4604      	mov	r4, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
   176e2:	f1b8 0f00 	cmp.w	r8, #0
   176e6:	d09e      	beq.n	17626 <z_sys_mem_pool_block_free+0x5e>
	int bit = get_bit_ptr(p, level, bn, &word);
   176e8:	f107 030c 	add.w	r3, r7, #12
   176ec:	462a      	mov	r2, r5
   176ee:	4641      	mov	r1, r8
   176f0:	4630      	mov	r0, r6
   176f2:	f015 fb0b 	bl	2cd0c <get_bit_ptr>
	return (*word >> (4*(bit / 4))) & 0xf;
   176f6:	68fb      	ldr	r3, [r7, #12]
   176f8:	2800      	cmp	r0, #0
   176fa:	bfb8      	it	lt
   176fc:	3003      	addlt	r0, #3
   176fe:	681b      	ldr	r3, [r3, #0]
   17700:	f020 0003 	bic.w	r0, r0, #3
   17704:	fa23 f000 	lsr.w	r0, r3, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
   17708:	f010 000f 	ands.w	r0, r0, #15
   1770c:	d18b      	bne.n	17626 <z_sys_mem_pool_block_free+0x5e>
	node->next = NULL;
   1770e:	4684      	mov	ip, r0
			int b = (bn & ~3) + i;
   17710:	f025 0a03 	bic.w	sl, r5, #3
	return (u8_t *)p->buf + lsz * block;
   17714:	687a      	ldr	r2, [r7, #4]
			int b = (bn & ~3) + i;
   17716:	eb0a 0300 	add.w	r3, sl, r0
	return (u8_t *)p->buf + lsz * block;
   1771a:	4353      	muls	r3, r2
   1771c:	6832      	ldr	r2, [r6, #0]
		for (i = 0; i < 4; i++) {
   1771e:	3001      	adds	r0, #1
	return (u8_t *)p->buf + lsz * block;
   17720:	18d1      	adds	r1, r2, r3
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
   17722:	f8d1 9004 	ldr.w	r9, [r1, #4]
   17726:	f852 e003 	ldr.w	lr, [r2, r3]
		for (i = 0; i < 4; i++) {
   1772a:	2804      	cmp	r0, #4
   1772c:	f8c9 e000 	str.w	lr, [r9]
	node->next->prev = node->prev;
   17730:	f8ce 9004 	str.w	r9, [lr, #4]
	node->next = NULL;
   17734:	f842 c003 	str.w	ip, [r2, r3]
	node->prev = NULL;
   17738:	f8c1 c004 	str.w	ip, [r1, #4]
   1773c:	d1ea      	bne.n	17714 <z_sys_mem_pool_block_free+0x14c>
		bn = bn / 4;
   1773e:	2d00      	cmp	r5, #0
   17740:	bfb8      	it	lt
   17742:	3503      	addlt	r5, #3
		level = level - 1;
   17744:	f108 38ff 	add.w	r8, r8, #4294967295
		bn = bn / 4;
   17748:	10ad      	asrs	r5, r5, #2
   1774a:	e75a      	b.n	17602 <z_sys_mem_pool_block_free+0x3a>
   1774c:	00032466 	.word	0x00032466
   17750:	0003495a 	.word	0x0003495a
   17754:	000311a3 	.word	0x000311a3
   17758:	000324ce 	.word	0x000324ce
   1775c:	0003248a 	.word	0x0003248a
   17760:	000324a9 	.word	0x000324a9

00017764 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
   17764:	680b      	ldr	r3, [r1, #0]
   17766:	3301      	adds	r3, #1
   17768:	600b      	str	r3, [r1, #0]
	return _char_out(c);
   1776a:	4b01      	ldr	r3, [pc, #4]	; (17770 <char_out+0xc>)
   1776c:	681b      	ldr	r3, [r3, #0]
   1776e:	4718      	bx	r3
   17770:	20038298 	.word	0x20038298

00017774 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
   17774:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17778:	b085      	sub	sp, #20
   1777a:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   1777c:	469b      	mov	fp, r3
   1777e:	2c01      	cmp	r4, #1
   17780:	bfb8      	it	lt
   17782:	2401      	movlt	r4, #1
   17784:	2b01      	cmp	r3, #1
   17786:	bf0c      	ite	eq
   17788:	2330      	moveq	r3, #48	; 0x30
   1778a:	2320      	movne	r3, #32
   1778c:	4616      	mov	r6, r2
   1778e:	4682      	mov	sl, r0
   17790:	4688      	mov	r8, r1
   17792:	2501      	movs	r5, #1
   17794:	270a      	movs	r7, #10
   17796:	2200      	movs	r2, #0
   17798:	f8df 906c 	ldr.w	r9, [pc, #108]	; 17808 <_printk_dec_ulong+0x94>
   1779c:	9302      	str	r3, [sp, #8]
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
   1779e:	fbb6 f3f9 	udiv	r3, r6, r9
   177a2:	9301      	str	r3, [sp, #4]
   177a4:	b90a      	cbnz	r2, 177aa <_printk_dec_ulong+0x36>
   177a6:	45b1      	cmp	r9, r6
   177a8:	d81c      	bhi.n	177e4 <_printk_dec_ulong+0x70>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
   177aa:	9b01      	ldr	r3, [sp, #4]
   177ac:	4641      	mov	r1, r8
   177ae:	f103 0030 	add.w	r0, r3, #48	; 0x30
   177b2:	47d0      	blx	sl
			found_largest_digit = 1;
   177b4:	2201      	movs	r2, #1
			digits++;
   177b6:	3501      	adds	r5, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= pos;
   177b8:	9b01      	ldr	r3, [sp, #4]
		remaining--;
   177ba:	3f01      	subs	r7, #1
		remainder %= pos;
   177bc:	fb09 6613 	mls	r6, r9, r3, r6
		pos /= 10;
   177c0:	230a      	movs	r3, #10
	while (pos >= 10) {
   177c2:	2f01      	cmp	r7, #1
		pos /= 10;
   177c4:	fbb9 f9f3 	udiv	r9, r9, r3
	while (pos >= 10) {
   177c8:	d1e9      	bne.n	1779e <_printk_dec_ulong+0x2a>
	}
	out((int)(remainder + 48), ctx);
   177ca:	4641      	mov	r1, r8
   177cc:	f106 0030 	add.w	r0, r6, #48	; 0x30
   177d0:	47d0      	blx	sl

	if (padding == PAD_SPACE_AFTER) {
   177d2:	f1bb 0f03 	cmp.w	fp, #3
   177d6:	d102      	bne.n	177de <_printk_dec_ulong+0x6a>
		remaining = min_width - digits;
   177d8:	1b64      	subs	r4, r4, r5
		while (remaining-- > 0) {
   177da:	2c00      	cmp	r4, #0
   177dc:	dc0e      	bgt.n	177fc <_printk_dec_ulong+0x88>
			out(' ', ctx);
		}
	}
}
   177de:	b005      	add	sp, #20
   177e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
   177e4:	42bc      	cmp	r4, r7
   177e6:	dbe7      	blt.n	177b8 <_printk_dec_ulong+0x44>
				&& padding < PAD_SPACE_AFTER) {
   177e8:	f1bb 0f02 	cmp.w	fp, #2
   177ec:	d8e4      	bhi.n	177b8 <_printk_dec_ulong+0x44>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
   177ee:	4641      	mov	r1, r8
   177f0:	9802      	ldr	r0, [sp, #8]
   177f2:	9203      	str	r2, [sp, #12]
			digits++;
   177f4:	3501      	adds	r5, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
   177f6:	47d0      	blx	sl
			digits++;
   177f8:	9a03      	ldr	r2, [sp, #12]
   177fa:	e7dd      	b.n	177b8 <_printk_dec_ulong+0x44>
			out(' ', ctx);
   177fc:	4641      	mov	r1, r8
   177fe:	2020      	movs	r0, #32
   17800:	47d0      	blx	sl
   17802:	3c01      	subs	r4, #1
   17804:	e7e9      	b.n	177da <_printk_dec_ulong+0x66>
   17806:	bf00      	nop
   17808:	3b9aca00 	.word	0x3b9aca00

0001780c <vprintk>:
	struct out_context ctx = { 0 };
   1780c:	2300      	movs	r3, #0
{
   1780e:	b507      	push	{r0, r1, r2, lr}
	z_vprintk(char_out, &ctx, fmt, ap);
   17810:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
   17812:	9301      	str	r3, [sp, #4]
	z_vprintk(char_out, &ctx, fmt, ap);
   17814:	4803      	ldr	r0, [pc, #12]	; (17824 <vprintk+0x18>)
   17816:	460b      	mov	r3, r1
   17818:	a901      	add	r1, sp, #4
   1781a:	f015 fba6 	bl	2cf6a <z_vprintk>
}
   1781e:	b003      	add	sp, #12
   17820:	f85d fb04 	ldr.w	pc, [sp], #4
   17824:	00017765 	.word	0x00017765

00017828 <nordicsemi_nrf91_init>:
	__asm__ volatile(
   17828:	f04f 0220 	mov.w	r2, #32
   1782c:	f3ef 8311 	mrs	r3, BASEPRI
   17830:	f382 8811 	msr	BASEPRI, r2
   17834:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
   17838:	2101      	movs	r1, #1
   1783a:	4a04      	ldr	r2, [pc, #16]	; (1784c <nordicsemi_nrf91_init+0x24>)
   1783c:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
   17840:	f383 8811 	msr	BASEPRI, r3
   17844:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
   17848:	2000      	movs	r0, #0
   1784a:	4770      	bx	lr
   1784c:	40039000 	.word	0x40039000

00017850 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   17850:	b120      	cbz	r0, 1785c <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   17852:	4b03      	ldr	r3, [pc, #12]	; (17860 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
   17854:	0180      	lsls	r0, r0, #6
   17856:	f043 0301 	orr.w	r3, r3, #1
   1785a:	4718      	bx	r3

void arch_busy_wait(u32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
   1785c:	4770      	bx	lr
   1785e:	bf00      	nop
   17860:	00030730 	.word	0x00030730

00017864 <log_generic>:
	if (_is_user_context()) {
		log_generic_from_user(src_level, fmt, ap);
	} else  if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) &&
	    (!IS_ENABLED(CONFIG_LOG_FRONTEND))) {
		struct log_backend const *backend;
		u32_t timestamp = timestamp_func();
   17864:	4b13      	ldr	r3, [pc, #76]	; (178b4 <log_generic+0x50>)
{
   17866:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		u32_t timestamp = timestamp_func();
   1786a:	681b      	ldr	r3, [r3, #0]
{
   1786c:	4680      	mov	r8, r0
   1786e:	4689      	mov	r9, r1
   17870:	4692      	mov	sl, r2
		u32_t timestamp = timestamp_func();
   17872:	4798      	blx	r3

		for (int i = 0; i < log_backend_count_get(); i++) {
   17874:	2600      	movs	r6, #0
		u32_t timestamp = timestamp_func();
   17876:	4607      	mov	r7, r0
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
   17878:	4c0f      	ldr	r4, [pc, #60]	; (178b8 <log_generic+0x54>)
   1787a:	4d10      	ldr	r5, [pc, #64]	; (178bc <log_generic+0x58>)
   1787c:	1b2d      	subs	r5, r5, r4
   1787e:	112d      	asrs	r5, r5, #4
		for (int i = 0; i < log_backend_count_get(); i++) {
   17880:	42ae      	cmp	r6, r5
   17882:	db02      	blt.n	1788a <log_generic+0x26>
			args[i] = va_arg(ap, log_arg_t);
		}

		log_n(fmt, args, nargs, src_level);
	}
}
   17884:	b003      	add	sp, #12
   17886:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (log_backend_is_active(backend)) {
   1788a:	4620      	mov	r0, r4
   1788c:	f015 fd2d 	bl	2d2ea <log_backend_is_active>
   17890:	b160      	cbz	r0, 178ac <log_generic+0x48>
	if (backend->api->put_sync_string) {
   17892:	6823      	ldr	r3, [r4, #0]
   17894:	f8d3 b004 	ldr.w	fp, [r3, #4]
   17898:	f1bb 0f00 	cmp.w	fp, #0
   1789c:	d006      	beq.n	178ac <log_generic+0x48>
		backend->api->put_sync_string(backend, src_level,
   1789e:	f8cd a000 	str.w	sl, [sp]
   178a2:	464b      	mov	r3, r9
   178a4:	463a      	mov	r2, r7
   178a6:	4641      	mov	r1, r8
   178a8:	4620      	mov	r0, r4
   178aa:	47d8      	blx	fp
		for (int i = 0; i < log_backend_count_get(); i++) {
   178ac:	3601      	adds	r6, #1
   178ae:	3410      	adds	r4, #16
   178b0:	e7e6      	b.n	17880 <log_generic+0x1c>
   178b2:	bf00      	nop
   178b4:	2003829c 	.word	0x2003829c
   178b8:	0003054c 	.word	0x0003054c
   178bc:	0003055c 	.word	0x0003055c

000178c0 <log_core_init>:
	/* Set default timestamp. */
	if (sys_clock_hw_cycles_per_sec() > 1000000) {
		timestamp_func = k_uptime_get_32;
		freq = 1000;
	} else {
		timestamp_func = k_cycle_get_32_wrapper;
   178c0:	4b03      	ldr	r3, [pc, #12]	; (178d0 <log_core_init+0x10>)
   178c2:	4a04      	ldr	r2, [pc, #16]	; (178d4 <log_core_init+0x14>)
		freq = sys_clock_hw_cycles_per_sec();
	}

	log_output_timestamp_freq_set(freq);
   178c4:	f44f 4000 	mov.w	r0, #32768	; 0x8000
		timestamp_func = k_cycle_get_32_wrapper;
   178c8:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
   178ca:	f000 ba35 	b.w	17d38 <log_output_timestamp_freq_set>
   178ce:	bf00      	nop
   178d0:	2003829c 	.word	0x2003829c
   178d4:	0002d2f1 	.word	0x0002d2f1

000178d8 <log_source_name_get>:
   178d8:	4a04      	ldr	r2, [pc, #16]	; (178ec <log_source_name_get+0x14>)
   178da:	4b05      	ldr	r3, [pc, #20]	; (178f0 <log_source_name_get+0x18>)
   178dc:	1a9b      	subs	r3, r3, r2
	return log_sources_count();
}

const char *log_source_name_get(u32_t domain_id, u32_t src_id)
{
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
   178de:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
   178e2:	bf34      	ite	cc
   178e4:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
   178e8:	2000      	movcs	r0, #0
}
   178ea:	4770      	bx	lr
   178ec:	0003040c 	.word	0x0003040c
   178f0:	0003054c 	.word	0x0003054c

000178f4 <log_backend_enable>:
}

void log_backend_enable(struct log_backend const *const backend,
			void *ctx,
			u32_t level)
{
   178f4:	b570      	push	{r4, r5, r6, lr}
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	u32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
   178f6:	4c10      	ldr	r4, [pc, #64]	; (17938 <log_backend_enable+0x44>)
{
   178f8:	4605      	mov	r5, r0
	id += backend - log_backend_get(0);
   178fa:	1b04      	subs	r4, r0, r4
   178fc:	1124      	asrs	r4, r4, #4
   178fe:	3401      	adds	r4, #1
{
   17900:	460e      	mov	r6, r1

	log_backend_id_set(backend, id);
   17902:	b2e4      	uxtb	r4, r4
	__ASSERT_NO_MSG(backend != NULL);
   17904:	b948      	cbnz	r0, 1791a <log_backend_enable+0x26>
   17906:	490d      	ldr	r1, [pc, #52]	; (1793c <log_backend_enable+0x48>)
   17908:	480d      	ldr	r0, [pc, #52]	; (17940 <log_backend_enable+0x4c>)
   1790a:	23c0      	movs	r3, #192	; 0xc0
   1790c:	4a0d      	ldr	r2, [pc, #52]	; (17944 <log_backend_enable+0x50>)
   1790e:	f015 fc9c 	bl	2d24a <printk>
   17912:	21c0      	movs	r1, #192	; 0xc0
   17914:	480b      	ldr	r0, [pc, #44]	; (17944 <log_backend_enable+0x50>)
   17916:	f015 fcde 	bl	2d2d6 <assert_post_action>
static inline void log_backend_activate(const struct log_backend *const backend,
					void *ctx)
{
	__ASSERT_NO_MSG(backend != NULL);
	backend->cb->ctx = ctx;
	backend->cb->active = true;
   1791a:	2201      	movs	r2, #1
	backend->cb->id = id;
   1791c:	686b      	ldr	r3, [r5, #4]
   1791e:	711c      	strb	r4, [r3, #4]
	log_backend_activate(backend, ctx);

	/* Wakeup logger thread after attaching first backend. It might be
	 * blocked with log messages pending.
	 */
	if (!backend_attached) {
   17920:	4c09      	ldr	r4, [pc, #36]	; (17948 <log_backend_enable+0x54>)
	backend->cb->active = true;
   17922:	715a      	strb	r2, [r3, #5]
   17924:	7822      	ldrb	r2, [r4, #0]
	backend->cb->ctx = ctx;
   17926:	601e      	str	r6, [r3, #0]
   17928:	b912      	cbnz	r2, 17930 <log_backend_enable+0x3c>
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
   1792a:	4808      	ldr	r0, [pc, #32]	; (1794c <log_backend_enable+0x58>)
   1792c:	f010 fdde 	bl	284ec <z_impl_k_sem_give>
		k_sem_give(&log_process_thread_sem);
	}

	backend_attached = true;
   17930:	2301      	movs	r3, #1
   17932:	7023      	strb	r3, [r4, #0]
}
   17934:	bd70      	pop	{r4, r5, r6, pc}
   17936:	bf00      	nop
   17938:	0003054c 	.word	0x0003054c
   1793c:	0003251c 	.word	0x0003251c
   17940:	000311a3 	.word	0x000311a3
   17944:	000324eb 	.word	0x000324eb
   17948:	2003007a 	.word	0x2003007a
   1794c:	2003b868 	.word	0x2003b868

00017950 <log_init>:
{
   17950:	b570      	push	{r4, r5, r6, lr}
	return __log_backends_end - __log_backends_start;
   17952:	4b13      	ldr	r3, [pc, #76]	; (179a0 <log_init+0x50>)
   17954:	4c13      	ldr	r4, [pc, #76]	; (179a4 <log_init+0x54>)
   17956:	1b1b      	subs	r3, r3, r4
	assert(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
   17958:	2b90      	cmp	r3, #144	; 0x90
   1795a:	dd06      	ble.n	1796a <log_init+0x1a>
   1795c:	4b12      	ldr	r3, [pc, #72]	; (179a8 <log_init+0x58>)
   1795e:	4a13      	ldr	r2, [pc, #76]	; (179ac <log_init+0x5c>)
   17960:	f240 11ed 	movw	r1, #493	; 0x1ed
   17964:	4812      	ldr	r0, [pc, #72]	; (179b0 <log_init+0x60>)
   17966:	f012 f9e7 	bl	29d38 <__assert_func>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   1796a:	4a12      	ldr	r2, [pc, #72]	; (179b4 <log_init+0x64>)
   1796c:	e8d2 6fef 	ldaex	r6, [r2]
   17970:	1c71      	adds	r1, r6, #1
   17972:	e8c2 1fe0 	stlex	r0, r1, [r2]
   17976:	2800      	cmp	r0, #0
   17978:	d1f8      	bne.n	1796c <log_init+0x1c>
	if (atomic_inc(&initialized) != 0) {
   1797a:	b916      	cbnz	r6, 17982 <log_init+0x32>
   1797c:	111d      	asrs	r5, r3, #4
	for (i = 0; i < log_backend_count_get(); i++) {
   1797e:	42ae      	cmp	r6, r5
   17980:	db00      	blt.n	17984 <log_init+0x34>
}
   17982:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
   17984:	7b23      	ldrb	r3, [r4, #12]
   17986:	b143      	cbz	r3, 1799a <log_init+0x4a>
			if (backend->api->init != NULL) {
   17988:	6823      	ldr	r3, [r4, #0]
   1798a:	695b      	ldr	r3, [r3, #20]
   1798c:	b103      	cbz	r3, 17990 <log_init+0x40>
				backend->api->init();
   1798e:	4798      	blx	r3
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
   17990:	2204      	movs	r2, #4
   17992:	2100      	movs	r1, #0
   17994:	4620      	mov	r0, r4
   17996:	f7ff ffad 	bl	178f4 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
   1799a:	3601      	adds	r6, #1
   1799c:	3410      	adds	r4, #16
   1799e:	e7ee      	b.n	1797e <log_init+0x2e>
   179a0:	0003055c 	.word	0x0003055c
   179a4:	0003054c 	.word	0x0003054c
   179a8:	00032533 	.word	0x00032533
   179ac:	000324e2 	.word	0x000324e2
   179b0:	0003256a 	.word	0x0003256a
   179b4:	20028648 	.word	0x20028648

000179b8 <z_impl_log_panic>:
{
   179b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
   179ba:	4f0c      	ldr	r7, [pc, #48]	; (179ec <z_impl_log_panic+0x34>)
   179bc:	783d      	ldrb	r5, [r7, #0]
   179be:	b94d      	cbnz	r5, 179d4 <z_impl_log_panic+0x1c>
	log_init();
   179c0:	f7ff ffc6 	bl	17950 <log_init>
   179c4:	4c0a      	ldr	r4, [pc, #40]	; (179f0 <z_impl_log_panic+0x38>)
   179c6:	4e0b      	ldr	r6, [pc, #44]	; (179f4 <z_impl_log_panic+0x3c>)
   179c8:	1b36      	subs	r6, r6, r4
   179ca:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   179cc:	42b5      	cmp	r5, r6
   179ce:	db02      	blt.n	179d6 <z_impl_log_panic+0x1e>
	panic_mode = true;
   179d0:	2301      	movs	r3, #1
   179d2:	703b      	strb	r3, [r7, #0]
}
   179d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (log_backend_is_active(backend)) {
   179d6:	4620      	mov	r0, r4
   179d8:	f015 fc87 	bl	2d2ea <log_backend_is_active>
   179dc:	b118      	cbz	r0, 179e6 <z_impl_log_panic+0x2e>
	backend->api->panic(backend);
   179de:	6823      	ldr	r3, [r4, #0]
   179e0:	4620      	mov	r0, r4
   179e2:	691b      	ldr	r3, [r3, #16]
   179e4:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   179e6:	3501      	adds	r5, #1
   179e8:	3410      	adds	r4, #16
   179ea:	e7ef      	b.n	179cc <z_impl_log_panic+0x14>
   179ec:	2003007b 	.word	0x2003007b
   179f0:	0003054c 	.word	0x0003054c
   179f4:	0003055c 	.word	0x0003055c

000179f8 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *log_output,
			   const char *fmt, ...)
{
   179f8:	b40e      	push	{r1, r2, r3}
   179fa:	b503      	push	{r0, r1, lr}
   179fc:	ab03      	add	r3, sp, #12
   179fe:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(args, fmt);
#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, args);
#else
	z_vprintk(out_func, (void *)log_output, fmt, args);
   17a02:	4601      	mov	r1, r0
   17a04:	4804      	ldr	r0, [pc, #16]	; (17a18 <print_formatted+0x20>)
	va_start(args, fmt);
   17a06:	9301      	str	r3, [sp, #4]
	z_vprintk(out_func, (void *)log_output, fmt, args);
   17a08:	f015 faaf 	bl	2cf6a <z_vprintk>
#endif
	va_end(args);

	return length;
}
   17a0c:	2000      	movs	r0, #0
   17a0e:	b002      	add	sp, #8
   17a10:	f85d eb04 	ldr.w	lr, [sp], #4
   17a14:	b003      	add	sp, #12
   17a16:	4770      	bx	lr
   17a18:	0002d31f 	.word	0x0002d31f

00017a1c <prefix_print>:
}

static u32_t prefix_print(const struct log_output *log_output,
			 u32_t flags, bool func_on, u32_t timestamp, u8_t level,
			 u8_t domain_id, u16_t source_id)
{
   17a1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
   17a20:	f011 0402 	ands.w	r4, r1, #2
{
   17a24:	b085      	sub	sp, #20
   17a26:	4606      	mov	r6, r0
   17a28:	4690      	mov	r8, r2
   17a2a:	f89d 7038 	ldrb.w	r7, [sp, #56]	; 0x38
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   17a2e:	f001 0901 	and.w	r9, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
   17a32:	f001 0508 	and.w	r5, r1, #8
	if (stamp) {
   17a36:	d007      	beq.n	17a48 <prefix_print+0x2c>
	if (!format) {
   17a38:	f011 0f44 	tst.w	r1, #68	; 0x44
   17a3c:	d137      	bne.n	17aae <prefix_print+0x92>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
   17a3e:	461a      	mov	r2, r3
   17a40:	4932      	ldr	r1, [pc, #200]	; (17b0c <prefix_print+0xf0>)
   17a42:	f7ff ffd9 	bl	179f8 <print_formatted>
		length += timestamp_print(log_output, flags, timestamp);
   17a46:	4604      	mov	r4, r0
	if (color) {
   17a48:	f1b9 0f00 	cmp.w	r9, #0
   17a4c:	d00a      	beq.n	17a64 <prefix_print+0x48>
		const char *color = start && (colors[level] != NULL) ?
   17a4e:	4b30      	ldr	r3, [pc, #192]	; (17b10 <prefix_print+0xf4>)
		print_formatted(log_output, "%s", color);
   17a50:	4930      	ldr	r1, [pc, #192]	; (17b14 <prefix_print+0xf8>)
		const char *color = start && (colors[level] != NULL) ?
   17a52:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
		print_formatted(log_output, "%s", color);
   17a56:	4b30      	ldr	r3, [pc, #192]	; (17b18 <prefix_print+0xfc>)
   17a58:	4630      	mov	r0, r6
   17a5a:	2a00      	cmp	r2, #0
   17a5c:	bf08      	it	eq
   17a5e:	461a      	moveq	r2, r3
   17a60:	f7ff ffca 	bl	179f8 <print_formatted>
	if (level_on) {
   17a64:	b13d      	cbz	r5, 17a76 <prefix_print+0x5a>
		total += print_formatted(log_output, "<%s> ", severity[level]);
   17a66:	4b2d      	ldr	r3, [pc, #180]	; (17b1c <prefix_print+0x100>)
   17a68:	492d      	ldr	r1, [pc, #180]	; (17b20 <prefix_print+0x104>)
   17a6a:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
   17a6e:	4630      	mov	r0, r6
   17a70:	f7ff ffc2 	bl	179f8 <print_formatted>
   17a74:	4605      	mov	r5, r0
	total += print_formatted(log_output,
   17a76:	f1b8 0f00 	cmp.w	r8, #0
   17a7a:	d044      	beq.n	17b06 <prefix_print+0xea>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
   17a7c:	2301      	movs	r3, #1
   17a7e:	fa03 f707 	lsl.w	r7, r3, r7
	total += print_formatted(log_output,
   17a82:	4b28      	ldr	r3, [pc, #160]	; (17b24 <prefix_print+0x108>)
   17a84:	f017 0f10 	tst.w	r7, #16
   17a88:	4f27      	ldr	r7, [pc, #156]	; (17b28 <prefix_print+0x10c>)
   17a8a:	bf18      	it	ne
   17a8c:	461f      	movne	r7, r3
   17a8e:	f8bd 1040 	ldrh.w	r1, [sp, #64]	; 0x40
   17a92:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
   17a96:	f7ff ff1f 	bl	178d8 <log_source_name_get>
   17a9a:	4639      	mov	r1, r7
   17a9c:	4602      	mov	r2, r0
   17a9e:	4630      	mov	r0, r6
   17aa0:	f7ff ffaa 	bl	179f8 <print_formatted>
   17aa4:	4428      	add	r0, r5
		length += ids_print(log_output, level_on, func_on,
				    domain_id, source_id, level);
	}

	return length;
}
   17aa6:	4420      	add	r0, r4
   17aa8:	b005      	add	sp, #20
   17aaa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (freq != 0U) {
   17aae:	4a1f      	ldr	r2, [pc, #124]	; (17b2c <prefix_print+0x110>)
   17ab0:	6811      	ldr	r1, [r2, #0]
   17ab2:	b331      	cbz	r1, 17b02 <prefix_print+0xe6>
		timestamp /= timestamp_div;
   17ab4:	4a1e      	ldr	r2, [pc, #120]	; (17b30 <prefix_print+0x114>)
   17ab6:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
   17aba:	6814      	ldr	r4, [r2, #0]
		ms = (remainder * 1000U) / freq;
   17abc:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
		timestamp /= timestamp_div;
   17ac0:	fbb3 f3f4 	udiv	r3, r3, r4
		seconds = timestamp / freq;
   17ac4:	fbb3 f4f1 	udiv	r4, r3, r1
		seconds -= hours * 3600U;
   17ac8:	fbb4 f2fe 	udiv	r2, r4, lr
   17acc:	fb0e 4e12 	mls	lr, lr, r2, r4
		remainder = timestamp % freq;
   17ad0:	fb01 3414 	mls	r4, r1, r4, r3
		ms = (remainder * 1000U) / freq;
   17ad4:	fb0c f404 	mul.w	r4, ip, r4
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   17ad8:	fbb4 fbf1 	udiv	fp, r4, r1
		mins = seconds / 60U;
   17adc:	f04f 0a3c 	mov.w	sl, #60	; 0x3c
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   17ae0:	fb01 441b 	mls	r4, r1, fp, r4
   17ae4:	fb0c f404 	mul.w	r4, ip, r4
		mins = seconds / 60U;
   17ae8:	fbbe f3fa 	udiv	r3, lr, sl
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   17aec:	fbb4 f1f1 	udiv	r1, r4, r1
			length = print_formatted(log_output,
   17af0:	e9cd b101 	strd	fp, r1, [sp, #4]
   17af4:	fb0a e113 	mls	r1, sl, r3, lr
   17af8:	9100      	str	r1, [sp, #0]
   17afa:	490e      	ldr	r1, [pc, #56]	; (17b34 <prefix_print+0x118>)
   17afc:	f7ff ff7c 	bl	179f8 <print_formatted>
   17b00:	e7a1      	b.n	17a46 <prefix_print+0x2a>
		length = 0;
   17b02:	4608      	mov	r0, r1
   17b04:	e79f      	b.n	17a46 <prefix_print+0x2a>
	total += print_formatted(log_output,
   17b06:	4f08      	ldr	r7, [pc, #32]	; (17b28 <prefix_print+0x10c>)
   17b08:	e7c1      	b.n	17a8e <prefix_print+0x72>
   17b0a:	bf00      	nop
   17b0c:	00032608 	.word	0x00032608
   17b10:	00030958 	.word	0x00030958
   17b14:	000335f1 	.word	0x000335f1
   17b18:	000325fa 	.word	0x000325fa
   17b1c:	0003096c 	.word	0x0003096c
   17b20:	0003262d 	.word	0x0003262d
   17b24:	00032604 	.word	0x00032604
   17b28:	000325ff 	.word	0x000325ff
   17b2c:	2002864c 	.word	0x2002864c
   17b30:	20028650 	.word	0x20028650
   17b34:	00032611 	.word	0x00032611

00017b38 <postfix_print>:

static void postfix_print(const struct log_output *log_output,
			  u32_t flags, u8_t level)
{
   17b38:	b538      	push	{r3, r4, r5, lr}
   17b3a:	460c      	mov	r4, r1
	if (color) {
   17b3c:	07e1      	lsls	r1, r4, #31
{
   17b3e:	4605      	mov	r5, r0
	if (color) {
   17b40:	d503      	bpl.n	17b4a <postfix_print+0x12>
		print_formatted(log_output, "%s", color);
   17b42:	4a08      	ldr	r2, [pc, #32]	; (17b64 <postfix_print+0x2c>)
   17b44:	4908      	ldr	r1, [pc, #32]	; (17b68 <postfix_print+0x30>)
   17b46:	f7ff ff57 	bl	179f8 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   17b4a:	06e2      	lsls	r2, r4, #27
   17b4c:	d408      	bmi.n	17b60 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   17b4e:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
   17b50:	4628      	mov	r0, r5
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(log_output, flags);
}
   17b52:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\n");
   17b56:	bf4c      	ite	mi
   17b58:	4904      	ldrmi	r1, [pc, #16]	; (17b6c <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
   17b5a:	4905      	ldrpl	r1, [pc, #20]	; (17b70 <postfix_print+0x38>)
   17b5c:	f7ff bf4c 	b.w	179f8 <print_formatted>
}
   17b60:	bd38      	pop	{r3, r4, r5, pc}
   17b62:	bf00      	nop
   17b64:	000325fa 	.word	0x000325fa
   17b68:	000335f1 	.word	0x000335f1
   17b6c:	00033243 	.word	0x00033243
   17b70:	00034073 	.word	0x00034073

00017b74 <hexdump_line_print>:
{
   17b74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   17b78:	4698      	mov	r8, r3
   17b7a:	9b08      	ldr	r3, [sp, #32]
   17b7c:	4604      	mov	r4, r0
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   17b7e:	06dd      	lsls	r5, r3, #27
{
   17b80:	460e      	mov	r6, r1
   17b82:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   17b84:	d405      	bmi.n	17b92 <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   17b86:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
   17b88:	bf4c      	ite	mi
   17b8a:	492a      	ldrmi	r1, [pc, #168]	; (17c34 <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
   17b8c:	492a      	ldrpl	r1, [pc, #168]	; (17c38 <hexdump_line_print+0xc4>)
   17b8e:	f7ff ff33 	bl	179f8 <print_formatted>
{
   17b92:	2500      	movs	r5, #0
		print_formatted(log_output, " ");
   17b94:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 17c40 <hexdump_line_print+0xcc>
	for (int i = 0; i < prefix_offset; i++) {
   17b98:	4545      	cmp	r5, r8
   17b9a:	db2d      	blt.n	17bf8 <hexdump_line_print+0x84>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   17b9c:	2500      	movs	r5, #0
			print_formatted(log_output, "   ");
   17b9e:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 17c44 <hexdump_line_print+0xd0>
			print_formatted(log_output, "%02x ", data[i]);
   17ba2:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 17c48 <hexdump_line_print+0xd4>
			print_formatted(log_output, " ");
   17ba6:	f8df a098 	ldr.w	sl, [pc, #152]	; 17c40 <hexdump_line_print+0xcc>
		if (i < length) {
   17baa:	42bd      	cmp	r5, r7
   17bac:	d231      	bcs.n	17c12 <hexdump_line_print+0x9e>
			print_formatted(log_output, "%02x ", data[i]);
   17bae:	5d72      	ldrb	r2, [r6, r5]
   17bb0:	4649      	mov	r1, r9
   17bb2:	4620      	mov	r0, r4
   17bb4:	f7ff ff20 	bl	179f8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   17bb8:	3501      	adds	r5, #1
   17bba:	2d10      	cmp	r5, #16
   17bbc:	d122      	bne.n	17c04 <hexdump_line_print+0x90>
	print_formatted(log_output, "|");
   17bbe:	491f      	ldr	r1, [pc, #124]	; (17c3c <hexdump_line_print+0xc8>)
   17bc0:	4620      	mov	r0, r4
   17bc2:	f7ff ff19 	bl	179f8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   17bc6:	2500      	movs	r5, #0
			print_formatted(log_output, " ");
   17bc8:	f8df 8074 	ldr.w	r8, [pc, #116]	; 17c40 <hexdump_line_print+0xcc>
			      isprint((int)c) ? c : '.');
   17bcc:	f8df 907c 	ldr.w	r9, [pc, #124]	; 17c4c <hexdump_line_print+0xd8>
			print_formatted(log_output, "%c",
   17bd0:	f8df a07c 	ldr.w	sl, [pc, #124]	; 17c50 <hexdump_line_print+0xdc>
		if (i < length) {
   17bd4:	42af      	cmp	r7, r5
   17bd6:	d928      	bls.n	17c2a <hexdump_line_print+0xb6>
			char c = (char)data[i];
   17bd8:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(log_output, "%c",
   17bda:	4651      	mov	r1, sl
   17bdc:	f812 3009 	ldrb.w	r3, [r2, r9]
   17be0:	4620      	mov	r0, r4
   17be2:	f013 0f97 	tst.w	r3, #151	; 0x97
   17be6:	bf08      	it	eq
   17be8:	222e      	moveq	r2, #46	; 0x2e
   17bea:	f7ff ff05 	bl	179f8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   17bee:	3501      	adds	r5, #1
   17bf0:	2d10      	cmp	r5, #16
   17bf2:	d113      	bne.n	17c1c <hexdump_line_print+0xa8>
}
   17bf4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, " ");
   17bf8:	4649      	mov	r1, r9
   17bfa:	4620      	mov	r0, r4
   17bfc:	f7ff fefc 	bl	179f8 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
   17c00:	3501      	adds	r5, #1
   17c02:	e7c9      	b.n	17b98 <hexdump_line_print+0x24>
		if (i > 0 && !(i % 8)) {
   17c04:	076a      	lsls	r2, r5, #29
   17c06:	d1d0      	bne.n	17baa <hexdump_line_print+0x36>
			print_formatted(log_output, " ");
   17c08:	4651      	mov	r1, sl
   17c0a:	4620      	mov	r0, r4
   17c0c:	f7ff fef4 	bl	179f8 <print_formatted>
   17c10:	e7cb      	b.n	17baa <hexdump_line_print+0x36>
			print_formatted(log_output, "   ");
   17c12:	4641      	mov	r1, r8
   17c14:	4620      	mov	r0, r4
   17c16:	f7ff feef 	bl	179f8 <print_formatted>
   17c1a:	e7cd      	b.n	17bb8 <hexdump_line_print+0x44>
		if (i > 0 && !(i % 8)) {
   17c1c:	076b      	lsls	r3, r5, #29
   17c1e:	d1d9      	bne.n	17bd4 <hexdump_line_print+0x60>
			print_formatted(log_output, " ");
   17c20:	4641      	mov	r1, r8
   17c22:	4620      	mov	r0, r4
   17c24:	f7ff fee8 	bl	179f8 <print_formatted>
   17c28:	e7d4      	b.n	17bd4 <hexdump_line_print+0x60>
			print_formatted(log_output, " ");
   17c2a:	4641      	mov	r1, r8
   17c2c:	4620      	mov	r0, r4
   17c2e:	f7ff fee3 	bl	179f8 <print_formatted>
   17c32:	e7dc      	b.n	17bee <hexdump_line_print+0x7a>
   17c34:	00033243 	.word	0x00033243
   17c38:	00034073 	.word	0x00034073
   17c3c:	000320b0 	.word	0x000320b0
   17c40:	00031420 	.word	0x00031420
   17c44:	0003141e 	.word	0x0003141e
   17c48:	000325af 	.word	0x000325af
   17c4c:	00034e16 	.word	0x00034e16
   17c50:	000325b5 	.word	0x000325b5

00017c54 <log_output_string>:
}

void log_output_string(const struct log_output *log_output,
		       struct log_msg_ids src_level, u32_t timestamp,
		       const char *fmt, va_list ap, u32_t flags)
{
   17c54:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
		log_output_string_syst_process(log_output,
				src_level, fmt, ap, flags);
		return;
	}

	if (!raw_string) {
   17c58:	f011 0407 	ands.w	r4, r1, #7
{
   17c5c:	4606      	mov	r6, r0
   17c5e:	e9dd 870a 	ldrd	r8, r7, [sp, #40]	; 0x28
   17c62:	461d      	mov	r5, r3
	if (!raw_string) {
   17c64:	d00b      	beq.n	17c7e <log_output_string+0x2a>
		prefix_print(log_output, flags, true, timestamp,
   17c66:	f3c1 1389 	ubfx	r3, r1, #6, #10
   17c6a:	f3c1 01c2 	ubfx	r1, r1, #3, #3
   17c6e:	9302      	str	r3, [sp, #8]
   17c70:	e9cd 4100 	strd	r4, r1, [sp]
   17c74:	4613      	mov	r3, r2
   17c76:	4639      	mov	r1, r7
   17c78:	2201      	movs	r2, #1
   17c7a:	f7ff fecf 	bl	17a1c <prefix_print>

#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, ap);
#else
	z_vprintk(out_func, (void *)log_output, fmt, ap);
   17c7e:	4643      	mov	r3, r8
   17c80:	462a      	mov	r2, r5
   17c82:	4631      	mov	r1, r6
   17c84:	480d      	ldr	r0, [pc, #52]	; (17cbc <log_output_string+0x68>)
   17c86:	f015 f970 	bl	2cf6a <z_vprintk>
#endif

	(void)length;

	if (raw_string) {
   17c8a:	b98c      	cbnz	r4, 17cb0 <log_output_string+0x5c>
   17c8c:	3d01      	subs	r5, #1
	while (*fmt != '\0') {
   17c8e:	f815 3f01 	ldrb.w	r3, [r5, #1]!
   17c92:	b95b      	cbnz	r3, 17cac <log_output_string+0x58>
		/* add \r if string ends with newline. */
		if (ends_with_newline(fmt)) {
   17c94:	2c0a      	cmp	r4, #10
   17c96:	d103      	bne.n	17ca0 <log_output_string+0x4c>
			print_formatted(log_output, "\r");
   17c98:	4909      	ldr	r1, [pc, #36]	; (17cc0 <log_output_string+0x6c>)
   17c9a:	4630      	mov	r0, r6
   17c9c:	f7ff feac 	bl	179f8 <print_formatted>
		}
	} else {
		postfix_print(log_output, flags, level);
	}

	log_output_flush(log_output);
   17ca0:	4630      	mov	r0, r6
}
   17ca2:	b004      	add	sp, #16
   17ca4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	log_output_flush(log_output);
   17ca8:	f015 bb52 	b.w	2d350 <log_output_flush>
	while (*fmt != '\0') {
   17cac:	461c      	mov	r4, r3
   17cae:	e7ee      	b.n	17c8e <log_output_string+0x3a>
		postfix_print(log_output, flags, level);
   17cb0:	4622      	mov	r2, r4
   17cb2:	4639      	mov	r1, r7
   17cb4:	4630      	mov	r0, r6
   17cb6:	f7ff ff3f 	bl	17b38 <postfix_print>
   17cba:	e7f1      	b.n	17ca0 <log_output_string+0x4c>
   17cbc:	0002d31f 	.word	0x0002d31f
   17cc0:	000325f8 	.word	0x000325f8

00017cc4 <log_output_hexdump>:

void log_output_hexdump(const struct log_output *log_output,
			     struct log_msg_ids src_level, u32_t timestamp,
			     const char *metadata, const u8_t *data,
			     u32_t length, u32_t flags)
{
   17cc4:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   17cc8:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   17cca:	4698      	mov	r8, r3
   17ccc:	e9dd 750c 	ldrd	r7, r5, [sp, #48]	; 0x30
		log_output_hexdump_syst_process(log_output,
				src_level, data, length, flags);
		return;
	}

	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   17cd0:	f3c1 1389 	ubfx	r3, r1, #6, #10
	u8_t level = (u8_t)src_level.level;
   17cd4:	f001 0907 	and.w	r9, r1, #7
	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   17cd8:	f3c1 01c2 	ubfx	r1, r1, #3, #3
   17cdc:	9302      	str	r3, [sp, #8]
   17cde:	e9cd 9100 	strd	r9, r1, [sp]
   17ce2:	4613      	mov	r3, r2
   17ce4:	4631      	mov	r1, r6
   17ce6:	2201      	movs	r2, #1
{
   17ce8:	4604      	mov	r4, r0
	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   17cea:	f7ff fe97 	bl	17a1c <prefix_print>
				     level, domain_id, source_id);

	/* Print metadata */
	print_formatted(log_output, "%s", metadata);
   17cee:	4642      	mov	r2, r8
	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   17cf0:	4682      	mov	sl, r0
	print_formatted(log_output, "%s", metadata);
   17cf2:	4910      	ldr	r1, [pc, #64]	; (17d34 <log_output_hexdump+0x70>)
   17cf4:	4620      	mov	r0, r4
   17cf6:	f7ff fe7f 	bl	179f8 <print_formatted>

	while (length) {
   17cfa:	b955      	cbnz	r5, 17d12 <log_output_hexdump+0x4e>

		data += part_len;
		length -= part_len;
	};

	postfix_print(log_output, flags, level);
   17cfc:	4620      	mov	r0, r4
   17cfe:	464a      	mov	r2, r9
   17d00:	4631      	mov	r1, r6
   17d02:	f7ff ff19 	bl	17b38 <postfix_print>
	log_output_flush(log_output);
   17d06:	4620      	mov	r0, r4
}
   17d08:	b004      	add	sp, #16
   17d0a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	log_output_flush(log_output);
   17d0e:	f015 bb1f 	b.w	2d350 <log_output_flush>
		u32_t part_len = length > HEXDUMP_BYTES_IN_LINE ?
   17d12:	2d10      	cmp	r5, #16
   17d14:	46a8      	mov	r8, r5
   17d16:	bf28      	it	cs
   17d18:	f04f 0810 	movcs.w	r8, #16
		hexdump_line_print(log_output, data, part_len,
   17d1c:	4639      	mov	r1, r7
   17d1e:	9600      	str	r6, [sp, #0]
   17d20:	4653      	mov	r3, sl
   17d22:	4642      	mov	r2, r8
   17d24:	4620      	mov	r0, r4
   17d26:	f7ff ff25 	bl	17b74 <hexdump_line_print>
		data += part_len;
   17d2a:	4447      	add	r7, r8
		length -= part_len;
   17d2c:	eba5 0508 	sub.w	r5, r5, r8
   17d30:	e7e3      	b.n	17cfa <log_output_hexdump+0x36>
   17d32:	bf00      	nop
   17d34:	000335f1 	.word	0x000335f1

00017d38 <log_output_timestamp_freq_set>:
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
}

void log_output_timestamp_freq_set(u32_t frequency)
{
	timestamp_div = 1U;
   17d38:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
   17d3a:	2100      	movs	r1, #0
	timestamp_div = 1U;
   17d3c:	4a07      	ldr	r2, [pc, #28]	; (17d5c <log_output_timestamp_freq_set+0x24>)
{
   17d3e:	b510      	push	{r4, lr}
	while (frequency > 1000000) {
   17d40:	4c07      	ldr	r4, [pc, #28]	; (17d60 <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
   17d42:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
   17d44:	42a0      	cmp	r0, r4
   17d46:	d804      	bhi.n	17d52 <log_output_timestamp_freq_set+0x1a>
   17d48:	b101      	cbz	r1, 17d4c <log_output_timestamp_freq_set+0x14>
   17d4a:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
   17d4c:	4b05      	ldr	r3, [pc, #20]	; (17d64 <log_output_timestamp_freq_set+0x2c>)
   17d4e:	6018      	str	r0, [r3, #0]
}
   17d50:	bd10      	pop	{r4, pc}
		frequency /= 2U;
   17d52:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
   17d54:	005b      	lsls	r3, r3, #1
   17d56:	2101      	movs	r1, #1
   17d58:	e7f4      	b.n	17d44 <log_output_timestamp_freq_set+0xc>
   17d5a:	bf00      	nop
   17d5c:	20028650 	.word	0x20028650
   17d60:	000f4240 	.word	0x000f4240
   17d64:	2002864c 	.word	0x2002864c

00017d68 <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
   17d68:	2201      	movs	r2, #1
   17d6a:	4b01      	ldr	r3, [pc, #4]	; (17d70 <log_backend_rtt_init+0x8>)
   17d6c:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
   17d6e:	4770      	bx	lr
   17d70:	2003007d 	.word	0x2003007d

00017d74 <panic>:

static void panic(struct log_backend const *const backend)
{
   17d74:	b508      	push	{r3, lr}
 * @param log_output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const log_output)
{
	log_output_flush(log_output);
   17d76:	4803      	ldr	r0, [pc, #12]	; (17d84 <panic+0x10>)
   17d78:	f015 faea 	bl	2d350 <log_output_flush>
	log_backend_std_panic(&log_output);
	panic_mode = true;
   17d7c:	2201      	movs	r2, #1
   17d7e:	4b02      	ldr	r3, [pc, #8]	; (17d88 <panic+0x14>)
   17d80:	701a      	strb	r2, [r3, #0]
}
   17d82:	bd08      	pop	{r3, pc}
   17d84:	00030998 	.word	0x00030998
   17d88:	2003007e 	.word	0x2003007e

00017d8c <sync_hexdump>:
}

static void sync_hexdump(const struct log_backend *const backend,
			 struct log_msg_ids src_level, u32_t timestamp,
			 const char *metadata, const u8_t *data, u32_t length)
{
   17d8c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		 * by another one, lock context for whole log processing.
		 */
		key = irq_lock();
	}

	log_output_hexdump(log_output, src_level, timestamp,
   17d8e:	200a      	movs	r0, #10
   17d90:	9002      	str	r0, [sp, #8]
   17d92:	9807      	ldr	r0, [sp, #28]
   17d94:	9001      	str	r0, [sp, #4]
   17d96:	9806      	ldr	r0, [sp, #24]
   17d98:	9000      	str	r0, [sp, #0]
   17d9a:	4803      	ldr	r0, [pc, #12]	; (17da8 <sync_hexdump+0x1c>)
   17d9c:	f7ff ff92 	bl	17cc4 <log_output_hexdump>
	u32_t flag = IS_ENABLED(CONFIG_LOG_BACKEND_RTT_SYST_ENABLE) ?
		LOG_OUTPUT_FLAG_FORMAT_SYST : 0;

	log_backend_std_sync_hexdump(&log_output, flag, src_level,
				     timestamp, metadata, data, length);
}
   17da0:	b005      	add	sp, #20
   17da2:	f85d fb04 	ldr.w	pc, [sp], #4
   17da6:	bf00      	nop
   17da8:	00030998 	.word	0x00030998

00017dac <sync_string>:
{
   17dac:	b507      	push	{r0, r1, r2, lr}
	log_output_string(log_output, src_level, timestamp, fmt, ap, flags);
   17dae:	200a      	movs	r0, #10
   17db0:	9001      	str	r0, [sp, #4]
   17db2:	9804      	ldr	r0, [sp, #16]
   17db4:	9000      	str	r0, [sp, #0]
   17db6:	4803      	ldr	r0, [pc, #12]	; (17dc4 <sync_string+0x18>)
   17db8:	f7ff ff4c 	bl	17c54 <log_output_string>
}
   17dbc:	b003      	add	sp, #12
   17dbe:	f85d fb04 	ldr.w	pc, [sp], #4
   17dc2:	bf00      	nop
   17dc4:	00030998 	.word	0x00030998

00017dc8 <data_out_drop_mode>:
{
   17dc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17dca:	4607      	mov	r7, r0
   17dcc:	460e      	mov	r6, r1
	int retry_cnt = CONFIG_LOG_BACKEND_RTT_RETRY_CNT;
   17dce:	240a      	movs	r4, #10
   17dd0:	4d17      	ldr	r5, [pc, #92]	; (17e30 <data_out_drop_mode+0x68>)
		ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
   17dd2:	4632      	mov	r2, r6
   17dd4:	4639      	mov	r1, r7
   17dd6:	2000      	movs	r0, #0
   17dd8:	f000 ffee 	bl	18db8 <SEGGER_RTT_WriteSkipNoLock>
		if (ret) {
   17ddc:	b1c8      	cbz	r0, 17e12 <data_out_drop_mode+0x4a>
	host_present = true;
   17dde:	2301      	movs	r3, #1
   17de0:	702b      	strb	r3, [r5, #0]
	return panic_mode;
   17de2:	4b14      	ldr	r3, [pc, #80]	; (17e34 <data_out_drop_mode+0x6c>)
	if (is_panic_mode()) {
   17de4:	781b      	ldrb	r3, [r3, #0]
   17de6:	b92b      	cbnz	r3, 17df4 <data_out_drop_mode+0x2c>
}
   17de8:	4630      	mov	r0, r6
   17dea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (retry_cnt == 0) {
   17dec:	b95c      	cbnz	r4, 17e06 <data_out_drop_mode+0x3e>
		host_present = false;
   17dee:	702c      	strb	r4, [r5, #0]
   17df0:	f04f 34ff 	mov.w	r4, #4294967295
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
   17df4:	2000      	movs	r0, #0
   17df6:	f001 f82b 	bl	18e50 <SEGGER_RTT_HasDataUp>
   17dfa:	2800      	cmp	r0, #0
   17dfc:	d0f4      	beq.n	17de8 <data_out_drop_mode+0x20>
   17dfe:	782b      	ldrb	r3, [r5, #0]
   17e00:	2b00      	cmp	r3, #0
   17e02:	d1f3      	bne.n	17dec <data_out_drop_mode+0x24>
   17e04:	e7f0      	b.n	17de8 <data_out_drop_mode+0x20>
			on_failed_write(retry_cnt--);
   17e06:	3c01      	subs	r4, #1
	z_impl_k_busy_wait(usec_to_wait);
   17e08:	f242 7010 	movw	r0, #10000	; 0x2710
   17e0c:	f017 f968 	bl	2f0e0 <z_impl_k_busy_wait>
   17e10:	e7f0      	b.n	17df4 <data_out_drop_mode+0x2c>
		} else if (host_present) {
   17e12:	782b      	ldrb	r3, [r5, #0]
   17e14:	b113      	cbz	r3, 17e1c <data_out_drop_mode+0x54>
	if (retry_cnt == 0) {
   17e16:	3c01      	subs	r4, #1
   17e18:	d104      	bne.n	17e24 <data_out_drop_mode+0x5c>
		host_present = false;
   17e1a:	702c      	strb	r4, [r5, #0]
	} while ((ret == 0) && host_present);
   17e1c:	782b      	ldrb	r3, [r5, #0]
   17e1e:	2b00      	cmp	r3, #0
   17e20:	d1d7      	bne.n	17dd2 <data_out_drop_mode+0xa>
   17e22:	e7e1      	b.n	17de8 <data_out_drop_mode+0x20>
   17e24:	f242 7010 	movw	r0, #10000	; 0x2710
   17e28:	f017 f95a 	bl	2f0e0 <z_impl_k_busy_wait>
   17e2c:	e7f6      	b.n	17e1c <data_out_drop_mode+0x54>
   17e2e:	bf00      	nop
   17e30:	2003007d 	.word	0x2003007d
   17e34:	2003007e 	.word	0x2003007e

00017e38 <nvs_flash_erase_sector>:

/* erase a sector by first checking it is used and then erasing if required
 * return 0 if OK, errorcode on error.
 */
static int nvs_flash_erase_sector(struct nvs_fs *fs, u32_t addr)
{
   17e38:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	int rc;
	off_t offset;

	addr &= ADDR_SECT_MASK;
   17e3c:	0c0c      	lsrs	r4, r1, #16
   17e3e:	0424      	lsls	r4, r4, #16
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
   17e40:	8982      	ldrh	r2, [r0, #12]
   17e42:	4621      	mov	r1, r4
{
   17e44:	4605      	mov	r5, r0
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
   17e46:	f015 faf1 	bl	2d42c <nvs_flash_cmp_const.constprop.5>
	if (rc <= 0) {
   17e4a:	1e06      	subs	r6, r0, #0
   17e4c:	dd29      	ble.n	17ea2 <nvs_flash_erase_sector+0x6a>
	}

	offset = fs->offset;
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);

	rc = flash_write_protection_set(fs->flash_device, 0);
   17e4e:	2100      	movs	r1, #0
   17e50:	6aa8      	ldr	r0, [r5, #40]	; 0x28
	offset = fs->offset;
   17e52:	682f      	ldr	r7, [r5, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   17e54:	f8b5 800c 	ldrh.w	r8, [r5, #12]
	rc = flash_write_protection_set(fs->flash_device, 0);
   17e58:	f015 fa87 	bl	2d36a <flash_write_protection_set>
	if (rc) {
   17e5c:	4606      	mov	r6, r0
   17e5e:	bb00      	cbnz	r0, 17ea2 <nvs_flash_erase_sector+0x6a>
		/* flash protection set error */
		return rc;
	}
	LOG_DBG("Erasing flash at %lx, len %d", (long int) offset,
   17e60:	2304      	movs	r3, #4
   17e62:	f04f 0000 	mov.w	r0, #0
	return ((u8_t *)data - (u8_t *)__log_const_start)/
   17e66:	4a11      	ldr	r2, [pc, #68]	; (17eac <nvs_flash_erase_sector+0x74>)
   17e68:	f363 0007 	bfi	r0, r3, #0, #8
   17e6c:	4b10      	ldr	r3, [pc, #64]	; (17eb0 <nvs_flash_erase_sector+0x78>)
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   17e6e:	0c24      	lsrs	r4, r4, #16
   17e70:	fb08 7404 	mla	r4, r8, r4, r7
   17e74:	1a9b      	subs	r3, r3, r2
   17e76:	08db      	lsrs	r3, r3, #3
	LOG_DBG("Erasing flash at %lx, len %d", (long int) offset,
   17e78:	f363 108f 	bfi	r0, r3, #6, #10
   17e7c:	89ab      	ldrh	r3, [r5, #12]
   17e7e:	4a0d      	ldr	r2, [pc, #52]	; (17eb4 <nvs_flash_erase_sector+0x7c>)
   17e80:	9300      	str	r3, [sp, #0]
   17e82:	490d      	ldr	r1, [pc, #52]	; (17eb8 <nvs_flash_erase_sector+0x80>)
   17e84:	4623      	mov	r3, r4
   17e86:	f015 fa37 	bl	2d2f8 <log_string_sync>
		fs->sector_size);
	rc = flash_erase(fs->flash_device, offset, fs->sector_size);
   17e8a:	6aa8      	ldr	r0, [r5, #40]	; 0x28
   17e8c:	89aa      	ldrh	r2, [r5, #12]
				    size_t size)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->driver_api;

	return api->erase(dev, offset, size);
   17e8e:	6843      	ldr	r3, [r0, #4]
   17e90:	4621      	mov	r1, r4
   17e92:	689b      	ldr	r3, [r3, #8]
   17e94:	4798      	blx	r3
	if (rc) {
   17e96:	4606      	mov	r6, r0
   17e98:	b918      	cbnz	r0, 17ea2 <nvs_flash_erase_sector+0x6a>
		/* flash erase error */
		return rc;
	}
	(void) flash_write_protection_set(fs->flash_device, 1);
   17e9a:	2101      	movs	r1, #1
   17e9c:	6aa8      	ldr	r0, [r5, #40]	; 0x28
   17e9e:	f015 fa64 	bl	2d36a <flash_write_protection_set>
	return 0;
}
   17ea2:	4630      	mov	r0, r6
   17ea4:	b002      	add	sp, #8
   17ea6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   17eaa:	bf00      	nop
   17eac:	0003040c 	.word	0x0003040c
   17eb0:	0003046c 	.word	0x0003046c
   17eb4:	00032663 	.word	0x00032663
   17eb8:	00032695 	.word	0x00032695

00017ebc <nvs_prev_ate>:

/* walking through allocation entry list, from newest to oldest entries
 * read ate from addr, modify addr to the previous ate
 */
static int nvs_prev_ate(struct nvs_fs *fs, u32_t *addr, struct nvs_ate *ate)
{
   17ebc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   17ec0:	2308      	movs	r3, #8
{
   17ec2:	b085      	sub	sp, #20
   17ec4:	460d      	mov	r5, r1
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   17ec6:	6809      	ldr	r1, [r1, #0]
{
   17ec8:	4607      	mov	r7, r0
	int rc;
	struct nvs_ate close_ate, end_ate;
	u32_t data_end_addr, ate_end_addr;
	size_t ate_size;

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   17eca:	7c04      	ldrb	r4, [r0, #16]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   17ecc:	f015 fa50 	bl	2d370 <nvs_flash_rd>

	rc = nvs_flash_ate_rd(fs, *addr, ate);
	if (rc) {
   17ed0:	b968      	cbnz	r0, 17eee <nvs_prev_ate+0x32>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   17ed2:	2108      	movs	r1, #8
   17ed4:	4620      	mov	r0, r4
   17ed6:	f015 fa96 	bl	2d406 <nvs_al_size.isra.1>
		return rc;
	}

	*addr += ate_size;
   17eda:	6829      	ldr	r1, [r5, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
   17edc:	89bb      	ldrh	r3, [r7, #12]
	*addr += ate_size;
   17ede:	4401      	add	r1, r0
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
   17ee0:	b28a      	uxth	r2, r1
   17ee2:	1a1b      	subs	r3, r3, r0
   17ee4:	429a      	cmp	r2, r3
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   17ee6:	4606      	mov	r6, r0
	*addr += ate_size;
   17ee8:	6029      	str	r1, [r5, #0]
	if (((*addr) & ADDR_OFFS_MASK) != (fs->sector_size - ate_size)) {
   17eea:	d003      	beq.n	17ef4 <nvs_prev_ate+0x38>
		return 0;
   17eec:	2000      	movs	r0, #0
	/* remark: if there was absolutely no valid data in the sector *addr
	 * is kept at sector_end - 2*ate_size, the next read will contain
	 * invalid data and continue with a sector jump
	 */
	return 0;
}
   17eee:	b005      	add	sp, #20
   17ef0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (((*addr) >> ADDR_SECT_SHIFT) == 0U) {
   17ef4:	0c0b      	lsrs	r3, r1, #16
		*addr += ((fs->sector_count - 1) << ADDR_SECT_SHIFT);
   17ef6:	bf09      	itett	eq
   17ef8:	89fb      	ldrheq	r3, [r7, #14]
		*addr -= (1 << ADDR_SECT_SHIFT);
   17efa:	f5a1 3180 	subne.w	r1, r1, #65536	; 0x10000
		*addr += ((fs->sector_count - 1) << ADDR_SECT_SHIFT);
   17efe:	f103 33ff 	addeq.w	r3, r3, #4294967295
   17f02:	eb01 4103 	addeq.w	r1, r1, r3, lsl #16
		*addr -= (1 << ADDR_SECT_SHIFT);
   17f06:	6029      	str	r1, [r5, #0]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   17f08:	2308      	movs	r3, #8
   17f0a:	466a      	mov	r2, sp
   17f0c:	4638      	mov	r0, r7
   17f0e:	f015 fa2f 	bl	2d370 <nvs_flash_rd>
	if (rc) {
   17f12:	2800      	cmp	r0, #0
   17f14:	d1eb      	bne.n	17eee <nvs_prev_ate+0x32>
   17f16:	466a      	mov	r2, sp
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   17f18:	4603      	mov	r3, r0
		if (data8[i] != value) {
   17f1a:	f812 1b01 	ldrb.w	r1, [r2], #1
   17f1e:	29ff      	cmp	r1, #255	; 0xff
   17f20:	d115      	bne.n	17f4e <nvs_prev_ate+0x92>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   17f22:	3301      	adds	r3, #1
   17f24:	2b08      	cmp	r3, #8
   17f26:	d1f8      	bne.n	17f1a <nvs_prev_ate+0x5e>
		*addr = fs->ate_wra;
   17f28:	687b      	ldr	r3, [r7, #4]
   17f2a:	602b      	str	r3, [r5, #0]
		return 0;
   17f2c:	e7df      	b.n	17eee <nvs_prev_ate+0x32>
		if (close_ate.offset < (fs->sector_size - ate_size) &&
   17f2e:	89ba      	ldrh	r2, [r7, #12]
   17f30:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   17f34:	1b92      	subs	r2, r2, r6
   17f36:	4293      	cmp	r3, r2
   17f38:	d20f      	bcs.n	17f5a <nvs_prev_ate+0x9e>
		    !(close_ate.offset % ate_size)) {
   17f3a:	fbb3 f2f6 	udiv	r2, r3, r6
   17f3e:	fb06 3212 	mls	r2, r6, r2, r3
		if (close_ate.offset < (fs->sector_size - ate_size) &&
   17f42:	b952      	cbnz	r2, 17f5a <nvs_prev_ate+0x9e>
			(*addr) &= ADDR_SECT_MASK;
   17f44:	0c24      	lsrs	r4, r4, #16
   17f46:	0424      	lsls	r4, r4, #16
			(*addr) += close_ate.offset;
   17f48:	441c      	add	r4, r3
   17f4a:	602c      	str	r4, [r5, #0]
			return 0;
   17f4c:	e7cf      	b.n	17eee <nvs_prev_ate+0x32>
	if (!nvs_ate_crc8_check(&close_ate)) {
   17f4e:	4668      	mov	r0, sp
   17f50:	f015 fa44 	bl	2d3dc <nvs_ate_crc8_check>
   17f54:	682c      	ldr	r4, [r5, #0]
   17f56:	2800      	cmp	r0, #0
   17f58:	d0e9      	beq.n	17f2e <nvs_prev_ate+0x72>
	data_end_addr = *addr & ADDR_SECT_MASK;
   17f5a:	4b10      	ldr	r3, [pc, #64]	; (17f9c <nvs_prev_ate+0xe0>)
	*addr -= ate_size;
   17f5c:	1ba4      	subs	r4, r4, r6
			data_end_addr &= ADDR_SECT_MASK;
   17f5e:	4699      	mov	r9, r3
	*addr -= ate_size;
   17f60:	602c      	str	r4, [r5, #0]
	data_end_addr = *addr & ADDR_SECT_MASK;
   17f62:	ea04 0803 	and.w	r8, r4, r3
	while (ate_end_addr > data_end_addr) {
   17f66:	45a0      	cmp	r8, r4
   17f68:	d2c0      	bcs.n	17eec <nvs_prev_ate+0x30>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   17f6a:	2308      	movs	r3, #8
   17f6c:	4621      	mov	r1, r4
   17f6e:	eb0d 0203 	add.w	r2, sp, r3
   17f72:	4638      	mov	r0, r7
   17f74:	f015 f9fc 	bl	2d370 <nvs_flash_rd>
		if (rc) {
   17f78:	2800      	cmp	r0, #0
   17f7a:	d1b8      	bne.n	17eee <nvs_prev_ate+0x32>
		if (!nvs_ate_crc8_check(&end_ate)) {
   17f7c:	a802      	add	r0, sp, #8
   17f7e:	f015 fa2d 	bl	2d3dc <nvs_ate_crc8_check>
   17f82:	b940      	cbnz	r0, 17f96 <nvs_prev_ate+0xda>
			data_end_addr += end_ate.offset + end_ate.len;
   17f84:	f8bd 300a 	ldrh.w	r3, [sp, #10]
   17f88:	f8bd 200c 	ldrh.w	r2, [sp, #12]
			data_end_addr &= ADDR_SECT_MASK;
   17f8c:	ea08 0809 	and.w	r8, r8, r9
			data_end_addr += end_ate.offset + end_ate.len;
   17f90:	4413      	add	r3, r2
   17f92:	4498      	add	r8, r3
			*addr = ate_end_addr;
   17f94:	602c      	str	r4, [r5, #0]
		ate_end_addr -= ate_size;
   17f96:	1ba4      	subs	r4, r4, r6
   17f98:	e7e5      	b.n	17f66 <nvs_prev_ate+0xaa>
   17f9a:	bf00      	nop
   17f9c:	ffff0000 	.word	0xffff0000

00017fa0 <nvs_gc>:
/* garbage collection: the address ate_wra has been updated to the new sector
 * that has just been started. The data to gc is in the sector after this new
 * sector.
 */
static int nvs_gc(struct nvs_fs *fs)
{
   17fa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct nvs_ate close_ate, gc_ate, wlk_ate;
	u32_t sec_addr, gc_addr, gc_prev_addr, wlk_addr, wlk_prev_addr,
	      data_addr, stop_addr;
	size_t ate_size;

	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   17fa4:	2108      	movs	r1, #8
{
   17fa6:	b097      	sub	sp, #92	; 0x5c
   17fa8:	4604      	mov	r4, r0
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   17faa:	7c00      	ldrb	r0, [r0, #16]
   17fac:	f015 fa2b 	bl	2d406 <nvs_al_size.isra.1>
   17fb0:	4680      	mov	r8, r0

	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
   17fb2:	6863      	ldr	r3, [r4, #4]
	nvs_sector_advance(fs, &sec_addr);
   17fb4:	a905      	add	r1, sp, #20
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
   17fb6:	0c1b      	lsrs	r3, r3, #16
   17fb8:	041b      	lsls	r3, r3, #16
	nvs_sector_advance(fs, &sec_addr);
   17fba:	89e0      	ldrh	r0, [r4, #14]
	sec_addr = (fs->ate_wra & ADDR_SECT_MASK);
   17fbc:	9305      	str	r3, [sp, #20]
	nvs_sector_advance(fs, &sec_addr);
   17fbe:	f015 fa2b 	bl	2d418 <nvs_sector_advance.isra.2>
	gc_addr = sec_addr + fs->sector_size - ate_size;
   17fc2:	9b05      	ldr	r3, [sp, #20]
   17fc4:	89a1      	ldrh	r1, [r4, #12]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   17fc6:	ad08      	add	r5, sp, #32
	gc_addr = sec_addr + fs->sector_size - ate_size;
   17fc8:	4419      	add	r1, r3
   17fca:	eba1 0108 	sub.w	r1, r1, r8
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   17fce:	462a      	mov	r2, r5
   17fd0:	2308      	movs	r3, #8
   17fd2:	4620      	mov	r0, r4
	gc_addr = sec_addr + fs->sector_size - ate_size;
   17fd4:	9106      	str	r1, [sp, #24]
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   17fd6:	f015 f9cb 	bl	2d370 <nvs_flash_rd>

	/* if the sector is not closed don't do gc */
	rc = nvs_flash_ate_rd(fs, gc_addr, &close_ate);
	if (rc < 0) {
   17fda:	1e02      	subs	r2, r0, #0
   17fdc:	f2c0 8085 	blt.w	180ea <nvs_gc+0x14a>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   17fe0:	2300      	movs	r3, #0
		if (data8[i] != value) {
   17fe2:	5cea      	ldrb	r2, [r5, r3]
   17fe4:	2aff      	cmp	r2, #255	; 0xff
   17fe6:	f040 8084 	bne.w	180f2 <nvs_gc+0x152>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   17fea:	3301      	adds	r3, #1
   17fec:	2b08      	cmp	r3, #8
   17fee:	d1f8      	bne.n	17fe2 <nvs_gc+0x42>
		return rc;
	}

	rc = nvs_ate_cmp_const(&close_ate, 0xff);
	if (!rc) {
		rc = nvs_flash_erase_sector(fs, sec_addr);
   17ff0:	9905      	ldr	r1, [sp, #20]
   17ff2:	4620      	mov	r0, r4
   17ff4:	f7ff ff20 	bl	17e38 <nvs_flash_erase_sector>
   17ff8:	4602      	mov	r2, r0
		if (rc) {
   17ffa:	e076      	b.n	180ea <nvs_gc+0x14a>
		bytes_to_copy = MIN(block_size, len);
   17ffc:	454e      	cmp	r6, r9
   17ffe:	4635      	mov	r5, r6
   18000:	bf28      	it	cs
   18002:	464d      	movcs	r5, r9
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_copy);
   18004:	aa0e      	add	r2, sp, #56	; 0x38
   18006:	462b      	mov	r3, r5
   18008:	4639      	mov	r1, r7
   1800a:	4620      	mov	r0, r4
   1800c:	f015 f9b0 	bl	2d370 <nvs_flash_rd>
		if (rc) {
   18010:	4602      	mov	r2, r0
   18012:	2800      	cmp	r0, #0
   18014:	d169      	bne.n	180ea <nvs_gc+0x14a>
	if (!len) {
   18016:	b135      	cbz	r5, 18026 <nvs_gc+0x86>
   18018:	aa0e      	add	r2, sp, #56	; 0x38
   1801a:	462b      	mov	r3, r5
   1801c:	68a1      	ldr	r1, [r4, #8]
   1801e:	4620      	mov	r0, r4
   18020:	f015 fa28 	bl	2d474 <nvs_flash_al_wrt.part.3>
   18024:	4602      	mov	r2, r0
	fs->data_wra += nvs_al_size(fs, len);
   18026:	4629      	mov	r1, r5
   18028:	7c20      	ldrb	r0, [r4, #16]
   1802a:	f015 f9ec 	bl	2d406 <nvs_al_size.isra.1>
   1802e:	68a3      	ldr	r3, [r4, #8]
   18030:	4418      	add	r0, r3
   18032:	60a0      	str	r0, [r4, #8]
		if (rc) {
   18034:	2a00      	cmp	r2, #0
   18036:	d158      	bne.n	180ea <nvs_gc+0x14a>
		len -= bytes_to_copy;
   18038:	eba9 0905 	sub.w	r9, r9, r5
		addr += bytes_to_copy;
   1803c:	442f      	add	r7, r5
   1803e:	e04a      	b.n	180d6 <nvs_gc+0x136>
				return rc;
			}
		}

		/* stop gc at end of the sector */
		if (gc_prev_addr == stop_addr) {
   18040:	45d8      	cmp	r8, fp
   18042:	d0d5      	beq.n	17ff0 <nvs_gc+0x50>
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
   18044:	aa0a      	add	r2, sp, #40	; 0x28
   18046:	a906      	add	r1, sp, #24
   18048:	4620      	mov	r0, r4
		gc_prev_addr = gc_addr;
   1804a:	f8dd b018 	ldr.w	fp, [sp, #24]
		rc = nvs_prev_ate(fs, &gc_addr, &gc_ate);
   1804e:	f7ff ff35 	bl	17ebc <nvs_prev_ate>
		if (rc) {
   18052:	4602      	mov	r2, r0
   18054:	2800      	cmp	r0, #0
   18056:	d148      	bne.n	180ea <nvs_gc+0x14a>
		wlk_addr = fs->ate_wra;
   18058:	6863      	ldr	r3, [r4, #4]
   1805a:	9307      	str	r3, [sp, #28]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   1805c:	aa0c      	add	r2, sp, #48	; 0x30
   1805e:	a907      	add	r1, sp, #28
   18060:	4620      	mov	r0, r4
			wlk_prev_addr = wlk_addr;
   18062:	9d07      	ldr	r5, [sp, #28]
			rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   18064:	f7ff ff2a 	bl	17ebc <nvs_prev_ate>
			if (rc) {
   18068:	4602      	mov	r2, r0
   1806a:	2800      	cmp	r0, #0
   1806c:	d13d      	bne.n	180ea <nvs_gc+0x14a>
			if ((wlk_ate.id == gc_ate.id) &&
   1806e:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
   18072:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   18076:	429a      	cmp	r2, r3
   18078:	d1f0      	bne.n	1805c <nvs_gc+0xbc>
			    (!nvs_ate_crc8_check(&wlk_ate))) {
   1807a:	a80c      	add	r0, sp, #48	; 0x30
   1807c:	f015 f9ae 	bl	2d3dc <nvs_ate_crc8_check>
			if ((wlk_ate.id == gc_ate.id) &&
   18080:	2800      	cmp	r0, #0
   18082:	d1eb      	bne.n	1805c <nvs_gc+0xbc>
		if ((wlk_prev_addr == gc_prev_addr) && gc_ate.len) {
   18084:	45ab      	cmp	fp, r5
   18086:	d1db      	bne.n	18040 <nvs_gc+0xa0>
   18088:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
   1808c:	2a00      	cmp	r2, #0
   1808e:	d0d7      	beq.n	18040 <nvs_gc+0xa0>
			LOG_DBG("Moving %d, len %d", gc_ate.id, gc_ate.len);
   18090:	f02a 033f 	bic.w	r3, sl, #63	; 0x3f
   18094:	f043 0304 	orr.w	r3, r3, #4
   18098:	f363 0a07 	bfi	sl, r3, #0, #8
   1809c:	9b02      	ldr	r3, [sp, #8]
   1809e:	9200      	str	r2, [sp, #0]
   180a0:	f363 1a8f 	bfi	sl, r3, #6, #10
   180a4:	4a1b      	ldr	r2, [pc, #108]	; (18114 <nvs_gc+0x174>)
   180a6:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   180aa:	491b      	ldr	r1, [pc, #108]	; (18118 <nvs_gc+0x178>)
   180ac:	4650      	mov	r0, sl
   180ae:	f015 f923 	bl	2d2f8 <log_string_sync>
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
   180b2:	9b03      	ldr	r3, [sp, #12]
			nvs_ate_crc8_update(&gc_ate);
   180b4:	a80a      	add	r0, sp, #40	; 0x28
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
   180b6:	ea0b 0703 	and.w	r7, fp, r3
			data_addr += gc_ate.offset;
   180ba:	f8bd 302a 	ldrh.w	r3, [sp, #42]	; 0x2a
   180be:	441f      	add	r7, r3
			gc_ate.offset = (u16_t)(fs->data_wra & ADDR_OFFS_MASK);
   180c0:	68a3      	ldr	r3, [r4, #8]
   180c2:	f8ad 302a 	strh.w	r3, [sp, #42]	; 0x2a
			nvs_ate_crc8_update(&gc_ate);
   180c6:	f015 f995 	bl	2d3f4 <nvs_ate_crc8_update>
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   180ca:	7c26      	ldrb	r6, [r4, #16]
			rc = nvs_flash_block_move(fs, data_addr, gc_ate.len);
   180cc:	f8bd 902c 	ldrh.w	r9, [sp, #44]	; 0x2c
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   180d0:	4276      	negs	r6, r6
   180d2:	f006 0620 	and.w	r6, r6, #32
	while (len) {
   180d6:	f1b9 0f00 	cmp.w	r9, #0
   180da:	d18f      	bne.n	17ffc <nvs_gc+0x5c>
			rc = nvs_flash_ate_wrt(fs, &gc_ate);
   180dc:	a90a      	add	r1, sp, #40	; 0x28
   180de:	4620      	mov	r0, r4
   180e0:	f015 fa0e 	bl	2d500 <nvs_flash_ate_wrt>
			if (rc) {
   180e4:	4602      	mov	r2, r0
   180e6:	2800      	cmp	r0, #0
   180e8:	d0aa      	beq.n	18040 <nvs_gc+0xa0>
	rc = nvs_flash_erase_sector(fs, sec_addr);
	if (rc) {
		return rc;
	}
	return 0;
}
   180ea:	4610      	mov	r0, r2
   180ec:	b017      	add	sp, #92	; 0x5c
   180ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	stop_addr = gc_addr - ate_size;
   180f2:	9b06      	ldr	r3, [sp, #24]
	gc_addr &= ADDR_SECT_MASK;
   180f4:	4a09      	ldr	r2, [pc, #36]	; (1811c <nvs_gc+0x17c>)
	gc_addr += close_ate.offset;
   180f6:	f8bd 1022 	ldrh.w	r1, [sp, #34]	; 0x22
	stop_addr = gc_addr - ate_size;
   180fa:	eba3 0808 	sub.w	r8, r3, r8
	gc_addr &= ADDR_SECT_MASK;
   180fe:	4013      	ands	r3, r2
	gc_addr += close_ate.offset;
   18100:	440b      	add	r3, r1
   18102:	9306      	str	r3, [sp, #24]
			LOG_DBG("Moving %d, len %d", gc_ate.id, gc_ate.len);
   18104:	4906      	ldr	r1, [pc, #24]	; (18120 <nvs_gc+0x180>)
   18106:	4b07      	ldr	r3, [pc, #28]	; (18124 <nvs_gc+0x184>)
   18108:	1a5b      	subs	r3, r3, r1
   1810a:	f3c3 03c9 	ubfx	r3, r3, #3, #10
			data_addr = (gc_prev_addr & ADDR_SECT_MASK);
   1810e:	e9cd 3202 	strd	r3, r2, [sp, #8]
   18112:	e797      	b.n	18044 <nvs_gc+0xa4>
   18114:	0003267a 	.word	0x0003267a
   18118:	000326b6 	.word	0x000326b6
   1811c:	ffff0000 	.word	0xffff0000
   18120:	0003040c 	.word	0x0003040c
   18124:	0003046c 	.word	0x0003046c

00018128 <nvs_init>:
	}
	return 0;
}

int nvs_init(struct nvs_fs *fs, const char *dev_name)
{
   18128:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1812c:	4604      	mov	r4, r0
   1812e:	b087      	sub	sp, #28
   18130:	460d      	mov	r5, r1

	int rc;
	struct flash_pages_info info;

	k_mutex_init(&fs->nvs_lock);
   18132:	f100 0614 	add.w	r6, r0, #20
	return z_impl_k_mutex_init(mutex);
   18136:	4630      	mov	r0, r6
   18138:	f016 ff57 	bl	2efea <z_impl_k_mutex_init>
   1813c:	4628      	mov	r0, r5
   1813e:	f00e f843 	bl	261c8 <z_impl_device_get_binding>

	fs->flash_device = device_get_binding(dev_name);
   18142:	62a0      	str	r0, [r4, #40]	; 0x28
	if (!fs->flash_device) {
   18144:	b988      	cbnz	r0, 1816a <nvs_init+0x42>
		LOG_ERR("No valid flash device found");
   18146:	2301      	movs	r3, #1
   18148:	4aa1      	ldr	r2, [pc, #644]	; (183d0 <nvs_init+0x2a8>)
   1814a:	f363 0007 	bfi	r0, r3, #0, #8
   1814e:	4ba1      	ldr	r3, [pc, #644]	; (183d4 <nvs_init+0x2ac>)
   18150:	49a1      	ldr	r1, [pc, #644]	; (183d8 <nvs_init+0x2b0>)
   18152:	1a9b      	subs	r3, r3, r2
   18154:	08db      	lsrs	r3, r3, #3
   18156:	f363 108f 	bfi	r0, r3, #6, #10
   1815a:	f015 f8cd 	bl	2d2f8 <log_string_sync>
		return -ENXIO;
   1815e:	f06f 0505 	mvn.w	r5, #5
	LOG_INF("data wra: %d, %x",
		(fs->data_wra >> ADDR_SECT_SHIFT),
		(fs->data_wra & ADDR_OFFS_MASK));

	return 0;
}
   18162:	4628      	mov	r0, r5
   18164:	b007      	add	sp, #28
   18166:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
static inline size_t z_impl_flash_get_write_block_size(struct device *dev)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->driver_api;

	return api->write_block_size;
   1816a:	6843      	ldr	r3, [r0, #4]
	fs->write_block_size = flash_get_write_block_size(fs->flash_device);
   1816c:	7d1b      	ldrb	r3, [r3, #20]
	if (fs->write_block_size > NVS_BLOCK_SIZE) {
   1816e:	2b20      	cmp	r3, #32
	fs->write_block_size = flash_get_write_block_size(fs->flash_device);
   18170:	7423      	strb	r3, [r4, #16]
	if (fs->write_block_size > NVS_BLOCK_SIZE) {
   18172:	d910      	bls.n	18196 <nvs_init+0x6e>
		LOG_ERR("Unsupported write block size");
   18174:	2301      	movs	r3, #1
   18176:	f04f 0000 	mov.w	r0, #0
   1817a:	4a95      	ldr	r2, [pc, #596]	; (183d0 <nvs_init+0x2a8>)
   1817c:	f363 0007 	bfi	r0, r3, #0, #8
   18180:	4b94      	ldr	r3, [pc, #592]	; (183d4 <nvs_init+0x2ac>)
   18182:	4996      	ldr	r1, [pc, #600]	; (183dc <nvs_init+0x2b4>)
   18184:	1a9b      	subs	r3, r3, r2
   18186:	08db      	lsrs	r3, r3, #3
   18188:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Unable to get page info");
   1818c:	f015 f8b4 	bl	2d2f8 <log_string_sync>
		return -EINVAL;
   18190:	f06f 0515 	mvn.w	r5, #21
   18194:	e7e5      	b.n	18162 <nvs_init+0x3a>
	rc = flash_get_page_info_by_offs(fs->flash_device, fs->offset, &info);
   18196:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   18198:	6821      	ldr	r1, [r4, #0]
   1819a:	aa03      	add	r2, sp, #12
   1819c:	f016 f848 	bl	2e230 <z_impl_flash_get_page_info_by_offs>
	if (rc) {
   181a0:	b160      	cbz	r0, 181bc <nvs_init+0x94>
		LOG_ERR("Unable to get page info");
   181a2:	2301      	movs	r3, #1
   181a4:	f04f 0000 	mov.w	r0, #0
   181a8:	4a89      	ldr	r2, [pc, #548]	; (183d0 <nvs_init+0x2a8>)
   181aa:	f363 0007 	bfi	r0, r3, #0, #8
   181ae:	4b89      	ldr	r3, [pc, #548]	; (183d4 <nvs_init+0x2ac>)
   181b0:	498b      	ldr	r1, [pc, #556]	; (183e0 <nvs_init+0x2b8>)
   181b2:	1a9b      	subs	r3, r3, r2
   181b4:	08db      	lsrs	r3, r3, #3
   181b6:	f363 108f 	bfi	r0, r3, #6, #10
   181ba:	e7e7      	b.n	1818c <nvs_init+0x64>
	if (!fs->sector_size || fs->sector_size % info.size) {
   181bc:	89a3      	ldrh	r3, [r4, #12]
   181be:	b12b      	cbz	r3, 181cc <nvs_init+0xa4>
   181c0:	9a04      	ldr	r2, [sp, #16]
   181c2:	fbb3 f5f2 	udiv	r5, r3, r2
   181c6:	fb02 3515 	mls	r5, r2, r5, r3
   181ca:	b165      	cbz	r5, 181e6 <nvs_init+0xbe>
		LOG_ERR("Invalid sector size");
   181cc:	2301      	movs	r3, #1
   181ce:	f04f 0000 	mov.w	r0, #0
   181d2:	4a7f      	ldr	r2, [pc, #508]	; (183d0 <nvs_init+0x2a8>)
   181d4:	f363 0007 	bfi	r0, r3, #0, #8
   181d8:	4b7e      	ldr	r3, [pc, #504]	; (183d4 <nvs_init+0x2ac>)
   181da:	4982      	ldr	r1, [pc, #520]	; (183e4 <nvs_init+0x2bc>)
   181dc:	1a9b      	subs	r3, r3, r2
   181de:	08db      	lsrs	r3, r3, #3
   181e0:	f363 108f 	bfi	r0, r3, #6, #10
   181e4:	e7d2      	b.n	1818c <nvs_init+0x64>
	if (fs->sector_count < 2) {
   181e6:	89e3      	ldrh	r3, [r4, #14]
   181e8:	2b01      	cmp	r3, #1
   181ea:	d80c      	bhi.n	18206 <nvs_init+0xde>
		LOG_ERR("Configuration error - sector count");
   181ec:	2301      	movs	r3, #1
   181ee:	f04f 0000 	mov.w	r0, #0
   181f2:	4a77      	ldr	r2, [pc, #476]	; (183d0 <nvs_init+0x2a8>)
   181f4:	f363 0007 	bfi	r0, r3, #0, #8
   181f8:	4b76      	ldr	r3, [pc, #472]	; (183d4 <nvs_init+0x2ac>)
   181fa:	497b      	ldr	r1, [pc, #492]	; (183e8 <nvs_init+0x2c0>)
   181fc:	1a9b      	subs	r3, r3, r2
   181fe:	08db      	lsrs	r3, r3, #3
   18200:	f363 108f 	bfi	r0, r3, #6, #10
   18204:	e7c2      	b.n	1818c <nvs_init+0x64>
	u32_t addr = 0U;
   18206:	9500      	str	r5, [sp, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
   18208:	f04f 31ff 	mov.w	r1, #4294967295
   1820c:	4630      	mov	r0, r6
   1820e:	f00e fcbf 	bl	26b90 <z_impl_k_mutex_lock>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   18212:	2108      	movs	r1, #8
   18214:	7c20      	ldrb	r0, [r4, #16]
   18216:	f015 f8f6 	bl	2d406 <nvs_al_size.isra.1>
	u16_t i, closed_sectors = 0;
   1821a:	46a9      	mov	r9, r5
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   1821c:	4607      	mov	r7, r0
	for (i = 0; i < fs->sector_count; i++) {
   1821e:	89e3      	ldrh	r3, [r4, #14]
   18220:	fa1f f885 	uxth.w	r8, r5
   18224:	4543      	cmp	r3, r8
   18226:	d805      	bhi.n	18234 <nvs_init+0x10c>
	if (closed_sectors == fs->sector_count) {
   18228:	89e3      	ldrh	r3, [r4, #14]
   1822a:	454b      	cmp	r3, r9
   1822c:	d11e      	bne.n	1826c <nvs_init+0x144>
		return -EDEADLK;
   1822e:	f06f 052c 	mvn.w	r5, #44	; 0x2c
   18232:	e796      	b.n	18162 <nvs_init+0x3a>
		       (u16_t)(fs->sector_size - ate_size);
   18234:	89a1      	ldrh	r1, [r4, #12]
		addr = (i << ADDR_SECT_SHIFT) +
   18236:	042b      	lsls	r3, r5, #16
		       (u16_t)(fs->sector_size - ate_size);
   18238:	1bc9      	subs	r1, r1, r7
		addr = (i << ADDR_SECT_SHIFT) +
   1823a:	fa13 f181 	uxtah	r1, r3, r1
		rc = nvs_flash_cmp_const(fs, addr, 0xff,
   1823e:	2208      	movs	r2, #8
   18240:	4620      	mov	r0, r4
		addr = (i << ADDR_SECT_SHIFT) +
   18242:	9100      	str	r1, [sp, #0]
		rc = nvs_flash_cmp_const(fs, addr, 0xff,
   18244:	f015 f8f2 	bl	2d42c <nvs_flash_cmp_const.constprop.5>
		if (rc) {
   18248:	b170      	cbz	r0, 18268 <nvs_init+0x140>
			nvs_sector_advance(fs, &addr);
   1824a:	4669      	mov	r1, sp
   1824c:	89e0      	ldrh	r0, [r4, #14]
   1824e:	f015 f8e3 	bl	2d418 <nvs_sector_advance.isra.2>
			closed_sectors++;
   18252:	f109 0901 	add.w	r9, r9, #1
			rc = nvs_flash_cmp_const(fs, addr, 0xff,
   18256:	2208      	movs	r2, #8
   18258:	9900      	ldr	r1, [sp, #0]
   1825a:	4620      	mov	r0, r4
			closed_sectors++;
   1825c:	fa1f f989 	uxth.w	r9, r9
			rc = nvs_flash_cmp_const(fs, addr, 0xff,
   18260:	f015 f8e4 	bl	2d42c <nvs_flash_cmp_const.constprop.5>
			if (!rc) {
   18264:	2800      	cmp	r0, #0
   18266:	d0df      	beq.n	18228 <nvs_init+0x100>
   18268:	3501      	adds	r5, #1
   1826a:	e7d8      	b.n	1821e <nvs_init+0xf6>
	if (i == fs->sector_count) {
   1826c:	4598      	cmp	r8, r3
   1826e:	d10a      	bne.n	18286 <nvs_init+0x15e>
		rc = nvs_flash_cmp_const(fs, addr - ate_size, 0xff,
   18270:	9900      	ldr	r1, [sp, #0]
   18272:	2208      	movs	r2, #8
   18274:	1bc9      	subs	r1, r1, r7
   18276:	4620      	mov	r0, r4
   18278:	f015 f8d8 	bl	2d42c <nvs_flash_cmp_const.constprop.5>
		if (!rc) {
   1827c:	b918      	cbnz	r0, 18286 <nvs_init+0x15e>
			nvs_sector_advance(fs, &addr);
   1827e:	4669      	mov	r1, sp
   18280:	89e0      	ldrh	r0, [r4, #14]
   18282:	f015 f8c9 	bl	2d418 <nvs_sector_advance.isra.2>
	fs->ate_wra = addr - ate_size;
   18286:	9b00      	ldr	r3, [sp, #0]
   18288:	1bda      	subs	r2, r3, r7
   1828a:	6062      	str	r2, [r4, #4]
	fs->data_wra = addr & ADDR_SECT_MASK;
   1828c:	4a57      	ldr	r2, [pc, #348]	; (183ec <nvs_init+0x2c4>)
			fs->data_wra = addr & ADDR_SECT_MASK;
   1828e:	4690      	mov	r8, r2
	fs->data_wra = addr & ADDR_SECT_MASK;
   18290:	4013      	ands	r3, r2
   18292:	60a3      	str	r3, [r4, #8]
	while (fs->ate_wra >= fs->data_wra) {
   18294:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
   18298:	4299      	cmp	r1, r3
   1829a:	d30e      	bcc.n	182ba <nvs_init+0x192>
	return nvs_flash_rd(fs, addr, entry, sizeof(struct nvs_ate));
   1829c:	2308      	movs	r3, #8
   1829e:	aa01      	add	r2, sp, #4
   182a0:	4620      	mov	r0, r4
   182a2:	f015 f865 	bl	2d370 <nvs_flash_rd>
		if (rc) {
   182a6:	4605      	mov	r5, r0
   182a8:	bb18      	cbnz	r0, 182f2 <nvs_init+0x1ca>
   182aa:	ab01      	add	r3, sp, #4
		if (data8[i] != value) {
   182ac:	f813 2b01 	ldrb.w	r2, [r3], #1
   182b0:	2aff      	cmp	r2, #255	; 0xff
   182b2:	d175      	bne.n	183a0 <nvs_init+0x278>
	for (i = 0; i < sizeof(struct nvs_ate); i++) {
   182b4:	3501      	adds	r5, #1
   182b6:	2d08      	cmp	r5, #8
   182b8:	d1f8      	bne.n	182ac <nvs_init+0x184>
	while (fs->ate_wra > fs->data_wra) {
   182ba:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
   182be:	428a      	cmp	r2, r1
   182c0:	d906      	bls.n	182d0 <nvs_init+0x1a8>
		rc = nvs_flash_cmp_const(fs, fs->data_wra, 0xff, empty_len);
   182c2:	1a52      	subs	r2, r2, r1
   182c4:	4620      	mov	r0, r4
   182c6:	f015 f8b1 	bl	2d42c <nvs_flash_cmp_const.constprop.5>
		if (rc < 0) {
   182ca:	1e05      	subs	r5, r0, #0
   182cc:	db11      	blt.n	182f2 <nvs_init+0x1ca>
		if (!rc) {
   182ce:	d14a      	bne.n	18366 <nvs_init+0x23e>
	addr = fs->ate_wra & ADDR_SECT_MASK;
   182d0:	6863      	ldr	r3, [r4, #4]
   182d2:	f8df 8118 	ldr.w	r8, [pc, #280]	; 183ec <nvs_init+0x2c4>
	nvs_sector_advance(fs, &addr);
   182d6:	4669      	mov	r1, sp
	addr = fs->ate_wra & ADDR_SECT_MASK;
   182d8:	ea03 0308 	and.w	r3, r3, r8
	nvs_sector_advance(fs, &addr);
   182dc:	89e0      	ldrh	r0, [r4, #14]
	addr = fs->ate_wra & ADDR_SECT_MASK;
   182de:	9300      	str	r3, [sp, #0]
	nvs_sector_advance(fs, &addr);
   182e0:	f015 f89a 	bl	2d418 <nvs_sector_advance.isra.2>
	rc = nvs_flash_cmp_const(fs, addr, 0xff, fs->sector_size);
   182e4:	89a2      	ldrh	r2, [r4, #12]
   182e6:	9900      	ldr	r1, [sp, #0]
   182e8:	4620      	mov	r0, r4
   182ea:	f015 f89f 	bl	2d42c <nvs_flash_cmp_const.constprop.5>
	if (rc < 0) {
   182ee:	1e05      	subs	r5, r0, #0
   182f0:	da3e      	bge.n	18370 <nvs_init+0x248>
	return z_impl_k_mutex_unlock(mutex);
   182f2:	4630      	mov	r0, r6
   182f4:	f00e fd2a 	bl	26d4c <z_impl_k_mutex_unlock>
	if (rc) {
   182f8:	2d00      	cmp	r5, #0
   182fa:	f47f af32 	bne.w	18162 <nvs_init+0x3a>
	fs->ready = true;
   182fe:	2301      	movs	r3, #1
	LOG_INF("%d Sectors of %d bytes", fs->sector_count, fs->sector_size);
   18300:	f04f 0000 	mov.w	r0, #0
	fs->ready = true;
   18304:	7463      	strb	r3, [r4, #17]
	LOG_INF("%d Sectors of %d bytes", fs->sector_count, fs->sector_size);
   18306:	2303      	movs	r3, #3
   18308:	4e32      	ldr	r6, [pc, #200]	; (183d4 <nvs_init+0x2ac>)
   1830a:	f363 0007 	bfi	r0, r3, #0, #8
   1830e:	4b30      	ldr	r3, [pc, #192]	; (183d0 <nvs_init+0x2a8>)
   18310:	89e2      	ldrh	r2, [r4, #14]
   18312:	1af6      	subs	r6, r6, r3
   18314:	f3c6 06c9 	ubfx	r6, r6, #3, #10
   18318:	f366 108f 	bfi	r0, r6, #6, #10
   1831c:	89a3      	ldrh	r3, [r4, #12]
   1831e:	4934      	ldr	r1, [pc, #208]	; (183f0 <nvs_init+0x2c8>)
   18320:	f014 ffea 	bl	2d2f8 <log_string_sync>
	LOG_INF("alloc wra: %d, %x",
   18324:	2303      	movs	r3, #3
   18326:	f04f 0000 	mov.w	r0, #0
   1832a:	6862      	ldr	r2, [r4, #4]
   1832c:	f363 0007 	bfi	r0, r3, #0, #8
   18330:	f366 108f 	bfi	r0, r6, #6, #10
   18334:	b293      	uxth	r3, r2
   18336:	492f      	ldr	r1, [pc, #188]	; (183f4 <nvs_init+0x2cc>)
   18338:	0c12      	lsrs	r2, r2, #16
   1833a:	f014 ffdd 	bl	2d2f8 <log_string_sync>
	LOG_INF("data wra: %d, %x",
   1833e:	2303      	movs	r3, #3
   18340:	f04f 0000 	mov.w	r0, #0
   18344:	68a2      	ldr	r2, [r4, #8]
   18346:	f363 0007 	bfi	r0, r3, #0, #8
   1834a:	f366 108f 	bfi	r0, r6, #6, #10
   1834e:	b293      	uxth	r3, r2
   18350:	4929      	ldr	r1, [pc, #164]	; (183f8 <nvs_init+0x2d0>)
   18352:	0c12      	lsrs	r2, r2, #16
   18354:	f014 ffd0 	bl	2d2f8 <log_string_sync>
	return 0;
   18358:	e703      	b.n	18162 <nvs_init+0x3a>
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
   1835a:	f1b9 0f00 	cmp.w	r9, #0
   1835e:	d034      	beq.n	183ca <nvs_init+0x2a2>
				return -ESPIPE;
   18360:	f06f 051c 	mvn.w	r5, #28
   18364:	e6fd      	b.n	18162 <nvs_init+0x3a>
		fs->data_wra += fs->write_block_size;
   18366:	68a3      	ldr	r3, [r4, #8]
   18368:	7c22      	ldrb	r2, [r4, #16]
   1836a:	4413      	add	r3, r2
   1836c:	60a3      	str	r3, [r4, #8]
   1836e:	e7a4      	b.n	182ba <nvs_init+0x192>
	if (rc) {
   18370:	d0bf      	beq.n	182f2 <nvs_init+0x1ca>
		rc = nvs_flash_erase_sector(fs, fs->ate_wra);
   18372:	6861      	ldr	r1, [r4, #4]
   18374:	4620      	mov	r0, r4
   18376:	f7ff fd5f 	bl	17e38 <nvs_flash_erase_sector>
		if (rc) {
   1837a:	4605      	mov	r5, r0
   1837c:	2800      	cmp	r0, #0
   1837e:	d1b8      	bne.n	182f2 <nvs_init+0x1ca>
		fs->ate_wra &= ADDR_SECT_MASK;
   18380:	6860      	ldr	r0, [r4, #4]
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
   18382:	89a3      	ldrh	r3, [r4, #12]
		fs->ate_wra &= ADDR_SECT_MASK;
   18384:	ea00 0008 	and.w	r0, r0, r8
		fs->ate_wra += (fs->sector_size - 2 * ate_size);
   18388:	4418      	add	r0, r3
   1838a:	eba0 0047 	sub.w	r0, r0, r7, lsl #1
   1838e:	6060      	str	r0, [r4, #4]
		fs->data_wra = (fs->ate_wra & ADDR_SECT_MASK);
   18390:	ea00 0008 	and.w	r0, r0, r8
   18394:	60a0      	str	r0, [r4, #8]
		rc = nvs_gc(fs);
   18396:	4620      	mov	r0, r4
   18398:	f7ff fe02 	bl	17fa0 <nvs_gc>
   1839c:	4605      	mov	r5, r0
		if (rc) {
   1839e:	e7a8      	b.n	182f2 <nvs_init+0x1ca>
		if (!nvs_ate_crc8_check(&last_ate)) {
   183a0:	a801      	add	r0, sp, #4
   183a2:	f015 f81b 	bl	2d3dc <nvs_ate_crc8_check>
   183a6:	6865      	ldr	r5, [r4, #4]
   183a8:	b978      	cbnz	r0, 183ca <nvs_init+0x2a2>
			fs->data_wra = addr & ADDR_SECT_MASK;
   183aa:	9800      	ldr	r0, [sp, #0]
			fs->data_wra += last_ate.offset;
   183ac:	f8bd 2006 	ldrh.w	r2, [sp, #6]
			fs->data_wra += nvs_al_size(fs, last_ate.len);
   183b0:	f8bd 9008 	ldrh.w	r9, [sp, #8]
			fs->data_wra = addr & ADDR_SECT_MASK;
   183b4:	ea00 0008 	and.w	r0, r0, r8
			fs->data_wra += last_ate.offset;
   183b8:	4402      	add	r2, r0
			fs->data_wra += nvs_al_size(fs, last_ate.len);
   183ba:	4649      	mov	r1, r9
   183bc:	7c20      	ldrb	r0, [r4, #16]
   183be:	f015 f822 	bl	2d406 <nvs_al_size.isra.1>
   183c2:	4410      	add	r0, r2
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
   183c4:	42a8      	cmp	r0, r5
			fs->data_wra += nvs_al_size(fs, last_ate.len);
   183c6:	60a0      	str	r0, [r4, #8]
			if (fs->ate_wra == fs->data_wra && last_ate.len) {
   183c8:	d0c7      	beq.n	1835a <nvs_init+0x232>
		fs->ate_wra -= ate_size;
   183ca:	1bed      	subs	r5, r5, r7
   183cc:	6065      	str	r5, [r4, #4]
   183ce:	e761      	b.n	18294 <nvs_init+0x16c>
   183d0:	0003040c 	.word	0x0003040c
   183d4:	0003046c 	.word	0x0003046c
   183d8:	000326cc 	.word	0x000326cc
   183dc:	000326e8 	.word	0x000326e8
   183e0:	00032705 	.word	0x00032705
   183e4:	0003271d 	.word	0x0003271d
   183e8:	00032731 	.word	0x00032731
   183ec:	ffff0000 	.word	0xffff0000
   183f0:	00032754 	.word	0x00032754
   183f4:	0003276b 	.word	0x0003276b
   183f8:	0003277d 	.word	0x0003277d

000183fc <nvs_write>:

ssize_t nvs_write(struct nvs_fs *fs, u16_t id, const void *data, size_t len)
{
   183fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18400:	461e      	mov	r6, r3
	struct nvs_ate wlk_ate;
	u32_t wlk_addr, rd_addr;
	u16_t required_space = 0U; /* no space, appropriate for delete ate */
	bool prev_found = false;

	if (!fs->ready) {
   18402:	7c43      	ldrb	r3, [r0, #17]
{
   18404:	b089      	sub	sp, #36	; 0x24
   18406:	4604      	mov	r4, r0
   18408:	4689      	mov	r9, r1
   1840a:	4690      	mov	r8, r2
	if (!fs->ready) {
   1840c:	b99b      	cbnz	r3, 18436 <nvs_write+0x3a>
		LOG_ERR("NVS not initialized");
   1840e:	2301      	movs	r3, #1
   18410:	f04f 0000 	mov.w	r0, #0
   18414:	4a68      	ldr	r2, [pc, #416]	; (185b8 <nvs_write+0x1bc>)
   18416:	f363 0007 	bfi	r0, r3, #0, #8
   1841a:	4b68      	ldr	r3, [pc, #416]	; (185bc <nvs_write+0x1c0>)
   1841c:	4968      	ldr	r1, [pc, #416]	; (185c0 <nvs_write+0x1c4>)
   1841e:	1a9b      	subs	r3, r3, r2
   18420:	08db      	lsrs	r3, r3, #3
   18422:	f363 108f 	bfi	r0, r3, #6, #10
   18426:	f014 ff67 	bl	2d2f8 <log_string_sync>
		return -EACCES;
   1842a:	f06f 050c 	mvn.w	r5, #12
	}
	rc = len;
end:
	k_mutex_unlock(&fs->nvs_lock);
	return rc;
}
   1842e:	4628      	mov	r0, r5
   18430:	b009      	add	sp, #36	; 0x24
   18432:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   18436:	f890 a010 	ldrb.w	sl, [r0, #16]
   1843a:	2108      	movs	r1, #8
   1843c:	4650      	mov	r0, sl
   1843e:	f014 ffe2 	bl	2d406 <nvs_al_size.isra.1>
	if ((len > (fs->sector_size - 3 * ate_size)) ||
   18442:	89a3      	ldrh	r3, [r4, #12]
   18444:	eb00 0240 	add.w	r2, r0, r0, lsl #1
   18448:	1a9b      	subs	r3, r3, r2
   1844a:	42b3      	cmp	r3, r6
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   1844c:	4607      	mov	r7, r0
	if ((len > (fs->sector_size - 3 * ate_size)) ||
   1844e:	f0c0 80ae 	bcc.w	185ae <nvs_write+0x1b2>
   18452:	b11e      	cbz	r6, 1845c <nvs_write+0x60>
	    ((len > 0) && (data == NULL))) {
   18454:	f1b8 0f00 	cmp.w	r8, #0
   18458:	f000 80a9 	beq.w	185ae <nvs_write+0x1b2>
	wlk_addr = fs->ate_wra;
   1845c:	6863      	ldr	r3, [r4, #4]
   1845e:	9303      	str	r3, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   18460:	aa04      	add	r2, sp, #16
   18462:	a903      	add	r1, sp, #12
   18464:	4620      	mov	r0, r4
		rd_addr = wlk_addr;
   18466:	f8dd b00c 	ldr.w	fp, [sp, #12]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   1846a:	f7ff fd27 	bl	17ebc <nvs_prev_ate>
		if (rc) {
   1846e:	4605      	mov	r5, r0
   18470:	2800      	cmp	r0, #0
   18472:	d1dc      	bne.n	1842e <nvs_write+0x32>
		if ((wlk_ate.id == id) && (!nvs_ate_crc8_check(&wlk_ate))) {
   18474:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   18478:	454b      	cmp	r3, r9
   1847a:	d005      	beq.n	18488 <nvs_write+0x8c>
		if (wlk_addr == fs->ate_wra) {
   1847c:	6862      	ldr	r2, [r4, #4]
   1847e:	9b03      	ldr	r3, [sp, #12]
   18480:	429a      	cmp	r2, r3
   18482:	d1ed      	bne.n	18460 <nvs_write+0x64>
		if (len == 0) {
   18484:	b9de      	cbnz	r6, 184be <nvs_write+0xc2>
   18486:	e7d2      	b.n	1842e <nvs_write+0x32>
		if ((wlk_ate.id == id) && (!nvs_ate_crc8_check(&wlk_ate))) {
   18488:	a804      	add	r0, sp, #16
   1848a:	f014 ffa7 	bl	2d3dc <nvs_ate_crc8_check>
   1848e:	2800      	cmp	r0, #0
   18490:	d1f4      	bne.n	1847c <nvs_write+0x80>
		if (len == 0) {
   18492:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   18496:	b186      	cbz	r6, 184ba <nvs_write+0xbe>
		} else if (len == wlk_ate.len) {
   18498:	42b3      	cmp	r3, r6
   1849a:	d110      	bne.n	184be <nvs_write+0xc2>
		rd_addr += wlk_ate.offset;
   1849c:	f8bd 0012 	ldrh.w	r0, [sp, #18]
		rd_addr &= ADDR_SECT_MASK;
   184a0:	ea4f 411b 	mov.w	r1, fp, lsr #16
   184a4:	0409      	lsls	r1, r1, #16
			rc = nvs_flash_block_cmp(fs, rd_addr, data, len);
   184a6:	4401      	add	r1, r0
   184a8:	4633      	mov	r3, r6
   184aa:	4642      	mov	r2, r8
   184ac:	4620      	mov	r0, r4
   184ae:	f014 ff6d 	bl	2d38c <nvs_flash_block_cmp>
			if (rc <= 0) {
   184b2:	2800      	cmp	r0, #0
   184b4:	dc03      	bgt.n	184be <nvs_write+0xc2>
   184b6:	4605      	mov	r5, r0
   184b8:	e7b9      	b.n	1842e <nvs_write+0x32>
			if (wlk_ate.len == 0U) {
   184ba:	2b00      	cmp	r3, #0
   184bc:	d0b7      	beq.n	1842e <nvs_write+0x32>
	data_size = nvs_al_size(fs, len);
   184be:	4631      	mov	r1, r6
   184c0:	4650      	mov	r0, sl
   184c2:	f014 ffa0 	bl	2d406 <nvs_al_size.isra.1>
	if (data_size) {
   184c6:	2800      	cmp	r0, #0
   184c8:	d13e      	bne.n	18548 <nvs_write+0x14c>
	u16_t required_space = 0U; /* no space, appropriate for delete ate */
   184ca:	4607      	mov	r7, r0
	k_mutex_lock(&fs->nvs_lock, K_FOREVER);
   184cc:	f104 0a14 	add.w	sl, r4, #20
	return z_impl_k_mutex_lock(mutex, timeout);
   184d0:	f04f 31ff 	mov.w	r1, #4294967295
   184d4:	4650      	mov	r0, sl
   184d6:	f00e fb5b 	bl	26b90 <z_impl_k_mutex_lock>
	gc_count = 0;
   184da:	2300      	movs	r3, #0
	fs->ate_wra &= ADDR_SECT_MASK;
   184dc:	f8df b0e4 	ldr.w	fp, [pc, #228]	; 185c4 <nvs_write+0x1c8>
		if (gc_count == fs->sector_count) {
   184e0:	89e2      	ldrh	r2, [r4, #14]
   184e2:	4293      	cmp	r3, r2
   184e4:	d060      	beq.n	185a8 <nvs_write+0x1ac>
		if (fs->ate_wra >= fs->data_wra + required_space) {
   184e6:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
   184ea:	1878      	adds	r0, r7, r1
   184ec:	4282      	cmp	r2, r0
   184ee:	d32e      	bcc.n	1854e <nvs_write+0x152>
	entry.part = 0xff;
   184f0:	23ff      	movs	r3, #255	; 0xff
	nvs_ate_crc8_update(&entry);
   184f2:	a806      	add	r0, sp, #24
	entry.id = id;
   184f4:	f8ad 9018 	strh.w	r9, [sp, #24]
	entry.offset = (u16_t)(fs->data_wra & ADDR_OFFS_MASK);
   184f8:	f8ad 101a 	strh.w	r1, [sp, #26]
	entry.len = (u16_t)len;
   184fc:	f8ad 601c 	strh.w	r6, [sp, #28]
	entry.part = 0xff;
   18500:	f88d 301e 	strb.w	r3, [sp, #30]
	nvs_ate_crc8_update(&entry);
   18504:	f014 ff76 	bl	2d3f4 <nvs_ate_crc8_update>
	if (!len) {
   18508:	b136      	cbz	r6, 18518 <nvs_write+0x11c>
   1850a:	4633      	mov	r3, r6
   1850c:	4642      	mov	r2, r8
   1850e:	68a1      	ldr	r1, [r4, #8]
   18510:	4620      	mov	r0, r4
   18512:	f014 ffaf 	bl	2d474 <nvs_flash_al_wrt.part.3>
   18516:	4605      	mov	r5, r0
	fs->data_wra += nvs_al_size(fs, len);
   18518:	4631      	mov	r1, r6
   1851a:	7c20      	ldrb	r0, [r4, #16]
   1851c:	f014 ff73 	bl	2d406 <nvs_al_size.isra.1>
   18520:	68a3      	ldr	r3, [r4, #8]
   18522:	4418      	add	r0, r3
   18524:	60a0      	str	r0, [r4, #8]
	if (rc) {
   18526:	2d00      	cmp	r5, #0
   18528:	d144      	bne.n	185b4 <nvs_write+0x1b8>
	rc = nvs_flash_ate_wrt(fs, &entry);
   1852a:	a906      	add	r1, sp, #24
   1852c:	4620      	mov	r0, r4
   1852e:	f014 ffe7 	bl	2d500 <nvs_flash_ate_wrt>
	if (rc) {
   18532:	4605      	mov	r5, r0
   18534:	2800      	cmp	r0, #0
   18536:	d13d      	bne.n	185b4 <nvs_write+0x1b8>
	rc = len;
   18538:	4632      	mov	r2, r6
   1853a:	9201      	str	r2, [sp, #4]
	return z_impl_k_mutex_unlock(mutex);
   1853c:	4650      	mov	r0, sl
   1853e:	f00e fc05 	bl	26d4c <z_impl_k_mutex_unlock>
	return rc;
   18542:	9a01      	ldr	r2, [sp, #4]
   18544:	4615      	mov	r5, r2
   18546:	e772      	b.n	1842e <nvs_write+0x32>
		required_space = data_size + ate_size;
   18548:	4407      	add	r7, r0
   1854a:	b2bf      	uxth	r7, r7
   1854c:	e7be      	b.n	184cc <nvs_write+0xd0>
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   1854e:	2108      	movs	r1, #8
   18550:	7c20      	ldrb	r0, [r4, #16]
   18552:	9301      	str	r3, [sp, #4]
   18554:	f014 ff57 	bl	2d406 <nvs_al_size.isra.1>
	close_ate.id = 0xFFFF;
   18558:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1855c:	f8ad 1018 	strh.w	r1, [sp, #24]
	close_ate.len = 0U;
   18560:	2100      	movs	r1, #0
   18562:	f8ad 101c 	strh.w	r1, [sp, #28]
	close_ate.offset = (u16_t)((fs->ate_wra + ate_size) & ADDR_OFFS_MASK);
   18566:	1811      	adds	r1, r2, r0
   18568:	f8ad 101a 	strh.w	r1, [sp, #26]
	fs->ate_wra += (fs->sector_size - ate_size);
   1856c:	89a1      	ldrh	r1, [r4, #12]
	fs->ate_wra &= ADDR_SECT_MASK;
   1856e:	ea02 020b 	and.w	r2, r2, fp
	fs->ate_wra += (fs->sector_size - ate_size);
   18572:	440a      	add	r2, r1
   18574:	1a12      	subs	r2, r2, r0
   18576:	6062      	str	r2, [r4, #4]
	nvs_ate_crc8_update(&close_ate);
   18578:	a806      	add	r0, sp, #24
   1857a:	f014 ff3b 	bl	2d3f4 <nvs_ate_crc8_update>
	rc = nvs_flash_ate_wrt(fs, &close_ate);
   1857e:	a906      	add	r1, sp, #24
   18580:	4620      	mov	r0, r4
   18582:	f014 ffbd 	bl	2d500 <nvs_flash_ate_wrt>
	nvs_sector_advance(fs, &fs->ate_wra);
   18586:	1d21      	adds	r1, r4, #4
   18588:	89e0      	ldrh	r0, [r4, #14]
   1858a:	f014 ff45 	bl	2d418 <nvs_sector_advance.isra.2>
	fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
   1858e:	6862      	ldr	r2, [r4, #4]
		rc = nvs_gc(fs);
   18590:	4620      	mov	r0, r4
	fs->data_wra = fs->ate_wra & ADDR_SECT_MASK;
   18592:	ea02 020b 	and.w	r2, r2, fp
   18596:	60a2      	str	r2, [r4, #8]
		rc = nvs_gc(fs);
   18598:	f7ff fd02 	bl	17fa0 <nvs_gc>
		if (rc) {
   1859c:	4602      	mov	r2, r0
   1859e:	2800      	cmp	r0, #0
   185a0:	d1cb      	bne.n	1853a <nvs_write+0x13e>
		gc_count++;
   185a2:	9b01      	ldr	r3, [sp, #4]
   185a4:	3301      	adds	r3, #1
		if (gc_count == fs->sector_count) {
   185a6:	e79b      	b.n	184e0 <nvs_write+0xe4>
			rc = -ENOSPC;
   185a8:	f06f 021b 	mvn.w	r2, #27
   185ac:	e7c5      	b.n	1853a <nvs_write+0x13e>
		return -EINVAL;
   185ae:	f06f 0515 	mvn.w	r5, #21
   185b2:	e73c      	b.n	1842e <nvs_write+0x32>
			if (rc) {
   185b4:	462a      	mov	r2, r5
   185b6:	e7c0      	b.n	1853a <nvs_write+0x13e>
   185b8:	0003040c 	.word	0x0003040c
   185bc:	0003046c 	.word	0x0003046c
   185c0:	00032681 	.word	0x00032681
   185c4:	ffff0000 	.word	0xffff0000

000185c8 <nvs_read_hist>:
	return nvs_write(fs, id, NULL, 0);
}

ssize_t nvs_read_hist(struct nvs_fs *fs, u16_t id, void *data, size_t len,
		      u16_t cnt)
{
   185c8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   185cc:	461f      	mov	r7, r3
	u32_t wlk_addr, rd_addr;
	u16_t cnt_his;
	struct nvs_ate wlk_ate;
	size_t ate_size;

	if (!fs->ready) {
   185ce:	7c43      	ldrb	r3, [r0, #17]
{
   185d0:	4604      	mov	r4, r0
   185d2:	468a      	mov	sl, r1
   185d4:	4691      	mov	r9, r2
   185d6:	f8bd 8030 	ldrh.w	r8, [sp, #48]	; 0x30
	if (!fs->ready) {
   185da:	b993      	cbnz	r3, 18602 <nvs_read_hist+0x3a>
		LOG_ERR("NVS not initialized");
   185dc:	2301      	movs	r3, #1
   185de:	f04f 0000 	mov.w	r0, #0
   185e2:	4a2a      	ldr	r2, [pc, #168]	; (1868c <nvs_read_hist+0xc4>)
   185e4:	f363 0007 	bfi	r0, r3, #0, #8
   185e8:	4b29      	ldr	r3, [pc, #164]	; (18690 <nvs_read_hist+0xc8>)
   185ea:	492a      	ldr	r1, [pc, #168]	; (18694 <nvs_read_hist+0xcc>)
   185ec:	1a9b      	subs	r3, r3, r2
   185ee:	08db      	lsrs	r3, r3, #3
   185f0:	f363 108f 	bfi	r0, r3, #6, #10
   185f4:	f014 fe80 	bl	2d2f8 <log_string_sync>
		return -EACCES;
   185f8:	f06f 000c 	mvn.w	r0, #12

	return wlk_ate.len;

err:
	return rc;
}
   185fc:	b004      	add	sp, #16
   185fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ate_size = nvs_al_size(fs, sizeof(struct nvs_ate));
   18602:	2108      	movs	r1, #8
   18604:	7c00      	ldrb	r0, [r0, #16]
   18606:	f014 fefe 	bl	2d406 <nvs_al_size.isra.1>
	if (len > (fs->sector_size - 2 * ate_size)) {
   1860a:	89a3      	ldrh	r3, [r4, #12]
   1860c:	eba3 0040 	sub.w	r0, r3, r0, lsl #1
   18610:	42b8      	cmp	r0, r7
   18612:	d338      	bcc.n	18686 <nvs_read_hist+0xbe>
	cnt_his = 0U;
   18614:	2500      	movs	r5, #0
	wlk_addr = fs->ate_wra;
   18616:	6863      	ldr	r3, [r4, #4]
   18618:	9301      	str	r3, [sp, #4]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   1861a:	aa02      	add	r2, sp, #8
   1861c:	a901      	add	r1, sp, #4
   1861e:	4620      	mov	r0, r4
		rd_addr = wlk_addr;
   18620:	9e01      	ldr	r6, [sp, #4]
		rc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);
   18622:	f7ff fc4b 	bl	17ebc <nvs_prev_ate>
		if (rc) {
   18626:	2800      	cmp	r0, #0
   18628:	d1e8      	bne.n	185fc <nvs_read_hist+0x34>
		if ((wlk_ate.id == id) &&  (!nvs_ate_crc8_check(&wlk_ate))) {
   1862a:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   1862e:	4553      	cmp	r3, sl
   18630:	d105      	bne.n	1863e <nvs_read_hist+0x76>
   18632:	a802      	add	r0, sp, #8
   18634:	f014 fed2 	bl	2d3dc <nvs_ate_crc8_check>
   18638:	b908      	cbnz	r0, 1863e <nvs_read_hist+0x76>
			cnt_his++;
   1863a:	3501      	adds	r5, #1
   1863c:	b2ad      	uxth	r5, r5
		if (wlk_addr == fs->ate_wra) {
   1863e:	6862      	ldr	r2, [r4, #4]
   18640:	9b01      	ldr	r3, [sp, #4]
   18642:	429a      	cmp	r2, r3
   18644:	d018      	beq.n	18678 <nvs_read_hist+0xb0>
	while (cnt_his <= cnt) {
   18646:	4545      	cmp	r5, r8
   18648:	d9e7      	bls.n	1861a <nvs_read_hist+0x52>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
   1864a:	f8bd 300c 	ldrh.w	r3, [sp, #12]
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
   1864e:	b1bb      	cbz	r3, 18680 <nvs_read_hist+0xb8>
	    (wlk_ate.len == 0U) || (cnt_his < cnt)) {
   18650:	4545      	cmp	r5, r8
   18652:	d315      	bcc.n	18680 <nvs_read_hist+0xb8>
	rd_addr += wlk_ate.offset;
   18654:	f8bd 000a 	ldrh.w	r0, [sp, #10]
	rd_addr &= ADDR_SECT_MASK;
   18658:	0c31      	lsrs	r1, r6, #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
   1865a:	42bb      	cmp	r3, r7
	rd_addr &= ADDR_SECT_MASK;
   1865c:	ea4f 4101 	mov.w	r1, r1, lsl #16
	rc = nvs_flash_rd(fs, rd_addr, data, MIN(len, wlk_ate.len));
   18660:	bf28      	it	cs
   18662:	463b      	movcs	r3, r7
   18664:	4401      	add	r1, r0
   18666:	464a      	mov	r2, r9
   18668:	4620      	mov	r0, r4
   1866a:	f014 fe81 	bl	2d370 <nvs_flash_rd>
	if (rc) {
   1866e:	2800      	cmp	r0, #0
   18670:	d1c4      	bne.n	185fc <nvs_read_hist+0x34>
	return wlk_ate.len;
   18672:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   18676:	e7c1      	b.n	185fc <nvs_read_hist+0x34>
	if (((wlk_addr == fs->ate_wra) && (wlk_ate.id != id)) ||
   18678:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   1867c:	4553      	cmp	r3, sl
   1867e:	d0e4      	beq.n	1864a <nvs_read_hist+0x82>
		return -ENOENT;
   18680:	f06f 0001 	mvn.w	r0, #1
   18684:	e7ba      	b.n	185fc <nvs_read_hist+0x34>
		return -EINVAL;
   18686:	f06f 0015 	mvn.w	r0, #21
   1868a:	e7b7      	b.n	185fc <nvs_read_hist+0x34>
   1868c:	0003040c 	.word	0x0003040c
   18690:	0003046c 	.word	0x0003046c
   18694:	00032681 	.word	0x00032681

00018698 <socket_offload_register>:

/* Only one provider may register socket operations upon boot. */
const struct socket_offload *socket_ops;

void socket_offload_register(const struct socket_offload *ops)
{
   18698:	b538      	push	{r3, r4, r5, lr}
	__ASSERT_NO_MSG(ops);
   1869a:	4605      	mov	r5, r0
   1869c:	b948      	cbnz	r0, 186b2 <socket_offload_register+0x1a>
   1869e:	490c      	ldr	r1, [pc, #48]	; (186d0 <socket_offload_register+0x38>)
   186a0:	480c      	ldr	r0, [pc, #48]	; (186d4 <socket_offload_register+0x3c>)
   186a2:	2311      	movs	r3, #17
   186a4:	4a0c      	ldr	r2, [pc, #48]	; (186d8 <socket_offload_register+0x40>)
   186a6:	f014 fdd0 	bl	2d24a <printk>
   186aa:	2111      	movs	r1, #17
   186ac:	480a      	ldr	r0, [pc, #40]	; (186d8 <socket_offload_register+0x40>)
   186ae:	f014 fe12 	bl	2d2d6 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops == NULL);
   186b2:	4c0a      	ldr	r4, [pc, #40]	; (186dc <socket_offload_register+0x44>)
   186b4:	6822      	ldr	r2, [r4, #0]
   186b6:	b14a      	cbz	r2, 186cc <socket_offload_register+0x34>
   186b8:	4909      	ldr	r1, [pc, #36]	; (186e0 <socket_offload_register+0x48>)
   186ba:	4806      	ldr	r0, [pc, #24]	; (186d4 <socket_offload_register+0x3c>)
   186bc:	2312      	movs	r3, #18
   186be:	4a06      	ldr	r2, [pc, #24]	; (186d8 <socket_offload_register+0x40>)
   186c0:	f014 fdc3 	bl	2d24a <printk>
   186c4:	2112      	movs	r1, #18
   186c6:	4804      	ldr	r0, [pc, #16]	; (186d8 <socket_offload_register+0x40>)
   186c8:	f014 fe05 	bl	2d2d6 <assert_post_action>

	socket_ops = ops;
   186cc:	6025      	str	r5, [r4, #0]
}
   186ce:	bd38      	pop	{r3, r4, r5, pc}
   186d0:	00031adc 	.word	0x00031adc
   186d4:	000311a3 	.word	0x000311a3
   186d8:	00032795 	.word	0x00032795
   186dc:	20028668 	.word	0x20028668
   186e0:	000327d0 	.word	0x000327d0

000186e4 <clk_init>:
 * symbol.
 */
void nrf_power_clock_isr(void *arg);

static int clk_init(struct device *dev)
{
   186e4:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   186e6:	2200      	movs	r2, #0
{
   186e8:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   186ea:	2101      	movs	r1, #1
   186ec:	2005      	movs	r0, #5
   186ee:	f000 fc9d 	bl	1902c <z_arm_irq_priority_set>
		    DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0_PRIORITY,
		    nrf_power_clock_isr, 0, 0);

	irq_enable(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0);
   186f2:	2005      	movs	r0, #5
   186f4:	f000 fc8a 	bl	1900c <arch_irq_enable>
    return false;
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
   186f8:	2202      	movs	r2, #2
   186fa:	4b07      	ldr	r3, [pc, #28]	; (18718 <clk_init+0x34>)
 *
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
   186fc:	2000      	movs	r0, #0
   186fe:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    p_reg->INTENSET = mask;
   18702:	2203      	movs	r2, #3
   18704:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

	clock_irqs_enable();

	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		sys_slist_init(&(get_sub_data(dev, i)->list));
   18708:	68a3      	ldr	r3, [r4, #8]
	list->tail = NULL;
   1870a:	e9c3 0000 	strd	r0, r0, [r3]
   1870e:	68a3      	ldr	r3, [r4, #8]
   18710:	e9c3 0003 	strd	r0, r0, [r3, #12]
	}

	return 0;
}
   18714:	bd10      	pop	{r4, pc}
   18716:	bf00      	nop
   18718:	40005000 	.word	0x40005000

0001871c <get_status>:
{
   1871c:	b538      	push	{r3, r4, r5, lr}
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   1871e:	b2cc      	uxtb	r4, r1
   18720:	2c01      	cmp	r4, #1
{
   18722:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   18724:	d909      	bls.n	1873a <get_status+0x1e>
   18726:	490b      	ldr	r1, [pc, #44]	; (18754 <get_status+0x38>)
   18728:	480b      	ldr	r0, [pc, #44]	; (18758 <get_status+0x3c>)
   1872a:	2384      	movs	r3, #132	; 0x84
   1872c:	4a0b      	ldr	r2, [pc, #44]	; (1875c <get_status+0x40>)
   1872e:	f014 fd8c 	bl	2d24a <printk>
   18732:	2184      	movs	r1, #132	; 0x84
   18734:	4809      	ldr	r0, [pc, #36]	; (1875c <get_status+0x40>)
   18736:	f014 fdce 	bl	2d2d6 <assert_post_action>
	if (data->started) {
   1873a:	210c      	movs	r1, #12
	data = get_sub_data(dev, type);
   1873c:	68ab      	ldr	r3, [r5, #8]
	if (data->started) {
   1873e:	fb04 3101 	mla	r1, r4, r1, r3
   18742:	7a4b      	ldrb	r3, [r1, #9]
   18744:	b923      	cbnz	r3, 18750 <get_status+0x34>
	if (data->ref > 0) {
   18746:	7a08      	ldrb	r0, [r1, #8]
		return CLOCK_CONTROL_STATUS_ON;
   18748:	fab0 f080 	clz	r0, r0
   1874c:	0940      	lsrs	r0, r0, #5
}
   1874e:	bd38      	pop	{r3, r4, r5, pc}
		return CLOCK_CONTROL_STATUS_ON;
   18750:	2002      	movs	r0, #2
   18752:	e7fc      	b.n	1874e <get_status+0x32>
   18754:	0003288b 	.word	0x0003288b
   18758:	000311a3 	.word	0x000311a3
   1875c:	00032850 	.word	0x00032850

00018760 <clock_async_start>:
{
   18760:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
   18764:	b2ce      	uxtb	r6, r1
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   18766:	2e01      	cmp	r6, #1
{
   18768:	4607      	mov	r7, r0
   1876a:	4614      	mov	r4, r2
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   1876c:	d909      	bls.n	18782 <clock_async_start+0x22>
   1876e:	4949      	ldr	r1, [pc, #292]	; (18894 <clock_async_start+0x134>)
   18770:	4849      	ldr	r0, [pc, #292]	; (18898 <clock_async_start+0x138>)
   18772:	23fd      	movs	r3, #253	; 0xfd
   18774:	4a49      	ldr	r2, [pc, #292]	; (1889c <clock_async_start+0x13c>)
   18776:	f014 fd68 	bl	2d24a <printk>
   1877a:	21fd      	movs	r1, #253	; 0xfd
   1877c:	4847      	ldr	r0, [pc, #284]	; (1889c <clock_async_start+0x13c>)
   1877e:	f014 fdaa 	bl	2d2d6 <assert_post_action>
	const struct nrf_clock_control_config *config =
   18782:	683b      	ldr	r3, [r7, #0]
	clk_data = get_sub_data(dev, type);
   18784:	f8d7 8008 	ldr.w	r8, [r7, #8]
	const struct nrf_clock_control_config *config =
   18788:	f8d3 9008 	ldr.w	r9, [r3, #8]
	__ASSERT_NO_MSG((data == NULL) ||
   1878c:	2c00      	cmp	r4, #0
   1878e:	d157      	bne.n	18840 <clock_async_start+0xe0>
	__asm__ volatile(
   18790:	f04f 0320 	mov.w	r3, #32
   18794:	f3ef 8a11 	mrs	sl, BASEPRI
   18798:	f383 8811 	msr	BASEPRI, r3
   1879c:	f3bf 8f6f 	isb	sy
	ref = ++clk_data->ref;
   187a0:	230c      	movs	r3, #12
   187a2:	fb03 8306 	mla	r3, r3, r6, r8
   187a6:	7a1d      	ldrb	r5, [r3, #8]
   187a8:	3501      	adds	r5, #1
   187aa:	b2ed      	uxtb	r5, r5
   187ac:	721d      	strb	r5, [r3, #8]
	__ASSERT_NO_MSG(clk_data->ref > 0);
   187ae:	b95d      	cbnz	r5, 187c8 <clock_async_start+0x68>
   187b0:	493b      	ldr	r1, [pc, #236]	; (188a0 <clock_async_start+0x140>)
   187b2:	4839      	ldr	r0, [pc, #228]	; (18898 <clock_async_start+0x138>)
   187b4:	f44f 7387 	mov.w	r3, #270	; 0x10e
   187b8:	4a38      	ldr	r2, [pc, #224]	; (1889c <clock_async_start+0x13c>)
   187ba:	f014 fd46 	bl	2d24a <printk>
   187be:	f44f 7187 	mov.w	r1, #270	; 0x10e
   187c2:	4836      	ldr	r0, [pc, #216]	; (1889c <clock_async_start+0x13c>)
   187c4:	f014 fd87 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   187c8:	f38a 8811 	msr	BASEPRI, sl
   187cc:	f3bf 8f6f 	isb	sy
	if (data) {
   187d0:	b32c      	cbz	r4, 1881e <clock_async_start+0xbe>
    p_reg->INTENCLR = mask;
   187d2:	2203      	movs	r2, #3
   187d4:	4b33      	ldr	r3, [pc, #204]	; (188a4 <clock_async_start+0x144>)
   187d6:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
		already_started = clk_data->started;
   187da:	220c      	movs	r2, #12
   187dc:	4372      	muls	r2, r6
   187de:	eb08 0302 	add.w	r3, r8, r2
   187e2:	7a59      	ldrb	r1, [r3, #9]
		if (!already_started) {
   187e4:	b991      	cbnz	r1, 1880c <clock_async_start+0xac>
	__asm__ volatile(
   187e6:	f04f 0020 	mov.w	r0, #32
   187ea:	f3ef 8c11 	mrs	ip, BASEPRI
   187ee:	f380 8811 	msr	BASEPRI, r0
   187f2:	f3bf 8f6f 	isb	sy
	return node->next;
}

static inline void z_snode_next_set(sys_snode_t *parent, sys_snode_t *child)
{
	parent->next = child;
   187f6:	6021      	str	r1, [r4, #0]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
   187f8:	6858      	ldr	r0, [r3, #4]
   187fa:	2800      	cmp	r0, #0
   187fc:	d13a      	bne.n	18874 <clock_async_start+0x114>
	list->tail = node;
   187fe:	605c      	str	r4, [r3, #4]
	list->head = node;
   18800:	f848 4002 	str.w	r4, [r8, r2]
	__asm__ volatile(
   18804:	f38c 8811 	msr	BASEPRI, ip
   18808:	f3bf 8f6f 	isb	sy
    p_reg->INTENSET = mask;
   1880c:	2203      	movs	r2, #3
   1880e:	4b25      	ldr	r3, [pc, #148]	; (188a4 <clock_async_start+0x144>)
   18810:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		if (already_started) {
   18814:	b119      	cbz	r1, 1881e <clock_async_start+0xbe>
			data->cb(dev, data->user_data);
   18816:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
   1881a:	4638      	mov	r0, r7
   1881c:	4798      	blx	r3
	if (ref == 1) {
   1881e:	2d01      	cmp	r5, #1
   18820:	d10c      	bne.n	1883c <clock_async_start+0xdc>
		do_start =  (config->start_handler) ?
   18822:	0135      	lsls	r5, r6, #4
   18824:	f859 3005 	ldr.w	r3, [r9, r5]
				config->start_handler(dev) : true;
   18828:	bb3b      	cbnz	r3, 1887a <clock_async_start+0x11a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1882a:	2201      	movs	r2, #1
			nrf_clock_task_trigger(NRF_CLOCK,
   1882c:	44a9      	add	r9, r5
   1882e:	f899 300a 	ldrb.w	r3, [r9, #10]
   18832:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   18836:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
   1883a:	601a      	str	r2, [r3, #0]
	return 0;
   1883c:	2000      	movs	r0, #0
   1883e:	e027      	b.n	18890 <clock_async_start+0x130>
	__ASSERT_NO_MSG((data == NULL) ||
   18840:	6863      	ldr	r3, [r4, #4]
   18842:	b95b      	cbnz	r3, 1885c <clock_async_start+0xfc>
   18844:	4918      	ldr	r1, [pc, #96]	; (188a8 <clock_async_start+0x148>)
   18846:	4814      	ldr	r0, [pc, #80]	; (18898 <clock_async_start+0x138>)
   18848:	f44f 7381 	mov.w	r3, #258	; 0x102
   1884c:	4a13      	ldr	r2, [pc, #76]	; (1889c <clock_async_start+0x13c>)
   1884e:	f014 fcfc 	bl	2d24a <printk>
   18852:	f44f 7181 	mov.w	r1, #258	; 0x102
   18856:	4811      	ldr	r0, [pc, #68]	; (1889c <clock_async_start+0x13c>)
   18858:	f014 fd3d 	bl	2d2d6 <assert_post_action>
	sys_snode_t *item = sys_slist_peek_head(list);
   1885c:	230c      	movs	r3, #12
   1885e:	4373      	muls	r3, r6
   18860:	f858 3003 	ldr.w	r3, [r8, r3]
		if (item == node) {
   18864:	429c      	cmp	r4, r3
   18866:	d011      	beq.n	1888c <clock_async_start+0x12c>
Z_GENLIST_PEEK_NEXT(slist, snode)
   18868:	2b00      	cmp	r3, #0
   1886a:	d091      	beq.n	18790 <clock_async_start+0x30>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1886c:	681b      	ldr	r3, [r3, #0]
	} while (item);
   1886e:	2b00      	cmp	r3, #0
   18870:	d1f8      	bne.n	18864 <clock_async_start+0x104>
   18872:	e78d      	b.n	18790 <clock_async_start+0x30>
	parent->next = child;
   18874:	6004      	str	r4, [r0, #0]
	list->tail = node;
   18876:	605c      	str	r4, [r3, #4]
   18878:	e7c4      	b.n	18804 <clock_async_start+0xa4>
				config->start_handler(dev) : true;
   1887a:	4638      	mov	r0, r7
   1887c:	4798      	blx	r3
   1887e:	2800      	cmp	r0, #0
   18880:	d1d3      	bne.n	1882a <clock_async_start+0xca>
			clkstarted_handle(dev, type);
   18882:	4631      	mov	r1, r6
   18884:	4638      	mov	r0, r7
   18886:	f014 fe53 	bl	2d530 <clkstarted_handle>
   1888a:	e7d7      	b.n	1883c <clock_async_start+0xdc>
		return -EBUSY;
   1888c:	f06f 000f 	mvn.w	r0, #15
}
   18890:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   18894:	0003288b 	.word	0x0003288b
   18898:	000311a3 	.word	0x000311a3
   1889c:	00032850 	.word	0x00032850
   188a0:	0003283e 	.word	0x0003283e
   188a4:	40005000 	.word	0x40005000
   188a8:	000327f0 	.word	0x000327f0

000188ac <clock_stop>:
{
   188ac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   188b0:	b2cd      	uxtb	r5, r1
   188b2:	2d01      	cmp	r5, #1
{
   188b4:	4680      	mov	r8, r0
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   188b6:	d909      	bls.n	188cc <clock_stop+0x20>
   188b8:	4925      	ldr	r1, [pc, #148]	; (18950 <clock_stop+0xa4>)
   188ba:	4826      	ldr	r0, [pc, #152]	; (18954 <clock_stop+0xa8>)
   188bc:	2399      	movs	r3, #153	; 0x99
   188be:	4a26      	ldr	r2, [pc, #152]	; (18958 <clock_stop+0xac>)
   188c0:	f014 fcc3 	bl	2d24a <printk>
   188c4:	2199      	movs	r1, #153	; 0x99
   188c6:	4824      	ldr	r0, [pc, #144]	; (18958 <clock_stop+0xac>)
   188c8:	f014 fd05 	bl	2d2d6 <assert_post_action>
	const struct nrf_clock_control_config *config =
   188cc:	f8d8 3000 	ldr.w	r3, [r8]
	data = get_sub_data(dev, type);
   188d0:	f8d8 7008 	ldr.w	r7, [r8, #8]
	const struct nrf_clock_control_config *config =
   188d4:	f8d3 9008 	ldr.w	r9, [r3, #8]
	__asm__ volatile(
   188d8:	f04f 0320 	mov.w	r3, #32
   188dc:	f3ef 8611 	mrs	r6, BASEPRI
   188e0:	f383 8811 	msr	BASEPRI, r3
   188e4:	f3bf 8f6f 	isb	sy
	if (data->ref == 0) {
   188e8:	220c      	movs	r2, #12
   188ea:	436a      	muls	r2, r5
   188ec:	18b9      	adds	r1, r7, r2
   188ee:	7a0b      	ldrb	r3, [r1, #8]
   188f0:	b34b      	cbz	r3, 18946 <clock_stop+0x9a>
	data->ref--;
   188f2:	3b01      	subs	r3, #1
   188f4:	b2db      	uxtb	r3, r3
   188f6:	720b      	strb	r3, [r1, #8]
	if (data->ref == 0) {
   188f8:	bb43      	cbnz	r3, 1894c <clock_stop+0xa0>
		do_stop =  (config->stop_handler) ?
   188fa:	012c      	lsls	r4, r5, #4
	list->head = NULL;
   188fc:	50bb      	str	r3, [r7, r2]
	list->tail = NULL;
   188fe:	604b      	str	r3, [r1, #4]
   18900:	eb09 0304 	add.w	r3, r9, r4
   18904:	685b      	ldr	r3, [r3, #4]
				config->stop_handler(dev) : true;
   18906:	b9cb      	cbnz	r3, 1893c <clock_stop+0x90>
   18908:	2201      	movs	r2, #1
			nrf_clock_task_trigger(NRF_CLOCK, config->stop_tsk);
   1890a:	444c      	add	r4, r9
   1890c:	7ae3      	ldrb	r3, [r4, #11]
   1890e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   18912:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
   18916:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   18918:	2200      	movs	r2, #0
   1891a:	8923      	ldrh	r3, [r4, #8]
   1891c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   18920:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
   18924:	601a      	str	r2, [r3, #0]
		data->started = false;
   18926:	230c      	movs	r3, #12
   18928:	2000      	movs	r0, #0
   1892a:	fb05 7503 	mla	r5, r5, r3, r7
   1892e:	7268      	strb	r0, [r5, #9]
	__asm__ volatile(
   18930:	f386 8811 	msr	BASEPRI, r6
   18934:	f3bf 8f6f 	isb	sy
}
   18938:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				config->stop_handler(dev) : true;
   1893c:	4640      	mov	r0, r8
   1893e:	4798      	blx	r3
   18940:	2800      	cmp	r0, #0
   18942:	d1e1      	bne.n	18908 <clock_stop+0x5c>
   18944:	e7ef      	b.n	18926 <clock_stop+0x7a>
		err = -EALREADY;
   18946:	f06f 0077 	mvn.w	r0, #119	; 0x77
   1894a:	e7f1      	b.n	18930 <clock_stop+0x84>
	int err = 0;
   1894c:	2000      	movs	r0, #0
   1894e:	e7ef      	b.n	18930 <clock_stop+0x84>
   18950:	0003288b 	.word	0x0003288b
   18954:	000311a3 	.word	0x000311a3
   18958:	00032850 	.word	0x00032850

0001895c <nrf_power_clock_isr>:
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
   1895c:	b508      	push	{r3, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   1895e:	4b10      	ldr	r3, [pc, #64]	; (189a0 <nrf_power_clock_isr+0x44>)
   18960:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
   18962:	b162      	cbz	r2, 1897e <nrf_power_clock_isr+0x22>
    return p_reg->INTENSET & mask;
   18964:	4a0f      	ldr	r2, [pc, #60]	; (189a4 <nrf_power_clock_isr+0x48>)
   18966:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
   1896a:	07d1      	lsls	r1, r2, #31
   1896c:	d507      	bpl.n	1897e <nrf_power_clock_isr+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1896e:	2200      	movs	r2, #0
	struct device *dev = DEVICE_GET(clock_nrf);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
   18970:	480d      	ldr	r0, [pc, #52]	; (189a8 <nrf_power_clock_isr+0x4c>)
   18972:	601a      	str	r2, [r3, #0]

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
   18974:	6883      	ldr	r3, [r0, #8]
   18976:	7a59      	ldrb	r1, [r3, #9]
   18978:	b909      	cbnz	r1, 1897e <nrf_power_clock_isr+0x22>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
   1897a:	f014 fdd9 	bl	2d530 <clkstarted_handle>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   1897e:	4b0b      	ldr	r3, [pc, #44]	; (189ac <nrf_power_clock_isr+0x50>)
   18980:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
   18982:	b162      	cbz	r2, 1899e <nrf_power_clock_isr+0x42>
    return p_reg->INTENSET & mask;
   18984:	4a07      	ldr	r2, [pc, #28]	; (189a4 <nrf_power_clock_isr+0x48>)
   18986:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
   1898a:	0792      	lsls	r2, r2, #30
   1898c:	d507      	bpl.n	1899e <nrf_power_clock_isr+0x42>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1898e:	2200      	movs	r2, #0
					NRF_CLOCK_INT_LF_STARTED_MASK)) {
		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started(dev);
		}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   18990:	2101      	movs	r1, #1
   18992:	601a      	str	r2, [r3, #0]
   18994:	4804      	ldr	r0, [pc, #16]	; (189a8 <nrf_power_clock_isr+0x4c>)
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
   18996:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   1899a:	f014 bdc9 	b.w	2d530 <clkstarted_handle>
}
   1899e:	bd08      	pop	{r3, pc}
   189a0:	40005100 	.word	0x40005100
   189a4:	40005000 	.word	0x40005000
   189a8:	2003b60c 	.word	0x2003b60c
   189ac:	40005104 	.word	0x40005104

000189b0 <z_clock_isr>:
#include <drivers/timer/system_timer.h>

/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
   189b0:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(false);
   189b2:	4c06      	ldr	r4, [pc, #24]	; (189cc <z_clock_isr+0x1c>)
   189b4:	4906      	ldr	r1, [pc, #24]	; (189d0 <z_clock_isr+0x20>)
   189b6:	4622      	mov	r2, r4
   189b8:	4806      	ldr	r0, [pc, #24]	; (189d4 <z_clock_isr+0x24>)
   189ba:	2317      	movs	r3, #23
   189bc:	f014 fc45 	bl	2d24a <printk>
   189c0:	4620      	mov	r0, r4
}
   189c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__ASSERT_NO_MSG(false);
   189c6:	2117      	movs	r1, #23
   189c8:	f014 bc85 	b.w	2d2d6 <assert_post_action>
   189cc:	000328d9 	.word	0x000328d9
   189d0:	0003495a 	.word	0x0003495a
   189d4:	000311a3 	.word	0x000311a3

000189d8 <rtc1_nrf_isr>:
 * symbol.
 */
void rtc1_nrf_isr(void *arg)
{
	ARG_UNUSED(arg);
	RTC->EVENTS_COMPARE[0] = 0;
   189d8:	2200      	movs	r2, #0
{
   189da:	b538      	push	{r3, r4, r5, lr}
	RTC->EVENTS_COMPARE[0] = 0;
   189dc:	4b22      	ldr	r3, [pc, #136]	; (18a68 <rtc1_nrf_isr+0x90>)
   189de:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
	__asm__ volatile(
   189e2:	f04f 0320 	mov.w	r3, #32
   189e6:	f3ef 8511 	mrs	r5, BASEPRI
   189ea:	f383 8811 	msr	BASEPRI, r3
   189ee:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   189f2:	481e      	ldr	r0, [pc, #120]	; (18a6c <rtc1_nrf_isr+0x94>)
   189f4:	f00f fe78 	bl	286e8 <z_spin_lock_valid>
   189f8:	b968      	cbnz	r0, 18a16 <rtc1_nrf_isr+0x3e>
   189fa:	234a      	movs	r3, #74	; 0x4a
   189fc:	4a1c      	ldr	r2, [pc, #112]	; (18a70 <rtc1_nrf_isr+0x98>)
   189fe:	491d      	ldr	r1, [pc, #116]	; (18a74 <rtc1_nrf_isr+0x9c>)
   18a00:	481d      	ldr	r0, [pc, #116]	; (18a78 <rtc1_nrf_isr+0xa0>)
   18a02:	f014 fc22 	bl	2d24a <printk>
   18a06:	4919      	ldr	r1, [pc, #100]	; (18a6c <rtc1_nrf_isr+0x94>)
   18a08:	481c      	ldr	r0, [pc, #112]	; (18a7c <rtc1_nrf_isr+0xa4>)
   18a0a:	f014 fc1e 	bl	2d24a <printk>
   18a0e:	214a      	movs	r1, #74	; 0x4a
   18a10:	4817      	ldr	r0, [pc, #92]	; (18a70 <rtc1_nrf_isr+0x98>)
   18a12:	f014 fc60 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   18a16:	4815      	ldr	r0, [pc, #84]	; (18a6c <rtc1_nrf_isr+0x94>)
   18a18:	f00f fe84 	bl	28724 <z_spin_lock_set_owner>
#endif
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
   18a1c:	4b12      	ldr	r3, [pc, #72]	; (18a68 <rtc1_nrf_isr+0x90>)

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t t = counter();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
   18a1e:	4a18      	ldr	r2, [pc, #96]	; (18a80 <rtc1_nrf_isr+0xa8>)
   18a20:	f8d3 4504 	ldr.w	r4, [r3, #1284]	; 0x504
   18a24:	6813      	ldr	r3, [r2, #0]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   18a26:	4811      	ldr	r0, [pc, #68]	; (18a6c <rtc1_nrf_isr+0x94>)
	return (a - b) & COUNTER_MAX;
   18a28:	1ae4      	subs	r4, r4, r3
   18a2a:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
   18a2e:	4423      	add	r3, r4
   18a30:	6013      	str	r3, [r2, #0]
   18a32:	f00f fe67 	bl	28704 <z_spin_unlock_valid>
   18a36:	b968      	cbnz	r0, 18a54 <rtc1_nrf_isr+0x7c>
   18a38:	235d      	movs	r3, #93	; 0x5d
   18a3a:	4a0d      	ldr	r2, [pc, #52]	; (18a70 <rtc1_nrf_isr+0x98>)
   18a3c:	4911      	ldr	r1, [pc, #68]	; (18a84 <rtc1_nrf_isr+0xac>)
   18a3e:	480e      	ldr	r0, [pc, #56]	; (18a78 <rtc1_nrf_isr+0xa0>)
   18a40:	f014 fc03 	bl	2d24a <printk>
   18a44:	4909      	ldr	r1, [pc, #36]	; (18a6c <rtc1_nrf_isr+0x94>)
   18a46:	4810      	ldr	r0, [pc, #64]	; (18a88 <rtc1_nrf_isr+0xb0>)
   18a48:	f014 fbff 	bl	2d24a <printk>
   18a4c:	215d      	movs	r1, #93	; 0x5d
   18a4e:	4808      	ldr	r0, [pc, #32]	; (18a70 <rtc1_nrf_isr+0x98>)
   18a50:	f014 fc41 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   18a54:	f385 8811 	msr	BASEPRI, r5
   18a58:	f3bf 8f6f 	isb	sy
		}
		set_comparator(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
   18a5c:	4620      	mov	r0, r4
}
   18a5e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
   18a62:	f010 bac7 	b.w	28ff4 <z_clock_announce>
   18a66:	bf00      	nop
   18a68:	40015000 	.word	0x40015000
   18a6c:	20028688 	.word	0x20028688
   18a70:	00031168 	.word	0x00031168
   18a74:	0003118e 	.word	0x0003118e
   18a78:	000311a3 	.word	0x000311a3
   18a7c:	000311c0 	.word	0x000311c0
   18a80:	20028684 	.word	0x20028684
   18a84:	00031202 	.word	0x00031202
   18a88:	00031219 	.word	0x00031219

00018a8c <z_clock_driver_init>:

int z_clock_driver_init(struct device *device)
{
   18a8c:	b570      	push	{r4, r5, r6, lr}
   18a8e:	4815      	ldr	r0, [pc, #84]	; (18ae4 <z_clock_driver_init+0x58>)
   18a90:	f00d fb9a 	bl	261c8 <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_INST_0_NORDIC_NRF_CLOCK_LABEL);
	if (!clock) {
   18a94:	b310      	cbz	r0, 18adc <z_clock_driver_init+0x50>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
   18a96:	6843      	ldr	r3, [r0, #4]
   18a98:	2101      	movs	r1, #1
   18a9a:	681b      	ldr	r3, [r3, #0]
   18a9c:	4798      	blx	r3
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
   18a9e:	2400      	movs	r4, #0
    p_reg->CC[ch] = cc_val;
   18aa0:	2601      	movs	r6, #1
    p_reg->INTENSET = mask;
   18aa2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   18aa6:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    p_reg->PRESCALER = val;
   18aaa:	4d0f      	ldr	r5, [pc, #60]	; (18ae8 <z_clock_driver_init+0x5c>)

	/* Clear the event flag and possible pending interrupt */
	nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_COMPARE_0);
	NVIC_ClearPendingIRQ(RTC1_IRQn);

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
   18aac:	4631      	mov	r1, r6
   18aae:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
   18ab2:	f8c5 6540 	str.w	r6, [r5, #1344]	; 0x540
    p_reg->INTENSET = mask;
   18ab6:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   18aba:	4b0c      	ldr	r3, [pc, #48]	; (18aec <z_clock_driver_init+0x60>)
   18abc:	2015      	movs	r0, #21
   18abe:	601c      	str	r4, [r3, #0]
   18ac0:	4b0b      	ldr	r3, [pc, #44]	; (18af0 <z_clock_driver_init+0x64>)
   18ac2:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   18ac6:	4622      	mov	r2, r4
   18ac8:	f000 fab0 	bl	1902c <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
   18acc:	2015      	movs	r0, #21
   18ace:	f000 fa9d 	bl	1900c <arch_irq_enable>

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
	}

	return 0;
   18ad2:	4620      	mov	r0, r4
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   18ad4:	4b07      	ldr	r3, [pc, #28]	; (18af4 <z_clock_driver_init+0x68>)
   18ad6:	601e      	str	r6, [r3, #0]
   18ad8:	602e      	str	r6, [r5, #0]
}
   18ada:	bd70      	pop	{r4, r5, r6, pc}
		return -1;
   18adc:	f04f 30ff 	mov.w	r0, #4294967295
   18ae0:	e7fb      	b.n	18ada <z_clock_driver_init+0x4e>
   18ae2:	bf00      	nop
   18ae4:	000328af 	.word	0x000328af
   18ae8:	40015000 	.word	0x40015000
   18aec:	40015140 	.word	0x40015140
   18af0:	e000e100 	.word	0xe000e100
   18af4:	40015008 	.word	0x40015008

00018af8 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
   18af8:	b570      	push	{r4, r5, r6, lr}
	ARG_UNUSED(idle);

#ifdef CONFIG_TICKLESS_KERNEL
	ticks = (ticks == K_FOREVER) ? MAX_TICKS : ticks;
   18afa:	4c3a      	ldr	r4, [pc, #232]	; (18be4 <z_clock_set_timeout+0xec>)
   18afc:	f1b0 3fff 	cmp.w	r0, #4294967295
   18b00:	bf18      	it	ne
   18b02:	4604      	movne	r4, r0
	__asm__ volatile(
   18b04:	f04f 0320 	mov.w	r3, #32
   18b08:	f3ef 8511 	mrs	r5, BASEPRI
   18b0c:	f383 8811 	msr	BASEPRI, r3
   18b10:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   18b14:	4834      	ldr	r0, [pc, #208]	; (18be8 <z_clock_set_timeout+0xf0>)
   18b16:	f00f fde7 	bl	286e8 <z_spin_lock_valid>
   18b1a:	b968      	cbnz	r0, 18b38 <z_clock_set_timeout+0x40>
   18b1c:	234a      	movs	r3, #74	; 0x4a
   18b1e:	4a33      	ldr	r2, [pc, #204]	; (18bec <z_clock_set_timeout+0xf4>)
   18b20:	4933      	ldr	r1, [pc, #204]	; (18bf0 <z_clock_set_timeout+0xf8>)
   18b22:	4834      	ldr	r0, [pc, #208]	; (18bf4 <z_clock_set_timeout+0xfc>)
   18b24:	f014 fb91 	bl	2d24a <printk>
   18b28:	492f      	ldr	r1, [pc, #188]	; (18be8 <z_clock_set_timeout+0xf0>)
   18b2a:	4833      	ldr	r0, [pc, #204]	; (18bf8 <z_clock_set_timeout+0x100>)
   18b2c:	f014 fb8d 	bl	2d24a <printk>
   18b30:	214a      	movs	r1, #74	; 0x4a
   18b32:	482e      	ldr	r0, [pc, #184]	; (18bec <z_clock_set_timeout+0xf4>)
   18b34:	f014 fbcf 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   18b38:	482b      	ldr	r0, [pc, #172]	; (18be8 <z_clock_set_timeout+0xf0>)
   18b3a:	f00f fdf3 	bl	28724 <z_spin_lock_set_owner>
     return p_reg->COUNTER;
   18b3e:	4b2f      	ldr	r3, [pc, #188]	; (18bfc <z_clock_set_timeout+0x104>)
   18b40:	4e28      	ldr	r6, [pc, #160]	; (18be4 <z_clock_set_timeout+0xec>)
   18b42:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t cyc, dt, t = counter();
	u32_t unannounced = counter_sub(t, last_count);
   18b46:	4b2e      	ldr	r3, [pc, #184]	; (18c00 <z_clock_set_timeout+0x108>)
   18b48:	681b      	ldr	r3, [r3, #0]
	return (a - b) & COUNTER_MAX;
   18b4a:	1ad0      	subs	r0, r2, r3
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
   18b4c:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
	return (a - b) & COUNTER_MAX;
   18b50:	f020 417f 	bic.w	r1, r0, #4278190080	; 0xff000000
	if (unannounced >= COUNTER_HALF_SPAN) {
   18b54:	d12c      	bne.n	18bb0 <z_clock_set_timeout+0xb8>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
   18b56:	1e60      	subs	r0, r4, #1
   18b58:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   18b5c:	42b0      	cmp	r0, r6
   18b5e:	bfa8      	it	ge
   18b60:	4630      	movge	r0, r6
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
   18b62:	3101      	adds	r1, #1
   18b64:	4408      	add	r0, r1
	 */
	if (cyc > MAX_CYCLES) {
		cyc = MAX_CYCLES;
	}

	cyc += last_count;
   18b66:	42b0      	cmp	r0, r6
   18b68:	bf94      	ite	ls
   18b6a:	181b      	addls	r3, r3, r0
   18b6c:	199b      	addhi	r3, r3, r6
	return (a - b) & COUNTER_MAX;
   18b6e:	1a9a      	subs	r2, r3, r2
   18b70:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
   18b74:	4921      	ldr	r1, [pc, #132]	; (18bfc <z_clock_set_timeout+0x104>)
   18b76:	f023 407f 	bic.w	r0, r3, #4278190080	; 0xff000000
	 * least on nRF52.  Some experimentation on nrf52840 shows
	 * that you need to be early by about 400 processor cycles
	 * (about 1/5th of a RTC cycle) in order to reliably get the
	 * interrupt.  The docs say two cycles, they mean two cycles.
	 */
	if (counter_sub(cyc, t) > 2) {
   18b7a:	2a02      	cmp	r2, #2
    p_reg->CC[ch] = cc_val;
   18b7c:	f8c1 0540 	str.w	r0, [r1, #1344]	; 0x540
   18b80:	d918      	bls.n	18bb4 <z_clock_set_timeout+0xbc>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   18b82:	4819      	ldr	r0, [pc, #100]	; (18be8 <z_clock_set_timeout+0xf0>)
   18b84:	f00f fdbe 	bl	28704 <z_spin_unlock_valid>
   18b88:	b968      	cbnz	r0, 18ba6 <z_clock_set_timeout+0xae>
   18b8a:	235d      	movs	r3, #93	; 0x5d
   18b8c:	4a17      	ldr	r2, [pc, #92]	; (18bec <z_clock_set_timeout+0xf4>)
   18b8e:	491d      	ldr	r1, [pc, #116]	; (18c04 <z_clock_set_timeout+0x10c>)
   18b90:	4818      	ldr	r0, [pc, #96]	; (18bf4 <z_clock_set_timeout+0xfc>)
   18b92:	f014 fb5a 	bl	2d24a <printk>
   18b96:	4914      	ldr	r1, [pc, #80]	; (18be8 <z_clock_set_timeout+0xf0>)
   18b98:	481b      	ldr	r0, [pc, #108]	; (18c08 <z_clock_set_timeout+0x110>)
   18b9a:	f014 fb56 	bl	2d24a <printk>
   18b9e:	215d      	movs	r1, #93	; 0x5d
   18ba0:	4812      	ldr	r0, [pc, #72]	; (18bec <z_clock_set_timeout+0xf4>)
   18ba2:	f014 fb98 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   18ba6:	f385 8811 	msr	BASEPRI, r5
   18baa:	f3bf 8f6f 	isb	sy
	}
#endif

	k_spin_unlock(&lock, key);
#endif /* CONFIG_TICKLESS_KERNEL */
}
   18bae:	bd70      	pop	{r4, r5, r6, pc}
		ticks = 0;
   18bb0:	2000      	movs	r0, #0
   18bb2:	e7d6      	b.n	18b62 <z_clock_set_timeout+0x6a>
     return p_reg->COUNTER;
   18bb4:	f8d1 2504 	ldr.w	r2, [r1, #1284]	; 0x504
		if (dt == 0 || dt > 0x7fffff) {
   18bb8:	4814      	ldr	r0, [pc, #80]	; (18c0c <z_clock_set_timeout+0x114>)
	return (a - b) & COUNTER_MAX;
   18bba:	1a9a      	subs	r2, r3, r2
   18bbc:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
		if (dt == 0 || dt > 0x7fffff) {
   18bc0:	1e54      	subs	r4, r2, #1
   18bc2:	4284      	cmp	r4, r0
   18bc4:	d905      	bls.n	18bd2 <z_clock_set_timeout+0xda>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   18bc6:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   18bca:	4b11      	ldr	r3, [pc, #68]	; (18c10 <z_clock_set_timeout+0x118>)
   18bcc:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   18bd0:	e7d7      	b.n	18b82 <z_clock_set_timeout+0x8a>
		} else if (dt == 1) {
   18bd2:	2a01      	cmp	r2, #1
			set_comparator(cyc + 2);
   18bd4:	bf02      	ittt	eq
   18bd6:	3302      	addeq	r3, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
   18bd8:	f023 437f 	biceq.w	r3, r3, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
   18bdc:	f8c1 3540 	streq.w	r3, [r1, #1344]	; 0x540
   18be0:	e7cf      	b.n	18b82 <z_clock_set_timeout+0x8a>
   18be2:	bf00      	nop
   18be4:	00fffffe 	.word	0x00fffffe
   18be8:	20028688 	.word	0x20028688
   18bec:	00031168 	.word	0x00031168
   18bf0:	0003118e 	.word	0x0003118e
   18bf4:	000311a3 	.word	0x000311a3
   18bf8:	000311c0 	.word	0x000311c0
   18bfc:	40015000 	.word	0x40015000
   18c00:	20028684 	.word	0x20028684
   18c04:	00031202 	.word	0x00031202
   18c08:	00031219 	.word	0x00031219
   18c0c:	007ffffe 	.word	0x007ffffe
   18c10:	e000e100 	.word	0xe000e100

00018c14 <z_clock_elapsed>:

u32_t z_clock_elapsed(void)
{
   18c14:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   18c16:	f04f 0320 	mov.w	r3, #32
   18c1a:	f3ef 8511 	mrs	r5, BASEPRI
   18c1e:	f383 8811 	msr	BASEPRI, r3
   18c22:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   18c26:	481a      	ldr	r0, [pc, #104]	; (18c90 <z_clock_elapsed+0x7c>)
   18c28:	f00f fd5e 	bl	286e8 <z_spin_lock_valid>
   18c2c:	b968      	cbnz	r0, 18c4a <z_clock_elapsed+0x36>
   18c2e:	234a      	movs	r3, #74	; 0x4a
   18c30:	4a18      	ldr	r2, [pc, #96]	; (18c94 <z_clock_elapsed+0x80>)
   18c32:	4919      	ldr	r1, [pc, #100]	; (18c98 <z_clock_elapsed+0x84>)
   18c34:	4819      	ldr	r0, [pc, #100]	; (18c9c <z_clock_elapsed+0x88>)
   18c36:	f014 fb08 	bl	2d24a <printk>
   18c3a:	4915      	ldr	r1, [pc, #84]	; (18c90 <z_clock_elapsed+0x7c>)
   18c3c:	4818      	ldr	r0, [pc, #96]	; (18ca0 <z_clock_elapsed+0x8c>)
   18c3e:	f014 fb04 	bl	2d24a <printk>
   18c42:	214a      	movs	r1, #74	; 0x4a
   18c44:	4813      	ldr	r0, [pc, #76]	; (18c94 <z_clock_elapsed+0x80>)
   18c46:	f014 fb46 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   18c4a:	4811      	ldr	r0, [pc, #68]	; (18c90 <z_clock_elapsed+0x7c>)
   18c4c:	f00f fd6a 	bl	28724 <z_spin_lock_set_owner>
     return p_reg->COUNTER;
   18c50:	4b14      	ldr	r3, [pc, #80]	; (18ca4 <z_clock_elapsed+0x90>)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   18c52:	480f      	ldr	r0, [pc, #60]	; (18c90 <z_clock_elapsed+0x7c>)
   18c54:	f8d3 4504 	ldr.w	r4, [r3, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
   18c58:	4b13      	ldr	r3, [pc, #76]	; (18ca8 <z_clock_elapsed+0x94>)
	return (a - b) & COUNTER_MAX;
   18c5a:	681b      	ldr	r3, [r3, #0]
   18c5c:	1ae4      	subs	r4, r4, r3
   18c5e:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
   18c62:	f00f fd4f 	bl	28704 <z_spin_unlock_valid>
   18c66:	b968      	cbnz	r0, 18c84 <z_clock_elapsed+0x70>
   18c68:	235d      	movs	r3, #93	; 0x5d
   18c6a:	4a0a      	ldr	r2, [pc, #40]	; (18c94 <z_clock_elapsed+0x80>)
   18c6c:	490f      	ldr	r1, [pc, #60]	; (18cac <z_clock_elapsed+0x98>)
   18c6e:	480b      	ldr	r0, [pc, #44]	; (18c9c <z_clock_elapsed+0x88>)
   18c70:	f014 faeb 	bl	2d24a <printk>
   18c74:	4906      	ldr	r1, [pc, #24]	; (18c90 <z_clock_elapsed+0x7c>)
   18c76:	480e      	ldr	r0, [pc, #56]	; (18cb0 <z_clock_elapsed+0x9c>)
   18c78:	f014 fae7 	bl	2d24a <printk>
   18c7c:	215d      	movs	r1, #93	; 0x5d
   18c7e:	4805      	ldr	r0, [pc, #20]	; (18c94 <z_clock_elapsed+0x80>)
   18c80:	f014 fb29 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   18c84:	f385 8811 	msr	BASEPRI, r5
   18c88:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
   18c8c:	4620      	mov	r0, r4
   18c8e:	bd38      	pop	{r3, r4, r5, pc}
   18c90:	20028688 	.word	0x20028688
   18c94:	00031168 	.word	0x00031168
   18c98:	0003118e 	.word	0x0003118e
   18c9c:	000311a3 	.word	0x000311a3
   18ca0:	000311c0 	.word	0x000311c0
   18ca4:	40015000 	.word	0x40015000
   18ca8:	20028684 	.word	0x20028684
   18cac:	00031202 	.word	0x00031202
   18cb0:	00031219 	.word	0x00031219

00018cb4 <z_timer_cycle_get_32>:

u32_t z_timer_cycle_get_32(void)
{
   18cb4:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   18cb6:	f04f 0320 	mov.w	r3, #32
   18cba:	f3ef 8511 	mrs	r5, BASEPRI
   18cbe:	f383 8811 	msr	BASEPRI, r3
   18cc2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   18cc6:	481b      	ldr	r0, [pc, #108]	; (18d34 <z_timer_cycle_get_32+0x80>)
   18cc8:	f00f fd0e 	bl	286e8 <z_spin_lock_valid>
   18ccc:	b968      	cbnz	r0, 18cea <z_timer_cycle_get_32+0x36>
   18cce:	234a      	movs	r3, #74	; 0x4a
   18cd0:	4a19      	ldr	r2, [pc, #100]	; (18d38 <z_timer_cycle_get_32+0x84>)
   18cd2:	491a      	ldr	r1, [pc, #104]	; (18d3c <z_timer_cycle_get_32+0x88>)
   18cd4:	481a      	ldr	r0, [pc, #104]	; (18d40 <z_timer_cycle_get_32+0x8c>)
   18cd6:	f014 fab8 	bl	2d24a <printk>
   18cda:	4916      	ldr	r1, [pc, #88]	; (18d34 <z_timer_cycle_get_32+0x80>)
   18cdc:	4819      	ldr	r0, [pc, #100]	; (18d44 <z_timer_cycle_get_32+0x90>)
   18cde:	f014 fab4 	bl	2d24a <printk>
   18ce2:	214a      	movs	r1, #74	; 0x4a
   18ce4:	4814      	ldr	r0, [pc, #80]	; (18d38 <z_timer_cycle_get_32+0x84>)
   18ce6:	f014 faf6 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   18cea:	4812      	ldr	r0, [pc, #72]	; (18d34 <z_timer_cycle_get_32+0x80>)
   18cec:	f00f fd1a 	bl	28724 <z_spin_lock_set_owner>
   18cf0:	4b15      	ldr	r3, [pc, #84]	; (18d48 <z_timer_cycle_get_32+0x94>)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   18cf2:	4810      	ldr	r0, [pc, #64]	; (18d34 <z_timer_cycle_get_32+0x80>)
   18cf4:	f8d3 4504 	ldr.w	r4, [r3, #1284]	; 0x504
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
   18cf8:	4b14      	ldr	r3, [pc, #80]	; (18d4c <z_timer_cycle_get_32+0x98>)
   18cfa:	681b      	ldr	r3, [r3, #0]
	return (a - b) & COUNTER_MAX;
   18cfc:	1ae4      	subs	r4, r4, r3
   18cfe:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
	u32_t ret = counter_sub(counter(), last_count) + last_count;
   18d02:	441c      	add	r4, r3
   18d04:	f00f fcfe 	bl	28704 <z_spin_unlock_valid>
   18d08:	b968      	cbnz	r0, 18d26 <z_timer_cycle_get_32+0x72>
   18d0a:	235d      	movs	r3, #93	; 0x5d
   18d0c:	4a0a      	ldr	r2, [pc, #40]	; (18d38 <z_timer_cycle_get_32+0x84>)
   18d0e:	4910      	ldr	r1, [pc, #64]	; (18d50 <z_timer_cycle_get_32+0x9c>)
   18d10:	480b      	ldr	r0, [pc, #44]	; (18d40 <z_timer_cycle_get_32+0x8c>)
   18d12:	f014 fa9a 	bl	2d24a <printk>
   18d16:	4907      	ldr	r1, [pc, #28]	; (18d34 <z_timer_cycle_get_32+0x80>)
   18d18:	480e      	ldr	r0, [pc, #56]	; (18d54 <z_timer_cycle_get_32+0xa0>)
   18d1a:	f014 fa96 	bl	2d24a <printk>
   18d1e:	215d      	movs	r1, #93	; 0x5d
   18d20:	4805      	ldr	r0, [pc, #20]	; (18d38 <z_timer_cycle_get_32+0x84>)
   18d22:	f014 fad8 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   18d26:	f385 8811 	msr	BASEPRI, r5
   18d2a:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
   18d2e:	4620      	mov	r0, r4
   18d30:	bd38      	pop	{r3, r4, r5, pc}
   18d32:	bf00      	nop
   18d34:	20028688 	.word	0x20028688
   18d38:	00031168 	.word	0x00031168
   18d3c:	0003118e 	.word	0x0003118e
   18d40:	000311a3 	.word	0x000311a3
   18d44:	000311c0 	.word	0x000311c0
   18d48:	40015000 	.word	0x40015000
   18d4c:	20028684 	.word	0x20028684
   18d50:	00031202 	.word	0x00031202
   18d54:	00031219 	.word	0x00031219

00018d58 <_DoInit>:
  SEGGER_RTT_CB* p;
  //
  // Initialize control block
  //
  p = &_SEGGER_RTT;
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   18d58:	2303      	movs	r3, #3
static void _DoInit(void) {
   18d5a:	b510      	push	{r4, lr}
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   18d5c:	4c10      	ldr	r4, [pc, #64]	; (18da0 <_DoInit+0x48>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
   18d5e:	4a11      	ldr	r2, [pc, #68]	; (18da4 <_DoInit+0x4c>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
   18d60:	e9c4 3304 	strd	r3, r3, [r4, #16]
  p->aUp[0].pBuffer       = _acUpBuffer;
   18d64:	4b10      	ldr	r3, [pc, #64]	; (18da8 <_DoInit+0x50>)
  p->aUp[0].sName         = "Terminal";
   18d66:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
   18d68:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
   18d6a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  p->aUp[0].WrOff         = 0u;
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
   18d6e:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
   18d70:	4a0e      	ldr	r2, [pc, #56]	; (18dac <_DoInit+0x54>)
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
   18d72:	6223      	str	r3, [r4, #32]
  p->aDown[0].pBuffer       = _acDownBuffer;
   18d74:	6662      	str	r2, [r4, #100]	; 0x64
  p->aUp[0].RdOff         = 0u;
   18d76:	2300      	movs	r3, #0
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
   18d78:	2210      	movs	r2, #16
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  strcpy(&p->acID[7], "RTT");
   18d7a:	490d      	ldr	r1, [pc, #52]	; (18db0 <_DoInit+0x58>)
   18d7c:	1de0      	adds	r0, r4, #7
  p->aUp[0].RdOff         = 0u;
   18d7e:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
   18d80:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   18d82:	62e3      	str	r3, [r4, #44]	; 0x2c
  p->aDown[0].RdOff         = 0u;
   18d84:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
   18d86:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   18d88:	6763      	str	r3, [r4, #116]	; 0x74
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
   18d8a:	66a2      	str	r2, [r4, #104]	; 0x68
  strcpy(&p->acID[7], "RTT");
   18d8c:	f016 fc83 	bl	2f696 <strcpy>
  strcpy(&p->acID[0], "SEGGER");
   18d90:	4908      	ldr	r1, [pc, #32]	; (18db4 <_DoInit+0x5c>)
   18d92:	4620      	mov	r0, r4
   18d94:	f016 fc7f 	bl	2f696 <strcpy>
  p->acID[6] = ' ';
   18d98:	2320      	movs	r3, #32
   18d9a:	71a3      	strb	r3, [r4, #6]
}
   18d9c:	bd10      	pop	{r4, pc}
   18d9e:	bf00      	nop
   18da0:	2002868c 	.word	0x2002868c
   18da4:	0003290b 	.word	0x0003290b
   18da8:	2003008f 	.word	0x2003008f
   18dac:	2003007f 	.word	0x2003007f
   18db0:	00032914 	.word	0x00032914
   18db4:	00032918 	.word	0x00032918

00018db8 <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   18db8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  RdOff = pRing->RdOff;
   18dbc:	f04f 0b18 	mov.w	fp, #24
   18dc0:	4e22      	ldr	r6, [pc, #136]	; (18e4c <SEGGER_RTT_WriteSkipNoLock+0x94>)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   18dc2:	4614      	mov	r4, r2
  RdOff = pRing->RdOff;
   18dc4:	fb0b 6200 	mla	r2, fp, r0, r6
   18dc8:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
   18dca:	6a55      	ldr	r5, [r2, #36]	; 0x24
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   18dcc:	4607      	mov	r7, r0
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   18dce:	42ab      	cmp	r3, r5
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
   18dd0:	4688      	mov	r8, r1
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
   18dd2:	d834      	bhi.n	18e3e <SEGGER_RTT_WriteSkipNoLock+0x86>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
   18dd4:	f8d2 a020 	ldr.w	sl, [r2, #32]
   18dd8:	ebaa 0905 	sub.w	r9, sl, r5
   18ddc:	f109 32ff 	add.w	r2, r9, #4294967295
    if (Avail >= NumBytes) {                            // Case 1)?
   18de0:	42a2      	cmp	r2, r4
   18de2:	d311      	bcc.n	18e08 <SEGGER_RTT_WriteSkipNoLock+0x50>
CopyStraight:
      memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
   18de4:	f04f 0918 	mov.w	r9, #24
   18de8:	fb07 9309 	mla	r3, r7, r9, r9
   18dec:	4433      	add	r3, r6
   18dee:	6858      	ldr	r0, [r3, #4]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   18df0:	4622      	mov	r2, r4
   18df2:	4641      	mov	r1, r8
   18df4:	4428      	add	r0, r5
   18df6:	f016 faad 	bl	2f354 <memcpy>
      pRing->WrOff = WrOff + NumBytes;
   18dfa:	fb09 6607 	mla	r6, r9, r7, r6
   18dfe:	442c      	add	r4, r5
      //
      if (NumBytes) {
        memcpy(pRing->pBuffer, pData + Rem, NumBytes);
      }
      pRing->WrOff = NumBytes;
      return 1;
   18e00:	2001      	movs	r0, #1
      pRing->WrOff = NumBytes;
   18e02:	6274      	str	r4, [r6, #36]	; 0x24
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
}
   18e04:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Avail += RdOff;                                     // Space incl. wrap-around
   18e08:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
   18e0a:	429c      	cmp	r4, r3
   18e0c:	d81b      	bhi.n	18e46 <SEGGER_RTT_WriteSkipNoLock+0x8e>
      memcpy(pRing->pBuffer + WrOff, pData, Rem);       // Copy 1st chunk
   18e0e:	fb00 bb0b 	mla	fp, r0, fp, fp
   18e12:	44b3      	add	fp, r6
   18e14:	f8db 0004 	ldr.w	r0, [fp, #4]
   18e18:	464a      	mov	r2, r9
   18e1a:	4428      	add	r0, r5
   18e1c:	442c      	add	r4, r5
   18e1e:	f016 fa99 	bl	2f354 <memcpy>
      if (NumBytes) {
   18e22:	ebb4 040a 	subs.w	r4, r4, sl
   18e26:	d006      	beq.n	18e36 <SEGGER_RTT_WriteSkipNoLock+0x7e>
   18e28:	4622      	mov	r2, r4
   18e2a:	eb08 0109 	add.w	r1, r8, r9
   18e2e:	f8db 0004 	ldr.w	r0, [fp, #4]
   18e32:	f016 fa8f 	bl	2f354 <memcpy>
      pRing->WrOff = NumBytes;
   18e36:	2318      	movs	r3, #24
   18e38:	fb03 6607 	mla	r6, r3, r7, r6
   18e3c:	e7e0      	b.n	18e00 <SEGGER_RTT_WriteSkipNoLock+0x48>
    Avail = RdOff - WrOff - 1u;
   18e3e:	3b01      	subs	r3, #1
   18e40:	1b5b      	subs	r3, r3, r5
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
   18e42:	429c      	cmp	r4, r3
   18e44:	d9ce      	bls.n	18de4 <SEGGER_RTT_WriteSkipNoLock+0x2c>
  return 0;     // No space in buffer
   18e46:	2000      	movs	r0, #0
   18e48:	e7dc      	b.n	18e04 <SEGGER_RTT_WriteSkipNoLock+0x4c>
   18e4a:	bf00      	nop
   18e4c:	2002868c 	.word	0x2002868c

00018e50 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = &_SEGGER_RTT.aUp[BufferIndex];
  v = pRing->RdOff;
   18e50:	2318      	movs	r3, #24
   18e52:	4a03      	ldr	r2, [pc, #12]	; (18e60 <SEGGER_RTT_HasDataUp+0x10>)
   18e54:	fb03 2300 	mla	r3, r3, r0, r2
   18e58:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  return pRing->WrOff - v;
   18e5a:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
   18e5c:	1a80      	subs	r0, r0, r2
   18e5e:	4770      	bx	lr
   18e60:	2002868c 	.word	0x2002868c

00018e64 <z_arm_exc_exit>:
    /* r0 contains the caller mode */
    push {r0, lr}
#endif

#ifdef CONFIG_PREEMPT_ENABLED
    ldr r0, =_kernel
   18e64:	4804      	ldr	r0, [pc, #16]	; (18e78 <_EXIT_EXC+0x2>)

    ldr r1, [r0, #_kernel_offset_to_current]
   18e66:	6881      	ldr	r1, [r0, #8]

    ldr r0, [r0, #_kernel_offset_to_ready_q_cache]
   18e68:	6a40      	ldr	r0, [r0, #36]	; 0x24
    cmp r0, r1
   18e6a:	4288      	cmp	r0, r1
    beq _EXIT_EXC
   18e6c:	d003      	beq.n	18e76 <_EXIT_EXC>

#if defined(CONFIG_CPU_CORTEX_M)
    /* context switch required, pend the PendSV exception */
    ldr r1, =_SCS_ICSR
   18e6e:	4903      	ldr	r1, [pc, #12]	; (18e7c <_EXIT_EXC+0x6>)
    ldr r2, =_SCS_ICSR_PENDSV
   18e70:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    str r2, [r1]
   18e74:	600a      	str	r2, [r1, #0]

00018e76 <_EXIT_EXC>:
    bl z_check_stack_sentinel
#endif /* CONFIG_CPU_CORTEX_M */
#endif /* CONFIG_STACK_SENTINEL */

#if defined(CONFIG_CPU_CORTEX_M)
    bx lr
   18e76:	4770      	bx	lr
    ldr r0, =_kernel
   18e78:	2002d2e8 	.word	0x2002d2e8
    ldr r1, =_SCS_ICSR
   18e7c:	e000ed04 	.word	0xe000ed04

00018e80 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   18e80:	492e      	ldr	r1, [pc, #184]	; (18f3c <in_fp_endif+0x40>)
    ldr r2, [r1, #_kernel_offset_to_current]
   18e82:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   18e84:	f04f 0028 	mov.w	r0, #40	; 0x28
    add r0, r2
   18e88:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   18e8a:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   18e8e:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#ifdef CONFIG_FP_SHARING
    /* Assess whether switched-out thread had been using the FP registers. */
    ldr r0, =0x10 /* EXC_RETURN.F_Type Mask */
   18e92:	f04f 0010 	mov.w	r0, #16
    tst lr, r0    /* EXC_RETURN & EXC_RETURN.F_Type_Msk */
   18e96:	ea1e 0f00 	tst.w	lr, r0
    beq out_fp_active
   18e9a:	d004      	beq.n	18ea6 <out_fp_active>
    /* FP context inactive: clear FP state */
    ldr r0, [r2, #_thread_offset_to_mode]
   18e9c:	f8d2 00ac 	ldr.w	r0, [r2, #172]	; 0xac
    bic r0, #0x4 /* _current->arch.mode &= ~(CONTROL_FPCA_Msk) */
   18ea0:	f020 0004 	bic.w	r0, r0, #4
    b out_fp_endif
   18ea4:	e007      	b.n	18eb6 <out_fp_endif>

00018ea6 <out_fp_active>:

out_fp_active:
    /* FP context active: set FP state and store callee-saved registers */
    add r0, r2, #_thread_offset_to_preempt_float
   18ea6:	f102 006c 	add.w	r0, r2, #108	; 0x6c
    vstmia r0, {s16-s31}
   18eaa:	ec80 8a10 	vstmia	r0, {s16-s31}
    ldr r0, [r2, #_thread_offset_to_mode]
   18eae:	f8d2 00ac 	ldr.w	r0, [r2, #172]	; 0xac
    orrs r0, r0, #0x4 /* _current->arch.mode |= CONTROL_FPCA_Msk */
   18eb2:	f050 0004 	orrs.w	r0, r0, #4

00018eb6 <out_fp_endif>:

out_fp_endif:
    str r0, [r2, #_thread_offset_to_mode]
   18eb6:	f8c2 00ac 	str.w	r0, [r2, #172]	; 0xac

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   18eba:	2020      	movs	r0, #32
    msr BASEPRI, r0
   18ebc:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   18ec0:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   18ec4:	4f1e      	ldr	r7, [pc, #120]	; (18f40 <in_fp_endif+0x44>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   18ec6:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   18eca:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
   18ecc:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   18ece:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   18ed0:	6e50      	ldr	r0, [r2, #100]	; 0x64
    movs r3, #0
   18ed2:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   18ed4:	6653      	str	r3, [r2, #100]	; 0x64
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   18ed6:	f380 8811 	msr	BASEPRI, r0

#ifdef CONFIG_FP_SHARING
    /* Assess whether switched-in thread had been using the FP registers. */
    ldr r0, [r2, #_thread_offset_to_mode]
   18eda:	f8d2 00ac 	ldr.w	r0, [r2, #172]	; 0xac
    tst r0, #0x04 /* thread.arch.mode & CONTROL.FPCA Msk */
   18ede:	f010 0f04 	tst.w	r0, #4
    bne in_fp_active
   18ee2:	d105      	bne.n	18ef0 <in_fp_active>
    /* FP context inactive for swapped-in thread:
     * - reset FPSCR to 0
     * - set EXC_RETURN.F_Type (prevents FP frame un-stacking when returning
     *   from pendSV)
     */
    movs.n r3, #0
   18ee4:	2300      	movs	r3, #0
    vmsr fpscr, r3
   18ee6:	eee1 3a10 	vmsr	fpscr, r3
    orrs lr, lr, #0x10 /* EXC_RETURN & EXC_RETURN.F_Type_Msk */
   18eea:	f05e 0e10 	orrs.w	lr, lr, #16
    b in_fp_endif
   18eee:	e005      	b.n	18efc <in_fp_endif>

00018ef0 <in_fp_active>:
    /* FP context active:
     * - clear EXC_RETURN.F_Type
     * - FPSCR and caller-saved registers will be restored automatically
     * - restore callee-saved FP registers
     */
    bic lr, #0x10 /* EXC_RETURN | (~EXC_RETURN.F_Type_Msk) */
   18ef0:	f02e 0e10 	bic.w	lr, lr, #16
    add r0, r2, #_thread_offset_to_preempt_float
   18ef4:	f102 006c 	add.w	r0, r2, #108	; 0x6c
    vldmia r0, {s16-s31}
   18ef8:	ec90 8a10 	vldmia	r0, {s16-s31}

00018efc <in_fp_endif>:
in_fp_endif:
    /* Clear CONTROL.FPCA that may have been set by FP instructions */
    mrs r3, CONTROL
   18efc:	f3ef 8314 	mrs	r3, CONTROL
    bic r3, #0x4 /* CONTROL.FPCA Msk */
   18f00:	f023 0304 	bic.w	r3, r3, #4
    msr CONTROL, r3
   18f04:	f383 8814 	msr	CONTROL, r3
    isb
   18f08:	f3bf 8f6f 	isb	sy
#endif

#if defined (CONFIG_ARM_MPU)
    /* Re-program dynamic memory map */
    push {r2,lr}
   18f0c:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
   18f0e:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
   18f10:	f014 fb4d 	bl	2d5ae <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
   18f14:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   18f18:	f102 0028 	add.w	r0, r2, #40	; 0x28
    ldmia r0, {v1-v8, ip}
   18f1c:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* clear stack pointer limit before setting the PSP */
    mov r0, #0
   18f20:	f04f 0000 	mov.w	r0, #0
    msr PSPLIM, r0
   18f24:	f380 880b 	msr	PSPLIM, r0
#endif /* CONFIG_BUILTIN_STACK_GUARD */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   18f28:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
   18f2c:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
   18f30:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
   18f32:	f014 fb2d 	bl	2d590 <configure_builtin_stack_guard>
    pop {r2, lr}
   18f36:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
   18f3a:	4770      	bx	lr
    ldr r1, =_kernel
   18f3c:	2002d2e8 	.word	0x2002d2e8
    ldr v4, =_SCS_ICSR
   18f40:	e000ed04 	.word	0xe000ed04

00018f44 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
   18f44:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   18f48:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   18f4a:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   18f4e:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   18f52:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   18f54:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   18f58:	2902      	cmp	r1, #2
    beq _oops
   18f5a:	d0ff      	beq.n	18f5c <_oops>

00018f5c <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   18f5c:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
   18f5e:	f014 fb1b 	bl	2d598 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
   18f62:	bd01      	pop	{r0, pc}

00018f64 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr r1, =_SCB_SCR
   18f64:	4901      	ldr	r1, [pc, #4]	; (18f6c <z_arm_cpu_idle_init+0x8>)
	movs.n r2, #_SCR_INIT_BITS
   18f66:	2210      	movs	r2, #16
	str r2, [r1]
   18f68:	600a      	str	r2, [r1, #0]
#endif
	bx lr
   18f6a:	4770      	bx	lr
	ldr r1, =_SCB_SCR
   18f6c:	e000ed10 	.word	0xe000ed10

00018f70 <arch_cpu_idle>:
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	cpsie i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* clear BASEPRI so wfi is awakened by incoming interrupts */
	eors.n r0, r0
   18f70:	4040      	eors	r0, r0
	msr BASEPRI, r0
   18f72:	f380 8811 	msr	BASEPRI, r0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	wfi
   18f76:	bf30      	wfi

	bx lr
   18f78:	4770      	bx	lr
   18f7a:	bf00      	nop

00018f7c <z_arm_bus_fault>:
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_reserved)

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) || \
	defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	mrs r0, MSP
   18f7c:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   18f80:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
   18f84:	4672      	mov	r2, lr

	push {r0, lr}
   18f86:	b501      	push	{r0, lr}
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE || CONFIG_ARMv7_M_ARMV8_M_MAINLINE */

	bl z_arm_fault
   18f88:	f000 fbae 	bl	196e8 <z_arm_fault>

#if defined(CONFIG_CPU_CORTEX_M)
	pop {r0, pc}
   18f8c:	bd01      	pop	{r0, pc}
   18f8e:	bf00      	nop

00018f90 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   18f90:	bf30      	wfi
    b z_SysNmiOnReset
   18f92:	f7ff bffd 	b.w	18f90 <z_SysNmiOnReset>
   18f96:	bf00      	nop

00018f98 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   18f98:	b501      	push	{r0, lr}
      * FIXME: Remove the Cortex-M conditional compilation checks for `cpsid i`
      *        and `cpsie i` after the Cortex-R port is updated to support
      *        interrupt nesting.  For more details, refer to the issue #21758.
      */
#if defined(CONFIG_CPU_CORTEX_M)
	cpsid i  /* PRIMASK = 1 */
   18f9a:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   18f9c:	4a0b      	ldr	r2, [pc, #44]	; (18fcc <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   18f9e:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
   18fa0:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   18fa2:	bf1e      	ittt	ne
	movne	r1, #0
   18fa4:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   18fa6:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
   18fa8:	f015 fff0 	blne	2ef8c <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   18fac:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   18fae:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   18fb2:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   18fb6:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 */
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldr r1, =_sw_isr_table
   18fba:	4905      	ldr	r1, [pc, #20]	; (18fd0 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   18fbc:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   18fbe:	c909      	ldmia	r1!, {r0, r3}
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldm sp!,{r0-r3} /* Restore r0 to r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
   18fc0:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   18fc2:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   18fc6:	4903      	ldr	r1, [pc, #12]	; (18fd4 <_isr_wrapper+0x3c>)
	bx r1
   18fc8:	4708      	bx	r1
   18fca:	0000      	.short	0x0000
	ldr r2, =_kernel
   18fcc:	2002d2e8 	.word	0x2002d2e8
	ldr r1, =_sw_isr_table
   18fd0:	000300f0 	.word	0x000300f0
	ldr r1, =z_arm_int_exit
   18fd4:	00018e65 	.word	0x00018e65

00018fd8 <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
   18fd8:	4a09      	ldr	r2, [pc, #36]	; (19000 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
   18fda:	490a      	ldr	r1, [pc, #40]	; (19004 <arch_swap+0x2c>)
	_current->arch.basepri = key;
   18fdc:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   18fde:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
   18fe0:	6658      	str	r0, [r3, #100]	; 0x64
	_current->arch.swap_return_value = _k_neg_eagain;
   18fe2:	6699      	str	r1, [r3, #104]	; 0x68

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   18fe4:	4908      	ldr	r1, [pc, #32]	; (19008 <arch_swap+0x30>)
   18fe6:	684b      	ldr	r3, [r1, #4]
   18fe8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   18fec:	604b      	str	r3, [r1, #4]
   18fee:	2300      	movs	r3, #0
   18ff0:	f383 8811 	msr	BASEPRI, r3
   18ff4:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   18ff8:	6893      	ldr	r3, [r2, #8]
}
   18ffa:	6e98      	ldr	r0, [r3, #104]	; 0x68
   18ffc:	4770      	bx	lr
   18ffe:	bf00      	nop
   19000:	2002d2e8 	.word	0x2002d2e8
   19004:	00030ea4 	.word	0x00030ea4
   19008:	e000ed00 	.word	0xe000ed00

0001900c <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   1900c:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
   1900e:	2b00      	cmp	r3, #0
   19010:	db08      	blt.n	19024 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   19012:	2201      	movs	r2, #1
   19014:	f000 001f 	and.w	r0, r0, #31
   19018:	fa02 f000 	lsl.w	r0, r2, r0
   1901c:	4a02      	ldr	r2, [pc, #8]	; (19028 <arch_irq_enable+0x1c>)
   1901e:	095b      	lsrs	r3, r3, #5
   19020:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   19024:	4770      	bx	lr
   19026:	bf00      	nop
   19028:	e000e100 	.word	0xe000e100

0001902c <z_arm_irq_priority_set>:
 * priority levels which are reserved.
 *
 * @return N/A
 */
void z_arm_irq_priority_set(unsigned int irq, unsigned int prio, u32_t flags)
{
   1902c:	b570      	push	{r4, r5, r6, lr}
	} else {
		prio += _IRQ_PRIO_OFFSET;
	}
#else
	ARG_UNUSED(flags);
	prio += _IRQ_PRIO_OFFSET;
   1902e:	1c4c      	adds	r4, r1, #1
	/* The last priority level is also used by PendSV exception, but
	 * allow other interrupts to use the same level, even if it ends up
	 * affecting performance (can still be useful on systems with a
	 * reduced set of priorities, like Cortex-M0/M0+).
	 */
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
   19030:	2c07      	cmp	r4, #7
{
   19032:	4605      	mov	r5, r0
   19034:	460e      	mov	r6, r1
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
   19036:	d90e      	bls.n	19056 <z_arm_irq_priority_set+0x2a>
   19038:	235f      	movs	r3, #95	; 0x5f
   1903a:	4a10      	ldr	r2, [pc, #64]	; (1907c <z_arm_irq_priority_set+0x50>)
   1903c:	4910      	ldr	r1, [pc, #64]	; (19080 <z_arm_irq_priority_set+0x54>)
   1903e:	4811      	ldr	r0, [pc, #68]	; (19084 <z_arm_irq_priority_set+0x58>)
   19040:	f014 f903 	bl	2d24a <printk>
   19044:	4631      	mov	r1, r6
   19046:	4810      	ldr	r0, [pc, #64]	; (19088 <z_arm_irq_priority_set+0x5c>)
   19048:	2207      	movs	r2, #7
   1904a:	f014 f8fe 	bl	2d24a <printk>
   1904e:	215f      	movs	r1, #95	; 0x5f
   19050:	480a      	ldr	r0, [pc, #40]	; (1907c <z_arm_irq_priority_set+0x50>)
   19052:	f014 f940 	bl	2d2d6 <assert_post_action>
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(DT_NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   19056:	b26b      	sxtb	r3, r5
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   19058:	2b00      	cmp	r3, #0
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1905a:	bfa8      	it	ge
   1905c:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
   19060:	ea4f 1444 	mov.w	r4, r4, lsl #5
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   19064:	bfb8      	it	lt
   19066:	4b09      	ldrlt	r3, [pc, #36]	; (1908c <z_arm_irq_priority_set+0x60>)
   19068:	b2e4      	uxtb	r4, r4
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1906a:	bfab      	itete	ge
   1906c:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   19070:	f005 050f 	andlt.w	r5, r5, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   19074:	f883 4300 	strbge.w	r4, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   19078:	555c      	strblt	r4, [r3, r5]
}
   1907a:	bd70      	pop	{r4, r5, r6, pc}
   1907c:	0003291f 	.word	0x0003291f
   19080:	00032955 	.word	0x00032955
   19084:	000311a3 	.word	0x000311a3
   19088:	00032970 	.word	0x00032970
   1908c:	e000ed14 	.word	0xe000ed14

00019090 <_arch_isr_direct_pm>:
	z_arm_reserved();
}

#ifdef CONFIG_SYS_POWER_MANAGEMENT
void _arch_isr_direct_pm(void)
{
   19090:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
   19092:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
   19094:	4b04      	ldr	r3, [pc, #16]	; (190a8 <_arch_isr_direct_pm+0x18>)
   19096:	6a18      	ldr	r0, [r3, #32]
   19098:	b118      	cbz	r0, 190a2 <_arch_isr_direct_pm+0x12>
		s32_t idle_val = _kernel.idle;

		_kernel.idle = 0;
   1909a:	2200      	movs	r2, #0
   1909c:	621a      	str	r2, [r3, #32]
		z_sys_power_save_idle_exit(idle_val);
   1909e:	f015 ff75 	bl	2ef8c <z_sys_power_save_idle_exit>

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
   190a2:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
   190a4:	bd08      	pop	{r3, pc}
   190a6:	bf00      	nop
   190a8:	2002d2e8 	.word	0x2002d2e8

000190ac <arch_new_thread>:
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     size_t stackSize, k_thread_entry_t pEntry,
		     void *parameter1, void *parameter2, void *parameter3,
		     int priority, unsigned int options)
{
   190ac:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   190b0:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   190b2:	4605      	mov	r5, r0
	char *pStackMem = Z_THREAD_STACK_BUFFER(stack);
	char *stackEnd;
	/* Offset between the top of stack and the high end of stack area. */
	u32_t top_of_stack_offset = 0U;

	Z_ASSERT_VALID_PRIO(priority, pEntry);
   190b4:	2e0f      	cmp	r6, #15
{
   190b6:	4688      	mov	r8, r1
   190b8:	4691      	mov	r9, r2
   190ba:	461f      	mov	r7, r3
	Z_ASSERT_VALID_PRIO(priority, pEntry);
   190bc:	d126      	bne.n	1910c <arch_new_thread+0x60>
   190be:	4b1e      	ldr	r3, [pc, #120]	; (19138 <arch_new_thread+0x8c>)
   190c0:	429f      	cmp	r7, r3
   190c2:	d127      	bne.n	19114 <arch_new_thread+0x68>
#endif
	stackEnd = pStackMem + stackSize;

	struct __esf *pInitCtx;

	z_new_thread_init(thread, pStackMem, stackSize, priority,
   190c4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   190c6:	464a      	mov	r2, r9
   190c8:	9300      	str	r3, [sp, #0]
   190ca:	4641      	mov	r1, r8
   190cc:	4633      	mov	r3, r6
   190ce:	4628      	mov	r0, r5
   190d0:	f016 f80d 	bl	2f0ee <z_new_thread_init>
	stackEnd = pStackMem + stackSize;
   190d4:	eb08 0409 	add.w	r4, r8, r9
	pInitCtx->basic.pc = (u32_t)z_thread_entry;
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
   190d8:	4a18      	ldr	r2, [pc, #96]	; (1913c <arch_new_thread+0x90>)
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
   190da:	f1a4 0320 	sub.w	r3, r4, #32
   190de:	f023 0307 	bic.w	r3, r3, #7
	pInitCtx->basic.pc &= 0xfffffffe;
   190e2:	f022 0201 	bic.w	r2, r2, #1
   190e6:	619a      	str	r2, [r3, #24]
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
	pInitCtx->basic.a2 = (u32_t)parameter1;
   190e8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
	pInitCtx->basic.a1 = (u32_t)pEntry;
   190ea:	601f      	str	r7, [r3, #0]
	pInitCtx->basic.a2 = (u32_t)parameter1;
   190ec:	605a      	str	r2, [r3, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
   190ee:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   190f0:	609a      	str	r2, [r3, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
   190f2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   190f4:	60da      	str	r2, [r3, #12]
	pInitCtx->basic.xpsr =
   190f6:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   190fa:	61da      	str	r2, [r3, #28]
		0x01000000UL; /* clear all, thumb bit is 1, even if RO */

	thread->callee_saved.psp = (u32_t)pInitCtx;
   190fc:	64ab      	str	r3, [r5, #72]	; 0x48
#if defined(CONFIG_CPU_CORTEX_R)
	pInitCtx->basic.lr = (u32_t)pInitCtx->basic.pc;
	thread->callee_saved.spsr = A_BIT | T_BIT | MODE_SYS;
	thread->callee_saved.lr = (u32_t)pInitCtx->basic.pc;
#endif
	thread->arch.basepri = 0;
   190fe:	2300      	movs	r3, #0
   19100:	666b      	str	r3, [r5, #100]	; 0x64

#if defined(CONFIG_USERSPACE) || defined(CONFIG_FP_SHARING)
	thread->arch.mode = 0;
   19102:	f8c5 30ac 	str.w	r3, [r5, #172]	; 0xac

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   19106:	b003      	add	sp, #12
   19108:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	Z_ASSERT_VALID_PRIO(priority, pEntry);
   1910c:	f106 0310 	add.w	r3, r6, #16
   19110:	2b1e      	cmp	r3, #30
   19112:	d9d7      	bls.n	190c4 <arch_new_thread+0x18>
   19114:	232d      	movs	r3, #45	; 0x2d
   19116:	4a0a      	ldr	r2, [pc, #40]	; (19140 <arch_new_thread+0x94>)
   19118:	490a      	ldr	r1, [pc, #40]	; (19144 <arch_new_thread+0x98>)
   1911a:	480b      	ldr	r0, [pc, #44]	; (19148 <arch_new_thread+0x9c>)
   1911c:	f014 f895 	bl	2d24a <printk>
   19120:	4631      	mov	r1, r6
   19122:	f06f 030f 	mvn.w	r3, #15
   19126:	220e      	movs	r2, #14
   19128:	4808      	ldr	r0, [pc, #32]	; (1914c <arch_new_thread+0xa0>)
   1912a:	f014 f88e 	bl	2d24a <printk>
   1912e:	212d      	movs	r1, #45	; 0x2d
   19130:	4803      	ldr	r0, [pc, #12]	; (19140 <arch_new_thread+0x94>)
   19132:	f014 f8d0 	bl	2d2d6 <assert_post_action>
   19136:	e7c5      	b.n	190c4 <arch_new_thread+0x18>
   19138:	00026319 	.word	0x00026319
   1913c:	0002d28d 	.word	0x0002d28d
   19140:	000329a5 	.word	0x000329a5
   19144:	000329d7 	.word	0x000329d7
   19148:	000311a3 	.word	0x000311a3
   1914c:	00032a64 	.word	0x00032a64

00019150 <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
   19150:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19152:	461f      	mov	r7, r3
   19154:	4606      	mov	r6, r0
   19156:	460d      	mov	r5, r1
   19158:	4614      	mov	r4, r2
// Re-enable using built-in when GCC has been fixed
// || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
  __builtin_arm_set_fpscr(fpscr);
#else
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
   1915a:	2300      	movs	r3, #0
   1915c:	eee1 3a10 	vmsr	fpscr, r3
  __ASM volatile ("MRS %0, control" : "=r" (result) );
   19160:	f3ef 8214 	mrs	r2, CONTROL
	 * initialized at thread creation for threads that make use of the FP).
	 */
	__set_FPSCR(0);
#if defined(CONFIG_FP_SHARING)
	/* In Sharing mode clearing FPSCR may set the CONTROL.FPCA flag. */
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
   19164:	f022 0204 	bic.w	r2, r2, #4
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
   19168:	f382 8814 	msr	CONTROL, r2
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
   1916c:	f3bf 8f6f 	isb	sy
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   19170:	f000 fc2a 	bl	199c8 <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);

	_current = main_thread;
   19174:	4b0b      	ldr	r3, [pc, #44]	; (191a4 <arch_switch_to_main_thread+0x54>)
	start_of_main_stack =
   19176:	442c      	add	r4, r5
#ifdef CONFIG_ARM_MPU
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
   19178:	4630      	mov	r0, r6
	_current = main_thread;
   1917a:	609e      	str	r6, [r3, #8]
	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);
   1917c:	f024 0407 	bic.w	r4, r4, #7
	z_arm_configure_dynamic_mpu_regions(main_thread);
   19180:	f014 fa15 	bl	2d5ae <z_arm_configure_dynamic_mpu_regions>
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   19184:	f385 880b 	msr	PSPLIM, r5

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   19188:	4638      	mov	r0, r7
   1918a:	f384 8809 	msr	PSP, r4
   1918e:	2100      	movs	r1, #0
   19190:	b663      	cpsie	if
   19192:	f381 8811 	msr	BASEPRI, r1
   19196:	f3bf 8f6f 	isb	sy
   1919a:	2200      	movs	r2, #0
   1919c:	2300      	movs	r3, #0
   1919e:	f014 f875 	bl	2d28c <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   191a2:	bf00      	nop
   191a4:	2002d2e8 	.word	0x2002d2e8

000191a8 <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   191a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   191ac:	4681      	mov	r9, r0
   191ae:	b086      	sub	sp, #24

	if (esf != NULL) {
   191b0:	460c      	mov	r4, r1
   191b2:	2900      	cmp	r1, #0
   191b4:	d075      	beq.n	192a2 <z_arm_fatal_error+0xfa>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
   191b6:	2301      	movs	r3, #1
   191b8:	f04f 0000 	mov.w	r0, #0
   191bc:	4d3c      	ldr	r5, [pc, #240]	; (192b0 <z_arm_fatal_error+0x108>)
   191be:	f363 0007 	bfi	r0, r3, #0, #8
   191c2:	4b3c      	ldr	r3, [pc, #240]	; (192b4 <z_arm_fatal_error+0x10c>)
   191c4:	4627      	mov	r7, r4
   191c6:	1aed      	subs	r5, r5, r3
   191c8:	688b      	ldr	r3, [r1, #8]
   191ca:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   191ce:	9300      	str	r3, [sp, #0]
   191d0:	e9d1 2300 	ldrd	r2, r3, [r1]
   191d4:	f365 108f 	bfi	r0, r5, #6, #10
   191d8:	4937      	ldr	r1, [pc, #220]	; (192b8 <z_arm_fatal_error+0x110>)
   191da:	f014 f88d 	bl	2d2f8 <log_string_sync>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
   191de:	2301      	movs	r3, #1
   191e0:	f04f 0000 	mov.w	r0, #0
   191e4:	f363 0007 	bfi	r0, r3, #0, #8
   191e8:	6963      	ldr	r3, [r4, #20]
   191ea:	f365 108f 	bfi	r0, r5, #6, #10
   191ee:	9300      	str	r3, [sp, #0]
   191f0:	e9d4 2303 	ldrd	r2, r3, [r4, #12]
   191f4:	4931      	ldr	r1, [pc, #196]	; (192bc <z_arm_fatal_error+0x114>)
   191f6:	f014 f87f 	bl	2d2f8 <log_string_sync>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
   191fa:	2301      	movs	r3, #1
   191fc:	f04f 0000 	mov.w	r0, #0
   19200:	f363 0007 	bfi	r0, r3, #0, #8
   19204:	f365 108f 	bfi	r0, r5, #6, #10
   19208:	69e2      	ldr	r2, [r4, #28]
   1920a:	492d      	ldr	r1, [pc, #180]	; (192c0 <z_arm_fatal_error+0x118>)
   1920c:	f014 f874 	bl	2d2f8 <log_string_sync>
	for (int i = 0; i < 16; i += 4) {
   19210:	2600      	movs	r6, #0
		LOG_ERR("s[%2d]:  0x%08x  s[%2d]:  0x%08x"
   19212:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 192cc <z_arm_fatal_error+0x124>
   19216:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
   1921a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1921e:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   19222:	f043 0301 	orr.w	r3, r3, #1
   19226:	f363 0807 	bfi	r8, r3, #0, #8
   1922a:	1cf3      	adds	r3, r6, #3
   1922c:	ed97 7a08 	vldr	s14, [r7, #32]
   19230:	9304      	str	r3, [sp, #16]
   19232:	edcd 7a05 	vstr	s15, [sp, #20]
   19236:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
   1923a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1923e:	1cb3      	adds	r3, r6, #2
   19240:	9302      	str	r3, [sp, #8]
   19242:	edcd 7a03 	vstr	s15, [sp, #12]
   19246:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
   1924a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1924e:	edcd 7a01 	vstr	s15, [sp, #4]
   19252:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   19256:	1c73      	adds	r3, r6, #1
   19258:	f365 188f 	bfi	r8, r5, #6, #10
   1925c:	9300      	str	r3, [sp, #0]
   1925e:	4632      	mov	r2, r6
   19260:	ee17 3a90 	vmov	r3, s15
   19264:	4651      	mov	r1, sl
   19266:	4640      	mov	r0, r8
	for (int i = 0; i < 16; i += 4) {
   19268:	3604      	adds	r6, #4
		LOG_ERR("s[%2d]:  0x%08x  s[%2d]:  0x%08x"
   1926a:	f014 f845 	bl	2d2f8 <log_string_sync>
	for (int i = 0; i < 16; i += 4) {
   1926e:	2e10      	cmp	r6, #16
   19270:	f107 0710 	add.w	r7, r7, #16
   19274:	d1cf      	bne.n	19216 <z_arm_fatal_error+0x6e>
	LOG_ERR("fpscr:  0x%08x", esf->fpscr);
   19276:	2301      	movs	r3, #1
   19278:	f04f 0000 	mov.w	r0, #0
   1927c:	f363 0007 	bfi	r0, r3, #0, #8
   19280:	f365 108f 	bfi	r0, r5, #6, #10
   19284:	6e22      	ldr	r2, [r4, #96]	; 0x60
   19286:	490f      	ldr	r1, [pc, #60]	; (192c4 <z_arm_fatal_error+0x11c>)
   19288:	f014 f836 	bl	2d2f8 <log_string_sync>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
   1928c:	f04f 0000 	mov.w	r0, #0
   19290:	2301      	movs	r3, #1
   19292:	f363 0007 	bfi	r0, r3, #0, #8
   19296:	f365 108f 	bfi	r0, r5, #6, #10
   1929a:	69a2      	ldr	r2, [r4, #24]
   1929c:	490a      	ldr	r1, [pc, #40]	; (192c8 <z_arm_fatal_error+0x120>)
   1929e:	f014 f82b 	bl	2d2f8 <log_string_sync>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   192a2:	4621      	mov	r1, r4
   192a4:	4648      	mov	r0, r9
}
   192a6:	b006      	add	sp, #24
   192a8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_fatal_error(reason, esf);
   192ac:	f00c bfb8 	b.w	26220 <z_fatal_error>
   192b0:	000304dc 	.word	0x000304dc
   192b4:	0003040c 	.word	0x0003040c
   192b8:	00032a95 	.word	0x00032a95
   192bc:	00032ac4 	.word	0x00032ac4
   192c0:	00032af3 	.word	0x00032af3
   192c4:	00032b45 	.word	0x00032b45
   192c8:	00032b54 	.word	0x00032b54
   192cc:	00032b02 	.word	0x00032b02

000192d0 <z_arm_prep_c>:
#else
#define VECTOR_ADDRESS CONFIG_SRAM_BASE_ADDRESS
#endif
static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   192d0:	4a11      	ldr	r2, [pc, #68]	; (19318 <z_arm_prep_c+0x48>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
   192d2:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   192d4:	4b11      	ldr	r3, [pc, #68]	; (1931c <z_arm_prep_c+0x4c>)
   192d6:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   192da:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   192dc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   192e0:	f3bf 8f6f 	isb	sy
	SCB->CPACR |= CPACR_CP10_PRIV_ACCESS | CPACR_CP11_PRIV_ACCESS;
   192e4:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   192e8:	f442 02a0 	orr.w	r2, r2, #5242880	; 0x500000
   192ec:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	FPU->FPCCR = FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk;
   192f0:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
   192f4:	f8c3 2234 	str.w	r2, [r3, #564]	; 0x234
  __ASM volatile ("dsb 0xF":::"memory");
   192f8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   192fc:	f3bf 8f6f 	isb	sy
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
   19300:	2300      	movs	r3, #0
   19302:	eee1 3a10 	vmsr	fpscr, r3
	relocate_vector_table();
	enable_floating_point();
	z_bss_zero();
   19306:	f00d f821 	bl	2634c <z_bss_zero>
	z_data_copy();
   1930a:	f00d f829 	bl	26360 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_int_lib_init();
   1930e:	f000 fb11 	bl	19934 <z_arm_int_lib_init>
	z_cstart();
   19312:	f00d f857 	bl	263c4 <z_cstart>
   19316:	bf00      	nop
   19318:	0000c000 	.word	0x0000c000
   1931c:	e000ed00 	.word	0xe000ed00

00019320 <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
   19320:	f013 ffe1 	bl	2d2e6 <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   19324:	2020      	movs	r0, #32
    msr BASEPRI, r0
   19326:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to _interrupt_stack during initialization.
     */
    ldr r0, =_interrupt_stack
   1932a:	4808      	ldr	r0, [pc, #32]	; (1934c <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
   1932c:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   19330:	1840      	adds	r0, r0, r1
    msr PSP, r0
   19332:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   19336:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   1933a:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   1933c:	4308      	orrs	r0, r1
    msr CONTROL, r0
   1933e:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   19342:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   19346:	f7ff ffc3 	bl	192d0 <z_arm_prep_c>
   1934a:	0000      	.short	0x0000
    ldr r0, =_interrupt_stack
   1934c:	20035d58 	.word	0x20035d58

00019350 <mem_manage_fault.isra.2>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   19350:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			      bool *recoverable)
{
	u32_t reason = K_ERR_CPU_EXCEPTION;
	u32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");
   19352:	2301      	movs	r3, #1
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   19354:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** MPU FAULT *****");
   19356:	f04f 0000 	mov.w	r0, #0
   1935a:	4c40      	ldr	r4, [pc, #256]	; (1945c <mem_manage_fault.isra.2+0x10c>)
   1935c:	f363 0007 	bfi	r0, r3, #0, #8
   19360:	4b3f      	ldr	r3, [pc, #252]	; (19460 <mem_manage_fault.isra.2+0x110>)
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   19362:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
   19364:	1ae4      	subs	r4, r4, r3
   19366:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1936a:	493e      	ldr	r1, [pc, #248]	; (19464 <mem_manage_fault.isra.2+0x114>)
   1936c:	f364 108f 	bfi	r0, r4, #6, #10
   19370:	f013 ffc2 	bl	2d2f8 <log_string_sync>

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   19374:	4b3c      	ldr	r3, [pc, #240]	; (19468 <mem_manage_fault.isra.2+0x118>)
   19376:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   19378:	06d9      	lsls	r1, r3, #27
   1937a:	d509      	bpl.n	19390 <mem_manage_fault.isra.2+0x40>
		PR_FAULT_INFO("  Stacking error (context area might be"
   1937c:	f04f 0000 	mov.w	r0, #0
   19380:	2301      	movs	r3, #1
   19382:	f363 0007 	bfi	r0, r3, #0, #8
   19386:	f364 108f 	bfi	r0, r4, #6, #10
   1938a:	4938      	ldr	r1, [pc, #224]	; (1946c <mem_manage_fault.isra.2+0x11c>)
   1938c:	f013 ffb4 	bl	2d2f8 <log_string_sync>
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   19390:	4b35      	ldr	r3, [pc, #212]	; (19468 <mem_manage_fault.isra.2+0x118>)
   19392:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   19394:	071a      	lsls	r2, r3, #28
   19396:	d509      	bpl.n	193ac <mem_manage_fault.isra.2+0x5c>
		PR_FAULT_INFO("  Unstacking error");
   19398:	f04f 0000 	mov.w	r0, #0
   1939c:	2301      	movs	r3, #1
   1939e:	f363 0007 	bfi	r0, r3, #0, #8
   193a2:	f364 108f 	bfi	r0, r4, #6, #10
   193a6:	4932      	ldr	r1, [pc, #200]	; (19470 <mem_manage_fault.isra.2+0x120>)
   193a8:	f013 ffa6 	bl	2d2f8 <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   193ac:	4d2e      	ldr	r5, [pc, #184]	; (19468 <mem_manage_fault.isra.2+0x118>)
   193ae:	6aab      	ldr	r3, [r5, #40]	; 0x28
   193b0:	079b      	lsls	r3, r3, #30
   193b2:	d51c      	bpl.n	193ee <mem_manage_fault.isra.2+0x9e>
		PR_FAULT_INFO("  Data Access Violation");
   193b4:	2301      	movs	r3, #1
   193b6:	f04f 0000 	mov.w	r0, #0
   193ba:	f363 0007 	bfi	r0, r3, #0, #8
   193be:	f364 108f 	bfi	r0, r4, #6, #10
   193c2:	492c      	ldr	r1, [pc, #176]	; (19474 <mem_manage_fault.isra.2+0x124>)
   193c4:	f013 ff98 	bl	2d2f8 <log_string_sync>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		mmfar = SCB->MMFAR;
   193c8:	6b6a      	ldr	r2, [r5, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   193ca:	6aab      	ldr	r3, [r5, #40]	; 0x28
   193cc:	0618      	lsls	r0, r3, #24
   193ce:	d50e      	bpl.n	193ee <mem_manage_fault.isra.2+0x9e>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
   193d0:	f04f 0000 	mov.w	r0, #0
   193d4:	2301      	movs	r3, #1
   193d6:	f363 0007 	bfi	r0, r3, #0, #8
   193da:	f364 108f 	bfi	r0, r4, #6, #10
   193de:	4926      	ldr	r1, [pc, #152]	; (19478 <mem_manage_fault.isra.2+0x128>)
   193e0:	f013 ff8a 	bl	2d2f8 <log_string_sync>
			if (from_hard_fault) {
   193e4:	b11f      	cbz	r7, 193ee <mem_manage_fault.isra.2+0x9e>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   193e6:	6aab      	ldr	r3, [r5, #40]	; 0x28
   193e8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   193ec:	62ab      	str	r3, [r5, #40]	; 0x28
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   193ee:	4b1e      	ldr	r3, [pc, #120]	; (19468 <mem_manage_fault.isra.2+0x118>)
   193f0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   193f2:	07d9      	lsls	r1, r3, #31
   193f4:	d509      	bpl.n	1940a <mem_manage_fault.isra.2+0xba>
		PR_FAULT_INFO("  Instruction Access Violation");
   193f6:	f04f 0000 	mov.w	r0, #0
   193fa:	2301      	movs	r3, #1
   193fc:	f363 0007 	bfi	r0, r3, #0, #8
   19400:	f364 108f 	bfi	r0, r4, #6, #10
   19404:	491d      	ldr	r1, [pc, #116]	; (1947c <mem_manage_fault.isra.2+0x12c>)
   19406:	f013 ff77 	bl	2d2f8 <log_string_sync>
	}
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   1940a:	4b17      	ldr	r3, [pc, #92]	; (19468 <mem_manage_fault.isra.2+0x118>)
   1940c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1940e:	069a      	lsls	r2, r3, #26
   19410:	d509      	bpl.n	19426 <mem_manage_fault.isra.2+0xd6>
		PR_FAULT_INFO(
   19412:	f04f 0000 	mov.w	r0, #0
   19416:	2301      	movs	r3, #1
   19418:	f363 0007 	bfi	r0, r3, #0, #8
   1941c:	f364 108f 	bfi	r0, r4, #6, #10
   19420:	4917      	ldr	r1, [pc, #92]	; (19480 <mem_manage_fault.isra.2+0x130>)
   19422:	f013 ff69 	bl	2d2f8 <log_string_sync>
	 * if the memory violation error is a stack corruption.
	 *
	 * By design, being a Stacking MemManage fault is a necessary
	 * and sufficient condition for a thread stack corruption.
	 */
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
   19426:	4b10      	ldr	r3, [pc, #64]	; (19468 <mem_manage_fault.isra.2+0x118>)
   19428:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1942a:	06db      	lsls	r3, r3, #27
   1942c:	d50e      	bpl.n	1944c <mem_manage_fault.isra.2+0xfc>
					"Stacking error not a stack fail\n");
			}
		}
#else
	(void)mmfar;
	__ASSERT(0,
   1942e:	4915      	ldr	r1, [pc, #84]	; (19484 <mem_manage_fault.isra.2+0x134>)
   19430:	f44f 739b 	mov.w	r3, #310	; 0x136
   19434:	4a14      	ldr	r2, [pc, #80]	; (19488 <mem_manage_fault.isra.2+0x138>)
   19436:	4815      	ldr	r0, [pc, #84]	; (1948c <mem_manage_fault.isra.2+0x13c>)
   19438:	f013 ff07 	bl	2d24a <printk>
   1943c:	4814      	ldr	r0, [pc, #80]	; (19490 <mem_manage_fault.isra.2+0x140>)
   1943e:	f013 ff04 	bl	2d24a <printk>
   19442:	f44f 719b 	mov.w	r1, #310	; 0x136
   19446:	4810      	ldr	r0, [pc, #64]	; (19488 <mem_manage_fault.isra.2+0x138>)
   19448:	f013 ff45 	bl	2d2d6 <assert_post_action>

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf);
   1944c:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   1944e:	4a06      	ldr	r2, [pc, #24]	; (19468 <mem_manage_fault.isra.2+0x118>)
   19450:	6a93      	ldr	r3, [r2, #40]	; 0x28
   19452:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
   19456:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
   19458:	7030      	strb	r0, [r6, #0]

	return reason;
}
   1945a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1945c:	000304dc 	.word	0x000304dc
   19460:	0003040c 	.word	0x0003040c
   19464:	00032c0a 	.word	0x00032c0a
   19468:	e000ed00 	.word	0xe000ed00
   1946c:	00032c20 	.word	0x00032c20
   19470:	00032c53 	.word	0x00032c53
   19474:	00032c66 	.word	0x00032c66
   19478:	00032c7e 	.word	0x00032c7e
   1947c:	00032c94 	.word	0x00032c94
   19480:	00032cb3 	.word	0x00032cb3
   19484:	0003495a 	.word	0x0003495a
   19488:	00032ce2 	.word	0x00032ce2
   1948c:	000311a3 	.word	0x000311a3
   19490:	00032d1c 	.word	0x00032d1c

00019494 <bus_fault.isra.3>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return N/A
 */
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   19494:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");
   19496:	2301      	movs	r3, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   19498:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** BUS FAULT *****");
   1949a:	f04f 0000 	mov.w	r0, #0
   1949e:	4c3d      	ldr	r4, [pc, #244]	; (19594 <bus_fault.isra.3+0x100>)
   194a0:	f363 0007 	bfi	r0, r3, #0, #8
   194a4:	4b3c      	ldr	r3, [pc, #240]	; (19598 <bus_fault.isra.3+0x104>)
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   194a6:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
   194a8:	1ae4      	subs	r4, r4, r3
   194aa:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   194ae:	493b      	ldr	r1, [pc, #236]	; (1959c <bus_fault.isra.3+0x108>)
   194b0:	f364 108f 	bfi	r0, r4, #6, #10
   194b4:	f013 ff20 	bl	2d2f8 <log_string_sync>

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   194b8:	4b39      	ldr	r3, [pc, #228]	; (195a0 <bus_fault.isra.3+0x10c>)
   194ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   194bc:	04d9      	lsls	r1, r3, #19
   194be:	d509      	bpl.n	194d4 <bus_fault.isra.3+0x40>
		PR_FAULT_INFO("  Stacking error");
   194c0:	f04f 0000 	mov.w	r0, #0
   194c4:	2301      	movs	r3, #1
   194c6:	f363 0007 	bfi	r0, r3, #0, #8
   194ca:	f364 108f 	bfi	r0, r4, #6, #10
   194ce:	4935      	ldr	r1, [pc, #212]	; (195a4 <bus_fault.isra.3+0x110>)
   194d0:	f013 ff12 	bl	2d2f8 <log_string_sync>
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   194d4:	4b32      	ldr	r3, [pc, #200]	; (195a0 <bus_fault.isra.3+0x10c>)
   194d6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   194d8:	051a      	lsls	r2, r3, #20
   194da:	d509      	bpl.n	194f0 <bus_fault.isra.3+0x5c>
		PR_FAULT_INFO("  Unstacking error");
   194dc:	f04f 0000 	mov.w	r0, #0
   194e0:	2301      	movs	r3, #1
   194e2:	f363 0007 	bfi	r0, r3, #0, #8
   194e6:	f364 108f 	bfi	r0, r4, #6, #10
   194ea:	492f      	ldr	r1, [pc, #188]	; (195a8 <bus_fault.isra.3+0x114>)
   194ec:	f013 ff04 	bl	2d2f8 <log_string_sync>
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   194f0:	4d2b      	ldr	r5, [pc, #172]	; (195a0 <bus_fault.isra.3+0x10c>)
   194f2:	6aab      	ldr	r3, [r5, #40]	; 0x28
   194f4:	059b      	lsls	r3, r3, #22
   194f6:	d51c      	bpl.n	19532 <bus_fault.isra.3+0x9e>
		PR_FAULT_INFO("  Precise data bus error");
   194f8:	2301      	movs	r3, #1
   194fa:	f04f 0000 	mov.w	r0, #0
   194fe:	f363 0007 	bfi	r0, r3, #0, #8
   19502:	f364 108f 	bfi	r0, r4, #6, #10
   19506:	4929      	ldr	r1, [pc, #164]	; (195ac <bus_fault.isra.3+0x118>)
   19508:	f013 fef6 	bl	2d2f8 <log_string_sync>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
   1950c:	6baa      	ldr	r2, [r5, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   1950e:	6aab      	ldr	r3, [r5, #40]	; 0x28
   19510:	0418      	lsls	r0, r3, #16
   19512:	d50e      	bpl.n	19532 <bus_fault.isra.3+0x9e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
   19514:	f04f 0000 	mov.w	r0, #0
   19518:	2301      	movs	r3, #1
   1951a:	f363 0007 	bfi	r0, r3, #0, #8
   1951e:	f364 108f 	bfi	r0, r4, #6, #10
   19522:	4923      	ldr	r1, [pc, #140]	; (195b0 <bus_fault.isra.3+0x11c>)
   19524:	f013 fee8 	bl	2d2f8 <log_string_sync>
			if (from_hard_fault) {
   19528:	b11f      	cbz	r7, 19532 <bus_fault.isra.3+0x9e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   1952a:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1952c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   19530:	62ab      	str	r3, [r5, #40]	; 0x28
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   19532:	4b1b      	ldr	r3, [pc, #108]	; (195a0 <bus_fault.isra.3+0x10c>)
   19534:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   19536:	0559      	lsls	r1, r3, #21
   19538:	d509      	bpl.n	1954e <bus_fault.isra.3+0xba>
		PR_FAULT_INFO("  Imprecise data bus error");
   1953a:	f04f 0000 	mov.w	r0, #0
   1953e:	2301      	movs	r3, #1
   19540:	f363 0007 	bfi	r0, r3, #0, #8
   19544:	f364 108f 	bfi	r0, r4, #6, #10
   19548:	491a      	ldr	r1, [pc, #104]	; (195b4 <bus_fault.isra.3+0x120>)
   1954a:	f013 fed5 	bl	2d2f8 <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   1954e:	4b14      	ldr	r3, [pc, #80]	; (195a0 <bus_fault.isra.3+0x10c>)
   19550:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   19552:	05d2      	lsls	r2, r2, #23
   19554:	d511      	bpl.n	1957a <bus_fault.isra.3+0xe6>
		PR_FAULT_INFO("  Instruction bus error");
   19556:	f04f 0000 	mov.w	r0, #0
   1955a:	2301      	movs	r3, #1
   1955c:	4916      	ldr	r1, [pc, #88]	; (195b8 <bus_fault.isra.3+0x124>)
   1955e:	f363 0007 	bfi	r0, r3, #0, #8
   19562:	f364 108f 	bfi	r0, r4, #6, #10
#if !defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	}
#else
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   19566:	f013 fec7 	bl	2d2f8 <log_string_sync>
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;

	*recoverable = memory_fault_recoverable(esf);
   1956a:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   1956c:	4a0c      	ldr	r2, [pc, #48]	; (195a0 <bus_fault.isra.3+0x10c>)
   1956e:	6a93      	ldr	r3, [r2, #40]	; 0x28
   19570:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
   19574:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
   19576:	7030      	strb	r0, [r6, #0]

	return reason;
}
   19578:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   1957a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1957c:	049b      	lsls	r3, r3, #18
   1957e:	d5f4      	bpl.n	1956a <bus_fault.isra.3+0xd6>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   19580:	f04f 0000 	mov.w	r0, #0
   19584:	2301      	movs	r3, #1
   19586:	f363 0007 	bfi	r0, r3, #0, #8
   1958a:	f364 108f 	bfi	r0, r4, #6, #10
   1958e:	490b      	ldr	r1, [pc, #44]	; (195bc <bus_fault.isra.3+0x128>)
   19590:	e7e9      	b.n	19566 <bus_fault.isra.3+0xd2>
   19592:	bf00      	nop
   19594:	000304dc 	.word	0x000304dc
   19598:	0003040c 	.word	0x0003040c
   1959c:	00032b82 	.word	0x00032b82
   195a0:	e000ed00 	.word	0xe000ed00
   195a4:	00032b98 	.word	0x00032b98
   195a8:	00032c53 	.word	0x00032c53
   195ac:	00032ba9 	.word	0x00032ba9
   195b0:	00032bc2 	.word	0x00032bc2
   195b4:	00032bd7 	.word	0x00032bd7
   195b8:	00032bf2 	.word	0x00032bf2
   195bc:	00032cb3 	.word	0x00032cb3

000195c0 <usage_fault.isra.4>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t usage_fault(const z_arch_esf_t *esf)
   195c0:	b538      	push	{r3, r4, r5, lr}
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
   195c2:	f04f 0000 	mov.w	r0, #0
   195c6:	2301      	movs	r3, #1
   195c8:	4c3c      	ldr	r4, [pc, #240]	; (196bc <usage_fault.isra.4+0xfc>)
   195ca:	f363 0007 	bfi	r0, r3, #0, #8
   195ce:	4b3c      	ldr	r3, [pc, #240]	; (196c0 <usage_fault.isra.4+0x100>)
   195d0:	493c      	ldr	r1, [pc, #240]	; (196c4 <usage_fault.isra.4+0x104>)
   195d2:	1ae4      	subs	r4, r4, r3
   195d4:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   195d8:	f364 108f 	bfi	r0, r4, #6, #10
   195dc:	f013 fe8c 	bl	2d2f8 <log_string_sync>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   195e0:	4b39      	ldr	r3, [pc, #228]	; (196c8 <usage_fault.isra.4+0x108>)
   195e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   195e4:	019b      	lsls	r3, r3, #6
   195e6:	d509      	bpl.n	195fc <usage_fault.isra.4+0x3c>
		PR_FAULT_INFO("  Division by zero");
   195e8:	f04f 0000 	mov.w	r0, #0
   195ec:	2301      	movs	r3, #1
   195ee:	f363 0007 	bfi	r0, r3, #0, #8
   195f2:	f364 108f 	bfi	r0, r4, #6, #10
   195f6:	4935      	ldr	r1, [pc, #212]	; (196cc <usage_fault.isra.4+0x10c>)
   195f8:	f013 fe7e 	bl	2d2f8 <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   195fc:	4b32      	ldr	r3, [pc, #200]	; (196c8 <usage_fault.isra.4+0x108>)
   195fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   19600:	01dd      	lsls	r5, r3, #7
   19602:	d509      	bpl.n	19618 <usage_fault.isra.4+0x58>
		PR_FAULT_INFO("  Unaligned memory access");
   19604:	f04f 0000 	mov.w	r0, #0
   19608:	2301      	movs	r3, #1
   1960a:	f363 0007 	bfi	r0, r3, #0, #8
   1960e:	f364 108f 	bfi	r0, r4, #6, #10
   19612:	492f      	ldr	r1, [pc, #188]	; (196d0 <usage_fault.isra.4+0x110>)
   19614:	f013 fe70 	bl	2d2f8 <log_string_sync>
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
   19618:	4b2b      	ldr	r3, [pc, #172]	; (196c8 <usage_fault.isra.4+0x108>)
   1961a:	6a9d      	ldr	r5, [r3, #40]	; 0x28
   1961c:	f415 1580 	ands.w	r5, r5, #1048576	; 0x100000
   19620:	d00a      	beq.n	19638 <usage_fault.isra.4+0x78>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
   19622:	2301      	movs	r3, #1
   19624:	f04f 0000 	mov.w	r0, #0
   19628:	f363 0007 	bfi	r0, r3, #0, #8
   1962c:	f364 108f 	bfi	r0, r4, #6, #10
   19630:	4928      	ldr	r1, [pc, #160]	; (196d4 <usage_fault.isra.4+0x114>)
   19632:	f013 fe61 	bl	2d2f8 <log_string_sync>
		 * prevents the context area to be loaded on the stack upon
		 * UsageFault exception entry. As a result, we cannot rely
		 * on the reported faulty instruction address, to determine
		 * the instruction that triggered the stack overflow.
		 */
		reason = K_ERR_STACK_CHK_FAIL;
   19636:	2502      	movs	r5, #2
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   19638:	4b23      	ldr	r3, [pc, #140]	; (196c8 <usage_fault.isra.4+0x108>)
   1963a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1963c:	0318      	lsls	r0, r3, #12
   1963e:	d509      	bpl.n	19654 <usage_fault.isra.4+0x94>
		PR_FAULT_INFO("  No coprocessor instructions");
   19640:	f04f 0000 	mov.w	r0, #0
   19644:	2301      	movs	r3, #1
   19646:	f363 0007 	bfi	r0, r3, #0, #8
   1964a:	f364 108f 	bfi	r0, r4, #6, #10
   1964e:	4922      	ldr	r1, [pc, #136]	; (196d8 <usage_fault.isra.4+0x118>)
   19650:	f013 fe52 	bl	2d2f8 <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   19654:	4b1c      	ldr	r3, [pc, #112]	; (196c8 <usage_fault.isra.4+0x108>)
   19656:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   19658:	0359      	lsls	r1, r3, #13
   1965a:	d509      	bpl.n	19670 <usage_fault.isra.4+0xb0>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
   1965c:	f04f 0000 	mov.w	r0, #0
   19660:	2301      	movs	r3, #1
   19662:	f363 0007 	bfi	r0, r3, #0, #8
   19666:	f364 108f 	bfi	r0, r4, #6, #10
   1966a:	491c      	ldr	r1, [pc, #112]	; (196dc <usage_fault.isra.4+0x11c>)
   1966c:	f013 fe44 	bl	2d2f8 <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   19670:	4b15      	ldr	r3, [pc, #84]	; (196c8 <usage_fault.isra.4+0x108>)
   19672:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   19674:	039a      	lsls	r2, r3, #14
   19676:	d509      	bpl.n	1968c <usage_fault.isra.4+0xcc>
		PR_FAULT_INFO("  Illegal use of the EPSR");
   19678:	f04f 0000 	mov.w	r0, #0
   1967c:	2301      	movs	r3, #1
   1967e:	f363 0007 	bfi	r0, r3, #0, #8
   19682:	f364 108f 	bfi	r0, r4, #6, #10
   19686:	4916      	ldr	r1, [pc, #88]	; (196e0 <usage_fault.isra.4+0x120>)
   19688:	f013 fe36 	bl	2d2f8 <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   1968c:	4b0e      	ldr	r3, [pc, #56]	; (196c8 <usage_fault.isra.4+0x108>)
   1968e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   19690:	03db      	lsls	r3, r3, #15
   19692:	d509      	bpl.n	196a8 <usage_fault.isra.4+0xe8>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
   19694:	f04f 0000 	mov.w	r0, #0
   19698:	2301      	movs	r3, #1
   1969a:	f363 0007 	bfi	r0, r3, #0, #8
   1969e:	f364 108f 	bfi	r0, r4, #6, #10
   196a2:	4910      	ldr	r1, [pc, #64]	; (196e4 <usage_fault.isra.4+0x124>)
   196a4:	f013 fe28 	bl	2d2f8 <log_string_sync>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   196a8:	4a07      	ldr	r2, [pc, #28]	; (196c8 <usage_fault.isra.4+0x108>)

	return reason;
}
   196aa:	4628      	mov	r0, r5
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   196ac:	6a93      	ldr	r3, [r2, #40]	; 0x28
   196ae:	ea6f 4303 	mvn.w	r3, r3, lsl #16
   196b2:	ea6f 4313 	mvn.w	r3, r3, lsr #16
   196b6:	6293      	str	r3, [r2, #40]	; 0x28
}
   196b8:	bd38      	pop	{r3, r4, r5, pc}
   196ba:	bf00      	nop
   196bc:	000304dc 	.word	0x000304dc
   196c0:	0003040c 	.word	0x0003040c
   196c4:	00032d56 	.word	0x00032d56
   196c8:	e000ed00 	.word	0xe000ed00
   196cc:	00032d6e 	.word	0x00032d6e
   196d0:	00032d81 	.word	0x00032d81
   196d4:	00032d9b 	.word	0x00032d9b
   196d8:	00032dc5 	.word	0x00032dc5
   196dc:	00032de3 	.word	0x00032de3
   196e0:	00032e08 	.word	0x00032e08
   196e4:	00032e22 	.word	0x00032e22

000196e8 <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
   196e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   196ec:	4b70      	ldr	r3, [pc, #448]	; (198b0 <z_arm_fault+0x1c8>)
{
   196ee:	b09d      	sub	sp, #116	; 0x74
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   196f0:	f8d3 8004 	ldr.w	r8, [r3, #4]
{
   196f4:	4606      	mov	r6, r0
   196f6:	4689      	mov	r9, r1
   196f8:	4614      	mov	r4, r2
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   196fa:	f3c8 0708 	ubfx	r7, r8, #0, #9
   196fe:	2500      	movs	r5, #0
   19700:	f385 8811 	msr	BASEPRI, r5
   19704:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   19708:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
   1970c:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   19710:	d11b      	bne.n	1974a <z_arm_fault+0x62>
	if (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {
   19712:	07d0      	lsls	r0, r2, #31
   19714:	d419      	bmi.n	1974a <z_arm_fault+0x62>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
   19716:	0651      	lsls	r1, r2, #25
   19718:	d403      	bmi.n	19722 <z_arm_fault+0x3a>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   1971a:	0722      	lsls	r2, r4, #28
   1971c:	d412      	bmi.n	19744 <z_arm_fault+0x5c>
			*nested_exc = true;
   1971e:	2501      	movs	r5, #1
   19720:	e012      	b.n	19748 <z_arm_fault+0x60>
		PR_FAULT_INFO("Exception occurred in Secure State");
   19722:	2301      	movs	r3, #1
   19724:	f04f 0000 	mov.w	r0, #0
   19728:	4a62      	ldr	r2, [pc, #392]	; (198b4 <z_arm_fault+0x1cc>)
   1972a:	f363 0007 	bfi	r0, r3, #0, #8
   1972e:	4b62      	ldr	r3, [pc, #392]	; (198b8 <z_arm_fault+0x1d0>)
   19730:	4962      	ldr	r1, [pc, #392]	; (198bc <z_arm_fault+0x1d4>)
   19732:	1a9b      	subs	r3, r3, r2
   19734:	08db      	lsrs	r3, r3, #3
   19736:	f363 108f 	bfi	r0, r3, #6, #10
   1973a:	f013 fddd 	bl	2d2f8 <log_string_sync>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
   1973e:	f014 0504 	ands.w	r5, r4, #4
   19742:	d001      	beq.n	19748 <z_arm_fault+0x60>
			ptr_esf = (z_arch_esf_t *)psp;
   19744:	464e      	mov	r6, r9
	*nested_exc = false;
   19746:	2500      	movs	r5, #0

	/* Retrieve the Exception Stack Frame (ESF) to be supplied
	 * as argument to the remainder of the fault handling process.
	 */
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
   19748:	b97e      	cbnz	r6, 1976a <z_arm_fault+0x82>
   1974a:	f240 33b1 	movw	r3, #945	; 0x3b1
   1974e:	4a5c      	ldr	r2, [pc, #368]	; (198c0 <z_arm_fault+0x1d8>)
   19750:	495c      	ldr	r1, [pc, #368]	; (198c4 <z_arm_fault+0x1dc>)
   19752:	485d      	ldr	r0, [pc, #372]	; (198c8 <z_arm_fault+0x1e0>)
   19754:	f013 fd79 	bl	2d24a <printk>
   19758:	485c      	ldr	r0, [pc, #368]	; (198cc <z_arm_fault+0x1e4>)
   1975a:	f013 fd76 	bl	2d24a <printk>
   1975e:	f240 31b1 	movw	r1, #945	; 0x3b1
   19762:	4857      	ldr	r0, [pc, #348]	; (198c0 <z_arm_fault+0x1d8>)
   19764:	f013 fdb7 	bl	2d2d6 <assert_post_action>
   19768:	2600      	movs	r6, #0
	*recoverable = false;
   1976a:	2300      	movs	r3, #0
   1976c:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
   19770:	1efb      	subs	r3, r7, #3
   19772:	2b09      	cmp	r3, #9
   19774:	d87f      	bhi.n	19876 <z_arm_fault+0x18e>
   19776:	e8df f003 	tbb	[pc, r3]
   1977a:	6905      	.short	0x6905
   1977c:	7e7e4c6d 	.word	0x7e7e4c6d
   19780:	717e7e7e 	.word	0x717e7e7e
	PR_FAULT_INFO("***** HARD FAULT *****");
   19784:	2301      	movs	r3, #1
   19786:	f04f 0000 	mov.w	r0, #0
	*recoverable = false;
   1978a:	f04f 0800 	mov.w	r8, #0
	PR_FAULT_INFO("***** HARD FAULT *****");
   1978e:	f363 0007 	bfi	r0, r3, #0, #8
   19792:	4f49      	ldr	r7, [pc, #292]	; (198b8 <z_arm_fault+0x1d0>)
   19794:	4b47      	ldr	r3, [pc, #284]	; (198b4 <z_arm_fault+0x1cc>)
   19796:	494e      	ldr	r1, [pc, #312]	; (198d0 <z_arm_fault+0x1e8>)
   19798:	1aff      	subs	r7, r7, r3
   1979a:	f3c7 07c9 	ubfx	r7, r7, #3, #10
   1979e:	f367 108f 	bfi	r0, r7, #6, #10
   197a2:	f013 fda9 	bl	2d2f8 <log_string_sync>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   197a6:	4b42      	ldr	r3, [pc, #264]	; (198b0 <z_arm_fault+0x1c8>)
	*recoverable = false;
   197a8:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   197ac:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   197ae:	f014 0402 	ands.w	r4, r4, #2
   197b2:	d00b      	beq.n	197cc <z_arm_fault+0xe4>
		PR_EXC("  Bus fault on vector table read");
   197b4:	f04f 0000 	mov.w	r0, #0
   197b8:	2301      	movs	r3, #1
   197ba:	4946      	ldr	r1, [pc, #280]	; (198d4 <z_arm_fault+0x1ec>)
   197bc:	f363 0007 	bfi	r0, r3, #0, #8
   197c0:	f367 108f 	bfi	r0, r7, #6, #10
	PR_FAULT_INFO(
   197c4:	f013 fd98 	bl	2d2f8 <log_string_sync>
	u32_t reason = K_ERR_CPU_EXCEPTION;
   197c8:	2400      	movs	r4, #0
   197ca:	e025      	b.n	19818 <z_arm_fault+0x130>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   197cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   197ce:	005b      	lsls	r3, r3, #1
   197d0:	d522      	bpl.n	19818 <z_arm_fault+0x130>
		PR_EXC("  Fault escalation (see below)");
   197d2:	2301      	movs	r3, #1
   197d4:	f04f 0000 	mov.w	r0, #0
   197d8:	f363 0007 	bfi	r0, r3, #0, #8
   197dc:	f367 108f 	bfi	r0, r7, #6, #10
   197e0:	493d      	ldr	r1, [pc, #244]	; (198d8 <z_arm_fault+0x1f0>)
   197e2:	f013 fd89 	bl	2d2f8 <log_string_sync>
		if (SCB_MMFSR != 0) {
   197e6:	4b3d      	ldr	r3, [pc, #244]	; (198dc <z_arm_fault+0x1f4>)
   197e8:	781b      	ldrb	r3, [r3, #0]
   197ea:	b12b      	cbz	r3, 197f8 <z_arm_fault+0x110>
			reason = mem_manage_fault(esf, 1, recoverable);
   197ec:	2001      	movs	r0, #1
   197ee:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
   197f2:	f7ff fdad 	bl	19350 <mem_manage_fault.isra.2>
   197f6:	e00e      	b.n	19816 <z_arm_fault+0x12e>
		} else if (SCB_BFSR != 0) {
   197f8:	4b39      	ldr	r3, [pc, #228]	; (198e0 <z_arm_fault+0x1f8>)
   197fa:	781b      	ldrb	r3, [r3, #0]
   197fc:	b12b      	cbz	r3, 1980a <z_arm_fault+0x122>
			reason = bus_fault(esf, 1, recoverable);
   197fe:	2001      	movs	r0, #1
   19800:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
   19804:	f7ff fe46 	bl	19494 <bus_fault.isra.3>
   19808:	e005      	b.n	19816 <z_arm_fault+0x12e>
		} else if (SCB_UFSR != 0) {
   1980a:	4b36      	ldr	r3, [pc, #216]	; (198e4 <z_arm_fault+0x1fc>)
   1980c:	881b      	ldrh	r3, [r3, #0]
   1980e:	b29b      	uxth	r3, r3
   19810:	b113      	cbz	r3, 19818 <z_arm_fault+0x130>
			reason = usage_fault(esf);
   19812:	f7ff fed5 	bl	195c0 <usage_fault.isra.4>
   19816:	4604      	mov	r4, r0
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
   19818:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1981c:	b99b      	cbnz	r3, 19846 <z_arm_fault+0x15e>
		return;
	}

	/* Copy ESF */
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   1981e:	2268      	movs	r2, #104	; 0x68
   19820:	4631      	mov	r1, r6
   19822:	a802      	add	r0, sp, #8
   19824:	f015 fd96 	bl	2f354 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
   19828:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1982a:	2d00      	cmp	r5, #0
   1982c:	d03a      	beq.n	198a4 <z_arm_fault+0x1bc>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   1982e:	f3c3 0208 	ubfx	r2, r3, #0, #9
   19832:	b922      	cbnz	r2, 1983e <z_arm_fault+0x156>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   19834:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   19838:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   1983c:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
   1983e:	a902      	add	r1, sp, #8
   19840:	4620      	mov	r0, r4
   19842:	f7ff fcb1 	bl	191a8 <z_arm_fatal_error>
}
   19846:	b01d      	add	sp, #116	; 0x74
   19848:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
   1984c:	f10d 0107 	add.w	r1, sp, #7
   19850:	2000      	movs	r0, #0
   19852:	e7ce      	b.n	197f2 <z_arm_fault+0x10a>
		reason = bus_fault(esf, 0, recoverable);
   19854:	f10d 0107 	add.w	r1, sp, #7
   19858:	2000      	movs	r0, #0
   1985a:	e7d3      	b.n	19804 <z_arm_fault+0x11c>
	PR_FAULT_INFO(
   1985c:	2301      	movs	r3, #1
   1985e:	f04f 0000 	mov.w	r0, #0
   19862:	4a14      	ldr	r2, [pc, #80]	; (198b4 <z_arm_fault+0x1cc>)
   19864:	f363 0007 	bfi	r0, r3, #0, #8
   19868:	4b13      	ldr	r3, [pc, #76]	; (198b8 <z_arm_fault+0x1d0>)
   1986a:	491f      	ldr	r1, [pc, #124]	; (198e8 <z_arm_fault+0x200>)
   1986c:	1a9b      	subs	r3, r3, r2
   1986e:	08db      	lsrs	r3, r3, #3
   19870:	f363 108f 	bfi	r0, r3, #6, #10
   19874:	e7a6      	b.n	197c4 <z_arm_fault+0xdc>
	PR_FAULT_INFO("***** %s %d) *****",
   19876:	2301      	movs	r3, #1
   19878:	f04f 0000 	mov.w	r0, #0
   1987c:	4a0d      	ldr	r2, [pc, #52]	; (198b4 <z_arm_fault+0x1cc>)
   1987e:	f363 0007 	bfi	r0, r3, #0, #8
   19882:	4b0d      	ldr	r3, [pc, #52]	; (198b8 <z_arm_fault+0x1d0>)
   19884:	4919      	ldr	r1, [pc, #100]	; (198ec <z_arm_fault+0x204>)
   19886:	1a9b      	subs	r3, r3, r2
   19888:	08db      	lsrs	r3, r3, #3
   1988a:	f418 7ff8 	tst.w	r8, #496	; 0x1f0
   1988e:	f363 108f 	bfi	r0, r3, #6, #10
   19892:	4a17      	ldr	r2, [pc, #92]	; (198f0 <z_arm_fault+0x208>)
   19894:	f1a7 0310 	sub.w	r3, r7, #16
   19898:	bf08      	it	eq
   1989a:	460a      	moveq	r2, r1
   1989c:	4915      	ldr	r1, [pc, #84]	; (198f4 <z_arm_fault+0x20c>)
   1989e:	f013 fd2b 	bl	2d2f8 <log_string_sync>
   198a2:	e791      	b.n	197c8 <z_arm_fault+0xe0>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   198a4:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   198a8:	f023 0301 	bic.w	r3, r3, #1
   198ac:	e7c6      	b.n	1983c <z_arm_fault+0x154>
   198ae:	bf00      	nop
   198b0:	e000ed00 	.word	0xe000ed00
   198b4:	0003040c 	.word	0x0003040c
   198b8:	000304dc 	.word	0x000304dc
   198bc:	00032e7b 	.word	0x00032e7b
   198c0:	00032ce2 	.word	0x00032ce2
   198c4:	00032e9e 	.word	0x00032e9e
   198c8:	000311a3 	.word	0x000311a3
   198cc:	00032eb1 	.word	0x00032eb1
   198d0:	00032eef 	.word	0x00032eef
   198d4:	00032f06 	.word	0x00032f06
   198d8:	00032f27 	.word	0x00032f27
   198dc:	e000ed28 	.word	0xe000ed28
   198e0:	e000ed29 	.word	0xe000ed29
   198e4:	e000ed2a 	.word	0xe000ed2a
   198e8:	00032f46 	.word	0x00032f46
   198ec:	00032e4d 	.word	0x00032e4d
   198f0:	00032e62 	.word	0x00032e62
   198f4:	00032f7c 	.word	0x00032f7c

000198f8 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   198f8:	4b04      	ldr	r3, [pc, #16]	; (1990c <z_arm_fault_init+0x14>)
   198fa:	695a      	ldr	r2, [r3, #20]
   198fc:	f042 0210 	orr.w	r2, r2, #16
   19900:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
   19902:	695a      	ldr	r2, [r3, #20]
   19904:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   19908:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
   1990a:	4770      	bx	lr
   1990c:	e000ed00 	.word	0xe000ed00

00019910 <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
   19910:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   19914:	4905      	ldr	r1, [pc, #20]	; (1992c <sys_arch_reboot+0x1c>)
   19916:	4b06      	ldr	r3, [pc, #24]	; (19930 <sys_arch_reboot+0x20>)
   19918:	68ca      	ldr	r2, [r1, #12]
   1991a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   1991e:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   19920:	60cb      	str	r3, [r1, #12]
   19922:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   19926:	bf00      	nop
   19928:	e7fd      	b.n	19926 <sys_arch_reboot+0x16>
   1992a:	bf00      	nop
   1992c:	e000ed00 	.word	0xe000ed00
   19930:	05fa0004 	.word	0x05fa0004

00019934 <z_arm_int_lib_init>:
 * @return N/A
 */

void z_arm_int_lib_init(void)
{
	int irq = 0;
   19934:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   19936:	2120      	movs	r1, #32
   19938:	4803      	ldr	r0, [pc, #12]	; (19948 <z_arm_int_lib_init+0x14>)
   1993a:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   1993c:	3301      	adds	r3, #1
   1993e:	2b41      	cmp	r3, #65	; 0x41
   19940:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   19944:	d1f9      	bne.n	1993a <z_arm_int_lib_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   19946:	4770      	bx	lr
   19948:	e000e100 	.word	0xe000e100

0001994c <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
   1994c:	b538      	push	{r3, r4, r5, lr}
   1994e:	4604      	mov	r4, r0
	__asm__ volatile(
   19950:	f04f 0320 	mov.w	r3, #32
   19954:	f3ef 8511 	mrs	r5, BASEPRI
   19958:	f383 8811 	msr	BASEPRI, r3
   1995c:	f3bf 8f6f 	isb	sy
	unsigned int key;

	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
   19960:	7b03      	ldrb	r3, [r0, #12]
   19962:	07db      	lsls	r3, r3, #31
   19964:	d50c      	bpl.n	19980 <z_impl_k_thread_abort+0x34>
   19966:	4912      	ldr	r1, [pc, #72]	; (199b0 <z_impl_k_thread_abort+0x64>)
   19968:	2324      	movs	r3, #36	; 0x24
   1996a:	4a12      	ldr	r2, [pc, #72]	; (199b4 <z_impl_k_thread_abort+0x68>)
   1996c:	4812      	ldr	r0, [pc, #72]	; (199b8 <z_impl_k_thread_abort+0x6c>)
   1996e:	f013 fc6c 	bl	2d24a <printk>
   19972:	4812      	ldr	r0, [pc, #72]	; (199bc <z_impl_k_thread_abort+0x70>)
   19974:	f013 fc69 	bl	2d24a <printk>
   19978:	2124      	movs	r1, #36	; 0x24
   1997a:	480e      	ldr	r0, [pc, #56]	; (199b4 <z_impl_k_thread_abort+0x68>)
   1997c:	f013 fcab 	bl	2d2d6 <assert_post_action>
		 "essential thread aborted");

	z_thread_single_abort(thread);
   19980:	4620      	mov	r0, r4
   19982:	f00e f935 	bl	27bf0 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
   19986:	4b0e      	ldr	r3, [pc, #56]	; (199c0 <z_impl_k_thread_abort+0x74>)
   19988:	689b      	ldr	r3, [r3, #8]
   1998a:	42a3      	cmp	r3, r4
   1998c:	d10b      	bne.n	199a6 <z_impl_k_thread_abort+0x5a>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
   1998e:	4b0d      	ldr	r3, [pc, #52]	; (199c4 <z_impl_k_thread_abort+0x78>)
   19990:	685a      	ldr	r2, [r3, #4]
   19992:	f3c2 0208 	ubfx	r2, r2, #0, #9
   19996:	b912      	cbnz	r2, 1999e <z_impl_k_thread_abort+0x52>
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
   19998:	4628      	mov	r0, r5
   1999a:	f7ff fb1d 	bl	18fd8 <arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   1999e:	685a      	ldr	r2, [r3, #4]
   199a0:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   199a4:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
   199a6:	4628      	mov	r0, r5
}
   199a8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
   199ac:	f015 bb50 	b.w	2f050 <z_reschedule_irqlock>
   199b0:	00032fd0 	.word	0x00032fd0
   199b4:	00032f8f 	.word	0x00032f8f
   199b8:	000311a3 	.word	0x000311a3
   199bc:	00032ffe 	.word	0x00032ffe
   199c0:	2002d2e8 	.word	0x2002d2e8
   199c4:	e000ed00 	.word	0xe000ed00

000199c8 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
   199c8:	b510      	push	{r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
   199ca:	4b0e      	ldr	r3, [pc, #56]	; (19a04 <z_arm_configure_static_mpu_regions+0x3c>)
{
   199cc:	b088      	sub	sp, #32
		const struct k_mem_partition ramfunc_region =
   199ce:	9302      	str	r3, [sp, #8]
   199d0:	4b0d      	ldr	r3, [pc, #52]	; (19a08 <z_arm_configure_static_mpu_regions+0x40>)
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   199d2:	4c0e      	ldr	r4, [pc, #56]	; (19a0c <z_arm_configure_static_mpu_regions+0x44>)
		const struct k_mem_partition ramfunc_region =
   199d4:	9303      	str	r3, [sp, #12]
   199d6:	4b0e      	ldr	r3, [pc, #56]	; (19a10 <z_arm_configure_static_mpu_regions+0x48>)
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   199d8:	4a0e      	ldr	r2, [pc, #56]	; (19a14 <z_arm_configure_static_mpu_regions+0x4c>)
		const struct k_mem_partition ramfunc_region =
   199da:	9304      	str	r3, [sp, #16]
	const struct k_mem_partition *static_regions[] = {
   199dc:	ab02      	add	r3, sp, #8
   199de:	9301      	str	r3, [sp, #4]
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   199e0:	a801      	add	r0, sp, #4
   199e2:	4623      	mov	r3, r4
   199e4:	2101      	movs	r1, #1
   199e6:	f000 f97d 	bl	19ce4 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of k_mem_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct k_mem_partition dyn_region_areas[] = {
   199ea:	2300      	movs	r3, #0
   199ec:	9307      	str	r3, [sp, #28]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
   199ee:	4b0a      	ldr	r3, [pc, #40]	; (19a18 <z_arm_configure_static_mpu_regions+0x50>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   199f0:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
   199f2:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   199f4:	a805      	add	r0, sp, #20
	const struct k_mem_partition dyn_region_areas[] = {
   199f6:	9305      	str	r3, [sp, #20]
   199f8:	9406      	str	r4, [sp, #24]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   199fa:	f000 f997 	bl	19d2c <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
   199fe:	b008      	add	sp, #32
   19a00:	bd10      	pop	{r4, pc}
   19a02:	bf00      	nop
   19a04:	20020000 	.word	0x20020000
   19a08:	00000000 	.word	0x00000000
   19a0c:	20040000 	.word	0x20040000
   19a10:	00010006 	.word	0x00010006
   19a14:	20020000 	.word	0x20020000
   19a18:	20020000 	.word	0x20020000

00019a1c <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
   19a1c:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
   19a1e:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
   19a20:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
   19a22:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
   19a26:	f004 031f 	and.w	r3, r4, #31
   19a2a:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   19a2c:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   19a2e:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   19a30:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
   19a34:	4904      	ldr	r1, [pc, #16]	; (19a48 <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   19a36:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
   19a3a:	f043 0301 	orr.w	r3, r3, #1
   19a3e:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
   19a40:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
   19a42:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
   19a44:	bd10      	pop	{r4, pc}
   19a46:	bf00      	nop
   19a48:	e000ed90 	.word	0xe000ed90

00019a4c <region_allocate_and_init>:

static int region_allocate_and_init(const u8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1)) {
   19a4c:	280f      	cmp	r0, #15
{
   19a4e:	b510      	push	{r4, lr}
   19a50:	4604      	mov	r4, r0
	if (index > (get_num_regions() - 1)) {
   19a52:	d912      	bls.n	19a7a <region_allocate_and_init+0x2e>

		/* No available MPU region index. */
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
   19a54:	2301      	movs	r3, #1
   19a56:	f04f 0000 	mov.w	r0, #0
   19a5a:	4a09      	ldr	r2, [pc, #36]	; (19a80 <region_allocate_and_init+0x34>)
   19a5c:	f363 0007 	bfi	r0, r3, #0, #8
   19a60:	4b08      	ldr	r3, [pc, #32]	; (19a84 <region_allocate_and_init+0x38>)
   19a62:	4909      	ldr	r1, [pc, #36]	; (19a88 <region_allocate_and_init+0x3c>)
   19a64:	1a9b      	subs	r3, r3, r2
   19a66:	08db      	lsrs	r3, r3, #3
   19a68:	4622      	mov	r2, r4
   19a6a:	f363 108f 	bfi	r0, r3, #6, #10
   19a6e:	f013 fc43 	bl	2d2f8 <log_string_sync>
		return -EINVAL;
   19a72:	f06f 0415 	mvn.w	r4, #21

	/* Program region */
	region_init(index, region_conf);

	return index;
}
   19a76:	4620      	mov	r0, r4
   19a78:	bd10      	pop	{r4, pc}
	region_init(index, region_conf);
   19a7a:	f7ff ffcf 	bl	19a1c <region_init>
	return index;
   19a7e:	e7fa      	b.n	19a76 <region_allocate_and_init+0x2a>
   19a80:	0003040c 	.word	0x0003040c
   19a84:	000304c4 	.word	0x000304c4
   19a88:	000331d1 	.word	0x000331d1

00019a8c <mpu_configure_regions_and_partition.constprop.2>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct k_mem_partition
   19a8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19a90:	4607      	mov	r7, r0
   19a92:	4688      	mov	r8, r1
   19a94:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
   19a96:	2600      	movs	r6, #0
	MPU->RNR = index;
   19a98:	4d58      	ldr	r5, [pc, #352]	; (19bfc <mpu_configure_regions_and_partition.constprop.2+0x170>)
static int mpu_configure_regions_and_partition(const struct k_mem_partition
   19a9a:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
   19a9c:	4546      	cmp	r6, r8
   19a9e:	da3d      	bge.n	19b1c <mpu_configure_regions_and_partition.constprop.2+0x90>
		if (regions[i]->size == 0U) {
   19aa0:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
   19aa4:	f8d3 9004 	ldr.w	r9, [r3, #4]
   19aa8:	f1b9 0f00 	cmp.w	r9, #0
   19aac:	d059      	beq.n	19b62 <mpu_configure_regions_and_partition.constprop.2+0xd6>
		&&
   19aae:	f1b9 0f1f 	cmp.w	r9, #31
   19ab2:	d922      	bls.n	19afa <mpu_configure_regions_and_partition.constprop.2+0x6e>
		&&
   19ab4:	f019 0f1f 	tst.w	r9, #31
   19ab8:	d11f      	bne.n	19afa <mpu_configure_regions_and_partition.constprop.2+0x6e>
		((part->start &
   19aba:	f8d3 a000 	ldr.w	sl, [r3]
		&&
   19abe:	f01a 0f1f 	tst.w	sl, #31
   19ac2:	d11a      	bne.n	19afa <mpu_configure_regions_and_partition.constprop.2+0x6e>
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
   19ac4:	4650      	mov	r0, sl
   19ac6:	f013 fd95 	bl	2d5f4 <arm_cmse_mpu_region_get>
   19aca:	4683      	mov	fp, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   19acc:	eb09 000a 	add.w	r0, r9, sl
   19ad0:	3801      	subs	r0, #1
   19ad2:	f013 fd8f 	bl	2d5f4 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   19ad6:	4583      	cmp	fp, r0
   19ad8:	d024      	beq.n	19b24 <mpu_configure_regions_and_partition.constprop.2+0x98>
	return -EINVAL;
   19ada:	f06f 0b15 	mvn.w	fp, #21
		int u_reg_index =
			get_region_index(regions[i]->start, regions[i]->size);

		if ((u_reg_index == -EINVAL) ||
			(u_reg_index > (reg_index - 1))) {
			LOG_ERR("Invalid underlying region index %u",
   19ade:	2301      	movs	r3, #1
   19ae0:	f04f 0000 	mov.w	r0, #0
   19ae4:	4a46      	ldr	r2, [pc, #280]	; (19c00 <mpu_configure_regions_and_partition.constprop.2+0x174>)
   19ae6:	f363 0007 	bfi	r0, r3, #0, #8
   19aea:	4b46      	ldr	r3, [pc, #280]	; (19c04 <mpu_configure_regions_and_partition.constprop.2+0x178>)
   19aec:	4946      	ldr	r1, [pc, #280]	; (19c08 <mpu_configure_regions_and_partition.constprop.2+0x17c>)
   19aee:	1a9b      	subs	r3, r3, r2
   19af0:	08db      	lsrs	r3, r3, #3
   19af2:	f363 108f 	bfi	r0, r3, #6, #10
   19af6:	465a      	mov	r2, fp
   19af8:	e00c      	b.n	19b14 <mpu_configure_regions_and_partition.constprop.2+0x88>
			LOG_ERR("Partition %u: sanity check failed.", i);
   19afa:	2301      	movs	r3, #1
   19afc:	f04f 0000 	mov.w	r0, #0
   19b00:	4a3f      	ldr	r2, [pc, #252]	; (19c00 <mpu_configure_regions_and_partition.constprop.2+0x174>)
   19b02:	f363 0007 	bfi	r0, r3, #0, #8
   19b06:	4b3f      	ldr	r3, [pc, #252]	; (19c04 <mpu_configure_regions_and_partition.constprop.2+0x178>)
   19b08:	4940      	ldr	r1, [pc, #256]	; (19c0c <mpu_configure_regions_and_partition.constprop.2+0x180>)
   19b0a:	1a9b      	subs	r3, r3, r2
   19b0c:	4632      	mov	r2, r6
   19b0e:	08db      	lsrs	r3, r3, #3
   19b10:	f363 108f 	bfi	r0, r3, #6, #10
			LOG_ERR("Invalid underlying region index %u",
   19b14:	f013 fbf0 	bl	2d2f8 <log_string_sync>

			reg_index =
				mpu_configure_region(reg_index, regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
   19b18:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
   19b1c:	4620      	mov	r0, r4
   19b1e:	b005      	add	sp, #20
   19b20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((u_reg_index == -EINVAL) ||
   19b24:	f11b 0f16 	cmn.w	fp, #22
   19b28:	d0d9      	beq.n	19ade <mpu_configure_regions_and_partition.constprop.2+0x52>
			(u_reg_index > (reg_index - 1))) {
   19b2a:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
   19b2c:	455b      	cmp	r3, fp
   19b2e:	dbd6      	blt.n	19ade <mpu_configure_regions_and_partition.constprop.2+0x52>
	MPU->RNR = index;
   19b30:	f8c5 b008 	str.w	fp, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   19b34:	68e8      	ldr	r0, [r5, #12]
	MPU->RNR = index;
   19b36:	f8c5 b008 	str.w	fp, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   19b3a:	692b      	ldr	r3, [r5, #16]
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
   19b3c:	f857 1026 	ldr.w	r1, [r7, r6, lsl #2]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   19b40:	f020 001f 	bic.w	r0, r0, #31
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   19b44:	f043 0a1f 	orr.w	sl, r3, #31
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
   19b48:	e9d1 3200 	ldrd	r3, r2, [r1]
   19b4c:	441a      	add	r2, r3
		if ((regions[i]->start == u_reg_base) &&
   19b4e:	4298      	cmp	r0, r3
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
   19b50:	f102 39ff 	add.w	r9, r2, #4294967295
		if ((regions[i]->start == u_reg_base) &&
   19b54:	d118      	bne.n	19b88 <mpu_configure_regions_and_partition.constprop.2+0xfc>
   19b56:	45ca      	cmp	sl, r9
   19b58:	d105      	bne.n	19b66 <mpu_configure_regions_and_partition.constprop.2+0xda>
			mpu_configure_region(u_reg_index, regions[i]);
   19b5a:	fa5f f08b 	uxtb.w	r0, fp
   19b5e:	f013 fd2e 	bl	2d5be <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
   19b62:	3601      	adds	r6, #1
   19b64:	e79a      	b.n	19a9c <mpu_configure_regions_and_partition.constprop.2+0x10>
	MPU->RNR = index;
   19b66:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   19b6a:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
   19b6c:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   19b70:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
   19b74:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   19b76:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, regions[i]);
   19b78:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, regions[i]);
   19b7a:	f013 fd20 	bl	2d5be <mpu_configure_region>
			if (reg_index == -EINVAL) {
   19b7e:	f110 0f16 	cmn.w	r0, #22
   19b82:	d0c9      	beq.n	19b18 <mpu_configure_regions_and_partition.constprop.2+0x8c>
			reg_index++;
   19b84:	1c44      	adds	r4, r0, #1
   19b86:	e7ec      	b.n	19b62 <mpu_configure_regions_and_partition.constprop.2+0xd6>
	MPU->RNR = index;
   19b88:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   19b8c:	692a      	ldr	r2, [r5, #16]
   19b8e:	3b01      	subs	r3, #1
   19b90:	f023 031f 	bic.w	r3, r3, #31
   19b94:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   19b98:	4313      	orrs	r3, r2
		} else if (reg_last == u_reg_last) {
   19b9a:	45ca      	cmp	sl, r9
   19b9c:	b2e0      	uxtb	r0, r4
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   19b9e:	612b      	str	r3, [r5, #16]
		} else if (reg_last == u_reg_last) {
   19ba0:	d0eb      	beq.n	19b7a <mpu_configure_regions_and_partition.constprop.2+0xee>
				mpu_configure_region(reg_index, regions[i]);
   19ba2:	f013 fd0c 	bl	2d5be <mpu_configure_region>
			if (reg_index == -EINVAL) {
   19ba6:	f110 0f16 	cmn.w	r0, #22
   19baa:	d0b5      	beq.n	19b18 <mpu_configure_regions_and_partition.constprop.2+0x8c>
	MPU->RNR = index;
   19bac:	f8c5 b008 	str.w	fp, [r5, #8]
	attr->rbar = MPU->RBAR &
   19bb0:	68ea      	ldr	r2, [r5, #12]
   19bb2:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i]->start +
   19bb6:	f10a 3aff 	add.w	sl, sl, #4294967295
	attr->rbar = MPU->RBAR &
   19bba:	f362 0304 	bfi	r3, r2, #0, #5
   19bbe:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   19bc2:	692b      	ldr	r3, [r5, #16]
   19bc4:	f89d 2008 	ldrb.w	r2, [sp, #8]
   19bc8:	085b      	lsrs	r3, r3, #1
   19bca:	f363 1247 	bfi	r2, r3, #5, #3
			fill_region.base = regions[i]->start +
   19bce:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   19bd2:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i]->start +
   19bd6:	e9d3 2300 	ldrd	r2, r3, [r3]
   19bda:	4413      	add	r3, r2
   19bdc:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i]->start +
   19bde:	f023 031f 	bic.w	r3, r3, #31
   19be2:	4453      	add	r3, sl
   19be4:	eba3 0309 	sub.w	r3, r3, r9
			reg_index++;
   19be8:	3001      	adds	r0, #1
			REGION_LIMIT_ADDR((regions[i]->start +
   19bea:	f023 031f 	bic.w	r3, r3, #31
				region_allocate_and_init(reg_index,
   19bee:	4669      	mov	r1, sp
   19bf0:	b2c0      	uxtb	r0, r0
			fill_region.attr.r_limit =
   19bf2:	9303      	str	r3, [sp, #12]
				region_allocate_and_init(reg_index,
   19bf4:	f7ff ff2a 	bl	19a4c <region_allocate_and_init>
   19bf8:	e7c1      	b.n	19b7e <mpu_configure_regions_and_partition.constprop.2+0xf2>
   19bfa:	bf00      	nop
   19bfc:	e000ed90 	.word	0xe000ed90
   19c00:	0003040c 	.word	0x0003040c
   19c04:	000304c4 	.word	0x000304c4
   19c08:	000331ae 	.word	0x000331ae
   19c0c:	0003318b 	.word	0x0003318b

00019c10 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   19c10:	2205      	movs	r2, #5
   19c12:	4b03      	ldr	r3, [pc, #12]	; (19c20 <arm_core_mpu_enable+0x10>)
   19c14:	605a      	str	r2, [r3, #4]
   19c16:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   19c1a:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   19c1e:	4770      	bx	lr
   19c20:	e000ed90 	.word	0xe000ed90

00019c24 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
   19c24:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   19c28:	2200      	movs	r2, #0
   19c2a:	4b01      	ldr	r3, [pc, #4]	; (19c30 <arm_core_mpu_disable+0xc>)
   19c2c:	605a      	str	r2, [r3, #4]
}
   19c2e:	4770      	bx	lr
   19c30:	e000ed90 	.word	0xe000ed90

00019c34 <arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
static int arm_mpu_init(struct device *arg)
{
   19c34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   19c36:	4f21      	ldr	r7, [pc, #132]	; (19cbc <arm_mpu_init+0x88>)
   19c38:	683e      	ldr	r6, [r7, #0]
   19c3a:	2e10      	cmp	r6, #16
   19c3c:	d913      	bls.n	19c66 <arm_mpu_init+0x32>
		 * what is supported by hardware. As this operation
		 * is executed during system (pre-kernel) initialization,
		 * we want to ensure we can detect an attempt to
		 * perform invalid configuration.
		 */
		__ASSERT(0,
   19c3e:	f240 132d 	movw	r3, #301	; 0x12d
   19c42:	4a1f      	ldr	r2, [pc, #124]	; (19cc0 <arm_mpu_init+0x8c>)
   19c44:	491f      	ldr	r1, [pc, #124]	; (19cc4 <arm_mpu_init+0x90>)
   19c46:	4820      	ldr	r0, [pc, #128]	; (19cc8 <arm_mpu_init+0x94>)
   19c48:	f013 faff 	bl	2d24a <printk>
   19c4c:	2210      	movs	r2, #16
   19c4e:	4631      	mov	r1, r6
   19c50:	481e      	ldr	r0, [pc, #120]	; (19ccc <arm_mpu_init+0x98>)
   19c52:	f013 fafa 	bl	2d24a <printk>
   19c56:	481a      	ldr	r0, [pc, #104]	; (19cc0 <arm_mpu_init+0x8c>)
   19c58:	f240 112d 	movw	r1, #301	; 0x12d
   19c5c:	f013 fb3b 	bl	2d2d6 <assert_post_action>
			"Request to configure: %u regions (supported: %u)\n",
			mpu_config.num_regions,
			get_num_regions()
		);
		return -1;
   19c60:	f04f 30ff 	mov.w	r0, #4294967295
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		DT_NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
}
   19c64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   19c66:	2400      	movs	r4, #0
	arm_core_mpu_disable();
   19c68:	f7ff ffdc 	bl	19c24 <arm_core_mpu_disable>
	MPU->MAIR0 =
   19c6c:	4d18      	ldr	r5, [pc, #96]	; (19cd0 <arm_mpu_init+0x9c>)
   19c6e:	4a19      	ldr	r2, [pc, #100]	; (19cd4 <arm_mpu_init+0xa0>)
   19c70:	632a      	str	r2, [r5, #48]	; 0x30
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   19c72:	42a6      	cmp	r6, r4
   19c74:	d119      	bne.n	19caa <arm_mpu_init+0x76>
	static_regions_num = mpu_config.num_regions;
   19c76:	4b18      	ldr	r3, [pc, #96]	; (19cd8 <arm_mpu_init+0xa4>)
   19c78:	701e      	strb	r6, [r3, #0]
	arm_core_mpu_enable();
   19c7a:	f7ff ffc9 	bl	19c10 <arm_core_mpu_enable>
	__ASSERT(
   19c7e:	682b      	ldr	r3, [r5, #0]
   19c80:	f3c3 2307 	ubfx	r3, r3, #8, #8
   19c84:	2b10      	cmp	r3, #16
   19c86:	d00e      	beq.n	19ca6 <arm_mpu_init+0x72>
   19c88:	4914      	ldr	r1, [pc, #80]	; (19cdc <arm_mpu_init+0xa8>)
   19c8a:	f44f 73a7 	mov.w	r3, #334	; 0x14e
   19c8e:	4a0c      	ldr	r2, [pc, #48]	; (19cc0 <arm_mpu_init+0x8c>)
   19c90:	480d      	ldr	r0, [pc, #52]	; (19cc8 <arm_mpu_init+0x94>)
   19c92:	f013 fada 	bl	2d24a <printk>
   19c96:	4812      	ldr	r0, [pc, #72]	; (19ce0 <arm_mpu_init+0xac>)
   19c98:	f013 fad7 	bl	2d24a <printk>
   19c9c:	f44f 71a7 	mov.w	r1, #334	; 0x14e
   19ca0:	4807      	ldr	r0, [pc, #28]	; (19cc0 <arm_mpu_init+0x8c>)
   19ca2:	f013 fb18 	bl	2d2d6 <assert_post_action>
	return 0;
   19ca6:	2000      	movs	r0, #0
   19ca8:	e7dc      	b.n	19c64 <arm_mpu_init+0x30>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
   19caa:	6879      	ldr	r1, [r7, #4]
   19cac:	4620      	mov	r0, r4
   19cae:	eb01 1104 	add.w	r1, r1, r4, lsl #4
   19cb2:	f7ff feb3 	bl	19a1c <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   19cb6:	3401      	adds	r4, #1
   19cb8:	e7db      	b.n	19c72 <arm_mpu_init+0x3e>
   19cba:	bf00      	nop
   19cbc:	000309dc 	.word	0x000309dc
   19cc0:	000330a5 	.word	0x000330a5
   19cc4:	0003495a 	.word	0x0003495a
   19cc8:	000311a3 	.word	0x000311a3
   19ccc:	000330e5 	.word	0x000330e5
   19cd0:	e000ed90 	.word	0xe000ed90
   19cd4:	0044ffaa 	.word	0x0044ffaa
   19cd8:	2003048f 	.word	0x2003048f
   19cdc:	00033119 	.word	0x00033119
   19ce0:	0003316a 	.word	0x0003316a

00019ce4 <arm_core_mpu_configure_static_mpu_regions>:
{
   19ce4:	b538      	push	{r3, r4, r5, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
   19ce6:	4c0c      	ldr	r4, [pc, #48]	; (19d18 <arm_core_mpu_configure_static_mpu_regions+0x34>)
   19ce8:	460d      	mov	r5, r1
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
   19cea:	7822      	ldrb	r2, [r4, #0]
   19cec:	f7ff fece 	bl	19a8c <mpu_configure_regions_and_partition.constprop.2>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   19cf0:	7020      	strb	r0, [r4, #0]
	if (mpu_configure_static_mpu_regions(static_regions, regions_num,
   19cf2:	3016      	adds	r0, #22
   19cf4:	d10f      	bne.n	19d16 <arm_core_mpu_configure_static_mpu_regions+0x32>
		__ASSERT(0, "Configuring %u static MPU regions failed\n",
   19cf6:	23f3      	movs	r3, #243	; 0xf3
   19cf8:	4a08      	ldr	r2, [pc, #32]	; (19d1c <arm_core_mpu_configure_static_mpu_regions+0x38>)
   19cfa:	4909      	ldr	r1, [pc, #36]	; (19d20 <arm_core_mpu_configure_static_mpu_regions+0x3c>)
   19cfc:	4809      	ldr	r0, [pc, #36]	; (19d24 <arm_core_mpu_configure_static_mpu_regions+0x40>)
   19cfe:	f013 faa4 	bl	2d24a <printk>
   19d02:	4629      	mov	r1, r5
   19d04:	4808      	ldr	r0, [pc, #32]	; (19d28 <arm_core_mpu_configure_static_mpu_regions+0x44>)
   19d06:	f013 faa0 	bl	2d24a <printk>
}
   19d0a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		__ASSERT(0, "Configuring %u static MPU regions failed\n",
   19d0e:	21f3      	movs	r1, #243	; 0xf3
   19d10:	4802      	ldr	r0, [pc, #8]	; (19d1c <arm_core_mpu_configure_static_mpu_regions+0x38>)
   19d12:	f013 bae0 	b.w	2d2d6 <assert_post_action>
}
   19d16:	bd38      	pop	{r3, r4, r5, pc}
   19d18:	2003048f 	.word	0x2003048f
   19d1c:	000330a5 	.word	0x000330a5
   19d20:	0003495a 	.word	0x0003495a
   19d24:	000311a3 	.word	0x000311a3
   19d28:	0003304a 	.word	0x0003304a

00019d2c <arm_core_mpu_mark_areas_for_dynamic_regions>:
{
   19d2c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19d30:	4c2e      	ldr	r4, [pc, #184]	; (19dec <arm_core_mpu_mark_areas_for_dynamic_regions+0xc0>)
   19d32:	4689      	mov	r9, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
   19d34:	4680      	mov	r8, r0
   19d36:	2700      	movs	r7, #0
   19d38:	46a2      	mov	sl, r4
	attr->rbar = MPU->RBAR &
   19d3a:	f04f 0b14 	mov.w	fp, #20
	MPU->RNR = index;
   19d3e:	4d2c      	ldr	r5, [pc, #176]	; (19df0 <arm_core_mpu_mark_areas_for_dynamic_regions+0xc4>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
   19d40:	454f      	cmp	r7, r9
   19d42:	db02      	blt.n	19d4a <arm_core_mpu_mark_areas_for_dynamic_regions+0x1e>
}
   19d44:	b003      	add	sp, #12
   19d46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (dyn_region_areas[i].size == 0U) {
   19d4a:	f8d8 3004 	ldr.w	r3, [r8, #4]
   19d4e:	9301      	str	r3, [sp, #4]
   19d50:	2b00      	cmp	r3, #0
   19d52:	d046      	beq.n	19de2 <arm_core_mpu_mark_areas_for_dynamic_regions+0xb6>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
   19d54:	f8d8 1000 	ldr.w	r1, [r8]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
   19d58:	4608      	mov	r0, r1
   19d5a:	9100      	str	r1, [sp, #0]
   19d5c:	f013 fc4a 	bl	2d5f4 <arm_cmse_mpu_region_get>
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   19d60:	e9dd 1300 	ldrd	r1, r3, [sp]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
   19d64:	4606      	mov	r6, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   19d66:	1858      	adds	r0, r3, r1
   19d68:	3801      	subs	r0, #1
   19d6a:	f013 fc43 	bl	2d5f4 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   19d6e:	4286      	cmp	r6, r0
   19d70:	4a20      	ldr	r2, [pc, #128]	; (19df4 <arm_core_mpu_mark_areas_for_dynamic_regions+0xc8>)
   19d72:	d018      	beq.n	19da6 <arm_core_mpu_mark_areas_for_dynamic_regions+0x7a>
		dyn_reg_info[i].index =
   19d74:	2314      	movs	r3, #20
   19d76:	435f      	muls	r7, r3
   19d78:	f06f 0315 	mvn.w	r3, #21
   19d7c:	f84a 3007 	str.w	r3, [sl, r7]
		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
   19d80:	f240 1303 	movw	r3, #259	; 0x103
   19d84:	4a1c      	ldr	r2, [pc, #112]	; (19df8 <arm_core_mpu_mark_areas_for_dynamic_regions+0xcc>)
   19d86:	491d      	ldr	r1, [pc, #116]	; (19dfc <arm_core_mpu_mark_areas_for_dynamic_regions+0xd0>)
   19d88:	481d      	ldr	r0, [pc, #116]	; (19e00 <arm_core_mpu_mark_areas_for_dynamic_regions+0xd4>)
   19d8a:	f013 fa5e 	bl	2d24a <printk>
   19d8e:	4649      	mov	r1, r9
   19d90:	481c      	ldr	r0, [pc, #112]	; (19e04 <arm_core_mpu_mark_areas_for_dynamic_regions+0xd8>)
   19d92:	f013 fa5a 	bl	2d24a <printk>
   19d96:	f240 1103 	movw	r1, #259	; 0x103
   19d9a:	4817      	ldr	r0, [pc, #92]	; (19df8 <arm_core_mpu_mark_areas_for_dynamic_regions+0xcc>)
}
   19d9c:	b003      	add	sp, #12
   19d9e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
   19da2:	f013 ba98 	b.w	2d2d6 <assert_post_action>
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
   19da6:	f116 0f16 	cmn.w	r6, #22
		dyn_reg_info[i].index =
   19daa:	6026      	str	r6, [r4, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
   19dac:	d0e8      	beq.n	19d80 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
   19dae:	7813      	ldrb	r3, [r2, #0]
   19db0:	42b3      	cmp	r3, r6
   19db2:	dde5      	ble.n	19d80 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
	attr->rbar = MPU->RBAR &
   19db4:	fb0b a307 	mla	r3, fp, r7, sl
	MPU->RNR = index;
   19db8:	60ae      	str	r6, [r5, #8]
	MPU->RNR = index;
   19dba:	60ae      	str	r6, [r5, #8]
	attr->rbar = MPU->RBAR &
   19dbc:	68e8      	ldr	r0, [r5, #12]
   19dbe:	7b19      	ldrb	r1, [r3, #12]
   19dc0:	f360 0104 	bfi	r1, r0, #0, #5
   19dc4:	7319      	strb	r1, [r3, #12]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   19dc6:	6929      	ldr	r1, [r5, #16]
   19dc8:	7b18      	ldrb	r0, [r3, #12]
   19dca:	0849      	lsrs	r1, r1, #1
   19dcc:	f361 1047 	bfi	r0, r1, #5, #3
   19dd0:	7318      	strb	r0, [r3, #12]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
   19dd2:	68eb      	ldr	r3, [r5, #12]
   19dd4:	f023 031f 	bic.w	r3, r3, #31
   19dd8:	6063      	str	r3, [r4, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
   19dda:	692b      	ldr	r3, [r5, #16]
   19ddc:	f023 031f 	bic.w	r3, r3, #31
   19de0:	6123      	str	r3, [r4, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
   19de2:	3701      	adds	r7, #1
   19de4:	3414      	adds	r4, #20
   19de6:	f108 080c 	add.w	r8, r8, #12
   19dea:	e7a9      	b.n	19d40 <arm_core_mpu_mark_areas_for_dynamic_regions+0x14>
   19dec:	20028734 	.word	0x20028734
   19df0:	e000ed90 	.word	0xe000ed90
   19df4:	2003048f 	.word	0x2003048f
   19df8:	000330a5 	.word	0x000330a5
   19dfc:	0003495a 	.word	0x0003495a
   19e00:	000311a3 	.word	0x000311a3
   19e04:	00033076 	.word	0x00033076

00019e08 <arm_core_mpu_configure_dynamic_mpu_regions>:
{
   19e08:	b570      	push	{r4, r5, r6, lr}
 * performed, the error signal is propagated to the caller of the function.
 */
static int mpu_configure_dynamic_mpu_regions(const struct k_mem_partition
	*dynamic_regions[], u8_t regions_num)
{
	int mpu_reg_index = static_regions_num;
   19e0a:	4b16      	ldr	r3, [pc, #88]	; (19e64 <arm_core_mpu_configure_dynamic_mpu_regions+0x5c>)
   19e0c:	460c      	mov	r4, r1
   19e0e:	781d      	ldrb	r5, [r3, #0]
   19e10:	4606      	mov	r6, r0
   19e12:	462b      	mov	r3, r5
  mpu->RLAR = 0U;
   19e14:	2100      	movs	r1, #0
  mpu->RNR = rnr;
   19e16:	4a14      	ldr	r2, [pc, #80]	; (19e68 <arm_core_mpu_configure_dynamic_mpu_regions+0x60>)

	/* Disable all MPU regions except for the static ones. */
	for (int i = mpu_reg_index; i < get_num_regions(); i++) {
   19e18:	2b0f      	cmp	r3, #15
   19e1a:	dd1d      	ble.n	19e58 <arm_core_mpu_configure_dynamic_mpu_regions+0x50>
#if defined(CONFIG_MPU_GAP_FILLING)
	/* Reset MPU regions inside which dynamic memory regions may
	 * be programmed.
	 */
	for (int i = 0; i < MPU_DYNAMIC_REGION_AREAS_NUM; i++) {
		region_init(dyn_reg_info[i].index,
   19e1c:	4913      	ldr	r1, [pc, #76]	; (19e6c <arm_core_mpu_configure_dynamic_mpu_regions+0x64>)
   19e1e:	f851 0b04 	ldr.w	r0, [r1], #4
   19e22:	f7ff fdfb 	bl	19a1c <region_init>

	/* In ARMv8-M architecture the dynamic regions are programmed on SRAM,
	 * forming a full partition of the background area, specified by the
	 * given boundaries.
	 */
	mpu_reg_index = mpu_configure_regions_and_partition(dynamic_regions,
   19e26:	462a      	mov	r2, r5
   19e28:	4621      	mov	r1, r4
   19e2a:	4630      	mov	r0, r6
   19e2c:	f7ff fe2e 	bl	19a8c <mpu_configure_regions_and_partition.constprop.2>
	if (mpu_configure_dynamic_mpu_regions(dynamic_regions, regions_num)
   19e30:	3016      	adds	r0, #22
   19e32:	d115      	bne.n	19e60 <arm_core_mpu_configure_dynamic_mpu_regions+0x58>
		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
   19e34:	f44f 7389 	mov.w	r3, #274	; 0x112
   19e38:	4a0d      	ldr	r2, [pc, #52]	; (19e70 <arm_core_mpu_configure_dynamic_mpu_regions+0x68>)
   19e3a:	490e      	ldr	r1, [pc, #56]	; (19e74 <arm_core_mpu_configure_dynamic_mpu_regions+0x6c>)
   19e3c:	480e      	ldr	r0, [pc, #56]	; (19e78 <arm_core_mpu_configure_dynamic_mpu_regions+0x70>)
   19e3e:	f013 fa04 	bl	2d24a <printk>
   19e42:	4621      	mov	r1, r4
   19e44:	480d      	ldr	r0, [pc, #52]	; (19e7c <arm_core_mpu_configure_dynamic_mpu_regions+0x74>)
   19e46:	f013 fa00 	bl	2d24a <printk>
}
   19e4a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		__ASSERT(0, "Configuring %u dynamic MPU regions failed\n",
   19e4e:	f44f 7189 	mov.w	r1, #274	; 0x112
   19e52:	4807      	ldr	r0, [pc, #28]	; (19e70 <arm_core_mpu_configure_dynamic_mpu_regions+0x68>)
   19e54:	f013 ba3f 	b.w	2d2d6 <assert_post_action>
   19e58:	6093      	str	r3, [r2, #8]
  mpu->RLAR = 0U;
   19e5a:	6111      	str	r1, [r2, #16]
	for (int i = mpu_reg_index; i < get_num_regions(); i++) {
   19e5c:	3301      	adds	r3, #1
   19e5e:	e7db      	b.n	19e18 <arm_core_mpu_configure_dynamic_mpu_regions+0x10>
}
   19e60:	bd70      	pop	{r4, r5, r6, pc}
   19e62:	bf00      	nop
   19e64:	2003048f 	.word	0x2003048f
   19e68:	e000ed90 	.word	0xe000ed90
   19e6c:	20028734 	.word	0x20028734
   19e70:	000330a5 	.word	0x000330a5
   19e74:	0003495a 	.word	0x0003495a
   19e78:	000311a3 	.word	0x000311a3
   19e7c:	0003301d 	.word	0x0003301d

00019e80 <z_impl_zephyr_read_stdin>:
{
	_stdin_hook = hook;
}

int z_impl_zephyr_read_stdin(char *buf, int nbytes)
{
   19e80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19e82:	4606      	mov	r6, r0
   19e84:	460d      	mov	r5, r1
	int i = 0;

	for (i = 0; i < nbytes; i++) {
   19e86:	2400      	movs	r4, #0
		*(buf + i) = _stdin_hook();
   19e88:	4f06      	ldr	r7, [pc, #24]	; (19ea4 <z_impl_zephyr_read_stdin+0x24>)
	for (i = 0; i < nbytes; i++) {
   19e8a:	42ac      	cmp	r4, r5
   19e8c:	da08      	bge.n	19ea0 <z_impl_zephyr_read_stdin+0x20>
		*(buf + i) = _stdin_hook();
   19e8e:	683b      	ldr	r3, [r7, #0]
   19e90:	4798      	blx	r3
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
   19e92:	280a      	cmp	r0, #10
		*(buf + i) = _stdin_hook();
   19e94:	5530      	strb	r0, [r6, r4]
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
   19e96:	f104 0401 	add.w	r4, r4, #1
   19e9a:	d001      	beq.n	19ea0 <z_impl_zephyr_read_stdin+0x20>
   19e9c:	280d      	cmp	r0, #13
   19e9e:	d1f4      	bne.n	19e8a <z_impl_zephyr_read_stdin+0xa>
			i++;
			break;
		}
	}
	return i;
}
   19ea0:	4620      	mov	r0, r4
   19ea2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   19ea4:	200382a0 	.word	0x200382a0

00019ea8 <z_impl_zephyr_write_stdout>:
}
#include <syscalls/z_zephyr_read_stdin_mrsh.c>
#endif

int z_impl_zephyr_write_stdout(const void *buffer, int nbytes)
{
   19ea8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19eaa:	460e      	mov	r6, r1
   19eac:	4f09      	ldr	r7, [pc, #36]	; (19ed4 <z_impl_zephyr_write_stdout+0x2c>)
   19eae:	1e44      	subs	r4, r0, #1
	const char *buf = buffer;
	int i;

	for (i = 0; i < nbytes; i++) {
   19eb0:	f1c0 0501 	rsb	r5, r0, #1
   19eb4:	192b      	adds	r3, r5, r4
   19eb6:	429e      	cmp	r6, r3
   19eb8:	dc01      	bgt.n	19ebe <z_impl_zephyr_write_stdout+0x16>
			_stdout_hook('\r');
		}
		_stdout_hook(*(buf + i));
	}
	return nbytes;
}
   19eba:	4630      	mov	r0, r6
   19ebc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (*(buf + i) == '\n') {
   19ebe:	7863      	ldrb	r3, [r4, #1]
   19ec0:	2b0a      	cmp	r3, #10
   19ec2:	d102      	bne.n	19eca <z_impl_zephyr_write_stdout+0x22>
			_stdout_hook('\r');
   19ec4:	683b      	ldr	r3, [r7, #0]
   19ec6:	200d      	movs	r0, #13
   19ec8:	4798      	blx	r3
		_stdout_hook(*(buf + i));
   19eca:	683b      	ldr	r3, [r7, #0]
   19ecc:	f814 0f01 	ldrb.w	r0, [r4, #1]!
   19ed0:	4798      	blx	r3
   19ed2:	e7ef      	b.n	19eb4 <z_impl_zephyr_write_stdout+0xc>
   19ed4:	200382a4 	.word	0x200382a4

00019ed8 <_exit>:
	return 0;
}
__weak FUNC_ALIAS(_fstat, fstat, int);

__weak void _exit(int status)
{
   19ed8:	b508      	push	{r3, lr}
	return z_impl_zephyr_write_stdout(buf, nbytes);
   19eda:	2105      	movs	r1, #5
   19edc:	4801      	ldr	r0, [pc, #4]	; (19ee4 <_exit+0xc>)
   19ede:	f7ff ffe3 	bl	19ea8 <z_impl_zephyr_write_stdout>
	_write(1, "exit\n", 5);
	while (1) {
		;
   19ee2:	e7fe      	b.n	19ee2 <_exit+0xa>
   19ee4:	000331f7 	.word	0x000331f7

00019ee8 <_sbrk>:
}

static LIBC_DATA SYS_SEM_DEFINE(heap_sem, 1, 1);

void *_sbrk(int count)
{
   19ee8:	b538      	push	{r3, r4, r5, lr}
   19eea:	4605      	mov	r5, r0
	void *ret, *ptr;

	sys_sem_take(&heap_sem, K_FOREVER);
   19eec:	f04f 31ff 	mov.w	r1, #4294967295
   19ef0:	480b      	ldr	r0, [pc, #44]	; (19f20 <_sbrk+0x38>)
   19ef2:	f013 f9bc 	bl	2d26e <sys_sem_take>

#if CONFIG_NEWLIB_LIBC_ALIGNED_HEAP_SIZE
	ptr = heap_base + heap_sz;
#else
	ptr = ((char *)HEAP_BASE) + heap_sz;
   19ef6:	4a0b      	ldr	r2, [pc, #44]	; (19f24 <_sbrk+0x3c>)
#endif

	if ((heap_sz + count) < MAX_HEAP_SIZE) {
   19ef8:	490b      	ldr	r1, [pc, #44]	; (19f28 <_sbrk+0x40>)
	ptr = ((char *)HEAP_BASE) + heap_sz;
   19efa:	6814      	ldr	r4, [r2, #0]
	if ((heap_sz + count) < MAX_HEAP_SIZE) {
   19efc:	f1c1 5300 	rsb	r3, r1, #536870912	; 0x20000000
   19f00:	4425      	add	r5, r4
   19f02:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   19f06:	429d      	cmp	r5, r3
		heap_sz += count;
		ret = ptr;
	} else {
		ret = (void *)-1;
   19f08:	bf2c      	ite	cs
   19f0a:	f04f 34ff 	movcs.w	r4, #4294967295
	ptr = ((char *)HEAP_BASE) + heap_sz;
   19f0e:	1864      	addcc	r4, r4, r1
	}

	sys_sem_give(&heap_sem);
   19f10:	4803      	ldr	r0, [pc, #12]	; (19f20 <_sbrk+0x38>)
		heap_sz += count;
   19f12:	bf38      	it	cc
   19f14:	6015      	strcc	r5, [r2, #0]
	sys_sem_give(&heap_sem);
   19f16:	f013 f9a5 	bl	2d264 <sys_sem_give>

	return ret;
}
   19f1a:	4620      	mov	r0, r4
   19f1c:	bd38      	pop	{r3, r4, r5, pc}
   19f1e:	bf00      	nop
   19f20:	2003b898 	.word	0x2003b898
   19f24:	20028748 	.word	0x20028748
   19f28:	2003b9bc 	.word	0x2003b9bc

00019f2c <net_if_flag_is_set>:
 *
 * @return True if the value is set, false otherwise
 */
static inline bool net_if_flag_is_set(struct net_if *iface,
				      enum net_if_flag value)
{
   19f2c:	b538      	push	{r3, r4, r5, lr}
   19f2e:	460d      	mov	r5, r1
	NET_ASSERT(iface);
   19f30:	4604      	mov	r4, r0
   19f32:	b970      	cbnz	r0, 19f52 <net_if_flag_is_set+0x26>
   19f34:	490b      	ldr	r1, [pc, #44]	; (19f64 <net_if_flag_is_set+0x38>)
   19f36:	f240 2311 	movw	r3, #529	; 0x211
   19f3a:	4a0b      	ldr	r2, [pc, #44]	; (19f68 <net_if_flag_is_set+0x3c>)
   19f3c:	480b      	ldr	r0, [pc, #44]	; (19f6c <net_if_flag_is_set+0x40>)
   19f3e:	f013 f984 	bl	2d24a <printk>
   19f42:	480b      	ldr	r0, [pc, #44]	; (19f70 <net_if_flag_is_set+0x44>)
   19f44:	f013 f981 	bl	2d24a <printk>
   19f48:	f240 2111 	movw	r1, #529	; 0x211
   19f4c:	4806      	ldr	r0, [pc, #24]	; (19f68 <net_if_flag_is_set+0x3c>)
   19f4e:	f013 f9c2 	bl	2d2d6 <assert_post_action>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   19f52:	6823      	ldr	r3, [r4, #0]
   19f54:	330c      	adds	r3, #12
   19f56:	e8d3 0faf 	lda	r0, [r3]
 */
static inline bool atomic_test_bit(const atomic_t *target, int bit)
{
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));

	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   19f5a:	4128      	asrs	r0, r5

	return atomic_test_bit(iface->if_dev->flags, value);
}
   19f5c:	f000 0001 	and.w	r0, r0, #1
   19f60:	bd38      	pop	{r3, r4, r5, pc}
   19f62:	bf00      	nop
   19f64:	0003323c 	.word	0x0003323c
   19f68:	00033214 	.word	0x00033214
   19f6c:	000311a3 	.word	0x000311a3
   19f70:	00033242 	.word	0x00033242

00019f74 <net_if_flag_set.constprop.24>:
static inline void net_if_flag_set(struct net_if *iface,
   19f74:	b510      	push	{r4, lr}
	NET_ASSERT(iface);
   19f76:	4604      	mov	r4, r0
   19f78:	b970      	cbnz	r0, 19f98 <net_if_flag_set.constprop.24+0x24>
   19f7a:	490d      	ldr	r1, [pc, #52]	; (19fb0 <net_if_flag_set.constprop.24+0x3c>)
   19f7c:	f240 13e3 	movw	r3, #483	; 0x1e3
   19f80:	4a0c      	ldr	r2, [pc, #48]	; (19fb4 <net_if_flag_set.constprop.24+0x40>)
   19f82:	480d      	ldr	r0, [pc, #52]	; (19fb8 <net_if_flag_set.constprop.24+0x44>)
   19f84:	f013 f961 	bl	2d24a <printk>
   19f88:	480c      	ldr	r0, [pc, #48]	; (19fbc <net_if_flag_set.constprop.24+0x48>)
   19f8a:	f013 f95e 	bl	2d24a <printk>
   19f8e:	f240 11e3 	movw	r1, #483	; 0x1e3
   19f92:	4808      	ldr	r0, [pc, #32]	; (19fb4 <net_if_flag_set.constprop.24+0x40>)
   19f94:	f013 f99f 	bl	2d2d6 <assert_post_action>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   19f98:	6823      	ldr	r3, [r4, #0]
   19f9a:	330c      	adds	r3, #12
   19f9c:	e8d3 2fef 	ldaex	r2, [r3]
   19fa0:	f042 0201 	orr.w	r2, r2, #1
   19fa4:	e8c3 2fe1 	stlex	r1, r2, [r3]
   19fa8:	2900      	cmp	r1, #0
   19faa:	d1f7      	bne.n	19f9c <net_if_flag_set.constprop.24+0x28>
}
   19fac:	bd10      	pop	{r4, pc}
   19fae:	bf00      	nop
   19fb0:	0003323c 	.word	0x0003323c
   19fb4:	00033214 	.word	0x00033214
   19fb8:	000311a3 	.word	0x000311a3
   19fbc:	00033242 	.word	0x00033242

00019fc0 <net_if_up>:
		cb(iface, user_data);
	}
}

int net_if_up(struct net_if *iface)
{
   19fc0:	b538      	push	{r3, r4, r5, lr}
	int status;

	NET_DBG("iface %p", iface);

	if (net_if_flag_is_set(iface, NET_IF_UP)) {
   19fc2:	2100      	movs	r1, #0
{
   19fc4:	4605      	mov	r5, r0
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
   19fc6:	f7ff ffb1 	bl	19f2c <net_if_flag_is_set>
   19fca:	b928      	cbnz	r0, 19fd8 <net_if_up+0x18>
 * @return True if socket offloading is active, false otherwise.
 */
static inline bool net_if_is_socket_offloaded(struct net_if *iface)
{
#if defined(CONFIG_NET_SOCKETS_OFFLOAD)
	return iface->if_dev->offloaded;
   19fcc:	682b      	ldr	r3, [r5, #0]

	if ((IS_ENABLED(CONFIG_NET_OFFLOAD) &&
	     net_if_is_ip_offloaded(iface)) ||
	    (IS_ENABLED(CONFIG_NET_SOCKETS_OFFLOAD) &&
	     net_if_is_socket_offloaded(iface))) {
		net_if_flag_set(iface, NET_IF_UP);
   19fce:	4628      	mov	r0, r5
	if ((IS_ENABLED(CONFIG_NET_OFFLOAD) &&
   19fd0:	7e9b      	ldrb	r3, [r3, #26]
   19fd2:	b11b      	cbz	r3, 19fdc <net_if_up+0x1c>
		net_if_flag_set(iface, NET_IF_UP);
   19fd4:	f7ff ffce 	bl	19f74 <net_if_flag_set.constprop.24>
		return 0;
   19fd8:	2000      	movs	r0, #0
   19fda:	e023      	b.n	1a024 <net_if_up+0x64>
		goto exit;
	}

	/* If the L2 does not support enable just set the flag */
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
   19fdc:	f013 fb39 	bl	2d652 <net_if_l2>
   19fe0:	b9c0      	cbnz	r0, 1a014 <net_if_up+0x54>

done:
	/* In many places it's assumed that link address was set with
	 * net_if_set_link_addr(). Better check that now.
	 */
	NET_ASSERT(net_if_get_link_addr(iface)->addr != NULL);
   19fe2:	682b      	ldr	r3, [r5, #0]
   19fe4:	691b      	ldr	r3, [r3, #16]
   19fe6:	b973      	cbnz	r3, 1a006 <net_if_up+0x46>
   19fe8:	490f      	ldr	r1, [pc, #60]	; (1a028 <net_if_up+0x68>)
   19fea:	f640 538f 	movw	r3, #3471	; 0xd8f
   19fee:	4a0f      	ldr	r2, [pc, #60]	; (1a02c <net_if_up+0x6c>)
   19ff0:	480f      	ldr	r0, [pc, #60]	; (1a030 <net_if_up+0x70>)
   19ff2:	f013 f92a 	bl	2d24a <printk>
   19ff6:	480f      	ldr	r0, [pc, #60]	; (1a034 <net_if_up+0x74>)
   19ff8:	f013 f927 	bl	2d24a <printk>
   19ffc:	f640 518f 	movw	r1, #3471	; 0xd8f
   1a000:	480a      	ldr	r0, [pc, #40]	; (1a02c <net_if_up+0x6c>)
   1a002:	f013 f968 	bl	2d2d6 <assert_post_action>

	net_if_flag_set(iface, NET_IF_UP);
   1a006:	4628      	mov	r0, r5
   1a008:	f7ff ffb4 	bl	19f74 <net_if_flag_set.constprop.24>

	/* If the interface is only having point-to-point traffic then we do
	 * not need to run DAD etc for it.
	 */
	if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
   1a00c:	4628      	mov	r0, r5
   1a00e:	f013 fb25 	bl	2d65c <l2_flags_get>
   1a012:	e7e1      	b.n	19fd8 <net_if_up+0x18>
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
   1a014:	6883      	ldr	r3, [r0, #8]
   1a016:	2b00      	cmp	r3, #0
   1a018:	d0e3      	beq.n	19fe2 <net_if_up+0x22>
	status = net_if_l2(iface)->enable(iface, true);
   1a01a:	2101      	movs	r1, #1
   1a01c:	4628      	mov	r0, r5
   1a01e:	4798      	blx	r3
	if (status < 0) {
   1a020:	2800      	cmp	r0, #0
   1a022:	dade      	bge.n	19fe2 <net_if_up+0x22>

exit:
	net_mgmt_event_notify(NET_EVENT_IF_UP, iface);

	return 0;
}
   1a024:	bd38      	pop	{r3, r4, r5, pc}
   1a026:	bf00      	nop
   1a028:	00033245 	.word	0x00033245
   1a02c:	00033276 	.word	0x00033276
   1a030:	000311a3 	.word	0x000311a3
   1a034:	00033242 	.word	0x00033242

0001a038 <net_if_init>:
	k_fifo_put(&tx_ts_queue, pkt);
}
#endif /* CONFIG_NET_PKT_TIMESTAMP_THREAD */

void net_if_init(void)
{
   1a038:	b538      	push	{r3, r4, r5, lr}

	NET_DBG("");

	net_tc_tx_init();

	for (iface = __net_if_start, if_count = 0; iface != __net_if_end;
   1a03a:	4c07      	ldr	r4, [pc, #28]	; (1a058 <net_if_init+0x20>)
   1a03c:	4d07      	ldr	r5, [pc, #28]	; (1a05c <net_if_init+0x24>)
   1a03e:	42ac      	cmp	r4, r5
   1a040:	d100      	bne.n	1a044 <net_if_init+0xc>
		NET_WARN("You have configured only %d VLAN interfaces"
			 " but you have %d network interfaces.",
			 CONFIG_NET_VLAN_COUNT, if_count);
	}
#endif
}
   1a042:	bd38      	pop	{r3, r4, r5, pc}
	return iface->if_dev->dev;
   1a044:	6823      	ldr	r3, [r4, #0]
	const struct net_if_api *api = net_if_get_device(iface)->driver_api;
   1a046:	681b      	ldr	r3, [r3, #0]
   1a048:	685b      	ldr	r3, [r3, #4]
	if (!api || !api->init) {
   1a04a:	b11b      	cbz	r3, 1a054 <net_if_init+0x1c>
   1a04c:	681b      	ldr	r3, [r3, #0]
   1a04e:	b10b      	cbz	r3, 1a054 <net_if_init+0x1c>
	api->init(iface);
   1a050:	4620      	mov	r0, r4
   1a052:	4798      	blx	r3
	     iface++, if_count++) {
   1a054:	3420      	adds	r4, #32
   1a056:	e7f2      	b.n	1a03e <net_if_init+0x6>
   1a058:	2003b980 	.word	0x2003b980
   1a05c:	2003b9a0 	.word	0x2003b9a0

0001a060 <net_if_post_init>:

void net_if_post_init(void)
{
   1a060:	b538      	push	{r3, r4, r5, lr}
	struct net_if *iface;

	NET_DBG("");

	/* After TX is running, attempt to bring the interface up */
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   1a062:	4c07      	ldr	r4, [pc, #28]	; (1a080 <net_if_post_init+0x20>)
   1a064:	4d07      	ldr	r5, [pc, #28]	; (1a084 <net_if_post_init+0x24>)
   1a066:	42ac      	cmp	r4, r5
   1a068:	d100      	bne.n	1a06c <net_if_post_init+0xc>
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
			net_if_up(iface);
		}
	}
}
   1a06a:	bd38      	pop	{r3, r4, r5, pc}
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
   1a06c:	2103      	movs	r1, #3
   1a06e:	4620      	mov	r0, r4
   1a070:	f7ff ff5c 	bl	19f2c <net_if_flag_is_set>
   1a074:	b910      	cbnz	r0, 1a07c <net_if_post_init+0x1c>
			net_if_up(iface);
   1a076:	4620      	mov	r0, r4
   1a078:	f7ff ffa2 	bl	19fc0 <net_if_up>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   1a07c:	3420      	adds	r4, #32
   1a07e:	e7f2      	b.n	1a066 <net_if_post_init+0x6>
   1a080:	2003b980 	.word	0x2003b980
   1a084:	2003b9a0 	.word	0x2003b9a0

0001a088 <z_impl_net_addr_ntop>:
	struct in6_addr *addr6;
	u16_t *w;
	u8_t i, bl, bh, longest = 1U;
	s8_t pos = -1;
	char delim = ':';
	unsigned char zeros[8] = { 0 };
   1a088:	2300      	movs	r3, #0
{
   1a08a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char *ptr = dst;
	int len = -1;
	u16_t value;
	bool needcolon = false;

	if (family == AF_INET6) {
   1a08e:	2802      	cmp	r0, #2
{
   1a090:	b089      	sub	sp, #36	; 0x24
   1a092:	4681      	mov	r9, r0
   1a094:	468a      	mov	sl, r1
   1a096:	4690      	mov	r8, r2
	unsigned char zeros[8] = { 0 };
   1a098:	e9cd 3306 	strd	r3, r3, [sp, #24]
	if (family == AF_INET6) {
   1a09c:	d13c      	bne.n	1a118 <z_impl_net_addr_ntop+0x90>
		addr6 = (struct in6_addr *)src;
		w = (u16_t *)addr6->s6_addr16;
   1a09e:	aa06      	add	r2, sp, #24
   1a0a0:	4610      	mov	r0, r2
   1a0a2:	9104      	str	r1, [sp, #16]
{
   1a0a4:	4619      	mov	r1, r3
   1a0a6:	e006      	b.n	1a0b6 <z_impl_net_addr_ntop+0x2e>
			for (j = i; j < 8; j++) {
				if (UNALIGNED_GET(&w[j]) != 0) {
					break;
				}

				zeros[i]++;
   1a0a8:	7804      	ldrb	r4, [r0, #0]
   1a0aa:	3101      	adds	r1, #1
   1a0ac:	3401      	adds	r4, #1
   1a0ae:	7004      	strb	r4, [r0, #0]
			for (j = i; j < 8; j++) {
   1a0b0:	b2cc      	uxtb	r4, r1
   1a0b2:	2c07      	cmp	r4, #7
   1a0b4:	d803      	bhi.n	1a0be <z_impl_net_addr_ntop+0x36>
				if (UNALIGNED_GET(&w[j]) != 0) {
   1a0b6:	f83a 4011 	ldrh.w	r4, [sl, r1, lsl #1]
   1a0ba:	2c00      	cmp	r4, #0
   1a0bc:	d0f4      	beq.n	1a0a8 <z_impl_net_addr_ntop+0x20>
   1a0be:	3301      	adds	r3, #1
		for (i = 0U; i < 8; i++) {
   1a0c0:	2b08      	cmp	r3, #8
   1a0c2:	f100 0001 	add.w	r0, r0, #1
   1a0c6:	d1ed      	bne.n	1a0a4 <z_impl_net_addr_ntop+0x1c>
	s8_t pos = -1;
   1a0c8:	f04f 36ff 	mov.w	r6, #4294967295
	u8_t i, bl, bh, longest = 1U;
   1a0cc:	2701      	movs	r7, #1
			}
		}

		for (i = 0U; i < 8; i++) {
   1a0ce:	2300      	movs	r3, #0
			if (zeros[i] > longest) {
   1a0d0:	f812 1b01 	ldrb.w	r1, [r2], #1
   1a0d4:	42b9      	cmp	r1, r7
				longest = zeros[i];
				pos = i;
   1a0d6:	bf88      	it	hi
   1a0d8:	b25e      	sxtbhi	r6, r3
		for (i = 0U; i < 8; i++) {
   1a0da:	f103 0301 	add.w	r3, r3, #1
   1a0de:	b2db      	uxtb	r3, r3
				pos = i;
   1a0e0:	bf88      	it	hi
   1a0e2:	460f      	movhi	r7, r1
		for (i = 0U; i < 8; i++) {
   1a0e4:	2b08      	cmp	r3, #8
   1a0e6:	d1f3      	bne.n	1a0d0 <z_impl_net_addr_ntop+0x48>
		len = 8;
   1a0e8:	9303      	str	r3, [sp, #12]
   1a0ea:	2f01      	cmp	r7, #1
   1a0ec:	f04f 033a 	mov.w	r3, #58	; 0x3a
   1a0f0:	bf08      	it	eq
   1a0f2:	f04f 36ff 	moveq.w	r6, #4294967295
   1a0f6:	9302      	str	r3, [sp, #8]
	bool needcolon = false;
   1a0f8:	2200      	movs	r2, #0
		delim = '.';
	} else {
		return NULL;
	}

	for (i = 0U; i < len; i++) {
   1a0fa:	4644      	mov	r4, r8
   1a0fc:	4615      	mov	r5, r2
   1a0fe:	9b03      	ldr	r3, [sp, #12]
   1a100:	429d      	cmp	r5, r3
   1a102:	db19      	blt.n	1a138 <z_impl_net_addr_ntop+0xb0>
		}

		needcolon = true;
	}

	if (!(ptr - dst)) {
   1a104:	4544      	cmp	r4, r8
   1a106:	d009      	beq.n	1a11c <z_impl_net_addr_ntop+0x94>
		return NULL;
	}

	if (family == AF_INET) {
   1a108:	2300      	movs	r3, #0
   1a10a:	f1b9 0f01 	cmp.w	r9, #1
		*(ptr - 1) = '\0';
   1a10e:	bf0c      	ite	eq
   1a110:	f804 3c01 	strbeq.w	r3, [r4, #-1]
	} else {
		*ptr = '\0';
   1a114:	7023      	strbne	r3, [r4, #0]
   1a116:	e003      	b.n	1a120 <z_impl_net_addr_ntop+0x98>
	} else if (family == AF_INET) {
   1a118:	2801      	cmp	r0, #1
   1a11a:	d005      	beq.n	1a128 <z_impl_net_addr_ntop+0xa0>
		return NULL;
   1a11c:	f04f 0800 	mov.w	r8, #0
	}

	return dst;
}
   1a120:	4640      	mov	r0, r8
   1a122:	b009      	add	sp, #36	; 0x24
   1a124:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		delim = '.';
   1a128:	232e      	movs	r3, #46	; 0x2e
   1a12a:	2204      	movs	r2, #4
	s8_t pos = -1;
   1a12c:	f04f 36ff 	mov.w	r6, #4294967295
		delim = '.';
   1a130:	e9cd 3202 	strd	r3, r2, [sp, #8]
	u8_t i, bl, bh, longest = 1U;
   1a134:	4607      	mov	r7, r0
   1a136:	e7df      	b.n	1a0f8 <z_impl_net_addr_ntop+0x70>
		if (len == 4) {
   1a138:	9b03      	ldr	r3, [sp, #12]
   1a13a:	2b04      	cmp	r3, #4
   1a13c:	d134      	bne.n	1a1a8 <z_impl_net_addr_ntop+0x120>
			value = (u32_t)addr->s4_addr[i];
   1a13e:	f81a 1005 	ldrb.w	r1, [sl, r5]
			if (value == 0U) {
   1a142:	b949      	cbnz	r1, 1a158 <z_impl_net_addr_ntop+0xd0>
				*ptr++ = '0';
   1a144:	2330      	movs	r3, #48	; 0x30
   1a146:	4620      	mov	r0, r4
   1a148:	f800 3b02 	strb.w	r3, [r0], #2
				*ptr++ = delim;
   1a14c:	9b02      	ldr	r3, [sp, #8]
   1a14e:	7063      	strb	r3, [r4, #1]
	for (i = 0U; i < len; i++) {
   1a150:	3501      	adds	r5, #1
   1a152:	b2ed      	uxtb	r5, r5
   1a154:	4604      	mov	r4, r0
   1a156:	e7d2      	b.n	1a0fe <z_impl_net_addr_ntop+0x76>
			l = net_value_to_udec(ptr, value, 0);
   1a158:	2009      	movs	r0, #9
   1a15a:	f04f 0b00 	mov.w	fp, #0
   1a15e:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 1a238 <z_impl_net_addr_ntop+0x1b0>
   1a162:	9401      	str	r4, [sp, #4]
		temp = value / divisor;
   1a164:	fbb1 fefc 	udiv	lr, r1, ip
		value = value % divisor;
   1a168:	fb0c 131e 	mls	r3, ip, lr, r1
		if ((precision > i) || (temp != 0)) {
   1a16c:	4583      	cmp	fp, r0
		value = value % divisor;
   1a16e:	9305      	str	r3, [sp, #20]
		if ((precision > i) || (temp != 0)) {
   1a170:	dc01      	bgt.n	1a176 <z_impl_net_addr_ntop+0xee>
   1a172:	4561      	cmp	r1, ip
   1a174:	d306      	bcc.n	1a184 <z_impl_net_addr_ntop+0xfc>
			*buf++ = (char) (temp + '0');
   1a176:	4683      	mov	fp, r0
   1a178:	9b01      	ldr	r3, [sp, #4]
   1a17a:	f10e 0e30 	add.w	lr, lr, #48	; 0x30
   1a17e:	f803 eb01 	strb.w	lr, [r3], #1
   1a182:	9301      	str	r3, [sp, #4]
	for (i = 9; i >= 0; i--, divisor /= 10U) {
   1a184:	230a      	movs	r3, #10
   1a186:	3801      	subs	r0, #1
   1a188:	fbbc fcf3 	udiv	ip, ip, r3
   1a18c:	1c43      	adds	r3, r0, #1
		value = value % divisor;
   1a18e:	9905      	ldr	r1, [sp, #20]
	for (i = 9; i >= 0; i--, divisor /= 10U) {
   1a190:	d1e8      	bne.n	1a164 <z_impl_net_addr_ntop+0xdc>
	*buf = 0;
   1a192:	f04f 0300 	mov.w	r3, #0
   1a196:	9901      	ldr	r1, [sp, #4]
   1a198:	700b      	strb	r3, [r1, #0]
	return buf - start;
   1a19a:	1b0b      	subs	r3, r1, r4
			ptr += l;
   1a19c:	b2db      	uxtb	r3, r3
			*ptr++ = delim;
   1a19e:	9902      	ldr	r1, [sp, #8]
			ptr += l;
   1a1a0:	18e0      	adds	r0, r4, r3
			*ptr++ = delim;
   1a1a2:	3001      	adds	r0, #1
   1a1a4:	54e1      	strb	r1, [r4, r3]
			continue;
   1a1a6:	e7d3      	b.n	1a150 <z_impl_net_addr_ntop+0xc8>
		if (i == pos) {
   1a1a8:	42ae      	cmp	r6, r5
   1a1aa:	d10d      	bne.n	1a1c8 <z_impl_net_addr_ntop+0x140>
			if (needcolon || i == 0U) {
   1a1ac:	b902      	cbnz	r2, 1a1b0 <z_impl_net_addr_ntop+0x128>
   1a1ae:	b916      	cbnz	r6, 1a1b6 <z_impl_net_addr_ntop+0x12e>
				*ptr++ = ':';
   1a1b0:	233a      	movs	r3, #58	; 0x3a
   1a1b2:	f804 3b01 	strb.w	r3, [r4], #1
			*ptr++ = ':';
   1a1b6:	233a      	movs	r3, #58	; 0x3a
   1a1b8:	4620      	mov	r0, r4
   1a1ba:	f800 3b01 	strb.w	r3, [r0], #1
			i += longest - 1U;
   1a1be:	1e7b      	subs	r3, r7, #1
   1a1c0:	441d      	add	r5, r3
   1a1c2:	b2ed      	uxtb	r5, r5
			needcolon = false;
   1a1c4:	2200      	movs	r2, #0
			continue;
   1a1c6:	e7c3      	b.n	1a150 <z_impl_net_addr_ntop+0xc8>
		if (needcolon) {
   1a1c8:	b112      	cbz	r2, 1a1d0 <z_impl_net_addr_ntop+0x148>
			*ptr++ = ':';
   1a1ca:	233a      	movs	r3, #58	; 0x3a
   1a1cc:	f804 3b01 	strb.w	r3, [r4], #1
		value = (u32_t)sys_be16_to_cpu(UNALIGNED_GET(&w[i]));
   1a1d0:	9b04      	ldr	r3, [sp, #16]
   1a1d2:	f833 3015 	ldrh.w	r3, [r3, r5, lsl #1]
   1a1d6:	021a      	lsls	r2, r3, #8
   1a1d8:	ea42 2213 	orr.w	r2, r2, r3, lsr #8
   1a1dc:	b212      	sxth	r2, r2
		bh = value >> 8;
   1a1de:	f3c2 2307 	ubfx	r3, r2, #8, #8
		bl = value & 0xff;
   1a1e2:	fa5f fb82 	uxtb.w	fp, r2
		if (bh) {
   1a1e6:	b1b3      	cbz	r3, 1a216 <z_impl_net_addr_ntop+0x18e>
			if (bh > 0x0f) {
   1a1e8:	2b0f      	cmp	r3, #15
		bh = value >> 8;
   1a1ea:	b2d9      	uxtb	r1, r3
			if (bh > 0x0f) {
   1a1ec:	d90b      	bls.n	1a206 <z_impl_net_addr_ntop+0x17e>
				ptr = net_byte_to_hex(ptr, bh, 'a', false);
   1a1ee:	2300      	movs	r3, #0
   1a1f0:	2261      	movs	r2, #97	; 0x61
   1a1f2:	4620      	mov	r0, r4
   1a1f4:	f013 fa3f 	bl	2d676 <net_byte_to_hex>
			ptr = net_byte_to_hex(ptr, bl, 'a', true);
   1a1f8:	2301      	movs	r3, #1
   1a1fa:	2261      	movs	r2, #97	; 0x61
   1a1fc:	4659      	mov	r1, fp
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
   1a1fe:	f013 fa3a 	bl	2d676 <net_byte_to_hex>
		needcolon = true;
   1a202:	2201      	movs	r2, #1
   1a204:	e7a4      	b.n	1a150 <z_impl_net_addr_ntop+0xc8>
				if (bh < 10) {
   1a206:	b25b      	sxtb	r3, r3
   1a208:	2909      	cmp	r1, #9
					*ptr++ = (char)(bh + '0');
   1a20a:	bf94      	ite	ls
   1a20c:	3330      	addls	r3, #48	; 0x30
					*ptr++ = (char) (bh - 10 + 'a');
   1a20e:	3357      	addhi	r3, #87	; 0x57
   1a210:	1c60      	adds	r0, r4, #1
   1a212:	7023      	strb	r3, [r4, #0]
   1a214:	e7f0      	b.n	1a1f8 <z_impl_net_addr_ntop+0x170>
		} else if (bl > 0x0f) {
   1a216:	f1bb 0f0f 	cmp.w	fp, #15
   1a21a:	d903      	bls.n	1a224 <z_impl_net_addr_ntop+0x19c>
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
   1a21c:	2261      	movs	r2, #97	; 0x61
   1a21e:	4659      	mov	r1, fp
   1a220:	4620      	mov	r0, r4
   1a222:	e7ec      	b.n	1a1fe <z_impl_net_addr_ntop+0x176>
			if (bl < 10) {
   1a224:	b252      	sxtb	r2, r2
   1a226:	f1bb 0f09 	cmp.w	fp, #9
				*ptr++ = (char)(bl + '0');
   1a22a:	bf94      	ite	ls
   1a22c:	3230      	addls	r2, #48	; 0x30
				*ptr++ = (char) (bl - 10 + 'a');
   1a22e:	3257      	addhi	r2, #87	; 0x57
   1a230:	1c60      	adds	r0, r4, #1
   1a232:	7022      	strb	r2, [r4, #0]
   1a234:	e7e5      	b.n	1a202 <z_impl_net_addr_ntop+0x17a>
   1a236:	bf00      	nop
   1a238:	3b9aca00 	.word	0x3b9aca00

0001a23c <connect_request_encode>:
	return mqtt_encode_fixed_header(message_type, start, buf);
}

int connect_request_encode(const struct mqtt_client *client,
			   struct buf_ctx *buf)
{
   1a23c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	} else {
		mqtt_proto_desc = &mqtt_3_1_0_proto_desc;
	}

	/* Reserve space for fixed header. */
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   1a240:	680f      	ldr	r7, [r1, #0]
	u8_t connect_flags = client->clean_session << 1;
   1a242:	f890 5060 	ldrb.w	r5, [r0, #96]	; 0x60
	start = buf->cur;

	MQTT_TRC("Encoding Protocol Description. Str:%s Size:%08x.",
		 mqtt_proto_desc->utf8, mqtt_proto_desc->size);

	err_code = pack_utf8_str(mqtt_proto_desc, buf);
   1a246:	4b3b      	ldr	r3, [pc, #236]	; (1a334 <connect_request_encode+0xf8>)
   1a248:	4a3b      	ldr	r2, [pc, #236]	; (1a338 <connect_request_encode+0xfc>)
{
   1a24a:	4606      	mov	r6, r0
	if (client->protocol_version == MQTT_VERSION_3_1_1) {
   1a24c:	f890 005e 	ldrb.w	r0, [r0, #94]	; 0x5e
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   1a250:	3705      	adds	r7, #5
	err_code = pack_utf8_str(mqtt_proto_desc, buf);
   1a252:	2804      	cmp	r0, #4
   1a254:	bf0c      	ite	eq
   1a256:	4610      	moveq	r0, r2
   1a258:	4618      	movne	r0, r3
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   1a25a:	600f      	str	r7, [r1, #0]
{
   1a25c:	460c      	mov	r4, r1
	err_code = pack_utf8_str(mqtt_proto_desc, buf);
   1a25e:	f013 faf2 	bl	2d846 <pack_utf8_str>
	u8_t connect_flags = client->clean_session << 1;
   1a262:	f3c5 0540 	ubfx	r5, r5, #1, #1
	if (err_code != 0) {
   1a266:	4603      	mov	r3, r0
   1a268:	b938      	cbnz	r0, 1a27a <connect_request_encode+0x3e>
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   1a26a:	e9d4 2000 	ldrd	r2, r0, [r4]
   1a26e:	4290      	cmp	r0, r2
		return err_code;
	}

	MQTT_TRC("Encoding Protocol Version %02x.", client->protocol_version);
	err_code = pack_uint8(client->protocol_version, buf);
   1a270:	f896 105e 	ldrb.w	r1, [r6, #94]	; 0x5e
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   1a274:	d104      	bne.n	1a280 <connect_request_encode+0x44>
		return -ENOMEM;
   1a276:	f06f 030b 	mvn.w	r3, #11

	/* Write the flags the connect flags. */
	*connect_flags_pos = connect_flags;

	return mqtt_encode_fixed_header(message_type, start, buf);
}
   1a27a:	4618      	mov	r0, r3
   1a27c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	*(buf->cur++) = val;
   1a280:	1c50      	adds	r0, r2, #1
   1a282:	6020      	str	r0, [r4, #0]
   1a284:	7011      	strb	r1, [r2, #0]
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   1a286:	e9d4 8200 	ldrd	r8, r2, [r4]
   1a28a:	4590      	cmp	r8, r2
   1a28c:	d0f3      	beq.n	1a276 <connect_request_encode+0x3a>
	*(buf->cur++) = val;
   1a28e:	f108 0201 	add.w	r2, r8, #1
   1a292:	6022      	str	r2, [r4, #0]
   1a294:	f888 3000 	strb.w	r3, [r8]
	err_code = pack_uint16(client->keepalive, buf);
   1a298:	4621      	mov	r1, r4
   1a29a:	f8b6 005c 	ldrh.w	r0, [r6, #92]	; 0x5c
   1a29e:	f013 fac0 	bl	2d822 <pack_uint16>
	if (err_code != 0) {
   1a2a2:	4603      	mov	r3, r0
   1a2a4:	2800      	cmp	r0, #0
   1a2a6:	d1e8      	bne.n	1a27a <connect_request_encode+0x3e>
	err_code = pack_utf8_str(&client->client_id, buf);
   1a2a8:	f106 002c 	add.w	r0, r6, #44	; 0x2c
   1a2ac:	f013 facb 	bl	2d846 <pack_utf8_str>
	if (err_code != 0) {
   1a2b0:	4603      	mov	r3, r0
   1a2b2:	2800      	cmp	r0, #0
   1a2b4:	d1e1      	bne.n	1a27a <connect_request_encode+0x3e>
	if (client->will_topic != NULL) {
   1a2b6:	6c30      	ldr	r0, [r6, #64]	; 0x40
	u8_t connect_flags = client->clean_session << 1;
   1a2b8:	006d      	lsls	r5, r5, #1
	if (client->will_topic != NULL) {
   1a2ba:	b1d8      	cbz	r0, 1a2f4 <connect_request_encode+0xb8>
		connect_flags |= client->will_retain << 5;
   1a2bc:	f896 3060 	ldrb.w	r3, [r6, #96]	; 0x60
		connect_flags |= MQTT_CONNECT_FLAG_WILL_TOPIC;
   1a2c0:	f045 0504 	orr.w	r5, r5, #4
		connect_flags |= client->will_retain << 5;
   1a2c4:	f003 0301 	and.w	r3, r3, #1
   1a2c8:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
		connect_flags |= ((client->will_topic->qos & 0x03) << 3);
   1a2cc:	7a03      	ldrb	r3, [r0, #8]
		err_code = pack_utf8_str(&client->will_topic->topic, buf);
   1a2ce:	4621      	mov	r1, r4
		connect_flags |= ((client->will_topic->qos & 0x03) << 3);
   1a2d0:	00db      	lsls	r3, r3, #3
   1a2d2:	f003 0318 	and.w	r3, r3, #24
		connect_flags |= client->will_retain << 5;
   1a2d6:	431d      	orrs	r5, r3
		err_code = pack_utf8_str(&client->will_topic->topic, buf);
   1a2d8:	f013 fab5 	bl	2d846 <pack_utf8_str>
		if (err_code != 0) {
   1a2dc:	4603      	mov	r3, r0
   1a2de:	2800      	cmp	r0, #0
   1a2e0:	d1cb      	bne.n	1a27a <connect_request_encode+0x3e>
		if (client->will_message != NULL) {
   1a2e2:	6c73      	ldr	r3, [r6, #68]	; 0x44
			err_code = pack_utf8_str(client->will_message, buf);
   1a2e4:	4621      	mov	r1, r4
		if (client->will_message != NULL) {
   1a2e6:	b313      	cbz	r3, 1a32e <connect_request_encode+0xf2>
			err_code = pack_utf8_str(client->will_message, buf);
   1a2e8:	4618      	mov	r0, r3
   1a2ea:	f013 faac 	bl	2d846 <pack_utf8_str>
			if (err_code != 0) {
   1a2ee:	4603      	mov	r3, r0
   1a2f0:	2800      	cmp	r0, #0
   1a2f2:	d1c2      	bne.n	1a27a <connect_request_encode+0x3e>
	if (client->user_name != NULL) {
   1a2f4:	6bb0      	ldr	r0, [r6, #56]	; 0x38
   1a2f6:	b138      	cbz	r0, 1a308 <connect_request_encode+0xcc>
		err_code = pack_utf8_str(client->user_name, buf);
   1a2f8:	4621      	mov	r1, r4
   1a2fa:	f013 faa4 	bl	2d846 <pack_utf8_str>
		if (err_code != 0) {
   1a2fe:	4603      	mov	r3, r0
   1a300:	2800      	cmp	r0, #0
   1a302:	d1ba      	bne.n	1a27a <connect_request_encode+0x3e>
		connect_flags |= MQTT_CONNECT_FLAG_USERNAME;
   1a304:	f045 0580 	orr.w	r5, r5, #128	; 0x80
	if (client->password != NULL) {
   1a308:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
   1a30a:	b138      	cbz	r0, 1a31c <connect_request_encode+0xe0>
		err_code = pack_utf8_str(client->password, buf);
   1a30c:	4621      	mov	r1, r4
   1a30e:	f013 fa9a 	bl	2d846 <pack_utf8_str>
		if (err_code != 0) {
   1a312:	4603      	mov	r3, r0
   1a314:	2800      	cmp	r0, #0
   1a316:	d1b0      	bne.n	1a27a <connect_request_encode+0x3e>
		connect_flags |= MQTT_CONNECT_FLAG_PASSWORD;
   1a318:	f045 0540 	orr.w	r5, r5, #64	; 0x40
	*connect_flags_pos = connect_flags;
   1a31c:	f888 5000 	strb.w	r5, [r8]
	return mqtt_encode_fixed_header(message_type, start, buf);
   1a320:	4622      	mov	r2, r4
   1a322:	4639      	mov	r1, r7
}
   1a324:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return mqtt_encode_fixed_header(message_type, start, buf);
   1a328:	2010      	movs	r0, #16
   1a32a:	f013 baa7 	b.w	2d87c <mqtt_encode_fixed_header>
	return pack_uint16(0x0000, buf);
   1a32e:	f013 fa78 	bl	2d822 <pack_uint16>
   1a332:	e7dc      	b.n	1a2ee <connect_request_encode+0xb2>
   1a334:	00030a04 	.word	0x00030a04
   1a338:	00030a0c 	.word	0x00030a0c

0001a33c <disconnect_encode>:
	return mqtt_message_id_only_enc(message_type, param->message_id, buf);
}

int disconnect_encode(struct buf_ctx *buf)
{
	if (buf->end - buf->cur < sizeof(disc_packet)) {
   1a33c:	e9d0 2300 	ldrd	r2, r3, [r0]
   1a340:	1a9b      	subs	r3, r3, r2
   1a342:	2b01      	cmp	r3, #1
   1a344:	bf81      	itttt	hi
   1a346:	4b05      	ldrhi	r3, [pc, #20]	; (1a35c <disconnect_encode+0x20>)
   1a348:	881b      	ldrhhi	r3, [r3, #0]
   1a34a:	8013      	strhhi	r3, [r2, #0]
		return -ENOMEM;
	}

	memcpy(buf->cur, disc_packet, sizeof(disc_packet));
	buf->end = buf->cur + sizeof(disc_packet);
   1a34c:	6803      	ldrhi	r3, [r0, #0]
   1a34e:	bf83      	ittte	hi
   1a350:	3302      	addhi	r3, #2
   1a352:	6043      	strhi	r3, [r0, #4]

	return 0;
   1a354:	2000      	movhi	r0, #0
		return -ENOMEM;
   1a356:	f06f 000b 	mvnls.w	r0, #11
}
   1a35a:	4770      	bx	lr
   1a35c:	000332a0 	.word	0x000332a0

0001a360 <ping_request_encode>:
	return mqtt_encode_fixed_header(message_type, start, buf);
}

int ping_request_encode(struct buf_ctx *buf)
{
	if (buf->end - buf->cur < sizeof(ping_packet)) {
   1a360:	e9d0 2300 	ldrd	r2, r3, [r0]
   1a364:	1a9b      	subs	r3, r3, r2
   1a366:	2b01      	cmp	r3, #1
   1a368:	bf81      	itttt	hi
   1a36a:	4b05      	ldrhi	r3, [pc, #20]	; (1a380 <ping_request_encode+0x20>)
   1a36c:	881b      	ldrhhi	r3, [r3, #0]
   1a36e:	8013      	strhhi	r3, [r2, #0]
		return -ENOMEM;
	}

	memcpy(buf->cur, ping_packet, sizeof(ping_packet));
	buf->end = buf->cur + sizeof(ping_packet);
   1a370:	6803      	ldrhi	r3, [r0, #0]
   1a372:	bf83      	ittte	hi
   1a374:	3302      	addhi	r3, #2
   1a376:	6043      	strhi	r3, [r0, #4]

	return 0;
   1a378:	2000      	movhi	r0, #0
		return -ENOMEM;
   1a37a:	f06f 000b 	mvnls.w	r0, #11
}
   1a37e:	4770      	bx	lr
   1a380:	000332ac 	.word	0x000332ac

0001a384 <close>:
{
   1a384:	b570      	push	{r4, r5, r6, lr}
	__ASSERT_NO_MSG(socket_ops);
   1a386:	4c10      	ldr	r4, [pc, #64]	; (1a3c8 <close+0x44>)
{
   1a388:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(socket_ops);
   1a38a:	6823      	ldr	r3, [r4, #0]
   1a38c:	b94b      	cbnz	r3, 1a3a2 <close+0x1e>
   1a38e:	490f      	ldr	r1, [pc, #60]	; (1a3cc <close+0x48>)
   1a390:	480f      	ldr	r0, [pc, #60]	; (1a3d0 <close+0x4c>)
   1a392:	2321      	movs	r3, #33	; 0x21
   1a394:	4a0f      	ldr	r2, [pc, #60]	; (1a3d4 <close+0x50>)
   1a396:	f012 ff58 	bl	2d24a <printk>
   1a39a:	2121      	movs	r1, #33	; 0x21
   1a39c:	480d      	ldr	r0, [pc, #52]	; (1a3d4 <close+0x50>)
   1a39e:	f012 ff9a 	bl	2d2d6 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->close);
   1a3a2:	6823      	ldr	r3, [r4, #0]
   1a3a4:	685b      	ldr	r3, [r3, #4]
   1a3a6:	b94b      	cbnz	r3, 1a3bc <close+0x38>
   1a3a8:	490b      	ldr	r1, [pc, #44]	; (1a3d8 <close+0x54>)
   1a3aa:	4809      	ldr	r0, [pc, #36]	; (1a3d0 <close+0x4c>)
   1a3ac:	2322      	movs	r3, #34	; 0x22
   1a3ae:	4a09      	ldr	r2, [pc, #36]	; (1a3d4 <close+0x50>)
   1a3b0:	f012 ff4b 	bl	2d24a <printk>
   1a3b4:	2122      	movs	r1, #34	; 0x22
   1a3b6:	4807      	ldr	r0, [pc, #28]	; (1a3d4 <close+0x50>)
   1a3b8:	f012 ff8d 	bl	2d2d6 <assert_post_action>
	return socket_ops->close(sock);
   1a3bc:	6823      	ldr	r3, [r4, #0]
   1a3be:	4628      	mov	r0, r5
}
   1a3c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return socket_ops->close(sock);
   1a3c4:	685b      	ldr	r3, [r3, #4]
   1a3c6:	4718      	bx	r3
   1a3c8:	20028668 	.word	0x20028668
   1a3cc:	00031ad5 	.word	0x00031ad5
   1a3d0:	000311a3 	.word	0x000311a3
   1a3d4:	00031aa5 	.word	0x00031aa5
   1a3d8:	000332ae 	.word	0x000332ae

0001a3dc <mqtt_client_tcp_connect>:
#include <net/mqtt.h>

#include "mqtt_os.h"

int mqtt_client_tcp_connect(struct mqtt_client *client)
{
   1a3dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(socket_ops);
   1a3e0:	4c2d      	ldr	r4, [pc, #180]	; (1a498 <mqtt_client_tcp_connect+0xbc>)
	const struct sockaddr *broker = client->broker;
   1a3e2:	6b45      	ldr	r5, [r0, #52]	; 0x34
   1a3e4:	6823      	ldr	r3, [r4, #0]
{
   1a3e6:	4606      	mov	r6, r0
	int ret;

	client->transport.tcp.sock = socket(broker->sa_family, SOCK_STREAM,
   1a3e8:	882f      	ldrh	r7, [r5, #0]
   1a3ea:	b94b      	cbnz	r3, 1a400 <mqtt_client_tcp_connect+0x24>
   1a3ec:	492b      	ldr	r1, [pc, #172]	; (1a49c <mqtt_client_tcp_connect+0xc0>)
   1a3ee:	482c      	ldr	r0, [pc, #176]	; (1a4a0 <mqtt_client_tcp_connect+0xc4>)
   1a3f0:	2319      	movs	r3, #25
   1a3f2:	4a2c      	ldr	r2, [pc, #176]	; (1a4a4 <mqtt_client_tcp_connect+0xc8>)
   1a3f4:	f012 ff29 	bl	2d24a <printk>
   1a3f8:	2119      	movs	r1, #25
   1a3fa:	482a      	ldr	r0, [pc, #168]	; (1a4a4 <mqtt_client_tcp_connect+0xc8>)
   1a3fc:	f012 ff6b 	bl	2d2d6 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->socket);
   1a400:	6823      	ldr	r3, [r4, #0]
   1a402:	681b      	ldr	r3, [r3, #0]
   1a404:	b94b      	cbnz	r3, 1a41a <mqtt_client_tcp_connect+0x3e>
   1a406:	4928      	ldr	r1, [pc, #160]	; (1a4a8 <mqtt_client_tcp_connect+0xcc>)
   1a408:	4825      	ldr	r0, [pc, #148]	; (1a4a0 <mqtt_client_tcp_connect+0xc4>)
   1a40a:	231a      	movs	r3, #26
   1a40c:	4a25      	ldr	r2, [pc, #148]	; (1a4a4 <mqtt_client_tcp_connect+0xc8>)
   1a40e:	f012 ff1c 	bl	2d24a <printk>
   1a412:	211a      	movs	r1, #26
   1a414:	4823      	ldr	r0, [pc, #140]	; (1a4a4 <mqtt_client_tcp_connect+0xc8>)
   1a416:	f012 ff5e 	bl	2d2d6 <assert_post_action>
	return socket_ops->socket(family, type, proto);
   1a41a:	6823      	ldr	r3, [r4, #0]
   1a41c:	4638      	mov	r0, r7
   1a41e:	681b      	ldr	r3, [r3, #0]
   1a420:	2206      	movs	r2, #6
   1a422:	2101      	movs	r1, #1
   1a424:	4798      	blx	r3
					    IPPROTO_TCP);
	if (client->transport.tcp.sock < 0) {
   1a426:	2800      	cmp	r0, #0
   1a428:	4607      	mov	r7, r0
	client->transport.tcp.sock = socket(broker->sa_family, SOCK_STREAM,
   1a42a:	62b0      	str	r0, [r6, #40]	; 0x28
	if (client->transport.tcp.sock < 0) {
   1a42c:	da05      	bge.n	1a43a <mqtt_client_tcp_connect+0x5e>

	ret = connect(client->transport.tcp.sock, client->broker,
		      peer_addr_size);
	if (ret < 0) {
		(void)close(client->transport.tcp.sock);
		return -errno;
   1a42e:	f013 f907 	bl	2d640 <__errno>
   1a432:	6800      	ldr	r0, [r0, #0]
   1a434:	4240      	negs	r0, r0
	}

	MQTT_TRC("Connect completed");
	return 0;
}
   1a436:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (broker->sa_family == AF_INET) {
   1a43a:	882b      	ldrh	r3, [r5, #0]
	ret = connect(client->transport.tcp.sock, client->broker,
   1a43c:	6b75      	ldr	r5, [r6, #52]	; 0x34
		peer_addr_size = sizeof(struct sockaddr_in);
   1a43e:	2b01      	cmp	r3, #1
	__ASSERT_NO_MSG(socket_ops);
   1a440:	6823      	ldr	r3, [r4, #0]
   1a442:	bf14      	ite	ne
   1a444:	f04f 0818 	movne.w	r8, #24
   1a448:	f04f 0808 	moveq.w	r8, #8
   1a44c:	b94b      	cbnz	r3, 1a462 <mqtt_client_tcp_connect+0x86>
   1a44e:	4913      	ldr	r1, [pc, #76]	; (1a49c <mqtt_client_tcp_connect+0xc0>)
   1a450:	4813      	ldr	r0, [pc, #76]	; (1a4a0 <mqtt_client_tcp_connect+0xc4>)
   1a452:	2345      	movs	r3, #69	; 0x45
   1a454:	4a13      	ldr	r2, [pc, #76]	; (1a4a4 <mqtt_client_tcp_connect+0xc8>)
   1a456:	f012 fef8 	bl	2d24a <printk>
   1a45a:	2145      	movs	r1, #69	; 0x45
   1a45c:	4811      	ldr	r0, [pc, #68]	; (1a4a4 <mqtt_client_tcp_connect+0xc8>)
   1a45e:	f012 ff3a 	bl	2d2d6 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->connect);
   1a462:	6823      	ldr	r3, [r4, #0]
   1a464:	695b      	ldr	r3, [r3, #20]
   1a466:	b94b      	cbnz	r3, 1a47c <mqtt_client_tcp_connect+0xa0>
   1a468:	4910      	ldr	r1, [pc, #64]	; (1a4ac <mqtt_client_tcp_connect+0xd0>)
   1a46a:	480d      	ldr	r0, [pc, #52]	; (1a4a0 <mqtt_client_tcp_connect+0xc4>)
   1a46c:	2346      	movs	r3, #70	; 0x46
   1a46e:	4a0d      	ldr	r2, [pc, #52]	; (1a4a4 <mqtt_client_tcp_connect+0xc8>)
   1a470:	f012 feeb 	bl	2d24a <printk>
   1a474:	2146      	movs	r1, #70	; 0x46
   1a476:	480b      	ldr	r0, [pc, #44]	; (1a4a4 <mqtt_client_tcp_connect+0xc8>)
   1a478:	f012 ff2d 	bl	2d2d6 <assert_post_action>
	return socket_ops->connect(sock, addr, addrlen);
   1a47c:	6823      	ldr	r3, [r4, #0]
   1a47e:	4642      	mov	r2, r8
   1a480:	695b      	ldr	r3, [r3, #20]
   1a482:	4629      	mov	r1, r5
   1a484:	4638      	mov	r0, r7
   1a486:	4798      	blx	r3
	if (ret < 0) {
   1a488:	2800      	cmp	r0, #0
   1a48a:	da03      	bge.n	1a494 <mqtt_client_tcp_connect+0xb8>
		(void)close(client->transport.tcp.sock);
   1a48c:	6ab0      	ldr	r0, [r6, #40]	; 0x28
   1a48e:	f7ff ff79 	bl	1a384 <close>
   1a492:	e7cc      	b.n	1a42e <mqtt_client_tcp_connect+0x52>
	return 0;
   1a494:	2000      	movs	r0, #0
   1a496:	e7ce      	b.n	1a436 <mqtt_client_tcp_connect+0x5a>
   1a498:	20028668 	.word	0x20028668
   1a49c:	00031ad5 	.word	0x00031ad5
   1a4a0:	000311a3 	.word	0x000311a3
   1a4a4:	00031aa5 	.word	0x00031aa5
   1a4a8:	000332c0 	.word	0x000332c0
   1a4ac:	000332d3 	.word	0x000332d3

0001a4b0 <mqtt_client_tcp_write>:

int mqtt_client_tcp_write(struct mqtt_client *client, const u8_t *data,
			  u32_t datalen)
{
   1a4b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a4b4:	4680      	mov	r8, r0
   1a4b6:	4689      	mov	r9, r1
   1a4b8:	4617      	mov	r7, r2
	u32_t offset = 0U;
   1a4ba:	2400      	movs	r4, #0
	__ASSERT_NO_MSG(socket_ops);
   1a4bc:	4d1d      	ldr	r5, [pc, #116]	; (1a534 <mqtt_client_tcp_write+0x84>)
	int ret;

	while (offset < datalen) {
   1a4be:	42bc      	cmp	r4, r7
   1a4c0:	d301      	bcc.n	1a4c6 <mqtt_client_tcp_write+0x16>
		}

		offset += ret;
	}

	return 0;
   1a4c2:	2000      	movs	r0, #0
   1a4c4:	e031      	b.n	1a52a <mqtt_client_tcp_write+0x7a>
		ret = send(client->transport.tcp.sock, data + offset,
   1a4c6:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
   1a4ca:	eb09 0a04 	add.w	sl, r9, r4
   1a4ce:	461e      	mov	r6, r3
   1a4d0:	4b19      	ldr	r3, [pc, #100]	; (1a538 <mqtt_client_tcp_write+0x88>)
   1a4d2:	eba7 0b04 	sub.w	fp, r7, r4
   1a4d6:	681b      	ldr	r3, [r3, #0]
   1a4d8:	b94b      	cbnz	r3, 1a4ee <mqtt_client_tcp_write+0x3e>
   1a4da:	4918      	ldr	r1, [pc, #96]	; (1a53c <mqtt_client_tcp_write+0x8c>)
   1a4dc:	4818      	ldr	r0, [pc, #96]	; (1a540 <mqtt_client_tcp_write+0x90>)
   1a4de:	237e      	movs	r3, #126	; 0x7e
   1a4e0:	462a      	mov	r2, r5
   1a4e2:	f012 feb2 	bl	2d24a <printk>
   1a4e6:	217e      	movs	r1, #126	; 0x7e
   1a4e8:	4628      	mov	r0, r5
   1a4ea:	f012 fef4 	bl	2d2d6 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->send);
   1a4ee:	4b12      	ldr	r3, [pc, #72]	; (1a538 <mqtt_client_tcp_write+0x88>)
   1a4f0:	681b      	ldr	r3, [r3, #0]
   1a4f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1a4f4:	b94b      	cbnz	r3, 1a50a <mqtt_client_tcp_write+0x5a>
   1a4f6:	4913      	ldr	r1, [pc, #76]	; (1a544 <mqtt_client_tcp_write+0x94>)
   1a4f8:	4811      	ldr	r0, [pc, #68]	; (1a540 <mqtt_client_tcp_write+0x90>)
   1a4fa:	237f      	movs	r3, #127	; 0x7f
   1a4fc:	462a      	mov	r2, r5
   1a4fe:	f012 fea4 	bl	2d24a <printk>
   1a502:	217f      	movs	r1, #127	; 0x7f
   1a504:	4628      	mov	r0, r5
   1a506:	f012 fee6 	bl	2d2d6 <assert_post_action>
	return socket_ops->send(sock, buf, len, flags);
   1a50a:	4b0b      	ldr	r3, [pc, #44]	; (1a538 <mqtt_client_tcp_write+0x88>)
   1a50c:	4630      	mov	r0, r6
   1a50e:	681b      	ldr	r3, [r3, #0]
   1a510:	465a      	mov	r2, fp
   1a512:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1a514:	4651      	mov	r1, sl
   1a516:	469c      	mov	ip, r3
   1a518:	2300      	movs	r3, #0
   1a51a:	4666      	mov	r6, ip
   1a51c:	47b0      	blx	r6
		if (ret < 0) {
   1a51e:	2800      	cmp	r0, #0
   1a520:	da05      	bge.n	1a52e <mqtt_client_tcp_write+0x7e>
			return -errno;
   1a522:	f013 f88d 	bl	2d640 <__errno>
   1a526:	6800      	ldr	r0, [r0, #0]
   1a528:	4240      	negs	r0, r0
}
   1a52a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		offset += ret;
   1a52e:	4404      	add	r4, r0
   1a530:	e7c5      	b.n	1a4be <mqtt_client_tcp_write+0xe>
   1a532:	bf00      	nop
   1a534:	00031aa5 	.word	0x00031aa5
   1a538:	20028668 	.word	0x20028668
   1a53c:	00031ad5 	.word	0x00031ad5
   1a540:	000311a3 	.word	0x000311a3
   1a544:	000332f8 	.word	0x000332f8

0001a548 <mqtt_client_tcp_read>:

int mqtt_client_tcp_read(struct mqtt_client *client, u8_t *data, u32_t buflen,
			 bool shall_block)
{
   1a548:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(socket_ops);
   1a54c:	4c18      	ldr	r4, [pc, #96]	; (1a5b0 <mqtt_client_tcp_read+0x68>)
	int flags = 0;
	int ret;

	if (!shall_block) {
		flags |= MSG_DONTWAIT;
   1a54e:	2b00      	cmp	r3, #0
   1a550:	6823      	ldr	r3, [r4, #0]
{
   1a552:	460e      	mov	r6, r1
   1a554:	4617      	mov	r7, r2
		flags |= MSG_DONTWAIT;
   1a556:	bf14      	ite	ne
   1a558:	f04f 0800 	movne.w	r8, #0
   1a55c:	f04f 0840 	moveq.w	r8, #64	; 0x40
	}

	ret = recv(client->transport.tcp.sock, data, buflen, flags);
   1a560:	6a85      	ldr	r5, [r0, #40]	; 0x28
   1a562:	b94b      	cbnz	r3, 1a578 <mqtt_client_tcp_read+0x30>
   1a564:	4913      	ldr	r1, [pc, #76]	; (1a5b4 <mqtt_client_tcp_read+0x6c>)
   1a566:	4814      	ldr	r0, [pc, #80]	; (1a5b8 <mqtt_client_tcp_read+0x70>)
   1a568:	2369      	movs	r3, #105	; 0x69
   1a56a:	4a14      	ldr	r2, [pc, #80]	; (1a5bc <mqtt_client_tcp_read+0x74>)
   1a56c:	f012 fe6d 	bl	2d24a <printk>
   1a570:	2169      	movs	r1, #105	; 0x69
   1a572:	4812      	ldr	r0, [pc, #72]	; (1a5bc <mqtt_client_tcp_read+0x74>)
   1a574:	f012 feaf 	bl	2d2d6 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->recv);
   1a578:	6823      	ldr	r3, [r4, #0]
   1a57a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1a57c:	b94b      	cbnz	r3, 1a592 <mqtt_client_tcp_read+0x4a>
   1a57e:	4910      	ldr	r1, [pc, #64]	; (1a5c0 <mqtt_client_tcp_read+0x78>)
   1a580:	480d      	ldr	r0, [pc, #52]	; (1a5b8 <mqtt_client_tcp_read+0x70>)
   1a582:	236a      	movs	r3, #106	; 0x6a
   1a584:	4a0d      	ldr	r2, [pc, #52]	; (1a5bc <mqtt_client_tcp_read+0x74>)
   1a586:	f012 fe60 	bl	2d24a <printk>
   1a58a:	216a      	movs	r1, #106	; 0x6a
   1a58c:	480b      	ldr	r0, [pc, #44]	; (1a5bc <mqtt_client_tcp_read+0x74>)
   1a58e:	f012 fea2 	bl	2d2d6 <assert_post_action>
	return socket_ops->recv(sock, buf, max_len, flags);
   1a592:	6823      	ldr	r3, [r4, #0]
   1a594:	463a      	mov	r2, r7
   1a596:	6a5c      	ldr	r4, [r3, #36]	; 0x24
   1a598:	4631      	mov	r1, r6
   1a59a:	4643      	mov	r3, r8
   1a59c:	4628      	mov	r0, r5
   1a59e:	47a0      	blx	r4
	if (ret < 0) {
   1a5a0:	2800      	cmp	r0, #0
   1a5a2:	da03      	bge.n	1a5ac <mqtt_client_tcp_read+0x64>
		return -errno;
   1a5a4:	f013 f84c 	bl	2d640 <__errno>
   1a5a8:	6800      	ldr	r0, [r0, #0]
   1a5aa:	4240      	negs	r0, r0
	}

	return ret;
}
   1a5ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1a5b0:	20028668 	.word	0x20028668
   1a5b4:	00031ad5 	.word	0x00031ad5
   1a5b8:	000311a3 	.word	0x000311a3
   1a5bc:	00031aa5 	.word	0x00031aa5
   1a5c0:	000332e7 	.word	0x000332e7

0001a5c4 <mqtt_transport_connect>:
#endif /* CONFIG_MQTT_LIB_WEBSOCKET */
};

int mqtt_transport_connect(struct mqtt_client *client)
{
	return transport_fn[client->transport.type].connect(client);
   1a5c4:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
   1a5c8:	4a01      	ldr	r2, [pc, #4]	; (1a5d0 <mqtt_transport_connect+0xc>)
   1a5ca:	011b      	lsls	r3, r3, #4
   1a5cc:	58d3      	ldr	r3, [r2, r3]
   1a5ce:	4718      	bx	r3
   1a5d0:	00030a14 	.word	0x00030a14

0001a5d4 <mqtt_transport_write>:
}

int mqtt_transport_write(struct mqtt_client *client, const u8_t *data,
			 u32_t datalen)
{
   1a5d4:	b410      	push	{r4}
	return transport_fn[client->transport.type].write(client, data,
   1a5d6:	4b04      	ldr	r3, [pc, #16]	; (1a5e8 <mqtt_transport_write+0x14>)
   1a5d8:	f890 4024 	ldrb.w	r4, [r0, #36]	; 0x24
   1a5dc:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   1a5e0:	685b      	ldr	r3, [r3, #4]
							  datalen);
}
   1a5e2:	f85d 4b04 	ldr.w	r4, [sp], #4
	return transport_fn[client->transport.type].write(client, data,
   1a5e6:	4718      	bx	r3
   1a5e8:	00030a14 	.word	0x00030a14

0001a5ec <mqtt_transport_read>:

int mqtt_transport_read(struct mqtt_client *client, u8_t *data, u32_t buflen,
			bool shall_block)
{
   1a5ec:	b430      	push	{r4, r5}
	return transport_fn[client->transport.type].read(client, data, buflen,
   1a5ee:	f890 5024 	ldrb.w	r5, [r0, #36]	; 0x24
   1a5f2:	4c03      	ldr	r4, [pc, #12]	; (1a600 <mqtt_transport_read+0x14>)
   1a5f4:	eb04 1405 	add.w	r4, r4, r5, lsl #4
   1a5f8:	68a4      	ldr	r4, [r4, #8]
   1a5fa:	46a4      	mov	ip, r4
							 shall_block);
}
   1a5fc:	bc30      	pop	{r4, r5}
	return transport_fn[client->transport.type].read(client, data, buflen,
   1a5fe:	4760      	bx	ip
   1a600:	00030a14 	.word	0x00030a14

0001a604 <mqtt_mutex_unlock>:
	return k_mutex_lock(&mutex->kernel_mutex, timeout);
}

static inline int sys_mutex_unlock(struct sys_mutex *mutex)
{
	if (mutex->kernel_mutex.lock_count == 0) {
   1a604:	68c2      	ldr	r2, [r0, #12]
}

/**@brief Release the lock on the module specific mutex, if any.
 */
static inline void mqtt_mutex_unlock(struct mqtt_client *client)
{
   1a606:	b510      	push	{r4, lr}
   1a608:	b142      	cbz	r2, 1a61c <mqtt_mutex_unlock+0x18>
		return -EINVAL;
	}

	if (mutex->kernel_mutex.owner != _current) {
   1a60a:	4b0f      	ldr	r3, [pc, #60]	; (1a648 <mqtt_mutex_unlock+0x44>)
   1a60c:	6882      	ldr	r2, [r0, #8]
   1a60e:	689b      	ldr	r3, [r3, #8]
   1a610:	429a      	cmp	r2, r3
   1a612:	d115      	bne.n	1a640 <mqtt_mutex_unlock+0x3c>
	int ret = sys_mutex_unlock(&client->internal.mutex);

	__ASSERT(ret == 0, "sys_mutex_unlock failed with %d", ret);
	(void)ret;
}
   1a614:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1a618:	f00c bb98 	b.w	26d4c <z_impl_k_mutex_unlock>
		return -EINVAL;
   1a61c:	f06f 0415 	mvn.w	r4, #21
	__ASSERT(ret == 0, "sys_mutex_unlock failed with %d", ret);
   1a620:	2343      	movs	r3, #67	; 0x43
   1a622:	4a0a      	ldr	r2, [pc, #40]	; (1a64c <mqtt_mutex_unlock+0x48>)
   1a624:	490a      	ldr	r1, [pc, #40]	; (1a650 <mqtt_mutex_unlock+0x4c>)
   1a626:	480b      	ldr	r0, [pc, #44]	; (1a654 <mqtt_mutex_unlock+0x50>)
   1a628:	f012 fe0f 	bl	2d24a <printk>
   1a62c:	4621      	mov	r1, r4
   1a62e:	480a      	ldr	r0, [pc, #40]	; (1a658 <mqtt_mutex_unlock+0x54>)
   1a630:	f012 fe0b 	bl	2d24a <printk>
}
   1a634:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__ASSERT(ret == 0, "sys_mutex_unlock failed with %d", ret);
   1a638:	2143      	movs	r1, #67	; 0x43
   1a63a:	4804      	ldr	r0, [pc, #16]	; (1a64c <mqtt_mutex_unlock+0x48>)
   1a63c:	f012 be4b 	b.w	2d2d6 <assert_post_action>
		return -EPERM;
   1a640:	f04f 34ff 	mov.w	r4, #4294967295
   1a644:	e7ec      	b.n	1a620 <mqtt_mutex_unlock+0x1c>
   1a646:	bf00      	nop
   1a648:	2002d2e8 	.word	0x2002d2e8
   1a64c:	00033329 	.word	0x00033329
   1a650:	0003335a 	.word	0x0003335a
   1a654:	000311a3 	.word	0x000311a3
   1a658:	00033363 	.word	0x00033363

0001a65c <mqtt_mutex_lock>:
{
   1a65c:	b510      	push	{r4, lr}
	return z_impl_k_mutex_lock(mutex, timeout);
   1a65e:	f04f 31ff 	mov.w	r1, #4294967295
   1a662:	f00c fa95 	bl	26b90 <z_impl_k_mutex_lock>
	__ASSERT(ret == 0, "sys_mutex_lock failed with %d", ret);
   1a666:	4604      	mov	r4, r0
   1a668:	b178      	cbz	r0, 1a68a <mqtt_mutex_lock+0x2e>
   1a66a:	2339      	movs	r3, #57	; 0x39
   1a66c:	4a07      	ldr	r2, [pc, #28]	; (1a68c <mqtt_mutex_lock+0x30>)
   1a66e:	4908      	ldr	r1, [pc, #32]	; (1a690 <mqtt_mutex_lock+0x34>)
   1a670:	4808      	ldr	r0, [pc, #32]	; (1a694 <mqtt_mutex_lock+0x38>)
   1a672:	f012 fdea 	bl	2d24a <printk>
   1a676:	4621      	mov	r1, r4
   1a678:	4807      	ldr	r0, [pc, #28]	; (1a698 <mqtt_mutex_lock+0x3c>)
   1a67a:	f012 fde6 	bl	2d24a <printk>
}
   1a67e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__ASSERT(ret == 0, "sys_mutex_lock failed with %d", ret);
   1a682:	2139      	movs	r1, #57	; 0x39
   1a684:	4801      	ldr	r0, [pc, #4]	; (1a68c <mqtt_mutex_lock+0x30>)
   1a686:	f012 be26 	b.w	2d2d6 <assert_post_action>
}
   1a68a:	bd10      	pop	{r4, pc}
   1a68c:	00033329 	.word	0x00033329
   1a690:	0003335a 	.word	0x0003335a
   1a694:	000311a3 	.word	0x000311a3
   1a698:	00033309 	.word	0x00033309

0001a69c <z_impl_entropy_get_entropy>:
				  u16_t length);

static inline int z_impl_entropy_get_entropy(struct device *dev,
					    u8_t *buffer,
					    u16_t length)
{
   1a69c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct entropy_driver_api *api =
   1a6a0:	6845      	ldr	r5, [r0, #4]
{
   1a6a2:	4604      	mov	r4, r0
		(const struct entropy_driver_api *)dev->driver_api;

	__ASSERT(api->get_entropy != NULL,
   1a6a4:	682b      	ldr	r3, [r5, #0]
{
   1a6a6:	460e      	mov	r6, r1
   1a6a8:	4617      	mov	r7, r2
	__ASSERT(api->get_entropy != NULL,
   1a6aa:	b963      	cbnz	r3, 1a6c6 <z_impl_entropy_get_entropy+0x2a>
   1a6ac:	4909      	ldr	r1, [pc, #36]	; (1a6d4 <z_impl_entropy_get_entropy+0x38>)
   1a6ae:	234c      	movs	r3, #76	; 0x4c
   1a6b0:	4a09      	ldr	r2, [pc, #36]	; (1a6d8 <z_impl_entropy_get_entropy+0x3c>)
   1a6b2:	480a      	ldr	r0, [pc, #40]	; (1a6dc <z_impl_entropy_get_entropy+0x40>)
   1a6b4:	f012 fdc9 	bl	2d24a <printk>
   1a6b8:	4809      	ldr	r0, [pc, #36]	; (1a6e0 <z_impl_entropy_get_entropy+0x44>)
   1a6ba:	f012 fdc6 	bl	2d24a <printk>
   1a6be:	214c      	movs	r1, #76	; 0x4c
   1a6c0:	4805      	ldr	r0, [pc, #20]	; (1a6d8 <z_impl_entropy_get_entropy+0x3c>)
   1a6c2:	f012 fe08 	bl	2d2d6 <assert_post_action>
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
   1a6c6:	682b      	ldr	r3, [r5, #0]
   1a6c8:	463a      	mov	r2, r7
   1a6ca:	4631      	mov	r1, r6
   1a6cc:	4620      	mov	r0, r4
}
   1a6ce:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return api->get_entropy(dev, buffer, length);
   1a6d2:	4718      	bx	r3
   1a6d4:	00033462 	.word	0x00033462
   1a6d8:	00033435 	.word	0x00033435
   1a6dc:	000311a3 	.word	0x000311a3
   1a6e0:	00033482 	.word	0x00033482

0001a6e4 <sys_rand32_get>:

static struct device *entropy_driver;

#if defined(CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR)
u32_t sys_rand32_get(void)
{
   1a6e4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct device *dev = entropy_driver;
   1a6e6:	4d12      	ldr	r5, [pc, #72]	; (1a730 <sys_rand32_get+0x4c>)
   1a6e8:	682c      	ldr	r4, [r5, #0]
	u32_t random_num;
	int ret;

	if (unlikely(!dev)) {
   1a6ea:	b99c      	cbnz	r4, 1a714 <sys_rand32_get+0x30>
   1a6ec:	4811      	ldr	r0, [pc, #68]	; (1a734 <sys_rand32_get+0x50>)
   1a6ee:	f00b fd6b 	bl	261c8 <z_impl_device_get_binding>
		/* Only one entropy device exists, so this is safe even
		 * if the whole operation isn't atomic.
		 */
		dev = device_get_binding(CONFIG_ENTROPY_NAME);
		__ASSERT((dev != NULL),
   1a6f2:	4604      	mov	r4, r0
   1a6f4:	b968      	cbnz	r0, 1a712 <sys_rand32_get+0x2e>
   1a6f6:	231d      	movs	r3, #29
   1a6f8:	4a0f      	ldr	r2, [pc, #60]	; (1a738 <sys_rand32_get+0x54>)
   1a6fa:	4910      	ldr	r1, [pc, #64]	; (1a73c <sys_rand32_get+0x58>)
   1a6fc:	4810      	ldr	r0, [pc, #64]	; (1a740 <sys_rand32_get+0x5c>)
   1a6fe:	f012 fda4 	bl	2d24a <printk>
   1a702:	490c      	ldr	r1, [pc, #48]	; (1a734 <sys_rand32_get+0x50>)
   1a704:	480f      	ldr	r0, [pc, #60]	; (1a744 <sys_rand32_get+0x60>)
   1a706:	f012 fda0 	bl	2d24a <printk>
   1a70a:	211d      	movs	r1, #29
   1a70c:	480a      	ldr	r0, [pc, #40]	; (1a738 <sys_rand32_get+0x54>)
   1a70e:	f012 fde2 	bl	2d2d6 <assert_post_action>
			"Device driver for %s (CONFIG_ENTROPY_NAME) not found. "
			"Check your build configuration!",
			CONFIG_ENTROPY_NAME);
		entropy_driver = dev;
   1a712:	602c      	str	r4, [r5, #0]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&buffer, *(uintptr_t *)&length, K_SYSCALL_ENTROPY_GET_ENTROPY);
	}
#endif
	compiler_barrier();
	return z_impl_entropy_get_entropy(dev, buffer, length);
   1a714:	2204      	movs	r2, #4
   1a716:	4620      	mov	r0, r4
   1a718:	eb0d 0102 	add.w	r1, sp, r2
   1a71c:	f7ff ffbe 	bl	1a69c <z_impl_entropy_get_entropy>
	}

	ret = entropy_get_entropy(dev, (u8_t *)&random_num,
				  sizeof(random_num));
	if (unlikely(ret < 0)) {
   1a720:	2800      	cmp	r0, #0
   1a722:	da02      	bge.n	1a72a <sys_rand32_get+0x46>
#ifndef _ASMLANGUAGE
extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
   1a724:	f7fe fac6 	bl	18cb4 <z_timer_cycle_get_32>
		 * 32-bit of data.  There's not much that can be done in this
		 * situation.  An __ASSERT() isn't used here as the HWRNG might
		 * still be gathering entropy during early boot situations.
		 */

		random_num = k_cycle_get_32();
   1a728:	9001      	str	r0, [sp, #4]
	}

	return random_num;
}
   1a72a:	9801      	ldr	r0, [sp, #4]
   1a72c:	b003      	add	sp, #12
   1a72e:	bd30      	pop	{r4, r5, pc}
   1a730:	2002874c 	.word	0x2002874c
   1a734:	00033385 	.word	0x00033385
   1a738:	0003338f 	.word	0x0003338f
   1a73c:	000333c8 	.word	0x000333c8
   1a740:	000311a3 	.word	0x000311a3
   1a744:	000333dd 	.word	0x000333dd

0001a748 <gpio_nrfx_manage_callback>:
}

static int gpio_nrfx_manage_callback(struct device *port,
				     struct gpio_callback *callback,
				     bool set)
{
   1a748:	b570      	push	{r4, r5, r6, lr}
   1a74a:	4616      	mov	r6, r2
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   1a74c:	6884      	ldr	r4, [r0, #8]
 */
static inline int gpio_manage_callback(sys_slist_t *callbacks,
					struct gpio_callback *callback,
					bool set)
{
	__ASSERT(callback, "No callback!");
   1a74e:	460d      	mov	r5, r1
   1a750:	b961      	cbnz	r1, 1a76c <gpio_nrfx_manage_callback+0x24>
   1a752:	4922      	ldr	r1, [pc, #136]	; (1a7dc <gpio_nrfx_manage_callback+0x94>)
   1a754:	231c      	movs	r3, #28
   1a756:	4a22      	ldr	r2, [pc, #136]	; (1a7e0 <gpio_nrfx_manage_callback+0x98>)
   1a758:	4822      	ldr	r0, [pc, #136]	; (1a7e4 <gpio_nrfx_manage_callback+0x9c>)
   1a75a:	f012 fd76 	bl	2d24a <printk>
   1a75e:	4822      	ldr	r0, [pc, #136]	; (1a7e8 <gpio_nrfx_manage_callback+0xa0>)
   1a760:	f012 fd73 	bl	2d24a <printk>
   1a764:	211c      	movs	r1, #28
   1a766:	481e      	ldr	r0, [pc, #120]	; (1a7e0 <gpio_nrfx_manage_callback+0x98>)
   1a768:	f012 fdb5 	bl	2d2d6 <assert_post_action>
	__ASSERT(callback->handler, "No callback handler!");
   1a76c:	686b      	ldr	r3, [r5, #4]
   1a76e:	b963      	cbnz	r3, 1a78a <gpio_nrfx_manage_callback+0x42>
   1a770:	491e      	ldr	r1, [pc, #120]	; (1a7ec <gpio_nrfx_manage_callback+0xa4>)
   1a772:	231d      	movs	r3, #29
   1a774:	4a1a      	ldr	r2, [pc, #104]	; (1a7e0 <gpio_nrfx_manage_callback+0x98>)
   1a776:	481b      	ldr	r0, [pc, #108]	; (1a7e4 <gpio_nrfx_manage_callback+0x9c>)
   1a778:	f012 fd67 	bl	2d24a <printk>
   1a77c:	481c      	ldr	r0, [pc, #112]	; (1a7f0 <gpio_nrfx_manage_callback+0xa8>)
   1a77e:	f012 fd64 	bl	2d24a <printk>
   1a782:	211d      	movs	r1, #29
   1a784:	4816      	ldr	r0, [pc, #88]	; (1a7e0 <gpio_nrfx_manage_callback+0x98>)
   1a786:	f012 fda6 	bl	2d2d6 <assert_post_action>
Z_GENLIST_IS_EMPTY(slist)
   1a78a:	6823      	ldr	r3, [r4, #0]

	if (!sys_slist_is_empty(callbacks)) {
   1a78c:	b15b      	cbz	r3, 1a7a6 <gpio_nrfx_manage_callback+0x5e>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1a78e:	2200      	movs	r2, #0
   1a790:	429d      	cmp	r5, r3
   1a792:	d113      	bne.n	1a7bc <gpio_nrfx_manage_callback+0x74>
Z_GENLIST_REMOVE(slist, snode)
   1a794:	682b      	ldr	r3, [r5, #0]
   1a796:	b95a      	cbnz	r2, 1a7b0 <gpio_nrfx_manage_callback+0x68>
   1a798:	6862      	ldr	r2, [r4, #4]
	list->head = node;
   1a79a:	6023      	str	r3, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   1a79c:	4295      	cmp	r5, r2
   1a79e:	d100      	bne.n	1a7a2 <gpio_nrfx_manage_callback+0x5a>
	list->tail = node;
   1a7a0:	6063      	str	r3, [r4, #4]
	parent->next = child;
   1a7a2:	2300      	movs	r3, #0
   1a7a4:	602b      	str	r3, [r5, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
   1a7a6:	b976      	cbnz	r6, 1a7c6 <gpio_nrfx_manage_callback+0x7e>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
   1a7a8:	2000      	movs	r0, #0
				     callback, set);
}
   1a7aa:	bd70      	pop	{r4, r5, r6, pc}
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1a7ac:	460b      	mov	r3, r1
   1a7ae:	e7ef      	b.n	1a790 <gpio_nrfx_manage_callback+0x48>
	parent->next = child;
   1a7b0:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   1a7b2:	6863      	ldr	r3, [r4, #4]
   1a7b4:	429d      	cmp	r5, r3
	list->tail = node;
   1a7b6:	bf08      	it	eq
   1a7b8:	6062      	streq	r2, [r4, #4]
   1a7ba:	e7f2      	b.n	1a7a2 <gpio_nrfx_manage_callback+0x5a>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1a7bc:	6819      	ldr	r1, [r3, #0]
	return node->next;
   1a7be:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1a7c0:	2900      	cmp	r1, #0
   1a7c2:	d1f3      	bne.n	1a7ac <gpio_nrfx_manage_callback+0x64>
			if (!set) {
   1a7c4:	b13e      	cbz	r6, 1a7d6 <gpio_nrfx_manage_callback+0x8e>
Z_GENLIST_PREPEND(slist, snode)
   1a7c6:	6823      	ldr	r3, [r4, #0]
	parent->next = child;
   1a7c8:	602b      	str	r3, [r5, #0]
Z_GENLIST_PREPEND(slist, snode)
   1a7ca:	6860      	ldr	r0, [r4, #4]
	list->head = node;
   1a7cc:	6025      	str	r5, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
   1a7ce:	2800      	cmp	r0, #0
   1a7d0:	d1ea      	bne.n	1a7a8 <gpio_nrfx_manage_callback+0x60>
	list->tail = node;
   1a7d2:	6065      	str	r5, [r4, #4]
   1a7d4:	e7e9      	b.n	1a7aa <gpio_nrfx_manage_callback+0x62>
				return -EINVAL;
   1a7d6:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   1a7da:	e7e6      	b.n	1a7aa <gpio_nrfx_manage_callback+0x62>
   1a7dc:	000312f7 	.word	0x000312f7
   1a7e0:	000334c1 	.word	0x000334c1
   1a7e4:	000311a3 	.word	0x000311a3
   1a7e8:	000334ee 	.word	0x000334ee
   1a7ec:	000334fd 	.word	0x000334fd
   1a7f0:	0003350f 	.word	0x0003350f

0001a7f4 <nrf_gpio_pin_port_decode.isra.8.part.9>:
 *
 * @param[in,out] p_pin Pointer to the absolute pin number overriden by the pin number that is relative to the port.
 *
 * @return Pointer to port register set.
 */
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   1a7f4:	b508      	push	{r3, lr}
{
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   1a7f6:	4a03      	ldr	r2, [pc, #12]	; (1a804 <nrf_gpio_pin_port_decode.isra.8.part.9+0x10>)
   1a7f8:	4b03      	ldr	r3, [pc, #12]	; (1a808 <nrf_gpio_pin_port_decode.isra.8.part.9+0x14>)
   1a7fa:	f240 11ff 	movw	r1, #511	; 0x1ff
   1a7fe:	4803      	ldr	r0, [pc, #12]	; (1a80c <nrf_gpio_pin_port_decode.isra.8.part.9+0x18>)
   1a800:	f00f fa9a 	bl	29d38 <__assert_func>
   1a804:	000334a8 	.word	0x000334a8
   1a808:	00033552 	.word	0x00033552
   1a80c:	00033560 	.word	0x00033560

0001a810 <nrf_gpio_cfg_sense_set>:
   1a810:	281f      	cmp	r0, #31
}


NRF_STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t             pin_number,
                                              nrf_gpio_pin_sense_t sense_config)
{
   1a812:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   1a814:	d901      	bls.n	1a81a <nrf_gpio_cfg_sense_set+0xa>
   1a816:	f7ff ffed 	bl	1a7f4 <nrf_gpio_pin_port_decode.isra.8.part.9>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
   1a81a:	4a06      	ldr	r2, [pc, #24]	; (1a834 <nrf_gpio_cfg_sense_set+0x24>)
   1a81c:	eb02 0080 	add.w	r0, r2, r0, lsl #2
   1a820:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
   1a824:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000

    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   1a828:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   1a82c:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
}
   1a830:	bd08      	pop	{r3, pc}
   1a832:	bf00      	nop
   1a834:	40842500 	.word	0x40842500

0001a838 <gpio_nrfx_init>:
#endif
	}
}

static int gpio_nrfx_init(struct device *port)
{
   1a838:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
   1a83a:	4b09      	ldr	r3, [pc, #36]	; (1a860 <gpio_nrfx_init+0x28>)
   1a83c:	781a      	ldrb	r2, [r3, #0]
   1a83e:	b96a      	cbnz	r2, 1a85c <gpio_nrfx_init+0x24>
		gpio_initialized = true;
   1a840:	2101      	movs	r1, #1
		IRQ_CONNECT(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0,
   1a842:	2031      	movs	r0, #49	; 0x31
		gpio_initialized = true;
   1a844:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0,
   1a846:	2105      	movs	r1, #5
   1a848:	f7fe fbf0 	bl	1902c <z_arm_irq_priority_set>
			    DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0_PRIORITY,
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0);
   1a84c:	2031      	movs	r0, #49	; 0x31
   1a84e:	f7fe fbdd 	bl	1900c <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   1a852:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   1a856:	4b03      	ldr	r3, [pc, #12]	; (1a864 <gpio_nrfx_init+0x2c>)
   1a858:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
   1a85c:	2000      	movs	r0, #0
   1a85e:	bd08      	pop	{r3, pc}
   1a860:	20030490 	.word	0x20030490
   1a864:	40031000 	.word	0x40031000

0001a868 <gpiote_pin_int_cfg>:
{
   1a868:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return port->config->config_info;
   1a86c:	6803      	ldr	r3, [r0, #0]
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1a86e:	f001 041f 	and.w	r4, r1, #31
   1a872:	689b      	ldr	r3, [r3, #8]
{
   1a874:	460d      	mov	r5, r1
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1a876:	791b      	ldrb	r3, [r3, #4]
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
   1a878:	4e4b      	ldr	r6, [pc, #300]	; (1a9a8 <gpiote_pin_int_cfg+0x140>)
   1a87a:	ea44 1443 	orr.w	r4, r4, r3, lsl #5
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   1a87e:	2300      	movs	r3, #0
   1a880:	f8d6 2304 	ldr.w	r2, [r6, #772]	; 0x304
	struct gpio_nrfx_data *data = get_port_data(port);
   1a884:	6887      	ldr	r7, [r0, #8]
   1a886:	b2d2      	uxtb	r2, r2
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   1a888:	f503 71a2 	add.w	r1, r3, #324	; 0x144
   1a88c:	f856 1021 	ldr.w	r1, [r6, r1, lsl #2]
   1a890:	f3c1 2104 	ubfx	r1, r1, #8, #5
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
   1a894:	428c      	cmp	r4, r1
   1a896:	d16c      	bne.n	1a972 <gpiote_pin_int_cfg+0x10a>
		    && (intenset & BIT(i))) {
   1a898:	fa22 f103 	lsr.w	r1, r2, r3
   1a89c:	07c9      	lsls	r1, r1, #31
   1a89e:	d568      	bpl.n	1a972 <gpiote_pin_int_cfg+0x10a>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
   1a8a0:	009a      	lsls	r2, r3, #2
   1a8a2:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   1a8a6:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   1a8aa:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
   1a8ae:	f021 0101 	bic.w	r1, r1, #1
   1a8b2:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
   1a8b6:	2201      	movs	r2, #1
   1a8b8:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENCLR = mask;
   1a8bc:	f8c6 3308 	str.w	r3, [r6, #776]	; 0x308
	nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   1a8c0:	4620      	mov	r0, r4
   1a8c2:	2100      	movs	r1, #0
   1a8c4:	f7ff ffa4 	bl	1a810 <nrf_gpio_cfg_sense_set>
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
   1a8c8:	68b8      	ldr	r0, [r7, #8]
   1a8ca:	40e8      	lsrs	r0, r5
   1a8cc:	f010 0001 	ands.w	r0, r0, #1
   1a8d0:	d04d      	beq.n	1a96e <gpiote_pin_int_cfg+0x106>
   1a8d2:	68f8      	ldr	r0, [r7, #12]
   1a8d4:	40e8      	lsrs	r0, r5
   1a8d6:	f010 0001 	ands.w	r0, r0, #1
   1a8da:	d048      	beq.n	1a96e <gpiote_pin_int_cfg+0x106>
		if (data->trig_edge & BIT(pin)) {
   1a8dc:	6978      	ldr	r0, [r7, #20]
   1a8de:	40e8      	lsrs	r0, r5
   1a8e0:	f010 0801 	ands.w	r8, r0, #1
   1a8e4:	d051      	beq.n	1a98a <gpiote_pin_int_cfg+0x122>
			if (data->double_edge & BIT(pin)) {
   1a8e6:	69bb      	ldr	r3, [r7, #24]
   1a8e8:	40eb      	lsrs	r3, r5
   1a8ea:	07db      	lsls	r3, r3, #31
   1a8ec:	d445      	bmi.n	1a97a <gpiote_pin_int_cfg+0x112>
			} else if (((data->active_level & BIT(pin)) != 0U)
   1a8ee:	693b      	ldr	r3, [r7, #16]
				   ^ ((BIT(pin) & data->inverted) != 0)) {
   1a8f0:	69fa      	ldr	r2, [r7, #28]
			} else if (((data->active_level & BIT(pin)) != 0U)
   1a8f2:	40eb      	lsrs	r3, r5
				   ^ ((BIT(pin) & data->inverted) != 0)) {
   1a8f4:	fa22 f505 	lsr.w	r5, r2, r5
			} else if (((data->active_level & BIT(pin)) != 0U)
   1a8f8:	f003 0301 	and.w	r3, r3, #1
   1a8fc:	f005 0501 	and.w	r5, r5, #1
				pol = NRF_GPIOTE_POLARITY_HITOLO;
   1a900:	42ab      	cmp	r3, r5
   1a902:	bf14      	ite	ne
   1a904:	2501      	movne	r5, #1
   1a906:	2502      	moveq	r5, #2
   1a908:	2100      	movs	r1, #0
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
   1a90a:	f501 73a2 	add.w	r3, r1, #324	; 0x144
   1a90e:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
   1a912:	f010 0003 	ands.w	r0, r0, #3
   1a916:	d132      	bne.n	1a97e <gpiote_pin_int_cfg+0x116>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   1a918:	008b      	lsls	r3, r1, #2
   1a91a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   1a91e:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   1a922:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   1a926:	0224      	lsls	r4, r4, #8
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   1a928:	f422 3247 	bic.w	r2, r2, #203776	; 0x31c00
   1a92c:	f422 7240 	bic.w	r2, r2, #768	; 0x300
   1a930:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   1a934:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   1a938:	f404 54f8 	and.w	r4, r4, #7936	; 0x1f00
   1a93c:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
   1a940:	4315      	orrs	r5, r2
			nrf_gpiote_event_t evt =
   1a942:	f101 0240 	add.w	r2, r1, #64	; 0x40
   1a946:	0092      	lsls	r2, r2, #2
    return ((uint32_t)p_reg + event);
   1a948:	b292      	uxth	r2, r2
   1a94a:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   1a94e:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   1a952:	f8c3 5510 	str.w	r5, [r3, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   1a956:	6010      	str	r0, [r2, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   1a958:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   1a95c:	f042 0201 	orr.w	r2, r2, #1
   1a960:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
   1a964:	2301      	movs	r3, #1
   1a966:	fa03 f101 	lsl.w	r1, r3, r1
    p_reg->INTENSET = mask;
   1a96a:	f8c6 1304 	str.w	r1, [r6, #772]	; 0x304
}
   1a96e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   1a972:	3301      	adds	r3, #1
   1a974:	2b08      	cmp	r3, #8
   1a976:	d187      	bne.n	1a888 <gpiote_pin_int_cfg+0x20>
   1a978:	e7a2      	b.n	1a8c0 <gpiote_pin_int_cfg+0x58>
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
   1a97a:	2503      	movs	r5, #3
   1a97c:	e7c4      	b.n	1a908 <gpiote_pin_int_cfg+0xa0>
   1a97e:	3101      	adds	r1, #1
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
   1a980:	2908      	cmp	r1, #8
   1a982:	d1c2      	bne.n	1a90a <gpiote_pin_int_cfg+0xa2>
	return -ENODEV;
   1a984:	f06f 0012 	mvn.w	r0, #18
   1a988:	e7f1      	b.n	1a96e <gpiote_pin_int_cfg+0x106>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   1a98a:	693b      	ldr	r3, [r7, #16]
   1a98c:	69fa      	ldr	r2, [r7, #28]
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   1a98e:	4620      	mov	r0, r4
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   1a990:	4053      	eors	r3, r2
   1a992:	fa23 f505 	lsr.w	r5, r3, r5
		return NRF_GPIO_PIN_SENSE_HIGH;
   1a996:	f015 0f01 	tst.w	r5, #1
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   1a99a:	bf0c      	ite	eq
   1a99c:	2103      	moveq	r1, #3
   1a99e:	2102      	movne	r1, #2
   1a9a0:	f7ff ff36 	bl	1a810 <nrf_gpio_cfg_sense_set>
	int res = 0;
   1a9a4:	4640      	mov	r0, r8
   1a9a6:	e7e2      	b.n	1a96e <gpiote_pin_int_cfg+0x106>
   1a9a8:	40031000 	.word	0x40031000

0001a9ac <gpio_nrfx_config>:
{
   1a9ac:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a9b0:	4680      	mov	r8, r0
	struct gpio_nrfx_data *data = get_port_data(port);
   1a9b2:	6885      	ldr	r5, [r0, #8]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   1a9b4:	f403 4070 	and.w	r0, r3, #61440	; 0xf000
   1a9b8:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
{
   1a9bc:	461e      	mov	r6, r3
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   1a9be:	d040      	beq.n	1aa42 <gpio_nrfx_config+0x96>
   1a9c0:	dc09      	bgt.n	1a9d6 <gpio_nrfx_config+0x2a>
   1a9c2:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   1a9c6:	d03e      	beq.n	1aa46 <gpio_nrfx_config+0x9a>
   1a9c8:	f5b0 5f40 	cmp.w	r0, #12288	; 0x3000
   1a9cc:	d03d      	beq.n	1aa4a <gpio_nrfx_config+0x9e>
   1a9ce:	b190      	cbz	r0, 1a9f6 <gpio_nrfx_config+0x4a>
		return -EINVAL;
   1a9d0:	f06f 0015 	mvn.w	r0, #21
   1a9d4:	e032      	b.n	1aa3c <gpio_nrfx_config+0x90>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   1a9d6:	f5b0 4fe0 	cmp.w	r0, #28672	; 0x7000
   1a9da:	d038      	beq.n	1aa4e <gpio_nrfx_config+0xa2>
   1a9dc:	dc04      	bgt.n	1a9e8 <gpio_nrfx_config+0x3c>
   1a9de:	f5b0 4fa0 	cmp.w	r0, #20480	; 0x5000
   1a9e2:	d1f5      	bne.n	1a9d0 <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0H1;
   1a9e4:	2003      	movs	r0, #3
   1a9e6:	e006      	b.n	1a9f6 <gpio_nrfx_config+0x4a>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   1a9e8:	f5b0 4f40 	cmp.w	r0, #49152	; 0xc000
   1a9ec:	d031      	beq.n	1aa52 <gpio_nrfx_config+0xa6>
   1a9ee:	f5b0 4f50 	cmp.w	r0, #53248	; 0xd000
   1a9f2:	d1ed      	bne.n	1a9d0 <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0D1;
   1a9f4:	2007      	movs	r0, #7
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
   1a9f6:	f406 7740 	and.w	r7, r6, #768	; 0x300
   1a9fa:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
   1a9fe:	d02a      	beq.n	1aa56 <gpio_nrfx_config+0xaa>
		pull = NRF_GPIO_PIN_NOPULL;
   1aa00:	f5a7 7400 	sub.w	r4, r7, #512	; 0x200
   1aa04:	4263      	negs	r3, r4
   1aa06:	4163      	adcs	r3, r4
	if (access_op == GPIO_ACCESS_BY_PORT) {
   1aa08:	2901      	cmp	r1, #1
		from_pin = pin;
   1aa0a:	bf19      	ittee	ne
   1aa0c:	b2d4      	uxtbne	r4, r2
		to_pin   = pin;
   1aa0e:	46a1      	movne	r9, r4
		to_pin   = 31U;
   1aa10:	f04f 091f 	moveq.w	r9, #31
		from_pin = 0U;
   1aa14:	2400      	moveq	r4, #0
   1aa16:	f04f 0b01 	mov.w	fp, #1
	dir = ((flags & GPIO_DIR_MASK) == GPIO_DIR_OUT)
   1aa1a:	f006 0c01 	and.w	ip, r6, #1
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
   1aa1e:	ea4f 074c 	mov.w	r7, ip, lsl #1
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   1aa22:	ea47 070c 	orr.w	r7, r7, ip
   1aa26:	ea47 2000 	orr.w	r0, r7, r0, lsl #8
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1aa2a:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 1aad4 <gpio_nrfx_config+0x128>
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   1aa2e:	ea40 0783 	orr.w	r7, r0, r3, lsl #2
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   1aa32:	f006 0302 	and.w	r3, r6, #2
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   1aa36:	45a1      	cmp	r9, r4
   1aa38:	d20f      	bcs.n	1aa5a <gpio_nrfx_config+0xae>
	return 0;
   1aa3a:	2000      	movs	r0, #0
}
   1aa3c:	b003      	add	sp, #12
   1aa3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		drive = NRF_GPIO_PIN_S0H1;
   1aa42:	2002      	movs	r0, #2
   1aa44:	e7d7      	b.n	1a9f6 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_H0S1;
   1aa46:	2001      	movs	r0, #1
   1aa48:	e7d5      	b.n	1a9f6 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0S1;
   1aa4a:	2004      	movs	r0, #4
   1aa4c:	e7d3      	b.n	1a9f6 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0H1;
   1aa4e:	2005      	movs	r0, #5
   1aa50:	e7d1      	b.n	1a9f6 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_S0D1;
   1aa52:	2006      	movs	r0, #6
   1aa54:	e7cf      	b.n	1a9f6 <gpio_nrfx_config+0x4a>
		pull = NRF_GPIO_PIN_PULLUP;
   1aa56:	2303      	movs	r3, #3
   1aa58:	e7d6      	b.n	1aa08 <gpio_nrfx_config+0x5c>
	return port->config->config_info;
   1aa5a:	f8d8 2000 	ldr.w	r2, [r8]
		nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num,
   1aa5e:	6892      	ldr	r2, [r2, #8]
   1aa60:	7911      	ldrb	r1, [r2, #4]
   1aa62:	f004 021f 	and.w	r2, r4, #31
   1aa66:	ea42 1241 	orr.w	r2, r2, r1, lsl #5
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   1aa6a:	2a1f      	cmp	r2, #31
   1aa6c:	dd01      	ble.n	1aa72 <gpio_nrfx_config+0xc6>
   1aa6e:	f7ff fec1 	bl	1a7f4 <nrf_gpio_pin_port_decode.isra.8.part.9>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1aa72:	3280      	adds	r2, #128	; 0x80
   1aa74:	f84a 7022 	str.w	r7, [sl, r2, lsl #2]
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   1aa78:	68a9      	ldr	r1, [r5, #8]
   1aa7a:	fa0b f204 	lsl.w	r2, fp, r4
   1aa7e:	2b00      	cmp	r3, #0
   1aa80:	d025      	beq.n	1aace <gpio_nrfx_config+0x122>
   1aa82:	4311      	orrs	r1, r2
   1aa84:	60a9      	str	r1, [r5, #8]
		WRITE_BIT(data->trig_edge, curr_pin, flags & GPIO_INT_EDGE);
   1aa86:	6969      	ldr	r1, [r5, #20]
   1aa88:	06b0      	lsls	r0, r6, #26
   1aa8a:	bf4c      	ite	mi
   1aa8c:	4311      	orrmi	r1, r2
   1aa8e:	4391      	bicpl	r1, r2
   1aa90:	6169      	str	r1, [r5, #20]
		WRITE_BIT(data->double_edge, curr_pin,
   1aa92:	69a9      	ldr	r1, [r5, #24]
   1aa94:	0670      	lsls	r0, r6, #25
   1aa96:	bf4c      	ite	mi
   1aa98:	4311      	orrmi	r1, r2
   1aa9a:	4391      	bicpl	r1, r2
   1aa9c:	61a9      	str	r1, [r5, #24]
		WRITE_BIT(data->active_level, curr_pin,
   1aa9e:	6929      	ldr	r1, [r5, #16]
   1aaa0:	0770      	lsls	r0, r6, #29
   1aaa2:	bf4c      	ite	mi
   1aaa4:	4311      	orrmi	r1, r2
   1aaa6:	4391      	bicpl	r1, r2
   1aaa8:	6129      	str	r1, [r5, #16]
		WRITE_BIT(data->inverted, curr_pin, flags & GPIO_POL_INV);
   1aaaa:	69e9      	ldr	r1, [r5, #28]
   1aaac:	0630      	lsls	r0, r6, #24
   1aaae:	bf4c      	ite	mi
   1aab0:	430a      	orrmi	r2, r1
   1aab2:	ea21 0202 	bicpl.w	r2, r1, r2
   1aab6:	61ea      	str	r2, [r5, #28]
		res = gpiote_pin_int_cfg(port, curr_pin);
   1aab8:	4621      	mov	r1, r4
   1aaba:	4640      	mov	r0, r8
   1aabc:	9301      	str	r3, [sp, #4]
   1aabe:	f7ff fed3 	bl	1a868 <gpiote_pin_int_cfg>
		if (res != 0) {
   1aac2:	2800      	cmp	r0, #0
   1aac4:	d1ba      	bne.n	1aa3c <gpio_nrfx_config+0x90>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   1aac6:	3401      	adds	r4, #1
   1aac8:	b2e4      	uxtb	r4, r4
   1aaca:	9b01      	ldr	r3, [sp, #4]
   1aacc:	e7b3      	b.n	1aa36 <gpio_nrfx_config+0x8a>
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   1aace:	ea21 0102 	bic.w	r1, r1, r2
   1aad2:	e7d7      	b.n	1aa84 <gpio_nrfx_config+0xd8>
   1aad4:	40842500 	.word	0x40842500

0001aad8 <gpiote_event_handler>:
{
   1aad8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1aadc:	4b56      	ldr	r3, [pc, #344]	; (1ac38 <gpiote_event_handler+0x160>)
   1aade:	681e      	ldr	r6, [r3, #0]
	if (port_event) {
   1aae0:	4698      	mov	r8, r3
   1aae2:	2e00      	cmp	r6, #0
   1aae4:	d05e      	beq.n	1aba4 <gpiote_event_handler+0xcc>
	u32_t bit = 1U << pin;
   1aae6:	2701      	movs	r7, #1
	u32_t pin = 0U;
   1aae8:	f04f 0a00 	mov.w	sl, #0
	struct gpio_nrfx_data *data = get_port_data(port);
   1aaec:	4a53      	ldr	r2, [pc, #332]	; (1ac3c <gpiote_event_handler+0x164>)
   1aaee:	6893      	ldr	r3, [r2, #8]
	return port->config->config_info;
   1aaf0:	6812      	ldr	r2, [r2, #0]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
   1aaf2:	69dc      	ldr	r4, [r3, #28]
	return port->config->config_info;
   1aaf4:	f8d2 9008 	ldr.w	r9, [r2, #8]
	u32_t out = data->int_en & data->pin_int_en;
   1aaf8:	e9d3 2502 	ldrd	r2, r5, [r3, #8]
   1aafc:	4015      	ands	r5, r2
	out &= ~data->trig_edge & ~data->double_edge;
   1aafe:	e9d3 2105 	ldrd	r2, r1, [r3, #20]
   1ab02:	430a      	orrs	r2, r1
   1ab04:	ea25 0502 	bic.w	r5, r5, r2
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
   1ab08:	f8d9 2000 	ldr.w	r2, [r9]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
   1ab0c:	691b      	ldr	r3, [r3, #16]
}


NRF_STATIC_INLINE uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const * p_reg)
{
    return p_reg->IN;
   1ab0e:	6912      	ldr	r2, [r2, #16]
   1ab10:	405c      	eors	r4, r3
   1ab12:	4054      	eors	r4, r2
	u32_t out = pin_states & level_pins;
   1ab14:	ea25 0404 	bic.w	r4, r5, r4
	while (level_pins) {
   1ab18:	bb9d      	cbnz	r5, 1ab82 <gpiote_event_handler+0xaa>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   1ab1a:	f8c8 5000 	str.w	r5, [r8]
	u32_t fired_triggers[GPIO_COUNT] = {0};
   1ab1e:	2300      	movs	r3, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
   1ab20:	2001      	movs	r0, #1
   1ab22:	461f      	mov	r7, r3
    return p_reg->INTENSET & mask;
   1ab24:	4946      	ldr	r1, [pc, #280]	; (1ac40 <gpiote_event_handler+0x168>)
   1ab26:	4d47      	ldr	r5, [pc, #284]	; (1ac44 <gpiote_event_handler+0x16c>)
   1ab28:	f8d1 2304 	ldr.w	r2, [r1, #772]	; 0x304
   1ab2c:	fa00 fc03 	lsl.w	ip, r0, r3
   1ab30:	ea1c 0f02 	tst.w	ip, r2
   1ab34:	d00d      	beq.n	1ab52 <gpiote_event_handler+0x7a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1ab36:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
   1ab3a:	b152      	cbz	r2, 1ab52 <gpiote_event_handler+0x7a>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   1ab3c:	f503 72a2 	add.w	r2, r3, #324	; 0x144
   1ab40:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   1ab44:	f845 7023 	str.w	r7, [r5, r3, lsl #2]
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   1ab48:	f3c2 2204 	ubfx	r2, r2, #8, #5
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
   1ab4c:	fa00 f202 	lsl.w	r2, r0, r2
   1ab50:	4314      	orrs	r4, r2
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   1ab52:	3301      	adds	r3, #1
   1ab54:	2b08      	cmp	r3, #8
   1ab56:	d1e7      	bne.n	1ab28 <gpiote_event_handler+0x50>
	if (fired_triggers[0]) {
   1ab58:	bb34      	cbnz	r4, 1aba8 <gpiote_event_handler+0xd0>
	if (port_event) {
   1ab5a:	b186      	cbz	r6, 1ab7e <gpiote_event_handler+0xa6>
	u32_t bit = 1U << pin;
   1ab5c:	2701      	movs	r7, #1
	u32_t pin = 0U;
   1ab5e:	f04f 0800 	mov.w	r8, #0
	const struct gpio_nrfx_data *data = get_port_data(port);
   1ab62:	4b36      	ldr	r3, [pc, #216]	; (1ac3c <gpiote_event_handler+0x164>)
   1ab64:	689d      	ldr	r5, [r3, #8]
	return port->config->config_info;
   1ab66:	681b      	ldr	r3, [r3, #0]
   1ab68:	689e      	ldr	r6, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
   1ab6a:	e9d5 3402 	ldrd	r3, r4, [r5, #8]
   1ab6e:	401c      	ands	r4, r3
	out &= ~data->trig_edge & ~data->double_edge;
   1ab70:	e9d5 3205 	ldrd	r3, r2, [r5, #20]
   1ab74:	4313      	orrs	r3, r2
   1ab76:	ea24 0403 	bic.w	r4, r4, r3
	while (level_pins) {
   1ab7a:	2c00      	cmp	r4, #0
   1ab7c:	d142      	bne.n	1ac04 <gpiote_event_handler+0x12c>
}
   1ab7e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (level_pins & bit) {
   1ab82:	423d      	tst	r5, r7
   1ab84:	d00a      	beq.n	1ab9c <gpiote_event_handler+0xc4>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1ab86:	f899 3004 	ldrb.w	r3, [r9, #4]
   1ab8a:	f00a 001f 	and.w	r0, sl, #31
			nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   1ab8e:	2100      	movs	r1, #0
   1ab90:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
   1ab94:	f7ff fe3c 	bl	1a810 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   1ab98:	ea25 0507 	bic.w	r5, r5, r7
		++pin;
   1ab9c:	f10a 0a01 	add.w	sl, sl, #1
		bit <<= 1;
   1aba0:	007f      	lsls	r7, r7, #1
   1aba2:	e7b9      	b.n	1ab18 <gpiote_event_handler+0x40>
	u32_t fired_triggers[GPIO_COUNT] = {0};
   1aba4:	4634      	mov	r4, r6
   1aba6:	e7ba      	b.n	1ab1e <gpiote_event_handler+0x46>
	struct gpio_nrfx_data *data = get_port_data(port);
   1aba8:	4b24      	ldr	r3, [pc, #144]	; (1ac3c <gpiote_event_handler+0x164>)
   1abaa:	f8d3 9008 	ldr.w	r9, [r3, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1abae:	f8d9 5000 	ldr.w	r5, [r9]
   1abb2:	2d00      	cmp	r5, #0
   1abb4:	d0d1      	beq.n	1ab5a <gpiote_event_handler+0x82>
			cb->handler(port, cb, pins);
   1abb6:	4698      	mov	r8, r3
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1abb8:	682f      	ldr	r7, [r5, #0]
			__ASSERT(cb->handler, "No callback handler!");
   1abba:	f8df a094 	ldr.w	sl, [pc, #148]	; 1ac50 <gpiote_event_handler+0x178>
   1abbe:	f8df b094 	ldr.w	fp, [pc, #148]	; 1ac54 <gpiote_event_handler+0x17c>
		if ((cb->pin_mask & pins) & data->int_en) {
   1abc2:	f8d9 300c 	ldr.w	r3, [r9, #12]
   1abc6:	68aa      	ldr	r2, [r5, #8]
   1abc8:	4023      	ands	r3, r4
   1abca:	4213      	tst	r3, r2
   1abcc:	d015      	beq.n	1abfa <gpiote_event_handler+0x122>
			__ASSERT(cb->handler, "No callback handler!");
   1abce:	686b      	ldr	r3, [r5, #4]
   1abd0:	b973      	cbnz	r3, 1abf0 <gpiote_event_handler+0x118>
   1abd2:	4659      	mov	r1, fp
   1abd4:	f44f 73d2 	mov.w	r3, #420	; 0x1a4
   1abd8:	4652      	mov	r2, sl
   1abda:	481b      	ldr	r0, [pc, #108]	; (1ac48 <gpiote_event_handler+0x170>)
   1abdc:	f012 fb35 	bl	2d24a <printk>
   1abe0:	481a      	ldr	r0, [pc, #104]	; (1ac4c <gpiote_event_handler+0x174>)
   1abe2:	f012 fb32 	bl	2d24a <printk>
   1abe6:	f44f 71d2 	mov.w	r1, #420	; 0x1a4
   1abea:	4650      	mov	r0, sl
   1abec:	f012 fb73 	bl	2d2d6 <assert_post_action>
			cb->handler(port, cb, pins);
   1abf0:	686b      	ldr	r3, [r5, #4]
   1abf2:	4622      	mov	r2, r4
   1abf4:	4629      	mov	r1, r5
   1abf6:	4640      	mov	r0, r8
   1abf8:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1abfa:	2f00      	cmp	r7, #0
   1abfc:	d0ad      	beq.n	1ab5a <gpiote_event_handler+0x82>
   1abfe:	463d      	mov	r5, r7
   1ac00:	683f      	ldr	r7, [r7, #0]
   1ac02:	e7de      	b.n	1abc2 <gpiote_event_handler+0xea>
		if (level_pins & bit) {
   1ac04:	4227      	tst	r7, r4
   1ac06:	d013      	beq.n	1ac30 <gpiote_event_handler+0x158>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   1ac08:	692b      	ldr	r3, [r5, #16]
   1ac0a:	69ea      	ldr	r2, [r5, #28]
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1ac0c:	f896 c004 	ldrb.w	ip, [r6, #4]
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   1ac10:	4053      	eors	r3, r2
   1ac12:	fa23 f308 	lsr.w	r3, r3, r8
		return NRF_GPIO_PIN_SENSE_HIGH;
   1ac16:	f013 0f01 	tst.w	r3, #1
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1ac1a:	f008 001f 	and.w	r0, r8, #31
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   1ac1e:	bf0c      	ite	eq
   1ac20:	2103      	moveq	r1, #3
   1ac22:	2102      	movne	r1, #2
   1ac24:	ea40 104c 	orr.w	r0, r0, ip, lsl #5
   1ac28:	f7ff fdf2 	bl	1a810 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   1ac2c:	ea24 0407 	bic.w	r4, r4, r7
		++pin;
   1ac30:	f108 0801 	add.w	r8, r8, #1
		bit <<= 1;
   1ac34:	007f      	lsls	r7, r7, #1
   1ac36:	e7a0      	b.n	1ab7a <gpiote_event_handler+0xa2>
   1ac38:	4003117c 	.word	0x4003117c
   1ac3c:	2003b654 	.word	0x2003b654
   1ac40:	40031000 	.word	0x40031000
   1ac44:	40031100 	.word	0x40031100
   1ac48:	000311a3 	.word	0x000311a3
   1ac4c:	0003350f 	.word	0x0003350f
   1ac50:	00033526 	.word	0x00033526
   1ac54:	0003418e 	.word	0x0003418e

0001ac58 <twim_1_init>:
#ifdef CONFIG_I2C_0_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(0);
#endif

#ifdef CONFIG_I2C_1_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(1);
   1ac58:	b510      	push	{r4, lr}
   1ac5a:	4604      	mov	r4, r0
   1ac5c:	2200      	movs	r2, #0
   1ac5e:	2101      	movs	r1, #1
   1ac60:	2009      	movs	r0, #9
   1ac62:	f7fe f9e3 	bl	1902c <z_arm_irq_priority_set>
	return dev->config->config_info;
   1ac66:	6823      	ldr	r3, [r4, #0]
	nrfx_err_t result = nrfx_twim_init(&get_dev_config(dev)->twim,
   1ac68:	4a0f      	ldr	r2, [pc, #60]	; (1aca8 <twim_1_init+0x50>)
	return dev->config->config_info;
   1ac6a:	6898      	ldr	r0, [r3, #8]
	nrfx_err_t result = nrfx_twim_init(&get_dev_config(dev)->twim,
   1ac6c:	4623      	mov	r3, r4
   1ac6e:	f100 0108 	add.w	r1, r0, #8
   1ac72:	f00a ff91 	bl	25b98 <nrfx_twim_init>
	if (result != NRFX_SUCCESS) {
   1ac76:	4b0d      	ldr	r3, [pc, #52]	; (1acac <twim_1_init+0x54>)
   1ac78:	4298      	cmp	r0, r3
   1ac7a:	d012      	beq.n	1aca2 <twim_1_init+0x4a>
		LOG_ERR("Failed to initialize device: %s",
   1ac7c:	2301      	movs	r3, #1
   1ac7e:	f04f 0000 	mov.w	r0, #0
   1ac82:	4a0b      	ldr	r2, [pc, #44]	; (1acb0 <twim_1_init+0x58>)
   1ac84:	f363 0007 	bfi	r0, r3, #0, #8
   1ac88:	4b0a      	ldr	r3, [pc, #40]	; (1acb4 <twim_1_init+0x5c>)
   1ac8a:	490b      	ldr	r1, [pc, #44]	; (1acb8 <twim_1_init+0x60>)
   1ac8c:	1a9b      	subs	r3, r3, r2
   1ac8e:	08db      	lsrs	r3, r3, #3
   1ac90:	f363 108f 	bfi	r0, r3, #6, #10
   1ac94:	6823      	ldr	r3, [r4, #0]
   1ac96:	681a      	ldr	r2, [r3, #0]
   1ac98:	f012 fb2e 	bl	2d2f8 <log_string_sync>
		return -EBUSY;
   1ac9c:	f06f 000f 	mvn.w	r0, #15
I2C_NRFX_TWIM_DEVICE(1);
   1aca0:	bd10      	pop	{r4, pc}
	return 0;
   1aca2:	2000      	movs	r0, #0
I2C_NRFX_TWIM_DEVICE(1);
   1aca4:	e7fc      	b.n	1aca0 <twim_1_init+0x48>
   1aca6:	bf00      	nop
   1aca8:	0001ae09 	.word	0x0001ae09
   1acac:	0bad0000 	.word	0x0bad0000
   1acb0:	0003040c 	.word	0x0003040c
   1acb4:	0003047c 	.word	0x0003047c
   1acb8:	000335d4 	.word	0x000335d4

0001acbc <i2c_nrfx_twim_configure>:
{
   1acbc:	b508      	push	{r3, lr}
	return dev->config->config_info;
   1acbe:	6803      	ldr	r3, [r0, #0]
	if (I2C_ADDR_10_BITS & dev_config) {
   1acc0:	07ca      	lsls	r2, r1, #31
	return dev->config->config_info;
   1acc2:	689b      	ldr	r3, [r3, #8]
	if (I2C_ADDR_10_BITS & dev_config) {
   1acc4:	d413      	bmi.n	1acee <i2c_nrfx_twim_configure+0x32>
	switch (I2C_SPEED_GET(dev_config)) {
   1acc6:	f3c1 0242 	ubfx	r2, r1, #1, #3
   1acca:	2a01      	cmp	r2, #1
   1accc:	d012      	beq.n	1acf4 <i2c_nrfx_twim_configure+0x38>
   1acce:	2a02      	cmp	r2, #2
   1acd0:	d019      	beq.n	1ad06 <i2c_nrfx_twim_configure+0x4a>
		LOG_ERR("unsupported speed");
   1acd2:	2301      	movs	r3, #1
   1acd4:	f04f 0000 	mov.w	r0, #0
   1acd8:	4a0d      	ldr	r2, [pc, #52]	; (1ad10 <i2c_nrfx_twim_configure+0x54>)
   1acda:	f363 0007 	bfi	r0, r3, #0, #8
   1acde:	4b0d      	ldr	r3, [pc, #52]	; (1ad14 <i2c_nrfx_twim_configure+0x58>)
   1ace0:	490d      	ldr	r1, [pc, #52]	; (1ad18 <i2c_nrfx_twim_configure+0x5c>)
   1ace2:	1a9b      	subs	r3, r3, r2
   1ace4:	08db      	lsrs	r3, r3, #3
   1ace6:	f363 108f 	bfi	r0, r3, #6, #10
   1acea:	f012 fb05 	bl	2d2f8 <log_string_sync>
		return -EINVAL;
   1acee:	f06f 0015 	mvn.w	r0, #21
   1acf2:	e007      	b.n	1ad04 <i2c_nrfx_twim_configure+0x48>
}

NRF_STATIC_INLINE void nrf_twim_frequency_set(NRF_TWIM_Type * p_reg,
                                              nrf_twim_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
   1acf4:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
		nrf_twim_frequency_set(inst->p_twim, NRF_TWIM_FREQ_100K);
   1acf8:	681b      	ldr	r3, [r3, #0]
   1acfa:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	get_dev_data(dev)->dev_config = dev_config;
   1acfe:	6883      	ldr	r3, [r0, #8]
	return 0;
   1ad00:	2000      	movs	r0, #0
	get_dev_data(dev)->dev_config = dev_config;
   1ad02:	6359      	str	r1, [r3, #52]	; 0x34
}
   1ad04:	bd08      	pop	{r3, pc}
		nrf_twim_frequency_set(inst->p_twim, NRF_TWIM_FREQ_400K);
   1ad06:	681b      	ldr	r3, [r3, #0]
   1ad08:	f04f 62c8 	mov.w	r2, #104857600	; 0x6400000
   1ad0c:	e7f5      	b.n	1acfa <i2c_nrfx_twim_configure+0x3e>
   1ad0e:	bf00      	nop
   1ad10:	0003040c 	.word	0x0003040c
   1ad14:	0003047c 	.word	0x0003047c
   1ad18:	00033593 	.word	0x00033593

0001ad1c <i2c_nrfx_twim_transfer>:
{
   1ad1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ad20:	4604      	mov	r4, r0
   1ad22:	b087      	sub	sp, #28
   1ad24:	460d      	mov	r5, r1
   1ad26:	4691      	mov	r9, r2
   1ad28:	469a      	mov	sl, r3
	k_sem_take(&(get_dev_data(dev)->transfer_sync), K_FOREVER);
   1ad2a:	6880      	ldr	r0, [r0, #8]
	return z_impl_k_sem_take(sem, timeout);
   1ad2c:	f04f 31ff 	mov.w	r1, #4294967295
   1ad30:	f00d fc26 	bl	28580 <z_impl_k_sem_take>
	return dev->config->config_info;
   1ad34:	6823      	ldr	r3, [r4, #0]
	for (size_t i = 0; i < num_msgs; i++) {
   1ad36:	2600      	movs	r6, #0
	nrfx_twim_enable(&get_dev_config(dev)->twim);
   1ad38:	6898      	ldr	r0, [r3, #8]
   1ad3a:	f00a ff8d 	bl	25c58 <nrfx_twim_enable>
		if (res != NRFX_SUCCESS) {
   1ad3e:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 1ae04 <i2c_nrfx_twim_transfer+0xe8>
   1ad42:	6823      	ldr	r3, [r4, #0]
	for (size_t i = 0; i < num_msgs; i++) {
   1ad44:	454e      	cmp	r6, r9
   1ad46:	f8d3 b008 	ldr.w	fp, [r3, #8]
   1ad4a:	d301      	bcc.n	1ad50 <i2c_nrfx_twim_transfer+0x34>
	int ret = 0;
   1ad4c:	2500      	movs	r5, #0
   1ad4e:	e024      	b.n	1ad9a <i2c_nrfx_twim_transfer+0x7e>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
   1ad50:	7a2f      	ldrb	r7, [r5, #8]
   1ad52:	f017 0108 	ands.w	r1, r7, #8
   1ad56:	d14a      	bne.n	1adee <i2c_nrfx_twim_transfer+0xd2>
		nrfx_twim_xfer_desc_t cur_xfer = {
   1ad58:	2212      	movs	r2, #18
   1ad5a:	f10d 0006 	add.w	r0, sp, #6
   1ad5e:	f014 fb19 	bl	2f394 <memset>
					  NRFX_TWIM_XFER_RX : NRFX_TWIM_XFER_TX
   1ad62:	f007 0301 	and.w	r3, r7, #1
		nrfx_twim_xfer_desc_t cur_xfer = {
   1ad66:	f88d 3004 	strb.w	r3, [sp, #4]
   1ad6a:	686b      	ldr	r3, [r5, #4]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
   1ad6c:	f017 0f02 	tst.w	r7, #2
		nrfx_twim_xfer_desc_t cur_xfer = {
   1ad70:	9302      	str	r3, [sp, #8]
   1ad72:	682b      	ldr	r3, [r5, #0]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
   1ad74:	bf0c      	ite	eq
   1ad76:	2220      	moveq	r2, #32
   1ad78:	2200      	movne	r2, #0
   1ad7a:	a901      	add	r1, sp, #4
   1ad7c:	4658      	mov	r0, fp
		nrfx_twim_xfer_desc_t cur_xfer = {
   1ad7e:	f88d a005 	strb.w	sl, [sp, #5]
   1ad82:	9304      	str	r3, [sp, #16]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
   1ad84:	f00a ffb6 	bl	25cf4 <nrfx_twim_xfer>
		if (res != NRFX_SUCCESS) {
   1ad88:	4540      	cmp	r0, r8
   1ad8a:	d011      	beq.n	1adb0 <i2c_nrfx_twim_transfer+0x94>
			if (res == NRFX_ERROR_BUSY) {
   1ad8c:	4b19      	ldr	r3, [pc, #100]	; (1adf4 <i2c_nrfx_twim_transfer+0xd8>)
				ret = -EIO;
   1ad8e:	4298      	cmp	r0, r3
   1ad90:	bf0c      	ite	eq
   1ad92:	f06f 050f 	mvneq.w	r5, #15
   1ad96:	f06f 0504 	mvnne.w	r5, #4
	return dev->config->config_info;
   1ad9a:	6823      	ldr	r3, [r4, #0]
	nrfx_twim_disable(&get_dev_config(dev)->twim);
   1ad9c:	6898      	ldr	r0, [r3, #8]
   1ad9e:	f00a ff7d 	bl	25c9c <nrfx_twim_disable>
	k_sem_give(&(get_dev_data(dev)->transfer_sync));
   1ada2:	68a0      	ldr	r0, [r4, #8]
	z_impl_k_sem_give(sem);
   1ada4:	f00d fba2 	bl	284ec <z_impl_k_sem_give>
}
   1ada8:	4628      	mov	r0, r5
   1adaa:	b007      	add	sp, #28
   1adac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		k_sem_take(&(get_dev_data(dev)->completion_sync), K_FOREVER);
   1adb0:	68a0      	ldr	r0, [r4, #8]
   1adb2:	3018      	adds	r0, #24
	return z_impl_k_sem_take(sem, timeout);
   1adb4:	f04f 31ff 	mov.w	r1, #4294967295
   1adb8:	f00d fbe2 	bl	28580 <z_impl_k_sem_take>
		res = get_dev_data(dev)->res;
   1adbc:	68a3      	ldr	r3, [r4, #8]
	return dev->driver_data;
   1adbe:	350c      	adds	r5, #12
		res = get_dev_data(dev)->res;
   1adc0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
		if (res != NRFX_SUCCESS) {
   1adc2:	4542      	cmp	r2, r8
   1adc4:	d011      	beq.n	1adea <i2c_nrfx_twim_transfer+0xce>
			LOG_ERR("Error %d occurred for message %d", res, i);
   1adc6:	2301      	movs	r3, #1
   1adc8:	f04f 0000 	mov.w	r0, #0
   1adcc:	490a      	ldr	r1, [pc, #40]	; (1adf8 <i2c_nrfx_twim_transfer+0xdc>)
   1adce:	f363 0007 	bfi	r0, r3, #0, #8
   1add2:	4b0a      	ldr	r3, [pc, #40]	; (1adfc <i2c_nrfx_twim_transfer+0xe0>)
			ret = -EIO;
   1add4:	f06f 0504 	mvn.w	r5, #4
   1add8:	1ac9      	subs	r1, r1, r3
   1adda:	08c9      	lsrs	r1, r1, #3
			LOG_ERR("Error %d occurred for message %d", res, i);
   1addc:	f361 108f 	bfi	r0, r1, #6, #10
   1ade0:	4633      	mov	r3, r6
   1ade2:	4907      	ldr	r1, [pc, #28]	; (1ae00 <i2c_nrfx_twim_transfer+0xe4>)
   1ade4:	f012 fa88 	bl	2d2f8 <log_string_sync>
			break;
   1ade8:	e7d7      	b.n	1ad9a <i2c_nrfx_twim_transfer+0x7e>
	for (size_t i = 0; i < num_msgs; i++) {
   1adea:	3601      	adds	r6, #1
   1adec:	e7a9      	b.n	1ad42 <i2c_nrfx_twim_transfer+0x26>
			ret = -ENOTSUP;
   1adee:	f06f 0585 	mvn.w	r5, #133	; 0x85
   1adf2:	e7d2      	b.n	1ad9a <i2c_nrfx_twim_transfer+0x7e>
   1adf4:	0bad000b 	.word	0x0bad000b
   1adf8:	0003047c 	.word	0x0003047c
   1adfc:	0003040c 	.word	0x0003040c
   1ae00:	000335a5 	.word	0x000335a5
   1ae04:	0bad0000 	.word	0x0bad0000

0001ae08 <event_handler>:
	switch (p_event->type) {
   1ae08:	7802      	ldrb	r2, [r0, #0]
	struct i2c_nrfx_twim_data *dev_data = get_dev_data(dev);
   1ae0a:	688b      	ldr	r3, [r1, #8]
	switch (p_event->type) {
   1ae0c:	2a01      	cmp	r2, #1
   1ae0e:	d00a      	beq.n	1ae26 <event_handler+0x1e>
   1ae10:	b11a      	cbz	r2, 1ae1a <event_handler+0x12>
   1ae12:	2a02      	cmp	r2, #2
   1ae14:	d009      	beq.n	1ae2a <event_handler+0x22>
		dev_data->res = NRFX_ERROR_INTERNAL;
   1ae16:	4a06      	ldr	r2, [pc, #24]	; (1ae30 <event_handler+0x28>)
   1ae18:	e000      	b.n	1ae1c <event_handler+0x14>
		dev_data->res = NRFX_SUCCESS;
   1ae1a:	4a06      	ldr	r2, [pc, #24]	; (1ae34 <event_handler+0x2c>)
		dev_data->res = NRFX_ERROR_INTERNAL;
   1ae1c:	631a      	str	r2, [r3, #48]	; 0x30
	z_impl_k_sem_give(sem);
   1ae1e:	f103 0018 	add.w	r0, r3, #24
   1ae22:	f00d bb63 	b.w	284ec <z_impl_k_sem_give>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   1ae26:	4a04      	ldr	r2, [pc, #16]	; (1ae38 <event_handler+0x30>)
   1ae28:	e7f8      	b.n	1ae1c <event_handler+0x14>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   1ae2a:	4a04      	ldr	r2, [pc, #16]	; (1ae3c <event_handler+0x34>)
   1ae2c:	e7f6      	b.n	1ae1c <event_handler+0x14>
   1ae2e:	bf00      	nop
   1ae30:	0bad0001 	.word	0x0bad0001
   1ae34:	0bad0000 	.word	0x0bad0000
   1ae38:	0bae0001 	.word	0x0bae0001
   1ae3c:	0bae0002 	.word	0x0bae0002

0001ae40 <init_spim>:
		transfer_next_chunk(dev);
	}
}

static int init_spim(struct device *dev)
{
   1ae40:	b510      	push	{r4, lr}
   1ae42:	4604      	mov	r4, r0
	return dev->config->config_info;
   1ae44:	6803      	ldr	r3, [r0, #0]
	/* This sets only default values of frequency, mode and bit order.
	 * The proper ones are set in configure() when a transfer is started.
	 */
	nrfx_err_t result = nrfx_spim_init(&get_dev_config(dev)->spim,
   1ae46:	4a11      	ldr	r2, [pc, #68]	; (1ae8c <init_spim+0x4c>)
	return dev->config->config_info;
   1ae48:	6898      	ldr	r0, [r3, #8]
	nrfx_err_t result = nrfx_spim_init(&get_dev_config(dev)->spim,
   1ae4a:	4623      	mov	r3, r4
   1ae4c:	f100 010c 	add.w	r1, r0, #12
   1ae50:	f00a fce0 	bl	25814 <nrfx_spim_init>
					   &get_dev_config(dev)->config,
					   event_handler,
					   dev);
	if (result != NRFX_SUCCESS) {
   1ae54:	4b0e      	ldr	r3, [pc, #56]	; (1ae90 <init_spim+0x50>)
   1ae56:	4298      	cmp	r0, r3
   1ae58:	d012      	beq.n	1ae80 <init_spim+0x40>
		LOG_ERR("Failed to initialize device: %s",
   1ae5a:	2301      	movs	r3, #1
   1ae5c:	f04f 0000 	mov.w	r0, #0
   1ae60:	4a0c      	ldr	r2, [pc, #48]	; (1ae94 <init_spim+0x54>)
   1ae62:	f363 0007 	bfi	r0, r3, #0, #8
   1ae66:	4b0c      	ldr	r3, [pc, #48]	; (1ae98 <init_spim+0x58>)
   1ae68:	490c      	ldr	r1, [pc, #48]	; (1ae9c <init_spim+0x5c>)
   1ae6a:	1a9b      	subs	r3, r3, r2
   1ae6c:	08db      	lsrs	r3, r3, #3
   1ae6e:	f363 108f 	bfi	r0, r3, #6, #10
   1ae72:	6823      	ldr	r3, [r4, #0]
   1ae74:	681a      	ldr	r2, [r3, #0]
   1ae76:	f012 fa3f 	bl	2d2f8 <log_string_sync>
			    dev->config->name);
		return -EBUSY;
   1ae7a:	f06f 000f 	mvn.w	r0, #15
	get_dev_data(dev)->pm_state = DEVICE_PM_ACTIVE_STATE;
#endif
	spi_context_unlock_unconditionally(&get_dev_data(dev)->ctx);

	return 0;
}
   1ae7e:	bd10      	pop	{r4, pc}
	spi_context_unlock_unconditionally(&get_dev_data(dev)->ctx);
   1ae80:	68a0      	ldr	r0, [r4, #8]
   1ae82:	f013 f92a 	bl	2e0da <spi_context_unlock_unconditionally>
	return 0;
   1ae86:	2000      	movs	r0, #0
   1ae88:	e7f9      	b.n	1ae7e <init_spim+0x3e>
   1ae8a:	bf00      	nop
   1ae8c:	0001af2d 	.word	0x0001af2d
   1ae90:	0bad0000 	.word	0x0bad0000
   1ae94:	0003040c 	.word	0x0003040c
   1ae98:	00030514 	.word	0x00030514
   1ae9c:	000335d4 	.word	0x000335d4

0001aea0 <transfer_next_chunk>:
{
   1aea0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   1aea2:	6885      	ldr	r5, [r0, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
}

static inline size_t spi_context_longest_current_buf(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
   1aea4:	6cea      	ldr	r2, [r5, #76]	; 0x4c
   1aea6:	6d6b      	ldr	r3, [r5, #84]	; 0x54
   1aea8:	b98a      	cbnz	r2, 1aece <transfer_next_chunk+0x2e>
	if (chunk_len > 0) {
   1aeaa:	2b00      	cmp	r3, #0
   1aeac:	d133      	bne.n	1af16 <transfer_next_chunk+0x76>
	int error = 0;
   1aeae:	461c      	mov	r4, r3
	_spi_context_cs_control(ctx, on, false);
   1aeb0:	2200      	movs	r2, #0
   1aeb2:	4628      	mov	r0, r5
   1aeb4:	4611      	mov	r1, r2
   1aeb6:	f013 f8e6 	bl	2e086 <_spi_context_cs_control.isra.7>
	ctx->sync_status = status;
   1aeba:	636c      	str	r4, [r5, #52]	; 0x34
   1aebc:	f105 001c 	add.w	r0, r5, #28
   1aec0:	f00d fb14 	bl	284ec <z_impl_k_sem_give>
	dev_data->busy = false;
   1aec4:	2300      	movs	r3, #0
   1aec6:	f885 305c 	strb.w	r3, [r5, #92]	; 0x5c
}
   1aeca:	b004      	add	sp, #16
   1aecc:	bd70      	pop	{r4, r5, r6, pc}
		return ctx->rx_len;
	} else if (!ctx->rx_len) {
   1aece:	b323      	cbz	r3, 1af1a <transfer_next_chunk+0x7a>
		return ctx->tx_len;
	} else if (ctx->tx_len < ctx->rx_len) {
   1aed0:	4293      	cmp	r3, r2
   1aed2:	4619      	mov	r1, r3
   1aed4:	bf28      	it	cs
   1aed6:	4611      	movcs	r1, r2
	return dev->config->config_info;
   1aed8:	6800      	ldr	r0, [r0, #0]
		const u8_t *tx_buf = ctx->tx_buf;
   1aeda:	6cac      	ldr	r4, [r5, #72]	; 0x48
	return dev->config->config_info;
   1aedc:	6880      	ldr	r0, [r0, #8]
		xfer.p_tx_buffer = tx_buf;
   1aede:	9400      	str	r4, [sp, #0]
   1aee0:	6886      	ldr	r6, [r0, #8]
   1aee2:	42b1      	cmp	r1, r6
   1aee4:	bf28      	it	cs
   1aee6:	4631      	movcs	r1, r6
		dev_data->chunk_len = chunk_len;
   1aee8:	65a9      	str	r1, [r5, #88]	; 0x58
	return !!(ctx->tx_buf && ctx->tx_len);
   1aeea:	b1c4      	cbz	r4, 1af1e <transfer_next_chunk+0x7e>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
   1aeec:	2a00      	cmp	r2, #0
   1aeee:	bf18      	it	ne
   1aef0:	460a      	movne	r2, r1
   1aef2:	9201      	str	r2, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
   1aef4:	6d2a      	ldr	r2, [r5, #80]	; 0x50
   1aef6:	9202      	str	r2, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
   1aef8:	b19a      	cbz	r2, 1af22 <transfer_next_chunk+0x82>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   1aefa:	2b00      	cmp	r3, #0
   1aefc:	bf18      	it	ne
   1aefe:	460b      	movne	r3, r1
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
   1af00:	2200      	movs	r2, #0
   1af02:	4669      	mov	r1, sp
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   1af04:	9303      	str	r3, [sp, #12]
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
   1af06:	f00a fd3d 	bl	25984 <nrfx_spim_xfer>
			if (result == NRFX_SUCCESS) {
   1af0a:	4b07      	ldr	r3, [pc, #28]	; (1af28 <transfer_next_chunk+0x88>)
   1af0c:	4298      	cmp	r0, r3
   1af0e:	d0dc      	beq.n	1aeca <transfer_next_chunk+0x2a>
			error = -EIO;
   1af10:	f06f 0404 	mvn.w	r4, #4
   1af14:	e7cc      	b.n	1aeb0 <transfer_next_chunk+0x10>
   1af16:	4619      	mov	r1, r3
   1af18:	e7de      	b.n	1aed8 <transfer_next_chunk+0x38>
	} else if (!ctx->rx_len) {
   1af1a:	4611      	mov	r1, r2
   1af1c:	e7dc      	b.n	1aed8 <transfer_next_chunk+0x38>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
   1af1e:	4622      	mov	r2, r4
   1af20:	e7e7      	b.n	1aef2 <transfer_next_chunk+0x52>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   1af22:	4613      	mov	r3, r2
   1af24:	e7ec      	b.n	1af00 <transfer_next_chunk+0x60>
   1af26:	bf00      	nop
   1af28:	0bad0000 	.word	0x0bad0000

0001af2c <event_handler>:
{
   1af2c:	b538      	push	{r3, r4, r5, lr}
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   1af2e:	7803      	ldrb	r3, [r0, #0]
{
   1af30:	460d      	mov	r5, r1
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   1af32:	2b00      	cmp	r3, #0
   1af34:	d157      	bne.n	1afe6 <event_handler+0xba>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   1af36:	688c      	ldr	r4, [r1, #8]
	if (!ctx->tx_len) {
   1af38:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   1af3a:	b183      	cbz	r3, 1af5e <event_handler+0x32>
		spi_context_update_tx(&dev_data->ctx, 1, dev_data->chunk_len);
   1af3c:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (len > ctx->tx_len) {
   1af3e:	429a      	cmp	r2, r3
   1af40:	d925      	bls.n	1af8e <event_handler+0x62>
		LOG_ERR("Update exceeds current buffer");
   1af42:	2301      	movs	r3, #1
   1af44:	f04f 0000 	mov.w	r0, #0
   1af48:	4a27      	ldr	r2, [pc, #156]	; (1afe8 <event_handler+0xbc>)
   1af4a:	f363 0007 	bfi	r0, r3, #0, #8
   1af4e:	4b27      	ldr	r3, [pc, #156]	; (1afec <event_handler+0xc0>)
   1af50:	4927      	ldr	r1, [pc, #156]	; (1aff0 <event_handler+0xc4>)
   1af52:	1a9b      	subs	r3, r3, r2
   1af54:	08db      	lsrs	r3, r3, #3
   1af56:	f363 108f 	bfi	r0, r3, #6, #10
   1af5a:	f012 f9cd 	bl	2d2f8 <log_string_sync>
	if (!ctx->rx_len) {
   1af5e:	6d63      	ldr	r3, [r4, #84]	; 0x54
   1af60:	b183      	cbz	r3, 1af84 <event_handler+0x58>
		spi_context_update_rx(&dev_data->ctx, 1, dev_data->chunk_len);
   1af62:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (len > ctx->rx_len) {
   1af64:	429a      	cmp	r2, r3
   1af66:	d928      	bls.n	1afba <event_handler+0x8e>
		LOG_ERR("Update exceeds current buffer");
   1af68:	2301      	movs	r3, #1
   1af6a:	f04f 0000 	mov.w	r0, #0
   1af6e:	4a1e      	ldr	r2, [pc, #120]	; (1afe8 <event_handler+0xbc>)
   1af70:	f363 0007 	bfi	r0, r3, #0, #8
   1af74:	4b1d      	ldr	r3, [pc, #116]	; (1afec <event_handler+0xc0>)
   1af76:	491e      	ldr	r1, [pc, #120]	; (1aff0 <event_handler+0xc4>)
   1af78:	1a9b      	subs	r3, r3, r2
   1af7a:	08db      	lsrs	r3, r3, #3
   1af7c:	f363 108f 	bfi	r0, r3, #6, #10
   1af80:	f012 f9ba 	bl	2d2f8 <log_string_sync>
		transfer_next_chunk(dev);
   1af84:	4628      	mov	r0, r5
}
   1af86:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		transfer_next_chunk(dev);
   1af8a:	f7ff bf89 	b.w	1aea0 <transfer_next_chunk>
	ctx->tx_len -= len;
   1af8e:	1a9b      	subs	r3, r3, r2
   1af90:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (!ctx->tx_len) {
   1af92:	b963      	cbnz	r3, 1afae <event_handler+0x82>
		ctx->tx_count--;
   1af94:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1af96:	3b01      	subs	r3, #1
   1af98:	63e3      	str	r3, [r4, #60]	; 0x3c
		if (ctx->tx_count) {
   1af9a:	b163      	cbz	r3, 1afb6 <event_handler+0x8a>
			ctx->current_tx++;
   1af9c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1af9e:	f103 0208 	add.w	r2, r3, #8
   1afa2:	63a2      	str	r2, [r4, #56]	; 0x38
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   1afa4:	689a      	ldr	r2, [r3, #8]
			ctx->tx_len = ctx->current_tx->len / dfs;
   1afa6:	68db      	ldr	r3, [r3, #12]
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   1afa8:	64a2      	str	r2, [r4, #72]	; 0x48
			ctx->tx_len = ctx->current_tx->len / dfs;
   1afaa:	64e3      	str	r3, [r4, #76]	; 0x4c
   1afac:	e7d7      	b.n	1af5e <event_handler+0x32>
	} else if (ctx->tx_buf) {
   1afae:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   1afb0:	2b00      	cmp	r3, #0
   1afb2:	d0d4      	beq.n	1af5e <event_handler+0x32>
		ctx->tx_buf += dfs * len;
   1afb4:	4413      	add	r3, r2
   1afb6:	64a3      	str	r3, [r4, #72]	; 0x48
   1afb8:	e7d1      	b.n	1af5e <event_handler+0x32>
	ctx->rx_len -= len;
   1afba:	1a9b      	subs	r3, r3, r2
   1afbc:	6563      	str	r3, [r4, #84]	; 0x54
	if (!ctx->rx_len) {
   1afbe:	b963      	cbnz	r3, 1afda <event_handler+0xae>
		ctx->rx_count--;
   1afc0:	6c63      	ldr	r3, [r4, #68]	; 0x44
   1afc2:	3b01      	subs	r3, #1
   1afc4:	6463      	str	r3, [r4, #68]	; 0x44
		if (ctx->rx_count) {
   1afc6:	b163      	cbz	r3, 1afe2 <event_handler+0xb6>
			ctx->current_rx++;
   1afc8:	6c23      	ldr	r3, [r4, #64]	; 0x40
   1afca:	f103 0208 	add.w	r2, r3, #8
   1afce:	6422      	str	r2, [r4, #64]	; 0x40
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   1afd0:	689a      	ldr	r2, [r3, #8]
			ctx->rx_len = ctx->current_rx->len / dfs;
   1afd2:	68db      	ldr	r3, [r3, #12]
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   1afd4:	6522      	str	r2, [r4, #80]	; 0x50
			ctx->rx_len = ctx->current_rx->len / dfs;
   1afd6:	6563      	str	r3, [r4, #84]	; 0x54
   1afd8:	e7d4      	b.n	1af84 <event_handler+0x58>
	} else if (ctx->rx_buf) {
   1afda:	6d23      	ldr	r3, [r4, #80]	; 0x50
   1afdc:	2b00      	cmp	r3, #0
   1afde:	d0d1      	beq.n	1af84 <event_handler+0x58>
		ctx->rx_buf += dfs * len;
   1afe0:	4413      	add	r3, r2
   1afe2:	6523      	str	r3, [r4, #80]	; 0x50
   1afe4:	e7ce      	b.n	1af84 <event_handler+0x58>
}
   1afe6:	bd38      	pop	{r3, r4, r5, pc}
   1afe8:	0003040c 	.word	0x0003040c
   1afec:	00030514 	.word	0x00030514
   1aff0:	000335f4 	.word	0x000335f4

0001aff4 <spi_nrfx_transceive>:
{
   1aff4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1aff8:	4607      	mov	r7, r0
	k_sem_take(&ctx->lock, K_FOREVER);
   1affa:	6880      	ldr	r0, [r0, #8]
   1affc:	4688      	mov	r8, r1
   1affe:	4616      	mov	r6, r2
   1b000:	461d      	mov	r5, r3
   1b002:	3004      	adds	r0, #4
	return z_impl_k_sem_take(sem, timeout);
   1b004:	f04f 31ff 	mov.w	r1, #4294967295
   1b008:	f00d faba 	bl	28580 <z_impl_k_sem_take>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   1b00c:	68bc      	ldr	r4, [r7, #8]
	if (spi_context_configured(ctx, spi_cfg)) {
   1b00e:	6823      	ldr	r3, [r4, #0]
   1b010:	4598      	cmp	r8, r3
   1b012:	f000 80b0 	beq.w	1b176 <spi_nrfx_transceive+0x182>
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
   1b016:	f8b8 3004 	ldrh.w	r3, [r8, #4]
	const nrfx_spim_t *spim = &get_dev_config(dev)->spim;
   1b01a:	683a      	ldr	r2, [r7, #0]
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
   1b01c:	07d8      	lsls	r0, r3, #31
   1b01e:	d516      	bpl.n	1b04e <spi_nrfx_transceive+0x5a>
		LOG_ERR("Slave mode is not supported on %s",
   1b020:	2301      	movs	r3, #1
   1b022:	f04f 0000 	mov.w	r0, #0
   1b026:	4981      	ldr	r1, [pc, #516]	; (1b22c <spi_nrfx_transceive+0x238>)
   1b028:	f363 0007 	bfi	r0, r3, #0, #8
   1b02c:	4b80      	ldr	r3, [pc, #512]	; (1b230 <spi_nrfx_transceive+0x23c>)
   1b02e:	6812      	ldr	r2, [r2, #0]
   1b030:	1a5b      	subs	r3, r3, r1
   1b032:	08db      	lsrs	r3, r3, #3
   1b034:	f363 108f 	bfi	r0, r3, #6, #10
   1b038:	497e      	ldr	r1, [pc, #504]	; (1b234 <spi_nrfx_transceive+0x240>)
   1b03a:	f012 f95d 	bl	2d2f8 <log_string_sync>
		return -EINVAL;
   1b03e:	f06f 0515 	mvn.w	r5, #21
	z_impl_k_sem_give(sem);
   1b042:	1d20      	adds	r0, r4, #4
   1b044:	f00d fa52 	bl	284ec <z_impl_k_sem_give>
}
   1b048:	4628      	mov	r0, r5
   1b04a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (spi_cfg->operation & SPI_MODE_LOOP) {
   1b04e:	0719      	lsls	r1, r3, #28
   1b050:	d50e      	bpl.n	1b070 <spi_nrfx_transceive+0x7c>
		LOG_ERR("Loopback mode is not supported");
   1b052:	2301      	movs	r3, #1
   1b054:	f04f 0000 	mov.w	r0, #0
   1b058:	4a74      	ldr	r2, [pc, #464]	; (1b22c <spi_nrfx_transceive+0x238>)
   1b05a:	f363 0007 	bfi	r0, r3, #0, #8
   1b05e:	4b74      	ldr	r3, [pc, #464]	; (1b230 <spi_nrfx_transceive+0x23c>)
   1b060:	4975      	ldr	r1, [pc, #468]	; (1b238 <spi_nrfx_transceive+0x244>)
   1b062:	1a9b      	subs	r3, r3, r2
   1b064:	08db      	lsrs	r3, r3, #3
   1b066:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Word sizes other than 8 bits"
   1b06a:	f012 f945 	bl	2d2f8 <log_string_sync>
   1b06e:	e7e6      	b.n	1b03e <spi_nrfx_transceive+0x4a>
	if ((spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
   1b070:	f413 51c0 	ands.w	r1, r3, #6144	; 0x1800
   1b074:	d00c      	beq.n	1b090 <spi_nrfx_transceive+0x9c>
		LOG_ERR("Only single line mode is supported");
   1b076:	2301      	movs	r3, #1
   1b078:	f04f 0000 	mov.w	r0, #0
   1b07c:	4a6b      	ldr	r2, [pc, #428]	; (1b22c <spi_nrfx_transceive+0x238>)
   1b07e:	f363 0007 	bfi	r0, r3, #0, #8
   1b082:	4b6b      	ldr	r3, [pc, #428]	; (1b230 <spi_nrfx_transceive+0x23c>)
   1b084:	496d      	ldr	r1, [pc, #436]	; (1b23c <spi_nrfx_transceive+0x248>)
   1b086:	1a9b      	subs	r3, r3, r2
   1b088:	08db      	lsrs	r3, r3, #3
   1b08a:	f363 108f 	bfi	r0, r3, #6, #10
   1b08e:	e7ec      	b.n	1b06a <spi_nrfx_transceive+0x76>
	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
   1b090:	f3c3 1345 	ubfx	r3, r3, #5, #6
   1b094:	2b08      	cmp	r3, #8
   1b096:	d00c      	beq.n	1b0b2 <spi_nrfx_transceive+0xbe>
		LOG_ERR("Word sizes other than 8 bits"
   1b098:	2301      	movs	r3, #1
   1b09a:	f04f 0000 	mov.w	r0, #0
   1b09e:	4a63      	ldr	r2, [pc, #396]	; (1b22c <spi_nrfx_transceive+0x238>)
   1b0a0:	f363 0007 	bfi	r0, r3, #0, #8
   1b0a4:	4b62      	ldr	r3, [pc, #392]	; (1b230 <spi_nrfx_transceive+0x23c>)
   1b0a6:	4966      	ldr	r1, [pc, #408]	; (1b240 <spi_nrfx_transceive+0x24c>)
   1b0a8:	1a9b      	subs	r3, r3, r2
   1b0aa:	08db      	lsrs	r3, r3, #3
   1b0ac:	f363 108f 	bfi	r0, r3, #6, #10
   1b0b0:	e7db      	b.n	1b06a <spi_nrfx_transceive+0x76>
	if (spi_cfg->frequency < 125000) {
   1b0b2:	f8d8 0000 	ldr.w	r0, [r8]
   1b0b6:	4b63      	ldr	r3, [pc, #396]	; (1b244 <spi_nrfx_transceive+0x250>)
   1b0b8:	4298      	cmp	r0, r3
   1b0ba:	d80c      	bhi.n	1b0d6 <spi_nrfx_transceive+0xe2>
		LOG_ERR("Frequencies lower than 125 kHz are not supported");
   1b0bc:	2301      	movs	r3, #1
   1b0be:	f04f 0000 	mov.w	r0, #0
   1b0c2:	4a5a      	ldr	r2, [pc, #360]	; (1b22c <spi_nrfx_transceive+0x238>)
   1b0c4:	f363 0007 	bfi	r0, r3, #0, #8
   1b0c8:	4b59      	ldr	r3, [pc, #356]	; (1b230 <spi_nrfx_transceive+0x23c>)
   1b0ca:	495f      	ldr	r1, [pc, #380]	; (1b248 <spi_nrfx_transceive+0x254>)
   1b0cc:	1a9b      	subs	r3, r3, r2
   1b0ce:	08db      	lsrs	r3, r3, #3
   1b0d0:	f363 108f 	bfi	r0, r3, #6, #10
   1b0d4:	e7c9      	b.n	1b06a <spi_nrfx_transceive+0x76>
	if (ctx->config->cs && ctx->config->cs->gpio_dev) {
   1b0d6:	f8d8 3008 	ldr.w	r3, [r8, #8]
	return dev->config->config_info;
   1b0da:	f8d2 9008 	ldr.w	r9, [r2, #8]
	ctx->config = spi_cfg;
   1b0de:	f8c4 8000 	str.w	r8, [r4]
   1b0e2:	2b00      	cmp	r3, #0
   1b0e4:	d06f      	beq.n	1b1c6 <spi_nrfx_transceive+0x1d2>
   1b0e6:	6818      	ldr	r0, [r3, #0]
   1b0e8:	2800      	cmp	r0, #0
   1b0ea:	d06c      	beq.n	1b1c6 <spi_nrfx_transceive+0x1d2>
		gpio_pin_configure(ctx->config->cs->gpio_dev,
   1b0ec:	685a      	ldr	r2, [r3, #4]
	return api->config(port, access_op, pin, flags);
   1b0ee:	6843      	ldr	r3, [r0, #4]
   1b0f0:	f8d3 a000 	ldr.w	sl, [r3]
   1b0f4:	2301      	movs	r3, #1
   1b0f6:	47d0      	blx	sl
		gpio_pin_write(ctx->config->cs->gpio_dev,
   1b0f8:	6822      	ldr	r2, [r4, #0]
   1b0fa:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   1b0fc:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
		gpio_pin_write(ctx->config->cs->gpio_dev,
   1b100:	e9d3 0100 	ldrd	r0, r1, [r3]
   1b104:	43d2      	mvns	r2, r2
   1b106:	0fd2      	lsrs	r2, r2, #31
   1b108:	f012 ffb3 	bl	2e072 <gpio_pin_write>
	nrf_spim_configure(spim->p_reg,
   1b10c:	f8b8 3004 	ldrh.w	r3, [r8, #4]
   1b110:	f8d9 1000 	ldr.w	r1, [r9]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
   1b114:	0798      	lsls	r0, r3, #30
   1b116:	f003 0204 	and.w	r2, r3, #4
   1b11a:	d563      	bpl.n	1b1e4 <spi_nrfx_transceive+0x1f0>
			return NRF_SPIM_MODE_2;
   1b11c:	2a00      	cmp	r2, #0
   1b11e:	bf14      	ite	ne
   1b120:	2203      	movne	r2, #3
   1b122:	2202      	moveq	r2, #2
                                          nrf_spim_mode_t      spi_mode,
                                          nrf_spim_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPIM_BIT_ORDER_MSB_FIRST ?
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
    switch (spi_mode)
   1b124:	2a02      	cmp	r2, #2
	if (operation & SPI_TRANSFER_LSB) {
   1b126:	f3c3 1300 	ubfx	r3, r3, #4, #1
   1b12a:	d05f      	beq.n	1b1ec <spi_nrfx_transceive+0x1f8>
   1b12c:	2a03      	cmp	r2, #3
   1b12e:	d060      	beq.n	1b1f2 <spi_nrfx_transceive+0x1fe>
   1b130:	2a01      	cmp	r2, #1
   1b132:	d101      	bne.n	1b138 <spi_nrfx_transceive+0x144>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Leading    << SPIM_CONFIG_CPHA_Pos);
        break;

    case NRF_SPIM_MODE_1:
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
   1b134:	f043 0302 	orr.w	r3, r3, #2
    case NRF_SPIM_MODE_3:
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Trailing   << SPIM_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
   1b138:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
	if (frequency < 250000) {
   1b13c:	4a43      	ldr	r2, [pc, #268]	; (1b24c <spi_nrfx_transceive+0x258>)
	nrf_spim_frequency_set(spim->p_reg,
   1b13e:	f8d8 3000 	ldr.w	r3, [r8]
	if (frequency < 250000) {
   1b142:	4293      	cmp	r3, r2
   1b144:	d958      	bls.n	1b1f8 <spi_nrfx_transceive+0x204>
	} else if (frequency < 500000) {
   1b146:	4a42      	ldr	r2, [pc, #264]	; (1b250 <spi_nrfx_transceive+0x25c>)
   1b148:	4293      	cmp	r3, r2
   1b14a:	d958      	bls.n	1b1fe <spi_nrfx_transceive+0x20a>
	} else if (frequency < 1000000) {
   1b14c:	4a41      	ldr	r2, [pc, #260]	; (1b254 <spi_nrfx_transceive+0x260>)
   1b14e:	4293      	cmp	r3, r2
   1b150:	d958      	bls.n	1b204 <spi_nrfx_transceive+0x210>
	} else if (frequency < 2000000) {
   1b152:	4a41      	ldr	r2, [pc, #260]	; (1b258 <spi_nrfx_transceive+0x264>)
   1b154:	4293      	cmp	r3, r2
   1b156:	d958      	bls.n	1b20a <spi_nrfx_transceive+0x216>
	} else if (frequency < 4000000) {
   1b158:	4a40      	ldr	r2, [pc, #256]	; (1b25c <spi_nrfx_transceive+0x268>)
   1b15a:	4293      	cmp	r3, r2
   1b15c:	d958      	bls.n	1b210 <spi_nrfx_transceive+0x21c>
		return NRF_SPIM_FREQ_8M;
   1b15e:	f502 1274 	add.w	r2, r2, #3997696	; 0x3d0000
   1b162:	f502 6210 	add.w	r2, r2, #2304	; 0x900
   1b166:	4293      	cmp	r3, r2
   1b168:	bf94      	ite	ls
   1b16a:	f04f 4380 	movls.w	r3, #1073741824	; 0x40000000
   1b16e:	f04f 4300 	movhi.w	r3, #2147483648	; 0x80000000
    p_reg->FREQUENCY = (uint32_t)frequency;
   1b172:	f8c1 3524 	str.w	r3, [r1, #1316]	; 0x524
		dev_data->busy = true;
   1b176:	2301      	movs	r3, #1
   1b178:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
	if (tx_bufs) {
   1b17c:	2e00      	cmp	r6, #0
   1b17e:	d04a      	beq.n	1b216 <spi_nrfx_transceive+0x222>
		ctx->current_tx = tx_bufs->buffers;
   1b180:	6833      	ldr	r3, [r6, #0]
		ctx->tx_count = tx_bufs->count;
   1b182:	6872      	ldr	r2, [r6, #4]
		ctx->current_tx = tx_bufs->buffers;
   1b184:	63a3      	str	r3, [r4, #56]	; 0x38
		ctx->tx_count = tx_bufs->count;
   1b186:	63e2      	str	r2, [r4, #60]	; 0x3c
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   1b188:	681a      	ldr	r2, [r3, #0]
		ctx->tx_len = ctx->current_tx->len / dfs;
   1b18a:	685b      	ldr	r3, [r3, #4]
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   1b18c:	64a2      	str	r2, [r4, #72]	; 0x48
		ctx->tx_len = ctx->current_tx->len / dfs;
   1b18e:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (rx_bufs) {
   1b190:	2d00      	cmp	r5, #0
   1b192:	d045      	beq.n	1b220 <spi_nrfx_transceive+0x22c>
		ctx->current_rx = rx_bufs->buffers;
   1b194:	682b      	ldr	r3, [r5, #0]
		ctx->rx_count = rx_bufs->count;
   1b196:	686a      	ldr	r2, [r5, #4]
		ctx->current_rx = rx_bufs->buffers;
   1b198:	6423      	str	r3, [r4, #64]	; 0x40
		ctx->rx_count = rx_bufs->count;
   1b19a:	6462      	str	r2, [r4, #68]	; 0x44
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   1b19c:	681a      	ldr	r2, [r3, #0]
		ctx->rx_len = ctx->current_rx->len / dfs;
   1b19e:	685b      	ldr	r3, [r3, #4]
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   1b1a0:	6522      	str	r2, [r4, #80]	; 0x50
		ctx->rx_len = ctx->current_rx->len / dfs;
   1b1a2:	6563      	str	r3, [r4, #84]	; 0x54
	ctx->sync_status = 0;
   1b1a4:	2200      	movs	r2, #0
	_spi_context_cs_control(ctx, on, false);
   1b1a6:	2101      	movs	r1, #1
	ctx->sync_status = 0;
   1b1a8:	6362      	str	r2, [r4, #52]	; 0x34
	_spi_context_cs_control(ctx, on, false);
   1b1aa:	4620      	mov	r0, r4
   1b1ac:	f012 ff6b 	bl	2e086 <_spi_context_cs_control.isra.7>
		transfer_next_chunk(dev);
   1b1b0:	4638      	mov	r0, r7
   1b1b2:	f7ff fe75 	bl	1aea0 <transfer_next_chunk>
	return z_impl_k_sem_take(sem, timeout);
   1b1b6:	f04f 31ff 	mov.w	r1, #4294967295
   1b1ba:	f104 001c 	add.w	r0, r4, #28
   1b1be:	f00d f9df 	bl	28580 <z_impl_k_sem_take>
	status = ctx->sync_status;
   1b1c2:	6b65      	ldr	r5, [r4, #52]	; 0x34
	return status;
   1b1c4:	e73d      	b.n	1b042 <spi_nrfx_transceive+0x4e>
		LOG_INF("CS control inhibited (no GPIO device)");
   1b1c6:	2303      	movs	r3, #3
   1b1c8:	f04f 0000 	mov.w	r0, #0
   1b1cc:	4a17      	ldr	r2, [pc, #92]	; (1b22c <spi_nrfx_transceive+0x238>)
   1b1ce:	f363 0007 	bfi	r0, r3, #0, #8
   1b1d2:	4b17      	ldr	r3, [pc, #92]	; (1b230 <spi_nrfx_transceive+0x23c>)
   1b1d4:	4922      	ldr	r1, [pc, #136]	; (1b260 <spi_nrfx_transceive+0x26c>)
   1b1d6:	1a9b      	subs	r3, r3, r2
   1b1d8:	08db      	lsrs	r3, r3, #3
   1b1da:	f363 108f 	bfi	r0, r3, #6, #10
   1b1de:	f012 f88b 	bl	2d2f8 <log_string_sync>
   1b1e2:	e793      	b.n	1b10c <spi_nrfx_transceive+0x118>
			return NRF_SPIM_MODE_0;
   1b1e4:	3200      	adds	r2, #0
   1b1e6:	bf18      	it	ne
   1b1e8:	2201      	movne	r2, #1
   1b1ea:	e79b      	b.n	1b124 <spi_nrfx_transceive+0x130>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   1b1ec:	f043 0304 	orr.w	r3, r3, #4
        break;
   1b1f0:	e7a2      	b.n	1b138 <spi_nrfx_transceive+0x144>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   1b1f2:	f043 0306 	orr.w	r3, r3, #6
        break;
   1b1f6:	e79f      	b.n	1b138 <spi_nrfx_transceive+0x144>
		return NRF_SPIM_FREQ_125K;
   1b1f8:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   1b1fc:	e7b9      	b.n	1b172 <spi_nrfx_transceive+0x17e>
		return NRF_SPIM_FREQ_250K;
   1b1fe:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   1b202:	e7b6      	b.n	1b172 <spi_nrfx_transceive+0x17e>
		return NRF_SPIM_FREQ_500K;
   1b204:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
   1b208:	e7b3      	b.n	1b172 <spi_nrfx_transceive+0x17e>
		return NRF_SPIM_FREQ_1M;
   1b20a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   1b20e:	e7b0      	b.n	1b172 <spi_nrfx_transceive+0x17e>
		return NRF_SPIM_FREQ_2M;
   1b210:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
   1b214:	e7ad      	b.n	1b172 <spi_nrfx_transceive+0x17e>
		ctx->tx_count = 0;
   1b216:	e9c4 660e 	strd	r6, r6, [r4, #56]	; 0x38
		ctx->tx_len = 0;
   1b21a:	e9c4 6612 	strd	r6, r6, [r4, #72]	; 0x48
   1b21e:	e7b7      	b.n	1b190 <spi_nrfx_transceive+0x19c>
		ctx->rx_count = 0;
   1b220:	e9c4 5510 	strd	r5, r5, [r4, #64]	; 0x40
		ctx->rx_len = 0;
   1b224:	e9c4 5514 	strd	r5, r5, [r4, #80]	; 0x50
   1b228:	e7bc      	b.n	1b1a4 <spi_nrfx_transceive+0x1b0>
   1b22a:	bf00      	nop
   1b22c:	0003040c 	.word	0x0003040c
   1b230:	00030514 	.word	0x00030514
   1b234:	00033612 	.word	0x00033612
   1b238:	00033634 	.word	0x00033634
   1b23c:	00033653 	.word	0x00033653
   1b240:	00033676 	.word	0x00033676
   1b244:	0001e847 	.word	0x0001e847
   1b248:	000336a5 	.word	0x000336a5
   1b24c:	0003d08f 	.word	0x0003d08f
   1b250:	0007a11f 	.word	0x0007a11f
   1b254:	000f423f 	.word	0x000f423f
   1b258:	001e847f 	.word	0x001e847f
   1b25c:	003d08ff 	.word	0x003d08ff
   1b260:	000336d6 	.word	0x000336d6

0001b264 <flash_nrf_pages_layout>:

static void flash_nrf_pages_layout(struct device *dev,
				     const struct flash_pages_layout **layout,
				     size_t *layout_size)
{
	*layout = &dev_layout;
   1b264:	4b02      	ldr	r3, [pc, #8]	; (1b270 <flash_nrf_pages_layout+0xc>)
   1b266:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
   1b268:	2301      	movs	r3, #1
   1b26a:	6013      	str	r3, [r2, #0]
}
   1b26c:	4770      	bx	lr
   1b26e:	bf00      	nop
   1b270:	20028770 	.word	0x20028770

0001b274 <flash_nrf_erase>:
{
   1b274:	b570      	push	{r4, r5, r6, lr}
   1b276:	460d      	mov	r5, r1
   1b278:	4614      	mov	r4, r2
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   1b27a:	f013 fe3b 	bl	2eef4 <nrfx_nvmc_flash_page_size_get>
	if (is_regular_addr_valid(addr, size)) {
   1b27e:	4621      	mov	r1, r4
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   1b280:	4606      	mov	r6, r0
	if (is_regular_addr_valid(addr, size)) {
   1b282:	4628      	mov	r0, r5
   1b284:	f012 ff63 	bl	2e14e <is_regular_addr_valid>
   1b288:	b1f0      	cbz	r0, 1b2c8 <flash_nrf_erase+0x54>
		if (((addr % pg_size) != 0) || ((size % pg_size) != 0)) {
   1b28a:	fbb5 f3f6 	udiv	r3, r5, r6
   1b28e:	fb06 5313 	mls	r3, r6, r3, r5
   1b292:	b9cb      	cbnz	r3, 1b2c8 <flash_nrf_erase+0x54>
   1b294:	fbb4 f0f6 	udiv	r0, r4, r6
   1b298:	fb06 4010 	mls	r0, r6, r0, r4
   1b29c:	b9a0      	cbnz	r0, 1b2c8 <flash_nrf_erase+0x54>
		if (!n_pages) {
   1b29e:	42a6      	cmp	r6, r4
   1b2a0:	d811      	bhi.n	1b2c6 <flash_nrf_erase+0x52>
   1b2a2:	f04f 31ff 	mov.w	r1, #4294967295
   1b2a6:	480a      	ldr	r0, [pc, #40]	; (1b2d0 <flash_nrf_erase+0x5c>)
   1b2a8:	f00d f96a 	bl	28580 <z_impl_k_sem_take>

#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

static int erase_op(void *context)
{
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   1b2ac:	f013 fe22 	bl	2eef4 <nrfx_nvmc_flash_page_size_get>
   1b2b0:	4606      	mov	r6, r0
		return FLASH_OP_DONE;
	}
#endif

	do {
		(void)nrfx_nvmc_page_erase(e_ctx->flash_addr);
   1b2b2:	4628      	mov	r0, r5
   1b2b4:	f00a fa28 	bl	25708 <nrfx_nvmc_page_erase>
				break;
			}
		}
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

	} while (e_ctx->len > 0);
   1b2b8:	1ba4      	subs	r4, r4, r6
   1b2ba:	4435      	add	r5, r6
   1b2bc:	d1f9      	bne.n	1b2b2 <flash_nrf_erase+0x3e>
	z_impl_k_sem_give(sem);
   1b2be:	4804      	ldr	r0, [pc, #16]	; (1b2d0 <flash_nrf_erase+0x5c>)
   1b2c0:	f00d f914 	bl	284ec <z_impl_k_sem_give>
	return ret;
   1b2c4:	4620      	mov	r0, r4
}
   1b2c6:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   1b2c8:	f06f 0015 	mvn.w	r0, #21
   1b2cc:	e7fb      	b.n	1b2c6 <flash_nrf_erase+0x52>
   1b2ce:	bf00      	nop
   1b2d0:	20028778 	.word	0x20028778

0001b2d4 <nrf_flash_init>:
{
   1b2d4:	b510      	push	{r4, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
   1b2d6:	2201      	movs	r2, #1
   1b2d8:	4806      	ldr	r0, [pc, #24]	; (1b2f4 <nrf_flash_init+0x20>)
   1b2da:	4611      	mov	r1, r2
   1b2dc:	f013 feea 	bl	2f0b4 <z_impl_k_sem_init>
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
   1b2e0:	f013 fe0b 	bl	2eefa <nrfx_nvmc_flash_page_count_get>
   1b2e4:	4c04      	ldr	r4, [pc, #16]	; (1b2f8 <nrf_flash_init+0x24>)
   1b2e6:	6020      	str	r0, [r4, #0]
	dev_layout.pages_size = nrfx_nvmc_flash_page_size_get();
   1b2e8:	f013 fe04 	bl	2eef4 <nrfx_nvmc_flash_page_size_get>
   1b2ec:	6060      	str	r0, [r4, #4]
}
   1b2ee:	2000      	movs	r0, #0
   1b2f0:	bd10      	pop	{r4, pc}
   1b2f2:	bf00      	nop
   1b2f4:	20028778 	.word	0x20028778
   1b2f8:	20028770 	.word	0x20028770

0001b2fc <flash_nrf_write>:
{
   1b2fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b2fe:	460e      	mov	r6, r1
	if (is_regular_addr_valid(addr, len)) {
   1b300:	4619      	mov	r1, r3
   1b302:	4630      	mov	r0, r6
{
   1b304:	4617      	mov	r7, r2
   1b306:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   1b308:	f012 ff21 	bl	2e14e <is_regular_addr_valid>
   1b30c:	b1f8      	cbz	r0, 1b34e <flash_nrf_write+0x52>
	return (data & 0x3) ? false : true;
   1b30e:	ea46 0504 	orr.w	r5, r6, r4
	if (!is_aligned_32(addr) || (len % sizeof(u32_t))) {
   1b312:	f015 0503 	ands.w	r5, r5, #3
   1b316:	d11a      	bne.n	1b34e <flash_nrf_write+0x52>
	if (!len) {
   1b318:	b1e4      	cbz	r4, 1b354 <flash_nrf_write+0x58>
	return z_impl_k_sem_take(sem, timeout);
   1b31a:	f04f 31ff 	mov.w	r1, #4294967295
   1b31e:	480e      	ldr	r0, [pc, #56]	; (1b358 <flash_nrf_write+0x5c>)
   1b320:	f00d f92e 	bl	28580 <z_impl_k_sem_take>
	w_ctx->flash_addr += shift;
	w_ctx->data_addr += shift;
	w_ctx->len -= shift;
}

static int write_op(void *context)
   1b324:	f024 0403 	bic.w	r4, r4, #3
		}
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */
	}
#endif /* CONFIG_SOC_FLASH_NRF_EMULATE_ONE_BYTE_WRITE_ACCESS */
	/* Write all the 4-byte aligned data */
	while (w_ctx->len >= sizeof(u32_t)) {
   1b328:	42a5      	cmp	r5, r4
   1b32a:	eb06 0005 	add.w	r0, r6, r5
   1b32e:	d109      	bne.n	1b344 <flash_nrf_write+0x48>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrf_nvmc_ready_check(NRF_NVMC_Type const * p_reg)
{
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   1b330:	4a0a      	ldr	r2, [pc, #40]	; (1b35c <flash_nrf_write+0x60>)
   1b332:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
   1b336:	07db      	lsls	r3, r3, #31
   1b338:	d5fb      	bpl.n	1b332 <flash_nrf_write+0x36>
	z_impl_k_sem_give(sem);
   1b33a:	4807      	ldr	r0, [pc, #28]	; (1b358 <flash_nrf_write+0x5c>)
   1b33c:	f00d f8d6 	bl	284ec <z_impl_k_sem_give>
   1b340:	2000      	movs	r0, #0
}
   1b342:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		nrfx_nvmc_word_write(w_ctx->flash_addr,
   1b344:	5979      	ldr	r1, [r7, r5]
   1b346:	f00a fa0b 	bl	25760 <nrfx_nvmc_word_write>
	w_ctx->len -= shift;
   1b34a:	3504      	adds	r5, #4
   1b34c:	e7ec      	b.n	1b328 <flash_nrf_write+0x2c>
		return -EINVAL;
   1b34e:	f06f 0015 	mvn.w	r0, #21
   1b352:	e7f6      	b.n	1b342 <flash_nrf_write+0x46>
		return 0;
   1b354:	4620      	mov	r0, r4
   1b356:	e7f4      	b.n	1b342 <flash_nrf_write+0x46>
   1b358:	20028778 	.word	0x20028778
   1b35c:	40039000 	.word	0x40039000

0001b360 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(struct device *dev,
				const struct uart_config *cfg)
{
   1b360:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
   1b362:	794b      	ldrb	r3, [r1, #5]
   1b364:	2b01      	cmp	r3, #1
   1b366:	d029      	beq.n	1b3bc <uarte_nrfx_configure+0x5c>
   1b368:	2b03      	cmp	r3, #3
   1b36a:	d124      	bne.n	1b3b6 <uarte_nrfx_configure+0x56>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
   1b36c:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   1b36e:	798b      	ldrb	r3, [r1, #6]
   1b370:	2b03      	cmp	r3, #3
   1b372:	d120      	bne.n	1b3b6 <uarte_nrfx_configure+0x56>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
   1b374:	79cc      	ldrb	r4, [r1, #7]
   1b376:	b12c      	cbz	r4, 1b384 <uarte_nrfx_configure+0x24>
   1b378:	2c01      	cmp	r4, #1
   1b37a:	d11c      	bne.n	1b3b6 <uarte_nrfx_configure+0x56>
	return dev->config->config_info;
   1b37c:	6803      	ldr	r3, [r0, #0]
	case UART_CFG_FLOW_CTRL_NONE:
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
		break;
	case UART_CFG_FLOW_CTRL_RTS_CTS:
		if (get_dev_config(dev)->rts_cts_pins_set) {
   1b37e:	689b      	ldr	r3, [r3, #8]
   1b380:	791b      	ldrb	r3, [r3, #4]
   1b382:	b1c3      	cbz	r3, 1b3b6 <uarte_nrfx_configure+0x56>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
   1b384:	790a      	ldrb	r2, [r1, #4]
   1b386:	b112      	cbz	r2, 1b38e <uarte_nrfx_configure+0x2e>
   1b388:	2a02      	cmp	r2, #2
   1b38a:	d114      	bne.n	1b3b6 <uarte_nrfx_configure+0x56>
	case UART_CFG_PARITY_NONE:
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
   1b38c:	220e      	movs	r2, #14
	switch (baudrate) {
   1b38e:	f647 2712 	movw	r7, #31250	; 0x7a12
	return dev->config->config_info;
   1b392:	6805      	ldr	r5, [r0, #0]
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
   1b394:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
   1b396:	68ad      	ldr	r5, [r5, #8]
	switch (baudrate) {
   1b398:	42bb      	cmp	r3, r7
	return config->uarte_regs;
   1b39a:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
   1b39c:	d062      	beq.n	1b464 <uarte_nrfx_configure+0x104>
   1b39e:	d829      	bhi.n	1b3f4 <uarte_nrfx_configure+0x94>
   1b3a0:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
   1b3a4:	d061      	beq.n	1b46a <uarte_nrfx_configure+0x10a>
   1b3a6:	d814      	bhi.n	1b3d2 <uarte_nrfx_configure+0x72>
   1b3a8:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
   1b3ac:	d05f      	beq.n	1b46e <uarte_nrfx_configure+0x10e>
   1b3ae:	d807      	bhi.n	1b3c0 <uarte_nrfx_configure+0x60>
   1b3b0:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   1b3b4:	d05e      	beq.n	1b474 <uarte_nrfx_configure+0x114>
		return -ENOTSUP;
   1b3b6:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1b3ba:	e052      	b.n	1b462 <uarte_nrfx_configure+0x102>
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
   1b3bc:	2600      	movs	r6, #0
   1b3be:	e7d6      	b.n	1b36e <uarte_nrfx_configure+0xe>
	switch (baudrate) {
   1b3c0:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
   1b3c4:	d059      	beq.n	1b47a <uarte_nrfx_configure+0x11a>
   1b3c6:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
   1b3ca:	d1f4      	bne.n	1b3b6 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
   1b3cc:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
   1b3d0:	e03c      	b.n	1b44c <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   1b3d2:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
   1b3d6:	d053      	beq.n	1b480 <uarte_nrfx_configure+0x120>
   1b3d8:	d804      	bhi.n	1b3e4 <uarte_nrfx_configure+0x84>
   1b3da:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   1b3de:	d1ea      	bne.n	1b3b6 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
   1b3e0:	4b32      	ldr	r3, [pc, #200]	; (1b4ac <uarte_nrfx_configure+0x14c>)
   1b3e2:	e033      	b.n	1b44c <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   1b3e4:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
   1b3e8:	d04c      	beq.n	1b484 <uarte_nrfx_configure+0x124>
   1b3ea:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
   1b3ee:	d1e2      	bne.n	1b3b6 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
   1b3f0:	4b2f      	ldr	r3, [pc, #188]	; (1b4b0 <uarte_nrfx_configure+0x150>)
   1b3f2:	e02b      	b.n	1b44c <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   1b3f4:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
   1b3f8:	d046      	beq.n	1b488 <uarte_nrfx_configure+0x128>
   1b3fa:	d812      	bhi.n	1b422 <uarte_nrfx_configure+0xc2>
   1b3fc:	f64d 27c0 	movw	r7, #56000	; 0xdac0
   1b400:	42bb      	cmp	r3, r7
   1b402:	d044      	beq.n	1b48e <uarte_nrfx_configure+0x12e>
   1b404:	d805      	bhi.n	1b412 <uarte_nrfx_configure+0xb2>
   1b406:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
   1b40a:	d1d4      	bne.n	1b3b6 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
   1b40c:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
   1b410:	e01c      	b.n	1b44c <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   1b412:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   1b416:	d03d      	beq.n	1b494 <uarte_nrfx_configure+0x134>
   1b418:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
   1b41c:	d1cb      	bne.n	1b3b6 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
   1b41e:	4b25      	ldr	r3, [pc, #148]	; (1b4b4 <uarte_nrfx_configure+0x154>)
   1b420:	e014      	b.n	1b44c <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   1b422:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
   1b426:	d038      	beq.n	1b49a <uarte_nrfx_configure+0x13a>
   1b428:	d808      	bhi.n	1b43c <uarte_nrfx_configure+0xdc>
   1b42a:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   1b42e:	d037      	beq.n	1b4a0 <uarte_nrfx_configure+0x140>
   1b430:	4f21      	ldr	r7, [pc, #132]	; (1b4b8 <uarte_nrfx_configure+0x158>)
   1b432:	42bb      	cmp	r3, r7
   1b434:	d1bf      	bne.n	1b3b6 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
   1b436:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   1b43a:	e007      	b.n	1b44c <uarte_nrfx_configure+0xec>
	switch (baudrate) {
   1b43c:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
   1b440:	d031      	beq.n	1b4a6 <uarte_nrfx_configure+0x146>
   1b442:	4f1e      	ldr	r7, [pc, #120]	; (1b4bc <uarte_nrfx_configure+0x15c>)
   1b444:	42bb      	cmp	r3, r7
   1b446:	d1b6      	bne.n	1b3b6 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
   1b448:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
   1b44c:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
                    | (uint32_t)p_cfg->hwfc;
   1b450:	4334      	orrs	r4, r6
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
   1b452:	6883      	ldr	r3, [r0, #8]
   1b454:	4322      	orrs	r2, r4
   1b456:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   1b458:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
   1b45c:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
   1b460:	2000      	movs	r0, #0
}
   1b462:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
   1b464:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   1b468:	e7f0      	b.n	1b44c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
   1b46a:	4b15      	ldr	r3, [pc, #84]	; (1b4c0 <uarte_nrfx_configure+0x160>)
   1b46c:	e7ee      	b.n	1b44c <uarte_nrfx_configure+0xec>
		nrf_baudrate = 0x00027000;
   1b46e:	f44f 331c 	mov.w	r3, #159744	; 0x27000
   1b472:	e7eb      	b.n	1b44c <uarte_nrfx_configure+0xec>
		nrf_baudrate = 0x00014000;
   1b474:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
   1b478:	e7e8      	b.n	1b44c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
   1b47a:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
   1b47e:	e7e5      	b.n	1b44c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
   1b480:	4b10      	ldr	r3, [pc, #64]	; (1b4c4 <uarte_nrfx_configure+0x164>)
   1b482:	e7e3      	b.n	1b44c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
   1b484:	4b10      	ldr	r3, [pc, #64]	; (1b4c8 <uarte_nrfx_configure+0x168>)
   1b486:	e7e1      	b.n	1b44c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
   1b488:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
   1b48c:	e7de      	b.n	1b44c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
   1b48e:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
   1b492:	e7db      	b.n	1b44c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
   1b494:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
   1b498:	e7d8      	b.n	1b44c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
   1b49a:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
   1b49e:	e7d5      	b.n	1b44c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
   1b4a0:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
   1b4a4:	e7d2      	b.n	1b44c <uarte_nrfx_configure+0xec>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
   1b4a6:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   1b4aa:	e7cf      	b.n	1b44c <uarte_nrfx_configure+0xec>
   1b4ac:	00275000 	.word	0x00275000
   1b4b0:	0075c000 	.word	0x0075c000
   1b4b4:	013a9000 	.word	0x013a9000
   1b4b8:	0003d090 	.word	0x0003d090
   1b4bc:	000f4240 	.word	0x000f4240
   1b4c0:	0013b000 	.word	0x0013b000
   1b4c4:	003af000 	.word	0x003af000
   1b4c8:	004ea000 	.word	0x004ea000

0001b4cc <uarte_0_init>:
	#endif
	#if !defined(DT_NORDIC_NRF_UARTE_UART_0_RX_PIN)
	#define DT_NORDIC_NRF_UARTE_UART_0_RX_PIN NRF_UARTE_PSEL_DISCONNECTED
	#endif

	UART_NRF_UARTE_DEVICE(0);
   1b4cc:	b570      	push	{r4, r5, r6, lr}
   1b4ce:	4606      	mov	r6, r0
   1b4d0:	2200      	movs	r2, #0
   1b4d2:	2101      	movs	r1, #1
   1b4d4:	2008      	movs	r0, #8
   1b4d6:	f7fd fda9 	bl	1902c <z_arm_irq_priority_set>
   1b4da:	2008      	movs	r0, #8
   1b4dc:	f7fd fd96 	bl	1900c <arch_irq_enable>
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
   1b4e0:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
	return dev->config->config_info;
   1b4e4:	6833      	ldr	r3, [r6, #0]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   1b4e6:	68b5      	ldr	r5, [r6, #8]
	return config->uarte_regs;
   1b4e8:	689b      	ldr	r3, [r3, #8]
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   1b4ea:	4629      	mov	r1, r5
	return config->uarte_regs;
   1b4ec:	681c      	ldr	r4, [r3, #0]
   1b4ee:	4b14      	ldr	r3, [pc, #80]	; (1b540 <uarte_0_init+0x74>)
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   1b4f0:	4630      	mov	r0, r6
   1b4f2:	609a      	str	r2, [r3, #8]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1b4f4:	2203      	movs	r2, #3
   1b4f6:	f8c3 2274 	str.w	r2, [r3, #628]	; 0x274
   1b4fa:	2200      	movs	r2, #0
   1b4fc:	f8c3 2270 	str.w	r2, [r3, #624]	; 0x270
    p_reg->PSEL.TXD = pseltxd;
   1b500:	231d      	movs	r3, #29
   1b502:	f8c4 350c 	str.w	r3, [r4, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
   1b506:	231c      	movs	r3, #28
   1b508:	f8c4 3514 	str.w	r3, [r4, #1300]	; 0x514
   1b50c:	f7ff ff28 	bl	1b360 <uarte_nrfx_configure>
	if (err) {
   1b510:	b9a0      	cbnz	r0, 1b53c <uarte_0_init+0x70>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   1b512:	2308      	movs	r3, #8
   1b514:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
		nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
   1b518:	f105 030c 	add.w	r3, r5, #12
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1b51c:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   1b520:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   1b524:	2301      	movs	r3, #1
		nrf_uarte_tx_buffer_set(uarte, data->int_driven->tx_buffer, 0);
   1b526:	68aa      	ldr	r2, [r5, #8]
   1b528:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   1b52c:	6892      	ldr	r2, [r2, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1b52e:	6023      	str	r3, [r4, #0]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   1b530:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   1b534:	f8c4 0548 	str.w	r0, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1b538:	60a3      	str	r3, [r4, #8]
   1b53a:	60e3      	str	r3, [r4, #12]
	UART_NRF_UARTE_DEVICE(0);
   1b53c:	bd70      	pop	{r4, r5, r6, pc}
   1b53e:	bf00      	nop
   1b540:	40842500 	.word	0x40842500

0001b544 <entropy_cc310_rng_get_entropy>:
#include "nrf_cc310_platform_entropy.h"
#endif

static int entropy_cc310_rng_get_entropy(struct device *dev, u8_t *buffer,
					 u16_t length)
{
   1b544:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1b546:	460d      	mov	r5, r1
   1b548:	4614      	mov	r4, r2
	int res = -EINVAL;
	size_t olen;

	__ASSERT_NO_MSG(dev != NULL);
   1b54a:	b948      	cbnz	r0, 1b560 <entropy_cc310_rng_get_entropy+0x1c>
   1b54c:	4910      	ldr	r1, [pc, #64]	; (1b590 <entropy_cc310_rng_get_entropy+0x4c>)
   1b54e:	4811      	ldr	r0, [pc, #68]	; (1b594 <entropy_cc310_rng_get_entropy+0x50>)
   1b550:	231e      	movs	r3, #30
   1b552:	4a11      	ldr	r2, [pc, #68]	; (1b598 <entropy_cc310_rng_get_entropy+0x54>)
   1b554:	f011 fe79 	bl	2d24a <printk>
   1b558:	211e      	movs	r1, #30
   1b55a:	480f      	ldr	r0, [pc, #60]	; (1b598 <entropy_cc310_rng_get_entropy+0x54>)
   1b55c:	f011 febb 	bl	2d2d6 <assert_post_action>
	__ASSERT_NO_MSG(buffer != NULL);
   1b560:	b94d      	cbnz	r5, 1b576 <entropy_cc310_rng_get_entropy+0x32>
   1b562:	490e      	ldr	r1, [pc, #56]	; (1b59c <entropy_cc310_rng_get_entropy+0x58>)
   1b564:	480b      	ldr	r0, [pc, #44]	; (1b594 <entropy_cc310_rng_get_entropy+0x50>)
   1b566:	231f      	movs	r3, #31
   1b568:	4a0b      	ldr	r2, [pc, #44]	; (1b598 <entropy_cc310_rng_get_entropy+0x54>)
   1b56a:	f011 fe6e 	bl	2d24a <printk>
   1b56e:	211f      	movs	r1, #31
   1b570:	4809      	ldr	r0, [pc, #36]	; (1b598 <entropy_cc310_rng_get_entropy+0x54>)
   1b572:	f011 feb0 	bl	2d2d6 <assert_post_action>

#if defined(CONFIG_SPM)
	/** This is a call from a non-secure app that enables secure services,
	 *  in which case entropy is gathered by calling through SPM
	 */
	res = spm_request_random_number(buffer, length, &olen);
   1b576:	aa01      	add	r2, sp, #4
   1b578:	4621      	mov	r1, r4
   1b57a:	4628      	mov	r0, r5
   1b57c:	f7ec fd38 	bl	7ff0 <spm_request_random_number>
	if (olen != length) {
   1b580:	9b01      	ldr	r3, [sp, #4]
		return -EINVAL;
   1b582:	429c      	cmp	r4, r3
		return -EINVAL;
	}
#endif

	return res;
}
   1b584:	bf18      	it	ne
   1b586:	f06f 0015 	mvnne.w	r0, #21
   1b58a:	b003      	add	sp, #12
   1b58c:	bd30      	pop	{r4, r5, pc}
   1b58e:	bf00      	nop
   1b590:	0003374a 	.word	0x0003374a
   1b594:	000311a3 	.word	0x000311a3
   1b598:	0003371a 	.word	0x0003371a
   1b59c:	0003375d 	.word	0x0003375d

0001b5a0 <_bsdlib_init>:
static int _bsdlib_init(struct device *unused)
{
	/* Setup the network IRQ used by the BSD library.
	 * Note: No call to irq_enable() here, that is done through bsd_init().
	 */
	IRQ_DIRECT_CONNECT(BSD_NETWORK_IRQ, BSD_NETWORK_IRQ_PRIORITY,
   1b5a0:	2200      	movs	r2, #0
{
   1b5a2:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(BSD_NETWORK_IRQ, BSD_NETWORK_IRQ_PRIORITY,
   1b5a4:	4611      	mov	r1, r2
   1b5a6:	202a      	movs	r0, #42	; 0x2a
   1b5a8:	f7fd fd40 	bl	1902c <z_arm_irq_priority_set>
			   ipc_proxy_irq_handler, 0);

	init_ret = bsd_init();
   1b5ac:	f003 ff72 	bl	1f494 <bsd_init>
   1b5b0:	4b01      	ldr	r3, [pc, #4]	; (1b5b8 <_bsdlib_init+0x18>)
   1b5b2:	6018      	str	r0, [r3, #0]
		 */
		return 0;
	}

	return init_ret;
}
   1b5b4:	2000      	movs	r0, #0
   1b5b6:	bd08      	pop	{r3, pc}
   1b5b8:	20028790 	.word	0x20028790

0001b5bc <thread_monitor_entry_get>:

/* Get thread monitor structure assigned to a specific thread id, with a RPC
 * counter value at which bsdlib last checked the 'readiness' of a thread
 */
static struct thread_monitor_entry *thread_monitor_entry_get(k_tid_t id)
{
   1b5bc:	b570      	push	{r4, r5, r6, lr}
			new_entry = entry;
			break;
		}

		/* Identify oldest entry. */
		entry_age = rpc_event_cnt - entry->cnt;
   1b5be:	4b0d      	ldr	r3, [pc, #52]	; (1b5f4 <thread_monitor_entry_get+0x38>)
	struct thread_monitor_entry *new_entry = thread_event_monitor;
   1b5c0:	4c0d      	ldr	r4, [pc, #52]	; (1b5f8 <thread_monitor_entry_get+0x3c>)
		entry_age = rpc_event_cnt - entry->cnt;
   1b5c2:	681a      	ldr	r2, [r3, #0]
   1b5c4:	250a      	movs	r5, #10
	int entry_age, oldest_entry_age = 0;
   1b5c6:	2600      	movs	r6, #0
	struct thread_monitor_entry *entry = thread_event_monitor;
   1b5c8:	4623      	mov	r3, r4
		if (entry->id == id) {
   1b5ca:	6819      	ldr	r1, [r3, #0]
   1b5cc:	4281      	cmp	r1, r0
   1b5ce:	d00e      	beq.n	1b5ee <thread_monitor_entry_get+0x32>
		} else if (entry->id == 0) {
   1b5d0:	b151      	cbz	r1, 1b5e8 <thread_monitor_entry_get+0x2c>
		entry_age = rpc_event_cnt - entry->cnt;
   1b5d2:	6859      	ldr	r1, [r3, #4]
   1b5d4:	1a51      	subs	r1, r2, r1
		if (entry_age > oldest_entry_age) {
   1b5d6:	42b1      	cmp	r1, r6
   1b5d8:	bfc4      	itt	gt
   1b5da:	461c      	movgt	r4, r3
   1b5dc:	460e      	movgt	r6, r1
	for ( ; PART_OF_ARRAY(thread_event_monitor, entry); entry++) {
   1b5de:	3d01      	subs	r5, #1
   1b5e0:	f103 0308 	add.w	r3, r3, #8
   1b5e4:	d1f1      	bne.n	1b5ca <thread_monitor_entry_get+0xe>
   1b5e6:	4623      	mov	r3, r4
			new_entry = entry;
		}
	}

	new_entry->id = id;
	new_entry->cnt = rpc_event_cnt - 1;
   1b5e8:	3a01      	subs	r2, #1
	new_entry->id = id;
   1b5ea:	6018      	str	r0, [r3, #0]
	new_entry->cnt = rpc_event_cnt - 1;
   1b5ec:	605a      	str	r2, [r3, #4]

	return new_entry;
}
   1b5ee:	4618      	mov	r0, r3
   1b5f0:	bd70      	pop	{r4, r5, r6, pc}
   1b5f2:	bf00      	nop
   1b5f4:	20028794 	.word	0x20028794
   1b5f8:	200287a0 	.word	0x200287a0

0001b5fc <rpc_proxy_irq_handler>:
			  */

	return 1; /* We should check if scheduling decision should be made */
}

ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   1b5fc:	4668      	mov	r0, sp
   1b5fe:	f020 0107 	bic.w	r1, r0, #7
   1b602:	468d      	mov	sp, r1
   1b604:	b519      	push	{r0, r3, r4, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   1b606:	4b0d      	ldr	r3, [pc, #52]	; (1b63c <rpc_proxy_irq_handler+0x40>)
   1b608:	e8d3 2fef 	ldaex	r2, [r3]
   1b60c:	3201      	adds	r2, #1
   1b60e:	e8c3 2fe1 	stlex	r1, r2, [r3]
   1b612:	2900      	cmp	r1, #0
   1b614:	d1f8      	bne.n	1b608 <rpc_proxy_irq_handler+0xc>
{
	atomic_inc(&rpc_event_cnt);

	bsd_os_application_irq_handler();
   1b616:	f008 f8f5 	bl	23804 <bsd_os_application_irq_handler>

	struct sleeping_thread *thread;

	/* Wake up all sleeping threads. */
	SYS_SLIST_FOR_EACH_CONTAINER(&sleeping_threads, thread, node) {
   1b61a:	4b09      	ldr	r3, [pc, #36]	; (1b640 <rpc_proxy_irq_handler+0x44>)
   1b61c:	681c      	ldr	r4, [r3, #0]
   1b61e:	b93c      	cbnz	r4, 1b630 <rpc_proxy_irq_handler+0x34>
		k_sem_give(&thread->sem);
	}

	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   1b620:	f7fd fd36 	bl	19090 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING
	sys_trace_isr_exit();
#endif
	if (maybe_swap) {
		z_arm_int_exit();
   1b624:	f7fd fc1e 	bl	18e64 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   1b628:	e8bd 4019 	ldmia.w	sp!, {r0, r3, r4, lr}
   1b62c:	4685      	mov	sp, r0
   1b62e:	4770      	bx	lr
   1b630:	1d20      	adds	r0, r4, #4
   1b632:	f00c ff5b 	bl	284ec <z_impl_k_sem_give>
   1b636:	6824      	ldr	r4, [r4, #0]
	return node->next;
   1b638:	e7f1      	b.n	1b61e <rpc_proxy_irq_handler+0x22>
   1b63a:	bf00      	nop
   1b63c:	20028794 	.word	0x20028794
   1b640:	20028798 	.word	0x20028798

0001b644 <bsd_os_timedwait>:
{
   1b644:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b648:	4688      	mov	r8, r1
   1b64a:	b089      	sub	sp, #36	; 0x24
	return z_impl_k_uptime_get();
   1b64c:	f013 fdc5 	bl	2f1da <z_impl_k_uptime_get>
	if (*timeout == 0) {
   1b650:	f8d8 3000 	ldr.w	r3, [r8]
   1b654:	4606      	mov	r6, r0
   1b656:	2b00      	cmp	r3, #0
   1b658:	460f      	mov	r7, r1
   1b65a:	d103      	bne.n	1b664 <bsd_os_timedwait+0x20>
	z_impl_k_yield();
   1b65c:	f00c fdc2 	bl	281e4 <z_impl_k_yield>
		return NRF_ETIMEDOUT;
   1b660:	203c      	movs	r0, #60	; 0x3c
   1b662:	e06e      	b.n	1b742 <bsd_os_timedwait+0xfe>
		*timeout = K_FOREVER;
   1b664:	bfbc      	itt	lt
   1b666:	f04f 33ff 	movlt.w	r3, #4294967295
   1b66a:	f8c8 3000 	strlt.w	r3, [r8]
	return z_impl_k_sem_init(sem, initial_count, limit);
   1b66e:	2201      	movs	r2, #1
   1b670:	2100      	movs	r1, #0
   1b672:	a802      	add	r0, sp, #8
   1b674:	f013 fd1e 	bl	2f0b4 <z_impl_k_sem_init>
   1b678:	f10d 0a04 	add.w	sl, sp, #4
   1b67c:	f04f 0320 	mov.w	r3, #32
   1b680:	f3ef 8b11 	mrs	fp, BASEPRI
   1b684:	f383 8811 	msr	BASEPRI, r3
   1b688:	f3bf 8f6f 	isb	sy
	return z_impl_k_current_get();
   1b68c:	f00c ff28 	bl	284e0 <z_impl_k_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   1b690:	f7ff ff94 	bl	1b5bc <thread_monitor_entry_get>
	if (rpc_event_cnt != entry->cnt) {
   1b694:	4933      	ldr	r1, [pc, #204]	; (1b764 <bsd_os_timedwait+0x120>)
   1b696:	6843      	ldr	r3, [r0, #4]
   1b698:	680a      	ldr	r2, [r1, #0]
   1b69a:	4689      	mov	r9, r1
   1b69c:	4293      	cmp	r3, r2
   1b69e:	f04f 0300 	mov.w	r3, #0
   1b6a2:	d108      	bne.n	1b6b6 <bsd_os_timedwait+0x72>
	parent->next = child;
   1b6a4:	9301      	str	r3, [sp, #4]
Z_GENLIST_APPEND(slist, snode)
   1b6a6:	4b30      	ldr	r3, [pc, #192]	; (1b768 <bsd_os_timedwait+0x124>)
   1b6a8:	685a      	ldr	r2, [r3, #4]
   1b6aa:	2a00      	cmp	r2, #0
   1b6ac:	d14c      	bne.n	1b748 <bsd_os_timedwait+0x104>
	list->head = node;
   1b6ae:	e9c3 aa00 	strd	sl, sl, [r3]
		allow_to_sleep = true;
   1b6b2:	2301      	movs	r3, #1
   1b6b4:	e000      	b.n	1b6b8 <bsd_os_timedwait+0x74>
	entry->cnt = rpc_event_cnt;
   1b6b6:	6042      	str	r2, [r0, #4]
	__asm__ volatile(
   1b6b8:	f38b 8811 	msr	BASEPRI, fp
   1b6bc:	f3bf 8f6f 	isb	sy
	if (!sleeping_thread_add(&thread)) {
   1b6c0:	2b00      	cmp	r3, #0
   1b6c2:	d03d      	beq.n	1b740 <bsd_os_timedwait+0xfc>
	(void)k_sem_take(&thread.sem, *timeout);
   1b6c4:	f8d8 1000 	ldr.w	r1, [r8]
	return z_impl_k_sem_take(sem, timeout);
   1b6c8:	a802      	add	r0, sp, #8
   1b6ca:	f00c ff59 	bl	28580 <z_impl_k_sem_take>
	__asm__ volatile(
   1b6ce:	f04f 0320 	mov.w	r3, #32
   1b6d2:	f3ef 8b11 	mrs	fp, BASEPRI
   1b6d6:	f383 8811 	msr	BASEPRI, r3
   1b6da:	f3bf 8f6f 	isb	sy
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1b6de:	2000      	movs	r0, #0
   1b6e0:	4b21      	ldr	r3, [pc, #132]	; (1b768 <bsd_os_timedwait+0x124>)
   1b6e2:	681a      	ldr	r2, [r3, #0]
   1b6e4:	b152      	cbz	r2, 1b6fc <bsd_os_timedwait+0xb8>
   1b6e6:	4552      	cmp	r2, sl
   1b6e8:	d139      	bne.n	1b75e <bsd_os_timedwait+0x11a>
Z_GENLIST_REMOVE(slist, snode)
   1b6ea:	9901      	ldr	r1, [sp, #4]
   1b6ec:	bb88      	cbnz	r0, 1b752 <bsd_os_timedwait+0x10e>
   1b6ee:	6858      	ldr	r0, [r3, #4]
	list->head = node;
   1b6f0:	6019      	str	r1, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   1b6f2:	4290      	cmp	r0, r2
   1b6f4:	d100      	bne.n	1b6f8 <bsd_os_timedwait+0xb4>
	list->tail = node;
   1b6f6:	6059      	str	r1, [r3, #4]
	parent->next = child;
   1b6f8:	2300      	movs	r3, #0
   1b6fa:	9301      	str	r3, [sp, #4]
	return z_impl_k_current_get();
   1b6fc:	f00c fef0 	bl	284e0 <z_impl_k_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   1b700:	f7ff ff5c 	bl	1b5bc <thread_monitor_entry_get>
	entry->cnt = rpc_event_cnt;
   1b704:	f8d9 3000 	ldr.w	r3, [r9]
   1b708:	6043      	str	r3, [r0, #4]
	__asm__ volatile(
   1b70a:	f38b 8811 	msr	BASEPRI, fp
   1b70e:	f3bf 8f6f 	isb	sy
	if (*timeout == K_FOREVER) {
   1b712:	f8d8 9000 	ldr.w	r9, [r8]
   1b716:	f1b9 3fff 	cmp.w	r9, #4294967295
   1b71a:	d011      	beq.n	1b740 <bsd_os_timedwait+0xfc>
	return z_impl_k_uptime_get();
   1b71c:	f013 fd5d 	bl	2f1da <z_impl_k_uptime_get>
	remaining = *timeout - (k_uptime_get() - start);
   1b720:	eb16 0209 	adds.w	r2, r6, r9
   1b724:	eb47 73e9 	adc.w	r3, r7, r9, asr #31
   1b728:	1a14      	subs	r4, r2, r0
   1b72a:	eb63 0501 	sbc.w	r5, r3, r1
	*timeout = remaining > 0 ? remaining : 0;
   1b72e:	2c00      	cmp	r4, #0
   1b730:	f175 0300 	sbcs.w	r3, r5, #0
   1b734:	bfb8      	it	lt
   1b736:	2400      	movlt	r4, #0
   1b738:	f8c8 4000 	str.w	r4, [r8]
	if (*timeout == 0) {
   1b73c:	2c00      	cmp	r4, #0
   1b73e:	d08f      	beq.n	1b660 <bsd_os_timedwait+0x1c>
	return 0;
   1b740:	2000      	movs	r0, #0
}
   1b742:	b009      	add	sp, #36	; 0x24
   1b744:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1b748:	f8c2 a000 	str.w	sl, [r2]
	list->tail = node;
   1b74c:	f8c3 a004 	str.w	sl, [r3, #4]
   1b750:	e7af      	b.n	1b6b2 <bsd_os_timedwait+0x6e>
	parent->next = child;
   1b752:	6001      	str	r1, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   1b754:	6859      	ldr	r1, [r3, #4]
   1b756:	4291      	cmp	r1, r2
	list->tail = node;
   1b758:	bf08      	it	eq
   1b75a:	6058      	streq	r0, [r3, #4]
   1b75c:	e7cc      	b.n	1b6f8 <bsd_os_timedwait+0xb4>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1b75e:	4610      	mov	r0, r2
   1b760:	6812      	ldr	r2, [r2, #0]
   1b762:	e7bf      	b.n	1b6e4 <bsd_os_timedwait+0xa0>
   1b764:	20028794 	.word	0x20028794
   1b768:	20028798 	.word	0x20028798

0001b76c <bsd_os_errno_set>:
	switch (err_code) {
   1b76c:	282d      	cmp	r0, #45	; 0x2d
{
   1b76e:	b510      	push	{r4, lr}
   1b770:	4604      	mov	r4, r0
	switch (err_code) {
   1b772:	f000 80a8 	beq.w	1b8c6 <bsd_os_errno_set+0x15a>
   1b776:	dc50      	bgt.n	1b81a <bsd_os_errno_set+0xae>
   1b778:	2816      	cmp	r0, #22
   1b77a:	d009      	beq.n	1b790 <bsd_os_errno_set+0x24>
   1b77c:	dc38      	bgt.n	1b7f0 <bsd_os_errno_set+0x84>
   1b77e:	2808      	cmp	r0, #8
   1b780:	d006      	beq.n	1b790 <bsd_os_errno_set+0x24>
   1b782:	dc09      	bgt.n	1b798 <bsd_os_errno_set+0x2c>
   1b784:	2802      	cmp	r0, #2
   1b786:	d003      	beq.n	1b790 <bsd_os_errno_set+0x24>
   1b788:	2805      	cmp	r0, #5
   1b78a:	d001      	beq.n	1b790 <bsd_os_errno_set+0x24>
   1b78c:	2801      	cmp	r0, #1
   1b78e:	d10c      	bne.n	1b7aa <bsd_os_errno_set+0x3e>
		errno = ENOBUFS;
   1b790:	f011 ff56 	bl	2d640 <__errno>
   1b794:	6004      	str	r4, [r0, #0]
}
   1b796:	bd10      	pop	{r4, pc}
	switch (err_code) {
   1b798:	280c      	cmp	r0, #12
   1b79a:	d0f9      	beq.n	1b790 <bsd_os_errno_set+0x24>
   1b79c:	dc01      	bgt.n	1b7a2 <bsd_os_errno_set+0x36>
   1b79e:	2809      	cmp	r0, #9
   1b7a0:	e7f5      	b.n	1b78e <bsd_os_errno_set+0x22>
   1b7a2:	280d      	cmp	r0, #13
   1b7a4:	d0f4      	beq.n	1b790 <bsd_os_errno_set+0x24>
   1b7a6:	280e      	cmp	r0, #14
   1b7a8:	d074      	beq.n	1b894 <bsd_os_errno_set+0x128>
		__ASSERT(false, "Untranslated errno %d set by bsdlib!", err_code);
   1b7aa:	f44f 73a5 	mov.w	r3, #330	; 0x14a
   1b7ae:	4a63      	ldr	r2, [pc, #396]	; (1b93c <bsd_os_errno_set+0x1d0>)
   1b7b0:	4963      	ldr	r1, [pc, #396]	; (1b940 <bsd_os_errno_set+0x1d4>)
   1b7b2:	4864      	ldr	r0, [pc, #400]	; (1b944 <bsd_os_errno_set+0x1d8>)
   1b7b4:	f011 fd49 	bl	2d24a <printk>
   1b7b8:	4621      	mov	r1, r4
   1b7ba:	4863      	ldr	r0, [pc, #396]	; (1b948 <bsd_os_errno_set+0x1dc>)
   1b7bc:	f011 fd45 	bl	2d24a <printk>
   1b7c0:	f44f 71a5 	mov.w	r1, #330	; 0x14a
   1b7c4:	485d      	ldr	r0, [pc, #372]	; (1b93c <bsd_os_errno_set+0x1d0>)
   1b7c6:	f011 fd86 	bl	2d2d6 <assert_post_action>
		LOG_ERR("Untranslated errno %d set by bsdlib!", err_code);
   1b7ca:	2301      	movs	r3, #1
   1b7cc:	f04f 0000 	mov.w	r0, #0
   1b7d0:	4a5e      	ldr	r2, [pc, #376]	; (1b94c <bsd_os_errno_set+0x1e0>)
   1b7d2:	f363 0007 	bfi	r0, r3, #0, #8
   1b7d6:	4b5e      	ldr	r3, [pc, #376]	; (1b950 <bsd_os_errno_set+0x1e4>)
   1b7d8:	495e      	ldr	r1, [pc, #376]	; (1b954 <bsd_os_errno_set+0x1e8>)
   1b7da:	1a9b      	subs	r3, r3, r2
   1b7dc:	08db      	lsrs	r3, r3, #3
   1b7de:	f363 108f 	bfi	r0, r3, #6, #10
   1b7e2:	4622      	mov	r2, r4
   1b7e4:	f011 fd88 	bl	2d2f8 <log_string_sync>
		errno = 0xBAADBAAD;
   1b7e8:	f011 ff2a 	bl	2d640 <__errno>
   1b7ec:	4b5a      	ldr	r3, [pc, #360]	; (1b958 <bsd_os_errno_set+0x1ec>)
   1b7ee:	e054      	b.n	1b89a <bsd_os_errno_set+0x12e>
	switch (err_code) {
   1b7f0:	2828      	cmp	r0, #40	; 0x28
   1b7f2:	f000 809f 	beq.w	1b934 <bsd_os_errno_set+0x1c8>
   1b7f6:	dc05      	bgt.n	1b804 <bsd_os_errno_set+0x98>
   1b7f8:	2823      	cmp	r0, #35	; 0x23
   1b7fa:	d050      	beq.n	1b89e <bsd_os_errno_set+0x132>
   1b7fc:	2825      	cmp	r0, #37	; 0x25
   1b7fe:	d052      	beq.n	1b8a6 <bsd_os_errno_set+0x13a>
   1b800:	2818      	cmp	r0, #24
   1b802:	e7c4      	b.n	1b78e <bsd_os_errno_set+0x22>
   1b804:	282a      	cmp	r0, #42	; 0x2a
   1b806:	d056      	beq.n	1b8b6 <bsd_os_errno_set+0x14a>
   1b808:	db51      	blt.n	1b8ae <bsd_os_errno_set+0x142>
   1b80a:	282b      	cmp	r0, #43	; 0x2b
   1b80c:	d057      	beq.n	1b8be <bsd_os_errno_set+0x152>
   1b80e:	282c      	cmp	r0, #44	; 0x2c
   1b810:	d1cb      	bne.n	1b7aa <bsd_os_errno_set+0x3e>
		errno = ESOCKTNOSUPPORT;
   1b812:	f011 ff15 	bl	2d640 <__errno>
   1b816:	237c      	movs	r3, #124	; 0x7c
   1b818:	e03f      	b.n	1b89a <bsd_os_errno_set+0x12e>
	switch (err_code) {
   1b81a:	283c      	cmp	r0, #60	; 0x3c
   1b81c:	d06b      	beq.n	1b8f6 <bsd_os_errno_set+0x18a>
   1b81e:	dc1d      	bgt.n	1b85c <bsd_os_errno_set+0xf0>
   1b820:	2833      	cmp	r0, #51	; 0x33
   1b822:	d05c      	beq.n	1b8de <bsd_os_errno_set+0x172>
   1b824:	dc09      	bgt.n	1b83a <bsd_os_errno_set+0xce>
   1b826:	2830      	cmp	r0, #48	; 0x30
   1b828:	d051      	beq.n	1b8ce <bsd_os_errno_set+0x162>
   1b82a:	2832      	cmp	r0, #50	; 0x32
   1b82c:	d053      	beq.n	1b8d6 <bsd_os_errno_set+0x16a>
   1b82e:	282f      	cmp	r0, #47	; 0x2f
   1b830:	d1bb      	bne.n	1b7aa <bsd_os_errno_set+0x3e>
		errno = EAFNOSUPPORT;
   1b832:	f011 ff05 	bl	2d640 <__errno>
   1b836:	236a      	movs	r3, #106	; 0x6a
   1b838:	e02f      	b.n	1b89a <bsd_os_errno_set+0x12e>
	switch (err_code) {
   1b83a:	2836      	cmp	r0, #54	; 0x36
   1b83c:	d053      	beq.n	1b8e6 <bsd_os_errno_set+0x17a>
   1b83e:	dc05      	bgt.n	1b84c <bsd_os_errno_set+0xe0>
   1b840:	2834      	cmp	r0, #52	; 0x34
   1b842:	d1b2      	bne.n	1b7aa <bsd_os_errno_set+0x3e>
		errno = ENETRESET;
   1b844:	f011 fefc 	bl	2d640 <__errno>
   1b848:	237e      	movs	r3, #126	; 0x7e
   1b84a:	e026      	b.n	1b89a <bsd_os_errno_set+0x12e>
	switch (err_code) {
   1b84c:	2838      	cmp	r0, #56	; 0x38
   1b84e:	d04e      	beq.n	1b8ee <bsd_os_errno_set+0x182>
   1b850:	2839      	cmp	r0, #57	; 0x39
   1b852:	d1aa      	bne.n	1b7aa <bsd_os_errno_set+0x3e>
		errno = ENOTCONN;
   1b854:	f011 fef4 	bl	2d640 <__errno>
   1b858:	2380      	movs	r3, #128	; 0x80
   1b85a:	e01e      	b.n	1b89a <bsd_os_errno_set+0x12e>
	switch (err_code) {
   1b85c:	287d      	cmp	r0, #125	; 0x7d
   1b85e:	d056      	beq.n	1b90e <bsd_os_errno_set+0x1a2>
   1b860:	dc0c      	bgt.n	1b87c <bsd_os_errno_set+0x110>
   1b862:	2870      	cmp	r0, #112	; 0x70
   1b864:	d04b      	beq.n	1b8fe <bsd_os_errno_set+0x192>
   1b866:	dc01      	bgt.n	1b86c <bsd_os_errno_set+0x100>
   1b868:	2869      	cmp	r0, #105	; 0x69
   1b86a:	e790      	b.n	1b78e <bsd_os_errno_set+0x22>
   1b86c:	2872      	cmp	r0, #114	; 0x72
   1b86e:	d04a      	beq.n	1b906 <bsd_os_errno_set+0x19a>
   1b870:	2873      	cmp	r0, #115	; 0x73
   1b872:	d19a      	bne.n	1b7aa <bsd_os_errno_set+0x3e>
		errno = EINPROGRESS;
   1b874:	f011 fee4 	bl	2d640 <__errno>
   1b878:	2377      	movs	r3, #119	; 0x77
   1b87a:	e00e      	b.n	1b89a <bsd_os_errno_set+0x12e>
	switch (err_code) {
   1b87c:	287f      	cmp	r0, #127	; 0x7f
   1b87e:	d04f      	beq.n	1b920 <bsd_os_errno_set+0x1b4>
   1b880:	db49      	blt.n	1b916 <bsd_os_errno_set+0x1aa>
   1b882:	2880      	cmp	r0, #128	; 0x80
   1b884:	d051      	beq.n	1b92a <bsd_os_errno_set+0x1be>
   1b886:	2881      	cmp	r0, #129	; 0x81
   1b888:	d18f      	bne.n	1b7aa <bsd_os_errno_set+0x3e>
		errno = EKEYREJECTED;
   1b88a:	f011 fed9 	bl	2d640 <__errno>
   1b88e:	f240 73d4 	movw	r3, #2004	; 0x7d4
   1b892:	e002      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = EFAULT;
   1b894:	f011 fed4 	bl	2d640 <__errno>
   1b898:	230e      	movs	r3, #14
		errno = 0xBAADBAAD;
   1b89a:	6003      	str	r3, [r0, #0]
}
   1b89c:	e77b      	b.n	1b796 <bsd_os_errno_set+0x2a>
		errno = EAGAIN;
   1b89e:	f011 fecf 	bl	2d640 <__errno>
   1b8a2:	230b      	movs	r3, #11
   1b8a4:	e7f9      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = EDOM;
   1b8a6:	f011 fecb 	bl	2d640 <__errno>
   1b8aa:	2321      	movs	r3, #33	; 0x21
   1b8ac:	e7f5      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = EPROTOTYPE;
   1b8ae:	f011 fec7 	bl	2d640 <__errno>
   1b8b2:	236b      	movs	r3, #107	; 0x6b
   1b8b4:	e7f1      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = ENOPROTOOPT;
   1b8b6:	f011 fec3 	bl	2d640 <__errno>
   1b8ba:	236d      	movs	r3, #109	; 0x6d
   1b8bc:	e7ed      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = EPROTONOSUPPORT;
   1b8be:	f011 febf 	bl	2d640 <__errno>
   1b8c2:	237b      	movs	r3, #123	; 0x7b
   1b8c4:	e7e9      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = EOPNOTSUPP;
   1b8c6:	f011 febb 	bl	2d640 <__errno>
   1b8ca:	235f      	movs	r3, #95	; 0x5f
   1b8cc:	e7e5      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = EADDRINUSE;
   1b8ce:	f011 feb7 	bl	2d640 <__errno>
   1b8d2:	2370      	movs	r3, #112	; 0x70
   1b8d4:	e7e1      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = ENETDOWN;
   1b8d6:	f011 feb3 	bl	2d640 <__errno>
   1b8da:	2373      	movs	r3, #115	; 0x73
   1b8dc:	e7dd      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = ENETUNREACH;
   1b8de:	f011 feaf 	bl	2d640 <__errno>
   1b8e2:	2372      	movs	r3, #114	; 0x72
   1b8e4:	e7d9      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = ECONNRESET;
   1b8e6:	f011 feab 	bl	2d640 <__errno>
   1b8ea:	2368      	movs	r3, #104	; 0x68
   1b8ec:	e7d5      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = EISCONN;
   1b8ee:	f011 fea7 	bl	2d640 <__errno>
   1b8f2:	237f      	movs	r3, #127	; 0x7f
   1b8f4:	e7d1      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = ETIMEDOUT;
   1b8f6:	f011 fea3 	bl	2d640 <__errno>
   1b8fa:	2374      	movs	r3, #116	; 0x74
   1b8fc:	e7cd      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = EHOSTDOWN;
   1b8fe:	f011 fe9f 	bl	2d640 <__errno>
   1b902:	2375      	movs	r3, #117	; 0x75
   1b904:	e7c9      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = EALREADY;
   1b906:	f011 fe9b 	bl	2d640 <__errno>
   1b90a:	2378      	movs	r3, #120	; 0x78
   1b90c:	e7c5      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = ECANCELED;
   1b90e:	f011 fe97 	bl	2d640 <__errno>
   1b912:	238c      	movs	r3, #140	; 0x8c
   1b914:	e7c1      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = ENOKEY;
   1b916:	f011 fe93 	bl	2d640 <__errno>
   1b91a:	f240 73d1 	movw	r3, #2001	; 0x7d1
   1b91e:	e7bc      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = EKEYEXPIRED;
   1b920:	f011 fe8e 	bl	2d640 <__errno>
   1b924:	f240 73d2 	movw	r3, #2002	; 0x7d2
   1b928:	e7b7      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = EKEYREVOKED;
   1b92a:	f011 fe89 	bl	2d640 <__errno>
   1b92e:	f240 73d3 	movw	r3, #2003	; 0x7d3
   1b932:	e7b2      	b.n	1b89a <bsd_os_errno_set+0x12e>
		errno = EMSGSIZE;
   1b934:	f011 fe84 	bl	2d640 <__errno>
   1b938:	237a      	movs	r3, #122	; 0x7a
   1b93a:	e7ae      	b.n	1b89a <bsd_os_errno_set+0x12e>
   1b93c:	00033773 	.word	0x00033773
   1b940:	0003495a 	.word	0x0003495a
   1b944:	000311a3 	.word	0x000311a3
   1b948:	00033797 	.word	0x00033797
   1b94c:	0003040c 	.word	0x0003040c
   1b950:	0003042c 	.word	0x0003042c
   1b954:	000337be 	.word	0x000337be
   1b958:	baadbaad 	.word	0xbaadbaad

0001b95c <bsd_os_application_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1b95c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1b960:	4b01      	ldr	r3, [pc, #4]	; (1b968 <bsd_os_application_irq_set+0xc>)
   1b962:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   1b966:	4770      	bx	lr
   1b968:	e000e100 	.word	0xe000e100

0001b96c <bsd_os_application_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1b96c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1b970:	4b01      	ldr	r3, [pc, #4]	; (1b978 <bsd_os_application_irq_clear+0xc>)
   1b972:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   1b976:	4770      	bx	lr
   1b978:	e000e100 	.word	0xe000e100

0001b97c <bsd_os_trace_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1b97c:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   1b980:	4b01      	ldr	r3, [pc, #4]	; (1b988 <bsd_os_trace_irq_set+0xc>)
   1b982:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   1b986:	4770      	bx	lr
   1b988:	e000e100 	.word	0xe000e100

0001b98c <bsd_os_trace_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1b98c:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   1b990:	4b01      	ldr	r3, [pc, #4]	; (1b998 <bsd_os_trace_irq_clear+0xc>)
   1b992:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   1b996:	4770      	bx	lr
   1b998:	e000e100 	.word	0xe000e100

0001b99c <bsd_os_init>:
#endif
}

/* This function is called by bsd_init and must not be called explicitly. */
void bsd_os_init(void)
{
   1b99c:	b508      	push	{r3, lr}
	list->head = NULL;
   1b99e:	2300      	movs	r3, #0
   1b9a0:	4a07      	ldr	r2, [pc, #28]	; (1b9c0 <bsd_os_init+0x24>)
	list->tail = NULL;
   1b9a2:	e9c2 3300 	strd	r3, r3, [r2]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1b9a6:	4a07      	ldr	r2, [pc, #28]	; (1b9c4 <bsd_os_init+0x28>)
   1b9a8:	e8d2 1fef 	ldaex	r1, [r2]
   1b9ac:	e8c2 3fe0 	stlex	r0, r3, [r2]
   1b9b0:	2800      	cmp	r0, #0
   1b9b2:	d1f9      	bne.n	1b9a8 <bsd_os_init+0xc>
	sys_slist_init(&sleeping_threads);
	atomic_clear(&rpc_event_cnt);

	read_task_create();
   1b9b4:	f012 fd5b 	bl	2e46e <read_task_create>

	/* Configure and enable modem tracing over UART. */
	trace_uart_init();
	trace_task_create();
}
   1b9b8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	trace_task_create();
   1b9bc:	f012 bd4c 	b.w	2e458 <trace_task_create>
   1b9c0:	20028798 	.word	0x20028798
   1b9c4:	20028794 	.word	0x20028794

0001b9c8 <z_to_nrf_optname>:
static int z_to_nrf_optname(int z_in_level, int z_in_optname,
			    int *nrf_out_optname)
{
	int retval = 0;

	switch (z_in_level) {
   1b9c8:	f5b0 7f8d 	cmp.w	r0, #282	; 0x11a
   1b9cc:	d03c      	beq.n	1ba48 <z_to_nrf_optname+0x80>
   1b9ce:	dc04      	bgt.n	1b9da <z_to_nrf_optname+0x12>
   1b9d0:	2801      	cmp	r0, #1
   1b9d2:	d044      	beq.n	1ba5e <z_to_nrf_optname+0x96>
			break;
		}
		break;

	default:
		retval = -1;
   1b9d4:	f04f 30ff 	mov.w	r0, #4294967295
		break;
	}

	return retval;
}
   1b9d8:	4770      	bx	lr
	switch (z_in_level) {
   1b9da:	f240 2302 	movw	r3, #514	; 0x202
   1b9de:	4298      	cmp	r0, r3
   1b9e0:	d052      	beq.n	1ba88 <z_to_nrf_optname+0xc0>
   1b9e2:	f240 2303 	movw	r3, #515	; 0x203
   1b9e6:	4298      	cmp	r0, r3
   1b9e8:	d1f4      	bne.n	1b9d4 <z_to_nrf_optname+0xc>
		switch (z_in_optname) {
   1b9ea:	3901      	subs	r1, #1
   1b9ec:	2913      	cmp	r1, #19
   1b9ee:	d8f1      	bhi.n	1b9d4 <z_to_nrf_optname+0xc>
   1b9f0:	a301      	add	r3, pc, #4	; (adr r3, 1b9f8 <z_to_nrf_optname+0x30>)
   1b9f2:	f853 f021 	ldr.w	pc, [r3, r1, lsl #2]
   1b9f6:	bf00      	nop
   1b9f8:	0001ba95 	.word	0x0001ba95
   1b9fc:	0001ba59 	.word	0x0001ba59
   1ba00:	0001ba79 	.word	0x0001ba79
   1ba04:	0001ba6b 	.word	0x0001ba6b
   1ba08:	0001ba7d 	.word	0x0001ba7d
   1ba0c:	0001ba81 	.word	0x0001ba81
   1ba10:	0001ba85 	.word	0x0001ba85
   1ba14:	0001b9d5 	.word	0x0001b9d5
   1ba18:	0001b9d5 	.word	0x0001b9d5
   1ba1c:	0001b9d5 	.word	0x0001b9d5
   1ba20:	0001b9d5 	.word	0x0001b9d5
   1ba24:	0001b9d5 	.word	0x0001b9d5
   1ba28:	0001b9d5 	.word	0x0001b9d5
   1ba2c:	0001b9d5 	.word	0x0001b9d5
   1ba30:	0001b9d5 	.word	0x0001b9d5
   1ba34:	0001b9d5 	.word	0x0001b9d5
   1ba38:	0001b9d5 	.word	0x0001b9d5
   1ba3c:	0001b9d5 	.word	0x0001b9d5
   1ba40:	0001b9d5 	.word	0x0001b9d5
   1ba44:	0001ba6f 	.word	0x0001ba6f
		switch (z_in_optname) {
   1ba48:	3901      	subs	r1, #1
   1ba4a:	2905      	cmp	r1, #5
   1ba4c:	d8c2      	bhi.n	1b9d4 <z_to_nrf_optname+0xc>
   1ba4e:	e8df f001 	tbb	[pc, r1]
   1ba52:	1503      	.short	0x1503
   1ba54:	210c1917 	.word	0x210c1917
			*nrf_out_optname = NRF_SO_SEC_TAG_LIST;
   1ba58:	2302      	movs	r3, #2
			*nrf_out_optname = NRF_SO_DFU_OFFSET;
   1ba5a:	6013      	str	r3, [r2, #0]
   1ba5c:	e00a      	b.n	1ba74 <z_to_nrf_optname+0xac>
		switch (z_in_optname) {
   1ba5e:	2914      	cmp	r1, #20
   1ba60:	d005      	beq.n	1ba6e <z_to_nrf_optname+0xa6>
   1ba62:	2919      	cmp	r1, #25
   1ba64:	d005      	beq.n	1ba72 <z_to_nrf_optname+0xaa>
   1ba66:	2904      	cmp	r1, #4
   1ba68:	d1b4      	bne.n	1b9d4 <z_to_nrf_optname+0xc>
			*nrf_out_optname = NRF_SO_SEC_PEER_VERIFY;
   1ba6a:	2304      	movs	r3, #4
   1ba6c:	e7f5      	b.n	1ba5a <z_to_nrf_optname+0x92>
			*nrf_out_optname = NRF_SO_RCVTIMEO;
   1ba6e:	2314      	movs	r3, #20
   1ba70:	e7f3      	b.n	1ba5a <z_to_nrf_optname+0x92>
			*nrf_out_optname = NRF_SO_BINDTODEVICE;
   1ba72:	6011      	str	r1, [r2, #0]
	int retval = 0;
   1ba74:	2000      	movs	r0, #0
			break;
   1ba76:	4770      	bx	lr
			*nrf_out_optname = NRF_SO_DFU_TIMEO;
   1ba78:	2303      	movs	r3, #3
   1ba7a:	e7ee      	b.n	1ba5a <z_to_nrf_optname+0x92>
			*nrf_out_optname = NRF_SO_DFU_REVERT;
   1ba7c:	2305      	movs	r3, #5
   1ba7e:	e7ec      	b.n	1ba5a <z_to_nrf_optname+0x92>
			*nrf_out_optname = NRF_SO_DFU_BACKUP_DELETE;
   1ba80:	2306      	movs	r3, #6
   1ba82:	e7ea      	b.n	1ba5a <z_to_nrf_optname+0x92>
			*nrf_out_optname = NRF_SO_DFU_OFFSET;
   1ba84:	2307      	movs	r3, #7
   1ba86:	e7e8      	b.n	1ba5a <z_to_nrf_optname+0x92>
		switch (z_in_optname) {
   1ba88:	2902      	cmp	r1, #2
   1ba8a:	d0e5      	beq.n	1ba58 <z_to_nrf_optname+0x90>
   1ba8c:	2903      	cmp	r1, #3
   1ba8e:	d0f3      	beq.n	1ba78 <z_to_nrf_optname+0xb0>
   1ba90:	2901      	cmp	r1, #1
   1ba92:	d19f      	bne.n	1b9d4 <z_to_nrf_optname+0xc>
			*nrf_out_optname = NRF_SO_SEC_ROLE;
   1ba94:	2301      	movs	r3, #1
   1ba96:	e7e0      	b.n	1ba5a <z_to_nrf_optname+0x92>

0001ba98 <nrf91_socket_iface_init>:

static void nrf91_socket_iface_init(struct net_if *iface)
{
	nrf91_socket_iface_data.iface = iface;

	iface->if_dev->offloaded = true;
   1ba98:	2201      	movs	r2, #1
	nrf91_socket_iface_data.iface = iface;
   1ba9a:	4b03      	ldr	r3, [pc, #12]	; (1baa8 <nrf91_socket_iface_init+0x10>)
   1ba9c:	6018      	str	r0, [r3, #0]
	iface->if_dev->offloaded = true;
   1ba9e:	6803      	ldr	r3, [r0, #0]

	socket_offload_register(&nrf91_socket_offload_ops);
   1baa0:	4802      	ldr	r0, [pc, #8]	; (1baac <nrf91_socket_iface_init+0x14>)
	iface->if_dev->offloaded = true;
   1baa2:	769a      	strb	r2, [r3, #26]
	socket_offload_register(&nrf91_socket_offload_ops);
   1baa4:	f7fc bdf8 	b.w	18698 <socket_offload_register>
   1baa8:	200287f0 	.word	0x200287f0
   1baac:	00030b24 	.word	0x00030b24

0001bab0 <close>:
{
   1bab0:	b570      	push	{r4, r5, r6, lr}
	__ASSERT_NO_MSG(socket_ops);
   1bab2:	4c10      	ldr	r4, [pc, #64]	; (1baf4 <close+0x44>)
{
   1bab4:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(socket_ops);
   1bab6:	6823      	ldr	r3, [r4, #0]
   1bab8:	b94b      	cbnz	r3, 1bace <close+0x1e>
   1baba:	490f      	ldr	r1, [pc, #60]	; (1baf8 <close+0x48>)
   1babc:	480f      	ldr	r0, [pc, #60]	; (1bafc <close+0x4c>)
   1babe:	2321      	movs	r3, #33	; 0x21
   1bac0:	4a0f      	ldr	r2, [pc, #60]	; (1bb00 <close+0x50>)
   1bac2:	f011 fbc2 	bl	2d24a <printk>
   1bac6:	2121      	movs	r1, #33	; 0x21
   1bac8:	480d      	ldr	r0, [pc, #52]	; (1bb00 <close+0x50>)
   1baca:	f011 fc04 	bl	2d2d6 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->close);
   1bace:	6823      	ldr	r3, [r4, #0]
   1bad0:	685b      	ldr	r3, [r3, #4]
   1bad2:	b94b      	cbnz	r3, 1bae8 <close+0x38>
   1bad4:	490b      	ldr	r1, [pc, #44]	; (1bb04 <close+0x54>)
   1bad6:	4809      	ldr	r0, [pc, #36]	; (1bafc <close+0x4c>)
   1bad8:	2322      	movs	r3, #34	; 0x22
   1bada:	4a09      	ldr	r2, [pc, #36]	; (1bb00 <close+0x50>)
   1badc:	f011 fbb5 	bl	2d24a <printk>
   1bae0:	2122      	movs	r1, #34	; 0x22
   1bae2:	4807      	ldr	r0, [pc, #28]	; (1bb00 <close+0x50>)
   1bae4:	f011 fbf7 	bl	2d2d6 <assert_post_action>
	return socket_ops->close(sock);
   1bae8:	6823      	ldr	r3, [r4, #0]
   1baea:	4628      	mov	r0, r5
}
   1baec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return socket_ops->close(sock);
   1baf0:	685b      	ldr	r3, [r3, #4]
   1baf2:	4718      	bx	r3
   1baf4:	20028668 	.word	0x20028668
   1baf8:	00031ad5 	.word	0x00031ad5
   1bafc:	000311a3 	.word	0x000311a3
   1bb00:	00031aa5 	.word	0x00031aa5
   1bb04:	000332ae 	.word	0x000332ae

0001bb08 <callback_worker>:

	return new_len;
}

static void callback_worker(struct k_work *item)
{
   1bb08:	b507      	push	{r0, r1, r2, lr}
	struct callback_work_item *data =
   1bb0a:	9001      	str	r0, [sp, #4]
		CONTAINER_OF(item, struct callback_work_item, work);

	if (data != NULL) {
   1bb0c:	b118      	cbz	r0, 1bb16 <callback_worker+0xe>
		data->callback(data->data);
   1bb0e:	f8d0 3a98 	ldr.w	r3, [r0, #2712]	; 0xa98
   1bb12:	300c      	adds	r0, #12
   1bb14:	4798      	blx	r3
	}

	k_mem_slab_free(&rsp_work_items, (void **)&data);
   1bb16:	a901      	add	r1, sp, #4
   1bb18:	4802      	ldr	r0, [pc, #8]	; (1bb24 <callback_worker+0x1c>)
   1bb1a:	f00a fd7b 	bl	26614 <k_mem_slab_free>
}
   1bb1e:	b003      	add	sp, #12
   1bb20:	f85d fb04 	ldr.w	pc, [sp], #4
   1bb24:	2003b818 	.word	0x2003b818

0001bb28 <open_socket>:
{
   1bb28:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(socket_ops);
   1bb2a:	4c16      	ldr	r4, [pc, #88]	; (1bb84 <open_socket+0x5c>)
   1bb2c:	6823      	ldr	r3, [r4, #0]
   1bb2e:	b94b      	cbnz	r3, 1bb44 <open_socket+0x1c>
   1bb30:	4915      	ldr	r1, [pc, #84]	; (1bb88 <open_socket+0x60>)
   1bb32:	4816      	ldr	r0, [pc, #88]	; (1bb8c <open_socket+0x64>)
   1bb34:	2319      	movs	r3, #25
   1bb36:	4a16      	ldr	r2, [pc, #88]	; (1bb90 <open_socket+0x68>)
   1bb38:	f011 fb87 	bl	2d24a <printk>
   1bb3c:	2119      	movs	r1, #25
   1bb3e:	4814      	ldr	r0, [pc, #80]	; (1bb90 <open_socket+0x68>)
   1bb40:	f011 fbc9 	bl	2d2d6 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->socket);
   1bb44:	6823      	ldr	r3, [r4, #0]
   1bb46:	681b      	ldr	r3, [r3, #0]
   1bb48:	b94b      	cbnz	r3, 1bb5e <open_socket+0x36>
   1bb4a:	4912      	ldr	r1, [pc, #72]	; (1bb94 <open_socket+0x6c>)
   1bb4c:	480f      	ldr	r0, [pc, #60]	; (1bb8c <open_socket+0x64>)
   1bb4e:	231a      	movs	r3, #26
   1bb50:	4a0f      	ldr	r2, [pc, #60]	; (1bb90 <open_socket+0x68>)
   1bb52:	f011 fb7a 	bl	2d24a <printk>
   1bb56:	211a      	movs	r1, #26
   1bb58:	480d      	ldr	r0, [pc, #52]	; (1bb90 <open_socket+0x68>)
   1bb5a:	f011 fbbc 	bl	2d2d6 <assert_post_action>
	return socket_ops->socket(family, type, proto);
   1bb5e:	6823      	ldr	r3, [r4, #0]
   1bb60:	f240 2201 	movw	r2, #513	; 0x201
   1bb64:	681b      	ldr	r3, [r3, #0]
   1bb66:	2102      	movs	r1, #2
   1bb68:	2066      	movs	r0, #102	; 0x66
   1bb6a:	4798      	blx	r3
	common_socket_fd = socket(AF_LTE, SOCK_DGRAM, NPROTO_AT);
   1bb6c:	4b0a      	ldr	r3, [pc, #40]	; (1bb98 <open_socket+0x70>)
   1bb6e:	6018      	str	r0, [r3, #0]
	if (common_socket_fd == -1) {
   1bb70:	3001      	adds	r0, #1
   1bb72:	d104      	bne.n	1bb7e <open_socket+0x56>
		return -errno;
   1bb74:	f011 fd64 	bl	2d640 <__errno>
   1bb78:	6800      	ldr	r0, [r0, #0]
   1bb7a:	4240      	negs	r0, r0
}
   1bb7c:	bd10      	pop	{r4, pc}
	return 0;
   1bb7e:	2000      	movs	r0, #0
   1bb80:	e7fc      	b.n	1bb7c <open_socket+0x54>
   1bb82:	bf00      	nop
   1bb84:	20028668 	.word	0x20028668
   1bb88:	00031ad5 	.word	0x00031ad5
   1bb8c:	000311a3 	.word	0x000311a3
   1bb90:	00031aa5 	.word	0x00031aa5
   1bb94:	000332c0 	.word	0x000332c0
   1bb98:	200287f4 	.word	0x200287f4

0001bb9c <at_write>:
		}
	}
}

static inline int at_write(const char *const cmd, enum at_cmd_state *state)
{
   1bb9c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   1bba0:	4680      	mov	r8, r0
   1bba2:	460d      	mov	r5, r1
	int bytes_sent;
	int bytes_to_send = strlen(cmd);
   1bba4:	f7f1 f9d8 	bl	cf58 <strlen>
	__ASSERT_NO_MSG(socket_ops);
   1bba8:	4c30      	ldr	r4, [pc, #192]	; (1bc6c <at_write+0xd0>)
	struct return_state_object ret;

	LOG_DBG("Sending command %s", log_strdup(cmd));

	bytes_sent = send(common_socket_fd, cmd, bytes_to_send, 0);
   1bbaa:	4b31      	ldr	r3, [pc, #196]	; (1bc70 <at_write+0xd4>)
	int bytes_to_send = strlen(cmd);
   1bbac:	4606      	mov	r6, r0
	bytes_sent = send(common_socket_fd, cmd, bytes_to_send, 0);
   1bbae:	681f      	ldr	r7, [r3, #0]
   1bbb0:	6823      	ldr	r3, [r4, #0]
   1bbb2:	b94b      	cbnz	r3, 1bbc8 <at_write+0x2c>
   1bbb4:	492f      	ldr	r1, [pc, #188]	; (1bc74 <at_write+0xd8>)
   1bbb6:	4830      	ldr	r0, [pc, #192]	; (1bc78 <at_write+0xdc>)
   1bbb8:	237e      	movs	r3, #126	; 0x7e
   1bbba:	4a30      	ldr	r2, [pc, #192]	; (1bc7c <at_write+0xe0>)
   1bbbc:	f011 fb45 	bl	2d24a <printk>
   1bbc0:	217e      	movs	r1, #126	; 0x7e
   1bbc2:	482e      	ldr	r0, [pc, #184]	; (1bc7c <at_write+0xe0>)
   1bbc4:	f011 fb87 	bl	2d2d6 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->send);
   1bbc8:	6823      	ldr	r3, [r4, #0]
   1bbca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1bbcc:	b94b      	cbnz	r3, 1bbe2 <at_write+0x46>
   1bbce:	492c      	ldr	r1, [pc, #176]	; (1bc80 <at_write+0xe4>)
   1bbd0:	4829      	ldr	r0, [pc, #164]	; (1bc78 <at_write+0xdc>)
   1bbd2:	237f      	movs	r3, #127	; 0x7f
   1bbd4:	4a29      	ldr	r2, [pc, #164]	; (1bc7c <at_write+0xe0>)
   1bbd6:	f011 fb38 	bl	2d24a <printk>
   1bbda:	217f      	movs	r1, #127	; 0x7f
   1bbdc:	4827      	ldr	r0, [pc, #156]	; (1bc7c <at_write+0xe0>)
   1bbde:	f011 fb7a 	bl	2d2d6 <assert_post_action>
	return socket_ops->send(sock, buf, len, flags);
   1bbe2:	6823      	ldr	r3, [r4, #0]
   1bbe4:	4632      	mov	r2, r6
   1bbe6:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   1bbe8:	4641      	mov	r1, r8
   1bbea:	2300      	movs	r3, #0
   1bbec:	4638      	mov	r0, r7
   1bbee:	47a0      	blx	r4

	if (bytes_sent == -1) {
   1bbf0:	1c43      	adds	r3, r0, #1
   1bbf2:	4604      	mov	r4, r0
   1bbf4:	d121      	bne.n	1bc3a <at_write+0x9e>
		LOG_ERR("Failed to send AT command (err:%d)", errno);
   1bbf6:	2301      	movs	r3, #1
   1bbf8:	f04f 0400 	mov.w	r4, #0
   1bbfc:	4a21      	ldr	r2, [pc, #132]	; (1bc84 <at_write+0xe8>)
   1bbfe:	f363 0407 	bfi	r4, r3, #0, #8
   1bc02:	4b21      	ldr	r3, [pc, #132]	; (1bc88 <at_write+0xec>)
   1bc04:	1a9b      	subs	r3, r3, r2
   1bc06:	08db      	lsrs	r3, r3, #3
   1bc08:	f363 148f 	bfi	r4, r3, #6, #10
   1bc0c:	f011 fd18 	bl	2d640 <__errno>
   1bc10:	491e      	ldr	r1, [pc, #120]	; (1bc8c <at_write+0xf0>)
   1bc12:	6802      	ldr	r2, [r0, #0]
   1bc14:	4620      	mov	r0, r4
   1bc16:	f011 fb6f 	bl	2d2f8 <log_string_sync>
		ret.code  = -errno;
   1bc1a:	f011 fd11 	bl	2d640 <__errno>
   1bc1e:	6803      	ldr	r3, [r0, #0]
   1bc20:	425b      	negs	r3, r3
   1bc22:	9300      	str	r3, [sp, #0]
		ret.state = AT_CMD_ERROR;
   1bc24:	2301      	movs	r3, #1
   1bc26:	f88d 3004 	strb.w	r3, [sp, #4]
				"same as expected (%d)",
				bytes_sent, bytes_to_send);
		}
	}

	if (state) {
   1bc2a:	b115      	cbz	r5, 1bc32 <at_write+0x96>
		*state = ret.state;
   1bc2c:	f89d 3004 	ldrb.w	r3, [sp, #4]
   1bc30:	702b      	strb	r3, [r5, #0]
	}

	return ret.code;
}
   1bc32:	9800      	ldr	r0, [sp, #0]
   1bc34:	b002      	add	sp, #8
   1bc36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&msgq, *(uintptr_t *)&data, *(uintptr_t *)&timeout, K_SYSCALL_K_MSGQ_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_get(msgq, data, timeout);
   1bc3a:	f04f 32ff 	mov.w	r2, #4294967295
   1bc3e:	4669      	mov	r1, sp
   1bc40:	4813      	ldr	r0, [pc, #76]	; (1bc90 <at_write+0xf4>)
   1bc42:	f00a fef9 	bl	26a38 <z_impl_k_msgq_get>
		if (bytes_sent != bytes_to_send) {
   1bc46:	42a6      	cmp	r6, r4
   1bc48:	d0ef      	beq.n	1bc2a <at_write+0x8e>
			LOG_ERR("Bytes sent (%d) was not the "
   1bc4a:	2301      	movs	r3, #1
   1bc4c:	f04f 0000 	mov.w	r0, #0
   1bc50:	4a0c      	ldr	r2, [pc, #48]	; (1bc84 <at_write+0xe8>)
   1bc52:	f363 0007 	bfi	r0, r3, #0, #8
   1bc56:	4b0c      	ldr	r3, [pc, #48]	; (1bc88 <at_write+0xec>)
   1bc58:	490e      	ldr	r1, [pc, #56]	; (1bc94 <at_write+0xf8>)
   1bc5a:	1a9b      	subs	r3, r3, r2
   1bc5c:	08db      	lsrs	r3, r3, #3
   1bc5e:	f363 108f 	bfi	r0, r3, #6, #10
   1bc62:	4622      	mov	r2, r4
   1bc64:	4633      	mov	r3, r6
   1bc66:	f011 fb47 	bl	2d2f8 <log_string_sync>
   1bc6a:	e7de      	b.n	1bc2a <at_write+0x8e>
   1bc6c:	20028668 	.word	0x20028668
   1bc70:	200287f4 	.word	0x200287f4
   1bc74:	00031ad5 	.word	0x00031ad5
   1bc78:	000311a3 	.word	0x000311a3
   1bc7c:	00031aa5 	.word	0x00031aa5
   1bc80:	000332f8 	.word	0x000332f8
   1bc84:	0003040c 	.word	0x0003040c
   1bc88:	00030414 	.word	0x00030414
   1bc8c:	00033856 	.word	0x00033856
   1bc90:	2003b93c 	.word	0x2003b93c
   1bc94:	00033879 	.word	0x00033879

0001bc98 <socket_thread_fn>:
{
   1bc98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
					LOG_ERR("Response buffer not large "
   1bc9c:	4b9e      	ldr	r3, [pc, #632]	; (1bf18 <socket_thread_fn+0x280>)
   1bc9e:	4c9f      	ldr	r4, [pc, #636]	; (1bf1c <socket_thread_fn+0x284>)
{
   1bca0:	b087      	sub	sp, #28
					LOG_ERR("Response buffer not large "
   1bca2:	1ae4      	subs	r4, r4, r3
   1bca4:	f3c4 04c9 	ubfx	r4, r4, #3, #10
		k_mem_slab_alloc(&rsp_work_items, (void **)&item, K_FOREVER);
   1bca8:	f04f 32ff 	mov.w	r2, #4294967295
   1bcac:	a903      	add	r1, sp, #12
   1bcae:	489c      	ldr	r0, [pc, #624]	; (1bf20 <socket_thread_fn+0x288>)
   1bcb0:	f00a fc4c 	bl	2654c <k_mem_slab_alloc>
		ret.code  = 0;
   1bcb4:	2300      	movs	r3, #0
		item->callback = NULL;
   1bcb6:	9d03      	ldr	r5, [sp, #12]
		ret.code  = 0;
   1bcb8:	9304      	str	r3, [sp, #16]
		item->callback = NULL;
   1bcba:	f8c5 3a98 	str.w	r3, [r5, #2712]	; 0xa98
		ret.state = AT_CMD_OK;
   1bcbe:	f88d 3014 	strb.w	r3, [sp, #20]
	__ASSERT_NO_MSG(socket_ops);
   1bcc2:	f8df a2b4 	ldr.w	sl, [pc, #692]	; 1bf78 <socket_thread_fn+0x2e0>
		bytes_read = recv(common_socket_fd, item->data,
   1bcc6:	4b97      	ldr	r3, [pc, #604]	; (1bf24 <socket_thread_fn+0x28c>)
   1bcc8:	350c      	adds	r5, #12
   1bcca:	f8d3 b000 	ldr.w	fp, [r3]
   1bcce:	f8da 3000 	ldr.w	r3, [sl]
   1bcd2:	b94b      	cbnz	r3, 1bce8 <socket_thread_fn+0x50>
   1bcd4:	4994      	ldr	r1, [pc, #592]	; (1bf28 <socket_thread_fn+0x290>)
   1bcd6:	4895      	ldr	r0, [pc, #596]	; (1bf2c <socket_thread_fn+0x294>)
   1bcd8:	2369      	movs	r3, #105	; 0x69
   1bcda:	4a95      	ldr	r2, [pc, #596]	; (1bf30 <socket_thread_fn+0x298>)
   1bcdc:	f011 fab5 	bl	2d24a <printk>
   1bce0:	2169      	movs	r1, #105	; 0x69
   1bce2:	4893      	ldr	r0, [pc, #588]	; (1bf30 <socket_thread_fn+0x298>)
   1bce4:	f011 faf7 	bl	2d2d6 <assert_post_action>
	__ASSERT_NO_MSG(socket_ops->recv);
   1bce8:	f8da 3000 	ldr.w	r3, [sl]
   1bcec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1bcee:	b94b      	cbnz	r3, 1bd04 <socket_thread_fn+0x6c>
   1bcf0:	4990      	ldr	r1, [pc, #576]	; (1bf34 <socket_thread_fn+0x29c>)
   1bcf2:	488e      	ldr	r0, [pc, #568]	; (1bf2c <socket_thread_fn+0x294>)
   1bcf4:	236a      	movs	r3, #106	; 0x6a
   1bcf6:	4a8e      	ldr	r2, [pc, #568]	; (1bf30 <socket_thread_fn+0x298>)
   1bcf8:	f011 faa7 	bl	2d24a <printk>
   1bcfc:	216a      	movs	r1, #106	; 0x6a
   1bcfe:	488c      	ldr	r0, [pc, #560]	; (1bf30 <socket_thread_fn+0x298>)
   1bd00:	f011 fae9 	bl	2d2d6 <assert_post_action>
	return socket_ops->recv(sock, buf, max_len, flags);
   1bd04:	f8da 3000 	ldr.w	r3, [sl]
   1bd08:	f640 228c 	movw	r2, #2700	; 0xa8c
   1bd0c:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
   1bd10:	4629      	mov	r1, r5
   1bd12:	2300      	movs	r3, #0
   1bd14:	4658      	mov	r0, fp
   1bd16:	47d0      	blx	sl
		if (bytes_read < 0) {
   1bd18:	1e02      	subs	r2, r0, #0
   1bd1a:	da58      	bge.n	1bdce <socket_thread_fn+0x136>
			LOG_ERR("AT socket recv failed with err %d",
   1bd1c:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   1bd20:	f043 0301 	orr.w	r3, r3, #1
   1bd24:	f363 0607 	bfi	r6, r3, #0, #8
   1bd28:	f364 168f 	bfi	r6, r4, #6, #10
   1bd2c:	4630      	mov	r0, r6
   1bd2e:	4982      	ldr	r1, [pc, #520]	; (1bf38 <socket_thread_fn+0x2a0>)
   1bd30:	f011 fae2 	bl	2d2f8 <log_string_sync>
			if ((close(common_socket_fd) == 0) &&
   1bd34:	4b7b      	ldr	r3, [pc, #492]	; (1bf24 <socket_thread_fn+0x28c>)
   1bd36:	6818      	ldr	r0, [r3, #0]
   1bd38:	f7ff feba 	bl	1bab0 <close>
   1bd3c:	2800      	cmp	r0, #0
   1bd3e:	d131      	bne.n	1bda4 <socket_thread_fn+0x10c>
			    (open_socket() == 0)) {
   1bd40:	f7ff fef2 	bl	1bb28 <open_socket>
			if ((close(common_socket_fd) == 0) &&
   1bd44:	bb70      	cbnz	r0, 1bda4 <socket_thread_fn+0x10c>
				LOG_INF("AT socket recovered");
   1bd46:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
   1bd4a:	f043 0303 	orr.w	r3, r3, #3
   1bd4e:	f363 0707 	bfi	r7, r3, #0, #8
   1bd52:	f364 178f 	bfi	r7, r4, #6, #10
   1bd56:	4979      	ldr	r1, [pc, #484]	; (1bf3c <socket_thread_fn+0x2a4>)
   1bd58:	4638      	mov	r0, r7
   1bd5a:	f011 facd 	bl	2d2f8 <log_string_sync>
				ret.state = AT_CMD_ERROR;
   1bd5e:	2301      	movs	r3, #1
   1bd60:	f88d 3014 	strb.w	r3, [sp, #20]
				ret.code  = -errno;
   1bd64:	f011 fc6c 	bl	2d640 <__errno>
   1bd68:	6803      	ldr	r3, [r0, #0]
   1bd6a:	425b      	negs	r3, r3
			ret.code  = -ENOBUFS;
   1bd6c:	9304      	str	r3, [sp, #16]
		if (item->callback == NULL) {
   1bd6e:	9903      	ldr	r1, [sp, #12]
   1bd70:	f8d1 3a98 	ldr.w	r3, [r1, #2712]	; 0xa98
   1bd74:	2b00      	cmp	r3, #0
   1bd76:	f040 80a5 	bne.w	1bec4 <socket_thread_fn+0x22c>
			k_mem_slab_free(&rsp_work_items, (void **)&item);
   1bd7a:	a903      	add	r1, sp, #12
   1bd7c:	4868      	ldr	r0, [pc, #416]	; (1bf20 <socket_thread_fn+0x288>)
   1bd7e:	f00a fc49 	bl	26614 <k_mem_slab_free>
	return z_impl_k_sem_count_get(sem);
   1bd82:	4b6f      	ldr	r3, [pc, #444]	; (1bf40 <socket_thread_fn+0x2a8>)
		if ((k_sem_count_get(&cmd_pending) == 0) &&
   1bd84:	689b      	ldr	r3, [r3, #8]
   1bd86:	2b00      	cmp	r3, #0
   1bd88:	d18e      	bne.n	1bca8 <socket_thread_fn+0x10>
   1bd8a:	f89d 2014 	ldrb.w	r2, [sp, #20]
   1bd8e:	2a04      	cmp	r2, #4
   1bd90:	d08a      	beq.n	1bca8 <socket_thread_fn+0x10>
			current_cmd_handler = NULL;
   1bd92:	4a6c      	ldr	r2, [pc, #432]	; (1bf44 <socket_thread_fn+0x2ac>)
   1bd94:	6013      	str	r3, [r2, #0]
	return z_impl_k_msgq_put(msgq, data, timeout);
   1bd96:	f04f 32ff 	mov.w	r2, #4294967295
   1bd9a:	a904      	add	r1, sp, #16
   1bd9c:	486a      	ldr	r0, [pc, #424]	; (1bf48 <socket_thread_fn+0x2b0>)
   1bd9e:	f00a fdab 	bl	268f8 <z_impl_k_msgq_put>
   1bda2:	e781      	b.n	1bca8 <socket_thread_fn+0x10>
			LOG_ERR("Unrecoverable reception error (err: %d), "
   1bda4:	2301      	movs	r3, #1
   1bda6:	f04f 0500 	mov.w	r5, #0
   1bdaa:	f363 0507 	bfi	r5, r3, #0, #8
   1bdae:	f011 fc47 	bl	2d640 <__errno>
   1bdb2:	f364 158f 	bfi	r5, r4, #6, #10
   1bdb6:	6802      	ldr	r2, [r0, #0]
   1bdb8:	4964      	ldr	r1, [pc, #400]	; (1bf4c <socket_thread_fn+0x2b4>)
   1bdba:	4628      	mov	r0, r5
   1bdbc:	f011 fa9c 	bl	2d2f8 <log_string_sync>
			close(common_socket_fd);
   1bdc0:	4b58      	ldr	r3, [pc, #352]	; (1bf24 <socket_thread_fn+0x28c>)
   1bdc2:	6818      	ldr	r0, [r3, #0]
   1bdc4:	f7ff fe74 	bl	1bab0 <close>
}
   1bdc8:	b007      	add	sp, #28
   1bdca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (bytes_read == sizeof(item->data) ||
   1bdce:	f640 238c 	movw	r3, #2700	; 0xa8c
   1bdd2:	429a      	cmp	r2, r3
   1bdd4:	d004      	beq.n	1bde0 <socket_thread_fn+0x148>
			   item->data[bytes_read - 1] != '\0') {
   1bdd6:	f8dd a00c 	ldr.w	sl, [sp, #12]
   1bdda:	4452      	add	r2, sl
		} else if (bytes_read == sizeof(item->data) ||
   1bddc:	7ad3      	ldrb	r3, [r2, #11]
   1bdde:	b173      	cbz	r3, 1bdfe <socket_thread_fn+0x166>
			LOG_ERR("AT message to large for reception buffer or "
   1bde0:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   1bde4:	f043 0301 	orr.w	r3, r3, #1
   1bde8:	f363 0807 	bfi	r8, r3, #0, #8
   1bdec:	f364 188f 	bfi	r8, r4, #6, #10
   1bdf0:	4957      	ldr	r1, [pc, #348]	; (1bf50 <socket_thread_fn+0x2b8>)
   1bdf2:	4640      	mov	r0, r8
   1bdf4:	f011 fa80 	bl	2d2f8 <log_string_sync>
			ret.code  = -ENOBUFS;
   1bdf8:	f06f 0368 	mvn.w	r3, #104	; 0x68
   1bdfc:	e7b6      	b.n	1bd6c <socket_thread_fn+0xd4>
	ret->state = AT_CMD_NOTIFICATION;
   1bdfe:	2204      	movs	r2, #4
		payload_len = get_return_code(item->data, &ret);
   1be00:	f10a 050c 	add.w	r5, sl, #12
		tmpstr = strstr(buf, AT_CMD_OK_STR);
   1be04:	4953      	ldr	r1, [pc, #332]	; (1bf54 <socket_thread_fn+0x2bc>)
   1be06:	4628      	mov	r0, r5
   1be08:	9301      	str	r3, [sp, #4]
	ret->state = AT_CMD_NOTIFICATION;
   1be0a:	f88d 2014 	strb.w	r2, [sp, #20]
		tmpstr = strstr(buf, AT_CMD_OK_STR);
   1be0e:	f013 fc6f 	bl	2f6f0 <strstr>
		if (tmpstr) {
   1be12:	4683      	mov	fp, r0
   1be14:	b120      	cbz	r0, 1be20 <socket_thread_fn+0x188>
			ret->state = AT_CMD_OK;
   1be16:	9b01      	ldr	r3, [sp, #4]
   1be18:	f88d 3014 	strb.w	r3, [sp, #20]
			ret->code  = -ENOEXEC;
   1be1c:	9304      	str	r3, [sp, #16]
			break;
   1be1e:	e00d      	b.n	1be3c <socket_thread_fn+0x1a4>
		tmpstr = strstr(buf, AT_CMD_CMS_STR);
   1be20:	494d      	ldr	r1, [pc, #308]	; (1bf58 <socket_thread_fn+0x2c0>)
   1be22:	4628      	mov	r0, r5
   1be24:	f013 fc64 	bl	2f6f0 <strstr>
		if (tmpstr) {
   1be28:	4683      	mov	fp, r0
   1be2a:	b330      	cbz	r0, 1be7a <socket_thread_fn+0x1e2>
			ret->state = AT_CMD_ERROR_CMS;
   1be2c:	2302      	movs	r3, #2
			ret->code = atoi(&buf[ARRAY_SIZE(AT_CMD_CMS_STR) - 1]);
   1be2e:	f10a 0017 	add.w	r0, sl, #23
			ret->state = AT_CMD_ERROR_CME;
   1be32:	f88d 3014 	strb.w	r3, [sp, #20]
			ret->code = atoi(&buf[ARRAY_SIZE(AT_CMD_CMS_STR) - 1]);
   1be36:	f013 fa6d 	bl	2f314 <atoi>
   1be3a:	9004      	str	r0, [sp, #16]
		buf[new_len++] = '\0';
   1be3c:	2300      	movs	r3, #0
		new_len = tmpstr - buf;
   1be3e:	ebab 0205 	sub.w	r2, fp, r5
		buf[new_len++] = '\0';
   1be42:	3201      	adds	r2, #1
   1be44:	f88b 3000 	strb.w	r3, [fp]
		if (ret.state != AT_CMD_NOTIFICATION) {
   1be48:	f89d 3014 	ldrb.w	r3, [sp, #20]
   1be4c:	2b04      	cmp	r3, #4
   1be4e:	d04f      	beq.n	1bef0 <socket_thread_fn+0x258>
			if ((response_buf_len > 0) &&
   1be50:	f8df a128 	ldr.w	sl, [pc, #296]	; 1bf7c <socket_thread_fn+0x2e4>
   1be54:	f8da 3000 	ldr.w	r3, [sl]
   1be58:	2b00      	cmp	r3, #0
   1be5a:	d052      	beq.n	1bf02 <socket_thread_fn+0x26a>
			    (response_buf != NULL)) {
   1be5c:	4d3f      	ldr	r5, [pc, #252]	; (1bf5c <socket_thread_fn+0x2c4>)
   1be5e:	6828      	ldr	r0, [r5, #0]
			if ((response_buf_len > 0) &&
   1be60:	2800      	cmp	r0, #0
   1be62:	d04e      	beq.n	1bf02 <socket_thread_fn+0x26a>
				if (response_buf_len > payload_len) {
   1be64:	4293      	cmp	r3, r2
   1be66:	d91d      	bls.n	1bea4 <socket_thread_fn+0x20c>
   1be68:	9903      	ldr	r1, [sp, #12]
   1be6a:	310c      	adds	r1, #12
   1be6c:	f013 fa72 	bl	2f354 <memcpy>
				response_buf_len = 0;
   1be70:	2300      	movs	r3, #0
   1be72:	f8ca 3000 	str.w	r3, [sl]
				response_buf     = NULL;
   1be76:	602b      	str	r3, [r5, #0]
				goto next;
   1be78:	e779      	b.n	1bd6e <socket_thread_fn+0xd6>
		tmpstr = strstr(buf, AT_CMD_CME_STR);
   1be7a:	4939      	ldr	r1, [pc, #228]	; (1bf60 <socket_thread_fn+0x2c8>)
   1be7c:	4628      	mov	r0, r5
   1be7e:	f013 fc37 	bl	2f6f0 <strstr>
		if (tmpstr) {
   1be82:	4683      	mov	fp, r0
   1be84:	b108      	cbz	r0, 1be8a <socket_thread_fn+0x1f2>
			ret->state = AT_CMD_ERROR_CME;
   1be86:	2303      	movs	r3, #3
   1be88:	e7d1      	b.n	1be2e <socket_thread_fn+0x196>
		tmpstr = strstr(buf, AT_CMD_ERROR_STR);
   1be8a:	4936      	ldr	r1, [pc, #216]	; (1bf64 <socket_thread_fn+0x2cc>)
   1be8c:	4628      	mov	r0, r5
   1be8e:	f013 fc2f 	bl	2f6f0 <strstr>
		if (tmpstr) {
   1be92:	4683      	mov	fp, r0
   1be94:	2800      	cmp	r0, #0
   1be96:	d039      	beq.n	1bf0c <socket_thread_fn+0x274>
			ret->state = AT_CMD_ERROR;
   1be98:	2301      	movs	r3, #1
   1be9a:	f88d 3014 	strb.w	r3, [sp, #20]
			ret->code  = -ENOEXEC;
   1be9e:	f06f 0307 	mvn.w	r3, #7
   1bea2:	e7bb      	b.n	1be1c <socket_thread_fn+0x184>
					LOG_ERR("Response buffer not large "
   1bea4:	f029 033f 	bic.w	r3, r9, #63	; 0x3f
   1bea8:	f043 0301 	orr.w	r3, r3, #1
   1beac:	f363 0907 	bfi	r9, r3, #0, #8
   1beb0:	f364 198f 	bfi	r9, r4, #6, #10
   1beb4:	492c      	ldr	r1, [pc, #176]	; (1bf68 <socket_thread_fn+0x2d0>)
   1beb6:	4648      	mov	r0, r9
   1beb8:	f011 fa1e 	bl	2d2f8 <log_string_sync>
					ret.code  = -EMSGSIZE;
   1bebc:	f06f 0379 	mvn.w	r3, #121	; 0x79
   1bec0:	9304      	str	r3, [sp, #16]
   1bec2:	e7d5      	b.n	1be70 <socket_thread_fn+0x1d8>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   1bec4:	4b29      	ldr	r3, [pc, #164]	; (1bf6c <socket_thread_fn+0x2d4>)
   1bec6:	2200      	movs	r2, #0
   1bec8:	604b      	str	r3, [r1, #4]
   1beca:	460b      	mov	r3, r1
   1becc:	600a      	str	r2, [r1, #0]
   1bece:	f843 2f08 	str.w	r2, [r3, #8]!
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1bed2:	e8d3 2fef 	ldaex	r2, [r3]
   1bed6:	f042 0001 	orr.w	r0, r2, #1
   1beda:	e8c3 0fe5 	stlex	r5, r0, [r3]
   1bede:	2d00      	cmp	r5, #0
   1bee0:	d1f7      	bne.n	1bed2 <socket_thread_fn+0x23a>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   1bee2:	07d3      	lsls	r3, r2, #31
   1bee4:	f53f af4d 	bmi.w	1bd82 <socket_thread_fn+0xea>
		k_queue_append(&work_q->queue, work);
   1bee8:	4821      	ldr	r0, [pc, #132]	; (1bf70 <socket_thread_fn+0x2d8>)
   1beea:	f013 f89a 	bl	2f022 <k_queue_append>
   1beee:	e748      	b.n	1bd82 <socket_thread_fn+0xea>
		if (payload_len == 0) {
   1bef0:	2a00      	cmp	r2, #0
   1bef2:	f43f af3c 	beq.w	1bd6e <socket_thread_fn+0xd6>
			item->callback = notification_handler;
   1bef6:	4b1f      	ldr	r3, [pc, #124]	; (1bf74 <socket_thread_fn+0x2dc>)
			item->callback = current_cmd_handler;
   1bef8:	681a      	ldr	r2, [r3, #0]
   1befa:	9b03      	ldr	r3, [sp, #12]
   1befc:	f8c3 2a98 	str.w	r2, [r3, #2712]	; 0xa98
   1bf00:	e735      	b.n	1bd6e <socket_thread_fn+0xd6>
		if (payload_len == 0) {
   1bf02:	2a00      	cmp	r2, #0
   1bf04:	f43f af33 	beq.w	1bd6e <socket_thread_fn+0xd6>
			item->callback = current_cmd_handler;
   1bf08:	4b0e      	ldr	r3, [pc, #56]	; (1bf44 <socket_thread_fn+0x2ac>)
   1bf0a:	e7f5      	b.n	1bef8 <socket_thread_fn+0x260>
		new_len = strlen(buf) + 1;
   1bf0c:	4628      	mov	r0, r5
   1bf0e:	f7f1 f823 	bl	cf58 <strlen>
   1bf12:	1c42      	adds	r2, r0, #1
   1bf14:	e798      	b.n	1be48 <socket_thread_fn+0x1b0>
   1bf16:	bf00      	nop
   1bf18:	0003040c 	.word	0x0003040c
   1bf1c:	00030414 	.word	0x00030414
   1bf20:	2003b818 	.word	0x2003b818
   1bf24:	200287f4 	.word	0x200287f4
   1bf28:	00031ad5 	.word	0x00031ad5
   1bf2c:	000311a3 	.word	0x000311a3
   1bf30:	00031aa5 	.word	0x00031aa5
   1bf34:	000332e7 	.word	0x000332e7
   1bf38:	000338ab 	.word	0x000338ab
   1bf3c:	000338cd 	.word	0x000338cd
   1bf40:	2003b880 	.word	0x2003b880
   1bf44:	200287f8 	.word	0x200287f8
   1bf48:	2003b93c 	.word	0x2003b93c
   1bf4c:	000338e1 	.word	0x000338e1
   1bf50:	00033918 	.word	0x00033918
   1bf54:	0003215e 	.word	0x0003215e
   1bf58:	00033962 	.word	0x00033962
   1bf5c:	20028800 	.word	0x20028800
   1bf60:	0003396e 	.word	0x0003396e
   1bf64:	0003397a 	.word	0x0003397a
   1bf68:	00033980 	.word	0x00033980
   1bf6c:	0001bb09 	.word	0x0001bb09
   1bf70:	2002d330 	.word	0x2002d330
   1bf74:	200287fc 	.word	0x200287fc
   1bf78:	20028668 	.word	0x20028668
   1bf7c:	20028804 	.word	0x20028804

0001bf80 <at_cmd_driver_init>:

	k_sem_give(&cmd_pending);
}

static int at_cmd_driver_init(struct device *dev)
{
   1bf80:	b510      	push	{r4, lr}
	static bool initialized;

	if (initialized) {
   1bf82:	4b16      	ldr	r3, [pc, #88]	; (1bfdc <at_cmd_driver_init+0x5c>)
{
   1bf84:	b086      	sub	sp, #24
	if (initialized) {
   1bf86:	781a      	ldrb	r2, [r3, #0]
   1bf88:	bb32      	cbnz	r2, 1bfd8 <at_cmd_driver_init+0x58>
		return 0;
	}

	initialized = true;
   1bf8a:	2201      	movs	r2, #1
   1bf8c:	701a      	strb	r2, [r3, #0]

	int err;

	ARG_UNUSED(dev);

	err = open_socket();
   1bf8e:	f7ff fdcb 	bl	1bb28 <open_socket>
	if (err) {
   1bf92:	4604      	mov	r4, r0
   1bf94:	b188      	cbz	r0, 1bfba <at_cmd_driver_init+0x3a>
		LOG_ERR("Failed to open AT socket (err:%d)", err);
   1bf96:	2301      	movs	r3, #1
   1bf98:	f04f 0000 	mov.w	r0, #0
   1bf9c:	4a10      	ldr	r2, [pc, #64]	; (1bfe0 <at_cmd_driver_init+0x60>)
   1bf9e:	f363 0007 	bfi	r0, r3, #0, #8
   1bfa2:	4b10      	ldr	r3, [pc, #64]	; (1bfe4 <at_cmd_driver_init+0x64>)
   1bfa4:	4910      	ldr	r1, [pc, #64]	; (1bfe8 <at_cmd_driver_init+0x68>)
   1bfa6:	1a9b      	subs	r3, r3, r2
   1bfa8:	08db      	lsrs	r3, r3, #3
   1bfaa:	f363 108f 	bfi	r0, r3, #6, #10
   1bfae:	4622      	mov	r2, r4
   1bfb0:	f011 f9a2 	bl	2d2f8 <log_string_sync>
			THREAD_PRIORITY, 0, K_NO_WAIT);

	LOG_DBG("Common AT socket processing thread created");

	return 0;
}
   1bfb4:	4620      	mov	r0, r4
   1bfb6:	b006      	add	sp, #24
   1bfb8:	bd10      	pop	{r4, pc}
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   1bfba:	230a      	movs	r3, #10
   1bfbc:	e9cd 0004 	strd	r0, r0, [sp, #16]
   1bfc0:	e9cd 0302 	strd	r0, r3, [sp, #8]
   1bfc4:	e9cd 0000 	strd	r0, r0, [sp]
   1bfc8:	4b08      	ldr	r3, [pc, #32]	; (1bfec <at_cmd_driver_init+0x6c>)
   1bfca:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1bfce:	4908      	ldr	r1, [pc, #32]	; (1bff0 <at_cmd_driver_init+0x70>)
   1bfd0:	4808      	ldr	r0, [pc, #32]	; (1bff4 <at_cmd_driver_init+0x74>)
   1bfd2:	f00c fc07 	bl	287e4 <z_impl_k_thread_create>
	return 0;
   1bfd6:	e7ed      	b.n	1bfb4 <at_cmd_driver_init+0x34>
		return 0;
   1bfd8:	2400      	movs	r4, #0
   1bfda:	e7eb      	b.n	1bfb4 <at_cmd_driver_init+0x34>
   1bfdc:	200304b1 	.word	0x200304b1
   1bfe0:	0003040c 	.word	0x0003040c
   1bfe4:	00030414 	.word	0x00030414
   1bfe8:	0003380b 	.word	0x0003380b
   1bfec:	0001bc99 	.word	0x0001bc99
   1bff0:	20033618 	.word	0x20033618
   1bff4:	20028808 	.word	0x20028808

0001bff8 <at_cmd_write>:
{
   1bff8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1bffc:	4605      	mov	r5, r0
   1bffe:	4688      	mov	r8, r1
   1c000:	4617      	mov	r7, r2
   1c002:	461e      	mov	r6, r3
	return z_impl_k_sem_take(sem, timeout);
   1c004:	4c0a      	ldr	r4, [pc, #40]	; (1c030 <at_cmd_write+0x38>)
   1c006:	f04f 31ff 	mov.w	r1, #4294967295
   1c00a:	4620      	mov	r0, r4
   1c00c:	f00c fab8 	bl	28580 <z_impl_k_sem_take>
	response_buf     = buf;
   1c010:	4b08      	ldr	r3, [pc, #32]	; (1c034 <at_cmd_write+0x3c>)
	int return_code = at_write(cmd, state);
   1c012:	4631      	mov	r1, r6
	response_buf     = buf;
   1c014:	f8c3 8000 	str.w	r8, [r3]
	response_buf_len = buf_len;
   1c018:	4b07      	ldr	r3, [pc, #28]	; (1c038 <at_cmd_write+0x40>)
	int return_code = at_write(cmd, state);
   1c01a:	4628      	mov	r0, r5
	response_buf_len = buf_len;
   1c01c:	601f      	str	r7, [r3, #0]
	int return_code = at_write(cmd, state);
   1c01e:	f7ff fdbd 	bl	1bb9c <at_write>
   1c022:	4605      	mov	r5, r0
	z_impl_k_sem_give(sem);
   1c024:	4620      	mov	r0, r4
   1c026:	f00c fa61 	bl	284ec <z_impl_k_sem_give>
}
   1c02a:	4628      	mov	r0, r5
   1c02c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1c030:	2003b880 	.word	0x2003b880
   1c034:	20028800 	.word	0x20028800
   1c038:	20028804 	.word	0x20028804

0001c03c <at_cmd_set_notification_handler>:
{
   1c03c:	b538      	push	{r3, r4, r5, lr}
	if (notification_handler != NULL && handler != notification_handler) {
   1c03e:	4c0f      	ldr	r4, [pc, #60]	; (1c07c <at_cmd_set_notification_handler+0x40>)
{
   1c040:	4605      	mov	r5, r0
	if (notification_handler != NULL && handler != notification_handler) {
   1c042:	6822      	ldr	r2, [r4, #0]
   1c044:	b17a      	cbz	r2, 1c066 <at_cmd_set_notification_handler+0x2a>
   1c046:	4282      	cmp	r2, r0
   1c048:	d00d      	beq.n	1c066 <at_cmd_set_notification_handler+0x2a>
		LOG_WRN("Forgetting prior notification handler %p",
   1c04a:	2302      	movs	r3, #2
   1c04c:	f04f 0000 	mov.w	r0, #0
   1c050:	490b      	ldr	r1, [pc, #44]	; (1c080 <at_cmd_set_notification_handler+0x44>)
   1c052:	f363 0007 	bfi	r0, r3, #0, #8
   1c056:	4b0b      	ldr	r3, [pc, #44]	; (1c084 <at_cmd_set_notification_handler+0x48>)
   1c058:	1a5b      	subs	r3, r3, r1
   1c05a:	08db      	lsrs	r3, r3, #3
   1c05c:	f363 108f 	bfi	r0, r3, #6, #10
   1c060:	4909      	ldr	r1, [pc, #36]	; (1c088 <at_cmd_set_notification_handler+0x4c>)
   1c062:	f011 f949 	bl	2d2f8 <log_string_sync>
	return z_impl_k_sem_take(sem, timeout);
   1c066:	f04f 31ff 	mov.w	r1, #4294967295
   1c06a:	4808      	ldr	r0, [pc, #32]	; (1c08c <at_cmd_set_notification_handler+0x50>)
   1c06c:	f00c fa88 	bl	28580 <z_impl_k_sem_take>
	notification_handler = handler;
   1c070:	6025      	str	r5, [r4, #0]
	z_impl_k_sem_give(sem);
   1c072:	4806      	ldr	r0, [pc, #24]	; (1c08c <at_cmd_set_notification_handler+0x50>)
}
   1c074:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1c078:	f00c ba38 	b.w	284ec <z_impl_k_sem_give>
   1c07c:	200287fc 	.word	0x200287fc
   1c080:	0003040c 	.word	0x0003040c
   1c084:	00030414 	.word	0x00030414
   1c088:	0003382d 	.word	0x0003382d
   1c08c:	2003b880 	.word	0x2003b880

0001c090 <find_node>:
static struct notif_handler *find_node(struct notif_handler **prev_out,
	void *ctx, at_notif_handler_t handler)
{
	struct notif_handler *prev = NULL, *curr, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   1c090:	4b0b      	ldr	r3, [pc, #44]	; (1c0c0 <find_node+0x30>)
{
   1c092:	b570      	push	{r4, r5, r6, lr}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   1c094:	681b      	ldr	r3, [r3, #0]
   1c096:	b153      	cbz	r3, 1c0ae <find_node+0x1e>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1c098:	2500      	movs	r5, #0
   1c09a:	461c      	mov	r4, r3
   1c09c:	681b      	ldr	r3, [r3, #0]
		if (curr->ctx == ctx && curr->handler == handler) {
   1c09e:	6866      	ldr	r6, [r4, #4]
   1c0a0:	428e      	cmp	r6, r1
   1c0a2:	d106      	bne.n	1c0b2 <find_node+0x22>
   1c0a4:	68a6      	ldr	r6, [r4, #8]
   1c0a6:	4296      	cmp	r6, r2
   1c0a8:	d103      	bne.n	1c0b2 <find_node+0x22>
			*prev_out = prev;
			return curr;
   1c0aa:	4623      	mov	r3, r4
			*prev_out = prev;
   1c0ac:	6005      	str	r5, [r0, #0]
		}
		prev = curr;
	}
	return NULL;
}
   1c0ae:	4618      	mov	r0, r3
   1c0b0:	bd70      	pop	{r4, r5, r6, pc}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   1c0b2:	2b00      	cmp	r3, #0
   1c0b4:	d0fb      	beq.n	1c0ae <find_node+0x1e>
   1c0b6:	4625      	mov	r5, r4
   1c0b8:	461c      	mov	r4, r3
   1c0ba:	681b      	ldr	r3, [r3, #0]
   1c0bc:	e7ef      	b.n	1c09e <find_node+0xe>
   1c0be:	bf00      	nop
   1c0c0:	200288b8 	.word	0x200288b8

0001c0c4 <module_init>:
{
	ARG_UNUSED(dev);

	static bool initialized;

	if (initialized) {
   1c0c4:	4a0e      	ldr	r2, [pc, #56]	; (1c100 <module_init+0x3c>)
{
   1c0c6:	b508      	push	{r3, lr}
	if (initialized) {
   1c0c8:	7813      	ldrb	r3, [r2, #0]
   1c0ca:	b17b      	cbz	r3, 1c0ec <module_init+0x28>
		LOG_WRN("Already initialized. Nothing to do");
   1c0cc:	2302      	movs	r3, #2
   1c0ce:	f04f 0000 	mov.w	r0, #0
   1c0d2:	4a0c      	ldr	r2, [pc, #48]	; (1c104 <module_init+0x40>)
   1c0d4:	f363 0007 	bfi	r0, r3, #0, #8
   1c0d8:	4b0b      	ldr	r3, [pc, #44]	; (1c108 <module_init+0x44>)
   1c0da:	490c      	ldr	r1, [pc, #48]	; (1c10c <module_init+0x48>)
   1c0dc:	1a9b      	subs	r3, r3, r2
   1c0de:	08db      	lsrs	r3, r3, #3
   1c0e0:	f363 108f 	bfi	r0, r3, #6, #10
   1c0e4:	f011 f908 	bl	2d2f8 <log_string_sync>

	LOG_DBG("Initialization");
	sys_slist_init(&handler_list);
	at_cmd_set_notification_handler(notif_dispatch);
	return 0;
}
   1c0e8:	2000      	movs	r0, #0
   1c0ea:	bd08      	pop	{r3, pc}
	initialized = true;
   1c0ec:	2101      	movs	r1, #1
   1c0ee:	7011      	strb	r1, [r2, #0]
	list->head = NULL;
   1c0f0:	4a07      	ldr	r2, [pc, #28]	; (1c110 <module_init+0x4c>)
	at_cmd_set_notification_handler(notif_dispatch);
   1c0f2:	4808      	ldr	r0, [pc, #32]	; (1c114 <module_init+0x50>)
	list->tail = NULL;
   1c0f4:	e9c2 3300 	strd	r3, r3, [r2]
   1c0f8:	f7ff ffa0 	bl	1c03c <at_cmd_set_notification_handler>
	return 0;
   1c0fc:	e7f4      	b.n	1c0e8 <module_init+0x24>
   1c0fe:	bf00      	nop
   1c100:	200304b2 	.word	0x200304b2
   1c104:	0003040c 	.word	0x0003040c
   1c108:	00030424 	.word	0x00030424
   1c10c:	000339ff 	.word	0x000339ff
   1c110:	200288b8 	.word	0x200288b8
   1c114:	0001c125 	.word	0x0001c125

0001c118 <k_mutex_unlock.constprop.7>:
	return z_impl_k_mutex_unlock(mutex);
   1c118:	4801      	ldr	r0, [pc, #4]	; (1c120 <k_mutex_unlock.constprop.7+0x8>)
   1c11a:	f00a be17 	b.w	26d4c <z_impl_k_mutex_unlock>
   1c11e:	bf00      	nop
   1c120:	2003b8d8 	.word	0x2003b8d8

0001c124 <notif_dispatch>:
{
   1c124:	b538      	push	{r3, r4, r5, lr}
   1c126:	4605      	mov	r5, r0
	return z_impl_k_mutex_lock(mutex, timeout);
   1c128:	f04f 31ff 	mov.w	r1, #4294967295
   1c12c:	4809      	ldr	r0, [pc, #36]	; (1c154 <notif_dispatch+0x30>)
   1c12e:	f00a fd2f 	bl	26b90 <z_impl_k_mutex_lock>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   1c132:	4b09      	ldr	r3, [pc, #36]	; (1c158 <notif_dispatch+0x34>)
   1c134:	681b      	ldr	r3, [r3, #0]
   1c136:	b91b      	cbnz	r3, 1c140 <notif_dispatch+0x1c>
}
   1c138:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	k_mutex_unlock(&list_mtx);
   1c13c:	f7ff bfec 	b.w	1c118 <k_mutex_unlock.constprop.7>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1c140:	681c      	ldr	r4, [r3, #0]
		curr->handler(curr->ctx, response);
   1c142:	689a      	ldr	r2, [r3, #8]
   1c144:	4629      	mov	r1, r5
   1c146:	6858      	ldr	r0, [r3, #4]
   1c148:	4790      	blx	r2
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   1c14a:	2c00      	cmp	r4, #0
   1c14c:	d0f4      	beq.n	1c138 <notif_dispatch+0x14>
   1c14e:	4623      	mov	r3, r4
   1c150:	6824      	ldr	r4, [r4, #0]
   1c152:	e7f6      	b.n	1c142 <notif_dispatch+0x1e>
   1c154:	2003b8d8 	.word	0x2003b8d8
   1c158:	200288b8 	.word	0x200288b8

0001c15c <at_notif_register_handler>:
{
	return module_init(NULL);
}

int at_notif_register_handler(void *context, at_notif_handler_t handler)
{
   1c15c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1c15e:	4606      	mov	r6, r0
	if (handler == NULL) {
   1c160:	460d      	mov	r5, r1
   1c162:	b999      	cbnz	r1, 1c18c <at_notif_register_handler+0x30>
		LOG_ERR("Invalid handler (context=0x%08X, handler=0x%08X)",
   1c164:	2301      	movs	r3, #1
   1c166:	f04f 0000 	mov.w	r0, #0
   1c16a:	4a1d      	ldr	r2, [pc, #116]	; (1c1e0 <at_notif_register_handler+0x84>)
   1c16c:	f363 0007 	bfi	r0, r3, #0, #8
   1c170:	4b1c      	ldr	r3, [pc, #112]	; (1c1e4 <at_notif_register_handler+0x88>)
   1c172:	1a9b      	subs	r3, r3, r2
   1c174:	08db      	lsrs	r3, r3, #3
   1c176:	f363 108f 	bfi	r0, r3, #6, #10
   1c17a:	4632      	mov	r2, r6
   1c17c:	460b      	mov	r3, r1
   1c17e:	491a      	ldr	r1, [pc, #104]	; (1c1e8 <at_notif_register_handler+0x8c>)
   1c180:	f011 f8ba 	bl	2d2f8 <log_string_sync>
			(u32_t)context, (u32_t)handler);
		return -EINVAL;
   1c184:	f06f 0015 	mvn.w	r0, #21
	}
	return append_notif_handler(context, handler);
}
   1c188:	b002      	add	sp, #8
   1c18a:	bd70      	pop	{r4, r5, r6, pc}
   1c18c:	f04f 31ff 	mov.w	r1, #4294967295
   1c190:	4816      	ldr	r0, [pc, #88]	; (1c1ec <at_notif_register_handler+0x90>)
   1c192:	f00a fcfd 	bl	26b90 <z_impl_k_mutex_lock>
	if (find_node(&to_ins, ctx, handler) != NULL) {
   1c196:	462a      	mov	r2, r5
   1c198:	4631      	mov	r1, r6
   1c19a:	a801      	add	r0, sp, #4
   1c19c:	f7ff ff78 	bl	1c090 <find_node>
   1c1a0:	4604      	mov	r4, r0
   1c1a2:	b118      	cbz	r0, 1c1ac <at_notif_register_handler+0x50>
		k_mutex_unlock(&list_mtx);
   1c1a4:	f7ff ffb8 	bl	1c118 <k_mutex_unlock.constprop.7>
		return 0;
   1c1a8:	2000      	movs	r0, #0
   1c1aa:	e7ed      	b.n	1c188 <at_notif_register_handler+0x2c>
	to_ins = (struct notif_handler *)k_malloc(sizeof(struct notif_handler));
   1c1ac:	200c      	movs	r0, #12
   1c1ae:	f00a fb87 	bl	268c0 <k_malloc>
   1c1b2:	9001      	str	r0, [sp, #4]
	if (to_ins == NULL) {
   1c1b4:	b920      	cbnz	r0, 1c1c0 <at_notif_register_handler+0x64>
		k_mutex_unlock(&list_mtx);
   1c1b6:	f7ff ffaf 	bl	1c118 <k_mutex_unlock.constprop.7>
		return -ENOBUFS;
   1c1ba:	f06f 0068 	mvn.w	r0, #104	; 0x68
   1c1be:	e7e3      	b.n	1c188 <at_notif_register_handler+0x2c>
__ssp_bos_icheck3(memset, void *, int)
   1c1c0:	6004      	str	r4, [r0, #0]
	to_ins->ctx     = ctx;
   1c1c2:	9b01      	ldr	r3, [sp, #4]
Z_GENLIST_APPEND(slist, snode)
   1c1c4:	4a0a      	ldr	r2, [pc, #40]	; (1c1f0 <at_notif_register_handler+0x94>)
   1c1c6:	6044      	str	r4, [r0, #4]
   1c1c8:	6084      	str	r4, [r0, #8]
	parent->next = child;
   1c1ca:	601c      	str	r4, [r3, #0]
Z_GENLIST_APPEND(slist, snode)
   1c1cc:	6851      	ldr	r1, [r2, #4]
	to_ins->handler = handler;
   1c1ce:	e9c3 6501 	strd	r6, r5, [r3, #4]
   1c1d2:	b911      	cbnz	r1, 1c1da <at_notif_register_handler+0x7e>
	list->head = node;
   1c1d4:	e9c2 3300 	strd	r3, r3, [r2]
   1c1d8:	e7e4      	b.n	1c1a4 <at_notif_register_handler+0x48>
	parent->next = child;
   1c1da:	600b      	str	r3, [r1, #0]
	list->tail = node;
   1c1dc:	6053      	str	r3, [r2, #4]
   1c1de:	e7e1      	b.n	1c1a4 <at_notif_register_handler+0x48>
   1c1e0:	0003040c 	.word	0x0003040c
   1c1e4:	00030424 	.word	0x00030424
   1c1e8:	000339ce 	.word	0x000339ce
   1c1ec:	2003b8d8 	.word	0x2003b8d8
   1c1f0:	200288b8 	.word	0x200288b8

0001c1f4 <at_notif_deregister_handler>:

int at_notif_deregister_handler(void *context, at_notif_handler_t handler)
{
   1c1f4:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1c1f6:	4605      	mov	r5, r0
	if (handler == NULL) {
   1c1f8:	460c      	mov	r4, r1
   1c1fa:	b999      	cbnz	r1, 1c224 <at_notif_deregister_handler+0x30>
		LOG_ERR("Invalid handler (context=0x%08X, handler=0x%08X)",
   1c1fc:	2301      	movs	r3, #1
   1c1fe:	f04f 0000 	mov.w	r0, #0
   1c202:	4921      	ldr	r1, [pc, #132]	; (1c288 <at_notif_deregister_handler+0x94>)
   1c204:	f363 0007 	bfi	r0, r3, #0, #8
   1c208:	4b20      	ldr	r3, [pc, #128]	; (1c28c <at_notif_deregister_handler+0x98>)
   1c20a:	462a      	mov	r2, r5
   1c20c:	1ac9      	subs	r1, r1, r3
   1c20e:	08c9      	lsrs	r1, r1, #3
   1c210:	f361 108f 	bfi	r0, r1, #6, #10
   1c214:	4623      	mov	r3, r4
   1c216:	491e      	ldr	r1, [pc, #120]	; (1c290 <at_notif_deregister_handler+0x9c>)
   1c218:	f011 f86e 	bl	2d2f8 <log_string_sync>
			(u32_t)context, (u32_t)handler);
		return -EINVAL;
   1c21c:	f06f 0015 	mvn.w	r0, #21
	}
	return remove_notif_handler(context, handler);
}
   1c220:	b003      	add	sp, #12
   1c222:	bd30      	pop	{r4, r5, pc}
	struct notif_handler *curr, *prev = NULL;
   1c224:	2300      	movs	r3, #0
   1c226:	9301      	str	r3, [sp, #4]
   1c228:	f04f 31ff 	mov.w	r1, #4294967295
   1c22c:	4819      	ldr	r0, [pc, #100]	; (1c294 <at_notif_deregister_handler+0xa0>)
   1c22e:	f00a fcaf 	bl	26b90 <z_impl_k_mutex_lock>
	curr = find_node(&prev, ctx, handler);
   1c232:	4622      	mov	r2, r4
   1c234:	4629      	mov	r1, r5
   1c236:	a801      	add	r0, sp, #4
   1c238:	f7ff ff2a 	bl	1c090 <find_node>
	if (curr == NULL) {
   1c23c:	b978      	cbnz	r0, 1c25e <at_notif_deregister_handler+0x6a>
		LOG_WRN("Handler not registered. Nothing to do");
   1c23e:	2302      	movs	r3, #2
   1c240:	4a12      	ldr	r2, [pc, #72]	; (1c28c <at_notif_deregister_handler+0x98>)
   1c242:	f363 0007 	bfi	r0, r3, #0, #8
   1c246:	4b10      	ldr	r3, [pc, #64]	; (1c288 <at_notif_deregister_handler+0x94>)
   1c248:	4913      	ldr	r1, [pc, #76]	; (1c298 <at_notif_deregister_handler+0xa4>)
   1c24a:	1a9b      	subs	r3, r3, r2
   1c24c:	08db      	lsrs	r3, r3, #3
   1c24e:	f363 108f 	bfi	r0, r3, #6, #10
   1c252:	f011 f851 	bl	2d2f8 <log_string_sync>
	k_mutex_unlock(&list_mtx);
   1c256:	f7ff ff5f 	bl	1c118 <k_mutex_unlock.constprop.7>
	return remove_notif_handler(context, handler);
   1c25a:	2000      	movs	r0, #0
   1c25c:	e7e0      	b.n	1c220 <at_notif_deregister_handler+0x2c>
	sys_slist_remove(&handler_list, &prev->node, &curr->node);
   1c25e:	9a01      	ldr	r2, [sp, #4]
Z_GENLIST_REMOVE(slist, snode)
   1c260:	6801      	ldr	r1, [r0, #0]
   1c262:	4b0e      	ldr	r3, [pc, #56]	; (1c29c <at_notif_deregister_handler+0xa8>)
   1c264:	b94a      	cbnz	r2, 1c27a <at_notif_deregister_handler+0x86>
   1c266:	685a      	ldr	r2, [r3, #4]
	list->head = node;
   1c268:	6019      	str	r1, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   1c26a:	4290      	cmp	r0, r2
   1c26c:	d100      	bne.n	1c270 <at_notif_deregister_handler+0x7c>
	list->tail = node;
   1c26e:	6059      	str	r1, [r3, #4]
	parent->next = child;
   1c270:	2300      	movs	r3, #0
   1c272:	6003      	str	r3, [r0, #0]
	k_free(curr);
   1c274:	f012 fe9f 	bl	2efb6 <k_free>
   1c278:	e7ed      	b.n	1c256 <at_notif_deregister_handler+0x62>
   1c27a:	6011      	str	r1, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   1c27c:	6859      	ldr	r1, [r3, #4]
   1c27e:	4288      	cmp	r0, r1
	list->tail = node;
   1c280:	bf08      	it	eq
   1c282:	605a      	streq	r2, [r3, #4]
   1c284:	e7f4      	b.n	1c270 <at_notif_deregister_handler+0x7c>
   1c286:	bf00      	nop
   1c288:	00030424 	.word	0x00030424
   1c28c:	0003040c 	.word	0x0003040c
   1c290:	000339ce 	.word	0x000339ce
   1c294:	2003b8d8 	.word	0x2003b8d8
   1c298:	000339a8 	.word	0x000339a8
   1c29c:	200288b8 	.word	0x200288b8

0001c2a0 <write_uart_string>:
static struct k_work cmd_send_work;



static inline void write_uart_string(const char *str)
{
   1c2a0:	b538      	push	{r3, r4, r5, lr}
	/* Send characters until, but not including, null */
	for (size_t i = 0; str[i]; i++) {
		uart_poll_out(uart_dev, str[i]);
   1c2a2:	4d05      	ldr	r5, [pc, #20]	; (1c2b8 <write_uart_string+0x18>)
   1c2a4:	1e44      	subs	r4, r0, #1
	for (size_t i = 0; str[i]; i++) {
   1c2a6:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   1c2aa:	b901      	cbnz	r1, 1c2ae <write_uart_string+0xe>
	}
}
   1c2ac:	bd38      	pop	{r3, r4, r5, pc}
		uart_poll_out(uart_dev, str[i]);
   1c2ae:	6828      	ldr	r0, [r5, #0]
	api->poll_out(dev, out_char);
   1c2b0:	6843      	ldr	r3, [r0, #4]
   1c2b2:	685b      	ldr	r3, [r3, #4]
   1c2b4:	4798      	blx	r3
   1c2b6:	e7f6      	b.n	1c2a6 <write_uart_string+0x6>
   1c2b8:	20028994 	.word	0x20028994

0001c2bc <cmd_send>:
	/* Forward the data over UART */
	write_uart_string(response);
}

static void cmd_send(struct k_work *work)
{
   1c2bc:	b500      	push	{lr}
	enum at_cmd_state state;
	int               err;

	ARG_UNUSED(work);

	err = at_cmd_write(at_buf, at_buf,
   1c2be:	4923      	ldr	r1, [pc, #140]	; (1c34c <cmd_send+0x90>)
{
   1c2c0:	b08b      	sub	sp, #44	; 0x2c
	err = at_cmd_write(at_buf, at_buf,
   1c2c2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   1c2c6:	f10d 030b 	add.w	r3, sp, #11
   1c2ca:	4608      	mov	r0, r1
   1c2cc:	f7ff fe94 	bl	1bff8 <at_cmd_write>
			   sizeof(at_buf), &state);
	if (err < 0) {
   1c2d0:	1e02      	subs	r2, r0, #0
   1c2d2:	da12      	bge.n	1c2fa <cmd_send+0x3e>
		LOG_ERR("Error while processing AT command: %d", err);
   1c2d4:	2301      	movs	r3, #1
   1c2d6:	f04f 0000 	mov.w	r0, #0
   1c2da:	491d      	ldr	r1, [pc, #116]	; (1c350 <cmd_send+0x94>)
   1c2dc:	f363 0007 	bfi	r0, r3, #0, #8
   1c2e0:	4b1c      	ldr	r3, [pc, #112]	; (1c354 <cmd_send+0x98>)
   1c2e2:	1a5b      	subs	r3, r3, r1
   1c2e4:	08db      	lsrs	r3, r3, #3
   1c2e6:	f363 108f 	bfi	r0, r3, #6, #10
   1c2ea:	491b      	ldr	r1, [pc, #108]	; (1c358 <cmd_send+0x9c>)
   1c2ec:	f011 f804 	bl	2d2f8 <log_string_sync>
		state = AT_CMD_ERROR;
   1c2f0:	2301      	movs	r3, #1
   1c2f2:	f88d 300b 	strb.w	r3, [sp, #11]
	case AT_CMD_OK:
		write_uart_string(at_buf);
		write_uart_string(OK_STR);
		break;
	case AT_CMD_ERROR:
		write_uart_string(ERROR_STR);
   1c2f6:	4819      	ldr	r0, [pc, #100]	; (1c35c <cmd_send+0xa0>)
   1c2f8:	e012      	b.n	1c320 <cmd_send+0x64>
	switch (state) {
   1c2fa:	f89d 300b 	ldrb.w	r3, [sp, #11]
   1c2fe:	2b03      	cmp	r3, #3
   1c300:	d810      	bhi.n	1c324 <cmd_send+0x68>
   1c302:	a101      	add	r1, pc, #4	; (adr r1, 1c308 <cmd_send+0x4c>)
   1c304:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
   1c308:	0001c319 	.word	0x0001c319
   1c30c:	0001c2f7 	.word	0x0001c2f7
   1c310:	0001c333 	.word	0x0001c333
   1c314:	0001c345 	.word	0x0001c345
		write_uart_string(at_buf);
   1c318:	480c      	ldr	r0, [pc, #48]	; (1c34c <cmd_send+0x90>)
   1c31a:	f7ff ffc1 	bl	1c2a0 <write_uart_string>
		write_uart_string(OK_STR);
   1c31e:	4810      	ldr	r0, [pc, #64]	; (1c360 <cmd_send+0xa4>)
		sprintf(str, "+CMS ERROR: %d\r\n", err);
		write_uart_string(str);
		break;
	case AT_CMD_ERROR_CME:
		sprintf(str, "+CME ERROR: %d\r\n", err);
		write_uart_string(str);
   1c320:	f7ff ffbe 	bl	1c2a0 <write_uart_string>
		break;
	default:
		break;
	}

	uart_irq_rx_enable(uart_dev);
   1c324:	4b0f      	ldr	r3, [pc, #60]	; (1c364 <cmd_send+0xa8>)
   1c326:	6818      	ldr	r0, [r3, #0]
		arch_syscall_invoke1(*(uintptr_t *)&dev, K_SYSCALL_UART_IRQ_RX_ENABLE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_rx_enable(dev);
   1c328:	f012 fc8e 	bl	2ec48 <z_impl_uart_irq_rx_enable>
}
   1c32c:	b00b      	add	sp, #44	; 0x2c
   1c32e:	f85d fb04 	ldr.w	pc, [sp], #4
		sprintf(str, "+CMS ERROR: %d\r\n", err);
   1c332:	4b0d      	ldr	r3, [pc, #52]	; (1c368 <cmd_send+0xac>)
   1c334:	9200      	str	r2, [sp, #0]
		sprintf(str, "+CME ERROR: %d\r\n", err);
   1c336:	2219      	movs	r2, #25
   1c338:	2100      	movs	r1, #0
   1c33a:	a803      	add	r0, sp, #12
   1c33c:	f013 f96c 	bl	2f618 <__sprintf_chk>
		write_uart_string(str);
   1c340:	a803      	add	r0, sp, #12
   1c342:	e7ed      	b.n	1c320 <cmd_send+0x64>
		sprintf(str, "+CME ERROR: %d\r\n", err);
   1c344:	9200      	str	r2, [sp, #0]
   1c346:	4b09      	ldr	r3, [pc, #36]	; (1c36c <cmd_send+0xb0>)
   1c348:	e7f5      	b.n	1c336 <cmd_send+0x7a>
   1c34a:	bf00      	nop
   1c34c:	200304b3 	.word	0x200304b3
   1c350:	0003040c 	.word	0x0003040c
   1c354:	0003041c 	.word	0x0003041c
   1c358:	00033ae6 	.word	0x00033ae6
   1c35c:	00033b11 	.word	0x00033b11
   1c360:	00033b0c 	.word	0x00033b0c
   1c364:	20028994 	.word	0x20028994
   1c368:	00033b19 	.word	0x00033b19
   1c36c:	00033b2a 	.word	0x00033b2a

0001c370 <isr>:
		k_work_submit_to_queue(&at_host_work_q, &cmd_send_work);
	}
}

static void isr(struct device *dev)
{
   1c370:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   1c374:	4606      	mov	r6, r0
	if (api->irq_update) {
   1c376:	6843      	ldr	r3, [r0, #4]
   1c378:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   1c37a:	b103      	cbz	r3, 1c37e <isr+0xe>
		return api->irq_update(dev);
   1c37c:	4798      	blx	r3
	if (api->irq_rx_ready) {
   1c37e:	6873      	ldr	r3, [r6, #4]
   1c380:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   1c382:	b1c3      	cbz	r3, 1c3b6 <isr+0x46>
		return api->irq_rx_ready(dev);
   1c384:	4630      	mov	r0, r6
   1c386:	4798      	blx	r3
	u8_t character;

	uart_irq_update(dev);

	if (!uart_irq_rx_ready(dev)) {
   1c388:	b1a8      	cbz	r0, 1c3b6 <isr+0x46>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1c38a:	f8df a14c 	ldr.w	sl, [pc, #332]	; 1c4d8 <isr+0x168>
   1c38e:	4d47      	ldr	r5, [pc, #284]	; (1c4ac <isr+0x13c>)
   1c390:	46d1      	mov	r9, sl
			LOG_WRN("Ignored null; would terminate string early.");
   1c392:	4b47      	ldr	r3, [pc, #284]	; (1c4b0 <isr+0x140>)
		if (at_cmd_len > 0) {
   1c394:	4c47      	ldr	r4, [pc, #284]	; (1c4b4 <isr+0x144>)
			LOG_WRN("Ignored null; would terminate string early.");
   1c396:	1aed      	subs	r5, r5, r3
   1c398:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   1c39c:	e8da 3faf 	lda	r3, [sl]

	/*
	 * Check that we are not sending data (buffer must be preserved then),
	 * and that a new character is available before handling each character
	 */
	while ((!k_work_pending(&cmd_send_work)) &&
   1c3a0:	07db      	lsls	r3, r3, #31
   1c3a2:	d408      	bmi.n	1c3b6 <isr+0x46>
	if (api->fifo_read) {
   1c3a4:	6873      	ldr	r3, [r6, #4]
   1c3a6:	699b      	ldr	r3, [r3, #24]
   1c3a8:	b12b      	cbz	r3, 1c3b6 <isr+0x46>
		return api->fifo_read(dev, rx_data, size);
   1c3aa:	2201      	movs	r2, #1
   1c3ac:	f10d 0107 	add.w	r1, sp, #7
   1c3b0:	4630      	mov	r0, r6
   1c3b2:	4798      	blx	r3
   1c3b4:	b910      	cbnz	r0, 1c3bc <isr+0x4c>
	       (uart_fifo_read(dev, &character, 1))) {
		uart_rx_handler(character);
	}
}
   1c3b6:	b002      	add	sp, #8
   1c3b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uart_rx_handler(character);
   1c3bc:	f89d 2007 	ldrb.w	r2, [sp, #7]
	switch (character) {
   1c3c0:	2a08      	cmp	r2, #8
   1c3c2:	d001      	beq.n	1c3c8 <isr+0x58>
   1c3c4:	2a7f      	cmp	r2, #127	; 0x7f
   1c3c6:	d105      	bne.n	1c3d4 <isr+0x64>
		if (at_cmd_len > 0) {
   1c3c8:	6823      	ldr	r3, [r4, #0]
   1c3ca:	2b00      	cmp	r3, #0
   1c3cc:	d0e6      	beq.n	1c39c <isr+0x2c>
			at_cmd_len--;
   1c3ce:	3b01      	subs	r3, #1
   1c3d0:	6023      	str	r3, [r4, #0]
   1c3d2:	e7e3      	b.n	1c39c <isr+0x2c>
	if (!inside_quotes) {
   1c3d4:	4938      	ldr	r1, [pc, #224]	; (1c4b8 <isr+0x148>)
   1c3d6:	780b      	ldrb	r3, [r1, #0]
   1c3d8:	b9cb      	cbnz	r3, 1c40e <isr+0x9e>
		switch (character) {
   1c3da:	2a0a      	cmp	r2, #10
   1c3dc:	d02b      	beq.n	1c436 <isr+0xc6>
   1c3de:	2a0d      	cmp	r2, #13
   1c3e0:	d011      	beq.n	1c406 <isr+0x96>
   1c3e2:	b9a2      	cbnz	r2, 1c40e <isr+0x9e>
			if (term_mode == MODE_NULL_TERM) {
   1c3e4:	4b35      	ldr	r3, [pc, #212]	; (1c4bc <isr+0x14c>)
   1c3e6:	781b      	ldrb	r3, [r3, #0]
   1c3e8:	2b00      	cmp	r3, #0
   1c3ea:	d040      	beq.n	1c46e <isr+0xfe>
			LOG_WRN("Ignored null; would terminate string early.");
   1c3ec:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
   1c3f0:	f043 0302 	orr.w	r3, r3, #2
   1c3f4:	f363 0707 	bfi	r7, r3, #0, #8
   1c3f8:	f365 178f 	bfi	r7, r5, #6, #10
   1c3fc:	4930      	ldr	r1, [pc, #192]	; (1c4c0 <isr+0x150>)
   1c3fe:	4638      	mov	r0, r7
   1c400:	f010 ff7a 	bl	2d2f8 <log_string_sync>
			return;
   1c404:	e7ca      	b.n	1c39c <isr+0x2c>
			if (term_mode == MODE_CR) {
   1c406:	482d      	ldr	r0, [pc, #180]	; (1c4bc <isr+0x14c>)
   1c408:	7800      	ldrb	r0, [r0, #0]
   1c40a:	2801      	cmp	r0, #1
			    at_cmd_len > 0 &&
   1c40c:	d02f      	beq.n	1c46e <isr+0xfe>
	if (at_cmd_len + 1 > sizeof(at_buf) - 1) {
   1c40e:	f8d4 c000 	ldr.w	ip, [r4]
   1c412:	f10c 0001 	add.w	r0, ip, #1
   1c416:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   1c41a:	d31d      	bcc.n	1c458 <isr+0xe8>
		LOG_ERR("Buffer overflow, dropping '%c'\n", character);
   1c41c:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   1c420:	f043 0301 	orr.w	r3, r3, #1
   1c424:	f363 0807 	bfi	r8, r3, #0, #8
   1c428:	f365 188f 	bfi	r8, r5, #6, #10
   1c42c:	4925      	ldr	r1, [pc, #148]	; (1c4c4 <isr+0x154>)
   1c42e:	4640      	mov	r0, r8
   1c430:	f010 ff62 	bl	2d2f8 <log_string_sync>
		return;
   1c434:	e7b2      	b.n	1c39c <isr+0x2c>
			if (term_mode == MODE_LF) {
   1c436:	4821      	ldr	r0, [pc, #132]	; (1c4bc <isr+0x14c>)
   1c438:	7800      	ldrb	r0, [r0, #0]
   1c43a:	2802      	cmp	r0, #2
   1c43c:	d017      	beq.n	1c46e <isr+0xfe>
			if (term_mode == MODE_CR_LF &&
   1c43e:	2803      	cmp	r0, #3
   1c440:	d1e5      	bne.n	1c40e <isr+0x9e>
   1c442:	f8d4 c000 	ldr.w	ip, [r4]
   1c446:	f1bc 0f00 	cmp.w	ip, #0
   1c44a:	d0e0      	beq.n	1c40e <isr+0x9e>
			    at_buf[at_cmd_len - 1] == '\r') {
   1c44c:	481e      	ldr	r0, [pc, #120]	; (1c4c8 <isr+0x158>)
   1c44e:	4460      	add	r0, ip
			    at_cmd_len > 0 &&
   1c450:	f810 0c01 	ldrb.w	r0, [r0, #-1]
   1c454:	280d      	cmp	r0, #13
   1c456:	e7d9      	b.n	1c40c <isr+0x9c>
	at_buf[at_cmd_len] = character;
   1c458:	f8df e06c 	ldr.w	lr, [pc, #108]	; 1c4c8 <isr+0x158>
	if (character == '"') {
   1c45c:	2a22      	cmp	r2, #34	; 0x22
	at_buf[at_cmd_len] = character;
   1c45e:	f80e 200c 	strb.w	r2, [lr, ip]
	at_cmd_len++;
   1c462:	6020      	str	r0, [r4, #0]
	if (character == '"') {
   1c464:	d19a      	bne.n	1c39c <isr+0x2c>
	if (!inside_quotes) {
   1c466:	f083 0301 	eor.w	r3, r3, #1
		inside_quotes = !inside_quotes;
   1c46a:	700b      	strb	r3, [r1, #0]
   1c46c:	e796      	b.n	1c39c <isr+0x2c>
	at_buf[at_cmd_len] = '\0'; /* Terminate the command string */
   1c46e:	2300      	movs	r3, #0
   1c470:	4a15      	ldr	r2, [pc, #84]	; (1c4c8 <isr+0x158>)
   1c472:	6820      	ldr	r0, [r4, #0]
	inside_quotes = false;
   1c474:	700b      	strb	r3, [r1, #0]
	at_buf[at_cmd_len] = '\0'; /* Terminate the command string */
   1c476:	5413      	strb	r3, [r2, r0]
	at_cmd_len = 0;
   1c478:	6023      	str	r3, [r4, #0]
	if (at_buf[0]) {
   1c47a:	7813      	ldrb	r3, [r2, #0]
   1c47c:	2b00      	cmp	r3, #0
   1c47e:	d08d      	beq.n	1c39c <isr+0x2c>
		uart_irq_rx_disable(uart_dev); /* Stop UART to protect at_buf */
   1c480:	4b12      	ldr	r3, [pc, #72]	; (1c4cc <isr+0x15c>)
   1c482:	6818      	ldr	r0, [r3, #0]
	if (api->irq_rx_disable) {
   1c484:	6843      	ldr	r3, [r0, #4]
   1c486:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1c488:	b103      	cbz	r3, 1c48c <isr+0x11c>
		api->irq_rx_disable(dev);
   1c48a:	4798      	blx	r3
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1c48c:	e8d9 3fef 	ldaex	r3, [r9]
   1c490:	f043 0201 	orr.w	r2, r3, #1
   1c494:	e8c9 2fe1 	stlex	r1, r2, [r9]
   1c498:	2900      	cmp	r1, #0
   1c49a:	d1f7      	bne.n	1c48c <isr+0x11c>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   1c49c:	07da      	lsls	r2, r3, #31
   1c49e:	f53f af7d 	bmi.w	1c39c <isr+0x2c>
		k_queue_append(&work_q->queue, work);
   1c4a2:	490b      	ldr	r1, [pc, #44]	; (1c4d0 <isr+0x160>)
   1c4a4:	480b      	ldr	r0, [pc, #44]	; (1c4d4 <isr+0x164>)
   1c4a6:	f012 fdbc 	bl	2f022 <k_queue_append>
   1c4aa:	e777      	b.n	1c39c <isr+0x2c>
   1c4ac:	0003041c 	.word	0x0003041c
   1c4b0:	0003040c 	.word	0x0003040c
   1c4b4:	200288c0 	.word	0x200288c0
   1c4b8:	200314b3 	.word	0x200314b3
   1c4bc:	200314b4 	.word	0x200314b4
   1c4c0:	00033b3b 	.word	0x00033b3b
   1c4c4:	00033b67 	.word	0x00033b67
   1c4c8:	200304b3 	.word	0x200304b3
   1c4cc:	20028994 	.word	0x20028994
   1c4d0:	20028988 	.word	0x20028988
   1c4d4:	200288c4 	.word	0x200288c4
   1c4d8:	20028990 	.word	0x20028990

0001c4dc <at_host_init>:

	ARG_UNUSED(arg);

	/* Choosing the termination mode */
	if (mode < MODE_COUNT) {
		term_mode = mode;
   1c4dc:	2202      	movs	r2, #2
   1c4de:	4b49      	ldr	r3, [pc, #292]	; (1c604 <at_host_init+0x128>)
{
   1c4e0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	default:
		LOG_ERR("Unknown UART instance %d", uart_id);
		return -EINVAL;
	}

	err = at_notif_register_handler(NULL, response_handler);
   1c4e4:	4948      	ldr	r1, [pc, #288]	; (1c608 <at_host_init+0x12c>)
   1c4e6:	2000      	movs	r0, #0
		term_mode = mode;
   1c4e8:	701a      	strb	r2, [r3, #0]
	err = at_notif_register_handler(NULL, response_handler);
   1c4ea:	f7ff fe37 	bl	1c15c <at_notif_register_handler>
	if (err != 0) {
   1c4ee:	4c47      	ldr	r4, [pc, #284]	; (1c60c <at_host_init+0x130>)
   1c4f0:	4b47      	ldr	r3, [pc, #284]	; (1c610 <at_host_init+0x134>)
   1c4f2:	4606      	mov	r6, r0
   1c4f4:	1ae4      	subs	r4, r4, r3
   1c4f6:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1c4fa:	b170      	cbz	r0, 1c51a <at_host_init+0x3e>
		LOG_ERR("Can't register handler err=%d", err);
   1c4fc:	f04f 0000 	mov.w	r0, #0
   1c500:	2301      	movs	r3, #1
   1c502:	f363 0007 	bfi	r0, r3, #0, #8
   1c506:	f364 108f 	bfi	r0, r4, #6, #10
   1c50a:	4632      	mov	r2, r6
   1c50c:	4941      	ldr	r1, [pc, #260]	; (1c614 <at_host_init+0x138>)
   1c50e:	f010 fef3 	bl	2d2f8 <log_string_sync>
		       K_THREAD_STACK_SIZEOF(at_host_stack_area),
		       CONFIG_AT_HOST_THREAD_PRIO);
	uart_irq_rx_enable(uart_dev);

	return err;
}
   1c512:	4630      	mov	r0, r6
   1c514:	b002      	add	sp, #8
   1c516:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1c51a:	483f      	ldr	r0, [pc, #252]	; (1c618 <at_host_init+0x13c>)
   1c51c:	f009 fe54 	bl	261c8 <z_impl_device_get_binding>
	uart_dev = device_get_binding(uart_dev_name);
   1c520:	4d3e      	ldr	r5, [pc, #248]	; (1c61c <at_host_init+0x140>)
   1c522:	6028      	str	r0, [r5, #0]
	if (uart_dev == NULL) {
   1c524:	b9b8      	cbnz	r0, 1c556 <at_host_init+0x7a>
		LOG_ERR("Cannot bind %s\n", uart_dev_name);
   1c526:	2301      	movs	r3, #1
   1c528:	f363 0007 	bfi	r0, r3, #0, #8
   1c52c:	4a3a      	ldr	r2, [pc, #232]	; (1c618 <at_host_init+0x13c>)
   1c52e:	f364 108f 	bfi	r0, r4, #6, #10
   1c532:	493b      	ldr	r1, [pc, #236]	; (1c620 <at_host_init+0x144>)
   1c534:	f010 fee0 	bl	2d2f8 <log_string_sync>
		return -EINVAL;
   1c538:	f06f 0215 	mvn.w	r2, #21
		LOG_ERR("UART could not be initialized: %d", err);
   1c53c:	2301      	movs	r3, #1
   1c53e:	f04f 0000 	mov.w	r0, #0
   1c542:	f363 0007 	bfi	r0, r3, #0, #8
   1c546:	f364 108f 	bfi	r0, r4, #6, #10
   1c54a:	4936      	ldr	r1, [pc, #216]	; (1c624 <at_host_init+0x148>)
   1c54c:	f010 fed4 	bl	2d2f8 <log_string_sync>
		return -EFAULT;
   1c550:	f06f 060d 	mvn.w	r6, #13
   1c554:	e7dd      	b.n	1c512 <at_host_init+0x36>
	return z_impl_k_uptime_get();
   1c556:	f012 fe40 	bl	2f1da <z_impl_k_uptime_get>
   1c55a:	4681      	mov	r9, r0
			LOG_INF("UART check failed: %d. "
   1c55c:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 1c640 <at_host_init+0x164>
		err = uart_err_check(uart_dev);
   1c560:	6828      	ldr	r0, [r5, #0]
	if (api->err_check != NULL) {
   1c562:	6843      	ldr	r3, [r0, #4]
   1c564:	689b      	ldr	r3, [r3, #8]
   1c566:	b39b      	cbz	r3, 1c5d0 <at_host_init+0xf4>
		return api->err_check(dev);
   1c568:	4798      	blx	r3
		if (err) {
   1c56a:	4680      	mov	r8, r0
   1c56c:	b380      	cbz	r0, 1c5d0 <at_host_init+0xf4>
   1c56e:	f012 fe34 	bl	2f1da <z_impl_k_uptime_get>
			if (k_uptime_get_32() - start_time >
   1c572:	eba0 0009 	sub.w	r0, r0, r9
   1c576:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
   1c57a:	d90d      	bls.n	1c598 <at_host_init+0xbc>
				LOG_ERR("UART check failed: %d. "
   1c57c:	2301      	movs	r3, #1
   1c57e:	f04f 0000 	mov.w	r0, #0
   1c582:	f363 0007 	bfi	r0, r3, #0, #8
   1c586:	4642      	mov	r2, r8
   1c588:	f364 108f 	bfi	r0, r4, #6, #10
   1c58c:	4926      	ldr	r1, [pc, #152]	; (1c628 <at_host_init+0x14c>)
   1c58e:	f010 feb3 	bl	2d2f8 <log_string_sync>
				return -EIO;
   1c592:	f06f 0204 	mvn.w	r2, #4
   1c596:	e7d1      	b.n	1c53c <at_host_init+0x60>
			LOG_INF("UART check failed: %d. "
   1c598:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
   1c59c:	f043 0303 	orr.w	r3, r3, #3
   1c5a0:	f363 0707 	bfi	r7, r3, #0, #8
   1c5a4:	f364 178f 	bfi	r7, r4, #6, #10
   1c5a8:	4642      	mov	r2, r8
   1c5aa:	4651      	mov	r1, sl
   1c5ac:	4638      	mov	r0, r7
   1c5ae:	f010 fea3 	bl	2d2f8 <log_string_sync>
			while (uart_fifo_read(uart_dev, &dummy, 1)) {
   1c5b2:	6828      	ldr	r0, [r5, #0]
	if (api->fifo_read) {
   1c5b4:	6843      	ldr	r3, [r0, #4]
   1c5b6:	699b      	ldr	r3, [r3, #24]
   1c5b8:	b91b      	cbnz	r3, 1c5c2 <at_host_init+0xe6>
	return z_impl_k_sleep(ms);
   1c5ba:	200a      	movs	r0, #10
   1c5bc:	f00b ff54 	bl	28468 <z_impl_k_sleep>
   1c5c0:	e7ce      	b.n	1c560 <at_host_init+0x84>
		return api->fifo_read(dev, rx_data, size);
   1c5c2:	2201      	movs	r2, #1
   1c5c4:	f10d 0107 	add.w	r1, sp, #7
   1c5c8:	4798      	blx	r3
   1c5ca:	2800      	cmp	r0, #0
   1c5cc:	d1f1      	bne.n	1c5b2 <at_host_init+0xd6>
   1c5ce:	e7f4      	b.n	1c5ba <at_host_init+0xde>
	uart_irq_callback_set(uart_dev, isr);
   1c5d0:	682a      	ldr	r2, [r5, #0]
	const struct uart_driver_api *api =
   1c5d2:	6853      	ldr	r3, [r2, #4]
	if ((api != NULL) && (api->irq_callback_set != NULL)) {
   1c5d4:	b123      	cbz	r3, 1c5e0 <at_host_init+0x104>
   1c5d6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   1c5d8:	b113      	cbz	r3, 1c5e0 <at_host_init+0x104>
		api->irq_callback_set(dev, cb, user_data);
   1c5da:	4914      	ldr	r1, [pc, #80]	; (1c62c <at_host_init+0x150>)
   1c5dc:	4610      	mov	r0, r2
   1c5de:	4798      	blx	r3
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   1c5e0:	2200      	movs	r2, #0
   1c5e2:	4b13      	ldr	r3, [pc, #76]	; (1c630 <at_host_init+0x154>)
   1c5e4:	4913      	ldr	r1, [pc, #76]	; (1c634 <at_host_init+0x158>)
   1c5e6:	601a      	str	r2, [r3, #0]
   1c5e8:	e9c3 1201 	strd	r1, r2, [r3, #4]
	k_work_q_start(&at_host_work_q, at_host_stack_area,
   1c5ec:	4812      	ldr	r0, [pc, #72]	; (1c638 <at_host_init+0x15c>)
   1c5ee:	230a      	movs	r3, #10
   1c5f0:	f44f 7200 	mov.w	r2, #512	; 0x200
   1c5f4:	4911      	ldr	r1, [pc, #68]	; (1c63c <at_host_init+0x160>)
   1c5f6:	f00c fa27 	bl	28a48 <k_work_q_start>
	uart_irq_rx_enable(uart_dev);
   1c5fa:	6828      	ldr	r0, [r5, #0]
   1c5fc:	f012 fb24 	bl	2ec48 <z_impl_uart_irq_rx_enable>
	return err;
   1c600:	e787      	b.n	1c512 <at_host_init+0x36>
   1c602:	bf00      	nop
   1c604:	200314b4 	.word	0x200314b4
   1c608:	0002ec53 	.word	0x0002ec53
   1c60c:	0003041c 	.word	0x0003041c
   1c610:	0003040c 	.word	0x0003040c
   1c614:	00033a2b 	.word	0x00033a2b
   1c618:	00031496 	.word	0x00031496
   1c61c:	20028994 	.word	0x20028994
   1c620:	00033a49 	.word	0x00033a49
   1c624:	00033ac4 	.word	0x00033ac4
   1c628:	00033a59 	.word	0x00033a59
   1c62c:	0001c371 	.word	0x0001c371
   1c630:	20028988 	.word	0x20028988
   1c634:	0001c2bd 	.word	0x0001c2bd
   1c638:	200288c4 	.word	0x200288c4
   1c63c:	20033a18 	.word	0x20033a18
   1c640:	00033a8f 	.word	0x00033a8f

0001c644 <is_valid_notification_char>:
 * @retval true  If character is valid
 * @retval false If character is not valid
 */
static inline bool is_valid_notification_char(char chr)
{
	chr = toupper(chr);
   1c644:	4b06      	ldr	r3, [pc, #24]	; (1c660 <is_valid_notification_char+0x1c>)
   1c646:	5cc3      	ldrb	r3, [r0, r3]
   1c648:	f003 0303 	and.w	r3, r3, #3
   1c64c:	2b02      	cmp	r3, #2
   1c64e:	bf08      	it	eq
   1c650:	3820      	subeq	r0, #32

	if ((chr >= 'A') && (chr <= 'Z')) {
   1c652:	3841      	subs	r0, #65	; 0x41
   1c654:	b2c0      	uxtb	r0, r0
		return true;
	}

	return false;
}
   1c656:	2819      	cmp	r0, #25
   1c658:	bf8c      	ite	hi
   1c65a:	2000      	movhi	r0, #0
   1c65c:	2001      	movls	r0, #1
   1c65e:	4770      	bx	lr
   1c660:	00034e16 	.word	0x00034e16

0001c664 <at_parse_process_element>:
	return 0;
}

static int at_parse_process_element(const char **str, int index,
				    struct at_param_list *const list)
{
   1c664:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	const char *tmpstr = *str;
   1c668:	6805      	ldr	r5, [r0, #0]
{
   1c66a:	b0a3      	sub	sp, #140	; 0x8c
	const char *tmpstr = *str;
   1c66c:	9500      	str	r5, [sp, #0]
 * @retval true  If character is 0
 * @retval false If character is not 0
 */
static inline bool is_terminated(char chr)
{
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   1c66e:	782b      	ldrb	r3, [r5, #0]
{
   1c670:	4680      	mov	r8, r0
   1c672:	460f      	mov	r7, r1
   1c674:	4616      	mov	r6, r2
   1c676:	2b00      	cmp	r3, #0
   1c678:	f000 80bd 	beq.w	1c7f6 <at_parse_process_element+0x192>

	if (is_terminated(*tmpstr)) {
		return -1;
	}

	if (state == NOTIFICATION) {
   1c67c:	4b5f      	ldr	r3, [pc, #380]	; (1c7fc <at_parse_process_element+0x198>)
   1c67e:	781c      	ldrb	r4, [r3, #0]
   1c680:	2c05      	cmp	r4, #5
   1c682:	d110      	bne.n	1c6a6 <at_parse_process_element+0x42>
		const char *start_ptr = tmpstr++;
   1c684:	1c6b      	adds	r3, r5, #1
   1c686:	9300      	str	r3, [sp, #0]

		while (is_valid_notification_char(*tmpstr)) {
   1c688:	9a00      	ldr	r2, [sp, #0]
   1c68a:	7810      	ldrb	r0, [r2, #0]
   1c68c:	f7ff ffda 	bl	1c644 <is_valid_notification_char>
   1c690:	b930      	cbnz	r0, 1c6a0 <at_parse_process_element+0x3c>
			tmpstr++;
		}

		at_params_string_put(list, index, start_ptr,
   1c692:	1b53      	subs	r3, r2, r5

		while (isxdigit((int)*tmpstr)) {
			tmpstr++;
		}

		at_params_string_put(list, index, start_ptr,
   1c694:	462a      	mov	r2, r5
   1c696:	4639      	mov	r1, r7
   1c698:	4630      	mov	r0, r6
   1c69a:	f012 fb53 	bl	2ed44 <at_params_string_put>
   1c69e:	e01b      	b.n	1c6d8 <at_parse_process_element+0x74>
			tmpstr++;
   1c6a0:	3201      	adds	r2, #1
   1c6a2:	9200      	str	r2, [sp, #0]
   1c6a4:	e7f0      	b.n	1c688 <at_parse_process_element+0x24>
	} else if (state == COMMAND) {
   1c6a6:	2c06      	cmp	r4, #6
   1c6a8:	d124      	bne.n	1c6f4 <at_parse_process_element+0x90>
		skip_command_prefix(&tmpstr);
   1c6aa:	4668      	mov	r0, sp
   1c6ac:	f012 fadd 	bl	2ec6a <skip_command_prefix>
		while (is_valid_notification_char(*tmpstr)) {
   1c6b0:	9a00      	ldr	r2, [sp, #0]
   1c6b2:	7810      	ldrb	r0, [r2, #0]
   1c6b4:	f7ff ffc6 	bl	1c644 <is_valid_notification_char>
   1c6b8:	b9a8      	cbnz	r0, 1c6e6 <at_parse_process_element+0x82>
		at_params_string_put(list, index, start_ptr,
   1c6ba:	1b53      	subs	r3, r2, r5
   1c6bc:	4639      	mov	r1, r7
   1c6be:	462a      	mov	r2, r5
   1c6c0:	4630      	mov	r0, r6
   1c6c2:	f012 fb3f 	bl	2ed44 <at_params_string_put>
		if ((*tmpstr == AT_CMD_SEPARATOR) &&
   1c6c6:	9b00      	ldr	r3, [sp, #0]
   1c6c8:	781a      	ldrb	r2, [r3, #0]
   1c6ca:	2a3d      	cmp	r2, #61	; 0x3d
   1c6cc:	d10e      	bne.n	1c6ec <at_parse_process_element+0x88>
   1c6ce:	785a      	ldrb	r2, [r3, #1]
   1c6d0:	2a3f      	cmp	r2, #63	; 0x3f
   1c6d2:	d101      	bne.n	1c6d8 <at_parse_process_element+0x74>
			tmpstr += 2;
   1c6d4:	3302      	adds	r3, #2
			tmpstr++;
   1c6d6:	9300      	str	r3, [sp, #0]
				     tmpstr - start_ptr);
	}

	*str = tmpstr;
	return 0;
   1c6d8:	2000      	movs	r0, #0
	*str = tmpstr;
   1c6da:	9b00      	ldr	r3, [sp, #0]
   1c6dc:	f8c8 3000 	str.w	r3, [r8]
}
   1c6e0:	b023      	add	sp, #140	; 0x8c
   1c6e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			tmpstr++;
   1c6e6:	3201      	adds	r2, #1
   1c6e8:	9200      	str	r2, [sp, #0]
   1c6ea:	e7e1      	b.n	1c6b0 <at_parse_process_element+0x4c>
		} else if (*tmpstr == AT_CMD_READ_TEST_IDENTIFIER) {
   1c6ec:	2a3f      	cmp	r2, #63	; 0x3f
   1c6ee:	d1f3      	bne.n	1c6d8 <at_parse_process_element+0x74>
			tmpstr++;
   1c6f0:	3301      	adds	r3, #1
   1c6f2:	e7f0      	b.n	1c6d6 <at_parse_process_element+0x72>
	} else if (state == OPTIONAL) {
   1c6f4:	2c07      	cmp	r4, #7
   1c6f6:	d103      	bne.n	1c700 <at_parse_process_element+0x9c>
		at_params_empty_put(list, index);
   1c6f8:	4610      	mov	r0, r2
   1c6fa:	f012 fafa 	bl	2ecf2 <at_params_empty_put>
   1c6fe:	e7eb      	b.n	1c6d8 <at_parse_process_element+0x74>
	} else if (state == STRING) {
   1c700:	2c02      	cmp	r4, #2
   1c702:	d112      	bne.n	1c72a <at_parse_process_element+0xc6>
		while (!is_dblquote(*tmpstr) && !is_terminated(*tmpstr) &&
   1c704:	9a00      	ldr	r2, [sp, #0]
   1c706:	7810      	ldrb	r0, [r2, #0]
 * @retval true  If character is "
 * @retval false If character is something else
 */
static inline bool is_dblquote(char chr)
{
	if (chr == '"') {
   1c708:	2822      	cmp	r0, #34	; 0x22
   1c70a:	d003      	beq.n	1c714 <at_parse_process_element+0xb0>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   1c70c:	b110      	cbz	r0, 1c714 <at_parse_process_element+0xb0>
		       !is_lfcr(*tmpstr)) {
   1c70e:	f012 faa3 	bl	2ec58 <is_lfcr>
		while (!is_dblquote(*tmpstr) && !is_terminated(*tmpstr) &&
   1c712:	b138      	cbz	r0, 1c724 <at_parse_process_element+0xc0>
		at_params_string_put(list, index, start_ptr,
   1c714:	1b53      	subs	r3, r2, r5
   1c716:	4639      	mov	r1, r7
   1c718:	462a      	mov	r2, r5
   1c71a:	4630      	mov	r0, r6
   1c71c:	f012 fb12 	bl	2ed44 <at_params_string_put>
		tmpstr++;
   1c720:	9b00      	ldr	r3, [sp, #0]
   1c722:	e7e5      	b.n	1c6f0 <at_parse_process_element+0x8c>
			tmpstr++;
   1c724:	3201      	adds	r2, #1
   1c726:	9200      	str	r2, [sp, #0]
   1c728:	e7ec      	b.n	1c704 <at_parse_process_element+0xa0>
	} else if (state == ARRAY) {
   1c72a:	2c01      	cmp	r4, #1
   1c72c:	d13c      	bne.n	1c7a8 <at_parse_process_element+0x144>
		tmparray[i++] = (u32_t)strtoul(tmpstr, &next, 10);
   1c72e:	4628      	mov	r0, r5
   1c730:	220a      	movs	r2, #10
   1c732:	a901      	add	r1, sp, #4
   1c734:	f00e f8e0 	bl	2a8f8 <strtoul>
		tmpstr = next;
   1c738:	9b01      	ldr	r3, [sp, #4]
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   1c73a:	4d31      	ldr	r5, [pc, #196]	; (1c800 <at_parse_process_element+0x19c>)
		tmparray[i++] = (u32_t)strtoul(tmpstr, &next, 10);
   1c73c:	9002      	str	r0, [sp, #8]
		tmpstr = next;
   1c73e:	9300      	str	r3, [sp, #0]
		while (!is_array_stop(*tmpstr) && !is_terminated(*tmpstr)) {
   1c740:	9800      	ldr	r0, [sp, #0]
   1c742:	7803      	ldrb	r3, [r0, #0]
 * @retval true  If character is )
 * @retval false If character is something else
 */
static inline bool is_array_stop(char chr)
{
	if (chr == ')') {
   1c744:	2b29      	cmp	r3, #41	; 0x29
   1c746:	d028      	beq.n	1c79a <at_parse_process_element+0x136>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   1c748:	b33b      	cbz	r3, 1c79a <at_parse_process_element+0x136>
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   1c74a:	3b2c      	subs	r3, #44	; 0x2c
   1c74c:	b2db      	uxtb	r3, r3
   1c74e:	3001      	adds	r0, #1
   1c750:	2b11      	cmp	r3, #17
				tmparray[i++] =
   1c752:	9000      	str	r0, [sp, #0]
   1c754:	d803      	bhi.n	1c75e <at_parse_process_element+0xfa>
   1c756:	fa25 f303 	lsr.w	r3, r5, r3
   1c75a:	07db      	lsls	r3, r3, #31
   1c75c:	d408      	bmi.n	1c770 <at_parse_process_element+0x10c>
				tmpstr++;
   1c75e:	46a1      	mov	r9, r4
   1c760:	e004      	b.n	1c76c <at_parse_process_element+0x108>
					tmpstr = next;
   1c762:	9b01      	ldr	r3, [sp, #4]
			if (i == AT_CMD_MAX_ARRAY_SIZE) {
   1c764:	f1b9 0f20 	cmp.w	r9, #32
					tmpstr = next;
   1c768:	9300      	str	r3, [sp, #0]
			if (i == AT_CMD_MAX_ARRAY_SIZE) {
   1c76a:	d015      	beq.n	1c798 <at_parse_process_element+0x134>
				tmpstr++;
   1c76c:	464c      	mov	r4, r9
   1c76e:	e7e7      	b.n	1c740 <at_parse_process_element+0xdc>
					(u32_t)strtoul(++tmpstr, &next, 10);
   1c770:	220a      	movs	r2, #10
   1c772:	a901      	add	r1, sp, #4
   1c774:	f00e f8c0 	bl	2a8f8 <strtoul>
				tmparray[i++] =
   1c778:	ab22      	add	r3, sp, #136	; 0x88
   1c77a:	f104 0901 	add.w	r9, r4, #1
   1c77e:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   1c782:	f844 0c80 	str.w	r0, [r4, #-128]
				if (strlen(tmpstr) == strlen(next)) {
   1c786:	9800      	ldr	r0, [sp, #0]
   1c788:	f7f0 fbe6 	bl	cf58 <strlen>
   1c78c:	4604      	mov	r4, r0
   1c78e:	9801      	ldr	r0, [sp, #4]
   1c790:	f7f0 fbe2 	bl	cf58 <strlen>
   1c794:	4284      	cmp	r4, r0
   1c796:	d1e4      	bne.n	1c762 <at_parse_process_element+0xfe>
   1c798:	464c      	mov	r4, r9
		at_params_array_put(list, index, tmparray, i * sizeof(u32_t));
   1c79a:	00a3      	lsls	r3, r4, #2
   1c79c:	aa02      	add	r2, sp, #8
   1c79e:	4639      	mov	r1, r7
   1c7a0:	4630      	mov	r0, r6
   1c7a2:	f012 faf5 	bl	2ed90 <at_params_array_put>
   1c7a6:	e7bb      	b.n	1c720 <at_parse_process_element+0xbc>
	} else if (state == NUMBER) {
   1c7a8:	2c03      	cmp	r4, #3
   1c7aa:	d115      	bne.n	1c7d8 <at_parse_process_element+0x174>
		int value = (u32_t)strtoul(tmpstr, &next, 10);
   1c7ac:	220a      	movs	r2, #10
   1c7ae:	a902      	add	r1, sp, #8
   1c7b0:	4628      	mov	r0, r5
   1c7b2:	f00e f8a1 	bl	2a8f8 <strtoul>
		tmpstr = next;
   1c7b6:	9b02      	ldr	r3, [sp, #8]
		if (value <= USHRT_MAX) {
   1c7b8:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
		int value = (u32_t)strtoul(tmpstr, &next, 10);
   1c7bc:	4602      	mov	r2, r0
		tmpstr = next;
   1c7be:	9300      	str	r3, [sp, #0]
		if (value <= USHRT_MAX) {
   1c7c0:	da05      	bge.n	1c7ce <at_parse_process_element+0x16a>
			at_params_short_put(list, index, (u16_t)value);
   1c7c2:	b282      	uxth	r2, r0
   1c7c4:	4639      	mov	r1, r7
   1c7c6:	4630      	mov	r0, r6
   1c7c8:	f012 fa7e 	bl	2ecc8 <at_params_short_put>
   1c7cc:	e784      	b.n	1c6d8 <at_parse_process_element+0x74>
			at_params_int_put(list, index, value);
   1c7ce:	4639      	mov	r1, r7
   1c7d0:	4630      	mov	r0, r6
   1c7d2:	f012 faa2 	bl	2ed1a <at_params_int_put>
   1c7d6:	e77f      	b.n	1c6d8 <at_parse_process_element+0x74>
	} else if (state == SMS_PDU) {
   1c7d8:	2c04      	cmp	r4, #4
   1c7da:	f47f af7d 	bne.w	1c6d8 <at_parse_process_element+0x74>
		while (isxdigit((int)*tmpstr)) {
   1c7de:	4909      	ldr	r1, [pc, #36]	; (1c804 <at_parse_process_element+0x1a0>)
   1c7e0:	9b00      	ldr	r3, [sp, #0]
   1c7e2:	781a      	ldrb	r2, [r3, #0]
   1c7e4:	5c52      	ldrb	r2, [r2, r1]
   1c7e6:	f012 0f44 	tst.w	r2, #68	; 0x44
   1c7ea:	d101      	bne.n	1c7f0 <at_parse_process_element+0x18c>
		at_params_string_put(list, index, start_ptr,
   1c7ec:	1b5b      	subs	r3, r3, r5
   1c7ee:	e751      	b.n	1c694 <at_parse_process_element+0x30>
			tmpstr++;
   1c7f0:	3301      	adds	r3, #1
   1c7f2:	9300      	str	r3, [sp, #0]
   1c7f4:	e7f4      	b.n	1c7e0 <at_parse_process_element+0x17c>
		return -1;
   1c7f6:	f04f 30ff 	mov.w	r0, #4294967295
   1c7fa:	e771      	b.n	1c6e0 <at_parse_process_element+0x7c>
   1c7fc:	200314b5 	.word	0x200314b5
   1c800:	00024001 	.word	0x00024001
   1c804:	00034e16 	.word	0x00034e16

0001c808 <is_command>:
 *
 * @retval true  If the string is an AT command
 * @retval false Otherwise
 */
static inline bool is_command(const char *str)
{
   1c808:	b510      	push	{r4, lr}
   1c80a:	4604      	mov	r4, r0
	if (strlen(str) < 2) {
   1c80c:	f7f0 fba4 	bl	cf58 <strlen>
   1c810:	2801      	cmp	r0, #1
   1c812:	d922      	bls.n	1c85a <is_command+0x52>
		return false;
	}

	if ((toupper(str[0]) != 'A') || (toupper(str[1]) != 'T')) {
   1c814:	7821      	ldrb	r1, [r4, #0]
   1c816:	4b13      	ldr	r3, [pc, #76]	; (1c864 <is_command+0x5c>)
   1c818:	5cca      	ldrb	r2, [r1, r3]
   1c81a:	f002 0203 	and.w	r2, r2, #3
   1c81e:	2a02      	cmp	r2, #2
   1c820:	bf08      	it	eq
   1c822:	3920      	subeq	r1, #32
   1c824:	2941      	cmp	r1, #65	; 0x41
   1c826:	461a      	mov	r2, r3
   1c828:	d117      	bne.n	1c85a <is_command+0x52>
   1c82a:	7863      	ldrb	r3, [r4, #1]
   1c82c:	5cd2      	ldrb	r2, [r2, r3]
   1c82e:	f002 0203 	and.w	r2, r2, #3
   1c832:	2a02      	cmp	r2, #2
   1c834:	bf08      	it	eq
   1c836:	3b20      	subeq	r3, #32
   1c838:	2b54      	cmp	r3, #84	; 0x54
   1c83a:	d10e      	bne.n	1c85a <is_command+0x52>
	}

	/* Third character has be one of the command special characters.
	 * The special case is a lone "AT" command.
	 */
	if ((str[2] == AT_STANDARD_NOTIFICATION_PREFIX) ||
   1c83c:	78a2      	ldrb	r2, [r4, #2]
   1c83e:	2a25      	cmp	r2, #37	; 0x25
   1c840:	d00d      	beq.n	1c85e <is_command+0x56>
	    (str[2] == AT_PROP_NOTIFICATION_PREFX) ||
   1c842:	f002 03f7 	and.w	r3, r2, #247	; 0xf7
   1c846:	2b23      	cmp	r3, #35	; 0x23
   1c848:	d009      	beq.n	1c85e <is_command+0x56>
	    (str[2] == AT_CUSTOM_COMMAND_PREFX) ||
	    is_lfcr(str[2]) || is_terminated(str[2])) {
   1c84a:	4610      	mov	r0, r2
   1c84c:	f012 fa04 	bl	2ec58 <is_lfcr>
	    (str[2] == AT_CUSTOM_COMMAND_PREFX) ||
   1c850:	b910      	cbnz	r0, 1c858 <is_command+0x50>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   1c852:	fab2 f082 	clz	r0, r2
   1c856:	0940      	lsrs	r0, r0, #5
		return true;
	}

	return false;
}
   1c858:	bd10      	pop	{r4, pc}
	return false;
   1c85a:	2000      	movs	r0, #0
   1c85c:	e7fc      	b.n	1c858 <is_command+0x50>
		return true;
   1c85e:	2001      	movs	r0, #1
   1c860:	e7fa      	b.n	1c858 <is_command+0x50>
   1c862:	bf00      	nop
   1c864:	00034e16 	.word	0x00034e16

0001c868 <at_parse_detect_type>:
{
   1c868:	b570      	push	{r4, r5, r6, lr}
	const char *tmpstr = *str;
   1c86a:	6804      	ldr	r4, [r0, #0]
	if ((index == 0) && is_notification(*tmpstr)) {
   1c86c:	2900      	cmp	r1, #0
{
   1c86e:	4606      	mov	r6, r0
   1c870:	7822      	ldrb	r2, [r4, #0]
	if ((index == 0) && is_notification(*tmpstr)) {
   1c872:	d141      	bne.n	1c8f8 <at_parse_detect_type+0x90>
	if ((chr == AT_STANDARD_NOTIFICATION_PREFIX) ||
   1c874:	2a2b      	cmp	r2, #43	; 0x2b
   1c876:	4d29      	ldr	r5, [pc, #164]	; (1c91c <at_parse_detect_type+0xb4>)
   1c878:	d001      	beq.n	1c87e <at_parse_detect_type+0x16>
   1c87a:	2a25      	cmp	r2, #37	; 0x25
   1c87c:	d104      	bne.n	1c888 <at_parse_detect_type+0x20>
	state = new_state;
   1c87e:	2305      	movs	r3, #5
   1c880:	702b      	strb	r3, [r5, #0]
	return 0;
   1c882:	2000      	movs	r0, #0
	*str = tmpstr;
   1c884:	6034      	str	r4, [r6, #0]
}
   1c886:	bd70      	pop	{r4, r5, r6, pc}
	} else if ((index == 0) && is_command(tmpstr)) {
   1c888:	4620      	mov	r0, r4
   1c88a:	f7ff ffbd 	bl	1c808 <is_command>
   1c88e:	b388      	cbz	r0, 1c8f4 <at_parse_detect_type+0x8c>
	state = new_state;
   1c890:	2306      	movs	r3, #6
   1c892:	e7f5      	b.n	1c880 <at_parse_detect_type+0x18>
	if (chr == '"') {
   1c894:	2a22      	cmp	r2, #34	; 0x22
   1c896:	d006      	beq.n	1c8a6 <at_parse_detect_type+0x3e>
	if (chr == '(') {
   1c898:	2a28      	cmp	r2, #40	; 0x28
   1c89a:	d109      	bne.n	1c8b0 <at_parse_detect_type+0x48>
   1c89c:	2201      	movs	r2, #1
   1c89e:	4b1f      	ldr	r3, [pc, #124]	; (1c91c <at_parse_detect_type+0xb4>)
		tmpstr++;
   1c8a0:	4414      	add	r4, r2
	state = new_state;
   1c8a2:	701a      	strb	r2, [r3, #0]
		tmpstr++;
   1c8a4:	e7ed      	b.n	1c882 <at_parse_detect_type+0x1a>
	state = new_state;
   1c8a6:	2202      	movs	r2, #2
   1c8a8:	4b1c      	ldr	r3, [pc, #112]	; (1c91c <at_parse_detect_type+0xb4>)
		tmpstr++;
   1c8aa:	3401      	adds	r4, #1
	state = new_state;
   1c8ac:	701a      	strb	r2, [r3, #0]
		tmpstr++;
   1c8ae:	e7e8      	b.n	1c882 <at_parse_detect_type+0x1a>
	} else if (is_lfcr(*tmpstr) && (state == NUMBER)) {
   1c8b0:	4610      	mov	r0, r2
   1c8b2:	f012 f9d1 	bl	2ec58 <is_lfcr>
   1c8b6:	b170      	cbz	r0, 1c8d6 <at_parse_detect_type+0x6e>
   1c8b8:	4918      	ldr	r1, [pc, #96]	; (1c91c <at_parse_detect_type+0xb4>)
   1c8ba:	7808      	ldrb	r0, [r1, #0]
   1c8bc:	2803      	cmp	r0, #3
   1c8be:	d108      	bne.n	1c8d2 <at_parse_detect_type+0x6a>
		while (is_lfcr(*tmpstr)) {
   1c8c0:	f814 0f01 	ldrb.w	r0, [r4, #1]!
   1c8c4:	f012 f9c8 	bl	2ec58 <is_lfcr>
   1c8c8:	2800      	cmp	r0, #0
   1c8ca:	d1f9      	bne.n	1c8c0 <at_parse_detect_type+0x58>
	state = new_state;
   1c8cc:	2304      	movs	r3, #4
   1c8ce:	700b      	strb	r3, [r1, #0]
   1c8d0:	e7d7      	b.n	1c882 <at_parse_detect_type+0x1a>
	} else if (is_lfcr(*tmpstr) && (state == OPTIONAL)) {
   1c8d2:	2807      	cmp	r0, #7
   1c8d4:	d0d5      	beq.n	1c882 <at_parse_detect_type+0x1a>
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   1c8d6:	3a2c      	subs	r2, #44	; 0x2c
   1c8d8:	b2d2      	uxtb	r2, r2
   1c8da:	2a11      	cmp	r2, #17
   1c8dc:	d807      	bhi.n	1c8ee <at_parse_detect_type+0x86>
   1c8de:	4b10      	ldr	r3, [pc, #64]	; (1c920 <at_parse_detect_type+0xb8>)
   1c8e0:	fa23 f202 	lsr.w	r2, r3, r2
   1c8e4:	07d3      	lsls	r3, r2, #31
   1c8e6:	d502      	bpl.n	1c8ee <at_parse_detect_type+0x86>
	state = new_state;
   1c8e8:	4b0c      	ldr	r3, [pc, #48]	; (1c91c <at_parse_detect_type+0xb4>)
   1c8ea:	2207      	movs	r2, #7
   1c8ec:	e013      	b.n	1c916 <at_parse_detect_type+0xae>
		return -1;
   1c8ee:	f04f 30ff 	mov.w	r0, #4294967295
   1c8f2:	e7c8      	b.n	1c886 <at_parse_detect_type+0x1e>
	state = new_state;
   1c8f4:	2302      	movs	r3, #2
   1c8f6:	e7c3      	b.n	1c880 <at_parse_detect_type+0x18>
	} else if ((index > 0) && is_notification(*tmpstr)) {
   1c8f8:	dd03      	ble.n	1c902 <at_parse_detect_type+0x9a>
	if ((chr == AT_STANDARD_NOTIFICATION_PREFIX) ||
   1c8fa:	2a2b      	cmp	r2, #43	; 0x2b
   1c8fc:	d0f7      	beq.n	1c8ee <at_parse_detect_type+0x86>
   1c8fe:	2a25      	cmp	r2, #37	; 0x25
   1c900:	d0f5      	beq.n	1c8ee <at_parse_detect_type+0x86>
	if (isdigit(chr) || (chr == '-') || (chr == '+')) {
   1c902:	4b08      	ldr	r3, [pc, #32]	; (1c924 <at_parse_detect_type+0xbc>)
   1c904:	5cd3      	ldrb	r3, [r2, r3]
   1c906:	0759      	lsls	r1, r3, #29
   1c908:	d403      	bmi.n	1c912 <at_parse_detect_type+0xaa>
   1c90a:	2a2d      	cmp	r2, #45	; 0x2d
   1c90c:	d001      	beq.n	1c912 <at_parse_detect_type+0xaa>
   1c90e:	2a2b      	cmp	r2, #43	; 0x2b
   1c910:	d1c0      	bne.n	1c894 <at_parse_detect_type+0x2c>
	state = new_state;
   1c912:	2203      	movs	r2, #3
   1c914:	4b01      	ldr	r3, [pc, #4]	; (1c91c <at_parse_detect_type+0xb4>)
   1c916:	701a      	strb	r2, [r3, #0]
   1c918:	e7b3      	b.n	1c882 <at_parse_detect_type+0x1a>
   1c91a:	bf00      	nop
   1c91c:	200314b5 	.word	0x200314b5
   1c920:	00024001 	.word	0x00024001
   1c924:	00034e16 	.word	0x00034e16

0001c928 <at_parser_max_params_from_str>:

int at_parser_max_params_from_str(const char *at_params_str,
				  char **next_param_str,
				  struct at_param_list *const list,
				  size_t max_params_count)
{
   1c928:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1c92c:	4688      	mov	r8, r1
   1c92e:	4616      	mov	r6, r2
   1c930:	461f      	mov	r7, r3
	int err = 0;

	if (at_params_str == NULL || list == NULL || list->params == NULL) {
   1c932:	4604      	mov	r4, r0
   1c934:	2800      	cmp	r0, #0
   1c936:	d07e      	beq.n	1ca36 <at_parser_max_params_from_str+0x10e>
   1c938:	2a00      	cmp	r2, #0
   1c93a:	d07c      	beq.n	1ca36 <at_parser_max_params_from_str+0x10e>
   1c93c:	6853      	ldr	r3, [r2, #4]
   1c93e:	2b00      	cmp	r3, #0
   1c940:	d079      	beq.n	1ca36 <at_parser_max_params_from_str+0x10e>
	state = IDLE;
   1c942:	2500      	movs	r5, #0
		return -EINVAL;
	}

	at_params_list_clear(list);
   1c944:	4610      	mov	r0, r2
   1c946:	f000 f8eb 	bl	1cb20 <at_params_list_clear>

	max_params_count = MIN(max_params_count, list->param_count);
   1c94a:	6832      	ldr	r2, [r6, #0]
	const char *str = *at_params_str;
   1c94c:	9401      	str	r4, [sp, #4]
	max_params_count = MIN(max_params_count, list->param_count);
   1c94e:	4297      	cmp	r7, r2
   1c950:	bf28      	it	cs
   1c952:	4617      	movcs	r7, r2
	int index = 0;
   1c954:	462c      	mov	r4, r5
	state = IDLE;
   1c956:	4b39      	ldr	r3, [pc, #228]	; (1ca3c <at_parser_max_params_from_str+0x114>)
		if (isspace((int)*str)) {
   1c958:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 1ca40 <at_parser_max_params_from_str+0x118>
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   1c95c:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 1ca44 <at_parser_max_params_from_str+0x11c>
	state = IDLE;
   1c960:	701d      	strb	r5, [r3, #0]
	while ((!is_terminated(*str)) && (index < max_params)) {
   1c962:	9b01      	ldr	r3, [sp, #4]
   1c964:	781a      	ldrb	r2, [r3, #0]
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   1c966:	2a00      	cmp	r2, #0
   1c968:	d04b      	beq.n	1ca02 <at_parser_max_params_from_str+0xda>
   1c96a:	42a7      	cmp	r7, r4
   1c96c:	d949      	bls.n	1ca02 <at_parser_max_params_from_str+0xda>
		if (isspace((int)*str)) {
   1c96e:	f812 2009 	ldrb.w	r2, [r2, r9]
		if (at_parse_detect_type(&str, index) == -1) {
   1c972:	a801      	add	r0, sp, #4
		if (isspace((int)*str)) {
   1c974:	0711      	lsls	r1, r2, #28
			str++;
   1c976:	bf48      	it	mi
   1c978:	3301      	addmi	r3, #1
		if (at_parse_detect_type(&str, index) == -1) {
   1c97a:	4621      	mov	r1, r4
			str++;
   1c97c:	bf48      	it	mi
   1c97e:	9301      	strmi	r3, [sp, #4]
		if (at_parse_detect_type(&str, index) == -1) {
   1c980:	f7ff ff72 	bl	1c868 <at_parse_detect_type>
   1c984:	1c42      	adds	r2, r0, #1
   1c986:	d03c      	beq.n	1ca02 <at_parser_max_params_from_str+0xda>
		if (at_parse_process_element(&str, index, list) == -1) {
   1c988:	4632      	mov	r2, r6
   1c98a:	4621      	mov	r1, r4
   1c98c:	a801      	add	r0, sp, #4
   1c98e:	f7ff fe69 	bl	1c664 <at_parse_process_element>
   1c992:	1c43      	adds	r3, r0, #1
   1c994:	d035      	beq.n	1ca02 <at_parser_max_params_from_str+0xda>
		if (is_separator(*str)) {
   1c996:	9b01      	ldr	r3, [sp, #4]
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   1c998:	781a      	ldrb	r2, [r3, #0]
   1c99a:	3a2c      	subs	r2, #44	; 0x2c
   1c99c:	b2d2      	uxtb	r2, r2
   1c99e:	2a11      	cmp	r2, #17
   1c9a0:	d81a      	bhi.n	1c9d8 <at_parser_max_params_from_str+0xb0>
   1c9a2:	fa2a f202 	lsr.w	r2, sl, r2
   1c9a6:	07d1      	lsls	r1, r2, #31
   1c9a8:	d516      	bpl.n	1c9d8 <at_parser_max_params_from_str+0xb0>
			if (is_lfcr(*(str + 1))) {
   1c9aa:	7858      	ldrb	r0, [r3, #1]
   1c9ac:	f012 f954 	bl	2ec58 <is_lfcr>
   1c9b0:	b178      	cbz	r0, 1c9d2 <at_parser_max_params_from_str+0xaa>
				index++;
   1c9b2:	3401      	adds	r4, #1
				if (index == max_params) {
   1c9b4:	42bc      	cmp	r4, r7
   1c9b6:	d039      	beq.n	1ca2c <at_parser_max_params_from_str+0x104>
				if (at_parse_detect_type(&str, index) == -1) {
   1c9b8:	4621      	mov	r1, r4
   1c9ba:	a801      	add	r0, sp, #4
   1c9bc:	f7ff ff54 	bl	1c868 <at_parse_detect_type>
   1c9c0:	1c42      	adds	r2, r0, #1
   1c9c2:	d01e      	beq.n	1ca02 <at_parser_max_params_from_str+0xda>
				if (at_parse_process_element(&str, index,
   1c9c4:	4632      	mov	r2, r6
   1c9c6:	4621      	mov	r1, r4
   1c9c8:	a801      	add	r0, sp, #4
   1c9ca:	f7ff fe4b 	bl	1c664 <at_parse_process_element>
   1c9ce:	1c43      	adds	r3, r0, #1
   1c9d0:	d017      	beq.n	1ca02 <at_parser_max_params_from_str+0xda>
			str++;
   1c9d2:	9b01      	ldr	r3, [sp, #4]
   1c9d4:	3301      	adds	r3, #1
   1c9d6:	9301      	str	r3, [sp, #4]
		if (is_lfcr(*str)) {
   1c9d8:	9a01      	ldr	r2, [sp, #4]
   1c9da:	7810      	ldrb	r0, [r2, #0]
   1c9dc:	f012 f93c 	bl	2ec58 <is_lfcr>
   1c9e0:	b1f8      	cbz	r0, 1ca22 <at_parser_max_params_from_str+0xfa>
   1c9e2:	3201      	adds	r2, #1
			while (is_lfcr(str[++i])) {
   1c9e4:	7811      	ldrb	r1, [r2, #0]
   1c9e6:	4693      	mov	fp, r2
   1c9e8:	4608      	mov	r0, r1
   1c9ea:	3201      	adds	r2, #1
   1c9ec:	f012 f934 	bl	2ec58 <is_lfcr>
   1c9f0:	2800      	cmp	r0, #0
   1c9f2:	d1f7      	bne.n	1c9e4 <at_parser_max_params_from_str+0xbc>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   1c9f4:	b119      	cbz	r1, 1c9fe <at_parser_max_params_from_str+0xd6>
	if ((chr == AT_STANDARD_NOTIFICATION_PREFIX) ||
   1c9f6:	292b      	cmp	r1, #43	; 0x2b
   1c9f8:	d001      	beq.n	1c9fe <at_parser_max_params_from_str+0xd6>
   1c9fa:	2925      	cmp	r1, #37	; 0x25
   1c9fc:	d111      	bne.n	1ca22 <at_parser_max_params_from_str+0xfa>
				str += i;
   1c9fe:	f8cd b004 	str.w	fp, [sp, #4]
	*at_params_str = str;
   1ca02:	9b01      	ldr	r3, [sp, #4]
	if (oversized) {
   1ca04:	b9a5      	cbnz	r5, 1ca30 <at_parser_max_params_from_str+0x108>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   1ca06:	781a      	ldrb	r2, [r3, #0]
		return -EAGAIN;
   1ca08:	2a00      	cmp	r2, #0
   1ca0a:	bf0c      	ite	eq
   1ca0c:	2000      	moveq	r0, #0
   1ca0e:	f06f 000a 	mvnne.w	r0, #10

	err = at_parse_param(&at_params_str, list, max_params_count);

	if (next_param_str) {
   1ca12:	f1b8 0f00 	cmp.w	r8, #0
   1ca16:	d001      	beq.n	1ca1c <at_parser_max_params_from_str+0xf4>
		*next_param_str = (char *)at_params_str;
   1ca18:	f8c8 3000 	str.w	r3, [r8]
	}

	return err;
}
   1ca1c:	b003      	add	sp, #12
   1ca1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		index++;
   1ca22:	3401      	adds	r4, #1
			oversized = true;
   1ca24:	42bc      	cmp	r4, r7
   1ca26:	bf08      	it	eq
   1ca28:	2501      	moveq	r5, #1
   1ca2a:	e79a      	b.n	1c962 <at_parser_max_params_from_str+0x3a>
					oversized = true;
   1ca2c:	4605      	mov	r5, r0
   1ca2e:	e7e8      	b.n	1ca02 <at_parser_max_params_from_str+0xda>
		return -E2BIG;
   1ca30:	f06f 0006 	mvn.w	r0, #6
   1ca34:	e7ed      	b.n	1ca12 <at_parser_max_params_from_str+0xea>
		return -EINVAL;
   1ca36:	f06f 0015 	mvn.w	r0, #21
   1ca3a:	e7ef      	b.n	1ca1c <at_parser_max_params_from_str+0xf4>
   1ca3c:	200314b5 	.word	0x200314b5
   1ca40:	00034e16 	.word	0x00034e16
   1ca44:	00024001 	.word	0x00024001

0001ca48 <at_params_get>:
}

/* Internal function. Parameter cannot be null. */
static struct at_param *at_params_get(const struct at_param_list *list,
				      size_t index)
{
   1ca48:	b538      	push	{r3, r4, r5, lr}
   1ca4a:	460c      	mov	r4, r1
	__ASSERT(list != NULL, "Parameter list cannot be NULL.");
   1ca4c:	4605      	mov	r5, r0
   1ca4e:	b960      	cbnz	r0, 1ca6a <at_params_get+0x22>
   1ca50:	490a      	ldr	r1, [pc, #40]	; (1ca7c <at_params_get+0x34>)
   1ca52:	232b      	movs	r3, #43	; 0x2b
   1ca54:	4a0a      	ldr	r2, [pc, #40]	; (1ca80 <at_params_get+0x38>)
   1ca56:	480b      	ldr	r0, [pc, #44]	; (1ca84 <at_params_get+0x3c>)
   1ca58:	f010 fbf7 	bl	2d24a <printk>
   1ca5c:	480a      	ldr	r0, [pc, #40]	; (1ca88 <at_params_get+0x40>)
   1ca5e:	f010 fbf4 	bl	2d24a <printk>
   1ca62:	212b      	movs	r1, #43	; 0x2b
   1ca64:	4806      	ldr	r0, [pc, #24]	; (1ca80 <at_params_get+0x38>)
   1ca66:	f010 fc36 	bl	2d2d6 <assert_post_action>

	if (index >= list->param_count) {
   1ca6a:	682b      	ldr	r3, [r5, #0]
   1ca6c:	42a3      	cmp	r3, r4
		return NULL;
	}

	struct at_param *param = list->params;

	return &param[index];
   1ca6e:	bf85      	ittet	hi
   1ca70:	230c      	movhi	r3, #12
   1ca72:	6868      	ldrhi	r0, [r5, #4]
		return NULL;
   1ca74:	2000      	movls	r0, #0
	return &param[index];
   1ca76:	fb03 0004 	mlahi	r0, r3, r4, r0
}
   1ca7a:	bd38      	pop	{r3, r4, r5, pc}
   1ca7c:	00033bee 	.word	0x00033bee
   1ca80:	00033bc0 	.word	0x00033bc0
   1ca84:	000311a3 	.word	0x000311a3
   1ca88:	00033c02 	.word	0x00033c02

0001ca8c <at_param_size>:

/* Internal function. Parameter cannot be null. */
static size_t at_param_size(const struct at_param *param)
{
   1ca8c:	b510      	push	{r4, lr}
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   1ca8e:	4604      	mov	r4, r0
   1ca90:	b960      	cbnz	r0, 1caac <at_param_size+0x20>
   1ca92:	490e      	ldr	r1, [pc, #56]	; (1cacc <at_param_size+0x40>)
   1ca94:	2339      	movs	r3, #57	; 0x39
   1ca96:	4a0e      	ldr	r2, [pc, #56]	; (1cad0 <at_param_size+0x44>)
   1ca98:	480e      	ldr	r0, [pc, #56]	; (1cad4 <at_param_size+0x48>)
   1ca9a:	f010 fbd6 	bl	2d24a <printk>
   1ca9e:	480e      	ldr	r0, [pc, #56]	; (1cad8 <at_param_size+0x4c>)
   1caa0:	f010 fbd3 	bl	2d24a <printk>
   1caa4:	2139      	movs	r1, #57	; 0x39
   1caa6:	480a      	ldr	r0, [pc, #40]	; (1cad0 <at_param_size+0x44>)
   1caa8:	f010 fc15 	bl	2d2d6 <assert_post_action>

	if (param->type == AT_PARAM_TYPE_NUM_SHORT) {
   1caac:	7823      	ldrb	r3, [r4, #0]
   1caae:	2b01      	cmp	r3, #1
   1cab0:	d006      	beq.n	1cac0 <at_param_size+0x34>
		return sizeof(u16_t);
	} else if (param->type == AT_PARAM_TYPE_NUM_INT) {
   1cab2:	2b02      	cmp	r3, #2
   1cab4:	d006      	beq.n	1cac4 <at_param_size+0x38>
		return sizeof(u32_t);
	} else if ((param->type == AT_PARAM_TYPE_STRING) ||
   1cab6:	3b03      	subs	r3, #3
   1cab8:	2b01      	cmp	r3, #1
   1caba:	d805      	bhi.n	1cac8 <at_param_size+0x3c>
		   (param->type == AT_PARAM_TYPE_ARRAY)) {
		return param->size;
   1cabc:	6860      	ldr	r0, [r4, #4]
	}

	return 0;
}
   1cabe:	bd10      	pop	{r4, pc}
		return sizeof(u16_t);
   1cac0:	2002      	movs	r0, #2
   1cac2:	e7fc      	b.n	1cabe <at_param_size+0x32>
		return sizeof(u32_t);
   1cac4:	2004      	movs	r0, #4
   1cac6:	e7fa      	b.n	1cabe <at_param_size+0x32>
	return 0;
   1cac8:	2000      	movs	r0, #0
   1caca:	e7f8      	b.n	1cabe <at_param_size+0x32>
   1cacc:	00033b8f 	.word	0x00033b8f
   1cad0:	00033bc0 	.word	0x00033bc0
   1cad4:	000311a3 	.word	0x000311a3
   1cad8:	00033ba4 	.word	0x00033ba4

0001cadc <at_param_clear>:
{
   1cadc:	b510      	push	{r4, lr}
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   1cade:	4604      	mov	r4, r0
   1cae0:	b960      	cbnz	r0, 1cafc <at_param_clear+0x20>
   1cae2:	490b      	ldr	r1, [pc, #44]	; (1cb10 <at_param_clear+0x34>)
   1cae4:	231d      	movs	r3, #29
   1cae6:	4a0b      	ldr	r2, [pc, #44]	; (1cb14 <at_param_clear+0x38>)
   1cae8:	480b      	ldr	r0, [pc, #44]	; (1cb18 <at_param_clear+0x3c>)
   1caea:	f010 fbae 	bl	2d24a <printk>
   1caee:	480b      	ldr	r0, [pc, #44]	; (1cb1c <at_param_clear+0x40>)
   1caf0:	f010 fbab 	bl	2d24a <printk>
   1caf4:	211d      	movs	r1, #29
   1caf6:	4807      	ldr	r0, [pc, #28]	; (1cb14 <at_param_clear+0x38>)
   1caf8:	f010 fbed 	bl	2d2d6 <assert_post_action>
	if ((param->type == AT_PARAM_TYPE_STRING) ||
   1cafc:	7823      	ldrb	r3, [r4, #0]
   1cafe:	3b03      	subs	r3, #3
   1cb00:	2b01      	cmp	r3, #1
   1cb02:	d802      	bhi.n	1cb0a <at_param_clear+0x2e>
		k_free(param->value.str_val);
   1cb04:	68a0      	ldr	r0, [r4, #8]
   1cb06:	f012 fa56 	bl	2efb6 <k_free>
	param->value.int_val = 0;
   1cb0a:	2300      	movs	r3, #0
   1cb0c:	60a3      	str	r3, [r4, #8]
}
   1cb0e:	bd10      	pop	{r4, pc}
   1cb10:	00033b8f 	.word	0x00033b8f
   1cb14:	00033bc0 	.word	0x00033bc0
   1cb18:	000311a3 	.word	0x000311a3
   1cb1c:	00033ba4 	.word	0x00033ba4

0001cb20 <at_params_list_clear>:
	list->param_count = max_params_count;
	return 0;
}

void at_params_list_clear(struct at_param_list *list)
{
   1cb20:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (list == NULL || list->params == NULL) {
   1cb24:	4605      	mov	r5, r0
   1cb26:	b158      	cbz	r0, 1cb40 <at_params_list_clear+0x20>
   1cb28:	6843      	ldr	r3, [r0, #4]
   1cb2a:	b14b      	cbz	r3, 1cb40 <at_params_list_clear+0x20>
		return;
	}

	for (size_t i = 0; i < list->param_count; ++i) {
   1cb2c:	2400      	movs	r4, #0
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   1cb2e:	f8df 8054 	ldr.w	r8, [pc, #84]	; 1cb84 <at_params_list_clear+0x64>
   1cb32:	f8df a054 	ldr.w	sl, [pc, #84]	; 1cb88 <at_params_list_clear+0x68>
   1cb36:	f8df b054 	ldr.w	fp, [pc, #84]	; 1cb8c <at_params_list_clear+0x6c>
	for (size_t i = 0; i < list->param_count; ++i) {
   1cb3a:	682b      	ldr	r3, [r5, #0]
   1cb3c:	429c      	cmp	r4, r3
   1cb3e:	d301      	bcc.n	1cb44 <at_params_list_clear+0x24>
		struct at_param *params = list->params;

		at_param_clear(&params[i]);
		at_param_init(&params[i]);
	}
}
   1cb40:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		at_param_clear(&params[i]);
   1cb44:	270c      	movs	r7, #12
   1cb46:	4367      	muls	r7, r4
   1cb48:	f8d5 9004 	ldr.w	r9, [r5, #4]
   1cb4c:	eb09 0607 	add.w	r6, r9, r7
   1cb50:	4630      	mov	r0, r6
   1cb52:	f7ff ffc3 	bl	1cadc <at_param_clear>
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   1cb56:	b966      	cbnz	r6, 1cb72 <at_params_list_clear+0x52>
   1cb58:	4651      	mov	r1, sl
   1cb5a:	2314      	movs	r3, #20
   1cb5c:	4642      	mov	r2, r8
   1cb5e:	4658      	mov	r0, fp
   1cb60:	f010 fb73 	bl	2d24a <printk>
   1cb64:	4806      	ldr	r0, [pc, #24]	; (1cb80 <at_params_list_clear+0x60>)
   1cb66:	f010 fb70 	bl	2d24a <printk>
   1cb6a:	2114      	movs	r1, #20
   1cb6c:	4640      	mov	r0, r8
   1cb6e:	f010 fbb2 	bl	2d2d6 <assert_post_action>
   1cb72:	2300      	movs	r3, #0
	for (size_t i = 0; i < list->param_count; ++i) {
   1cb74:	3401      	adds	r4, #1
   1cb76:	f849 3007 	str.w	r3, [r9, r7]
   1cb7a:	6073      	str	r3, [r6, #4]
   1cb7c:	60b3      	str	r3, [r6, #8]
   1cb7e:	e7dc      	b.n	1cb3a <at_params_list_clear+0x1a>
   1cb80:	00033ba4 	.word	0x00033ba4
   1cb84:	00033bc0 	.word	0x00033bc0
   1cb88:	00033b8f 	.word	0x00033b8f
   1cb8c:	000311a3 	.word	0x000311a3

0001cb90 <w_lte_lc_init>:
	}
}

static int w_lte_lc_init(void)
{
	if (at_cmd_write(nw_mode_preferred, NULL, 0, NULL) != 0) {
   1cb90:	2300      	movs	r3, #0
{
   1cb92:	b510      	push	{r4, lr}
	if (at_cmd_write(nw_mode_preferred, NULL, 0, NULL) != 0) {
   1cb94:	461a      	mov	r2, r3
   1cb96:	4619      	mov	r1, r3
   1cb98:	4813      	ldr	r0, [pc, #76]	; (1cbe8 <w_lte_lc_init+0x58>)
   1cb9a:	f7ff fa2d 	bl	1bff8 <at_cmd_write>
   1cb9e:	4603      	mov	r3, r0
   1cba0:	b118      	cbz	r0, 1cbaa <w_lte_lc_init+0x1a>
		return -EIO;
   1cba2:	f06f 0404 	mvn.w	r4, #4
	}
	LOG_INF("PDN Auth: %s", log_strdup(cgauth));
#endif

	return 0;
}
   1cba6:	4620      	mov	r0, r4
   1cba8:	bd10      	pop	{r4, pc}
	if (at_cmd_write(cereg_5_subscribe, NULL, 0, NULL) != 0) {
   1cbaa:	4602      	mov	r2, r0
   1cbac:	4601      	mov	r1, r0
   1cbae:	480f      	ldr	r0, [pc, #60]	; (1cbec <w_lte_lc_init+0x5c>)
   1cbb0:	f7ff fa22 	bl	1bff8 <at_cmd_write>
   1cbb4:	4603      	mov	r3, r0
   1cbb6:	2800      	cmp	r0, #0
   1cbb8:	d1f3      	bne.n	1cba2 <w_lte_lc_init+0x12>
	if (at_cmd_write(legacy_pco, NULL, 0, NULL) != 0) {
   1cbba:	4602      	mov	r2, r0
   1cbbc:	4601      	mov	r1, r0
   1cbbe:	480c      	ldr	r0, [pc, #48]	; (1cbf0 <w_lte_lc_init+0x60>)
   1cbc0:	f7ff fa1a 	bl	1bff8 <at_cmd_write>
   1cbc4:	4604      	mov	r4, r0
   1cbc6:	2800      	cmp	r0, #0
   1cbc8:	d1eb      	bne.n	1cba2 <w_lte_lc_init+0x12>
	LOG_INF("Using legacy LTE PCO mode...");
   1cbca:	2303      	movs	r3, #3
   1cbcc:	f04f 0000 	mov.w	r0, #0
   1cbd0:	4a08      	ldr	r2, [pc, #32]	; (1cbf4 <w_lte_lc_init+0x64>)
   1cbd2:	f363 0007 	bfi	r0, r3, #0, #8
   1cbd6:	4b08      	ldr	r3, [pc, #32]	; (1cbf8 <w_lte_lc_init+0x68>)
   1cbd8:	4908      	ldr	r1, [pc, #32]	; (1cbfc <w_lte_lc_init+0x6c>)
   1cbda:	1a9b      	subs	r3, r3, r2
   1cbdc:	08db      	lsrs	r3, r3, #3
   1cbde:	f363 108f 	bfi	r0, r3, #6, #10
   1cbe2:	f010 fb89 	bl	2d2f8 <log_string_sync>
	return 0;
   1cbe6:	e7de      	b.n	1cba6 <w_lte_lc_init+0x16>
   1cbe8:	00033c8d 	.word	0x00033c8d
   1cbec:	00033c6d 	.word	0x00033c6d
   1cbf0:	00033c78 	.word	0x00033c78
   1cbf4:	0003040c 	.word	0x0003040c
   1cbf8:	0003049c 	.word	0x0003049c
   1cbfc:	00033de8 	.word	0x00033de8

0001cc00 <parse_nw_reg_status>:
static int parse_nw_reg_status(const char *at_response,
			       enum lte_lc_nw_reg_status *status,
			       size_t reg_status_index)
{
	int err, reg_status;
	struct at_param_list resp_list = {0};
   1cc00:	2300      	movs	r3, #0
{
   1cc02:	b5f0      	push	{r4, r5, r6, r7, lr}
   1cc04:	b087      	sub	sp, #28
	char  response_prefix[sizeof(AT_CEREG_RESPONSE_PREFIX)] = {0};
   1cc06:	9302      	str	r3, [sp, #8]
	struct at_param_list resp_list = {0};
   1cc08:	e9cd 3304 	strd	r3, r3, [sp, #16]
	char  response_prefix[sizeof(AT_CEREG_RESPONSE_PREFIX)] = {0};
   1cc0c:	f8cd 300b 	str.w	r3, [sp, #11]
	size_t response_prefix_len = sizeof(response_prefix);
   1cc10:	2307      	movs	r3, #7
{
   1cc12:	460d      	mov	r5, r1
   1cc14:	4617      	mov	r7, r2
	size_t response_prefix_len = sizeof(response_prefix);
   1cc16:	9301      	str	r3, [sp, #4]

	if ((at_response == NULL) || (status == NULL)) {
   1cc18:	4606      	mov	r6, r0
   1cc1a:	2800      	cmp	r0, #0
   1cc1c:	f000 8082 	beq.w	1cd24 <parse_nw_reg_status+0x124>
   1cc20:	2900      	cmp	r1, #0
   1cc22:	d07f      	beq.n	1cd24 <parse_nw_reg_status+0x124>
		return -EINVAL;
	}

	err = at_params_list_init(&resp_list, AT_CEREG_PARAMS_COUNT_MAX);
   1cc24:	210a      	movs	r1, #10
   1cc26:	a804      	add	r0, sp, #16
   1cc28:	f012 f82d 	bl	2ec86 <at_params_list_init>
	if (err) {
   1cc2c:	4604      	mov	r4, r0
   1cc2e:	b188      	cbz	r0, 1cc54 <parse_nw_reg_status+0x54>
		LOG_ERR("Could not init AT params list, error: %d", err);
   1cc30:	2301      	movs	r3, #1
   1cc32:	f04f 0000 	mov.w	r0, #0
   1cc36:	4a3d      	ldr	r2, [pc, #244]	; (1cd2c <parse_nw_reg_status+0x12c>)
   1cc38:	f363 0007 	bfi	r0, r3, #0, #8
   1cc3c:	4b3c      	ldr	r3, [pc, #240]	; (1cd30 <parse_nw_reg_status+0x130>)
   1cc3e:	493d      	ldr	r1, [pc, #244]	; (1cd34 <parse_nw_reg_status+0x134>)
   1cc40:	1a9b      	subs	r3, r3, r2
   1cc42:	08db      	lsrs	r3, r3, #3
   1cc44:	f363 108f 	bfi	r0, r3, #6, #10
   1cc48:	4622      	mov	r2, r4
   1cc4a:	f010 fb55 	bl	2d2f8 <log_string_sync>

clean_exit:
	at_params_list_free(&resp_list);

	return err;
}
   1cc4e:	4620      	mov	r0, r4
   1cc50:	b007      	add	sp, #28
   1cc52:	bdf0      	pop	{r4, r5, r6, r7, pc}
	err = at_parser_max_params_from_str(at_response,
   1cc54:	4601      	mov	r1, r0
   1cc56:	230a      	movs	r3, #10
   1cc58:	aa04      	add	r2, sp, #16
   1cc5a:	4630      	mov	r0, r6
   1cc5c:	f7ff fe64 	bl	1c928 <at_parser_max_params_from_str>
	if (err) {
   1cc60:	4604      	mov	r4, r0
   1cc62:	b190      	cbz	r0, 1cc8a <parse_nw_reg_status+0x8a>
		LOG_ERR("Could not parse AT+CEREG response, error: %d", err);
   1cc64:	2301      	movs	r3, #1
   1cc66:	f04f 0000 	mov.w	r0, #0
   1cc6a:	4a30      	ldr	r2, [pc, #192]	; (1cd2c <parse_nw_reg_status+0x12c>)
   1cc6c:	f363 0007 	bfi	r0, r3, #0, #8
   1cc70:	4b2f      	ldr	r3, [pc, #188]	; (1cd30 <parse_nw_reg_status+0x130>)
   1cc72:	4931      	ldr	r1, [pc, #196]	; (1cd38 <parse_nw_reg_status+0x138>)
   1cc74:	1a9b      	subs	r3, r3, r2
   1cc76:	4622      	mov	r2, r4
   1cc78:	08db      	lsrs	r3, r3, #3
   1cc7a:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Could not get response prefix, error: %d", err);
   1cc7e:	f010 fb3b 	bl	2d2f8 <log_string_sync>
	at_params_list_free(&resp_list);
   1cc82:	a804      	add	r0, sp, #16
   1cc84:	f012 f812 	bl	2ecac <at_params_list_free>
	return err;
   1cc88:	e7e1      	b.n	1cc4e <parse_nw_reg_status+0x4e>
	err = at_params_string_get(&resp_list,
   1cc8a:	4601      	mov	r1, r0
   1cc8c:	ab01      	add	r3, sp, #4
   1cc8e:	aa02      	add	r2, sp, #8
   1cc90:	a804      	add	r0, sp, #16
   1cc92:	f012 f8d0 	bl	2ee36 <at_params_string_get>
	if (err) {
   1cc96:	4604      	mov	r4, r0
   1cc98:	b168      	cbz	r0, 1ccb6 <parse_nw_reg_status+0xb6>
		LOG_ERR("Could not get response prefix, error: %d", err);
   1cc9a:	2301      	movs	r3, #1
   1cc9c:	f04f 0000 	mov.w	r0, #0
   1cca0:	4a22      	ldr	r2, [pc, #136]	; (1cd2c <parse_nw_reg_status+0x12c>)
   1cca2:	f363 0007 	bfi	r0, r3, #0, #8
   1cca6:	4b22      	ldr	r3, [pc, #136]	; (1cd30 <parse_nw_reg_status+0x130>)
   1cca8:	4924      	ldr	r1, [pc, #144]	; (1cd3c <parse_nw_reg_status+0x13c>)
   1ccaa:	1a9b      	subs	r3, r3, r2
   1ccac:	08db      	lsrs	r3, r3, #3
   1ccae:	f363 108f 	bfi	r0, r3, #6, #10
   1ccb2:	4622      	mov	r2, r4
   1ccb4:	e7e3      	b.n	1cc7e <parse_nw_reg_status+0x7e>
	if (!response_is_valid(response_prefix, response_prefix_len,
   1ccb6:	4a22      	ldr	r2, [pc, #136]	; (1cd40 <parse_nw_reg_status+0x140>)
   1ccb8:	9901      	ldr	r1, [sp, #4]
   1ccba:	a802      	add	r0, sp, #8
   1ccbc:	f012 f8f9 	bl	2eeb2 <response_is_valid>
   1ccc0:	2800      	cmp	r0, #0
   1ccc2:	d0de      	beq.n	1cc82 <parse_nw_reg_status+0x82>
	err = at_params_int_get(&resp_list, reg_status_index,
   1ccc4:	466a      	mov	r2, sp
   1ccc6:	4639      	mov	r1, r7
   1ccc8:	a804      	add	r0, sp, #16
   1ccca:	f012 f89d 	bl	2ee08 <at_params_int_get>
	if (err) {
   1ccce:	4604      	mov	r4, r0
   1ccd0:	b168      	cbz	r0, 1ccee <parse_nw_reg_status+0xee>
		LOG_ERR("Could not get registration status, error: %d", err);
   1ccd2:	2301      	movs	r3, #1
   1ccd4:	f04f 0000 	mov.w	r0, #0
   1ccd8:	4a14      	ldr	r2, [pc, #80]	; (1cd2c <parse_nw_reg_status+0x12c>)
   1ccda:	f363 0007 	bfi	r0, r3, #0, #8
   1ccde:	4b14      	ldr	r3, [pc, #80]	; (1cd30 <parse_nw_reg_status+0x130>)
   1cce0:	4918      	ldr	r1, [pc, #96]	; (1cd44 <parse_nw_reg_status+0x144>)
   1cce2:	1a9b      	subs	r3, r3, r2
   1cce4:	08db      	lsrs	r3, r3, #3
   1cce6:	f363 108f 	bfi	r0, r3, #6, #10
   1ccea:	4622      	mov	r2, r4
   1ccec:	e7c7      	b.n	1cc7e <parse_nw_reg_status+0x7e>
	switch (reg_status) {
   1ccee:	9a00      	ldr	r2, [sp, #0]
   1ccf0:	2a08      	cmp	r2, #8
   1ccf2:	d015      	beq.n	1cd20 <parse_nw_reg_status+0x120>
   1ccf4:	dc12      	bgt.n	1cd1c <parse_nw_reg_status+0x11c>
   1ccf6:	2a05      	cmp	r2, #5
   1ccf8:	d912      	bls.n	1cd20 <parse_nw_reg_status+0x120>
		LOG_ERR("Invalid network registration status: %d", reg_status);
   1ccfa:	2301      	movs	r3, #1
   1ccfc:	f04f 0000 	mov.w	r0, #0
   1cd00:	490a      	ldr	r1, [pc, #40]	; (1cd2c <parse_nw_reg_status+0x12c>)
   1cd02:	f363 0007 	bfi	r0, r3, #0, #8
   1cd06:	4b0a      	ldr	r3, [pc, #40]	; (1cd30 <parse_nw_reg_status+0x130>)
		err = -EIO;
   1cd08:	f06f 0404 	mvn.w	r4, #4
   1cd0c:	1a5b      	subs	r3, r3, r1
   1cd0e:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Invalid network registration status: %d", reg_status);
   1cd10:	f363 108f 	bfi	r0, r3, #6, #10
   1cd14:	490c      	ldr	r1, [pc, #48]	; (1cd48 <parse_nw_reg_status+0x148>)
   1cd16:	f010 faef 	bl	2d2f8 <log_string_sync>
		err = -EIO;
   1cd1a:	e7b2      	b.n	1cc82 <parse_nw_reg_status+0x82>
	switch (reg_status) {
   1cd1c:	2a5a      	cmp	r2, #90	; 0x5a
   1cd1e:	d1ec      	bne.n	1ccfa <parse_nw_reg_status+0xfa>
		*status = reg_status;
   1cd20:	702a      	strb	r2, [r5, #0]
		LOG_DBG("Network registration status: %d", reg_status);
   1cd22:	e7ae      	b.n	1cc82 <parse_nw_reg_status+0x82>
		return -EINVAL;
   1cd24:	f06f 0415 	mvn.w	r4, #21
   1cd28:	e791      	b.n	1cc4e <parse_nw_reg_status+0x4e>
   1cd2a:	bf00      	nop
   1cd2c:	0003040c 	.word	0x0003040c
   1cd30:	0003049c 	.word	0x0003049c
   1cd34:	00033ca4 	.word	0x00033ca4
   1cd38:	00033ccd 	.word	0x00033ccd
   1cd3c:	00033cfa 	.word	0x00033cfa
   1cd40:	00033d23 	.word	0x00033d23
   1cd44:	00033d2a 	.word	0x00033d2a
   1cd48:	00033d57 	.word	0x00033d57

0001cd4c <at_handler>:
{
   1cd4c:	b507      	push	{r0, r1, r2, lr}
	if (response == NULL) {
   1cd4e:	4608      	mov	r0, r1
   1cd50:	b971      	cbnz	r1, 1cd70 <at_handler+0x24>
		LOG_ERR("Response buffer is NULL-pointer");
   1cd52:	2301      	movs	r3, #1
   1cd54:	4a15      	ldr	r2, [pc, #84]	; (1cdac <at_handler+0x60>)
   1cd56:	f363 0007 	bfi	r0, r3, #0, #8
   1cd5a:	4b15      	ldr	r3, [pc, #84]	; (1cdb0 <at_handler+0x64>)
   1cd5c:	4915      	ldr	r1, [pc, #84]	; (1cdb4 <at_handler+0x68>)
   1cd5e:	1a9b      	subs	r3, r3, r2
   1cd60:	08db      	lsrs	r3, r3, #3
   1cd62:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Could not get network registration status");
   1cd66:	f010 fac7 	bl	2d2f8 <log_string_sync>
}
   1cd6a:	b003      	add	sp, #12
   1cd6c:	f85d fb04 	ldr.w	pc, [sp], #4
	err = parse_nw_reg_status(response, &status, AT_CEREG_REG_STATUS_INDEX);
   1cd70:	2201      	movs	r2, #1
   1cd72:	f10d 0107 	add.w	r1, sp, #7
   1cd76:	f7ff ff43 	bl	1cc00 <parse_nw_reg_status>
	if (err) {
   1cd7a:	b160      	cbz	r0, 1cd96 <at_handler+0x4a>
		LOG_ERR("Could not get network registration status");
   1cd7c:	2301      	movs	r3, #1
   1cd7e:	f04f 0000 	mov.w	r0, #0
   1cd82:	4a0a      	ldr	r2, [pc, #40]	; (1cdac <at_handler+0x60>)
   1cd84:	f363 0007 	bfi	r0, r3, #0, #8
   1cd88:	4b09      	ldr	r3, [pc, #36]	; (1cdb0 <at_handler+0x64>)
   1cd8a:	490b      	ldr	r1, [pc, #44]	; (1cdb8 <at_handler+0x6c>)
   1cd8c:	1a9b      	subs	r3, r3, r2
   1cd8e:	08db      	lsrs	r3, r3, #3
   1cd90:	f363 108f 	bfi	r0, r3, #6, #10
   1cd94:	e7e7      	b.n	1cd66 <at_handler+0x1a>
	if ((status == LTE_LC_NW_REG_REGISTERED_HOME) ||
   1cd96:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1cd9a:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
   1cd9e:	2b01      	cmp	r3, #1
   1cda0:	d1e3      	bne.n	1cd6a <at_handler+0x1e>
	z_impl_k_sem_give(sem);
   1cda2:	4806      	ldr	r0, [pc, #24]	; (1cdbc <at_handler+0x70>)
   1cda4:	f00b fba2 	bl	284ec <z_impl_k_sem_give>
   1cda8:	e7df      	b.n	1cd6a <at_handler+0x1e>
   1cdaa:	bf00      	nop
   1cdac:	0003040c 	.word	0x0003040c
   1cdb0:	0003049c 	.word	0x0003049c
   1cdb4:	00033c23 	.word	0x00033c23
   1cdb8:	00033c43 	.word	0x00033c43
   1cdbc:	20028998 	.word	0x20028998

0001cdc0 <w_lte_lc_connect>:
{
   1cdc0:	b510      	push	{r4, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
   1cdc2:	2201      	movs	r2, #1
   1cdc4:	2100      	movs	r1, #0
   1cdc6:	482c      	ldr	r0, [pc, #176]	; (1ce78 <w_lte_lc_connect+0xb8>)
   1cdc8:	f012 f974 	bl	2f0b4 <z_impl_k_sem_init>
	rc = at_notif_register_handler(NULL, at_handler);
   1cdcc:	492b      	ldr	r1, [pc, #172]	; (1ce7c <w_lte_lc_connect+0xbc>)
   1cdce:	2000      	movs	r0, #0
   1cdd0:	f7ff f9c4 	bl	1c15c <at_notif_register_handler>
	if (rc != 0) {
   1cdd4:	4604      	mov	r4, r0
   1cdd6:	b180      	cbz	r0, 1cdfa <w_lte_lc_connect+0x3a>
		LOG_ERR("Can't register handler rc=%d", rc);
   1cdd8:	2301      	movs	r3, #1
   1cdda:	f04f 0000 	mov.w	r0, #0
   1cdde:	4a28      	ldr	r2, [pc, #160]	; (1ce80 <w_lte_lc_connect+0xc0>)
   1cde0:	f363 0007 	bfi	r0, r3, #0, #8
   1cde4:	4b27      	ldr	r3, [pc, #156]	; (1ce84 <w_lte_lc_connect+0xc4>)
   1cde6:	4928      	ldr	r1, [pc, #160]	; (1ce88 <w_lte_lc_connect+0xc8>)
   1cde8:	1a9b      	subs	r3, r3, r2
   1cdea:	4622      	mov	r2, r4
   1cdec:	08db      	lsrs	r3, r3, #3
   1cdee:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Can't de-register handler rc=%d", rc);
   1cdf2:	f010 fa81 	bl	2d2f8 <log_string_sync>
}
   1cdf6:	4620      	mov	r0, r4
   1cdf8:	bd10      	pop	{r4, pc}
		if (at_cmd_write(current_network_mode, NULL, 0, NULL) != 0) {
   1cdfa:	4603      	mov	r3, r0
   1cdfc:	4602      	mov	r2, r0
   1cdfe:	4601      	mov	r1, r0
   1ce00:	4822      	ldr	r0, [pc, #136]	; (1ce8c <w_lte_lc_connect+0xcc>)
   1ce02:	f7ff f8f9 	bl	1bff8 <at_cmd_write>
   1ce06:	b1a8      	cbz	r0, 1ce34 <w_lte_lc_connect+0x74>
			err = -EIO;
   1ce08:	f06f 0404 	mvn.w	r4, #4
	rc = at_notif_deregister_handler(NULL, at_handler);
   1ce0c:	491b      	ldr	r1, [pc, #108]	; (1ce7c <w_lte_lc_connect+0xbc>)
   1ce0e:	2000      	movs	r0, #0
   1ce10:	f7ff f9f0 	bl	1c1f4 <at_notif_deregister_handler>
	if (rc != 0) {
   1ce14:	4602      	mov	r2, r0
   1ce16:	2800      	cmp	r0, #0
   1ce18:	d0ed      	beq.n	1cdf6 <w_lte_lc_connect+0x36>
		LOG_ERR("Can't de-register handler rc=%d", rc);
   1ce1a:	2301      	movs	r3, #1
   1ce1c:	f04f 0000 	mov.w	r0, #0
   1ce20:	4917      	ldr	r1, [pc, #92]	; (1ce80 <w_lte_lc_connect+0xc0>)
   1ce22:	f363 0007 	bfi	r0, r3, #0, #8
   1ce26:	4b17      	ldr	r3, [pc, #92]	; (1ce84 <w_lte_lc_connect+0xc4>)
   1ce28:	1a5b      	subs	r3, r3, r1
   1ce2a:	08db      	lsrs	r3, r3, #3
   1ce2c:	f363 108f 	bfi	r0, r3, #6, #10
   1ce30:	4917      	ldr	r1, [pc, #92]	; (1ce90 <w_lte_lc_connect+0xd0>)
   1ce32:	e7de      	b.n	1cdf2 <w_lte_lc_connect+0x32>
		if (at_cmd_write(normal, NULL, 0, NULL) != 0) {
   1ce34:	4623      	mov	r3, r4
   1ce36:	4622      	mov	r2, r4
   1ce38:	4621      	mov	r1, r4
   1ce3a:	4816      	ldr	r0, [pc, #88]	; (1ce94 <w_lte_lc_connect+0xd4>)
   1ce3c:	f7ff f8dc 	bl	1bff8 <at_cmd_write>
   1ce40:	2800      	cmp	r0, #0
   1ce42:	d1e1      	bne.n	1ce08 <w_lte_lc_connect+0x48>
	return z_impl_k_sem_take(sem, timeout);
   1ce44:	f64e 2160 	movw	r1, #60000	; 0xea60
   1ce48:	480b      	ldr	r0, [pc, #44]	; (1ce78 <w_lte_lc_connect+0xb8>)
   1ce4a:	f00b fb99 	bl	28580 <z_impl_k_sem_take>
		if (err == -EAGAIN) {
   1ce4e:	f110 0f0b 	cmn.w	r0, #11
   1ce52:	4604      	mov	r4, r0
   1ce54:	d1da      	bne.n	1ce0c <w_lte_lc_connect+0x4c>
			LOG_INF("Network connection attempt timed out");
   1ce56:	2303      	movs	r3, #3
   1ce58:	f04f 0000 	mov.w	r0, #0
   1ce5c:	4a08      	ldr	r2, [pc, #32]	; (1ce80 <w_lte_lc_connect+0xc0>)
   1ce5e:	f363 0007 	bfi	r0, r3, #0, #8
   1ce62:	4b08      	ldr	r3, [pc, #32]	; (1ce84 <w_lte_lc_connect+0xc4>)
   1ce64:	490c      	ldr	r1, [pc, #48]	; (1ce98 <w_lte_lc_connect+0xd8>)
   1ce66:	1a9b      	subs	r3, r3, r2
   1ce68:	08db      	lsrs	r3, r3, #3
   1ce6a:	f363 108f 	bfi	r0, r3, #6, #10
   1ce6e:	f010 fa43 	bl	2d2f8 <log_string_sync>
				err = -ETIMEDOUT;
   1ce72:	f06f 0473 	mvn.w	r4, #115	; 0x73
   1ce76:	e7c9      	b.n	1ce0c <w_lte_lc_connect+0x4c>
   1ce78:	20028998 	.word	0x20028998
   1ce7c:	0001cd4d 	.word	0x0001cd4d
   1ce80:	0003040c 	.word	0x0003040c
   1ce84:	0003049c 	.word	0x0003049c
   1ce88:	00033d86 	.word	0x00033d86
   1ce8c:	00033c8d 	.word	0x00033c8d
   1ce90:	00033dc8 	.word	0x00033dc8
   1ce94:	00033c83 	.word	0x00033c83
   1ce98:	00033da3 	.word	0x00033da3

0001ce9c <modem_info_parse.isra.0>:
		buf[i] = next_char;
		buf[i + 1] = current_char;
	}
}

static int modem_info_parse(const struct modem_info_data *modem_data,
   1ce9c:	b538      	push	{r3, r4, r5, lr}
   1ce9e:	4605      	mov	r5, r0
			    const char *buf)
{
	int err;
	u32_t param_index;

	err = at_parser_max_params_from_str(buf, NULL, &m_param_list,
   1cea0:	4a08      	ldr	r2, [pc, #32]	; (1cec4 <modem_info_parse.isra.0+0x28>)
static int modem_info_parse(const struct modem_info_data *modem_data,
   1cea2:	4608      	mov	r0, r1
	err = at_parser_max_params_from_str(buf, NULL, &m_param_list,
   1cea4:	782b      	ldrb	r3, [r5, #0]
   1cea6:	2100      	movs	r1, #0
   1cea8:	f7ff fd3e 	bl	1c928 <at_parser_max_params_from_str>
					    modem_data->param_count);

	if (err != 0) {
   1ceac:	4604      	mov	r4, r0
   1ceae:	b938      	cbnz	r0, 1cec0 <modem_info_parse.isra.0+0x24>
		return err;
	}

	param_index = at_params_valid_count_get(&m_param_list);
   1ceb0:	4804      	ldr	r0, [pc, #16]	; (1cec4 <modem_info_parse.isra.0+0x28>)
   1ceb2:	f011 ffe7 	bl	2ee84 <at_params_valid_count_get>
	if (param_index > modem_data->param_count) {
   1ceb6:	782b      	ldrb	r3, [r5, #0]
		return -EAGAIN;
   1ceb8:	4298      	cmp	r0, r3
   1ceba:	bf88      	it	hi
   1cebc:	f06f 040a 	mvnhi.w	r4, #10
	}

	return err;
}
   1cec0:	4620      	mov	r0, r4
   1cec2:	bd38      	pop	{r3, r4, r5, pc}
   1cec4:	200289b0 	.word	0x200289b0

0001cec8 <modem_info_rsrp_subscribe_handler>:

	return len <= 0 ? -ENOTSUP : len;
}

static void modem_info_rsrp_subscribe_handler(void *context, const char *response)
{
   1cec8:	b513      	push	{r0, r1, r4, lr}
   1ceca:	460c      	mov	r4, r1
	ARG_UNUSED(context);

	u16_t param_value;
	int err;

	if (!is_cesq_notification(response, strlen(response))) {
   1cecc:	4608      	mov	r0, r1
   1cece:	f7f0 f843 	bl	cf58 <strlen>
	return strstr(buf, AT_CMD_CESQ_RESP) ? true : false;
   1ced2:	491b      	ldr	r1, [pc, #108]	; (1cf40 <modem_info_rsrp_subscribe_handler+0x78>)
   1ced4:	4620      	mov	r0, r4
   1ced6:	f012 fc0b 	bl	2f6f0 <strstr>
	if (!is_cesq_notification(response, strlen(response))) {
   1ceda:	b198      	cbz	r0, 1cf04 <modem_info_rsrp_subscribe_handler+0x3c>
		return;
	}

	err = modem_info_parse(modem_data[MODEM_INFO_RSRP],
   1cedc:	4621      	mov	r1, r4
   1cede:	4819      	ldr	r0, [pc, #100]	; (1cf44 <modem_info_rsrp_subscribe_handler+0x7c>)
   1cee0:	f7ff ffdc 	bl	1ce9c <modem_info_parse.isra.0>
			       response);
	if (err != 0) {
   1cee4:	4602      	mov	r2, r0
   1cee6:	b178      	cbz	r0, 1cf08 <modem_info_rsrp_subscribe_handler+0x40>
		LOG_ERR("modem_info_parse failed to parse "
   1cee8:	2301      	movs	r3, #1
   1ceea:	f04f 0000 	mov.w	r0, #0
   1ceee:	4916      	ldr	r1, [pc, #88]	; (1cf48 <modem_info_rsrp_subscribe_handler+0x80>)
   1cef0:	f363 0007 	bfi	r0, r3, #0, #8
   1cef4:	4b15      	ldr	r3, [pc, #84]	; (1cf4c <modem_info_rsrp_subscribe_handler+0x84>)
   1cef6:	1a5b      	subs	r3, r3, r1
   1cef8:	08db      	lsrs	r3, r3, #3
   1cefa:	4915      	ldr	r1, [pc, #84]	; (1cf50 <modem_info_rsrp_subscribe_handler+0x88>)
   1cefc:	f363 108f 	bfi	r0, r3, #6, #10

	err = at_params_short_get(&m_param_list,
				  modem_data[MODEM_INFO_RSRP]->param_index,
				  &param_value);
	if (err != 0) {
		LOG_ERR("Failed to obtain RSRP value, %d", err);
   1cf00:	f010 f9fa 	bl	2d2f8 <log_string_sync>
		return;
	}

	modem_info_rsrp_cb(param_value);
}
   1cf04:	b002      	add	sp, #8
   1cf06:	bd10      	pop	{r4, pc}
	err = at_params_short_get(&m_param_list,
   1cf08:	f10d 0206 	add.w	r2, sp, #6
   1cf0c:	2101      	movs	r1, #1
   1cf0e:	4811      	ldr	r0, [pc, #68]	; (1cf54 <modem_info_rsrp_subscribe_handler+0x8c>)
   1cf10:	f011 ff64 	bl	2eddc <at_params_short_get>
	if (err != 0) {
   1cf14:	4602      	mov	r2, r0
   1cf16:	b160      	cbz	r0, 1cf32 <modem_info_rsrp_subscribe_handler+0x6a>
		LOG_ERR("Failed to obtain RSRP value, %d", err);
   1cf18:	2301      	movs	r3, #1
   1cf1a:	f04f 0000 	mov.w	r0, #0
   1cf1e:	490a      	ldr	r1, [pc, #40]	; (1cf48 <modem_info_rsrp_subscribe_handler+0x80>)
   1cf20:	f363 0007 	bfi	r0, r3, #0, #8
   1cf24:	4b09      	ldr	r3, [pc, #36]	; (1cf4c <modem_info_rsrp_subscribe_handler+0x84>)
   1cf26:	1a5b      	subs	r3, r3, r1
   1cf28:	08db      	lsrs	r3, r3, #3
   1cf2a:	f363 108f 	bfi	r0, r3, #6, #10
   1cf2e:	490a      	ldr	r1, [pc, #40]	; (1cf58 <modem_info_rsrp_subscribe_handler+0x90>)
   1cf30:	e7e6      	b.n	1cf00 <modem_info_rsrp_subscribe_handler+0x38>
	modem_info_rsrp_cb(param_value);
   1cf32:	4b0a      	ldr	r3, [pc, #40]	; (1cf5c <modem_info_rsrp_subscribe_handler+0x94>)
   1cf34:	f89d 0006 	ldrb.w	r0, [sp, #6]
   1cf38:	681b      	ldr	r3, [r3, #0]
   1cf3a:	4798      	blx	r3
   1cf3c:	e7e2      	b.n	1cf04 <modem_info_rsrp_subscribe_handler+0x3c>
   1cf3e:	bf00      	nop
   1cf40:	00033e05 	.word	0x00033e05
   1cf44:	00030b6d 	.word	0x00030b6d
   1cf48:	0003040c 	.word	0x0003040c
   1cf4c:	000304b4 	.word	0x000304b4
   1cf50:	00033e0b 	.word	0x00033e0b
   1cf54:	200289b0 	.word	0x200289b0
   1cf58:	00033e42 	.word	0x00033e42
   1cf5c:	200289b8 	.word	0x200289b8

0001cf60 <modem_info_rsrp_register>:

int modem_info_rsrp_register(rsrp_cb_t cb)
{
	modem_info_rsrp_cb = cb;
   1cf60:	4b12      	ldr	r3, [pc, #72]	; (1cfac <modem_info_rsrp_register+0x4c>)
{
   1cf62:	b510      	push	{r4, lr}

	int rc = at_notif_register_handler(NULL,
   1cf64:	4912      	ldr	r1, [pc, #72]	; (1cfb0 <modem_info_rsrp_register+0x50>)
	modem_info_rsrp_cb = cb;
   1cf66:	6018      	str	r0, [r3, #0]
	int rc = at_notif_register_handler(NULL,
   1cf68:	2000      	movs	r0, #0
   1cf6a:	f7ff f8f7 	bl	1c15c <at_notif_register_handler>
		modem_info_rsrp_subscribe_handler);
	if (rc != 0) {
   1cf6e:	4604      	mov	r4, r0
   1cf70:	b180      	cbz	r0, 1cf94 <modem_info_rsrp_register+0x34>
		LOG_ERR("Can't register handler rc=%d", rc);
   1cf72:	2301      	movs	r3, #1
   1cf74:	f04f 0000 	mov.w	r0, #0
   1cf78:	4a0e      	ldr	r2, [pc, #56]	; (1cfb4 <modem_info_rsrp_register+0x54>)
   1cf7a:	f363 0007 	bfi	r0, r3, #0, #8
   1cf7e:	4b0e      	ldr	r3, [pc, #56]	; (1cfb8 <modem_info_rsrp_register+0x58>)
   1cf80:	490e      	ldr	r1, [pc, #56]	; (1cfbc <modem_info_rsrp_register+0x5c>)
   1cf82:	1a9b      	subs	r3, r3, r2
   1cf84:	08db      	lsrs	r3, r3, #3
   1cf86:	f363 108f 	bfi	r0, r3, #6, #10
   1cf8a:	4622      	mov	r2, r4
   1cf8c:	f010 f9b4 	bl	2d2f8 <log_string_sync>
	if (at_cmd_write(AT_CMD_CESQ_ON, NULL, 0, NULL) != 0) {
		return -EIO;
	}

	return 0;
}
   1cf90:	4620      	mov	r0, r4
   1cf92:	bd10      	pop	{r4, pc}
	if (at_cmd_write(AT_CMD_CESQ_ON, NULL, 0, NULL) != 0) {
   1cf94:	4603      	mov	r3, r0
   1cf96:	4602      	mov	r2, r0
   1cf98:	4601      	mov	r1, r0
   1cf9a:	4809      	ldr	r0, [pc, #36]	; (1cfc0 <modem_info_rsrp_register+0x60>)
   1cf9c:	f7ff f82c 	bl	1bff8 <at_cmd_write>
   1cfa0:	1e04      	subs	r4, r0, #0
		return -EIO;
   1cfa2:	bf18      	it	ne
   1cfa4:	f06f 0404 	mvnne.w	r4, #4
   1cfa8:	e7f2      	b.n	1cf90 <modem_info_rsrp_register+0x30>
   1cfaa:	bf00      	nop
   1cfac:	200289b8 	.word	0x200289b8
   1cfb0:	0001cec9 	.word	0x0001cec9
   1cfb4:	0003040c 	.word	0x0003040c
   1cfb8:	000304b4 	.word	0x000304b4
   1cfbc:	00033d86 	.word	0x00033d86
   1cfc0:	00031eca 	.word	0x00031eca

0001cfc4 <modem_info_init>:

int modem_info_init(void)
{
	/* Init at_cmd_parser storage module */
	int err = at_params_list_init(&m_param_list,
   1cfc4:	210a      	movs	r1, #10
   1cfc6:	4801      	ldr	r0, [pc, #4]	; (1cfcc <modem_info_init+0x8>)
   1cfc8:	f011 be5d 	b.w	2ec86 <at_params_list_init>
   1cfcc:	200289b0 	.word	0x200289b0

0001cfd0 <modem_info_params_init>:

LOG_MODULE_REGISTER(modem_info_params);

int modem_info_params_init(struct modem_param_info *modem)
{
	if (modem == NULL) {
   1cfd0:	2800      	cmp	r0, #0
   1cfd2:	d043      	beq.n	1d05c <modem_info_params_init+0x8c>
		return -EINVAL;
	}

	modem->network.current_band.type	= MODEM_INFO_CUR_BAND;
   1cfd4:	2301      	movs	r3, #1
   1cfd6:	f880 306c 	strb.w	r3, [r0, #108]	; 0x6c
	modem->network.sup_band.type		= MODEM_INFO_SUP_BAND;
   1cfda:	2302      	movs	r3, #2
   1cfdc:	f880 30dc 	strb.w	r3, [r0, #220]	; 0xdc
	modem->network.area_code.type		= MODEM_INFO_AREA_CODE;
   1cfe0:	2303      	movs	r3, #3
   1cfe2:	f880 314c 	strb.w	r3, [r0, #332]	; 0x14c
	modem->network.current_operator.type	= MODEM_INFO_OPERATOR;
   1cfe6:	2305      	movs	r3, #5
   1cfe8:	f880 31bc 	strb.w	r3, [r0, #444]	; 0x1bc
	modem->network.mcc.type			= MODEM_INFO_MCC;
   1cfec:	2306      	movs	r3, #6
   1cfee:	f880 322c 	strb.w	r3, [r0, #556]	; 0x22c
	modem->network.mnc.type			= MODEM_INFO_MNC;
   1cff2:	2307      	movs	r3, #7
   1cff4:	f880 329c 	strb.w	r3, [r0, #668]	; 0x29c
	modem->network.cellid_hex.type		= MODEM_INFO_CELLID;
   1cff8:	2308      	movs	r3, #8
   1cffa:	f880 330c 	strb.w	r3, [r0, #780]	; 0x30c
	modem->network.ip_address.type		= MODEM_INFO_IP_ADDRESS;
   1cffe:	2309      	movs	r3, #9
   1d000:	f880 337c 	strb.w	r3, [r0, #892]	; 0x37c
	modem->network.ue_mode.type		= MODEM_INFO_UE_MODE;
   1d004:	2304      	movs	r3, #4
   1d006:	f880 33ec 	strb.w	r3, [r0, #1004]	; 0x3ec
	modem->network.lte_mode.type		= MODEM_INFO_LTE_MODE;
   1d00a:	230f      	movs	r3, #15
   1d00c:	f880 345c 	strb.w	r3, [r0, #1116]	; 0x45c
	modem->network.nbiot_mode.type		= MODEM_INFO_NBIOT_MODE;
   1d010:	2310      	movs	r3, #16
   1d012:	f880 34cc 	strb.w	r3, [r0, #1228]	; 0x4cc
	modem->network.gps_mode.type		= MODEM_INFO_GPS_MODE;
   1d016:	2311      	movs	r3, #17
   1d018:	f880 353c 	strb.w	r3, [r0, #1340]	; 0x53c
	modem->network.date_time.type		= MODEM_INFO_DATE_TIME;
   1d01c:	2314      	movs	r3, #20
   1d01e:	f880 35ac 	strb.w	r3, [r0, #1452]	; 0x5ac

	modem->sim.uicc.type			= MODEM_INFO_UICC;
   1d022:	230a      	movs	r3, #10
   1d024:	f880 3634 	strb.w	r3, [r0, #1588]	; 0x634
	modem->sim.iccid.type			= MODEM_INFO_ICCID;
   1d028:	230e      	movs	r3, #14
   1d02a:	f880 36a4 	strb.w	r3, [r0, #1700]	; 0x6a4
	modem->sim.imsi.type		        = MODEM_INFO_IMSI;
   1d02e:	2312      	movs	r3, #18
   1d030:	f880 3714 	strb.w	r3, [r0, #1812]	; 0x714

	modem->device.modem_fw.type		= MODEM_INFO_FW_VERSION;
   1d034:	230d      	movs	r3, #13
   1d036:	f880 3784 	strb.w	r3, [r0, #1924]	; 0x784
	modem->device.battery.type		= MODEM_INFO_BATTERY;
   1d03a:	230b      	movs	r3, #11
   1d03c:	f880 37f4 	strb.w	r3, [r0, #2036]	; 0x7f4
	modem->device.imei.type			= MODEM_INFO_IMEI;
   1d040:	2313      	movs	r3, #19
   1d042:	f880 3864 	strb.w	r3, [r0, #2148]	; 0x864
	modem->device.board			= CONFIG_BOARD;
   1d046:	4b07      	ldr	r3, [pc, #28]	; (1d064 <modem_info_params_init+0x94>)
   1d048:	f8c0 3868 	str.w	r3, [r0, #2152]	; 0x868
	modem->device.app_version		= STRINGIFY(APP_VERSION);
   1d04c:	4b06      	ldr	r3, [pc, #24]	; (1d068 <modem_info_params_init+0x98>)
   1d04e:	f8c0 386c 	str.w	r3, [r0, #2156]	; 0x86c
	modem->device.app_name			= STRINGIFY(PROJECT_NAME);
   1d052:	4b06      	ldr	r3, [pc, #24]	; (1d06c <modem_info_params_init+0x9c>)
   1d054:	f8c0 3870 	str.w	r3, [r0, #2160]	; 0x870

	return 0;
   1d058:	2000      	movs	r0, #0
   1d05a:	4770      	bx	lr
		return -EINVAL;
   1d05c:	f06f 0015 	mvn.w	r0, #21
}
   1d060:	4770      	bx	lr
   1d062:	bf00      	nop
   1d064:	00033fb4 	.word	0x00033fb4
   1d068:	00033fc5 	.word	0x00033fc5
   1d06c:	00033fde 	.word	0x00033fde

0001d070 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
   1d070:	b508      	push	{r3, lr}
		arch_syscall_invoke0(K_SYSCALL_LOG_PANIC);
		return;
	}
#endif
	compiler_barrier();
	z_impl_log_panic();
   1d072:	f7fa fca1 	bl	179b8 <z_impl_log_panic>
	ARG_UNUSED(esf);
	ARG_UNUSED(reason);

	LOG_PANIC();

	LOG_ERR("Resetting system");
   1d076:	2301      	movs	r3, #1
   1d078:	f04f 0000 	mov.w	r0, #0
   1d07c:	4a06      	ldr	r2, [pc, #24]	; (1d098 <k_sys_fatal_error_handler+0x28>)
   1d07e:	f363 0007 	bfi	r0, r3, #0, #8
   1d082:	4b06      	ldr	r3, [pc, #24]	; (1d09c <k_sys_fatal_error_handler+0x2c>)
   1d084:	4906      	ldr	r1, [pc, #24]	; (1d0a0 <k_sys_fatal_error_handler+0x30>)
   1d086:	1a9b      	subs	r3, r3, r2
   1d088:	08db      	lsrs	r3, r3, #3
   1d08a:	f363 108f 	bfi	r0, r3, #6, #10
   1d08e:	f010 f933 	bl	2d2f8 <log_string_sync>
	sys_arch_reboot(0);
   1d092:	2000      	movs	r0, #0
   1d094:	f7fc fc3c 	bl	19910 <sys_arch_reboot>

	CODE_UNREACHABLE;
   1d098:	0003040c 	.word	0x0003040c
   1d09c:	00030464 	.word	0x00030464
   1d0a0:	00033ffd 	.word	0x00033ffd

0001d0a4 <check_ext_api_requests>:
	}
};
#endif

static int check_ext_api_requests(struct device *dev)
{
   1d0a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	(void)dev;

	const struct fw_info_ext_api_request *ext_api_req =
			skip_ext_apis(&m_firmware_info);

	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   1d0a8:	2500      	movs	r5, #0
			skip_ext_apis(&m_firmware_info);
   1d0aa:	4c21      	ldr	r4, [pc, #132]	; (1d130 <check_ext_api_requests+0x8c>)
 */
static inline const struct fw_info_ext_api *fw_info_ext_api_check(
							u32_t ext_api_addr)
{
	const struct fw_info_ext_api *ext_api;
	const u32_t ext_api_magic[] = {EXT_API_MAGIC};
   1d0ac:	4e21      	ldr	r6, [pc, #132]	; (1d134 <check_ext_api_requests+0x90>)
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   1d0ae:	f854 8c04 	ldr.w	r8, [r4, #-4]
			/* EXT_API hard requirement not met. */
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
			k_panic();
		} else {
			/* EXT_API soft requirement not met. */
			printk("WARNING: Optional EXT_API request not "
   1d0b2:	f8df 9088 	ldr.w	r9, [pc, #136]	; 1d13c <check_ext_api_requests+0x98>
{
   1d0b6:	b085      	sub	sp, #20
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   1d0b8:	45a8      	cmp	r8, r5
   1d0ba:	d803      	bhi.n	1d0c4 <check_ext_api_requests+0x20>
		}
		ADVANCE_EXT_API_REQ(ext_api_req);
	}

	return 0;
}
   1d0bc:	2000      	movs	r0, #0
   1d0be:	b005      	add	sp, #20
   1d0c0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (fw_info_ext_api_check((u32_t)*(ext_api_req->ext_api))
   1d0c4:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1d0c6:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
   1d0ca:	681f      	ldr	r7, [r3, #0]
   1d0cc:	ab01      	add	r3, sp, #4
   1d0ce:	e883 0007 	stmia.w	r3, {r0, r1, r2}

	ext_api = (const struct fw_info_ext_api *)(ext_api_addr);
	if (memcmp(ext_api->magic, ext_api_magic, CONFIG_FW_INFO_MAGIC_LEN)
   1d0d2:	220c      	movs	r2, #12
   1d0d4:	4619      	mov	r1, r3
   1d0d6:	4638      	mov	r0, r7
   1d0d8:	f012 f92e 	bl	2f338 <memcmp>
   1d0dc:	b990      	cbnz	r0, 1d104 <check_ext_api_requests+0x60>
   1d0de:	b18f      	cbz	r7, 1d104 <check_ext_api_requests+0x60>
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
   1d0e0:	6a63      	ldr	r3, [r4, #36]	; 0x24
	const u32_t req_id = ext_api_req->request.ext_api_id;
   1d0e2:	6921      	ldr	r1, [r4, #16]
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
   1d0e4:	681b      	ldr	r3, [r3, #0]
	return ((ext_api->ext_api_id == req_id)
   1d0e6:	691a      	ldr	r2, [r3, #16]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
   1d0e8:	4291      	cmp	r1, r2
   1d0ea:	d10b      	bne.n	1d104 <check_ext_api_requests+0x60>
		&&  (ext_api->ext_api_version >= req_min_version)
   1d0ec:	699a      	ldr	r2, [r3, #24]
	const u32_t req_min_version = ext_api_req->request.ext_api_version;
   1d0ee:	69a1      	ldr	r1, [r4, #24]
		&&  (ext_api->ext_api_version >= req_min_version)
   1d0f0:	4291      	cmp	r1, r2
   1d0f2:	d807      	bhi.n	1d104 <check_ext_api_requests+0x60>
	const u32_t req_max_version = ext_api_req->ext_api_max_version;
   1d0f4:	69e1      	ldr	r1, [r4, #28]
		&&  (ext_api->ext_api_version <  req_max_version)
   1d0f6:	4291      	cmp	r1, r2
   1d0f8:	d904      	bls.n	1d104 <check_ext_api_requests+0x60>
	const u32_t req_flags = ext_api_req->request.ext_api_flags;
   1d0fa:	6962      	ldr	r2, [r4, #20]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
   1d0fc:	695b      	ldr	r3, [r3, #20]
   1d0fe:	ea32 0303 	bics.w	r3, r2, r3
   1d102:	d00a      	beq.n	1d11a <check_ext_api_requests+0x76>
		} else if (ext_api_req->required) {
   1d104:	6a27      	ldr	r7, [r4, #32]
   1d106:	b167      	cbz	r7, 1d122 <check_ext_api_requests+0x7e>
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
   1d108:	480b      	ldr	r0, [pc, #44]	; (1d138 <check_ext_api_requests+0x94>)
   1d10a:	f010 f89e 	bl	2d24a <printk>
			k_panic();
   1d10e:	4040      	eors	r0, r0
   1d110:	f380 8811 	msr	BASEPRI, r0
   1d114:	f04f 0004 	mov.w	r0, #4
   1d118:	df02      	svc	2
		ADVANCE_EXT_API_REQ(ext_api_req);
   1d11a:	68e3      	ldr	r3, [r4, #12]
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   1d11c:	3501      	adds	r5, #1
		ADVANCE_EXT_API_REQ(ext_api_req);
   1d11e:	441c      	add	r4, r3
   1d120:	e7ca      	b.n	1d0b8 <check_ext_api_requests+0x14>
			printk("WARNING: Optional EXT_API request not "
   1d122:	4648      	mov	r0, r9
   1d124:	f010 f891 	bl	2d24a <printk>
			*ext_api_req->ext_api = NULL;
   1d128:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1d12a:	601f      	str	r7, [r3, #0]
   1d12c:	e7f5      	b.n	1d11a <check_ext_api_requests+0x76>
   1d12e:	bf00      	nop
   1d130:	0000c23c 	.word	0x0000c23c
   1d134:	000305b0 	.word	0x000305b0
   1d138:	0003401a 	.word	0x0003401a
   1d13c:	00034043 	.word	0x00034043

0001d140 <rpc_logobj_client_evt_handler>:
   1d140:	b120      	cbz	r0, 1d14c <rpc_logobj_client_evt_handler+0xc>
   1d142:	f850 1b08 	ldr.w	r1, [r0], #8
   1d146:	0c09      	lsrs	r1, r1, #16
   1d148:	f000 b852 	b.w	1d1f0 <logobj_event_handler>
   1d14c:	4770      	bx	lr
   1d14e:	bf00      	nop

0001d150 <rpc_logobj_client_init>:
   1d150:	4801      	ldr	r0, [pc, #4]	; (1d158 <rpc_logobj_client_init+0x8>)
   1d152:	f006 bbd1 	b.w	238f8 <rpc_client_register>
   1d156:	bf00      	nop
   1d158:	00030b70 	.word	0x00030b70

0001d15c <rpc_logobj_client_request_alloc>:
   1d15c:	2300      	movs	r3, #0
   1d15e:	b510      	push	{r4, lr}
   1d160:	b082      	sub	sp, #8
   1d162:	9301      	str	r3, [sp, #4]
   1d164:	b961      	cbnz	r1, 1d180 <rpc_logobj_client_request_alloc+0x24>
   1d166:	b170      	cbz	r0, 1d186 <rpc_logobj_client_request_alloc+0x2a>
   1d168:	4604      	mov	r4, r0
   1d16a:	aa01      	add	r2, sp, #4
   1d16c:	2009      	movs	r0, #9
   1d16e:	f006 fdfb 	bl	23d68 <rpc_message_alloc>
   1d172:	b918      	cbnz	r0, 1d17c <rpc_logobj_client_request_alloc+0x20>
   1d174:	9b01      	ldr	r3, [sp, #4]
   1d176:	b10b      	cbz	r3, 1d17c <rpc_logobj_client_request_alloc+0x20>
   1d178:	3308      	adds	r3, #8
   1d17a:	6023      	str	r3, [r4, #0]
   1d17c:	b002      	add	sp, #8
   1d17e:	bd10      	pop	{r4, pc}
   1d180:	200f      	movs	r0, #15
   1d182:	b002      	add	sp, #8
   1d184:	bd10      	pop	{r4, pc}
   1d186:	200e      	movs	r0, #14
   1d188:	b002      	add	sp, #8
   1d18a:	bd10      	pop	{r4, pc}

0001d18c <rpc_logobj_client_request_send>:
   1d18c:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   1d190:	f5b3 4fe0 	cmp.w	r3, #28672	; 0x7000
   1d194:	d10b      	bne.n	1d1ae <rpc_logobj_client_request_send+0x22>
   1d196:	b160      	cbz	r0, 1d1b2 <rpc_logobj_client_request_send+0x26>
   1d198:	4603      	mov	r3, r0
   1d19a:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   1d19e:	2009      	movs	r0, #9
   1d1a0:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   1d1a4:	f843 1d08 	str.w	r1, [r3, #-8]!
   1d1a8:	4619      	mov	r1, r3
   1d1aa:	f006 bdc5 	b.w	23d38 <rpc_message_send>
   1d1ae:	200f      	movs	r0, #15
   1d1b0:	4770      	bx	lr
   1d1b2:	200e      	movs	r0, #14
   1d1b4:	4770      	bx	lr
   1d1b6:	bf00      	nop

0001d1b8 <rpc_logobj_client_message_free>:
   1d1b8:	b120      	cbz	r0, 1d1c4 <rpc_logobj_client_message_free+0xc>
   1d1ba:	f1a0 0108 	sub.w	r1, r0, #8
   1d1be:	2009      	movs	r0, #9
   1d1c0:	f006 be04 	b.w	23dcc <rpc_message_free>
   1d1c4:	200e      	movs	r0, #14
   1d1c6:	4770      	bx	lr

0001d1c8 <rpc_logobj_client_data_free>:
   1d1c8:	b118      	cbz	r0, 1d1d2 <rpc_logobj_client_data_free+0xa>
   1d1ca:	4601      	mov	r1, r0
   1d1cc:	2009      	movs	r0, #9
   1d1ce:	f006 bf0f 	b.w	23ff0 <rpc_message_data_free>
   1d1d2:	200e      	movs	r0, #14
   1d1d4:	4770      	bx	lr
   1d1d6:	bf00      	nop

0001d1d8 <packet_free_cb>:
   1d1d8:	b510      	push	{r4, lr}
   1d1da:	4604      	mov	r4, r0
   1d1dc:	6800      	ldr	r0, [r0, #0]
   1d1de:	f7ff fff3 	bl	1d1c8 <rpc_logobj_client_data_free>
   1d1e2:	68a0      	ldr	r0, [r4, #8]
   1d1e4:	b118      	cbz	r0, 1d1ee <packet_free_cb+0x16>
   1d1e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1d1ea:	f001 b935 	b.w	1e458 <nrf_free>
   1d1ee:	bd10      	pop	{r4, pc}

0001d1f0 <logobj_event_handler>:
   1d1f0:	b530      	push	{r4, r5, lr}
   1d1f2:	4b3b      	ldr	r3, [pc, #236]	; (1d2e0 <logobj_event_handler+0xf0>)
   1d1f4:	b085      	sub	sp, #20
   1d1f6:	681d      	ldr	r5, [r3, #0]
   1d1f8:	2d00      	cmp	r5, #0
   1d1fa:	d04c      	beq.n	1d296 <logobj_event_handler+0xa6>
   1d1fc:	f248 0302 	movw	r3, #32770	; 0x8002
   1d200:	4299      	cmp	r1, r3
   1d202:	d053      	beq.n	1d2ac <logobj_event_handler+0xbc>
   1d204:	d91c      	bls.n	1d240 <logobj_event_handler+0x50>
   1d206:	f248 0303 	movw	r3, #32771	; 0x8003
   1d20a:	4299      	cmp	r1, r3
   1d20c:	d05a      	beq.n	1d2c4 <logobj_event_handler+0xd4>
   1d20e:	f249 0301 	movw	r3, #36865	; 0x9001
   1d212:	4299      	cmp	r1, r3
   1d214:	d147      	bne.n	1d2a6 <logobj_event_handler+0xb6>
   1d216:	2400      	movs	r4, #0
   1d218:	6843      	ldr	r3, [r0, #4]
   1d21a:	6802      	ldr	r2, [r0, #0]
   1d21c:	e9cd 4402 	strd	r4, r4, [sp, #8]
   1d220:	e9cd 2300 	strd	r2, r3, [sp]
   1d224:	69e8      	ldr	r0, [r5, #28]
   1d226:	4669      	mov	r1, sp
   1d228:	6803      	ldr	r3, [r0, #0]
   1d22a:	685b      	ldr	r3, [r3, #4]
   1d22c:	4798      	blx	r3
   1d22e:	3001      	adds	r0, #1
   1d230:	d04e      	beq.n	1d2d0 <logobj_event_handler+0xe0>
   1d232:	4620      	mov	r0, r4
   1d234:	682b      	ldr	r3, [r5, #0]
   1d236:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   1d23a:	602b      	str	r3, [r5, #0]
   1d23c:	b005      	add	sp, #20
   1d23e:	bd30      	pop	{r4, r5, pc}
   1d240:	f248 0301 	movw	r3, #32769	; 0x8001
   1d244:	4299      	cmp	r1, r3
   1d246:	d12e      	bne.n	1d2a6 <logobj_event_handler+0xb6>
   1d248:	68c3      	ldr	r3, [r0, #12]
   1d24a:	2b00      	cmp	r3, #0
   1d24c:	d135      	bne.n	1d2ba <logobj_event_handler+0xca>
   1d24e:	6828      	ldr	r0, [r5, #0]
   1d250:	f410 0080 	ands.w	r0, r0, #4194304	; 0x400000
   1d254:	d03e      	beq.n	1d2d4 <logobj_event_handler+0xe4>
   1d256:	682b      	ldr	r3, [r5, #0]
   1d258:	b29b      	uxth	r3, r3
   1d25a:	2b01      	cmp	r3, #1
   1d25c:	d105      	bne.n	1d26a <logobj_event_handler+0x7a>
   1d25e:	682b      	ldr	r3, [r5, #0]
   1d260:	0c1b      	lsrs	r3, r3, #16
   1d262:	041b      	lsls	r3, r3, #16
   1d264:	f043 0302 	orr.w	r3, r3, #2
   1d268:	602b      	str	r3, [r5, #0]
   1d26a:	4b1e      	ldr	r3, [pc, #120]	; (1d2e4 <logobj_event_handler+0xf4>)
   1d26c:	781a      	ldrb	r2, [r3, #0]
   1d26e:	f002 01ff 	and.w	r1, r2, #255	; 0xff
   1d272:	2a00      	cmp	r2, #0
   1d274:	d031      	beq.n	1d2da <logobj_event_handler+0xea>
   1d276:	4a1c      	ldr	r2, [pc, #112]	; (1d2e8 <logobj_event_handler+0xf8>)
   1d278:	7811      	ldrb	r1, [r2, #0]
   1d27a:	b909      	cbnz	r1, 1d280 <logobj_event_handler+0x90>
   1d27c:	2101      	movs	r1, #1
   1d27e:	7011      	strb	r1, [r2, #0]
   1d280:	2000      	movs	r0, #0
   1d282:	7018      	strb	r0, [r3, #0]
   1d284:	682b      	ldr	r3, [r5, #0]
   1d286:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   1d28a:	602b      	str	r3, [r5, #0]
   1d28c:	682b      	ldr	r3, [r5, #0]
   1d28e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   1d292:	602b      	str	r3, [r5, #0]
   1d294:	e7d2      	b.n	1d23c <logobj_event_handler+0x4c>
   1d296:	6800      	ldr	r0, [r0, #0]
   1d298:	2800      	cmp	r0, #0
   1d29a:	d0cf      	beq.n	1d23c <logobj_event_handler+0x4c>
   1d29c:	f7ff ff94 	bl	1d1c8 <rpc_logobj_client_data_free>
   1d2a0:	4628      	mov	r0, r5
   1d2a2:	b005      	add	sp, #20
   1d2a4:	bd30      	pop	{r4, r5, pc}
   1d2a6:	2000      	movs	r0, #0
   1d2a8:	b005      	add	sp, #20
   1d2aa:	bd30      	pop	{r4, r5, pc}
   1d2ac:	682b      	ldr	r3, [r5, #0]
   1d2ae:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
   1d2b2:	d00b      	beq.n	1d2cc <logobj_event_handler+0xdc>
   1d2b4:	68c0      	ldr	r0, [r0, #12]
   1d2b6:	2800      	cmp	r0, #0
   1d2b8:	d0e4      	beq.n	1d284 <logobj_event_handler+0x94>
   1d2ba:	230e      	movs	r3, #14
   1d2bc:	2000      	movs	r0, #0
   1d2be:	606b      	str	r3, [r5, #4]
   1d2c0:	b005      	add	sp, #20
   1d2c2:	bd30      	pop	{r4, r5, pc}
   1d2c4:	68c3      	ldr	r3, [r0, #12]
   1d2c6:	2b01      	cmp	r3, #1
   1d2c8:	d1a5      	bne.n	1d216 <logobj_event_handler+0x26>
   1d2ca:	e7f6      	b.n	1d2ba <logobj_event_handler+0xca>
   1d2cc:	4618      	mov	r0, r3
   1d2ce:	e7b5      	b.n	1d23c <logobj_event_handler+0x4c>
   1d2d0:	2002      	movs	r0, #2
   1d2d2:	e7b3      	b.n	1d23c <logobj_event_handler+0x4c>
   1d2d4:	230e      	movs	r3, #14
   1d2d6:	606b      	str	r3, [r5, #4]
   1d2d8:	e7b0      	b.n	1d23c <logobj_event_handler+0x4c>
   1d2da:	4a03      	ldr	r2, [pc, #12]	; (1d2e8 <logobj_event_handler+0xf8>)
   1d2dc:	7011      	strb	r1, [r2, #0]
   1d2de:	e7cf      	b.n	1d280 <logobj_event_handler+0x90>
   1d2e0:	200289c0 	.word	0x200289c0
   1d2e4:	200314b6 	.word	0x200314b6
   1d2e8:	200314b7 	.word	0x200314b7

0001d2ec <logobj_interface_init>:
   1d2ec:	2300      	movs	r3, #0
   1d2ee:	b510      	push	{r4, lr}
   1d2f0:	4907      	ldr	r1, [pc, #28]	; (1d310 <logobj_interface_init+0x24>)
   1d2f2:	4a08      	ldr	r2, [pc, #32]	; (1d314 <logobj_interface_init+0x28>)
   1d2f4:	4c08      	ldr	r4, [pc, #32]	; (1d318 <logobj_interface_init+0x2c>)
   1d2f6:	4809      	ldr	r0, [pc, #36]	; (1d31c <logobj_interface_init+0x30>)
   1d2f8:	7023      	strb	r3, [r4, #0]
   1d2fa:	6003      	str	r3, [r0, #0]
   1d2fc:	700b      	strb	r3, [r1, #0]
   1d2fe:	6013      	str	r3, [r2, #0]
   1d300:	f7ff ff26 	bl	1d150 <rpc_logobj_client_init>
   1d304:	3000      	adds	r0, #0
   1d306:	bf18      	it	ne
   1d308:	2001      	movne	r0, #1
   1d30a:	4240      	negs	r0, r0
   1d30c:	bd10      	pop	{r4, pc}
   1d30e:	bf00      	nop
   1d310:	200314b6 	.word	0x200314b6
   1d314:	200289bc 	.word	0x200289bc
   1d318:	200314b7 	.word	0x200314b7
   1d31c:	200289c0 	.word	0x200289c0

0001d320 <logobj_interface_open>:
   1d320:	2300      	movs	r3, #0
   1d322:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1d326:	2866      	cmp	r0, #102	; 0x66
   1d328:	b082      	sub	sp, #8
   1d32a:	9300      	str	r3, [sp, #0]
   1d32c:	d172      	bne.n	1d414 <logobj_interface_open+0xf4>
   1d32e:	2902      	cmp	r1, #2
   1d330:	4689      	mov	r9, r1
   1d332:	d16f      	bne.n	1d414 <logobj_interface_open+0xf4>
   1d334:	f240 2305 	movw	r3, #517	; 0x205
   1d338:	429a      	cmp	r2, r3
   1d33a:	4692      	mov	sl, r2
   1d33c:	d16a      	bne.n	1d414 <logobj_interface_open+0xf4>
   1d33e:	4f48      	ldr	r7, [pc, #288]	; (1d460 <logobj_interface_open+0x140>)
   1d340:	683d      	ldr	r5, [r7, #0]
   1d342:	2d00      	cmp	r5, #0
   1d344:	d17c      	bne.n	1d440 <logobj_interface_open+0x120>
   1d346:	4680      	mov	r8, r0
   1d348:	4a46      	ldr	r2, [pc, #280]	; (1d464 <logobj_interface_open+0x144>)
   1d34a:	4668      	mov	r0, sp
   1d34c:	f006 f872 	bl	23434 <interface_socket_allocate>
   1d350:	9b00      	ldr	r3, [sp, #0]
   1d352:	4606      	mov	r6, r0
   1d354:	2b00      	cmp	r3, #0
   1d356:	d07d      	beq.n	1d454 <logobj_interface_open+0x134>
   1d358:	4629      	mov	r1, r5
   1d35a:	2204      	movs	r2, #4
   1d35c:	4842      	ldr	r0, [pc, #264]	; (1d468 <logobj_interface_open+0x148>)
   1d35e:	603b      	str	r3, [r7, #0]
   1d360:	f012 f818 	bl	2f394 <memset>
   1d364:	9c00      	ldr	r4, [sp, #0]
   1d366:	4629      	mov	r1, r5
   1d368:	e9c4 8903 	strd	r8, r9, [r4, #12]
   1d36c:	f8c4 a014 	str.w	sl, [r4, #20]
   1d370:	a801      	add	r0, sp, #4
   1d372:	f7ff fef3 	bl	1d15c <rpc_logobj_client_request_alloc>
   1d376:	2800      	cmp	r0, #0
   1d378:	d13c      	bne.n	1d3f4 <logobj_interface_open+0xd4>
   1d37a:	2201      	movs	r2, #1
   1d37c:	2104      	movs	r1, #4
   1d37e:	9b01      	ldr	r3, [sp, #4]
   1d380:	4d3a      	ldr	r5, [pc, #232]	; (1d46c <logobj_interface_open+0x14c>)
   1d382:	7358      	strb	r0, [r3, #13]
   1d384:	7398      	strb	r0, [r3, #14]
   1d386:	73d8      	strb	r0, [r3, #15]
   1d388:	7258      	strb	r0, [r3, #9]
   1d38a:	7298      	strb	r0, [r3, #10]
   1d38c:	72d8      	strb	r0, [r3, #11]
   1d38e:	7219      	strb	r1, [r3, #8]
   1d390:	702a      	strb	r2, [r5, #0]
   1d392:	731a      	strb	r2, [r3, #12]
   1d394:	6822      	ldr	r2, [r4, #0]
   1d396:	4618      	mov	r0, r3
   1d398:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
   1d39c:	6022      	str	r2, [r4, #0]
   1d39e:	f247 0101 	movw	r1, #28673	; 0x7001
   1d3a2:	f7ff fef3 	bl	1d18c <rpc_logobj_client_request_send>
   1d3a6:	bb38      	cbnz	r0, 1d3f8 <logobj_interface_open+0xd8>
   1d3a8:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   1d3ac:	f04f 33ff 	mov.w	r3, #4294967295
   1d3b0:	4611      	mov	r1, r2
   1d3b2:	4630      	mov	r0, r6
   1d3b4:	f006 f8f0 	bl	23598 <interface_socket_wait>
   1d3b8:	4604      	mov	r4, r0
   1d3ba:	b310      	cbz	r0, 1d402 <logobj_interface_open+0xe2>
   1d3bc:	9a00      	ldr	r2, [sp, #0]
   1d3be:	2e00      	cmp	r6, #0
   1d3c0:	6813      	ldr	r3, [r2, #0]
   1d3c2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1d3c6:	6013      	str	r3, [r2, #0]
   1d3c8:	9a00      	ldr	r2, [sp, #0]
   1d3ca:	6813      	ldr	r3, [r2, #0]
   1d3cc:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   1d3d0:	6013      	str	r3, [r2, #0]
   1d3d2:	9a00      	ldr	r2, [sp, #0]
   1d3d4:	6813      	ldr	r3, [r2, #0]
   1d3d6:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   1d3da:	6013      	str	r3, [r2, #0]
   1d3dc:	da36      	bge.n	1d44c <logobj_interface_open+0x12c>
   1d3de:	2300      	movs	r3, #0
   1d3e0:	4620      	mov	r0, r4
   1d3e2:	603b      	str	r3, [r7, #0]
   1d3e4:	f04f 36ff 	mov.w	r6, #4294967295
   1d3e8:	f7fe f9c0 	bl	1b76c <bsd_os_errno_set>
   1d3ec:	4630      	mov	r0, r6
   1d3ee:	b002      	add	sp, #8
   1d3f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1d3f4:	240c      	movs	r4, #12
   1d3f6:	e7e1      	b.n	1d3bc <logobj_interface_open+0x9c>
   1d3f8:	9801      	ldr	r0, [sp, #4]
   1d3fa:	f7ff fedd 	bl	1d1b8 <rpc_logobj_client_message_free>
   1d3fe:	2405      	movs	r4, #5
   1d400:	e7dc      	b.n	1d3bc <logobj_interface_open+0x9c>
   1d402:	4630      	mov	r0, r6
   1d404:	f006 f93c 	bl	23680 <interface_socket_from_handle_get>
   1d408:	b150      	cbz	r0, 1d420 <logobj_interface_open+0x100>
   1d40a:	6844      	ldr	r4, [r0, #4]
   1d40c:	b144      	cbz	r4, 1d420 <logobj_interface_open+0x100>
   1d40e:	2300      	movs	r3, #0
   1d410:	6043      	str	r3, [r0, #4]
   1d412:	e7d3      	b.n	1d3bc <logobj_interface_open+0x9c>
   1d414:	2016      	movs	r0, #22
   1d416:	f7fe f9a9 	bl	1b76c <bsd_os_errno_set>
   1d41a:	f04f 36ff 	mov.w	r6, #4294967295
   1d41e:	e7e5      	b.n	1d3ec <logobj_interface_open+0xcc>
   1d420:	9a00      	ldr	r2, [sp, #0]
   1d422:	6813      	ldr	r3, [r2, #0]
   1d424:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1d428:	6013      	str	r3, [r2, #0]
   1d42a:	9a00      	ldr	r2, [sp, #0]
   1d42c:	6813      	ldr	r3, [r2, #0]
   1d42e:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   1d432:	6013      	str	r3, [r2, #0]
   1d434:	9a00      	ldr	r2, [sp, #0]
   1d436:	6813      	ldr	r3, [r2, #0]
   1d438:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   1d43c:	6013      	str	r3, [r2, #0]
   1d43e:	e7d5      	b.n	1d3ec <logobj_interface_open+0xcc>
   1d440:	2001      	movs	r0, #1
   1d442:	f7fe f993 	bl	1b76c <bsd_os_errno_set>
   1d446:	f04f 36ff 	mov.w	r6, #4294967295
   1d44a:	e7cf      	b.n	1d3ec <logobj_interface_open+0xcc>
   1d44c:	4630      	mov	r0, r6
   1d44e:	f006 f855 	bl	234fc <interface_socket_free>
   1d452:	e7c4      	b.n	1d3de <logobj_interface_open+0xbe>
   1d454:	2018      	movs	r0, #24
   1d456:	f7fe f989 	bl	1b76c <bsd_os_errno_set>
   1d45a:	f04f 36ff 	mov.w	r6, #4294967295
   1d45e:	e7c5      	b.n	1d3ec <logobj_interface_open+0xcc>
   1d460:	200289c0 	.word	0x200289c0
   1d464:	0001d1d9 	.word	0x0001d1d9
   1d468:	200289bc 	.word	0x200289bc
   1d46c:	200314b6 	.word	0x200314b6

0001d470 <logobj_interface_read>:
   1d470:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1d474:	b085      	sub	sp, #20
   1d476:	2900      	cmp	r1, #0
   1d478:	d068      	beq.n	1d54c <logobj_interface_read+0xdc>
   1d47a:	2a00      	cmp	r2, #0
   1d47c:	4617      	mov	r7, r2
   1d47e:	dd65      	ble.n	1d54c <logobj_interface_read+0xdc>
   1d480:	461d      	mov	r5, r3
   1d482:	4680      	mov	r8, r0
   1d484:	460e      	mov	r6, r1
   1d486:	f006 f8fb 	bl	23680 <interface_socket_from_handle_get>
   1d48a:	4604      	mov	r4, r0
   1d48c:	2800      	cmp	r0, #0
   1d48e:	d063      	beq.n	1d558 <logobj_interface_read+0xe8>
   1d490:	bb4d      	cbnz	r5, 1d4e6 <logobj_interface_read+0x76>
   1d492:	69e0      	ldr	r0, [r4, #28]
   1d494:	07aa      	lsls	r2, r5, #30
   1d496:	6803      	ldr	r3, [r0, #0]
   1d498:	68db      	ldr	r3, [r3, #12]
   1d49a:	d52d      	bpl.n	1d4f8 <logobj_interface_read+0x88>
   1d49c:	4798      	blx	r3
   1d49e:	3001      	adds	r0, #1
   1d4a0:	d044      	beq.n	1d52c <logobj_interface_read+0xbc>
   1d4a2:	6823      	ldr	r3, [r4, #0]
   1d4a4:	69e0      	ldr	r0, [r4, #28]
   1d4a6:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
   1d4aa:	d041      	beq.n	1d530 <logobj_interface_read+0xc0>
   1d4ac:	2100      	movs	r1, #0
   1d4ae:	6823      	ldr	r3, [r4, #0]
   1d4b0:	462a      	mov	r2, r5
   1d4b2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   1d4b6:	6023      	str	r3, [r4, #0]
   1d4b8:	e9cd 1102 	strd	r1, r1, [sp, #8]
   1d4bc:	e9cd 6700 	strd	r6, r7, [sp]
   1d4c0:	6803      	ldr	r3, [r0, #0]
   1d4c2:	4669      	mov	r1, sp
   1d4c4:	689b      	ldr	r3, [r3, #8]
   1d4c6:	4798      	blx	r3
   1d4c8:	4605      	mov	r5, r0
   1d4ca:	69e0      	ldr	r0, [r4, #28]
   1d4cc:	6803      	ldr	r3, [r0, #0]
   1d4ce:	68db      	ldr	r3, [r3, #12]
   1d4d0:	4798      	blx	r3
   1d4d2:	3001      	adds	r0, #1
   1d4d4:	d003      	beq.n	1d4de <logobj_interface_read+0x6e>
   1d4d6:	6823      	ldr	r3, [r4, #0]
   1d4d8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   1d4dc:	6023      	str	r3, [r4, #0]
   1d4de:	4628      	mov	r0, r5
   1d4e0:	b005      	add	sp, #20
   1d4e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1d4e6:	f015 0f0a 	tst.w	r5, #10
   1d4ea:	d1d2      	bne.n	1d492 <logobj_interface_read+0x22>
   1d4ec:	202d      	movs	r0, #45	; 0x2d
   1d4ee:	f7fe f93d 	bl	1b76c <bsd_os_errno_set>
   1d4f2:	f04f 35ff 	mov.w	r5, #4294967295
   1d4f6:	e7f2      	b.n	1d4de <logobj_interface_read+0x6e>
   1d4f8:	6822      	ldr	r2, [r4, #0]
   1d4fa:	f012 5980 	ands.w	r9, r2, #268435456	; 0x10000000
   1d4fe:	d1cd      	bne.n	1d49c <logobj_interface_read+0x2c>
   1d500:	4798      	blx	r3
   1d502:	1c43      	adds	r3, r0, #1
   1d504:	d1cd      	bne.n	1d4a2 <logobj_interface_read+0x32>
   1d506:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   1d50a:	6a23      	ldr	r3, [r4, #32]
   1d50c:	4611      	mov	r1, r2
   1d50e:	2b00      	cmp	r3, #0
   1d510:	bf08      	it	eq
   1d512:	4603      	moveq	r3, r0
   1d514:	4640      	mov	r0, r8
   1d516:	f006 f83f 	bl	23598 <interface_socket_wait>
   1d51a:	b158      	cbz	r0, 1d534 <logobj_interface_read+0xc4>
   1d51c:	f04f 35ff 	mov.w	r5, #4294967295
   1d520:	f7fe f924 	bl	1b76c <bsd_os_errno_set>
   1d524:	4628      	mov	r0, r5
   1d526:	b005      	add	sp, #20
   1d528:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1d52c:	2023      	movs	r0, #35	; 0x23
   1d52e:	e7f5      	b.n	1d51c <logobj_interface_read+0xac>
   1d530:	461d      	mov	r5, r3
   1d532:	e7cb      	b.n	1d4cc <logobj_interface_read+0x5c>
   1d534:	4640      	mov	r0, r8
   1d536:	f006 f8a3 	bl	23680 <interface_socket_from_handle_get>
   1d53a:	4603      	mov	r3, r0
   1d53c:	2800      	cmp	r0, #0
   1d53e:	d0b0      	beq.n	1d4a2 <logobj_interface_read+0x32>
   1d540:	6840      	ldr	r0, [r0, #4]
   1d542:	2800      	cmp	r0, #0
   1d544:	d0ad      	beq.n	1d4a2 <logobj_interface_read+0x32>
   1d546:	f8c3 9004 	str.w	r9, [r3, #4]
   1d54a:	e7e7      	b.n	1d51c <logobj_interface_read+0xac>
   1d54c:	2016      	movs	r0, #22
   1d54e:	f7fe f90d 	bl	1b76c <bsd_os_errno_set>
   1d552:	f04f 35ff 	mov.w	r5, #4294967295
   1d556:	e7c2      	b.n	1d4de <logobj_interface_read+0x6e>
   1d558:	2009      	movs	r0, #9
   1d55a:	f7fe f907 	bl	1b76c <bsd_os_errno_set>
   1d55e:	f04f 35ff 	mov.w	r5, #4294967295
   1d562:	e7bc      	b.n	1d4de <logobj_interface_read+0x6e>

0001d564 <logobj_interface_write>:
   1d564:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d568:	b082      	sub	sp, #8
   1d56a:	2900      	cmp	r1, #0
   1d56c:	d05e      	beq.n	1d62c <logobj_interface_write+0xc8>
   1d56e:	2a04      	cmp	r2, #4
   1d570:	d15c      	bne.n	1d62c <logobj_interface_write+0xc8>
   1d572:	461e      	mov	r6, r3
   1d574:	4607      	mov	r7, r0
   1d576:	460d      	mov	r5, r1
   1d578:	f006 f882 	bl	23680 <interface_socket_from_handle_get>
   1d57c:	4604      	mov	r4, r0
   1d57e:	2800      	cmp	r0, #0
   1d580:	d070      	beq.n	1d664 <logobj_interface_write+0x100>
   1d582:	b1e6      	cbz	r6, 1d5be <logobj_interface_write+0x5a>
   1d584:	07b0      	lsls	r0, r6, #30
   1d586:	d567      	bpl.n	1d658 <logobj_interface_write+0xf4>
   1d588:	6823      	ldr	r3, [r4, #0]
   1d58a:	039b      	lsls	r3, r3, #14
   1d58c:	d560      	bpl.n	1d650 <logobj_interface_write+0xec>
   1d58e:	2600      	movs	r6, #0
   1d590:	6823      	ldr	r3, [r4, #0]
   1d592:	2100      	movs	r1, #0
   1d594:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   1d598:	6023      	str	r3, [r4, #0]
   1d59a:	a801      	add	r0, sp, #4
   1d59c:	f8d5 8000 	ldr.w	r8, [r5]
   1d5a0:	f7ff fddc 	bl	1d15c <rpc_logobj_client_request_alloc>
   1d5a4:	b198      	cbz	r0, 1d5ce <logobj_interface_write+0x6a>
   1d5a6:	200c      	movs	r0, #12
   1d5a8:	6823      	ldr	r3, [r4, #0]
   1d5aa:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1d5ae:	6023      	str	r3, [r4, #0]
   1d5b0:	f7fe f8dc 	bl	1b76c <bsd_os_errno_set>
   1d5b4:	f04f 30ff 	mov.w	r0, #4294967295
   1d5b8:	b002      	add	sp, #8
   1d5ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1d5be:	6803      	ldr	r3, [r0, #0]
   1d5c0:	00d9      	lsls	r1, r3, #3
   1d5c2:	d4e1      	bmi.n	1d588 <logobj_interface_write+0x24>
   1d5c4:	6803      	ldr	r3, [r0, #0]
   1d5c6:	039a      	lsls	r2, r3, #14
   1d5c8:	d544      	bpl.n	1d654 <logobj_interface_write+0xf0>
   1d5ca:	2601      	movs	r6, #1
   1d5cc:	e7e0      	b.n	1d590 <logobj_interface_write+0x2c>
   1d5ce:	2504      	movs	r5, #4
   1d5d0:	9b01      	ldr	r3, [sp, #4]
   1d5d2:	f247 0103 	movw	r1, #28675	; 0x7003
   1d5d6:	f8c3 800c 	str.w	r8, [r3, #12]
   1d5da:	7258      	strb	r0, [r3, #9]
   1d5dc:	7298      	strb	r0, [r3, #10]
   1d5de:	72d8      	strb	r0, [r3, #11]
   1d5e0:	721d      	strb	r5, [r3, #8]
   1d5e2:	4618      	mov	r0, r3
   1d5e4:	f7ff fdd2 	bl	1d18c <rpc_logobj_client_request_send>
   1d5e8:	4680      	mov	r8, r0
   1d5ea:	b9b0      	cbnz	r0, 1d61a <logobj_interface_write+0xb6>
   1d5ec:	b93e      	cbnz	r6, 1d5fe <logobj_interface_write+0x9a>
   1d5ee:	4628      	mov	r0, r5
   1d5f0:	6823      	ldr	r3, [r4, #0]
   1d5f2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1d5f6:	6023      	str	r3, [r4, #0]
   1d5f8:	b002      	add	sp, #8
   1d5fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1d5fe:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   1d602:	f04f 33ff 	mov.w	r3, #4294967295
   1d606:	4611      	mov	r1, r2
   1d608:	4638      	mov	r0, r7
   1d60a:	f005 ffc5 	bl	23598 <interface_socket_wait>
   1d60e:	b198      	cbz	r0, 1d638 <logobj_interface_write+0xd4>
   1d610:	6823      	ldr	r3, [r4, #0]
   1d612:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1d616:	6023      	str	r3, [r4, #0]
   1d618:	e7ca      	b.n	1d5b0 <logobj_interface_write+0x4c>
   1d61a:	9801      	ldr	r0, [sp, #4]
   1d61c:	f7ff fdcc 	bl	1d1b8 <rpc_logobj_client_message_free>
   1d620:	6823      	ldr	r3, [r4, #0]
   1d622:	2005      	movs	r0, #5
   1d624:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1d628:	6023      	str	r3, [r4, #0]
   1d62a:	e7c1      	b.n	1d5b0 <logobj_interface_write+0x4c>
   1d62c:	2016      	movs	r0, #22
   1d62e:	f7fe f89d 	bl	1b76c <bsd_os_errno_set>
   1d632:	f04f 30ff 	mov.w	r0, #4294967295
   1d636:	e7bf      	b.n	1d5b8 <logobj_interface_write+0x54>
   1d638:	4638      	mov	r0, r7
   1d63a:	f006 f821 	bl	23680 <interface_socket_from_handle_get>
   1d63e:	4603      	mov	r3, r0
   1d640:	2800      	cmp	r0, #0
   1d642:	d0d4      	beq.n	1d5ee <logobj_interface_write+0x8a>
   1d644:	6840      	ldr	r0, [r0, #4]
   1d646:	2800      	cmp	r0, #0
   1d648:	d0d1      	beq.n	1d5ee <logobj_interface_write+0x8a>
   1d64a:	f8c3 8004 	str.w	r8, [r3, #4]
   1d64e:	e7df      	b.n	1d610 <logobj_interface_write+0xac>
   1d650:	2073      	movs	r0, #115	; 0x73
   1d652:	e7ad      	b.n	1d5b0 <logobj_interface_write+0x4c>
   1d654:	2009      	movs	r0, #9
   1d656:	e7ab      	b.n	1d5b0 <logobj_interface_write+0x4c>
   1d658:	202d      	movs	r0, #45	; 0x2d
   1d65a:	f7fe f887 	bl	1b76c <bsd_os_errno_set>
   1d65e:	f04f 30ff 	mov.w	r0, #4294967295
   1d662:	e7a9      	b.n	1d5b8 <logobj_interface_write+0x54>
   1d664:	2009      	movs	r0, #9
   1d666:	f7fe f881 	bl	1b76c <bsd_os_errno_set>
   1d66a:	f04f 30ff 	mov.w	r0, #4294967295
   1d66e:	e7a3      	b.n	1d5b8 <logobj_interface_write+0x54>

0001d670 <logobj_interface_setopt>:
   1d670:	b5f0      	push	{r4, r5, r6, r7, lr}
   1d672:	2901      	cmp	r1, #1
   1d674:	b085      	sub	sp, #20
   1d676:	d068      	beq.n	1d74a <logobj_interface_setopt+0xda>
   1d678:	461e      	mov	r6, r3
   1d67a:	f240 2305 	movw	r3, #517	; 0x205
   1d67e:	4299      	cmp	r1, r3
   1d680:	f040 8095 	bne.w	1d7ae <logobj_interface_setopt+0x13e>
   1d684:	4607      	mov	r7, r0
   1d686:	4615      	mov	r5, r2
   1d688:	f005 fffa 	bl	23680 <interface_socket_from_handle_get>
   1d68c:	4604      	mov	r4, r0
   1d68e:	2800      	cmp	r0, #0
   1d690:	f000 80b2 	beq.w	1d7f8 <logobj_interface_setopt+0x188>
   1d694:	2d01      	cmp	r5, #1
   1d696:	d019      	beq.n	1d6cc <logobj_interface_setopt+0x5c>
   1d698:	2d02      	cmp	r5, #2
   1d69a:	d010      	beq.n	1d6be <logobj_interface_setopt+0x4e>
   1d69c:	252a      	movs	r5, #42	; 0x2a
   1d69e:	6803      	ldr	r3, [r0, #0]
   1d6a0:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   1d6a4:	6023      	str	r3, [r4, #0]
   1d6a6:	6823      	ldr	r3, [r4, #0]
   1d6a8:	4628      	mov	r0, r5
   1d6aa:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   1d6ae:	6023      	str	r3, [r4, #0]
   1d6b0:	f7fe f85c 	bl	1b76c <bsd_os_errno_set>
   1d6b4:	f04f 35ff 	mov.w	r5, #4294967295
   1d6b8:	4628      	mov	r0, r5
   1d6ba:	b005      	add	sp, #20
   1d6bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d6be:	b116      	cbz	r6, 1d6c6 <logobj_interface_setopt+0x56>
   1d6c0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1d6c2:	2b01      	cmp	r3, #1
   1d6c4:	d049      	beq.n	1d75a <logobj_interface_setopt+0xea>
   1d6c6:	6823      	ldr	r3, [r4, #0]
   1d6c8:	2516      	movs	r5, #22
   1d6ca:	e7e9      	b.n	1d6a0 <logobj_interface_setopt+0x30>
   1d6cc:	2e00      	cmp	r6, #0
   1d6ce:	d0fa      	beq.n	1d6c6 <logobj_interface_setopt+0x56>
   1d6d0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1d6d2:	2b04      	cmp	r3, #4
   1d6d4:	d1f7      	bne.n	1d6c6 <logobj_interface_setopt+0x56>
   1d6d6:	2100      	movs	r1, #0
   1d6d8:	a803      	add	r0, sp, #12
   1d6da:	f7ff fd3f 	bl	1d15c <rpc_logobj_client_request_alloc>
   1d6de:	4605      	mov	r5, r0
   1d6e0:	2800      	cmp	r0, #0
   1d6e2:	d16a      	bne.n	1d7ba <logobj_interface_setopt+0x14a>
   1d6e4:	9803      	ldr	r0, [sp, #12]
   1d6e6:	2208      	movs	r2, #8
   1d6e8:	4629      	mov	r1, r5
   1d6ea:	300c      	adds	r0, #12
   1d6ec:	f011 fe52 	bl	2f394 <memset>
   1d6f0:	9803      	ldr	r0, [sp, #12]
   1d6f2:	4631      	mov	r1, r6
   1d6f4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1d6f6:	300c      	adds	r0, #12
   1d6f8:	f011 fe2c 	bl	2f354 <memcpy>
   1d6fc:	2308      	movs	r3, #8
   1d6fe:	9803      	ldr	r0, [sp, #12]
   1d700:	f247 0102 	movw	r1, #28674	; 0x7002
   1d704:	7203      	strb	r3, [r0, #8]
   1d706:	7245      	strb	r5, [r0, #9]
   1d708:	7285      	strb	r5, [r0, #10]
   1d70a:	72c5      	strb	r5, [r0, #11]
   1d70c:	6823      	ldr	r3, [r4, #0]
   1d70e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   1d712:	6023      	str	r3, [r4, #0]
   1d714:	f7ff fd3a 	bl	1d18c <rpc_logobj_client_request_send>
   1d718:	2800      	cmp	r0, #0
   1d71a:	d151      	bne.n	1d7c0 <logobj_interface_setopt+0x150>
   1d71c:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   1d720:	f04f 33ff 	mov.w	r3, #4294967295
   1d724:	4611      	mov	r1, r2
   1d726:	4638      	mov	r0, r7
   1d728:	f005 ff36 	bl	23598 <interface_socket_wait>
   1d72c:	4605      	mov	r5, r0
   1d72e:	2800      	cmp	r0, #0
   1d730:	d13b      	bne.n	1d7aa <logobj_interface_setopt+0x13a>
   1d732:	4638      	mov	r0, r7
   1d734:	f005 ffa4 	bl	23680 <interface_socket_from_handle_get>
   1d738:	2800      	cmp	r0, #0
   1d73a:	d04f      	beq.n	1d7dc <logobj_interface_setopt+0x16c>
   1d73c:	6843      	ldr	r3, [r0, #4]
   1d73e:	2b00      	cmp	r3, #0
   1d740:	d04c      	beq.n	1d7dc <logobj_interface_setopt+0x16c>
   1d742:	2200      	movs	r2, #0
   1d744:	461d      	mov	r5, r3
   1d746:	6042      	str	r2, [r0, #4]
   1d748:	e02f      	b.n	1d7aa <logobj_interface_setopt+0x13a>
   1d74a:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   1d74c:	9400      	str	r4, [sp, #0]
   1d74e:	f005 ffbf 	bl	236d0 <interface_socket_setopt>
   1d752:	4605      	mov	r5, r0
   1d754:	4628      	mov	r0, r5
   1d756:	b005      	add	sp, #20
   1d758:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d75a:	2100      	movs	r1, #0
   1d75c:	a803      	add	r0, sp, #12
   1d75e:	7835      	ldrb	r5, [r6, #0]
   1d760:	f7ff fcfc 	bl	1d15c <rpc_logobj_client_request_alloc>
   1d764:	bb48      	cbnz	r0, 1d7ba <logobj_interface_setopt+0x14a>
   1d766:	2d01      	cmp	r5, #1
   1d768:	bf08      	it	eq
   1d76a:	4b26      	ldreq	r3, [pc, #152]	; (1d804 <logobj_interface_setopt+0x194>)
   1d76c:	f04f 0204 	mov.w	r2, #4
   1d770:	bf08      	it	eq
   1d772:	701d      	strbeq	r5, [r3, #0]
   1d774:	2300      	movs	r3, #0
   1d776:	9803      	ldr	r0, [sp, #12]
   1d778:	f247 0101 	movw	r1, #28673	; 0x7001
   1d77c:	7243      	strb	r3, [r0, #9]
   1d77e:	60c5      	str	r5, [r0, #12]
   1d780:	7283      	strb	r3, [r0, #10]
   1d782:	72c3      	strb	r3, [r0, #11]
   1d784:	7202      	strb	r2, [r0, #8]
   1d786:	6823      	ldr	r3, [r4, #0]
   1d788:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   1d78c:	6023      	str	r3, [r4, #0]
   1d78e:	f7ff fcfd 	bl	1d18c <rpc_logobj_client_request_send>
   1d792:	4606      	mov	r6, r0
   1d794:	b9a0      	cbnz	r0, 1d7c0 <logobj_interface_setopt+0x150>
   1d796:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   1d79a:	f04f 33ff 	mov.w	r3, #4294967295
   1d79e:	4611      	mov	r1, r2
   1d7a0:	4638      	mov	r0, r7
   1d7a2:	f005 fef9 	bl	23598 <interface_socket_wait>
   1d7a6:	4605      	mov	r5, r0
   1d7a8:	b180      	cbz	r0, 1d7cc <logobj_interface_setopt+0x15c>
   1d7aa:	6823      	ldr	r3, [r4, #0]
   1d7ac:	e778      	b.n	1d6a0 <logobj_interface_setopt+0x30>
   1d7ae:	202a      	movs	r0, #42	; 0x2a
   1d7b0:	f7fd ffdc 	bl	1b76c <bsd_os_errno_set>
   1d7b4:	f04f 35ff 	mov.w	r5, #4294967295
   1d7b8:	e77e      	b.n	1d6b8 <logobj_interface_setopt+0x48>
   1d7ba:	6823      	ldr	r3, [r4, #0]
   1d7bc:	250c      	movs	r5, #12
   1d7be:	e76f      	b.n	1d6a0 <logobj_interface_setopt+0x30>
   1d7c0:	9803      	ldr	r0, [sp, #12]
   1d7c2:	f7ff fcf9 	bl	1d1b8 <rpc_logobj_client_message_free>
   1d7c6:	2505      	movs	r5, #5
   1d7c8:	6823      	ldr	r3, [r4, #0]
   1d7ca:	e769      	b.n	1d6a0 <logobj_interface_setopt+0x30>
   1d7cc:	4638      	mov	r0, r7
   1d7ce:	f005 ff57 	bl	23680 <interface_socket_from_handle_get>
   1d7d2:	b140      	cbz	r0, 1d7e6 <logobj_interface_setopt+0x176>
   1d7d4:	6845      	ldr	r5, [r0, #4]
   1d7d6:	b135      	cbz	r5, 1d7e6 <logobj_interface_setopt+0x176>
   1d7d8:	6046      	str	r6, [r0, #4]
   1d7da:	e7e6      	b.n	1d7aa <logobj_interface_setopt+0x13a>
   1d7dc:	4631      	mov	r1, r6
   1d7de:	2204      	movs	r2, #4
   1d7e0:	4809      	ldr	r0, [pc, #36]	; (1d808 <logobj_interface_setopt+0x198>)
   1d7e2:	f011 fdb7 	bl	2f354 <memcpy>
   1d7e6:	6823      	ldr	r3, [r4, #0]
   1d7e8:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   1d7ec:	6023      	str	r3, [r4, #0]
   1d7ee:	6823      	ldr	r3, [r4, #0]
   1d7f0:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   1d7f4:	6023      	str	r3, [r4, #0]
   1d7f6:	e75f      	b.n	1d6b8 <logobj_interface_setopt+0x48>
   1d7f8:	2009      	movs	r0, #9
   1d7fa:	f7fd ffb7 	bl	1b76c <bsd_os_errno_set>
   1d7fe:	f04f 35ff 	mov.w	r5, #4294967295
   1d802:	e759      	b.n	1d6b8 <logobj_interface_setopt+0x48>
   1d804:	200314b6 	.word	0x200314b6
   1d808:	200289bc 	.word	0x200289bc

0001d80c <logobj_interface_getopt>:
   1d80c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1d80e:	2901      	cmp	r1, #1
   1d810:	b083      	sub	sp, #12
   1d812:	9e08      	ldr	r6, [sp, #32]
   1d814:	d030      	beq.n	1d878 <logobj_interface_getopt+0x6c>
   1d816:	461f      	mov	r7, r3
   1d818:	f240 2305 	movw	r3, #517	; 0x205
   1d81c:	4299      	cmp	r1, r3
   1d81e:	d134      	bne.n	1d88a <logobj_interface_getopt+0x7e>
   1d820:	4615      	mov	r5, r2
   1d822:	f005 ff2d 	bl	23680 <interface_socket_from_handle_get>
   1d826:	2800      	cmp	r0, #0
   1d828:	d037      	beq.n	1d89a <logobj_interface_getopt+0x8e>
   1d82a:	2d01      	cmp	r5, #1
   1d82c:	d015      	beq.n	1d85a <logobj_interface_getopt+0x4e>
   1d82e:	2d02      	cmp	r5, #2
   1d830:	d10b      	bne.n	1d84a <logobj_interface_getopt+0x3e>
   1d832:	b387      	cbz	r7, 1d896 <logobj_interface_getopt+0x8a>
   1d834:	6833      	ldr	r3, [r6, #0]
   1d836:	b373      	cbz	r3, 1d896 <logobj_interface_getopt+0x8a>
   1d838:	2300      	movs	r3, #0
   1d83a:	2201      	movs	r2, #1
   1d83c:	4618      	mov	r0, r3
   1d83e:	491a      	ldr	r1, [pc, #104]	; (1d8a8 <logobj_interface_getopt+0x9c>)
   1d840:	7809      	ldrb	r1, [r1, #0]
   1d842:	7039      	strb	r1, [r7, #0]
   1d844:	6032      	str	r2, [r6, #0]
   1d846:	b003      	add	sp, #12
   1d848:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d84a:	2009      	movs	r0, #9
   1d84c:	f7fd ff8e 	bl	1b76c <bsd_os_errno_set>
   1d850:	f04f 33ff 	mov.w	r3, #4294967295
   1d854:	4618      	mov	r0, r3
   1d856:	b003      	add	sp, #12
   1d858:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d85a:	b1e7      	cbz	r7, 1d896 <logobj_interface_getopt+0x8a>
   1d85c:	6833      	ldr	r3, [r6, #0]
   1d85e:	2b03      	cmp	r3, #3
   1d860:	d919      	bls.n	1d896 <logobj_interface_getopt+0x8a>
   1d862:	4638      	mov	r0, r7
   1d864:	2204      	movs	r2, #4
   1d866:	4911      	ldr	r1, [pc, #68]	; (1d8ac <logobj_interface_getopt+0xa0>)
   1d868:	f011 fd74 	bl	2f354 <memcpy>
   1d86c:	2300      	movs	r3, #0
   1d86e:	2204      	movs	r2, #4
   1d870:	4618      	mov	r0, r3
   1d872:	6032      	str	r2, [r6, #0]
   1d874:	b003      	add	sp, #12
   1d876:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d878:	9600      	str	r6, [sp, #0]
   1d87a:	f005 ff6b 	bl	23754 <interface_socket_getopt>
   1d87e:	4603      	mov	r3, r0
   1d880:	2800      	cmp	r0, #0
   1d882:	d1e3      	bne.n	1d84c <logobj_interface_getopt+0x40>
   1d884:	4618      	mov	r0, r3
   1d886:	b003      	add	sp, #12
   1d888:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1d88a:	202a      	movs	r0, #42	; 0x2a
   1d88c:	f7fd ff6e 	bl	1b76c <bsd_os_errno_set>
   1d890:	f04f 33ff 	mov.w	r3, #4294967295
   1d894:	e7de      	b.n	1d854 <logobj_interface_getopt+0x48>
   1d896:	2016      	movs	r0, #22
   1d898:	e7d8      	b.n	1d84c <logobj_interface_getopt+0x40>
   1d89a:	2009      	movs	r0, #9
   1d89c:	f7fd ff66 	bl	1b76c <bsd_os_errno_set>
   1d8a0:	f04f 33ff 	mov.w	r3, #4294967295
   1d8a4:	e7d6      	b.n	1d854 <logobj_interface_getopt+0x48>
   1d8a6:	bf00      	nop
   1d8a8:	200314b7 	.word	0x200314b7
   1d8ac:	200289bc 	.word	0x200289bc

0001d8b0 <logobj_interface_close>:
   1d8b0:	b510      	push	{r4, lr}
   1d8b2:	4604      	mov	r4, r0
   1d8b4:	f005 fee4 	bl	23680 <interface_socket_from_handle_get>
   1d8b8:	b138      	cbz	r0, 1d8ca <logobj_interface_close+0x1a>
   1d8ba:	4620      	mov	r0, r4
   1d8bc:	f005 fe1e 	bl	234fc <interface_socket_free>
   1d8c0:	2300      	movs	r3, #0
   1d8c2:	4a05      	ldr	r2, [pc, #20]	; (1d8d8 <logobj_interface_close+0x28>)
   1d8c4:	4618      	mov	r0, r3
   1d8c6:	6013      	str	r3, [r2, #0]
   1d8c8:	bd10      	pop	{r4, pc}
   1d8ca:	2009      	movs	r0, #9
   1d8cc:	f7fd ff4e 	bl	1b76c <bsd_os_errno_set>
   1d8d0:	f04f 30ff 	mov.w	r0, #4294967295
   1d8d4:	bd10      	pop	{r4, pc}
   1d8d6:	bf00      	nop
   1d8d8:	200289c0 	.word	0x200289c0

0001d8dc <packet_free_cb>:
   1d8dc:	6800      	ldr	r0, [r0, #0]
   1d8de:	f004 b9f1 	b.w	21cc4 <rpc_at_client_data_free>
   1d8e2:	bf00      	nop

0001d8e4 <at_interface_write>:
   1d8e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d8e8:	b082      	sub	sp, #8
   1d8ea:	9c08      	ldr	r4, [sp, #32]
   1d8ec:	2c00      	cmp	r4, #0
   1d8ee:	d15b      	bne.n	1d9a8 <at_interface_write+0xc4>
   1d8f0:	460f      	mov	r7, r1
   1d8f2:	4615      	mov	r5, r2
   1d8f4:	4698      	mov	r8, r3
   1d8f6:	4606      	mov	r6, r0
   1d8f8:	f005 fec2 	bl	23680 <interface_socket_from_handle_get>
   1d8fc:	4604      	mov	r4, r0
   1d8fe:	f1b8 0f00 	cmp.w	r8, #0
   1d902:	d12b      	bne.n	1d95c <at_interface_write+0x78>
   1d904:	2800      	cmp	r0, #0
   1d906:	d055      	beq.n	1d9b4 <at_interface_write+0xd0>
   1d908:	6803      	ldr	r3, [r0, #0]
   1d90a:	039b      	lsls	r3, r3, #14
   1d90c:	d552      	bpl.n	1d9b4 <at_interface_write+0xd0>
   1d90e:	6803      	ldr	r3, [r0, #0]
   1d910:	4629      	mov	r1, r5
   1d912:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   1d916:	6003      	str	r3, [r0, #0]
   1d918:	6803      	ldr	r3, [r0, #0]
   1d91a:	a801      	add	r0, sp, #4
   1d91c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
   1d920:	6023      	str	r3, [r4, #0]
   1d922:	f004 f9a5 	bl	21c70 <rpc_at_client_request_alloc>
   1d926:	bb08      	cbnz	r0, 1d96c <at_interface_write+0x88>
   1d928:	2204      	movs	r2, #4
   1d92a:	9b01      	ldr	r3, [sp, #4]
   1d92c:	721a      	strb	r2, [r3, #8]
   1d92e:	7258      	strb	r0, [r3, #9]
   1d930:	7298      	strb	r0, [r3, #10]
   1d932:	72d8      	strb	r0, [r3, #11]
   1d934:	60de      	str	r6, [r3, #12]
   1d936:	b9fd      	cbnz	r5, 1d978 <at_interface_write+0x94>
   1d938:	4618      	mov	r0, r3
   1d93a:	2101      	movs	r1, #1
   1d93c:	f004 f9ac 	bl	21c98 <rpc_at_client_request_send>
   1d940:	bb48      	cbnz	r0, 1d996 <at_interface_write+0xb2>
   1d942:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   1d946:	4630      	mov	r0, r6
   1d948:	4611      	mov	r1, r2
   1d94a:	f04f 33ff 	mov.w	r3, #4294967295
   1d94e:	f005 fe23 	bl	23598 <interface_socket_wait>
   1d952:	b960      	cbnz	r0, 1d96e <at_interface_write+0x8a>
   1d954:	4628      	mov	r0, r5
   1d956:	b002      	add	sp, #8
   1d958:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1d95c:	b360      	cbz	r0, 1d9b8 <at_interface_write+0xd4>
   1d95e:	6803      	ldr	r3, [r0, #0]
   1d960:	202d      	movs	r0, #45	; 0x2d
   1d962:	f7fd ff03 	bl	1b76c <bsd_os_errno_set>
   1d966:	f04f 30ff 	mov.w	r0, #4294967295
   1d96a:	e7f4      	b.n	1d956 <at_interface_write+0x72>
   1d96c:	200c      	movs	r0, #12
   1d96e:	6823      	ldr	r3, [r4, #0]
   1d970:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1d974:	6023      	str	r3, [r4, #0]
   1d976:	e7f4      	b.n	1d962 <at_interface_write+0x7e>
   1d978:	4639      	mov	r1, r7
   1d97a:	6818      	ldr	r0, [r3, #0]
   1d97c:	462a      	mov	r2, r5
   1d97e:	f011 fce9 	bl	2f354 <memcpy>
   1d982:	2101      	movs	r1, #1
   1d984:	9801      	ldr	r0, [sp, #4]
   1d986:	f004 f987 	bl	21c98 <rpc_at_client_request_send>
   1d98a:	2800      	cmp	r0, #0
   1d98c:	d0d9      	beq.n	1d942 <at_interface_write+0x5e>
   1d98e:	9b01      	ldr	r3, [sp, #4]
   1d990:	6818      	ldr	r0, [r3, #0]
   1d992:	f004 f997 	bl	21cc4 <rpc_at_client_data_free>
   1d996:	9801      	ldr	r0, [sp, #4]
   1d998:	f004 f98c 	bl	21cb4 <rpc_at_client_message_free>
   1d99c:	6823      	ldr	r3, [r4, #0]
   1d99e:	2023      	movs	r0, #35	; 0x23
   1d9a0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1d9a4:	6023      	str	r3, [r4, #0]
   1d9a6:	e7dc      	b.n	1d962 <at_interface_write+0x7e>
   1d9a8:	2038      	movs	r0, #56	; 0x38
   1d9aa:	f7fd fedf 	bl	1b76c <bsd_os_errno_set>
   1d9ae:	f04f 30ff 	mov.w	r0, #4294967295
   1d9b2:	e7d0      	b.n	1d956 <at_interface_write+0x72>
   1d9b4:	2016      	movs	r0, #22
   1d9b6:	e7d4      	b.n	1d962 <at_interface_write+0x7e>
   1d9b8:	202d      	movs	r0, #45	; 0x2d
   1d9ba:	e7d2      	b.n	1d962 <at_interface_write+0x7e>

0001d9bc <at_interface_init>:
   1d9bc:	f004 b952 	b.w	21c64 <rpc_at_client_init>

0001d9c0 <at_interface_open>:
   1d9c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d9c4:	2600      	movs	r6, #0
   1d9c6:	b082      	sub	sp, #8
   1d9c8:	2902      	cmp	r1, #2
   1d9ca:	9600      	str	r6, [sp, #0]
   1d9cc:	d13e      	bne.n	1da4c <at_interface_open+0x8c>
   1d9ce:	4680      	mov	r8, r0
   1d9d0:	4617      	mov	r7, r2
   1d9d2:	4668      	mov	r0, sp
   1d9d4:	4a20      	ldr	r2, [pc, #128]	; (1da58 <at_interface_open+0x98>)
   1d9d6:	460c      	mov	r4, r1
   1d9d8:	f005 fd2c 	bl	23434 <interface_socket_allocate>
   1d9dc:	9b00      	ldr	r3, [sp, #0]
   1d9de:	4605      	mov	r5, r0
   1d9e0:	b30b      	cbz	r3, 1da26 <at_interface_open+0x66>
   1d9e2:	e9c3 8403 	strd	r8, r4, [r3, #12]
   1d9e6:	615f      	str	r7, [r3, #20]
   1d9e8:	4631      	mov	r1, r6
   1d9ea:	a801      	add	r0, sp, #4
   1d9ec:	f004 f940 	bl	21c70 <rpc_at_client_request_alloc>
   1d9f0:	bb50      	cbnz	r0, 1da48 <at_interface_open+0x88>
   1d9f2:	2204      	movs	r2, #4
   1d9f4:	9b01      	ldr	r3, [sp, #4]
   1d9f6:	2105      	movs	r1, #5
   1d9f8:	7258      	strb	r0, [r3, #9]
   1d9fa:	7298      	strb	r0, [r3, #10]
   1d9fc:	72d8      	strb	r0, [r3, #11]
   1d9fe:	721a      	strb	r2, [r3, #8]
   1da00:	60dd      	str	r5, [r3, #12]
   1da02:	4618      	mov	r0, r3
   1da04:	f004 f948 	bl	21c98 <rpc_at_client_request_send>
   1da08:	b988      	cbnz	r0, 1da2e <at_interface_open+0x6e>
   1da0a:	4622      	mov	r2, r4
   1da0c:	4621      	mov	r1, r4
   1da0e:	f04f 33ff 	mov.w	r3, #4294967295
   1da12:	4628      	mov	r0, r5
   1da14:	f005 fdc0 	bl	23598 <interface_socket_wait>
   1da18:	4604      	mov	r4, r0
   1da1a:	b960      	cbnz	r0, 1da36 <at_interface_open+0x76>
   1da1c:	9a00      	ldr	r2, [sp, #0]
   1da1e:	6813      	ldr	r3, [r2, #0]
   1da20:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1da24:	6013      	str	r3, [r2, #0]
   1da26:	4628      	mov	r0, r5
   1da28:	b002      	add	sp, #8
   1da2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1da2e:	9801      	ldr	r0, [sp, #4]
   1da30:	f004 f940 	bl	21cb4 <rpc_at_client_message_free>
   1da34:	2423      	movs	r4, #35	; 0x23
   1da36:	4628      	mov	r0, r5
   1da38:	f005 fd60 	bl	234fc <interface_socket_free>
   1da3c:	4620      	mov	r0, r4
   1da3e:	f7fd fe95 	bl	1b76c <bsd_os_errno_set>
   1da42:	f04f 35ff 	mov.w	r5, #4294967295
   1da46:	e7ee      	b.n	1da26 <at_interface_open+0x66>
   1da48:	240c      	movs	r4, #12
   1da4a:	e7f4      	b.n	1da36 <at_interface_open+0x76>
   1da4c:	2029      	movs	r0, #41	; 0x29
   1da4e:	f7fd fe8d 	bl	1b76c <bsd_os_errno_set>
   1da52:	f04f 35ff 	mov.w	r5, #4294967295
   1da56:	e7e6      	b.n	1da26 <at_interface_open+0x66>
   1da58:	0001d8dd 	.word	0x0001d8dd

0001da5c <at_interface_close>:
   1da5c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1da5e:	b083      	sub	sp, #12
   1da60:	4606      	mov	r6, r0
   1da62:	f005 fe0d 	bl	23680 <interface_socket_from_handle_get>
   1da66:	2800      	cmp	r0, #0
   1da68:	d03d      	beq.n	1dae6 <at_interface_close+0x8a>
   1da6a:	230d      	movs	r3, #13
   1da6c:	6807      	ldr	r7, [r0, #0]
   1da6e:	6003      	str	r3, [r0, #0]
   1da70:	6803      	ldr	r3, [r0, #0]
   1da72:	4604      	mov	r4, r0
   1da74:	039b      	lsls	r3, r3, #14
   1da76:	d41f      	bmi.n	1dab8 <at_interface_close+0x5c>
   1da78:	2100      	movs	r1, #0
   1da7a:	a801      	add	r0, sp, #4
   1da7c:	f004 f8f8 	bl	21c70 <rpc_at_client_request_alloc>
   1da80:	bb20      	cbnz	r0, 1dacc <at_interface_close+0x70>
   1da82:	2204      	movs	r2, #4
   1da84:	9b01      	ldr	r3, [sp, #4]
   1da86:	2106      	movs	r1, #6
   1da88:	7258      	strb	r0, [r3, #9]
   1da8a:	7298      	strb	r0, [r3, #10]
   1da8c:	72d8      	strb	r0, [r3, #11]
   1da8e:	721a      	strb	r2, [r3, #8]
   1da90:	60de      	str	r6, [r3, #12]
   1da92:	4618      	mov	r0, r3
   1da94:	f004 f900 	bl	21c98 <rpc_at_client_request_send>
   1da98:	b9d0      	cbnz	r0, 1dad0 <at_interface_close+0x74>
   1da9a:	220e      	movs	r2, #14
   1da9c:	f04f 33ff 	mov.w	r3, #4294967295
   1daa0:	4611      	mov	r1, r2
   1daa2:	4630      	mov	r0, r6
   1daa4:	f005 fd78 	bl	23598 <interface_socket_wait>
   1daa8:	4605      	mov	r5, r0
   1daaa:	b9a8      	cbnz	r0, 1dad8 <at_interface_close+0x7c>
   1daac:	4630      	mov	r0, r6
   1daae:	f005 fd25 	bl	234fc <interface_socket_free>
   1dab2:	4628      	mov	r0, r5
   1dab4:	b003      	add	sp, #12
   1dab6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1dab8:	6803      	ldr	r3, [r0, #0]
   1daba:	2100      	movs	r1, #0
   1dabc:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   1dac0:	6003      	str	r3, [r0, #0]
   1dac2:	a801      	add	r0, sp, #4
   1dac4:	f004 f8d4 	bl	21c70 <rpc_at_client_request_alloc>
   1dac8:	2800      	cmp	r0, #0
   1daca:	d0da      	beq.n	1da82 <at_interface_close+0x26>
   1dacc:	250c      	movs	r5, #12
   1dace:	e003      	b.n	1dad8 <at_interface_close+0x7c>
   1dad0:	9801      	ldr	r0, [sp, #4]
   1dad2:	f004 f8ef 	bl	21cb4 <rpc_at_client_message_free>
   1dad6:	2523      	movs	r5, #35	; 0x23
   1dad8:	6027      	str	r7, [r4, #0]
   1dada:	4628      	mov	r0, r5
   1dadc:	f7fd fe46 	bl	1b76c <bsd_os_errno_set>
   1dae0:	f04f 35ff 	mov.w	r5, #4294967295
   1dae4:	e7e5      	b.n	1dab2 <at_interface_close+0x56>
   1dae6:	2516      	movs	r5, #22
   1dae8:	e7f7      	b.n	1dada <at_interface_close+0x7e>
   1daea:	bf00      	nop

0001daec <at_interface_read>:
   1daec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1daf0:	b084      	sub	sp, #16
   1daf2:	4688      	mov	r8, r1
   1daf4:	4615      	mov	r5, r2
   1daf6:	461e      	mov	r6, r3
   1daf8:	4607      	mov	r7, r0
   1dafa:	f005 fdc1 	bl	23680 <interface_socket_from_handle_get>
   1dafe:	2800      	cmp	r0, #0
   1db00:	d043      	beq.n	1db8a <at_interface_read+0x9e>
   1db02:	2300      	movs	r3, #0
   1db04:	4604      	mov	r4, r0
   1db06:	e9cd 8500 	strd	r8, r5, [sp]
   1db0a:	e9cd 3302 	strd	r3, r3, [sp, #8]
   1db0e:	bb2e      	cbnz	r6, 1db5c <at_interface_read+0x70>
   1db10:	f016 0502 	ands.w	r5, r6, #2
   1db14:	d00d      	beq.n	1db32 <at_interface_read+0x46>
   1db16:	e028      	b.n	1db6a <at_interface_read+0x7e>
   1db18:	b9cd      	cbnz	r5, 1db4e <at_interface_read+0x62>
   1db1a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   1db1e:	6a23      	ldr	r3, [r4, #32]
   1db20:	4611      	mov	r1, r2
   1db22:	2b00      	cmp	r3, #0
   1db24:	bf08      	it	eq
   1db26:	f04f 33ff 	moveq.w	r3, #4294967295
   1db2a:	4638      	mov	r0, r7
   1db2c:	f005 fd34 	bl	23598 <interface_socket_wait>
   1db30:	4605      	mov	r5, r0
   1db32:	6823      	ldr	r3, [r4, #0]
   1db34:	69e0      	ldr	r0, [r4, #28]
   1db36:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   1db3a:	6023      	str	r3, [r4, #0]
   1db3c:	6803      	ldr	r3, [r0, #0]
   1db3e:	4632      	mov	r2, r6
   1db40:	689b      	ldr	r3, [r3, #8]
   1db42:	4669      	mov	r1, sp
   1db44:	4798      	blx	r3
   1db46:	f1b0 0800 	subs.w	r8, r0, #0
   1db4a:	dbe5      	blt.n	1db18 <at_interface_read+0x2c>
   1db4c:	b115      	cbz	r5, 1db54 <at_interface_read+0x68>
   1db4e:	4628      	mov	r0, r5
   1db50:	f7fd fe0c 	bl	1b76c <bsd_os_errno_set>
   1db54:	4640      	mov	r0, r8
   1db56:	b004      	add	sp, #16
   1db58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1db5c:	f016 0f0a 	tst.w	r6, #10
   1db60:	d1d6      	bne.n	1db10 <at_interface_read+0x24>
   1db62:	252d      	movs	r5, #45	; 0x2d
   1db64:	f04f 38ff 	mov.w	r8, #4294967295
   1db68:	e7f1      	b.n	1db4e <at_interface_read+0x62>
   1db6a:	6823      	ldr	r3, [r4, #0]
   1db6c:	69e0      	ldr	r0, [r4, #28]
   1db6e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   1db72:	6023      	str	r3, [r4, #0]
   1db74:	6803      	ldr	r3, [r0, #0]
   1db76:	4632      	mov	r2, r6
   1db78:	689b      	ldr	r3, [r3, #8]
   1db7a:	4669      	mov	r1, sp
   1db7c:	4798      	blx	r3
   1db7e:	f1b0 3fff 	cmp.w	r0, #4294967295
   1db82:	4680      	mov	r8, r0
   1db84:	d1e6      	bne.n	1db54 <at_interface_read+0x68>
   1db86:	2523      	movs	r5, #35	; 0x23
   1db88:	e7e1      	b.n	1db4e <at_interface_read+0x62>
   1db8a:	2516      	movs	r5, #22
   1db8c:	f04f 38ff 	mov.w	r8, #4294967295
   1db90:	e7dd      	b.n	1db4e <at_interface_read+0x62>
   1db92:	bf00      	nop

0001db94 <at_interface_getopt>:
   1db94:	f005 bdde 	b.w	23754 <interface_socket_getopt>

0001db98 <at_interface_setopt>:
   1db98:	f005 bd9a 	b.w	236d0 <interface_socket_setopt>

0001db9c <rpc_at_event_handler>:
   1db9c:	b570      	push	{r4, r5, r6, lr}
   1db9e:	4606      	mov	r6, r0
   1dba0:	b084      	sub	sp, #16
   1dba2:	68c0      	ldr	r0, [r0, #12]
   1dba4:	460d      	mov	r5, r1
   1dba6:	f005 fd6b 	bl	23680 <interface_socket_from_handle_get>
   1dbaa:	4604      	mov	r4, r0
   1dbac:	b348      	cbz	r0, 1dc02 <rpc_at_event_handler+0x66>
   1dbae:	6803      	ldr	r3, [r0, #0]
   1dbb0:	b29b      	uxth	r3, r3
   1dbb2:	2b01      	cmp	r3, #1
   1dbb4:	d01f      	beq.n	1dbf6 <rpc_at_event_handler+0x5a>
   1dbb6:	6803      	ldr	r3, [r0, #0]
   1dbb8:	b29b      	uxth	r3, r3
   1dbba:	2b0d      	cmp	r3, #13
   1dbbc:	d029      	beq.n	1dc12 <rpc_at_event_handler+0x76>
   1dbbe:	6803      	ldr	r3, [r0, #0]
   1dbc0:	b29b      	uxth	r3, r3
   1dbc2:	2b02      	cmp	r3, #2
   1dbc4:	d02d      	beq.n	1dc22 <rpc_at_event_handler+0x86>
   1dbc6:	3d03      	subs	r5, #3
   1dbc8:	2d01      	cmp	r5, #1
   1dbca:	d817      	bhi.n	1dbfc <rpc_at_event_handler+0x60>
   1dbcc:	2500      	movs	r5, #0
   1dbce:	6873      	ldr	r3, [r6, #4]
   1dbd0:	6832      	ldr	r2, [r6, #0]
   1dbd2:	e9cd 5502 	strd	r5, r5, [sp, #8]
   1dbd6:	e9cd 2300 	strd	r2, r3, [sp]
   1dbda:	69e0      	ldr	r0, [r4, #28]
   1dbdc:	4669      	mov	r1, sp
   1dbde:	6803      	ldr	r3, [r0, #0]
   1dbe0:	685b      	ldr	r3, [r3, #4]
   1dbe2:	4798      	blx	r3
   1dbe4:	3001      	adds	r0, #1
   1dbe6:	d019      	beq.n	1dc1c <rpc_at_event_handler+0x80>
   1dbe8:	4628      	mov	r0, r5
   1dbea:	6823      	ldr	r3, [r4, #0]
   1dbec:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   1dbf0:	6023      	str	r3, [r4, #0]
   1dbf2:	b004      	add	sp, #16
   1dbf4:	bd70      	pop	{r4, r5, r6, pc}
   1dbf6:	2d02      	cmp	r5, #2
   1dbf8:	d1e5      	bne.n	1dbc6 <rpc_at_event_handler+0x2a>
   1dbfa:	6005      	str	r5, [r0, #0]
   1dbfc:	2000      	movs	r0, #0
   1dbfe:	b004      	add	sp, #16
   1dc00:	bd70      	pop	{r4, r5, r6, pc}
   1dc02:	6830      	ldr	r0, [r6, #0]
   1dc04:	2800      	cmp	r0, #0
   1dc06:	d0f9      	beq.n	1dbfc <rpc_at_event_handler+0x60>
   1dc08:	f004 f85c 	bl	21cc4 <rpc_at_client_data_free>
   1dc0c:	4620      	mov	r0, r4
   1dc0e:	b004      	add	sp, #16
   1dc10:	bd70      	pop	{r4, r5, r6, pc}
   1dc12:	2d02      	cmp	r5, #2
   1dc14:	d1d7      	bne.n	1dbc6 <rpc_at_event_handler+0x2a>
   1dc16:	230e      	movs	r3, #14
   1dc18:	6003      	str	r3, [r0, #0]
   1dc1a:	e7ef      	b.n	1dbfc <rpc_at_event_handler+0x60>
   1dc1c:	2002      	movs	r0, #2
   1dc1e:	b004      	add	sp, #16
   1dc20:	bd70      	pop	{r4, r5, r6, pc}
   1dc22:	6803      	ldr	r3, [r0, #0]
   1dc24:	029b      	lsls	r3, r3, #10
   1dc26:	d5ce      	bpl.n	1dbc6 <rpc_at_event_handler+0x2a>
   1dc28:	2d02      	cmp	r5, #2
   1dc2a:	d1cc      	bne.n	1dbc6 <rpc_at_event_handler+0x2a>
   1dc2c:	6803      	ldr	r3, [r0, #0]
   1dc2e:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   1dc32:	6003      	str	r3, [r0, #0]
   1dc34:	6803      	ldr	r3, [r0, #0]
   1dc36:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1dc3a:	6003      	str	r3, [r0, #0]
   1dc3c:	e7de      	b.n	1dbfc <rpc_at_event_handler+0x60>
   1dc3e:	bf00      	nop

0001dc40 <dfu_client_event_handler>:
   1dc40:	f850 1b08 	ldr.w	r1, [r0], #8
   1dc44:	0c09      	lsrs	r1, r1, #16
   1dc46:	f001 b925 	b.w	1ee94 <rpc_dfu_event_handler>
   1dc4a:	bf00      	nop

0001dc4c <rpc_dfu_client_init>:
   1dc4c:	4801      	ldr	r0, [pc, #4]	; (1dc54 <rpc_dfu_client_init+0x8>)
   1dc4e:	f005 be53 	b.w	238f8 <rpc_client_register>
   1dc52:	bf00      	nop
   1dc54:	00030b80 	.word	0x00030b80

0001dc58 <rpc_dfu_client_request_alloc>:
   1dc58:	2300      	movs	r3, #0
   1dc5a:	b510      	push	{r4, lr}
   1dc5c:	b082      	sub	sp, #8
   1dc5e:	9301      	str	r3, [sp, #4]
   1dc60:	b158      	cbz	r0, 1dc7a <rpc_dfu_client_request_alloc+0x22>
   1dc62:	4604      	mov	r4, r0
   1dc64:	aa01      	add	r2, sp, #4
   1dc66:	2006      	movs	r0, #6
   1dc68:	f006 f87e 	bl	23d68 <rpc_message_alloc>
   1dc6c:	b918      	cbnz	r0, 1dc76 <rpc_dfu_client_request_alloc+0x1e>
   1dc6e:	9b01      	ldr	r3, [sp, #4]
   1dc70:	b10b      	cbz	r3, 1dc76 <rpc_dfu_client_request_alloc+0x1e>
   1dc72:	3308      	adds	r3, #8
   1dc74:	6023      	str	r3, [r4, #0]
   1dc76:	b002      	add	sp, #8
   1dc78:	bd10      	pop	{r4, pc}
   1dc7a:	2007      	movs	r0, #7
   1dc7c:	b002      	add	sp, #8
   1dc7e:	bd10      	pop	{r4, pc}

0001dc80 <rpc_dfu_client_request_send>:
   1dc80:	f411 4f70 	tst.w	r1, #61440	; 0xf000
   1dc84:	d10b      	bne.n	1dc9e <rpc_dfu_client_request_send+0x1e>
   1dc86:	b160      	cbz	r0, 1dca2 <rpc_dfu_client_request_send+0x22>
   1dc88:	4603      	mov	r3, r0
   1dc8a:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   1dc8e:	2006      	movs	r0, #6
   1dc90:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   1dc94:	f843 1d08 	str.w	r1, [r3, #-8]!
   1dc98:	4619      	mov	r1, r3
   1dc9a:	f006 b84d 	b.w	23d38 <rpc_message_send>
   1dc9e:	200f      	movs	r0, #15
   1dca0:	4770      	bx	lr
   1dca2:	2007      	movs	r0, #7
   1dca4:	4770      	bx	lr
   1dca6:	bf00      	nop

0001dca8 <rpc_dfu_client_message_free>:
   1dca8:	b120      	cbz	r0, 1dcb4 <rpc_dfu_client_message_free+0xc>
   1dcaa:	f1a0 0108 	sub.w	r1, r0, #8
   1dcae:	2006      	movs	r0, #6
   1dcb0:	f006 b88c 	b.w	23dcc <rpc_message_free>
   1dcb4:	2007      	movs	r0, #7
   1dcb6:	4770      	bx	lr

0001dcb8 <rpc_dfu_client_data_free>:
   1dcb8:	b118      	cbz	r0, 1dcc2 <rpc_dfu_client_data_free+0xa>
   1dcba:	4601      	mov	r1, r0
   1dcbc:	2006      	movs	r0, #6
   1dcbe:	f006 b997 	b.w	23ff0 <rpc_message_data_free>
   1dcc2:	2007      	movs	r0, #7
   1dcc4:	4770      	bx	lr
   1dcc6:	bf00      	nop

0001dcc8 <mem_free>:
   1dcc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1dccc:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 1dd9c <mem_free+0xd4>
   1dcd0:	b083      	sub	sp, #12
   1dcd2:	9000      	str	r0, [sp, #0]
   1dcd4:	f10c 0b3c 	add.w	fp, ip, #60	; 0x3c
   1dcd8:	f8dc 3008 	ldr.w	r3, [ip, #8]
   1dcdc:	b12b      	cbz	r3, 1dcea <mem_free+0x22>
   1dcde:	f8dc 2000 	ldr.w	r2, [ip]
   1dce2:	9c00      	ldr	r4, [sp, #0]
   1dce4:	7810      	ldrb	r0, [r2, #0]
   1dce6:	42a0      	cmp	r0, r4
   1dce8:	d006      	beq.n	1dcf8 <mem_free+0x30>
   1dcea:	f10c 0c0c 	add.w	ip, ip, #12
   1dcee:	45e3      	cmp	fp, ip
   1dcf0:	d1f2      	bne.n	1dcd8 <mem_free+0x10>
   1dcf2:	b003      	add	sp, #12
   1dcf4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1dcf8:	f8dc a004 	ldr.w	sl, [ip, #4]
   1dcfc:	eb03 080a 	add.w	r8, r3, sl
   1dd00:	45c2      	cmp	sl, r8
   1dd02:	d2f2      	bcs.n	1dcea <mem_free+0x22>
   1dd04:	6853      	ldr	r3, [r2, #4]
   1dd06:	f8cd c004 	str.w	ip, [sp, #4]
   1dd0a:	46d6      	mov	lr, sl
   1dd0c:	469c      	mov	ip, r3
   1dd0e:	f8d2 9010 	ldr.w	r9, [r2, #16]
   1dd12:	8997      	ldrh	r7, [r2, #12]
   1dd14:	ebae 000a 	sub.w	r0, lr, sl
   1dd18:	b3df      	cbz	r7, 1dd92 <mem_free+0xca>
   1dd1a:	f8b9 2002 	ldrh.w	r2, [r9, #2]
   1dd1e:	4290      	cmp	r0, r2
   1dd20:	d31c      	bcc.n	1dd5c <mem_free+0x94>
   1dd22:	4665      	mov	r5, ip
   1dd24:	2400      	movs	r4, #0
   1dd26:	f109 0304 	add.w	r3, r9, #4
   1dd2a:	e003      	b.n	1dd34 <mem_free+0x6c>
   1dd2c:	885a      	ldrh	r2, [r3, #2]
   1dd2e:	3304      	adds	r3, #4
   1dd30:	4282      	cmp	r2, r0
   1dd32:	d815      	bhi.n	1dd60 <mem_free+0x98>
   1dd34:	f833 6c04 	ldrh.w	r6, [r3, #-4]
   1dd38:	3401      	adds	r4, #1
   1dd3a:	42a7      	cmp	r7, r4
   1dd3c:	fb02 5506 	mla	r5, r2, r6, r5
   1dd40:	eba0 0002 	sub.w	r0, r0, r2
   1dd44:	461e      	mov	r6, r3
   1dd46:	d1f1      	bne.n	1dd2c <mem_free+0x64>
   1dd48:	2000      	movs	r0, #0
   1dd4a:	4281      	cmp	r1, r0
   1dd4c:	d00d      	beq.n	1dd6a <mem_free+0xa2>
   1dd4e:	f10e 0e01 	add.w	lr, lr, #1
   1dd52:	45f0      	cmp	r8, lr
   1dd54:	d1de      	bne.n	1dd14 <mem_free+0x4c>
   1dd56:	f8dd c004 	ldr.w	ip, [sp, #4]
   1dd5a:	e7c6      	b.n	1dcea <mem_free+0x22>
   1dd5c:	4665      	mov	r5, ip
   1dd5e:	464e      	mov	r6, r9
   1dd60:	8833      	ldrh	r3, [r6, #0]
   1dd62:	fb00 5003 	mla	r0, r0, r3, r5
   1dd66:	4281      	cmp	r1, r0
   1dd68:	d1f1      	bne.n	1dd4e <mem_free+0x86>
   1dd6a:	f5be 7f00 	cmp.w	lr, #512	; 0x200
   1dd6e:	f8dd c004 	ldr.w	ip, [sp, #4]
   1dd72:	d0ba      	beq.n	1dcea <mem_free+0x22>
   1dd74:	2301      	movs	r3, #1
   1dd76:	4a08      	ldr	r2, [pc, #32]	; (1dd98 <mem_free+0xd0>)
   1dd78:	ea4f 115e 	mov.w	r1, lr, lsr #5
   1dd7c:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
   1dd80:	f00e 0e1f 	and.w	lr, lr, #31
   1dd84:	fa03 fe0e 	lsl.w	lr, r3, lr
   1dd88:	ea4e 0000 	orr.w	r0, lr, r0
   1dd8c:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
   1dd90:	e7af      	b.n	1dcf2 <mem_free+0x2a>
   1dd92:	4638      	mov	r0, r7
   1dd94:	e7d9      	b.n	1dd4a <mem_free+0x82>
   1dd96:	bf00      	nop
   1dd98:	200289c4 	.word	0x200289c4
   1dd9c:	20028a08 	.word	0x20028a08

0001dda0 <mem_alloc.constprop.5>:
   1dda0:	2800      	cmp	r0, #0
   1dda2:	d050      	beq.n	1de46 <mem_alloc.constprop.5+0xa6>
   1dda4:	4b6d      	ldr	r3, [pc, #436]	; (1df5c <mem_alloc.constprop.5+0x1bc>)
   1dda6:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   1ddaa:	4290      	cmp	r0, r2
   1ddac:	d84b      	bhi.n	1de46 <mem_alloc.constprop.5+0xa6>
   1ddae:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ddb2:	f8d3 b08c 	ldr.w	fp, [r3, #140]	; 0x8c
   1ddb6:	b083      	sub	sp, #12
   1ddb8:	f1bb 0f00 	cmp.w	fp, #0
   1ddbc:	d054      	beq.n	1de68 <mem_alloc.constprop.5+0xc8>
   1ddbe:	f10b 32ff 	add.w	r2, fp, #4294967295
   1ddc2:	4691      	mov	r9, r2
   1ddc4:	2600      	movs	r6, #0
   1ddc6:	f04f 0812 	mov.w	r8, #18
   1ddca:	4f65      	ldr	r7, [pc, #404]	; (1df60 <mem_alloc.constprop.5+0x1c0>)
   1ddcc:	9201      	str	r2, [sp, #4]
   1ddce:	f10b 0e11 	add.w	lr, fp, #17
   1ddd2:	eb06 0209 	add.w	r2, r6, r9
   1ddd6:	f853 4038 	ldr.w	r4, [r3, r8, lsl #3]
   1ddda:	3201      	adds	r2, #1
   1dddc:	0852      	lsrs	r2, r2, #1
   1ddde:	eb04 0c44 	add.w	ip, r4, r4, lsl #1
   1dde2:	f102 0112 	add.w	r1, r2, #18
   1dde6:	f853 5031 	ldr.w	r5, [r3, r1, lsl #3]
   1ddea:	f857 a02c 	ldr.w	sl, [r7, ip, lsl #2]
   1ddee:	f853 403e 	ldr.w	r4, [r3, lr, lsl #3]
   1ddf2:	eb03 0cc8 	add.w	ip, r3, r8, lsl #3
   1ddf6:	f8dc c004 	ldr.w	ip, [ip, #4]
   1ddfa:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   1ddfe:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   1de02:	f8da a010 	ldr.w	sl, [sl, #16]
   1de06:	f857 5025 	ldr.w	r5, [r7, r5, lsl #2]
   1de0a:	f857 4024 	ldr.w	r4, [r7, r4, lsl #2]
   1de0e:	f83a a02c 	ldrh.w	sl, [sl, ip, lsl #2]
   1de12:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   1de16:	eb03 0cce 	add.w	ip, r3, lr, lsl #3
   1de1a:	6849      	ldr	r1, [r1, #4]
   1de1c:	692d      	ldr	r5, [r5, #16]
   1de1e:	6924      	ldr	r4, [r4, #16]
   1de20:	f8dc c004 	ldr.w	ip, [ip, #4]
   1de24:	4550      	cmp	r0, sl
   1de26:	f835 5021 	ldrh.w	r5, [r5, r1, lsl #2]
   1de2a:	f834 102c 	ldrh.w	r1, [r4, ip, lsl #2]
   1de2e:	d915      	bls.n	1de5c <mem_alloc.constprop.5+0xbc>
   1de30:	4288      	cmp	r0, r1
   1de32:	d211      	bcs.n	1de58 <mem_alloc.constprop.5+0xb8>
   1de34:	42a8      	cmp	r0, r5
   1de36:	d908      	bls.n	1de4a <mem_alloc.constprop.5+0xaa>
   1de38:	1c56      	adds	r6, r2, #1
   1de3a:	45b1      	cmp	r9, r6
   1de3c:	f0c0 8087 	bcc.w	1df4e <mem_alloc.constprop.5+0x1ae>
   1de40:	f102 0813 	add.w	r8, r2, #19
   1de44:	e7c5      	b.n	1ddd2 <mem_alloc.constprop.5+0x32>
   1de46:	2000      	movs	r0, #0
   1de48:	4770      	bx	lr
   1de4a:	f102 39ff 	add.w	r9, r2, #4294967295
   1de4e:	454e      	cmp	r6, r9
   1de50:	d87d      	bhi.n	1df4e <mem_alloc.constprop.5+0x1ae>
   1de52:	f102 0e11 	add.w	lr, r2, #17
   1de56:	e7bc      	b.n	1ddd2 <mem_alloc.constprop.5+0x32>
   1de58:	f109 0601 	add.w	r6, r9, #1
   1de5c:	45b3      	cmp	fp, r6
   1de5e:	d007      	beq.n	1de70 <mem_alloc.constprop.5+0xd0>
   1de60:	2e10      	cmp	r6, #16
   1de62:	d001      	beq.n	1de68 <mem_alloc.constprop.5+0xc8>
   1de64:	45b3      	cmp	fp, r6
   1de66:	d808      	bhi.n	1de7a <mem_alloc.constprop.5+0xda>
   1de68:	2000      	movs	r0, #0
   1de6a:	b003      	add	sp, #12
   1de6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1de70:	9a01      	ldr	r2, [sp, #4]
   1de72:	2a10      	cmp	r2, #16
   1de74:	bf18      	it	ne
   1de76:	4616      	movne	r6, r2
   1de78:	d0f6      	beq.n	1de68 <mem_alloc.constprop.5+0xc8>
   1de7a:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 1df64 <mem_alloc.constprop.5+0x1c4>
   1de7e:	eb03 08c6 	add.w	r8, r3, r6, lsl #3
   1de82:	e9d8 2424 	ldrd	r2, r4, [r8, #144]	; 0x90
   1de86:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1de8a:	f857 3022 	ldr.w	r3, [r7, r2, lsl #2]
   1de8e:	eb07 0282 	add.w	r2, r7, r2, lsl #2
   1de92:	f8d2 e004 	ldr.w	lr, [r2, #4]
   1de96:	691d      	ldr	r5, [r3, #16]
   1de98:	2c00      	cmp	r4, #0
   1de9a:	d056      	beq.n	1df4a <mem_alloc.constprop.5+0x1aa>
   1de9c:	462a      	mov	r2, r5
   1de9e:	4670      	mov	r0, lr
   1dea0:	00a4      	lsls	r4, r4, #2
   1dea2:	eb05 0904 	add.w	r9, r5, r4
   1dea6:	8851      	ldrh	r1, [r2, #2]
   1dea8:	3204      	adds	r2, #4
   1deaa:	4591      	cmp	r9, r2
   1deac:	4408      	add	r0, r1
   1deae:	d1fa      	bne.n	1dea6 <mem_alloc.constprop.5+0x106>
   1deb0:	1929      	adds	r1, r5, r4
   1deb2:	f8b1 a002 	ldrh.w	sl, [r1, #2]
   1deb6:	4482      	add	sl, r0
   1deb8:	4582      	cmp	sl, r0
   1deba:	d918      	bls.n	1deee <mem_alloc.constprop.5+0x14e>
   1debc:	0941      	lsrs	r1, r0, #5
   1debe:	f85c 2021 	ldr.w	r2, [ip, r1, lsl #2]
   1dec2:	f000 041f 	and.w	r4, r0, #31
   1dec6:	fa22 f904 	lsr.w	r9, r2, r4
   1deca:	f019 0f01 	tst.w	r9, #1
   1dece:	d007      	beq.n	1dee0 <mem_alloc.constprop.5+0x140>
   1ded0:	e013      	b.n	1defa <mem_alloc.constprop.5+0x15a>
   1ded2:	f85c 2021 	ldr.w	r2, [ip, r1, lsl #2]
   1ded6:	fa22 f904 	lsr.w	r9, r2, r4
   1deda:	f019 0f01 	tst.w	r9, #1
   1dede:	d10c      	bne.n	1defa <mem_alloc.constprop.5+0x15a>
   1dee0:	3001      	adds	r0, #1
   1dee2:	4582      	cmp	sl, r0
   1dee4:	ea4f 1150 	mov.w	r1, r0, lsr #5
   1dee8:	f000 041f 	and.w	r4, r0, #31
   1deec:	d1f1      	bne.n	1ded2 <mem_alloc.constprop.5+0x132>
   1deee:	3601      	adds	r6, #1
   1def0:	455e      	cmp	r6, fp
   1def2:	f108 0808 	add.w	r8, r8, #8
   1def6:	d3c4      	bcc.n	1de82 <mem_alloc.constprop.5+0xe2>
   1def8:	e7b6      	b.n	1de68 <mem_alloc.constprop.5+0xc8>
   1defa:	2601      	movs	r6, #1
   1defc:	fa06 f404 	lsl.w	r4, r6, r4
   1df00:	899e      	ldrh	r6, [r3, #12]
   1df02:	ea22 0204 	bic.w	r2, r2, r4
   1df06:	eba0 000e 	sub.w	r0, r0, lr
   1df0a:	f84c 2021 	str.w	r2, [ip, r1, lsl #2]
   1df0e:	685c      	ldr	r4, [r3, #4]
   1df10:	2e00      	cmp	r6, #0
   1df12:	d0a9      	beq.n	1de68 <mem_alloc.constprop.5+0xc8>
   1df14:	886a      	ldrh	r2, [r5, #2]
   1df16:	4282      	cmp	r2, r0
   1df18:	d811      	bhi.n	1df3e <mem_alloc.constprop.5+0x19e>
   1df1a:	2100      	movs	r1, #0
   1df1c:	1d2b      	adds	r3, r5, #4
   1df1e:	e003      	b.n	1df28 <mem_alloc.constprop.5+0x188>
   1df20:	885a      	ldrh	r2, [r3, #2]
   1df22:	3304      	adds	r3, #4
   1df24:	4282      	cmp	r2, r0
   1df26:	d80a      	bhi.n	1df3e <mem_alloc.constprop.5+0x19e>
   1df28:	f833 5c04 	ldrh.w	r5, [r3, #-4]
   1df2c:	3101      	adds	r1, #1
   1df2e:	428e      	cmp	r6, r1
   1df30:	fb02 4405 	mla	r4, r2, r5, r4
   1df34:	eba0 0002 	sub.w	r0, r0, r2
   1df38:	461d      	mov	r5, r3
   1df3a:	d1f1      	bne.n	1df20 <mem_alloc.constprop.5+0x180>
   1df3c:	e794      	b.n	1de68 <mem_alloc.constprop.5+0xc8>
   1df3e:	882b      	ldrh	r3, [r5, #0]
   1df40:	fb00 4003 	mla	r0, r0, r3, r4
   1df44:	b003      	add	sp, #12
   1df46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1df4a:	4670      	mov	r0, lr
   1df4c:	e7b0      	b.n	1deb0 <mem_alloc.constprop.5+0x110>
   1df4e:	f1bb 0f10 	cmp.w	fp, #16
   1df52:	bf08      	it	eq
   1df54:	260f      	moveq	r6, #15
   1df56:	d090      	beq.n	1de7a <mem_alloc.constprop.5+0xda>
   1df58:	e786      	b.n	1de68 <mem_alloc.constprop.5+0xc8>
   1df5a:	bf00      	nop
   1df5c:	20028a44 	.word	0x20028a44
   1df60:	20028a08 	.word	0x20028a08
   1df64:	200289c4 	.word	0x200289c4

0001df68 <mem_alloc.constprop.4>:
   1df68:	2800      	cmp	r0, #0
   1df6a:	d04c      	beq.n	1e006 <mem_alloc.constprop.4+0x9e>
   1df6c:	4b6b      	ldr	r3, [pc, #428]	; (1e11c <mem_alloc.constprop.4+0x1b4>)
   1df6e:	681a      	ldr	r2, [r3, #0]
   1df70:	4290      	cmp	r0, r2
   1df72:	d848      	bhi.n	1e006 <mem_alloc.constprop.4+0x9e>
   1df74:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1df78:	685f      	ldr	r7, [r3, #4]
   1df7a:	b083      	sub	sp, #12
   1df7c:	9700      	str	r7, [sp, #0]
   1df7e:	2f00      	cmp	r7, #0
   1df80:	d051      	beq.n	1e026 <mem_alloc.constprop.4+0xbe>
   1df82:	1e7a      	subs	r2, r7, #1
   1df84:	4696      	mov	lr, r2
   1df86:	2100      	movs	r1, #0
   1df88:	f04f 0c01 	mov.w	ip, #1
   1df8c:	4c64      	ldr	r4, [pc, #400]	; (1e120 <mem_alloc.constprop.4+0x1b8>)
   1df8e:	9201      	str	r2, [sp, #4]
   1df90:	eb01 020e 	add.w	r2, r1, lr
   1df94:	3201      	adds	r2, #1
   1df96:	f853 503c 	ldr.w	r5, [r3, ip, lsl #3]
   1df9a:	0852      	lsrs	r2, r2, #1
   1df9c:	f102 0801 	add.w	r8, r2, #1
   1dfa0:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   1dfa4:	f853 9037 	ldr.w	r9, [r3, r7, lsl #3]
   1dfa8:	f854 a025 	ldr.w	sl, [r4, r5, lsl #2]
   1dfac:	f853 6038 	ldr.w	r6, [r3, r8, lsl #3]
   1dfb0:	eb09 0549 	add.w	r5, r9, r9, lsl #1
   1dfb4:	eb03 09cc 	add.w	r9, r3, ip, lsl #3
   1dfb8:	f8d9 9004 	ldr.w	r9, [r9, #4]
   1dfbc:	eb06 0646 	add.w	r6, r6, r6, lsl #1
   1dfc0:	f8da a010 	ldr.w	sl, [sl, #16]
   1dfc4:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
   1dfc8:	f854 5025 	ldr.w	r5, [r4, r5, lsl #2]
   1dfcc:	f83a a029 	ldrh.w	sl, [sl, r9, lsl #2]
   1dfd0:	eb03 0bc8 	add.w	fp, r3, r8, lsl #3
   1dfd4:	eb03 09c7 	add.w	r9, r3, r7, lsl #3
   1dfd8:	6936      	ldr	r6, [r6, #16]
   1dfda:	f8db b004 	ldr.w	fp, [fp, #4]
   1dfde:	692d      	ldr	r5, [r5, #16]
   1dfe0:	f8d9 9004 	ldr.w	r9, [r9, #4]
   1dfe4:	4550      	cmp	r0, sl
   1dfe6:	f836 602b 	ldrh.w	r6, [r6, fp, lsl #2]
   1dfea:	f835 5029 	ldrh.w	r5, [r5, r9, lsl #2]
   1dfee:	d913      	bls.n	1e018 <mem_alloc.constprop.4+0xb0>
   1dff0:	42a8      	cmp	r0, r5
   1dff2:	d210      	bcs.n	1e016 <mem_alloc.constprop.4+0xae>
   1dff4:	42b0      	cmp	r0, r6
   1dff6:	d908      	bls.n	1e00a <mem_alloc.constprop.4+0xa2>
   1dff8:	45c6      	cmp	lr, r8
   1dffa:	4641      	mov	r1, r8
   1dffc:	f0c0 8087 	bcc.w	1e10e <mem_alloc.constprop.4+0x1a6>
   1e000:	f108 0c01 	add.w	ip, r8, #1
   1e004:	e7c4      	b.n	1df90 <mem_alloc.constprop.4+0x28>
   1e006:	2000      	movs	r0, #0
   1e008:	4770      	bx	lr
   1e00a:	f102 3eff 	add.w	lr, r2, #4294967295
   1e00e:	4571      	cmp	r1, lr
   1e010:	d87d      	bhi.n	1e10e <mem_alloc.constprop.4+0x1a6>
   1e012:	4617      	mov	r7, r2
   1e014:	e7bc      	b.n	1df90 <mem_alloc.constprop.4+0x28>
   1e016:	4639      	mov	r1, r7
   1e018:	9a00      	ldr	r2, [sp, #0]
   1e01a:	428a      	cmp	r2, r1
   1e01c:	d007      	beq.n	1e02e <mem_alloc.constprop.4+0xc6>
   1e01e:	2910      	cmp	r1, #16
   1e020:	d001      	beq.n	1e026 <mem_alloc.constprop.4+0xbe>
   1e022:	428a      	cmp	r2, r1
   1e024:	d808      	bhi.n	1e038 <mem_alloc.constprop.4+0xd0>
   1e026:	2000      	movs	r0, #0
   1e028:	b003      	add	sp, #12
   1e02a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e02e:	9a01      	ldr	r2, [sp, #4]
   1e030:	2a10      	cmp	r2, #16
   1e032:	bf18      	it	ne
   1e034:	4611      	movne	r1, r2
   1e036:	d0f6      	beq.n	1e026 <mem_alloc.constprop.4+0xbe>
   1e038:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 1e124 <mem_alloc.constprop.4+0x1bc>
   1e03c:	f8dd 9000 	ldr.w	r9, [sp]
   1e040:	eb03 08c1 	add.w	r8, r3, r1, lsl #3
   1e044:	e9d8 2602 	ldrd	r2, r6, [r8, #8]
   1e048:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1e04c:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
   1e050:	eb04 0282 	add.w	r2, r4, r2, lsl #2
   1e054:	f8d2 e004 	ldr.w	lr, [r2, #4]
   1e058:	691f      	ldr	r7, [r3, #16]
   1e05a:	2e00      	cmp	r6, #0
   1e05c:	d055      	beq.n	1e10a <mem_alloc.constprop.4+0x1a2>
   1e05e:	463a      	mov	r2, r7
   1e060:	4670      	mov	r0, lr
   1e062:	00b6      	lsls	r6, r6, #2
   1e064:	eb07 0a06 	add.w	sl, r7, r6
   1e068:	8855      	ldrh	r5, [r2, #2]
   1e06a:	3204      	adds	r2, #4
   1e06c:	4592      	cmp	sl, r2
   1e06e:	4428      	add	r0, r5
   1e070:	d1fa      	bne.n	1e068 <mem_alloc.constprop.4+0x100>
   1e072:	19bd      	adds	r5, r7, r6
   1e074:	f8b5 b002 	ldrh.w	fp, [r5, #2]
   1e078:	4483      	add	fp, r0
   1e07a:	4583      	cmp	fp, r0
   1e07c:	d918      	bls.n	1e0b0 <mem_alloc.constprop.4+0x148>
   1e07e:	0945      	lsrs	r5, r0, #5
   1e080:	f85c 2025 	ldr.w	r2, [ip, r5, lsl #2]
   1e084:	f000 061f 	and.w	r6, r0, #31
   1e088:	fa22 fa06 	lsr.w	sl, r2, r6
   1e08c:	f01a 0f01 	tst.w	sl, #1
   1e090:	d007      	beq.n	1e0a2 <mem_alloc.constprop.4+0x13a>
   1e092:	e013      	b.n	1e0bc <mem_alloc.constprop.4+0x154>
   1e094:	f85c 2025 	ldr.w	r2, [ip, r5, lsl #2]
   1e098:	fa22 fa06 	lsr.w	sl, r2, r6
   1e09c:	f01a 0f01 	tst.w	sl, #1
   1e0a0:	d10c      	bne.n	1e0bc <mem_alloc.constprop.4+0x154>
   1e0a2:	3001      	adds	r0, #1
   1e0a4:	4583      	cmp	fp, r0
   1e0a6:	ea4f 1550 	mov.w	r5, r0, lsr #5
   1e0aa:	f000 061f 	and.w	r6, r0, #31
   1e0ae:	d1f1      	bne.n	1e094 <mem_alloc.constprop.4+0x12c>
   1e0b0:	3101      	adds	r1, #1
   1e0b2:	4549      	cmp	r1, r9
   1e0b4:	f108 0808 	add.w	r8, r8, #8
   1e0b8:	d3c4      	bcc.n	1e044 <mem_alloc.constprop.4+0xdc>
   1e0ba:	e7b4      	b.n	1e026 <mem_alloc.constprop.4+0xbe>
   1e0bc:	2101      	movs	r1, #1
   1e0be:	40b1      	lsls	r1, r6
   1e0c0:	899e      	ldrh	r6, [r3, #12]
   1e0c2:	ea22 0201 	bic.w	r2, r2, r1
   1e0c6:	eba0 000e 	sub.w	r0, r0, lr
   1e0ca:	f84c 2025 	str.w	r2, [ip, r5, lsl #2]
   1e0ce:	685c      	ldr	r4, [r3, #4]
   1e0d0:	2e00      	cmp	r6, #0
   1e0d2:	d0a8      	beq.n	1e026 <mem_alloc.constprop.4+0xbe>
   1e0d4:	887a      	ldrh	r2, [r7, #2]
   1e0d6:	4282      	cmp	r2, r0
   1e0d8:	d811      	bhi.n	1e0fe <mem_alloc.constprop.4+0x196>
   1e0da:	2100      	movs	r1, #0
   1e0dc:	1d3b      	adds	r3, r7, #4
   1e0de:	e003      	b.n	1e0e8 <mem_alloc.constprop.4+0x180>
   1e0e0:	885a      	ldrh	r2, [r3, #2]
   1e0e2:	3304      	adds	r3, #4
   1e0e4:	4282      	cmp	r2, r0
   1e0e6:	d80a      	bhi.n	1e0fe <mem_alloc.constprop.4+0x196>
   1e0e8:	f833 5c04 	ldrh.w	r5, [r3, #-4]
   1e0ec:	3101      	adds	r1, #1
   1e0ee:	428e      	cmp	r6, r1
   1e0f0:	eba0 0002 	sub.w	r0, r0, r2
   1e0f4:	fb02 4405 	mla	r4, r2, r5, r4
   1e0f8:	461f      	mov	r7, r3
   1e0fa:	d1f1      	bne.n	1e0e0 <mem_alloc.constprop.4+0x178>
   1e0fc:	e793      	b.n	1e026 <mem_alloc.constprop.4+0xbe>
   1e0fe:	883b      	ldrh	r3, [r7, #0]
   1e100:	fb00 4003 	mla	r0, r0, r3, r4
   1e104:	b003      	add	sp, #12
   1e106:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e10a:	4670      	mov	r0, lr
   1e10c:	e7b1      	b.n	1e072 <mem_alloc.constprop.4+0x10a>
   1e10e:	9a00      	ldr	r2, [sp, #0]
   1e110:	2a10      	cmp	r2, #16
   1e112:	bf08      	it	eq
   1e114:	210f      	moveq	r1, #15
   1e116:	d08f      	beq.n	1e038 <mem_alloc.constprop.4+0xd0>
   1e118:	e785      	b.n	1e026 <mem_alloc.constprop.4+0xbe>
   1e11a:	bf00      	nop
   1e11c:	20028a44 	.word	0x20028a44
   1e120:	20028a08 	.word	0x20028a08
   1e124:	200289c4 	.word	0x200289c4

0001e128 <nrf_mem_init>:
   1e128:	b570      	push	{r4, r5, r6, lr}
   1e12a:	2200      	movs	r2, #0
   1e12c:	2501      	movs	r5, #1
   1e12e:	4833      	ldr	r0, [pc, #204]	; (1e1fc <nrf_mem_init+0xd4>)
   1e130:	0951      	lsrs	r1, r2, #5
   1e132:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
   1e136:	f002 031f 	and.w	r3, r2, #31
   1e13a:	fa05 f303 	lsl.w	r3, r5, r3
   1e13e:	3201      	adds	r2, #1
   1e140:	4323      	orrs	r3, r4
   1e142:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   1e146:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
   1e14a:	d1f1      	bne.n	1e130 <nrf_mem_init+0x8>
   1e14c:	2400      	movs	r4, #0
   1e14e:	4b2c      	ldr	r3, [pc, #176]	; (1e200 <nrf_mem_init+0xd8>)
   1e150:	4621      	mov	r1, r4
   1e152:	223c      	movs	r2, #60	; 0x3c
   1e154:	482b      	ldr	r0, [pc, #172]	; (1e204 <nrf_mem_init+0xdc>)
   1e156:	601c      	str	r4, [r3, #0]
   1e158:	f011 f91c 	bl	2f394 <memset>
   1e15c:	2110      	movs	r1, #16
   1e15e:	2205      	movs	r2, #5
   1e160:	4b29      	ldr	r3, [pc, #164]	; (1e208 <nrf_mem_init+0xe0>)
   1e162:	4e2a      	ldr	r6, [pc, #168]	; (1e20c <nrf_mem_init+0xe4>)
   1e164:	e9c3 4400 	strd	r4, r4, [r3]
   1e168:	60d9      	str	r1, [r3, #12]
   1e16a:	6159      	str	r1, [r3, #20]
   1e16c:	61d9      	str	r1, [r3, #28]
   1e16e:	6259      	str	r1, [r3, #36]	; 0x24
   1e170:	62d9      	str	r1, [r3, #44]	; 0x2c
   1e172:	6359      	str	r1, [r3, #52]	; 0x34
   1e174:	63d9      	str	r1, [r3, #60]	; 0x3c
   1e176:	6459      	str	r1, [r3, #68]	; 0x44
   1e178:	64d9      	str	r1, [r3, #76]	; 0x4c
   1e17a:	6559      	str	r1, [r3, #84]	; 0x54
   1e17c:	65d9      	str	r1, [r3, #92]	; 0x5c
   1e17e:	6659      	str	r1, [r3, #100]	; 0x64
   1e180:	66d9      	str	r1, [r3, #108]	; 0x6c
   1e182:	6759      	str	r1, [r3, #116]	; 0x74
   1e184:	67d9      	str	r1, [r3, #124]	; 0x7c
   1e186:	609a      	str	r2, [r3, #8]
   1e188:	611a      	str	r2, [r3, #16]
   1e18a:	619a      	str	r2, [r3, #24]
   1e18c:	621a      	str	r2, [r3, #32]
   1e18e:	629a      	str	r2, [r3, #40]	; 0x28
   1e190:	631a      	str	r2, [r3, #48]	; 0x30
   1e192:	639a      	str	r2, [r3, #56]	; 0x38
   1e194:	641a      	str	r2, [r3, #64]	; 0x40
   1e196:	649a      	str	r2, [r3, #72]	; 0x48
   1e198:	651a      	str	r2, [r3, #80]	; 0x50
   1e19a:	659a      	str	r2, [r3, #88]	; 0x58
   1e19c:	661a      	str	r2, [r3, #96]	; 0x60
   1e19e:	669a      	str	r2, [r3, #104]	; 0x68
   1e1a0:	671a      	str	r2, [r3, #112]	; 0x70
   1e1a2:	679a      	str	r2, [r3, #120]	; 0x78
   1e1a4:	e9c3 2120 	strd	r2, r1, [r3, #128]	; 0x80
   1e1a8:	e9c3 4422 	strd	r4, r4, [r3, #136]	; 0x88
   1e1ac:	e9c3 2124 	strd	r2, r1, [r3, #144]	; 0x90
   1e1b0:	e9c3 2126 	strd	r2, r1, [r3, #152]	; 0x98
   1e1b4:	e9c3 2128 	strd	r2, r1, [r3, #160]	; 0xa0
   1e1b8:	e9c3 212a 	strd	r2, r1, [r3, #168]	; 0xa8
   1e1bc:	e9c3 212c 	strd	r2, r1, [r3, #176]	; 0xb0
   1e1c0:	e9c3 212e 	strd	r2, r1, [r3, #184]	; 0xb8
   1e1c4:	e9c3 2130 	strd	r2, r1, [r3, #192]	; 0xc0
   1e1c8:	e9c3 2132 	strd	r2, r1, [r3, #200]	; 0xc8
   1e1cc:	e9c3 2134 	strd	r2, r1, [r3, #208]	; 0xd0
   1e1d0:	e9c3 2136 	strd	r2, r1, [r3, #216]	; 0xd8
   1e1d4:	e9c3 2138 	strd	r2, r1, [r3, #224]	; 0xe0
   1e1d8:	e9c3 213a 	strd	r2, r1, [r3, #232]	; 0xe8
   1e1dc:	e9c3 213c 	strd	r2, r1, [r3, #240]	; 0xf0
   1e1e0:	e9c3 213e 	strd	r2, r1, [r3, #248]	; 0xf8
   1e1e4:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
   1e1e8:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   1e1ec:	f8c3 110c 	str.w	r1, [r3, #268]	; 0x10c
   1e1f0:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   1e1f4:	4620      	mov	r0, r4
   1e1f6:	7035      	strb	r5, [r6, #0]
   1e1f8:	bd70      	pop	{r4, r5, r6, pc}
   1e1fa:	bf00      	nop
   1e1fc:	200289c4 	.word	0x200289c4
   1e200:	20028a04 	.word	0x20028a04
   1e204:	20028a08 	.word	0x20028a08
   1e208:	20028a44 	.word	0x20028a44
   1e20c:	200314b8 	.word	0x200314b8

0001e210 <nrf_mem_register>:
   1e210:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1e214:	4b87      	ldr	r3, [pc, #540]	; (1e434 <nrf_mem_register+0x224>)
   1e216:	b087      	sub	sp, #28
   1e218:	781b      	ldrb	r3, [r3, #0]
   1e21a:	2b00      	cmp	r3, #0
   1e21c:	f000 808c 	beq.w	1e338 <nrf_mem_register+0x128>
   1e220:	b328      	cbz	r0, 1e26e <nrf_mem_register+0x5e>
   1e222:	b321      	cbz	r1, 1e26e <nrf_mem_register+0x5e>
   1e224:	780b      	ldrb	r3, [r1, #0]
   1e226:	f8df 8218 	ldr.w	r8, [pc, #536]	; 1e440 <nrf_mem_register+0x230>
   1e22a:	eb03 1303 	add.w	r3, r3, r3, lsl #4
   1e22e:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
   1e232:	685b      	ldr	r3, [r3, #4]
   1e234:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
   1e238:	4463      	add	r3, ip
   1e23a:	2b10      	cmp	r3, #16
   1e23c:	d811      	bhi.n	1e262 <nrf_mem_register+0x52>
   1e23e:	f04f 0a00 	mov.w	sl, #0
   1e242:	4689      	mov	r9, r1
   1e244:	4b7c      	ldr	r3, [pc, #496]	; (1e438 <nrf_mem_register+0x228>)
   1e246:	4f7d      	ldr	r7, [pc, #500]	; (1e43c <nrf_mem_register+0x22c>)
   1e248:	681b      	ldr	r3, [r3, #0]
   1e24a:	ea4f 0e8c 	mov.w	lr, ip, lsl #2
   1e24e:	9300      	str	r3, [sp, #0]
   1e250:	68b9      	ldr	r1, [r7, #8]
   1e252:	b191      	cbz	r1, 1e27a <nrf_mem_register+0x6a>
   1e254:	f10a 0a01 	add.w	sl, sl, #1
   1e258:	f1ba 0f05 	cmp.w	sl, #5
   1e25c:	f107 070c 	add.w	r7, r7, #12
   1e260:	d1f6      	bne.n	1e250 <nrf_mem_register+0x40>
   1e262:	f248 1b07 	movw	fp, #33031	; 0x8107
   1e266:	4658      	mov	r0, fp
   1e268:	b007      	add	sp, #28
   1e26a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e26e:	f248 1b0e 	movw	fp, #33038	; 0x810e
   1e272:	4658      	mov	r0, fp
   1e274:	b007      	add	sp, #28
   1e276:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e27a:	f1bc 0f00 	cmp.w	ip, #0
   1e27e:	d061      	beq.n	1e344 <nrf_mem_register+0x134>
   1e280:	460d      	mov	r5, r1
   1e282:	460c      	mov	r4, r1
   1e284:	f8d9 3010 	ldr.w	r3, [r9, #16]
   1e288:	eb0e 0b03 	add.w	fp, lr, r3
   1e28c:	885a      	ldrh	r2, [r3, #2]
   1e28e:	f833 6b04 	ldrh.w	r6, [r3], #4
   1e292:	4415      	add	r5, r2
   1e294:	459b      	cmp	fp, r3
   1e296:	fb02 4406 	mla	r4, r2, r6, r4
   1e29a:	d1f7      	bne.n	1e28c <nrf_mem_register+0x7c>
   1e29c:	f8d9 3008 	ldr.w	r3, [r9, #8]
   1e2a0:	42a3      	cmp	r3, r4
   1e2a2:	d3d7      	bcc.n	1e254 <nrf_mem_register+0x44>
   1e2a4:	9b00      	ldr	r3, [sp, #0]
   1e2a6:	442b      	add	r3, r5
   1e2a8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   1e2ac:	d2d2      	bcs.n	1e254 <nrf_mem_register+0x44>
   1e2ae:	4c63      	ldr	r4, [pc, #396]	; (1e43c <nrf_mem_register+0x22c>)
   1e2b0:	eb0a 024a 	add.w	r2, sl, sl, lsl #1
   1e2b4:	0092      	lsls	r2, r2, #2
   1e2b6:	f8c0 a000 	str.w	sl, [r0]
   1e2ba:	18a0      	adds	r0, r4, r2
   1e2bc:	f844 9002 	str.w	r9, [r4, r2]
   1e2c0:	9a00      	ldr	r2, [sp, #0]
   1e2c2:	468b      	mov	fp, r1
   1e2c4:	e9c0 2501 	strd	r2, r5, [r0, #4]
   1e2c8:	f899 2001 	ldrb.w	r2, [r9, #1]
   1e2cc:	485a      	ldr	r0, [pc, #360]	; (1e438 <nrf_mem_register+0x228>)
   1e2ce:	2a01      	cmp	r2, #1
   1e2d0:	6003      	str	r3, [r0, #0]
   1e2d2:	d0c8      	beq.n	1e266 <nrf_mem_register+0x56>
   1e2d4:	f8b9 300c 	ldrh.w	r3, [r9, #12]
   1e2d8:	2b00      	cmp	r3, #0
   1e2da:	d0c4      	beq.n	1e266 <nrf_mem_register+0x56>
   1e2dc:	2500      	movs	r5, #0
   1e2de:	f8cd 9004 	str.w	r9, [sp, #4]
   1e2e2:	f8cd a00c 	str.w	sl, [sp, #12]
   1e2e6:	f8cd b014 	str.w	fp, [sp, #20]
   1e2ea:	9b01      	ldr	r3, [sp, #4]
   1e2ec:	781f      	ldrb	r7, [r3, #0]
   1e2ee:	691a      	ldr	r2, [r3, #16]
   1e2f0:	013b      	lsls	r3, r7, #4
   1e2f2:	eb03 0907 	add.w	r9, r3, r7
   1e2f6:	9300      	str	r3, [sp, #0]
   1e2f8:	eb08 03c9 	add.w	r3, r8, r9, lsl #3
   1e2fc:	6859      	ldr	r1, [r3, #4]
   1e2fe:	f832 4025 	ldrh.w	r4, [r2, r5, lsl #2]
   1e302:	9102      	str	r1, [sp, #8]
   1e304:	bb39      	cbnz	r1, 1e356 <nrf_mem_register+0x146>
   1e306:	9a03      	ldr	r2, [sp, #12]
   1e308:	60dd      	str	r5, [r3, #12]
   1e30a:	609a      	str	r2, [r3, #8]
   1e30c:	9b00      	ldr	r3, [sp, #0]
   1e30e:	443b      	add	r3, r7
   1e310:	461f      	mov	r7, r3
   1e312:	eb08 01c3 	add.w	r1, r8, r3, lsl #3
   1e316:	684b      	ldr	r3, [r1, #4]
   1e318:	f858 2037 	ldr.w	r2, [r8, r7, lsl #3]
   1e31c:	3301      	adds	r3, #1
   1e31e:	4294      	cmp	r4, r2
   1e320:	604b      	str	r3, [r1, #4]
   1e322:	d912      	bls.n	1e34a <nrf_mem_register+0x13a>
   1e324:	9b01      	ldr	r3, [sp, #4]
   1e326:	f848 4037 	str.w	r4, [r8, r7, lsl #3]
   1e32a:	899b      	ldrh	r3, [r3, #12]
   1e32c:	3501      	adds	r5, #1
   1e32e:	429d      	cmp	r5, r3
   1e330:	d3db      	bcc.n	1e2ea <nrf_mem_register+0xda>
   1e332:	f8dd b014 	ldr.w	fp, [sp, #20]
   1e336:	e796      	b.n	1e266 <nrf_mem_register+0x56>
   1e338:	f248 1b08 	movw	fp, #33032	; 0x8108
   1e33c:	4658      	mov	r0, fp
   1e33e:	b007      	add	sp, #28
   1e340:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e344:	9b00      	ldr	r3, [sp, #0]
   1e346:	4665      	mov	r5, ip
   1e348:	e7ae      	b.n	1e2a8 <nrf_mem_register+0x98>
   1e34a:	9b01      	ldr	r3, [sp, #4]
   1e34c:	3501      	adds	r5, #1
   1e34e:	899b      	ldrh	r3, [r3, #12]
   1e350:	42ab      	cmp	r3, r5
   1e352:	d8ca      	bhi.n	1e2ea <nrf_mem_register+0xda>
   1e354:	e7ed      	b.n	1e332 <nrf_mem_register+0x122>
   1e356:	2600      	movs	r6, #0
   1e358:	f101 3aff 	add.w	sl, r1, #4294967295
   1e35c:	9504      	str	r5, [sp, #16]
   1e35e:	eb06 000a 	add.w	r0, r6, sl
   1e362:	eb09 0206 	add.w	r2, r9, r6
   1e366:	3201      	adds	r2, #1
   1e368:	3001      	adds	r0, #1
   1e36a:	f858 c032 	ldr.w	ip, [r8, r2, lsl #3]
   1e36e:	0840      	lsrs	r0, r0, #1
   1e370:	4d32      	ldr	r5, [pc, #200]	; (1e43c <nrf_mem_register+0x22c>)
   1e372:	eb09 0100 	add.w	r1, r9, r0
   1e376:	eb09 030a 	add.w	r3, r9, sl
   1e37a:	3101      	adds	r1, #1
   1e37c:	3301      	adds	r3, #1
   1e37e:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
   1e382:	f858 e031 	ldr.w	lr, [r8, r1, lsl #3]
   1e386:	f855 b02c 	ldr.w	fp, [r5, ip, lsl #2]
   1e38a:	f858 c033 	ldr.w	ip, [r8, r3, lsl #3]
   1e38e:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
   1e392:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
   1e396:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
   1e39a:	f8db b010 	ldr.w	fp, [fp, #16]
   1e39e:	6852      	ldr	r2, [r2, #4]
   1e3a0:	f855 e02e 	ldr.w	lr, [r5, lr, lsl #2]
   1e3a4:	f855 c02c 	ldr.w	ip, [r5, ip, lsl #2]
   1e3a8:	eb08 01c1 	add.w	r1, r8, r1, lsl #3
   1e3ac:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
   1e3b0:	f83b 2022 	ldrh.w	r2, [fp, r2, lsl #2]
   1e3b4:	f8de e010 	ldr.w	lr, [lr, #16]
   1e3b8:	6849      	ldr	r1, [r1, #4]
   1e3ba:	f8dc c010 	ldr.w	ip, [ip, #16]
   1e3be:	685b      	ldr	r3, [r3, #4]
   1e3c0:	4294      	cmp	r4, r2
   1e3c2:	f83e 1021 	ldrh.w	r1, [lr, r1, lsl #2]
   1e3c6:	f83c 3023 	ldrh.w	r3, [ip, r3, lsl #2]
   1e3ca:	d92d      	bls.n	1e428 <nrf_mem_register+0x218>
   1e3cc:	429c      	cmp	r4, r3
   1e3ce:	d22d      	bcs.n	1e42c <nrf_mem_register+0x21c>
   1e3d0:	428c      	cmp	r4, r1
   1e3d2:	d924      	bls.n	1e41e <nrf_mem_register+0x20e>
   1e3d4:	1c46      	adds	r6, r0, #1
   1e3d6:	45b2      	cmp	sl, r6
   1e3d8:	d2c1      	bcs.n	1e35e <nrf_mem_register+0x14e>
   1e3da:	2610      	movs	r6, #16
   1e3dc:	9d04      	ldr	r5, [sp, #16]
   1e3de:	9a02      	ldr	r2, [sp, #8]
   1e3e0:	42b2      	cmp	r2, r6
   1e3e2:	d911      	bls.n	1e408 <nrf_mem_register+0x1f8>
   1e3e4:	9b00      	ldr	r3, [sp, #0]
   1e3e6:	443b      	add	r3, r7
   1e3e8:	441a      	add	r2, r3
   1e3ea:	4433      	add	r3, r6
   1e3ec:	eb08 0ac2 	add.w	sl, r8, r2, lsl #3
   1e3f0:	eb08 09c3 	add.w	r9, r8, r3, lsl #3
   1e3f4:	2208      	movs	r2, #8
   1e3f6:	4651      	mov	r1, sl
   1e3f8:	eb0a 0002 	add.w	r0, sl, r2
   1e3fc:	f1aa 0a08 	sub.w	sl, sl, #8
   1e400:	f010 ffa8 	bl	2f354 <memcpy>
   1e404:	45d1      	cmp	r9, sl
   1e406:	d1f5      	bne.n	1e3f4 <nrf_mem_register+0x1e4>
   1e408:	9b00      	ldr	r3, [sp, #0]
   1e40a:	9903      	ldr	r1, [sp, #12]
   1e40c:	443b      	add	r3, r7
   1e40e:	4433      	add	r3, r6
   1e410:	3301      	adds	r3, #1
   1e412:	eb08 02c3 	add.w	r2, r8, r3, lsl #3
   1e416:	f848 1033 	str.w	r1, [r8, r3, lsl #3]
   1e41a:	6055      	str	r5, [r2, #4]
   1e41c:	e776      	b.n	1e30c <nrf_mem_register+0xfc>
   1e41e:	f100 3aff 	add.w	sl, r0, #4294967295
   1e422:	4556      	cmp	r6, sl
   1e424:	d99b      	bls.n	1e35e <nrf_mem_register+0x14e>
   1e426:	e7d8      	b.n	1e3da <nrf_mem_register+0x1ca>
   1e428:	9d04      	ldr	r5, [sp, #16]
   1e42a:	e7d8      	b.n	1e3de <nrf_mem_register+0x1ce>
   1e42c:	9d04      	ldr	r5, [sp, #16]
   1e42e:	f10a 0601 	add.w	r6, sl, #1
   1e432:	e7d4      	b.n	1e3de <nrf_mem_register+0x1ce>
   1e434:	200314b8 	.word	0x200314b8
   1e438:	20028a04 	.word	0x20028a04
   1e43c:	20028a08 	.word	0x20028a08
   1e440:	20028a44 	.word	0x20028a44

0001e444 <nrf_malloc>:
   1e444:	4b03      	ldr	r3, [pc, #12]	; (1e454 <nrf_malloc+0x10>)
   1e446:	781b      	ldrb	r3, [r3, #0]
   1e448:	b10b      	cbz	r3, 1e44e <nrf_malloc+0xa>
   1e44a:	f7ff bd8d 	b.w	1df68 <mem_alloc.constprop.4>
   1e44e:	4618      	mov	r0, r3
   1e450:	4770      	bx	lr
   1e452:	bf00      	nop
   1e454:	200314b8 	.word	0x200314b8

0001e458 <nrf_free>:
   1e458:	4b04      	ldr	r3, [pc, #16]	; (1e46c <nrf_free+0x14>)
   1e45a:	781b      	ldrb	r3, [r3, #0]
   1e45c:	b123      	cbz	r3, 1e468 <nrf_free+0x10>
   1e45e:	b118      	cbz	r0, 1e468 <nrf_free+0x10>
   1e460:	4601      	mov	r1, r0
   1e462:	2000      	movs	r0, #0
   1e464:	f7ff bc30 	b.w	1dcc8 <mem_free>
   1e468:	4770      	bx	lr
   1e46a:	bf00      	nop
   1e46c:	200314b8 	.word	0x200314b8

0001e470 <nrf_shared_malloc>:
   1e470:	4b03      	ldr	r3, [pc, #12]	; (1e480 <nrf_shared_malloc+0x10>)
   1e472:	781b      	ldrb	r3, [r3, #0]
   1e474:	b10b      	cbz	r3, 1e47a <nrf_shared_malloc+0xa>
   1e476:	f7ff bc93 	b.w	1dda0 <mem_alloc.constprop.5>
   1e47a:	4618      	mov	r0, r3
   1e47c:	4770      	bx	lr
   1e47e:	bf00      	nop
   1e480:	200314b8 	.word	0x200314b8

0001e484 <nrf_shared_free>:
   1e484:	4b04      	ldr	r3, [pc, #16]	; (1e498 <nrf_shared_free+0x14>)
   1e486:	781b      	ldrb	r3, [r3, #0]
   1e488:	b123      	cbz	r3, 1e494 <nrf_shared_free+0x10>
   1e48a:	b118      	cbz	r0, 1e494 <nrf_shared_free+0x10>
   1e48c:	4601      	mov	r1, r0
   1e48e:	2001      	movs	r0, #1
   1e490:	f7ff bc1a 	b.w	1dcc8 <mem_free>
   1e494:	4770      	bx	lr
   1e496:	bf00      	nop
   1e498:	200314b8 	.word	0x200314b8

0001e49c <ip_client_event_handler>:
   1e49c:	f850 1b08 	ldr.w	r1, [r0], #8
   1e4a0:	0c09      	lsrs	r1, r1, #16
   1e4a2:	f004 bd35 	b.w	22f10 <rpc_ip_event_handler>
   1e4a6:	bf00      	nop

0001e4a8 <rpc_ip_client_init>:
   1e4a8:	4801      	ldr	r0, [pc, #4]	; (1e4b0 <rpc_ip_client_init+0x8>)
   1e4aa:	f005 ba25 	b.w	238f8 <rpc_client_register>
   1e4ae:	bf00      	nop
   1e4b0:	00030b90 	.word	0x00030b90

0001e4b4 <rpc_ip_client_request_alloc>:
   1e4b4:	2300      	movs	r3, #0
   1e4b6:	b510      	push	{r4, lr}
   1e4b8:	b082      	sub	sp, #8
   1e4ba:	9301      	str	r3, [sp, #4]
   1e4bc:	b158      	cbz	r0, 1e4d6 <rpc_ip_client_request_alloc+0x22>
   1e4be:	4604      	mov	r4, r0
   1e4c0:	aa01      	add	r2, sp, #4
   1e4c2:	2004      	movs	r0, #4
   1e4c4:	f005 fc50 	bl	23d68 <rpc_message_alloc>
   1e4c8:	b918      	cbnz	r0, 1e4d2 <rpc_ip_client_request_alloc+0x1e>
   1e4ca:	9b01      	ldr	r3, [sp, #4]
   1e4cc:	b10b      	cbz	r3, 1e4d2 <rpc_ip_client_request_alloc+0x1e>
   1e4ce:	3308      	adds	r3, #8
   1e4d0:	6023      	str	r3, [r4, #0]
   1e4d2:	b002      	add	sp, #8
   1e4d4:	bd10      	pop	{r4, pc}
   1e4d6:	2007      	movs	r0, #7
   1e4d8:	b002      	add	sp, #8
   1e4da:	bd10      	pop	{r4, pc}

0001e4dc <rpc_ip_client_request_send>:
   1e4dc:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   1e4e0:	f5b3 4fe0 	cmp.w	r3, #28672	; 0x7000
   1e4e4:	d10b      	bne.n	1e4fe <rpc_ip_client_request_send+0x22>
   1e4e6:	b160      	cbz	r0, 1e502 <rpc_ip_client_request_send+0x26>
   1e4e8:	4603      	mov	r3, r0
   1e4ea:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   1e4ee:	2004      	movs	r0, #4
   1e4f0:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   1e4f4:	f843 1d08 	str.w	r1, [r3, #-8]!
   1e4f8:	4619      	mov	r1, r3
   1e4fa:	f005 bc1d 	b.w	23d38 <rpc_message_send>
   1e4fe:	200f      	movs	r0, #15
   1e500:	4770      	bx	lr
   1e502:	2007      	movs	r0, #7
   1e504:	4770      	bx	lr
   1e506:	bf00      	nop

0001e508 <rpc_ip_client_message_free>:
   1e508:	b120      	cbz	r0, 1e514 <rpc_ip_client_message_free+0xc>
   1e50a:	f1a0 0108 	sub.w	r1, r0, #8
   1e50e:	2004      	movs	r0, #4
   1e510:	f005 bc5c 	b.w	23dcc <rpc_message_free>
   1e514:	2007      	movs	r0, #7
   1e516:	4770      	bx	lr

0001e518 <rpc_ip_client_data_free>:
   1e518:	b118      	cbz	r0, 1e522 <rpc_ip_client_data_free+0xa>
   1e51a:	4601      	mov	r1, r0
   1e51c:	2004      	movs	r0, #4
   1e51e:	f005 bd67 	b.w	23ff0 <rpc_message_data_free>
   1e522:	2007      	movs	r0, #7
   1e524:	4770      	bx	lr
   1e526:	bf00      	nop

0001e528 <secure_client_socket>:
   1e528:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1e52c:	460c      	mov	r4, r1
   1e52e:	680b      	ldr	r3, [r1, #0]
   1e530:	4f46      	ldr	r7, [pc, #280]	; (1e64c <secure_client_socket+0x124>)
   1e532:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   1e536:	600b      	str	r3, [r1, #0]
   1e538:	680b      	ldr	r3, [r1, #0]
   1e53a:	00c6      	lsls	r6, r0, #3
   1e53c:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   1e540:	600b      	str	r3, [r1, #0]
   1e542:	eb07 0a06 	add.w	sl, r7, r6
   1e546:	b082      	sub	sp, #8
   1e548:	f8da 3004 	ldr.w	r3, [sl, #4]
   1e54c:	6989      	ldr	r1, [r1, #24]
   1e54e:	f247 0281 	movw	r2, #28801	; 0x7081
   1e552:	4605      	mov	r5, r0
   1e554:	f8d4 8000 	ldr.w	r8, [r4]
   1e558:	f003 fbd2 	bl	21d00 <ip_interface_request_create>
   1e55c:	2800      	cmp	r0, #0
   1e55e:	d06f      	beq.n	1e640 <secure_client_socket+0x118>
   1e560:	f8da 2004 	ldr.w	r2, [sl, #4]
   1e564:	4681      	mov	r9, r0
   1e566:	2a00      	cmp	r2, #0
   1e568:	d15f      	bne.n	1e62a <secure_client_socket+0x102>
   1e56a:	4b39      	ldr	r3, [pc, #228]	; (1e650 <secure_client_socket+0x128>)
   1e56c:	1971      	adds	r1, r6, r5
   1e56e:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   1e572:	2224      	movs	r2, #36	; 0x24
   1e574:	f109 0014 	add.w	r0, r9, #20
   1e578:	f010 feec 	bl	2f354 <memcpy>
   1e57c:	f8d9 3008 	ldr.w	r3, [r9, #8]
   1e580:	4649      	mov	r1, r9
   1e582:	3324      	adds	r3, #36	; 0x24
   1e584:	f8c9 3008 	str.w	r3, [r9, #8]
   1e588:	6822      	ldr	r2, [r4, #0]
   1e58a:	4643      	mov	r3, r8
   1e58c:	0c12      	lsrs	r2, r2, #16
   1e58e:	0412      	lsls	r2, r2, #16
   1e590:	f042 020a 	orr.w	r2, r2, #10
   1e594:	6022      	str	r2, [r4, #0]
   1e596:	4620      	mov	r0, r4
   1e598:	f247 0281 	movw	r2, #28801	; 0x7081
   1e59c:	f003 fbd0 	bl	21d40 <ip_interface_request_send>
   1e5a0:	4603      	mov	r3, r0
   1e5a2:	b970      	cbnz	r0, 1e5c2 <secure_client_socket+0x9a>
   1e5a4:	6823      	ldr	r3, [r4, #0]
   1e5a6:	00db      	lsls	r3, r3, #3
   1e5a8:	d40f      	bmi.n	1e5ca <secure_client_socket+0xa2>
   1e5aa:	f04f 33ff 	mov.w	r3, #4294967295
   1e5ae:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1e5b2:	210b      	movs	r1, #11
   1e5b4:	4628      	mov	r0, r5
   1e5b6:	f003 fbd7 	bl	21d68 <ip_interface_wait>
   1e5ba:	4603      	mov	r3, r0
   1e5bc:	b150      	cbz	r0, 1e5d4 <secure_client_socket+0xac>
   1e5be:	f8c4 8000 	str.w	r8, [r4]
   1e5c2:	4618      	mov	r0, r3
   1e5c4:	b002      	add	sp, #8
   1e5c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1e5ca:	2373      	movs	r3, #115	; 0x73
   1e5cc:	4618      	mov	r0, r3
   1e5ce:	b002      	add	sp, #8
   1e5d0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1e5d4:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
   1e5d8:	f04f 33ff 	mov.w	r3, #4294967295
   1e5dc:	4611      	mov	r1, r2
   1e5de:	4628      	mov	r0, r5
   1e5e0:	f003 fbc2 	bl	21d68 <ip_interface_wait>
   1e5e4:	4603      	mov	r3, r0
   1e5e6:	bb30      	cbnz	r0, 1e636 <secure_client_socket+0x10e>
   1e5e8:	f857 0035 	ldr.w	r0, [r7, r5, lsl #3]
   1e5ec:	b138      	cbz	r0, 1e5fe <secure_client_socket+0xd6>
   1e5ee:	9301      	str	r3, [sp, #4]
   1e5f0:	f7ff ff32 	bl	1e458 <nrf_free>
   1e5f4:	9b01      	ldr	r3, [sp, #4]
   1e5f6:	443e      	add	r6, r7
   1e5f8:	6073      	str	r3, [r6, #4]
   1e5fa:	f847 3035 	str.w	r3, [r7, r5, lsl #3]
   1e5fe:	4618      	mov	r0, r3
   1e600:	6822      	ldr	r2, [r4, #0]
   1e602:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
   1e606:	6022      	str	r2, [r4, #0]
   1e608:	6822      	ldr	r2, [r4, #0]
   1e60a:	0c12      	lsrs	r2, r2, #16
   1e60c:	0412      	lsls	r2, r2, #16
   1e60e:	f042 020c 	orr.w	r2, r2, #12
   1e612:	6022      	str	r2, [r4, #0]
   1e614:	6822      	ldr	r2, [r4, #0]
   1e616:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   1e61a:	6022      	str	r2, [r4, #0]
   1e61c:	6822      	ldr	r2, [r4, #0]
   1e61e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
   1e622:	6022      	str	r2, [r4, #0]
   1e624:	b002      	add	sp, #8
   1e626:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1e62a:	f857 1035 	ldr.w	r1, [r7, r5, lsl #3]
   1e62e:	6800      	ldr	r0, [r0, #0]
   1e630:	f010 fe90 	bl	2f354 <memcpy>
   1e634:	e799      	b.n	1e56a <secure_client_socket+0x42>
   1e636:	2b73      	cmp	r3, #115	; 0x73
   1e638:	d0c3      	beq.n	1e5c2 <secure_client_socket+0x9a>
   1e63a:	f8c4 8000 	str.w	r8, [r4]
   1e63e:	e7c0      	b.n	1e5c2 <secure_client_socket+0x9a>
   1e640:	230c      	movs	r3, #12
   1e642:	4618      	mov	r0, r3
   1e644:	b002      	add	sp, #8
   1e646:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1e64a:	bf00      	nop
   1e64c:	20028c98 	.word	0x20028c98
   1e650:	20028b54 	.word	0x20028b54

0001e654 <tls_interface_init>:
   1e654:	2000      	movs	r0, #0
   1e656:	4770      	bx	lr

0001e658 <tls_interface_open>:
   1e658:	b538      	push	{r3, r4, r5, lr}
   1e65a:	1e4b      	subs	r3, r1, #1
   1e65c:	2b01      	cmp	r3, #1
   1e65e:	d808      	bhi.n	1e672 <tls_interface_open+0x1a>
   1e660:	4614      	mov	r4, r2
   1e662:	b162      	cbz	r2, 1e67e <tls_interface_open+0x26>
   1e664:	2901      	cmp	r1, #1
   1e666:	d02d      	beq.n	1e6c4 <tls_interface_open+0x6c>
   1e668:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   1e66c:	bf08      	it	eq
   1e66e:	2202      	moveq	r2, #2
   1e670:	d00d      	beq.n	1e68e <tls_interface_open+0x36>
   1e672:	2029      	movs	r0, #41	; 0x29
   1e674:	f7fd f87a 	bl	1b76c <bsd_os_errno_set>
   1e678:	f04f 35ff 	mov.w	r5, #4294967295
   1e67c:	e020      	b.n	1e6c0 <tls_interface_open+0x68>
   1e67e:	2901      	cmp	r1, #1
   1e680:	bf0b      	itete	eq
   1e682:	2201      	moveq	r2, #1
   1e684:	2202      	movne	r2, #2
   1e686:	f44f 7482 	moveq.w	r4, #260	; 0x104
   1e68a:	f44f 7487 	movne.w	r4, #270	; 0x10e
   1e68e:	f003 fb97 	bl	21dc0 <ip_interface_open>
   1e692:	1e05      	subs	r5, r0, #0
   1e694:	db1b      	blt.n	1e6ce <tls_interface_open+0x76>
   1e696:	4b0f      	ldr	r3, [pc, #60]	; (1e6d4 <tls_interface_open+0x7c>)
   1e698:	eb05 00c5 	add.w	r0, r5, r5, lsl #3
   1e69c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   1e6a0:	2224      	movs	r2, #36	; 0x24
   1e6a2:	490d      	ldr	r1, [pc, #52]	; (1e6d8 <tls_interface_open+0x80>)
   1e6a4:	f010 fe56 	bl	2f354 <memcpy>
   1e6a8:	4628      	mov	r0, r5
   1e6aa:	f004 ffe9 	bl	23680 <interface_socket_from_handle_get>
   1e6ae:	6803      	ldr	r3, [r0, #0]
   1e6b0:	6144      	str	r4, [r0, #20]
   1e6b2:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   1e6b6:	6003      	str	r3, [r0, #0]
   1e6b8:	6803      	ldr	r3, [r0, #0]
   1e6ba:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   1e6be:	6003      	str	r3, [r0, #0]
   1e6c0:	4628      	mov	r0, r5
   1e6c2:	bd38      	pop	{r3, r4, r5, pc}
   1e6c4:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   1e6c8:	d1d3      	bne.n	1e672 <tls_interface_open+0x1a>
   1e6ca:	460a      	mov	r2, r1
   1e6cc:	e7df      	b.n	1e68e <tls_interface_open+0x36>
   1e6ce:	f04f 35ff 	mov.w	r5, #4294967295
   1e6d2:	e7f5      	b.n	1e6c0 <tls_interface_open+0x68>
   1e6d4:	20028b54 	.word	0x20028b54
   1e6d8:	00030ba0 	.word	0x00030ba0

0001e6dc <tls_interface_close>:
   1e6dc:	b538      	push	{r3, r4, r5, lr}
   1e6de:	4604      	mov	r4, r0
   1e6e0:	f004 ffce 	bl	23680 <interface_socket_from_handle_get>
   1e6e4:	b180      	cbz	r0, 1e708 <tls_interface_close+0x2c>
   1e6e6:	4d0b      	ldr	r5, [pc, #44]	; (1e714 <tls_interface_close+0x38>)
   1e6e8:	f855 0034 	ldr.w	r0, [r5, r4, lsl #3]
   1e6ec:	b138      	cbz	r0, 1e6fe <tls_interface_close+0x22>
   1e6ee:	f7ff feb3 	bl	1e458 <nrf_free>
   1e6f2:	2300      	movs	r3, #0
   1e6f4:	eb05 02c4 	add.w	r2, r5, r4, lsl #3
   1e6f8:	f845 3034 	str.w	r3, [r5, r4, lsl #3]
   1e6fc:	6053      	str	r3, [r2, #4]
   1e6fe:	4620      	mov	r0, r4
   1e700:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1e704:	f003 bc0e 	b.w	21f24 <ip_interface_close>
   1e708:	2009      	movs	r0, #9
   1e70a:	f7fd f82f 	bl	1b76c <bsd_os_errno_set>
   1e70e:	f04f 30ff 	mov.w	r0, #4294967295
   1e712:	bd38      	pop	{r3, r4, r5, pc}
   1e714:	20028c98 	.word	0x20028c98

0001e718 <tls_interface_sendto>:
   1e718:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1e71c:	460d      	mov	r5, r1
   1e71e:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   1e722:	4616      	mov	r6, r2
   1e724:	461f      	mov	r7, r3
   1e726:	4604      	mov	r4, r0
   1e728:	f004 ffaa 	bl	23680 <interface_socket_from_handle_get>
   1e72c:	2800      	cmp	r0, #0
   1e72e:	d03b      	beq.n	1e7a8 <tls_interface_sendto+0x90>
   1e730:	6803      	ldr	r3, [r0, #0]
   1e732:	b29b      	uxth	r3, r3
   1e734:	2b0c      	cmp	r3, #12
   1e736:	d039      	beq.n	1e7ac <tls_interface_sendto+0x94>
   1e738:	6803      	ldr	r3, [r0, #0]
   1e73a:	b29b      	uxth	r3, r3
   1e73c:	2b0b      	cmp	r3, #11
   1e73e:	d111      	bne.n	1e764 <tls_interface_sendto+0x4c>
   1e740:	4b20      	ldr	r3, [pc, #128]	; (1e7c4 <tls_interface_sendto+0xac>)
   1e742:	eb04 04c4 	add.w	r4, r4, r4, lsl #3
   1e746:	f813 3024 	ldrb.w	r3, [r3, r4, lsl #2]
   1e74a:	2b02      	cmp	r3, #2
   1e74c:	d038      	beq.n	1e7c0 <tls_interface_sendto+0xa8>
   1e74e:	6903      	ldr	r3, [r0, #16]
   1e750:	2b01      	cmp	r3, #1
   1e752:	bf14      	ite	ne
   1e754:	2039      	movne	r0, #57	; 0x39
   1e756:	202a      	moveq	r0, #42	; 0x2a
   1e758:	f7fd f808 	bl	1b76c <bsd_os_errno_set>
   1e75c:	f04f 30ff 	mov.w	r0, #4294967295
   1e760:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1e764:	6903      	ldr	r3, [r0, #16]
   1e766:	2b01      	cmp	r3, #1
   1e768:	d00b      	beq.n	1e782 <tls_interface_sendto+0x6a>
   1e76a:	2b02      	cmp	r3, #2
   1e76c:	d001      	beq.n	1e772 <tls_interface_sendto+0x5a>
   1e76e:	2039      	movs	r0, #57	; 0x39
   1e770:	e7f2      	b.n	1e758 <tls_interface_sendto+0x40>
   1e772:	6803      	ldr	r3, [r0, #0]
   1e774:	b29b      	uxth	r3, r3
   1e776:	2b02      	cmp	r3, #2
   1e778:	d007      	beq.n	1e78a <tls_interface_sendto+0x72>
   1e77a:	6803      	ldr	r3, [r0, #0]
   1e77c:	b29b      	uxth	r3, r3
   1e77e:	2b04      	cmp	r3, #4
   1e780:	d003      	beq.n	1e78a <tls_interface_sendto+0x72>
   1e782:	6803      	ldr	r3, [r0, #0]
   1e784:	b29b      	uxth	r3, r3
   1e786:	2b05      	cmp	r3, #5
   1e788:	d1f1      	bne.n	1e76e <tls_interface_sendto+0x56>
   1e78a:	4b0e      	ldr	r3, [pc, #56]	; (1e7c4 <tls_interface_sendto+0xac>)
   1e78c:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
   1e790:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   1e794:	2b02      	cmp	r3, #2
   1e796:	d1ea      	bne.n	1e76e <tls_interface_sendto+0x56>
   1e798:	4601      	mov	r1, r0
   1e79a:	4620      	mov	r0, r4
   1e79c:	f7ff fec4 	bl	1e528 <secure_client_socket>
   1e7a0:	2800      	cmp	r0, #0
   1e7a2:	d003      	beq.n	1e7ac <tls_interface_sendto+0x94>
   1e7a4:	dcd8      	bgt.n	1e758 <tls_interface_sendto+0x40>
   1e7a6:	e7d9      	b.n	1e75c <tls_interface_sendto+0x44>
   1e7a8:	2009      	movs	r0, #9
   1e7aa:	e7d5      	b.n	1e758 <tls_interface_sendto+0x40>
   1e7ac:	e9cd 8908 	strd	r8, r9, [sp, #32]
   1e7b0:	463b      	mov	r3, r7
   1e7b2:	4632      	mov	r2, r6
   1e7b4:	4629      	mov	r1, r5
   1e7b6:	4620      	mov	r0, r4
   1e7b8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1e7bc:	f003 bc22 	b.w	22004 <ip_interface_sendto>
   1e7c0:	2023      	movs	r0, #35	; 0x23
   1e7c2:	e7c9      	b.n	1e758 <tls_interface_sendto+0x40>
   1e7c4:	20028b54 	.word	0x20028b54

0001e7c8 <tls_interface_recvfrom>:
   1e7c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1e7cc:	460d      	mov	r5, r1
   1e7ce:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   1e7d2:	4616      	mov	r6, r2
   1e7d4:	461f      	mov	r7, r3
   1e7d6:	4604      	mov	r4, r0
   1e7d8:	f004 ff52 	bl	23680 <interface_socket_from_handle_get>
   1e7dc:	2800      	cmp	r0, #0
   1e7de:	d038      	beq.n	1e852 <tls_interface_recvfrom+0x8a>
   1e7e0:	6803      	ldr	r3, [r0, #0]
   1e7e2:	b29b      	uxth	r3, r3
   1e7e4:	2b0c      	cmp	r3, #12
   1e7e6:	d00f      	beq.n	1e808 <tls_interface_recvfrom+0x40>
   1e7e8:	6803      	ldr	r3, [r0, #0]
   1e7ea:	b29b      	uxth	r3, r3
   1e7ec:	2b0d      	cmp	r3, #13
   1e7ee:	d00b      	beq.n	1e808 <tls_interface_recvfrom+0x40>
   1e7f0:	6903      	ldr	r3, [r0, #16]
   1e7f2:	2b01      	cmp	r3, #1
   1e7f4:	d01a      	beq.n	1e82c <tls_interface_recvfrom+0x64>
   1e7f6:	2b02      	cmp	r3, #2
   1e7f8:	d010      	beq.n	1e81c <tls_interface_recvfrom+0x54>
   1e7fa:	2023      	movs	r0, #35	; 0x23
   1e7fc:	f7fc ffb6 	bl	1b76c <bsd_os_errno_set>
   1e800:	f04f 30ff 	mov.w	r0, #4294967295
   1e804:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1e808:	e9cd 8908 	strd	r8, r9, [sp, #32]
   1e80c:	463b      	mov	r3, r7
   1e80e:	4632      	mov	r2, r6
   1e810:	4629      	mov	r1, r5
   1e812:	4620      	mov	r0, r4
   1e814:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1e818:	f003 bd6c 	b.w	222f4 <ip_interface_recvfrom>
   1e81c:	6803      	ldr	r3, [r0, #0]
   1e81e:	b29b      	uxth	r3, r3
   1e820:	2b02      	cmp	r3, #2
   1e822:	d007      	beq.n	1e834 <tls_interface_recvfrom+0x6c>
   1e824:	6803      	ldr	r3, [r0, #0]
   1e826:	b29b      	uxth	r3, r3
   1e828:	2b04      	cmp	r3, #4
   1e82a:	d003      	beq.n	1e834 <tls_interface_recvfrom+0x6c>
   1e82c:	6803      	ldr	r3, [r0, #0]
   1e82e:	b29b      	uxth	r3, r3
   1e830:	2b05      	cmp	r3, #5
   1e832:	d1e2      	bne.n	1e7fa <tls_interface_recvfrom+0x32>
   1e834:	4b08      	ldr	r3, [pc, #32]	; (1e858 <tls_interface_recvfrom+0x90>)
   1e836:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
   1e83a:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   1e83e:	2b02      	cmp	r3, #2
   1e840:	d1db      	bne.n	1e7fa <tls_interface_recvfrom+0x32>
   1e842:	4601      	mov	r1, r0
   1e844:	4620      	mov	r0, r4
   1e846:	f7ff fe6f 	bl	1e528 <secure_client_socket>
   1e84a:	2800      	cmp	r0, #0
   1e84c:	d0dc      	beq.n	1e808 <tls_interface_recvfrom+0x40>
   1e84e:	dcd5      	bgt.n	1e7fc <tls_interface_recvfrom+0x34>
   1e850:	e7d6      	b.n	1e800 <tls_interface_recvfrom+0x38>
   1e852:	2009      	movs	r0, #9
   1e854:	e7d2      	b.n	1e7fc <tls_interface_recvfrom+0x34>
   1e856:	bf00      	nop
   1e858:	20028b54 	.word	0x20028b54

0001e85c <tls_interface_bind>:
   1e85c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1e860:	460c      	mov	r4, r1
   1e862:	4617      	mov	r7, r2
   1e864:	4606      	mov	r6, r0
   1e866:	f004 ff0b 	bl	23680 <interface_socket_from_handle_get>
   1e86a:	2800      	cmp	r0, #0
   1e86c:	d06d      	beq.n	1e94a <tls_interface_bind+0xee>
   1e86e:	6803      	ldr	r3, [r0, #0]
   1e870:	4605      	mov	r5, r0
   1e872:	b29b      	uxth	r3, r3
   1e874:	2b02      	cmp	r3, #2
   1e876:	d15a      	bne.n	1e92e <tls_interface_bind+0xd2>
   1e878:	4621      	mov	r1, r4
   1e87a:	463a      	mov	r2, r7
   1e87c:	4630      	mov	r0, r6
   1e87e:	f003 ff27 	bl	226d0 <ip_interface_bind>
   1e882:	4604      	mov	r4, r0
   1e884:	2800      	cmp	r0, #0
   1e886:	d148      	bne.n	1e91a <tls_interface_bind+0xbe>
   1e888:	00f7      	lsls	r7, r6, #3
   1e88a:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 1e950 <tls_interface_bind+0xf4>
   1e88e:	19bb      	adds	r3, r7, r6
   1e890:	f818 3023 	ldrb.w	r3, [r8, r3, lsl #2]
   1e894:	2b01      	cmp	r3, #1
   1e896:	d002      	beq.n	1e89e <tls_interface_bind+0x42>
   1e898:	4620      	mov	r0, r4
   1e89a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e89e:	f8df b0b4 	ldr.w	fp, [pc, #180]	; 1e954 <tls_interface_bind+0xf8>
   1e8a2:	f247 0281 	movw	r2, #28801	; 0x7081
   1e8a6:	eb0b 0a07 	add.w	sl, fp, r7
   1e8aa:	f8da 3004 	ldr.w	r3, [sl, #4]
   1e8ae:	69a9      	ldr	r1, [r5, #24]
   1e8b0:	4630      	mov	r0, r6
   1e8b2:	f003 fa25 	bl	21d00 <ip_interface_request_create>
   1e8b6:	4681      	mov	r9, r0
   1e8b8:	2800      	cmp	r0, #0
   1e8ba:	d044      	beq.n	1e946 <tls_interface_bind+0xea>
   1e8bc:	f8da 2004 	ldr.w	r2, [sl, #4]
   1e8c0:	2a00      	cmp	r2, #0
   1e8c2:	d13a      	bne.n	1e93a <tls_interface_bind+0xde>
   1e8c4:	19b9      	adds	r1, r7, r6
   1e8c6:	eb08 0181 	add.w	r1, r8, r1, lsl #2
   1e8ca:	2224      	movs	r2, #36	; 0x24
   1e8cc:	f109 0014 	add.w	r0, r9, #20
   1e8d0:	f010 fd40 	bl	2f354 <memcpy>
   1e8d4:	f8d9 3008 	ldr.w	r3, [r9, #8]
   1e8d8:	4649      	mov	r1, r9
   1e8da:	3324      	adds	r3, #36	; 0x24
   1e8dc:	f8c9 3008 	str.w	r3, [r9, #8]
   1e8e0:	682a      	ldr	r2, [r5, #0]
   1e8e2:	2304      	movs	r3, #4
   1e8e4:	0c12      	lsrs	r2, r2, #16
   1e8e6:	0412      	lsls	r2, r2, #16
   1e8e8:	f042 020a 	orr.w	r2, r2, #10
   1e8ec:	602a      	str	r2, [r5, #0]
   1e8ee:	4628      	mov	r0, r5
   1e8f0:	f247 0281 	movw	r2, #28801	; 0x7081
   1e8f4:	f003 fa24 	bl	21d40 <ip_interface_request_send>
   1e8f8:	b9e8      	cbnz	r0, 1e936 <tls_interface_bind+0xda>
   1e8fa:	682b      	ldr	r3, [r5, #0]
   1e8fc:	00db      	lsls	r3, r3, #3
   1e8fe:	d418      	bmi.n	1e932 <tls_interface_bind+0xd6>
   1e900:	4630      	mov	r0, r6
   1e902:	f04f 33ff 	mov.w	r3, #4294967295
   1e906:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1e90a:	210b      	movs	r1, #11
   1e90c:	f003 fa2c 	bl	21d68 <ip_interface_wait>
   1e910:	2800      	cmp	r0, #0
   1e912:	d0c1      	beq.n	1e898 <tls_interface_bind+0x3c>
   1e914:	2304      	movs	r3, #4
   1e916:	4604      	mov	r4, r0
   1e918:	602b      	str	r3, [r5, #0]
   1e91a:	2c00      	cmp	r4, #0
   1e91c:	ddbc      	ble.n	1e898 <tls_interface_bind+0x3c>
   1e91e:	4620      	mov	r0, r4
   1e920:	f04f 34ff 	mov.w	r4, #4294967295
   1e924:	f7fc ff22 	bl	1b76c <bsd_os_errno_set>
   1e928:	4620      	mov	r0, r4
   1e92a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1e92e:	242d      	movs	r4, #45	; 0x2d
   1e930:	e7f5      	b.n	1e91e <tls_interface_bind+0xc2>
   1e932:	2473      	movs	r4, #115	; 0x73
   1e934:	e7f3      	b.n	1e91e <tls_interface_bind+0xc2>
   1e936:	4604      	mov	r4, r0
   1e938:	e7ef      	b.n	1e91a <tls_interface_bind+0xbe>
   1e93a:	f85b 1036 	ldr.w	r1, [fp, r6, lsl #3]
   1e93e:	6800      	ldr	r0, [r0, #0]
   1e940:	f010 fd08 	bl	2f354 <memcpy>
   1e944:	e7be      	b.n	1e8c4 <tls_interface_bind+0x68>
   1e946:	240c      	movs	r4, #12
   1e948:	e7e9      	b.n	1e91e <tls_interface_bind+0xc2>
   1e94a:	2409      	movs	r4, #9
   1e94c:	e7e7      	b.n	1e91e <tls_interface_bind+0xc2>
   1e94e:	bf00      	nop
   1e950:	20028b54 	.word	0x20028b54
   1e954:	20028c98 	.word	0x20028c98

0001e958 <tls_interface_connect>:
   1e958:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1e95a:	460e      	mov	r6, r1
   1e95c:	4617      	mov	r7, r2
   1e95e:	4604      	mov	r4, r0
   1e960:	f004 fe8e 	bl	23680 <interface_socket_from_handle_get>
   1e964:	b1e8      	cbz	r0, 1e9a2 <tls_interface_connect+0x4a>
   1e966:	4b13      	ldr	r3, [pc, #76]	; (1e9b4 <tls_interface_connect+0x5c>)
   1e968:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
   1e96c:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   1e970:	2b02      	cmp	r3, #2
   1e972:	d11c      	bne.n	1e9ae <tls_interface_connect+0x56>
   1e974:	6803      	ldr	r3, [r0, #0]
   1e976:	4605      	mov	r5, r0
   1e978:	b29b      	uxth	r3, r3
   1e97a:	2b02      	cmp	r3, #2
   1e97c:	d003      	beq.n	1e986 <tls_interface_connect+0x2e>
   1e97e:	6803      	ldr	r3, [r0, #0]
   1e980:	b29b      	uxth	r3, r3
   1e982:	2b04      	cmp	r3, #4
   1e984:	d113      	bne.n	1e9ae <tls_interface_connect+0x56>
   1e986:	463a      	mov	r2, r7
   1e988:	4631      	mov	r1, r6
   1e98a:	4620      	mov	r0, r4
   1e98c:	f003 fde6 	bl	2255c <ip_interface_connect>
   1e990:	b110      	cbz	r0, 1e998 <tls_interface_connect+0x40>
   1e992:	2800      	cmp	r0, #0
   1e994:	dc06      	bgt.n	1e9a4 <tls_interface_connect+0x4c>
   1e996:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e998:	4629      	mov	r1, r5
   1e99a:	4620      	mov	r0, r4
   1e99c:	f7ff fdc4 	bl	1e528 <secure_client_socket>
   1e9a0:	e7f7      	b.n	1e992 <tls_interface_connect+0x3a>
   1e9a2:	2009      	movs	r0, #9
   1e9a4:	f7fc fee2 	bl	1b76c <bsd_os_errno_set>
   1e9a8:	f04f 30ff 	mov.w	r0, #4294967295
   1e9ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e9ae:	202d      	movs	r0, #45	; 0x2d
   1e9b0:	e7f8      	b.n	1e9a4 <tls_interface_connect+0x4c>
   1e9b2:	bf00      	nop
   1e9b4:	20028b54 	.word	0x20028b54

0001e9b8 <tls_interface_listen>:
   1e9b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1e9bc:	b083      	sub	sp, #12
   1e9be:	9101      	str	r1, [sp, #4]
   1e9c0:	4605      	mov	r5, r0
   1e9c2:	f004 fe5d 	bl	23680 <interface_socket_from_handle_get>
   1e9c6:	2800      	cmp	r0, #0
   1e9c8:	d079      	beq.n	1eabe <tls_interface_listen+0x106>
   1e9ca:	6903      	ldr	r3, [r0, #16]
   1e9cc:	4604      	mov	r4, r0
   1e9ce:	2b01      	cmp	r3, #1
   1e9d0:	d173      	bne.n	1eaba <tls_interface_listen+0x102>
   1e9d2:	6803      	ldr	r3, [r0, #0]
   1e9d4:	b29b      	uxth	r3, r3
   1e9d6:	2b04      	cmp	r3, #4
   1e9d8:	d05f      	beq.n	1ea9a <tls_interface_listen+0xe2>
   1e9da:	6823      	ldr	r3, [r4, #0]
   1e9dc:	b29b      	uxth	r3, r3
   1e9de:	2b0b      	cmp	r3, #11
   1e9e0:	d16b      	bne.n	1eaba <tls_interface_listen+0x102>
   1e9e2:	00ee      	lsls	r6, r5, #3
   1e9e4:	4f37      	ldr	r7, [pc, #220]	; (1eac4 <tls_interface_listen+0x10c>)
   1e9e6:	1973      	adds	r3, r6, r5
   1e9e8:	f817 3023 	ldrb.w	r3, [r7, r3, lsl #2]
   1e9ec:	2b01      	cmp	r3, #1
   1e9ee:	d164      	bne.n	1eaba <tls_interface_listen+0x102>
   1e9f0:	2201      	movs	r2, #1
   1e9f2:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 1eac8 <tls_interface_listen+0x110>
   1e9f6:	1973      	adds	r3, r6, r5
   1e9f8:	00ee      	lsls	r6, r5, #3
   1e9fa:	f807 2023 	strb.w	r2, [r7, r3, lsl #2]
   1e9fe:	eb09 0806 	add.w	r8, r9, r6
   1ea02:	69a1      	ldr	r1, [r4, #24]
   1ea04:	f8d8 3004 	ldr.w	r3, [r8, #4]
   1ea08:	f247 0281 	movw	r2, #28801	; 0x7081
   1ea0c:	4628      	mov	r0, r5
   1ea0e:	f8d4 a000 	ldr.w	sl, [r4]
   1ea12:	f003 f975 	bl	21d00 <ip_interface_request_create>
   1ea16:	4683      	mov	fp, r0
   1ea18:	2800      	cmp	r0, #0
   1ea1a:	d04c      	beq.n	1eab6 <tls_interface_listen+0xfe>
   1ea1c:	f8d8 2004 	ldr.w	r2, [r8, #4]
   1ea20:	2a00      	cmp	r2, #0
   1ea22:	d142      	bne.n	1eaaa <tls_interface_listen+0xf2>
   1ea24:	1971      	adds	r1, r6, r5
   1ea26:	eb07 0181 	add.w	r1, r7, r1, lsl #2
   1ea2a:	2224      	movs	r2, #36	; 0x24
   1ea2c:	f10b 0014 	add.w	r0, fp, #20
   1ea30:	f010 fc90 	bl	2f354 <memcpy>
   1ea34:	f8db 2008 	ldr.w	r2, [fp, #8]
   1ea38:	4659      	mov	r1, fp
   1ea3a:	3224      	adds	r2, #36	; 0x24
   1ea3c:	f8cb 2008 	str.w	r2, [fp, #8]
   1ea40:	6822      	ldr	r2, [r4, #0]
   1ea42:	4653      	mov	r3, sl
   1ea44:	0c12      	lsrs	r2, r2, #16
   1ea46:	0412      	lsls	r2, r2, #16
   1ea48:	f042 020a 	orr.w	r2, r2, #10
   1ea4c:	6022      	str	r2, [r4, #0]
   1ea4e:	4620      	mov	r0, r4
   1ea50:	f247 0281 	movw	r2, #28801	; 0x7081
   1ea54:	f003 f974 	bl	21d40 <ip_interface_request_send>
   1ea58:	b968      	cbnz	r0, 1ea76 <tls_interface_listen+0xbe>
   1ea5a:	6823      	ldr	r3, [r4, #0]
   1ea5c:	00db      	lsls	r3, r3, #3
   1ea5e:	d40f      	bmi.n	1ea80 <tls_interface_listen+0xc8>
   1ea60:	f04f 33ff 	mov.w	r3, #4294967295
   1ea64:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1ea68:	210b      	movs	r1, #11
   1ea6a:	4628      	mov	r0, r5
   1ea6c:	f003 f97c 	bl	21d68 <ip_interface_wait>
   1ea70:	b170      	cbz	r0, 1ea90 <tls_interface_listen+0xd8>
   1ea72:	f8c4 a000 	str.w	sl, [r4]
   1ea76:	2800      	cmp	r0, #0
   1ea78:	dc03      	bgt.n	1ea82 <tls_interface_listen+0xca>
   1ea7a:	b003      	add	sp, #12
   1ea7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ea80:	2073      	movs	r0, #115	; 0x73
   1ea82:	f7fc fe73 	bl	1b76c <bsd_os_errno_set>
   1ea86:	f04f 30ff 	mov.w	r0, #4294967295
   1ea8a:	b003      	add	sp, #12
   1ea8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ea90:	9901      	ldr	r1, [sp, #4]
   1ea92:	4628      	mov	r0, r5
   1ea94:	f003 febc 	bl	22810 <ip_interface_listen>
   1ea98:	e7ed      	b.n	1ea76 <tls_interface_listen+0xbe>
   1ea9a:	00ee      	lsls	r6, r5, #3
   1ea9c:	4f09      	ldr	r7, [pc, #36]	; (1eac4 <tls_interface_listen+0x10c>)
   1ea9e:	1973      	adds	r3, r6, r5
   1eaa0:	f817 3023 	ldrb.w	r3, [r7, r3, lsl #2]
   1eaa4:	2b02      	cmp	r3, #2
   1eaa6:	d198      	bne.n	1e9da <tls_interface_listen+0x22>
   1eaa8:	e7a2      	b.n	1e9f0 <tls_interface_listen+0x38>
   1eaaa:	f859 1035 	ldr.w	r1, [r9, r5, lsl #3]
   1eaae:	6800      	ldr	r0, [r0, #0]
   1eab0:	f010 fc50 	bl	2f354 <memcpy>
   1eab4:	e7b6      	b.n	1ea24 <tls_interface_listen+0x6c>
   1eab6:	200c      	movs	r0, #12
   1eab8:	e7e3      	b.n	1ea82 <tls_interface_listen+0xca>
   1eaba:	202d      	movs	r0, #45	; 0x2d
   1eabc:	e7e1      	b.n	1ea82 <tls_interface_listen+0xca>
   1eabe:	2009      	movs	r0, #9
   1eac0:	e7df      	b.n	1ea82 <tls_interface_listen+0xca>
   1eac2:	bf00      	nop
   1eac4:	20028b54 	.word	0x20028b54
   1eac8:	20028c98 	.word	0x20028c98

0001eacc <tls_interface_accept>:
   1eacc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1eace:	460c      	mov	r4, r1
   1ead0:	4616      	mov	r6, r2
   1ead2:	461f      	mov	r7, r3
   1ead4:	4605      	mov	r5, r0
   1ead6:	f004 fdd3 	bl	23680 <interface_socket_from_handle_get>
   1eada:	2800      	cmp	r0, #0
   1eadc:	d03b      	beq.n	1eb56 <tls_interface_accept+0x8a>
   1eade:	6800      	ldr	r0, [r0, #0]
   1eae0:	b280      	uxth	r0, r0
   1eae2:	2806      	cmp	r0, #6
   1eae4:	d137      	bne.n	1eb56 <tls_interface_accept+0x8a>
   1eae6:	4621      	mov	r1, r4
   1eae8:	463b      	mov	r3, r7
   1eaea:	4632      	mov	r2, r6
   1eaec:	4628      	mov	r0, r5
   1eaee:	f003 ff05 	bl	228fc <ip_interface_accept>
   1eaf2:	4604      	mov	r4, r0
   1eaf4:	b118      	cbz	r0, 1eafe <tls_interface_accept+0x32>
   1eaf6:	2c00      	cmp	r4, #0
   1eaf8:	dc2e      	bgt.n	1eb58 <tls_interface_accept+0x8c>
   1eafa:	4620      	mov	r0, r4
   1eafc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1eafe:	4628      	mov	r0, r5
   1eb00:	f004 fdbe 	bl	23680 <interface_socket_from_handle_get>
   1eb04:	6803      	ldr	r3, [r0, #0]
   1eb06:	4f18      	ldr	r7, [pc, #96]	; (1eb68 <tls_interface_accept+0x9c>)
   1eb08:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   1eb0c:	6003      	str	r3, [r0, #0]
   1eb0e:	6803      	ldr	r3, [r0, #0]
   1eb10:	eb05 05c5 	add.w	r5, r5, r5, lsl #3
   1eb14:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   1eb18:	4606      	mov	r6, r0
   1eb1a:	6003      	str	r3, [r0, #0]
   1eb1c:	eb07 0185 	add.w	r1, r7, r5, lsl #2
   1eb20:	2224      	movs	r2, #36	; 0x24
   1eb22:	4638      	mov	r0, r7
   1eb24:	f010 fc16 	bl	2f354 <memcpy>
   1eb28:	2302      	movs	r3, #2
   1eb2a:	703b      	strb	r3, [r7, #0]
   1eb2c:	6833      	ldr	r3, [r6, #0]
   1eb2e:	4620      	mov	r0, r4
   1eb30:	0c1b      	lsrs	r3, r3, #16
   1eb32:	041b      	lsls	r3, r3, #16
   1eb34:	f043 030b 	orr.w	r3, r3, #11
   1eb38:	6033      	str	r3, [r6, #0]
   1eb3a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1eb3e:	f04f 33ff 	mov.w	r3, #4294967295
   1eb42:	210c      	movs	r1, #12
   1eb44:	f003 f910 	bl	21d68 <ip_interface_wait>
   1eb48:	4604      	mov	r4, r0
   1eb4a:	2800      	cmp	r0, #0
   1eb4c:	d0d5      	beq.n	1eafa <tls_interface_accept+0x2e>
   1eb4e:	2000      	movs	r0, #0
   1eb50:	f003 f9e8 	bl	21f24 <ip_interface_close>
   1eb54:	e7cf      	b.n	1eaf6 <tls_interface_accept+0x2a>
   1eb56:	2409      	movs	r4, #9
   1eb58:	4620      	mov	r0, r4
   1eb5a:	f04f 34ff 	mov.w	r4, #4294967295
   1eb5e:	f7fc fe05 	bl	1b76c <bsd_os_errno_set>
   1eb62:	4620      	mov	r0, r4
   1eb64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1eb66:	bf00      	nop
   1eb68:	20028b54 	.word	0x20028b54

0001eb6c <tls_interface_setopt>:
   1eb6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1eb70:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
   1eb74:	9e06      	ldr	r6, [sp, #24]
   1eb76:	d11e      	bne.n	1ebb6 <tls_interface_setopt+0x4a>
   1eb78:	461f      	mov	r7, r3
   1eb7a:	4605      	mov	r5, r0
   1eb7c:	2b00      	cmp	r3, #0
   1eb7e:	f000 808c 	beq.w	1ec9a <tls_interface_setopt+0x12e>
   1eb82:	4690      	mov	r8, r2
   1eb84:	f004 fd7c 	bl	23680 <interface_socket_from_handle_get>
   1eb88:	2800      	cmp	r0, #0
   1eb8a:	d07b      	beq.n	1ec84 <tls_interface_setopt+0x118>
   1eb8c:	6804      	ldr	r4, [r0, #0]
   1eb8e:	b2a4      	uxth	r4, r4
   1eb90:	2c02      	cmp	r4, #2
   1eb92:	d007      	beq.n	1eba4 <tls_interface_setopt+0x38>
   1eb94:	6803      	ldr	r3, [r0, #0]
   1eb96:	b29b      	uxth	r3, r3
   1eb98:	2b04      	cmp	r3, #4
   1eb9a:	d003      	beq.n	1eba4 <tls_interface_setopt+0x38>
   1eb9c:	6803      	ldr	r3, [r0, #0]
   1eb9e:	b29b      	uxth	r3, r3
   1eba0:	2b05      	cmp	r3, #5
   1eba2:	d16f      	bne.n	1ec84 <tls_interface_setopt+0x118>
   1eba4:	f108 32ff 	add.w	r2, r8, #4294967295
   1eba8:	2a04      	cmp	r2, #4
   1ebaa:	d87c      	bhi.n	1eca6 <tls_interface_setopt+0x13a>
   1ebac:	e8df f002 	tbb	[pc, r2]
   1ebb0:	41324e24 	.word	0x41324e24
   1ebb4:	07          	.byte	0x07
   1ebb5:	00          	.byte	0x00
   1ebb6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1ebba:	f003 bfd7 	b.w	22b6c <ip_interface_setopt>
   1ebbe:	4c3b      	ldr	r4, [pc, #236]	; (1ecac <tls_interface_setopt+0x140>)
   1ebc0:	f854 0035 	ldr.w	r0, [r4, r5, lsl #3]
   1ebc4:	b138      	cbz	r0, 1ebd6 <tls_interface_setopt+0x6a>
   1ebc6:	f7ff fc47 	bl	1e458 <nrf_free>
   1ebca:	2200      	movs	r2, #0
   1ebcc:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
   1ebd0:	f844 2035 	str.w	r2, [r4, r5, lsl #3]
   1ebd4:	605a      	str	r2, [r3, #4]
   1ebd6:	4630      	mov	r0, r6
   1ebd8:	b34e      	cbz	r6, 1ec2e <tls_interface_setopt+0xc2>
   1ebda:	f7ff fc33 	bl	1e444 <nrf_malloc>
   1ebde:	f844 0035 	str.w	r0, [r4, r5, lsl #3]
   1ebe2:	2800      	cmp	r0, #0
   1ebe4:	d057      	beq.n	1ec96 <tls_interface_setopt+0x12a>
   1ebe6:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   1ebea:	4632      	mov	r2, r6
   1ebec:	4639      	mov	r1, r7
   1ebee:	6066      	str	r6, [r4, #4]
   1ebf0:	f010 fbb0 	bl	2f354 <memcpy>
   1ebf4:	2000      	movs	r0, #0
   1ebf6:	e01a      	b.n	1ec2e <tls_interface_setopt+0xc2>
   1ebf8:	2e04      	cmp	r6, #4
   1ebfa:	d14a      	bne.n	1ec92 <tls_interface_setopt+0x126>
   1ebfc:	6838      	ldr	r0, [r7, #0]
   1ebfe:	2800      	cmp	r0, #0
   1ec00:	d039      	beq.n	1ec76 <tls_interface_setopt+0x10a>
   1ec02:	2801      	cmp	r0, #1
   1ec04:	d145      	bne.n	1ec92 <tls_interface_setopt+0x126>
   1ec06:	4a2a      	ldr	r2, [pc, #168]	; (1ecb0 <tls_interface_setopt+0x144>)
   1ec08:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   1ec0c:	f802 0024 	strb.w	r0, [r2, r4, lsl #2]
   1ec10:	2000      	movs	r0, #0
   1ec12:	e00c      	b.n	1ec2e <tls_interface_setopt+0xc2>
   1ec14:	2e01      	cmp	r6, #1
   1ec16:	d13c      	bne.n	1ec92 <tls_interface_setopt+0x126>
   1ec18:	783a      	ldrb	r2, [r7, #0]
   1ec1a:	2000      	movs	r0, #0
   1ec1c:	3200      	adds	r2, #0
   1ec1e:	bf18      	it	ne
   1ec20:	2201      	movne	r2, #1
   1ec22:	4b23      	ldr	r3, [pc, #140]	; (1ecb0 <tls_interface_setopt+0x144>)
   1ec24:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   1ec28:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   1ec2c:	7062      	strb	r2, [r4, #1]
   1ec2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1ec32:	2e04      	cmp	r6, #4
   1ec34:	d12d      	bne.n	1ec92 <tls_interface_setopt+0x126>
   1ec36:	683a      	ldr	r2, [r7, #0]
   1ec38:	2a02      	cmp	r2, #2
   1ec3a:	d82a      	bhi.n	1ec92 <tls_interface_setopt+0x126>
   1ec3c:	4b1c      	ldr	r3, [pc, #112]	; (1ecb0 <tls_interface_setopt+0x144>)
   1ec3e:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   1ec42:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   1ec46:	70a2      	strb	r2, [r4, #2]
   1ec48:	2000      	movs	r0, #0
   1ec4a:	e7f0      	b.n	1ec2e <tls_interface_setopt+0xc2>
   1ec4c:	ea5f 0c96 	movs.w	ip, r6, lsr #2
   1ec50:	d01f      	beq.n	1ec92 <tls_interface_setopt+0x126>
   1ec52:	f016 0403 	ands.w	r4, r6, #3
   1ec56:	d11c      	bne.n	1ec92 <tls_interface_setopt+0x126>
   1ec58:	eb05 05c5 	add.w	r5, r5, r5, lsl #3
   1ec5c:	00ad      	lsls	r5, r5, #2
   1ec5e:	4b14      	ldr	r3, [pc, #80]	; (1ecb0 <tls_interface_setopt+0x144>)
   1ec60:	1d28      	adds	r0, r5, #4
   1ec62:	4418      	add	r0, r3
   1ec64:	442b      	add	r3, r5
   1ec66:	4632      	mov	r2, r6
   1ec68:	4639      	mov	r1, r7
   1ec6a:	f883 c003 	strb.w	ip, [r3, #3]
   1ec6e:	f010 fb71 	bl	2f354 <memcpy>
   1ec72:	4620      	mov	r0, r4
   1ec74:	e7db      	b.n	1ec2e <tls_interface_setopt+0xc2>
   1ec76:	2102      	movs	r1, #2
   1ec78:	4a0d      	ldr	r2, [pc, #52]	; (1ecb0 <tls_interface_setopt+0x144>)
   1ec7a:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   1ec7e:	f802 1024 	strb.w	r1, [r2, r4, lsl #2]
   1ec82:	e7d4      	b.n	1ec2e <tls_interface_setopt+0xc2>
   1ec84:	2009      	movs	r0, #9
   1ec86:	f7fc fd71 	bl	1b76c <bsd_os_errno_set>
   1ec8a:	f04f 30ff 	mov.w	r0, #4294967295
   1ec8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1ec92:	2016      	movs	r0, #22
   1ec94:	e7f7      	b.n	1ec86 <tls_interface_setopt+0x11a>
   1ec96:	200c      	movs	r0, #12
   1ec98:	e7f5      	b.n	1ec86 <tls_interface_setopt+0x11a>
   1ec9a:	200e      	movs	r0, #14
   1ec9c:	f7fc fd66 	bl	1b76c <bsd_os_errno_set>
   1eca0:	f04f 30ff 	mov.w	r0, #4294967295
   1eca4:	e7c3      	b.n	1ec2e <tls_interface_setopt+0xc2>
   1eca6:	202a      	movs	r0, #42	; 0x2a
   1eca8:	e7ed      	b.n	1ec86 <tls_interface_setopt+0x11a>
   1ecaa:	bf00      	nop
   1ecac:	20028c98 	.word	0x20028c98
   1ecb0:	20028b54 	.word	0x20028b54

0001ecb4 <tls_interface_getopt>:
   1ecb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1ecb8:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
   1ecbc:	9f06      	ldr	r7, [sp, #24]
   1ecbe:	d112      	bne.n	1ece6 <tls_interface_getopt+0x32>
   1ecc0:	461d      	mov	r5, r3
   1ecc2:	b16b      	cbz	r3, 1ece0 <tls_interface_getopt+0x2c>
   1ecc4:	b167      	cbz	r7, 1ece0 <tls_interface_getopt+0x2c>
   1ecc6:	4606      	mov	r6, r0
   1ecc8:	4614      	mov	r4, r2
   1ecca:	f004 fcd9 	bl	23680 <interface_socket_from_handle_get>
   1ecce:	2800      	cmp	r0, #0
   1ecd0:	d04f      	beq.n	1ed72 <tls_interface_getopt+0xbe>
   1ecd2:	3c01      	subs	r4, #1
   1ecd4:	2c03      	cmp	r4, #3
   1ecd6:	d852      	bhi.n	1ed7e <tls_interface_getopt+0xca>
   1ecd8:	e8df f004 	tbb	[pc, r4]
   1ecdc:	09152139 	.word	0x09152139
   1ece0:	200e      	movs	r0, #14
   1ece2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1ece6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1ecea:	f003 bffb 	b.w	22ce4 <ip_interface_getopt>
   1ecee:	683b      	ldr	r3, [r7, #0]
   1ecf0:	2b04      	cmp	r3, #4
   1ecf2:	d13c      	bne.n	1ed6e <tls_interface_getopt+0xba>
   1ecf4:	4b23      	ldr	r3, [pc, #140]	; (1ed84 <tls_interface_getopt+0xd0>)
   1ecf6:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   1ecfa:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   1ecfe:	78b3      	ldrb	r3, [r6, #2]
   1ed00:	2000      	movs	r0, #0
   1ed02:	602b      	str	r3, [r5, #0]
   1ed04:	e7ed      	b.n	1ece2 <tls_interface_getopt+0x2e>
   1ed06:	683b      	ldr	r3, [r7, #0]
   1ed08:	2b01      	cmp	r3, #1
   1ed0a:	d130      	bne.n	1ed6e <tls_interface_getopt+0xba>
   1ed0c:	4b1d      	ldr	r3, [pc, #116]	; (1ed84 <tls_interface_getopt+0xd0>)
   1ed0e:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   1ed12:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   1ed16:	7873      	ldrb	r3, [r6, #1]
   1ed18:	2000      	movs	r0, #0
   1ed1a:	702b      	strb	r3, [r5, #0]
   1ed1c:	e7e1      	b.n	1ece2 <tls_interface_getopt+0x2e>
   1ed1e:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   1ed22:	4918      	ldr	r1, [pc, #96]	; (1ed84 <tls_interface_getopt+0xd0>)
   1ed24:	683b      	ldr	r3, [r7, #0]
   1ed26:	00b6      	lsls	r6, r6, #2
   1ed28:	198a      	adds	r2, r1, r6
   1ed2a:	f013 0403 	ands.w	r4, r3, #3
   1ed2e:	78d0      	ldrb	r0, [r2, #3]
   1ed30:	d121      	bne.n	1ed76 <tls_interface_getopt+0xc2>
   1ed32:	089b      	lsrs	r3, r3, #2
   1ed34:	4283      	cmp	r3, r0
   1ed36:	bf28      	it	cs
   1ed38:	4603      	movcs	r3, r0
   1ed3a:	009a      	lsls	r2, r3, #2
   1ed3c:	b1db      	cbz	r3, 1ed76 <tls_interface_getopt+0xc2>
   1ed3e:	3604      	adds	r6, #4
   1ed40:	4431      	add	r1, r6
   1ed42:	603a      	str	r2, [r7, #0]
   1ed44:	4628      	mov	r0, r5
   1ed46:	f010 fb05 	bl	2f354 <memcpy>
   1ed4a:	4620      	mov	r0, r4
   1ed4c:	e7c9      	b.n	1ece2 <tls_interface_getopt+0x2e>
   1ed4e:	683b      	ldr	r3, [r7, #0]
   1ed50:	2b04      	cmp	r3, #4
   1ed52:	d10c      	bne.n	1ed6e <tls_interface_getopt+0xba>
   1ed54:	4b0b      	ldr	r3, [pc, #44]	; (1ed84 <tls_interface_getopt+0xd0>)
   1ed56:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   1ed5a:	f813 3026 	ldrb.w	r3, [r3, r6, lsl #2]
   1ed5e:	2000      	movs	r0, #0
   1ed60:	f1a3 0301 	sub.w	r3, r3, #1
   1ed64:	fab3 f383 	clz	r3, r3
   1ed68:	095b      	lsrs	r3, r3, #5
   1ed6a:	602b      	str	r3, [r5, #0]
   1ed6c:	e7b9      	b.n	1ece2 <tls_interface_getopt+0x2e>
   1ed6e:	2016      	movs	r0, #22
   1ed70:	e7b7      	b.n	1ece2 <tls_interface_getopt+0x2e>
   1ed72:	2009      	movs	r0, #9
   1ed74:	e7b5      	b.n	1ece2 <tls_interface_getopt+0x2e>
   1ed76:	2800      	cmp	r0, #0
   1ed78:	d1f9      	bne.n	1ed6e <tls_interface_getopt+0xba>
   1ed7a:	6038      	str	r0, [r7, #0]
   1ed7c:	e7b1      	b.n	1ece2 <tls_interface_getopt+0x2e>
   1ed7e:	202a      	movs	r0, #42	; 0x2a
   1ed80:	e7af      	b.n	1ece2 <tls_interface_getopt+0x2e>
   1ed82:	bf00      	nop
   1ed84:	20028b54 	.word	0x20028b54

0001ed88 <tls_rpc_ip_event_handler>:
   1ed88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ed8a:	f248 0581 	movw	r5, #32897	; 0x8081
   1ed8e:	42ab      	cmp	r3, r5
   1ed90:	460c      	mov	r4, r1
   1ed92:	d062      	beq.n	1ee5a <tls_rpc_ip_event_handler+0xd2>
   1ed94:	f249 0182 	movw	r1, #36994	; 0x9082
   1ed98:	428b      	cmp	r3, r1
   1ed9a:	4606      	mov	r6, r0
   1ed9c:	d02e      	beq.n	1edfc <tls_rpc_ip_event_handler+0x74>
   1ed9e:	f248 0102 	movw	r1, #32770	; 0x8002
   1eda2:	428b      	cmp	r3, r1
   1eda4:	d001      	beq.n	1edaa <tls_rpc_ip_event_handler+0x22>
   1eda6:	2001      	movs	r0, #1
   1eda8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1edaa:	2c00      	cmp	r4, #0
   1edac:	d0fb      	beq.n	1eda6 <tls_rpc_ip_event_handler+0x1e>
   1edae:	6963      	ldr	r3, [r4, #20]
   1edb0:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
   1edb4:	d002      	beq.n	1edbc <tls_rpc_ip_event_handler+0x34>
   1edb6:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   1edba:	d1f4      	bne.n	1eda6 <tls_rpc_ip_event_handler+0x1e>
   1edbc:	6823      	ldr	r3, [r4, #0]
   1edbe:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   1edc2:	6023      	str	r3, [r4, #0]
   1edc4:	6955      	ldr	r5, [r2, #20]
   1edc6:	2d00      	cmp	r5, #0
   1edc8:	d156      	bne.n	1ee78 <tls_rpc_ip_event_handler+0xf0>
   1edca:	6823      	ldr	r3, [r4, #0]
   1edcc:	0c1b      	lsrs	r3, r3, #16
   1edce:	041b      	lsls	r3, r3, #16
   1edd0:	f043 0305 	orr.w	r3, r3, #5
   1edd4:	6023      	str	r3, [r4, #0]
   1edd6:	6823      	ldr	r3, [r4, #0]
   1edd8:	00da      	lsls	r2, r3, #3
   1edda:	d50d      	bpl.n	1edf8 <tls_rpc_ip_event_handler+0x70>
   1eddc:	4b2b      	ldr	r3, [pc, #172]	; (1ee8c <tls_rpc_ip_event_handler+0x104>)
   1edde:	eb06 02c6 	add.w	r2, r6, r6, lsl #3
   1ede2:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   1ede6:	2b02      	cmp	r3, #2
   1ede8:	d106      	bne.n	1edf8 <tls_rpc_ip_event_handler+0x70>
   1edea:	4630      	mov	r0, r6
   1edec:	4621      	mov	r1, r4
   1edee:	f7ff fb9b 	bl	1e528 <secure_client_socket>
   1edf2:	b108      	cbz	r0, 1edf8 <tls_rpc_ip_event_handler+0x70>
   1edf4:	2873      	cmp	r0, #115	; 0x73
   1edf6:	d142      	bne.n	1ee7e <tls_rpc_ip_event_handler+0xf6>
   1edf8:	2000      	movs	r0, #0
   1edfa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1edfc:	2c00      	cmp	r4, #0
   1edfe:	d0fb      	beq.n	1edf8 <tls_rpc_ip_event_handler+0x70>
   1ee00:	6823      	ldr	r3, [r4, #0]
   1ee02:	b29b      	uxth	r3, r3
   1ee04:	2b0b      	cmp	r3, #11
   1ee06:	d1f7      	bne.n	1edf8 <tls_rpc_ip_event_handler+0x70>
   1ee08:	6915      	ldr	r5, [r2, #16]
   1ee0a:	2d00      	cmp	r5, #0
   1ee0c:	d134      	bne.n	1ee78 <tls_rpc_ip_event_handler+0xf0>
   1ee0e:	6823      	ldr	r3, [r4, #0]
   1ee10:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   1ee14:	6023      	str	r3, [r4, #0]
   1ee16:	6823      	ldr	r3, [r4, #0]
   1ee18:	00db      	lsls	r3, r3, #3
   1ee1a:	d5ed      	bpl.n	1edf8 <tls_rpc_ip_event_handler+0x70>
   1ee1c:	4f1c      	ldr	r7, [pc, #112]	; (1ee90 <tls_rpc_ip_event_handler+0x108>)
   1ee1e:	f857 0030 	ldr.w	r0, [r7, r0, lsl #3]
   1ee22:	b130      	cbz	r0, 1ee32 <tls_rpc_ip_event_handler+0xaa>
   1ee24:	f7ff fb18 	bl	1e458 <nrf_free>
   1ee28:	eb07 03c6 	add.w	r3, r7, r6, lsl #3
   1ee2c:	f847 5036 	str.w	r5, [r7, r6, lsl #3]
   1ee30:	605d      	str	r5, [r3, #4]
   1ee32:	6823      	ldr	r3, [r4, #0]
   1ee34:	2000      	movs	r0, #0
   1ee36:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   1ee3a:	6023      	str	r3, [r4, #0]
   1ee3c:	6823      	ldr	r3, [r4, #0]
   1ee3e:	0c1b      	lsrs	r3, r3, #16
   1ee40:	041b      	lsls	r3, r3, #16
   1ee42:	f043 030c 	orr.w	r3, r3, #12
   1ee46:	6023      	str	r3, [r4, #0]
   1ee48:	6823      	ldr	r3, [r4, #0]
   1ee4a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1ee4e:	6023      	str	r3, [r4, #0]
   1ee50:	6823      	ldr	r3, [r4, #0]
   1ee52:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   1ee56:	6023      	str	r3, [r4, #0]
   1ee58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1ee5a:	2900      	cmp	r1, #0
   1ee5c:	d0cc      	beq.n	1edf8 <tls_rpc_ip_event_handler+0x70>
   1ee5e:	680b      	ldr	r3, [r1, #0]
   1ee60:	b29b      	uxth	r3, r3
   1ee62:	2b0a      	cmp	r3, #10
   1ee64:	d1c8      	bne.n	1edf8 <tls_rpc_ip_event_handler+0x70>
   1ee66:	6950      	ldr	r0, [r2, #20]
   1ee68:	b938      	cbnz	r0, 1ee7a <tls_rpc_ip_event_handler+0xf2>
   1ee6a:	680b      	ldr	r3, [r1, #0]
   1ee6c:	0c1b      	lsrs	r3, r3, #16
   1ee6e:	041b      	lsls	r3, r3, #16
   1ee70:	f043 030b 	orr.w	r3, r3, #11
   1ee74:	600b      	str	r3, [r1, #0]
   1ee76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1ee78:	4628      	mov	r0, r5
   1ee7a:	f002 ff37 	bl	21cec <rpc_error_to_nrf_bsd_error>
   1ee7e:	6060      	str	r0, [r4, #4]
   1ee80:	6823      	ldr	r3, [r4, #0]
   1ee82:	2000      	movs	r0, #0
   1ee84:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   1ee88:	6023      	str	r3, [r4, #0]
   1ee8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1ee8c:	20028b54 	.word	0x20028b54
   1ee90:	20028c98 	.word	0x20028c98

0001ee94 <rpc_dfu_event_handler>:
   1ee94:	b508      	push	{r3, lr}
   1ee96:	4a08      	ldr	r2, [pc, #32]	; (1eeb8 <rpc_dfu_event_handler+0x24>)
   1ee98:	68c1      	ldr	r1, [r0, #12]
   1ee9a:	8812      	ldrh	r2, [r2, #0]
   1ee9c:	4603      	mov	r3, r0
   1ee9e:	ebb2 4f11 	cmp.w	r2, r1, lsr #16
   1eea2:	d005      	beq.n	1eeb0 <rpc_dfu_event_handler+0x1c>
   1eea4:	6800      	ldr	r0, [r0, #0]
   1eea6:	b110      	cbz	r0, 1eeae <rpc_dfu_event_handler+0x1a>
   1eea8:	f7fe ff06 	bl	1dcb8 <rpc_dfu_client_data_free>
   1eeac:	2000      	movs	r0, #0
   1eeae:	bd08      	pop	{r3, pc}
   1eeb0:	4a02      	ldr	r2, [pc, #8]	; (1eebc <rpc_dfu_event_handler+0x28>)
   1eeb2:	2001      	movs	r0, #1
   1eeb4:	6013      	str	r3, [r2, #0]
   1eeb6:	bd08      	pop	{r3, pc}
   1eeb8:	2002d488 	.word	0x2002d488
   1eebc:	20028ce4 	.word	0x20028ce4

0001eec0 <mfu_interface_init>:
   1eec0:	2300      	movs	r3, #0
   1eec2:	b510      	push	{r4, lr}
   1eec4:	4808      	ldr	r0, [pc, #32]	; (1eee8 <mfu_interface_init+0x28>)
   1eec6:	4909      	ldr	r1, [pc, #36]	; (1eeec <mfu_interface_init+0x2c>)
   1eec8:	4a09      	ldr	r2, [pc, #36]	; (1eef0 <mfu_interface_init+0x30>)
   1eeca:	4c0a      	ldr	r4, [pc, #40]	; (1eef4 <mfu_interface_init+0x34>)
   1eecc:	8003      	strh	r3, [r0, #0]
   1eece:	600b      	str	r3, [r1, #0]
   1eed0:	6013      	str	r3, [r2, #0]
   1eed2:	6023      	str	r3, [r4, #0]
   1eed4:	f7fe feba 	bl	1dc4c <rpc_dfu_client_init>
   1eed8:	b910      	cbnz	r0, 1eee0 <mfu_interface_init+0x20>
   1eeda:	2301      	movs	r3, #1
   1eedc:	6023      	str	r3, [r4, #0]
   1eede:	bd10      	pop	{r4, pc}
   1eee0:	f04f 30ff 	mov.w	r0, #4294967295
   1eee4:	bd10      	pop	{r4, pc}
   1eee6:	bf00      	nop
   1eee8:	2002d488 	.word	0x2002d488
   1eeec:	20028ce4 	.word	0x20028ce4
   1eef0:	20028ce0 	.word	0x20028ce0
   1eef4:	20028cd8 	.word	0x20028cd8

0001eef8 <mfu_interface_open>:
   1eef8:	b508      	push	{r3, lr}
   1eefa:	4b07      	ldr	r3, [pc, #28]	; (1ef18 <mfu_interface_open+0x20>)
   1eefc:	681a      	ldr	r2, [r3, #0]
   1eefe:	2a01      	cmp	r2, #1
   1ef00:	d103      	bne.n	1ef0a <mfu_interface_open+0x12>
   1ef02:	2202      	movs	r2, #2
   1ef04:	601a      	str	r2, [r3, #0]
   1ef06:	4805      	ldr	r0, [pc, #20]	; (1ef1c <mfu_interface_open+0x24>)
   1ef08:	bd08      	pop	{r3, pc}
   1ef0a:	2001      	movs	r0, #1
   1ef0c:	f7fc fc2e 	bl	1b76c <bsd_os_errno_set>
   1ef10:	f04f 30ff 	mov.w	r0, #4294967295
   1ef14:	bd08      	pop	{r3, pc}
   1ef16:	bf00      	nop
   1ef18:	20028cd8 	.word	0x20028cd8
   1ef1c:	49765432 	.word	0x49765432

0001ef20 <mfu_interface_close>:
   1ef20:	b5f0      	push	{r4, r5, r6, r7, lr}
   1ef22:	4c32      	ldr	r4, [pc, #200]	; (1efec <mfu_interface_close+0xcc>)
   1ef24:	b083      	sub	sp, #12
   1ef26:	6823      	ldr	r3, [r4, #0]
   1ef28:	1e9a      	subs	r2, r3, #2
   1ef2a:	2a01      	cmp	r2, #1
   1ef2c:	d857      	bhi.n	1efde <mfu_interface_close+0xbe>
   1ef2e:	2b03      	cmp	r3, #3
   1ef30:	d004      	beq.n	1ef3c <mfu_interface_close+0x1c>
   1ef32:	2301      	movs	r3, #1
   1ef34:	2000      	movs	r0, #0
   1ef36:	6023      	str	r3, [r4, #0]
   1ef38:	b003      	add	sp, #12
   1ef3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1ef3c:	2100      	movs	r1, #0
   1ef3e:	4668      	mov	r0, sp
   1ef40:	f7fe fe8a 	bl	1dc58 <rpc_dfu_client_request_alloc>
   1ef44:	4603      	mov	r3, r0
   1ef46:	2800      	cmp	r0, #0
   1ef48:	d13d      	bne.n	1efc6 <mfu_interface_close+0xa6>
   1ef4a:	2104      	movs	r1, #4
   1ef4c:	4e28      	ldr	r6, [pc, #160]	; (1eff0 <mfu_interface_close+0xd0>)
   1ef4e:	9800      	ldr	r0, [sp, #0]
   1ef50:	8832      	ldrh	r2, [r6, #0]
   1ef52:	7201      	strb	r1, [r0, #8]
   1ef54:	3201      	adds	r2, #1
   1ef56:	b292      	uxth	r2, r2
   1ef58:	0411      	lsls	r1, r2, #16
   1ef5a:	f041 0106 	orr.w	r1, r1, #6
   1ef5e:	4d25      	ldr	r5, [pc, #148]	; (1eff4 <mfu_interface_close+0xd4>)
   1ef60:	60c1      	str	r1, [r0, #12]
   1ef62:	7103      	strb	r3, [r0, #4]
   1ef64:	7143      	strb	r3, [r0, #5]
   1ef66:	7183      	strb	r3, [r0, #6]
   1ef68:	71c3      	strb	r3, [r0, #7]
   1ef6a:	7243      	strb	r3, [r0, #9]
   1ef6c:	7283      	strb	r3, [r0, #10]
   1ef6e:	72c3      	strb	r3, [r0, #11]
   1ef70:	2106      	movs	r1, #6
   1ef72:	8032      	strh	r2, [r6, #0]
   1ef74:	602b      	str	r3, [r5, #0]
   1ef76:	f7fe fe83 	bl	1dc80 <rpc_dfu_client_request_send>
   1ef7a:	b9d8      	cbnz	r0, 1efb4 <mfu_interface_close+0x94>
   1ef7c:	f04f 33ff 	mov.w	r3, #4294967295
   1ef80:	ae02      	add	r6, sp, #8
   1ef82:	4627      	mov	r7, r4
   1ef84:	f846 3d04 	str.w	r3, [r6, #-4]!
   1ef88:	e004      	b.n	1ef94 <mfu_interface_close+0x74>
   1ef8a:	4631      	mov	r1, r6
   1ef8c:	4638      	mov	r0, r7
   1ef8e:	f7fc fb59 	bl	1b644 <bsd_os_timedwait>
   1ef92:	b9f0      	cbnz	r0, 1efd2 <mfu_interface_close+0xb2>
   1ef94:	6828      	ldr	r0, [r5, #0]
   1ef96:	2800      	cmp	r0, #0
   1ef98:	d0f7      	beq.n	1ef8a <mfu_interface_close+0x6a>
   1ef9a:	6905      	ldr	r5, [r0, #16]
   1ef9c:	f7fe fe84 	bl	1dca8 <rpc_dfu_client_message_free>
   1efa0:	2d00      	cmp	r5, #0
   1efa2:	d0c6      	beq.n	1ef32 <mfu_interface_close+0x12>
   1efa4:	4b14      	ldr	r3, [pc, #80]	; (1eff8 <mfu_interface_close+0xd8>)
   1efa6:	2008      	movs	r0, #8
   1efa8:	601d      	str	r5, [r3, #0]
   1efaa:	f7fc fbdf 	bl	1b76c <bsd_os_errno_set>
   1efae:	f04f 30ff 	mov.w	r0, #4294967295
   1efb2:	e7c1      	b.n	1ef38 <mfu_interface_close+0x18>
   1efb4:	9800      	ldr	r0, [sp, #0]
   1efb6:	6803      	ldr	r3, [r0, #0]
   1efb8:	b11b      	cbz	r3, 1efc2 <mfu_interface_close+0xa2>
   1efba:	4618      	mov	r0, r3
   1efbc:	f7fe fe7c 	bl	1dcb8 <rpc_dfu_client_data_free>
   1efc0:	9800      	ldr	r0, [sp, #0]
   1efc2:	f7fe fe71 	bl	1dca8 <rpc_dfu_client_message_free>
   1efc6:	200c      	movs	r0, #12
   1efc8:	f7fc fbd0 	bl	1b76c <bsd_os_errno_set>
   1efcc:	f04f 30ff 	mov.w	r0, #4294967295
   1efd0:	e7b2      	b.n	1ef38 <mfu_interface_close+0x18>
   1efd2:	203c      	movs	r0, #60	; 0x3c
   1efd4:	f7fc fbca 	bl	1b76c <bsd_os_errno_set>
   1efd8:	f04f 30ff 	mov.w	r0, #4294967295
   1efdc:	e7ac      	b.n	1ef38 <mfu_interface_close+0x18>
   1efde:	2001      	movs	r0, #1
   1efe0:	f7fc fbc4 	bl	1b76c <bsd_os_errno_set>
   1efe4:	f04f 30ff 	mov.w	r0, #4294967295
   1efe8:	e7a6      	b.n	1ef38 <mfu_interface_close+0x18>
   1efea:	bf00      	nop
   1efec:	20028cd8 	.word	0x20028cd8
   1eff0:	2002d488 	.word	0x2002d488
   1eff4:	20028ce4 	.word	0x20028ce4
   1eff8:	20028cdc 	.word	0x20028cdc

0001effc <mfu_interface_sendto>:
   1effc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1f000:	4e64      	ldr	r6, [pc, #400]	; (1f194 <mfu_interface_sendto+0x198>)
   1f002:	460f      	mov	r7, r1
   1f004:	6831      	ldr	r1, [r6, #0]
   1f006:	4615      	mov	r5, r2
   1f008:	1e8a      	subs	r2, r1, #2
   1f00a:	2a01      	cmp	r2, #1
   1f00c:	b082      	sub	sp, #8
   1f00e:	f200 80b4 	bhi.w	1f17a <mfu_interface_sendto+0x17e>
   1f012:	2f00      	cmp	r7, #0
   1f014:	f000 80a5 	beq.w	1f162 <mfu_interface_sendto+0x166>
   1f018:	2d00      	cmp	r5, #0
   1f01a:	f000 80a2 	beq.w	1f162 <mfu_interface_sendto+0x166>
   1f01e:	2b00      	cmp	r3, #0
   1f020:	f040 80b1 	bne.w	1f186 <mfu_interface_sendto+0x18a>
   1f024:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1f026:	2b00      	cmp	r3, #0
   1f028:	f040 80a1 	bne.w	1f16e <mfu_interface_sendto+0x172>
   1f02c:	2902      	cmp	r1, #2
   1f02e:	d04f      	beq.n	1f0d0 <mfu_interface_sendto+0xd4>
   1f030:	46e8      	mov	r8, sp
   1f032:	4640      	mov	r0, r8
   1f034:	4629      	mov	r1, r5
   1f036:	f7fe fe0f 	bl	1dc58 <rpc_dfu_client_request_alloc>
   1f03a:	4606      	mov	r6, r0
   1f03c:	b140      	cbz	r0, 1f050 <mfu_interface_sendto+0x54>
   1f03e:	200c      	movs	r0, #12
   1f040:	f7fc fb94 	bl	1b76c <bsd_os_errno_set>
   1f044:	f04f 35ff 	mov.w	r5, #4294967295
   1f048:	4628      	mov	r0, r5
   1f04a:	b002      	add	sp, #8
   1f04c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1f050:	9b00      	ldr	r3, [sp, #0]
   1f052:	4639      	mov	r1, r7
   1f054:	6818      	ldr	r0, [r3, #0]
   1f056:	462a      	mov	r2, r5
   1f058:	f010 f97c 	bl	2f354 <memcpy>
   1f05c:	2104      	movs	r1, #4
   1f05e:	4c4e      	ldr	r4, [pc, #312]	; (1f198 <mfu_interface_sendto+0x19c>)
   1f060:	9800      	ldr	r0, [sp, #0]
   1f062:	8823      	ldrh	r3, [r4, #0]
   1f064:	6045      	str	r5, [r0, #4]
   1f066:	3301      	adds	r3, #1
   1f068:	b29b      	uxth	r3, r3
   1f06a:	041a      	lsls	r2, r3, #16
   1f06c:	8023      	strh	r3, [r4, #0]
   1f06e:	430a      	orrs	r2, r1
   1f070:	4c4a      	ldr	r4, [pc, #296]	; (1f19c <mfu_interface_sendto+0x1a0>)
   1f072:	60c2      	str	r2, [r0, #12]
   1f074:	7246      	strb	r6, [r0, #9]
   1f076:	7286      	strb	r6, [r0, #10]
   1f078:	72c6      	strb	r6, [r0, #11]
   1f07a:	7201      	strb	r1, [r0, #8]
   1f07c:	6026      	str	r6, [r4, #0]
   1f07e:	f7fe fdff 	bl	1dc80 <rpc_dfu_client_request_send>
   1f082:	2800      	cmp	r0, #0
   1f084:	d163      	bne.n	1f14e <mfu_interface_sendto+0x152>
   1f086:	f04f 33ff 	mov.w	r3, #4294967295
   1f08a:	ae02      	add	r6, sp, #8
   1f08c:	4f41      	ldr	r7, [pc, #260]	; (1f194 <mfu_interface_sendto+0x198>)
   1f08e:	f846 3d04 	str.w	r3, [r6, #-4]!
   1f092:	e004      	b.n	1f09e <mfu_interface_sendto+0xa2>
   1f094:	4631      	mov	r1, r6
   1f096:	4638      	mov	r0, r7
   1f098:	f7fc fad4 	bl	1b644 <bsd_os_timedwait>
   1f09c:	b978      	cbnz	r0, 1f0be <mfu_interface_sendto+0xc2>
   1f09e:	6820      	ldr	r0, [r4, #0]
   1f0a0:	2800      	cmp	r0, #0
   1f0a2:	d0f7      	beq.n	1f094 <mfu_interface_sendto+0x98>
   1f0a4:	6904      	ldr	r4, [r0, #16]
   1f0a6:	f7fe fdff 	bl	1dca8 <rpc_dfu_client_message_free>
   1f0aa:	2c00      	cmp	r4, #0
   1f0ac:	d0cc      	beq.n	1f048 <mfu_interface_sendto+0x4c>
   1f0ae:	4b3c      	ldr	r3, [pc, #240]	; (1f1a0 <mfu_interface_sendto+0x1a4>)
   1f0b0:	2008      	movs	r0, #8
   1f0b2:	601c      	str	r4, [r3, #0]
   1f0b4:	f04f 35ff 	mov.w	r5, #4294967295
   1f0b8:	f7fc fb58 	bl	1b76c <bsd_os_errno_set>
   1f0bc:	e7c4      	b.n	1f048 <mfu_interface_sendto+0x4c>
   1f0be:	f04f 35ff 	mov.w	r5, #4294967295
   1f0c2:	203c      	movs	r0, #60	; 0x3c
   1f0c4:	f7fc fb52 	bl	1b76c <bsd_os_errno_set>
   1f0c8:	4628      	mov	r0, r5
   1f0ca:	b002      	add	sp, #8
   1f0cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1f0d0:	46e8      	mov	r8, sp
   1f0d2:	4619      	mov	r1, r3
   1f0d4:	4640      	mov	r0, r8
   1f0d6:	f7fe fdbf 	bl	1dc58 <rpc_dfu_client_request_alloc>
   1f0da:	4602      	mov	r2, r0
   1f0dc:	2800      	cmp	r0, #0
   1f0de:	d1ae      	bne.n	1f03e <mfu_interface_sendto+0x42>
   1f0e0:	f04f 0c08 	mov.w	ip, #8
   1f0e4:	492c      	ldr	r1, [pc, #176]	; (1f198 <mfu_interface_sendto+0x19c>)
   1f0e6:	482f      	ldr	r0, [pc, #188]	; (1f1a4 <mfu_interface_sendto+0x1a8>)
   1f0e8:	880b      	ldrh	r3, [r1, #0]
   1f0ea:	6804      	ldr	r4, [r0, #0]
   1f0ec:	3301      	adds	r3, #1
   1f0ee:	9800      	ldr	r0, [sp, #0]
   1f0f0:	b29b      	uxth	r3, r3
   1f0f2:	800b      	strh	r3, [r1, #0]
   1f0f4:	041b      	lsls	r3, r3, #16
   1f0f6:	f043 0303 	orr.w	r3, r3, #3
   1f0fa:	6104      	str	r4, [r0, #16]
   1f0fc:	4c27      	ldr	r4, [pc, #156]	; (1f19c <mfu_interface_sendto+0x1a0>)
   1f0fe:	60c3      	str	r3, [r0, #12]
   1f100:	7102      	strb	r2, [r0, #4]
   1f102:	7142      	strb	r2, [r0, #5]
   1f104:	7182      	strb	r2, [r0, #6]
   1f106:	71c2      	strb	r2, [r0, #7]
   1f108:	7242      	strb	r2, [r0, #9]
   1f10a:	7282      	strb	r2, [r0, #10]
   1f10c:	72c2      	strb	r2, [r0, #11]
   1f10e:	f880 c008 	strb.w	ip, [r0, #8]
   1f112:	2103      	movs	r1, #3
   1f114:	6022      	str	r2, [r4, #0]
   1f116:	f7fe fdb3 	bl	1dc80 <rpc_dfu_client_request_send>
   1f11a:	b9c0      	cbnz	r0, 1f14e <mfu_interface_sendto+0x152>
   1f11c:	f04f 33ff 	mov.w	r3, #4294967295
   1f120:	f10d 0908 	add.w	r9, sp, #8
   1f124:	f849 3d04 	str.w	r3, [r9, #-4]!
   1f128:	46b2      	mov	sl, r6
   1f12a:	e005      	b.n	1f138 <mfu_interface_sendto+0x13c>
   1f12c:	4649      	mov	r1, r9
   1f12e:	4650      	mov	r0, sl
   1f130:	f7fc fa88 	bl	1b644 <bsd_os_timedwait>
   1f134:	2800      	cmp	r0, #0
   1f136:	d1c2      	bne.n	1f0be <mfu_interface_sendto+0xc2>
   1f138:	6820      	ldr	r0, [r4, #0]
   1f13a:	2800      	cmp	r0, #0
   1f13c:	d0f6      	beq.n	1f12c <mfu_interface_sendto+0x130>
   1f13e:	6904      	ldr	r4, [r0, #16]
   1f140:	f7fe fdb2 	bl	1dca8 <rpc_dfu_client_message_free>
   1f144:	2c00      	cmp	r4, #0
   1f146:	d1b2      	bne.n	1f0ae <mfu_interface_sendto+0xb2>
   1f148:	2303      	movs	r3, #3
   1f14a:	6033      	str	r3, [r6, #0]
   1f14c:	e771      	b.n	1f032 <mfu_interface_sendto+0x36>
   1f14e:	9800      	ldr	r0, [sp, #0]
   1f150:	6803      	ldr	r3, [r0, #0]
   1f152:	b11b      	cbz	r3, 1f15c <mfu_interface_sendto+0x160>
   1f154:	4618      	mov	r0, r3
   1f156:	f7fe fdaf 	bl	1dcb8 <rpc_dfu_client_data_free>
   1f15a:	9800      	ldr	r0, [sp, #0]
   1f15c:	f7fe fda4 	bl	1dca8 <rpc_dfu_client_message_free>
   1f160:	e76d      	b.n	1f03e <mfu_interface_sendto+0x42>
   1f162:	2016      	movs	r0, #22
   1f164:	f7fc fb02 	bl	1b76c <bsd_os_errno_set>
   1f168:	f04f 35ff 	mov.w	r5, #4294967295
   1f16c:	e76c      	b.n	1f048 <mfu_interface_sendto+0x4c>
   1f16e:	2038      	movs	r0, #56	; 0x38
   1f170:	f7fc fafc 	bl	1b76c <bsd_os_errno_set>
   1f174:	f04f 35ff 	mov.w	r5, #4294967295
   1f178:	e766      	b.n	1f048 <mfu_interface_sendto+0x4c>
   1f17a:	2001      	movs	r0, #1
   1f17c:	f7fc faf6 	bl	1b76c <bsd_os_errno_set>
   1f180:	f04f 35ff 	mov.w	r5, #4294967295
   1f184:	e760      	b.n	1f048 <mfu_interface_sendto+0x4c>
   1f186:	202d      	movs	r0, #45	; 0x2d
   1f188:	f7fc faf0 	bl	1b76c <bsd_os_errno_set>
   1f18c:	f04f 35ff 	mov.w	r5, #4294967295
   1f190:	e75a      	b.n	1f048 <mfu_interface_sendto+0x4c>
   1f192:	bf00      	nop
   1f194:	20028cd8 	.word	0x20028cd8
   1f198:	2002d488 	.word	0x2002d488
   1f19c:	20028ce4 	.word	0x20028ce4
   1f1a0:	20028cdc 	.word	0x20028cdc
   1f1a4:	20028ce0 	.word	0x20028ce0

0001f1a8 <mfu_interface_setopt>:
   1f1a8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f1aa:	4846      	ldr	r0, [pc, #280]	; (1f2c4 <mfu_interface_setopt+0x11c>)
   1f1ac:	b083      	sub	sp, #12
   1f1ae:	6800      	ldr	r0, [r0, #0]
   1f1b0:	3802      	subs	r0, #2
   1f1b2:	2801      	cmp	r0, #1
   1f1b4:	d877      	bhi.n	1f2a6 <mfu_interface_setopt+0xfe>
   1f1b6:	f240 2003 	movw	r0, #515	; 0x203
   1f1ba:	4281      	cmp	r1, r0
   1f1bc:	d16d      	bne.n	1f29a <mfu_interface_setopt+0xf2>
   1f1be:	3a04      	subs	r2, #4
   1f1c0:	2a03      	cmp	r2, #3
   1f1c2:	d85c      	bhi.n	1f27e <mfu_interface_setopt+0xd6>
   1f1c4:	e8df f002 	tbb	[pc, r2]
   1f1c8:	514e024b 	.word	0x514e024b
   1f1cc:	2407      	movs	r4, #7
   1f1ce:	4625      	mov	r5, r4
   1f1d0:	2100      	movs	r1, #0
   1f1d2:	4668      	mov	r0, sp
   1f1d4:	f7fe fd40 	bl	1dc58 <rpc_dfu_client_request_alloc>
   1f1d8:	4603      	mov	r3, r0
   1f1da:	2800      	cmp	r0, #0
   1f1dc:	d138      	bne.n	1f250 <mfu_interface_setopt+0xa8>
   1f1de:	2704      	movs	r7, #4
   1f1e0:	4e39      	ldr	r6, [pc, #228]	; (1f2c8 <mfu_interface_setopt+0x120>)
   1f1e2:	9800      	ldr	r0, [sp, #0]
   1f1e4:	8832      	ldrh	r2, [r6, #0]
   1f1e6:	4629      	mov	r1, r5
   1f1e8:	3201      	adds	r2, #1
   1f1ea:	b292      	uxth	r2, r2
   1f1ec:	ea44 4502 	orr.w	r5, r4, r2, lsl #16
   1f1f0:	4c36      	ldr	r4, [pc, #216]	; (1f2cc <mfu_interface_setopt+0x124>)
   1f1f2:	60c5      	str	r5, [r0, #12]
   1f1f4:	7103      	strb	r3, [r0, #4]
   1f1f6:	7143      	strb	r3, [r0, #5]
   1f1f8:	7183      	strb	r3, [r0, #6]
   1f1fa:	71c3      	strb	r3, [r0, #7]
   1f1fc:	7243      	strb	r3, [r0, #9]
   1f1fe:	7283      	strb	r3, [r0, #10]
   1f200:	72c3      	strb	r3, [r0, #11]
   1f202:	7207      	strb	r7, [r0, #8]
   1f204:	8032      	strh	r2, [r6, #0]
   1f206:	6023      	str	r3, [r4, #0]
   1f208:	f7fe fd3a 	bl	1dc80 <rpc_dfu_client_request_send>
   1f20c:	b9b8      	cbnz	r0, 1f23e <mfu_interface_setopt+0x96>
   1f20e:	f04f 33ff 	mov.w	r3, #4294967295
   1f212:	ad02      	add	r5, sp, #8
   1f214:	4e2b      	ldr	r6, [pc, #172]	; (1f2c4 <mfu_interface_setopt+0x11c>)
   1f216:	f845 3d04 	str.w	r3, [r5, #-4]!
   1f21a:	e005      	b.n	1f228 <mfu_interface_setopt+0x80>
   1f21c:	4629      	mov	r1, r5
   1f21e:	4630      	mov	r0, r6
   1f220:	f7fc fa10 	bl	1b644 <bsd_os_timedwait>
   1f224:	2800      	cmp	r0, #0
   1f226:	d131      	bne.n	1f28c <mfu_interface_setopt+0xe4>
   1f228:	6820      	ldr	r0, [r4, #0]
   1f22a:	2800      	cmp	r0, #0
   1f22c:	d0f6      	beq.n	1f21c <mfu_interface_setopt+0x74>
   1f22e:	6904      	ldr	r4, [r0, #16]
   1f230:	f7fe fd3a 	bl	1dca8 <rpc_dfu_client_message_free>
   1f234:	2c00      	cmp	r4, #0
   1f236:	d13c      	bne.n	1f2b2 <mfu_interface_setopt+0x10a>
   1f238:	4620      	mov	r0, r4
   1f23a:	b003      	add	sp, #12
   1f23c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f23e:	9800      	ldr	r0, [sp, #0]
   1f240:	6803      	ldr	r3, [r0, #0]
   1f242:	b11b      	cbz	r3, 1f24c <mfu_interface_setopt+0xa4>
   1f244:	4618      	mov	r0, r3
   1f246:	f7fe fd37 	bl	1dcb8 <rpc_dfu_client_data_free>
   1f24a:	9800      	ldr	r0, [sp, #0]
   1f24c:	f7fe fd2c 	bl	1dca8 <rpc_dfu_client_message_free>
   1f250:	200c      	movs	r0, #12
   1f252:	f7fc fa8b 	bl	1b76c <bsd_os_errno_set>
   1f256:	f04f 30ff 	mov.w	r0, #4294967295
   1f25a:	b003      	add	sp, #12
   1f25c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f25e:	2405      	movs	r4, #5
   1f260:	4625      	mov	r5, r4
   1f262:	e7b5      	b.n	1f1d0 <mfu_interface_setopt+0x28>
   1f264:	2408      	movs	r4, #8
   1f266:	4625      	mov	r5, r4
   1f268:	e7b2      	b.n	1f1d0 <mfu_interface_setopt+0x28>
   1f26a:	b1b3      	cbz	r3, 1f29a <mfu_interface_setopt+0xf2>
   1f26c:	9a08      	ldr	r2, [sp, #32]
   1f26e:	2a04      	cmp	r2, #4
   1f270:	d113      	bne.n	1f29a <mfu_interface_setopt+0xf2>
   1f272:	2000      	movs	r0, #0
   1f274:	681a      	ldr	r2, [r3, #0]
   1f276:	4b16      	ldr	r3, [pc, #88]	; (1f2d0 <mfu_interface_setopt+0x128>)
   1f278:	601a      	str	r2, [r3, #0]
   1f27a:	b003      	add	sp, #12
   1f27c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f27e:	202a      	movs	r0, #42	; 0x2a
   1f280:	f7fc fa74 	bl	1b76c <bsd_os_errno_set>
   1f284:	f04f 30ff 	mov.w	r0, #4294967295
   1f288:	b003      	add	sp, #12
   1f28a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f28c:	203c      	movs	r0, #60	; 0x3c
   1f28e:	f7fc fa6d 	bl	1b76c <bsd_os_errno_set>
   1f292:	f04f 30ff 	mov.w	r0, #4294967295
   1f296:	b003      	add	sp, #12
   1f298:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f29a:	2016      	movs	r0, #22
   1f29c:	f7fc fa66 	bl	1b76c <bsd_os_errno_set>
   1f2a0:	f04f 30ff 	mov.w	r0, #4294967295
   1f2a4:	e7c9      	b.n	1f23a <mfu_interface_setopt+0x92>
   1f2a6:	2001      	movs	r0, #1
   1f2a8:	f7fc fa60 	bl	1b76c <bsd_os_errno_set>
   1f2ac:	f04f 30ff 	mov.w	r0, #4294967295
   1f2b0:	e7c3      	b.n	1f23a <mfu_interface_setopt+0x92>
   1f2b2:	4b08      	ldr	r3, [pc, #32]	; (1f2d4 <mfu_interface_setopt+0x12c>)
   1f2b4:	2008      	movs	r0, #8
   1f2b6:	601c      	str	r4, [r3, #0]
   1f2b8:	f7fc fa58 	bl	1b76c <bsd_os_errno_set>
   1f2bc:	f04f 30ff 	mov.w	r0, #4294967295
   1f2c0:	e7bb      	b.n	1f23a <mfu_interface_setopt+0x92>
   1f2c2:	bf00      	nop
   1f2c4:	20028cd8 	.word	0x20028cd8
   1f2c8:	2002d488 	.word	0x2002d488
   1f2cc:	20028ce4 	.word	0x20028ce4
   1f2d0:	20028ce0 	.word	0x20028ce0
   1f2d4:	20028cdc 	.word	0x20028cdc

0001f2d8 <mfu_interface_getopt>:
   1f2d8:	f240 2003 	movw	r0, #515	; 0x203
   1f2dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1f2e0:	4281      	cmp	r1, r0
   1f2e2:	b082      	sub	sp, #8
   1f2e4:	9e08      	ldr	r6, [sp, #32]
   1f2e6:	f040 80ae 	bne.w	1f446 <mfu_interface_getopt+0x16e>
   1f2ea:	461d      	mov	r5, r3
   1f2ec:	2b00      	cmp	r3, #0
   1f2ee:	f000 80aa 	beq.w	1f446 <mfu_interface_getopt+0x16e>
   1f2f2:	2e00      	cmp	r6, #0
   1f2f4:	f000 80a7 	beq.w	1f446 <mfu_interface_getopt+0x16e>
   1f2f8:	4b5e      	ldr	r3, [pc, #376]	; (1f474 <mfu_interface_getopt+0x19c>)
   1f2fa:	681b      	ldr	r3, [r3, #0]
   1f2fc:	3b02      	subs	r3, #2
   1f2fe:	2b01      	cmp	r3, #1
   1f300:	f200 80a7 	bhi.w	1f452 <mfu_interface_getopt+0x17a>
   1f304:	3a01      	subs	r2, #1
   1f306:	2a13      	cmp	r2, #19
   1f308:	d879      	bhi.n	1f3fe <mfu_interface_getopt+0x126>
   1f30a:	e8df f002 	tbb	[pc, r2]
   1f30e:	5f17      	.short	0x5f17
   1f310:	78787878 	.word	0x78787878
   1f314:	78787872 	.word	0x78787872
   1f318:	78787878 	.word	0x78787878
   1f31c:	78787878 	.word	0x78787878
   1f320:	0a78      	.short	0x0a78
   1f322:	6833      	ldr	r3, [r6, #0]
   1f324:	2b04      	cmp	r3, #4
   1f326:	f040 808e 	bne.w	1f446 <mfu_interface_getopt+0x16e>
   1f32a:	2200      	movs	r2, #0
   1f32c:	4610      	mov	r0, r2
   1f32e:	4b52      	ldr	r3, [pc, #328]	; (1f478 <mfu_interface_getopt+0x1a0>)
   1f330:	6819      	ldr	r1, [r3, #0]
   1f332:	601a      	str	r2, [r3, #0]
   1f334:	6029      	str	r1, [r5, #0]
   1f336:	b002      	add	sp, #8
   1f338:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1f33c:	6833      	ldr	r3, [r6, #0]
   1f33e:	2b24      	cmp	r3, #36	; 0x24
   1f340:	f040 8081 	bne.w	1f446 <mfu_interface_getopt+0x16e>
   1f344:	2401      	movs	r4, #1
   1f346:	46a0      	mov	r8, r4
   1f348:	2100      	movs	r1, #0
   1f34a:	4668      	mov	r0, sp
   1f34c:	f7fe fc84 	bl	1dc58 <rpc_dfu_client_request_alloc>
   1f350:	2800      	cmp	r0, #0
   1f352:	d146      	bne.n	1f3e2 <mfu_interface_getopt+0x10a>
   1f354:	4949      	ldr	r1, [pc, #292]	; (1f47c <mfu_interface_getopt+0x1a4>)
   1f356:	9b00      	ldr	r3, [sp, #0]
   1f358:	880a      	ldrh	r2, [r1, #0]
   1f35a:	f1b8 0f03 	cmp.w	r8, #3
   1f35e:	f102 0201 	add.w	r2, r2, #1
   1f362:	b292      	uxth	r2, r2
   1f364:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
   1f368:	7118      	strb	r0, [r3, #4]
   1f36a:	800a      	strh	r2, [r1, #0]
   1f36c:	60dc      	str	r4, [r3, #12]
   1f36e:	7158      	strb	r0, [r3, #5]
   1f370:	7198      	strb	r0, [r3, #6]
   1f372:	71d8      	strb	r0, [r3, #7]
   1f374:	d04b      	beq.n	1f40e <mfu_interface_getopt+0x136>
   1f376:	2104      	movs	r1, #4
   1f378:	2200      	movs	r2, #0
   1f37a:	4f41      	ldr	r7, [pc, #260]	; (1f480 <mfu_interface_getopt+0x1a8>)
   1f37c:	6099      	str	r1, [r3, #8]
   1f37e:	4618      	mov	r0, r3
   1f380:	4641      	mov	r1, r8
   1f382:	603a      	str	r2, [r7, #0]
   1f384:	f7fe fc7c 	bl	1dc80 <rpc_dfu_client_request_send>
   1f388:	2800      	cmp	r0, #0
   1f38a:	d14d      	bne.n	1f428 <mfu_interface_getopt+0x150>
   1f38c:	f04f 33ff 	mov.w	r3, #4294967295
   1f390:	ac02      	add	r4, sp, #8
   1f392:	f844 3d04 	str.w	r3, [r4, #-4]!
   1f396:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 1f474 <mfu_interface_getopt+0x19c>
   1f39a:	e005      	b.n	1f3a8 <mfu_interface_getopt+0xd0>
   1f39c:	4621      	mov	r1, r4
   1f39e:	4640      	mov	r0, r8
   1f3a0:	f7fc f950 	bl	1b644 <bsd_os_timedwait>
   1f3a4:	2800      	cmp	r0, #0
   1f3a6:	d137      	bne.n	1f418 <mfu_interface_getopt+0x140>
   1f3a8:	6839      	ldr	r1, [r7, #0]
   1f3aa:	2900      	cmp	r1, #0
   1f3ac:	d0f6      	beq.n	1f39c <mfu_interface_getopt+0xc4>
   1f3ae:	690c      	ldr	r4, [r1, #16]
   1f3b0:	2c00      	cmp	r4, #0
   1f3b2:	d154      	bne.n	1f45e <mfu_interface_getopt+0x186>
   1f3b4:	6832      	ldr	r2, [r6, #0]
   1f3b6:	3114      	adds	r1, #20
   1f3b8:	4628      	mov	r0, r5
   1f3ba:	f00f ffcb 	bl	2f354 <memcpy>
   1f3be:	6838      	ldr	r0, [r7, #0]
   1f3c0:	f7fe fc72 	bl	1dca8 <rpc_dfu_client_message_free>
   1f3c4:	4620      	mov	r0, r4
   1f3c6:	b002      	add	sp, #8
   1f3c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1f3cc:	6833      	ldr	r3, [r6, #0]
   1f3ce:	2b04      	cmp	r3, #4
   1f3d0:	d139      	bne.n	1f446 <mfu_interface_getopt+0x16e>
   1f3d2:	2402      	movs	r4, #2
   1f3d4:	2100      	movs	r1, #0
   1f3d6:	4668      	mov	r0, sp
   1f3d8:	46a0      	mov	r8, r4
   1f3da:	f7fe fc3d 	bl	1dc58 <rpc_dfu_client_request_alloc>
   1f3de:	2800      	cmp	r0, #0
   1f3e0:	d0b8      	beq.n	1f354 <mfu_interface_getopt+0x7c>
   1f3e2:	200c      	movs	r0, #12
   1f3e4:	f7fc f9c2 	bl	1b76c <bsd_os_errno_set>
   1f3e8:	f04f 30ff 	mov.w	r0, #4294967295
   1f3ec:	b002      	add	sp, #8
   1f3ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1f3f2:	6833      	ldr	r3, [r6, #0]
   1f3f4:	2b04      	cmp	r3, #4
   1f3f6:	d126      	bne.n	1f446 <mfu_interface_getopt+0x16e>
   1f3f8:	2409      	movs	r4, #9
   1f3fa:	46a0      	mov	r8, r4
   1f3fc:	e7a4      	b.n	1f348 <mfu_interface_getopt+0x70>
   1f3fe:	202a      	movs	r0, #42	; 0x2a
   1f400:	f7fc f9b4 	bl	1b76c <bsd_os_errno_set>
   1f404:	f04f 30ff 	mov.w	r0, #4294967295
   1f408:	b002      	add	sp, #8
   1f40a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1f40e:	4a1d      	ldr	r2, [pc, #116]	; (1f484 <mfu_interface_getopt+0x1ac>)
   1f410:	2108      	movs	r1, #8
   1f412:	6812      	ldr	r2, [r2, #0]
   1f414:	611a      	str	r2, [r3, #16]
   1f416:	e7af      	b.n	1f378 <mfu_interface_getopt+0xa0>
   1f418:	203c      	movs	r0, #60	; 0x3c
   1f41a:	f7fc f9a7 	bl	1b76c <bsd_os_errno_set>
   1f41e:	f04f 30ff 	mov.w	r0, #4294967295
   1f422:	b002      	add	sp, #8
   1f424:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1f428:	9800      	ldr	r0, [sp, #0]
   1f42a:	6803      	ldr	r3, [r0, #0]
   1f42c:	b11b      	cbz	r3, 1f436 <mfu_interface_getopt+0x15e>
   1f42e:	4618      	mov	r0, r3
   1f430:	f7fe fc42 	bl	1dcb8 <rpc_dfu_client_data_free>
   1f434:	9800      	ldr	r0, [sp, #0]
   1f436:	f7fe fc37 	bl	1dca8 <rpc_dfu_client_message_free>
   1f43a:	200c      	movs	r0, #12
   1f43c:	f7fc f996 	bl	1b76c <bsd_os_errno_set>
   1f440:	f04f 30ff 	mov.w	r0, #4294967295
   1f444:	e7d2      	b.n	1f3ec <mfu_interface_getopt+0x114>
   1f446:	2016      	movs	r0, #22
   1f448:	f7fc f990 	bl	1b76c <bsd_os_errno_set>
   1f44c:	f04f 30ff 	mov.w	r0, #4294967295
   1f450:	e771      	b.n	1f336 <mfu_interface_getopt+0x5e>
   1f452:	2001      	movs	r0, #1
   1f454:	f7fc f98a 	bl	1b76c <bsd_os_errno_set>
   1f458:	f04f 30ff 	mov.w	r0, #4294967295
   1f45c:	e76b      	b.n	1f336 <mfu_interface_getopt+0x5e>
   1f45e:	4b06      	ldr	r3, [pc, #24]	; (1f478 <mfu_interface_getopt+0x1a0>)
   1f460:	2008      	movs	r0, #8
   1f462:	601c      	str	r4, [r3, #0]
   1f464:	f7fc f982 	bl	1b76c <bsd_os_errno_set>
   1f468:	6838      	ldr	r0, [r7, #0]
   1f46a:	f7fe fc1d 	bl	1dca8 <rpc_dfu_client_message_free>
   1f46e:	f04f 30ff 	mov.w	r0, #4294967295
   1f472:	e760      	b.n	1f336 <mfu_interface_getopt+0x5e>
   1f474:	20028cd8 	.word	0x20028cd8
   1f478:	20028cdc 	.word	0x20028cdc
   1f47c:	2002d488 	.word	0x2002d488
   1f480:	20028ce4 	.word	0x20028ce4
   1f484:	20028ce0 	.word	0x20028ce0

0001f488 <bsd_recoverable_error_handler>:
   1f488:	4770      	bx	lr
   1f48a:	bf00      	nop

0001f48c <bsd_platform_error_handler>:
   1f48c:	b508      	push	{r3, lr}
   1f48e:	f7ff fffb 	bl	1f488 <bsd_recoverable_error_handler>
   1f492:	bd08      	pop	{r3, pc}

0001f494 <bsd_init>:
   1f494:	b510      	push	{r4, lr}
   1f496:	4c06      	ldr	r4, [pc, #24]	; (1f4b0 <bsd_init+0x1c>)
   1f498:	7823      	ldrb	r3, [r4, #0]
   1f49a:	b92b      	cbnz	r3, 1f4a8 <bsd_init+0x14>
   1f49c:	f000 f818 	bl	1f4d0 <bsd_platform_init>
   1f4a0:	b908      	cbnz	r0, 1f4a6 <bsd_init+0x12>
   1f4a2:	2301      	movs	r3, #1
   1f4a4:	7023      	strb	r3, [r4, #0]
   1f4a6:	bd10      	pop	{r4, pc}
   1f4a8:	f04f 30ff 	mov.w	r0, #4294967295
   1f4ac:	bd10      	pop	{r4, pc}
   1f4ae:	bf00      	nop
   1f4b0:	200314b9 	.word	0x200314b9

0001f4b4 <unimplemented_method>:
   1f4b4:	b40f      	push	{r0, r1, r2, r3}
   1f4b6:	b508      	push	{r3, lr}
   1f4b8:	202d      	movs	r0, #45	; 0x2d
   1f4ba:	f7fc f957 	bl	1b76c <bsd_os_errno_set>
   1f4be:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   1f4c2:	f04f 30ff 	mov.w	r0, #4294967295
   1f4c6:	b004      	add	sp, #16
   1f4c8:	4770      	bx	lr
   1f4ca:	bf00      	nop

0001f4cc <rpc_transport_ipc_fault_handler>:
   1f4cc:	f7ff bfde 	b.w	1f48c <bsd_platform_error_handler>

0001f4d0 <bsd_platform_init>:
   1f4d0:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f4d2:	b093      	sub	sp, #76	; 0x4c
   1f4d4:	f7fe fe28 	bl	1e128 <nrf_mem_init>
   1f4d8:	2800      	cmp	r0, #0
   1f4da:	d14c      	bne.n	1f576 <bsd_platform_init+0xa6>
   1f4dc:	4928      	ldr	r1, [pc, #160]	; (1f580 <bsd_platform_init+0xb0>)
   1f4de:	a801      	add	r0, sp, #4
   1f4e0:	f7fe fe96 	bl	1e210 <nrf_mem_register>
   1f4e4:	2800      	cmp	r0, #0
   1f4e6:	d146      	bne.n	1f576 <bsd_platform_init+0xa6>
   1f4e8:	f7fc fa58 	bl	1b99c <bsd_os_init>
   1f4ec:	f004 f9fa 	bl	238e4 <rpc_framework_init>
   1f4f0:	2800      	cmp	r0, #0
   1f4f2:	d140      	bne.n	1f576 <bsd_platform_init+0xa6>
   1f4f4:	2320      	movs	r3, #32
   1f4f6:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   1f4fa:	2208      	movs	r2, #8
   1f4fc:	f44f 5c40 	mov.w	ip, #12288	; 0x3000
   1f500:	4f20      	ldr	r7, [pc, #128]	; (1f584 <bsd_platform_init+0xb4>)
   1f502:	4e21      	ldr	r6, [pc, #132]	; (1f588 <bsd_platform_init+0xb8>)
   1f504:	9303      	str	r3, [sp, #12]
   1f506:	9305      	str	r3, [sp, #20]
   1f508:	9307      	str	r3, [sp, #28]
   1f50a:	4d20      	ldr	r5, [pc, #128]	; (1f58c <bsd_platform_init+0xbc>)
   1f50c:	9109      	str	r1, [sp, #36]	; 0x24
   1f50e:	910d      	str	r1, [sp, #52]	; 0x34
   1f510:	4c1f      	ldr	r4, [pc, #124]	; (1f590 <bsd_platform_init+0xc0>)
   1f512:	4920      	ldr	r1, [pc, #128]	; (1f594 <bsd_platform_init+0xc4>)
   1f514:	4b20      	ldr	r3, [pc, #128]	; (1f598 <bsd_platform_init+0xc8>)
   1f516:	e9cd 0010 	strd	r0, r0, [sp, #64]	; 0x40
   1f51a:	eb0d 0002 	add.w	r0, sp, r2
   1f51e:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
   1f522:	e9cd 220e 	strd	r2, r2, [sp, #56]	; 0x38
   1f526:	9702      	str	r7, [sp, #8]
   1f528:	9604      	str	r6, [sp, #16]
   1f52a:	9506      	str	r5, [sp, #24]
   1f52c:	9408      	str	r4, [sp, #32]
   1f52e:	910a      	str	r1, [sp, #40]	; 0x28
   1f530:	930c      	str	r3, [sp, #48]	; 0x30
   1f532:	f000 fbe9 	bl	1fd08 <rpc_transport_ipc_init>
   1f536:	b108      	cbz	r0, 1f53c <bsd_platform_init+0x6c>
   1f538:	b013      	add	sp, #76	; 0x4c
   1f53a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f53c:	f003 ff6e 	bl	2341c <interface_init>
   1f540:	b9c8      	cbnz	r0, 1f576 <bsd_platform_init+0xa6>
   1f542:	f7fe fa3b 	bl	1d9bc <at_interface_init>
   1f546:	b9b0      	cbnz	r0, 1f576 <bsd_platform_init+0xa6>
   1f548:	f002 fc22 	bl	21d90 <ip_interface_init>
   1f54c:	b998      	cbnz	r0, 1f576 <bsd_platform_init+0xa6>
   1f54e:	f7ff f881 	bl	1e654 <tls_interface_init>
   1f552:	b980      	cbnz	r0, 1f576 <bsd_platform_init+0xa6>
   1f554:	f7ff fcb4 	bl	1eec0 <mfu_interface_init>
   1f558:	b968      	cbnz	r0, 1f576 <bsd_platform_init+0xa6>
   1f55a:	f001 f9e9 	bl	20930 <pdn_interface_init>
   1f55e:	b950      	cbnz	r0, 1f576 <bsd_platform_init+0xa6>
   1f560:	f005 fc94 	bl	24e8c <gnss_interface_init>
   1f564:	b938      	cbnz	r0, 1f576 <bsd_platform_init+0xa6>
   1f566:	f7fd fec1 	bl	1d2ec <logobj_interface_init>
   1f56a:	3000      	adds	r0, #0
   1f56c:	bf18      	it	ne
   1f56e:	2001      	movne	r0, #1
   1f570:	4240      	negs	r0, r0
   1f572:	b013      	add	sp, #76	; 0x4c
   1f574:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f576:	f04f 30ff 	mov.w	r0, #4294967295
   1f57a:	b013      	add	sp, #76	; 0x4c
   1f57c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f57e:	bf00      	nop
   1f580:	00030d1c 	.word	0x00030d1c
   1f584:	20010000 	.word	0x20010000
   1f588:	20010040 	.word	0x20010040
   1f58c:	20010020 	.word	0x20010020
   1f590:	20017060 	.word	0x20017060
   1f594:	20010060 	.word	0x20010060
   1f598:	20013060 	.word	0x20013060

0001f59c <bsd_platform_af_method_table_get>:
   1f59c:	2805      	cmp	r0, #5
   1f59e:	d02a      	beq.n	1f5f6 <bsd_platform_af_method_table_get+0x5a>
   1f5a0:	b508      	push	{r3, lr}
   1f5a2:	d914      	bls.n	1f5ce <bsd_platform_af_method_table_get+0x32>
   1f5a4:	280a      	cmp	r0, #10
   1f5a6:	d016      	beq.n	1f5d6 <bsd_platform_af_method_table_get+0x3a>
   1f5a8:	2866      	cmp	r0, #102	; 0x66
   1f5aa:	d11f      	bne.n	1f5ec <bsd_platform_af_method_table_get+0x50>
   1f5ac:	f240 2302 	movw	r3, #514	; 0x202
   1f5b0:	429a      	cmp	r2, r3
   1f5b2:	d035      	beq.n	1f620 <bsd_platform_af_method_table_get+0x84>
   1f5b4:	f240 2305 	movw	r3, #517	; 0x205
   1f5b8:	429a      	cmp	r2, r3
   1f5ba:	d035      	beq.n	1f628 <bsd_platform_af_method_table_get+0x8c>
   1f5bc:	f240 2301 	movw	r3, #513	; 0x201
   1f5c0:	429a      	cmp	r2, r3
   1f5c2:	d02f      	beq.n	1f624 <bsd_platform_af_method_table_get+0x88>
   1f5c4:	202b      	movs	r0, #43	; 0x2b
   1f5c6:	f7fc f8d1 	bl	1b76c <bsd_os_errno_set>
   1f5ca:	2000      	movs	r0, #0
   1f5cc:	bd08      	pop	{r3, pc}
   1f5ce:	2801      	cmp	r0, #1
   1f5d0:	d016      	beq.n	1f600 <bsd_platform_af_method_table_get+0x64>
   1f5d2:	2802      	cmp	r0, #2
   1f5d4:	d10a      	bne.n	1f5ec <bsd_platform_af_method_table_get+0x50>
   1f5d6:	f5b2 7f83 	cmp.w	r2, #262	; 0x106
   1f5da:	d21a      	bcs.n	1f612 <bsd_platform_af_method_table_get+0x76>
   1f5dc:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   1f5e0:	d21a      	bcs.n	1f618 <bsd_platform_af_method_table_get+0x7c>
   1f5e2:	3a01      	subs	r2, #1
   1f5e4:	2a01      	cmp	r2, #1
   1f5e6:	d8ed      	bhi.n	1f5c4 <bsd_platform_af_method_table_get+0x28>
   1f5e8:	4810      	ldr	r0, [pc, #64]	; (1f62c <bsd_platform_af_method_table_get+0x90>)
   1f5ea:	bd08      	pop	{r3, pc}
   1f5ec:	2016      	movs	r0, #22
   1f5ee:	f7fc f8bd 	bl	1b76c <bsd_os_errno_set>
   1f5f2:	2000      	movs	r0, #0
   1f5f4:	bd08      	pop	{r3, pc}
   1f5f6:	2903      	cmp	r1, #3
   1f5f8:	480d      	ldr	r0, [pc, #52]	; (1f630 <bsd_platform_af_method_table_get+0x94>)
   1f5fa:	bf18      	it	ne
   1f5fc:	2000      	movne	r0, #0
   1f5fe:	4770      	bx	lr
   1f600:	f240 2303 	movw	r3, #515	; 0x203
   1f604:	429a      	cmp	r2, r3
   1f606:	d009      	beq.n	1f61c <bsd_platform_af_method_table_get+0x80>
   1f608:	f5b2 7f01 	cmp.w	r2, #516	; 0x204
   1f60c:	d1da      	bne.n	1f5c4 <bsd_platform_af_method_table_get+0x28>
   1f60e:	4809      	ldr	r0, [pc, #36]	; (1f634 <bsd_platform_af_method_table_get+0x98>)
   1f610:	bd08      	pop	{r3, pc}
   1f612:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   1f616:	d1d5      	bne.n	1f5c4 <bsd_platform_af_method_table_get+0x28>
   1f618:	4807      	ldr	r0, [pc, #28]	; (1f638 <bsd_platform_af_method_table_get+0x9c>)
   1f61a:	bd08      	pop	{r3, pc}
   1f61c:	4807      	ldr	r0, [pc, #28]	; (1f63c <bsd_platform_af_method_table_get+0xa0>)
   1f61e:	bd08      	pop	{r3, pc}
   1f620:	4807      	ldr	r0, [pc, #28]	; (1f640 <bsd_platform_af_method_table_get+0xa4>)
   1f622:	bd08      	pop	{r3, pc}
   1f624:	4807      	ldr	r0, [pc, #28]	; (1f644 <bsd_platform_af_method_table_get+0xa8>)
   1f626:	bd08      	pop	{r3, pc}
   1f628:	4807      	ldr	r0, [pc, #28]	; (1f648 <bsd_platform_af_method_table_get+0xac>)
   1f62a:	bd08      	pop	{r3, pc}
   1f62c:	00030bec 	.word	0x00030bec
   1f630:	00030cdc 	.word	0x00030cdc
   1f634:	00030c8c 	.word	0x00030c8c
   1f638:	00030c14 	.word	0x00030c14
   1f63c:	00030c3c 	.word	0x00030c3c
   1f640:	00030c64 	.word	0x00030c64
   1f644:	00030bc4 	.word	0x00030bc4
   1f648:	00030cb4 	.word	0x00030cb4

0001f64c <bsd_platform_fd_method_table_get>:
   1f64c:	b538      	push	{r3, r4, r5, lr}
   1f64e:	4605      	mov	r5, r0
   1f650:	f004 f816 	bl	23680 <interface_socket_from_handle_get>
   1f654:	4604      	mov	r4, r0
   1f656:	b960      	cbnz	r0, 1f672 <bsd_platform_fd_method_table_get+0x26>
   1f658:	4b2c      	ldr	r3, [pc, #176]	; (1f70c <bsd_platform_fd_method_table_get+0xc0>)
   1f65a:	429d      	cmp	r5, r3
   1f65c:	d02f      	beq.n	1f6be <bsd_platform_fd_method_table_get+0x72>
   1f65e:	0c2b      	lsrs	r3, r5, #16
   1f660:	4a2b      	ldr	r2, [pc, #172]	; (1f710 <bsd_platform_fd_method_table_get+0xc4>)
   1f662:	041b      	lsls	r3, r3, #16
   1f664:	4293      	cmp	r3, r2
   1f666:	d03d      	beq.n	1f6e4 <bsd_platform_fd_method_table_get+0x98>
   1f668:	4b2a      	ldr	r3, [pc, #168]	; (1f714 <bsd_platform_fd_method_table_get+0xc8>)
   1f66a:	429d      	cmp	r5, r3
   1f66c:	d149      	bne.n	1f702 <bsd_platform_fd_method_table_get+0xb6>
   1f66e:	482a      	ldr	r0, [pc, #168]	; (1f718 <bsd_platform_fd_method_table_get+0xcc>)
   1f670:	bd38      	pop	{r3, r4, r5, pc}
   1f672:	68c3      	ldr	r3, [r0, #12]
   1f674:	6942      	ldr	r2, [r0, #20]
   1f676:	2b05      	cmp	r3, #5
   1f678:	d036      	beq.n	1f6e8 <bsd_platform_fd_method_table_get+0x9c>
   1f67a:	d911      	bls.n	1f6a0 <bsd_platform_fd_method_table_get+0x54>
   1f67c:	2b0a      	cmp	r3, #10
   1f67e:	d013      	beq.n	1f6a8 <bsd_platform_fd_method_table_get+0x5c>
   1f680:	2b66      	cmp	r3, #102	; 0x66
   1f682:	d11e      	bne.n	1f6c2 <bsd_platform_fd_method_table_get+0x76>
   1f684:	f240 2302 	movw	r3, #514	; 0x202
   1f688:	429a      	cmp	r2, r3
   1f68a:	d02b      	beq.n	1f6e4 <bsd_platform_fd_method_table_get+0x98>
   1f68c:	f240 2305 	movw	r3, #517	; 0x205
   1f690:	429a      	cmp	r2, r3
   1f692:	d02f      	beq.n	1f6f4 <bsd_platform_fd_method_table_get+0xa8>
   1f694:	f240 2301 	movw	r3, #513	; 0x201
   1f698:	429a      	cmp	r2, r3
   1f69a:	d11e      	bne.n	1f6da <bsd_platform_fd_method_table_get+0x8e>
   1f69c:	481f      	ldr	r0, [pc, #124]	; (1f71c <bsd_platform_fd_method_table_get+0xd0>)
   1f69e:	bd38      	pop	{r3, r4, r5, pc}
   1f6a0:	2b01      	cmp	r3, #1
   1f6a2:	d013      	beq.n	1f6cc <bsd_platform_fd_method_table_get+0x80>
   1f6a4:	2b02      	cmp	r3, #2
   1f6a6:	d10c      	bne.n	1f6c2 <bsd_platform_fd_method_table_get+0x76>
   1f6a8:	f5b2 7f83 	cmp.w	r2, #262	; 0x106
   1f6ac:	d224      	bcs.n	1f6f8 <bsd_platform_fd_method_table_get+0xac>
   1f6ae:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   1f6b2:	d224      	bcs.n	1f6fe <bsd_platform_fd_method_table_get+0xb2>
   1f6b4:	3a01      	subs	r2, #1
   1f6b6:	2a01      	cmp	r2, #1
   1f6b8:	d80f      	bhi.n	1f6da <bsd_platform_fd_method_table_get+0x8e>
   1f6ba:	4819      	ldr	r0, [pc, #100]	; (1f720 <bsd_platform_fd_method_table_get+0xd4>)
   1f6bc:	bd38      	pop	{r3, r4, r5, pc}
   1f6be:	4819      	ldr	r0, [pc, #100]	; (1f724 <bsd_platform_fd_method_table_get+0xd8>)
   1f6c0:	bd38      	pop	{r3, r4, r5, pc}
   1f6c2:	2016      	movs	r0, #22
   1f6c4:	f7fc f852 	bl	1b76c <bsd_os_errno_set>
   1f6c8:	2000      	movs	r0, #0
   1f6ca:	bd38      	pop	{r3, r4, r5, pc}
   1f6cc:	f240 2303 	movw	r3, #515	; 0x203
   1f6d0:	429a      	cmp	r2, r3
   1f6d2:	d0f4      	beq.n	1f6be <bsd_platform_fd_method_table_get+0x72>
   1f6d4:	f5b2 7f01 	cmp.w	r2, #516	; 0x204
   1f6d8:	d0c9      	beq.n	1f66e <bsd_platform_fd_method_table_get+0x22>
   1f6da:	202b      	movs	r0, #43	; 0x2b
   1f6dc:	f7fc f846 	bl	1b76c <bsd_os_errno_set>
   1f6e0:	2000      	movs	r0, #0
   1f6e2:	bd38      	pop	{r3, r4, r5, pc}
   1f6e4:	4810      	ldr	r0, [pc, #64]	; (1f728 <bsd_platform_fd_method_table_get+0xdc>)
   1f6e6:	bd38      	pop	{r3, r4, r5, pc}
   1f6e8:	6903      	ldr	r3, [r0, #16]
   1f6ea:	4810      	ldr	r0, [pc, #64]	; (1f72c <bsd_platform_fd_method_table_get+0xe0>)
   1f6ec:	2b03      	cmp	r3, #3
   1f6ee:	bf18      	it	ne
   1f6f0:	2000      	movne	r0, #0
   1f6f2:	bd38      	pop	{r3, r4, r5, pc}
   1f6f4:	480e      	ldr	r0, [pc, #56]	; (1f730 <bsd_platform_fd_method_table_get+0xe4>)
   1f6f6:	bd38      	pop	{r3, r4, r5, pc}
   1f6f8:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   1f6fc:	d1ed      	bne.n	1f6da <bsd_platform_fd_method_table_get+0x8e>
   1f6fe:	480d      	ldr	r0, [pc, #52]	; (1f734 <bsd_platform_fd_method_table_get+0xe8>)
   1f700:	bd38      	pop	{r3, r4, r5, pc}
   1f702:	2009      	movs	r0, #9
   1f704:	f7fc f832 	bl	1b76c <bsd_os_errno_set>
   1f708:	4620      	mov	r0, r4
   1f70a:	bd38      	pop	{r3, r4, r5, pc}
   1f70c:	49765432 	.word	0x49765432
   1f710:	789a0000 	.word	0x789a0000
   1f714:	49765443 	.word	0x49765443
   1f718:	00030c8c 	.word	0x00030c8c
   1f71c:	00030bc4 	.word	0x00030bc4
   1f720:	00030bec 	.word	0x00030bec
   1f724:	00030c3c 	.word	0x00030c3c
   1f728:	00030c64 	.word	0x00030c64
   1f72c:	00030cdc 	.word	0x00030cdc
   1f730:	00030cb4 	.word	0x00030cb4
   1f734:	00030c14 	.word	0x00030c14

0001f738 <bsd_platform_getaddrinfo>:
   1f738:	f003 bad6 	b.w	22ce8 <ip_interface_getaddrinfo>

0001f73c <bsd_platform_freeaddrinfo>:
   1f73c:	f003 bbca 	b.w	22ed4 <ip_interface_freeaddrinfo>

0001f740 <bsd_platform_poll>:
   1f740:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1f744:	ea42 72e2 	orr.w	r2, r2, r2, asr #31
   1f748:	b083      	sub	sp, #12
   1f74a:	9200      	str	r2, [sp, #0]
   1f74c:	2800      	cmp	r0, #0
   1f74e:	d048      	beq.n	1f7e2 <bsd_platform_poll+0xa2>
   1f750:	1e4b      	subs	r3, r1, #1
   1f752:	2b08      	cmp	r3, #8
   1f754:	d845      	bhi.n	1f7e2 <bsd_platform_poll+0xa2>
   1f756:	4680      	mov	r8, r0
   1f758:	4605      	mov	r5, r0
   1f75a:	2400      	movs	r4, #0
   1f75c:	eb00 07c1 	add.w	r7, r0, r1, lsl #3
   1f760:	88ab      	ldrh	r3, [r5, #4]
   1f762:	6828      	ldr	r0, [r5, #0]
   1f764:	f003 0303 	and.w	r3, r3, #3
   1f768:	a901      	add	r1, sp, #4
   1f76a:	f043 061c 	orr.w	r6, r3, #28
   1f76e:	f003 ff95 	bl	2369c <interface_socket_event_get>
   1f772:	9b01      	ldr	r3, [sp, #4]
   1f774:	3508      	adds	r5, #8
   1f776:	4033      	ands	r3, r6
   1f778:	f825 3c02 	strh.w	r3, [r5, #-2]
   1f77c:	b103      	cbz	r3, 1f780 <bsd_platform_poll+0x40>
   1f77e:	3401      	adds	r4, #1
   1f780:	42af      	cmp	r7, r5
   1f782:	d1ed      	bne.n	1f760 <bsd_platform_poll+0x20>
   1f784:	bb9c      	cbnz	r4, 1f7ee <bsd_platform_poll+0xae>
   1f786:	4669      	mov	r1, sp
   1f788:	4640      	mov	r0, r8
   1f78a:	f7fb ff5b 	bl	1b644 <bsd_os_timedwait>
   1f78e:	4607      	mov	r7, r0
   1f790:	b108      	cbz	r0, 1f796 <bsd_platform_poll+0x56>
   1f792:	283c      	cmp	r0, #60	; 0x3c
   1f794:	d11d      	bne.n	1f7d2 <bsd_platform_poll+0x92>
   1f796:	46c1      	mov	r9, r8
   1f798:	2600      	movs	r6, #0
   1f79a:	f8b9 3004 	ldrh.w	r3, [r9, #4]
   1f79e:	f8d9 0000 	ldr.w	r0, [r9]
   1f7a2:	f003 0303 	and.w	r3, r3, #3
   1f7a6:	a901      	add	r1, sp, #4
   1f7a8:	f043 041c 	orr.w	r4, r3, #28
   1f7ac:	f003 ff76 	bl	2369c <interface_socket_event_get>
   1f7b0:	9b01      	ldr	r3, [sp, #4]
   1f7b2:	f109 0908 	add.w	r9, r9, #8
   1f7b6:	4023      	ands	r3, r4
   1f7b8:	f829 3c02 	strh.w	r3, [r9, #-2]
   1f7bc:	b103      	cbz	r3, 1f7c0 <bsd_platform_poll+0x80>
   1f7be:	3601      	adds	r6, #1
   1f7c0:	454d      	cmp	r5, r9
   1f7c2:	d1ea      	bne.n	1f79a <bsd_platform_poll+0x5a>
   1f7c4:	b90e      	cbnz	r6, 1f7ca <bsd_platform_poll+0x8a>
   1f7c6:	2f00      	cmp	r7, #0
   1f7c8:	d0dd      	beq.n	1f786 <bsd_platform_poll+0x46>
   1f7ca:	4630      	mov	r0, r6
   1f7cc:	b003      	add	sp, #12
   1f7ce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1f7d2:	2023      	movs	r0, #35	; 0x23
   1f7d4:	f7fb ffca 	bl	1b76c <bsd_os_errno_set>
   1f7d8:	f04f 30ff 	mov.w	r0, #4294967295
   1f7dc:	b003      	add	sp, #12
   1f7de:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1f7e2:	2016      	movs	r0, #22
   1f7e4:	f7fb ffc2 	bl	1b76c <bsd_os_errno_set>
   1f7e8:	f04f 30ff 	mov.w	r0, #4294967295
   1f7ec:	e7ee      	b.n	1f7cc <bsd_platform_poll+0x8c>
   1f7ee:	4620      	mov	r0, r4
   1f7f0:	e7ec      	b.n	1f7cc <bsd_platform_poll+0x8c>
   1f7f2:	bf00      	nop

0001f7f4 <bsd_platform_fcntl>:
   1f7f4:	b508      	push	{r3, lr}
   1f7f6:	4b06      	ldr	r3, [pc, #24]	; (1f810 <bsd_platform_fcntl+0x1c>)
   1f7f8:	4298      	cmp	r0, r3
   1f7fa:	d003      	beq.n	1f804 <bsd_platform_fcntl+0x10>
   1f7fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   1f800:	f003 bfd6 	b.w	237b0 <interface_socket_fcntl>
   1f804:	202d      	movs	r0, #45	; 0x2d
   1f806:	f7fb ffb1 	bl	1b76c <bsd_os_errno_set>
   1f80a:	f04f 30ff 	mov.w	r0, #4294967295
   1f80e:	bd08      	pop	{r3, pc}
   1f810:	49765432 	.word	0x49765432

0001f814 <ipc_trace_init>:
   1f814:	4b01      	ldr	r3, [pc, #4]	; (1f81c <ipc_trace_init+0x8>)
   1f816:	6018      	str	r0, [r3, #0]
   1f818:	4770      	bx	lr
   1f81a:	bf00      	nop
   1f81c:	20028cf4 	.word	0x20028cf4

0001f820 <bsd_os_trace_irq_handler>:
   1f820:	b5f0      	push	{r4, r5, r6, r7, lr}
   1f822:	4b6c      	ldr	r3, [pc, #432]	; (1f9d4 <bsd_os_trace_irq_handler+0x1b4>)
   1f824:	b083      	sub	sp, #12
   1f826:	781b      	ldrb	r3, [r3, #0]
   1f828:	2b00      	cmp	r3, #0
   1f82a:	f000 80ad 	beq.w	1f988 <bsd_os_trace_irq_handler+0x168>
   1f82e:	4b6a      	ldr	r3, [pc, #424]	; (1f9d8 <bsd_os_trace_irq_handler+0x1b8>)
   1f830:	681c      	ldr	r4, [r3, #0]
   1f832:	68a2      	ldr	r2, [r4, #8]
   1f834:	6863      	ldr	r3, [r4, #4]
   1f836:	429a      	cmp	r2, r3
   1f838:	d02d      	beq.n	1f896 <bsd_os_trace_irq_handler+0x76>
   1f83a:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   1f83e:	f8ad 3000 	strh.w	r3, [sp]
   1f842:	7823      	ldrb	r3, [r4, #0]
   1f844:	466e      	mov	r6, sp
   1f846:	f88d 3004 	strb.w	r3, [sp, #4]
   1f84a:	6863      	ldr	r3, [r4, #4]
   1f84c:	2105      	movs	r1, #5
   1f84e:	429a      	cmp	r2, r3
   1f850:	bf2a      	itet	cs
   1f852:	6927      	ldrcs	r7, [r4, #16]
   1f854:	1a9f      	subcc	r7, r3, r2
   1f856:	1abf      	subcs	r7, r7, r2
   1f858:	429a      	cmp	r2, r3
   1f85a:	bf94      	ite	ls
   1f85c:	2500      	movls	r5, #0
   1f85e:	68e5      	ldrhi	r5, [r4, #12]
   1f860:	b2bf      	uxth	r7, r7
   1f862:	bf88      	it	hi
   1f864:	1b5b      	subhi	r3, r3, r5
   1f866:	4630      	mov	r0, r6
   1f868:	bf88      	it	hi
   1f86a:	b29d      	uxthhi	r5, r3
   1f86c:	f8ad 7002 	strh.w	r7, [sp, #2]
   1f870:	f00e fe08 	bl	2e484 <bsd_os_trace_put>
   1f874:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1f878:	68a0      	ldr	r0, [r4, #8]
   1f87a:	f00e fe03 	bl	2e484 <bsd_os_trace_put>
   1f87e:	68a3      	ldr	r3, [r4, #8]
   1f880:	6922      	ldr	r2, [r4, #16]
   1f882:	441f      	add	r7, r3
   1f884:	4297      	cmp	r7, r2
   1f886:	bf08      	it	eq
   1f888:	68e3      	ldreq	r3, [r4, #12]
   1f88a:	60a7      	str	r7, [r4, #8]
   1f88c:	bf08      	it	eq
   1f88e:	60a3      	streq	r3, [r4, #8]
   1f890:	2d00      	cmp	r5, #0
   1f892:	f040 808d 	bne.w	1f9b0 <bsd_os_trace_irq_handler+0x190>
   1f896:	4b51      	ldr	r3, [pc, #324]	; (1f9dc <bsd_os_trace_irq_handler+0x1bc>)
   1f898:	681c      	ldr	r4, [r3, #0]
   1f89a:	68a2      	ldr	r2, [r4, #8]
   1f89c:	6863      	ldr	r3, [r4, #4]
   1f89e:	429a      	cmp	r2, r3
   1f8a0:	d02c      	beq.n	1f8fc <bsd_os_trace_irq_handler+0xdc>
   1f8a2:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   1f8a6:	f8ad 3000 	strh.w	r3, [sp]
   1f8aa:	7823      	ldrb	r3, [r4, #0]
   1f8ac:	466e      	mov	r6, sp
   1f8ae:	f88d 3004 	strb.w	r3, [sp, #4]
   1f8b2:	6863      	ldr	r3, [r4, #4]
   1f8b4:	2105      	movs	r1, #5
   1f8b6:	429a      	cmp	r2, r3
   1f8b8:	bf2a      	itet	cs
   1f8ba:	6927      	ldrcs	r7, [r4, #16]
   1f8bc:	1a9f      	subcc	r7, r3, r2
   1f8be:	1abf      	subcs	r7, r7, r2
   1f8c0:	429a      	cmp	r2, r3
   1f8c2:	bf94      	ite	ls
   1f8c4:	2500      	movls	r5, #0
   1f8c6:	68e5      	ldrhi	r5, [r4, #12]
   1f8c8:	b2bf      	uxth	r7, r7
   1f8ca:	bf88      	it	hi
   1f8cc:	1b5b      	subhi	r3, r3, r5
   1f8ce:	4630      	mov	r0, r6
   1f8d0:	bf88      	it	hi
   1f8d2:	b29d      	uxthhi	r5, r3
   1f8d4:	f8ad 7002 	strh.w	r7, [sp, #2]
   1f8d8:	f00e fdd4 	bl	2e484 <bsd_os_trace_put>
   1f8dc:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1f8e0:	68a0      	ldr	r0, [r4, #8]
   1f8e2:	f00e fdcf 	bl	2e484 <bsd_os_trace_put>
   1f8e6:	68a3      	ldr	r3, [r4, #8]
   1f8e8:	6922      	ldr	r2, [r4, #16]
   1f8ea:	441f      	add	r7, r3
   1f8ec:	4297      	cmp	r7, r2
   1f8ee:	bf08      	it	eq
   1f8f0:	68e3      	ldreq	r3, [r4, #12]
   1f8f2:	60a7      	str	r7, [r4, #8]
   1f8f4:	bf08      	it	eq
   1f8f6:	60a3      	streq	r3, [r4, #8]
   1f8f8:	2d00      	cmp	r5, #0
   1f8fa:	d148      	bne.n	1f98e <bsd_os_trace_irq_handler+0x16e>
   1f8fc:	4b38      	ldr	r3, [pc, #224]	; (1f9e0 <bsd_os_trace_irq_handler+0x1c0>)
   1f8fe:	681c      	ldr	r4, [r3, #0]
   1f900:	68a2      	ldr	r2, [r4, #8]
   1f902:	6863      	ldr	r3, [r4, #4]
   1f904:	429a      	cmp	r2, r3
   1f906:	d02b      	beq.n	1f960 <bsd_os_trace_irq_handler+0x140>
   1f908:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   1f90c:	f8ad 3000 	strh.w	r3, [sp]
   1f910:	7823      	ldrb	r3, [r4, #0]
   1f912:	466e      	mov	r6, sp
   1f914:	f88d 3004 	strb.w	r3, [sp, #4]
   1f918:	6863      	ldr	r3, [r4, #4]
   1f91a:	2105      	movs	r1, #5
   1f91c:	429a      	cmp	r2, r3
   1f91e:	bf2a      	itet	cs
   1f920:	6927      	ldrcs	r7, [r4, #16]
   1f922:	1a9f      	subcc	r7, r3, r2
   1f924:	1abf      	subcs	r7, r7, r2
   1f926:	429a      	cmp	r2, r3
   1f928:	bf94      	ite	ls
   1f92a:	2500      	movls	r5, #0
   1f92c:	68e5      	ldrhi	r5, [r4, #12]
   1f92e:	b2bf      	uxth	r7, r7
   1f930:	bf88      	it	hi
   1f932:	1b5b      	subhi	r3, r3, r5
   1f934:	4630      	mov	r0, r6
   1f936:	bf88      	it	hi
   1f938:	b29d      	uxthhi	r5, r3
   1f93a:	f8ad 7002 	strh.w	r7, [sp, #2]
   1f93e:	f00e fda1 	bl	2e484 <bsd_os_trace_put>
   1f942:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1f946:	68a0      	ldr	r0, [r4, #8]
   1f948:	f00e fd9c 	bl	2e484 <bsd_os_trace_put>
   1f94c:	68a3      	ldr	r3, [r4, #8]
   1f94e:	6922      	ldr	r2, [r4, #16]
   1f950:	441f      	add	r7, r3
   1f952:	4297      	cmp	r7, r2
   1f954:	bf08      	it	eq
   1f956:	68e3      	ldreq	r3, [r4, #12]
   1f958:	60a7      	str	r7, [r4, #8]
   1f95a:	bf08      	it	eq
   1f95c:	60a3      	streq	r3, [r4, #8]
   1f95e:	b90d      	cbnz	r5, 1f964 <bsd_os_trace_irq_handler+0x144>
   1f960:	b003      	add	sp, #12
   1f962:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f964:	4630      	mov	r0, r6
   1f966:	2105      	movs	r1, #5
   1f968:	f8ad 5002 	strh.w	r5, [sp, #2]
   1f96c:	f00e fd8a 	bl	2e484 <bsd_os_trace_put>
   1f970:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1f974:	68e0      	ldr	r0, [r4, #12]
   1f976:	f00e fd85 	bl	2e484 <bsd_os_trace_put>
   1f97a:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   1f97e:	68e3      	ldr	r3, [r4, #12]
   1f980:	4413      	add	r3, r2
   1f982:	60a3      	str	r3, [r4, #8]
   1f984:	b003      	add	sp, #12
   1f986:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1f988:	f7fc f800 	bl	1b98c <bsd_os_trace_irq_clear>
   1f98c:	e74f      	b.n	1f82e <bsd_os_trace_irq_handler+0xe>
   1f98e:	2105      	movs	r1, #5
   1f990:	4630      	mov	r0, r6
   1f992:	f8ad 5002 	strh.w	r5, [sp, #2]
   1f996:	f00e fd75 	bl	2e484 <bsd_os_trace_put>
   1f99a:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1f99e:	68e0      	ldr	r0, [r4, #12]
   1f9a0:	f00e fd70 	bl	2e484 <bsd_os_trace_put>
   1f9a4:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   1f9a8:	68e3      	ldr	r3, [r4, #12]
   1f9aa:	4413      	add	r3, r2
   1f9ac:	60a3      	str	r3, [r4, #8]
   1f9ae:	e7a5      	b.n	1f8fc <bsd_os_trace_irq_handler+0xdc>
   1f9b0:	2105      	movs	r1, #5
   1f9b2:	4630      	mov	r0, r6
   1f9b4:	f8ad 5002 	strh.w	r5, [sp, #2]
   1f9b8:	f00e fd64 	bl	2e484 <bsd_os_trace_put>
   1f9bc:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1f9c0:	68e0      	ldr	r0, [r4, #12]
   1f9c2:	f00e fd5f 	bl	2e484 <bsd_os_trace_put>
   1f9c6:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   1f9ca:	68e3      	ldr	r3, [r4, #12]
   1f9cc:	4413      	add	r3, r2
   1f9ce:	60a3      	str	r3, [r4, #8]
   1f9d0:	e761      	b.n	1f896 <bsd_os_trace_irq_handler+0x76>
   1f9d2:	bf00      	nop
   1f9d4:	200314ba 	.word	0x200314ba
   1f9d8:	20028cf0 	.word	0x20028cf0
   1f9dc:	20028ce8 	.word	0x20028ce8
   1f9e0:	20028cec 	.word	0x20028cec

0001f9e4 <ipc_trace_handle>:
   1f9e4:	2200      	movs	r2, #0
   1f9e6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1f9ea:	4bb0      	ldr	r3, [pc, #704]	; (1fcac <ipc_trace_handle+0x2c8>)
   1f9ec:	b083      	sub	sp, #12
   1f9ee:	681b      	ldr	r3, [r3, #0]
   1f9f0:	6919      	ldr	r1, [r3, #16]
   1f9f2:	695c      	ldr	r4, [r3, #20]
   1f9f4:	7c18      	ldrb	r0, [r3, #16]
   1f9f6:	741a      	strb	r2, [r3, #16]
   1f9f8:	7c58      	ldrb	r0, [r3, #17]
   1f9fa:	745a      	strb	r2, [r3, #17]
   1f9fc:	7c98      	ldrb	r0, [r3, #18]
   1f9fe:	749a      	strb	r2, [r3, #18]
   1fa00:	7cd8      	ldrb	r0, [r3, #19]
   1fa02:	74da      	strb	r2, [r3, #19]
   1fa04:	7d18      	ldrb	r0, [r3, #20]
   1fa06:	751a      	strb	r2, [r3, #20]
   1fa08:	7d58      	ldrb	r0, [r3, #21]
   1fa0a:	755a      	strb	r2, [r3, #21]
   1fa0c:	7d98      	ldrb	r0, [r3, #22]
   1fa0e:	759a      	strb	r2, [r3, #22]
   1fa10:	7dd8      	ldrb	r0, [r3, #23]
   1fa12:	75da      	strb	r2, [r3, #23]
   1fa14:	b1b9      	cbz	r1, 1fa46 <ipc_trace_handle+0x62>
   1fa16:	3901      	subs	r1, #1
   1fa18:	2903      	cmp	r1, #3
   1fa1a:	d814      	bhi.n	1fa46 <ipc_trace_handle+0x62>
   1fa1c:	e8df f011 	tbh	[pc, r1, lsl #1]
   1fa20:	010300d6 	.word	0x010300d6
   1fa24:	00160004 	.word	0x00160004
   1fa28:	2501      	movs	r5, #1
   1fa2a:	2003      	movs	r0, #3
   1fa2c:	2200      	movs	r2, #0
   1fa2e:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   1fa32:	4c9f      	ldr	r4, [pc, #636]	; (1fcb0 <ipc_trace_handle+0x2cc>)
   1fa34:	7025      	strb	r5, [r4, #0]
   1fa36:	7a1c      	ldrb	r4, [r3, #8]
   1fa38:	7218      	strb	r0, [r3, #8]
   1fa3a:	7a58      	ldrb	r0, [r3, #9]
   1fa3c:	725a      	strb	r2, [r3, #9]
   1fa3e:	7a98      	ldrb	r0, [r3, #10]
   1fa40:	729a      	strb	r2, [r3, #10]
   1fa42:	7ada      	ldrb	r2, [r3, #11]
   1fa44:	72d9      	strb	r1, [r3, #11]
   1fa46:	b003      	add	sp, #12
   1fa48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1fa4c:	2104      	movs	r1, #4
   1fa4e:	2200      	movs	r2, #0
   1fa50:	f06f 005f 	mvn.w	r0, #95	; 0x5f
   1fa54:	7a1c      	ldrb	r4, [r3, #8]
   1fa56:	7219      	strb	r1, [r3, #8]
   1fa58:	7a59      	ldrb	r1, [r3, #9]
   1fa5a:	725a      	strb	r2, [r3, #9]
   1fa5c:	4994      	ldr	r1, [pc, #592]	; (1fcb0 <ipc_trace_handle+0x2cc>)
   1fa5e:	7a9c      	ldrb	r4, [r3, #10]
   1fa60:	729a      	strb	r2, [r3, #10]
   1fa62:	7adc      	ldrb	r4, [r3, #11]
   1fa64:	72d8      	strb	r0, [r3, #11]
   1fa66:	700a      	strb	r2, [r1, #0]
   1fa68:	780b      	ldrb	r3, [r1, #0]
   1fa6a:	2b00      	cmp	r3, #0
   1fa6c:	f000 8117 	beq.w	1fc9e <ipc_trace_handle+0x2ba>
   1fa70:	4b90      	ldr	r3, [pc, #576]	; (1fcb4 <ipc_trace_handle+0x2d0>)
   1fa72:	681c      	ldr	r4, [r3, #0]
   1fa74:	68a2      	ldr	r2, [r4, #8]
   1fa76:	6863      	ldr	r3, [r4, #4]
   1fa78:	429a      	cmp	r2, r3
   1fa7a:	d02d      	beq.n	1fad8 <ipc_trace_handle+0xf4>
   1fa7c:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   1fa80:	f8ad 3000 	strh.w	r3, [sp]
   1fa84:	7823      	ldrb	r3, [r4, #0]
   1fa86:	466e      	mov	r6, sp
   1fa88:	f88d 3004 	strb.w	r3, [sp, #4]
   1fa8c:	6863      	ldr	r3, [r4, #4]
   1fa8e:	2105      	movs	r1, #5
   1fa90:	429a      	cmp	r2, r3
   1fa92:	bf2a      	itet	cs
   1fa94:	6927      	ldrcs	r7, [r4, #16]
   1fa96:	1a9f      	subcc	r7, r3, r2
   1fa98:	1abf      	subcs	r7, r7, r2
   1fa9a:	429a      	cmp	r2, r3
   1fa9c:	bf94      	ite	ls
   1fa9e:	2500      	movls	r5, #0
   1faa0:	68e5      	ldrhi	r5, [r4, #12]
   1faa2:	b2bf      	uxth	r7, r7
   1faa4:	bf88      	it	hi
   1faa6:	1b5b      	subhi	r3, r3, r5
   1faa8:	4630      	mov	r0, r6
   1faaa:	bf88      	it	hi
   1faac:	b29d      	uxthhi	r5, r3
   1faae:	f8ad 7002 	strh.w	r7, [sp, #2]
   1fab2:	f00e fce7 	bl	2e484 <bsd_os_trace_put>
   1fab6:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1faba:	68a0      	ldr	r0, [r4, #8]
   1fabc:	f00e fce2 	bl	2e484 <bsd_os_trace_put>
   1fac0:	68a3      	ldr	r3, [r4, #8]
   1fac2:	6922      	ldr	r2, [r4, #16]
   1fac4:	441f      	add	r7, r3
   1fac6:	4297      	cmp	r7, r2
   1fac8:	bf08      	it	eq
   1faca:	68e3      	ldreq	r3, [r4, #12]
   1facc:	60a7      	str	r7, [r4, #8]
   1face:	bf08      	it	eq
   1fad0:	60a3      	streq	r3, [r4, #8]
   1fad2:	2d00      	cmp	r5, #0
   1fad4:	f040 80d2 	bne.w	1fc7c <ipc_trace_handle+0x298>
   1fad8:	4b77      	ldr	r3, [pc, #476]	; (1fcb8 <ipc_trace_handle+0x2d4>)
   1fada:	681c      	ldr	r4, [r3, #0]
   1fadc:	68a2      	ldr	r2, [r4, #8]
   1fade:	6863      	ldr	r3, [r4, #4]
   1fae0:	429a      	cmp	r2, r3
   1fae2:	d02d      	beq.n	1fb40 <ipc_trace_handle+0x15c>
   1fae4:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   1fae8:	f8ad 3000 	strh.w	r3, [sp]
   1faec:	7823      	ldrb	r3, [r4, #0]
   1faee:	466e      	mov	r6, sp
   1faf0:	f88d 3004 	strb.w	r3, [sp, #4]
   1faf4:	6863      	ldr	r3, [r4, #4]
   1faf6:	2105      	movs	r1, #5
   1faf8:	429a      	cmp	r2, r3
   1fafa:	bf2a      	itet	cs
   1fafc:	6927      	ldrcs	r7, [r4, #16]
   1fafe:	1a9f      	subcc	r7, r3, r2
   1fb00:	1abf      	subcs	r7, r7, r2
   1fb02:	429a      	cmp	r2, r3
   1fb04:	bf94      	ite	ls
   1fb06:	2500      	movls	r5, #0
   1fb08:	68e5      	ldrhi	r5, [r4, #12]
   1fb0a:	b2bf      	uxth	r7, r7
   1fb0c:	bf88      	it	hi
   1fb0e:	1b5b      	subhi	r3, r3, r5
   1fb10:	4630      	mov	r0, r6
   1fb12:	bf88      	it	hi
   1fb14:	b29d      	uxthhi	r5, r3
   1fb16:	f8ad 7002 	strh.w	r7, [sp, #2]
   1fb1a:	f00e fcb3 	bl	2e484 <bsd_os_trace_put>
   1fb1e:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1fb22:	68a0      	ldr	r0, [r4, #8]
   1fb24:	f00e fcae 	bl	2e484 <bsd_os_trace_put>
   1fb28:	68a3      	ldr	r3, [r4, #8]
   1fb2a:	6922      	ldr	r2, [r4, #16]
   1fb2c:	441f      	add	r7, r3
   1fb2e:	4297      	cmp	r7, r2
   1fb30:	bf08      	it	eq
   1fb32:	68e3      	ldreq	r3, [r4, #12]
   1fb34:	60a7      	str	r7, [r4, #8]
   1fb36:	bf08      	it	eq
   1fb38:	60a3      	streq	r3, [r4, #8]
   1fb3a:	2d00      	cmp	r5, #0
   1fb3c:	f040 808d 	bne.w	1fc5a <ipc_trace_handle+0x276>
   1fb40:	4b5e      	ldr	r3, [pc, #376]	; (1fcbc <ipc_trace_handle+0x2d8>)
   1fb42:	681c      	ldr	r4, [r3, #0]
   1fb44:	68a2      	ldr	r2, [r4, #8]
   1fb46:	6863      	ldr	r3, [r4, #4]
   1fb48:	429a      	cmp	r2, r3
   1fb4a:	f43f af7c 	beq.w	1fa46 <ipc_trace_handle+0x62>
   1fb4e:	f64b 63ef 	movw	r3, #48879	; 0xbeef
   1fb52:	f8ad 3000 	strh.w	r3, [sp]
   1fb56:	7823      	ldrb	r3, [r4, #0]
   1fb58:	466e      	mov	r6, sp
   1fb5a:	f88d 3004 	strb.w	r3, [sp, #4]
   1fb5e:	6863      	ldr	r3, [r4, #4]
   1fb60:	2105      	movs	r1, #5
   1fb62:	429a      	cmp	r2, r3
   1fb64:	bf2a      	itet	cs
   1fb66:	6927      	ldrcs	r7, [r4, #16]
   1fb68:	1a9f      	subcc	r7, r3, r2
   1fb6a:	1abf      	subcs	r7, r7, r2
   1fb6c:	429a      	cmp	r2, r3
   1fb6e:	bf94      	ite	ls
   1fb70:	2500      	movls	r5, #0
   1fb72:	68e5      	ldrhi	r5, [r4, #12]
   1fb74:	b2bf      	uxth	r7, r7
   1fb76:	bf88      	it	hi
   1fb78:	1b5b      	subhi	r3, r3, r5
   1fb7a:	4630      	mov	r0, r6
   1fb7c:	bf88      	it	hi
   1fb7e:	b29d      	uxthhi	r5, r3
   1fb80:	f8ad 7002 	strh.w	r7, [sp, #2]
   1fb84:	f00e fc7e 	bl	2e484 <bsd_os_trace_put>
   1fb88:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1fb8c:	68a0      	ldr	r0, [r4, #8]
   1fb8e:	f00e fc79 	bl	2e484 <bsd_os_trace_put>
   1fb92:	68a3      	ldr	r3, [r4, #8]
   1fb94:	6922      	ldr	r2, [r4, #16]
   1fb96:	441f      	add	r7, r3
   1fb98:	4297      	cmp	r7, r2
   1fb9a:	bf08      	it	eq
   1fb9c:	68e3      	ldreq	r3, [r4, #12]
   1fb9e:	60a7      	str	r7, [r4, #8]
   1fba0:	bf08      	it	eq
   1fba2:	60a3      	streq	r3, [r4, #8]
   1fba4:	2d00      	cmp	r5, #0
   1fba6:	f43f af4e 	beq.w	1fa46 <ipc_trace_handle+0x62>
   1fbaa:	2105      	movs	r1, #5
   1fbac:	4630      	mov	r0, r6
   1fbae:	f8ad 5002 	strh.w	r5, [sp, #2]
   1fbb2:	f00e fc67 	bl	2e484 <bsd_os_trace_put>
   1fbb6:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1fbba:	68e0      	ldr	r0, [r4, #12]
   1fbbc:	f00e fc62 	bl	2e484 <bsd_os_trace_put>
   1fbc0:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   1fbc4:	68e3      	ldr	r3, [r4, #12]
   1fbc6:	4413      	add	r3, r2
   1fbc8:	60a3      	str	r3, [r4, #8]
   1fbca:	e73c      	b.n	1fa46 <ipc_trace_handle+0x62>
   1fbcc:	4a38      	ldr	r2, [pc, #224]	; (1fcb0 <ipc_trace_handle+0x2cc>)
   1fbce:	7811      	ldrb	r1, [r2, #0]
   1fbd0:	b109      	cbz	r1, 1fbd6 <ipc_trace_handle+0x1f2>
   1fbd2:	2100      	movs	r1, #0
   1fbd4:	7011      	strb	r1, [r2, #0]
   1fbd6:	68a5      	ldr	r5, [r4, #8]
   1fbd8:	2d00      	cmp	r5, #0
   1fbda:	d039      	beq.n	1fc50 <ipc_trace_handle+0x26c>
   1fbdc:	f04f 0c00 	mov.w	ip, #0
   1fbe0:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 1fcb8 <ipc_trace_handle+0x2d4>
   1fbe4:	f8df b0cc 	ldr.w	fp, [pc, #204]	; 1fcb4 <ipc_trace_handle+0x2d0>
   1fbe8:	4934      	ldr	r1, [pc, #208]	; (1fcbc <ipc_trace_handle+0x2d8>)
   1fbea:	46e1      	mov	r9, ip
   1fbec:	4666      	mov	r6, ip
   1fbee:	4662      	mov	r2, ip
   1fbf0:	f8d1 e000 	ldr.w	lr, [r1]
   1fbf4:	f8da 8000 	ldr.w	r8, [sl]
   1fbf8:	f8db 7000 	ldr.w	r7, [fp]
   1fbfc:	e008      	b.n	1fc10 <ipc_trace_handle+0x22c>
   1fbfe:	2963      	cmp	r1, #99	; 0x63
   1fc00:	d016      	beq.n	1fc30 <ipc_trace_handle+0x24c>
   1fc02:	2961      	cmp	r1, #97	; 0x61
   1fc04:	bf04      	itt	eq
   1fc06:	4607      	moveq	r7, r0
   1fc08:	2601      	moveq	r6, #1
   1fc0a:	3201      	adds	r2, #1
   1fc0c:	42aa      	cmp	r2, r5
   1fc0e:	d013      	beq.n	1fc38 <ipc_trace_handle+0x254>
   1fc10:	1c91      	adds	r1, r2, #2
   1fc12:	eb04 0181 	add.w	r1, r4, r1, lsl #2
   1fc16:	6848      	ldr	r0, [r1, #4]
   1fc18:	7801      	ldrb	r1, [r0, #0]
   1fc1a:	2962      	cmp	r1, #98	; 0x62
   1fc1c:	d1ef      	bne.n	1fbfe <ipc_trace_handle+0x21a>
   1fc1e:	4680      	mov	r8, r0
   1fc20:	f04f 0901 	mov.w	r9, #1
   1fc24:	e7f1      	b.n	1fc0a <ipc_trace_handle+0x226>
   1fc26:	f7fb fea9 	bl	1b97c <bsd_os_trace_irq_set>
   1fc2a:	b003      	add	sp, #12
   1fc2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1fc30:	4686      	mov	lr, r0
   1fc32:	f04f 0c01 	mov.w	ip, #1
   1fc36:	e7e8      	b.n	1fc0a <ipc_trace_handle+0x226>
   1fc38:	bba6      	cbnz	r6, 1fca4 <ipc_trace_handle+0x2c0>
   1fc3a:	f1b9 0f00 	cmp.w	r9, #0
   1fc3e:	d001      	beq.n	1fc44 <ipc_trace_handle+0x260>
   1fc40:	f8ca 8000 	str.w	r8, [sl]
   1fc44:	f1bc 0f00 	cmp.w	ip, #0
   1fc48:	d002      	beq.n	1fc50 <ipc_trace_handle+0x26c>
   1fc4a:	4a1c      	ldr	r2, [pc, #112]	; (1fcbc <ipc_trace_handle+0x2d8>)
   1fc4c:	f8c2 e000 	str.w	lr, [r2]
   1fc50:	2001      	movs	r0, #1
   1fc52:	2200      	movs	r2, #0
   1fc54:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   1fc58:	e6ed      	b.n	1fa36 <ipc_trace_handle+0x52>
   1fc5a:	2105      	movs	r1, #5
   1fc5c:	4630      	mov	r0, r6
   1fc5e:	f8ad 5002 	strh.w	r5, [sp, #2]
   1fc62:	f00e fc0f 	bl	2e484 <bsd_os_trace_put>
   1fc66:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1fc6a:	68e0      	ldr	r0, [r4, #12]
   1fc6c:	f00e fc0a 	bl	2e484 <bsd_os_trace_put>
   1fc70:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   1fc74:	68e3      	ldr	r3, [r4, #12]
   1fc76:	4413      	add	r3, r2
   1fc78:	60a3      	str	r3, [r4, #8]
   1fc7a:	e761      	b.n	1fb40 <ipc_trace_handle+0x15c>
   1fc7c:	2105      	movs	r1, #5
   1fc7e:	4630      	mov	r0, r6
   1fc80:	f8ad 5002 	strh.w	r5, [sp, #2]
   1fc84:	f00e fbfe 	bl	2e484 <bsd_os_trace_put>
   1fc88:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1fc8c:	68e0      	ldr	r0, [r4, #12]
   1fc8e:	f00e fbf9 	bl	2e484 <bsd_os_trace_put>
   1fc92:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   1fc96:	68e3      	ldr	r3, [r4, #12]
   1fc98:	4413      	add	r3, r2
   1fc9a:	60a3      	str	r3, [r4, #8]
   1fc9c:	e71c      	b.n	1fad8 <ipc_trace_handle+0xf4>
   1fc9e:	f7fb fe75 	bl	1b98c <bsd_os_trace_irq_clear>
   1fca2:	e6e5      	b.n	1fa70 <ipc_trace_handle+0x8c>
   1fca4:	f8cb 7000 	str.w	r7, [fp]
   1fca8:	e7c7      	b.n	1fc3a <ipc_trace_handle+0x256>
   1fcaa:	bf00      	nop
   1fcac:	20028cf4 	.word	0x20028cf4
   1fcb0:	200314ba 	.word	0x200314ba
   1fcb4:	20028cf0 	.word	0x20028cf0
   1fcb8:	20028ce8 	.word	0x20028ce8
   1fcbc:	20028cec 	.word	0x20028cec

0001fcc0 <rpc_trace_coredump_in_progress>:
   1fcc0:	4b01      	ldr	r3, [pc, #4]	; (1fcc8 <rpc_trace_coredump_in_progress+0x8>)
   1fcc2:	7818      	ldrb	r0, [r3, #0]
   1fcc4:	4770      	bx	lr
   1fcc6:	bf00      	nop
   1fcc8:	200314ba 	.word	0x200314ba

0001fccc <transport_reset>:
   1fccc:	2000      	movs	r0, #0
   1fcce:	4770      	bx	lr

0001fcd0 <transport_data_free>:
   1fcd0:	4b0b      	ldr	r3, [pc, #44]	; (1fd00 <transport_data_free+0x30>)
   1fcd2:	e9d3 2300 	ldrd	r2, r3, [r3]
   1fcd6:	4413      	add	r3, r2
   1fcd8:	4298      	cmp	r0, r3
   1fcda:	d20d      	bcs.n	1fcf8 <transport_data_free+0x28>
   1fcdc:	4282      	cmp	r2, r0
   1fcde:	d80b      	bhi.n	1fcf8 <transport_data_free+0x28>
   1fce0:	b510      	push	{r4, lr}
   1fce2:	4604      	mov	r4, r0
   1fce4:	f000 fd5a 	bl	2079c <rpc_transport_ipc_tx_rpc_ctrl_alloc>
   1fce8:	b140      	cbz	r0, 1fcfc <transport_data_free+0x2c>
   1fcea:	4a06      	ldr	r2, [pc, #24]	; (1fd04 <transport_data_free+0x34>)
   1fcec:	6084      	str	r4, [r0, #8]
   1fcee:	6002      	str	r2, [r0, #0]
   1fcf0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1fcf4:	f000 bc9a 	b.w	2062c <rpc_transport_ipc_tx_send>
   1fcf8:	f7fe bbc4 	b.w	1e484 <nrf_shared_free>
   1fcfc:	bd10      	pop	{r4, pc}
   1fcfe:	bf00      	nop
   1fd00:	20028cf8 	.word	0x20028cf8
   1fd04:	00020001 	.word	0x00020001

0001fd08 <rpc_transport_ipc_init>:
   1fd08:	2800      	cmp	r0, #0
   1fd0a:	d02b      	beq.n	1fd64 <rpc_transport_ipc_init+0x5c>
   1fd0c:	b530      	push	{r4, r5, lr}
   1fd0e:	b089      	sub	sp, #36	; 0x24
   1fd10:	aa01      	add	r2, sp, #4
   1fd12:	4669      	mov	r1, sp
   1fd14:	4604      	mov	r4, r0
   1fd16:	f000 fb9f 	bl	20458 <rpc_transport_ipc_tx_init>
   1fd1a:	4603      	mov	r3, r0
   1fd1c:	b140      	cbz	r0, 1fd30 <rpc_transport_ipc_init+0x28>
   1fd1e:	4a13      	ldr	r2, [pc, #76]	; (1fd6c <rpc_transport_ipc_init+0x64>)
   1fd20:	f104 0028 	add.w	r0, r4, #40	; 0x28
   1fd24:	c803      	ldmia	r0, {r0, r1}
   1fd26:	e882 0003 	stmia.w	r2, {r0, r1}
   1fd2a:	4618      	mov	r0, r3
   1fd2c:	b009      	add	sp, #36	; 0x24
   1fd2e:	bd30      	pop	{r4, r5, pc}
   1fd30:	e9dd 1200 	ldrd	r1, r2, [sp]
   1fd34:	4620      	mov	r0, r4
   1fd36:	f000 f84b 	bl	1fdd0 <rpc_transport_ipc_rx_init>
   1fd3a:	4603      	mov	r3, r0
   1fd3c:	2800      	cmp	r0, #0
   1fd3e:	d1ee      	bne.n	1fd1e <rpc_transport_ipc_init+0x16>
   1fd40:	4b0b      	ldr	r3, [pc, #44]	; (1fd70 <rpc_transport_ipc_init+0x68>)
   1fd42:	490c      	ldr	r1, [pc, #48]	; (1fd74 <rpc_transport_ipc_init+0x6c>)
   1fd44:	480c      	ldr	r0, [pc, #48]	; (1fd78 <rpc_transport_ipc_init+0x70>)
   1fd46:	4a0d      	ldr	r2, [pc, #52]	; (1fd7c <rpc_transport_ipc_init+0x74>)
   1fd48:	9303      	str	r3, [sp, #12]
   1fd4a:	4d0d      	ldr	r5, [pc, #52]	; (1fd80 <rpc_transport_ipc_init+0x78>)
   1fd4c:	4b0d      	ldr	r3, [pc, #52]	; (1fd84 <rpc_transport_ipc_init+0x7c>)
   1fd4e:	9104      	str	r1, [sp, #16]
   1fd50:	9005      	str	r0, [sp, #20]
   1fd52:	490d      	ldr	r1, [pc, #52]	; (1fd88 <rpc_transport_ipc_init+0x80>)
   1fd54:	a802      	add	r0, sp, #8
   1fd56:	9307      	str	r3, [sp, #28]
   1fd58:	9506      	str	r5, [sp, #24]
   1fd5a:	9202      	str	r2, [sp, #8]
   1fd5c:	f003 ff44 	bl	23be8 <rpc_transport_register>
   1fd60:	4603      	mov	r3, r0
   1fd62:	e7dc      	b.n	1fd1e <rpc_transport_ipc_init+0x16>
   1fd64:	230e      	movs	r3, #14
   1fd66:	4618      	mov	r0, r3
   1fd68:	4770      	bx	lr
   1fd6a:	bf00      	nop
   1fd6c:	20028cf8 	.word	0x20028cf8
   1fd70:	0002072d 	.word	0x0002072d
   1fd74:	000207fd 	.word	0x000207fd
   1fd78:	000203ed 	.word	0x000203ed
   1fd7c:	0002062d 	.word	0x0002062d
   1fd80:	0001fcd1 	.word	0x0001fcd1
   1fd84:	0001fccd 	.word	0x0001fccd
   1fd88:	20028d00 	.word	0x20028d00

0001fd8c <rpc_transport_rx_handle>:
   1fd8c:	b160      	cbz	r0, 1fda8 <rpc_transport_rx_handle+0x1c>
   1fd8e:	b508      	push	{r3, lr}
   1fd90:	6843      	ldr	r3, [r0, #4]
   1fd92:	b2db      	uxtb	r3, r3
   1fd94:	2b02      	cmp	r3, #2
   1fd96:	d00e      	beq.n	1fdb6 <rpc_transport_rx_handle+0x2a>
   1fd98:	6803      	ldr	r3, [r0, #0]
   1fd9a:	0c1b      	lsrs	r3, r3, #16
   1fd9c:	2b02      	cmp	r3, #2
   1fd9e:	d005      	beq.n	1fdac <rpc_transport_rx_handle+0x20>
   1fda0:	2b04      	cmp	r3, #4
   1fda2:	d00e      	beq.n	1fdc2 <rpc_transport_rx_handle+0x36>
   1fda4:	2000      	movs	r0, #0
   1fda6:	bd08      	pop	{r3, pc}
   1fda8:	2000      	movs	r0, #0
   1fdaa:	4770      	bx	lr
   1fdac:	6880      	ldr	r0, [r0, #8]
   1fdae:	f7fe fb69 	bl	1e484 <nrf_shared_free>
   1fdb2:	2000      	movs	r0, #0
   1fdb4:	bd08      	pop	{r3, pc}
   1fdb6:	4601      	mov	r1, r0
   1fdb8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   1fdbc:	4803      	ldr	r0, [pc, #12]	; (1fdcc <rpc_transport_rx_handle+0x40>)
   1fdbe:	f003 be05 	b.w	239cc <rpc_transport_input>
   1fdc2:	4802      	ldr	r0, [pc, #8]	; (1fdcc <rpc_transport_rx_handle+0x40>)
   1fdc4:	f003 ff70 	bl	23ca8 <rpc_transport_unregister>
   1fdc8:	2000      	movs	r0, #0
   1fdca:	bd08      	pop	{r3, pc}
   1fdcc:	20028d00 	.word	0x20028d00

0001fdd0 <rpc_transport_ipc_rx_init>:
   1fdd0:	2800      	cmp	r0, #0
   1fdd2:	f000 80ff 	beq.w	1ffd4 <rpc_transport_ipc_rx_init+0x204>
   1fdd6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1fdda:	6805      	ldr	r5, [r0, #0]
   1fddc:	b095      	sub	sp, #84	; 0x54
   1fdde:	2d00      	cmp	r5, #0
   1fde0:	f000 80ee 	beq.w	1ffc0 <rpc_transport_ipc_rx_init+0x1f0>
   1fde4:	6883      	ldr	r3, [r0, #8]
   1fde6:	2b00      	cmp	r3, #0
   1fde8:	f000 80ea 	beq.w	1ffc0 <rpc_transport_ipc_rx_init+0x1f0>
   1fdec:	6907      	ldr	r7, [r0, #16]
   1fdee:	2f00      	cmp	r7, #0
   1fdf0:	f000 80e6 	beq.w	1ffc0 <rpc_transport_ipc_rx_init+0x1f0>
   1fdf4:	6a84      	ldr	r4, [r0, #40]	; 0x28
   1fdf6:	2c00      	cmp	r4, #0
   1fdf8:	f000 80e2 	beq.w	1ffc0 <rpc_transport_ipc_rx_init+0x1f0>
   1fdfc:	6844      	ldr	r4, [r0, #4]
   1fdfe:	2c1b      	cmp	r4, #27
   1fe00:	f240 80e3 	bls.w	1ffca <rpc_transport_ipc_rx_init+0x1fa>
   1fe04:	68c4      	ldr	r4, [r0, #12]
   1fe06:	2c0b      	cmp	r4, #11
   1fe08:	f240 80df 	bls.w	1ffca <rpc_transport_ipc_rx_init+0x1fa>
   1fe0c:	f8d0 e014 	ldr.w	lr, [r0, #20]
   1fe10:	f1be 0f17 	cmp.w	lr, #23
   1fe14:	f240 80d9 	bls.w	1ffca <rpc_transport_ipc_rx_init+0x1fa>
   1fe18:	2600      	movs	r6, #0
   1fe1a:	4604      	mov	r4, r0
   1fe1c:	486f      	ldr	r0, [pc, #444]	; (1ffdc <rpc_transport_ipc_rx_init+0x20c>)
   1fe1e:	e9cd 1200 	strd	r1, r2, [sp]
   1fe22:	f8df a1d8 	ldr.w	sl, [pc, #472]	; 1fffc <rpc_transport_ipc_rx_init+0x22c>
   1fe26:	496e      	ldr	r1, [pc, #440]	; (1ffe0 <rpc_transport_ipc_rx_init+0x210>)
   1fe28:	8006      	strh	r6, [r0, #0]
   1fe2a:	6ba0      	ldr	r0, [r4, #56]	; 0x38
   1fe2c:	f8df c1d0 	ldr.w	ip, [pc, #464]	; 20000 <__kernel_ram_size>
   1fe30:	f8df 81d0 	ldr.w	r8, [pc, #464]	; 20004 <__kernel_ram_size+0x4>
   1fe34:	f8df b1d0 	ldr.w	fp, [pc, #464]	; 20008 <__kernel_ram_size+0x8>
   1fe38:	f8df 91d0 	ldr.w	r9, [pc, #464]	; 2000c <__kernel_ram_size+0xc>
   1fe3c:	4672      	mov	r2, lr
   1fe3e:	600e      	str	r6, [r1, #0]
   1fe40:	f8ca 0000 	str.w	r0, [sl]
   1fe44:	4631      	mov	r1, r6
   1fe46:	4638      	mov	r0, r7
   1fe48:	f8cc 6000 	str.w	r6, [ip]
   1fe4c:	f8cb 3000 	str.w	r3, [fp]
   1fe50:	f8c8 6000 	str.w	r6, [r8]
   1fe54:	f8c9 6000 	str.w	r6, [r9]
   1fe58:	f00f fa9c 	bl	2f394 <memset>
   1fe5c:	69e3      	ldr	r3, [r4, #28]
   1fe5e:	4638      	mov	r0, r7
   1fe60:	603b      	str	r3, [r7, #0]
   1fe62:	69a3      	ldr	r3, [r4, #24]
   1fe64:	607b      	str	r3, [r7, #4]
   1fe66:	f7ff fcd5 	bl	1f814 <ipc_trace_init>
   1fe6a:	2201      	movs	r2, #1
   1fe6c:	f04f 0c04 	mov.w	ip, #4
   1fe70:	4b5c      	ldr	r3, [pc, #368]	; (1ffe4 <rpc_transport_ipc_rx_init+0x214>)
   1fe72:	495d      	ldr	r1, [pc, #372]	; (1ffe8 <rpc_transport_ipc_rx_init+0x218>)
   1fe74:	f8c3 5610 	str.w	r5, [r3, #1552]	; 0x610
   1fe78:	6809      	ldr	r1, [r1, #0]
   1fe7a:	2080      	movs	r0, #128	; 0x80
   1fe7c:	9104      	str	r1, [sp, #16]
   1fe7e:	495b      	ldr	r1, [pc, #364]	; (1ffec <rpc_transport_ipc_rx_init+0x21c>)
   1fe80:	f8dd e010 	ldr.w	lr, [sp, #16]
   1fe84:	f8c3 6614 	str.w	r6, [r3, #1556]	; 0x614
   1fe88:	6809      	ldr	r1, [r1, #0]
   1fe8a:	702e      	strb	r6, [r5, #0]
   1fe8c:	9103      	str	r1, [sp, #12]
   1fe8e:	706e      	strb	r6, [r5, #1]
   1fe90:	70ee      	strb	r6, [r5, #3]
   1fe92:	70aa      	strb	r2, [r5, #2]
   1fe94:	9903      	ldr	r1, [sp, #12]
   1fe96:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   1fe98:	f8db e000 	ldr.w	lr, [fp]
   1fe9c:	6069      	str	r1, [r5, #4]
   1fe9e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   1fea0:	9c01      	ldr	r4, [sp, #4]
   1fea2:	60a9      	str	r1, [r5, #8]
   1fea4:	60ec      	str	r4, [r5, #12]
   1fea6:	9c00      	ldr	r4, [sp, #0]
   1fea8:	4951      	ldr	r1, [pc, #324]	; (1fff0 <rpc_transport_ipc_rx_init+0x220>)
   1feaa:	61af      	str	r7, [r5, #24]
   1feac:	f8c5 e014 	str.w	lr, [r5, #20]
   1feb0:	612c      	str	r4, [r5, #16]
   1feb2:	f8c3 2590 	str.w	r2, [r3, #1424]	; 0x590
   1feb6:	680c      	ldr	r4, [r1, #0]
   1feb8:	f5a1 6192 	sub.w	r1, r1, #1168	; 0x490
   1febc:	9405      	str	r4, [sp, #20]
   1febe:	9c05      	ldr	r4, [sp, #20]
   1fec0:	f8c3 c598 	str.w	ip, [r3, #1432]	; 0x598
   1fec4:	f8d1 4498 	ldr.w	r4, [r1, #1176]	; 0x498
   1fec8:	f44f 6780 	mov.w	r7, #1024	; 0x400
   1fecc:	9406      	str	r4, [sp, #24]
   1fece:	9c06      	ldr	r4, [sp, #24]
   1fed0:	2410      	movs	r4, #16
   1fed2:	f8c3 45a0 	str.w	r4, [r3, #1440]	; 0x5a0
   1fed6:	f8d1 44a0 	ldr.w	r4, [r1, #1184]	; 0x4a0
   1feda:	4d46      	ldr	r5, [pc, #280]	; (1fff4 <rpc_transport_ipc_rx_init+0x224>)
   1fedc:	9407      	str	r4, [sp, #28]
   1fede:	9c07      	ldr	r4, [sp, #28]
   1fee0:	2440      	movs	r4, #64	; 0x40
   1fee2:	f8c3 45a8 	str.w	r4, [r3, #1448]	; 0x5a8
   1fee6:	f8d1 44a8 	ldr.w	r4, [r1, #1192]	; 0x4a8
   1feea:	9408      	str	r4, [sp, #32]
   1feec:	9c08      	ldr	r4, [sp, #32]
   1feee:	f8c3 05ac 	str.w	r0, [r3, #1452]	; 0x5ac
   1fef2:	f8d1 04ac 	ldr.w	r0, [r1, #1196]	; 0x4ac
   1fef6:	9009      	str	r0, [sp, #36]	; 0x24
   1fef8:	9809      	ldr	r0, [sp, #36]	; 0x24
   1fefa:	f8c3 6100 	str.w	r6, [r3, #256]	; 0x100
   1fefe:	6808      	ldr	r0, [r1, #0]
   1ff00:	900a      	str	r0, [sp, #40]	; 0x28
   1ff02:	980a      	ldr	r0, [sp, #40]	; 0x28
   1ff04:	f8c3 6108 	str.w	r6, [r3, #264]	; 0x108
   1ff08:	6888      	ldr	r0, [r1, #8]
   1ff0a:	900b      	str	r0, [sp, #44]	; 0x2c
   1ff0c:	980b      	ldr	r0, [sp, #44]	; 0x2c
   1ff0e:	f8c3 6110 	str.w	r6, [r3, #272]	; 0x110
   1ff12:	6908      	ldr	r0, [r1, #16]
   1ff14:	900c      	str	r0, [sp, #48]	; 0x30
   1ff16:	980c      	ldr	r0, [sp, #48]	; 0x30
   1ff18:	f8c3 6118 	str.w	r6, [r3, #280]	; 0x118
   1ff1c:	6988      	ldr	r0, [r1, #24]
   1ff1e:	900d      	str	r0, [sp, #52]	; 0x34
   1ff20:	980d      	ldr	r0, [sp, #52]	; 0x34
   1ff22:	f8c3 611c 	str.w	r6, [r3, #284]	; 0x11c
   1ff26:	69c8      	ldr	r0, [r1, #28]
   1ff28:	f501 7101 	add.w	r1, r1, #516	; 0x204
   1ff2c:	900e      	str	r0, [sp, #56]	; 0x38
   1ff2e:	980e      	ldr	r0, [sp, #56]	; 0x38
   1ff30:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
   1ff34:	4310      	orrs	r0, r2
   1ff36:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
   1ff3a:	680c      	ldr	r4, [r1, #0]
   1ff3c:	482e      	ldr	r0, [pc, #184]	; (1fff8 <rpc_transport_ipc_rx_init+0x228>)
   1ff3e:	940f      	str	r4, [sp, #60]	; 0x3c
   1ff40:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
   1ff42:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   1ff46:	ea44 040c 	orr.w	r4, r4, ip
   1ff4a:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   1ff4e:	680c      	ldr	r4, [r1, #0]
   1ff50:	9410      	str	r4, [sp, #64]	; 0x40
   1ff52:	9c10      	ldr	r4, [sp, #64]	; 0x40
   1ff54:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   1ff58:	f044 0410 	orr.w	r4, r4, #16
   1ff5c:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   1ff60:	680c      	ldr	r4, [r1, #0]
   1ff62:	9411      	str	r4, [sp, #68]	; 0x44
   1ff64:	9c11      	ldr	r4, [sp, #68]	; 0x44
   1ff66:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   1ff6a:	f044 0440 	orr.w	r4, r4, #64	; 0x40
   1ff6e:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   1ff72:	680c      	ldr	r4, [r1, #0]
   1ff74:	9412      	str	r4, [sp, #72]	; 0x48
   1ff76:	9c12      	ldr	r4, [sp, #72]	; 0x48
   1ff78:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   1ff7c:	f044 0480 	orr.w	r4, r4, #128	; 0x80
   1ff80:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   1ff84:	f8da 3000 	ldr.w	r3, [sl]
   1ff88:	6809      	ldr	r1, [r1, #0]
   1ff8a:	015b      	lsls	r3, r3, #5
   1ff8c:	9113      	str	r1, [sp, #76]	; 0x4c
   1ff8e:	b2db      	uxtb	r3, r3
   1ff90:	9913      	ldr	r1, [sp, #76]	; 0x4c
   1ff92:	f8c8 2000 	str.w	r2, [r8]
   1ff96:	f880 332a 	strb.w	r3, [r0, #810]	; 0x32a
   1ff9a:	f8c0 7184 	str.w	r7, [r0, #388]	; 0x184
   1ff9e:	6047      	str	r7, [r0, #4]
   1ffa0:	9602      	str	r6, [sp, #8]
   1ffa2:	f8c5 6610 	str.w	r6, [r5, #1552]	; 0x610
   1ffa6:	f8d5 3610 	ldr.w	r3, [r5, #1552]	; 0x610
   1ffaa:	9302      	str	r3, [sp, #8]
   1ffac:	9b02      	ldr	r3, [sp, #8]
   1ffae:	f8d8 3000 	ldr.w	r3, [r8]
   1ffb2:	2b01      	cmp	r3, #1
   1ffb4:	d0fb      	beq.n	1ffae <rpc_transport_ipc_rx_init+0x1de>
   1ffb6:	f8d9 0000 	ldr.w	r0, [r9]
   1ffba:	b015      	add	sp, #84	; 0x54
   1ffbc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ffc0:	f24c 000e 	movw	r0, #49166	; 0xc00e
   1ffc4:	b015      	add	sp, #84	; 0x54
   1ffc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ffca:	f24c 0009 	movw	r0, #49161	; 0xc009
   1ffce:	b015      	add	sp, #84	; 0x54
   1ffd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ffd4:	f24c 000e 	movw	r0, #49166	; 0xc00e
   1ffd8:	4770      	bx	lr
   1ffda:	bf00      	nop
   1ffdc:	2002d48a 	.word	0x2002d48a
   1ffe0:	20028d10 	.word	0x20028d10
   1ffe4:	4002a000 	.word	0x4002a000
   1ffe8:	4002a610 	.word	0x4002a610
   1ffec:	4002a614 	.word	0x4002a614
   1fff0:	4002a590 	.word	0x4002a590
   1fff4:	40005000 	.word	0x40005000
   1fff8:	e000e100 	.word	0xe000e100
   1fffc:	20028d08 	.word	0x20028d08
   20000:	20028d14 	.word	0x20028d14
   20004:	20028d0c 	.word	0x20028d0c
   20008:	20028d18 	.word	0x20028d18
   2000c:	20028d04 	.word	0x20028d04

00020010 <IPC_IRQHandler>:
   20010:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20014:	f44f 6580 	mov.w	r5, #1024	; 0x400
   20018:	4ca7      	ldr	r4, [pc, #668]	; (202b8 <IPC_IRQHandler+0x2a8>)
   2001a:	b087      	sub	sp, #28
   2001c:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
   20020:	f3bf 8f4f 	dsb	sy
   20024:	f3bf 8f6f 	isb	sy
   20028:	4ea4      	ldr	r6, [pc, #656]	; (202bc <IPC_IRQHandler+0x2ac>)
   2002a:	f8c4 5184 	str.w	r5, [r4, #388]	; 0x184
   2002e:	f8d6 330c 	ldr.w	r3, [r6, #780]	; 0x30c
   20032:	061f      	lsls	r7, r3, #24
   20034:	f100 80c8 	bmi.w	201c8 <IPC_IRQHandler+0x1b8>
   20038:	4ba0      	ldr	r3, [pc, #640]	; (202bc <IPC_IRQHandler+0x2ac>)
   2003a:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
   2003e:	07d0      	lsls	r0, r2, #31
   20040:	f100 80d4 	bmi.w	201ec <IPC_IRQHandler+0x1dc>
   20044:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
   20048:	f012 0240 	ands.w	r2, r2, #64	; 0x40
   2004c:	f040 80b6 	bne.w	201bc <IPC_IRQHandler+0x1ac>
   20050:	f8d3 130c 	ldr.w	r1, [r3, #780]	; 0x30c
   20054:	0749      	lsls	r1, r1, #29
   20056:	f100 80e6 	bmi.w	20226 <IPC_IRQHandler+0x216>
   2005a:	f8d3 330c 	ldr.w	r3, [r3, #780]	; 0x30c
   2005e:	06da      	lsls	r2, r3, #27
   20060:	f140 809d 	bpl.w	2019e <IPC_IRQHandler+0x18e>
   20064:	2100      	movs	r1, #0
   20066:	4a95      	ldr	r2, [pc, #596]	; (202bc <IPC_IRQHandler+0x2ac>)
   20068:	4b95      	ldr	r3, [pc, #596]	; (202c0 <IPC_IRQHandler+0x2b0>)
   2006a:	f8c2 1110 	str.w	r1, [r2, #272]	; 0x110
   2006e:	681b      	ldr	r3, [r3, #0]
   20070:	9304      	str	r3, [sp, #16]
   20072:	9b04      	ldr	r3, [sp, #16]
   20074:	f8df 8270 	ldr.w	r8, [pc, #624]	; 202e8 <IPC_IRQHandler+0x2d8>
   20078:	4f92      	ldr	r7, [pc, #584]	; (202c4 <IPC_IRQHandler+0x2b4>)
   2007a:	f8df 9270 	ldr.w	r9, [pc, #624]	; 202ec <IPC_IRQHandler+0x2dc>
   2007e:	f8d8 a000 	ldr.w	sl, [r8]
   20082:	f8da 1000 	ldr.w	r1, [sl]
   20086:	2900      	cmp	r1, #0
   20088:	d03f      	beq.n	2010a <IPC_IRQHandler+0xfa>
   2008a:	2200      	movs	r2, #0
   2008c:	4614      	mov	r4, r2
   2008e:	e002      	b.n	20096 <IPC_IRQHandler+0x86>
   20090:	3401      	adds	r4, #1
   20092:	428c      	cmp	r4, r1
   20094:	d227      	bcs.n	200e6 <IPC_IRQHandler+0xd6>
   20096:	eb0a 05c4 	add.w	r5, sl, r4, lsl #3
   2009a:	68ab      	ldr	r3, [r5, #8]
   2009c:	2b00      	cmp	r3, #0
   2009e:	d0f7      	beq.n	20090 <IPC_IRQHandler+0x80>
   200a0:	686e      	ldr	r6, [r5, #4]
   200a2:	b2f6      	uxtb	r6, r6
   200a4:	2e01      	cmp	r6, #1
   200a6:	d1f3      	bne.n	20090 <IPC_IRQHandler+0x80>
   200a8:	6868      	ldr	r0, [r5, #4]
   200aa:	f8b9 3000 	ldrh.w	r3, [r9]
   200ae:	ebb3 4f10 	cmp.w	r3, r0, lsr #16
   200b2:	d1ed      	bne.n	20090 <IPC_IRQHandler+0x80>
   200b4:	686a      	ldr	r2, [r5, #4]
   200b6:	3301      	adds	r3, #1
   200b8:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   200bc:	f042 0202 	orr.w	r2, r2, #2
   200c0:	606a      	str	r2, [r5, #4]
   200c2:	68a8      	ldr	r0, [r5, #8]
   200c4:	f8a9 3000 	strh.w	r3, [r9]
   200c8:	f7ff fe60 	bl	1fd8c <rpc_transport_rx_handle>
   200cc:	4632      	mov	r2, r6
   200ce:	b928      	cbnz	r0, 200dc <IPC_IRQHandler+0xcc>
   200d0:	686b      	ldr	r3, [r5, #4]
   200d2:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   200d6:	f043 0303 	orr.w	r3, r3, #3
   200da:	606b      	str	r3, [r5, #4]
   200dc:	f8da 1000 	ldr.w	r1, [sl]
   200e0:	3401      	adds	r4, #1
   200e2:	428c      	cmp	r4, r1
   200e4:	d3d7      	bcc.n	20096 <IPC_IRQHandler+0x86>
   200e6:	2a00      	cmp	r2, #0
   200e8:	d1cd      	bne.n	20086 <IPC_IRQHandler+0x76>
   200ea:	b171      	cbz	r1, 2010a <IPC_IRQHandler+0xfa>
   200ec:	4613      	mov	r3, r2
   200ee:	eb0a 02c3 	add.w	r2, sl, r3, lsl #3
   200f2:	6890      	ldr	r0, [r2, #8]
   200f4:	3301      	adds	r3, #1
   200f6:	b130      	cbz	r0, 20106 <IPC_IRQHandler+0xf6>
   200f8:	f8d2 b004 	ldr.w	fp, [r2, #4]
   200fc:	fa5f fb8b 	uxtb.w	fp, fp
   20100:	f1bb 0f01 	cmp.w	fp, #1
   20104:	d003      	beq.n	2010e <IPC_IRQHandler+0xfe>
   20106:	428b      	cmp	r3, r1
   20108:	d1f1      	bne.n	200ee <IPC_IRQHandler+0xde>
   2010a:	f04f 0b00 	mov.w	fp, #0
   2010e:	f8d7 a000 	ldr.w	sl, [r7]
   20112:	f8da 2000 	ldr.w	r2, [sl]
   20116:	2a00      	cmp	r2, #0
   20118:	d03d      	beq.n	20196 <IPC_IRQHandler+0x186>
   2011a:	2100      	movs	r1, #0
   2011c:	460c      	mov	r4, r1
   2011e:	e002      	b.n	20126 <IPC_IRQHandler+0x116>
   20120:	3401      	adds	r4, #1
   20122:	4294      	cmp	r4, r2
   20124:	d227      	bcs.n	20176 <IPC_IRQHandler+0x166>
   20126:	eb0a 05c4 	add.w	r5, sl, r4, lsl #3
   2012a:	68ab      	ldr	r3, [r5, #8]
   2012c:	2b00      	cmp	r3, #0
   2012e:	d0f7      	beq.n	20120 <IPC_IRQHandler+0x110>
   20130:	686e      	ldr	r6, [r5, #4]
   20132:	b2f6      	uxtb	r6, r6
   20134:	2e01      	cmp	r6, #1
   20136:	d1f3      	bne.n	20120 <IPC_IRQHandler+0x110>
   20138:	6868      	ldr	r0, [r5, #4]
   2013a:	f8b9 3000 	ldrh.w	r3, [r9]
   2013e:	ebb3 4f10 	cmp.w	r3, r0, lsr #16
   20142:	d1ed      	bne.n	20120 <IPC_IRQHandler+0x110>
   20144:	686a      	ldr	r2, [r5, #4]
   20146:	3301      	adds	r3, #1
   20148:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   2014c:	f042 0202 	orr.w	r2, r2, #2
   20150:	606a      	str	r2, [r5, #4]
   20152:	68a8      	ldr	r0, [r5, #8]
   20154:	f8a9 3000 	strh.w	r3, [r9]
   20158:	f7ff fe18 	bl	1fd8c <rpc_transport_rx_handle>
   2015c:	4631      	mov	r1, r6
   2015e:	b928      	cbnz	r0, 2016c <IPC_IRQHandler+0x15c>
   20160:	686a      	ldr	r2, [r5, #4]
   20162:	f022 03ff 	bic.w	r3, r2, #255	; 0xff
   20166:	f043 0303 	orr.w	r3, r3, #3
   2016a:	606b      	str	r3, [r5, #4]
   2016c:	f8da 2000 	ldr.w	r2, [sl]
   20170:	3401      	adds	r4, #1
   20172:	4294      	cmp	r4, r2
   20174:	d3d7      	bcc.n	20126 <IPC_IRQHandler+0x116>
   20176:	2900      	cmp	r1, #0
   20178:	d1cd      	bne.n	20116 <IPC_IRQHandler+0x106>
   2017a:	b162      	cbz	r2, 20196 <IPC_IRQHandler+0x186>
   2017c:	460b      	mov	r3, r1
   2017e:	eb0a 01c3 	add.w	r1, sl, r3, lsl #3
   20182:	6888      	ldr	r0, [r1, #8]
   20184:	3301      	adds	r3, #1
   20186:	b120      	cbz	r0, 20192 <IPC_IRQHandler+0x182>
   20188:	6849      	ldr	r1, [r1, #4]
   2018a:	b2c9      	uxtb	r1, r1
   2018c:	2901      	cmp	r1, #1
   2018e:	f43f af76 	beq.w	2007e <IPC_IRQHandler+0x6e>
   20192:	4293      	cmp	r3, r2
   20194:	d1f3      	bne.n	2017e <IPC_IRQHandler+0x16e>
   20196:	f1bb 0f00 	cmp.w	fp, #0
   2019a:	f47f af70 	bne.w	2007e <IPC_IRQHandler+0x6e>
   2019e:	f44f 6180 	mov.w	r1, #1024	; 0x400
   201a2:	4b49      	ldr	r3, [pc, #292]	; (202c8 <IPC_IRQHandler+0x2b8>)
   201a4:	4a44      	ldr	r2, [pc, #272]	; (202b8 <IPC_IRQHandler+0x2a8>)
   201a6:	681b      	ldr	r3, [r3, #0]
   201a8:	015b      	lsls	r3, r3, #5
   201aa:	b2db      	uxtb	r3, r3
   201ac:	f882 332a 	strb.w	r3, [r2, #810]	; 0x32a
   201b0:	f8c2 1184 	str.w	r1, [r2, #388]	; 0x184
   201b4:	6051      	str	r1, [r2, #4]
   201b6:	b007      	add	sp, #28
   201b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   201bc:	2206      	movs	r2, #6
   201be:	4b43      	ldr	r3, [pc, #268]	; (202cc <IPC_IRQHandler+0x2bc>)
   201c0:	601a      	str	r2, [r3, #0]
   201c2:	b007      	add	sp, #28
   201c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   201c8:	f7ff fc0c 	bl	1f9e4 <ipc_trace_handle>
   201cc:	f7ff fd78 	bl	1fcc0 <rpc_trace_coredump_in_progress>
   201d0:	2800      	cmp	r0, #0
   201d2:	d149      	bne.n	20268 <IPC_IRQHandler+0x258>
   201d4:	4b3e      	ldr	r3, [pc, #248]	; (202d0 <IPC_IRQHandler+0x2c0>)
   201d6:	f8c6 011c 	str.w	r0, [r6, #284]	; 0x11c
   201da:	681b      	ldr	r3, [r3, #0]
   201dc:	9301      	str	r3, [sp, #4]
   201de:	9b01      	ldr	r3, [sp, #4]
   201e0:	4b36      	ldr	r3, [pc, #216]	; (202bc <IPC_IRQHandler+0x2ac>)
   201e2:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
   201e6:	07d0      	lsls	r0, r2, #31
   201e8:	f57f af2c 	bpl.w	20044 <IPC_IRQHandler+0x34>
   201ec:	2000      	movs	r0, #0
   201ee:	f248 0202 	movw	r2, #32770	; 0x8002
   201f2:	4938      	ldr	r1, [pc, #224]	; (202d4 <IPC_IRQHandler+0x2c4>)
   201f4:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
   201f8:	6809      	ldr	r1, [r1, #0]
   201fa:	9102      	str	r1, [sp, #8]
   201fc:	9902      	ldr	r1, [sp, #8]
   201fe:	f8d3 3614 	ldr.w	r3, [r3, #1556]	; 0x614
   20202:	4293      	cmp	r3, r2
   20204:	d040      	beq.n	20288 <IPC_IRQHandler+0x278>
   20206:	d81e      	bhi.n	20246 <IPC_IRQHandler+0x236>
   20208:	2b00      	cmp	r3, #0
   2020a:	d04f      	beq.n	202ac <IPC_IRQHandler+0x29c>
   2020c:	2b02      	cmp	r3, #2
   2020e:	d942      	bls.n	20296 <IPC_IRQHandler+0x286>
   20210:	f248 0201 	movw	r2, #32769	; 0x8001
   20214:	4293      	cmp	r3, r2
   20216:	d149      	bne.n	202ac <IPC_IRQHandler+0x29c>
   20218:	2003      	movs	r0, #3
   2021a:	2207      	movs	r2, #7
   2021c:	492b      	ldr	r1, [pc, #172]	; (202cc <IPC_IRQHandler+0x2bc>)
   2021e:	4b2e      	ldr	r3, [pc, #184]	; (202d8 <IPC_IRQHandler+0x2c8>)
   20220:	6008      	str	r0, [r1, #0]
   20222:	601a      	str	r2, [r3, #0]
   20224:	e7cd      	b.n	201c2 <IPC_IRQHandler+0x1b2>
   20226:	4d29      	ldr	r5, [pc, #164]	; (202cc <IPC_IRQHandler+0x2bc>)
   20228:	6829      	ldr	r1, [r5, #0]
   2022a:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   2022e:	2901      	cmp	r1, #1
   20230:	492a      	ldr	r1, [pc, #168]	; (202dc <IPC_IRQHandler+0x2cc>)
   20232:	d05d      	beq.n	202f0 <IPC_IRQHandler+0x2e0>
   20234:	680a      	ldr	r2, [r1, #0]
   20236:	9203      	str	r2, [sp, #12]
   20238:	9a03      	ldr	r2, [sp, #12]
   2023a:	f8d3 330c 	ldr.w	r3, [r3, #780]	; 0x30c
   2023e:	06db      	lsls	r3, r3, #27
   20240:	f53f af10 	bmi.w	20064 <IPC_IRQHandler+0x54>
   20244:	e716      	b.n	20074 <IPC_IRQHandler+0x64>
   20246:	4a26      	ldr	r2, [pc, #152]	; (202e0 <IPC_IRQHandler+0x2d0>)
   20248:	4293      	cmp	r3, r2
   2024a:	d814      	bhi.n	20276 <IPC_IRQHandler+0x266>
   2024c:	f1b3 6f88 	cmp.w	r3, #71303168	; 0x4400000
   20250:	d814      	bhi.n	2027c <IPC_IRQHandler+0x26c>
   20252:	f248 0203 	movw	r2, #32771	; 0x8003
   20256:	4293      	cmp	r3, r2
   20258:	d128      	bne.n	202ac <IPC_IRQHandler+0x29c>
   2025a:	2003      	movs	r0, #3
   2025c:	2204      	movs	r2, #4
   2025e:	491b      	ldr	r1, [pc, #108]	; (202cc <IPC_IRQHandler+0x2bc>)
   20260:	4b1d      	ldr	r3, [pc, #116]	; (202d8 <IPC_IRQHandler+0x2c8>)
   20262:	6008      	str	r0, [r1, #0]
   20264:	601a      	str	r2, [r3, #0]
   20266:	e7ac      	b.n	201c2 <IPC_IRQHandler+0x1b2>
   20268:	23e0      	movs	r3, #224	; 0xe0
   2026a:	f884 332a 	strb.w	r3, [r4, #810]	; 0x32a
   2026e:	6065      	str	r5, [r4, #4]
   20270:	b007      	add	sp, #28
   20272:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   20276:	4a1b      	ldr	r2, [pc, #108]	; (202e4 <IPC_IRQHandler+0x2d4>)
   20278:	4293      	cmp	r3, r2
   2027a:	d117      	bne.n	202ac <IPC_IRQHandler+0x29c>
   2027c:	2003      	movs	r0, #3
   2027e:	4913      	ldr	r1, [pc, #76]	; (202cc <IPC_IRQHandler+0x2bc>)
   20280:	4a15      	ldr	r2, [pc, #84]	; (202d8 <IPC_IRQHandler+0x2c8>)
   20282:	6008      	str	r0, [r1, #0]
   20284:	6013      	str	r3, [r2, #0]
   20286:	e79c      	b.n	201c2 <IPC_IRQHandler+0x1b2>
   20288:	2003      	movs	r0, #3
   2028a:	2206      	movs	r2, #6
   2028c:	490f      	ldr	r1, [pc, #60]	; (202cc <IPC_IRQHandler+0x2bc>)
   2028e:	4b12      	ldr	r3, [pc, #72]	; (202d8 <IPC_IRQHandler+0x2c8>)
   20290:	6008      	str	r0, [r1, #0]
   20292:	601a      	str	r2, [r3, #0]
   20294:	e795      	b.n	201c2 <IPC_IRQHandler+0x1b2>
   20296:	2303      	movs	r3, #3
   20298:	4618      	mov	r0, r3
   2029a:	490c      	ldr	r1, [pc, #48]	; (202cc <IPC_IRQHandler+0x2bc>)
   2029c:	4a0e      	ldr	r2, [pc, #56]	; (202d8 <IPC_IRQHandler+0x2c8>)
   2029e:	600b      	str	r3, [r1, #0]
   202a0:	6013      	str	r3, [r2, #0]
   202a2:	b007      	add	sp, #28
   202a4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   202a8:	f7ff b910 	b.w	1f4cc <rpc_transport_ipc_fault_handler>
   202ac:	2303      	movs	r3, #3
   202ae:	4907      	ldr	r1, [pc, #28]	; (202cc <IPC_IRQHandler+0x2bc>)
   202b0:	4a09      	ldr	r2, [pc, #36]	; (202d8 <IPC_IRQHandler+0x2c8>)
   202b2:	600b      	str	r3, [r1, #0]
   202b4:	6013      	str	r3, [r2, #0]
   202b6:	e784      	b.n	201c2 <IPC_IRQHandler+0x1b2>
   202b8:	e000e100 	.word	0xe000e100
   202bc:	4002a000 	.word	0x4002a000
   202c0:	4002a110 	.word	0x4002a110
   202c4:	20028d10 	.word	0x20028d10
   202c8:	20028d08 	.word	0x20028d08
   202cc:	20028d0c 	.word	0x20028d0c
   202d0:	4002a11c 	.word	0x4002a11c
   202d4:	4002a100 	.word	0x4002a100
   202d8:	20028d04 	.word	0x20028d04
   202dc:	4002a108 	.word	0x4002a108
   202e0:	04400004 	.word	0x04400004
   202e4:	05500001 	.word	0x05500001
   202e8:	20028d14 	.word	0x20028d14
   202ec:	2002d48a 	.word	0x2002d48a
   202f0:	4a37      	ldr	r2, [pc, #220]	; (203d0 <IPC_IRQHandler+0x3c0>)
   202f2:	680b      	ldr	r3, [r1, #0]
   202f4:	6812      	ldr	r2, [r2, #0]
   202f6:	9305      	str	r3, [sp, #20]
   202f8:	6893      	ldr	r3, [r2, #8]
   202fa:	4836      	ldr	r0, [pc, #216]	; (203d4 <IPC_IRQHandler+0x3c4>)
   202fc:	4936      	ldr	r1, [pc, #216]	; (203d8 <IPC_IRQHandler+0x3c8>)
   202fe:	6003      	str	r3, [r0, #0]
   20300:	6854      	ldr	r4, [r2, #4]
   20302:	9a05      	ldr	r2, [sp, #20]
   20304:	600c      	str	r4, [r1, #0]
   20306:	b16b      	cbz	r3, 20324 <IPC_IRQHandler+0x314>
   20308:	b164      	cbz	r4, 20324 <IPC_IRQHandler+0x314>
   2030a:	681b      	ldr	r3, [r3, #0]
   2030c:	2b10      	cmp	r3, #16
   2030e:	d802      	bhi.n	20316 <IPC_IRQHandler+0x306>
   20310:	6822      	ldr	r2, [r4, #0]
   20312:	2a10      	cmp	r2, #16
   20314:	d90c      	bls.n	20330 <IPC_IRQHandler+0x320>
   20316:	2103      	movs	r1, #3
   20318:	f24c 0206 	movw	r2, #49158	; 0xc006
   2031c:	4b2f      	ldr	r3, [pc, #188]	; (203dc <IPC_IRQHandler+0x3cc>)
   2031e:	6029      	str	r1, [r5, #0]
   20320:	601a      	str	r2, [r3, #0]
   20322:	e74e      	b.n	201c2 <IPC_IRQHandler+0x1b2>
   20324:	2103      	movs	r1, #3
   20326:	2210      	movs	r2, #16
   20328:	4b2c      	ldr	r3, [pc, #176]	; (203dc <IPC_IRQHandler+0x3cc>)
   2032a:	6029      	str	r1, [r5, #0]
   2032c:	601a      	str	r2, [r3, #0]
   2032e:	e748      	b.n	201c2 <IPC_IRQHandler+0x1b2>
   20330:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 203e8 <IPC_IRQHandler+0x3d8>
   20334:	2a00      	cmp	r2, #0
   20336:	d042      	beq.n	203be <IPC_IRQHandler+0x3ae>
   20338:	2300      	movs	r3, #0
   2033a:	f104 0904 	add.w	r9, r4, #4
   2033e:	461e      	mov	r6, r3
   20340:	e002      	b.n	20348 <IPC_IRQHandler+0x338>
   20342:	3601      	adds	r6, #1
   20344:	4296      	cmp	r6, r2
   20346:	d22a      	bcs.n	2039e <IPC_IRQHandler+0x38e>
   20348:	00f7      	lsls	r7, r6, #3
   2034a:	19e1      	adds	r1, r4, r7
   2034c:	6888      	ldr	r0, [r1, #8]
   2034e:	2800      	cmp	r0, #0
   20350:	d0f7      	beq.n	20342 <IPC_IRQHandler+0x332>
   20352:	f8d1 a004 	ldr.w	sl, [r1, #4]
   20356:	fa5f fa8a 	uxtb.w	sl, sl
   2035a:	f1ba 0f01 	cmp.w	sl, #1
   2035e:	d1f0      	bne.n	20342 <IPC_IRQHandler+0x332>
   20360:	f8d1 c004 	ldr.w	ip, [r1, #4]
   20364:	f8b8 0000 	ldrh.w	r0, [r8]
   20368:	ebb0 4f1c 	cmp.w	r0, ip, lsr #16
   2036c:	d1e9      	bne.n	20342 <IPC_IRQHandler+0x332>
   2036e:	684b      	ldr	r3, [r1, #4]
   20370:	1c42      	adds	r2, r0, #1
   20372:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   20376:	f043 0302 	orr.w	r3, r3, #2
   2037a:	604b      	str	r3, [r1, #4]
   2037c:	6888      	ldr	r0, [r1, #8]
   2037e:	f8a8 2000 	strh.w	r2, [r8]
   20382:	f7ff fd03 	bl	1fd8c <rpc_transport_rx_handle>
   20386:	4653      	mov	r3, sl
   20388:	b938      	cbnz	r0, 2039a <IPC_IRQHandler+0x38a>
   2038a:	f859 2007 	ldr.w	r2, [r9, r7]
   2038e:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   20392:	f042 0203 	orr.w	r2, r2, #3
   20396:	f849 2007 	str.w	r2, [r9, r7]
   2039a:	6822      	ldr	r2, [r4, #0]
   2039c:	e7d1      	b.n	20342 <IPC_IRQHandler+0x332>
   2039e:	2b00      	cmp	r3, #0
   203a0:	d1c8      	bne.n	20334 <IPC_IRQHandler+0x324>
   203a2:	b912      	cbnz	r2, 203aa <IPC_IRQHandler+0x39a>
   203a4:	e00b      	b.n	203be <IPC_IRQHandler+0x3ae>
   203a6:	4293      	cmp	r3, r2
   203a8:	d009      	beq.n	203be <IPC_IRQHandler+0x3ae>
   203aa:	eb04 01c3 	add.w	r1, r4, r3, lsl #3
   203ae:	6888      	ldr	r0, [r1, #8]
   203b0:	3301      	adds	r3, #1
   203b2:	2800      	cmp	r0, #0
   203b4:	d0f7      	beq.n	203a6 <IPC_IRQHandler+0x396>
   203b6:	6849      	ldr	r1, [r1, #4]
   203b8:	b2c9      	uxtb	r1, r1
   203ba:	2901      	cmp	r1, #1
   203bc:	d1f3      	bne.n	203a6 <IPC_IRQHandler+0x396>
   203be:	2002      	movs	r0, #2
   203c0:	4b07      	ldr	r3, [pc, #28]	; (203e0 <IPC_IRQHandler+0x3d0>)
   203c2:	f44f 6180 	mov.w	r1, #1024	; 0x400
   203c6:	4a07      	ldr	r2, [pc, #28]	; (203e4 <IPC_IRQHandler+0x3d4>)
   203c8:	681b      	ldr	r3, [r3, #0]
   203ca:	6028      	str	r0, [r5, #0]
   203cc:	e6ec      	b.n	201a8 <IPC_IRQHandler+0x198>
   203ce:	bf00      	nop
   203d0:	20028d18 	.word	0x20028d18
   203d4:	20028d14 	.word	0x20028d14
   203d8:	20028d10 	.word	0x20028d10
   203dc:	20028d04 	.word	0x20028d04
   203e0:	20028d08 	.word	0x20028d08
   203e4:	e000e100 	.word	0xe000e100
   203e8:	2002d48a 	.word	0x2002d48a

000203ec <rpc_transport_msg_free>:
   203ec:	b430      	push	{r4, r5}
   203ee:	4b18      	ldr	r3, [pc, #96]	; (20450 <rpc_transport_msg_free+0x64>)
   203f0:	681c      	ldr	r4, [r3, #0]
   203f2:	6825      	ldr	r5, [r4, #0]
   203f4:	b16d      	cbz	r5, 20412 <rpc_transport_msg_free+0x26>
   203f6:	68a3      	ldr	r3, [r4, #8]
   203f8:	4283      	cmp	r3, r0
   203fa:	d027      	beq.n	2044c <rpc_transport_msg_free+0x60>
   203fc:	2300      	movs	r3, #0
   203fe:	e002      	b.n	20406 <rpc_transport_msg_free+0x1a>
   20400:	6889      	ldr	r1, [r1, #8]
   20402:	4281      	cmp	r1, r0
   20404:	d019      	beq.n	2043a <rpc_transport_msg_free+0x4e>
   20406:	3301      	adds	r3, #1
   20408:	00da      	lsls	r2, r3, #3
   2040a:	42ab      	cmp	r3, r5
   2040c:	eb04 0102 	add.w	r1, r4, r2
   20410:	d1f6      	bne.n	20400 <rpc_transport_msg_free+0x14>
   20412:	4b10      	ldr	r3, [pc, #64]	; (20454 <rpc_transport_msg_free+0x68>)
   20414:	681c      	ldr	r4, [r3, #0]
   20416:	6825      	ldr	r5, [r4, #0]
   20418:	b16d      	cbz	r5, 20436 <rpc_transport_msg_free+0x4a>
   2041a:	68a3      	ldr	r3, [r4, #8]
   2041c:	4283      	cmp	r3, r0
   2041e:	d015      	beq.n	2044c <rpc_transport_msg_free+0x60>
   20420:	2300      	movs	r3, #0
   20422:	e002      	b.n	2042a <rpc_transport_msg_free+0x3e>
   20424:	6889      	ldr	r1, [r1, #8]
   20426:	4281      	cmp	r1, r0
   20428:	d007      	beq.n	2043a <rpc_transport_msg_free+0x4e>
   2042a:	3301      	adds	r3, #1
   2042c:	00da      	lsls	r2, r3, #3
   2042e:	429d      	cmp	r5, r3
   20430:	eb04 0102 	add.w	r1, r4, r2
   20434:	d1f6      	bne.n	20424 <rpc_transport_msg_free+0x38>
   20436:	bc30      	pop	{r4, r5}
   20438:	4770      	bx	lr
   2043a:	3204      	adds	r2, #4
   2043c:	58a3      	ldr	r3, [r4, r2]
   2043e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   20442:	f043 0303 	orr.w	r3, r3, #3
   20446:	50a3      	str	r3, [r4, r2]
   20448:	bc30      	pop	{r4, r5}
   2044a:	4770      	bx	lr
   2044c:	2204      	movs	r2, #4
   2044e:	e7f5      	b.n	2043c <rpc_transport_msg_free+0x50>
   20450:	20028d14 	.word	0x20028d14
   20454:	20028d10 	.word	0x20028d10

00020458 <rpc_transport_ipc_tx_init>:
   20458:	2800      	cmp	r0, #0
   2045a:	f000 80b8 	beq.w	205ce <rpc_transport_ipc_tx_init+0x176>
   2045e:	2900      	cmp	r1, #0
   20460:	f000 80b5 	beq.w	205ce <rpc_transport_ipc_tx_init+0x176>
   20464:	2a00      	cmp	r2, #0
   20466:	f000 80b2 	beq.w	205ce <rpc_transport_ipc_tx_init+0x176>
   2046a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2046e:	6a04      	ldr	r4, [r0, #32]
   20470:	b085      	sub	sp, #20
   20472:	2c00      	cmp	r4, #0
   20474:	f000 80a6 	beq.w	205c4 <rpc_transport_ipc_tx_init+0x16c>
   20478:	6a40      	ldr	r0, [r0, #36]	; 0x24
   2047a:	2800      	cmp	r0, #0
   2047c:	f000 80a2 	beq.w	205c4 <rpc_transport_ipc_tx_init+0x16c>
   20480:	f642 4587 	movw	r5, #11399	; 0x2c87
   20484:	f04f 0a00 	mov.w	sl, #0
   20488:	4e55      	ldr	r6, [pc, #340]	; (205e0 <rpc_transport_ipc_tx_init+0x188>)
   2048a:	42a8      	cmp	r0, r5
   2048c:	f886 a000 	strb.w	sl, [r6]
   20490:	f240 80a0 	bls.w	205d4 <rpc_transport_ipc_tx_init+0x17c>
   20494:	2708      	movs	r7, #8
   20496:	f8df 9180 	ldr.w	r9, [pc, #384]	; 20618 <rpc_transport_ipc_tx_init+0x1c0>
   2049a:	4620      	mov	r0, r4
   2049c:	4616      	mov	r6, r2
   2049e:	460d      	mov	r5, r1
   204a0:	2244      	movs	r2, #68	; 0x44
   204a2:	4651      	mov	r1, sl
   204a4:	f8c9 4000 	str.w	r4, [r9]
   204a8:	f00e ff74 	bl	2f394 <memset>
   204ac:	f8d9 2000 	ldr.w	r2, [r9]
   204b0:	f104 0344 	add.w	r3, r4, #68	; 0x44
   204b4:	f8df 8164 	ldr.w	r8, [pc, #356]	; 2061c <rpc_transport_ipc_tx_init+0x1c4>
   204b8:	f882 a001 	strb.w	sl, [r2, #1]
   204bc:	f882 a002 	strb.w	sl, [r2, #2]
   204c0:	f882 a003 	strb.w	sl, [r2, #3]
   204c4:	7017      	strb	r7, [r2, #0]
   204c6:	4618      	mov	r0, r3
   204c8:	2244      	movs	r2, #68	; 0x44
   204ca:	4651      	mov	r1, sl
   204cc:	f8c8 3000 	str.w	r3, [r8]
   204d0:	f00e ff60 	bl	2f394 <memset>
   204d4:	f8d8 2000 	ldr.w	r2, [r8]
   204d8:	f104 0388 	add.w	r3, r4, #136	; 0x88
   204dc:	f8df b140 	ldr.w	fp, [pc, #320]	; 20620 <rpc_transport_ipc_tx_init+0x1c8>
   204e0:	7017      	strb	r7, [r2, #0]
   204e2:	f882 a001 	strb.w	sl, [r2, #1]
   204e6:	f882 a002 	strb.w	sl, [r2, #2]
   204ea:	f882 a003 	strb.w	sl, [r2, #3]
   204ee:	4618      	mov	r0, r3
   204f0:	f44f 7200 	mov.w	r2, #512	; 0x200
   204f4:	4651      	mov	r1, sl
   204f6:	f8cb 3000 	str.w	r3, [fp]
   204fa:	f00e ff4b 	bl	2f394 <memset>
   204fe:	4b39      	ldr	r3, [pc, #228]	; (205e4 <rpc_transport_ipc_tx_init+0x18c>)
   20500:	f504 7c22 	add.w	ip, r4, #648	; 0x288
   20504:	f8c3 c000 	str.w	ip, [r3]
   20508:	4651      	mov	r1, sl
   2050a:	4660      	mov	r0, ip
   2050c:	f44f 7200 	mov.w	r2, #512	; 0x200
   20510:	f00e ff40 	bl	2f394 <memset>
   20514:	f44f 5c20 	mov.w	ip, #10240	; 0x2800
   20518:	2106      	movs	r1, #6
   2051a:	f04f 0e01 	mov.w	lr, #1
   2051e:	f44f 3001 	mov.w	r0, #132096	; 0x20400
   20522:	f44f 3288 	mov.w	r2, #69632	; 0x11000
   20526:	4b30      	ldr	r3, [pc, #192]	; (205e8 <rpc_transport_ipc_tx_init+0x190>)
   20528:	f504 6491 	add.w	r4, r4, #1160	; 0x488
   2052c:	605c      	str	r4, [r3, #4]
   2052e:	4c2f      	ldr	r4, [pc, #188]	; (205ec <rpc_transport_ipc_tx_init+0x194>)
   20530:	f8c3 c008 	str.w	ip, [r3, #8]
   20534:	8199      	strh	r1, [r3, #12]
   20536:	f8a3 e000 	strh.w	lr, [r3]
   2053a:	4619      	mov	r1, r3
   2053c:	611c      	str	r4, [r3, #16]
   2053e:	4b2c      	ldr	r3, [pc, #176]	; (205f0 <rpc_transport_ipc_tx_init+0x198>)
   20540:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 20624 <rpc_transport_ipc_tx_init+0x1cc>
   20544:	6120      	str	r0, [r4, #16]
   20546:	482b      	ldr	r0, [pc, #172]	; (205f4 <rpc_transport_ipc_tx_init+0x19c>)
   20548:	6063      	str	r3, [r4, #4]
   2054a:	f503 73c0 	add.w	r3, r3, #384	; 0x180
   2054e:	60a0      	str	r0, [r4, #8]
   20550:	f8c4 c000 	str.w	ip, [r4]
   20554:	4828      	ldr	r0, [pc, #160]	; (205f8 <rpc_transport_ipc_tx_init+0x1a0>)
   20556:	60e3      	str	r3, [r4, #12]
   20558:	6162      	str	r2, [r4, #20]
   2055a:	f7fd fe59 	bl	1e210 <nrf_mem_register>
   2055e:	2800      	cmp	r0, #0
   20560:	d132      	bne.n	205c8 <rpc_transport_ipc_tx_init+0x170>
   20562:	f04f 0c02 	mov.w	ip, #2
   20566:	2420      	movs	r4, #32
   20568:	f8d9 1000 	ldr.w	r1, [r9]
   2056c:	f8db 2000 	ldr.w	r2, [fp]
   20570:	6029      	str	r1, [r5, #0]
   20572:	4b1c      	ldr	r3, [pc, #112]	; (205e4 <rpc_transport_ipc_tx_init+0x18c>)
   20574:	f8d8 1000 	ldr.w	r1, [r8]
   20578:	f8df e0ac 	ldr.w	lr, [pc, #172]	; 20628 <rpc_transport_ipc_tx_init+0x1d0>
   2057c:	4d1f      	ldr	r5, [pc, #124]	; (205fc <rpc_transport_ipc_tx_init+0x1a4>)
   2057e:	6031      	str	r1, [r6, #0]
   20580:	f8ce 2000 	str.w	r2, [lr]
   20584:	681b      	ldr	r3, [r3, #0]
   20586:	491e      	ldr	r1, [pc, #120]	; (20600 <rpc_transport_ipc_tx_init+0x1a8>)
   20588:	f502 7200 	add.w	r2, r2, #512	; 0x200
   2058c:	602a      	str	r2, [r5, #0]
   2058e:	4e1d      	ldr	r6, [pc, #116]	; (20604 <rpc_transport_ipc_tx_init+0x1ac>)
   20590:	4a1d      	ldr	r2, [pc, #116]	; (20608 <rpc_transport_ipc_tx_init+0x1b0>)
   20592:	4d1e      	ldr	r5, [pc, #120]	; (2060c <rpc_transport_ipc_tx_init+0x1b4>)
   20594:	600b      	str	r3, [r1, #0]
   20596:	f503 7300 	add.w	r3, r3, #512	; 0x200
   2059a:	491d      	ldr	r1, [pc, #116]	; (20610 <rpc_transport_ipc_tx_init+0x1b8>)
   2059c:	6033      	str	r3, [r6, #0]
   2059e:	8028      	strh	r0, [r5, #0]
   205a0:	f8c2 c514 	str.w	ip, [r2, #1300]	; 0x514
   205a4:	6809      	ldr	r1, [r1, #0]
   205a6:	4b1b      	ldr	r3, [pc, #108]	; (20614 <rpc_transport_ipc_tx_init+0x1bc>)
   205a8:	9103      	str	r1, [sp, #12]
   205aa:	9903      	ldr	r1, [sp, #12]
   205ac:	f8c2 751c 	str.w	r7, [r2, #1308]	; 0x51c
   205b0:	6819      	ldr	r1, [r3, #0]
   205b2:	443b      	add	r3, r7
   205b4:	9102      	str	r1, [sp, #8]
   205b6:	9902      	ldr	r1, [sp, #8]
   205b8:	f8c2 4524 	str.w	r4, [r2, #1316]	; 0x524
   205bc:	681b      	ldr	r3, [r3, #0]
   205be:	9301      	str	r3, [sp, #4]
   205c0:	9b01      	ldr	r3, [sp, #4]
   205c2:	e001      	b.n	205c8 <rpc_transport_ipc_tx_init+0x170>
   205c4:	f24c 0007 	movw	r0, #49159	; 0xc007
   205c8:	b005      	add	sp, #20
   205ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   205ce:	f24c 000e 	movw	r0, #49166	; 0xc00e
   205d2:	4770      	bx	lr
   205d4:	f24c 0004 	movw	r0, #49156	; 0xc004
   205d8:	b005      	add	sp, #20
   205da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   205de:	bf00      	nop
   205e0:	200314bb 	.word	0x200314bb
   205e4:	20028d44 	.word	0x20028d44
   205e8:	20028d30 	.word	0x20028d30
   205ec:	20028d54 	.word	0x20028d54
   205f0:	00040080 	.word	0x00040080
   205f4:	00040100 	.word	0x00040100
   205f8:	20028d1c 	.word	0x20028d1c
   205fc:	20028d28 	.word	0x20028d28
   20600:	20028d24 	.word	0x20028d24
   20604:	20028d20 	.word	0x20028d20
   20608:	4002a000 	.word	0x4002a000
   2060c:	2002d48c 	.word	0x2002d48c
   20610:	4002a514 	.word	0x4002a514
   20614:	4002a51c 	.word	0x4002a51c
   20618:	20028d50 	.word	0x20028d50
   2061c:	20028d48 	.word	0x20028d48
   20620:	20028d4c 	.word	0x20028d4c
   20624:	00080040 	.word	0x00080040
   20628:	20028d2c 	.word	0x20028d2c

0002062c <rpc_transport_ipc_tx_send>:
   2062c:	2800      	cmp	r0, #0
   2062e:	d05f      	beq.n	206f0 <rpc_transport_ipc_tx_send+0xc4>
   20630:	b470      	push	{r4, r5, r6}
   20632:	4b33      	ldr	r3, [pc, #204]	; (20700 <rpc_transport_ipc_tx_send+0xd4>)
   20634:	b083      	sub	sp, #12
   20636:	681a      	ldr	r2, [r3, #0]
   20638:	4b32      	ldr	r3, [pc, #200]	; (20704 <rpc_transport_ipc_tx_send+0xd8>)
   2063a:	4282      	cmp	r2, r0
   2063c:	d81e      	bhi.n	2067c <rpc_transport_ipc_tx_send+0x50>
   2063e:	681b      	ldr	r3, [r3, #0]
   20640:	4931      	ldr	r1, [pc, #196]	; (20708 <rpc_transport_ipc_tx_send+0xdc>)
   20642:	4283      	cmp	r3, r0
   20644:	6809      	ldr	r1, [r1, #0]
   20646:	d803      	bhi.n	20650 <rpc_transport_ipc_tx_send+0x24>
   20648:	4c30      	ldr	r4, [pc, #192]	; (2070c <rpc_transport_ipc_tx_send+0xe0>)
   2064a:	6824      	ldr	r4, [r4, #0]
   2064c:	4284      	cmp	r4, r0
   2064e:	d847      	bhi.n	206e0 <rpc_transport_ipc_tx_send+0xb4>
   20650:	4281      	cmp	r1, r0
   20652:	d90e      	bls.n	20672 <rpc_transport_ipc_tx_send+0x46>
   20654:	4b2e      	ldr	r3, [pc, #184]	; (20710 <rpc_transport_ipc_tx_send+0xe4>)
   20656:	781b      	ldrb	r3, [r3, #0]
   20658:	2b00      	cmp	r3, #0
   2065a:	d14c      	bne.n	206f6 <rpc_transport_ipc_tx_send+0xca>
   2065c:	1a83      	subs	r3, r0, r2
   2065e:	492d      	ldr	r1, [pc, #180]	; (20714 <rpc_transport_ipc_tx_send+0xe8>)
   20660:	099e      	lsrs	r6, r3, #6
   20662:	069b      	lsls	r3, r3, #26
   20664:	680a      	ldr	r2, [r1, #0]
   20666:	4c2c      	ldr	r4, [pc, #176]	; (20718 <rpc_transport_ipc_tx_send+0xec>)
   20668:	f04f 0103 	mov.w	r1, #3
   2066c:	f04f 0502 	mov.w	r5, #2
   20670:	d014      	beq.n	2069c <rpc_transport_ipc_tx_send+0x70>
   20672:	f24c 0010 	movw	r0, #49168	; 0xc010
   20676:	b003      	add	sp, #12
   20678:	bc70      	pop	{r4, r5, r6}
   2067a:	4770      	bx	lr
   2067c:	681b      	ldr	r3, [r3, #0]
   2067e:	4298      	cmp	r0, r3
   20680:	d3f7      	bcc.n	20672 <rpc_transport_ipc_tx_send+0x46>
   20682:	4a22      	ldr	r2, [pc, #136]	; (2070c <rpc_transport_ipc_tx_send+0xe0>)
   20684:	6812      	ldr	r2, [r2, #0]
   20686:	4290      	cmp	r0, r2
   20688:	d2f3      	bcs.n	20672 <rpc_transport_ipc_tx_send+0x46>
   2068a:	2101      	movs	r1, #1
   2068c:	1ac3      	subs	r3, r0, r3
   2068e:	4a23      	ldr	r2, [pc, #140]	; (2071c <rpc_transport_ipc_tx_send+0xf0>)
   20690:	099e      	lsrs	r6, r3, #6
   20692:	069b      	lsls	r3, r3, #26
   20694:	460d      	mov	r5, r1
   20696:	6812      	ldr	r2, [r2, #0]
   20698:	4c21      	ldr	r4, [pc, #132]	; (20720 <rpc_transport_ipc_tx_send+0xf4>)
   2069a:	d1ea      	bne.n	20672 <rpc_transport_ipc_tx_send+0x46>
   2069c:	6843      	ldr	r3, [r0, #4]
   2069e:	b2db      	uxtb	r3, r3
   206a0:	429d      	cmp	r5, r3
   206a2:	d120      	bne.n	206e6 <rpc_transport_ipc_tx_send+0xba>
   206a4:	2020      	movs	r0, #32
   206a6:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
   206aa:	4d1e      	ldr	r5, [pc, #120]	; (20724 <rpc_transport_ipc_tx_send+0xf8>)
   206ac:	6853      	ldr	r3, [r2, #4]
   206ae:	882e      	ldrh	r6, [r5, #0]
   206b0:	b29b      	uxth	r3, r3
   206b2:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   206b6:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   206ba:	f043 0301 	orr.w	r3, r3, #1
   206be:	6053      	str	r3, [r2, #4]
   206c0:	bf00      	nop
   206c2:	3801      	subs	r0, #1
   206c4:	d1fc      	bne.n	206c0 <rpc_transport_ipc_tx_send+0x94>
   206c6:	2201      	movs	r2, #1
   206c8:	4b17      	ldr	r3, [pc, #92]	; (20728 <rpc_transport_ipc_tx_send+0xfc>)
   206ca:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
   206ce:	6822      	ldr	r2, [r4, #0]
   206d0:	882b      	ldrh	r3, [r5, #0]
   206d2:	9201      	str	r2, [sp, #4]
   206d4:	9a01      	ldr	r2, [sp, #4]
   206d6:	3301      	adds	r3, #1
   206d8:	802b      	strh	r3, [r5, #0]
   206da:	b003      	add	sp, #12
   206dc:	bc70      	pop	{r4, r5, r6}
   206de:	4770      	bx	lr
   206e0:	4281      	cmp	r1, r0
   206e2:	d9d2      	bls.n	2068a <rpc_transport_ipc_tx_send+0x5e>
   206e4:	e7b6      	b.n	20654 <rpc_transport_ipc_tx_send+0x28>
   206e6:	f24c 0007 	movw	r0, #49159	; 0xc007
   206ea:	b003      	add	sp, #12
   206ec:	bc70      	pop	{r4, r5, r6}
   206ee:	4770      	bx	lr
   206f0:	f24c 000e 	movw	r0, #49166	; 0xc00e
   206f4:	4770      	bx	lr
   206f6:	f24c 000f 	movw	r0, #49167	; 0xc00f
   206fa:	b003      	add	sp, #12
   206fc:	bc70      	pop	{r4, r5, r6}
   206fe:	4770      	bx	lr
   20700:	20028d2c 	.word	0x20028d2c
   20704:	20028d24 	.word	0x20028d24
   20708:	20028d28 	.word	0x20028d28
   2070c:	20028d20 	.word	0x20028d20
   20710:	200314bb 	.word	0x200314bb
   20714:	20028d50 	.word	0x20028d50
   20718:	4002a00c 	.word	0x4002a00c
   2071c:	20028d48 	.word	0x20028d48
   20720:	4002a004 	.word	0x4002a004
   20724:	2002d48c 	.word	0x2002d48c
   20728:	4002a000 	.word	0x4002a000

0002072c <rpc_transport_ipc_tx_rpc_data_alloc>:
   2072c:	4b18      	ldr	r3, [pc, #96]	; (20790 <rpc_transport_ipc_tx_rpc_data_alloc+0x64>)
   2072e:	781b      	ldrb	r3, [r3, #0]
   20730:	bb63      	cbnz	r3, 2078c <rpc_transport_ipc_tx_rpc_data_alloc+0x60>
   20732:	b4f0      	push	{r4, r5, r6, r7}
   20734:	4a17      	ldr	r2, [pc, #92]	; (20794 <rpc_transport_ipc_tx_rpc_data_alloc+0x68>)
   20736:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   2073a:	6814      	ldr	r4, [r2, #0]
   2073c:	4b16      	ldr	r3, [pc, #88]	; (20798 <rpc_transport_ipc_tx_rpc_data_alloc+0x6c>)
   2073e:	6825      	ldr	r5, [r4, #0]
   20740:	681e      	ldr	r6, [r3, #0]
   20742:	b1a5      	cbz	r5, 2076e <rpc_transport_ipc_tx_rpc_data_alloc+0x42>
   20744:	4607      	mov	r7, r0
   20746:	00c1      	lsls	r1, r0, #3
   20748:	1863      	adds	r3, r4, r1
   2074a:	685a      	ldr	r2, [r3, #4]
   2074c:	b2d2      	uxtb	r2, r2
   2074e:	2a03      	cmp	r2, #3
   20750:	d104      	bne.n	2075c <rpc_transport_ipc_tx_rpc_data_alloc+0x30>
   20752:	609f      	str	r7, [r3, #8]
   20754:	685a      	ldr	r2, [r3, #4]
   20756:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   2075a:	605a      	str	r2, [r3, #4]
   2075c:	685a      	ldr	r2, [r3, #4]
   2075e:	f012 0fff 	tst.w	r2, #255	; 0xff
   20762:	d101      	bne.n	20768 <rpc_transport_ipc_tx_rpc_data_alloc+0x3c>
   20764:	689b      	ldr	r3, [r3, #8]
   20766:	b12b      	cbz	r3, 20774 <rpc_transport_ipc_tx_rpc_data_alloc+0x48>
   20768:	3001      	adds	r0, #1
   2076a:	42a8      	cmp	r0, r5
   2076c:	d1eb      	bne.n	20746 <rpc_transport_ipc_tx_rpc_data_alloc+0x1a>
   2076e:	2000      	movs	r0, #0
   20770:	bcf0      	pop	{r4, r5, r6, r7}
   20772:	4770      	bx	lr
   20774:	eb06 1080 	add.w	r0, r6, r0, lsl #6
   20778:	4421      	add	r1, r4
   2077a:	6088      	str	r0, [r1, #8]
   2077c:	6843      	ldr	r3, [r0, #4]
   2077e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   20782:	f043 0302 	orr.w	r3, r3, #2
   20786:	6043      	str	r3, [r0, #4]
   20788:	bcf0      	pop	{r4, r5, r6, r7}
   2078a:	4770      	bx	lr
   2078c:	2000      	movs	r0, #0
   2078e:	4770      	bx	lr
   20790:	200314bb 	.word	0x200314bb
   20794:	20028d50 	.word	0x20028d50
   20798:	20028d4c 	.word	0x20028d4c

0002079c <rpc_transport_ipc_tx_rpc_ctrl_alloc>:
   2079c:	b4f0      	push	{r4, r5, r6, r7}
   2079e:	4a15      	ldr	r2, [pc, #84]	; (207f4 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x58>)
   207a0:	4b15      	ldr	r3, [pc, #84]	; (207f8 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x5c>)
   207a2:	6814      	ldr	r4, [r2, #0]
   207a4:	681e      	ldr	r6, [r3, #0]
   207a6:	6825      	ldr	r5, [r4, #0]
   207a8:	b1ad      	cbz	r5, 207d6 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x3a>
   207aa:	2000      	movs	r0, #0
   207ac:	4607      	mov	r7, r0
   207ae:	00c1      	lsls	r1, r0, #3
   207b0:	1863      	adds	r3, r4, r1
   207b2:	685a      	ldr	r2, [r3, #4]
   207b4:	b2d2      	uxtb	r2, r2
   207b6:	2a03      	cmp	r2, #3
   207b8:	d104      	bne.n	207c4 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x28>
   207ba:	609f      	str	r7, [r3, #8]
   207bc:	685a      	ldr	r2, [r3, #4]
   207be:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   207c2:	605a      	str	r2, [r3, #4]
   207c4:	685a      	ldr	r2, [r3, #4]
   207c6:	f012 0fff 	tst.w	r2, #255	; 0xff
   207ca:	d101      	bne.n	207d0 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x34>
   207cc:	689b      	ldr	r3, [r3, #8]
   207ce:	b12b      	cbz	r3, 207dc <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x40>
   207d0:	3001      	adds	r0, #1
   207d2:	4285      	cmp	r5, r0
   207d4:	d1eb      	bne.n	207ae <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x12>
   207d6:	2000      	movs	r0, #0
   207d8:	bcf0      	pop	{r4, r5, r6, r7}
   207da:	4770      	bx	lr
   207dc:	eb06 1080 	add.w	r0, r6, r0, lsl #6
   207e0:	4421      	add	r1, r4
   207e2:	6088      	str	r0, [r1, #8]
   207e4:	6843      	ldr	r3, [r0, #4]
   207e6:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   207ea:	f043 0301 	orr.w	r3, r3, #1
   207ee:	6043      	str	r3, [r0, #4]
   207f0:	bcf0      	pop	{r4, r5, r6, r7}
   207f2:	4770      	bx	lr
   207f4:	20028d48 	.word	0x20028d48
   207f8:	20028d44 	.word	0x20028d44

000207fc <rpc_transport_ipc_tx_data_alloc>:
   207fc:	4b03      	ldr	r3, [pc, #12]	; (2080c <rpc_transport_ipc_tx_data_alloc+0x10>)
   207fe:	781b      	ldrb	r3, [r3, #0]
   20800:	b90b      	cbnz	r3, 20806 <rpc_transport_ipc_tx_data_alloc+0xa>
   20802:	f7fd be35 	b.w	1e470 <nrf_shared_malloc>
   20806:	2000      	movs	r0, #0
   20808:	4770      	bx	lr
   2080a:	bf00      	nop
   2080c:	200314bb 	.word	0x200314bb

00020810 <ok_rsp_parser>:
   20810:	2000      	movs	r0, #0
   20812:	4770      	bx	lr

00020814 <pdn_state_get_parser>:
   20814:	2200      	movs	r2, #0
   20816:	b570      	push	{r4, r5, r6, lr}
   20818:	780b      	ldrb	r3, [r1, #0]
   2081a:	b084      	sub	sp, #16
   2081c:	460e      	mov	r6, r1
   2081e:	e9cd 2200 	strd	r2, r2, [sp]
   20822:	e9cd 2202 	strd	r2, r2, [sp, #8]
   20826:	b323      	cbz	r3, 20872 <pdn_state_get_parser+0x5e>
   20828:	460c      	mov	r4, r1
   2082a:	2b20      	cmp	r3, #32
   2082c:	460d      	mov	r5, r1
   2082e:	d01b      	beq.n	20868 <pdn_state_get_parser+0x54>
   20830:	700b      	strb	r3, [r1, #0]
   20832:	3201      	adds	r2, #1
   20834:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   20838:	18b1      	adds	r1, r6, r2
   2083a:	460d      	mov	r5, r1
   2083c:	2b00      	cmp	r3, #0
   2083e:	d1f4      	bne.n	2082a <pdn_state_get_parser+0x16>
   20840:	2200      	movs	r2, #0
   20842:	4b0d      	ldr	r3, [pc, #52]	; (20878 <pdn_state_get_parser+0x64>)
   20844:	702a      	strb	r2, [r5, #0]
   20846:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   2084a:	4a0c      	ldr	r2, [pc, #48]	; (2087c <pdn_state_get_parser+0x68>)
   2084c:	681b      	ldr	r3, [r3, #0]
   2084e:	2110      	movs	r1, #16
   20850:	4668      	mov	r0, sp
   20852:	f009 ff07 	bl	2a664 <sniprintf>
   20856:	4669      	mov	r1, sp
   20858:	4630      	mov	r0, r6
   2085a:	f00e ff49 	bl	2f6f0 <strstr>
   2085e:	3000      	adds	r0, #0
   20860:	bf18      	it	ne
   20862:	2001      	movne	r0, #1
   20864:	b004      	add	sp, #16
   20866:	bd70      	pop	{r4, r5, r6, pc}
   20868:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   2086c:	2b00      	cmp	r3, #0
   2086e:	d1dc      	bne.n	2082a <pdn_state_get_parser+0x16>
   20870:	e7e6      	b.n	20840 <pdn_state_get_parser+0x2c>
   20872:	460d      	mov	r5, r1
   20874:	e7e4      	b.n	20840 <pdn_state_get_parser+0x2c>
   20876:	bf00      	nop
   20878:	20028e70 	.word	0x20028e70
   2087c:	00030dd8 	.word	0x00030dd8

00020880 <pdn_id_get_parser>:
   20880:	b570      	push	{r4, r5, r6, lr}
   20882:	780b      	ldrb	r3, [r1, #0]
   20884:	4606      	mov	r6, r0
   20886:	b313      	cbz	r3, 208ce <pdn_id_get_parser+0x4e>
   20888:	4608      	mov	r0, r1
   2088a:	2400      	movs	r4, #0
   2088c:	460a      	mov	r2, r1
   2088e:	2b20      	cmp	r3, #32
   20890:	4615      	mov	r5, r2
   20892:	d017      	beq.n	208c4 <pdn_id_get_parser+0x44>
   20894:	7013      	strb	r3, [r2, #0]
   20896:	3401      	adds	r4, #1
   20898:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   2089c:	190a      	adds	r2, r1, r4
   2089e:	4615      	mov	r5, r2
   208a0:	2b00      	cmp	r3, #0
   208a2:	d1f4      	bne.n	2088e <pdn_id_get_parser+0xe>
   208a4:	2300      	movs	r3, #0
   208a6:	4608      	mov	r0, r1
   208a8:	702b      	strb	r3, [r5, #0]
   208aa:	213a      	movs	r1, #58	; 0x3a
   208ac:	f00e fee6 	bl	2f67c <strchr>
   208b0:	b130      	cbz	r0, 208c0 <pdn_id_get_parser+0x40>
   208b2:	3001      	adds	r0, #1
   208b4:	f00e fd2e 	bl	2f314 <atoi>
   208b8:	4b06      	ldr	r3, [pc, #24]	; (208d4 <pdn_id_get_parser+0x54>)
   208ba:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
   208be:	6058      	str	r0, [r3, #4]
   208c0:	2000      	movs	r0, #0
   208c2:	bd70      	pop	{r4, r5, r6, pc}
   208c4:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   208c8:	2b00      	cmp	r3, #0
   208ca:	d1e0      	bne.n	2088e <pdn_id_get_parser+0xe>
   208cc:	e7ea      	b.n	208a4 <pdn_id_get_parser+0x24>
   208ce:	460d      	mov	r5, r1
   208d0:	e7e8      	b.n	208a4 <pdn_id_get_parser+0x24>
   208d2:	bf00      	nop
   208d4:	20028e70 	.word	0x20028e70

000208d8 <context_create_parser>:
   208d8:	b570      	push	{r4, r5, r6, lr}
   208da:	780b      	ldrb	r3, [r1, #0]
   208dc:	4606      	mov	r6, r0
   208de:	b313      	cbz	r3, 20926 <context_create_parser+0x4e>
   208e0:	4608      	mov	r0, r1
   208e2:	2400      	movs	r4, #0
   208e4:	460a      	mov	r2, r1
   208e6:	2b20      	cmp	r3, #32
   208e8:	4615      	mov	r5, r2
   208ea:	d017      	beq.n	2091c <context_create_parser+0x44>
   208ec:	7013      	strb	r3, [r2, #0]
   208ee:	3401      	adds	r4, #1
   208f0:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   208f4:	190a      	adds	r2, r1, r4
   208f6:	4615      	mov	r5, r2
   208f8:	2b00      	cmp	r3, #0
   208fa:	d1f4      	bne.n	208e6 <context_create_parser+0xe>
   208fc:	2300      	movs	r3, #0
   208fe:	4608      	mov	r0, r1
   20900:	702b      	strb	r3, [r5, #0]
   20902:	213a      	movs	r1, #58	; 0x3a
   20904:	f00e feba 	bl	2f67c <strchr>
   20908:	b130      	cbz	r0, 20918 <context_create_parser+0x40>
   2090a:	4b08      	ldr	r3, [pc, #32]	; (2092c <context_create_parser+0x54>)
   2090c:	3001      	adds	r0, #1
   2090e:	f853 4026 	ldr.w	r4, [r3, r6, lsl #2]
   20912:	f00e fcff 	bl	2f314 <atoi>
   20916:	6020      	str	r0, [r4, #0]
   20918:	2000      	movs	r0, #0
   2091a:	bd70      	pop	{r4, r5, r6, pc}
   2091c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   20920:	2b00      	cmp	r3, #0
   20922:	d1e0      	bne.n	208e6 <context_create_parser+0xe>
   20924:	e7ea      	b.n	208fc <context_create_parser+0x24>
   20926:	460d      	mov	r5, r1
   20928:	e7e8      	b.n	208fc <context_create_parser+0x24>
   2092a:	bf00      	nop
   2092c:	20028e70 	.word	0x20028e70

00020930 <pdn_interface_init>:
   20930:	f04f 33ff 	mov.w	r3, #4294967295
   20934:	b510      	push	{r4, lr}
   20936:	4c09      	ldr	r4, [pc, #36]	; (2095c <pdn_interface_init+0x2c>)
   20938:	2228      	movs	r2, #40	; 0x28
   2093a:	2100      	movs	r1, #0
   2093c:	4808      	ldr	r0, [pc, #32]	; (20960 <pdn_interface_init+0x30>)
   2093e:	6023      	str	r3, [r4, #0]
   20940:	f00e fd28 	bl	2f394 <memset>
   20944:	f240 2201 	movw	r2, #513	; 0x201
   20948:	2102      	movs	r1, #2
   2094a:	2066      	movs	r0, #102	; 0x66
   2094c:	f7fd f838 	bl	1d9c0 <at_interface_open>
   20950:	2800      	cmp	r0, #0
   20952:	6020      	str	r0, [r4, #0]
   20954:	bfb4      	ite	lt
   20956:	2003      	movlt	r0, #3
   20958:	2000      	movge	r0, #0
   2095a:	bd10      	pop	{r4, pc}
   2095c:	20028d6c 	.word	0x20028d6c
   20960:	20028e70 	.word	0x20028e70

00020964 <pdn_interface_open>:
   20964:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   20968:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   2096c:	b083      	sub	sp, #12
   2096e:	f040 80ad 	bne.w	20acc <pdn_interface_open+0x168>
   20972:	4c5f      	ldr	r4, [pc, #380]	; (20af0 <pdn_interface_open+0x18c>)
   20974:	6825      	ldr	r5, [r4, #0]
   20976:	b34d      	cbz	r5, 209cc <pdn_interface_open+0x68>
   20978:	6863      	ldr	r3, [r4, #4]
   2097a:	2b00      	cmp	r3, #0
   2097c:	f000 8098 	beq.w	20ab0 <pdn_interface_open+0x14c>
   20980:	68a3      	ldr	r3, [r4, #8]
   20982:	2b00      	cmp	r3, #0
   20984:	f000 8096 	beq.w	20ab4 <pdn_interface_open+0x150>
   20988:	68e3      	ldr	r3, [r4, #12]
   2098a:	2b00      	cmp	r3, #0
   2098c:	f000 8094 	beq.w	20ab8 <pdn_interface_open+0x154>
   20990:	6923      	ldr	r3, [r4, #16]
   20992:	2b00      	cmp	r3, #0
   20994:	f000 8092 	beq.w	20abc <pdn_interface_open+0x158>
   20998:	6963      	ldr	r3, [r4, #20]
   2099a:	2b00      	cmp	r3, #0
   2099c:	f000 8090 	beq.w	20ac0 <pdn_interface_open+0x15c>
   209a0:	69a3      	ldr	r3, [r4, #24]
   209a2:	2b00      	cmp	r3, #0
   209a4:	f000 808e 	beq.w	20ac4 <pdn_interface_open+0x160>
   209a8:	69e3      	ldr	r3, [r4, #28]
   209aa:	2b00      	cmp	r3, #0
   209ac:	f000 808c 	beq.w	20ac8 <pdn_interface_open+0x164>
   209b0:	6a23      	ldr	r3, [r4, #32]
   209b2:	b153      	cbz	r3, 209ca <pdn_interface_open+0x66>
   209b4:	6a63      	ldr	r3, [r4, #36]	; 0x24
   209b6:	2509      	movs	r5, #9
   209b8:	b143      	cbz	r3, 209cc <pdn_interface_open+0x68>
   209ba:	200c      	movs	r0, #12
   209bc:	f7fa fed6 	bl	1b76c <bsd_os_errno_set>
   209c0:	f04f 30ff 	mov.w	r0, #4294967295
   209c4:	b003      	add	sp, #12
   209c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   209ca:	2508      	movs	r5, #8
   209cc:	2074      	movs	r0, #116	; 0x74
   209ce:	f7fd fd39 	bl	1e444 <nrf_malloc>
   209d2:	f844 0025 	str.w	r0, [r4, r5, lsl #2]
   209d6:	2800      	cmp	r0, #0
   209d8:	d0ef      	beq.n	209ba <pdn_interface_open+0x56>
   209da:	2274      	movs	r2, #116	; 0x74
   209dc:	2100      	movs	r1, #0
   209de:	f00e fcd9 	bl	2f394 <memset>
   209e2:	2101      	movs	r1, #1
   209e4:	2003      	movs	r0, #3
   209e6:	f04f 37ff 	mov.w	r7, #4294967295
   209ea:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   209ee:	4a41      	ldr	r2, [pc, #260]	; (20af4 <pdn_interface_open+0x190>)
   209f0:	6099      	str	r1, [r3, #8]
   209f2:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   209f6:	f44f 7180 	mov.w	r1, #256	; 0x100
   209fa:	6718      	str	r0, [r3, #112]	; 0x70
   209fc:	605f      	str	r7, [r3, #4]
   209fe:	483e      	ldr	r0, [pc, #248]	; (20af8 <pdn_interface_open+0x194>)
   20a00:	f8df 8100 	ldr.w	r8, [pc, #256]	; 20b04 <pdn_interface_open+0x1a0>
   20a04:	f009 fe2e 	bl	2a664 <sniprintf>
   20a08:	483b      	ldr	r0, [pc, #236]	; (20af8 <pdn_interface_open+0x194>)
   20a0a:	f8d8 9000 	ldr.w	r9, [r8]
   20a0e:	2600      	movs	r6, #0
   20a10:	f7ec faa2 	bl	cf58 <strlen>
   20a14:	4633      	mov	r3, r6
   20a16:	4602      	mov	r2, r0
   20a18:	4937      	ldr	r1, [pc, #220]	; (20af8 <pdn_interface_open+0x194>)
   20a1a:	4648      	mov	r0, r9
   20a1c:	9601      	str	r6, [sp, #4]
   20a1e:	9600      	str	r6, [sp, #0]
   20a20:	f7fc ff60 	bl	1d8e4 <at_interface_write>
   20a24:	4681      	mov	r9, r0
   20a26:	4834      	ldr	r0, [pc, #208]	; (20af8 <pdn_interface_open+0x194>)
   20a28:	f7ec fa96 	bl	cf58 <strlen>
   20a2c:	4548      	cmp	r0, r9
   20a2e:	d153      	bne.n	20ad8 <pdn_interface_open+0x174>
   20a30:	4633      	mov	r3, r6
   20a32:	e9cd 6600 	strd	r6, r6, [sp]
   20a36:	f44f 7280 	mov.w	r2, #256	; 0x100
   20a3a:	492f      	ldr	r1, [pc, #188]	; (20af8 <pdn_interface_open+0x194>)
   20a3c:	f8d8 0000 	ldr.w	r0, [r8]
   20a40:	f7fd f854 	bl	1daec <at_interface_read>
   20a44:	4606      	mov	r6, r0
   20a46:	482d      	ldr	r0, [pc, #180]	; (20afc <pdn_interface_open+0x198>)
   20a48:	f7ec fa86 	bl	cf58 <strlen>
   20a4c:	4286      	cmp	r6, r0
   20a4e:	db15      	blt.n	20a7c <pdn_interface_open+0x118>
   20a50:	4602      	mov	r2, r0
   20a52:	4929      	ldr	r1, [pc, #164]	; (20af8 <pdn_interface_open+0x194>)
   20a54:	4829      	ldr	r0, [pc, #164]	; (20afc <pdn_interface_open+0x198>)
   20a56:	f00e fe26 	bl	2f6a6 <strncmp>
   20a5a:	b978      	cbnz	r0, 20a7c <pdn_interface_open+0x118>
   20a5c:	4926      	ldr	r1, [pc, #152]	; (20af8 <pdn_interface_open+0x194>)
   20a5e:	4628      	mov	r0, r5
   20a60:	f7ff ff3a 	bl	208d8 <context_create_parser>
   20a64:	b9b0      	cbnz	r0, 20a94 <pdn_interface_open+0x130>
   20a66:	2202      	movs	r2, #2
   20a68:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   20a6c:	f045 40f1 	orr.w	r0, r5, #2021654528	; 0x78800000
   20a70:	f440 10d0 	orr.w	r0, r0, #1703936	; 0x1a0000
   20a74:	609a      	str	r2, [r3, #8]
   20a76:	b003      	add	sp, #12
   20a78:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   20a7c:	4820      	ldr	r0, [pc, #128]	; (20b00 <pdn_interface_open+0x19c>)
   20a7e:	f7ec fa6b 	bl	cf58 <strlen>
   20a82:	491d      	ldr	r1, [pc, #116]	; (20af8 <pdn_interface_open+0x194>)
   20a84:	4602      	mov	r2, r0
   20a86:	481e      	ldr	r0, [pc, #120]	; (20b00 <pdn_interface_open+0x19c>)
   20a88:	f00e fe0d 	bl	2f6a6 <strncmp>
   20a8c:	b960      	cbnz	r0, 20aa8 <pdn_interface_open+0x144>
   20a8e:	2008      	movs	r0, #8
   20a90:	f7fa fe6c 	bl	1b76c <bsd_os_errno_set>
   20a94:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
   20a98:	f7fd fcde 	bl	1e458 <nrf_free>
   20a9c:	2300      	movs	r3, #0
   20a9e:	f04f 30ff 	mov.w	r0, #4294967295
   20aa2:	f844 3025 	str.w	r3, [r4, r5, lsl #2]
   20aa6:	e78d      	b.n	209c4 <pdn_interface_open+0x60>
   20aa8:	2005      	movs	r0, #5
   20aaa:	f7fa fe5f 	bl	1b76c <bsd_os_errno_set>
   20aae:	e7f1      	b.n	20a94 <pdn_interface_open+0x130>
   20ab0:	2501      	movs	r5, #1
   20ab2:	e78b      	b.n	209cc <pdn_interface_open+0x68>
   20ab4:	2502      	movs	r5, #2
   20ab6:	e789      	b.n	209cc <pdn_interface_open+0x68>
   20ab8:	2503      	movs	r5, #3
   20aba:	e787      	b.n	209cc <pdn_interface_open+0x68>
   20abc:	2504      	movs	r5, #4
   20abe:	e785      	b.n	209cc <pdn_interface_open+0x68>
   20ac0:	2505      	movs	r5, #5
   20ac2:	e783      	b.n	209cc <pdn_interface_open+0x68>
   20ac4:	2506      	movs	r5, #6
   20ac6:	e781      	b.n	209cc <pdn_interface_open+0x68>
   20ac8:	2507      	movs	r5, #7
   20aca:	e77f      	b.n	209cc <pdn_interface_open+0x68>
   20acc:	2029      	movs	r0, #41	; 0x29
   20ace:	f7fa fe4d 	bl	1b76c <bsd_os_errno_set>
   20ad2:	f04f 30ff 	mov.w	r0, #4294967295
   20ad6:	e775      	b.n	209c4 <pdn_interface_open+0x60>
   20ad8:	2005      	movs	r0, #5
   20ada:	f7fa fe47 	bl	1b76c <bsd_os_errno_set>
   20ade:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
   20ae2:	f7fd fcb9 	bl	1e458 <nrf_free>
   20ae6:	f844 6025 	str.w	r6, [r4, r5, lsl #2]
   20aea:	4638      	mov	r0, r7
   20aec:	e76a      	b.n	209c4 <pdn_interface_open+0x60>
   20aee:	bf00      	nop
   20af0:	20028e70 	.word	0x20028e70
   20af4:	00030db4 	.word	0x00030db4
   20af8:	20028d70 	.word	0x20028d70
   20afc:	00030dc4 	.word	0x00030dc4
   20b00:	00030dd0 	.word	0x00030dd0
   20b04:	20028d6c 	.word	0x20028d6c

00020b08 <pdn_interface_connect>:
   20b08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20b0c:	b083      	sub	sp, #12
   20b0e:	2900      	cmp	r1, #0
   20b10:	f000 813d 	beq.w	20d8e <pdn_interface_connect+0x286>
   20b14:	2a64      	cmp	r2, #100	; 0x64
   20b16:	4691      	mov	r9, r2
   20b18:	f200 8139 	bhi.w	20d8e <pdn_interface_connect+0x286>
   20b1c:	4605      	mov	r5, r0
   20b1e:	4608      	mov	r0, r1
   20b20:	4688      	mov	r8, r1
   20b22:	f7ec fa19 	bl	cf58 <strlen>
   20b26:	2864      	cmp	r0, #100	; 0x64
   20b28:	f200 8131 	bhi.w	20d8e <pdn_interface_connect+0x286>
   20b2c:	0c2b      	lsrs	r3, r5, #16
   20b2e:	4aa5      	ldr	r2, [pc, #660]	; (20dc4 <pdn_interface_connect+0x2bc>)
   20b30:	041b      	lsls	r3, r3, #16
   20b32:	4293      	cmp	r3, r2
   20b34:	f040 8122 	bne.w	20d7c <pdn_interface_connect+0x274>
   20b38:	f025 45f1 	bic.w	r5, r5, #2021654528	; 0x78800000
   20b3c:	f425 15d0 	bic.w	r5, r5, #1703936	; 0x1a0000
   20b40:	2d09      	cmp	r5, #9
   20b42:	f300 811b 	bgt.w	20d7c <pdn_interface_connect+0x274>
   20b46:	4fa0      	ldr	r7, [pc, #640]	; (20dc8 <pdn_interface_connect+0x2c0>)
   20b48:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   20b4c:	2b00      	cmp	r3, #0
   20b4e:	f000 8115 	beq.w	20d7c <pdn_interface_connect+0x274>
   20b52:	689a      	ldr	r2, [r3, #8]
   20b54:	2a00      	cmp	r2, #0
   20b56:	f000 8111 	beq.w	20d7c <pdn_interface_connect+0x274>
   20b5a:	689b      	ldr	r3, [r3, #8]
   20b5c:	2b02      	cmp	r3, #2
   20b5e:	f040 810d 	bne.w	20d7c <pdn_interface_connect+0x274>
   20b62:	4e9a      	ldr	r6, [pc, #616]	; (20dcc <pdn_interface_connect+0x2c4>)
   20b64:	4a9a      	ldr	r2, [pc, #616]	; (20dd0 <pdn_interface_connect+0x2c8>)
   20b66:	f44f 7180 	mov.w	r1, #256	; 0x100
   20b6a:	4630      	mov	r0, r6
   20b6c:	f009 fd7a 	bl	2a664 <sniprintf>
   20b70:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   20b74:	4604      	mov	r4, r0
   20b76:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   20b7a:	681b      	ldr	r3, [r3, #0]
   20b7c:	4a95      	ldr	r2, [pc, #596]	; (20dd4 <pdn_interface_connect+0x2cc>)
   20b7e:	1830      	adds	r0, r6, r0
   20b80:	f009 fd70 	bl	2a664 <sniprintf>
   20b84:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   20b88:	4404      	add	r4, r0
   20b8a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   20b8c:	f003 0203 	and.w	r2, r3, #3
   20b90:	2a03      	cmp	r2, #3
   20b92:	f000 80ea 	beq.w	20d6a <pdn_interface_connect+0x262>
   20b96:	079b      	lsls	r3, r3, #30
   20b98:	eb06 0004 	add.w	r0, r6, r4
   20b9c:	f5c4 7180 	rsb	r1, r4, #256	; 0x100
   20ba0:	bf4c      	ite	mi
   20ba2:	4b8d      	ldrmi	r3, [pc, #564]	; (20dd8 <pdn_interface_connect+0x2d0>)
   20ba4:	4b8d      	ldrpl	r3, [pc, #564]	; (20ddc <pdn_interface_connect+0x2d4>)
   20ba6:	4a8e      	ldr	r2, [pc, #568]	; (20de0 <pdn_interface_connect+0x2d8>)
   20ba8:	f009 fd5c 	bl	2a664 <sniprintf>
   20bac:	4404      	add	r4, r0
   20bae:	4643      	mov	r3, r8
   20bb0:	4a8c      	ldr	r2, [pc, #560]	; (20de4 <pdn_interface_connect+0x2dc>)
   20bb2:	f5c4 7180 	rsb	r1, r4, #256	; 0x100
   20bb6:	1930      	adds	r0, r6, r4
   20bb8:	f009 fd54 	bl	2a664 <sniprintf>
   20bbc:	4420      	add	r0, r4
   20bbe:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
   20bc2:	f300 80f7 	bgt.w	20db4 <pdn_interface_connect+0x2ac>
   20bc6:	f8df a23c 	ldr.w	sl, [pc, #572]	; 20e04 <pdn_interface_connect+0x2fc>
   20bca:	4880      	ldr	r0, [pc, #512]	; (20dcc <pdn_interface_connect+0x2c4>)
   20bcc:	f8da b000 	ldr.w	fp, [sl]
   20bd0:	2400      	movs	r4, #0
   20bd2:	f7ec f9c1 	bl	cf58 <strlen>
   20bd6:	4623      	mov	r3, r4
   20bd8:	4602      	mov	r2, r0
   20bda:	497c      	ldr	r1, [pc, #496]	; (20dcc <pdn_interface_connect+0x2c4>)
   20bdc:	4658      	mov	r0, fp
   20bde:	9401      	str	r4, [sp, #4]
   20be0:	9400      	str	r4, [sp, #0]
   20be2:	f7fc fe7f 	bl	1d8e4 <at_interface_write>
   20be6:	4683      	mov	fp, r0
   20be8:	4878      	ldr	r0, [pc, #480]	; (20dcc <pdn_interface_connect+0x2c4>)
   20bea:	f7ec f9b5 	bl	cf58 <strlen>
   20bee:	4558      	cmp	r0, fp
   20bf0:	d008      	beq.n	20c04 <pdn_interface_connect+0xfc>
   20bf2:	2005      	movs	r0, #5
   20bf4:	f7fa fdba 	bl	1b76c <bsd_os_errno_set>
   20bf8:	f04f 34ff 	mov.w	r4, #4294967295
   20bfc:	4620      	mov	r0, r4
   20bfe:	b003      	add	sp, #12
   20c00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   20c04:	4623      	mov	r3, r4
   20c06:	e9cd 4400 	strd	r4, r4, [sp]
   20c0a:	f44f 7280 	mov.w	r2, #256	; 0x100
   20c0e:	496f      	ldr	r1, [pc, #444]	; (20dcc <pdn_interface_connect+0x2c4>)
   20c10:	f8da 0000 	ldr.w	r0, [sl]
   20c14:	f7fc ff6a 	bl	1daec <at_interface_read>
   20c18:	4604      	mov	r4, r0
   20c1a:	4873      	ldr	r0, [pc, #460]	; (20de8 <pdn_interface_connect+0x2e0>)
   20c1c:	f7ec f99c 	bl	cf58 <strlen>
   20c20:	4284      	cmp	r4, r0
   20c22:	f2c0 8091 	blt.w	20d48 <pdn_interface_connect+0x240>
   20c26:	4602      	mov	r2, r0
   20c28:	4968      	ldr	r1, [pc, #416]	; (20dcc <pdn_interface_connect+0x2c4>)
   20c2a:	486f      	ldr	r0, [pc, #444]	; (20de8 <pdn_interface_connect+0x2e0>)
   20c2c:	f00e fd3b 	bl	2f6a6 <strncmp>
   20c30:	2800      	cmp	r0, #0
   20c32:	f040 8089 	bne.w	20d48 <pdn_interface_connect+0x240>
   20c36:	4965      	ldr	r1, [pc, #404]	; (20dcc <pdn_interface_connect+0x2c4>)
   20c38:	4628      	mov	r0, r5
   20c3a:	f7ff fde9 	bl	20810 <ok_rsp_parser>
   20c3e:	4604      	mov	r4, r0
   20c40:	2800      	cmp	r0, #0
   20c42:	d1db      	bne.n	20bfc <pdn_interface_connect+0xf4>
   20c44:	4a69      	ldr	r2, [pc, #420]	; (20dec <pdn_interface_connect+0x2e4>)
   20c46:	f44f 7180 	mov.w	r1, #256	; 0x100
   20c4a:	4860      	ldr	r0, [pc, #384]	; (20dcc <pdn_interface_connect+0x2c4>)
   20c4c:	f009 fd0a 	bl	2a664 <sniprintf>
   20c50:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   20c54:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   20c58:	681b      	ldr	r3, [r3, #0]
   20c5a:	4a65      	ldr	r2, [pc, #404]	; (20df0 <pdn_interface_connect+0x2e8>)
   20c5c:	4430      	add	r0, r6
   20c5e:	f009 fd01 	bl	2a664 <sniprintf>
   20c62:	485a      	ldr	r0, [pc, #360]	; (20dcc <pdn_interface_connect+0x2c4>)
   20c64:	f8da b000 	ldr.w	fp, [sl]
   20c68:	f7ec f976 	bl	cf58 <strlen>
   20c6c:	4623      	mov	r3, r4
   20c6e:	4602      	mov	r2, r0
   20c70:	4956      	ldr	r1, [pc, #344]	; (20dcc <pdn_interface_connect+0x2c4>)
   20c72:	4658      	mov	r0, fp
   20c74:	9401      	str	r4, [sp, #4]
   20c76:	9400      	str	r4, [sp, #0]
   20c78:	f7fc fe34 	bl	1d8e4 <at_interface_write>
   20c7c:	4683      	mov	fp, r0
   20c7e:	4853      	ldr	r0, [pc, #332]	; (20dcc <pdn_interface_connect+0x2c4>)
   20c80:	f7ec f96a 	bl	cf58 <strlen>
   20c84:	4558      	cmp	r0, fp
   20c86:	d1b4      	bne.n	20bf2 <pdn_interface_connect+0xea>
   20c88:	4623      	mov	r3, r4
   20c8a:	f44f 7280 	mov.w	r2, #256	; 0x100
   20c8e:	494f      	ldr	r1, [pc, #316]	; (20dcc <pdn_interface_connect+0x2c4>)
   20c90:	f8da 0000 	ldr.w	r0, [sl]
   20c94:	e9cd 4400 	strd	r4, r4, [sp]
   20c98:	f7fc ff28 	bl	1daec <at_interface_read>
   20c9c:	4683      	mov	fp, r0
   20c9e:	4852      	ldr	r0, [pc, #328]	; (20de8 <pdn_interface_connect+0x2e0>)
   20ca0:	f7ec f95a 	bl	cf58 <strlen>
   20ca4:	4583      	cmp	fp, r0
   20ca6:	db4f      	blt.n	20d48 <pdn_interface_connect+0x240>
   20ca8:	4602      	mov	r2, r0
   20caa:	4948      	ldr	r1, [pc, #288]	; (20dcc <pdn_interface_connect+0x2c4>)
   20cac:	484e      	ldr	r0, [pc, #312]	; (20de8 <pdn_interface_connect+0x2e0>)
   20cae:	f00e fcfa 	bl	2f6a6 <strncmp>
   20cb2:	2800      	cmp	r0, #0
   20cb4:	d148      	bne.n	20d48 <pdn_interface_connect+0x240>
   20cb6:	2103      	movs	r1, #3
   20cb8:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   20cbc:	464a      	mov	r2, r9
   20cbe:	6099      	str	r1, [r3, #8]
   20cc0:	f857 0025 	ldr.w	r0, [r7, r5, lsl #2]
   20cc4:	4641      	mov	r1, r8
   20cc6:	300c      	adds	r0, #12
   20cc8:	f00e fb44 	bl	2f354 <memcpy>
   20ccc:	4a49      	ldr	r2, [pc, #292]	; (20df4 <pdn_interface_connect+0x2ec>)
   20cce:	f44f 7180 	mov.w	r1, #256	; 0x100
   20cd2:	483e      	ldr	r0, [pc, #248]	; (20dcc <pdn_interface_connect+0x2c4>)
   20cd4:	f009 fcc6 	bl	2a664 <sniprintf>
   20cd8:	4601      	mov	r1, r0
   20cda:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   20cde:	f5c1 7180 	rsb	r1, r1, #256	; 0x100
   20ce2:	681b      	ldr	r3, [r3, #0]
   20ce4:	4a42      	ldr	r2, [pc, #264]	; (20df0 <pdn_interface_connect+0x2e8>)
   20ce6:	1830      	adds	r0, r6, r0
   20ce8:	f009 fcbc 	bl	2a664 <sniprintf>
   20cec:	4837      	ldr	r0, [pc, #220]	; (20dcc <pdn_interface_connect+0x2c4>)
   20cee:	f8da 6000 	ldr.w	r6, [sl]
   20cf2:	f7ec f931 	bl	cf58 <strlen>
   20cf6:	4623      	mov	r3, r4
   20cf8:	4602      	mov	r2, r0
   20cfa:	4934      	ldr	r1, [pc, #208]	; (20dcc <pdn_interface_connect+0x2c4>)
   20cfc:	4630      	mov	r0, r6
   20cfe:	9401      	str	r4, [sp, #4]
   20d00:	9400      	str	r4, [sp, #0]
   20d02:	f7fc fdef 	bl	1d8e4 <at_interface_write>
   20d06:	4606      	mov	r6, r0
   20d08:	4830      	ldr	r0, [pc, #192]	; (20dcc <pdn_interface_connect+0x2c4>)
   20d0a:	f7ec f925 	bl	cf58 <strlen>
   20d0e:	42b0      	cmp	r0, r6
   20d10:	d153      	bne.n	20dba <pdn_interface_connect+0x2b2>
   20d12:	4623      	mov	r3, r4
   20d14:	f44f 7280 	mov.w	r2, #256	; 0x100
   20d18:	492c      	ldr	r1, [pc, #176]	; (20dcc <pdn_interface_connect+0x2c4>)
   20d1a:	f8da 0000 	ldr.w	r0, [sl]
   20d1e:	e9cd 4400 	strd	r4, r4, [sp]
   20d22:	f7fc fee3 	bl	1daec <at_interface_read>
   20d26:	4606      	mov	r6, r0
   20d28:	4833      	ldr	r0, [pc, #204]	; (20df8 <pdn_interface_connect+0x2f0>)
   20d2a:	f7ec f915 	bl	cf58 <strlen>
   20d2e:	4286      	cmp	r6, r0
   20d30:	db33      	blt.n	20d9a <pdn_interface_connect+0x292>
   20d32:	4602      	mov	r2, r0
   20d34:	4925      	ldr	r1, [pc, #148]	; (20dcc <pdn_interface_connect+0x2c4>)
   20d36:	4830      	ldr	r0, [pc, #192]	; (20df8 <pdn_interface_connect+0x2f0>)
   20d38:	f00e fcb5 	bl	2f6a6 <strncmp>
   20d3c:	bb68      	cbnz	r0, 20d9a <pdn_interface_connect+0x292>
   20d3e:	4628      	mov	r0, r5
   20d40:	4922      	ldr	r1, [pc, #136]	; (20dcc <pdn_interface_connect+0x2c4>)
   20d42:	f7ff fd9d 	bl	20880 <pdn_id_get_parser>
   20d46:	e759      	b.n	20bfc <pdn_interface_connect+0xf4>
   20d48:	482c      	ldr	r0, [pc, #176]	; (20dfc <pdn_interface_connect+0x2f4>)
   20d4a:	f7ec f905 	bl	cf58 <strlen>
   20d4e:	491f      	ldr	r1, [pc, #124]	; (20dcc <pdn_interface_connect+0x2c4>)
   20d50:	4602      	mov	r2, r0
   20d52:	482a      	ldr	r0, [pc, #168]	; (20dfc <pdn_interface_connect+0x2f4>)
   20d54:	f00e fca7 	bl	2f6a6 <strncmp>
   20d58:	2800      	cmp	r0, #0
   20d5a:	f47f af4a 	bne.w	20bf2 <pdn_interface_connect+0xea>
   20d5e:	2008      	movs	r0, #8
   20d60:	f7fa fd04 	bl	1b76c <bsd_os_errno_set>
   20d64:	f04f 34ff 	mov.w	r4, #4294967295
   20d68:	e748      	b.n	20bfc <pdn_interface_connect+0xf4>
   20d6a:	f5c4 7180 	rsb	r1, r4, #256	; 0x100
   20d6e:	1930      	adds	r0, r6, r4
   20d70:	4b23      	ldr	r3, [pc, #140]	; (20e00 <pdn_interface_connect+0x2f8>)
   20d72:	4a1b      	ldr	r2, [pc, #108]	; (20de0 <pdn_interface_connect+0x2d8>)
   20d74:	f009 fc76 	bl	2a664 <sniprintf>
   20d78:	4404      	add	r4, r0
   20d7a:	e718      	b.n	20bae <pdn_interface_connect+0xa6>
   20d7c:	f04f 34ff 	mov.w	r4, #4294967295
   20d80:	2009      	movs	r0, #9
   20d82:	f7fa fcf3 	bl	1b76c <bsd_os_errno_set>
   20d86:	4620      	mov	r0, r4
   20d88:	b003      	add	sp, #12
   20d8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   20d8e:	2016      	movs	r0, #22
   20d90:	f7fa fcec 	bl	1b76c <bsd_os_errno_set>
   20d94:	f04f 34ff 	mov.w	r4, #4294967295
   20d98:	e730      	b.n	20bfc <pdn_interface_connect+0xf4>
   20d9a:	4818      	ldr	r0, [pc, #96]	; (20dfc <pdn_interface_connect+0x2f4>)
   20d9c:	f7ec f8dc 	bl	cf58 <strlen>
   20da0:	490a      	ldr	r1, [pc, #40]	; (20dcc <pdn_interface_connect+0x2c4>)
   20da2:	4602      	mov	r2, r0
   20da4:	4815      	ldr	r0, [pc, #84]	; (20dfc <pdn_interface_connect+0x2f4>)
   20da6:	f00e fc7e 	bl	2f6a6 <strncmp>
   20daa:	b930      	cbnz	r0, 20dba <pdn_interface_connect+0x2b2>
   20dac:	2008      	movs	r0, #8
   20dae:	f7fa fcdd 	bl	1b76c <bsd_os_errno_set>
   20db2:	e723      	b.n	20bfc <pdn_interface_connect+0xf4>
   20db4:	f04f 34ff 	mov.w	r4, #4294967295
   20db8:	e720      	b.n	20bfc <pdn_interface_connect+0xf4>
   20dba:	2005      	movs	r0, #5
   20dbc:	f7fa fcd6 	bl	1b76c <bsd_os_errno_set>
   20dc0:	e71c      	b.n	20bfc <pdn_interface_connect+0xf4>
   20dc2:	bf00      	nop
   20dc4:	789a0000 	.word	0x789a0000
   20dc8:	20028e70 	.word	0x20028e70
   20dcc:	20028d70 	.word	0x20028d70
   20dd0:	00030d3c 	.word	0x00030d3c
   20dd4:	00030d48 	.word	0x00030d48
   20dd8:	00030d5c 	.word	0x00030d5c
   20ddc:	00030d64 	.word	0x00030d64
   20de0:	00030d54 	.word	0x00030d54
   20de4:	00030d98 	.word	0x00030d98
   20de8:	00030d68 	.word	0x00030d68
   20dec:	00030d6c 	.word	0x00030d6c
   20df0:	00030d78 	.word	0x00030d78
   20df4:	00030d7c 	.word	0x00030d7c
   20df8:	00030d8c 	.word	0x00030d8c
   20dfc:	00030dd0 	.word	0x00030dd0
   20e00:	00030d4c 	.word	0x00030d4c
   20e04:	20028d6c 	.word	0x20028d6c

00020e08 <pdn_interface_close>:
   20e08:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   20e0c:	4a64      	ldr	r2, [pc, #400]	; (20fa0 <pdn_interface_close+0x198>)
   20e0e:	0c03      	lsrs	r3, r0, #16
   20e10:	041b      	lsls	r3, r3, #16
   20e12:	4293      	cmp	r3, r2
   20e14:	b083      	sub	sp, #12
   20e16:	f040 809d 	bne.w	20f54 <pdn_interface_close+0x14c>
   20e1a:	f020 44f1 	bic.w	r4, r0, #2021654528	; 0x78800000
   20e1e:	f424 14d0 	bic.w	r4, r4, #1703936	; 0x1a0000
   20e22:	2c09      	cmp	r4, #9
   20e24:	f300 8096 	bgt.w	20f54 <pdn_interface_close+0x14c>
   20e28:	4d5e      	ldr	r5, [pc, #376]	; (20fa4 <pdn_interface_close+0x19c>)
   20e2a:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   20e2e:	2800      	cmp	r0, #0
   20e30:	f000 8090 	beq.w	20f54 <pdn_interface_close+0x14c>
   20e34:	6883      	ldr	r3, [r0, #8]
   20e36:	2b00      	cmp	r3, #0
   20e38:	f000 808c 	beq.w	20f54 <pdn_interface_close+0x14c>
   20e3c:	6883      	ldr	r3, [r0, #8]
   20e3e:	2b03      	cmp	r3, #3
   20e40:	d008      	beq.n	20e54 <pdn_interface_close+0x4c>
   20e42:	f7fd fb09 	bl	1e458 <nrf_free>
   20e46:	2300      	movs	r3, #0
   20e48:	4618      	mov	r0, r3
   20e4a:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
   20e4e:	b003      	add	sp, #12
   20e50:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   20e54:	4e54      	ldr	r6, [pc, #336]	; (20fa8 <pdn_interface_close+0x1a0>)
   20e56:	4a55      	ldr	r2, [pc, #340]	; (20fac <pdn_interface_close+0x1a4>)
   20e58:	f44f 7180 	mov.w	r1, #256	; 0x100
   20e5c:	4630      	mov	r0, r6
   20e5e:	f009 fc01 	bl	2a664 <sniprintf>
   20e62:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   20e66:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   20e6a:	681b      	ldr	r3, [r3, #0]
   20e6c:	4a50      	ldr	r2, [pc, #320]	; (20fb0 <pdn_interface_close+0x1a8>)
   20e6e:	4430      	add	r0, r6
   20e70:	f8df 814c 	ldr.w	r8, [pc, #332]	; 20fc0 <pdn_interface_close+0x1b8>
   20e74:	f009 fbf6 	bl	2a664 <sniprintf>
   20e78:	4630      	mov	r0, r6
   20e7a:	f8d8 9000 	ldr.w	r9, [r8]
   20e7e:	2700      	movs	r7, #0
   20e80:	f7ec f86a 	bl	cf58 <strlen>
   20e84:	4631      	mov	r1, r6
   20e86:	4602      	mov	r2, r0
   20e88:	463b      	mov	r3, r7
   20e8a:	4648      	mov	r0, r9
   20e8c:	9701      	str	r7, [sp, #4]
   20e8e:	9700      	str	r7, [sp, #0]
   20e90:	f7fc fd28 	bl	1d8e4 <at_interface_write>
   20e94:	4681      	mov	r9, r0
   20e96:	4630      	mov	r0, r6
   20e98:	f7ec f85e 	bl	cf58 <strlen>
   20e9c:	4548      	cmp	r0, r9
   20e9e:	d176      	bne.n	20f8e <pdn_interface_close+0x186>
   20ea0:	463b      	mov	r3, r7
   20ea2:	e9cd 7700 	strd	r7, r7, [sp]
   20ea6:	f44f 7280 	mov.w	r2, #256	; 0x100
   20eaa:	4631      	mov	r1, r6
   20eac:	f8d8 0000 	ldr.w	r0, [r8]
   20eb0:	f7fc fe1c 	bl	1daec <at_interface_read>
   20eb4:	4607      	mov	r7, r0
   20eb6:	483f      	ldr	r0, [pc, #252]	; (20fb4 <pdn_interface_close+0x1ac>)
   20eb8:	f7ec f84e 	bl	cf58 <strlen>
   20ebc:	4287      	cmp	r7, r0
   20ebe:	da4f      	bge.n	20f60 <pdn_interface_close+0x158>
   20ec0:	483d      	ldr	r0, [pc, #244]	; (20fb8 <pdn_interface_close+0x1b0>)
   20ec2:	f7ec f849 	bl	cf58 <strlen>
   20ec6:	4938      	ldr	r1, [pc, #224]	; (20fa8 <pdn_interface_close+0x1a0>)
   20ec8:	4602      	mov	r2, r0
   20eca:	483b      	ldr	r0, [pc, #236]	; (20fb8 <pdn_interface_close+0x1b0>)
   20ecc:	f00e fbeb 	bl	2f6a6 <strncmp>
   20ed0:	2800      	cmp	r0, #0
   20ed2:	d15c      	bne.n	20f8e <pdn_interface_close+0x186>
   20ed4:	2008      	movs	r0, #8
   20ed6:	f7fa fc49 	bl	1b76c <bsd_os_errno_set>
   20eda:	4a38      	ldr	r2, [pc, #224]	; (20fbc <pdn_interface_close+0x1b4>)
   20edc:	f44f 7180 	mov.w	r1, #256	; 0x100
   20ee0:	4831      	ldr	r0, [pc, #196]	; (20fa8 <pdn_interface_close+0x1a0>)
   20ee2:	f009 fbbf 	bl	2a664 <sniprintf>
   20ee6:	4601      	mov	r1, r0
   20ee8:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   20eec:	f5c1 7180 	rsb	r1, r1, #256	; 0x100
   20ef0:	681b      	ldr	r3, [r3, #0]
   20ef2:	4a2f      	ldr	r2, [pc, #188]	; (20fb0 <pdn_interface_close+0x1a8>)
   20ef4:	1830      	adds	r0, r6, r0
   20ef6:	f009 fbb5 	bl	2a664 <sniprintf>
   20efa:	482b      	ldr	r0, [pc, #172]	; (20fa8 <pdn_interface_close+0x1a0>)
   20efc:	f8d8 7000 	ldr.w	r7, [r8]
   20f00:	2600      	movs	r6, #0
   20f02:	f7ec f829 	bl	cf58 <strlen>
   20f06:	4633      	mov	r3, r6
   20f08:	4602      	mov	r2, r0
   20f0a:	4927      	ldr	r1, [pc, #156]	; (20fa8 <pdn_interface_close+0x1a0>)
   20f0c:	4638      	mov	r0, r7
   20f0e:	9601      	str	r6, [sp, #4]
   20f10:	9600      	str	r6, [sp, #0]
   20f12:	f7fc fce7 	bl	1d8e4 <at_interface_write>
   20f16:	4607      	mov	r7, r0
   20f18:	4823      	ldr	r0, [pc, #140]	; (20fa8 <pdn_interface_close+0x1a0>)
   20f1a:	f7ec f81d 	bl	cf58 <strlen>
   20f1e:	42b8      	cmp	r0, r7
   20f20:	d139      	bne.n	20f96 <pdn_interface_close+0x18e>
   20f22:	4633      	mov	r3, r6
   20f24:	e9cd 6600 	strd	r6, r6, [sp]
   20f28:	f44f 7280 	mov.w	r2, #256	; 0x100
   20f2c:	491e      	ldr	r1, [pc, #120]	; (20fa8 <pdn_interface_close+0x1a0>)
   20f2e:	f8d8 0000 	ldr.w	r0, [r8]
   20f32:	f7fc fddb 	bl	1daec <at_interface_read>
   20f36:	4606      	mov	r6, r0
   20f38:	481e      	ldr	r0, [pc, #120]	; (20fb4 <pdn_interface_close+0x1ac>)
   20f3a:	f7ec f80d 	bl	cf58 <strlen>
   20f3e:	4286      	cmp	r6, r0
   20f40:	db16      	blt.n	20f70 <pdn_interface_close+0x168>
   20f42:	4602      	mov	r2, r0
   20f44:	4918      	ldr	r1, [pc, #96]	; (20fa8 <pdn_interface_close+0x1a0>)
   20f46:	481b      	ldr	r0, [pc, #108]	; (20fb4 <pdn_interface_close+0x1ac>)
   20f48:	f00e fbad 	bl	2f6a6 <strncmp>
   20f4c:	b980      	cbnz	r0, 20f70 <pdn_interface_close+0x168>
   20f4e:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   20f52:	e776      	b.n	20e42 <pdn_interface_close+0x3a>
   20f54:	2009      	movs	r0, #9
   20f56:	f7fa fc09 	bl	1b76c <bsd_os_errno_set>
   20f5a:	f04f 30ff 	mov.w	r0, #4294967295
   20f5e:	e776      	b.n	20e4e <pdn_interface_close+0x46>
   20f60:	4602      	mov	r2, r0
   20f62:	4631      	mov	r1, r6
   20f64:	4813      	ldr	r0, [pc, #76]	; (20fb4 <pdn_interface_close+0x1ac>)
   20f66:	f00e fb9e 	bl	2f6a6 <strncmp>
   20f6a:	2800      	cmp	r0, #0
   20f6c:	d0b5      	beq.n	20eda <pdn_interface_close+0xd2>
   20f6e:	e7a7      	b.n	20ec0 <pdn_interface_close+0xb8>
   20f70:	4811      	ldr	r0, [pc, #68]	; (20fb8 <pdn_interface_close+0x1b0>)
   20f72:	f7eb fff1 	bl	cf58 <strlen>
   20f76:	490c      	ldr	r1, [pc, #48]	; (20fa8 <pdn_interface_close+0x1a0>)
   20f78:	4602      	mov	r2, r0
   20f7a:	480f      	ldr	r0, [pc, #60]	; (20fb8 <pdn_interface_close+0x1b0>)
   20f7c:	f00e fb93 	bl	2f6a6 <strncmp>
   20f80:	b948      	cbnz	r0, 20f96 <pdn_interface_close+0x18e>
   20f82:	2008      	movs	r0, #8
   20f84:	f7fa fbf2 	bl	1b76c <bsd_os_errno_set>
   20f88:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   20f8c:	e759      	b.n	20e42 <pdn_interface_close+0x3a>
   20f8e:	2005      	movs	r0, #5
   20f90:	f7fa fbec 	bl	1b76c <bsd_os_errno_set>
   20f94:	e7a1      	b.n	20eda <pdn_interface_close+0xd2>
   20f96:	2005      	movs	r0, #5
   20f98:	f7fa fbe8 	bl	1b76c <bsd_os_errno_set>
   20f9c:	e7d7      	b.n	20f4e <pdn_interface_close+0x146>
   20f9e:	bf00      	nop
   20fa0:	789a0000 	.word	0x789a0000
   20fa4:	20028e70 	.word	0x20028e70
   20fa8:	20028d70 	.word	0x20028d70
   20fac:	00030d30 	.word	0x00030d30
   20fb0:	00030d78 	.word	0x00030d78
   20fb4:	00030d68 	.word	0x00030d68
   20fb8:	00030dd0 	.word	0x00030dd0
   20fbc:	00030d3c 	.word	0x00030d3c
   20fc0:	20028d6c 	.word	0x20028d6c

00020fc4 <pdn_interface_setopt>:
   20fc4:	b510      	push	{r4, lr}
   20fc6:	f240 2402 	movw	r4, #514	; 0x202
   20fca:	42a1      	cmp	r1, r4
   20fcc:	d10d      	bne.n	20fea <pdn_interface_setopt+0x26>
   20fce:	b163      	cbz	r3, 20fea <pdn_interface_setopt+0x26>
   20fd0:	9902      	ldr	r1, [sp, #8]
   20fd2:	b151      	cbz	r1, 20fea <pdn_interface_setopt+0x26>
   20fd4:	0c01      	lsrs	r1, r0, #16
   20fd6:	4c25      	ldr	r4, [pc, #148]	; (2106c <pdn_interface_setopt+0xa8>)
   20fd8:	0409      	lsls	r1, r1, #16
   20fda:	42a1      	cmp	r1, r4
   20fdc:	d00b      	beq.n	20ff6 <pdn_interface_setopt+0x32>
   20fde:	2009      	movs	r0, #9
   20fe0:	f7fa fbc4 	bl	1b76c <bsd_os_errno_set>
   20fe4:	f04f 30ff 	mov.w	r0, #4294967295
   20fe8:	bd10      	pop	{r4, pc}
   20fea:	2016      	movs	r0, #22
   20fec:	f7fa fbbe 	bl	1b76c <bsd_os_errno_set>
   20ff0:	f04f 30ff 	mov.w	r0, #4294967295
   20ff4:	bd10      	pop	{r4, pc}
   20ff6:	f020 40f1 	bic.w	r0, r0, #2021654528	; 0x78800000
   20ffa:	f420 10d0 	bic.w	r0, r0, #1703936	; 0x1a0000
   20ffe:	2809      	cmp	r0, #9
   21000:	dced      	bgt.n	20fde <pdn_interface_setopt+0x1a>
   21002:	491b      	ldr	r1, [pc, #108]	; (21070 <pdn_interface_setopt+0xac>)
   21004:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
   21008:	2900      	cmp	r1, #0
   2100a:	d0e8      	beq.n	20fde <pdn_interface_setopt+0x1a>
   2100c:	6888      	ldr	r0, [r1, #8]
   2100e:	2800      	cmp	r0, #0
   21010:	d0e5      	beq.n	20fde <pdn_interface_setopt+0x1a>
   21012:	2a01      	cmp	r2, #1
   21014:	d001      	beq.n	2101a <pdn_interface_setopt+0x56>
   21016:	202d      	movs	r0, #45	; 0x2d
   21018:	e7e8      	b.n	20fec <pdn_interface_setopt+0x28>
   2101a:	688a      	ldr	r2, [r1, #8]
   2101c:	b1fa      	cbz	r2, 2105e <pdn_interface_setopt+0x9a>
   2101e:	688a      	ldr	r2, [r1, #8]
   21020:	2a03      	cmp	r2, #3
   21022:	d01c      	beq.n	2105e <pdn_interface_setopt+0x9a>
   21024:	688a      	ldr	r2, [r1, #8]
   21026:	2a04      	cmp	r2, #4
   21028:	d019      	beq.n	2105e <pdn_interface_setopt+0x9a>
   2102a:	9a02      	ldr	r2, [sp, #8]
   2102c:	0890      	lsrs	r0, r2, #2
   2102e:	1e42      	subs	r2, r0, #1
   21030:	2a01      	cmp	r2, #1
   21032:	d8da      	bhi.n	20fea <pdn_interface_setopt+0x26>
   21034:	9a02      	ldr	r2, [sp, #8]
   21036:	0792      	lsls	r2, r2, #30
   21038:	d1d7      	bne.n	20fea <pdn_interface_setopt+0x26>
   2103a:	681a      	ldr	r2, [r3, #0]
   2103c:	2a02      	cmp	r2, #2
   2103e:	d010      	beq.n	21062 <pdn_interface_setopt+0x9e>
   21040:	2a0a      	cmp	r2, #10
   21042:	d1d2      	bne.n	20fea <pdn_interface_setopt+0x26>
   21044:	2202      	movs	r2, #2
   21046:	2802      	cmp	r0, #2
   21048:	d106      	bne.n	21058 <pdn_interface_setopt+0x94>
   2104a:	685b      	ldr	r3, [r3, #4]
   2104c:	2b02      	cmp	r3, #2
   2104e:	d00a      	beq.n	21066 <pdn_interface_setopt+0xa2>
   21050:	2b0a      	cmp	r3, #10
   21052:	d1ca      	bne.n	20fea <pdn_interface_setopt+0x26>
   21054:	f042 0202 	orr.w	r2, r2, #2
   21058:	670a      	str	r2, [r1, #112]	; 0x70
   2105a:	2000      	movs	r0, #0
   2105c:	e7c6      	b.n	20fec <pdn_interface_setopt+0x28>
   2105e:	200e      	movs	r0, #14
   21060:	e7c4      	b.n	20fec <pdn_interface_setopt+0x28>
   21062:	2201      	movs	r2, #1
   21064:	e7ef      	b.n	21046 <pdn_interface_setopt+0x82>
   21066:	f042 0201 	orr.w	r2, r2, #1
   2106a:	e7f5      	b.n	21058 <pdn_interface_setopt+0x94>
   2106c:	789a0000 	.word	0x789a0000
   21070:	20028e70 	.word	0x20028e70

00021074 <pdn_interface_getopt>:
   21074:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   21078:	f240 2402 	movw	r4, #514	; 0x202
   2107c:	b083      	sub	sp, #12
   2107e:	42a1      	cmp	r1, r4
   21080:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   21082:	f040 80a9 	bne.w	211d8 <pdn_interface_getopt+0x164>
   21086:	461e      	mov	r6, r3
   21088:	2b00      	cmp	r3, #0
   2108a:	f000 80a5 	beq.w	211d8 <pdn_interface_getopt+0x164>
   2108e:	2d00      	cmp	r5, #0
   21090:	f000 80a2 	beq.w	211d8 <pdn_interface_getopt+0x164>
   21094:	0c03      	lsrs	r3, r0, #16
   21096:	4956      	ldr	r1, [pc, #344]	; (211f0 <pdn_interface_getopt+0x17c>)
   21098:	041b      	lsls	r3, r3, #16
   2109a:	428b      	cmp	r3, r1
   2109c:	f040 8082 	bne.w	211a4 <pdn_interface_getopt+0x130>
   210a0:	f020 44f1 	bic.w	r4, r0, #2021654528	; 0x78800000
   210a4:	f424 14d0 	bic.w	r4, r4, #1703936	; 0x1a0000
   210a8:	2c09      	cmp	r4, #9
   210aa:	dc7b      	bgt.n	211a4 <pdn_interface_getopt+0x130>
   210ac:	4b51      	ldr	r3, [pc, #324]	; (211f4 <pdn_interface_getopt+0x180>)
   210ae:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   210b2:	2b00      	cmp	r3, #0
   210b4:	d076      	beq.n	211a4 <pdn_interface_getopt+0x130>
   210b6:	6899      	ldr	r1, [r3, #8]
   210b8:	2900      	cmp	r1, #0
   210ba:	d073      	beq.n	211a4 <pdn_interface_getopt+0x130>
   210bc:	2a02      	cmp	r2, #2
   210be:	d00e      	beq.n	210de <pdn_interface_getopt+0x6a>
   210c0:	2a03      	cmp	r2, #3
   210c2:	d008      	beq.n	210d6 <pdn_interface_getopt+0x62>
   210c4:	2a01      	cmp	r2, #1
   210c6:	d015      	beq.n	210f4 <pdn_interface_getopt+0x80>
   210c8:	202d      	movs	r0, #45	; 0x2d
   210ca:	f7fa fb4f 	bl	1b76c <bsd_os_errno_set>
   210ce:	2000      	movs	r0, #0
   210d0:	b003      	add	sp, #12
   210d2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   210d6:	682b      	ldr	r3, [r5, #0]
   210d8:	bb23      	cbnz	r3, 21124 <pdn_interface_getopt+0xb0>
   210da:	2016      	movs	r0, #22
   210dc:	e7f5      	b.n	210ca <pdn_interface_getopt+0x56>
   210de:	682a      	ldr	r2, [r5, #0]
   210e0:	2a00      	cmp	r2, #0
   210e2:	d0fa      	beq.n	210da <pdn_interface_getopt+0x66>
   210e4:	2201      	movs	r2, #1
   210e6:	2000      	movs	r0, #0
   210e8:	681b      	ldr	r3, [r3, #0]
   210ea:	7033      	strb	r3, [r6, #0]
   210ec:	602a      	str	r2, [r5, #0]
   210ee:	b003      	add	sp, #12
   210f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   210f4:	689a      	ldr	r2, [r3, #8]
   210f6:	2a00      	cmp	r2, #0
   210f8:	d052      	beq.n	211a0 <pdn_interface_getopt+0x12c>
   210fa:	689a      	ldr	r2, [r3, #8]
   210fc:	2a04      	cmp	r2, #4
   210fe:	d04f      	beq.n	211a0 <pdn_interface_getopt+0x12c>
   21100:	682a      	ldr	r2, [r5, #0]
   21102:	2a07      	cmp	r2, #7
   21104:	d9e9      	bls.n	210da <pdn_interface_getopt+0x66>
   21106:	f012 0203 	ands.w	r2, r2, #3
   2110a:	d1e6      	bne.n	210da <pdn_interface_getopt+0x66>
   2110c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   2110e:	0799      	lsls	r1, r3, #30
   21110:	d45d      	bmi.n	211ce <pdn_interface_getopt+0x15a>
   21112:	2104      	movs	r1, #4
   21114:	07db      	lsls	r3, r3, #31
   21116:	d502      	bpl.n	2111e <pdn_interface_getopt+0xaa>
   21118:	2302      	movs	r3, #2
   2111a:	50b3      	str	r3, [r6, r2]
   2111c:	460a      	mov	r2, r1
   2111e:	602a      	str	r2, [r5, #0]
   21120:	2000      	movs	r0, #0
   21122:	e7d5      	b.n	210d0 <pdn_interface_getopt+0x5c>
   21124:	4a34      	ldr	r2, [pc, #208]	; (211f8 <pdn_interface_getopt+0x184>)
   21126:	f44f 7180 	mov.w	r1, #256	; 0x100
   2112a:	4834      	ldr	r0, [pc, #208]	; (211fc <pdn_interface_getopt+0x188>)
   2112c:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 21208 <pdn_interface_getopt+0x194>
   21130:	f009 fa98 	bl	2a664 <sniprintf>
   21134:	4831      	ldr	r0, [pc, #196]	; (211fc <pdn_interface_getopt+0x188>)
   21136:	f8d8 9000 	ldr.w	r9, [r8]
   2113a:	2700      	movs	r7, #0
   2113c:	f7eb ff0c 	bl	cf58 <strlen>
   21140:	463b      	mov	r3, r7
   21142:	4602      	mov	r2, r0
   21144:	492d      	ldr	r1, [pc, #180]	; (211fc <pdn_interface_getopt+0x188>)
   21146:	4648      	mov	r0, r9
   21148:	9701      	str	r7, [sp, #4]
   2114a:	9700      	str	r7, [sp, #0]
   2114c:	f7fc fbca 	bl	1d8e4 <at_interface_write>
   21150:	4681      	mov	r9, r0
   21152:	482a      	ldr	r0, [pc, #168]	; (211fc <pdn_interface_getopt+0x188>)
   21154:	f7eb ff00 	bl	cf58 <strlen>
   21158:	4548      	cmp	r0, r9
   2115a:	d143      	bne.n	211e4 <pdn_interface_getopt+0x170>
   2115c:	463b      	mov	r3, r7
   2115e:	e9cd 7700 	strd	r7, r7, [sp]
   21162:	f44f 7280 	mov.w	r2, #256	; 0x100
   21166:	4925      	ldr	r1, [pc, #148]	; (211fc <pdn_interface_getopt+0x188>)
   21168:	f8d8 0000 	ldr.w	r0, [r8]
   2116c:	f7fc fcbe 	bl	1daec <at_interface_read>
   21170:	4607      	mov	r7, r0
   21172:	4823      	ldr	r0, [pc, #140]	; (21200 <pdn_interface_getopt+0x18c>)
   21174:	f7eb fef0 	bl	cf58 <strlen>
   21178:	4287      	cmp	r7, r0
   2117a:	db19      	blt.n	211b0 <pdn_interface_getopt+0x13c>
   2117c:	4602      	mov	r2, r0
   2117e:	491f      	ldr	r1, [pc, #124]	; (211fc <pdn_interface_getopt+0x188>)
   21180:	481f      	ldr	r0, [pc, #124]	; (21200 <pdn_interface_getopt+0x18c>)
   21182:	f00e fa90 	bl	2f6a6 <strncmp>
   21186:	4607      	mov	r7, r0
   21188:	b990      	cbnz	r0, 211b0 <pdn_interface_getopt+0x13c>
   2118a:	4620      	mov	r0, r4
   2118c:	491b      	ldr	r1, [pc, #108]	; (211fc <pdn_interface_getopt+0x188>)
   2118e:	f7ff fb41 	bl	20814 <pdn_state_get_parser>
   21192:	2800      	cmp	r0, #0
   21194:	db99      	blt.n	210ca <pdn_interface_getopt+0x56>
   21196:	2301      	movs	r3, #1
   21198:	7030      	strb	r0, [r6, #0]
   2119a:	4638      	mov	r0, r7
   2119c:	602b      	str	r3, [r5, #0]
   2119e:	e797      	b.n	210d0 <pdn_interface_getopt+0x5c>
   211a0:	200e      	movs	r0, #14
   211a2:	e792      	b.n	210ca <pdn_interface_getopt+0x56>
   211a4:	2009      	movs	r0, #9
   211a6:	f7fa fae1 	bl	1b76c <bsd_os_errno_set>
   211aa:	f04f 30ff 	mov.w	r0, #4294967295
   211ae:	e78f      	b.n	210d0 <pdn_interface_getopt+0x5c>
   211b0:	4814      	ldr	r0, [pc, #80]	; (21204 <pdn_interface_getopt+0x190>)
   211b2:	f7eb fed1 	bl	cf58 <strlen>
   211b6:	4911      	ldr	r1, [pc, #68]	; (211fc <pdn_interface_getopt+0x188>)
   211b8:	4602      	mov	r2, r0
   211ba:	4812      	ldr	r0, [pc, #72]	; (21204 <pdn_interface_getopt+0x190>)
   211bc:	f00e fa73 	bl	2f6a6 <strncmp>
   211c0:	b980      	cbnz	r0, 211e4 <pdn_interface_getopt+0x170>
   211c2:	2008      	movs	r0, #8
   211c4:	f7fa fad2 	bl	1b76c <bsd_os_errno_set>
   211c8:	f04f 30ff 	mov.w	r0, #4294967295
   211cc:	e77d      	b.n	210ca <pdn_interface_getopt+0x56>
   211ce:	220a      	movs	r2, #10
   211d0:	2108      	movs	r1, #8
   211d2:	6032      	str	r2, [r6, #0]
   211d4:	2204      	movs	r2, #4
   211d6:	e79d      	b.n	21114 <pdn_interface_getopt+0xa0>
   211d8:	2016      	movs	r0, #22
   211da:	f7fa fac7 	bl	1b76c <bsd_os_errno_set>
   211de:	f04f 30ff 	mov.w	r0, #4294967295
   211e2:	e775      	b.n	210d0 <pdn_interface_getopt+0x5c>
   211e4:	2005      	movs	r0, #5
   211e6:	f7fa fac1 	bl	1b76c <bsd_os_errno_set>
   211ea:	f04f 30ff 	mov.w	r0, #4294967295
   211ee:	e76c      	b.n	210ca <pdn_interface_getopt+0x56>
   211f0:	789a0000 	.word	0x789a0000
   211f4:	20028e70 	.word	0x20028e70
   211f8:	00030da0 	.word	0x00030da0
   211fc:	20028d70 	.word	0x20028d70
   21200:	00030dac 	.word	0x00030dac
   21204:	00030dd0 	.word	0x00030dd0
   21208:	20028d6c 	.word	0x20028d6c

0002120c <pdn_interface_pdn_id_get>:
   2120c:	2900      	cmp	r1, #0
   2120e:	f000 83b9 	beq.w	21984 <pdn_interface_pdn_id_get+0x778>
   21212:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   21216:	4ca3      	ldr	r4, [pc, #652]	; (214a4 <pdn_interface_pdn_id_get+0x298>)
   21218:	2802      	cmp	r0, #2
   2121a:	b083      	sub	sp, #12
   2121c:	460d      	mov	r5, r1
   2121e:	6823      	ldr	r3, [r4, #0]
   21220:	f000 8094 	beq.w	2134c <pdn_interface_pdn_id_get+0x140>
   21224:	280a      	cmp	r0, #10
   21226:	d03f      	beq.n	212a8 <pdn_interface_pdn_id_get+0x9c>
   21228:	b11b      	cbz	r3, 21232 <pdn_interface_pdn_id_get+0x26>
   2122a:	689b      	ldr	r3, [r3, #8]
   2122c:	2b03      	cmp	r3, #3
   2122e:	f000 8127 	beq.w	21480 <pdn_interface_pdn_id_get+0x274>
   21232:	6863      	ldr	r3, [r4, #4]
   21234:	b11b      	cbz	r3, 2123e <pdn_interface_pdn_id_get+0x32>
   21236:	689b      	ldr	r3, [r3, #8]
   21238:	2b03      	cmp	r3, #3
   2123a:	f000 8110 	beq.w	2145e <pdn_interface_pdn_id_get+0x252>
   2123e:	68a3      	ldr	r3, [r4, #8]
   21240:	b11b      	cbz	r3, 2124a <pdn_interface_pdn_id_get+0x3e>
   21242:	689b      	ldr	r3, [r3, #8]
   21244:	2b03      	cmp	r3, #3
   21246:	f000 80f9 	beq.w	2143c <pdn_interface_pdn_id_get+0x230>
   2124a:	68e3      	ldr	r3, [r4, #12]
   2124c:	b11b      	cbz	r3, 21256 <pdn_interface_pdn_id_get+0x4a>
   2124e:	689b      	ldr	r3, [r3, #8]
   21250:	2b03      	cmp	r3, #3
   21252:	f000 80e2 	beq.w	2141a <pdn_interface_pdn_id_get+0x20e>
   21256:	6923      	ldr	r3, [r4, #16]
   21258:	b11b      	cbz	r3, 21262 <pdn_interface_pdn_id_get+0x56>
   2125a:	689b      	ldr	r3, [r3, #8]
   2125c:	2b03      	cmp	r3, #3
   2125e:	f000 8123 	beq.w	214a8 <pdn_interface_pdn_id_get+0x29c>
   21262:	6963      	ldr	r3, [r4, #20]
   21264:	b11b      	cbz	r3, 2126e <pdn_interface_pdn_id_get+0x62>
   21266:	689b      	ldr	r3, [r3, #8]
   21268:	2b03      	cmp	r3, #3
   2126a:	f000 8161 	beq.w	21530 <pdn_interface_pdn_id_get+0x324>
   2126e:	69a3      	ldr	r3, [r4, #24]
   21270:	b11b      	cbz	r3, 2127a <pdn_interface_pdn_id_get+0x6e>
   21272:	689b      	ldr	r3, [r3, #8]
   21274:	2b03      	cmp	r3, #3
   21276:	f000 814a 	beq.w	2150e <pdn_interface_pdn_id_get+0x302>
   2127a:	69e3      	ldr	r3, [r4, #28]
   2127c:	b11b      	cbz	r3, 21286 <pdn_interface_pdn_id_get+0x7a>
   2127e:	689b      	ldr	r3, [r3, #8]
   21280:	2b03      	cmp	r3, #3
   21282:	f000 8133 	beq.w	214ec <pdn_interface_pdn_id_get+0x2e0>
   21286:	6a23      	ldr	r3, [r4, #32]
   21288:	b11b      	cbz	r3, 21292 <pdn_interface_pdn_id_get+0x86>
   2128a:	689b      	ldr	r3, [r3, #8]
   2128c:	2b03      	cmp	r3, #3
   2128e:	f000 811c 	beq.w	214ca <pdn_interface_pdn_id_get+0x2be>
   21292:	6a63      	ldr	r3, [r4, #36]	; 0x24
   21294:	b11b      	cbz	r3, 2129e <pdn_interface_pdn_id_get+0x92>
   21296:	689b      	ldr	r3, [r3, #8]
   21298:	2b03      	cmp	r3, #3
   2129a:	f000 80ad 	beq.w	213f8 <pdn_interface_pdn_id_get+0x1ec>
   2129e:	f04f 30ff 	mov.w	r0, #4294967295
   212a2:	b003      	add	sp, #12
   212a4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   212a8:	b11b      	cbz	r3, 212b2 <pdn_interface_pdn_id_get+0xa6>
   212aa:	689b      	ldr	r3, [r3, #8]
   212ac:	2b03      	cmp	r3, #3
   212ae:	f000 8335 	beq.w	2191c <pdn_interface_pdn_id_get+0x710>
   212b2:	6863      	ldr	r3, [r4, #4]
   212b4:	b11b      	cbz	r3, 212be <pdn_interface_pdn_id_get+0xb2>
   212b6:	689b      	ldr	r3, [r3, #8]
   212b8:	2b03      	cmp	r3, #3
   212ba:	f000 82fd 	beq.w	218b8 <pdn_interface_pdn_id_get+0x6ac>
   212be:	68a3      	ldr	r3, [r4, #8]
   212c0:	b11b      	cbz	r3, 212ca <pdn_interface_pdn_id_get+0xbe>
   212c2:	689b      	ldr	r3, [r3, #8]
   212c4:	2b03      	cmp	r3, #3
   212c6:	f000 82d5 	beq.w	21874 <pdn_interface_pdn_id_get+0x668>
   212ca:	68e3      	ldr	r3, [r4, #12]
   212cc:	b11b      	cbz	r3, 212d6 <pdn_interface_pdn_id_get+0xca>
   212ce:	689e      	ldr	r6, [r3, #8]
   212d0:	2e03      	cmp	r6, #3
   212d2:	f000 81f0 	beq.w	216b6 <pdn_interface_pdn_id_get+0x4aa>
   212d6:	6923      	ldr	r3, [r4, #16]
   212d8:	b11b      	cbz	r3, 212e2 <pdn_interface_pdn_id_get+0xd6>
   212da:	689b      	ldr	r3, [r3, #8]
   212dc:	2b03      	cmp	r3, #3
   212de:	f000 8203 	beq.w	216e8 <pdn_interface_pdn_id_get+0x4dc>
   212e2:	6963      	ldr	r3, [r4, #20]
   212e4:	b11b      	cbz	r3, 212ee <pdn_interface_pdn_id_get+0xe2>
   212e6:	689b      	ldr	r3, [r3, #8]
   212e8:	2b03      	cmp	r3, #3
   212ea:	f000 8215 	beq.w	21718 <pdn_interface_pdn_id_get+0x50c>
   212ee:	69a3      	ldr	r3, [r4, #24]
   212f0:	b11b      	cbz	r3, 212fa <pdn_interface_pdn_id_get+0xee>
   212f2:	689b      	ldr	r3, [r3, #8]
   212f4:	2b03      	cmp	r3, #3
   212f6:	f000 8227 	beq.w	21748 <pdn_interface_pdn_id_get+0x53c>
   212fa:	69e3      	ldr	r3, [r4, #28]
   212fc:	b11b      	cbz	r3, 21306 <pdn_interface_pdn_id_get+0xfa>
   212fe:	689b      	ldr	r3, [r3, #8]
   21300:	2b03      	cmp	r3, #3
   21302:	f000 8239 	beq.w	21778 <pdn_interface_pdn_id_get+0x56c>
   21306:	6a23      	ldr	r3, [r4, #32]
   21308:	b11b      	cbz	r3, 21312 <pdn_interface_pdn_id_get+0x106>
   2130a:	689b      	ldr	r3, [r3, #8]
   2130c:	2b03      	cmp	r3, #3
   2130e:	f000 824d 	beq.w	217ac <pdn_interface_pdn_id_get+0x5a0>
   21312:	6a63      	ldr	r3, [r4, #36]	; 0x24
   21314:	2b00      	cmp	r3, #0
   21316:	d0c2      	beq.n	2129e <pdn_interface_pdn_id_get+0x92>
   21318:	689b      	ldr	r3, [r3, #8]
   2131a:	2b03      	cmp	r3, #3
   2131c:	d1bf      	bne.n	2129e <pdn_interface_pdn_id_get+0x92>
   2131e:	4628      	mov	r0, r5
   21320:	f7eb fe1a 	bl	cf58 <strlen>
   21324:	4606      	mov	r6, r0
   21326:	6a60      	ldr	r0, [r4, #36]	; 0x24
   21328:	300c      	adds	r0, #12
   2132a:	f7eb fe15 	bl	cf58 <strlen>
   2132e:	42b0      	cmp	r0, r6
   21330:	d1b5      	bne.n	2129e <pdn_interface_pdn_id_get+0x92>
   21332:	6a61      	ldr	r1, [r4, #36]	; 0x24
   21334:	4628      	mov	r0, r5
   21336:	310c      	adds	r1, #12
   21338:	f7eb fe04 	bl	cf44 <strcmp>
   2133c:	2800      	cmp	r0, #0
   2133e:	d1ae      	bne.n	2129e <pdn_interface_pdn_id_get+0x92>
   21340:	6a63      	ldr	r3, [r4, #36]	; 0x24
   21342:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   21344:	0792      	lsls	r2, r2, #30
   21346:	d5aa      	bpl.n	2129e <pdn_interface_pdn_id_get+0x92>
   21348:	2609      	movs	r6, #9
   2134a:	e11a      	b.n	21582 <pdn_interface_pdn_id_get+0x376>
   2134c:	b11b      	cbz	r3, 21356 <pdn_interface_pdn_id_get+0x14a>
   2134e:	689b      	ldr	r3, [r3, #8]
   21350:	2b03      	cmp	r3, #3
   21352:	f000 82fd 	beq.w	21950 <pdn_interface_pdn_id_get+0x744>
   21356:	6863      	ldr	r3, [r4, #4]
   21358:	b11b      	cbz	r3, 21362 <pdn_interface_pdn_id_get+0x156>
   2135a:	689b      	ldr	r3, [r3, #8]
   2135c:	2b03      	cmp	r3, #3
   2135e:	f000 82c5 	beq.w	218ec <pdn_interface_pdn_id_get+0x6e0>
   21362:	68a3      	ldr	r3, [r4, #8]
   21364:	b11b      	cbz	r3, 2136e <pdn_interface_pdn_id_get+0x162>
   21366:	689b      	ldr	r3, [r3, #8]
   21368:	2b03      	cmp	r3, #3
   2136a:	f000 8269 	beq.w	21840 <pdn_interface_pdn_id_get+0x634>
   2136e:	68e3      	ldr	r3, [r4, #12]
   21370:	b11b      	cbz	r3, 2137a <pdn_interface_pdn_id_get+0x16e>
   21372:	689e      	ldr	r6, [r3, #8]
   21374:	2e03      	cmp	r6, #3
   21376:	f000 80ec 	beq.w	21552 <pdn_interface_pdn_id_get+0x346>
   2137a:	6923      	ldr	r3, [r4, #16]
   2137c:	b11b      	cbz	r3, 21386 <pdn_interface_pdn_id_get+0x17a>
   2137e:	689b      	ldr	r3, [r3, #8]
   21380:	2b03      	cmp	r3, #3
   21382:	f000 814a 	beq.w	2161a <pdn_interface_pdn_id_get+0x40e>
   21386:	6963      	ldr	r3, [r4, #20]
   21388:	b11b      	cbz	r3, 21392 <pdn_interface_pdn_id_get+0x186>
   2138a:	689b      	ldr	r3, [r3, #8]
   2138c:	2b03      	cmp	r3, #3
   2138e:	f000 815e 	beq.w	2164e <pdn_interface_pdn_id_get+0x442>
   21392:	69a3      	ldr	r3, [r4, #24]
   21394:	b11b      	cbz	r3, 2139e <pdn_interface_pdn_id_get+0x192>
   21396:	689b      	ldr	r3, [r3, #8]
   21398:	2b03      	cmp	r3, #3
   2139a:	f000 8172 	beq.w	21682 <pdn_interface_pdn_id_get+0x476>
   2139e:	69e3      	ldr	r3, [r4, #28]
   213a0:	b11b      	cbz	r3, 213aa <pdn_interface_pdn_id_get+0x19e>
   213a2:	689b      	ldr	r3, [r3, #8]
   213a4:	2b03      	cmp	r3, #3
   213a6:	f000 821b 	beq.w	217e0 <pdn_interface_pdn_id_get+0x5d4>
   213aa:	6a23      	ldr	r3, [r4, #32]
   213ac:	b11b      	cbz	r3, 213b6 <pdn_interface_pdn_id_get+0x1aa>
   213ae:	689b      	ldr	r3, [r3, #8]
   213b0:	2b03      	cmp	r3, #3
   213b2:	f000 822d 	beq.w	21810 <pdn_interface_pdn_id_get+0x604>
   213b6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   213b8:	2b00      	cmp	r3, #0
   213ba:	f43f af70 	beq.w	2129e <pdn_interface_pdn_id_get+0x92>
   213be:	689b      	ldr	r3, [r3, #8]
   213c0:	2b03      	cmp	r3, #3
   213c2:	f47f af6c 	bne.w	2129e <pdn_interface_pdn_id_get+0x92>
   213c6:	4628      	mov	r0, r5
   213c8:	f7eb fdc6 	bl	cf58 <strlen>
   213cc:	4606      	mov	r6, r0
   213ce:	6a60      	ldr	r0, [r4, #36]	; 0x24
   213d0:	300c      	adds	r0, #12
   213d2:	f7eb fdc1 	bl	cf58 <strlen>
   213d6:	4286      	cmp	r6, r0
   213d8:	f47f af61 	bne.w	2129e <pdn_interface_pdn_id_get+0x92>
   213dc:	6a61      	ldr	r1, [r4, #36]	; 0x24
   213de:	4628      	mov	r0, r5
   213e0:	310c      	adds	r1, #12
   213e2:	f7eb fdaf 	bl	cf44 <strcmp>
   213e6:	2800      	cmp	r0, #0
   213e8:	f47f af59 	bne.w	2129e <pdn_interface_pdn_id_get+0x92>
   213ec:	6a63      	ldr	r3, [r4, #36]	; 0x24
   213ee:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   213f0:	07d2      	lsls	r2, r2, #31
   213f2:	f57f af54 	bpl.w	2129e <pdn_interface_pdn_id_get+0x92>
   213f6:	e7a7      	b.n	21348 <pdn_interface_pdn_id_get+0x13c>
   213f8:	4628      	mov	r0, r5
   213fa:	f7eb fdad 	bl	cf58 <strlen>
   213fe:	4606      	mov	r6, r0
   21400:	6a60      	ldr	r0, [r4, #36]	; 0x24
   21402:	300c      	adds	r0, #12
   21404:	f7eb fda8 	bl	cf58 <strlen>
   21408:	42b0      	cmp	r0, r6
   2140a:	f47f af48 	bne.w	2129e <pdn_interface_pdn_id_get+0x92>
   2140e:	6a61      	ldr	r1, [r4, #36]	; 0x24
   21410:	4628      	mov	r0, r5
   21412:	310c      	adds	r1, #12
   21414:	f7eb fd96 	bl	cf44 <strcmp>
   21418:	e741      	b.n	2129e <pdn_interface_pdn_id_get+0x92>
   2141a:	4628      	mov	r0, r5
   2141c:	f7eb fd9c 	bl	cf58 <strlen>
   21420:	4606      	mov	r6, r0
   21422:	68e0      	ldr	r0, [r4, #12]
   21424:	300c      	adds	r0, #12
   21426:	f7eb fd97 	bl	cf58 <strlen>
   2142a:	4286      	cmp	r6, r0
   2142c:	f47f af13 	bne.w	21256 <pdn_interface_pdn_id_get+0x4a>
   21430:	68e1      	ldr	r1, [r4, #12]
   21432:	4628      	mov	r0, r5
   21434:	310c      	adds	r1, #12
   21436:	f7eb fd85 	bl	cf44 <strcmp>
   2143a:	e70c      	b.n	21256 <pdn_interface_pdn_id_get+0x4a>
   2143c:	4628      	mov	r0, r5
   2143e:	f7eb fd8b 	bl	cf58 <strlen>
   21442:	4606      	mov	r6, r0
   21444:	68a0      	ldr	r0, [r4, #8]
   21446:	300c      	adds	r0, #12
   21448:	f7eb fd86 	bl	cf58 <strlen>
   2144c:	4286      	cmp	r6, r0
   2144e:	f47f aefc 	bne.w	2124a <pdn_interface_pdn_id_get+0x3e>
   21452:	68a1      	ldr	r1, [r4, #8]
   21454:	4628      	mov	r0, r5
   21456:	310c      	adds	r1, #12
   21458:	f7eb fd74 	bl	cf44 <strcmp>
   2145c:	e6f5      	b.n	2124a <pdn_interface_pdn_id_get+0x3e>
   2145e:	4628      	mov	r0, r5
   21460:	f7eb fd7a 	bl	cf58 <strlen>
   21464:	4606      	mov	r6, r0
   21466:	6860      	ldr	r0, [r4, #4]
   21468:	300c      	adds	r0, #12
   2146a:	f7eb fd75 	bl	cf58 <strlen>
   2146e:	4286      	cmp	r6, r0
   21470:	f47f aee5 	bne.w	2123e <pdn_interface_pdn_id_get+0x32>
   21474:	6861      	ldr	r1, [r4, #4]
   21476:	4628      	mov	r0, r5
   21478:	310c      	adds	r1, #12
   2147a:	f7eb fd63 	bl	cf44 <strcmp>
   2147e:	e6de      	b.n	2123e <pdn_interface_pdn_id_get+0x32>
   21480:	4608      	mov	r0, r1
   21482:	f7eb fd69 	bl	cf58 <strlen>
   21486:	4606      	mov	r6, r0
   21488:	6820      	ldr	r0, [r4, #0]
   2148a:	300c      	adds	r0, #12
   2148c:	f7eb fd64 	bl	cf58 <strlen>
   21490:	4286      	cmp	r6, r0
   21492:	f47f aece 	bne.w	21232 <pdn_interface_pdn_id_get+0x26>
   21496:	6821      	ldr	r1, [r4, #0]
   21498:	4628      	mov	r0, r5
   2149a:	310c      	adds	r1, #12
   2149c:	f7eb fd52 	bl	cf44 <strcmp>
   214a0:	e6c7      	b.n	21232 <pdn_interface_pdn_id_get+0x26>
   214a2:	bf00      	nop
   214a4:	20028e70 	.word	0x20028e70
   214a8:	4628      	mov	r0, r5
   214aa:	f7eb fd55 	bl	cf58 <strlen>
   214ae:	4606      	mov	r6, r0
   214b0:	6920      	ldr	r0, [r4, #16]
   214b2:	300c      	adds	r0, #12
   214b4:	f7eb fd50 	bl	cf58 <strlen>
   214b8:	4286      	cmp	r6, r0
   214ba:	f47f aed2 	bne.w	21262 <pdn_interface_pdn_id_get+0x56>
   214be:	6921      	ldr	r1, [r4, #16]
   214c0:	4628      	mov	r0, r5
   214c2:	310c      	adds	r1, #12
   214c4:	f7eb fd3e 	bl	cf44 <strcmp>
   214c8:	e6cb      	b.n	21262 <pdn_interface_pdn_id_get+0x56>
   214ca:	4628      	mov	r0, r5
   214cc:	f7eb fd44 	bl	cf58 <strlen>
   214d0:	4606      	mov	r6, r0
   214d2:	6a20      	ldr	r0, [r4, #32]
   214d4:	300c      	adds	r0, #12
   214d6:	f7eb fd3f 	bl	cf58 <strlen>
   214da:	4286      	cmp	r6, r0
   214dc:	f47f aed9 	bne.w	21292 <pdn_interface_pdn_id_get+0x86>
   214e0:	6a21      	ldr	r1, [r4, #32]
   214e2:	4628      	mov	r0, r5
   214e4:	310c      	adds	r1, #12
   214e6:	f7eb fd2d 	bl	cf44 <strcmp>
   214ea:	e6d2      	b.n	21292 <pdn_interface_pdn_id_get+0x86>
   214ec:	4628      	mov	r0, r5
   214ee:	f7eb fd33 	bl	cf58 <strlen>
   214f2:	4606      	mov	r6, r0
   214f4:	69e0      	ldr	r0, [r4, #28]
   214f6:	300c      	adds	r0, #12
   214f8:	f7eb fd2e 	bl	cf58 <strlen>
   214fc:	4286      	cmp	r6, r0
   214fe:	f47f aec2 	bne.w	21286 <pdn_interface_pdn_id_get+0x7a>
   21502:	69e1      	ldr	r1, [r4, #28]
   21504:	4628      	mov	r0, r5
   21506:	310c      	adds	r1, #12
   21508:	f7eb fd1c 	bl	cf44 <strcmp>
   2150c:	e6bb      	b.n	21286 <pdn_interface_pdn_id_get+0x7a>
   2150e:	4628      	mov	r0, r5
   21510:	f7eb fd22 	bl	cf58 <strlen>
   21514:	4606      	mov	r6, r0
   21516:	69a0      	ldr	r0, [r4, #24]
   21518:	300c      	adds	r0, #12
   2151a:	f7eb fd1d 	bl	cf58 <strlen>
   2151e:	4286      	cmp	r6, r0
   21520:	f47f aeab 	bne.w	2127a <pdn_interface_pdn_id_get+0x6e>
   21524:	69a1      	ldr	r1, [r4, #24]
   21526:	4628      	mov	r0, r5
   21528:	310c      	adds	r1, #12
   2152a:	f7eb fd0b 	bl	cf44 <strcmp>
   2152e:	e6a4      	b.n	2127a <pdn_interface_pdn_id_get+0x6e>
   21530:	4628      	mov	r0, r5
   21532:	f7eb fd11 	bl	cf58 <strlen>
   21536:	4606      	mov	r6, r0
   21538:	6960      	ldr	r0, [r4, #20]
   2153a:	300c      	adds	r0, #12
   2153c:	f7eb fd0c 	bl	cf58 <strlen>
   21540:	4286      	cmp	r6, r0
   21542:	f47f ae94 	bne.w	2126e <pdn_interface_pdn_id_get+0x62>
   21546:	6961      	ldr	r1, [r4, #20]
   21548:	4628      	mov	r0, r5
   2154a:	310c      	adds	r1, #12
   2154c:	f7eb fcfa 	bl	cf44 <strcmp>
   21550:	e68d      	b.n	2126e <pdn_interface_pdn_id_get+0x62>
   21552:	4628      	mov	r0, r5
   21554:	f7eb fd00 	bl	cf58 <strlen>
   21558:	4607      	mov	r7, r0
   2155a:	68e0      	ldr	r0, [r4, #12]
   2155c:	300c      	adds	r0, #12
   2155e:	f7eb fcfb 	bl	cf58 <strlen>
   21562:	4287      	cmp	r7, r0
   21564:	f47f af09 	bne.w	2137a <pdn_interface_pdn_id_get+0x16e>
   21568:	68e1      	ldr	r1, [r4, #12]
   2156a:	4628      	mov	r0, r5
   2156c:	310c      	adds	r1, #12
   2156e:	f7eb fce9 	bl	cf44 <strcmp>
   21572:	2800      	cmp	r0, #0
   21574:	f47f af01 	bne.w	2137a <pdn_interface_pdn_id_get+0x16e>
   21578:	68e3      	ldr	r3, [r4, #12]
   2157a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2157c:	07d1      	lsls	r1, r2, #31
   2157e:	f57f aefc 	bpl.w	2137a <pdn_interface_pdn_id_get+0x16e>
   21582:	6858      	ldr	r0, [r3, #4]
   21584:	1c43      	adds	r3, r0, #1
   21586:	f47f ae8c 	bne.w	212a2 <pdn_interface_pdn_id_get+0x96>
   2158a:	4dc6      	ldr	r5, [pc, #792]	; (218a4 <pdn_interface_pdn_id_get+0x698>)
   2158c:	4ac6      	ldr	r2, [pc, #792]	; (218a8 <pdn_interface_pdn_id_get+0x69c>)
   2158e:	f44f 7180 	mov.w	r1, #256	; 0x100
   21592:	4628      	mov	r0, r5
   21594:	f009 f866 	bl	2a664 <sniprintf>
   21598:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   2159c:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   215a0:	681b      	ldr	r3, [r3, #0]
   215a2:	4ac2      	ldr	r2, [pc, #776]	; (218ac <pdn_interface_pdn_id_get+0x6a0>)
   215a4:	4428      	add	r0, r5
   215a6:	f8df 830c 	ldr.w	r8, [pc, #780]	; 218b4 <pdn_interface_pdn_id_get+0x6a8>
   215aa:	f009 f85b 	bl	2a664 <sniprintf>
   215ae:	4628      	mov	r0, r5
   215b0:	f8d8 9000 	ldr.w	r9, [r8]
   215b4:	2700      	movs	r7, #0
   215b6:	f7eb fccf 	bl	cf58 <strlen>
   215ba:	4629      	mov	r1, r5
   215bc:	4602      	mov	r2, r0
   215be:	463b      	mov	r3, r7
   215c0:	4648      	mov	r0, r9
   215c2:	9701      	str	r7, [sp, #4]
   215c4:	9700      	str	r7, [sp, #0]
   215c6:	f7fc f98d 	bl	1d8e4 <at_interface_write>
   215ca:	4681      	mov	r9, r0
   215cc:	4628      	mov	r0, r5
   215ce:	f7eb fcc3 	bl	cf58 <strlen>
   215d2:	4548      	cmp	r0, r9
   215d4:	f040 81e9 	bne.w	219aa <pdn_interface_pdn_id_get+0x79e>
   215d8:	463b      	mov	r3, r7
   215da:	f44f 7280 	mov.w	r2, #256	; 0x100
   215de:	e9cd 7700 	strd	r7, r7, [sp]
   215e2:	4629      	mov	r1, r5
   215e4:	f8d8 0000 	ldr.w	r0, [r8]
   215e8:	f7fc fa80 	bl	1daec <at_interface_read>
   215ec:	4607      	mov	r7, r0
   215ee:	48b0      	ldr	r0, [pc, #704]	; (218b0 <pdn_interface_pdn_id_get+0x6a4>)
   215f0:	f7eb fcb2 	bl	cf58 <strlen>
   215f4:	4287      	cmp	r7, r0
   215f6:	4602      	mov	r2, r0
   215f8:	f2c0 81c7 	blt.w	2198a <pdn_interface_pdn_id_get+0x77e>
   215fc:	4629      	mov	r1, r5
   215fe:	48ac      	ldr	r0, [pc, #688]	; (218b0 <pdn_interface_pdn_id_get+0x6a4>)
   21600:	f00e f851 	bl	2f6a6 <strncmp>
   21604:	2800      	cmp	r0, #0
   21606:	f040 81c0 	bne.w	2198a <pdn_interface_pdn_id_get+0x77e>
   2160a:	4629      	mov	r1, r5
   2160c:	4630      	mov	r0, r6
   2160e:	f7ff f937 	bl	20880 <pdn_id_get_parser>
   21612:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   21616:	6858      	ldr	r0, [r3, #4]
   21618:	e643      	b.n	212a2 <pdn_interface_pdn_id_get+0x96>
   2161a:	4628      	mov	r0, r5
   2161c:	f7eb fc9c 	bl	cf58 <strlen>
   21620:	4606      	mov	r6, r0
   21622:	6920      	ldr	r0, [r4, #16]
   21624:	300c      	adds	r0, #12
   21626:	f7eb fc97 	bl	cf58 <strlen>
   2162a:	4286      	cmp	r6, r0
   2162c:	f47f aeab 	bne.w	21386 <pdn_interface_pdn_id_get+0x17a>
   21630:	6921      	ldr	r1, [r4, #16]
   21632:	4628      	mov	r0, r5
   21634:	310c      	adds	r1, #12
   21636:	f7eb fc85 	bl	cf44 <strcmp>
   2163a:	2800      	cmp	r0, #0
   2163c:	f47f aea3 	bne.w	21386 <pdn_interface_pdn_id_get+0x17a>
   21640:	6923      	ldr	r3, [r4, #16]
   21642:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   21644:	07d2      	lsls	r2, r2, #31
   21646:	f57f ae9e 	bpl.w	21386 <pdn_interface_pdn_id_get+0x17a>
   2164a:	2604      	movs	r6, #4
   2164c:	e799      	b.n	21582 <pdn_interface_pdn_id_get+0x376>
   2164e:	4628      	mov	r0, r5
   21650:	f7eb fc82 	bl	cf58 <strlen>
   21654:	4606      	mov	r6, r0
   21656:	6960      	ldr	r0, [r4, #20]
   21658:	300c      	adds	r0, #12
   2165a:	f7eb fc7d 	bl	cf58 <strlen>
   2165e:	4286      	cmp	r6, r0
   21660:	f47f ae97 	bne.w	21392 <pdn_interface_pdn_id_get+0x186>
   21664:	6961      	ldr	r1, [r4, #20]
   21666:	4628      	mov	r0, r5
   21668:	310c      	adds	r1, #12
   2166a:	f7eb fc6b 	bl	cf44 <strcmp>
   2166e:	2800      	cmp	r0, #0
   21670:	f47f ae8f 	bne.w	21392 <pdn_interface_pdn_id_get+0x186>
   21674:	6963      	ldr	r3, [r4, #20]
   21676:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   21678:	07d7      	lsls	r7, r2, #31
   2167a:	f57f ae8a 	bpl.w	21392 <pdn_interface_pdn_id_get+0x186>
   2167e:	2605      	movs	r6, #5
   21680:	e77f      	b.n	21582 <pdn_interface_pdn_id_get+0x376>
   21682:	4628      	mov	r0, r5
   21684:	f7eb fc68 	bl	cf58 <strlen>
   21688:	4606      	mov	r6, r0
   2168a:	69a0      	ldr	r0, [r4, #24]
   2168c:	300c      	adds	r0, #12
   2168e:	f7eb fc63 	bl	cf58 <strlen>
   21692:	4286      	cmp	r6, r0
   21694:	f47f ae83 	bne.w	2139e <pdn_interface_pdn_id_get+0x192>
   21698:	69a1      	ldr	r1, [r4, #24]
   2169a:	4628      	mov	r0, r5
   2169c:	310c      	adds	r1, #12
   2169e:	f7eb fc51 	bl	cf44 <strcmp>
   216a2:	2800      	cmp	r0, #0
   216a4:	f47f ae7b 	bne.w	2139e <pdn_interface_pdn_id_get+0x192>
   216a8:	69a3      	ldr	r3, [r4, #24]
   216aa:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   216ac:	07d6      	lsls	r6, r2, #31
   216ae:	f57f ae76 	bpl.w	2139e <pdn_interface_pdn_id_get+0x192>
   216b2:	2606      	movs	r6, #6
   216b4:	e765      	b.n	21582 <pdn_interface_pdn_id_get+0x376>
   216b6:	4628      	mov	r0, r5
   216b8:	f7eb fc4e 	bl	cf58 <strlen>
   216bc:	4607      	mov	r7, r0
   216be:	68e0      	ldr	r0, [r4, #12]
   216c0:	300c      	adds	r0, #12
   216c2:	f7eb fc49 	bl	cf58 <strlen>
   216c6:	4287      	cmp	r7, r0
   216c8:	f47f ae05 	bne.w	212d6 <pdn_interface_pdn_id_get+0xca>
   216cc:	68e1      	ldr	r1, [r4, #12]
   216ce:	4628      	mov	r0, r5
   216d0:	310c      	adds	r1, #12
   216d2:	f7eb fc37 	bl	cf44 <strcmp>
   216d6:	2800      	cmp	r0, #0
   216d8:	f47f adfd 	bne.w	212d6 <pdn_interface_pdn_id_get+0xca>
   216dc:	68e3      	ldr	r3, [r4, #12]
   216de:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   216e0:	0791      	lsls	r1, r2, #30
   216e2:	f53f af4e 	bmi.w	21582 <pdn_interface_pdn_id_get+0x376>
   216e6:	e5f6      	b.n	212d6 <pdn_interface_pdn_id_get+0xca>
   216e8:	4628      	mov	r0, r5
   216ea:	f7eb fc35 	bl	cf58 <strlen>
   216ee:	4606      	mov	r6, r0
   216f0:	6920      	ldr	r0, [r4, #16]
   216f2:	300c      	adds	r0, #12
   216f4:	f7eb fc30 	bl	cf58 <strlen>
   216f8:	4286      	cmp	r6, r0
   216fa:	f47f adf2 	bne.w	212e2 <pdn_interface_pdn_id_get+0xd6>
   216fe:	6921      	ldr	r1, [r4, #16]
   21700:	4628      	mov	r0, r5
   21702:	310c      	adds	r1, #12
   21704:	f7eb fc1e 	bl	cf44 <strcmp>
   21708:	2800      	cmp	r0, #0
   2170a:	f47f adea 	bne.w	212e2 <pdn_interface_pdn_id_get+0xd6>
   2170e:	6923      	ldr	r3, [r4, #16]
   21710:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   21712:	0792      	lsls	r2, r2, #30
   21714:	d499      	bmi.n	2164a <pdn_interface_pdn_id_get+0x43e>
   21716:	e5e4      	b.n	212e2 <pdn_interface_pdn_id_get+0xd6>
   21718:	4628      	mov	r0, r5
   2171a:	f7eb fc1d 	bl	cf58 <strlen>
   2171e:	4606      	mov	r6, r0
   21720:	6960      	ldr	r0, [r4, #20]
   21722:	300c      	adds	r0, #12
   21724:	f7eb fc18 	bl	cf58 <strlen>
   21728:	4286      	cmp	r6, r0
   2172a:	f47f ade0 	bne.w	212ee <pdn_interface_pdn_id_get+0xe2>
   2172e:	6961      	ldr	r1, [r4, #20]
   21730:	4628      	mov	r0, r5
   21732:	310c      	adds	r1, #12
   21734:	f7eb fc06 	bl	cf44 <strcmp>
   21738:	2800      	cmp	r0, #0
   2173a:	f47f add8 	bne.w	212ee <pdn_interface_pdn_id_get+0xe2>
   2173e:	6963      	ldr	r3, [r4, #20]
   21740:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   21742:	0797      	lsls	r7, r2, #30
   21744:	d49b      	bmi.n	2167e <pdn_interface_pdn_id_get+0x472>
   21746:	e5d2      	b.n	212ee <pdn_interface_pdn_id_get+0xe2>
   21748:	4628      	mov	r0, r5
   2174a:	f7eb fc05 	bl	cf58 <strlen>
   2174e:	4606      	mov	r6, r0
   21750:	69a0      	ldr	r0, [r4, #24]
   21752:	300c      	adds	r0, #12
   21754:	f7eb fc00 	bl	cf58 <strlen>
   21758:	4286      	cmp	r6, r0
   2175a:	f47f adce 	bne.w	212fa <pdn_interface_pdn_id_get+0xee>
   2175e:	69a1      	ldr	r1, [r4, #24]
   21760:	4628      	mov	r0, r5
   21762:	310c      	adds	r1, #12
   21764:	f7eb fbee 	bl	cf44 <strcmp>
   21768:	2800      	cmp	r0, #0
   2176a:	f47f adc6 	bne.w	212fa <pdn_interface_pdn_id_get+0xee>
   2176e:	69a3      	ldr	r3, [r4, #24]
   21770:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   21772:	0796      	lsls	r6, r2, #30
   21774:	d49d      	bmi.n	216b2 <pdn_interface_pdn_id_get+0x4a6>
   21776:	e5c0      	b.n	212fa <pdn_interface_pdn_id_get+0xee>
   21778:	4628      	mov	r0, r5
   2177a:	f7eb fbed 	bl	cf58 <strlen>
   2177e:	4606      	mov	r6, r0
   21780:	69e0      	ldr	r0, [r4, #28]
   21782:	300c      	adds	r0, #12
   21784:	f7eb fbe8 	bl	cf58 <strlen>
   21788:	4286      	cmp	r6, r0
   2178a:	f47f adbc 	bne.w	21306 <pdn_interface_pdn_id_get+0xfa>
   2178e:	69e1      	ldr	r1, [r4, #28]
   21790:	4628      	mov	r0, r5
   21792:	310c      	adds	r1, #12
   21794:	f7eb fbd6 	bl	cf44 <strcmp>
   21798:	2800      	cmp	r0, #0
   2179a:	f47f adb4 	bne.w	21306 <pdn_interface_pdn_id_get+0xfa>
   2179e:	69e3      	ldr	r3, [r4, #28]
   217a0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   217a2:	0790      	lsls	r0, r2, #30
   217a4:	f57f adaf 	bpl.w	21306 <pdn_interface_pdn_id_get+0xfa>
   217a8:	2607      	movs	r6, #7
   217aa:	e6ea      	b.n	21582 <pdn_interface_pdn_id_get+0x376>
   217ac:	4628      	mov	r0, r5
   217ae:	f7eb fbd3 	bl	cf58 <strlen>
   217b2:	4606      	mov	r6, r0
   217b4:	6a20      	ldr	r0, [r4, #32]
   217b6:	300c      	adds	r0, #12
   217b8:	f7eb fbce 	bl	cf58 <strlen>
   217bc:	4286      	cmp	r6, r0
   217be:	f47f ada8 	bne.w	21312 <pdn_interface_pdn_id_get+0x106>
   217c2:	6a21      	ldr	r1, [r4, #32]
   217c4:	4628      	mov	r0, r5
   217c6:	310c      	adds	r1, #12
   217c8:	f7eb fbbc 	bl	cf44 <strcmp>
   217cc:	2800      	cmp	r0, #0
   217ce:	f47f ada0 	bne.w	21312 <pdn_interface_pdn_id_get+0x106>
   217d2:	6a23      	ldr	r3, [r4, #32]
   217d4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   217d6:	0791      	lsls	r1, r2, #30
   217d8:	f57f ad9b 	bpl.w	21312 <pdn_interface_pdn_id_get+0x106>
   217dc:	2608      	movs	r6, #8
   217de:	e6d0      	b.n	21582 <pdn_interface_pdn_id_get+0x376>
   217e0:	4628      	mov	r0, r5
   217e2:	f7eb fbb9 	bl	cf58 <strlen>
   217e6:	4606      	mov	r6, r0
   217e8:	69e0      	ldr	r0, [r4, #28]
   217ea:	300c      	adds	r0, #12
   217ec:	f7eb fbb4 	bl	cf58 <strlen>
   217f0:	4286      	cmp	r6, r0
   217f2:	f47f adda 	bne.w	213aa <pdn_interface_pdn_id_get+0x19e>
   217f6:	69e1      	ldr	r1, [r4, #28]
   217f8:	4628      	mov	r0, r5
   217fa:	310c      	adds	r1, #12
   217fc:	f7eb fba2 	bl	cf44 <strcmp>
   21800:	2800      	cmp	r0, #0
   21802:	f47f add2 	bne.w	213aa <pdn_interface_pdn_id_get+0x19e>
   21806:	69e3      	ldr	r3, [r4, #28]
   21808:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2180a:	07d0      	lsls	r0, r2, #31
   2180c:	d4cc      	bmi.n	217a8 <pdn_interface_pdn_id_get+0x59c>
   2180e:	e5cc      	b.n	213aa <pdn_interface_pdn_id_get+0x19e>
   21810:	4628      	mov	r0, r5
   21812:	f7eb fba1 	bl	cf58 <strlen>
   21816:	4606      	mov	r6, r0
   21818:	6a20      	ldr	r0, [r4, #32]
   2181a:	300c      	adds	r0, #12
   2181c:	f7eb fb9c 	bl	cf58 <strlen>
   21820:	4286      	cmp	r6, r0
   21822:	f47f adc8 	bne.w	213b6 <pdn_interface_pdn_id_get+0x1aa>
   21826:	6a21      	ldr	r1, [r4, #32]
   21828:	4628      	mov	r0, r5
   2182a:	310c      	adds	r1, #12
   2182c:	f7eb fb8a 	bl	cf44 <strcmp>
   21830:	2800      	cmp	r0, #0
   21832:	f47f adc0 	bne.w	213b6 <pdn_interface_pdn_id_get+0x1aa>
   21836:	6a23      	ldr	r3, [r4, #32]
   21838:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2183a:	07d1      	lsls	r1, r2, #31
   2183c:	d4ce      	bmi.n	217dc <pdn_interface_pdn_id_get+0x5d0>
   2183e:	e5ba      	b.n	213b6 <pdn_interface_pdn_id_get+0x1aa>
   21840:	4628      	mov	r0, r5
   21842:	f7eb fb89 	bl	cf58 <strlen>
   21846:	4606      	mov	r6, r0
   21848:	68a0      	ldr	r0, [r4, #8]
   2184a:	300c      	adds	r0, #12
   2184c:	f7eb fb84 	bl	cf58 <strlen>
   21850:	4286      	cmp	r6, r0
   21852:	f47f ad8c 	bne.w	2136e <pdn_interface_pdn_id_get+0x162>
   21856:	68a1      	ldr	r1, [r4, #8]
   21858:	4628      	mov	r0, r5
   2185a:	310c      	adds	r1, #12
   2185c:	f7eb fb72 	bl	cf44 <strcmp>
   21860:	2800      	cmp	r0, #0
   21862:	f47f ad84 	bne.w	2136e <pdn_interface_pdn_id_get+0x162>
   21866:	68a3      	ldr	r3, [r4, #8]
   21868:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2186a:	07d0      	lsls	r0, r2, #31
   2186c:	f57f ad7f 	bpl.w	2136e <pdn_interface_pdn_id_get+0x162>
   21870:	2602      	movs	r6, #2
   21872:	e686      	b.n	21582 <pdn_interface_pdn_id_get+0x376>
   21874:	4628      	mov	r0, r5
   21876:	f7eb fb6f 	bl	cf58 <strlen>
   2187a:	4606      	mov	r6, r0
   2187c:	68a0      	ldr	r0, [r4, #8]
   2187e:	300c      	adds	r0, #12
   21880:	f7eb fb6a 	bl	cf58 <strlen>
   21884:	4286      	cmp	r6, r0
   21886:	f47f ad20 	bne.w	212ca <pdn_interface_pdn_id_get+0xbe>
   2188a:	68a1      	ldr	r1, [r4, #8]
   2188c:	4628      	mov	r0, r5
   2188e:	310c      	adds	r1, #12
   21890:	f7eb fb58 	bl	cf44 <strcmp>
   21894:	2800      	cmp	r0, #0
   21896:	f47f ad18 	bne.w	212ca <pdn_interface_pdn_id_get+0xbe>
   2189a:	68a3      	ldr	r3, [r4, #8]
   2189c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2189e:	0790      	lsls	r0, r2, #30
   218a0:	d4e6      	bmi.n	21870 <pdn_interface_pdn_id_get+0x664>
   218a2:	e512      	b.n	212ca <pdn_interface_pdn_id_get+0xbe>
   218a4:	20028d70 	.word	0x20028d70
   218a8:	00030d7c 	.word	0x00030d7c
   218ac:	00030d78 	.word	0x00030d78
   218b0:	00030d8c 	.word	0x00030d8c
   218b4:	20028d6c 	.word	0x20028d6c
   218b8:	4628      	mov	r0, r5
   218ba:	f7eb fb4d 	bl	cf58 <strlen>
   218be:	4606      	mov	r6, r0
   218c0:	6860      	ldr	r0, [r4, #4]
   218c2:	300c      	adds	r0, #12
   218c4:	f7eb fb48 	bl	cf58 <strlen>
   218c8:	4286      	cmp	r6, r0
   218ca:	f47f acf8 	bne.w	212be <pdn_interface_pdn_id_get+0xb2>
   218ce:	6861      	ldr	r1, [r4, #4]
   218d0:	4628      	mov	r0, r5
   218d2:	310c      	adds	r1, #12
   218d4:	f7eb fb36 	bl	cf44 <strcmp>
   218d8:	2800      	cmp	r0, #0
   218da:	f47f acf0 	bne.w	212be <pdn_interface_pdn_id_get+0xb2>
   218de:	6863      	ldr	r3, [r4, #4]
   218e0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   218e2:	0796      	lsls	r6, r2, #30
   218e4:	f57f aceb 	bpl.w	212be <pdn_interface_pdn_id_get+0xb2>
   218e8:	2601      	movs	r6, #1
   218ea:	e64a      	b.n	21582 <pdn_interface_pdn_id_get+0x376>
   218ec:	4628      	mov	r0, r5
   218ee:	f7eb fb33 	bl	cf58 <strlen>
   218f2:	4606      	mov	r6, r0
   218f4:	6860      	ldr	r0, [r4, #4]
   218f6:	300c      	adds	r0, #12
   218f8:	f7eb fb2e 	bl	cf58 <strlen>
   218fc:	4286      	cmp	r6, r0
   218fe:	f47f ad30 	bne.w	21362 <pdn_interface_pdn_id_get+0x156>
   21902:	6861      	ldr	r1, [r4, #4]
   21904:	4628      	mov	r0, r5
   21906:	310c      	adds	r1, #12
   21908:	f7eb fb1c 	bl	cf44 <strcmp>
   2190c:	2800      	cmp	r0, #0
   2190e:	f47f ad28 	bne.w	21362 <pdn_interface_pdn_id_get+0x156>
   21912:	6863      	ldr	r3, [r4, #4]
   21914:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   21916:	07d6      	lsls	r6, r2, #31
   21918:	d4e6      	bmi.n	218e8 <pdn_interface_pdn_id_get+0x6dc>
   2191a:	e522      	b.n	21362 <pdn_interface_pdn_id_get+0x156>
   2191c:	4608      	mov	r0, r1
   2191e:	f7eb fb1b 	bl	cf58 <strlen>
   21922:	4606      	mov	r6, r0
   21924:	6820      	ldr	r0, [r4, #0]
   21926:	300c      	adds	r0, #12
   21928:	f7eb fb16 	bl	cf58 <strlen>
   2192c:	4286      	cmp	r6, r0
   2192e:	f47f acc0 	bne.w	212b2 <pdn_interface_pdn_id_get+0xa6>
   21932:	6821      	ldr	r1, [r4, #0]
   21934:	4628      	mov	r0, r5
   21936:	310c      	adds	r1, #12
   21938:	f7eb fb04 	bl	cf44 <strcmp>
   2193c:	4606      	mov	r6, r0
   2193e:	2800      	cmp	r0, #0
   21940:	f47f acb7 	bne.w	212b2 <pdn_interface_pdn_id_get+0xa6>
   21944:	6823      	ldr	r3, [r4, #0]
   21946:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   21948:	0797      	lsls	r7, r2, #30
   2194a:	f53f ae1a 	bmi.w	21582 <pdn_interface_pdn_id_get+0x376>
   2194e:	e4b0      	b.n	212b2 <pdn_interface_pdn_id_get+0xa6>
   21950:	4608      	mov	r0, r1
   21952:	f7eb fb01 	bl	cf58 <strlen>
   21956:	4606      	mov	r6, r0
   21958:	6820      	ldr	r0, [r4, #0]
   2195a:	300c      	adds	r0, #12
   2195c:	f7eb fafc 	bl	cf58 <strlen>
   21960:	4286      	cmp	r6, r0
   21962:	f47f acf8 	bne.w	21356 <pdn_interface_pdn_id_get+0x14a>
   21966:	6821      	ldr	r1, [r4, #0]
   21968:	4628      	mov	r0, r5
   2196a:	310c      	adds	r1, #12
   2196c:	f7eb faea 	bl	cf44 <strcmp>
   21970:	4606      	mov	r6, r0
   21972:	2800      	cmp	r0, #0
   21974:	f47f acef 	bne.w	21356 <pdn_interface_pdn_id_get+0x14a>
   21978:	6823      	ldr	r3, [r4, #0]
   2197a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2197c:	07d7      	lsls	r7, r2, #31
   2197e:	f53f ae00 	bmi.w	21582 <pdn_interface_pdn_id_get+0x376>
   21982:	e4e8      	b.n	21356 <pdn_interface_pdn_id_get+0x14a>
   21984:	f04f 30ff 	mov.w	r0, #4294967295
   21988:	4770      	bx	lr
   2198a:	480b      	ldr	r0, [pc, #44]	; (219b8 <pdn_interface_pdn_id_get+0x7ac>)
   2198c:	f7eb fae4 	bl	cf58 <strlen>
   21990:	490a      	ldr	r1, [pc, #40]	; (219bc <pdn_interface_pdn_id_get+0x7b0>)
   21992:	4602      	mov	r2, r0
   21994:	4808      	ldr	r0, [pc, #32]	; (219b8 <pdn_interface_pdn_id_get+0x7ac>)
   21996:	f00d fe86 	bl	2f6a6 <strncmp>
   2199a:	b930      	cbnz	r0, 219aa <pdn_interface_pdn_id_get+0x79e>
   2199c:	2008      	movs	r0, #8
   2199e:	f7f9 fee5 	bl	1b76c <bsd_os_errno_set>
   219a2:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   219a6:	6858      	ldr	r0, [r3, #4]
   219a8:	e47b      	b.n	212a2 <pdn_interface_pdn_id_get+0x96>
   219aa:	2005      	movs	r0, #5
   219ac:	f7f9 fede 	bl	1b76c <bsd_os_errno_set>
   219b0:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   219b4:	6858      	ldr	r0, [r3, #4]
   219b6:	e474      	b.n	212a2 <pdn_interface_pdn_id_get+0x96>
   219b8:	00030dd0 	.word	0x00030dd0
   219bc:	20028d70 	.word	0x20028d70

000219c0 <linked_list_init>:
   219c0:	b128      	cbz	r0, 219ce <linked_list_init+0xe>
   219c2:	2300      	movs	r3, #0
   219c4:	6003      	str	r3, [r0, #0]
   219c6:	e9c0 3301 	strd	r3, r3, [r0, #4]
   219ca:	4618      	mov	r0, r3
   219cc:	4770      	bx	lr
   219ce:	2007      	movs	r0, #7
   219d0:	4770      	bx	lr
   219d2:	bf00      	nop

000219d4 <linked_list_push>:
   219d4:	6802      	ldr	r2, [r0, #0]
   219d6:	4603      	mov	r3, r0
   219d8:	3201      	adds	r2, #1
   219da:	d00e      	beq.n	219fa <linked_list_push+0x26>
   219dc:	2200      	movs	r2, #0
   219de:	600a      	str	r2, [r1, #0]
   219e0:	6802      	ldr	r2, [r0, #0]
   219e2:	b13a      	cbz	r2, 219f4 <linked_list_push+0x20>
   219e4:	6882      	ldr	r2, [r0, #8]
   219e6:	6011      	str	r1, [r2, #0]
   219e8:	6081      	str	r1, [r0, #8]
   219ea:	681a      	ldr	r2, [r3, #0]
   219ec:	2000      	movs	r0, #0
   219ee:	3201      	adds	r2, #1
   219f0:	601a      	str	r2, [r3, #0]
   219f2:	4770      	bx	lr
   219f4:	e9c0 1101 	strd	r1, r1, [r0, #4]
   219f8:	e7f7      	b.n	219ea <linked_list_push+0x16>
   219fa:	2004      	movs	r0, #4
   219fc:	4770      	bx	lr
   219fe:	bf00      	nop

00021a00 <linked_list_pop>:
   21a00:	4603      	mov	r3, r0
   21a02:	6800      	ldr	r0, [r0, #0]
   21a04:	b128      	cbz	r0, 21a12 <linked_list_pop+0x12>
   21a06:	6858      	ldr	r0, [r3, #4]
   21a08:	681a      	ldr	r2, [r3, #0]
   21a0a:	6801      	ldr	r1, [r0, #0]
   21a0c:	3a01      	subs	r2, #1
   21a0e:	6059      	str	r1, [r3, #4]
   21a10:	601a      	str	r2, [r3, #0]
   21a12:	4770      	bx	lr

00021a14 <linked_list_peek>:
   21a14:	6803      	ldr	r3, [r0, #0]
   21a16:	b10b      	cbz	r3, 21a1c <linked_list_peek+0x8>
   21a18:	6840      	ldr	r0, [r0, #4]
   21a1a:	4770      	bx	lr
   21a1c:	4618      	mov	r0, r3
   21a1e:	4770      	bx	lr

00021a20 <linked_list_size_get>:
   21a20:	6800      	ldr	r0, [r0, #0]
   21a22:	4770      	bx	lr

00021a24 <linked_list_get_next>:
   21a24:	6800      	ldr	r0, [r0, #0]
   21a26:	4770      	bx	lr

00021a28 <nrf_socket>:
   21a28:	b570      	push	{r4, r5, r6, lr}
   21a2a:	4604      	mov	r4, r0
   21a2c:	460d      	mov	r5, r1
   21a2e:	4616      	mov	r6, r2
   21a30:	f7fd fdb4 	bl	1f59c <bsd_platform_af_method_table_get>
   21a34:	b130      	cbz	r0, 21a44 <nrf_socket+0x1c>
   21a36:	6803      	ldr	r3, [r0, #0]
   21a38:	4632      	mov	r2, r6
   21a3a:	4629      	mov	r1, r5
   21a3c:	4620      	mov	r0, r4
   21a3e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   21a42:	4718      	bx	r3
   21a44:	f04f 30ff 	mov.w	r0, #4294967295
   21a48:	bd70      	pop	{r4, r5, r6, pc}
   21a4a:	bf00      	nop

00021a4c <nrf_close>:
   21a4c:	b510      	push	{r4, lr}
   21a4e:	4604      	mov	r4, r0
   21a50:	f7fd fdfc 	bl	1f64c <bsd_platform_fd_method_table_get>
   21a54:	b120      	cbz	r0, 21a60 <nrf_close+0x14>
   21a56:	6843      	ldr	r3, [r0, #4]
   21a58:	4620      	mov	r0, r4
   21a5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   21a5e:	4718      	bx	r3
   21a60:	f04f 30ff 	mov.w	r0, #4294967295
   21a64:	bd10      	pop	{r4, pc}
   21a66:	bf00      	nop

00021a68 <nrf_sendto>:
   21a68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   21a6c:	460d      	mov	r5, r1
   21a6e:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   21a72:	4616      	mov	r6, r2
   21a74:	461f      	mov	r7, r3
   21a76:	4604      	mov	r4, r0
   21a78:	f7fd fde8 	bl	1f64c <bsd_platform_fd_method_table_get>
   21a7c:	b158      	cbz	r0, 21a96 <nrf_sendto+0x2e>
   21a7e:	e9cd 8908 	strd	r8, r9, [sp, #32]
   21a82:	f8d0 e008 	ldr.w	lr, [r0, #8]
   21a86:	463b      	mov	r3, r7
   21a88:	4632      	mov	r2, r6
   21a8a:	4629      	mov	r1, r5
   21a8c:	4620      	mov	r0, r4
   21a8e:	46f4      	mov	ip, lr
   21a90:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   21a94:	4760      	bx	ip
   21a96:	f04f 30ff 	mov.w	r0, #4294967295
   21a9a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   21a9e:	bf00      	nop

00021aa0 <nrf_send>:
   21aa0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   21aa4:	b082      	sub	sp, #8
   21aa6:	460e      	mov	r6, r1
   21aa8:	4617      	mov	r7, r2
   21aaa:	4698      	mov	r8, r3
   21aac:	4605      	mov	r5, r0
   21aae:	f7fd fdcd 	bl	1f64c <bsd_platform_fd_method_table_get>
   21ab2:	b160      	cbz	r0, 21ace <nrf_send+0x2e>
   21ab4:	4604      	mov	r4, r0
   21ab6:	2000      	movs	r0, #0
   21ab8:	e9cd 0000 	strd	r0, r0, [sp]
   21abc:	4643      	mov	r3, r8
   21abe:	463a      	mov	r2, r7
   21ac0:	4631      	mov	r1, r6
   21ac2:	4628      	mov	r0, r5
   21ac4:	68a4      	ldr	r4, [r4, #8]
   21ac6:	47a0      	blx	r4
   21ac8:	b002      	add	sp, #8
   21aca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   21ace:	f04f 30ff 	mov.w	r0, #4294967295
   21ad2:	e7f9      	b.n	21ac8 <nrf_send+0x28>

00021ad4 <nrf_recvfrom>:
   21ad4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   21ad8:	460d      	mov	r5, r1
   21ada:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   21ade:	4616      	mov	r6, r2
   21ae0:	461f      	mov	r7, r3
   21ae2:	4604      	mov	r4, r0
   21ae4:	f7fd fdb2 	bl	1f64c <bsd_platform_fd_method_table_get>
   21ae8:	b158      	cbz	r0, 21b02 <nrf_recvfrom+0x2e>
   21aea:	e9cd 8908 	strd	r8, r9, [sp, #32]
   21aee:	f8d0 e00c 	ldr.w	lr, [r0, #12]
   21af2:	463b      	mov	r3, r7
   21af4:	4632      	mov	r2, r6
   21af6:	4629      	mov	r1, r5
   21af8:	4620      	mov	r0, r4
   21afa:	46f4      	mov	ip, lr
   21afc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   21b00:	4760      	bx	ip
   21b02:	f04f 30ff 	mov.w	r0, #4294967295
   21b06:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   21b0a:	bf00      	nop

00021b0c <nrf_recv>:
   21b0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   21b10:	b082      	sub	sp, #8
   21b12:	460e      	mov	r6, r1
   21b14:	4617      	mov	r7, r2
   21b16:	4698      	mov	r8, r3
   21b18:	4605      	mov	r5, r0
   21b1a:	f7fd fd97 	bl	1f64c <bsd_platform_fd_method_table_get>
   21b1e:	b160      	cbz	r0, 21b3a <nrf_recv+0x2e>
   21b20:	4604      	mov	r4, r0
   21b22:	2000      	movs	r0, #0
   21b24:	e9cd 0000 	strd	r0, r0, [sp]
   21b28:	4643      	mov	r3, r8
   21b2a:	463a      	mov	r2, r7
   21b2c:	4631      	mov	r1, r6
   21b2e:	4628      	mov	r0, r5
   21b30:	68e4      	ldr	r4, [r4, #12]
   21b32:	47a0      	blx	r4
   21b34:	b002      	add	sp, #8
   21b36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   21b3a:	f04f 30ff 	mov.w	r0, #4294967295
   21b3e:	e7f9      	b.n	21b34 <nrf_recv+0x28>

00021b40 <nrf_connect>:
   21b40:	b570      	push	{r4, r5, r6, lr}
   21b42:	460d      	mov	r5, r1
   21b44:	4616      	mov	r6, r2
   21b46:	4604      	mov	r4, r0
   21b48:	f7fd fd80 	bl	1f64c <bsd_platform_fd_method_table_get>
   21b4c:	b130      	cbz	r0, 21b5c <nrf_connect+0x1c>
   21b4e:	6943      	ldr	r3, [r0, #20]
   21b50:	4632      	mov	r2, r6
   21b52:	4629      	mov	r1, r5
   21b54:	4620      	mov	r0, r4
   21b56:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   21b5a:	4718      	bx	r3
   21b5c:	f04f 30ff 	mov.w	r0, #4294967295
   21b60:	bd70      	pop	{r4, r5, r6, pc}
   21b62:	bf00      	nop

00021b64 <nrf_listen>:
   21b64:	b570      	push	{r4, r5, r6, lr}
   21b66:	460d      	mov	r5, r1
   21b68:	4604      	mov	r4, r0
   21b6a:	f7fd fd6f 	bl	1f64c <bsd_platform_fd_method_table_get>
   21b6e:	b128      	cbz	r0, 21b7c <nrf_listen+0x18>
   21b70:	6983      	ldr	r3, [r0, #24]
   21b72:	4629      	mov	r1, r5
   21b74:	4620      	mov	r0, r4
   21b76:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   21b7a:	4718      	bx	r3
   21b7c:	f04f 30ff 	mov.w	r0, #4294967295
   21b80:	bd70      	pop	{r4, r5, r6, pc}
   21b82:	bf00      	nop

00021b84 <nrf_accept>:
   21b84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   21b88:	460d      	mov	r5, r1
   21b8a:	4616      	mov	r6, r2
   21b8c:	4604      	mov	r4, r0
   21b8e:	f7fd fd5d 	bl	1f64c <bsd_platform_fd_method_table_get>
   21b92:	b140      	cbz	r0, 21ba6 <nrf_accept+0x22>
   21b94:	69c7      	ldr	r7, [r0, #28]
   21b96:	4632      	mov	r2, r6
   21b98:	4629      	mov	r1, r5
   21b9a:	4620      	mov	r0, r4
   21b9c:	46bc      	mov	ip, r7
   21b9e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   21ba2:	2300      	movs	r3, #0
   21ba4:	4760      	bx	ip
   21ba6:	f04f 30ff 	mov.w	r0, #4294967295
   21baa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   21bae:	bf00      	nop

00021bb0 <nrf_bind>:
   21bb0:	b570      	push	{r4, r5, r6, lr}
   21bb2:	460d      	mov	r5, r1
   21bb4:	4616      	mov	r6, r2
   21bb6:	4604      	mov	r4, r0
   21bb8:	f7fd fd48 	bl	1f64c <bsd_platform_fd_method_table_get>
   21bbc:	b130      	cbz	r0, 21bcc <nrf_bind+0x1c>
   21bbe:	6903      	ldr	r3, [r0, #16]
   21bc0:	4632      	mov	r2, r6
   21bc2:	4629      	mov	r1, r5
   21bc4:	4620      	mov	r0, r4
   21bc6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   21bca:	4718      	bx	r3
   21bcc:	f04f 30ff 	mov.w	r0, #4294967295
   21bd0:	bd70      	pop	{r4, r5, r6, pc}
   21bd2:	bf00      	nop

00021bd4 <nrf_setsockopt>:
   21bd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   21bd8:	f8dd 8018 	ldr.w	r8, [sp, #24]
   21bdc:	460d      	mov	r5, r1
   21bde:	4616      	mov	r6, r2
   21be0:	461f      	mov	r7, r3
   21be2:	4604      	mov	r4, r0
   21be4:	f7fd fd32 	bl	1f64c <bsd_platform_fd_method_table_get>
   21be8:	b158      	cbz	r0, 21c02 <nrf_setsockopt+0x2e>
   21bea:	f8cd 8018 	str.w	r8, [sp, #24]
   21bee:	f8d0 e020 	ldr.w	lr, [r0, #32]
   21bf2:	463b      	mov	r3, r7
   21bf4:	4632      	mov	r2, r6
   21bf6:	4629      	mov	r1, r5
   21bf8:	4620      	mov	r0, r4
   21bfa:	46f4      	mov	ip, lr
   21bfc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   21c00:	4760      	bx	ip
   21c02:	f04f 30ff 	mov.w	r0, #4294967295
   21c06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   21c0a:	bf00      	nop

00021c0c <nrf_getsockopt>:
   21c0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   21c10:	f8dd 8018 	ldr.w	r8, [sp, #24]
   21c14:	460d      	mov	r5, r1
   21c16:	4616      	mov	r6, r2
   21c18:	461f      	mov	r7, r3
   21c1a:	4604      	mov	r4, r0
   21c1c:	f7fd fd16 	bl	1f64c <bsd_platform_fd_method_table_get>
   21c20:	b158      	cbz	r0, 21c3a <nrf_getsockopt+0x2e>
   21c22:	f8cd 8018 	str.w	r8, [sp, #24]
   21c26:	f8d0 e024 	ldr.w	lr, [r0, #36]	; 0x24
   21c2a:	463b      	mov	r3, r7
   21c2c:	4632      	mov	r2, r6
   21c2e:	4629      	mov	r1, r5
   21c30:	4620      	mov	r0, r4
   21c32:	46f4      	mov	ip, lr
   21c34:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   21c38:	4760      	bx	ip
   21c3a:	f04f 30ff 	mov.w	r0, #4294967295
   21c3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   21c42:	bf00      	nop

00021c44 <nrf_getaddrinfo>:
   21c44:	f7fd bd78 	b.w	1f738 <bsd_platform_getaddrinfo>

00021c48 <nrf_freeaddrinfo>:
   21c48:	f7fd bd78 	b.w	1f73c <bsd_platform_freeaddrinfo>

00021c4c <nrf_poll>:
   21c4c:	f7fd bd78 	b.w	1f740 <bsd_platform_poll>

00021c50 <nrf_fcntl>:
   21c50:	f7fd bdd0 	b.w	1f7f4 <bsd_platform_fcntl>

00021c54 <at_client_evt_handler>:
   21c54:	b120      	cbz	r0, 21c60 <at_client_evt_handler+0xc>
   21c56:	f850 1b08 	ldr.w	r1, [r0], #8
   21c5a:	0c09      	lsrs	r1, r1, #16
   21c5c:	f7fb bf9e 	b.w	1db9c <rpc_at_event_handler>
   21c60:	4770      	bx	lr
   21c62:	bf00      	nop

00021c64 <rpc_at_client_init>:
   21c64:	4801      	ldr	r0, [pc, #4]	; (21c6c <rpc_at_client_init+0x8>)
   21c66:	f001 be47 	b.w	238f8 <rpc_client_register>
   21c6a:	bf00      	nop
   21c6c:	00030de4 	.word	0x00030de4

00021c70 <rpc_at_client_request_alloc>:
   21c70:	b180      	cbz	r0, 21c94 <rpc_at_client_request_alloc+0x24>
   21c72:	2300      	movs	r3, #0
   21c74:	b510      	push	{r4, lr}
   21c76:	b082      	sub	sp, #8
   21c78:	aa02      	add	r2, sp, #8
   21c7a:	4604      	mov	r4, r0
   21c7c:	f842 3d04 	str.w	r3, [r2, #-4]!
   21c80:	2003      	movs	r0, #3
   21c82:	f002 f871 	bl	23d68 <rpc_message_alloc>
   21c86:	b918      	cbnz	r0, 21c90 <rpc_at_client_request_alloc+0x20>
   21c88:	9b01      	ldr	r3, [sp, #4]
   21c8a:	b10b      	cbz	r3, 21c90 <rpc_at_client_request_alloc+0x20>
   21c8c:	3308      	adds	r3, #8
   21c8e:	6023      	str	r3, [r4, #0]
   21c90:	b002      	add	sp, #8
   21c92:	bd10      	pop	{r4, pc}
   21c94:	200e      	movs	r0, #14
   21c96:	4770      	bx	lr

00021c98 <rpc_at_client_request_send>:
   21c98:	b150      	cbz	r0, 21cb0 <rpc_at_client_request_send+0x18>
   21c9a:	4603      	mov	r3, r0
   21c9c:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   21ca0:	2003      	movs	r0, #3
   21ca2:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   21ca6:	f843 1d08 	str.w	r1, [r3, #-8]!
   21caa:	4619      	mov	r1, r3
   21cac:	f002 b844 	b.w	23d38 <rpc_message_send>
   21cb0:	200e      	movs	r0, #14
   21cb2:	4770      	bx	lr

00021cb4 <rpc_at_client_message_free>:
   21cb4:	b120      	cbz	r0, 21cc0 <rpc_at_client_message_free+0xc>
   21cb6:	f1a0 0108 	sub.w	r1, r0, #8
   21cba:	2003      	movs	r0, #3
   21cbc:	f002 b886 	b.w	23dcc <rpc_message_free>
   21cc0:	200e      	movs	r0, #14
   21cc2:	4770      	bx	lr

00021cc4 <rpc_at_client_data_free>:
   21cc4:	b118      	cbz	r0, 21cce <rpc_at_client_data_free+0xa>
   21cc6:	4601      	mov	r1, r0
   21cc8:	2003      	movs	r0, #3
   21cca:	f002 b991 	b.w	23ff0 <rpc_message_data_free>
   21cce:	200e      	movs	r0, #14
   21cd0:	4770      	bx	lr
   21cd2:	bf00      	nop

00021cd4 <ip_recvd_packet_free_cb>:
   21cd4:	b510      	push	{r4, lr}
   21cd6:	4604      	mov	r4, r0
   21cd8:	6800      	ldr	r0, [r0, #0]
   21cda:	f7fc fc1d 	bl	1e518 <rpc_ip_client_data_free>
   21cde:	68a0      	ldr	r0, [r4, #8]
   21ce0:	b118      	cbz	r0, 21cea <ip_recvd_packet_free_cb+0x16>
   21ce2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   21ce6:	f7fc bbb7 	b.w	1e458 <nrf_free>
   21cea:	bd10      	pop	{r4, pc}

00021cec <rpc_error_to_nrf_bsd_error>:
   21cec:	2810      	cmp	r0, #16
   21cee:	bf9a      	itte	ls
   21cf0:	4b02      	ldrls	r3, [pc, #8]	; (21cfc <rpc_error_to_nrf_bsd_error+0x10>)
   21cf2:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
   21cf6:	202d      	movhi	r0, #45	; 0x2d
   21cf8:	4770      	bx	lr
   21cfa:	bf00      	nop
   21cfc:	00030df4 	.word	0x00030df4

00021d00 <ip_interface_request_create>:
   21d00:	b570      	push	{r4, r5, r6, lr}
   21d02:	2500      	movs	r5, #0
   21d04:	b082      	sub	sp, #8
   21d06:	ac02      	add	r4, sp, #8
   21d08:	f844 5d04 	str.w	r5, [r4, #-4]!
   21d0c:	4606      	mov	r6, r0
   21d0e:	460d      	mov	r5, r1
   21d10:	4620      	mov	r0, r4
   21d12:	4619      	mov	r1, r3
   21d14:	4614      	mov	r4, r2
   21d16:	f7fc fbcd 	bl	1e4b4 <rpc_ip_client_request_alloc>
   21d1a:	b960      	cbnz	r0, 21d36 <ip_interface_request_create+0x36>
   21d1c:	9b01      	ldr	r3, [sp, #4]
   21d1e:	2208      	movs	r2, #8
   21d20:	7258      	strb	r0, [r3, #9]
   21d22:	7298      	strb	r0, [r3, #10]
   21d24:	72d8      	strb	r0, [r3, #11]
   21d26:	4618      	mov	r0, r3
   21d28:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
   21d2c:	60dc      	str	r4, [r3, #12]
   21d2e:	611d      	str	r5, [r3, #16]
   21d30:	721a      	strb	r2, [r3, #8]
   21d32:	b002      	add	sp, #8
   21d34:	bd70      	pop	{r4, r5, r6, pc}
   21d36:	9b01      	ldr	r3, [sp, #4]
   21d38:	4618      	mov	r0, r3
   21d3a:	b002      	add	sp, #8
   21d3c:	bd70      	pop	{r4, r5, r6, pc}
   21d3e:	bf00      	nop

00021d40 <ip_interface_request_send>:
   21d40:	b570      	push	{r4, r5, r6, lr}
   21d42:	460c      	mov	r4, r1
   21d44:	4605      	mov	r5, r0
   21d46:	4611      	mov	r1, r2
   21d48:	4620      	mov	r0, r4
   21d4a:	461e      	mov	r6, r3
   21d4c:	f7fc fbc6 	bl	1e4dc <rpc_ip_client_request_send>
   21d50:	b900      	cbnz	r0, 21d54 <ip_interface_request_send+0x14>
   21d52:	bd70      	pop	{r4, r5, r6, pc}
   21d54:	6820      	ldr	r0, [r4, #0]
   21d56:	b108      	cbz	r0, 21d5c <ip_interface_request_send+0x1c>
   21d58:	f7fc fbde 	bl	1e518 <rpc_ip_client_data_free>
   21d5c:	4620      	mov	r0, r4
   21d5e:	f7fc fbd3 	bl	1e508 <rpc_ip_client_message_free>
   21d62:	602e      	str	r6, [r5, #0]
   21d64:	2023      	movs	r0, #35	; 0x23
   21d66:	bd70      	pop	{r4, r5, r6, pc}

00021d68 <ip_interface_wait>:
   21d68:	b538      	push	{r3, r4, r5, lr}
   21d6a:	4605      	mov	r5, r0
   21d6c:	f001 fc14 	bl	23598 <interface_socket_wait>
   21d70:	4604      	mov	r4, r0
   21d72:	b108      	cbz	r0, 21d78 <ip_interface_wait+0x10>
   21d74:	4620      	mov	r0, r4
   21d76:	bd38      	pop	{r3, r4, r5, pc}
   21d78:	4628      	mov	r0, r5
   21d7a:	f001 fc81 	bl	23680 <interface_socket_from_handle_get>
   21d7e:	2800      	cmp	r0, #0
   21d80:	d0f8      	beq.n	21d74 <ip_interface_wait+0xc>
   21d82:	6844      	ldr	r4, [r0, #4]
   21d84:	2c00      	cmp	r4, #0
   21d86:	d0f5      	beq.n	21d74 <ip_interface_wait+0xc>
   21d88:	2300      	movs	r3, #0
   21d8a:	6043      	str	r3, [r0, #4]
   21d8c:	4620      	mov	r0, r4
   21d8e:	bd38      	pop	{r3, r4, r5, pc}

00021d90 <ip_interface_init>:
   21d90:	b538      	push	{r3, r4, r5, lr}
   21d92:	2300      	movs	r3, #0
   21d94:	4d07      	ldr	r5, [pc, #28]	; (21db4 <ip_interface_init+0x24>)
   21d96:	4c08      	ldr	r4, [pc, #32]	; (21db8 <ip_interface_init+0x28>)
   21d98:	4619      	mov	r1, r3
   21d9a:	2224      	movs	r2, #36	; 0x24
   21d9c:	4807      	ldr	r0, [pc, #28]	; (21dbc <ip_interface_init+0x2c>)
   21d9e:	602b      	str	r3, [r5, #0]
   21da0:	6023      	str	r3, [r4, #0]
   21da2:	f00d faf7 	bl	2f394 <memset>
   21da6:	f7fc fb7f 	bl	1e4a8 <rpc_ip_client_init>
   21daa:	3000      	adds	r0, #0
   21dac:	bf18      	it	ne
   21dae:	2001      	movne	r0, #1
   21db0:	4240      	negs	r0, r0
   21db2:	bd38      	pop	{r3, r4, r5, pc}
   21db4:	20028ea8 	.word	0x20028ea8
   21db8:	20028ea4 	.word	0x20028ea4
   21dbc:	20028eb0 	.word	0x20028eb0

00021dc0 <ip_interface_open>:
   21dc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   21dc4:	4606      	mov	r6, r0
   21dc6:	2000      	movs	r0, #0
   21dc8:	f026 0308 	bic.w	r3, r6, #8
   21dcc:	b082      	sub	sp, #8
   21dce:	2b02      	cmp	r3, #2
   21dd0:	460c      	mov	r4, r1
   21dd2:	4617      	mov	r7, r2
   21dd4:	9000      	str	r0, [sp, #0]
   21dd6:	d002      	beq.n	21dde <ip_interface_open+0x1e>
   21dd8:	2e05      	cmp	r6, #5
   21dda:	f040 8085 	bne.w	21ee8 <ip_interface_open+0x128>
   21dde:	1e63      	subs	r3, r4, #1
   21de0:	2b02      	cmp	r3, #2
   21de2:	f200 8097 	bhi.w	21f14 <ip_interface_open+0x154>
   21de6:	2f00      	cmp	r7, #0
   21de8:	d154      	bne.n	21e94 <ip_interface_open+0xd4>
   21dea:	2c01      	cmp	r4, #1
   21dec:	d067      	beq.n	21ebe <ip_interface_open+0xfe>
   21dee:	2c03      	cmp	r4, #3
   21df0:	bf18      	it	ne
   21df2:	2702      	movne	r7, #2
   21df4:	4a4a      	ldr	r2, [pc, #296]	; (21f20 <ip_interface_open+0x160>)
   21df6:	4621      	mov	r1, r4
   21df8:	4668      	mov	r0, sp
   21dfa:	f001 fb1b 	bl	23434 <interface_socket_allocate>
   21dfe:	9b00      	ldr	r3, [sp, #0]
   21e00:	4680      	mov	r8, r0
   21e02:	2b00      	cmp	r3, #0
   21e04:	d059      	beq.n	21eba <ip_interface_open+0xfa>
   21e06:	2100      	movs	r1, #0
   21e08:	a802      	add	r0, sp, #8
   21e0a:	f840 1d04 	str.w	r1, [r0, #-4]!
   21e0e:	e9c3 6403 	strd	r6, r4, [r3, #12]
   21e12:	615f      	str	r7, [r3, #20]
   21e14:	f7fc fb4e 	bl	1e4b4 <rpc_ip_client_request_alloc>
   21e18:	2800      	cmp	r0, #0
   21e1a:	d14b      	bne.n	21eb4 <ip_interface_open+0xf4>
   21e1c:	f247 0201 	movw	r2, #28673	; 0x7001
   21e20:	f04f 33ff 	mov.w	r3, #4294967295
   21e24:	2108      	movs	r1, #8
   21e26:	9d01      	ldr	r5, [sp, #4]
   21e28:	ea42 4208 	orr.w	r2, r2, r8, lsl #16
   21e2c:	60ea      	str	r2, [r5, #12]
   21e2e:	7268      	strb	r0, [r5, #9]
   21e30:	72a8      	strb	r0, [r5, #10]
   21e32:	72e8      	strb	r0, [r5, #11]
   21e34:	7229      	strb	r1, [r5, #8]
   21e36:	742b      	strb	r3, [r5, #16]
   21e38:	746b      	strb	r3, [r5, #17]
   21e3a:	74ab      	strb	r3, [r5, #18]
   21e3c:	74eb      	strb	r3, [r5, #19]
   21e3e:	68ab      	ldr	r3, [r5, #8]
   21e40:	2e05      	cmp	r6, #5
   21e42:	f103 030c 	add.w	r3, r3, #12
   21e46:	60ab      	str	r3, [r5, #8]
   21e48:	d003      	beq.n	21e52 <ip_interface_open+0x92>
   21e4a:	2e0a      	cmp	r6, #10
   21e4c:	bf14      	ite	ne
   21e4e:	2601      	movne	r6, #1
   21e50:	2602      	moveq	r6, #2
   21e52:	616e      	str	r6, [r5, #20]
   21e54:	61ef      	str	r7, [r5, #28]
   21e56:	61ac      	str	r4, [r5, #24]
   21e58:	f247 0101 	movw	r1, #28673	; 0x7001
   21e5c:	4628      	mov	r0, r5
   21e5e:	9f00      	ldr	r7, [sp, #0]
   21e60:	f7fc fb3c 	bl	1e4dc <rpc_ip_client_request_send>
   21e64:	4606      	mov	r6, r0
   21e66:	b360      	cbz	r0, 21ec2 <ip_interface_open+0x102>
   21e68:	6828      	ldr	r0, [r5, #0]
   21e6a:	b108      	cbz	r0, 21e70 <ip_interface_open+0xb0>
   21e6c:	f7fc fb54 	bl	1e518 <rpc_ip_client_data_free>
   21e70:	4628      	mov	r0, r5
   21e72:	f7fc fb49 	bl	1e508 <rpc_ip_client_message_free>
   21e76:	2301      	movs	r3, #1
   21e78:	2523      	movs	r5, #35	; 0x23
   21e7a:	603b      	str	r3, [r7, #0]
   21e7c:	4640      	mov	r0, r8
   21e7e:	f001 fb3d 	bl	234fc <interface_socket_free>
   21e82:	4628      	mov	r0, r5
   21e84:	f7f9 fc72 	bl	1b76c <bsd_os_errno_set>
   21e88:	f04f 38ff 	mov.w	r8, #4294967295
   21e8c:	4640      	mov	r0, r8
   21e8e:	b002      	add	sp, #8
   21e90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   21e94:	2c01      	cmp	r4, #1
   21e96:	d009      	beq.n	21eac <ip_interface_open+0xec>
   21e98:	2c02      	cmp	r4, #2
   21e9a:	d109      	bne.n	21eb0 <ip_interface_open+0xf0>
   21e9c:	2f02      	cmp	r7, #2
   21e9e:	d0a9      	beq.n	21df4 <ip_interface_open+0x34>
   21ea0:	2029      	movs	r0, #41	; 0x29
   21ea2:	f7f9 fc63 	bl	1b76c <bsd_os_errno_set>
   21ea6:	f04f 38ff 	mov.w	r8, #4294967295
   21eaa:	e7ef      	b.n	21e8c <ip_interface_open+0xcc>
   21eac:	2f01      	cmp	r7, #1
   21eae:	d1f7      	bne.n	21ea0 <ip_interface_open+0xe0>
   21eb0:	2702      	movs	r7, #2
   21eb2:	e79f      	b.n	21df4 <ip_interface_open+0x34>
   21eb4:	9d01      	ldr	r5, [sp, #4]
   21eb6:	2d00      	cmp	r5, #0
   21eb8:	d1c1      	bne.n	21e3e <ip_interface_open+0x7e>
   21eba:	250c      	movs	r5, #12
   21ebc:	e7de      	b.n	21e7c <ip_interface_open+0xbc>
   21ebe:	4627      	mov	r7, r4
   21ec0:	e798      	b.n	21df4 <ip_interface_open+0x34>
   21ec2:	f04f 33ff 	mov.w	r3, #4294967295
   21ec6:	f64f 72ff 	movw	r2, #65535	; 0xffff
   21eca:	2102      	movs	r1, #2
   21ecc:	4640      	mov	r0, r8
   21ece:	f001 fb63 	bl	23598 <interface_socket_wait>
   21ed2:	4605      	mov	r5, r0
   21ed4:	2800      	cmp	r0, #0
   21ed6:	d1d1      	bne.n	21e7c <ip_interface_open+0xbc>
   21ed8:	4640      	mov	r0, r8
   21eda:	f001 fbd1 	bl	23680 <interface_socket_from_handle_get>
   21ede:	b148      	cbz	r0, 21ef4 <ip_interface_open+0x134>
   21ee0:	6845      	ldr	r5, [r0, #4]
   21ee2:	b13d      	cbz	r5, 21ef4 <ip_interface_open+0x134>
   21ee4:	6046      	str	r6, [r0, #4]
   21ee6:	e7c9      	b.n	21e7c <ip_interface_open+0xbc>
   21ee8:	202f      	movs	r0, #47	; 0x2f
   21eea:	f7f9 fc3f 	bl	1b76c <bsd_os_errno_set>
   21eee:	f04f 38ff 	mov.w	r8, #4294967295
   21ef2:	e7cb      	b.n	21e8c <ip_interface_open+0xcc>
   21ef4:	3c02      	subs	r4, #2
   21ef6:	2c01      	cmp	r4, #1
   21ef8:	d8c8      	bhi.n	21e8c <ip_interface_open+0xcc>
   21efa:	4640      	mov	r0, r8
   21efc:	9b00      	ldr	r3, [sp, #0]
   21efe:	681a      	ldr	r2, [r3, #0]
   21f00:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   21f04:	601a      	str	r2, [r3, #0]
   21f06:	681a      	ldr	r2, [r3, #0]
   21f08:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
   21f0c:	601a      	str	r2, [r3, #0]
   21f0e:	b002      	add	sp, #8
   21f10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   21f14:	2016      	movs	r0, #22
   21f16:	f7f9 fc29 	bl	1b76c <bsd_os_errno_set>
   21f1a:	f04f 38ff 	mov.w	r8, #4294967295
   21f1e:	e7b5      	b.n	21e8c <ip_interface_open+0xcc>
   21f20:	00021cd5 	.word	0x00021cd5

00021f24 <ip_interface_close>:
   21f24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   21f28:	b082      	sub	sp, #8
   21f2a:	4606      	mov	r6, r0
   21f2c:	f001 fba8 	bl	23680 <interface_socket_from_handle_get>
   21f30:	2800      	cmp	r0, #0
   21f32:	d063      	beq.n	21ffc <ip_interface_close+0xd8>
   21f34:	4604      	mov	r4, r0
   21f36:	2100      	movs	r1, #0
   21f38:	a802      	add	r0, sp, #8
   21f3a:	6827      	ldr	r7, [r4, #0]
   21f3c:	f840 1d04 	str.w	r1, [r0, #-4]!
   21f40:	f8d4 8018 	ldr.w	r8, [r4, #24]
   21f44:	f7fc fab6 	bl	1e4b4 <rpc_ip_client_request_alloc>
   21f48:	2800      	cmp	r0, #0
   21f4a:	d13a      	bne.n	21fc2 <ip_interface_close+0x9e>
   21f4c:	f247 0309 	movw	r3, #28681	; 0x7009
   21f50:	2208      	movs	r2, #8
   21f52:	9d01      	ldr	r5, [sp, #4]
   21f54:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   21f58:	60eb      	str	r3, [r5, #12]
   21f5a:	f8c5 8010 	str.w	r8, [r5, #16]
   21f5e:	7268      	strb	r0, [r5, #9]
   21f60:	72a8      	strb	r0, [r5, #10]
   21f62:	72e8      	strb	r0, [r5, #11]
   21f64:	722a      	strb	r2, [r5, #8]
   21f66:	6823      	ldr	r3, [r4, #0]
   21f68:	f247 0109 	movw	r1, #28681	; 0x7009
   21f6c:	0c1b      	lsrs	r3, r3, #16
   21f6e:	041b      	lsls	r3, r3, #16
   21f70:	f043 030d 	orr.w	r3, r3, #13
   21f74:	6023      	str	r3, [r4, #0]
   21f76:	6823      	ldr	r3, [r4, #0]
   21f78:	4628      	mov	r0, r5
   21f7a:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   21f7e:	6023      	str	r3, [r4, #0]
   21f80:	6823      	ldr	r3, [r4, #0]
   21f82:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   21f86:	6023      	str	r3, [r4, #0]
   21f88:	f7fc faa8 	bl	1e4dc <rpc_ip_client_request_send>
   21f8c:	bb40      	cbnz	r0, 21fe0 <ip_interface_close+0xbc>
   21f8e:	f04f 33ff 	mov.w	r3, #4294967295
   21f92:	f64f 72ff 	movw	r2, #65535	; 0xffff
   21f96:	210e      	movs	r1, #14
   21f98:	4630      	mov	r0, r6
   21f9a:	f001 fafd 	bl	23598 <interface_socket_wait>
   21f9e:	4604      	mov	r4, r0
   21fa0:	b1a0      	cbz	r0, 21fcc <ip_interface_close+0xa8>
   21fa2:	4c17      	ldr	r4, [pc, #92]	; (22000 <ip_interface_close+0xdc>)
   21fa4:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
   21fa8:	b120      	cbz	r0, 21fb4 <ip_interface_close+0x90>
   21faa:	f7fc faad 	bl	1e508 <rpc_ip_client_message_free>
   21fae:	2300      	movs	r3, #0
   21fb0:	f844 3026 	str.w	r3, [r4, r6, lsl #2]
   21fb4:	4630      	mov	r0, r6
   21fb6:	f001 faa1 	bl	234fc <interface_socket_free>
   21fba:	2000      	movs	r0, #0
   21fbc:	b002      	add	sp, #8
   21fbe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   21fc2:	9d01      	ldr	r5, [sp, #4]
   21fc4:	200c      	movs	r0, #12
   21fc6:	2d00      	cmp	r5, #0
   21fc8:	d1cd      	bne.n	21f66 <ip_interface_close+0x42>
   21fca:	e012      	b.n	21ff2 <ip_interface_close+0xce>
   21fcc:	4630      	mov	r0, r6
   21fce:	f001 fb57 	bl	23680 <interface_socket_from_handle_get>
   21fd2:	2800      	cmp	r0, #0
   21fd4:	d0e5      	beq.n	21fa2 <ip_interface_close+0x7e>
   21fd6:	6843      	ldr	r3, [r0, #4]
   21fd8:	2b00      	cmp	r3, #0
   21fda:	d0e2      	beq.n	21fa2 <ip_interface_close+0x7e>
   21fdc:	6044      	str	r4, [r0, #4]
   21fde:	e7e0      	b.n	21fa2 <ip_interface_close+0x7e>
   21fe0:	6828      	ldr	r0, [r5, #0]
   21fe2:	b108      	cbz	r0, 21fe8 <ip_interface_close+0xc4>
   21fe4:	f7fc fa98 	bl	1e518 <rpc_ip_client_data_free>
   21fe8:	4628      	mov	r0, r5
   21fea:	f7fc fa8d 	bl	1e508 <rpc_ip_client_message_free>
   21fee:	2023      	movs	r0, #35	; 0x23
   21ff0:	6027      	str	r7, [r4, #0]
   21ff2:	f7f9 fbbb 	bl	1b76c <bsd_os_errno_set>
   21ff6:	f04f 30ff 	mov.w	r0, #4294967295
   21ffa:	e7df      	b.n	21fbc <ip_interface_close+0x98>
   21ffc:	2009      	movs	r0, #9
   21ffe:	e7f8      	b.n	21ff2 <ip_interface_close+0xce>
   22000:	20028eb0 	.word	0x20028eb0

00022004 <ip_interface_sendto>:
   22004:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   22008:	2400      	movs	r4, #0
   2200a:	b089      	sub	sp, #36	; 0x24
   2200c:	9102      	str	r1, [sp, #8]
   2200e:	4615      	mov	r5, r2
   22010:	4699      	mov	r9, r3
   22012:	9407      	str	r4, [sp, #28]
   22014:	4607      	mov	r7, r0
   22016:	9e12      	ldr	r6, [sp, #72]	; 0x48
   22018:	f001 fb32 	bl	23680 <interface_socket_from_handle_get>
   2201c:	2800      	cmp	r0, #0
   2201e:	f000 815f 	beq.w	222e0 <ip_interface_sendto+0x2dc>
   22022:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
   22026:	f300 814c 	bgt.w	222c2 <ip_interface_sendto+0x2be>
   2202a:	6903      	ldr	r3, [r0, #16]
   2202c:	4604      	mov	r4, r0
   2202e:	2b01      	cmp	r3, #1
   22030:	f000 80fb 	beq.w	2222a <ip_interface_sendto+0x226>
   22034:	6822      	ldr	r2, [r4, #0]
   22036:	0390      	lsls	r0, r2, #14
   22038:	d562      	bpl.n	22100 <ip_interface_sendto+0xfc>
   2203a:	f1b9 0f00 	cmp.w	r9, #0
   2203e:	f000 80fc 	beq.w	2223a <ip_interface_sendto+0x236>
   22042:	f019 0f02 	tst.w	r9, #2
   22046:	f000 8146 	beq.w	222d6 <ip_interface_sendto+0x2d2>
   2204a:	2300      	movs	r3, #0
   2204c:	9303      	str	r3, [sp, #12]
   2204e:	f247 0806 	movw	r8, #28678	; 0x7006
   22052:	f04f 0b0c 	mov.w	fp, #12
   22056:	4ba6      	ldr	r3, [pc, #664]	; (222f0 <ip_interface_sendto+0x2ec>)
   22058:	9300      	str	r3, [sp, #0]
   2205a:	043b      	lsls	r3, r7, #16
   2205c:	9304      	str	r3, [sp, #16]
   2205e:	4629      	mov	r1, r5
   22060:	a807      	add	r0, sp, #28
   22062:	f7fc fa27 	bl	1e4b4 <rpc_ip_client_request_alloc>
   22066:	2804      	cmp	r0, #4
   22068:	d063      	beq.n	22132 <ip_interface_sendto+0x12e>
   2206a:	2800      	cmp	r0, #0
   2206c:	f040 813d 	bne.w	222ea <ip_interface_sendto+0x2e6>
   22070:	9b07      	ldr	r3, [sp, #28]
   22072:	f883 b008 	strb.w	fp, [r3, #8]
   22076:	7258      	strb	r0, [r3, #9]
   22078:	7298      	strb	r0, [r3, #10]
   2207a:	72d8      	strb	r0, [r3, #11]
   2207c:	2e00      	cmp	r6, #0
   2207e:	d074      	beq.n	2216a <ip_interface_sendto+0x166>
   22080:	68e2      	ldr	r2, [r4, #12]
   22082:	6871      	ldr	r1, [r6, #4]
   22084:	428a      	cmp	r2, r1
   22086:	f040 80a2 	bne.w	221ce <ip_interface_sendto+0x1ca>
   2208a:	7831      	ldrb	r1, [r6, #0]
   2208c:	9813      	ldr	r0, [sp, #76]	; 0x4c
   2208e:	4288      	cmp	r0, r1
   22090:	d10a      	bne.n	220a8 <ip_interface_sendto+0xa4>
   22092:	2a02      	cmp	r2, #2
   22094:	f103 001c 	add.w	r0, r3, #28
   22098:	f000 8101 	beq.w	2229e <ip_interface_sendto+0x29a>
   2209c:	2a0a      	cmp	r2, #10
   2209e:	d103      	bne.n	220a8 <ip_interface_sendto+0xa4>
   220a0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   220a2:	2a24      	cmp	r2, #36	; 0x24
   220a4:	f000 80e8 	beq.w	22278 <ip_interface_sendto+0x274>
   220a8:	f04f 0a16 	mov.w	sl, #22
   220ac:	6818      	ldr	r0, [r3, #0]
   220ae:	b110      	cbz	r0, 220b6 <ip_interface_sendto+0xb2>
   220b0:	f7fc fa32 	bl	1e518 <rpc_ip_client_data_free>
   220b4:	9b07      	ldr	r3, [sp, #28]
   220b6:	4618      	mov	r0, r3
   220b8:	f7fc fa26 	bl	1e508 <rpc_ip_client_message_free>
   220bc:	6823      	ldr	r3, [r4, #0]
   220be:	031a      	lsls	r2, r3, #12
   220c0:	d43f      	bmi.n	22142 <ip_interface_sendto+0x13e>
   220c2:	6823      	ldr	r3, [r4, #0]
   220c4:	b29b      	uxth	r3, r3
   220c6:	2b0d      	cmp	r3, #13
   220c8:	d007      	beq.n	220da <ip_interface_sendto+0xd6>
   220ca:	6823      	ldr	r3, [r4, #0]
   220cc:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   220d0:	6023      	str	r3, [r4, #0]
   220d2:	6823      	ldr	r3, [r4, #0]
   220d4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   220d8:	6023      	str	r3, [r4, #0]
   220da:	f1ba 0f00 	cmp.w	sl, #0
   220de:	d130      	bne.n	22142 <ip_interface_sendto+0x13e>
   220e0:	6823      	ldr	r3, [r4, #0]
   220e2:	0118      	lsls	r0, r3, #4
   220e4:	d576      	bpl.n	221d4 <ip_interface_sendto+0x1d0>
   220e6:	6823      	ldr	r3, [r4, #0]
   220e8:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
   220ec:	6023      	str	r3, [r4, #0]
   220ee:	9b00      	ldr	r3, [sp, #0]
   220f0:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   220f4:	2800      	cmp	r0, #0
   220f6:	d12e      	bne.n	22156 <ip_interface_sendto+0x152>
   220f8:	4628      	mov	r0, r5
   220fa:	b009      	add	sp, #36	; 0x24
   220fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   22100:	6822      	ldr	r2, [r4, #0]
   22102:	0091      	lsls	r1, r2, #2
   22104:	d406      	bmi.n	22114 <ip_interface_sendto+0x110>
   22106:	2b01      	cmp	r3, #1
   22108:	f000 80b0 	beq.w	2226c <ip_interface_sendto+0x268>
   2210c:	6823      	ldr	r3, [r4, #0]
   2210e:	031a      	lsls	r2, r3, #12
   22110:	f140 80d2 	bpl.w	222b8 <ip_interface_sendto+0x2b4>
   22114:	6823      	ldr	r3, [r4, #0]
   22116:	031b      	lsls	r3, r3, #12
   22118:	f140 80d8 	bpl.w	222cc <ip_interface_sendto+0x2c8>
   2211c:	4b74      	ldr	r3, [pc, #464]	; (222f0 <ip_interface_sendto+0x2ec>)
   2211e:	f8d4 a008 	ldr.w	sl, [r4, #8]
   22122:	9300      	str	r3, [sp, #0]
   22124:	e7d9      	b.n	220da <ip_interface_sendto+0xd6>
   22126:	9b00      	ldr	r3, [sp, #0]
   22128:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   2212c:	b108      	cbz	r0, 22132 <ip_interface_sendto+0x12e>
   2212e:	f7fc f9eb 	bl	1e508 <rpc_ip_client_message_free>
   22132:	9b03      	ldr	r3, [sp, #12]
   22134:	2b00      	cmp	r3, #0
   22136:	d192      	bne.n	2205e <ip_interface_sendto+0x5a>
   22138:	6823      	ldr	r3, [r4, #0]
   2213a:	f04f 0a23 	mov.w	sl, #35	; 0x23
   2213e:	031a      	lsls	r2, r3, #12
   22140:	d5bf      	bpl.n	220c2 <ip_interface_sendto+0xbe>
   22142:	4650      	mov	r0, sl
   22144:	f7f9 fb12 	bl	1b76c <bsd_os_errno_set>
   22148:	9b00      	ldr	r3, [sp, #0]
   2214a:	f04f 35ff 	mov.w	r5, #4294967295
   2214e:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   22152:	2800      	cmp	r0, #0
   22154:	d0d0      	beq.n	220f8 <ip_interface_sendto+0xf4>
   22156:	f7fc f9d7 	bl	1e508 <rpc_ip_client_message_free>
   2215a:	2300      	movs	r3, #0
   2215c:	9a00      	ldr	r2, [sp, #0]
   2215e:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
   22162:	4628      	mov	r0, r5
   22164:	b009      	add	sp, #36	; 0x24
   22166:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2216a:	4642      	mov	r2, r8
   2216c:	f8c3 9014 	str.w	r9, [r3, #20]
   22170:	69a1      	ldr	r1, [r4, #24]
   22172:	9804      	ldr	r0, [sp, #16]
   22174:	6119      	str	r1, [r3, #16]
   22176:	9902      	ldr	r1, [sp, #8]
   22178:	4302      	orrs	r2, r0
   2217a:	60da      	str	r2, [r3, #12]
   2217c:	605d      	str	r5, [r3, #4]
   2217e:	b119      	cbz	r1, 22188 <ip_interface_sendto+0x184>
   22180:	6818      	ldr	r0, [r3, #0]
   22182:	462a      	mov	r2, r5
   22184:	f00d f8e6 	bl	2f354 <memcpy>
   22188:	6823      	ldr	r3, [r4, #0]
   2218a:	4641      	mov	r1, r8
   2218c:	9305      	str	r3, [sp, #20]
   2218e:	6823      	ldr	r3, [r4, #0]
   22190:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   22194:	6023      	str	r3, [r4, #0]
   22196:	6823      	ldr	r3, [r4, #0]
   22198:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
   2219c:	6023      	str	r3, [r4, #0]
   2219e:	9b07      	ldr	r3, [sp, #28]
   221a0:	4618      	mov	r0, r3
   221a2:	9301      	str	r3, [sp, #4]
   221a4:	f7fc f99a 	bl	1e4dc <rpc_ip_client_request_send>
   221a8:	9b01      	ldr	r3, [sp, #4]
   221aa:	4682      	mov	sl, r0
   221ac:	b9e8      	cbnz	r0, 221ea <ip_interface_sendto+0x1e6>
   221ae:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   221b2:	f04f 33ff 	mov.w	r3, #4294967295
   221b6:	4611      	mov	r1, r2
   221b8:	4638      	mov	r0, r7
   221ba:	f001 f9ed 	bl	23598 <interface_socket_wait>
   221be:	b308      	cbz	r0, 22204 <ip_interface_sendto+0x200>
   221c0:	6823      	ldr	r3, [r4, #0]
   221c2:	0319      	lsls	r1, r3, #12
   221c4:	d42a      	bmi.n	2221c <ip_interface_sendto+0x218>
   221c6:	280c      	cmp	r0, #12
   221c8:	d0ad      	beq.n	22126 <ip_interface_sendto+0x122>
   221ca:	4682      	mov	sl, r0
   221cc:	e776      	b.n	220bc <ip_interface_sendto+0xb8>
   221ce:	f04f 0a2f 	mov.w	sl, #47	; 0x2f
   221d2:	e76b      	b.n	220ac <ip_interface_sendto+0xa8>
   221d4:	9b00      	ldr	r3, [sp, #0]
   221d6:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   221da:	6985      	ldr	r5, [r0, #24]
   221dc:	f7fc f994 	bl	1e508 <rpc_ip_client_message_free>
   221e0:	2300      	movs	r3, #0
   221e2:	9a00      	ldr	r2, [sp, #0]
   221e4:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
   221e8:	e7bb      	b.n	22162 <ip_interface_sendto+0x15e>
   221ea:	6818      	ldr	r0, [r3, #0]
   221ec:	469a      	mov	sl, r3
   221ee:	b108      	cbz	r0, 221f4 <ip_interface_sendto+0x1f0>
   221f0:	f7fc f992 	bl	1e518 <rpc_ip_client_data_free>
   221f4:	4650      	mov	r0, sl
   221f6:	f7fc f987 	bl	1e508 <rpc_ip_client_message_free>
   221fa:	9b05      	ldr	r3, [sp, #20]
   221fc:	f04f 0a23 	mov.w	sl, #35	; 0x23
   22200:	6023      	str	r3, [r4, #0]
   22202:	e75b      	b.n	220bc <ip_interface_sendto+0xb8>
   22204:	4638      	mov	r0, r7
   22206:	f001 fa3b 	bl	23680 <interface_socket_from_handle_get>
   2220a:	4603      	mov	r3, r0
   2220c:	b1e0      	cbz	r0, 22248 <ip_interface_sendto+0x244>
   2220e:	6840      	ldr	r0, [r0, #4]
   22210:	b1d0      	cbz	r0, 22248 <ip_interface_sendto+0x244>
   22212:	f8c3 a004 	str.w	sl, [r3, #4]
   22216:	6823      	ldr	r3, [r4, #0]
   22218:	0319      	lsls	r1, r3, #12
   2221a:	d5d4      	bpl.n	221c6 <ip_interface_sendto+0x1c2>
   2221c:	f8d4 a008 	ldr.w	sl, [r4, #8]
   22220:	6823      	ldr	r3, [r4, #0]
   22222:	031e      	lsls	r6, r3, #12
   22224:	f57f af4d 	bpl.w	220c2 <ip_interface_sendto+0xbe>
   22228:	e757      	b.n	220da <ip_interface_sendto+0xd6>
   2222a:	2e00      	cmp	r6, #0
   2222c:	f43f af02 	beq.w	22034 <ip_interface_sendto+0x30>
   22230:	4b2f      	ldr	r3, [pc, #188]	; (222f0 <ip_interface_sendto+0x2ec>)
   22232:	f04f 0a38 	mov.w	sl, #56	; 0x38
   22236:	9300      	str	r3, [sp, #0]
   22238:	e783      	b.n	22142 <ip_interface_sendto+0x13e>
   2223a:	6823      	ldr	r3, [r4, #0]
   2223c:	f083 5380 	eor.w	r3, r3, #268435456	; 0x10000000
   22240:	f3c3 7300 	ubfx	r3, r3, #28, #1
   22244:	9303      	str	r3, [sp, #12]
   22246:	e702      	b.n	2204e <ip_interface_sendto+0x4a>
   22248:	6823      	ldr	r3, [r4, #0]
   2224a:	031b      	lsls	r3, r3, #12
   2224c:	f53f af48 	bmi.w	220e0 <ip_interface_sendto+0xdc>
   22250:	6823      	ldr	r3, [r4, #0]
   22252:	b29b      	uxth	r3, r3
   22254:	2b0d      	cmp	r3, #13
   22256:	f43f af43 	beq.w	220e0 <ip_interface_sendto+0xdc>
   2225a:	6823      	ldr	r3, [r4, #0]
   2225c:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   22260:	6023      	str	r3, [r4, #0]
   22262:	6823      	ldr	r3, [r4, #0]
   22264:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   22268:	6023      	str	r3, [r4, #0]
   2226a:	e739      	b.n	220e0 <ip_interface_sendto+0xdc>
   2226c:	6823      	ldr	r3, [r4, #0]
   2226e:	b29b      	uxth	r3, r3
   22270:	2b05      	cmp	r3, #5
   22272:	f47f af4f 	bne.w	22114 <ip_interface_sendto+0x110>
   22276:	e749      	b.n	2210c <ip_interface_sendto+0x108>
   22278:	2210      	movs	r2, #16
   2227a:	8931      	ldrh	r1, [r6, #8]
   2227c:	835a      	strh	r2, [r3, #26]
   2227e:	8319      	strh	r1, [r3, #24]
   22280:	18b1      	adds	r1, r6, r2
   22282:	f00d f867 	bl	2f354 <memcpy>
   22286:	f247 0207 	movw	r2, #28679	; 0x7007
   2228a:	9b07      	ldr	r3, [sp, #28]
   2228c:	4690      	mov	r8, r2
   2228e:	6899      	ldr	r1, [r3, #8]
   22290:	8b58      	ldrh	r0, [r3, #26]
   22292:	3104      	adds	r1, #4
   22294:	4401      	add	r1, r0
   22296:	f8c3 9014 	str.w	r9, [r3, #20]
   2229a:	6099      	str	r1, [r3, #8]
   2229c:	e768      	b.n	22170 <ip_interface_sendto+0x16c>
   2229e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   222a0:	2a10      	cmp	r2, #16
   222a2:	f47f af01 	bne.w	220a8 <ip_interface_sendto+0xa4>
   222a6:	2204      	movs	r2, #4
   222a8:	8931      	ldrh	r1, [r6, #8]
   222aa:	835a      	strh	r2, [r3, #26]
   222ac:	8319      	strh	r1, [r3, #24]
   222ae:	f106 010c 	add.w	r1, r6, #12
   222b2:	f00d f84f 	bl	2f354 <memcpy>
   222b6:	e7e6      	b.n	22286 <ip_interface_sendto+0x282>
   222b8:	4b0d      	ldr	r3, [pc, #52]	; (222f0 <ip_interface_sendto+0x2ec>)
   222ba:	f04f 0a23 	mov.w	sl, #35	; 0x23
   222be:	9300      	str	r3, [sp, #0]
   222c0:	e73f      	b.n	22142 <ip_interface_sendto+0x13e>
   222c2:	4b0b      	ldr	r3, [pc, #44]	; (222f0 <ip_interface_sendto+0x2ec>)
   222c4:	f04f 0a28 	mov.w	sl, #40	; 0x28
   222c8:	9300      	str	r3, [sp, #0]
   222ca:	e73a      	b.n	22142 <ip_interface_sendto+0x13e>
   222cc:	4b08      	ldr	r3, [pc, #32]	; (222f0 <ip_interface_sendto+0x2ec>)
   222ce:	f04f 0a39 	mov.w	sl, #57	; 0x39
   222d2:	9300      	str	r3, [sp, #0]
   222d4:	e735      	b.n	22142 <ip_interface_sendto+0x13e>
   222d6:	4b06      	ldr	r3, [pc, #24]	; (222f0 <ip_interface_sendto+0x2ec>)
   222d8:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
   222dc:	9300      	str	r3, [sp, #0]
   222de:	e730      	b.n	22142 <ip_interface_sendto+0x13e>
   222e0:	4b03      	ldr	r3, [pc, #12]	; (222f0 <ip_interface_sendto+0x2ec>)
   222e2:	f04f 0a09 	mov.w	sl, #9
   222e6:	9300      	str	r3, [sp, #0]
   222e8:	e72b      	b.n	22142 <ip_interface_sendto+0x13e>
   222ea:	f04f 0a0c 	mov.w	sl, #12
   222ee:	e6e5      	b.n	220bc <ip_interface_sendto+0xb8>
   222f0:	20028eb0 	.word	0x20028eb0

000222f4 <ip_interface_recvfrom>:
   222f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   222f8:	b085      	sub	sp, #20
   222fa:	2a00      	cmp	r2, #0
   222fc:	f000 811b 	beq.w	22536 <ip_interface_recvfrom+0x242>
   22300:	4605      	mov	r5, r0
   22302:	468a      	mov	sl, r1
   22304:	4698      	mov	r8, r3
   22306:	4617      	mov	r7, r2
   22308:	b11b      	cbz	r3, 22312 <ip_interface_recvfrom+0x1e>
   2230a:	f013 0f1a 	tst.w	r3, #26
   2230e:	f000 810f 	beq.w	22530 <ip_interface_recvfrom+0x23c>
   22312:	4628      	mov	r0, r5
   22314:	f001 f9b4 	bl	23680 <interface_socket_from_handle_get>
   22318:	4604      	mov	r4, r0
   2231a:	2800      	cmp	r0, #0
   2231c:	f000 810e 	beq.w	2253c <ip_interface_recvfrom+0x248>
   22320:	6803      	ldr	r3, [r0, #0]
   22322:	02d9      	lsls	r1, r3, #11
   22324:	d564      	bpl.n	223f0 <ip_interface_recvfrom+0xfc>
   22326:	f018 0f02 	tst.w	r8, #2
   2232a:	bf18      	it	ne
   2232c:	f04f 0900 	movne.w	r9, #0
   22330:	f04f 3bff 	mov.w	fp, #4294967295
   22334:	bf08      	it	eq
   22336:	6803      	ldreq	r3, [r0, #0]
   22338:	f008 0610 	and.w	r6, r8, #16
   2233c:	bf04      	itt	eq
   2233e:	f083 5980 	eoreq.w	r9, r3, #268435456	; 0x10000000
   22342:	f3c9 7900 	ubfxeq	r9, r9, #28, #1
   22346:	6823      	ldr	r3, [r4, #0]
   22348:	03da      	lsls	r2, r3, #15
   2234a:	d56c      	bpl.n	22426 <ip_interface_recvfrom+0x132>
   2234c:	6823      	ldr	r3, [r4, #0]
   2234e:	69e0      	ldr	r0, [r4, #28]
   22350:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   22354:	6023      	str	r3, [r4, #0]
   22356:	6803      	ldr	r3, [r0, #0]
   22358:	68db      	ldr	r3, [r3, #12]
   2235a:	4798      	blx	r3
   2235c:	f1b0 3fff 	cmp.w	r0, #4294967295
   22360:	4683      	mov	fp, r0
   22362:	d07f      	beq.n	22464 <ip_interface_recvfrom+0x170>
   22364:	4287      	cmp	r7, r0
   22366:	dd03      	ble.n	22370 <ip_interface_recvfrom+0x7c>
   22368:	6923      	ldr	r3, [r4, #16]
   2236a:	2b01      	cmp	r3, #1
   2236c:	f000 80a6 	beq.w	224bc <ip_interface_recvfrom+0x1c8>
   22370:	2600      	movs	r6, #0
   22372:	69e0      	ldr	r0, [r4, #28]
   22374:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   22376:	b103      	cbz	r3, 2237a <ip_interface_recvfrom+0x86>
   22378:	681b      	ldr	r3, [r3, #0]
   2237a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   2237c:	e9cd a700 	strd	sl, r7, [sp]
   22380:	e9cd 2302 	strd	r2, r3, [sp, #8]
   22384:	6803      	ldr	r3, [r0, #0]
   22386:	4642      	mov	r2, r8
   22388:	689b      	ldr	r3, [r3, #8]
   2238a:	4669      	mov	r1, sp
   2238c:	4798      	blx	r3
   2238e:	4683      	mov	fp, r0
   22390:	69e0      	ldr	r0, [r4, #28]
   22392:	f1bb 3fff 	cmp.w	fp, #4294967295
   22396:	6803      	ldr	r3, [r0, #0]
   22398:	bf18      	it	ne
   2239a:	2501      	movne	r5, #1
   2239c:	68db      	ldr	r3, [r3, #12]
   2239e:	bf0a      	itet	eq
   223a0:	2500      	moveq	r5, #0
   223a2:	f04f 0900 	movne.w	r9, #0
   223a6:	f04f 0923 	moveq.w	r9, #35	; 0x23
   223aa:	4798      	blx	r3
   223ac:	3001      	adds	r0, #1
   223ae:	d135      	bne.n	2241c <ip_interface_recvfrom+0x128>
   223b0:	2e00      	cmp	r6, #0
   223b2:	f000 80b5 	beq.w	22520 <ip_interface_recvfrom+0x22c>
   223b6:	2d00      	cmp	r5, #0
   223b8:	f000 80a5 	beq.w	22506 <ip_interface_recvfrom+0x212>
   223bc:	6823      	ldr	r3, [r4, #0]
   223be:	0319      	lsls	r1, r3, #12
   223c0:	d506      	bpl.n	223d0 <ip_interface_recvfrom+0xdc>
   223c2:	6823      	ldr	r3, [r4, #0]
   223c4:	b29b      	uxth	r3, r3
   223c6:	2b0d      	cmp	r3, #13
   223c8:	d002      	beq.n	223d0 <ip_interface_recvfrom+0xdc>
   223ca:	6923      	ldr	r3, [r4, #16]
   223cc:	2b01      	cmp	r3, #1
   223ce:	d025      	beq.n	2241c <ip_interface_recvfrom+0x128>
   223d0:	6823      	ldr	r3, [r4, #0]
   223d2:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
   223d6:	6823      	ldr	r3, [r4, #0]
   223d8:	f040 80b3 	bne.w	22542 <ip_interface_recvfrom+0x24e>
   223dc:	031a      	lsls	r2, r3, #12
   223de:	d474      	bmi.n	224ca <ip_interface_recvfrom+0x1d6>
   223e0:	f1b9 0f00 	cmp.w	r9, #0
   223e4:	f040 8089 	bne.w	224fa <ip_interface_recvfrom+0x206>
   223e8:	4658      	mov	r0, fp
   223ea:	b005      	add	sp, #20
   223ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   223f0:	6803      	ldr	r3, [r0, #0]
   223f2:	b29b      	uxth	r3, r3
   223f4:	2b06      	cmp	r3, #6
   223f6:	d072      	beq.n	224de <ip_interface_recvfrom+0x1ea>
   223f8:	6803      	ldr	r3, [r0, #0]
   223fa:	b29b      	uxth	r3, r3
   223fc:	2b07      	cmp	r3, #7
   223fe:	bf0c      	ite	eq
   22400:	f04f 0909 	moveq.w	r9, #9
   22404:	f04f 0939 	movne.w	r9, #57	; 0x39
   22408:	69e0      	ldr	r0, [r4, #28]
   2240a:	6803      	ldr	r3, [r0, #0]
   2240c:	68db      	ldr	r3, [r3, #12]
   2240e:	4798      	blx	r3
   22410:	f1b0 3fff 	cmp.w	r0, #4294967295
   22414:	4683      	mov	fp, r0
   22416:	d0db      	beq.n	223d0 <ip_interface_recvfrom+0xdc>
   22418:	f04f 3bff 	mov.w	fp, #4294967295
   2241c:	6823      	ldr	r3, [r4, #0]
   2241e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   22422:	6023      	str	r3, [r4, #0]
   22424:	e7dc      	b.n	223e0 <ip_interface_recvfrom+0xec>
   22426:	f1b9 0f00 	cmp.w	r9, #0
   2242a:	d07d      	beq.n	22528 <ip_interface_recvfrom+0x234>
   2242c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   22430:	6a23      	ldr	r3, [r4, #32]
   22432:	4611      	mov	r1, r2
   22434:	2b00      	cmp	r3, #0
   22436:	bf08      	it	eq
   22438:	f04f 33ff 	moveq.w	r3, #4294967295
   2243c:	4628      	mov	r0, r5
   2243e:	f001 f8ab 	bl	23598 <interface_socket_wait>
   22442:	4681      	mov	r9, r0
   22444:	b358      	cbz	r0, 2249e <ip_interface_recvfrom+0x1aa>
   22446:	6823      	ldr	r3, [r4, #0]
   22448:	69e0      	ldr	r0, [r4, #28]
   2244a:	031b      	lsls	r3, r3, #12
   2244c:	d521      	bpl.n	22492 <ip_interface_recvfrom+0x19e>
   2244e:	6823      	ldr	r3, [r4, #0]
   22450:	b29b      	uxth	r3, r3
   22452:	2b0d      	cmp	r3, #13
   22454:	d01d      	beq.n	22492 <ip_interface_recvfrom+0x19e>
   22456:	6926      	ldr	r6, [r4, #16]
   22458:	f1a6 0601 	sub.w	r6, r6, #1
   2245c:	fab6 f686 	clz	r6, r6
   22460:	0976      	lsrs	r6, r6, #5
   22462:	e787      	b.n	22374 <ip_interface_recvfrom+0x80>
   22464:	6823      	ldr	r3, [r4, #0]
   22466:	0318      	lsls	r0, r3, #12
   22468:	d5dd      	bpl.n	22426 <ip_interface_recvfrom+0x132>
   2246a:	6823      	ldr	r3, [r4, #0]
   2246c:	b29b      	uxth	r3, r3
   2246e:	2b0d      	cmp	r3, #13
   22470:	d0d9      	beq.n	22426 <ip_interface_recvfrom+0x132>
   22472:	6923      	ldr	r3, [r4, #16]
   22474:	69e0      	ldr	r0, [r4, #28]
   22476:	2b01      	cmp	r3, #1
   22478:	d034      	beq.n	224e4 <ip_interface_recvfrom+0x1f0>
   2247a:	f04f 0939 	mov.w	r9, #57	; 0x39
   2247e:	6823      	ldr	r3, [r4, #0]
   22480:	0c1b      	lsrs	r3, r3, #16
   22482:	041b      	lsls	r3, r3, #16
   22484:	f043 030d 	orr.w	r3, r3, #13
   22488:	6023      	str	r3, [r4, #0]
   2248a:	6823      	ldr	r3, [r4, #0]
   2248c:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   22490:	6023      	str	r3, [r4, #0]
   22492:	6803      	ldr	r3, [r0, #0]
   22494:	68db      	ldr	r3, [r3, #12]
   22496:	4798      	blx	r3
   22498:	3001      	adds	r0, #1
   2249a:	d1bf      	bne.n	2241c <ip_interface_recvfrom+0x128>
   2249c:	e798      	b.n	223d0 <ip_interface_recvfrom+0xdc>
   2249e:	4628      	mov	r0, r5
   224a0:	f001 f8ee 	bl	23680 <interface_socket_from_handle_get>
   224a4:	b138      	cbz	r0, 224b6 <ip_interface_recvfrom+0x1c2>
   224a6:	f8d0 9004 	ldr.w	r9, [r0, #4]
   224aa:	f1b9 0f00 	cmp.w	r9, #0
   224ae:	d002      	beq.n	224b6 <ip_interface_recvfrom+0x1c2>
   224b0:	2300      	movs	r3, #0
   224b2:	6043      	str	r3, [r0, #4]
   224b4:	e7c7      	b.n	22446 <ip_interface_recvfrom+0x152>
   224b6:	f04f 0901 	mov.w	r9, #1
   224ba:	e744      	b.n	22346 <ip_interface_recvfrom+0x52>
   224bc:	b11e      	cbz	r6, 224c6 <ip_interface_recvfrom+0x1d2>
   224be:	6823      	ldr	r3, [r4, #0]
   224c0:	00db      	lsls	r3, r3, #3
   224c2:	d5b3      	bpl.n	2242c <ip_interface_recvfrom+0x138>
   224c4:	e754      	b.n	22370 <ip_interface_recvfrom+0x7c>
   224c6:	69e0      	ldr	r0, [r4, #28]
   224c8:	e754      	b.n	22374 <ip_interface_recvfrom+0x80>
   224ca:	6823      	ldr	r3, [r4, #0]
   224cc:	b29b      	uxth	r3, r3
   224ce:	2b0d      	cmp	r3, #13
   224d0:	d186      	bne.n	223e0 <ip_interface_recvfrom+0xec>
   224d2:	68a3      	ldr	r3, [r4, #8]
   224d4:	2b00      	cmp	r3, #0
   224d6:	d083      	beq.n	223e0 <ip_interface_recvfrom+0xec>
   224d8:	f8d4 9008 	ldr.w	r9, [r4, #8]
   224dc:	e780      	b.n	223e0 <ip_interface_recvfrom+0xec>
   224de:	f04f 0909 	mov.w	r9, #9
   224e2:	e791      	b.n	22408 <ip_interface_recvfrom+0x114>
   224e4:	6803      	ldr	r3, [r0, #0]
   224e6:	68db      	ldr	r3, [r3, #12]
   224e8:	4798      	blx	r3
   224ea:	3001      	adds	r0, #1
   224ec:	d00b      	beq.n	22506 <ip_interface_recvfrom+0x212>
   224ee:	f04f 0923 	mov.w	r9, #35	; 0x23
   224f2:	6823      	ldr	r3, [r4, #0]
   224f4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   224f8:	6023      	str	r3, [r4, #0]
   224fa:	4648      	mov	r0, r9
   224fc:	f7f9 f936 	bl	1b76c <bsd_os_errno_set>
   22500:	f04f 3bff 	mov.w	fp, #4294967295
   22504:	e770      	b.n	223e8 <ip_interface_recvfrom+0xf4>
   22506:	6823      	ldr	r3, [r4, #0]
   22508:	f04f 0b00 	mov.w	fp, #0
   2250c:	0c1b      	lsrs	r3, r3, #16
   2250e:	041b      	lsls	r3, r3, #16
   22510:	f043 030d 	orr.w	r3, r3, #13
   22514:	6023      	str	r3, [r4, #0]
   22516:	6823      	ldr	r3, [r4, #0]
   22518:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   2251c:	6023      	str	r3, [r4, #0]
   2251e:	e763      	b.n	223e8 <ip_interface_recvfrom+0xf4>
   22520:	2d00      	cmp	r5, #0
   22522:	f47f af4b 	bne.w	223bc <ip_interface_recvfrom+0xc8>
   22526:	e753      	b.n	223d0 <ip_interface_recvfrom+0xdc>
   22528:	f04f 0923 	mov.w	r9, #35	; 0x23
   2252c:	69e0      	ldr	r0, [r4, #28]
   2252e:	e7b0      	b.n	22492 <ip_interface_recvfrom+0x19e>
   22530:	f04f 092d 	mov.w	r9, #45	; 0x2d
   22534:	e7e1      	b.n	224fa <ip_interface_recvfrom+0x206>
   22536:	f04f 0916 	mov.w	r9, #22
   2253a:	e7de      	b.n	224fa <ip_interface_recvfrom+0x206>
   2253c:	f04f 0909 	mov.w	r9, #9
   22540:	e7db      	b.n	224fa <ip_interface_recvfrom+0x206>
   22542:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
   22546:	6023      	str	r3, [r4, #0]
   22548:	6823      	ldr	r3, [r4, #0]
   2254a:	f04f 0969 	mov.w	r9, #105	; 0x69
   2254e:	0c1b      	lsrs	r3, r3, #16
   22550:	041b      	lsls	r3, r3, #16
   22552:	f043 030d 	orr.w	r3, r3, #13
   22556:	6023      	str	r3, [r4, #0]
   22558:	e7cf      	b.n	224fa <ip_interface_recvfrom+0x206>
   2255a:	bf00      	nop

0002255c <ip_interface_connect>:
   2255c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   22560:	b083      	sub	sp, #12
   22562:	2900      	cmp	r1, #0
   22564:	d049      	beq.n	225fa <ip_interface_connect+0x9e>
   22566:	4616      	mov	r6, r2
   22568:	2a00      	cmp	r2, #0
   2256a:	d046      	beq.n	225fa <ip_interface_connect+0x9e>
   2256c:	4607      	mov	r7, r0
   2256e:	4688      	mov	r8, r1
   22570:	f001 f886 	bl	23680 <interface_socket_from_handle_get>
   22574:	4605      	mov	r5, r0
   22576:	2800      	cmp	r0, #0
   22578:	f000 80a8 	beq.w	226cc <ip_interface_connect+0x170>
   2257c:	6803      	ldr	r3, [r0, #0]
   2257e:	b29b      	uxth	r3, r3
   22580:	2b02      	cmp	r3, #2
   22582:	d004      	beq.n	2258e <ip_interface_connect+0x32>
   22584:	6803      	ldr	r3, [r0, #0]
   22586:	b29b      	uxth	r3, r3
   22588:	2b04      	cmp	r3, #4
   2258a:	f040 808b 	bne.w	226a4 <ip_interface_connect+0x148>
   2258e:	6829      	ldr	r1, [r5, #0]
   22590:	f011 5100 	ands.w	r1, r1, #536870912	; 0x20000000
   22594:	f040 8082 	bne.w	2269c <ip_interface_connect+0x140>
   22598:	a802      	add	r0, sp, #8
   2259a:	f840 1d04 	str.w	r1, [r0, #-4]!
   2259e:	f8d5 9018 	ldr.w	r9, [r5, #24]
   225a2:	f7fb ff87 	bl	1e4b4 <rpc_ip_client_request_alloc>
   225a6:	bb90      	cbnz	r0, 2260e <ip_interface_connect+0xb2>
   225a8:	2108      	movs	r1, #8
   225aa:	043b      	lsls	r3, r7, #16
   225ac:	9c01      	ldr	r4, [sp, #4]
   225ae:	f443 42e0 	orr.w	r2, r3, #28672	; 0x7000
   225b2:	f042 0202 	orr.w	r2, r2, #2
   225b6:	60e2      	str	r2, [r4, #12]
   225b8:	f8c4 9010 	str.w	r9, [r4, #16]
   225bc:	7260      	strb	r0, [r4, #9]
   225be:	72a0      	strb	r0, [r4, #10]
   225c0:	72e0      	strb	r0, [r4, #11]
   225c2:	7221      	strb	r1, [r4, #8]
   225c4:	f443 43e0 	orr.w	r3, r3, #28672	; 0x7000
   225c8:	f043 0302 	orr.w	r3, r3, #2
   225cc:	60e3      	str	r3, [r4, #12]
   225ce:	68a3      	ldr	r3, [r4, #8]
   225d0:	69aa      	ldr	r2, [r5, #24]
   225d2:	3304      	adds	r3, #4
   225d4:	6122      	str	r2, [r4, #16]
   225d6:	60a3      	str	r3, [r4, #8]
   225d8:	68eb      	ldr	r3, [r5, #12]
   225da:	f8d8 2004 	ldr.w	r2, [r8, #4]
   225de:	4293      	cmp	r3, r2
   225e0:	d11a      	bne.n	22618 <ip_interface_connect+0xbc>
   225e2:	f898 2000 	ldrb.w	r2, [r8]
   225e6:	4296      	cmp	r6, r2
   225e8:	d107      	bne.n	225fa <ip_interface_connect+0x9e>
   225ea:	2b02      	cmp	r3, #2
   225ec:	f104 0018 	add.w	r0, r4, #24
   225f0:	d014      	beq.n	2261c <ip_interface_connect+0xc0>
   225f2:	2b0a      	cmp	r3, #10
   225f4:	d101      	bne.n	225fa <ip_interface_connect+0x9e>
   225f6:	2e24      	cmp	r6, #36	; 0x24
   225f8:	d01c      	beq.n	22634 <ip_interface_connect+0xd8>
   225fa:	2416      	movs	r4, #22
   225fc:	4620      	mov	r0, r4
   225fe:	f7f9 f8b5 	bl	1b76c <bsd_os_errno_set>
   22602:	f04f 34ff 	mov.w	r4, #4294967295
   22606:	4620      	mov	r0, r4
   22608:	b003      	add	sp, #12
   2260a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2260e:	9c01      	ldr	r4, [sp, #4]
   22610:	2c00      	cmp	r4, #0
   22612:	d059      	beq.n	226c8 <ip_interface_connect+0x16c>
   22614:	043b      	lsls	r3, r7, #16
   22616:	e7d5      	b.n	225c4 <ip_interface_connect+0x68>
   22618:	242f      	movs	r4, #47	; 0x2f
   2261a:	e7ef      	b.n	225fc <ip_interface_connect+0xa0>
   2261c:	2e10      	cmp	r6, #16
   2261e:	d1ec      	bne.n	225fa <ip_interface_connect+0x9e>
   22620:	2204      	movs	r2, #4
   22622:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   22626:	f108 010c 	add.w	r1, r8, #12
   2262a:	82e2      	strh	r2, [r4, #22]
   2262c:	82a3      	strh	r3, [r4, #20]
   2262e:	f00c fe91 	bl	2f354 <memcpy>
   22632:	e008      	b.n	22646 <ip_interface_connect+0xea>
   22634:	2210      	movs	r2, #16
   22636:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   2263a:	eb08 0102 	add.w	r1, r8, r2
   2263e:	82e2      	strh	r2, [r4, #22]
   22640:	82a3      	strh	r3, [r4, #20]
   22642:	f00c fe87 	bl	2f354 <memcpy>
   22646:	68a3      	ldr	r3, [r4, #8]
   22648:	8ae2      	ldrh	r2, [r4, #22]
   2264a:	f247 0102 	movw	r1, #28674	; 0x7002
   2264e:	4413      	add	r3, r2
   22650:	60a3      	str	r3, [r4, #8]
   22652:	682e      	ldr	r6, [r5, #0]
   22654:	682b      	ldr	r3, [r5, #0]
   22656:	4620      	mov	r0, r4
   22658:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   2265c:	602b      	str	r3, [r5, #0]
   2265e:	f7fb ff3d 	bl	1e4dc <rpc_ip_client_request_send>
   22662:	b988      	cbnz	r0, 22688 <ip_interface_connect+0x12c>
   22664:	682b      	ldr	r3, [r5, #0]
   22666:	f013 5880 	ands.w	r8, r3, #268435456	; 0x10000000
   2266a:	d119      	bne.n	226a0 <ip_interface_connect+0x144>
   2266c:	f04f 33ff 	mov.w	r3, #4294967295
   22670:	f64f 72ff 	movw	r2, #65535	; 0xffff
   22674:	2105      	movs	r1, #5
   22676:	4638      	mov	r0, r7
   22678:	f000 ff8e 	bl	23598 <interface_socket_wait>
   2267c:	4604      	mov	r4, r0
   2267e:	b1c0      	cbz	r0, 226b2 <ip_interface_connect+0x156>
   22680:	2c73      	cmp	r4, #115	; 0x73
   22682:	d0bb      	beq.n	225fc <ip_interface_connect+0xa0>
   22684:	602e      	str	r6, [r5, #0]
   22686:	e7b9      	b.n	225fc <ip_interface_connect+0xa0>
   22688:	6820      	ldr	r0, [r4, #0]
   2268a:	b108      	cbz	r0, 22690 <ip_interface_connect+0x134>
   2268c:	f7fb ff44 	bl	1e518 <rpc_ip_client_data_free>
   22690:	4620      	mov	r0, r4
   22692:	f7fb ff39 	bl	1e508 <rpc_ip_client_message_free>
   22696:	2423      	movs	r4, #35	; 0x23
   22698:	602e      	str	r6, [r5, #0]
   2269a:	e7af      	b.n	225fc <ip_interface_connect+0xa0>
   2269c:	2472      	movs	r4, #114	; 0x72
   2269e:	e7ad      	b.n	225fc <ip_interface_connect+0xa0>
   226a0:	2473      	movs	r4, #115	; 0x73
   226a2:	e7ab      	b.n	225fc <ip_interface_connect+0xa0>
   226a4:	6803      	ldr	r3, [r0, #0]
   226a6:	b29b      	uxth	r3, r3
   226a8:	2b05      	cmp	r3, #5
   226aa:	bf14      	ite	ne
   226ac:	2409      	movne	r4, #9
   226ae:	2438      	moveq	r4, #56	; 0x38
   226b0:	e7a4      	b.n	225fc <ip_interface_connect+0xa0>
   226b2:	4638      	mov	r0, r7
   226b4:	f000 ffe4 	bl	23680 <interface_socket_from_handle_get>
   226b8:	2800      	cmp	r0, #0
   226ba:	d0a4      	beq.n	22606 <ip_interface_connect+0xaa>
   226bc:	6844      	ldr	r4, [r0, #4]
   226be:	2c00      	cmp	r4, #0
   226c0:	d0a1      	beq.n	22606 <ip_interface_connect+0xaa>
   226c2:	f8c0 8004 	str.w	r8, [r0, #4]
   226c6:	e7db      	b.n	22680 <ip_interface_connect+0x124>
   226c8:	240c      	movs	r4, #12
   226ca:	e797      	b.n	225fc <ip_interface_connect+0xa0>
   226cc:	2409      	movs	r4, #9
   226ce:	e795      	b.n	225fc <ip_interface_connect+0xa0>

000226d0 <ip_interface_bind>:
   226d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   226d4:	b083      	sub	sp, #12
   226d6:	b3b1      	cbz	r1, 22746 <ip_interface_bind+0x76>
   226d8:	4616      	mov	r6, r2
   226da:	b3a2      	cbz	r2, 22746 <ip_interface_bind+0x76>
   226dc:	4607      	mov	r7, r0
   226de:	4688      	mov	r8, r1
   226e0:	f000 ffce 	bl	23680 <interface_socket_from_handle_get>
   226e4:	4605      	mov	r5, r0
   226e6:	2800      	cmp	r0, #0
   226e8:	d04a      	beq.n	22780 <ip_interface_bind+0xb0>
   226ea:	6803      	ldr	r3, [r0, #0]
   226ec:	b29b      	uxth	r3, r3
   226ee:	2b02      	cmp	r3, #2
   226f0:	d146      	bne.n	22780 <ip_interface_bind+0xb0>
   226f2:	2100      	movs	r1, #0
   226f4:	a802      	add	r0, sp, #8
   226f6:	f840 1d04 	str.w	r1, [r0, #-4]!
   226fa:	f8d5 9018 	ldr.w	r9, [r5, #24]
   226fe:	f7fb fed9 	bl	1e4b4 <rpc_ip_client_request_alloc>
   22702:	bb50      	cbnz	r0, 2275a <ip_interface_bind+0x8a>
   22704:	f247 0305 	movw	r3, #28677	; 0x7005
   22708:	2208      	movs	r2, #8
   2270a:	9c01      	ldr	r4, [sp, #4]
   2270c:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
   22710:	60e3      	str	r3, [r4, #12]
   22712:	f8c4 9010 	str.w	r9, [r4, #16]
   22716:	7260      	strb	r0, [r4, #9]
   22718:	72a0      	strb	r0, [r4, #10]
   2271a:	72e0      	strb	r0, [r4, #11]
   2271c:	7222      	strb	r2, [r4, #8]
   2271e:	68a3      	ldr	r3, [r4, #8]
   22720:	3304      	adds	r3, #4
   22722:	60a3      	str	r3, [r4, #8]
   22724:	68eb      	ldr	r3, [r5, #12]
   22726:	f8d8 2004 	ldr.w	r2, [r8, #4]
   2272a:	4293      	cmp	r3, r2
   2272c:	d11a      	bne.n	22764 <ip_interface_bind+0x94>
   2272e:	f898 2000 	ldrb.w	r2, [r8]
   22732:	4296      	cmp	r6, r2
   22734:	d107      	bne.n	22746 <ip_interface_bind+0x76>
   22736:	2b02      	cmp	r3, #2
   22738:	f104 0018 	add.w	r0, r4, #24
   2273c:	d014      	beq.n	22768 <ip_interface_bind+0x98>
   2273e:	2b0a      	cmp	r3, #10
   22740:	d101      	bne.n	22746 <ip_interface_bind+0x76>
   22742:	2e24      	cmp	r6, #36	; 0x24
   22744:	d01e      	beq.n	22784 <ip_interface_bind+0xb4>
   22746:	2416      	movs	r4, #22
   22748:	4620      	mov	r0, r4
   2274a:	f7f9 f80f 	bl	1b76c <bsd_os_errno_set>
   2274e:	f04f 34ff 	mov.w	r4, #4294967295
   22752:	4620      	mov	r0, r4
   22754:	b003      	add	sp, #12
   22756:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2275a:	9c01      	ldr	r4, [sp, #4]
   2275c:	2c00      	cmp	r4, #0
   2275e:	d1de      	bne.n	2271e <ip_interface_bind+0x4e>
   22760:	240c      	movs	r4, #12
   22762:	e7f1      	b.n	22748 <ip_interface_bind+0x78>
   22764:	242f      	movs	r4, #47	; 0x2f
   22766:	e7ef      	b.n	22748 <ip_interface_bind+0x78>
   22768:	2e10      	cmp	r6, #16
   2276a:	d1ec      	bne.n	22746 <ip_interface_bind+0x76>
   2276c:	2204      	movs	r2, #4
   2276e:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   22772:	f108 010c 	add.w	r1, r8, #12
   22776:	82e2      	strh	r2, [r4, #22]
   22778:	82a3      	strh	r3, [r4, #20]
   2277a:	f00c fdeb 	bl	2f354 <memcpy>
   2277e:	e00a      	b.n	22796 <ip_interface_bind+0xc6>
   22780:	2409      	movs	r4, #9
   22782:	e7e1      	b.n	22748 <ip_interface_bind+0x78>
   22784:	2210      	movs	r2, #16
   22786:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   2278a:	eb08 0102 	add.w	r1, r8, r2
   2278e:	82e2      	strh	r2, [r4, #22]
   22790:	82a3      	strh	r3, [r4, #20]
   22792:	f00c fddf 	bl	2f354 <memcpy>
   22796:	68a3      	ldr	r3, [r4, #8]
   22798:	8ae2      	ldrh	r2, [r4, #22]
   2279a:	f247 0105 	movw	r1, #28677	; 0x7005
   2279e:	4413      	add	r3, r2
   227a0:	60a3      	str	r3, [r4, #8]
   227a2:	682b      	ldr	r3, [r5, #0]
   227a4:	4620      	mov	r0, r4
   227a6:	0c1b      	lsrs	r3, r3, #16
   227a8:	041b      	lsls	r3, r3, #16
   227aa:	f043 0303 	orr.w	r3, r3, #3
   227ae:	602b      	str	r3, [r5, #0]
   227b0:	682e      	ldr	r6, [r5, #0]
   227b2:	f7fb fe93 	bl	1e4dc <rpc_ip_client_request_send>
   227b6:	4680      	mov	r8, r0
   227b8:	b980      	cbnz	r0, 227dc <ip_interface_bind+0x10c>
   227ba:	f04f 33ff 	mov.w	r3, #4294967295
   227be:	f64f 72ff 	movw	r2, #65535	; 0xffff
   227c2:	2104      	movs	r1, #4
   227c4:	4638      	mov	r0, r7
   227c6:	f000 fee7 	bl	23598 <interface_socket_wait>
   227ca:	4604      	mov	r4, r0
   227cc:	b1a0      	cbz	r0, 227f8 <ip_interface_bind+0x128>
   227ce:	682b      	ldr	r3, [r5, #0]
   227d0:	0c1b      	lsrs	r3, r3, #16
   227d2:	041b      	lsls	r3, r3, #16
   227d4:	f043 0302 	orr.w	r3, r3, #2
   227d8:	602b      	str	r3, [r5, #0]
   227da:	e7b5      	b.n	22748 <ip_interface_bind+0x78>
   227dc:	6820      	ldr	r0, [r4, #0]
   227de:	b108      	cbz	r0, 227e4 <ip_interface_bind+0x114>
   227e0:	f7fb fe9a 	bl	1e518 <rpc_ip_client_data_free>
   227e4:	0c36      	lsrs	r6, r6, #16
   227e6:	0436      	lsls	r6, r6, #16
   227e8:	4620      	mov	r0, r4
   227ea:	f046 0602 	orr.w	r6, r6, #2
   227ee:	f7fb fe8b 	bl	1e508 <rpc_ip_client_message_free>
   227f2:	2423      	movs	r4, #35	; 0x23
   227f4:	602e      	str	r6, [r5, #0]
   227f6:	e7a7      	b.n	22748 <ip_interface_bind+0x78>
   227f8:	4638      	mov	r0, r7
   227fa:	f000 ff41 	bl	23680 <interface_socket_from_handle_get>
   227fe:	2800      	cmp	r0, #0
   22800:	d0a7      	beq.n	22752 <ip_interface_bind+0x82>
   22802:	6844      	ldr	r4, [r0, #4]
   22804:	2c00      	cmp	r4, #0
   22806:	d0a4      	beq.n	22752 <ip_interface_bind+0x82>
   22808:	f8c0 8004 	str.w	r8, [r0, #4]
   2280c:	e7df      	b.n	227ce <ip_interface_bind+0xfe>
   2280e:	bf00      	nop

00022810 <ip_interface_listen>:
   22810:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   22814:	b082      	sub	sp, #8
   22816:	4606      	mov	r6, r0
   22818:	f000 ff32 	bl	23680 <interface_socket_from_handle_get>
   2281c:	2800      	cmp	r0, #0
   2281e:	d067      	beq.n	228f0 <ip_interface_listen+0xe0>
   22820:	6803      	ldr	r3, [r0, #0]
   22822:	4605      	mov	r5, r0
   22824:	b29b      	uxth	r3, r3
   22826:	2b04      	cmp	r3, #4
   22828:	d162      	bne.n	228f0 <ip_interface_listen+0xe0>
   2282a:	2100      	movs	r1, #0
   2282c:	4a32      	ldr	r2, [pc, #200]	; (228f8 <ip_interface_listen+0xe8>)
   2282e:	4630      	mov	r0, r6
   22830:	f000 fe7a 	bl	23528 <interface_socket_packet_handler_update>
   22834:	4601      	mov	r1, r0
   22836:	2800      	cmp	r0, #0
   22838:	d15c      	bne.n	228f4 <ip_interface_listen+0xe4>
   2283a:	a802      	add	r0, sp, #8
   2283c:	f840 1d04 	str.w	r1, [r0, #-4]!
   22840:	69af      	ldr	r7, [r5, #24]
   22842:	f7fb fe37 	bl	1e4b4 <rpc_ip_client_request_alloc>
   22846:	bba8      	cbnz	r0, 228b4 <ip_interface_listen+0xa4>
   22848:	f247 0308 	movw	r3, #28680	; 0x7008
   2284c:	2208      	movs	r2, #8
   2284e:	9c01      	ldr	r4, [sp, #4]
   22850:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   22854:	60e3      	str	r3, [r4, #12]
   22856:	6127      	str	r7, [r4, #16]
   22858:	7260      	strb	r0, [r4, #9]
   2285a:	72a0      	strb	r0, [r4, #10]
   2285c:	72e0      	strb	r0, [r4, #11]
   2285e:	7222      	strb	r2, [r4, #8]
   22860:	68a3      	ldr	r3, [r4, #8]
   22862:	f247 0108 	movw	r1, #28680	; 0x7008
   22866:	3304      	adds	r3, #4
   22868:	60a3      	str	r3, [r4, #8]
   2286a:	682b      	ldr	r3, [r5, #0]
   2286c:	4620      	mov	r0, r4
   2286e:	0c1b      	lsrs	r3, r3, #16
   22870:	041b      	lsls	r3, r3, #16
   22872:	f043 0306 	orr.w	r3, r3, #6
   22876:	602b      	str	r3, [r5, #0]
   22878:	682f      	ldr	r7, [r5, #0]
   2287a:	f7fb fe2f 	bl	1e4dc <rpc_ip_client_request_send>
   2287e:	4680      	mov	r8, r0
   22880:	b9e8      	cbnz	r0, 228be <ip_interface_listen+0xae>
   22882:	f04f 33ff 	mov.w	r3, #4294967295
   22886:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2288a:	2107      	movs	r1, #7
   2288c:	4630      	mov	r0, r6
   2288e:	f000 fe83 	bl	23598 <interface_socket_wait>
   22892:	4604      	mov	r4, r0
   22894:	b308      	cbz	r0, 228da <ip_interface_listen+0xca>
   22896:	682b      	ldr	r3, [r5, #0]
   22898:	0c1b      	lsrs	r3, r3, #16
   2289a:	041b      	lsls	r3, r3, #16
   2289c:	f043 0304 	orr.w	r3, r3, #4
   228a0:	602b      	str	r3, [r5, #0]
   228a2:	4620      	mov	r0, r4
   228a4:	f7f8 ff62 	bl	1b76c <bsd_os_errno_set>
   228a8:	f04f 34ff 	mov.w	r4, #4294967295
   228ac:	4620      	mov	r0, r4
   228ae:	b002      	add	sp, #8
   228b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   228b4:	9c01      	ldr	r4, [sp, #4]
   228b6:	2c00      	cmp	r4, #0
   228b8:	d1d2      	bne.n	22860 <ip_interface_listen+0x50>
   228ba:	240c      	movs	r4, #12
   228bc:	e7f1      	b.n	228a2 <ip_interface_listen+0x92>
   228be:	6820      	ldr	r0, [r4, #0]
   228c0:	b108      	cbz	r0, 228c6 <ip_interface_listen+0xb6>
   228c2:	f7fb fe29 	bl	1e518 <rpc_ip_client_data_free>
   228c6:	0c3f      	lsrs	r7, r7, #16
   228c8:	043f      	lsls	r7, r7, #16
   228ca:	4620      	mov	r0, r4
   228cc:	f047 0704 	orr.w	r7, r7, #4
   228d0:	f7fb fe1a 	bl	1e508 <rpc_ip_client_message_free>
   228d4:	2423      	movs	r4, #35	; 0x23
   228d6:	602f      	str	r7, [r5, #0]
   228d8:	e7e3      	b.n	228a2 <ip_interface_listen+0x92>
   228da:	4630      	mov	r0, r6
   228dc:	f000 fed0 	bl	23680 <interface_socket_from_handle_get>
   228e0:	2800      	cmp	r0, #0
   228e2:	d0e3      	beq.n	228ac <ip_interface_listen+0x9c>
   228e4:	6844      	ldr	r4, [r0, #4]
   228e6:	2c00      	cmp	r4, #0
   228e8:	d0e0      	beq.n	228ac <ip_interface_listen+0x9c>
   228ea:	f8c0 8004 	str.w	r8, [r0, #4]
   228ee:	e7d2      	b.n	22896 <ip_interface_listen+0x86>
   228f0:	2409      	movs	r4, #9
   228f2:	e7d6      	b.n	228a2 <ip_interface_listen+0x92>
   228f4:	2423      	movs	r4, #35	; 0x23
   228f6:	e7d4      	b.n	228a2 <ip_interface_listen+0x92>
   228f8:	00021cd5 	.word	0x00021cd5

000228fc <ip_interface_accept>:
   228fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   22900:	2500      	movs	r5, #0
   22902:	b085      	sub	sp, #20
   22904:	460f      	mov	r7, r1
   22906:	4690      	mov	r8, r2
   22908:	9502      	str	r5, [sp, #8]
   2290a:	4606      	mov	r6, r0
   2290c:	f000 feb8 	bl	23680 <interface_socket_from_handle_get>
   22910:	4604      	mov	r4, r0
   22912:	2800      	cmp	r0, #0
   22914:	f000 811c 	beq.w	22b50 <ip_interface_accept+0x254>
   22918:	6803      	ldr	r3, [r0, #0]
   2291a:	b29b      	uxth	r3, r3
   2291c:	2b07      	cmp	r3, #7
   2291e:	d10a      	bne.n	22936 <ip_interface_accept+0x3a>
   22920:	6803      	ldr	r3, [r0, #0]
   22922:	6805      	ldr	r5, [r0, #0]
   22924:	00db      	lsls	r3, r3, #3
   22926:	d416      	bmi.n	22956 <ip_interface_accept+0x5a>
   22928:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   2292c:	d019      	beq.n	22962 <ip_interface_accept+0x66>
   2292e:	6805      	ldr	r5, [r0, #0]
   22930:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   22934:	d124      	bne.n	22980 <ip_interface_accept+0x84>
   22936:	f04f 0909 	mov.w	r9, #9
   2293a:	9b02      	ldr	r3, [sp, #8]
   2293c:	b113      	cbz	r3, 22944 <ip_interface_accept+0x48>
   2293e:	4628      	mov	r0, r5
   22940:	f000 fddc 	bl	234fc <interface_socket_free>
   22944:	4648      	mov	r0, r9
   22946:	f04f 39ff 	mov.w	r9, #4294967295
   2294a:	f7f8 ff0f 	bl	1b76c <bsd_os_errno_set>
   2294e:	4648      	mov	r0, r9
   22950:	b005      	add	sp, #20
   22952:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   22956:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   2295a:	d16d      	bne.n	22a38 <ip_interface_accept+0x13c>
   2295c:	f04f 0923 	mov.w	r9, #35	; 0x23
   22960:	e7eb      	b.n	2293a <ip_interface_accept+0x3e>
   22962:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   22966:	f04f 33ff 	mov.w	r3, #4294967295
   2296a:	4611      	mov	r1, r2
   2296c:	4630      	mov	r0, r6
   2296e:	f000 fe13 	bl	23598 <interface_socket_wait>
   22972:	4681      	mov	r9, r0
   22974:	2800      	cmp	r0, #0
   22976:	d07e      	beq.n	22a76 <ip_interface_accept+0x17a>
   22978:	6825      	ldr	r5, [r4, #0]
   2297a:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   2297e:	d0dc      	beq.n	2293a <ip_interface_accept+0x3e>
   22980:	f04f 30ff 	mov.w	r0, #4294967295
   22984:	2300      	movs	r3, #0
   22986:	e9cd 0300 	strd	r0, r3, [sp]
   2298a:	4a75      	ldr	r2, [pc, #468]	; (22b60 <ip_interface_accept+0x264>)
   2298c:	6921      	ldr	r1, [r4, #16]
   2298e:	a802      	add	r0, sp, #8
   22990:	f000 fd50 	bl	23434 <interface_socket_allocate>
   22994:	9b02      	ldr	r3, [sp, #8]
   22996:	4605      	mov	r5, r0
   22998:	2b00      	cmp	r3, #0
   2299a:	f000 80dd 	beq.w	22b58 <ip_interface_accept+0x25c>
   2299e:	2100      	movs	r1, #0
   229a0:	6962      	ldr	r2, [r4, #20]
   229a2:	a804      	add	r0, sp, #16
   229a4:	615a      	str	r2, [r3, #20]
   229a6:	68e2      	ldr	r2, [r4, #12]
   229a8:	f840 1d04 	str.w	r1, [r0, #-4]!
   229ac:	60da      	str	r2, [r3, #12]
   229ae:	6922      	ldr	r2, [r4, #16]
   229b0:	611a      	str	r2, [r3, #16]
   229b2:	f8d4 9018 	ldr.w	r9, [r4, #24]
   229b6:	f7fb fd7d 	bl	1e4b4 <rpc_ip_client_request_alloc>
   229ba:	2800      	cmp	r0, #0
   229bc:	d143      	bne.n	22a46 <ip_interface_accept+0x14a>
   229be:	f247 030c 	movw	r3, #28684	; 0x700c
   229c2:	2108      	movs	r1, #8
   229c4:	f8dd b00c 	ldr.w	fp, [sp, #12]
   229c8:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   229cc:	f8cb 300c 	str.w	r3, [fp, #12]
   229d0:	f8cb 9010 	str.w	r9, [fp, #16]
   229d4:	f88b 0009 	strb.w	r0, [fp, #9]
   229d8:	f88b 000a 	strb.w	r0, [fp, #10]
   229dc:	f88b 000b 	strb.w	r0, [fp, #11]
   229e0:	f88b 1008 	strb.w	r1, [fp, #8]
   229e4:	6823      	ldr	r3, [r4, #0]
   229e6:	f247 010c 	movw	r1, #28684	; 0x700c
   229ea:	0c1b      	lsrs	r3, r3, #16
   229ec:	041b      	lsls	r3, r3, #16
   229ee:	f043 0308 	orr.w	r3, r3, #8
   229f2:	6023      	str	r3, [r4, #0]
   229f4:	4658      	mov	r0, fp
   229f6:	f8d4 9000 	ldr.w	r9, [r4]
   229fa:	f7fb fd6f 	bl	1e4dc <rpc_ip_client_request_send>
   229fe:	4682      	mov	sl, r0
   22a00:	bb48      	cbnz	r0, 22a56 <ip_interface_accept+0x15a>
   22a02:	6822      	ldr	r2, [r4, #0]
   22a04:	9900      	ldr	r1, [sp, #0]
   22a06:	f04f 33ff 	mov.w	r3, #4294967295
   22a0a:	400a      	ands	r2, r1
   22a0c:	6022      	str	r2, [r4, #0]
   22a0e:	2109      	movs	r1, #9
   22a10:	f64f 72ff 	movw	r2, #65535	; 0xffff
   22a14:	4630      	mov	r0, r6
   22a16:	f000 fdbf 	bl	23598 <interface_socket_wait>
   22a1a:	4681      	mov	r9, r0
   22a1c:	2800      	cmp	r0, #0
   22a1e:	f000 8085 	beq.w	22b2c <ip_interface_accept+0x230>
   22a22:	6823      	ldr	r3, [r4, #0]
   22a24:	9a01      	ldr	r2, [sp, #4]
   22a26:	431a      	orrs	r2, r3
   22a28:	6022      	str	r2, [r4, #0]
   22a2a:	6823      	ldr	r3, [r4, #0]
   22a2c:	0c1b      	lsrs	r3, r3, #16
   22a2e:	041b      	lsls	r3, r3, #16
   22a30:	f043 0307 	orr.w	r3, r3, #7
   22a34:	6023      	str	r3, [r4, #0]
   22a36:	e780      	b.n	2293a <ip_interface_accept+0x3e>
   22a38:	f06f 5280 	mvn.w	r2, #268435456	; 0x10000000
   22a3c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   22a40:	e9cd 2300 	strd	r2, r3, [sp]
   22a44:	e7a1      	b.n	2298a <ip_interface_accept+0x8e>
   22a46:	f8dd b00c 	ldr.w	fp, [sp, #12]
   22a4a:	f04f 090c 	mov.w	r9, #12
   22a4e:	f1bb 0f00 	cmp.w	fp, #0
   22a52:	d1c7      	bne.n	229e4 <ip_interface_accept+0xe8>
   22a54:	e771      	b.n	2293a <ip_interface_accept+0x3e>
   22a56:	f8db 0000 	ldr.w	r0, [fp]
   22a5a:	b108      	cbz	r0, 22a60 <ip_interface_accept+0x164>
   22a5c:	f7fb fd5c 	bl	1e518 <rpc_ip_client_data_free>
   22a60:	ea4f 4919 	mov.w	r9, r9, lsr #16
   22a64:	4658      	mov	r0, fp
   22a66:	ea4f 4909 	mov.w	r9, r9, lsl #16
   22a6a:	f7fb fd4d 	bl	1e508 <rpc_ip_client_message_free>
   22a6e:	f049 0307 	orr.w	r3, r9, #7
   22a72:	6023      	str	r3, [r4, #0]
   22a74:	e772      	b.n	2295c <ip_interface_accept+0x60>
   22a76:	4630      	mov	r0, r6
   22a78:	f000 fe02 	bl	23680 <interface_socket_from_handle_get>
   22a7c:	b130      	cbz	r0, 22a8c <ip_interface_accept+0x190>
   22a7e:	f8d0 9004 	ldr.w	r9, [r0, #4]
   22a82:	f1b9 0f00 	cmp.w	r9, #0
   22a86:	d001      	beq.n	22a8c <ip_interface_accept+0x190>
   22a88:	6045      	str	r5, [r0, #4]
   22a8a:	e775      	b.n	22978 <ip_interface_accept+0x7c>
   22a8c:	6823      	ldr	r3, [r4, #0]
   22a8e:	03d9      	lsls	r1, r3, #15
   22a90:	f53f af76 	bmi.w	22980 <ip_interface_accept+0x84>
   22a94:	4d33      	ldr	r5, [pc, #204]	; (22b64 <ip_interface_accept+0x268>)
   22a96:	9902      	ldr	r1, [sp, #8]
   22a98:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
   22a9c:	699b      	ldr	r3, [r3, #24]
   22a9e:	618b      	str	r3, [r1, #24]
   22aa0:	b147      	cbz	r7, 22ab4 <ip_interface_accept+0x1b8>
   22aa2:	68cb      	ldr	r3, [r1, #12]
   22aa4:	2b0a      	cmp	r3, #10
   22aa6:	d024      	beq.n	22af2 <ip_interface_accept+0x1f6>
   22aa8:	2b02      	cmp	r3, #2
   22aaa:	d103      	bne.n	22ab4 <ip_interface_accept+0x1b8>
   22aac:	f8d8 2000 	ldr.w	r2, [r8]
   22ab0:	2a10      	cmp	r2, #16
   22ab2:	d032      	beq.n	22b1a <ip_interface_accept+0x21e>
   22ab4:	680a      	ldr	r2, [r1, #0]
   22ab6:	482c      	ldr	r0, [pc, #176]	; (22b68 <ip_interface_accept+0x26c>)
   22ab8:	4002      	ands	r2, r0
   22aba:	f042 0205 	orr.w	r2, r2, #5
   22abe:	600a      	str	r2, [r1, #0]
   22ac0:	9a02      	ldr	r2, [sp, #8]
   22ac2:	6811      	ldr	r1, [r2, #0]
   22ac4:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
   22ac8:	6011      	str	r1, [r2, #0]
   22aca:	6811      	ldr	r1, [r2, #0]
   22acc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   22ad0:	6011      	str	r1, [r2, #0]
   22ad2:	6823      	ldr	r3, [r4, #0]
   22ad4:	4003      	ands	r3, r0
   22ad6:	f043 0307 	orr.w	r3, r3, #7
   22ada:	6023      	str	r3, [r4, #0]
   22adc:	f855 0026 	ldr.w	r0, [r5, r6, lsl #2]
   22ae0:	f7fb fd12 	bl	1e508 <rpc_ip_client_message_free>
   22ae4:	2300      	movs	r3, #0
   22ae6:	4648      	mov	r0, r9
   22ae8:	f845 3026 	str.w	r3, [r5, r6, lsl #2]
   22aec:	b005      	add	sp, #20
   22aee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   22af2:	f8d8 2000 	ldr.w	r2, [r8]
   22af6:	2a24      	cmp	r2, #36	; 0x24
   22af8:	d1dc      	bne.n	22ab4 <ip_interface_accept+0x1b8>
   22afa:	703a      	strb	r2, [r7, #0]
   22afc:	2210      	movs	r2, #16
   22afe:	607b      	str	r3, [r7, #4]
   22b00:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
   22b04:	f107 0010 	add.w	r0, r7, #16
   22b08:	8b9b      	ldrh	r3, [r3, #28]
   22b0a:	813b      	strh	r3, [r7, #8]
   22b0c:	f855 1026 	ldr.w	r1, [r5, r6, lsl #2]
   22b10:	3120      	adds	r1, #32
   22b12:	f00c fc1f 	bl	2f354 <memcpy>
   22b16:	9902      	ldr	r1, [sp, #8]
   22b18:	e7cc      	b.n	22ab4 <ip_interface_accept+0x1b8>
   22b1a:	703a      	strb	r2, [r7, #0]
   22b1c:	607b      	str	r3, [r7, #4]
   22b1e:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
   22b22:	f107 000c 	add.w	r0, r7, #12
   22b26:	8b9b      	ldrh	r3, [r3, #28]
   22b28:	2204      	movs	r2, #4
   22b2a:	e7ee      	b.n	22b0a <ip_interface_accept+0x20e>
   22b2c:	4630      	mov	r0, r6
   22b2e:	f000 fda7 	bl	23680 <interface_socket_from_handle_get>
   22b32:	b138      	cbz	r0, 22b44 <ip_interface_accept+0x248>
   22b34:	f8d0 9004 	ldr.w	r9, [r0, #4]
   22b38:	f1b9 0f00 	cmp.w	r9, #0
   22b3c:	d002      	beq.n	22b44 <ip_interface_accept+0x248>
   22b3e:	f8c0 a004 	str.w	sl, [r0, #4]
   22b42:	e76e      	b.n	22a22 <ip_interface_accept+0x126>
   22b44:	6823      	ldr	r3, [r4, #0]
   22b46:	9a01      	ldr	r2, [sp, #4]
   22b48:	46a9      	mov	r9, r5
   22b4a:	4313      	orrs	r3, r2
   22b4c:	6023      	str	r3, [r4, #0]
   22b4e:	e7a1      	b.n	22a94 <ip_interface_accept+0x198>
   22b50:	4605      	mov	r5, r0
   22b52:	f04f 0909 	mov.w	r9, #9
   22b56:	e6f0      	b.n	2293a <ip_interface_accept+0x3e>
   22b58:	f04f 090c 	mov.w	r9, #12
   22b5c:	e6f2      	b.n	22944 <ip_interface_accept+0x48>
   22b5e:	bf00      	nop
   22b60:	00021cd5 	.word	0x00021cd5
   22b64:	20028eb0 	.word	0x20028eb0
   22b68:	ffff0000 	.word	0xffff0000

00022b6c <ip_interface_setopt>:
   22b6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   22b70:	2901      	cmp	r1, #1
   22b72:	b084      	sub	sp, #16
   22b74:	f040 809c 	bne.w	22cb0 <ip_interface_setopt+0x144>
   22b78:	460e      	mov	r6, r1
   22b7a:	4690      	mov	r8, r2
   22b7c:	461d      	mov	r5, r3
   22b7e:	4607      	mov	r7, r0
   22b80:	f000 fd7e 	bl	23680 <interface_socket_from_handle_get>
   22b84:	4604      	mov	r4, r0
   22b86:	2800      	cmp	r0, #0
   22b88:	f000 80a5 	beq.w	22cd6 <ip_interface_setopt+0x16a>
   22b8c:	f1b8 0f19 	cmp.w	r8, #25
   22b90:	d16e      	bne.n	22c70 <ip_interface_setopt+0x104>
   22b92:	2d00      	cmp	r5, #0
   22b94:	f000 8092 	beq.w	22cbc <ip_interface_setopt+0x150>
   22b98:	4628      	mov	r0, r5
   22b9a:	f7ea f9dd 	bl	cf58 <strlen>
   22b9e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   22ba0:	4298      	cmp	r0, r3
   22ba2:	f040 808b 	bne.w	22cbc <ip_interface_setopt+0x150>
   22ba6:	6823      	ldr	r3, [r4, #0]
   22ba8:	b29b      	uxth	r3, r3
   22baa:	2b02      	cmp	r3, #2
   22bac:	d173      	bne.n	22c96 <ip_interface_setopt+0x12a>
   22bae:	4629      	mov	r1, r5
   22bb0:	68e0      	ldr	r0, [r4, #12]
   22bb2:	f7fe fb2b 	bl	2120c <pdn_interface_pdn_id_get>
   22bb6:	9002      	str	r0, [sp, #8]
   22bb8:	3001      	adds	r0, #1
   22bba:	bf08      	it	eq
   22bbc:	2516      	moveq	r5, #22
   22bbe:	d04e      	beq.n	22c5e <ip_interface_setopt+0xf2>
   22bc0:	6823      	ldr	r3, [r4, #0]
   22bc2:	025b      	lsls	r3, r3, #9
   22bc4:	d44a      	bmi.n	22c5c <ip_interface_setopt+0xf0>
   22bc6:	6823      	ldr	r3, [r4, #0]
   22bc8:	f413 0300 	ands.w	r3, r3, #8388608	; 0x800000
   22bcc:	d146      	bne.n	22c5c <ip_interface_setopt+0xf0>
   22bce:	6826      	ldr	r6, [r4, #0]
   22bd0:	6822      	ldr	r2, [r4, #0]
   22bd2:	a804      	add	r0, sp, #16
   22bd4:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
   22bd8:	6022      	str	r2, [r4, #0]
   22bda:	2104      	movs	r1, #4
   22bdc:	f840 3d04 	str.w	r3, [r0, #-4]!
   22be0:	f8d4 8018 	ldr.w	r8, [r4, #24]
   22be4:	f7fb fc66 	bl	1e4b4 <rpc_ip_client_request_alloc>
   22be8:	2800      	cmp	r0, #0
   22bea:	d14e      	bne.n	22c8a <ip_interface_setopt+0x11e>
   22bec:	f247 0203 	movw	r2, #28675	; 0x7003
   22bf0:	2300      	movs	r3, #0
   22bf2:	2108      	movs	r1, #8
   22bf4:	9d03      	ldr	r5, [sp, #12]
   22bf6:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
   22bfa:	60ea      	str	r2, [r5, #12]
   22bfc:	f8c5 8010 	str.w	r8, [r5, #16]
   22c00:	7229      	strb	r1, [r5, #8]
   22c02:	726b      	strb	r3, [r5, #9]
   22c04:	72ab      	strb	r3, [r5, #10]
   22c06:	72eb      	strb	r3, [r5, #11]
   22c08:	f04f 0c08 	mov.w	ip, #8
   22c0c:	2300      	movs	r3, #0
   22c0e:	2010      	movs	r0, #16
   22c10:	2130      	movs	r1, #48	; 0x30
   22c12:	68aa      	ldr	r2, [r5, #8]
   22c14:	756b      	strb	r3, [r5, #21]
   22c16:	4462      	add	r2, ip
   22c18:	60aa      	str	r2, [r5, #8]
   22c1a:	75ab      	strb	r3, [r5, #22]
   22c1c:	75eb      	strb	r3, [r5, #23]
   22c1e:	76ab      	strb	r3, [r5, #26]
   22c20:	76eb      	strb	r3, [r5, #27]
   22c22:	f885 c014 	strb.w	ip, [r5, #20]
   22c26:	7628      	strb	r0, [r5, #24]
   22c28:	7669      	strb	r1, [r5, #25]
   22c2a:	2204      	movs	r2, #4
   22c2c:	eb0d 010c 	add.w	r1, sp, ip
   22c30:	6828      	ldr	r0, [r5, #0]
   22c32:	f00c fb8f 	bl	2f354 <memcpy>
   22c36:	f247 0103 	movw	r1, #28675	; 0x7003
   22c3a:	4628      	mov	r0, r5
   22c3c:	f7fb fc4e 	bl	1e4dc <rpc_ip_client_request_send>
   22c40:	4680      	mov	r8, r0
   22c42:	bb50      	cbnz	r0, 22c9a <ip_interface_setopt+0x12e>
   22c44:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   22c48:	f04f 33ff 	mov.w	r3, #4294967295
   22c4c:	4611      	mov	r1, r2
   22c4e:	4638      	mov	r0, r7
   22c50:	f000 fca2 	bl	23598 <interface_socket_wait>
   22c54:	4605      	mov	r5, r0
   22c56:	b398      	cbz	r0, 22cc0 <ip_interface_setopt+0x154>
   22c58:	6026      	str	r6, [r4, #0]
   22c5a:	e000      	b.n	22c5e <ip_interface_setopt+0xf2>
   22c5c:	2523      	movs	r5, #35	; 0x23
   22c5e:	4628      	mov	r0, r5
   22c60:	f7f8 fd84 	bl	1b76c <bsd_os_errno_set>
   22c64:	f04f 35ff 	mov.w	r5, #4294967295
   22c68:	4628      	mov	r0, r5
   22c6a:	b004      	add	sp, #16
   22c6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   22c70:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   22c72:	4642      	mov	r2, r8
   22c74:	9300      	str	r3, [sp, #0]
   22c76:	4631      	mov	r1, r6
   22c78:	462b      	mov	r3, r5
   22c7a:	4638      	mov	r0, r7
   22c7c:	f000 fd28 	bl	236d0 <interface_socket_setopt>
   22c80:	4605      	mov	r5, r0
   22c82:	4628      	mov	r0, r5
   22c84:	b004      	add	sp, #16
   22c86:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   22c8a:	9d03      	ldr	r5, [sp, #12]
   22c8c:	2d00      	cmp	r5, #0
   22c8e:	d1bb      	bne.n	22c08 <ip_interface_setopt+0x9c>
   22c90:	6026      	str	r6, [r4, #0]
   22c92:	250c      	movs	r5, #12
   22c94:	e7e3      	b.n	22c5e <ip_interface_setopt+0xf2>
   22c96:	2509      	movs	r5, #9
   22c98:	e7e1      	b.n	22c5e <ip_interface_setopt+0xf2>
   22c9a:	6828      	ldr	r0, [r5, #0]
   22c9c:	b108      	cbz	r0, 22ca2 <ip_interface_setopt+0x136>
   22c9e:	f7fb fc3b 	bl	1e518 <rpc_ip_client_data_free>
   22ca2:	4628      	mov	r0, r5
   22ca4:	f7fb fc30 	bl	1e508 <rpc_ip_client_message_free>
   22ca8:	2523      	movs	r5, #35	; 0x23
   22caa:	6026      	str	r6, [r4, #0]
   22cac:	6026      	str	r6, [r4, #0]
   22cae:	e7d6      	b.n	22c5e <ip_interface_setopt+0xf2>
   22cb0:	202a      	movs	r0, #42	; 0x2a
   22cb2:	f7f8 fd5b 	bl	1b76c <bsd_os_errno_set>
   22cb6:	f04f 35ff 	mov.w	r5, #4294967295
   22cba:	e7d5      	b.n	22c68 <ip_interface_setopt+0xfc>
   22cbc:	250e      	movs	r5, #14
   22cbe:	e7ce      	b.n	22c5e <ip_interface_setopt+0xf2>
   22cc0:	4638      	mov	r0, r7
   22cc2:	f000 fcdd 	bl	23680 <interface_socket_from_handle_get>
   22cc6:	b120      	cbz	r0, 22cd2 <ip_interface_setopt+0x166>
   22cc8:	6845      	ldr	r5, [r0, #4]
   22cca:	b115      	cbz	r5, 22cd2 <ip_interface_setopt+0x166>
   22ccc:	f8c0 8004 	str.w	r8, [r0, #4]
   22cd0:	e7c2      	b.n	22c58 <ip_interface_setopt+0xec>
   22cd2:	6026      	str	r6, [r4, #0]
   22cd4:	e7c8      	b.n	22c68 <ip_interface_setopt+0xfc>
   22cd6:	2009      	movs	r0, #9
   22cd8:	f7f8 fd48 	bl	1b76c <bsd_os_errno_set>
   22cdc:	f04f 35ff 	mov.w	r5, #4294967295
   22ce0:	e7c2      	b.n	22c68 <ip_interface_setopt+0xfc>
   22ce2:	bf00      	nop

00022ce4 <ip_interface_getopt>:
   22ce4:	f000 bd36 	b.w	23754 <interface_socket_getopt>

00022ce8 <ip_interface_getaddrinfo>:
   22ce8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   22cec:	f04f 0c00 	mov.w	ip, #0
   22cf0:	2401      	movs	r4, #1
   22cf2:	4e72      	ldr	r6, [pc, #456]	; (22ebc <ip_interface_getaddrinfo+0x1d4>)
   22cf4:	f8df a1d0 	ldr.w	sl, [pc, #464]	; 22ec8 <ip_interface_getaddrinfo+0x1e0>
   22cf8:	f8df 91d0 	ldr.w	r9, [pc, #464]	; 22ecc <ip_interface_getaddrinfo+0x1e4>
   22cfc:	b085      	sub	sp, #20
   22cfe:	4607      	mov	r7, r0
   22d00:	4615      	mov	r5, r2
   22d02:	9301      	str	r3, [sp, #4]
   22d04:	f8a6 c000 	strh.w	ip, [r6]
   22d08:	f8ca 4000 	str.w	r4, [sl]
   22d0c:	f8c9 4000 	str.w	r4, [r9]
   22d10:	b171      	cbz	r1, 22d30 <ip_interface_getaddrinfo+0x48>
   22d12:	4608      	mov	r0, r1
   22d14:	220a      	movs	r2, #10
   22d16:	4661      	mov	r1, ip
   22d18:	f007 fd70 	bl	2a7fc <strtol>
   22d1c:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   22d20:	1e42      	subs	r2, r0, #1
   22d22:	429a      	cmp	r2, r3
   22d24:	f200 8083 	bhi.w	22e2e <ip_interface_getaddrinfo+0x146>
   22d28:	0203      	lsls	r3, r0, #8
   22d2a:	ea43 2020 	orr.w	r0, r3, r0, asr #8
   22d2e:	8030      	strh	r0, [r6, #0]
   22d30:	f8df 819c 	ldr.w	r8, [pc, #412]	; 22ed0 <ip_interface_getaddrinfo+0x1e8>
   22d34:	f8d8 3000 	ldr.w	r3, [r8]
   22d38:	2b00      	cmp	r3, #0
   22d3a:	d174      	bne.n	22e26 <ip_interface_getaddrinfo+0x13e>
   22d3c:	4a60      	ldr	r2, [pc, #384]	; (22ec0 <ip_interface_getaddrinfo+0x1d8>)
   22d3e:	6013      	str	r3, [r2, #0]
   22d40:	4a60      	ldr	r2, [pc, #384]	; (22ec4 <ip_interface_getaddrinfo+0x1dc>)
   22d42:	6013      	str	r3, [r2, #0]
   22d44:	2f00      	cmp	r7, #0
   22d46:	d062      	beq.n	22e0e <ip_interface_getaddrinfo+0x126>
   22d48:	4638      	mov	r0, r7
   22d4a:	f7ea f905 	bl	cf58 <strlen>
   22d4e:	4683      	mov	fp, r0
   22d50:	b125      	cbz	r5, 22d5c <ip_interface_getaddrinfo+0x74>
   22d52:	69ea      	ldr	r2, [r5, #28]
   22d54:	b112      	cbz	r2, 22d5c <ip_interface_getaddrinfo+0x74>
   22d56:	6851      	ldr	r1, [r2, #4]
   22d58:	2966      	cmp	r1, #102	; 0x66
   22d5a:	d06c      	beq.n	22e36 <ip_interface_getaddrinfo+0x14e>
   22d5c:	f04f 32ff 	mov.w	r2, #4294967295
   22d60:	2100      	movs	r1, #0
   22d62:	ae04      	add	r6, sp, #16
   22d64:	f846 1d04 	str.w	r1, [r6, #-4]!
   22d68:	4630      	mov	r0, r6
   22d6a:	4659      	mov	r1, fp
   22d6c:	9200      	str	r2, [sp, #0]
   22d6e:	f7fb fba1 	bl	1e4b4 <rpc_ip_client_request_alloc>
   22d72:	9a00      	ldr	r2, [sp, #0]
   22d74:	2800      	cmp	r0, #0
   22d76:	d14c      	bne.n	22e12 <ip_interface_getaddrinfo+0x12a>
   22d78:	f247 010d 	movw	r1, #28685	; 0x700d
   22d7c:	f04f 0c08 	mov.w	ip, #8
   22d80:	9c03      	ldr	r4, [sp, #12]
   22d82:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   22d86:	60e1      	str	r1, [r4, #12]
   22d88:	6122      	str	r2, [r4, #16]
   22d8a:	7260      	strb	r0, [r4, #9]
   22d8c:	72a0      	strb	r0, [r4, #10]
   22d8e:	72e0      	strb	r0, [r4, #11]
   22d90:	f884 c008 	strb.w	ip, [r4, #8]
   22d94:	2d00      	cmp	r5, #0
   22d96:	d076      	beq.n	22e86 <ip_interface_getaddrinfo+0x19e>
   22d98:	686a      	ldr	r2, [r5, #4]
   22d9a:	f022 0108 	bic.w	r1, r2, #8
   22d9e:	2902      	cmp	r1, #2
   22da0:	d05c      	beq.n	22e5c <ip_interface_getaddrinfo+0x174>
   22da2:	2a05      	cmp	r2, #5
   22da4:	d178      	bne.n	22e98 <ip_interface_getaddrinfo+0x1b0>
   22da6:	68a9      	ldr	r1, [r5, #8]
   22da8:	2902      	cmp	r1, #2
   22daa:	f8c9 1000 	str.w	r1, [r9]
   22dae:	d061      	beq.n	22e74 <ip_interface_getaddrinfo+0x18c>
   22db0:	61a2      	str	r2, [r4, #24]
   22db2:	68ea      	ldr	r2, [r5, #12]
   22db4:	6222      	str	r2, [r4, #32]
   22db6:	68aa      	ldr	r2, [r5, #8]
   22db8:	61e2      	str	r2, [r4, #28]
   22dba:	682a      	ldr	r2, [r5, #0]
   22dbc:	6162      	str	r2, [r4, #20]
   22dbe:	68a2      	ldr	r2, [r4, #8]
   22dc0:	3210      	adds	r2, #16
   22dc2:	60a2      	str	r2, [r4, #8]
   22dc4:	b12f      	cbz	r7, 22dd2 <ip_interface_getaddrinfo+0xea>
   22dc6:	6820      	ldr	r0, [r4, #0]
   22dc8:	b118      	cbz	r0, 22dd2 <ip_interface_getaddrinfo+0xea>
   22dca:	465a      	mov	r2, fp
   22dcc:	4639      	mov	r1, r7
   22dce:	f00c fac1 	bl	2f354 <memcpy>
   22dd2:	2301      	movs	r3, #1
   22dd4:	f247 010d 	movw	r1, #28685	; 0x700d
   22dd8:	4620      	mov	r0, r4
   22dda:	f8c8 3000 	str.w	r3, [r8]
   22dde:	f7fb fb7d 	bl	1e4dc <rpc_ip_client_request_send>
   22de2:	2800      	cmp	r0, #0
   22de4:	d156      	bne.n	22e94 <ip_interface_getaddrinfo+0x1ac>
   22de6:	f04f 33ff 	mov.w	r3, #4294967295
   22dea:	9303      	str	r3, [sp, #12]
   22dec:	4631      	mov	r1, r6
   22dee:	4620      	mov	r0, r4
   22df0:	f7f8 fc28 	bl	1b644 <bsd_os_timedwait>
   22df4:	f8d8 3000 	ldr.w	r3, [r8]
   22df8:	2b01      	cmp	r3, #1
   22dfa:	d0f7      	beq.n	22dec <ip_interface_getaddrinfo+0x104>
   22dfc:	4b31      	ldr	r3, [pc, #196]	; (22ec4 <ip_interface_getaddrinfo+0x1dc>)
   22dfe:	6818      	ldr	r0, [r3, #0]
   22e00:	2800      	cmp	r0, #0
   22e02:	d13b      	bne.n	22e7c <ip_interface_getaddrinfo+0x194>
   22e04:	4b2e      	ldr	r3, [pc, #184]	; (22ec0 <ip_interface_getaddrinfo+0x1d8>)
   22e06:	9a01      	ldr	r2, [sp, #4]
   22e08:	681b      	ldr	r3, [r3, #0]
   22e0a:	6013      	str	r3, [r2, #0]
   22e0c:	e00c      	b.n	22e28 <ip_interface_getaddrinfo+0x140>
   22e0e:	46bb      	mov	fp, r7
   22e10:	e79e      	b.n	22d50 <ip_interface_getaddrinfo+0x68>
   22e12:	9c03      	ldr	r4, [sp, #12]
   22e14:	2c00      	cmp	r4, #0
   22e16:	d1bd      	bne.n	22d94 <ip_interface_getaddrinfo+0xac>
   22e18:	200c      	movs	r0, #12
   22e1a:	2300      	movs	r3, #0
   22e1c:	f8c8 3000 	str.w	r3, [r8]
   22e20:	b005      	add	sp, #20
   22e22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   22e26:	2073      	movs	r0, #115	; 0x73
   22e28:	b005      	add	sp, #20
   22e2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   22e2e:	2016      	movs	r0, #22
   22e30:	b005      	add	sp, #20
   22e32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   22e36:	6891      	ldr	r1, [r2, #8]
   22e38:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   22e3c:	d18e      	bne.n	22d5c <ip_interface_getaddrinfo+0x74>
   22e3e:	f240 2102 	movw	r1, #514	; 0x202
   22e42:	68d0      	ldr	r0, [r2, #12]
   22e44:	4288      	cmp	r0, r1
   22e46:	d189      	bne.n	22d5c <ip_interface_getaddrinfo+0x74>
   22e48:	6991      	ldr	r1, [r2, #24]
   22e4a:	2900      	cmp	r1, #0
   22e4c:	d086      	beq.n	22d5c <ip_interface_getaddrinfo+0x74>
   22e4e:	6868      	ldr	r0, [r5, #4]
   22e50:	f7fe f9dc 	bl	2120c <pdn_interface_pdn_id_get>
   22e54:	1c43      	adds	r3, r0, #1
   22e56:	d081      	beq.n	22d5c <ip_interface_getaddrinfo+0x74>
   22e58:	4602      	mov	r2, r0
   22e5a:	e781      	b.n	22d60 <ip_interface_getaddrinfo+0x78>
   22e5c:	68a9      	ldr	r1, [r5, #8]
   22e5e:	2902      	cmp	r1, #2
   22e60:	f8c9 1000 	str.w	r1, [r9]
   22e64:	d006      	beq.n	22e74 <ip_interface_getaddrinfo+0x18c>
   22e66:	2a05      	cmp	r2, #5
   22e68:	d0a2      	beq.n	22db0 <ip_interface_getaddrinfo+0xc8>
   22e6a:	2a0a      	cmp	r2, #10
   22e6c:	bf14      	ite	ne
   22e6e:	2201      	movne	r2, #1
   22e70:	2202      	moveq	r2, #2
   22e72:	e79d      	b.n	22db0 <ip_interface_getaddrinfo+0xc8>
   22e74:	2102      	movs	r1, #2
   22e76:	f8ca 1000 	str.w	r1, [sl]
   22e7a:	e7f4      	b.n	22e66 <ip_interface_getaddrinfo+0x17e>
   22e7c:	4b11      	ldr	r3, [pc, #68]	; (22ec4 <ip_interface_getaddrinfo+0x1dc>)
   22e7e:	6818      	ldr	r0, [r3, #0]
   22e80:	2800      	cmp	r0, #0
   22e82:	d0d1      	beq.n	22e28 <ip_interface_getaddrinfo+0x140>
   22e84:	e7c9      	b.n	22e1a <ip_interface_getaddrinfo+0x132>
   22e86:	4629      	mov	r1, r5
   22e88:	2210      	movs	r2, #16
   22e8a:	f104 0014 	add.w	r0, r4, #20
   22e8e:	f00c fa81 	bl	2f394 <memset>
   22e92:	e794      	b.n	22dbe <ip_interface_getaddrinfo+0xd6>
   22e94:	2023      	movs	r0, #35	; 0x23
   22e96:	e7c0      	b.n	22e1a <ip_interface_getaddrinfo+0x132>
   22e98:	202f      	movs	r0, #47	; 0x2f
   22e9a:	f7f8 fc67 	bl	1b76c <bsd_os_errno_set>
   22e9e:	68a2      	ldr	r2, [r4, #8]
   22ea0:	3210      	adds	r2, #16
   22ea2:	60a2      	str	r2, [r4, #8]
   22ea4:	b917      	cbnz	r7, 22eac <ip_interface_getaddrinfo+0x1c4>
   22ea6:	f04f 30ff 	mov.w	r0, #4294967295
   22eaa:	e7b6      	b.n	22e1a <ip_interface_getaddrinfo+0x132>
   22eac:	6820      	ldr	r0, [r4, #0]
   22eae:	2800      	cmp	r0, #0
   22eb0:	d0f9      	beq.n	22ea6 <ip_interface_getaddrinfo+0x1be>
   22eb2:	465a      	mov	r2, fp
   22eb4:	4639      	mov	r1, r7
   22eb6:	f00c fa4d 	bl	2f354 <memcpy>
   22eba:	e7f4      	b.n	22ea6 <ip_interface_getaddrinfo+0x1be>
   22ebc:	2002d48e 	.word	0x2002d48e
   22ec0:	20028ea8 	.word	0x20028ea8
   22ec4:	20028ea0 	.word	0x20028ea0
   22ec8:	20028e98 	.word	0x20028e98
   22ecc:	20028e9c 	.word	0x20028e9c
   22ed0:	20028ea4 	.word	0x20028ea4

00022ed4 <ip_interface_freeaddrinfo>:
   22ed4:	b538      	push	{r3, r4, r5, lr}
   22ed6:	4c0b      	ldr	r4, [pc, #44]	; (22f04 <ip_interface_freeaddrinfo+0x30>)
   22ed8:	6823      	ldr	r3, [r4, #0]
   22eda:	2b02      	cmp	r3, #2
   22edc:	d000      	beq.n	22ee0 <ip_interface_freeaddrinfo+0xc>
   22ede:	bd38      	pop	{r3, r4, r5, pc}
   22ee0:	b130      	cbz	r0, 22ef0 <ip_interface_freeaddrinfo+0x1c>
   22ee2:	4605      	mov	r5, r0
   22ee4:	6940      	ldr	r0, [r0, #20]
   22ee6:	f7fb fab7 	bl	1e458 <nrf_free>
   22eea:	4628      	mov	r0, r5
   22eec:	f7fb fab4 	bl	1e458 <nrf_free>
   22ef0:	2300      	movs	r3, #0
   22ef2:	4a05      	ldr	r2, [pc, #20]	; (22f08 <ip_interface_freeaddrinfo+0x34>)
   22ef4:	4905      	ldr	r1, [pc, #20]	; (22f0c <ip_interface_freeaddrinfo+0x38>)
   22ef6:	6023      	str	r3, [r4, #0]
   22ef8:	6013      	str	r3, [r2, #0]
   22efa:	6808      	ldr	r0, [r1, #0]
   22efc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   22f00:	f7fb bb0a 	b.w	1e518 <rpc_ip_client_data_free>
   22f04:	20028ea4 	.word	0x20028ea4
   22f08:	20028ea0 	.word	0x20028ea0
   22f0c:	20028eac 	.word	0x20028eac

00022f10 <rpc_ip_event_handler>:
   22f10:	f248 030d 	movw	r3, #32781	; 0x800d
   22f14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   22f18:	4299      	cmp	r1, r3
   22f1a:	b089      	sub	sp, #36	; 0x24
   22f1c:	4605      	mov	r5, r0
   22f1e:	d062      	beq.n	22fe6 <rpc_ip_event_handler+0xd6>
   22f20:	f248 030f 	movw	r3, #32783	; 0x800f
   22f24:	4299      	cmp	r1, r3
   22f26:	460c      	mov	r4, r1
   22f28:	d04b      	beq.n	22fc2 <rpc_ip_event_handler+0xb2>
   22f2a:	f401 4310 	and.w	r3, r1, #36864	; 0x9000
   22f2e:	f5b3 4f10 	cmp.w	r3, #36864	; 0x9000
   22f32:	68c0      	ldr	r0, [r0, #12]
   22f34:	d07b      	beq.n	2302e <rpc_ip_event_handler+0x11e>
   22f36:	0c07      	lsrs	r7, r0, #16
   22f38:	4638      	mov	r0, r7
   22f3a:	f000 fba1 	bl	23680 <interface_socket_from_handle_get>
   22f3e:	4606      	mov	r6, r0
   22f40:	2800      	cmp	r0, #0
   22f42:	d05f      	beq.n	23004 <rpc_ip_event_handler+0xf4>
   22f44:	4601      	mov	r1, r0
   22f46:	4623      	mov	r3, r4
   22f48:	462a      	mov	r2, r5
   22f4a:	4638      	mov	r0, r7
   22f4c:	f7fb ff1c 	bl	1ed88 <tls_rpc_ip_event_handler>
   22f50:	2800      	cmp	r0, #0
   22f52:	d053      	beq.n	22ffc <rpc_ip_event_handler+0xec>
   22f54:	f248 0307 	movw	r3, #32775	; 0x8007
   22f58:	429c      	cmp	r4, r3
   22f5a:	d97d      	bls.n	23058 <rpc_ip_event_handler+0x148>
   22f5c:	f248 030c 	movw	r3, #32780	; 0x800c
   22f60:	429c      	cmp	r4, r3
   22f62:	d068      	beq.n	23036 <rpc_ip_event_handler+0x126>
   22f64:	f240 8119 	bls.w	2319a <rpc_ip_event_handler+0x28a>
   22f68:	f249 0302 	movw	r3, #36866	; 0x9002
   22f6c:	429c      	cmp	r4, r3
   22f6e:	f000 8195 	beq.w	2329c <rpc_ip_event_handler+0x38c>
   22f72:	f249 0303 	movw	r3, #36867	; 0x9003
   22f76:	429c      	cmp	r4, r3
   22f78:	f000 81aa 	beq.w	232d0 <rpc_ip_event_handler+0x3c0>
   22f7c:	f249 0301 	movw	r3, #36865	; 0x9001
   22f80:	429c      	cmp	r4, r3
   22f82:	d13f      	bne.n	23004 <rpc_ip_event_handler+0xf4>
   22f84:	6834      	ldr	r4, [r6, #0]
   22f86:	f414 1480 	ands.w	r4, r4, #1048576	; 0x100000
   22f8a:	f000 81c2 	beq.w	23312 <rpc_ip_event_handler+0x402>
   22f8e:	68ab      	ldr	r3, [r5, #8]
   22f90:	2b04      	cmp	r3, #4
   22f92:	f200 81ff 	bhi.w	23394 <rpc_ip_event_handler+0x484>
   22f96:	2400      	movs	r4, #0
   22f98:	4627      	mov	r7, r4
   22f9a:	6829      	ldr	r1, [r5, #0]
   22f9c:	686a      	ldr	r2, [r5, #4]
   22f9e:	e9cd 7406 	strd	r7, r4, [sp, #24]
   22fa2:	e9cd 1204 	strd	r1, r2, [sp, #16]
   22fa6:	69f0      	ldr	r0, [r6, #28]
   22fa8:	a904      	add	r1, sp, #16
   22faa:	6803      	ldr	r3, [r0, #0]
   22fac:	685b      	ldr	r3, [r3, #4]
   22fae:	4798      	blx	r3
   22fb0:	3001      	adds	r0, #1
   22fb2:	f000 81db 	beq.w	2336c <rpc_ip_event_handler+0x45c>
   22fb6:	6833      	ldr	r3, [r6, #0]
   22fb8:	2000      	movs	r0, #0
   22fba:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   22fbe:	6033      	str	r3, [r6, #0]
   22fc0:	e00e      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   22fc2:	6943      	ldr	r3, [r0, #20]
   22fc4:	2001      	movs	r0, #1
   22fc6:	2b10      	cmp	r3, #16
   22fc8:	49b7      	ldr	r1, [pc, #732]	; (232a8 <rpc_ip_event_handler+0x398>)
   22fca:	bf88      	it	hi
   22fcc:	222d      	movhi	r2, #45	; 0x2d
   22fce:	7008      	strb	r0, [r1, #0]
   22fd0:	f04f 0000 	mov.w	r0, #0
   22fd4:	bf9c      	itt	ls
   22fd6:	4ab5      	ldrls	r2, [pc, #724]	; (232ac <rpc_ip_event_handler+0x39c>)
   22fd8:	f852 2023 	ldrls.w	r2, [r2, r3, lsl #2]
   22fdc:	4bb4      	ldr	r3, [pc, #720]	; (232b0 <rpc_ip_event_handler+0x3a0>)
   22fde:	601a      	str	r2, [r3, #0]
   22fe0:	b009      	add	sp, #36	; 0x24
   22fe2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   22fe6:	f8df 92dc 	ldr.w	r9, [pc, #732]	; 232c4 <rpc_ip_event_handler+0x3b4>
   22fea:	6807      	ldr	r7, [r0, #0]
   22fec:	f8d9 3000 	ldr.w	r3, [r9]
   22ff0:	2b01      	cmp	r3, #1
   22ff2:	d00b      	beq.n	2300c <rpc_ip_event_handler+0xfc>
   22ff4:	b117      	cbz	r7, 22ffc <rpc_ip_event_handler+0xec>
   22ff6:	4638      	mov	r0, r7
   22ff8:	f7fb fa8e 	bl	1e518 <rpc_ip_client_data_free>
   22ffc:	2000      	movs	r0, #0
   22ffe:	b009      	add	sp, #36	; 0x24
   23000:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   23004:	6828      	ldr	r0, [r5, #0]
   23006:	2800      	cmp	r0, #0
   23008:	d1f6      	bne.n	22ff8 <rpc_ip_event_handler+0xe8>
   2300a:	e7f7      	b.n	22ffc <rpc_ip_event_handler+0xec>
   2300c:	6943      	ldr	r3, [r0, #20]
   2300e:	2b00      	cmp	r3, #0
   23010:	d046      	beq.n	230a0 <rpc_ip_event_handler+0x190>
   23012:	2b10      	cmp	r3, #16
   23014:	bf96      	itet	ls
   23016:	4aa5      	ldrls	r2, [pc, #660]	; (232ac <rpc_ip_event_handler+0x39c>)
   23018:	232d      	movhi	r3, #45	; 0x2d
   2301a:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
   2301e:	2202      	movs	r2, #2
   23020:	49a4      	ldr	r1, [pc, #656]	; (232b4 <rpc_ip_event_handler+0x3a4>)
   23022:	600b      	str	r3, [r1, #0]
   23024:	f8c9 2000 	str.w	r2, [r9]
   23028:	2f00      	cmp	r7, #0
   2302a:	d1e4      	bne.n	22ff6 <rpc_ip_event_handler+0xe6>
   2302c:	e7e6      	b.n	22ffc <rpc_ip_event_handler+0xec>
   2302e:	f000 fad5 	bl	235dc <interface_from_internal_id_search>
   23032:	4607      	mov	r7, r0
   23034:	e780      	b.n	22f38 <rpc_ip_event_handler+0x28>
   23036:	6833      	ldr	r3, [r6, #0]
   23038:	b29b      	uxth	r3, r3
   2303a:	2b08      	cmp	r3, #8
   2303c:	d1de      	bne.n	22ffc <rpc_ip_event_handler+0xec>
   2303e:	696b      	ldr	r3, [r5, #20]
   23040:	2b00      	cmp	r3, #0
   23042:	f000 819c 	beq.w	2337e <rpc_ip_event_handler+0x46e>
   23046:	2b10      	cmp	r3, #16
   23048:	f200 8161 	bhi.w	2330e <rpc_ip_event_handler+0x3fe>
   2304c:	4a97      	ldr	r2, [pc, #604]	; (232ac <rpc_ip_event_handler+0x39c>)
   2304e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   23052:	6073      	str	r3, [r6, #4]
   23054:	2000      	movs	r0, #0
   23056:	e7c3      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   23058:	f248 0306 	movw	r3, #32774	; 0x8006
   2305c:	429c      	cmp	r4, r3
   2305e:	f080 810d 	bcs.w	2327c <rpc_ip_event_handler+0x36c>
   23062:	f248 0302 	movw	r3, #32770	; 0x8002
   23066:	429c      	cmp	r4, r3
   23068:	f000 80f0 	beq.w	2324c <rpc_ip_event_handler+0x33c>
   2306c:	f240 80be 	bls.w	231ec <rpc_ip_event_handler+0x2dc>
   23070:	f248 0303 	movw	r3, #32771	; 0x8003
   23074:	429c      	cmp	r4, r3
   23076:	f000 80ca 	beq.w	2320e <rpc_ip_event_handler+0x2fe>
   2307a:	f248 0305 	movw	r3, #32773	; 0x8005
   2307e:	429c      	cmp	r4, r3
   23080:	d1c0      	bne.n	23004 <rpc_ip_event_handler+0xf4>
   23082:	6833      	ldr	r3, [r6, #0]
   23084:	b29b      	uxth	r3, r3
   23086:	2b03      	cmp	r3, #3
   23088:	d1b8      	bne.n	22ffc <rpc_ip_event_handler+0xec>
   2308a:	696b      	ldr	r3, [r5, #20]
   2308c:	2b00      	cmp	r3, #0
   2308e:	d1da      	bne.n	23046 <rpc_ip_event_handler+0x136>
   23090:	6833      	ldr	r3, [r6, #0]
   23092:	2000      	movs	r0, #0
   23094:	0c1b      	lsrs	r3, r3, #16
   23096:	041b      	lsls	r3, r3, #16
   23098:	f043 0304 	orr.w	r3, r3, #4
   2309c:	6033      	str	r3, [r6, #0]
   2309e:	e79f      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   230a0:	4b85      	ldr	r3, [pc, #532]	; (232b8 <rpc_ip_event_handler+0x3a8>)
   230a2:	601f      	str	r7, [r3, #0]
   230a4:	6984      	ldr	r4, [r0, #24]
   230a6:	0163      	lsls	r3, r4, #5
   230a8:	4618      	mov	r0, r3
   230aa:	9303      	str	r3, [sp, #12]
   230ac:	f7fb f9ca 	bl	1e444 <nrf_malloc>
   230b0:	9002      	str	r0, [sp, #8]
   230b2:	2800      	cmp	r0, #0
   230b4:	f000 808a 	beq.w	231cc <rpc_ip_event_handler+0x2bc>
   230b8:	00e5      	lsls	r5, r4, #3
   230ba:	1928      	adds	r0, r5, r4
   230bc:	0080      	lsls	r0, r0, #2
   230be:	f7fb f9c1 	bl	1e444 <nrf_malloc>
   230c2:	2800      	cmp	r0, #0
   230c4:	f000 811f 	beq.w	23306 <rpc_ip_event_handler+0x3f6>
   230c8:	2c00      	cmp	r4, #0
   230ca:	d05e      	beq.n	2318a <rpc_ip_event_handler+0x27a>
   230cc:	3510      	adds	r5, #16
   230ce:	1943      	adds	r3, r0, r5
   230d0:	9301      	str	r3, [sp, #4]
   230d2:	9b02      	ldr	r3, [sp, #8]
   230d4:	2404      	movs	r4, #4
   230d6:	f8df a1f0 	ldr.w	sl, [pc, #496]	; 232c8 <rpc_ip_event_handler+0x3b8>
   230da:	f8df b1f0 	ldr.w	fp, [pc, #496]	; 232cc <rpc_ip_event_handler+0x3bc>
   230de:	f100 0810 	add.w	r8, r0, #16
   230e2:	f103 0620 	add.w	r6, r3, #32
   230e6:	e01d      	b.n	23124 <rpc_ip_event_handler+0x214>
   230e8:	220a      	movs	r2, #10
   230ea:	f848 2c0c 	str.w	r2, [r8, #-12]
   230ee:	f04f 0224 	mov.w	r2, #36	; 0x24
   230f2:	4640      	mov	r0, r8
   230f4:	f808 2c10 	strb.w	r2, [r8, #-16]
   230f8:	f828 3c08 	strh.w	r3, [r8, #-8]
   230fc:	f856 2c10 	ldr.w	r2, [r6, #-16]
   23100:	f00c f928 	bl	2f354 <memcpy>
   23104:	f856 3c10 	ldr.w	r3, [r6, #-16]
   23108:	f108 0808 	add.w	r8, r8, #8
   2310c:	441c      	add	r4, r3
   2310e:	193b      	adds	r3, r7, r4
   23110:	f846 3c08 	str.w	r3, [r6, #-8]
   23114:	9b01      	ldr	r3, [sp, #4]
   23116:	f846 6c04 	str.w	r6, [r6, #-4]
   2311a:	4598      	cmp	r8, r3
   2311c:	442c      	add	r4, r5
   2311e:	f106 0620 	add.w	r6, r6, #32
   23122:	d02c      	beq.n	2317e <rpc_ip_event_handler+0x26e>
   23124:	593b      	ldr	r3, [r7, r4]
   23126:	193a      	adds	r2, r7, r4
   23128:	f846 3c20 	str.w	r3, [r6, #-32]
   2312c:	6853      	ldr	r3, [r2, #4]
   2312e:	f8da 1000 	ldr.w	r1, [sl]
   23132:	2b02      	cmp	r3, #2
   23134:	bf14      	ite	ne
   23136:	2002      	movne	r0, #2
   23138:	200a      	moveq	r0, #10
   2313a:	f8db 3000 	ldr.w	r3, [fp]
   2313e:	e946 0107 	strd	r0, r1, [r6, #-28]
   23142:	f846 3c14 	str.w	r3, [r6, #-20]
   23146:	8a10      	ldrh	r0, [r2, #16]
   23148:	f1a8 0310 	sub.w	r3, r8, #16
   2314c:	f846 0c10 	str.w	r0, [r6, #-16]
   23150:	8a55      	ldrh	r5, [r2, #18]
   23152:	f846 3c0c 	str.w	r3, [r6, #-12]
   23156:	4b59      	ldr	r3, [pc, #356]	; (232bc <rpc_ip_event_handler+0x3ac>)
   23158:	3414      	adds	r4, #20
   2315a:	2804      	cmp	r0, #4
   2315c:	eb07 0104 	add.w	r1, r7, r4
   23160:	881b      	ldrh	r3, [r3, #0]
   23162:	d1c1      	bne.n	230e8 <rpc_ip_event_handler+0x1d8>
   23164:	2210      	movs	r2, #16
   23166:	2002      	movs	r0, #2
   23168:	f828 3c08 	strh.w	r3, [r8, #-8]
   2316c:	f848 0c0c 	str.w	r0, [r8, #-12]
   23170:	f808 2c10 	strb.w	r2, [r8, #-16]
   23174:	f856 2c10 	ldr.w	r2, [r6, #-16]
   23178:	f1a8 0004 	sub.w	r0, r8, #4
   2317c:	e7c0      	b.n	23100 <rpc_ip_event_handler+0x1f0>
   2317e:	2200      	movs	r2, #0
   23180:	e9dd 1302 	ldrd	r1, r3, [sp, #8]
   23184:	440b      	add	r3, r1
   23186:	f843 2c04 	str.w	r2, [r3, #-4]
   2318a:	2202      	movs	r2, #2
   2318c:	4b4c      	ldr	r3, [pc, #304]	; (232c0 <rpc_ip_event_handler+0x3b0>)
   2318e:	f8c9 2000 	str.w	r2, [r9]
   23192:	9a02      	ldr	r2, [sp, #8]
   23194:	2000      	movs	r0, #0
   23196:	601a      	str	r2, [r3, #0]
   23198:	e722      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   2319a:	f248 0308 	movw	r3, #32776	; 0x8008
   2319e:	429c      	cmp	r4, r3
   231a0:	d045      	beq.n	2322e <rpc_ip_event_handler+0x31e>
   231a2:	f248 0309 	movw	r3, #32777	; 0x8009
   231a6:	429c      	cmp	r4, r3
   231a8:	f47f af2c 	bne.w	23004 <rpc_ip_event_handler+0xf4>
   231ac:	6833      	ldr	r3, [r6, #0]
   231ae:	b29b      	uxth	r3, r3
   231b0:	2b0d      	cmp	r3, #13
   231b2:	f47f af23 	bne.w	22ffc <rpc_ip_event_handler+0xec>
   231b6:	6968      	ldr	r0, [r5, #20]
   231b8:	2800      	cmp	r0, #0
   231ba:	f000 80d9 	beq.w	23370 <rpc_ip_event_handler+0x460>
   231be:	2810      	cmp	r0, #16
   231c0:	f200 80a5 	bhi.w	2330e <rpc_ip_event_handler+0x3fe>
   231c4:	4b39      	ldr	r3, [pc, #228]	; (232ac <rpc_ip_event_handler+0x39c>)
   231c6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   231ca:	e742      	b.n	23052 <rpc_ip_event_handler+0x142>
   231cc:	f7fb f944 	bl	1e458 <nrf_free>
   231d0:	200c      	movs	r0, #12
   231d2:	2302      	movs	r3, #2
   231d4:	4937      	ldr	r1, [pc, #220]	; (232b4 <rpc_ip_event_handler+0x3a4>)
   231d6:	4a3a      	ldr	r2, [pc, #232]	; (232c0 <rpc_ip_event_handler+0x3b0>)
   231d8:	6008      	str	r0, [r1, #0]
   231da:	682f      	ldr	r7, [r5, #0]
   231dc:	9902      	ldr	r1, [sp, #8]
   231de:	f8c9 3000 	str.w	r3, [r9]
   231e2:	6011      	str	r1, [r2, #0]
   231e4:	2f00      	cmp	r7, #0
   231e6:	f47f af06 	bne.w	22ff6 <rpc_ip_event_handler+0xe6>
   231ea:	e707      	b.n	22ffc <rpc_ip_event_handler+0xec>
   231ec:	f248 0301 	movw	r3, #32769	; 0x8001
   231f0:	429c      	cmp	r4, r3
   231f2:	f47f af07 	bne.w	23004 <rpc_ip_event_handler+0xf4>
   231f6:	6833      	ldr	r3, [r6, #0]
   231f8:	2b01      	cmp	r3, #1
   231fa:	f47f aeff 	bne.w	22ffc <rpc_ip_event_handler+0xec>
   231fe:	6968      	ldr	r0, [r5, #20]
   23200:	2800      	cmp	r0, #0
   23202:	d1dc      	bne.n	231be <rpc_ip_event_handler+0x2ae>
   23204:	2302      	movs	r3, #2
   23206:	6033      	str	r3, [r6, #0]
   23208:	69ab      	ldr	r3, [r5, #24]
   2320a:	61b3      	str	r3, [r6, #24]
   2320c:	e6e8      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   2320e:	6833      	ldr	r3, [r6, #0]
   23210:	025b      	lsls	r3, r3, #9
   23212:	f57f aef3 	bpl.w	22ffc <rpc_ip_event_handler+0xec>
   23216:	6968      	ldr	r0, [r5, #20]
   23218:	2800      	cmp	r0, #0
   2321a:	f000 80a0 	beq.w	2335e <rpc_ip_event_handler+0x44e>
   2321e:	2810      	cmp	r0, #16
   23220:	bf8e      	itee	hi
   23222:	232d      	movhi	r3, #45	; 0x2d
   23224:	4b21      	ldrls	r3, [pc, #132]	; (232ac <rpc_ip_event_handler+0x39c>)
   23226:	f853 3020 	ldrls.w	r3, [r3, r0, lsl #2]
   2322a:	6073      	str	r3, [r6, #4]
   2322c:	e6e6      	b.n	22ffc <rpc_ip_event_handler+0xec>
   2322e:	6833      	ldr	r3, [r6, #0]
   23230:	b29b      	uxth	r3, r3
   23232:	2b06      	cmp	r3, #6
   23234:	f47f aee2 	bne.w	22ffc <rpc_ip_event_handler+0xec>
   23238:	6968      	ldr	r0, [r5, #20]
   2323a:	2800      	cmp	r0, #0
   2323c:	d1bf      	bne.n	231be <rpc_ip_event_handler+0x2ae>
   2323e:	6833      	ldr	r3, [r6, #0]
   23240:	0c1b      	lsrs	r3, r3, #16
   23242:	041b      	lsls	r3, r3, #16
   23244:	f043 0307 	orr.w	r3, r3, #7
   23248:	6033      	str	r3, [r6, #0]
   2324a:	e6c9      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   2324c:	6833      	ldr	r3, [r6, #0]
   2324e:	0099      	lsls	r1, r3, #2
   23250:	f57f aed4 	bpl.w	22ffc <rpc_ip_event_handler+0xec>
   23254:	6833      	ldr	r3, [r6, #0]
   23256:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   2325a:	6033      	str	r3, [r6, #0]
   2325c:	6968      	ldr	r0, [r5, #20]
   2325e:	2800      	cmp	r0, #0
   23260:	d06e      	beq.n	23340 <rpc_ip_event_handler+0x430>
   23262:	2810      	cmp	r0, #16
   23264:	f200 8080 	bhi.w	23368 <rpc_ip_event_handler+0x458>
   23268:	4b10      	ldr	r3, [pc, #64]	; (232ac <rpc_ip_event_handler+0x39c>)
   2326a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   2326e:	6073      	str	r3, [r6, #4]
   23270:	6833      	ldr	r3, [r6, #0]
   23272:	2000      	movs	r0, #0
   23274:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   23278:	6033      	str	r3, [r6, #0]
   2327a:	e6b1      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   2327c:	6833      	ldr	r3, [r6, #0]
   2327e:	029a      	lsls	r2, r3, #10
   23280:	f57f aebc 	bpl.w	22ffc <rpc_ip_event_handler+0xec>
   23284:	696b      	ldr	r3, [r5, #20]
   23286:	2b00      	cmp	r3, #0
   23288:	d051      	beq.n	2332e <rpc_ip_event_handler+0x41e>
   2328a:	2b6b      	cmp	r3, #107	; 0x6b
   2328c:	f000 8086 	beq.w	2339c <rpc_ip_event_handler+0x48c>
   23290:	2b10      	cmp	r3, #16
   23292:	d869      	bhi.n	23368 <rpc_ip_event_handler+0x458>
   23294:	4a05      	ldr	r2, [pc, #20]	; (232ac <rpc_ip_event_handler+0x39c>)
   23296:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   2329a:	e7e8      	b.n	2326e <rpc_ip_event_handler+0x35e>
   2329c:	6833      	ldr	r3, [r6, #0]
   2329e:	b29b      	uxth	r3, r3
   232a0:	2b07      	cmp	r3, #7
   232a2:	f47f aeab 	bne.w	22ffc <rpc_ip_event_handler+0xec>
   232a6:	e686      	b.n	22fb6 <rpc_ip_event_handler+0xa6>
   232a8:	200314bc 	.word	0x200314bc
   232ac:	00030df4 	.word	0x00030df4
   232b0:	20028ed4 	.word	0x20028ed4
   232b4:	20028ea0 	.word	0x20028ea0
   232b8:	20028eac 	.word	0x20028eac
   232bc:	2002d48e 	.word	0x2002d48e
   232c0:	20028ea8 	.word	0x20028ea8
   232c4:	20028ea4 	.word	0x20028ea4
   232c8:	20028e9c 	.word	0x20028e9c
   232cc:	20028e98 	.word	0x20028e98
   232d0:	6833      	ldr	r3, [r6, #0]
   232d2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
   232d6:	6033      	str	r3, [r6, #0]
   232d8:	6833      	ldr	r3, [r6, #0]
   232da:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   232de:	6033      	str	r3, [r6, #0]
   232e0:	6833      	ldr	r3, [r6, #0]
   232e2:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   232e6:	6033      	str	r3, [r6, #0]
   232e8:	692b      	ldr	r3, [r5, #16]
   232ea:	2b6c      	cmp	r3, #108	; 0x6c
   232ec:	d016      	beq.n	2331c <rpc_ip_event_handler+0x40c>
   232ee:	2b10      	cmp	r3, #16
   232f0:	bf8c      	ite	hi
   232f2:	232d      	movhi	r3, #45	; 0x2d
   232f4:	4a46      	ldrls	r2, [pc, #280]	; (23410 <rpc_ip_event_handler+0x500>)
   232f6:	f04f 0000 	mov.w	r0, #0
   232fa:	bf98      	it	ls
   232fc:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
   23300:	6073      	str	r3, [r6, #4]
   23302:	60b3      	str	r3, [r6, #8]
   23304:	e66c      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   23306:	220c      	movs	r2, #12
   23308:	4b42      	ldr	r3, [pc, #264]	; (23414 <rpc_ip_event_handler+0x504>)
   2330a:	601a      	str	r2, [r3, #0]
   2330c:	e73d      	b.n	2318a <rpc_ip_event_handler+0x27a>
   2330e:	232d      	movs	r3, #45	; 0x2d
   23310:	e69f      	b.n	23052 <rpc_ip_event_handler+0x142>
   23312:	6828      	ldr	r0, [r5, #0]
   23314:	f7fb f900 	bl	1e518 <rpc_ip_client_data_free>
   23318:	4620      	mov	r0, r4
   2331a:	e661      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   2331c:	2239      	movs	r2, #57	; 0x39
   2331e:	6833      	ldr	r3, [r6, #0]
   23320:	2000      	movs	r0, #0
   23322:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   23326:	6033      	str	r3, [r6, #0]
   23328:	6072      	str	r2, [r6, #4]
   2332a:	60b2      	str	r2, [r6, #8]
   2332c:	e658      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   2332e:	6833      	ldr	r3, [r6, #0]
   23330:	4a39      	ldr	r2, [pc, #228]	; (23418 <rpc_ip_event_handler+0x508>)
   23332:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   23336:	6033      	str	r3, [r6, #0]
   23338:	2001      	movs	r0, #1
   2333a:	f842 5027 	str.w	r5, [r2, r7, lsl #2]
   2333e:	e64f      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   23340:	6833      	ldr	r3, [r6, #0]
   23342:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   23346:	6033      	str	r3, [r6, #0]
   23348:	6833      	ldr	r3, [r6, #0]
   2334a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   2334e:	6033      	str	r3, [r6, #0]
   23350:	6833      	ldr	r3, [r6, #0]
   23352:	0c1b      	lsrs	r3, r3, #16
   23354:	041b      	lsls	r3, r3, #16
   23356:	f043 0305 	orr.w	r3, r3, #5
   2335a:	6033      	str	r3, [r6, #0]
   2335c:	e640      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   2335e:	6833      	ldr	r3, [r6, #0]
   23360:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   23364:	6033      	str	r3, [r6, #0]
   23366:	e63b      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   23368:	232d      	movs	r3, #45	; 0x2d
   2336a:	e780      	b.n	2326e <rpc_ip_event_handler+0x35e>
   2336c:	2002      	movs	r0, #2
   2336e:	e637      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   23370:	6833      	ldr	r3, [r6, #0]
   23372:	0c1b      	lsrs	r3, r3, #16
   23374:	041b      	lsls	r3, r3, #16
   23376:	f043 030e 	orr.w	r3, r3, #14
   2337a:	6033      	str	r3, [r6, #0]
   2337c:	e630      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   2337e:	4b26      	ldr	r3, [pc, #152]	; (23418 <rpc_ip_event_handler+0x508>)
   23380:	2001      	movs	r0, #1
   23382:	f843 5027 	str.w	r5, [r3, r7, lsl #2]
   23386:	6833      	ldr	r3, [r6, #0]
   23388:	0c1b      	lsrs	r3, r3, #16
   2338a:	041b      	lsls	r3, r3, #16
   2338c:	f043 0309 	orr.w	r3, r3, #9
   23390:	6033      	str	r3, [r6, #0]
   23392:	e625      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   23394:	8a6c      	ldrh	r4, [r5, #18]
   23396:	b934      	cbnz	r4, 233a6 <rpc_ip_event_handler+0x496>
   23398:	4627      	mov	r7, r4
   2339a:	e5fe      	b.n	22f9a <rpc_ip_event_handler+0x8a>
   2339c:	6933      	ldr	r3, [r6, #16]
   2339e:	2b01      	cmp	r3, #1
   233a0:	d012      	beq.n	233c8 <rpc_ip_event_handler+0x4b8>
   233a2:	230c      	movs	r3, #12
   233a4:	e763      	b.n	2326e <rpc_ip_event_handler+0x35e>
   233a6:	2024      	movs	r0, #36	; 0x24
   233a8:	f7fb f84c 	bl	1e444 <nrf_malloc>
   233ac:	4607      	mov	r7, r0
   233ae:	b358      	cbz	r0, 23408 <rpc_ip_event_handler+0x4f8>
   233b0:	8a6a      	ldrh	r2, [r5, #18]
   233b2:	2a10      	cmp	r2, #16
   233b4:	d01c      	beq.n	233f0 <rpc_ip_event_handler+0x4e0>
   233b6:	2a04      	cmp	r2, #4
   233b8:	d00e      	beq.n	233d8 <rpc_ip_event_handler+0x4c8>
   233ba:	6828      	ldr	r0, [r5, #0]
   233bc:	f7fb f8ac 	bl	1e518 <rpc_ip_client_data_free>
   233c0:	4638      	mov	r0, r7
   233c2:	f7fb f849 	bl	1e458 <nrf_free>
   233c6:	e619      	b.n	22ffc <rpc_ip_event_handler+0xec>
   233c8:	220c      	movs	r2, #12
   233ca:	6833      	ldr	r3, [r6, #0]
   233cc:	2000      	movs	r0, #0
   233ce:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   233d2:	6033      	str	r3, [r6, #0]
   233d4:	6072      	str	r2, [r6, #4]
   233d6:	e603      	b.n	22fe0 <rpc_ip_event_handler+0xd0>
   233d8:	2302      	movs	r3, #2
   233da:	2410      	movs	r4, #16
   233dc:	6043      	str	r3, [r0, #4]
   233de:	7004      	strb	r4, [r0, #0]
   233e0:	8a2b      	ldrh	r3, [r5, #16]
   233e2:	f105 0114 	add.w	r1, r5, #20
   233e6:	8103      	strh	r3, [r0, #8]
   233e8:	300c      	adds	r0, #12
   233ea:	f00b ffb3 	bl	2f354 <memcpy>
   233ee:	e5d4      	b.n	22f9a <rpc_ip_event_handler+0x8a>
   233f0:	230a      	movs	r3, #10
   233f2:	2424      	movs	r4, #36	; 0x24
   233f4:	6043      	str	r3, [r0, #4]
   233f6:	7004      	strb	r4, [r0, #0]
   233f8:	8a2b      	ldrh	r3, [r5, #16]
   233fa:	f105 0114 	add.w	r1, r5, #20
   233fe:	8103      	strh	r3, [r0, #8]
   23400:	3010      	adds	r0, #16
   23402:	f00b ffa7 	bl	2f354 <memcpy>
   23406:	e5c8      	b.n	22f9a <rpc_ip_event_handler+0x8a>
   23408:	6828      	ldr	r0, [r5, #0]
   2340a:	f7fb f885 	bl	1e518 <rpc_ip_client_data_free>
   2340e:	e5f5      	b.n	22ffc <rpc_ip_event_handler+0xec>
   23410:	00030df4 	.word	0x00030df4
   23414:	20028ea0 	.word	0x20028ea0
   23418:	20028eb0 	.word	0x20028eb0

0002341c <interface_init>:
   2341c:	b508      	push	{r3, lr}
   2341e:	f44f 72a2 	mov.w	r2, #324	; 0x144
   23422:	2100      	movs	r1, #0
   23424:	4802      	ldr	r0, [pc, #8]	; (23430 <interface_init+0x14>)
   23426:	f00b ffb5 	bl	2f394 <memset>
   2342a:	2000      	movs	r0, #0
   2342c:	bd08      	pop	{r3, pc}
   2342e:	bf00      	nop
   23430:	200314c0 	.word	0x200314c0

00023434 <interface_socket_allocate>:
   23434:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   23436:	4b30      	ldr	r3, [pc, #192]	; (234f8 <interface_socket_allocate+0xc4>)
   23438:	4606      	mov	r6, r0
   2343a:	681d      	ldr	r5, [r3, #0]
   2343c:	4608      	mov	r0, r1
   2343e:	b31d      	cbz	r5, 23488 <interface_socket_allocate+0x54>
   23440:	6a5c      	ldr	r4, [r3, #36]	; 0x24
   23442:	2c00      	cmp	r4, #0
   23444:	d04a      	beq.n	234dc <interface_socket_allocate+0xa8>
   23446:	6c9c      	ldr	r4, [r3, #72]	; 0x48
   23448:	2c00      	cmp	r4, #0
   2344a:	d049      	beq.n	234e0 <interface_socket_allocate+0xac>
   2344c:	6edc      	ldr	r4, [r3, #108]	; 0x6c
   2344e:	2c00      	cmp	r4, #0
   23450:	d048      	beq.n	234e4 <interface_socket_allocate+0xb0>
   23452:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
   23456:	2900      	cmp	r1, #0
   23458:	d046      	beq.n	234e8 <interface_socket_allocate+0xb4>
   2345a:	f8d3 10b4 	ldr.w	r1, [r3, #180]	; 0xb4
   2345e:	b191      	cbz	r1, 23486 <interface_socket_allocate+0x52>
   23460:	f8d3 10d8 	ldr.w	r1, [r3, #216]	; 0xd8
   23464:	2900      	cmp	r1, #0
   23466:	d043      	beq.n	234f0 <interface_socket_allocate+0xbc>
   23468:	f8d3 10fc 	ldr.w	r1, [r3, #252]	; 0xfc
   2346c:	2900      	cmp	r1, #0
   2346e:	d041      	beq.n	234f4 <interface_socket_allocate+0xc0>
   23470:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
   23474:	2900      	cmp	r1, #0
   23476:	d039      	beq.n	234ec <interface_socket_allocate+0xb8>
   23478:	f04f 35ff 	mov.w	r5, #4294967295
   2347c:	2069      	movs	r0, #105	; 0x69
   2347e:	f7f8 f975 	bl	1b76c <bsd_os_errno_set>
   23482:	4628      	mov	r0, r5
   23484:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   23486:	2505      	movs	r5, #5
   23488:	f04f 0c01 	mov.w	ip, #1
   2348c:	f04f 37ff 	mov.w	r7, #4294967295
   23490:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   23494:	00a4      	lsls	r4, r4, #2
   23496:	f843 c004 	str.w	ip, [r3, r4]
   2349a:	441c      	add	r4, r3
   2349c:	4611      	mov	r1, r2
   2349e:	61a7      	str	r7, [r4, #24]
   234a0:	4622      	mov	r2, r4
   234a2:	f001 ffd1 	bl	25448 <packet_handler_create>
   234a6:	4603      	mov	r3, r0
   234a8:	61e0      	str	r0, [r4, #28]
   234aa:	b158      	cbz	r0, 234c4 <interface_socket_allocate+0x90>
   234ac:	681b      	ldr	r3, [r3, #0]
   234ae:	681b      	ldr	r3, [r3, #0]
   234b0:	4798      	blx	r3
   234b2:	b910      	cbnz	r0, 234ba <interface_socket_allocate+0x86>
   234b4:	6034      	str	r4, [r6, #0]
   234b6:	4628      	mov	r0, r5
   234b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   234ba:	69e0      	ldr	r0, [r4, #28]
   234bc:	f001 ffe4 	bl	25488 <packet_handler_delete>
   234c0:	2300      	movs	r3, #0
   234c2:	61e3      	str	r3, [r4, #28]
   234c4:	f04f 35ff 	mov.w	r5, #4294967295
   234c8:	2224      	movs	r2, #36	; 0x24
   234ca:	2100      	movs	r1, #0
   234cc:	4620      	mov	r0, r4
   234ce:	f00b ff61 	bl	2f394 <memset>
   234d2:	200c      	movs	r0, #12
   234d4:	f7f8 f94a 	bl	1b76c <bsd_os_errno_set>
   234d8:	4628      	mov	r0, r5
   234da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   234dc:	2501      	movs	r5, #1
   234de:	e7d3      	b.n	23488 <interface_socket_allocate+0x54>
   234e0:	2502      	movs	r5, #2
   234e2:	e7d1      	b.n	23488 <interface_socket_allocate+0x54>
   234e4:	2503      	movs	r5, #3
   234e6:	e7cf      	b.n	23488 <interface_socket_allocate+0x54>
   234e8:	2504      	movs	r5, #4
   234ea:	e7cd      	b.n	23488 <interface_socket_allocate+0x54>
   234ec:	2508      	movs	r5, #8
   234ee:	e7cb      	b.n	23488 <interface_socket_allocate+0x54>
   234f0:	2506      	movs	r5, #6
   234f2:	e7c9      	b.n	23488 <interface_socket_allocate+0x54>
   234f4:	2507      	movs	r5, #7
   234f6:	e7c7      	b.n	23488 <interface_socket_allocate+0x54>
   234f8:	200314c0 	.word	0x200314c0

000234fc <interface_socket_free>:
   234fc:	2808      	cmp	r0, #8
   234fe:	d900      	bls.n	23502 <interface_socket_free+0x6>
   23500:	4770      	bx	lr
   23502:	b510      	push	{r4, lr}
   23504:	4c07      	ldr	r4, [pc, #28]	; (23524 <interface_socket_free+0x28>)
   23506:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   2350a:	eb04 0480 	add.w	r4, r4, r0, lsl #2
   2350e:	69e0      	ldr	r0, [r4, #28]
   23510:	b108      	cbz	r0, 23516 <interface_socket_free+0x1a>
   23512:	f001 ffb9 	bl	25488 <packet_handler_delete>
   23516:	4620      	mov	r0, r4
   23518:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2351c:	2224      	movs	r2, #36	; 0x24
   2351e:	2100      	movs	r1, #0
   23520:	f00b bf38 	b.w	2f394 <memset>
   23524:	200314c0 	.word	0x200314c0

00023528 <interface_socket_packet_handler_update>:
   23528:	2808      	cmp	r0, #8
   2352a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2352e:	d81e      	bhi.n	2356e <interface_socket_packet_handler_update+0x46>
   23530:	ea4f 08c0 	mov.w	r8, r0, lsl #3
   23534:	4e17      	ldr	r6, [pc, #92]	; (23594 <interface_socket_packet_handler_update+0x6c>)
   23536:	eb08 0300 	add.w	r3, r8, r0
   2353a:	009b      	lsls	r3, r3, #2
   2353c:	58f4      	ldr	r4, [r6, r3]
   2353e:	18f5      	adds	r5, r6, r3
   23540:	b1ac      	cbz	r4, 2356e <interface_socket_packet_handler_update+0x46>
   23542:	460b      	mov	r3, r1
   23544:	4604      	mov	r4, r0
   23546:	4611      	mov	r1, r2
   23548:	4618      	mov	r0, r3
   2354a:	462a      	mov	r2, r5
   2354c:	f8d5 901c 	ldr.w	r9, [r5, #28]
   23550:	f001 ff7a 	bl	25448 <packet_handler_create>
   23554:	61e8      	str	r0, [r5, #28]
   23556:	b1d0      	cbz	r0, 2358e <interface_socket_packet_handler_update+0x66>
   23558:	6803      	ldr	r3, [r0, #0]
   2355a:	681b      	ldr	r3, [r3, #0]
   2355c:	4798      	blx	r3
   2355e:	4607      	mov	r7, r0
   23560:	b948      	cbnz	r0, 23576 <interface_socket_packet_handler_update+0x4e>
   23562:	4648      	mov	r0, r9
   23564:	f001 ff90 	bl	25488 <packet_handler_delete>
   23568:	4638      	mov	r0, r7
   2356a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2356e:	2705      	movs	r7, #5
   23570:	4638      	mov	r0, r7
   23572:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   23576:	69e8      	ldr	r0, [r5, #28]
   23578:	f001 ff86 	bl	25488 <packet_handler_delete>
   2357c:	eb08 0004 	add.w	r0, r8, r4
   23580:	eb06 0680 	add.w	r6, r6, r0, lsl #2
   23584:	f8c6 901c 	str.w	r9, [r6, #28]
   23588:	4638      	mov	r0, r7
   2358a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2358e:	2704      	movs	r7, #4
   23590:	e7f4      	b.n	2357c <interface_socket_packet_handler_update+0x54>
   23592:	bf00      	nop
   23594:	200314c0 	.word	0x200314c0

00023598 <interface_socket_wait>:
   23598:	b5f0      	push	{r4, r5, r6, r7, lr}
   2359a:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   2359e:	4c0e      	ldr	r4, [pc, #56]	; (235d8 <interface_socket_wait+0x40>)
   235a0:	0080      	lsls	r0, r0, #2
   235a2:	5825      	ldr	r5, [r4, r0]
   235a4:	b083      	sub	sp, #12
   235a6:	4015      	ands	r5, r2
   235a8:	428d      	cmp	r5, r1
   235aa:	9301      	str	r3, [sp, #4]
   235ac:	4404      	add	r4, r0
   235ae:	d010      	beq.n	235d2 <interface_socket_wait+0x3a>
   235b0:	6863      	ldr	r3, [r4, #4]
   235b2:	b973      	cbnz	r3, 235d2 <interface_socket_wait+0x3a>
   235b4:	460f      	mov	r7, r1
   235b6:	4616      	mov	r6, r2
   235b8:	4625      	mov	r5, r4
   235ba:	e006      	b.n	235ca <interface_socket_wait+0x32>
   235bc:	686b      	ldr	r3, [r5, #4]
   235be:	b943      	cbnz	r3, 235d2 <interface_socket_wait+0x3a>
   235c0:	a901      	add	r1, sp, #4
   235c2:	4620      	mov	r0, r4
   235c4:	f7f8 f83e 	bl	1b644 <bsd_os_timedwait>
   235c8:	b920      	cbnz	r0, 235d4 <interface_socket_wait+0x3c>
   235ca:	682b      	ldr	r3, [r5, #0]
   235cc:	4033      	ands	r3, r6
   235ce:	42bb      	cmp	r3, r7
   235d0:	d1f4      	bne.n	235bc <interface_socket_wait+0x24>
   235d2:	2000      	movs	r0, #0
   235d4:	b003      	add	sp, #12
   235d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   235d8:	200314c0 	.word	0x200314c0

000235dc <interface_from_internal_id_search>:
   235dc:	4b27      	ldr	r3, [pc, #156]	; (2367c <interface_from_internal_id_search+0xa0>)
   235de:	681a      	ldr	r2, [r3, #0]
   235e0:	b112      	cbz	r2, 235e8 <interface_from_internal_id_search+0xc>
   235e2:	699a      	ldr	r2, [r3, #24]
   235e4:	4282      	cmp	r2, r0
   235e6:	d039      	beq.n	2365c <interface_from_internal_id_search+0x80>
   235e8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   235ea:	b112      	cbz	r2, 235f2 <interface_from_internal_id_search+0x16>
   235ec:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   235ee:	4282      	cmp	r2, r0
   235f0:	d036      	beq.n	23660 <interface_from_internal_id_search+0x84>
   235f2:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   235f4:	b112      	cbz	r2, 235fc <interface_from_internal_id_search+0x20>
   235f6:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   235f8:	4282      	cmp	r2, r0
   235fa:	d033      	beq.n	23664 <interface_from_internal_id_search+0x88>
   235fc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
   235fe:	b11a      	cbz	r2, 23608 <interface_from_internal_id_search+0x2c>
   23600:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   23604:	4282      	cmp	r2, r0
   23606:	d02f      	beq.n	23668 <interface_from_internal_id_search+0x8c>
   23608:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   2360c:	b11a      	cbz	r2, 23616 <interface_from_internal_id_search+0x3a>
   2360e:	f8d3 20a8 	ldr.w	r2, [r3, #168]	; 0xa8
   23612:	4282      	cmp	r2, r0
   23614:	d02a      	beq.n	2366c <interface_from_internal_id_search+0x90>
   23616:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
   2361a:	b11a      	cbz	r2, 23624 <interface_from_internal_id_search+0x48>
   2361c:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
   23620:	4282      	cmp	r2, r0
   23622:	d025      	beq.n	23670 <interface_from_internal_id_search+0x94>
   23624:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
   23628:	b11a      	cbz	r2, 23632 <interface_from_internal_id_search+0x56>
   2362a:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
   2362e:	4282      	cmp	r2, r0
   23630:	d020      	beq.n	23674 <interface_from_internal_id_search+0x98>
   23632:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
   23636:	b11a      	cbz	r2, 23640 <interface_from_internal_id_search+0x64>
   23638:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
   2363c:	4282      	cmp	r2, r0
   2363e:	d01b      	beq.n	23678 <interface_from_internal_id_search+0x9c>
   23640:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   23644:	b13a      	cbz	r2, 23656 <interface_from_internal_id_search+0x7a>
   23646:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
   2364a:	4283      	cmp	r3, r0
   2364c:	bf14      	ite	ne
   2364e:	f04f 30ff 	movne.w	r0, #4294967295
   23652:	2008      	moveq	r0, #8
   23654:	4770      	bx	lr
   23656:	f04f 30ff 	mov.w	r0, #4294967295
   2365a:	4770      	bx	lr
   2365c:	2000      	movs	r0, #0
   2365e:	4770      	bx	lr
   23660:	2001      	movs	r0, #1
   23662:	4770      	bx	lr
   23664:	2002      	movs	r0, #2
   23666:	4770      	bx	lr
   23668:	2003      	movs	r0, #3
   2366a:	4770      	bx	lr
   2366c:	2004      	movs	r0, #4
   2366e:	4770      	bx	lr
   23670:	2005      	movs	r0, #5
   23672:	4770      	bx	lr
   23674:	2006      	movs	r0, #6
   23676:	4770      	bx	lr
   23678:	2007      	movs	r0, #7
   2367a:	4770      	bx	lr
   2367c:	200314c0 	.word	0x200314c0

00023680 <interface_socket_from_handle_get>:
   23680:	2808      	cmp	r0, #8
   23682:	d807      	bhi.n	23694 <interface_socket_from_handle_get+0x14>
   23684:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   23688:	4b03      	ldr	r3, [pc, #12]	; (23698 <interface_socket_from_handle_get+0x18>)
   2368a:	0080      	lsls	r0, r0, #2
   2368c:	581a      	ldr	r2, [r3, r0]
   2368e:	b10a      	cbz	r2, 23694 <interface_socket_from_handle_get+0x14>
   23690:	4418      	add	r0, r3
   23692:	4770      	bx	lr
   23694:	2000      	movs	r0, #0
   23696:	4770      	bx	lr
   23698:	200314c0 	.word	0x200314c0

0002369c <interface_socket_event_get>:
   2369c:	b119      	cbz	r1, 236a6 <interface_socket_event_get+0xa>
   2369e:	2808      	cmp	r0, #8
   236a0:	d902      	bls.n	236a8 <interface_socket_event_get+0xc>
   236a2:	2310      	movs	r3, #16
   236a4:	600b      	str	r3, [r1, #0]
   236a6:	4770      	bx	lr
   236a8:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   236ac:	4b07      	ldr	r3, [pc, #28]	; (236cc <interface_socket_event_get+0x30>)
   236ae:	0080      	lsls	r0, r0, #2
   236b0:	581a      	ldr	r2, [r3, r0]
   236b2:	2a00      	cmp	r2, #0
   236b4:	d0f5      	beq.n	236a2 <interface_socket_event_get+0x6>
   236b6:	581b      	ldr	r3, [r3, r0]
   236b8:	0c1b      	lsrs	r3, r3, #16
   236ba:	f003 020a 	and.w	r2, r3, #10
   236be:	2a0a      	cmp	r2, #10
   236c0:	bf14      	ite	ne
   236c2:	f003 030f 	andne.w	r3, r3, #15
   236c6:	f003 030d 	andeq.w	r3, r3, #13
   236ca:	e7eb      	b.n	236a4 <interface_socket_event_get+0x8>
   236cc:	200314c0 	.word	0x200314c0

000236d0 <interface_socket_setopt>:
   236d0:	2808      	cmp	r0, #8
   236d2:	b538      	push	{r3, r4, r5, lr}
   236d4:	d82d      	bhi.n	23732 <interface_socket_setopt+0x62>
   236d6:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   236da:	4c1c      	ldr	r4, [pc, #112]	; (2374c <interface_socket_setopt+0x7c>)
   236dc:	0080      	lsls	r0, r0, #2
   236de:	461d      	mov	r5, r3
   236e0:	5823      	ldr	r3, [r4, r0]
   236e2:	b333      	cbz	r3, 23732 <interface_socket_setopt+0x62>
   236e4:	2901      	cmp	r1, #1
   236e6:	d11e      	bne.n	23726 <interface_socket_setopt+0x56>
   236e8:	2a14      	cmp	r2, #20
   236ea:	d11c      	bne.n	23726 <interface_socket_setopt+0x56>
   236ec:	b1ad      	cbz	r5, 2371a <interface_socket_setopt+0x4a>
   236ee:	9b04      	ldr	r3, [sp, #16]
   236f0:	2b08      	cmp	r3, #8
   236f2:	d112      	bne.n	2371a <interface_socket_setopt+0x4a>
   236f4:	686a      	ldr	r2, [r5, #4]
   236f6:	4b16      	ldr	r3, [pc, #88]	; (23750 <interface_socket_setopt+0x80>)
   236f8:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   236fc:	fba3 3202 	umull	r3, r2, r3, r2
   23700:	2300      	movs	r3, #0
   23702:	682d      	ldr	r5, [r5, #0]
   23704:	0992      	lsrs	r2, r2, #6
   23706:	fbe1 2305 	umlal	r2, r3, r1, r5
   2370a:	2b01      	cmp	r3, #1
   2370c:	bf08      	it	eq
   2370e:	2a00      	cmpeq	r2, #0
   23710:	d215      	bcs.n	2373e <interface_socket_setopt+0x6e>
   23712:	4420      	add	r0, r4
   23714:	6202      	str	r2, [r0, #32]
   23716:	2000      	movs	r0, #0
   23718:	bd38      	pop	{r3, r4, r5, pc}
   2371a:	2016      	movs	r0, #22
   2371c:	f7f8 f826 	bl	1b76c <bsd_os_errno_set>
   23720:	f04f 30ff 	mov.w	r0, #4294967295
   23724:	bd38      	pop	{r3, r4, r5, pc}
   23726:	202a      	movs	r0, #42	; 0x2a
   23728:	f7f8 f820 	bl	1b76c <bsd_os_errno_set>
   2372c:	f04f 30ff 	mov.w	r0, #4294967295
   23730:	bd38      	pop	{r3, r4, r5, pc}
   23732:	2009      	movs	r0, #9
   23734:	f7f8 f81a 	bl	1b76c <bsd_os_errno_set>
   23738:	f04f 30ff 	mov.w	r0, #4294967295
   2373c:	bd38      	pop	{r3, r4, r5, pc}
   2373e:	2025      	movs	r0, #37	; 0x25
   23740:	f7f8 f814 	bl	1b76c <bsd_os_errno_set>
   23744:	f04f 30ff 	mov.w	r0, #4294967295
   23748:	bd38      	pop	{r3, r4, r5, pc}
   2374a:	bf00      	nop
   2374c:	200314c0 	.word	0x200314c0
   23750:	10624dd3 	.word	0x10624dd3

00023754 <interface_socket_getopt>:
   23754:	b570      	push	{r4, r5, r6, lr}
   23756:	2808      	cmp	r0, #8
   23758:	9d04      	ldr	r5, [sp, #16]
   2375a:	d821      	bhi.n	237a0 <interface_socket_getopt+0x4c>
   2375c:	4c13      	ldr	r4, [pc, #76]	; (237ac <interface_socket_getopt+0x58>)
   2375e:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   23762:	0080      	lsls	r0, r0, #2
   23764:	5826      	ldr	r6, [r4, r0]
   23766:	4404      	add	r4, r0
   23768:	b1d6      	cbz	r6, 237a0 <interface_socket_getopt+0x4c>
   2376a:	2901      	cmp	r1, #1
   2376c:	d112      	bne.n	23794 <interface_socket_getopt+0x40>
   2376e:	2a04      	cmp	r2, #4
   23770:	d110      	bne.n	23794 <interface_socket_getopt+0x40>
   23772:	b14b      	cbz	r3, 23788 <interface_socket_getopt+0x34>
   23774:	b145      	cbz	r5, 23788 <interface_socket_getopt+0x34>
   23776:	682a      	ldr	r2, [r5, #0]
   23778:	2a04      	cmp	r2, #4
   2377a:	d105      	bne.n	23788 <interface_socket_getopt+0x34>
   2377c:	2200      	movs	r2, #0
   2377e:	6861      	ldr	r1, [r4, #4]
   23780:	4610      	mov	r0, r2
   23782:	6019      	str	r1, [r3, #0]
   23784:	6062      	str	r2, [r4, #4]
   23786:	bd70      	pop	{r4, r5, r6, pc}
   23788:	2016      	movs	r0, #22
   2378a:	f7f7 ffef 	bl	1b76c <bsd_os_errno_set>
   2378e:	f04f 30ff 	mov.w	r0, #4294967295
   23792:	bd70      	pop	{r4, r5, r6, pc}
   23794:	202a      	movs	r0, #42	; 0x2a
   23796:	f7f7 ffe9 	bl	1b76c <bsd_os_errno_set>
   2379a:	f04f 30ff 	mov.w	r0, #4294967295
   2379e:	bd70      	pop	{r4, r5, r6, pc}
   237a0:	2009      	movs	r0, #9
   237a2:	f7f7 ffe3 	bl	1b76c <bsd_os_errno_set>
   237a6:	f04f 30ff 	mov.w	r0, #4294967295
   237aa:	bd70      	pop	{r4, r5, r6, pc}
   237ac:	200314c0 	.word	0x200314c0

000237b0 <interface_socket_fcntl>:
   237b0:	2808      	cmp	r0, #8
   237b2:	b510      	push	{r4, lr}
   237b4:	d818      	bhi.n	237e8 <interface_socket_fcntl+0x38>
   237b6:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
   237ba:	4c11      	ldr	r4, [pc, #68]	; (23800 <interface_socket_fcntl+0x50>)
   237bc:	0083      	lsls	r3, r0, #2
   237be:	58e0      	ldr	r0, [r4, r3]
   237c0:	b190      	cbz	r0, 237e8 <interface_socket_fcntl+0x38>
   237c2:	2901      	cmp	r1, #1
   237c4:	d005      	beq.n	237d2 <interface_socket_fcntl+0x22>
   237c6:	2902      	cmp	r1, #2
   237c8:	d114      	bne.n	237f4 <interface_socket_fcntl+0x44>
   237ca:	58e0      	ldr	r0, [r4, r3]
   237cc:	f3c0 7000 	ubfx	r0, r0, #28, #1
   237d0:	bd10      	pop	{r4, pc}
   237d2:	f012 0001 	ands.w	r0, r2, #1
   237d6:	58e2      	ldr	r2, [r4, r3]
   237d8:	bf1a      	itte	ne
   237da:	2000      	movne	r0, #0
   237dc:	f042 5280 	orrne.w	r2, r2, #268435456	; 0x10000000
   237e0:	f022 5280 	biceq.w	r2, r2, #268435456	; 0x10000000
   237e4:	50e2      	str	r2, [r4, r3]
   237e6:	bd10      	pop	{r4, pc}
   237e8:	2009      	movs	r0, #9
   237ea:	f7f7 ffbf 	bl	1b76c <bsd_os_errno_set>
   237ee:	f04f 30ff 	mov.w	r0, #4294967295
   237f2:	bd10      	pop	{r4, pc}
   237f4:	2016      	movs	r0, #22
   237f6:	f7f7 ffb9 	bl	1b76c <bsd_os_errno_set>
   237fa:	f04f 30ff 	mov.w	r0, #4294967295
   237fe:	bd10      	pop	{r4, pc}
   23800:	200314c0 	.word	0x200314c0

00023804 <bsd_os_application_irq_handler>:
   23804:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   23808:	4c33      	ldr	r4, [pc, #204]	; (238d8 <bsd_os_application_irq_handler+0xd4>)
   2380a:	f7f8 f8af 	bl	1b96c <bsd_os_application_irq_clear>
   2380e:	f04f 0803 	mov.w	r8, #3
   23812:	4d32      	ldr	r5, [pc, #200]	; (238dc <bsd_os_application_irq_handler+0xd8>)
   23814:	4f32      	ldr	r7, [pc, #200]	; (238e0 <bsd_os_application_irq_handler+0xdc>)
   23816:	f104 0680 	add.w	r6, r4, #128	; 0x80
   2381a:	e004      	b.n	23826 <bsd_os_application_irq_handler+0x22>
   2381c:	2b04      	cmp	r3, #4
   2381e:	d006      	beq.n	2382e <bsd_os_application_irq_handler+0x2a>
   23820:	3408      	adds	r4, #8
   23822:	42b4      	cmp	r4, r6
   23824:	d03b      	beq.n	2389e <bsd_os_application_irq_handler+0x9a>
   23826:	f814 3c04 	ldrb.w	r3, [r4, #-4]
   2382a:	2b02      	cmp	r3, #2
   2382c:	d1f6      	bne.n	2381c <bsd_os_application_irq_handler+0x18>
   2382e:	6820      	ldr	r0, [r4, #0]
   23830:	882a      	ldrh	r2, [r5, #0]
   23832:	6803      	ldr	r3, [r0, #0]
   23834:	b29b      	uxth	r3, r3
   23836:	429a      	cmp	r2, r3
   23838:	d033      	beq.n	238a2 <bsd_os_application_irq_handler+0x9e>
   2383a:	8a2a      	ldrh	r2, [r5, #16]
   2383c:	429a      	cmp	r2, r3
   2383e:	d032      	beq.n	238a6 <bsd_os_application_irq_handler+0xa2>
   23840:	8c2a      	ldrh	r2, [r5, #32]
   23842:	429a      	cmp	r2, r3
   23844:	d031      	beq.n	238aa <bsd_os_application_irq_handler+0xa6>
   23846:	8e2a      	ldrh	r2, [r5, #48]	; 0x30
   23848:	429a      	cmp	r2, r3
   2384a:	d030      	beq.n	238ae <bsd_os_application_irq_handler+0xaa>
   2384c:	f8b5 2040 	ldrh.w	r2, [r5, #64]	; 0x40
   23850:	429a      	cmp	r2, r3
   23852:	d036      	beq.n	238c2 <bsd_os_application_irq_handler+0xbe>
   23854:	f8b5 2050 	ldrh.w	r2, [r5, #80]	; 0x50
   23858:	429a      	cmp	r2, r3
   2385a:	d034      	beq.n	238c6 <bsd_os_application_irq_handler+0xc2>
   2385c:	f8b5 2060 	ldrh.w	r2, [r5, #96]	; 0x60
   23860:	429a      	cmp	r2, r3
   23862:	d032      	beq.n	238ca <bsd_os_application_irq_handler+0xc6>
   23864:	f8b5 2070 	ldrh.w	r2, [r5, #112]	; 0x70
   23868:	429a      	cmp	r2, r3
   2386a:	d030      	beq.n	238ce <bsd_os_application_irq_handler+0xca>
   2386c:	f8b5 2080 	ldrh.w	r2, [r5, #128]	; 0x80
   23870:	429a      	cmp	r2, r3
   23872:	d02e      	beq.n	238d2 <bsd_os_application_irq_handler+0xce>
   23874:	f8b5 2090 	ldrh.w	r2, [r5, #144]	; 0x90
   23878:	429a      	cmp	r2, r3
   2387a:	bf08      	it	eq
   2387c:	2309      	moveq	r3, #9
   2387e:	d1cf      	bne.n	23820 <bsd_os_application_irq_handler+0x1c>
   23880:	eb05 1303 	add.w	r3, r5, r3, lsl #4
   23884:	685a      	ldr	r2, [r3, #4]
   23886:	68d9      	ldr	r1, [r3, #12]
   23888:	4790      	blx	r2
   2388a:	b990      	cbnz	r0, 238b2 <bsd_os_application_irq_handler+0xae>
   2388c:	2201      	movs	r2, #1
   2388e:	6820      	ldr	r0, [r4, #0]
   23890:	f804 2c04 	strb.w	r2, [r4, #-4]
   23894:	68fb      	ldr	r3, [r7, #12]
   23896:	3408      	adds	r4, #8
   23898:	4798      	blx	r3
   2389a:	42b4      	cmp	r4, r6
   2389c:	d1c3      	bne.n	23826 <bsd_os_application_irq_handler+0x22>
   2389e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   238a2:	2300      	movs	r3, #0
   238a4:	e7ec      	b.n	23880 <bsd_os_application_irq_handler+0x7c>
   238a6:	2301      	movs	r3, #1
   238a8:	e7ea      	b.n	23880 <bsd_os_application_irq_handler+0x7c>
   238aa:	2302      	movs	r3, #2
   238ac:	e7e8      	b.n	23880 <bsd_os_application_irq_handler+0x7c>
   238ae:	2303      	movs	r3, #3
   238b0:	e7e6      	b.n	23880 <bsd_os_application_irq_handler+0x7c>
   238b2:	2802      	cmp	r0, #2
   238b4:	bf0a      	itet	eq
   238b6:	2304      	moveq	r3, #4
   238b8:	f804 8c04 	strbne.w	r8, [r4, #-4]
   238bc:	f804 3c04 	strbeq.w	r3, [r4, #-4]
   238c0:	e7ae      	b.n	23820 <bsd_os_application_irq_handler+0x1c>
   238c2:	2304      	movs	r3, #4
   238c4:	e7dc      	b.n	23880 <bsd_os_application_irq_handler+0x7c>
   238c6:	2305      	movs	r3, #5
   238c8:	e7da      	b.n	23880 <bsd_os_application_irq_handler+0x7c>
   238ca:	2306      	movs	r3, #6
   238cc:	e7d8      	b.n	23880 <bsd_os_application_irq_handler+0x7c>
   238ce:	2307      	movs	r3, #7
   238d0:	e7d6      	b.n	23880 <bsd_os_application_irq_handler+0x7c>
   238d2:	2308      	movs	r3, #8
   238d4:	e7d4      	b.n	23880 <bsd_os_application_irq_handler+0x7c>
   238d6:	bf00      	nop
   238d8:	20029014 	.word	0x20029014
   238dc:	20028ed8 	.word	0x20028ed8
   238e0:	20028f78 	.word	0x20028f78

000238e4 <rpc_framework_init>:
   238e4:	b508      	push	{r3, lr}
   238e6:	22a0      	movs	r2, #160	; 0xa0
   238e8:	2100      	movs	r1, #0
   238ea:	4802      	ldr	r0, [pc, #8]	; (238f4 <rpc_framework_init+0x10>)
   238ec:	f00b fd52 	bl	2f394 <memset>
   238f0:	2000      	movs	r0, #0
   238f2:	bd08      	pop	{r3, pc}
   238f4:	20028ed8 	.word	0x20028ed8

000238f8 <rpc_client_register>:
   238f8:	8803      	ldrh	r3, [r0, #0]
   238fa:	2b00      	cmp	r3, #0
   238fc:	d045      	beq.n	2398a <rpc_client_register+0x92>
   238fe:	6842      	ldr	r2, [r0, #4]
   23900:	4601      	mov	r1, r0
   23902:	2a00      	cmp	r2, #0
   23904:	d050      	beq.n	239a8 <rpc_client_register+0xb0>
   23906:	4a30      	ldr	r2, [pc, #192]	; (239c8 <rpc_client_register+0xd0>)
   23908:	8810      	ldrh	r0, [r2, #0]
   2390a:	4283      	cmp	r3, r0
   2390c:	d03d      	beq.n	2398a <rpc_client_register+0x92>
   2390e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   23912:	8a14      	ldrh	r4, [r2, #16]
   23914:	42a3      	cmp	r3, r4
   23916:	d035      	beq.n	23984 <rpc_client_register+0x8c>
   23918:	8c15      	ldrh	r5, [r2, #32]
   2391a:	42ab      	cmp	r3, r5
   2391c:	d032      	beq.n	23984 <rpc_client_register+0x8c>
   2391e:	8e16      	ldrh	r6, [r2, #48]	; 0x30
   23920:	42b3      	cmp	r3, r6
   23922:	d02f      	beq.n	23984 <rpc_client_register+0x8c>
   23924:	f8b2 7040 	ldrh.w	r7, [r2, #64]	; 0x40
   23928:	42bb      	cmp	r3, r7
   2392a:	d02b      	beq.n	23984 <rpc_client_register+0x8c>
   2392c:	f8b2 c050 	ldrh.w	ip, [r2, #80]	; 0x50
   23930:	4563      	cmp	r3, ip
   23932:	d027      	beq.n	23984 <rpc_client_register+0x8c>
   23934:	f8b2 e060 	ldrh.w	lr, [r2, #96]	; 0x60
   23938:	4573      	cmp	r3, lr
   2393a:	d023      	beq.n	23984 <rpc_client_register+0x8c>
   2393c:	f8b2 8070 	ldrh.w	r8, [r2, #112]	; 0x70
   23940:	4543      	cmp	r3, r8
   23942:	d01f      	beq.n	23984 <rpc_client_register+0x8c>
   23944:	f8b2 9080 	ldrh.w	r9, [r2, #128]	; 0x80
   23948:	454b      	cmp	r3, r9
   2394a:	d01b      	beq.n	23984 <rpc_client_register+0x8c>
   2394c:	f8b2 a090 	ldrh.w	sl, [r2, #144]	; 0x90
   23950:	4553      	cmp	r3, sl
   23952:	d017      	beq.n	23984 <rpc_client_register+0x8c>
   23954:	b1e0      	cbz	r0, 23990 <rpc_client_register+0x98>
   23956:	b35c      	cbz	r4, 239b0 <rpc_client_register+0xb8>
   23958:	b365      	cbz	r5, 239b4 <rpc_client_register+0xbc>
   2395a:	b36e      	cbz	r6, 239b8 <rpc_client_register+0xc0>
   2395c:	b377      	cbz	r7, 239bc <rpc_client_register+0xc4>
   2395e:	f1bc 0f00 	cmp.w	ip, #0
   23962:	d02d      	beq.n	239c0 <rpc_client_register+0xc8>
   23964:	f1be 0f00 	cmp.w	lr, #0
   23968:	d020      	beq.n	239ac <rpc_client_register+0xb4>
   2396a:	f1b8 0f00 	cmp.w	r8, #0
   2396e:	d029      	beq.n	239c4 <rpc_client_register+0xcc>
   23970:	f1b9 0f00 	cmp.w	r9, #0
   23974:	d00b      	beq.n	2398e <rpc_client_register+0x96>
   23976:	2009      	movs	r0, #9
   23978:	f1ba 0f00 	cmp.w	sl, #0
   2397c:	d008      	beq.n	23990 <rpc_client_register+0x98>
   2397e:	2004      	movs	r0, #4
   23980:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   23984:	2007      	movs	r0, #7
   23986:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2398a:	2007      	movs	r0, #7
   2398c:	4770      	bx	lr
   2398e:	2008      	movs	r0, #8
   23990:	0100      	lsls	r0, r0, #4
   23992:	5213      	strh	r3, [r2, r0]
   23994:	684b      	ldr	r3, [r1, #4]
   23996:	4402      	add	r2, r0
   23998:	6053      	str	r3, [r2, #4]
   2399a:	688b      	ldr	r3, [r1, #8]
   2399c:	2000      	movs	r0, #0
   2399e:	6093      	str	r3, [r2, #8]
   239a0:	68cb      	ldr	r3, [r1, #12]
   239a2:	60d3      	str	r3, [r2, #12]
   239a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   239a8:	200e      	movs	r0, #14
   239aa:	4770      	bx	lr
   239ac:	2006      	movs	r0, #6
   239ae:	e7ef      	b.n	23990 <rpc_client_register+0x98>
   239b0:	2001      	movs	r0, #1
   239b2:	e7ed      	b.n	23990 <rpc_client_register+0x98>
   239b4:	2002      	movs	r0, #2
   239b6:	e7eb      	b.n	23990 <rpc_client_register+0x98>
   239b8:	2003      	movs	r0, #3
   239ba:	e7e9      	b.n	23990 <rpc_client_register+0x98>
   239bc:	2004      	movs	r0, #4
   239be:	e7e7      	b.n	23990 <rpc_client_register+0x98>
   239c0:	2005      	movs	r0, #5
   239c2:	e7e5      	b.n	23990 <rpc_client_register+0x98>
   239c4:	2007      	movs	r0, #7
   239c6:	e7e3      	b.n	23990 <rpc_client_register+0x98>
   239c8:	20028ed8 	.word	0x20028ed8

000239cc <rpc_transport_input>:
   239cc:	b538      	push	{r3, r4, r5, lr}
   239ce:	4a82      	ldr	r2, [pc, #520]	; (23bd8 <rpc_transport_input+0x20c>)
   239d0:	680b      	ldr	r3, [r1, #0]
   239d2:	8810      	ldrh	r0, [r2, #0]
   239d4:	b29b      	uxth	r3, r3
   239d6:	4298      	cmp	r0, r3
   239d8:	d027      	beq.n	23a2a <rpc_transport_input+0x5e>
   239da:	8a10      	ldrh	r0, [r2, #16]
   239dc:	4298      	cmp	r0, r3
   239de:	d024      	beq.n	23a2a <rpc_transport_input+0x5e>
   239e0:	8c10      	ldrh	r0, [r2, #32]
   239e2:	4298      	cmp	r0, r3
   239e4:	d021      	beq.n	23a2a <rpc_transport_input+0x5e>
   239e6:	8e10      	ldrh	r0, [r2, #48]	; 0x30
   239e8:	4298      	cmp	r0, r3
   239ea:	d01e      	beq.n	23a2a <rpc_transport_input+0x5e>
   239ec:	f8b2 0040 	ldrh.w	r0, [r2, #64]	; 0x40
   239f0:	4298      	cmp	r0, r3
   239f2:	d01a      	beq.n	23a2a <rpc_transport_input+0x5e>
   239f4:	f8b2 0050 	ldrh.w	r0, [r2, #80]	; 0x50
   239f8:	4298      	cmp	r0, r3
   239fa:	d016      	beq.n	23a2a <rpc_transport_input+0x5e>
   239fc:	f8b2 0060 	ldrh.w	r0, [r2, #96]	; 0x60
   23a00:	4298      	cmp	r0, r3
   23a02:	d012      	beq.n	23a2a <rpc_transport_input+0x5e>
   23a04:	f8b2 0070 	ldrh.w	r0, [r2, #112]	; 0x70
   23a08:	4298      	cmp	r0, r3
   23a0a:	d00e      	beq.n	23a2a <rpc_transport_input+0x5e>
   23a0c:	f8b2 0080 	ldrh.w	r0, [r2, #128]	; 0x80
   23a10:	4298      	cmp	r0, r3
   23a12:	d00a      	beq.n	23a2a <rpc_transport_input+0x5e>
   23a14:	f8b2 2090 	ldrh.w	r2, [r2, #144]	; 0x90
   23a18:	429a      	cmp	r2, r3
   23a1a:	d006      	beq.n	23a2a <rpc_transport_input+0x5e>
   23a1c:	6888      	ldr	r0, [r1, #8]
   23a1e:	b118      	cbz	r0, 23a28 <rpc_transport_input+0x5c>
   23a20:	4b6e      	ldr	r3, [pc, #440]	; (23bdc <rpc_transport_input+0x210>)
   23a22:	691b      	ldr	r3, [r3, #16]
   23a24:	4798      	blx	r3
   23a26:	2000      	movs	r0, #0
   23a28:	bd38      	pop	{r3, r4, r5, pc}
   23a2a:	6888      	ldr	r0, [r1, #8]
   23a2c:	2800      	cmp	r0, #0
   23a2e:	f000 8098 	beq.w	23b62 <rpc_transport_input+0x196>
   23a32:	4a6b      	ldr	r2, [pc, #428]	; (23be0 <rpc_transport_input+0x214>)
   23a34:	6814      	ldr	r4, [r2, #0]
   23a36:	2c00      	cmp	r4, #0
   23a38:	d03c      	beq.n	23ab4 <rpc_transport_input+0xe8>
   23a3a:	6894      	ldr	r4, [r2, #8]
   23a3c:	2c00      	cmp	r4, #0
   23a3e:	f000 809a 	beq.w	23b76 <rpc_transport_input+0x1aa>
   23a42:	6914      	ldr	r4, [r2, #16]
   23a44:	2c00      	cmp	r4, #0
   23a46:	f000 809a 	beq.w	23b7e <rpc_transport_input+0x1b2>
   23a4a:	6994      	ldr	r4, [r2, #24]
   23a4c:	2c00      	cmp	r4, #0
   23a4e:	f000 809a 	beq.w	23b86 <rpc_transport_input+0x1ba>
   23a52:	6a14      	ldr	r4, [r2, #32]
   23a54:	2c00      	cmp	r4, #0
   23a56:	f000 809a 	beq.w	23b8e <rpc_transport_input+0x1c2>
   23a5a:	6a94      	ldr	r4, [r2, #40]	; 0x28
   23a5c:	2c00      	cmp	r4, #0
   23a5e:	f000 8084 	beq.w	23b6a <rpc_transport_input+0x19e>
   23a62:	6b14      	ldr	r4, [r2, #48]	; 0x30
   23a64:	2c00      	cmp	r4, #0
   23a66:	f000 8098 	beq.w	23b9a <rpc_transport_input+0x1ce>
   23a6a:	6b94      	ldr	r4, [r2, #56]	; 0x38
   23a6c:	2c00      	cmp	r4, #0
   23a6e:	f000 8096 	beq.w	23b9e <rpc_transport_input+0x1d2>
   23a72:	6c14      	ldr	r4, [r2, #64]	; 0x40
   23a74:	2c00      	cmp	r4, #0
   23a76:	f000 8096 	beq.w	23ba6 <rpc_transport_input+0x1da>
   23a7a:	6c94      	ldr	r4, [r2, #72]	; 0x48
   23a7c:	2c00      	cmp	r4, #0
   23a7e:	f000 8096 	beq.w	23bae <rpc_transport_input+0x1e2>
   23a82:	6d14      	ldr	r4, [r2, #80]	; 0x50
   23a84:	2c00      	cmp	r4, #0
   23a86:	f000 8096 	beq.w	23bb6 <rpc_transport_input+0x1ea>
   23a8a:	6d94      	ldr	r4, [r2, #88]	; 0x58
   23a8c:	2c00      	cmp	r4, #0
   23a8e:	f000 8098 	beq.w	23bc2 <rpc_transport_input+0x1f6>
   23a92:	6e14      	ldr	r4, [r2, #96]	; 0x60
   23a94:	2c00      	cmp	r4, #0
   23a96:	f000 8098 	beq.w	23bca <rpc_transport_input+0x1fe>
   23a9a:	6e94      	ldr	r4, [r2, #104]	; 0x68
   23a9c:	2c00      	cmp	r4, #0
   23a9e:	f000 8096 	beq.w	23bce <rpc_transport_input+0x202>
   23aa2:	6f14      	ldr	r4, [r2, #112]	; 0x70
   23aa4:	2c00      	cmp	r4, #0
   23aa6:	f000 8094 	beq.w	23bd2 <rpc_transport_input+0x206>
   23aaa:	6f94      	ldr	r4, [r2, #120]	; 0x78
   23aac:	b10c      	cbz	r4, 23ab2 <rpc_transport_input+0xe6>
   23aae:	2001      	movs	r0, #1
   23ab0:	bd38      	pop	{r3, r4, r5, pc}
   23ab2:	240f      	movs	r4, #15
   23ab4:	eb02 05c4 	add.w	r5, r2, r4, lsl #3
   23ab8:	f842 0034 	str.w	r0, [r2, r4, lsl #3]
   23abc:	80ab      	strh	r3, [r5, #4]
   23abe:	4b49      	ldr	r3, [pc, #292]	; (23be4 <rpc_transport_input+0x218>)
   23ac0:	781a      	ldrb	r2, [r3, #0]
   23ac2:	2a01      	cmp	r2, #1
   23ac4:	d053      	beq.n	23b6e <rpc_transport_input+0x1a2>
   23ac6:	7a1a      	ldrb	r2, [r3, #8]
   23ac8:	2a01      	cmp	r2, #1
   23aca:	d041      	beq.n	23b50 <rpc_transport_input+0x184>
   23acc:	7c1a      	ldrb	r2, [r3, #16]
   23ace:	2a01      	cmp	r2, #1
   23ad0:	d04f      	beq.n	23b72 <rpc_transport_input+0x1a6>
   23ad2:	7e1a      	ldrb	r2, [r3, #24]
   23ad4:	2a01      	cmp	r2, #1
   23ad6:	d050      	beq.n	23b7a <rpc_transport_input+0x1ae>
   23ad8:	f893 2020 	ldrb.w	r2, [r3, #32]
   23adc:	2a01      	cmp	r2, #1
   23ade:	d050      	beq.n	23b82 <rpc_transport_input+0x1b6>
   23ae0:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
   23ae4:	2a01      	cmp	r2, #1
   23ae6:	d050      	beq.n	23b8a <rpc_transport_input+0x1be>
   23ae8:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
   23aec:	2a01      	cmp	r2, #1
   23aee:	d03a      	beq.n	23b66 <rpc_transport_input+0x19a>
   23af0:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
   23af4:	2a01      	cmp	r2, #1
   23af6:	d04c      	beq.n	23b92 <rpc_transport_input+0x1c6>
   23af8:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
   23afc:	2a01      	cmp	r2, #1
   23afe:	d04a      	beq.n	23b96 <rpc_transport_input+0x1ca>
   23b00:	f893 2048 	ldrb.w	r2, [r3, #72]	; 0x48
   23b04:	2a01      	cmp	r2, #1
   23b06:	d04c      	beq.n	23ba2 <rpc_transport_input+0x1d6>
   23b08:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
   23b0c:	2a01      	cmp	r2, #1
   23b0e:	d04c      	beq.n	23baa <rpc_transport_input+0x1de>
   23b10:	f893 2058 	ldrb.w	r2, [r3, #88]	; 0x58
   23b14:	2a01      	cmp	r2, #1
   23b16:	d04c      	beq.n	23bb2 <rpc_transport_input+0x1e6>
   23b18:	f893 2060 	ldrb.w	r2, [r3, #96]	; 0x60
   23b1c:	2a01      	cmp	r2, #1
   23b1e:	d04c      	beq.n	23bba <rpc_transport_input+0x1ee>
   23b20:	f893 2068 	ldrb.w	r2, [r3, #104]	; 0x68
   23b24:	2a01      	cmp	r2, #1
   23b26:	d04a      	beq.n	23bbe <rpc_transport_input+0x1f2>
   23b28:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
   23b2c:	2a01      	cmp	r2, #1
   23b2e:	d04a      	beq.n	23bc6 <rpc_transport_input+0x1fa>
   23b30:	f893 2078 	ldrb.w	r2, [r3, #120]	; 0x78
   23b34:	2a01      	cmp	r2, #1
   23b36:	d00a      	beq.n	23b4e <rpc_transport_input+0x182>
   23b38:	2c10      	cmp	r4, #16
   23b3a:	d0b8      	beq.n	23aae <rpc_transport_input+0xe2>
   23b3c:	2200      	movs	r2, #0
   23b3e:	4b28      	ldr	r3, [pc, #160]	; (23be0 <rpc_transport_input+0x214>)
   23b40:	2001      	movs	r0, #1
   23b42:	eb03 01c4 	add.w	r1, r3, r4, lsl #3
   23b46:	808a      	strh	r2, [r1, #4]
   23b48:	f843 2034 	str.w	r2, [r3, r4, lsl #3]
   23b4c:	bd38      	pop	{r3, r4, r5, pc}
   23b4e:	220f      	movs	r2, #15
   23b50:	2402      	movs	r4, #2
   23b52:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
   23b56:	f803 4032 	strb.w	r4, [r3, r2, lsl #3]
   23b5a:	6041      	str	r1, [r0, #4]
   23b5c:	f7f7 fefe 	bl	1b95c <bsd_os_application_irq_set>
   23b60:	e7a5      	b.n	23aae <rpc_transport_input+0xe2>
   23b62:	2410      	movs	r4, #16
   23b64:	e7ab      	b.n	23abe <rpc_transport_input+0xf2>
   23b66:	2206      	movs	r2, #6
   23b68:	e7f2      	b.n	23b50 <rpc_transport_input+0x184>
   23b6a:	2405      	movs	r4, #5
   23b6c:	e7a2      	b.n	23ab4 <rpc_transport_input+0xe8>
   23b6e:	2200      	movs	r2, #0
   23b70:	e7ee      	b.n	23b50 <rpc_transport_input+0x184>
   23b72:	2202      	movs	r2, #2
   23b74:	e7ec      	b.n	23b50 <rpc_transport_input+0x184>
   23b76:	2401      	movs	r4, #1
   23b78:	e79c      	b.n	23ab4 <rpc_transport_input+0xe8>
   23b7a:	2203      	movs	r2, #3
   23b7c:	e7e8      	b.n	23b50 <rpc_transport_input+0x184>
   23b7e:	2402      	movs	r4, #2
   23b80:	e798      	b.n	23ab4 <rpc_transport_input+0xe8>
   23b82:	2204      	movs	r2, #4
   23b84:	e7e4      	b.n	23b50 <rpc_transport_input+0x184>
   23b86:	2403      	movs	r4, #3
   23b88:	e794      	b.n	23ab4 <rpc_transport_input+0xe8>
   23b8a:	2205      	movs	r2, #5
   23b8c:	e7e0      	b.n	23b50 <rpc_transport_input+0x184>
   23b8e:	2404      	movs	r4, #4
   23b90:	e790      	b.n	23ab4 <rpc_transport_input+0xe8>
   23b92:	2207      	movs	r2, #7
   23b94:	e7dc      	b.n	23b50 <rpc_transport_input+0x184>
   23b96:	2208      	movs	r2, #8
   23b98:	e7da      	b.n	23b50 <rpc_transport_input+0x184>
   23b9a:	2406      	movs	r4, #6
   23b9c:	e78a      	b.n	23ab4 <rpc_transport_input+0xe8>
   23b9e:	2407      	movs	r4, #7
   23ba0:	e788      	b.n	23ab4 <rpc_transport_input+0xe8>
   23ba2:	2209      	movs	r2, #9
   23ba4:	e7d4      	b.n	23b50 <rpc_transport_input+0x184>
   23ba6:	2408      	movs	r4, #8
   23ba8:	e784      	b.n	23ab4 <rpc_transport_input+0xe8>
   23baa:	220a      	movs	r2, #10
   23bac:	e7d0      	b.n	23b50 <rpc_transport_input+0x184>
   23bae:	2409      	movs	r4, #9
   23bb0:	e780      	b.n	23ab4 <rpc_transport_input+0xe8>
   23bb2:	220b      	movs	r2, #11
   23bb4:	e7cc      	b.n	23b50 <rpc_transport_input+0x184>
   23bb6:	240a      	movs	r4, #10
   23bb8:	e77c      	b.n	23ab4 <rpc_transport_input+0xe8>
   23bba:	220c      	movs	r2, #12
   23bbc:	e7c8      	b.n	23b50 <rpc_transport_input+0x184>
   23bbe:	220d      	movs	r2, #13
   23bc0:	e7c6      	b.n	23b50 <rpc_transport_input+0x184>
   23bc2:	240b      	movs	r4, #11
   23bc4:	e776      	b.n	23ab4 <rpc_transport_input+0xe8>
   23bc6:	220e      	movs	r2, #14
   23bc8:	e7c2      	b.n	23b50 <rpc_transport_input+0x184>
   23bca:	240c      	movs	r4, #12
   23bcc:	e772      	b.n	23ab4 <rpc_transport_input+0xe8>
   23bce:	240d      	movs	r4, #13
   23bd0:	e770      	b.n	23ab4 <rpc_transport_input+0xe8>
   23bd2:	240e      	movs	r4, #14
   23bd4:	e76e      	b.n	23ab4 <rpc_transport_input+0xe8>
   23bd6:	bf00      	nop
   23bd8:	20028ed8 	.word	0x20028ed8
   23bdc:	20028f78 	.word	0x20028f78
   23be0:	20028f90 	.word	0x20028f90
   23be4:	20029010 	.word	0x20029010

00023be8 <rpc_transport_register>:
   23be8:	b4f0      	push	{r4, r5, r6, r7}
   23bea:	2900      	cmp	r1, #0
   23bec:	d052      	beq.n	23c94 <rpc_transport_register+0xac>
   23bee:	2800      	cmp	r0, #0
   23bf0:	d050      	beq.n	23c94 <rpc_transport_register+0xac>
   23bf2:	6883      	ldr	r3, [r0, #8]
   23bf4:	2b00      	cmp	r3, #0
   23bf6:	d04d      	beq.n	23c94 <rpc_transport_register+0xac>
   23bf8:	6903      	ldr	r3, [r0, #16]
   23bfa:	2b00      	cmp	r3, #0
   23bfc:	d04a      	beq.n	23c94 <rpc_transport_register+0xac>
   23bfe:	6843      	ldr	r3, [r0, #4]
   23c00:	2b00      	cmp	r3, #0
   23c02:	d047      	beq.n	23c94 <rpc_transport_register+0xac>
   23c04:	68c3      	ldr	r3, [r0, #12]
   23c06:	2b00      	cmp	r3, #0
   23c08:	d044      	beq.n	23c94 <rpc_transport_register+0xac>
   23c0a:	6803      	ldr	r3, [r0, #0]
   23c0c:	2b00      	cmp	r3, #0
   23c0e:	d041      	beq.n	23c94 <rpc_transport_register+0xac>
   23c10:	6943      	ldr	r3, [r0, #20]
   23c12:	2b00      	cmp	r3, #0
   23c14:	d03e      	beq.n	23c94 <rpc_transport_register+0xac>
   23c16:	2601      	movs	r6, #1
   23c18:	2500      	movs	r5, #0
   23c1a:	4604      	mov	r4, r0
   23c1c:	460f      	mov	r7, r1
   23c1e:	4a1f      	ldr	r2, [pc, #124]	; (23c9c <rpc_transport_register+0xb4>)
   23c20:	4b1f      	ldr	r3, [pc, #124]	; (23ca0 <rpc_transport_register+0xb8>)
   23c22:	f8df c080 	ldr.w	ip, [pc, #128]	; 23ca4 <rpc_transport_register+0xbc>
   23c26:	7416      	strb	r6, [r2, #16]
   23c28:	7616      	strb	r6, [r2, #24]
   23c2a:	f882 6020 	strb.w	r6, [r2, #32]
   23c2e:	f882 6028 	strb.w	r6, [r2, #40]	; 0x28
   23c32:	f882 6030 	strb.w	r6, [r2, #48]	; 0x30
   23c36:	f882 6038 	strb.w	r6, [r2, #56]	; 0x38
   23c3a:	f882 6040 	strb.w	r6, [r2, #64]	; 0x40
   23c3e:	f882 6048 	strb.w	r6, [r2, #72]	; 0x48
   23c42:	f882 6050 	strb.w	r6, [r2, #80]	; 0x50
   23c46:	f882 6058 	strb.w	r6, [r2, #88]	; 0x58
   23c4a:	f882 6060 	strb.w	r6, [r2, #96]	; 0x60
   23c4e:	f882 6068 	strb.w	r6, [r2, #104]	; 0x68
   23c52:	f882 6070 	strb.w	r6, [r2, #112]	; 0x70
   23c56:	f882 6078 	strb.w	r6, [r2, #120]	; 0x78
   23c5a:	611d      	str	r5, [r3, #16]
   23c5c:	619d      	str	r5, [r3, #24]
   23c5e:	621d      	str	r5, [r3, #32]
   23c60:	629d      	str	r5, [r3, #40]	; 0x28
   23c62:	631d      	str	r5, [r3, #48]	; 0x30
   23c64:	639d      	str	r5, [r3, #56]	; 0x38
   23c66:	641d      	str	r5, [r3, #64]	; 0x40
   23c68:	649d      	str	r5, [r3, #72]	; 0x48
   23c6a:	651d      	str	r5, [r3, #80]	; 0x50
   23c6c:	659d      	str	r5, [r3, #88]	; 0x58
   23c6e:	661d      	str	r5, [r3, #96]	; 0x60
   23c70:	669d      	str	r5, [r3, #104]	; 0x68
   23c72:	671d      	str	r5, [r3, #112]	; 0x70
   23c74:	679d      	str	r5, [r3, #120]	; 0x78
   23c76:	7016      	strb	r6, [r2, #0]
   23c78:	7216      	strb	r6, [r2, #8]
   23c7a:	601d      	str	r5, [r3, #0]
   23c7c:	609d      	str	r5, [r3, #8]
   23c7e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   23c80:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   23c84:	e894 0003 	ldmia.w	r4, {r0, r1}
   23c88:	e88c 0003 	stmia.w	ip, {r0, r1}
   23c8c:	603e      	str	r6, [r7, #0]
   23c8e:	4628      	mov	r0, r5
   23c90:	bcf0      	pop	{r4, r5, r6, r7}
   23c92:	4770      	bx	lr
   23c94:	250e      	movs	r5, #14
   23c96:	4628      	mov	r0, r5
   23c98:	bcf0      	pop	{r4, r5, r6, r7}
   23c9a:	4770      	bx	lr
   23c9c:	20029010 	.word	0x20029010
   23ca0:	20028f90 	.word	0x20028f90
   23ca4:	20028f78 	.word	0x20028f78

00023ca8 <rpc_transport_unregister>:
   23ca8:	2800      	cmp	r0, #0
   23caa:	d03a      	beq.n	23d22 <rpc_transport_unregister+0x7a>
   23cac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   23cb0:	4680      	mov	r8, r0
   23cb2:	4c1d      	ldr	r4, [pc, #116]	; (23d28 <rpc_transport_unregister+0x80>)
   23cb4:	f104 05a0 	add.w	r5, r4, #160	; 0xa0
   23cb8:	68a3      	ldr	r3, [r4, #8]
   23cba:	3410      	adds	r4, #16
   23cbc:	b103      	cbz	r3, 23cc0 <rpc_transport_unregister+0x18>
   23cbe:	4798      	blx	r3
   23cc0:	42ac      	cmp	r4, r5
   23cc2:	d1f9      	bne.n	23cb8 <rpc_transport_unregister+0x10>
   23cc4:	f04f 0901 	mov.w	r9, #1
   23cc8:	2600      	movs	r6, #0
   23cca:	4c18      	ldr	r4, [pc, #96]	; (23d2c <rpc_transport_unregister+0x84>)
   23ccc:	4d18      	ldr	r5, [pc, #96]	; (23d30 <rpc_transport_unregister+0x88>)
   23cce:	f8df a064 	ldr.w	sl, [pc, #100]	; 23d34 <rpc_transport_unregister+0x8c>
   23cd2:	f104 0780 	add.w	r7, r4, #128	; 0x80
   23cd6:	f814 3c04 	ldrb.w	r3, [r4, #-4]
   23cda:	2b01      	cmp	r3, #1
   23cdc:	d005      	beq.n	23cea <rpc_transport_unregister+0x42>
   23cde:	f8da 300c 	ldr.w	r3, [sl, #12]
   23ce2:	6820      	ldr	r0, [r4, #0]
   23ce4:	4798      	blx	r3
   23ce6:	f804 9c04 	strb.w	r9, [r4, #-4]
   23cea:	f855 0c04 	ldr.w	r0, [r5, #-4]
   23cee:	3408      	adds	r4, #8
   23cf0:	b128      	cbz	r0, 23cfe <rpc_transport_unregister+0x56>
   23cf2:	f8da 3010 	ldr.w	r3, [sl, #16]
   23cf6:	4798      	blx	r3
   23cf8:	802e      	strh	r6, [r5, #0]
   23cfa:	f845 6c04 	str.w	r6, [r5, #-4]
   23cfe:	42bc      	cmp	r4, r7
   23d00:	f105 0508 	add.w	r5, r5, #8
   23d04:	d1e7      	bne.n	23cd6 <rpc_transport_unregister+0x2e>
   23d06:	f8d8 0000 	ldr.w	r0, [r8]
   23d0a:	2218      	movs	r2, #24
   23d0c:	3801      	subs	r0, #1
   23d0e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   23d12:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
   23d16:	2100      	movs	r1, #0
   23d18:	f00b fb3c 	bl	2f394 <memset>
   23d1c:	2000      	movs	r0, #0
   23d1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   23d22:	200e      	movs	r0, #14
   23d24:	4770      	bx	lr
   23d26:	bf00      	nop
   23d28:	20028ed8 	.word	0x20028ed8
   23d2c:	20029014 	.word	0x20029014
   23d30:	20028f94 	.word	0x20028f94
   23d34:	20028f78 	.word	0x20028f78

00023d38 <rpc_message_send>:
   23d38:	b168      	cbz	r0, 23d56 <rpc_message_send+0x1e>
   23d3a:	b171      	cbz	r1, 23d5a <rpc_message_send+0x22>
   23d3c:	4a09      	ldr	r2, [pc, #36]	; (23d64 <rpc_message_send+0x2c>)
   23d3e:	6853      	ldr	r3, [r2, #4]
   23d40:	b16b      	cbz	r3, 23d5e <rpc_message_send+0x26>
   23d42:	684b      	ldr	r3, [r1, #4]
   23d44:	8008      	strh	r0, [r1, #0]
   23d46:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   23d4a:	f043 0302 	orr.w	r3, r3, #2
   23d4e:	6812      	ldr	r2, [r2, #0]
   23d50:	604b      	str	r3, [r1, #4]
   23d52:	4608      	mov	r0, r1
   23d54:	4710      	bx	r2
   23d56:	2007      	movs	r0, #7
   23d58:	4770      	bx	lr
   23d5a:	200e      	movs	r0, #14
   23d5c:	4770      	bx	lr
   23d5e:	2008      	movs	r0, #8
   23d60:	4770      	bx	lr
   23d62:	bf00      	nop
   23d64:	20028f78 	.word	0x20028f78

00023d68 <rpc_message_alloc>:
   23d68:	b35a      	cbz	r2, 23dc2 <rpc_message_alloc+0x5a>
   23d6a:	b330      	cbz	r0, 23dba <rpc_message_alloc+0x52>
   23d6c:	2300      	movs	r3, #0
   23d6e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   23d72:	4f15      	ldr	r7, [pc, #84]	; (23dc8 <rpc_message_alloc+0x60>)
   23d74:	6013      	str	r3, [r2, #0]
   23d76:	687b      	ldr	r3, [r7, #4]
   23d78:	b30b      	cbz	r3, 23dbe <rpc_message_alloc+0x56>
   23d7a:	4615      	mov	r5, r2
   23d7c:	460c      	mov	r4, r1
   23d7e:	4606      	mov	r6, r0
   23d80:	b959      	cbnz	r1, 23d9a <rpc_message_alloc+0x32>
   23d82:	4798      	blx	r3
   23d84:	4603      	mov	r3, r0
   23d86:	b1a8      	cbz	r0, 23db4 <rpc_message_alloc+0x4c>
   23d88:	46a0      	mov	r8, r4
   23d8a:	60dc      	str	r4, [r3, #12]
   23d8c:	f8c3 8008 	str.w	r8, [r3, #8]
   23d90:	801e      	strh	r6, [r3, #0]
   23d92:	602b      	str	r3, [r5, #0]
   23d94:	2000      	movs	r0, #0
   23d96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   23d9a:	68bb      	ldr	r3, [r7, #8]
   23d9c:	4608      	mov	r0, r1
   23d9e:	4798      	blx	r3
   23da0:	4680      	mov	r8, r0
   23da2:	b138      	cbz	r0, 23db4 <rpc_message_alloc+0x4c>
   23da4:	687b      	ldr	r3, [r7, #4]
   23da6:	4798      	blx	r3
   23da8:	4603      	mov	r3, r0
   23daa:	2800      	cmp	r0, #0
   23dac:	d1ed      	bne.n	23d8a <rpc_message_alloc+0x22>
   23dae:	693b      	ldr	r3, [r7, #16]
   23db0:	4640      	mov	r0, r8
   23db2:	4798      	blx	r3
   23db4:	2004      	movs	r0, #4
   23db6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   23dba:	2007      	movs	r0, #7
   23dbc:	4770      	bx	lr
   23dbe:	2008      	movs	r0, #8
   23dc0:	e7f9      	b.n	23db6 <rpc_message_alloc+0x4e>
   23dc2:	200e      	movs	r0, #14
   23dc4:	4770      	bx	lr
   23dc6:	bf00      	nop
   23dc8:	20028f78 	.word	0x20028f78

00023dcc <rpc_message_free>:
   23dcc:	2800      	cmp	r0, #0
   23dce:	f000 808c 	beq.w	23eea <rpc_message_free+0x11e>
   23dd2:	2900      	cmp	r1, #0
   23dd4:	f000 80e9 	beq.w	23faa <rpc_message_free+0x1de>
   23dd8:	b538      	push	{r3, r4, r5, lr}
   23dda:	4a83      	ldr	r2, [pc, #524]	; (23fe8 <rpc_message_free+0x21c>)
   23ddc:	6853      	ldr	r3, [r2, #4]
   23dde:	2b00      	cmp	r3, #0
   23de0:	f000 8085 	beq.w	23eee <rpc_message_free+0x122>
   23de4:	4c81      	ldr	r4, [pc, #516]	; (23fec <rpc_message_free+0x220>)
   23de6:	4608      	mov	r0, r1
   23de8:	6863      	ldr	r3, [r4, #4]
   23dea:	4299      	cmp	r1, r3
   23dec:	f000 8085 	beq.w	23efa <rpc_message_free+0x12e>
   23df0:	68e3      	ldr	r3, [r4, #12]
   23df2:	4298      	cmp	r0, r3
   23df4:	f000 808e 	beq.w	23f14 <rpc_message_free+0x148>
   23df8:	6963      	ldr	r3, [r4, #20]
   23dfa:	4298      	cmp	r0, r3
   23dfc:	f000 8090 	beq.w	23f20 <rpc_message_free+0x154>
   23e00:	69e3      	ldr	r3, [r4, #28]
   23e02:	4298      	cmp	r0, r3
   23e04:	f000 8092 	beq.w	23f2c <rpc_message_free+0x160>
   23e08:	6a63      	ldr	r3, [r4, #36]	; 0x24
   23e0a:	4298      	cmp	r0, r3
   23e0c:	f000 8095 	beq.w	23f3a <rpc_message_free+0x16e>
   23e10:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   23e12:	4298      	cmp	r0, r3
   23e14:	f000 8098 	beq.w	23f48 <rpc_message_free+0x17c>
   23e18:	6b63      	ldr	r3, [r4, #52]	; 0x34
   23e1a:	4298      	cmp	r0, r3
   23e1c:	f000 809b 	beq.w	23f56 <rpc_message_free+0x18a>
   23e20:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   23e22:	4298      	cmp	r0, r3
   23e24:	f000 809e 	beq.w	23f64 <rpc_message_free+0x198>
   23e28:	6c63      	ldr	r3, [r4, #68]	; 0x44
   23e2a:	4298      	cmp	r0, r3
   23e2c:	f000 80a1 	beq.w	23f72 <rpc_message_free+0x1a6>
   23e30:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   23e32:	4298      	cmp	r0, r3
   23e34:	f000 80a4 	beq.w	23f80 <rpc_message_free+0x1b4>
   23e38:	6d63      	ldr	r3, [r4, #84]	; 0x54
   23e3a:	4298      	cmp	r0, r3
   23e3c:	f000 80a7 	beq.w	23f8e <rpc_message_free+0x1c2>
   23e40:	6de3      	ldr	r3, [r4, #92]	; 0x5c
   23e42:	4298      	cmp	r0, r3
   23e44:	f000 80aa 	beq.w	23f9c <rpc_message_free+0x1d0>
   23e48:	6e63      	ldr	r3, [r4, #100]	; 0x64
   23e4a:	4298      	cmp	r0, r3
   23e4c:	f000 80af 	beq.w	23fae <rpc_message_free+0x1e2>
   23e50:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
   23e52:	4298      	cmp	r0, r3
   23e54:	f000 80b2 	beq.w	23fbc <rpc_message_free+0x1f0>
   23e58:	6f63      	ldr	r3, [r4, #116]	; 0x74
   23e5a:	4298      	cmp	r0, r3
   23e5c:	f000 80b5 	beq.w	23fca <rpc_message_free+0x1fe>
   23e60:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
   23e62:	4283      	cmp	r3, r0
   23e64:	f000 80b8 	beq.w	23fd8 <rpc_message_free+0x20c>
   23e68:	68d3      	ldr	r3, [r2, #12]
   23e6a:	4798      	blx	r3
   23e6c:	7823      	ldrb	r3, [r4, #0]
   23e6e:	2b04      	cmp	r3, #4
   23e70:	d03f      	beq.n	23ef2 <rpc_message_free+0x126>
   23e72:	7a23      	ldrb	r3, [r4, #8]
   23e74:	2b04      	cmp	r3, #4
   23e76:	d03c      	beq.n	23ef2 <rpc_message_free+0x126>
   23e78:	7c23      	ldrb	r3, [r4, #16]
   23e7a:	2b04      	cmp	r3, #4
   23e7c:	d039      	beq.n	23ef2 <rpc_message_free+0x126>
   23e7e:	7e23      	ldrb	r3, [r4, #24]
   23e80:	2b04      	cmp	r3, #4
   23e82:	d036      	beq.n	23ef2 <rpc_message_free+0x126>
   23e84:	f894 3020 	ldrb.w	r3, [r4, #32]
   23e88:	2b04      	cmp	r3, #4
   23e8a:	d032      	beq.n	23ef2 <rpc_message_free+0x126>
   23e8c:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
   23e90:	2b04      	cmp	r3, #4
   23e92:	d02e      	beq.n	23ef2 <rpc_message_free+0x126>
   23e94:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   23e98:	2b04      	cmp	r3, #4
   23e9a:	d02a      	beq.n	23ef2 <rpc_message_free+0x126>
   23e9c:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
   23ea0:	2b04      	cmp	r3, #4
   23ea2:	d026      	beq.n	23ef2 <rpc_message_free+0x126>
   23ea4:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   23ea8:	2b04      	cmp	r3, #4
   23eaa:	d022      	beq.n	23ef2 <rpc_message_free+0x126>
   23eac:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
   23eb0:	2b04      	cmp	r3, #4
   23eb2:	d01e      	beq.n	23ef2 <rpc_message_free+0x126>
   23eb4:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
   23eb8:	2b04      	cmp	r3, #4
   23eba:	d01a      	beq.n	23ef2 <rpc_message_free+0x126>
   23ebc:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
   23ec0:	2b04      	cmp	r3, #4
   23ec2:	d016      	beq.n	23ef2 <rpc_message_free+0x126>
   23ec4:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
   23ec8:	2b04      	cmp	r3, #4
   23eca:	d012      	beq.n	23ef2 <rpc_message_free+0x126>
   23ecc:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
   23ed0:	2b04      	cmp	r3, #4
   23ed2:	d00e      	beq.n	23ef2 <rpc_message_free+0x126>
   23ed4:	f894 3070 	ldrb.w	r3, [r4, #112]	; 0x70
   23ed8:	2b04      	cmp	r3, #4
   23eda:	d00a      	beq.n	23ef2 <rpc_message_free+0x126>
   23edc:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
   23ee0:	2b04      	cmp	r3, #4
   23ee2:	bf18      	it	ne
   23ee4:	2000      	movne	r0, #0
   23ee6:	d004      	beq.n	23ef2 <rpc_message_free+0x126>
   23ee8:	bd38      	pop	{r3, r4, r5, pc}
   23eea:	2007      	movs	r0, #7
   23eec:	4770      	bx	lr
   23eee:	2008      	movs	r0, #8
   23ef0:	bd38      	pop	{r3, r4, r5, pc}
   23ef2:	f7f7 fd33 	bl	1b95c <bsd_os_application_irq_set>
   23ef6:	2000      	movs	r0, #0
   23ef8:	bd38      	pop	{r3, r4, r5, pc}
   23efa:	7821      	ldrb	r1, [r4, #0]
   23efc:	2903      	cmp	r1, #3
   23efe:	f47f af77 	bne.w	23df0 <rpc_message_free+0x24>
   23f02:	2100      	movs	r1, #0
   23f04:	2501      	movs	r5, #1
   23f06:	4618      	mov	r0, r3
   23f08:	68d2      	ldr	r2, [r2, #12]
   23f0a:	f804 5031 	strb.w	r5, [r4, r1, lsl #3]
   23f0e:	4790      	blx	r2
   23f10:	2000      	movs	r0, #0
   23f12:	bd38      	pop	{r3, r4, r5, pc}
   23f14:	7a21      	ldrb	r1, [r4, #8]
   23f16:	2903      	cmp	r1, #3
   23f18:	f47f af6e 	bne.w	23df8 <rpc_message_free+0x2c>
   23f1c:	2101      	movs	r1, #1
   23f1e:	e7f1      	b.n	23f04 <rpc_message_free+0x138>
   23f20:	7c21      	ldrb	r1, [r4, #16]
   23f22:	2903      	cmp	r1, #3
   23f24:	f47f af6c 	bne.w	23e00 <rpc_message_free+0x34>
   23f28:	2102      	movs	r1, #2
   23f2a:	e7eb      	b.n	23f04 <rpc_message_free+0x138>
   23f2c:	7e21      	ldrb	r1, [r4, #24]
   23f2e:	2903      	cmp	r1, #3
   23f30:	d0e8      	beq.n	23f04 <rpc_message_free+0x138>
   23f32:	6a63      	ldr	r3, [r4, #36]	; 0x24
   23f34:	4298      	cmp	r0, r3
   23f36:	f47f af6b 	bne.w	23e10 <rpc_message_free+0x44>
   23f3a:	f894 1020 	ldrb.w	r1, [r4, #32]
   23f3e:	2903      	cmp	r1, #3
   23f40:	f47f af66 	bne.w	23e10 <rpc_message_free+0x44>
   23f44:	2104      	movs	r1, #4
   23f46:	e7dd      	b.n	23f04 <rpc_message_free+0x138>
   23f48:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
   23f4c:	2903      	cmp	r1, #3
   23f4e:	f47f af63 	bne.w	23e18 <rpc_message_free+0x4c>
   23f52:	2105      	movs	r1, #5
   23f54:	e7d6      	b.n	23f04 <rpc_message_free+0x138>
   23f56:	f894 1030 	ldrb.w	r1, [r4, #48]	; 0x30
   23f5a:	2903      	cmp	r1, #3
   23f5c:	f47f af60 	bne.w	23e20 <rpc_message_free+0x54>
   23f60:	2106      	movs	r1, #6
   23f62:	e7cf      	b.n	23f04 <rpc_message_free+0x138>
   23f64:	f894 1038 	ldrb.w	r1, [r4, #56]	; 0x38
   23f68:	2903      	cmp	r1, #3
   23f6a:	f47f af5d 	bne.w	23e28 <rpc_message_free+0x5c>
   23f6e:	2107      	movs	r1, #7
   23f70:	e7c8      	b.n	23f04 <rpc_message_free+0x138>
   23f72:	f894 1040 	ldrb.w	r1, [r4, #64]	; 0x40
   23f76:	2903      	cmp	r1, #3
   23f78:	f47f af5a 	bne.w	23e30 <rpc_message_free+0x64>
   23f7c:	2108      	movs	r1, #8
   23f7e:	e7c1      	b.n	23f04 <rpc_message_free+0x138>
   23f80:	f894 1048 	ldrb.w	r1, [r4, #72]	; 0x48
   23f84:	2903      	cmp	r1, #3
   23f86:	f47f af57 	bne.w	23e38 <rpc_message_free+0x6c>
   23f8a:	2109      	movs	r1, #9
   23f8c:	e7ba      	b.n	23f04 <rpc_message_free+0x138>
   23f8e:	f894 1050 	ldrb.w	r1, [r4, #80]	; 0x50
   23f92:	2903      	cmp	r1, #3
   23f94:	f47f af54 	bne.w	23e40 <rpc_message_free+0x74>
   23f98:	210a      	movs	r1, #10
   23f9a:	e7b3      	b.n	23f04 <rpc_message_free+0x138>
   23f9c:	f894 1058 	ldrb.w	r1, [r4, #88]	; 0x58
   23fa0:	2903      	cmp	r1, #3
   23fa2:	f47f af51 	bne.w	23e48 <rpc_message_free+0x7c>
   23fa6:	210b      	movs	r1, #11
   23fa8:	e7ac      	b.n	23f04 <rpc_message_free+0x138>
   23faa:	200e      	movs	r0, #14
   23fac:	4770      	bx	lr
   23fae:	f894 1060 	ldrb.w	r1, [r4, #96]	; 0x60
   23fb2:	2903      	cmp	r1, #3
   23fb4:	f47f af4c 	bne.w	23e50 <rpc_message_free+0x84>
   23fb8:	210c      	movs	r1, #12
   23fba:	e7a3      	b.n	23f04 <rpc_message_free+0x138>
   23fbc:	f894 1068 	ldrb.w	r1, [r4, #104]	; 0x68
   23fc0:	2903      	cmp	r1, #3
   23fc2:	f47f af49 	bne.w	23e58 <rpc_message_free+0x8c>
   23fc6:	210d      	movs	r1, #13
   23fc8:	e79c      	b.n	23f04 <rpc_message_free+0x138>
   23fca:	f894 1070 	ldrb.w	r1, [r4, #112]	; 0x70
   23fce:	2903      	cmp	r1, #3
   23fd0:	f47f af46 	bne.w	23e60 <rpc_message_free+0x94>
   23fd4:	210e      	movs	r1, #14
   23fd6:	e795      	b.n	23f04 <rpc_message_free+0x138>
   23fd8:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
   23fdc:	2b03      	cmp	r3, #3
   23fde:	f47f af43 	bne.w	23e68 <rpc_message_free+0x9c>
   23fe2:	4603      	mov	r3, r0
   23fe4:	210f      	movs	r1, #15
   23fe6:	e78d      	b.n	23f04 <rpc_message_free+0x138>
   23fe8:	20028f78 	.word	0x20028f78
   23fec:	20029010 	.word	0x20029010

00023ff0 <rpc_message_data_free>:
   23ff0:	2800      	cmp	r0, #0
   23ff2:	f000 8091 	beq.w	24118 <rpc_message_data_free+0x128>
   23ff6:	2900      	cmp	r1, #0
   23ff8:	f000 80e4 	beq.w	241c4 <rpc_message_data_free+0x1d4>
   23ffc:	b538      	push	{r3, r4, r5, lr}
   23ffe:	4a81      	ldr	r2, [pc, #516]	; (24204 <rpc_message_data_free+0x214>)
   24000:	6853      	ldr	r3, [r2, #4]
   24002:	2b00      	cmp	r3, #0
   24004:	f000 808a 	beq.w	2411c <rpc_message_data_free+0x12c>
   24008:	4b7f      	ldr	r3, [pc, #508]	; (24208 <rpc_message_data_free+0x218>)
   2400a:	681c      	ldr	r4, [r3, #0]
   2400c:	42a1      	cmp	r1, r4
   2400e:	f000 8087 	beq.w	24120 <rpc_message_data_free+0x130>
   24012:	689c      	ldr	r4, [r3, #8]
   24014:	42a1      	cmp	r1, r4
   24016:	f000 808f 	beq.w	24138 <rpc_message_data_free+0x148>
   2401a:	691c      	ldr	r4, [r3, #16]
   2401c:	42a1      	cmp	r1, r4
   2401e:	f000 8091 	beq.w	24144 <rpc_message_data_free+0x154>
   24022:	699c      	ldr	r4, [r3, #24]
   24024:	42a1      	cmp	r1, r4
   24026:	f000 8093 	beq.w	24150 <rpc_message_data_free+0x160>
   2402a:	6a1c      	ldr	r4, [r3, #32]
   2402c:	42a1      	cmp	r1, r4
   2402e:	f000 8095 	beq.w	2415c <rpc_message_data_free+0x16c>
   24032:	6a9c      	ldr	r4, [r3, #40]	; 0x28
   24034:	42a1      	cmp	r1, r4
   24036:	f000 8097 	beq.w	24168 <rpc_message_data_free+0x178>
   2403a:	6b1c      	ldr	r4, [r3, #48]	; 0x30
   2403c:	42a1      	cmp	r1, r4
   2403e:	f000 8099 	beq.w	24174 <rpc_message_data_free+0x184>
   24042:	6b9c      	ldr	r4, [r3, #56]	; 0x38
   24044:	42a1      	cmp	r1, r4
   24046:	f000 809b 	beq.w	24180 <rpc_message_data_free+0x190>
   2404a:	6c1c      	ldr	r4, [r3, #64]	; 0x40
   2404c:	42a1      	cmp	r1, r4
   2404e:	f000 809d 	beq.w	2418c <rpc_message_data_free+0x19c>
   24052:	6c9c      	ldr	r4, [r3, #72]	; 0x48
   24054:	42a1      	cmp	r1, r4
   24056:	f000 80a0 	beq.w	2419a <rpc_message_data_free+0x1aa>
   2405a:	6d1c      	ldr	r4, [r3, #80]	; 0x50
   2405c:	42a1      	cmp	r1, r4
   2405e:	f000 80a3 	beq.w	241a8 <rpc_message_data_free+0x1b8>
   24062:	6d9c      	ldr	r4, [r3, #88]	; 0x58
   24064:	42a1      	cmp	r1, r4
   24066:	f000 80a6 	beq.w	241b6 <rpc_message_data_free+0x1c6>
   2406a:	6e1c      	ldr	r4, [r3, #96]	; 0x60
   2406c:	42a1      	cmp	r1, r4
   2406e:	f000 80ab 	beq.w	241c8 <rpc_message_data_free+0x1d8>
   24072:	6e9c      	ldr	r4, [r3, #104]	; 0x68
   24074:	42a1      	cmp	r1, r4
   24076:	f000 80ae 	beq.w	241d6 <rpc_message_data_free+0x1e6>
   2407a:	6f1c      	ldr	r4, [r3, #112]	; 0x70
   2407c:	42a1      	cmp	r1, r4
   2407e:	f000 80b1 	beq.w	241e4 <rpc_message_data_free+0x1f4>
   24082:	6f9c      	ldr	r4, [r3, #120]	; 0x78
   24084:	428c      	cmp	r4, r1
   24086:	f000 80b4 	beq.w	241f2 <rpc_message_data_free+0x202>
   2408a:	6913      	ldr	r3, [r2, #16]
   2408c:	4608      	mov	r0, r1
   2408e:	4798      	blx	r3
   24090:	4b5e      	ldr	r3, [pc, #376]	; (2420c <rpc_message_data_free+0x21c>)
   24092:	781a      	ldrb	r2, [r3, #0]
   24094:	2a04      	cmp	r2, #4
   24096:	d03b      	beq.n	24110 <rpc_message_data_free+0x120>
   24098:	7a1a      	ldrb	r2, [r3, #8]
   2409a:	2a04      	cmp	r2, #4
   2409c:	d038      	beq.n	24110 <rpc_message_data_free+0x120>
   2409e:	7c1a      	ldrb	r2, [r3, #16]
   240a0:	2a04      	cmp	r2, #4
   240a2:	d035      	beq.n	24110 <rpc_message_data_free+0x120>
   240a4:	7e1a      	ldrb	r2, [r3, #24]
   240a6:	2a04      	cmp	r2, #4
   240a8:	d032      	beq.n	24110 <rpc_message_data_free+0x120>
   240aa:	f893 2020 	ldrb.w	r2, [r3, #32]
   240ae:	2a04      	cmp	r2, #4
   240b0:	d02e      	beq.n	24110 <rpc_message_data_free+0x120>
   240b2:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
   240b6:	2a04      	cmp	r2, #4
   240b8:	d02a      	beq.n	24110 <rpc_message_data_free+0x120>
   240ba:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
   240be:	2a04      	cmp	r2, #4
   240c0:	d026      	beq.n	24110 <rpc_message_data_free+0x120>
   240c2:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
   240c6:	2a04      	cmp	r2, #4
   240c8:	d022      	beq.n	24110 <rpc_message_data_free+0x120>
   240ca:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
   240ce:	2a04      	cmp	r2, #4
   240d0:	d01e      	beq.n	24110 <rpc_message_data_free+0x120>
   240d2:	f893 2048 	ldrb.w	r2, [r3, #72]	; 0x48
   240d6:	2a04      	cmp	r2, #4
   240d8:	d01a      	beq.n	24110 <rpc_message_data_free+0x120>
   240da:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
   240de:	2a04      	cmp	r2, #4
   240e0:	d016      	beq.n	24110 <rpc_message_data_free+0x120>
   240e2:	f893 2058 	ldrb.w	r2, [r3, #88]	; 0x58
   240e6:	2a04      	cmp	r2, #4
   240e8:	d012      	beq.n	24110 <rpc_message_data_free+0x120>
   240ea:	f893 2060 	ldrb.w	r2, [r3, #96]	; 0x60
   240ee:	2a04      	cmp	r2, #4
   240f0:	d00e      	beq.n	24110 <rpc_message_data_free+0x120>
   240f2:	f893 2068 	ldrb.w	r2, [r3, #104]	; 0x68
   240f6:	2a04      	cmp	r2, #4
   240f8:	d00a      	beq.n	24110 <rpc_message_data_free+0x120>
   240fa:	f893 2070 	ldrb.w	r2, [r3, #112]	; 0x70
   240fe:	2a04      	cmp	r2, #4
   24100:	d006      	beq.n	24110 <rpc_message_data_free+0x120>
   24102:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
   24106:	2b04      	cmp	r3, #4
   24108:	bf18      	it	ne
   2410a:	2000      	movne	r0, #0
   2410c:	d000      	beq.n	24110 <rpc_message_data_free+0x120>
   2410e:	bd38      	pop	{r3, r4, r5, pc}
   24110:	f7f7 fc24 	bl	1b95c <bsd_os_application_irq_set>
   24114:	2000      	movs	r0, #0
   24116:	bd38      	pop	{r3, r4, r5, pc}
   24118:	2007      	movs	r0, #7
   2411a:	4770      	bx	lr
   2411c:	2008      	movs	r0, #8
   2411e:	bd38      	pop	{r3, r4, r5, pc}
   24120:	889c      	ldrh	r4, [r3, #4]
   24122:	4284      	cmp	r4, r0
   24124:	f47f af75 	bne.w	24012 <rpc_message_data_free+0x22>
   24128:	2400      	movs	r4, #0
   2412a:	2000      	movs	r0, #0
   2412c:	eb03 05c4 	add.w	r5, r3, r4, lsl #3
   24130:	f843 0034 	str.w	r0, [r3, r4, lsl #3]
   24134:	80a8      	strh	r0, [r5, #4]
   24136:	e7a8      	b.n	2408a <rpc_message_data_free+0x9a>
   24138:	899c      	ldrh	r4, [r3, #12]
   2413a:	4284      	cmp	r4, r0
   2413c:	f47f af6d 	bne.w	2401a <rpc_message_data_free+0x2a>
   24140:	2401      	movs	r4, #1
   24142:	e7f2      	b.n	2412a <rpc_message_data_free+0x13a>
   24144:	8a9c      	ldrh	r4, [r3, #20]
   24146:	4284      	cmp	r4, r0
   24148:	f47f af6b 	bne.w	24022 <rpc_message_data_free+0x32>
   2414c:	2402      	movs	r4, #2
   2414e:	e7ec      	b.n	2412a <rpc_message_data_free+0x13a>
   24150:	8b9c      	ldrh	r4, [r3, #28]
   24152:	4284      	cmp	r4, r0
   24154:	f47f af69 	bne.w	2402a <rpc_message_data_free+0x3a>
   24158:	2403      	movs	r4, #3
   2415a:	e7e6      	b.n	2412a <rpc_message_data_free+0x13a>
   2415c:	8c9c      	ldrh	r4, [r3, #36]	; 0x24
   2415e:	4284      	cmp	r4, r0
   24160:	f47f af67 	bne.w	24032 <rpc_message_data_free+0x42>
   24164:	2404      	movs	r4, #4
   24166:	e7e0      	b.n	2412a <rpc_message_data_free+0x13a>
   24168:	8d9c      	ldrh	r4, [r3, #44]	; 0x2c
   2416a:	4284      	cmp	r4, r0
   2416c:	f47f af65 	bne.w	2403a <rpc_message_data_free+0x4a>
   24170:	2405      	movs	r4, #5
   24172:	e7da      	b.n	2412a <rpc_message_data_free+0x13a>
   24174:	8e9c      	ldrh	r4, [r3, #52]	; 0x34
   24176:	4284      	cmp	r4, r0
   24178:	f47f af63 	bne.w	24042 <rpc_message_data_free+0x52>
   2417c:	2406      	movs	r4, #6
   2417e:	e7d4      	b.n	2412a <rpc_message_data_free+0x13a>
   24180:	8f9c      	ldrh	r4, [r3, #60]	; 0x3c
   24182:	4284      	cmp	r4, r0
   24184:	f47f af61 	bne.w	2404a <rpc_message_data_free+0x5a>
   24188:	2407      	movs	r4, #7
   2418a:	e7ce      	b.n	2412a <rpc_message_data_free+0x13a>
   2418c:	f8b3 4044 	ldrh.w	r4, [r3, #68]	; 0x44
   24190:	4284      	cmp	r4, r0
   24192:	f47f af5e 	bne.w	24052 <rpc_message_data_free+0x62>
   24196:	2408      	movs	r4, #8
   24198:	e7c7      	b.n	2412a <rpc_message_data_free+0x13a>
   2419a:	f8b3 404c 	ldrh.w	r4, [r3, #76]	; 0x4c
   2419e:	4284      	cmp	r4, r0
   241a0:	f47f af5b 	bne.w	2405a <rpc_message_data_free+0x6a>
   241a4:	2409      	movs	r4, #9
   241a6:	e7c0      	b.n	2412a <rpc_message_data_free+0x13a>
   241a8:	f8b3 4054 	ldrh.w	r4, [r3, #84]	; 0x54
   241ac:	4284      	cmp	r4, r0
   241ae:	f47f af58 	bne.w	24062 <rpc_message_data_free+0x72>
   241b2:	240a      	movs	r4, #10
   241b4:	e7b9      	b.n	2412a <rpc_message_data_free+0x13a>
   241b6:	f8b3 405c 	ldrh.w	r4, [r3, #92]	; 0x5c
   241ba:	4284      	cmp	r4, r0
   241bc:	f47f af55 	bne.w	2406a <rpc_message_data_free+0x7a>
   241c0:	240b      	movs	r4, #11
   241c2:	e7b2      	b.n	2412a <rpc_message_data_free+0x13a>
   241c4:	200e      	movs	r0, #14
   241c6:	4770      	bx	lr
   241c8:	f8b3 4064 	ldrh.w	r4, [r3, #100]	; 0x64
   241cc:	4284      	cmp	r4, r0
   241ce:	f47f af50 	bne.w	24072 <rpc_message_data_free+0x82>
   241d2:	240c      	movs	r4, #12
   241d4:	e7a9      	b.n	2412a <rpc_message_data_free+0x13a>
   241d6:	f8b3 406c 	ldrh.w	r4, [r3, #108]	; 0x6c
   241da:	4284      	cmp	r4, r0
   241dc:	f47f af4d 	bne.w	2407a <rpc_message_data_free+0x8a>
   241e0:	240d      	movs	r4, #13
   241e2:	e7a2      	b.n	2412a <rpc_message_data_free+0x13a>
   241e4:	f8b3 4074 	ldrh.w	r4, [r3, #116]	; 0x74
   241e8:	4284      	cmp	r4, r0
   241ea:	f47f af4a 	bne.w	24082 <rpc_message_data_free+0x92>
   241ee:	240e      	movs	r4, #14
   241f0:	e79b      	b.n	2412a <rpc_message_data_free+0x13a>
   241f2:	f8b3 407c 	ldrh.w	r4, [r3, #124]	; 0x7c
   241f6:	4284      	cmp	r4, r0
   241f8:	bf08      	it	eq
   241fa:	240f      	moveq	r4, #15
   241fc:	f47f af45 	bne.w	2408a <rpc_message_data_free+0x9a>
   24200:	e793      	b.n	2412a <rpc_message_data_free+0x13a>
   24202:	bf00      	nop
   24204:	20028f78 	.word	0x20028f78
   24208:	20028f90 	.word	0x20028f90
   2420c:	20029010 	.word	0x20029010

00024210 <packet_free_cb>:
   24210:	b510      	push	{r4, lr}
   24212:	4604      	mov	r4, r0
   24214:	b118      	cbz	r0, 2421e <packet_free_cb+0xe>
   24216:	6800      	ldr	r0, [r0, #0]
   24218:	b108      	cbz	r0, 2421e <packet_free_cb+0xe>
   2421a:	f001 f82f 	bl	2527c <rpc_gnss_client_data_free>
   2421e:	68a0      	ldr	r0, [r4, #8]
   24220:	b118      	cbz	r0, 2422a <packet_free_cb+0x1a>
   24222:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   24226:	f7fa b917 	b.w	1e458 <nrf_free>
   2422a:	bd10      	pop	{r4, pc}

0002422c <rpc_gnss_event_handler>:
   2422c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   24230:	4b64      	ldr	r3, [pc, #400]	; (243c4 <rpc_gnss_event_handler+0x198>)
   24232:	4606      	mov	r6, r0
   24234:	6800      	ldr	r0, [r0, #0]
   24236:	881b      	ldrh	r3, [r3, #0]
   24238:	6802      	ldr	r2, [r0, #0]
   2423a:	4f63      	ldr	r7, [pc, #396]	; (243c8 <rpc_gnss_event_handler+0x19c>)
   2423c:	ebb3 4f12 	cmp.w	r3, r2, lsr #16
   24240:	b084      	sub	sp, #16
   24242:	460d      	mov	r5, r1
   24244:	6038      	str	r0, [r7, #0]
   24246:	d038      	beq.n	242ba <rpc_gnss_event_handler+0x8e>
   24248:	f505 433f 	add.w	r3, r5, #48896	; 0xbf00
   2424c:	33ff      	adds	r3, #255	; 0xff
   2424e:	b29b      	uxth	r3, r3
   24250:	2b02      	cmp	r3, #2
   24252:	d810      	bhi.n	24276 <rpc_gnss_event_handler+0x4a>
   24254:	4c5d      	ldr	r4, [pc, #372]	; (243cc <rpc_gnss_event_handler+0x1a0>)
   24256:	6823      	ldr	r3, [r4, #0]
   24258:	075a      	lsls	r2, r3, #29
   2425a:	d410      	bmi.n	2427e <rpc_gnss_event_handler+0x52>
   2425c:	6823      	ldr	r3, [r4, #0]
   2425e:	079b      	lsls	r3, r3, #30
   24260:	d503      	bpl.n	2426a <rpc_gnss_event_handler+0x3e>
   24262:	f244 0303 	movw	r3, #16387	; 0x4003
   24266:	429d      	cmp	r5, r3
   24268:	d009      	beq.n	2427e <rpc_gnss_event_handler+0x52>
   2426a:	6830      	ldr	r0, [r6, #0]
   2426c:	b118      	cbz	r0, 24276 <rpc_gnss_event_handler+0x4a>
   2426e:	f001 f805 	bl	2527c <rpc_gnss_client_data_free>
   24272:	2300      	movs	r3, #0
   24274:	603b      	str	r3, [r7, #0]
   24276:	2000      	movs	r0, #0
   24278:	b004      	add	sp, #16
   2427a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2427e:	2002      	movs	r0, #2
   24280:	f7fa f8e0 	bl	1e444 <nrf_malloc>
   24284:	4680      	mov	r8, r0
   24286:	2800      	cmp	r0, #0
   24288:	f000 8093 	beq.w	243b2 <rpc_gnss_event_handler+0x186>
   2428c:	2302      	movs	r3, #2
   2428e:	8005      	strh	r5, [r0, #0]
   24290:	6831      	ldr	r1, [r6, #0]
   24292:	6872      	ldr	r2, [r6, #4]
   24294:	484e      	ldr	r0, [pc, #312]	; (243d0 <rpc_gnss_event_handler+0x1a4>)
   24296:	e88d 0106 	stmia.w	sp, {r1, r2, r8}
   2429a:	6800      	ldr	r0, [r0, #0]
   2429c:	9303      	str	r3, [sp, #12]
   2429e:	6803      	ldr	r3, [r0, #0]
   242a0:	4669      	mov	r1, sp
   242a2:	685b      	ldr	r3, [r3, #4]
   242a4:	4798      	blx	r3
   242a6:	3001      	adds	r0, #1
   242a8:	d070      	beq.n	2438c <rpc_gnss_event_handler+0x160>
   242aa:	2000      	movs	r0, #0
   242ac:	6823      	ldr	r3, [r4, #0]
   242ae:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   242b2:	6023      	str	r3, [r4, #0]
   242b4:	b004      	add	sp, #16
   242b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   242ba:	4c44      	ldr	r4, [pc, #272]	; (243cc <rpc_gnss_event_handler+0x1a0>)
   242bc:	6823      	ldr	r3, [r4, #0]
   242be:	01d9      	lsls	r1, r3, #7
   242c0:	d523      	bpl.n	2430a <rpc_gnss_event_handler+0xde>
   242c2:	f242 1302 	movw	r3, #8450	; 0x2102
   242c6:	429d      	cmp	r5, r3
   242c8:	d11f      	bne.n	2430a <rpc_gnss_event_handler+0xde>
   242ca:	6843      	ldr	r3, [r0, #4]
   242cc:	b91b      	cbnz	r3, 242d6 <rpc_gnss_event_handler+0xaa>
   242ce:	6823      	ldr	r3, [r4, #0]
   242d0:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   242d4:	6023      	str	r3, [r4, #0]
   242d6:	6823      	ldr	r3, [r4, #0]
   242d8:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   242dc:	6023      	str	r3, [r4, #0]
   242de:	6823      	ldr	r3, [r4, #0]
   242e0:	025a      	lsls	r2, r3, #9
   242e2:	d430      	bmi.n	24346 <rpc_gnss_event_handler+0x11a>
   242e4:	f242 0305 	movw	r3, #8197	; 0x2005
   242e8:	429d      	cmp	r5, r3
   242ea:	d12c      	bne.n	24346 <rpc_gnss_event_handler+0x11a>
   242ec:	6823      	ldr	r3, [r4, #0]
   242ee:	0299      	lsls	r1, r3, #10
   242f0:	d529      	bpl.n	24346 <rpc_gnss_event_handler+0x11a>
   242f2:	6843      	ldr	r3, [r0, #4]
   242f4:	2b00      	cmp	r3, #0
   242f6:	d157      	bne.n	243a8 <rpc_gnss_event_handler+0x17c>
   242f8:	6823      	ldr	r3, [r4, #0]
   242fa:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   242fe:	6023      	str	r3, [r4, #0]
   24300:	6823      	ldr	r3, [r4, #0]
   24302:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   24306:	6023      	str	r3, [r4, #0]
   24308:	e01d      	b.n	24346 <rpc_gnss_event_handler+0x11a>
   2430a:	6823      	ldr	r3, [r4, #0]
   2430c:	025b      	lsls	r3, r3, #9
   2430e:	d50e      	bpl.n	2432e <rpc_gnss_event_handler+0x102>
   24310:	f242 1303 	movw	r3, #8451	; 0x2103
   24314:	429d      	cmp	r5, r3
   24316:	d10a      	bne.n	2432e <rpc_gnss_event_handler+0x102>
   24318:	6843      	ldr	r3, [r0, #4]
   2431a:	b91b      	cbnz	r3, 24324 <rpc_gnss_event_handler+0xf8>
   2431c:	6823      	ldr	r3, [r4, #0]
   2431e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   24322:	6023      	str	r3, [r4, #0]
   24324:	6823      	ldr	r3, [r4, #0]
   24326:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   2432a:	6023      	str	r3, [r4, #0]
   2432c:	e00b      	b.n	24346 <rpc_gnss_event_handler+0x11a>
   2432e:	f242 0301 	movw	r3, #8193	; 0x2001
   24332:	429d      	cmp	r5, r3
   24334:	d10c      	bne.n	24350 <rpc_gnss_event_handler+0x124>
   24336:	6843      	ldr	r3, [r0, #4]
   24338:	b92b      	cbnz	r3, 24346 <rpc_gnss_event_handler+0x11a>
   2433a:	6823      	ldr	r3, [r4, #0]
   2433c:	0c1b      	lsrs	r3, r3, #16
   2433e:	041b      	lsls	r3, r3, #16
   24340:	f043 0302 	orr.w	r3, r3, #2
   24344:	6023      	str	r3, [r4, #0]
   24346:	f000 ff99 	bl	2527c <rpc_gnss_client_data_free>
   2434a:	2300      	movs	r3, #0
   2434c:	603b      	str	r3, [r7, #0]
   2434e:	e77b      	b.n	24248 <rpc_gnss_event_handler+0x1c>
   24350:	f242 0304 	movw	r3, #8196	; 0x2004
   24354:	429d      	cmp	r5, r3
   24356:	d1c5      	bne.n	242e4 <rpc_gnss_event_handler+0xb8>
   24358:	6843      	ldr	r3, [r0, #4]
   2435a:	b993      	cbnz	r3, 24382 <rpc_gnss_event_handler+0x156>
   2435c:	6823      	ldr	r3, [r4, #0]
   2435e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   24362:	6023      	str	r3, [r4, #0]
   24364:	6823      	ldr	r3, [r4, #0]
   24366:	b29b      	uxth	r3, r3
   24368:	2b03      	cmp	r3, #3
   2436a:	6823      	ldr	r3, [r4, #0]
   2436c:	d016      	beq.n	2439c <rpc_gnss_event_handler+0x170>
   2436e:	b29b      	uxth	r3, r3
   24370:	2b04      	cmp	r3, #4
   24372:	d1d7      	bne.n	24324 <rpc_gnss_event_handler+0xf8>
   24374:	6823      	ldr	r3, [r4, #0]
   24376:	0c1b      	lsrs	r3, r3, #16
   24378:	041b      	lsls	r3, r3, #16
   2437a:	f043 0302 	orr.w	r3, r3, #2
   2437e:	6023      	str	r3, [r4, #0]
   24380:	e7d0      	b.n	24324 <rpc_gnss_event_handler+0xf8>
   24382:	6823      	ldr	r3, [r4, #0]
   24384:	b29b      	uxth	r3, r3
   24386:	2b03      	cmp	r3, #3
   24388:	d1cc      	bne.n	24324 <rpc_gnss_event_handler+0xf8>
   2438a:	e7f3      	b.n	24374 <rpc_gnss_event_handler+0x148>
   2438c:	4640      	mov	r0, r8
   2438e:	f7fa f863 	bl	1e458 <nrf_free>
   24392:	6830      	ldr	r0, [r6, #0]
   24394:	2800      	cmp	r0, #0
   24396:	f47f af6a 	bne.w	2426e <rpc_gnss_event_handler+0x42>
   2439a:	e76c      	b.n	24276 <rpc_gnss_event_handler+0x4a>
   2439c:	0c1b      	lsrs	r3, r3, #16
   2439e:	041b      	lsls	r3, r3, #16
   243a0:	f043 0304 	orr.w	r3, r3, #4
   243a4:	6023      	str	r3, [r4, #0]
   243a6:	e7bd      	b.n	24324 <rpc_gnss_event_handler+0xf8>
   243a8:	6823      	ldr	r3, [r4, #0]
   243aa:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   243ae:	6023      	str	r3, [r4, #0]
   243b0:	e7c9      	b.n	24346 <rpc_gnss_event_handler+0x11a>
   243b2:	6830      	ldr	r0, [r6, #0]
   243b4:	2800      	cmp	r0, #0
   243b6:	f43f af5e 	beq.w	24276 <rpc_gnss_event_handler+0x4a>
   243ba:	f000 ff5f 	bl	2527c <rpc_gnss_client_data_free>
   243be:	f8c7 8000 	str.w	r8, [r7]
   243c2:	e758      	b.n	24276 <rpc_gnss_event_handler+0x4a>
   243c4:	2002d490 	.word	0x2002d490
   243c8:	20029094 	.word	0x20029094
   243cc:	20029090 	.word	0x20029090
   243d0:	20029098 	.word	0x20029098

000243d4 <gnss_interface_write>:
   243d4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   243d8:	4a74      	ldr	r2, [pc, #464]	; (245ac <gnss_interface_write+0x1d8>)
   243da:	b09f      	sub	sp, #124	; 0x7c
   243dc:	4290      	cmp	r0, r2
   243de:	9d26      	ldr	r5, [sp, #152]	; 0x98
   243e0:	f040 80d7 	bne.w	24592 <gnss_interface_write+0x1be>
   243e4:	2900      	cmp	r1, #0
   243e6:	f000 80c6 	beq.w	24576 <gnss_interface_write+0x1a2>
   243ea:	2d00      	cmp	r5, #0
   243ec:	f000 80c3 	beq.w	24576 <gnss_interface_write+0x1a2>
   243f0:	9a27      	ldr	r2, [sp, #156]	; 0x9c
   243f2:	2a02      	cmp	r2, #2
   243f4:	f040 80bf 	bne.w	24576 <gnss_interface_write+0x1a2>
   243f8:	4c6d      	ldr	r4, [pc, #436]	; (245b0 <gnss_interface_write+0x1dc>)
   243fa:	6822      	ldr	r2, [r4, #0]
   243fc:	b292      	uxth	r2, r2
   243fe:	2a02      	cmp	r2, #2
   24400:	d004      	beq.n	2440c <gnss_interface_write+0x38>
   24402:	6822      	ldr	r2, [r4, #0]
   24404:	b292      	uxth	r2, r2
   24406:	2a04      	cmp	r2, #4
   24408:	f040 80bd 	bne.w	24586 <gnss_interface_write+0x1b2>
   2440c:	2b00      	cmp	r3, #0
   2440e:	f040 80c6 	bne.w	2459e <gnss_interface_write+0x1ca>
   24412:	6822      	ldr	r2, [r4, #0]
   24414:	0390      	lsls	r0, r2, #14
   24416:	d512      	bpl.n	2443e <gnss_interface_write+0x6a>
   24418:	6822      	ldr	r2, [r4, #0]
   2441a:	882b      	ldrh	r3, [r5, #0]
   2441c:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
   24420:	6022      	str	r2, [r4, #0]
   24422:	6822      	ldr	r2, [r4, #0]
   24424:	3b01      	subs	r3, #1
   24426:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
   2442a:	6022      	str	r2, [r4, #0]
   2442c:	2b07      	cmp	r3, #7
   2442e:	f200 80a2 	bhi.w	24576 <gnss_interface_write+0x1a2>
   24432:	e8df f003 	tbb	[pc, r3]
   24436:	7d82      	.short	0x7d82
   24438:	646e7378 	.word	0x646e7378
   2443c:	0869      	.short	0x0869
   2443e:	2000      	movs	r0, #0
   24440:	b01f      	add	sp, #124	; 0x7c
   24442:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   24446:	4608      	mov	r0, r1
   24448:	a902      	add	r1, sp, #8
   2444a:	f000 fecb 	bl	251e4 <rpc_gnss_serialize_integrity>
   2444e:	2172      	movs	r1, #114	; 0x72
   24450:	4668      	mov	r0, sp
   24452:	f000 fee1 	bl	25218 <rpc_gnss_client_request_alloc>
   24456:	4605      	mov	r5, r0
   24458:	9800      	ldr	r0, [sp, #0]
   2445a:	2d00      	cmp	r5, #0
   2445c:	d172      	bne.n	24544 <gnss_interface_write+0x170>
   2445e:	2800      	cmp	r0, #0
   24460:	d077      	beq.n	24552 <gnss_interface_write+0x17e>
   24462:	f241 0605 	movw	r6, #4101	; 0x1005
   24466:	f04f 0c49 	mov.w	ip, #73	; 0x49
   2446a:	2272      	movs	r2, #114	; 0x72
   2446c:	f04f 0e76 	mov.w	lr, #118	; 0x76
   24470:	f04f 0943 	mov.w	r9, #67	; 0x43
   24474:	f04f 0854 	mov.w	r8, #84	; 0x54
   24478:	4f4e      	ldr	r7, [pc, #312]	; (245b4 <gnss_interface_write+0x1e0>)
   2447a:	a91e      	add	r1, sp, #120	; 0x78
   2447c:	883b      	ldrh	r3, [r7, #0]
   2447e:	f880 c00f 	strb.w	ip, [r0, #15]
   24482:	3301      	adds	r3, #1
   24484:	b29b      	uxth	r3, r3
   24486:	ea46 4c03 	orr.w	ip, r6, r3, lsl #16
   2448a:	f841 cd74 	str.w	ip, [r1, #-116]!
   2448e:	7145      	strb	r5, [r0, #5]
   24490:	7185      	strb	r5, [r0, #6]
   24492:	71c5      	strb	r5, [r0, #7]
   24494:	7205      	strb	r5, [r0, #8]
   24496:	7245      	strb	r5, [r0, #9]
   24498:	7285      	strb	r5, [r0, #10]
   2449a:	72c5      	strb	r5, [r0, #11]
   2449c:	7102      	strb	r2, [r0, #4]
   2449e:	f880 900c 	strb.w	r9, [r0, #12]
   244a2:	f880 800d 	strb.w	r8, [r0, #13]
   244a6:	f880 e00e 	strb.w	lr, [r0, #14]
   244aa:	6800      	ldr	r0, [r0, #0]
   244ac:	803b      	strh	r3, [r7, #0]
   244ae:	f00a ff51 	bl	2f354 <memcpy>
   244b2:	4b41      	ldr	r3, [pc, #260]	; (245b8 <gnss_interface_write+0x1e4>)
   244b4:	4631      	mov	r1, r6
   244b6:	9800      	ldr	r0, [sp, #0]
   244b8:	601d      	str	r5, [r3, #0]
   244ba:	f000 fec1 	bl	25240 <rpc_gnss_client_request_send>
   244be:	2800      	cmp	r0, #0
   244c0:	d14e      	bne.n	24560 <gnss_interface_write+0x18c>
   244c2:	6823      	ldr	r3, [r4, #0]
   244c4:	0299      	lsls	r1, r3, #10
   244c6:	d50b      	bpl.n	244e0 <gnss_interface_write+0x10c>
   244c8:	4e3c      	ldr	r6, [pc, #240]	; (245bc <gnss_interface_write+0x1e8>)
   244ca:	4d38      	ldr	r5, [pc, #224]	; (245ac <gnss_interface_write+0x1d8>)
   244cc:	e000      	b.n	244d0 <gnss_interface_write+0xfc>
   244ce:	b978      	cbnz	r0, 244f0 <gnss_interface_write+0x11c>
   244d0:	4631      	mov	r1, r6
   244d2:	4628      	mov	r0, r5
   244d4:	f7f7 f8b6 	bl	1b644 <bsd_os_timedwait>
   244d8:	6823      	ldr	r3, [r4, #0]
   244da:	029a      	lsls	r2, r3, #10
   244dc:	d4f7      	bmi.n	244ce <gnss_interface_write+0xfa>
   244de:	b938      	cbnz	r0, 244f0 <gnss_interface_write+0x11c>
   244e0:	6823      	ldr	r3, [r4, #0]
   244e2:	039b      	lsls	r3, r3, #14
   244e4:	d4ab      	bmi.n	2443e <gnss_interface_write+0x6a>
   244e6:	2005      	movs	r0, #5
   244e8:	6823      	ldr	r3, [r4, #0]
   244ea:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   244ee:	6023      	str	r3, [r4, #0]
   244f0:	f7f7 f93c 	bl	1b76c <bsd_os_errno_set>
   244f4:	f04f 30ff 	mov.w	r0, #4294967295
   244f8:	b01f      	add	sp, #124	; 0x7c
   244fa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   244fe:	4608      	mov	r0, r1
   24500:	a902      	add	r1, sp, #8
   24502:	f000 fe27 	bl	25154 <rpc_gnss_serialize_time_and_sv_tow>
   24506:	e7a2      	b.n	2444e <gnss_interface_write+0x7a>
   24508:	4608      	mov	r0, r1
   2450a:	a902      	add	r1, sp, #8
   2450c:	f000 fe4a 	bl	251a4 <rpc_gnss_serialize_location>
   24510:	e79d      	b.n	2444e <gnss_interface_write+0x7a>
   24512:	4608      	mov	r0, r1
   24514:	a902      	add	r1, sp, #8
   24516:	f000 fe03 	bl	25120 <rpc_gnss_serialize_nequick>
   2451a:	e798      	b.n	2444e <gnss_interface_write+0x7a>
   2451c:	4608      	mov	r0, r1
   2451e:	a902      	add	r1, sp, #8
   24520:	f000 fdda 	bl	250d8 <rpc_gnss_serialize_klob>
   24524:	e793      	b.n	2444e <gnss_interface_write+0x7a>
   24526:	4608      	mov	r0, r1
   24528:	a902      	add	r1, sp, #8
   2452a:	f000 fda3 	bl	25074 <rpc_gnss_serialize_alm>
   2452e:	e78e      	b.n	2444e <gnss_interface_write+0x7a>
   24530:	4608      	mov	r0, r1
   24532:	a902      	add	r1, sp, #8
   24534:	f000 fd4c 	bl	24fd0 <rpc_gnss_serialize_ephe>
   24538:	e789      	b.n	2444e <gnss_interface_write+0x7a>
   2453a:	4608      	mov	r0, r1
   2453c:	a902      	add	r1, sp, #8
   2453e:	f000 fd25 	bl	24f8c <rpc_gnss_serialize_utc>
   24542:	e784      	b.n	2444e <gnss_interface_write+0x7a>
   24544:	b128      	cbz	r0, 24552 <gnss_interface_write+0x17e>
   24546:	6803      	ldr	r3, [r0, #0]
   24548:	b11b      	cbz	r3, 24552 <gnss_interface_write+0x17e>
   2454a:	4618      	mov	r0, r3
   2454c:	f000 fe96 	bl	2527c <rpc_gnss_client_data_free>
   24550:	9800      	ldr	r0, [sp, #0]
   24552:	f000 fe8b 	bl	2526c <rpc_gnss_client_message_free>
   24556:	2023      	movs	r0, #35	; 0x23
   24558:	f7f7 f908 	bl	1b76c <bsd_os_errno_set>
   2455c:	f04f 30ff 	mov.w	r0, #4294967295
   24560:	6823      	ldr	r3, [r4, #0]
   24562:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   24566:	6023      	str	r3, [r4, #0]
   24568:	6823      	ldr	r3, [r4, #0]
   2456a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2456e:	6023      	str	r3, [r4, #0]
   24570:	b01f      	add	sp, #124	; 0x7c
   24572:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   24576:	2016      	movs	r0, #22
   24578:	f7f7 f8f8 	bl	1b76c <bsd_os_errno_set>
   2457c:	f04f 30ff 	mov.w	r0, #4294967295
   24580:	b01f      	add	sp, #124	; 0x7c
   24582:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   24586:	2039      	movs	r0, #57	; 0x39
   24588:	f7f7 f8f0 	bl	1b76c <bsd_os_errno_set>
   2458c:	f04f 30ff 	mov.w	r0, #4294967295
   24590:	e756      	b.n	24440 <gnss_interface_write+0x6c>
   24592:	2009      	movs	r0, #9
   24594:	f7f7 f8ea 	bl	1b76c <bsd_os_errno_set>
   24598:	f04f 30ff 	mov.w	r0, #4294967295
   2459c:	e750      	b.n	24440 <gnss_interface_write+0x6c>
   2459e:	202d      	movs	r0, #45	; 0x2d
   245a0:	f7f7 f8e4 	bl	1b76c <bsd_os_errno_set>
   245a4:	f04f 30ff 	mov.w	r0, #4294967295
   245a8:	e74a      	b.n	24440 <gnss_interface_write+0x6c>
   245aa:	bf00      	nop
   245ac:	49765443 	.word	0x49765443
   245b0:	20029090 	.word	0x20029090
   245b4:	2002d490 	.word	0x2002d490
   245b8:	20029094 	.word	0x20029094
   245bc:	200383c4 	.word	0x200383c4

000245c0 <gnss_interface_read>:
   245c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   245c4:	4c50      	ldr	r4, [pc, #320]	; (24708 <gnss_interface_read+0x148>)
   245c6:	b0b7      	sub	sp, #220	; 0xdc
   245c8:	42a0      	cmp	r0, r4
   245ca:	f040 81fe 	bne.w	249ca <gnss_interface_read+0x40a>
   245ce:	4688      	mov	r8, r1
   245d0:	2900      	cmp	r1, #0
   245d2:	f000 81f4 	beq.w	249be <gnss_interface_read+0x3fe>
   245d6:	2ad7      	cmp	r2, #215	; 0xd7
   245d8:	f240 81f1 	bls.w	249be <gnss_interface_read+0x3fe>
   245dc:	4d4b      	ldr	r5, [pc, #300]	; (2470c <gnss_interface_read+0x14c>)
   245de:	4699      	mov	r9, r3
   245e0:	682b      	ldr	r3, [r5, #0]
   245e2:	b29b      	uxth	r3, r3
   245e4:	2b04      	cmp	r3, #4
   245e6:	d004      	beq.n	245f2 <gnss_interface_read+0x32>
   245e8:	682b      	ldr	r3, [r5, #0]
   245ea:	b29b      	uxth	r3, r3
   245ec:	2b02      	cmp	r3, #2
   245ee:	f040 81e0 	bne.w	249b2 <gnss_interface_read+0x3f2>
   245f2:	f1b9 0f00 	cmp.w	r9, #0
   245f6:	d158      	bne.n	246aa <gnss_interface_read+0xea>
   245f8:	2102      	movs	r1, #2
   245fa:	20b6      	movs	r0, #182	; 0xb6
   245fc:	2400      	movs	r4, #0
   245fe:	682b      	ldr	r3, [r5, #0]
   24600:	f10d 020e 	add.w	r2, sp, #14
   24604:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   24608:	602b      	str	r3, [r5, #0]
   2460a:	f8df a108 	ldr.w	sl, [pc, #264]	; 24714 <gnss_interface_read+0x154>
   2460e:	ab08      	add	r3, sp, #32
   24610:	4f3f      	ldr	r7, [pc, #252]	; (24710 <gnss_interface_read+0x150>)
   24612:	4e3d      	ldr	r6, [pc, #244]	; (24708 <gnss_interface_read+0x148>)
   24614:	9005      	str	r0, [sp, #20]
   24616:	9107      	str	r1, [sp, #28]
   24618:	9304      	str	r3, [sp, #16]
   2461a:	9206      	str	r2, [sp, #24]
   2461c:	ea09 0b01 	and.w	fp, r9, r1
   24620:	f8da 0000 	ldr.w	r0, [sl]
   24624:	464a      	mov	r2, r9
   24626:	6803      	ldr	r3, [r0, #0]
   24628:	a904      	add	r1, sp, #16
   2462a:	689b      	ldr	r3, [r3, #8]
   2462c:	4798      	blx	r3
   2462e:	2800      	cmp	r0, #0
   24630:	da11      	bge.n	24656 <gnss_interface_read+0x96>
   24632:	f1bb 0f00 	cmp.w	fp, #0
   24636:	d141      	bne.n	246bc <gnss_interface_read+0xfc>
   24638:	682b      	ldr	r3, [r5, #0]
   2463a:	03d8      	lsls	r0, r3, #15
   2463c:	d4f0      	bmi.n	24620 <gnss_interface_read+0x60>
   2463e:	b10c      	cbz	r4, 24644 <gnss_interface_read+0x84>
   24640:	e7ee      	b.n	24620 <gnss_interface_read+0x60>
   24642:	b930      	cbnz	r0, 24652 <gnss_interface_read+0x92>
   24644:	4639      	mov	r1, r7
   24646:	4630      	mov	r0, r6
   24648:	f7f6 fffc 	bl	1b644 <bsd_os_timedwait>
   2464c:	682b      	ldr	r3, [r5, #0]
   2464e:	03d9      	lsls	r1, r3, #15
   24650:	d5f7      	bpl.n	24642 <gnss_interface_read+0x82>
   24652:	4604      	mov	r4, r0
   24654:	e7e4      	b.n	24620 <gnss_interface_read+0x60>
   24656:	f244 0202 	movw	r2, #16386	; 0x4002
   2465a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   2465e:	4293      	cmp	r3, r2
   24660:	d042      	beq.n	246e8 <gnss_interface_read+0x128>
   24662:	f244 0201 	movw	r2, #16385	; 0x4001
   24666:	4293      	cmp	r3, r2
   24668:	d056      	beq.n	24718 <gnss_interface_read+0x158>
   2466a:	f244 0203 	movw	r2, #16387	; 0x4003
   2466e:	4293      	cmp	r3, r2
   24670:	f040 81a5 	bne.w	249be <gnss_interface_read+0x3fe>
   24674:	2203      	movs	r2, #3
   24676:	2414      	movs	r4, #20
   24678:	9b08      	ldr	r3, [sp, #32]
   2467a:	f888 2000 	strb.w	r2, [r8]
   2467e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   24680:	f8c8 3008 	str.w	r3, [r8, #8]
   24684:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   24688:	e9c8 2303 	strd	r2, r3, [r8, #12]
   2468c:	f8da 0000 	ldr.w	r0, [sl]
   24690:	6803      	ldr	r3, [r0, #0]
   24692:	68db      	ldr	r3, [r3, #12]
   24694:	4798      	blx	r3
   24696:	2800      	cmp	r0, #0
   24698:	dd03      	ble.n	246a2 <gnss_interface_read+0xe2>
   2469a:	682b      	ldr	r3, [r5, #0]
   2469c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   246a0:	602b      	str	r3, [r5, #0]
   246a2:	4620      	mov	r0, r4
   246a4:	b037      	add	sp, #220	; 0xdc
   246a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   246aa:	f019 0f0a 	tst.w	r9, #10
   246ae:	d1a3      	bne.n	245f8 <gnss_interface_read+0x38>
   246b0:	202d      	movs	r0, #45	; 0x2d
   246b2:	f7f7 f85b 	bl	1b76c <bsd_os_errno_set>
   246b6:	f04f 34ff 	mov.w	r4, #4294967295
   246ba:	e7f2      	b.n	246a2 <gnss_interface_read+0xe2>
   246bc:	1c42      	adds	r2, r0, #1
   246be:	4603      	mov	r3, r0
   246c0:	d1c9      	bne.n	24656 <gnss_interface_read+0x96>
   246c2:	b93c      	cbnz	r4, 246d4 <gnss_interface_read+0x114>
   246c4:	461c      	mov	r4, r3
   246c6:	2023      	movs	r0, #35	; 0x23
   246c8:	f7f7 f850 	bl	1b76c <bsd_os_errno_set>
   246cc:	4620      	mov	r0, r4
   246ce:	b037      	add	sp, #220	; 0xdc
   246d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   246d4:	9001      	str	r0, [sp, #4]
   246d6:	4620      	mov	r0, r4
   246d8:	f7f7 f848 	bl	1b76c <bsd_os_errno_set>
   246dc:	9b01      	ldr	r3, [sp, #4]
   246de:	461c      	mov	r4, r3
   246e0:	4620      	mov	r0, r4
   246e2:	b037      	add	sp, #220	; 0xdc
   246e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   246e8:	a808      	add	r0, sp, #32
   246ea:	f7e8 fc35 	bl	cf58 <strlen>
   246ee:	2302      	movs	r3, #2
   246f0:	1c44      	adds	r4, r0, #1
   246f2:	b2a4      	uxth	r4, r4
   246f4:	f808 3b08 	strb.w	r3, [r8], #8
   246f8:	4622      	mov	r2, r4
   246fa:	a908      	add	r1, sp, #32
   246fc:	4640      	mov	r0, r8
   246fe:	f00a fe29 	bl	2f354 <memcpy>
   24702:	3408      	adds	r4, #8
   24704:	e7c2      	b.n	2468c <gnss_interface_read+0xcc>
   24706:	bf00      	nop
   24708:	49765443 	.word	0x49765443
   2470c:	20029090 	.word	0x20029090
   24710:	200383c4 	.word	0x200383c4
   24714:	20029098 	.word	0x20029098
   24718:	2401      	movs	r4, #1
   2471a:	a809      	add	r0, sp, #36	; 0x24
   2471c:	c80f      	ldmia	r0, {r0, r1, r2, r3}
   2471e:	e9c8 0102 	strd	r0, r1, [r8, #8]
   24722:	e9c8 2304 	strd	r2, r3, [r8, #16]
   24726:	990d      	ldr	r1, [sp, #52]	; 0x34
   24728:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   2472a:	f888 4000 	strb.w	r4, [r8]
   2472e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   24730:	f8c8 1018 	str.w	r1, [r8, #24]
   24734:	9910      	ldr	r1, [sp, #64]	; 0x40
   24736:	f8c8 201c 	str.w	r2, [r8, #28]
   2473a:	f8c8 3020 	str.w	r3, [r8, #32]
   2473e:	f89d 205d 	ldrb.w	r2, [sp, #93]	; 0x5d
   24742:	f8dd 304d 	ldr.w	r3, [sp, #77]	; 0x4d
   24746:	f8c8 1024 	str.w	r1, [r8, #36]	; 0x24
   2474a:	f8dd 1051 	ldr.w	r1, [sp, #81]	; 0x51
   2474e:	f888 2044 	strb.w	r2, [r8, #68]	; 0x44
   24752:	f8dd 2055 	ldr.w	r2, [sp, #85]	; 0x55
   24756:	f8c8 3034 	str.w	r3, [r8, #52]	; 0x34
   2475a:	f8dd 3059 	ldr.w	r3, [sp, #89]	; 0x59
   2475e:	f8c8 1038 	str.w	r1, [r8, #56]	; 0x38
   24762:	f8bd 1044 	ldrh.w	r1, [sp, #68]	; 0x44
   24766:	f8c8 203c 	str.w	r2, [r8, #60]	; 0x3c
   2476a:	f8c8 3040 	str.w	r3, [r8, #64]	; 0x40
   2476e:	f8dd 2046 	ldr.w	r2, [sp, #70]	; 0x46
   24772:	f89d 304a 	ldrb.w	r3, [sp, #74]	; 0x4a
   24776:	f8a8 1028 	strh.w	r1, [r8, #40]	; 0x28
   2477a:	f888 302e 	strb.w	r3, [r8, #46]	; 0x2e
   2477e:	f8c8 202a 	str.w	r2, [r8, #42]	; 0x2a
   24782:	f89d 004b 	ldrb.w	r0, [sp, #75]	; 0x4b
   24786:	f89d 204c 	ldrb.w	r2, [sp, #76]	; 0x4c
   2478a:	9b18      	ldr	r3, [sp, #96]	; 0x60
   2478c:	f89d 406c 	ldrb.w	r4, [sp, #108]	; 0x6c
   24790:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
   24794:	f89d 206b 	ldrb.w	r2, [sp, #107]	; 0x6b
   24798:	f3c3 210f 	ubfx	r1, r3, #8, #16
   2479c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   2479e:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
   247a2:	f8a8 0030 	strh.w	r0, [r8, #48]	; 0x30
   247a6:	f8a8 104a 	strh.w	r1, [r8, #74]	; 0x4a
   247aa:	f8bd 105e 	ldrh.w	r1, [sp, #94]	; 0x5e
   247ae:	f3c3 230f 	ubfx	r3, r3, #8, #16
   247b2:	f8a8 2056 	strh.w	r2, [r8, #86]	; 0x56
   247b6:	f89d 2060 	ldrb.w	r2, [sp, #96]	; 0x60
   247ba:	f8a8 3062 	strh.w	r3, [r8, #98]	; 0x62
   247be:	f8dd 3063 	ldr.w	r3, [sp, #99]	; 0x63
   247c2:	f8a8 1046 	strh.w	r1, [r8, #70]	; 0x46
   247c6:	f888 2048 	strb.w	r2, [r8, #72]	; 0x48
   247ca:	f8bd 2068 	ldrh.w	r2, [sp, #104]	; 0x68
   247ce:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
   247d2:	f8c8 304c 	str.w	r3, [r8, #76]	; 0x4c
   247d6:	f89d 306a 	ldrb.w	r3, [sp, #106]	; 0x6a
   247da:	f888 1050 	strb.w	r1, [r8, #80]	; 0x50
   247de:	f8a8 2052 	strh.w	r2, [r8, #82]	; 0x52
   247e2:	f888 3054 	strb.w	r3, [r8, #84]	; 0x54
   247e6:	f8bd 3072 	ldrh.w	r3, [sp, #114]	; 0x72
   247ea:	f8dd 106d 	ldr.w	r1, [sp, #109]	; 0x6d
   247ee:	f89d 2071 	ldrb.w	r2, [sp, #113]	; 0x71
   247f2:	f8c8 1058 	str.w	r1, [r8, #88]	; 0x58
   247f6:	f888 205c 	strb.w	r2, [r8, #92]	; 0x5c
   247fa:	f89d 1074 	ldrb.w	r1, [sp, #116]	; 0x74
   247fe:	f8dd 2077 	ldr.w	r2, [sp, #119]	; 0x77
   24802:	f8a8 305e 	strh.w	r3, [r8, #94]	; 0x5e
   24806:	f89d 307b 	ldrb.w	r3, [sp, #123]	; 0x7b
   2480a:	f888 1060 	strb.w	r1, [r8, #96]	; 0x60
   2480e:	f8c8 2064 	str.w	r2, [r8, #100]	; 0x64
   24812:	f888 3068 	strb.w	r3, [r8, #104]	; 0x68
   24816:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
   2481a:	f89d 107f 	ldrb.w	r1, [sp, #127]	; 0x7f
   2481e:	9a22      	ldr	r2, [sp, #136]	; 0x88
   24820:	f89d 0094 	ldrb.w	r0, [sp, #148]	; 0x94
   24824:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
   24828:	f89d 3093 	ldrb.w	r3, [sp, #147]	; 0x93
   2482c:	f3c2 220f 	ubfx	r2, r2, #8, #16
   24830:	f8a8 106e 	strh.w	r1, [r8, #110]	; 0x6e
   24834:	f8bd 107c 	ldrh.w	r1, [sp, #124]	; 0x7c
   24838:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   2483c:	f8a8 207a 	strh.w	r2, [r8, #122]	; 0x7a
   24840:	f89d 207e 	ldrb.w	r2, [sp, #126]	; 0x7e
   24844:	f8a8 3086 	strh.w	r3, [r8, #134]	; 0x86
   24848:	f8dd 3081 	ldr.w	r3, [sp, #129]	; 0x81
   2484c:	f8a8 106a 	strh.w	r1, [r8, #106]	; 0x6a
   24850:	f888 206c 	strb.w	r2, [r8, #108]	; 0x6c
   24854:	f8bd 2086 	ldrh.w	r2, [sp, #134]	; 0x86
   24858:	f89d 1085 	ldrb.w	r1, [sp, #133]	; 0x85
   2485c:	f8c8 3070 	str.w	r3, [r8, #112]	; 0x70
   24860:	f89d 3088 	ldrb.w	r3, [sp, #136]	; 0x88
   24864:	f888 1074 	strb.w	r1, [r8, #116]	; 0x74
   24868:	f8a8 2076 	strh.w	r2, [r8, #118]	; 0x76
   2486c:	f888 3078 	strb.w	r3, [r8, #120]	; 0x78
   24870:	f8bd 3090 	ldrh.w	r3, [sp, #144]	; 0x90
   24874:	f8dd 108b 	ldr.w	r1, [sp, #139]	; 0x8b
   24878:	f89d 208f 	ldrb.w	r2, [sp, #143]	; 0x8f
   2487c:	f8c8 107c 	str.w	r1, [r8, #124]	; 0x7c
   24880:	f888 2080 	strb.w	r2, [r8, #128]	; 0x80
   24884:	f89d 1092 	ldrb.w	r1, [sp, #146]	; 0x92
   24888:	f8dd 2095 	ldr.w	r2, [sp, #149]	; 0x95
   2488c:	f8a8 3082 	strh.w	r3, [r8, #130]	; 0x82
   24890:	f89d 3099 	ldrb.w	r3, [sp, #153]	; 0x99
   24894:	f888 1084 	strb.w	r1, [r8, #132]	; 0x84
   24898:	f8c8 2088 	str.w	r2, [r8, #136]	; 0x88
   2489c:	f888 308c 	strb.w	r3, [r8, #140]	; 0x8c
   248a0:	f8bd 009a 	ldrh.w	r0, [sp, #154]	; 0x9a
   248a4:	9b27      	ldr	r3, [sp, #156]	; 0x9c
   248a6:	f89d 40a8 	ldrb.w	r4, [sp, #168]	; 0xa8
   248aa:	f89d 20a7 	ldrb.w	r2, [sp, #167]	; 0xa7
   248ae:	f3c3 210f 	ubfx	r1, r3, #8, #16
   248b2:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   248b4:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
   248b8:	f8a8 1092 	strh.w	r1, [r8, #146]	; 0x92
   248bc:	f89d 109c 	ldrb.w	r1, [sp, #156]	; 0x9c
   248c0:	f8a8 209e 	strh.w	r2, [r8, #158]	; 0x9e
   248c4:	f3c3 230f 	ubfx	r3, r3, #8, #16
   248c8:	f8dd 209f 	ldr.w	r2, [sp, #159]	; 0x9f
   248cc:	f8a8 008e 	strh.w	r0, [r8, #142]	; 0x8e
   248d0:	f8a8 30aa 	strh.w	r3, [r8, #170]	; 0xaa
   248d4:	f888 1090 	strb.w	r1, [r8, #144]	; 0x90
   248d8:	f89d 30a3 	ldrb.w	r3, [sp, #163]	; 0xa3
   248dc:	f8bd 10a4 	ldrh.w	r1, [sp, #164]	; 0xa4
   248e0:	f8c8 2094 	str.w	r2, [r8, #148]	; 0x94
   248e4:	f89d 20a6 	ldrb.w	r2, [sp, #166]	; 0xa6
   248e8:	f888 3098 	strb.w	r3, [r8, #152]	; 0x98
   248ec:	f8dd 30a9 	ldr.w	r3, [sp, #169]	; 0xa9
   248f0:	f8a8 109a 	strh.w	r1, [r8, #154]	; 0x9a
   248f4:	f888 209c 	strb.w	r2, [r8, #156]	; 0x9c
   248f8:	f8bd 20ae 	ldrh.w	r2, [sp, #174]	; 0xae
   248fc:	f89d 10ad 	ldrb.w	r1, [sp, #173]	; 0xad
   24900:	f8c8 30a0 	str.w	r3, [r8, #160]	; 0xa0
   24904:	f89d 30b0 	ldrb.w	r3, [sp, #176]	; 0xb0
   24908:	f888 10a4 	strb.w	r1, [r8, #164]	; 0xa4
   2490c:	f8a8 20a6 	strh.w	r2, [r8, #166]	; 0xa6
   24910:	f888 30a8 	strb.w	r3, [r8, #168]	; 0xa8
   24914:	f8bd 30b8 	ldrh.w	r3, [sp, #184]	; 0xb8
   24918:	f8dd 10b3 	ldr.w	r1, [sp, #179]	; 0xb3
   2491c:	f89d 20b7 	ldrb.w	r2, [sp, #183]	; 0xb7
   24920:	f8c8 10ac 	str.w	r1, [r8, #172]	; 0xac
   24924:	f888 20b0 	strb.w	r2, [r8, #176]	; 0xb0
   24928:	f8a8 30b2 	strh.w	r3, [r8, #178]	; 0xb2
   2492c:	f89d 30bc 	ldrb.w	r3, [sp, #188]	; 0xbc
   24930:	f89d 10bb 	ldrb.w	r1, [sp, #187]	; 0xbb
   24934:	f89d 00d0 	ldrb.w	r0, [sp, #208]	; 0xd0
   24938:	9a31      	ldr	r2, [sp, #196]	; 0xc4
   2493a:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
   2493e:	f89d 30cf 	ldrb.w	r3, [sp, #207]	; 0xcf
   24942:	f89d 40ba 	ldrb.w	r4, [sp, #186]	; 0xba
   24946:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   2494a:	f3c2 220f 	ubfx	r2, r2, #8, #16
   2494e:	f8a8 10b6 	strh.w	r1, [r8, #182]	; 0xb6
   24952:	f8a8 30ce 	strh.w	r3, [r8, #206]	; 0xce
   24956:	f888 40b4 	strb.w	r4, [r8, #180]	; 0xb4
   2495a:	f8a8 20c2 	strh.w	r2, [r8, #194]	; 0xc2
   2495e:	f8bd 20c2 	ldrh.w	r2, [sp, #194]	; 0xc2
   24962:	f89d 10c1 	ldrb.w	r1, [sp, #193]	; 0xc1
   24966:	f89d 30c4 	ldrb.w	r3, [sp, #196]	; 0xc4
   2496a:	f8dd 00bd 	ldr.w	r0, [sp, #189]	; 0xbd
   2496e:	f888 10bc 	strb.w	r1, [r8, #188]	; 0xbc
   24972:	f8a8 20be 	strh.w	r2, [r8, #190]	; 0xbe
   24976:	f8c8 00b8 	str.w	r0, [r8, #184]	; 0xb8
   2497a:	f888 30c0 	strb.w	r3, [r8, #192]	; 0xc0
   2497e:	f8bd 30cc 	ldrh.w	r3, [sp, #204]	; 0xcc
   24982:	f8dd 10c7 	ldr.w	r1, [sp, #199]	; 0xc7
   24986:	f89d 20cb 	ldrb.w	r2, [sp, #203]	; 0xcb
   2498a:	f8c8 10c4 	str.w	r1, [r8, #196]	; 0xc4
   2498e:	f888 20c8 	strb.w	r2, [r8, #200]	; 0xc8
   24992:	f89d 10ce 	ldrb.w	r1, [sp, #206]	; 0xce
   24996:	f8dd 20d1 	ldr.w	r2, [sp, #209]	; 0xd1
   2499a:	f8a8 30ca 	strh.w	r3, [r8, #202]	; 0xca
   2499e:	f89d 30d5 	ldrb.w	r3, [sp, #213]	; 0xd5
   249a2:	f888 10cc 	strb.w	r1, [r8, #204]	; 0xcc
   249a6:	f8c8 20d0 	str.w	r2, [r8, #208]	; 0xd0
   249aa:	f888 30d4 	strb.w	r3, [r8, #212]	; 0xd4
   249ae:	24d8      	movs	r4, #216	; 0xd8
   249b0:	e66c      	b.n	2468c <gnss_interface_read+0xcc>
   249b2:	2039      	movs	r0, #57	; 0x39
   249b4:	f7f6 feda 	bl	1b76c <bsd_os_errno_set>
   249b8:	f04f 34ff 	mov.w	r4, #4294967295
   249bc:	e671      	b.n	246a2 <gnss_interface_read+0xe2>
   249be:	2016      	movs	r0, #22
   249c0:	f7f6 fed4 	bl	1b76c <bsd_os_errno_set>
   249c4:	f04f 34ff 	mov.w	r4, #4294967295
   249c8:	e66b      	b.n	246a2 <gnss_interface_read+0xe2>
   249ca:	2009      	movs	r0, #9
   249cc:	f7f6 fece 	bl	1b76c <bsd_os_errno_set>
   249d0:	f04f 34ff 	mov.w	r4, #4294967295
   249d4:	e665      	b.n	246a2 <gnss_interface_read+0xe2>
   249d6:	bf00      	nop

000249d8 <gnss_interface_setopt>:
   249d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   249dc:	f241 1402 	movw	r4, #4354	; 0x1102
   249e0:	4222      	tst	r2, r4
   249e2:	b086      	sub	sp, #24
   249e4:	4d9c      	ldr	r5, [pc, #624]	; (24c58 <gnss_interface_setopt+0x280>)
   249e6:	d004      	beq.n	249f2 <gnss_interface_setopt+0x1a>
   249e8:	682c      	ldr	r4, [r5, #0]
   249ea:	b2a4      	uxth	r4, r4
   249ec:	2c02      	cmp	r4, #2
   249ee:	f040 8104 	bne.w	24bfa <gnss_interface_setopt+0x222>
   249f2:	682c      	ldr	r4, [r5, #0]
   249f4:	0264      	lsls	r4, r4, #9
   249f6:	f100 8128 	bmi.w	24c4a <gnss_interface_setopt+0x272>
   249fa:	f5b1 7f01 	cmp.w	r1, #516	; 0x204
   249fe:	f040 811e 	bne.w	24c3e <gnss_interface_setopt+0x266>
   24a02:	4996      	ldr	r1, [pc, #600]	; (24c5c <gnss_interface_setopt+0x284>)
   24a04:	4288      	cmp	r0, r1
   24a06:	f040 8114 	bne.w	24c32 <gnss_interface_setopt+0x25a>
   24a0a:	3a01      	subs	r2, #1
   24a0c:	2a08      	cmp	r2, #8
   24a0e:	f200 80ec 	bhi.w	24bea <gnss_interface_setopt+0x212>
   24a12:	e8df f012 	tbh	[pc, r2, lsl #1]
   24a16:	0075      	.short	0x0075
   24a18:	00c200d8 	.word	0x00c200d8
   24a1c:	008100cc 	.word	0x008100cc
   24a20:	0098008c 	.word	0x0098008c
   24a24:	000900af 	.word	0x000900af
   24a28:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   24a2a:	2a01      	cmp	r2, #1
   24a2c:	f040 80dd 	bne.w	24bea <gnss_interface_setopt+0x212>
   24a30:	f241 1603 	movw	r6, #4355	; 0x1103
   24a34:	2240      	movs	r2, #64	; 0x40
   24a36:	4637      	mov	r7, r6
   24a38:	781b      	ldrb	r3, [r3, #0]
   24a3a:	9202      	str	r2, [sp, #8]
   24a3c:	f88d 3015 	strb.w	r3, [sp, #21]
   24a40:	682b      	ldr	r3, [r5, #0]
   24a42:	2112      	movs	r1, #18
   24a44:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   24a48:	4668      	mov	r0, sp
   24a4a:	602b      	str	r3, [r5, #0]
   24a4c:	f000 fbe4 	bl	25218 <rpc_gnss_client_request_alloc>
   24a50:	4604      	mov	r4, r0
   24a52:	9800      	ldr	r0, [sp, #0]
   24a54:	2c00      	cmp	r4, #0
   24a56:	f040 80d6 	bne.w	24c06 <gnss_interface_setopt+0x22e>
   24a5a:	2800      	cmp	r0, #0
   24a5c:	f000 80da 	beq.w	24c14 <gnss_interface_setopt+0x23c>
   24a60:	2212      	movs	r2, #18
   24a62:	f04f 0876 	mov.w	r8, #118	; 0x76
   24a66:	f04f 0e49 	mov.w	lr, #73	; 0x49
   24a6a:	f04f 0a43 	mov.w	sl, #67	; 0x43
   24a6e:	f04f 0954 	mov.w	r9, #84	; 0x54
   24a72:	f8df c1f0 	ldr.w	ip, [pc, #496]	; 24c64 <gnss_interface_setopt+0x28c>
   24a76:	a906      	add	r1, sp, #24
   24a78:	f8bc 3000 	ldrh.w	r3, [ip]
   24a7c:	f880 800e 	strb.w	r8, [r0, #14]
   24a80:	3301      	adds	r3, #1
   24a82:	b29b      	uxth	r3, r3
   24a84:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
   24a88:	f841 6d14 	str.w	r6, [r1, #-20]!
   24a8c:	7144      	strb	r4, [r0, #5]
   24a8e:	7184      	strb	r4, [r0, #6]
   24a90:	71c4      	strb	r4, [r0, #7]
   24a92:	7204      	strb	r4, [r0, #8]
   24a94:	7244      	strb	r4, [r0, #9]
   24a96:	7284      	strb	r4, [r0, #10]
   24a98:	72c4      	strb	r4, [r0, #11]
   24a9a:	7102      	strb	r2, [r0, #4]
   24a9c:	f880 a00c 	strb.w	sl, [r0, #12]
   24aa0:	f880 900d 	strb.w	r9, [r0, #13]
   24aa4:	f880 e00f 	strb.w	lr, [r0, #15]
   24aa8:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 24c68 <gnss_interface_setopt+0x290>
   24aac:	6800      	ldr	r0, [r0, #0]
   24aae:	f8ac 3000 	strh.w	r3, [ip]
   24ab2:	f00a fc4f 	bl	2f354 <memcpy>
   24ab6:	4639      	mov	r1, r7
   24ab8:	9800      	ldr	r0, [sp, #0]
   24aba:	f8c8 4000 	str.w	r4, [r8]
   24abe:	f000 fbbf 	bl	25240 <rpc_gnss_client_request_send>
   24ac2:	2800      	cmp	r0, #0
   24ac4:	f040 80ab 	bne.w	24c1e <gnss_interface_setopt+0x246>
   24ac8:	4f65      	ldr	r7, [pc, #404]	; (24c60 <gnss_interface_setopt+0x288>)
   24aca:	4e64      	ldr	r6, [pc, #400]	; (24c5c <gnss_interface_setopt+0x284>)
   24acc:	4639      	mov	r1, r7
   24ace:	4630      	mov	r0, r6
   24ad0:	f7f6 fdb8 	bl	1b644 <bsd_os_timedwait>
   24ad4:	682c      	ldr	r4, [r5, #0]
   24ad6:	f414 0480 	ands.w	r4, r4, #4194304	; 0x400000
   24ada:	d1f7      	bne.n	24acc <gnss_interface_setopt+0xf4>
   24adc:	f8d8 0000 	ldr.w	r0, [r8]
   24ae0:	b118      	cbz	r0, 24aea <gnss_interface_setopt+0x112>
   24ae2:	f000 fbcb 	bl	2527c <rpc_gnss_client_data_free>
   24ae6:	f8c8 4000 	str.w	r4, [r8]
   24aea:	682b      	ldr	r3, [r5, #0]
   24aec:	021b      	lsls	r3, r3, #8
   24aee:	d576      	bpl.n	24bde <gnss_interface_setopt+0x206>
   24af0:	2000      	movs	r0, #0
   24af2:	682b      	ldr	r3, [r5, #0]
   24af4:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   24af8:	602b      	str	r3, [r5, #0]
   24afa:	b006      	add	sp, #24
   24afc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   24b00:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   24b02:	2a02      	cmp	r2, #2
   24b04:	d171      	bne.n	24bea <gnss_interface_setopt+0x212>
   24b06:	2208      	movs	r2, #8
   24b08:	f241 1603 	movw	r6, #4355	; 0x1103
   24b0c:	881b      	ldrh	r3, [r3, #0]
   24b0e:	9202      	str	r2, [sp, #8]
   24b10:	f8ad 300f 	strh.w	r3, [sp, #15]
   24b14:	4637      	mov	r7, r6
   24b16:	e793      	b.n	24a40 <gnss_interface_setopt+0x68>
   24b18:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   24b1a:	2a01      	cmp	r2, #1
   24b1c:	d165      	bne.n	24bea <gnss_interface_setopt+0x212>
   24b1e:	f241 1603 	movw	r6, #4355	; 0x1103
   24b22:	781b      	ldrb	r3, [r3, #0]
   24b24:	9202      	str	r2, [sp, #8]
   24b26:	f88d 300c 	strb.w	r3, [sp, #12]
   24b2a:	4637      	mov	r7, r6
   24b2c:	e788      	b.n	24a40 <gnss_interface_setopt+0x68>
   24b2e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   24b30:	2a01      	cmp	r2, #1
   24b32:	d15a      	bne.n	24bea <gnss_interface_setopt+0x212>
   24b34:	2202      	movs	r2, #2
   24b36:	f241 1603 	movw	r6, #4355	; 0x1103
   24b3a:	781b      	ldrb	r3, [r3, #0]
   24b3c:	9202      	str	r2, [sp, #8]
   24b3e:	f88d 300d 	strb.w	r3, [sp, #13]
   24b42:	4637      	mov	r7, r6
   24b44:	e77c      	b.n	24a40 <gnss_interface_setopt+0x68>
   24b46:	682a      	ldr	r2, [r5, #0]
   24b48:	b292      	uxth	r2, r2
   24b4a:	2a02      	cmp	r2, #2
   24b4c:	d155      	bne.n	24bfa <gnss_interface_setopt+0x222>
   24b4e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   24b50:	2a04      	cmp	r2, #4
   24b52:	d14a      	bne.n	24bea <gnss_interface_setopt+0x212>
   24b54:	2101      	movs	r1, #1
   24b56:	f241 0604 	movw	r6, #4100	; 0x1004
   24b5a:	682a      	ldr	r2, [r5, #0]
   24b5c:	6818      	ldr	r0, [r3, #0]
   24b5e:	0c13      	lsrs	r3, r2, #16
   24b60:	041b      	lsls	r3, r3, #16
   24b62:	f043 0303 	orr.w	r3, r3, #3
   24b66:	f8cd 0009 	str.w	r0, [sp, #9]
   24b6a:	602b      	str	r3, [r5, #0]
   24b6c:	f88d 1008 	strb.w	r1, [sp, #8]
   24b70:	4637      	mov	r7, r6
   24b72:	e765      	b.n	24a40 <gnss_interface_setopt+0x68>
   24b74:	682b      	ldr	r3, [r5, #0]
   24b76:	b29b      	uxth	r3, r3
   24b78:	2b04      	cmp	r3, #4
   24b7a:	d13e      	bne.n	24bfa <gnss_interface_setopt+0x222>
   24b7c:	2300      	movs	r3, #0
   24b7e:	f241 0604 	movw	r6, #4100	; 0x1004
   24b82:	f88d 3008 	strb.w	r3, [sp, #8]
   24b86:	f88d 3009 	strb.w	r3, [sp, #9]
   24b8a:	f88d 300a 	strb.w	r3, [sp, #10]
   24b8e:	f88d 300b 	strb.w	r3, [sp, #11]
   24b92:	f88d 300c 	strb.w	r3, [sp, #12]
   24b96:	4637      	mov	r7, r6
   24b98:	e752      	b.n	24a40 <gnss_interface_setopt+0x68>
   24b9a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   24b9c:	2a01      	cmp	r2, #1
   24b9e:	d124      	bne.n	24bea <gnss_interface_setopt+0x212>
   24ba0:	781b      	ldrb	r3, [r3, #0]
   24ba2:	2b01      	cmp	r3, #1
   24ba4:	d121      	bne.n	24bea <gnss_interface_setopt+0x212>
   24ba6:	f241 1603 	movw	r6, #4355	; 0x1103
   24baa:	4637      	mov	r7, r6
   24bac:	e748      	b.n	24a40 <gnss_interface_setopt+0x68>
   24bae:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   24bb0:	2a02      	cmp	r2, #2
   24bb2:	d11a      	bne.n	24bea <gnss_interface_setopt+0x212>
   24bb4:	2220      	movs	r2, #32
   24bb6:	f241 1603 	movw	r6, #4355	; 0x1103
   24bba:	881b      	ldrh	r3, [r3, #0]
   24bbc:	9202      	str	r2, [sp, #8]
   24bbe:	f8ad 3013 	strh.w	r3, [sp, #19]
   24bc2:	4637      	mov	r7, r6
   24bc4:	e73c      	b.n	24a40 <gnss_interface_setopt+0x68>
   24bc6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   24bc8:	2a02      	cmp	r2, #2
   24bca:	d10e      	bne.n	24bea <gnss_interface_setopt+0x212>
   24bcc:	2210      	movs	r2, #16
   24bce:	f241 1603 	movw	r6, #4355	; 0x1103
   24bd2:	881b      	ldrh	r3, [r3, #0]
   24bd4:	9202      	str	r2, [sp, #8]
   24bd6:	f8ad 3011 	strh.w	r3, [sp, #17]
   24bda:	4637      	mov	r7, r6
   24bdc:	e730      	b.n	24a40 <gnss_interface_setopt+0x68>
   24bde:	200e      	movs	r0, #14
   24be0:	f7f6 fdc4 	bl	1b76c <bsd_os_errno_set>
   24be4:	f04f 30ff 	mov.w	r0, #4294967295
   24be8:	e783      	b.n	24af2 <gnss_interface_setopt+0x11a>
   24bea:	2016      	movs	r0, #22
   24bec:	f7f6 fdbe 	bl	1b76c <bsd_os_errno_set>
   24bf0:	f04f 30ff 	mov.w	r0, #4294967295
   24bf4:	b006      	add	sp, #24
   24bf6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   24bfa:	200e      	movs	r0, #14
   24bfc:	f7f6 fdb6 	bl	1b76c <bsd_os_errno_set>
   24c00:	f04f 30ff 	mov.w	r0, #4294967295
   24c04:	e779      	b.n	24afa <gnss_interface_setopt+0x122>
   24c06:	b128      	cbz	r0, 24c14 <gnss_interface_setopt+0x23c>
   24c08:	6803      	ldr	r3, [r0, #0]
   24c0a:	b11b      	cbz	r3, 24c14 <gnss_interface_setopt+0x23c>
   24c0c:	4618      	mov	r0, r3
   24c0e:	f000 fb35 	bl	2527c <rpc_gnss_client_data_free>
   24c12:	9800      	ldr	r0, [sp, #0]
   24c14:	f000 fb2a 	bl	2526c <rpc_gnss_client_message_free>
   24c18:	2023      	movs	r0, #35	; 0x23
   24c1a:	f7f6 fda7 	bl	1b76c <bsd_os_errno_set>
   24c1e:	682b      	ldr	r3, [r5, #0]
   24c20:	200e      	movs	r0, #14
   24c22:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   24c26:	602b      	str	r3, [r5, #0]
   24c28:	f7f6 fda0 	bl	1b76c <bsd_os_errno_set>
   24c2c:	f04f 30ff 	mov.w	r0, #4294967295
   24c30:	e763      	b.n	24afa <gnss_interface_setopt+0x122>
   24c32:	2009      	movs	r0, #9
   24c34:	f7f6 fd9a 	bl	1b76c <bsd_os_errno_set>
   24c38:	f04f 30ff 	mov.w	r0, #4294967295
   24c3c:	e75d      	b.n	24afa <gnss_interface_setopt+0x122>
   24c3e:	202a      	movs	r0, #42	; 0x2a
   24c40:	f7f6 fd94 	bl	1b76c <bsd_os_errno_set>
   24c44:	f04f 30ff 	mov.w	r0, #4294967295
   24c48:	e757      	b.n	24afa <gnss_interface_setopt+0x122>
   24c4a:	2073      	movs	r0, #115	; 0x73
   24c4c:	f7f6 fd8e 	bl	1b76c <bsd_os_errno_set>
   24c50:	f04f 30ff 	mov.w	r0, #4294967295
   24c54:	e751      	b.n	24afa <gnss_interface_setopt+0x122>
   24c56:	bf00      	nop
   24c58:	20029090 	.word	0x20029090
   24c5c:	49765443 	.word	0x49765443
   24c60:	200383c4 	.word	0x200383c4
   24c64:	2002d490 	.word	0x2002d490
   24c68:	20029094 	.word	0x20029094

00024c6c <gnss_interface_getopt>:
   24c6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   24c70:	4c81      	ldr	r4, [pc, #516]	; (24e78 <gnss_interface_getopt+0x20c>)
   24c72:	b087      	sub	sp, #28
   24c74:	6825      	ldr	r5, [r4, #0]
   24c76:	4698      	mov	r8, r3
   24c78:	b2ad      	uxth	r5, r5
   24c7a:	2d02      	cmp	r5, #2
   24c7c:	9b10      	ldr	r3, [sp, #64]	; 0x40
   24c7e:	f040 80dd 	bne.w	24e3c <gnss_interface_getopt+0x1d0>
   24c82:	6825      	ldr	r5, [r4, #0]
   24c84:	03ee      	lsls	r6, r5, #15
   24c86:	f100 80eb 	bmi.w	24e60 <gnss_interface_getopt+0x1f4>
   24c8a:	6825      	ldr	r5, [r4, #0]
   24c8c:	01ed      	lsls	r5, r5, #7
   24c8e:	f100 80ed 	bmi.w	24e6c <gnss_interface_getopt+0x200>
   24c92:	f5b1 7f01 	cmp.w	r1, #516	; 0x204
   24c96:	f040 80d7 	bne.w	24e48 <gnss_interface_getopt+0x1dc>
   24c9a:	4978      	ldr	r1, [pc, #480]	; (24e7c <gnss_interface_getopt+0x210>)
   24c9c:	4288      	cmp	r0, r1
   24c9e:	f040 80d9 	bne.w	24e54 <gnss_interface_getopt+0x1e8>
   24ca2:	f1b8 0f00 	cmp.w	r8, #0
   24ca6:	d00b      	beq.n	24cc0 <gnss_interface_getopt+0x54>
   24ca8:	b153      	cbz	r3, 24cc0 <gnss_interface_getopt+0x54>
   24caa:	1e57      	subs	r7, r2, #1
   24cac:	2f05      	cmp	r7, #5
   24cae:	d807      	bhi.n	24cc0 <gnss_interface_getopt+0x54>
   24cb0:	e8df f007 	tbb	[pc, r7]
   24cb4:	0f030f0f 	.word	0x0f030f0f
   24cb8:	0303      	.short	0x0303
   24cba:	681b      	ldr	r3, [r3, #0]
   24cbc:	2b01      	cmp	r3, #1
   24cbe:	d00b      	beq.n	24cd8 <gnss_interface_getopt+0x6c>
   24cc0:	2016      	movs	r0, #22
   24cc2:	f7f6 fd53 	bl	1b76c <bsd_os_errno_set>
   24cc6:	f04f 35ff 	mov.w	r5, #4294967295
   24cca:	4628      	mov	r0, r5
   24ccc:	b007      	add	sp, #28
   24cce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   24cd2:	681b      	ldr	r3, [r3, #0]
   24cd4:	2b02      	cmp	r3, #2
   24cd6:	d1f3      	bne.n	24cc0 <gnss_interface_getopt+0x54>
   24cd8:	6823      	ldr	r3, [r4, #0]
   24cda:	2212      	movs	r2, #18
   24cdc:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   24ce0:	2100      	movs	r1, #0
   24ce2:	a801      	add	r0, sp, #4
   24ce4:	6023      	str	r3, [r4, #0]
   24ce6:	f00a fb55 	bl	2f394 <memset>
   24cea:	2112      	movs	r1, #18
   24cec:	4668      	mov	r0, sp
   24cee:	f000 fa93 	bl	25218 <rpc_gnss_client_request_alloc>
   24cf2:	4605      	mov	r5, r0
   24cf4:	9800      	ldr	r0, [sp, #0]
   24cf6:	2d00      	cmp	r5, #0
   24cf8:	f040 808a 	bne.w	24e10 <gnss_interface_getopt+0x1a4>
   24cfc:	2800      	cmp	r0, #0
   24cfe:	f000 808e 	beq.w	24e1e <gnss_interface_getopt+0x1b2>
   24d02:	f241 1602 	movw	r6, #4354	; 0x1102
   24d06:	f04f 0e49 	mov.w	lr, #73	; 0x49
   24d0a:	2212      	movs	r2, #18
   24d0c:	f04f 0976 	mov.w	r9, #118	; 0x76
   24d10:	f04f 0b43 	mov.w	fp, #67	; 0x43
   24d14:	f04f 0a54 	mov.w	sl, #84	; 0x54
   24d18:	f8df c168 	ldr.w	ip, [pc, #360]	; 24e84 <gnss_interface_getopt+0x218>
   24d1c:	f880 e00f 	strb.w	lr, [r0, #15]
   24d20:	f8bc 3000 	ldrh.w	r3, [ip]
   24d24:	f880 900e 	strb.w	r9, [r0, #14]
   24d28:	3301      	adds	r3, #1
   24d2a:	b29b      	uxth	r3, r3
   24d2c:	ea46 4e03 	orr.w	lr, r6, r3, lsl #16
   24d30:	f8cd e004 	str.w	lr, [sp, #4]
   24d34:	7145      	strb	r5, [r0, #5]
   24d36:	7185      	strb	r5, [r0, #6]
   24d38:	71c5      	strb	r5, [r0, #7]
   24d3a:	7205      	strb	r5, [r0, #8]
   24d3c:	7245      	strb	r5, [r0, #9]
   24d3e:	7285      	strb	r5, [r0, #10]
   24d40:	72c5      	strb	r5, [r0, #11]
   24d42:	a901      	add	r1, sp, #4
   24d44:	7102      	strb	r2, [r0, #4]
   24d46:	f880 b00c 	strb.w	fp, [r0, #12]
   24d4a:	f880 a00d 	strb.w	sl, [r0, #13]
   24d4e:	f8df 9138 	ldr.w	r9, [pc, #312]	; 24e88 <gnss_interface_getopt+0x21c>
   24d52:	6800      	ldr	r0, [r0, #0]
   24d54:	f8ac 3000 	strh.w	r3, [ip]
   24d58:	f00a fafc 	bl	2f354 <memcpy>
   24d5c:	4631      	mov	r1, r6
   24d5e:	9800      	ldr	r0, [sp, #0]
   24d60:	f8c9 5000 	str.w	r5, [r9]
   24d64:	f000 fa6c 	bl	25240 <rpc_gnss_client_request_send>
   24d68:	2800      	cmp	r0, #0
   24d6a:	d15d      	bne.n	24e28 <gnss_interface_getopt+0x1bc>
   24d6c:	4e44      	ldr	r6, [pc, #272]	; (24e80 <gnss_interface_getopt+0x214>)
   24d6e:	4d43      	ldr	r5, [pc, #268]	; (24e7c <gnss_interface_getopt+0x210>)
   24d70:	4631      	mov	r1, r6
   24d72:	4628      	mov	r0, r5
   24d74:	f7f6 fc66 	bl	1b644 <bsd_os_timedwait>
   24d78:	6823      	ldr	r3, [r4, #0]
   24d7a:	01db      	lsls	r3, r3, #7
   24d7c:	d4f8      	bmi.n	24d70 <gnss_interface_getopt+0x104>
   24d7e:	f8d9 0000 	ldr.w	r0, [r9]
   24d82:	b1d8      	cbz	r0, 24dbc <gnss_interface_getopt+0x150>
   24d84:	6825      	ldr	r5, [r4, #0]
   24d86:	f015 7500 	ands.w	r5, r5, #33554432	; 0x2000000
   24d8a:	d00f      	beq.n	24dac <gnss_interface_getopt+0x140>
   24d8c:	2f05      	cmp	r7, #5
   24d8e:	d837      	bhi.n	24e00 <gnss_interface_getopt+0x194>
   24d90:	e8df f007 	tbb	[pc, r7]
   24d94:	2b26201a 	.word	0x2b26201a
   24d98:	0331      	.short	0x0331
   24d9a:	2500      	movs	r5, #0
   24d9c:	7b43      	ldrb	r3, [r0, #13]
   24d9e:	f888 3000 	strb.w	r3, [r8]
   24da2:	f000 fa6b 	bl	2527c <rpc_gnss_client_data_free>
   24da6:	2300      	movs	r3, #0
   24da8:	f8c9 3000 	str.w	r3, [r9]
   24dac:	6823      	ldr	r3, [r4, #0]
   24dae:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
   24db2:	6023      	str	r3, [r4, #0]
   24db4:	4628      	mov	r0, r5
   24db6:	b007      	add	sp, #28
   24db8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   24dbc:	6823      	ldr	r3, [r4, #0]
   24dbe:	4605      	mov	r5, r0
   24dc0:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
   24dc4:	6023      	str	r3, [r4, #0]
   24dc6:	e7f5      	b.n	24db4 <gnss_interface_getopt+0x148>
   24dc8:	f8b0 300f 	ldrh.w	r3, [r0, #15]
   24dcc:	2500      	movs	r5, #0
   24dce:	f8a8 3000 	strh.w	r3, [r8]
   24dd2:	e7e6      	b.n	24da2 <gnss_interface_getopt+0x136>
   24dd4:	f8b0 3011 	ldrh.w	r3, [r0, #17]
   24dd8:	2500      	movs	r5, #0
   24dda:	f8a8 3000 	strh.w	r3, [r8]
   24dde:	e7e0      	b.n	24da2 <gnss_interface_getopt+0x136>
   24de0:	7b83      	ldrb	r3, [r0, #14]
   24de2:	2500      	movs	r5, #0
   24de4:	f888 3000 	strb.w	r3, [r8]
   24de8:	e7db      	b.n	24da2 <gnss_interface_getopt+0x136>
   24dea:	f8b0 3013 	ldrh.w	r3, [r0, #19]
   24dee:	2500      	movs	r5, #0
   24df0:	f8a8 3000 	strh.w	r3, [r8]
   24df4:	e7d5      	b.n	24da2 <gnss_interface_getopt+0x136>
   24df6:	7b03      	ldrb	r3, [r0, #12]
   24df8:	2500      	movs	r5, #0
   24dfa:	f888 3000 	strb.w	r3, [r8]
   24dfe:	e7d0      	b.n	24da2 <gnss_interface_getopt+0x136>
   24e00:	2016      	movs	r0, #22
   24e02:	f7f6 fcb3 	bl	1b76c <bsd_os_errno_set>
   24e06:	f04f 35ff 	mov.w	r5, #4294967295
   24e0a:	f8d9 0000 	ldr.w	r0, [r9]
   24e0e:	e7c8      	b.n	24da2 <gnss_interface_getopt+0x136>
   24e10:	b128      	cbz	r0, 24e1e <gnss_interface_getopt+0x1b2>
   24e12:	6803      	ldr	r3, [r0, #0]
   24e14:	b11b      	cbz	r3, 24e1e <gnss_interface_getopt+0x1b2>
   24e16:	4618      	mov	r0, r3
   24e18:	f000 fa30 	bl	2527c <rpc_gnss_client_data_free>
   24e1c:	9800      	ldr	r0, [sp, #0]
   24e1e:	f000 fa25 	bl	2526c <rpc_gnss_client_message_free>
   24e22:	2023      	movs	r0, #35	; 0x23
   24e24:	f7f6 fca2 	bl	1b76c <bsd_os_errno_set>
   24e28:	6823      	ldr	r3, [r4, #0]
   24e2a:	200e      	movs	r0, #14
   24e2c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   24e30:	6023      	str	r3, [r4, #0]
   24e32:	f04f 35ff 	mov.w	r5, #4294967295
   24e36:	f7f6 fc99 	bl	1b76c <bsd_os_errno_set>
   24e3a:	e746      	b.n	24cca <gnss_interface_getopt+0x5e>
   24e3c:	200e      	movs	r0, #14
   24e3e:	f7f6 fc95 	bl	1b76c <bsd_os_errno_set>
   24e42:	f04f 35ff 	mov.w	r5, #4294967295
   24e46:	e740      	b.n	24cca <gnss_interface_getopt+0x5e>
   24e48:	202a      	movs	r0, #42	; 0x2a
   24e4a:	f7f6 fc8f 	bl	1b76c <bsd_os_errno_set>
   24e4e:	f04f 35ff 	mov.w	r5, #4294967295
   24e52:	e73a      	b.n	24cca <gnss_interface_getopt+0x5e>
   24e54:	2009      	movs	r0, #9
   24e56:	f7f6 fc89 	bl	1b76c <bsd_os_errno_set>
   24e5a:	f04f 35ff 	mov.w	r5, #4294967295
   24e5e:	e734      	b.n	24cca <gnss_interface_getopt+0x5e>
   24e60:	2005      	movs	r0, #5
   24e62:	f7f6 fc83 	bl	1b76c <bsd_os_errno_set>
   24e66:	f04f 35ff 	mov.w	r5, #4294967295
   24e6a:	e72e      	b.n	24cca <gnss_interface_getopt+0x5e>
   24e6c:	2073      	movs	r0, #115	; 0x73
   24e6e:	f7f6 fc7d 	bl	1b76c <bsd_os_errno_set>
   24e72:	f04f 35ff 	mov.w	r5, #4294967295
   24e76:	e728      	b.n	24cca <gnss_interface_getopt+0x5e>
   24e78:	20029090 	.word	0x20029090
   24e7c:	49765443 	.word	0x49765443
   24e80:	200383c4 	.word	0x200383c4
   24e84:	2002d490 	.word	0x2002d490
   24e88:	20029094 	.word	0x20029094

00024e8c <gnss_interface_init>:
   24e8c:	2100      	movs	r1, #0
   24e8e:	b538      	push	{r3, r4, r5, lr}
   24e90:	4c09      	ldr	r4, [pc, #36]	; (24eb8 <gnss_interface_init+0x2c>)
   24e92:	4d0a      	ldr	r5, [pc, #40]	; (24ebc <gnss_interface_init+0x30>)
   24e94:	6822      	ldr	r2, [r4, #0]
   24e96:	480a      	ldr	r0, [pc, #40]	; (24ec0 <gnss_interface_init+0x34>)
   24e98:	4b0a      	ldr	r3, [pc, #40]	; (24ec4 <gnss_interface_init+0x38>)
   24e9a:	402a      	ands	r2, r5
   24e9c:	6022      	str	r2, [r4, #0]
   24e9e:	8001      	strh	r1, [r0, #0]
   24ea0:	6019      	str	r1, [r3, #0]
   24ea2:	f000 f9b3 	bl	2520c <rpc_gnss_client_init>
   24ea6:	b928      	cbnz	r0, 24eb4 <gnss_interface_init+0x28>
   24ea8:	6823      	ldr	r3, [r4, #0]
   24eaa:	402b      	ands	r3, r5
   24eac:	f043 0301 	orr.w	r3, r3, #1
   24eb0:	6023      	str	r3, [r4, #0]
   24eb2:	bd38      	pop	{r3, r4, r5, pc}
   24eb4:	2003      	movs	r0, #3
   24eb6:	bd38      	pop	{r3, r4, r5, pc}
   24eb8:	20029090 	.word	0x20029090
   24ebc:	ffff0000 	.word	0xffff0000
   24ec0:	2002d490 	.word	0x2002d490
   24ec4:	20029094 	.word	0x20029094

00024ec8 <gnss_interface_open>:
   24ec8:	2902      	cmp	r1, #2
   24eca:	b510      	push	{r4, lr}
   24ecc:	d121      	bne.n	24f12 <gnss_interface_open+0x4a>
   24ece:	4c14      	ldr	r4, [pc, #80]	; (24f20 <gnss_interface_open+0x58>)
   24ed0:	6823      	ldr	r3, [r4, #0]
   24ed2:	b29b      	uxth	r3, r3
   24ed4:	2b01      	cmp	r3, #1
   24ed6:	d116      	bne.n	24f06 <gnss_interface_open+0x3e>
   24ed8:	6823      	ldr	r3, [r4, #0]
   24eda:	4608      	mov	r0, r1
   24edc:	0c1b      	lsrs	r3, r3, #16
   24ede:	041b      	lsls	r3, r3, #16
   24ee0:	f043 0302 	orr.w	r3, r3, #2
   24ee4:	2200      	movs	r2, #0
   24ee6:	490f      	ldr	r1, [pc, #60]	; (24f24 <gnss_interface_open+0x5c>)
   24ee8:	6023      	str	r3, [r4, #0]
   24eea:	f000 faad 	bl	25448 <packet_handler_create>
   24eee:	4a0e      	ldr	r2, [pc, #56]	; (24f28 <gnss_interface_open+0x60>)
   24ef0:	6010      	str	r0, [r2, #0]
   24ef2:	b140      	cbz	r0, 24f06 <gnss_interface_open+0x3e>
   24ef4:	6823      	ldr	r3, [r4, #0]
   24ef6:	6802      	ldr	r2, [r0, #0]
   24ef8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   24efc:	6812      	ldr	r2, [r2, #0]
   24efe:	6023      	str	r3, [r4, #0]
   24f00:	4790      	blx	r2
   24f02:	480a      	ldr	r0, [pc, #40]	; (24f2c <gnss_interface_open+0x64>)
   24f04:	bd10      	pop	{r4, pc}
   24f06:	200e      	movs	r0, #14
   24f08:	f7f6 fc30 	bl	1b76c <bsd_os_errno_set>
   24f0c:	f04f 30ff 	mov.w	r0, #4294967295
   24f10:	bd10      	pop	{r4, pc}
   24f12:	2029      	movs	r0, #41	; 0x29
   24f14:	f7f6 fc2a 	bl	1b76c <bsd_os_errno_set>
   24f18:	f04f 30ff 	mov.w	r0, #4294967295
   24f1c:	bd10      	pop	{r4, pc}
   24f1e:	bf00      	nop
   24f20:	20029090 	.word	0x20029090
   24f24:	00024211 	.word	0x00024211
   24f28:	20029098 	.word	0x20029098
   24f2c:	49765443 	.word	0x49765443

00024f30 <gnss_interface_close>:
   24f30:	b530      	push	{r4, r5, lr}
   24f32:	4b13      	ldr	r3, [pc, #76]	; (24f80 <gnss_interface_close+0x50>)
   24f34:	b083      	sub	sp, #12
   24f36:	4298      	cmp	r0, r3
   24f38:	d11c      	bne.n	24f74 <gnss_interface_close+0x44>
   24f3a:	4c12      	ldr	r4, [pc, #72]	; (24f84 <gnss_interface_close+0x54>)
   24f3c:	6823      	ldr	r3, [r4, #0]
   24f3e:	b29b      	uxth	r3, r3
   24f40:	2b04      	cmp	r3, #4
   24f42:	d00f      	beq.n	24f64 <gnss_interface_close+0x34>
   24f44:	4d10      	ldr	r5, [pc, #64]	; (24f88 <gnss_interface_close+0x58>)
   24f46:	6828      	ldr	r0, [r5, #0]
   24f48:	b118      	cbz	r0, 24f52 <gnss_interface_close+0x22>
   24f4a:	f000 fa9d 	bl	25488 <packet_handler_delete>
   24f4e:	2300      	movs	r3, #0
   24f50:	602b      	str	r3, [r5, #0]
   24f52:	2000      	movs	r0, #0
   24f54:	6823      	ldr	r3, [r4, #0]
   24f56:	0c1b      	lsrs	r3, r3, #16
   24f58:	041b      	lsls	r3, r3, #16
   24f5a:	f043 0301 	orr.w	r3, r3, #1
   24f5e:	6023      	str	r3, [r4, #0]
   24f60:	b003      	add	sp, #12
   24f62:	bd30      	pop	{r4, r5, pc}
   24f64:	2300      	movs	r3, #0
   24f66:	2208      	movs	r2, #8
   24f68:	9300      	str	r3, [sp, #0]
   24f6a:	f44f 7101 	mov.w	r1, #516	; 0x204
   24f6e:	f7fc fe31 	bl	21bd4 <nrf_setsockopt>
   24f72:	e7e7      	b.n	24f44 <gnss_interface_close+0x14>
   24f74:	2009      	movs	r0, #9
   24f76:	f7f6 fbf9 	bl	1b76c <bsd_os_errno_set>
   24f7a:	f04f 30ff 	mov.w	r0, #4294967295
   24f7e:	e7ef      	b.n	24f60 <gnss_interface_close+0x30>
   24f80:	49765443 	.word	0x49765443
   24f84:	20029090 	.word	0x20029090
   24f88:	20029098 	.word	0x20029098

00024f8c <rpc_gnss_serialize_utc>:
   24f8c:	4603      	mov	r3, r0
   24f8e:	b1d8      	cbz	r0, 24fc8 <rpc_gnss_serialize_utc+0x3c>
   24f90:	b1d1      	cbz	r1, 24fc8 <rpc_gnss_serialize_utc+0x3c>
   24f92:	2000      	movs	r0, #0
   24f94:	2201      	movs	r2, #1
   24f96:	7048      	strb	r0, [r1, #1]
   24f98:	700a      	strb	r2, [r1, #0]
   24f9a:	685a      	ldr	r2, [r3, #4]
   24f9c:	2010      	movs	r0, #16
   24f9e:	f8c1 2006 	str.w	r2, [r1, #6]
   24fa2:	681a      	ldr	r2, [r3, #0]
   24fa4:	f8c1 2002 	str.w	r2, [r1, #2]
   24fa8:	f993 200a 	ldrsb.w	r2, [r3, #10]
   24fac:	730a      	strb	r2, [r1, #12]
   24fae:	f993 200d 	ldrsb.w	r2, [r3, #13]
   24fb2:	73ca      	strb	r2, [r1, #15]
   24fb4:	f993 200c 	ldrsb.w	r2, [r3, #12]
   24fb8:	738a      	strb	r2, [r1, #14]
   24fba:	7a1a      	ldrb	r2, [r3, #8]
   24fbc:	728a      	strb	r2, [r1, #10]
   24fbe:	7ada      	ldrb	r2, [r3, #11]
   24fc0:	734a      	strb	r2, [r1, #13]
   24fc2:	7a5b      	ldrb	r3, [r3, #9]
   24fc4:	72cb      	strb	r3, [r1, #11]
   24fc6:	4770      	bx	lr
   24fc8:	f04f 30ff 	mov.w	r0, #4294967295
   24fcc:	4770      	bx	lr
   24fce:	bf00      	nop

00024fd0 <rpc_gnss_serialize_ephe>:
   24fd0:	4603      	mov	r3, r0
   24fd2:	2800      	cmp	r0, #0
   24fd4:	d04b      	beq.n	2506e <rpc_gnss_serialize_ephe+0x9e>
   24fd6:	2900      	cmp	r1, #0
   24fd8:	d049      	beq.n	2506e <rpc_gnss_serialize_ephe+0x9e>
   24fda:	2000      	movs	r0, #0
   24fdc:	2202      	movs	r2, #2
   24fde:	7048      	strb	r0, [r1, #1]
   24fe0:	700a      	strb	r2, [r1, #0]
   24fe2:	68da      	ldr	r2, [r3, #12]
   24fe4:	2040      	movs	r0, #64	; 0x40
   24fe6:	f8c1 200b 	str.w	r2, [r1, #11]
   24fea:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   24fee:	f8a1 2009 	strh.w	r2, [r1, #9]
   24ff2:	f993 2006 	ldrsb.w	r2, [r3, #6]
   24ff6:	720a      	strb	r2, [r1, #8]
   24ff8:	f9b3 2044 	ldrsh.w	r2, [r3, #68]	; 0x44
   24ffc:	878a      	strh	r2, [r1, #60]	; 0x3c
   24ffe:	f9b3 203e 	ldrsh.w	r2, [r3, #62]	; 0x3e
   25002:	86ca      	strh	r2, [r1, #54]	; 0x36
   25004:	f9b3 2042 	ldrsh.w	r2, [r3, #66]	; 0x42
   25008:	874a      	strh	r2, [r1, #58]	; 0x3a
   2500a:	f9b3 203c 	ldrsh.w	r2, [r3, #60]	; 0x3c
   2500e:	868a      	strh	r2, [r1, #52]	; 0x34
   25010:	f9b3 2046 	ldrsh.w	r2, [r3, #70]	; 0x46
   25014:	87ca      	strh	r2, [r1, #62]	; 0x3e
   25016:	f9b3 2040 	ldrsh.w	r2, [r3, #64]	; 0x40
   2501a:	870a      	strh	r2, [r1, #56]	; 0x38
   2501c:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
   25020:	830a      	strh	r2, [r1, #24]
   25022:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   25024:	f8c1 2022 	str.w	r2, [r1, #34]	; 0x22
   25028:	7c9a      	ldrb	r2, [r3, #18]
   2502a:	744a      	strb	r2, [r1, #17]
   2502c:	785a      	ldrb	r2, [r3, #1]
   2502e:	70ca      	strb	r2, [r1, #3]
   25030:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   25032:	62ca      	str	r2, [r1, #44]	; 0x2c
   25034:	f9b3 202c 	ldrsh.w	r2, [r3, #44]	; 0x2c
   25038:	84ca      	strh	r2, [r1, #38]	; 0x26
   2503a:	885a      	ldrh	r2, [r3, #2]
   2503c:	808a      	strh	r2, [r1, #4]
   2503e:	6a1a      	ldr	r2, [r3, #32]
   25040:	f8c1 201a 	str.w	r2, [r1, #26]
   25044:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   25046:	630a      	str	r2, [r1, #48]	; 0x30
   25048:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   2504a:	f8c1 201e 	str.w	r2, [r1, #30]
   2504e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   25050:	628a      	str	r2, [r1, #40]	; 0x28
   25052:	781a      	ldrb	r2, [r3, #0]
   25054:	708a      	strb	r2, [r1, #2]
   25056:	f993 2010 	ldrsb.w	r2, [r3, #16]
   2505a:	73ca      	strb	r2, [r1, #15]
   2505c:	889a      	ldrh	r2, [r3, #4]
   2505e:	80ca      	strh	r2, [r1, #6]
   25060:	8a9a      	ldrh	r2, [r3, #20]
   25062:	824a      	strh	r2, [r1, #18]
   25064:	7c5a      	ldrb	r2, [r3, #17]
   25066:	740a      	strb	r2, [r1, #16]
   25068:	699b      	ldr	r3, [r3, #24]
   2506a:	614b      	str	r3, [r1, #20]
   2506c:	4770      	bx	lr
   2506e:	f04f 30ff 	mov.w	r0, #4294967295
   25072:	4770      	bx	lr

00025074 <rpc_gnss_serialize_alm>:
   25074:	4603      	mov	r3, r0
   25076:	b360      	cbz	r0, 250d2 <rpc_gnss_serialize_alm+0x5e>
   25078:	b359      	cbz	r1, 250d2 <rpc_gnss_serialize_alm+0x5e>
   2507a:	2000      	movs	r0, #0
   2507c:	2203      	movs	r2, #3
   2507e:	7048      	strb	r0, [r1, #1]
   25080:	700a      	strb	r2, [r1, #0]
   25082:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
   25086:	2021      	movs	r0, #33	; 0x21
   25088:	f8a1 201d 	strh.w	r2, [r1, #29]
   2508c:	f9b3 201e 	ldrsh.w	r2, [r3, #30]
   25090:	f8a1 201f 	strh.w	r2, [r1, #31]
   25094:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
   25098:	810a      	strh	r2, [r1, #8]
   2509a:	889a      	ldrh	r2, [r3, #4]
   2509c:	80ca      	strh	r2, [r1, #6]
   2509e:	78da      	ldrb	r2, [r3, #3]
   250a0:	714a      	strb	r2, [r1, #5]
   250a2:	699a      	ldr	r2, [r3, #24]
   250a4:	f8c1 2019 	str.w	r2, [r1, #25]
   250a8:	691a      	ldr	r2, [r3, #16]
   250aa:	f8c1 2011 	str.w	r2, [r1, #17]
   250ae:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   250b2:	814a      	strh	r2, [r1, #10]
   250b4:	68da      	ldr	r2, [r3, #12]
   250b6:	f8c1 200d 	str.w	r2, [r1, #13]
   250ba:	7a9a      	ldrb	r2, [r3, #10]
   250bc:	730a      	strb	r2, [r1, #12]
   250be:	781a      	ldrb	r2, [r3, #0]
   250c0:	708a      	strb	r2, [r1, #2]
   250c2:	789a      	ldrb	r2, [r3, #2]
   250c4:	710a      	strb	r2, [r1, #4]
   250c6:	695a      	ldr	r2, [r3, #20]
   250c8:	f8c1 2015 	str.w	r2, [r1, #21]
   250cc:	785b      	ldrb	r3, [r3, #1]
   250ce:	70cb      	strb	r3, [r1, #3]
   250d0:	4770      	bx	lr
   250d2:	f04f 30ff 	mov.w	r0, #4294967295
   250d6:	4770      	bx	lr

000250d8 <rpc_gnss_serialize_klob>:
   250d8:	4603      	mov	r3, r0
   250da:	b1f0      	cbz	r0, 2511a <rpc_gnss_serialize_klob+0x42>
   250dc:	b1e9      	cbz	r1, 2511a <rpc_gnss_serialize_klob+0x42>
   250de:	2000      	movs	r0, #0
   250e0:	2204      	movs	r2, #4
   250e2:	7048      	strb	r0, [r1, #1]
   250e4:	700a      	strb	r2, [r1, #0]
   250e6:	f993 2000 	ldrsb.w	r2, [r3]
   250ea:	200a      	movs	r0, #10
   250ec:	708a      	strb	r2, [r1, #2]
   250ee:	f993 2001 	ldrsb.w	r2, [r3, #1]
   250f2:	70ca      	strb	r2, [r1, #3]
   250f4:	f993 2002 	ldrsb.w	r2, [r3, #2]
   250f8:	710a      	strb	r2, [r1, #4]
   250fa:	f993 2003 	ldrsb.w	r2, [r3, #3]
   250fe:	714a      	strb	r2, [r1, #5]
   25100:	f993 2004 	ldrsb.w	r2, [r3, #4]
   25104:	718a      	strb	r2, [r1, #6]
   25106:	f993 2005 	ldrsb.w	r2, [r3, #5]
   2510a:	71ca      	strb	r2, [r1, #7]
   2510c:	f993 2006 	ldrsb.w	r2, [r3, #6]
   25110:	720a      	strb	r2, [r1, #8]
   25112:	f993 3007 	ldrsb.w	r3, [r3, #7]
   25116:	724b      	strb	r3, [r1, #9]
   25118:	4770      	bx	lr
   2511a:	f04f 30ff 	mov.w	r0, #4294967295
   2511e:	4770      	bx	lr

00025120 <rpc_gnss_serialize_nequick>:
   25120:	4603      	mov	r3, r0
   25122:	b198      	cbz	r0, 2514c <rpc_gnss_serialize_nequick+0x2c>
   25124:	b191      	cbz	r1, 2514c <rpc_gnss_serialize_nequick+0x2c>
   25126:	2000      	movs	r0, #0
   25128:	2205      	movs	r2, #5
   2512a:	7048      	strb	r0, [r1, #1]
   2512c:	700a      	strb	r2, [r1, #0]
   2512e:	f9b3 2000 	ldrsh.w	r2, [r3]
   25132:	200a      	movs	r0, #10
   25134:	804a      	strh	r2, [r1, #2]
   25136:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
   2513a:	808a      	strh	r2, [r1, #4]
   2513c:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
   25140:	80ca      	strh	r2, [r1, #6]
   25142:	799a      	ldrb	r2, [r3, #6]
   25144:	720a      	strb	r2, [r1, #8]
   25146:	79db      	ldrb	r3, [r3, #7]
   25148:	724b      	strb	r3, [r1, #9]
   2514a:	4770      	bx	lr
   2514c:	f04f 30ff 	mov.w	r0, #4294967295
   25150:	4770      	bx	lr
   25152:	bf00      	nop

00025154 <rpc_gnss_serialize_time_and_sv_tow>:
   25154:	b310      	cbz	r0, 2519c <rpc_gnss_serialize_time_and_sv_tow+0x48>
   25156:	b309      	cbz	r1, 2519c <rpc_gnss_serialize_time_and_sv_tow+0x48>
   25158:	b470      	push	{r4, r5, r6}
   2515a:	2500      	movs	r5, #0
   2515c:	2606      	movs	r6, #6
   2515e:	460c      	mov	r4, r1
   25160:	704d      	strb	r5, [r1, #1]
   25162:	700e      	strb	r6, [r1, #0]
   25164:	462b      	mov	r3, r5
   25166:	8805      	ldrh	r5, [r0, #0]
   25168:	4602      	mov	r2, r0
   2516a:	804d      	strh	r5, [r1, #2]
   2516c:	68c5      	ldr	r5, [r0, #12]
   2516e:	f8c1 500a 	str.w	r5, [r1, #10]
   25172:	8905      	ldrh	r5, [r0, #8]
   25174:	810d      	strh	r5, [r1, #8]
   25176:	6840      	ldr	r0, [r0, #4]
   25178:	6048      	str	r0, [r1, #4]
   2517a:	8a15      	ldrh	r5, [r2, #16]
   2517c:	eb03 0043 	add.w	r0, r3, r3, lsl #1
   25180:	4408      	add	r0, r1
   25182:	81c5      	strh	r5, [r0, #14]
   25184:	7c90      	ldrb	r0, [r2, #18]
   25186:	3301      	adds	r3, #1
   25188:	2b20      	cmp	r3, #32
   2518a:	7420      	strb	r0, [r4, #16]
   2518c:	f102 0204 	add.w	r2, r2, #4
   25190:	f104 0403 	add.w	r4, r4, #3
   25194:	d1f1      	bne.n	2517a <rpc_gnss_serialize_time_and_sv_tow+0x26>
   25196:	206e      	movs	r0, #110	; 0x6e
   25198:	bc70      	pop	{r4, r5, r6}
   2519a:	4770      	bx	lr
   2519c:	f04f 30ff 	mov.w	r0, #4294967295
   251a0:	4770      	bx	lr
   251a2:	bf00      	nop

000251a4 <rpc_gnss_serialize_location>:
   251a4:	4603      	mov	r3, r0
   251a6:	b1c8      	cbz	r0, 251dc <rpc_gnss_serialize_location+0x38>
   251a8:	b1c1      	cbz	r1, 251dc <rpc_gnss_serialize_location+0x38>
   251aa:	2000      	movs	r0, #0
   251ac:	2207      	movs	r2, #7
   251ae:	7048      	strb	r0, [r1, #1]
   251b0:	700a      	strb	r2, [r1, #0]
   251b2:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   251b6:	2011      	movs	r0, #17
   251b8:	814a      	strh	r2, [r1, #10]
   251ba:	7b9a      	ldrb	r2, [r3, #14]
   251bc:	740a      	strb	r2, [r1, #16]
   251be:	681a      	ldr	r2, [r3, #0]
   251c0:	f8c1 2002 	str.w	r2, [r1, #2]
   251c4:	685a      	ldr	r2, [r3, #4]
   251c6:	f8c1 2006 	str.w	r2, [r1, #6]
   251ca:	7b1a      	ldrb	r2, [r3, #12]
   251cc:	738a      	strb	r2, [r1, #14]
   251ce:	7b5a      	ldrb	r2, [r3, #13]
   251d0:	73ca      	strb	r2, [r1, #15]
   251d2:	7a9a      	ldrb	r2, [r3, #10]
   251d4:	730a      	strb	r2, [r1, #12]
   251d6:	7adb      	ldrb	r3, [r3, #11]
   251d8:	734b      	strb	r3, [r1, #13]
   251da:	4770      	bx	lr
   251dc:	f04f 30ff 	mov.w	r0, #4294967295
   251e0:	4770      	bx	lr
   251e2:	bf00      	nop

000251e4 <rpc_gnss_serialize_integrity>:
   251e4:	b148      	cbz	r0, 251fa <rpc_gnss_serialize_integrity+0x16>
   251e6:	b141      	cbz	r1, 251fa <rpc_gnss_serialize_integrity+0x16>
   251e8:	2200      	movs	r2, #0
   251ea:	2308      	movs	r3, #8
   251ec:	704a      	strb	r2, [r1, #1]
   251ee:	700b      	strb	r3, [r1, #0]
   251f0:	6803      	ldr	r3, [r0, #0]
   251f2:	2006      	movs	r0, #6
   251f4:	f8c1 3002 	str.w	r3, [r1, #2]
   251f8:	4770      	bx	lr
   251fa:	f04f 30ff 	mov.w	r0, #4294967295
   251fe:	4770      	bx	lr

00025200 <gnss_client_event_handler>:
   25200:	f850 1b08 	ldr.w	r1, [r0], #8
   25204:	0c09      	lsrs	r1, r1, #16
   25206:	f7ff b811 	b.w	2422c <rpc_gnss_event_handler>
   2520a:	bf00      	nop

0002520c <rpc_gnss_client_init>:
   2520c:	4801      	ldr	r0, [pc, #4]	; (25214 <rpc_gnss_client_init+0x8>)
   2520e:	f7fe bb73 	b.w	238f8 <rpc_client_register>
   25212:	bf00      	nop
   25214:	00030e38 	.word	0x00030e38

00025218 <rpc_gnss_client_request_alloc>:
   25218:	2300      	movs	r3, #0
   2521a:	b510      	push	{r4, lr}
   2521c:	b082      	sub	sp, #8
   2521e:	9301      	str	r3, [sp, #4]
   25220:	b158      	cbz	r0, 2523a <rpc_gnss_client_request_alloc+0x22>
   25222:	4604      	mov	r4, r0
   25224:	aa01      	add	r2, sp, #4
   25226:	2007      	movs	r0, #7
   25228:	f7fe fd9e 	bl	23d68 <rpc_message_alloc>
   2522c:	b918      	cbnz	r0, 25236 <rpc_gnss_client_request_alloc+0x1e>
   2522e:	9b01      	ldr	r3, [sp, #4]
   25230:	b10b      	cbz	r3, 25236 <rpc_gnss_client_request_alloc+0x1e>
   25232:	3308      	adds	r3, #8
   25234:	6023      	str	r3, [r4, #0]
   25236:	b002      	add	sp, #8
   25238:	bd10      	pop	{r4, pc}
   2523a:	2007      	movs	r0, #7
   2523c:	b002      	add	sp, #8
   2523e:	bd10      	pop	{r4, pc}

00025240 <rpc_gnss_client_request_send>:
   25240:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   25244:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   25248:	d10b      	bne.n	25262 <rpc_gnss_client_request_send+0x22>
   2524a:	b160      	cbz	r0, 25266 <rpc_gnss_client_request_send+0x26>
   2524c:	4603      	mov	r3, r0
   2524e:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   25252:	2007      	movs	r0, #7
   25254:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   25258:	f843 1d08 	str.w	r1, [r3, #-8]!
   2525c:	4619      	mov	r1, r3
   2525e:	f7fe bd6b 	b.w	23d38 <rpc_message_send>
   25262:	200f      	movs	r0, #15
   25264:	4770      	bx	lr
   25266:	2007      	movs	r0, #7
   25268:	4770      	bx	lr
   2526a:	bf00      	nop

0002526c <rpc_gnss_client_message_free>:
   2526c:	b120      	cbz	r0, 25278 <rpc_gnss_client_message_free+0xc>
   2526e:	f1a0 0108 	sub.w	r1, r0, #8
   25272:	2007      	movs	r0, #7
   25274:	f7fe bdaa 	b.w	23dcc <rpc_message_free>
   25278:	2007      	movs	r0, #7
   2527a:	4770      	bx	lr

0002527c <rpc_gnss_client_data_free>:
   2527c:	b118      	cbz	r0, 25286 <rpc_gnss_client_data_free+0xa>
   2527e:	4601      	mov	r1, r0
   25280:	2007      	movs	r0, #7
   25282:	f7fe beb5 	b.w	23ff0 <rpc_message_data_free>
   25286:	2007      	movs	r0, #7
   25288:	4770      	bx	lr
   2528a:	bf00      	nop

0002528c <datagram_handler_init>:
   2528c:	b510      	push	{r4, lr}
   2528e:	4604      	mov	r4, r0
   25290:	200c      	movs	r0, #12
   25292:	f7f9 f8d7 	bl	1e444 <nrf_malloc>
   25296:	60e0      	str	r0, [r4, #12]
   25298:	b118      	cbz	r0, 252a2 <datagram_handler_init+0x16>
   2529a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2529e:	f7fc bb8f 	b.w	219c0 <linked_list_init>
   252a2:	2004      	movs	r0, #4
   252a4:	bd10      	pop	{r4, pc}
   252a6:	bf00      	nop

000252a8 <datagram_handler_put>:
   252a8:	b570      	push	{r4, r5, r6, lr}
   252aa:	4606      	mov	r6, r0
   252ac:	2014      	movs	r0, #20
   252ae:	460d      	mov	r5, r1
   252b0:	f7f9 f8c8 	bl	1e444 <nrf_malloc>
   252b4:	b178      	cbz	r0, 252d6 <datagram_handler_put+0x2e>
   252b6:	682b      	ldr	r3, [r5, #0]
   252b8:	4604      	mov	r4, r0
   252ba:	6043      	str	r3, [r0, #4]
   252bc:	686b      	ldr	r3, [r5, #4]
   252be:	4601      	mov	r1, r0
   252c0:	6083      	str	r3, [r0, #8]
   252c2:	68eb      	ldr	r3, [r5, #12]
   252c4:	60c3      	str	r3, [r0, #12]
   252c6:	68ab      	ldr	r3, [r5, #8]
   252c8:	6103      	str	r3, [r0, #16]
   252ca:	68f0      	ldr	r0, [r6, #12]
   252cc:	f7fc fb82 	bl	219d4 <linked_list_push>
   252d0:	b920      	cbnz	r0, 252dc <datagram_handler_put+0x34>
   252d2:	6868      	ldr	r0, [r5, #4]
   252d4:	bd70      	pop	{r4, r5, r6, pc}
   252d6:	f04f 30ff 	mov.w	r0, #4294967295
   252da:	bd70      	pop	{r4, r5, r6, pc}
   252dc:	4620      	mov	r0, r4
   252de:	f7f9 f8bb 	bl	1e458 <nrf_free>
   252e2:	f04f 30ff 	mov.w	r0, #4294967295
   252e6:	bd70      	pop	{r4, r5, r6, pc}

000252e8 <datagram_handler_get>:
   252e8:	b5f0      	push	{r4, r5, r6, r7, lr}
   252ea:	4606      	mov	r6, r0
   252ec:	b085      	sub	sp, #20
   252ee:	68c0      	ldr	r0, [r0, #12]
   252f0:	460c      	mov	r4, r1
   252f2:	4617      	mov	r7, r2
   252f4:	f7fc fb8e 	bl	21a14 <linked_list_peek>
   252f8:	2800      	cmp	r0, #0
   252fa:	d037      	beq.n	2536c <datagram_handler_get+0x84>
   252fc:	6882      	ldr	r2, [r0, #8]
   252fe:	4605      	mov	r5, r0
   25300:	e9d4 0300 	ldrd	r0, r3, [r4]
   25304:	429a      	cmp	r2, r3
   25306:	bf28      	it	cs
   25308:	461a      	movcs	r2, r3
   2530a:	6062      	str	r2, [r4, #4]
   2530c:	b110      	cbz	r0, 25314 <datagram_handler_get+0x2c>
   2530e:	6869      	ldr	r1, [r5, #4]
   25310:	f00a f820 	bl	2f354 <memcpy>
   25314:	68a0      	ldr	r0, [r4, #8]
   25316:	b118      	cbz	r0, 25320 <datagram_handler_get+0x38>
   25318:	692b      	ldr	r3, [r5, #16]
   2531a:	b10b      	cbz	r3, 25320 <datagram_handler_get+0x38>
   2531c:	68ea      	ldr	r2, [r5, #12]
   2531e:	b9e2      	cbnz	r2, 2535a <datagram_handler_get+0x72>
   25320:	2300      	movs	r3, #0
   25322:	60e3      	str	r3, [r4, #12]
   25324:	073b      	lsls	r3, r7, #28
   25326:	d502      	bpl.n	2532e <datagram_handler_get+0x46>
   25328:	6860      	ldr	r0, [r4, #4]
   2532a:	b005      	add	sp, #20
   2532c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2532e:	68f0      	ldr	r0, [r6, #12]
   25330:	f7fc fb66 	bl	21a00 <linked_list_pop>
   25334:	4605      	mov	r5, r0
   25336:	2800      	cmp	r0, #0
   25338:	d0f6      	beq.n	25328 <datagram_handler_get+0x40>
   2533a:	e9d0 3101 	ldrd	r3, r1, [r0, #4]
   2533e:	6902      	ldr	r2, [r0, #16]
   25340:	9300      	str	r3, [sp, #0]
   25342:	68c3      	ldr	r3, [r0, #12]
   25344:	e9cd 1201 	strd	r1, r2, [sp, #4]
   25348:	9303      	str	r3, [sp, #12]
   2534a:	4668      	mov	r0, sp
   2534c:	e9d6 3101 	ldrd	r3, r1, [r6, #4]
   25350:	4798      	blx	r3
   25352:	4628      	mov	r0, r5
   25354:	f7f9 f880 	bl	1e458 <nrf_free>
   25358:	e7e6      	b.n	25328 <datagram_handler_get+0x40>
   2535a:	68e3      	ldr	r3, [r4, #12]
   2535c:	429a      	cmp	r2, r3
   2535e:	bf28      	it	cs
   25360:	461a      	movcs	r2, r3
   25362:	60e2      	str	r2, [r4, #12]
   25364:	6929      	ldr	r1, [r5, #16]
   25366:	f009 fff5 	bl	2f354 <memcpy>
   2536a:	e7db      	b.n	25324 <datagram_handler_get+0x3c>
   2536c:	f04f 30ff 	mov.w	r0, #4294967295
   25370:	e7db      	b.n	2532a <datagram_handler_get+0x42>
   25372:	bf00      	nop

00025374 <datagram_handler_available>:
   25374:	b508      	push	{r3, lr}
   25376:	68c0      	ldr	r0, [r0, #12]
   25378:	f7fc fb4c 	bl	21a14 <linked_list_peek>
   2537c:	b108      	cbz	r0, 25382 <datagram_handler_available+0xe>
   2537e:	6880      	ldr	r0, [r0, #8]
   25380:	bd08      	pop	{r3, pc}
   25382:	f04f 30ff 	mov.w	r0, #4294967295
   25386:	bd08      	pop	{r3, pc}

00025388 <datagram_handler_flush>:
   25388:	b530      	push	{r4, r5, lr}
   2538a:	4605      	mov	r5, r0
   2538c:	68c0      	ldr	r0, [r0, #12]
   2538e:	b085      	sub	sp, #20
   25390:	b9a8      	cbnz	r0, 253be <datagram_handler_flush+0x36>
   25392:	e01a      	b.n	253ca <datagram_handler_flush+0x42>
   25394:	68e8      	ldr	r0, [r5, #12]
   25396:	f7fc fb33 	bl	21a00 <linked_list_pop>
   2539a:	4604      	mov	r4, r0
   2539c:	b170      	cbz	r0, 253bc <datagram_handler_flush+0x34>
   2539e:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   253a2:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   253a6:	e9cd 0100 	strd	r0, r1, [sp]
   253aa:	e9cd 2302 	strd	r2, r3, [sp, #8]
   253ae:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   253b2:	4668      	mov	r0, sp
   253b4:	4798      	blx	r3
   253b6:	4620      	mov	r0, r4
   253b8:	f7f9 f84e 	bl	1e458 <nrf_free>
   253bc:	68e8      	ldr	r0, [r5, #12]
   253be:	f7fc fb2f 	bl	21a20 <linked_list_size_get>
   253c2:	2800      	cmp	r0, #0
   253c4:	d1e6      	bne.n	25394 <datagram_handler_flush+0xc>
   253c6:	b005      	add	sp, #20
   253c8:	bd30      	pop	{r4, r5, pc}
   253ca:	2008      	movs	r0, #8
   253cc:	b005      	add	sp, #20
   253ce:	bd30      	pop	{r4, r5, pc}

000253d0 <datagram_handler_free>:
   253d0:	b530      	push	{r4, r5, lr}
   253d2:	4605      	mov	r5, r0
   253d4:	68c0      	ldr	r0, [r0, #12]
   253d6:	b085      	sub	sp, #20
   253d8:	b9a0      	cbnz	r0, 25404 <datagram_handler_free+0x34>
   253da:	e01c      	b.n	25416 <datagram_handler_free+0x46>
   253dc:	f7fc fb10 	bl	21a00 <linked_list_pop>
   253e0:	4604      	mov	r4, r0
   253e2:	b170      	cbz	r0, 25402 <datagram_handler_free+0x32>
   253e4:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   253e8:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   253ec:	e9cd 0100 	strd	r0, r1, [sp]
   253f0:	e9cd 2302 	strd	r2, r3, [sp, #8]
   253f4:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   253f8:	4668      	mov	r0, sp
   253fa:	4798      	blx	r3
   253fc:	4620      	mov	r0, r4
   253fe:	f7f9 f82b 	bl	1e458 <nrf_free>
   25402:	68e8      	ldr	r0, [r5, #12]
   25404:	f7fc fb0c 	bl	21a20 <linked_list_size_get>
   25408:	4604      	mov	r4, r0
   2540a:	68e8      	ldr	r0, [r5, #12]
   2540c:	2c00      	cmp	r4, #0
   2540e:	d1e5      	bne.n	253dc <datagram_handler_free+0xc>
   25410:	f7f9 f822 	bl	1e458 <nrf_free>
   25414:	60ec      	str	r4, [r5, #12]
   25416:	b005      	add	sp, #20
   25418:	bd30      	pop	{r4, r5, pc}
   2541a:	bf00      	nop

0002541c <null_handler_init>:
   2541c:	2000      	movs	r0, #0
   2541e:	4770      	bx	lr

00025420 <null_handler_put>:
   25420:	b510      	push	{r4, lr}
   25422:	460c      	mov	r4, r1
   25424:	e9d0 3101 	ldrd	r3, r1, [r0, #4]
   25428:	4620      	mov	r0, r4
   2542a:	4798      	blx	r3
   2542c:	6860      	ldr	r0, [r4, #4]
   2542e:	bd10      	pop	{r4, pc}

00025430 <null_handler_get>:
   25430:	f04f 30ff 	mov.w	r0, #4294967295
   25434:	4770      	bx	lr
   25436:	bf00      	nop

00025438 <null_handler_available>:
   25438:	f04f 30ff 	mov.w	r0, #4294967295
   2543c:	4770      	bx	lr
   2543e:	bf00      	nop

00025440 <null_handler_flush>:
   25440:	2000      	movs	r0, #0
   25442:	4770      	bx	lr

00025444 <null_handler_free>:
   25444:	4770      	bx	lr
   25446:	bf00      	nop

00025448 <packet_handler_create>:
   25448:	2801      	cmp	r0, #1
   2544a:	b538      	push	{r3, r4, r5, lr}
   2544c:	460d      	mov	r5, r1
   2544e:	4614      	mov	r4, r2
   25450:	d00d      	beq.n	2546e <packet_handler_create+0x26>
   25452:	db11      	blt.n	25478 <packet_handler_create+0x30>
   25454:	2803      	cmp	r0, #3
   25456:	dc0f      	bgt.n	25478 <packet_handler_create+0x30>
   25458:	2010      	movs	r0, #16
   2545a:	f7f8 fff3 	bl	1e444 <nrf_malloc>
   2545e:	2218      	movs	r2, #24
   25460:	b120      	cbz	r0, 2546c <packet_handler_create+0x24>
   25462:	4b08      	ldr	r3, [pc, #32]	; (25484 <packet_handler_create+0x3c>)
   25464:	6045      	str	r5, [r0, #4]
   25466:	4413      	add	r3, r2
   25468:	6084      	str	r4, [r0, #8]
   2546a:	6003      	str	r3, [r0, #0]
   2546c:	bd38      	pop	{r3, r4, r5, pc}
   2546e:	2014      	movs	r0, #20
   25470:	f7f8 ffe8 	bl	1e444 <nrf_malloc>
   25474:	2230      	movs	r2, #48	; 0x30
   25476:	e7f3      	b.n	25460 <packet_handler_create+0x18>
   25478:	200c      	movs	r0, #12
   2547a:	f7f8 ffe3 	bl	1e444 <nrf_malloc>
   2547e:	2200      	movs	r2, #0
   25480:	e7ee      	b.n	25460 <packet_handler_create+0x18>
   25482:	bf00      	nop
   25484:	00030e48 	.word	0x00030e48

00025488 <packet_handler_delete>:
   25488:	b510      	push	{r4, lr}
   2548a:	4604      	mov	r4, r0
   2548c:	6803      	ldr	r3, [r0, #0]
   2548e:	691b      	ldr	r3, [r3, #16]
   25490:	4798      	blx	r3
   25492:	6823      	ldr	r3, [r4, #0]
   25494:	4620      	mov	r0, r4
   25496:	695b      	ldr	r3, [r3, #20]
   25498:	4798      	blx	r3
   2549a:	4620      	mov	r0, r4
   2549c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   254a0:	f7f8 bfda 	b.w	1e458 <nrf_free>

000254a4 <stream_handler_init>:
   254a4:	b510      	push	{r4, lr}
   254a6:	4604      	mov	r4, r0
   254a8:	200c      	movs	r0, #12
   254aa:	f7f8 ffcb 	bl	1e444 <nrf_malloc>
   254ae:	60e0      	str	r0, [r4, #12]
   254b0:	b128      	cbz	r0, 254be <stream_handler_init+0x1a>
   254b2:	2300      	movs	r3, #0
   254b4:	6123      	str	r3, [r4, #16]
   254b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   254ba:	f7fc ba81 	b.w	219c0 <linked_list_init>
   254be:	2004      	movs	r0, #4
   254c0:	bd10      	pop	{r4, pc}
   254c2:	bf00      	nop

000254c4 <stream_handler_put>:
   254c4:	b570      	push	{r4, r5, r6, lr}
   254c6:	4606      	mov	r6, r0
   254c8:	2014      	movs	r0, #20
   254ca:	460d      	mov	r5, r1
   254cc:	f7f8 ffba 	bl	1e444 <nrf_malloc>
   254d0:	b178      	cbz	r0, 254f2 <stream_handler_put+0x2e>
   254d2:	682b      	ldr	r3, [r5, #0]
   254d4:	4604      	mov	r4, r0
   254d6:	6043      	str	r3, [r0, #4]
   254d8:	686b      	ldr	r3, [r5, #4]
   254da:	4601      	mov	r1, r0
   254dc:	6083      	str	r3, [r0, #8]
   254de:	68eb      	ldr	r3, [r5, #12]
   254e0:	60c3      	str	r3, [r0, #12]
   254e2:	68ab      	ldr	r3, [r5, #8]
   254e4:	6103      	str	r3, [r0, #16]
   254e6:	68f0      	ldr	r0, [r6, #12]
   254e8:	f7fc fa74 	bl	219d4 <linked_list_push>
   254ec:	b920      	cbnz	r0, 254f8 <stream_handler_put+0x34>
   254ee:	6868      	ldr	r0, [r5, #4]
   254f0:	bd70      	pop	{r4, r5, r6, pc}
   254f2:	f04f 30ff 	mov.w	r0, #4294967295
   254f6:	bd70      	pop	{r4, r5, r6, pc}
   254f8:	4620      	mov	r0, r4
   254fa:	f7f8 ffad 	bl	1e458 <nrf_free>
   254fe:	f04f 30ff 	mov.w	r0, #4294967295
   25502:	bd70      	pop	{r4, r5, r6, pc}

00025504 <stream_handler_get>:
   25504:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   25508:	4682      	mov	sl, r0
   2550a:	b087      	sub	sp, #28
   2550c:	68c0      	ldr	r0, [r0, #12]
   2550e:	4689      	mov	r9, r1
   25510:	4693      	mov	fp, r2
   25512:	f7fc fa7f 	bl	21a14 <linked_list_peek>
   25516:	2800      	cmp	r0, #0
   25518:	d072      	beq.n	25600 <stream_handler_get+0xfc>
   2551a:	4605      	mov	r5, r0
   2551c:	f8d9 0008 	ldr.w	r0, [r9, #8]
   25520:	b120      	cbz	r0, 2552c <stream_handler_get+0x28>
   25522:	692b      	ldr	r3, [r5, #16]
   25524:	b113      	cbz	r3, 2552c <stream_handler_get+0x28>
   25526:	68ea      	ldr	r2, [r5, #12]
   25528:	2a00      	cmp	r2, #0
   2552a:	d15c      	bne.n	255e6 <stream_handler_get+0xe2>
   2552c:	2300      	movs	r3, #0
   2552e:	f8c9 300c 	str.w	r3, [r9, #12]
   25532:	f8d9 2000 	ldr.w	r2, [r9]
   25536:	f8d9 8004 	ldr.w	r8, [r9, #4]
   2553a:	f8da 1010 	ldr.w	r1, [sl, #16]
   2553e:	9201      	str	r2, [sp, #4]
   25540:	f1b8 0f00 	cmp.w	r8, #0
   25544:	d05a      	beq.n	255fc <stream_handler_get+0xf8>
   25546:	f00b 0308 	and.w	r3, fp, #8
   2554a:	2400      	movs	r4, #0
   2554c:	9300      	str	r3, [sp, #0]
   2554e:	e010      	b.n	25572 <stream_handler_get+0x6e>
   25550:	f8da 3010 	ldr.w	r3, [sl, #16]
   25554:	443b      	add	r3, r7
   25556:	f8ca 3010 	str.w	r3, [sl, #16]
   2555a:	4628      	mov	r0, r5
   2555c:	f7fc fa62 	bl	21a24 <linked_list_get_next>
   25560:	443c      	add	r4, r7
   25562:	4605      	mov	r5, r0
   25564:	2800      	cmp	r0, #0
   25566:	d038      	beq.n	255da <stream_handler_get+0xd6>
   25568:	45a0      	cmp	r8, r4
   2556a:	d936      	bls.n	255da <stream_handler_get+0xd6>
   2556c:	2100      	movs	r1, #0
   2556e:	f8d9 2000 	ldr.w	r2, [r9]
   25572:	68ae      	ldr	r6, [r5, #8]
   25574:	eba8 0b04 	sub.w	fp, r8, r4
   25578:	1a76      	subs	r6, r6, r1
   2557a:	455e      	cmp	r6, fp
   2557c:	4637      	mov	r7, r6
   2557e:	bf28      	it	cs
   25580:	465f      	movcs	r7, fp
   25582:	b132      	cbz	r2, 25592 <stream_handler_get+0x8e>
   25584:	6868      	ldr	r0, [r5, #4]
   25586:	9b01      	ldr	r3, [sp, #4]
   25588:	4401      	add	r1, r0
   2558a:	463a      	mov	r2, r7
   2558c:	1918      	adds	r0, r3, r4
   2558e:	f009 fee1 	bl	2f354 <memcpy>
   25592:	9b00      	ldr	r3, [sp, #0]
   25594:	2b00      	cmp	r3, #0
   25596:	d1e0      	bne.n	2555a <stream_handler_get+0x56>
   25598:	455e      	cmp	r6, fp
   2559a:	d8d9      	bhi.n	25550 <stream_handler_get+0x4c>
   2559c:	f8da 000c 	ldr.w	r0, [sl, #12]
   255a0:	f7fc fa2e 	bl	21a00 <linked_list_pop>
   255a4:	4606      	mov	r6, r0
   255a6:	b170      	cbz	r0, 255c6 <stream_handler_get+0xc2>
   255a8:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
   255ac:	e9d0 0103 	ldrd	r0, r1, [r0, #12]
   255b0:	e9cd 2302 	strd	r2, r3, [sp, #8]
   255b4:	e9cd 1004 	strd	r1, r0, [sp, #16]
   255b8:	e9da 3101 	ldrd	r3, r1, [sl, #4]
   255bc:	a802      	add	r0, sp, #8
   255be:	4798      	blx	r3
   255c0:	4630      	mov	r0, r6
   255c2:	f7f8 ff49 	bl	1e458 <nrf_free>
   255c6:	2300      	movs	r3, #0
   255c8:	4628      	mov	r0, r5
   255ca:	f8ca 3010 	str.w	r3, [sl, #16]
   255ce:	f7fc fa29 	bl	21a24 <linked_list_get_next>
   255d2:	443c      	add	r4, r7
   255d4:	4605      	mov	r5, r0
   255d6:	2800      	cmp	r0, #0
   255d8:	d1c6      	bne.n	25568 <stream_handler_get+0x64>
   255da:	4620      	mov	r0, r4
   255dc:	f8c9 4004 	str.w	r4, [r9, #4]
   255e0:	b007      	add	sp, #28
   255e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   255e6:	f8d9 300c 	ldr.w	r3, [r9, #12]
   255ea:	429a      	cmp	r2, r3
   255ec:	bf28      	it	cs
   255ee:	461a      	movcs	r2, r3
   255f0:	f8c9 200c 	str.w	r2, [r9, #12]
   255f4:	6929      	ldr	r1, [r5, #16]
   255f6:	f009 fead 	bl	2f354 <memcpy>
   255fa:	e79a      	b.n	25532 <stream_handler_get+0x2e>
   255fc:	4644      	mov	r4, r8
   255fe:	e7ec      	b.n	255da <stream_handler_get+0xd6>
   25600:	f04f 30ff 	mov.w	r0, #4294967295
   25604:	e7ec      	b.n	255e0 <stream_handler_get+0xdc>
   25606:	bf00      	nop

00025608 <stream_handler_available>:
   25608:	b510      	push	{r4, lr}
   2560a:	4604      	mov	r4, r0
   2560c:	68c0      	ldr	r0, [r0, #12]
   2560e:	f7fc fa01 	bl	21a14 <linked_list_peek>
   25612:	b150      	cbz	r0, 2562a <stream_handler_available+0x22>
   25614:	6924      	ldr	r4, [r4, #16]
   25616:	4264      	negs	r4, r4
   25618:	6883      	ldr	r3, [r0, #8]
   2561a:	441c      	add	r4, r3
   2561c:	f7fc fa02 	bl	21a24 <linked_list_get_next>
   25620:	2800      	cmp	r0, #0
   25622:	d1f9      	bne.n	25618 <stream_handler_available+0x10>
   25624:	ea24 70e4 	bic.w	r0, r4, r4, asr #31
   25628:	bd10      	pop	{r4, pc}
   2562a:	f04f 30ff 	mov.w	r0, #4294967295
   2562e:	bd10      	pop	{r4, pc}

00025630 <stream_handler_flush>:
   25630:	b530      	push	{r4, r5, lr}
   25632:	4605      	mov	r5, r0
   25634:	68c0      	ldr	r0, [r0, #12]
   25636:	b085      	sub	sp, #20
   25638:	b9a8      	cbnz	r0, 25666 <stream_handler_flush+0x36>
   2563a:	e01a      	b.n	25672 <stream_handler_flush+0x42>
   2563c:	68e8      	ldr	r0, [r5, #12]
   2563e:	f7fc f9df 	bl	21a00 <linked_list_pop>
   25642:	4604      	mov	r4, r0
   25644:	b170      	cbz	r0, 25664 <stream_handler_flush+0x34>
   25646:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   2564a:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   2564e:	e9cd 0100 	strd	r0, r1, [sp]
   25652:	e9cd 2302 	strd	r2, r3, [sp, #8]
   25656:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   2565a:	4668      	mov	r0, sp
   2565c:	4798      	blx	r3
   2565e:	4620      	mov	r0, r4
   25660:	f7f8 fefa 	bl	1e458 <nrf_free>
   25664:	68e8      	ldr	r0, [r5, #12]
   25666:	f7fc f9db 	bl	21a20 <linked_list_size_get>
   2566a:	2800      	cmp	r0, #0
   2566c:	d1e6      	bne.n	2563c <stream_handler_flush+0xc>
   2566e:	b005      	add	sp, #20
   25670:	bd30      	pop	{r4, r5, pc}
   25672:	2008      	movs	r0, #8
   25674:	b005      	add	sp, #20
   25676:	bd30      	pop	{r4, r5, pc}

00025678 <stream_handler_free>:
   25678:	b530      	push	{r4, r5, lr}
   2567a:	4605      	mov	r5, r0
   2567c:	68c0      	ldr	r0, [r0, #12]
   2567e:	b085      	sub	sp, #20
   25680:	b9a0      	cbnz	r0, 256ac <stream_handler_free+0x34>
   25682:	e01c      	b.n	256be <stream_handler_free+0x46>
   25684:	f7fc f9bc 	bl	21a00 <linked_list_pop>
   25688:	4604      	mov	r4, r0
   2568a:	b170      	cbz	r0, 256aa <stream_handler_free+0x32>
   2568c:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   25690:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   25694:	e9cd 0100 	strd	r0, r1, [sp]
   25698:	e9cd 2302 	strd	r2, r3, [sp, #8]
   2569c:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   256a0:	4668      	mov	r0, sp
   256a2:	4798      	blx	r3
   256a4:	4620      	mov	r0, r4
   256a6:	f7f8 fed7 	bl	1e458 <nrf_free>
   256aa:	68e8      	ldr	r0, [r5, #12]
   256ac:	f7fc f9b8 	bl	21a20 <linked_list_size_get>
   256b0:	4604      	mov	r4, r0
   256b2:	68e8      	ldr	r0, [r5, #12]
   256b4:	2c00      	cmp	r4, #0
   256b6:	d1e5      	bne.n	25684 <stream_handler_free+0xc>
   256b8:	f7f8 fece 	bl	1e458 <nrf_free>
   256bc:	60ec      	str	r4, [r5, #12]
   256be:	b005      	add	sp, #20
   256c0:	bd30      	pop	{r4, r5, pc}
   256c2:	bf00      	nop

000256c4 <SystemInit>:
    
    /* Enable the FPU if the compiler used floating point unit instructions. __FPU_USED is a MACRO defined by the
    * compiler. Since the FPU consumes energy, remember to disable FPU use in the compiler if floating point unit
    * operations are not used in your code. */
    #if (__FPU_USED == 1)
      SCB->CPACR |= (3UL << 20) | (3UL << 22);
   256c4:	4a07      	ldr	r2, [pc, #28]	; (256e4 <SystemInit+0x20>)
   256c6:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
   256ca:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
   256ce:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
   256d2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   256d6:	f3bf 8f6f 	isb	sy
    SystemCoreClock = __SYSTEM_CLOCK;
   256da:	4b03      	ldr	r3, [pc, #12]	; (256e8 <SystemInit+0x24>)
   256dc:	4a03      	ldr	r2, [pc, #12]	; (256ec <SystemInit+0x28>)
   256de:	601a      	str	r2, [r3, #0]
      __DSB();
      __ISB();
    #endif
    
    SystemCoreClockUpdate();
}
   256e0:	4770      	bx	lr
   256e2:	bf00      	nop
   256e4:	e000ed00 	.word	0xe000ed00
   256e8:	200383c8 	.word	0x200383c8
   256ec:	03d09000 	.word	0x03d09000

000256f0 <nvmc_word_write>:
}

#if defined(NVMC_READYNEXT_READYNEXT_Msk)
NRF_STATIC_INLINE bool nrf_nvmc_write_ready_check(NRF_NVMC_Type const * p_reg)
{
    return (bool)(p_reg->READYNEXT & NVMC_READYNEXT_READYNEXT_Msk);
   256f0:	4a04      	ldr	r2, [pc, #16]	; (25704 <nvmc_word_write+0x14>)
   256f2:	f8d2 3408 	ldr.w	r3, [r2, #1032]	; 0x408
}

static void nvmc_word_write(uint32_t addr, uint32_t value)
{
#if defined(NRF9160_XXAA)
    while (!nrf_nvmc_write_ready_check(NRF_NVMC))
   256f6:	07db      	lsls	r3, r3, #31
   256f8:	d5fb      	bpl.n	256f2 <nvmc_word_write+0x2>
#else
    while (!nrf_nvmc_ready_check(NRF_NVMC))
    {}
#endif

    *(volatile uint32_t *)addr = value;
   256fa:	6001      	str	r1, [r0, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   256fc:	f3bf 8f5f 	dmb	sy
    __DMB();
}
   25700:	4770      	bx	lr
   25702:	bf00      	nop
   25704:	40039000 	.word	0x40039000

00025708 <nrfx_nvmc_page_erase>:
    }
}

nrfx_err_t nrfx_nvmc_page_erase(uint32_t addr)
{
    NRFX_ASSERT((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get());
   25708:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
{
   2570c:	b508      	push	{r3, lr}
    NRFX_ASSERT((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get());
   2570e:	d305      	bcc.n	2571c <nrfx_nvmc_page_erase+0x14>
   25710:	4b0d      	ldr	r3, [pc, #52]	; (25748 <nrfx_nvmc_page_erase+0x40>)
   25712:	4a0e      	ldr	r2, [pc, #56]	; (2574c <nrfx_nvmc_page_erase+0x44>)
   25714:	21dd      	movs	r1, #221	; 0xdd
   25716:	480e      	ldr	r0, [pc, #56]	; (25750 <nrfx_nvmc_page_erase+0x48>)
   25718:	f004 fb0e 	bl	29d38 <__assert_func>
    return !(addr % flash_page_size_get());
   2571c:	f3c0 030b 	ubfx	r3, r0, #0, #12

    if (!is_page_aligned_check(addr))
   25720:	b97b      	cbnz	r3, 25742 <nrfx_nvmc_page_erase+0x3a>

#if defined(NVMC_CONFIGNS_WEN_Msk)
NRF_STATIC_INLINE void nrf_nvmc_nonsecure_mode_set(NRF_NVMC_Type *    p_reg,
                                                   nrf_nvmc_ns_mode_t mode)
{
    p_reg->CONFIGNS = (uint32_t)mode;
   25722:	2202      	movs	r2, #2
   25724:	4b0b      	ldr	r3, [pc, #44]	; (25754 <nrfx_nvmc_page_erase+0x4c>)
   25726:	f8c3 2584 	str.w	r2, [r3, #1412]	; 0x584
        p_reg->ERASEPCR1 = page_addr;
    }
#elif defined(NRF52_SERIES)
    p_reg->ERASEPAGE = page_addr;
#elif defined(NRF9160_XXAA) || defined(NRF5340_XXAA_APPLICATION) || defined(NRF5340_XXAA_NETWORK)
    *(volatile uint32_t *)page_addr = 0xFFFFFFFF;
   2572a:	f04f 32ff 	mov.w	r2, #4294967295
   2572e:	6002      	str	r2, [r0, #0]
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   25730:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
        return NRFX_ERROR_INVALID_ADDR;
    }

    nvmc_erase_mode_set();
    nrf_nvmc_page_erase_start(NRF_NVMC, addr);
    while (!nrf_nvmc_ready_check(NRF_NVMC))
   25734:	07d2      	lsls	r2, r2, #31
   25736:	d5fb      	bpl.n	25730 <nrfx_nvmc_page_erase+0x28>
    p_reg->CONFIGNS = (uint32_t)mode;
   25738:	2200      	movs	r2, #0
    {}
    nvmc_readonly_mode_set();

    return NRFX_SUCCESS;
   2573a:	4807      	ldr	r0, [pc, #28]	; (25758 <nrfx_nvmc_page_erase+0x50>)
   2573c:	f8c3 2584 	str.w	r2, [r3, #1412]	; 0x584
}
   25740:	bd08      	pop	{r3, pc}
        return NRFX_ERROR_INVALID_ADDR;
   25742:	4806      	ldr	r0, [pc, #24]	; (2575c <nrfx_nvmc_page_erase+0x54>)
   25744:	e7fc      	b.n	25740 <nrfx_nvmc_page_erase+0x38>
   25746:	bf00      	nop
   25748:	000340a0 	.word	0x000340a0
   2574c:	00034076 	.word	0x00034076
   25750:	0003410d 	.word	0x0003410d
   25754:	40039000 	.word	0x40039000
   25758:	0bad0000 	.word	0x0bad0000
   2575c:	0bad000a 	.word	0x0bad000a

00025760 <nrfx_nvmc_word_write>:
    nrfx_nvmc_word_write(aligned_addr, partial_word_create(addr, &value, 1));
}

void nrfx_nvmc_word_write(uint32_t addr, uint32_t value)
{
    NRFX_ASSERT((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get());
   25760:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
{
   25764:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT((addr - NVMC_FLASH_BASE_ADDRESS) < flash_total_size_get());
   25766:	d306      	bcc.n	25776 <nrfx_nvmc_word_write+0x16>
   25768:	f240 114d 	movw	r1, #333	; 0x14d
   2576c:	4b0a      	ldr	r3, [pc, #40]	; (25798 <nrfx_nvmc_word_write+0x38>)
   2576e:	4a0b      	ldr	r2, [pc, #44]	; (2579c <nrfx_nvmc_word_write+0x3c>)
    NRFX_ASSERT(nrfx_is_word_aligned((void const *)addr));
   25770:	480b      	ldr	r0, [pc, #44]	; (257a0 <nrfx_nvmc_word_write+0x40>)
   25772:	f004 fae1 	bl	29d38 <__assert_func>
   25776:	f010 0403 	ands.w	r4, r0, #3
   2577a:	d004      	beq.n	25786 <nrfx_nvmc_word_write+0x26>
   2577c:	4b09      	ldr	r3, [pc, #36]	; (257a4 <nrfx_nvmc_word_write+0x44>)
   2577e:	4a07      	ldr	r2, [pc, #28]	; (2579c <nrfx_nvmc_word_write+0x3c>)
   25780:	f44f 71a7 	mov.w	r1, #334	; 0x14e
   25784:	e7f4      	b.n	25770 <nrfx_nvmc_word_write+0x10>
   25786:	2301      	movs	r3, #1
   25788:	4d07      	ldr	r5, [pc, #28]	; (257a8 <nrfx_nvmc_word_write+0x48>)
   2578a:	f8c5 3584 	str.w	r3, [r5, #1412]	; 0x584

    nvmc_write_mode_set();

    nvmc_word_write(addr, value);
   2578e:	f7ff ffaf 	bl	256f0 <nvmc_word_write>
   25792:	f8c5 4584 	str.w	r4, [r5, #1412]	; 0x584

    nvmc_readonly_mode_set();
}
   25796:	bd38      	pop	{r3, r4, r5, pc}
   25798:	000340a0 	.word	0x000340a0
   2579c:	0003408b 	.word	0x0003408b
   257a0:	0003410d 	.word	0x0003410d
   257a4:	000340c4 	.word	0x000340c4
   257a8:	40039000 	.word	0x40039000

000257ac <nrf_gpio_pin_port_decode.isra.0.part.1>:
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   257ac:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   257ae:	4a03      	ldr	r2, [pc, #12]	; (257bc <nrf_gpio_pin_port_decode.isra.0.part.1+0x10>)
   257b0:	4b03      	ldr	r3, [pc, #12]	; (257c0 <nrf_gpio_pin_port_decode.isra.0.part.1+0x14>)
   257b2:	f240 11ff 	movw	r1, #511	; 0x1ff
   257b6:	4803      	ldr	r0, [pc, #12]	; (257c4 <nrf_gpio_pin_port_decode.isra.0.part.1+0x18>)
   257b8:	f004 fabe 	bl	29d38 <__assert_func>
   257bc:	00034149 	.word	0x00034149
   257c0:	00033552 	.word	0x00033552
   257c4:	00033560 	.word	0x00033560

000257c8 <nrf_gpio_pin_clear>:
   257c8:	281f      	cmp	r0, #31
{
   257ca:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   257cc:	d901      	bls.n	257d2 <nrf_gpio_pin_clear+0xa>
   257ce:	f7ff ffed 	bl	257ac <nrf_gpio_pin_port_decode.isra.0.part.1>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   257d2:	2301      	movs	r3, #1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
   257d4:	4a01      	ldr	r2, [pc, #4]	; (257dc <nrf_gpio_pin_clear+0x14>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   257d6:	4083      	lsls	r3, r0
    p_reg->OUTCLR = clr_mask;
   257d8:	60d3      	str	r3, [r2, #12]
}
   257da:	bd08      	pop	{r3, pc}
   257dc:	40842500 	.word	0x40842500

000257e0 <nrf_gpio_pin_set>:
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   257e0:	281f      	cmp	r0, #31
{
   257e2:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   257e4:	d901      	bls.n	257ea <nrf_gpio_pin_set+0xa>
   257e6:	f7ff ffe1 	bl	257ac <nrf_gpio_pin_port_decode.isra.0.part.1>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   257ea:	2301      	movs	r3, #1
    p_reg->OUTSET = set_mask;
   257ec:	4a01      	ldr	r2, [pc, #4]	; (257f4 <nrf_gpio_pin_set+0x14>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   257ee:	4083      	lsls	r3, r0
    p_reg->OUTSET = set_mask;
   257f0:	6093      	str	r3, [r2, #8]
}
   257f2:	bd08      	pop	{r3, pc}
   257f4:	40842500 	.word	0x40842500

000257f8 <irq_handler.part.2>:
{
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
    return nrf_spim_event_address_get(p_spim, NRF_SPIM_EVENT_END);
}

static void irq_handler(NRF_SPIM_Type * p_spim, spim_control_block_t * p_cb)
   257f8:	b508      	push	{r3, lr}
        {
            anomaly_198_disable();
        }
#endif
        nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_END);
        NRFX_ASSERT(p_cb->handler);
   257fa:	4a03      	ldr	r2, [pc, #12]	; (25808 <irq_handler.part.2+0x10>)
   257fc:	4b03      	ldr	r3, [pc, #12]	; (2580c <irq_handler.part.2+0x14>)
   257fe:	f240 21e7 	movw	r1, #743	; 0x2e7
   25802:	4803      	ldr	r0, [pc, #12]	; (25810 <irq_handler.part.2+0x18>)
   25804:	f004 fa98 	bl	29d38 <__assert_func>
   25808:	00034180 	.word	0x00034180
   2580c:	0003418c 	.word	0x0003418c
   25810:	0003419a 	.word	0x0003419a

00025814 <nrfx_spim_init>:
{
   25814:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   25818:	4681      	mov	r9, r0
    NRFX_ASSERT(p_config);
   2581a:	460c      	mov	r4, r1
   2581c:	b929      	cbnz	r1, 2582a <nrfx_spim_init+0x16>
   2581e:	4b52      	ldr	r3, [pc, #328]	; (25968 <nrfx_spim_init+0x154>)
   25820:	4a52      	ldr	r2, [pc, #328]	; (2596c <nrfx_spim_init+0x158>)
   25822:	21f4      	movs	r1, #244	; 0xf4
   25824:	4852      	ldr	r0, [pc, #328]	; (25970 <nrfx_spim_init+0x15c>)
   25826:	f004 fa87 	bl	29d38 <__assert_func>
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   2582a:	2124      	movs	r1, #36	; 0x24
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   2582c:	7905      	ldrb	r5, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   2582e:	4e51      	ldr	r6, [pc, #324]	; (25974 <nrfx_spim_init+0x160>)
   25830:	4369      	muls	r1, r5
   25832:	1870      	adds	r0, r6, r1
   25834:	7f07      	ldrb	r7, [r0, #28]
   25836:	2f00      	cmp	r7, #0
   25838:	f040 8094 	bne.w	25964 <nrfx_spim_init+0x150>
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
   2583c:	f8d9 7000 	ldr.w	r7, [r9]
    p_cb->p_context = p_context;
   25840:	6043      	str	r3, [r0, #4]
    if (p_config->mode <= NRF_SPIM_MODE_1)
   25842:	7b23      	ldrb	r3, [r4, #12]
    p_cb->handler = handler;
   25844:	5072      	str	r2, [r6, r1]
    if (p_config->mode <= NRF_SPIM_MODE_1)
   25846:	2b01      	cmp	r3, #1
   25848:	7820      	ldrb	r0, [r4, #0]
   2584a:	d806      	bhi.n	2585a <nrfx_spim_init+0x46>
        nrf_gpio_pin_clear(p_config->sck_pin);
   2584c:	f7ff ffbc 	bl	257c8 <nrf_gpio_pin_clear>
    nrf_gpio_cfg(p_config->sck_pin,
   25850:	7823      	ldrb	r3, [r4, #0]
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   25852:	2b1f      	cmp	r3, #31
   25854:	d904      	bls.n	25860 <nrfx_spim_init+0x4c>
   25856:	f7ff ffa9 	bl	257ac <nrf_gpio_pin_port_decode.isra.0.part.1>
        nrf_gpio_pin_set(p_config->sck_pin);
   2585a:	f7ff ffc1 	bl	257e0 <nrf_gpio_pin_set>
   2585e:	e7f7      	b.n	25850 <nrfx_spim_init+0x3c>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   25860:	2101      	movs	r1, #1
   25862:	4a45      	ldr	r2, [pc, #276]	; (25978 <nrfx_spim_init+0x164>)
   25864:	3380      	adds	r3, #128	; 0x80
   25866:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    if (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
   2586a:	f894 8001 	ldrb.w	r8, [r4, #1]
   2586e:	4692      	mov	sl, r2
   25870:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
   25874:	d067      	beq.n	25946 <nrfx_spim_init+0x132>
        nrf_gpio_pin_clear(mosi_pin);
   25876:	4640      	mov	r0, r8
   25878:	f7ff ffa6 	bl	257c8 <nrf_gpio_pin_clear>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   2587c:	f1b8 0f1f 	cmp.w	r8, #31
   25880:	d8e9      	bhi.n	25856 <nrfx_spim_init+0x42>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   25882:	2203      	movs	r2, #3
   25884:	f108 0380 	add.w	r3, r8, #128	; 0x80
   25888:	f84a 2023 	str.w	r2, [sl, r3, lsl #2]
    if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
   2588c:	78a3      	ldrb	r3, [r4, #2]
   2588e:	2bff      	cmp	r3, #255	; 0xff
   25890:	d05c      	beq.n	2594c <nrfx_spim_init+0x138>
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   25892:	2b1f      	cmp	r3, #31
        miso_pin = p_config->miso_pin;
   25894:	469b      	mov	fp, r3
        nrf_gpio_cfg_input(miso_pin, p_config->miso_pull);
   25896:	7ba2      	ldrb	r2, [r4, #14]
   25898:	d8dd      	bhi.n	25856 <nrfx_spim_init+0x42>
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
   2589a:	0092      	lsls	r2, r2, #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   2589c:	f103 0180 	add.w	r1, r3, #128	; 0x80
   258a0:	f84a 2021 	str.w	r2, [sl, r1, lsl #2]
    p_cb->miso_pin = p_config->miso_pin;
   258a4:	2224      	movs	r2, #36	; 0x24
   258a6:	fb02 6205 	mla	r2, r2, r5, r6
   258aa:	f882 3020 	strb.w	r3, [r2, #32]
    p_cb->ss_pin = p_config->ss_pin;
   258ae:	78e0      	ldrb	r0, [r4, #3]
    if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   258b0:	28ff      	cmp	r0, #255	; 0xff
    p_cb->ss_pin = p_config->ss_pin;
   258b2:	77d0      	strb	r0, [r2, #31]
    if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   258b4:	d010      	beq.n	258d8 <nrfx_spim_init+0xc4>
        if (p_config->ss_active_high)
   258b6:	7923      	ldrb	r3, [r4, #4]
   258b8:	2b00      	cmp	r3, #0
   258ba:	d04a      	beq.n	25952 <nrfx_spim_init+0x13e>
            nrf_gpio_pin_clear(p_config->ss_pin);
   258bc:	f7ff ff84 	bl	257c8 <nrf_gpio_pin_clear>
        nrf_gpio_cfg_output(p_config->ss_pin);
   258c0:	78e3      	ldrb	r3, [r4, #3]
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   258c2:	2b1f      	cmp	r3, #31
   258c4:	d8c7      	bhi.n	25856 <nrfx_spim_init+0x42>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   258c6:	2203      	movs	r2, #3
   258c8:	3380      	adds	r3, #128	; 0x80
   258ca:	f84a 2023 	str.w	r2, [sl, r3, lsl #2]
        p_cb->ss_active_high = p_config->ss_active_high;
   258ce:	2324      	movs	r3, #36	; 0x24
   258d0:	fb03 6305 	mla	r3, r3, r5, r6
   258d4:	7922      	ldrb	r2, [r4, #4]
   258d6:	779a      	strb	r2, [r3, #30]
    nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
   258d8:	7823      	ldrb	r3, [r4, #0]
    nrf_spim_configure(p_spim, p_config->mode, p_config->bit_order);
   258da:	7b22      	ldrb	r2, [r4, #12]
    p_reg->PSEL.SCK  = sck_pin;
   258dc:	f8c7 3508 	str.w	r3, [r7, #1288]	; 0x508
    p_reg->FREQUENCY = (uint32_t)frequency;
   258e0:	68a3      	ldr	r3, [r4, #8]
    p_reg->PSEL.MOSI = mosi_pin;
   258e2:	f8c7 850c 	str.w	r8, [r7, #1292]	; 0x50c
    p_reg->PSEL.MISO = miso_pin;
   258e6:	f8c7 b510 	str.w	fp, [r7, #1296]	; 0x510
    p_reg->FREQUENCY = (uint32_t)frequency;
   258ea:	f8c7 3524 	str.w	r3, [r7, #1316]	; 0x524
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
   258ee:	7b63      	ldrb	r3, [r4, #13]
   258f0:	3300      	adds	r3, #0
   258f2:	bf18      	it	ne
   258f4:	2301      	movne	r3, #1
    switch (spi_mode)
   258f6:	2a02      	cmp	r2, #2
   258f8:	d02e      	beq.n	25958 <nrfx_spim_init+0x144>
   258fa:	2a03      	cmp	r2, #3
   258fc:	d02f      	beq.n	2595e <nrfx_spim_init+0x14a>
   258fe:	2a01      	cmp	r2, #1
   25900:	d101      	bne.n	25906 <nrfx_spim_init+0xf2>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
   25902:	f043 0302 	orr.w	r3, r3, #2
    p_reg->CONFIG = config;
   25906:	f8c7 3554 	str.w	r3, [r7, #1364]	; 0x554
}

NRF_STATIC_INLINE void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
                                        uint8_t         orc)
{
    p_reg->ORC = orc;
   2590a:	79a3      	ldrb	r3, [r4, #6]
   2590c:	f8c7 35c0 	str.w	r3, [r7, #1472]	; 0x5c0
    if (p_cb->handler)
   25910:	2324      	movs	r3, #36	; 0x24
   25912:	436b      	muls	r3, r5
   25914:	58f3      	ldr	r3, [r6, r3]
   25916:	b113      	cbz	r3, 2591e <nrfx_spim_init+0x10a>
    p_reg->INTENSET = mask;
   25918:	2240      	movs	r2, #64	; 0x40
   2591a:	f8c7 2304 	str.w	r2, [r7, #772]	; 0x304
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Enabled << SPIM_ENABLE_ENABLE_Pos);
   2591e:	2207      	movs	r2, #7
   25920:	f8c7 2500 	str.w	r2, [r7, #1280]	; 0x500
    if (p_cb->handler)
   25924:	b12b      	cbz	r3, 25932 <nrfx_spim_init+0x11e>
    return ((((uint32_t)p_object) & 0x3u) == 0u);
}

NRF_STATIC_INLINE IRQn_Type nrfx_get_irq_number(void const * p_reg)
{
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
   25926:	f8d9 0000 	ldr.w	r0, [r9]
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
   2592a:	f340 3007 	sbfx	r0, r0, #12, #8
   2592e:	f7f3 fb6d 	bl	1900c <arch_irq_enable>
    p_cb->transfer_in_progress = false;
   25932:	2324      	movs	r3, #36	; 0x24
   25934:	fb03 6505 	mla	r5, r3, r5, r6
   25938:	2300      	movs	r3, #0
   2593a:	776b      	strb	r3, [r5, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   2593c:	2301      	movs	r3, #1
    return err_code;
   2593e:	480f      	ldr	r0, [pc, #60]	; (2597c <nrfx_spim_init+0x168>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   25940:	772b      	strb	r3, [r5, #28]
}
   25942:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        mosi_pin = NRF_SPIM_PIN_NOT_CONNECTED;
   25946:	f04f 38ff 	mov.w	r8, #4294967295
   2594a:	e79f      	b.n	2588c <nrfx_spim_init+0x78>
        miso_pin = NRF_SPIM_PIN_NOT_CONNECTED;
   2594c:	f04f 3bff 	mov.w	fp, #4294967295
   25950:	e7a8      	b.n	258a4 <nrfx_spim_init+0x90>
            nrf_gpio_pin_set(p_config->ss_pin);
   25952:	f7ff ff45 	bl	257e0 <nrf_gpio_pin_set>
   25956:	e7b3      	b.n	258c0 <nrfx_spim_init+0xac>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   25958:	f043 0304 	orr.w	r3, r3, #4
        break;
   2595c:	e7d3      	b.n	25906 <nrfx_spim_init+0xf2>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   2595e:	f043 0306 	orr.w	r3, r3, #6
        break;
   25962:	e7d0      	b.n	25906 <nrfx_spim_init+0xf2>
        return err_code;
   25964:	4806      	ldr	r0, [pc, #24]	; (25980 <nrfx_spim_init+0x16c>)
   25966:	e7ec      	b.n	25942 <nrfx_spim_init+0x12e>
   25968:	000341d6 	.word	0x000341d6
   2596c:	00034162 	.word	0x00034162
   25970:	0003419a 	.word	0x0003419a
   25974:	2002909c 	.word	0x2002909c
   25978:	40842500 	.word	0x40842500
   2597c:	0bad0000 	.word	0x0bad0000
   25980:	0bad0005 	.word	0x0bad0005

00025984 <nrfx_spim_xfer>:
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   25984:	2324      	movs	r3, #36	; 0x24
{
   25986:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   2598a:	4d58      	ldr	r5, [pc, #352]	; (25aec <nrfx_spim_xfer+0x168>)
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   2598c:	7906      	ldrb	r6, [r0, #4]
{
   2598e:	4680      	mov	r8, r0
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   25990:	fb03 5306 	mla	r3, r3, r6, r5
   25994:	7f1b      	ldrb	r3, [r3, #28]
{
   25996:	460c      	mov	r4, r1
   25998:	4617      	mov	r7, r2
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   2599a:	b933      	cbnz	r3, 259aa <nrfx_spim_xfer+0x26>
   2599c:	f240 217d 	movw	r1, #637	; 0x27d
   259a0:	4b53      	ldr	r3, [pc, #332]	; (25af0 <nrfx_spim_xfer+0x16c>)
   259a2:	4a54      	ldr	r2, [pc, #336]	; (25af4 <nrfx_spim_xfer+0x170>)
    NRFX_ASSERT(p_xfer_desc->p_tx_buffer != NULL || p_xfer_desc->tx_length == 0);
   259a4:	4854      	ldr	r0, [pc, #336]	; (25af8 <nrfx_spim_xfer+0x174>)
   259a6:	f004 f9c7 	bl	29d38 <__assert_func>
   259aa:	680b      	ldr	r3, [r1, #0]
   259ac:	b933      	cbnz	r3, 259bc <nrfx_spim_xfer+0x38>
   259ae:	684b      	ldr	r3, [r1, #4]
   259b0:	b123      	cbz	r3, 259bc <nrfx_spim_xfer+0x38>
   259b2:	4b52      	ldr	r3, [pc, #328]	; (25afc <nrfx_spim_xfer+0x178>)
   259b4:	4a4f      	ldr	r2, [pc, #316]	; (25af4 <nrfx_spim_xfer+0x170>)
   259b6:	f240 217e 	movw	r1, #638	; 0x27e
   259ba:	e7f3      	b.n	259a4 <nrfx_spim_xfer+0x20>
    NRFX_ASSERT(p_xfer_desc->p_rx_buffer != NULL || p_xfer_desc->rx_length == 0);
   259bc:	68a3      	ldr	r3, [r4, #8]
   259be:	b943      	cbnz	r3, 259d2 <nrfx_spim_xfer+0x4e>
   259c0:	68e3      	ldr	r3, [r4, #12]
   259c2:	2b00      	cmp	r3, #0
   259c4:	f000 808e 	beq.w	25ae4 <nrfx_spim_xfer+0x160>
   259c8:	4b4d      	ldr	r3, [pc, #308]	; (25b00 <nrfx_spim_xfer+0x17c>)
   259ca:	4a4a      	ldr	r2, [pc, #296]	; (25af4 <nrfx_spim_xfer+0x170>)
   259cc:	f240 217f 	movw	r1, #639	; 0x27f
   259d0:	e7e8      	b.n	259a4 <nrfx_spim_xfer+0x20>
    NRFX_ASSERT(SPIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   259d2:	2e01      	cmp	r6, #1
   259d4:	d807      	bhi.n	259e6 <nrfx_spim_xfer+0x62>
   259d6:	68e3      	ldr	r3, [r4, #12]
   259d8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   259dc:	d203      	bcs.n	259e6 <nrfx_spim_xfer+0x62>
   259de:	6863      	ldr	r3, [r4, #4]
   259e0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   259e4:	d304      	bcc.n	259f0 <nrfx_spim_xfer+0x6c>
   259e6:	4b47      	ldr	r3, [pc, #284]	; (25b04 <nrfx_spim_xfer+0x180>)
   259e8:	4a42      	ldr	r2, [pc, #264]	; (25af4 <nrfx_spim_xfer+0x170>)
   259ea:	f240 2182 	movw	r1, #642	; 0x282
   259ee:	e7d9      	b.n	259a4 <nrfx_spim_xfer+0x20>
    if (p_cb->transfer_in_progress)
   259f0:	2324      	movs	r3, #36	; 0x24
   259f2:	4373      	muls	r3, r6
   259f4:	18ea      	adds	r2, r5, r3
   259f6:	7f51      	ldrb	r1, [r2, #29]
   259f8:	2900      	cmp	r1, #0
   259fa:	d171      	bne.n	25ae0 <nrfx_spim_xfer+0x15c>
        if (p_cb->handler && !(flags & (NRFX_SPIM_FLAG_REPEATED_XFER |
   259fc:	58eb      	ldr	r3, [r5, r3]
   259fe:	b123      	cbz	r3, 25a0a <nrfx_spim_xfer+0x86>
   25a00:	f017 0f14 	tst.w	r7, #20
            p_cb->transfer_in_progress = true;
   25a04:	bf04      	itt	eq
   25a06:	2301      	moveq	r3, #1
   25a08:	7753      	strbeq	r3, [r2, #29]
    p_cb->evt.xfer_desc = *p_xfer_desc;
   25a0a:	f04f 0c24 	mov.w	ip, #36	; 0x24
   25a0e:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   25a12:	fb0c 5c06 	mla	ip, ip, r6, r5
   25a16:	f10c 0e0c 	add.w	lr, ip, #12
   25a1a:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   25a1e:	f89c 001f 	ldrb.w	r0, [ip, #31]
   25a22:	28ff      	cmp	r0, #255	; 0xff
   25a24:	d004      	beq.n	25a30 <nrfx_spim_xfer+0xac>
            if (p_cb->ss_active_high)
   25a26:	f89c 301e 	ldrb.w	r3, [ip, #30]
   25a2a:	b1bb      	cbz	r3, 25a5c <nrfx_spim_xfer+0xd8>
                nrf_gpio_pin_set(p_cb->ss_pin);
   25a2c:	f7ff fed8 	bl	257e0 <nrf_gpio_pin_set>
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   25a30:	6821      	ldr	r1, [r4, #0]
   25a32:	b121      	cbz	r1, 25a3e <nrfx_spim_xfer+0xba>
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   25a34:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
   25a38:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   25a3c:	d106      	bne.n	25a4c <nrfx_spim_xfer+0xc8>
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   25a3e:	68a2      	ldr	r2, [r4, #8]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   25a40:	b17a      	cbz	r2, 25a62 <nrfx_spim_xfer+0xde>
   25a42:	f002 4360 	and.w	r3, r2, #3758096384	; 0xe0000000
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   25a46:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   25a4a:	d00a      	beq.n	25a62 <nrfx_spim_xfer+0xde>
        p_cb->transfer_in_progress = false;
   25a4c:	2324      	movs	r3, #36	; 0x24
   25a4e:	fb03 5506 	mla	r5, r3, r6, r5
   25a52:	2300      	movs	r3, #0
        return err_code;
   25a54:	482c      	ldr	r0, [pc, #176]	; (25b08 <nrfx_spim_xfer+0x184>)
        p_cb->transfer_in_progress = false;
   25a56:	776b      	strb	r3, [r5, #29]
}
   25a58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                nrf_gpio_pin_clear(p_cb->ss_pin);
   25a5c:	f7ff feb4 	bl	257c8 <nrf_gpio_pin_clear>
   25a60:	e7e6      	b.n	25a30 <nrfx_spim_xfer+0xac>
    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
   25a62:	f8d8 3000 	ldr.w	r3, [r8]
    nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
   25a66:	6860      	ldr	r0, [r4, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   25a68:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   25a6c:	f8c3 0548 	str.w	r0, [r3, #1352]	; 0x548
    nrf_spim_rx_buffer_set(p_spim, p_xfer_desc->p_rx_buffer, p_xfer_desc->rx_length);
   25a70:	68e1      	ldr	r1, [r4, #12]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   25a72:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25a76:	2200      	movs	r2, #0
    p_reg->RXD.MAXCNT = length;
   25a78:	f8c3 1538 	str.w	r1, [r3, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25a7c:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    if (NRFX_SPIM_FLAG_TX_POSTINC & flags)
   25a80:	f017 0201 	ands.w	r2, r7, #1
}


NRF_STATIC_INLINE void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_ArrayList << SPIM_TXD_LIST_LIST_Pos;
   25a84:	bf18      	it	ne
   25a86:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_tx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_Disabled << SPIM_TXD_LIST_LIST_Pos;
   25a88:	f8c3 2550 	str.w	r2, [r3, #1360]	; 0x550
    if (NRFX_SPIM_FLAG_RX_POSTINC & flags)
   25a8c:	f017 0202 	ands.w	r2, r7, #2
}

NRF_STATIC_INLINE void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_ArrayList << SPIM_RXD_LIST_LIST_Pos;
   25a90:	bf18      	it	ne
   25a92:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_Disabled << SPIM_RXD_LIST_LIST_Pos;
   25a94:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
   25a98:	073a      	lsls	r2, r7, #28
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   25a9a:	bf5c      	itt	pl
   25a9c:	2201      	movpl	r2, #1
   25a9e:	611a      	strpl	r2, [r3, #16]
    if (!p_cb->handler)
   25aa0:	2224      	movs	r2, #36	; 0x24
   25aa2:	4372      	muls	r2, r6
   25aa4:	58aa      	ldr	r2, [r5, r2]
   25aa6:	b992      	cbnz	r2, 25ace <nrfx_spim_xfer+0x14a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25aa8:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
        while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END)){}
   25aac:	2a00      	cmp	r2, #0
   25aae:	d0fb      	beq.n	25aa8 <nrfx_spim_xfer+0x124>
        if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   25ab0:	2324      	movs	r3, #36	; 0x24
   25ab2:	fb03 5506 	mla	r5, r3, r6, r5
   25ab6:	7fe8      	ldrb	r0, [r5, #31]
   25ab8:	28ff      	cmp	r0, #255	; 0xff
   25aba:	d003      	beq.n	25ac4 <nrfx_spim_xfer+0x140>
                if (p_cb->ss_active_high)
   25abc:	7fab      	ldrb	r3, [r5, #30]
   25abe:	b11b      	cbz	r3, 25ac8 <nrfx_spim_xfer+0x144>
                    nrf_gpio_pin_clear(p_cb->ss_pin);
   25ac0:	f7ff fe82 	bl	257c8 <nrf_gpio_pin_clear>
    return err_code;
   25ac4:	4811      	ldr	r0, [pc, #68]	; (25b0c <nrfx_spim_xfer+0x188>)
   25ac6:	e7c7      	b.n	25a58 <nrfx_spim_xfer+0xd4>
                    nrf_gpio_pin_set(p_cb->ss_pin);
   25ac8:	f7ff fe8a 	bl	257e0 <nrf_gpio_pin_set>
   25acc:	e7fa      	b.n	25ac4 <nrfx_spim_xfer+0x140>
    if (!enable)
   25ace:	2240      	movs	r2, #64	; 0x40
   25ad0:	f017 0f04 	tst.w	r7, #4
    p_reg->INTENCLR = mask;
   25ad4:	bf14      	ite	ne
   25ad6:	f8c3 2308 	strne.w	r2, [r3, #776]	; 0x308
    p_reg->INTENSET = mask;
   25ada:	f8c3 2304 	streq.w	r2, [r3, #772]	; 0x304
   25ade:	e7f1      	b.n	25ac4 <nrfx_spim_xfer+0x140>
        return err_code;
   25ae0:	480b      	ldr	r0, [pc, #44]	; (25b10 <nrfx_spim_xfer+0x18c>)
   25ae2:	e7b9      	b.n	25a58 <nrfx_spim_xfer+0xd4>
    NRFX_ASSERT(SPIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   25ae4:	2e01      	cmp	r6, #1
   25ae6:	f67f af7a 	bls.w	259de <nrfx_spim_xfer+0x5a>
   25aea:	e77c      	b.n	259e6 <nrfx_spim_xfer+0x62>
   25aec:	2002909c 	.word	0x2002909c
   25af0:	000341df 	.word	0x000341df
   25af4:	00034171 	.word	0x00034171
   25af8:	0003419a 	.word	0x0003419a
   25afc:	0003420b 	.word	0x0003420b
   25b00:	00034252 	.word	0x00034252
   25b04:	00034299 	.word	0x00034299
   25b08:	0bad000a 	.word	0x0bad000a
   25b0c:	0bad0000 	.word	0x0bad0000
   25b10:	0bad000b 	.word	0x0bad000b

00025b14 <nrfx_spim_2_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_SPIM2_ENABLED)
void nrfx_spim_2_irq_handler(void)
{
   25b14:	b508      	push	{r3, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25b16:	4b08      	ldr	r3, [pc, #32]	; (25b38 <nrfx_spim_2_irq_handler+0x24>)
   25b18:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   25b1c:	b15a      	cbz	r2, 25b36 <nrfx_spim_2_irq_handler+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25b1e:	2200      	movs	r2, #0
        NRFX_ASSERT(p_cb->handler);
   25b20:	4806      	ldr	r0, [pc, #24]	; (25b3c <nrfx_spim_2_irq_handler+0x28>)
   25b22:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   25b26:	6803      	ldr	r3, [r0, #0]
   25b28:	b90b      	cbnz	r3, 25b2e <nrfx_spim_2_irq_handler+0x1a>
   25b2a:	f7ff fe65 	bl	257f8 <irq_handler.part.2>
    irq_handler(NRF_SPIM2, &m_cb[NRFX_SPIM2_INST_IDX]);
}
   25b2e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        finish_transfer(p_cb);
   25b32:	f009 b9e5 	b.w	2ef00 <finish_transfer>
}
   25b36:	bd08      	pop	{r3, pc}
   25b38:	4000a000 	.word	0x4000a000
   25b3c:	2002909c 	.word	0x2002909c

00025b40 <nrfx_spim_3_irq_handler>:
#endif

#if NRFX_CHECK(NRFX_SPIM3_ENABLED)
void nrfx_spim_3_irq_handler(void)
{
   25b40:	b508      	push	{r3, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25b42:	4b09      	ldr	r3, [pc, #36]	; (25b68 <nrfx_spim_3_irq_handler+0x28>)
   25b44:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   25b48:	b162      	cbz	r2, 25b64 <nrfx_spim_3_irq_handler+0x24>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25b4a:	2200      	movs	r2, #0
        NRFX_ASSERT(p_cb->handler);
   25b4c:	4807      	ldr	r0, [pc, #28]	; (25b6c <nrfx_spim_3_irq_handler+0x2c>)
   25b4e:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   25b52:	6a43      	ldr	r3, [r0, #36]	; 0x24
   25b54:	b90b      	cbnz	r3, 25b5a <nrfx_spim_3_irq_handler+0x1a>
   25b56:	f7ff fe4f 	bl	257f8 <irq_handler.part.2>
        finish_transfer(p_cb);
   25b5a:	3024      	adds	r0, #36	; 0x24
    irq_handler(NRF_SPIM3, &m_cb[NRFX_SPIM3_INST_IDX]);
}
   25b5c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        finish_transfer(p_cb);
   25b60:	f009 b9ce 	b.w	2ef00 <finish_transfer>
}
   25b64:	bd08      	pop	{r3, pc}
   25b66:	bf00      	nop
   25b68:	4000b000 	.word	0x4000b000
   25b6c:	2002909c 	.word	0x2002909c

00025b70 <nrf_gpio_pin_port_decode.isra.1>:
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   25b70:	281f      	cmp	r0, #31
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   25b72:	b508      	push	{r3, lr}
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
   25b74:	d906      	bls.n	25b84 <nrf_gpio_pin_port_decode.isra.1+0x14>
   25b76:	4b04      	ldr	r3, [pc, #16]	; (25b88 <nrf_gpio_pin_port_decode.isra.1+0x18>)
   25b78:	4a04      	ldr	r2, [pc, #16]	; (25b8c <nrf_gpio_pin_port_decode.isra.1+0x1c>)
   25b7a:	f240 11ff 	movw	r1, #511	; 0x1ff
   25b7e:	4804      	ldr	r0, [pc, #16]	; (25b90 <nrf_gpio_pin_port_decode.isra.1+0x20>)
   25b80:	f004 f8da 	bl	29d38 <__assert_func>
}
   25b84:	4803      	ldr	r0, [pc, #12]	; (25b94 <nrf_gpio_pin_port_decode.isra.1+0x24>)
   25b86:	bd08      	pop	{r3, pc}
   25b88:	00033552 	.word	0x00033552
   25b8c:	000343c9 	.word	0x000343c9
   25b90:	00033560 	.word	0x00033560
   25b94:	40842500 	.word	0x40842500

00025b98 <nrfx_twim_init>:

nrfx_err_t nrfx_twim_init(nrfx_twim_t const *        p_instance,
                          nrfx_twim_config_t const * p_config,
                          nrfx_twim_evt_handler_t    event_handler,
                          void *                     p_context)
{
   25b98:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   25b9c:	4682      	mov	sl, r0
   25b9e:	4691      	mov	r9, r2
    NRFX_ASSERT(p_config);
   25ba0:	460d      	mov	r5, r1
   25ba2:	b929      	cbnz	r1, 25bb0 <nrfx_twim_init+0x18>
   25ba4:	21de      	movs	r1, #222	; 0xde
   25ba6:	4b25      	ldr	r3, [pc, #148]	; (25c3c <nrfx_twim_init+0xa4>)
   25ba8:	4a25      	ldr	r2, [pc, #148]	; (25c40 <nrfx_twim_init+0xa8>)
    NRFX_ASSERT(p_config->scl != p_config->sda);
   25baa:	4826      	ldr	r0, [pc, #152]	; (25c44 <nrfx_twim_init+0xac>)
   25bac:	f004 f8c4 	bl	29d38 <__assert_func>
   25bb0:	e9d1 8700 	ldrd	r8, r7, [r1]
   25bb4:	45b8      	cmp	r8, r7
   25bb6:	d103      	bne.n	25bc0 <nrfx_twim_init+0x28>
   25bb8:	4b23      	ldr	r3, [pc, #140]	; (25c48 <nrfx_twim_init+0xb0>)
   25bba:	4a21      	ldr	r2, [pc, #132]	; (25c40 <nrfx_twim_init+0xa8>)
   25bbc:	21df      	movs	r1, #223	; 0xdf
   25bbe:	e7f4      	b.n	25baa <nrfx_twim_init+0x12>
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   25bc0:	2134      	movs	r1, #52	; 0x34
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   25bc2:	7906      	ldrb	r6, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   25bc4:	4c21      	ldr	r4, [pc, #132]	; (25c4c <nrfx_twim_init+0xb4>)
   25bc6:	4371      	muls	r1, r6
   25bc8:	1860      	adds	r0, r4, r1
   25bca:	f890 202d 	ldrb.w	r2, [r0, #45]	; 0x2d
   25bce:	bb9a      	cbnz	r2, 25c38 <nrfx_twim_init+0xa0>
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler         = event_handler;
    p_cb->p_context       = p_context;
   25bd0:	6043      	str	r3, [r0, #4]
    p_cb->int_mask        = 0;
    p_cb->repeated        = false;
    p_cb->busy            = false;
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   25bd2:	7b6b      	ldrb	r3, [r5, #13]
    p_cb->int_mask        = 0;
   25bd4:	6082      	str	r2, [r0, #8]
    p_cb->repeated        = false;
   25bd6:	f880 2030 	strb.w	r2, [r0, #48]	; 0x30
    p_cb->busy            = false;
   25bda:	f880 202f 	strb.w	r2, [r0, #47]	; 0x2f
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   25bde:	f880 3032 	strb.w	r3, [r0, #50]	; 0x32
    p_cb->handler         = event_handler;
   25be2:	f844 9001 	str.w	r9, [r4, r1]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   25be6:	4640      	mov	r0, r8
   25be8:	f7ff ffc2 	bl	25b70 <nrf_gpio_pin_port_decode.isra.1>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   25bec:	f240 6b0c 	movw	fp, #1548	; 0x60c
   25bf0:	f108 0380 	add.w	r3, r8, #128	; 0x80
   25bf4:	f840 b023 	str.w	fp, [r0, r3, lsl #2]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   25bf8:	4638      	mov	r0, r7
   25bfa:	f7ff ffb9 	bl	25b70 <nrf_gpio_pin_port_decode.isra.1>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   25bfe:	f107 0380 	add.w	r3, r7, #128	; 0x80
   25c02:	f840 b023 	str.w	fp, [r0, r3, lsl #2]
       disabled, these pins must be configured in the GPIO peripheral.
    */
    TWIM_PIN_INIT(p_config->scl);
    TWIM_PIN_INIT(p_config->sda);

    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   25c06:	f8da 0000 	ldr.w	r0, [sl]
    nrf_twim_pins_set(p_twim, p_config->scl, p_config->sda);
    nrf_twim_frequency_set(p_twim,
        (nrf_twim_frequency_t)p_config->frequency);
   25c0a:	68ab      	ldr	r3, [r5, #8]
    p_reg->PSEL.SCL = scl_pin;
   25c0c:	f8c0 8508 	str.w	r8, [r0, #1288]	; 0x508
    p_reg->PSEL.SDA = sda_pin;
   25c10:	f8c0 750c 	str.w	r7, [r0, #1292]	; 0x50c
    p_reg->FREQUENCY = frequency;
   25c14:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524

    if (p_cb->handler)
   25c18:	f1b9 0f00 	cmp.w	r9, #0
   25c1c:	d003      	beq.n	25c26 <nrfx_twim_init+0x8e>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_twim),
            p_config->interrupt_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twim));
   25c1e:	f340 3007 	sbfx	r0, r0, #12, #8
   25c22:	f7f3 f9f3 	bl	1900c <arch_irq_enable>
    }

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   25c26:	2334      	movs	r3, #52	; 0x34
   25c28:	fb03 4406 	mla	r4, r3, r6, r4
   25c2c:	2301      	movs	r3, #1

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   25c2e:	4808      	ldr	r0, [pc, #32]	; (25c50 <nrfx_twim_init+0xb8>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   25c30:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
   25c34:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return err_code;
   25c38:	4806      	ldr	r0, [pc, #24]	; (25c54 <nrfx_twim_init+0xbc>)
   25c3a:	e7fb      	b.n	25c34 <nrfx_twim_init+0x9c>
   25c3c:	000341d6 	.word	0x000341d6
   25c40:	000343e2 	.word	0x000343e2
   25c44:	00034468 	.word	0x00034468
   25c48:	000344a4 	.word	0x000344a4
   25c4c:	200290e4 	.word	0x200290e4
   25c50:	0bad0000 	.word	0x0bad0000
   25c54:	0bad0005 	.word	0x0bad0005

00025c58 <nrfx_twim_enable>:
}

void nrfx_twim_enable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   25c58:	2134      	movs	r1, #52	; 0x34
{
   25c5a:	b508      	push	{r3, lr}
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   25c5c:	4a0b      	ldr	r2, [pc, #44]	; (25c8c <nrfx_twim_enable+0x34>)
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   25c5e:	7903      	ldrb	r3, [r0, #4]
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   25c60:	fb01 2303 	mla	r3, r1, r3, r2
   25c64:	f893 202d 	ldrb.w	r2, [r3, #45]	; 0x2d
   25c68:	2a01      	cmp	r2, #1
   25c6a:	d006      	beq.n	25c7a <nrfx_twim_enable+0x22>
   25c6c:	4b08      	ldr	r3, [pc, #32]	; (25c90 <nrfx_twim_enable+0x38>)
   25c6e:	4a09      	ldr	r2, [pc, #36]	; (25c94 <nrfx_twim_enable+0x3c>)
   25c70:	f44f 71a3 	mov.w	r1, #326	; 0x146
   25c74:	4808      	ldr	r0, [pc, #32]	; (25c98 <nrfx_twim_enable+0x40>)
   25c76:	f004 f85f 	bl	29d38 <__assert_func>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   25c7a:	2106      	movs	r1, #6

    nrf_twim_enable(p_instance->p_twim);
   25c7c:	6802      	ldr	r2, [r0, #0]
   25c7e:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500

    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
   25c82:	2202      	movs	r2, #2
   25c84:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance enabled: %d.", p_instance->drv_inst_idx);
}
   25c88:	bd08      	pop	{r3, pc}
   25c8a:	bf00      	nop
   25c8c:	200290e4 	.word	0x200290e4
   25c90:	0003443e 	.word	0x0003443e
   25c94:	000343f1 	.word	0x000343f1
   25c98:	00034468 	.word	0x00034468

00025c9c <nrfx_twim_disable>:

void nrfx_twim_disable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   25c9c:	2134      	movs	r1, #52	; 0x34
{
   25c9e:	b508      	push	{r3, lr}
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   25ca0:	4a0f      	ldr	r2, [pc, #60]	; (25ce0 <nrfx_twim_disable+0x44>)
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   25ca2:	7903      	ldrb	r3, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   25ca4:	fb01 2303 	mla	r3, r1, r3, r2
   25ca8:	f893 202d 	ldrb.w	r2, [r3, #45]	; 0x2d
   25cac:	b932      	cbnz	r2, 25cbc <nrfx_twim_disable+0x20>
   25cae:	4b0d      	ldr	r3, [pc, #52]	; (25ce4 <nrfx_twim_disable+0x48>)
   25cb0:	4a0d      	ldr	r2, [pc, #52]	; (25ce8 <nrfx_twim_disable+0x4c>)
   25cb2:	f240 1151 	movw	r1, #337	; 0x151
   25cb6:	480d      	ldr	r0, [pc, #52]	; (25cec <nrfx_twim_disable+0x50>)
   25cb8:	f004 f83e 	bl	29d38 <__assert_func>

    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   25cbc:	6802      	ldr	r2, [r0, #0]
    p_cb->int_mask = 0;
   25cbe:	2000      	movs	r0, #0
    p_reg->INTENCLR = mask;
   25cc0:	490b      	ldr	r1, [pc, #44]	; (25cf0 <nrfx_twim_disable+0x54>)
   25cc2:	6098      	str	r0, [r3, #8]
   25cc4:	f8c2 1308 	str.w	r1, [r2, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
   25cc8:	f8d2 1200 	ldr.w	r1, [r2, #512]	; 0x200
   25ccc:	f421 51bc 	bic.w	r1, r1, #6016	; 0x1780
   25cd0:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   25cd4:	f8c2 0500 	str.w	r0, [r2, #1280]	; 0x500
    nrf_twim_int_disable(p_twim, NRF_TWIM_ALL_INTS_MASK);
    nrf_twim_shorts_disable(p_twim, NRF_TWIM_ALL_SHORTS_MASK);
    nrf_twim_disable(p_twim);

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   25cd8:	2201      	movs	r2, #1
   25cda:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance disabled: %d.", p_instance->drv_inst_idx);
}
   25cde:	bd08      	pop	{r3, pc}
   25ce0:	200290e4 	.word	0x200290e4
   25ce4:	000341df 	.word	0x000341df
   25ce8:	00034402 	.word	0x00034402
   25cec:	00034468 	.word	0x00034468
   25cf0:	019c0202 	.word	0x019c0202

00025cf4 <nrfx_twim_xfer>:


nrfx_err_t nrfx_twim_xfer(nrfx_twim_t           const * p_instance,
                          nrfx_twim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
   25cf4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    NRFX_ASSERT(TWIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   25cf8:	f890 8004 	ldrb.w	r8, [r0, #4]
{
   25cfc:	460e      	mov	r6, r1
   25cfe:	4617      	mov	r7, r2
    NRFX_ASSERT(TWIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   25d00:	f1b8 0f00 	cmp.w	r8, #0
   25d04:	d107      	bne.n	25d16 <nrfx_twim_xfer+0x22>
   25d06:	684b      	ldr	r3, [r1, #4]
   25d08:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   25d0c:	d203      	bcs.n	25d16 <nrfx_twim_xfer+0x22>
   25d0e:	688b      	ldr	r3, [r1, #8]
   25d10:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   25d14:	d306      	bcc.n	25d24 <nrfx_twim_xfer+0x30>
   25d16:	f240 2163 	movw	r1, #611	; 0x263
   25d1a:	4ba9      	ldr	r3, [pc, #676]	; (25fc0 <nrfx_twim_xfer+0x2cc>)
   25d1c:	4aa9      	ldr	r2, [pc, #676]	; (25fc4 <nrfx_twim_xfer+0x2d0>)

    nrfx_err_t err_code = NRFX_SUCCESS;
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];

    // TXRX and TXTX transfers are supported only in non-blocking mode.
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWIM_XFER_TXRX)));
   25d1e:	48aa      	ldr	r0, [pc, #680]	; (25fc8 <nrfx_twim_xfer+0x2d4>)
   25d20:	f004 f80a 	bl	29d38 <__assert_func>
   25d24:	4da9      	ldr	r5, [pc, #676]	; (25fcc <nrfx_twim_xfer+0x2d8>)
   25d26:	682b      	ldr	r3, [r5, #0]
   25d28:	b973      	cbnz	r3, 25d48 <nrfx_twim_xfer+0x54>
   25d2a:	780b      	ldrb	r3, [r1, #0]
   25d2c:	2b02      	cmp	r3, #2
   25d2e:	d104      	bne.n	25d3a <nrfx_twim_xfer+0x46>
   25d30:	4ba7      	ldr	r3, [pc, #668]	; (25fd0 <nrfx_twim_xfer+0x2dc>)
   25d32:	4aa4      	ldr	r2, [pc, #656]	; (25fc4 <nrfx_twim_xfer+0x2d0>)
   25d34:	f240 2169 	movw	r1, #617	; 0x269
   25d38:	e7f1      	b.n	25d1e <nrfx_twim_xfer+0x2a>
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWIM_XFER_TXTX)));
   25d3a:	2b03      	cmp	r3, #3
   25d3c:	d104      	bne.n	25d48 <nrfx_twim_xfer+0x54>
   25d3e:	4ba5      	ldr	r3, [pc, #660]	; (25fd4 <nrfx_twim_xfer+0x2e0>)
   25d40:	4aa0      	ldr	r2, [pc, #640]	; (25fc4 <nrfx_twim_xfer+0x2d0>)
   25d42:	f240 216a 	movw	r1, #618	; 0x26a
   25d46:	e7ea      	b.n	25d1e <nrfx_twim_xfer+0x2a>
    p_cb->error = false;
   25d48:	2300      	movs	r3, #0
                           p_xfer_desc->primary_length * sizeof(p_xfer_desc->p_primary_buf[0]));
    NRFX_LOG_DEBUG("Secondary buffer data:");
    NRFX_LOG_HEXDUMP_DEBUG(p_xfer_desc->p_secondary_buf,
                           p_xfer_desc->secondary_length * sizeof(p_xfer_desc->p_secondary_buf[0]));

    err_code = twim_xfer(p_cb, (NRF_TWIM_Type *)p_instance->p_twim, p_xfer_desc, flags);
   25d4a:	6804      	ldr	r4, [r0, #0]
    p_cb->error = false;
   25d4c:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e
   25d50:	68f3      	ldr	r3, [r6, #12]
   25d52:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
    if (!nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   25d56:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   25d5a:	d003      	beq.n	25d64 <nrfx_twim_xfer+0x70>
        return err_code;
   25d5c:	4e9e      	ldr	r6, [pc, #632]	; (25fd8 <nrfx_twim_xfer+0x2e4>)
    NRFX_LOG_WARNING("Function: %s, error code: %s.",
                     __func__,
                     NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   25d5e:	4630      	mov	r0, r6
   25d60:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    p_reg->INTENCLR = mask;
   25d64:	4b9d      	ldr	r3, [pc, #628]	; (25fdc <nrfx_twim_xfer+0x2e8>)
   25d66:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    if (p_cb->busy)
   25d6a:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
   25d6e:	f003 09ff 	and.w	r9, r3, #255	; 0xff
   25d72:	b123      	cbz	r3, 25d7e <nrfx_twim_xfer+0x8a>
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   25d74:	68ab      	ldr	r3, [r5, #8]
        return err_code;
   25d76:	4e9a      	ldr	r6, [pc, #616]	; (25fe0 <nrfx_twim_xfer+0x2ec>)
    p_reg->INTENSET = mask;
   25d78:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   25d7c:	e7ef      	b.n	25d5e <nrfx_twim_xfer+0x6a>
                      (NRFX_TWIM_FLAG_REPEATED_XFER & flags)) ? false: true;
   25d7e:	f017 0f14 	tst.w	r7, #20
   25d82:	bf0c      	ite	eq
   25d84:	2301      	moveq	r3, #1
   25d86:	2300      	movne	r3, #0
    p_cb->xfer_desc = *p_xfer_desc;
   25d88:	46b6      	mov	lr, r6
   25d8a:	f8df c27c 	ldr.w	ip, [pc, #636]	; 26008 <nrfx_twim_xfer+0x314>
        p_cb->busy = ((NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER & flags) ||
   25d8e:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
    p_cb->xfer_desc = *p_xfer_desc;
   25d92:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   25d96:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   25d9a:	f8de 3000 	ldr.w	r3, [lr]
    p_cb->flags = flags;
   25d9e:	622f      	str	r7, [r5, #32]
    p_cb->xfer_desc = *p_xfer_desc;
   25da0:	f8cc 3000 	str.w	r3, [ip]
    p_cb->repeated = (flags & NRFX_TWIM_FLAG_REPEATED_XFER) ? true : false;
   25da4:	f3c7 1300 	ubfx	r3, r7, #4, #1
   25da8:	f885 3030 	strb.w	r3, [r5, #48]	; 0x30
}

NRF_STATIC_INLINE void nrf_twim_address_set(NRF_TWIM_Type * p_reg,
                                            uint8_t address)
{
    p_reg->ADDRESS = address;
   25dac:	7873      	ldrb	r3, [r6, #1]
   25dae:	f8c4 3588 	str.w	r3, [r4, #1416]	; 0x588
    if (NRFX_TWIM_FLAG_TX_POSTINC & flags)
   25db2:	f017 0301 	ands.w	r3, r7, #1
    return p_reg->RXD.AMOUNT;
}

NRF_STATIC_INLINE void nrf_twim_tx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_ArrayList << TWIM_TXD_LIST_LIST_Pos;
   25db6:	bf18      	it	ne
   25db8:	2301      	movne	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25dba:	f8c4 9104 	str.w	r9, [r4, #260]	; 0x104
   25dbe:	f8c4 9124 	str.w	r9, [r4, #292]	; 0x124
   25dc2:	f8c4 9160 	str.w	r9, [r4, #352]	; 0x160
   25dc6:	f8c4 9148 	str.w	r9, [r4, #328]	; 0x148
}

NRF_STATIC_INLINE void nrf_twim_tx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_Disabled << TWIM_TXD_LIST_LIST_Pos;
   25dca:	f8c4 3550 	str.w	r3, [r4, #1360]	; 0x550
    if (NRFX_TWIM_FLAG_RX_POSTINC & flags)
   25dce:	f017 0302 	ands.w	r3, r7, #2
}

NRF_STATIC_INLINE void nrf_twim_rx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_ArrayList << TWIM_RXD_LIST_LIST_Pos;
   25dd2:	bf18      	it	ne
   25dd4:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_rx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_Disabled << TWIM_RXD_LIST_LIST_Pos;
   25dd6:	f8c4 3540 	str.w	r3, [r4, #1344]	; 0x540
    switch (p_xfer_desc->type)
   25dda:	7833      	ldrb	r3, [r6, #0]
   25ddc:	2b03      	cmp	r3, #3
   25dde:	f200 80ac 	bhi.w	25f3a <nrfx_twim_xfer+0x246>
   25de2:	e8df f003 	tbb	[pc, r3]
   25de6:	9b86      	.short	0x9b86
   25de8:	026e      	.short	0x026e
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_REPEATED_XFER));
   25dea:	06f9      	lsls	r1, r7, #27
   25dec:	d504      	bpl.n	25df8 <nrfx_twim_xfer+0x104>
   25dee:	4b7d      	ldr	r3, [pc, #500]	; (25fe4 <nrfx_twim_xfer+0x2f0>)
   25df0:	4a7d      	ldr	r2, [pc, #500]	; (25fe8 <nrfx_twim_xfer+0x2f4>)
   25df2:	f240 11a9 	movw	r1, #425	; 0x1a9
   25df6:	e792      	b.n	25d1e <nrfx_twim_xfer+0x2a>
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_HOLD_XFER));
   25df8:	073a      	lsls	r2, r7, #28
   25dfa:	d504      	bpl.n	25e06 <nrfx_twim_xfer+0x112>
   25dfc:	4b7b      	ldr	r3, [pc, #492]	; (25fec <nrfx_twim_xfer+0x2f8>)
   25dfe:	4a7a      	ldr	r2, [pc, #488]	; (25fe8 <nrfx_twim_xfer+0x2f4>)
   25e00:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
   25e04:	e78b      	b.n	25d1e <nrfx_twim_xfer+0x2a>
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER));
   25e06:	f017 0c04 	ands.w	ip, r7, #4
   25e0a:	d004      	beq.n	25e16 <nrfx_twim_xfer+0x122>
   25e0c:	4b78      	ldr	r3, [pc, #480]	; (25ff0 <nrfx_twim_xfer+0x2fc>)
   25e0e:	4a76      	ldr	r2, [pc, #472]	; (25fe8 <nrfx_twim_xfer+0x2f4>)
   25e10:	f240 11ab 	movw	r1, #427	; 0x1ab
   25e14:	e783      	b.n	25d1e <nrfx_twim_xfer+0x2a>
   25e16:	6932      	ldr	r2, [r6, #16]
   25e18:	f002 4060 	and.w	r0, r2, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   25e1c:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
   25e20:	d19c      	bne.n	25d5c <nrfx_twim_xfer+0x68>
    p_reg->SHORTS = mask;
   25e22:	f44f 7080 	mov.w	r0, #256	; 0x100
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   25e26:	68f1      	ldr	r1, [r6, #12]
    p_reg->SHORTS = mask;
   25e28:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   25e2c:	6870      	ldr	r0, [r6, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   25e2e:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   25e32:	2101      	movs	r1, #1
    p_reg->TXD.MAXCNT = length;
   25e34:	f8c4 0548 	str.w	r0, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25e38:	f8c4 c150 	str.w	ip, [r4, #336]	; 0x150
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   25e3c:	6221      	str	r1, [r4, #32]
   25e3e:	60a1      	str	r1, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25e40:	f8d4 1150 	ldr.w	r1, [r4, #336]	; 0x150
        while (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_TXSTARTED))
   25e44:	2900      	cmp	r1, #0
   25e46:	d0fb      	beq.n	25e40 <nrfx_twim_xfer+0x14c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25e48:	2100      	movs	r1, #0
   25e4a:	f8c4 1150 	str.w	r1, [r4, #336]	; 0x150
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   25e4e:	68b1      	ldr	r1, [r6, #8]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   25e50:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
        p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   25e54:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    p_reg->TXD.MAXCNT = length;
   25e58:	f8c4 1548 	str.w	r1, [r4, #1352]	; 0x548
   25e5c:	60aa      	str	r2, [r5, #8]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   25e5e:	f04f 0808 	mov.w	r8, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
   25e62:	4e64      	ldr	r6, [pc, #400]	; (25ff4 <nrfx_twim_xfer+0x300>)
    if (!(flags & NRFX_TWIM_FLAG_HOLD_XFER) && (p_xfer_desc->type != NRFX_TWIM_XFER_TXTX))
   25e64:	0739      	lsls	r1, r7, #28
   25e66:	d404      	bmi.n	25e72 <nrfx_twim_xfer+0x17e>
   25e68:	2b03      	cmp	r3, #3
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   25e6a:	bf1c      	itt	ne
   25e6c:	2301      	movne	r3, #1
   25e6e:	f844 3008 	strne.w	r3, [r4, r8]
    if (p_cb->handler)
   25e72:	682b      	ldr	r3, [r5, #0]
   25e74:	2b00      	cmp	r3, #0
   25e76:	d164      	bne.n	25f42 <nrfx_twim_xfer+0x24e>
                transmission_finished = true;
   25e78:	2101      	movs	r1, #1
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25e7a:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
   25e7e:	f8d4 0104 	ldr.w	r0, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   25e82:	2800      	cmp	r0, #0
   25e84:	d16f      	bne.n	25f66 <nrfx_twim_xfer+0x272>
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_SUSPENDED))
   25e86:	3200      	adds	r2, #0
   25e88:	bf18      	it	ne
   25e8a:	2201      	movne	r2, #1
   25e8c:	f8d4 0124 	ldr.w	r0, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   25e90:	2800      	cmp	r0, #0
   25e92:	d06c      	beq.n	25f6e <nrfx_twim_xfer+0x27a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25e94:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25e98:	f8d4 c160 	ldr.w	ip, [r4, #352]	; 0x160
    return p_reg->SHORTS;
   25e9c:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
                if (!(lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_STOP_MASK)))
   25ea0:	f1bc 0f00 	cmp.w	ip, #0
   25ea4:	d002      	beq.n	25eac <nrfx_twim_xfer+0x1b8>
   25ea6:	f410 7f00 	tst.w	r0, #512	; 0x200
   25eaa:	d105      	bne.n	25eb8 <nrfx_twim_xfer+0x1c4>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   25eac:	6221      	str	r1, [r4, #32]
   25eae:	6161      	str	r1, [r4, #20]
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   25eb0:	f1bc 0f00 	cmp.w	ip, #0
   25eb4:	d0e1      	beq.n	25e7a <nrfx_twim_xfer+0x186>
                    transmission_finished = false;
   25eb6:	2200      	movs	r2, #0
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   25eb8:	05c0      	lsls	r0, r0, #23
   25eba:	d558      	bpl.n	25f6e <nrfx_twim_xfer+0x27a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25ebc:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
                    transmission_finished = false;
   25ec0:	e7db      	b.n	25e7a <nrfx_twim_xfer+0x186>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   25ec2:	6872      	ldr	r2, [r6, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   25ec4:	68f1      	ldr	r1, [r6, #12]
   25ec6:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   25eca:	f8c4 2548 	str.w	r2, [r4, #1352]	; 0x548
   25ece:	6932      	ldr	r2, [r6, #16]
   25ed0:	f002 4160 	and.w	r1, r2, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   25ed4:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
   25ed8:	f47f af40 	bne.w	25d5c <nrfx_twim_xfer+0x68>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   25edc:	68b1      	ldr	r1, [r6, #8]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   25ede:	f8c4 2534 	str.w	r2, [r4, #1332]	; 0x534
    p_reg->SHORTS = mask;
   25ee2:	f44f 5284 	mov.w	r2, #4224	; 0x1080
    p_reg->RXD.MAXCNT = length;
   25ee6:	f8c4 1538 	str.w	r1, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   25eea:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   25eee:	2202      	movs	r2, #2
   25ef0:	e00d      	b.n	25f0e <nrfx_twim_xfer+0x21a>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   25ef2:	6872      	ldr	r2, [r6, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   25ef4:	68f1      	ldr	r1, [r6, #12]
        if (NRFX_TWIM_FLAG_TX_NO_STOP & flags)
   25ef6:	06b8      	lsls	r0, r7, #26
   25ef8:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   25efc:	f8c4 2548 	str.w	r2, [r4, #1352]	; 0x548
   25f00:	d509      	bpl.n	25f16 <nrfx_twim_xfer+0x222>
    p_reg->SHORTS = mask;
   25f02:	f44f 7280 	mov.w	r2, #256	; 0x100
   25f06:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   25f0a:	f44f 2280 	mov.w	r2, #262144	; 0x40000
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   25f0e:	60aa      	str	r2, [r5, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   25f10:	2201      	movs	r2, #1
   25f12:	6222      	str	r2, [r4, #32]
   25f14:	e7a3      	b.n	25e5e <nrfx_twim_xfer+0x16a>
    p_reg->SHORTS = mask;
   25f16:	f44f 7200 	mov.w	r2, #512	; 0x200
   25f1a:	e7e6      	b.n	25eea <nrfx_twim_xfer+0x1f6>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   25f1c:	6872      	ldr	r2, [r6, #4]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   25f1e:	68f1      	ldr	r1, [r6, #12]
   25f20:	f8c4 1534 	str.w	r1, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   25f24:	f8c4 2538 	str.w	r2, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   25f28:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   25f2c:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   25f30:	2202      	movs	r2, #2
   25f32:	60aa      	str	r2, [r5, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   25f34:	2201      	movs	r2, #1
   25f36:	6222      	str	r2, [r4, #32]
   25f38:	e793      	b.n	25e62 <nrfx_twim_xfer+0x16e>
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   25f3a:	f04f 0808 	mov.w	r8, #8
        err_code = NRFX_ERROR_INVALID_PARAM;
   25f3e:	4e2e      	ldr	r6, [pc, #184]	; (25ff8 <nrfx_twim_xfer+0x304>)
   25f40:	e790      	b.n	25e64 <nrfx_twim_xfer+0x170>
        if (flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER)
   25f42:	077a      	lsls	r2, r7, #29
            p_cb->int_mask = 0;
   25f44:	bf44      	itt	mi
   25f46:	2300      	movmi	r3, #0
   25f48:	60ab      	strmi	r3, [r5, #8]
        if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK))
   25f4a:	067b      	lsls	r3, r7, #25
            p_cb->int_mask |= NRF_TWIM_INT_STOPPED_MASK;
   25f4c:	bf5e      	ittt	pl
   25f4e:	68ab      	ldrpl	r3, [r5, #8]
   25f50:	f043 0302 	orrpl.w	r3, r3, #2
   25f54:	60ab      	strpl	r3, [r5, #8]
        p_cb->int_mask |= NRF_TWIM_INT_ERROR_MASK;
   25f56:	68ab      	ldr	r3, [r5, #8]
   25f58:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   25f5c:	60ab      	str	r3, [r5, #8]
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   25f5e:	68ab      	ldr	r3, [r5, #8]
    p_reg->INTENSET = mask;
   25f60:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   25f64:	e6fb      	b.n	25d5e <nrfx_twim_xfer+0x6a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25f66:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
                transmission_finished = true;
   25f6a:	2201      	movs	r2, #1
   25f6c:	e78e      	b.n	25e8c <nrfx_twim_xfer+0x198>
        } while (!transmission_finished);
   25f6e:	2a00      	cmp	r2, #0
   25f70:	d083      	beq.n	25e7a <nrfx_twim_xfer+0x186>
        p_cb->busy = false;
   25f72:	2200      	movs	r2, #0
    uint32_t error_source = p_reg->ERRORSRC;
   25f74:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   25f78:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
   25f7c:	f885 202f 	strb.w	r2, [r5, #47]	; 0x2f
        if (errorsrc)
   25f80:	b18b      	cbz	r3, 25fa6 <nrfx_twim_xfer+0x2b2>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
   25f82:	4a1e      	ldr	r2, [pc, #120]	; (25ffc <nrfx_twim_xfer+0x308>)
   25f84:	f013 0f01 	tst.w	r3, #1
   25f88:	4e1d      	ldr	r6, [pc, #116]	; (26000 <nrfx_twim_xfer+0x30c>)
   25f8a:	bf18      	it	ne
   25f8c:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   25f8e:	f013 0f02 	tst.w	r3, #2
   25f92:	f102 0201 	add.w	r2, r2, #1
   25f96:	bf18      	it	ne
   25f98:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   25f9a:	f013 0f04 	tst.w	r3, #4
   25f9e:	4b19      	ldr	r3, [pc, #100]	; (26004 <nrfx_twim_xfer+0x310>)
   25fa0:	bf18      	it	ne
   25fa2:	461e      	movne	r6, r3
   25fa4:	e6db      	b.n	25d5e <nrfx_twim_xfer+0x6a>
            if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) &&
   25fa6:	067b      	lsls	r3, r7, #25
   25fa8:	f53f aed9 	bmi.w	25d5e <nrfx_twim_xfer+0x6a>
                !xfer_completeness_check(p_twim, p_cb))
   25fac:	4907      	ldr	r1, [pc, #28]	; (25fcc <nrfx_twim_xfer+0x2d8>)
   25fae:	4620      	mov	r0, r4
   25fb0:	f008 ffbc 	bl	2ef2c <xfer_completeness_check>
                err_code = NRFX_ERROR_INTERNAL;
   25fb4:	4b12      	ldr	r3, [pc, #72]	; (26000 <nrfx_twim_xfer+0x30c>)
   25fb6:	2800      	cmp	r0, #0
   25fb8:	bf08      	it	eq
   25fba:	461e      	moveq	r6, r3
   25fbc:	e6cf      	b.n	25d5e <nrfx_twim_xfer+0x6a>
   25fbe:	bf00      	nop
   25fc0:	000344c3 	.word	0x000344c3
   25fc4:	0003441e 	.word	0x0003441e
   25fc8:	00034468 	.word	0x00034468
   25fcc:	200290e4 	.word	0x200290e4
   25fd0:	0003456e 	.word	0x0003456e
   25fd4:	000345be 	.word	0x000345be
   25fd8:	0bad000a 	.word	0x0bad000a
   25fdc:	019c0202 	.word	0x019c0202
   25fe0:	0bad000b 	.word	0x0bad000b
   25fe4:	0003460e 	.word	0x0003460e
   25fe8:	00034414 	.word	0x00034414
   25fec:	00034624 	.word	0x00034624
   25ff0:	0003463a 	.word	0x0003463a
   25ff4:	0bad0000 	.word	0x0bad0000
   25ff8:	0bad0004 	.word	0x0bad0004
   25ffc:	0bae0000 	.word	0x0bae0000
   26000:	0bad0001 	.word	0x0bad0001
   26004:	0bae0002 	.word	0x0bae0002
   26008:	200290f0 	.word	0x200290f0

0002600c <nrfx_twim_1_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_TWIM1_ENABLED)
void nrfx_twim_1_irq_handler(void)
{
   2600c:	b5f0      	push	{r4, r5, r6, r7, lr}
    NRFX_ASSERT(p_cb->handler);
   2600e:	4c5b      	ldr	r4, [pc, #364]	; (2617c <nrfx_twim_1_irq_handler+0x170>)
{
   26010:	b087      	sub	sp, #28
    NRFX_ASSERT(p_cb->handler);
   26012:	6823      	ldr	r3, [r4, #0]
   26014:	b933      	cbnz	r3, 26024 <nrfx_twim_1_irq_handler+0x18>
   26016:	4b5a      	ldr	r3, [pc, #360]	; (26180 <nrfx_twim_1_irq_handler+0x174>)
   26018:	4a5a      	ldr	r2, [pc, #360]	; (26184 <nrfx_twim_1_irq_handler+0x178>)
   2601a:	f44f 7129 	mov.w	r1, #676	; 0x2a4
   2601e:	485a      	ldr	r0, [pc, #360]	; (26188 <nrfx_twim_1_irq_handler+0x17c>)
   26020:	f003 fe8a 	bl	29d38 <__assert_func>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   26024:	4b59      	ldr	r3, [pc, #356]	; (2618c <nrfx_twim_1_irq_handler+0x180>)
   26026:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
   2602a:	461d      	mov	r5, r3
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   2602c:	b1ea      	cbz	r2, 2606a <nrfx_twim_1_irq_handler+0x5e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2602e:	2200      	movs	r2, #0
   26030:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   26034:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
        if (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   26038:	b9ba      	cbnz	r2, 2606a <nrfx_twim_1_irq_handler+0x5e>
            nrf_twim_int_disable(p_twim, p_cb->int_mask);
   2603a:	68a2      	ldr	r2, [r4, #8]
    p_reg->INTENCLR = mask;
   2603c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   26040:	2202      	movs	r2, #2
   26042:	60a2      	str	r2, [r4, #8]
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   26044:	68a2      	ldr	r2, [r4, #8]
    p_reg->INTENSET = mask;
   26046:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2604a:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
            if (!(nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_LASTTX) &&
   2604e:	b11a      	cbz	r2, 26058 <nrfx_twim_1_irq_handler+0x4c>
    return p_reg->SHORTS;
   26050:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
   26054:	059e      	lsls	r6, r3, #22
   26056:	d403      	bmi.n	26060 <nrfx_twim_1_irq_handler+0x54>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   26058:	2201      	movs	r2, #1
   2605a:	4b4c      	ldr	r3, [pc, #304]	; (2618c <nrfx_twim_1_irq_handler+0x180>)
   2605c:	621a      	str	r2, [r3, #32]
   2605e:	615a      	str	r2, [r3, #20]
            p_cb->error = true;
   26060:	2301      	movs	r3, #1
   26062:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
    twim_irq_handler(NRF_TWIM1, &m_cb[NRFX_TWIM1_INST_IDX]);
}
   26066:	b007      	add	sp, #28
   26068:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2606a:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   2606e:	2b00      	cmp	r3, #0
   26070:	d04e      	beq.n	26110 <nrfx_twim_1_irq_handler+0x104>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   26072:	2300      	movs	r3, #0
   26074:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) && !p_cb->error)
   26078:	6a23      	ldr	r3, [r4, #32]
   2607a:	065d      	lsls	r5, r3, #25
   2607c:	d40a      	bmi.n	26094 <nrfx_twim_1_irq_handler+0x88>
   2607e:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   26082:	b93b      	cbnz	r3, 26094 <nrfx_twim_1_irq_handler+0x88>
            p_cb->error = !xfer_completeness_check(p_twim, p_cb);
   26084:	493d      	ldr	r1, [pc, #244]	; (2617c <nrfx_twim_1_irq_handler+0x170>)
   26086:	4841      	ldr	r0, [pc, #260]	; (2618c <nrfx_twim_1_irq_handler+0x180>)
   26088:	f008 ff50 	bl	2ef2c <xfer_completeness_check>
   2608c:	f080 0001 	eor.w	r0, r0, #1
   26090:	f884 002e 	strb.w	r0, [r4, #46]	; 0x2e
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
   26094:	6a23      	ldr	r3, [r4, #32]
   26096:	f013 0704 	ands.w	r7, r3, #4
   2609a:	d11e      	bne.n	260da <nrfx_twim_1_irq_handler+0xce>
            event.xfer_desc = p_cb->xfer_desc;
   2609c:	4e3c      	ldr	r6, [pc, #240]	; (26190 <nrfx_twim_1_irq_handler+0x184>)
   2609e:	ad01      	add	r5, sp, #4
   260a0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   260a2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   260a4:	6833      	ldr	r3, [r6, #0]
   260a6:	f894 c030 	ldrb.w	ip, [r4, #48]	; 0x30
   260aa:	602b      	str	r3, [r5, #0]
   260ac:	4b37      	ldr	r3, [pc, #220]	; (2618c <nrfx_twim_1_irq_handler+0x180>)
   260ae:	f8c3 7160 	str.w	r7, [r3, #352]	; 0x160
   260b2:	f8c3 715c 	str.w	r7, [r3, #348]	; 0x15c
            if (!p_cb->repeated || p_cb->error)
   260b6:	f1bc 0f00 	cmp.w	ip, #0
   260ba:	d002      	beq.n	260c2 <nrfx_twim_1_irq_handler+0xb6>
   260bc:	f894 202e 	ldrb.w	r2, [r4, #46]	; 0x2e
   260c0:	b15a      	cbz	r2, 260da <nrfx_twim_1_irq_handler+0xce>
    p_reg->SHORTS = mask;
   260c2:	2200      	movs	r2, #0
   260c4:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
                p_cb->int_mask = 0;
   260c8:	60a2      	str	r2, [r4, #8]
    p_reg->INTENCLR = mask;
   260ca:	4a32      	ldr	r2, [pc, #200]	; (26194 <nrfx_twim_1_irq_handler+0x188>)
   260cc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   260d0:	f44f 7200 	mov.w	r2, #512	; 0x200
   260d4:	4b30      	ldr	r3, [pc, #192]	; (26198 <nrfx_twim_1_irq_handler+0x18c>)
   260d6:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    uint32_t error_source = p_reg->ERRORSRC;
   260da:	4a2c      	ldr	r2, [pc, #176]	; (2618c <nrfx_twim_1_irq_handler+0x180>)
   260dc:	f8d2 34c4 	ldr.w	r3, [r2, #1220]	; 0x4c4
    if (errorsrc & NRF_TWIM_ERROR_ADDRESS_NACK)
   260e0:	0798      	lsls	r0, r3, #30
    p_reg->ERRORSRC = error_source;
   260e2:	f8c2 34c4 	str.w	r3, [r2, #1220]	; 0x4c4
   260e6:	d53a      	bpl.n	2615e <nrfx_twim_1_irq_handler+0x152>
        event.type = NRFX_TWIM_EVT_ADDRESS_NACK;
   260e8:	2301      	movs	r3, #1
        event.type = NRFX_TWIM_EVT_DONE;
   260ea:	f88d 3000 	strb.w	r3, [sp]
    if (!p_cb->repeated)
   260ee:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   260f2:	b90b      	cbnz	r3, 260f8 <nrfx_twim_1_irq_handler+0xec>
        p_cb->busy = false;
   260f4:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
    if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER) || p_cb->error)
   260f8:	6a23      	ldr	r3, [r4, #32]
   260fa:	075b      	lsls	r3, r3, #29
   260fc:	d503      	bpl.n	26106 <nrfx_twim_1_irq_handler+0xfa>
   260fe:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   26102:	2b00      	cmp	r3, #0
   26104:	d0af      	beq.n	26066 <nrfx_twim_1_irq_handler+0x5a>
        p_cb->handler(&event, p_cb->p_context);
   26106:	e9d4 3100 	ldrd	r3, r1, [r4]
   2610a:	4668      	mov	r0, sp
   2610c:	4798      	blx	r3
}
   2610e:	e7aa      	b.n	26066 <nrfx_twim_1_irq_handler+0x5a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   26110:	f8c5 3148 	str.w	r3, [r5, #328]	; 0x148
        if (p_cb->xfer_desc.type == NRFX_TWIM_XFER_TX)
   26114:	7b23      	ldrb	r3, [r4, #12]
   26116:	b983      	cbnz	r3, 2613a <nrfx_twim_1_irq_handler+0x12e>
            event.xfer_desc = p_cb->xfer_desc;
   26118:	4f1d      	ldr	r7, [pc, #116]	; (26190 <nrfx_twim_1_irq_handler+0x184>)
   2611a:	ae01      	add	r6, sp, #4
   2611c:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
   2611e:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   26120:	683b      	ldr	r3, [r7, #0]
   26122:	6033      	str	r3, [r6, #0]
            if (!p_cb->repeated)
   26124:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   26128:	2b00      	cmp	r3, #0
   2612a:	d1d6      	bne.n	260da <nrfx_twim_1_irq_handler+0xce>
    p_reg->SHORTS = mask;
   2612c:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
                p_cb->int_mask = 0;
   26130:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   26132:	4b18      	ldr	r3, [pc, #96]	; (26194 <nrfx_twim_1_irq_handler+0x188>)
   26134:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
   26138:	e7ca      	b.n	260d0 <nrfx_twim_1_irq_handler+0xc4>
    p_reg->SHORTS = mask;
   2613a:	f44f 7300 	mov.w	r3, #512	; 0x200
   2613e:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK | NRF_TWIM_INT_ERROR_MASK;
   26142:	f240 2302 	movw	r3, #514	; 0x202
   26146:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   26148:	f103 73ce 	add.w	r3, r3, #27000832	; 0x19c0000
   2614c:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   26150:	68a3      	ldr	r3, [r4, #8]
    p_reg->INTENSET = mask;
   26152:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   26156:	2301      	movs	r3, #1
   26158:	60ab      	str	r3, [r5, #8]
   2615a:	622b      	str	r3, [r5, #32]
            return;
   2615c:	e783      	b.n	26066 <nrfx_twim_1_irq_handler+0x5a>
    else if (errorsrc & NRF_TWIM_ERROR_DATA_NACK)
   2615e:	0759      	lsls	r1, r3, #29
   26160:	d501      	bpl.n	26166 <nrfx_twim_1_irq_handler+0x15a>
        event.type = NRFX_TWIM_EVT_DATA_NACK;
   26162:	2302      	movs	r3, #2
   26164:	e7c1      	b.n	260ea <nrfx_twim_1_irq_handler+0xde>
    else if (errorsrc & NRF_TWIM_ERROR_OVERRUN)
   26166:	07da      	lsls	r2, r3, #31
   26168:	d501      	bpl.n	2616e <nrfx_twim_1_irq_handler+0x162>
        event.type = NRFX_TWIM_EVT_OVERRUN;
   2616a:	2303      	movs	r3, #3
   2616c:	e7bd      	b.n	260ea <nrfx_twim_1_irq_handler+0xde>
    else if (p_cb->error)
   2616e:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   26172:	2b00      	cmp	r3, #0
   26174:	d0b9      	beq.n	260ea <nrfx_twim_1_irq_handler+0xde>
        event.type = NRFX_TWIM_EVT_BUS_ERROR;
   26176:	2304      	movs	r3, #4
   26178:	e7b7      	b.n	260ea <nrfx_twim_1_irq_handler+0xde>
   2617a:	bf00      	nop
   2617c:	200290e4 	.word	0x200290e4
   26180:	0003418c 	.word	0x0003418c
   26184:	0003442d 	.word	0x0003442d
   26188:	00034468 	.word	0x00034468
   2618c:	40009000 	.word	0x40009000
   26190:	200290f0 	.word	0x200290f0
   26194:	019c0202 	.word	0x019c0202
   26198:	e000e100 	.word	0xe000e100

0002619c <z_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_device_do_config_level(s32_t level)
{
   2619c:	b570      	push	{r4, r5, r6, lr}
		retval = device_conf->init(info);
		if (retval != 0) {
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
   2619e:	2600      	movs	r6, #0
	for (info = config_levels[level]; info < config_levels[level+1];
   261a0:	4b08      	ldr	r3, [pc, #32]	; (261c4 <z_sys_device_do_config_level+0x28>)
   261a2:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   261a6:	3001      	adds	r0, #1
   261a8:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
   261ac:	42a5      	cmp	r5, r4
   261ae:	d800      	bhi.n	261b2 <z_sys_device_do_config_level+0x16>
		} else {
			z_object_init(info);
		}
	}
}
   261b0:	bd70      	pop	{r4, r5, r6, pc}
		retval = device_conf->init(info);
   261b2:	6823      	ldr	r3, [r4, #0]
   261b4:	4620      	mov	r0, r4
   261b6:	685b      	ldr	r3, [r3, #4]
   261b8:	4798      	blx	r3
		if (retval != 0) {
   261ba:	b100      	cbz	r0, 261be <z_sys_device_do_config_level+0x22>
			info->driver_api = NULL;
   261bc:	6066      	str	r6, [r4, #4]
								info++) {
   261be:	340c      	adds	r4, #12
   261c0:	e7f4      	b.n	261ac <z_sys_device_do_config_level+0x10>
   261c2:	bf00      	nop
   261c4:	00030e90 	.word	0x00030e90

000261c8 <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
   261c8:	4b10      	ldr	r3, [pc, #64]	; (2620c <z_impl_device_get_binding+0x44>)
{
   261ca:	b570      	push	{r4, r5, r6, lr}
   261cc:	4605      	mov	r5, r0
   261ce:	461e      	mov	r6, r3
	for (info = __device_init_start; info != __device_init_end; info++) {
   261d0:	4c0f      	ldr	r4, [pc, #60]	; (26210 <z_impl_device_get_binding+0x48>)
   261d2:	429c      	cmp	r4, r3
   261d4:	d104      	bne.n	261e0 <z_impl_device_get_binding+0x18>
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
   261d6:	4c0e      	ldr	r4, [pc, #56]	; (26210 <z_impl_device_get_binding+0x48>)
   261d8:	42b4      	cmp	r4, r6
   261da:	d109      	bne.n	261f0 <z_impl_device_get_binding+0x28>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
   261dc:	2400      	movs	r4, #0
   261de:	e012      	b.n	26206 <z_impl_device_get_binding+0x3e>
		if ((info->driver_api != NULL) &&
   261e0:	6862      	ldr	r2, [r4, #4]
   261e2:	b11a      	cbz	r2, 261ec <z_impl_device_get_binding+0x24>
		    (info->config->name == name)) {
   261e4:	6822      	ldr	r2, [r4, #0]
		if ((info->driver_api != NULL) &&
   261e6:	6812      	ldr	r2, [r2, #0]
   261e8:	42aa      	cmp	r2, r5
   261ea:	d00c      	beq.n	26206 <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
   261ec:	340c      	adds	r4, #12
   261ee:	e7f0      	b.n	261d2 <z_impl_device_get_binding+0xa>
		if (info->driver_api == NULL) {
   261f0:	6863      	ldr	r3, [r4, #4]
   261f2:	b90b      	cbnz	r3, 261f8 <z_impl_device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
   261f4:	340c      	adds	r4, #12
   261f6:	e7ef      	b.n	261d8 <z_impl_device_get_binding+0x10>
		if (strcmp(name, info->config->name) == 0) {
   261f8:	6823      	ldr	r3, [r4, #0]
   261fa:	4628      	mov	r0, r5
   261fc:	6819      	ldr	r1, [r3, #0]
   261fe:	f7e6 fea1 	bl	cf44 <strcmp>
   26202:	2800      	cmp	r0, #0
   26204:	d1f6      	bne.n	261f4 <z_impl_device_get_binding+0x2c>
}
   26206:	4620      	mov	r0, r4
   26208:	bd70      	pop	{r4, r5, r6, pc}
   2620a:	bf00      	nop
   2620c:	2003b6e4 	.word	0x2003b6e4
   26210:	2003b5d0 	.word	0x2003b5d0

00026214 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   26214:	4b01      	ldr	r3, [pc, #4]	; (2621c <z_impl_z_errno+0x8>)
   26216:	6898      	ldr	r0, [r3, #8]
}
   26218:	3054      	adds	r0, #84	; 0x54
   2621a:	4770      	bx	lr
   2621c:	2002d2e8 	.word	0x2002d2e8

00026220 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   26220:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   26224:	4605      	mov	r5, r0
   26226:	4688      	mov	r8, r1
	return z_impl_k_current_get();
   26228:	f002 f95a 	bl	284e0 <z_impl_k_current_get>
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   2622c:	2301      	movs	r3, #1
   2622e:	4606      	mov	r6, r0
   26230:	f04f 0000 	mov.w	r0, #0
   26234:	2200      	movs	r2, #0
   26236:	f363 0007 	bfi	r0, r3, #0, #8
   2623a:	4c2b      	ldr	r4, [pc, #172]	; (262e8 <z_fatal_error+0xc8>)
   2623c:	4b2b      	ldr	r3, [pc, #172]	; (262ec <z_fatal_error+0xcc>)
   2623e:	2d04      	cmp	r5, #4
   26240:	eba4 0403 	sub.w	r4, r4, r3
   26244:	bf98      	it	ls
   26246:	4b2a      	ldrls	r3, [pc, #168]	; (262f0 <z_fatal_error+0xd0>)
   26248:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   2624c:	bf94      	ite	ls
   2624e:	f853 3025 	ldrls.w	r3, [r3, r5, lsl #2]
   26252:	4b28      	ldrhi	r3, [pc, #160]	; (262f4 <z_fatal_error+0xd4>)
   26254:	9200      	str	r2, [sp, #0]
   26256:	f364 108f 	bfi	r0, r4, #6, #10
   2625a:	462a      	mov	r2, r5
   2625c:	4926      	ldr	r1, [pc, #152]	; (262f8 <z_fatal_error+0xd8>)
   2625e:	f007 f84b 	bl	2d2f8 <log_string_sync>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   26262:	f8d8 301c 	ldr.w	r3, [r8, #28]
   26266:	f3c3 0308 	ubfx	r3, r3, #0, #9
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if (arch_is_in_nested_exception(esf)) {
   2626a:	b14b      	cbz	r3, 26280 <z_fatal_error+0x60>
		LOG_ERR("Fault during interrupt handling\n");
   2626c:	f04f 0000 	mov.w	r0, #0
   26270:	2301      	movs	r3, #1
   26272:	f363 0007 	bfi	r0, r3, #0, #8
   26276:	f364 108f 	bfi	r0, r4, #6, #10
   2627a:	4920      	ldr	r1, [pc, #128]	; (262fc <z_fatal_error+0xdc>)
   2627c:	f007 f83c 	bl	2d2f8 <log_string_sync>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   26280:	f04f 0700 	mov.w	r7, #0
   26284:	2301      	movs	r3, #1
	const char *thread_name = k_thread_name_get(thread);
   26286:	4630      	mov	r0, r6
	LOG_ERR("Current thread: %p (%s)", thread,
   26288:	f363 0707 	bfi	r7, r3, #0, #8
   2628c:	f364 178f 	bfi	r7, r4, #6, #10
	const char *thread_name = k_thread_name_get(thread);
   26290:	f008 ff2b 	bl	2f0ea <k_thread_name_get>
	if (thread_name == NULL || thread_name[0] == '\0') {
   26294:	b328      	cbz	r0, 262e2 <z_fatal_error+0xc2>
   26296:	7802      	ldrb	r2, [r0, #0]
		thread_name = "unknown";
   26298:	4b19      	ldr	r3, [pc, #100]	; (26300 <z_fatal_error+0xe0>)
   2629a:	2a00      	cmp	r2, #0
   2629c:	bf08      	it	eq
   2629e:	4618      	moveq	r0, r3
	LOG_ERR("Current thread: %p (%s)", thread,
   262a0:	f007 f83c 	bl	2d31c <log_strdup>
   262a4:	4632      	mov	r2, r6
   262a6:	4603      	mov	r3, r0
   262a8:	4916      	ldr	r1, [pc, #88]	; (26304 <z_fatal_error+0xe4>)
   262aa:	4638      	mov	r0, r7
   262ac:	f007 f824 	bl	2d2f8 <log_string_sync>
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
   262b0:	4641      	mov	r1, r8
   262b2:	4628      	mov	r0, r5
   262b4:	f7f6 fedc 	bl	1d070 <k_sys_fatal_error_handler>
	 *
	 * Note that k_thread_abort() returns on some architectures but
	 * not others; e.g. on ARC, x86_64, Xtensa with ASM2, ARM
	 */
	if (!IS_ENABLED(CONFIG_TEST)) {
		__ASSERT(reason != K_ERR_KERNEL_PANIC,
   262b8:	2d04      	cmp	r5, #4
   262ba:	d10c      	bne.n	262d6 <z_fatal_error+0xb6>
   262bc:	4912      	ldr	r1, [pc, #72]	; (26308 <z_fatal_error+0xe8>)
   262be:	2387      	movs	r3, #135	; 0x87
   262c0:	4a12      	ldr	r2, [pc, #72]	; (2630c <z_fatal_error+0xec>)
   262c2:	4813      	ldr	r0, [pc, #76]	; (26310 <z_fatal_error+0xf0>)
   262c4:	f006 ffc1 	bl	2d24a <printk>
   262c8:	4812      	ldr	r0, [pc, #72]	; (26314 <z_fatal_error+0xf4>)
   262ca:	f006 ffbe 	bl	2d24a <printk>
   262ce:	2187      	movs	r1, #135	; 0x87
   262d0:	480e      	ldr	r0, [pc, #56]	; (2630c <z_fatal_error+0xec>)
   262d2:	f007 f800 	bl	2d2d6 <assert_post_action>
	z_impl_k_thread_abort(thread);
   262d6:	4630      	mov	r0, r6
			}
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	k_thread_abort(thread);
}
   262d8:	b002      	add	sp, #8
   262da:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   262de:	f7f3 bb35 	b.w	1994c <z_impl_k_thread_abort>
		thread_name = "unknown";
   262e2:	4807      	ldr	r0, [pc, #28]	; (26300 <z_fatal_error+0xe0>)
   262e4:	e7dc      	b.n	262a0 <z_fatal_error+0x80>
   262e6:	bf00      	nop
   262e8:	000304dc 	.word	0x000304dc
   262ec:	0003040c 	.word	0x0003040c
   262f0:	00030ea8 	.word	0x00030ea8
   262f4:	0003469a 	.word	0x0003469a
   262f8:	000346b0 	.word	0x000346b0
   262fc:	000346d8 	.word	0x000346d8
   26300:	000346a8 	.word	0x000346a8
   26304:	000346f9 	.word	0x000346f9
   26308:	00034733 	.word	0x00034733
   2630c:	00034711 	.word	0x00034711
   26310:	000311a3 	.word	0x000311a3
   26314:	00034750 	.word	0x00034750

00026318 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
   26318:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
   2631a:	4d0b      	ldr	r5, [pc, #44]	; (26348 <idle+0x30>)
	__asm__ volatile(
   2631c:	f04f 0220 	mov.w	r2, #32
   26320:	f3ef 8311 	mrs	r3, BASEPRI
   26324:	f382 8811 	msr	BASEPRI, r2
   26328:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
   2632c:	f002 fdca 	bl	28ec4 <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   26330:	2101      	movs	r1, #1
	s32_t ticks = z_get_next_timeout_expiry();
   26332:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   26334:	2802      	cmp	r0, #2
   26336:	bfd8      	it	le
   26338:	4608      	movle	r0, r1
   2633a:	f002 fe0b 	bl	28f54 <z_set_timeout_expiry>
	_kernel.idle = ticks;
   2633e:	622c      	str	r4, [r5, #32]
 * @return N/A
 * @req K-CPU-IDLE-001
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
   26340:	f7f2 fe16 	bl	18f70 <arch_cpu_idle>
   26344:	e7ea      	b.n	2631c <idle+0x4>
   26346:	bf00      	nop
   26348:	2002d2e8 	.word	0x2002d2e8

0002634c <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   2634c:	4802      	ldr	r0, [pc, #8]	; (26358 <z_bss_zero+0xc>)
   2634e:	4a03      	ldr	r2, [pc, #12]	; (2635c <z_bss_zero+0x10>)
   26350:	2100      	movs	r1, #0
   26352:	1a12      	subs	r2, r2, r0
   26354:	f009 b81e 	b.w	2f394 <memset>
   26358:	20020000 	.word	0x20020000
   2635c:	20031614 	.word	0x20031614

00026360 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   26360:	b508      	push	{r3, lr}
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   26362:	4806      	ldr	r0, [pc, #24]	; (2637c <z_data_copy+0x1c>)
   26364:	4a06      	ldr	r2, [pc, #24]	; (26380 <z_data_copy+0x20>)
   26366:	4907      	ldr	r1, [pc, #28]	; (26384 <z_data_copy+0x24>)
   26368:	1a12      	subs	r2, r2, r0
   2636a:	f008 fff3 	bl	2f354 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   2636e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   26372:	4a05      	ldr	r2, [pc, #20]	; (26388 <z_data_copy+0x28>)
   26374:	4905      	ldr	r1, [pc, #20]	; (2638c <z_data_copy+0x2c>)
   26376:	4806      	ldr	r0, [pc, #24]	; (26390 <z_data_copy+0x30>)
   26378:	f008 bfec 	b.w	2f354 <memcpy>
   2637c:	20038298 	.word	0x20038298
   26380:	2003b9bc 	.word	0x2003b9bc
   26384:	00034f9c 	.word	0x00034f9c
   26388:	00000000 	.word	0x00000000
   2638c:	00034f9c 	.word	0x00034f9c
   26390:	20020000 	.word	0x20020000

00026394 <bg_thread_main>:
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
   26394:	2201      	movs	r2, #1
{
   26396:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   26398:	4b08      	ldr	r3, [pc, #32]	; (263bc <bg_thread_main+0x28>)

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   2639a:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   2639c:	701a      	strb	r2, [r3, #0]
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   2639e:	f7ff fefd 	bl	2619c <z_sys_device_do_config_level>
			KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
   263a2:	2003      	movs	r0, #3
   263a4:	f7ff fefa 	bl	2619c <z_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
   263a8:	f002 fa70 	bl	2888c <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
   263ac:	f005 f818 	bl	2b3e0 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   263b0:	4a03      	ldr	r2, [pc, #12]	; (263c0 <bg_thread_main+0x2c>)
   263b2:	7b13      	ldrb	r3, [r2, #12]
   263b4:	f023 0301 	bic.w	r3, r3, #1
   263b8:	7313      	strb	r3, [r2, #12]

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   263ba:	bd08      	pop	{r3, pc}
   263bc:	200314bd 	.word	0x200314bd
   263c0:	200291c8 	.word	0x200291c8

000263c4 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
   263c4:	b580      	push	{r7, lr}
   263c6:	b0b2      	sub	sp, #200	; 0xc8
#endif	/* CONFIG_STACK_CANARIES */

	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
   263c8:	f7f1 fa7a 	bl	178c0 <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(_interrupt_stack)) +
   263cc:	4b35      	ldr	r3, [pc, #212]	; (264a4 <z_cstart+0xe0>)
   263ce:	f503 6200 	add.w	r2, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   263d2:	f382 8808 	msr	MSP, r2
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
   263d6:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   263da:	2400      	movs	r4, #0
   263dc:	23e0      	movs	r3, #224	; 0xe0
   263de:	4d32      	ldr	r5, [pc, #200]	; (264a8 <z_cstart+0xe4>)

	/* perform any architecture-specific initialization */
	arch_kernel_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
   263e0:	2701      	movs	r7, #1
   263e2:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   263e6:	77ec      	strb	r4, [r5, #31]
   263e8:	762c      	strb	r4, [r5, #24]
   263ea:	766c      	strb	r4, [r5, #25]
   263ec:	76ac      	strb	r4, [r5, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   263ee:	6a6b      	ldr	r3, [r5, #36]	; 0x24
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
   263f0:	4e2e      	ldr	r6, [pc, #184]	; (264ac <z_cstart+0xe8>)
   263f2:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   263f6:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   263f8:	f7f3 fa7e 	bl	198f8 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   263fc:	f7f2 fdb2 	bl	18f64 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   26400:	f04f 33ff 	mov.w	r3, #4294967295
   26404:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   26406:	62eb      	str	r3, [r5, #44]	; 0x2c
	struct k_thread dummy_thread = {
   26408:	ab06      	add	r3, sp, #24
   2640a:	22b0      	movs	r2, #176	; 0xb0
   2640c:	4621      	mov	r1, r4
   2640e:	4618      	mov	r0, r3
   26410:	f008 ffc0 	bl	2f394 <memset>
	_current = &dummy_thread;
   26414:	60b0      	str	r0, [r6, #8]
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   26416:	4620      	mov	r0, r4
	struct k_thread dummy_thread = {
   26418:	f88d 7025 	strb.w	r7, [sp, #37]	; 0x25
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   2641c:	f7ff febe 	bl	2619c <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   26420:	4638      	mov	r0, r7
   26422:	f7ff febb 	bl	2619c <z_sys_device_do_config_level>
	_kernel.ready_q.cache = &z_main_thread;
   26426:	4d22      	ldr	r5, [pc, #136]	; (264b0 <z_cstart+0xec>)
	z_sched_init();
   26428:	f001 fed0 	bl	281cc <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
   2642c:	4b21      	ldr	r3, [pc, #132]	; (264b4 <z_cstart+0xf0>)
   2642e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   26432:	e9cd 7304 	strd	r7, r3, [sp, #16]
   26436:	e9cd 4402 	strd	r4, r4, [sp, #8]
   2643a:	4b1f      	ldr	r3, [pc, #124]	; (264b8 <z_cstart+0xf4>)
   2643c:	e9cd 4400 	strd	r4, r4, [sp]
   26440:	491e      	ldr	r1, [pc, #120]	; (264bc <z_cstart+0xf8>)
   26442:	4628      	mov	r0, r5
	_kernel.ready_q.cache = &z_main_thread;
   26444:	6275      	str	r5, [r6, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
   26446:	f002 f937 	bl	286b8 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   2644a:	7b6b      	ldrb	r3, [r5, #13]
   2644c:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   26450:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
   26454:	736a      	strb	r2, [r5, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   26456:	d104      	bne.n	26462 <z_cstart+0x9e>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
   26458:	69ab      	ldr	r3, [r5, #24]
   2645a:	b913      	cbnz	r3, 26462 <z_cstart+0x9e>
		z_add_thread_to_ready_q(thread);
   2645c:	4628      	mov	r0, r5
   2645e:	f001 f9af 	bl	277c0 <z_add_thread_to_ready_q>
	z_setup_new_thread(thread, stack,
   26462:	4b17      	ldr	r3, [pc, #92]	; (264c0 <z_cstart+0xfc>)
   26464:	2201      	movs	r2, #1
   26466:	9305      	str	r3, [sp, #20]
   26468:	230f      	movs	r3, #15
   2646a:	e9cd 3203 	strd	r3, r2, [sp, #12]
   2646e:	2300      	movs	r3, #0
   26470:	4d14      	ldr	r5, [pc, #80]	; (264c4 <z_cstart+0x100>)
   26472:	e9cd 3301 	strd	r3, r3, [sp, #4]
   26476:	9300      	str	r3, [sp, #0]
   26478:	f44f 72a0 	mov.w	r2, #320	; 0x140
   2647c:	4b12      	ldr	r3, [pc, #72]	; (264c8 <z_cstart+0x104>)
   2647e:	4913      	ldr	r1, [pc, #76]	; (264cc <z_cstart+0x108>)
   26480:	4628      	mov	r0, r5
   26482:	f002 f919 	bl	286b8 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   26486:	7b6b      	ldrb	r3, [r5, #13]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
   26488:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   2648c:	f023 0304 	bic.w	r3, r3, #4
   26490:	736b      	strb	r3, [r5, #13]
	list->head = (sys_dnode_t *)list;
   26492:	4b0f      	ldr	r3, [pc, #60]	; (264d0 <z_cstart+0x10c>)
   26494:	4909      	ldr	r1, [pc, #36]	; (264bc <z_cstart+0xf8>)
	list->tail = (sys_dnode_t *)list;
   26496:	e9c6 3306 	strd	r3, r3, [r6, #24]
   2649a:	4805      	ldr	r0, [pc, #20]	; (264b0 <z_cstart+0xec>)
   2649c:	4b06      	ldr	r3, [pc, #24]	; (264b8 <z_cstart+0xf4>)
	_kernel.cpus[0].idle_thread = &z_idle_thread;
   2649e:	60f5      	str	r5, [r6, #12]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
   264a0:	f7f2 fe56 	bl	19150 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   264a4:	20035d58 	.word	0x20035d58
   264a8:	e000ed00 	.word	0xe000ed00
   264ac:	2002d2e8 	.word	0x2002d2e8
   264b0:	200291c8 	.word	0x200291c8
   264b4:	00034785 	.word	0x00034785
   264b8:	00026395 	.word	0x00026395
   264bc:	20033c18 	.word	0x20033c18
   264c0:	0003478a 	.word	0x0003478a
   264c4:	20029118 	.word	0x20029118
   264c8:	00026319 	.word	0x00026319
   264cc:	20035c18 	.word	0x20035c18
   264d0:	2002d300 	.word	0x2002d300

000264d4 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(struct device *dev)
{
   264d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   264d8:	4d16      	ldr	r5, [pc, #88]	; (26534 <init_mem_slab_module+0x60>)
   264da:	4c17      	ldr	r4, [pc, #92]	; (26538 <init_mem_slab_module+0x64>)
   264dc:	46a8      	mov	r8, r5
   264de:	4e17      	ldr	r6, [pc, #92]	; (2653c <init_mem_slab_module+0x68>)
   264e0:	42ac      	cmp	r4, r5
   264e2:	d90c      	bls.n	264fe <init_mem_slab_module+0x2a>
   264e4:	4916      	ldr	r1, [pc, #88]	; (26540 <init_mem_slab_module+0x6c>)
   264e6:	2342      	movs	r3, #66	; 0x42
   264e8:	4632      	mov	r2, r6
   264ea:	4816      	ldr	r0, [pc, #88]	; (26544 <init_mem_slab_module+0x70>)
   264ec:	f006 fead 	bl	2d24a <printk>
   264f0:	4815      	ldr	r0, [pc, #84]	; (26548 <init_mem_slab_module+0x74>)
   264f2:	f006 feaa 	bl	2d24a <printk>
   264f6:	2142      	movs	r1, #66	; 0x42
   264f8:	4630      	mov	r0, r6
   264fa:	f006 feec 	bl	2d2d6 <assert_post_action>
   264fe:	4544      	cmp	r4, r8
   26500:	d302      	bcc.n	26508 <init_mem_slab_module+0x34>
		}
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}

out:
   26502:	2000      	movs	r0, #0
	return rc;
}
   26504:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   26508:	e9d4 1203 	ldrd	r1, r2, [r4, #12]
   2650c:	ea42 0301 	orr.w	r3, r2, r1
   26510:	f013 0303 	ands.w	r3, r3, #3
   26514:	d10b      	bne.n	2652e <init_mem_slab_module+0x5a>
	for (j = 0U; j < slab->num_blocks; j++) {
   26516:	68a0      	ldr	r0, [r4, #8]
	slab->free_list = NULL;
   26518:	6163      	str	r3, [r4, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   2651a:	4283      	cmp	r3, r0
   2651c:	d101      	bne.n	26522 <init_mem_slab_module+0x4e>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   2651e:	341c      	adds	r4, #28
   26520:	e7de      	b.n	264e0 <init_mem_slab_module+0xc>
		*(char **)p = slab->free_list;
   26522:	6967      	ldr	r7, [r4, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   26524:	3301      	adds	r3, #1
		*(char **)p = slab->free_list;
   26526:	6017      	str	r7, [r2, #0]
		slab->free_list = p;
   26528:	6162      	str	r2, [r4, #20]
		p += slab->block_size;
   2652a:	440a      	add	r2, r1
   2652c:	e7f5      	b.n	2651a <init_mem_slab_module+0x46>
		return -EINVAL;
   2652e:	f06f 0015 	mvn.w	r0, #21
	return rc;
   26532:	e7e7      	b.n	26504 <init_mem_slab_module+0x30>
   26534:	2003b834 	.word	0x2003b834
   26538:	2003b818 	.word	0x2003b818
   2653c:	0003478f 	.word	0x0003478f
   26540:	000347b4 	.word	0x000347b4
   26544:	000311a3 	.word	0x000311a3
   26548:	000347d1 	.word	0x000347d1

0002654c <k_mem_slab_alloc>:
out:
	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)
{
   2654c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2654e:	4604      	mov	r4, r0
   26550:	460d      	mov	r5, r1
   26552:	4616      	mov	r6, r2
   26554:	f04f 0320 	mov.w	r3, #32
   26558:	f3ef 8711 	mrs	r7, BASEPRI
   2655c:	f383 8811 	msr	BASEPRI, r3
   26560:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26564:	4823      	ldr	r0, [pc, #140]	; (265f4 <k_mem_slab_alloc+0xa8>)
   26566:	f002 f8bf 	bl	286e8 <z_spin_lock_valid>
   2656a:	b968      	cbnz	r0, 26588 <k_mem_slab_alloc+0x3c>
   2656c:	234a      	movs	r3, #74	; 0x4a
   2656e:	4a22      	ldr	r2, [pc, #136]	; (265f8 <k_mem_slab_alloc+0xac>)
   26570:	4922      	ldr	r1, [pc, #136]	; (265fc <k_mem_slab_alloc+0xb0>)
   26572:	4823      	ldr	r0, [pc, #140]	; (26600 <k_mem_slab_alloc+0xb4>)
   26574:	f006 fe69 	bl	2d24a <printk>
   26578:	491e      	ldr	r1, [pc, #120]	; (265f4 <k_mem_slab_alloc+0xa8>)
   2657a:	4822      	ldr	r0, [pc, #136]	; (26604 <k_mem_slab_alloc+0xb8>)
   2657c:	f006 fe65 	bl	2d24a <printk>
   26580:	214a      	movs	r1, #74	; 0x4a
   26582:	481d      	ldr	r0, [pc, #116]	; (265f8 <k_mem_slab_alloc+0xac>)
   26584:	f006 fea7 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   26588:	481a      	ldr	r0, [pc, #104]	; (265f4 <k_mem_slab_alloc+0xa8>)
   2658a:	f002 f8cb 	bl	28724 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
   2658e:	6963      	ldr	r3, [r4, #20]
   26590:	b1eb      	cbz	r3, 265ce <k_mem_slab_alloc+0x82>
		/* take a free block */
		*mem = slab->free_list;
   26592:	602b      	str	r3, [r5, #0]
		slab->free_list = *(char **)(slab->free_list);
   26594:	681b      	ldr	r3, [r3, #0]
   26596:	6163      	str	r3, [r4, #20]
		slab->num_used++;
   26598:	69a3      	ldr	r3, [r4, #24]
   2659a:	3301      	adds	r3, #1
   2659c:	61a3      	str	r3, [r4, #24]
		result = 0;
   2659e:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   265a0:	4814      	ldr	r0, [pc, #80]	; (265f4 <k_mem_slab_alloc+0xa8>)
   265a2:	f002 f8af 	bl	28704 <z_spin_unlock_valid>
   265a6:	b968      	cbnz	r0, 265c4 <k_mem_slab_alloc+0x78>
   265a8:	235d      	movs	r3, #93	; 0x5d
   265aa:	4a13      	ldr	r2, [pc, #76]	; (265f8 <k_mem_slab_alloc+0xac>)
   265ac:	4916      	ldr	r1, [pc, #88]	; (26608 <k_mem_slab_alloc+0xbc>)
   265ae:	4814      	ldr	r0, [pc, #80]	; (26600 <k_mem_slab_alloc+0xb4>)
   265b0:	f006 fe4b 	bl	2d24a <printk>
   265b4:	490f      	ldr	r1, [pc, #60]	; (265f4 <k_mem_slab_alloc+0xa8>)
   265b6:	4815      	ldr	r0, [pc, #84]	; (2660c <k_mem_slab_alloc+0xc0>)
   265b8:	f006 fe47 	bl	2d24a <printk>
   265bc:	215d      	movs	r1, #93	; 0x5d
   265be:	480e      	ldr	r0, [pc, #56]	; (265f8 <k_mem_slab_alloc+0xac>)
   265c0:	f006 fe89 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   265c4:	f387 8811 	msr	BASEPRI, r7
   265c8:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
   265cc:	e010      	b.n	265f0 <k_mem_slab_alloc+0xa4>
	} else if (timeout == K_NO_WAIT) {
   265ce:	b91e      	cbnz	r6, 265d8 <k_mem_slab_alloc+0x8c>
		*mem = NULL;
   265d0:	602e      	str	r6, [r5, #0]
		result = -ENOMEM;
   265d2:	f06f 040b 	mvn.w	r4, #11
   265d6:	e7e3      	b.n	265a0 <k_mem_slab_alloc+0x54>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
   265d8:	4622      	mov	r2, r4
   265da:	4633      	mov	r3, r6
   265dc:	4639      	mov	r1, r7
   265de:	4805      	ldr	r0, [pc, #20]	; (265f4 <k_mem_slab_alloc+0xa8>)
   265e0:	f001 fca8 	bl	27f34 <z_pend_curr>
		if (result == 0) {
   265e4:	4604      	mov	r4, r0
   265e6:	b918      	cbnz	r0, 265f0 <k_mem_slab_alloc+0xa4>
			*mem = _current->base.swap_data;
   265e8:	4b09      	ldr	r3, [pc, #36]	; (26610 <k_mem_slab_alloc+0xc4>)
   265ea:	689b      	ldr	r3, [r3, #8]
   265ec:	695b      	ldr	r3, [r3, #20]
   265ee:	602b      	str	r3, [r5, #0]
}
   265f0:	4620      	mov	r0, r4
   265f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   265f4:	20029278 	.word	0x20029278
   265f8:	00031168 	.word	0x00031168
   265fc:	0003118e 	.word	0x0003118e
   26600:	000311a3 	.word	0x000311a3
   26604:	000311c0 	.word	0x000311c0
   26608:	00031202 	.word	0x00031202
   2660c:	00031219 	.word	0x00031219
   26610:	2002d2e8 	.word	0x2002d2e8

00026614 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   26614:	b570      	push	{r4, r5, r6, lr}
   26616:	4604      	mov	r4, r0
   26618:	460d      	mov	r5, r1
	__asm__ volatile(
   2661a:	f04f 0320 	mov.w	r3, #32
   2661e:	f3ef 8611 	mrs	r6, BASEPRI
   26622:	f383 8811 	msr	BASEPRI, r3
   26626:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2662a:	4824      	ldr	r0, [pc, #144]	; (266bc <k_mem_slab_free+0xa8>)
   2662c:	f002 f85c 	bl	286e8 <z_spin_lock_valid>
   26630:	b968      	cbnz	r0, 2664e <k_mem_slab_free+0x3a>
   26632:	234a      	movs	r3, #74	; 0x4a
   26634:	4a22      	ldr	r2, [pc, #136]	; (266c0 <k_mem_slab_free+0xac>)
   26636:	4923      	ldr	r1, [pc, #140]	; (266c4 <k_mem_slab_free+0xb0>)
   26638:	4823      	ldr	r0, [pc, #140]	; (266c8 <k_mem_slab_free+0xb4>)
   2663a:	f006 fe06 	bl	2d24a <printk>
   2663e:	491f      	ldr	r1, [pc, #124]	; (266bc <k_mem_slab_free+0xa8>)
   26640:	4822      	ldr	r0, [pc, #136]	; (266cc <k_mem_slab_free+0xb8>)
   26642:	f006 fe02 	bl	2d24a <printk>
   26646:	214a      	movs	r1, #74	; 0x4a
   26648:	481d      	ldr	r0, [pc, #116]	; (266c0 <k_mem_slab_free+0xac>)
   2664a:	f006 fe44 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   2664e:	481b      	ldr	r0, [pc, #108]	; (266bc <k_mem_slab_free+0xa8>)
   26650:	f002 f868 	bl	28724 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   26654:	4620      	mov	r0, r4
   26656:	f001 fd29 	bl	280ac <z_unpend_first_thread>

	if (pending_thread != NULL) {
   2665a:	b180      	cbz	r0, 2667e <k_mem_slab_free+0x6a>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   2665c:	2100      	movs	r1, #0
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   2665e:	682a      	ldr	r2, [r5, #0]
   26660:	6681      	str	r1, [r0, #104]	; 0x68
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   26662:	6142      	str	r2, [r0, #20]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   26664:	7b42      	ldrb	r2, [r0, #13]
   26666:	06d2      	lsls	r2, r2, #27
   26668:	d103      	bne.n	26672 <k_mem_slab_free+0x5e>
	if (z_is_thread_ready(thread)) {
   2666a:	6983      	ldr	r3, [r0, #24]
   2666c:	b90b      	cbnz	r3, 26672 <k_mem_slab_free+0x5e>
		z_add_thread_to_ready_q(thread);
   2666e:	f001 f8a7 	bl	277c0 <z_add_thread_to_ready_q>
		z_ready_thread(pending_thread);
		z_reschedule(&lock, key);
   26672:	4631      	mov	r1, r6
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
   26674:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   26678:	4810      	ldr	r0, [pc, #64]	; (266bc <k_mem_slab_free+0xa8>)
   2667a:	f000 beb7 	b.w	273ec <z_reschedule>
		**(char ***)mem = slab->free_list;
   2667e:	682b      	ldr	r3, [r5, #0]
   26680:	6962      	ldr	r2, [r4, #20]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26682:	480e      	ldr	r0, [pc, #56]	; (266bc <k_mem_slab_free+0xa8>)
   26684:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
   26686:	682b      	ldr	r3, [r5, #0]
   26688:	6163      	str	r3, [r4, #20]
		slab->num_used--;
   2668a:	69a3      	ldr	r3, [r4, #24]
   2668c:	3b01      	subs	r3, #1
   2668e:	61a3      	str	r3, [r4, #24]
   26690:	f002 f838 	bl	28704 <z_spin_unlock_valid>
   26694:	b968      	cbnz	r0, 266b2 <k_mem_slab_free+0x9e>
   26696:	235d      	movs	r3, #93	; 0x5d
   26698:	4a09      	ldr	r2, [pc, #36]	; (266c0 <k_mem_slab_free+0xac>)
   2669a:	490d      	ldr	r1, [pc, #52]	; (266d0 <k_mem_slab_free+0xbc>)
   2669c:	480a      	ldr	r0, [pc, #40]	; (266c8 <k_mem_slab_free+0xb4>)
   2669e:	f006 fdd4 	bl	2d24a <printk>
   266a2:	4906      	ldr	r1, [pc, #24]	; (266bc <k_mem_slab_free+0xa8>)
   266a4:	480b      	ldr	r0, [pc, #44]	; (266d4 <k_mem_slab_free+0xc0>)
   266a6:	f006 fdd0 	bl	2d24a <printk>
   266aa:	215d      	movs	r1, #93	; 0x5d
   266ac:	4804      	ldr	r0, [pc, #16]	; (266c0 <k_mem_slab_free+0xac>)
   266ae:	f006 fe12 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   266b2:	f386 8811 	msr	BASEPRI, r6
   266b6:	f3bf 8f6f 	isb	sy
}
   266ba:	bd70      	pop	{r4, r5, r6, pc}
   266bc:	20029278 	.word	0x20029278
   266c0:	00031168 	.word	0x00031168
   266c4:	0003118e 	.word	0x0003118e
   266c8:	000311a3 	.word	0x000311a3
   266cc:	000311c0 	.word	0x000311c0
   266d0:	00031202 	.word	0x00031202
   266d4:	00031219 	.word	0x00031219

000266d8 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
   266d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ARG_UNUSED(unused);

	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
   266da:	4d10      	ldr	r5, [pc, #64]	; (2671c <init_static_pools+0x44>)
   266dc:	4c10      	ldr	r4, [pc, #64]	; (26720 <init_static_pools+0x48>)
   266de:	462f      	mov	r7, r5
   266e0:	4e10      	ldr	r6, [pc, #64]	; (26724 <init_static_pools+0x4c>)
   266e2:	42ac      	cmp	r4, r5
   266e4:	d90c      	bls.n	26700 <init_static_pools+0x28>
   266e6:	4910      	ldr	r1, [pc, #64]	; (26728 <init_static_pools+0x50>)
   266e8:	2328      	movs	r3, #40	; 0x28
   266ea:	4632      	mov	r2, r6
   266ec:	480f      	ldr	r0, [pc, #60]	; (2672c <init_static_pools+0x54>)
   266ee:	f006 fdac 	bl	2d24a <printk>
   266f2:	480f      	ldr	r0, [pc, #60]	; (26730 <init_static_pools+0x58>)
   266f4:	f006 fda9 	bl	2d24a <printk>
   266f8:	2128      	movs	r1, #40	; 0x28
   266fa:	4630      	mov	r0, r6
   266fc:	f006 fdeb 	bl	2d2d6 <assert_post_action>
   26700:	42bc      	cmp	r4, r7
   26702:	d301      	bcc.n	26708 <init_static_pools+0x30>
		k_mem_pool_init(p);
	}

	return 0;
}
   26704:	2000      	movs	r0, #0
   26706:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   26708:	f104 0314 	add.w	r3, r4, #20
	z_sys_mem_pool_base_init(&p->base);
   2670c:	4620      	mov	r0, r4
   2670e:	e9c4 3305 	strd	r3, r3, [r4, #20]
   26712:	f006 fb22 	bl	2cd5a <z_sys_mem_pool_base_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
   26716:	341c      	adds	r4, #28
   26718:	e7e3      	b.n	266e2 <init_static_pools+0xa>
   2671a:	bf00      	nop
   2671c:	2003b850 	.word	0x2003b850
   26720:	2003b834 	.word	0x2003b834
   26724:	000347f0 	.word	0x000347f0
   26728:	00034814 	.word	0x00034814
   2672c:	000311a3 	.word	0x000311a3
   26730:	000347d1 	.word	0x000347d1

00026734 <k_mem_pool_alloc>:

SYS_INIT(init_static_pools, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, s32_t timeout)
{
   26734:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   26738:	4607      	mov	r7, r0
   2673a:	b085      	sub	sp, #20
   2673c:	460d      	mov	r5, r1
   2673e:	4692      	mov	sl, r2
   26740:	461c      	mov	r4, r3
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   26742:	f3ef 8305 	mrs	r3, IPSR
	int ret;
	s64_t end = 0;

	__ASSERT(!(arch_is_in_isr() && timeout != K_NO_WAIT), "");
   26746:	2b00      	cmp	r3, #0
   26748:	d048      	beq.n	267dc <k_mem_pool_alloc+0xa8>
   2674a:	2c00      	cmp	r4, #0
   2674c:	d139      	bne.n	267c2 <k_mem_pool_alloc+0x8e>
	s64_t end = 0;
   2674e:	f04f 0800 	mov.w	r8, #0
	return pool - &_k_mem_pool_list_start[0];
   26752:	4b26      	ldr	r3, [pc, #152]	; (267ec <k_mem_pool_alloc+0xb8>)
   26754:	4e26      	ldr	r6, [pc, #152]	; (267f0 <k_mem_pool_alloc+0xbc>)
   26756:	1afb      	subs	r3, r7, r3
   26758:	109b      	asrs	r3, r3, #2
   2675a:	435e      	muls	r6, r3
		if (ret == 0 || timeout == K_NO_WAIT ||
		    ret != -ENOMEM) {
			return ret;
		}

		z_pend_curr_unlocked(&p->wait_q, timeout);
   2675c:	f107 0b14 	add.w	fp, r7, #20
		block->id.pool = pool_id(p);
   26760:	b2f6      	uxtb	r6, r6
		ret = z_sys_mem_pool_block_alloc(&p->base, size,
   26762:	ab03      	add	r3, sp, #12
   26764:	aa02      	add	r2, sp, #8
   26766:	9500      	str	r5, [sp, #0]
   26768:	4651      	mov	r1, sl
   2676a:	4638      	mov	r0, r7
   2676c:	f006 fb3b 	bl	2cde6 <z_sys_mem_pool_block_alloc>
		block->id.level = level_num;
   26770:	796b      	ldrb	r3, [r5, #5]
   26772:	9a02      	ldr	r2, [sp, #8]
		block->id.pool = pool_id(p);
   26774:	712e      	strb	r6, [r5, #4]
		block->id.level = level_num;
   26776:	f362 0303 	bfi	r3, r2, #0, #4
   2677a:	716b      	strb	r3, [r5, #5]
		block->id.block = block_num;
   2677c:	686b      	ldr	r3, [r5, #4]
   2677e:	9a03      	ldr	r2, [sp, #12]
   26780:	f362 331f 	bfi	r3, r2, #12, #20
   26784:	606b      	str	r3, [r5, #4]
		if (ret == 0 || timeout == K_NO_WAIT ||
   26786:	b1c8      	cbz	r0, 267bc <k_mem_pool_alloc+0x88>
   26788:	b1c4      	cbz	r4, 267bc <k_mem_pool_alloc+0x88>
   2678a:	f110 0f0c 	cmn.w	r0, #12
   2678e:	d115      	bne.n	267bc <k_mem_pool_alloc+0x88>
	__asm__ volatile(
   26790:	f04f 0320 	mov.w	r3, #32
   26794:	f3ef 8011 	mrs	r0, BASEPRI
   26798:	f383 8811 	msr	BASEPRI, r3
   2679c:	f3bf 8f6f 	isb	sy
	(void) z_pend_curr_irqlock(arch_irq_lock(), wait_q, timeout);
   267a0:	4622      	mov	r2, r4
   267a2:	4659      	mov	r1, fp
   267a4:	f001 fb6c 	bl	27e80 <z_pend_curr_irqlock>

		if (timeout != K_FOREVER) {
   267a8:	1c63      	adds	r3, r4, #1
   267aa:	d0da      	beq.n	26762 <k_mem_pool_alloc+0x2e>
	return z_impl_k_uptime_get();
   267ac:	f008 fd15 	bl	2f1da <z_impl_k_uptime_get>
			timeout = end - k_uptime_get();
   267b0:	eba8 0400 	sub.w	r4, r8, r0
			if (timeout <= 0) {
   267b4:	2c00      	cmp	r4, #0
   267b6:	dcd4      	bgt.n	26762 <k_mem_pool_alloc+0x2e>
				break;
			}
		}
	}

	return -EAGAIN;
   267b8:	f06f 000a 	mvn.w	r0, #10
}
   267bc:	b005      	add	sp, #20
   267be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	__ASSERT(!(arch_is_in_isr() && timeout != K_NO_WAIT), "");
   267c2:	490c      	ldr	r1, [pc, #48]	; (267f4 <k_mem_pool_alloc+0xc0>)
   267c4:	2337      	movs	r3, #55	; 0x37
   267c6:	4a0c      	ldr	r2, [pc, #48]	; (267f8 <k_mem_pool_alloc+0xc4>)
   267c8:	480c      	ldr	r0, [pc, #48]	; (267fc <k_mem_pool_alloc+0xc8>)
   267ca:	f006 fd3e 	bl	2d24a <printk>
   267ce:	480c      	ldr	r0, [pc, #48]	; (26800 <k_mem_pool_alloc+0xcc>)
   267d0:	f006 fd3b 	bl	2d24a <printk>
   267d4:	2137      	movs	r1, #55	; 0x37
   267d6:	4808      	ldr	r0, [pc, #32]	; (267f8 <k_mem_pool_alloc+0xc4>)
   267d8:	f006 fd7d 	bl	2d2d6 <assert_post_action>
	if (timeout > 0) {
   267dc:	2c00      	cmp	r4, #0
   267de:	ddb6      	ble.n	2674e <k_mem_pool_alloc+0x1a>
   267e0:	f008 fcfb 	bl	2f1da <z_impl_k_uptime_get>
		end = k_uptime_get() + timeout;
   267e4:	eb10 0804 	adds.w	r8, r0, r4
   267e8:	e7b3      	b.n	26752 <k_mem_pool_alloc+0x1e>
   267ea:	bf00      	nop
   267ec:	2003b834 	.word	0x2003b834
   267f0:	b6db6db7 	.word	0xb6db6db7
   267f4:	0003482e 	.word	0x0003482e
   267f8:	000347f0 	.word	0x000347f0
   267fc:	000311a3 	.word	0x000311a3
   26800:	00033242 	.word	0x00033242

00026804 <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
   26804:	b570      	push	{r4, r5, r6, lr}
   26806:	7804      	ldrb	r4, [r0, #0]
	int need_sched = 0;
	struct k_mem_pool *p = get_pool(id->pool);

	z_sys_mem_pool_block_free(&p->base, id->level, id->block);
   26808:	6802      	ldr	r2, [r0, #0]
   2680a:	7841      	ldrb	r1, [r0, #1]
   2680c:	4d24      	ldr	r5, [pc, #144]	; (268a0 <k_mem_pool_free_id+0x9c>)
   2680e:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   26812:	00a4      	lsls	r4, r4, #2
   26814:	0b12      	lsrs	r2, r2, #12
   26816:	f001 010f 	and.w	r1, r1, #15
   2681a:	1928      	adds	r0, r5, r4
   2681c:	f7f0 fed4 	bl	175c8 <z_sys_mem_pool_block_free>
   26820:	f04f 0320 	mov.w	r3, #32
   26824:	f3ef 8611 	mrs	r6, BASEPRI
   26828:	f383 8811 	msr	BASEPRI, r3
   2682c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26830:	481c      	ldr	r0, [pc, #112]	; (268a4 <k_mem_pool_free_id+0xa0>)
   26832:	f001 ff59 	bl	286e8 <z_spin_lock_valid>
   26836:	b968      	cbnz	r0, 26854 <k_mem_pool_free_id+0x50>
   26838:	234a      	movs	r3, #74	; 0x4a
   2683a:	4a1b      	ldr	r2, [pc, #108]	; (268a8 <k_mem_pool_free_id+0xa4>)
   2683c:	491b      	ldr	r1, [pc, #108]	; (268ac <k_mem_pool_free_id+0xa8>)
   2683e:	481c      	ldr	r0, [pc, #112]	; (268b0 <k_mem_pool_free_id+0xac>)
   26840:	f006 fd03 	bl	2d24a <printk>
   26844:	4917      	ldr	r1, [pc, #92]	; (268a4 <k_mem_pool_free_id+0xa0>)
   26846:	481b      	ldr	r0, [pc, #108]	; (268b4 <k_mem_pool_free_id+0xb0>)
   26848:	f006 fcff 	bl	2d24a <printk>
   2684c:	214a      	movs	r1, #74	; 0x4a
   2684e:	4816      	ldr	r0, [pc, #88]	; (268a8 <k_mem_pool_free_id+0xa4>)
   26850:	f006 fd41 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   26854:	4813      	ldr	r0, [pc, #76]	; (268a4 <k_mem_pool_free_id+0xa0>)
   26856:	f001 ff65 	bl	28724 <z_spin_lock_set_owner>
	 * is unsynchronized.  Maybe we want to put the lock into the
	 * wait_q instead and make the API safe?)
	 */
	k_spinlock_key_t key = k_spin_lock(&lock);

	need_sched = z_unpend_all(&p->wait_q);
   2685a:	f104 0014 	add.w	r0, r4, #20
   2685e:	4428      	add	r0, r5
   26860:	f008 fc12 	bl	2f088 <z_unpend_all>

	if (need_sched != 0) {
   26864:	b128      	cbz	r0, 26872 <k_mem_pool_free_id+0x6e>
		z_reschedule(&lock, key);
   26866:	4631      	mov	r1, r6
	} else {
		k_spin_unlock(&lock, key);
	}
}
   26868:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   2686c:	480d      	ldr	r0, [pc, #52]	; (268a4 <k_mem_pool_free_id+0xa0>)
   2686e:	f000 bdbd 	b.w	273ec <z_reschedule>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26872:	480c      	ldr	r0, [pc, #48]	; (268a4 <k_mem_pool_free_id+0xa0>)
   26874:	f001 ff46 	bl	28704 <z_spin_unlock_valid>
   26878:	b968      	cbnz	r0, 26896 <k_mem_pool_free_id+0x92>
   2687a:	235d      	movs	r3, #93	; 0x5d
   2687c:	4a0a      	ldr	r2, [pc, #40]	; (268a8 <k_mem_pool_free_id+0xa4>)
   2687e:	490e      	ldr	r1, [pc, #56]	; (268b8 <k_mem_pool_free_id+0xb4>)
   26880:	480b      	ldr	r0, [pc, #44]	; (268b0 <k_mem_pool_free_id+0xac>)
   26882:	f006 fce2 	bl	2d24a <printk>
   26886:	4907      	ldr	r1, [pc, #28]	; (268a4 <k_mem_pool_free_id+0xa0>)
   26888:	480c      	ldr	r0, [pc, #48]	; (268bc <k_mem_pool_free_id+0xb8>)
   2688a:	f006 fcde 	bl	2d24a <printk>
   2688e:	215d      	movs	r1, #93	; 0x5d
   26890:	4805      	ldr	r0, [pc, #20]	; (268a8 <k_mem_pool_free_id+0xa4>)
   26892:	f006 fd20 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   26896:	f386 8811 	msr	BASEPRI, r6
   2689a:	f3bf 8f6f 	isb	sy
}
   2689e:	bd70      	pop	{r4, r5, r6, pc}
   268a0:	2003b834 	.word	0x2003b834
   268a4:	2002d2e0 	.word	0x2002d2e0
   268a8:	00031168 	.word	0x00031168
   268ac:	0003118e 	.word	0x0003118e
   268b0:	000311a3 	.word	0x000311a3
   268b4:	000311c0 	.word	0x000311c0
   268b8:	00031202 	.word	0x00031202
   268bc:	00031219 	.word	0x00031219

000268c0 <k_malloc>:
		  CONFIG_HEAP_MEM_POOL_SIZE, 1, 4);
#define _HEAP_MEM_POOL (&_heap_mem_pool)

void *k_malloc(size_t size)
{
	return k_mem_pool_malloc(_HEAP_MEM_POOL, size);
   268c0:	4601      	mov	r1, r0
   268c2:	4801      	ldr	r0, [pc, #4]	; (268c8 <k_malloc+0x8>)
   268c4:	f008 bb64 	b.w	2ef90 <k_mem_pool_malloc>
   268c8:	2003b834 	.word	0x2003b834

000268cc <z_thread_malloc>:
#else
#define _HEAP_MEM_POOL	NULL
#endif

void *z_thread_malloc(size_t size)
{
   268cc:	b510      	push	{r4, lr}
   268ce:	4604      	mov	r4, r0
	void *ret;
	struct k_mem_pool *pool;

	if (k_is_in_isr()) {
   268d0:	f008 fc00 	bl	2f0d4 <k_is_in_isr>
   268d4:	b948      	cbnz	r0, 268ea <z_thread_malloc+0x1e>
		pool = _HEAP_MEM_POOL;
	} else {
		pool = _current->resource_pool;
   268d6:	4b06      	ldr	r3, [pc, #24]	; (268f0 <z_thread_malloc+0x24>)
   268d8:	689b      	ldr	r3, [r3, #8]
   268da:	6e1b      	ldr	r3, [r3, #96]	; 0x60
	}

	if (pool) {
   268dc:	b13b      	cbz	r3, 268ee <z_thread_malloc+0x22>
		ret = k_mem_pool_malloc(pool, size);
   268de:	4621      	mov	r1, r4
	} else {
		ret = NULL;
	}

	return ret;
}
   268e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ret = k_mem_pool_malloc(pool, size);
   268e4:	4618      	mov	r0, r3
   268e6:	f008 bb53 	b.w	2ef90 <k_mem_pool_malloc>
		pool = _HEAP_MEM_POOL;
   268ea:	4b02      	ldr	r3, [pc, #8]	; (268f4 <z_thread_malloc+0x28>)
   268ec:	e7f7      	b.n	268de <z_thread_malloc+0x12>
}
   268ee:	bd10      	pop	{r4, pc}
   268f0:	2002d2e8 	.word	0x2002d2e8
   268f4:	2003b834 	.word	0x2003b834

000268f8 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, void *data, s32_t timeout)
{
   268f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   268fc:	4604      	mov	r4, r0
   268fe:	4688      	mov	r8, r1
   26900:	4616      	mov	r6, r2
   26902:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr() || timeout == K_NO_WAIT, "");
   26906:	b16b      	cbz	r3, 26924 <z_impl_k_msgq_put+0x2c>
   26908:	b162      	cbz	r2, 26924 <z_impl_k_msgq_put+0x2c>
   2690a:	4941      	ldr	r1, [pc, #260]	; (26a10 <z_impl_k_msgq_put+0x118>)
   2690c:	2376      	movs	r3, #118	; 0x76
   2690e:	4a41      	ldr	r2, [pc, #260]	; (26a14 <z_impl_k_msgq_put+0x11c>)
   26910:	4841      	ldr	r0, [pc, #260]	; (26a18 <z_impl_k_msgq_put+0x120>)
   26912:	f006 fc9a 	bl	2d24a <printk>
   26916:	4841      	ldr	r0, [pc, #260]	; (26a1c <z_impl_k_msgq_put+0x124>)
   26918:	f006 fc97 	bl	2d24a <printk>
   2691c:	2176      	movs	r1, #118	; 0x76
   2691e:	483d      	ldr	r0, [pc, #244]	; (26a14 <z_impl_k_msgq_put+0x11c>)
   26920:	f006 fcd9 	bl	2d2d6 <assert_post_action>

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
   26924:	f104 0508 	add.w	r5, r4, #8
	__asm__ volatile(
   26928:	f04f 0320 	mov.w	r3, #32
   2692c:	f3ef 8711 	mrs	r7, BASEPRI
   26930:	f383 8811 	msr	BASEPRI, r3
   26934:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26938:	4628      	mov	r0, r5
   2693a:	f001 fed5 	bl	286e8 <z_spin_lock_valid>
   2693e:	b968      	cbnz	r0, 2695c <z_impl_k_msgq_put+0x64>
   26940:	234a      	movs	r3, #74	; 0x4a
   26942:	4a37      	ldr	r2, [pc, #220]	; (26a20 <z_impl_k_msgq_put+0x128>)
   26944:	4937      	ldr	r1, [pc, #220]	; (26a24 <z_impl_k_msgq_put+0x12c>)
   26946:	4834      	ldr	r0, [pc, #208]	; (26a18 <z_impl_k_msgq_put+0x120>)
   26948:	f006 fc7f 	bl	2d24a <printk>
   2694c:	4629      	mov	r1, r5
   2694e:	4836      	ldr	r0, [pc, #216]	; (26a28 <z_impl_k_msgq_put+0x130>)
   26950:	f006 fc7b 	bl	2d24a <printk>
   26954:	214a      	movs	r1, #74	; 0x4a
   26956:	4832      	ldr	r0, [pc, #200]	; (26a20 <z_impl_k_msgq_put+0x128>)
   26958:	f006 fcbd 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   2695c:	4628      	mov	r0, r5
   2695e:	f001 fee1 	bl	28724 <z_spin_lock_set_owner>

	if (msgq->used_msgs < msgq->max_msgs) {
   26962:	6a62      	ldr	r2, [r4, #36]	; 0x24
   26964:	6923      	ldr	r3, [r4, #16]
   26966:	429a      	cmp	r2, r3
   26968:	d242      	bcs.n	269f0 <z_impl_k_msgq_put+0xf8>
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   2696a:	4620      	mov	r0, r4
   2696c:	f001 fb9e 	bl	280ac <z_unpend_first_thread>
		if (pending_thread != NULL) {
   26970:	68e2      	ldr	r2, [r4, #12]
   26972:	4606      	mov	r6, r0
   26974:	4641      	mov	r1, r8
   26976:	b1a0      	cbz	r0, 269a2 <z_impl_k_msgq_put+0xaa>
   26978:	6940      	ldr	r0, [r0, #20]
   2697a:	f008 fceb 	bl	2f354 <memcpy>
   2697e:	2300      	movs	r3, #0
   26980:	66b3      	str	r3, [r6, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   26982:	7b73      	ldrb	r3, [r6, #13]
   26984:	06db      	lsls	r3, r3, #27
   26986:	d104      	bne.n	26992 <z_impl_k_msgq_put+0x9a>
	if (z_is_thread_ready(thread)) {
   26988:	69b3      	ldr	r3, [r6, #24]
   2698a:	b913      	cbnz	r3, 26992 <z_impl_k_msgq_put+0x9a>
		z_add_thread_to_ready_q(thread);
   2698c:	4630      	mov	r0, r6
   2698e:	f000 ff17 	bl	277c0 <z_add_thread_to_ready_q>
			(void)memcpy(pending_thread->base.swap_data, data,
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
   26992:	4639      	mov	r1, r7
   26994:	4628      	mov	r0, r5
   26996:	f000 fd29 	bl	273ec <z_reschedule>
			return 0;
   2699a:	2400      	movs	r4, #0
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   2699c:	4620      	mov	r0, r4
   2699e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   269a2:	6a20      	ldr	r0, [r4, #32]
   269a4:	f008 fcd6 	bl	2f354 <memcpy>
			msgq->write_ptr += msgq->msg_size;
   269a8:	6a23      	ldr	r3, [r4, #32]
   269aa:	68e2      	ldr	r2, [r4, #12]
   269ac:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   269ae:	69a2      	ldr	r2, [r4, #24]
			msgq->write_ptr += msgq->msg_size;
   269b0:	6223      	str	r3, [r4, #32]
			if (msgq->write_ptr == msgq->buffer_end) {
   269b2:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   269b4:	bf04      	itt	eq
   269b6:	6963      	ldreq	r3, [r4, #20]
   269b8:	6223      	streq	r3, [r4, #32]
			msgq->used_msgs++;
   269ba:	6a63      	ldr	r3, [r4, #36]	; 0x24
   269bc:	3301      	adds	r3, #1
   269be:	6263      	str	r3, [r4, #36]	; 0x24
		result = 0;
   269c0:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   269c2:	4628      	mov	r0, r5
   269c4:	f001 fe9e 	bl	28704 <z_spin_unlock_valid>
   269c8:	b968      	cbnz	r0, 269e6 <z_impl_k_msgq_put+0xee>
   269ca:	235d      	movs	r3, #93	; 0x5d
   269cc:	4a14      	ldr	r2, [pc, #80]	; (26a20 <z_impl_k_msgq_put+0x128>)
   269ce:	4917      	ldr	r1, [pc, #92]	; (26a2c <z_impl_k_msgq_put+0x134>)
   269d0:	4811      	ldr	r0, [pc, #68]	; (26a18 <z_impl_k_msgq_put+0x120>)
   269d2:	f006 fc3a 	bl	2d24a <printk>
   269d6:	4629      	mov	r1, r5
   269d8:	4815      	ldr	r0, [pc, #84]	; (26a30 <z_impl_k_msgq_put+0x138>)
   269da:	f006 fc36 	bl	2d24a <printk>
   269de:	215d      	movs	r1, #93	; 0x5d
   269e0:	480f      	ldr	r0, [pc, #60]	; (26a20 <z_impl_k_msgq_put+0x128>)
   269e2:	f006 fc78 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   269e6:	f387 8811 	msr	BASEPRI, r7
   269ea:	f3bf 8f6f 	isb	sy
	return result;
   269ee:	e7d5      	b.n	2699c <z_impl_k_msgq_put+0xa4>
	} else if (timeout == K_NO_WAIT) {
   269f0:	b15e      	cbz	r6, 26a0a <z_impl_k_msgq_put+0x112>
		_current->base.swap_data = data;
   269f2:	4b10      	ldr	r3, [pc, #64]	; (26a34 <z_impl_k_msgq_put+0x13c>)
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   269f4:	4622      	mov	r2, r4
		_current->base.swap_data = data;
   269f6:	689b      	ldr	r3, [r3, #8]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   269f8:	4639      	mov	r1, r7
		_current->base.swap_data = data;
   269fa:	f8c3 8014 	str.w	r8, [r3, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   269fe:	4628      	mov	r0, r5
   26a00:	4633      	mov	r3, r6
}
   26a02:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   26a06:	f001 ba95 	b.w	27f34 <z_pend_curr>
		result = -ENOMSG;
   26a0a:	f06f 0422 	mvn.w	r4, #34	; 0x22
   26a0e:	e7d8      	b.n	269c2 <z_impl_k_msgq_put+0xca>
   26a10:	00034874 	.word	0x00034874
   26a14:	00034852 	.word	0x00034852
   26a18:	000311a3 	.word	0x000311a3
   26a1c:	00033242 	.word	0x00033242
   26a20:	00031168 	.word	0x00031168
   26a24:	0003118e 	.word	0x0003118e
   26a28:	000311c0 	.word	0x000311c0
   26a2c:	00031202 	.word	0x00031202
   26a30:	00031219 	.word	0x00031219
   26a34:	2002d2e8 	.word	0x2002d2e8

00026a38 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, s32_t timeout)
{
   26a38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   26a3c:	4604      	mov	r4, r0
   26a3e:	4688      	mov	r8, r1
   26a40:	4615      	mov	r5, r2
   26a42:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr() || timeout == K_NO_WAIT, "");
   26a46:	b16b      	cbz	r3, 26a64 <z_impl_k_msgq_get+0x2c>
   26a48:	b162      	cbz	r2, 26a64 <z_impl_k_msgq_get+0x2c>
   26a4a:	4947      	ldr	r1, [pc, #284]	; (26b68 <z_impl_k_msgq_get+0x130>)
   26a4c:	23c1      	movs	r3, #193	; 0xc1
   26a4e:	4a47      	ldr	r2, [pc, #284]	; (26b6c <z_impl_k_msgq_get+0x134>)
   26a50:	4847      	ldr	r0, [pc, #284]	; (26b70 <z_impl_k_msgq_get+0x138>)
   26a52:	f006 fbfa 	bl	2d24a <printk>
   26a56:	4847      	ldr	r0, [pc, #284]	; (26b74 <z_impl_k_msgq_get+0x13c>)
   26a58:	f006 fbf7 	bl	2d24a <printk>
   26a5c:	21c1      	movs	r1, #193	; 0xc1
   26a5e:	4843      	ldr	r0, [pc, #268]	; (26b6c <z_impl_k_msgq_get+0x134>)
   26a60:	f006 fc39 	bl	2d2d6 <assert_post_action>

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
   26a64:	f104 0608 	add.w	r6, r4, #8
	__asm__ volatile(
   26a68:	f04f 0320 	mov.w	r3, #32
   26a6c:	f3ef 8711 	mrs	r7, BASEPRI
   26a70:	f383 8811 	msr	BASEPRI, r3
   26a74:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26a78:	4630      	mov	r0, r6
   26a7a:	f001 fe35 	bl	286e8 <z_spin_lock_valid>
   26a7e:	b968      	cbnz	r0, 26a9c <z_impl_k_msgq_get+0x64>
   26a80:	234a      	movs	r3, #74	; 0x4a
   26a82:	4a3d      	ldr	r2, [pc, #244]	; (26b78 <z_impl_k_msgq_get+0x140>)
   26a84:	493d      	ldr	r1, [pc, #244]	; (26b7c <z_impl_k_msgq_get+0x144>)
   26a86:	483a      	ldr	r0, [pc, #232]	; (26b70 <z_impl_k_msgq_get+0x138>)
   26a88:	f006 fbdf 	bl	2d24a <printk>
   26a8c:	4631      	mov	r1, r6
   26a8e:	483c      	ldr	r0, [pc, #240]	; (26b80 <z_impl_k_msgq_get+0x148>)
   26a90:	f006 fbdb 	bl	2d24a <printk>
   26a94:	214a      	movs	r1, #74	; 0x4a
   26a96:	4838      	ldr	r0, [pc, #224]	; (26b78 <z_impl_k_msgq_get+0x140>)
   26a98:	f006 fc1d 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   26a9c:	4630      	mov	r0, r6
   26a9e:	f001 fe41 	bl	28724 <z_spin_lock_set_owner>

	if (msgq->used_msgs > 0) {
   26aa2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   26aa4:	2b00      	cmp	r3, #0
   26aa6:	d039      	beq.n	26b1c <z_impl_k_msgq_get+0xe4>
   26aa8:	68e2      	ldr	r2, [r4, #12]
   26aaa:	69e1      	ldr	r1, [r4, #28]
   26aac:	4640      	mov	r0, r8
   26aae:	f008 fc51 	bl	2f354 <memcpy>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
   26ab2:	69e3      	ldr	r3, [r4, #28]
   26ab4:	68e2      	ldr	r2, [r4, #12]
			msgq->read_ptr = msgq->buffer_start;
		}
		msgq->used_msgs--;

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   26ab6:	4620      	mov	r0, r4
		msgq->read_ptr += msgq->msg_size;
   26ab8:	4413      	add	r3, r2
		if (msgq->read_ptr == msgq->buffer_end) {
   26aba:	69a2      	ldr	r2, [r4, #24]
		msgq->read_ptr += msgq->msg_size;
   26abc:	61e3      	str	r3, [r4, #28]
		if (msgq->read_ptr == msgq->buffer_end) {
   26abe:	4293      	cmp	r3, r2
			msgq->read_ptr = msgq->buffer_start;
   26ac0:	bf04      	itt	eq
   26ac2:	6963      	ldreq	r3, [r4, #20]
   26ac4:	61e3      	streq	r3, [r4, #28]
		msgq->used_msgs--;
   26ac6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   26ac8:	3b01      	subs	r3, #1
   26aca:	6263      	str	r3, [r4, #36]	; 0x24
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   26acc:	f001 faee 	bl	280ac <z_unpend_first_thread>
		if (pending_thread != NULL) {
   26ad0:	4605      	mov	r5, r0
   26ad2:	2800      	cmp	r0, #0
   26ad4:	d031      	beq.n	26b3a <z_impl_k_msgq_get+0x102>
   26ad6:	68e2      	ldr	r2, [r4, #12]
   26ad8:	6941      	ldr	r1, [r0, #20]
   26ada:	6a20      	ldr	r0, [r4, #32]
   26adc:	f008 fc3a 	bl	2f354 <memcpy>
			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
   26ae0:	6a23      	ldr	r3, [r4, #32]
   26ae2:	68e2      	ldr	r2, [r4, #12]
   26ae4:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   26ae6:	69a2      	ldr	r2, [r4, #24]
			msgq->write_ptr += msgq->msg_size;
   26ae8:	6223      	str	r3, [r4, #32]
			if (msgq->write_ptr == msgq->buffer_end) {
   26aea:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   26aec:	bf04      	itt	eq
   26aee:	6963      	ldreq	r3, [r4, #20]
   26af0:	6223      	streq	r3, [r4, #32]
			}
			msgq->used_msgs++;
   26af2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   26af4:	3301      	adds	r3, #1
   26af6:	6263      	str	r3, [r4, #36]	; 0x24
   26af8:	2300      	movs	r3, #0
   26afa:	66ab      	str	r3, [r5, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   26afc:	7b6b      	ldrb	r3, [r5, #13]
   26afe:	06db      	lsls	r3, r3, #27
   26b00:	d104      	bne.n	26b0c <z_impl_k_msgq_get+0xd4>
	if (z_is_thread_ready(thread)) {
   26b02:	69ab      	ldr	r3, [r5, #24]
   26b04:	b913      	cbnz	r3, 26b0c <z_impl_k_msgq_get+0xd4>
		z_add_thread_to_ready_q(thread);
   26b06:	4628      	mov	r0, r5
   26b08:	f000 fe5a 	bl	277c0 <z_add_thread_to_ready_q>

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
   26b0c:	4639      	mov	r1, r7
   26b0e:	4630      	mov	r0, r6
   26b10:	f000 fc6c 	bl	273ec <z_reschedule>
			return 0;
   26b14:	2500      	movs	r5, #0
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   26b16:	4628      	mov	r0, r5
   26b18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (timeout == K_NO_WAIT) {
   26b1c:	b15d      	cbz	r5, 26b36 <z_impl_k_msgq_get+0xfe>
		_current->base.swap_data = data;
   26b1e:	4b19      	ldr	r3, [pc, #100]	; (26b84 <z_impl_k_msgq_get+0x14c>)
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   26b20:	4622      	mov	r2, r4
		_current->base.swap_data = data;
   26b22:	689b      	ldr	r3, [r3, #8]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   26b24:	4639      	mov	r1, r7
		_current->base.swap_data = data;
   26b26:	f8c3 8014 	str.w	r8, [r3, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   26b2a:	4630      	mov	r0, r6
   26b2c:	462b      	mov	r3, r5
}
   26b2e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   26b32:	f001 b9ff 	b.w	27f34 <z_pend_curr>
		result = -ENOMSG;
   26b36:	f06f 0522 	mvn.w	r5, #34	; 0x22
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26b3a:	4630      	mov	r0, r6
   26b3c:	f001 fde2 	bl	28704 <z_spin_unlock_valid>
   26b40:	b968      	cbnz	r0, 26b5e <z_impl_k_msgq_get+0x126>
   26b42:	235d      	movs	r3, #93	; 0x5d
   26b44:	4a0c      	ldr	r2, [pc, #48]	; (26b78 <z_impl_k_msgq_get+0x140>)
   26b46:	4910      	ldr	r1, [pc, #64]	; (26b88 <z_impl_k_msgq_get+0x150>)
   26b48:	4809      	ldr	r0, [pc, #36]	; (26b70 <z_impl_k_msgq_get+0x138>)
   26b4a:	f006 fb7e 	bl	2d24a <printk>
   26b4e:	4631      	mov	r1, r6
   26b50:	480e      	ldr	r0, [pc, #56]	; (26b8c <z_impl_k_msgq_get+0x154>)
   26b52:	f006 fb7a 	bl	2d24a <printk>
   26b56:	215d      	movs	r1, #93	; 0x5d
   26b58:	4807      	ldr	r0, [pc, #28]	; (26b78 <z_impl_k_msgq_get+0x140>)
   26b5a:	f006 fbbc 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   26b5e:	f387 8811 	msr	BASEPRI, r7
   26b62:	f3bf 8f6f 	isb	sy
	return result;
   26b66:	e7d6      	b.n	26b16 <z_impl_k_msgq_get+0xde>
   26b68:	00034874 	.word	0x00034874
   26b6c:	00034852 	.word	0x00034852
   26b70:	000311a3 	.word	0x000311a3
   26b74:	00033242 	.word	0x00033242
   26b78:	00031168 	.word	0x00031168
   26b7c:	0003118e 	.word	0x0003118e
   26b80:	000311c0 	.word	0x000311c0
   26b84:	2002d2e8 	.word	0x2002d2e8
   26b88:	00031202 	.word	0x00031202
   26b8c:	00031219 	.word	0x00031219

00026b90 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, s32_t timeout)
{
   26b90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   26b92:	4604      	mov	r4, r0
   26b94:	460e      	mov	r6, r1
	__asm__ volatile(
   26b96:	f04f 0320 	mov.w	r3, #32
   26b9a:	f3ef 8511 	mrs	r5, BASEPRI
   26b9e:	f383 8811 	msr	BASEPRI, r3
   26ba2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26ba6:	4861      	ldr	r0, [pc, #388]	; (26d2c <z_impl_k_mutex_lock+0x19c>)
   26ba8:	f001 fd9e 	bl	286e8 <z_spin_lock_valid>
   26bac:	b968      	cbnz	r0, 26bca <z_impl_k_mutex_lock+0x3a>
   26bae:	234a      	movs	r3, #74	; 0x4a
   26bb0:	4a5f      	ldr	r2, [pc, #380]	; (26d30 <z_impl_k_mutex_lock+0x1a0>)
   26bb2:	4960      	ldr	r1, [pc, #384]	; (26d34 <z_impl_k_mutex_lock+0x1a4>)
   26bb4:	4860      	ldr	r0, [pc, #384]	; (26d38 <z_impl_k_mutex_lock+0x1a8>)
   26bb6:	f006 fb48 	bl	2d24a <printk>
   26bba:	495c      	ldr	r1, [pc, #368]	; (26d2c <z_impl_k_mutex_lock+0x19c>)
   26bbc:	485f      	ldr	r0, [pc, #380]	; (26d3c <z_impl_k_mutex_lock+0x1ac>)
   26bbe:	f006 fb44 	bl	2d24a <printk>
   26bc2:	214a      	movs	r1, #74	; 0x4a
   26bc4:	485a      	ldr	r0, [pc, #360]	; (26d30 <z_impl_k_mutex_lock+0x1a0>)
   26bc6:	f006 fb86 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   26bca:	4858      	ldr	r0, [pc, #352]	; (26d2c <z_impl_k_mutex_lock+0x19c>)
   26bcc:	f001 fdaa 	bl	28724 <z_spin_lock_set_owner>
	bool resched = false;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   26bd0:	68e3      	ldr	r3, [r4, #12]
   26bd2:	4a5b      	ldr	r2, [pc, #364]	; (26d40 <z_impl_k_mutex_lock+0x1b0>)
   26bd4:	b1f3      	cbz	r3, 26c14 <z_impl_k_mutex_lock+0x84>
   26bd6:	68a0      	ldr	r0, [r4, #8]
   26bd8:	6891      	ldr	r1, [r2, #8]
   26bda:	4288      	cmp	r0, r1
   26bdc:	d03a      	beq.n	26c54 <z_impl_k_mutex_lock+0xc4>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(timeout == (s32_t)K_NO_WAIT)) {
   26bde:	2e00      	cmp	r6, #0
   26be0:	d13a      	bne.n	26c58 <z_impl_k_mutex_lock+0xc8>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26be2:	4852      	ldr	r0, [pc, #328]	; (26d2c <z_impl_k_mutex_lock+0x19c>)
   26be4:	f001 fd8e 	bl	28704 <z_spin_unlock_valid>
   26be8:	b968      	cbnz	r0, 26c06 <z_impl_k_mutex_lock+0x76>
   26bea:	235d      	movs	r3, #93	; 0x5d
   26bec:	4a50      	ldr	r2, [pc, #320]	; (26d30 <z_impl_k_mutex_lock+0x1a0>)
   26bee:	4955      	ldr	r1, [pc, #340]	; (26d44 <z_impl_k_mutex_lock+0x1b4>)
   26bf0:	4851      	ldr	r0, [pc, #324]	; (26d38 <z_impl_k_mutex_lock+0x1a8>)
   26bf2:	f006 fb2a 	bl	2d24a <printk>
   26bf6:	494d      	ldr	r1, [pc, #308]	; (26d2c <z_impl_k_mutex_lock+0x19c>)
   26bf8:	4853      	ldr	r0, [pc, #332]	; (26d48 <z_impl_k_mutex_lock+0x1b8>)
   26bfa:	f006 fb26 	bl	2d24a <printk>
   26bfe:	215d      	movs	r1, #93	; 0x5d
   26c00:	484b      	ldr	r0, [pc, #300]	; (26d30 <z_impl_k_mutex_lock+0x1a0>)
   26c02:	f006 fb68 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   26c06:	f385 8811 	msr	BASEPRI, r5
   26c0a:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
   26c0e:	f06f 000f 	mvn.w	r0, #15
   26c12:	e01e      	b.n	26c52 <z_impl_k_mutex_lock+0xc2>
					_current->base.prio :
   26c14:	6891      	ldr	r1, [r2, #8]
   26c16:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
   26c1a:	3301      	adds	r3, #1
   26c1c:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   26c1e:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   26c20:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
   26c22:	60a3      	str	r3, [r4, #8]
   26c24:	4841      	ldr	r0, [pc, #260]	; (26d2c <z_impl_k_mutex_lock+0x19c>)
   26c26:	f001 fd6d 	bl	28704 <z_spin_unlock_valid>
   26c2a:	b968      	cbnz	r0, 26c48 <z_impl_k_mutex_lock+0xb8>
   26c2c:	235d      	movs	r3, #93	; 0x5d
   26c2e:	4a40      	ldr	r2, [pc, #256]	; (26d30 <z_impl_k_mutex_lock+0x1a0>)
   26c30:	4944      	ldr	r1, [pc, #272]	; (26d44 <z_impl_k_mutex_lock+0x1b4>)
   26c32:	4841      	ldr	r0, [pc, #260]	; (26d38 <z_impl_k_mutex_lock+0x1a8>)
   26c34:	f006 fb09 	bl	2d24a <printk>
   26c38:	493c      	ldr	r1, [pc, #240]	; (26d2c <z_impl_k_mutex_lock+0x19c>)
   26c3a:	4843      	ldr	r0, [pc, #268]	; (26d48 <z_impl_k_mutex_lock+0x1b8>)
   26c3c:	f006 fb05 	bl	2d24a <printk>
   26c40:	215d      	movs	r1, #93	; 0x5d
   26c42:	483b      	ldr	r0, [pc, #236]	; (26d30 <z_impl_k_mutex_lock+0x1a0>)
   26c44:	f006 fb47 	bl	2d2d6 <assert_post_action>
   26c48:	f385 8811 	msr	BASEPRI, r5
   26c4c:	f3bf 8f6f 	isb	sy
		return 0;
   26c50:	2000      	movs	r0, #0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
   26c52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					_current->base.prio :
   26c54:	6921      	ldr	r1, [r4, #16]
   26c56:	e7e0      	b.n	26c1a <z_impl_k_mutex_lock+0x8a>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   26c58:	f990 300e 	ldrsb.w	r3, [r0, #14]
   26c5c:	f991 100e 	ldrsb.w	r1, [r1, #14]
   26c60:	4299      	cmp	r1, r3
   26c62:	bfa8      	it	ge
   26c64:	4619      	movge	r1, r3
   26c66:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   26c6a:	4299      	cmp	r1, r3
   26c6c:	da40      	bge.n	26cf0 <z_impl_k_mutex_lock+0x160>
		return z_set_prio(mutex->owner, new_prio);
   26c6e:	f001 f98f 	bl	27f90 <z_set_prio>
   26c72:	4607      	mov	r7, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   26c74:	4633      	mov	r3, r6
   26c76:	4622      	mov	r2, r4
   26c78:	4629      	mov	r1, r5
   26c7a:	482c      	ldr	r0, [pc, #176]	; (26d2c <z_impl_k_mutex_lock+0x19c>)
   26c7c:	f001 f95a 	bl	27f34 <z_pend_curr>
	if (got_mutex == 0) {
   26c80:	2800      	cmp	r0, #0
   26c82:	d0e6      	beq.n	26c52 <z_impl_k_mutex_lock+0xc2>
	__asm__ volatile(
   26c84:	f04f 0320 	mov.w	r3, #32
   26c88:	f3ef 8511 	mrs	r5, BASEPRI
   26c8c:	f383 8811 	msr	BASEPRI, r3
   26c90:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26c94:	4825      	ldr	r0, [pc, #148]	; (26d2c <z_impl_k_mutex_lock+0x19c>)
   26c96:	f001 fd27 	bl	286e8 <z_spin_lock_valid>
   26c9a:	b968      	cbnz	r0, 26cb8 <z_impl_k_mutex_lock+0x128>
   26c9c:	234a      	movs	r3, #74	; 0x4a
   26c9e:	4a24      	ldr	r2, [pc, #144]	; (26d30 <z_impl_k_mutex_lock+0x1a0>)
   26ca0:	4924      	ldr	r1, [pc, #144]	; (26d34 <z_impl_k_mutex_lock+0x1a4>)
   26ca2:	4825      	ldr	r0, [pc, #148]	; (26d38 <z_impl_k_mutex_lock+0x1a8>)
   26ca4:	f006 fad1 	bl	2d24a <printk>
   26ca8:	4920      	ldr	r1, [pc, #128]	; (26d2c <z_impl_k_mutex_lock+0x19c>)
   26caa:	4824      	ldr	r0, [pc, #144]	; (26d3c <z_impl_k_mutex_lock+0x1ac>)
   26cac:	f006 facd 	bl	2d24a <printk>
   26cb0:	214a      	movs	r1, #74	; 0x4a
   26cb2:	481f      	ldr	r0, [pc, #124]	; (26d30 <z_impl_k_mutex_lock+0x1a0>)
   26cb4:	f006 fb0f 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   26cb8:	481c      	ldr	r0, [pc, #112]	; (26d2c <z_impl_k_mutex_lock+0x19c>)
   26cba:	f001 fd33 	bl	28724 <z_spin_lock_set_owner>
	return list->head == list;
   26cbe:	6823      	ldr	r3, [r4, #0]
   26cc0:	6921      	ldr	r1, [r4, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   26cc2:	429c      	cmp	r4, r3
   26cc4:	d007      	beq.n	26cd6 <z_impl_k_mutex_lock+0x146>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   26cc6:	b133      	cbz	r3, 26cd6 <z_impl_k_mutex_lock+0x146>
   26cc8:	f993 300e 	ldrsb.w	r3, [r3, #14]
   26ccc:	4299      	cmp	r1, r3
   26cce:	bfa8      	it	ge
   26cd0:	4619      	movge	r1, r3
   26cd2:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   26cd6:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   26cd8:	f990 300e 	ldrsb.w	r3, [r0, #14]
   26cdc:	4299      	cmp	r1, r3
   26cde:	d109      	bne.n	26cf4 <z_impl_k_mutex_lock+0x164>
	if (resched) {
   26ce0:	b16f      	cbz	r7, 26cfe <z_impl_k_mutex_lock+0x16e>
		z_reschedule(&lock, key);
   26ce2:	4629      	mov	r1, r5
   26ce4:	4811      	ldr	r0, [pc, #68]	; (26d2c <z_impl_k_mutex_lock+0x19c>)
   26ce6:	f000 fb81 	bl	273ec <z_reschedule>
	return -EAGAIN;
   26cea:	f06f 000a 	mvn.w	r0, #10
   26cee:	e7b0      	b.n	26c52 <z_impl_k_mutex_lock+0xc2>
	bool resched = false;
   26cf0:	2700      	movs	r7, #0
   26cf2:	e7bf      	b.n	26c74 <z_impl_k_mutex_lock+0xe4>
		return z_set_prio(mutex->owner, new_prio);
   26cf4:	f001 f94c 	bl	27f90 <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   26cf8:	2800      	cmp	r0, #0
   26cfa:	d1f2      	bne.n	26ce2 <z_impl_k_mutex_lock+0x152>
   26cfc:	e7f0      	b.n	26ce0 <z_impl_k_mutex_lock+0x150>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26cfe:	480b      	ldr	r0, [pc, #44]	; (26d2c <z_impl_k_mutex_lock+0x19c>)
   26d00:	f001 fd00 	bl	28704 <z_spin_unlock_valid>
   26d04:	b968      	cbnz	r0, 26d22 <z_impl_k_mutex_lock+0x192>
   26d06:	235d      	movs	r3, #93	; 0x5d
   26d08:	4a09      	ldr	r2, [pc, #36]	; (26d30 <z_impl_k_mutex_lock+0x1a0>)
   26d0a:	490e      	ldr	r1, [pc, #56]	; (26d44 <z_impl_k_mutex_lock+0x1b4>)
   26d0c:	480a      	ldr	r0, [pc, #40]	; (26d38 <z_impl_k_mutex_lock+0x1a8>)
   26d0e:	f006 fa9c 	bl	2d24a <printk>
   26d12:	4906      	ldr	r1, [pc, #24]	; (26d2c <z_impl_k_mutex_lock+0x19c>)
   26d14:	480c      	ldr	r0, [pc, #48]	; (26d48 <z_impl_k_mutex_lock+0x1b8>)
   26d16:	f006 fa98 	bl	2d24a <printk>
   26d1a:	215d      	movs	r1, #93	; 0x5d
   26d1c:	4804      	ldr	r0, [pc, #16]	; (26d30 <z_impl_k_mutex_lock+0x1a0>)
   26d1e:	f006 fada 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   26d22:	f385 8811 	msr	BASEPRI, r5
   26d26:	f3bf 8f6f 	isb	sy
   26d2a:	e7de      	b.n	26cea <z_impl_k_mutex_lock+0x15a>
   26d2c:	2002d2e4 	.word	0x2002d2e4
   26d30:	00031168 	.word	0x00031168
   26d34:	0003118e 	.word	0x0003118e
   26d38:	000311a3 	.word	0x000311a3
   26d3c:	000311c0 	.word	0x000311c0
   26d40:	2002d2e8 	.word	0x2002d2e8
   26d44:	00031202 	.word	0x00031202
   26d48:	00031219 	.word	0x00031219

00026d4c <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   26d4c:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *new_owner;

	CHECKIF(mutex->owner == NULL) {
   26d4e:	6883      	ldr	r3, [r0, #8]
{
   26d50:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   26d52:	2b00      	cmp	r3, #0
   26d54:	f000 8096 	beq.w	26e84 <z_impl_k_mutex_unlock+0x138>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   26d58:	4d4d      	ldr	r5, [pc, #308]	; (26e90 <z_impl_k_mutex_unlock+0x144>)
   26d5a:	68aa      	ldr	r2, [r5, #8]
   26d5c:	4293      	cmp	r3, r2
   26d5e:	f040 8094 	bne.w	26e8a <z_impl_k_mutex_unlock+0x13e>
	 * Attempt to unlock a mutex which is unlocked. mutex->lock_count
	 * cannot be zero if the current thread is equal to mutex->owner,
	 * therefore no underflow check is required. Use assert to catch
	 * undefined behavior.
	 */
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
   26d62:	68c3      	ldr	r3, [r0, #12]
   26d64:	b94b      	cbnz	r3, 26d7a <z_impl_k_mutex_unlock+0x2e>
   26d66:	494b      	ldr	r1, [pc, #300]	; (26e94 <z_impl_k_mutex_unlock+0x148>)
   26d68:	484b      	ldr	r0, [pc, #300]	; (26e98 <z_impl_k_mutex_unlock+0x14c>)
   26d6a:	23e5      	movs	r3, #229	; 0xe5
   26d6c:	4a4b      	ldr	r2, [pc, #300]	; (26e9c <z_impl_k_mutex_unlock+0x150>)
   26d6e:	f006 fa6c 	bl	2d24a <printk>
   26d72:	21e5      	movs	r1, #229	; 0xe5
   26d74:	4849      	ldr	r0, [pc, #292]	; (26e9c <z_impl_k_mutex_unlock+0x150>)
   26d76:	f006 faae 	bl	2d2d6 <assert_post_action>
   26d7a:	f3ef 8305 	mrs	r3, IPSR
}

static inline void z_sched_lock(void)
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
   26d7e:	b173      	cbz	r3, 26d9e <z_impl_k_mutex_unlock+0x52>
   26d80:	4947      	ldr	r1, [pc, #284]	; (26ea0 <z_impl_k_mutex_unlock+0x154>)
   26d82:	f240 130d 	movw	r3, #269	; 0x10d
   26d86:	4a47      	ldr	r2, [pc, #284]	; (26ea4 <z_impl_k_mutex_unlock+0x158>)
   26d88:	4843      	ldr	r0, [pc, #268]	; (26e98 <z_impl_k_mutex_unlock+0x14c>)
   26d8a:	f006 fa5e 	bl	2d24a <printk>
   26d8e:	4846      	ldr	r0, [pc, #280]	; (26ea8 <z_impl_k_mutex_unlock+0x15c>)
   26d90:	f006 fa5b 	bl	2d24a <printk>
   26d94:	f240 110d 	movw	r1, #269	; 0x10d
   26d98:	4842      	ldr	r0, [pc, #264]	; (26ea4 <z_impl_k_mutex_unlock+0x158>)
   26d9a:	f006 fa9c 	bl	2d2d6 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1, "");
   26d9e:	68ab      	ldr	r3, [r5, #8]
   26da0:	7bdb      	ldrb	r3, [r3, #15]
   26da2:	2b01      	cmp	r3, #1
   26da4:	d10e      	bne.n	26dc4 <z_impl_k_mutex_unlock+0x78>
   26da6:	4941      	ldr	r1, [pc, #260]	; (26eac <z_impl_k_mutex_unlock+0x160>)
   26da8:	f44f 7387 	mov.w	r3, #270	; 0x10e
   26dac:	4a3d      	ldr	r2, [pc, #244]	; (26ea4 <z_impl_k_mutex_unlock+0x158>)
   26dae:	483a      	ldr	r0, [pc, #232]	; (26e98 <z_impl_k_mutex_unlock+0x14c>)
   26db0:	f006 fa4b 	bl	2d24a <printk>
   26db4:	483c      	ldr	r0, [pc, #240]	; (26ea8 <z_impl_k_mutex_unlock+0x15c>)
   26db6:	f006 fa48 	bl	2d24a <printk>
   26dba:	f44f 7187 	mov.w	r1, #270	; 0x10e
   26dbe:	4839      	ldr	r0, [pc, #228]	; (26ea4 <z_impl_k_mutex_unlock+0x158>)
   26dc0:	f006 fa89 	bl	2d2d6 <assert_post_action>

	--_current->base.sched_locked;
   26dc4:	68aa      	ldr	r2, [r5, #8]
   26dc6:	7bd3      	ldrb	r3, [r2, #15]
   26dc8:	3b01      	subs	r3, #1
   26dca:	73d3      	strb	r3, [r2, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count - 1U != 0U) {
   26dcc:	68e3      	ldr	r3, [r4, #12]
   26dce:	2b01      	cmp	r3, #1
   26dd0:	d005      	beq.n	26dde <z_impl_k_mutex_unlock+0x92>
		mutex->lock_count--;
   26dd2:	3b01      	subs	r3, #1
   26dd4:	60e3      	str	r3, [r4, #12]
		k_spin_unlock(&lock, key);
	}


k_mutex_unlock_return:
	k_sched_unlock();
   26dd6:	f000 fc77 	bl	276c8 <k_sched_unlock>
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);

	return 0;
   26dda:	2000      	movs	r0, #0
}
   26ddc:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   26dde:	f04f 0320 	mov.w	r3, #32
   26de2:	f3ef 8511 	mrs	r5, BASEPRI
   26de6:	f383 8811 	msr	BASEPRI, r3
   26dea:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26dee:	4830      	ldr	r0, [pc, #192]	; (26eb0 <z_impl_k_mutex_unlock+0x164>)
   26df0:	f001 fc7a 	bl	286e8 <z_spin_lock_valid>
   26df4:	b968      	cbnz	r0, 26e12 <z_impl_k_mutex_unlock+0xc6>
   26df6:	234a      	movs	r3, #74	; 0x4a
   26df8:	4a2e      	ldr	r2, [pc, #184]	; (26eb4 <z_impl_k_mutex_unlock+0x168>)
   26dfa:	492f      	ldr	r1, [pc, #188]	; (26eb8 <z_impl_k_mutex_unlock+0x16c>)
   26dfc:	4826      	ldr	r0, [pc, #152]	; (26e98 <z_impl_k_mutex_unlock+0x14c>)
   26dfe:	f006 fa24 	bl	2d24a <printk>
   26e02:	492b      	ldr	r1, [pc, #172]	; (26eb0 <z_impl_k_mutex_unlock+0x164>)
   26e04:	482d      	ldr	r0, [pc, #180]	; (26ebc <z_impl_k_mutex_unlock+0x170>)
   26e06:	f006 fa20 	bl	2d24a <printk>
   26e0a:	214a      	movs	r1, #74	; 0x4a
   26e0c:	4829      	ldr	r0, [pc, #164]	; (26eb4 <z_impl_k_mutex_unlock+0x168>)
   26e0e:	f006 fa62 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   26e12:	4827      	ldr	r0, [pc, #156]	; (26eb0 <z_impl_k_mutex_unlock+0x164>)
   26e14:	f001 fc86 	bl	28724 <z_spin_lock_set_owner>
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   26e18:	68a0      	ldr	r0, [r4, #8]
   26e1a:	6921      	ldr	r1, [r4, #16]
	if (mutex->owner->base.prio != new_prio) {
   26e1c:	f990 300e 	ldrsb.w	r3, [r0, #14]
   26e20:	4299      	cmp	r1, r3
   26e22:	d001      	beq.n	26e28 <z_impl_k_mutex_unlock+0xdc>
		return z_set_prio(mutex->owner, new_prio);
   26e24:	f001 f8b4 	bl	27f90 <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   26e28:	4620      	mov	r0, r4
   26e2a:	f001 f93f 	bl	280ac <z_unpend_first_thread>
	mutex->owner = new_owner;
   26e2e:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   26e30:	b180      	cbz	r0, 26e54 <z_impl_k_mutex_unlock+0x108>
		mutex->owner_orig_prio = new_owner->base.prio;
   26e32:	f990 200e 	ldrsb.w	r2, [r0, #14]
   26e36:	6122      	str	r2, [r4, #16]
   26e38:	2200      	movs	r2, #0
   26e3a:	6682      	str	r2, [r0, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   26e3c:	7b42      	ldrb	r2, [r0, #13]
   26e3e:	06d2      	lsls	r2, r2, #27
   26e40:	d103      	bne.n	26e4a <z_impl_k_mutex_unlock+0xfe>
	if (z_is_thread_ready(thread)) {
   26e42:	6983      	ldr	r3, [r0, #24]
   26e44:	b90b      	cbnz	r3, 26e4a <z_impl_k_mutex_unlock+0xfe>
		z_add_thread_to_ready_q(thread);
   26e46:	f000 fcbb 	bl	277c0 <z_add_thread_to_ready_q>
		z_reschedule(&lock, key);
   26e4a:	4629      	mov	r1, r5
   26e4c:	4818      	ldr	r0, [pc, #96]	; (26eb0 <z_impl_k_mutex_unlock+0x164>)
   26e4e:	f000 facd 	bl	273ec <z_reschedule>
   26e52:	e7c0      	b.n	26dd6 <z_impl_k_mutex_unlock+0x8a>
		mutex->lock_count = 0U;
   26e54:	60e0      	str	r0, [r4, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26e56:	4816      	ldr	r0, [pc, #88]	; (26eb0 <z_impl_k_mutex_unlock+0x164>)
   26e58:	f001 fc54 	bl	28704 <z_spin_unlock_valid>
   26e5c:	b968      	cbnz	r0, 26e7a <z_impl_k_mutex_unlock+0x12e>
   26e5e:	235d      	movs	r3, #93	; 0x5d
   26e60:	4a14      	ldr	r2, [pc, #80]	; (26eb4 <z_impl_k_mutex_unlock+0x168>)
   26e62:	4917      	ldr	r1, [pc, #92]	; (26ec0 <z_impl_k_mutex_unlock+0x174>)
   26e64:	480c      	ldr	r0, [pc, #48]	; (26e98 <z_impl_k_mutex_unlock+0x14c>)
   26e66:	f006 f9f0 	bl	2d24a <printk>
   26e6a:	4911      	ldr	r1, [pc, #68]	; (26eb0 <z_impl_k_mutex_unlock+0x164>)
   26e6c:	4815      	ldr	r0, [pc, #84]	; (26ec4 <z_impl_k_mutex_unlock+0x178>)
   26e6e:	f006 f9ec 	bl	2d24a <printk>
   26e72:	215d      	movs	r1, #93	; 0x5d
   26e74:	480f      	ldr	r0, [pc, #60]	; (26eb4 <z_impl_k_mutex_unlock+0x168>)
   26e76:	f006 fa2e 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   26e7a:	f385 8811 	msr	BASEPRI, r5
   26e7e:	f3bf 8f6f 	isb	sy
   26e82:	e7a8      	b.n	26dd6 <z_impl_k_mutex_unlock+0x8a>
		return -EINVAL;
   26e84:	f06f 0015 	mvn.w	r0, #21
   26e88:	e7a8      	b.n	26ddc <z_impl_k_mutex_unlock+0x90>
		return -EPERM;
   26e8a:	f04f 30ff 	mov.w	r0, #4294967295
   26e8e:	e7a5      	b.n	26ddc <z_impl_k_mutex_unlock+0x90>
   26e90:	2002d2e8 	.word	0x2002d2e8
   26e94:	000348b8 	.word	0x000348b8
   26e98:	000311a3 	.word	0x000311a3
   26e9c:	00034896 	.word	0x00034896
   26ea0:	000348fa 	.word	0x000348fa
   26ea4:	000348cf 	.word	0x000348cf
   26ea8:	00033242 	.word	0x00033242
   26eac:	0003490c 	.word	0x0003490c
   26eb0:	2002d2e4 	.word	0x2002d2e4
   26eb4:	00031168 	.word	0x00031168
   26eb8:	0003118e 	.word	0x0003118e
   26ebc:	000311c0 	.word	0x000311c0
   26ec0:	00031202 	.word	0x00031202
   26ec4:	00031219 	.word	0x00031219

00026ec8 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static s32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			  bool alloc)
{
   26ec8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   26ecc:	4604      	mov	r4, r0
   26ece:	460e      	mov	r6, r1
   26ed0:	4690      	mov	r8, r2
   26ed2:	4699      	mov	r9, r3
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   26ed4:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   26ed8:	f04f 0320 	mov.w	r3, #32
   26edc:	f3ef 8711 	mrs	r7, BASEPRI
   26ee0:	f383 8811 	msr	BASEPRI, r3
   26ee4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26ee8:	4628      	mov	r0, r5
   26eea:	f001 fbfd 	bl	286e8 <z_spin_lock_valid>
   26eee:	b968      	cbnz	r0, 26f0c <queue_insert+0x44>
   26ef0:	234a      	movs	r3, #74	; 0x4a
   26ef2:	4a33      	ldr	r2, [pc, #204]	; (26fc0 <queue_insert+0xf8>)
   26ef4:	4933      	ldr	r1, [pc, #204]	; (26fc4 <queue_insert+0xfc>)
   26ef6:	4834      	ldr	r0, [pc, #208]	; (26fc8 <queue_insert+0x100>)
   26ef8:	f006 f9a7 	bl	2d24a <printk>
   26efc:	4629      	mov	r1, r5
   26efe:	4833      	ldr	r0, [pc, #204]	; (26fcc <queue_insert+0x104>)
   26f00:	f006 f9a3 	bl	2d24a <printk>
   26f04:	214a      	movs	r1, #74	; 0x4a
   26f06:	482e      	ldr	r0, [pc, #184]	; (26fc0 <queue_insert+0xf8>)
   26f08:	f006 f9e5 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   26f0c:	4628      	mov	r0, r5
   26f0e:	f001 fc09 	bl	28724 <z_spin_lock_set_owner>
		return 0;
	}
#endif /* !CONFIG_POLL */

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
   26f12:	f1b9 0f00 	cmp.w	r9, #0
   26f16:	d02d      	beq.n	26f74 <queue_insert+0xac>
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
   26f18:	2008      	movs	r0, #8
   26f1a:	f7ff fcd7 	bl	268cc <z_thread_malloc>
		if (anode == NULL) {
   26f1e:	b9c8      	cbnz	r0, 26f54 <queue_insert+0x8c>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   26f20:	4628      	mov	r0, r5
   26f22:	f001 fbef 	bl	28704 <z_spin_unlock_valid>
   26f26:	b968      	cbnz	r0, 26f44 <queue_insert+0x7c>
   26f28:	235d      	movs	r3, #93	; 0x5d
   26f2a:	4a25      	ldr	r2, [pc, #148]	; (26fc0 <queue_insert+0xf8>)
   26f2c:	4928      	ldr	r1, [pc, #160]	; (26fd0 <queue_insert+0x108>)
   26f2e:	4826      	ldr	r0, [pc, #152]	; (26fc8 <queue_insert+0x100>)
   26f30:	f006 f98b 	bl	2d24a <printk>
   26f34:	4629      	mov	r1, r5
   26f36:	4827      	ldr	r0, [pc, #156]	; (26fd4 <queue_insert+0x10c>)
   26f38:	f006 f987 	bl	2d24a <printk>
   26f3c:	215d      	movs	r1, #93	; 0x5d
   26f3e:	4820      	ldr	r0, [pc, #128]	; (26fc0 <queue_insert+0xf8>)
   26f40:	f006 f9c9 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   26f44:	f387 8811 	msr	BASEPRI, r7
   26f48:	f3bf 8f6f 	isb	sy
			k_spin_unlock(&queue->lock, key);
			return -ENOMEM;
   26f4c:	f06f 000b 	mvn.w	r0, #11
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* CONFIG_POLL */

	z_reschedule(&queue->lock, key);
	return 0;
}
   26f50:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	node->next_and_flags = flags;
   26f54:	2301      	movs	r3, #1
		anode->data = data;
   26f56:	f8c0 8004 	str.w	r8, [r0, #4]
   26f5a:	6003      	str	r3, [r0, #0]
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
   26f5c:	6803      	ldr	r3, [r0, #0]
   26f5e:	f003 0203 	and.w	r2, r3, #3
   26f62:	b95e      	cbnz	r6, 26f7c <queue_insert+0xb4>
	parent->next_and_flags = cur_flags | (unative_t)child;
   26f64:	6823      	ldr	r3, [r4, #0]
   26f66:	4313      	orrs	r3, r2
   26f68:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   26f6a:	6863      	ldr	r3, [r4, #4]
	list->head = node;
   26f6c:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   26f6e:	b973      	cbnz	r3, 26f8e <queue_insert+0xc6>
	list->tail = node;
   26f70:	6060      	str	r0, [r4, #4]
   26f72:	e00c      	b.n	26f8e <queue_insert+0xc6>
	node->next_and_flags = flags;
   26f74:	f8c8 9000 	str.w	r9, [r8]
   26f78:	4640      	mov	r0, r8
   26f7a:	e7ef      	b.n	26f5c <queue_insert+0x94>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   26f7c:	6833      	ldr	r3, [r6, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   26f7e:	f033 0303 	bics.w	r3, r3, #3
   26f82:	d115      	bne.n	26fb0 <queue_insert+0xe8>
	parent->next_and_flags = cur_flags | (unative_t)child;
   26f84:	6002      	str	r2, [r0, #0]
Z_GENLIST_APPEND(sflist, sfnode)
   26f86:	6862      	ldr	r2, [r4, #4]
   26f88:	b962      	cbnz	r2, 26fa4 <queue_insert+0xdc>
	list->head = node;
   26f8a:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   26f8e:	2104      	movs	r1, #4
   26f90:	f104 000c 	add.w	r0, r4, #12
   26f94:	f008 f9ab 	bl	2f2ee <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   26f98:	4628      	mov	r0, r5
   26f9a:	4639      	mov	r1, r7
   26f9c:	f000 fa26 	bl	273ec <z_reschedule>
	return 0;
   26fa0:	2000      	movs	r0, #0
   26fa2:	e7d5      	b.n	26f50 <queue_insert+0x88>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   26fa4:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   26fa6:	f003 0303 	and.w	r3, r3, #3
   26faa:	4303      	orrs	r3, r0
   26fac:	6013      	str	r3, [r2, #0]
   26fae:	e7df      	b.n	26f70 <queue_insert+0xa8>
   26fb0:	4313      	orrs	r3, r2
   26fb2:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   26fb4:	6833      	ldr	r3, [r6, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   26fb6:	f003 0303 	and.w	r3, r3, #3
   26fba:	4318      	orrs	r0, r3
   26fbc:	6030      	str	r0, [r6, #0]
   26fbe:	e7e6      	b.n	26f8e <queue_insert+0xc6>
   26fc0:	00031168 	.word	0x00031168
   26fc4:	0003118e 	.word	0x0003118e
   26fc8:	000311a3 	.word	0x000311a3
   26fcc:	000311c0 	.word	0x000311c0
   26fd0:	00031202 	.word	0x00031202
   26fd4:	00031219 	.word	0x00031219

00026fd8 <z_impl_k_queue_get>:
	return val;
}
#endif /* CONFIG_POLL */

void *z_impl_k_queue_get(struct k_queue *queue, s32_t timeout)
{
   26fd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   26fdc:	4606      	mov	r6, r0
   26fde:	b089      	sub	sp, #36	; 0x24
   26fe0:	460f      	mov	r7, r1
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   26fe2:	f100 0408 	add.w	r4, r0, #8
	__asm__ volatile(
   26fe6:	f04f 0320 	mov.w	r3, #32
   26fea:	f3ef 8811 	mrs	r8, BASEPRI
   26fee:	f383 8811 	msr	BASEPRI, r3
   26ff2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   26ff6:	4620      	mov	r0, r4
   26ff8:	f001 fb76 	bl	286e8 <z_spin_lock_valid>
   26ffc:	b968      	cbnz	r0, 2701a <z_impl_k_queue_get+0x42>
   26ffe:	234a      	movs	r3, #74	; 0x4a
   27000:	4a5f      	ldr	r2, [pc, #380]	; (27180 <z_impl_k_queue_get+0x1a8>)
   27002:	4960      	ldr	r1, [pc, #384]	; (27184 <z_impl_k_queue_get+0x1ac>)
   27004:	4860      	ldr	r0, [pc, #384]	; (27188 <z_impl_k_queue_get+0x1b0>)
   27006:	f006 f920 	bl	2d24a <printk>
   2700a:	4621      	mov	r1, r4
   2700c:	485f      	ldr	r0, [pc, #380]	; (2718c <z_impl_k_queue_get+0x1b4>)
   2700e:	f006 f91c 	bl	2d24a <printk>
   27012:	214a      	movs	r1, #74	; 0x4a
   27014:	485a      	ldr	r0, [pc, #360]	; (27180 <z_impl_k_queue_get+0x1a8>)
   27016:	f006 f95e 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   2701a:	4620      	mov	r0, r4
   2701c:	f001 fb82 	bl	28724 <z_spin_lock_set_owner>
Z_GENLIST_IS_EMPTY(sflist)
   27020:	6835      	ldr	r5, [r6, #0]
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   27022:	b335      	cbz	r5, 27072 <z_impl_k_queue_get+0x9a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   27024:	682b      	ldr	r3, [r5, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   27026:	6872      	ldr	r2, [r6, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   27028:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   2702c:	4295      	cmp	r5, r2
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   2702e:	4628      	mov	r0, r5
	list->head = node;
   27030:	6033      	str	r3, [r6, #0]
	list->tail = node;
   27032:	bf08      	it	eq
   27034:	6073      	streq	r3, [r6, #4]
   27036:	2101      	movs	r1, #1
   27038:	f007 ffde 	bl	2eff8 <z_queue_node_peek>
   2703c:	4605      	mov	r5, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2703e:	4620      	mov	r0, r4
   27040:	f001 fb60 	bl	28704 <z_spin_unlock_valid>
   27044:	b968      	cbnz	r0, 27062 <z_impl_k_queue_get+0x8a>
   27046:	235d      	movs	r3, #93	; 0x5d
   27048:	4a4d      	ldr	r2, [pc, #308]	; (27180 <z_impl_k_queue_get+0x1a8>)
   2704a:	4951      	ldr	r1, [pc, #324]	; (27190 <z_impl_k_queue_get+0x1b8>)
   2704c:	484e      	ldr	r0, [pc, #312]	; (27188 <z_impl_k_queue_get+0x1b0>)
   2704e:	f006 f8fc 	bl	2d24a <printk>
   27052:	4621      	mov	r1, r4
   27054:	484f      	ldr	r0, [pc, #316]	; (27194 <z_impl_k_queue_get+0x1bc>)
   27056:	f006 f8f8 	bl	2d24a <printk>
   2705a:	215d      	movs	r1, #93	; 0x5d
   2705c:	4848      	ldr	r0, [pc, #288]	; (27180 <z_impl_k_queue_get+0x1a8>)
   2705e:	f006 f93a 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   27062:	f388 8811 	msr	BASEPRI, r8
   27066:	f3bf 8f6f 	isb	sy
#else
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
#endif /* CONFIG_POLL */
}
   2706a:	4628      	mov	r0, r5
   2706c:	b009      	add	sp, #36	; 0x24
   2706e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   27072:	4620      	mov	r0, r4
	if (timeout == K_NO_WAIT) {
   27074:	2f00      	cmp	r7, #0
   27076:	d0e3      	beq.n	27040 <z_impl_k_queue_get+0x68>
   27078:	f001 fb44 	bl	28704 <z_spin_unlock_valid>
   2707c:	b968      	cbnz	r0, 2709a <z_impl_k_queue_get+0xc2>
   2707e:	235d      	movs	r3, #93	; 0x5d
   27080:	4a3f      	ldr	r2, [pc, #252]	; (27180 <z_impl_k_queue_get+0x1a8>)
   27082:	4943      	ldr	r1, [pc, #268]	; (27190 <z_impl_k_queue_get+0x1b8>)
   27084:	4840      	ldr	r0, [pc, #256]	; (27188 <z_impl_k_queue_get+0x1b0>)
   27086:	f006 f8e0 	bl	2d24a <printk>
   2708a:	4621      	mov	r1, r4
   2708c:	4841      	ldr	r0, [pc, #260]	; (27194 <z_impl_k_queue_get+0x1bc>)
   2708e:	f006 f8dc 	bl	2d24a <printk>
   27092:	215d      	movs	r1, #93	; 0x5d
   27094:	483a      	ldr	r0, [pc, #232]	; (27180 <z_impl_k_queue_get+0x1a8>)
   27096:	f006 f91e 	bl	2d2d6 <assert_post_action>
   2709a:	f388 8811 	msr	BASEPRI, r8
   2709e:	f3bf 8f6f 	isb	sy
	k_poll_event_init(&event, K_POLL_TYPE_FIFO_DATA_AVAILABLE,
   270a2:	2200      	movs	r2, #0
   270a4:	4633      	mov	r3, r6
   270a6:	2104      	movs	r1, #4
   270a8:	a803      	add	r0, sp, #12
   270aa:	f002 fb03 	bl	296b4 <k_poll_event_init>
	if (timeout != K_FOREVER) {
   270ae:	1c7a      	adds	r2, r7, #1
   270b0:	d002      	beq.n	270b8 <z_impl_k_queue_get+0xe0>
   270b2:	f008 f892 	bl	2f1da <z_impl_k_uptime_get>
   270b6:	4683      	mov	fp, r0
{
   270b8:	f04f 0900 	mov.w	r9, #0
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   270bc:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 27180 <z_impl_k_queue_get+0x1a8>
   270c0:	f8df a0c4 	ldr.w	sl, [pc, #196]	; 27188 <z_impl_k_queue_get+0x1b0>
		event.state = K_POLL_STATE_NOT_READY;
   270c4:	9b06      	ldr	r3, [sp, #24]
   270c6:	f36f 3310 	bfc	r3, #12, #5
   270ca:	9306      	str	r3, [sp, #24]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&events, *(uintptr_t *)&num_events, *(uintptr_t *)&timeout, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
   270cc:	2101      	movs	r1, #1
   270ce:	eba7 0209 	sub.w	r2, r7, r9
   270d2:	a803      	add	r0, sp, #12
   270d4:	f002 fb40 	bl	29758 <z_impl_k_poll>
		if (err && err != -EAGAIN) {
   270d8:	b118      	cbz	r0, 270e2 <z_impl_k_queue_get+0x10a>
   270da:	300b      	adds	r0, #11
   270dc:	d001      	beq.n	270e2 <z_impl_k_queue_get+0x10a>
			return NULL;
   270de:	2500      	movs	r5, #0
   270e0:	e7c3      	b.n	2706a <z_impl_k_queue_get+0x92>
	__asm__ volatile(
   270e2:	f04f 0320 	mov.w	r3, #32
   270e6:	f3ef 8211 	mrs	r2, BASEPRI
   270ea:	f383 8811 	msr	BASEPRI, r3
   270ee:	f3bf 8f6f 	isb	sy
   270f2:	4620      	mov	r0, r4
   270f4:	9201      	str	r2, [sp, #4]
   270f6:	f001 faf7 	bl	286e8 <z_spin_lock_valid>
   270fa:	b968      	cbnz	r0, 27118 <z_impl_k_queue_get+0x140>
   270fc:	234a      	movs	r3, #74	; 0x4a
   270fe:	4642      	mov	r2, r8
   27100:	4920      	ldr	r1, [pc, #128]	; (27184 <z_impl_k_queue_get+0x1ac>)
   27102:	4650      	mov	r0, sl
   27104:	f006 f8a1 	bl	2d24a <printk>
   27108:	4621      	mov	r1, r4
   2710a:	4820      	ldr	r0, [pc, #128]	; (2718c <z_impl_k_queue_get+0x1b4>)
   2710c:	f006 f89d 	bl	2d24a <printk>
   27110:	214a      	movs	r1, #74	; 0x4a
   27112:	4640      	mov	r0, r8
   27114:	f006 f8df 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   27118:	4620      	mov	r0, r4
   2711a:	f001 fb03 	bl	28724 <z_spin_lock_set_owner>
Z_GENLIST_IS_EMPTY(sflist)
   2711e:	6830      	ldr	r0, [r6, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_sfnode_t *sys_sflist_get(sys_sflist_t *list);

Z_GENLIST_GET(sflist, sfnode)
   27120:	b138      	cbz	r0, 27132 <z_impl_k_queue_get+0x15a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   27122:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   27124:	6872      	ldr	r2, [r6, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   27126:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   2712a:	4290      	cmp	r0, r2
	list->head = node;
   2712c:	6033      	str	r3, [r6, #0]
	list->tail = node;
   2712e:	bf08      	it	eq
   27130:	6073      	streq	r3, [r6, #4]
		val = z_queue_node_peek(sys_sflist_get(&queue->data_q), true);
   27132:	2101      	movs	r1, #1
   27134:	f007 ff60 	bl	2eff8 <z_queue_node_peek>
   27138:	4605      	mov	r5, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2713a:	4620      	mov	r0, r4
   2713c:	f001 fae2 	bl	28704 <z_spin_unlock_valid>
   27140:	b968      	cbnz	r0, 2715e <z_impl_k_queue_get+0x186>
   27142:	235d      	movs	r3, #93	; 0x5d
   27144:	4642      	mov	r2, r8
   27146:	4912      	ldr	r1, [pc, #72]	; (27190 <z_impl_k_queue_get+0x1b8>)
   27148:	4650      	mov	r0, sl
   2714a:	f006 f87e 	bl	2d24a <printk>
   2714e:	4621      	mov	r1, r4
   27150:	4810      	ldr	r0, [pc, #64]	; (27194 <z_impl_k_queue_get+0x1bc>)
   27152:	f006 f87a 	bl	2d24a <printk>
   27156:	215d      	movs	r1, #93	; 0x5d
   27158:	4640      	mov	r0, r8
   2715a:	f006 f8bc 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   2715e:	9b01      	ldr	r3, [sp, #4]
   27160:	f383 8811 	msr	BASEPRI, r3
   27164:	f3bf 8f6f 	isb	sy
		if ((val == NULL) && (timeout != K_FOREVER)) {
   27168:	2d00      	cmp	r5, #0
   2716a:	f47f af7e 	bne.w	2706a <z_impl_k_queue_get+0x92>
   2716e:	1c7b      	adds	r3, r7, #1
   27170:	d0a8      	beq.n	270c4 <z_impl_k_queue_get+0xec>
	return z_impl_k_uptime_get();
   27172:	f008 f832 	bl	2f1da <z_impl_k_uptime_get>
			elapsed = k_uptime_get_32() - start;
   27176:	eba0 090b 	sub.w	r9, r0, fp
	} while (!val && !done);
   2717a:	454f      	cmp	r7, r9
   2717c:	daa2      	bge.n	270c4 <z_impl_k_queue_get+0xec>
   2717e:	e7ae      	b.n	270de <z_impl_k_queue_get+0x106>
   27180:	00031168 	.word	0x00031168
   27184:	0003118e 	.word	0x0003118e
   27188:	000311a3 	.word	0x000311a3
   2718c:	000311c0 	.word	0x000311c0
   27190:	00031202 	.word	0x00031202
   27194:	00031219 	.word	0x00031219

00027198 <pended_on.isra.17>:
	}
}

static _wait_q_t *pended_on(struct k_thread *thread)
{
	__ASSERT_NO_MSG(thread->base.pended_on);
   27198:	6803      	ldr	r3, [r0, #0]
static _wait_q_t *pended_on(struct k_thread *thread)
   2719a:	b510      	push	{r4, lr}
   2719c:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(thread->base.pended_on);
   2719e:	b95b      	cbnz	r3, 271b8 <pended_on.isra.17+0x20>
   271a0:	4906      	ldr	r1, [pc, #24]	; (271bc <pended_on.isra.17+0x24>)
   271a2:	4807      	ldr	r0, [pc, #28]	; (271c0 <pended_on.isra.17+0x28>)
   271a4:	f240 139d 	movw	r3, #413	; 0x19d
   271a8:	4a06      	ldr	r2, [pc, #24]	; (271c4 <pended_on.isra.17+0x2c>)
   271aa:	f006 f84e 	bl	2d24a <printk>
   271ae:	f240 119d 	movw	r1, #413	; 0x19d
   271b2:	4804      	ldr	r0, [pc, #16]	; (271c4 <pended_on.isra.17+0x2c>)
   271b4:	f006 f88f 	bl	2d2d6 <assert_post_action>

	return thread->base.pended_on;
}
   271b8:	6820      	ldr	r0, [r4, #0]
   271ba:	bd10      	pop	{r4, pc}
   271bc:	000349b4 	.word	0x000349b4
   271c0:	000311a3 	.word	0x000311a3
   271c4:	00034992 	.word	0x00034992

000271c8 <z_reset_time_slice>:
{
   271c8:	b510      	push	{r4, lr}
	if (slice_time != 0) {
   271ca:	4c08      	ldr	r4, [pc, #32]	; (271ec <z_reset_time_slice+0x24>)
   271cc:	6823      	ldr	r3, [r4, #0]
   271ce:	b15b      	cbz	r3, 271e8 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   271d0:	f7f1 fd20 	bl	18c14 <z_clock_elapsed>
   271d4:	6823      	ldr	r3, [r4, #0]
   271d6:	4a06      	ldr	r2, [pc, #24]	; (271f0 <z_reset_time_slice+0x28>)
   271d8:	4418      	add	r0, r3
   271da:	6110      	str	r0, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   271dc:	2100      	movs	r1, #0
}
   271de:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_set_timeout_expiry(slice_time, false);
   271e2:	4618      	mov	r0, r3
   271e4:	f001 beb6 	b.w	28f54 <z_set_timeout_expiry>
}
   271e8:	bd10      	pop	{r4, pc}
   271ea:	bf00      	nop
   271ec:	2002d328 	.word	0x2002d328
   271f0:	2002d2e8 	.word	0x2002d2e8

000271f4 <k_sched_time_slice_set>:
{
   271f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   271f6:	4607      	mov	r7, r0
   271f8:	460d      	mov	r5, r1
	__asm__ volatile(
   271fa:	f04f 0320 	mov.w	r3, #32
   271fe:	f3ef 8411 	mrs	r4, BASEPRI
   27202:	f383 8811 	msr	BASEPRI, r3
   27206:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2720a:	4820      	ldr	r0, [pc, #128]	; (2728c <k_sched_time_slice_set+0x98>)
   2720c:	f001 fa6c 	bl	286e8 <z_spin_lock_valid>
   27210:	b968      	cbnz	r0, 2722e <k_sched_time_slice_set+0x3a>
   27212:	234a      	movs	r3, #74	; 0x4a
   27214:	4a1e      	ldr	r2, [pc, #120]	; (27290 <k_sched_time_slice_set+0x9c>)
   27216:	491f      	ldr	r1, [pc, #124]	; (27294 <k_sched_time_slice_set+0xa0>)
   27218:	481f      	ldr	r0, [pc, #124]	; (27298 <k_sched_time_slice_set+0xa4>)
   2721a:	f006 f816 	bl	2d24a <printk>
   2721e:	491b      	ldr	r1, [pc, #108]	; (2728c <k_sched_time_slice_set+0x98>)
   27220:	481e      	ldr	r0, [pc, #120]	; (2729c <k_sched_time_slice_set+0xa8>)
   27222:	f006 f812 	bl	2d24a <printk>
   27226:	214a      	movs	r1, #74	; 0x4a
   27228:	4819      	ldr	r0, [pc, #100]	; (27290 <k_sched_time_slice_set+0x9c>)
   2722a:	f006 f854 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   2722e:	4817      	ldr	r0, [pc, #92]	; (2728c <k_sched_time_slice_set+0x98>)
   27230:	f001 fa78 	bl	28724 <z_spin_lock_set_owner>
			return (u32_t)((t * to_hz + off) / from_hz);
   27234:	f44f 4600 	mov.w	r6, #32768	; 0x8000
		_current_cpu->slice_ticks = 0;
   27238:	2200      	movs	r2, #0
   2723a:	f240 30e7 	movw	r0, #999	; 0x3e7
   2723e:	2100      	movs	r1, #0
   27240:	4b17      	ldr	r3, [pc, #92]	; (272a0 <k_sched_time_slice_set+0xac>)
   27242:	fbe6 0107 	umlal	r0, r1, r6, r7
   27246:	611a      	str	r2, [r3, #16]
   27248:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2724c:	2300      	movs	r3, #0
   2724e:	f7e5 fcbd 	bl	cbcc <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
   27252:	4b14      	ldr	r3, [pc, #80]	; (272a4 <k_sched_time_slice_set+0xb0>)
   27254:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
   27256:	4b14      	ldr	r3, [pc, #80]	; (272a8 <k_sched_time_slice_set+0xb4>)
   27258:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
   2725a:	f7ff ffb5 	bl	271c8 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2725e:	480b      	ldr	r0, [pc, #44]	; (2728c <k_sched_time_slice_set+0x98>)
   27260:	f001 fa50 	bl	28704 <z_spin_unlock_valid>
   27264:	b968      	cbnz	r0, 27282 <k_sched_time_slice_set+0x8e>
   27266:	235d      	movs	r3, #93	; 0x5d
   27268:	4a09      	ldr	r2, [pc, #36]	; (27290 <k_sched_time_slice_set+0x9c>)
   2726a:	4910      	ldr	r1, [pc, #64]	; (272ac <k_sched_time_slice_set+0xb8>)
   2726c:	480a      	ldr	r0, [pc, #40]	; (27298 <k_sched_time_slice_set+0xa4>)
   2726e:	f005 ffec 	bl	2d24a <printk>
   27272:	4906      	ldr	r1, [pc, #24]	; (2728c <k_sched_time_slice_set+0x98>)
   27274:	480e      	ldr	r0, [pc, #56]	; (272b0 <k_sched_time_slice_set+0xbc>)
   27276:	f005 ffe8 	bl	2d24a <printk>
   2727a:	215d      	movs	r1, #93	; 0x5d
   2727c:	4804      	ldr	r0, [pc, #16]	; (27290 <k_sched_time_slice_set+0x9c>)
   2727e:	f006 f82a 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   27282:	f384 8811 	msr	BASEPRI, r4
   27286:	f3bf 8f6f 	isb	sy
}
   2728a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2728c:	2002d320 	.word	0x2002d320
   27290:	00031168 	.word	0x00031168
   27294:	0003118e 	.word	0x0003118e
   27298:	000311a3 	.word	0x000311a3
   2729c:	000311c0 	.word	0x000311c0
   272a0:	2002d2e8 	.word	0x2002d2e8
   272a4:	2002d328 	.word	0x2002d328
   272a8:	2002d324 	.word	0x2002d324
   272ac:	00031202 	.word	0x00031202
   272b0:	00031219 	.word	0x00031219

000272b4 <z_find_first_thread_to_unpend>:
	pend(thread, wait_q, timeout);
}

ALWAYS_INLINE struct k_thread *z_find_first_thread_to_unpend(_wait_q_t *wait_q,
						     struct k_thread *from)
{
   272b4:	b538      	push	{r3, r4, r5, lr}
   272b6:	4604      	mov	r4, r0
	__asm__ volatile(
   272b8:	f04f 0320 	mov.w	r3, #32
   272bc:	f3ef 8511 	mrs	r5, BASEPRI
   272c0:	f383 8811 	msr	BASEPRI, r3
   272c4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   272c8:	4818      	ldr	r0, [pc, #96]	; (2732c <z_find_first_thread_to_unpend+0x78>)
   272ca:	f001 fa0d 	bl	286e8 <z_spin_lock_valid>
   272ce:	b968      	cbnz	r0, 272ec <z_find_first_thread_to_unpend+0x38>
   272d0:	234a      	movs	r3, #74	; 0x4a
   272d2:	4a17      	ldr	r2, [pc, #92]	; (27330 <z_find_first_thread_to_unpend+0x7c>)
   272d4:	4917      	ldr	r1, [pc, #92]	; (27334 <z_find_first_thread_to_unpend+0x80>)
   272d6:	4818      	ldr	r0, [pc, #96]	; (27338 <z_find_first_thread_to_unpend+0x84>)
   272d8:	f005 ffb7 	bl	2d24a <printk>
   272dc:	4913      	ldr	r1, [pc, #76]	; (2732c <z_find_first_thread_to_unpend+0x78>)
   272de:	4817      	ldr	r0, [pc, #92]	; (2733c <z_find_first_thread_to_unpend+0x88>)
   272e0:	f005 ffb3 	bl	2d24a <printk>
   272e4:	214a      	movs	r1, #74	; 0x4a
   272e6:	4812      	ldr	r0, [pc, #72]	; (27330 <z_find_first_thread_to_unpend+0x7c>)
   272e8:	f005 fff5 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   272ec:	480f      	ldr	r0, [pc, #60]	; (2732c <z_find_first_thread_to_unpend+0x78>)
   272ee:	f001 fa19 	bl	28724 <z_spin_lock_set_owner>
	ARG_UNUSED(from);

	struct k_thread *ret = NULL;

	LOCKED(&sched_spinlock) {
		ret = _priq_wait_best(&wait_q->waitq);
   272f2:	4620      	mov	r0, r4
   272f4:	f007 fec2 	bl	2f07c <z_priq_dumb_best>
   272f8:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   272fa:	480c      	ldr	r0, [pc, #48]	; (2732c <z_find_first_thread_to_unpend+0x78>)
   272fc:	f001 fa02 	bl	28704 <z_spin_unlock_valid>
   27300:	b968      	cbnz	r0, 2731e <z_find_first_thread_to_unpend+0x6a>
   27302:	235d      	movs	r3, #93	; 0x5d
   27304:	4a0a      	ldr	r2, [pc, #40]	; (27330 <z_find_first_thread_to_unpend+0x7c>)
   27306:	490e      	ldr	r1, [pc, #56]	; (27340 <z_find_first_thread_to_unpend+0x8c>)
   27308:	480b      	ldr	r0, [pc, #44]	; (27338 <z_find_first_thread_to_unpend+0x84>)
   2730a:	f005 ff9e 	bl	2d24a <printk>
   2730e:	4907      	ldr	r1, [pc, #28]	; (2732c <z_find_first_thread_to_unpend+0x78>)
   27310:	480c      	ldr	r0, [pc, #48]	; (27344 <z_find_first_thread_to_unpend+0x90>)
   27312:	f005 ff9a 	bl	2d24a <printk>
   27316:	215d      	movs	r1, #93	; 0x5d
   27318:	4805      	ldr	r0, [pc, #20]	; (27330 <z_find_first_thread_to_unpend+0x7c>)
   2731a:	f005 ffdc 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   2731e:	f385 8811 	msr	BASEPRI, r5
   27322:	f3bf 8f6f 	isb	sy
	}

	return ret;
}
   27326:	4620      	mov	r0, r4
   27328:	bd38      	pop	{r3, r4, r5, pc}
   2732a:	bf00      	nop
   2732c:	2002d320 	.word	0x2002d320
   27330:	00031168 	.word	0x00031168
   27334:	0003118e 	.word	0x0003118e
   27338:	000311a3 	.word	0x000311a3
   2733c:	000311c0 	.word	0x000311c0
   27340:	00031202 	.word	0x00031202
   27344:	00031219 	.word	0x00031219

00027348 <z_unpend_thread_no_timeout>:

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
   27348:	b538      	push	{r3, r4, r5, lr}
   2734a:	4604      	mov	r4, r0
	__asm__ volatile(
   2734c:	f04f 0320 	mov.w	r3, #32
   27350:	f3ef 8511 	mrs	r5, BASEPRI
   27354:	f383 8811 	msr	BASEPRI, r3
   27358:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2735c:	481c      	ldr	r0, [pc, #112]	; (273d0 <z_unpend_thread_no_timeout+0x88>)
   2735e:	f001 f9c3 	bl	286e8 <z_spin_lock_valid>
   27362:	b968      	cbnz	r0, 27380 <z_unpend_thread_no_timeout+0x38>
   27364:	234a      	movs	r3, #74	; 0x4a
   27366:	4a1b      	ldr	r2, [pc, #108]	; (273d4 <z_unpend_thread_no_timeout+0x8c>)
   27368:	491b      	ldr	r1, [pc, #108]	; (273d8 <z_unpend_thread_no_timeout+0x90>)
   2736a:	481c      	ldr	r0, [pc, #112]	; (273dc <z_unpend_thread_no_timeout+0x94>)
   2736c:	f005 ff6d 	bl	2d24a <printk>
   27370:	4917      	ldr	r1, [pc, #92]	; (273d0 <z_unpend_thread_no_timeout+0x88>)
   27372:	481b      	ldr	r0, [pc, #108]	; (273e0 <z_unpend_thread_no_timeout+0x98>)
   27374:	f005 ff69 	bl	2d24a <printk>
   27378:	214a      	movs	r1, #74	; 0x4a
   2737a:	4816      	ldr	r0, [pc, #88]	; (273d4 <z_unpend_thread_no_timeout+0x8c>)
   2737c:	f005 ffab 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   27380:	4813      	ldr	r0, [pc, #76]	; (273d0 <z_unpend_thread_no_timeout+0x88>)
   27382:	f001 f9cf 	bl	28724 <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   27386:	f104 0008 	add.w	r0, r4, #8
   2738a:	f7ff ff05 	bl	27198 <pended_on.isra.17>
   2738e:	4621      	mov	r1, r4
   27390:	f000 f8e0 	bl	27554 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   27394:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27396:	480e      	ldr	r0, [pc, #56]	; (273d0 <z_unpend_thread_no_timeout+0x88>)
   27398:	f023 0302 	bic.w	r3, r3, #2
   2739c:	7363      	strb	r3, [r4, #13]
   2739e:	f001 f9b1 	bl	28704 <z_spin_unlock_valid>
   273a2:	b968      	cbnz	r0, 273c0 <z_unpend_thread_no_timeout+0x78>
   273a4:	235d      	movs	r3, #93	; 0x5d
   273a6:	4a0b      	ldr	r2, [pc, #44]	; (273d4 <z_unpend_thread_no_timeout+0x8c>)
   273a8:	490e      	ldr	r1, [pc, #56]	; (273e4 <z_unpend_thread_no_timeout+0x9c>)
   273aa:	480c      	ldr	r0, [pc, #48]	; (273dc <z_unpend_thread_no_timeout+0x94>)
   273ac:	f005 ff4d 	bl	2d24a <printk>
   273b0:	4907      	ldr	r1, [pc, #28]	; (273d0 <z_unpend_thread_no_timeout+0x88>)
   273b2:	480d      	ldr	r0, [pc, #52]	; (273e8 <z_unpend_thread_no_timeout+0xa0>)
   273b4:	f005 ff49 	bl	2d24a <printk>
   273b8:	215d      	movs	r1, #93	; 0x5d
   273ba:	4806      	ldr	r0, [pc, #24]	; (273d4 <z_unpend_thread_no_timeout+0x8c>)
   273bc:	f005 ff8b 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   273c0:	f385 8811 	msr	BASEPRI, r5
   273c4:	f3bf 8f6f 	isb	sy
		z_mark_thread_as_not_pending(thread);
	}

	thread->base.pended_on = NULL;
   273c8:	2300      	movs	r3, #0
   273ca:	60a3      	str	r3, [r4, #8]
}
   273cc:	bd38      	pop	{r3, r4, r5, pc}
   273ce:	bf00      	nop
   273d0:	2002d320 	.word	0x2002d320
   273d4:	00031168 	.word	0x00031168
   273d8:	0003118e 	.word	0x0003118e
   273dc:	000311a3 	.word	0x000311a3
   273e0:	000311c0 	.word	0x000311c0
   273e4:	00031202 	.word	0x00031202
   273e8:	00031219 	.word	0x00031219

000273ec <z_reschedule>:

	return arch_irq_unlocked(key) && !arch_is_in_isr();
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
   273ec:	b538      	push	{r3, r4, r5, lr}
   273ee:	4604      	mov	r4, r0
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   273f0:	460d      	mov	r5, r1
   273f2:	b9c1      	cbnz	r1, 27426 <z_reschedule+0x3a>
   273f4:	f3ef 8305 	mrs	r3, IPSR
   273f8:	b9ab      	cbnz	r3, 27426 <z_reschedule+0x3a>
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   273fa:	f001 f983 	bl	28704 <z_spin_unlock_valid>
   273fe:	b968      	cbnz	r0, 2741c <z_reschedule+0x30>
   27400:	2374      	movs	r3, #116	; 0x74
   27402:	4a14      	ldr	r2, [pc, #80]	; (27454 <z_reschedule+0x68>)
   27404:	4914      	ldr	r1, [pc, #80]	; (27458 <z_reschedule+0x6c>)
   27406:	4815      	ldr	r0, [pc, #84]	; (2745c <z_reschedule+0x70>)
   27408:	f005 ff1f 	bl	2d24a <printk>
   2740c:	4621      	mov	r1, r4
   2740e:	4814      	ldr	r0, [pc, #80]	; (27460 <z_reschedule+0x74>)
   27410:	f005 ff1b 	bl	2d24a <printk>
   27414:	2174      	movs	r1, #116	; 0x74
   27416:	480f      	ldr	r0, [pc, #60]	; (27454 <z_reschedule+0x68>)
   27418:	f005 ff5d 	bl	2d2d6 <assert_post_action>
	if (resched(key.key)) {
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
   2741c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   27420:	2000      	movs	r0, #0
   27422:	f7f1 bdd9 	b.w	18fd8 <arch_swap>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27426:	4620      	mov	r0, r4
   27428:	f001 f96c 	bl	28704 <z_spin_unlock_valid>
   2742c:	b968      	cbnz	r0, 2744a <z_reschedule+0x5e>
   2742e:	235d      	movs	r3, #93	; 0x5d
   27430:	4a08      	ldr	r2, [pc, #32]	; (27454 <z_reschedule+0x68>)
   27432:	4909      	ldr	r1, [pc, #36]	; (27458 <z_reschedule+0x6c>)
   27434:	4809      	ldr	r0, [pc, #36]	; (2745c <z_reschedule+0x70>)
   27436:	f005 ff08 	bl	2d24a <printk>
   2743a:	4621      	mov	r1, r4
   2743c:	4808      	ldr	r0, [pc, #32]	; (27460 <z_reschedule+0x74>)
   2743e:	f005 ff04 	bl	2d24a <printk>
   27442:	215d      	movs	r1, #93	; 0x5d
   27444:	4803      	ldr	r0, [pc, #12]	; (27454 <z_reschedule+0x68>)
   27446:	f005 ff46 	bl	2d2d6 <assert_post_action>
   2744a:	f385 8811 	msr	BASEPRI, r5
   2744e:	f3bf 8f6f 	isb	sy
   27452:	bd38      	pop	{r3, r4, r5, pc}
   27454:	00031168 	.word	0x00031168
   27458:	00031202 	.word	0x00031202
   2745c:	000311a3 	.word	0x000311a3
   27460:	00031219 	.word	0x00031219

00027464 <k_sched_lock>:
		irq_unlock(key);
	}
}

void k_sched_lock(void)
{
   27464:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   27466:	f04f 0320 	mov.w	r3, #32
   2746a:	f3ef 8511 	mrs	r5, BASEPRI
   2746e:	f383 8811 	msr	BASEPRI, r3
   27472:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27476:	482b      	ldr	r0, [pc, #172]	; (27524 <k_sched_lock+0xc0>)
   27478:	f001 f936 	bl	286e8 <z_spin_lock_valid>
   2747c:	b968      	cbnz	r0, 2749a <k_sched_lock+0x36>
   2747e:	234a      	movs	r3, #74	; 0x4a
   27480:	4a29      	ldr	r2, [pc, #164]	; (27528 <k_sched_lock+0xc4>)
   27482:	492a      	ldr	r1, [pc, #168]	; (2752c <k_sched_lock+0xc8>)
   27484:	482a      	ldr	r0, [pc, #168]	; (27530 <k_sched_lock+0xcc>)
   27486:	f005 fee0 	bl	2d24a <printk>
   2748a:	4926      	ldr	r1, [pc, #152]	; (27524 <k_sched_lock+0xc0>)
   2748c:	4829      	ldr	r0, [pc, #164]	; (27534 <k_sched_lock+0xd0>)
   2748e:	f005 fedc 	bl	2d24a <printk>
   27492:	214a      	movs	r1, #74	; 0x4a
   27494:	4824      	ldr	r0, [pc, #144]	; (27528 <k_sched_lock+0xc4>)
   27496:	f005 ff1e 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   2749a:	4822      	ldr	r0, [pc, #136]	; (27524 <k_sched_lock+0xc0>)
   2749c:	f001 f942 	bl	28724 <z_spin_lock_set_owner>
   274a0:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   274a4:	b173      	cbz	r3, 274c4 <k_sched_lock+0x60>
   274a6:	4924      	ldr	r1, [pc, #144]	; (27538 <k_sched_lock+0xd4>)
   274a8:	f240 130d 	movw	r3, #269	; 0x10d
   274ac:	4a23      	ldr	r2, [pc, #140]	; (2753c <k_sched_lock+0xd8>)
   274ae:	4820      	ldr	r0, [pc, #128]	; (27530 <k_sched_lock+0xcc>)
   274b0:	f005 fecb 	bl	2d24a <printk>
   274b4:	4822      	ldr	r0, [pc, #136]	; (27540 <k_sched_lock+0xdc>)
   274b6:	f005 fec8 	bl	2d24a <printk>
   274ba:	f240 110d 	movw	r1, #269	; 0x10d
   274be:	481f      	ldr	r0, [pc, #124]	; (2753c <k_sched_lock+0xd8>)
   274c0:	f005 ff09 	bl	2d2d6 <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1, "");
   274c4:	4c1f      	ldr	r4, [pc, #124]	; (27544 <k_sched_lock+0xe0>)
   274c6:	68a2      	ldr	r2, [r4, #8]
   274c8:	7bd2      	ldrb	r2, [r2, #15]
   274ca:	2a01      	cmp	r2, #1
   274cc:	d10e      	bne.n	274ec <k_sched_lock+0x88>
   274ce:	491e      	ldr	r1, [pc, #120]	; (27548 <k_sched_lock+0xe4>)
   274d0:	f44f 7387 	mov.w	r3, #270	; 0x10e
   274d4:	4a19      	ldr	r2, [pc, #100]	; (2753c <k_sched_lock+0xd8>)
   274d6:	4816      	ldr	r0, [pc, #88]	; (27530 <k_sched_lock+0xcc>)
   274d8:	f005 feb7 	bl	2d24a <printk>
   274dc:	4818      	ldr	r0, [pc, #96]	; (27540 <k_sched_lock+0xdc>)
   274de:	f005 feb4 	bl	2d24a <printk>
   274e2:	f44f 7187 	mov.w	r1, #270	; 0x10e
   274e6:	4815      	ldr	r0, [pc, #84]	; (2753c <k_sched_lock+0xd8>)
   274e8:	f005 fef5 	bl	2d2d6 <assert_post_action>
	--_current->base.sched_locked;
   274ec:	68a2      	ldr	r2, [r4, #8]
   274ee:	7bd3      	ldrb	r3, [r2, #15]
   274f0:	3b01      	subs	r3, #1
   274f2:	73d3      	strb	r3, [r2, #15]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   274f4:	480b      	ldr	r0, [pc, #44]	; (27524 <k_sched_lock+0xc0>)
   274f6:	f001 f905 	bl	28704 <z_spin_unlock_valid>
   274fa:	b968      	cbnz	r0, 27518 <k_sched_lock+0xb4>
   274fc:	235d      	movs	r3, #93	; 0x5d
   274fe:	4a0a      	ldr	r2, [pc, #40]	; (27528 <k_sched_lock+0xc4>)
   27500:	4912      	ldr	r1, [pc, #72]	; (2754c <k_sched_lock+0xe8>)
   27502:	480b      	ldr	r0, [pc, #44]	; (27530 <k_sched_lock+0xcc>)
   27504:	f005 fea1 	bl	2d24a <printk>
   27508:	4906      	ldr	r1, [pc, #24]	; (27524 <k_sched_lock+0xc0>)
   2750a:	4811      	ldr	r0, [pc, #68]	; (27550 <k_sched_lock+0xec>)
   2750c:	f005 fe9d 	bl	2d24a <printk>
   27510:	215d      	movs	r1, #93	; 0x5d
   27512:	4805      	ldr	r0, [pc, #20]	; (27528 <k_sched_lock+0xc4>)
   27514:	f005 fedf 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   27518:	f385 8811 	msr	BASEPRI, r5
   2751c:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
   27520:	bd38      	pop	{r3, r4, r5, pc}
   27522:	bf00      	nop
   27524:	2002d320 	.word	0x2002d320
   27528:	00031168 	.word	0x00031168
   2752c:	0003118e 	.word	0x0003118e
   27530:	000311a3 	.word	0x000311a3
   27534:	000311c0 	.word	0x000311c0
   27538:	000348fa 	.word	0x000348fa
   2753c:	000348cf 	.word	0x000348cf
   27540:	00033242 	.word	0x00033242
   27544:	2002d2e8 	.word	0x2002d2e8
   27548:	0003490c 	.word	0x0003490c
   2754c:	00031202 	.word	0x00031202
   27550:	00031219 	.word	0x00031219

00027554 <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   27554:	4b11      	ldr	r3, [pc, #68]	; (2759c <z_priq_dumb_remove+0x48>)
{
   27556:	b510      	push	{r4, lr}
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   27558:	f103 0228 	add.w	r2, r3, #40	; 0x28
   2755c:	4282      	cmp	r2, r0
{
   2755e:	460c      	mov	r4, r1
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   27560:	d105      	bne.n	2756e <z_priq_dumb_remove+0x1a>
   27562:	689b      	ldr	r3, [r3, #8]
   27564:	428b      	cmp	r3, r1
   27566:	d102      	bne.n	2756e <z_priq_dumb_remove+0x1a>
   27568:	7b4b      	ldrb	r3, [r1, #13]
   2756a:	06db      	lsls	r3, r3, #27
   2756c:	d115      	bne.n	2759a <z_priq_dumb_remove+0x46>
	    z_is_thread_prevented_from_running(thread)) {
		return;
	}
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   2756e:	4b0c      	ldr	r3, [pc, #48]	; (275a0 <z_priq_dumb_remove+0x4c>)
   27570:	429c      	cmp	r4, r3
   27572:	d10b      	bne.n	2758c <z_priq_dumb_remove+0x38>
   27574:	490b      	ldr	r1, [pc, #44]	; (275a4 <z_priq_dumb_remove+0x50>)
   27576:	480c      	ldr	r0, [pc, #48]	; (275a8 <z_priq_dumb_remove+0x54>)
   27578:	f44f 7346 	mov.w	r3, #792	; 0x318
   2757c:	4a0b      	ldr	r2, [pc, #44]	; (275ac <z_priq_dumb_remove+0x58>)
   2757e:	f005 fe64 	bl	2d24a <printk>
   27582:	f44f 7146 	mov.w	r1, #792	; 0x318
   27586:	4809      	ldr	r0, [pc, #36]	; (275ac <z_priq_dumb_remove+0x58>)
   27588:	f005 fea5 	bl	2d2d6 <assert_post_action>
	node->prev->next = node->next;
   2758c:	e9d4 3200 	ldrd	r3, r2, [r4]
   27590:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   27592:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   27594:	2300      	movs	r3, #0
	node->prev = NULL;
   27596:	e9c4 3300 	strd	r3, r3, [r4]

	sys_dlist_remove(&thread->base.qnode_dlist);
}
   2759a:	bd10      	pop	{r4, pc}
   2759c:	2002d2e8 	.word	0x2002d2e8
   275a0:	20029118 	.word	0x20029118
   275a4:	000349ea 	.word	0x000349ea
   275a8:	000311a3 	.word	0x000311a3
   275ac:	00034992 	.word	0x00034992

000275b0 <z_unpend_thread>:
{
   275b0:	b538      	push	{r3, r4, r5, lr}
   275b2:	4604      	mov	r4, r0
	__asm__ volatile(
   275b4:	f04f 0320 	mov.w	r3, #32
   275b8:	f3ef 8511 	mrs	r5, BASEPRI
   275bc:	f383 8811 	msr	BASEPRI, r3
   275c0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   275c4:	481e      	ldr	r0, [pc, #120]	; (27640 <z_unpend_thread+0x90>)
   275c6:	f001 f88f 	bl	286e8 <z_spin_lock_valid>
   275ca:	b968      	cbnz	r0, 275e8 <z_unpend_thread+0x38>
   275cc:	234a      	movs	r3, #74	; 0x4a
   275ce:	4a1d      	ldr	r2, [pc, #116]	; (27644 <z_unpend_thread+0x94>)
   275d0:	491d      	ldr	r1, [pc, #116]	; (27648 <z_unpend_thread+0x98>)
   275d2:	481e      	ldr	r0, [pc, #120]	; (2764c <z_unpend_thread+0x9c>)
   275d4:	f005 fe39 	bl	2d24a <printk>
   275d8:	4919      	ldr	r1, [pc, #100]	; (27640 <z_unpend_thread+0x90>)
   275da:	481d      	ldr	r0, [pc, #116]	; (27650 <z_unpend_thread+0xa0>)
   275dc:	f005 fe35 	bl	2d24a <printk>
   275e0:	214a      	movs	r1, #74	; 0x4a
   275e2:	4818      	ldr	r0, [pc, #96]	; (27644 <z_unpend_thread+0x94>)
   275e4:	f005 fe77 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   275e8:	4815      	ldr	r0, [pc, #84]	; (27640 <z_unpend_thread+0x90>)
   275ea:	f001 f89b 	bl	28724 <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   275ee:	f104 0008 	add.w	r0, r4, #8
   275f2:	f7ff fdd1 	bl	27198 <pended_on.isra.17>
   275f6:	4621      	mov	r1, r4
   275f8:	f7ff ffac 	bl	27554 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   275fc:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   275fe:	4810      	ldr	r0, [pc, #64]	; (27640 <z_unpend_thread+0x90>)
   27600:	f023 0302 	bic.w	r3, r3, #2
   27604:	7363      	strb	r3, [r4, #13]
   27606:	f001 f87d 	bl	28704 <z_spin_unlock_valid>
   2760a:	b968      	cbnz	r0, 27628 <z_unpend_thread+0x78>
   2760c:	235d      	movs	r3, #93	; 0x5d
   2760e:	4a0d      	ldr	r2, [pc, #52]	; (27644 <z_unpend_thread+0x94>)
   27610:	4910      	ldr	r1, [pc, #64]	; (27654 <z_unpend_thread+0xa4>)
   27612:	480e      	ldr	r0, [pc, #56]	; (2764c <z_unpend_thread+0x9c>)
   27614:	f005 fe19 	bl	2d24a <printk>
   27618:	4909      	ldr	r1, [pc, #36]	; (27640 <z_unpend_thread+0x90>)
   2761a:	480f      	ldr	r0, [pc, #60]	; (27658 <z_unpend_thread+0xa8>)
   2761c:	f005 fe15 	bl	2d24a <printk>
   27620:	215d      	movs	r1, #93	; 0x5d
   27622:	4808      	ldr	r0, [pc, #32]	; (27644 <z_unpend_thread+0x94>)
   27624:	f005 fe57 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   27628:	f385 8811 	msr	BASEPRI, r5
   2762c:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   27630:	2300      	movs	r3, #0
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   27632:	f104 0018 	add.w	r0, r4, #24
   27636:	60a3      	str	r3, [r4, #8]
}
   27638:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2763c:	f001 bb94 	b.w	28d68 <z_abort_timeout>
   27640:	2002d320 	.word	0x2002d320
   27644:	00031168 	.word	0x00031168
   27648:	0003118e 	.word	0x0003118e
   2764c:	000311a3 	.word	0x000311a3
   27650:	000311c0 	.word	0x000311c0
   27654:	00031202 	.word	0x00031202
   27658:	00031219 	.word	0x00031219

0002765c <update_cache>:
{
   2765c:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   2765e:	4c15      	ldr	r4, [pc, #84]	; (276b4 <update_cache+0x58>)
{
   27660:	4602      	mov	r2, r0
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   27662:	f104 0028 	add.w	r0, r4, #40	; 0x28
   27666:	f007 fd09 	bl	2f07c <z_priq_dumb_best>
	return thread ? thread : _current_cpu->idle_thread;
   2766a:	4605      	mov	r5, r0
   2766c:	b900      	cbnz	r0, 27670 <update_cache+0x14>
   2766e:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
   27670:	b9ca      	cbnz	r2, 276a6 <update_cache+0x4a>
	__ASSERT(_current != NULL, "");
   27672:	68a3      	ldr	r3, [r4, #8]
   27674:	b963      	cbnz	r3, 27690 <update_cache+0x34>
   27676:	4910      	ldr	r1, [pc, #64]	; (276b8 <update_cache+0x5c>)
   27678:	237e      	movs	r3, #126	; 0x7e
   2767a:	4a10      	ldr	r2, [pc, #64]	; (276bc <update_cache+0x60>)
   2767c:	4810      	ldr	r0, [pc, #64]	; (276c0 <update_cache+0x64>)
   2767e:	f005 fde4 	bl	2d24a <printk>
   27682:	4810      	ldr	r0, [pc, #64]	; (276c4 <update_cache+0x68>)
   27684:	f005 fde1 	bl	2d24a <printk>
   27688:	217e      	movs	r1, #126	; 0x7e
   2768a:	480c      	ldr	r0, [pc, #48]	; (276bc <update_cache+0x60>)
   2768c:	f005 fe23 	bl	2d2d6 <assert_post_action>
	if (z_is_thread_prevented_from_running(_current)) {
   27690:	68a3      	ldr	r3, [r4, #8]
   27692:	7b5a      	ldrb	r2, [r3, #13]
   27694:	06d2      	lsls	r2, r2, #27
   27696:	d106      	bne.n	276a6 <update_cache+0x4a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   27698:	69aa      	ldr	r2, [r5, #24]
   2769a:	b922      	cbnz	r2, 276a6 <update_cache+0x4a>
	if (is_preempt(_current) || is_metairq(thread)) {
   2769c:	89da      	ldrh	r2, [r3, #14]
   2769e:	2a7f      	cmp	r2, #127	; 0x7f
   276a0:	d901      	bls.n	276a6 <update_cache+0x4a>
		_kernel.ready_q.cache = _current;
   276a2:	6263      	str	r3, [r4, #36]	; 0x24
}
   276a4:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
   276a6:	68a3      	ldr	r3, [r4, #8]
   276a8:	42ab      	cmp	r3, r5
   276aa:	d001      	beq.n	276b0 <update_cache+0x54>
			z_reset_time_slice();
   276ac:	f7ff fd8c 	bl	271c8 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   276b0:	6265      	str	r5, [r4, #36]	; 0x24
}
   276b2:	e7f7      	b.n	276a4 <update_cache+0x48>
   276b4:	2002d2e8 	.word	0x2002d2e8
   276b8:	000349cb 	.word	0x000349cb
   276bc:	00034992 	.word	0x00034992
   276c0:	000311a3 	.word	0x000311a3
   276c4:	00033242 	.word	0x00033242

000276c8 <k_sched_unlock>:
{
   276c8:	b538      	push	{r3, r4, r5, lr}
	__ASSERT(_current->base.sched_locked != 0, "");
   276ca:	4c31      	ldr	r4, [pc, #196]	; (27790 <k_sched_unlock+0xc8>)
   276cc:	68a2      	ldr	r2, [r4, #8]
   276ce:	7bd2      	ldrb	r2, [r2, #15]
   276d0:	b972      	cbnz	r2, 276f0 <k_sched_unlock+0x28>
   276d2:	4930      	ldr	r1, [pc, #192]	; (27794 <k_sched_unlock+0xcc>)
   276d4:	f240 23ad 	movw	r3, #685	; 0x2ad
   276d8:	4a2f      	ldr	r2, [pc, #188]	; (27798 <k_sched_unlock+0xd0>)
   276da:	4830      	ldr	r0, [pc, #192]	; (2779c <k_sched_unlock+0xd4>)
   276dc:	f005 fdb5 	bl	2d24a <printk>
   276e0:	482f      	ldr	r0, [pc, #188]	; (277a0 <k_sched_unlock+0xd8>)
   276e2:	f005 fdb2 	bl	2d24a <printk>
   276e6:	f240 21ad 	movw	r1, #685	; 0x2ad
   276ea:	482b      	ldr	r0, [pc, #172]	; (27798 <k_sched_unlock+0xd0>)
   276ec:	f005 fdf3 	bl	2d2d6 <assert_post_action>
   276f0:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   276f4:	b173      	cbz	r3, 27714 <k_sched_unlock+0x4c>
   276f6:	492b      	ldr	r1, [pc, #172]	; (277a4 <k_sched_unlock+0xdc>)
   276f8:	f240 23ae 	movw	r3, #686	; 0x2ae
   276fc:	4a26      	ldr	r2, [pc, #152]	; (27798 <k_sched_unlock+0xd0>)
   276fe:	4827      	ldr	r0, [pc, #156]	; (2779c <k_sched_unlock+0xd4>)
   27700:	f005 fda3 	bl	2d24a <printk>
   27704:	4826      	ldr	r0, [pc, #152]	; (277a0 <k_sched_unlock+0xd8>)
   27706:	f005 fda0 	bl	2d24a <printk>
   2770a:	f240 21ae 	movw	r1, #686	; 0x2ae
   2770e:	4822      	ldr	r0, [pc, #136]	; (27798 <k_sched_unlock+0xd0>)
   27710:	f005 fde1 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   27714:	f04f 0320 	mov.w	r3, #32
   27718:	f3ef 8511 	mrs	r5, BASEPRI
   2771c:	f383 8811 	msr	BASEPRI, r3
   27720:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27724:	4820      	ldr	r0, [pc, #128]	; (277a8 <k_sched_unlock+0xe0>)
   27726:	f000 ffdf 	bl	286e8 <z_spin_lock_valid>
   2772a:	b968      	cbnz	r0, 27748 <k_sched_unlock+0x80>
   2772c:	234a      	movs	r3, #74	; 0x4a
   2772e:	4a1f      	ldr	r2, [pc, #124]	; (277ac <k_sched_unlock+0xe4>)
   27730:	491f      	ldr	r1, [pc, #124]	; (277b0 <k_sched_unlock+0xe8>)
   27732:	481a      	ldr	r0, [pc, #104]	; (2779c <k_sched_unlock+0xd4>)
   27734:	f005 fd89 	bl	2d24a <printk>
   27738:	491b      	ldr	r1, [pc, #108]	; (277a8 <k_sched_unlock+0xe0>)
   2773a:	481e      	ldr	r0, [pc, #120]	; (277b4 <k_sched_unlock+0xec>)
   2773c:	f005 fd85 	bl	2d24a <printk>
   27740:	214a      	movs	r1, #74	; 0x4a
   27742:	481a      	ldr	r0, [pc, #104]	; (277ac <k_sched_unlock+0xe4>)
   27744:	f005 fdc7 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   27748:	4817      	ldr	r0, [pc, #92]	; (277a8 <k_sched_unlock+0xe0>)
   2774a:	f000 ffeb 	bl	28724 <z_spin_lock_set_owner>
		++_current->base.sched_locked;
   2774e:	68a2      	ldr	r2, [r4, #8]
		update_cache(0);
   27750:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   27752:	7bd3      	ldrb	r3, [r2, #15]
   27754:	3301      	adds	r3, #1
   27756:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   27758:	f7ff ff80 	bl	2765c <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2775c:	4812      	ldr	r0, [pc, #72]	; (277a8 <k_sched_unlock+0xe0>)
   2775e:	f000 ffd1 	bl	28704 <z_spin_unlock_valid>
   27762:	b968      	cbnz	r0, 27780 <k_sched_unlock+0xb8>
   27764:	235d      	movs	r3, #93	; 0x5d
   27766:	4a11      	ldr	r2, [pc, #68]	; (277ac <k_sched_unlock+0xe4>)
   27768:	4913      	ldr	r1, [pc, #76]	; (277b8 <k_sched_unlock+0xf0>)
   2776a:	480c      	ldr	r0, [pc, #48]	; (2779c <k_sched_unlock+0xd4>)
   2776c:	f005 fd6d 	bl	2d24a <printk>
   27770:	490d      	ldr	r1, [pc, #52]	; (277a8 <k_sched_unlock+0xe0>)
   27772:	4812      	ldr	r0, [pc, #72]	; (277bc <k_sched_unlock+0xf4>)
   27774:	f005 fd69 	bl	2d24a <printk>
   27778:	215d      	movs	r1, #93	; 0x5d
   2777a:	480c      	ldr	r0, [pc, #48]	; (277ac <k_sched_unlock+0xe4>)
   2777c:	f005 fdab 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   27780:	f385 8811 	msr	BASEPRI, r5
   27784:	f3bf 8f6f 	isb	sy
}
   27788:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_unlocked();
   2778c:	f007 bc6c 	b.w	2f068 <z_reschedule_unlocked>
   27790:	2002d2e8 	.word	0x2002d2e8
   27794:	00034934 	.word	0x00034934
   27798:	00034992 	.word	0x00034992
   2779c:	000311a3 	.word	0x000311a3
   277a0:	00033242 	.word	0x00033242
   277a4:	000348fa 	.word	0x000348fa
   277a8:	2002d320 	.word	0x2002d320
   277ac:	00031168 	.word	0x00031168
   277b0:	0003118e 	.word	0x0003118e
   277b4:	000311c0 	.word	0x000311c0
   277b8:	00031202 	.word	0x00031202
   277bc:	00031219 	.word	0x00031219

000277c0 <z_add_thread_to_ready_q>:
{
   277c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   277c2:	4604      	mov	r4, r0
	__asm__ volatile(
   277c4:	f04f 0320 	mov.w	r3, #32
   277c8:	f3ef 8511 	mrs	r5, BASEPRI
   277cc:	f383 8811 	msr	BASEPRI, r3
   277d0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   277d4:	482f      	ldr	r0, [pc, #188]	; (27894 <z_add_thread_to_ready_q+0xd4>)
   277d6:	f000 ff87 	bl	286e8 <z_spin_lock_valid>
   277da:	b968      	cbnz	r0, 277f8 <z_add_thread_to_ready_q+0x38>
   277dc:	234a      	movs	r3, #74	; 0x4a
   277de:	4a2e      	ldr	r2, [pc, #184]	; (27898 <z_add_thread_to_ready_q+0xd8>)
   277e0:	492e      	ldr	r1, [pc, #184]	; (2789c <z_add_thread_to_ready_q+0xdc>)
   277e2:	482f      	ldr	r0, [pc, #188]	; (278a0 <z_add_thread_to_ready_q+0xe0>)
   277e4:	f005 fd31 	bl	2d24a <printk>
   277e8:	492a      	ldr	r1, [pc, #168]	; (27894 <z_add_thread_to_ready_q+0xd4>)
   277ea:	482e      	ldr	r0, [pc, #184]	; (278a4 <z_add_thread_to_ready_q+0xe4>)
   277ec:	f005 fd2d 	bl	2d24a <printk>
   277f0:	214a      	movs	r1, #74	; 0x4a
   277f2:	4829      	ldr	r0, [pc, #164]	; (27898 <z_add_thread_to_ready_q+0xd8>)
   277f4:	f005 fd6f 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   277f8:	4826      	ldr	r0, [pc, #152]	; (27894 <z_add_thread_to_ready_q+0xd4>)
   277fa:	f000 ff93 	bl	28724 <z_spin_lock_set_owner>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   277fe:	4b2a      	ldr	r3, [pc, #168]	; (278a8 <z_add_thread_to_ready_q+0xe8>)
   27800:	429c      	cmp	r4, r3
   27802:	d10b      	bne.n	2781c <z_add_thread_to_ready_q+0x5c>
   27804:	4929      	ldr	r1, [pc, #164]	; (278ac <z_add_thread_to_ready_q+0xec>)
   27806:	4826      	ldr	r0, [pc, #152]	; (278a0 <z_add_thread_to_ready_q+0xe0>)
   27808:	f240 3302 	movw	r3, #770	; 0x302
   2780c:	4a28      	ldr	r2, [pc, #160]	; (278b0 <z_add_thread_to_ready_q+0xf0>)
   2780e:	f005 fd1c 	bl	2d24a <printk>
   27812:	f240 3102 	movw	r1, #770	; 0x302
   27816:	4826      	ldr	r0, [pc, #152]	; (278b0 <z_add_thread_to_ready_q+0xf0>)
   27818:	f005 fd5d 	bl	2d2d6 <assert_post_action>
	return list->head == list;
   2781c:	4a25      	ldr	r2, [pc, #148]	; (278b4 <z_add_thread_to_ready_q+0xf4>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2781e:	f102 0128 	add.w	r1, r2, #40	; 0x28
   27822:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
   27826:	428b      	cmp	r3, r1
   27828:	d02e      	beq.n	27888 <z_add_thread_to_ready_q+0xc8>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2782a:	b36b      	cbz	r3, 27888 <z_add_thread_to_ready_q+0xc8>
	if (thread_1->base.prio < thread_2->base.prio) {
   2782c:	f994 600e 	ldrsb.w	r6, [r4, #14]
   27830:	f993 700e 	ldrsb.w	r7, [r3, #14]
   27834:	42b7      	cmp	r7, r6
   27836:	dd22      	ble.n	2787e <z_add_thread_to_ready_q+0xbe>
	node->prev = successor->prev;
   27838:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   2783a:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   2783e:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   27840:	605c      	str	r4, [r3, #4]
	thread->base.thread_state |= states;
   27842:	7b63      	ldrb	r3, [r4, #13]
		update_cache(0);
   27844:	2000      	movs	r0, #0
   27846:	f063 037f 	orn	r3, r3, #127	; 0x7f
   2784a:	7363      	strb	r3, [r4, #13]
   2784c:	f7ff ff06 	bl	2765c <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27850:	4810      	ldr	r0, [pc, #64]	; (27894 <z_add_thread_to_ready_q+0xd4>)
   27852:	f000 ff57 	bl	28704 <z_spin_unlock_valid>
   27856:	b968      	cbnz	r0, 27874 <z_add_thread_to_ready_q+0xb4>
   27858:	235d      	movs	r3, #93	; 0x5d
   2785a:	4a0f      	ldr	r2, [pc, #60]	; (27898 <z_add_thread_to_ready_q+0xd8>)
   2785c:	4916      	ldr	r1, [pc, #88]	; (278b8 <z_add_thread_to_ready_q+0xf8>)
   2785e:	4810      	ldr	r0, [pc, #64]	; (278a0 <z_add_thread_to_ready_q+0xe0>)
   27860:	f005 fcf3 	bl	2d24a <printk>
   27864:	490b      	ldr	r1, [pc, #44]	; (27894 <z_add_thread_to_ready_q+0xd4>)
   27866:	4815      	ldr	r0, [pc, #84]	; (278bc <z_add_thread_to_ready_q+0xfc>)
   27868:	f005 fcef 	bl	2d24a <printk>
   2786c:	215d      	movs	r1, #93	; 0x5d
   2786e:	480a      	ldr	r0, [pc, #40]	; (27898 <z_add_thread_to_ready_q+0xd8>)
   27870:	f005 fd31 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   27874:	f385 8811 	msr	BASEPRI, r5
   27878:	f3bf 8f6f 	isb	sy
}
   2787c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   2787e:	4298      	cmp	r0, r3
   27880:	d002      	beq.n	27888 <z_add_thread_to_ready_q+0xc8>
   27882:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   27884:	2b00      	cmp	r3, #0
   27886:	d1d3      	bne.n	27830 <z_add_thread_to_ready_q+0x70>
	node->prev = list->tail;
   27888:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   2788c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   2788e:	601c      	str	r4, [r3, #0]
	list->tail = node;
   27890:	62d4      	str	r4, [r2, #44]	; 0x2c
   27892:	e7d6      	b.n	27842 <z_add_thread_to_ready_q+0x82>
   27894:	2002d320 	.word	0x2002d320
   27898:	00031168 	.word	0x00031168
   2789c:	0003118e 	.word	0x0003118e
   278a0:	000311a3 	.word	0x000311a3
   278a4:	000311c0 	.word	0x000311c0
   278a8:	20029118 	.word	0x20029118
   278ac:	000349ea 	.word	0x000349ea
   278b0:	00034992 	.word	0x00034992
   278b4:	2002d2e8 	.word	0x2002d2e8
   278b8:	00031202 	.word	0x00031202
   278bc:	00031219 	.word	0x00031219

000278c0 <z_thread_timeout>:
	if (thread->base.pended_on != NULL) {
   278c0:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
   278c4:	b570      	push	{r4, r5, r6, lr}
   278c6:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
   278c8:	f1a0 0518 	sub.w	r5, r0, #24
	if (thread->base.pended_on != NULL) {
   278cc:	2b00      	cmp	r3, #0
   278ce:	d042      	beq.n	27956 <z_thread_timeout+0x96>
	__asm__ volatile(
   278d0:	f04f 0320 	mov.w	r3, #32
   278d4:	f3ef 8611 	mrs	r6, BASEPRI
   278d8:	f383 8811 	msr	BASEPRI, r3
   278dc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   278e0:	4825      	ldr	r0, [pc, #148]	; (27978 <z_thread_timeout+0xb8>)
   278e2:	f000 ff01 	bl	286e8 <z_spin_lock_valid>
   278e6:	b968      	cbnz	r0, 27904 <z_thread_timeout+0x44>
   278e8:	234a      	movs	r3, #74	; 0x4a
   278ea:	4a24      	ldr	r2, [pc, #144]	; (2797c <z_thread_timeout+0xbc>)
   278ec:	4924      	ldr	r1, [pc, #144]	; (27980 <z_thread_timeout+0xc0>)
   278ee:	4825      	ldr	r0, [pc, #148]	; (27984 <z_thread_timeout+0xc4>)
   278f0:	f005 fcab 	bl	2d24a <printk>
   278f4:	4920      	ldr	r1, [pc, #128]	; (27978 <z_thread_timeout+0xb8>)
   278f6:	4824      	ldr	r0, [pc, #144]	; (27988 <z_thread_timeout+0xc8>)
   278f8:	f005 fca7 	bl	2d24a <printk>
   278fc:	214a      	movs	r1, #74	; 0x4a
   278fe:	481f      	ldr	r0, [pc, #124]	; (2797c <z_thread_timeout+0xbc>)
   27900:	f005 fce9 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   27904:	481c      	ldr	r0, [pc, #112]	; (27978 <z_thread_timeout+0xb8>)
   27906:	f000 ff0d 	bl	28724 <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   2790a:	f1a4 0010 	sub.w	r0, r4, #16
   2790e:	f7ff fc43 	bl	27198 <pended_on.isra.17>
   27912:	4629      	mov	r1, r5
   27914:	f7ff fe1e 	bl	27554 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   27918:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2791c:	4816      	ldr	r0, [pc, #88]	; (27978 <z_thread_timeout+0xb8>)
   2791e:	f023 0302 	bic.w	r3, r3, #2
   27922:	f804 3c0b 	strb.w	r3, [r4, #-11]
   27926:	f000 feed 	bl	28704 <z_spin_unlock_valid>
   2792a:	b968      	cbnz	r0, 27948 <z_thread_timeout+0x88>
   2792c:	235d      	movs	r3, #93	; 0x5d
   2792e:	4a13      	ldr	r2, [pc, #76]	; (2797c <z_thread_timeout+0xbc>)
   27930:	4916      	ldr	r1, [pc, #88]	; (2798c <z_thread_timeout+0xcc>)
   27932:	4814      	ldr	r0, [pc, #80]	; (27984 <z_thread_timeout+0xc4>)
   27934:	f005 fc89 	bl	2d24a <printk>
   27938:	490f      	ldr	r1, [pc, #60]	; (27978 <z_thread_timeout+0xb8>)
   2793a:	4815      	ldr	r0, [pc, #84]	; (27990 <z_thread_timeout+0xd0>)
   2793c:	f005 fc85 	bl	2d24a <printk>
   27940:	215d      	movs	r1, #93	; 0x5d
   27942:	480e      	ldr	r0, [pc, #56]	; (2797c <z_thread_timeout+0xbc>)
   27944:	f005 fcc7 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   27948:	f386 8811 	msr	BASEPRI, r6
   2794c:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   27950:	2300      	movs	r3, #0
   27952:	f844 3c10 	str.w	r3, [r4, #-16]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   27956:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
   2795a:	4628      	mov	r0, r5
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   2795c:	f023 0314 	bic.w	r3, r3, #20
   27960:	f804 3c0b 	strb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
   27964:	f007 fb62 	bl	2f02c <z_is_thread_ready>
   27968:	b120      	cbz	r0, 27974 <z_thread_timeout+0xb4>
		z_add_thread_to_ready_q(thread);
   2796a:	4628      	mov	r0, r5
}
   2796c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   27970:	f7ff bf26 	b.w	277c0 <z_add_thread_to_ready_q>
   27974:	bd70      	pop	{r4, r5, r6, pc}
   27976:	bf00      	nop
   27978:	2002d320 	.word	0x2002d320
   2797c:	00031168 	.word	0x00031168
   27980:	0003118e 	.word	0x0003118e
   27984:	000311a3 	.word	0x000311a3
   27988:	000311c0 	.word	0x000311c0
   2798c:	00031202 	.word	0x00031202
   27990:	00031219 	.word	0x00031219

00027994 <z_move_thread_to_end_of_prio_q>:
{
   27994:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   27996:	4604      	mov	r4, r0
	__asm__ volatile(
   27998:	f04f 0320 	mov.w	r3, #32
   2799c:	f3ef 8511 	mrs	r5, BASEPRI
   279a0:	f383 8811 	msr	BASEPRI, r3
   279a4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   279a8:	4835      	ldr	r0, [pc, #212]	; (27a80 <z_move_thread_to_end_of_prio_q+0xec>)
   279aa:	f000 fe9d 	bl	286e8 <z_spin_lock_valid>
   279ae:	b968      	cbnz	r0, 279cc <z_move_thread_to_end_of_prio_q+0x38>
   279b0:	234a      	movs	r3, #74	; 0x4a
   279b2:	4a34      	ldr	r2, [pc, #208]	; (27a84 <z_move_thread_to_end_of_prio_q+0xf0>)
   279b4:	4934      	ldr	r1, [pc, #208]	; (27a88 <z_move_thread_to_end_of_prio_q+0xf4>)
   279b6:	4835      	ldr	r0, [pc, #212]	; (27a8c <z_move_thread_to_end_of_prio_q+0xf8>)
   279b8:	f005 fc47 	bl	2d24a <printk>
   279bc:	4930      	ldr	r1, [pc, #192]	; (27a80 <z_move_thread_to_end_of_prio_q+0xec>)
   279be:	4834      	ldr	r0, [pc, #208]	; (27a90 <z_move_thread_to_end_of_prio_q+0xfc>)
   279c0:	f005 fc43 	bl	2d24a <printk>
   279c4:	214a      	movs	r1, #74	; 0x4a
   279c6:	482f      	ldr	r0, [pc, #188]	; (27a84 <z_move_thread_to_end_of_prio_q+0xf0>)
   279c8:	f005 fc85 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   279cc:	482c      	ldr	r0, [pc, #176]	; (27a80 <z_move_thread_to_end_of_prio_q+0xec>)
   279ce:	f000 fea9 	bl	28724 <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
   279d2:	f994 300d 	ldrsb.w	r3, [r4, #13]
   279d6:	2b00      	cmp	r3, #0
   279d8:	da03      	bge.n	279e2 <z_move_thread_to_end_of_prio_q+0x4e>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   279da:	4621      	mov	r1, r4
   279dc:	482d      	ldr	r0, [pc, #180]	; (27a94 <z_move_thread_to_end_of_prio_q+0x100>)
   279de:	f7ff fdb9 	bl	27554 <z_priq_dumb_remove>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   279e2:	4b2d      	ldr	r3, [pc, #180]	; (27a98 <z_move_thread_to_end_of_prio_q+0x104>)
   279e4:	429c      	cmp	r4, r3
   279e6:	d10b      	bne.n	27a00 <z_move_thread_to_end_of_prio_q+0x6c>
   279e8:	492c      	ldr	r1, [pc, #176]	; (27a9c <z_move_thread_to_end_of_prio_q+0x108>)
   279ea:	4828      	ldr	r0, [pc, #160]	; (27a8c <z_move_thread_to_end_of_prio_q+0xf8>)
   279ec:	f240 3302 	movw	r3, #770	; 0x302
   279f0:	4a2b      	ldr	r2, [pc, #172]	; (27aa0 <z_move_thread_to_end_of_prio_q+0x10c>)
   279f2:	f005 fc2a 	bl	2d24a <printk>
   279f6:	f240 3102 	movw	r1, #770	; 0x302
   279fa:	4829      	ldr	r0, [pc, #164]	; (27aa0 <z_move_thread_to_end_of_prio_q+0x10c>)
   279fc:	f005 fc6b 	bl	2d2d6 <assert_post_action>
	return list->head == list;
   27a00:	4a28      	ldr	r2, [pc, #160]	; (27aa4 <z_move_thread_to_end_of_prio_q+0x110>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
   27a02:	f102 0128 	add.w	r1, r2, #40	; 0x28
   27a06:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
   27a0a:	428b      	cmp	r3, r1
   27a0c:	d032      	beq.n	27a74 <z_move_thread_to_end_of_prio_q+0xe0>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   27a0e:	2b00      	cmp	r3, #0
   27a10:	d030      	beq.n	27a74 <z_move_thread_to_end_of_prio_q+0xe0>
	if (thread_1->base.prio < thread_2->base.prio) {
   27a12:	f994 600e 	ldrsb.w	r6, [r4, #14]
   27a16:	f993 700e 	ldrsb.w	r7, [r3, #14]
   27a1a:	42b7      	cmp	r7, r6
   27a1c:	dd25      	ble.n	27a6a <z_move_thread_to_end_of_prio_q+0xd6>
	node->prev = successor->prev;
   27a1e:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   27a20:	e9c4 3100 	strd	r3, r1, [r4]
	successor->prev->next = node;
   27a24:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   27a26:	605c      	str	r4, [r3, #4]
	thread->base.thread_state |= states;
   27a28:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
   27a2a:	6890      	ldr	r0, [r2, #8]
   27a2c:	f063 037f 	orn	r3, r3, #127	; 0x7f
   27a30:	7363      	strb	r3, [r4, #13]
   27a32:	1b03      	subs	r3, r0, r4
   27a34:	4258      	negs	r0, r3
   27a36:	4158      	adcs	r0, r3
   27a38:	f7ff fe10 	bl	2765c <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27a3c:	4810      	ldr	r0, [pc, #64]	; (27a80 <z_move_thread_to_end_of_prio_q+0xec>)
   27a3e:	f000 fe61 	bl	28704 <z_spin_unlock_valid>
   27a42:	b968      	cbnz	r0, 27a60 <z_move_thread_to_end_of_prio_q+0xcc>
   27a44:	235d      	movs	r3, #93	; 0x5d
   27a46:	4a0f      	ldr	r2, [pc, #60]	; (27a84 <z_move_thread_to_end_of_prio_q+0xf0>)
   27a48:	4917      	ldr	r1, [pc, #92]	; (27aa8 <z_move_thread_to_end_of_prio_q+0x114>)
   27a4a:	4810      	ldr	r0, [pc, #64]	; (27a8c <z_move_thread_to_end_of_prio_q+0xf8>)
   27a4c:	f005 fbfd 	bl	2d24a <printk>
   27a50:	490b      	ldr	r1, [pc, #44]	; (27a80 <z_move_thread_to_end_of_prio_q+0xec>)
   27a52:	4816      	ldr	r0, [pc, #88]	; (27aac <z_move_thread_to_end_of_prio_q+0x118>)
   27a54:	f005 fbf9 	bl	2d24a <printk>
   27a58:	215d      	movs	r1, #93	; 0x5d
   27a5a:	480a      	ldr	r0, [pc, #40]	; (27a84 <z_move_thread_to_end_of_prio_q+0xf0>)
   27a5c:	f005 fc3b 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   27a60:	f385 8811 	msr	BASEPRI, r5
   27a64:	f3bf 8f6f 	isb	sy
}
   27a68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   27a6a:	4298      	cmp	r0, r3
   27a6c:	d002      	beq.n	27a74 <z_move_thread_to_end_of_prio_q+0xe0>
   27a6e:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   27a70:	2b00      	cmp	r3, #0
   27a72:	d1d0      	bne.n	27a16 <z_move_thread_to_end_of_prio_q+0x82>
	node->prev = list->tail;
   27a74:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   27a78:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   27a7a:	601c      	str	r4, [r3, #0]
	list->tail = node;
   27a7c:	62d4      	str	r4, [r2, #44]	; 0x2c
   27a7e:	e7d3      	b.n	27a28 <z_move_thread_to_end_of_prio_q+0x94>
   27a80:	2002d320 	.word	0x2002d320
   27a84:	00031168 	.word	0x00031168
   27a88:	0003118e 	.word	0x0003118e
   27a8c:	000311a3 	.word	0x000311a3
   27a90:	000311c0 	.word	0x000311c0
   27a94:	2002d310 	.word	0x2002d310
   27a98:	20029118 	.word	0x20029118
   27a9c:	000349ea 	.word	0x000349ea
   27aa0:	00034992 	.word	0x00034992
   27aa4:	2002d2e8 	.word	0x2002d2e8
   27aa8:	00031202 	.word	0x00031202
   27aac:	00031219 	.word	0x00031219

00027ab0 <z_time_slice>:
	if (pending_current == _current) {
   27ab0:	4a15      	ldr	r2, [pc, #84]	; (27b08 <z_time_slice+0x58>)
   27ab2:	4916      	ldr	r1, [pc, #88]	; (27b0c <z_time_slice+0x5c>)
{
   27ab4:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
   27ab6:	680c      	ldr	r4, [r1, #0]
   27ab8:	6893      	ldr	r3, [r2, #8]
   27aba:	42a3      	cmp	r3, r4
   27abc:	4614      	mov	r4, r2
   27abe:	d103      	bne.n	27ac8 <z_time_slice+0x18>
}
   27ac0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
   27ac4:	f7ff bb80 	b.w	271c8 <z_reset_time_slice>
	pending_current = NULL;
   27ac8:	2500      	movs	r5, #0
   27aca:	600d      	str	r5, [r1, #0]
	if (slice_time && sliceable(_current)) {
   27acc:	4910      	ldr	r1, [pc, #64]	; (27b10 <z_time_slice+0x60>)
   27ace:	6809      	ldr	r1, [r1, #0]
   27ad0:	b1b9      	cbz	r1, 27b02 <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   27ad2:	89d9      	ldrh	r1, [r3, #14]
   27ad4:	297f      	cmp	r1, #127	; 0x7f
   27ad6:	d814      	bhi.n	27b02 <z_time_slice+0x52>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   27ad8:	490e      	ldr	r1, [pc, #56]	; (27b14 <z_time_slice+0x64>)
   27ada:	f993 500e 	ldrsb.w	r5, [r3, #14]
   27ade:	6809      	ldr	r1, [r1, #0]
   27ae0:	428d      	cmp	r5, r1
   27ae2:	db0e      	blt.n	27b02 <z_time_slice+0x52>
		&& !z_is_idle_thread_object(thread)
   27ae4:	490c      	ldr	r1, [pc, #48]	; (27b18 <z_time_slice+0x68>)
   27ae6:	428b      	cmp	r3, r1
   27ae8:	d00b      	beq.n	27b02 <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   27aea:	6999      	ldr	r1, [r3, #24]
   27aec:	b949      	cbnz	r1, 27b02 <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
   27aee:	6911      	ldr	r1, [r2, #16]
   27af0:	4281      	cmp	r1, r0
   27af2:	dc03      	bgt.n	27afc <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
   27af4:	4618      	mov	r0, r3
   27af6:	f7ff ff4d 	bl	27994 <z_move_thread_to_end_of_prio_q>
   27afa:	e7e1      	b.n	27ac0 <z_time_slice+0x10>
			_current_cpu->slice_ticks -= ticks;
   27afc:	1a09      	subs	r1, r1, r0
   27afe:	6111      	str	r1, [r2, #16]
}
   27b00:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
   27b02:	2300      	movs	r3, #0
   27b04:	6123      	str	r3, [r4, #16]
   27b06:	e7fb      	b.n	27b00 <z_time_slice+0x50>
   27b08:	2002d2e8 	.word	0x2002d2e8
   27b0c:	2002d31c 	.word	0x2002d31c
   27b10:	2002d328 	.word	0x2002d328
   27b14:	2002d324 	.word	0x2002d324
   27b18:	20029118 	.word	0x20029118

00027b1c <z_thread_single_suspend>:
{
   27b1c:	b570      	push	{r4, r5, r6, lr}
   27b1e:	4604      	mov	r4, r0
   27b20:	3018      	adds	r0, #24
   27b22:	f001 f921 	bl	28d68 <z_abort_timeout>
	__asm__ volatile(
   27b26:	f04f 0320 	mov.w	r3, #32
   27b2a:	f3ef 8611 	mrs	r6, BASEPRI
   27b2e:	f383 8811 	msr	BASEPRI, r3
   27b32:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27b36:	4825      	ldr	r0, [pc, #148]	; (27bcc <z_thread_single_suspend+0xb0>)
   27b38:	f000 fdd6 	bl	286e8 <z_spin_lock_valid>
   27b3c:	b968      	cbnz	r0, 27b5a <z_thread_single_suspend+0x3e>
   27b3e:	234a      	movs	r3, #74	; 0x4a
   27b40:	4a23      	ldr	r2, [pc, #140]	; (27bd0 <z_thread_single_suspend+0xb4>)
   27b42:	4924      	ldr	r1, [pc, #144]	; (27bd4 <z_thread_single_suspend+0xb8>)
   27b44:	4824      	ldr	r0, [pc, #144]	; (27bd8 <z_thread_single_suspend+0xbc>)
   27b46:	f005 fb80 	bl	2d24a <printk>
   27b4a:	4920      	ldr	r1, [pc, #128]	; (27bcc <z_thread_single_suspend+0xb0>)
   27b4c:	4823      	ldr	r0, [pc, #140]	; (27bdc <z_thread_single_suspend+0xc0>)
   27b4e:	f005 fb7c 	bl	2d24a <printk>
   27b52:	214a      	movs	r1, #74	; 0x4a
   27b54:	481e      	ldr	r0, [pc, #120]	; (27bd0 <z_thread_single_suspend+0xb4>)
   27b56:	f005 fbbe 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   27b5a:	481c      	ldr	r0, [pc, #112]	; (27bcc <z_thread_single_suspend+0xb0>)
   27b5c:	f000 fde2 	bl	28724 <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
   27b60:	f994 300d 	ldrsb.w	r3, [r4, #13]
   27b64:	2b00      	cmp	r3, #0
   27b66:	da07      	bge.n	27b78 <z_thread_single_suspend+0x5c>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   27b68:	4621      	mov	r1, r4
   27b6a:	481d      	ldr	r0, [pc, #116]	; (27be0 <z_thread_single_suspend+0xc4>)
   27b6c:	f7ff fcf2 	bl	27554 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   27b70:	7b63      	ldrb	r3, [r4, #13]
   27b72:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   27b76:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   27b78:	4d1a      	ldr	r5, [pc, #104]	; (27be4 <z_thread_single_suspend+0xc8>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   27b7a:	7b63      	ldrb	r3, [r4, #13]
   27b7c:	68a8      	ldr	r0, [r5, #8]
   27b7e:	f043 0310 	orr.w	r3, r3, #16
   27b82:	7363      	strb	r3, [r4, #13]
   27b84:	1b03      	subs	r3, r0, r4
   27b86:	4258      	negs	r0, r3
   27b88:	4158      	adcs	r0, r3
   27b8a:	f7ff fd67 	bl	2765c <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27b8e:	480f      	ldr	r0, [pc, #60]	; (27bcc <z_thread_single_suspend+0xb0>)
   27b90:	f000 fdb8 	bl	28704 <z_spin_unlock_valid>
   27b94:	b968      	cbnz	r0, 27bb2 <z_thread_single_suspend+0x96>
   27b96:	235d      	movs	r3, #93	; 0x5d
   27b98:	4a0d      	ldr	r2, [pc, #52]	; (27bd0 <z_thread_single_suspend+0xb4>)
   27b9a:	4913      	ldr	r1, [pc, #76]	; (27be8 <z_thread_single_suspend+0xcc>)
   27b9c:	480e      	ldr	r0, [pc, #56]	; (27bd8 <z_thread_single_suspend+0xbc>)
   27b9e:	f005 fb54 	bl	2d24a <printk>
   27ba2:	490a      	ldr	r1, [pc, #40]	; (27bcc <z_thread_single_suspend+0xb0>)
   27ba4:	4811      	ldr	r0, [pc, #68]	; (27bec <z_thread_single_suspend+0xd0>)
   27ba6:	f005 fb50 	bl	2d24a <printk>
   27baa:	215d      	movs	r1, #93	; 0x5d
   27bac:	4808      	ldr	r0, [pc, #32]	; (27bd0 <z_thread_single_suspend+0xb4>)
   27bae:	f005 fb92 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   27bb2:	f386 8811 	msr	BASEPRI, r6
   27bb6:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   27bba:	68ab      	ldr	r3, [r5, #8]
   27bbc:	42a3      	cmp	r3, r4
   27bbe:	d103      	bne.n	27bc8 <z_thread_single_suspend+0xac>
}
   27bc0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   27bc4:	f007 ba50 	b.w	2f068 <z_reschedule_unlocked>
}
   27bc8:	bd70      	pop	{r4, r5, r6, pc}
   27bca:	bf00      	nop
   27bcc:	2002d320 	.word	0x2002d320
   27bd0:	00031168 	.word	0x00031168
   27bd4:	0003118e 	.word	0x0003118e
   27bd8:	000311a3 	.word	0x000311a3
   27bdc:	000311c0 	.word	0x000311c0
   27be0:	2002d310 	.word	0x2002d310
   27be4:	2002d2e8 	.word	0x2002d2e8
   27be8:	00031202 	.word	0x00031202
   27bec:	00031219 	.word	0x00031219

00027bf0 <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
   27bf0:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
   27bf2:	b570      	push	{r4, r5, r6, lr}
   27bf4:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
   27bf6:	b103      	cbz	r3, 27bfa <z_thread_single_abort+0xa>
		thread->fn_abort();
   27bf8:	4798      	blx	r3
   27bfa:	f104 0018 	add.w	r0, r4, #24
   27bfe:	f001 f8b3 	bl	28d68 <z_abort_timeout>
	__asm__ volatile(
   27c02:	f04f 0320 	mov.w	r3, #32
   27c06:	f3ef 8511 	mrs	r5, BASEPRI
   27c0a:	f383 8811 	msr	BASEPRI, r3
   27c0e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27c12:	482c      	ldr	r0, [pc, #176]	; (27cc4 <z_thread_single_abort+0xd4>)
   27c14:	f000 fd68 	bl	286e8 <z_spin_lock_valid>
   27c18:	b968      	cbnz	r0, 27c36 <z_thread_single_abort+0x46>
   27c1a:	234a      	movs	r3, #74	; 0x4a
   27c1c:	4a2a      	ldr	r2, [pc, #168]	; (27cc8 <z_thread_single_abort+0xd8>)
   27c1e:	492b      	ldr	r1, [pc, #172]	; (27ccc <z_thread_single_abort+0xdc>)
   27c20:	482b      	ldr	r0, [pc, #172]	; (27cd0 <z_thread_single_abort+0xe0>)
   27c22:	f005 fb12 	bl	2d24a <printk>
   27c26:	4927      	ldr	r1, [pc, #156]	; (27cc4 <z_thread_single_abort+0xd4>)
   27c28:	482a      	ldr	r0, [pc, #168]	; (27cd4 <z_thread_single_abort+0xe4>)
   27c2a:	f005 fb0e 	bl	2d24a <printk>
   27c2e:	214a      	movs	r1, #74	; 0x4a
   27c30:	4825      	ldr	r0, [pc, #148]	; (27cc8 <z_thread_single_abort+0xd8>)
   27c32:	f005 fb50 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   27c36:	4823      	ldr	r0, [pc, #140]	; (27cc4 <z_thread_single_abort+0xd4>)
   27c38:	f000 fd74 	bl	28724 <z_spin_lock_set_owner>
		if (z_is_thread_ready(thread)) {
   27c3c:	4620      	mov	r0, r4
   27c3e:	f007 f9f5 	bl	2f02c <z_is_thread_ready>
   27c42:	4606      	mov	r6, r0
   27c44:	b368      	cbz	r0, 27ca2 <z_thread_single_abort+0xb2>
			if (z_is_thread_queued(thread)) {
   27c46:	f994 300d 	ldrsb.w	r3, [r4, #13]
   27c4a:	2b00      	cmp	r3, #0
   27c4c:	da07      	bge.n	27c5e <z_thread_single_abort+0x6e>
				_priq_run_remove(&_kernel.ready_q.runq,
   27c4e:	4621      	mov	r1, r4
   27c50:	4821      	ldr	r0, [pc, #132]	; (27cd8 <z_thread_single_abort+0xe8>)
   27c52:	f7ff fc7f 	bl	27554 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   27c56:	7b63      	ldrb	r3, [r4, #13]
   27c58:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   27c5c:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
   27c5e:	4b1f      	ldr	r3, [pc, #124]	; (27cdc <z_thread_single_abort+0xec>)
   27c60:	6898      	ldr	r0, [r3, #8]
   27c62:	1b02      	subs	r2, r0, r4
   27c64:	4250      	negs	r0, r2
   27c66:	4150      	adcs	r0, r2
   27c68:	f7ff fcf8 	bl	2765c <update_cache>
		thread->base.thread_state |= mask;
   27c6c:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27c6e:	4815      	ldr	r0, [pc, #84]	; (27cc4 <z_thread_single_abort+0xd4>)
   27c70:	f043 0308 	orr.w	r3, r3, #8
   27c74:	7363      	strb	r3, [r4, #13]
   27c76:	f000 fd45 	bl	28704 <z_spin_unlock_valid>
   27c7a:	b968      	cbnz	r0, 27c98 <z_thread_single_abort+0xa8>
   27c7c:	235d      	movs	r3, #93	; 0x5d
   27c7e:	4a12      	ldr	r2, [pc, #72]	; (27cc8 <z_thread_single_abort+0xd8>)
   27c80:	4917      	ldr	r1, [pc, #92]	; (27ce0 <z_thread_single_abort+0xf0>)
   27c82:	4813      	ldr	r0, [pc, #76]	; (27cd0 <z_thread_single_abort+0xe0>)
   27c84:	f005 fae1 	bl	2d24a <printk>
   27c88:	490e      	ldr	r1, [pc, #56]	; (27cc4 <z_thread_single_abort+0xd4>)
   27c8a:	4816      	ldr	r0, [pc, #88]	; (27ce4 <z_thread_single_abort+0xf4>)
   27c8c:	f005 fadd 	bl	2d24a <printk>
   27c90:	215d      	movs	r1, #93	; 0x5d
   27c92:	480d      	ldr	r0, [pc, #52]	; (27cc8 <z_thread_single_abort+0xd8>)
   27c94:	f005 fb1f 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   27c98:	f385 8811 	msr	BASEPRI, r5
   27c9c:	f3bf 8f6f 	isb	sy
}
   27ca0:	bd70      	pop	{r4, r5, r6, pc}
			if (z_is_thread_pending(thread)) {
   27ca2:	7b63      	ldrb	r3, [r4, #13]
   27ca4:	079b      	lsls	r3, r3, #30
   27ca6:	d5e1      	bpl.n	27c6c <z_thread_single_abort+0x7c>
				_priq_wait_remove(&pended_on(thread)->waitq,
   27ca8:	f104 0008 	add.w	r0, r4, #8
   27cac:	f7ff fa74 	bl	27198 <pended_on.isra.17>
   27cb0:	4621      	mov	r1, r4
   27cb2:	f7ff fc4f 	bl	27554 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   27cb6:	7b63      	ldrb	r3, [r4, #13]
				thread->base.pended_on = NULL;
   27cb8:	60a6      	str	r6, [r4, #8]
   27cba:	f023 0302 	bic.w	r3, r3, #2
   27cbe:	7363      	strb	r3, [r4, #13]
   27cc0:	e7d4      	b.n	27c6c <z_thread_single_abort+0x7c>
   27cc2:	bf00      	nop
   27cc4:	2002d320 	.word	0x2002d320
   27cc8:	00031168 	.word	0x00031168
   27ccc:	0003118e 	.word	0x0003118e
   27cd0:	000311a3 	.word	0x000311a3
   27cd4:	000311c0 	.word	0x000311c0
   27cd8:	2002d310 	.word	0x2002d310
   27cdc:	2002d2e8 	.word	0x2002d2e8
   27ce0:	00031202 	.word	0x00031202
   27ce4:	00031219 	.word	0x00031219

00027ce8 <z_remove_thread_from_ready_q>:
{
   27ce8:	b538      	push	{r3, r4, r5, lr}
   27cea:	4604      	mov	r4, r0
	__asm__ volatile(
   27cec:	f04f 0320 	mov.w	r3, #32
   27cf0:	f3ef 8511 	mrs	r5, BASEPRI
   27cf4:	f383 8811 	msr	BASEPRI, r3
   27cf8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27cfc:	481f      	ldr	r0, [pc, #124]	; (27d7c <z_remove_thread_from_ready_q+0x94>)
   27cfe:	f000 fcf3 	bl	286e8 <z_spin_lock_valid>
   27d02:	b968      	cbnz	r0, 27d20 <z_remove_thread_from_ready_q+0x38>
   27d04:	234a      	movs	r3, #74	; 0x4a
   27d06:	4a1e      	ldr	r2, [pc, #120]	; (27d80 <z_remove_thread_from_ready_q+0x98>)
   27d08:	491e      	ldr	r1, [pc, #120]	; (27d84 <z_remove_thread_from_ready_q+0x9c>)
   27d0a:	481f      	ldr	r0, [pc, #124]	; (27d88 <z_remove_thread_from_ready_q+0xa0>)
   27d0c:	f005 fa9d 	bl	2d24a <printk>
   27d10:	491a      	ldr	r1, [pc, #104]	; (27d7c <z_remove_thread_from_ready_q+0x94>)
   27d12:	481e      	ldr	r0, [pc, #120]	; (27d8c <z_remove_thread_from_ready_q+0xa4>)
   27d14:	f005 fa99 	bl	2d24a <printk>
   27d18:	214a      	movs	r1, #74	; 0x4a
   27d1a:	4819      	ldr	r0, [pc, #100]	; (27d80 <z_remove_thread_from_ready_q+0x98>)
   27d1c:	f005 fadb 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   27d20:	4816      	ldr	r0, [pc, #88]	; (27d7c <z_remove_thread_from_ready_q+0x94>)
   27d22:	f000 fcff 	bl	28724 <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
   27d26:	f994 300d 	ldrsb.w	r3, [r4, #13]
   27d2a:	2b00      	cmp	r3, #0
   27d2c:	da07      	bge.n	27d3e <z_remove_thread_from_ready_q+0x56>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   27d2e:	4621      	mov	r1, r4
   27d30:	4817      	ldr	r0, [pc, #92]	; (27d90 <z_remove_thread_from_ready_q+0xa8>)
   27d32:	f7ff fc0f 	bl	27554 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   27d36:	7b63      	ldrb	r3, [r4, #13]
   27d38:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   27d3c:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   27d3e:	4b15      	ldr	r3, [pc, #84]	; (27d94 <z_remove_thread_from_ready_q+0xac>)
   27d40:	6898      	ldr	r0, [r3, #8]
   27d42:	1b03      	subs	r3, r0, r4
   27d44:	4258      	negs	r0, r3
   27d46:	4158      	adcs	r0, r3
   27d48:	f7ff fc88 	bl	2765c <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27d4c:	480b      	ldr	r0, [pc, #44]	; (27d7c <z_remove_thread_from_ready_q+0x94>)
   27d4e:	f000 fcd9 	bl	28704 <z_spin_unlock_valid>
   27d52:	b968      	cbnz	r0, 27d70 <z_remove_thread_from_ready_q+0x88>
   27d54:	235d      	movs	r3, #93	; 0x5d
   27d56:	4a0a      	ldr	r2, [pc, #40]	; (27d80 <z_remove_thread_from_ready_q+0x98>)
   27d58:	490f      	ldr	r1, [pc, #60]	; (27d98 <z_remove_thread_from_ready_q+0xb0>)
   27d5a:	480b      	ldr	r0, [pc, #44]	; (27d88 <z_remove_thread_from_ready_q+0xa0>)
   27d5c:	f005 fa75 	bl	2d24a <printk>
   27d60:	4906      	ldr	r1, [pc, #24]	; (27d7c <z_remove_thread_from_ready_q+0x94>)
   27d62:	480e      	ldr	r0, [pc, #56]	; (27d9c <z_remove_thread_from_ready_q+0xb4>)
   27d64:	f005 fa71 	bl	2d24a <printk>
   27d68:	215d      	movs	r1, #93	; 0x5d
   27d6a:	4805      	ldr	r0, [pc, #20]	; (27d80 <z_remove_thread_from_ready_q+0x98>)
   27d6c:	f005 fab3 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   27d70:	f385 8811 	msr	BASEPRI, r5
   27d74:	f3bf 8f6f 	isb	sy
}
   27d78:	bd38      	pop	{r3, r4, r5, pc}
   27d7a:	bf00      	nop
   27d7c:	2002d320 	.word	0x2002d320
   27d80:	00031168 	.word	0x00031168
   27d84:	0003118e 	.word	0x0003118e
   27d88:	000311a3 	.word	0x000311a3
   27d8c:	000311c0 	.word	0x000311c0
   27d90:	2002d310 	.word	0x2002d310
   27d94:	2002d2e8 	.word	0x2002d2e8
   27d98:	00031202 	.word	0x00031202
   27d9c:	00031219 	.word	0x00031219

00027da0 <pend>:
{
   27da0:	b570      	push	{r4, r5, r6, lr}
   27da2:	4604      	mov	r4, r0
   27da4:	460d      	mov	r5, r1
   27da6:	4616      	mov	r6, r2
	z_remove_thread_from_ready_q(thread);
   27da8:	f7ff ff9e 	bl	27ce8 <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_PENDING;
   27dac:	7b63      	ldrb	r3, [r4, #13]
   27dae:	f043 0302 	orr.w	r3, r3, #2
   27db2:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   27db4:	b1fd      	cbz	r5, 27df6 <pend+0x56>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   27db6:	4b2b      	ldr	r3, [pc, #172]	; (27e64 <pend+0xc4>)
		thread->base.pended_on = wait_q;
   27db8:	60a5      	str	r5, [r4, #8]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   27dba:	429c      	cmp	r4, r3
   27dbc:	d10b      	bne.n	27dd6 <pend+0x36>
   27dbe:	492a      	ldr	r1, [pc, #168]	; (27e68 <pend+0xc8>)
   27dc0:	482a      	ldr	r0, [pc, #168]	; (27e6c <pend+0xcc>)
   27dc2:	f240 3302 	movw	r3, #770	; 0x302
   27dc6:	4a2a      	ldr	r2, [pc, #168]	; (27e70 <pend+0xd0>)
   27dc8:	f005 fa3f 	bl	2d24a <printk>
   27dcc:	f240 3102 	movw	r1, #770	; 0x302
   27dd0:	4827      	ldr	r0, [pc, #156]	; (27e70 <pend+0xd0>)
   27dd2:	f005 fa80 	bl	2d2d6 <assert_post_action>
	return list->head == list;
   27dd6:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   27dd8:	429d      	cmp	r5, r3
   27dda:	d03b      	beq.n	27e54 <pend+0xb4>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   27ddc:	2b00      	cmp	r3, #0
   27dde:	d039      	beq.n	27e54 <pend+0xb4>
	if (thread_1->base.prio < thread_2->base.prio) {
   27de0:	f994 200e 	ldrsb.w	r2, [r4, #14]
   27de4:	f993 100e 	ldrsb.w	r1, [r3, #14]
   27de8:	4291      	cmp	r1, r2
   27dea:	dd2d      	ble.n	27e48 <pend+0xa8>
	node->prev = successor->prev;
   27dec:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   27dee:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   27df2:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   27df4:	605c      	str	r4, [r3, #4]
	if (timeout != K_FOREVER) {
   27df6:	1c73      	adds	r3, r6, #1
   27df8:	d033      	beq.n	27e62 <pend+0xc2>
		__ASSERT(timeout >= 0,
   27dfa:	2e00      	cmp	r6, #0
   27dfc:	da0e      	bge.n	27e1c <pend+0x7c>
   27dfe:	491d      	ldr	r1, [pc, #116]	; (27e74 <pend+0xd4>)
   27e00:	f44f 73fb 	mov.w	r3, #502	; 0x1f6
   27e04:	4a1a      	ldr	r2, [pc, #104]	; (27e70 <pend+0xd0>)
   27e06:	4819      	ldr	r0, [pc, #100]	; (27e6c <pend+0xcc>)
   27e08:	f005 fa1f 	bl	2d24a <printk>
   27e0c:	481a      	ldr	r0, [pc, #104]	; (27e78 <pend+0xd8>)
   27e0e:	f005 fa1c 	bl	2d24a <printk>
   27e12:	f44f 71fb 	mov.w	r1, #502	; 0x1f6
   27e16:	4816      	ldr	r0, [pc, #88]	; (27e70 <pend+0xd0>)
   27e18:	f005 fa5d 	bl	2d2d6 <assert_post_action>
   27e1c:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   27e20:	f240 30e7 	movw	r0, #999	; 0x3e7
   27e24:	2100      	movs	r1, #0
   27e26:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
   27e2a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   27e2e:	fbc5 0106 	smlal	r0, r1, r5, r6
   27e32:	2300      	movs	r3, #0
   27e34:	f7e4 feca 	bl	cbcc <__aeabi_uldivmod>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   27e38:	4910      	ldr	r1, [pc, #64]	; (27e7c <pend+0xdc>)
   27e3a:	1c42      	adds	r2, r0, #1
   27e3c:	f104 0018 	add.w	r0, r4, #24
}
   27e40:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   27e44:	f000 beea 	b.w	28c1c <z_add_timeout>
	return (node == list->tail) ? NULL : node->next;
   27e48:	6869      	ldr	r1, [r5, #4]
   27e4a:	428b      	cmp	r3, r1
   27e4c:	d002      	beq.n	27e54 <pend+0xb4>
   27e4e:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   27e50:	2b00      	cmp	r3, #0
   27e52:	d1c7      	bne.n	27de4 <pend+0x44>
	node->prev = list->tail;
   27e54:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   27e56:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
   27e58:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   27e5a:	686b      	ldr	r3, [r5, #4]
   27e5c:	601c      	str	r4, [r3, #0]
	list->tail = node;
   27e5e:	606c      	str	r4, [r5, #4]
   27e60:	e7c9      	b.n	27df6 <pend+0x56>
}
   27e62:	bd70      	pop	{r4, r5, r6, pc}
   27e64:	20029118 	.word	0x20029118
   27e68:	000349ea 	.word	0x000349ea
   27e6c:	000311a3 	.word	0x000311a3
   27e70:	00034992 	.word	0x00034992
   27e74:	0003495c 	.word	0x0003495c
   27e78:	00034969 	.word	0x00034969
   27e7c:	000278c1 	.word	0x000278c1

00027e80 <z_pend_curr_irqlock>:
{
   27e80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   27e82:	4606      	mov	r6, r0
	pend(_current, wait_q, timeout);
   27e84:	4d22      	ldr	r5, [pc, #136]	; (27f10 <z_pend_curr_irqlock+0x90>)
	pending_current = _current;
   27e86:	4c23      	ldr	r4, [pc, #140]	; (27f14 <z_pend_curr_irqlock+0x94>)
	pend(_current, wait_q, timeout);
   27e88:	68a8      	ldr	r0, [r5, #8]
   27e8a:	f7ff ff89 	bl	27da0 <pend>
	pending_current = _current;
   27e8e:	68ab      	ldr	r3, [r5, #8]
   27e90:	4630      	mov	r0, r6
   27e92:	6023      	str	r3, [r4, #0]
   27e94:	f7f1 f8a0 	bl	18fd8 <arch_swap>
   27e98:	4606      	mov	r6, r0
	__asm__ volatile(
   27e9a:	f04f 0320 	mov.w	r3, #32
   27e9e:	f3ef 8711 	mrs	r7, BASEPRI
   27ea2:	f383 8811 	msr	BASEPRI, r3
   27ea6:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27eaa:	481b      	ldr	r0, [pc, #108]	; (27f18 <z_pend_curr_irqlock+0x98>)
   27eac:	f000 fc1c 	bl	286e8 <z_spin_lock_valid>
   27eb0:	b968      	cbnz	r0, 27ece <z_pend_curr_irqlock+0x4e>
   27eb2:	234a      	movs	r3, #74	; 0x4a
   27eb4:	4a19      	ldr	r2, [pc, #100]	; (27f1c <z_pend_curr_irqlock+0x9c>)
   27eb6:	491a      	ldr	r1, [pc, #104]	; (27f20 <z_pend_curr_irqlock+0xa0>)
   27eb8:	481a      	ldr	r0, [pc, #104]	; (27f24 <z_pend_curr_irqlock+0xa4>)
   27eba:	f005 f9c6 	bl	2d24a <printk>
   27ebe:	4916      	ldr	r1, [pc, #88]	; (27f18 <z_pend_curr_irqlock+0x98>)
   27ec0:	4819      	ldr	r0, [pc, #100]	; (27f28 <z_pend_curr_irqlock+0xa8>)
   27ec2:	f005 f9c2 	bl	2d24a <printk>
   27ec6:	214a      	movs	r1, #74	; 0x4a
   27ec8:	4814      	ldr	r0, [pc, #80]	; (27f1c <z_pend_curr_irqlock+0x9c>)
   27eca:	f005 fa04 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   27ece:	4812      	ldr	r0, [pc, #72]	; (27f18 <z_pend_curr_irqlock+0x98>)
   27ed0:	f000 fc28 	bl	28724 <z_spin_lock_set_owner>
		if (pending_current == _current) {
   27ed4:	6823      	ldr	r3, [r4, #0]
   27ed6:	68aa      	ldr	r2, [r5, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27ed8:	480f      	ldr	r0, [pc, #60]	; (27f18 <z_pend_curr_irqlock+0x98>)
   27eda:	429a      	cmp	r2, r3
			pending_current = NULL;
   27edc:	bf04      	itt	eq
   27ede:	2300      	moveq	r3, #0
   27ee0:	6023      	streq	r3, [r4, #0]
   27ee2:	f000 fc0f 	bl	28704 <z_spin_unlock_valid>
   27ee6:	b968      	cbnz	r0, 27f04 <z_pend_curr_irqlock+0x84>
   27ee8:	235d      	movs	r3, #93	; 0x5d
   27eea:	4a0c      	ldr	r2, [pc, #48]	; (27f1c <z_pend_curr_irqlock+0x9c>)
   27eec:	490f      	ldr	r1, [pc, #60]	; (27f2c <z_pend_curr_irqlock+0xac>)
   27eee:	480d      	ldr	r0, [pc, #52]	; (27f24 <z_pend_curr_irqlock+0xa4>)
   27ef0:	f005 f9ab 	bl	2d24a <printk>
   27ef4:	4908      	ldr	r1, [pc, #32]	; (27f18 <z_pend_curr_irqlock+0x98>)
   27ef6:	480e      	ldr	r0, [pc, #56]	; (27f30 <z_pend_curr_irqlock+0xb0>)
   27ef8:	f005 f9a7 	bl	2d24a <printk>
   27efc:	215d      	movs	r1, #93	; 0x5d
   27efe:	4807      	ldr	r0, [pc, #28]	; (27f1c <z_pend_curr_irqlock+0x9c>)
   27f00:	f005 f9e9 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   27f04:	f387 8811 	msr	BASEPRI, r7
   27f08:	f3bf 8f6f 	isb	sy
}
   27f0c:	4630      	mov	r0, r6
   27f0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   27f10:	2002d2e8 	.word	0x2002d2e8
   27f14:	2002d31c 	.word	0x2002d31c
   27f18:	2002d320 	.word	0x2002d320
   27f1c:	00031168 	.word	0x00031168
   27f20:	0003118e 	.word	0x0003118e
   27f24:	000311a3 	.word	0x000311a3
   27f28:	000311c0 	.word	0x000311c0
   27f2c:	00031202 	.word	0x00031202
   27f30:	00031219 	.word	0x00031219

00027f34 <z_pend_curr>:
{
   27f34:	b538      	push	{r3, r4, r5, lr}
   27f36:	4604      	mov	r4, r0
   27f38:	460d      	mov	r5, r1
   27f3a:	4611      	mov	r1, r2
	pending_current = _current;
   27f3c:	4a0e      	ldr	r2, [pc, #56]	; (27f78 <z_pend_curr+0x44>)
   27f3e:	6890      	ldr	r0, [r2, #8]
   27f40:	4a0e      	ldr	r2, [pc, #56]	; (27f7c <z_pend_curr+0x48>)
   27f42:	6010      	str	r0, [r2, #0]
	pend(_current, wait_q, timeout);
   27f44:	461a      	mov	r2, r3
   27f46:	f7ff ff2b 	bl	27da0 <pend>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   27f4a:	4620      	mov	r0, r4
   27f4c:	f000 fbda 	bl	28704 <z_spin_unlock_valid>
   27f50:	b968      	cbnz	r0, 27f6e <z_pend_curr+0x3a>
   27f52:	2374      	movs	r3, #116	; 0x74
   27f54:	4a0a      	ldr	r2, [pc, #40]	; (27f80 <z_pend_curr+0x4c>)
   27f56:	490b      	ldr	r1, [pc, #44]	; (27f84 <z_pend_curr+0x50>)
   27f58:	480b      	ldr	r0, [pc, #44]	; (27f88 <z_pend_curr+0x54>)
   27f5a:	f005 f976 	bl	2d24a <printk>
   27f5e:	4621      	mov	r1, r4
   27f60:	480a      	ldr	r0, [pc, #40]	; (27f8c <z_pend_curr+0x58>)
   27f62:	f005 f972 	bl	2d24a <printk>
   27f66:	2174      	movs	r1, #116	; 0x74
   27f68:	4805      	ldr	r0, [pc, #20]	; (27f80 <z_pend_curr+0x4c>)
   27f6a:	f005 f9b4 	bl	2d2d6 <assert_post_action>
   27f6e:	4628      	mov	r0, r5
}
   27f70:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   27f74:	f7f1 b830 	b.w	18fd8 <arch_swap>
   27f78:	2002d2e8 	.word	0x2002d2e8
   27f7c:	2002d31c 	.word	0x2002d31c
   27f80:	00031168 	.word	0x00031168
   27f84:	00031202 	.word	0x00031202
   27f88:	000311a3 	.word	0x000311a3
   27f8c:	00031219 	.word	0x00031219

00027f90 <z_set_prio>:
{
   27f90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   27f92:	4604      	mov	r4, r0
   27f94:	460d      	mov	r5, r1
	__asm__ volatile(
   27f96:	f04f 0320 	mov.w	r3, #32
   27f9a:	f3ef 8611 	mrs	r6, BASEPRI
   27f9e:	f383 8811 	msr	BASEPRI, r3
   27fa2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   27fa6:	4835      	ldr	r0, [pc, #212]	; (2807c <z_set_prio+0xec>)
   27fa8:	f000 fb9e 	bl	286e8 <z_spin_lock_valid>
   27fac:	b968      	cbnz	r0, 27fca <z_set_prio+0x3a>
   27fae:	234a      	movs	r3, #74	; 0x4a
   27fb0:	4a33      	ldr	r2, [pc, #204]	; (28080 <z_set_prio+0xf0>)
   27fb2:	4934      	ldr	r1, [pc, #208]	; (28084 <z_set_prio+0xf4>)
   27fb4:	4834      	ldr	r0, [pc, #208]	; (28088 <z_set_prio+0xf8>)
   27fb6:	f005 f948 	bl	2d24a <printk>
   27fba:	4930      	ldr	r1, [pc, #192]	; (2807c <z_set_prio+0xec>)
   27fbc:	4833      	ldr	r0, [pc, #204]	; (2808c <z_set_prio+0xfc>)
   27fbe:	f005 f944 	bl	2d24a <printk>
   27fc2:	214a      	movs	r1, #74	; 0x4a
   27fc4:	482e      	ldr	r0, [pc, #184]	; (28080 <z_set_prio+0xf0>)
   27fc6:	f005 f986 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   27fca:	482c      	ldr	r0, [pc, #176]	; (2807c <z_set_prio+0xec>)
   27fcc:	f000 fbaa 	bl	28724 <z_spin_lock_set_owner>
		need_sched = z_is_thread_ready(thread);
   27fd0:	4620      	mov	r0, r4
   27fd2:	f007 f82b 	bl	2f02c <z_is_thread_ready>
		if (need_sched) {
   27fd6:	b26d      	sxtb	r5, r5
   27fd8:	4607      	mov	r7, r0
   27fda:	2800      	cmp	r0, #0
   27fdc:	d04c      	beq.n	28078 <z_set_prio+0xe8>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
   27fde:	4621      	mov	r1, r4
   27fe0:	482b      	ldr	r0, [pc, #172]	; (28090 <z_set_prio+0x100>)
   27fe2:	f7ff fab7 	bl	27554 <z_priq_dumb_remove>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   27fe6:	4b2b      	ldr	r3, [pc, #172]	; (28094 <z_set_prio+0x104>)
				thread->base.prio = prio;
   27fe8:	73a5      	strb	r5, [r4, #14]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   27fea:	429c      	cmp	r4, r3
   27fec:	d10b      	bne.n	28006 <z_set_prio+0x76>
   27fee:	492a      	ldr	r1, [pc, #168]	; (28098 <z_set_prio+0x108>)
   27ff0:	4825      	ldr	r0, [pc, #148]	; (28088 <z_set_prio+0xf8>)
   27ff2:	f240 3302 	movw	r3, #770	; 0x302
   27ff6:	4a29      	ldr	r2, [pc, #164]	; (2809c <z_set_prio+0x10c>)
   27ff8:	f005 f927 	bl	2d24a <printk>
   27ffc:	f240 3102 	movw	r1, #770	; 0x302
   28000:	4826      	ldr	r0, [pc, #152]	; (2809c <z_set_prio+0x10c>)
   28002:	f005 f968 	bl	2d2d6 <assert_post_action>
	return list->head == list;
   28006:	4a26      	ldr	r2, [pc, #152]	; (280a0 <z_set_prio+0x110>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
   28008:	f102 0128 	add.w	r1, r2, #40	; 0x28
   2800c:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
   28010:	428b      	cmp	r3, r1
   28012:	d02b      	beq.n	2806c <z_set_prio+0xdc>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   28014:	b353      	cbz	r3, 2806c <z_set_prio+0xdc>
	if (thread_1->base.prio < thread_2->base.prio) {
   28016:	f994 500e 	ldrsb.w	r5, [r4, #14]
   2801a:	f993 c00e 	ldrsb.w	ip, [r3, #14]
   2801e:	45ac      	cmp	ip, r5
   28020:	dd1f      	ble.n	28062 <z_set_prio+0xd2>
	node->prev = successor->prev;
   28022:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   28024:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   28028:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   2802a:	605c      	str	r4, [r3, #4]
			update_cache(1);
   2802c:	2001      	movs	r0, #1
   2802e:	f7ff fb15 	bl	2765c <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28032:	4812      	ldr	r0, [pc, #72]	; (2807c <z_set_prio+0xec>)
   28034:	f000 fb66 	bl	28704 <z_spin_unlock_valid>
   28038:	b968      	cbnz	r0, 28056 <z_set_prio+0xc6>
   2803a:	235d      	movs	r3, #93	; 0x5d
   2803c:	4a10      	ldr	r2, [pc, #64]	; (28080 <z_set_prio+0xf0>)
   2803e:	4919      	ldr	r1, [pc, #100]	; (280a4 <z_set_prio+0x114>)
   28040:	4811      	ldr	r0, [pc, #68]	; (28088 <z_set_prio+0xf8>)
   28042:	f005 f902 	bl	2d24a <printk>
   28046:	490d      	ldr	r1, [pc, #52]	; (2807c <z_set_prio+0xec>)
   28048:	4817      	ldr	r0, [pc, #92]	; (280a8 <z_set_prio+0x118>)
   2804a:	f005 f8fe 	bl	2d24a <printk>
   2804e:	215d      	movs	r1, #93	; 0x5d
   28050:	480b      	ldr	r0, [pc, #44]	; (28080 <z_set_prio+0xf0>)
   28052:	f005 f940 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   28056:	f386 8811 	msr	BASEPRI, r6
   2805a:	f3bf 8f6f 	isb	sy
}
   2805e:	4638      	mov	r0, r7
   28060:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   28062:	4298      	cmp	r0, r3
   28064:	d002      	beq.n	2806c <z_set_prio+0xdc>
   28066:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   28068:	2b00      	cmp	r3, #0
   2806a:	d1d6      	bne.n	2801a <z_set_prio+0x8a>
	node->prev = list->tail;
   2806c:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   28070:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   28072:	601c      	str	r4, [r3, #0]
	list->tail = node;
   28074:	62d4      	str	r4, [r2, #44]	; 0x2c
   28076:	e7d9      	b.n	2802c <z_set_prio+0x9c>
			thread->base.prio = prio;
   28078:	73a5      	strb	r5, [r4, #14]
   2807a:	e7da      	b.n	28032 <z_set_prio+0xa2>
   2807c:	2002d320 	.word	0x2002d320
   28080:	00031168 	.word	0x00031168
   28084:	0003118e 	.word	0x0003118e
   28088:	000311a3 	.word	0x000311a3
   2808c:	000311c0 	.word	0x000311c0
   28090:	2002d310 	.word	0x2002d310
   28094:	20029118 	.word	0x20029118
   28098:	000349ea 	.word	0x000349ea
   2809c:	00034992 	.word	0x00034992
   280a0:	2002d2e8 	.word	0x2002d2e8
   280a4:	00031202 	.word	0x00031202
   280a8:	00031219 	.word	0x00031219

000280ac <z_unpend_first_thread>:
{
   280ac:	b538      	push	{r3, r4, r5, lr}
   280ae:	4604      	mov	r4, r0
	__asm__ volatile(
   280b0:	f04f 0320 	mov.w	r3, #32
   280b4:	f3ef 8511 	mrs	r5, BASEPRI
   280b8:	f383 8811 	msr	BASEPRI, r3
   280bc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   280c0:	483b      	ldr	r0, [pc, #236]	; (281b0 <z_unpend_first_thread+0x104>)
   280c2:	f000 fb11 	bl	286e8 <z_spin_lock_valid>
   280c6:	b968      	cbnz	r0, 280e4 <z_unpend_first_thread+0x38>
   280c8:	234a      	movs	r3, #74	; 0x4a
   280ca:	4a3a      	ldr	r2, [pc, #232]	; (281b4 <z_unpend_first_thread+0x108>)
   280cc:	493a      	ldr	r1, [pc, #232]	; (281b8 <z_unpend_first_thread+0x10c>)
   280ce:	483b      	ldr	r0, [pc, #236]	; (281bc <z_unpend_first_thread+0x110>)
   280d0:	f005 f8bb 	bl	2d24a <printk>
   280d4:	4936      	ldr	r1, [pc, #216]	; (281b0 <z_unpend_first_thread+0x104>)
   280d6:	483a      	ldr	r0, [pc, #232]	; (281c0 <z_unpend_first_thread+0x114>)
   280d8:	f005 f8b7 	bl	2d24a <printk>
   280dc:	214a      	movs	r1, #74	; 0x4a
   280de:	4835      	ldr	r0, [pc, #212]	; (281b4 <z_unpend_first_thread+0x108>)
   280e0:	f005 f8f9 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   280e4:	4832      	ldr	r0, [pc, #200]	; (281b0 <z_unpend_first_thread+0x104>)
   280e6:	f000 fb1d 	bl	28724 <z_spin_lock_set_owner>
		ret = _priq_wait_best(&wait_q->waitq);
   280ea:	4620      	mov	r0, r4
   280ec:	f006 ffc6 	bl	2f07c <z_priq_dumb_best>
   280f0:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   280f2:	482f      	ldr	r0, [pc, #188]	; (281b0 <z_unpend_first_thread+0x104>)
   280f4:	f000 fb06 	bl	28704 <z_spin_unlock_valid>
   280f8:	b968      	cbnz	r0, 28116 <z_unpend_first_thread+0x6a>
   280fa:	235d      	movs	r3, #93	; 0x5d
   280fc:	4a2d      	ldr	r2, [pc, #180]	; (281b4 <z_unpend_first_thread+0x108>)
   280fe:	4931      	ldr	r1, [pc, #196]	; (281c4 <z_unpend_first_thread+0x118>)
   28100:	482e      	ldr	r0, [pc, #184]	; (281bc <z_unpend_first_thread+0x110>)
   28102:	f005 f8a2 	bl	2d24a <printk>
   28106:	492a      	ldr	r1, [pc, #168]	; (281b0 <z_unpend_first_thread+0x104>)
   28108:	482f      	ldr	r0, [pc, #188]	; (281c8 <z_unpend_first_thread+0x11c>)
   2810a:	f005 f89e 	bl	2d24a <printk>
   2810e:	215d      	movs	r1, #93	; 0x5d
   28110:	4828      	ldr	r0, [pc, #160]	; (281b4 <z_unpend_first_thread+0x108>)
   28112:	f005 f8e0 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   28116:	f385 8811 	msr	BASEPRI, r5
   2811a:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   2811e:	2c00      	cmp	r4, #0
   28120:	d043      	beq.n	281aa <z_unpend_first_thread+0xfe>
	__asm__ volatile(
   28122:	f04f 0320 	mov.w	r3, #32
   28126:	f3ef 8511 	mrs	r5, BASEPRI
   2812a:	f383 8811 	msr	BASEPRI, r3
   2812e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28132:	481f      	ldr	r0, [pc, #124]	; (281b0 <z_unpend_first_thread+0x104>)
   28134:	f000 fad8 	bl	286e8 <z_spin_lock_valid>
   28138:	b968      	cbnz	r0, 28156 <z_unpend_first_thread+0xaa>
   2813a:	234a      	movs	r3, #74	; 0x4a
   2813c:	4a1d      	ldr	r2, [pc, #116]	; (281b4 <z_unpend_first_thread+0x108>)
   2813e:	491e      	ldr	r1, [pc, #120]	; (281b8 <z_unpend_first_thread+0x10c>)
   28140:	481e      	ldr	r0, [pc, #120]	; (281bc <z_unpend_first_thread+0x110>)
   28142:	f005 f882 	bl	2d24a <printk>
   28146:	491a      	ldr	r1, [pc, #104]	; (281b0 <z_unpend_first_thread+0x104>)
   28148:	481d      	ldr	r0, [pc, #116]	; (281c0 <z_unpend_first_thread+0x114>)
   2814a:	f005 f87e 	bl	2d24a <printk>
   2814e:	214a      	movs	r1, #74	; 0x4a
   28150:	4818      	ldr	r0, [pc, #96]	; (281b4 <z_unpend_first_thread+0x108>)
   28152:	f005 f8c0 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   28156:	4816      	ldr	r0, [pc, #88]	; (281b0 <z_unpend_first_thread+0x104>)
   28158:	f000 fae4 	bl	28724 <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   2815c:	f104 0008 	add.w	r0, r4, #8
   28160:	f7ff f81a 	bl	27198 <pended_on.isra.17>
   28164:	4621      	mov	r1, r4
   28166:	f7ff f9f5 	bl	27554 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   2816a:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2816c:	4810      	ldr	r0, [pc, #64]	; (281b0 <z_unpend_first_thread+0x104>)
   2816e:	f023 0302 	bic.w	r3, r3, #2
   28172:	7363      	strb	r3, [r4, #13]
   28174:	f000 fac6 	bl	28704 <z_spin_unlock_valid>
   28178:	b968      	cbnz	r0, 28196 <z_unpend_first_thread+0xea>
   2817a:	235d      	movs	r3, #93	; 0x5d
   2817c:	4a0d      	ldr	r2, [pc, #52]	; (281b4 <z_unpend_first_thread+0x108>)
   2817e:	4911      	ldr	r1, [pc, #68]	; (281c4 <z_unpend_first_thread+0x118>)
   28180:	480e      	ldr	r0, [pc, #56]	; (281bc <z_unpend_first_thread+0x110>)
   28182:	f005 f862 	bl	2d24a <printk>
   28186:	490a      	ldr	r1, [pc, #40]	; (281b0 <z_unpend_first_thread+0x104>)
   28188:	480f      	ldr	r0, [pc, #60]	; (281c8 <z_unpend_first_thread+0x11c>)
   2818a:	f005 f85e 	bl	2d24a <printk>
   2818e:	215d      	movs	r1, #93	; 0x5d
   28190:	4808      	ldr	r0, [pc, #32]	; (281b4 <z_unpend_first_thread+0x108>)
   28192:	f005 f8a0 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   28196:	f385 8811 	msr	BASEPRI, r5
   2819a:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   2819e:	2300      	movs	r3, #0
	return z_abort_timeout(&thread->base.timeout);
   281a0:	f104 0018 	add.w	r0, r4, #24
   281a4:	60a3      	str	r3, [r4, #8]
   281a6:	f000 fddf 	bl	28d68 <z_abort_timeout>
}
   281aa:	4620      	mov	r0, r4
   281ac:	bd38      	pop	{r3, r4, r5, pc}
   281ae:	bf00      	nop
   281b0:	2002d320 	.word	0x2002d320
   281b4:	00031168 	.word	0x00031168
   281b8:	0003118e 	.word	0x0003118e
   281bc:	000311a3 	.word	0x000311a3
   281c0:	000311c0 	.word	0x000311c0
   281c4:	00031202 	.word	0x00031202
   281c8:	00031219 	.word	0x00031219

000281cc <z_sched_init>:
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   281cc:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
   281ce:	4b04      	ldr	r3, [pc, #16]	; (281e0 <z_sched_init+0x14>)
   281d0:	4608      	mov	r0, r1
   281d2:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
   281d6:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
   281da:	f7ff b80b 	b.w	271f4 <k_sched_time_slice_set>
   281de:	bf00      	nop
   281e0:	2002d2e8 	.word	0x2002d2e8

000281e4 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
   281e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   281e6:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   281ea:	b173      	cbz	r3, 2820a <z_impl_k_yield+0x26>
   281ec:	4945      	ldr	r1, [pc, #276]	; (28304 <z_impl_k_yield+0x120>)
   281ee:	f240 430d 	movw	r3, #1037	; 0x40d
   281f2:	4a45      	ldr	r2, [pc, #276]	; (28308 <z_impl_k_yield+0x124>)
   281f4:	4845      	ldr	r0, [pc, #276]	; (2830c <z_impl_k_yield+0x128>)
   281f6:	f005 f828 	bl	2d24a <printk>
   281fa:	4845      	ldr	r0, [pc, #276]	; (28310 <z_impl_k_yield+0x12c>)
   281fc:	f005 f825 	bl	2d24a <printk>
   28200:	f240 410d 	movw	r1, #1037	; 0x40d
   28204:	4840      	ldr	r0, [pc, #256]	; (28308 <z_impl_k_yield+0x124>)
   28206:	f005 f866 	bl	2d2d6 <assert_post_action>

	if (!z_is_idle_thread_object(_current)) {
   2820a:	4c42      	ldr	r4, [pc, #264]	; (28314 <z_impl_k_yield+0x130>)
   2820c:	4e42      	ldr	r6, [pc, #264]	; (28318 <z_impl_k_yield+0x134>)
   2820e:	68a2      	ldr	r2, [r4, #8]
   28210:	42b2      	cmp	r2, r6
   28212:	d05f      	beq.n	282d4 <z_impl_k_yield+0xf0>
	__asm__ volatile(
   28214:	f04f 0320 	mov.w	r3, #32
   28218:	f3ef 8711 	mrs	r7, BASEPRI
   2821c:	f383 8811 	msr	BASEPRI, r3
   28220:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28224:	483d      	ldr	r0, [pc, #244]	; (2831c <z_impl_k_yield+0x138>)
   28226:	f000 fa5f 	bl	286e8 <z_spin_lock_valid>
   2822a:	b968      	cbnz	r0, 28248 <z_impl_k_yield+0x64>
   2822c:	234a      	movs	r3, #74	; 0x4a
   2822e:	4a3c      	ldr	r2, [pc, #240]	; (28320 <z_impl_k_yield+0x13c>)
   28230:	493c      	ldr	r1, [pc, #240]	; (28324 <z_impl_k_yield+0x140>)
   28232:	4836      	ldr	r0, [pc, #216]	; (2830c <z_impl_k_yield+0x128>)
   28234:	f005 f809 	bl	2d24a <printk>
   28238:	4938      	ldr	r1, [pc, #224]	; (2831c <z_impl_k_yield+0x138>)
   2823a:	483b      	ldr	r0, [pc, #236]	; (28328 <z_impl_k_yield+0x144>)
   2823c:	f005 f805 	bl	2d24a <printk>
   28240:	214a      	movs	r1, #74	; 0x4a
   28242:	4837      	ldr	r0, [pc, #220]	; (28320 <z_impl_k_yield+0x13c>)
   28244:	f005 f847 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   28248:	4834      	ldr	r0, [pc, #208]	; (2831c <z_impl_k_yield+0x138>)
   2824a:	f000 fa6b 	bl	28724 <z_spin_lock_set_owner>
		LOCKED(&sched_spinlock) {
			if (!IS_ENABLED(CONFIG_SMP) ||
			    z_is_thread_queued(_current)) {
				_priq_run_remove(&_kernel.ready_q.runq,
   2824e:	68a1      	ldr	r1, [r4, #8]
   28250:	4836      	ldr	r0, [pc, #216]	; (2832c <z_impl_k_yield+0x148>)
   28252:	f7ff f97f 	bl	27554 <z_priq_dumb_remove>
						 _current);
			}
			_priq_run_add(&_kernel.ready_q.runq, _current);
   28256:	68a5      	ldr	r5, [r4, #8]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   28258:	42b5      	cmp	r5, r6
   2825a:	d10b      	bne.n	28274 <z_impl_k_yield+0x90>
   2825c:	4934      	ldr	r1, [pc, #208]	; (28330 <z_impl_k_yield+0x14c>)
   2825e:	482b      	ldr	r0, [pc, #172]	; (2830c <z_impl_k_yield+0x128>)
   28260:	f240 3302 	movw	r3, #770	; 0x302
   28264:	4a28      	ldr	r2, [pc, #160]	; (28308 <z_impl_k_yield+0x124>)
   28266:	f004 fff0 	bl	2d24a <printk>
   2826a:	f240 3102 	movw	r1, #770	; 0x302
   2826e:	4826      	ldr	r0, [pc, #152]	; (28308 <z_impl_k_yield+0x124>)
   28270:	f005 f831 	bl	2d2d6 <assert_post_action>
	return list->head == list;
   28274:	e9d4 310a 	ldrd	r3, r1, [r4, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
   28278:	4a2c      	ldr	r2, [pc, #176]	; (2832c <z_impl_k_yield+0x148>)
   2827a:	4293      	cmp	r3, r2
   2827c:	d03b      	beq.n	282f6 <z_impl_k_yield+0x112>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2827e:	2b00      	cmp	r3, #0
   28280:	d039      	beq.n	282f6 <z_impl_k_yield+0x112>
	if (thread_1->base.prio < thread_2->base.prio) {
   28282:	f995 000e 	ldrsb.w	r0, [r5, #14]
   28286:	f993 600e 	ldrsb.w	r6, [r3, #14]
   2828a:	4286      	cmp	r6, r0
   2828c:	dd2e      	ble.n	282ec <z_impl_k_yield+0x108>
	node->prev = successor->prev;
   2828e:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   28290:	e9c5 3200 	strd	r3, r2, [r5]
	successor->prev->next = node;
   28294:	6015      	str	r5, [r2, #0]
	successor->prev = node;
   28296:	605d      	str	r5, [r3, #4]
			z_mark_thread_as_queued(_current);
   28298:	68a2      	ldr	r2, [r4, #8]
			update_cache(1);
   2829a:	2001      	movs	r0, #1
	thread->base.thread_state |= states;
   2829c:	7b53      	ldrb	r3, [r2, #13]
   2829e:	f063 037f 	orn	r3, r3, #127	; 0x7f
   282a2:	7353      	strb	r3, [r2, #13]
   282a4:	f7ff f9da 	bl	2765c <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   282a8:	481c      	ldr	r0, [pc, #112]	; (2831c <z_impl_k_yield+0x138>)
   282aa:	f000 fa2b 	bl	28704 <z_spin_unlock_valid>
   282ae:	b968      	cbnz	r0, 282cc <z_impl_k_yield+0xe8>
   282b0:	235d      	movs	r3, #93	; 0x5d
   282b2:	4a1b      	ldr	r2, [pc, #108]	; (28320 <z_impl_k_yield+0x13c>)
   282b4:	491f      	ldr	r1, [pc, #124]	; (28334 <z_impl_k_yield+0x150>)
   282b6:	4815      	ldr	r0, [pc, #84]	; (2830c <z_impl_k_yield+0x128>)
   282b8:	f004 ffc7 	bl	2d24a <printk>
   282bc:	4917      	ldr	r1, [pc, #92]	; (2831c <z_impl_k_yield+0x138>)
   282be:	481e      	ldr	r0, [pc, #120]	; (28338 <z_impl_k_yield+0x154>)
   282c0:	f004 ffc3 	bl	2d24a <printk>
   282c4:	215d      	movs	r1, #93	; 0x5d
   282c6:	4816      	ldr	r0, [pc, #88]	; (28320 <z_impl_k_yield+0x13c>)
   282c8:	f005 f805 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   282cc:	f387 8811 	msr	BASEPRI, r7
   282d0:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   282d4:	f04f 0320 	mov.w	r3, #32
   282d8:	f3ef 8011 	mrs	r0, BASEPRI
   282dc:	f383 8811 	msr	BASEPRI, r3
   282e0:	f3bf 8f6f 	isb	sy
		}
	}
	z_swap_unlocked();
}
   282e4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   282e8:	f7f0 be76 	b.w	18fd8 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   282ec:	4299      	cmp	r1, r3
   282ee:	d002      	beq.n	282f6 <z_impl_k_yield+0x112>
   282f0:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   282f2:	2b00      	cmp	r3, #0
   282f4:	d1c7      	bne.n	28286 <z_impl_k_yield+0xa2>
	node->prev = list->tail;
   282f6:	e9c5 2100 	strd	r2, r1, [r5]
	list->tail->next = node;
   282fa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   282fc:	601d      	str	r5, [r3, #0]
	list->tail = node;
   282fe:	62e5      	str	r5, [r4, #44]	; 0x2c
   28300:	e7ca      	b.n	28298 <z_impl_k_yield+0xb4>
   28302:	bf00      	nop
   28304:	000348fa 	.word	0x000348fa
   28308:	00034992 	.word	0x00034992
   2830c:	000311a3 	.word	0x000311a3
   28310:	00033242 	.word	0x00033242
   28314:	2002d2e8 	.word	0x2002d2e8
   28318:	20029118 	.word	0x20029118
   2831c:	2002d320 	.word	0x2002d320
   28320:	00031168 	.word	0x00031168
   28324:	0003118e 	.word	0x0003118e
   28328:	000311c0 	.word	0x000311c0
   2832c:	2002d310 	.word	0x2002d310
   28330:	000349ea 	.word	0x000349ea
   28334:	00031202 	.word	0x00031202
   28338:	00031219 	.word	0x00031219

0002833c <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static s32_t z_tick_sleep(s32_t ticks)
{
   2833c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2833e:	4604      	mov	r4, r0
   28340:	f3ef 8305 	mrs	r3, IPSR
#ifdef CONFIG_MULTITHREADING
	u32_t expected_wakeup_time;

	__ASSERT(!arch_is_in_isr(), "");
   28344:	b173      	cbz	r3, 28364 <z_tick_sleep+0x28>
   28346:	493b      	ldr	r1, [pc, #236]	; (28434 <z_tick_sleep+0xf8>)
   28348:	f240 432b 	movw	r3, #1067	; 0x42b
   2834c:	4a3a      	ldr	r2, [pc, #232]	; (28438 <z_tick_sleep+0xfc>)
   2834e:	483b      	ldr	r0, [pc, #236]	; (2843c <z_tick_sleep+0x100>)
   28350:	f004 ff7b 	bl	2d24a <printk>
   28354:	483a      	ldr	r0, [pc, #232]	; (28440 <z_tick_sleep+0x104>)
   28356:	f004 ff78 	bl	2d24a <printk>
   2835a:	f240 412b 	movw	r1, #1067	; 0x42b
   2835e:	4836      	ldr	r0, [pc, #216]	; (28438 <z_tick_sleep+0xfc>)
   28360:	f004 ffb9 	bl	2d2d6 <assert_post_action>

	K_DEBUG("thread %p for %d ticks\n", _current, ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   28364:	b924      	cbnz	r4, 28370 <z_tick_sleep+0x34>
	z_impl_k_yield();
   28366:	f7ff ff3d 	bl	281e4 <z_impl_k_yield>
		return ticks;
	}
#endif

	return 0;
}
   2836a:	4620      	mov	r0, r4
   2836c:	b003      	add	sp, #12
   2836e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	expected_wakeup_time = ticks + z_tick_get_32();
   28370:	f006 ff2f 	bl	2f1d2 <z_tick_get_32>
	struct k_spinlock local_lock = {};
   28374:	2300      	movs	r3, #0
	ticks += _TICK_ALIGN;
   28376:	1c66      	adds	r6, r4, #1
	expected_wakeup_time = ticks + z_tick_get_32();
   28378:	1834      	adds	r4, r6, r0
	struct k_spinlock local_lock = {};
   2837a:	9301      	str	r3, [sp, #4]
   2837c:	f04f 0320 	mov.w	r3, #32
   28380:	f3ef 8711 	mrs	r7, BASEPRI
   28384:	f383 8811 	msr	BASEPRI, r3
   28388:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2838c:	a801      	add	r0, sp, #4
   2838e:	f000 f9ab 	bl	286e8 <z_spin_lock_valid>
   28392:	b968      	cbnz	r0, 283b0 <z_tick_sleep+0x74>
   28394:	234a      	movs	r3, #74	; 0x4a
   28396:	4a2b      	ldr	r2, [pc, #172]	; (28444 <z_tick_sleep+0x108>)
   28398:	492b      	ldr	r1, [pc, #172]	; (28448 <z_tick_sleep+0x10c>)
   2839a:	4828      	ldr	r0, [pc, #160]	; (2843c <z_tick_sleep+0x100>)
   2839c:	f004 ff55 	bl	2d24a <printk>
   283a0:	a901      	add	r1, sp, #4
   283a2:	482a      	ldr	r0, [pc, #168]	; (2844c <z_tick_sleep+0x110>)
   283a4:	f004 ff51 	bl	2d24a <printk>
   283a8:	214a      	movs	r1, #74	; 0x4a
   283aa:	4826      	ldr	r0, [pc, #152]	; (28444 <z_tick_sleep+0x108>)
   283ac:	f004 ff93 	bl	2d2d6 <assert_post_action>
	pending_current = _current;
   283b0:	4d27      	ldr	r5, [pc, #156]	; (28450 <z_tick_sleep+0x114>)
	z_spin_lock_set_owner(l);
   283b2:	a801      	add	r0, sp, #4
   283b4:	f000 f9b6 	bl	28724 <z_spin_lock_set_owner>
   283b8:	4b26      	ldr	r3, [pc, #152]	; (28454 <z_tick_sleep+0x118>)
   283ba:	68a8      	ldr	r0, [r5, #8]
   283bc:	6018      	str	r0, [r3, #0]
	z_remove_thread_from_ready_q(_current);
   283be:	f7ff fc93 	bl	27ce8 <z_remove_thread_from_ready_q>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   283c2:	68a8      	ldr	r0, [r5, #8]
   283c4:	4632      	mov	r2, r6
   283c6:	3018      	adds	r0, #24
   283c8:	4923      	ldr	r1, [pc, #140]	; (28458 <z_tick_sleep+0x11c>)
   283ca:	f000 fc27 	bl	28c1c <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   283ce:	68aa      	ldr	r2, [r5, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   283d0:	a801      	add	r0, sp, #4
	thread->base.thread_state |= _THREAD_SUSPENDED;
   283d2:	7b53      	ldrb	r3, [r2, #13]
   283d4:	f043 0310 	orr.w	r3, r3, #16
   283d8:	7353      	strb	r3, [r2, #13]
   283da:	f000 f993 	bl	28704 <z_spin_unlock_valid>
   283de:	b968      	cbnz	r0, 283fc <z_tick_sleep+0xc0>
   283e0:	2374      	movs	r3, #116	; 0x74
   283e2:	4a18      	ldr	r2, [pc, #96]	; (28444 <z_tick_sleep+0x108>)
   283e4:	491d      	ldr	r1, [pc, #116]	; (2845c <z_tick_sleep+0x120>)
   283e6:	4815      	ldr	r0, [pc, #84]	; (2843c <z_tick_sleep+0x100>)
   283e8:	f004 ff2f 	bl	2d24a <printk>
   283ec:	a901      	add	r1, sp, #4
   283ee:	481c      	ldr	r0, [pc, #112]	; (28460 <z_tick_sleep+0x124>)
   283f0:	f004 ff2b 	bl	2d24a <printk>
   283f4:	2174      	movs	r1, #116	; 0x74
   283f6:	4813      	ldr	r0, [pc, #76]	; (28444 <z_tick_sleep+0x108>)
   283f8:	f004 ff6d 	bl	2d2d6 <assert_post_action>
   283fc:	4638      	mov	r0, r7
   283fe:	f7f0 fdeb 	bl	18fd8 <arch_swap>
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
   28402:	68ab      	ldr	r3, [r5, #8]
   28404:	7b5b      	ldrb	r3, [r3, #13]
   28406:	06db      	lsls	r3, r3, #27
   28408:	d50e      	bpl.n	28428 <z_tick_sleep+0xec>
   2840a:	4916      	ldr	r1, [pc, #88]	; (28464 <z_tick_sleep+0x128>)
   2840c:	f44f 6389 	mov.w	r3, #1096	; 0x448
   28410:	4a09      	ldr	r2, [pc, #36]	; (28438 <z_tick_sleep+0xfc>)
   28412:	480a      	ldr	r0, [pc, #40]	; (2843c <z_tick_sleep+0x100>)
   28414:	f004 ff19 	bl	2d24a <printk>
   28418:	4809      	ldr	r0, [pc, #36]	; (28440 <z_tick_sleep+0x104>)
   2841a:	f004 ff16 	bl	2d24a <printk>
   2841e:	f44f 6189 	mov.w	r1, #1096	; 0x448
   28422:	4805      	ldr	r0, [pc, #20]	; (28438 <z_tick_sleep+0xfc>)
   28424:	f004 ff57 	bl	2d2d6 <assert_post_action>
	ticks = expected_wakeup_time - z_tick_get_32();
   28428:	f006 fed3 	bl	2f1d2 <z_tick_get_32>
   2842c:	1a24      	subs	r4, r4, r0
   2842e:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
   28432:	e79a      	b.n	2836a <z_tick_sleep+0x2e>
   28434:	000348fa 	.word	0x000348fa
   28438:	00034992 	.word	0x00034992
   2843c:	000311a3 	.word	0x000311a3
   28440:	00033242 	.word	0x00033242
   28444:	00031168 	.word	0x00031168
   28448:	0003118e 	.word	0x0003118e
   2844c:	000311c0 	.word	0x000311c0
   28450:	2002d2e8 	.word	0x2002d2e8
   28454:	2002d31c 	.word	0x2002d31c
   28458:	000278c1 	.word	0x000278c1
   2845c:	00031202 	.word	0x00031202
   28460:	00031219 	.word	0x00031219
   28464:	00034a0b 	.word	0x00034a0b

00028468 <z_impl_k_sleep>:

s32_t z_impl_k_sleep(int ms)
{
   28468:	b538      	push	{r3, r4, r5, lr}
   2846a:	4604      	mov	r4, r0
   2846c:	f3ef 8305 	mrs	r3, IPSR
	s32_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
   28470:	b173      	cbz	r3, 28490 <z_impl_k_sleep+0x28>
   28472:	4916      	ldr	r1, [pc, #88]	; (284cc <z_impl_k_sleep+0x64>)
   28474:	f240 4357 	movw	r3, #1111	; 0x457
   28478:	4a15      	ldr	r2, [pc, #84]	; (284d0 <z_impl_k_sleep+0x68>)
   2847a:	4816      	ldr	r0, [pc, #88]	; (284d4 <z_impl_k_sleep+0x6c>)
   2847c:	f004 fee5 	bl	2d24a <printk>
   28480:	4815      	ldr	r0, [pc, #84]	; (284d8 <z_impl_k_sleep+0x70>)
   28482:	f004 fee2 	bl	2d24a <printk>
   28486:	f240 4157 	movw	r1, #1111	; 0x457
   2848a:	4811      	ldr	r0, [pc, #68]	; (284d0 <z_impl_k_sleep+0x68>)
   2848c:	f004 ff23 	bl	2d2d6 <assert_post_action>

	if (ms == K_FOREVER) {
   28490:	1c63      	adds	r3, r4, #1
   28492:	d105      	bne.n	284a0 <z_impl_k_sleep+0x38>
		k_thread_suspend(_current);
   28494:	4b11      	ldr	r3, [pc, #68]	; (284dc <z_impl_k_sleep+0x74>)
   28496:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   28498:	f000 fa82 	bl	289a0 <z_impl_k_thread_suspend>
	}

	ticks = k_ms_to_ticks_ceil32(ms);
	ticks = z_tick_sleep(ticks);
	return k_ticks_to_ms_floor64(ticks);
}
   2849c:	4620      	mov	r0, r4
   2849e:	bd38      	pop	{r3, r4, r5, pc}
   284a0:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   284a4:	f240 30e7 	movw	r0, #999	; 0x3e7
   284a8:	2100      	movs	r1, #0
   284aa:	2300      	movs	r3, #0
   284ac:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   284b0:	fbe5 0104 	umlal	r0, r1, r5, r4
   284b4:	f7e4 fb8a 	bl	cbcc <__aeabi_uldivmod>
	ticks = z_tick_sleep(ticks);
   284b8:	f7ff ff40 	bl	2833c <z_tick_sleep>
			return (t * to_hz + off) / from_hz;
   284bc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   284c0:	fb80 0103 	smull	r0, r1, r0, r3
   284c4:	0bc4      	lsrs	r4, r0, #15
   284c6:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
	return k_ticks_to_ms_floor64(ticks);
   284ca:	e7e7      	b.n	2849c <z_impl_k_sleep+0x34>
   284cc:	000348fa 	.word	0x000348fa
   284d0:	00034992 	.word	0x00034992
   284d4:	000311a3 	.word	0x000311a3
   284d8:	00033242 	.word	0x00033242
   284dc:	2002d2e8 	.word	0x2002d2e8

000284e0 <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
   284e0:	4b01      	ldr	r3, [pc, #4]	; (284e8 <z_impl_k_current_get+0x8>)
   284e2:	6898      	ldr	r0, [r3, #8]
   284e4:	4770      	bx	lr
   284e6:	bf00      	nop
   284e8:	2002d2e8 	.word	0x2002d2e8

000284ec <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   284ec:	b570      	push	{r4, r5, r6, lr}
   284ee:	4604      	mov	r4, r0
   284f0:	f04f 0320 	mov.w	r3, #32
   284f4:	f3ef 8611 	mrs	r6, BASEPRI
   284f8:	f383 8811 	msr	BASEPRI, r3
   284fc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28500:	481a      	ldr	r0, [pc, #104]	; (2856c <z_impl_k_sem_give+0x80>)
   28502:	f000 f8f1 	bl	286e8 <z_spin_lock_valid>
   28506:	b968      	cbnz	r0, 28524 <z_impl_k_sem_give+0x38>
   28508:	234a      	movs	r3, #74	; 0x4a
   2850a:	4a19      	ldr	r2, [pc, #100]	; (28570 <z_impl_k_sem_give+0x84>)
   2850c:	4919      	ldr	r1, [pc, #100]	; (28574 <z_impl_k_sem_give+0x88>)
   2850e:	481a      	ldr	r0, [pc, #104]	; (28578 <z_impl_k_sem_give+0x8c>)
   28510:	f004 fe9b 	bl	2d24a <printk>
   28514:	4915      	ldr	r1, [pc, #84]	; (2856c <z_impl_k_sem_give+0x80>)
   28516:	4819      	ldr	r0, [pc, #100]	; (2857c <z_impl_k_sem_give+0x90>)
   28518:	f004 fe97 	bl	2d24a <printk>
   2851c:	214a      	movs	r1, #74	; 0x4a
   2851e:	4814      	ldr	r0, [pc, #80]	; (28570 <z_impl_k_sem_give+0x84>)
   28520:	f004 fed9 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   28524:	4811      	ldr	r0, [pc, #68]	; (2856c <z_impl_k_sem_give+0x80>)
   28526:	f000 f8fd 	bl	28724 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
   2852a:	4620      	mov	r0, r4
   2852c:	f7ff fdbe 	bl	280ac <z_unpend_first_thread>

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);

	if (thread != NULL) {
   28530:	4605      	mov	r5, r0
   28532:	b170      	cbz	r0, 28552 <z_impl_k_sem_give+0x66>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   28534:	7b43      	ldrb	r3, [r0, #13]
   28536:	06db      	lsls	r3, r3, #27
   28538:	d103      	bne.n	28542 <z_impl_k_sem_give+0x56>
	if (z_is_thread_ready(thread)) {
   2853a:	6983      	ldr	r3, [r0, #24]
   2853c:	b90b      	cbnz	r3, 28542 <z_impl_k_sem_give+0x56>
		z_add_thread_to_ready_q(thread);
   2853e:	f7ff f93f 	bl	277c0 <z_add_thread_to_ready_q>
   28542:	2300      	movs	r3, #0
   28544:	66ab      	str	r3, [r5, #104]	; 0x68
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
   28546:	4631      	mov	r1, r6
}
   28548:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&lock, key);
   2854c:	4807      	ldr	r0, [pc, #28]	; (2856c <z_impl_k_sem_give+0x80>)
   2854e:	f7fe bf4d 	b.w	273ec <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   28552:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   28556:	429a      	cmp	r2, r3
   28558:	bf18      	it	ne
   2855a:	3301      	addne	r3, #1
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   2855c:	2102      	movs	r1, #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   2855e:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   28560:	f104 0010 	add.w	r0, r4, #16
   28564:	f006 fec3 	bl	2f2ee <z_handle_obj_poll_events>
   28568:	e7ed      	b.n	28546 <z_impl_k_sem_give+0x5a>
   2856a:	bf00      	nop
   2856c:	2002d32c 	.word	0x2002d32c
   28570:	00031168 	.word	0x00031168
   28574:	0003118e 	.word	0x0003118e
   28578:	000311a3 	.word	0x000311a3
   2857c:	000311c0 	.word	0x000311c0

00028580 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, s32_t timeout)
{
   28580:	b570      	push	{r4, r5, r6, lr}
   28582:	4605      	mov	r5, r0
   28584:	460e      	mov	r6, r1
   28586:	f3ef 8305 	mrs	r3, IPSR
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");
   2858a:	b16b      	cbz	r3, 285a8 <z_impl_k_sem_take+0x28>
   2858c:	b161      	cbz	r1, 285a8 <z_impl_k_sem_take+0x28>
   2858e:	4934      	ldr	r1, [pc, #208]	; (28660 <z_impl_k_sem_take+0xe0>)
   28590:	238c      	movs	r3, #140	; 0x8c
   28592:	4a34      	ldr	r2, [pc, #208]	; (28664 <z_impl_k_sem_take+0xe4>)
   28594:	4834      	ldr	r0, [pc, #208]	; (28668 <z_impl_k_sem_take+0xe8>)
   28596:	f004 fe58 	bl	2d24a <printk>
   2859a:	4834      	ldr	r0, [pc, #208]	; (2866c <z_impl_k_sem_take+0xec>)
   2859c:	f004 fe55 	bl	2d24a <printk>
   285a0:	218c      	movs	r1, #140	; 0x8c
   285a2:	4830      	ldr	r0, [pc, #192]	; (28664 <z_impl_k_sem_take+0xe4>)
   285a4:	f004 fe97 	bl	2d2d6 <assert_post_action>
   285a8:	f04f 0320 	mov.w	r3, #32
   285ac:	f3ef 8411 	mrs	r4, BASEPRI
   285b0:	f383 8811 	msr	BASEPRI, r3
   285b4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   285b8:	482d      	ldr	r0, [pc, #180]	; (28670 <z_impl_k_sem_take+0xf0>)
   285ba:	f000 f895 	bl	286e8 <z_spin_lock_valid>
   285be:	b968      	cbnz	r0, 285dc <z_impl_k_sem_take+0x5c>
   285c0:	234a      	movs	r3, #74	; 0x4a
   285c2:	4a2c      	ldr	r2, [pc, #176]	; (28674 <z_impl_k_sem_take+0xf4>)
   285c4:	492c      	ldr	r1, [pc, #176]	; (28678 <z_impl_k_sem_take+0xf8>)
   285c6:	4828      	ldr	r0, [pc, #160]	; (28668 <z_impl_k_sem_take+0xe8>)
   285c8:	f004 fe3f 	bl	2d24a <printk>
   285cc:	4928      	ldr	r1, [pc, #160]	; (28670 <z_impl_k_sem_take+0xf0>)
   285ce:	482b      	ldr	r0, [pc, #172]	; (2867c <z_impl_k_sem_take+0xfc>)
   285d0:	f004 fe3b 	bl	2d24a <printk>
   285d4:	214a      	movs	r1, #74	; 0x4a
   285d6:	4827      	ldr	r0, [pc, #156]	; (28674 <z_impl_k_sem_take+0xf4>)
   285d8:	f004 fe7d 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   285dc:	4824      	ldr	r0, [pc, #144]	; (28670 <z_impl_k_sem_take+0xf0>)
   285de:	f000 f8a1 	bl	28724 <z_spin_lock_set_owner>

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
   285e2:	68ab      	ldr	r3, [r5, #8]
   285e4:	b1cb      	cbz	r3, 2861a <z_impl_k_sem_take+0x9a>
		sem->count--;
   285e6:	3b01      	subs	r3, #1
   285e8:	60ab      	str	r3, [r5, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   285ea:	4821      	ldr	r0, [pc, #132]	; (28670 <z_impl_k_sem_take+0xf0>)
   285ec:	f000 f88a 	bl	28704 <z_spin_unlock_valid>
   285f0:	b968      	cbnz	r0, 2860e <z_impl_k_sem_take+0x8e>
   285f2:	235d      	movs	r3, #93	; 0x5d
   285f4:	4a1f      	ldr	r2, [pc, #124]	; (28674 <z_impl_k_sem_take+0xf4>)
   285f6:	4922      	ldr	r1, [pc, #136]	; (28680 <z_impl_k_sem_take+0x100>)
   285f8:	481b      	ldr	r0, [pc, #108]	; (28668 <z_impl_k_sem_take+0xe8>)
   285fa:	f004 fe26 	bl	2d24a <printk>
   285fe:	491c      	ldr	r1, [pc, #112]	; (28670 <z_impl_k_sem_take+0xf0>)
   28600:	4820      	ldr	r0, [pc, #128]	; (28684 <z_impl_k_sem_take+0x104>)
   28602:	f004 fe22 	bl	2d24a <printk>
   28606:	215d      	movs	r1, #93	; 0x5d
   28608:	481a      	ldr	r0, [pc, #104]	; (28674 <z_impl_k_sem_take+0xf4>)
   2860a:	f004 fe64 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   2860e:	f384 8811 	msr	BASEPRI, r4
   28612:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   28616:	2000      	movs	r0, #0
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
   28618:	bd70      	pop	{r4, r5, r6, pc}
	if (timeout == K_NO_WAIT) {
   2861a:	b9c6      	cbnz	r6, 2864e <z_impl_k_sem_take+0xce>
   2861c:	4814      	ldr	r0, [pc, #80]	; (28670 <z_impl_k_sem_take+0xf0>)
   2861e:	f000 f871 	bl	28704 <z_spin_unlock_valid>
   28622:	b968      	cbnz	r0, 28640 <z_impl_k_sem_take+0xc0>
   28624:	235d      	movs	r3, #93	; 0x5d
   28626:	4a13      	ldr	r2, [pc, #76]	; (28674 <z_impl_k_sem_take+0xf4>)
   28628:	4915      	ldr	r1, [pc, #84]	; (28680 <z_impl_k_sem_take+0x100>)
   2862a:	480f      	ldr	r0, [pc, #60]	; (28668 <z_impl_k_sem_take+0xe8>)
   2862c:	f004 fe0d 	bl	2d24a <printk>
   28630:	490f      	ldr	r1, [pc, #60]	; (28670 <z_impl_k_sem_take+0xf0>)
   28632:	4814      	ldr	r0, [pc, #80]	; (28684 <z_impl_k_sem_take+0x104>)
   28634:	f004 fe09 	bl	2d24a <printk>
   28638:	215d      	movs	r1, #93	; 0x5d
   2863a:	480e      	ldr	r0, [pc, #56]	; (28674 <z_impl_k_sem_take+0xf4>)
   2863c:	f004 fe4b 	bl	2d2d6 <assert_post_action>
   28640:	f384 8811 	msr	BASEPRI, r4
   28644:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   28648:	f06f 000f 	mvn.w	r0, #15
		goto out;
   2864c:	e7e4      	b.n	28618 <z_impl_k_sem_take+0x98>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   2864e:	4633      	mov	r3, r6
   28650:	462a      	mov	r2, r5
   28652:	4621      	mov	r1, r4
}
   28654:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   28658:	4805      	ldr	r0, [pc, #20]	; (28670 <z_impl_k_sem_take+0xf0>)
   2865a:	f7ff bc6b 	b.w	27f34 <z_pend_curr>
   2865e:	bf00      	nop
   28660:	00034a63 	.word	0x00034a63
   28664:	00034a43 	.word	0x00034a43
   28668:	000311a3 	.word	0x000311a3
   2866c:	00033242 	.word	0x00033242
   28670:	2002d32c 	.word	0x2002d32c
   28674:	00031168 	.word	0x00031168
   28678:	0003118e 	.word	0x0003118e
   2867c:	000311c0 	.word	0x000311c0
   28680:	00031202 	.word	0x00031202
   28684:	00031219 	.word	0x00031219

00028688 <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
   28688:	b510      	push	{r4, lr}
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
   2868a:	4c08      	ldr	r4, [pc, #32]	; (286ac <k_sys_work_q_init+0x24>)
   2868c:	f04f 33ff 	mov.w	r3, #4294967295
   28690:	f44f 6200 	mov.w	r2, #2048	; 0x800
   28694:	4906      	ldr	r1, [pc, #24]	; (286b0 <k_sys_work_q_init+0x28>)
   28696:	4620      	mov	r0, r4
   28698:	f000 f9d6 	bl	28a48 <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
   2869c:	4905      	ldr	r1, [pc, #20]	; (286b4 <k_sys_work_q_init+0x2c>)
   2869e:	f104 0014 	add.w	r0, r4, #20
   286a2:	f006 fd1f 	bl	2f0e4 <z_impl_k_thread_name_set>
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
   286a6:	2000      	movs	r0, #0
   286a8:	bd10      	pop	{r4, pc}
   286aa:	bf00      	nop
   286ac:	2002d330 	.word	0x2002d330
   286b0:	20036558 	.word	0x20036558
   286b4:	00034a8f 	.word	0x00034a8f

000286b8 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
   286b8:	b530      	push	{r4, r5, lr}
   286ba:	b087      	sub	sp, #28
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   286bc:	9d0e      	ldr	r5, [sp, #56]	; 0x38
{
   286be:	4604      	mov	r4, r0
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   286c0:	9504      	str	r5, [sp, #16]
   286c2:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   286c4:	9503      	str	r5, [sp, #12]
   286c6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   286c8:	9502      	str	r5, [sp, #8]
   286ca:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   286cc:	9501      	str	r5, [sp, #4]
   286ce:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   286d0:	9500      	str	r5, [sp, #0]
   286d2:	f7f0 fceb 	bl	190ac <arch_new_thread>
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
   286d6:	4b03      	ldr	r3, [pc, #12]	; (286e4 <z_setup_new_thread+0x2c>)
   286d8:	689b      	ldr	r3, [r3, #8]
   286da:	b103      	cbz	r3, 286de <z_setup_new_thread+0x26>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
   286dc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
   286de:	6623      	str	r3, [r4, #96]	; 0x60
	sys_trace_thread_create(new_thread);
}
   286e0:	b007      	add	sp, #28
   286e2:	bd30      	pop	{r4, r5, pc}
   286e4:	2002d2e8 	.word	0x2002d2e8

000286e8 <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
   286e8:	6800      	ldr	r0, [r0, #0]

	if (thread_cpu) {
   286ea:	b138      	cbz	r0, 286fc <z_spin_lock_valid+0x14>
		if ((thread_cpu & 3) == _current_cpu->id) {
   286ec:	4b04      	ldr	r3, [pc, #16]	; (28700 <z_spin_lock_valid+0x18>)
   286ee:	f000 0003 	and.w	r0, r0, #3
   286f2:	7d1b      	ldrb	r3, [r3, #20]
   286f4:	1ac0      	subs	r0, r0, r3
   286f6:	bf18      	it	ne
   286f8:	2001      	movne	r0, #1
   286fa:	4770      	bx	lr
			return false;
		}
	}
	return true;
   286fc:	2001      	movs	r0, #1
}
   286fe:	4770      	bx	lr
   28700:	2002d2e8 	.word	0x2002d2e8

00028704 <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
   28704:	4a06      	ldr	r2, [pc, #24]	; (28720 <z_spin_unlock_valid+0x1c>)
   28706:	7d11      	ldrb	r1, [r2, #20]
   28708:	6893      	ldr	r3, [r2, #8]
   2870a:	6802      	ldr	r2, [r0, #0]
   2870c:	430b      	orrs	r3, r1
   2870e:	429a      	cmp	r2, r3
   28710:	f04f 0300 	mov.w	r3, #0
		return false;
	}
	l->thread_cpu = 0;
   28714:	bf06      	itte	eq
   28716:	6003      	streq	r3, [r0, #0]
	return true;
   28718:	2001      	moveq	r0, #1
		return false;
   2871a:	4618      	movne	r0, r3
}
   2871c:	4770      	bx	lr
   2871e:	bf00      	nop
   28720:	2002d2e8 	.word	0x2002d2e8

00028724 <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
   28724:	4a02      	ldr	r2, [pc, #8]	; (28730 <z_spin_lock_set_owner+0xc>)
   28726:	7d11      	ldrb	r1, [r2, #20]
   28728:	6893      	ldr	r3, [r2, #8]
   2872a:	430b      	orrs	r3, r1
   2872c:	6003      	str	r3, [r0, #0]
}
   2872e:	4770      	bx	lr
   28730:	2002d2e8 	.word	0x2002d2e8

00028734 <z_impl_k_thread_start>:
{
   28734:	b538      	push	{r3, r4, r5, lr}
   28736:	4604      	mov	r4, r0
	__asm__ volatile(
   28738:	f04f 0320 	mov.w	r3, #32
   2873c:	f3ef 8511 	mrs	r5, BASEPRI
   28740:	f383 8811 	msr	BASEPRI, r3
   28744:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28748:	481f      	ldr	r0, [pc, #124]	; (287c8 <z_impl_k_thread_start+0x94>)
   2874a:	f7ff ffcd 	bl	286e8 <z_spin_lock_valid>
   2874e:	b968      	cbnz	r0, 2876c <z_impl_k_thread_start+0x38>
   28750:	234a      	movs	r3, #74	; 0x4a
   28752:	4a1e      	ldr	r2, [pc, #120]	; (287cc <z_impl_k_thread_start+0x98>)
   28754:	491e      	ldr	r1, [pc, #120]	; (287d0 <z_impl_k_thread_start+0x9c>)
   28756:	481f      	ldr	r0, [pc, #124]	; (287d4 <z_impl_k_thread_start+0xa0>)
   28758:	f004 fd77 	bl	2d24a <printk>
   2875c:	491a      	ldr	r1, [pc, #104]	; (287c8 <z_impl_k_thread_start+0x94>)
   2875e:	481e      	ldr	r0, [pc, #120]	; (287d8 <z_impl_k_thread_start+0xa4>)
   28760:	f004 fd73 	bl	2d24a <printk>
   28764:	214a      	movs	r1, #74	; 0x4a
   28766:	4819      	ldr	r0, [pc, #100]	; (287cc <z_impl_k_thread_start+0x98>)
   28768:	f004 fdb5 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   2876c:	4816      	ldr	r0, [pc, #88]	; (287c8 <z_impl_k_thread_start+0x94>)
   2876e:	f7ff ffd9 	bl	28724 <z_spin_lock_set_owner>
	if (z_has_thread_started(thread)) {
   28772:	7b63      	ldrb	r3, [r4, #13]
   28774:	075a      	lsls	r2, r3, #29
   28776:	d416      	bmi.n	287a6 <z_impl_k_thread_start+0x72>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28778:	4813      	ldr	r0, [pc, #76]	; (287c8 <z_impl_k_thread_start+0x94>)
   2877a:	f7ff ffc3 	bl	28704 <z_spin_unlock_valid>
   2877e:	b968      	cbnz	r0, 2879c <z_impl_k_thread_start+0x68>
   28780:	235d      	movs	r3, #93	; 0x5d
   28782:	4a12      	ldr	r2, [pc, #72]	; (287cc <z_impl_k_thread_start+0x98>)
   28784:	4915      	ldr	r1, [pc, #84]	; (287dc <z_impl_k_thread_start+0xa8>)
   28786:	4813      	ldr	r0, [pc, #76]	; (287d4 <z_impl_k_thread_start+0xa0>)
   28788:	f004 fd5f 	bl	2d24a <printk>
   2878c:	490e      	ldr	r1, [pc, #56]	; (287c8 <z_impl_k_thread_start+0x94>)
   2878e:	4814      	ldr	r0, [pc, #80]	; (287e0 <z_impl_k_thread_start+0xac>)
   28790:	f004 fd5b 	bl	2d24a <printk>
   28794:	215d      	movs	r1, #93	; 0x5d
   28796:	480d      	ldr	r0, [pc, #52]	; (287cc <z_impl_k_thread_start+0x98>)
   28798:	f004 fd9d 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   2879c:	f385 8811 	msr	BASEPRI, r5
   287a0:	f3bf 8f6f 	isb	sy
}
   287a4:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   287a6:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   287aa:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
   287ae:	7362      	strb	r2, [r4, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   287b0:	d104      	bne.n	287bc <z_impl_k_thread_start+0x88>
	if (z_is_thread_ready(thread)) {
   287b2:	69a3      	ldr	r3, [r4, #24]
   287b4:	b913      	cbnz	r3, 287bc <z_impl_k_thread_start+0x88>
		z_add_thread_to_ready_q(thread);
   287b6:	4620      	mov	r0, r4
   287b8:	f7ff f802 	bl	277c0 <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
   287bc:	4629      	mov	r1, r5
}
   287be:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   287c2:	4801      	ldr	r0, [pc, #4]	; (287c8 <z_impl_k_thread_start+0x94>)
   287c4:	f7fe be12 	b.w	273ec <z_reschedule>
   287c8:	2002d3f4 	.word	0x2002d3f4
   287cc:	00031168 	.word	0x00031168
   287d0:	0003118e 	.word	0x0003118e
   287d4:	000311a3 	.word	0x000311a3
   287d8:	000311c0 	.word	0x000311c0
   287dc:	00031202 	.word	0x00031202
   287e0:	00031219 	.word	0x00031219

000287e4 <z_impl_k_thread_create>:
{
   287e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   287e8:	b086      	sub	sp, #24
   287ea:	4604      	mov	r4, r0
   287ec:	460e      	mov	r6, r1
   287ee:	4617      	mov	r7, r2
   287f0:	4698      	mov	r8, r3
   287f2:	9d11      	ldr	r5, [sp, #68]	; 0x44
   287f4:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
   287f8:	b173      	cbz	r3, 28818 <z_impl_k_thread_create+0x34>
   287fa:	491f      	ldr	r1, [pc, #124]	; (28878 <z_impl_k_thread_create+0x94>)
   287fc:	f240 2357 	movw	r3, #599	; 0x257
   28800:	4a1e      	ldr	r2, [pc, #120]	; (2887c <z_impl_k_thread_create+0x98>)
   28802:	481f      	ldr	r0, [pc, #124]	; (28880 <z_impl_k_thread_create+0x9c>)
   28804:	f004 fd21 	bl	2d24a <printk>
   28808:	481e      	ldr	r0, [pc, #120]	; (28884 <z_impl_k_thread_create+0xa0>)
   2880a:	f004 fd1e 	bl	2d24a <printk>
   2880e:	f240 2157 	movw	r1, #599	; 0x257
   28812:	481a      	ldr	r0, [pc, #104]	; (2887c <z_impl_k_thread_create+0x98>)
   28814:	f004 fd5f 	bl	2d2d6 <assert_post_action>
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   28818:	2300      	movs	r3, #0
   2881a:	9305      	str	r3, [sp, #20]
   2881c:	9b10      	ldr	r3, [sp, #64]	; 0x40
   2881e:	463a      	mov	r2, r7
   28820:	9304      	str	r3, [sp, #16]
   28822:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   28824:	4631      	mov	r1, r6
   28826:	9303      	str	r3, [sp, #12]
   28828:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   2882a:	4620      	mov	r0, r4
   2882c:	9302      	str	r3, [sp, #8]
   2882e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   28830:	9301      	str	r3, [sp, #4]
   28832:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   28834:	9300      	str	r3, [sp, #0]
   28836:	4643      	mov	r3, r8
   28838:	f7ff ff3e 	bl	286b8 <z_setup_new_thread>
	if (delay != K_FOREVER) {
   2883c:	1c6b      	adds	r3, r5, #1
   2883e:	d003      	beq.n	28848 <z_impl_k_thread_create+0x64>
	if (delay == 0) {
   28840:	b935      	cbnz	r5, 28850 <z_impl_k_thread_create+0x6c>
	z_impl_k_thread_start(thread);
   28842:	4620      	mov	r0, r4
   28844:	f7ff ff76 	bl	28734 <z_impl_k_thread_start>
}
   28848:	4620      	mov	r0, r4
   2884a:	b006      	add	sp, #24
   2884c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			return (u32_t)((t * to_hz + off) / from_hz);
   28850:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   28854:	f240 30e7 	movw	r0, #999	; 0x3e7
   28858:	2100      	movs	r1, #0
   2885a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2885e:	2300      	movs	r3, #0
   28860:	fbe6 0105 	umlal	r0, r1, r6, r5
   28864:	f7e4 f9b2 	bl	cbcc <__aeabi_uldivmod>
   28868:	4907      	ldr	r1, [pc, #28]	; (28888 <z_impl_k_thread_create+0xa4>)
   2886a:	1c42      	adds	r2, r0, #1
   2886c:	f104 0018 	add.w	r0, r4, #24
   28870:	f000 f9d4 	bl	28c1c <z_add_timeout>
   28874:	e7e8      	b.n	28848 <z_impl_k_thread_create+0x64>
   28876:	bf00      	nop
   28878:	000348fa 	.word	0x000348fa
   2887c:	00034a98 	.word	0x00034a98
   28880:	000311a3 	.word	0x000311a3
   28884:	00034abb 	.word	0x00034abb
   28888:	000278c1 	.word	0x000278c1

0002888c <z_init_static_threads>:
{
   2888c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   28890:	4f3c      	ldr	r7, [pc, #240]	; (28984 <z_init_static_threads+0xf8>)
   28892:	4d3d      	ldr	r5, [pc, #244]	; (28988 <z_init_static_threads+0xfc>)
   28894:	463e      	mov	r6, r7
   28896:	f8df 8100 	ldr.w	r8, [pc, #256]	; 28998 <z_init_static_threads+0x10c>
{
   2889a:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
   2889c:	42bd      	cmp	r5, r7
   2889e:	d90e      	bls.n	288be <z_init_static_threads+0x32>
   288a0:	493a      	ldr	r1, [pc, #232]	; (2898c <z_init_static_threads+0x100>)
   288a2:	f240 23e7 	movw	r3, #743	; 0x2e7
   288a6:	4642      	mov	r2, r8
   288a8:	4839      	ldr	r0, [pc, #228]	; (28990 <z_init_static_threads+0x104>)
   288aa:	f004 fcce 	bl	2d24a <printk>
   288ae:	4839      	ldr	r0, [pc, #228]	; (28994 <z_init_static_threads+0x108>)
   288b0:	f004 fccb 	bl	2d24a <printk>
   288b4:	f240 21e7 	movw	r1, #743	; 0x2e7
   288b8:	4640      	mov	r0, r8
   288ba:	f004 fd0c 	bl	2d2d6 <assert_post_action>
   288be:	42b5      	cmp	r5, r6
   288c0:	f105 0430 	add.w	r4, r5, #48	; 0x30
   288c4:	d31f      	bcc.n	28906 <z_init_static_threads+0x7a>
	k_sched_lock();
   288c6:	f7fe fdcd 	bl	27464 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   288ca:	4c2f      	ldr	r4, [pc, #188]	; (28988 <z_init_static_threads+0xfc>)
   288cc:	4d32      	ldr	r5, [pc, #200]	; (28998 <z_init_static_threads+0x10c>)
   288ce:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 2898c <z_init_static_threads+0x100>
   288d2:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 28990 <z_init_static_threads+0x104>
   288d6:	42b4      	cmp	r4, r6
   288d8:	d90e      	bls.n	288f8 <z_init_static_threads+0x6c>
   288da:	4641      	mov	r1, r8
   288dc:	f240 3306 	movw	r3, #774	; 0x306
   288e0:	462a      	mov	r2, r5
   288e2:	4648      	mov	r0, r9
   288e4:	f004 fcb1 	bl	2d24a <printk>
   288e8:	482a      	ldr	r0, [pc, #168]	; (28994 <z_init_static_threads+0x108>)
   288ea:	f004 fcae 	bl	2d24a <printk>
   288ee:	f240 3106 	movw	r1, #774	; 0x306
   288f2:	4628      	mov	r0, r5
   288f4:	f004 fcef 	bl	2d2d6 <assert_post_action>
   288f8:	42b4      	cmp	r4, r6
   288fa:	d321      	bcc.n	28940 <z_init_static_threads+0xb4>
}
   288fc:	b007      	add	sp, #28
   288fe:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_sched_unlock();
   28902:	f7fe bee1 	b.w	276c8 <k_sched_unlock>
		z_setup_new_thread(
   28906:	f854 3c04 	ldr.w	r3, [r4, #-4]
   2890a:	9305      	str	r3, [sp, #20]
   2890c:	f854 3c10 	ldr.w	r3, [r4, #-16]
   28910:	9304      	str	r3, [sp, #16]
   28912:	f854 3c14 	ldr.w	r3, [r4, #-20]
   28916:	9303      	str	r3, [sp, #12]
   28918:	f854 3c18 	ldr.w	r3, [r4, #-24]
   2891c:	9302      	str	r3, [sp, #8]
   2891e:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   28922:	9301      	str	r3, [sp, #4]
   28924:	f854 3c20 	ldr.w	r3, [r4, #-32]
   28928:	9300      	str	r3, [sp, #0]
   2892a:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   2892e:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   28932:	f7ff fec1 	bl	286b8 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   28936:	f854 3c30 	ldr.w	r3, [r4, #-48]
   2893a:	64dd      	str	r5, [r3, #76]	; 0x4c
   2893c:	4625      	mov	r5, r4
   2893e:	e7ad      	b.n	2889c <z_init_static_threads+0x10>
		if (thread_data->init_delay != K_FOREVER) {
   28940:	f8d4 c024 	ldr.w	ip, [r4, #36]	; 0x24
   28944:	f1bc 3fff 	cmp.w	ip, #4294967295
   28948:	d006      	beq.n	28958 <z_init_static_threads+0xcc>
			schedule_new_thread(thread_data->init_thread,
   2894a:	6827      	ldr	r7, [r4, #0]
	if (delay == 0) {
   2894c:	f1bc 0f00 	cmp.w	ip, #0
   28950:	d104      	bne.n	2895c <z_init_static_threads+0xd0>
   28952:	4638      	mov	r0, r7
   28954:	f7ff feee 	bl	28734 <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   28958:	3430      	adds	r4, #48	; 0x30
   2895a:	e7bc      	b.n	288d6 <z_init_static_threads+0x4a>
   2895c:	f44f 4e00 	mov.w	lr, #32768	; 0x8000
   28960:	f240 30e7 	movw	r0, #999	; 0x3e7
   28964:	2100      	movs	r1, #0
   28966:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2896a:	2300      	movs	r3, #0
   2896c:	fbee 010c 	umlal	r0, r1, lr, ip
   28970:	f7e4 f92c 	bl	cbcc <__aeabi_uldivmod>
   28974:	4909      	ldr	r1, [pc, #36]	; (2899c <z_init_static_threads+0x110>)
   28976:	1c42      	adds	r2, r0, #1
   28978:	f107 0018 	add.w	r0, r7, #24
   2897c:	f000 f94e 	bl	28c1c <z_add_timeout>
   28980:	e7ea      	b.n	28958 <z_init_static_threads+0xcc>
   28982:	bf00      	nop
   28984:	2003b6e4 	.word	0x2003b6e4
   28988:	2003b6e4 	.word	0x2003b6e4
   2898c:	00034ae0 	.word	0x00034ae0
   28990:	000311a3 	.word	0x000311a3
   28994:	000347d1 	.word	0x000347d1
   28998:	00034a98 	.word	0x00034a98
   2899c:	000278c1 	.word	0x000278c1

000289a0 <z_impl_k_thread_suspend>:
{
   289a0:	b538      	push	{r3, r4, r5, lr}
   289a2:	4605      	mov	r5, r0
	__asm__ volatile(
   289a4:	f04f 0320 	mov.w	r3, #32
   289a8:	f3ef 8411 	mrs	r4, BASEPRI
   289ac:	f383 8811 	msr	BASEPRI, r3
   289b0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   289b4:	481c      	ldr	r0, [pc, #112]	; (28a28 <z_impl_k_thread_suspend+0x88>)
   289b6:	f7ff fe97 	bl	286e8 <z_spin_lock_valid>
   289ba:	b968      	cbnz	r0, 289d8 <z_impl_k_thread_suspend+0x38>
   289bc:	234a      	movs	r3, #74	; 0x4a
   289be:	4a1b      	ldr	r2, [pc, #108]	; (28a2c <z_impl_k_thread_suspend+0x8c>)
   289c0:	491b      	ldr	r1, [pc, #108]	; (28a30 <z_impl_k_thread_suspend+0x90>)
   289c2:	481c      	ldr	r0, [pc, #112]	; (28a34 <z_impl_k_thread_suspend+0x94>)
   289c4:	f004 fc41 	bl	2d24a <printk>
   289c8:	4917      	ldr	r1, [pc, #92]	; (28a28 <z_impl_k_thread_suspend+0x88>)
   289ca:	481b      	ldr	r0, [pc, #108]	; (28a38 <z_impl_k_thread_suspend+0x98>)
   289cc:	f004 fc3d 	bl	2d24a <printk>
   289d0:	214a      	movs	r1, #74	; 0x4a
   289d2:	4816      	ldr	r0, [pc, #88]	; (28a2c <z_impl_k_thread_suspend+0x8c>)
   289d4:	f004 fc7f 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   289d8:	4813      	ldr	r0, [pc, #76]	; (28a28 <z_impl_k_thread_suspend+0x88>)
   289da:	f7ff fea3 	bl	28724 <z_spin_lock_set_owner>
	z_thread_single_suspend(thread);
   289de:	4628      	mov	r0, r5
   289e0:	f7ff f89c 	bl	27b1c <z_thread_single_suspend>
	if (thread == _current) {
   289e4:	4b15      	ldr	r3, [pc, #84]	; (28a3c <z_impl_k_thread_suspend+0x9c>)
   289e6:	689b      	ldr	r3, [r3, #8]
   289e8:	42ab      	cmp	r3, r5
   289ea:	d105      	bne.n	289f8 <z_impl_k_thread_suspend+0x58>
		z_reschedule(&lock, key);
   289ec:	4621      	mov	r1, r4
}
   289ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&lock, key);
   289f2:	480d      	ldr	r0, [pc, #52]	; (28a28 <z_impl_k_thread_suspend+0x88>)
   289f4:	f7fe bcfa 	b.w	273ec <z_reschedule>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   289f8:	480b      	ldr	r0, [pc, #44]	; (28a28 <z_impl_k_thread_suspend+0x88>)
   289fa:	f7ff fe83 	bl	28704 <z_spin_unlock_valid>
   289fe:	b968      	cbnz	r0, 28a1c <z_impl_k_thread_suspend+0x7c>
   28a00:	235d      	movs	r3, #93	; 0x5d
   28a02:	4a0a      	ldr	r2, [pc, #40]	; (28a2c <z_impl_k_thread_suspend+0x8c>)
   28a04:	490e      	ldr	r1, [pc, #56]	; (28a40 <z_impl_k_thread_suspend+0xa0>)
   28a06:	480b      	ldr	r0, [pc, #44]	; (28a34 <z_impl_k_thread_suspend+0x94>)
   28a08:	f004 fc1f 	bl	2d24a <printk>
   28a0c:	4906      	ldr	r1, [pc, #24]	; (28a28 <z_impl_k_thread_suspend+0x88>)
   28a0e:	480d      	ldr	r0, [pc, #52]	; (28a44 <z_impl_k_thread_suspend+0xa4>)
   28a10:	f004 fc1b 	bl	2d24a <printk>
   28a14:	215d      	movs	r1, #93	; 0x5d
   28a16:	4805      	ldr	r0, [pc, #20]	; (28a2c <z_impl_k_thread_suspend+0x8c>)
   28a18:	f004 fc5d 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   28a1c:	f384 8811 	msr	BASEPRI, r4
   28a20:	f3bf 8f6f 	isb	sy
}
   28a24:	bd38      	pop	{r3, r4, r5, pc}
   28a26:	bf00      	nop
   28a28:	2002d3f4 	.word	0x2002d3f4
   28a2c:	00031168 	.word	0x00031168
   28a30:	0003118e 	.word	0x0003118e
   28a34:	000311a3 	.word	0x000311a3
   28a38:	000311c0 	.word	0x000311c0
   28a3c:	2002d2e8 	.word	0x2002d2e8
   28a40:	00031202 	.word	0x00031202
   28a44:	00031219 	.word	0x00031219

00028a48 <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
   28a48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   28a4c:	4605      	mov	r5, r0
   28a4e:	b086      	sub	sp, #24
   28a50:	460e      	mov	r6, r1
   28a52:	4617      	mov	r7, r2
   28a54:	4698      	mov	r8, r3
	z_impl_k_queue_init(queue);
   28a56:	f006 fadb 	bl	2f010 <z_impl_k_queue_init>
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
   28a5a:	f105 0414 	add.w	r4, r5, #20
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   28a5e:	2000      	movs	r0, #0
   28a60:	4b09      	ldr	r3, [pc, #36]	; (28a88 <k_work_q_start+0x40>)
   28a62:	e9cd 0004 	strd	r0, r0, [sp, #16]
   28a66:	e9cd 0802 	strd	r0, r8, [sp, #8]
   28a6a:	e9cd 5000 	strd	r5, r0, [sp]
   28a6e:	463a      	mov	r2, r7
   28a70:	4631      	mov	r1, r6
   28a72:	4620      	mov	r0, r4
   28a74:	f7ff feb6 	bl	287e4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   28a78:	4620      	mov	r0, r4
   28a7a:	4904      	ldr	r1, [pc, #16]	; (28a8c <k_work_q_start+0x44>)
			work_q, NULL, NULL, prio, 0, K_NO_WAIT);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
   28a7c:	b006      	add	sp, #24
   28a7e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   28a82:	f006 bb2f 	b.w	2f0e4 <z_impl_k_thread_name_set>
   28a86:	bf00      	nop
   28a88:	0002d2a1 	.word	0x0002d2a1
   28a8c:	00031256 	.word	0x00031256

00028a90 <k_delayed_work_submit_to_queue>:
}

int k_delayed_work_submit_to_queue(struct k_work_q *work_q,
				   struct k_delayed_work *work,
				   s32_t delay)
{
   28a90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   28a94:	4606      	mov	r6, r0
   28a96:	460d      	mov	r5, r1
   28a98:	4690      	mov	r8, r2
	__asm__ volatile(
   28a9a:	f04f 0320 	mov.w	r3, #32
   28a9e:	f3ef 8711 	mrs	r7, BASEPRI
   28aa2:	f383 8811 	msr	BASEPRI, r3
   28aa6:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28aaa:	4837      	ldr	r0, [pc, #220]	; (28b88 <k_delayed_work_submit_to_queue+0xf8>)
   28aac:	f7ff fe1c 	bl	286e8 <z_spin_lock_valid>
   28ab0:	b968      	cbnz	r0, 28ace <k_delayed_work_submit_to_queue+0x3e>
   28ab2:	234a      	movs	r3, #74	; 0x4a
   28ab4:	4a35      	ldr	r2, [pc, #212]	; (28b8c <k_delayed_work_submit_to_queue+0xfc>)
   28ab6:	4936      	ldr	r1, [pc, #216]	; (28b90 <k_delayed_work_submit_to_queue+0x100>)
   28ab8:	4836      	ldr	r0, [pc, #216]	; (28b94 <k_delayed_work_submit_to_queue+0x104>)
   28aba:	f004 fbc6 	bl	2d24a <printk>
   28abe:	4932      	ldr	r1, [pc, #200]	; (28b88 <k_delayed_work_submit_to_queue+0xf8>)
   28ac0:	4835      	ldr	r0, [pc, #212]	; (28b98 <k_delayed_work_submit_to_queue+0x108>)
   28ac2:	f004 fbc2 	bl	2d24a <printk>
   28ac6:	214a      	movs	r1, #74	; 0x4a
   28ac8:	4830      	ldr	r0, [pc, #192]	; (28b8c <k_delayed_work_submit_to_queue+0xfc>)
   28aca:	f004 fc04 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   28ace:	482e      	ldr	r0, [pc, #184]	; (28b88 <k_delayed_work_submit_to_queue+0xf8>)
   28ad0:	f7ff fe28 	bl	28724 <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	int err = 0;

	/* Work cannot be active in multiple queues */
	if (work->work_q != NULL && work->work_q != work_q) {
   28ad4:	69ec      	ldr	r4, [r5, #28]
   28ad6:	b1ec      	cbz	r4, 28b14 <k_delayed_work_submit_to_queue+0x84>
   28ad8:	42b4      	cmp	r4, r6
   28ada:	d152      	bne.n	28b82 <k_delayed_work_submit_to_queue+0xf2>
		goto done;
	}

	/* Cancel if work has been submitted */
	if (work->work_q == work_q) {
		err = work_cancel(work);
   28adc:	4628      	mov	r0, r5
   28ade:	f006 fb2e 	bl	2f13e <work_cancel>
		if (err < 0) {
   28ae2:	1e04      	subs	r4, r0, #0
   28ae4:	da18      	bge.n	28b18 <k_delayed_work_submit_to_queue+0x88>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28ae6:	4828      	ldr	r0, [pc, #160]	; (28b88 <k_delayed_work_submit_to_queue+0xf8>)
   28ae8:	f7ff fe0c 	bl	28704 <z_spin_unlock_valid>
   28aec:	b968      	cbnz	r0, 28b0a <k_delayed_work_submit_to_queue+0x7a>
   28aee:	235d      	movs	r3, #93	; 0x5d
   28af0:	4a26      	ldr	r2, [pc, #152]	; (28b8c <k_delayed_work_submit_to_queue+0xfc>)
   28af2:	492a      	ldr	r1, [pc, #168]	; (28b9c <k_delayed_work_submit_to_queue+0x10c>)
   28af4:	4827      	ldr	r0, [pc, #156]	; (28b94 <k_delayed_work_submit_to_queue+0x104>)
   28af6:	f004 fba8 	bl	2d24a <printk>
   28afa:	4923      	ldr	r1, [pc, #140]	; (28b88 <k_delayed_work_submit_to_queue+0xf8>)
   28afc:	4828      	ldr	r0, [pc, #160]	; (28ba0 <k_delayed_work_submit_to_queue+0x110>)
   28afe:	f004 fba4 	bl	2d24a <printk>
   28b02:	215d      	movs	r1, #93	; 0x5d
   28b04:	4821      	ldr	r0, [pc, #132]	; (28b8c <k_delayed_work_submit_to_queue+0xfc>)
   28b06:	f004 fbe6 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   28b0a:	f387 8811 	msr	BASEPRI, r7
   28b0e:	f3bf 8f6f 	isb	sy
	z_add_timeout(&work->timeout, work_timeout,
		     _TICK_ALIGN + k_ms_to_ticks_ceil32(delay));

done:
	k_spin_unlock(&lock, key);
	return err;
   28b12:	e020      	b.n	28b56 <k_delayed_work_submit_to_queue+0xc6>
	if (work->work_q == work_q) {
   28b14:	2e00      	cmp	r6, #0
   28b16:	d0e1      	beq.n	28adc <k_delayed_work_submit_to_queue+0x4c>
	work->work_q = work_q;
   28b18:	61ee      	str	r6, [r5, #28]
	if (delay == 0) {
   28b1a:	f1b8 0f00 	cmp.w	r8, #0
   28b1e:	d11d      	bne.n	28b5c <k_delayed_work_submit_to_queue+0xcc>
   28b20:	4819      	ldr	r0, [pc, #100]	; (28b88 <k_delayed_work_submit_to_queue+0xf8>)
   28b22:	f7ff fdef 	bl	28704 <z_spin_unlock_valid>
   28b26:	b968      	cbnz	r0, 28b44 <k_delayed_work_submit_to_queue+0xb4>
   28b28:	235d      	movs	r3, #93	; 0x5d
   28b2a:	4a18      	ldr	r2, [pc, #96]	; (28b8c <k_delayed_work_submit_to_queue+0xfc>)
   28b2c:	491b      	ldr	r1, [pc, #108]	; (28b9c <k_delayed_work_submit_to_queue+0x10c>)
   28b2e:	4819      	ldr	r0, [pc, #100]	; (28b94 <k_delayed_work_submit_to_queue+0x104>)
   28b30:	f004 fb8b 	bl	2d24a <printk>
   28b34:	4914      	ldr	r1, [pc, #80]	; (28b88 <k_delayed_work_submit_to_queue+0xf8>)
   28b36:	481a      	ldr	r0, [pc, #104]	; (28ba0 <k_delayed_work_submit_to_queue+0x110>)
   28b38:	f004 fb87 	bl	2d24a <printk>
   28b3c:	215d      	movs	r1, #93	; 0x5d
   28b3e:	4813      	ldr	r0, [pc, #76]	; (28b8c <k_delayed_work_submit_to_queue+0xfc>)
   28b40:	f004 fbc9 	bl	2d2d6 <assert_post_action>
   28b44:	f387 8811 	msr	BASEPRI, r7
   28b48:	f3bf 8f6f 	isb	sy
		k_work_submit_to_queue(work_q, &work->work);
   28b4c:	4629      	mov	r1, r5
   28b4e:	4630      	mov	r0, r6
   28b50:	f006 fadc 	bl	2f10c <k_work_submit_to_queue>
		return 0;
   28b54:	2400      	movs	r4, #0
}
   28b56:	4620      	mov	r0, r4
   28b58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   28b5c:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   28b60:	f240 30e7 	movw	r0, #999	; 0x3e7
   28b64:	2100      	movs	r1, #0
   28b66:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   28b6a:	2300      	movs	r3, #0
   28b6c:	fbe6 0108 	umlal	r0, r1, r6, r8
   28b70:	f7e4 f82c 	bl	cbcc <__aeabi_uldivmod>
	z_add_timeout(&work->timeout, work_timeout,
   28b74:	490b      	ldr	r1, [pc, #44]	; (28ba4 <k_delayed_work_submit_to_queue+0x114>)
   28b76:	1c42      	adds	r2, r0, #1
   28b78:	f105 000c 	add.w	r0, r5, #12
   28b7c:	f000 f84e 	bl	28c1c <z_add_timeout>
   28b80:	e7b1      	b.n	28ae6 <k_delayed_work_submit_to_queue+0x56>
		err = -EADDRINUSE;
   28b82:	f06f 046f 	mvn.w	r4, #111	; 0x6f
   28b86:	e7ae      	b.n	28ae6 <k_delayed_work_submit_to_queue+0x56>
   28b88:	2002d3f8 	.word	0x2002d3f8
   28b8c:	00031168 	.word	0x00031168
   28b90:	0003118e 	.word	0x0003118e
   28b94:	000311a3 	.word	0x000311a3
   28b98:	000311c0 	.word	0x000311c0
   28b9c:	00031202 	.word	0x00031202
   28ba0:	00031219 	.word	0x00031219
   28ba4:	0002f135 	.word	0x0002f135

00028ba8 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
   28ba8:	4b03      	ldr	r3, [pc, #12]	; (28bb8 <elapsed+0x10>)
   28baa:	681b      	ldr	r3, [r3, #0]
   28bac:	b90b      	cbnz	r3, 28bb2 <elapsed+0xa>
   28bae:	f7f0 b831 	b.w	18c14 <z_clock_elapsed>
}
   28bb2:	2000      	movs	r0, #0
   28bb4:	4770      	bx	lr
   28bb6:	bf00      	nop
   28bb8:	2002d3fc 	.word	0x2002d3fc

00028bbc <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   28bbc:	6803      	ldr	r3, [r0, #0]
   28bbe:	b140      	cbz	r0, 28bd2 <remove_timeout+0x16>
   28bc0:	4a07      	ldr	r2, [pc, #28]	; (28be0 <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
   28bc2:	6852      	ldr	r2, [r2, #4]
   28bc4:	4290      	cmp	r0, r2
   28bc6:	d004      	beq.n	28bd2 <remove_timeout+0x16>
	if (next(t) != NULL) {
   28bc8:	b11b      	cbz	r3, 28bd2 <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
   28bca:	689a      	ldr	r2, [r3, #8]
   28bcc:	6881      	ldr	r1, [r0, #8]
   28bce:	440a      	add	r2, r1
   28bd0:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
   28bd2:	6842      	ldr	r2, [r0, #4]
   28bd4:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   28bd6:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   28bd8:	2300      	movs	r3, #0
	node->prev = NULL;
   28bda:	e9c0 3300 	strd	r3, r3, [r0]
}
   28bde:	4770      	bx	lr
   28be0:	200383cc 	.word	0x200383cc

00028be4 <next_timeout>:
	return list->head == list;
   28be4:	4b0b      	ldr	r3, [pc, #44]	; (28c14 <next_timeout+0x30>)

static s32_t next_timeout(void)
{
   28be6:	b510      	push	{r4, lr}
   28be8:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   28bea:	429c      	cmp	r4, r3
   28bec:	bf08      	it	eq
   28bee:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
   28bf0:	f7ff ffda 	bl	28ba8 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   28bf4:	b154      	cbz	r4, 28c0c <next_timeout+0x28>
   28bf6:	68a3      	ldr	r3, [r4, #8]
   28bf8:	1a18      	subs	r0, r3, r0
   28bfa:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   28bfe:	4b06      	ldr	r3, [pc, #24]	; (28c18 <next_timeout+0x34>)
   28c00:	691b      	ldr	r3, [r3, #16]
   28c02:	b113      	cbz	r3, 28c0a <next_timeout+0x26>
   28c04:	4298      	cmp	r0, r3
   28c06:	bfa8      	it	ge
   28c08:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   28c0a:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   28c0c:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   28c10:	e7f5      	b.n	28bfe <next_timeout+0x1a>
   28c12:	bf00      	nop
   28c14:	200383cc 	.word	0x200383cc
   28c18:	2002d2e8 	.word	0x2002d2e8

00028c1c <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
   28c1c:	6803      	ldr	r3, [r0, #0]
{
   28c1e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   28c22:	4604      	mov	r4, r0
   28c24:	460e      	mov	r6, r1
   28c26:	4615      	mov	r5, r2
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
   28c28:	b163      	cbz	r3, 28c44 <z_add_timeout+0x28>
   28c2a:	4943      	ldr	r1, [pc, #268]	; (28d38 <z_add_timeout+0x11c>)
   28c2c:	2358      	movs	r3, #88	; 0x58
   28c2e:	4a43      	ldr	r2, [pc, #268]	; (28d3c <z_add_timeout+0x120>)
   28c30:	4843      	ldr	r0, [pc, #268]	; (28d40 <z_add_timeout+0x124>)
   28c32:	f004 fb0a 	bl	2d24a <printk>
   28c36:	4843      	ldr	r0, [pc, #268]	; (28d44 <z_add_timeout+0x128>)
   28c38:	f004 fb07 	bl	2d24a <printk>
   28c3c:	2158      	movs	r1, #88	; 0x58
   28c3e:	483f      	ldr	r0, [pc, #252]	; (28d3c <z_add_timeout+0x120>)
   28c40:	f004 fb49 	bl	2d2d6 <assert_post_action>
	to->fn = fn;
	ticks = MAX(1, ticks);
   28c44:	2d01      	cmp	r5, #1
   28c46:	bfb8      	it	lt
   28c48:	2501      	movlt	r5, #1
	to->fn = fn;
   28c4a:	60e6      	str	r6, [r4, #12]
	__asm__ volatile(
   28c4c:	f04f 0320 	mov.w	r3, #32
   28c50:	f3ef 8811 	mrs	r8, BASEPRI
   28c54:	f383 8811 	msr	BASEPRI, r3
   28c58:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28c5c:	483a      	ldr	r0, [pc, #232]	; (28d48 <z_add_timeout+0x12c>)
   28c5e:	f7ff fd43 	bl	286e8 <z_spin_lock_valid>
   28c62:	b968      	cbnz	r0, 28c80 <z_add_timeout+0x64>
   28c64:	234a      	movs	r3, #74	; 0x4a
   28c66:	4a39      	ldr	r2, [pc, #228]	; (28d4c <z_add_timeout+0x130>)
   28c68:	4939      	ldr	r1, [pc, #228]	; (28d50 <z_add_timeout+0x134>)
   28c6a:	4835      	ldr	r0, [pc, #212]	; (28d40 <z_add_timeout+0x124>)
   28c6c:	f004 faed 	bl	2d24a <printk>
   28c70:	4935      	ldr	r1, [pc, #212]	; (28d48 <z_add_timeout+0x12c>)
   28c72:	4838      	ldr	r0, [pc, #224]	; (28d54 <z_add_timeout+0x138>)
   28c74:	f004 fae9 	bl	2d24a <printk>
   28c78:	214a      	movs	r1, #74	; 0x4a
   28c7a:	4834      	ldr	r0, [pc, #208]	; (28d4c <z_add_timeout+0x130>)
   28c7c:	f004 fb2b 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   28c80:	4831      	ldr	r0, [pc, #196]	; (28d48 <z_add_timeout+0x12c>)
   28c82:	f7ff fd4f 	bl	28724 <z_spin_lock_set_owner>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
   28c86:	f7ff ff8f 	bl	28ba8 <elapsed>
   28c8a:	4428      	add	r0, r5
	return list->head == list;
   28c8c:	4d32      	ldr	r5, [pc, #200]	; (28d58 <z_add_timeout+0x13c>)
   28c8e:	60a0      	str	r0, [r4, #8]
   28c90:	682e      	ldr	r6, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   28c92:	42ae      	cmp	r6, r5
   28c94:	d005      	beq.n	28ca2 <z_add_timeout+0x86>
		for (t = first(); t != NULL; t = next(t)) {
			__ASSERT(t->dticks >= 0, "");
   28c96:	4f29      	ldr	r7, [pc, #164]	; (28d3c <z_add_timeout+0x120>)
   28c98:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 28d64 <z_add_timeout+0x148>
   28c9c:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 28d40 <z_add_timeout+0x124>
		for (t = first(); t != NULL; t = next(t)) {
   28ca0:	b936      	cbnz	r6, 28cb0 <z_add_timeout+0x94>
	node->prev = list->tail;
   28ca2:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   28ca4:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
   28ca6:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   28ca8:	686b      	ldr	r3, [r5, #4]
   28caa:	601c      	str	r4, [r3, #0]
	list->tail = node;
   28cac:	606c      	str	r4, [r5, #4]
   28cae:	e01a      	b.n	28ce6 <z_add_timeout+0xca>
			__ASSERT(t->dticks >= 0, "");
   28cb0:	68b3      	ldr	r3, [r6, #8]
   28cb2:	2b00      	cmp	r3, #0
   28cb4:	da0c      	bge.n	28cd0 <z_add_timeout+0xb4>
   28cb6:	4649      	mov	r1, r9
   28cb8:	2361      	movs	r3, #97	; 0x61
   28cba:	463a      	mov	r2, r7
   28cbc:	4650      	mov	r0, sl
   28cbe:	f004 fac4 	bl	2d24a <printk>
   28cc2:	4820      	ldr	r0, [pc, #128]	; (28d44 <z_add_timeout+0x128>)
   28cc4:	f004 fac1 	bl	2d24a <printk>
   28cc8:	2161      	movs	r1, #97	; 0x61
   28cca:	4638      	mov	r0, r7
   28ccc:	f004 fb03 	bl	2d2d6 <assert_post_action>

			if (t->dticks > to->dticks) {
   28cd0:	68b2      	ldr	r2, [r6, #8]
   28cd2:	68a3      	ldr	r3, [r4, #8]
   28cd4:	429a      	cmp	r2, r3
   28cd6:	dd28      	ble.n	28d2a <z_add_timeout+0x10e>
				t->dticks -= to->dticks;
   28cd8:	1ad3      	subs	r3, r2, r3
   28cda:	60b3      	str	r3, [r6, #8]
	node->prev = successor->prev;
   28cdc:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   28cde:	e9c4 6300 	strd	r6, r3, [r4]
	successor->prev->next = node;
   28ce2:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   28ce4:	6074      	str	r4, [r6, #4]
	return list->head == list;
   28ce6:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   28ce8:	42ab      	cmp	r3, r5
   28cea:	d006      	beq.n	28cfa <z_add_timeout+0xde>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   28cec:	429c      	cmp	r4, r3
   28cee:	d104      	bne.n	28cfa <z_add_timeout+0xde>
			z_clock_set_timeout(next_timeout(), false);
   28cf0:	f7ff ff78 	bl	28be4 <next_timeout>
   28cf4:	2100      	movs	r1, #0
   28cf6:	f7ef feff 	bl	18af8 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28cfa:	4813      	ldr	r0, [pc, #76]	; (28d48 <z_add_timeout+0x12c>)
   28cfc:	f7ff fd02 	bl	28704 <z_spin_unlock_valid>
   28d00:	b968      	cbnz	r0, 28d1e <z_add_timeout+0x102>
   28d02:	235d      	movs	r3, #93	; 0x5d
   28d04:	4a11      	ldr	r2, [pc, #68]	; (28d4c <z_add_timeout+0x130>)
   28d06:	4915      	ldr	r1, [pc, #84]	; (28d5c <z_add_timeout+0x140>)
   28d08:	480d      	ldr	r0, [pc, #52]	; (28d40 <z_add_timeout+0x124>)
   28d0a:	f004 fa9e 	bl	2d24a <printk>
   28d0e:	490e      	ldr	r1, [pc, #56]	; (28d48 <z_add_timeout+0x12c>)
   28d10:	4813      	ldr	r0, [pc, #76]	; (28d60 <z_add_timeout+0x144>)
   28d12:	f004 fa9a 	bl	2d24a <printk>
   28d16:	215d      	movs	r1, #93	; 0x5d
   28d18:	480c      	ldr	r0, [pc, #48]	; (28d4c <z_add_timeout+0x130>)
   28d1a:	f004 fadc 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   28d1e:	f388 8811 	msr	BASEPRI, r8
   28d22:	f3bf 8f6f 	isb	sy
		}
	}
}
   28d26:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			to->dticks -= t->dticks;
   28d2a:	1a9b      	subs	r3, r3, r2
   28d2c:	60a3      	str	r3, [r4, #8]
	return (node == list->tail) ? NULL : node->next;
   28d2e:	686b      	ldr	r3, [r5, #4]
   28d30:	429e      	cmp	r6, r3
   28d32:	d0b6      	beq.n	28ca2 <z_add_timeout+0x86>
   28d34:	6836      	ldr	r6, [r6, #0]
   28d36:	e7b3      	b.n	28ca0 <z_add_timeout+0x84>
   28d38:	00034b31 	.word	0x00034b31
   28d3c:	00034b0d 	.word	0x00034b0d
   28d40:	000311a3 	.word	0x000311a3
   28d44:	00033242 	.word	0x00033242
   28d48:	2002d400 	.word	0x2002d400
   28d4c:	00031168 	.word	0x00031168
   28d50:	0003118e 	.word	0x0003118e
   28d54:	000311c0 	.word	0x000311c0
   28d58:	200383cc 	.word	0x200383cc
   28d5c:	00031202 	.word	0x00031202
   28d60:	00031219 	.word	0x00031219
   28d64:	00034b51 	.word	0x00034b51

00028d68 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
   28d68:	b538      	push	{r3, r4, r5, lr}
   28d6a:	4604      	mov	r4, r0
	__asm__ volatile(
   28d6c:	f04f 0320 	mov.w	r3, #32
   28d70:	f3ef 8511 	mrs	r5, BASEPRI
   28d74:	f383 8811 	msr	BASEPRI, r3
   28d78:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28d7c:	481a      	ldr	r0, [pc, #104]	; (28de8 <z_abort_timeout+0x80>)
   28d7e:	f7ff fcb3 	bl	286e8 <z_spin_lock_valid>
   28d82:	b968      	cbnz	r0, 28da0 <z_abort_timeout+0x38>
   28d84:	234a      	movs	r3, #74	; 0x4a
   28d86:	4a19      	ldr	r2, [pc, #100]	; (28dec <z_abort_timeout+0x84>)
   28d88:	4919      	ldr	r1, [pc, #100]	; (28df0 <z_abort_timeout+0x88>)
   28d8a:	481a      	ldr	r0, [pc, #104]	; (28df4 <z_abort_timeout+0x8c>)
   28d8c:	f004 fa5d 	bl	2d24a <printk>
   28d90:	4915      	ldr	r1, [pc, #84]	; (28de8 <z_abort_timeout+0x80>)
   28d92:	4819      	ldr	r0, [pc, #100]	; (28df8 <z_abort_timeout+0x90>)
   28d94:	f004 fa59 	bl	2d24a <printk>
   28d98:	214a      	movs	r1, #74	; 0x4a
   28d9a:	4814      	ldr	r0, [pc, #80]	; (28dec <z_abort_timeout+0x84>)
   28d9c:	f004 fa9b 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   28da0:	4811      	ldr	r0, [pc, #68]	; (28de8 <z_abort_timeout+0x80>)
   28da2:	f7ff fcbf 	bl	28724 <z_spin_lock_set_owner>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
   28da6:	6823      	ldr	r3, [r4, #0]
   28da8:	b1db      	cbz	r3, 28de2 <z_abort_timeout+0x7a>
			remove_timeout(to);
   28daa:	4620      	mov	r0, r4
   28dac:	f7ff ff06 	bl	28bbc <remove_timeout>
			ret = 0;
   28db0:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28db2:	480d      	ldr	r0, [pc, #52]	; (28de8 <z_abort_timeout+0x80>)
   28db4:	f7ff fca6 	bl	28704 <z_spin_unlock_valid>
   28db8:	b968      	cbnz	r0, 28dd6 <z_abort_timeout+0x6e>
   28dba:	235d      	movs	r3, #93	; 0x5d
   28dbc:	4a0b      	ldr	r2, [pc, #44]	; (28dec <z_abort_timeout+0x84>)
   28dbe:	490f      	ldr	r1, [pc, #60]	; (28dfc <z_abort_timeout+0x94>)
   28dc0:	480c      	ldr	r0, [pc, #48]	; (28df4 <z_abort_timeout+0x8c>)
   28dc2:	f004 fa42 	bl	2d24a <printk>
   28dc6:	4908      	ldr	r1, [pc, #32]	; (28de8 <z_abort_timeout+0x80>)
   28dc8:	480d      	ldr	r0, [pc, #52]	; (28e00 <z_abort_timeout+0x98>)
   28dca:	f004 fa3e 	bl	2d24a <printk>
   28dce:	215d      	movs	r1, #93	; 0x5d
   28dd0:	4806      	ldr	r0, [pc, #24]	; (28dec <z_abort_timeout+0x84>)
   28dd2:	f004 fa80 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   28dd6:	f385 8811 	msr	BASEPRI, r5
   28dda:	f3bf 8f6f 	isb	sy
		}
	}

	return ret;
}
   28dde:	4620      	mov	r0, r4
   28de0:	bd38      	pop	{r3, r4, r5, pc}
	int ret = -EINVAL;
   28de2:	f06f 0415 	mvn.w	r4, #21
   28de6:	e7e4      	b.n	28db2 <z_abort_timeout+0x4a>
   28de8:	2002d400 	.word	0x2002d400
   28dec:	00031168 	.word	0x00031168
   28df0:	0003118e 	.word	0x0003118e
   28df4:	000311a3 	.word	0x000311a3
   28df8:	000311c0 	.word	0x000311c0
   28dfc:	00031202 	.word	0x00031202
   28e00:	00031219 	.word	0x00031219

00028e04 <z_timeout_remaining>:

s32_t z_timeout_remaining(struct _timeout *timeout)
{
   28e04:	b570      	push	{r4, r5, r6, lr}
   28e06:	4605      	mov	r5, r0
	s32_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
   28e08:	6800      	ldr	r0, [r0, #0]
   28e0a:	2800      	cmp	r0, #0
   28e0c:	d03c      	beq.n	28e88 <z_timeout_remaining+0x84>
	__asm__ volatile(
   28e0e:	f04f 0320 	mov.w	r3, #32
   28e12:	f3ef 8611 	mrs	r6, BASEPRI
   28e16:	f383 8811 	msr	BASEPRI, r3
   28e1a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28e1e:	4821      	ldr	r0, [pc, #132]	; (28ea4 <z_timeout_remaining+0xa0>)
   28e20:	f7ff fc62 	bl	286e8 <z_spin_lock_valid>
   28e24:	b968      	cbnz	r0, 28e42 <z_timeout_remaining+0x3e>
   28e26:	234a      	movs	r3, #74	; 0x4a
   28e28:	4a1f      	ldr	r2, [pc, #124]	; (28ea8 <z_timeout_remaining+0xa4>)
   28e2a:	4920      	ldr	r1, [pc, #128]	; (28eac <z_timeout_remaining+0xa8>)
   28e2c:	4820      	ldr	r0, [pc, #128]	; (28eb0 <z_timeout_remaining+0xac>)
   28e2e:	f004 fa0c 	bl	2d24a <printk>
   28e32:	491c      	ldr	r1, [pc, #112]	; (28ea4 <z_timeout_remaining+0xa0>)
   28e34:	481f      	ldr	r0, [pc, #124]	; (28eb4 <z_timeout_remaining+0xb0>)
   28e36:	f004 fa08 	bl	2d24a <printk>
   28e3a:	214a      	movs	r1, #74	; 0x4a
   28e3c:	481a      	ldr	r0, [pc, #104]	; (28ea8 <z_timeout_remaining+0xa4>)
   28e3e:	f004 fa4a 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   28e42:	4818      	ldr	r0, [pc, #96]	; (28ea4 <z_timeout_remaining+0xa0>)
   28e44:	f7ff fc6e 	bl	28724 <z_spin_lock_set_owner>
	return list->head == list;
   28e48:	4a1b      	ldr	r2, [pc, #108]	; (28eb8 <z_timeout_remaining+0xb4>)
   28e4a:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   28e4c:	4293      	cmp	r3, r2
   28e4e:	d026      	beq.n	28e9e <z_timeout_remaining+0x9a>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   28e50:	2400      	movs	r4, #0
   28e52:	6852      	ldr	r2, [r2, #4]
		return 0;
	}

	LOCKED(&timeout_lock) {
		for (struct _timeout *t = first(); t != NULL; t = next(t)) {
   28e54:	b9cb      	cbnz	r3, 28e8a <z_timeout_remaining+0x86>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28e56:	4813      	ldr	r0, [pc, #76]	; (28ea4 <z_timeout_remaining+0xa0>)
   28e58:	f7ff fc54 	bl	28704 <z_spin_unlock_valid>
   28e5c:	b968      	cbnz	r0, 28e7a <z_timeout_remaining+0x76>
   28e5e:	235d      	movs	r3, #93	; 0x5d
   28e60:	4a11      	ldr	r2, [pc, #68]	; (28ea8 <z_timeout_remaining+0xa4>)
   28e62:	4916      	ldr	r1, [pc, #88]	; (28ebc <z_timeout_remaining+0xb8>)
   28e64:	4812      	ldr	r0, [pc, #72]	; (28eb0 <z_timeout_remaining+0xac>)
   28e66:	f004 f9f0 	bl	2d24a <printk>
   28e6a:	490e      	ldr	r1, [pc, #56]	; (28ea4 <z_timeout_remaining+0xa0>)
   28e6c:	4814      	ldr	r0, [pc, #80]	; (28ec0 <z_timeout_remaining+0xbc>)
   28e6e:	f004 f9ec 	bl	2d24a <printk>
   28e72:	215d      	movs	r1, #93	; 0x5d
   28e74:	480c      	ldr	r0, [pc, #48]	; (28ea8 <z_timeout_remaining+0xa4>)
   28e76:	f004 fa2e 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   28e7a:	f386 8811 	msr	BASEPRI, r6
   28e7e:	f3bf 8f6f 	isb	sy
				break;
			}
		}
	}

	return ticks - elapsed();
   28e82:	f7ff fe91 	bl	28ba8 <elapsed>
   28e86:	1a20      	subs	r0, r4, r0
}
   28e88:	bd70      	pop	{r4, r5, r6, pc}
			ticks += t->dticks;
   28e8a:	6899      	ldr	r1, [r3, #8]
			if (timeout == t) {
   28e8c:	42ab      	cmp	r3, r5
			ticks += t->dticks;
   28e8e:	440c      	add	r4, r1
			if (timeout == t) {
   28e90:	d0e1      	beq.n	28e56 <z_timeout_remaining+0x52>
   28e92:	2b00      	cmp	r3, #0
   28e94:	d0df      	beq.n	28e56 <z_timeout_remaining+0x52>
	return (node == list->tail) ? NULL : node->next;
   28e96:	4293      	cmp	r3, r2
   28e98:	d0dd      	beq.n	28e56 <z_timeout_remaining+0x52>
   28e9a:	681b      	ldr	r3, [r3, #0]
   28e9c:	e7da      	b.n	28e54 <z_timeout_remaining+0x50>
	return sys_dlist_is_empty(list) ? NULL : list->head;
   28e9e:	2400      	movs	r4, #0
   28ea0:	e7d9      	b.n	28e56 <z_timeout_remaining+0x52>
   28ea2:	bf00      	nop
   28ea4:	2002d400 	.word	0x2002d400
   28ea8:	00031168 	.word	0x00031168
   28eac:	0003118e 	.word	0x0003118e
   28eb0:	000311a3 	.word	0x000311a3
   28eb4:	000311c0 	.word	0x000311c0
   28eb8:	200383cc 	.word	0x200383cc
   28ebc:	00031202 	.word	0x00031202
   28ec0:	00031219 	.word	0x00031219

00028ec4 <z_get_next_timeout_expiry>:

s32_t z_get_next_timeout_expiry(void)
{
   28ec4:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   28ec6:	f04f 0320 	mov.w	r3, #32
   28eca:	f3ef 8511 	mrs	r5, BASEPRI
   28ece:	f383 8811 	msr	BASEPRI, r3
   28ed2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28ed6:	4818      	ldr	r0, [pc, #96]	; (28f38 <z_get_next_timeout_expiry+0x74>)
   28ed8:	f7ff fc06 	bl	286e8 <z_spin_lock_valid>
   28edc:	b968      	cbnz	r0, 28efa <z_get_next_timeout_expiry+0x36>
   28ede:	234a      	movs	r3, #74	; 0x4a
   28ee0:	4a16      	ldr	r2, [pc, #88]	; (28f3c <z_get_next_timeout_expiry+0x78>)
   28ee2:	4917      	ldr	r1, [pc, #92]	; (28f40 <z_get_next_timeout_expiry+0x7c>)
   28ee4:	4817      	ldr	r0, [pc, #92]	; (28f44 <z_get_next_timeout_expiry+0x80>)
   28ee6:	f004 f9b0 	bl	2d24a <printk>
   28eea:	4913      	ldr	r1, [pc, #76]	; (28f38 <z_get_next_timeout_expiry+0x74>)
   28eec:	4816      	ldr	r0, [pc, #88]	; (28f48 <z_get_next_timeout_expiry+0x84>)
   28eee:	f004 f9ac 	bl	2d24a <printk>
   28ef2:	214a      	movs	r1, #74	; 0x4a
   28ef4:	4811      	ldr	r0, [pc, #68]	; (28f3c <z_get_next_timeout_expiry+0x78>)
   28ef6:	f004 f9ee 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   28efa:	480f      	ldr	r0, [pc, #60]	; (28f38 <z_get_next_timeout_expiry+0x74>)
   28efc:	f7ff fc12 	bl	28724 <z_spin_lock_set_owner>
	s32_t ret = K_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
   28f00:	f7ff fe70 	bl	28be4 <next_timeout>
   28f04:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28f06:	480c      	ldr	r0, [pc, #48]	; (28f38 <z_get_next_timeout_expiry+0x74>)
   28f08:	f7ff fbfc 	bl	28704 <z_spin_unlock_valid>
   28f0c:	b968      	cbnz	r0, 28f2a <z_get_next_timeout_expiry+0x66>
   28f0e:	235d      	movs	r3, #93	; 0x5d
   28f10:	4a0a      	ldr	r2, [pc, #40]	; (28f3c <z_get_next_timeout_expiry+0x78>)
   28f12:	490e      	ldr	r1, [pc, #56]	; (28f4c <z_get_next_timeout_expiry+0x88>)
   28f14:	480b      	ldr	r0, [pc, #44]	; (28f44 <z_get_next_timeout_expiry+0x80>)
   28f16:	f004 f998 	bl	2d24a <printk>
   28f1a:	4907      	ldr	r1, [pc, #28]	; (28f38 <z_get_next_timeout_expiry+0x74>)
   28f1c:	480c      	ldr	r0, [pc, #48]	; (28f50 <z_get_next_timeout_expiry+0x8c>)
   28f1e:	f004 f994 	bl	2d24a <printk>
   28f22:	215d      	movs	r1, #93	; 0x5d
   28f24:	4805      	ldr	r0, [pc, #20]	; (28f3c <z_get_next_timeout_expiry+0x78>)
   28f26:	f004 f9d6 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   28f2a:	f385 8811 	msr	BASEPRI, r5
   28f2e:	f3bf 8f6f 	isb	sy
	}
	return ret;
}
   28f32:	4620      	mov	r0, r4
   28f34:	bd38      	pop	{r3, r4, r5, pc}
   28f36:	bf00      	nop
   28f38:	2002d400 	.word	0x2002d400
   28f3c:	00031168 	.word	0x00031168
   28f40:	0003118e 	.word	0x0003118e
   28f44:	000311a3 	.word	0x000311a3
   28f48:	000311c0 	.word	0x000311c0
   28f4c:	00031202 	.word	0x00031202
   28f50:	00031219 	.word	0x00031219

00028f54 <z_set_timeout_expiry>:

void z_set_timeout_expiry(s32_t ticks, bool idle)
{
   28f54:	b570      	push	{r4, r5, r6, lr}
   28f56:	4604      	mov	r4, r0
   28f58:	460e      	mov	r6, r1
	__asm__ volatile(
   28f5a:	f04f 0320 	mov.w	r3, #32
   28f5e:	f3ef 8511 	mrs	r5, BASEPRI
   28f62:	f383 8811 	msr	BASEPRI, r3
   28f66:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   28f6a:	481b      	ldr	r0, [pc, #108]	; (28fd8 <z_set_timeout_expiry+0x84>)
   28f6c:	f7ff fbbc 	bl	286e8 <z_spin_lock_valid>
   28f70:	b968      	cbnz	r0, 28f8e <z_set_timeout_expiry+0x3a>
   28f72:	234a      	movs	r3, #74	; 0x4a
   28f74:	4a19      	ldr	r2, [pc, #100]	; (28fdc <z_set_timeout_expiry+0x88>)
   28f76:	491a      	ldr	r1, [pc, #104]	; (28fe0 <z_set_timeout_expiry+0x8c>)
   28f78:	481a      	ldr	r0, [pc, #104]	; (28fe4 <z_set_timeout_expiry+0x90>)
   28f7a:	f004 f966 	bl	2d24a <printk>
   28f7e:	4916      	ldr	r1, [pc, #88]	; (28fd8 <z_set_timeout_expiry+0x84>)
   28f80:	4819      	ldr	r0, [pc, #100]	; (28fe8 <z_set_timeout_expiry+0x94>)
   28f82:	f004 f962 	bl	2d24a <printk>
   28f86:	214a      	movs	r1, #74	; 0x4a
   28f88:	4814      	ldr	r0, [pc, #80]	; (28fdc <z_set_timeout_expiry+0x88>)
   28f8a:	f004 f9a4 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   28f8e:	4812      	ldr	r0, [pc, #72]	; (28fd8 <z_set_timeout_expiry+0x84>)
   28f90:	f7ff fbc8 	bl	28724 <z_spin_lock_set_owner>
	LOCKED(&timeout_lock) {
		int next = next_timeout();
   28f94:	f7ff fe26 	bl	28be4 <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   28f98:	2801      	cmp	r0, #1
   28f9a:	dd05      	ble.n	28fa8 <z_set_timeout_expiry+0x54>
   28f9c:	42a0      	cmp	r0, r4
   28f9e:	dd03      	ble.n	28fa8 <z_set_timeout_expiry+0x54>
			z_clock_set_timeout(ticks, idle);
   28fa0:	4631      	mov	r1, r6
   28fa2:	4620      	mov	r0, r4
   28fa4:	f7ef fda8 	bl	18af8 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   28fa8:	480b      	ldr	r0, [pc, #44]	; (28fd8 <z_set_timeout_expiry+0x84>)
   28faa:	f7ff fbab 	bl	28704 <z_spin_unlock_valid>
   28fae:	b968      	cbnz	r0, 28fcc <z_set_timeout_expiry+0x78>
   28fb0:	235d      	movs	r3, #93	; 0x5d
   28fb2:	4a0a      	ldr	r2, [pc, #40]	; (28fdc <z_set_timeout_expiry+0x88>)
   28fb4:	490d      	ldr	r1, [pc, #52]	; (28fec <z_set_timeout_expiry+0x98>)
   28fb6:	480b      	ldr	r0, [pc, #44]	; (28fe4 <z_set_timeout_expiry+0x90>)
   28fb8:	f004 f947 	bl	2d24a <printk>
   28fbc:	4906      	ldr	r1, [pc, #24]	; (28fd8 <z_set_timeout_expiry+0x84>)
   28fbe:	480c      	ldr	r0, [pc, #48]	; (28ff0 <z_set_timeout_expiry+0x9c>)
   28fc0:	f004 f943 	bl	2d24a <printk>
   28fc4:	215d      	movs	r1, #93	; 0x5d
   28fc6:	4805      	ldr	r0, [pc, #20]	; (28fdc <z_set_timeout_expiry+0x88>)
   28fc8:	f004 f985 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   28fcc:	f385 8811 	msr	BASEPRI, r5
   28fd0:	f3bf 8f6f 	isb	sy
		}
	}
}
   28fd4:	bd70      	pop	{r4, r5, r6, pc}
   28fd6:	bf00      	nop
   28fd8:	2002d400 	.word	0x2002d400
   28fdc:	00031168 	.word	0x00031168
   28fe0:	0003118e 	.word	0x0003118e
   28fe4:	000311a3 	.word	0x000311a3
   28fe8:	000311c0 	.word	0x000311c0
   28fec:	00031202 	.word	0x00031202
   28ff0:	00031219 	.word	0x00031219

00028ff4 <z_clock_announce>:

void z_clock_announce(s32_t ticks)
{
   28ff4:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
   28ff8:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   28ffa:	f7fe fd59 	bl	27ab0 <z_time_slice>
	__asm__ volatile(
   28ffe:	f04f 0320 	mov.w	r3, #32
   29002:	f3ef 8511 	mrs	r5, BASEPRI
   29006:	f383 8811 	msr	BASEPRI, r3
   2900a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2900e:	4848      	ldr	r0, [pc, #288]	; (29130 <z_clock_announce+0x13c>)
   29010:	f7ff fb6a 	bl	286e8 <z_spin_lock_valid>
   29014:	b968      	cbnz	r0, 29032 <z_clock_announce+0x3e>
   29016:	234a      	movs	r3, #74	; 0x4a
   29018:	4a46      	ldr	r2, [pc, #280]	; (29134 <z_clock_announce+0x140>)
   2901a:	4947      	ldr	r1, [pc, #284]	; (29138 <z_clock_announce+0x144>)
   2901c:	4847      	ldr	r0, [pc, #284]	; (2913c <z_clock_announce+0x148>)
   2901e:	f004 f914 	bl	2d24a <printk>
   29022:	4943      	ldr	r1, [pc, #268]	; (29130 <z_clock_announce+0x13c>)
   29024:	4846      	ldr	r0, [pc, #280]	; (29140 <z_clock_announce+0x14c>)
   29026:	f004 f910 	bl	2d24a <printk>
   2902a:	214a      	movs	r1, #74	; 0x4a
   2902c:	4841      	ldr	r0, [pc, #260]	; (29134 <z_clock_announce+0x140>)
   2902e:	f004 f952 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   29032:	4f44      	ldr	r7, [pc, #272]	; (29144 <z_clock_announce+0x150>)
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   29034:	4e44      	ldr	r6, [pc, #272]	; (29148 <z_clock_announce+0x154>)
   29036:	46b9      	mov	r9, r7
   29038:	483d      	ldr	r0, [pc, #244]	; (29130 <z_clock_announce+0x13c>)
	return list->head == list;
   2903a:	f8df 8118 	ldr.w	r8, [pc, #280]	; 29154 <z_clock_announce+0x160>
   2903e:	f7ff fb71 	bl	28724 <z_spin_lock_set_owner>
   29042:	6034      	str	r4, [r6, #0]
   29044:	f8d8 4000 	ldr.w	r4, [r8]
   29048:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2904a:	4544      	cmp	r4, r8
   2904c:	e9d7 bc00 	ldrd	fp, ip, [r7]
   29050:	d005      	beq.n	2905e <z_clock_announce+0x6a>

	while (first() != NULL && first()->dticks <= announce_remaining) {
   29052:	b124      	cbz	r4, 2905e <z_clock_announce+0x6a>
   29054:	68a3      	ldr	r3, [r4, #8]
   29056:	4293      	cmp	r3, r2
   29058:	dd26      	ble.n	290a8 <z_clock_announce+0xb4>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   2905a:	1a9b      	subs	r3, r3, r2
   2905c:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
   2905e:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
   29060:	eb1b 0002 	adds.w	r0, fp, r2
   29064:	eb4c 71e2 	adc.w	r1, ip, r2, asr #31
   29068:	e9c9 0100 	strd	r0, r1, [r9]
	announce_remaining = 0;
   2906c:	6034      	str	r4, [r6, #0]

	z_clock_set_timeout(next_timeout(), false);
   2906e:	f7ff fdb9 	bl	28be4 <next_timeout>
   29072:	4621      	mov	r1, r4
   29074:	f7ef fd40 	bl	18af8 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   29078:	482d      	ldr	r0, [pc, #180]	; (29130 <z_clock_announce+0x13c>)
   2907a:	f7ff fb43 	bl	28704 <z_spin_unlock_valid>
   2907e:	b968      	cbnz	r0, 2909c <z_clock_announce+0xa8>
   29080:	235d      	movs	r3, #93	; 0x5d
   29082:	4a2c      	ldr	r2, [pc, #176]	; (29134 <z_clock_announce+0x140>)
   29084:	4931      	ldr	r1, [pc, #196]	; (2914c <z_clock_announce+0x158>)
   29086:	482d      	ldr	r0, [pc, #180]	; (2913c <z_clock_announce+0x148>)
   29088:	f004 f8df 	bl	2d24a <printk>
   2908c:	4928      	ldr	r1, [pc, #160]	; (29130 <z_clock_announce+0x13c>)
   2908e:	4830      	ldr	r0, [pc, #192]	; (29150 <z_clock_announce+0x15c>)
   29090:	f004 f8db 	bl	2d24a <printk>
   29094:	215d      	movs	r1, #93	; 0x5d
   29096:	4827      	ldr	r0, [pc, #156]	; (29134 <z_clock_announce+0x140>)
   29098:	f004 f91d 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   2909c:	f385 8811 	msr	BASEPRI, r5
   290a0:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   290a4:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		curr_tick += dt;
   290a8:	eb1b 0003 	adds.w	r0, fp, r3
   290ac:	eb4c 71e3 	adc.w	r1, ip, r3, asr #31
		announce_remaining -= dt;
   290b0:	1ad3      	subs	r3, r2, r3
   290b2:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
   290b4:	2300      	movs	r3, #0
		curr_tick += dt;
   290b6:	e9c7 0100 	strd	r0, r1, [r7]
		t->dticks = 0;
   290ba:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
   290bc:	4620      	mov	r0, r4
   290be:	f7ff fd7d 	bl	28bbc <remove_timeout>
   290c2:	481b      	ldr	r0, [pc, #108]	; (29130 <z_clock_announce+0x13c>)
   290c4:	f7ff fb1e 	bl	28704 <z_spin_unlock_valid>
   290c8:	b968      	cbnz	r0, 290e6 <z_clock_announce+0xf2>
   290ca:	235d      	movs	r3, #93	; 0x5d
   290cc:	4a19      	ldr	r2, [pc, #100]	; (29134 <z_clock_announce+0x140>)
   290ce:	491f      	ldr	r1, [pc, #124]	; (2914c <z_clock_announce+0x158>)
   290d0:	481a      	ldr	r0, [pc, #104]	; (2913c <z_clock_announce+0x148>)
   290d2:	f004 f8ba 	bl	2d24a <printk>
   290d6:	4916      	ldr	r1, [pc, #88]	; (29130 <z_clock_announce+0x13c>)
   290d8:	481d      	ldr	r0, [pc, #116]	; (29150 <z_clock_announce+0x15c>)
   290da:	f004 f8b6 	bl	2d24a <printk>
   290de:	215d      	movs	r1, #93	; 0x5d
   290e0:	4814      	ldr	r0, [pc, #80]	; (29134 <z_clock_announce+0x140>)
   290e2:	f004 f8f8 	bl	2d2d6 <assert_post_action>
   290e6:	f385 8811 	msr	BASEPRI, r5
   290ea:	f3bf 8f6f 	isb	sy
		t->fn(t);
   290ee:	68e3      	ldr	r3, [r4, #12]
   290f0:	4620      	mov	r0, r4
   290f2:	4798      	blx	r3
	__asm__ volatile(
   290f4:	f04f 0320 	mov.w	r3, #32
   290f8:	f3ef 8511 	mrs	r5, BASEPRI
   290fc:	f383 8811 	msr	BASEPRI, r3
   29100:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   29104:	480a      	ldr	r0, [pc, #40]	; (29130 <z_clock_announce+0x13c>)
   29106:	f7ff faef 	bl	286e8 <z_spin_lock_valid>
   2910a:	b968      	cbnz	r0, 29128 <z_clock_announce+0x134>
   2910c:	234a      	movs	r3, #74	; 0x4a
   2910e:	4a09      	ldr	r2, [pc, #36]	; (29134 <z_clock_announce+0x140>)
   29110:	4909      	ldr	r1, [pc, #36]	; (29138 <z_clock_announce+0x144>)
   29112:	480a      	ldr	r0, [pc, #40]	; (2913c <z_clock_announce+0x148>)
   29114:	f004 f899 	bl	2d24a <printk>
   29118:	4905      	ldr	r1, [pc, #20]	; (29130 <z_clock_announce+0x13c>)
   2911a:	4809      	ldr	r0, [pc, #36]	; (29140 <z_clock_announce+0x14c>)
   2911c:	f004 f895 	bl	2d24a <printk>
   29120:	214a      	movs	r1, #74	; 0x4a
   29122:	4804      	ldr	r0, [pc, #16]	; (29134 <z_clock_announce+0x140>)
   29124:	f004 f8d7 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   29128:	4801      	ldr	r0, [pc, #4]	; (29130 <z_clock_announce+0x13c>)
   2912a:	f7ff fafb 	bl	28724 <z_spin_lock_set_owner>
	return k;
   2912e:	e789      	b.n	29044 <z_clock_announce+0x50>
   29130:	2002d400 	.word	0x2002d400
   29134:	00031168 	.word	0x00031168
   29138:	0003118e 	.word	0x0003118e
   2913c:	000311a3 	.word	0x000311a3
   29140:	000311c0 	.word	0x000311c0
   29144:	20020958 	.word	0x20020958
   29148:	2002d3fc 	.word	0x2002d3fc
   2914c:	00031202 	.word	0x00031202
   29150:	00031219 	.word	0x00031219
   29154:	200383cc 	.word	0x200383cc

00029158 <z_tick_get>:

s64_t z_tick_get(void)
{
   29158:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2915c:	f04f 0320 	mov.w	r3, #32
   29160:	f3ef 8611 	mrs	r6, BASEPRI
   29164:	f383 8811 	msr	BASEPRI, r3
   29168:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2916c:	481b      	ldr	r0, [pc, #108]	; (291dc <z_tick_get+0x84>)
   2916e:	f7ff fabb 	bl	286e8 <z_spin_lock_valid>
   29172:	b968      	cbnz	r0, 29190 <z_tick_get+0x38>
   29174:	234a      	movs	r3, #74	; 0x4a
   29176:	4a1a      	ldr	r2, [pc, #104]	; (291e0 <z_tick_get+0x88>)
   29178:	491a      	ldr	r1, [pc, #104]	; (291e4 <z_tick_get+0x8c>)
   2917a:	481b      	ldr	r0, [pc, #108]	; (291e8 <z_tick_get+0x90>)
   2917c:	f004 f865 	bl	2d24a <printk>
   29180:	4916      	ldr	r1, [pc, #88]	; (291dc <z_tick_get+0x84>)
   29182:	481a      	ldr	r0, [pc, #104]	; (291ec <z_tick_get+0x94>)
   29184:	f004 f861 	bl	2d24a <printk>
   29188:	214a      	movs	r1, #74	; 0x4a
   2918a:	4815      	ldr	r0, [pc, #84]	; (291e0 <z_tick_get+0x88>)
   2918c:	f004 f8a3 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   29190:	4812      	ldr	r0, [pc, #72]	; (291dc <z_tick_get+0x84>)
   29192:	f7ff fac7 	bl	28724 <z_spin_lock_set_owner>
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
   29196:	f7ef fd3d 	bl	18c14 <z_clock_elapsed>
   2919a:	4b15      	ldr	r3, [pc, #84]	; (291f0 <z_tick_get+0x98>)
   2919c:	e9d3 4500 	ldrd	r4, r5, [r3]
   291a0:	1827      	adds	r7, r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   291a2:	480e      	ldr	r0, [pc, #56]	; (291dc <z_tick_get+0x84>)
   291a4:	f145 0800 	adc.w	r8, r5, #0
   291a8:	f7ff faac 	bl	28704 <z_spin_unlock_valid>
   291ac:	b968      	cbnz	r0, 291ca <z_tick_get+0x72>
   291ae:	235d      	movs	r3, #93	; 0x5d
   291b0:	4a0b      	ldr	r2, [pc, #44]	; (291e0 <z_tick_get+0x88>)
   291b2:	4910      	ldr	r1, [pc, #64]	; (291f4 <z_tick_get+0x9c>)
   291b4:	480c      	ldr	r0, [pc, #48]	; (291e8 <z_tick_get+0x90>)
   291b6:	f004 f848 	bl	2d24a <printk>
   291ba:	4908      	ldr	r1, [pc, #32]	; (291dc <z_tick_get+0x84>)
   291bc:	480e      	ldr	r0, [pc, #56]	; (291f8 <z_tick_get+0xa0>)
   291be:	f004 f844 	bl	2d24a <printk>
   291c2:	215d      	movs	r1, #93	; 0x5d
   291c4:	4806      	ldr	r0, [pc, #24]	; (291e0 <z_tick_get+0x88>)
   291c6:	f004 f886 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   291ca:	f386 8811 	msr	BASEPRI, r6
   291ce:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   291d2:	4638      	mov	r0, r7
   291d4:	4641      	mov	r1, r8
   291d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   291da:	bf00      	nop
   291dc:	2002d400 	.word	0x2002d400
   291e0:	00031168 	.word	0x00031168
   291e4:	0003118e 	.word	0x0003118e
   291e8:	000311a3 	.word	0x000311a3
   291ec:	000311c0 	.word	0x000311c0
   291f0:	20020958 	.word	0x20020958
   291f4:	00031202 	.word	0x00031202
   291f8:	00031219 	.word	0x00031219

000291fc <z_timer_expiration_handler>:

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
   291fc:	6a02      	ldr	r2, [r0, #32]
{
   291fe:	b538      	push	{r3, r4, r5, lr}
	if (timer->period > 0) {
   29200:	2a00      	cmp	r2, #0
{
   29202:	4604      	mov	r4, r0
	if (timer->period > 0) {
   29204:	dd02      	ble.n	2920c <z_timer_expiration_handler+0x10>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   29206:	490e      	ldr	r1, [pc, #56]	; (29240 <z_timer_expiration_handler+0x44>)
   29208:	f7ff fd08 	bl	28c1c <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   2920c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2920e:	3301      	adds	r3, #1
   29210:	6263      	str	r3, [r4, #36]	; 0x24

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   29212:	69a3      	ldr	r3, [r4, #24]
   29214:	b10b      	cbz	r3, 2921a <z_timer_expiration_handler+0x1e>
		timer->expiry_fn(timer);
   29216:	4620      	mov	r0, r4
   29218:	4798      	blx	r3
	return list->head == list;
   2921a:	f854 5f10 	ldr.w	r5, [r4, #16]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2921e:	42a5      	cmp	r5, r4
   29220:	d00d      	beq.n	2923e <z_timer_expiration_handler+0x42>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   29222:	b165      	cbz	r5, 2923e <z_timer_expiration_handler+0x42>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
   29224:	4628      	mov	r0, r5
   29226:	f7fe f88f 	bl	27348 <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   2922a:	7b6b      	ldrb	r3, [r5, #13]
   2922c:	06db      	lsls	r3, r3, #27
   2922e:	d104      	bne.n	2923a <z_timer_expiration_handler+0x3e>
	if (z_is_thread_ready(thread)) {
   29230:	69ab      	ldr	r3, [r5, #24]
   29232:	b913      	cbnz	r3, 2923a <z_timer_expiration_handler+0x3e>
		z_add_thread_to_ready_q(thread);
   29234:	4628      	mov	r0, r5
   29236:	f7fe fac3 	bl	277c0 <z_add_thread_to_ready_q>
   2923a:	2300      	movs	r3, #0
   2923c:	66ab      	str	r3, [r5, #104]	; 0x68

	z_ready_thread(thread);

	arch_thread_return_value_set(thread, 0);
}
   2923e:	bd38      	pop	{r3, r4, r5, pc}
   29240:	000291fd 	.word	0x000291fd

00029244 <z_impl_k_timer_start>:
	z_object_init(timer);
}


void z_impl_k_timer_start(struct k_timer *timer, s32_t duration, s32_t period)
{
   29244:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	__ASSERT(duration >= 0 && period >= 0 &&
   29248:	f1b1 0900 	subs.w	r9, r1, #0
{
   2924c:	4604      	mov	r4, r0
   2924e:	4615      	mov	r5, r2
	__ASSERT(duration >= 0 && period >= 0 &&
   29250:	db04      	blt.n	2925c <z_impl_k_timer_start+0x18>
   29252:	2a00      	cmp	r2, #0
   29254:	db02      	blt.n	2925c <z_impl_k_timer_start+0x18>
   29256:	ea59 0302 	orrs.w	r3, r9, r2
   2925a:	d10c      	bne.n	29276 <z_impl_k_timer_start+0x32>
   2925c:	491a      	ldr	r1, [pc, #104]	; (292c8 <z_impl_k_timer_start+0x84>)
   2925e:	236f      	movs	r3, #111	; 0x6f
   29260:	4a1a      	ldr	r2, [pc, #104]	; (292cc <z_impl_k_timer_start+0x88>)
   29262:	481b      	ldr	r0, [pc, #108]	; (292d0 <z_impl_k_timer_start+0x8c>)
   29264:	f003 fff1 	bl	2d24a <printk>
   29268:	481a      	ldr	r0, [pc, #104]	; (292d4 <z_impl_k_timer_start+0x90>)
   2926a:	f003 ffee 	bl	2d24a <printk>
   2926e:	216f      	movs	r1, #111	; 0x6f
   29270:	4816      	ldr	r0, [pc, #88]	; (292cc <z_impl_k_timer_start+0x88>)
   29272:	f004 f830 	bl	2d2d6 <assert_post_action>
   29276:	f240 36e7 	movw	r6, #999	; 0x3e7
   2927a:	2700      	movs	r7, #0
   2927c:	f44f 4800 	mov.w	r8, #32768	; 0x8000
   29280:	4630      	mov	r0, r6
   29282:	4639      	mov	r1, r7
   29284:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   29288:	2300      	movs	r3, #0
   2928a:	fbe8 0105 	umlal	r0, r1, r8, r5
   2928e:	f7e3 fc9d 	bl	cbcc <__aeabi_uldivmod>
   29292:	4639      	mov	r1, r7
		 (duration != 0 || period != 0), "invalid parameters\n");

	volatile s32_t period_in_ticks, duration_in_ticks;

	period_in_ticks = k_ms_to_ticks_ceil32(period);
   29294:	9000      	str	r0, [sp, #0]
   29296:	4630      	mov	r0, r6
   29298:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2929c:	2300      	movs	r3, #0
   2929e:	fbe8 0109 	umlal	r0, r1, r8, r9
   292a2:	f7e3 fc93 	bl	cbcc <__aeabi_uldivmod>
	duration_in_ticks = k_ms_to_ticks_ceil32(duration);
   292a6:	9001      	str	r0, [sp, #4]

	(void)z_abort_timeout(&timer->timeout);
   292a8:	4620      	mov	r0, r4
   292aa:	f7ff fd5d 	bl	28d68 <z_abort_timeout>
	timer->period = period_in_ticks;
   292ae:	9b00      	ldr	r3, [sp, #0]
	timer->status = 0U;
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   292b0:	4620      	mov	r0, r4
	timer->period = period_in_ticks;
   292b2:	6223      	str	r3, [r4, #32]
	timer->status = 0U;
   292b4:	2300      	movs	r3, #0
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   292b6:	9a01      	ldr	r2, [sp, #4]
   292b8:	4907      	ldr	r1, [pc, #28]	; (292d8 <z_impl_k_timer_start+0x94>)
	timer->status = 0U;
   292ba:	6263      	str	r3, [r4, #36]	; 0x24
		     duration_in_ticks);
}
   292bc:	b003      	add	sp, #12
   292be:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   292c2:	f7ff bcab 	b.w	28c1c <z_add_timeout>
   292c6:	bf00      	nop
   292c8:	00034b82 	.word	0x00034b82
   292cc:	00034b60 	.word	0x00034b60
   292d0:	000311a3 	.word	0x000311a3
   292d4:	00034bc1 	.word	0x00034bc1
   292d8:	000291fd 	.word	0x000291fd

000292dc <k_poll_poller_cb>:

	return events_registered;
}

static int k_poll_poller_cb(struct k_poll_event *event, u32_t state)
{
   292dc:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = event->poller->thread;
   292de:	6883      	ldr	r3, [r0, #8]
{
   292e0:	460d      	mov	r5, r1
	struct k_thread *thread = event->poller->thread;
   292e2:	685c      	ldr	r4, [r3, #4]

	__ASSERT(thread != NULL, "poller should have a thread\n");
   292e4:	b964      	cbnz	r4, 29300 <k_poll_poller_cb+0x24>
   292e6:	4915      	ldr	r1, [pc, #84]	; (2933c <k_poll_poller_cb+0x60>)
   292e8:	23e0      	movs	r3, #224	; 0xe0
   292ea:	4a15      	ldr	r2, [pc, #84]	; (29340 <k_poll_poller_cb+0x64>)
   292ec:	4815      	ldr	r0, [pc, #84]	; (29344 <k_poll_poller_cb+0x68>)
   292ee:	f003 ffac 	bl	2d24a <printk>
   292f2:	4815      	ldr	r0, [pc, #84]	; (29348 <k_poll_poller_cb+0x6c>)
   292f4:	f003 ffa9 	bl	2d24a <printk>
   292f8:	21e0      	movs	r1, #224	; 0xe0
   292fa:	4811      	ldr	r0, [pc, #68]	; (29340 <k_poll_poller_cb+0x64>)
   292fc:	f003 ffeb 	bl	2d2d6 <assert_post_action>

	if (!z_is_thread_pending(thread)) {
   29300:	7b63      	ldrb	r3, [r4, #13]
   29302:	079a      	lsls	r2, r3, #30
   29304:	d401      	bmi.n	2930a <k_poll_poller_cb+0x2e>
		return 0;
   29306:	2000      	movs	r0, #0
	}

	z_ready_thread(thread);

	return 0;
}
   29308:	bd38      	pop	{r3, r4, r5, pc}
	if (z_is_thread_timeout_expired(thread)) {
   2930a:	6a23      	ldr	r3, [r4, #32]
   2930c:	3302      	adds	r3, #2
   2930e:	d012      	beq.n	29336 <k_poll_poller_cb+0x5a>
	z_unpend_thread(thread);
   29310:	4620      	mov	r0, r4
   29312:	f7fe f94d 	bl	275b0 <z_unpend_thread>
	arch_thread_return_value_set(thread,
   29316:	2d08      	cmp	r5, #8
   29318:	bf0c      	ite	eq
   2931a:	f06f 0303 	mvneq.w	r3, #3
   2931e:	2300      	movne	r3, #0
   29320:	66a3      	str	r3, [r4, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   29322:	7b63      	ldrb	r3, [r4, #13]
   29324:	06db      	lsls	r3, r3, #27
   29326:	d1ee      	bne.n	29306 <k_poll_poller_cb+0x2a>
	if (!z_is_thread_ready(thread)) {
   29328:	69a5      	ldr	r5, [r4, #24]
   2932a:	2d00      	cmp	r5, #0
   2932c:	d1eb      	bne.n	29306 <k_poll_poller_cb+0x2a>
		z_add_thread_to_ready_q(thread);
   2932e:	4620      	mov	r0, r4
   29330:	f7fe fa46 	bl	277c0 <z_add_thread_to_ready_q>
	return 0;
   29334:	e7e7      	b.n	29306 <k_poll_poller_cb+0x2a>
		return -EAGAIN;
   29336:	f06f 000a 	mvn.w	r0, #10
   2933a:	e7e5      	b.n	29308 <k_poll_poller_cb+0x2c>
   2933c:	00034d45 	.word	0x00034d45
   29340:	00034d24 	.word	0x00034d24
   29344:	000311a3 	.word	0x000311a3
   29348:	00034d5b 	.word	0x00034d5b

0002934c <clear_event_registrations>:
{
   2934c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   29350:	2414      	movs	r4, #20
   29352:	4680      	mov	r8, r0
   29354:	4617      	mov	r7, r2
	while (num_events--) {
   29356:	fb04 0401 	mla	r4, r4, r1, r0
		__ASSERT(false, "invalid event type\n");
   2935a:	4d48      	ldr	r5, [pc, #288]	; (2947c <clear_event_registrations+0x130>)
   2935c:	f8df 9158 	ldr.w	r9, [pc, #344]	; 294b8 <clear_event_registrations+0x16c>
   29360:	4e47      	ldr	r6, [pc, #284]	; (29480 <clear_event_registrations+0x134>)
	while (num_events--) {
   29362:	4544      	cmp	r4, r8
   29364:	d101      	bne.n	2936a <clear_event_registrations+0x1e>
}
   29366:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	event->poller = NULL;
   2936a:	2300      	movs	r3, #0
   2936c:	f844 3c0c 	str.w	r3, [r4, #-12]
	switch (event->type) {
   29370:	f814 3c07 	ldrb.w	r3, [r4, #-7]
   29374:	f003 030f 	and.w	r3, r3, #15
   29378:	2b04      	cmp	r3, #4
   2937a:	d83d      	bhi.n	293f8 <clear_event_registrations+0xac>
   2937c:	e8df f003 	tbb	[pc, r3]
   29380:	3c032d49 	.word	0x3c032d49
   29384:	1e          	.byte	0x1e
   29385:	00          	.byte	0x00
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
   29386:	f854 3c04 	ldr.w	r3, [r4, #-4]
   2938a:	b963      	cbnz	r3, 293a6 <clear_event_registrations+0x5a>
   2938c:	493d      	ldr	r1, [pc, #244]	; (29484 <clear_event_registrations+0x138>)
   2938e:	2396      	movs	r3, #150	; 0x96
   29390:	462a      	mov	r2, r5
   29392:	4630      	mov	r0, r6
   29394:	f003 ff59 	bl	2d24a <printk>
   29398:	483b      	ldr	r0, [pc, #236]	; (29488 <clear_event_registrations+0x13c>)
   2939a:	f003 ff56 	bl	2d24a <printk>
   2939e:	2196      	movs	r1, #150	; 0x96
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   293a0:	4628      	mov	r0, r5
   293a2:	f003 ff98 	bl	2d2d6 <assert_post_action>
	if (remove && sys_dnode_is_linked(&event->_node)) {
   293a6:	f854 3c14 	ldr.w	r3, [r4, #-20]
   293aa:	b393      	cbz	r3, 29412 <clear_event_registrations+0xc6>
	node->prev->next = node->next;
   293ac:	f854 2c10 	ldr.w	r2, [r4, #-16]
   293b0:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   293b2:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   293b4:	2300      	movs	r3, #0
	node->prev = NULL;
   293b6:	e944 3305 	strd	r3, r3, [r4, #-20]
   293ba:	e02a      	b.n	29412 <clear_event_registrations+0xc6>
		__ASSERT(event->queue != NULL, "invalid queue\n");
   293bc:	f854 3c04 	ldr.w	r3, [r4, #-4]
   293c0:	2b00      	cmp	r3, #0
   293c2:	d1f0      	bne.n	293a6 <clear_event_registrations+0x5a>
   293c4:	4931      	ldr	r1, [pc, #196]	; (2948c <clear_event_registrations+0x140>)
   293c6:	239a      	movs	r3, #154	; 0x9a
   293c8:	462a      	mov	r2, r5
   293ca:	4630      	mov	r0, r6
   293cc:	f003 ff3d 	bl	2d24a <printk>
   293d0:	482f      	ldr	r0, [pc, #188]	; (29490 <clear_event_registrations+0x144>)
   293d2:	f003 ff3a 	bl	2d24a <printk>
   293d6:	219a      	movs	r1, #154	; 0x9a
   293d8:	e7e2      	b.n	293a0 <clear_event_registrations+0x54>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   293da:	f854 3c04 	ldr.w	r3, [r4, #-4]
   293de:	2b00      	cmp	r3, #0
   293e0:	d1e1      	bne.n	293a6 <clear_event_registrations+0x5a>
   293e2:	492c      	ldr	r1, [pc, #176]	; (29494 <clear_event_registrations+0x148>)
   293e4:	239e      	movs	r3, #158	; 0x9e
   293e6:	462a      	mov	r2, r5
   293e8:	4630      	mov	r0, r6
   293ea:	f003 ff2e 	bl	2d24a <printk>
   293ee:	482a      	ldr	r0, [pc, #168]	; (29498 <clear_event_registrations+0x14c>)
   293f0:	f003 ff2b 	bl	2d24a <printk>
   293f4:	219e      	movs	r1, #158	; 0x9e
   293f6:	e7d3      	b.n	293a0 <clear_event_registrations+0x54>
		__ASSERT(false, "invalid event type\n");
   293f8:	4649      	mov	r1, r9
   293fa:	23a5      	movs	r3, #165	; 0xa5
   293fc:	462a      	mov	r2, r5
   293fe:	4630      	mov	r0, r6
   29400:	f003 ff23 	bl	2d24a <printk>
   29404:	4825      	ldr	r0, [pc, #148]	; (2949c <clear_event_registrations+0x150>)
   29406:	f003 ff20 	bl	2d24a <printk>
   2940a:	21a5      	movs	r1, #165	; 0xa5
   2940c:	4628      	mov	r0, r5
   2940e:	f003 ff62 	bl	2d2d6 <assert_post_action>
   29412:	4823      	ldr	r0, [pc, #140]	; (294a0 <clear_event_registrations+0x154>)
   29414:	f7ff f976 	bl	28704 <z_spin_unlock_valid>
   29418:	b968      	cbnz	r0, 29436 <clear_event_registrations+0xea>
   2941a:	235d      	movs	r3, #93	; 0x5d
   2941c:	4a21      	ldr	r2, [pc, #132]	; (294a4 <clear_event_registrations+0x158>)
   2941e:	4922      	ldr	r1, [pc, #136]	; (294a8 <clear_event_registrations+0x15c>)
   29420:	4630      	mov	r0, r6
   29422:	f003 ff12 	bl	2d24a <printk>
   29426:	491e      	ldr	r1, [pc, #120]	; (294a0 <clear_event_registrations+0x154>)
   29428:	4820      	ldr	r0, [pc, #128]	; (294ac <clear_event_registrations+0x160>)
   2942a:	f003 ff0e 	bl	2d24a <printk>
   2942e:	215d      	movs	r1, #93	; 0x5d
   29430:	481c      	ldr	r0, [pc, #112]	; (294a4 <clear_event_registrations+0x158>)
   29432:	f003 ff50 	bl	2d2d6 <assert_post_action>
   29436:	f387 8811 	msr	BASEPRI, r7
   2943a:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   2943e:	f04f 0320 	mov.w	r3, #32
   29442:	f3ef 8711 	mrs	r7, BASEPRI
   29446:	f383 8811 	msr	BASEPRI, r3
   2944a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2944e:	4814      	ldr	r0, [pc, #80]	; (294a0 <clear_event_registrations+0x154>)
   29450:	f7ff f94a 	bl	286e8 <z_spin_lock_valid>
   29454:	b968      	cbnz	r0, 29472 <clear_event_registrations+0x126>
   29456:	234a      	movs	r3, #74	; 0x4a
   29458:	4a12      	ldr	r2, [pc, #72]	; (294a4 <clear_event_registrations+0x158>)
   2945a:	4915      	ldr	r1, [pc, #84]	; (294b0 <clear_event_registrations+0x164>)
   2945c:	4630      	mov	r0, r6
   2945e:	f003 fef4 	bl	2d24a <printk>
   29462:	490f      	ldr	r1, [pc, #60]	; (294a0 <clear_event_registrations+0x154>)
   29464:	4813      	ldr	r0, [pc, #76]	; (294b4 <clear_event_registrations+0x168>)
   29466:	f003 fef0 	bl	2d24a <printk>
   2946a:	214a      	movs	r1, #74	; 0x4a
   2946c:	480d      	ldr	r0, [pc, #52]	; (294a4 <clear_event_registrations+0x158>)
   2946e:	f003 ff32 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   29472:	480b      	ldr	r0, [pc, #44]	; (294a0 <clear_event_registrations+0x154>)
   29474:	f7ff f956 	bl	28724 <z_spin_lock_set_owner>
	return k;
   29478:	3c14      	subs	r4, #20
   2947a:	e772      	b.n	29362 <clear_event_registrations+0x16>
   2947c:	00034d24 	.word	0x00034d24
   29480:	000311a3 	.word	0x000311a3
   29484:	00034bd7 	.word	0x00034bd7
   29488:	00034bf1 	.word	0x00034bf1
   2948c:	00034c06 	.word	0x00034c06
   29490:	00034c22 	.word	0x00034c22
   29494:	00034c33 	.word	0x00034c33
   29498:	00034c50 	.word	0x00034c50
   2949c:	00034c67 	.word	0x00034c67
   294a0:	2002d404 	.word	0x2002d404
   294a4:	00031168 	.word	0x00031168
   294a8:	00031202 	.word	0x00031202
   294ac:	00031219 	.word	0x00031219
   294b0:	0003118e 	.word	0x0003118e
   294b4:	000311c0 	.word	0x000311c0
   294b8:	0003495a 	.word	0x0003495a

000294bc <register_events>:
{
   294bc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
   294c0:	2700      	movs	r7, #0
{
   294c2:	468a      	mov	sl, r1
   294c4:	4615      	mov	r5, r2
   294c6:	4604      	mov	r4, r0
	int events_registered = 0;
   294c8:	46b9      	mov	r9, r7
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   294ca:	4e69      	ldr	r6, [pc, #420]	; (29670 <register_events+0x1b4>)
   294cc:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 296b0 <register_events+0x1f4>
{
   294d0:	9301      	str	r3, [sp, #4]
	for (int ii = 0; ii < num_events; ii++) {
   294d2:	4557      	cmp	r7, sl
   294d4:	db03      	blt.n	294de <register_events+0x22>
}
   294d6:	4648      	mov	r0, r9
   294d8:	b003      	add	sp, #12
   294da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   294de:	f04f 0320 	mov.w	r3, #32
   294e2:	f3ef 8b11 	mrs	fp, BASEPRI
   294e6:	f383 8811 	msr	BASEPRI, r3
   294ea:	f3bf 8f6f 	isb	sy
   294ee:	4630      	mov	r0, r6
   294f0:	f7ff f8fa 	bl	286e8 <z_spin_lock_valid>
   294f4:	b968      	cbnz	r0, 29512 <register_events+0x56>
   294f6:	234a      	movs	r3, #74	; 0x4a
   294f8:	4642      	mov	r2, r8
   294fa:	495e      	ldr	r1, [pc, #376]	; (29674 <register_events+0x1b8>)
   294fc:	485e      	ldr	r0, [pc, #376]	; (29678 <register_events+0x1bc>)
   294fe:	f003 fea4 	bl	2d24a <printk>
   29502:	4631      	mov	r1, r6
   29504:	485d      	ldr	r0, [pc, #372]	; (2967c <register_events+0x1c0>)
   29506:	f003 fea0 	bl	2d24a <printk>
   2950a:	214a      	movs	r1, #74	; 0x4a
   2950c:	4640      	mov	r0, r8
   2950e:	f003 fee2 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   29512:	4630      	mov	r0, r6
   29514:	f7ff f906 	bl	28724 <z_spin_lock_set_owner>
	switch (event->type) {
   29518:	7b63      	ldrb	r3, [r4, #13]
   2951a:	f003 030f 	and.w	r3, r3, #15
   2951e:	2b04      	cmp	r3, #4
   29520:	d844      	bhi.n	295ac <register_events+0xf0>
   29522:	e8df f003 	tbb	[pc, r3]
   29526:	3d2d      	.short	0x3d2d
   29528:	4303      	.short	0x4303
   2952a:	2a          	.byte	0x2a
   2952b:	00          	.byte	0x00
		if (k_sem_count_get(event->sem) > 0) {
   2952c:	6923      	ldr	r3, [r4, #16]
   2952e:	689b      	ldr	r3, [r3, #8]
   29530:	b333      	cbz	r3, 29580 <register_events+0xc4>
			*state = K_POLL_STATE_SEM_AVAILABLE;
   29532:	2202      	movs	r2, #2
	event->poller = NULL;
   29534:	2100      	movs	r1, #0
	event->state |= state;
   29536:	68e3      	ldr	r3, [r4, #12]
	event->poller = NULL;
   29538:	60a1      	str	r1, [r4, #8]
	event->state |= state;
   2953a:	f3c3 3004 	ubfx	r0, r3, #12, #5
   2953e:	4302      	orrs	r2, r0
   29540:	f362 3310 	bfi	r3, r2, #12, #5
   29544:	60e3      	str	r3, [r4, #12]
			poller->is_polling = false;
   29546:	7029      	strb	r1, [r5, #0]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   29548:	4630      	mov	r0, r6
   2954a:	f7ff f8db 	bl	28704 <z_spin_unlock_valid>
   2954e:	b968      	cbnz	r0, 2956c <register_events+0xb0>
   29550:	235d      	movs	r3, #93	; 0x5d
   29552:	4642      	mov	r2, r8
   29554:	494a      	ldr	r1, [pc, #296]	; (29680 <register_events+0x1c4>)
   29556:	4848      	ldr	r0, [pc, #288]	; (29678 <register_events+0x1bc>)
   29558:	f003 fe77 	bl	2d24a <printk>
   2955c:	4631      	mov	r1, r6
   2955e:	4849      	ldr	r0, [pc, #292]	; (29684 <register_events+0x1c8>)
   29560:	f003 fe73 	bl	2d24a <printk>
   29564:	215d      	movs	r1, #93	; 0x5d
   29566:	4640      	mov	r0, r8
   29568:	f003 feb5 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   2956c:	f38b 8811 	msr	BASEPRI, fp
   29570:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   29574:	3701      	adds	r7, #1
   29576:	3414      	adds	r4, #20
   29578:	e7ab      	b.n	294d2 <register_events+0x16>
		if (!k_queue_is_empty(event->queue)) {
   2957a:	6923      	ldr	r3, [r4, #16]
   2957c:	681b      	ldr	r3, [r3, #0]
   2957e:	bb33      	cbnz	r3, 295ce <register_events+0x112>
		} else if (!just_check && poller->is_polling) {
   29580:	9b01      	ldr	r3, [sp, #4]
   29582:	2b00      	cmp	r3, #0
   29584:	d1e0      	bne.n	29548 <register_events+0x8c>
   29586:	782b      	ldrb	r3, [r5, #0]
   29588:	2b00      	cmp	r3, #0
   2958a:	d0dd      	beq.n	29548 <register_events+0x8c>
	switch (event->type) {
   2958c:	7b63      	ldrb	r3, [r4, #13]
   2958e:	f003 030f 	and.w	r3, r3, #15
   29592:	2b04      	cmp	r3, #4
   29594:	d85d      	bhi.n	29652 <register_events+0x196>
   29596:	e8df f003 	tbb	[pc, r3]
   2959a:	4931      	.short	0x4931
   2959c:	5c1c      	.short	0x5c1c
   2959e:	35          	.byte	0x35
   2959f:	00          	.byte	0x00
		if (event->signal->signaled != 0U) {
   295a0:	6923      	ldr	r3, [r4, #16]
   295a2:	689b      	ldr	r3, [r3, #8]
   295a4:	2b00      	cmp	r3, #0
   295a6:	d0eb      	beq.n	29580 <register_events+0xc4>
			*state = K_POLL_STATE_SIGNALED;
   295a8:	2201      	movs	r2, #1
   295aa:	e7c3      	b.n	29534 <register_events+0x78>
		__ASSERT(false, "invalid event type (0x%x)\n", event->type);
   295ac:	2350      	movs	r3, #80	; 0x50
   295ae:	4a36      	ldr	r2, [pc, #216]	; (29688 <register_events+0x1cc>)
   295b0:	4936      	ldr	r1, [pc, #216]	; (2968c <register_events+0x1d0>)
   295b2:	4831      	ldr	r0, [pc, #196]	; (29678 <register_events+0x1bc>)
   295b4:	f003 fe49 	bl	2d24a <printk>
   295b8:	7b61      	ldrb	r1, [r4, #13]
   295ba:	4835      	ldr	r0, [pc, #212]	; (29690 <register_events+0x1d4>)
   295bc:	f001 010f 	and.w	r1, r1, #15
   295c0:	f003 fe43 	bl	2d24a <printk>
   295c4:	2150      	movs	r1, #80	; 0x50
   295c6:	4830      	ldr	r0, [pc, #192]	; (29688 <register_events+0x1cc>)
   295c8:	f003 fe85 	bl	2d2d6 <assert_post_action>
		break;
   295cc:	e7d8      	b.n	29580 <register_events+0xc4>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
   295ce:	2204      	movs	r2, #4
   295d0:	e7b0      	b.n	29534 <register_events+0x78>
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
   295d2:	6923      	ldr	r3, [r4, #16]
   295d4:	b963      	cbnz	r3, 295f0 <register_events+0x134>
   295d6:	492f      	ldr	r1, [pc, #188]	; (29694 <register_events+0x1d8>)
   295d8:	2375      	movs	r3, #117	; 0x75
   295da:	4a2b      	ldr	r2, [pc, #172]	; (29688 <register_events+0x1cc>)
   295dc:	4826      	ldr	r0, [pc, #152]	; (29678 <register_events+0x1bc>)
   295de:	f003 fe34 	bl	2d24a <printk>
   295e2:	482d      	ldr	r0, [pc, #180]	; (29698 <register_events+0x1dc>)
   295e4:	f003 fe31 	bl	2d24a <printk>
   295e8:	2175      	movs	r1, #117	; 0x75
   295ea:	4827      	ldr	r0, [pc, #156]	; (29688 <register_events+0x1cc>)
   295ec:	f003 fe73 	bl	2d2d6 <assert_post_action>
		add_event(&event->sem->poll_events, event, poller);
   295f0:	462a      	mov	r2, r5
   295f2:	4621      	mov	r1, r4
   295f4:	6920      	ldr	r0, [r4, #16]
   295f6:	3010      	adds	r0, #16
		add_event(&event->queue->poll_events, event, poller);
   295f8:	f005 fe4b 	bl	2f292 <add_event>
	event->poller = poller;
   295fc:	60a5      	str	r5, [r4, #8]
				events_registered += 1;
   295fe:	f109 0901 	add.w	r9, r9, #1
   29602:	e7a1      	b.n	29548 <register_events+0x8c>
		__ASSERT(event->queue != NULL, "invalid queue\n");
   29604:	6923      	ldr	r3, [r4, #16]
   29606:	b963      	cbnz	r3, 29622 <register_events+0x166>
   29608:	4924      	ldr	r1, [pc, #144]	; (2969c <register_events+0x1e0>)
   2960a:	2379      	movs	r3, #121	; 0x79
   2960c:	4a1e      	ldr	r2, [pc, #120]	; (29688 <register_events+0x1cc>)
   2960e:	481a      	ldr	r0, [pc, #104]	; (29678 <register_events+0x1bc>)
   29610:	f003 fe1b 	bl	2d24a <printk>
   29614:	4822      	ldr	r0, [pc, #136]	; (296a0 <register_events+0x1e4>)
   29616:	f003 fe18 	bl	2d24a <printk>
   2961a:	2179      	movs	r1, #121	; 0x79
   2961c:	481a      	ldr	r0, [pc, #104]	; (29688 <register_events+0x1cc>)
   2961e:	f003 fe5a 	bl	2d2d6 <assert_post_action>
		add_event(&event->queue->poll_events, event, poller);
   29622:	6920      	ldr	r0, [r4, #16]
   29624:	462a      	mov	r2, r5
   29626:	4621      	mov	r1, r4
   29628:	300c      	adds	r0, #12
   2962a:	e7e5      	b.n	295f8 <register_events+0x13c>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   2962c:	6923      	ldr	r3, [r4, #16]
   2962e:	b963      	cbnz	r3, 2964a <register_events+0x18e>
   29630:	491c      	ldr	r1, [pc, #112]	; (296a4 <register_events+0x1e8>)
   29632:	237d      	movs	r3, #125	; 0x7d
   29634:	4a14      	ldr	r2, [pc, #80]	; (29688 <register_events+0x1cc>)
   29636:	4810      	ldr	r0, [pc, #64]	; (29678 <register_events+0x1bc>)
   29638:	f003 fe07 	bl	2d24a <printk>
   2963c:	481a      	ldr	r0, [pc, #104]	; (296a8 <register_events+0x1ec>)
   2963e:	f003 fe04 	bl	2d24a <printk>
   29642:	217d      	movs	r1, #125	; 0x7d
   29644:	4810      	ldr	r0, [pc, #64]	; (29688 <register_events+0x1cc>)
   29646:	f003 fe46 	bl	2d2d6 <assert_post_action>
		add_event(&event->signal->poll_events, event, poller);
   2964a:	462a      	mov	r2, r5
   2964c:	4621      	mov	r1, r4
   2964e:	6920      	ldr	r0, [r4, #16]
   29650:	e7d2      	b.n	295f8 <register_events+0x13c>
		__ASSERT(false, "invalid event type\n");
   29652:	2384      	movs	r3, #132	; 0x84
   29654:	4a0c      	ldr	r2, [pc, #48]	; (29688 <register_events+0x1cc>)
   29656:	490d      	ldr	r1, [pc, #52]	; (2968c <register_events+0x1d0>)
   29658:	4807      	ldr	r0, [pc, #28]	; (29678 <register_events+0x1bc>)
   2965a:	f003 fdf6 	bl	2d24a <printk>
   2965e:	4813      	ldr	r0, [pc, #76]	; (296ac <register_events+0x1f0>)
   29660:	f003 fdf3 	bl	2d24a <printk>
   29664:	2184      	movs	r1, #132	; 0x84
   29666:	4808      	ldr	r0, [pc, #32]	; (29688 <register_events+0x1cc>)
   29668:	f003 fe35 	bl	2d2d6 <assert_post_action>
		break;
   2966c:	e7c6      	b.n	295fc <register_events+0x140>
   2966e:	bf00      	nop
   29670:	2002d404 	.word	0x2002d404
   29674:	0003118e 	.word	0x0003118e
   29678:	000311a3 	.word	0x000311a3
   2967c:	000311c0 	.word	0x000311c0
   29680:	00031202 	.word	0x00031202
   29684:	00031219 	.word	0x00031219
   29688:	00034d24 	.word	0x00034d24
   2968c:	0003495a 	.word	0x0003495a
   29690:	00034d7a 	.word	0x00034d7a
   29694:	00034bd7 	.word	0x00034bd7
   29698:	00034bf1 	.word	0x00034bf1
   2969c:	00034c06 	.word	0x00034c06
   296a0:	00034c22 	.word	0x00034c22
   296a4:	00034c33 	.word	0x00034c33
   296a8:	00034c50 	.word	0x00034c50
   296ac:	00034c67 	.word	0x00034c67
   296b0:	00031168 	.word	0x00031168

000296b4 <k_poll_event_init>:
{
   296b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   296b6:	4604      	mov	r4, r0
   296b8:	460f      	mov	r7, r1
   296ba:	461d      	mov	r5, r3
	__ASSERT(mode == K_POLL_MODE_NOTIFY_ONLY,
   296bc:	4616      	mov	r6, r2
   296be:	b162      	cbz	r2, 296da <k_poll_event_init+0x26>
   296c0:	491c      	ldr	r1, [pc, #112]	; (29734 <k_poll_event_init+0x80>)
   296c2:	232a      	movs	r3, #42	; 0x2a
   296c4:	4a1c      	ldr	r2, [pc, #112]	; (29738 <k_poll_event_init+0x84>)
   296c6:	481d      	ldr	r0, [pc, #116]	; (2973c <k_poll_event_init+0x88>)
   296c8:	f003 fdbf 	bl	2d24a <printk>
   296cc:	481c      	ldr	r0, [pc, #112]	; (29740 <k_poll_event_init+0x8c>)
   296ce:	f003 fdbc 	bl	2d24a <printk>
   296d2:	212a      	movs	r1, #42	; 0x2a
   296d4:	4818      	ldr	r0, [pc, #96]	; (29738 <k_poll_event_init+0x84>)
   296d6:	f003 fdfe 	bl	2d2d6 <assert_post_action>
	__ASSERT(type < (BIT(_POLL_NUM_TYPES)), "invalid type\n");
   296da:	2f0f      	cmp	r7, #15
   296dc:	d90c      	bls.n	296f8 <k_poll_event_init+0x44>
   296de:	4919      	ldr	r1, [pc, #100]	; (29744 <k_poll_event_init+0x90>)
   296e0:	232b      	movs	r3, #43	; 0x2b
   296e2:	4a15      	ldr	r2, [pc, #84]	; (29738 <k_poll_event_init+0x84>)
   296e4:	4815      	ldr	r0, [pc, #84]	; (2973c <k_poll_event_init+0x88>)
   296e6:	f003 fdb0 	bl	2d24a <printk>
   296ea:	4817      	ldr	r0, [pc, #92]	; (29748 <k_poll_event_init+0x94>)
   296ec:	f003 fdad 	bl	2d24a <printk>
   296f0:	212b      	movs	r1, #43	; 0x2b
   296f2:	4811      	ldr	r0, [pc, #68]	; (29738 <k_poll_event_init+0x84>)
   296f4:	f003 fdef 	bl	2d2d6 <assert_post_action>
	__ASSERT(obj != NULL, "must provide an object\n");
   296f8:	b965      	cbnz	r5, 29714 <k_poll_event_init+0x60>
   296fa:	4914      	ldr	r1, [pc, #80]	; (2974c <k_poll_event_init+0x98>)
   296fc:	232c      	movs	r3, #44	; 0x2c
   296fe:	4a0e      	ldr	r2, [pc, #56]	; (29738 <k_poll_event_init+0x84>)
   29700:	480e      	ldr	r0, [pc, #56]	; (2973c <k_poll_event_init+0x88>)
   29702:	f003 fda2 	bl	2d24a <printk>
   29706:	4812      	ldr	r0, [pc, #72]	; (29750 <k_poll_event_init+0x9c>)
   29708:	f003 fd9f 	bl	2d24a <printk>
   2970c:	212c      	movs	r1, #44	; 0x2c
   2970e:	480a      	ldr	r0, [pc, #40]	; (29738 <k_poll_event_init+0x84>)
   29710:	f003 fde1 	bl	2d2d6 <assert_post_action>
	event->type = type;
   29714:	7b63      	ldrb	r3, [r4, #13]
   29716:	f367 0303 	bfi	r3, r7, #0, #4
   2971a:	7363      	strb	r3, [r4, #13]
	event->mode = mode;
   2971c:	7ba3      	ldrb	r3, [r4, #14]
   2971e:	f366 0341 	bfi	r3, r6, #1, #1
   29722:	73a3      	strb	r3, [r4, #14]
	event->poller = NULL;
   29724:	2300      	movs	r3, #0
	event->state = K_POLL_STATE_NOT_READY;
   29726:	68e2      	ldr	r2, [r4, #12]
	event->poller = NULL;
   29728:	60a3      	str	r3, [r4, #8]
	event->state = K_POLL_STATE_NOT_READY;
   2972a:	4b0a      	ldr	r3, [pc, #40]	; (29754 <k_poll_event_init+0xa0>)
   2972c:	4013      	ands	r3, r2
	event->obj = obj;
   2972e:	e9c4 3503 	strd	r3, r5, [r4, #12]
}
   29732:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   29734:	00034c7d 	.word	0x00034c7d
   29738:	00034d24 	.word	0x00034d24
   2973c:	000311a3 	.word	0x000311a3
   29740:	00034c9d 	.word	0x00034c9d
   29744:	00034cc3 	.word	0x00034cc3
   29748:	00034ce7 	.word	0x00034ce7
   2974c:	00034cf7 	.word	0x00034cf7
   29750:	00034d0a 	.word	0x00034d0a
   29754:	00020fff 	.word	0x00020fff

00029758 <z_impl_k_poll>:

int z_impl_k_poll(struct k_poll_event *events, int num_events, s32_t timeout)
{
	int events_registered;
	k_spinlock_key_t key;
	struct _poller poller = { .is_polling = true,
   29758:	2301      	movs	r3, #1
{
   2975a:	b5f0      	push	{r4, r5, r6, r7, lr}
   2975c:	b087      	sub	sp, #28
	struct _poller poller = { .is_polling = true,
   2975e:	f88d 300c 	strb.w	r3, [sp, #12]
				  .thread     = _current,
   29762:	4b70      	ldr	r3, [pc, #448]	; (29924 <z_impl_k_poll+0x1cc>)
{
   29764:	4604      	mov	r4, r0
	struct _poller poller = { .is_polling = true,
   29766:	689b      	ldr	r3, [r3, #8]
{
   29768:	460d      	mov	r5, r1
	struct _poller poller = { .is_polling = true,
   2976a:	9304      	str	r3, [sp, #16]
   2976c:	4b6e      	ldr	r3, [pc, #440]	; (29928 <z_impl_k_poll+0x1d0>)
{
   2976e:	4616      	mov	r6, r2
	struct _poller poller = { .is_polling = true,
   29770:	9305      	str	r3, [sp, #20]
   29772:	f3ef 8305 	mrs	r3, IPSR
				  .cb         = k_poll_poller_cb };

	__ASSERT(!arch_is_in_isr(), "");
   29776:	b163      	cbz	r3, 29792 <z_impl_k_poll+0x3a>
   29778:	496c      	ldr	r1, [pc, #432]	; (2992c <z_impl_k_poll+0x1d4>)
   2977a:	23ff      	movs	r3, #255	; 0xff
   2977c:	4a6c      	ldr	r2, [pc, #432]	; (29930 <z_impl_k_poll+0x1d8>)
   2977e:	486d      	ldr	r0, [pc, #436]	; (29934 <z_impl_k_poll+0x1dc>)
   29780:	f003 fd63 	bl	2d24a <printk>
   29784:	486c      	ldr	r0, [pc, #432]	; (29938 <z_impl_k_poll+0x1e0>)
   29786:	f003 fd60 	bl	2d24a <printk>
   2978a:	21ff      	movs	r1, #255	; 0xff
   2978c:	4868      	ldr	r0, [pc, #416]	; (29930 <z_impl_k_poll+0x1d8>)
   2978e:	f003 fda2 	bl	2d2d6 <assert_post_action>
	__ASSERT(events != NULL, "NULL events\n");
   29792:	b974      	cbnz	r4, 297b2 <z_impl_k_poll+0x5a>
   29794:	4969      	ldr	r1, [pc, #420]	; (2993c <z_impl_k_poll+0x1e4>)
   29796:	f44f 7380 	mov.w	r3, #256	; 0x100
   2979a:	4a65      	ldr	r2, [pc, #404]	; (29930 <z_impl_k_poll+0x1d8>)
   2979c:	4865      	ldr	r0, [pc, #404]	; (29934 <z_impl_k_poll+0x1dc>)
   2979e:	f003 fd54 	bl	2d24a <printk>
   297a2:	4867      	ldr	r0, [pc, #412]	; (29940 <z_impl_k_poll+0x1e8>)
   297a4:	f003 fd51 	bl	2d24a <printk>
   297a8:	f44f 7180 	mov.w	r1, #256	; 0x100
   297ac:	4860      	ldr	r0, [pc, #384]	; (29930 <z_impl_k_poll+0x1d8>)
   297ae:	f003 fd92 	bl	2d2d6 <assert_post_action>
	__ASSERT(num_events >= 0, "<0 events\n");
   297b2:	2d00      	cmp	r5, #0
   297b4:	da0e      	bge.n	297d4 <z_impl_k_poll+0x7c>
   297b6:	4963      	ldr	r1, [pc, #396]	; (29944 <z_impl_k_poll+0x1ec>)
   297b8:	f240 1301 	movw	r3, #257	; 0x101
   297bc:	4a5c      	ldr	r2, [pc, #368]	; (29930 <z_impl_k_poll+0x1d8>)
   297be:	485d      	ldr	r0, [pc, #372]	; (29934 <z_impl_k_poll+0x1dc>)
   297c0:	f003 fd43 	bl	2d24a <printk>
   297c4:	4860      	ldr	r0, [pc, #384]	; (29948 <z_impl_k_poll+0x1f0>)
   297c6:	f003 fd40 	bl	2d24a <printk>
   297ca:	f240 1101 	movw	r1, #257	; 0x101
   297ce:	4858      	ldr	r0, [pc, #352]	; (29930 <z_impl_k_poll+0x1d8>)
   297d0:	f003 fd81 	bl	2d2d6 <assert_post_action>

	events_registered = register_events(events, num_events, &poller,
   297d4:	fab6 f386 	clz	r3, r6
   297d8:	aa03      	add	r2, sp, #12
   297da:	095b      	lsrs	r3, r3, #5
   297dc:	4629      	mov	r1, r5
   297de:	4620      	mov	r0, r4
   297e0:	f7ff fe6c 	bl	294bc <register_events>
   297e4:	4607      	mov	r7, r0
	__asm__ volatile(
   297e6:	f04f 0320 	mov.w	r3, #32
   297ea:	f3ef 8511 	mrs	r5, BASEPRI
   297ee:	f383 8811 	msr	BASEPRI, r3
   297f2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   297f6:	4855      	ldr	r0, [pc, #340]	; (2994c <z_impl_k_poll+0x1f4>)
   297f8:	f7fe ff76 	bl	286e8 <z_spin_lock_valid>
   297fc:	b968      	cbnz	r0, 2981a <z_impl_k_poll+0xc2>
   297fe:	234a      	movs	r3, #74	; 0x4a
   29800:	4a53      	ldr	r2, [pc, #332]	; (29950 <z_impl_k_poll+0x1f8>)
   29802:	4954      	ldr	r1, [pc, #336]	; (29954 <z_impl_k_poll+0x1fc>)
   29804:	484b      	ldr	r0, [pc, #300]	; (29934 <z_impl_k_poll+0x1dc>)
   29806:	f003 fd20 	bl	2d24a <printk>
   2980a:	4950      	ldr	r1, [pc, #320]	; (2994c <z_impl_k_poll+0x1f4>)
   2980c:	4852      	ldr	r0, [pc, #328]	; (29958 <z_impl_k_poll+0x200>)
   2980e:	f003 fd1c 	bl	2d24a <printk>
   29812:	214a      	movs	r1, #74	; 0x4a
   29814:	484e      	ldr	r0, [pc, #312]	; (29950 <z_impl_k_poll+0x1f8>)
   29816:	f003 fd5e 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   2981a:	484c      	ldr	r0, [pc, #304]	; (2994c <z_impl_k_poll+0x1f4>)
   2981c:	f7fe ff82 	bl	28724 <z_spin_lock_set_owner>
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller.is_polling) {
   29820:	f89d 300c 	ldrb.w	r3, [sp, #12]
   29824:	b9f3      	cbnz	r3, 29864 <z_impl_k_poll+0x10c>
		clear_event_registrations(events, events_registered, key);
   29826:	4620      	mov	r0, r4
   29828:	462a      	mov	r2, r5
   2982a:	4639      	mov	r1, r7
   2982c:	f7ff fd8e 	bl	2934c <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   29830:	4846      	ldr	r0, [pc, #280]	; (2994c <z_impl_k_poll+0x1f4>)
   29832:	f7fe ff67 	bl	28704 <z_spin_unlock_valid>
   29836:	b968      	cbnz	r0, 29854 <z_impl_k_poll+0xfc>
   29838:	235d      	movs	r3, #93	; 0x5d
   2983a:	4a45      	ldr	r2, [pc, #276]	; (29950 <z_impl_k_poll+0x1f8>)
   2983c:	4947      	ldr	r1, [pc, #284]	; (2995c <z_impl_k_poll+0x204>)
   2983e:	483d      	ldr	r0, [pc, #244]	; (29934 <z_impl_k_poll+0x1dc>)
   29840:	f003 fd03 	bl	2d24a <printk>
   29844:	4941      	ldr	r1, [pc, #260]	; (2994c <z_impl_k_poll+0x1f4>)
   29846:	4846      	ldr	r0, [pc, #280]	; (29960 <z_impl_k_poll+0x208>)
   29848:	f003 fcff 	bl	2d24a <printk>
   2984c:	215d      	movs	r1, #93	; 0x5d
   2984e:	4840      	ldr	r0, [pc, #256]	; (29950 <z_impl_k_poll+0x1f8>)
   29850:	f003 fd41 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   29854:	f385 8811 	msr	BASEPRI, r5
   29858:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		return 0;
   2985c:	2500      	movs	r5, #0
	key = k_spin_lock(&lock);
	clear_event_registrations(events, events_registered, key);
	k_spin_unlock(&lock, key);

	return swap_rc;
}
   2985e:	4628      	mov	r0, r5
   29860:	b007      	add	sp, #28
   29862:	bdf0      	pop	{r4, r5, r6, r7, pc}
	poller.is_polling = false;
   29864:	2300      	movs	r3, #0
   29866:	f88d 300c 	strb.w	r3, [sp, #12]
	if (timeout == K_NO_WAIT) {
   2986a:	b9c6      	cbnz	r6, 2989e <z_impl_k_poll+0x146>
   2986c:	4837      	ldr	r0, [pc, #220]	; (2994c <z_impl_k_poll+0x1f4>)
   2986e:	f7fe ff49 	bl	28704 <z_spin_unlock_valid>
   29872:	b968      	cbnz	r0, 29890 <z_impl_k_poll+0x138>
   29874:	235d      	movs	r3, #93	; 0x5d
   29876:	4a36      	ldr	r2, [pc, #216]	; (29950 <z_impl_k_poll+0x1f8>)
   29878:	4938      	ldr	r1, [pc, #224]	; (2995c <z_impl_k_poll+0x204>)
   2987a:	482e      	ldr	r0, [pc, #184]	; (29934 <z_impl_k_poll+0x1dc>)
   2987c:	f003 fce5 	bl	2d24a <printk>
   29880:	4932      	ldr	r1, [pc, #200]	; (2994c <z_impl_k_poll+0x1f4>)
   29882:	4837      	ldr	r0, [pc, #220]	; (29960 <z_impl_k_poll+0x208>)
   29884:	f003 fce1 	bl	2d24a <printk>
   29888:	215d      	movs	r1, #93	; 0x5d
   2988a:	4831      	ldr	r0, [pc, #196]	; (29950 <z_impl_k_poll+0x1f8>)
   2988c:	f003 fd23 	bl	2d2d6 <assert_post_action>
   29890:	f385 8811 	msr	BASEPRI, r5
   29894:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
   29898:	f06f 050a 	mvn.w	r5, #10
   2989c:	e7df      	b.n	2985e <z_impl_k_poll+0x106>
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   2989e:	aa01      	add	r2, sp, #4
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   298a0:	4629      	mov	r1, r5
   298a2:	4633      	mov	r3, r6
   298a4:	4829      	ldr	r0, [pc, #164]	; (2994c <z_impl_k_poll+0x1f4>)
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   298a6:	e9cd 2201 	strd	r2, r2, [sp, #4]
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   298aa:	f7fe fb43 	bl	27f34 <z_pend_curr>
   298ae:	4605      	mov	r5, r0
	__asm__ volatile(
   298b0:	f04f 0320 	mov.w	r3, #32
   298b4:	f3ef 8611 	mrs	r6, BASEPRI
   298b8:	f383 8811 	msr	BASEPRI, r3
   298bc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   298c0:	4822      	ldr	r0, [pc, #136]	; (2994c <z_impl_k_poll+0x1f4>)
   298c2:	f7fe ff11 	bl	286e8 <z_spin_lock_valid>
   298c6:	b968      	cbnz	r0, 298e4 <z_impl_k_poll+0x18c>
   298c8:	234a      	movs	r3, #74	; 0x4a
   298ca:	4a21      	ldr	r2, [pc, #132]	; (29950 <z_impl_k_poll+0x1f8>)
   298cc:	4921      	ldr	r1, [pc, #132]	; (29954 <z_impl_k_poll+0x1fc>)
   298ce:	4819      	ldr	r0, [pc, #100]	; (29934 <z_impl_k_poll+0x1dc>)
   298d0:	f003 fcbb 	bl	2d24a <printk>
   298d4:	491d      	ldr	r1, [pc, #116]	; (2994c <z_impl_k_poll+0x1f4>)
   298d6:	4820      	ldr	r0, [pc, #128]	; (29958 <z_impl_k_poll+0x200>)
   298d8:	f003 fcb7 	bl	2d24a <printk>
   298dc:	214a      	movs	r1, #74	; 0x4a
   298de:	481c      	ldr	r0, [pc, #112]	; (29950 <z_impl_k_poll+0x1f8>)
   298e0:	f003 fcf9 	bl	2d2d6 <assert_post_action>
	z_spin_lock_set_owner(l);
   298e4:	4819      	ldr	r0, [pc, #100]	; (2994c <z_impl_k_poll+0x1f4>)
   298e6:	f7fe ff1d 	bl	28724 <z_spin_lock_set_owner>
	clear_event_registrations(events, events_registered, key);
   298ea:	4620      	mov	r0, r4
   298ec:	4632      	mov	r2, r6
   298ee:	4639      	mov	r1, r7
   298f0:	f7ff fd2c 	bl	2934c <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   298f4:	4815      	ldr	r0, [pc, #84]	; (2994c <z_impl_k_poll+0x1f4>)
   298f6:	f7fe ff05 	bl	28704 <z_spin_unlock_valid>
   298fa:	b968      	cbnz	r0, 29918 <z_impl_k_poll+0x1c0>
   298fc:	235d      	movs	r3, #93	; 0x5d
   298fe:	4a14      	ldr	r2, [pc, #80]	; (29950 <z_impl_k_poll+0x1f8>)
   29900:	4916      	ldr	r1, [pc, #88]	; (2995c <z_impl_k_poll+0x204>)
   29902:	480c      	ldr	r0, [pc, #48]	; (29934 <z_impl_k_poll+0x1dc>)
   29904:	f003 fca1 	bl	2d24a <printk>
   29908:	4910      	ldr	r1, [pc, #64]	; (2994c <z_impl_k_poll+0x1f4>)
   2990a:	4815      	ldr	r0, [pc, #84]	; (29960 <z_impl_k_poll+0x208>)
   2990c:	f003 fc9d 	bl	2d24a <printk>
   29910:	215d      	movs	r1, #93	; 0x5d
   29912:	480f      	ldr	r0, [pc, #60]	; (29950 <z_impl_k_poll+0x1f8>)
   29914:	f003 fcdf 	bl	2d2d6 <assert_post_action>
	__asm__ volatile(
   29918:	f386 8811 	msr	BASEPRI, r6
   2991c:	f3bf 8f6f 	isb	sy
	return swap_rc;
   29920:	e79d      	b.n	2985e <z_impl_k_poll+0x106>
   29922:	bf00      	nop
   29924:	2002d2e8 	.word	0x2002d2e8
   29928:	000292dd 	.word	0x000292dd
   2992c:	000348fa 	.word	0x000348fa
   29930:	00034d24 	.word	0x00034d24
   29934:	000311a3 	.word	0x000311a3
   29938:	00033242 	.word	0x00033242
   2993c:	00034d97 	.word	0x00034d97
   29940:	00034dad 	.word	0x00034dad
   29944:	00034dbc 	.word	0x00034dbc
   29948:	00034dcc 	.word	0x00034dcc
   2994c:	2002d404 	.word	0x2002d404
   29950:	00031168 	.word	0x00031168
   29954:	0003118e 	.word	0x0003118e
   29958:	000311c0 	.word	0x000311c0
   2995c:	00031202 	.word	0x00031202
   29960:	00031219 	.word	0x00031219

00029964 <fabs>:
   29964:	ec51 0b10 	vmov	r0, r1, d0
   29968:	ee10 2a10 	vmov	r2, s0
   2996c:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   29970:	ec43 2b10 	vmov	d0, r2, r3
   29974:	4770      	bx	lr
   29976:	bf00      	nop

00029978 <acos>:
   29978:	b538      	push	{r3, r4, r5, lr}
   2997a:	ed2d 8b02 	vpush	{d8}
   2997e:	ec55 4b10 	vmov	r4, r5, d0
   29982:	f7e4 fdb1 	bl	e4e8 <__ieee754_acos>
   29986:	4b16      	ldr	r3, [pc, #88]	; (299e0 <acos+0x68>)
   29988:	eeb0 8a40 	vmov.f32	s16, s0
   2998c:	eef0 8a60 	vmov.f32	s17, s1
   29990:	f993 3000 	ldrsb.w	r3, [r3]
   29994:	3301      	adds	r3, #1
   29996:	d011      	beq.n	299bc <acos+0x44>
   29998:	4622      	mov	r2, r4
   2999a:	462b      	mov	r3, r5
   2999c:	4620      	mov	r0, r4
   2999e:	4629      	mov	r1, r5
   299a0:	f7e3 fa92 	bl	cec8 <__aeabi_dcmpun>
   299a4:	b950      	cbnz	r0, 299bc <acos+0x44>
   299a6:	ec45 4b10 	vmov	d0, r4, r5
   299aa:	f7ff ffdb 	bl	29964 <fabs>
   299ae:	2200      	movs	r2, #0
   299b0:	4b0c      	ldr	r3, [pc, #48]	; (299e4 <acos+0x6c>)
   299b2:	ec51 0b10 	vmov	r0, r1, d0
   299b6:	f7e3 f88f 	bl	cad8 <__aeabi_dcmpgt>
   299ba:	b930      	cbnz	r0, 299ca <acos+0x52>
   299bc:	eeb0 0a48 	vmov.f32	s0, s16
   299c0:	eef0 0a68 	vmov.f32	s1, s17
   299c4:	ecbd 8b02 	vpop	{d8}
   299c8:	bd38      	pop	{r3, r4, r5, pc}
   299ca:	f003 fe39 	bl	2d640 <__errno>
   299ce:	2321      	movs	r3, #33	; 0x21
   299d0:	ecbd 8b02 	vpop	{d8}
   299d4:	6003      	str	r3, [r0, #0]
   299d6:	4804      	ldr	r0, [pc, #16]	; (299e8 <acos+0x70>)
   299d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   299dc:	f7e5 bd74 	b.w	f4c8 <nan>
   299e0:	2003b5ce 	.word	0x2003b5ce
   299e4:	3ff00000 	.word	0x3ff00000
   299e8:	00030d9c 	.word	0x00030d9c

000299ec <sqrt>:
   299ec:	b538      	push	{r3, r4, r5, lr}
   299ee:	ed2d 8b02 	vpush	{d8}
   299f2:	ec55 4b10 	vmov	r4, r5, d0
   299f6:	f000 f833 	bl	29a60 <__ieee754_sqrt>
   299fa:	4b18      	ldr	r3, [pc, #96]	; (29a5c <sqrt+0x70>)
   299fc:	eeb0 8a40 	vmov.f32	s16, s0
   29a00:	eef0 8a60 	vmov.f32	s17, s1
   29a04:	f993 3000 	ldrsb.w	r3, [r3]
   29a08:	3301      	adds	r3, #1
   29a0a:	d00d      	beq.n	29a28 <sqrt+0x3c>
   29a0c:	4622      	mov	r2, r4
   29a0e:	462b      	mov	r3, r5
   29a10:	4620      	mov	r0, r4
   29a12:	4629      	mov	r1, r5
   29a14:	f7e3 fa58 	bl	cec8 <__aeabi_dcmpun>
   29a18:	b930      	cbnz	r0, 29a28 <sqrt+0x3c>
   29a1a:	4620      	mov	r0, r4
   29a1c:	4629      	mov	r1, r5
   29a1e:	2200      	movs	r2, #0
   29a20:	2300      	movs	r3, #0
   29a22:	f7e3 f83b 	bl	ca9c <__aeabi_dcmplt>
   29a26:	b930      	cbnz	r0, 29a36 <sqrt+0x4a>
   29a28:	eeb0 0a48 	vmov.f32	s0, s16
   29a2c:	eef0 0a68 	vmov.f32	s1, s17
   29a30:	ecbd 8b02 	vpop	{d8}
   29a34:	bd38      	pop	{r3, r4, r5, pc}
   29a36:	f003 fe03 	bl	2d640 <__errno>
   29a3a:	2121      	movs	r1, #33	; 0x21
   29a3c:	2200      	movs	r2, #0
   29a3e:	2300      	movs	r3, #0
   29a40:	6001      	str	r1, [r0, #0]
   29a42:	4610      	mov	r0, r2
   29a44:	4619      	mov	r1, r3
   29a46:	f7e2 fee1 	bl	c80c <__aeabi_ddiv>
   29a4a:	ec41 0b18 	vmov	d8, r0, r1
   29a4e:	eeb0 0a48 	vmov.f32	s0, s16
   29a52:	eef0 0a68 	vmov.f32	s1, s17
   29a56:	ecbd 8b02 	vpop	{d8}
   29a5a:	bd38      	pop	{r3, r4, r5, pc}
   29a5c:	2003b5ce 	.word	0x2003b5ce

00029a60 <__ieee754_sqrt>:
   29a60:	4a63      	ldr	r2, [pc, #396]	; (29bf0 <__ieee754_sqrt+0x190>)
   29a62:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   29a66:	ec55 4b10 	vmov	r4, r5, d0
   29a6a:	43aa      	bics	r2, r5
   29a6c:	f000 8098 	beq.w	29ba0 <__ieee754_sqrt+0x140>
   29a70:	2d00      	cmp	r5, #0
   29a72:	462b      	mov	r3, r5
   29a74:	ee10 0a10 	vmov	r0, s0
   29a78:	dd5a      	ble.n	29b30 <__ieee754_sqrt+0xd0>
   29a7a:	ea5f 5e25 	movs.w	lr, r5, asr #20
   29a7e:	f000 80ab 	beq.w	29bd8 <__ieee754_sqrt+0x178>
   29a82:	f3c3 0113 	ubfx	r1, r3, #0, #20
   29a86:	f2ae 3eff 	subw	lr, lr, #1023	; 0x3ff
   29a8a:	0fc3      	lsrs	r3, r0, #31
   29a8c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   29a90:	f01e 0f01 	tst.w	lr, #1
   29a94:	ea4f 0240 	mov.w	r2, r0, lsl #1
   29a98:	eb03 0341 	add.w	r3, r3, r1, lsl #1
   29a9c:	d003      	beq.n	29aa6 <__ieee754_sqrt+0x46>
   29a9e:	0fd1      	lsrs	r1, r2, #31
   29aa0:	0082      	lsls	r2, r0, #2
   29aa2:	eb01 0343 	add.w	r3, r1, r3, lsl #1
   29aa6:	f04f 0c00 	mov.w	ip, #0
   29aaa:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   29aae:	2416      	movs	r4, #22
   29ab0:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
   29ab4:	4665      	mov	r5, ip
   29ab6:	1868      	adds	r0, r5, r1
   29ab8:	4298      	cmp	r0, r3
   29aba:	dc02      	bgt.n	29ac2 <__ieee754_sqrt+0x62>
   29abc:	1a1b      	subs	r3, r3, r0
   29abe:	1845      	adds	r5, r0, r1
   29ac0:	448c      	add	ip, r1
   29ac2:	005b      	lsls	r3, r3, #1
   29ac4:	3c01      	subs	r4, #1
   29ac6:	ea4f 0151 	mov.w	r1, r1, lsr #1
   29aca:	eb03 73d2 	add.w	r3, r3, r2, lsr #31
   29ace:	ea4f 0242 	mov.w	r2, r2, lsl #1
   29ad2:	d1f0      	bne.n	29ab6 <__ieee754_sqrt+0x56>
   29ad4:	4627      	mov	r7, r4
   29ad6:	2620      	movs	r6, #32
   29ad8:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   29adc:	e014      	b.n	29b08 <__ieee754_sqrt+0xa8>
   29ade:	d10a      	bne.n	29af6 <__ieee754_sqrt+0x96>
   29ae0:	4290      	cmp	r0, r2
   29ae2:	d808      	bhi.n	29af6 <__ieee754_sqrt+0x96>
   29ae4:	2800      	cmp	r0, #0
   29ae6:	eb00 0401 	add.w	r4, r0, r1
   29aea:	db1c      	blt.n	29b26 <__ieee754_sqrt+0xc6>
   29aec:	46a8      	mov	r8, r5
   29aee:	2300      	movs	r3, #0
   29af0:	1a12      	subs	r2, r2, r0
   29af2:	440f      	add	r7, r1
   29af4:	4645      	mov	r5, r8
   29af6:	0fd0      	lsrs	r0, r2, #31
   29af8:	3e01      	subs	r6, #1
   29afa:	ea4f 0151 	mov.w	r1, r1, lsr #1
   29afe:	eb00 0343 	add.w	r3, r0, r3, lsl #1
   29b02:	ea4f 0242 	mov.w	r2, r2, lsl #1
   29b06:	d034      	beq.n	29b72 <__ieee754_sqrt+0x112>
   29b08:	42ab      	cmp	r3, r5
   29b0a:	eb01 0004 	add.w	r0, r1, r4
   29b0e:	dde6      	ble.n	29ade <__ieee754_sqrt+0x7e>
   29b10:	2800      	cmp	r0, #0
   29b12:	eb00 0401 	add.w	r4, r0, r1
   29b16:	db06      	blt.n	29b26 <__ieee754_sqrt+0xc6>
   29b18:	46a8      	mov	r8, r5
   29b1a:	1b5b      	subs	r3, r3, r5
   29b1c:	4290      	cmp	r0, r2
   29b1e:	bf88      	it	hi
   29b20:	f103 33ff 	addhi.w	r3, r3, #4294967295
   29b24:	e7e4      	b.n	29af0 <__ieee754_sqrt+0x90>
   29b26:	2c00      	cmp	r4, #0
   29b28:	dbf6      	blt.n	29b18 <__ieee754_sqrt+0xb8>
   29b2a:	f105 0801 	add.w	r8, r5, #1
   29b2e:	e7f4      	b.n	29b1a <__ieee754_sqrt+0xba>
   29b30:	f025 4200 	bic.w	r2, r5, #2147483648	; 0x80000000
   29b34:	4322      	orrs	r2, r4
   29b36:	d02c      	beq.n	29b92 <__ieee754_sqrt+0x132>
   29b38:	2d00      	cmp	r5, #0
   29b3a:	d141      	bne.n	29bc0 <__ieee754_sqrt+0x160>
   29b3c:	0ac4      	lsrs	r4, r0, #11
   29b3e:	3b15      	subs	r3, #21
   29b40:	0540      	lsls	r0, r0, #21
   29b42:	4622      	mov	r2, r4
   29b44:	2c00      	cmp	r4, #0
   29b46:	d0f9      	beq.n	29b3c <__ieee754_sqrt+0xdc>
   29b48:	02e5      	lsls	r5, r4, #11
   29b4a:	d44b      	bmi.n	29be4 <__ieee754_sqrt+0x184>
   29b4c:	2100      	movs	r1, #0
   29b4e:	e000      	b.n	29b52 <__ieee754_sqrt+0xf2>
   29b50:	4629      	mov	r1, r5
   29b52:	0052      	lsls	r2, r2, #1
   29b54:	1c4d      	adds	r5, r1, #1
   29b56:	02d4      	lsls	r4, r2, #11
   29b58:	d5fa      	bpl.n	29b50 <__ieee754_sqrt+0xf0>
   29b5a:	4614      	mov	r4, r2
   29b5c:	4602      	mov	r2, r0
   29b5e:	40a8      	lsls	r0, r5
   29b60:	f1c5 0520 	rsb	r5, r5, #32
   29b64:	fa22 f505 	lsr.w	r5, r2, r5
   29b68:	eba3 0e01 	sub.w	lr, r3, r1
   29b6c:	ea45 0304 	orr.w	r3, r5, r4
   29b70:	e787      	b.n	29a82 <__ieee754_sqrt+0x22>
   29b72:	4313      	orrs	r3, r2
   29b74:	d10f      	bne.n	29b96 <__ieee754_sqrt+0x136>
   29b76:	087e      	lsrs	r6, r7, #1
   29b78:	491e      	ldr	r1, [pc, #120]	; (29bf4 <__ieee754_sqrt+0x194>)
   29b7a:	f01c 0f01 	tst.w	ip, #1
   29b7e:	eb01 016c 	add.w	r1, r1, ip, asr #1
   29b82:	bf18      	it	ne
   29b84:	f046 4600 	orrne.w	r6, r6, #2147483648	; 0x80000000
   29b88:	eb01 530e 	add.w	r3, r1, lr, lsl #20
   29b8c:	4632      	mov	r2, r6
   29b8e:	ec43 2b10 	vmov	d0, r2, r3
   29b92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   29b96:	1c7b      	adds	r3, r7, #1
   29b98:	d021      	beq.n	29bde <__ieee754_sqrt+0x17e>
   29b9a:	1c7e      	adds	r6, r7, #1
   29b9c:	0876      	lsrs	r6, r6, #1
   29b9e:	e7eb      	b.n	29b78 <__ieee754_sqrt+0x118>
   29ba0:	ee10 2a10 	vmov	r2, s0
   29ba4:	462b      	mov	r3, r5
   29ba6:	ee10 0a10 	vmov	r0, s0
   29baa:	4629      	mov	r1, r5
   29bac:	f7e2 fd04 	bl	c5b8 <__aeabi_dmul>
   29bb0:	4622      	mov	r2, r4
   29bb2:	462b      	mov	r3, r5
   29bb4:	f7e2 fb4a 	bl	c24c <__adddf3>
   29bb8:	ec41 0b10 	vmov	d0, r0, r1
   29bbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   29bc0:	ee10 2a10 	vmov	r2, s0
   29bc4:	4629      	mov	r1, r5
   29bc6:	f7e2 fb3f 	bl	c248 <__aeabi_dsub>
   29bca:	4602      	mov	r2, r0
   29bcc:	460b      	mov	r3, r1
   29bce:	f7e2 fe1d 	bl	c80c <__aeabi_ddiv>
   29bd2:	ec41 0b10 	vmov	d0, r0, r1
   29bd6:	e7dc      	b.n	29b92 <__ieee754_sqrt+0x132>
   29bd8:	462a      	mov	r2, r5
   29bda:	4673      	mov	r3, lr
   29bdc:	e7b6      	b.n	29b4c <__ieee754_sqrt+0xec>
   29bde:	f10c 0c01 	add.w	ip, ip, #1
   29be2:	e7c9      	b.n	29b78 <__ieee754_sqrt+0x118>
   29be4:	4602      	mov	r2, r0
   29be6:	2520      	movs	r5, #32
   29be8:	f04f 31ff 	mov.w	r1, #4294967295
   29bec:	e7ba      	b.n	29b64 <__ieee754_sqrt+0x104>
   29bee:	bf00      	nop
   29bf0:	7ff00000 	.word	0x7ff00000
   29bf4:	3fe00000 	.word	0x3fe00000

00029bf8 <finite>:
   29bf8:	ee10 3a90 	vmov	r3, s1
   29bfc:	4802      	ldr	r0, [pc, #8]	; (29c08 <finite+0x10>)
   29bfe:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   29c02:	4418      	add	r0, r3
   29c04:	0fc0      	lsrs	r0, r0, #31
   29c06:	4770      	bx	lr
   29c08:	80100000 	.word	0x80100000

00029c0c <rint>:
   29c0c:	ec53 2b10 	vmov	r2, r3, d0
   29c10:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   29c14:	f3c3 560a 	ubfx	r6, r3, #20, #11
   29c18:	b083      	sub	sp, #12
   29c1a:	4619      	mov	r1, r3
   29c1c:	ee10 5a10 	vmov	r5, s0
   29c20:	f2a6 30ff 	subw	r0, r6, #1023	; 0x3ff
   29c24:	0fdc      	lsrs	r4, r3, #31
   29c26:	2813      	cmp	r0, #19
   29c28:	dc38      	bgt.n	29c9c <rint+0x90>
   29c2a:	2800      	cmp	r0, #0
   29c2c:	db2d      	blt.n	29c8a <rint+0x7e>
   29c2e:	4e3f      	ldr	r6, [pc, #252]	; (29d2c <rint+0x120>)
   29c30:	4106      	asrs	r6, r0
   29c32:	ea03 0706 	and.w	r7, r3, r6
   29c36:	4317      	orrs	r7, r2
   29c38:	d02b      	beq.n	29c92 <rint+0x86>
   29c3a:	0876      	lsrs	r6, r6, #1
   29c3c:	4033      	ands	r3, r6
   29c3e:	431d      	orrs	r5, r3
   29c40:	d00b      	beq.n	29c5a <rint+0x4e>
   29c42:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   29c46:	2813      	cmp	r0, #19
   29c48:	ea21 0606 	bic.w	r6, r1, r6
   29c4c:	fa43 f100 	asr.w	r1, r3, r0
   29c50:	bf0c      	ite	eq
   29c52:	f04f 4500 	moveq.w	r5, #2147483648	; 0x80000000
   29c56:	2500      	movne	r5, #0
   29c58:	4331      	orrs	r1, r6
   29c5a:	4835      	ldr	r0, [pc, #212]	; (29d30 <rint+0x124>)
   29c5c:	462a      	mov	r2, r5
   29c5e:	460b      	mov	r3, r1
   29c60:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
   29c64:	e9d4 4500 	ldrd	r4, r5, [r4]
   29c68:	4620      	mov	r0, r4
   29c6a:	4629      	mov	r1, r5
   29c6c:	f7e2 faee 	bl	c24c <__adddf3>
   29c70:	4622      	mov	r2, r4
   29c72:	462b      	mov	r3, r5
   29c74:	e9cd 0100 	strd	r0, r1, [sp]
   29c78:	e9dd 0100 	ldrd	r0, r1, [sp]
   29c7c:	f7e2 fae4 	bl	c248 <__aeabi_dsub>
   29c80:	ec41 0b10 	vmov	d0, r0, r1
   29c84:	b003      	add	sp, #12
   29c86:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   29c8a:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
   29c8e:	4310      	orrs	r0, r2
   29c90:	d123      	bne.n	29cda <rint+0xce>
   29c92:	ec43 2b10 	vmov	d0, r2, r3
   29c96:	b003      	add	sp, #12
   29c98:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   29c9c:	2833      	cmp	r0, #51	; 0x33
   29c9e:	dd09      	ble.n	29cb4 <rint+0xa8>
   29ca0:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
   29ca4:	d1f5      	bne.n	29c92 <rint+0x86>
   29ca6:	ee10 0a10 	vmov	r0, s0
   29caa:	f7e2 facf 	bl	c24c <__adddf3>
   29cae:	ec41 0b10 	vmov	d0, r0, r1
   29cb2:	e7f0      	b.n	29c96 <rint+0x8a>
   29cb4:	f2a6 4613 	subw	r6, r6, #1043	; 0x413
   29cb8:	f04f 30ff 	mov.w	r0, #4294967295
   29cbc:	40f0      	lsrs	r0, r6
   29cbe:	4202      	tst	r2, r0
   29cc0:	d0e7      	beq.n	29c92 <rint+0x86>
   29cc2:	0840      	lsrs	r0, r0, #1
   29cc4:	4202      	tst	r2, r0
   29cc6:	d0c8      	beq.n	29c5a <rint+0x4e>
   29cc8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   29ccc:	ea25 0000 	bic.w	r0, r5, r0
   29cd0:	fa43 f606 	asr.w	r6, r3, r6
   29cd4:	ea40 0506 	orr.w	r5, r0, r6
   29cd8:	e7bf      	b.n	29c5a <rint+0x4e>
   29cda:	f3c3 0613 	ubfx	r6, r3, #0, #20
   29cde:	4815      	ldr	r0, [pc, #84]	; (29d34 <rint+0x128>)
   29ce0:	4a13      	ldr	r2, [pc, #76]	; (29d30 <rint+0x124>)
   29ce2:	4335      	orrs	r5, r6
   29ce4:	4018      	ands	r0, r3
   29ce6:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
   29cea:	426b      	negs	r3, r5
   29cec:	432b      	orrs	r3, r5
   29cee:	0b1b      	lsrs	r3, r3, #12
   29cf0:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
   29cf4:	e9d2 6700 	ldrd	r6, r7, [r2]
   29cf8:	ea43 0900 	orr.w	r9, r3, r0
   29cfc:	ee10 2a10 	vmov	r2, s0
   29d00:	4630      	mov	r0, r6
   29d02:	4639      	mov	r1, r7
   29d04:	464b      	mov	r3, r9
   29d06:	f7e2 faa1 	bl	c24c <__adddf3>
   29d0a:	463b      	mov	r3, r7
   29d0c:	4632      	mov	r2, r6
   29d0e:	e9cd 0100 	strd	r0, r1, [sp]
   29d12:	e9dd 0100 	ldrd	r0, r1, [sp]
   29d16:	f7e2 fa97 	bl	c248 <__aeabi_dsub>
   29d1a:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   29d1e:	ea43 71c4 	orr.w	r1, r3, r4, lsl #31
   29d22:	ec41 0b10 	vmov	d0, r0, r1
   29d26:	b003      	add	sp, #12
   29d28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   29d2c:	000fffff 	.word	0x000fffff
   29d30:	00030738 	.word	0x00030738
   29d34:	fffe0000 	.word	0xfffe0000

00029d38 <__assert_func>:
   29d38:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   29d3a:	461c      	mov	r4, r3
   29d3c:	4b09      	ldr	r3, [pc, #36]	; (29d64 <__assert_func+0x2c>)
   29d3e:	4605      	mov	r5, r0
   29d40:	681b      	ldr	r3, [r3, #0]
   29d42:	68d8      	ldr	r0, [r3, #12]
   29d44:	b152      	cbz	r2, 29d5c <__assert_func+0x24>
   29d46:	4b08      	ldr	r3, [pc, #32]	; (29d68 <__assert_func+0x30>)
   29d48:	9100      	str	r1, [sp, #0]
   29d4a:	4908      	ldr	r1, [pc, #32]	; (29d6c <__assert_func+0x34>)
   29d4c:	e9cd 3201 	strd	r3, r2, [sp, #4]
   29d50:	462b      	mov	r3, r5
   29d52:	4622      	mov	r2, r4
   29d54:	f000 f80e 	bl	29d74 <fiprintf>
   29d58:	f005 fd0d 	bl	2f776 <abort>
   29d5c:	4b04      	ldr	r3, [pc, #16]	; (29d70 <__assert_func+0x38>)
   29d5e:	461a      	mov	r2, r3
   29d60:	e7f2      	b.n	29d48 <__assert_func+0x10>
   29d62:	bf00      	nop
   29d64:	200383d4 	.word	0x200383d4
   29d68:	00034dd9 	.word	0x00034dd9
   29d6c:	00034de6 	.word	0x00034de6
   29d70:	00033244 	.word	0x00033244

00029d74 <fiprintf>:
   29d74:	b40e      	push	{r1, r2, r3}
   29d76:	b503      	push	{r0, r1, lr}
   29d78:	ab03      	add	r3, sp, #12
   29d7a:	4601      	mov	r1, r0
   29d7c:	4805      	ldr	r0, [pc, #20]	; (29d94 <fiprintf+0x20>)
   29d7e:	f853 2b04 	ldr.w	r2, [r3], #4
   29d82:	6800      	ldr	r0, [r0, #0]
   29d84:	9301      	str	r3, [sp, #4]
   29d86:	f000 f807 	bl	29d98 <_vfiprintf_r>
   29d8a:	b002      	add	sp, #8
   29d8c:	f85d eb04 	ldr.w	lr, [sp], #4
   29d90:	b003      	add	sp, #12
   29d92:	4770      	bx	lr
   29d94:	200383d4 	.word	0x200383d4

00029d98 <_vfiprintf_r>:
   29d98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   29d9c:	460d      	mov	r5, r1
   29d9e:	b09d      	sub	sp, #116	; 0x74
   29da0:	4614      	mov	r4, r2
   29da2:	461e      	mov	r6, r3
   29da4:	4607      	mov	r7, r0
   29da6:	b118      	cbz	r0, 29db0 <_vfiprintf_r+0x18>
   29da8:	6983      	ldr	r3, [r0, #24]
   29daa:	b90b      	cbnz	r3, 29db0 <_vfiprintf_r+0x18>
   29dac:	f000 ffc2 	bl	2ad34 <__sinit>
   29db0:	4b85      	ldr	r3, [pc, #532]	; (29fc8 <_vfiprintf_r+0x230>)
   29db2:	429d      	cmp	r5, r3
   29db4:	d11b      	bne.n	29dee <_vfiprintf_r+0x56>
   29db6:	687d      	ldr	r5, [r7, #4]
   29db8:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   29dba:	07d9      	lsls	r1, r3, #31
   29dbc:	d405      	bmi.n	29dca <_vfiprintf_r+0x32>
   29dbe:	89ab      	ldrh	r3, [r5, #12]
   29dc0:	059a      	lsls	r2, r3, #22
   29dc2:	d402      	bmi.n	29dca <_vfiprintf_r+0x32>
   29dc4:	6da8      	ldr	r0, [r5, #88]	; 0x58
   29dc6:	f005 fda0 	bl	2f90a <__retarget_lock_acquire_recursive>
   29dca:	89ab      	ldrh	r3, [r5, #12]
   29dcc:	071b      	lsls	r3, r3, #28
   29dce:	d501      	bpl.n	29dd4 <_vfiprintf_r+0x3c>
   29dd0:	692b      	ldr	r3, [r5, #16]
   29dd2:	b9eb      	cbnz	r3, 29e10 <_vfiprintf_r+0x78>
   29dd4:	4629      	mov	r1, r5
   29dd6:	4638      	mov	r0, r7
   29dd8:	f000 fe18 	bl	2aa0c <__swsetup_r>
   29ddc:	b1c0      	cbz	r0, 29e10 <_vfiprintf_r+0x78>
   29dde:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   29de0:	07d8      	lsls	r0, r3, #31
   29de2:	d50e      	bpl.n	29e02 <_vfiprintf_r+0x6a>
   29de4:	f04f 30ff 	mov.w	r0, #4294967295
   29de8:	b01d      	add	sp, #116	; 0x74
   29dea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   29dee:	4b77      	ldr	r3, [pc, #476]	; (29fcc <_vfiprintf_r+0x234>)
   29df0:	429d      	cmp	r5, r3
   29df2:	d101      	bne.n	29df8 <_vfiprintf_r+0x60>
   29df4:	68bd      	ldr	r5, [r7, #8]
   29df6:	e7df      	b.n	29db8 <_vfiprintf_r+0x20>
   29df8:	4b75      	ldr	r3, [pc, #468]	; (29fd0 <_vfiprintf_r+0x238>)
   29dfa:	429d      	cmp	r5, r3
   29dfc:	bf08      	it	eq
   29dfe:	68fd      	ldreq	r5, [r7, #12]
   29e00:	e7da      	b.n	29db8 <_vfiprintf_r+0x20>
   29e02:	89ab      	ldrh	r3, [r5, #12]
   29e04:	0599      	lsls	r1, r3, #22
   29e06:	d4ed      	bmi.n	29de4 <_vfiprintf_r+0x4c>
   29e08:	6da8      	ldr	r0, [r5, #88]	; 0x58
   29e0a:	f005 fd7f 	bl	2f90c <__retarget_lock_release_recursive>
   29e0e:	e7e9      	b.n	29de4 <_vfiprintf_r+0x4c>
   29e10:	2300      	movs	r3, #0
   29e12:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 29fd4 <_vfiprintf_r+0x23c>
   29e16:	f04f 0a01 	mov.w	sl, #1
   29e1a:	9603      	str	r6, [sp, #12]
   29e1c:	9309      	str	r3, [sp, #36]	; 0x24
   29e1e:	2320      	movs	r3, #32
   29e20:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   29e24:	2330      	movs	r3, #48	; 0x30
   29e26:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   29e2a:	4623      	mov	r3, r4
   29e2c:	461e      	mov	r6, r3
   29e2e:	f813 2b01 	ldrb.w	r2, [r3], #1
   29e32:	b10a      	cbz	r2, 29e38 <_vfiprintf_r+0xa0>
   29e34:	2a25      	cmp	r2, #37	; 0x25
   29e36:	d1f9      	bne.n	29e2c <_vfiprintf_r+0x94>
   29e38:	ebb6 0b04 	subs.w	fp, r6, r4
   29e3c:	d00b      	beq.n	29e56 <_vfiprintf_r+0xbe>
   29e3e:	465b      	mov	r3, fp
   29e40:	4622      	mov	r2, r4
   29e42:	4629      	mov	r1, r5
   29e44:	4638      	mov	r0, r7
   29e46:	f005 facd 	bl	2f3e4 <__sfputs_r>
   29e4a:	3001      	adds	r0, #1
   29e4c:	f000 80a3 	beq.w	29f96 <_vfiprintf_r+0x1fe>
   29e50:	9b09      	ldr	r3, [sp, #36]	; 0x24
   29e52:	445b      	add	r3, fp
   29e54:	9309      	str	r3, [sp, #36]	; 0x24
   29e56:	7833      	ldrb	r3, [r6, #0]
   29e58:	2b00      	cmp	r3, #0
   29e5a:	f000 809c 	beq.w	29f96 <_vfiprintf_r+0x1fe>
   29e5e:	2300      	movs	r3, #0
   29e60:	f04f 32ff 	mov.w	r2, #4294967295
   29e64:	3601      	adds	r6, #1
   29e66:	9304      	str	r3, [sp, #16]
   29e68:	9307      	str	r3, [sp, #28]
   29e6a:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   29e6e:	931a      	str	r3, [sp, #104]	; 0x68
   29e70:	e9cd 2305 	strd	r2, r3, [sp, #20]
   29e74:	4634      	mov	r4, r6
   29e76:	2205      	movs	r2, #5
   29e78:	4856      	ldr	r0, [pc, #344]	; (29fd4 <_vfiprintf_r+0x23c>)
   29e7a:	f814 1b01 	ldrb.w	r1, [r4], #1
   29e7e:	f005 fa4d 	bl	2f31c <memchr>
   29e82:	9b04      	ldr	r3, [sp, #16]
   29e84:	b9c0      	cbnz	r0, 29eb8 <_vfiprintf_r+0x120>
   29e86:	06da      	lsls	r2, r3, #27
   29e88:	bf44      	itt	mi
   29e8a:	2220      	movmi	r2, #32
   29e8c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   29e90:	0718      	lsls	r0, r3, #28
   29e92:	bf44      	itt	mi
   29e94:	222b      	movmi	r2, #43	; 0x2b
   29e96:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   29e9a:	7832      	ldrb	r2, [r6, #0]
   29e9c:	2a2a      	cmp	r2, #42	; 0x2a
   29e9e:	d013      	beq.n	29ec8 <_vfiprintf_r+0x130>
   29ea0:	4634      	mov	r4, r6
   29ea2:	9a07      	ldr	r2, [sp, #28]
   29ea4:	2000      	movs	r0, #0
   29ea6:	260a      	movs	r6, #10
   29ea8:	4621      	mov	r1, r4
   29eaa:	f811 3b01 	ldrb.w	r3, [r1], #1
   29eae:	3b30      	subs	r3, #48	; 0x30
   29eb0:	2b09      	cmp	r3, #9
   29eb2:	d94b      	bls.n	29f4c <_vfiprintf_r+0x1b4>
   29eb4:	b970      	cbnz	r0, 29ed4 <_vfiprintf_r+0x13c>
   29eb6:	e014      	b.n	29ee2 <_vfiprintf_r+0x14a>
   29eb8:	eba0 0009 	sub.w	r0, r0, r9
   29ebc:	4626      	mov	r6, r4
   29ebe:	fa0a f000 	lsl.w	r0, sl, r0
   29ec2:	4318      	orrs	r0, r3
   29ec4:	9004      	str	r0, [sp, #16]
   29ec6:	e7d5      	b.n	29e74 <_vfiprintf_r+0xdc>
   29ec8:	9a03      	ldr	r2, [sp, #12]
   29eca:	1d11      	adds	r1, r2, #4
   29ecc:	6812      	ldr	r2, [r2, #0]
   29ece:	2a00      	cmp	r2, #0
   29ed0:	9103      	str	r1, [sp, #12]
   29ed2:	db01      	blt.n	29ed8 <_vfiprintf_r+0x140>
   29ed4:	9207      	str	r2, [sp, #28]
   29ed6:	e004      	b.n	29ee2 <_vfiprintf_r+0x14a>
   29ed8:	4252      	negs	r2, r2
   29eda:	f043 0302 	orr.w	r3, r3, #2
   29ede:	9207      	str	r2, [sp, #28]
   29ee0:	9304      	str	r3, [sp, #16]
   29ee2:	7823      	ldrb	r3, [r4, #0]
   29ee4:	2b2e      	cmp	r3, #46	; 0x2e
   29ee6:	d10c      	bne.n	29f02 <_vfiprintf_r+0x16a>
   29ee8:	7863      	ldrb	r3, [r4, #1]
   29eea:	2b2a      	cmp	r3, #42	; 0x2a
   29eec:	d133      	bne.n	29f56 <_vfiprintf_r+0x1be>
   29eee:	9b03      	ldr	r3, [sp, #12]
   29ef0:	3402      	adds	r4, #2
   29ef2:	1d1a      	adds	r2, r3, #4
   29ef4:	681b      	ldr	r3, [r3, #0]
   29ef6:	2b00      	cmp	r3, #0
   29ef8:	9203      	str	r2, [sp, #12]
   29efa:	bfb8      	it	lt
   29efc:	f04f 33ff 	movlt.w	r3, #4294967295
   29f00:	9305      	str	r3, [sp, #20]
   29f02:	4e35      	ldr	r6, [pc, #212]	; (29fd8 <_vfiprintf_r+0x240>)
   29f04:	2203      	movs	r2, #3
   29f06:	7821      	ldrb	r1, [r4, #0]
   29f08:	4630      	mov	r0, r6
   29f0a:	f005 fa07 	bl	2f31c <memchr>
   29f0e:	b138      	cbz	r0, 29f20 <_vfiprintf_r+0x188>
   29f10:	2340      	movs	r3, #64	; 0x40
   29f12:	1b80      	subs	r0, r0, r6
   29f14:	3401      	adds	r4, #1
   29f16:	fa03 f000 	lsl.w	r0, r3, r0
   29f1a:	9b04      	ldr	r3, [sp, #16]
   29f1c:	4303      	orrs	r3, r0
   29f1e:	9304      	str	r3, [sp, #16]
   29f20:	f814 1b01 	ldrb.w	r1, [r4], #1
   29f24:	2206      	movs	r2, #6
   29f26:	482d      	ldr	r0, [pc, #180]	; (29fdc <_vfiprintf_r+0x244>)
   29f28:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   29f2c:	f005 f9f6 	bl	2f31c <memchr>
   29f30:	2800      	cmp	r0, #0
   29f32:	d03f      	beq.n	29fb4 <_vfiprintf_r+0x21c>
   29f34:	4b2a      	ldr	r3, [pc, #168]	; (29fe0 <_vfiprintf_r+0x248>)
   29f36:	bb13      	cbnz	r3, 29f7e <_vfiprintf_r+0x1e6>
   29f38:	9b03      	ldr	r3, [sp, #12]
   29f3a:	3307      	adds	r3, #7
   29f3c:	f023 0307 	bic.w	r3, r3, #7
   29f40:	3308      	adds	r3, #8
   29f42:	9303      	str	r3, [sp, #12]
   29f44:	9b09      	ldr	r3, [sp, #36]	; 0x24
   29f46:	4443      	add	r3, r8
   29f48:	9309      	str	r3, [sp, #36]	; 0x24
   29f4a:	e76e      	b.n	29e2a <_vfiprintf_r+0x92>
   29f4c:	fb06 3202 	mla	r2, r6, r2, r3
   29f50:	2001      	movs	r0, #1
   29f52:	460c      	mov	r4, r1
   29f54:	e7a8      	b.n	29ea8 <_vfiprintf_r+0x110>
   29f56:	2300      	movs	r3, #0
   29f58:	3401      	adds	r4, #1
   29f5a:	260a      	movs	r6, #10
   29f5c:	4619      	mov	r1, r3
   29f5e:	9305      	str	r3, [sp, #20]
   29f60:	4620      	mov	r0, r4
   29f62:	f810 2b01 	ldrb.w	r2, [r0], #1
   29f66:	3a30      	subs	r2, #48	; 0x30
   29f68:	2a09      	cmp	r2, #9
   29f6a:	d903      	bls.n	29f74 <_vfiprintf_r+0x1dc>
   29f6c:	2b00      	cmp	r3, #0
   29f6e:	d0c8      	beq.n	29f02 <_vfiprintf_r+0x16a>
   29f70:	9105      	str	r1, [sp, #20]
   29f72:	e7c6      	b.n	29f02 <_vfiprintf_r+0x16a>
   29f74:	fb06 2101 	mla	r1, r6, r1, r2
   29f78:	2301      	movs	r3, #1
   29f7a:	4604      	mov	r4, r0
   29f7c:	e7f0      	b.n	29f60 <_vfiprintf_r+0x1c8>
   29f7e:	ab03      	add	r3, sp, #12
   29f80:	462a      	mov	r2, r5
   29f82:	a904      	add	r1, sp, #16
   29f84:	4638      	mov	r0, r7
   29f86:	9300      	str	r3, [sp, #0]
   29f88:	4b16      	ldr	r3, [pc, #88]	; (29fe4 <_vfiprintf_r+0x24c>)
   29f8a:	f000 f82d 	bl	29fe8 <_printf_float>
   29f8e:	f1b0 3fff 	cmp.w	r0, #4294967295
   29f92:	4680      	mov	r8, r0
   29f94:	d1d6      	bne.n	29f44 <_vfiprintf_r+0x1ac>
   29f96:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   29f98:	07d9      	lsls	r1, r3, #31
   29f9a:	d405      	bmi.n	29fa8 <_vfiprintf_r+0x210>
   29f9c:	89ab      	ldrh	r3, [r5, #12]
   29f9e:	059a      	lsls	r2, r3, #22
   29fa0:	d402      	bmi.n	29fa8 <_vfiprintf_r+0x210>
   29fa2:	6da8      	ldr	r0, [r5, #88]	; 0x58
   29fa4:	f005 fcb2 	bl	2f90c <__retarget_lock_release_recursive>
   29fa8:	89ab      	ldrh	r3, [r5, #12]
   29faa:	065b      	lsls	r3, r3, #25
   29fac:	f53f af1a 	bmi.w	29de4 <_vfiprintf_r+0x4c>
   29fb0:	9809      	ldr	r0, [sp, #36]	; 0x24
   29fb2:	e719      	b.n	29de8 <_vfiprintf_r+0x50>
   29fb4:	ab03      	add	r3, sp, #12
   29fb6:	462a      	mov	r2, r5
   29fb8:	a904      	add	r1, sp, #16
   29fba:	4638      	mov	r0, r7
   29fbc:	9300      	str	r3, [sp, #0]
   29fbe:	4b09      	ldr	r3, [pc, #36]	; (29fe4 <_vfiprintf_r+0x24c>)
   29fc0:	f000 fa3c 	bl	2a43c <_printf_i>
   29fc4:	e7e3      	b.n	29f8e <_vfiprintf_r+0x1f6>
   29fc6:	bf00      	nop
   29fc8:	00030ee0 	.word	0x00030ee0
   29fcc:	00030f00 	.word	0x00030f00
   29fd0:	00030ec0 	.word	0x00030ec0
   29fd4:	00034f16 	.word	0x00034f16
   29fd8:	00034f1c 	.word	0x00034f1c
   29fdc:	00034f20 	.word	0x00034f20
   29fe0:	00029fe9 	.word	0x00029fe9
   29fe4:	0002f3e5 	.word	0x0002f3e5

00029fe8 <_printf_float>:
   29fe8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   29fec:	b08d      	sub	sp, #52	; 0x34
   29fee:	460c      	mov	r4, r1
   29ff0:	4616      	mov	r6, r2
   29ff2:	461f      	mov	r7, r3
   29ff4:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
   29ff8:	4605      	mov	r5, r0
   29ffa:	f000 ff19 	bl	2ae30 <_localeconv_r>
   29ffe:	6803      	ldr	r3, [r0, #0]
   2a000:	4618      	mov	r0, r3
   2a002:	9306      	str	r3, [sp, #24]
   2a004:	f7e2 ffa8 	bl	cf58 <strlen>
   2a008:	2300      	movs	r3, #0
   2a00a:	9007      	str	r0, [sp, #28]
   2a00c:	930a      	str	r3, [sp, #40]	; 0x28
   2a00e:	f8d8 3000 	ldr.w	r3, [r8]
   2a012:	f894 a018 	ldrb.w	sl, [r4, #24]
   2a016:	3307      	adds	r3, #7
   2a018:	f8d4 b000 	ldr.w	fp, [r4]
   2a01c:	f023 0307 	bic.w	r3, r3, #7
   2a020:	f103 0208 	add.w	r2, r3, #8
   2a024:	f8c8 2000 	str.w	r2, [r8]
   2a028:	e9d3 2300 	ldrd	r2, r3, [r3]
   2a02c:	e9c4 2312 	strd	r2, r3, [r4, #72]	; 0x48
   2a030:	ed94 7b12 	vldr	d7, [r4, #72]	; 0x48
   2a034:	f04f 32ff 	mov.w	r2, #4294967295
   2a038:	ed8d 7b04 	vstr	d7, [sp, #16]
   2a03c:	e9dd 8304 	ldrd	r8, r3, [sp, #16]
   2a040:	f023 4900 	bic.w	r9, r3, #2147483648	; 0x80000000
   2a044:	4640      	mov	r0, r8
   2a046:	4ba6      	ldr	r3, [pc, #664]	; (2a2e0 <_printf_float+0x2f8>)
   2a048:	4649      	mov	r1, r9
   2a04a:	f7e2 ff3d 	bl	cec8 <__aeabi_dcmpun>
   2a04e:	bb70      	cbnz	r0, 2a0ae <_printf_float+0xc6>
   2a050:	f04f 32ff 	mov.w	r2, #4294967295
   2a054:	4ba2      	ldr	r3, [pc, #648]	; (2a2e0 <_printf_float+0x2f8>)
   2a056:	4640      	mov	r0, r8
   2a058:	4649      	mov	r1, r9
   2a05a:	f7e2 fd29 	bl	cab0 <__aeabi_dcmple>
   2a05e:	bb30      	cbnz	r0, 2a0ae <_printf_float+0xc6>
   2a060:	2200      	movs	r2, #0
   2a062:	2300      	movs	r3, #0
   2a064:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   2a068:	f7e2 fd18 	bl	ca9c <__aeabi_dcmplt>
   2a06c:	b110      	cbz	r0, 2a074 <_printf_float+0x8c>
   2a06e:	232d      	movs	r3, #45	; 0x2d
   2a070:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   2a074:	4a9b      	ldr	r2, [pc, #620]	; (2a2e4 <_printf_float+0x2fc>)
   2a076:	4b9c      	ldr	r3, [pc, #624]	; (2a2e8 <_printf_float+0x300>)
   2a078:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
   2a07c:	bf94      	ite	ls
   2a07e:	4690      	movls	r8, r2
   2a080:	4698      	movhi	r8, r3
   2a082:	f04f 0900 	mov.w	r9, #0
   2a086:	2303      	movs	r3, #3
   2a088:	f02b 0204 	bic.w	r2, fp, #4
   2a08c:	6123      	str	r3, [r4, #16]
   2a08e:	6022      	str	r2, [r4, #0]
   2a090:	9700      	str	r7, [sp, #0]
   2a092:	4633      	mov	r3, r6
   2a094:	aa0b      	add	r2, sp, #44	; 0x2c
   2a096:	4621      	mov	r1, r4
   2a098:	4628      	mov	r0, r5
   2a09a:	f005 fa45 	bl	2f528 <_printf_common>
   2a09e:	3001      	adds	r0, #1
   2a0a0:	f040 808c 	bne.w	2a1bc <_printf_float+0x1d4>
   2a0a4:	f04f 30ff 	mov.w	r0, #4294967295
   2a0a8:	b00d      	add	sp, #52	; 0x34
   2a0aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2a0ae:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   2a0b2:	4610      	mov	r0, r2
   2a0b4:	4619      	mov	r1, r3
   2a0b6:	f7e2 ff07 	bl	cec8 <__aeabi_dcmpun>
   2a0ba:	b140      	cbz	r0, 2a0ce <_printf_float+0xe6>
   2a0bc:	9b05      	ldr	r3, [sp, #20]
   2a0be:	4a8b      	ldr	r2, [pc, #556]	; (2a2ec <_printf_float+0x304>)
   2a0c0:	2b00      	cmp	r3, #0
   2a0c2:	bfbc      	itt	lt
   2a0c4:	232d      	movlt	r3, #45	; 0x2d
   2a0c6:	f884 3043 	strblt.w	r3, [r4, #67]	; 0x43
   2a0ca:	4b89      	ldr	r3, [pc, #548]	; (2a2f0 <_printf_float+0x308>)
   2a0cc:	e7d4      	b.n	2a078 <_printf_float+0x90>
   2a0ce:	6863      	ldr	r3, [r4, #4]
   2a0d0:	f00a 09df 	and.w	r9, sl, #223	; 0xdf
   2a0d4:	1c5a      	adds	r2, r3, #1
   2a0d6:	d13e      	bne.n	2a156 <_printf_float+0x16e>
   2a0d8:	2306      	movs	r3, #6
   2a0da:	6063      	str	r3, [r4, #4]
   2a0dc:	2300      	movs	r3, #0
   2a0de:	f44b 6280 	orr.w	r2, fp, #1024	; 0x400
   2a0e2:	6861      	ldr	r1, [r4, #4]
   2a0e4:	4628      	mov	r0, r5
   2a0e6:	9303      	str	r3, [sp, #12]
   2a0e8:	ab0a      	add	r3, sp, #40	; 0x28
   2a0ea:	6022      	str	r2, [r4, #0]
   2a0ec:	e9cd a301 	strd	sl, r3, [sp, #4]
   2a0f0:	ab09      	add	r3, sp, #36	; 0x24
   2a0f2:	ed9d 0b04 	vldr	d0, [sp, #16]
   2a0f6:	9300      	str	r3, [sp, #0]
   2a0f8:	f10d 0323 	add.w	r3, sp, #35	; 0x23
   2a0fc:	f005 f984 	bl	2f408 <__cvt>
   2a100:	f1b9 0f47 	cmp.w	r9, #71	; 0x47
   2a104:	4680      	mov	r8, r0
   2a106:	9909      	ldr	r1, [sp, #36]	; 0x24
   2a108:	d108      	bne.n	2a11c <_printf_float+0x134>
   2a10a:	1cc8      	adds	r0, r1, #3
   2a10c:	db02      	blt.n	2a114 <_printf_float+0x12c>
   2a10e:	6863      	ldr	r3, [r4, #4]
   2a110:	4299      	cmp	r1, r3
   2a112:	dd41      	ble.n	2a198 <_printf_float+0x1b0>
   2a114:	f1aa 0a02 	sub.w	sl, sl, #2
   2a118:	fa5f fa8a 	uxtb.w	sl, sl
   2a11c:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
   2a120:	d820      	bhi.n	2a164 <_printf_float+0x17c>
   2a122:	3901      	subs	r1, #1
   2a124:	4652      	mov	r2, sl
   2a126:	f104 0050 	add.w	r0, r4, #80	; 0x50
   2a12a:	9109      	str	r1, [sp, #36]	; 0x24
   2a12c:	f005 f9c9 	bl	2f4c2 <__exponent>
   2a130:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   2a132:	4681      	mov	r9, r0
   2a134:	1813      	adds	r3, r2, r0
   2a136:	2a01      	cmp	r2, #1
   2a138:	6123      	str	r3, [r4, #16]
   2a13a:	dc02      	bgt.n	2a142 <_printf_float+0x15a>
   2a13c:	6822      	ldr	r2, [r4, #0]
   2a13e:	07d2      	lsls	r2, r2, #31
   2a140:	d501      	bpl.n	2a146 <_printf_float+0x15e>
   2a142:	3301      	adds	r3, #1
   2a144:	6123      	str	r3, [r4, #16]
   2a146:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
   2a14a:	2b00      	cmp	r3, #0
   2a14c:	d0a0      	beq.n	2a090 <_printf_float+0xa8>
   2a14e:	232d      	movs	r3, #45	; 0x2d
   2a150:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   2a154:	e79c      	b.n	2a090 <_printf_float+0xa8>
   2a156:	f1b9 0f47 	cmp.w	r9, #71	; 0x47
   2a15a:	d1bf      	bne.n	2a0dc <_printf_float+0xf4>
   2a15c:	2b00      	cmp	r3, #0
   2a15e:	d1bd      	bne.n	2a0dc <_printf_float+0xf4>
   2a160:	2301      	movs	r3, #1
   2a162:	e7ba      	b.n	2a0da <_printf_float+0xf2>
   2a164:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
   2a168:	d118      	bne.n	2a19c <_printf_float+0x1b4>
   2a16a:	2900      	cmp	r1, #0
   2a16c:	6863      	ldr	r3, [r4, #4]
   2a16e:	dd0b      	ble.n	2a188 <_printf_float+0x1a0>
   2a170:	6121      	str	r1, [r4, #16]
   2a172:	b913      	cbnz	r3, 2a17a <_printf_float+0x192>
   2a174:	6822      	ldr	r2, [r4, #0]
   2a176:	07d0      	lsls	r0, r2, #31
   2a178:	d502      	bpl.n	2a180 <_printf_float+0x198>
   2a17a:	3301      	adds	r3, #1
   2a17c:	440b      	add	r3, r1
   2a17e:	6123      	str	r3, [r4, #16]
   2a180:	65a1      	str	r1, [r4, #88]	; 0x58
   2a182:	f04f 0900 	mov.w	r9, #0
   2a186:	e7de      	b.n	2a146 <_printf_float+0x15e>
   2a188:	b913      	cbnz	r3, 2a190 <_printf_float+0x1a8>
   2a18a:	6822      	ldr	r2, [r4, #0]
   2a18c:	07d2      	lsls	r2, r2, #31
   2a18e:	d501      	bpl.n	2a194 <_printf_float+0x1ac>
   2a190:	3302      	adds	r3, #2
   2a192:	e7f4      	b.n	2a17e <_printf_float+0x196>
   2a194:	2301      	movs	r3, #1
   2a196:	e7f2      	b.n	2a17e <_printf_float+0x196>
   2a198:	f04f 0a67 	mov.w	sl, #103	; 0x67
   2a19c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2a19e:	4299      	cmp	r1, r3
   2a1a0:	db05      	blt.n	2a1ae <_printf_float+0x1c6>
   2a1a2:	6823      	ldr	r3, [r4, #0]
   2a1a4:	6121      	str	r1, [r4, #16]
   2a1a6:	07d8      	lsls	r0, r3, #31
   2a1a8:	d5ea      	bpl.n	2a180 <_printf_float+0x198>
   2a1aa:	1c4b      	adds	r3, r1, #1
   2a1ac:	e7e7      	b.n	2a17e <_printf_float+0x196>
   2a1ae:	2900      	cmp	r1, #0
   2a1b0:	bfd4      	ite	le
   2a1b2:	f1c1 0202 	rsble	r2, r1, #2
   2a1b6:	2201      	movgt	r2, #1
   2a1b8:	4413      	add	r3, r2
   2a1ba:	e7e0      	b.n	2a17e <_printf_float+0x196>
   2a1bc:	6823      	ldr	r3, [r4, #0]
   2a1be:	055a      	lsls	r2, r3, #21
   2a1c0:	d407      	bmi.n	2a1d2 <_printf_float+0x1ea>
   2a1c2:	6923      	ldr	r3, [r4, #16]
   2a1c4:	4642      	mov	r2, r8
   2a1c6:	4631      	mov	r1, r6
   2a1c8:	4628      	mov	r0, r5
   2a1ca:	47b8      	blx	r7
   2a1cc:	3001      	adds	r0, #1
   2a1ce:	d12b      	bne.n	2a228 <_printf_float+0x240>
   2a1d0:	e768      	b.n	2a0a4 <_printf_float+0xbc>
   2a1d2:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
   2a1d6:	f240 80dc 	bls.w	2a392 <_printf_float+0x3aa>
   2a1da:	2200      	movs	r2, #0
   2a1dc:	2300      	movs	r3, #0
   2a1de:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
   2a1e2:	f7e2 fc51 	bl	ca88 <__aeabi_dcmpeq>
   2a1e6:	2800      	cmp	r0, #0
   2a1e8:	d033      	beq.n	2a252 <_printf_float+0x26a>
   2a1ea:	2301      	movs	r3, #1
   2a1ec:	4a41      	ldr	r2, [pc, #260]	; (2a2f4 <_printf_float+0x30c>)
   2a1ee:	4631      	mov	r1, r6
   2a1f0:	4628      	mov	r0, r5
   2a1f2:	47b8      	blx	r7
   2a1f4:	3001      	adds	r0, #1
   2a1f6:	f43f af55 	beq.w	2a0a4 <_printf_float+0xbc>
   2a1fa:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   2a1fe:	429a      	cmp	r2, r3
   2a200:	db02      	blt.n	2a208 <_printf_float+0x220>
   2a202:	6823      	ldr	r3, [r4, #0]
   2a204:	07d8      	lsls	r0, r3, #31
   2a206:	d50f      	bpl.n	2a228 <_printf_float+0x240>
   2a208:	4631      	mov	r1, r6
   2a20a:	4628      	mov	r0, r5
   2a20c:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   2a210:	47b8      	blx	r7
   2a212:	3001      	adds	r0, #1
   2a214:	f43f af46 	beq.w	2a0a4 <_printf_float+0xbc>
   2a218:	f04f 0800 	mov.w	r8, #0
   2a21c:	f104 091a 	add.w	r9, r4, #26
   2a220:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2a222:	3b01      	subs	r3, #1
   2a224:	4543      	cmp	r3, r8
   2a226:	dc09      	bgt.n	2a23c <_printf_float+0x254>
   2a228:	6823      	ldr	r3, [r4, #0]
   2a22a:	079b      	lsls	r3, r3, #30
   2a22c:	f100 8101 	bmi.w	2a432 <_printf_float+0x44a>
   2a230:	68e0      	ldr	r0, [r4, #12]
   2a232:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   2a234:	4298      	cmp	r0, r3
   2a236:	bfb8      	it	lt
   2a238:	4618      	movlt	r0, r3
   2a23a:	e735      	b.n	2a0a8 <_printf_float+0xc0>
   2a23c:	2301      	movs	r3, #1
   2a23e:	464a      	mov	r2, r9
   2a240:	4631      	mov	r1, r6
   2a242:	4628      	mov	r0, r5
   2a244:	47b8      	blx	r7
   2a246:	3001      	adds	r0, #1
   2a248:	f43f af2c 	beq.w	2a0a4 <_printf_float+0xbc>
   2a24c:	f108 0801 	add.w	r8, r8, #1
   2a250:	e7e6      	b.n	2a220 <_printf_float+0x238>
   2a252:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2a254:	2b00      	cmp	r3, #0
   2a256:	dc2b      	bgt.n	2a2b0 <_printf_float+0x2c8>
   2a258:	2301      	movs	r3, #1
   2a25a:	4a26      	ldr	r2, [pc, #152]	; (2a2f4 <_printf_float+0x30c>)
   2a25c:	4631      	mov	r1, r6
   2a25e:	4628      	mov	r0, r5
   2a260:	47b8      	blx	r7
   2a262:	3001      	adds	r0, #1
   2a264:	f43f af1e 	beq.w	2a0a4 <_printf_float+0xbc>
   2a268:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   2a26c:	4313      	orrs	r3, r2
   2a26e:	d102      	bne.n	2a276 <_printf_float+0x28e>
   2a270:	6823      	ldr	r3, [r4, #0]
   2a272:	07d9      	lsls	r1, r3, #31
   2a274:	d5d8      	bpl.n	2a228 <_printf_float+0x240>
   2a276:	4631      	mov	r1, r6
   2a278:	4628      	mov	r0, r5
   2a27a:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   2a27e:	47b8      	blx	r7
   2a280:	3001      	adds	r0, #1
   2a282:	f43f af0f 	beq.w	2a0a4 <_printf_float+0xbc>
   2a286:	f04f 0900 	mov.w	r9, #0
   2a28a:	f104 0a1a 	add.w	sl, r4, #26
   2a28e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2a290:	425b      	negs	r3, r3
   2a292:	454b      	cmp	r3, r9
   2a294:	dc01      	bgt.n	2a29a <_printf_float+0x2b2>
   2a296:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2a298:	e794      	b.n	2a1c4 <_printf_float+0x1dc>
   2a29a:	2301      	movs	r3, #1
   2a29c:	4652      	mov	r2, sl
   2a29e:	4631      	mov	r1, r6
   2a2a0:	4628      	mov	r0, r5
   2a2a2:	47b8      	blx	r7
   2a2a4:	3001      	adds	r0, #1
   2a2a6:	f43f aefd 	beq.w	2a0a4 <_printf_float+0xbc>
   2a2aa:	f109 0901 	add.w	r9, r9, #1
   2a2ae:	e7ee      	b.n	2a28e <_printf_float+0x2a6>
   2a2b0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   2a2b2:	6da3      	ldr	r3, [r4, #88]	; 0x58
   2a2b4:	429a      	cmp	r2, r3
   2a2b6:	bfa8      	it	ge
   2a2b8:	461a      	movge	r2, r3
   2a2ba:	2a00      	cmp	r2, #0
   2a2bc:	4691      	mov	r9, r2
   2a2be:	dd07      	ble.n	2a2d0 <_printf_float+0x2e8>
   2a2c0:	4613      	mov	r3, r2
   2a2c2:	4631      	mov	r1, r6
   2a2c4:	4642      	mov	r2, r8
   2a2c6:	4628      	mov	r0, r5
   2a2c8:	47b8      	blx	r7
   2a2ca:	3001      	adds	r0, #1
   2a2cc:	f43f aeea 	beq.w	2a0a4 <_printf_float+0xbc>
   2a2d0:	f104 031a 	add.w	r3, r4, #26
   2a2d4:	f04f 0b00 	mov.w	fp, #0
   2a2d8:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
   2a2dc:	9304      	str	r3, [sp, #16]
   2a2de:	e015      	b.n	2a30c <_printf_float+0x324>
   2a2e0:	7fefffff 	.word	0x7fefffff
   2a2e4:	00034f27 	.word	0x00034f27
   2a2e8:	0003264b 	.word	0x0003264b
   2a2ec:	00034f2b 	.word	0x00034f2b
   2a2f0:	00034f2f 	.word	0x00034f2f
   2a2f4:	0003495a 	.word	0x0003495a
   2a2f8:	2301      	movs	r3, #1
   2a2fa:	9a04      	ldr	r2, [sp, #16]
   2a2fc:	4631      	mov	r1, r6
   2a2fe:	4628      	mov	r0, r5
   2a300:	47b8      	blx	r7
   2a302:	3001      	adds	r0, #1
   2a304:	f43f aece 	beq.w	2a0a4 <_printf_float+0xbc>
   2a308:	f10b 0b01 	add.w	fp, fp, #1
   2a30c:	f8d4 a058 	ldr.w	sl, [r4, #88]	; 0x58
   2a310:	ebaa 0309 	sub.w	r3, sl, r9
   2a314:	455b      	cmp	r3, fp
   2a316:	dcef      	bgt.n	2a2f8 <_printf_float+0x310>
   2a318:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   2a31c:	429a      	cmp	r2, r3
   2a31e:	db1b      	blt.n	2a358 <_printf_float+0x370>
   2a320:	6823      	ldr	r3, [r4, #0]
   2a322:	07da      	lsls	r2, r3, #31
   2a324:	d418      	bmi.n	2a358 <_printf_float+0x370>
   2a326:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   2a32a:	4592      	cmp	sl, r2
   2a32c:	db1c      	blt.n	2a368 <_printf_float+0x380>
   2a32e:	eba3 090a 	sub.w	r9, r3, sl
   2a332:	f1b9 0f00 	cmp.w	r9, #0
   2a336:	dd08      	ble.n	2a34a <_printf_float+0x362>
   2a338:	464b      	mov	r3, r9
   2a33a:	eb08 020a 	add.w	r2, r8, sl
   2a33e:	4631      	mov	r1, r6
   2a340:	4628      	mov	r0, r5
   2a342:	47b8      	blx	r7
   2a344:	3001      	adds	r0, #1
   2a346:	f43f aead 	beq.w	2a0a4 <_printf_float+0xbc>
   2a34a:	f04f 0800 	mov.w	r8, #0
   2a34e:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
   2a352:	f104 0a1a 	add.w	sl, r4, #26
   2a356:	e014      	b.n	2a382 <_printf_float+0x39a>
   2a358:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   2a35c:	4631      	mov	r1, r6
   2a35e:	4628      	mov	r0, r5
   2a360:	47b8      	blx	r7
   2a362:	3001      	adds	r0, #1
   2a364:	d1df      	bne.n	2a326 <_printf_float+0x33e>
   2a366:	e69d      	b.n	2a0a4 <_printf_float+0xbc>
   2a368:	eba3 0902 	sub.w	r9, r3, r2
   2a36c:	e7e1      	b.n	2a332 <_printf_float+0x34a>
   2a36e:	2301      	movs	r3, #1
   2a370:	4652      	mov	r2, sl
   2a372:	4631      	mov	r1, r6
   2a374:	4628      	mov	r0, r5
   2a376:	47b8      	blx	r7
   2a378:	3001      	adds	r0, #1
   2a37a:	f43f ae93 	beq.w	2a0a4 <_printf_float+0xbc>
   2a37e:	f108 0801 	add.w	r8, r8, #1
   2a382:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   2a386:	1a9b      	subs	r3, r3, r2
   2a388:	eba3 0309 	sub.w	r3, r3, r9
   2a38c:	4543      	cmp	r3, r8
   2a38e:	dcee      	bgt.n	2a36e <_printf_float+0x386>
   2a390:	e74a      	b.n	2a228 <_printf_float+0x240>
   2a392:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   2a394:	2a01      	cmp	r2, #1
   2a396:	dc01      	bgt.n	2a39c <_printf_float+0x3b4>
   2a398:	07db      	lsls	r3, r3, #31
   2a39a:	d537      	bpl.n	2a40c <_printf_float+0x424>
   2a39c:	2301      	movs	r3, #1
   2a39e:	4642      	mov	r2, r8
   2a3a0:	4631      	mov	r1, r6
   2a3a2:	4628      	mov	r0, r5
   2a3a4:	47b8      	blx	r7
   2a3a6:	3001      	adds	r0, #1
   2a3a8:	f43f ae7c 	beq.w	2a0a4 <_printf_float+0xbc>
   2a3ac:	4631      	mov	r1, r6
   2a3ae:	4628      	mov	r0, r5
   2a3b0:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   2a3b4:	47b8      	blx	r7
   2a3b6:	3001      	adds	r0, #1
   2a3b8:	f43f ae74 	beq.w	2a0a4 <_printf_float+0xbc>
   2a3bc:	2200      	movs	r2, #0
   2a3be:	2300      	movs	r3, #0
   2a3c0:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
   2a3c4:	f7e2 fb60 	bl	ca88 <__aeabi_dcmpeq>
   2a3c8:	b9d8      	cbnz	r0, 2a402 <_printf_float+0x41a>
   2a3ca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2a3cc:	f108 0201 	add.w	r2, r8, #1
   2a3d0:	3b01      	subs	r3, #1
   2a3d2:	4631      	mov	r1, r6
   2a3d4:	4628      	mov	r0, r5
   2a3d6:	47b8      	blx	r7
   2a3d8:	3001      	adds	r0, #1
   2a3da:	d10e      	bne.n	2a3fa <_printf_float+0x412>
   2a3dc:	e662      	b.n	2a0a4 <_printf_float+0xbc>
   2a3de:	2301      	movs	r3, #1
   2a3e0:	4652      	mov	r2, sl
   2a3e2:	4631      	mov	r1, r6
   2a3e4:	4628      	mov	r0, r5
   2a3e6:	47b8      	blx	r7
   2a3e8:	3001      	adds	r0, #1
   2a3ea:	f43f ae5b 	beq.w	2a0a4 <_printf_float+0xbc>
   2a3ee:	f108 0801 	add.w	r8, r8, #1
   2a3f2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2a3f4:	3b01      	subs	r3, #1
   2a3f6:	4543      	cmp	r3, r8
   2a3f8:	dcf1      	bgt.n	2a3de <_printf_float+0x3f6>
   2a3fa:	464b      	mov	r3, r9
   2a3fc:	f104 0250 	add.w	r2, r4, #80	; 0x50
   2a400:	e6e1      	b.n	2a1c6 <_printf_float+0x1de>
   2a402:	f04f 0800 	mov.w	r8, #0
   2a406:	f104 0a1a 	add.w	sl, r4, #26
   2a40a:	e7f2      	b.n	2a3f2 <_printf_float+0x40a>
   2a40c:	2301      	movs	r3, #1
   2a40e:	4642      	mov	r2, r8
   2a410:	e7df      	b.n	2a3d2 <_printf_float+0x3ea>
   2a412:	2301      	movs	r3, #1
   2a414:	464a      	mov	r2, r9
   2a416:	4631      	mov	r1, r6
   2a418:	4628      	mov	r0, r5
   2a41a:	47b8      	blx	r7
   2a41c:	3001      	adds	r0, #1
   2a41e:	f43f ae41 	beq.w	2a0a4 <_printf_float+0xbc>
   2a422:	f108 0801 	add.w	r8, r8, #1
   2a426:	68e3      	ldr	r3, [r4, #12]
   2a428:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   2a42a:	1a9b      	subs	r3, r3, r2
   2a42c:	4543      	cmp	r3, r8
   2a42e:	dcf0      	bgt.n	2a412 <_printf_float+0x42a>
   2a430:	e6fe      	b.n	2a230 <_printf_float+0x248>
   2a432:	f04f 0800 	mov.w	r8, #0
   2a436:	f104 0919 	add.w	r9, r4, #25
   2a43a:	e7f4      	b.n	2a426 <_printf_float+0x43e>

0002a43c <_printf_i>:
   2a43c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2a440:	4606      	mov	r6, r0
   2a442:	460c      	mov	r4, r1
   2a444:	f101 0043 	add.w	r0, r1, #67	; 0x43
   2a448:	7e09      	ldrb	r1, [r1, #24]
   2a44a:	b085      	sub	sp, #20
   2a44c:	4698      	mov	r8, r3
   2a44e:	296e      	cmp	r1, #110	; 0x6e
   2a450:	4617      	mov	r7, r2
   2a452:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   2a454:	f000 80ba 	beq.w	2a5cc <_printf_i+0x190>
   2a458:	d824      	bhi.n	2a4a4 <_printf_i+0x68>
   2a45a:	2963      	cmp	r1, #99	; 0x63
   2a45c:	d039      	beq.n	2a4d2 <_printf_i+0x96>
   2a45e:	d80a      	bhi.n	2a476 <_printf_i+0x3a>
   2a460:	2900      	cmp	r1, #0
   2a462:	f000 80c3 	beq.w	2a5ec <_printf_i+0x1b0>
   2a466:	2958      	cmp	r1, #88	; 0x58
   2a468:	f000 8091 	beq.w	2a58e <_printf_i+0x152>
   2a46c:	f104 0542 	add.w	r5, r4, #66	; 0x42
   2a470:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
   2a474:	e035      	b.n	2a4e2 <_printf_i+0xa6>
   2a476:	2964      	cmp	r1, #100	; 0x64
   2a478:	d001      	beq.n	2a47e <_printf_i+0x42>
   2a47a:	2969      	cmp	r1, #105	; 0x69
   2a47c:	d1f6      	bne.n	2a46c <_printf_i+0x30>
   2a47e:	6825      	ldr	r5, [r4, #0]
   2a480:	681a      	ldr	r2, [r3, #0]
   2a482:	f015 0f80 	tst.w	r5, #128	; 0x80
   2a486:	f102 0104 	add.w	r1, r2, #4
   2a48a:	d02c      	beq.n	2a4e6 <_printf_i+0xaa>
   2a48c:	6812      	ldr	r2, [r2, #0]
   2a48e:	6019      	str	r1, [r3, #0]
   2a490:	2a00      	cmp	r2, #0
   2a492:	da03      	bge.n	2a49c <_printf_i+0x60>
   2a494:	232d      	movs	r3, #45	; 0x2d
   2a496:	4252      	negs	r2, r2
   2a498:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   2a49c:	f8df c1bc 	ldr.w	ip, [pc, #444]	; 2a65c <_printf_i+0x220>
   2a4a0:	230a      	movs	r3, #10
   2a4a2:	e03f      	b.n	2a524 <_printf_i+0xe8>
   2a4a4:	2973      	cmp	r1, #115	; 0x73
   2a4a6:	f000 80a5 	beq.w	2a5f4 <_printf_i+0x1b8>
   2a4aa:	d808      	bhi.n	2a4be <_printf_i+0x82>
   2a4ac:	296f      	cmp	r1, #111	; 0x6f
   2a4ae:	d021      	beq.n	2a4f4 <_printf_i+0xb8>
   2a4b0:	2970      	cmp	r1, #112	; 0x70
   2a4b2:	d1db      	bne.n	2a46c <_printf_i+0x30>
   2a4b4:	6822      	ldr	r2, [r4, #0]
   2a4b6:	f042 0220 	orr.w	r2, r2, #32
   2a4ba:	6022      	str	r2, [r4, #0]
   2a4bc:	e003      	b.n	2a4c6 <_printf_i+0x8a>
   2a4be:	2975      	cmp	r1, #117	; 0x75
   2a4c0:	d018      	beq.n	2a4f4 <_printf_i+0xb8>
   2a4c2:	2978      	cmp	r1, #120	; 0x78
   2a4c4:	d1d2      	bne.n	2a46c <_printf_i+0x30>
   2a4c6:	2278      	movs	r2, #120	; 0x78
   2a4c8:	f8df c194 	ldr.w	ip, [pc, #404]	; 2a660 <_printf_i+0x224>
   2a4cc:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
   2a4d0:	e061      	b.n	2a596 <_printf_i+0x15a>
   2a4d2:	681a      	ldr	r2, [r3, #0]
   2a4d4:	f104 0542 	add.w	r5, r4, #66	; 0x42
   2a4d8:	1d11      	adds	r1, r2, #4
   2a4da:	6019      	str	r1, [r3, #0]
   2a4dc:	6813      	ldr	r3, [r2, #0]
   2a4de:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
   2a4e2:	2301      	movs	r3, #1
   2a4e4:	e093      	b.n	2a60e <_printf_i+0x1d2>
   2a4e6:	6812      	ldr	r2, [r2, #0]
   2a4e8:	f015 0f40 	tst.w	r5, #64	; 0x40
   2a4ec:	6019      	str	r1, [r3, #0]
   2a4ee:	bf18      	it	ne
   2a4f0:	b212      	sxthne	r2, r2
   2a4f2:	e7cd      	b.n	2a490 <_printf_i+0x54>
   2a4f4:	f8d4 c000 	ldr.w	ip, [r4]
   2a4f8:	681a      	ldr	r2, [r3, #0]
   2a4fa:	f01c 0f80 	tst.w	ip, #128	; 0x80
   2a4fe:	f102 0504 	add.w	r5, r2, #4
   2a502:	601d      	str	r5, [r3, #0]
   2a504:	d001      	beq.n	2a50a <_printf_i+0xce>
   2a506:	6812      	ldr	r2, [r2, #0]
   2a508:	e003      	b.n	2a512 <_printf_i+0xd6>
   2a50a:	f01c 0f40 	tst.w	ip, #64	; 0x40
   2a50e:	d0fa      	beq.n	2a506 <_printf_i+0xca>
   2a510:	8812      	ldrh	r2, [r2, #0]
   2a512:	296f      	cmp	r1, #111	; 0x6f
   2a514:	f8df c144 	ldr.w	ip, [pc, #324]	; 2a65c <_printf_i+0x220>
   2a518:	bf0c      	ite	eq
   2a51a:	2308      	moveq	r3, #8
   2a51c:	230a      	movne	r3, #10
   2a51e:	2100      	movs	r1, #0
   2a520:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
   2a524:	6865      	ldr	r5, [r4, #4]
   2a526:	2d00      	cmp	r5, #0
   2a528:	60a5      	str	r5, [r4, #8]
   2a52a:	bfa2      	ittt	ge
   2a52c:	6821      	ldrge	r1, [r4, #0]
   2a52e:	f021 0104 	bicge.w	r1, r1, #4
   2a532:	6021      	strge	r1, [r4, #0]
   2a534:	b90a      	cbnz	r2, 2a53a <_printf_i+0xfe>
   2a536:	2d00      	cmp	r5, #0
   2a538:	d046      	beq.n	2a5c8 <_printf_i+0x18c>
   2a53a:	4605      	mov	r5, r0
   2a53c:	4293      	cmp	r3, r2
   2a53e:	fbb2 f1f3 	udiv	r1, r2, r3
   2a542:	fb03 2e11 	mls	lr, r3, r1, r2
   2a546:	f81c e00e 	ldrb.w	lr, [ip, lr]
   2a54a:	f805 ed01 	strb.w	lr, [r5, #-1]!
   2a54e:	d939      	bls.n	2a5c4 <_printf_i+0x188>
   2a550:	2b08      	cmp	r3, #8
   2a552:	d10b      	bne.n	2a56c <_printf_i+0x130>
   2a554:	6823      	ldr	r3, [r4, #0]
   2a556:	07da      	lsls	r2, r3, #31
   2a558:	d508      	bpl.n	2a56c <_printf_i+0x130>
   2a55a:	6923      	ldr	r3, [r4, #16]
   2a55c:	6862      	ldr	r2, [r4, #4]
   2a55e:	429a      	cmp	r2, r3
   2a560:	bfde      	ittt	le
   2a562:	2330      	movle	r3, #48	; 0x30
   2a564:	f805 3c01 	strble.w	r3, [r5, #-1]
   2a568:	f105 35ff 	addle.w	r5, r5, #4294967295
   2a56c:	1b40      	subs	r0, r0, r5
   2a56e:	6120      	str	r0, [r4, #16]
   2a570:	f8cd 8000 	str.w	r8, [sp]
   2a574:	463b      	mov	r3, r7
   2a576:	aa03      	add	r2, sp, #12
   2a578:	4621      	mov	r1, r4
   2a57a:	4630      	mov	r0, r6
   2a57c:	f004 ffd4 	bl	2f528 <_printf_common>
   2a580:	3001      	adds	r0, #1
   2a582:	d149      	bne.n	2a618 <_printf_i+0x1dc>
   2a584:	f04f 30ff 	mov.w	r0, #4294967295
   2a588:	b005      	add	sp, #20
   2a58a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2a58e:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 2a65c <_printf_i+0x220>
   2a592:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
   2a596:	681d      	ldr	r5, [r3, #0]
   2a598:	6821      	ldr	r1, [r4, #0]
   2a59a:	f855 2b04 	ldr.w	r2, [r5], #4
   2a59e:	601d      	str	r5, [r3, #0]
   2a5a0:	060d      	lsls	r5, r1, #24
   2a5a2:	d50b      	bpl.n	2a5bc <_printf_i+0x180>
   2a5a4:	07cd      	lsls	r5, r1, #31
   2a5a6:	bf44      	itt	mi
   2a5a8:	f041 0120 	orrmi.w	r1, r1, #32
   2a5ac:	6021      	strmi	r1, [r4, #0]
   2a5ae:	b91a      	cbnz	r2, 2a5b8 <_printf_i+0x17c>
   2a5b0:	6823      	ldr	r3, [r4, #0]
   2a5b2:	f023 0320 	bic.w	r3, r3, #32
   2a5b6:	6023      	str	r3, [r4, #0]
   2a5b8:	2310      	movs	r3, #16
   2a5ba:	e7b0      	b.n	2a51e <_printf_i+0xe2>
   2a5bc:	064b      	lsls	r3, r1, #25
   2a5be:	bf48      	it	mi
   2a5c0:	b292      	uxthmi	r2, r2
   2a5c2:	e7ef      	b.n	2a5a4 <_printf_i+0x168>
   2a5c4:	460a      	mov	r2, r1
   2a5c6:	e7b9      	b.n	2a53c <_printf_i+0x100>
   2a5c8:	4605      	mov	r5, r0
   2a5ca:	e7c1      	b.n	2a550 <_printf_i+0x114>
   2a5cc:	681a      	ldr	r2, [r3, #0]
   2a5ce:	f8d4 c000 	ldr.w	ip, [r4]
   2a5d2:	1d15      	adds	r5, r2, #4
   2a5d4:	6961      	ldr	r1, [r4, #20]
   2a5d6:	f01c 0f80 	tst.w	ip, #128	; 0x80
   2a5da:	601d      	str	r5, [r3, #0]
   2a5dc:	6813      	ldr	r3, [r2, #0]
   2a5de:	d001      	beq.n	2a5e4 <_printf_i+0x1a8>
   2a5e0:	6019      	str	r1, [r3, #0]
   2a5e2:	e003      	b.n	2a5ec <_printf_i+0x1b0>
   2a5e4:	f01c 0f40 	tst.w	ip, #64	; 0x40
   2a5e8:	d0fa      	beq.n	2a5e0 <_printf_i+0x1a4>
   2a5ea:	8019      	strh	r1, [r3, #0]
   2a5ec:	2300      	movs	r3, #0
   2a5ee:	4605      	mov	r5, r0
   2a5f0:	6123      	str	r3, [r4, #16]
   2a5f2:	e7bd      	b.n	2a570 <_printf_i+0x134>
   2a5f4:	681a      	ldr	r2, [r3, #0]
   2a5f6:	1d11      	adds	r1, r2, #4
   2a5f8:	6019      	str	r1, [r3, #0]
   2a5fa:	2100      	movs	r1, #0
   2a5fc:	6815      	ldr	r5, [r2, #0]
   2a5fe:	6862      	ldr	r2, [r4, #4]
   2a600:	4628      	mov	r0, r5
   2a602:	f004 fe8b 	bl	2f31c <memchr>
   2a606:	b108      	cbz	r0, 2a60c <_printf_i+0x1d0>
   2a608:	1b40      	subs	r0, r0, r5
   2a60a:	6060      	str	r0, [r4, #4]
   2a60c:	6863      	ldr	r3, [r4, #4]
   2a60e:	6123      	str	r3, [r4, #16]
   2a610:	2300      	movs	r3, #0
   2a612:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   2a616:	e7ab      	b.n	2a570 <_printf_i+0x134>
   2a618:	6923      	ldr	r3, [r4, #16]
   2a61a:	462a      	mov	r2, r5
   2a61c:	4639      	mov	r1, r7
   2a61e:	4630      	mov	r0, r6
   2a620:	47c0      	blx	r8
   2a622:	3001      	adds	r0, #1
   2a624:	d0ae      	beq.n	2a584 <_printf_i+0x148>
   2a626:	6823      	ldr	r3, [r4, #0]
   2a628:	079b      	lsls	r3, r3, #30
   2a62a:	d413      	bmi.n	2a654 <_printf_i+0x218>
   2a62c:	68e0      	ldr	r0, [r4, #12]
   2a62e:	9b03      	ldr	r3, [sp, #12]
   2a630:	4298      	cmp	r0, r3
   2a632:	bfb8      	it	lt
   2a634:	4618      	movlt	r0, r3
   2a636:	e7a7      	b.n	2a588 <_printf_i+0x14c>
   2a638:	2301      	movs	r3, #1
   2a63a:	464a      	mov	r2, r9
   2a63c:	4639      	mov	r1, r7
   2a63e:	4630      	mov	r0, r6
   2a640:	47c0      	blx	r8
   2a642:	3001      	adds	r0, #1
   2a644:	d09e      	beq.n	2a584 <_printf_i+0x148>
   2a646:	3501      	adds	r5, #1
   2a648:	68e3      	ldr	r3, [r4, #12]
   2a64a:	9a03      	ldr	r2, [sp, #12]
   2a64c:	1a9b      	subs	r3, r3, r2
   2a64e:	42ab      	cmp	r3, r5
   2a650:	dcf2      	bgt.n	2a638 <_printf_i+0x1fc>
   2a652:	e7eb      	b.n	2a62c <_printf_i+0x1f0>
   2a654:	2500      	movs	r5, #0
   2a656:	f104 0919 	add.w	r9, r4, #25
   2a65a:	e7f5      	b.n	2a648 <_printf_i+0x20c>
   2a65c:	00034f33 	.word	0x00034f33
   2a660:	00034f44 	.word	0x00034f44

0002a664 <sniprintf>:
   2a664:	b40c      	push	{r2, r3}
   2a666:	4b18      	ldr	r3, [pc, #96]	; (2a6c8 <sniprintf+0x64>)
   2a668:	b530      	push	{r4, r5, lr}
   2a66a:	1e0c      	subs	r4, r1, #0
   2a66c:	b09d      	sub	sp, #116	; 0x74
   2a66e:	681d      	ldr	r5, [r3, #0]
   2a670:	da08      	bge.n	2a684 <sniprintf+0x20>
   2a672:	238b      	movs	r3, #139	; 0x8b
   2a674:	f04f 30ff 	mov.w	r0, #4294967295
   2a678:	602b      	str	r3, [r5, #0]
   2a67a:	b01d      	add	sp, #116	; 0x74
   2a67c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   2a680:	b002      	add	sp, #8
   2a682:	4770      	bx	lr
   2a684:	f44f 7302 	mov.w	r3, #520	; 0x208
   2a688:	9002      	str	r0, [sp, #8]
   2a68a:	9006      	str	r0, [sp, #24]
   2a68c:	a902      	add	r1, sp, #8
   2a68e:	f8ad 3014 	strh.w	r3, [sp, #20]
   2a692:	bf14      	ite	ne
   2a694:	f104 33ff 	addne.w	r3, r4, #4294967295
   2a698:	4623      	moveq	r3, r4
   2a69a:	9a20      	ldr	r2, [sp, #128]	; 0x80
   2a69c:	4628      	mov	r0, r5
   2a69e:	9304      	str	r3, [sp, #16]
   2a6a0:	9307      	str	r3, [sp, #28]
   2a6a2:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2a6a6:	f8ad 3016 	strh.w	r3, [sp, #22]
   2a6aa:	ab21      	add	r3, sp, #132	; 0x84
   2a6ac:	9301      	str	r3, [sp, #4]
   2a6ae:	f000 fd01 	bl	2b0b4 <_svfiprintf_r>
   2a6b2:	1c43      	adds	r3, r0, #1
   2a6b4:	bfbc      	itt	lt
   2a6b6:	238b      	movlt	r3, #139	; 0x8b
   2a6b8:	602b      	strlt	r3, [r5, #0]
   2a6ba:	2c00      	cmp	r4, #0
   2a6bc:	d0dd      	beq.n	2a67a <sniprintf+0x16>
   2a6be:	9b02      	ldr	r3, [sp, #8]
   2a6c0:	2200      	movs	r2, #0
   2a6c2:	701a      	strb	r2, [r3, #0]
   2a6c4:	e7d9      	b.n	2a67a <sniprintf+0x16>
   2a6c6:	bf00      	nop
   2a6c8:	200383d4 	.word	0x200383d4

0002a6cc <siprintf>:
   2a6cc:	b40e      	push	{r1, r2, r3}
   2a6ce:	b500      	push	{lr}
   2a6d0:	b09c      	sub	sp, #112	; 0x70
   2a6d2:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   2a6d6:	ab1d      	add	r3, sp, #116	; 0x74
   2a6d8:	9002      	str	r0, [sp, #8]
   2a6da:	9006      	str	r0, [sp, #24]
   2a6dc:	9107      	str	r1, [sp, #28]
   2a6de:	9104      	str	r1, [sp, #16]
   2a6e0:	4808      	ldr	r0, [pc, #32]	; (2a704 <siprintf+0x38>)
   2a6e2:	4909      	ldr	r1, [pc, #36]	; (2a708 <siprintf+0x3c>)
   2a6e4:	f853 2b04 	ldr.w	r2, [r3], #4
   2a6e8:	9105      	str	r1, [sp, #20]
   2a6ea:	a902      	add	r1, sp, #8
   2a6ec:	6800      	ldr	r0, [r0, #0]
   2a6ee:	9301      	str	r3, [sp, #4]
   2a6f0:	f000 fce0 	bl	2b0b4 <_svfiprintf_r>
   2a6f4:	9b02      	ldr	r3, [sp, #8]
   2a6f6:	2200      	movs	r2, #0
   2a6f8:	701a      	strb	r2, [r3, #0]
   2a6fa:	b01c      	add	sp, #112	; 0x70
   2a6fc:	f85d eb04 	ldr.w	lr, [sp], #4
   2a700:	b003      	add	sp, #12
   2a702:	4770      	bx	lr
   2a704:	200383d4 	.word	0x200383d4
   2a708:	ffff0208 	.word	0xffff0208

0002a70c <_strtol_l.isra.0>:
   2a70c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2a710:	4686      	mov	lr, r0
   2a712:	4f39      	ldr	r7, [pc, #228]	; (2a7f8 <_strtol_l.isra.0+0xec>)
   2a714:	4608      	mov	r0, r1
   2a716:	4605      	mov	r5, r0
   2a718:	f815 4b01 	ldrb.w	r4, [r5], #1
   2a71c:	5de6      	ldrb	r6, [r4, r7]
   2a71e:	f016 0608 	ands.w	r6, r6, #8
   2a722:	d135      	bne.n	2a790 <_strtol_l.isra.0+0x84>
   2a724:	2c2d      	cmp	r4, #45	; 0x2d
   2a726:	d135      	bne.n	2a794 <_strtol_l.isra.0+0x88>
   2a728:	782c      	ldrb	r4, [r5, #0]
   2a72a:	f04f 0801 	mov.w	r8, #1
   2a72e:	1c85      	adds	r5, r0, #2
   2a730:	2b00      	cmp	r3, #0
   2a732:	d05c      	beq.n	2a7ee <_strtol_l.isra.0+0xe2>
   2a734:	2b10      	cmp	r3, #16
   2a736:	d109      	bne.n	2a74c <_strtol_l.isra.0+0x40>
   2a738:	2c30      	cmp	r4, #48	; 0x30
   2a73a:	d107      	bne.n	2a74c <_strtol_l.isra.0+0x40>
   2a73c:	7828      	ldrb	r0, [r5, #0]
   2a73e:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   2a742:	2858      	cmp	r0, #88	; 0x58
   2a744:	d14e      	bne.n	2a7e4 <_strtol_l.isra.0+0xd8>
   2a746:	786c      	ldrb	r4, [r5, #1]
   2a748:	2310      	movs	r3, #16
   2a74a:	3502      	adds	r5, #2
   2a74c:	f1b8 0f00 	cmp.w	r8, #0
   2a750:	f04f 0700 	mov.w	r7, #0
   2a754:	bf14      	ite	ne
   2a756:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
   2a75a:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
   2a75e:	4638      	mov	r0, r7
   2a760:	fbbc f9f3 	udiv	r9, ip, r3
   2a764:	fb03 ca19 	mls	sl, r3, r9, ip
   2a768:	f1a4 0630 	sub.w	r6, r4, #48	; 0x30
   2a76c:	2e09      	cmp	r6, #9
   2a76e:	d817      	bhi.n	2a7a0 <_strtol_l.isra.0+0x94>
   2a770:	4634      	mov	r4, r6
   2a772:	42a3      	cmp	r3, r4
   2a774:	dd23      	ble.n	2a7be <_strtol_l.isra.0+0xb2>
   2a776:	1c7e      	adds	r6, r7, #1
   2a778:	d007      	beq.n	2a78a <_strtol_l.isra.0+0x7e>
   2a77a:	4581      	cmp	r9, r0
   2a77c:	d31c      	bcc.n	2a7b8 <_strtol_l.isra.0+0xac>
   2a77e:	d101      	bne.n	2a784 <_strtol_l.isra.0+0x78>
   2a780:	45a2      	cmp	sl, r4
   2a782:	db19      	blt.n	2a7b8 <_strtol_l.isra.0+0xac>
   2a784:	fb00 4003 	mla	r0, r0, r3, r4
   2a788:	2701      	movs	r7, #1
   2a78a:	f815 4b01 	ldrb.w	r4, [r5], #1
   2a78e:	e7eb      	b.n	2a768 <_strtol_l.isra.0+0x5c>
   2a790:	4628      	mov	r0, r5
   2a792:	e7c0      	b.n	2a716 <_strtol_l.isra.0+0xa>
   2a794:	2c2b      	cmp	r4, #43	; 0x2b
   2a796:	46b0      	mov	r8, r6
   2a798:	bf04      	itt	eq
   2a79a:	782c      	ldrbeq	r4, [r5, #0]
   2a79c:	1c85      	addeq	r5, r0, #2
   2a79e:	e7c7      	b.n	2a730 <_strtol_l.isra.0+0x24>
   2a7a0:	f1a4 0641 	sub.w	r6, r4, #65	; 0x41
   2a7a4:	2e19      	cmp	r6, #25
   2a7a6:	d801      	bhi.n	2a7ac <_strtol_l.isra.0+0xa0>
   2a7a8:	3c37      	subs	r4, #55	; 0x37
   2a7aa:	e7e2      	b.n	2a772 <_strtol_l.isra.0+0x66>
   2a7ac:	f1a4 0661 	sub.w	r6, r4, #97	; 0x61
   2a7b0:	2e19      	cmp	r6, #25
   2a7b2:	d804      	bhi.n	2a7be <_strtol_l.isra.0+0xb2>
   2a7b4:	3c57      	subs	r4, #87	; 0x57
   2a7b6:	e7dc      	b.n	2a772 <_strtol_l.isra.0+0x66>
   2a7b8:	f04f 37ff 	mov.w	r7, #4294967295
   2a7bc:	e7e5      	b.n	2a78a <_strtol_l.isra.0+0x7e>
   2a7be:	1c7b      	adds	r3, r7, #1
   2a7c0:	d106      	bne.n	2a7d0 <_strtol_l.isra.0+0xc4>
   2a7c2:	2322      	movs	r3, #34	; 0x22
   2a7c4:	4660      	mov	r0, ip
   2a7c6:	f8ce 3000 	str.w	r3, [lr]
   2a7ca:	b942      	cbnz	r2, 2a7de <_strtol_l.isra.0+0xd2>
   2a7cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2a7d0:	f1b8 0f00 	cmp.w	r8, #0
   2a7d4:	d000      	beq.n	2a7d8 <_strtol_l.isra.0+0xcc>
   2a7d6:	4240      	negs	r0, r0
   2a7d8:	2a00      	cmp	r2, #0
   2a7da:	d0f7      	beq.n	2a7cc <_strtol_l.isra.0+0xc0>
   2a7dc:	b107      	cbz	r7, 2a7e0 <_strtol_l.isra.0+0xd4>
   2a7de:	1e69      	subs	r1, r5, #1
   2a7e0:	6011      	str	r1, [r2, #0]
   2a7e2:	e7f3      	b.n	2a7cc <_strtol_l.isra.0+0xc0>
   2a7e4:	2430      	movs	r4, #48	; 0x30
   2a7e6:	2b00      	cmp	r3, #0
   2a7e8:	d1b0      	bne.n	2a74c <_strtol_l.isra.0+0x40>
   2a7ea:	2308      	movs	r3, #8
   2a7ec:	e7ae      	b.n	2a74c <_strtol_l.isra.0+0x40>
   2a7ee:	2c30      	cmp	r4, #48	; 0x30
   2a7f0:	d0a4      	beq.n	2a73c <_strtol_l.isra.0+0x30>
   2a7f2:	230a      	movs	r3, #10
   2a7f4:	e7aa      	b.n	2a74c <_strtol_l.isra.0+0x40>
   2a7f6:	bf00      	nop
   2a7f8:	00034e16 	.word	0x00034e16

0002a7fc <strtol>:
   2a7fc:	4613      	mov	r3, r2
   2a7fe:	460a      	mov	r2, r1
   2a800:	4601      	mov	r1, r0
   2a802:	4802      	ldr	r0, [pc, #8]	; (2a80c <strtol+0x10>)
   2a804:	6800      	ldr	r0, [r0, #0]
   2a806:	f7ff bf81 	b.w	2a70c <_strtol_l.isra.0>
   2a80a:	bf00      	nop
   2a80c:	200383d4 	.word	0x200383d4

0002a810 <_strtoul_l.isra.0>:
   2a810:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2a814:	4686      	mov	lr, r0
   2a816:	4f37      	ldr	r7, [pc, #220]	; (2a8f4 <_strtoul_l.isra.0+0xe4>)
   2a818:	4608      	mov	r0, r1
   2a81a:	4605      	mov	r5, r0
   2a81c:	f815 4b01 	ldrb.w	r4, [r5], #1
   2a820:	5de6      	ldrb	r6, [r4, r7]
   2a822:	f016 0608 	ands.w	r6, r6, #8
   2a826:	d131      	bne.n	2a88c <_strtoul_l.isra.0+0x7c>
   2a828:	2c2d      	cmp	r4, #45	; 0x2d
   2a82a:	d131      	bne.n	2a890 <_strtoul_l.isra.0+0x80>
   2a82c:	782c      	ldrb	r4, [r5, #0]
   2a82e:	f04f 0801 	mov.w	r8, #1
   2a832:	1c85      	adds	r5, r0, #2
   2a834:	2b00      	cmp	r3, #0
   2a836:	d059      	beq.n	2a8ec <_strtoul_l.isra.0+0xdc>
   2a838:	2b10      	cmp	r3, #16
   2a83a:	d109      	bne.n	2a850 <_strtoul_l.isra.0+0x40>
   2a83c:	2c30      	cmp	r4, #48	; 0x30
   2a83e:	d107      	bne.n	2a850 <_strtoul_l.isra.0+0x40>
   2a840:	7828      	ldrb	r0, [r5, #0]
   2a842:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   2a846:	2858      	cmp	r0, #88	; 0x58
   2a848:	d14b      	bne.n	2a8e2 <_strtoul_l.isra.0+0xd2>
   2a84a:	786c      	ldrb	r4, [r5, #1]
   2a84c:	2310      	movs	r3, #16
   2a84e:	3502      	adds	r5, #2
   2a850:	f04f 3cff 	mov.w	ip, #4294967295
   2a854:	2600      	movs	r6, #0
   2a856:	fbbc fcf3 	udiv	ip, ip, r3
   2a85a:	fb03 f90c 	mul.w	r9, r3, ip
   2a85e:	4630      	mov	r0, r6
   2a860:	ea6f 0909 	mvn.w	r9, r9
   2a864:	f1a4 0730 	sub.w	r7, r4, #48	; 0x30
   2a868:	2f09      	cmp	r7, #9
   2a86a:	d817      	bhi.n	2a89c <_strtoul_l.isra.0+0x8c>
   2a86c:	463c      	mov	r4, r7
   2a86e:	42a3      	cmp	r3, r4
   2a870:	dd23      	ble.n	2a8ba <_strtoul_l.isra.0+0xaa>
   2a872:	2e00      	cmp	r6, #0
   2a874:	db1e      	blt.n	2a8b4 <_strtoul_l.isra.0+0xa4>
   2a876:	4584      	cmp	ip, r0
   2a878:	d31c      	bcc.n	2a8b4 <_strtoul_l.isra.0+0xa4>
   2a87a:	d101      	bne.n	2a880 <_strtoul_l.isra.0+0x70>
   2a87c:	45a1      	cmp	r9, r4
   2a87e:	db19      	blt.n	2a8b4 <_strtoul_l.isra.0+0xa4>
   2a880:	fb00 4003 	mla	r0, r0, r3, r4
   2a884:	2601      	movs	r6, #1
   2a886:	f815 4b01 	ldrb.w	r4, [r5], #1
   2a88a:	e7eb      	b.n	2a864 <_strtoul_l.isra.0+0x54>
   2a88c:	4628      	mov	r0, r5
   2a88e:	e7c4      	b.n	2a81a <_strtoul_l.isra.0+0xa>
   2a890:	2c2b      	cmp	r4, #43	; 0x2b
   2a892:	46b0      	mov	r8, r6
   2a894:	bf04      	itt	eq
   2a896:	782c      	ldrbeq	r4, [r5, #0]
   2a898:	1c85      	addeq	r5, r0, #2
   2a89a:	e7cb      	b.n	2a834 <_strtoul_l.isra.0+0x24>
   2a89c:	f1a4 0741 	sub.w	r7, r4, #65	; 0x41
   2a8a0:	2f19      	cmp	r7, #25
   2a8a2:	d801      	bhi.n	2a8a8 <_strtoul_l.isra.0+0x98>
   2a8a4:	3c37      	subs	r4, #55	; 0x37
   2a8a6:	e7e2      	b.n	2a86e <_strtoul_l.isra.0+0x5e>
   2a8a8:	f1a4 0761 	sub.w	r7, r4, #97	; 0x61
   2a8ac:	2f19      	cmp	r7, #25
   2a8ae:	d804      	bhi.n	2a8ba <_strtoul_l.isra.0+0xaa>
   2a8b0:	3c57      	subs	r4, #87	; 0x57
   2a8b2:	e7dc      	b.n	2a86e <_strtoul_l.isra.0+0x5e>
   2a8b4:	f04f 36ff 	mov.w	r6, #4294967295
   2a8b8:	e7e5      	b.n	2a886 <_strtoul_l.isra.0+0x76>
   2a8ba:	2e00      	cmp	r6, #0
   2a8bc:	da07      	bge.n	2a8ce <_strtoul_l.isra.0+0xbe>
   2a8be:	2322      	movs	r3, #34	; 0x22
   2a8c0:	f04f 30ff 	mov.w	r0, #4294967295
   2a8c4:	f8ce 3000 	str.w	r3, [lr]
   2a8c8:	b942      	cbnz	r2, 2a8dc <_strtoul_l.isra.0+0xcc>
   2a8ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2a8ce:	f1b8 0f00 	cmp.w	r8, #0
   2a8d2:	d000      	beq.n	2a8d6 <_strtoul_l.isra.0+0xc6>
   2a8d4:	4240      	negs	r0, r0
   2a8d6:	2a00      	cmp	r2, #0
   2a8d8:	d0f7      	beq.n	2a8ca <_strtoul_l.isra.0+0xba>
   2a8da:	b106      	cbz	r6, 2a8de <_strtoul_l.isra.0+0xce>
   2a8dc:	1e69      	subs	r1, r5, #1
   2a8de:	6011      	str	r1, [r2, #0]
   2a8e0:	e7f3      	b.n	2a8ca <_strtoul_l.isra.0+0xba>
   2a8e2:	2430      	movs	r4, #48	; 0x30
   2a8e4:	2b00      	cmp	r3, #0
   2a8e6:	d1b3      	bne.n	2a850 <_strtoul_l.isra.0+0x40>
   2a8e8:	2308      	movs	r3, #8
   2a8ea:	e7b1      	b.n	2a850 <_strtoul_l.isra.0+0x40>
   2a8ec:	2c30      	cmp	r4, #48	; 0x30
   2a8ee:	d0a7      	beq.n	2a840 <_strtoul_l.isra.0+0x30>
   2a8f0:	230a      	movs	r3, #10
   2a8f2:	e7ad      	b.n	2a850 <_strtoul_l.isra.0+0x40>
   2a8f4:	00034e16 	.word	0x00034e16

0002a8f8 <strtoul>:
   2a8f8:	4613      	mov	r3, r2
   2a8fa:	460a      	mov	r2, r1
   2a8fc:	4601      	mov	r1, r0
   2a8fe:	4802      	ldr	r0, [pc, #8]	; (2a908 <strtoul+0x10>)
   2a900:	6800      	ldr	r0, [r0, #0]
   2a902:	f7ff bf85 	b.w	2a810 <_strtoul_l.isra.0>
   2a906:	bf00      	nop
   2a908:	200383d4 	.word	0x200383d4

0002a90c <vsniprintf>:
   2a90c:	b507      	push	{r0, r1, r2, lr}
   2a90e:	9300      	str	r3, [sp, #0]
   2a910:	4613      	mov	r3, r2
   2a912:	460a      	mov	r2, r1
   2a914:	4601      	mov	r1, r0
   2a916:	4803      	ldr	r0, [pc, #12]	; (2a924 <vsniprintf+0x18>)
   2a918:	6800      	ldr	r0, [r0, #0]
   2a91a:	f004 ff00 	bl	2f71e <_vsniprintf_r>
   2a91e:	b003      	add	sp, #12
   2a920:	f85d fb04 	ldr.w	pc, [sp], #4
   2a924:	200383d4 	.word	0x200383d4

0002a928 <_vsiprintf_r>:
   2a928:	b500      	push	{lr}
   2a92a:	b09b      	sub	sp, #108	; 0x6c
   2a92c:	9100      	str	r1, [sp, #0]
   2a92e:	9104      	str	r1, [sp, #16]
   2a930:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   2a934:	9105      	str	r1, [sp, #20]
   2a936:	9102      	str	r1, [sp, #8]
   2a938:	4905      	ldr	r1, [pc, #20]	; (2a950 <_vsiprintf_r+0x28>)
   2a93a:	9103      	str	r1, [sp, #12]
   2a93c:	4669      	mov	r1, sp
   2a93e:	f000 fbb9 	bl	2b0b4 <_svfiprintf_r>
   2a942:	9b00      	ldr	r3, [sp, #0]
   2a944:	2200      	movs	r2, #0
   2a946:	701a      	strb	r2, [r3, #0]
   2a948:	b01b      	add	sp, #108	; 0x6c
   2a94a:	f85d fb04 	ldr.w	pc, [sp], #4
   2a94e:	bf00      	nop
   2a950:	ffff0208 	.word	0xffff0208

0002a954 <vsiprintf>:
   2a954:	4613      	mov	r3, r2
   2a956:	460a      	mov	r2, r1
   2a958:	4601      	mov	r1, r0
   2a95a:	4802      	ldr	r0, [pc, #8]	; (2a964 <vsiprintf+0x10>)
   2a95c:	6800      	ldr	r0, [r0, #0]
   2a95e:	f7ff bfe3 	b.w	2a928 <_vsiprintf_r>
   2a962:	bf00      	nop
   2a964:	200383d4 	.word	0x200383d4

0002a968 <__swbuf_r>:
   2a968:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2a96a:	460e      	mov	r6, r1
   2a96c:	4614      	mov	r4, r2
   2a96e:	4605      	mov	r5, r0
   2a970:	b118      	cbz	r0, 2a97a <__swbuf_r+0x12>
   2a972:	6983      	ldr	r3, [r0, #24]
   2a974:	b90b      	cbnz	r3, 2a97a <__swbuf_r+0x12>
   2a976:	f000 f9dd 	bl	2ad34 <__sinit>
   2a97a:	4b21      	ldr	r3, [pc, #132]	; (2aa00 <__swbuf_r+0x98>)
   2a97c:	429c      	cmp	r4, r3
   2a97e:	d12b      	bne.n	2a9d8 <__swbuf_r+0x70>
   2a980:	686c      	ldr	r4, [r5, #4]
   2a982:	69a3      	ldr	r3, [r4, #24]
   2a984:	60a3      	str	r3, [r4, #8]
   2a986:	89a3      	ldrh	r3, [r4, #12]
   2a988:	071a      	lsls	r2, r3, #28
   2a98a:	d52f      	bpl.n	2a9ec <__swbuf_r+0x84>
   2a98c:	6923      	ldr	r3, [r4, #16]
   2a98e:	b36b      	cbz	r3, 2a9ec <__swbuf_r+0x84>
   2a990:	6923      	ldr	r3, [r4, #16]
   2a992:	b2f6      	uxtb	r6, r6
   2a994:	6820      	ldr	r0, [r4, #0]
   2a996:	4637      	mov	r7, r6
   2a998:	1ac0      	subs	r0, r0, r3
   2a99a:	6963      	ldr	r3, [r4, #20]
   2a99c:	4283      	cmp	r3, r0
   2a99e:	dc04      	bgt.n	2a9aa <__swbuf_r+0x42>
   2a9a0:	4621      	mov	r1, r4
   2a9a2:	4628      	mov	r0, r5
   2a9a4:	f000 f948 	bl	2ac38 <_fflush_r>
   2a9a8:	bb30      	cbnz	r0, 2a9f8 <__swbuf_r+0x90>
   2a9aa:	68a3      	ldr	r3, [r4, #8]
   2a9ac:	3001      	adds	r0, #1
   2a9ae:	3b01      	subs	r3, #1
   2a9b0:	60a3      	str	r3, [r4, #8]
   2a9b2:	6823      	ldr	r3, [r4, #0]
   2a9b4:	1c5a      	adds	r2, r3, #1
   2a9b6:	6022      	str	r2, [r4, #0]
   2a9b8:	701e      	strb	r6, [r3, #0]
   2a9ba:	6963      	ldr	r3, [r4, #20]
   2a9bc:	4283      	cmp	r3, r0
   2a9be:	d004      	beq.n	2a9ca <__swbuf_r+0x62>
   2a9c0:	89a3      	ldrh	r3, [r4, #12]
   2a9c2:	07db      	lsls	r3, r3, #31
   2a9c4:	d506      	bpl.n	2a9d4 <__swbuf_r+0x6c>
   2a9c6:	2e0a      	cmp	r6, #10
   2a9c8:	d104      	bne.n	2a9d4 <__swbuf_r+0x6c>
   2a9ca:	4621      	mov	r1, r4
   2a9cc:	4628      	mov	r0, r5
   2a9ce:	f000 f933 	bl	2ac38 <_fflush_r>
   2a9d2:	b988      	cbnz	r0, 2a9f8 <__swbuf_r+0x90>
   2a9d4:	4638      	mov	r0, r7
   2a9d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2a9d8:	4b0a      	ldr	r3, [pc, #40]	; (2aa04 <__swbuf_r+0x9c>)
   2a9da:	429c      	cmp	r4, r3
   2a9dc:	d101      	bne.n	2a9e2 <__swbuf_r+0x7a>
   2a9de:	68ac      	ldr	r4, [r5, #8]
   2a9e0:	e7cf      	b.n	2a982 <__swbuf_r+0x1a>
   2a9e2:	4b09      	ldr	r3, [pc, #36]	; (2aa08 <__swbuf_r+0xa0>)
   2a9e4:	429c      	cmp	r4, r3
   2a9e6:	bf08      	it	eq
   2a9e8:	68ec      	ldreq	r4, [r5, #12]
   2a9ea:	e7ca      	b.n	2a982 <__swbuf_r+0x1a>
   2a9ec:	4621      	mov	r1, r4
   2a9ee:	4628      	mov	r0, r5
   2a9f0:	f000 f80c 	bl	2aa0c <__swsetup_r>
   2a9f4:	2800      	cmp	r0, #0
   2a9f6:	d0cb      	beq.n	2a990 <__swbuf_r+0x28>
   2a9f8:	f04f 37ff 	mov.w	r7, #4294967295
   2a9fc:	e7ea      	b.n	2a9d4 <__swbuf_r+0x6c>
   2a9fe:	bf00      	nop
   2aa00:	00030ee0 	.word	0x00030ee0
   2aa04:	00030f00 	.word	0x00030f00
   2aa08:	00030ec0 	.word	0x00030ec0

0002aa0c <__swsetup_r>:
   2aa0c:	4b32      	ldr	r3, [pc, #200]	; (2aad8 <__swsetup_r+0xcc>)
   2aa0e:	b570      	push	{r4, r5, r6, lr}
   2aa10:	681d      	ldr	r5, [r3, #0]
   2aa12:	4606      	mov	r6, r0
   2aa14:	460c      	mov	r4, r1
   2aa16:	b125      	cbz	r5, 2aa22 <__swsetup_r+0x16>
   2aa18:	69ab      	ldr	r3, [r5, #24]
   2aa1a:	b913      	cbnz	r3, 2aa22 <__swsetup_r+0x16>
   2aa1c:	4628      	mov	r0, r5
   2aa1e:	f000 f989 	bl	2ad34 <__sinit>
   2aa22:	4b2e      	ldr	r3, [pc, #184]	; (2aadc <__swsetup_r+0xd0>)
   2aa24:	429c      	cmp	r4, r3
   2aa26:	d10f      	bne.n	2aa48 <__swsetup_r+0x3c>
   2aa28:	686c      	ldr	r4, [r5, #4]
   2aa2a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   2aa2e:	b29a      	uxth	r2, r3
   2aa30:	0715      	lsls	r5, r2, #28
   2aa32:	d42c      	bmi.n	2aa8e <__swsetup_r+0x82>
   2aa34:	06d0      	lsls	r0, r2, #27
   2aa36:	d411      	bmi.n	2aa5c <__swsetup_r+0x50>
   2aa38:	2209      	movs	r2, #9
   2aa3a:	6032      	str	r2, [r6, #0]
   2aa3c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   2aa40:	f04f 30ff 	mov.w	r0, #4294967295
   2aa44:	81a3      	strh	r3, [r4, #12]
   2aa46:	e03e      	b.n	2aac6 <__swsetup_r+0xba>
   2aa48:	4b25      	ldr	r3, [pc, #148]	; (2aae0 <__swsetup_r+0xd4>)
   2aa4a:	429c      	cmp	r4, r3
   2aa4c:	d101      	bne.n	2aa52 <__swsetup_r+0x46>
   2aa4e:	68ac      	ldr	r4, [r5, #8]
   2aa50:	e7eb      	b.n	2aa2a <__swsetup_r+0x1e>
   2aa52:	4b24      	ldr	r3, [pc, #144]	; (2aae4 <__swsetup_r+0xd8>)
   2aa54:	429c      	cmp	r4, r3
   2aa56:	bf08      	it	eq
   2aa58:	68ec      	ldreq	r4, [r5, #12]
   2aa5a:	e7e6      	b.n	2aa2a <__swsetup_r+0x1e>
   2aa5c:	0751      	lsls	r1, r2, #29
   2aa5e:	d512      	bpl.n	2aa86 <__swsetup_r+0x7a>
   2aa60:	6b61      	ldr	r1, [r4, #52]	; 0x34
   2aa62:	b141      	cbz	r1, 2aa76 <__swsetup_r+0x6a>
   2aa64:	f104 0344 	add.w	r3, r4, #68	; 0x44
   2aa68:	4299      	cmp	r1, r3
   2aa6a:	d002      	beq.n	2aa72 <__swsetup_r+0x66>
   2aa6c:	4630      	mov	r0, r6
   2aa6e:	f000 fa79 	bl	2af64 <_free_r>
   2aa72:	2300      	movs	r3, #0
   2aa74:	6363      	str	r3, [r4, #52]	; 0x34
   2aa76:	89a3      	ldrh	r3, [r4, #12]
   2aa78:	f023 0324 	bic.w	r3, r3, #36	; 0x24
   2aa7c:	81a3      	strh	r3, [r4, #12]
   2aa7e:	2300      	movs	r3, #0
   2aa80:	6063      	str	r3, [r4, #4]
   2aa82:	6923      	ldr	r3, [r4, #16]
   2aa84:	6023      	str	r3, [r4, #0]
   2aa86:	89a3      	ldrh	r3, [r4, #12]
   2aa88:	f043 0308 	orr.w	r3, r3, #8
   2aa8c:	81a3      	strh	r3, [r4, #12]
   2aa8e:	6923      	ldr	r3, [r4, #16]
   2aa90:	b94b      	cbnz	r3, 2aaa6 <__swsetup_r+0x9a>
   2aa92:	89a3      	ldrh	r3, [r4, #12]
   2aa94:	f403 7320 	and.w	r3, r3, #640	; 0x280
   2aa98:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   2aa9c:	d003      	beq.n	2aaa6 <__swsetup_r+0x9a>
   2aa9e:	4621      	mov	r1, r4
   2aaa0:	4630      	mov	r0, r6
   2aaa2:	f000 f9c9 	bl	2ae38 <__smakebuf_r>
   2aaa6:	89a2      	ldrh	r2, [r4, #12]
   2aaa8:	f012 0301 	ands.w	r3, r2, #1
   2aaac:	d00c      	beq.n	2aac8 <__swsetup_r+0xbc>
   2aaae:	2300      	movs	r3, #0
   2aab0:	60a3      	str	r3, [r4, #8]
   2aab2:	6963      	ldr	r3, [r4, #20]
   2aab4:	425b      	negs	r3, r3
   2aab6:	61a3      	str	r3, [r4, #24]
   2aab8:	6923      	ldr	r3, [r4, #16]
   2aaba:	b953      	cbnz	r3, 2aad2 <__swsetup_r+0xc6>
   2aabc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   2aac0:	f013 0080 	ands.w	r0, r3, #128	; 0x80
   2aac4:	d1ba      	bne.n	2aa3c <__swsetup_r+0x30>
   2aac6:	bd70      	pop	{r4, r5, r6, pc}
   2aac8:	0792      	lsls	r2, r2, #30
   2aaca:	bf58      	it	pl
   2aacc:	6963      	ldrpl	r3, [r4, #20]
   2aace:	60a3      	str	r3, [r4, #8]
   2aad0:	e7f2      	b.n	2aab8 <__swsetup_r+0xac>
   2aad2:	2000      	movs	r0, #0
   2aad4:	e7f7      	b.n	2aac6 <__swsetup_r+0xba>
   2aad6:	bf00      	nop
   2aad8:	200383d4 	.word	0x200383d4
   2aadc:	00030ee0 	.word	0x00030ee0
   2aae0:	00030f00 	.word	0x00030f00
   2aae4:	00030ec0 	.word	0x00030ec0

0002aae8 <__chk_fail>:
   2aae8:	b500      	push	{lr}
   2aaea:	b08d      	sub	sp, #52	; 0x34
   2aaec:	4b0f      	ldr	r3, [pc, #60]	; (2ab2c <__chk_fail+0x44>)
   2aaee:	466a      	mov	r2, sp
   2aaf0:	f103 0628 	add.w	r6, r3, #40	; 0x28
   2aaf4:	4615      	mov	r5, r2
   2aaf6:	6818      	ldr	r0, [r3, #0]
   2aaf8:	3308      	adds	r3, #8
   2aafa:	f853 1c04 	ldr.w	r1, [r3, #-4]
   2aafe:	4614      	mov	r4, r2
   2ab00:	42b3      	cmp	r3, r6
   2ab02:	c403      	stmia	r4!, {r0, r1}
   2ab04:	4622      	mov	r2, r4
   2ab06:	d1f6      	bne.n	2aaf6 <__chk_fail+0xe>
   2ab08:	6818      	ldr	r0, [r3, #0]
   2ab0a:	889b      	ldrh	r3, [r3, #4]
   2ab0c:	6020      	str	r0, [r4, #0]
   2ab0e:	4628      	mov	r0, r5
   2ab10:	80a3      	strh	r3, [r4, #4]
   2ab12:	f7e2 fa21 	bl	cf58 <strlen>
   2ab16:	4629      	mov	r1, r5
   2ab18:	4602      	mov	r2, r0
   2ab1a:	2002      	movs	r0, #2
   2ab1c:	f002 fd7c 	bl	2d618 <_write>
   2ab20:	2006      	movs	r0, #6
   2ab22:	f000 fbcf 	bl	2b2c4 <raise>
   2ab26:	207f      	movs	r0, #127	; 0x7f
   2ab28:	f7ef f9d6 	bl	19ed8 <_exit>
   2ab2c:	00034f55 	.word	0x00034f55

0002ab30 <__sflush_r>:
   2ab30:	898a      	ldrh	r2, [r1, #12]
   2ab32:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2ab36:	4605      	mov	r5, r0
   2ab38:	0710      	lsls	r0, r2, #28
   2ab3a:	460c      	mov	r4, r1
   2ab3c:	d458      	bmi.n	2abf0 <__sflush_r+0xc0>
   2ab3e:	684b      	ldr	r3, [r1, #4]
   2ab40:	2b00      	cmp	r3, #0
   2ab42:	dc05      	bgt.n	2ab50 <__sflush_r+0x20>
   2ab44:	6c0b      	ldr	r3, [r1, #64]	; 0x40
   2ab46:	2b00      	cmp	r3, #0
   2ab48:	dc02      	bgt.n	2ab50 <__sflush_r+0x20>
   2ab4a:	2000      	movs	r0, #0
   2ab4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2ab50:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   2ab52:	2e00      	cmp	r6, #0
   2ab54:	d0f9      	beq.n	2ab4a <__sflush_r+0x1a>
   2ab56:	2300      	movs	r3, #0
   2ab58:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
   2ab5c:	682f      	ldr	r7, [r5, #0]
   2ab5e:	602b      	str	r3, [r5, #0]
   2ab60:	d032      	beq.n	2abc8 <__sflush_r+0x98>
   2ab62:	6d60      	ldr	r0, [r4, #84]	; 0x54
   2ab64:	89a3      	ldrh	r3, [r4, #12]
   2ab66:	075a      	lsls	r2, r3, #29
   2ab68:	d505      	bpl.n	2ab76 <__sflush_r+0x46>
   2ab6a:	6863      	ldr	r3, [r4, #4]
   2ab6c:	1ac0      	subs	r0, r0, r3
   2ab6e:	6b63      	ldr	r3, [r4, #52]	; 0x34
   2ab70:	b10b      	cbz	r3, 2ab76 <__sflush_r+0x46>
   2ab72:	6c23      	ldr	r3, [r4, #64]	; 0x40
   2ab74:	1ac0      	subs	r0, r0, r3
   2ab76:	2300      	movs	r3, #0
   2ab78:	4602      	mov	r2, r0
   2ab7a:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   2ab7c:	4628      	mov	r0, r5
   2ab7e:	6a21      	ldr	r1, [r4, #32]
   2ab80:	47b0      	blx	r6
   2ab82:	1c43      	adds	r3, r0, #1
   2ab84:	89a3      	ldrh	r3, [r4, #12]
   2ab86:	d106      	bne.n	2ab96 <__sflush_r+0x66>
   2ab88:	6829      	ldr	r1, [r5, #0]
   2ab8a:	291d      	cmp	r1, #29
   2ab8c:	d82c      	bhi.n	2abe8 <__sflush_r+0xb8>
   2ab8e:	4a29      	ldr	r2, [pc, #164]	; (2ac34 <__sflush_r+0x104>)
   2ab90:	40ca      	lsrs	r2, r1
   2ab92:	07d6      	lsls	r6, r2, #31
   2ab94:	d528      	bpl.n	2abe8 <__sflush_r+0xb8>
   2ab96:	2200      	movs	r2, #0
   2ab98:	04d9      	lsls	r1, r3, #19
   2ab9a:	6062      	str	r2, [r4, #4]
   2ab9c:	6922      	ldr	r2, [r4, #16]
   2ab9e:	6022      	str	r2, [r4, #0]
   2aba0:	d504      	bpl.n	2abac <__sflush_r+0x7c>
   2aba2:	1c42      	adds	r2, r0, #1
   2aba4:	d101      	bne.n	2abaa <__sflush_r+0x7a>
   2aba6:	682b      	ldr	r3, [r5, #0]
   2aba8:	b903      	cbnz	r3, 2abac <__sflush_r+0x7c>
   2abaa:	6560      	str	r0, [r4, #84]	; 0x54
   2abac:	6b61      	ldr	r1, [r4, #52]	; 0x34
   2abae:	602f      	str	r7, [r5, #0]
   2abb0:	2900      	cmp	r1, #0
   2abb2:	d0ca      	beq.n	2ab4a <__sflush_r+0x1a>
   2abb4:	f104 0344 	add.w	r3, r4, #68	; 0x44
   2abb8:	4299      	cmp	r1, r3
   2abba:	d002      	beq.n	2abc2 <__sflush_r+0x92>
   2abbc:	4628      	mov	r0, r5
   2abbe:	f000 f9d1 	bl	2af64 <_free_r>
   2abc2:	2000      	movs	r0, #0
   2abc4:	6360      	str	r0, [r4, #52]	; 0x34
   2abc6:	e7c1      	b.n	2ab4c <__sflush_r+0x1c>
   2abc8:	6a21      	ldr	r1, [r4, #32]
   2abca:	2301      	movs	r3, #1
   2abcc:	4628      	mov	r0, r5
   2abce:	47b0      	blx	r6
   2abd0:	1c41      	adds	r1, r0, #1
   2abd2:	d1c7      	bne.n	2ab64 <__sflush_r+0x34>
   2abd4:	682b      	ldr	r3, [r5, #0]
   2abd6:	2b00      	cmp	r3, #0
   2abd8:	d0c4      	beq.n	2ab64 <__sflush_r+0x34>
   2abda:	2b1d      	cmp	r3, #29
   2abdc:	d001      	beq.n	2abe2 <__sflush_r+0xb2>
   2abde:	2b16      	cmp	r3, #22
   2abe0:	d101      	bne.n	2abe6 <__sflush_r+0xb6>
   2abe2:	602f      	str	r7, [r5, #0]
   2abe4:	e7b1      	b.n	2ab4a <__sflush_r+0x1a>
   2abe6:	89a3      	ldrh	r3, [r4, #12]
   2abe8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   2abec:	81a3      	strh	r3, [r4, #12]
   2abee:	e7ad      	b.n	2ab4c <__sflush_r+0x1c>
   2abf0:	690f      	ldr	r7, [r1, #16]
   2abf2:	2f00      	cmp	r7, #0
   2abf4:	d0a9      	beq.n	2ab4a <__sflush_r+0x1a>
   2abf6:	0793      	lsls	r3, r2, #30
   2abf8:	680e      	ldr	r6, [r1, #0]
   2abfa:	600f      	str	r7, [r1, #0]
   2abfc:	bf0c      	ite	eq
   2abfe:	694b      	ldreq	r3, [r1, #20]
   2ac00:	2300      	movne	r3, #0
   2ac02:	eba6 0807 	sub.w	r8, r6, r7
   2ac06:	608b      	str	r3, [r1, #8]
   2ac08:	f1b8 0f00 	cmp.w	r8, #0
   2ac0c:	dd9d      	ble.n	2ab4a <__sflush_r+0x1a>
   2ac0e:	4643      	mov	r3, r8
   2ac10:	463a      	mov	r2, r7
   2ac12:	6a21      	ldr	r1, [r4, #32]
   2ac14:	4628      	mov	r0, r5
   2ac16:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   2ac18:	47b0      	blx	r6
   2ac1a:	2800      	cmp	r0, #0
   2ac1c:	dc06      	bgt.n	2ac2c <__sflush_r+0xfc>
   2ac1e:	89a3      	ldrh	r3, [r4, #12]
   2ac20:	f04f 30ff 	mov.w	r0, #4294967295
   2ac24:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   2ac28:	81a3      	strh	r3, [r4, #12]
   2ac2a:	e78f      	b.n	2ab4c <__sflush_r+0x1c>
   2ac2c:	4407      	add	r7, r0
   2ac2e:	eba8 0800 	sub.w	r8, r8, r0
   2ac32:	e7e9      	b.n	2ac08 <__sflush_r+0xd8>
   2ac34:	20400001 	.word	0x20400001

0002ac38 <_fflush_r>:
   2ac38:	b538      	push	{r3, r4, r5, lr}
   2ac3a:	690b      	ldr	r3, [r1, #16]
   2ac3c:	4605      	mov	r5, r0
   2ac3e:	460c      	mov	r4, r1
   2ac40:	b913      	cbnz	r3, 2ac48 <_fflush_r+0x10>
   2ac42:	2500      	movs	r5, #0
   2ac44:	4628      	mov	r0, r5
   2ac46:	bd38      	pop	{r3, r4, r5, pc}
   2ac48:	b118      	cbz	r0, 2ac52 <_fflush_r+0x1a>
   2ac4a:	6983      	ldr	r3, [r0, #24]
   2ac4c:	b90b      	cbnz	r3, 2ac52 <_fflush_r+0x1a>
   2ac4e:	f000 f871 	bl	2ad34 <__sinit>
   2ac52:	4b14      	ldr	r3, [pc, #80]	; (2aca4 <_fflush_r+0x6c>)
   2ac54:	429c      	cmp	r4, r3
   2ac56:	d11b      	bne.n	2ac90 <_fflush_r+0x58>
   2ac58:	686c      	ldr	r4, [r5, #4]
   2ac5a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   2ac5e:	2b00      	cmp	r3, #0
   2ac60:	d0ef      	beq.n	2ac42 <_fflush_r+0xa>
   2ac62:	6e62      	ldr	r2, [r4, #100]	; 0x64
   2ac64:	07d0      	lsls	r0, r2, #31
   2ac66:	d404      	bmi.n	2ac72 <_fflush_r+0x3a>
   2ac68:	0599      	lsls	r1, r3, #22
   2ac6a:	d402      	bmi.n	2ac72 <_fflush_r+0x3a>
   2ac6c:	6da0      	ldr	r0, [r4, #88]	; 0x58
   2ac6e:	f004 fe4c 	bl	2f90a <__retarget_lock_acquire_recursive>
   2ac72:	4628      	mov	r0, r5
   2ac74:	4621      	mov	r1, r4
   2ac76:	f7ff ff5b 	bl	2ab30 <__sflush_r>
   2ac7a:	6e63      	ldr	r3, [r4, #100]	; 0x64
   2ac7c:	4605      	mov	r5, r0
   2ac7e:	07da      	lsls	r2, r3, #31
   2ac80:	d4e0      	bmi.n	2ac44 <_fflush_r+0xc>
   2ac82:	89a3      	ldrh	r3, [r4, #12]
   2ac84:	059b      	lsls	r3, r3, #22
   2ac86:	d4dd      	bmi.n	2ac44 <_fflush_r+0xc>
   2ac88:	6da0      	ldr	r0, [r4, #88]	; 0x58
   2ac8a:	f004 fe3f 	bl	2f90c <__retarget_lock_release_recursive>
   2ac8e:	e7d9      	b.n	2ac44 <_fflush_r+0xc>
   2ac90:	4b05      	ldr	r3, [pc, #20]	; (2aca8 <_fflush_r+0x70>)
   2ac92:	429c      	cmp	r4, r3
   2ac94:	d101      	bne.n	2ac9a <_fflush_r+0x62>
   2ac96:	68ac      	ldr	r4, [r5, #8]
   2ac98:	e7df      	b.n	2ac5a <_fflush_r+0x22>
   2ac9a:	4b04      	ldr	r3, [pc, #16]	; (2acac <_fflush_r+0x74>)
   2ac9c:	429c      	cmp	r4, r3
   2ac9e:	bf08      	it	eq
   2aca0:	68ec      	ldreq	r4, [r5, #12]
   2aca2:	e7da      	b.n	2ac5a <_fflush_r+0x22>
   2aca4:	00030ee0 	.word	0x00030ee0
   2aca8:	00030f00 	.word	0x00030f00
   2acac:	00030ec0 	.word	0x00030ec0

0002acb0 <std>:
   2acb0:	2300      	movs	r3, #0
   2acb2:	b510      	push	{r4, lr}
   2acb4:	4604      	mov	r4, r0
   2acb6:	6083      	str	r3, [r0, #8]
   2acb8:	8181      	strh	r1, [r0, #12]
   2acba:	4619      	mov	r1, r3
   2acbc:	6643      	str	r3, [r0, #100]	; 0x64
   2acbe:	81c2      	strh	r2, [r0, #14]
   2acc0:	2208      	movs	r2, #8
   2acc2:	6183      	str	r3, [r0, #24]
   2acc4:	e9c0 3300 	strd	r3, r3, [r0]
   2acc8:	e9c0 3304 	strd	r3, r3, [r0, #16]
   2accc:	305c      	adds	r0, #92	; 0x5c
   2acce:	f004 fb61 	bl	2f394 <memset>
   2acd2:	4b05      	ldr	r3, [pc, #20]	; (2ace8 <std+0x38>)
   2acd4:	6224      	str	r4, [r4, #32]
   2acd6:	6263      	str	r3, [r4, #36]	; 0x24
   2acd8:	4b04      	ldr	r3, [pc, #16]	; (2acec <std+0x3c>)
   2acda:	62a3      	str	r3, [r4, #40]	; 0x28
   2acdc:	4b04      	ldr	r3, [pc, #16]	; (2acf0 <std+0x40>)
   2acde:	62e3      	str	r3, [r4, #44]	; 0x2c
   2ace0:	4b04      	ldr	r3, [pc, #16]	; (2acf4 <std+0x44>)
   2ace2:	6323      	str	r3, [r4, #48]	; 0x30
   2ace4:	bd10      	pop	{r4, pc}
   2ace6:	bf00      	nop
   2ace8:	00030013 	.word	0x00030013
   2acec:	00030035 	.word	0x00030035
   2acf0:	0003006d 	.word	0x0003006d
   2acf4:	00030091 	.word	0x00030091

0002acf8 <_cleanup_r>:
   2acf8:	4901      	ldr	r1, [pc, #4]	; (2ad00 <_cleanup_r+0x8>)
   2acfa:	f004 bde7 	b.w	2f8cc <_fwalk_reent>
   2acfe:	bf00      	nop
   2ad00:	0002ac39 	.word	0x0002ac39

0002ad04 <__sfp_lock_acquire>:
   2ad04:	4801      	ldr	r0, [pc, #4]	; (2ad0c <__sfp_lock_acquire+0x8>)
   2ad06:	f004 be00 	b.w	2f90a <__retarget_lock_acquire_recursive>
   2ad0a:	bf00      	nop
   2ad0c:	20031610 	.word	0x20031610

0002ad10 <__sfp_lock_release>:
   2ad10:	4801      	ldr	r0, [pc, #4]	; (2ad18 <__sfp_lock_release+0x8>)
   2ad12:	f004 bdfb 	b.w	2f90c <__retarget_lock_release_recursive>
   2ad16:	bf00      	nop
   2ad18:	20031610 	.word	0x20031610

0002ad1c <__sinit_lock_acquire>:
   2ad1c:	4801      	ldr	r0, [pc, #4]	; (2ad24 <__sinit_lock_acquire+0x8>)
   2ad1e:	f004 bdf4 	b.w	2f90a <__retarget_lock_acquire_recursive>
   2ad22:	bf00      	nop
   2ad24:	2003160b 	.word	0x2003160b

0002ad28 <__sinit_lock_release>:
   2ad28:	4801      	ldr	r0, [pc, #4]	; (2ad30 <__sinit_lock_release+0x8>)
   2ad2a:	f004 bdef 	b.w	2f90c <__retarget_lock_release_recursive>
   2ad2e:	bf00      	nop
   2ad30:	2003160b 	.word	0x2003160b

0002ad34 <__sinit>:
   2ad34:	b510      	push	{r4, lr}
   2ad36:	4604      	mov	r4, r0
   2ad38:	f7ff fff0 	bl	2ad1c <__sinit_lock_acquire>
   2ad3c:	69a3      	ldr	r3, [r4, #24]
   2ad3e:	b11b      	cbz	r3, 2ad48 <__sinit+0x14>
   2ad40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2ad44:	f7ff bff0 	b.w	2ad28 <__sinit_lock_release>
   2ad48:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
   2ad4c:	6523      	str	r3, [r4, #80]	; 0x50
   2ad4e:	4620      	mov	r0, r4
   2ad50:	4b12      	ldr	r3, [pc, #72]	; (2ad9c <__sinit+0x68>)
   2ad52:	4a13      	ldr	r2, [pc, #76]	; (2ada0 <__sinit+0x6c>)
   2ad54:	681b      	ldr	r3, [r3, #0]
   2ad56:	62a2      	str	r2, [r4, #40]	; 0x28
   2ad58:	42a3      	cmp	r3, r4
   2ad5a:	bf04      	itt	eq
   2ad5c:	2301      	moveq	r3, #1
   2ad5e:	61a3      	streq	r3, [r4, #24]
   2ad60:	f000 f820 	bl	2ada4 <__sfp>
   2ad64:	6060      	str	r0, [r4, #4]
   2ad66:	4620      	mov	r0, r4
   2ad68:	f000 f81c 	bl	2ada4 <__sfp>
   2ad6c:	60a0      	str	r0, [r4, #8]
   2ad6e:	4620      	mov	r0, r4
   2ad70:	f000 f818 	bl	2ada4 <__sfp>
   2ad74:	2200      	movs	r2, #0
   2ad76:	60e0      	str	r0, [r4, #12]
   2ad78:	2104      	movs	r1, #4
   2ad7a:	6860      	ldr	r0, [r4, #4]
   2ad7c:	f7ff ff98 	bl	2acb0 <std>
   2ad80:	2201      	movs	r2, #1
   2ad82:	2109      	movs	r1, #9
   2ad84:	68a0      	ldr	r0, [r4, #8]
   2ad86:	f7ff ff93 	bl	2acb0 <std>
   2ad8a:	2202      	movs	r2, #2
   2ad8c:	2112      	movs	r1, #18
   2ad8e:	68e0      	ldr	r0, [r4, #12]
   2ad90:	f7ff ff8e 	bl	2acb0 <std>
   2ad94:	2301      	movs	r3, #1
   2ad96:	61a3      	str	r3, [r4, #24]
   2ad98:	e7d2      	b.n	2ad40 <__sinit+0xc>
   2ad9a:	bf00      	nop
   2ad9c:	00030ebc 	.word	0x00030ebc
   2ada0:	0002acf9 	.word	0x0002acf9

0002ada4 <__sfp>:
   2ada4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2ada6:	4607      	mov	r7, r0
   2ada8:	f7ff ffac 	bl	2ad04 <__sfp_lock_acquire>
   2adac:	4b1e      	ldr	r3, [pc, #120]	; (2ae28 <__sfp+0x84>)
   2adae:	681e      	ldr	r6, [r3, #0]
   2adb0:	69b3      	ldr	r3, [r6, #24]
   2adb2:	b913      	cbnz	r3, 2adba <__sfp+0x16>
   2adb4:	4630      	mov	r0, r6
   2adb6:	f7ff ffbd 	bl	2ad34 <__sinit>
   2adba:	3648      	adds	r6, #72	; 0x48
   2adbc:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
   2adc0:	3b01      	subs	r3, #1
   2adc2:	d503      	bpl.n	2adcc <__sfp+0x28>
   2adc4:	6833      	ldr	r3, [r6, #0]
   2adc6:	b30b      	cbz	r3, 2ae0c <__sfp+0x68>
   2adc8:	6836      	ldr	r6, [r6, #0]
   2adca:	e7f7      	b.n	2adbc <__sfp+0x18>
   2adcc:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
   2add0:	b9d5      	cbnz	r5, 2ae08 <__sfp+0x64>
   2add2:	4b16      	ldr	r3, [pc, #88]	; (2ae2c <__sfp+0x88>)
   2add4:	f104 0058 	add.w	r0, r4, #88	; 0x58
   2add8:	6665      	str	r5, [r4, #100]	; 0x64
   2adda:	60e3      	str	r3, [r4, #12]
   2addc:	f004 fd94 	bl	2f908 <__retarget_lock_init_recursive>
   2ade0:	f7ff ff96 	bl	2ad10 <__sfp_lock_release>
   2ade4:	6025      	str	r5, [r4, #0]
   2ade6:	61a5      	str	r5, [r4, #24]
   2ade8:	2208      	movs	r2, #8
   2adea:	4629      	mov	r1, r5
   2adec:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   2adf0:	e9c4 5501 	strd	r5, r5, [r4, #4]
   2adf4:	e9c4 5504 	strd	r5, r5, [r4, #16]
   2adf8:	f004 facc 	bl	2f394 <memset>
   2adfc:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
   2ae00:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
   2ae04:	4620      	mov	r0, r4
   2ae06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2ae08:	3468      	adds	r4, #104	; 0x68
   2ae0a:	e7d9      	b.n	2adc0 <__sfp+0x1c>
   2ae0c:	2104      	movs	r1, #4
   2ae0e:	4638      	mov	r0, r7
   2ae10:	f004 fd46 	bl	2f8a0 <__sfmoreglue>
   2ae14:	4604      	mov	r4, r0
   2ae16:	6030      	str	r0, [r6, #0]
   2ae18:	2800      	cmp	r0, #0
   2ae1a:	d1d5      	bne.n	2adc8 <__sfp+0x24>
   2ae1c:	f7ff ff78 	bl	2ad10 <__sfp_lock_release>
   2ae20:	230c      	movs	r3, #12
   2ae22:	603b      	str	r3, [r7, #0]
   2ae24:	e7ee      	b.n	2ae04 <__sfp+0x60>
   2ae26:	bf00      	nop
   2ae28:	00030ebc 	.word	0x00030ebc
   2ae2c:	ffff0001 	.word	0xffff0001

0002ae30 <_localeconv_r>:
   2ae30:	4800      	ldr	r0, [pc, #0]	; (2ae34 <_localeconv_r+0x4>)
   2ae32:	4770      	bx	lr
   2ae34:	20038528 	.word	0x20038528

0002ae38 <__smakebuf_r>:
   2ae38:	898b      	ldrh	r3, [r1, #12]
   2ae3a:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2ae3c:	079d      	lsls	r5, r3, #30
   2ae3e:	4606      	mov	r6, r0
   2ae40:	460c      	mov	r4, r1
   2ae42:	d507      	bpl.n	2ae54 <__smakebuf_r+0x1c>
   2ae44:	f104 0347 	add.w	r3, r4, #71	; 0x47
   2ae48:	6023      	str	r3, [r4, #0]
   2ae4a:	6123      	str	r3, [r4, #16]
   2ae4c:	2301      	movs	r3, #1
   2ae4e:	6163      	str	r3, [r4, #20]
   2ae50:	b002      	add	sp, #8
   2ae52:	bd70      	pop	{r4, r5, r6, pc}
   2ae54:	ab01      	add	r3, sp, #4
   2ae56:	466a      	mov	r2, sp
   2ae58:	f004 fd59 	bl	2f90e <__swhatbuf_r>
   2ae5c:	9900      	ldr	r1, [sp, #0]
   2ae5e:	4605      	mov	r5, r0
   2ae60:	4630      	mov	r0, r6
   2ae62:	f000 f8cd 	bl	2b000 <_malloc_r>
   2ae66:	b948      	cbnz	r0, 2ae7c <__smakebuf_r+0x44>
   2ae68:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   2ae6c:	059a      	lsls	r2, r3, #22
   2ae6e:	d4ef      	bmi.n	2ae50 <__smakebuf_r+0x18>
   2ae70:	f023 0303 	bic.w	r3, r3, #3
   2ae74:	f043 0302 	orr.w	r3, r3, #2
   2ae78:	81a3      	strh	r3, [r4, #12]
   2ae7a:	e7e3      	b.n	2ae44 <__smakebuf_r+0xc>
   2ae7c:	4b0d      	ldr	r3, [pc, #52]	; (2aeb4 <__smakebuf_r+0x7c>)
   2ae7e:	62b3      	str	r3, [r6, #40]	; 0x28
   2ae80:	89a3      	ldrh	r3, [r4, #12]
   2ae82:	6020      	str	r0, [r4, #0]
   2ae84:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   2ae88:	6120      	str	r0, [r4, #16]
   2ae8a:	81a3      	strh	r3, [r4, #12]
   2ae8c:	9b00      	ldr	r3, [sp, #0]
   2ae8e:	6163      	str	r3, [r4, #20]
   2ae90:	9b01      	ldr	r3, [sp, #4]
   2ae92:	b15b      	cbz	r3, 2aeac <__smakebuf_r+0x74>
   2ae94:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   2ae98:	4630      	mov	r0, r6
   2ae9a:	f000 fa61 	bl	2b360 <_isatty_r>
   2ae9e:	b128      	cbz	r0, 2aeac <__smakebuf_r+0x74>
   2aea0:	89a3      	ldrh	r3, [r4, #12]
   2aea2:	f023 0303 	bic.w	r3, r3, #3
   2aea6:	f043 0301 	orr.w	r3, r3, #1
   2aeaa:	81a3      	strh	r3, [r4, #12]
   2aeac:	89a3      	ldrh	r3, [r4, #12]
   2aeae:	431d      	orrs	r5, r3
   2aeb0:	81a5      	strh	r5, [r4, #12]
   2aeb2:	e7cd      	b.n	2ae50 <__smakebuf_r+0x18>
   2aeb4:	0002acf9 	.word	0x0002acf9

0002aeb8 <malloc>:
   2aeb8:	4b02      	ldr	r3, [pc, #8]	; (2aec4 <malloc+0xc>)
   2aeba:	4601      	mov	r1, r0
   2aebc:	6818      	ldr	r0, [r3, #0]
   2aebe:	f000 b89f 	b.w	2b000 <_malloc_r>
   2aec2:	bf00      	nop
   2aec4:	200383d4 	.word	0x200383d4

0002aec8 <__pow5mult>:
   2aec8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2aecc:	4615      	mov	r5, r2
   2aece:	f012 0203 	ands.w	r2, r2, #3
   2aed2:	4606      	mov	r6, r0
   2aed4:	460f      	mov	r7, r1
   2aed6:	d007      	beq.n	2aee8 <__pow5mult+0x20>
   2aed8:	3a01      	subs	r2, #1
   2aeda:	4c21      	ldr	r4, [pc, #132]	; (2af60 <__pow5mult+0x98>)
   2aedc:	2300      	movs	r3, #0
   2aede:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
   2aee2:	f004 fd9d 	bl	2fa20 <__multadd>
   2aee6:	4607      	mov	r7, r0
   2aee8:	10ad      	asrs	r5, r5, #2
   2aeea:	d035      	beq.n	2af58 <__pow5mult+0x90>
   2aeec:	6a74      	ldr	r4, [r6, #36]	; 0x24
   2aeee:	b93c      	cbnz	r4, 2af00 <__pow5mult+0x38>
   2aef0:	2010      	movs	r0, #16
   2aef2:	f7ff ffe1 	bl	2aeb8 <malloc>
   2aef6:	6270      	str	r0, [r6, #36]	; 0x24
   2aef8:	6004      	str	r4, [r0, #0]
   2aefa:	60c4      	str	r4, [r0, #12]
   2aefc:	e9c0 4401 	strd	r4, r4, [r0, #4]
   2af00:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
   2af04:	f8d8 4008 	ldr.w	r4, [r8, #8]
   2af08:	b94c      	cbnz	r4, 2af1e <__pow5mult+0x56>
   2af0a:	f240 2171 	movw	r1, #625	; 0x271
   2af0e:	4630      	mov	r0, r6
   2af10:	f004 fe13 	bl	2fb3a <__i2b>
   2af14:	2300      	movs	r3, #0
   2af16:	4604      	mov	r4, r0
   2af18:	f8c8 0008 	str.w	r0, [r8, #8]
   2af1c:	6003      	str	r3, [r0, #0]
   2af1e:	f04f 0800 	mov.w	r8, #0
   2af22:	07eb      	lsls	r3, r5, #31
   2af24:	d50a      	bpl.n	2af3c <__pow5mult+0x74>
   2af26:	4639      	mov	r1, r7
   2af28:	4622      	mov	r2, r4
   2af2a:	4630      	mov	r0, r6
   2af2c:	f004 fe0e 	bl	2fb4c <__multiply>
   2af30:	4681      	mov	r9, r0
   2af32:	4639      	mov	r1, r7
   2af34:	4630      	mov	r0, r6
   2af36:	464f      	mov	r7, r9
   2af38:	f004 fd5b 	bl	2f9f2 <_Bfree>
   2af3c:	106d      	asrs	r5, r5, #1
   2af3e:	d00b      	beq.n	2af58 <__pow5mult+0x90>
   2af40:	6820      	ldr	r0, [r4, #0]
   2af42:	b938      	cbnz	r0, 2af54 <__pow5mult+0x8c>
   2af44:	4622      	mov	r2, r4
   2af46:	4621      	mov	r1, r4
   2af48:	4630      	mov	r0, r6
   2af4a:	f004 fdff 	bl	2fb4c <__multiply>
   2af4e:	6020      	str	r0, [r4, #0]
   2af50:	f8c0 8000 	str.w	r8, [r0]
   2af54:	4604      	mov	r4, r0
   2af56:	e7e4      	b.n	2af22 <__pow5mult+0x5a>
   2af58:	4638      	mov	r0, r7
   2af5a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2af5e:	bf00      	nop
   2af60:	00030f20 	.word	0x00030f20

0002af64 <_free_r>:
   2af64:	b538      	push	{r3, r4, r5, lr}
   2af66:	4605      	mov	r5, r0
   2af68:	2900      	cmp	r1, #0
   2af6a:	d045      	beq.n	2aff8 <_free_r+0x94>
   2af6c:	f851 3c04 	ldr.w	r3, [r1, #-4]
   2af70:	1f0c      	subs	r4, r1, #4
   2af72:	2b00      	cmp	r3, #0
   2af74:	bfb8      	it	lt
   2af76:	18e4      	addlt	r4, r4, r3
   2af78:	f000 fa14 	bl	2b3a4 <__malloc_lock>
   2af7c:	4a1f      	ldr	r2, [pc, #124]	; (2affc <_free_r+0x98>)
   2af7e:	6813      	ldr	r3, [r2, #0]
   2af80:	4610      	mov	r0, r2
   2af82:	b933      	cbnz	r3, 2af92 <_free_r+0x2e>
   2af84:	6063      	str	r3, [r4, #4]
   2af86:	6014      	str	r4, [r2, #0]
   2af88:	4628      	mov	r0, r5
   2af8a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2af8e:	f000 ba0f 	b.w	2b3b0 <__malloc_unlock>
   2af92:	42a3      	cmp	r3, r4
   2af94:	d90c      	bls.n	2afb0 <_free_r+0x4c>
   2af96:	6821      	ldr	r1, [r4, #0]
   2af98:	1862      	adds	r2, r4, r1
   2af9a:	4293      	cmp	r3, r2
   2af9c:	bf02      	ittt	eq
   2af9e:	681a      	ldreq	r2, [r3, #0]
   2afa0:	685b      	ldreq	r3, [r3, #4]
   2afa2:	1852      	addeq	r2, r2, r1
   2afa4:	6063      	str	r3, [r4, #4]
   2afa6:	bf08      	it	eq
   2afa8:	6022      	streq	r2, [r4, #0]
   2afaa:	6004      	str	r4, [r0, #0]
   2afac:	e7ec      	b.n	2af88 <_free_r+0x24>
   2afae:	4613      	mov	r3, r2
   2afb0:	685a      	ldr	r2, [r3, #4]
   2afb2:	b10a      	cbz	r2, 2afb8 <_free_r+0x54>
   2afb4:	42a2      	cmp	r2, r4
   2afb6:	d9fa      	bls.n	2afae <_free_r+0x4a>
   2afb8:	6819      	ldr	r1, [r3, #0]
   2afba:	1858      	adds	r0, r3, r1
   2afbc:	42a0      	cmp	r0, r4
   2afbe:	d10b      	bne.n	2afd8 <_free_r+0x74>
   2afc0:	6820      	ldr	r0, [r4, #0]
   2afc2:	4401      	add	r1, r0
   2afc4:	1858      	adds	r0, r3, r1
   2afc6:	6019      	str	r1, [r3, #0]
   2afc8:	4282      	cmp	r2, r0
   2afca:	d1dd      	bne.n	2af88 <_free_r+0x24>
   2afcc:	6810      	ldr	r0, [r2, #0]
   2afce:	6852      	ldr	r2, [r2, #4]
   2afd0:	4401      	add	r1, r0
   2afd2:	605a      	str	r2, [r3, #4]
   2afd4:	6019      	str	r1, [r3, #0]
   2afd6:	e7d7      	b.n	2af88 <_free_r+0x24>
   2afd8:	d902      	bls.n	2afe0 <_free_r+0x7c>
   2afda:	230c      	movs	r3, #12
   2afdc:	602b      	str	r3, [r5, #0]
   2afde:	e7d3      	b.n	2af88 <_free_r+0x24>
   2afe0:	6820      	ldr	r0, [r4, #0]
   2afe2:	1821      	adds	r1, r4, r0
   2afe4:	428a      	cmp	r2, r1
   2afe6:	bf02      	ittt	eq
   2afe8:	6811      	ldreq	r1, [r2, #0]
   2afea:	6852      	ldreq	r2, [r2, #4]
   2afec:	1809      	addeq	r1, r1, r0
   2afee:	6062      	str	r2, [r4, #4]
   2aff0:	bf08      	it	eq
   2aff2:	6021      	streq	r1, [r4, #0]
   2aff4:	605c      	str	r4, [r3, #4]
   2aff6:	e7c7      	b.n	2af88 <_free_r+0x24>
   2aff8:	bd38      	pop	{r3, r4, r5, pc}
   2affa:	bf00      	nop
   2affc:	2002d408 	.word	0x2002d408

0002b000 <_malloc_r>:
   2b000:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2b002:	1ccd      	adds	r5, r1, #3
   2b004:	4606      	mov	r6, r0
   2b006:	f025 0503 	bic.w	r5, r5, #3
   2b00a:	3508      	adds	r5, #8
   2b00c:	2d0c      	cmp	r5, #12
   2b00e:	bf38      	it	cc
   2b010:	250c      	movcc	r5, #12
   2b012:	2d00      	cmp	r5, #0
   2b014:	db01      	blt.n	2b01a <_malloc_r+0x1a>
   2b016:	42a9      	cmp	r1, r5
   2b018:	d903      	bls.n	2b022 <_malloc_r+0x22>
   2b01a:	230c      	movs	r3, #12
   2b01c:	6033      	str	r3, [r6, #0]
   2b01e:	2000      	movs	r0, #0
   2b020:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2b022:	f000 f9bf 	bl	2b3a4 <__malloc_lock>
   2b026:	4921      	ldr	r1, [pc, #132]	; (2b0ac <_malloc_r+0xac>)
   2b028:	680a      	ldr	r2, [r1, #0]
   2b02a:	4614      	mov	r4, r2
   2b02c:	b99c      	cbnz	r4, 2b056 <_malloc_r+0x56>
   2b02e:	4f20      	ldr	r7, [pc, #128]	; (2b0b0 <_malloc_r+0xb0>)
   2b030:	683b      	ldr	r3, [r7, #0]
   2b032:	b923      	cbnz	r3, 2b03e <_malloc_r+0x3e>
   2b034:	4621      	mov	r1, r4
   2b036:	4630      	mov	r0, r6
   2b038:	f000 f934 	bl	2b2a4 <_sbrk_r>
   2b03c:	6038      	str	r0, [r7, #0]
   2b03e:	4629      	mov	r1, r5
   2b040:	4630      	mov	r0, r6
   2b042:	f000 f92f 	bl	2b2a4 <_sbrk_r>
   2b046:	1c43      	adds	r3, r0, #1
   2b048:	d123      	bne.n	2b092 <_malloc_r+0x92>
   2b04a:	230c      	movs	r3, #12
   2b04c:	4630      	mov	r0, r6
   2b04e:	6033      	str	r3, [r6, #0]
   2b050:	f000 f9ae 	bl	2b3b0 <__malloc_unlock>
   2b054:	e7e3      	b.n	2b01e <_malloc_r+0x1e>
   2b056:	6823      	ldr	r3, [r4, #0]
   2b058:	1b5b      	subs	r3, r3, r5
   2b05a:	d417      	bmi.n	2b08c <_malloc_r+0x8c>
   2b05c:	2b0b      	cmp	r3, #11
   2b05e:	d903      	bls.n	2b068 <_malloc_r+0x68>
   2b060:	6023      	str	r3, [r4, #0]
   2b062:	441c      	add	r4, r3
   2b064:	6025      	str	r5, [r4, #0]
   2b066:	e004      	b.n	2b072 <_malloc_r+0x72>
   2b068:	6863      	ldr	r3, [r4, #4]
   2b06a:	42a2      	cmp	r2, r4
   2b06c:	bf0c      	ite	eq
   2b06e:	600b      	streq	r3, [r1, #0]
   2b070:	6053      	strne	r3, [r2, #4]
   2b072:	4630      	mov	r0, r6
   2b074:	f000 f99c 	bl	2b3b0 <__malloc_unlock>
   2b078:	f104 000b 	add.w	r0, r4, #11
   2b07c:	1d23      	adds	r3, r4, #4
   2b07e:	f020 0007 	bic.w	r0, r0, #7
   2b082:	1ac2      	subs	r2, r0, r3
   2b084:	d0cc      	beq.n	2b020 <_malloc_r+0x20>
   2b086:	1a1b      	subs	r3, r3, r0
   2b088:	50a3      	str	r3, [r4, r2]
   2b08a:	e7c9      	b.n	2b020 <_malloc_r+0x20>
   2b08c:	4622      	mov	r2, r4
   2b08e:	6864      	ldr	r4, [r4, #4]
   2b090:	e7cc      	b.n	2b02c <_malloc_r+0x2c>
   2b092:	1cc4      	adds	r4, r0, #3
   2b094:	f024 0403 	bic.w	r4, r4, #3
   2b098:	42a0      	cmp	r0, r4
   2b09a:	d0e3      	beq.n	2b064 <_malloc_r+0x64>
   2b09c:	1a21      	subs	r1, r4, r0
   2b09e:	4630      	mov	r0, r6
   2b0a0:	f000 f900 	bl	2b2a4 <_sbrk_r>
   2b0a4:	3001      	adds	r0, #1
   2b0a6:	d1dd      	bne.n	2b064 <_malloc_r+0x64>
   2b0a8:	e7cf      	b.n	2b04a <_malloc_r+0x4a>
   2b0aa:	bf00      	nop
   2b0ac:	2002d408 	.word	0x2002d408
   2b0b0:	2002d40c 	.word	0x2002d40c

0002b0b4 <_svfiprintf_r>:
   2b0b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2b0b8:	461e      	mov	r6, r3
   2b0ba:	898b      	ldrh	r3, [r1, #12]
   2b0bc:	b09d      	sub	sp, #116	; 0x74
   2b0be:	4607      	mov	r7, r0
   2b0c0:	061b      	lsls	r3, r3, #24
   2b0c2:	460d      	mov	r5, r1
   2b0c4:	4614      	mov	r4, r2
   2b0c6:	d50e      	bpl.n	2b0e6 <_svfiprintf_r+0x32>
   2b0c8:	690b      	ldr	r3, [r1, #16]
   2b0ca:	b963      	cbnz	r3, 2b0e6 <_svfiprintf_r+0x32>
   2b0cc:	2140      	movs	r1, #64	; 0x40
   2b0ce:	f7ff ff97 	bl	2b000 <_malloc_r>
   2b0d2:	6028      	str	r0, [r5, #0]
   2b0d4:	6128      	str	r0, [r5, #16]
   2b0d6:	b920      	cbnz	r0, 2b0e2 <_svfiprintf_r+0x2e>
   2b0d8:	230c      	movs	r3, #12
   2b0da:	603b      	str	r3, [r7, #0]
   2b0dc:	f04f 30ff 	mov.w	r0, #4294967295
   2b0e0:	e0c9      	b.n	2b276 <_svfiprintf_r+0x1c2>
   2b0e2:	2340      	movs	r3, #64	; 0x40
   2b0e4:	616b      	str	r3, [r5, #20]
   2b0e6:	2300      	movs	r3, #0
   2b0e8:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 2b290 <_svfiprintf_r+0x1dc>
   2b0ec:	f04f 0a01 	mov.w	sl, #1
   2b0f0:	9603      	str	r6, [sp, #12]
   2b0f2:	9309      	str	r3, [sp, #36]	; 0x24
   2b0f4:	2320      	movs	r3, #32
   2b0f6:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   2b0fa:	2330      	movs	r3, #48	; 0x30
   2b0fc:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   2b100:	4623      	mov	r3, r4
   2b102:	461e      	mov	r6, r3
   2b104:	f813 2b01 	ldrb.w	r2, [r3], #1
   2b108:	b10a      	cbz	r2, 2b10e <_svfiprintf_r+0x5a>
   2b10a:	2a25      	cmp	r2, #37	; 0x25
   2b10c:	d1f9      	bne.n	2b102 <_svfiprintf_r+0x4e>
   2b10e:	ebb6 0b04 	subs.w	fp, r6, r4
   2b112:	d00b      	beq.n	2b12c <_svfiprintf_r+0x78>
   2b114:	465b      	mov	r3, fp
   2b116:	4622      	mov	r2, r4
   2b118:	4629      	mov	r1, r5
   2b11a:	4638      	mov	r0, r7
   2b11c:	f004 fef4 	bl	2ff08 <__ssputs_r>
   2b120:	3001      	adds	r0, #1
   2b122:	f000 80a3 	beq.w	2b26c <_svfiprintf_r+0x1b8>
   2b126:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2b128:	445b      	add	r3, fp
   2b12a:	9309      	str	r3, [sp, #36]	; 0x24
   2b12c:	7833      	ldrb	r3, [r6, #0]
   2b12e:	2b00      	cmp	r3, #0
   2b130:	f000 809c 	beq.w	2b26c <_svfiprintf_r+0x1b8>
   2b134:	2300      	movs	r3, #0
   2b136:	f04f 32ff 	mov.w	r2, #4294967295
   2b13a:	3601      	adds	r6, #1
   2b13c:	9304      	str	r3, [sp, #16]
   2b13e:	9307      	str	r3, [sp, #28]
   2b140:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   2b144:	931a      	str	r3, [sp, #104]	; 0x68
   2b146:	e9cd 2305 	strd	r2, r3, [sp, #20]
   2b14a:	4634      	mov	r4, r6
   2b14c:	2205      	movs	r2, #5
   2b14e:	4850      	ldr	r0, [pc, #320]	; (2b290 <_svfiprintf_r+0x1dc>)
   2b150:	f814 1b01 	ldrb.w	r1, [r4], #1
   2b154:	f004 f8e2 	bl	2f31c <memchr>
   2b158:	9b04      	ldr	r3, [sp, #16]
   2b15a:	b9c0      	cbnz	r0, 2b18e <_svfiprintf_r+0xda>
   2b15c:	06d9      	lsls	r1, r3, #27
   2b15e:	bf44      	itt	mi
   2b160:	2220      	movmi	r2, #32
   2b162:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   2b166:	071a      	lsls	r2, r3, #28
   2b168:	bf44      	itt	mi
   2b16a:	222b      	movmi	r2, #43	; 0x2b
   2b16c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   2b170:	7832      	ldrb	r2, [r6, #0]
   2b172:	2a2a      	cmp	r2, #42	; 0x2a
   2b174:	d013      	beq.n	2b19e <_svfiprintf_r+0xea>
   2b176:	4634      	mov	r4, r6
   2b178:	9a07      	ldr	r2, [sp, #28]
   2b17a:	2000      	movs	r0, #0
   2b17c:	260a      	movs	r6, #10
   2b17e:	4621      	mov	r1, r4
   2b180:	f811 3b01 	ldrb.w	r3, [r1], #1
   2b184:	3b30      	subs	r3, #48	; 0x30
   2b186:	2b09      	cmp	r3, #9
   2b188:	d94b      	bls.n	2b222 <_svfiprintf_r+0x16e>
   2b18a:	b970      	cbnz	r0, 2b1aa <_svfiprintf_r+0xf6>
   2b18c:	e014      	b.n	2b1b8 <_svfiprintf_r+0x104>
   2b18e:	eba0 0009 	sub.w	r0, r0, r9
   2b192:	4626      	mov	r6, r4
   2b194:	fa0a f000 	lsl.w	r0, sl, r0
   2b198:	4318      	orrs	r0, r3
   2b19a:	9004      	str	r0, [sp, #16]
   2b19c:	e7d5      	b.n	2b14a <_svfiprintf_r+0x96>
   2b19e:	9a03      	ldr	r2, [sp, #12]
   2b1a0:	1d11      	adds	r1, r2, #4
   2b1a2:	6812      	ldr	r2, [r2, #0]
   2b1a4:	2a00      	cmp	r2, #0
   2b1a6:	9103      	str	r1, [sp, #12]
   2b1a8:	db01      	blt.n	2b1ae <_svfiprintf_r+0xfa>
   2b1aa:	9207      	str	r2, [sp, #28]
   2b1ac:	e004      	b.n	2b1b8 <_svfiprintf_r+0x104>
   2b1ae:	4252      	negs	r2, r2
   2b1b0:	f043 0302 	orr.w	r3, r3, #2
   2b1b4:	9207      	str	r2, [sp, #28]
   2b1b6:	9304      	str	r3, [sp, #16]
   2b1b8:	7823      	ldrb	r3, [r4, #0]
   2b1ba:	2b2e      	cmp	r3, #46	; 0x2e
   2b1bc:	d10c      	bne.n	2b1d8 <_svfiprintf_r+0x124>
   2b1be:	7863      	ldrb	r3, [r4, #1]
   2b1c0:	2b2a      	cmp	r3, #42	; 0x2a
   2b1c2:	d133      	bne.n	2b22c <_svfiprintf_r+0x178>
   2b1c4:	9b03      	ldr	r3, [sp, #12]
   2b1c6:	3402      	adds	r4, #2
   2b1c8:	1d1a      	adds	r2, r3, #4
   2b1ca:	681b      	ldr	r3, [r3, #0]
   2b1cc:	2b00      	cmp	r3, #0
   2b1ce:	9203      	str	r2, [sp, #12]
   2b1d0:	bfb8      	it	lt
   2b1d2:	f04f 33ff 	movlt.w	r3, #4294967295
   2b1d6:	9305      	str	r3, [sp, #20]
   2b1d8:	4e2e      	ldr	r6, [pc, #184]	; (2b294 <_svfiprintf_r+0x1e0>)
   2b1da:	2203      	movs	r2, #3
   2b1dc:	7821      	ldrb	r1, [r4, #0]
   2b1de:	4630      	mov	r0, r6
   2b1e0:	f004 f89c 	bl	2f31c <memchr>
   2b1e4:	b138      	cbz	r0, 2b1f6 <_svfiprintf_r+0x142>
   2b1e6:	2340      	movs	r3, #64	; 0x40
   2b1e8:	1b80      	subs	r0, r0, r6
   2b1ea:	3401      	adds	r4, #1
   2b1ec:	fa03 f000 	lsl.w	r0, r3, r0
   2b1f0:	9b04      	ldr	r3, [sp, #16]
   2b1f2:	4303      	orrs	r3, r0
   2b1f4:	9304      	str	r3, [sp, #16]
   2b1f6:	f814 1b01 	ldrb.w	r1, [r4], #1
   2b1fa:	2206      	movs	r2, #6
   2b1fc:	4826      	ldr	r0, [pc, #152]	; (2b298 <_svfiprintf_r+0x1e4>)
   2b1fe:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   2b202:	f004 f88b 	bl	2f31c <memchr>
   2b206:	2800      	cmp	r0, #0
   2b208:	d038      	beq.n	2b27c <_svfiprintf_r+0x1c8>
   2b20a:	4b24      	ldr	r3, [pc, #144]	; (2b29c <_svfiprintf_r+0x1e8>)
   2b20c:	bb13      	cbnz	r3, 2b254 <_svfiprintf_r+0x1a0>
   2b20e:	9b03      	ldr	r3, [sp, #12]
   2b210:	3307      	adds	r3, #7
   2b212:	f023 0307 	bic.w	r3, r3, #7
   2b216:	3308      	adds	r3, #8
   2b218:	9303      	str	r3, [sp, #12]
   2b21a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   2b21c:	4443      	add	r3, r8
   2b21e:	9309      	str	r3, [sp, #36]	; 0x24
   2b220:	e76e      	b.n	2b100 <_svfiprintf_r+0x4c>
   2b222:	fb06 3202 	mla	r2, r6, r2, r3
   2b226:	2001      	movs	r0, #1
   2b228:	460c      	mov	r4, r1
   2b22a:	e7a8      	b.n	2b17e <_svfiprintf_r+0xca>
   2b22c:	2300      	movs	r3, #0
   2b22e:	3401      	adds	r4, #1
   2b230:	260a      	movs	r6, #10
   2b232:	4619      	mov	r1, r3
   2b234:	9305      	str	r3, [sp, #20]
   2b236:	4620      	mov	r0, r4
   2b238:	f810 2b01 	ldrb.w	r2, [r0], #1
   2b23c:	3a30      	subs	r2, #48	; 0x30
   2b23e:	2a09      	cmp	r2, #9
   2b240:	d903      	bls.n	2b24a <_svfiprintf_r+0x196>
   2b242:	2b00      	cmp	r3, #0
   2b244:	d0c8      	beq.n	2b1d8 <_svfiprintf_r+0x124>
   2b246:	9105      	str	r1, [sp, #20]
   2b248:	e7c6      	b.n	2b1d8 <_svfiprintf_r+0x124>
   2b24a:	fb06 2101 	mla	r1, r6, r1, r2
   2b24e:	2301      	movs	r3, #1
   2b250:	4604      	mov	r4, r0
   2b252:	e7f0      	b.n	2b236 <_svfiprintf_r+0x182>
   2b254:	ab03      	add	r3, sp, #12
   2b256:	462a      	mov	r2, r5
   2b258:	a904      	add	r1, sp, #16
   2b25a:	4638      	mov	r0, r7
   2b25c:	9300      	str	r3, [sp, #0]
   2b25e:	4b10      	ldr	r3, [pc, #64]	; (2b2a0 <_svfiprintf_r+0x1ec>)
   2b260:	f7fe fec2 	bl	29fe8 <_printf_float>
   2b264:	f1b0 3fff 	cmp.w	r0, #4294967295
   2b268:	4680      	mov	r8, r0
   2b26a:	d1d6      	bne.n	2b21a <_svfiprintf_r+0x166>
   2b26c:	89ab      	ldrh	r3, [r5, #12]
   2b26e:	065b      	lsls	r3, r3, #25
   2b270:	f53f af34 	bmi.w	2b0dc <_svfiprintf_r+0x28>
   2b274:	9809      	ldr	r0, [sp, #36]	; 0x24
   2b276:	b01d      	add	sp, #116	; 0x74
   2b278:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2b27c:	ab03      	add	r3, sp, #12
   2b27e:	462a      	mov	r2, r5
   2b280:	a904      	add	r1, sp, #16
   2b282:	4638      	mov	r0, r7
   2b284:	9300      	str	r3, [sp, #0]
   2b286:	4b06      	ldr	r3, [pc, #24]	; (2b2a0 <_svfiprintf_r+0x1ec>)
   2b288:	f7ff f8d8 	bl	2a43c <_printf_i>
   2b28c:	e7ea      	b.n	2b264 <_svfiprintf_r+0x1b0>
   2b28e:	bf00      	nop
   2b290:	00034f16 	.word	0x00034f16
   2b294:	00034f1c 	.word	0x00034f1c
   2b298:	00034f20 	.word	0x00034f20
   2b29c:	00029fe9 	.word	0x00029fe9
   2b2a0:	0002ff09 	.word	0x0002ff09

0002b2a4 <_sbrk_r>:
   2b2a4:	b538      	push	{r3, r4, r5, lr}
   2b2a6:	2300      	movs	r3, #0
   2b2a8:	4c05      	ldr	r4, [pc, #20]	; (2b2c0 <_sbrk_r+0x1c>)
   2b2aa:	4605      	mov	r5, r0
   2b2ac:	4608      	mov	r0, r1
   2b2ae:	6023      	str	r3, [r4, #0]
   2b2b0:	f7ee fe1a 	bl	19ee8 <_sbrk>
   2b2b4:	1c43      	adds	r3, r0, #1
   2b2b6:	d102      	bne.n	2b2be <_sbrk_r+0x1a>
   2b2b8:	6823      	ldr	r3, [r4, #0]
   2b2ba:	b103      	cbz	r3, 2b2be <_sbrk_r+0x1a>
   2b2bc:	602b      	str	r3, [r5, #0]
   2b2be:	bd38      	pop	{r3, r4, r5, pc}
   2b2c0:	20031604 	.word	0x20031604

0002b2c4 <raise>:
   2b2c4:	4b02      	ldr	r3, [pc, #8]	; (2b2d0 <raise+0xc>)
   2b2c6:	4601      	mov	r1, r0
   2b2c8:	6818      	ldr	r0, [r3, #0]
   2b2ca:	f004 be78 	b.w	2ffbe <_raise_r>
   2b2ce:	bf00      	nop
   2b2d0:	200383d4 	.word	0x200383d4

0002b2d4 <_kill_r>:
   2b2d4:	b538      	push	{r3, r4, r5, lr}
   2b2d6:	2300      	movs	r3, #0
   2b2d8:	4c06      	ldr	r4, [pc, #24]	; (2b2f4 <_kill_r+0x20>)
   2b2da:	4605      	mov	r5, r0
   2b2dc:	4608      	mov	r0, r1
   2b2de:	4611      	mov	r1, r2
   2b2e0:	6023      	str	r3, [r4, #0]
   2b2e2:	f002 f9a4 	bl	2d62e <_kill>
   2b2e6:	1c43      	adds	r3, r0, #1
   2b2e8:	d102      	bne.n	2b2f0 <_kill_r+0x1c>
   2b2ea:	6823      	ldr	r3, [r4, #0]
   2b2ec:	b103      	cbz	r3, 2b2f0 <_kill_r+0x1c>
   2b2ee:	602b      	str	r3, [r5, #0]
   2b2f0:	bd38      	pop	{r3, r4, r5, pc}
   2b2f2:	bf00      	nop
   2b2f4:	20031604 	.word	0x20031604

0002b2f8 <_write_r>:
   2b2f8:	b538      	push	{r3, r4, r5, lr}
   2b2fa:	4605      	mov	r5, r0
   2b2fc:	4c06      	ldr	r4, [pc, #24]	; (2b318 <_write_r+0x20>)
   2b2fe:	4608      	mov	r0, r1
   2b300:	4611      	mov	r1, r2
   2b302:	2200      	movs	r2, #0
   2b304:	6022      	str	r2, [r4, #0]
   2b306:	461a      	mov	r2, r3
   2b308:	f002 f986 	bl	2d618 <_write>
   2b30c:	1c43      	adds	r3, r0, #1
   2b30e:	d102      	bne.n	2b316 <_write_r+0x1e>
   2b310:	6823      	ldr	r3, [r4, #0]
   2b312:	b103      	cbz	r3, 2b316 <_write_r+0x1e>
   2b314:	602b      	str	r3, [r5, #0]
   2b316:	bd38      	pop	{r3, r4, r5, pc}
   2b318:	20031604 	.word	0x20031604

0002b31c <_close_r>:
   2b31c:	b538      	push	{r3, r4, r5, lr}
   2b31e:	2300      	movs	r3, #0
   2b320:	4c05      	ldr	r4, [pc, #20]	; (2b338 <_close_r+0x1c>)
   2b322:	4605      	mov	r5, r0
   2b324:	4608      	mov	r0, r1
   2b326:	6023      	str	r3, [r4, #0]
   2b328:	f002 f97a 	bl	2d620 <_close>
   2b32c:	1c43      	adds	r3, r0, #1
   2b32e:	d102      	bne.n	2b336 <_close_r+0x1a>
   2b330:	6823      	ldr	r3, [r4, #0]
   2b332:	b103      	cbz	r3, 2b336 <_close_r+0x1a>
   2b334:	602b      	str	r3, [r5, #0]
   2b336:	bd38      	pop	{r3, r4, r5, pc}
   2b338:	20031604 	.word	0x20031604

0002b33c <_fstat_r>:
   2b33c:	b538      	push	{r3, r4, r5, lr}
   2b33e:	2300      	movs	r3, #0
   2b340:	4c06      	ldr	r4, [pc, #24]	; (2b35c <_fstat_r+0x20>)
   2b342:	4605      	mov	r5, r0
   2b344:	4608      	mov	r0, r1
   2b346:	4611      	mov	r1, r2
   2b348:	6023      	str	r3, [r4, #0]
   2b34a:	f002 f974 	bl	2d636 <_fstat>
   2b34e:	1c43      	adds	r3, r0, #1
   2b350:	d102      	bne.n	2b358 <_fstat_r+0x1c>
   2b352:	6823      	ldr	r3, [r4, #0]
   2b354:	b103      	cbz	r3, 2b358 <_fstat_r+0x1c>
   2b356:	602b      	str	r3, [r5, #0]
   2b358:	bd38      	pop	{r3, r4, r5, pc}
   2b35a:	bf00      	nop
   2b35c:	20031604 	.word	0x20031604

0002b360 <_isatty_r>:
   2b360:	b538      	push	{r3, r4, r5, lr}
   2b362:	2300      	movs	r3, #0
   2b364:	4c05      	ldr	r4, [pc, #20]	; (2b37c <_isatty_r+0x1c>)
   2b366:	4605      	mov	r5, r0
   2b368:	4608      	mov	r0, r1
   2b36a:	6023      	str	r3, [r4, #0]
   2b36c:	f002 f95d 	bl	2d62a <_isatty>
   2b370:	1c43      	adds	r3, r0, #1
   2b372:	d102      	bne.n	2b37a <_isatty_r+0x1a>
   2b374:	6823      	ldr	r3, [r4, #0]
   2b376:	b103      	cbz	r3, 2b37a <_isatty_r+0x1a>
   2b378:	602b      	str	r3, [r5, #0]
   2b37a:	bd38      	pop	{r3, r4, r5, pc}
   2b37c:	20031604 	.word	0x20031604

0002b380 <_lseek_r>:
   2b380:	b538      	push	{r3, r4, r5, lr}
   2b382:	4605      	mov	r5, r0
   2b384:	4c06      	ldr	r4, [pc, #24]	; (2b3a0 <_lseek_r+0x20>)
   2b386:	4608      	mov	r0, r1
   2b388:	4611      	mov	r1, r2
   2b38a:	2200      	movs	r2, #0
   2b38c:	6022      	str	r2, [r4, #0]
   2b38e:	461a      	mov	r2, r3
   2b390:	f002 f949 	bl	2d626 <_lseek>
   2b394:	1c43      	adds	r3, r0, #1
   2b396:	d102      	bne.n	2b39e <_lseek_r+0x1e>
   2b398:	6823      	ldr	r3, [r4, #0]
   2b39a:	b103      	cbz	r3, 2b39e <_lseek_r+0x1e>
   2b39c:	602b      	str	r3, [r5, #0]
   2b39e:	bd38      	pop	{r3, r4, r5, pc}
   2b3a0:	20031604 	.word	0x20031604

0002b3a4 <__malloc_lock>:
   2b3a4:	4801      	ldr	r0, [pc, #4]	; (2b3ac <__malloc_lock+0x8>)
   2b3a6:	f004 bab0 	b.w	2f90a <__retarget_lock_acquire_recursive>
   2b3aa:	bf00      	nop
   2b3ac:	2003160c 	.word	0x2003160c

0002b3b0 <__malloc_unlock>:
   2b3b0:	4801      	ldr	r0, [pc, #4]	; (2b3b8 <__malloc_unlock+0x8>)
   2b3b2:	f004 baab 	b.w	2f90c <__retarget_lock_release_recursive>
   2b3b6:	bf00      	nop
   2b3b8:	2003160c 	.word	0x2003160c

0002b3bc <_read_r>:
   2b3bc:	b538      	push	{r3, r4, r5, lr}
   2b3be:	4605      	mov	r5, r0
   2b3c0:	4c06      	ldr	r4, [pc, #24]	; (2b3dc <_read_r+0x20>)
   2b3c2:	4608      	mov	r0, r1
   2b3c4:	4611      	mov	r1, r2
   2b3c6:	2200      	movs	r2, #0
   2b3c8:	6022      	str	r2, [r4, #0]
   2b3ca:	461a      	mov	r2, r3
   2b3cc:	f002 f920 	bl	2d610 <_read>
   2b3d0:	1c43      	adds	r3, r0, #1
   2b3d2:	d102      	bne.n	2b3da <_read_r+0x1e>
   2b3d4:	6823      	ldr	r3, [r4, #0]
   2b3d6:	b103      	cbz	r3, 2b3da <_read_r+0x1e>
   2b3d8:	602b      	str	r3, [r5, #0]
   2b3da:	bd38      	pop	{r3, r4, r5, pc}
   2b3dc:	20031604 	.word	0x20031604

0002b3e0 <main>:
*    : main 
*    :  
*  : int 
**************************************************************************/
int main(void)
{
   2b3e0:	b508      	push	{r3, lr}
	work_init();
   2b3e2:	f7e4 fed7 	bl	10194 <work_init>
	system_init();
   2b3e6:	f7e4 feb7 	bl	10158 <system_init>
//	test_i2c();
//	test_bat_soc();

	while(1)
	{
		TimeMsgProcess();
   2b3ea:	f7e5 fa67 	bl	108bc <TimeMsgProcess>
		NBMsgProcess();
   2b3ee:	f7e9 f90f 	bl	14610 <NBMsgProcess>
		GPSMsgProcess();
   2b3f2:	f7e7 ffbf 	bl	13374 <GPSMsgProcess>
		PMUMsgProcess();
   2b3f6:	f7eb fbe5 	bl	16bc4 <PMUMsgProcess>
		IMUMsgProcess();
   2b3fa:	f7ea f8e7 	bl	155cc <IMUMsgProcess>
		LCDMsgProcess();
   2b3fe:	f7e5 fd5d 	bl	10ebc <LCDMsgProcess>
		//TPMsgProcess();
		AlarmMsgProcess();
   2b402:	f7e5 fb7f 	bl	10b04 <AlarmMsgProcess>
		SettingsMsgPorcess();
   2b406:	f7e6 fbd9 	bl	11bbc <SettingsMsgPorcess>
		SOSMsgProc();
   2b40a:	f7ec f8bb 	bl	17584 <SOSMsgProc>
		
		ScreenMsgProcess();
   2b40e:	f7ea ffaf 	bl	16370 <ScreenMsgProcess>
   2b412:	f7ed fdad 	bl	18f70 <arch_cpu_idle>
   2b416:	e7e8      	b.n	2b3ea <main+0xa>

0002b418 <CheckYearIsLeap>:
	if(((years%4 == 0) && (years%100 != 0))||(years%400 == 0))
   2b418:	0783      	lsls	r3, r0, #30
   2b41a:	d105      	bne.n	2b428 <CheckYearIsLeap+0x10>
   2b41c:	2264      	movs	r2, #100	; 0x64
   2b41e:	fbb0 f3f2 	udiv	r3, r0, r2
   2b422:	fb02 0313 	mls	r3, r2, r3, r0
   2b426:	b94b      	cbnz	r3, 2b43c <CheckYearIsLeap+0x24>
   2b428:	f44f 72c8 	mov.w	r2, #400	; 0x190
   2b42c:	fbb0 f3f2 	udiv	r3, r0, r2
   2b430:	fb02 0013 	mls	r0, r2, r3, r0
		return 1;
   2b434:	fab0 f080 	clz	r0, r0
   2b438:	0940      	lsrs	r0, r0, #5
   2b43a:	4770      	bx	lr
   2b43c:	2001      	movs	r0, #1
}
   2b43e:	4770      	bx	lr

0002b440 <GetWeekDayByDate>:
{
   2b440:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2b442:	ab02      	add	r3, sp, #8
   2b444:	e903 0003 	stmdb	r3, {r0, r1}
   2b448:	f8bd 0000 	ldrh.w	r0, [sp]
	if(date.year < SYSTEM_STARTING_YEAR)
   2b44c:	f5b0 6ff0 	cmp.w	r0, #1920	; 0x780
   2b450:	d359      	bcc.n	2b506 <GetWeekDayByDate+0xc6>
	u32_t i,count=0;
   2b452:	2100      	movs	r1, #0
	for(i=SYSTEM_STARTING_YEAR;i<date.year;i++)
   2b454:	f44f 63f0 	mov.w	r3, #1920	; 0x780
		if(((i%4 == 0)&&(i%100 != 0))||(i%400 == 0))	//366
   2b458:	f44f 74c8 	mov.w	r4, #400	; 0x190
   2b45c:	2564      	movs	r5, #100	; 0x64
	for(i=SYSTEM_STARTING_YEAR;i<date.year;i++)
   2b45e:	4298      	cmp	r0, r3
   2b460:	d812      	bhi.n	2b488 <GetWeekDayByDate+0x48>
	if(CheckYearIsLeap(date.year))
   2b462:	f7ff ffd9 	bl	2b418 <CheckYearIsLeap>
	switch(date.month)
   2b466:	f89d 3002 	ldrb.w	r3, [sp, #2]
	if(CheckYearIsLeap(date.year))
   2b46a:	3000      	adds	r0, #0
	switch(date.month)
   2b46c:	f1a3 0302 	sub.w	r3, r3, #2
	if(CheckYearIsLeap(date.year))
   2b470:	bf18      	it	ne
   2b472:	2001      	movne	r0, #1
	switch(date.month)
   2b474:	2b0a      	cmp	r3, #10
   2b476:	d81b      	bhi.n	2b4b0 <GetWeekDayByDate+0x70>
   2b478:	e8df f003 	tbb	[pc, r3]
   2b47c:	32302d19 	.word	0x32302d19
   2b480:	3a383634 	.word	0x3a383634
   2b484:	3f3c      	.short	0x3f3c
   2b486:	42          	.byte	0x42
   2b487:	00          	.byte	0x00
		if(((i%4 == 0)&&(i%100 != 0))||(i%400 == 0))	//366
   2b488:	079a      	lsls	r2, r3, #30
   2b48a:	d104      	bne.n	2b496 <GetWeekDayByDate+0x56>
   2b48c:	fbb3 f2f5 	udiv	r2, r3, r5
   2b490:	fb05 3212 	mls	r2, r5, r2, r3
   2b494:	b922      	cbnz	r2, 2b4a0 <GetWeekDayByDate+0x60>
   2b496:	fbb3 f2f4 	udiv	r2, r3, r4
   2b49a:	fb04 3212 	mls	r2, r4, r2, r3
   2b49e:	b91a      	cbnz	r2, 2b4a8 <GetWeekDayByDate+0x68>
			count += 366;
   2b4a0:	f501 71b7 	add.w	r1, r1, #366	; 0x16e
	for(i=SYSTEM_STARTING_YEAR;i<date.year;i++)
   2b4a4:	3301      	adds	r3, #1
   2b4a6:	e7da      	b.n	2b45e <GetWeekDayByDate+0x1e>
			count += 365;
   2b4a8:	f201 116d 	addw	r1, r1, #365	; 0x16d
   2b4ac:	e7fa      	b.n	2b4a4 <GetWeekDayByDate+0x64>
		count += 31;
   2b4ae:	311f      	adds	r1, #31
	count = count%7;
   2b4b0:	2307      	movs	r3, #7
	count += (date.day-1);
   2b4b2:	f89d 0003 	ldrb.w	r0, [sp, #3]
   2b4b6:	3801      	subs	r0, #1
   2b4b8:	4401      	add	r1, r0
	count = count%7;
   2b4ba:	fbb1 f0f3 	udiv	r0, r1, r3
   2b4be:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
   2b4c2:	1a09      	subs	r1, r1, r0
	index = (index+count)%7;
   2b4c4:	1d08      	adds	r0, r1, #4
   2b4c6:	fbb0 f3f3 	udiv	r3, r0, r3
   2b4ca:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   2b4ce:	1ac0      	subs	r0, r0, r3
   2b4d0:	b2c0      	uxtb	r0, r0
}
   2b4d2:	b003      	add	sp, #12
   2b4d4:	bd30      	pop	{r4, r5, pc}
		count += (31+(28+flag));
   2b4d6:	313b      	adds	r1, #59	; 0x3b
		count += (6*31+4*30+(28+flag));
   2b4d8:	4401      	add	r1, r0
		break;			
   2b4da:	e7e9      	b.n	2b4b0 <GetWeekDayByDate+0x70>
		count += (2*31+(28+flag));
   2b4dc:	315a      	adds	r1, #90	; 0x5a
   2b4de:	e7fb      	b.n	2b4d8 <GetWeekDayByDate+0x98>
		count += (2*31+30+(28+flag));
   2b4e0:	3178      	adds	r1, #120	; 0x78
   2b4e2:	e7f9      	b.n	2b4d8 <GetWeekDayByDate+0x98>
		count += (3*31+30+(28+flag));
   2b4e4:	3197      	adds	r1, #151	; 0x97
   2b4e6:	e7f7      	b.n	2b4d8 <GetWeekDayByDate+0x98>
		count += (3*31+2*30+(28+flag));
   2b4e8:	31b5      	adds	r1, #181	; 0xb5
   2b4ea:	e7f5      	b.n	2b4d8 <GetWeekDayByDate+0x98>
		count += (4*31+2*30+(28+flag));
   2b4ec:	31d4      	adds	r1, #212	; 0xd4
   2b4ee:	e7f3      	b.n	2b4d8 <GetWeekDayByDate+0x98>
		count += (5*31+2*30+(28+flag));
   2b4f0:	31f3      	adds	r1, #243	; 0xf3
   2b4f2:	e7f1      	b.n	2b4d8 <GetWeekDayByDate+0x98>
		count += (5*31+3*30+(28+flag));
   2b4f4:	f201 1111 	addw	r1, r1, #273	; 0x111
   2b4f8:	e7ee      	b.n	2b4d8 <GetWeekDayByDate+0x98>
		count += (6*31+3*30+(28+flag));
   2b4fa:	f501 7198 	add.w	r1, r1, #304	; 0x130
   2b4fe:	e7eb      	b.n	2b4d8 <GetWeekDayByDate+0x98>
		count += (6*31+4*30+(28+flag));
   2b500:	f501 71a7 	add.w	r1, r1, #334	; 0x14e
   2b504:	e7e8      	b.n	2b4d8 <GetWeekDayByDate+0x98>
		return 0xff;
   2b506:	20ff      	movs	r0, #255	; 0xff
   2b508:	e7e3      	b.n	2b4d2 <GetWeekDayByDate+0x92>

0002b50a <CheckSystemDateTimeIsValid>:
{
   2b50a:	b082      	sub	sp, #8
   2b50c:	ab02      	add	r3, sp, #8
   2b50e:	e903 0003 	stmdb	r3, {r0, r1}
	if((systime.year<SYSTEM_STARTING_YEAR || systime.year>9999)
   2b512:	f641 718f 	movw	r1, #8079	; 0x1f8f
   2b516:	f8bd 2000 	ldrh.w	r2, [sp]
   2b51a:	f5a2 63f0 	sub.w	r3, r2, #1920	; 0x780
   2b51e:	b29b      	uxth	r3, r3
   2b520:	428b      	cmp	r3, r1
   2b522:	d816      	bhi.n	2b552 <CheckSystemDateTimeIsValid+0x48>
   2b524:	f89d 3002 	ldrb.w	r3, [sp, #2]
		|| ((systime.month==0)||(systime.month>12)) 
   2b528:	1e59      	subs	r1, r3, #1
   2b52a:	290b      	cmp	r1, #11
   2b52c:	d811      	bhi.n	2b552 <CheckSystemDateTimeIsValid+0x48>
   2b52e:	f89d 0003 	ldrb.w	r0, [sp, #3]
		|| (systime.day==0) 
   2b532:	b338      	cbz	r0, 2b584 <CheckSystemDateTimeIsValid+0x7a>
		|| ((systime.day>31)&&((systime.month==1)||(systime.month==3)||(systime.month==5)||(systime.month==7)||(systime.month==8)||(systime.month==10)||(systime.month==12)))
   2b534:	281f      	cmp	r0, #31
   2b536:	d90e      	bls.n	2b556 <CheckSystemDateTimeIsValid+0x4c>
   2b538:	f241 50aa 	movw	r0, #5546	; 0x15aa
   2b53c:	40d8      	lsrs	r0, r3
   2b53e:	43c0      	mvns	r0, r0
   2b540:	f010 0001 	ands.w	r0, r0, #1
   2b544:	d01e      	beq.n	2b584 <CheckSystemDateTimeIsValid+0x7a>
		|| ((systime.day>30)&&((systime.month==4)||(systime.month==6)||(systime.month==9)||(systime.month==11)))
   2b546:	f003 02fd 	and.w	r2, r3, #253	; 0xfd
   2b54a:	2a04      	cmp	r2, #4
   2b54c:	d001      	beq.n	2b552 <CheckSystemDateTimeIsValid+0x48>
   2b54e:	2a09      	cmp	r2, #9
   2b550:	d104      	bne.n	2b55c <CheckSystemDateTimeIsValid+0x52>
		ret = false;
   2b552:	2000      	movs	r0, #0
   2b554:	e016      	b.n	2b584 <CheckSystemDateTimeIsValid+0x7a>
		|| ((systime.day>30)&&((systime.month==4)||(systime.month==6)||(systime.month==9)||(systime.month==11)))
   2b556:	d0f6      	beq.n	2b546 <CheckSystemDateTimeIsValid+0x3c>
		|| ((systime.day>29)&&((systime.month==2)&&(systime.year%4==0)))
   2b558:	281e      	cmp	r0, #30
   2b55a:	d115      	bne.n	2b588 <CheckSystemDateTimeIsValid+0x7e>
   2b55c:	2b02      	cmp	r3, #2
   2b55e:	d0f8      	beq.n	2b552 <CheckSystemDateTimeIsValid+0x48>
		|| ((systime.hour>23)||(systime.minute>59)||(systime.second>59))
   2b560:	f89d 3004 	ldrb.w	r3, [sp, #4]
   2b564:	2b17      	cmp	r3, #23
   2b566:	d8f4      	bhi.n	2b552 <CheckSystemDateTimeIsValid+0x48>
   2b568:	f89d 3005 	ldrb.w	r3, [sp, #5]
   2b56c:	2b3b      	cmp	r3, #59	; 0x3b
   2b56e:	d8f0      	bhi.n	2b552 <CheckSystemDateTimeIsValid+0x48>
   2b570:	f89d 3006 	ldrb.w	r3, [sp, #6]
   2b574:	2b3b      	cmp	r3, #59	; 0x3b
   2b576:	d8ec      	bhi.n	2b552 <CheckSystemDateTimeIsValid+0x48>
		|| (systime.week>6))
   2b578:	f89d 0007 	ldrb.w	r0, [sp, #7]
   2b57c:	2806      	cmp	r0, #6
   2b57e:	bf8c      	ite	hi
   2b580:	2000      	movhi	r0, #0
   2b582:	2001      	movls	r0, #1
}
   2b584:	b002      	add	sp, #8
   2b586:	4770      	bx	lr
		|| ((systime.day>28)&&((systime.month==2)&&(systime.year%4!=0)))
   2b588:	281d      	cmp	r0, #29
   2b58a:	d1e9      	bne.n	2b560 <CheckSystemDateTimeIsValid+0x56>
   2b58c:	2b02      	cmp	r3, #2
   2b58e:	d1e7      	bne.n	2b560 <CheckSystemDateTimeIsValid+0x56>
   2b590:	0793      	lsls	r3, r2, #30
   2b592:	d1de      	bne.n	2b552 <CheckSystemDateTimeIsValid+0x48>
   2b594:	e7e4      	b.n	2b560 <CheckSystemDateTimeIsValid+0x56>

0002b596 <AlarmRemindEntryScreen>:
{
   2b596:	b508      	push	{r3, lr}
	EnterAlarmScreen();
   2b598:	f7ea fe80 	bl	1629c <EnterAlarmScreen>
}
   2b59c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	AlarmRemindStart();
   2b5a0:	f7e5 b9e4 	b.w	1096c <AlarmRemindStart>

0002b5a4 <FindDeviceEntryScreen>:
{
   2b5a4:	b508      	push	{r3, lr}
	EnterFindDeviceScreen();
   2b5a6:	f7ea fe8f 	bl	162c8 <EnterFindDeviceScreen>
}
   2b5aa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	FindDeviceStart();
   2b5ae:	f7e5 ba75 	b.w	10a9c <FindDeviceStart>

0002b5b2 <k_sleep>:
	return z_impl_k_sleep(ms);
   2b5b2:	f7fc bf59 	b.w	28468 <z_impl_k_sleep>

0002b5b6 <gpio_pin_write>:
{
   2b5b6:	b410      	push	{r4}
   2b5b8:	4613      	mov	r3, r2
	return api->write(port, access_op, pin, value);
   2b5ba:	6842      	ldr	r2, [r0, #4]
   2b5bc:	6854      	ldr	r4, [r2, #4]
   2b5be:	460a      	mov	r2, r1
   2b5c0:	46a4      	mov	ip, r4
   2b5c2:	2100      	movs	r1, #0
}
   2b5c4:	f85d 4b04 	ldr.w	r4, [sp], #4
	return api->write(port, access_op, pin, value);
   2b5c8:	4760      	bx	ip

0002b5ca <gpio_pin_configure.constprop.2>:
static inline int gpio_pin_configure(struct device *port, u32_t pin,
   2b5ca:	b410      	push	{r4}
   2b5cc:	460a      	mov	r2, r1
	return api->config(port, access_op, pin, flags);
   2b5ce:	6843      	ldr	r3, [r0, #4]
   2b5d0:	2100      	movs	r1, #0
   2b5d2:	681c      	ldr	r4, [r3, #0]
   2b5d4:	2301      	movs	r3, #1
   2b5d6:	46a4      	mov	ip, r4
}
   2b5d8:	f85d 4b04 	ldr.w	r4, [sp], #4
	return api->config(port, access_op, pin, flags);
   2b5dc:	4760      	bx	ip

0002b5de <BlockWrite>:
{
   2b5de:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2b5e2:	4605      	mov	r5, r0
   2b5e4:	4690      	mov	r8, r2
   2b5e6:	460c      	mov	r4, r1
   2b5e8:	461e      	mov	r6, r3
	WriteComm(0x2A);             
   2b5ea:	202a      	movs	r0, #42	; 0x2a
	WriteData(x);             
   2b5ec:	b2ef      	uxtb	r7, r5
	WriteComm(0x2A);             
   2b5ee:	f7e5 fcb7 	bl	10f60 <WriteComm>
	WriteData(x>>8);             
   2b5f2:	f3c5 2007 	ubfx	r0, r5, #8, #8
   2b5f6:	f7e5 fcc3 	bl	10f80 <WriteData>
	WriteData((x+w-1)>>8);             
   2b5fa:	f108 38ff 	add.w	r8, r8, #4294967295
	WriteData(x);             
   2b5fe:	4638      	mov	r0, r7
   2b600:	f7e5 fcbe 	bl	10f80 <WriteData>
	WriteData((x+w-1)>>8);             
   2b604:	eb08 0005 	add.w	r0, r8, r5
   2b608:	f3c0 2007 	ubfx	r0, r0, #8, #8
   2b60c:	f7e5 fcb8 	bl	10f80 <WriteData>
	WriteData((x+w-1));             
   2b610:	eb07 0008 	add.w	r0, r7, r8
   2b614:	b2c0      	uxtb	r0, r0
   2b616:	f7e5 fcb3 	bl	10f80 <WriteData>
	WriteComm(0x2B);             
   2b61a:	202b      	movs	r0, #43	; 0x2b
   2b61c:	f7e5 fca0 	bl	10f60 <WriteComm>
	WriteData(y);             
   2b620:	b2e5      	uxtb	r5, r4
	WriteData(y>>8);             
   2b622:	f3c4 2007 	ubfx	r0, r4, #8, #8
   2b626:	f7e5 fcab 	bl	10f80 <WriteData>
	WriteData((y+h-1)>>8);//	WriteData((Yend+1)>>8);             
   2b62a:	3e01      	subs	r6, #1
	WriteData(y);             
   2b62c:	4628      	mov	r0, r5
   2b62e:	f7e5 fca7 	bl	10f80 <WriteData>
	WriteData((y+h-1)>>8);//	WriteData((Yend+1)>>8);             
   2b632:	1930      	adds	r0, r6, r4
   2b634:	f3c0 2007 	ubfx	r0, r0, #8, #8
   2b638:	f7e5 fca2 	bl	10f80 <WriteData>
	WriteData((y+h-1));//	WriteData(Yend+1);   	
   2b63c:	19a8      	adds	r0, r5, r6
   2b63e:	b2c0      	uxtb	r0, r0
   2b640:	f7e5 fc9e 	bl	10f80 <WriteData>
}
   2b644:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	WriteComm(0x2c);
   2b648:	202c      	movs	r0, #44	; 0x2c
   2b64a:	f7e5 bc89 	b.w	10f60 <WriteComm>

0002b64e <LCD_Clear>:
	BlockWrite(0,0,COL,ROW);//
   2b64e:	2100      	movs	r1, #0
{
   2b650:	b510      	push	{r4, lr}
   2b652:	4604      	mov	r4, r0
	BlockWrite(0,0,COL,ROW);//
   2b654:	23d2      	movs	r3, #210	; 0xd2
   2b656:	4608      	mov	r0, r1
   2b658:	22f0      	movs	r2, #240	; 0xf0
   2b65a:	f7ff ffc0 	bl	2b5de <BlockWrite>
	DispColor(COL*ROW, color);
   2b65e:	4621      	mov	r1, r4
} 
   2b660:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	DispColor(COL*ROW, color);
   2b664:	f24c 40e0 	movw	r0, #50400	; 0xc4e0
   2b668:	f7e5 bc9a 	b.w	10fa0 <DispColor>

0002b66c <is_wearing>:
}
   2b66c:	2001      	movs	r0, #1
   2b66e:	4770      	bx	lr

0002b670 <uart_fifo_fill>:
	if (api->fifo_fill) {
   2b670:	6843      	ldr	r3, [r0, #4]
   2b672:	695b      	ldr	r3, [r3, #20]
   2b674:	b103      	cbz	r3, 2b678 <uart_fifo_fill+0x8>
		return api->fifo_fill(dev, tx_data, size);
   2b676:	4718      	bx	r3
}
   2b678:	4618      	mov	r0, r3
   2b67a:	4770      	bx	lr

0002b67c <z_impl_uart_irq_tx_enable>:
	if (api->irq_tx_enable) {
   2b67c:	6843      	ldr	r3, [r0, #4]
   2b67e:	69db      	ldr	r3, [r3, #28]
   2b680:	b103      	cbz	r3, 2b684 <z_impl_uart_irq_tx_enable+0x8>
		api->irq_tx_enable(dev);
   2b682:	4718      	bx	r3
}
   2b684:	4770      	bx	lr

0002b686 <uart_irq_tx_disable>:
	if (api->irq_tx_disable) {
   2b686:	6843      	ldr	r3, [r0, #4]
   2b688:	6a1b      	ldr	r3, [r3, #32]
   2b68a:	b103      	cbz	r3, 2b68e <uart_irq_tx_disable+0x8>
		api->irq_tx_disable(dev);
   2b68c:	4718      	bx	r3
}
   2b68e:	4770      	bx	lr

0002b690 <APP_get_firmware_version>:
{
   2b690:	b500      	push	{lr}
   2b692:	b0a1      	sub	sp, #132	; 0x84
	u8_t reply[128] = {0};
   2b694:	2100      	movs	r1, #0
   2b696:	2280      	movs	r2, #128	; 0x80
   2b698:	4668      	mov	r0, sp
   2b69a:	f003 fe7b 	bl	2f394 <memset>
	reply[reply_len++] = PACKET_HEAD;
   2b69e:	23ab      	movs	r3, #171	; 0xab
   2b6a0:	f88d 3000 	strb.w	r3, [sp]
	reply[reply_len++] = 0x07;
   2b6a4:	f64f 7307 	movw	r3, #65287	; 0xff07
   2b6a8:	f8ad 3002 	strh.w	r3, [sp, #2]
	reply[reply_len++] = (u8_t)(FIRMWARE_INFOR_ID&0x00ff);
   2b6ac:	f248 0352 	movw	r3, #32850	; 0x8052
   2b6b0:	f8ad 3004 	strh.w	r3, [sp, #4]
	reply[reply_len++] = (0x02<<4)+0x00;	//V2.0
   2b6b4:	2320      	movs	r3, #32
   2b6b6:	f88d 3007 	strb.w	r3, [sp, #7]
	reply[reply_len++] = PACKET_END;
   2b6ba:	2388      	movs	r3, #136	; 0x88
   2b6bc:	4669      	mov	r1, sp
   2b6be:	f88d 3009 	strb.w	r3, [sp, #9]
	for(i=0;i<(reply_len-2);i++)
   2b6c2:	2300      	movs	r3, #0
		reply[reply_len-2] += reply[i];
   2b6c4:	f811 2b01 	ldrb.w	r2, [r1], #1
   2b6c8:	f89d 0008 	ldrb.w	r0, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   2b6cc:	3301      	adds	r3, #1
		reply[reply_len-2] += reply[i];
   2b6ce:	4402      	add	r2, r0
	for(i=0;i<(reply_len-2);i++)
   2b6d0:	2b08      	cmp	r3, #8
		reply[reply_len-2] += reply[i];
   2b6d2:	f88d 2008 	strb.w	r2, [sp, #8]
	for(i=0;i<(reply_len-2);i++)
   2b6d6:	d1f5      	bne.n	2b6c4 <APP_get_firmware_version+0x34>
	ble_send_date_handle(reply, reply_len);
   2b6d8:	210a      	movs	r1, #10
   2b6da:	4668      	mov	r0, sp
   2b6dc:	f7e6 fc66 	bl	11fac <ble_send_date_handle>
}
   2b6e0:	b021      	add	sp, #132	; 0x84
   2b6e2:	f85d fb04 	ldr.w	pc, [sp], #4

0002b6e6 <gpio_add_callback>:
	if (api->manage_callback == NULL) {
   2b6e6:	6843      	ldr	r3, [r0, #4]
   2b6e8:	68db      	ldr	r3, [r3, #12]
   2b6ea:	b10b      	cbz	r3, 2b6f0 <gpio_add_callback+0xa>
	return api->manage_callback(port, callback, true);
   2b6ec:	2201      	movs	r2, #1
   2b6ee:	4718      	bx	r3
}
   2b6f0:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2b6f4:	4770      	bx	lr

0002b6f6 <get_input_degree>:
	if(d == b)                  // Rshoulder
   2b6f6:	eeb4 2a41 	vcmp.f32	s4, s2
	volatile float re_val=0;
   2b6fa:	2300      	movs	r3, #0
	if(d == b)                  // Rshoulder
   2b6fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
   2b700:	b082      	sub	sp, #8
	volatile float re_val=0;
   2b702:	9301      	str	r3, [sp, #4]
	if(d == b)                  // Rshoulder
   2b704:	461a      	mov	r2, r3
   2b706:	d124      	bne.n	2b752 <get_input_degree+0x5c>
		if(x >= b)                     re_val = 1;
   2b708:	eeb4 1ac0 	vcmpe.f32	s2, s0
   2b70c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b710:	d802      	bhi.n	2b718 <get_input_degree+0x22>
		if(x <= c)                     re_val = 1;
   2b712:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   2b716:	e026      	b.n	2b766 <get_input_degree+0x70>
		else if(x > a && x < b)        re_val = (x - a) / (b - a);
   2b718:	eeb4 0ae0 	vcmpe.f32	s0, s1
   2b71c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b720:	dd10      	ble.n	2b744 <get_input_degree+0x4e>
   2b722:	eeb4 1ac0 	vcmpe.f32	s2, s0
   2b726:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b72a:	dd0b      	ble.n	2b744 <get_input_degree+0x4e>
		else if(x < b)                 re_val = (x - a) / (b - a);
   2b72c:	ee30 0a60 	vsub.f32	s0, s0, s1
   2b730:	ee31 1a60 	vsub.f32	s2, s2, s1
   2b734:	eec0 7a01 	vdiv.f32	s15, s0, s2
		else if(x > c && x < d)        re_val = (d - x) / (d - c);
   2b738:	edcd 7a01 	vstr	s15, [sp, #4]
	return re_val;
   2b73c:	ed9d 0a01 	vldr	s0, [sp, #4]
}
   2b740:	b002      	add	sp, #8
   2b742:	4770      	bx	lr
		else if(x <= a)                re_val = 0;
   2b744:	eeb4 0ae0 	vcmpe.f32	s0, s1
		else if(x >= d)                re_val = 0;
   2b748:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b74c:	d8f6      	bhi.n	2b73c <get_input_degree+0x46>
   2b74e:	9201      	str	r2, [sp, #4]
   2b750:	e7f4      	b.n	2b73c <get_input_degree+0x46>
	else if(d == c)             // Triangle
   2b752:	eeb4 2a61 	vcmp.f32	s4, s3
   2b756:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b75a:	d121      	bne.n	2b7a0 <get_input_degree+0xaa>
		if(x <= a)                     re_val = 0;
   2b75c:	eeb4 0ae0 	vcmpe.f32	s0, s1
   2b760:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b764:	d801      	bhi.n	2b76a <get_input_degree+0x74>
	else re_val = 0;
   2b766:	9301      	str	r3, [sp, #4]
   2b768:	e7e8      	b.n	2b73c <get_input_degree+0x46>
		else if(x == b)                re_val = 1;
   2b76a:	eeb4 1a40 	vcmp.f32	s2, s0
   2b76e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b772:	d0ce      	beq.n	2b712 <get_input_degree+0x1c>
		else if(x < b)                 re_val = (x - a) / (b - a);
   2b774:	eeb4 1ac0 	vcmpe.f32	s2, s0
   2b778:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b77c:	dcd6      	bgt.n	2b72c <get_input_degree+0x36>
		else if(x >= c)                re_val = 0;
   2b77e:	eeb4 0ae1 	vcmpe.f32	s0, s3
   2b782:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b786:	daee      	bge.n	2b766 <get_input_degree+0x70>
		else if(x > b)                 re_val = (c - x) / (c - b);
   2b788:	eeb4 1ac0 	vcmpe.f32	s2, s0
   2b78c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b790:	d5d4      	bpl.n	2b73c <get_input_degree+0x46>
   2b792:	ee31 0ac0 	vsub.f32	s0, s3, s0
   2b796:	ee31 2ac1 	vsub.f32	s4, s3, s2
		else if(x > c && x < d)        re_val = (d - x) / (d - c);
   2b79a:	eec0 7a02 	vdiv.f32	s15, s0, s4
   2b79e:	e7cb      	b.n	2b738 <get_input_degree+0x42>
	else if(d == a)             //Lshoulder
   2b7a0:	eeb4 2a60 	vcmp.f32	s4, s1
   2b7a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b7a8:	d1dd      	bne.n	2b766 <get_input_degree+0x70>
		if(x <= c)                     re_val = 1;
   2b7aa:	eeb4 0ae1 	vcmpe.f32	s0, s3
   2b7ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b7b2:	d9ae      	bls.n	2b712 <get_input_degree+0x1c>
		else if(x > c && x < d)        re_val = (d - x) / (d - c);
   2b7b4:	dd09      	ble.n	2b7ca <get_input_degree+0xd4>
   2b7b6:	eeb4 2ac0 	vcmpe.f32	s4, s0
   2b7ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2b7be:	dd04      	ble.n	2b7ca <get_input_degree+0xd4>
   2b7c0:	ee32 0a40 	vsub.f32	s0, s4, s0
   2b7c4:	ee32 2a61 	vsub.f32	s4, s4, s3
   2b7c8:	e7e7      	b.n	2b79a <get_input_degree+0xa4>
		else if(x >= d)                re_val = 0;
   2b7ca:	eeb4 2ac0 	vcmpe.f32	s4, s0
   2b7ce:	e7bb      	b.n	2b748 <get_input_degree+0x52>

0002b7d0 <gpio_pin_disable_callback>:
 * @param port Pointer to the device structure for the driver instance.
 * @param pin Pin number where the callback function is disabled.
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_disable_callback(struct device *port, u32_t pin)
{
   2b7d0:	460a      	mov	r2, r1
	if (api->disable_callback == NULL) {
   2b7d2:	6843      	ldr	r3, [r0, #4]
   2b7d4:	695b      	ldr	r3, [r3, #20]
   2b7d6:	b10b      	cbz	r3, 2b7dc <gpio_pin_disable_callback+0xc>
	return api->disable_callback(port, access_op, pin);
   2b7d8:	2100      	movs	r1, #0
   2b7da:	4718      	bx	r3
	return gpio_disable_callback(port, GPIO_ACCESS_BY_PIN, pin);
}
   2b7dc:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2b7e0:	4770      	bx	lr

0002b7e2 <gpio_pin_enable_callback>:
{
   2b7e2:	460a      	mov	r2, r1
	if (api->enable_callback == NULL) {
   2b7e4:	6843      	ldr	r3, [r0, #4]
   2b7e6:	691b      	ldr	r3, [r3, #16]
   2b7e8:	b10b      	cbz	r3, 2b7ee <gpio_pin_enable_callback+0xc>
	return api->enable_callback(port, access_op, pin);
   2b7ea:	2100      	movs	r1, #0
   2b7ec:	4718      	bx	r3
}
   2b7ee:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2b7f2:	4770      	bx	lr

0002b7f4 <gpio_pin_configure>:
{
   2b7f4:	b410      	push	{r4}
   2b7f6:	4613      	mov	r3, r2
	return api->config(port, access_op, pin, flags);
   2b7f8:	6842      	ldr	r2, [r0, #4]
   2b7fa:	6814      	ldr	r4, [r2, #0]
   2b7fc:	460a      	mov	r2, r1
   2b7fe:	46a4      	mov	ip, r4
   2b800:	2100      	movs	r1, #0
}
   2b802:	f85d 4b04 	ldr.w	r4, [sp], #4
	return api->config(port, access_op, pin, flags);
   2b806:	4760      	bx	ip

0002b808 <lsm6dso_read_reg>:
{
   2b808:	b410      	push	{r4}
  ret = ctx->read_reg(ctx->handle, reg, data, len);
   2b80a:	e9d0 4001 	ldrd	r4, r0, [r0, #4]
   2b80e:	46a4      	mov	ip, r4
}
   2b810:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->read_reg(ctx->handle, reg, data, len);
   2b814:	4760      	bx	ip

0002b816 <lsm6dso_write_reg>:
{
   2b816:	b410      	push	{r4}
  ret = ctx->write_reg(ctx->handle, reg, data, len);
   2b818:	6804      	ldr	r4, [r0, #0]
   2b81a:	6880      	ldr	r0, [r0, #8]
   2b81c:	46a4      	mov	ip, r4
}
   2b81e:	f85d 4b04 	ldr.w	r4, [sp], #4
  ret = ctx->write_reg(ctx->handle, reg, data, len);
   2b822:	4760      	bx	ip

0002b824 <lsm6dso_xl_full_scale_set>:
  * @param  val      change the values of fs_xl in reg CTRL1_XL
  *
  */
int32_t lsm6dso_xl_full_scale_set(stmdev_ctx_t *ctx,
                                  lsm6dso_fs_xl_t val)
{
   2b824:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_ctrl1_xl_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   2b826:	2301      	movs	r3, #1
{
   2b828:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   2b82a:	aa01      	add	r2, sp, #4
   2b82c:	2110      	movs	r1, #16
{
   2b82e:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   2b830:	f7ff ffea 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2b834:	b958      	cbnz	r0, 2b84e <lsm6dso_xl_full_scale_set+0x2a>
    reg.fs_xl = (uint8_t) val;
   2b836:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   2b83a:	aa01      	add	r2, sp, #4
    reg.fs_xl = (uint8_t) val;
   2b83c:	f365 0383 	bfi	r3, r5, #2, #2
   2b840:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   2b844:	2110      	movs	r1, #16
   2b846:	2301      	movs	r3, #1
   2b848:	4620      	mov	r0, r4
   2b84a:	f7ff ffe4 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2b84e:	b003      	add	sp, #12
   2b850:	bd30      	pop	{r4, r5, pc}

0002b852 <lsm6dso_gy_full_scale_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of fs_g in reg CTRL2_G
  *
  */
int32_t lsm6dso_gy_full_scale_set(stmdev_ctx_t *ctx, lsm6dso_fs_g_t val)
{
   2b852:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_ctrl2_g_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   2b854:	2301      	movs	r3, #1
{
   2b856:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   2b858:	aa01      	add	r2, sp, #4
   2b85a:	2111      	movs	r1, #17
{
   2b85c:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   2b85e:	f7ff ffd3 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2b862:	b958      	cbnz	r0, 2b87c <lsm6dso_gy_full_scale_set+0x2a>
    reg.fs_g = (uint8_t) val;
   2b864:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   2b868:	aa01      	add	r2, sp, #4
    reg.fs_g = (uint8_t) val;
   2b86a:	f365 0343 	bfi	r3, r5, #1, #3
   2b86e:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   2b872:	2111      	movs	r1, #17
   2b874:	2301      	movs	r3, #1
   2b876:	4620      	mov	r0, r4
   2b878:	f7ff ffcd 	bl	2b816 <lsm6dso_write_reg>
  }

  return ret;
}
   2b87c:	b003      	add	sp, #12
   2b87e:	bd30      	pop	{r4, r5, pc}

0002b880 <lsm6dso_block_data_update_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of bdu in reg CTRL3_C
  *
  */
int32_t lsm6dso_block_data_update_set(stmdev_ctx_t *ctx, uint8_t val)
{
   2b880:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_ctrl3_c_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   2b882:	2301      	movs	r3, #1
{
   2b884:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   2b886:	aa01      	add	r2, sp, #4
   2b888:	2112      	movs	r1, #18
{
   2b88a:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   2b88c:	f7ff ffbc 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2b890:	b958      	cbnz	r0, 2b8aa <lsm6dso_block_data_update_set+0x2a>
    reg.bdu = val;
   2b892:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   2b896:	aa01      	add	r2, sp, #4
    reg.bdu = val;
   2b898:	f365 1386 	bfi	r3, r5, #6, #1
   2b89c:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   2b8a0:	2112      	movs	r1, #18
   2b8a2:	2301      	movs	r3, #1
   2b8a4:	4620      	mov	r0, r4
   2b8a6:	f7ff ffb6 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2b8aa:	b003      	add	sp, #12
   2b8ac:	bd30      	pop	{r4, r5, pc}

0002b8ae <lsm6dso_xl_power_mode_set>:
  *                               reg CTRL6_C
  *
  */
int32_t lsm6dso_xl_power_mode_set(stmdev_ctx_t *ctx,
                                  lsm6dso_xl_hm_mode_t val)
{
   2b8ae:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_ctrl5_c_t ctrl5_c;
  lsm6dso_ctrl6_c_t ctrl6_c;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL5_C, (uint8_t*) &ctrl5_c, 1);
   2b8b0:	2301      	movs	r3, #1
{
   2b8b2:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL5_C, (uint8_t*) &ctrl5_c, 1);
   2b8b4:	466a      	mov	r2, sp
   2b8b6:	2114      	movs	r1, #20
{
   2b8b8:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL5_C, (uint8_t*) &ctrl5_c, 1);
   2b8ba:	f7ff ffa5 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2b8be:	bb00      	cbnz	r0, 2b902 <lsm6dso_xl_power_mode_set+0x54>
    ctrl5_c.xl_ulp_en = ((uint8_t)val & 0x02U) >> 1;
   2b8c0:	f89d 2000 	ldrb.w	r2, [sp]
   2b8c4:	086b      	lsrs	r3, r5, #1
   2b8c6:	f363 12c7 	bfi	r2, r3, #7, #1
   2b8ca:	f88d 2000 	strb.w	r2, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL5_C, (uint8_t*) &ctrl5_c, 1);
   2b8ce:	2301      	movs	r3, #1
   2b8d0:	466a      	mov	r2, sp
   2b8d2:	2114      	movs	r1, #20
   2b8d4:	4620      	mov	r0, r4
   2b8d6:	f7ff ff9e 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2b8da:	b990      	cbnz	r0, 2b902 <lsm6dso_xl_power_mode_set+0x54>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL6_C, (uint8_t*) &ctrl6_c, 1);
   2b8dc:	2301      	movs	r3, #1
   2b8de:	aa01      	add	r2, sp, #4
   2b8e0:	2115      	movs	r1, #21
   2b8e2:	4620      	mov	r0, r4
   2b8e4:	f7ff ff90 	bl	2b808 <lsm6dso_read_reg>
  }
  if (ret == 0) {
   2b8e8:	b958      	cbnz	r0, 2b902 <lsm6dso_xl_power_mode_set+0x54>
    ctrl6_c.xl_hm_mode = (uint8_t)val & 0x01U;
   2b8ea:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL6_C, (uint8_t*) &ctrl6_c, 1);
   2b8ee:	aa01      	add	r2, sp, #4
    ctrl6_c.xl_hm_mode = (uint8_t)val & 0x01U;
   2b8f0:	f365 1304 	bfi	r3, r5, #4, #1
   2b8f4:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL6_C, (uint8_t*) &ctrl6_c, 1);
   2b8f8:	2115      	movs	r1, #21
   2b8fa:	2301      	movs	r3, #1
   2b8fc:	4620      	mov	r0, r4
   2b8fe:	f7ff ff8a 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2b902:	b003      	add	sp, #12
   2b904:	bd30      	pop	{r4, r5, pc}

0002b906 <lsm6dso_xl_flag_data_ready_get>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of xlda in reg STATUS_REG
  *
  */
int32_t lsm6dso_xl_flag_data_ready_get(stmdev_ctx_t *ctx, uint8_t *val)
{
   2b906:	b513      	push	{r0, r1, r4, lr}
  lsm6dso_status_reg_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_STATUS_REG, (uint8_t*)&reg, 1);
   2b908:	2301      	movs	r3, #1
{
   2b90a:	460c      	mov	r4, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_STATUS_REG, (uint8_t*)&reg, 1);
   2b90c:	aa01      	add	r2, sp, #4
   2b90e:	211e      	movs	r1, #30
   2b910:	f7ff ff7a 	bl	2b808 <lsm6dso_read_reg>
  *val = reg.xlda;
   2b914:	f89d 3004 	ldrb.w	r3, [sp, #4]
   2b918:	f3c3 0300 	ubfx	r3, r3, #0, #1
   2b91c:	7023      	strb	r3, [r4, #0]

  return ret;
}
   2b91e:	b002      	add	sp, #8
   2b920:	bd10      	pop	{r4, pc}

0002b922 <lsm6dso_timestamp_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of timestamp_en in reg CTRL10_C
  *
  */
int32_t lsm6dso_timestamp_set(stmdev_ctx_t *ctx, uint8_t val)
{
   2b922:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_ctrl10_c_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL10_C, (uint8_t*)&reg, 1);
   2b924:	2301      	movs	r3, #1
{
   2b926:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL10_C, (uint8_t*)&reg, 1);
   2b928:	aa01      	add	r2, sp, #4
   2b92a:	2119      	movs	r1, #25
{
   2b92c:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL10_C, (uint8_t*)&reg, 1);
   2b92e:	f7ff ff6b 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2b932:	b958      	cbnz	r0, 2b94c <lsm6dso_timestamp_set+0x2a>
    reg.timestamp_en = val;
   2b934:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL10_C, (uint8_t*)&reg, 1);
   2b938:	aa01      	add	r2, sp, #4
    reg.timestamp_en = val;
   2b93a:	f365 1345 	bfi	r3, r5, #5, #1
   2b93e:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL10_C, (uint8_t*)&reg, 1);
   2b942:	2119      	movs	r1, #25
   2b944:	2301      	movs	r3, #1
   2b946:	4620      	mov	r0, r4
   2b948:	f7ff ff65 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2b94c:	b003      	add	sp, #12
   2b94e:	bd30      	pop	{r4, r5, pc}

0002b950 <lsm6dso_acceleration_raw_get>:
  *
  */
int32_t lsm6dso_acceleration_raw_get(stmdev_ctx_t *ctx, uint8_t *buff)
{
  int32_t ret;
  ret = lsm6dso_read_reg(ctx, LSM6DSO_OUTX_L_A, buff, 6);
   2b950:	460a      	mov	r2, r1
   2b952:	2306      	movs	r3, #6
   2b954:	2128      	movs	r1, #40	; 0x28
   2b956:	f7ff bf57 	b.w	2b808 <lsm6dso_read_reg>

0002b95a <lsm6dso_fifo_out_raw_get>:
  *
  */
int32_t lsm6dso_fifo_out_raw_get(stmdev_ctx_t *ctx, uint8_t *buff)
{
  int32_t ret;
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_DATA_OUT_X_L, buff, 6);
   2b95a:	460a      	mov	r2, r1
   2b95c:	2306      	movs	r3, #6
   2b95e:	2179      	movs	r1, #121	; 0x79
   2b960:	f7ff bf52 	b.w	2b808 <lsm6dso_read_reg>

0002b964 <lsm6dso_mem_bank_set>:
int32_t lsm6dso_mem_bank_set(stmdev_ctx_t *ctx, lsm6dso_reg_access_t val)
{
  lsm6dso_func_cfg_access_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t*)&reg, 1);
   2b964:	2301      	movs	r3, #1
{
   2b966:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2b968:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t*)&reg, 1);
   2b96a:	aa01      	add	r2, sp, #4
   2b96c:	4619      	mov	r1, r3
{
   2b96e:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t*)&reg, 1);
   2b970:	f7ff ff4a 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2b974:	b958      	cbnz	r0, 2b98e <lsm6dso_mem_bank_set+0x2a>
    reg.reg_access = (uint8_t)val;
   2b976:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t*)&reg, 1);
   2b97a:	aa01      	add	r2, sp, #4
    reg.reg_access = (uint8_t)val;
   2b97c:	f365 1387 	bfi	r3, r5, #6, #2
   2b980:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FUNC_CFG_ACCESS, (uint8_t*)&reg, 1);
   2b984:	2301      	movs	r3, #1
   2b986:	4620      	mov	r0, r4
   2b988:	4619      	mov	r1, r3
   2b98a:	f7ff ff44 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2b98e:	b003      	add	sp, #12
   2b990:	bd30      	pop	{r4, r5, pc}

0002b992 <lsm6dso_all_sources_get>:
{
   2b992:	b538      	push	{r3, r4, r5, lr}
  ret = lsm6dso_read_reg(ctx, LSM6DSO_ALL_INT_SRC,
   2b994:	460a      	mov	r2, r1
{
   2b996:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_ALL_INT_SRC,
   2b998:	2301      	movs	r3, #1
   2b99a:	211a      	movs	r1, #26
{
   2b99c:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_ALL_INT_SRC,
   2b99e:	f7ff ff33 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2b9a2:	bbd8      	cbnz	r0, 2ba1c <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_WAKE_UP_SRC,
   2b9a4:	2301      	movs	r3, #1
   2b9a6:	211b      	movs	r1, #27
   2b9a8:	18ea      	adds	r2, r5, r3
   2b9aa:	4620      	mov	r0, r4
   2b9ac:	f7ff ff2c 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2b9b0:	bba0      	cbnz	r0, 2ba1c <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_SRC,
   2b9b2:	2301      	movs	r3, #1
   2b9b4:	1caa      	adds	r2, r5, #2
   2b9b6:	211c      	movs	r1, #28
   2b9b8:	4620      	mov	r0, r4
   2b9ba:	f7ff ff25 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2b9be:	bb68      	cbnz	r0, 2ba1c <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_D6D_SRC,
   2b9c0:	2301      	movs	r3, #1
   2b9c2:	1cea      	adds	r2, r5, #3
   2b9c4:	211d      	movs	r1, #29
   2b9c6:	4620      	mov	r0, r4
   2b9c8:	f7ff ff1e 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2b9cc:	bb30      	cbnz	r0, 2ba1c <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_STATUS_REG,
   2b9ce:	2301      	movs	r3, #1
   2b9d0:	1d2a      	adds	r2, r5, #4
   2b9d2:	211e      	movs	r1, #30
   2b9d4:	4620      	mov	r0, r4
   2b9d6:	f7ff ff17 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2b9da:	b9f8      	cbnz	r0, 2ba1c <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2b9dc:	2102      	movs	r1, #2
   2b9de:	4620      	mov	r0, r4
   2b9e0:	f7ff ffc0 	bl	2b964 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   2b9e4:	b9d0      	cbnz	r0, 2ba1c <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_STATUS,
   2b9e6:	2301      	movs	r3, #1
   2b9e8:	1d6a      	adds	r2, r5, #5
   2b9ea:	2112      	movs	r1, #18
   2b9ec:	4620      	mov	r0, r4
   2b9ee:	f7ff ff0b 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2b9f2:	b998      	cbnz	r0, 2ba1c <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FSM_STATUS_A,
   2b9f4:	2301      	movs	r3, #1
   2b9f6:	1daa      	adds	r2, r5, #6
   2b9f8:	2113      	movs	r1, #19
   2b9fa:	4620      	mov	r0, r4
   2b9fc:	f7ff ff04 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2ba00:	b960      	cbnz	r0, 2ba1c <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FSM_STATUS_B,
   2ba02:	2301      	movs	r3, #1
   2ba04:	1dea      	adds	r2, r5, #7
   2ba06:	2114      	movs	r1, #20
   2ba08:	4620      	mov	r0, r4
   2ba0a:	f7ff fefd 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2ba0e:	b928      	cbnz	r0, 2ba1c <lsm6dso_all_sources_get+0x8a>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2ba10:	4601      	mov	r1, r0
   2ba12:	4620      	mov	r0, r4
}
   2ba14:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2ba18:	f7ff bfa4 	b.w	2b964 <lsm6dso_mem_bank_set>
}
   2ba1c:	bd38      	pop	{r3, r4, r5, pc}

0002ba1e <lsm6dso_number_of_steps_get>:
{
   2ba1e:	b538      	push	{r3, r4, r5, lr}
   2ba20:	460d      	mov	r5, r1
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2ba22:	2102      	movs	r1, #2
{
   2ba24:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2ba26:	f7ff ff9d 	bl	2b964 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   2ba2a:	b960      	cbnz	r0, 2ba46 <lsm6dso_number_of_steps_get+0x28>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_STEP_COUNTER_L, buff, 2);
   2ba2c:	2302      	movs	r3, #2
   2ba2e:	462a      	mov	r2, r5
   2ba30:	2162      	movs	r1, #98	; 0x62
   2ba32:	4620      	mov	r0, r4
   2ba34:	f7ff fee8 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2ba38:	b928      	cbnz	r0, 2ba46 <lsm6dso_number_of_steps_get+0x28>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2ba3a:	4601      	mov	r1, r0
   2ba3c:	4620      	mov	r0, r4
}
   2ba3e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2ba42:	f7ff bf8f 	b.w	2b964 <lsm6dso_mem_bank_set>
}
   2ba46:	bd38      	pop	{r3, r4, r5, pc}

0002ba48 <lsm6dso_steps_reset>:
{
   2ba48:	b513      	push	{r0, r1, r4, lr}
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2ba4a:	2102      	movs	r1, #2
{
   2ba4c:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2ba4e:	f7ff ff89 	bl	2b964 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   2ba52:	b9b8      	cbnz	r0, 2ba84 <lsm6dso_steps_reset+0x3c>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_SRC, (uint8_t*)&reg, 1);
   2ba54:	2301      	movs	r3, #1
   2ba56:	aa01      	add	r2, sp, #4
   2ba58:	2164      	movs	r1, #100	; 0x64
   2ba5a:	4620      	mov	r0, r4
   2ba5c:	f7ff fed4 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2ba60:	b980      	cbnz	r0, 2ba84 <lsm6dso_steps_reset+0x3c>
    reg.pedo_rst_step = PROPERTY_ENABLE;
   2ba62:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_SRC, (uint8_t*)&reg, 1);
   2ba66:	aa01      	add	r2, sp, #4
    reg.pedo_rst_step = PROPERTY_ENABLE;
   2ba68:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   2ba6c:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_SRC, (uint8_t*)&reg, 1);
   2ba70:	2164      	movs	r1, #100	; 0x64
   2ba72:	2301      	movs	r3, #1
   2ba74:	4620      	mov	r0, r4
   2ba76:	f7ff fece 	bl	2b816 <lsm6dso_write_reg>
  if (ret == 0) {
   2ba7a:	b918      	cbnz	r0, 2ba84 <lsm6dso_steps_reset+0x3c>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2ba7c:	4601      	mov	r1, r0
   2ba7e:	4620      	mov	r0, r4
   2ba80:	f7ff ff70 	bl	2b964 <lsm6dso_mem_bank_set>
}
   2ba84:	b002      	add	sp, #8
   2ba86:	bd10      	pop	{r4, pc}

0002ba88 <lsm6dso_ln_pg_write_byte>:
  * @param  val      value to write
  *
  */
int32_t lsm6dso_ln_pg_write_byte(stmdev_ctx_t *ctx, uint16_t address,
                                 uint8_t *val)
{
   2ba88:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   2ba8c:	460f      	mov	r7, r1
  lsm6dso_page_rw_t page_rw;
  lsm6dso_page_sel_t page_sel;
  lsm6dso_page_address_t page_address;
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2ba8e:	2102      	movs	r1, #2
{
   2ba90:	4604      	mov	r4, r0
   2ba92:	4690      	mov	r8, r2
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2ba94:	f7ff ff66 	bl	2b964 <lsm6dso_mem_bank_set>

  if (ret == 0) {
   2ba98:	2800      	cmp	r0, #0
   2ba9a:	d156      	bne.n	2bb4a <lsm6dso_ln_pg_write_byte+0xc2>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2ba9c:	2301      	movs	r3, #1
   2ba9e:	aa01      	add	r2, sp, #4
   2baa0:	2117      	movs	r1, #23
   2baa2:	4620      	mov	r0, r4
   2baa4:	f7ff feb0 	bl	2b808 <lsm6dso_read_reg>
  }
  if (ret == 0) {
   2baa8:	2800      	cmp	r0, #0
   2baaa:	d14e      	bne.n	2bb4a <lsm6dso_ln_pg_write_byte+0xc2>
    page_rw.page_rw = 0x02; /* page_write enable */
   2baac:	2602      	movs	r6, #2
   2baae:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bab2:	aa01      	add	r2, sp, #4
    page_rw.page_rw = 0x02; /* page_write enable */
   2bab4:	f366 1346 	bfi	r3, r6, #5, #2
   2bab8:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2babc:	2117      	movs	r1, #23
   2babe:	2301      	movs	r3, #1
   2bac0:	4620      	mov	r0, r4
   2bac2:	f7ff fea8 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2bac6:	2800      	cmp	r0, #0
   2bac8:	d13f      	bne.n	2bb4a <lsm6dso_ln_pg_write_byte+0xc2>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   2baca:	2301      	movs	r3, #1
   2bacc:	aa02      	add	r2, sp, #8
   2bace:	4631      	mov	r1, r6
   2bad0:	4620      	mov	r0, r4
   2bad2:	f7ff fe99 	bl	2b808 <lsm6dso_read_reg>
  }

  if (ret == 0) {
   2bad6:	bbc0      	cbnz	r0, 2bb4a <lsm6dso_ln_pg_write_byte+0xc2>
    page_sel.page_sel = ((uint8_t)(address >> 8) & 0x0FU);
    page_sel.not_used_01 = 1;
   2bad8:	2501      	movs	r5, #1
    page_sel.page_sel = ((uint8_t)(address >> 8) & 0x0FU);
   2bada:	f89d 3008 	ldrb.w	r3, [sp, #8]
   2bade:	0a3a      	lsrs	r2, r7, #8
   2bae0:	f362 1307 	bfi	r3, r2, #4, #4
    page_sel.not_used_01 = 1;
   2bae4:	f365 0303 	bfi	r3, r5, #0, #4
   2bae8:	f88d 3008 	strb.w	r3, [sp, #8]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   2baec:	aa02      	add	r2, sp, #8
   2baee:	462b      	mov	r3, r5
   2baf0:	4631      	mov	r1, r6
   2baf2:	4620      	mov	r0, r4
   2baf4:	f7ff fe8f 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2baf8:	bb38      	cbnz	r0, 2bb4a <lsm6dso_ln_pg_write_byte+0xc2>
    page_address.page_addr = (uint8_t)address & 0xFFU;
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_ADDRESS,
   2bafa:	462b      	mov	r3, r5
   2bafc:	aa03      	add	r2, sp, #12
   2bafe:	2108      	movs	r1, #8
   2bb00:	4620      	mov	r0, r4
    page_address.page_addr = (uint8_t)address & 0xFFU;
   2bb02:	f88d 700c 	strb.w	r7, [sp, #12]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_ADDRESS,
   2bb06:	f7ff fe86 	bl	2b816 <lsm6dso_write_reg>
                            (uint8_t*)&page_address, 1);
  }
  if (ret == 0) {
   2bb0a:	b9f0      	cbnz	r0, 2bb4a <lsm6dso_ln_pg_write_byte+0xc2>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_VALUE, val, 1);
   2bb0c:	462b      	mov	r3, r5
   2bb0e:	4642      	mov	r2, r8
   2bb10:	2109      	movs	r1, #9
   2bb12:	4620      	mov	r0, r4
   2bb14:	f7ff fe7f 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2bb18:	b9b8      	cbnz	r0, 2bb4a <lsm6dso_ln_pg_write_byte+0xc2>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bb1a:	462b      	mov	r3, r5
   2bb1c:	aa01      	add	r2, sp, #4
   2bb1e:	2117      	movs	r1, #23
   2bb20:	4620      	mov	r0, r4
   2bb22:	f7ff fe71 	bl	2b808 <lsm6dso_read_reg>
  }
  if (ret == 0) {
   2bb26:	b980      	cbnz	r0, 2bb4a <lsm6dso_ln_pg_write_byte+0xc2>
    page_rw.page_rw = 0x00; /* page_write disable */
   2bb28:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bb2c:	aa01      	add	r2, sp, #4
    page_rw.page_rw = 0x00; /* page_write disable */
   2bb2e:	f360 1346 	bfi	r3, r0, #5, #2
   2bb32:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bb36:	2117      	movs	r1, #23
   2bb38:	462b      	mov	r3, r5
   2bb3a:	4620      	mov	r0, r4
   2bb3c:	f7ff fe6b 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2bb40:	b918      	cbnz	r0, 2bb4a <lsm6dso_ln_pg_write_byte+0xc2>

    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2bb42:	4601      	mov	r1, r0
   2bb44:	4620      	mov	r0, r4
   2bb46:	f7ff ff0d 	bl	2b964 <lsm6dso_mem_bank_set>
  }
  return ret;
}
   2bb4a:	b004      	add	sp, #16
   2bb4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002bb50 <lsm6dso_ln_pg_write>:
  * @param  uint8_t len: buffer len
  *
  */
int32_t lsm6dso_ln_pg_write(stmdev_ctx_t *ctx, uint16_t address,
                            uint8_t *buf, uint8_t len)
{
   2bb50:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2bb54:	460d      	mov	r5, r1
   2bb56:	b085      	sub	sp, #20
  int32_t ret;
  uint8_t i ;

  addr_pointed = address;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2bb58:	2102      	movs	r1, #2
{
   2bb5a:	4604      	mov	r4, r0
   2bb5c:	4616      	mov	r6, r2
   2bb5e:	4698      	mov	r8, r3
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2bb60:	f7ff ff00 	bl	2b964 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   2bb64:	2800      	cmp	r0, #0
   2bb66:	d15f      	bne.n	2bc28 <lsm6dso_ln_pg_write+0xd8>

    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bb68:	2301      	movs	r3, #1
   2bb6a:	aa01      	add	r2, sp, #4
   2bb6c:	2117      	movs	r1, #23
   2bb6e:	4620      	mov	r0, r4
   2bb70:	f7ff fe4a 	bl	2b808 <lsm6dso_read_reg>
  }
  if (ret == 0) {
   2bb74:	2800      	cmp	r0, #0
   2bb76:	d157      	bne.n	2bc28 <lsm6dso_ln_pg_write+0xd8>
    page_rw.page_rw = 0x02; /* page_write enable*/
   2bb78:	f04f 0902 	mov.w	r9, #2
   2bb7c:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bb80:	aa01      	add	r2, sp, #4
    page_rw.page_rw = 0x02; /* page_write enable*/
   2bb82:	f369 1346 	bfi	r3, r9, #5, #2
   2bb86:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bb8a:	2117      	movs	r1, #23
   2bb8c:	2301      	movs	r3, #1
   2bb8e:	4620      	mov	r0, r4
   2bb90:	f7ff fe41 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2bb94:	2800      	cmp	r0, #0
   2bb96:	d147      	bne.n	2bc28 <lsm6dso_ln_pg_write+0xd8>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   2bb98:	2301      	movs	r3, #1
   2bb9a:	aa02      	add	r2, sp, #8
   2bb9c:	4649      	mov	r1, r9
   2bb9e:	4620      	mov	r0, r4
   2bba0:	f7ff fe32 	bl	2b808 <lsm6dso_read_reg>
  }
  if (ret == 0) {
   2bba4:	2800      	cmp	r0, #0
   2bba6:	d13f      	bne.n	2bc28 <lsm6dso_ln_pg_write+0xd8>
    page_sel.page_sel = ((uint8_t)(addr_pointed >> 8) & 0x0FU);
    page_sel.not_used_01 = 1;
   2bba8:	2701      	movs	r7, #1
    page_sel.page_sel = ((uint8_t)(addr_pointed >> 8) & 0x0FU);
   2bbaa:	f89d 3008 	ldrb.w	r3, [sp, #8]
   2bbae:	0a2a      	lsrs	r2, r5, #8
   2bbb0:	f362 1307 	bfi	r3, r2, #4, #4
    page_sel.not_used_01 = 1;
   2bbb4:	f367 0303 	bfi	r3, r7, #0, #4
   2bbb8:	f88d 3008 	strb.w	r3, [sp, #8]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   2bbbc:	aa02      	add	r2, sp, #8
   2bbbe:	463b      	mov	r3, r7
   2bbc0:	4649      	mov	r1, r9
   2bbc2:	4620      	mov	r0, r4
   2bbc4:	f7ff fe27 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2bbc8:	bb70      	cbnz	r0, 2bc28 <lsm6dso_ln_pg_write+0xd8>
    page_address.page_addr = (uint8_t)(addr_pointed & 0x00FFU);
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_ADDRESS,
   2bbca:	463b      	mov	r3, r7
   2bbcc:	aa03      	add	r2, sp, #12
   2bbce:	2108      	movs	r1, #8
   2bbd0:	4620      	mov	r0, r4
    page_address.page_addr = (uint8_t)(addr_pointed & 0x00FFU);
   2bbd2:	f88d 500c 	strb.w	r5, [sp, #12]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_ADDRESS,
   2bbd6:	f7ff fe1e 	bl	2b816 <lsm6dso_write_reg>
                            (uint8_t*)&page_address, 1);
  }

  if (ret == 0) {
   2bbda:	bb28      	cbnz	r0, 2bc28 <lsm6dso_ln_pg_write+0xd8>
   2bbdc:	44b0      	add	r8, r6
    for (i = 0; ( (i < len) && (ret == 0) ); i++) {
   2bbde:	45b0      	cmp	r8, r6
   2bbe0:	d000      	beq.n	2bbe4 <lsm6dso_ln_pg_write+0x94>
   2bbe2:	b320      	cbz	r0, 2bc2e <lsm6dso_ln_pg_write+0xde>
                                  (uint8_t*)&page_sel, 1);
        }
      }
    }
    page_sel.page_sel = 0;
    page_sel.not_used_01 = 1;
   2bbe4:	2501      	movs	r5, #1
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   2bbe6:	aa02      	add	r2, sp, #8
   2bbe8:	462b      	mov	r3, r5
   2bbea:	2102      	movs	r1, #2
   2bbec:	4620      	mov	r0, r4
    page_sel.not_used_01 = 1;
   2bbee:	f88d 5008 	strb.w	r5, [sp, #8]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   2bbf2:	f7ff fe10 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2bbf6:	b9b8      	cbnz	r0, 2bc28 <lsm6dso_ln_pg_write+0xd8>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bbf8:	462b      	mov	r3, r5
   2bbfa:	aa01      	add	r2, sp, #4
   2bbfc:	2117      	movs	r1, #23
   2bbfe:	4620      	mov	r0, r4
   2bc00:	f7ff fe02 	bl	2b808 <lsm6dso_read_reg>
  }
  if (ret == 0) {
   2bc04:	b980      	cbnz	r0, 2bc28 <lsm6dso_ln_pg_write+0xd8>
    page_rw.page_rw = 0x00; /* page_write disable */
   2bc06:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bc0a:	aa01      	add	r2, sp, #4
    page_rw.page_rw = 0x00; /* page_write disable */
   2bc0c:	f360 1346 	bfi	r3, r0, #5, #2
   2bc10:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bc14:	2117      	movs	r1, #23
   2bc16:	462b      	mov	r3, r5
   2bc18:	4620      	mov	r0, r4
   2bc1a:	f7ff fdfc 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2bc1e:	b918      	cbnz	r0, 2bc28 <lsm6dso_ln_pg_write+0xd8>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2bc20:	4601      	mov	r1, r0
   2bc22:	4620      	mov	r0, r4
   2bc24:	f7ff fe9e 	bl	2b964 <lsm6dso_mem_bank_set>
  }
  return ret;
}
   2bc28:	b005      	add	sp, #20
   2bc2a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      addr_pointed++;
   2bc2e:	3501      	adds	r5, #1
      ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_VALUE, &buf[i], 1);
   2bc30:	2301      	movs	r3, #1
   2bc32:	4632      	mov	r2, r6
   2bc34:	2109      	movs	r1, #9
   2bc36:	4620      	mov	r0, r4
      addr_pointed++;
   2bc38:	b2ad      	uxth	r5, r5
      ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_VALUE, &buf[i], 1);
   2bc3a:	f7ff fdec 	bl	2b816 <lsm6dso_write_reg>
      if ( ( (addr_pointed % 0x0100U) == 0x00U ) && (ret == 0) ) {
   2bc3e:	f015 0fff 	tst.w	r5, #255	; 0xff
   2bc42:	d116      	bne.n	2bc72 <lsm6dso_ln_pg_write+0x122>
   2bc44:	b9a8      	cbnz	r0, 2bc72 <lsm6dso_ln_pg_write+0x122>
        ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*)&page_sel, 1);
   2bc46:	2301      	movs	r3, #1
   2bc48:	aa02      	add	r2, sp, #8
   2bc4a:	2102      	movs	r1, #2
   2bc4c:	4620      	mov	r0, r4
   2bc4e:	f7ff fddb 	bl	2b808 <lsm6dso_read_reg>
        if (ret == 0) {
   2bc52:	b970      	cbnz	r0, 2bc72 <lsm6dso_ln_pg_write+0x122>
          page_sel.page_sel = ((uint8_t)(addr_pointed >> 8) & 0x0FU);
   2bc54:	f89d 2008 	ldrb.w	r2, [sp, #8]
   2bc58:	0a2b      	lsrs	r3, r5, #8
   2bc5a:	f363 1207 	bfi	r2, r3, #4, #4
          page_sel.not_used_01 = 1;
   2bc5e:	f367 0203 	bfi	r2, r7, #0, #4
   2bc62:	f88d 2008 	strb.w	r2, [sp, #8]
          ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_SEL,
   2bc66:	2301      	movs	r3, #1
   2bc68:	aa02      	add	r2, sp, #8
   2bc6a:	2102      	movs	r1, #2
   2bc6c:	4620      	mov	r0, r4
   2bc6e:	f7ff fdd2 	bl	2b816 <lsm6dso_write_reg>
   2bc72:	3601      	adds	r6, #1
   2bc74:	e7b3      	b.n	2bbde <lsm6dso_ln_pg_write+0x8e>

0002bc76 <lsm6dso_ln_pg_read_byte>:
  * @param  val      read value
  *
  */
int32_t lsm6dso_ln_pg_read_byte(stmdev_ctx_t *ctx, uint16_t address,
                                uint8_t *val)
{
   2bc76:	b5f0      	push	{r4, r5, r6, r7, lr}
   2bc78:	460e      	mov	r6, r1
   2bc7a:	b085      	sub	sp, #20
  lsm6dso_page_rw_t page_rw;
  lsm6dso_page_sel_t page_sel;
  lsm6dso_page_address_t  page_address;
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2bc7c:	2102      	movs	r1, #2
{
   2bc7e:	4604      	mov	r4, r0
   2bc80:	4617      	mov	r7, r2
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2bc82:	f7ff fe6f 	bl	2b964 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   2bc86:	2800      	cmp	r0, #0
   2bc88:	d155      	bne.n	2bd36 <lsm6dso_ln_pg_read_byte+0xc0>

    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bc8a:	2301      	movs	r3, #1
   2bc8c:	aa01      	add	r2, sp, #4
   2bc8e:	2117      	movs	r1, #23
   2bc90:	4620      	mov	r0, r4
   2bc92:	f7ff fdb9 	bl	2b808 <lsm6dso_read_reg>
  }
  if (ret == 0) {
   2bc96:	2800      	cmp	r0, #0
   2bc98:	d14d      	bne.n	2bd36 <lsm6dso_ln_pg_read_byte+0xc0>
    page_rw.page_rw = 0x01; /* page_read enable*/
   2bc9a:	2501      	movs	r5, #1
   2bc9c:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bca0:	aa01      	add	r2, sp, #4
    page_rw.page_rw = 0x01; /* page_read enable*/
   2bca2:	f365 1346 	bfi	r3, r5, #5, #2
   2bca6:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bcaa:	2117      	movs	r1, #23
   2bcac:	462b      	mov	r3, r5
   2bcae:	4620      	mov	r0, r4
   2bcb0:	f7ff fdb1 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2bcb4:	2800      	cmp	r0, #0
   2bcb6:	d13e      	bne.n	2bd36 <lsm6dso_ln_pg_read_byte+0xc0>

    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   2bcb8:	462b      	mov	r3, r5
   2bcba:	aa02      	add	r2, sp, #8
   2bcbc:	2102      	movs	r1, #2
   2bcbe:	4620      	mov	r0, r4
   2bcc0:	f7ff fda2 	bl	2b808 <lsm6dso_read_reg>
  }
  if (ret == 0) {
   2bcc4:	bbb8      	cbnz	r0, 2bd36 <lsm6dso_ln_pg_read_byte+0xc0>
    page_sel.page_sel = ((uint8_t)(address >> 8) & 0x0FU);
   2bcc6:	f89d 3008 	ldrb.w	r3, [sp, #8]
   2bcca:	0a32      	lsrs	r2, r6, #8
   2bccc:	f362 1307 	bfi	r3, r2, #4, #4
    page_sel.not_used_01 = 1;
   2bcd0:	f365 0303 	bfi	r3, r5, #0, #4
   2bcd4:	f88d 3008 	strb.w	r3, [sp, #8]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_SEL, (uint8_t*) &page_sel, 1);
   2bcd8:	aa02      	add	r2, sp, #8
   2bcda:	462b      	mov	r3, r5
   2bcdc:	2102      	movs	r1, #2
   2bcde:	4620      	mov	r0, r4
   2bce0:	f7ff fd99 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2bce4:	bb38      	cbnz	r0, 2bd36 <lsm6dso_ln_pg_read_byte+0xc0>
    page_address.page_addr = (uint8_t)address & 0x00FFU;
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_ADDRESS,
   2bce6:	462b      	mov	r3, r5
   2bce8:	aa03      	add	r2, sp, #12
   2bcea:	2108      	movs	r1, #8
   2bcec:	4620      	mov	r0, r4
    page_address.page_addr = (uint8_t)address & 0x00FFU;
   2bcee:	f88d 600c 	strb.w	r6, [sp, #12]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_ADDRESS,
   2bcf2:	f7ff fd90 	bl	2b816 <lsm6dso_write_reg>
                            (uint8_t*)&page_address, 1);
  }
  if (ret == 0) {
   2bcf6:	b9f0      	cbnz	r0, 2bd36 <lsm6dso_ln_pg_read_byte+0xc0>

    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_VALUE, val, 1);
   2bcf8:	462b      	mov	r3, r5
   2bcfa:	463a      	mov	r2, r7
   2bcfc:	2109      	movs	r1, #9
   2bcfe:	4620      	mov	r0, r4
   2bd00:	f7ff fd82 	bl	2b808 <lsm6dso_read_reg>
  }
  if (ret == 0) {
   2bd04:	b9b8      	cbnz	r0, 2bd36 <lsm6dso_ln_pg_read_byte+0xc0>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bd06:	462b      	mov	r3, r5
   2bd08:	aa01      	add	r2, sp, #4
   2bd0a:	2117      	movs	r1, #23
   2bd0c:	4620      	mov	r0, r4
   2bd0e:	f7ff fd7b 	bl	2b808 <lsm6dso_read_reg>
  }
  if (ret == 0) {
   2bd12:	b980      	cbnz	r0, 2bd36 <lsm6dso_ln_pg_read_byte+0xc0>
    page_rw.page_rw = 0x00; /* page_read disable */
   2bd14:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bd18:	aa01      	add	r2, sp, #4
    page_rw.page_rw = 0x00; /* page_read disable */
   2bd1a:	f360 1346 	bfi	r3, r0, #5, #2
   2bd1e:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2bd22:	2117      	movs	r1, #23
   2bd24:	462b      	mov	r3, r5
   2bd26:	4620      	mov	r0, r4
   2bd28:	f7ff fd75 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2bd2c:	b918      	cbnz	r0, 2bd36 <lsm6dso_ln_pg_read_byte+0xc0>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2bd2e:	4601      	mov	r1, r0
   2bd30:	4620      	mov	r0, r4
   2bd32:	f7ff fe17 	bl	2b964 <lsm6dso_mem_bank_set>
  }

  return ret;
}
   2bd36:	b005      	add	sp, #20
   2bd38:	bdf0      	pop	{r4, r5, r6, r7, pc}

0002bd3a <lsm6dso_data_ready_mode_set>:
  *                                     reg COUNTER_BDR_REG1
  *
  */
int32_t lsm6dso_data_ready_mode_set(stmdev_ctx_t *ctx,
                                    lsm6dso_dataready_pulsed_t val)
{
   2bd3a:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_counter_bdr_reg1_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_COUNTER_BDR_REG1, (uint8_t*)&reg, 1);
   2bd3c:	2301      	movs	r3, #1
{
   2bd3e:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_COUNTER_BDR_REG1, (uint8_t*)&reg, 1);
   2bd40:	aa01      	add	r2, sp, #4
   2bd42:	210b      	movs	r1, #11
{
   2bd44:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_COUNTER_BDR_REG1, (uint8_t*)&reg, 1);
   2bd46:	f7ff fd5f 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2bd4a:	b958      	cbnz	r0, 2bd64 <lsm6dso_data_ready_mode_set+0x2a>
    reg.dataready_pulsed = (uint8_t)val;
   2bd4c:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_COUNTER_BDR_REG1, (uint8_t*)&reg, 1);
   2bd50:	aa01      	add	r2, sp, #4
    reg.dataready_pulsed = (uint8_t)val;
   2bd52:	f365 13c7 	bfi	r3, r5, #7, #1
   2bd56:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_COUNTER_BDR_REG1, (uint8_t*)&reg, 1);
   2bd5a:	210b      	movs	r1, #11
   2bd5c:	2301      	movs	r3, #1
   2bd5e:	4620      	mov	r0, r4
   2bd60:	f7ff fd59 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2bd64:	b003      	add	sp, #12
   2bd66:	bd30      	pop	{r4, r5, pc}

0002bd68 <lsm6dso_device_id_get>:
  *
  */
int32_t lsm6dso_device_id_get(stmdev_ctx_t *ctx, uint8_t *buff)
{
  int32_t ret;
  ret = lsm6dso_read_reg(ctx, LSM6DSO_WHO_AM_I, buff, 1);
   2bd68:	460a      	mov	r2, r1
   2bd6a:	2301      	movs	r3, #1
   2bd6c:	210f      	movs	r1, #15
   2bd6e:	f7ff bd4b 	b.w	2b808 <lsm6dso_read_reg>

0002bd72 <lsm6dso_reset_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of sw_reset in reg CTRL3_C
  *
  */
int32_t lsm6dso_reset_set(stmdev_ctx_t *ctx, uint8_t val)
{
   2bd72:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_ctrl3_c_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   2bd74:	2301      	movs	r3, #1
{
   2bd76:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   2bd78:	aa01      	add	r2, sp, #4
   2bd7a:	2112      	movs	r1, #18
{
   2bd7c:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   2bd7e:	f7ff fd43 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2bd82:	b958      	cbnz	r0, 2bd9c <lsm6dso_reset_set+0x2a>
    reg.sw_reset = val;
   2bd84:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   2bd88:	aa01      	add	r2, sp, #4
    reg.sw_reset = val;
   2bd8a:	f365 0300 	bfi	r3, r5, #0, #1
   2bd8e:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   2bd92:	2112      	movs	r1, #18
   2bd94:	2301      	movs	r3, #1
   2bd96:	4620      	mov	r0, r4
   2bd98:	f7ff fd3d 	bl	2b816 <lsm6dso_write_reg>
  }

  return ret;
}
   2bd9c:	b003      	add	sp, #12
   2bd9e:	bd30      	pop	{r4, r5, pc}

0002bda0 <lsm6dso_reset_get>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of sw_reset in reg CTRL3_C
  *
  */
int32_t lsm6dso_reset_get(stmdev_ctx_t *ctx, uint8_t *val)
{
   2bda0:	b513      	push	{r0, r1, r4, lr}
  lsm6dso_ctrl3_c_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   2bda2:	2301      	movs	r3, #1
{
   2bda4:	460c      	mov	r4, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL3_C, (uint8_t*)&reg, 1);
   2bda6:	aa01      	add	r2, sp, #4
   2bda8:	2112      	movs	r1, #18
   2bdaa:	f7ff fd2d 	bl	2b808 <lsm6dso_read_reg>
  *val = reg.sw_reset;
   2bdae:	f89d 3004 	ldrb.w	r3, [sp, #4]
   2bdb2:	f3c3 0300 	ubfx	r3, r3, #0, #1
   2bdb6:	7023      	strb	r3, [r4, #0]

  return ret;
}
   2bdb8:	b002      	add	sp, #8
   2bdba:	bd10      	pop	{r4, pc}

0002bdbc <lsm6dso_i3c_disable_set>:
  * @param  val      change the values of i3c_disable
  *                                    in reg CTRL9_XL
  *
  */
int32_t lsm6dso_i3c_disable_set(stmdev_ctx_t *ctx, lsm6dso_i3c_disable_t val)
{
   2bdbc:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_i3c_bus_avb_t i3c_bus_avb;
  lsm6dso_ctrl9_xl_t ctrl9_xl;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
   2bdbe:	2301      	movs	r3, #1
{
   2bdc0:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
   2bdc2:	aa01      	add	r2, sp, #4
   2bdc4:	2118      	movs	r1, #24
{
   2bdc6:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
   2bdc8:	f7ff fd1e 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2bdcc:	bb00      	cbnz	r0, 2be10 <lsm6dso_i3c_disable_set+0x54>
    ctrl9_xl.i3c_disable = ((uint8_t)val & 0x80U) >> 7;
   2bdce:	f89d 2004 	ldrb.w	r2, [sp, #4]
   2bdd2:	09eb      	lsrs	r3, r5, #7
   2bdd4:	f363 0241 	bfi	r2, r3, #1, #1
   2bdd8:	f88d 2004 	strb.w	r2, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL9_XL, (uint8_t*)&ctrl9_xl, 1);
   2bddc:	2301      	movs	r3, #1
   2bdde:	aa01      	add	r2, sp, #4
   2bde0:	2118      	movs	r1, #24
   2bde2:	4620      	mov	r0, r4
   2bde4:	f7ff fd17 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2bde8:	b990      	cbnz	r0, 2be10 <lsm6dso_i3c_disable_set+0x54>

    ret = lsm6dso_read_reg(ctx, LSM6DSO_I3C_BUS_AVB,
   2bdea:	2301      	movs	r3, #1
   2bdec:	466a      	mov	r2, sp
   2bdee:	2162      	movs	r1, #98	; 0x62
   2bdf0:	4620      	mov	r0, r4
   2bdf2:	f7ff fd09 	bl	2b808 <lsm6dso_read_reg>
                           (uint8_t*)&i3c_bus_avb, 1);
  }
  if (ret == 0) {
   2bdf6:	b958      	cbnz	r0, 2be10 <lsm6dso_i3c_disable_set+0x54>
    i3c_bus_avb.i3c_bus_avb_sel = (uint8_t)val & 0x03U;
   2bdf8:	f89d 3000 	ldrb.w	r3, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_I3C_BUS_AVB,
   2bdfc:	466a      	mov	r2, sp
    i3c_bus_avb.i3c_bus_avb_sel = (uint8_t)val & 0x03U;
   2bdfe:	f365 03c4 	bfi	r3, r5, #3, #2
   2be02:	f88d 3000 	strb.w	r3, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_I3C_BUS_AVB,
   2be06:	2162      	movs	r1, #98	; 0x62
   2be08:	2301      	movs	r3, #1
   2be0a:	4620      	mov	r0, r4
   2be0c:	f7ff fd03 	bl	2b816 <lsm6dso_write_reg>
                            (uint8_t*)&i3c_bus_avb, 1);
  }

  return ret;
}
   2be10:	b003      	add	sp, #12
   2be12:	bd30      	pop	{r4, r5, pc}

0002be14 <lsm6dso_pin_int1_route_get>:
  *                  EMB_FUNC_INT1, FSM_INT1_A, FSM_INT1_B
  *
  */
int32_t lsm6dso_pin_int1_route_get(stmdev_ctx_t *ctx,
                                   lsm6dso_pin_int1_route_t *val)
{
   2be14:	b570      	push	{r4, r5, r6, lr}
   2be16:	460d      	mov	r5, r1
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2be18:	2102      	movs	r1, #2
{
   2be1a:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2be1c:	f7ff fda2 	bl	2b964 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   2be20:	bb40      	cbnz	r0, 2be74 <lsm6dso_pin_int1_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_INT1,
   2be22:	2301      	movs	r3, #1
   2be24:	1caa      	adds	r2, r5, #2
   2be26:	210a      	movs	r1, #10
   2be28:	4620      	mov	r0, r4
   2be2a:	f7ff fced 	bl	2b808 <lsm6dso_read_reg>
                           (uint8_t*)&val->emb_func_int1, 1);
  }
  if (ret == 0) {
   2be2e:	bb08      	cbnz	r0, 2be74 <lsm6dso_pin_int1_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FSM_INT1_A,
   2be30:	2301      	movs	r3, #1
   2be32:	1cea      	adds	r2, r5, #3
   2be34:	210b      	movs	r1, #11
   2be36:	4620      	mov	r0, r4
   2be38:	f7ff fce6 	bl	2b808 <lsm6dso_read_reg>
                           (uint8_t*)&val->fsm_int1_a, 1);
  }
  if (ret == 0) {
   2be3c:	b9d0      	cbnz	r0, 2be74 <lsm6dso_pin_int1_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FSM_INT1_B,
   2be3e:	2301      	movs	r3, #1
   2be40:	1d2a      	adds	r2, r5, #4
   2be42:	210c      	movs	r1, #12
   2be44:	4620      	mov	r0, r4
   2be46:	f7ff fcdf 	bl	2b808 <lsm6dso_read_reg>
                           (uint8_t*)&val->fsm_int1_b, 1);
  }
  if (ret == 0) {
   2be4a:	b998      	cbnz	r0, 2be74 <lsm6dso_pin_int1_route_get+0x60>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2be4c:	4601      	mov	r1, r0
   2be4e:	4620      	mov	r0, r4
   2be50:	f7ff fd88 	bl	2b964 <lsm6dso_mem_bank_set>
  }
  if (ret == 0) {
   2be54:	b970      	cbnz	r0, 2be74 <lsm6dso_pin_int1_route_get+0x60>

    ret = lsm6dso_read_reg(ctx, LSM6DSO_INT1_CTRL,
   2be56:	2301      	movs	r3, #1
   2be58:	462a      	mov	r2, r5
   2be5a:	210d      	movs	r1, #13
   2be5c:	4620      	mov	r0, r4
   2be5e:	f7ff fcd3 	bl	2b808 <lsm6dso_read_reg>
                           (uint8_t*)&val->int1_ctrl, 1);
  }
  if (ret == 0) {
   2be62:	b938      	cbnz	r0, 2be74 <lsm6dso_pin_int1_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_MD1_CFG, (uint8_t*)&val->md1_cfg, 1);
   2be64:	2301      	movs	r3, #1
   2be66:	4620      	mov	r0, r4
   2be68:	18ea      	adds	r2, r5, r3
   2be6a:	215e      	movs	r1, #94	; 0x5e
  }

  return ret;
}
   2be6c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    ret = lsm6dso_read_reg(ctx, LSM6DSO_MD1_CFG, (uint8_t*)&val->md1_cfg, 1);
   2be70:	f7ff bcca 	b.w	2b808 <lsm6dso_read_reg>
}
   2be74:	bd70      	pop	{r4, r5, r6, pc}

0002be76 <lsm6dso_pin_int2_route_set>:
  *                  EMB_FUNC_INT2, FSM_INT2_A, FSM_INT2_B
  *
  */
int32_t lsm6dso_pin_int2_route_set(stmdev_ctx_t *ctx,
                                   lsm6dso_pin_int2_route_t *val)
{
   2be76:	b530      	push	{r4, r5, lr}
   2be78:	460d      	mov	r5, r1
   2be7a:	b085      	sub	sp, #20
  lsm6dso_pin_int1_route_t pin_int1_route;
  lsm6dso_tap_cfg2_t tap_cfg2;
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2be7c:	2102      	movs	r1, #2
{
   2be7e:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2be80:	f7ff fd70 	bl	2b964 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   2be84:	2800      	cmp	r0, #0
   2be86:	f040 80de 	bne.w	2c046 <lsm6dso_pin_int2_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_INT2,
   2be8a:	2301      	movs	r3, #1
   2be8c:	1caa      	adds	r2, r5, #2
   2be8e:	210e      	movs	r1, #14
   2be90:	4620      	mov	r0, r4
   2be92:	f7ff fcc0 	bl	2b816 <lsm6dso_write_reg>
                            (uint8_t*)&val->emb_func_int2, 1);
  }
  if (ret == 0) {
   2be96:	2800      	cmp	r0, #0
   2be98:	f040 80d5 	bne.w	2c046 <lsm6dso_pin_int2_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FSM_INT2_A,
   2be9c:	2301      	movs	r3, #1
   2be9e:	1cea      	adds	r2, r5, #3
   2bea0:	210f      	movs	r1, #15
   2bea2:	4620      	mov	r0, r4
   2bea4:	f7ff fcb7 	bl	2b816 <lsm6dso_write_reg>
                            (uint8_t*)&val->fsm_int2_a, 1);
  }
  if (ret == 0) {
   2bea8:	2800      	cmp	r0, #0
   2beaa:	f040 80cc 	bne.w	2c046 <lsm6dso_pin_int2_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FSM_INT2_B,
   2beae:	2301      	movs	r3, #1
   2beb0:	1d2a      	adds	r2, r5, #4
   2beb2:	2110      	movs	r1, #16
   2beb4:	4620      	mov	r0, r4
   2beb6:	f7ff fcae 	bl	2b816 <lsm6dso_write_reg>
                            (uint8_t*)&val->fsm_int2_b, 1);
  }
  if (ret == 0) {
   2beba:	2800      	cmp	r0, #0
   2bebc:	f040 80c3 	bne.w	2c046 <lsm6dso_pin_int2_route_set+0x1d0>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2bec0:	4601      	mov	r1, r0
   2bec2:	4620      	mov	r0, r4
   2bec4:	f7ff fd4e 	bl	2b964 <lsm6dso_mem_bank_set>
  }

  if (ret == 0) {
   2bec8:	2800      	cmp	r0, #0
   2beca:	f040 80bc 	bne.w	2c046 <lsm6dso_pin_int2_route_set+0x1d0>
    if (( val->emb_func_int2.int2_fsm_lc
   2bece:	78aa      	ldrb	r2, [r5, #2]
      val->md2_cfg.int2_emb_func = PROPERTY_ENABLE;
    }
    else{
      val->md2_cfg.int2_emb_func = PROPERTY_DISABLE;
    }
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT2_CTRL,
   2bed0:	4620      	mov	r0, r4
        | val->emb_func_int2.int2_sig_mot
   2bed2:	f3c2 1340 	ubfx	r3, r2, #5, #1
        | val->emb_func_int2.int2_step_detector
   2bed6:	f3c2 01c0 	ubfx	r1, r2, #3, #1
        | val->emb_func_int2.int2_sig_mot
   2beda:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
        | val->emb_func_int2.int2_step_detector
   2bede:	430b      	orrs	r3, r1
        | val->emb_func_int2.int2_tilt
   2bee0:	f3c2 1200 	ubfx	r2, r2, #4, #1
   2bee4:	4313      	orrs	r3, r2
        | val->fsm_int2_a.int2_fsm1
   2bee6:	78ea      	ldrb	r2, [r5, #3]
   2bee8:	f3c2 0100 	ubfx	r1, r2, #0, #1
   2beec:	430b      	orrs	r3, r1
        | val->fsm_int2_a.int2_fsm2
   2beee:	f3c2 0140 	ubfx	r1, r2, #1, #1
   2bef2:	430b      	orrs	r3, r1
        | val->fsm_int2_a.int2_fsm3
   2bef4:	f3c2 0180 	ubfx	r1, r2, #2, #1
   2bef8:	430b      	orrs	r3, r1
        | val->fsm_int2_a.int2_fsm4
   2befa:	f3c2 01c0 	ubfx	r1, r2, #3, #1
   2befe:	430b      	orrs	r3, r1
        | val->fsm_int2_a.int2_fsm5
   2bf00:	f3c2 1100 	ubfx	r1, r2, #4, #1
   2bf04:	430b      	orrs	r3, r1
        | val->fsm_int2_a.int2_fsm6
   2bf06:	f3c2 1140 	ubfx	r1, r2, #5, #1
   2bf0a:	430b      	orrs	r3, r1
        | val->fsm_int2_a.int2_fsm7
   2bf0c:	f3c2 1180 	ubfx	r1, r2, #6, #1
   2bf10:	430b      	orrs	r3, r1
        | val->fsm_int2_a.int2_fsm8
   2bf12:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
        | val->fsm_int2_b.int2_fsm9
   2bf16:	792a      	ldrb	r2, [r5, #4]
   2bf18:	f3c2 0100 	ubfx	r1, r2, #0, #1
   2bf1c:	430b      	orrs	r3, r1
        | val->fsm_int2_b.int2_fsm10
   2bf1e:	f3c2 0140 	ubfx	r1, r2, #1, #1
   2bf22:	430b      	orrs	r3, r1
        | val->fsm_int2_b.int2_fsm11
   2bf24:	f3c2 0180 	ubfx	r1, r2, #2, #1
   2bf28:	430b      	orrs	r3, r1
        | val->fsm_int2_b.int2_fsm12
   2bf2a:	f3c2 01c0 	ubfx	r1, r2, #3, #1
   2bf2e:	430b      	orrs	r3, r1
        | val->fsm_int2_b.int2_fsm13
   2bf30:	f3c2 1100 	ubfx	r1, r2, #4, #1
   2bf34:	430b      	orrs	r3, r1
        | val->fsm_int2_b.int2_fsm14
   2bf36:	f3c2 1140 	ubfx	r1, r2, #5, #1
   2bf3a:	430b      	orrs	r3, r1
        | val->fsm_int2_b.int2_fsm15
   2bf3c:	f3c2 1180 	ubfx	r1, r2, #6, #1
   2bf40:	430b      	orrs	r3, r1
        | val->fsm_int2_b.int2_fsm16 )!= PROPERTY_DISABLE ){
   2bf42:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
   2bf46:	786a      	ldrb	r2, [r5, #1]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT2_CTRL,
   2bf48:	210e      	movs	r1, #14
   2bf4a:	f363 0241 	bfi	r2, r3, #1, #1
   2bf4e:	706a      	strb	r2, [r5, #1]
   2bf50:	2301      	movs	r3, #1
   2bf52:	462a      	mov	r2, r5
   2bf54:	f7ff fc5f 	bl	2b816 <lsm6dso_write_reg>
                            (uint8_t*)&val->int2_ctrl, 1);
  }
  if (ret == 0) {
   2bf58:	2800      	cmp	r0, #0
   2bf5a:	d174      	bne.n	2c046 <lsm6dso_pin_int2_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_MD2_CFG, (uint8_t*)&val->md2_cfg, 1);
   2bf5c:	2301      	movs	r3, #1
   2bf5e:	215f      	movs	r1, #95	; 0x5f
   2bf60:	18ea      	adds	r2, r5, r3
   2bf62:	4620      	mov	r0, r4
   2bf64:	f7ff fc57 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2bf68:	2800      	cmp	r0, #0
   2bf6a:	d16c      	bne.n	2c046 <lsm6dso_pin_int2_route_set+0x1d0>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*) &tap_cfg2, 1);
   2bf6c:	2301      	movs	r3, #1
   2bf6e:	aa01      	add	r2, sp, #4
   2bf70:	2158      	movs	r1, #88	; 0x58
   2bf72:	4620      	mov	r0, r4
   2bf74:	f7ff fc48 	bl	2b808 <lsm6dso_read_reg>
  }

  if (ret == 0) {
   2bf78:	2800      	cmp	r0, #0
   2bf7a:	d164      	bne.n	2c046 <lsm6dso_pin_int2_route_set+0x1d0>
    ret = lsm6dso_pin_int1_route_get(ctx, &pin_int1_route);
   2bf7c:	a902      	add	r1, sp, #8
   2bf7e:	4620      	mov	r0, r4
   2bf80:	f7ff ff48 	bl	2be14 <lsm6dso_pin_int1_route_get>
  }

  if (ret == 0) {
   2bf84:	2800      	cmp	r0, #0
   2bf86:	d15e      	bne.n	2c046 <lsm6dso_pin_int2_route_set+0x1d0>
         | val->md2_cfg.int2_double_tap
         | val->md2_cfg.int2_ff
         | val->md2_cfg.int2_wu
         | val->md2_cfg.int2_single_tap
         | val->md2_cfg.int2_sleep_change
         | pin_int1_route.int1_ctrl.den_drdy_flag
   2bf88:	f89d 2008 	ldrb.w	r2, [sp, #8]
      tap_cfg2.interrupts_enable = PROPERTY_ENABLE;
    }
    else{
      tap_cfg2.interrupts_enable = PROPERTY_DISABLE;
    }
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*) &tap_cfg2, 1);
   2bf8c:	4620      	mov	r0, r4
         | pin_int1_route.int1_ctrl.int1_boot
   2bf8e:	f3c2 0380 	ubfx	r3, r2, #2, #1
         | pin_int1_route.int1_ctrl.int1_cnt_bdr
   2bf92:	f3c2 1180 	ubfx	r1, r2, #6, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bf96:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
   2bf9a:	430b      	orrs	r3, r1
         | pin_int1_route.int1_ctrl.int1_drdy_g
   2bf9c:	f3c2 0140 	ubfx	r1, r2, #1, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bfa0:	430b      	orrs	r3, r1
         | pin_int1_route.int1_ctrl.int1_drdy_xl
   2bfa2:	f3c2 0100 	ubfx	r1, r2, #0, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bfa6:	430b      	orrs	r3, r1
         | pin_int1_route.int1_ctrl.int1_fifo_full
   2bfa8:	f3c2 1140 	ubfx	r1, r2, #5, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bfac:	430b      	orrs	r3, r1
         | pin_int1_route.int1_ctrl.int1_fifo_ovr
   2bfae:	f3c2 1100 	ubfx	r1, r2, #4, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bfb2:	430b      	orrs	r3, r1
         | pin_int1_route.int1_ctrl.int1_fifo_th
   2bfb4:	f3c2 02c0 	ubfx	r2, r2, #3, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bfb8:	4313      	orrs	r3, r2
         | pin_int1_route.md1_cfg.int1_6d
   2bfba:	f89d 2009 	ldrb.w	r2, [sp, #9]
   2bfbe:	f3c2 0180 	ubfx	r1, r2, #2, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bfc2:	430b      	orrs	r3, r1
         | pin_int1_route.md1_cfg.int1_double_tap
   2bfc4:	f3c2 01c0 	ubfx	r1, r2, #3, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bfc8:	430b      	orrs	r3, r1
         | pin_int1_route.md1_cfg.int1_ff
   2bfca:	f3c2 1100 	ubfx	r1, r2, #4, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bfce:	430b      	orrs	r3, r1
         | pin_int1_route.md1_cfg.int1_wu
   2bfd0:	f3c2 1140 	ubfx	r1, r2, #5, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bfd4:	430b      	orrs	r3, r1
         | pin_int1_route.md1_cfg.int1_single_tap
   2bfd6:	f3c2 1180 	ubfx	r1, r2, #6, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bfda:	430b      	orrs	r3, r1
   2bfdc:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
    if ( ( val->int2_ctrl.int2_cnt_bdr
   2bfe0:	782a      	ldrb	r2, [r5, #0]
   2bfe2:	f3c2 1180 	ubfx	r1, r2, #6, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bfe6:	430b      	orrs	r3, r1
         | val->int2_ctrl.int2_drdy_g
   2bfe8:	f3c2 0140 	ubfx	r1, r2, #1, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bfec:	430b      	orrs	r3, r1
         | val->int2_ctrl.int2_drdy_temp
   2bfee:	f3c2 0180 	ubfx	r1, r2, #2, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bff2:	430b      	orrs	r3, r1
         | val->int2_ctrl.int2_drdy_xl
   2bff4:	f3c2 0100 	ubfx	r1, r2, #0, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bff8:	430b      	orrs	r3, r1
         | val->int2_ctrl.int2_fifo_full
   2bffa:	f3c2 1140 	ubfx	r1, r2, #5, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2bffe:	430b      	orrs	r3, r1
         | val->int2_ctrl.int2_fifo_ovr
   2c000:	f3c2 1100 	ubfx	r1, r2, #4, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2c004:	430b      	orrs	r3, r1
         | val->int2_ctrl.int2_fifo_th
   2c006:	f3c2 02c0 	ubfx	r2, r2, #3, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2c00a:	4313      	orrs	r3, r2
         | val->md2_cfg.int2_6d
   2c00c:	786a      	ldrb	r2, [r5, #1]
   2c00e:	f3c2 0180 	ubfx	r1, r2, #2, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2c012:	430b      	orrs	r3, r1
         | val->md2_cfg.int2_double_tap
   2c014:	f3c2 01c0 	ubfx	r1, r2, #3, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2c018:	430b      	orrs	r3, r1
         | val->md2_cfg.int2_ff
   2c01a:	f3c2 1100 	ubfx	r1, r2, #4, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2c01e:	430b      	orrs	r3, r1
         | val->md2_cfg.int2_wu
   2c020:	f3c2 1140 	ubfx	r1, r2, #5, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2c024:	430b      	orrs	r3, r1
         | val->md2_cfg.int2_single_tap
   2c026:	f3c2 1180 	ubfx	r1, r2, #6, #1
         | pin_int1_route.md1_cfg.int1_sleep_change ) != PROPERTY_DISABLE) {
   2c02a:	430b      	orrs	r3, r1
   2c02c:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
   2c030:	f89d 2004 	ldrb.w	r2, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*) &tap_cfg2, 1);
   2c034:	2158      	movs	r1, #88	; 0x58
   2c036:	f363 12c7 	bfi	r2, r3, #7, #1
   2c03a:	f88d 2004 	strb.w	r2, [sp, #4]
   2c03e:	2301      	movs	r3, #1
   2c040:	aa01      	add	r2, sp, #4
   2c042:	f7ff fbe8 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2c046:	b005      	add	sp, #20
   2c048:	bd30      	pop	{r4, r5, pc}

0002c04a <lsm6dso_pin_int2_route_get>:
  *                  EMB_FUNC_INT2, FSM_INT2_A, FSM_INT2_B
  *
  */
int32_t lsm6dso_pin_int2_route_get(stmdev_ctx_t *ctx,
                                   lsm6dso_pin_int2_route_t *val)
{
   2c04a:	b570      	push	{r4, r5, r6, lr}
   2c04c:	460d      	mov	r5, r1
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2c04e:	2102      	movs	r1, #2
{
   2c050:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2c052:	f7ff fc87 	bl	2b964 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   2c056:	bb40      	cbnz	r0, 2c0aa <lsm6dso_pin_int2_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_INT2,
   2c058:	2301      	movs	r3, #1
   2c05a:	1caa      	adds	r2, r5, #2
   2c05c:	210e      	movs	r1, #14
   2c05e:	4620      	mov	r0, r4
   2c060:	f7ff fbd2 	bl	2b808 <lsm6dso_read_reg>
                           (uint8_t*)&val->emb_func_int2, 1);
  }
  if (ret == 0) {
   2c064:	bb08      	cbnz	r0, 2c0aa <lsm6dso_pin_int2_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FSM_INT2_A,
   2c066:	2301      	movs	r3, #1
   2c068:	1cea      	adds	r2, r5, #3
   2c06a:	210f      	movs	r1, #15
   2c06c:	4620      	mov	r0, r4
   2c06e:	f7ff fbcb 	bl	2b808 <lsm6dso_read_reg>
                           (uint8_t*)&val->fsm_int2_a, 1);
  }
  if (ret == 0) {
   2c072:	b9d0      	cbnz	r0, 2c0aa <lsm6dso_pin_int2_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FSM_INT2_B,
   2c074:	2301      	movs	r3, #1
   2c076:	1d2a      	adds	r2, r5, #4
   2c078:	2110      	movs	r1, #16
   2c07a:	4620      	mov	r0, r4
   2c07c:	f7ff fbc4 	bl	2b808 <lsm6dso_read_reg>
                           (uint8_t*)&val->fsm_int2_b, 1);
  }
  if (ret == 0) {
   2c080:	b998      	cbnz	r0, 2c0aa <lsm6dso_pin_int2_route_get+0x60>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2c082:	4601      	mov	r1, r0
   2c084:	4620      	mov	r0, r4
   2c086:	f7ff fc6d 	bl	2b964 <lsm6dso_mem_bank_set>
  }
  if (ret == 0) {
   2c08a:	b970      	cbnz	r0, 2c0aa <lsm6dso_pin_int2_route_get+0x60>

    ret = lsm6dso_read_reg(ctx, LSM6DSO_INT2_CTRL,
   2c08c:	2301      	movs	r3, #1
   2c08e:	462a      	mov	r2, r5
   2c090:	210e      	movs	r1, #14
   2c092:	4620      	mov	r0, r4
   2c094:	f7ff fbb8 	bl	2b808 <lsm6dso_read_reg>
                           (uint8_t*)&val->int2_ctrl, 1);
  }
  if (ret == 0) {
   2c098:	b938      	cbnz	r0, 2c0aa <lsm6dso_pin_int2_route_get+0x60>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_MD2_CFG, (uint8_t*)&val->md2_cfg, 1);
   2c09a:	2301      	movs	r3, #1
   2c09c:	4620      	mov	r0, r4
   2c09e:	18ea      	adds	r2, r5, r3
   2c0a0:	215f      	movs	r1, #95	; 0x5f
  }
  return ret;
}
   2c0a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    ret = lsm6dso_read_reg(ctx, LSM6DSO_MD2_CFG, (uint8_t*)&val->md2_cfg, 1);
   2c0a6:	f7ff bbaf 	b.w	2b808 <lsm6dso_read_reg>
}
   2c0aa:	bd70      	pop	{r4, r5, r6, pc}

0002c0ac <lsm6dso_pin_int1_route_set>:
{
   2c0ac:	b530      	push	{r4, r5, lr}
   2c0ae:	460d      	mov	r5, r1
   2c0b0:	b085      	sub	sp, #20
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2c0b2:	2102      	movs	r1, #2
{
   2c0b4:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2c0b6:	f7ff fc55 	bl	2b964 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   2c0ba:	2800      	cmp	r0, #0
   2c0bc:	f040 80de 	bne.w	2c27c <lsm6dso_pin_int1_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_INT1,
   2c0c0:	2301      	movs	r3, #1
   2c0c2:	1caa      	adds	r2, r5, #2
   2c0c4:	210a      	movs	r1, #10
   2c0c6:	4620      	mov	r0, r4
   2c0c8:	f7ff fba5 	bl	2b816 <lsm6dso_write_reg>
  if (ret == 0) {
   2c0cc:	2800      	cmp	r0, #0
   2c0ce:	f040 80d5 	bne.w	2c27c <lsm6dso_pin_int1_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FSM_INT1_A,
   2c0d2:	2301      	movs	r3, #1
   2c0d4:	1cea      	adds	r2, r5, #3
   2c0d6:	210b      	movs	r1, #11
   2c0d8:	4620      	mov	r0, r4
   2c0da:	f7ff fb9c 	bl	2b816 <lsm6dso_write_reg>
  if (ret == 0) {
   2c0de:	2800      	cmp	r0, #0
   2c0e0:	f040 80cc 	bne.w	2c27c <lsm6dso_pin_int1_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FSM_INT1_B,
   2c0e4:	2301      	movs	r3, #1
   2c0e6:	1d2a      	adds	r2, r5, #4
   2c0e8:	210c      	movs	r1, #12
   2c0ea:	4620      	mov	r0, r4
   2c0ec:	f7ff fb93 	bl	2b816 <lsm6dso_write_reg>
  if (ret == 0) {
   2c0f0:	2800      	cmp	r0, #0
   2c0f2:	f040 80c3 	bne.w	2c27c <lsm6dso_pin_int1_route_set+0x1d0>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2c0f6:	4601      	mov	r1, r0
   2c0f8:	4620      	mov	r0, r4
   2c0fa:	f7ff fc33 	bl	2b964 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   2c0fe:	2800      	cmp	r0, #0
   2c100:	f040 80bc 	bne.w	2c27c <lsm6dso_pin_int1_route_set+0x1d0>
    if ( ( val->emb_func_int1.int1_fsm_lc
   2c104:	78aa      	ldrb	r2, [r5, #2]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT1_CTRL,
   2c106:	4620      	mov	r0, r4
         | val->emb_func_int1.int1_sig_mot
   2c108:	f3c2 1340 	ubfx	r3, r2, #5, #1
         | val->emb_func_int1.int1_step_detector
   2c10c:	f3c2 01c0 	ubfx	r1, r2, #3, #1
         | val->emb_func_int1.int1_sig_mot
   2c110:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
         | val->emb_func_int1.int1_step_detector
   2c114:	430b      	orrs	r3, r1
         | val->emb_func_int1.int1_tilt
   2c116:	f3c2 1200 	ubfx	r2, r2, #4, #1
   2c11a:	4313      	orrs	r3, r2
         | val->fsm_int1_a.int1_fsm1
   2c11c:	78ea      	ldrb	r2, [r5, #3]
   2c11e:	f3c2 0100 	ubfx	r1, r2, #0, #1
   2c122:	430b      	orrs	r3, r1
         | val->fsm_int1_a.int1_fsm2
   2c124:	f3c2 0140 	ubfx	r1, r2, #1, #1
   2c128:	430b      	orrs	r3, r1
         | val->fsm_int1_a.int1_fsm3
   2c12a:	f3c2 0180 	ubfx	r1, r2, #2, #1
   2c12e:	430b      	orrs	r3, r1
         | val->fsm_int1_a.int1_fsm4
   2c130:	f3c2 01c0 	ubfx	r1, r2, #3, #1
   2c134:	430b      	orrs	r3, r1
         | val->fsm_int1_a.int1_fsm5
   2c136:	f3c2 1100 	ubfx	r1, r2, #4, #1
   2c13a:	430b      	orrs	r3, r1
         | val->fsm_int1_a.int1_fsm6
   2c13c:	f3c2 1140 	ubfx	r1, r2, #5, #1
   2c140:	430b      	orrs	r3, r1
         | val->fsm_int1_a.int1_fsm7
   2c142:	f3c2 1180 	ubfx	r1, r2, #6, #1
   2c146:	430b      	orrs	r3, r1
         | val->fsm_int1_a.int1_fsm8
   2c148:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
         | val->fsm_int1_b.int1_fsm9
   2c14c:	792a      	ldrb	r2, [r5, #4]
   2c14e:	f3c2 0100 	ubfx	r1, r2, #0, #1
   2c152:	430b      	orrs	r3, r1
         | val->fsm_int1_b.int1_fsm10
   2c154:	f3c2 0140 	ubfx	r1, r2, #1, #1
   2c158:	430b      	orrs	r3, r1
         | val->fsm_int1_b.int1_fsm11
   2c15a:	f3c2 0180 	ubfx	r1, r2, #2, #1
   2c15e:	430b      	orrs	r3, r1
         | val->fsm_int1_b.int1_fsm12
   2c160:	f3c2 01c0 	ubfx	r1, r2, #3, #1
   2c164:	430b      	orrs	r3, r1
         | val->fsm_int1_b.int1_fsm13
   2c166:	f3c2 1100 	ubfx	r1, r2, #4, #1
   2c16a:	430b      	orrs	r3, r1
         | val->fsm_int1_b.int1_fsm14
   2c16c:	f3c2 1140 	ubfx	r1, r2, #5, #1
   2c170:	430b      	orrs	r3, r1
         | val->fsm_int1_b.int1_fsm15
   2c172:	f3c2 1180 	ubfx	r1, r2, #6, #1
   2c176:	430b      	orrs	r3, r1
         | val->fsm_int1_b.int1_fsm16) != PROPERTY_DISABLE){
   2c178:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
   2c17c:	786a      	ldrb	r2, [r5, #1]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT1_CTRL,
   2c17e:	210d      	movs	r1, #13
   2c180:	f363 0241 	bfi	r2, r3, #1, #1
   2c184:	706a      	strb	r2, [r5, #1]
   2c186:	2301      	movs	r3, #1
   2c188:	462a      	mov	r2, r5
   2c18a:	f7ff fb44 	bl	2b816 <lsm6dso_write_reg>
  if (ret == 0) {
   2c18e:	2800      	cmp	r0, #0
   2c190:	d174      	bne.n	2c27c <lsm6dso_pin_int1_route_set+0x1d0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_MD1_CFG, (uint8_t*)&val->md1_cfg, 1);
   2c192:	2301      	movs	r3, #1
   2c194:	215e      	movs	r1, #94	; 0x5e
   2c196:	18ea      	adds	r2, r5, r3
   2c198:	4620      	mov	r0, r4
   2c19a:	f7ff fb3c 	bl	2b816 <lsm6dso_write_reg>
  if (ret == 0) {
   2c19e:	2800      	cmp	r0, #0
   2c1a0:	d16c      	bne.n	2c27c <lsm6dso_pin_int1_route_set+0x1d0>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*) &tap_cfg2, 1);
   2c1a2:	2301      	movs	r3, #1
   2c1a4:	aa01      	add	r2, sp, #4
   2c1a6:	2158      	movs	r1, #88	; 0x58
   2c1a8:	4620      	mov	r0, r4
   2c1aa:	f7ff fb2d 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c1ae:	2800      	cmp	r0, #0
   2c1b0:	d164      	bne.n	2c27c <lsm6dso_pin_int1_route_set+0x1d0>
    ret = lsm6dso_pin_int2_route_get(ctx, &pin_int2_route);
   2c1b2:	a902      	add	r1, sp, #8
   2c1b4:	4620      	mov	r0, r4
   2c1b6:	f7ff ff48 	bl	2c04a <lsm6dso_pin_int2_route_get>
  if (ret == 0) {
   2c1ba:	2800      	cmp	r0, #0
   2c1bc:	d15e      	bne.n	2c27c <lsm6dso_pin_int1_route_set+0x1d0>
    if ( ( pin_int2_route.int2_ctrl.int2_cnt_bdr
   2c1be:	f89d 2008 	ldrb.w	r2, [sp, #8]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*) &tap_cfg2, 1);
   2c1c2:	4620      	mov	r0, r4
         | pin_int2_route.int2_ctrl.int2_drdy_g
   2c1c4:	f3c2 0140 	ubfx	r1, r2, #1, #1
    if ( ( pin_int2_route.int2_ctrl.int2_cnt_bdr
   2c1c8:	f3c2 1380 	ubfx	r3, r2, #6, #1
         | pin_int2_route.int2_ctrl.int2_drdy_g
   2c1cc:	430b      	orrs	r3, r1
         | pin_int2_route.int2_ctrl.int2_drdy_temp
   2c1ce:	f3c2 0180 	ubfx	r1, r2, #2, #1
   2c1d2:	430b      	orrs	r3, r1
         | pin_int2_route.int2_ctrl.int2_drdy_xl
   2c1d4:	f3c2 0100 	ubfx	r1, r2, #0, #1
   2c1d8:	430b      	orrs	r3, r1
         | pin_int2_route.int2_ctrl.int2_fifo_full
   2c1da:	f3c2 1140 	ubfx	r1, r2, #5, #1
   2c1de:	430b      	orrs	r3, r1
         | pin_int2_route.int2_ctrl.int2_fifo_ovr
   2c1e0:	f3c2 1100 	ubfx	r1, r2, #4, #1
   2c1e4:	430b      	orrs	r3, r1
         | pin_int2_route.int2_ctrl.int2_fifo_th
   2c1e6:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   2c1ea:	4313      	orrs	r3, r2
         | pin_int2_route.md2_cfg.int2_6d
   2c1ec:	f89d 2009 	ldrb.w	r2, [sp, #9]
   2c1f0:	f3c2 0180 	ubfx	r1, r2, #2, #1
   2c1f4:	430b      	orrs	r3, r1
         | pin_int2_route.md2_cfg.int2_double_tap
   2c1f6:	f3c2 01c0 	ubfx	r1, r2, #3, #1
   2c1fa:	430b      	orrs	r3, r1
         | pin_int2_route.md2_cfg.int2_ff
   2c1fc:	f3c2 1100 	ubfx	r1, r2, #4, #1
   2c200:	430b      	orrs	r3, r1
         | pin_int2_route.md2_cfg.int2_wu
   2c202:	f3c2 1140 	ubfx	r1, r2, #5, #1
   2c206:	430b      	orrs	r3, r1
         | pin_int2_route.md2_cfg.int2_single_tap
   2c208:	f3c2 1180 	ubfx	r1, r2, #6, #1
   2c20c:	430b      	orrs	r3, r1
         | pin_int2_route.md2_cfg.int2_sleep_change
   2c20e:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
         | val->int1_ctrl.den_drdy_flag
   2c212:	782a      	ldrb	r2, [r5, #0]
         | val->int1_ctrl.int1_boot
   2c214:	f3c2 0180 	ubfx	r1, r2, #2, #1
         | val->int1_ctrl.den_drdy_flag
   2c218:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
         | val->int1_ctrl.int1_boot
   2c21c:	430b      	orrs	r3, r1
         | val->int1_ctrl.int1_cnt_bdr
   2c21e:	f3c2 1180 	ubfx	r1, r2, #6, #1
   2c222:	430b      	orrs	r3, r1
         | val->int1_ctrl.int1_drdy_g
   2c224:	f3c2 0140 	ubfx	r1, r2, #1, #1
   2c228:	430b      	orrs	r3, r1
         | val->int1_ctrl.int1_drdy_xl
   2c22a:	f3c2 0100 	ubfx	r1, r2, #0, #1
   2c22e:	430b      	orrs	r3, r1
         | val->int1_ctrl.int1_fifo_full
   2c230:	f3c2 1140 	ubfx	r1, r2, #5, #1
   2c234:	430b      	orrs	r3, r1
         | val->int1_ctrl.int1_fifo_ovr
   2c236:	f3c2 1100 	ubfx	r1, r2, #4, #1
   2c23a:	430b      	orrs	r3, r1
         | val->int1_ctrl.int1_fifo_th
   2c23c:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   2c240:	4313      	orrs	r3, r2
         | val->md1_cfg.int1_6d
   2c242:	786a      	ldrb	r2, [r5, #1]
   2c244:	f3c2 0180 	ubfx	r1, r2, #2, #1
   2c248:	430b      	orrs	r3, r1
         | val->md1_cfg.int1_double_tap
   2c24a:	f3c2 01c0 	ubfx	r1, r2, #3, #1
   2c24e:	430b      	orrs	r3, r1
         | val->md1_cfg.int1_ff
   2c250:	f3c2 1100 	ubfx	r1, r2, #4, #1
   2c254:	430b      	orrs	r3, r1
         | val->md1_cfg.int1_wu
   2c256:	f3c2 1140 	ubfx	r1, r2, #5, #1
   2c25a:	430b      	orrs	r3, r1
         | val->md1_cfg.int1_single_tap
   2c25c:	f3c2 1180 	ubfx	r1, r2, #6, #1
   2c260:	430b      	orrs	r3, r1
         | val->md1_cfg.int1_sleep_change) != PROPERTY_DISABLE) {
   2c262:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
   2c266:	f89d 2004 	ldrb.w	r2, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*) &tap_cfg2, 1);
   2c26a:	2158      	movs	r1, #88	; 0x58
   2c26c:	f363 12c7 	bfi	r2, r3, #7, #1
   2c270:	f88d 2004 	strb.w	r2, [sp, #4]
   2c274:	2301      	movs	r3, #1
   2c276:	aa01      	add	r2, sp, #4
   2c278:	f7ff facd 	bl	2b816 <lsm6dso_write_reg>
}
   2c27c:	b005      	add	sp, #20
   2c27e:	bd30      	pop	{r4, r5, pc}

0002c280 <lsm6dso_int_notification_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of lir in reg TAP_CFG0
  *
  */
int32_t lsm6dso_int_notification_set(stmdev_ctx_t *ctx, lsm6dso_lir_t val)
{
   2c280:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_tap_cfg0_t tap_cfg0;
  lsm6dso_page_rw_t page_rw;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*) &tap_cfg0, 1);
   2c282:	2301      	movs	r3, #1
{
   2c284:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*) &tap_cfg0, 1);
   2c286:	466a      	mov	r2, sp
   2c288:	2156      	movs	r1, #86	; 0x56
{
   2c28a:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*) &tap_cfg0, 1);
   2c28c:	f7ff fabc 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c290:	bb70      	cbnz	r0, 2c2f0 <lsm6dso_int_notification_set+0x70>
    tap_cfg0.lir = (uint8_t)val & 0x01U;
   2c292:	f89d 3000 	ldrb.w	r3, [sp]
   2c296:	f005 0201 	and.w	r2, r5, #1
   2c29a:	f362 0300 	bfi	r3, r2, #0, #1
    tap_cfg0.int_clr_on_read = (uint8_t)val & 0x01U;
   2c29e:	f362 1386 	bfi	r3, r2, #6, #1
   2c2a2:	f88d 3000 	strb.w	r3, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*) &tap_cfg0, 1);
   2c2a6:	466a      	mov	r2, sp
   2c2a8:	2301      	movs	r3, #1
   2c2aa:	2156      	movs	r1, #86	; 0x56
   2c2ac:	4620      	mov	r0, r4
   2c2ae:	f7ff fab2 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2c2b2:	b9e8      	cbnz	r0, 2c2f0 <lsm6dso_int_notification_set+0x70>

    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2c2b4:	2102      	movs	r1, #2
   2c2b6:	4620      	mov	r0, r4
   2c2b8:	f7ff fb54 	bl	2b964 <lsm6dso_mem_bank_set>
  }
  if (ret == 0) {
   2c2bc:	b9c0      	cbnz	r0, 2c2f0 <lsm6dso_int_notification_set+0x70>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2c2be:	2301      	movs	r3, #1
   2c2c0:	aa01      	add	r2, sp, #4
   2c2c2:	2117      	movs	r1, #23
   2c2c4:	4620      	mov	r0, r4
   2c2c6:	f7ff fa9f 	bl	2b808 <lsm6dso_read_reg>
  }
  if (ret == 0) {
   2c2ca:	b988      	cbnz	r0, 2c2f0 <lsm6dso_int_notification_set+0x70>
    page_rw.emb_func_lir = ((uint8_t)val & 0x02U) >> 1;
   2c2cc:	f89d 3004 	ldrb.w	r3, [sp, #4]
   2c2d0:	086d      	lsrs	r5, r5, #1
   2c2d2:	f365 13c7 	bfi	r3, r5, #7, #1
   2c2d6:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_PAGE_RW, (uint8_t*) &page_rw, 1);
   2c2da:	aa01      	add	r2, sp, #4
   2c2dc:	2301      	movs	r3, #1
   2c2de:	2117      	movs	r1, #23
   2c2e0:	4620      	mov	r0, r4
   2c2e2:	f7ff fa98 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2c2e6:	b918      	cbnz	r0, 2c2f0 <lsm6dso_int_notification_set+0x70>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2c2e8:	4601      	mov	r1, r0
   2c2ea:	4620      	mov	r0, r4
   2c2ec:	f7ff fb3a 	bl	2b964 <lsm6dso_mem_bank_set>
  }

  return ret;
}
   2c2f0:	b003      	add	sp, #12
   2c2f2:	bd30      	pop	{r4, r5, pc}

0002c2f4 <lsm6dso_tap_detection_on_z_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of tap_z_en in reg TAP_CFG0
  *
  */
int32_t lsm6dso_tap_detection_on_z_set(stmdev_ctx_t *ctx, uint8_t val)
{
   2c2f4:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_tap_cfg0_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   2c2f6:	2301      	movs	r3, #1
{
   2c2f8:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   2c2fa:	aa01      	add	r2, sp, #4
   2c2fc:	2156      	movs	r1, #86	; 0x56
{
   2c2fe:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   2c300:	f7ff fa82 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c304:	b958      	cbnz	r0, 2c31e <lsm6dso_tap_detection_on_z_set+0x2a>
    reg.tap_z_en = val;
   2c306:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   2c30a:	aa01      	add	r2, sp, #4
    reg.tap_z_en = val;
   2c30c:	f365 0341 	bfi	r3, r5, #1, #1
   2c310:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   2c314:	2156      	movs	r1, #86	; 0x56
   2c316:	2301      	movs	r3, #1
   2c318:	4620      	mov	r0, r4
   2c31a:	f7ff fa7c 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2c31e:	b003      	add	sp, #12
   2c320:	bd30      	pop	{r4, r5, pc}

0002c322 <lsm6dso_tap_detection_on_y_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of tap_y_en in reg TAP_CFG0
  *
  */
int32_t lsm6dso_tap_detection_on_y_set(stmdev_ctx_t *ctx, uint8_t val)
{
   2c322:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_tap_cfg0_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   2c324:	2301      	movs	r3, #1
{
   2c326:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   2c328:	aa01      	add	r2, sp, #4
   2c32a:	2156      	movs	r1, #86	; 0x56
{
   2c32c:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   2c32e:	f7ff fa6b 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c332:	b958      	cbnz	r0, 2c34c <lsm6dso_tap_detection_on_y_set+0x2a>
    reg.tap_y_en = val;
   2c334:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   2c338:	aa01      	add	r2, sp, #4
    reg.tap_y_en = val;
   2c33a:	f365 0382 	bfi	r3, r5, #2, #1
   2c33e:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   2c342:	2156      	movs	r1, #86	; 0x56
   2c344:	2301      	movs	r3, #1
   2c346:	4620      	mov	r0, r4
   2c348:	f7ff fa65 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2c34c:	b003      	add	sp, #12
   2c34e:	bd30      	pop	{r4, r5, pc}

0002c350 <lsm6dso_tap_detection_on_x_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of tap_x_en in reg TAP_CFG0
  *
  */
int32_t lsm6dso_tap_detection_on_x_set(stmdev_ctx_t *ctx, uint8_t val)
{
   2c350:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_tap_cfg0_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   2c352:	2301      	movs	r3, #1
{
   2c354:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   2c356:	aa01      	add	r2, sp, #4
   2c358:	2156      	movs	r1, #86	; 0x56
{
   2c35a:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   2c35c:	f7ff fa54 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c360:	b958      	cbnz	r0, 2c37a <lsm6dso_tap_detection_on_x_set+0x2a>
    reg.tap_x_en = val;
   2c362:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   2c366:	aa01      	add	r2, sp, #4
    reg.tap_x_en = val;
   2c368:	f365 03c3 	bfi	r3, r5, #3, #1
   2c36c:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG0, (uint8_t*)&reg, 1);
   2c370:	2156      	movs	r1, #86	; 0x56
   2c372:	2301      	movs	r3, #1
   2c374:	4620      	mov	r0, r4
   2c376:	f7ff fa4e 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2c37a:	b003      	add	sp, #12
   2c37c:	bd30      	pop	{r4, r5, pc}

0002c37e <lsm6dso_tap_threshold_x_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of tap_ths_x in reg TAP_CFG1
  *
  */
int32_t lsm6dso_tap_threshold_x_set(stmdev_ctx_t *ctx, uint8_t val)
{
   2c37e:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_tap_cfg1_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG1, (uint8_t*)&reg, 1);
   2c380:	2301      	movs	r3, #1
{
   2c382:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG1, (uint8_t*)&reg, 1);
   2c384:	aa01      	add	r2, sp, #4
   2c386:	2157      	movs	r1, #87	; 0x57
{
   2c388:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG1, (uint8_t*)&reg, 1);
   2c38a:	f7ff fa3d 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c38e:	b958      	cbnz	r0, 2c3a8 <lsm6dso_tap_threshold_x_set+0x2a>
    reg.tap_ths_x = val;
   2c390:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG1, (uint8_t*)&reg, 1);
   2c394:	aa01      	add	r2, sp, #4
    reg.tap_ths_x = val;
   2c396:	f365 0304 	bfi	r3, r5, #0, #5
   2c39a:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG1, (uint8_t*)&reg, 1);
   2c39e:	2157      	movs	r1, #87	; 0x57
   2c3a0:	2301      	movs	r3, #1
   2c3a2:	4620      	mov	r0, r4
   2c3a4:	f7ff fa37 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2c3a8:	b003      	add	sp, #12
   2c3aa:	bd30      	pop	{r4, r5, pc}

0002c3ac <lsm6dso_tap_threshold_y_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of tap_ths_y in reg TAP_CFG2
  *
  */
int32_t lsm6dso_tap_threshold_y_set(stmdev_ctx_t *ctx, uint8_t val)
{
   2c3ac:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_tap_cfg2_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*)&reg, 1);
   2c3ae:	2301      	movs	r3, #1
{
   2c3b0:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*)&reg, 1);
   2c3b2:	aa01      	add	r2, sp, #4
   2c3b4:	2158      	movs	r1, #88	; 0x58
{
   2c3b6:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*)&reg, 1);
   2c3b8:	f7ff fa26 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c3bc:	b958      	cbnz	r0, 2c3d6 <lsm6dso_tap_threshold_y_set+0x2a>
    reg.tap_ths_y = val;
   2c3be:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*)&reg, 1);
   2c3c2:	aa01      	add	r2, sp, #4
    reg.tap_ths_y = val;
   2c3c4:	f365 0304 	bfi	r3, r5, #0, #5
   2c3c8:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_CFG2, (uint8_t*)&reg, 1);
   2c3cc:	2158      	movs	r1, #88	; 0x58
   2c3ce:	2301      	movs	r3, #1
   2c3d0:	4620      	mov	r0, r4
   2c3d2:	f7ff fa20 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2c3d6:	b003      	add	sp, #12
   2c3d8:	bd30      	pop	{r4, r5, pc}

0002c3da <lsm6dso_tap_threshold_z_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of tap_ths_z in reg TAP_THS_6D
  *
  */
int32_t lsm6dso_tap_threshold_z_set(stmdev_ctx_t *ctx, uint8_t val)
{
   2c3da:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_tap_ths_6d_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_THS_6D, (uint8_t*)&reg, 1);
   2c3dc:	2301      	movs	r3, #1
{
   2c3de:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_THS_6D, (uint8_t*)&reg, 1);
   2c3e0:	aa01      	add	r2, sp, #4
   2c3e2:	2159      	movs	r1, #89	; 0x59
{
   2c3e4:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_TAP_THS_6D, (uint8_t*)&reg, 1);
   2c3e6:	f7ff fa0f 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c3ea:	b958      	cbnz	r0, 2c404 <lsm6dso_tap_threshold_z_set+0x2a>
    reg.tap_ths_z = val;
   2c3ec:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_THS_6D, (uint8_t*)&reg, 1);
   2c3f0:	aa01      	add	r2, sp, #4
    reg.tap_ths_z = val;
   2c3f2:	f365 0304 	bfi	r3, r5, #0, #5
   2c3f6:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_TAP_THS_6D, (uint8_t*)&reg, 1);
   2c3fa:	2159      	movs	r1, #89	; 0x59
   2c3fc:	2301      	movs	r3, #1
   2c3fe:	4620      	mov	r0, r4
   2c400:	f7ff fa09 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2c404:	b003      	add	sp, #12
   2c406:	bd30      	pop	{r4, r5, pc}

0002c408 <lsm6dso_tap_shock_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of shock in reg INT_DUR2
  *
  */
int32_t lsm6dso_tap_shock_set(stmdev_ctx_t *ctx, uint8_t val)
{
   2c408:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_int_dur2_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   2c40a:	2301      	movs	r3, #1
{
   2c40c:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   2c40e:	aa01      	add	r2, sp, #4
   2c410:	215a      	movs	r1, #90	; 0x5a
{
   2c412:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   2c414:	f7ff f9f8 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c418:	b958      	cbnz	r0, 2c432 <lsm6dso_tap_shock_set+0x2a>
    reg.shock = val;
   2c41a:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   2c41e:	aa01      	add	r2, sp, #4
    reg.shock = val;
   2c420:	f365 0301 	bfi	r3, r5, #0, #2
   2c424:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   2c428:	215a      	movs	r1, #90	; 0x5a
   2c42a:	2301      	movs	r3, #1
   2c42c:	4620      	mov	r0, r4
   2c42e:	f7ff f9f2 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2c432:	b003      	add	sp, #12
   2c434:	bd30      	pop	{r4, r5, pc}

0002c436 <lsm6dso_tap_quiet_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of quiet in reg INT_DUR2
  *
  */
int32_t lsm6dso_tap_quiet_set(stmdev_ctx_t *ctx, uint8_t val)
{
   2c436:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_int_dur2_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   2c438:	2301      	movs	r3, #1
{
   2c43a:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   2c43c:	aa01      	add	r2, sp, #4
   2c43e:	215a      	movs	r1, #90	; 0x5a
{
   2c440:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   2c442:	f7ff f9e1 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c446:	b958      	cbnz	r0, 2c460 <lsm6dso_tap_quiet_set+0x2a>
    reg.quiet = val;
   2c448:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   2c44c:	aa01      	add	r2, sp, #4
    reg.quiet = val;
   2c44e:	f365 0383 	bfi	r3, r5, #2, #2
   2c452:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_INT_DUR2, (uint8_t*)&reg, 1);
   2c456:	215a      	movs	r1, #90	; 0x5a
   2c458:	2301      	movs	r3, #1
   2c45a:	4620      	mov	r0, r4
   2c45c:	f7ff f9db 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2c460:	b003      	add	sp, #12
   2c462:	bd30      	pop	{r4, r5, pc}

0002c464 <lsm6dso_tap_mode_set>:
  * @param  val      change the values of single_double_tap in reg WAKE_UP_THS
  *
  */
int32_t lsm6dso_tap_mode_set(stmdev_ctx_t *ctx,
                             lsm6dso_single_double_tap_t val)
{
   2c464:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_wake_up_ths_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_WAKE_UP_THS, (uint8_t*)&reg, 1);
   2c466:	2301      	movs	r3, #1
{
   2c468:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_WAKE_UP_THS, (uint8_t*)&reg, 1);
   2c46a:	aa01      	add	r2, sp, #4
   2c46c:	215b      	movs	r1, #91	; 0x5b
{
   2c46e:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_WAKE_UP_THS, (uint8_t*)&reg, 1);
   2c470:	f7ff f9ca 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c474:	b958      	cbnz	r0, 2c48e <lsm6dso_tap_mode_set+0x2a>
    reg.single_double_tap = (uint8_t)val;
   2c476:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_WAKE_UP_THS, (uint8_t*)&reg, 1);
   2c47a:	aa01      	add	r2, sp, #4
    reg.single_double_tap = (uint8_t)val;
   2c47c:	f365 13c7 	bfi	r3, r5, #7, #1
   2c480:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_WAKE_UP_THS, (uint8_t*)&reg, 1);
   2c484:	215b      	movs	r1, #91	; 0x5b
   2c486:	2301      	movs	r3, #1
   2c488:	4620      	mov	r0, r4
   2c48a:	f7ff f9c4 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2c48e:	b003      	add	sp, #12
   2c490:	bd30      	pop	{r4, r5, pc}

0002c492 <lsm6dso_fifo_watermark_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of wtm in reg FIFO_CTRL1
  *
  */
int32_t lsm6dso_fifo_watermark_set(stmdev_ctx_t *ctx, uint16_t val)
{
   2c492:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_fifo_ctrl1_t fifo_ctrl1;
  lsm6dso_fifo_ctrl2_t fifo_ctrl2;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
   2c494:	2301      	movs	r3, #1
{
   2c496:	460c      	mov	r4, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
   2c498:	aa01      	add	r2, sp, #4
   2c49a:	2108      	movs	r1, #8
{
   2c49c:	4605      	mov	r5, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
   2c49e:	f7ff f9b3 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c4a2:	b9a8      	cbnz	r0, 2c4d0 <lsm6dso_fifo_watermark_set+0x3e>
    fifo_ctrl1.wtm = 0x00FFU & (uint8_t)val;
    fifo_ctrl2.wtm = (uint8_t)(( 0x0100U & val ) >> 8);
   2c4a4:	f89d 3004 	ldrb.w	r3, [sp, #4]
    fifo_ctrl1.wtm = 0x00FFU & (uint8_t)val;
   2c4a8:	f88d 4000 	strb.w	r4, [sp]
    fifo_ctrl2.wtm = (uint8_t)(( 0x0100U & val ) >> 8);
   2c4ac:	0a24      	lsrs	r4, r4, #8
   2c4ae:	f364 0300 	bfi	r3, r4, #0, #1
   2c4b2:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL1, (uint8_t*)&fifo_ctrl1, 1);
   2c4b6:	466a      	mov	r2, sp
   2c4b8:	2301      	movs	r3, #1
   2c4ba:	2107      	movs	r1, #7
   2c4bc:	4628      	mov	r0, r5
   2c4be:	f7ff f9aa 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2c4c2:	b928      	cbnz	r0, 2c4d0 <lsm6dso_fifo_watermark_set+0x3e>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&fifo_ctrl2, 1);
   2c4c4:	2301      	movs	r3, #1
   2c4c6:	aa01      	add	r2, sp, #4
   2c4c8:	2108      	movs	r1, #8
   2c4ca:	4628      	mov	r0, r5
   2c4cc:	f7ff f9a3 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2c4d0:	b003      	add	sp, #12
   2c4d2:	bd30      	pop	{r4, r5, pc}

0002c4d4 <lsm6dso_fifo_stop_on_wtm_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of stop_on_wtm in reg FIFO_CTRL2
  *
  */
int32_t lsm6dso_fifo_stop_on_wtm_set(stmdev_ctx_t *ctx, uint8_t val)
{
   2c4d4:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_fifo_ctrl2_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&reg, 1);
   2c4d6:	2301      	movs	r3, #1
{
   2c4d8:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&reg, 1);
   2c4da:	aa01      	add	r2, sp, #4
   2c4dc:	2108      	movs	r1, #8
{
   2c4de:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&reg, 1);
   2c4e0:	f7ff f992 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c4e4:	b958      	cbnz	r0, 2c4fe <lsm6dso_fifo_stop_on_wtm_set+0x2a>
    reg.stop_on_wtm = val;
   2c4e6:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&reg, 1);
   2c4ea:	aa01      	add	r2, sp, #4
    reg.stop_on_wtm = val;
   2c4ec:	f365 13c7 	bfi	r3, r5, #7, #1
   2c4f0:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL2, (uint8_t*)&reg, 1);
   2c4f4:	2108      	movs	r1, #8
   2c4f6:	2301      	movs	r3, #1
   2c4f8:	4620      	mov	r0, r4
   2c4fa:	f7ff f98c 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2c4fe:	b003      	add	sp, #12
   2c500:	bd30      	pop	{r4, r5, pc}

0002c502 <lsm6dso_fifo_xl_batch_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of bdr_xl in reg FIFO_CTRL3
  *
  */
int32_t lsm6dso_fifo_xl_batch_set(stmdev_ctx_t *ctx, lsm6dso_bdr_xl_t val)
{
   2c502:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_fifo_ctrl3_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   2c504:	2301      	movs	r3, #1
{
   2c506:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   2c508:	aa01      	add	r2, sp, #4
   2c50a:	2109      	movs	r1, #9
{
   2c50c:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   2c50e:	f7ff f97b 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c512:	b958      	cbnz	r0, 2c52c <lsm6dso_fifo_xl_batch_set+0x2a>
    reg.bdr_xl = (uint8_t)val;
   2c514:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   2c518:	aa01      	add	r2, sp, #4
    reg.bdr_xl = (uint8_t)val;
   2c51a:	f365 0303 	bfi	r3, r5, #0, #4
   2c51e:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   2c522:	2109      	movs	r1, #9
   2c524:	2301      	movs	r3, #1
   2c526:	4620      	mov	r0, r4
   2c528:	f7ff f975 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2c52c:	b003      	add	sp, #12
   2c52e:	bd30      	pop	{r4, r5, pc}

0002c530 <lsm6dso_fifo_gy_batch_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of bdr_gy in reg FIFO_CTRL3
  *
  */
int32_t lsm6dso_fifo_gy_batch_set(stmdev_ctx_t *ctx, lsm6dso_bdr_gy_t val)
{
   2c530:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_fifo_ctrl3_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   2c532:	2301      	movs	r3, #1
{
   2c534:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   2c536:	aa01      	add	r2, sp, #4
   2c538:	2109      	movs	r1, #9
{
   2c53a:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   2c53c:	f7ff f964 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c540:	b958      	cbnz	r0, 2c55a <lsm6dso_fifo_gy_batch_set+0x2a>
    reg.bdr_gy = (uint8_t)val;
   2c542:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   2c546:	aa01      	add	r2, sp, #4
    reg.bdr_gy = (uint8_t)val;
   2c548:	f365 1307 	bfi	r3, r5, #4, #4
   2c54c:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL3, (uint8_t*)&reg, 1);
   2c550:	2109      	movs	r1, #9
   2c552:	2301      	movs	r3, #1
   2c554:	4620      	mov	r0, r4
   2c556:	f7ff f95e 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2c55a:	b003      	add	sp, #12
   2c55c:	bd30      	pop	{r4, r5, pc}

0002c55e <lsm6dso_fifo_mode_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of fifo_mode in reg FIFO_CTRL4
  *
  */
int32_t lsm6dso_fifo_mode_set(stmdev_ctx_t *ctx, lsm6dso_fifo_mode_t val)
{
   2c55e:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_fifo_ctrl4_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL4, (uint8_t*)&reg, 1);
   2c560:	2301      	movs	r3, #1
{
   2c562:	460d      	mov	r5, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL4, (uint8_t*)&reg, 1);
   2c564:	aa01      	add	r2, sp, #4
   2c566:	210a      	movs	r1, #10
{
   2c568:	4604      	mov	r4, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_CTRL4, (uint8_t*)&reg, 1);
   2c56a:	f7ff f94d 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c56e:	b958      	cbnz	r0, 2c588 <lsm6dso_fifo_mode_set+0x2a>
    reg.fifo_mode = (uint8_t)val;
   2c570:	f89d 3004 	ldrb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL4, (uint8_t*)&reg, 1);
   2c574:	aa01      	add	r2, sp, #4
    reg.fifo_mode = (uint8_t)val;
   2c576:	f365 0302 	bfi	r3, r5, #0, #3
   2c57a:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FIFO_CTRL4, (uint8_t*)&reg, 1);
   2c57e:	210a      	movs	r1, #10
   2c580:	2301      	movs	r3, #1
   2c582:	4620      	mov	r0, r4
   2c584:	f7ff f947 	bl	2b816 <lsm6dso_write_reg>
  }
  return ret;
}
   2c588:	b003      	add	sp, #12
   2c58a:	bd30      	pop	{r4, r5, pc}

0002c58c <lsm6dso_fifo_data_level_get>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of diff_fifo in reg FIFO_STATUS1
  *
  */
int32_t lsm6dso_fifo_data_level_get(stmdev_ctx_t *ctx, uint16_t *val)
{
   2c58c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  lsm6dso_fifo_status1_t fifo_status1;
  lsm6dso_fifo_status2_t fifo_status2;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_STATUS1,
   2c58e:	2301      	movs	r3, #1
{
   2c590:	460c      	mov	r4, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_STATUS1,
   2c592:	466a      	mov	r2, sp
   2c594:	213a      	movs	r1, #58	; 0x3a
{
   2c596:	4605      	mov	r5, r0
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_STATUS1,
   2c598:	f7ff f936 	bl	2b808 <lsm6dso_read_reg>
                         (uint8_t*)&fifo_status1, 1);
  if (ret == 0) {
   2c59c:	b970      	cbnz	r0, 2c5bc <lsm6dso_fifo_data_level_get+0x30>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_STATUS2,
   2c59e:	2301      	movs	r3, #1
   2c5a0:	aa01      	add	r2, sp, #4
   2c5a2:	213b      	movs	r1, #59	; 0x3b
   2c5a4:	4628      	mov	r0, r5
   2c5a6:	f7ff f92f 	bl	2b808 <lsm6dso_read_reg>
                           (uint8_t*)&fifo_status2, 1);
    *val = ((uint16_t)fifo_status2.diff_fifo << 8) +
   2c5aa:	f89d 3004 	ldrb.w	r3, [sp, #4]
   2c5ae:	f003 0203 	and.w	r2, r3, #3
            (uint16_t)fifo_status1.diff_fifo;
   2c5b2:	f89d 3000 	ldrb.w	r3, [sp]
    *val = ((uint16_t)fifo_status2.diff_fifo << 8) +
   2c5b6:	eb03 2302 	add.w	r3, r3, r2, lsl #8
   2c5ba:	8023      	strh	r3, [r4, #0]
  }
  return ret;
}
   2c5bc:	b003      	add	sp, #12
   2c5be:	bd30      	pop	{r4, r5, pc}

0002c5c0 <lsm6dso_fifo_wtm_flag_get>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of fifo_wtm_ia in reg FIFO_STATUS2
  *
  */
int32_t lsm6dso_fifo_wtm_flag_get(stmdev_ctx_t *ctx, uint8_t *val)
{
   2c5c0:	b513      	push	{r0, r1, r4, lr}
  lsm6dso_fifo_status2_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_STATUS2, (uint8_t*)&reg, 1);
   2c5c2:	2301      	movs	r3, #1
{
   2c5c4:	460c      	mov	r4, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_STATUS2, (uint8_t*)&reg, 1);
   2c5c6:	aa01      	add	r2, sp, #4
   2c5c8:	213b      	movs	r1, #59	; 0x3b
   2c5ca:	f7ff f91d 	bl	2b808 <lsm6dso_read_reg>
  *val = reg.fifo_wtm_ia;
   2c5ce:	f89d 3004 	ldrb.w	r3, [sp, #4]
   2c5d2:	f3c3 13c0 	ubfx	r3, r3, #7, #1
   2c5d6:	7023      	strb	r3, [r4, #0]

  return ret;
}
   2c5d8:	b002      	add	sp, #8
   2c5da:	bd10      	pop	{r4, pc}

0002c5dc <lsm6dso_fifo_sensor_tag_get>:
  * @param  val      change the values of tag_sensor in reg FIFO_DATA_OUT_TAG
  *
  */
int32_t lsm6dso_fifo_sensor_tag_get(stmdev_ctx_t *ctx,
                                    lsm6dso_fifo_tag_t *val)
{
   2c5dc:	b513      	push	{r0, r1, r4, lr}
  lsm6dso_fifo_data_out_tag_t reg;
  int32_t ret;

  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_DATA_OUT_TAG, (uint8_t*)&reg, 1);
   2c5de:	2301      	movs	r3, #1
{
   2c5e0:	460c      	mov	r4, r1
  ret = lsm6dso_read_reg(ctx, LSM6DSO_FIFO_DATA_OUT_TAG, (uint8_t*)&reg, 1);
   2c5e2:	aa01      	add	r2, sp, #4
   2c5e4:	2178      	movs	r1, #120	; 0x78
   2c5e6:	f7ff f90f 	bl	2b808 <lsm6dso_read_reg>
  switch (reg.tag_sensor) {
   2c5ea:	f89d 3004 	ldrb.w	r3, [sp, #4]
   2c5ee:	08db      	lsrs	r3, r3, #3
   2c5f0:	3b01      	subs	r3, #1
   2c5f2:	2b18      	cmp	r3, #24
   2c5f4:	d838      	bhi.n	2c668 <lsm6dso_fifo_sensor_tag_get+0x8c>
   2c5f6:	e8df f003 	tbb	[pc, r3]
   2c5fa:	0d37      	.short	0x0d37
   2c5fc:	15133711 	.word	0x15133711
   2c600:	1d1b1917 	.word	0x1d1b1917
   2c604:	2523211f 	.word	0x2523211f
   2c608:	2d2b2927 	.word	0x2d2b2927
   2c60c:	3733312f 	.word	0x3733312f
   2c610:	3737      	.short	0x3737
   2c612:	35          	.byte	0x35
   2c613:	00          	.byte	0x00
    case LSM6DSO_GYRO_NC_TAG:
      *val = LSM6DSO_GYRO_NC_TAG;
      break;
    case LSM6DSO_XL_NC_TAG:
      *val = LSM6DSO_XL_NC_TAG;
   2c614:	2302      	movs	r3, #2
      break;
    case LSM6DSO_SENSORHUB_NACK_TAG:
      *val = LSM6DSO_SENSORHUB_NACK_TAG;
      break;
    default:
      *val = LSM6DSO_GYRO_NC_TAG;
   2c616:	7023      	strb	r3, [r4, #0]
      break;
  }
  return ret;
}
   2c618:	b002      	add	sp, #8
   2c61a:	bd10      	pop	{r4, pc}
      *val = LSM6DSO_TEMPERATURE_TAG;
   2c61c:	2303      	movs	r3, #3
   2c61e:	e7fa      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_CFG_CHANGE_TAG;
   2c620:	2305      	movs	r3, #5
   2c622:	e7f8      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_XL_NC_T_2_TAG;
   2c624:	2306      	movs	r3, #6
   2c626:	e7f6      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_XL_NC_T_1_TAG;
   2c628:	2307      	movs	r3, #7
   2c62a:	e7f4      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_XL_2XC_TAG;
   2c62c:	2308      	movs	r3, #8
   2c62e:	e7f2      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_XL_3XC_TAG;
   2c630:	2309      	movs	r3, #9
   2c632:	e7f0      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_GYRO_NC_T_2_TAG;
   2c634:	230a      	movs	r3, #10
   2c636:	e7ee      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_GYRO_NC_T_1_TAG;
   2c638:	230b      	movs	r3, #11
   2c63a:	e7ec      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_GYRO_2XC_TAG;
   2c63c:	230c      	movs	r3, #12
   2c63e:	e7ea      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_GYRO_3XC_TAG;
   2c640:	230d      	movs	r3, #13
   2c642:	e7e8      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_SENSORHUB_SLAVE0_TAG;
   2c644:	230e      	movs	r3, #14
   2c646:	e7e6      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_SENSORHUB_SLAVE1_TAG;
   2c648:	230f      	movs	r3, #15
   2c64a:	e7e4      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_SENSORHUB_SLAVE2_TAG;
   2c64c:	2310      	movs	r3, #16
   2c64e:	e7e2      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_SENSORHUB_SLAVE3_TAG;
   2c650:	2311      	movs	r3, #17
   2c652:	e7e0      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_STEP_CPUNTER_TAG;
   2c654:	2312      	movs	r3, #18
   2c656:	e7de      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_GAME_ROTATION_TAG;
   2c658:	2313      	movs	r3, #19
   2c65a:	e7dc      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_GEOMAG_ROTATION_TAG;
   2c65c:	2314      	movs	r3, #20
   2c65e:	e7da      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_ROTATION_TAG;
   2c660:	2315      	movs	r3, #21
   2c662:	e7d8      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_SENSORHUB_NACK_TAG;
   2c664:	2319      	movs	r3, #25
   2c666:	e7d6      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>
      *val = LSM6DSO_GYRO_NC_TAG;
   2c668:	2301      	movs	r3, #1
   2c66a:	e7d4      	b.n	2c616 <lsm6dso_fifo_sensor_tag_get+0x3a>

0002c66c <lsm6dso_pedo_sens_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      turn on and configure pedometer
  *
  */
int32_t lsm6dso_pedo_sens_set(stmdev_ctx_t *ctx, lsm6dso_pedo_md_t val)
{
   2c66c:	b530      	push	{r4, r5, lr}
   2c66e:	b085      	sub	sp, #20
   2c670:	460d      	mov	r5, r1
  lsm6dso_emb_func_en_a_t emb_func_en_a;
  lsm6dso_emb_func_en_b_t emb_func_en_b;
  lsm6dso_pedo_cmd_reg_t pedo_cmd_reg;
  int32_t ret;

  ret = lsm6dso_ln_pg_read_byte(ctx, LSM6DSO_PEDO_CMD_REG,
   2c672:	aa03      	add	r2, sp, #12
   2c674:	f240 1183 	movw	r1, #387	; 0x183
{
   2c678:	4604      	mov	r4, r0
  ret = lsm6dso_ln_pg_read_byte(ctx, LSM6DSO_PEDO_CMD_REG,
   2c67a:	f7ff fafc 	bl	2bc76 <lsm6dso_ln_pg_read_byte>
                                (uint8_t*)&pedo_cmd_reg);
  if (ret == 0) {
   2c67e:	2800      	cmp	r0, #0
   2c680:	d143      	bne.n	2c70a <_flash_used+0x4a>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2c682:	2102      	movs	r1, #2
   2c684:	4620      	mov	r0, r4
   2c686:	f7ff f96d 	bl	2b964 <lsm6dso_mem_bank_set>
  }
  if (ret == 0) {
   2c68a:	2800      	cmp	r0, #0
   2c68c:	d13d      	bne.n	2c70a <_flash_used+0x4a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_EN_A,
   2c68e:	2301      	movs	r3, #1
   2c690:	aa01      	add	r2, sp, #4
   2c692:	2104      	movs	r1, #4
   2c694:	4620      	mov	r0, r4
   2c696:	f7ff f8b7 	bl	2b808 <lsm6dso_read_reg>
                           (uint8_t*)&emb_func_en_a, 1);
  }
  if (ret == 0) {
   2c69a:	bbb0      	cbnz	r0, 2c70a <_flash_used+0x4a>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_EN_B,
   2c69c:	2301      	movs	r3, #1
   2c69e:	aa02      	add	r2, sp, #8
   2c6a0:	2105      	movs	r1, #5
   2c6a2:	4620      	mov	r0, r4
   2c6a4:	f7ff f8b0 	bl	2b808 <lsm6dso_read_reg>
                           (uint8_t*)&emb_func_en_b, 1);

    emb_func_en_a.pedo_en = (uint8_t)val & 0x01U;
   2c6a8:	f89d 3004 	ldrb.w	r3, [sp, #4]
    emb_func_en_b.pedo_adv_en = ((uint8_t)val & 0x02U)>>1;
   2c6ac:	086a      	lsrs	r2, r5, #1
    emb_func_en_a.pedo_en = (uint8_t)val & 0x01U;
   2c6ae:	f365 03c3 	bfi	r3, r5, #3, #1
   2c6b2:	f88d 3004 	strb.w	r3, [sp, #4]
    emb_func_en_b.pedo_adv_en = ((uint8_t)val & 0x02U)>>1;
   2c6b6:	f89d 3008 	ldrb.w	r3, [sp, #8]
   2c6ba:	f362 1304 	bfi	r3, r2, #4, #1
   2c6be:	f88d 3008 	strb.w	r3, [sp, #8]
    pedo_cmd_reg.fp_rejection_en = ((uint8_t)val & 0x10U)>>4;
   2c6c2:	f89d 300c 	ldrb.w	r3, [sp, #12]
   2c6c6:	092a      	lsrs	r2, r5, #4
   2c6c8:	f362 0382 	bfi	r3, r2, #2, #1
    pedo_cmd_reg.ad_det_en = ((uint8_t)val & 0x20U)>>5;
   2c6cc:	096d      	lsrs	r5, r5, #5
   2c6ce:	f365 0300 	bfi	r3, r5, #0, #1
   2c6d2:	f88d 300c 	strb.w	r3, [sp, #12]
  }
  if (ret == 0) {
   2c6d6:	b9c0      	cbnz	r0, 2c70a <_flash_used+0x4a>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_EN_A,
   2c6d8:	2301      	movs	r3, #1
   2c6da:	aa01      	add	r2, sp, #4
   2c6dc:	2104      	movs	r1, #4
   2c6de:	4620      	mov	r0, r4
   2c6e0:	f7ff f899 	bl	2b816 <lsm6dso_write_reg>
                            (uint8_t*)&emb_func_en_a, 1);
  }
  if (ret == 0) {
   2c6e4:	b988      	cbnz	r0, 2c70a <_flash_used+0x4a>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_EN_B,
   2c6e6:	2301      	movs	r3, #1
   2c6e8:	aa02      	add	r2, sp, #8
   2c6ea:	2105      	movs	r1, #5
   2c6ec:	4620      	mov	r0, r4
   2c6ee:	f7ff f892 	bl	2b816 <lsm6dso_write_reg>
                            (uint8_t*)&emb_func_en_b, 1);
  }
  if (ret == 0) {
   2c6f2:	b950      	cbnz	r0, 2c70a <_flash_used+0x4a>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2c6f4:	4601      	mov	r1, r0
   2c6f6:	4620      	mov	r0, r4
   2c6f8:	f7ff f934 	bl	2b964 <lsm6dso_mem_bank_set>
  }
  if (ret == 0) {
   2c6fc:	b928      	cbnz	r0, 2c70a <_flash_used+0x4a>
    ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_PEDO_CMD_REG,
   2c6fe:	aa03      	add	r2, sp, #12
   2c700:	f240 1183 	movw	r1, #387	; 0x183
   2c704:	4620      	mov	r0, r4
   2c706:	f7ff f9bf 	bl	2ba88 <lsm6dso_ln_pg_write_byte>
                                   (uint8_t*)&pedo_cmd_reg);
  }
  return ret;
}
   2c70a:	b005      	add	sp, #20
   2c70c:	bd30      	pop	{r4, r5, pc}

0002c70e <lsm6dso_pedo_debounce_steps_set>:
  *
  */
int32_t lsm6dso_pedo_debounce_steps_set(stmdev_ctx_t *ctx, uint8_t *buff)
{
  int32_t ret;
  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_PEDO_DEB_STEPS_CONF, buff);
   2c70e:	460a      	mov	r2, r1
   2c710:	f44f 71c2 	mov.w	r1, #388	; 0x184
   2c714:	f7ff b9b8 	b.w	2ba88 <lsm6dso_ln_pg_write_byte>

0002c718 <lsm6dso_pedo_steps_period_set>:
  * @param  ctx      read / write interface definitions
  * @param  buff     buffer that contains data to write
  *
  */
int32_t lsm6dso_pedo_steps_period_set(stmdev_ctx_t *ctx, uint8_t *buff)
{
   2c718:	b538      	push	{r3, r4, r5, lr}
  int32_t ret;
  uint8_t index;

  index = 0x00U;
  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_PEDO_SC_DELTAT_L, &buff[index]);
   2c71a:	460a      	mov	r2, r1
{
   2c71c:	460c      	mov	r4, r1
  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_PEDO_SC_DELTAT_L, &buff[index]);
   2c71e:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
{
   2c722:	4605      	mov	r5, r0
  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_PEDO_SC_DELTAT_L, &buff[index]);
   2c724:	f7ff f9b0 	bl	2ba88 <lsm6dso_ln_pg_write_byte>
  if (ret == 0) {
   2c728:	b938      	cbnz	r0, 2c73a <lsm6dso_pedo_steps_period_set+0x22>
    index++;
    ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_PEDO_SC_DELTAT_H,
   2c72a:	1c62      	adds	r2, r4, #1
   2c72c:	4628      	mov	r0, r5
                                   &buff[index]);
  }
  return ret;
}
   2c72e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_PEDO_SC_DELTAT_H,
   2c732:	f240 11d1 	movw	r1, #465	; 0x1d1
   2c736:	f7ff b9a7 	b.w	2ba88 <lsm6dso_ln_pg_write_byte>
}
   2c73a:	bd38      	pop	{r3, r4, r5, pc}

0002c73c <lsm6dso_fsm_enable_set>:
  * @param  val      union of registers from FSM_ENABLE_A to FSM_ENABLE_B
  *
  */
int32_t lsm6dso_fsm_enable_set(stmdev_ctx_t *ctx,
                               lsm6dso_emb_fsm_enable_t *val)
{
   2c73c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2c73e:	460d      	mov	r5, r1
  int32_t ret;
  lsm6dso_emb_func_en_b_t reg;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2c740:	2102      	movs	r1, #2
{
   2c742:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2c744:	f7ff f90e 	bl	2b964 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   2c748:	2800      	cmp	r0, #0
   2c74a:	d157      	bne.n	2c7fc <lsm6dso_fsm_enable_set+0xc0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FSM_ENABLE_A,
   2c74c:	2301      	movs	r3, #1
   2c74e:	462a      	mov	r2, r5
   2c750:	2146      	movs	r1, #70	; 0x46
   2c752:	4620      	mov	r0, r4
   2c754:	f7ff f85f 	bl	2b816 <lsm6dso_write_reg>
                            (uint8_t*)&val->fsm_enable_a, 1);
  }
  if (ret == 0) {
   2c758:	2800      	cmp	r0, #0
   2c75a:	d14f      	bne.n	2c7fc <lsm6dso_fsm_enable_set+0xc0>
    ret = lsm6dso_write_reg(ctx, LSM6DSO_FSM_ENABLE_B,
   2c75c:	2301      	movs	r3, #1
   2c75e:	2147      	movs	r1, #71	; 0x47
   2c760:	18ea      	adds	r2, r5, r3
   2c762:	4620      	mov	r0, r4
   2c764:	f7ff f857 	bl	2b816 <lsm6dso_write_reg>
                            (uint8_t*)&val->fsm_enable_b, 1);
  }
  if (ret == 0) {
   2c768:	2800      	cmp	r0, #0
   2c76a:	d147      	bne.n	2c7fc <lsm6dso_fsm_enable_set+0xc0>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_EN_B, (uint8_t*)&reg, 1);
   2c76c:	2301      	movs	r3, #1
   2c76e:	aa01      	add	r2, sp, #4
   2c770:	2105      	movs	r1, #5
   2c772:	4620      	mov	r0, r4
   2c774:	f7ff f848 	bl	2b808 <lsm6dso_read_reg>
  }
  if (ret == 0) {
   2c778:	2800      	cmp	r0, #0
   2c77a:	d13f      	bne.n	2c7fc <lsm6dso_fsm_enable_set+0xc0>
    if ( (val->fsm_enable_a.fsm1_en   |
   2c77c:	782a      	ldrb	r2, [r5, #0]
    else
    {
      reg.fsm_en = PROPERTY_DISABLE;
    }

    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_EN_B, (uint8_t*)&reg, 1);
   2c77e:	4620      	mov	r0, r4
          val->fsm_enable_a.fsm2_en   |
   2c780:	f3c2 0140 	ubfx	r1, r2, #1, #1
    if ( (val->fsm_enable_a.fsm1_en   |
   2c784:	f3c2 0300 	ubfx	r3, r2, #0, #1
   2c788:	430b      	orrs	r3, r1
          val->fsm_enable_a.fsm3_en   |
   2c78a:	f3c2 0180 	ubfx	r1, r2, #2, #1
          val->fsm_enable_a.fsm2_en   |
   2c78e:	430b      	orrs	r3, r1
          val->fsm_enable_a.fsm4_en   |
   2c790:	f3c2 01c0 	ubfx	r1, r2, #3, #1
          val->fsm_enable_a.fsm3_en   |
   2c794:	430b      	orrs	r3, r1
          val->fsm_enable_a.fsm5_en   |
   2c796:	f3c2 1100 	ubfx	r1, r2, #4, #1
          val->fsm_enable_a.fsm4_en   |
   2c79a:	430b      	orrs	r3, r1
          val->fsm_enable_a.fsm6_en   |
   2c79c:	f3c2 1140 	ubfx	r1, r2, #5, #1
          val->fsm_enable_a.fsm5_en   |
   2c7a0:	430b      	orrs	r3, r1
          val->fsm_enable_a.fsm7_en   |
   2c7a2:	f3c2 1180 	ubfx	r1, r2, #6, #1
          val->fsm_enable_a.fsm6_en   |
   2c7a6:	430b      	orrs	r3, r1
          val->fsm_enable_a.fsm7_en   |
   2c7a8:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
          val->fsm_enable_b.fsm9_en   |
   2c7ac:	786a      	ldrb	r2, [r5, #1]
   2c7ae:	f3c2 0100 	ubfx	r1, r2, #0, #1
          val->fsm_enable_a.fsm8_en   |
   2c7b2:	430b      	orrs	r3, r1
          val->fsm_enable_b.fsm10_en  |
   2c7b4:	f3c2 0140 	ubfx	r1, r2, #1, #1
          val->fsm_enable_b.fsm9_en   |
   2c7b8:	430b      	orrs	r3, r1
          val->fsm_enable_b.fsm11_en  |
   2c7ba:	f3c2 0180 	ubfx	r1, r2, #2, #1
          val->fsm_enable_b.fsm10_en  |
   2c7be:	430b      	orrs	r3, r1
          val->fsm_enable_b.fsm12_en  |
   2c7c0:	f3c2 01c0 	ubfx	r1, r2, #3, #1
          val->fsm_enable_b.fsm11_en  |
   2c7c4:	430b      	orrs	r3, r1
          val->fsm_enable_b.fsm13_en  |
   2c7c6:	f3c2 1100 	ubfx	r1, r2, #4, #1
          val->fsm_enable_b.fsm12_en  |
   2c7ca:	430b      	orrs	r3, r1
          val->fsm_enable_b.fsm14_en  |
   2c7cc:	f3c2 1140 	ubfx	r1, r2, #5, #1
          val->fsm_enable_b.fsm13_en  |
   2c7d0:	430b      	orrs	r3, r1
          val->fsm_enable_b.fsm15_en  |
   2c7d2:	f3c2 1180 	ubfx	r1, r2, #6, #1
          val->fsm_enable_b.fsm14_en  |
   2c7d6:	430b      	orrs	r3, r1
          val->fsm_enable_b.fsm15_en  |
   2c7d8:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
   2c7dc:	f89d 2004 	ldrb.w	r2, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_EN_B, (uint8_t*)&reg, 1);
   2c7e0:	2105      	movs	r1, #5
   2c7e2:	f363 0200 	bfi	r2, r3, #0, #1
   2c7e6:	f88d 2004 	strb.w	r2, [sp, #4]
   2c7ea:	2301      	movs	r3, #1
   2c7ec:	aa01      	add	r2, sp, #4
   2c7ee:	f7ff f812 	bl	2b816 <lsm6dso_write_reg>
  }
  if (ret == 0) {
   2c7f2:	b918      	cbnz	r0, 2c7fc <lsm6dso_fsm_enable_set+0xc0>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2c7f4:	4601      	mov	r1, r0
   2c7f6:	4620      	mov	r0, r4
   2c7f8:	f7ff f8b4 	bl	2b964 <lsm6dso_mem_bank_set>
  }

  return ret;
}
   2c7fc:	b003      	add	sp, #12
   2c7fe:	bd30      	pop	{r4, r5, pc}

0002c800 <lsm6dso_fsm_enable_get>:
  * @param  val      union of registers from FSM_ENABLE_A to FSM_ENABLE_B
  *
  */
int32_t lsm6dso_fsm_enable_get(stmdev_ctx_t *ctx,
                               lsm6dso_emb_fsm_enable_t *val)
{
   2c800:	b538      	push	{r3, r4, r5, lr}
   2c802:	460d      	mov	r5, r1
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2c804:	2102      	movs	r1, #2
{
   2c806:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2c808:	f7ff f8ac 	bl	2b964 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   2c80c:	b960      	cbnz	r0, 2c828 <lsm6dso_fsm_enable_get+0x28>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_FSM_ENABLE_A, (uint8_t*) val, 2);
   2c80e:	2302      	movs	r3, #2
   2c810:	462a      	mov	r2, r5
   2c812:	2146      	movs	r1, #70	; 0x46
   2c814:	4620      	mov	r0, r4
   2c816:	f7fe fff7 	bl	2b808 <lsm6dso_read_reg>
  }
  if (ret == 0) {
   2c81a:	b928      	cbnz	r0, 2c828 <lsm6dso_fsm_enable_get+0x28>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2c81c:	4601      	mov	r1, r0
   2c81e:	4620      	mov	r0, r4
  }
  return ret;
}
   2c820:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2c824:	f7ff b89e 	b.w	2b964 <lsm6dso_mem_bank_set>
}
   2c828:	bd38      	pop	{r3, r4, r5, pc}

0002c82a <lsm6dso_fsm_data_rate_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      change the values of fsm_odr in reg EMB_FUNC_ODR_CFG_B
  *
  */
int32_t lsm6dso_fsm_data_rate_set(stmdev_ctx_t *ctx, lsm6dso_fsm_odr_t val)
{
   2c82a:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2c82c:	460d      	mov	r5, r1
  lsm6dso_emb_func_odr_cfg_b_t reg;
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2c82e:	2102      	movs	r1, #2
{
   2c830:	4604      	mov	r4, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2c832:	f7ff f897 	bl	2b964 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   2c836:	b9d8      	cbnz	r0, 2c870 <lsm6dso_fsm_data_rate_set+0x46>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_ODR_CFG_B,
   2c838:	2301      	movs	r3, #1
   2c83a:	aa01      	add	r2, sp, #4
   2c83c:	215f      	movs	r1, #95	; 0x5f
   2c83e:	4620      	mov	r0, r4
   2c840:	f7fe ffe2 	bl	2b808 <lsm6dso_read_reg>
                           (uint8_t*)&reg, 1);
  }
  if (ret == 0) {
   2c844:	b9a0      	cbnz	r0, 2c870 <lsm6dso_fsm_data_rate_set+0x46>
    reg.not_used_01 = 3; /* set default values */
   2c846:	f89d 3004 	ldrb.w	r3, [sp, #4]
    reg.not_used_02 = 2; /* set default values */
    reg.fsm_odr = (uint8_t)val;
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_ODR_CFG_B,
   2c84a:	aa01      	add	r2, sp, #4
    reg.not_used_01 = 3; /* set default values */
   2c84c:	f003 0318 	and.w	r3, r3, #24
    reg.fsm_odr = (uint8_t)val;
   2c850:	f043 0343 	orr.w	r3, r3, #67	; 0x43
   2c854:	f365 03c4 	bfi	r3, r5, #3, #2
   2c858:	f88d 3004 	strb.w	r3, [sp, #4]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_EMB_FUNC_ODR_CFG_B,
   2c85c:	215f      	movs	r1, #95	; 0x5f
   2c85e:	2301      	movs	r3, #1
   2c860:	4620      	mov	r0, r4
   2c862:	f7fe ffd8 	bl	2b816 <lsm6dso_write_reg>
                            (uint8_t*)&reg, 1);
  }
  if (ret == 0) {
   2c866:	b918      	cbnz	r0, 2c870 <lsm6dso_fsm_data_rate_set+0x46>
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2c868:	4601      	mov	r1, r0
   2c86a:	4620      	mov	r0, r4
   2c86c:	f7ff f87a 	bl	2b964 <lsm6dso_mem_bank_set>
  }
  return ret;
}
   2c870:	b003      	add	sp, #12
   2c872:	bd30      	pop	{r4, r5, pc}

0002c874 <lsm6dso_fsm_data_rate_get>:
  * @param  ctx      read / write interface definitions
  * @param  val      Get the values of fsm_odr in reg EMB_FUNC_ODR_CFG_B
  *
  */
int32_t lsm6dso_fsm_data_rate_get(stmdev_ctx_t *ctx, lsm6dso_fsm_odr_t *val)
{
   2c874:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2c876:	460c      	mov	r4, r1
  lsm6dso_emb_func_odr_cfg_b_t reg;
  int32_t ret;

  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2c878:	2102      	movs	r1, #2
{
   2c87a:	4605      	mov	r5, r0
  ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_EMBEDDED_FUNC_BANK);
   2c87c:	f7ff f872 	bl	2b964 <lsm6dso_mem_bank_set>
  if (ret == 0) {
   2c880:	b9b8      	cbnz	r0, 2c8b2 <lsm6dso_fsm_data_rate_get+0x3e>
    ret = lsm6dso_read_reg(ctx, LSM6DSO_EMB_FUNC_ODR_CFG_B,
   2c882:	2301      	movs	r3, #1
   2c884:	aa01      	add	r2, sp, #4
   2c886:	215f      	movs	r1, #95	; 0x5f
   2c888:	4628      	mov	r0, r5
   2c88a:	f7fe ffbd 	bl	2b808 <lsm6dso_read_reg>
                           (uint8_t*)&reg, 1);
  }
  if (ret == 0) {
   2c88e:	b980      	cbnz	r0, 2c8b2 <lsm6dso_fsm_data_rate_get+0x3e>
    switch (reg.fsm_odr) {
   2c890:	f89d 3004 	ldrb.w	r3, [sp, #4]
   2c894:	f3c3 03c1 	ubfx	r3, r3, #3, #2
   2c898:	3b01      	subs	r3, #1
   2c89a:	2b02      	cmp	r3, #2
   2c89c:	d803      	bhi.n	2c8a6 <lsm6dso_fsm_data_rate_get+0x32>
   2c89e:	e8df f003 	tbb	[pc, r3]
   2c8a2:	0c0a      	.short	0x0c0a
   2c8a4:	0e          	.byte	0x0e
   2c8a5:	00          	.byte	0x00
      case LSM6DSO_ODR_FSM_12Hz5:
        *val = LSM6DSO_ODR_FSM_12Hz5;
   2c8a6:	2300      	movs	r3, #0
        break;
      case LSM6DSO_ODR_FSM_52Hz:
        *val = LSM6DSO_ODR_FSM_52Hz;
        break;
      case LSM6DSO_ODR_FSM_104Hz:
        *val = LSM6DSO_ODR_FSM_104Hz;
   2c8a8:	7023      	strb	r3, [r4, #0]
        break;
      default:
        *val = LSM6DSO_ODR_FSM_12Hz5;
        break;
    }
    ret = lsm6dso_mem_bank_set(ctx, LSM6DSO_USER_BANK);
   2c8aa:	2100      	movs	r1, #0
   2c8ac:	4628      	mov	r0, r5
   2c8ae:	f7ff f859 	bl	2b964 <lsm6dso_mem_bank_set>
  }

  return ret;
}
   2c8b2:	b003      	add	sp, #12
   2c8b4:	bd30      	pop	{r4, r5, pc}
        *val = LSM6DSO_ODR_FSM_26Hz;
   2c8b6:	2301      	movs	r3, #1
   2c8b8:	e7f6      	b.n	2c8a8 <lsm6dso_fsm_data_rate_get+0x34>
        *val = LSM6DSO_ODR_FSM_52Hz;
   2c8ba:	2302      	movs	r3, #2
   2c8bc:	e7f4      	b.n	2c8a8 <lsm6dso_fsm_data_rate_get+0x34>
        *val = LSM6DSO_ODR_FSM_104Hz;
   2c8be:	2303      	movs	r3, #3
   2c8c0:	e7f2      	b.n	2c8a8 <lsm6dso_fsm_data_rate_get+0x34>

0002c8c2 <lsm6dso_xl_data_rate_set>:
{
   2c8c2:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2c8c4:	460c      	mov	r4, r1
  ret =  lsm6dso_fsm_enable_get(ctx, &fsm_enable);
   2c8c6:	a901      	add	r1, sp, #4
{
   2c8c8:	4605      	mov	r5, r0
  ret =  lsm6dso_fsm_enable_get(ctx, &fsm_enable);
   2c8ca:	f7ff ff99 	bl	2c800 <lsm6dso_fsm_enable_get>
  if (ret == 0) {
   2c8ce:	2800      	cmp	r0, #0
   2c8d0:	d156      	bne.n	2c980 <lsm6dso_xl_data_rate_set+0xbe>
    if ( (fsm_enable.fsm_enable_a.fsm1_en  |
   2c8d2:	f89d 2004 	ldrb.w	r2, [sp, #4]
          fsm_enable.fsm_enable_a.fsm2_en  |
   2c8d6:	f3c2 0140 	ubfx	r1, r2, #1, #1
    if ( (fsm_enable.fsm_enable_a.fsm1_en  |
   2c8da:	f3c2 0300 	ubfx	r3, r2, #0, #1
   2c8de:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm3_en  |
   2c8e0:	f3c2 0180 	ubfx	r1, r2, #2, #1
          fsm_enable.fsm_enable_a.fsm2_en  |
   2c8e4:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm4_en  |
   2c8e6:	f3c2 01c0 	ubfx	r1, r2, #3, #1
          fsm_enable.fsm_enable_a.fsm3_en  |
   2c8ea:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm5_en  |
   2c8ec:	f3c2 1100 	ubfx	r1, r2, #4, #1
          fsm_enable.fsm_enable_a.fsm4_en  |
   2c8f0:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm6_en  |
   2c8f2:	f3c2 1140 	ubfx	r1, r2, #5, #1
          fsm_enable.fsm_enable_a.fsm5_en  |
   2c8f6:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm7_en  |
   2c8f8:	f3c2 1180 	ubfx	r1, r2, #6, #1
          fsm_enable.fsm_enable_a.fsm6_en  |
   2c8fc:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm7_en  |
   2c8fe:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
          fsm_enable.fsm_enable_b.fsm9_en  |
   2c902:	f89d 2005 	ldrb.w	r2, [sp, #5]
   2c906:	f3c2 0100 	ubfx	r1, r2, #0, #1
          fsm_enable.fsm_enable_a.fsm8_en  |
   2c90a:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm10_en |
   2c90c:	f3c2 0140 	ubfx	r1, r2, #1, #1
          fsm_enable.fsm_enable_b.fsm9_en  |
   2c910:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm11_en |
   2c912:	f3c2 0180 	ubfx	r1, r2, #2, #1
          fsm_enable.fsm_enable_b.fsm10_en |
   2c916:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm12_en |
   2c918:	f3c2 01c0 	ubfx	r1, r2, #3, #1
          fsm_enable.fsm_enable_b.fsm11_en |
   2c91c:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm13_en |
   2c91e:	f3c2 1100 	ubfx	r1, r2, #4, #1
          fsm_enable.fsm_enable_b.fsm12_en |
   2c922:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm14_en |
   2c924:	f3c2 1140 	ubfx	r1, r2, #5, #1
          fsm_enable.fsm_enable_b.fsm13_en |
   2c928:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm15_en |
   2c92a:	f3c2 1180 	ubfx	r1, r2, #6, #1
          fsm_enable.fsm_enable_b.fsm14_en |
   2c92e:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm15_en |
   2c930:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
    if ( (fsm_enable.fsm_enable_a.fsm1_en  |
   2c934:	07db      	lsls	r3, r3, #31
   2c936:	d510      	bpl.n	2c95a <lsm6dso_xl_data_rate_set+0x98>
      ret =  lsm6dso_fsm_data_rate_get(ctx, &fsm_odr);
   2c938:	f10d 0103 	add.w	r1, sp, #3
   2c93c:	4628      	mov	r0, r5
   2c93e:	f7ff ff99 	bl	2c874 <lsm6dso_fsm_data_rate_get>
      if (ret == 0) {
   2c942:	b9e8      	cbnz	r0, 2c980 <lsm6dso_xl_data_rate_set+0xbe>
        switch (fsm_odr) {
   2c944:	f89d 3003 	ldrb.w	r3, [sp, #3]
   2c948:	2b03      	cmp	r3, #3
   2c94a:	d806      	bhi.n	2c95a <lsm6dso_xl_data_rate_set+0x98>
   2c94c:	e8df f003 	tbb	[pc, r3]
   2c950:	221e1a02 	.word	0x221e1a02
            if (val == LSM6DSO_XL_ODR_OFF){
   2c954:	2c00      	cmp	r4, #0
              odr_xl = LSM6DSO_XL_ODR_12Hz5;
   2c956:	bf08      	it	eq
   2c958:	2401      	moveq	r4, #1
    ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   2c95a:	2301      	movs	r3, #1
   2c95c:	466a      	mov	r2, sp
   2c95e:	2110      	movs	r1, #16
   2c960:	4628      	mov	r0, r5
   2c962:	f7fe ff51 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2c966:	b958      	cbnz	r0, 2c980 <lsm6dso_xl_data_rate_set+0xbe>
    reg.odr_xl = (uint8_t) odr_xl;
   2c968:	f89d 3000 	ldrb.w	r3, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   2c96c:	466a      	mov	r2, sp
    reg.odr_xl = (uint8_t) odr_xl;
   2c96e:	f364 1307 	bfi	r3, r4, #4, #4
   2c972:	f88d 3000 	strb.w	r3, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL1_XL, (uint8_t*)&reg, 1);
   2c976:	2110      	movs	r1, #16
   2c978:	2301      	movs	r3, #1
   2c97a:	4628      	mov	r0, r5
   2c97c:	f7fe ff4b 	bl	2b816 <lsm6dso_write_reg>
}
   2c980:	b003      	add	sp, #12
   2c982:	bd30      	pop	{r4, r5, pc}
            if (val == LSM6DSO_XL_ODR_OFF){
   2c984:	2c02      	cmp	r4, #2
   2c986:	bf38      	it	cc
   2c988:	2402      	movcc	r4, #2
   2c98a:	e7e6      	b.n	2c95a <lsm6dso_xl_data_rate_set+0x98>
            if (val == LSM6DSO_XL_ODR_OFF){
   2c98c:	2c03      	cmp	r4, #3
   2c98e:	bf38      	it	cc
   2c990:	2403      	movcc	r4, #3
   2c992:	e7e2      	b.n	2c95a <lsm6dso_xl_data_rate_set+0x98>
            if (val == LSM6DSO_XL_ODR_OFF){
   2c994:	2c04      	cmp	r4, #4
   2c996:	bf38      	it	cc
   2c998:	2404      	movcc	r4, #4
   2c99a:	e7de      	b.n	2c95a <lsm6dso_xl_data_rate_set+0x98>

0002c99c <lsm6dso_gy_data_rate_set>:
{
   2c99c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2c99e:	460c      	mov	r4, r1
  ret =  lsm6dso_fsm_enable_get(ctx, &fsm_enable);
   2c9a0:	a901      	add	r1, sp, #4
{
   2c9a2:	4605      	mov	r5, r0
  ret =  lsm6dso_fsm_enable_get(ctx, &fsm_enable);
   2c9a4:	f7ff ff2c 	bl	2c800 <lsm6dso_fsm_enable_get>
  if (ret == 0) {
   2c9a8:	2800      	cmp	r0, #0
   2c9aa:	d156      	bne.n	2ca5a <lsm6dso_gy_data_rate_set+0xbe>
    if ( (fsm_enable.fsm_enable_a.fsm1_en  |
   2c9ac:	f89d 2004 	ldrb.w	r2, [sp, #4]
          fsm_enable.fsm_enable_a.fsm2_en  |
   2c9b0:	f3c2 0140 	ubfx	r1, r2, #1, #1
    if ( (fsm_enable.fsm_enable_a.fsm1_en  |
   2c9b4:	f3c2 0300 	ubfx	r3, r2, #0, #1
   2c9b8:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm3_en  |
   2c9ba:	f3c2 0180 	ubfx	r1, r2, #2, #1
          fsm_enable.fsm_enable_a.fsm2_en  |
   2c9be:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm4_en  |
   2c9c0:	f3c2 01c0 	ubfx	r1, r2, #3, #1
          fsm_enable.fsm_enable_a.fsm3_en  |
   2c9c4:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm5_en  |
   2c9c6:	f3c2 1100 	ubfx	r1, r2, #4, #1
          fsm_enable.fsm_enable_a.fsm4_en  |
   2c9ca:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm6_en  |
   2c9cc:	f3c2 1140 	ubfx	r1, r2, #5, #1
          fsm_enable.fsm_enable_a.fsm5_en  |
   2c9d0:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm7_en  |
   2c9d2:	f3c2 1180 	ubfx	r1, r2, #6, #1
          fsm_enable.fsm_enable_a.fsm6_en  |
   2c9d6:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_a.fsm7_en  |
   2c9d8:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
          fsm_enable.fsm_enable_b.fsm9_en  |
   2c9dc:	f89d 2005 	ldrb.w	r2, [sp, #5]
   2c9e0:	f3c2 0100 	ubfx	r1, r2, #0, #1
          fsm_enable.fsm_enable_a.fsm8_en  |
   2c9e4:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm10_en |
   2c9e6:	f3c2 0140 	ubfx	r1, r2, #1, #1
          fsm_enable.fsm_enable_b.fsm9_en  |
   2c9ea:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm11_en |
   2c9ec:	f3c2 0180 	ubfx	r1, r2, #2, #1
          fsm_enable.fsm_enable_b.fsm10_en |
   2c9f0:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm12_en |
   2c9f2:	f3c2 01c0 	ubfx	r1, r2, #3, #1
          fsm_enable.fsm_enable_b.fsm11_en |
   2c9f6:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm13_en |
   2c9f8:	f3c2 1100 	ubfx	r1, r2, #4, #1
          fsm_enable.fsm_enable_b.fsm12_en |
   2c9fc:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm14_en |
   2c9fe:	f3c2 1140 	ubfx	r1, r2, #5, #1
          fsm_enable.fsm_enable_b.fsm13_en |
   2ca02:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm15_en |
   2ca04:	f3c2 1180 	ubfx	r1, r2, #6, #1
          fsm_enable.fsm_enable_b.fsm14_en |
   2ca08:	430b      	orrs	r3, r1
          fsm_enable.fsm_enable_b.fsm15_en |
   2ca0a:	ea43 13d2 	orr.w	r3, r3, r2, lsr #7
    if ( (fsm_enable.fsm_enable_a.fsm1_en  |
   2ca0e:	07db      	lsls	r3, r3, #31
   2ca10:	d510      	bpl.n	2ca34 <lsm6dso_gy_data_rate_set+0x98>
      ret =  lsm6dso_fsm_data_rate_get(ctx, &fsm_odr);
   2ca12:	f10d 0103 	add.w	r1, sp, #3
   2ca16:	4628      	mov	r0, r5
   2ca18:	f7ff ff2c 	bl	2c874 <lsm6dso_fsm_data_rate_get>
      if (ret == 0) {
   2ca1c:	b9e8      	cbnz	r0, 2ca5a <lsm6dso_gy_data_rate_set+0xbe>
        switch (fsm_odr) {
   2ca1e:	f89d 3003 	ldrb.w	r3, [sp, #3]
   2ca22:	2b03      	cmp	r3, #3
   2ca24:	d806      	bhi.n	2ca34 <lsm6dso_gy_data_rate_set+0x98>
   2ca26:	e8df f003 	tbb	[pc, r3]
   2ca2a:	1a02      	.short	0x1a02
   2ca2c:	221e      	.short	0x221e
            if (val == LSM6DSO_GY_ODR_OFF){
   2ca2e:	2c00      	cmp	r4, #0
              odr_gy = LSM6DSO_GY_ODR_12Hz5;
   2ca30:	bf08      	it	eq
   2ca32:	2401      	moveq	r4, #1
    ret = lsm6dso_read_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   2ca34:	2301      	movs	r3, #1
   2ca36:	466a      	mov	r2, sp
   2ca38:	2111      	movs	r1, #17
   2ca3a:	4628      	mov	r0, r5
   2ca3c:	f7fe fee4 	bl	2b808 <lsm6dso_read_reg>
  if (ret == 0) {
   2ca40:	b958      	cbnz	r0, 2ca5a <lsm6dso_gy_data_rate_set+0xbe>
    reg.odr_g = (uint8_t) odr_gy;
   2ca42:	f89d 3000 	ldrb.w	r3, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   2ca46:	466a      	mov	r2, sp
    reg.odr_g = (uint8_t) odr_gy;
   2ca48:	f364 1307 	bfi	r3, r4, #4, #4
   2ca4c:	f88d 3000 	strb.w	r3, [sp]
    ret = lsm6dso_write_reg(ctx, LSM6DSO_CTRL2_G, (uint8_t*)&reg, 1);
   2ca50:	2111      	movs	r1, #17
   2ca52:	2301      	movs	r3, #1
   2ca54:	4628      	mov	r0, r5
   2ca56:	f7fe fede 	bl	2b816 <lsm6dso_write_reg>
}
   2ca5a:	b003      	add	sp, #12
   2ca5c:	bd30      	pop	{r4, r5, pc}
            if (val == LSM6DSO_GY_ODR_OFF){
   2ca5e:	2c02      	cmp	r4, #2
   2ca60:	bf38      	it	cc
   2ca62:	2402      	movcc	r4, #2
   2ca64:	e7e6      	b.n	2ca34 <lsm6dso_gy_data_rate_set+0x98>
            if (val == LSM6DSO_GY_ODR_OFF){
   2ca66:	2c03      	cmp	r4, #3
   2ca68:	bf38      	it	cc
   2ca6a:	2403      	movcc	r4, #3
   2ca6c:	e7e2      	b.n	2ca34 <lsm6dso_gy_data_rate_set+0x98>
            if (val == LSM6DSO_GY_ODR_OFF){
   2ca6e:	2c04      	cmp	r4, #4
   2ca70:	bf38      	it	cc
   2ca72:	2404      	movcc	r4, #4
   2ca74:	e7de      	b.n	2ca34 <lsm6dso_gy_data_rate_set+0x98>

0002ca76 <lsm6dso_long_cnt_int_value_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      the value of long counter
  *
  */
int32_t lsm6dso_long_cnt_int_value_set(stmdev_ctx_t *ctx, uint16_t val)
{
   2ca76:	b513      	push	{r0, r1, r4, lr}
  int32_t ret;
  uint8_t add_l;
  uint8_t add_h;

  add_h = (uint8_t)( ( val & 0xFF00U ) >> 8 );
   2ca78:	0a0b      	lsrs	r3, r1, #8
  add_l = (uint8_t)( val & 0x00FFU );
   2ca7a:	f88d 1006 	strb.w	r1, [sp, #6]

  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_FSM_LC_TIMEOUT_L, &add_l);
   2ca7e:	f10d 0206 	add.w	r2, sp, #6
   2ca82:	f44f 71bd 	mov.w	r1, #378	; 0x17a
{
   2ca86:	4604      	mov	r4, r0
  add_h = (uint8_t)( ( val & 0xFF00U ) >> 8 );
   2ca88:	f88d 3007 	strb.w	r3, [sp, #7]
  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_FSM_LC_TIMEOUT_L, &add_l);
   2ca8c:	f7fe fffc 	bl	2ba88 <lsm6dso_ln_pg_write_byte>
  if (ret == 0) {
   2ca90:	b930      	cbnz	r0, 2caa0 <lsm6dso_long_cnt_int_value_set+0x2a>
    ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_FSM_LC_TIMEOUT_H, &add_h);
   2ca92:	f10d 0207 	add.w	r2, sp, #7
   2ca96:	f240 117b 	movw	r1, #379	; 0x17b
   2ca9a:	4620      	mov	r0, r4
   2ca9c:	f7fe fff4 	bl	2ba88 <lsm6dso_ln_pg_write_byte>
  }

  return ret;
}
   2caa0:	b002      	add	sp, #8
   2caa2:	bd10      	pop	{r4, pc}

0002caa4 <lsm6dso_fsm_number_of_programs_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      value to write
  *
  */
int32_t lsm6dso_fsm_number_of_programs_set(stmdev_ctx_t *ctx, uint8_t val)
{
   2caa4:	b507      	push	{r0, r1, r2, lr}
   2caa6:	f88d 1007 	strb.w	r1, [sp, #7]
  int32_t ret;

  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_FSM_PROGRAMS, &val);
   2caaa:	f10d 0207 	add.w	r2, sp, #7
   2caae:	f44f 71be 	mov.w	r1, #380	; 0x17c
   2cab2:	f7fe ffe9 	bl	2ba88 <lsm6dso_ln_pg_write_byte>

  return ret;
}
   2cab6:	b003      	add	sp, #12
   2cab8:	f85d fb04 	ldr.w	pc, [sp], #4

0002cabc <lsm6dso_fsm_start_address_set>:
  * @param  ctx      read / write interface definitions
  * @param  val      the value of start address
  *
  */
int32_t lsm6dso_fsm_start_address_set(stmdev_ctx_t *ctx, uint16_t val)
{
   2cabc:	b513      	push	{r0, r1, r4, lr}
  int32_t ret;
  uint8_t add_l;
  uint8_t add_h;

  add_h = (uint8_t)( ( val & 0xFF00U ) >> 8 );
   2cabe:	0a0b      	lsrs	r3, r1, #8
  add_l = (uint8_t)( val & 0x00FFU );
   2cac0:	f88d 1006 	strb.w	r1, [sp, #6]

  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_FSM_START_ADD_L, &add_l);
   2cac4:	f10d 0206 	add.w	r2, sp, #6
   2cac8:	f44f 71bf 	mov.w	r1, #382	; 0x17e
{
   2cacc:	4604      	mov	r4, r0
  add_h = (uint8_t)( ( val & 0xFF00U ) >> 8 );
   2cace:	f88d 3007 	strb.w	r3, [sp, #7]
  ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_FSM_START_ADD_L, &add_l);
   2cad2:	f7fe ffd9 	bl	2ba88 <lsm6dso_ln_pg_write_byte>
  if (ret == 0) {
   2cad6:	b930      	cbnz	r0, 2cae6 <lsm6dso_fsm_start_address_set+0x2a>
    ret = lsm6dso_ln_pg_write_byte(ctx, LSM6DSO_FSM_START_ADD_H, &add_h);
   2cad8:	f10d 0207 	add.w	r2, sp, #7
   2cadc:	f240 117f 	movw	r1, #383	; 0x17f
   2cae0:	4620      	mov	r0, r4
   2cae2:	f7fe ffd1 	bl	2ba88 <lsm6dso_ln_pg_write_byte>
  }
  return ret;
}
   2cae6:	b002      	add	sp, #8
   2cae8:	bd10      	pop	{r4, pc}

0002caea <ShowBootUpLogo>:
}
   2caea:	4770      	bx	lr

0002caec <IdleShowDateTime>:
{
   2caec:	b508      	push	{r3, lr}
	IdleShowSystemTime();
   2caee:	f7e8 ff59 	bl	159a4 <IdleShowSystemTime>
	IdleShowSystemDate();
   2caf2:	f7e8 ff13 	bl	1591c <IdleShowSystemDate>
}
   2caf6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	IdleShowSystemWeek();
   2cafa:	f7e8 bf97 	b.w	15a2c <IdleShowSystemWeek>

0002cafe <NotifyTimerOutCallBack>:
	ExitNotifyScreen();
   2cafe:	f7e9 bc25 	b.w	1634c <ExitNotifyScreen>

0002cb02 <gpio_add_callback>:
	if (api->manage_callback == NULL) {
   2cb02:	6843      	ldr	r3, [r0, #4]
   2cb04:	68db      	ldr	r3, [r3, #12]
   2cb06:	b10b      	cbz	r3, 2cb0c <gpio_add_callback+0xa>
	return api->manage_callback(port, callback, true);
   2cb08:	2201      	movs	r2, #1
   2cb0a:	4718      	bx	r3
}
   2cb0c:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2cb10:	4770      	bx	lr

0002cb12 <gpio_pin_disable_callback>:
{
   2cb12:	460a      	mov	r2, r1
	if (api->disable_callback == NULL) {
   2cb14:	6843      	ldr	r3, [r0, #4]
   2cb16:	695b      	ldr	r3, [r3, #20]
   2cb18:	b10b      	cbz	r3, 2cb1e <gpio_pin_disable_callback+0xc>
	return api->disable_callback(port, access_op, pin);
   2cb1a:	2100      	movs	r1, #0
   2cb1c:	4718      	bx	r3
}
   2cb1e:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2cb22:	4770      	bx	lr

0002cb24 <gpio_pin_enable_callback>:
{
   2cb24:	460a      	mov	r2, r1
	if (api->enable_callback == NULL) {
   2cb26:	6843      	ldr	r3, [r0, #4]
   2cb28:	691b      	ldr	r3, [r3, #16]
   2cb2a:	b10b      	cbz	r3, 2cb30 <gpio_pin_enable_callback+0xc>
	return api->enable_callback(port, access_op, pin);
   2cb2c:	2100      	movs	r1, #0
   2cb2e:	4718      	bx	r3
}
   2cb30:	f06f 0085 	mvn.w	r0, #133	; 0x85
   2cb34:	4770      	bx	lr

0002cb36 <platform_write>:
{
   2cb36:	b5f0      	push	{r4, r5, r6, r7, lr}
   2cb38:	b085      	sub	sp, #20
   2cb3a:	4604      	mov	r4, r0
	u8_t data[len+1];
   2cb3c:	4668      	mov	r0, sp
{
   2cb3e:	4616      	mov	r6, r2
	u8_t data[len+1];
   2cb40:	f103 0208 	add.w	r2, r3, #8
   2cb44:	08d2      	lsrs	r2, r2, #3
   2cb46:	eba0 02c2 	sub.w	r2, r0, r2, lsl #3
{
   2cb4a:	af00      	add	r7, sp, #0
	u8_t data[len+1];
   2cb4c:	4695      	mov	sp, r2
	data[0] = reg;
   2cb4e:	4668      	mov	r0, sp
   2cb50:	461a      	mov	r2, r3
   2cb52:	f800 1b01 	strb.w	r1, [r0], #1
   2cb56:	4631      	mov	r1, r6
	u8_t data[len+1];
   2cb58:	1c5d      	adds	r5, r3, #1
   2cb5a:	f002 fbfb 	bl	2f354 <memcpy>
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   2cb5e:	2302      	movs	r3, #2
	msg.buf = (u8_t *)buf;
   2cb60:	f8c7 d004 	str.w	sp, [r7, #4]
	msg.len = num_bytes;
   2cb64:	60bd      	str	r5, [r7, #8]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   2cb66:	733b      	strb	r3, [r7, #12]
	return api->transfer(dev, msgs, num_msgs, addr);
   2cb68:	6863      	ldr	r3, [r4, #4]
   2cb6a:	1d39      	adds	r1, r7, #4
   2cb6c:	685d      	ldr	r5, [r3, #4]
   2cb6e:	2201      	movs	r2, #1
   2cb70:	2328      	movs	r3, #40	; 0x28
   2cb72:	4620      	mov	r0, r4
   2cb74:	47a8      	blx	r5
}
   2cb76:	3714      	adds	r7, #20
   2cb78:	46bd      	mov	sp, r7
   2cb7a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0002cb7c <platform_read>:
{
   2cb7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2cb80:	b086      	sub	sp, #24
   2cb82:	461e      	mov	r6, r3
	msg.buf = (u8_t *)buf;
   2cb84:	f10d 0307 	add.w	r3, sp, #7
   2cb88:	9303      	str	r3, [sp, #12]
	msg.len = num_bytes;
   2cb8a:	2501      	movs	r5, #1
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   2cb8c:	2302      	movs	r3, #2
   2cb8e:	4604      	mov	r4, r0
   2cb90:	4617      	mov	r7, r2
   2cb92:	f88d 1007 	strb.w	r1, [sp, #7]
	msg.len = num_bytes;
   2cb96:	9504      	str	r5, [sp, #16]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   2cb98:	f88d 3014 	strb.w	r3, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   2cb9c:	6843      	ldr	r3, [r0, #4]
   2cb9e:	462a      	mov	r2, r5
   2cba0:	f8d3 8004 	ldr.w	r8, [r3, #4]
   2cba4:	a903      	add	r1, sp, #12
   2cba6:	2328      	movs	r3, #40	; 0x28
   2cba8:	47c0      	blx	r8
	if(rslt == 0)
   2cbaa:	b958      	cbnz	r0, 2cbc4 <platform_read+0x48>
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
   2cbac:	2303      	movs	r3, #3
		rslt = i2c_read(handle, bufp, len, MAX20353_I2C_ADDR);
   2cbae:	e9cd 7603 	strd	r7, r6, [sp, #12]
   2cbb2:	f88d 3014 	strb.w	r3, [sp, #20]
	return api->transfer(dev, msgs, num_msgs, addr);
   2cbb6:	6863      	ldr	r3, [r4, #4]
   2cbb8:	462a      	mov	r2, r5
   2cbba:	685e      	ldr	r6, [r3, #4]
   2cbbc:	a903      	add	r1, sp, #12
   2cbbe:	2328      	movs	r3, #40	; 0x28
   2cbc0:	4620      	mov	r0, r4
   2cbc2:	47b0      	blx	r6
}
   2cbc4:	b006      	add	sp, #24
   2cbc6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002cbca <Set_Screen_Backlight_On>:
	ret = MAX20353_LED1(2, 31, true);
   2cbca:	2201      	movs	r2, #1
   2cbcc:	211f      	movs	r1, #31
   2cbce:	2002      	movs	r0, #2
   2cbd0:	f000 b81d 	b.w	2cc0e <MAX20353_LED1>

0002cbd4 <Set_Screen_Backlight_Off>:
	ret = MAX20353_LED1(2, 0, false);
   2cbd4:	2200      	movs	r2, #0
   2cbd6:	2002      	movs	r0, #2
   2cbd8:	4611      	mov	r1, r2
   2cbda:	f000 b818 	b.w	2cc0e <MAX20353_LED1>

0002cbde <SystemShutDown>:
{
   2cbde:	b508      	push	{r3, lr}
	SaveSystemDateTime();
   2cbe0:	f7e4 ff12 	bl	11a08 <SaveSystemDateTime>
}
   2cbe4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	MAX20353_PowerOffConfig();
   2cbe8:	f7ea b960 	b.w	16eac <MAX20353_PowerOffConfig>

0002cbec <k_sleep>:
   2cbec:	f7fb bc3c 	b.w	28468 <z_impl_k_sleep>

0002cbf0 <VibrateStart>:
{
   2cbf0:	b508      	push	{r3, lr}
	MAX20353_WriteReg( REG_HPT_RTI2CAMP,  0x3F);	//0x000x7f
   2cbf2:	213f      	movs	r1, #63	; 0x3f
   2cbf4:	2032      	movs	r0, #50	; 0x32
   2cbf6:	f7ea f845 	bl	16c84 <MAX20353_WriteReg>
}
   2cbfa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	MAX20353_WriteReg( REG_HPT_DIRECT1,  0x26); //hptExtTrig=1, HptRamEn=1, HptDrvEn=1, HptDrvMode=0x06
   2cbfe:	2126      	movs	r1, #38	; 0x26
   2cc00:	2031      	movs	r0, #49	; 0x31
   2cc02:	f7ea b83f 	b.w	16c84 <MAX20353_WriteReg>

0002cc06 <VibrateStop>:
	MAX20353_WriteReg( REG_HPT_DIRECT1,  0x00); //hptExtTrig=1, HptRamEn=1, HptDrvEn=1, HptDrvMode=0x12
   2cc06:	2100      	movs	r1, #0
   2cc08:	2031      	movs	r0, #49	; 0x31
   2cc0a:	f7ea b83b 	b.w	16c84 <MAX20353_WriteReg>

0002cc0e <MAX20353_LED1>:
{ 
   2cc0e:	b538      	push	{r3, r4, r5, lr}
   2cc10:	4615      	mov	r5, r2
   2cc12:	460c      	mov	r4, r1
	ret |= MAX20353_WriteReg(REG_LED_STEP_DIRECT,  IStep&0x03);
   2cc14:	f000 0103 	and.w	r1, r0, #3
   2cc18:	202c      	movs	r0, #44	; 0x2c
   2cc1a:	f7ea f833 	bl	16c84 <MAX20353_WriteReg>
	if(flag)
   2cc1e:	b145      	cbz	r5, 2cc32 <MAX20353_LED1+0x24>
		ret |= MAX20353_WriteReg(REG_LED1_DIRECT,  0x20|(Amplitude&0x1F)); 
   2cc20:	f004 011f 	and.w	r1, r4, #31
   2cc24:	f041 0120 	orr.w	r1, r1, #32
		ret |= MAX20353_WriteReg(REG_LED1_DIRECT,  0x00); 
   2cc28:	202e      	movs	r0, #46	; 0x2e
}
   2cc2a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		ret |= MAX20353_WriteReg(REG_LED1_DIRECT,  0x00); 
   2cc2e:	f7ea b829 	b.w	16c84 <MAX20353_WriteReg>
   2cc32:	4629      	mov	r1, r5
   2cc34:	e7f8      	b.n	2cc28 <MAX20353_LED1+0x1a>

0002cc36 <MAX20353_EnablePMICIntMaskRegisters>:
{
   2cc36:	b538      	push	{r3, r4, r5, lr}
   2cc38:	4605      	mov	r5, r0
	ret  = MAX20353_WriteReg(REG_INT_MASK0, buf_results[0]);
   2cc3a:	7801      	ldrb	r1, [r0, #0]
   2cc3c:	200c      	movs	r0, #12
   2cc3e:	f7ea f821 	bl	16c84 <MAX20353_WriteReg>
	ret |= MAX20353_WriteReg(REG_INT_MASK1, buf_results[1]);
   2cc42:	7869      	ldrb	r1, [r5, #1]
	ret  = MAX20353_WriteReg(REG_INT_MASK0, buf_results[0]);
   2cc44:	4604      	mov	r4, r0
	ret |= MAX20353_WriteReg(REG_INT_MASK1, buf_results[1]);
   2cc46:	200d      	movs	r0, #13
   2cc48:	f7ea f81c 	bl	16c84 <MAX20353_WriteReg>
	ret |= MAX20353_WriteReg(REG_INT_MASK2, buf_results[2]);
   2cc4c:	78a9      	ldrb	r1, [r5, #2]
	ret |= MAX20353_WriteReg(REG_INT_MASK1, buf_results[1]);
   2cc4e:	4304      	orrs	r4, r0
	ret |= MAX20353_WriteReg(REG_INT_MASK2, buf_results[2]);
   2cc50:	200e      	movs	r0, #14
   2cc52:	f7ea f817 	bl	16c84 <MAX20353_WriteReg>
}
   2cc56:	4320      	orrs	r0, r4
   2cc58:	bd38      	pop	{r3, r4, r5, pc}

0002cc5a <MAX20353_GetDeviceID>:
	MAX20353_ReadReg(REG_HARDWARE_ID, Device_ID);
   2cc5a:	4601      	mov	r1, r0
   2cc5c:	2000      	movs	r0, #0
   2cc5e:	f7ea b825 	b.w	16cac <MAX20353_ReadReg>

0002cc62 <MAX20353_QuickStart>:
	WriteWord(0x06, 0x40, 0x00);
   2cc62:	2200      	movs	r2, #0
   2cc64:	2140      	movs	r1, #64	; 0x40
   2cc66:	2006      	movs	r0, #6
   2cc68:	f7ea b9ee 	b.w	17048 <WriteWord>

0002cc6c <handle_model>:
handle_model(LOAD_MODEL);
If you want to verify the model, and correct errors, call:
handle_model(VERIFY_AND_FIX);
*/
void handle_model(int load_or_verify)
{
   2cc6c:	b538      	push	{r3, r4, r5, lr}
   2cc6e:	4605      	mov	r5, r0
   2cc70:	2403      	movs	r4, #3
	u8_t retry = 3;
	
	do
	{
		// Steps 1-4
		prepare_to_load_model();
   2cc72:	f7ea faa9 	bl	171c8 <prepare_to_load_model>
		if(load_or_verify == LOAD_MODEL)
   2cc76:	b90d      	cbnz	r5, 2cc7c <handle_model+0x10>
		{
			//Step 5
			load_model();
   2cc78:	f7ea fabe 	bl	171f8 <load_model>
		}
		
		//Steps 6-9
		model_load_ok = verify_model_is_correct();
   2cc7c:	f7ea fae0 	bl	17240 <verify_model_is_correct>
		if(!model_load_ok)
   2cc80:	b118      	cbz	r0, 2cc8a <handle_model+0x1e>
		retry--;
	}while((!model_load_ok)&&(retry>0));
	
	// Steps 10-11
	cleanup_model_load();
}
   2cc82:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	cleanup_model_load();
   2cc86:	f7ea bb01 	b.w	1728c <cleanup_model_load>
		retry--;
   2cc8a:	3c01      	subs	r4, #1
	}while((!model_load_ok)&&(retry>0));
   2cc8c:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
			load_or_verify = LOAD_MODEL;
   2cc90:	4605      	mov	r5, r0
	}while((!model_load_ok)&&(retry>0));
   2cc92:	d1ee      	bne.n	2cc72 <handle_model+0x6>
   2cc94:	e7f5      	b.n	2cc82 <handle_model+0x16>

0002cc96 <MAX20353_SOCReadReg>:
   2cc96:	f7ea b99f 	b.w	16fd8 <ReadWord>

0002cc9a <MAX20353_SOCWriteReg>:
   2cc9a:	f7ea b9d5 	b.w	17048 <WriteWord>

0002cc9e <MAX20353_SOCInit>:
		return MAX20353_ERROR;
	return MAX20353_NO_ERROR;
}

void MAX20353_SOCInit(void)
{
   2cc9e:	b507      	push	{r0, r1, r2, lr}
	u8_t MSB,LSB;

	MAX20353_SOCReadReg(0x1A, &MSB, &LSB);
   2cca0:	201a      	movs	r0, #26
   2cca2:	f10d 0106 	add.w	r1, sp, #6
   2cca6:	f10d 0207 	add.w	r2, sp, #7
   2ccaa:	f7ea f995 	bl	16fd8 <ReadWord>
	if(MSB&0x01)
   2ccae:	f89d 1006 	ldrb.w	r1, [sp, #6]
   2ccb2:	07cb      	lsls	r3, r1, #31
   2ccb4:	d510      	bpl.n	2ccd8 <MAX20353_SOCInit+0x3a>
	{
		//RI (reset indicator) is set when the device powers up.
		//Any time this bit is set, the IC is not configured, so the
		//model should be loaded and the bit should be cleared
		MSB = MSB&0xFE;
   2ccb6:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
		MAX20353_SOCWriteReg(0x1A, MSB, LSB);
   2ccba:	f89d 2007 	ldrb.w	r2, [sp, #7]
   2ccbe:	201a      	movs	r0, #26
		MSB = MSB&0xFE;
   2ccc0:	f88d 1006 	strb.w	r1, [sp, #6]
		MAX20353_SOCWriteReg(0x1A, MSB, LSB);
   2ccc4:	f7ea f9c0 	bl	17048 <WriteWord>
		MAX20353_QuickStart();
   2ccc8:	f7ff ffcb 	bl	2cc62 <MAX20353_QuickStart>
    k_sleep(K_MSEC(period));
   2cccc:	2096      	movs	r0, #150	; 0x96
   2ccce:	f7ff ff8d 	bl	2cbec <k_sleep>
		delay_ms(150);
		
		handle_model(LOAD_MODEL);
   2ccd2:	2000      	movs	r0, #0
   2ccd4:	f7ff ffca 	bl	2cc6c <handle_model>
	}
	
	//25SOC1%4%
	WriteWord(0x0C, 0x12, 0x5C);
   2ccd8:	225c      	movs	r2, #92	; 0x5c
   2ccda:	2112      	movs	r1, #18
   2ccdc:	200c      	movs	r0, #12
   2ccde:	f7ea f9b3 	bl	17048 <WriteWord>

#ifdef BATTERT_NTC_CHECK
	MAX20353_StartCheckTemper();
   2cce2:	f7ea fa4f 	bl	17184 <MAX20353_StartCheckTemper>
#endif
}
   2cce6:	b003      	add	sp, #12
   2cce8:	f85d fb04 	ldr.w	pc, [sp], #4

0002ccec <GetHeartRate>:
	gpio_pin_write(gpio_ppg, 17, 0);
	return 0;
}

void GetHeartRate(u8_t *HR)
{
   2ccec:	b538      	push	{r3, r4, r5, lr}
   2ccee:	4605      	mov	r5, r0
	u32_t heart;

	while(1)
	{
		heart = sys_rand32_get();
		if(((heart%200)>=60) && ((heart%200)<=160))
   2ccf0:	24c8      	movs	r4, #200	; 0xc8
		heart = sys_rand32_get();
   2ccf2:	f7ed fcf7 	bl	1a6e4 <sys_rand32_get>
		if(((heart%200)>=60) && ((heart%200)<=160))
   2ccf6:	fbb0 f3f4 	udiv	r3, r0, r4
   2ccfa:	fb03 0014 	mls	r0, r3, r4, r0
   2ccfe:	f1a0 033c 	sub.w	r3, r0, #60	; 0x3c
   2cd02:	2b64      	cmp	r3, #100	; 0x64
   2cd04:	d8f5      	bhi.n	2ccf2 <GetHeartRate+0x6>
		{
			*HR = (heart%200);
   2cd06:	7028      	strb	r0, [r5, #0]
			break;
		}
	}
}
   2cd08:	bd38      	pop	{r3, r4, r5, pc}

0002cd0a <mmi_chset_init>:
	}
#endif /* __MMI_CHSET_WESTERN_WIN__ */ 


    g_chset_tbl_is_init = true;
}
   2cd0a:	4770      	bx	lr

0002cd0c <get_bit_ptr>:
{
   2cd0c:	b570      	push	{r4, r5, r6, lr}
   2cd0e:	250c      	movs	r5, #12
   2cd10:	68c6      	ldr	r6, [r0, #12]
	u32_t *bitarray = level <= p->max_inline_level ?
   2cd12:	f990 000b 	ldrsb.w	r0, [r0, #11]
   2cd16:	434d      	muls	r5, r1
		p->levels[level].bits : p->levels[level].bits_p;
   2cd18:	4288      	cmp	r0, r1
	*word = &bitarray[bn / 32];
   2cd1a:	4610      	mov	r0, r2
   2cd1c:	eb06 0405 	add.w	r4, r6, r5
		p->levels[level].bits : p->levels[level].bits_p;
   2cd20:	bfb8      	it	lt
   2cd22:	5974      	ldrlt	r4, [r6, r5]
	*word = &bitarray[bn / 32];
   2cd24:	2a00      	cmp	r2, #0
   2cd26:	bfb8      	it	lt
   2cd28:	f102 001f 	addlt.w	r0, r2, #31
   2cd2c:	1140      	asrs	r0, r0, #5
   2cd2e:	eb04 0180 	add.w	r1, r4, r0, lsl #2
   2cd32:	6019      	str	r1, [r3, #0]
}
   2cd34:	f002 001f 	and.w	r0, r2, #31
   2cd38:	bd70      	pop	{r4, r5, r6, pc}

0002cd3a <pool_irq_lock.isra.2.part.3>:
	__asm__ volatile(
   2cd3a:	f04f 0320 	mov.w	r3, #32
   2cd3e:	f3ef 8011 	mrs	r0, BASEPRI
   2cd42:	f383 8811 	msr	BASEPRI, r3
   2cd46:	f3bf 8f6f 	isb	sy
}
   2cd4a:	4770      	bx	lr

0002cd4c <pool_irq_unlock.isra.4>:
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   2cd4c:	07c3      	lsls	r3, r0, #31
   2cd4e:	d503      	bpl.n	2cd58 <pool_irq_unlock.isra.4+0xc>
	__asm__ volatile(
   2cd50:	f381 8811 	msr	BASEPRI, r1
   2cd54:	f3bf 8f6f 	isb	sy
}
   2cd58:	4770      	bx	lr

0002cd5a <z_sys_mem_pool_base_init>:
	p->max_inline_level = -1;
   2cd5a:	23ff      	movs	r3, #255	; 0xff
{
   2cd5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   2cd60:	6846      	ldr	r6, [r0, #4]
	p->max_inline_level = -1;
   2cd62:	72c3      	strb	r3, [r0, #11]
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   2cd64:	4632      	mov	r2, r6
	for (i = 0; i < p->n_levels; i++) {
   2cd66:	2300      	movs	r3, #0
		sys_dlist_init(&p->levels[i].free_list);
   2cd68:	f04f 090c 	mov.w	r9, #12
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   2cd6c:	8907      	ldrh	r7, [r0, #8]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   2cd6e:	6801      	ldr	r1, [r0, #0]
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   2cd70:	fb06 fc07 	mul.w	ip, r6, r7
	for (i = 0; i < p->n_levels; i++) {
   2cd74:	f890 800a 	ldrb.w	r8, [r0, #10]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   2cd78:	4461      	add	r1, ip
	for (i = 0; i < p->n_levels; i++) {
   2cd7a:	4598      	cmp	r8, r3
   2cd7c:	dc05      	bgt.n	2cd8a <z_sys_mem_pool_base_init+0x30>
   2cd7e:	2300      	movs	r3, #0
	for (i = 0; i < p->n_max; i++) {
   2cd80:	4619      	mov	r1, r3
   2cd82:	428f      	cmp	r7, r1
   2cd84:	dc20      	bgt.n	2cdc8 <z_sys_mem_pool_base_init+0x6e>
}
   2cd86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		int nblocks = buflen / sz;
   2cd8a:	fbbc f5f2 	udiv	r5, ip, r2
		sys_dlist_init(&p->levels[i].free_list);
   2cd8e:	fb09 fe03 	mul.w	lr, r9, r3
   2cd92:	f8d0 a00c 	ldr.w	sl, [r0, #12]
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
   2cd96:	2d20      	cmp	r5, #32
		sys_dlist_init(&p->levels[i].free_list);
   2cd98:	eb0a 040e 	add.w	r4, sl, lr
   2cd9c:	f104 0b04 	add.w	fp, r4, #4
	list->tail = (sys_dnode_t *)list;
   2cda0:	e9c4 bb01 	strd	fp, fp, [r4, #4]
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
   2cda4:	d805      	bhi.n	2cdb2 <z_sys_mem_pool_base_init+0x58>
			p->max_inline_level = i;
   2cda6:	72c3      	strb	r3, [r0, #11]
		sz = WB_DN(sz / 4);
   2cda8:	0892      	lsrs	r2, r2, #2
   2cdaa:	f022 0203 	bic.w	r2, r2, #3
	for (i = 0; i < p->n_levels; i++) {
   2cdae:	3301      	adds	r3, #1
   2cdb0:	e7e3      	b.n	2cd7a <z_sys_mem_pool_base_init+0x20>
			bits += (nblocks + 31)/32;
   2cdb2:	f115 041f 	adds.w	r4, r5, #31
   2cdb6:	bf48      	it	mi
   2cdb8:	f105 043e 	addmi.w	r4, r5, #62	; 0x3e
   2cdbc:	1164      	asrs	r4, r4, #5
			p->levels[i].bits_p = bits;
   2cdbe:	f84a 100e 	str.w	r1, [sl, lr]
			bits += (nblocks + 31)/32;
   2cdc2:	eb01 0184 	add.w	r1, r1, r4, lsl #2
   2cdc6:	e7ef      	b.n	2cda8 <z_sys_mem_pool_base_init+0x4e>
		sys_dlist_append(&p->levels[0].free_list, block);
   2cdc8:	68c2      	ldr	r2, [r0, #12]
	return (u8_t *)p->buf + lsz * block;
   2cdca:	6805      	ldr	r5, [r0, #0]
		sys_dlist_append(&p->levels[0].free_list, block);
   2cdcc:	f102 0c04 	add.w	ip, r2, #4
	return (u8_t *)p->buf + lsz * block;
   2cdd0:	18ec      	adds	r4, r5, r3
	node->next = list;
   2cdd2:	f845 c003 	str.w	ip, [r5, r3]
	node->prev = list->tail;
   2cdd6:	6895      	ldr	r5, [r2, #8]
	for (i = 0; i < p->n_max; i++) {
   2cdd8:	3101      	adds	r1, #1
   2cdda:	6065      	str	r5, [r4, #4]
	list->tail->next = node;
   2cddc:	6895      	ldr	r5, [r2, #8]
   2cdde:	4433      	add	r3, r6
   2cde0:	602c      	str	r4, [r5, #0]
	list->tail = node;
   2cde2:	6094      	str	r4, [r2, #8]
   2cde4:	e7cd      	b.n	2cd82 <z_sys_mem_pool_base_init+0x28>

0002cde6 <z_sys_mem_pool_block_alloc>:
{
   2cde6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2cdea:	b087      	sub	sp, #28
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   2cdec:	7a84      	ldrb	r4, [r0, #10]
{
   2cdee:	af00      	add	r7, sp, #0
   2cdf0:	e9c7 3201 	strd	r3, r2, [r7, #4]
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   2cdf4:	00a3      	lsls	r3, r4, #2
   2cdf6:	3307      	adds	r3, #7
   2cdf8:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
   2cdfc:	ebad 0d03 	sub.w	sp, sp, r3
   2ce00:	46ea      	mov	sl, sp
	lsizes[0] = p->max_sz;
   2ce02:	4653      	mov	r3, sl
   2ce04:	6842      	ldr	r2, [r0, #4]
{
   2ce06:	4605      	mov	r5, r0
	lsizes[0] = p->max_sz;
   2ce08:	f843 2904 	str.w	r2, [r3], #-4
	for (i = 0; i < p->n_levels; i++) {
   2ce0c:	2200      	movs	r2, #0
   2ce0e:	4294      	cmp	r4, r2
   2ce10:	f102 39ff 	add.w	r9, r2, #4294967295
   2ce14:	dd09      	ble.n	2ce2a <z_sys_mem_pool_block_alloc+0x44>
		if (i > 0) {
   2ce16:	b122      	cbz	r2, 2ce22 <z_sys_mem_pool_block_alloc+0x3c>
			lsizes[i] = WB_DN(lsizes[i-1] / 4);
   2ce18:	6818      	ldr	r0, [r3, #0]
   2ce1a:	0880      	lsrs	r0, r0, #2
   2ce1c:	f020 0003 	bic.w	r0, r0, #3
   2ce20:	6058      	str	r0, [r3, #4]
		if (lsizes[i] < size) {
   2ce22:	f853 0f04 	ldr.w	r0, [r3, #4]!
   2ce26:	4288      	cmp	r0, r1
   2ce28:	d208      	bcs.n	2ce3c <z_sys_mem_pool_block_alloc+0x56>
	if (alloc_l < 0) {
   2ce2a:	f1b9 3fff 	cmp.w	r9, #4294967295
   2ce2e:	d107      	bne.n	2ce40 <z_sys_mem_pool_block_alloc+0x5a>
		*data_p = NULL;
   2ce30:	2300      	movs	r3, #0
   2ce32:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   2ce34:	6013      	str	r3, [r2, #0]
		return -ENOMEM;
   2ce36:	f06f 000b 	mvn.w	r0, #11
   2ce3a:	e02c      	b.n	2ce96 <z_sys_mem_pool_block_alloc+0xb0>
	for (i = 0; i < p->n_levels; i++) {
   2ce3c:	3201      	adds	r2, #1
   2ce3e:	e7e6      	b.n	2ce0e <z_sys_mem_pool_block_alloc+0x28>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   2ce40:	7c28      	ldrb	r0, [r5, #16]
   2ce42:	f010 0001 	ands.w	r0, r0, #1
   2ce46:	d001      	beq.n	2ce4c <z_sys_mem_pool_block_alloc+0x66>
   2ce48:	f7ff ff77 	bl	2cd3a <pool_irq_lock.isra.2.part.3>
   2ce4c:	230c      	movs	r3, #12
	key = pool_irq_lock(p);
   2ce4e:	4680      	mov	r8, r0
	block = sys_dlist_get(&p->levels[l].free_list);
   2ce50:	464e      	mov	r6, r9
   2ce52:	68ea      	ldr	r2, [r5, #12]
   2ce54:	fb03 2309 	mla	r3, r3, r9, r2
	return list->head == list;
   2ce58:	461a      	mov	r2, r3
   2ce5a:	f852 4f04 	ldr.w	r4, [r2, #4]!

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   2ce5e:	4294      	cmp	r4, r2
   2ce60:	d11d      	bne.n	2ce9e <z_sys_mem_pool_block_alloc+0xb8>
	for (i = alloc_l; i >= 0; i--) {
   2ce62:	3e01      	subs	r6, #1
   2ce64:	1c72      	adds	r2, r6, #1
   2ce66:	f1a3 030c 	sub.w	r3, r3, #12
   2ce6a:	d1f5      	bne.n	2ce58 <z_sys_mem_pool_block_alloc+0x72>
   2ce6c:	2400      	movs	r4, #0
	pool_irq_unlock(p, key);
   2ce6e:	4641      	mov	r1, r8
   2ce70:	7c28      	ldrb	r0, [r5, #16]
   2ce72:	f7ff ff6b 	bl	2cd4c <pool_irq_unlock.isra.4>
	*data_p = data;
   2ce76:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   2ce78:	601c      	str	r4, [r3, #0]
	if (data == NULL) {
   2ce7a:	2c00      	cmp	r4, #0
   2ce7c:	d0db      	beq.n	2ce36 <z_sys_mem_pool_block_alloc+0x50>
	*level_p = alloc_l;
   2ce7e:	68bb      	ldr	r3, [r7, #8]
	return 0;
   2ce80:	2000      	movs	r0, #0
	*level_p = alloc_l;
   2ce82:	f8c3 9000 	str.w	r9, [r3]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   2ce86:	682b      	ldr	r3, [r5, #0]
   2ce88:	1ae4      	subs	r4, r4, r3
   2ce8a:	f85a 3029 	ldr.w	r3, [sl, r9, lsl #2]
   2ce8e:	fb94 f4f3 	sdiv	r4, r4, r3
	*block_p = block_num(p, data, lsizes[alloc_l]);
   2ce92:	687b      	ldr	r3, [r7, #4]
   2ce94:	601c      	str	r4, [r3, #0]
}
   2ce96:	371c      	adds	r7, #28
   2ce98:	46bd      	mov	sp, r7
   2ce9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	node->prev->next = node->next;
   2ce9e:	e9d4 3200 	ldrd	r3, r2, [r4]
   2cea2:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   2cea4:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   2cea6:	2300      	movs	r3, #0
	node->prev = NULL;
   2cea8:	e9c4 3300 	strd	r3, r3, [r4]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   2ceac:	682b      	ldr	r3, [r5, #0]
		data = block_alloc(p, i, lsizes[i]);
   2ceae:	f85a 1026 	ldr.w	r1, [sl, r6, lsl #2]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   2ceb2:	1ae2      	subs	r2, r4, r3
	int bit = get_bit_ptr(p, level, bn, &word);
   2ceb4:	f107 0b14 	add.w	fp, r7, #20
   2ceb8:	fb92 f2f1 	sdiv	r2, r2, r1
   2cebc:	465b      	mov	r3, fp
   2cebe:	4631      	mov	r1, r6
   2cec0:	4628      	mov	r0, r5
   2cec2:	f7ff ff23 	bl	2cd0c <get_bit_ptr>
	*word |= (1<<bit);
   2cec6:	2201      	movs	r2, #1
   2cec8:	6979      	ldr	r1, [r7, #20]
   2ceca:	fa02 f000 	lsl.w	r0, r2, r0
   2cece:	680b      	ldr	r3, [r1, #0]
   2ced0:	603a      	str	r2, [r7, #0]
   2ced2:	4303      	orrs	r3, r0
   2ced4:	600b      	str	r3, [r1, #0]
			for (from_l = i; from_l < alloc_l; from_l++) {
   2ced6:	454e      	cmp	r6, r9
   2ced8:	dac9      	bge.n	2ce6e <z_sys_mem_pool_block_alloc+0x88>
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   2ceda:	682a      	ldr	r2, [r5, #0]
   2cedc:	f85a 3026 	ldr.w	r3, [sl, r6, lsl #2]
   2cee0:	1aa2      	subs	r2, r4, r2
   2cee2:	fb92 f2f3 	sdiv	r2, r2, r3
	set_alloc_bit(p, l + 1, 4*bn);
   2cee6:	3601      	adds	r6, #1
	int bit = get_bit_ptr(p, level, bn, &word);
   2cee8:	465b      	mov	r3, fp
   2ceea:	0092      	lsls	r2, r2, #2
   2ceec:	4631      	mov	r1, r6
   2ceee:	4628      	mov	r0, r5
   2cef0:	f7ff ff0c 	bl	2cd0c <get_bit_ptr>
	*word |= (1<<bit);
   2cef4:	697a      	ldr	r2, [r7, #20]
   2cef6:	683b      	ldr	r3, [r7, #0]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   2cef8:	68e9      	ldr	r1, [r5, #12]
	*word |= (1<<bit);
   2cefa:	fa03 f000 	lsl.w	r0, r3, r0
   2cefe:	6813      	ldr	r3, [r2, #0]
   2cf00:	4303      	orrs	r3, r0
   2cf02:	6013      	str	r3, [r2, #0]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   2cf04:	230c      	movs	r3, #12
   2cf06:	2203      	movs	r2, #3
   2cf08:	fb03 1106 	mla	r1, r3, r6, r1
		int lsz = lsizes[l + 1];
   2cf0c:	f85a 0026 	ldr.w	r0, [sl, r6, lsl #2]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   2cf10:	f101 0e04 	add.w	lr, r1, #4
   2cf14:	1823      	adds	r3, r4, r0
   2cf16:	60fa      	str	r2, [r7, #12]
	node->prev = list->tail;
   2cf18:	688a      	ldr	r2, [r1, #8]
	node->next = list;
   2cf1a:	f8c3 e000 	str.w	lr, [r3]
	node->prev = list->tail;
   2cf1e:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
   2cf20:	688a      	ldr	r2, [r1, #8]
   2cf22:	6013      	str	r3, [r2, #0]
	for (i = 1; i < 4; i++) {
   2cf24:	68fa      	ldr	r2, [r7, #12]
	list->tail = node;
   2cf26:	608b      	str	r3, [r1, #8]
   2cf28:	3a01      	subs	r2, #1
   2cf2a:	4403      	add	r3, r0
   2cf2c:	60fa      	str	r2, [r7, #12]
   2cf2e:	d1f3      	bne.n	2cf18 <z_sys_mem_pool_block_alloc+0x132>
				pool_irq_unlock(p, key);
   2cf30:	4641      	mov	r1, r8
   2cf32:	7c28      	ldrb	r0, [r5, #16]
   2cf34:	f7ff ff0a 	bl	2cd4c <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   2cf38:	7c2b      	ldrb	r3, [r5, #16]
   2cf3a:	07db      	lsls	r3, r3, #31
   2cf3c:	d503      	bpl.n	2cf46 <z_sys_mem_pool_block_alloc+0x160>
   2cf3e:	f7ff fefc 	bl	2cd3a <pool_irq_lock.isra.2.part.3>
				key = pool_irq_lock(p);
   2cf42:	4680      	mov	r8, r0
   2cf44:	e7c7      	b.n	2ced6 <z_sys_mem_pool_block_alloc+0xf0>
		return 0;
   2cf46:	68f8      	ldr	r0, [r7, #12]
   2cf48:	e7fb      	b.n	2cf42 <z_sys_mem_pool_block_alloc+0x15c>

0002cf4a <arch_printk_char_out>:
}
   2cf4a:	2000      	movs	r0, #0
   2cf4c:	4770      	bx	lr

0002cf4e <print_err>:
{
   2cf4e:	b570      	push	{r4, r5, r6, lr}
   2cf50:	460d      	mov	r5, r1
   2cf52:	4604      	mov	r4, r0
	out('E', ctx);
   2cf54:	2045      	movs	r0, #69	; 0x45
   2cf56:	47a0      	blx	r4
	out('R', ctx);
   2cf58:	4629      	mov	r1, r5
   2cf5a:	2052      	movs	r0, #82	; 0x52
   2cf5c:	47a0      	blx	r4
	out('R', ctx);
   2cf5e:	4629      	mov	r1, r5
   2cf60:	4623      	mov	r3, r4
}
   2cf62:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
   2cf66:	2052      	movs	r0, #82	; 0x52
   2cf68:	4718      	bx	r3

0002cf6a <z_vprintk>:
{
   2cf6a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char length_mod = 0;
   2cf6e:	f04f 0800 	mov.w	r8, #0
{
   2cf72:	4606      	mov	r6, r0
   2cf74:	460f      	mov	r7, r1
   2cf76:	461c      	mov	r4, r3
	int min_width = -1;
   2cf78:	f04f 3aff 	mov.w	sl, #4294967295
	enum pad_type padding = PAD_NONE;
   2cf7c:	46c1      	mov	r9, r8
	int might_format = 0; /* 1 if encountered a '%' */
   2cf7e:	4645      	mov	r5, r8
{
   2cf80:	b08b      	sub	sp, #44	; 0x2c
   2cf82:	9202      	str	r2, [sp, #8]
	while (*fmt) {
   2cf84:	9b02      	ldr	r3, [sp, #8]
   2cf86:	7818      	ldrb	r0, [r3, #0]
   2cf88:	b910      	cbnz	r0, 2cf90 <z_vprintk+0x26>
}
   2cf8a:	b00b      	add	sp, #44	; 0x2c
   2cf8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!might_format) {
   2cf90:	b945      	cbnz	r5, 2cfa4 <z_vprintk+0x3a>
			if (*fmt != '%') {
   2cf92:	2825      	cmp	r0, #37	; 0x25
   2cf94:	f000 814b 	beq.w	2d22e <z_vprintk+0x2c4>
				out((int)*fmt, ctx);
   2cf98:	4639      	mov	r1, r7
   2cf9a:	47b0      	blx	r6
		++fmt;
   2cf9c:	9b02      	ldr	r3, [sp, #8]
   2cf9e:	3301      	adds	r3, #1
   2cfa0:	9302      	str	r3, [sp, #8]
   2cfa2:	e7ef      	b.n	2cf84 <z_vprintk+0x1a>
			switch (*fmt) {
   2cfa4:	2864      	cmp	r0, #100	; 0x64
   2cfa6:	d06d      	beq.n	2d084 <z_vprintk+0x11a>
   2cfa8:	d819      	bhi.n	2cfde <z_vprintk+0x74>
   2cfaa:	2839      	cmp	r0, #57	; 0x39
   2cfac:	d80a      	bhi.n	2cfc4 <z_vprintk+0x5a>
   2cfae:	2831      	cmp	r0, #49	; 0x31
   2cfb0:	d25f      	bcs.n	2d072 <z_vprintk+0x108>
   2cfb2:	282d      	cmp	r0, #45	; 0x2d
   2cfb4:	f000 8141 	beq.w	2d23a <z_vprintk+0x2d0>
   2cfb8:	2830      	cmp	r0, #48	; 0x30
   2cfba:	d04b      	beq.n	2d054 <z_vprintk+0xea>
   2cfbc:	2825      	cmp	r0, #37	; 0x25
   2cfbe:	d107      	bne.n	2cfd0 <z_vprintk+0x66>
				out((int)'%', ctx);
   2cfc0:	4639      	mov	r1, r7
   2cfc2:	e132      	b.n	2d22a <z_vprintk+0x2c0>
			switch (*fmt) {
   2cfc4:	2858      	cmp	r0, #88	; 0x58
   2cfc6:	f000 80bb 	beq.w	2d140 <z_vprintk+0x1d6>
   2cfca:	2863      	cmp	r0, #99	; 0x63
   2cfcc:	f000 812a 	beq.w	2d224 <z_vprintk+0x2ba>
				out((int)'%', ctx);
   2cfd0:	4639      	mov	r1, r7
   2cfd2:	2025      	movs	r0, #37	; 0x25
   2cfd4:	47b0      	blx	r6
				out((int)*fmt, ctx);
   2cfd6:	9b02      	ldr	r3, [sp, #8]
   2cfd8:	4639      	mov	r1, r7
   2cfda:	7818      	ldrb	r0, [r3, #0]
   2cfdc:	e125      	b.n	2d22a <z_vprintk+0x2c0>
			switch (*fmt) {
   2cfde:	2870      	cmp	r0, #112	; 0x70
   2cfe0:	f000 80a4 	beq.w	2d12c <z_vprintk+0x1c2>
   2cfe4:	d811      	bhi.n	2d00a <z_vprintk+0xa0>
   2cfe6:	2869      	cmp	r0, #105	; 0x69
   2cfe8:	d04c      	beq.n	2d084 <z_vprintk+0x11a>
   2cfea:	286c      	cmp	r0, #108	; 0x6c
   2cfec:	d105      	bne.n	2cffa <z_vprintk+0x90>
				} else if (*fmt == 'l' && length_mod == 'l') {
   2cfee:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   2cff2:	d12a      	bne.n	2d04a <z_vprintk+0xe0>
					length_mod = 'L';
   2cff4:	f04f 084c 	mov.w	r8, #76	; 0x4c
   2cff8:	e7d0      	b.n	2cf9c <z_vprintk+0x32>
			switch (*fmt) {
   2cffa:	2868      	cmp	r0, #104	; 0x68
   2cffc:	d1e8      	bne.n	2cfd0 <z_vprintk+0x66>
				if (*fmt == 'h' && length_mod == 'h') {
   2cffe:	f1b8 0f68 	cmp.w	r8, #104	; 0x68
   2d002:	d122      	bne.n	2d04a <z_vprintk+0xe0>
					length_mod = 'H';
   2d004:	f04f 0848 	mov.w	r8, #72	; 0x48
   2d008:	e7c8      	b.n	2cf9c <z_vprintk+0x32>
			switch (*fmt) {
   2d00a:	2875      	cmp	r0, #117	; 0x75
   2d00c:	d072      	beq.n	2d0f4 <z_vprintk+0x18a>
   2d00e:	d818      	bhi.n	2d042 <z_vprintk+0xd8>
   2d010:	2873      	cmp	r0, #115	; 0x73
   2d012:	d1dd      	bne.n	2cfd0 <z_vprintk+0x66>
				char *s = va_arg(ap, char *);
   2d014:	f854 5b04 	ldr.w	r5, [r4], #4
				while (*s) {
   2d018:	46ab      	mov	fp, r5
   2d01a:	465b      	mov	r3, fp
   2d01c:	f81b 0b01 	ldrb.w	r0, [fp], #1
   2d020:	2800      	cmp	r0, #0
   2d022:	f040 80fc 	bne.w	2d21e <z_vprintk+0x2b4>
				if (padding == PAD_SPACE_AFTER) {
   2d026:	f1b9 0f03 	cmp.w	r9, #3
   2d02a:	f040 810c 	bne.w	2d246 <z_vprintk+0x2dc>
					int remaining = min_width - (s - start);
   2d02e:	1b5d      	subs	r5, r3, r5
   2d030:	ebaa 0505 	sub.w	r5, sl, r5
					while (remaining-- > 0) {
   2d034:	2d00      	cmp	r5, #0
   2d036:	dd49      	ble.n	2d0cc <z_vprintk+0x162>
						out(' ', ctx);
   2d038:	4639      	mov	r1, r7
   2d03a:	2020      	movs	r0, #32
   2d03c:	47b0      	blx	r6
   2d03e:	3d01      	subs	r5, #1
   2d040:	e7f8      	b.n	2d034 <z_vprintk+0xca>
			switch (*fmt) {
   2d042:	2878      	cmp	r0, #120	; 0x78
   2d044:	d07c      	beq.n	2d140 <z_vprintk+0x1d6>
   2d046:	287a      	cmp	r0, #122	; 0x7a
   2d048:	d1c2      	bne.n	2cfd0 <z_vprintk+0x66>
				} else if (length_mod == 0) {
   2d04a:	f1b8 0f00 	cmp.w	r8, #0
   2d04e:	d1bf      	bne.n	2cfd0 <z_vprintk+0x66>
   2d050:	4680      	mov	r8, r0
   2d052:	e7a3      	b.n	2cf9c <z_vprintk+0x32>
				if (min_width < 0 && padding == PAD_NONE) {
   2d054:	f1ba 0f00 	cmp.w	sl, #0
   2d058:	da0e      	bge.n	2d078 <z_vprintk+0x10e>
   2d05a:	f1b9 0f00 	cmp.w	r9, #0
   2d05e:	f000 80ef 	beq.w	2d240 <z_vprintk+0x2d6>
					min_width = *fmt - '0';
   2d062:	f1a0 0a30 	sub.w	sl, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
   2d066:	f1b9 0f00 	cmp.w	r9, #0
   2d06a:	bf08      	it	eq
   2d06c:	f04f 0902 	moveq.w	r9, #2
   2d070:	e794      	b.n	2cf9c <z_vprintk+0x32>
				if (min_width < 0) {
   2d072:	f1ba 0f00 	cmp.w	sl, #0
   2d076:	dbf4      	blt.n	2d062 <z_vprintk+0xf8>
					min_width = 10 * min_width + *fmt - '0';
   2d078:	230a      	movs	r3, #10
   2d07a:	fb03 0a0a 	mla	sl, r3, sl, r0
   2d07e:	f1aa 0a30 	sub.w	sl, sl, #48	; 0x30
   2d082:	e7f0      	b.n	2d066 <z_vprintk+0xfc>
				if (length_mod == 'z') {
   2d084:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
   2d088:	d102      	bne.n	2d090 <z_vprintk+0x126>
					d = va_arg(ap, int);
   2d08a:	f854 5b04 	ldr.w	r5, [r4], #4
   2d08e:	e020      	b.n	2d0d2 <z_vprintk+0x168>
				} else if (length_mod == 'l') {
   2d090:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   2d094:	d0f9      	beq.n	2d08a <z_vprintk+0x120>
				} else if (length_mod == 'L') {
   2d096:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   2d09a:	d1f6      	bne.n	2d08a <z_vprintk+0x120>
					long long lld = va_arg(ap, long long);
   2d09c:	3407      	adds	r4, #7
   2d09e:	f024 0407 	bic.w	r4, r4, #7
   2d0a2:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (lld > __LONG_MAX__ ||
   2d0a6:	f112 4100 	adds.w	r1, r2, #2147483648	; 0x80000000
   2d0aa:	9106      	str	r1, [sp, #24]
   2d0ac:	f143 0100 	adc.w	r1, r3, #0
   2d0b0:	9107      	str	r1, [sp, #28]
   2d0b2:	2100      	movs	r1, #0
   2d0b4:	e9dd bc06 	ldrd	fp, ip, [sp, #24]
   2d0b8:	f04f 30ff 	mov.w	r0, #4294967295
   2d0bc:	4561      	cmp	r1, ip
   2d0be:	bf08      	it	eq
   2d0c0:	4558      	cmpeq	r0, fp
   2d0c2:	d205      	bcs.n	2d0d0 <z_vprintk+0x166>
						print_err(out, ctx);
   2d0c4:	4639      	mov	r1, r7
   2d0c6:	4630      	mov	r0, r6
   2d0c8:	f7ff ff41 	bl	2cf4e <print_err>
			might_format = 0;
   2d0cc:	2500      	movs	r5, #0
				break;
   2d0ce:	e765      	b.n	2cf9c <z_vprintk+0x32>
					d = lld;
   2d0d0:	4615      	mov	r5, r2
				if (d < 0) {
   2d0d2:	2d00      	cmp	r5, #0
   2d0d4:	da05      	bge.n	2d0e2 <z_vprintk+0x178>
					out((int)'-', ctx);
   2d0d6:	4639      	mov	r1, r7
   2d0d8:	202d      	movs	r0, #45	; 0x2d
   2d0da:	47b0      	blx	r6
					d = -d;
   2d0dc:	426d      	negs	r5, r5
					min_width--;
   2d0de:	f10a 3aff 	add.w	sl, sl, #4294967295
				_printk_dec_ulong(out, ctx, d, padding,
   2d0e2:	464b      	mov	r3, r9
   2d0e4:	462a      	mov	r2, r5
   2d0e6:	f8cd a000 	str.w	sl, [sp]
				_printk_dec_ulong(out, ctx, u, padding,
   2d0ea:	4639      	mov	r1, r7
   2d0ec:	4630      	mov	r0, r6
   2d0ee:	f7ea fb41 	bl	17774 <_printk_dec_ulong>
				break;
   2d0f2:	e7eb      	b.n	2d0cc <z_vprintk+0x162>
				if (length_mod == 'z') {
   2d0f4:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
   2d0f8:	d102      	bne.n	2d100 <z_vprintk+0x196>
					u = va_arg(ap, unsigned int);
   2d0fa:	f854 2b04 	ldr.w	r2, [r4], #4
   2d0fe:	e011      	b.n	2d124 <z_vprintk+0x1ba>
				} else if (length_mod == 'l') {
   2d100:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   2d104:	d0f9      	beq.n	2d0fa <z_vprintk+0x190>
				} else if (length_mod == 'L') {
   2d106:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   2d10a:	d1f6      	bne.n	2d0fa <z_vprintk+0x190>
					if (llu > ~0UL) {
   2d10c:	2100      	movs	r1, #0
   2d10e:	f04f 30ff 	mov.w	r0, #4294967295
					unsigned long long llu =
   2d112:	3407      	adds	r4, #7
   2d114:	f024 0407 	bic.w	r4, r4, #7
   2d118:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > ~0UL) {
   2d11c:	4299      	cmp	r1, r3
   2d11e:	bf08      	it	eq
   2d120:	4290      	cmpeq	r0, r2
   2d122:	d3cf      	bcc.n	2d0c4 <z_vprintk+0x15a>
				_printk_dec_ulong(out, ctx, u, padding,
   2d124:	f8cd a000 	str.w	sl, [sp]
   2d128:	464b      	mov	r3, r9
   2d12a:	e7de      	b.n	2d0ea <z_vprintk+0x180>
				out('0', ctx);
   2d12c:	4639      	mov	r1, r7
   2d12e:	2030      	movs	r0, #48	; 0x30
   2d130:	47b0      	blx	r6
				out('x', ctx);
   2d132:	4639      	mov	r1, r7
   2d134:	2078      	movs	r0, #120	; 0x78
   2d136:	47b0      	blx	r6
					min_width = 8;
   2d138:	f04f 0a08 	mov.w	sl, #8
				padding = PAD_ZERO_BEFORE;
   2d13c:	f04f 0901 	mov.w	r9, #1
				if (*fmt == 'p') {
   2d140:	9b02      	ldr	r3, [sp, #8]
   2d142:	781b      	ldrb	r3, [r3, #0]
   2d144:	2b70      	cmp	r3, #112	; 0x70
   2d146:	d104      	bne.n	2d152 <z_vprintk+0x1e8>
					x = va_arg(ap, unsigned int);
   2d148:	f854 3b04 	ldr.w	r3, [r4], #4
   2d14c:	9304      	str	r3, [sp, #16]
   2d14e:	2300      	movs	r3, #0
   2d150:	e00d      	b.n	2d16e <z_vprintk+0x204>
				} else if (length_mod == 'l') {
   2d152:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   2d156:	d0f7      	beq.n	2d148 <z_vprintk+0x1de>
				} else if (length_mod == 'L') {
   2d158:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   2d15c:	d1f4      	bne.n	2d148 <z_vprintk+0x1de>
					x = va_arg(ap, unsigned long long);
   2d15e:	3407      	adds	r4, #7
   2d160:	f024 0307 	bic.w	r3, r4, #7
   2d164:	461c      	mov	r4, r3
   2d166:	f854 2b08 	ldr.w	r2, [r4], #8
   2d16a:	685b      	ldr	r3, [r3, #4]
   2d16c:	9204      	str	r2, [sp, #16]
	int digits = 0;
   2d16e:	2100      	movs	r1, #0
	int remaining = 16; /* 16 digits max */
   2d170:	2210      	movs	r2, #16
	int shift = sizeof(num) * 8;
   2d172:	f04f 0b40 	mov.w	fp, #64	; 0x40
	int digits = 0;
   2d176:	9103      	str	r1, [sp, #12]
	int found_largest_digit = 0;
   2d178:	9105      	str	r1, [sp, #20]
		shift -= 4;
   2d17a:	f1ab 0b04 	sub.w	fp, fp, #4
		nibble = (num >> shift) & 0xf;
   2d17e:	9804      	ldr	r0, [sp, #16]
   2d180:	f1cb 0c20 	rsb	ip, fp, #32
   2d184:	f1ab 0120 	sub.w	r1, fp, #32
   2d188:	fa20 f00b 	lsr.w	r0, r0, fp
   2d18c:	fa03 fc0c 	lsl.w	ip, r3, ip
   2d190:	ea40 000c 	orr.w	r0, r0, ip
   2d194:	fa23 f101 	lsr.w	r1, r3, r1
   2d198:	4308      	orrs	r0, r1
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
   2d19a:	f010 000f 	ands.w	r0, r0, #15
   2d19e:	d106      	bne.n	2d1ae <z_vprintk+0x244>
   2d1a0:	9905      	ldr	r1, [sp, #20]
   2d1a2:	b911      	cbnz	r1, 2d1aa <z_vprintk+0x240>
   2d1a4:	f1bb 0f00 	cmp.w	fp, #0
   2d1a8:	d122      	bne.n	2d1f0 <z_vprintk+0x286>
			nibble += nibble > 9 ? 87 : 48;
   2d1aa:	2130      	movs	r1, #48	; 0x30
   2d1ac:	e003      	b.n	2d1b6 <z_vprintk+0x24c>
   2d1ae:	2809      	cmp	r0, #9
   2d1b0:	bf8c      	ite	hi
   2d1b2:	2157      	movhi	r1, #87	; 0x57
   2d1b4:	2130      	movls	r1, #48	; 0x30
   2d1b6:	4408      	add	r0, r1
			out((int)nibble, ctx);
   2d1b8:	b240      	sxtb	r0, r0
   2d1ba:	4639      	mov	r1, r7
   2d1bc:	9308      	str	r3, [sp, #32]
   2d1be:	9205      	str	r2, [sp, #20]
   2d1c0:	47b0      	blx	r6
			digits++;
   2d1c2:	9b03      	ldr	r3, [sp, #12]
	while (shift >= 4) {
   2d1c4:	9a05      	ldr	r2, [sp, #20]
			digits++;
   2d1c6:	3301      	adds	r3, #1
   2d1c8:	9303      	str	r3, [sp, #12]
	while (shift >= 4) {
   2d1ca:	9b08      	ldr	r3, [sp, #32]
   2d1cc:	f1bb 0f00 	cmp.w	fp, #0
   2d1d0:	d123      	bne.n	2d21a <z_vprintk+0x2b0>
	if (padding == PAD_SPACE_AFTER) {
   2d1d2:	f1b9 0f03 	cmp.w	r9, #3
   2d1d6:	f47f af79 	bne.w	2d0cc <z_vprintk+0x162>
		remaining = min_width * 2 - digits;
   2d1da:	9b03      	ldr	r3, [sp, #12]
   2d1dc:	ebc3 054a 	rsb	r5, r3, sl, lsl #1
		while (remaining-- > 0) {
   2d1e0:	2d00      	cmp	r5, #0
   2d1e2:	f77f af73 	ble.w	2d0cc <z_vprintk+0x162>
			out(' ', ctx);
   2d1e6:	4639      	mov	r1, r7
   2d1e8:	2020      	movs	r0, #32
   2d1ea:	47b0      	blx	r6
   2d1ec:	3d01      	subs	r5, #1
   2d1ee:	e7f7      	b.n	2d1e0 <z_vprintk+0x276>
		if (remaining-- <= min_width) {
   2d1f0:	1e51      	subs	r1, r2, #1
   2d1f2:	4592      	cmp	sl, r2
   2d1f4:	9108      	str	r1, [sp, #32]
   2d1f6:	db07      	blt.n	2d208 <z_vprintk+0x29e>
			if (padding == PAD_ZERO_BEFORE) {
   2d1f8:	f1b9 0f01 	cmp.w	r9, #1
   2d1fc:	d106      	bne.n	2d20c <z_vprintk+0x2a2>
				out('0', ctx);
   2d1fe:	4639      	mov	r1, r7
   2d200:	2030      	movs	r0, #48	; 0x30
   2d202:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
   2d204:	47b0      	blx	r6
   2d206:	9b09      	ldr	r3, [sp, #36]	; 0x24
			nibble += nibble > 9 ? 87 : 48;
   2d208:	9a08      	ldr	r2, [sp, #32]
   2d20a:	e7b6      	b.n	2d17a <z_vprintk+0x210>
			} else if (padding == PAD_SPACE_BEFORE) {
   2d20c:	f1b9 0f02 	cmp.w	r9, #2
   2d210:	d1fa      	bne.n	2d208 <z_vprintk+0x29e>
   2d212:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
   2d214:	4639      	mov	r1, r7
   2d216:	2020      	movs	r0, #32
   2d218:	e7f4      	b.n	2d204 <z_vprintk+0x29a>
			found_largest_digit = 1;
   2d21a:	9505      	str	r5, [sp, #20]
   2d21c:	e7ad      	b.n	2d17a <z_vprintk+0x210>
					out((int)(*s++), ctx);
   2d21e:	4639      	mov	r1, r7
   2d220:	47b0      	blx	r6
   2d222:	e6fa      	b.n	2d01a <z_vprintk+0xb0>
				out(c, ctx);
   2d224:	4639      	mov	r1, r7
   2d226:	f854 0b04 	ldr.w	r0, [r4], #4
				out((int)'%', ctx);
   2d22a:	47b0      	blx	r6
   2d22c:	e74e      	b.n	2d0cc <z_vprintk+0x162>
				length_mod = 0;
   2d22e:	46a8      	mov	r8, r5
				padding = PAD_NONE;
   2d230:	46a9      	mov	r9, r5
				min_width = -1;
   2d232:	f04f 3aff 	mov.w	sl, #4294967295
				might_format = 1;
   2d236:	2501      	movs	r5, #1
   2d238:	e6b0      	b.n	2cf9c <z_vprintk+0x32>
				padding = PAD_SPACE_AFTER;
   2d23a:	f04f 0903 	mov.w	r9, #3
   2d23e:	e6ad      	b.n	2cf9c <z_vprintk+0x32>
					padding = PAD_ZERO_BEFORE;
   2d240:	f04f 0901 	mov.w	r9, #1
   2d244:	e6aa      	b.n	2cf9c <z_vprintk+0x32>
			might_format = 0;
   2d246:	4605      	mov	r5, r0
   2d248:	e6a8      	b.n	2cf9c <z_vprintk+0x32>

0002d24a <printk>:
{
   2d24a:	b40f      	push	{r0, r1, r2, r3}
   2d24c:	b507      	push	{r0, r1, r2, lr}
   2d24e:	a904      	add	r1, sp, #16
   2d250:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   2d254:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
   2d256:	f7ea fad9 	bl	1780c <vprintk>
}
   2d25a:	b003      	add	sp, #12
   2d25c:	f85d eb04 	ldr.w	lr, [sp], #4
   2d260:	b004      	add	sp, #16
   2d262:	4770      	bx	lr

0002d264 <sys_sem_give>:

	return 0;
}

int sys_sem_give(struct sys_sem *sem)
{
   2d264:	b508      	push	{r3, lr}
	z_impl_k_sem_give(sem);
   2d266:	f7fb f941 	bl	284ec <z_impl_k_sem_give>
	k_sem_give(&sem->kernel_sem);

	return 0;
}
   2d26a:	2000      	movs	r0, #0
   2d26c:	bd08      	pop	{r3, pc}

0002d26e <sys_sem_take>:

int sys_sem_take(struct sys_sem *sem, s32_t timeout)
{
   2d26e:	b508      	push	{r3, lr}
	return z_impl_k_sem_take(sem, timeout);
   2d270:	f7fb f986 	bl	28580 <z_impl_k_sem_take>
	int ret_value = 0;

	ret_value = k_sem_take(&sem->kernel_sem, timeout);
	if (ret_value == -EAGAIN || ret_value == -EBUSY) {
   2d274:	f110 0f0b 	cmn.w	r0, #11
   2d278:	d005      	beq.n	2d286 <sys_sem_take+0x18>
   2d27a:	f110 0f10 	cmn.w	r0, #16
		ret_value = -ETIMEDOUT;
   2d27e:	bf08      	it	eq
   2d280:	f06f 0073 	mvneq.w	r0, #115	; 0x73
	}

	return ret_value;
}
   2d284:	bd08      	pop	{r3, pc}
		ret_value = -ETIMEDOUT;
   2d286:	f06f 0073 	mvn.w	r0, #115	; 0x73
	return ret_value;
   2d28a:	e7fb      	b.n	2d284 <sys_sem_take+0x16>

0002d28c <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   2d28c:	4604      	mov	r4, r0
   2d28e:	b508      	push	{r3, lr}
   2d290:	4608      	mov	r0, r1
   2d292:	4611      	mov	r1, r2
	entry(p1, p2, p3);
   2d294:	461a      	mov	r2, r3
   2d296:	47a0      	blx	r4
	return z_impl_k_current_get();
   2d298:	f7fb f922 	bl	284e0 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
   2d29c:	f7ec fb56 	bl	1994c <z_impl_k_thread_abort>

0002d2a0 <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
   2d2a0:	b510      	push	{r4, lr}
   2d2a2:	4604      	mov	r4, r0
	return z_impl_k_queue_get(queue, timeout);
   2d2a4:	f04f 31ff 	mov.w	r1, #4294967295
   2d2a8:	4620      	mov	r0, r4
   2d2aa:	f7f9 fe95 	bl	26fd8 <z_impl_k_queue_get>
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
   2d2ae:	4603      	mov	r3, r0
   2d2b0:	2800      	cmp	r0, #0
   2d2b2:	d0f7      	beq.n	2d2a4 <z_work_q_main+0x4>
			continue;
		}

		handler = work->handler;
   2d2b4:	6842      	ldr	r2, [r0, #4]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2d2b6:	3308      	adds	r3, #8
   2d2b8:	e8d3 1fef 	ldaex	r1, [r3]
   2d2bc:	f021 0c01 	bic.w	ip, r1, #1
   2d2c0:	e8c3 cfee 	stlex	lr, ip, [r3]
   2d2c4:	f1be 0f00 	cmp.w	lr, #0
   2d2c8:	d1f6      	bne.n	2d2b8 <z_work_q_main+0x18>

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
   2d2ca:	07cb      	lsls	r3, r1, #31
   2d2cc:	d500      	bpl.n	2d2d0 <z_work_q_main+0x30>
					      K_WORK_STATE_PENDING)) {
			handler(work);
   2d2ce:	4790      	blx	r2
	z_impl_k_yield();
   2d2d0:	f7fa ff88 	bl	281e4 <z_impl_k_yield>
   2d2d4:	e7e6      	b.n	2d2a4 <z_work_q_main+0x4>

0002d2d6 <assert_post_action>:
	if (_is_user_context()) {
		k_oops();
	}
#endif

	k_panic();
   2d2d6:	4040      	eors	r0, r0
   2d2d8:	f380 8811 	msr	BASEPRI, r0
   2d2dc:	f04f 0004 	mov.w	r0, #4
   2d2e0:	df02      	svc	2
}
   2d2e2:	4770      	bx	lr

0002d2e4 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_REBOOT, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   2d2e4:	4770      	bx	lr

0002d2e6 <z_platform_init>:

void z_platform_init(void)
{
	SystemInit();
   2d2e6:	f7f8 b9ed 	b.w	256c4 <SystemInit>

0002d2ea <log_backend_is_active>:
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
   2d2ea:	6843      	ldr	r3, [r0, #4]
}
   2d2ec:	7958      	ldrb	r0, [r3, #5]
   2d2ee:	4770      	bx	lr

0002d2f0 <k_cycle_get_32_wrapper>:
   2d2f0:	f7eb bce0 	b.w	18cb4 <z_timer_cycle_get_32>

0002d2f4 <dummy_timestamp>:
   2d2f4:	2000      	movs	r0, #0
   2d2f6:	4770      	bx	lr

0002d2f8 <log_string_sync>:
{
   2d2f8:	b40e      	push	{r1, r2, r3}
   2d2fa:	b503      	push	{r0, r1, lr}
   2d2fc:	aa03      	add	r2, sp, #12
   2d2fe:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(ap, fmt);
   2d302:	9201      	str	r2, [sp, #4]
	log_generic(src_level, fmt, ap);
   2d304:	f7ea faae 	bl	17864 <log_generic>
}
   2d308:	b002      	add	sp, #8
   2d30a:	f85d eb04 	ldr.w	lr, [sp], #4
   2d30e:	b003      	add	sp, #12
   2d310:	4770      	bx	lr

0002d312 <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
   2d312:	b508      	push	{r3, lr}
				K_THREAD_STACK_SIZEOF(logging_stack),
				log_process_thread_func, NULL, NULL, NULL,
				K_LOWEST_APPLICATION_THREAD_PRIO, 0, K_NO_WAIT);
		k_thread_name_set(&logging_thread, "logging");
	} else {
		log_init();
   2d314:	f7ea fb1c 	bl	17950 <log_init>
	}

	return 0;
}
   2d318:	2000      	movs	r0, #0
   2d31a:	bd08      	pop	{r3, pc}

0002d31c <log_strdup>:
}
   2d31c:	4770      	bx	lr

0002d31e <out_func>:
{
   2d31e:	b507      	push	{r0, r1, r2, lr}
		out_ctx->func((u8_t *)&c, 1, out_ctx->control_block->ctx);
   2d320:	e9d1 3200 	ldrd	r3, r2, [r1]
{
   2d324:	9001      	str	r0, [sp, #4]
		out_ctx->func((u8_t *)&c, 1, out_ctx->control_block->ctx);
   2d326:	6852      	ldr	r2, [r2, #4]
   2d328:	2101      	movs	r1, #1
   2d32a:	a801      	add	r0, sp, #4
   2d32c:	4798      	blx	r3
}
   2d32e:	2000      	movs	r0, #0
   2d330:	b003      	add	sp, #12
   2d332:	f85d fb04 	ldr.w	pc, [sp], #4

0002d336 <buffer_write>:
{
   2d336:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2d338:	4606      	mov	r6, r0
   2d33a:	460d      	mov	r5, r1
   2d33c:	4614      	mov	r4, r2
   2d33e:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
   2d340:	4621      	mov	r1, r4
   2d342:	4628      	mov	r0, r5
   2d344:	463a      	mov	r2, r7
   2d346:	47b0      	blx	r6
	} while (len != 0);
   2d348:	1a24      	subs	r4, r4, r0
		buf += processed;
   2d34a:	4405      	add	r5, r0
	} while (len != 0);
   2d34c:	d1f8      	bne.n	2d340 <buffer_write+0xa>
}
   2d34e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002d350 <log_output_flush>:
		     log_output->control_block->offset,
   2d350:	6842      	ldr	r2, [r0, #4]
{
   2d352:	b510      	push	{r4, lr}
	buffer_write(log_output->func, log_output->buf,
   2d354:	e9d2 2300 	ldrd	r2, r3, [r2]
{
   2d358:	4604      	mov	r4, r0
	buffer_write(log_output->func, log_output->buf,
   2d35a:	6881      	ldr	r1, [r0, #8]
   2d35c:	6800      	ldr	r0, [r0, #0]
   2d35e:	f7ff ffea 	bl	2d336 <buffer_write>
	log_output->control_block->offset = 0;
   2d362:	2200      	movs	r2, #0
   2d364:	6863      	ldr	r3, [r4, #4]
   2d366:	601a      	str	r2, [r3, #0]
}
   2d368:	bd10      	pop	{r4, pc}

0002d36a <flash_write_protection_set>:
	return api->write_protection(dev, enable);
   2d36a:	6843      	ldr	r3, [r0, #4]
   2d36c:	68db      	ldr	r3, [r3, #12]
   2d36e:	4718      	bx	r3

0002d370 <nvs_flash_rd>:
{
   2d370:	b470      	push	{r4, r5, r6}
	offset += addr & ADDR_OFFS_MASK;
   2d372:	6806      	ldr	r6, [r0, #0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   2d374:	8984      	ldrh	r4, [r0, #12]
   2d376:	0c0d      	lsrs	r5, r1, #16
	offset += addr & ADDR_OFFS_MASK;
   2d378:	fa16 f181 	uxtah	r1, r6, r1
   2d37c:	fb05 1104 	mla	r1, r5, r4, r1
	rc = flash_read(fs->flash_device, offset, data, len);
   2d380:	6a80      	ldr	r0, [r0, #40]	; 0x28
	return api->read(dev, offset, data, len);
   2d382:	6844      	ldr	r4, [r0, #4]
   2d384:	6824      	ldr	r4, [r4, #0]
   2d386:	46a4      	mov	ip, r4
}
   2d388:	bc70      	pop	{r4, r5, r6}
   2d38a:	4760      	bx	ip

0002d38c <nvs_flash_block_cmp>:
{
   2d38c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2d390:	4681      	mov	r9, r0
   2d392:	460f      	mov	r7, r1
   2d394:	4690      	mov	r8, r2
   2d396:	461c      	mov	r4, r3
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   2d398:	7c05      	ldrb	r5, [r0, #16]
{
   2d39a:	b089      	sub	sp, #36	; 0x24
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   2d39c:	426d      	negs	r5, r5
   2d39e:	f005 0520 	and.w	r5, r5, #32
	while (len) {
   2d3a2:	b91c      	cbnz	r4, 2d3ac <nvs_flash_block_cmp+0x20>
	return 0;
   2d3a4:	4620      	mov	r0, r4
}
   2d3a6:	b009      	add	sp, #36	; 0x24
   2d3a8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		bytes_to_cmp = MIN(block_size, len);
   2d3ac:	42ac      	cmp	r4, r5
   2d3ae:	4626      	mov	r6, r4
   2d3b0:	bf28      	it	cs
   2d3b2:	462e      	movcs	r6, r5
		rc = nvs_flash_rd(fs, addr, buf, bytes_to_cmp);
   2d3b4:	466a      	mov	r2, sp
   2d3b6:	4633      	mov	r3, r6
   2d3b8:	4639      	mov	r1, r7
   2d3ba:	4648      	mov	r0, r9
   2d3bc:	f7ff ffd8 	bl	2d370 <nvs_flash_rd>
		if (rc) {
   2d3c0:	2800      	cmp	r0, #0
   2d3c2:	d1f0      	bne.n	2d3a6 <nvs_flash_block_cmp+0x1a>
		rc = memcmp(data8, buf, bytes_to_cmp);
   2d3c4:	4632      	mov	r2, r6
   2d3c6:	4669      	mov	r1, sp
   2d3c8:	4640      	mov	r0, r8
   2d3ca:	f001 ffb5 	bl	2f338 <memcmp>
		if (rc) {
   2d3ce:	b918      	cbnz	r0, 2d3d8 <nvs_flash_block_cmp+0x4c>
		len -= bytes_to_cmp;
   2d3d0:	1ba4      	subs	r4, r4, r6
		addr += bytes_to_cmp;
   2d3d2:	4437      	add	r7, r6
		data8 += bytes_to_cmp;
   2d3d4:	44b0      	add	r8, r6
   2d3d6:	e7e4      	b.n	2d3a2 <nvs_flash_block_cmp+0x16>
			return 1;
   2d3d8:	2001      	movs	r0, #1
   2d3da:	e7e4      	b.n	2d3a6 <nvs_flash_block_cmp+0x1a>

0002d3dc <nvs_ate_crc8_check>:
{
   2d3dc:	b510      	push	{r4, lr}
   2d3de:	4604      	mov	r4, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   2d3e0:	4601      	mov	r1, r0
   2d3e2:	2207      	movs	r2, #7
   2d3e4:	20ff      	movs	r0, #255	; 0xff
   2d3e6:	f7ea f8d9 	bl	1759c <crc8_ccitt>
	if (crc8 == entry->crc8) {
   2d3ea:	79e3      	ldrb	r3, [r4, #7]
}
   2d3ec:	1a18      	subs	r0, r3, r0
   2d3ee:	bf18      	it	ne
   2d3f0:	2001      	movne	r0, #1
   2d3f2:	bd10      	pop	{r4, pc}

0002d3f4 <nvs_ate_crc8_update>:
{
   2d3f4:	b510      	push	{r4, lr}
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   2d3f6:	4601      	mov	r1, r0
{
   2d3f8:	4604      	mov	r4, r0
	crc8 = crc8_ccitt(0xff, entry, offsetof(struct nvs_ate, crc8));
   2d3fa:	2207      	movs	r2, #7
   2d3fc:	20ff      	movs	r0, #255	; 0xff
   2d3fe:	f7ea f8cd 	bl	1759c <crc8_ccitt>
	entry->crc8 = crc8;
   2d402:	71e0      	strb	r0, [r4, #7]
}
   2d404:	bd10      	pop	{r4, pc}

0002d406 <nvs_al_size.isra.1>:
	if (fs->write_block_size <= 1U) {
   2d406:	2801      	cmp	r0, #1
	return (len + (fs->write_block_size - 1U)) & ~(fs->write_block_size - 1U);
   2d408:	bf81      	itttt	hi
   2d40a:	f100 33ff 	addhi.w	r3, r0, #4294967295
   2d40e:	18c9      	addhi	r1, r1, r3
   2d410:	4240      	neghi	r0, r0
   2d412:	4001      	andhi	r1, r0
}
   2d414:	4608      	mov	r0, r1
   2d416:	4770      	bx	lr

0002d418 <nvs_sector_advance.isra.2>:
	*addr += (1 << ADDR_SECT_SHIFT);
   2d418:	680b      	ldr	r3, [r1, #0]
   2d41a:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
	if ((*addr >> ADDR_SECT_SHIFT) == fs->sector_count) {
   2d41e:	0c1a      	lsrs	r2, r3, #16
   2d420:	4282      	cmp	r2, r0
		*addr -= (fs->sector_count << ADDR_SECT_SHIFT);
   2d422:	bf08      	it	eq
   2d424:	eba3 4302 	subeq.w	r3, r3, r2, lsl #16
   2d428:	600b      	str	r3, [r1, #0]
}
   2d42a:	4770      	bx	lr

0002d42c <nvs_flash_cmp_const.constprop.5>:
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   2d42c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   2d430:	7c04      	ldrb	r4, [r0, #16]
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   2d432:	b088      	sub	sp, #32
	block_size = NVS_BLOCK_SIZE & ~(fs->write_block_size - 1U);
   2d434:	4264      	negs	r4, r4
   2d436:	f004 0420 	and.w	r4, r4, #32
static int nvs_flash_cmp_const(struct nvs_fs *fs, u32_t addr, u8_t value,
   2d43a:	4680      	mov	r8, r0
   2d43c:	460e      	mov	r6, r1
   2d43e:	4615      	mov	r5, r2
	(void)memset(cmp, value, block_size);
   2d440:	2320      	movs	r3, #32
   2d442:	4622      	mov	r2, r4
   2d444:	21ff      	movs	r1, #255	; 0xff
   2d446:	4668      	mov	r0, sp
   2d448:	f001 ffac 	bl	2f3a4 <__memset_chk>
	while (len) {
   2d44c:	b91d      	cbnz	r5, 2d456 <nvs_flash_cmp_const.constprop.5+0x2a>
	return 0;
   2d44e:	4628      	mov	r0, r5
}
   2d450:	b008      	add	sp, #32
   2d452:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		bytes_to_cmp = MIN(block_size, len);
   2d456:	42ac      	cmp	r4, r5
   2d458:	4627      	mov	r7, r4
   2d45a:	bf28      	it	cs
   2d45c:	462f      	movcs	r7, r5
		rc = nvs_flash_block_cmp(fs, addr, cmp, bytes_to_cmp);
   2d45e:	466a      	mov	r2, sp
   2d460:	463b      	mov	r3, r7
   2d462:	4631      	mov	r1, r6
   2d464:	4640      	mov	r0, r8
   2d466:	f7ff ff91 	bl	2d38c <nvs_flash_block_cmp>
		if (rc) {
   2d46a:	2800      	cmp	r0, #0
   2d46c:	d1f0      	bne.n	2d450 <nvs_flash_cmp_const.constprop.5+0x24>
		len -= bytes_to_cmp;
   2d46e:	1bed      	subs	r5, r5, r7
		addr += bytes_to_cmp;
   2d470:	443e      	add	r6, r7
   2d472:	e7eb      	b.n	2d44c <nvs_flash_cmp_const.constprop.5+0x20>

0002d474 <nvs_flash_al_wrt.part.3>:
static int nvs_flash_al_wrt(struct nvs_fs *fs, u32_t addr, const void *data,
   2d474:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2d478:	4607      	mov	r7, r0
   2d47a:	b088      	sub	sp, #32
   2d47c:	460d      	mov	r5, r1
	offset = fs->offset;
   2d47e:	f8d0 a000 	ldr.w	sl, [r0]
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   2d482:	8986      	ldrh	r6, [r0, #12]
	rc = flash_write_protection_set(fs->flash_device, 0);
   2d484:	2100      	movs	r1, #0
   2d486:	6a80      	ldr	r0, [r0, #40]	; 0x28
static int nvs_flash_al_wrt(struct nvs_fs *fs, u32_t addr, const void *data,
   2d488:	4690      	mov	r8, r2
   2d48a:	461c      	mov	r4, r3
	rc = flash_write_protection_set(fs->flash_device, 0);
   2d48c:	f7ff ff6d 	bl	2d36a <flash_write_protection_set>
	if (rc) {
   2d490:	bb88      	cbnz	r0, 2d4f6 <nvs_flash_al_wrt.part.3+0x82>
	offset += fs->sector_size * (addr >> ADDR_SECT_SHIFT);
   2d492:	ea4f 4915 	mov.w	r9, r5, lsr #16
	offset += addr & ADDR_OFFS_MASK;
   2d496:	fa1a f585 	uxtah	r5, sl, r5
   2d49a:	fb06 5909 	mla	r9, r6, r9, r5
	blen = len & ~(fs->write_block_size - 1U);
   2d49e:	7c3d      	ldrb	r5, [r7, #16]
   2d4a0:	426d      	negs	r5, r5
	if (blen > 0) {
   2d4a2:	4025      	ands	r5, r4
   2d4a4:	d00b      	beq.n	2d4be <nvs_flash_al_wrt.part.3+0x4a>
   2d4a6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
	return api->write(dev, offset, data, len);
   2d4a8:	6843      	ldr	r3, [r0, #4]
   2d4aa:	4642      	mov	r2, r8
   2d4ac:	685e      	ldr	r6, [r3, #4]
   2d4ae:	4649      	mov	r1, r9
   2d4b0:	462b      	mov	r3, r5
   2d4b2:	47b0      	blx	r6
		if (rc) {
   2d4b4:	4606      	mov	r6, r0
   2d4b6:	b9c8      	cbnz	r0, 2d4ec <nvs_flash_al_wrt.part.3+0x78>
		len -= blen;
   2d4b8:	1b64      	subs	r4, r4, r5
		offset += blen;
   2d4ba:	44a9      	add	r9, r5
		data8 += blen;
   2d4bc:	44a8      	add	r8, r5
	if (len) {
   2d4be:	b1ec      	cbz	r4, 2d4fc <nvs_flash_al_wrt.part.3+0x88>
		memcpy(buf, data8, len);
   2d4c0:	2320      	movs	r3, #32
   2d4c2:	4622      	mov	r2, r4
   2d4c4:	4641      	mov	r1, r8
   2d4c6:	4668      	mov	r0, sp
   2d4c8:	6abd      	ldr	r5, [r7, #40]	; 0x28
   2d4ca:	f001 ff50 	bl	2f36e <__memcpy_chk>
		(void)memset(buf + len, 0xff, fs->write_block_size - len);
   2d4ce:	7c3e      	ldrb	r6, [r7, #16]
__ssp_bos_icheck3(memset, void *, int)
   2d4d0:	21ff      	movs	r1, #255	; 0xff
   2d4d2:	1b32      	subs	r2, r6, r4
   2d4d4:	eb0d 0004 	add.w	r0, sp, r4
   2d4d8:	f001 ff5c 	bl	2f394 <memset>
   2d4dc:	686b      	ldr	r3, [r5, #4]
   2d4de:	466a      	mov	r2, sp
   2d4e0:	685c      	ldr	r4, [r3, #4]
   2d4e2:	4649      	mov	r1, r9
   2d4e4:	4633      	mov	r3, r6
   2d4e6:	4628      	mov	r0, r5
   2d4e8:	47a0      	blx	r4
   2d4ea:	4606      	mov	r6, r0
	(void) flash_write_protection_set(fs->flash_device, 1);
   2d4ec:	2101      	movs	r1, #1
   2d4ee:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   2d4f0:	f7ff ff3b 	bl	2d36a <flash_write_protection_set>
	return rc;
   2d4f4:	4630      	mov	r0, r6
}
   2d4f6:	b008      	add	sp, #32
   2d4f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
   2d4fc:	4626      	mov	r6, r4
   2d4fe:	e7f5      	b.n	2d4ec <nvs_flash_al_wrt.part.3+0x78>

0002d500 <nvs_flash_ate_wrt>:
{
   2d500:	b510      	push	{r4, lr}
   2d502:	2308      	movs	r3, #8
   2d504:	460a      	mov	r2, r1
   2d506:	6841      	ldr	r1, [r0, #4]
   2d508:	4604      	mov	r4, r0
   2d50a:	f7ff ffb3 	bl	2d474 <nvs_flash_al_wrt.part.3>
	fs->ate_wra -= nvs_al_size(fs, sizeof(struct nvs_ate));
   2d50e:	2108      	movs	r1, #8
   2d510:	4602      	mov	r2, r0
   2d512:	7c20      	ldrb	r0, [r4, #16]
   2d514:	f7ff ff77 	bl	2d406 <nvs_al_size.isra.1>
   2d518:	6863      	ldr	r3, [r4, #4]
   2d51a:	1a18      	subs	r0, r3, r0
   2d51c:	6060      	str	r0, [r4, #4]
}
   2d51e:	4610      	mov	r0, r2
   2d520:	bd10      	pop	{r4, pc}

0002d522 <nvs_read>:

ssize_t nvs_read(struct nvs_fs *fs, u16_t id, void *data, size_t len)
{
   2d522:	b513      	push	{r0, r1, r4, lr}
	int rc;

	rc = nvs_read_hist(fs, id, data, len, 0);
   2d524:	2400      	movs	r4, #0
   2d526:	9400      	str	r4, [sp, #0]
   2d528:	f7eb f84e 	bl	185c8 <nvs_read_hist>
	return rc;
}
   2d52c:	b002      	add	sp, #8
   2d52e:	bd10      	pop	{r4, pc}

0002d530 <clkstarted_handle>:
{
   2d530:	b538      	push	{r3, r4, r5, lr}
	sub_data->started = true;
   2d532:	240c      	movs	r4, #12
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
   2d534:	6883      	ldr	r3, [r0, #8]
{
   2d536:	4605      	mov	r5, r0
	sub_data->started = true;
   2d538:	fb04 3401 	mla	r4, r4, r1, r3
   2d53c:	2301      	movs	r3, #1
   2d53e:	7263      	strb	r3, [r4, #9]
	__asm__ volatile(
   2d540:	f04f 0320 	mov.w	r3, #32
   2d544:	f3ef 8111 	mrs	r1, BASEPRI
   2d548:	f383 8811 	msr	BASEPRI, r3
   2d54c:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
   2d550:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_GET(slist, snode)
   2d552:	b12b      	cbz	r3, 2d560 <clkstarted_handle+0x30>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2d554:	6860      	ldr	r0, [r4, #4]
   2d556:	681a      	ldr	r2, [r3, #0]
   2d558:	4283      	cmp	r3, r0
	list->head = node;
   2d55a:	6022      	str	r2, [r4, #0]
	list->tail = node;
   2d55c:	bf08      	it	eq
   2d55e:	6062      	streq	r2, [r4, #4]
	__asm__ volatile(
   2d560:	f381 8811 	msr	BASEPRI, r1
   2d564:	f3bf 8f6f 	isb	sy
	while ((async_data = list_get(&sub_data->list)) != NULL) {
   2d568:	b903      	cbnz	r3, 2d56c <clkstarted_handle+0x3c>
}
   2d56a:	bd38      	pop	{r3, r4, r5, pc}
		async_data->cb(dev, async_data->user_data);
   2d56c:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
   2d570:	4628      	mov	r0, r5
   2d572:	4790      	blx	r2
   2d574:	e7e4      	b.n	2d540 <clkstarted_handle+0x10>

0002d576 <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
   2d576:	2200      	movs	r2, #0
   2d578:	f7eb b8f2 	b.w	18760 <clock_async_start>

0002d57c <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
   2d57c:	4770      	bx	lr

0002d57e <SEGGER_RTT_Init>:
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
  _DoInit();
   2d57e:	f7eb bbeb 	b.w	18d58 <_DoInit>

0002d582 <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(struct device *unused)
{
   2d582:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
   2d584:	f7ff fffb 	bl	2d57e <SEGGER_RTT_Init>

	return 0;
}
   2d588:	2000      	movs	r0, #0
   2d58a:	bd08      	pop	{r3, pc}

0002d58c <z_irq_spurious>:
	z_arm_reserved();
   2d58c:	f7eb bcf6 	b.w	18f7c <z_arm_bus_fault>

0002d590 <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   2d590:	6d83      	ldr	r3, [r0, #88]	; 0x58
   2d592:	f383 880b 	msr	PSPLIM, r3
}
   2d596:	4770      	bx	lr

0002d598 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   2d598:	4601      	mov	r1, r0
			reason = K_ERR_KERNEL_OOPS;
		}
	}

#endif /* CONFIG_USERSPACE */
	z_arm_fatal_error(reason, esf);
   2d59a:	6800      	ldr	r0, [r0, #0]
   2d59c:	f7eb be04 	b.w	191a8 <z_arm_fatal_error>

0002d5a0 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   2d5a0:	b508      	push	{r3, lr}
	handler();
   2d5a2:	f7eb fcf5 	bl	18f90 <z_SysNmiOnReset>
	z_arm_exc_exit();
}
   2d5a6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_exc_exit();
   2d5aa:	f7eb bc5b 	b.w	18e64 <z_arm_exc_exit>

0002d5ae <z_arm_configure_dynamic_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_dynamic_mpu_regions(struct k_thread *thread)
{
   2d5ae:	b507      	push	{r0, r1, r2, lr}

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(
   2d5b0:	2100      	movs	r1, #0
   2d5b2:	a801      	add	r0, sp, #4
   2d5b4:	f7ec fc28 	bl	19e08 <arm_core_mpu_configure_dynamic_mpu_regions>
		(const struct k_mem_partition **)dynamic_regions,
		region_num);
}
   2d5b8:	b003      	add	sp, #12
   2d5ba:	f85d fb04 	ldr.w	pc, [sp], #4

0002d5be <mpu_configure_region>:
{
   2d5be:	b530      	push	{r4, r5, lr}
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
   2d5c0:	684b      	ldr	r3, [r1, #4]
{
   2d5c2:	b085      	sub	sp, #20
	region_conf.base = new_region->start;
   2d5c4:	680c      	ldr	r4, [r1, #0]
	p_attr->rbar = attr->rbar &
   2d5c6:	f89d 2008 	ldrb.w	r2, [sp, #8]
   2d5ca:	890d      	ldrh	r5, [r1, #8]
   2d5cc:	9400      	str	r4, [sp, #0]
	p_attr->mair_idx = attr->mair_idx;
   2d5ce:	8949      	ldrh	r1, [r1, #10]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   2d5d0:	f024 041f 	bic.w	r4, r4, #31
   2d5d4:	3b01      	subs	r3, #1
	p_attr->rbar = attr->rbar &
   2d5d6:	f365 0204 	bfi	r2, r5, #0, #5
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   2d5da:	4423      	add	r3, r4
	p_attr->mair_idx = attr->mair_idx;
   2d5dc:	f361 1247 	bfi	r2, r1, #5, #3
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   2d5e0:	f023 031f 	bic.w	r3, r3, #31
	return region_allocate_and_init(index,
   2d5e4:	4669      	mov	r1, sp
	p_attr->mair_idx = attr->mair_idx;
   2d5e6:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   2d5ea:	9303      	str	r3, [sp, #12]
   2d5ec:	f7ec fa2e 	bl	19a4c <region_allocate_and_init>
}
   2d5f0:	b005      	add	sp, #20
   2d5f2:	bd30      	pop	{r4, r5, pc}

0002d5f4 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   2d5f4:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(u32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
   2d5f8:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   2d5fc:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
   2d5fe:	bf08      	it	eq
   2d600:	f06f 0015 	mvneq.w	r0, #21
   2d604:	4770      	bx	lr

0002d606 <_stdout_hook_default>:
}
   2d606:	f04f 30ff 	mov.w	r0, #4294967295
   2d60a:	4770      	bx	lr

0002d60c <_stdin_hook_default>:
}
   2d60c:	2000      	movs	r0, #0
   2d60e:	4770      	bx	lr

0002d610 <_read>:
{
   2d610:	4608      	mov	r0, r1
	return z_impl_zephyr_read_stdin(buf, nbytes);
   2d612:	4611      	mov	r1, r2
   2d614:	f7ec bc34 	b.w	19e80 <z_impl_zephyr_read_stdin>

0002d618 <_write>:
{
   2d618:	4608      	mov	r0, r1
	return z_impl_zephyr_write_stdout(buf, nbytes);
   2d61a:	4611      	mov	r1, r2
   2d61c:	f7ec bc44 	b.w	19ea8 <z_impl_zephyr_write_stdout>

0002d620 <_close>:
   2d620:	f04f 30ff 	mov.w	r0, #4294967295
   2d624:	4770      	bx	lr

0002d626 <_lseek>:
}
   2d626:	2000      	movs	r0, #0
   2d628:	4770      	bx	lr

0002d62a <_isatty>:
}
   2d62a:	2001      	movs	r0, #1
   2d62c:	4770      	bx	lr

0002d62e <_kill>:
}
   2d62e:	2000      	movs	r0, #0
   2d630:	4770      	bx	lr

0002d632 <_getpid>:
}
   2d632:	2000      	movs	r0, #0
   2d634:	4770      	bx	lr

0002d636 <_fstat>:
	st->st_mode = S_IFCHR;
   2d636:	f44f 5300 	mov.w	r3, #8192	; 0x2000
}
   2d63a:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
   2d63c:	604b      	str	r3, [r1, #4]
}
   2d63e:	4770      	bx	lr

0002d640 <__errno>:
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
   2d640:	f7f8 bde8 	b.w	26214 <z_impl_z_errno>

0002d644 <net_init>:

	return status;
}

static int net_init(struct device *unused)
{
   2d644:	b508      	push	{r3, lr}
	net_if_init();
   2d646:	f7ec fcf7 	bl	1a038 <net_if_init>
	net_if_post_init();
   2d64a:	f7ec fd09 	bl	1a060 <net_if_post_init>
	net_mgmt_event_init();

	init_rx_queues();

	return services_init();
}
   2d64e:	2000      	movs	r0, #0
   2d650:	bd08      	pop	{r3, pc}

0002d652 <net_if_l2>:
	if (!iface || !iface->if_dev) {
   2d652:	b110      	cbz	r0, 2d65a <net_if_l2+0x8>
   2d654:	6800      	ldr	r0, [r0, #0]
   2d656:	b100      	cbz	r0, 2d65a <net_if_l2+0x8>
	return iface->if_dev->l2;
   2d658:	6840      	ldr	r0, [r0, #4]
}
   2d65a:	4770      	bx	lr

0002d65c <l2_flags_get>:
{
   2d65c:	b510      	push	{r4, lr}
   2d65e:	4602      	mov	r2, r0
	if (net_if_l2(iface) && net_if_l2(iface)->get_flags) {
   2d660:	f7ff fff7 	bl	2d652 <net_if_l2>
   2d664:	b128      	cbz	r0, 2d672 <l2_flags_get+0x16>
   2d666:	68c3      	ldr	r3, [r0, #12]
   2d668:	b11b      	cbz	r3, 2d672 <l2_flags_get+0x16>
}
   2d66a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		flags = net_if_l2(iface)->get_flags(iface);
   2d66e:	4610      	mov	r0, r2
   2d670:	4718      	bx	r3
}
   2d672:	2000      	movs	r0, #0
   2d674:	bd10      	pop	{r4, pc}

0002d676 <net_byte_to_hex>:
{
   2d676:	b570      	push	{r4, r5, r6, lr}
	for (i = 0, val = (byte & 0xf0) >> 4; i < 2; i++, val = byte & 0x0f) {
   2d678:	090e      	lsrs	r6, r1, #4
		if (i == 0 && !pad && !val) {
   2d67a:	b1b3      	cbz	r3, 2d6aa <net_byte_to_hex+0x34>
		if (val < 10) {
   2d67c:	2e09      	cmp	r6, #9
			*ptr++ = (char) (val - 10 + base);
   2d67e:	b274      	sxtb	r4, r6
   2d680:	bf86      	itte	hi
   2d682:	f1a2 030a 	subhi.w	r3, r2, #10
   2d686:	18e4      	addhi	r4, r4, r3
			*ptr++ = (char) (val + '0');
   2d688:	3430      	addls	r4, #48	; 0x30
   2d68a:	1c45      	adds	r5, r0, #1
   2d68c:	7004      	strb	r4, [r0, #0]
   2d68e:	f001 010f 	and.w	r1, r1, #15
		if (val < 10) {
   2d692:	2909      	cmp	r1, #9
			*ptr++ = (char) (val - 10 + base);
   2d694:	b24b      	sxtb	r3, r1
   2d696:	bf83      	ittte	hi
   2d698:	3a0a      	subhi	r2, #10
   2d69a:	189b      	addhi	r3, r3, r2
   2d69c:	b2db      	uxtbhi	r3, r3
			*ptr++ = (char) (val + '0');
   2d69e:	3330      	addls	r3, #48	; 0x30
   2d6a0:	702b      	strb	r3, [r5, #0]
	*ptr = '\0';
   2d6a2:	2300      	movs	r3, #0
   2d6a4:	706b      	strb	r3, [r5, #1]
   2d6a6:	1c68      	adds	r0, r5, #1
}
   2d6a8:	bd70      	pop	{r4, r5, r6, pc}
		if (i == 0 && !pad && !val) {
   2d6aa:	2e00      	cmp	r6, #0
   2d6ac:	d1e6      	bne.n	2d67c <net_byte_to_hex+0x6>
   2d6ae:	4605      	mov	r5, r0
   2d6b0:	e7ed      	b.n	2d68e <net_byte_to_hex+0x18>

0002d6b2 <unpack_uint16>:
 */
static int unpack_uint16(struct buf_ctx *buf, u16_t *val)
{
	MQTT_TRC(">> cur:%p, end:%p", buf->cur, buf->end);

	if ((buf->end - buf->cur) < sizeof(u16_t)) {
   2d6b2:	e9d0 2300 	ldrd	r2, r3, [r0]
   2d6b6:	1a9b      	subs	r3, r3, r2
   2d6b8:	2b01      	cmp	r3, #1
{
   2d6ba:	b510      	push	{r4, lr}
	if ((buf->end - buf->cur) < sizeof(u16_t)) {
   2d6bc:	d90c      	bls.n	2d6d8 <unpack_uint16+0x26>
		return -EINVAL;
	}

	*val = *(buf->cur++) << 8; /* MSB */
   2d6be:	4614      	mov	r4, r2
   2d6c0:	1c53      	adds	r3, r2, #1
   2d6c2:	6003      	str	r3, [r0, #0]
   2d6c4:	f814 3b02 	ldrb.w	r3, [r4], #2
   2d6c8:	021b      	lsls	r3, r3, #8
   2d6ca:	800b      	strh	r3, [r1, #0]
	*val |= *(buf->cur++); /* LSB */
   2d6cc:	6004      	str	r4, [r0, #0]

	MQTT_TRC("<< val:%04x", *val);

	return 0;
   2d6ce:	2000      	movs	r0, #0
	*val |= *(buf->cur++); /* LSB */
   2d6d0:	7852      	ldrb	r2, [r2, #1]
   2d6d2:	4313      	orrs	r3, r2
   2d6d4:	800b      	strh	r3, [r1, #0]
}
   2d6d6:	bd10      	pop	{r4, pc}
		return -EINVAL;
   2d6d8:	f06f 0015 	mvn.w	r0, #21
   2d6dc:	e7fb      	b.n	2d6d6 <unpack_uint16+0x24>

0002d6de <packet_length_decode>:
int packet_length_decode(struct buf_ctx *buf, u32_t *length)
{
	u8_t shift = 0U;
	u8_t bytes = 0U;

	*length = 0U;
   2d6de:	2300      	movs	r3, #0
{
   2d6e0:	b5f0      	push	{r4, r5, r6, r7, lr}
	do {
		if (bytes > MQTT_MAX_LENGTH_BYTES) {
			return -EINVAL;
		}

		if (buf->cur >= buf->end) {
   2d6e2:	6847      	ldr	r7, [r0, #4]
	*length = 0U;
   2d6e4:	600b      	str	r3, [r1, #0]
		if (buf->cur >= buf->end) {
   2d6e6:	6804      	ldr	r4, [r0, #0]
   2d6e8:	42bc      	cmp	r4, r7
   2d6ea:	d215      	bcs.n	2d718 <packet_length_decode+0x3a>
			return -EAGAIN;
		}

		*length += ((u32_t)*(buf->cur) & MQTT_LENGTH_VALUE_MASK)
   2d6ec:	4625      	mov	r5, r4
   2d6ee:	f815 2b01 	ldrb.w	r2, [r5], #1
   2d6f2:	680e      	ldr	r6, [r1, #0]
   2d6f4:	f002 027f 	and.w	r2, r2, #127	; 0x7f
								<< shift;
   2d6f8:	409a      	lsls	r2, r3
		*length += ((u32_t)*(buf->cur) & MQTT_LENGTH_VALUE_MASK)
   2d6fa:	4432      	add	r2, r6
   2d6fc:	600a      	str	r2, [r1, #0]
		shift += MQTT_LENGTH_SHIFT;
		bytes++;
	} while ((*(buf->cur++) & MQTT_LENGTH_CONTINUATION_BIT) != 0U);
   2d6fe:	6005      	str	r5, [r0, #0]
   2d700:	f994 2000 	ldrsb.w	r2, [r4]
   2d704:	2a00      	cmp	r2, #0
   2d706:	db01      	blt.n	2d70c <packet_length_decode+0x2e>

	MQTT_TRC("length:0x%08x", *length);

	return 0;
   2d708:	2000      	movs	r0, #0
}
   2d70a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (bytes > MQTT_MAX_LENGTH_BYTES) {
   2d70c:	3307      	adds	r3, #7
   2d70e:	2b23      	cmp	r3, #35	; 0x23
   2d710:	d1e9      	bne.n	2d6e6 <packet_length_decode+0x8>
			return -EINVAL;
   2d712:	f06f 0015 	mvn.w	r0, #21
   2d716:	e7f8      	b.n	2d70a <packet_length_decode+0x2c>
			return -EAGAIN;
   2d718:	f06f 000a 	mvn.w	r0, #10
   2d71c:	e7f5      	b.n	2d70a <packet_length_decode+0x2c>

0002d71e <fixed_header_decode>:

int fixed_header_decode(struct buf_ctx *buf, u8_t *type_and_flags,
			u32_t *length)
{
   2d71e:	b430      	push	{r4, r5}
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   2d720:	e9d0 3500 	ldrd	r3, r5, [r0]
   2d724:	429d      	cmp	r5, r3
   2d726:	d007      	beq.n	2d738 <fixed_header_decode+0x1a>
	*val = *(buf->cur++);
   2d728:	1c5d      	adds	r5, r3, #1
   2d72a:	6005      	str	r5, [r0, #0]
   2d72c:	781b      	ldrb	r3, [r3, #0]
   2d72e:	700b      	strb	r3, [r1, #0]
	if (err_code != 0) {
		return err_code;
	}

	return packet_length_decode(buf, length);
}
   2d730:	bc30      	pop	{r4, r5}
	return packet_length_decode(buf, length);
   2d732:	4611      	mov	r1, r2
   2d734:	f7ff bfd3 	b.w	2d6de <packet_length_decode>
}
   2d738:	f06f 0015 	mvn.w	r0, #21
   2d73c:	bc30      	pop	{r4, r5}
   2d73e:	4770      	bx	lr

0002d740 <connect_ack_decode>:

int connect_ack_decode(const struct mqtt_client *client, struct buf_ctx *buf,
		       struct mqtt_connack_param *param)
{
   2d740:	b530      	push	{r4, r5, lr}
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   2d742:	e9d1 3500 	ldrd	r3, r5, [r1]
   2d746:	429d      	cmp	r5, r3
   2d748:	d102      	bne.n	2d750 <connect_ack_decode+0x10>
		return -EINVAL;
   2d74a:	f06f 0015 	mvn.w	r0, #21
	}

	param->return_code = (enum mqtt_conn_return_code)ret_code;

	return 0;
}
   2d74e:	bd30      	pop	{r4, r5, pc}
	*val = *(buf->cur++);
   2d750:	1c5c      	adds	r4, r3, #1
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   2d752:	42a5      	cmp	r5, r4
	*val = *(buf->cur++);
   2d754:	600c      	str	r4, [r1, #0]
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   2d756:	d0f8      	beq.n	2d74a <connect_ack_decode+0xa>
	*val = *(buf->cur++);
   2d758:	461d      	mov	r5, r3
   2d75a:	f815 4b02 	ldrb.w	r4, [r5], #2
   2d75e:	600d      	str	r5, [r1, #0]
	if (client->protocol_version == MQTT_VERSION_3_1_1) {
   2d760:	f890 105e 	ldrb.w	r1, [r0, #94]	; 0x5e
	*val = *(buf->cur++);
   2d764:	785b      	ldrb	r3, [r3, #1]
	if (client->protocol_version == MQTT_VERSION_3_1_1) {
   2d766:	2904      	cmp	r1, #4
			flags & MQTT_CONNACK_FLAG_SESSION_PRESENT;
   2d768:	bf04      	itt	eq
   2d76a:	f004 0401 	andeq.w	r4, r4, #1
		param->session_present_flag =
   2d76e:	7014      	strbeq	r4, [r2, #0]
	param->return_code = (enum mqtt_conn_return_code)ret_code;
   2d770:	7053      	strb	r3, [r2, #1]
	return 0;
   2d772:	2000      	movs	r0, #0
   2d774:	e7eb      	b.n	2d74e <connect_ack_decode+0xe>

0002d776 <publish_decode>:

int publish_decode(u8_t flags, u32_t var_length, struct buf_ctx *buf,
		   struct mqtt_publish_param *param)
{
   2d776:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   2d77a:	461c      	mov	r4, r3
	int err_code;
	u32_t var_header_length;

	param->dup_flag = flags & MQTT_HEADER_DUP_MASK;
   2d77c:	7d9b      	ldrb	r3, [r3, #22]
{
   2d77e:	4688      	mov	r8, r1
	param->retain_flag = flags & MQTT_HEADER_RETAIN_MASK;
   2d780:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
   2d784:	f360 0341 	bfi	r3, r0, #1, #1
	param->message.topic.qos = ((flags & MQTT_HEADER_QOS_MASK) >> 1);
   2d788:	f3c0 0041 	ubfx	r0, r0, #1, #2
   2d78c:	7220      	strb	r0, [r4, #8]
	param->retain_flag = flags & MQTT_HEADER_RETAIN_MASK;
   2d78e:	75a3      	strb	r3, [r4, #22]
	err_code = unpack_uint16(buf, &utf8_strlen);
   2d790:	f10d 0106 	add.w	r1, sp, #6
   2d794:	4610      	mov	r0, r2
{
   2d796:	4616      	mov	r6, r2
	err_code = unpack_uint16(buf, &utf8_strlen);
   2d798:	f7ff ff8b 	bl	2d6b2 <unpack_uint16>
	if (err_code != 0) {
   2d79c:	4607      	mov	r7, r0
   2d79e:	b940      	cbnz	r0, 2d7b2 <publish_decode+0x3c>
	if ((buf->end - buf->cur) < utf8_strlen) {
   2d7a0:	6833      	ldr	r3, [r6, #0]
   2d7a2:	6872      	ldr	r2, [r6, #4]
   2d7a4:	f8bd 5006 	ldrh.w	r5, [sp, #6]
   2d7a8:	1ad2      	subs	r2, r2, r3
   2d7aa:	42aa      	cmp	r2, r5
   2d7ac:	da05      	bge.n	2d7ba <publish_decode+0x44>
		return -EINVAL;
   2d7ae:	f06f 0715 	mvn.w	r7, #21

	param->message.payload.data = NULL;
	param->message.payload.len = var_length - var_header_length;

	return 0;
}
   2d7b2:	4638      	mov	r0, r7
   2d7b4:	b002      	add	sp, #8
   2d7b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	str->size = utf8_strlen;
   2d7ba:	6065      	str	r5, [r4, #4]
	if (utf8_strlen) {
   2d7bc:	b15d      	cbz	r5, 2d7d6 <publish_decode+0x60>
		str->utf8 = buf->cur;
   2d7be:	6023      	str	r3, [r4, #0]
		buf->cur += utf8_strlen;
   2d7c0:	442b      	add	r3, r5
   2d7c2:	6033      	str	r3, [r6, #0]
	if (param->message.topic.qos > MQTT_QOS_0_AT_MOST_ONCE) {
   2d7c4:	7a23      	ldrb	r3, [r4, #8]
   2d7c6:	b943      	cbnz	r3, 2d7da <publish_decode+0x64>
	var_header_length = param->message.topic.topic.size + sizeof(u16_t);
   2d7c8:	3502      	adds	r5, #2
	param->message.payload.data = NULL;
   2d7ca:	2300      	movs	r3, #0
	param->message.payload.len = var_length - var_header_length;
   2d7cc:	eba8 0505 	sub.w	r5, r8, r5
	param->message.payload.data = NULL;
   2d7d0:	60e3      	str	r3, [r4, #12]
	param->message.payload.len = var_length - var_header_length;
   2d7d2:	6125      	str	r5, [r4, #16]
	return 0;
   2d7d4:	e7ed      	b.n	2d7b2 <publish_decode+0x3c>
		str->utf8 = NULL;
   2d7d6:	6025      	str	r5, [r4, #0]
	if (err_code != 0) {
   2d7d8:	e7f4      	b.n	2d7c4 <publish_decode+0x4e>
		err_code = unpack_uint16(buf, &param->message_id);
   2d7da:	f104 0114 	add.w	r1, r4, #20
   2d7de:	4630      	mov	r0, r6
   2d7e0:	f7ff ff67 	bl	2d6b2 <unpack_uint16>
		if (err_code != 0) {
   2d7e4:	b908      	cbnz	r0, 2d7ea <publish_decode+0x74>
		var_header_length += sizeof(u16_t);
   2d7e6:	3504      	adds	r5, #4
   2d7e8:	e7ef      	b.n	2d7ca <publish_decode+0x54>
   2d7ea:	4607      	mov	r7, r0
   2d7ec:	e7e1      	b.n	2d7b2 <publish_decode+0x3c>

0002d7ee <publish_ack_decode>:

int publish_ack_decode(struct buf_ctx *buf, struct mqtt_puback_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   2d7ee:	f7ff bf60 	b.w	2d6b2 <unpack_uint16>

0002d7f2 <publish_receive_decode>:
}

int publish_receive_decode(struct buf_ctx *buf, struct mqtt_pubrec_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   2d7f2:	f7ff bf5e 	b.w	2d6b2 <unpack_uint16>

0002d7f6 <publish_release_decode>:
}

int publish_release_decode(struct buf_ctx *buf, struct mqtt_pubrel_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   2d7f6:	f7ff bf5c 	b.w	2d6b2 <unpack_uint16>

0002d7fa <publish_complete_decode>:
}

int publish_complete_decode(struct buf_ctx *buf,
			    struct mqtt_pubcomp_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   2d7fa:	f7ff bf5a 	b.w	2d6b2 <unpack_uint16>

0002d7fe <subscribe_ack_decode>:
}

int subscribe_ack_decode(struct buf_ctx *buf, struct mqtt_suback_param *param)
{
   2d7fe:	b538      	push	{r3, r4, r5, lr}
   2d800:	4605      	mov	r5, r0
   2d802:	460c      	mov	r4, r1
	int err_code;

	err_code = unpack_uint16(buf, &param->message_id);
   2d804:	f7ff ff55 	bl	2d6b2 <unpack_uint16>
	if (err_code != 0) {
   2d808:	b930      	cbnz	r0, 2d818 <subscribe_ack_decode+0x1a>
		return err_code;
	}

	return unpack_data(buf->end - buf->cur, buf, &param->return_codes);
   2d80a:	e9d5 2300 	ldrd	r2, r3, [r5]
   2d80e:	1a99      	subs	r1, r3, r2
	str->len = length;
   2d810:	60a1      	str	r1, [r4, #8]
	if (length > 0) {
   2d812:	b111      	cbz	r1, 2d81a <subscribe_ack_decode+0x1c>
		str->data = buf->cur;
   2d814:	6062      	str	r2, [r4, #4]
		buf->cur += length;
   2d816:	602b      	str	r3, [r5, #0]
}
   2d818:	bd38      	pop	{r3, r4, r5, pc}
		str->data = NULL;
   2d81a:	6060      	str	r0, [r4, #4]
   2d81c:	e7fc      	b.n	2d818 <subscribe_ack_decode+0x1a>

0002d81e <unsubscribe_ack_decode>:

int unsubscribe_ack_decode(struct buf_ctx *buf,
			   struct mqtt_unsuback_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   2d81e:	f7ff bf48 	b.w	2d6b2 <unpack_uint16>

0002d822 <pack_uint16>:
	if ((buf->end - buf->cur) < sizeof(u16_t)) {
   2d822:	e9d1 3200 	ldrd	r3, r2, [r1]
   2d826:	1ad2      	subs	r2, r2, r3
   2d828:	2a01      	cmp	r2, #1
   2d82a:	d909      	bls.n	2d840 <pack_uint16+0x1e>
	*(buf->cur++) = (val >> 8) & 0xFF;
   2d82c:	1c5a      	adds	r2, r3, #1
   2d82e:	600a      	str	r2, [r1, #0]
   2d830:	0a02      	lsrs	r2, r0, #8
   2d832:	701a      	strb	r2, [r3, #0]
	*(buf->cur++) = val & 0xFF;
   2d834:	680b      	ldr	r3, [r1, #0]
   2d836:	1c5a      	adds	r2, r3, #1
   2d838:	600a      	str	r2, [r1, #0]
   2d83a:	7018      	strb	r0, [r3, #0]
	return 0;
   2d83c:	2000      	movs	r0, #0
   2d83e:	4770      	bx	lr
		return -ENOMEM;
   2d840:	f06f 000b 	mvn.w	r0, #11
}
   2d844:	4770      	bx	lr

0002d846 <pack_utf8_str>:
{
   2d846:	b538      	push	{r3, r4, r5, lr}
	if ((buf->end - buf->cur) < GET_UT8STR_BUFFER_SIZE(str)) {
   2d848:	e9d1 2300 	ldrd	r2, r3, [r1]
{
   2d84c:	4605      	mov	r5, r0
	if ((buf->end - buf->cur) < GET_UT8STR_BUFFER_SIZE(str)) {
   2d84e:	6840      	ldr	r0, [r0, #4]
   2d850:	1a9b      	subs	r3, r3, r2
   2d852:	1c82      	adds	r2, r0, #2
   2d854:	4293      	cmp	r3, r2
{
   2d856:	460c      	mov	r4, r1
	if ((buf->end - buf->cur) < GET_UT8STR_BUFFER_SIZE(str)) {
   2d858:	d30d      	bcc.n	2d876 <pack_utf8_str+0x30>
	(void)pack_uint16(str->size, buf);
   2d85a:	b280      	uxth	r0, r0
   2d85c:	f7ff ffe1 	bl	2d822 <pack_uint16>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   2d860:	e9d5 1200 	ldrd	r1, r2, [r5]
   2d864:	6820      	ldr	r0, [r4, #0]
   2d866:	f001 fd75 	bl	2f354 <memcpy>
	return 0;
   2d86a:	2000      	movs	r0, #0
	buf->cur += str->size;
   2d86c:	6823      	ldr	r3, [r4, #0]
   2d86e:	686a      	ldr	r2, [r5, #4]
   2d870:	4413      	add	r3, r2
   2d872:	6023      	str	r3, [r4, #0]
}
   2d874:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOMEM;
   2d876:	f06f 000b 	mvn.w	r0, #11
   2d87a:	e7fb      	b.n	2d874 <pack_utf8_str+0x2e>

0002d87c <mqtt_encode_fixed_header>:
{
   2d87c:	b570      	push	{r4, r5, r6, lr}
	u32_t length = buf->cur - start;
   2d87e:	6815      	ldr	r5, [r2, #0]
   2d880:	1a6d      	subs	r5, r5, r1
	if (length > MQTT_MAX_PAYLOAD_SIZE) {
   2d882:	f1b5 5f80 	cmp.w	r5, #268435456	; 0x10000000
   2d886:	d227      	bcs.n	2d8d8 <mqtt_encode_fixed_header+0x5c>
   2d888:	462c      	mov	r4, r5
   2d88a:	2600      	movs	r6, #0
	} while (length > 0);
   2d88c:	09e4      	lsrs	r4, r4, #7
   2d88e:	b2f3      	uxtb	r3, r6
		if (buf != NULL) {
   2d890:	f106 0601 	add.w	r6, r6, #1
	} while (length > 0);
   2d894:	d1fa      	bne.n	2d88c <mqtt_encode_fixed_header+0x10>
	fixed_header_length += sizeof(u8_t);
   2d896:	3302      	adds	r3, #2
	buf->cur = start - fixed_header_length;
   2d898:	b2db      	uxtb	r3, r3
   2d89a:	425b      	negs	r3, r3
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   2d89c:	6856      	ldr	r6, [r2, #4]
	buf->cur = start - fixed_header_length;
   2d89e:	18cc      	adds	r4, r1, r3
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   2d8a0:	42b4      	cmp	r4, r6
	buf->cur = start - fixed_header_length;
   2d8a2:	6014      	str	r4, [r2, #0]
	*(buf->cur++) = val;
   2d8a4:	bf1e      	ittt	ne
   2d8a6:	3401      	addne	r4, #1
   2d8a8:	6014      	strne	r4, [r2, #0]
   2d8aa:	54c8      	strbne	r0, [r1, r3]
	return 0;
   2d8ac:	4628      	mov	r0, r5
			*(buf->cur) = length & MQTT_LENGTH_VALUE_MASK;
   2d8ae:	6811      	ldr	r1, [r2, #0]
   2d8b0:	f000 047f 	and.w	r4, r0, #127	; 0x7f
   2d8b4:	700c      	strb	r4, [r1, #0]
			if (length > 0) {
   2d8b6:	09c0      	lsrs	r0, r0, #7
				*(buf->cur) |= MQTT_LENGTH_CONTINUATION_BIT;
   2d8b8:	bf1f      	itttt	ne
   2d8ba:	6814      	ldrne	r4, [r2, #0]
   2d8bc:	7821      	ldrbne	r1, [r4, #0]
   2d8be:	f061 017f 	ornne	r1, r1, #127	; 0x7f
   2d8c2:	7021      	strbne	r1, [r4, #0]
			buf->cur++;
   2d8c4:	6811      	ldr	r1, [r2, #0]
   2d8c6:	3101      	adds	r1, #1
   2d8c8:	6011      	str	r1, [r2, #0]
	} while (length > 0);
   2d8ca:	2800      	cmp	r0, #0
   2d8cc:	d1ef      	bne.n	2d8ae <mqtt_encode_fixed_header+0x32>
	buf->cur = buf->cur - fixed_header_length;
   2d8ce:	440b      	add	r3, r1
	buf->end = buf->cur + length + fixed_header_length;
   2d8d0:	4429      	add	r1, r5
	buf->cur = buf->cur - fixed_header_length;
   2d8d2:	6013      	str	r3, [r2, #0]
	buf->end = buf->cur + length + fixed_header_length;
   2d8d4:	6051      	str	r1, [r2, #4]
}
   2d8d6:	bd70      	pop	{r4, r5, r6, pc}
		return -EMSGSIZE;
   2d8d8:	f06f 0079 	mvn.w	r0, #121	; 0x79
   2d8dc:	e7fb      	b.n	2d8d6 <mqtt_encode_fixed_header+0x5a>

0002d8de <publish_encode>:
{
   2d8de:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2d8e2:	4607      	mov	r7, r0
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   2d8e4:	7d80      	ldrb	r0, [r0, #22]
   2d8e6:	7a3c      	ldrb	r4, [r7, #8]
{
   2d8e8:	460d      	mov	r5, r1
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   2d8ea:	f000 0801 	and.w	r8, r0, #1
   2d8ee:	f3c0 0940 	ubfx	r9, r0, #1, #1
	if ((param->message.topic.qos) && (param->message_id == 0U)) {
   2d8f2:	b10c      	cbz	r4, 2d8f8 <publish_encode+0x1a>
   2d8f4:	8abb      	ldrh	r3, [r7, #20]
   2d8f6:	b35b      	cbz	r3, 2d950 <publish_encode+0x72>
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   2d8f8:	682e      	ldr	r6, [r5, #0]
	err_code = pack_utf8_str(&param->message.topic.topic, buf);
   2d8fa:	4629      	mov	r1, r5
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   2d8fc:	3605      	adds	r6, #5
   2d8fe:	602e      	str	r6, [r5, #0]
	err_code = pack_utf8_str(&param->message.topic.topic, buf);
   2d900:	4638      	mov	r0, r7
   2d902:	f7ff ffa0 	bl	2d846 <pack_utf8_str>
	if (err_code != 0) {
   2d906:	b9a8      	cbnz	r0, 2d934 <publish_encode+0x56>
	if (param->message.topic.qos) {
   2d908:	7a3b      	ldrb	r3, [r7, #8]
   2d90a:	b9ab      	cbnz	r3, 2d938 <publish_encode+0x5a>
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   2d90c:	0060      	lsls	r0, r4, #1
   2d90e:	f000 0006 	and.w	r0, r0, #6
	buf->cur += param->message.payload.len;
   2d912:	693a      	ldr	r2, [r7, #16]
   2d914:	682b      	ldr	r3, [r5, #0]
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   2d916:	ea40 0009 	orr.w	r0, r0, r9
   2d91a:	ea40 00c8 	orr.w	r0, r0, r8, lsl #3
	buf->cur += param->message.payload.len;
   2d91e:	4413      	add	r3, r2
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   2d920:	f040 0030 	orr.w	r0, r0, #48	; 0x30
	buf->cur += param->message.payload.len;
   2d924:	602b      	str	r3, [r5, #0]
	err_code = mqtt_encode_fixed_header(message_type, start, buf);
   2d926:	462a      	mov	r2, r5
   2d928:	4631      	mov	r1, r6
   2d92a:	f000 003f 	and.w	r0, r0, #63	; 0x3f
   2d92e:	f7ff ffa5 	bl	2d87c <mqtt_encode_fixed_header>
	if (err_code != 0) {
   2d932:	b140      	cbz	r0, 2d946 <publish_encode+0x68>
}
   2d934:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		err_code = pack_uint16(param->message_id, buf);
   2d938:	4629      	mov	r1, r5
   2d93a:	8ab8      	ldrh	r0, [r7, #20]
   2d93c:	f7ff ff71 	bl	2d822 <pack_uint16>
		if (err_code != 0) {
   2d940:	2800      	cmp	r0, #0
   2d942:	d0e3      	beq.n	2d90c <publish_encode+0x2e>
   2d944:	e7f6      	b.n	2d934 <publish_encode+0x56>
	buf->end -= param->message.payload.len;
   2d946:	686b      	ldr	r3, [r5, #4]
   2d948:	693a      	ldr	r2, [r7, #16]
   2d94a:	1a9b      	subs	r3, r3, r2
   2d94c:	606b      	str	r3, [r5, #4]
	return 0;
   2d94e:	e7f1      	b.n	2d934 <publish_encode+0x56>
		return -EINVAL;
   2d950:	f06f 0015 	mvn.w	r0, #21
   2d954:	e7ee      	b.n	2d934 <publish_encode+0x56>

0002d956 <subscribe_encode>:
{
   2d956:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2d95a:	4607      	mov	r7, r0
	if (param->message_id == 0U) {
   2d95c:	88c0      	ldrh	r0, [r0, #6]
{
   2d95e:	460d      	mov	r5, r1
	if (param->message_id == 0U) {
   2d960:	b330      	cbz	r0, 2d9b0 <subscribe_encode+0x5a>
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   2d962:	680e      	ldr	r6, [r1, #0]
   2d964:	3605      	adds	r6, #5
   2d966:	600e      	str	r6, [r1, #0]
	err_code = pack_uint16(param->message_id, buf);
   2d968:	f7ff ff5b 	bl	2d822 <pack_uint16>
	if (err_code != 0) {
   2d96c:	4604      	mov	r4, r0
   2d96e:	bb08      	cbnz	r0, 2d9b4 <subscribe_encode+0x5e>
   2d970:	f04f 090c 	mov.w	r9, #12
	for (i = 0; i < param->list_count; i++) {
   2d974:	88bb      	ldrh	r3, [r7, #4]
   2d976:	42a3      	cmp	r3, r4
   2d978:	dc06      	bgt.n	2d988 <subscribe_encode+0x32>
	return mqtt_encode_fixed_header(message_type, start, buf);
   2d97a:	462a      	mov	r2, r5
   2d97c:	4631      	mov	r1, r6
}
   2d97e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return mqtt_encode_fixed_header(message_type, start, buf);
   2d982:	2082      	movs	r0, #130	; 0x82
   2d984:	f7ff bf7a 	b.w	2d87c <mqtt_encode_fixed_header>
		err_code = pack_utf8_str(&param->list[i].topic, buf);
   2d988:	fb09 f804 	mul.w	r8, r9, r4
   2d98c:	6838      	ldr	r0, [r7, #0]
   2d98e:	4629      	mov	r1, r5
   2d990:	4440      	add	r0, r8
   2d992:	f7ff ff58 	bl	2d846 <pack_utf8_str>
		if (err_code != 0) {
   2d996:	b980      	cbnz	r0, 2d9ba <subscribe_encode+0x64>
		err_code = pack_uint8(param->list[i].qos, buf);
   2d998:	683b      	ldr	r3, [r7, #0]
   2d99a:	4443      	add	r3, r8
   2d99c:	7a1a      	ldrb	r2, [r3, #8]
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   2d99e:	e9d5 3100 	ldrd	r3, r1, [r5]
   2d9a2:	4299      	cmp	r1, r3
   2d9a4:	d00b      	beq.n	2d9be <subscribe_encode+0x68>
	*(buf->cur++) = val;
   2d9a6:	1c59      	adds	r1, r3, #1
   2d9a8:	6029      	str	r1, [r5, #0]
	for (i = 0; i < param->list_count; i++) {
   2d9aa:	3401      	adds	r4, #1
	*(buf->cur++) = val;
   2d9ac:	701a      	strb	r2, [r3, #0]
		if (err_code != 0) {
   2d9ae:	e7e1      	b.n	2d974 <subscribe_encode+0x1e>
		return -EINVAL;
   2d9b0:	f06f 0415 	mvn.w	r4, #21
}
   2d9b4:	4620      	mov	r0, r4
   2d9b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		err_code = pack_utf8_str(&param->list[i].topic, buf);
   2d9ba:	4604      	mov	r4, r0
   2d9bc:	e7fa      	b.n	2d9b4 <subscribe_encode+0x5e>
		return -ENOMEM;
   2d9be:	f06f 040b 	mvn.w	r4, #11
   2d9c2:	e7f7      	b.n	2d9b4 <subscribe_encode+0x5e>

0002d9c4 <mqtt_read_message_chunk>:
	return err_code;
}

static int mqtt_read_message_chunk(struct mqtt_client *client,
				   struct buf_ctx *buf, u32_t length)
{
   2d9c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2d9c6:	460d      	mov	r5, r1
	int len;

	/* Calculate how much data we need to read from the transport,
	 * given the already buffered data.
	 */
	remaining = length - (buf->end - buf->cur);
   2d9c8:	e9d1 4100 	ldrd	r4, r1, [r1]
   2d9cc:	1b0c      	subs	r4, r1, r4
   2d9ce:	1b14      	subs	r4, r2, r4
	if (remaining <= 0) {
   2d9d0:	2c00      	cmp	r4, #0
{
   2d9d2:	4606      	mov	r6, r0
	if (remaining <= 0) {
   2d9d4:	dd14      	ble.n	2da00 <mqtt_read_message_chunk+0x3c>
		return 0;
	}

	/* Check if read does not exceed the buffer. */
	if (buf->end + remaining > client->rx_buf + client->rx_buf_size) {
   2d9d6:	e9d0 3713 	ldrd	r3, r7, [r0, #76]	; 0x4c
   2d9da:	190a      	adds	r2, r1, r4
   2d9dc:	443b      	add	r3, r7
   2d9de:	429a      	cmp	r2, r3
   2d9e0:	d810      	bhi.n	2da04 <mqtt_read_message_chunk+0x40>
		MQTT_ERR("[CID %p]: Buffer too small to receive the message",
			 client);
		return -ENOMEM;
	}

	len = mqtt_transport_read(client, buf->end, remaining, false);
   2d9e2:	2300      	movs	r3, #0
   2d9e4:	4622      	mov	r2, r4
   2d9e6:	f7ec fe01 	bl	1a5ec <mqtt_transport_read>
	if (len < 0) {
   2d9ea:	2800      	cmp	r0, #0
   2d9ec:	db09      	blt.n	2da02 <mqtt_read_message_chunk+0x3e>
		MQTT_TRC("[CID %p]: Transport read error: %d", client, len);
		return len;
	}

	if (len == 0) {
   2d9ee:	d00c      	beq.n	2da0a <mqtt_read_message_chunk+0x46>
		MQTT_TRC("[CID %p]: Connection closed.", client);
		return -ENOTCONN;
	}

	client->internal.rx_buf_datalen += len;
   2d9f0:	69f3      	ldr	r3, [r6, #28]
	buf->end += len;

	if (len < remaining) {
   2d9f2:	4284      	cmp	r4, r0
	client->internal.rx_buf_datalen += len;
   2d9f4:	4403      	add	r3, r0
   2d9f6:	61f3      	str	r3, [r6, #28]
	buf->end += len;
   2d9f8:	686b      	ldr	r3, [r5, #4]
   2d9fa:	4403      	add	r3, r0
   2d9fc:	606b      	str	r3, [r5, #4]
	if (len < remaining) {
   2d9fe:	dc07      	bgt.n	2da10 <mqtt_read_message_chunk+0x4c>
		MQTT_TRC("[CID %p]: Message partially received.", client);
		return -EAGAIN;
	}

	return 0;
   2da00:	2000      	movs	r0, #0
}
   2da02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ENOMEM;
   2da04:	f06f 000b 	mvn.w	r0, #11
   2da08:	e7fb      	b.n	2da02 <mqtt_read_message_chunk+0x3e>
		return -ENOTCONN;
   2da0a:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   2da0e:	e7f8      	b.n	2da02 <mqtt_read_message_chunk+0x3e>
		return -EAGAIN;
   2da10:	f06f 000a 	mvn.w	r0, #10
   2da14:	e7f5      	b.n	2da02 <mqtt_read_message_chunk+0x3e>

0002da16 <mqtt_handle_rx>:

	return err_code;
}

int mqtt_handle_rx(struct mqtt_client *client)
{
   2da16:	b570      	push	{r4, r5, r6, lr}
	int err_code;
	u8_t type_and_flags;
	u32_t var_length;
	struct buf_ctx buf;

	buf.cur = client->rx_buf;
   2da18:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
	buf.end = client->rx_buf + client->internal.rx_buf_datalen;
   2da1a:	69c2      	ldr	r2, [r0, #28]
{
   2da1c:	b08c      	sub	sp, #48	; 0x30
	buf.cur = client->rx_buf;
   2da1e:	9302      	str	r3, [sp, #8]
{
   2da20:	4605      	mov	r5, r0
	buf.end = client->rx_buf + client->internal.rx_buf_datalen;
   2da22:	4413      	add	r3, r2
	u8_t chunk_size = MQTT_FIXED_HEADER_MIN_SIZE;
   2da24:	2202      	movs	r2, #2
	buf.end = client->rx_buf + client->internal.rx_buf_datalen;
   2da26:	9303      	str	r3, [sp, #12]
		err_code = mqtt_read_message_chunk(client, buf, chunk_size);
   2da28:	a902      	add	r1, sp, #8
   2da2a:	4628      	mov	r0, r5
   2da2c:	f7ff ffca 	bl	2d9c4 <mqtt_read_message_chunk>
		if (err_code < 0) {
   2da30:	1e04      	subs	r4, r0, #0
   2da32:	db2b      	blt.n	2da8c <mqtt_handle_rx+0x76>
		buf->cur = client->rx_buf;
   2da34:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
		err_code = fixed_header_decode(buf, type_and_flags, var_length);
   2da36:	aa01      	add	r2, sp, #4
   2da38:	f10d 0103 	add.w	r1, sp, #3
   2da3c:	a802      	add	r0, sp, #8
		buf->cur = client->rx_buf;
   2da3e:	9302      	str	r3, [sp, #8]
		err_code = fixed_header_decode(buf, type_and_flags, var_length);
   2da40:	f7ff fe6d 	bl	2d71e <fixed_header_decode>
	} while (err_code == -EAGAIN);
   2da44:	f110 0f0b 	cmn.w	r0, #11
		err_code = fixed_header_decode(buf, type_and_flags, var_length);
   2da48:	4604      	mov	r4, r0
		chunk_size = 1U;
   2da4a:	f04f 0201 	mov.w	r2, #1
	} while (err_code == -EAGAIN);
   2da4e:	d0eb      	beq.n	2da28 <mqtt_handle_rx+0x12>

	err_code = mqtt_read_and_parse_fixed_header(client, &type_and_flags,
						    &var_length, &buf);
	if (err_code < 0) {
   2da50:	2800      	cmp	r0, #0
   2da52:	db1f      	blt.n	2da94 <mqtt_handle_rx+0x7e>
		return (err_code == -EAGAIN) ? 0 : err_code;
	}

	if ((type_and_flags & 0xF0) == MQTT_PKT_TYPE_PUBLISH) {
   2da54:	f89d 6003 	ldrb.w	r6, [sp, #3]
   2da58:	f006 03f0 	and.w	r3, r6, #240	; 0xf0
   2da5c:	2b30      	cmp	r3, #48	; 0x30
   2da5e:	d11c      	bne.n	2da9a <mqtt_handle_rx+0x84>
	err_code = mqtt_read_message_chunk(client, buf, sizeof(u16_t));
   2da60:	2202      	movs	r2, #2
   2da62:	a902      	add	r1, sp, #8
   2da64:	4628      	mov	r0, r5
   2da66:	f7ff ffad 	bl	2d9c4 <mqtt_read_message_chunk>
	if (err_code < 0) {
   2da6a:	1e04      	subs	r4, r0, #0
   2da6c:	db0e      	blt.n	2da8c <mqtt_handle_rx+0x76>
	variable_header_length = *buf->cur << 8; /* MSB */
   2da6e:	9b02      	ldr	r3, [sp, #8]
	if (qos > MQTT_QOS_0_AT_MOST_ONCE) {
   2da70:	f016 0f06 	tst.w	r6, #6
   2da74:	881a      	ldrh	r2, [r3, #0]
   2da76:	ba52      	rev16	r2, r2
   2da78:	b292      	uxth	r2, r2
	variable_header_length += sizeof(u16_t);
   2da7a:	bf0c      	ite	eq
   2da7c:	3202      	addeq	r2, #2
		variable_header_length += sizeof(u16_t);
   2da7e:	3204      	addne	r2, #4
		err_code = mqtt_read_publish_var_header(client, type_and_flags,
							&buf);
	} else {
		err_code = mqtt_read_message_chunk(client, &buf, var_length);
   2da80:	a902      	add	r1, sp, #8
   2da82:	4628      	mov	r0, r5
   2da84:	f7ff ff9e 	bl	2d9c4 <mqtt_read_message_chunk>
	}

	if (err_code < 0) {
   2da88:	1e04      	subs	r4, r0, #0
   2da8a:	da08      	bge.n	2da9e <mqtt_handle_rx+0x88>
		return (err_code == -EAGAIN) ? 0 : err_code;
   2da8c:	f114 0f0b 	cmn.w	r4, #11
   2da90:	d100      	bne.n	2da94 <mqtt_handle_rx+0x7e>
   2da92:	2400      	movs	r4, #0
	}

	client->internal.rx_buf_datalen = 0U;

	return 0;
}
   2da94:	4620      	mov	r0, r4
   2da96:	b00c      	add	sp, #48	; 0x30
   2da98:	bd70      	pop	{r4, r5, r6, pc}
		err_code = mqtt_read_message_chunk(client, &buf, var_length);
   2da9a:	9a01      	ldr	r2, [sp, #4]
   2da9c:	e7f0      	b.n	2da80 <mqtt_handle_rx+0x6a>
	evt.result = 0;
   2da9e:	2200      	movs	r2, #0
	err_code = mqtt_handle_packet(client, type_and_flags, var_length, &buf);
   2daa0:	f89d 0003 	ldrb.w	r0, [sp, #3]
   2daa4:	9901      	ldr	r1, [sp, #4]
	evt.result = 0;
   2daa6:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
	switch (type_and_flags & 0xF0) {
   2daaa:	2b60      	cmp	r3, #96	; 0x60
	evt.result = 0;
   2daac:	920b      	str	r2, [sp, #44]	; 0x2c
	switch (type_and_flags & 0xF0) {
   2daae:	d05e      	beq.n	2db6e <mqtt_handle_rx+0x158>
   2dab0:	d813      	bhi.n	2dada <mqtt_handle_rx+0xc4>
   2dab2:	2b30      	cmp	r3, #48	; 0x30
   2dab4:	d045      	beq.n	2db42 <mqtt_handle_rx+0x12c>
   2dab6:	d804      	bhi.n	2dac2 <mqtt_handle_rx+0xac>
   2dab8:	2b20      	cmp	r3, #32
   2daba:	d02a      	beq.n	2db12 <mqtt_handle_rx+0xfc>
	client->internal.rx_buf_datalen = 0U;
   2dabc:	2400      	movs	r4, #0
   2dabe:	61ec      	str	r4, [r5, #28]
	return 0;
   2dac0:	e7e8      	b.n	2da94 <mqtt_handle_rx+0x7e>
	switch (type_and_flags & 0xF0) {
   2dac2:	2b40      	cmp	r3, #64	; 0x40
   2dac4:	d049      	beq.n	2db5a <mqtt_handle_rx+0x144>
   2dac6:	2b50      	cmp	r3, #80	; 0x50
   2dac8:	d1f8      	bne.n	2dabc <mqtt_handle_rx+0xa6>
		evt.type = MQTT_EVT_PUBREC;
   2daca:	2304      	movs	r3, #4
		err_code = publish_receive_decode(buf, &evt.param.pubrec);
   2dacc:	a905      	add	r1, sp, #20
   2dace:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBREC;
   2dad0:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_receive_decode(buf, &evt.param.pubrec);
   2dad4:	f7ff fe8d 	bl	2d7f2 <publish_receive_decode>
   2dad8:	e046      	b.n	2db68 <mqtt_handle_rx+0x152>
	switch (type_and_flags & 0xF0) {
   2dada:	2b90      	cmp	r3, #144	; 0x90
   2dadc:	d04f      	beq.n	2db7e <mqtt_handle_rx+0x168>
   2dade:	d809      	bhi.n	2daf4 <mqtt_handle_rx+0xde>
   2dae0:	2b70      	cmp	r3, #112	; 0x70
   2dae2:	d1eb      	bne.n	2dabc <mqtt_handle_rx+0xa6>
		evt.type = MQTT_EVT_PUBCOMP;
   2dae4:	2306      	movs	r3, #6
		err_code = publish_complete_decode(buf, &evt.param.pubcomp);
   2dae6:	a905      	add	r1, sp, #20
   2dae8:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBCOMP;
   2daea:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_complete_decode(buf, &evt.param.pubcomp);
   2daee:	f7ff fe84 	bl	2d7fa <publish_complete_decode>
   2daf2:	e039      	b.n	2db68 <mqtt_handle_rx+0x152>
	switch (type_and_flags & 0xF0) {
   2daf4:	2bb0      	cmp	r3, #176	; 0xb0
   2daf6:	d04a      	beq.n	2db8e <mqtt_handle_rx+0x178>
   2daf8:	2bd0      	cmp	r3, #208	; 0xd0
   2dafa:	d1df      	bne.n	2dabc <mqtt_handle_rx+0xa6>
		if (client->unacked_ping <= 0) {
   2dafc:	f995 305f 	ldrsb.w	r3, [r5, #95]	; 0x5f
   2db00:	2b00      	cmp	r3, #0
			client->unacked_ping--;
   2db02:	bfca      	itet	gt
   2db04:	f103 33ff 	addgt.w	r3, r3, #4294967295
			client->unacked_ping = 0;
   2db08:	f885 205f 	strble.w	r2, [r5, #95]	; 0x5f
			client->unacked_ping--;
   2db0c:	f885 305f 	strbgt.w	r3, [r5, #95]	; 0x5f
	if (err_code < 0) {
   2db10:	e7d4      	b.n	2dabc <mqtt_handle_rx+0xa6>
		evt.type = MQTT_EVT_CONNACK;
   2db12:	f88d 2010 	strb.w	r2, [sp, #16]
		err_code = connect_ack_decode(client, buf, &evt.param.connack);
   2db16:	a902      	add	r1, sp, #8
   2db18:	aa05      	add	r2, sp, #20
   2db1a:	4628      	mov	r0, r5
   2db1c:	f7ff fe10 	bl	2d740 <connect_ack_decode>
		if (err_code == 0) {
   2db20:	4604      	mov	r4, r0
   2db22:	bb10      	cbnz	r0, 2db6a <mqtt_handle_rx+0x154>
			if (evt.param.connack.return_code ==
   2db24:	f89d 2015 	ldrb.w	r2, [sp, #21]
   2db28:	b91a      	cbnz	r2, 2db32 <mqtt_handle_rx+0x11c>
				MQTT_SET_STATE(client, MQTT_STATE_CONNECTED);
   2db2a:	69ab      	ldr	r3, [r5, #24]
   2db2c:	f043 0304 	orr.w	r3, r3, #4
   2db30:	61ab      	str	r3, [r5, #24]
			evt.result = evt.param.connack.return_code;
   2db32:	920b      	str	r2, [sp, #44]	; 0x2c
		event_notify(client, &evt);
   2db34:	a904      	add	r1, sp, #16
   2db36:	4628      	mov	r0, r5
   2db38:	f000 f84f 	bl	2dbda <event_notify>
	if (err_code < 0) {
   2db3c:	2c00      	cmp	r4, #0
   2db3e:	dabd      	bge.n	2dabc <mqtt_handle_rx+0xa6>
   2db40:	e7a8      	b.n	2da94 <mqtt_handle_rx+0x7e>
		evt.type = MQTT_EVT_PUBLISH;
   2db42:	2302      	movs	r3, #2
		err_code = publish_decode(type_and_flags, var_length, buf,
   2db44:	aa02      	add	r2, sp, #8
		evt.type = MQTT_EVT_PUBLISH;
   2db46:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_decode(type_and_flags, var_length, buf,
   2db4a:	ab05      	add	r3, sp, #20
   2db4c:	f7ff fe13 	bl	2d776 <publish_decode>
		client->internal.remaining_payload =
   2db50:	9b09      	ldr	r3, [sp, #36]	; 0x24
		err_code = publish_decode(type_and_flags, var_length, buf,
   2db52:	4604      	mov	r4, r0
		evt.result = err_code;
   2db54:	900b      	str	r0, [sp, #44]	; 0x2c
		client->internal.remaining_payload =
   2db56:	622b      	str	r3, [r5, #32]
	if (notify_event == true) {
   2db58:	e7ec      	b.n	2db34 <mqtt_handle_rx+0x11e>
		evt.type = MQTT_EVT_PUBACK;
   2db5a:	2303      	movs	r3, #3
		err_code = publish_ack_decode(buf, &evt.param.puback);
   2db5c:	a905      	add	r1, sp, #20
   2db5e:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBACK;
   2db60:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_ack_decode(buf, &evt.param.puback);
   2db64:	f7ff fe43 	bl	2d7ee <publish_ack_decode>
		err_code = unsubscribe_ack_decode(buf, &evt.param.unsuback);
   2db68:	4604      	mov	r4, r0
		evt.result = err_code;
   2db6a:	940b      	str	r4, [sp, #44]	; 0x2c
	if (notify_event == true) {
   2db6c:	e7e2      	b.n	2db34 <mqtt_handle_rx+0x11e>
		evt.type = MQTT_EVT_PUBREL;
   2db6e:	2305      	movs	r3, #5
		err_code = publish_release_decode(buf, &evt.param.pubrel);
   2db70:	a905      	add	r1, sp, #20
   2db72:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBREL;
   2db74:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_release_decode(buf, &evt.param.pubrel);
   2db78:	f7ff fe3d 	bl	2d7f6 <publish_release_decode>
   2db7c:	e7f4      	b.n	2db68 <mqtt_handle_rx+0x152>
		evt.type = MQTT_EVT_SUBACK;
   2db7e:	2307      	movs	r3, #7
		err_code = subscribe_ack_decode(buf, &evt.param.suback);
   2db80:	a905      	add	r1, sp, #20
   2db82:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_SUBACK;
   2db84:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = subscribe_ack_decode(buf, &evt.param.suback);
   2db88:	f7ff fe39 	bl	2d7fe <subscribe_ack_decode>
   2db8c:	e7ec      	b.n	2db68 <mqtt_handle_rx+0x152>
		evt.type = MQTT_EVT_UNSUBACK;
   2db8e:	2308      	movs	r3, #8
		err_code = unsubscribe_ack_decode(buf, &evt.param.unsuback);
   2db90:	a905      	add	r1, sp, #20
   2db92:	eb0d 0003 	add.w	r0, sp, r3
		evt.type = MQTT_EVT_UNSUBACK;
   2db96:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = unsubscribe_ack_decode(buf, &evt.param.unsuback);
   2db9a:	f7ff fe40 	bl	2d81e <unsubscribe_ack_decode>
   2db9e:	e7e3      	b.n	2db68 <mqtt_handle_rx+0x152>

0002dba0 <mqtt_client_tcp_disconnect>:

int mqtt_client_tcp_disconnect(struct mqtt_client *client)
{
   2dba0:	b508      	push	{r3, lr}
	int ret;

	MQTT_TRC("Closing socket %d", client->transport.tcp.sock);

	ret = close(client->transport.tcp.sock);
   2dba2:	6a80      	ldr	r0, [r0, #40]	; 0x28
   2dba4:	f7ec fbee 	bl	1a384 <close>
	if (ret < 0) {
   2dba8:	2800      	cmp	r0, #0
   2dbaa:	da04      	bge.n	2dbb6 <mqtt_client_tcp_disconnect+0x16>
		return -errno;
   2dbac:	f7ff fd48 	bl	2d640 <__errno>
   2dbb0:	6800      	ldr	r0, [r0, #0]
   2dbb2:	4240      	negs	r0, r0
	}

	return 0;
}
   2dbb4:	bd08      	pop	{r3, pc}
	return 0;
   2dbb6:	2000      	movs	r0, #0
   2dbb8:	e7fc      	b.n	2dbb4 <mqtt_client_tcp_disconnect+0x14>

0002dbba <mqtt_transport_disconnect>:

int mqtt_transport_disconnect(struct mqtt_client *client)
{
	return transport_fn[client->transport.type].disconnect(client);
   2dbba:	f7ff bff1 	b.w	2dba0 <mqtt_client_tcp_disconnect>

0002dbbe <tx_buf_init>:
	client->internal.remaining_payload = 0U;
}

/** @brief Initialize tx buffer. */
static void tx_buf_init(struct mqtt_client *client, struct buf_ctx *buf)
{
   2dbbe:	b538      	push	{r3, r4, r5, lr}
   2dbc0:	4604      	mov	r4, r0
   2dbc2:	460d      	mov	r5, r1
__ssp_bos_icheck3(memset, void *, int)
   2dbc4:	6d82      	ldr	r2, [r0, #88]	; 0x58
   2dbc6:	2100      	movs	r1, #0
   2dbc8:	6d40      	ldr	r0, [r0, #84]	; 0x54
   2dbca:	f001 fbe3 	bl	2f394 <memset>
	memset(client->tx_buf, 0, client->tx_buf_size);
	buf->cur = client->tx_buf;
   2dbce:	6d63      	ldr	r3, [r4, #84]	; 0x54
	buf->end = client->tx_buf + client->tx_buf_size;
   2dbd0:	6da2      	ldr	r2, [r4, #88]	; 0x58
	buf->cur = client->tx_buf;
   2dbd2:	602b      	str	r3, [r5, #0]
	buf->end = client->tx_buf + client->tx_buf_size;
   2dbd4:	4413      	add	r3, r2
   2dbd6:	606b      	str	r3, [r5, #4]
}
   2dbd8:	bd38      	pop	{r3, r4, r5, pc}

0002dbda <event_notify>:
	/* Reset internal state. */
	client_reset(client);
}

void event_notify(struct mqtt_client *client, const struct mqtt_evt *evt)
{
   2dbda:	b538      	push	{r3, r4, r5, lr}
	if (client->evt_cb != NULL) {
   2dbdc:	6c83      	ldr	r3, [r0, #72]	; 0x48
{
   2dbde:	4604      	mov	r4, r0
   2dbe0:	460d      	mov	r5, r1
	if (client->evt_cb != NULL) {
   2dbe2:	b153      	cbz	r3, 2dbfa <event_notify+0x20>
		mqtt_mutex_unlock(client);
   2dbe4:	f7ec fd0e 	bl	1a604 <mqtt_mutex_unlock>

		client->evt_cb(client, evt);
   2dbe8:	4620      	mov	r0, r4
   2dbea:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   2dbec:	4629      	mov	r1, r5
   2dbee:	4798      	blx	r3

		mqtt_mutex_lock(client);
   2dbf0:	4620      	mov	r0, r4
	}
}
   2dbf2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		mqtt_mutex_lock(client);
   2dbf6:	f7ec bd31 	b.w	1a65c <mqtt_mutex_lock>
}
   2dbfa:	bd38      	pop	{r3, r4, r5, pc}

0002dbfc <client_disconnect>:

static void client_disconnect(struct mqtt_client *client, int result)
{
   2dbfc:	b530      	push	{r4, r5, lr}
   2dbfe:	4604      	mov	r4, r0
   2dc00:	b089      	sub	sp, #36	; 0x24
   2dc02:	460d      	mov	r5, r1
	int err_code;

	err_code = mqtt_transport_disconnect(client);
   2dc04:	f7ff ffd9 	bl	2dbba <mqtt_transport_disconnect>
	if (MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   2dc08:	69a3      	ldr	r3, [r4, #24]
	event_notify(client, &evt);
   2dc0a:	4669      	mov	r1, sp
	if (MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   2dc0c:	f013 0304 	ands.w	r3, r3, #4
		evt.type = MQTT_EVT_DISCONNECT;
   2dc10:	bf12      	itee	ne
   2dc12:	2301      	movne	r3, #1
		evt.type = MQTT_EVT_CONNACK;
   2dc14:	f88d 3000 	strbeq.w	r3, [sp]
		evt.result = -ECONNREFUSED;
   2dc18:	f06f 036e 	mvneq.w	r3, #110	; 0x6e
	event_notify(client, &evt);
   2dc1c:	4620      	mov	r0, r4
		evt.type = MQTT_EVT_DISCONNECT;
   2dc1e:	bf16      	itet	ne
   2dc20:	f88d 3000 	strbne.w	r3, [sp]
		evt.result = -ECONNREFUSED;
   2dc24:	9307      	streq	r3, [sp, #28]
		evt.result = result;
   2dc26:	9507      	strne	r5, [sp, #28]
	event_notify(client, &evt);
   2dc28:	f7ff ffd7 	bl	2dbda <event_notify>
	MQTT_STATE_INIT(client);
   2dc2c:	2300      	movs	r3, #0
	client->internal.last_activity = 0U;
   2dc2e:	e9c4 3305 	strd	r3, r3, [r4, #20]
	client->internal.remaining_payload = 0U;
   2dc32:	e9c4 3307 	strd	r3, r3, [r4, #28]
	if (err_code < 0) {
		MQTT_ERR("Failed to disconnect transport!");
	}

	disconnect_event_notify(client, result);
}
   2dc36:	b009      	add	sp, #36	; 0x24
   2dc38:	bd30      	pop	{r4, r5, pc}

0002dc3a <client_write>:
	return err_code;
}

static int client_write(struct mqtt_client *client, const u8_t *data,
			u32_t datalen)
{
   2dc3a:	b538      	push	{r3, r4, r5, lr}
   2dc3c:	4605      	mov	r5, r0
	int err_code;

	MQTT_TRC("[%p]: Transport writing %d bytes.", client, datalen);

	err_code = mqtt_transport_write(client, data, datalen);
   2dc3e:	f7ec fcc9 	bl	1a5d4 <mqtt_transport_write>
	if (err_code < 0) {
   2dc42:	1e04      	subs	r4, r0, #0
   2dc44:	da05      	bge.n	2dc52 <client_write+0x18>
		MQTT_TRC("TCP write failed, errno = %d, "
			 "closing connection", errno);
		client_disconnect(client, err_code);
   2dc46:	4621      	mov	r1, r4
   2dc48:	4628      	mov	r0, r5
   2dc4a:	f7ff ffd7 	bl	2dbfc <client_disconnect>

	MQTT_TRC("[%p]: Transport write complete.", client);
	client->internal.last_activity = mqtt_sys_tick_in_ms_get();

	return 0;
}
   2dc4e:	4620      	mov	r0, r4
   2dc50:	bd38      	pop	{r3, r4, r5, pc}
	return z_impl_k_uptime_get();
   2dc52:	f001 fac2 	bl	2f1da <z_impl_k_uptime_get>
	return 0;
   2dc56:	2400      	movs	r4, #0
	return (u32_t)k_uptime_get();
   2dc58:	6168      	str	r0, [r5, #20]
   2dc5a:	e7f8      	b.n	2dc4e <client_write+0x14>

0002dc5c <read_publish_payload>:
	return err_code;
}

static int read_publish_payload(struct mqtt_client *client, void *buffer,
				size_t length, bool shall_block)
{
   2dc5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2dc60:	460f      	mov	r7, r1
   2dc62:	4690      	mov	r8, r2
   2dc64:	461e      	mov	r6, r3
	int ret;

	NULL_PARAM_CHECK(client);
   2dc66:	4605      	mov	r5, r0
   2dc68:	b320      	cbz	r0, 2dcb4 <read_publish_payload+0x58>

	mqtt_mutex_lock(client);
   2dc6a:	f7ec fcf7 	bl	1a65c <mqtt_mutex_lock>

	if (client->internal.remaining_payload == 0U) {
   2dc6e:	6a2c      	ldr	r4, [r5, #32]
   2dc70:	b1b4      	cbz	r4, 2dca0 <read_publish_payload+0x44>

	if (client->internal.remaining_payload < length) {
		length = client->internal.remaining_payload;
	}

	ret = mqtt_transport_read(client, buffer, length, shall_block);
   2dc72:	4544      	cmp	r4, r8
   2dc74:	4622      	mov	r2, r4
   2dc76:	4633      	mov	r3, r6
   2dc78:	bf28      	it	cs
   2dc7a:	4642      	movcs	r2, r8
   2dc7c:	4639      	mov	r1, r7
   2dc7e:	4628      	mov	r0, r5
   2dc80:	f7ec fcb4 	bl	1a5ec <mqtt_transport_read>
   2dc84:	4604      	mov	r4, r0
	if (!shall_block && ret == -EAGAIN) {
   2dc86:	b916      	cbnz	r6, 2dc8e <read_publish_payload+0x32>
   2dc88:	f110 0f0b 	cmn.w	r0, #11
   2dc8c:	d008      	beq.n	2dca0 <read_publish_payload+0x44>
		goto exit;
	}

	if (ret <= 0) {
   2dc8e:	2c00      	cmp	r4, #0
   2dc90:	dc0c      	bgt.n	2dcac <read_publish_payload+0x50>
		if (ret == 0) {
			ret = -ENOTCONN;
   2dc92:	bf08      	it	eq
   2dc94:	f06f 047f 	mvneq.w	r4, #127	; 0x7f
		}

		client_disconnect(client, ret);
   2dc98:	4628      	mov	r0, r5
   2dc9a:	4621      	mov	r1, r4
   2dc9c:	f7ff ffae 	bl	2dbfc <client_disconnect>
	}

	client->internal.remaining_payload -= ret;

exit:
	mqtt_mutex_unlock(client);
   2dca0:	4628      	mov	r0, r5
   2dca2:	f7ec fcaf 	bl	1a604 <mqtt_mutex_unlock>

	return ret;
}
   2dca6:	4620      	mov	r0, r4
   2dca8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	client->internal.remaining_payload -= ret;
   2dcac:	6a2b      	ldr	r3, [r5, #32]
   2dcae:	1b1b      	subs	r3, r3, r4
   2dcb0:	622b      	str	r3, [r5, #32]
   2dcb2:	e7f5      	b.n	2dca0 <read_publish_payload+0x44>
	NULL_PARAM_CHECK(client);
   2dcb4:	f06f 0415 	mvn.w	r4, #21
   2dcb8:	e7f5      	b.n	2dca6 <read_publish_payload+0x4a>

0002dcba <mqtt_client_init>:
{
   2dcba:	b510      	push	{r4, lr}
	NULL_PARAM_CHECK_VOID(client);
   2dcbc:	4604      	mov	r4, r0
   2dcbe:	b1a0      	cbz	r0, 2dcea <mqtt_client_init+0x30>
   2dcc0:	2264      	movs	r2, #100	; 0x64
   2dcc2:	2100      	movs	r1, #0
   2dcc4:	f001 fb66 	bl	2f394 <memset>
	MQTT_STATE_INIT(client);
   2dcc8:	2300      	movs	r3, #0
   2dcca:	61a3      	str	r3, [r4, #24]
	return z_impl_k_mutex_init(mutex);
   2dccc:	4620      	mov	r0, r4
   2dcce:	f001 f98c 	bl	2efea <z_impl_k_mutex_init>
	client->protocol_version = MQTT_VERSION_3_1_1;
   2dcd2:	2304      	movs	r3, #4
   2dcd4:	f884 305e 	strb.w	r3, [r4, #94]	; 0x5e
	client->clean_session = 1U;
   2dcd8:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
   2dcdc:	f043 0302 	orr.w	r3, r3, #2
   2dce0:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
	client->keepalive = MQTT_KEEPALIVE;
   2dce4:	233c      	movs	r3, #60	; 0x3c
   2dce6:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
}
   2dcea:	bd10      	pop	{r4, pc}

0002dcec <mqtt_connect>:
{
   2dcec:	b537      	push	{r0, r1, r2, r4, r5, lr}
	NULL_PARAM_CHECK(client);
   2dcee:	4604      	mov	r4, r0
   2dcf0:	2800      	cmp	r0, #0
   2dcf2:	d03c      	beq.n	2dd6e <mqtt_connect+0x82>
	NULL_PARAM_CHECK(client->client_id.utf8);
   2dcf4:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
   2dcf6:	2b00      	cmp	r3, #0
   2dcf8:	d039      	beq.n	2dd6e <mqtt_connect+0x82>
	mqtt_mutex_lock(client);
   2dcfa:	f7ec fcaf 	bl	1a65c <mqtt_mutex_lock>
	if ((client->tx_buf == NULL) || (client->rx_buf == NULL)) {
   2dcfe:	6d63      	ldr	r3, [r4, #84]	; 0x54
   2dd00:	b393      	cbz	r3, 2dd68 <mqtt_connect+0x7c>
   2dd02:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   2dd04:	b383      	cbz	r3, 2dd68 <mqtt_connect+0x7c>
	err_code = mqtt_transport_connect(client);
   2dd06:	4620      	mov	r0, r4
   2dd08:	f7ec fc5c 	bl	1a5c4 <mqtt_transport_connect>
	if (err_code < 0) {
   2dd0c:	1e05      	subs	r5, r0, #0
   2dd0e:	db25      	blt.n	2dd5c <mqtt_connect+0x70>
	tx_buf_init(client, &packet);
   2dd10:	4669      	mov	r1, sp
   2dd12:	4620      	mov	r0, r4
   2dd14:	f7ff ff53 	bl	2dbbe <tx_buf_init>
	MQTT_SET_STATE(client, MQTT_STATE_TCP_CONNECTED);
   2dd18:	69a3      	ldr	r3, [r4, #24]
	err_code = connect_request_encode(client, &packet);
   2dd1a:	4669      	mov	r1, sp
	MQTT_SET_STATE(client, MQTT_STATE_TCP_CONNECTED);
   2dd1c:	f043 0302 	orr.w	r3, r3, #2
   2dd20:	61a3      	str	r3, [r4, #24]
	err_code = connect_request_encode(client, &packet);
   2dd22:	4620      	mov	r0, r4
   2dd24:	f7ec fa8a 	bl	1a23c <connect_request_encode>
	if (err_code < 0) {
   2dd28:	1e05      	subs	r5, r0, #0
   2dd2a:	db13      	blt.n	2dd54 <mqtt_connect+0x68>
	err_code = mqtt_transport_write(client, packet.cur,
   2dd2c:	e9dd 1200 	ldrd	r1, r2, [sp]
   2dd30:	4620      	mov	r0, r4
   2dd32:	1a52      	subs	r2, r2, r1
   2dd34:	f7ec fc4e 	bl	1a5d4 <mqtt_transport_write>
	if (err_code < 0) {
   2dd38:	1e05      	subs	r5, r0, #0
   2dd3a:	db0b      	blt.n	2dd54 <mqtt_connect+0x68>
	return z_impl_k_uptime_get();
   2dd3c:	f001 fa4d 	bl	2f1da <z_impl_k_uptime_get>
	client->unacked_ping = 0;
   2dd40:	2500      	movs	r5, #0
   2dd42:	6160      	str	r0, [r4, #20]
   2dd44:	f884 505f 	strb.w	r5, [r4, #95]	; 0x5f
	mqtt_mutex_unlock(client);
   2dd48:	4620      	mov	r0, r4
   2dd4a:	f7ec fc5b 	bl	1a604 <mqtt_mutex_unlock>
}
   2dd4e:	4628      	mov	r0, r5
   2dd50:	b003      	add	sp, #12
   2dd52:	bd30      	pop	{r4, r5, pc}
	client_disconnect(client, err_code);
   2dd54:	4629      	mov	r1, r5
   2dd56:	4620      	mov	r0, r4
   2dd58:	f7ff ff50 	bl	2dbfc <client_disconnect>
	MQTT_STATE_INIT(client);
   2dd5c:	2300      	movs	r3, #0
	client->internal.last_activity = 0U;
   2dd5e:	e9c4 3305 	strd	r3, r3, [r4, #20]
	client->internal.remaining_payload = 0U;
   2dd62:	e9c4 3307 	strd	r3, r3, [r4, #28]
   2dd66:	e7ef      	b.n	2dd48 <mqtt_connect+0x5c>
		err_code = -ENOMEM;
   2dd68:	f06f 050b 	mvn.w	r5, #11
   2dd6c:	e7f6      	b.n	2dd5c <mqtt_connect+0x70>
	NULL_PARAM_CHECK(client);
   2dd6e:	f06f 0515 	mvn.w	r5, #21
   2dd72:	e7ec      	b.n	2dd4e <mqtt_connect+0x62>

0002dd74 <mqtt_publish>:
{
   2dd74:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2dd76:	460e      	mov	r6, r1
	NULL_PARAM_CHECK(client);
   2dd78:	4605      	mov	r5, r0
   2dd7a:	b330      	cbz	r0, 2ddca <mqtt_publish+0x56>
	NULL_PARAM_CHECK(param);
   2dd7c:	b329      	cbz	r1, 2ddca <mqtt_publish+0x56>
	mqtt_mutex_lock(client);
   2dd7e:	f7ec fc6d 	bl	1a65c <mqtt_mutex_lock>
	tx_buf_init(client, &packet);
   2dd82:	4669      	mov	r1, sp
   2dd84:	4628      	mov	r0, r5
   2dd86:	f7ff ff1a 	bl	2dbbe <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   2dd8a:	69ab      	ldr	r3, [r5, #24]
   2dd8c:	075b      	lsls	r3, r3, #29
   2dd8e:	d519      	bpl.n	2ddc4 <mqtt_publish+0x50>
	err_code = publish_encode(param, &packet);
   2dd90:	4669      	mov	r1, sp
   2dd92:	4630      	mov	r0, r6
   2dd94:	f7ff fda3 	bl	2d8de <publish_encode>
	if (err_code < 0) {
   2dd98:	1e04      	subs	r4, r0, #0
   2dd9a:	db0d      	blt.n	2ddb8 <mqtt_publish+0x44>
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   2dd9c:	e9dd 1200 	ldrd	r1, r2, [sp]
   2dda0:	4628      	mov	r0, r5
   2dda2:	1a52      	subs	r2, r2, r1
   2dda4:	f7ff ff49 	bl	2dc3a <client_write>
	if (err_code < 0) {
   2dda8:	1e04      	subs	r4, r0, #0
   2ddaa:	db05      	blt.n	2ddb8 <mqtt_publish+0x44>
	err_code = client_write(client, param->message.payload.data,
   2ddac:	e9d6 1203 	ldrd	r1, r2, [r6, #12]
   2ddb0:	4628      	mov	r0, r5
   2ddb2:	f7ff ff42 	bl	2dc3a <client_write>
   2ddb6:	4604      	mov	r4, r0
	mqtt_mutex_unlock(client);
   2ddb8:	4628      	mov	r0, r5
   2ddba:	f7ec fc23 	bl	1a604 <mqtt_mutex_unlock>
}
   2ddbe:	4620      	mov	r0, r4
   2ddc0:	b002      	add	sp, #8
   2ddc2:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOTCONN;
   2ddc4:	f06f 047f 	mvn.w	r4, #127	; 0x7f
   2ddc8:	e7f6      	b.n	2ddb8 <mqtt_publish+0x44>
	NULL_PARAM_CHECK(client);
   2ddca:	f06f 0415 	mvn.w	r4, #21
   2ddce:	e7f6      	b.n	2ddbe <mqtt_publish+0x4a>

0002ddd0 <mqtt_disconnect>:
{
   2ddd0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	NULL_PARAM_CHECK(client);
   2ddd2:	4604      	mov	r4, r0
   2ddd4:	b310      	cbz	r0, 2de1c <mqtt_disconnect+0x4c>
	mqtt_mutex_lock(client);
   2ddd6:	f7ec fc41 	bl	1a65c <mqtt_mutex_lock>
	tx_buf_init(client, &packet);
   2ddda:	4669      	mov	r1, sp
   2dddc:	4620      	mov	r0, r4
   2ddde:	f7ff feee 	bl	2dbbe <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   2dde2:	69a3      	ldr	r3, [r4, #24]
   2dde4:	075b      	lsls	r3, r3, #29
   2dde6:	d516      	bpl.n	2de16 <mqtt_disconnect+0x46>
	err_code = disconnect_encode(&packet);
   2dde8:	4668      	mov	r0, sp
   2ddea:	f7ec faa7 	bl	1a33c <disconnect_encode>
	if (err_code < 0) {
   2ddee:	1e05      	subs	r5, r0, #0
   2ddf0:	db0b      	blt.n	2de0a <mqtt_disconnect+0x3a>
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   2ddf2:	e9dd 1200 	ldrd	r1, r2, [sp]
   2ddf6:	4620      	mov	r0, r4
   2ddf8:	1a52      	subs	r2, r2, r1
   2ddfa:	f7ff ff1e 	bl	2dc3a <client_write>
	if (err_code < 0) {
   2ddfe:	1e05      	subs	r5, r0, #0
   2de00:	db03      	blt.n	2de0a <mqtt_disconnect+0x3a>
	client_disconnect(client, 0);
   2de02:	2100      	movs	r1, #0
   2de04:	4620      	mov	r0, r4
   2de06:	f7ff fef9 	bl	2dbfc <client_disconnect>
	mqtt_mutex_unlock(client);
   2de0a:	4620      	mov	r0, r4
   2de0c:	f7ec fbfa 	bl	1a604 <mqtt_mutex_unlock>
}
   2de10:	4628      	mov	r0, r5
   2de12:	b003      	add	sp, #12
   2de14:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   2de16:	f06f 057f 	mvn.w	r5, #127	; 0x7f
   2de1a:	e7f6      	b.n	2de0a <mqtt_disconnect+0x3a>
	NULL_PARAM_CHECK(client);
   2de1c:	f06f 0515 	mvn.w	r5, #21
   2de20:	e7f6      	b.n	2de10 <mqtt_disconnect+0x40>

0002de22 <mqtt_subscribe>:
{
   2de22:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2de24:	460c      	mov	r4, r1
	NULL_PARAM_CHECK(client);
   2de26:	4605      	mov	r5, r0
   2de28:	b1f8      	cbz	r0, 2de6a <mqtt_subscribe+0x48>
	NULL_PARAM_CHECK(param);
   2de2a:	b1f1      	cbz	r1, 2de6a <mqtt_subscribe+0x48>
	mqtt_mutex_lock(client);
   2de2c:	f7ec fc16 	bl	1a65c <mqtt_mutex_lock>
	tx_buf_init(client, &packet);
   2de30:	4669      	mov	r1, sp
   2de32:	4628      	mov	r0, r5
   2de34:	f7ff fec3 	bl	2dbbe <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   2de38:	69ab      	ldr	r3, [r5, #24]
   2de3a:	075b      	lsls	r3, r3, #29
   2de3c:	d512      	bpl.n	2de64 <mqtt_subscribe+0x42>
	err_code = subscribe_encode(param, &packet);
   2de3e:	4620      	mov	r0, r4
   2de40:	4669      	mov	r1, sp
   2de42:	f7ff fd88 	bl	2d956 <subscribe_encode>
	if (err_code < 0) {
   2de46:	1e04      	subs	r4, r0, #0
   2de48:	db06      	blt.n	2de58 <mqtt_subscribe+0x36>
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   2de4a:	e9dd 1200 	ldrd	r1, r2, [sp]
   2de4e:	4628      	mov	r0, r5
   2de50:	1a52      	subs	r2, r2, r1
   2de52:	f7ff fef2 	bl	2dc3a <client_write>
   2de56:	4604      	mov	r4, r0
	mqtt_mutex_unlock(client);
   2de58:	4628      	mov	r0, r5
   2de5a:	f7ec fbd3 	bl	1a604 <mqtt_mutex_unlock>
}
   2de5e:	4620      	mov	r0, r4
   2de60:	b003      	add	sp, #12
   2de62:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   2de64:	f06f 047f 	mvn.w	r4, #127	; 0x7f
   2de68:	e7f6      	b.n	2de58 <mqtt_subscribe+0x36>
	NULL_PARAM_CHECK(client);
   2de6a:	f06f 0415 	mvn.w	r4, #21
   2de6e:	e7f6      	b.n	2de5e <mqtt_subscribe+0x3c>

0002de70 <mqtt_ping>:
{
   2de70:	b537      	push	{r0, r1, r2, r4, r5, lr}
	NULL_PARAM_CHECK(client);
   2de72:	4604      	mov	r4, r0
   2de74:	b320      	cbz	r0, 2dec0 <mqtt_ping+0x50>
	mqtt_mutex_lock(client);
   2de76:	f7ec fbf1 	bl	1a65c <mqtt_mutex_lock>
	tx_buf_init(client, &packet);
   2de7a:	4669      	mov	r1, sp
   2de7c:	4620      	mov	r0, r4
   2de7e:	f7ff fe9e 	bl	2dbbe <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   2de82:	69a3      	ldr	r3, [r4, #24]
   2de84:	075b      	lsls	r3, r3, #29
   2de86:	d518      	bpl.n	2deba <mqtt_ping+0x4a>
	err_code = ping_request_encode(&packet);
   2de88:	4668      	mov	r0, sp
   2de8a:	f7ec fa69 	bl	1a360 <ping_request_encode>
	if (err_code < 0) {
   2de8e:	1e05      	subs	r5, r0, #0
   2de90:	db0d      	blt.n	2deae <mqtt_ping+0x3e>
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   2de92:	e9dd 1200 	ldrd	r1, r2, [sp]
   2de96:	4620      	mov	r0, r4
   2de98:	1a52      	subs	r2, r2, r1
   2de9a:	f7ff fece 	bl	2dc3a <client_write>
	if (client->unacked_ping >= INT8_MAX) {
   2de9e:	f994 305f 	ldrsb.w	r3, [r4, #95]	; 0x5f
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   2dea2:	4605      	mov	r5, r0
	if (client->unacked_ping >= INT8_MAX) {
   2dea4:	2b7f      	cmp	r3, #127	; 0x7f
   2dea6:	d002      	beq.n	2deae <mqtt_ping+0x3e>
		client->unacked_ping++;
   2dea8:	3301      	adds	r3, #1
   2deaa:	f884 305f 	strb.w	r3, [r4, #95]	; 0x5f
	mqtt_mutex_unlock(client);
   2deae:	4620      	mov	r0, r4
   2deb0:	f7ec fba8 	bl	1a604 <mqtt_mutex_unlock>
}
   2deb4:	4628      	mov	r0, r5
   2deb6:	b003      	add	sp, #12
   2deb8:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   2deba:	f06f 057f 	mvn.w	r5, #127	; 0x7f
   2debe:	e7f6      	b.n	2deae <mqtt_ping+0x3e>
	NULL_PARAM_CHECK(client);
   2dec0:	f06f 0515 	mvn.w	r5, #21
   2dec4:	e7f6      	b.n	2deb4 <mqtt_ping+0x44>

0002dec6 <mqtt_live>:
{
   2dec6:	b570      	push	{r4, r5, r6, lr}
	NULL_PARAM_CHECK(client);
   2dec8:	4606      	mov	r6, r0
   2deca:	b300      	cbz	r0, 2df0e <mqtt_live+0x48>
	mqtt_mutex_lock(client);
   2decc:	f7ec fbc6 	bl	1a65c <mqtt_mutex_lock>
	elapsed_time = mqtt_elapsed_time_in_ms_get(
   2ded0:	6974      	ldr	r4, [r6, #20]
   2ded2:	f001 f982 	bl	2f1da <z_impl_k_uptime_get>
 *
 * @retval Time elapsed since last_activity time.
 */
static inline u32_t mqtt_elapsed_time_in_ms_get(u32_t last_activity)
{
	s32_t diff = k_uptime_get_32() - last_activity;
   2ded6:	1b00      	subs	r0, r0, r4
	if ((client->keepalive > 0) &&
   2ded8:	f8b6 405c 	ldrh.w	r4, [r6, #92]	; 0x5c

	if (diff < 0) {
		return 0;
   2dedc:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   2dee0:	b19c      	cbz	r4, 2df0a <mqtt_live+0x44>
	    (elapsed_time >= (client->keepalive * 1000))) {
   2dee2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   2dee6:	435c      	muls	r4, r3
	if ((client->keepalive > 0) &&
   2dee8:	4284      	cmp	r4, r0
   2deea:	d80d      	bhi.n	2df08 <mqtt_live+0x42>
		err_code = mqtt_ping(client);
   2deec:	4630      	mov	r0, r6
   2deee:	f7ff ffbf 	bl	2de70 <mqtt_ping>
		ping_sent = true;
   2def2:	2401      	movs	r4, #1
		err_code = mqtt_ping(client);
   2def4:	4605      	mov	r5, r0
	mqtt_mutex_unlock(client);
   2def6:	4630      	mov	r0, r6
   2def8:	f7ec fb84 	bl	1a604 <mqtt_mutex_unlock>
		return -EAGAIN;
   2defc:	2c00      	cmp	r4, #0
   2defe:	bf08      	it	eq
   2df00:	f06f 050a 	mvneq.w	r5, #10
}
   2df04:	4628      	mov	r0, r5
   2df06:	bd70      	pop	{r4, r5, r6, pc}
	bool ping_sent = false;
   2df08:	2400      	movs	r4, #0
	int err_code = 0;
   2df0a:	4625      	mov	r5, r4
   2df0c:	e7f3      	b.n	2def6 <mqtt_live+0x30>
	NULL_PARAM_CHECK(client);
   2df0e:	f06f 0515 	mvn.w	r5, #21
   2df12:	e7f7      	b.n	2df04 <mqtt_live+0x3e>

0002df14 <mqtt_keepalive_time_left>:
{
   2df14:	b538      	push	{r3, r4, r5, lr}
   2df16:	4605      	mov	r5, r0
	u32_t elapsed_time = mqtt_elapsed_time_in_ms_get(
   2df18:	6944      	ldr	r4, [r0, #20]
   2df1a:	f001 f95e 	bl	2f1da <z_impl_k_uptime_get>
	s32_t diff = k_uptime_get_32() - last_activity;
   2df1e:	1b04      	subs	r4, r0, r4
	u32_t keepalive_ms = 1000U * client->keepalive;
   2df20:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   2df24:	f8b5 205c 	ldrh.w	r2, [r5, #92]	; 0x5c
		return 0;
   2df28:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
   2df2c:	4350      	muls	r0, r2
	if (client->keepalive == 0) {
   2df2e:	b11a      	cbz	r2, 2df38 <mqtt_keepalive_time_left+0x24>
	if (keepalive_ms <= elapsed_time) {
   2df30:	42a0      	cmp	r0, r4
   2df32:	d904      	bls.n	2df3e <mqtt_keepalive_time_left+0x2a>
	return keepalive_ms - elapsed_time;
   2df34:	1b00      	subs	r0, r0, r4
}
   2df36:	bd38      	pop	{r3, r4, r5, pc}
		return UINT32_MAX;
   2df38:	f04f 30ff 	mov.w	r0, #4294967295
   2df3c:	e7fb      	b.n	2df36 <mqtt_keepalive_time_left+0x22>
		return 0;
   2df3e:	2000      	movs	r0, #0
   2df40:	e7f9      	b.n	2df36 <mqtt_keepalive_time_left+0x22>

0002df42 <mqtt_input>:
{
   2df42:	b538      	push	{r3, r4, r5, lr}
	NULL_PARAM_CHECK(client);
   2df44:	4605      	mov	r5, r0
   2df46:	b1d0      	cbz	r0, 2df7e <mqtt_input+0x3c>
	mqtt_mutex_lock(client);
   2df48:	f7ec fb88 	bl	1a65c <mqtt_mutex_lock>
	if (MQTT_HAS_STATE(client, MQTT_STATE_TCP_CONNECTED)) {
   2df4c:	69ab      	ldr	r3, [r5, #24]
   2df4e:	079b      	lsls	r3, r3, #30
   2df50:	d50f      	bpl.n	2df72 <mqtt_input+0x30>
	if (client->internal.remaining_payload > 0) {
   2df52:	6a2b      	ldr	r3, [r5, #32]
   2df54:	b983      	cbnz	r3, 2df78 <mqtt_input+0x36>
	err_code = mqtt_handle_rx(client);
   2df56:	4628      	mov	r0, r5
   2df58:	f7ff fd5d 	bl	2da16 <mqtt_handle_rx>
	if (err_code < 0) {
   2df5c:	1e04      	subs	r4, r0, #0
   2df5e:	da03      	bge.n	2df68 <mqtt_input+0x26>
		client_disconnect(client, err_code);
   2df60:	4621      	mov	r1, r4
   2df62:	4628      	mov	r0, r5
   2df64:	f7ff fe4a 	bl	2dbfc <client_disconnect>
	mqtt_mutex_unlock(client);
   2df68:	4628      	mov	r0, r5
   2df6a:	f7ec fb4b 	bl	1a604 <mqtt_mutex_unlock>
}
   2df6e:	4620      	mov	r0, r4
   2df70:	bd38      	pop	{r3, r4, r5, pc}
		err_code = -EACCES;
   2df72:	f06f 040c 	mvn.w	r4, #12
   2df76:	e7f7      	b.n	2df68 <mqtt_input+0x26>
		return -EBUSY;
   2df78:	f06f 040f 	mvn.w	r4, #15
   2df7c:	e7f4      	b.n	2df68 <mqtt_input+0x26>
	NULL_PARAM_CHECK(client);
   2df7e:	f06f 0415 	mvn.w	r4, #21
   2df82:	e7f4      	b.n	2df6e <mqtt_input+0x2c>

0002df84 <mqtt_read_publish_payload>:

int mqtt_read_publish_payload(struct mqtt_client *client, void *buffer,
			      size_t length)
{
	return read_publish_payload(client, buffer, length, false);
   2df84:	2300      	movs	r3, #0
   2df86:	f7ff be69 	b.w	2dc5c <read_publish_payload>

0002df8a <gpio_nrfx_write>:
{
   2df8a:	b510      	push	{r4, lr}
	return port->config->config_info;
   2df8c:	6804      	ldr	r4, [r0, #0]
   2df8e:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2df90:	68a4      	ldr	r4, [r4, #8]
	if (access_op == GPIO_ACCESS_BY_PORT) {
   2df92:	2901      	cmp	r1, #1
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2df94:	6824      	ldr	r4, [r4, #0]
	if (access_op == GPIO_ACCESS_BY_PORT) {
   2df96:	69c0      	ldr	r0, [r0, #28]
   2df98:	d103      	bne.n	2dfa2 <gpio_nrfx_write+0x18>
		nrf_gpio_port_out_write(reg, value ^ data->inverted);
   2df9a:	4058      	eors	r0, r3
    p_reg->OUT = value;
   2df9c:	6060      	str	r0, [r4, #4]
}
   2df9e:	2000      	movs	r0, #0
   2dfa0:	bd10      	pop	{r4, pc}
		if ((value > 0) ^ ((BIT(pin) & data->inverted) != 0)) {
   2dfa2:	3300      	adds	r3, #0
   2dfa4:	f04f 0101 	mov.w	r1, #1
   2dfa8:	bf18      	it	ne
   2dfaa:	2301      	movne	r3, #1
   2dfac:	40d0      	lsrs	r0, r2
   2dfae:	f000 0001 	and.w	r0, r0, #1
   2dfb2:	4091      	lsls	r1, r2
   2dfb4:	4283      	cmp	r3, r0
    p_reg->OUTSET = set_mask;
   2dfb6:	bf14      	ite	ne
   2dfb8:	60a1      	strne	r1, [r4, #8]
    p_reg->OUTCLR = clr_mask;
   2dfba:	60e1      	streq	r1, [r4, #12]
   2dfbc:	e7ef      	b.n	2df9e <gpio_nrfx_write+0x14>

0002dfbe <gpio_nrfx_read>:
{
   2dfbe:	b570      	push	{r4, r5, r6, lr}
	return port->config->config_info;
   2dfc0:	6804      	ldr	r4, [r0, #0]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   2dfc2:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2dfc4:	68a4      	ldr	r4, [r4, #8]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   2dfc6:	69c0      	ldr	r0, [r0, #28]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2dfc8:	6825      	ldr	r5, [r4, #0]
	if (access_op == GPIO_ACCESS_BY_PORT) {
   2dfca:	2901      	cmp	r1, #1
    return p_reg->DIR;
   2dfcc:	696e      	ldr	r6, [r5, #20]
    return p_reg->IN;
   2dfce:	692c      	ldr	r4, [r5, #16]
    return p_reg->OUT;
   2dfd0:	686d      	ldr	r5, [r5, #4]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   2dfd2:	ea80 0004 	eor.w	r0, r0, r4
   2dfd6:	ea84 0405 	eor.w	r4, r4, r5
   2dfda:	ea04 0406 	and.w	r4, r4, r6
   2dfde:	ea80 0004 	eor.w	r0, r0, r4
		*value = (port_val & BIT(pin)) ? 1 : 0;
   2dfe2:	bf1c      	itt	ne
   2dfe4:	40d0      	lsrne	r0, r2
   2dfe6:	f000 0001 	andne.w	r0, r0, #1
   2dfea:	6018      	str	r0, [r3, #0]
}
   2dfec:	2000      	movs	r0, #0
   2dfee:	bd70      	pop	{r4, r5, r6, pc}

0002dff0 <gpio_nrfx_pin_disable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
   2dff0:	2901      	cmp	r1, #1
{
   2dff2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
   2dff6:	bf18      	it	ne
   2dff8:	b2d4      	uxtbne	r4, r2
{
   2dffa:	4606      	mov	r6, r0
		to_pin   = pin;
   2dffc:	bf12      	itee	ne
   2dffe:	4625      	movne	r5, r4
		to_pin   = 31U;
   2e000:	251f      	moveq	r5, #31
		from_pin = 0U;
   2e002:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
   2e004:	f04f 0801 	mov.w	r8, #1
	struct gpio_nrfx_data *data = get_port_data(port);
   2e008:	6887      	ldr	r7, [r0, #8]
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   2e00a:	42ac      	cmp	r4, r5
   2e00c:	d902      	bls.n	2e014 <gpio_nrfx_pin_disable_callback+0x24>
	return res;
   2e00e:	2000      	movs	r0, #0
}
   2e010:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
   2e014:	68fb      	ldr	r3, [r7, #12]
   2e016:	fa08 f204 	lsl.w	r2, r8, r4
   2e01a:	ea23 0302 	bic.w	r3, r3, r2
   2e01e:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
   2e020:	4621      	mov	r1, r4
   2e022:	4630      	mov	r0, r6
   2e024:	f7ec fc20 	bl	1a868 <gpiote_pin_int_cfg>
		if (res != 0) {
   2e028:	2800      	cmp	r0, #0
   2e02a:	d1f1      	bne.n	2e010 <gpio_nrfx_pin_disable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   2e02c:	3401      	adds	r4, #1
   2e02e:	b2e4      	uxtb	r4, r4
   2e030:	e7eb      	b.n	2e00a <gpio_nrfx_pin_disable_callback+0x1a>

0002e032 <gpio_nrfx_pin_enable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
   2e032:	2901      	cmp	r1, #1
{
   2e034:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
   2e038:	bf18      	it	ne
   2e03a:	b2d4      	uxtbne	r4, r2
{
   2e03c:	4606      	mov	r6, r0
		to_pin   = pin;
   2e03e:	bf12      	itee	ne
   2e040:	4625      	movne	r5, r4
		to_pin   = 31U;
   2e042:	251f      	moveq	r5, #31
		from_pin = 0U;
   2e044:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
   2e046:	f04f 0801 	mov.w	r8, #1
	struct gpio_nrfx_data *data = get_port_data(port);
   2e04a:	6887      	ldr	r7, [r0, #8]
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   2e04c:	42ac      	cmp	r4, r5
   2e04e:	d902      	bls.n	2e056 <gpio_nrfx_pin_enable_callback+0x24>
	return res;
   2e050:	2000      	movs	r0, #0
}
   2e052:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
   2e056:	68fb      	ldr	r3, [r7, #12]
   2e058:	fa08 f204 	lsl.w	r2, r8, r4
   2e05c:	4313      	orrs	r3, r2
   2e05e:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
   2e060:	4621      	mov	r1, r4
   2e062:	4630      	mov	r0, r6
   2e064:	f7ec fc00 	bl	1a868 <gpiote_pin_int_cfg>
		if (res != 0) {
   2e068:	2800      	cmp	r0, #0
   2e06a:	d1f2      	bne.n	2e052 <gpio_nrfx_pin_enable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   2e06c:	3401      	adds	r4, #1
   2e06e:	b2e4      	uxtb	r4, r4
   2e070:	e7ec      	b.n	2e04c <gpio_nrfx_pin_enable_callback+0x1a>

0002e072 <gpio_pin_write>:
{
   2e072:	b410      	push	{r4}
   2e074:	4613      	mov	r3, r2
	return api->write(port, access_op, pin, value);
   2e076:	6842      	ldr	r2, [r0, #4]
   2e078:	6854      	ldr	r4, [r2, #4]
   2e07a:	460a      	mov	r2, r1
   2e07c:	46a4      	mov	ip, r4
   2e07e:	2100      	movs	r1, #0
}
   2e080:	f85d 4b04 	ldr.w	r4, [sp], #4
	return api->write(port, access_op, pin, value);
   2e084:	4760      	bx	ip

0002e086 <_spi_context_cs_control.isra.7>:
static inline void _spi_context_cs_control(struct spi_context *ctx,
   2e086:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   2e088:	6804      	ldr	r4, [r0, #0]
static inline void _spi_context_cs_control(struct spi_context *ctx,
   2e08a:	4605      	mov	r5, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   2e08c:	b324      	cbz	r4, 2e0d8 <_spi_context_cs_control.isra.7+0x52>
   2e08e:	68a3      	ldr	r3, [r4, #8]
   2e090:	b313      	cbz	r3, 2e0d8 <_spi_context_cs_control.isra.7+0x52>
   2e092:	6818      	ldr	r0, [r3, #0]
   2e094:	b300      	cbz	r0, 2e0d8 <_spi_context_cs_control.isra.7+0x52>
		if (on) {
   2e096:	b161      	cbz	r1, 2e0b2 <_spi_context_cs_control.isra.7+0x2c>
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   2e098:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
			gpio_pin_write(ctx->config->cs->gpio_dev,
   2e09c:	6859      	ldr	r1, [r3, #4]
   2e09e:	0fd2      	lsrs	r2, r2, #31
   2e0a0:	f7ff ffe7 	bl	2e072 <gpio_pin_write>
			k_busy_wait(ctx->config->cs->delay);
   2e0a4:	682b      	ldr	r3, [r5, #0]
   2e0a6:	689b      	ldr	r3, [r3, #8]
   2e0a8:	6898      	ldr	r0, [r3, #8]
}
   2e0aa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_busy_wait(usec_to_wait);
   2e0ae:	f001 b817 	b.w	2f0e0 <z_impl_k_busy_wait>
			if (!force_off &&
   2e0b2:	b912      	cbnz	r2, 2e0ba <_spi_context_cs_control.isra.7+0x34>
   2e0b4:	88a2      	ldrh	r2, [r4, #4]
   2e0b6:	0492      	lsls	r2, r2, #18
   2e0b8:	d40e      	bmi.n	2e0d8 <_spi_context_cs_control.isra.7+0x52>
			k_busy_wait(ctx->config->cs->delay);
   2e0ba:	6898      	ldr	r0, [r3, #8]
   2e0bc:	f001 f810 	bl	2f0e0 <z_impl_k_busy_wait>
			gpio_pin_write(ctx->config->cs->gpio_dev,
   2e0c0:	682a      	ldr	r2, [r5, #0]
   2e0c2:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   2e0c4:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
			gpio_pin_write(ctx->config->cs->gpio_dev,
   2e0c8:	e9d3 0100 	ldrd	r0, r1, [r3]
   2e0cc:	43d2      	mvns	r2, r2
}
   2e0ce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_write(ctx->config->cs->gpio_dev,
   2e0d2:	0fd2      	lsrs	r2, r2, #31
   2e0d4:	f7ff bfcd 	b.w	2e072 <gpio_pin_write>
}
   2e0d8:	bd38      	pop	{r3, r4, r5, pc}

0002e0da <spi_context_unlock_unconditionally>:
{
   2e0da:	b510      	push	{r4, lr}
	_spi_context_cs_control(ctx, false, true);
   2e0dc:	2201      	movs	r2, #1
   2e0de:	2100      	movs	r1, #0
{
   2e0e0:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
   2e0e2:	f7ff ffd0 	bl	2e086 <_spi_context_cs_control.isra.7>
	if (!k_sem_count_get(&ctx->lock)) {
   2e0e6:	68e3      	ldr	r3, [r4, #12]
   2e0e8:	b923      	cbnz	r3, 2e0f4 <spi_context_unlock_unconditionally+0x1a>
	z_impl_k_sem_give(sem);
   2e0ea:	1d20      	adds	r0, r4, #4
}
   2e0ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2e0f0:	f7fa b9fc 	b.w	284ec <z_impl_k_sem_give>
   2e0f4:	bd10      	pop	{r4, pc}

0002e0f6 <spi_2_init>:
#ifdef CONFIG_SPI_1_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(1);
#endif

#ifdef CONFIG_SPI_2_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(2);
   2e0f6:	b510      	push	{r4, lr}
   2e0f8:	4604      	mov	r4, r0
   2e0fa:	2200      	movs	r2, #0
   2e0fc:	200a      	movs	r0, #10
   2e0fe:	2101      	movs	r1, #1
   2e100:	f7ea ff94 	bl	1902c <z_arm_irq_priority_set>
   2e104:	4620      	mov	r0, r4
   2e106:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2e10a:	f7ec be99 	b.w	1ae40 <init_spim>

0002e10e <spi_3_init>:
#endif

#ifdef CONFIG_SPI_3_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(3);
   2e10e:	b510      	push	{r4, lr}
   2e110:	4604      	mov	r4, r0
   2e112:	2200      	movs	r2, #0
   2e114:	200b      	movs	r0, #11
   2e116:	2101      	movs	r1, #1
   2e118:	f7ea ff88 	bl	1902c <z_arm_irq_priority_set>
   2e11c:	4620      	mov	r0, r4
   2e11e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2e122:	f7ec be8d 	b.w	1ae40 <init_spim>

0002e126 <spi_nrfx_release>:
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   2e126:	6880      	ldr	r0, [r0, #8]
{
   2e128:	b510      	push	{r4, lr}
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   2e12a:	6803      	ldr	r3, [r0, #0]
   2e12c:	428b      	cmp	r3, r1
   2e12e:	d106      	bne.n	2e13e <spi_nrfx_release+0x18>
	if (dev_data->busy) {
   2e130:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
   2e134:	b934      	cbnz	r4, 2e144 <spi_nrfx_release+0x1e>
	spi_context_unlock_unconditionally(&dev_data->ctx);
   2e136:	f7ff ffd0 	bl	2e0da <spi_context_unlock_unconditionally>
	return 0;
   2e13a:	4620      	mov	r0, r4
}
   2e13c:	bd10      	pop	{r4, pc}
		return -EINVAL;
   2e13e:	f06f 0015 	mvn.w	r0, #21
   2e142:	e7fb      	b.n	2e13c <spi_nrfx_release+0x16>
		return -EBUSY;
   2e144:	f06f 000f 	mvn.w	r0, #15
   2e148:	e7f8      	b.n	2e13c <spi_nrfx_release+0x16>

0002e14a <flash_nrf_write_protection>:
}
   2e14a:	2000      	movs	r0, #0
   2e14c:	4770      	bx	lr

0002e14e <is_regular_addr_valid>:
{
   2e14e:	b538      	push	{r3, r4, r5, lr}
   2e150:	4604      	mov	r4, r0
   2e152:	460d      	mov	r5, r1
	size_t flash_size = nrfx_nvmc_flash_size_get();
   2e154:	f000 fecb 	bl	2eeee <nrfx_nvmc_flash_size_get>
	if (addr >= flash_size ||
   2e158:	4284      	cmp	r4, r0
   2e15a:	d209      	bcs.n	2e170 <is_regular_addr_valid+0x22>
   2e15c:	2c00      	cmp	r4, #0
   2e15e:	db07      	blt.n	2e170 <is_regular_addr_valid+0x22>
	    addr < 0 ||
   2e160:	42a8      	cmp	r0, r5
   2e162:	d305      	bcc.n	2e170 <is_regular_addr_valid+0x22>
	    (addr) + len > flash_size) {
   2e164:	442c      	add	r4, r5
	    len > flash_size ||
   2e166:	4284      	cmp	r4, r0
   2e168:	bf8c      	ite	hi
   2e16a:	2000      	movhi	r0, #0
   2e16c:	2001      	movls	r0, #1
}
   2e16e:	bd38      	pop	{r3, r4, r5, pc}
		return false;
   2e170:	2000      	movs	r0, #0
   2e172:	e7fc      	b.n	2e16e <is_regular_addr_valid+0x20>

0002e174 <flash_nrf_read>:
{
   2e174:	b570      	push	{r4, r5, r6, lr}
   2e176:	460d      	mov	r5, r1
	if (is_regular_addr_valid(addr, len)) {
   2e178:	4619      	mov	r1, r3
   2e17a:	4628      	mov	r0, r5
{
   2e17c:	4616      	mov	r6, r2
   2e17e:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   2e180:	f7ff ffe5 	bl	2e14e <is_regular_addr_valid>
   2e184:	b170      	cbz	r0, 2e1a4 <flash_nrf_read+0x30>
	if (!len) {
   2e186:	b184      	cbz	r4, 2e1aa <flash_nrf_read+0x36>
	if (addr < PM_APP_ADDRESS) {
   2e188:	f5b5 4f40 	cmp.w	r5, #49152	; 0xc000
		return spm_request_read(data, addr, len);
   2e18c:	4622      	mov	r2, r4
   2e18e:	4629      	mov	r1, r5
   2e190:	4630      	mov	r0, r6
	if (addr < PM_APP_ADDRESS) {
   2e192:	da03      	bge.n	2e19c <flash_nrf_read+0x28>
}
   2e194:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return spm_request_read(data, addr, len);
   2e198:	f7d9 bf22 	b.w	7fe0 <spm_request_read>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   2e19c:	f001 f8da 	bl	2f354 <memcpy>
   2e1a0:	2000      	movs	r0, #0
}
   2e1a2:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   2e1a4:	f06f 0015 	mvn.w	r0, #21
   2e1a8:	e7fb      	b.n	2e1a2 <flash_nrf_read+0x2e>
		return 0;
   2e1aa:	4620      	mov	r0, r4
   2e1ac:	e7f9      	b.n	2e1a2 <flash_nrf_read+0x2e>

0002e1ae <flash_get_page_info>:

#include <drivers/flash.h>

static int flash_get_page_info(struct device *dev, off_t offs,
				   bool use_addr, struct flash_pages_info *info)
{
   2e1ae:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   2e1b2:	461d      	mov	r5, r3
	off_t group_offs = 0;
	u32_t num_in_group;
	off_t end = 0;
	size_t layout_size;

	api->page_layout(dev, &layout, &layout_size);
   2e1b4:	6843      	ldr	r3, [r0, #4]
{
   2e1b6:	460c      	mov	r4, r1
	api->page_layout(dev, &layout, &layout_size);
   2e1b8:	691b      	ldr	r3, [r3, #16]
   2e1ba:	4669      	mov	r1, sp
{
   2e1bc:	4616      	mov	r6, r2
	api->page_layout(dev, &layout, &layout_size);
   2e1be:	aa01      	add	r2, sp, #4
   2e1c0:	4798      	blx	r3

	while (layout_size--) {
   2e1c2:	e9dd 1200 	ldrd	r1, r2, [sp]
   2e1c6:	2300      	movs	r3, #0
	off_t end = 0;
   2e1c8:	4618      	mov	r0, r3
	off_t group_offs = 0;
   2e1ca:	469e      	mov	lr, r3
	size_t page_count = 0;
   2e1cc:	469c      	mov	ip, r3
   2e1ce:	3a01      	subs	r2, #1
	while (layout_size--) {
   2e1d0:	1c57      	adds	r7, r2, #1
   2e1d2:	d102      	bne.n	2e1da <flash_get_page_info+0x2c>
		page_count += layout->pages_count;

		layout++;
	}

	return -EINVAL; /* page of the index doesn't exist */
   2e1d4:	f06f 0015 	mvn.w	r0, #21
   2e1d8:	e01a      	b.n	2e210 <flash_get_page_info+0x62>
		if (use_addr) {
   2e1da:	f8d1 8000 	ldr.w	r8, [r1]
   2e1de:	b1d6      	cbz	r6, 2e216 <flash_get_page_info+0x68>
			end += layout->pages_count * layout->pages_size;
   2e1e0:	684f      	ldr	r7, [r1, #4]
   2e1e2:	fb07 0008 	mla	r0, r7, r8, r0
		if (offs < end) {
   2e1e6:	42a0      	cmp	r0, r4
   2e1e8:	f102 37ff 	add.w	r7, r2, #4294967295
   2e1ec:	dd18      	ble.n	2e220 <flash_get_page_info+0x72>
   2e1ee:	9201      	str	r2, [sp, #4]
   2e1f0:	b103      	cbz	r3, 2e1f4 <flash_get_page_info+0x46>
   2e1f2:	9100      	str	r1, [sp, #0]
			info->size = layout->pages_size;
   2e1f4:	9b00      	ldr	r3, [sp, #0]
   2e1f6:	685b      	ldr	r3, [r3, #4]
   2e1f8:	606b      	str	r3, [r5, #4]
			if (use_addr) {
   2e1fa:	b176      	cbz	r6, 2e21a <flash_get_page_info+0x6c>
				num_in_group = (offs - group_offs) /
   2e1fc:	eba4 040e 	sub.w	r4, r4, lr
   2e200:	fbb4 f4f3 	udiv	r4, r4, r3
			return 0;
   2e204:	2000      	movs	r0, #0
			info->start_offset = group_offs +
   2e206:	fb04 e303 	mla	r3, r4, r3, lr
			info->index = page_count + num_in_group;
   2e20a:	4464      	add	r4, ip
			info->start_offset = group_offs +
   2e20c:	602b      	str	r3, [r5, #0]
			info->index = page_count + num_in_group;
   2e20e:	60ac      	str	r4, [r5, #8]
}
   2e210:	b002      	add	sp, #8
   2e212:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			end += layout->pages_count;
   2e216:	4440      	add	r0, r8
   2e218:	e7e5      	b.n	2e1e6 <flash_get_page_info+0x38>
				num_in_group = offs - page_count;
   2e21a:	eba4 040c 	sub.w	r4, r4, ip
   2e21e:	e7f1      	b.n	2e204 <flash_get_page_info+0x56>
		group_offs += layout->pages_count * layout->pages_size;
   2e220:	684b      	ldr	r3, [r1, #4]
		page_count += layout->pages_count;
   2e222:	44c4      	add	ip, r8
		group_offs += layout->pages_count * layout->pages_size;
   2e224:	fb03 ee08 	mla	lr, r3, r8, lr
		layout++;
   2e228:	3108      	adds	r1, #8
   2e22a:	2301      	movs	r3, #1
   2e22c:	463a      	mov	r2, r7
   2e22e:	e7cf      	b.n	2e1d0 <flash_get_page_info+0x22>

0002e230 <z_impl_flash_get_page_info_by_offs>:

int z_impl_flash_get_page_info_by_offs(struct device *dev, off_t offs,
				      struct flash_pages_info *info)
{
	return flash_get_page_info(dev, offs, true, info);
   2e230:	4613      	mov	r3, r2
   2e232:	2201      	movs	r2, #1
   2e234:	f7ff bfbb 	b.w	2e1ae <flash_get_page_info>

0002e238 <uarte_nrfx_isr_int>:
	if (data->int_driven->disable_tx_irq &&
   2e238:	6882      	ldr	r2, [r0, #8]
	return dev->config->config_info;
   2e23a:	6803      	ldr	r3, [r0, #0]
	if (data->int_driven->disable_tx_irq &&
   2e23c:	6892      	ldr	r2, [r2, #8]
	return config->uarte_regs;
   2e23e:	689b      	ldr	r3, [r3, #8]
	if (data->int_driven->disable_tx_irq &&
   2e240:	7b91      	ldrb	r1, [r2, #14]
	return config->uarte_regs;
   2e242:	681b      	ldr	r3, [r3, #0]
	if (data->int_driven->disable_tx_irq &&
   2e244:	b159      	cbz	r1, 2e25e <uarte_nrfx_isr_int+0x26>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2e246:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
   2e24a:	b141      	cbz	r1, 2e25e <uarte_nrfx_isr_int+0x26>
    p_reg->INTENCLR = mask;
   2e24c:	f44f 7180 	mov.w	r1, #256	; 0x100
   2e250:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2e254:	2101      	movs	r1, #1
   2e256:	60d9      	str	r1, [r3, #12]
		data->int_driven->disable_tx_irq = false;
   2e258:	2300      	movs	r3, #0
   2e25a:	7393      	strb	r3, [r2, #14]
		return;
   2e25c:	4770      	bx	lr
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2e25e:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ERROR)) {
   2e262:	b111      	cbz	r1, 2e26a <uarte_nrfx_isr_int+0x32>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2e264:	2100      	movs	r1, #0
   2e266:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
	if (data->int_driven->cb) {
   2e26a:	6813      	ldr	r3, [r2, #0]
   2e26c:	b10b      	cbz	r3, 2e272 <uarte_nrfx_isr_int+0x3a>
		data->int_driven->cb(data->int_driven->cb_data);
   2e26e:	6850      	ldr	r0, [r2, #4]
   2e270:	4718      	bx	r3
}
   2e272:	4770      	bx	lr

0002e274 <uarte_nrfx_config_get>:
{
   2e274:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   2e276:	6882      	ldr	r2, [r0, #8]
   2e278:	e892 0003 	ldmia.w	r2, {r0, r1}
   2e27c:	e883 0003 	stmia.w	r3, {r0, r1}
}
   2e280:	2000      	movs	r0, #0
   2e282:	4770      	bx	lr

0002e284 <uarte_nrfx_err_check>:
	return dev->config->config_info;
   2e284:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   2e286:	689b      	ldr	r3, [r3, #8]
   2e288:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   2e28a:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   2e28e:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   2e292:	4770      	bx	lr

0002e294 <uarte_nrfx_poll_in>:
	return dev->config->config_info;
   2e294:	6803      	ldr	r3, [r0, #0]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   2e296:	6882      	ldr	r2, [r0, #8]
	return config->uarte_regs;
   2e298:	689b      	ldr	r3, [r3, #8]
   2e29a:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2e29c:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   2e2a0:	b138      	cbz	r0, 2e2b2 <uarte_nrfx_poll_in+0x1e>
	*c = data->rx_data;
   2e2a2:	7b12      	ldrb	r2, [r2, #12]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2e2a4:	2000      	movs	r0, #0
   2e2a6:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2e2a8:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2e2aa:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2e2ae:	601a      	str	r2, [r3, #0]
	return 0;
   2e2b0:	4770      	bx	lr
		return -1;
   2e2b2:	f04f 30ff 	mov.w	r0, #4294967295
}
   2e2b6:	4770      	bx	lr

0002e2b8 <uarte_nrfx_poll_out>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2e2b8:	2200      	movs	r2, #0
	return dev->config->config_info;
   2e2ba:	6803      	ldr	r3, [r0, #0]
{
   2e2bc:	b082      	sub	sp, #8
	return config->uarte_regs;
   2e2be:	689b      	ldr	r3, [r3, #8]
{
   2e2c0:	f88d 1007 	strb.w	r1, [sp, #7]
	return config->uarte_regs;
   2e2c4:	681b      	ldr	r3, [r3, #0]
   2e2c6:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   2e2ca:	f10d 0207 	add.w	r2, sp, #7
   2e2ce:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   2e2d2:	2201      	movs	r2, #1
   2e2d4:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2e2d8:	609a      	str	r2, [r3, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2e2da:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	while (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   2e2de:	2900      	cmp	r1, #0
   2e2e0:	d0fb      	beq.n	2e2da <uarte_nrfx_poll_out+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2e2e2:	60da      	str	r2, [r3, #12]
}
   2e2e4:	b002      	add	sp, #8
   2e2e6:	4770      	bx	lr

0002e2e8 <uarte_nrfx_fifo_fill>:
	return dev->config->config_info;
   2e2e8:	6803      	ldr	r3, [r0, #0]
{
   2e2ea:	b570      	push	{r4, r5, r6, lr}
	return config->uarte_regs;
   2e2ec:	689b      	ldr	r3, [r3, #8]
   2e2ee:	681c      	ldr	r4, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2e2f0:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   2e2f4:	b1bb      	cbz	r3, 2e326 <uarte_nrfx_fifo_fill+0x3e>
	struct uarte_nrfx_data *data = get_dev_data(dev);
   2e2f6:	6885      	ldr	r5, [r0, #8]
	if (len > data->int_driven->tx_buff_size) {
   2e2f8:	68ab      	ldr	r3, [r5, #8]
   2e2fa:	8998      	ldrh	r0, [r3, #12]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2e2fc:	2300      	movs	r3, #0
   2e2fe:	4290      	cmp	r0, r2
   2e300:	bfa8      	it	ge
   2e302:	4610      	movge	r0, r2
   2e304:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
	for (int i = 0; i < len; i++) {
   2e308:	68aa      	ldr	r2, [r5, #8]
   2e30a:	4283      	cmp	r3, r0
   2e30c:	6892      	ldr	r2, [r2, #8]
   2e30e:	db06      	blt.n	2e31e <uarte_nrfx_fifo_fill+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2e310:	2301      	movs	r3, #1
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   2e312:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   2e316:	f8c4 0548 	str.w	r0, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2e31a:	60a3      	str	r3, [r4, #8]
}
   2e31c:	bd70      	pop	{r4, r5, r6, pc}
		data->int_driven->tx_buffer[i] = tx_data[i];
   2e31e:	5cce      	ldrb	r6, [r1, r3]
   2e320:	54d6      	strb	r6, [r2, r3]
	for (int i = 0; i < len; i++) {
   2e322:	3301      	adds	r3, #1
   2e324:	e7f0      	b.n	2e308 <uarte_nrfx_fifo_fill+0x20>
		return 0;
   2e326:	4618      	mov	r0, r3
   2e328:	e7f8      	b.n	2e31c <uarte_nrfx_fifo_fill+0x34>

0002e32a <uarte_nrfx_fifo_read>:
	return dev->config->config_info;
   2e32a:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   2e32c:	689b      	ldr	r3, [r3, #8]
   2e32e:	681a      	ldr	r2, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2e330:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   2e334:	b143      	cbz	r3, 2e348 <uarte_nrfx_fifo_read+0x1e>
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   2e336:	6883      	ldr	r3, [r0, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2e338:	2000      	movs	r0, #0
   2e33a:	f8c2 0110 	str.w	r0, [r2, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2e33e:	2001      	movs	r0, #1
		rx_data[num_rx++] = (u8_t)data->rx_data;
   2e340:	7b1b      	ldrb	r3, [r3, #12]
   2e342:	700b      	strb	r3, [r1, #0]
   2e344:	6010      	str	r0, [r2, #0]
   2e346:	4770      	bx	lr
	int num_rx = 0;
   2e348:	4618      	mov	r0, r3
}
   2e34a:	4770      	bx	lr

0002e34c <uarte_nrfx_irq_tx_enable>:
	data->int_driven->disable_tx_irq = false;
   2e34c:	2100      	movs	r1, #0
	return dev->config->config_info;
   2e34e:	6803      	ldr	r3, [r0, #0]
	data->int_driven->disable_tx_irq = false;
   2e350:	6882      	ldr	r2, [r0, #8]
	return config->uarte_regs;
   2e352:	689b      	ldr	r3, [r3, #8]
	data->int_driven->disable_tx_irq = false;
   2e354:	6892      	ldr	r2, [r2, #8]
	return config->uarte_regs;
   2e356:	681b      	ldr	r3, [r3, #0]
	data->int_driven->disable_tx_irq = false;
   2e358:	7391      	strb	r1, [r2, #14]
    p_reg->INTENSET = mask;
   2e35a:	f44f 7280 	mov.w	r2, #256	; 0x100
   2e35e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   2e362:	4770      	bx	lr

0002e364 <uarte_nrfx_irq_tx_disable>:
	data->int_driven->disable_tx_irq = true;
   2e364:	2201      	movs	r2, #1
   2e366:	6883      	ldr	r3, [r0, #8]
   2e368:	689b      	ldr	r3, [r3, #8]
   2e36a:	739a      	strb	r2, [r3, #14]
}
   2e36c:	4770      	bx	lr

0002e36e <uarte_nrfx_irq_tx_ready_complete>:
	return dev->config->config_info;
   2e36e:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   2e370:	689b      	ldr	r3, [r3, #8]
   2e372:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2e374:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX) &&
   2e378:	b118      	cbz	r0, 2e382 <uarte_nrfx_irq_tx_ready_complete+0x14>
    return p_reg->INTENSET & mask;
   2e37a:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
   2e37e:	f3c0 2000 	ubfx	r0, r0, #8, #1
}
   2e382:	4770      	bx	lr

0002e384 <uarte_nrfx_irq_rx_ready>:
	return dev->config->config_info;
   2e384:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   2e386:	689b      	ldr	r3, [r3, #8]
   2e388:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2e38a:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
}
   2e38e:	3000      	adds	r0, #0
   2e390:	bf18      	it	ne
   2e392:	2001      	movne	r0, #1
   2e394:	4770      	bx	lr

0002e396 <uarte_nrfx_irq_rx_enable>:
    p_reg->INTENSET = mask;
   2e396:	2210      	movs	r2, #16
	return dev->config->config_info;
   2e398:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   2e39a:	689b      	ldr	r3, [r3, #8]
   2e39c:	681b      	ldr	r3, [r3, #0]
   2e39e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   2e3a2:	4770      	bx	lr

0002e3a4 <uarte_nrfx_irq_rx_disable>:
    p_reg->INTENCLR = mask;
   2e3a4:	2210      	movs	r2, #16
	return dev->config->config_info;
   2e3a6:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   2e3a8:	689b      	ldr	r3, [r3, #8]
   2e3aa:	681b      	ldr	r3, [r3, #0]
   2e3ac:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   2e3b0:	4770      	bx	lr

0002e3b2 <uarte_nrfx_irq_err_enable>:
    p_reg->INTENSET = mask;
   2e3b2:	f44f 7200 	mov.w	r2, #512	; 0x200
	return dev->config->config_info;
   2e3b6:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   2e3b8:	689b      	ldr	r3, [r3, #8]
   2e3ba:	681b      	ldr	r3, [r3, #0]
   2e3bc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   2e3c0:	4770      	bx	lr

0002e3c2 <uarte_nrfx_irq_err_disable>:
    p_reg->INTENCLR = mask;
   2e3c2:	f44f 7200 	mov.w	r2, #512	; 0x200
	return dev->config->config_info;
   2e3c6:	6803      	ldr	r3, [r0, #0]
	return config->uarte_regs;
   2e3c8:	689b      	ldr	r3, [r3, #8]
   2e3ca:	681b      	ldr	r3, [r3, #0]
   2e3cc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   2e3d0:	4770      	bx	lr

0002e3d2 <uarte_nrfx_irq_update>:
}
   2e3d2:	2001      	movs	r0, #1
   2e3d4:	4770      	bx	lr

0002e3d6 <uarte_nrfx_irq_callback_set>:
	data->int_driven->cb = cb;
   2e3d6:	6883      	ldr	r3, [r0, #8]
   2e3d8:	689b      	ldr	r3, [r3, #8]
	data->int_driven->cb_data = cb_data;
   2e3da:	e9c3 1200 	strd	r1, r2, [r3]
}
   2e3de:	4770      	bx	lr

0002e3e0 <uarte_nrfx_irq_is_pending>:
{
   2e3e0:	b508      	push	{r3, lr}
	return dev->config->config_info;
   2e3e2:	6803      	ldr	r3, [r0, #0]
{
   2e3e4:	4602      	mov	r2, r0
	return config->uarte_regs;
   2e3e6:	689b      	ldr	r3, [r3, #8]
   2e3e8:	6819      	ldr	r1, [r3, #0]
    return p_reg->INTENSET & mask;
   2e3ea:	f8d1 3304 	ldr.w	r3, [r1, #772]	; 0x304
		||
   2e3ee:	05db      	lsls	r3, r3, #23
   2e3f0:	d405      	bmi.n	2e3fe <uarte_nrfx_irq_is_pending+0x1e>
   2e3f2:	f8d1 0304 	ldr.w	r0, [r1, #772]	; 0x304
   2e3f6:	f010 0010 	ands.w	r0, r0, #16
   2e3fa:	d106      	bne.n	2e40a <uarte_nrfx_irq_is_pending+0x2a>
}
   2e3fc:	bd08      	pop	{r3, pc}
		 uarte_nrfx_irq_tx_ready_complete(dev))
   2e3fe:	f7ff ffb6 	bl	2e36e <uarte_nrfx_irq_tx_ready_complete>
					    NRF_UARTE_INT_ENDTX_MASK) &&
   2e402:	2800      	cmp	r0, #0
   2e404:	d0f5      	beq.n	2e3f2 <uarte_nrfx_irq_is_pending+0x12>
		||
   2e406:	2001      	movs	r0, #1
   2e408:	e7f8      	b.n	2e3fc <uarte_nrfx_irq_is_pending+0x1c>
		 uarte_nrfx_irq_rx_ready(dev)));
   2e40a:	4610      	mov	r0, r2
   2e40c:	f7ff ffba 	bl	2e384 <uarte_nrfx_irq_rx_ready>
					    NRF_UARTE_INT_ENDRX_MASK) &&
   2e410:	3000      	adds	r0, #0
   2e412:	bf18      	it	ne
   2e414:	2001      	movne	r0, #1
   2e416:	e7f1      	b.n	2e3fc <uarte_nrfx_irq_is_pending+0x1c>

0002e418 <entropy_cc310_rng_init>:
{
	/* No initialization is required */
	(void)dev;

	return 0;
}
   2e418:	2000      	movs	r0, #0
   2e41a:	4770      	bx	lr

0002e41c <trace_proxy_irq_handler>:
ISR_DIRECT_DECLARE(trace_proxy_irq_handler)
   2e41c:	4668      	mov	r0, sp
   2e41e:	f020 0107 	bic.w	r1, r0, #7
   2e422:	468d      	mov	sp, r1
   2e424:	b501      	push	{r0, lr}
	bsd_os_trace_irq_handler();
   2e426:	f7f1 f9fb 	bl	1f820 <bsd_os_trace_irq_handler>
	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   2e42a:	f7ea fe31 	bl	19090 <_arch_isr_direct_pm>
   2e42e:	f7ea fd19 	bl	18e64 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(trace_proxy_irq_handler)
   2e432:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   2e436:	4685      	mov	sp, r0
   2e438:	4770      	bx	lr

0002e43a <ipc_proxy_irq_handler>:
ISR_DIRECT_DECLARE(ipc_proxy_irq_handler)
   2e43a:	4668      	mov	r0, sp
   2e43c:	f020 0107 	bic.w	r1, r0, #7
   2e440:	468d      	mov	sp, r1
   2e442:	b501      	push	{r0, lr}
	IPC_IRQHandler();
   2e444:	f7f1 fde4 	bl	20010 <IPC_IRQHandler>
	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   2e448:	f7ea fe22 	bl	19090 <_arch_isr_direct_pm>
   2e44c:	f7ea fd0a 	bl	18e64 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(ipc_proxy_irq_handler)
   2e450:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   2e454:	4685      	mov	sp, r0
   2e456:	4770      	bx	lr

0002e458 <trace_task_create>:
{
   2e458:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(TRACE_IRQ, TRACE_IRQ_PRIORITY,
   2e45a:	201d      	movs	r0, #29
   2e45c:	2200      	movs	r2, #0
   2e45e:	2106      	movs	r1, #6
   2e460:	f7ea fde4 	bl	1902c <z_arm_irq_priority_set>
}
   2e464:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(TRACE_IRQ);
   2e468:	201d      	movs	r0, #29
   2e46a:	f7ea bdcf 	b.w	1900c <arch_irq_enable>

0002e46e <read_task_create>:
{
   2e46e:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(BSD_APPLICATION_IRQ, BSD_APPLICATION_IRQ_PRIORITY,
   2e470:	201c      	movs	r0, #28
   2e472:	2200      	movs	r2, #0
   2e474:	2106      	movs	r1, #6
   2e476:	f7ea fdd9 	bl	1902c <z_arm_irq_priority_set>
}
   2e47a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(BSD_APPLICATION_IRQ);
   2e47e:	201c      	movs	r0, #28
   2e480:	f7ea bdc4 	b.w	1900c <arch_irq_enable>

0002e484 <bsd_os_trace_put>:
		remaining_bytes -= transfer_len;
	}
#endif

	return 0;
}
   2e484:	2000      	movs	r0, #0
   2e486:	4770      	bx	lr

0002e488 <z_to_nrf_flags>:
		nrf_flags |= NRF_MSG_DONTWAIT;
   2e488:	f010 0340 	ands.w	r3, r0, #64	; 0x40
   2e48c:	bf18      	it	ne
   2e48e:	2302      	movne	r3, #2
	if (z_flags & MSG_PEEK) {
   2e490:	0782      	lsls	r2, r0, #30
		nrf_flags |= NRF_MSG_PEEK;
   2e492:	bf48      	it	mi
   2e494:	f043 0308 	orrmi.w	r3, r3, #8
}
   2e498:	4618      	mov	r0, r3
   2e49a:	4770      	bx	lr

0002e49c <z_to_nrf_family>:
	switch (z_family) {
   2e49c:	2803      	cmp	r0, #3
   2e49e:	d00f      	beq.n	2e4c0 <z_to_nrf_family+0x24>
   2e4a0:	d808      	bhi.n	2e4b4 <z_to_nrf_family+0x18>
   2e4a2:	2801      	cmp	r0, #1
   2e4a4:	d00e      	beq.n	2e4c4 <z_to_nrf_family+0x28>
   2e4a6:	2802      	cmp	r0, #2
		return -EAFNOSUPPORT;
   2e4a8:	bf08      	it	eq
   2e4aa:	200a      	moveq	r0, #10
   2e4ac:	bf18      	it	ne
   2e4ae:	f06f 0069 	mvnne.w	r0, #105	; 0x69
   2e4b2:	4770      	bx	lr
	switch (z_family) {
   2e4b4:	2866      	cmp	r0, #102	; 0x66
   2e4b6:	d006      	beq.n	2e4c6 <z_to_nrf_family+0x2a>
   2e4b8:	2867      	cmp	r0, #103	; 0x67
		return -EAFNOSUPPORT;
   2e4ba:	bf08      	it	eq
   2e4bc:	2001      	moveq	r0, #1
   2e4be:	e7f5      	b.n	2e4ac <z_to_nrf_family+0x10>
		return NRF_AF_PACKET;
   2e4c0:	2005      	movs	r0, #5
   2e4c2:	4770      	bx	lr
		return NRF_AF_INET;
   2e4c4:	2002      	movs	r0, #2
}
   2e4c6:	4770      	bx	lr

0002e4c8 <z_to_nrf_protocol>:
	switch (proto) {
   2e4c8:	f5b0 7f81 	cmp.w	r0, #258	; 0x102
   2e4cc:	d01d      	beq.n	2e50a <z_to_nrf_protocol+0x42>
   2e4ce:	dc08      	bgt.n	2e4e2 <z_to_nrf_protocol+0x1a>
   2e4d0:	2806      	cmp	r0, #6
   2e4d2:	d01d      	beq.n	2e510 <z_to_nrf_protocol+0x48>
   2e4d4:	2811      	cmp	r0, #17
   2e4d6:	d01d      	beq.n	2e514 <z_to_nrf_protocol+0x4c>
   2e4d8:	2800      	cmp	r0, #0
		return -EPROTONOSUPPORT;
   2e4da:	bf18      	it	ne
   2e4dc:	f06f 007a 	mvnne.w	r0, #122	; 0x7a
   2e4e0:	4770      	bx	lr
	switch (proto) {
   2e4e2:	f240 2301 	movw	r3, #513	; 0x201
   2e4e6:	4298      	cmp	r0, r3
   2e4e8:	d015      	beq.n	2e516 <z_to_nrf_protocol+0x4e>
   2e4ea:	dc06      	bgt.n	2e4fa <z_to_nrf_protocol+0x32>
   2e4ec:	f240 1311 	movw	r3, #273	; 0x111
   2e4f0:	4298      	cmp	r0, r3
		return -EPROTONOSUPPORT;
   2e4f2:	bf08      	it	eq
   2e4f4:	f44f 7087 	moveq.w	r0, #270	; 0x10e
   2e4f8:	e7ef      	b.n	2e4da <z_to_nrf_protocol+0x12>
	switch (proto) {
   2e4fa:	f240 2302 	movw	r3, #514	; 0x202
   2e4fe:	4298      	cmp	r0, r3
   2e500:	d009      	beq.n	2e516 <z_to_nrf_protocol+0x4e>
   2e502:	f240 2303 	movw	r3, #515	; 0x203
   2e506:	4298      	cmp	r0, r3
   2e508:	e7e7      	b.n	2e4da <z_to_nrf_protocol+0x12>
		return NRF_SPROTO_TLS1v2;
   2e50a:	f44f 7082 	mov.w	r0, #260	; 0x104
   2e50e:	4770      	bx	lr
		return NRF_IPPROTO_TCP;
   2e510:	2001      	movs	r0, #1
   2e512:	4770      	bx	lr
		return NRF_IPPROTO_UDP;
   2e514:	2002      	movs	r0, #2
}
   2e516:	4770      	bx	lr

0002e518 <nrf91_bsdlib_socket_offload_init>:
}
   2e518:	2000      	movs	r0, #0
   2e51a:	4770      	bx	lr

0002e51c <nrf91_socket_offload_freeaddrinfo>:
{
   2e51c:	b538      	push	{r3, r4, r5, lr}
   2e51e:	4604      	mov	r4, r0
	while (next != NULL) {
   2e520:	b904      	cbnz	r4, 2e524 <nrf91_socket_offload_freeaddrinfo+0x8>
}
   2e522:	bd38      	pop	{r3, r4, r5, pc}
		k_free(this->ai_addr);
   2e524:	6960      	ldr	r0, [r4, #20]
		next = next->ai_next;
   2e526:	69e5      	ldr	r5, [r4, #28]
		k_free(this->ai_addr);
   2e528:	f000 fd45 	bl	2efb6 <k_free>
		k_free(this);
   2e52c:	4620      	mov	r0, r4
   2e52e:	f000 fd42 	bl	2efb6 <k_free>
		next = next->ai_next;
   2e532:	462c      	mov	r4, r5
   2e534:	e7f4      	b.n	2e520 <nrf91_socket_offload_freeaddrinfo+0x4>

0002e536 <z_to_nrf_addrinfo_hints>:
{
   2e536:	b538      	push	{r3, r4, r5, lr}
   2e538:	460c      	mov	r4, r1
   2e53a:	4605      	mov	r5, r0
__ssp_bos_icheck3(memset, void *, int)
   2e53c:	221c      	movs	r2, #28
   2e53e:	2100      	movs	r1, #0
   2e540:	1d20      	adds	r0, r4, #4
   2e542:	f000 ff27 	bl	2f394 <memset>
	nrf_out->ai_flags = z_to_nrf_addrinfo_flags(z_in->ai_flags);
   2e546:	2300      	movs	r3, #0
   2e548:	6023      	str	r3, [r4, #0]
	nrf_out->ai_socktype = z_to_nrf_socktype(z_in->ai_socktype);
   2e54a:	68ab      	ldr	r3, [r5, #8]
	switch (socktype) {
   2e54c:	2b03      	cmp	r3, #3
   2e54e:	d003      	beq.n	2e558 <z_to_nrf_addrinfo_hints+0x22>
		return NRF_SOCK_MGMT;
   2e550:	2b04      	cmp	r3, #4
   2e552:	bf08      	it	eq
   2e554:	f44f 7300 	moveq.w	r3, #512	; 0x200
	nrf_out->ai_socktype = z_to_nrf_socktype(z_in->ai_socktype);
   2e558:	60a3      	str	r3, [r4, #8]
	family = z_to_nrf_family(z_in->ai_family);
   2e55a:	88a8      	ldrh	r0, [r5, #4]
   2e55c:	f7ff ff9e 	bl	2e49c <z_to_nrf_family>
	if (family == -EAFNOSUPPORT) {
   2e560:	f110 0f6a 	cmn.w	r0, #106	; 0x6a
   2e564:	d00b      	beq.n	2e57e <z_to_nrf_addrinfo_hints+0x48>
	nrf_out->ai_family = family;
   2e566:	6060      	str	r0, [r4, #4]
	nrf_out->ai_protocol = z_to_nrf_protocol(z_in->ai_protocol);
   2e568:	68e8      	ldr	r0, [r5, #12]
   2e56a:	f7ff ffad 	bl	2e4c8 <z_to_nrf_protocol>
	if (nrf_out->ai_protocol == -EPROTONOSUPPORT) {
   2e56e:	f110 0f7b 	cmn.w	r0, #123	; 0x7b
	nrf_out->ai_protocol = z_to_nrf_protocol(z_in->ai_protocol);
   2e572:	60e0      	str	r0, [r4, #12]
	if (nrf_out->ai_protocol == -EPROTONOSUPPORT) {
   2e574:	d003      	beq.n	2e57e <z_to_nrf_addrinfo_hints+0x48>
	if (z_in->ai_canonname != NULL) {
   2e576:	69a8      	ldr	r0, [r5, #24]
   2e578:	b108      	cbz	r0, 2e57e <z_to_nrf_addrinfo_hints+0x48>
		nrf_out->ai_canonname = z_in->ai_canonname;
   2e57a:	61a0      	str	r0, [r4, #24]
	return 0;
   2e57c:	2000      	movs	r0, #0
}
   2e57e:	bd38      	pop	{r3, r4, r5, pc}

0002e580 <nrf91_socket_offload_send>:
{
   2e580:	b570      	push	{r4, r5, r6, lr}
   2e582:	4604      	mov	r4, r0
	return nrf_send(sd, buf, len, z_to_nrf_flags(flags));
   2e584:	4618      	mov	r0, r3
{
   2e586:	4615      	mov	r5, r2
	return nrf_send(sd, buf, len, z_to_nrf_flags(flags));
   2e588:	f7ff ff7e 	bl	2e488 <z_to_nrf_flags>
   2e58c:	462a      	mov	r2, r5
   2e58e:	4603      	mov	r3, r0
   2e590:	4620      	mov	r0, r4
}
   2e592:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return nrf_send(sd, buf, len, z_to_nrf_flags(flags));
   2e596:	f7f3 ba83 	b.w	21aa0 <nrf_send>

0002e59a <nrf91_socket_offload_recv>:
{
   2e59a:	b570      	push	{r4, r5, r6, lr}
   2e59c:	4604      	mov	r4, r0
	return nrf_recv(sd, buf, max_len, z_to_nrf_flags(flags));
   2e59e:	4618      	mov	r0, r3
{
   2e5a0:	4615      	mov	r5, r2
	return nrf_recv(sd, buf, max_len, z_to_nrf_flags(flags));
   2e5a2:	f7ff ff71 	bl	2e488 <z_to_nrf_flags>
   2e5a6:	462a      	mov	r2, r5
   2e5a8:	4603      	mov	r3, r0
   2e5aa:	4620      	mov	r0, r4
}
   2e5ac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return nrf_recv(sd, buf, max_len, z_to_nrf_flags(flags));
   2e5b0:	f7f3 baac 	b.w	21b0c <nrf_recv>

0002e5b4 <nrf91_socket_offload_getsockopt>:
{
   2e5b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2e5b8:	461d      	mov	r5, r3
	struct nrf_timeval nrf_rcvtimeo = {0, 0};
   2e5ba:	2300      	movs	r3, #0
{
   2e5bc:	b086      	sub	sp, #24
   2e5be:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
	struct nrf_timeval nrf_rcvtimeo = {0, 0};
   2e5c2:	e9cd 3304 	strd	r3, r3, [sp, #16]
	nrf_socklen_t nrf_optlen = (nrf_socklen_t)*optlen;
   2e5c6:	f8d8 3000 	ldr.w	r3, [r8]
	switch (z_in_level) {
   2e5ca:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
{
   2e5ce:	4607      	mov	r7, r0
   2e5d0:	460c      	mov	r4, r1
   2e5d2:	4616      	mov	r6, r2
	nrf_socklen_t nrf_optlen = (nrf_socklen_t)*optlen;
   2e5d4:	9303      	str	r3, [sp, #12]
	switch (z_in_level) {
   2e5d6:	d002      	beq.n	2e5de <nrf91_socket_offload_getsockopt+0x2a>
   2e5d8:	dc2b      	bgt.n	2e632 <nrf91_socket_offload_getsockopt+0x7e>
   2e5da:	2901      	cmp	r1, #1
   2e5dc:	d13d      	bne.n	2e65a <nrf91_socket_offload_getsockopt+0xa6>
	if (z_to_nrf_optname(level, optname, &nrf_optname) < 0)
   2e5de:	aa02      	add	r2, sp, #8
   2e5e0:	4631      	mov	r1, r6
   2e5e2:	4620      	mov	r0, r4
   2e5e4:	f7ed f9f0 	bl	1b9c8 <z_to_nrf_optname>
   2e5e8:	2800      	cmp	r0, #0
   2e5ea:	db36      	blt.n	2e65a <nrf91_socket_offload_getsockopt+0xa6>
	if ((level == SOL_SOCKET) && (optname == SO_RCVTIMEO)) {
   2e5ec:	2c01      	cmp	r4, #1
   2e5ee:	d128      	bne.n	2e642 <nrf91_socket_offload_getsockopt+0x8e>
   2e5f0:	2e14      	cmp	r6, #20
   2e5f2:	d126      	bne.n	2e642 <nrf91_socket_offload_getsockopt+0x8e>
		nrf_optlen = sizeof(struct nrf_timeval);
   2e5f4:	2308      	movs	r3, #8
   2e5f6:	9303      	str	r3, [sp, #12]
		nrf_optval = &nrf_rcvtimeo;
   2e5f8:	ab04      	add	r3, sp, #16
	retval = nrf_getsockopt(sd, nrf_level, nrf_optname, nrf_optval,
   2e5fa:	aa03      	add	r2, sp, #12
   2e5fc:	9200      	str	r2, [sp, #0]
   2e5fe:	4638      	mov	r0, r7
   2e600:	9a02      	ldr	r2, [sp, #8]
   2e602:	4621      	mov	r1, r4
   2e604:	f7f3 fb02 	bl	21c0c <nrf_getsockopt>
	if ((retval == 0) && (optval != NULL)) {
   2e608:	4607      	mov	r7, r0
   2e60a:	b970      	cbnz	r0, 2e62a <nrf91_socket_offload_getsockopt+0x76>
   2e60c:	b16d      	cbz	r5, 2e62a <nrf91_socket_offload_getsockopt+0x76>
		*optlen = nrf_optlen;
   2e60e:	9b03      	ldr	r3, [sp, #12]
		if (level == SOL_SOCKET) {
   2e610:	2c01      	cmp	r4, #1
		*optlen = nrf_optlen;
   2e612:	f8c8 3000 	str.w	r3, [r8]
		if (level == SOL_SOCKET) {
   2e616:	d108      	bne.n	2e62a <nrf91_socket_offload_getsockopt+0x76>
			if (optname == SO_ERROR) {
   2e618:	2e04      	cmp	r6, #4
   2e61a:	d114      	bne.n	2e646 <nrf91_socket_offload_getsockopt+0x92>
				bsd_os_errno_set(*(int *)optval);
   2e61c:	6828      	ldr	r0, [r5, #0]
   2e61e:	f7ed f8a5 	bl	1b76c <bsd_os_errno_set>
				*(int *)optval = errno;
   2e622:	f7ff f80d 	bl	2d640 <__errno>
   2e626:	6803      	ldr	r3, [r0, #0]
   2e628:	602b      	str	r3, [r5, #0]
}
   2e62a:	4638      	mov	r0, r7
   2e62c:	b006      	add	sp, #24
   2e62e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (z_in_level) {
   2e632:	f240 2302 	movw	r3, #514	; 0x202
   2e636:	4299      	cmp	r1, r3
   2e638:	d0d1      	beq.n	2e5de <nrf91_socket_offload_getsockopt+0x2a>
   2e63a:	f240 2303 	movw	r3, #515	; 0x203
   2e63e:	4299      	cmp	r1, r3
   2e640:	e7cc      	b.n	2e5dc <nrf91_socket_offload_getsockopt+0x28>
   2e642:	462b      	mov	r3, r5
   2e644:	e7d9      	b.n	2e5fa <nrf91_socket_offload_getsockopt+0x46>
			} else if (optname == SO_RCVTIMEO) {
   2e646:	2e14      	cmp	r6, #20
   2e648:	d1ef      	bne.n	2e62a <nrf91_socket_offload_getsockopt+0x76>
				((struct timeval *)optval)->tv_sec =
   2e64a:	9b04      	ldr	r3, [sp, #16]
   2e64c:	602b      	str	r3, [r5, #0]
				((struct timeval *)optval)->tv_usec =
   2e64e:	9b05      	ldr	r3, [sp, #20]
   2e650:	606b      	str	r3, [r5, #4]
				*optlen = sizeof(struct timeval);
   2e652:	2308      	movs	r3, #8
   2e654:	f8c8 3000 	str.w	r3, [r8]
   2e658:	e7e7      	b.n	2e62a <nrf91_socket_offload_getsockopt+0x76>
	errno = ENOPROTOOPT;
   2e65a:	f7fe fff1 	bl	2d640 <__errno>
   2e65e:	236d      	movs	r3, #109	; 0x6d
	return retval;
   2e660:	f04f 37ff 	mov.w	r7, #4294967295
	errno = ENOPROTOOPT;
   2e664:	6003      	str	r3, [r0, #0]
	return retval;
   2e666:	e7e0      	b.n	2e62a <nrf91_socket_offload_getsockopt+0x76>

0002e668 <nrf91_socket_offload_poll>:
{
   2e668:	b5f0      	push	{r4, r5, r6, r7, lr}
   2e66a:	b091      	sub	sp, #68	; 0x44
   2e66c:	4605      	mov	r5, r0
   2e66e:	460c      	mov	r4, r1
   2e670:	4616      	mov	r6, r2
	struct nrf_pollfd tmp[BSD_MAX_SOCKET_COUNT] = {0};
   2e672:	2100      	movs	r1, #0
   2e674:	2240      	movs	r2, #64	; 0x40
   2e676:	4668      	mov	r0, sp
   2e678:	f000 fe8c 	bl	2f394 <memset>
	for (int i = 0; i < nfds; i++) {
   2e67c:	466a      	mov	r2, sp
   2e67e:	2100      	movs	r1, #0
		if (fds[i].events & POLLIN) {
   2e680:	1d2f      	adds	r7, r5, #4
	for (int i = 0; i < nfds; i++) {
   2e682:	42a1      	cmp	r1, r4
   2e684:	db0c      	blt.n	2e6a0 <nrf91_socket_offload_poll+0x38>
	retval = nrf_poll((struct nrf_pollfd *)&tmp, nfds, timeout);
   2e686:	4632      	mov	r2, r6
   2e688:	4621      	mov	r1, r4
   2e68a:	4668      	mov	r0, sp
   2e68c:	f7f3 fade 	bl	21c4c <nrf_poll>
	for (int i = 0; i < nfds; i++) {
   2e690:	2200      	movs	r2, #0
   2e692:	462b      	mov	r3, r5
		fds[i].revents = 0;
   2e694:	4616      	mov	r6, r2
			fds[i].revents |= POLLIN;
   2e696:	2701      	movs	r7, #1
	for (int i = 0; i < nfds; i++) {
   2e698:	42a2      	cmp	r2, r4
   2e69a:	db1a      	blt.n	2e6d2 <nrf91_socket_offload_poll+0x6a>
}
   2e69c:	b011      	add	sp, #68	; 0x44
   2e69e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		tmp[i].handle = fds[i].fd;
   2e6a0:	f855 3031 	ldr.w	r3, [r5, r1, lsl #3]
		if (fds[i].events & POLLIN) {
   2e6a4:	f837 0031 	ldrh.w	r0, [r7, r1, lsl #3]
		tmp[i].handle = fds[i].fd;
   2e6a8:	6013      	str	r3, [r2, #0]
		if (fds[i].events & POLLIN) {
   2e6aa:	07c3      	lsls	r3, r0, #31
			tmp[i].requested |= NRF_POLLIN;
   2e6ac:	bf48      	it	mi
   2e6ae:	8893      	ldrhmi	r3, [r2, #4]
	for (int i = 0; i < nfds; i++) {
   2e6b0:	f101 0101 	add.w	r1, r1, #1
			tmp[i].requested |= NRF_POLLIN;
   2e6b4:	bf44      	itt	mi
   2e6b6:	f043 0301 	orrmi.w	r3, r3, #1
   2e6ba:	8093      	strhmi	r3, [r2, #4]
		if (fds[i].events & POLLOUT) {
   2e6bc:	0743      	lsls	r3, r0, #29
			tmp[i].requested |= NRF_POLLOUT;
   2e6be:	bf48      	it	mi
   2e6c0:	8893      	ldrhmi	r3, [r2, #4]
   2e6c2:	f102 0208 	add.w	r2, r2, #8
   2e6c6:	bf44      	itt	mi
   2e6c8:	f043 0302 	orrmi.w	r3, r3, #2
   2e6cc:	f822 3c04 	strhmi.w	r3, [r2, #-4]
   2e6d0:	e7d7      	b.n	2e682 <nrf91_socket_offload_poll+0x1a>
		if (tmp[i].returned & NRF_POLLIN) {
   2e6d2:	eb0d 01c2 	add.w	r1, sp, r2, lsl #3
   2e6d6:	88c9      	ldrh	r1, [r1, #6]
		fds[i].revents = 0;
   2e6d8:	80de      	strh	r6, [r3, #6]
		if (tmp[i].returned & NRF_POLLIN) {
   2e6da:	07cd      	lsls	r5, r1, #31
			fds[i].revents |= POLLIN;
   2e6dc:	bf48      	it	mi
   2e6de:	80df      	strhmi	r7, [r3, #6]
		if (tmp[i].returned & NRF_POLLOUT) {
   2e6e0:	078d      	lsls	r5, r1, #30
			fds[i].revents |= POLLOUT;
   2e6e2:	bf48      	it	mi
   2e6e4:	88dd      	ldrhmi	r5, [r3, #6]
	for (int i = 0; i < nfds; i++) {
   2e6e6:	f102 0201 	add.w	r2, r2, #1
			fds[i].revents |= POLLOUT;
   2e6ea:	bf44      	itt	mi
   2e6ec:	f045 0504 	orrmi.w	r5, r5, #4
   2e6f0:	80dd      	strhmi	r5, [r3, #6]
		if (tmp[i].returned & NRF_POLLERR) {
   2e6f2:	074d      	lsls	r5, r1, #29
			fds[i].revents |= POLLERR;
   2e6f4:	bf48      	it	mi
   2e6f6:	88dd      	ldrhmi	r5, [r3, #6]
   2e6f8:	f103 0308 	add.w	r3, r3, #8
   2e6fc:	bf44      	itt	mi
   2e6fe:	f045 0508 	orrmi.w	r5, r5, #8
   2e702:	f823 5c02 	strhmi.w	r5, [r3, #-2]
		if (tmp[i].returned & NRF_POLLNVAL) {
   2e706:	06cd      	lsls	r5, r1, #27
			fds[i].revents |= POLLNVAL;
   2e708:	bf42      	ittt	mi
   2e70a:	f833 5c02 	ldrhmi.w	r5, [r3, #-2]
   2e70e:	f045 0520 	orrmi.w	r5, r5, #32
   2e712:	f823 5c02 	strhmi.w	r5, [r3, #-2]
		if (tmp[i].returned & NRF_POLLHUP) {
   2e716:	0709      	lsls	r1, r1, #28
			fds[i].revents |= POLLHUP;
   2e718:	bf42      	ittt	mi
   2e71a:	f833 1c02 	ldrhmi.w	r1, [r3, #-2]
   2e71e:	f041 0110 	orrmi.w	r1, r1, #16
   2e722:	f823 1c02 	strhmi.w	r1, [r3, #-2]
   2e726:	e7b7      	b.n	2e698 <nrf91_socket_offload_poll+0x30>

0002e728 <nrf91_socket_offload_listen>:
	return nrf_listen(sd, backlog);
   2e728:	f7f3 ba1c 	b.w	21b64 <nrf_listen>

0002e72c <nrf91_socket_offload_close>:
	return nrf_close(sd);
   2e72c:	f7f3 b98e 	b.w	21a4c <nrf_close>

0002e730 <nrf91_socket_offload_fcntl>:
	switch (cmd) {
   2e730:	2903      	cmp	r1, #3
{
   2e732:	b508      	push	{r3, lr}
	switch (cmd) {
   2e734:	d00b      	beq.n	2e74e <nrf91_socket_offload_fcntl+0x1e>
   2e736:	2904      	cmp	r1, #4
   2e738:	d111      	bne.n	2e75e <nrf91_socket_offload_fcntl+0x2e>
		flags = va_arg(args, int);
   2e73a:	6812      	ldr	r2, [r2, #0]
		if (flags != 0 && flags != O_NONBLOCK)
   2e73c:	f432 4380 	bics.w	r3, r2, #16384	; 0x4000
   2e740:	d10d      	bne.n	2e75e <nrf91_socket_offload_fcntl+0x2e>
}
   2e742:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		retval = nrf_fcntl(fd, NRF_F_SETFL, flags);
   2e746:	1392      	asrs	r2, r2, #14
   2e748:	2101      	movs	r1, #1
   2e74a:	f7f3 ba81 	b.w	21c50 <nrf_fcntl>
		flags = nrf_fcntl(fd, NRF_F_GETFL, 0);
   2e74e:	2200      	movs	r2, #0
   2e750:	2102      	movs	r1, #2
   2e752:	f7f3 fa7d 	bl	21c50 <nrf_fcntl>
		retval = (flags & NRF_O_NONBLOCK) ? O_NONBLOCK : 0;
   2e756:	0380      	lsls	r0, r0, #14
   2e758:	f400 4080 	and.w	r0, r0, #16384	; 0x4000
}
   2e75c:	bd08      	pop	{r3, pc}
	errno = EINVAL;
   2e75e:	f7fe ff6f 	bl	2d640 <__errno>
   2e762:	2316      	movs	r3, #22
   2e764:	6003      	str	r3, [r0, #0]
	return retval;
   2e766:	f04f 30ff 	mov.w	r0, #4294967295
   2e76a:	e7f7      	b.n	2e75c <nrf91_socket_offload_fcntl+0x2c>

0002e76c <nrf_to_z_ipv6>:
	ptr->sin6_port = nrf_in->sin6_port;
   2e76c:	890b      	ldrh	r3, [r1, #8]
	ptr->sin6_family = AF_INET6;
   2e76e:	2202      	movs	r2, #2
	ptr->sin6_port = nrf_in->sin6_port;
   2e770:	8043      	strh	r3, [r0, #2]
	ptr->sin6_family = AF_INET6;
   2e772:	4603      	mov	r3, r0
{
   2e774:	b530      	push	{r4, r5, lr}
	ptr->sin6_family = AF_INET6;
   2e776:	f823 2b04 	strh.w	r2, [r3], #4
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   2e77a:	f101 0210 	add.w	r2, r1, #16
   2e77e:	f102 0410 	add.w	r4, r2, #16
   2e782:	f852 5b04 	ldr.w	r5, [r2], #4
   2e786:	42a2      	cmp	r2, r4
   2e788:	f843 5b04 	str.w	r5, [r3], #4
   2e78c:	d1f9      	bne.n	2e782 <nrf_to_z_ipv6+0x16>
	ptr->sin6_scope_id = (u8_t)nrf_in->sin6_scope_id;
   2e78e:	6a0b      	ldr	r3, [r1, #32]
   2e790:	7503      	strb	r3, [r0, #20]
}
   2e792:	bd30      	pop	{r4, r5, pc}

0002e794 <nrf91_socket_offload_getaddrinfo>:
{
   2e794:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2e798:	4614      	mov	r4, r2
   2e79a:	460e      	mov	r6, r1
	struct nrf_addrinfo *nrf_res = NULL;
   2e79c:	2100      	movs	r1, #0
{
   2e79e:	b093      	sub	sp, #76	; 0x4c
   2e7a0:	4605      	mov	r5, r0
	memset(&nrf_hints, 0, sizeof(struct nrf_addrinfo));
   2e7a2:	2220      	movs	r2, #32
   2e7a4:	a802      	add	r0, sp, #8
{
   2e7a6:	461f      	mov	r7, r3
	struct nrf_addrinfo *nrf_res = NULL;
   2e7a8:	9101      	str	r1, [sp, #4]
	memset(&nrf_hints, 0, sizeof(struct nrf_addrinfo));
   2e7aa:	f000 fdf3 	bl	2f394 <memset>
	if (hints != NULL) {
   2e7ae:	b194      	cbz	r4, 2e7d6 <nrf91_socket_offload_getaddrinfo+0x42>
		error = z_to_nrf_addrinfo_hints(hints, &nrf_hints);
   2e7b0:	a902      	add	r1, sp, #8
   2e7b2:	4620      	mov	r0, r4
   2e7b4:	f7ff febf 	bl	2e536 <z_to_nrf_addrinfo_hints>
		if (error == -EPROTONOSUPPORT) {
   2e7b8:	f110 0f7b 	cmn.w	r0, #123	; 0x7b
   2e7bc:	f000 80bf 	beq.w	2e93e <nrf91_socket_offload_getaddrinfo+0x1aa>
		} else if (error == -EAFNOSUPPORT) {
   2e7c0:	306a      	adds	r0, #106	; 0x6a
   2e7c2:	f000 80bf 	beq.w	2e944 <nrf91_socket_offload_getaddrinfo+0x1b0>
		if (hints->ai_next != NULL) {
   2e7c6:	69e0      	ldr	r0, [r4, #28]
   2e7c8:	b120      	cbz	r0, 2e7d4 <nrf91_socket_offload_getaddrinfo+0x40>
			z_to_nrf_addrinfo_hints(hints->ai_next, &nrf_hints_pdn);
   2e7ca:	ac0a      	add	r4, sp, #40	; 0x28
   2e7cc:	4621      	mov	r1, r4
   2e7ce:	f7ff feb2 	bl	2e536 <z_to_nrf_addrinfo_hints>
			nrf_hints.ai_next = &nrf_hints_pdn;
   2e7d2:	9409      	str	r4, [sp, #36]	; 0x24
		nrf_hints_ptr = &nrf_hints;
   2e7d4:	ac02      	add	r4, sp, #8
	int retval = nrf_getaddrinfo(node, service, nrf_hints_ptr, &nrf_res);
   2e7d6:	4628      	mov	r0, r5
   2e7d8:	ab01      	add	r3, sp, #4
   2e7da:	4622      	mov	r2, r4
   2e7dc:	4631      	mov	r1, r6
   2e7de:	f7f3 fa31 	bl	21c44 <nrf_getaddrinfo>
	if (retval != 0) {
   2e7e2:	4605      	mov	r5, r0
   2e7e4:	b1b0      	cbz	r0, 2e814 <nrf91_socket_offload_getaddrinfo+0x80>
	switch (nrf_error) {
   2e7e6:	2823      	cmp	r0, #35	; 0x23
   2e7e8:	f000 80af 	beq.w	2e94a <nrf91_socket_offload_getaddrinfo+0x1b6>
   2e7ec:	dc0a      	bgt.n	2e804 <nrf91_socket_offload_getaddrinfo+0x70>
		return DNS_EAI_SYSTEM;
   2e7ee:	280c      	cmp	r0, #12
   2e7f0:	bf08      	it	eq
   2e7f2:	f06f 0509 	mvneq.w	r5, #9
   2e7f6:	bf18      	it	ne
   2e7f8:	f06f 050a 	mvnne.w	r5, #10
}
   2e7fc:	4628      	mov	r0, r5
   2e7fe:	b013      	add	sp, #76	; 0x4c
   2e800:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	switch (nrf_error) {
   2e804:	282f      	cmp	r0, #47	; 0x2f
   2e806:	f000 80a3 	beq.w	2e950 <nrf91_socket_offload_getaddrinfo+0x1bc>
		return DNS_EAI_SYSTEM;
   2e80a:	2873      	cmp	r0, #115	; 0x73
   2e80c:	bf08      	it	eq
   2e80e:	f06f 0563 	mvneq.w	r5, #99	; 0x63
   2e812:	e7f0      	b.n	2e7f6 <nrf91_socket_offload_getaddrinfo+0x62>
	struct addrinfo *latest_z_res = NULL;
   2e814:	4680      	mov	r8, r0
	z_out->ai_next = NULL;
   2e816:	4681      	mov	r9, r0
	struct nrf_addrinfo *next_nrf_res = nrf_res;
   2e818:	9e01      	ldr	r6, [sp, #4]
	*res = NULL;
   2e81a:	6038      	str	r0, [r7, #0]
	while ((retval == 0) && (next_nrf_res != NULL)) {
   2e81c:	b91e      	cbnz	r6, 2e826 <nrf91_socket_offload_getaddrinfo+0x92>
	nrf_freeaddrinfo(nrf_res);
   2e81e:	9801      	ldr	r0, [sp, #4]
   2e820:	f7f3 fa12 	bl	21c48 <nrf_freeaddrinfo>
	return retval;
   2e824:	e7ea      	b.n	2e7fc <nrf91_socket_offload_getaddrinfo+0x68>
		struct addrinfo *next_z_res = k_malloc(sizeof(struct addrinfo));
   2e826:	2020      	movs	r0, #32
   2e828:	f7f8 f84a 	bl	268c0 <k_malloc>
		if (next_z_res == NULL) {
   2e82c:	4604      	mov	r4, r0
   2e82e:	2800      	cmp	r0, #0
   2e830:	d07a      	beq.n	2e928 <nrf91_socket_offload_getaddrinfo+0x194>
	family = nrf_to_z_family(nrf_in->ai_family);
   2e832:	6872      	ldr	r2, [r6, #4]
	z_out->ai_socktype = nrf_in->ai_socktype;
   2e834:	68b3      	ldr	r3, [r6, #8]
	switch (nrf_family) {
   2e836:	2a05      	cmp	r2, #5
	z_out->ai_canonname = NULL; /* TODO Do proper content copy. */
   2e838:	e9c0 9906 	strd	r9, r9, [r0, #24]
	z_out->ai_flags = nrf_to_z_addrinfo_flags(nrf_in->ai_flags);
   2e83c:	f8c0 9000 	str.w	r9, [r0]
	z_out->ai_socktype = nrf_in->ai_socktype;
   2e840:	6083      	str	r3, [r0, #8]
	switch (nrf_family) {
   2e842:	d033      	beq.n	2e8ac <nrf91_socket_offload_getaddrinfo+0x118>
   2e844:	dc09      	bgt.n	2e85a <nrf91_socket_offload_getaddrinfo+0xc6>
   2e846:	2a01      	cmp	r2, #1
   2e848:	d032      	beq.n	2e8b0 <nrf91_socket_offload_getaddrinfo+0x11c>
   2e84a:	2a02      	cmp	r2, #2
   2e84c:	d032      	beq.n	2e8b4 <nrf91_socket_offload_getaddrinfo+0x120>
			k_free(next_z_res);
   2e84e:	4620      	mov	r0, r4
   2e850:	f000 fbb1 	bl	2efb6 <k_free>
			retval = DNS_EAI_ADDRFAMILY;
   2e854:	f06f 0508 	mvn.w	r5, #8
   2e858:	e068      	b.n	2e92c <nrf91_socket_offload_getaddrinfo+0x198>
	switch (nrf_family) {
   2e85a:	2a0a      	cmp	r2, #10
   2e85c:	d02c      	beq.n	2e8b8 <nrf91_socket_offload_getaddrinfo+0x124>
   2e85e:	2a66      	cmp	r2, #102	; 0x66
   2e860:	d1f5      	bne.n	2e84e <nrf91_socket_offload_getaddrinfo+0xba>
		return AF_LTE;
   2e862:	4613      	mov	r3, r2
	z_out->ai_family = family;
   2e864:	6063      	str	r3, [r4, #4]
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   2e866:	68f3      	ldr	r3, [r6, #12]
	switch (proto) {
   2e868:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
   2e86c:	d045      	beq.n	2e8fa <nrf91_socket_offload_getaddrinfo+0x166>
   2e86e:	dc25      	bgt.n	2e8bc <nrf91_socket_offload_getaddrinfo+0x128>
   2e870:	2b01      	cmp	r3, #1
   2e872:	d047      	beq.n	2e904 <nrf91_socket_offload_getaddrinfo+0x170>
   2e874:	2b02      	cmp	r3, #2
   2e876:	d043      	beq.n	2e900 <nrf91_socket_offload_getaddrinfo+0x16c>
   2e878:	bb43      	cbnz	r3, 2e8cc <nrf91_socket_offload_getaddrinfo+0x138>
	if (nrf_in->ai_family == NRF_AF_INET) {
   2e87a:	2a02      	cmp	r2, #2
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   2e87c:	60e3      	str	r3, [r4, #12]
	if (nrf_in->ai_family == NRF_AF_INET) {
   2e87e:	d143      	bne.n	2e908 <nrf91_socket_offload_getaddrinfo+0x174>
		z_out->ai_addr = k_malloc(sizeof(struct sockaddr_in));
   2e880:	2008      	movs	r0, #8
   2e882:	f7f8 f81d 	bl	268c0 <k_malloc>
   2e886:	6160      	str	r0, [r4, #20]
		if (z_out->ai_addr == NULL) {
   2e888:	2800      	cmp	r0, #0
   2e88a:	d04a      	beq.n	2e922 <nrf91_socket_offload_getaddrinfo+0x18e>
		z_out->ai_addrlen  = sizeof(struct sockaddr_in);
   2e88c:	2308      	movs	r3, #8
   2e88e:	6123      	str	r3, [r4, #16]
			(const struct nrf_sockaddr_in *)nrf_in->ai_addr);
   2e890:	6973      	ldr	r3, [r6, #20]
	ptr->sin_port = nrf_in->sin_port;
   2e892:	891a      	ldrh	r2, [r3, #8]
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   2e894:	68db      	ldr	r3, [r3, #12]
	ptr->sin_port = nrf_in->sin_port;
   2e896:	8042      	strh	r2, [r0, #2]
	ptr->sin_family = AF_INET;
   2e898:	2201      	movs	r2, #1
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   2e89a:	6043      	str	r3, [r0, #4]
	ptr->sin_family = AF_INET;
   2e89c:	8002      	strh	r2, [r0, #0]
		if (latest_z_res == NULL) {
   2e89e:	f1b8 0f00 	cmp.w	r8, #0
   2e8a2:	d149      	bne.n	2e938 <nrf91_socket_offload_getaddrinfo+0x1a4>
			*res = next_z_res;
   2e8a4:	603c      	str	r4, [r7, #0]
		next_nrf_res = next_nrf_res->ai_next;
   2e8a6:	69f6      	ldr	r6, [r6, #28]
   2e8a8:	46a0      	mov	r8, r4
   2e8aa:	e7b7      	b.n	2e81c <nrf91_socket_offload_getaddrinfo+0x88>
		return AF_PACKET;
   2e8ac:	2303      	movs	r3, #3
   2e8ae:	e7d9      	b.n	2e864 <nrf91_socket_offload_getaddrinfo+0xd0>
		return AF_LOCAL;
   2e8b0:	2367      	movs	r3, #103	; 0x67
   2e8b2:	e7d7      	b.n	2e864 <nrf91_socket_offload_getaddrinfo+0xd0>
		return AF_INET;
   2e8b4:	2301      	movs	r3, #1
   2e8b6:	e7d5      	b.n	2e864 <nrf91_socket_offload_getaddrinfo+0xd0>
		return AF_INET6;
   2e8b8:	2302      	movs	r3, #2
   2e8ba:	e7d3      	b.n	2e864 <nrf91_socket_offload_getaddrinfo+0xd0>
	switch (proto) {
   2e8bc:	f240 2101 	movw	r1, #513	; 0x201
   2e8c0:	428b      	cmp	r3, r1
   2e8c2:	d0da      	beq.n	2e87a <nrf91_socket_offload_getaddrinfo+0xe6>
   2e8c4:	dc0d      	bgt.n	2e8e2 <nrf91_socket_offload_getaddrinfo+0x14e>
   2e8c6:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   2e8ca:	d013      	beq.n	2e8f4 <nrf91_socket_offload_getaddrinfo+0x160>
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   2e8cc:	f06f 037a 	mvn.w	r3, #122	; 0x7a
   2e8d0:	60e3      	str	r3, [r4, #12]
		z_out->ai_addr = NULL;
   2e8d2:	2300      	movs	r3, #0
   2e8d4:	6163      	str	r3, [r4, #20]
			k_free(next_z_res);
   2e8d6:	4620      	mov	r0, r4
   2e8d8:	f000 fb6d 	bl	2efb6 <k_free>
			retval = DNS_EAI_SOCKTYPE;
   2e8dc:	f06f 0506 	mvn.w	r5, #6
   2e8e0:	e024      	b.n	2e92c <nrf91_socket_offload_getaddrinfo+0x198>
	switch (proto) {
   2e8e2:	f240 2102 	movw	r1, #514	; 0x202
   2e8e6:	428b      	cmp	r3, r1
   2e8e8:	d0c7      	beq.n	2e87a <nrf91_socket_offload_getaddrinfo+0xe6>
   2e8ea:	f240 2103 	movw	r1, #515	; 0x203
   2e8ee:	428b      	cmp	r3, r1
   2e8f0:	d0c3      	beq.n	2e87a <nrf91_socket_offload_getaddrinfo+0xe6>
   2e8f2:	e7eb      	b.n	2e8cc <nrf91_socket_offload_getaddrinfo+0x138>
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   2e8f4:	f240 1311 	movw	r3, #273	; 0x111
   2e8f8:	e7bf      	b.n	2e87a <nrf91_socket_offload_getaddrinfo+0xe6>
   2e8fa:	f44f 7381 	mov.w	r3, #258	; 0x102
   2e8fe:	e7bc      	b.n	2e87a <nrf91_socket_offload_getaddrinfo+0xe6>
   2e900:	2311      	movs	r3, #17
   2e902:	e7ba      	b.n	2e87a <nrf91_socket_offload_getaddrinfo+0xe6>
   2e904:	2306      	movs	r3, #6
   2e906:	e7b8      	b.n	2e87a <nrf91_socket_offload_getaddrinfo+0xe6>
	} else if (nrf_in->ai_family == NRF_AF_INET6) {
   2e908:	2a0a      	cmp	r2, #10
   2e90a:	d1e4      	bne.n	2e8d6 <nrf91_socket_offload_getaddrinfo+0x142>
		z_out->ai_addr = k_malloc(sizeof(struct sockaddr_in6));
   2e90c:	2018      	movs	r0, #24
   2e90e:	f7f7 ffd7 	bl	268c0 <k_malloc>
   2e912:	6160      	str	r0, [r4, #20]
		if (z_out->ai_addr == NULL) {
   2e914:	b128      	cbz	r0, 2e922 <nrf91_socket_offload_getaddrinfo+0x18e>
		z_out->ai_addrlen  = sizeof(struct sockaddr_in6);
   2e916:	2318      	movs	r3, #24
		nrf_to_z_ipv6(z_out->ai_addr,
   2e918:	6971      	ldr	r1, [r6, #20]
		z_out->ai_addrlen  = sizeof(struct sockaddr_in6);
   2e91a:	6123      	str	r3, [r4, #16]
		nrf_to_z_ipv6(z_out->ai_addr,
   2e91c:	f7ff ff26 	bl	2e76c <nrf_to_z_ipv6>
		} else if (error == -EAFNOSUPPORT) {
   2e920:	e7bd      	b.n	2e89e <nrf91_socket_offload_getaddrinfo+0x10a>
			k_free(next_z_res);
   2e922:	4620      	mov	r0, r4
   2e924:	f000 fb47 	bl	2efb6 <k_free>
			retval = DNS_EAI_MEMORY;
   2e928:	f06f 0509 	mvn.w	r5, #9
		nrf91_socket_offload_freeaddrinfo(*res);
   2e92c:	6838      	ldr	r0, [r7, #0]
   2e92e:	f7ff fdf5 	bl	2e51c <nrf91_socket_offload_freeaddrinfo>
		*res = NULL;
   2e932:	2300      	movs	r3, #0
   2e934:	603b      	str	r3, [r7, #0]
   2e936:	e772      	b.n	2e81e <nrf91_socket_offload_getaddrinfo+0x8a>
			latest_z_res->ai_next = next_z_res;
   2e938:	f8c8 401c 	str.w	r4, [r8, #28]
   2e93c:	e7b3      	b.n	2e8a6 <nrf91_socket_offload_getaddrinfo+0x112>
			return DNS_EAI_SOCKTYPE;
   2e93e:	f06f 0506 	mvn.w	r5, #6
   2e942:	e75b      	b.n	2e7fc <nrf91_socket_offload_getaddrinfo+0x68>
			return DNS_EAI_ADDRFAMILY;
   2e944:	f06f 0508 	mvn.w	r5, #8
   2e948:	e758      	b.n	2e7fc <nrf91_socket_offload_getaddrinfo+0x68>
		return DNS_EAI_AGAIN;
   2e94a:	f06f 0502 	mvn.w	r5, #2
   2e94e:	e755      	b.n	2e7fc <nrf91_socket_offload_getaddrinfo+0x68>
		return DNS_EAI_NONAME;
   2e950:	f06f 0501 	mvn.w	r5, #1
   2e954:	e752      	b.n	2e7fc <nrf91_socket_offload_getaddrinfo+0x68>

0002e956 <z_to_nrf_ipv6>:
	nrf_out->sin6_len = sizeof(struct nrf_sockaddr_in6);
   2e956:	2224      	movs	r2, #36	; 0x24
{
   2e958:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_out->sin6_len = sizeof(struct nrf_sockaddr_in6);
   2e95a:	700a      	strb	r2, [r1, #0]
	nrf_out->sin6_port = ptr->sin6_port;
   2e95c:	8842      	ldrh	r2, [r0, #2]
{
   2e95e:	4604      	mov	r4, r0
	nrf_out->sin6_port = ptr->sin6_port;
   2e960:	810a      	strh	r2, [r1, #8]
	nrf_out->sin6_family = NRF_AF_INET6;
   2e962:	220a      	movs	r2, #10
{
   2e964:	460b      	mov	r3, r1
	nrf_out->sin6_family = NRF_AF_INET6;
   2e966:	604a      	str	r2, [r1, #4]
   2e968:	f101 0610 	add.w	r6, r1, #16
   2e96c:	1d02      	adds	r2, r0, #4
   2e96e:	f100 0714 	add.w	r7, r0, #20
   2e972:	4635      	mov	r5, r6
   2e974:	6810      	ldr	r0, [r2, #0]
   2e976:	6851      	ldr	r1, [r2, #4]
   2e978:	3208      	adds	r2, #8
   2e97a:	c503      	stmia	r5!, {r0, r1}
   2e97c:	42ba      	cmp	r2, r7
   2e97e:	462e      	mov	r6, r5
   2e980:	d1f7      	bne.n	2e972 <z_to_nrf_ipv6+0x1c>
	nrf_out->sin6_scope_id = (u32_t)ptr->sin6_scope_id;
   2e982:	7d22      	ldrb	r2, [r4, #20]
   2e984:	621a      	str	r2, [r3, #32]
}
   2e986:	bdf0      	pop	{r4, r5, r6, r7, pc}

0002e988 <nrf91_socket_offload_sendto>:
{
   2e988:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2e98c:	b08d      	sub	sp, #52	; 0x34
   2e98e:	9c14      	ldr	r4, [sp, #80]	; 0x50
   2e990:	4605      	mov	r5, r0
   2e992:	460e      	mov	r6, r1
   2e994:	4617      	mov	r7, r2
   2e996:	4698      	mov	r8, r3
	if (to == NULL) {
   2e998:	b96c      	cbnz	r4, 2e9b6 <nrf91_socket_offload_sendto+0x2e>
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), NULL,
   2e99a:	4618      	mov	r0, r3
   2e99c:	f7ff fd74 	bl	2e488 <z_to_nrf_flags>
   2e9a0:	e9cd 4400 	strd	r4, r4, [sp]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv6,
   2e9a4:	4603      	mov	r3, r0
   2e9a6:	463a      	mov	r2, r7
   2e9a8:	4631      	mov	r1, r6
   2e9aa:	4628      	mov	r0, r5
   2e9ac:	f7f3 f85c 	bl	21a68 <nrf_sendto>
}
   2e9b0:	b00d      	add	sp, #52	; 0x34
   2e9b2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if (to->sa_family == AF_INET) {
   2e9b6:	8823      	ldrh	r3, [r4, #0]
   2e9b8:	2b01      	cmp	r3, #1
   2e9ba:	d110      	bne.n	2e9de <nrf91_socket_offload_sendto+0x56>
	nrf_out->sin_port = ptr->sin_port;
   2e9bc:	8863      	ldrh	r3, [r4, #2]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   2e9be:	2110      	movs	r1, #16
	nrf_out->sin_port = ptr->sin_port;
   2e9c0:	f8ad 3014 	strh.w	r3, [sp, #20]
	nrf_out->sin_family = NRF_AF_INET;
   2e9c4:	2302      	movs	r3, #2
   2e9c6:	9304      	str	r3, [sp, #16]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   2e9c8:	6863      	ldr	r3, [r4, #4]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv4,
   2e9ca:	4640      	mov	r0, r8
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   2e9cc:	9306      	str	r3, [sp, #24]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   2e9ce:	f88d 100c 	strb.w	r1, [sp, #12]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv4,
   2e9d2:	f7ff fd59 	bl	2e488 <z_to_nrf_flags>
   2e9d6:	ab03      	add	r3, sp, #12
   2e9d8:	9101      	str	r1, [sp, #4]
   2e9da:	9300      	str	r3, [sp, #0]
   2e9dc:	e7e2      	b.n	2e9a4 <nrf91_socket_offload_sendto+0x1c>
	} else if (to->sa_family == AF_INET6) {
   2e9de:	2b02      	cmp	r3, #2
   2e9e0:	d10c      	bne.n	2e9fc <nrf91_socket_offload_sendto+0x74>
		z_to_nrf_ipv6(to, &ipv6);
   2e9e2:	f10d 090c 	add.w	r9, sp, #12
   2e9e6:	4649      	mov	r1, r9
   2e9e8:	4620      	mov	r0, r4
   2e9ea:	f7ff ffb4 	bl	2e956 <z_to_nrf_ipv6>
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv6,
   2e9ee:	4640      	mov	r0, r8
   2e9f0:	f7ff fd4a 	bl	2e488 <z_to_nrf_flags>
   2e9f4:	2324      	movs	r3, #36	; 0x24
   2e9f6:	e9cd 9300 	strd	r9, r3, [sp]
   2e9fa:	e7d3      	b.n	2e9a4 <nrf91_socket_offload_sendto+0x1c>
	errno = ENOTSUP;
   2e9fc:	f7fe fe20 	bl	2d640 <__errno>
   2ea00:	2386      	movs	r3, #134	; 0x86
   2ea02:	6003      	str	r3, [r0, #0]
	return retval;
   2ea04:	f04f 30ff 	mov.w	r0, #4294967295
   2ea08:	e7d2      	b.n	2e9b0 <nrf91_socket_offload_sendto+0x28>

0002ea0a <nrf91_socket_offload_recvfrom>:
{
   2ea0a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2ea0e:	4605      	mov	r5, r0
   2ea10:	b08c      	sub	sp, #48	; 0x30
   2ea12:	4618      	mov	r0, r3
   2ea14:	e9dd 4612 	ldrd	r4, r6, [sp, #72]	; 0x48
   2ea18:	4690      	mov	r8, r2
	if (from == NULL) {
   2ea1a:	f7ff fd35 	bl	2e488 <z_to_nrf_flags>
   2ea1e:	4603      	mov	r3, r0
   2ea20:	b954      	cbnz	r4, 2ea38 <nrf91_socket_offload_recvfrom+0x2e>
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags), NULL,
   2ea22:	4628      	mov	r0, r5
   2ea24:	e9cd 4400 	strd	r4, r4, [sp]
   2ea28:	4642      	mov	r2, r8
   2ea2a:	f7f3 f853 	bl	21ad4 <nrf_recvfrom>
   2ea2e:	4605      	mov	r5, r0
}
   2ea30:	4628      	mov	r0, r5
   2ea32:	b00c      	add	sp, #48	; 0x30
   2ea34:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		nrf_socklen_t sock_len = sizeof(struct nrf_sockaddr_in6);
   2ea38:	2224      	movs	r2, #36	; 0x24
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags),
   2ea3a:	af03      	add	r7, sp, #12
		nrf_socklen_t sock_len = sizeof(struct nrf_sockaddr_in6);
   2ea3c:	9202      	str	r2, [sp, #8]
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags),
   2ea3e:	aa02      	add	r2, sp, #8
   2ea40:	9201      	str	r2, [sp, #4]
   2ea42:	4628      	mov	r0, r5
   2ea44:	9700      	str	r7, [sp, #0]
   2ea46:	4642      	mov	r2, r8
   2ea48:	f7f3 f844 	bl	21ad4 <nrf_recvfrom>
		if (cliaddr->sa_family == NRF_AF_INET) {
   2ea4c:	9b04      	ldr	r3, [sp, #16]
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags),
   2ea4e:	4605      	mov	r5, r0
		if (cliaddr->sa_family == NRF_AF_INET) {
   2ea50:	2b02      	cmp	r3, #2
   2ea52:	d109      	bne.n	2ea68 <nrf91_socket_offload_recvfrom+0x5e>
	ptr->sin_port = nrf_in->sin_port;
   2ea54:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   2ea58:	8063      	strh	r3, [r4, #2]
	ptr->sin_family = AF_INET;
   2ea5a:	2301      	movs	r3, #1
   2ea5c:	8023      	strh	r3, [r4, #0]
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   2ea5e:	9b06      	ldr	r3, [sp, #24]
   2ea60:	6063      	str	r3, [r4, #4]
			*fromlen = sizeof(struct sockaddr_in);
   2ea62:	2308      	movs	r3, #8
			*fromlen = sizeof(struct sockaddr_in6);
   2ea64:	6033      	str	r3, [r6, #0]
	return retval;
   2ea66:	e7e3      	b.n	2ea30 <nrf91_socket_offload_recvfrom+0x26>
		} else if (cliaddr->sa_family == NRF_AF_INET6) {
   2ea68:	2b0a      	cmp	r3, #10
   2ea6a:	d1e1      	bne.n	2ea30 <nrf91_socket_offload_recvfrom+0x26>
			nrf_to_z_ipv6(from, (struct nrf_sockaddr_in6 *)
   2ea6c:	4639      	mov	r1, r7
   2ea6e:	4620      	mov	r0, r4
   2ea70:	f7ff fe7c 	bl	2e76c <nrf_to_z_ipv6>
			*fromlen = sizeof(struct sockaddr_in6);
   2ea74:	2318      	movs	r3, #24
   2ea76:	e7f5      	b.n	2ea64 <nrf91_socket_offload_recvfrom+0x5a>

0002ea78 <nrf91_socket_offload_connect>:
{
   2ea78:	b530      	push	{r4, r5, lr}
	if (addr->sa_family == AF_INET) {
   2ea7a:	880c      	ldrh	r4, [r1, #0]
{
   2ea7c:	b08b      	sub	sp, #44	; 0x2c
	if (addr->sa_family == AF_INET) {
   2ea7e:	2c01      	cmp	r4, #1
{
   2ea80:	4605      	mov	r5, r0
   2ea82:	460b      	mov	r3, r1
	if (addr->sa_family == AF_INET) {
   2ea84:	d10e      	bne.n	2eaa4 <nrf91_socket_offload_connect+0x2c>
	nrf_out->sin_port = ptr->sin_port;
   2ea86:	8849      	ldrh	r1, [r1, #2]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   2ea88:	2210      	movs	r2, #16
	nrf_out->sin_port = ptr->sin_port;
   2ea8a:	f8ad 100c 	strh.w	r1, [sp, #12]
	nrf_out->sin_family = NRF_AF_INET;
   2ea8e:	2102      	movs	r1, #2
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   2ea90:	685b      	ldr	r3, [r3, #4]
	nrf_out->sin_family = NRF_AF_INET;
   2ea92:	9102      	str	r1, [sp, #8]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   2ea94:	f88d 2004 	strb.w	r2, [sp, #4]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   2ea98:	9304      	str	r3, [sp, #16]
		retval = nrf_connect(sd, (const struct nrf_sockaddr_in *)&ipv4,
   2ea9a:	a901      	add	r1, sp, #4
		retval = nrf_connect(sd, (const struct nrf_sockaddr *)&ipv6,
   2ea9c:	f7f3 f850 	bl	21b40 <nrf_connect>
}
   2eaa0:	b00b      	add	sp, #44	; 0x2c
   2eaa2:	bd30      	pop	{r4, r5, pc}
	} else if (addr->sa_family == AF_INET6) {
   2eaa4:	2c02      	cmp	r4, #2
   2eaa6:	d107      	bne.n	2eab8 <nrf91_socket_offload_connect+0x40>
		z_to_nrf_ipv6(addr, &ipv6);
   2eaa8:	a901      	add	r1, sp, #4
   2eaaa:	4618      	mov	r0, r3
   2eaac:	f7ff ff53 	bl	2e956 <z_to_nrf_ipv6>
		retval = nrf_connect(sd, (const struct nrf_sockaddr *)&ipv6,
   2eab0:	2224      	movs	r2, #36	; 0x24
   2eab2:	a901      	add	r1, sp, #4
   2eab4:	4628      	mov	r0, r5
   2eab6:	e7f1      	b.n	2ea9c <nrf91_socket_offload_connect+0x24>
		retval = nrf_connect(sd, (void *)addr, addrlen);
   2eab8:	f7f3 f842 	bl	21b40 <nrf_connect>
		if (retval < 0) {
   2eabc:	2800      	cmp	r0, #0
   2eabe:	daef      	bge.n	2eaa0 <nrf91_socket_offload_connect+0x28>
	errno = ENOTSUP;
   2eac0:	f7fe fdbe 	bl	2d640 <__errno>
   2eac4:	2386      	movs	r3, #134	; 0x86
   2eac6:	6003      	str	r3, [r0, #0]
   2eac8:	f04f 30ff 	mov.w	r0, #4294967295
   2eacc:	e7e8      	b.n	2eaa0 <nrf91_socket_offload_connect+0x28>

0002eace <nrf91_socket_offload_accept>:
{
   2eace:	b5f0      	push	{r4, r5, r6, r7, lr}
   2ead0:	4616      	mov	r6, r2
   2ead2:	b08b      	sub	sp, #44	; 0x2c
	if ((addr != NULL) && (addrlen != NULL)) {
   2ead4:	460c      	mov	r4, r1
   2ead6:	b1f1      	cbz	r1, 2eb16 <nrf91_socket_offload_accept+0x48>
   2ead8:	b302      	cbz	r2, 2eb1c <nrf91_socket_offload_accept+0x4e>
		if (*addrlen == sizeof(struct sockaddr_in)) {
   2eada:	6813      	ldr	r3, [r2, #0]
		nrf_addrlen_ptr = &nrf_addrlen;
   2eadc:	466a      	mov	r2, sp
		if (*addrlen == sizeof(struct sockaddr_in)) {
   2eade:	2b08      	cmp	r3, #8
			nrf_addrlen = sizeof(struct nrf_sockaddr_in);
   2eae0:	bf0c      	ite	eq
   2eae2:	2310      	moveq	r3, #16
			nrf_addrlen = sizeof(struct nrf_sockaddr_in6);
   2eae4:	2324      	movne	r3, #36	; 0x24
		nrf_addr_ptr = (struct nrf_sockaddr *)&nrf_addr;
   2eae6:	ad01      	add	r5, sp, #4
			nrf_addrlen = sizeof(struct nrf_sockaddr_in6);
   2eae8:	9300      	str	r3, [sp, #0]
	retval = nrf_accept(sd, nrf_addr_ptr, nrf_addrlen_ptr);
   2eaea:	4629      	mov	r1, r5
   2eaec:	f7f3 f84a 	bl	21b84 <nrf_accept>
	if (retval < 0) {
   2eaf0:	1e07      	subs	r7, r0, #0
   2eaf2:	db22      	blt.n	2eb3a <nrf91_socket_offload_accept+0x6c>
	if ((addr != NULL) && (addrlen != NULL)) {
   2eaf4:	b164      	cbz	r4, 2eb10 <nrf91_socket_offload_accept+0x42>
   2eaf6:	b15e      	cbz	r6, 2eb10 <nrf91_socket_offload_accept+0x42>
		if (nrf_addr_ptr->sa_family == NRF_AF_INET) {
   2eaf8:	686b      	ldr	r3, [r5, #4]
   2eafa:	2b02      	cmp	r3, #2
   2eafc:	d110      	bne.n	2eb20 <nrf91_socket_offload_accept+0x52>
			*addrlen = sizeof(struct sockaddr_in);
   2eafe:	2308      	movs	r3, #8
   2eb00:	6033      	str	r3, [r6, #0]
	ptr->sin_port = nrf_in->sin_port;
   2eb02:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   2eb06:	8063      	strh	r3, [r4, #2]
	ptr->sin_family = AF_INET;
   2eb08:	2301      	movs	r3, #1
   2eb0a:	8023      	strh	r3, [r4, #0]
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   2eb0c:	9b04      	ldr	r3, [sp, #16]
   2eb0e:	6063      	str	r3, [r4, #4]
}
   2eb10:	4638      	mov	r0, r7
   2eb12:	b00b      	add	sp, #44	; 0x2c
   2eb14:	bdf0      	pop	{r4, r5, r6, r7, pc}
	nrf_socklen_t *nrf_addrlen_ptr = NULL;
   2eb16:	460a      	mov	r2, r1
	struct nrf_sockaddr *nrf_addr_ptr = NULL;
   2eb18:	460d      	mov	r5, r1
   2eb1a:	e7e6      	b.n	2eaea <nrf91_socket_offload_accept+0x1c>
   2eb1c:	4615      	mov	r5, r2
   2eb1e:	e7e4      	b.n	2eaea <nrf91_socket_offload_accept+0x1c>
		} else if (nrf_addr_ptr->sa_family == NRF_AF_INET6) {
   2eb20:	2b0a      	cmp	r3, #10
   2eb22:	d106      	bne.n	2eb32 <nrf91_socket_offload_accept+0x64>
			*addrlen = sizeof(struct sockaddr_in6);
   2eb24:	2318      	movs	r3, #24
			nrf_to_z_ipv6(
   2eb26:	a901      	add	r1, sp, #4
			*addrlen = sizeof(struct sockaddr_in6);
   2eb28:	6033      	str	r3, [r6, #0]
			nrf_to_z_ipv6(
   2eb2a:	4620      	mov	r0, r4
   2eb2c:	f7ff fe1e 	bl	2e76c <nrf_to_z_ipv6>
   2eb30:	e7ee      	b.n	2eb10 <nrf91_socket_offload_accept+0x42>
	errno = ENOTSUP;
   2eb32:	f7fe fd85 	bl	2d640 <__errno>
   2eb36:	2386      	movs	r3, #134	; 0x86
   2eb38:	6003      	str	r3, [r0, #0]
		return -1;
   2eb3a:	f04f 37ff 	mov.w	r7, #4294967295
   2eb3e:	e7e7      	b.n	2eb10 <nrf91_socket_offload_accept+0x42>

0002eb40 <nrf91_socket_offload_socket>:
{
   2eb40:	b510      	push	{r4, lr}
	family = z_to_nrf_family(family);
   2eb42:	b280      	uxth	r0, r0
   2eb44:	f7ff fcaa 	bl	2e49c <z_to_nrf_family>
	if (family == -EAFNOSUPPORT) {
   2eb48:	f110 0f6a 	cmn.w	r0, #106	; 0x6a
	family = z_to_nrf_family(family);
   2eb4c:	4604      	mov	r4, r0
	if (family == -EAFNOSUPPORT) {
   2eb4e:	d106      	bne.n	2eb5e <nrf91_socket_offload_socket+0x1e>
		errno = EAFNOSUPPORT;
   2eb50:	f7fe fd76 	bl	2d640 <__errno>
   2eb54:	236a      	movs	r3, #106	; 0x6a
		errno = EPROTONOSUPPORT;
   2eb56:	6003      	str	r3, [r0, #0]
}
   2eb58:	f04f 30ff 	mov.w	r0, #4294967295
   2eb5c:	bd10      	pop	{r4, pc}
	switch (socktype) {
   2eb5e:	2903      	cmp	r1, #3
   2eb60:	d003      	beq.n	2eb6a <nrf91_socket_offload_socket+0x2a>
		return NRF_SOCK_MGMT;
   2eb62:	2904      	cmp	r1, #4
   2eb64:	bf08      	it	eq
   2eb66:	f44f 7100 	moveq.w	r1, #512	; 0x200
	proto = z_to_nrf_protocol(proto);
   2eb6a:	4610      	mov	r0, r2
   2eb6c:	f7ff fcac 	bl	2e4c8 <z_to_nrf_protocol>
	if (proto == -EPROTONOSUPPORT) {
   2eb70:	f110 0f7b 	cmn.w	r0, #123	; 0x7b
	proto = z_to_nrf_protocol(proto);
   2eb74:	4602      	mov	r2, r0
	if (proto == -EPROTONOSUPPORT) {
   2eb76:	d103      	bne.n	2eb80 <nrf91_socket_offload_socket+0x40>
		errno = EPROTONOSUPPORT;
   2eb78:	f7fe fd62 	bl	2d640 <__errno>
   2eb7c:	237b      	movs	r3, #123	; 0x7b
   2eb7e:	e7ea      	b.n	2eb56 <nrf91_socket_offload_socket+0x16>
	retval = nrf_socket(family, type, proto);
   2eb80:	4620      	mov	r0, r4
}
   2eb82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	retval = nrf_socket(family, type, proto);
   2eb86:	f7f2 bf4f 	b.w	21a28 <nrf_socket>

0002eb8a <nrf91_socket_offload_setsockopt>:
{
   2eb8a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	switch (z_in_level) {
   2eb8e:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
{
   2eb92:	b086      	sub	sp, #24
   2eb94:	4680      	mov	r8, r0
   2eb96:	460c      	mov	r4, r1
   2eb98:	4617      	mov	r7, r2
   2eb9a:	461d      	mov	r5, r3
   2eb9c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
	switch (z_in_level) {
   2eb9e:	d002      	beq.n	2eba6 <nrf91_socket_offload_setsockopt+0x1c>
   2eba0:	dc1c      	bgt.n	2ebdc <nrf91_socket_offload_setsockopt+0x52>
   2eba2:	2901      	cmp	r1, #1
   2eba4:	d122      	bne.n	2ebec <nrf91_socket_offload_setsockopt+0x62>
	if (z_to_nrf_optname(level, optname, &nrf_optname) < 0)
   2eba6:	aa03      	add	r2, sp, #12
   2eba8:	4639      	mov	r1, r7
   2ebaa:	4620      	mov	r0, r4
   2ebac:	f7ec ff0c 	bl	1b9c8 <z_to_nrf_optname>
   2ebb0:	2800      	cmp	r0, #0
   2ebb2:	db1b      	blt.n	2ebec <nrf91_socket_offload_setsockopt+0x62>
	if ((level == SOL_SOCKET) && (optname == SO_RCVTIMEO)) {
   2ebb4:	2c01      	cmp	r4, #1
   2ebb6:	d107      	bne.n	2ebc8 <nrf91_socket_offload_setsockopt+0x3e>
   2ebb8:	2f14      	cmp	r7, #20
   2ebba:	d105      	bne.n	2ebc8 <nrf91_socket_offload_setsockopt+0x3e>
		nrf_optlen = sizeof(struct nrf_timeval);
   2ebbc:	2608      	movs	r6, #8
		nrf_rcvtimeo.tv_sec = ((struct timeval *)optval)->tv_sec;
   2ebbe:	682b      	ldr	r3, [r5, #0]
   2ebc0:	9304      	str	r3, [sp, #16]
		nrf_rcvtimeo.tv_usec = ((struct timeval *)optval)->tv_usec;
   2ebc2:	686b      	ldr	r3, [r5, #4]
		nrf_optval = &nrf_rcvtimeo;
   2ebc4:	ad04      	add	r5, sp, #16
		nrf_rcvtimeo.tv_usec = ((struct timeval *)optval)->tv_usec;
   2ebc6:	9305      	str	r3, [sp, #20]
	retval = nrf_setsockopt(sd, nrf_level, nrf_optname, nrf_optval,
   2ebc8:	9600      	str	r6, [sp, #0]
   2ebca:	462b      	mov	r3, r5
   2ebcc:	9a03      	ldr	r2, [sp, #12]
   2ebce:	4621      	mov	r1, r4
   2ebd0:	4640      	mov	r0, r8
   2ebd2:	f7f2 ffff 	bl	21bd4 <nrf_setsockopt>
}
   2ebd6:	b006      	add	sp, #24
   2ebd8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (z_in_level) {
   2ebdc:	f240 2302 	movw	r3, #514	; 0x202
   2ebe0:	4299      	cmp	r1, r3
   2ebe2:	d0e0      	beq.n	2eba6 <nrf91_socket_offload_setsockopt+0x1c>
   2ebe4:	f240 2303 	movw	r3, #515	; 0x203
   2ebe8:	4299      	cmp	r1, r3
   2ebea:	e7db      	b.n	2eba4 <nrf91_socket_offload_setsockopt+0x1a>
	errno = ENOPROTOOPT;
   2ebec:	f7fe fd28 	bl	2d640 <__errno>
   2ebf0:	236d      	movs	r3, #109	; 0x6d
   2ebf2:	6003      	str	r3, [r0, #0]
   2ebf4:	f04f 30ff 	mov.w	r0, #4294967295
   2ebf8:	e7ed      	b.n	2ebd6 <nrf91_socket_offload_setsockopt+0x4c>

0002ebfa <nrf91_socket_offload_bind>:
{
   2ebfa:	b510      	push	{r4, lr}
	if (addr->sa_family == AF_INET) {
   2ebfc:	880a      	ldrh	r2, [r1, #0]
{
   2ebfe:	b08a      	sub	sp, #40	; 0x28
	if (addr->sa_family == AF_INET) {
   2ec00:	2a01      	cmp	r2, #1
{
   2ec02:	4604      	mov	r4, r0
   2ec04:	460b      	mov	r3, r1
	if (addr->sa_family == AF_INET) {
   2ec06:	d10e      	bne.n	2ec26 <nrf91_socket_offload_bind+0x2c>
	nrf_out->sin_port = ptr->sin_port;
   2ec08:	8849      	ldrh	r1, [r1, #2]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   2ec0a:	2210      	movs	r2, #16
	nrf_out->sin_port = ptr->sin_port;
   2ec0c:	f8ad 100c 	strh.w	r1, [sp, #12]
	nrf_out->sin_family = NRF_AF_INET;
   2ec10:	2102      	movs	r1, #2
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   2ec12:	685b      	ldr	r3, [r3, #4]
	nrf_out->sin_family = NRF_AF_INET;
   2ec14:	9102      	str	r1, [sp, #8]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   2ec16:	f88d 2004 	strb.w	r2, [sp, #4]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   2ec1a:	9304      	str	r3, [sp, #16]
		retval = nrf_bind(sd, (const struct nrf_sockaddr *)&ipv4,
   2ec1c:	a901      	add	r1, sp, #4
		retval = nrf_bind(sd, (const struct nrf_sockaddr *)&ipv6,
   2ec1e:	f7f2 ffc7 	bl	21bb0 <nrf_bind>
}
   2ec22:	b00a      	add	sp, #40	; 0x28
   2ec24:	bd10      	pop	{r4, pc}
	} else if (addr->sa_family == AF_INET6) {
   2ec26:	2a02      	cmp	r2, #2
   2ec28:	d107      	bne.n	2ec3a <nrf91_socket_offload_bind+0x40>
		z_to_nrf_ipv6(addr, &ipv6);
   2ec2a:	a901      	add	r1, sp, #4
   2ec2c:	4618      	mov	r0, r3
   2ec2e:	f7ff fe92 	bl	2e956 <z_to_nrf_ipv6>
		retval = nrf_bind(sd, (const struct nrf_sockaddr *)&ipv6,
   2ec32:	2224      	movs	r2, #36	; 0x24
   2ec34:	a901      	add	r1, sp, #4
   2ec36:	4620      	mov	r0, r4
   2ec38:	e7f1      	b.n	2ec1e <nrf91_socket_offload_bind+0x24>
	errno = ENOTSUP;
   2ec3a:	f7fe fd01 	bl	2d640 <__errno>
   2ec3e:	2386      	movs	r3, #134	; 0x86
   2ec40:	6003      	str	r3, [r0, #0]
   2ec42:	f04f 30ff 	mov.w	r0, #4294967295
   2ec46:	e7ec      	b.n	2ec22 <nrf91_socket_offload_bind+0x28>

0002ec48 <z_impl_uart_irq_rx_enable>:
	if (api->irq_rx_enable) {
   2ec48:	6843      	ldr	r3, [r0, #4]
   2ec4a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   2ec4c:	b103      	cbz	r3, 2ec50 <z_impl_uart_irq_rx_enable+0x8>
		api->irq_rx_enable(dev);
   2ec4e:	4718      	bx	r3
}
   2ec50:	4770      	bx	lr

0002ec52 <response_handler>:
	write_uart_string(response);
   2ec52:	4608      	mov	r0, r1
   2ec54:	f7ed bb24 	b.w	1c2a0 <write_uart_string>

0002ec58 <is_lfcr>:
	if ((chr == '\r') || (chr == '\n')) {
   2ec58:	280d      	cmp	r0, #13
   2ec5a:	d004      	beq.n	2ec66 <is_lfcr+0xe>
   2ec5c:	f1a0 030a 	sub.w	r3, r0, #10
   2ec60:	4258      	negs	r0, r3
   2ec62:	4158      	adcs	r0, r3
   2ec64:	4770      	bx	lr
		return true;
   2ec66:	2001      	movs	r0, #1
}
   2ec68:	4770      	bx	lr

0002ec6a <skip_command_prefix>:
{
   2ec6a:	b510      	push	{r4, lr}
	*cmd += sizeof("AT") - 1;
   2ec6c:	6802      	ldr	r2, [r0, #0]
{
   2ec6e:	4601      	mov	r1, r0
	*cmd += sizeof("AT") - 1;
   2ec70:	1c93      	adds	r3, r2, #2
   2ec72:	6003      	str	r3, [r0, #0]
	if (is_lfcr(**cmd) || is_terminated(**cmd)) {
   2ec74:	7894      	ldrb	r4, [r2, #2]
   2ec76:	4620      	mov	r0, r4
   2ec78:	f7ff ffee 	bl	2ec58 <is_lfcr>
   2ec7c:	b910      	cbnz	r0, 2ec84 <skip_command_prefix+0x1a>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   2ec7e:	b10c      	cbz	r4, 2ec84 <skip_command_prefix+0x1a>
	(*cmd)++;
   2ec80:	3203      	adds	r2, #3
   2ec82:	600a      	str	r2, [r1, #0]
}
   2ec84:	bd10      	pop	{r4, pc}

0002ec86 <at_params_list_init>:
{
   2ec86:	b538      	push	{r3, r4, r5, lr}
   2ec88:	460d      	mov	r5, r1
	if (list == NULL) {
   2ec8a:	4604      	mov	r4, r0
   2ec8c:	b140      	cbz	r0, 2eca0 <at_params_list_init+0x1a>
	list->params = k_calloc(max_params_count, sizeof(struct at_param));
   2ec8e:	210c      	movs	r1, #12
   2ec90:	4628      	mov	r0, r5
   2ec92:	f000 f995 	bl	2efc0 <k_calloc>
   2ec96:	6060      	str	r0, [r4, #4]
	if (list->params == NULL) {
   2ec98:	b128      	cbz	r0, 2eca6 <at_params_list_init+0x20>
	return 0;
   2ec9a:	2000      	movs	r0, #0
	list->param_count = max_params_count;
   2ec9c:	6025      	str	r5, [r4, #0]
}
   2ec9e:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   2eca0:	f06f 0015 	mvn.w	r0, #21
   2eca4:	e7fb      	b.n	2ec9e <at_params_list_init+0x18>
		return -ENOMEM;
   2eca6:	f06f 000b 	mvn.w	r0, #11
   2ecaa:	e7f8      	b.n	2ec9e <at_params_list_init+0x18>

0002ecac <at_params_list_free>:

void at_params_list_free(struct at_param_list *list)
{
   2ecac:	b538      	push	{r3, r4, r5, lr}
	if (list == NULL || list->params == NULL) {
   2ecae:	4604      	mov	r4, r0
   2ecb0:	b148      	cbz	r0, 2ecc6 <at_params_list_free+0x1a>
   2ecb2:	6843      	ldr	r3, [r0, #4]
   2ecb4:	b13b      	cbz	r3, 2ecc6 <at_params_list_free+0x1a>
		return;
	}

	at_params_list_clear(list);

	list->param_count = 0;
   2ecb6:	2500      	movs	r5, #0
	at_params_list_clear(list);
   2ecb8:	f7ed ff32 	bl	1cb20 <at_params_list_clear>
	list->param_count = 0;
   2ecbc:	6025      	str	r5, [r4, #0]
	k_free(list->params);
   2ecbe:	6860      	ldr	r0, [r4, #4]
   2ecc0:	f000 f979 	bl	2efb6 <k_free>
	list->params = NULL;
   2ecc4:	6065      	str	r5, [r4, #4]
}
   2ecc6:	bd38      	pop	{r3, r4, r5, pc}

0002ecc8 <at_params_short_put>:

int at_params_short_put(const struct at_param_list *list, size_t index,
			u16_t value)
{
   2ecc8:	b538      	push	{r3, r4, r5, lr}
   2ecca:	4615      	mov	r5, r2
	if (list == NULL || list->params == NULL) {
   2eccc:	b910      	cbnz	r0, 2ecd4 <at_params_short_put+0xc>
		return -EINVAL;
   2ecce:	f06f 0015 	mvn.w	r0, #21
	at_param_clear(param);

	param->type = AT_PARAM_TYPE_NUM_SHORT;
	param->value.int_val = (u32_t)(value & USHRT_MAX);
	return 0;
}
   2ecd2:	bd38      	pop	{r3, r4, r5, pc}
	if (list == NULL || list->params == NULL) {
   2ecd4:	6843      	ldr	r3, [r0, #4]
   2ecd6:	2b00      	cmp	r3, #0
   2ecd8:	d0f9      	beq.n	2ecce <at_params_short_put+0x6>
	struct at_param *param = at_params_get(list, index);
   2ecda:	f7ed feb5 	bl	1ca48 <at_params_get>
	if (param == NULL) {
   2ecde:	4604      	mov	r4, r0
   2ece0:	2800      	cmp	r0, #0
   2ece2:	d0f4      	beq.n	2ecce <at_params_short_put+0x6>
	at_param_clear(param);
   2ece4:	f7ed fefa 	bl	1cadc <at_param_clear>
	param->type = AT_PARAM_TYPE_NUM_SHORT;
   2ece8:	2301      	movs	r3, #1
	param->value.int_val = (u32_t)(value & USHRT_MAX);
   2ecea:	60a5      	str	r5, [r4, #8]
	param->type = AT_PARAM_TYPE_NUM_SHORT;
   2ecec:	7023      	strb	r3, [r4, #0]
	return 0;
   2ecee:	2000      	movs	r0, #0
   2ecf0:	e7ef      	b.n	2ecd2 <at_params_short_put+0xa>

0002ecf2 <at_params_empty_put>:

int at_params_empty_put(const struct at_param_list *list, size_t index)
{
   2ecf2:	b510      	push	{r4, lr}
	if (list == NULL || list->params == NULL) {
   2ecf4:	b910      	cbnz	r0, 2ecfc <at_params_empty_put+0xa>
		return -EINVAL;
   2ecf6:	f06f 0015 	mvn.w	r0, #21

	param->type = AT_PARAM_TYPE_EMPTY;
	param->value.int_val = 0;

	return 0;
}
   2ecfa:	bd10      	pop	{r4, pc}
	if (list == NULL || list->params == NULL) {
   2ecfc:	6843      	ldr	r3, [r0, #4]
   2ecfe:	2b00      	cmp	r3, #0
   2ed00:	d0f9      	beq.n	2ecf6 <at_params_empty_put+0x4>
	struct at_param *param = at_params_get(list, index);
   2ed02:	f7ed fea1 	bl	1ca48 <at_params_get>
	if (param == NULL) {
   2ed06:	4604      	mov	r4, r0
   2ed08:	2800      	cmp	r0, #0
   2ed0a:	d0f4      	beq.n	2ecf6 <at_params_empty_put+0x4>
	at_param_clear(param);
   2ed0c:	f7ed fee6 	bl	1cadc <at_param_clear>
	param->type = AT_PARAM_TYPE_EMPTY;
   2ed10:	2305      	movs	r3, #5
	param->value.int_val = 0;
   2ed12:	2000      	movs	r0, #0
	param->type = AT_PARAM_TYPE_EMPTY;
   2ed14:	7023      	strb	r3, [r4, #0]
	param->value.int_val = 0;
   2ed16:	60a0      	str	r0, [r4, #8]
	return 0;
   2ed18:	e7ef      	b.n	2ecfa <at_params_empty_put+0x8>

0002ed1a <at_params_int_put>:

int at_params_int_put(const struct at_param_list *list, size_t index,
		      u32_t value)
{
   2ed1a:	b538      	push	{r3, r4, r5, lr}
   2ed1c:	4615      	mov	r5, r2
	if (list == NULL || list->params == NULL) {
   2ed1e:	b910      	cbnz	r0, 2ed26 <at_params_int_put+0xc>
		return -EINVAL;
   2ed20:	f06f 0015 	mvn.w	r0, #21
	at_param_clear(param);

	param->type = AT_PARAM_TYPE_NUM_INT;
	param->value.int_val = value;
	return 0;
}
   2ed24:	bd38      	pop	{r3, r4, r5, pc}
	if (list == NULL || list->params == NULL) {
   2ed26:	6843      	ldr	r3, [r0, #4]
   2ed28:	2b00      	cmp	r3, #0
   2ed2a:	d0f9      	beq.n	2ed20 <at_params_int_put+0x6>
	struct at_param *param = at_params_get(list, index);
   2ed2c:	f7ed fe8c 	bl	1ca48 <at_params_get>
	if (param == NULL) {
   2ed30:	4604      	mov	r4, r0
   2ed32:	2800      	cmp	r0, #0
   2ed34:	d0f4      	beq.n	2ed20 <at_params_int_put+0x6>
	at_param_clear(param);
   2ed36:	f7ed fed1 	bl	1cadc <at_param_clear>
	param->type = AT_PARAM_TYPE_NUM_INT;
   2ed3a:	2302      	movs	r3, #2
	param->value.int_val = value;
   2ed3c:	60a5      	str	r5, [r4, #8]
	param->type = AT_PARAM_TYPE_NUM_INT;
   2ed3e:	7023      	strb	r3, [r4, #0]
	return 0;
   2ed40:	2000      	movs	r0, #0
   2ed42:	e7ef      	b.n	2ed24 <at_params_int_put+0xa>

0002ed44 <at_params_string_put>:

int at_params_string_put(const struct at_param_list *list, size_t index,
			 const char *str, size_t str_len)
{
   2ed44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2ed46:	4616      	mov	r6, r2
   2ed48:	461d      	mov	r5, r3
	if (list == NULL || list->params == NULL || str == NULL) {
   2ed4a:	b910      	cbnz	r0, 2ed52 <at_params_string_put+0xe>
		return -EINVAL;
   2ed4c:	f06f 0015 	mvn.w	r0, #21
	param->size = str_len;
	param->type = AT_PARAM_TYPE_STRING;
	param->value.str_val = param_value;

	return 0;
}
   2ed50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (list == NULL || list->params == NULL || str == NULL) {
   2ed52:	6843      	ldr	r3, [r0, #4]
   2ed54:	2b00      	cmp	r3, #0
   2ed56:	d0f9      	beq.n	2ed4c <at_params_string_put+0x8>
   2ed58:	2a00      	cmp	r2, #0
   2ed5a:	d0f7      	beq.n	2ed4c <at_params_string_put+0x8>
	struct at_param *param = at_params_get(list, index);
   2ed5c:	f7ed fe74 	bl	1ca48 <at_params_get>
	if (param == NULL) {
   2ed60:	4604      	mov	r4, r0
   2ed62:	2800      	cmp	r0, #0
   2ed64:	d0f2      	beq.n	2ed4c <at_params_string_put+0x8>
	char *param_value = (char *)k_malloc(str_len + 1);
   2ed66:	1c68      	adds	r0, r5, #1
   2ed68:	f7f7 fdaa 	bl	268c0 <k_malloc>
	if (param_value == NULL) {
   2ed6c:	4607      	mov	r7, r0
   2ed6e:	b160      	cbz	r0, 2ed8a <at_params_string_put+0x46>
   2ed70:	462a      	mov	r2, r5
   2ed72:	4631      	mov	r1, r6
   2ed74:	f000 faee 	bl	2f354 <memcpy>
	at_param_clear(param);
   2ed78:	4620      	mov	r0, r4
   2ed7a:	f7ed feaf 	bl	1cadc <at_param_clear>
	param->type = AT_PARAM_TYPE_STRING;
   2ed7e:	2303      	movs	r3, #3
	param->size = str_len;
   2ed80:	6065      	str	r5, [r4, #4]
	param->type = AT_PARAM_TYPE_STRING;
   2ed82:	7023      	strb	r3, [r4, #0]
	param->value.str_val = param_value;
   2ed84:	60a7      	str	r7, [r4, #8]
	return 0;
   2ed86:	2000      	movs	r0, #0
   2ed88:	e7e2      	b.n	2ed50 <at_params_string_put+0xc>
		return -ENOMEM;
   2ed8a:	f06f 000b 	mvn.w	r0, #11
   2ed8e:	e7df      	b.n	2ed50 <at_params_string_put+0xc>

0002ed90 <at_params_array_put>:

int at_params_array_put(const struct at_param_list *list, size_t index,
			const u32_t *array, size_t array_len)
{
   2ed90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2ed92:	4616      	mov	r6, r2
   2ed94:	461d      	mov	r5, r3
	if (list == NULL || list->params == NULL || array == NULL) {
   2ed96:	b910      	cbnz	r0, 2ed9e <at_params_array_put+0xe>
		return -EINVAL;
   2ed98:	f06f 0015 	mvn.w	r0, #21
	param->size = array_len;
	param->type = AT_PARAM_TYPE_ARRAY;
	param->value.array_val = param_value;

	return 0;
}
   2ed9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (list == NULL || list->params == NULL || array == NULL) {
   2ed9e:	6843      	ldr	r3, [r0, #4]
   2eda0:	2b00      	cmp	r3, #0
   2eda2:	d0f9      	beq.n	2ed98 <at_params_array_put+0x8>
   2eda4:	2a00      	cmp	r2, #0
   2eda6:	d0f7      	beq.n	2ed98 <at_params_array_put+0x8>
	struct at_param *param = at_params_get(list, index);
   2eda8:	f7ed fe4e 	bl	1ca48 <at_params_get>
	if (param == NULL) {
   2edac:	4604      	mov	r4, r0
   2edae:	2800      	cmp	r0, #0
   2edb0:	d0f2      	beq.n	2ed98 <at_params_array_put+0x8>
	u32_t *param_value = (u32_t *)k_malloc(array_len);
   2edb2:	4628      	mov	r0, r5
   2edb4:	f7f7 fd84 	bl	268c0 <k_malloc>
	if (param_value == NULL) {
   2edb8:	4607      	mov	r7, r0
   2edba:	b160      	cbz	r0, 2edd6 <at_params_array_put+0x46>
   2edbc:	462a      	mov	r2, r5
   2edbe:	4631      	mov	r1, r6
   2edc0:	f000 fac8 	bl	2f354 <memcpy>
	at_param_clear(param);
   2edc4:	4620      	mov	r0, r4
   2edc6:	f7ed fe89 	bl	1cadc <at_param_clear>
	param->type = AT_PARAM_TYPE_ARRAY;
   2edca:	2304      	movs	r3, #4
	param->size = array_len;
   2edcc:	6065      	str	r5, [r4, #4]
	param->type = AT_PARAM_TYPE_ARRAY;
   2edce:	7023      	strb	r3, [r4, #0]
	param->value.array_val = param_value;
   2edd0:	60a7      	str	r7, [r4, #8]
	return 0;
   2edd2:	2000      	movs	r0, #0
   2edd4:	e7e2      	b.n	2ed9c <at_params_array_put+0xc>
		return -ENOMEM;
   2edd6:	f06f 000b 	mvn.w	r0, #11
   2edda:	e7df      	b.n	2ed9c <at_params_array_put+0xc>

0002eddc <at_params_short_get>:
	return 0;
}

int at_params_short_get(const struct at_param_list *list, size_t index,
			u16_t *value)
{
   2eddc:	b510      	push	{r4, lr}
   2edde:	4614      	mov	r4, r2
	if (list == NULL || list->params == NULL || value == NULL) {
   2ede0:	b910      	cbnz	r0, 2ede8 <at_params_short_get+0xc>
		return -EINVAL;
   2ede2:	f06f 0015 	mvn.w	r0, #21
		return -EINVAL;
	}

	*value = (u16_t)param->value.int_val;
	return 0;
}
   2ede6:	bd10      	pop	{r4, pc}
	if (list == NULL || list->params == NULL || value == NULL) {
   2ede8:	6843      	ldr	r3, [r0, #4]
   2edea:	2b00      	cmp	r3, #0
   2edec:	d0f9      	beq.n	2ede2 <at_params_short_get+0x6>
   2edee:	2a00      	cmp	r2, #0
   2edf0:	d0f7      	beq.n	2ede2 <at_params_short_get+0x6>
	struct at_param *param = at_params_get(list, index);
   2edf2:	f7ed fe29 	bl	1ca48 <at_params_get>
	if (param == NULL) {
   2edf6:	2800      	cmp	r0, #0
   2edf8:	d0f3      	beq.n	2ede2 <at_params_short_get+0x6>
	if (param->type != AT_PARAM_TYPE_NUM_SHORT) {
   2edfa:	7803      	ldrb	r3, [r0, #0]
   2edfc:	2b01      	cmp	r3, #1
   2edfe:	d1f0      	bne.n	2ede2 <at_params_short_get+0x6>
	*value = (u16_t)param->value.int_val;
   2ee00:	6883      	ldr	r3, [r0, #8]
	return 0;
   2ee02:	2000      	movs	r0, #0
	*value = (u16_t)param->value.int_val;
   2ee04:	8023      	strh	r3, [r4, #0]
	return 0;
   2ee06:	e7ee      	b.n	2ede6 <at_params_short_get+0xa>

0002ee08 <at_params_int_get>:

int at_params_int_get(const struct at_param_list *list, size_t index,
		      u32_t *value)
{
   2ee08:	b510      	push	{r4, lr}
   2ee0a:	4614      	mov	r4, r2
	if (list == NULL || list->params == NULL || value == NULL) {
   2ee0c:	b910      	cbnz	r0, 2ee14 <at_params_int_get+0xc>
		return -EINVAL;
   2ee0e:	f06f 0015 	mvn.w	r0, #21
		return -EINVAL;
	}

	*value = param->value.int_val;
	return 0;
}
   2ee12:	bd10      	pop	{r4, pc}
	if (list == NULL || list->params == NULL || value == NULL) {
   2ee14:	6843      	ldr	r3, [r0, #4]
   2ee16:	2b00      	cmp	r3, #0
   2ee18:	d0f9      	beq.n	2ee0e <at_params_int_get+0x6>
   2ee1a:	2a00      	cmp	r2, #0
   2ee1c:	d0f7      	beq.n	2ee0e <at_params_int_get+0x6>
	struct at_param *param = at_params_get(list, index);
   2ee1e:	f7ed fe13 	bl	1ca48 <at_params_get>
	if (param == NULL) {
   2ee22:	2800      	cmp	r0, #0
   2ee24:	d0f3      	beq.n	2ee0e <at_params_int_get+0x6>
	if ((param->type != AT_PARAM_TYPE_NUM_INT) &&
   2ee26:	7803      	ldrb	r3, [r0, #0]
   2ee28:	3b01      	subs	r3, #1
   2ee2a:	2b01      	cmp	r3, #1
   2ee2c:	d8ef      	bhi.n	2ee0e <at_params_int_get+0x6>
	*value = param->value.int_val;
   2ee2e:	6883      	ldr	r3, [r0, #8]
	return 0;
   2ee30:	2000      	movs	r0, #0
	*value = param->value.int_val;
   2ee32:	6023      	str	r3, [r4, #0]
	return 0;
   2ee34:	e7ed      	b.n	2ee12 <at_params_int_get+0xa>

0002ee36 <at_params_string_get>:

int at_params_string_get(const struct at_param_list *list, size_t index,
			 char *value, size_t *len)
{
   2ee36:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2ee38:	4616      	mov	r6, r2
   2ee3a:	461c      	mov	r4, r3
	if (list == NULL || list->params == NULL || value == NULL ||
   2ee3c:	b910      	cbnz	r0, 2ee44 <at_params_string_get+0xe>
	    value == NULL || len == NULL) {
		return -EINVAL;
   2ee3e:	f06f 0015 	mvn.w	r0, #21

	memcpy(value, param->value.str_val, param_len);
	*len = param_len;

	return 0;
}
   2ee42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (list == NULL || list->params == NULL || value == NULL ||
   2ee44:	6843      	ldr	r3, [r0, #4]
   2ee46:	2b00      	cmp	r3, #0
   2ee48:	d0f9      	beq.n	2ee3e <at_params_string_get+0x8>
   2ee4a:	2a00      	cmp	r2, #0
   2ee4c:	d0f7      	beq.n	2ee3e <at_params_string_get+0x8>
	    value == NULL || len == NULL) {
   2ee4e:	2c00      	cmp	r4, #0
   2ee50:	d0f5      	beq.n	2ee3e <at_params_string_get+0x8>
	struct at_param *param = at_params_get(list, index);
   2ee52:	f7ed fdf9 	bl	1ca48 <at_params_get>
	if (param == NULL) {
   2ee56:	4607      	mov	r7, r0
   2ee58:	2800      	cmp	r0, #0
   2ee5a:	d0f0      	beq.n	2ee3e <at_params_string_get+0x8>
	if (param->type != AT_PARAM_TYPE_STRING) {
   2ee5c:	7803      	ldrb	r3, [r0, #0]
   2ee5e:	2b03      	cmp	r3, #3
   2ee60:	d1ed      	bne.n	2ee3e <at_params_string_get+0x8>
	size_t param_len = at_param_size(param);
   2ee62:	f7ed fe13 	bl	1ca8c <at_param_size>
	if (*len < param_len) {
   2ee66:	6823      	ldr	r3, [r4, #0]
	size_t param_len = at_param_size(param);
   2ee68:	4605      	mov	r5, r0
	if (*len < param_len) {
   2ee6a:	4283      	cmp	r3, r0
   2ee6c:	d307      	bcc.n	2ee7e <at_params_string_get+0x48>
   2ee6e:	4602      	mov	r2, r0
   2ee70:	68b9      	ldr	r1, [r7, #8]
   2ee72:	4630      	mov	r0, r6
   2ee74:	f000 fa6e 	bl	2f354 <memcpy>
	*len = param_len;
   2ee78:	6025      	str	r5, [r4, #0]
	return 0;
   2ee7a:	2000      	movs	r0, #0
   2ee7c:	e7e1      	b.n	2ee42 <at_params_string_get+0xc>
		return -ENOMEM;
   2ee7e:	f06f 000b 	mvn.w	r0, #11
   2ee82:	e7de      	b.n	2ee42 <at_params_string_get+0xc>

0002ee84 <at_params_valid_count_get>:

	return 0;
}

u32_t at_params_valid_count_get(const struct at_param_list *list)
{
   2ee84:	b538      	push	{r3, r4, r5, lr}
	if (list == NULL || list->params == NULL) {
   2ee86:	4605      	mov	r5, r0
   2ee88:	b180      	cbz	r0, 2eeac <at_params_valid_count_get+0x28>
   2ee8a:	6843      	ldr	r3, [r0, #4]
   2ee8c:	b173      	cbz	r3, 2eeac <at_params_valid_count_get+0x28>
		return -EINVAL;
	}

	size_t valid_i = 0;
	struct at_param *param = at_params_get(list, valid_i);
   2ee8e:	2100      	movs	r1, #0
   2ee90:	f7ed fdda 	bl	1ca48 <at_params_get>
	size_t valid_i = 0;
   2ee94:	2400      	movs	r4, #0

	while (param != NULL && param->type != AT_PARAM_TYPE_INVALID) {
   2ee96:	b108      	cbz	r0, 2ee9c <at_params_valid_count_get+0x18>
   2ee98:	7803      	ldrb	r3, [r0, #0]
   2ee9a:	b90b      	cbnz	r3, 2eea0 <at_params_valid_count_get+0x1c>
		valid_i += 1;
		param = at_params_get(list, valid_i);
	}

	return valid_i;
}
   2ee9c:	4620      	mov	r0, r4
   2ee9e:	bd38      	pop	{r3, r4, r5, pc}
		valid_i += 1;
   2eea0:	3401      	adds	r4, #1
		param = at_params_get(list, valid_i);
   2eea2:	4621      	mov	r1, r4
   2eea4:	4628      	mov	r0, r5
   2eea6:	f7ed fdcf 	bl	1ca48 <at_params_get>
   2eeaa:	e7f4      	b.n	2ee96 <at_params_valid_count_get+0x12>
		return -EINVAL;
   2eeac:	f06f 0415 	mvn.w	r4, #21
   2eeb0:	e7f4      	b.n	2ee9c <at_params_valid_count_get+0x18>

0002eeb2 <response_is_valid>:
{
   2eeb2:	b570      	push	{r4, r5, r6, lr}
   2eeb4:	4606      	mov	r6, r0
	if ((response_len < strlen(check)) ||
   2eeb6:	4610      	mov	r0, r2
{
   2eeb8:	460d      	mov	r5, r1
   2eeba:	4614      	mov	r4, r2
	if ((response_len < strlen(check)) ||
   2eebc:	f7de f84c 	bl	cf58 <strlen>
   2eec0:	42a8      	cmp	r0, r5
   2eec2:	d808      	bhi.n	2eed6 <response_is_valid+0x24>
	    (memcmp(response, check, response_len) != 0)) {
   2eec4:	462a      	mov	r2, r5
   2eec6:	4621      	mov	r1, r4
   2eec8:	4630      	mov	r0, r6
   2eeca:	f000 fa35 	bl	2f338 <memcmp>
	if ((response_len < strlen(check)) ||
   2eece:	fab0 f080 	clz	r0, r0
   2eed2:	0940      	lsrs	r0, r0, #5
}
   2eed4:	bd70      	pop	{r4, r5, r6, pc}
		return false;
   2eed6:	2000      	movs	r0, #0
   2eed8:	e7fc      	b.n	2eed4 <response_is_valid+0x22>

0002eeda <lte_lc_init_and_connect>:
{
   2eeda:	b508      	push	{r3, lr}
	ret = w_lte_lc_init();
   2eedc:	f7ed fe58 	bl	1cb90 <w_lte_lc_init>
	if (ret) {
   2eee0:	b918      	cbnz	r0, 2eeea <lte_lc_init_and_connect+0x10>
}
   2eee2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return w_lte_lc_connect();
   2eee6:	f7ed bf6b 	b.w	1cdc0 <w_lte_lc_connect>
}
   2eeea:	bd08      	pop	{r3, pc}

0002eeec <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   2eeec:	4700      	bx	r0

0002eeee <nrfx_nvmc_flash_size_get>:
}

uint32_t nrfx_nvmc_flash_size_get(void)
{
    return flash_total_size_get();
}
   2eeee:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   2eef2:	4770      	bx	lr

0002eef4 <nrfx_nvmc_flash_page_size_get>:

uint32_t nrfx_nvmc_flash_page_size_get(void)
{
    return flash_page_size_get();
}
   2eef4:	f44f 5080 	mov.w	r0, #4096	; 0x1000
   2eef8:	4770      	bx	lr

0002eefa <nrfx_nvmc_flash_page_count_get>:

uint32_t nrfx_nvmc_flash_page_count_get(void)
{
    return flash_page_count_get();
}
   2eefa:	f44f 7080 	mov.w	r0, #256	; 0x100
   2eefe:	4770      	bx	lr

0002ef00 <finish_transfer>:
{
   2ef00:	b510      	push	{r4, lr}
   2ef02:	4604      	mov	r4, r0
    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   2ef04:	7fc0      	ldrb	r0, [r0, #31]
   2ef06:	28ff      	cmp	r0, #255	; 0xff
   2ef08:	d003      	beq.n	2ef12 <finish_transfer+0x12>
            if (p_cb->ss_active_high)
   2ef0a:	7fa3      	ldrb	r3, [r4, #30]
   2ef0c:	b15b      	cbz	r3, 2ef26 <finish_transfer+0x26>
                nrf_gpio_pin_clear(p_cb->ss_pin);
   2ef0e:	f7f6 fc5b 	bl	257c8 <nrf_gpio_pin_clear>
    p_cb->transfer_in_progress = false;
   2ef12:	2300      	movs	r3, #0
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   2ef14:	4620      	mov	r0, r4
    p_cb->transfer_in_progress = false;
   2ef16:	7763      	strb	r3, [r4, #29]
    p_cb->evt.type = NRFX_SPIM_EVENT_DONE;
   2ef18:	7223      	strb	r3, [r4, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   2ef1a:	6861      	ldr	r1, [r4, #4]
   2ef1c:	f850 3b08 	ldr.w	r3, [r0], #8
}
   2ef20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   2ef24:	4718      	bx	r3
                nrf_gpio_pin_set(p_cb->ss_pin);
   2ef26:	f7f6 fc5b 	bl	257e0 <nrf_gpio_pin_set>
   2ef2a:	e7f2      	b.n	2ef12 <finish_transfer+0x12>

0002ef2c <xfer_completeness_check>:
    switch (p_cb->xfer_desc.type)
   2ef2c:	7b0b      	ldrb	r3, [r1, #12]
   2ef2e:	2b03      	cmp	r3, #3
   2ef30:	d82a      	bhi.n	2ef88 <xfer_completeness_check+0x5c>
   2ef32:	e8df f003 	tbb	[pc, r3]
   2ef36:	2622      	.short	0x2622
   2ef38:	021a      	.short	0x021a
            if (((p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   2ef3a:	688b      	ldr	r3, [r1, #8]
   2ef3c:	035a      	lsls	r2, r3, #13
   2ef3e:	d504      	bpl.n	2ef4a <xfer_completeness_check+0x1e>
    return p_reg->TXD.AMOUNT;
   2ef40:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
   2ef44:	690a      	ldr	r2, [r1, #16]
   2ef46:	429a      	cmp	r2, r3
   2ef48:	d107      	bne.n	2ef5a <xfer_completeness_check+0x2e>
                (!(p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   2ef4a:	688b      	ldr	r3, [r1, #8]
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)) ||
   2ef4c:	035b      	lsls	r3, r3, #13
   2ef4e:	d41b      	bmi.n	2ef88 <xfer_completeness_check+0x5c>
   2ef50:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   2ef54:	694a      	ldr	r2, [r1, #20]
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   2ef56:	429a      	cmp	r2, r3
   2ef58:	d016      	beq.n	2ef88 <xfer_completeness_check+0x5c>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   2ef5a:	2300      	movs	r3, #0
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   2ef5c:	2206      	movs	r2, #6
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   2ef5e:	f8c0 3500 	str.w	r3, [r0, #1280]	; 0x500
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   2ef62:	f8c0 2500 	str.w	r2, [r0, #1280]	; 0x500
   2ef66:	4618      	mov	r0, r3
   2ef68:	4770      	bx	lr
    return p_reg->TXD.AMOUNT;
   2ef6a:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   2ef6e:	690a      	ldr	r2, [r1, #16]
   2ef70:	429a      	cmp	r2, r3
   2ef72:	d1f2      	bne.n	2ef5a <xfer_completeness_check+0x2e>
    return p_reg->RXD.AMOUNT;
   2ef74:	f8d0 353c 	ldr.w	r3, [r0, #1340]	; 0x53c
   2ef78:	e7ec      	b.n	2ef54 <xfer_completeness_check+0x28>
    return p_reg->TXD.AMOUNT;
   2ef7a:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   2ef7e:	690a      	ldr	r2, [r1, #16]
   2ef80:	e7e9      	b.n	2ef56 <xfer_completeness_check+0x2a>
    return p_reg->RXD.AMOUNT;
   2ef82:	f8d0 353c 	ldr.w	r3, [r0, #1340]	; 0x53c
   2ef86:	e7fa      	b.n	2ef7e <xfer_completeness_check+0x52>
    bool transfer_complete = true;
   2ef88:	2001      	movs	r0, #1
}
   2ef8a:	4770      	bx	lr

0002ef8c <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
   2ef8c:	f7fe baf6 	b.w	2d57c <z_clock_idle_exit>

0002ef90 <k_mem_pool_malloc>:
{
   2ef90:	b507      	push	{r0, r1, r2, lr}
   2ef92:	2204      	movs	r2, #4
   2ef94:	188a      	adds	r2, r1, r2
   2ef96:	d204      	bcs.n	2efa2 <k_mem_pool_malloc+0x12>
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
   2ef98:	2300      	movs	r3, #0
   2ef9a:	4669      	mov	r1, sp
   2ef9c:	f7f7 fbca 	bl	26734 <k_mem_pool_alloc>
   2efa0:	b118      	cbz	r0, 2efaa <k_mem_pool_malloc+0x1a>
		return NULL;
   2efa2:	2000      	movs	r0, #0
}
   2efa4:	b003      	add	sp, #12
   2efa6:	f85d fb04 	ldr.w	pc, [sp], #4
   2efaa:	e9dd 3200 	ldrd	r3, r2, [sp]
   2efae:	601a      	str	r2, [r3, #0]
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
   2efb0:	9800      	ldr	r0, [sp, #0]
   2efb2:	3004      	adds	r0, #4
   2efb4:	e7f6      	b.n	2efa4 <k_mem_pool_malloc+0x14>

0002efb6 <k_free>:
	if (ptr != NULL) {
   2efb6:	b110      	cbz	r0, 2efbe <k_free+0x8>
		k_mem_pool_free_id(ptr);
   2efb8:	3804      	subs	r0, #4
   2efba:	f7f7 bc23 	b.w	26804 <k_mem_pool_free_id>
}
   2efbe:	4770      	bx	lr

0002efc0 <k_calloc>:
{
   2efc0:	b538      	push	{r3, r4, r5, lr}
	return a != 0 && (c / a) != b;
}

static inline bool size_mul_overflow(size_t a, size_t b, size_t *result)
{
	size_t c = a * b;
   2efc2:	fb01 f400 	mul.w	r4, r1, r0

	*result = c;

	return a != 0 && (c / a) != b;
   2efc6:	b118      	cbz	r0, 2efd0 <k_calloc+0x10>
   2efc8:	fbb4 f0f0 	udiv	r0, r4, r0
   2efcc:	4281      	cmp	r1, r0
   2efce:	d10a      	bne.n	2efe6 <k_calloc+0x26>
	ret = k_malloc(bounds);
   2efd0:	4620      	mov	r0, r4
   2efd2:	f7f7 fc75 	bl	268c0 <k_malloc>
	if (ret != NULL) {
   2efd6:	4605      	mov	r5, r0
   2efd8:	b118      	cbz	r0, 2efe2 <k_calloc+0x22>
__ssp_bos_icheck3(memset, void *, int)
   2efda:	4622      	mov	r2, r4
   2efdc:	2100      	movs	r1, #0
   2efde:	f000 f9d9 	bl	2f394 <memset>
}
   2efe2:	4628      	mov	r0, r5
   2efe4:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
   2efe6:	2500      	movs	r5, #0
   2efe8:	e7fb      	b.n	2efe2 <k_calloc+0x22>

0002efea <z_impl_k_mutex_init>:
{
   2efea:	4603      	mov	r3, r0
	mutex->owner = NULL;
   2efec:	2000      	movs	r0, #0
	list->tail = (sys_dnode_t *)list;
   2efee:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
   2eff2:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
   2eff6:	4770      	bx	lr

0002eff8 <z_queue_node_peek>:
{
   2eff8:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
   2effa:	4604      	mov	r4, r0
   2effc:	b130      	cbz	r0, 2f00c <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2effe:	6802      	ldr	r2, [r0, #0]
   2f000:	0793      	lsls	r3, r2, #30
   2f002:	d003      	beq.n	2f00c <z_queue_node_peek+0x14>
		ret = anode->data;
   2f004:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   2f006:	b109      	cbz	r1, 2f00c <z_queue_node_peek+0x14>
			k_free(anode);
   2f008:	f7ff ffd5 	bl	2efb6 <k_free>
}
   2f00c:	4620      	mov	r0, r4
   2f00e:	bd10      	pop	{r4, pc}

0002f010 <z_impl_k_queue_init>:
	list->head = NULL;
   2f010:	2300      	movs	r3, #0
	list->tail = NULL;
   2f012:	e9c0 3300 	strd	r3, r3, [r0]
	queue->lock = (struct k_spinlock) {};
   2f016:	6083      	str	r3, [r0, #8]
	sys_dlist_init(&queue->poll_events);
   2f018:	f100 030c 	add.w	r3, r0, #12
   2f01c:	e9c0 3303 	strd	r3, r3, [r0, #12]
}
   2f020:	4770      	bx	lr

0002f022 <k_queue_append>:
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
   2f022:	460a      	mov	r2, r1
   2f024:	2300      	movs	r3, #0
   2f026:	6841      	ldr	r1, [r0, #4]
   2f028:	f7f7 bf4e 	b.w	26ec8 <queue_insert>

0002f02c <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   2f02c:	7b43      	ldrb	r3, [r0, #13]
   2f02e:	06db      	lsls	r3, r3, #27
   2f030:	bf03      	ittte	eq
   2f032:	6980      	ldreq	r0, [r0, #24]
   2f034:	fab0 f080 	clzeq	r0, r0
   2f038:	0940      	lsreq	r0, r0, #5
   2f03a:	2000      	movne	r0, #0
}
   2f03c:	4770      	bx	lr

0002f03e <z_is_t1_higher_prio_than_t2>:
	if (thread_1->base.prio < thread_2->base.prio) {
   2f03e:	f990 000e 	ldrsb.w	r0, [r0, #14]
   2f042:	f991 300e 	ldrsb.w	r3, [r1, #14]
}
   2f046:	4298      	cmp	r0, r3
   2f048:	bfac      	ite	ge
   2f04a:	2000      	movge	r0, #0
   2f04c:	2001      	movlt	r0, #1
   2f04e:	4770      	bx	lr

0002f050 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   2f050:	4603      	mov	r3, r0
   2f052:	b920      	cbnz	r0, 2f05e <z_reschedule_irqlock+0xe>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   2f054:	f3ef 8205 	mrs	r2, IPSR
   2f058:	b90a      	cbnz	r2, 2f05e <z_reschedule_irqlock+0xe>
   2f05a:	f7e9 bfbd 	b.w	18fd8 <arch_swap>
   2f05e:	f383 8811 	msr	BASEPRI, r3
   2f062:	f3bf 8f6f 	isb	sy
}
   2f066:	4770      	bx	lr

0002f068 <z_reschedule_unlocked>:
	__asm__ volatile(
   2f068:	f04f 0320 	mov.w	r3, #32
   2f06c:	f3ef 8011 	mrs	r0, BASEPRI
   2f070:	f383 8811 	msr	BASEPRI, r3
   2f074:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   2f078:	f7ff bfea 	b.w	2f050 <z_reschedule_irqlock>

0002f07c <z_priq_dumb_best>:
	return list->head == list;
   2f07c:	6803      	ldr	r3, [r0, #0]
}
   2f07e:	4298      	cmp	r0, r3
   2f080:	bf14      	ite	ne
   2f082:	4618      	movne	r0, r3
   2f084:	2000      	moveq	r0, #0
   2f086:	4770      	bx	lr

0002f088 <z_unpend_all>:
{
   2f088:	b570      	push	{r4, r5, r6, lr}
   2f08a:	4606      	mov	r6, r0
	int need_sched = 0;
   2f08c:	2500      	movs	r5, #0
   2f08e:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2f090:	42a6      	cmp	r6, r4
   2f092:	d000      	beq.n	2f096 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   2f094:	b90c      	cbnz	r4, 2f09a <z_unpend_all+0x12>
}
   2f096:	4628      	mov	r0, r5
   2f098:	bd70      	pop	{r4, r5, r6, pc}
		z_unpend_thread(thread);
   2f09a:	4620      	mov	r0, r4
   2f09c:	f7f8 fa88 	bl	275b0 <z_unpend_thread>
	if (z_is_thread_ready(thread)) {
   2f0a0:	4620      	mov	r0, r4
   2f0a2:	f7ff ffc3 	bl	2f02c <z_is_thread_ready>
		need_sched = 1;
   2f0a6:	2501      	movs	r5, #1
   2f0a8:	2800      	cmp	r0, #0
   2f0aa:	d0f0      	beq.n	2f08e <z_unpend_all+0x6>
		z_add_thread_to_ready_q(thread);
   2f0ac:	4620      	mov	r0, r4
   2f0ae:	f7f8 fb87 	bl	277c0 <z_add_thread_to_ready_q>
   2f0b2:	e7ec      	b.n	2f08e <z_unpend_all+0x6>

0002f0b4 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || initial_count > limit) {
   2f0b4:	b15a      	cbz	r2, 2f0ce <z_impl_k_sem_init+0x1a>
   2f0b6:	428a      	cmp	r2, r1
   2f0b8:	d309      	bcc.n	2f0ce <z_impl_k_sem_init+0x1a>
	sys_dlist_init(&sem->poll_events);
   2f0ba:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
   2f0be:	e9c0 1202 	strd	r1, r2, [r0, #8]
	list->tail = (sys_dnode_t *)list;
   2f0c2:	e9c0 0000 	strd	r0, r0, [r0]
   2f0c6:	e9c0 3304 	strd	r3, r3, [r0, #16]
	return 0;
   2f0ca:	2000      	movs	r0, #0
   2f0cc:	4770      	bx	lr
		return -EINVAL;
   2f0ce:	f06f 0015 	mvn.w	r0, #21
}
   2f0d2:	4770      	bx	lr

0002f0d4 <k_is_in_isr>:
   2f0d4:	f3ef 8005 	mrs	r0, IPSR
}
   2f0d8:	3000      	adds	r0, #0
   2f0da:	bf18      	it	ne
   2f0dc:	2001      	movne	r0, #1
   2f0de:	4770      	bx	lr

0002f0e0 <z_impl_k_busy_wait>:
	arch_busy_wait(usec_to_wait);
   2f0e0:	f7e8 bbb6 	b.w	17850 <arch_busy_wait>

0002f0e4 <z_impl_k_thread_name_set>:
}
   2f0e4:	f06f 0057 	mvn.w	r0, #87	; 0x57
   2f0e8:	4770      	bx	lr

0002f0ea <k_thread_name_get>:
}
   2f0ea:	2000      	movs	r0, #0
   2f0ec:	4770      	bx	lr

0002f0ee <z_new_thread_init>:
{
   2f0ee:	b510      	push	{r4, lr}
	thread_base->user_options = (u8_t)options;
   2f0f0:	9c02      	ldr	r4, [sp, #8]
	thread_base->prio = priority;
   2f0f2:	7383      	strb	r3, [r0, #14]
	thread_base->user_options = (u8_t)options;
   2f0f4:	7304      	strb	r4, [r0, #12]
	thread_base->sched_locked = 0U;
   2f0f6:	2300      	movs	r3, #0
	thread_base->thread_state = (u8_t)initial_state;
   2f0f8:	2404      	movs	r4, #4
	thread_base->sched_locked = 0U;
   2f0fa:	73c3      	strb	r3, [r0, #15]
	thread_base->thread_state = (u8_t)initial_state;
   2f0fc:	7344      	strb	r4, [r0, #13]
	node->prev = NULL;
   2f0fe:	e9c0 3306 	strd	r3, r3, [r0, #24]
	thread->fn_abort = NULL;
   2f102:	e9c0 3313 	strd	r3, r3, [r0, #76]	; 0x4c
	thread->stack_info.size = (u32_t)stackSize;
   2f106:	e9c0 1216 	strd	r1, r2, [r0, #88]	; 0x58
}
   2f10a:	bd10      	pop	{r4, pc}

0002f10c <k_work_submit_to_queue>:
{
   2f10c:	b500      	push	{lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2f10e:	f101 0308 	add.w	r3, r1, #8
   2f112:	e8d3 2fef 	ldaex	r2, [r3]
   2f116:	f042 0c01 	orr.w	ip, r2, #1
   2f11a:	e8c3 cfee 	stlex	lr, ip, [r3]
   2f11e:	f1be 0f00 	cmp.w	lr, #0
   2f122:	d1f6      	bne.n	2f112 <k_work_submit_to_queue+0x6>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   2f124:	07d3      	lsls	r3, r2, #31
   2f126:	d403      	bmi.n	2f130 <k_work_submit_to_queue+0x24>
}
   2f128:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
   2f12c:	f7ff bf79 	b.w	2f022 <k_queue_append>
}
   2f130:	f85d fb04 	ldr.w	pc, [sp], #4

0002f134 <work_timeout>:
	k_work_submit_to_queue(w->work_q, &w->work);
   2f134:	f1a0 010c 	sub.w	r1, r0, #12
   2f138:	6900      	ldr	r0, [r0, #16]
   2f13a:	f7ff bfe7 	b.w	2f10c <k_work_submit_to_queue>

0002f13e <work_cancel>:
	CHECKIF(work->work_q == NULL) {
   2f13e:	69c3      	ldr	r3, [r0, #28]
{
   2f140:	b570      	push	{r4, r5, r6, lr}
   2f142:	4604      	mov	r4, r0
	CHECKIF(work->work_q == NULL) {
   2f144:	2b00      	cmp	r3, #0
   2f146:	d039      	beq.n	2f1bc <work_cancel+0x7e>
	return atomic_test_bit(work->flags, K_WORK_STATE_PENDING);
   2f148:	f100 0508 	add.w	r5, r0, #8
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2f14c:	e8d5 3faf 	lda	r3, [r5]
	if (k_work_pending(&work->work)) {
   2f150:	07db      	lsls	r3, r3, #31
   2f152:	d52f      	bpl.n	2f1b4 <work_cancel+0x76>
 * @return true if node was removed
 */
static inline bool sys_sflist_find_and_remove(sys_sflist_t *list,
					      sys_sfnode_t *node);

Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   2f154:	2100      	movs	r1, #0
		if (!k_queue_remove(&work->work_q->queue, &work->work)) {
   2f156:	69c2      	ldr	r2, [r0, #28]
   2f158:	6813      	ldr	r3, [r2, #0]
   2f15a:	b913      	cbnz	r3, 2f162 <work_cancel+0x24>
			return -EINVAL;
   2f15c:	f06f 0015 	mvn.w	r0, #21
}
   2f160:	bd70      	pop	{r4, r5, r6, pc}
   2f162:	429c      	cmp	r4, r3
   2f164:	d121      	bne.n	2f1aa <work_cancel+0x6c>
Z_GENLIST_REMOVE(sflist, sfnode)
   2f166:	6823      	ldr	r3, [r4, #0]
   2f168:	6856      	ldr	r6, [r2, #4]
   2f16a:	f023 0003 	bic.w	r0, r3, #3
   2f16e:	b991      	cbnz	r1, 2f196 <work_cancel+0x58>
   2f170:	42b4      	cmp	r4, r6
	list->head = node;
   2f172:	6010      	str	r0, [r2, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
   2f174:	d100      	bne.n	2f178 <work_cancel+0x3a>
	list->tail = node;
   2f176:	6050      	str	r0, [r2, #4]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2f178:	6823      	ldr	r3, [r4, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   2f17a:	f003 0303 	and.w	r3, r3, #3
   2f17e:	6023      	str	r3, [r4, #0]
	work->work_q = NULL;
   2f180:	2000      	movs	r0, #0
   2f182:	61e0      	str	r0, [r4, #28]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2f184:	e8d5 3fef 	ldaex	r3, [r5]
   2f188:	f023 0301 	bic.w	r3, r3, #1
   2f18c:	e8c5 3fe2 	stlex	r2, r3, [r5]
   2f190:	2a00      	cmp	r2, #0
   2f192:	d0e5      	beq.n	2f160 <work_cancel+0x22>
   2f194:	e7f6      	b.n	2f184 <work_cancel+0x46>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2f196:	680b      	ldr	r3, [r1, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
   2f198:	42b4      	cmp	r4, r6
	parent->next_and_flags = cur_flags | (unative_t)child;
   2f19a:	f003 0303 	and.w	r3, r3, #3
   2f19e:	ea43 0300 	orr.w	r3, r3, r0
   2f1a2:	600b      	str	r3, [r1, #0]
	list->tail = node;
   2f1a4:	bf08      	it	eq
   2f1a6:	6051      	streq	r1, [r2, #4]
   2f1a8:	e7e6      	b.n	2f178 <work_cancel+0x3a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   2f1aa:	6818      	ldr	r0, [r3, #0]
Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   2f1ac:	4619      	mov	r1, r3
   2f1ae:	f020 0303 	bic.w	r3, r0, #3
   2f1b2:	e7d2      	b.n	2f15a <work_cancel+0x1c>
		(void)z_abort_timeout(&work->timeout);
   2f1b4:	300c      	adds	r0, #12
   2f1b6:	f7f9 fdd7 	bl	28d68 <z_abort_timeout>
   2f1ba:	e7e1      	b.n	2f180 <work_cancel+0x42>
		return -EAGAIN;
   2f1bc:	f06f 000a 	mvn.w	r0, #10
   2f1c0:	e7ce      	b.n	2f160 <work_cancel+0x22>

0002f1c2 <k_delayed_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   2f1c2:	2300      	movs	r3, #0
   2f1c4:	e9c0 3100 	strd	r3, r1, [r0]
	node->next = NULL;
   2f1c8:	e9c0 3302 	strd	r3, r3, [r0, #8]
	node->prev = NULL;
   2f1cc:	6103      	str	r3, [r0, #16]
	work->work_q = NULL;
   2f1ce:	61c3      	str	r3, [r0, #28]
}
   2f1d0:	4770      	bx	lr

0002f1d2 <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
   2f1d2:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
   2f1d4:	f7f9 ffc0 	bl	29158 <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
   2f1d8:	bd08      	pop	{r3, pc}

0002f1da <z_impl_k_uptime_get>:

s64_t z_impl_k_uptime_get(void)
{
   2f1da:	b510      	push	{r4, lr}
	return k_ticks_to_ms_floor64(z_tick_get());
   2f1dc:	f7f9 ffbc 	bl	29158 <z_tick_get>
			return (t * to_hz + off) / from_hz;
   2f1e0:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   2f1e4:	fba0 2304 	umull	r2, r3, r0, r4
   2f1e8:	fb04 3301 	mla	r3, r4, r1, r3
   2f1ec:	0bd0      	lsrs	r0, r2, #15
}
   2f1ee:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   2f1f2:	0bd9      	lsrs	r1, r3, #15
   2f1f4:	bd10      	pop	{r4, pc}

0002f1f6 <k_timer_init>:
	timer->status = 0U;
   2f1f6:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   2f1f8:	e9c0 1206 	strd	r1, r2, [r0, #24]
   2f1fc:	f100 0210 	add.w	r2, r0, #16
	timer->status = 0U;
   2f200:	6243      	str	r3, [r0, #36]	; 0x24
	list->tail = (sys_dnode_t *)list;
   2f202:	e9c0 2204 	strd	r2, r2, [r0, #16]
	node->prev = NULL;
   2f206:	e9c0 3300 	strd	r3, r3, [r0]
	timer->user_data = NULL;
   2f20a:	6283      	str	r3, [r0, #40]	; 0x28
}
   2f20c:	4770      	bx	lr

0002f20e <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   2f20e:	b510      	push	{r4, lr}
   2f210:	4604      	mov	r4, r0
	int inactive = z_abort_timeout(&timer->timeout) != 0;
   2f212:	f7f9 fda9 	bl	28d68 <z_abort_timeout>

	if (inactive) {
   2f216:	bb00      	cbnz	r0, 2f25a <z_impl_k_timer_stop+0x4c>
		return;
	}

	if (timer->stop_fn != NULL) {
   2f218:	69e3      	ldr	r3, [r4, #28]
   2f21a:	b10b      	cbz	r3, 2f220 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   2f21c:	4620      	mov	r0, r4
   2f21e:	4798      	blx	r3
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
   2f220:	f104 0010 	add.w	r0, r4, #16
   2f224:	2100      	movs	r1, #0
   2f226:	f7f8 f845 	bl	272b4 <z_find_first_thread_to_unpend>
	if (thread != NULL) {
   2f22a:	4604      	mov	r4, r0
   2f22c:	b1a8      	cbz	r0, 2f25a <z_impl_k_timer_stop+0x4c>
		z_unpend_thread_no_timeout(thread);
   2f22e:	f7f8 f88b 	bl	27348 <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   2f232:	7b63      	ldrb	r3, [r4, #13]
   2f234:	06db      	lsls	r3, r3, #27
   2f236:	d104      	bne.n	2f242 <z_impl_k_timer_stop+0x34>
	if (z_is_thread_ready(thread)) {
   2f238:	69a3      	ldr	r3, [r4, #24]
   2f23a:	b913      	cbnz	r3, 2f242 <z_impl_k_timer_stop+0x34>
		z_add_thread_to_ready_q(thread);
   2f23c:	4620      	mov	r0, r4
   2f23e:	f7f8 fabf 	bl	277c0 <z_add_thread_to_ready_q>
   2f242:	f04f 0320 	mov.w	r3, #32
   2f246:	f3ef 8011 	mrs	r0, BASEPRI
   2f24a:	f383 8811 	msr	BASEPRI, r3
   2f24e:	f3bf 8f6f 	isb	sy

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
		z_reschedule_unlocked();
	}
}
   2f252:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   2f256:	f7ff befb 	b.w	2f050 <z_reschedule_irqlock>
   2f25a:	bd10      	pop	{r4, pc}

0002f25c <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, u32_t state)
{
   2f25c:	b570      	push	{r4, r5, r6, lr}
	struct _poller *poller = event->poller;
   2f25e:	6884      	ldr	r4, [r0, #8]
{
   2f260:	4605      	mov	r5, r0
   2f262:	460e      	mov	r6, r1
	int retcode = 0;

	if (poller) {
   2f264:	b19c      	cbz	r4, 2f28e <signal_poll_event+0x32>
		if (poller->cb != NULL) {
   2f266:	68a3      	ldr	r3, [r4, #8]
   2f268:	b95b      	cbnz	r3, 2f282 <signal_poll_event+0x26>
	int retcode = 0;
   2f26a:	4618      	mov	r0, r3
			retcode = poller->cb(event, state);
		}

		poller->is_polling = false;
   2f26c:	7023      	strb	r3, [r4, #0]
	event->poller = NULL;
   2f26e:	2300      	movs	r3, #0
   2f270:	60ab      	str	r3, [r5, #8]
	event->state |= state;
   2f272:	68eb      	ldr	r3, [r5, #12]
   2f274:	f3c3 3204 	ubfx	r2, r3, #12, #5
   2f278:	4316      	orrs	r6, r2
   2f27a:	f366 3310 	bfi	r3, r6, #12, #5
   2f27e:	60eb      	str	r3, [r5, #12]
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
   2f280:	e004      	b.n	2f28c <signal_poll_event+0x30>
			retcode = poller->cb(event, state);
   2f282:	4798      	blx	r3
		poller->is_polling = false;
   2f284:	2300      	movs	r3, #0
		if (retcode < 0) {
   2f286:	2800      	cmp	r0, #0
		poller->is_polling = false;
   2f288:	7023      	strb	r3, [r4, #0]
		if (retcode < 0) {
   2f28a:	daf0      	bge.n	2f26e <signal_poll_event+0x12>
}
   2f28c:	bd70      	pop	{r4, r5, r6, pc}
	int retcode = 0;
   2f28e:	4620      	mov	r0, r4
   2f290:	e7ed      	b.n	2f26e <signal_poll_event+0x12>

0002f292 <add_event>:
{
   2f292:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2f294:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   2f296:	e9d0 2300 	ldrd	r2, r3, [r0]
   2f29a:	4290      	cmp	r0, r2
   2f29c:	4604      	mov	r4, r0
   2f29e:	460d      	mov	r5, r1
   2f2a0:	d106      	bne.n	2f2b0 <add_event+0x1e>
	node->prev = list->tail;
   2f2a2:	6863      	ldr	r3, [r4, #4]
	node->next = list;
   2f2a4:	602c      	str	r4, [r5, #0]
	node->prev = list->tail;
   2f2a6:	606b      	str	r3, [r5, #4]
	list->tail->next = node;
   2f2a8:	6863      	ldr	r3, [r4, #4]
   2f2aa:	601d      	str	r5, [r3, #0]
	list->tail = node;
   2f2ac:	6065      	str	r5, [r4, #4]
}
   2f2ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
   2f2b0:	2b00      	cmp	r3, #0
   2f2b2:	d0f6      	beq.n	2f2a2 <add_event+0x10>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
   2f2b4:	689b      	ldr	r3, [r3, #8]
   2f2b6:	6879      	ldr	r1, [r7, #4]
   2f2b8:	6858      	ldr	r0, [r3, #4]
   2f2ba:	f7ff fec0 	bl	2f03e <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
   2f2be:	2800      	cmp	r0, #0
   2f2c0:	d1ef      	bne.n	2f2a2 <add_event+0x10>
	return list->head == list;
   2f2c2:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2f2c4:	42b4      	cmp	r4, r6
   2f2c6:	d0ec      	beq.n	2f2a2 <add_event+0x10>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   2f2c8:	2e00      	cmp	r6, #0
   2f2ca:	d0ea      	beq.n	2f2a2 <add_event+0x10>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
   2f2cc:	68b3      	ldr	r3, [r6, #8]
   2f2ce:	6878      	ldr	r0, [r7, #4]
   2f2d0:	6859      	ldr	r1, [r3, #4]
   2f2d2:	f7ff feb4 	bl	2f03e <z_is_t1_higher_prio_than_t2>
   2f2d6:	b128      	cbz	r0, 2f2e4 <add_event+0x52>
	node->prev = successor->prev;
   2f2d8:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   2f2da:	e9c5 6300 	strd	r6, r3, [r5]
	successor->prev->next = node;
   2f2de:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   2f2e0:	6075      	str	r5, [r6, #4]
			return;
   2f2e2:	e7e4      	b.n	2f2ae <add_event+0x1c>
	return (node == list->tail) ? NULL : node->next;
   2f2e4:	6863      	ldr	r3, [r4, #4]
   2f2e6:	429e      	cmp	r6, r3
   2f2e8:	d0db      	beq.n	2f2a2 <add_event+0x10>
   2f2ea:	6836      	ldr	r6, [r6, #0]
   2f2ec:	e7ec      	b.n	2f2c8 <add_event+0x36>

0002f2ee <z_handle_obj_poll_events>:
	return list->head == list;
   2f2ee:	6803      	ldr	r3, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
   2f2f0:	4298      	cmp	r0, r3
   2f2f2:	d009      	beq.n	2f308 <z_handle_obj_poll_events+0x1a>
	node->prev->next = node->next;
   2f2f4:	e9d3 2000 	ldrd	r2, r0, [r3]
   2f2f8:	6002      	str	r2, [r0, #0]
	node->next->prev = node->prev;
   2f2fa:	6050      	str	r0, [r2, #4]
	node->next = NULL;
   2f2fc:	2200      	movs	r2, #0
{
	struct k_poll_event *poll_event;

	poll_event = (struct k_poll_event *)sys_dlist_get(events);
	if (poll_event != NULL) {
		(void) signal_poll_event(poll_event, state);
   2f2fe:	4618      	mov	r0, r3
	node->prev = NULL;
   2f300:	e9c3 2200 	strd	r2, r2, [r3]
   2f304:	f7ff bfaa 	b.w	2f25c <signal_poll_event>
	}
}
   2f308:	4770      	bx	lr

0002f30a <_OffsetAbsSyms>:
					    sizeof(struct _preempt_float));
#else
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF, sizeof(struct k_thread));
#endif

GEN_ABS_SYM_END
   2f30a:	4770      	bx	lr

0002f30c <abs>:
   2f30c:	2800      	cmp	r0, #0
   2f30e:	bfb8      	it	lt
   2f310:	4240      	neglt	r0, r0
   2f312:	4770      	bx	lr

0002f314 <atoi>:
   2f314:	220a      	movs	r2, #10
   2f316:	2100      	movs	r1, #0
   2f318:	f7fb ba70 	b.w	2a7fc <strtol>

0002f31c <memchr>:
   2f31c:	b2c9      	uxtb	r1, r1
   2f31e:	4402      	add	r2, r0
   2f320:	b510      	push	{r4, lr}
   2f322:	4290      	cmp	r0, r2
   2f324:	4603      	mov	r3, r0
   2f326:	d101      	bne.n	2f32c <memchr+0x10>
   2f328:	2300      	movs	r3, #0
   2f32a:	e003      	b.n	2f334 <memchr+0x18>
   2f32c:	781c      	ldrb	r4, [r3, #0]
   2f32e:	3001      	adds	r0, #1
   2f330:	428c      	cmp	r4, r1
   2f332:	d1f6      	bne.n	2f322 <memchr+0x6>
   2f334:	4618      	mov	r0, r3
   2f336:	bd10      	pop	{r4, pc}

0002f338 <memcmp>:
   2f338:	b530      	push	{r4, r5, lr}
   2f33a:	3901      	subs	r1, #1
   2f33c:	2400      	movs	r4, #0
   2f33e:	42a2      	cmp	r2, r4
   2f340:	d101      	bne.n	2f346 <memcmp+0xe>
   2f342:	2000      	movs	r0, #0
   2f344:	e005      	b.n	2f352 <memcmp+0x1a>
   2f346:	5d03      	ldrb	r3, [r0, r4]
   2f348:	3401      	adds	r4, #1
   2f34a:	5d0d      	ldrb	r5, [r1, r4]
   2f34c:	42ab      	cmp	r3, r5
   2f34e:	d0f6      	beq.n	2f33e <memcmp+0x6>
   2f350:	1b58      	subs	r0, r3, r5
   2f352:	bd30      	pop	{r4, r5, pc}

0002f354 <memcpy>:
   2f354:	440a      	add	r2, r1
   2f356:	1e43      	subs	r3, r0, #1
   2f358:	4291      	cmp	r1, r2
   2f35a:	d100      	bne.n	2f35e <memcpy+0xa>
   2f35c:	4770      	bx	lr
   2f35e:	b510      	push	{r4, lr}
   2f360:	f811 4b01 	ldrb.w	r4, [r1], #1
   2f364:	4291      	cmp	r1, r2
   2f366:	f803 4f01 	strb.w	r4, [r3, #1]!
   2f36a:	d1f9      	bne.n	2f360 <memcpy+0xc>
   2f36c:	bd10      	pop	{r4, pc}

0002f36e <__memcpy_chk>:
   2f36e:	429a      	cmp	r2, r3
   2f370:	b508      	push	{r3, lr}
   2f372:	d901      	bls.n	2f378 <__memcpy_chk+0xa>
   2f374:	f7fb fbb8 	bl	2aae8 <__chk_fail>
   2f378:	4281      	cmp	r1, r0
   2f37a:	d804      	bhi.n	2f386 <__memcpy_chk+0x18>
   2f37c:	188b      	adds	r3, r1, r2
   2f37e:	4298      	cmp	r0, r3
   2f380:	d3f8      	bcc.n	2f374 <__memcpy_chk+0x6>
   2f382:	4281      	cmp	r1, r0
   2f384:	d102      	bne.n	2f38c <__memcpy_chk+0x1e>
   2f386:	1883      	adds	r3, r0, r2
   2f388:	4299      	cmp	r1, r3
   2f38a:	d3f3      	bcc.n	2f374 <__memcpy_chk+0x6>
   2f38c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   2f390:	f7ff bfe0 	b.w	2f354 <memcpy>

0002f394 <memset>:
   2f394:	4402      	add	r2, r0
   2f396:	4603      	mov	r3, r0
   2f398:	4293      	cmp	r3, r2
   2f39a:	d100      	bne.n	2f39e <memset+0xa>
   2f39c:	4770      	bx	lr
   2f39e:	f803 1b01 	strb.w	r1, [r3], #1
   2f3a2:	e7f9      	b.n	2f398 <memset+0x4>

0002f3a4 <__memset_chk>:
   2f3a4:	429a      	cmp	r2, r3
   2f3a6:	b508      	push	{r3, lr}
   2f3a8:	d901      	bls.n	2f3ae <__memset_chk+0xa>
   2f3aa:	f7fb fb9d 	bl	2aae8 <__chk_fail>
   2f3ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   2f3b2:	f7ff bfef 	b.w	2f394 <memset>

0002f3b6 <__sfputc_r>:
   2f3b6:	6893      	ldr	r3, [r2, #8]
   2f3b8:	3b01      	subs	r3, #1
   2f3ba:	2b00      	cmp	r3, #0
   2f3bc:	6093      	str	r3, [r2, #8]
   2f3be:	b410      	push	{r4}
   2f3c0:	da08      	bge.n	2f3d4 <__sfputc_r+0x1e>
   2f3c2:	6994      	ldr	r4, [r2, #24]
   2f3c4:	42a3      	cmp	r3, r4
   2f3c6:	db01      	blt.n	2f3cc <__sfputc_r+0x16>
   2f3c8:	290a      	cmp	r1, #10
   2f3ca:	d103      	bne.n	2f3d4 <__sfputc_r+0x1e>
   2f3cc:	f85d 4b04 	ldr.w	r4, [sp], #4
   2f3d0:	f7fb baca 	b.w	2a968 <__swbuf_r>
   2f3d4:	6813      	ldr	r3, [r2, #0]
   2f3d6:	1c58      	adds	r0, r3, #1
   2f3d8:	6010      	str	r0, [r2, #0]
   2f3da:	4608      	mov	r0, r1
   2f3dc:	7019      	strb	r1, [r3, #0]
   2f3de:	f85d 4b04 	ldr.w	r4, [sp], #4
   2f3e2:	4770      	bx	lr

0002f3e4 <__sfputs_r>:
   2f3e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2f3e6:	4606      	mov	r6, r0
   2f3e8:	460f      	mov	r7, r1
   2f3ea:	4614      	mov	r4, r2
   2f3ec:	18d5      	adds	r5, r2, r3
   2f3ee:	42ac      	cmp	r4, r5
   2f3f0:	d101      	bne.n	2f3f6 <__sfputs_r+0x12>
   2f3f2:	2000      	movs	r0, #0
   2f3f4:	e007      	b.n	2f406 <__sfputs_r+0x22>
   2f3f6:	463a      	mov	r2, r7
   2f3f8:	f814 1b01 	ldrb.w	r1, [r4], #1
   2f3fc:	4630      	mov	r0, r6
   2f3fe:	f7ff ffda 	bl	2f3b6 <__sfputc_r>
   2f402:	1c43      	adds	r3, r0, #1
   2f404:	d1f3      	bne.n	2f3ee <__sfputs_r+0xa>
   2f406:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002f408 <__cvt>:
   2f408:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   2f40c:	ec55 4b10 	vmov	r4, r5, d0
   2f410:	2d00      	cmp	r5, #0
   2f412:	460e      	mov	r6, r1
   2f414:	4691      	mov	r9, r2
   2f416:	4619      	mov	r1, r3
   2f418:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   2f41c:	f04f 0200 	mov.w	r2, #0
   2f420:	da03      	bge.n	2f42a <__cvt+0x22>
   2f422:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
   2f426:	222d      	movs	r2, #45	; 0x2d
   2f428:	461d      	mov	r5, r3
   2f42a:	9f0d      	ldr	r7, [sp, #52]	; 0x34
   2f42c:	700a      	strb	r2, [r1, #0]
   2f42e:	f027 0720 	bic.w	r7, r7, #32
   2f432:	2f46      	cmp	r7, #70	; 0x46
   2f434:	d004      	beq.n	2f440 <__cvt+0x38>
   2f436:	2f45      	cmp	r7, #69	; 0x45
   2f438:	d100      	bne.n	2f43c <__cvt+0x34>
   2f43a:	3601      	adds	r6, #1
   2f43c:	2102      	movs	r1, #2
   2f43e:	e000      	b.n	2f442 <__cvt+0x3a>
   2f440:	2103      	movs	r1, #3
   2f442:	ab03      	add	r3, sp, #12
   2f444:	4632      	mov	r2, r6
   2f446:	9301      	str	r3, [sp, #4]
   2f448:	ab02      	add	r3, sp, #8
   2f44a:	ec45 4b10 	vmov	d0, r4, r5
   2f44e:	9300      	str	r3, [sp, #0]
   2f450:	4653      	mov	r3, sl
   2f452:	f7e0 f8d1 	bl	f5f8 <_dtoa_r>
   2f456:	2f47      	cmp	r7, #71	; 0x47
   2f458:	4680      	mov	r8, r0
   2f45a:	d102      	bne.n	2f462 <__cvt+0x5a>
   2f45c:	f019 0f01 	tst.w	r9, #1
   2f460:	d022      	beq.n	2f4a8 <__cvt+0xa0>
   2f462:	2f46      	cmp	r7, #70	; 0x46
   2f464:	eb08 0906 	add.w	r9, r8, r6
   2f468:	d111      	bne.n	2f48e <__cvt+0x86>
   2f46a:	f898 3000 	ldrb.w	r3, [r8]
   2f46e:	2b30      	cmp	r3, #48	; 0x30
   2f470:	d10a      	bne.n	2f488 <__cvt+0x80>
   2f472:	2200      	movs	r2, #0
   2f474:	2300      	movs	r3, #0
   2f476:	4620      	mov	r0, r4
   2f478:	4629      	mov	r1, r5
   2f47a:	f7dd fb05 	bl	ca88 <__aeabi_dcmpeq>
   2f47e:	b918      	cbnz	r0, 2f488 <__cvt+0x80>
   2f480:	f1c6 0601 	rsb	r6, r6, #1
   2f484:	f8ca 6000 	str.w	r6, [sl]
   2f488:	f8da 3000 	ldr.w	r3, [sl]
   2f48c:	4499      	add	r9, r3
   2f48e:	2200      	movs	r2, #0
   2f490:	2300      	movs	r3, #0
   2f492:	4620      	mov	r0, r4
   2f494:	4629      	mov	r1, r5
   2f496:	f7dd faf7 	bl	ca88 <__aeabi_dcmpeq>
   2f49a:	b108      	cbz	r0, 2f4a0 <__cvt+0x98>
   2f49c:	f8cd 900c 	str.w	r9, [sp, #12]
   2f4a0:	2230      	movs	r2, #48	; 0x30
   2f4a2:	9b03      	ldr	r3, [sp, #12]
   2f4a4:	454b      	cmp	r3, r9
   2f4a6:	d308      	bcc.n	2f4ba <__cvt+0xb2>
   2f4a8:	9b03      	ldr	r3, [sp, #12]
   2f4aa:	4640      	mov	r0, r8
   2f4ac:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   2f4ae:	eba3 0308 	sub.w	r3, r3, r8
   2f4b2:	6013      	str	r3, [r2, #0]
   2f4b4:	b004      	add	sp, #16
   2f4b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2f4ba:	1c59      	adds	r1, r3, #1
   2f4bc:	9103      	str	r1, [sp, #12]
   2f4be:	701a      	strb	r2, [r3, #0]
   2f4c0:	e7ef      	b.n	2f4a2 <__cvt+0x9a>

0002f4c2 <__exponent>:
   2f4c2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2f4c4:	2900      	cmp	r1, #0
   2f4c6:	7002      	strb	r2, [r0, #0]
   2f4c8:	bfba      	itte	lt
   2f4ca:	4249      	neglt	r1, r1
   2f4cc:	232d      	movlt	r3, #45	; 0x2d
   2f4ce:	232b      	movge	r3, #43	; 0x2b
   2f4d0:	2909      	cmp	r1, #9
   2f4d2:	7043      	strb	r3, [r0, #1]
   2f4d4:	dd22      	ble.n	2f51c <__exponent+0x5a>
   2f4d6:	f10d 0307 	add.w	r3, sp, #7
   2f4da:	260a      	movs	r6, #10
   2f4dc:	461f      	mov	r7, r3
   2f4de:	2963      	cmp	r1, #99	; 0x63
   2f4e0:	f103 35ff 	add.w	r5, r3, #4294967295
   2f4e4:	fb91 f2f6 	sdiv	r2, r1, r6
   2f4e8:	fb06 1412 	mls	r4, r6, r2, r1
   2f4ec:	f104 0430 	add.w	r4, r4, #48	; 0x30
   2f4f0:	f803 4c01 	strb.w	r4, [r3, #-1]
   2f4f4:	dc0a      	bgt.n	2f50c <__exponent+0x4a>
   2f4f6:	3230      	adds	r2, #48	; 0x30
   2f4f8:	3b02      	subs	r3, #2
   2f4fa:	f805 2c01 	strb.w	r2, [r5, #-1]
   2f4fe:	1c82      	adds	r2, r0, #2
   2f500:	42bb      	cmp	r3, r7
   2f502:	4614      	mov	r4, r2
   2f504:	d305      	bcc.n	2f512 <__exponent+0x50>
   2f506:	1a20      	subs	r0, r4, r0
   2f508:	b003      	add	sp, #12
   2f50a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2f50c:	462b      	mov	r3, r5
   2f50e:	4611      	mov	r1, r2
   2f510:	e7e5      	b.n	2f4de <__exponent+0x1c>
   2f512:	f813 1b01 	ldrb.w	r1, [r3], #1
   2f516:	f802 1b01 	strb.w	r1, [r2], #1
   2f51a:	e7f1      	b.n	2f500 <__exponent+0x3e>
   2f51c:	2330      	movs	r3, #48	; 0x30
   2f51e:	1d04      	adds	r4, r0, #4
   2f520:	4419      	add	r1, r3
   2f522:	7083      	strb	r3, [r0, #2]
   2f524:	70c1      	strb	r1, [r0, #3]
   2f526:	e7ee      	b.n	2f506 <__exponent+0x44>

0002f528 <_printf_common>:
   2f528:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2f52c:	4691      	mov	r9, r2
   2f52e:	461f      	mov	r7, r3
   2f530:	688a      	ldr	r2, [r1, #8]
   2f532:	4606      	mov	r6, r0
   2f534:	690b      	ldr	r3, [r1, #16]
   2f536:	460c      	mov	r4, r1
   2f538:	f8dd 8020 	ldr.w	r8, [sp, #32]
   2f53c:	4293      	cmp	r3, r2
   2f53e:	bfb8      	it	lt
   2f540:	4613      	movlt	r3, r2
   2f542:	f8c9 3000 	str.w	r3, [r9]
   2f546:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
   2f54a:	b112      	cbz	r2, 2f552 <_printf_common+0x2a>
   2f54c:	3301      	adds	r3, #1
   2f54e:	f8c9 3000 	str.w	r3, [r9]
   2f552:	6823      	ldr	r3, [r4, #0]
   2f554:	0699      	lsls	r1, r3, #26
   2f556:	bf42      	ittt	mi
   2f558:	f8d9 3000 	ldrmi.w	r3, [r9]
   2f55c:	3302      	addmi	r3, #2
   2f55e:	f8c9 3000 	strmi.w	r3, [r9]
   2f562:	6825      	ldr	r5, [r4, #0]
   2f564:	f015 0506 	ands.w	r5, r5, #6
   2f568:	d107      	bne.n	2f57a <_printf_common+0x52>
   2f56a:	f104 0a19 	add.w	sl, r4, #25
   2f56e:	68e3      	ldr	r3, [r4, #12]
   2f570:	f8d9 2000 	ldr.w	r2, [r9]
   2f574:	1a9b      	subs	r3, r3, r2
   2f576:	42ab      	cmp	r3, r5
   2f578:	dc2b      	bgt.n	2f5d2 <_printf_common+0xaa>
   2f57a:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   2f57e:	6822      	ldr	r2, [r4, #0]
   2f580:	3300      	adds	r3, #0
   2f582:	bf18      	it	ne
   2f584:	2301      	movne	r3, #1
   2f586:	0692      	lsls	r2, r2, #26
   2f588:	d430      	bmi.n	2f5ec <_printf_common+0xc4>
   2f58a:	f104 0243 	add.w	r2, r4, #67	; 0x43
   2f58e:	4639      	mov	r1, r7
   2f590:	4630      	mov	r0, r6
   2f592:	47c0      	blx	r8
   2f594:	3001      	adds	r0, #1
   2f596:	d023      	beq.n	2f5e0 <_printf_common+0xb8>
   2f598:	6823      	ldr	r3, [r4, #0]
   2f59a:	341a      	adds	r4, #26
   2f59c:	f854 5c0e 	ldr.w	r5, [r4, #-14]
   2f5a0:	f003 0306 	and.w	r3, r3, #6
   2f5a4:	f8d9 2000 	ldr.w	r2, [r9]
   2f5a8:	f04f 0900 	mov.w	r9, #0
   2f5ac:	2b04      	cmp	r3, #4
   2f5ae:	f854 3c12 	ldr.w	r3, [r4, #-18]
   2f5b2:	bf08      	it	eq
   2f5b4:	1aad      	subeq	r5, r5, r2
   2f5b6:	f854 2c0a 	ldr.w	r2, [r4, #-10]
   2f5ba:	bf14      	ite	ne
   2f5bc:	2500      	movne	r5, #0
   2f5be:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
   2f5c2:	4293      	cmp	r3, r2
   2f5c4:	bfc4      	itt	gt
   2f5c6:	1a9b      	subgt	r3, r3, r2
   2f5c8:	18ed      	addgt	r5, r5, r3
   2f5ca:	454d      	cmp	r5, r9
   2f5cc:	d11a      	bne.n	2f604 <_printf_common+0xdc>
   2f5ce:	2000      	movs	r0, #0
   2f5d0:	e008      	b.n	2f5e4 <_printf_common+0xbc>
   2f5d2:	2301      	movs	r3, #1
   2f5d4:	4652      	mov	r2, sl
   2f5d6:	4639      	mov	r1, r7
   2f5d8:	4630      	mov	r0, r6
   2f5da:	47c0      	blx	r8
   2f5dc:	3001      	adds	r0, #1
   2f5de:	d103      	bne.n	2f5e8 <_printf_common+0xc0>
   2f5e0:	f04f 30ff 	mov.w	r0, #4294967295
   2f5e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2f5e8:	3501      	adds	r5, #1
   2f5ea:	e7c0      	b.n	2f56e <_printf_common+0x46>
   2f5ec:	18e1      	adds	r1, r4, r3
   2f5ee:	1c5a      	adds	r2, r3, #1
   2f5f0:	2030      	movs	r0, #48	; 0x30
   2f5f2:	3302      	adds	r3, #2
   2f5f4:	4422      	add	r2, r4
   2f5f6:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
   2f5fa:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
   2f5fe:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
   2f602:	e7c2      	b.n	2f58a <_printf_common+0x62>
   2f604:	2301      	movs	r3, #1
   2f606:	4622      	mov	r2, r4
   2f608:	4639      	mov	r1, r7
   2f60a:	4630      	mov	r0, r6
   2f60c:	47c0      	blx	r8
   2f60e:	3001      	adds	r0, #1
   2f610:	d0e6      	beq.n	2f5e0 <_printf_common+0xb8>
   2f612:	f109 0901 	add.w	r9, r9, #1
   2f616:	e7d8      	b.n	2f5ca <_printf_common+0xa2>

0002f618 <__sprintf_chk>:
   2f618:	b408      	push	{r3}
   2f61a:	b517      	push	{r0, r1, r2, r4, lr}
   2f61c:	ab05      	add	r3, sp, #20
   2f61e:	1e14      	subs	r4, r2, #0
   2f620:	f853 1b04 	ldr.w	r1, [r3], #4
   2f624:	9301      	str	r3, [sp, #4]
   2f626:	da07      	bge.n	2f638 <__sprintf_chk+0x20>
   2f628:	461a      	mov	r2, r3
   2f62a:	f7fb f993 	bl	2a954 <vsiprintf>
   2f62e:	b003      	add	sp, #12
   2f630:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2f634:	b001      	add	sp, #4
   2f636:	4770      	bx	lr
   2f638:	460a      	mov	r2, r1
   2f63a:	4621      	mov	r1, r4
   2f63c:	f7fb f966 	bl	2a90c <vsniprintf>
   2f640:	2800      	cmp	r0, #0
   2f642:	dbf4      	blt.n	2f62e <__sprintf_chk+0x16>
   2f644:	42a0      	cmp	r0, r4
   2f646:	d3f2      	bcc.n	2f62e <__sprintf_chk+0x16>
   2f648:	f7fb fa4e 	bl	2aae8 <__chk_fail>

0002f64c <__strcat_chk>:
   2f64c:	b538      	push	{r3, r4, r5, lr}
   2f64e:	4604      	mov	r4, r0
   2f650:	4623      	mov	r3, r4
   2f652:	f814 5b01 	ldrb.w	r5, [r4], #1
   2f656:	b935      	cbnz	r5, 2f666 <__strcat_chk+0x1a>
   2f658:	3901      	subs	r1, #1
   2f65a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   2f65e:	b93c      	cbnz	r4, 2f670 <__strcat_chk+0x24>
   2f660:	b112      	cbz	r2, 2f668 <__strcat_chk+0x1c>
   2f662:	701c      	strb	r4, [r3, #0]
   2f664:	bd38      	pop	{r3, r4, r5, pc}
   2f666:	b90a      	cbnz	r2, 2f66c <__strcat_chk+0x20>
   2f668:	f7fb fa3e 	bl	2aae8 <__chk_fail>
   2f66c:	3a01      	subs	r2, #1
   2f66e:	e7ef      	b.n	2f650 <__strcat_chk+0x4>
   2f670:	2a00      	cmp	r2, #0
   2f672:	d0f9      	beq.n	2f668 <__strcat_chk+0x1c>
   2f674:	f803 4b01 	strb.w	r4, [r3], #1
   2f678:	3a01      	subs	r2, #1
   2f67a:	e7ee      	b.n	2f65a <__strcat_chk+0xe>

0002f67c <strchr>:
   2f67c:	b2c9      	uxtb	r1, r1
   2f67e:	4603      	mov	r3, r0
   2f680:	f810 2b01 	ldrb.w	r2, [r0], #1
   2f684:	b11a      	cbz	r2, 2f68e <strchr+0x12>
   2f686:	428a      	cmp	r2, r1
   2f688:	d1f9      	bne.n	2f67e <strchr+0x2>
   2f68a:	4618      	mov	r0, r3
   2f68c:	4770      	bx	lr
   2f68e:	2900      	cmp	r1, #0
   2f690:	bf18      	it	ne
   2f692:	2300      	movne	r3, #0
   2f694:	e7f9      	b.n	2f68a <strchr+0xe>

0002f696 <strcpy>:
   2f696:	4603      	mov	r3, r0
   2f698:	f811 2b01 	ldrb.w	r2, [r1], #1
   2f69c:	f803 2b01 	strb.w	r2, [r3], #1
   2f6a0:	2a00      	cmp	r2, #0
   2f6a2:	d1f9      	bne.n	2f698 <strcpy+0x2>
   2f6a4:	4770      	bx	lr

0002f6a6 <strncmp>:
   2f6a6:	b510      	push	{r4, lr}
   2f6a8:	b16a      	cbz	r2, 2f6c6 <strncmp+0x20>
   2f6aa:	3901      	subs	r1, #1
   2f6ac:	1884      	adds	r4, r0, r2
   2f6ae:	f810 3b01 	ldrb.w	r3, [r0], #1
   2f6b2:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   2f6b6:	4293      	cmp	r3, r2
   2f6b8:	d103      	bne.n	2f6c2 <strncmp+0x1c>
   2f6ba:	42a0      	cmp	r0, r4
   2f6bc:	d001      	beq.n	2f6c2 <strncmp+0x1c>
   2f6be:	2b00      	cmp	r3, #0
   2f6c0:	d1f5      	bne.n	2f6ae <strncmp+0x8>
   2f6c2:	1a98      	subs	r0, r3, r2
   2f6c4:	bd10      	pop	{r4, pc}
   2f6c6:	4610      	mov	r0, r2
   2f6c8:	e7fc      	b.n	2f6c4 <strncmp+0x1e>

0002f6ca <strncpy>:
   2f6ca:	3901      	subs	r1, #1
   2f6cc:	4603      	mov	r3, r0
   2f6ce:	b510      	push	{r4, lr}
   2f6d0:	b132      	cbz	r2, 2f6e0 <strncpy+0x16>
   2f6d2:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   2f6d6:	3a01      	subs	r2, #1
   2f6d8:	f803 4b01 	strb.w	r4, [r3], #1
   2f6dc:	2c00      	cmp	r4, #0
   2f6de:	d1f7      	bne.n	2f6d0 <strncpy+0x6>
   2f6e0:	441a      	add	r2, r3
   2f6e2:	2100      	movs	r1, #0
   2f6e4:	4293      	cmp	r3, r2
   2f6e6:	d100      	bne.n	2f6ea <strncpy+0x20>
   2f6e8:	bd10      	pop	{r4, pc}
   2f6ea:	f803 1b01 	strb.w	r1, [r3], #1
   2f6ee:	e7f9      	b.n	2f6e4 <strncpy+0x1a>

0002f6f0 <strstr>:
   2f6f0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2f6f2:	780c      	ldrb	r4, [r1, #0]
   2f6f4:	b164      	cbz	r4, 2f710 <strstr+0x20>
   2f6f6:	4603      	mov	r3, r0
   2f6f8:	781a      	ldrb	r2, [r3, #0]
   2f6fa:	4618      	mov	r0, r3
   2f6fc:	1c5e      	adds	r6, r3, #1
   2f6fe:	b90a      	cbnz	r2, 2f704 <strstr+0x14>
   2f700:	4610      	mov	r0, r2
   2f702:	e005      	b.n	2f710 <strstr+0x20>
   2f704:	4294      	cmp	r4, r2
   2f706:	d108      	bne.n	2f71a <strstr+0x2a>
   2f708:	460d      	mov	r5, r1
   2f70a:	f815 2f01 	ldrb.w	r2, [r5, #1]!
   2f70e:	b902      	cbnz	r2, 2f712 <strstr+0x22>
   2f710:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2f712:	f813 7f01 	ldrb.w	r7, [r3, #1]!
   2f716:	4297      	cmp	r7, r2
   2f718:	d0f7      	beq.n	2f70a <strstr+0x1a>
   2f71a:	4633      	mov	r3, r6
   2f71c:	e7ec      	b.n	2f6f8 <strstr+0x8>

0002f71e <_vsniprintf_r>:
   2f71e:	b530      	push	{r4, r5, lr}
   2f720:	1e14      	subs	r4, r2, #0
   2f722:	4605      	mov	r5, r0
   2f724:	b09b      	sub	sp, #108	; 0x6c
   2f726:	4618      	mov	r0, r3
   2f728:	da05      	bge.n	2f736 <_vsniprintf_r+0x18>
   2f72a:	238b      	movs	r3, #139	; 0x8b
   2f72c:	f04f 30ff 	mov.w	r0, #4294967295
   2f730:	602b      	str	r3, [r5, #0]
   2f732:	b01b      	add	sp, #108	; 0x6c
   2f734:	bd30      	pop	{r4, r5, pc}
   2f736:	f44f 7302 	mov.w	r3, #520	; 0x208
   2f73a:	9100      	str	r1, [sp, #0]
   2f73c:	9104      	str	r1, [sp, #16]
   2f73e:	4602      	mov	r2, r0
   2f740:	f8ad 300c 	strh.w	r3, [sp, #12]
   2f744:	bf14      	ite	ne
   2f746:	f104 33ff 	addne.w	r3, r4, #4294967295
   2f74a:	4623      	moveq	r3, r4
   2f74c:	4669      	mov	r1, sp
   2f74e:	4628      	mov	r0, r5
   2f750:	9302      	str	r3, [sp, #8]
   2f752:	9305      	str	r3, [sp, #20]
   2f754:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2f758:	f8ad 300e 	strh.w	r3, [sp, #14]
   2f75c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
   2f75e:	f7fb fca9 	bl	2b0b4 <_svfiprintf_r>
   2f762:	1c43      	adds	r3, r0, #1
   2f764:	bfbc      	itt	lt
   2f766:	238b      	movlt	r3, #139	; 0x8b
   2f768:	602b      	strlt	r3, [r5, #0]
   2f76a:	2c00      	cmp	r4, #0
   2f76c:	d0e1      	beq.n	2f732 <_vsniprintf_r+0x14>
   2f76e:	9b00      	ldr	r3, [sp, #0]
   2f770:	2200      	movs	r2, #0
   2f772:	701a      	strb	r2, [r3, #0]
   2f774:	e7dd      	b.n	2f732 <_vsniprintf_r+0x14>

0002f776 <abort>:
   2f776:	b508      	push	{r3, lr}
   2f778:	2006      	movs	r0, #6
   2f77a:	f7fb fda3 	bl	2b2c4 <raise>
   2f77e:	2001      	movs	r0, #1
   2f780:	f7ea fbaa 	bl	19ed8 <_exit>

0002f784 <quorem>:
   2f784:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2f788:	6903      	ldr	r3, [r0, #16]
   2f78a:	4680      	mov	r8, r0
   2f78c:	690c      	ldr	r4, [r1, #16]
   2f78e:	42a3      	cmp	r3, r4
   2f790:	f2c0 8084 	blt.w	2f89c <quorem+0x118>
   2f794:	3c01      	subs	r4, #1
   2f796:	f108 0514 	add.w	r5, r8, #20
   2f79a:	f101 0714 	add.w	r7, r1, #20
   2f79e:	00a0      	lsls	r0, r4, #2
   2f7a0:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   2f7a4:	182b      	adds	r3, r5, r0
   2f7a6:	eb07 0900 	add.w	r9, r7, r0
   2f7aa:	9301      	str	r3, [sp, #4]
   2f7ac:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
   2f7b0:	3301      	adds	r3, #1
   2f7b2:	429a      	cmp	r2, r3
   2f7b4:	fbb2 f6f3 	udiv	r6, r2, r3
   2f7b8:	d333      	bcc.n	2f822 <quorem+0x9e>
   2f7ba:	f04f 0a00 	mov.w	sl, #0
   2f7be:	46bc      	mov	ip, r7
   2f7c0:	46ae      	mov	lr, r5
   2f7c2:	46d3      	mov	fp, sl
   2f7c4:	f85c 2b04 	ldr.w	r2, [ip], #4
   2f7c8:	b293      	uxth	r3, r2
   2f7ca:	45e1      	cmp	r9, ip
   2f7cc:	ea4f 4212 	mov.w	r2, r2, lsr #16
   2f7d0:	fb06 a303 	mla	r3, r6, r3, sl
   2f7d4:	ea4f 4a13 	mov.w	sl, r3, lsr #16
   2f7d8:	b29b      	uxth	r3, r3
   2f7da:	fb06 a202 	mla	r2, r6, r2, sl
   2f7de:	ebab 0303 	sub.w	r3, fp, r3
   2f7e2:	f8de b000 	ldr.w	fp, [lr]
   2f7e6:	ea4f 4a12 	mov.w	sl, r2, lsr #16
   2f7ea:	fa1f fb8b 	uxth.w	fp, fp
   2f7ee:	445b      	add	r3, fp
   2f7f0:	fa1f fb82 	uxth.w	fp, r2
   2f7f4:	f8de 2000 	ldr.w	r2, [lr]
   2f7f8:	ebcb 4212 	rsb	r2, fp, r2, lsr #16
   2f7fc:	eb02 4223 	add.w	r2, r2, r3, asr #16
   2f800:	b29b      	uxth	r3, r3
   2f802:	ea4f 4b22 	mov.w	fp, r2, asr #16
   2f806:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   2f80a:	f84e 3b04 	str.w	r3, [lr], #4
   2f80e:	d2d9      	bcs.n	2f7c4 <quorem+0x40>
   2f810:	582b      	ldr	r3, [r5, r0]
   2f812:	b933      	cbnz	r3, 2f822 <quorem+0x9e>
   2f814:	9b01      	ldr	r3, [sp, #4]
   2f816:	3b04      	subs	r3, #4
   2f818:	429d      	cmp	r5, r3
   2f81a:	461a      	mov	r2, r3
   2f81c:	d332      	bcc.n	2f884 <quorem+0x100>
   2f81e:	f8c8 4010 	str.w	r4, [r8, #16]
   2f822:	4640      	mov	r0, r8
   2f824:	f000 fa74 	bl	2fd10 <__mcmp>
   2f828:	2800      	cmp	r0, #0
   2f82a:	db27      	blt.n	2f87c <quorem+0xf8>
   2f82c:	3601      	adds	r6, #1
   2f82e:	4628      	mov	r0, r5
   2f830:	f04f 0c00 	mov.w	ip, #0
   2f834:	f857 1b04 	ldr.w	r1, [r7], #4
   2f838:	f8d0 e000 	ldr.w	lr, [r0]
   2f83c:	b28b      	uxth	r3, r1
   2f83e:	45b9      	cmp	r9, r7
   2f840:	fa1f f28e 	uxth.w	r2, lr
   2f844:	ebac 0303 	sub.w	r3, ip, r3
   2f848:	4413      	add	r3, r2
   2f84a:	ea4f 4211 	mov.w	r2, r1, lsr #16
   2f84e:	ebc2 421e 	rsb	r2, r2, lr, lsr #16
   2f852:	eb02 4223 	add.w	r2, r2, r3, asr #16
   2f856:	b29b      	uxth	r3, r3
   2f858:	ea4f 4c22 	mov.w	ip, r2, asr #16
   2f85c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   2f860:	f840 3b04 	str.w	r3, [r0], #4
   2f864:	d2e6      	bcs.n	2f834 <quorem+0xb0>
   2f866:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   2f86a:	eb05 0384 	add.w	r3, r5, r4, lsl #2
   2f86e:	b92a      	cbnz	r2, 2f87c <quorem+0xf8>
   2f870:	3b04      	subs	r3, #4
   2f872:	429d      	cmp	r5, r3
   2f874:	461a      	mov	r2, r3
   2f876:	d30b      	bcc.n	2f890 <quorem+0x10c>
   2f878:	f8c8 4010 	str.w	r4, [r8, #16]
   2f87c:	4630      	mov	r0, r6
   2f87e:	b003      	add	sp, #12
   2f880:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2f884:	6812      	ldr	r2, [r2, #0]
   2f886:	3b04      	subs	r3, #4
   2f888:	2a00      	cmp	r2, #0
   2f88a:	d1c8      	bne.n	2f81e <quorem+0x9a>
   2f88c:	3c01      	subs	r4, #1
   2f88e:	e7c3      	b.n	2f818 <quorem+0x94>
   2f890:	6812      	ldr	r2, [r2, #0]
   2f892:	3b04      	subs	r3, #4
   2f894:	2a00      	cmp	r2, #0
   2f896:	d1ef      	bne.n	2f878 <quorem+0xf4>
   2f898:	3c01      	subs	r4, #1
   2f89a:	e7ea      	b.n	2f872 <quorem+0xee>
   2f89c:	2000      	movs	r0, #0
   2f89e:	e7ee      	b.n	2f87e <quorem+0xfa>

0002f8a0 <__sfmoreglue>:
   2f8a0:	b570      	push	{r4, r5, r6, lr}
   2f8a2:	1e4a      	subs	r2, r1, #1
   2f8a4:	2568      	movs	r5, #104	; 0x68
   2f8a6:	460e      	mov	r6, r1
   2f8a8:	4355      	muls	r5, r2
   2f8aa:	f105 0174 	add.w	r1, r5, #116	; 0x74
   2f8ae:	f7fb fba7 	bl	2b000 <_malloc_r>
   2f8b2:	4604      	mov	r4, r0
   2f8b4:	b140      	cbz	r0, 2f8c8 <__sfmoreglue+0x28>
   2f8b6:	2100      	movs	r1, #0
   2f8b8:	f105 0268 	add.w	r2, r5, #104	; 0x68
   2f8bc:	e9c0 1600 	strd	r1, r6, [r0]
   2f8c0:	300c      	adds	r0, #12
   2f8c2:	60a0      	str	r0, [r4, #8]
   2f8c4:	f7ff fd66 	bl	2f394 <memset>
   2f8c8:	4620      	mov	r0, r4
   2f8ca:	bd70      	pop	{r4, r5, r6, pc}

0002f8cc <_fwalk_reent>:
   2f8cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2f8d0:	4680      	mov	r8, r0
   2f8d2:	4689      	mov	r9, r1
   2f8d4:	f100 0448 	add.w	r4, r0, #72	; 0x48
   2f8d8:	2600      	movs	r6, #0
   2f8da:	b914      	cbnz	r4, 2f8e2 <_fwalk_reent+0x16>
   2f8dc:	4630      	mov	r0, r6
   2f8de:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2f8e2:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
   2f8e6:	3f01      	subs	r7, #1
   2f8e8:	d501      	bpl.n	2f8ee <_fwalk_reent+0x22>
   2f8ea:	6824      	ldr	r4, [r4, #0]
   2f8ec:	e7f5      	b.n	2f8da <_fwalk_reent+0xe>
   2f8ee:	89ab      	ldrh	r3, [r5, #12]
   2f8f0:	2b01      	cmp	r3, #1
   2f8f2:	d907      	bls.n	2f904 <_fwalk_reent+0x38>
   2f8f4:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
   2f8f8:	3301      	adds	r3, #1
   2f8fa:	d003      	beq.n	2f904 <_fwalk_reent+0x38>
   2f8fc:	4629      	mov	r1, r5
   2f8fe:	4640      	mov	r0, r8
   2f900:	47c8      	blx	r9
   2f902:	4306      	orrs	r6, r0
   2f904:	3568      	adds	r5, #104	; 0x68
   2f906:	e7ee      	b.n	2f8e6 <_fwalk_reent+0x1a>

0002f908 <__retarget_lock_init_recursive>:
   2f908:	4770      	bx	lr

0002f90a <__retarget_lock_acquire_recursive>:
   2f90a:	4770      	bx	lr

0002f90c <__retarget_lock_release_recursive>:
   2f90c:	4770      	bx	lr

0002f90e <__swhatbuf_r>:
   2f90e:	b570      	push	{r4, r5, r6, lr}
   2f910:	460e      	mov	r6, r1
   2f912:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   2f916:	b096      	sub	sp, #88	; 0x58
   2f918:	4614      	mov	r4, r2
   2f91a:	2900      	cmp	r1, #0
   2f91c:	461d      	mov	r5, r3
   2f91e:	da07      	bge.n	2f930 <__swhatbuf_r+0x22>
   2f920:	2300      	movs	r3, #0
   2f922:	602b      	str	r3, [r5, #0]
   2f924:	89b3      	ldrh	r3, [r6, #12]
   2f926:	061a      	lsls	r2, r3, #24
   2f928:	d410      	bmi.n	2f94c <__swhatbuf_r+0x3e>
   2f92a:	f44f 6380 	mov.w	r3, #1024	; 0x400
   2f92e:	e00e      	b.n	2f94e <__swhatbuf_r+0x40>
   2f930:	466a      	mov	r2, sp
   2f932:	f7fb fd03 	bl	2b33c <_fstat_r>
   2f936:	2800      	cmp	r0, #0
   2f938:	dbf2      	blt.n	2f920 <__swhatbuf_r+0x12>
   2f93a:	9a01      	ldr	r2, [sp, #4]
   2f93c:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
   2f940:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
   2f944:	425a      	negs	r2, r3
   2f946:	415a      	adcs	r2, r3
   2f948:	602a      	str	r2, [r5, #0]
   2f94a:	e7ee      	b.n	2f92a <__swhatbuf_r+0x1c>
   2f94c:	2340      	movs	r3, #64	; 0x40
   2f94e:	2000      	movs	r0, #0
   2f950:	6023      	str	r3, [r4, #0]
   2f952:	b016      	add	sp, #88	; 0x58
   2f954:	bd70      	pop	{r4, r5, r6, pc}

0002f956 <memmove>:
   2f956:	4288      	cmp	r0, r1
   2f958:	eb01 0302 	add.w	r3, r1, r2
   2f95c:	b510      	push	{r4, lr}
   2f95e:	d902      	bls.n	2f966 <memmove+0x10>
   2f960:	4283      	cmp	r3, r0
   2f962:	461c      	mov	r4, r3
   2f964:	d807      	bhi.n	2f976 <memmove+0x20>
   2f966:	1e42      	subs	r2, r0, #1
   2f968:	4299      	cmp	r1, r3
   2f96a:	d008      	beq.n	2f97e <memmove+0x28>
   2f96c:	f811 4b01 	ldrb.w	r4, [r1], #1
   2f970:	f802 4f01 	strb.w	r4, [r2, #1]!
   2f974:	e7f8      	b.n	2f968 <memmove+0x12>
   2f976:	1883      	adds	r3, r0, r2
   2f978:	1a9a      	subs	r2, r3, r2
   2f97a:	429a      	cmp	r2, r3
   2f97c:	d100      	bne.n	2f980 <memmove+0x2a>
   2f97e:	bd10      	pop	{r4, pc}
   2f980:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
   2f984:	f803 1d01 	strb.w	r1, [r3, #-1]!
   2f988:	e7f7      	b.n	2f97a <memmove+0x24>

0002f98a <_Balloc>:
   2f98a:	b570      	push	{r4, r5, r6, lr}
   2f98c:	6a45      	ldr	r5, [r0, #36]	; 0x24
   2f98e:	4604      	mov	r4, r0
   2f990:	460e      	mov	r6, r1
   2f992:	b93d      	cbnz	r5, 2f9a4 <_Balloc+0x1a>
   2f994:	2010      	movs	r0, #16
   2f996:	f7fb fa8f 	bl	2aeb8 <malloc>
   2f99a:	6260      	str	r0, [r4, #36]	; 0x24
   2f99c:	6005      	str	r5, [r0, #0]
   2f99e:	60c5      	str	r5, [r0, #12]
   2f9a0:	e9c0 5501 	strd	r5, r5, [r0, #4]
   2f9a4:	6a65      	ldr	r5, [r4, #36]	; 0x24
   2f9a6:	68eb      	ldr	r3, [r5, #12]
   2f9a8:	b183      	cbz	r3, 2f9cc <_Balloc+0x42>
   2f9aa:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2f9ac:	68db      	ldr	r3, [r3, #12]
   2f9ae:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
   2f9b2:	b9b8      	cbnz	r0, 2f9e4 <_Balloc+0x5a>
   2f9b4:	2101      	movs	r1, #1
   2f9b6:	4620      	mov	r0, r4
   2f9b8:	fa01 f506 	lsl.w	r5, r1, r6
   2f9bc:	1d6a      	adds	r2, r5, #5
   2f9be:	0092      	lsls	r2, r2, #2
   2f9c0:	f000 fa6e 	bl	2fea0 <_calloc_r>
   2f9c4:	b160      	cbz	r0, 2f9e0 <_Balloc+0x56>
   2f9c6:	e9c0 6501 	strd	r6, r5, [r0, #4]
   2f9ca:	e00e      	b.n	2f9ea <_Balloc+0x60>
   2f9cc:	2221      	movs	r2, #33	; 0x21
   2f9ce:	2104      	movs	r1, #4
   2f9d0:	4620      	mov	r0, r4
   2f9d2:	f000 fa65 	bl	2fea0 <_calloc_r>
   2f9d6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2f9d8:	60e8      	str	r0, [r5, #12]
   2f9da:	68db      	ldr	r3, [r3, #12]
   2f9dc:	2b00      	cmp	r3, #0
   2f9de:	d1e4      	bne.n	2f9aa <_Balloc+0x20>
   2f9e0:	2000      	movs	r0, #0
   2f9e2:	bd70      	pop	{r4, r5, r6, pc}
   2f9e4:	6802      	ldr	r2, [r0, #0]
   2f9e6:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
   2f9ea:	2300      	movs	r3, #0
   2f9ec:	e9c0 3303 	strd	r3, r3, [r0, #12]
   2f9f0:	e7f7      	b.n	2f9e2 <_Balloc+0x58>

0002f9f2 <_Bfree>:
   2f9f2:	b570      	push	{r4, r5, r6, lr}
   2f9f4:	6a44      	ldr	r4, [r0, #36]	; 0x24
   2f9f6:	4606      	mov	r6, r0
   2f9f8:	460d      	mov	r5, r1
   2f9fa:	b93c      	cbnz	r4, 2fa0c <_Bfree+0x1a>
   2f9fc:	2010      	movs	r0, #16
   2f9fe:	f7fb fa5b 	bl	2aeb8 <malloc>
   2fa02:	6270      	str	r0, [r6, #36]	; 0x24
   2fa04:	6004      	str	r4, [r0, #0]
   2fa06:	60c4      	str	r4, [r0, #12]
   2fa08:	e9c0 4401 	strd	r4, r4, [r0, #4]
   2fa0c:	b13d      	cbz	r5, 2fa1e <_Bfree+0x2c>
   2fa0e:	6a73      	ldr	r3, [r6, #36]	; 0x24
   2fa10:	686a      	ldr	r2, [r5, #4]
   2fa12:	68db      	ldr	r3, [r3, #12]
   2fa14:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   2fa18:	6029      	str	r1, [r5, #0]
   2fa1a:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
   2fa1e:	bd70      	pop	{r4, r5, r6, pc}

0002fa20 <__multadd>:
   2fa20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2fa24:	f101 0c14 	add.w	ip, r1, #20
   2fa28:	461f      	mov	r7, r3
   2fa2a:	4606      	mov	r6, r0
   2fa2c:	460c      	mov	r4, r1
   2fa2e:	690d      	ldr	r5, [r1, #16]
   2fa30:	2300      	movs	r3, #0
   2fa32:	f8dc 0000 	ldr.w	r0, [ip]
   2fa36:	3301      	adds	r3, #1
   2fa38:	b281      	uxth	r1, r0
   2fa3a:	429d      	cmp	r5, r3
   2fa3c:	ea4f 4010 	mov.w	r0, r0, lsr #16
   2fa40:	fb02 7101 	mla	r1, r2, r1, r7
   2fa44:	ea4f 4711 	mov.w	r7, r1, lsr #16
   2fa48:	b289      	uxth	r1, r1
   2fa4a:	fb02 7000 	mla	r0, r2, r0, r7
   2fa4e:	eb01 4100 	add.w	r1, r1, r0, lsl #16
   2fa52:	ea4f 4710 	mov.w	r7, r0, lsr #16
   2fa56:	f84c 1b04 	str.w	r1, [ip], #4
   2fa5a:	dcea      	bgt.n	2fa32 <__multadd+0x12>
   2fa5c:	b1d7      	cbz	r7, 2fa94 <__multadd+0x74>
   2fa5e:	68a3      	ldr	r3, [r4, #8]
   2fa60:	42ab      	cmp	r3, r5
   2fa62:	dc12      	bgt.n	2fa8a <__multadd+0x6a>
   2fa64:	6861      	ldr	r1, [r4, #4]
   2fa66:	4630      	mov	r0, r6
   2fa68:	3101      	adds	r1, #1
   2fa6a:	f7ff ff8e 	bl	2f98a <_Balloc>
   2fa6e:	6922      	ldr	r2, [r4, #16]
   2fa70:	4680      	mov	r8, r0
   2fa72:	f104 010c 	add.w	r1, r4, #12
   2fa76:	3202      	adds	r2, #2
   2fa78:	300c      	adds	r0, #12
   2fa7a:	0092      	lsls	r2, r2, #2
   2fa7c:	f7ff fc6a 	bl	2f354 <memcpy>
   2fa80:	4621      	mov	r1, r4
   2fa82:	4644      	mov	r4, r8
   2fa84:	4630      	mov	r0, r6
   2fa86:	f7ff ffb4 	bl	2f9f2 <_Bfree>
   2fa8a:	eb04 0385 	add.w	r3, r4, r5, lsl #2
   2fa8e:	3501      	adds	r5, #1
   2fa90:	615f      	str	r7, [r3, #20]
   2fa92:	6125      	str	r5, [r4, #16]
   2fa94:	4620      	mov	r0, r4
   2fa96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002fa9a <__hi0bits>:
   2fa9a:	0c02      	lsrs	r2, r0, #16
   2fa9c:	4603      	mov	r3, r0
   2fa9e:	0412      	lsls	r2, r2, #16
   2faa0:	b9ca      	cbnz	r2, 2fad6 <__hi0bits+0x3c>
   2faa2:	0403      	lsls	r3, r0, #16
   2faa4:	2010      	movs	r0, #16
   2faa6:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
   2faaa:	bf04      	itt	eq
   2faac:	021b      	lsleq	r3, r3, #8
   2faae:	3008      	addeq	r0, #8
   2fab0:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
   2fab4:	bf04      	itt	eq
   2fab6:	011b      	lsleq	r3, r3, #4
   2fab8:	3004      	addeq	r0, #4
   2faba:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
   2fabe:	bf04      	itt	eq
   2fac0:	009b      	lsleq	r3, r3, #2
   2fac2:	3002      	addeq	r0, #2
   2fac4:	2b00      	cmp	r3, #0
   2fac6:	db05      	blt.n	2fad4 <__hi0bits+0x3a>
   2fac8:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
   2facc:	f100 0001 	add.w	r0, r0, #1
   2fad0:	bf08      	it	eq
   2fad2:	2020      	moveq	r0, #32
   2fad4:	4770      	bx	lr
   2fad6:	2000      	movs	r0, #0
   2fad8:	e7e5      	b.n	2faa6 <__hi0bits+0xc>

0002fada <__lo0bits>:
   2fada:	6803      	ldr	r3, [r0, #0]
   2fadc:	4601      	mov	r1, r0
   2fade:	f013 0207 	ands.w	r2, r3, #7
   2fae2:	d00b      	beq.n	2fafc <__lo0bits+0x22>
   2fae4:	07da      	lsls	r2, r3, #31
   2fae6:	d424      	bmi.n	2fb32 <__lo0bits+0x58>
   2fae8:	0798      	lsls	r0, r3, #30
   2faea:	bf47      	ittee	mi
   2faec:	085b      	lsrmi	r3, r3, #1
   2faee:	2001      	movmi	r0, #1
   2faf0:	089b      	lsrpl	r3, r3, #2
   2faf2:	2002      	movpl	r0, #2
   2faf4:	bf4c      	ite	mi
   2faf6:	600b      	strmi	r3, [r1, #0]
   2faf8:	600b      	strpl	r3, [r1, #0]
   2fafa:	4770      	bx	lr
   2fafc:	b298      	uxth	r0, r3
   2fafe:	b9b0      	cbnz	r0, 2fb2e <__lo0bits+0x54>
   2fb00:	0c1b      	lsrs	r3, r3, #16
   2fb02:	2010      	movs	r0, #16
   2fb04:	f013 0fff 	tst.w	r3, #255	; 0xff
   2fb08:	bf04      	itt	eq
   2fb0a:	0a1b      	lsreq	r3, r3, #8
   2fb0c:	3008      	addeq	r0, #8
   2fb0e:	071a      	lsls	r2, r3, #28
   2fb10:	bf04      	itt	eq
   2fb12:	091b      	lsreq	r3, r3, #4
   2fb14:	3004      	addeq	r0, #4
   2fb16:	079a      	lsls	r2, r3, #30
   2fb18:	bf04      	itt	eq
   2fb1a:	089b      	lsreq	r3, r3, #2
   2fb1c:	3002      	addeq	r0, #2
   2fb1e:	07da      	lsls	r2, r3, #31
   2fb20:	d403      	bmi.n	2fb2a <__lo0bits+0x50>
   2fb22:	085b      	lsrs	r3, r3, #1
   2fb24:	f100 0001 	add.w	r0, r0, #1
   2fb28:	d005      	beq.n	2fb36 <__lo0bits+0x5c>
   2fb2a:	600b      	str	r3, [r1, #0]
   2fb2c:	4770      	bx	lr
   2fb2e:	4610      	mov	r0, r2
   2fb30:	e7e8      	b.n	2fb04 <__lo0bits+0x2a>
   2fb32:	2000      	movs	r0, #0
   2fb34:	4770      	bx	lr
   2fb36:	2020      	movs	r0, #32
   2fb38:	4770      	bx	lr

0002fb3a <__i2b>:
   2fb3a:	b510      	push	{r4, lr}
   2fb3c:	460c      	mov	r4, r1
   2fb3e:	2101      	movs	r1, #1
   2fb40:	f7ff ff23 	bl	2f98a <_Balloc>
   2fb44:	2201      	movs	r2, #1
   2fb46:	6144      	str	r4, [r0, #20]
   2fb48:	6102      	str	r2, [r0, #16]
   2fb4a:	bd10      	pop	{r4, pc}

0002fb4c <__multiply>:
   2fb4c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2fb50:	4690      	mov	r8, r2
   2fb52:	690a      	ldr	r2, [r1, #16]
   2fb54:	460c      	mov	r4, r1
   2fb56:	f8d8 3010 	ldr.w	r3, [r8, #16]
   2fb5a:	429a      	cmp	r2, r3
   2fb5c:	bfbe      	ittt	lt
   2fb5e:	460b      	movlt	r3, r1
   2fb60:	4644      	movlt	r4, r8
   2fb62:	4698      	movlt	r8, r3
   2fb64:	6927      	ldr	r7, [r4, #16]
   2fb66:	68a3      	ldr	r3, [r4, #8]
   2fb68:	f8d8 9010 	ldr.w	r9, [r8, #16]
   2fb6c:	6861      	ldr	r1, [r4, #4]
   2fb6e:	eb07 0609 	add.w	r6, r7, r9
   2fb72:	42b3      	cmp	r3, r6
   2fb74:	bfb8      	it	lt
   2fb76:	3101      	addlt	r1, #1
   2fb78:	f7ff ff07 	bl	2f98a <_Balloc>
   2fb7c:	f100 0514 	add.w	r5, r0, #20
   2fb80:	2200      	movs	r2, #0
   2fb82:	eb05 0e86 	add.w	lr, r5, r6, lsl #2
   2fb86:	462b      	mov	r3, r5
   2fb88:	4573      	cmp	r3, lr
   2fb8a:	d316      	bcc.n	2fbba <__multiply+0x6e>
   2fb8c:	f104 0314 	add.w	r3, r4, #20
   2fb90:	f108 0214 	add.w	r2, r8, #20
   2fb94:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   2fb98:	eb02 0389 	add.w	r3, r2, r9, lsl #2
   2fb9c:	9300      	str	r3, [sp, #0]
   2fb9e:	9b00      	ldr	r3, [sp, #0]
   2fba0:	9201      	str	r2, [sp, #4]
   2fba2:	4293      	cmp	r3, r2
   2fba4:	d80c      	bhi.n	2fbc0 <__multiply+0x74>
   2fba6:	2e00      	cmp	r6, #0
   2fba8:	dd03      	ble.n	2fbb2 <__multiply+0x66>
   2fbaa:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
   2fbae:	2b00      	cmp	r3, #0
   2fbb0:	d059      	beq.n	2fc66 <__multiply+0x11a>
   2fbb2:	6106      	str	r6, [r0, #16]
   2fbb4:	b003      	add	sp, #12
   2fbb6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2fbba:	f843 2b04 	str.w	r2, [r3], #4
   2fbbe:	e7e3      	b.n	2fb88 <__multiply+0x3c>
   2fbc0:	f8b2 a000 	ldrh.w	sl, [r2]
   2fbc4:	f1ba 0f00 	cmp.w	sl, #0
   2fbc8:	d023      	beq.n	2fc12 <__multiply+0xc6>
   2fbca:	f104 0914 	add.w	r9, r4, #20
   2fbce:	46ac      	mov	ip, r5
   2fbd0:	f04f 0800 	mov.w	r8, #0
   2fbd4:	f859 1b04 	ldr.w	r1, [r9], #4
   2fbd8:	f8dc b000 	ldr.w	fp, [ip]
   2fbdc:	b28b      	uxth	r3, r1
   2fbde:	454f      	cmp	r7, r9
   2fbe0:	fa1f fb8b 	uxth.w	fp, fp
   2fbe4:	fb0a b303 	mla	r3, sl, r3, fp
   2fbe8:	ea4f 4b11 	mov.w	fp, r1, lsr #16
   2fbec:	f8dc 1000 	ldr.w	r1, [ip]
   2fbf0:	4443      	add	r3, r8
   2fbf2:	ea4f 4811 	mov.w	r8, r1, lsr #16
   2fbf6:	fb0a 810b 	mla	r1, sl, fp, r8
   2fbfa:	eb01 4113 	add.w	r1, r1, r3, lsr #16
   2fbfe:	b29b      	uxth	r3, r3
   2fc00:	ea4f 4811 	mov.w	r8, r1, lsr #16
   2fc04:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   2fc08:	f84c 3b04 	str.w	r3, [ip], #4
   2fc0c:	d8e2      	bhi.n	2fbd4 <__multiply+0x88>
   2fc0e:	f8cc 8000 	str.w	r8, [ip]
   2fc12:	9b01      	ldr	r3, [sp, #4]
   2fc14:	3204      	adds	r2, #4
   2fc16:	f8b3 9002 	ldrh.w	r9, [r3, #2]
   2fc1a:	f1b9 0f00 	cmp.w	r9, #0
   2fc1e:	d020      	beq.n	2fc62 <__multiply+0x116>
   2fc20:	682b      	ldr	r3, [r5, #0]
   2fc22:	f104 0814 	add.w	r8, r4, #20
   2fc26:	46ac      	mov	ip, r5
   2fc28:	f04f 0a00 	mov.w	sl, #0
   2fc2c:	f8b8 1000 	ldrh.w	r1, [r8]
   2fc30:	b29b      	uxth	r3, r3
   2fc32:	f8bc b002 	ldrh.w	fp, [ip, #2]
   2fc36:	fb09 b101 	mla	r1, r9, r1, fp
   2fc3a:	448a      	add	sl, r1
   2fc3c:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
   2fc40:	f84c 3b04 	str.w	r3, [ip], #4
   2fc44:	f858 3b04 	ldr.w	r3, [r8], #4
   2fc48:	f8bc 1000 	ldrh.w	r1, [ip]
   2fc4c:	0c1b      	lsrs	r3, r3, #16
   2fc4e:	4547      	cmp	r7, r8
   2fc50:	fb09 1303 	mla	r3, r9, r3, r1
   2fc54:	eb03 431a 	add.w	r3, r3, sl, lsr #16
   2fc58:	ea4f 4a13 	mov.w	sl, r3, lsr #16
   2fc5c:	d8e6      	bhi.n	2fc2c <__multiply+0xe0>
   2fc5e:	f8cc 3000 	str.w	r3, [ip]
   2fc62:	3504      	adds	r5, #4
   2fc64:	e79b      	b.n	2fb9e <__multiply+0x52>
   2fc66:	3e01      	subs	r6, #1
   2fc68:	e79d      	b.n	2fba6 <__multiply+0x5a>

0002fc6a <__lshift>:
   2fc6a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2fc6e:	460c      	mov	r4, r1
   2fc70:	ea4f 1a62 	mov.w	sl, r2, asr #5
   2fc74:	4607      	mov	r7, r0
   2fc76:	4616      	mov	r6, r2
   2fc78:	6923      	ldr	r3, [r4, #16]
   2fc7a:	6849      	ldr	r1, [r1, #4]
   2fc7c:	eb0a 0903 	add.w	r9, sl, r3
   2fc80:	68a3      	ldr	r3, [r4, #8]
   2fc82:	f109 0501 	add.w	r5, r9, #1
   2fc86:	42ab      	cmp	r3, r5
   2fc88:	db33      	blt.n	2fcf2 <__lshift+0x88>
   2fc8a:	4638      	mov	r0, r7
   2fc8c:	f7ff fe7d 	bl	2f98a <_Balloc>
   2fc90:	2300      	movs	r3, #0
   2fc92:	4680      	mov	r8, r0
   2fc94:	f100 0114 	add.w	r1, r0, #20
   2fc98:	f100 0210 	add.w	r2, r0, #16
   2fc9c:	4618      	mov	r0, r3
   2fc9e:	4553      	cmp	r3, sl
   2fca0:	db2a      	blt.n	2fcf8 <__lshift+0x8e>
   2fca2:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
   2fca6:	f104 0314 	add.w	r3, r4, #20
   2fcaa:	6920      	ldr	r0, [r4, #16]
   2fcac:	f016 021f 	ands.w	r2, r6, #31
   2fcb0:	eb01 018a 	add.w	r1, r1, sl, lsl #2
   2fcb4:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   2fcb8:	d022      	beq.n	2fd00 <__lshift+0x96>
   2fcba:	f1c2 0e20 	rsb	lr, r2, #32
   2fcbe:	2000      	movs	r0, #0
   2fcc0:	681e      	ldr	r6, [r3, #0]
   2fcc2:	4096      	lsls	r6, r2
   2fcc4:	4330      	orrs	r0, r6
   2fcc6:	f841 0b04 	str.w	r0, [r1], #4
   2fcca:	f853 0b04 	ldr.w	r0, [r3], #4
   2fcce:	459c      	cmp	ip, r3
   2fcd0:	fa20 f00e 	lsr.w	r0, r0, lr
   2fcd4:	d8f4      	bhi.n	2fcc0 <__lshift+0x56>
   2fcd6:	6008      	str	r0, [r1, #0]
   2fcd8:	b108      	cbz	r0, 2fcde <__lshift+0x74>
   2fcda:	f109 0502 	add.w	r5, r9, #2
   2fcde:	3d01      	subs	r5, #1
   2fce0:	4638      	mov	r0, r7
   2fce2:	4621      	mov	r1, r4
   2fce4:	f8c8 5010 	str.w	r5, [r8, #16]
   2fce8:	f7ff fe83 	bl	2f9f2 <_Bfree>
   2fcec:	4640      	mov	r0, r8
   2fcee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2fcf2:	3101      	adds	r1, #1
   2fcf4:	005b      	lsls	r3, r3, #1
   2fcf6:	e7c6      	b.n	2fc86 <__lshift+0x1c>
   2fcf8:	f842 0f04 	str.w	r0, [r2, #4]!
   2fcfc:	3301      	adds	r3, #1
   2fcfe:	e7ce      	b.n	2fc9e <__lshift+0x34>
   2fd00:	3904      	subs	r1, #4
   2fd02:	f853 2b04 	ldr.w	r2, [r3], #4
   2fd06:	459c      	cmp	ip, r3
   2fd08:	f841 2f04 	str.w	r2, [r1, #4]!
   2fd0c:	d8f9      	bhi.n	2fd02 <__lshift+0x98>
   2fd0e:	e7e6      	b.n	2fcde <__lshift+0x74>

0002fd10 <__mcmp>:
   2fd10:	6903      	ldr	r3, [r0, #16]
   2fd12:	690a      	ldr	r2, [r1, #16]
   2fd14:	1a9b      	subs	r3, r3, r2
   2fd16:	b530      	push	{r4, r5, lr}
   2fd18:	d10c      	bne.n	2fd34 <__mcmp+0x24>
   2fd1a:	0092      	lsls	r2, r2, #2
   2fd1c:	3014      	adds	r0, #20
   2fd1e:	3114      	adds	r1, #20
   2fd20:	1884      	adds	r4, r0, r2
   2fd22:	4411      	add	r1, r2
   2fd24:	f854 5d04 	ldr.w	r5, [r4, #-4]!
   2fd28:	f851 2d04 	ldr.w	r2, [r1, #-4]!
   2fd2c:	4295      	cmp	r5, r2
   2fd2e:	d003      	beq.n	2fd38 <__mcmp+0x28>
   2fd30:	d305      	bcc.n	2fd3e <__mcmp+0x2e>
   2fd32:	2301      	movs	r3, #1
   2fd34:	4618      	mov	r0, r3
   2fd36:	bd30      	pop	{r4, r5, pc}
   2fd38:	42a0      	cmp	r0, r4
   2fd3a:	d3f3      	bcc.n	2fd24 <__mcmp+0x14>
   2fd3c:	e7fa      	b.n	2fd34 <__mcmp+0x24>
   2fd3e:	f04f 33ff 	mov.w	r3, #4294967295
   2fd42:	e7f7      	b.n	2fd34 <__mcmp+0x24>

0002fd44 <__mdiff>:
   2fd44:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2fd48:	460d      	mov	r5, r1
   2fd4a:	4607      	mov	r7, r0
   2fd4c:	4611      	mov	r1, r2
   2fd4e:	4614      	mov	r4, r2
   2fd50:	4628      	mov	r0, r5
   2fd52:	f7ff ffdd 	bl	2fd10 <__mcmp>
   2fd56:	1e06      	subs	r6, r0, #0
   2fd58:	d108      	bne.n	2fd6c <__mdiff+0x28>
   2fd5a:	4631      	mov	r1, r6
   2fd5c:	4638      	mov	r0, r7
   2fd5e:	f7ff fe14 	bl	2f98a <_Balloc>
   2fd62:	2301      	movs	r3, #1
   2fd64:	e9c0 3604 	strd	r3, r6, [r0, #16]
   2fd68:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2fd6c:	bfa3      	ittte	ge
   2fd6e:	4623      	movge	r3, r4
   2fd70:	462c      	movge	r4, r5
   2fd72:	2600      	movge	r6, #0
   2fd74:	2601      	movlt	r6, #1
   2fd76:	bfa8      	it	ge
   2fd78:	461d      	movge	r5, r3
   2fd7a:	6861      	ldr	r1, [r4, #4]
   2fd7c:	4638      	mov	r0, r7
   2fd7e:	f7ff fe04 	bl	2f98a <_Balloc>
   2fd82:	f105 0914 	add.w	r9, r5, #20
   2fd86:	60c6      	str	r6, [r0, #12]
   2fd88:	f104 0214 	add.w	r2, r4, #20
   2fd8c:	6926      	ldr	r6, [r4, #16]
   2fd8e:	f100 0114 	add.w	r1, r0, #20
   2fd92:	692b      	ldr	r3, [r5, #16]
   2fd94:	f04f 0e00 	mov.w	lr, #0
   2fd98:	eb02 0786 	add.w	r7, r2, r6, lsl #2
   2fd9c:	eb09 0883 	add.w	r8, r9, r3, lsl #2
   2fda0:	f852 ab04 	ldr.w	sl, [r2], #4
   2fda4:	f859 5b04 	ldr.w	r5, [r9], #4
   2fda8:	fa1f f38a 	uxth.w	r3, sl
   2fdac:	4694      	mov	ip, r2
   2fdae:	b2ac      	uxth	r4, r5
   2fdb0:	45c8      	cmp	r8, r9
   2fdb2:	4473      	add	r3, lr
   2fdb4:	eba3 0304 	sub.w	r3, r3, r4
   2fdb8:	ea4f 4415 	mov.w	r4, r5, lsr #16
   2fdbc:	ebc4 441a 	rsb	r4, r4, sl, lsr #16
   2fdc0:	eb04 4423 	add.w	r4, r4, r3, asr #16
   2fdc4:	b29b      	uxth	r3, r3
   2fdc6:	ea4f 4e24 	mov.w	lr, r4, asr #16
   2fdca:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
   2fdce:	f841 4b04 	str.w	r4, [r1], #4
   2fdd2:	d8e5      	bhi.n	2fda0 <__mdiff+0x5c>
   2fdd4:	45bc      	cmp	ip, r7
   2fdd6:	d304      	bcc.n	2fde2 <__mdiff+0x9e>
   2fdd8:	f851 3d04 	ldr.w	r3, [r1, #-4]!
   2fddc:	b183      	cbz	r3, 2fe00 <__mdiff+0xbc>
   2fdde:	6106      	str	r6, [r0, #16]
   2fde0:	e7c2      	b.n	2fd68 <__mdiff+0x24>
   2fde2:	f85c 4b04 	ldr.w	r4, [ip], #4
   2fde6:	b2a2      	uxth	r2, r4
   2fde8:	4472      	add	r2, lr
   2fdea:	1413      	asrs	r3, r2, #16
   2fdec:	b292      	uxth	r2, r2
   2fdee:	eb03 4314 	add.w	r3, r3, r4, lsr #16
   2fdf2:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
   2fdf6:	ea4f 4e23 	mov.w	lr, r3, asr #16
   2fdfa:	f841 2b04 	str.w	r2, [r1], #4
   2fdfe:	e7e9      	b.n	2fdd4 <__mdiff+0x90>
   2fe00:	3e01      	subs	r6, #1
   2fe02:	e7e9      	b.n	2fdd8 <__mdiff+0x94>

0002fe04 <__d2b>:
   2fe04:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   2fe08:	ec59 8b10 	vmov	r8, r9, d0
   2fe0c:	f3c9 540a 	ubfx	r4, r9, #20, #11
   2fe10:	460e      	mov	r6, r1
   2fe12:	2101      	movs	r1, #1
   2fe14:	4615      	mov	r5, r2
   2fe16:	f7ff fdb8 	bl	2f98a <_Balloc>
   2fe1a:	f3c9 0313 	ubfx	r3, r9, #0, #20
   2fe1e:	4607      	mov	r7, r0
   2fe20:	bb2c      	cbnz	r4, 2fe6e <__d2b+0x6a>
   2fe22:	9301      	str	r3, [sp, #4]
   2fe24:	f1b8 0300 	subs.w	r3, r8, #0
   2fe28:	d026      	beq.n	2fe78 <__d2b+0x74>
   2fe2a:	4668      	mov	r0, sp
   2fe2c:	9300      	str	r3, [sp, #0]
   2fe2e:	f7ff fe54 	bl	2fada <__lo0bits>
   2fe32:	9900      	ldr	r1, [sp, #0]
   2fe34:	b1f0      	cbz	r0, 2fe74 <__d2b+0x70>
   2fe36:	9a01      	ldr	r2, [sp, #4]
   2fe38:	f1c0 0320 	rsb	r3, r0, #32
   2fe3c:	fa02 f303 	lsl.w	r3, r2, r3
   2fe40:	40c2      	lsrs	r2, r0
   2fe42:	430b      	orrs	r3, r1
   2fe44:	9201      	str	r2, [sp, #4]
   2fe46:	617b      	str	r3, [r7, #20]
   2fe48:	9b01      	ldr	r3, [sp, #4]
   2fe4a:	2b00      	cmp	r3, #0
   2fe4c:	61bb      	str	r3, [r7, #24]
   2fe4e:	bf14      	ite	ne
   2fe50:	2102      	movne	r1, #2
   2fe52:	2101      	moveq	r1, #1
   2fe54:	6139      	str	r1, [r7, #16]
   2fe56:	b1c4      	cbz	r4, 2fe8a <__d2b+0x86>
   2fe58:	f2a4 4433 	subw	r4, r4, #1075	; 0x433
   2fe5c:	4404      	add	r4, r0
   2fe5e:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
   2fe62:	6034      	str	r4, [r6, #0]
   2fe64:	6028      	str	r0, [r5, #0]
   2fe66:	4638      	mov	r0, r7
   2fe68:	b003      	add	sp, #12
   2fe6a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2fe6e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   2fe72:	e7d6      	b.n	2fe22 <__d2b+0x1e>
   2fe74:	6179      	str	r1, [r7, #20]
   2fe76:	e7e7      	b.n	2fe48 <__d2b+0x44>
   2fe78:	a801      	add	r0, sp, #4
   2fe7a:	f7ff fe2e 	bl	2fada <__lo0bits>
   2fe7e:	9b01      	ldr	r3, [sp, #4]
   2fe80:	2101      	movs	r1, #1
   2fe82:	3020      	adds	r0, #32
   2fe84:	617b      	str	r3, [r7, #20]
   2fe86:	6139      	str	r1, [r7, #16]
   2fe88:	e7e5      	b.n	2fe56 <__d2b+0x52>
   2fe8a:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
   2fe8e:	eb07 0381 	add.w	r3, r7, r1, lsl #2
   2fe92:	6030      	str	r0, [r6, #0]
   2fe94:	6918      	ldr	r0, [r3, #16]
   2fe96:	f7ff fe00 	bl	2fa9a <__hi0bits>
   2fe9a:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
   2fe9e:	e7e1      	b.n	2fe64 <__d2b+0x60>

0002fea0 <_calloc_r>:
   2fea0:	b538      	push	{r3, r4, r5, lr}
   2fea2:	fb02 f401 	mul.w	r4, r2, r1
   2fea6:	4621      	mov	r1, r4
   2fea8:	f7fb f8aa 	bl	2b000 <_malloc_r>
   2feac:	4605      	mov	r5, r0
   2feae:	b118      	cbz	r0, 2feb8 <_calloc_r+0x18>
   2feb0:	4622      	mov	r2, r4
   2feb2:	2100      	movs	r1, #0
   2feb4:	f7ff fa6e 	bl	2f394 <memset>
   2feb8:	4628      	mov	r0, r5
   2feba:	bd38      	pop	{r3, r4, r5, pc}

0002febc <_realloc_r>:
   2febc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2febe:	4607      	mov	r7, r0
   2fec0:	4614      	mov	r4, r2
   2fec2:	460e      	mov	r6, r1
   2fec4:	b921      	cbnz	r1, 2fed0 <_realloc_r+0x14>
   2fec6:	4611      	mov	r1, r2
   2fec8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   2fecc:	f7fb b898 	b.w	2b000 <_malloc_r>
   2fed0:	b922      	cbnz	r2, 2fedc <_realloc_r+0x20>
   2fed2:	4625      	mov	r5, r4
   2fed4:	f7fb f846 	bl	2af64 <_free_r>
   2fed8:	4628      	mov	r0, r5
   2feda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2fedc:	f000 f8ee 	bl	300bc <_malloc_usable_size_r>
   2fee0:	42a0      	cmp	r0, r4
   2fee2:	d20f      	bcs.n	2ff04 <_realloc_r+0x48>
   2fee4:	4621      	mov	r1, r4
   2fee6:	4638      	mov	r0, r7
   2fee8:	f7fb f88a 	bl	2b000 <_malloc_r>
   2feec:	4605      	mov	r5, r0
   2feee:	2800      	cmp	r0, #0
   2fef0:	d0f2      	beq.n	2fed8 <_realloc_r+0x1c>
   2fef2:	4631      	mov	r1, r6
   2fef4:	4622      	mov	r2, r4
   2fef6:	f7ff fa2d 	bl	2f354 <memcpy>
   2fefa:	4631      	mov	r1, r6
   2fefc:	4638      	mov	r0, r7
   2fefe:	f7fb f831 	bl	2af64 <_free_r>
   2ff02:	e7e9      	b.n	2fed8 <_realloc_r+0x1c>
   2ff04:	4635      	mov	r5, r6
   2ff06:	e7e7      	b.n	2fed8 <_realloc_r+0x1c>

0002ff08 <__ssputs_r>:
   2ff08:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2ff0c:	688e      	ldr	r6, [r1, #8]
   2ff0e:	4682      	mov	sl, r0
   2ff10:	460c      	mov	r4, r1
   2ff12:	4691      	mov	r9, r2
   2ff14:	429e      	cmp	r6, r3
   2ff16:	4698      	mov	r8, r3
   2ff18:	d838      	bhi.n	2ff8c <__ssputs_r+0x84>
   2ff1a:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
   2ff1e:	f41c 6f90 	tst.w	ip, #1152	; 0x480
   2ff22:	d031      	beq.n	2ff88 <__ssputs_r+0x80>
   2ff24:	6962      	ldr	r2, [r4, #20]
   2ff26:	3301      	adds	r3, #1
   2ff28:	6825      	ldr	r5, [r4, #0]
   2ff2a:	6909      	ldr	r1, [r1, #16]
   2ff2c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   2ff30:	1a6f      	subs	r7, r5, r1
   2ff32:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   2ff36:	443b      	add	r3, r7
   2ff38:	1055      	asrs	r5, r2, #1
   2ff3a:	429d      	cmp	r5, r3
   2ff3c:	bf38      	it	cc
   2ff3e:	461d      	movcc	r5, r3
   2ff40:	f41c 6f80 	tst.w	ip, #1024	; 0x400
   2ff44:	d030      	beq.n	2ffa8 <__ssputs_r+0xa0>
   2ff46:	4629      	mov	r1, r5
   2ff48:	f7fb f85a 	bl	2b000 <_malloc_r>
   2ff4c:	4606      	mov	r6, r0
   2ff4e:	b950      	cbnz	r0, 2ff66 <__ssputs_r+0x5e>
   2ff50:	230c      	movs	r3, #12
   2ff52:	f04f 30ff 	mov.w	r0, #4294967295
   2ff56:	f8ca 3000 	str.w	r3, [sl]
   2ff5a:	89a3      	ldrh	r3, [r4, #12]
   2ff5c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   2ff60:	81a3      	strh	r3, [r4, #12]
   2ff62:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2ff66:	463a      	mov	r2, r7
   2ff68:	6921      	ldr	r1, [r4, #16]
   2ff6a:	f7ff f9f3 	bl	2f354 <memcpy>
   2ff6e:	89a3      	ldrh	r3, [r4, #12]
   2ff70:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   2ff74:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   2ff78:	81a3      	strh	r3, [r4, #12]
   2ff7a:	6126      	str	r6, [r4, #16]
   2ff7c:	443e      	add	r6, r7
   2ff7e:	6165      	str	r5, [r4, #20]
   2ff80:	1bed      	subs	r5, r5, r7
   2ff82:	6026      	str	r6, [r4, #0]
   2ff84:	4646      	mov	r6, r8
   2ff86:	60a5      	str	r5, [r4, #8]
   2ff88:	4546      	cmp	r6, r8
   2ff8a:	d900      	bls.n	2ff8e <__ssputs_r+0x86>
   2ff8c:	4646      	mov	r6, r8
   2ff8e:	4632      	mov	r2, r6
   2ff90:	4649      	mov	r1, r9
   2ff92:	6820      	ldr	r0, [r4, #0]
   2ff94:	f7ff fcdf 	bl	2f956 <memmove>
   2ff98:	68a3      	ldr	r3, [r4, #8]
   2ff9a:	2000      	movs	r0, #0
   2ff9c:	1b9b      	subs	r3, r3, r6
   2ff9e:	60a3      	str	r3, [r4, #8]
   2ffa0:	6823      	ldr	r3, [r4, #0]
   2ffa2:	441e      	add	r6, r3
   2ffa4:	6026      	str	r6, [r4, #0]
   2ffa6:	e7dc      	b.n	2ff62 <__ssputs_r+0x5a>
   2ffa8:	462a      	mov	r2, r5
   2ffaa:	f7ff ff87 	bl	2febc <_realloc_r>
   2ffae:	4606      	mov	r6, r0
   2ffb0:	2800      	cmp	r0, #0
   2ffb2:	d1e2      	bne.n	2ff7a <__ssputs_r+0x72>
   2ffb4:	6921      	ldr	r1, [r4, #16]
   2ffb6:	4650      	mov	r0, sl
   2ffb8:	f7fa ffd4 	bl	2af64 <_free_r>
   2ffbc:	e7c8      	b.n	2ff50 <__ssputs_r+0x48>

0002ffbe <_raise_r>:
   2ffbe:	291f      	cmp	r1, #31
   2ffc0:	b538      	push	{r3, r4, r5, lr}
   2ffc2:	4604      	mov	r4, r0
   2ffc4:	460d      	mov	r5, r1
   2ffc6:	d904      	bls.n	2ffd2 <_raise_r+0x14>
   2ffc8:	2316      	movs	r3, #22
   2ffca:	6003      	str	r3, [r0, #0]
   2ffcc:	f04f 30ff 	mov.w	r0, #4294967295
   2ffd0:	bd38      	pop	{r3, r4, r5, pc}
   2ffd2:	6c42      	ldr	r2, [r0, #68]	; 0x44
   2ffd4:	b112      	cbz	r2, 2ffdc <_raise_r+0x1e>
   2ffd6:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   2ffda:	b94b      	cbnz	r3, 2fff0 <_raise_r+0x32>
   2ffdc:	4620      	mov	r0, r4
   2ffde:	f000 f816 	bl	3000e <_getpid_r>
   2ffe2:	462a      	mov	r2, r5
   2ffe4:	4601      	mov	r1, r0
   2ffe6:	4620      	mov	r0, r4
   2ffe8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2ffec:	f7fb b972 	b.w	2b2d4 <_kill_r>
   2fff0:	2b01      	cmp	r3, #1
   2fff2:	d00a      	beq.n	3000a <_raise_r+0x4c>
   2fff4:	1c59      	adds	r1, r3, #1
   2fff6:	d103      	bne.n	30000 <_raise_r+0x42>
   2fff8:	2316      	movs	r3, #22
   2fffa:	6003      	str	r3, [r0, #0]
   2fffc:	2001      	movs	r0, #1
   2fffe:	e7e7      	b.n	2ffd0 <_raise_r+0x12>
   30000:	2400      	movs	r4, #0
   30002:	4628      	mov	r0, r5
   30004:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
   30008:	4798      	blx	r3
   3000a:	2000      	movs	r0, #0
   3000c:	e7e0      	b.n	2ffd0 <_raise_r+0x12>

0003000e <_getpid_r>:
   3000e:	f7fd bb10 	b.w	2d632 <_getpid>

00030012 <__sread>:
   30012:	b510      	push	{r4, lr}
   30014:	460c      	mov	r4, r1
   30016:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   3001a:	f7fb f9cf 	bl	2b3bc <_read_r>
   3001e:	2800      	cmp	r0, #0
   30020:	bfab      	itete	ge
   30022:	6d63      	ldrge	r3, [r4, #84]	; 0x54
   30024:	89a3      	ldrhlt	r3, [r4, #12]
   30026:	181b      	addge	r3, r3, r0
   30028:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
   3002c:	bfac      	ite	ge
   3002e:	6563      	strge	r3, [r4, #84]	; 0x54
   30030:	81a3      	strhlt	r3, [r4, #12]
   30032:	bd10      	pop	{r4, pc}

00030034 <__swrite>:
   30034:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   30038:	461f      	mov	r7, r3
   3003a:	898b      	ldrh	r3, [r1, #12]
   3003c:	4605      	mov	r5, r0
   3003e:	460c      	mov	r4, r1
   30040:	05db      	lsls	r3, r3, #23
   30042:	4616      	mov	r6, r2
   30044:	d505      	bpl.n	30052 <__swrite+0x1e>
   30046:	2302      	movs	r3, #2
   30048:	2200      	movs	r2, #0
   3004a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   3004e:	f7fb f997 	bl	2b380 <_lseek_r>
   30052:	89a3      	ldrh	r3, [r4, #12]
   30054:	4632      	mov	r2, r6
   30056:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   3005a:	4628      	mov	r0, r5
   3005c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   30060:	81a3      	strh	r3, [r4, #12]
   30062:	463b      	mov	r3, r7
   30064:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   30068:	f7fb b946 	b.w	2b2f8 <_write_r>

0003006c <__sseek>:
   3006c:	b510      	push	{r4, lr}
   3006e:	460c      	mov	r4, r1
   30070:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   30074:	f7fb f984 	bl	2b380 <_lseek_r>
   30078:	1c43      	adds	r3, r0, #1
   3007a:	89a3      	ldrh	r3, [r4, #12]
   3007c:	bf15      	itete	ne
   3007e:	6560      	strne	r0, [r4, #84]	; 0x54
   30080:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   30084:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
   30088:	81a3      	strheq	r3, [r4, #12]
   3008a:	bf18      	it	ne
   3008c:	81a3      	strhne	r3, [r4, #12]
   3008e:	bd10      	pop	{r4, pc}

00030090 <__sclose>:
   30090:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   30094:	f7fb b942 	b.w	2b31c <_close_r>

00030098 <__ascii_mbtowc>:
   30098:	b082      	sub	sp, #8
   3009a:	b901      	cbnz	r1, 3009e <__ascii_mbtowc+0x6>
   3009c:	a901      	add	r1, sp, #4
   3009e:	b142      	cbz	r2, 300b2 <__ascii_mbtowc+0x1a>
   300a0:	b14b      	cbz	r3, 300b6 <__ascii_mbtowc+0x1e>
   300a2:	7813      	ldrb	r3, [r2, #0]
   300a4:	600b      	str	r3, [r1, #0]
   300a6:	7812      	ldrb	r2, [r2, #0]
   300a8:	1c10      	adds	r0, r2, #0
   300aa:	bf18      	it	ne
   300ac:	2001      	movne	r0, #1
   300ae:	b002      	add	sp, #8
   300b0:	4770      	bx	lr
   300b2:	4610      	mov	r0, r2
   300b4:	e7fb      	b.n	300ae <__ascii_mbtowc+0x16>
   300b6:	f06f 0001 	mvn.w	r0, #1
   300ba:	e7f8      	b.n	300ae <__ascii_mbtowc+0x16>

000300bc <_malloc_usable_size_r>:
   300bc:	f851 3c04 	ldr.w	r3, [r1, #-4]
   300c0:	1f18      	subs	r0, r3, #4
   300c2:	2b00      	cmp	r3, #0
   300c4:	bfbc      	itt	lt
   300c6:	580b      	ldrlt	r3, [r1, r0]
   300c8:	18c0      	addlt	r0, r0, r3
   300ca:	4770      	bx	lr

000300cc <__ascii_wctomb>:
   300cc:	b149      	cbz	r1, 300e2 <__ascii_wctomb+0x16>
   300ce:	2aff      	cmp	r2, #255	; 0xff
   300d0:	bf8d      	iteet	hi
   300d2:	238a      	movhi	r3, #138	; 0x8a
   300d4:	700a      	strbls	r2, [r1, #0]
   300d6:	2001      	movls	r0, #1
   300d8:	6003      	strhi	r3, [r0, #0]
   300da:	bf88      	it	hi
   300dc:	f04f 30ff 	movhi.w	r0, #4294967295
   300e0:	4770      	bx	lr
   300e2:	4608      	mov	r0, r1
   300e4:	4770      	bx	lr
